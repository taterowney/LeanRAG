{"name":"ContinuousMap.IccExtendCM_of_mem","module":"Mathlib.Topology.ContinuousMap.Interval","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å¥ : LinearOrder Œ±\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : OrderTopology Œ±\na b : Œ±\ninst‚úù¬π : Fact (LE.le a b)\nE : Type u_2\ninst‚úù : TopologicalSpace E\nf : ContinuousMap (‚Üë(Set.Icc a b)) E\nx : Œ±\nhx : Membership.mem (Set.Icc a b) x\n‚ä¢ Eq ((ContinuousMap.IccExtendCM f) x) (f ‚ü®x, hx‚ü©)","decl":"@[simp]\ntheorem IccExtendCM_of_mem {f : C(Icc a b, E)} {x : Œ±} (hx : x ‚àà Icc a b) :\n    IccExtendCM f x = f ‚ü®x, hx‚ü© := by\n  simp [IccExtendCM, projIccCM, projIcc, hx.1, hx.2]\n\n"}
{"name":"ContinuousMap.concat_comp_IccInclusionLeft","module":"Mathlib.Topology.ContinuousMap.Interval","initialProofState":"Œ± : Type u_1\ninst‚úù‚Åµ : LinearOrder Œ±\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : OrderTopology Œ±\na b c : Œ±\ninst‚úù¬≤ : Fact (LE.le a b)\ninst‚úù¬π : Fact (LE.le b c)\nE : Type u_2\ninst‚úù : TopologicalSpace E\nf : ContinuousMap (‚Üë(Set.Icc a b)) E\ng : ContinuousMap (‚Üë(Set.Icc b c)) E\nhb : Eq (f Top.top) (g Bot.bot)\n‚ä¢ Eq ((f.concat g).comp ContinuousMap.IccInclusionLeft) f","decl":"theorem concat_comp_IccInclusionLeft (hb : f ‚ä§ = g ‚ä•) :\n    (concat f g).comp IccInclusionLeft = f := by\n  ext x\n  simp [concat, IccExtendCM, hb, IccInclusionLeft, projIccCM, inclusion, x.2.2]\n\n"}
{"name":"ContinuousMap.concat_comp_IccInclusionRight","module":"Mathlib.Topology.ContinuousMap.Interval","initialProofState":"Œ± : Type u_1\ninst‚úù‚Åµ : LinearOrder Œ±\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : OrderTopology Œ±\na b c : Œ±\ninst‚úù¬≤ : Fact (LE.le a b)\ninst‚úù¬π : Fact (LE.le b c)\nE : Type u_2\ninst‚úù : TopologicalSpace E\nf : ContinuousMap (‚Üë(Set.Icc a b)) E\ng : ContinuousMap (‚Üë(Set.Icc b c)) E\nhb : Eq (f Top.top) (g Bot.bot)\n‚ä¢ Eq ((f.concat g).comp ContinuousMap.IccInclusionRight) g","decl":"theorem concat_comp_IccInclusionRight (hb : f ‚ä§ = g ‚ä•) :\n    (concat f g).comp IccInclusionRight = g := by\n  ext ‚ü®x, hx‚ü©\n  obtain rfl | hxb := eq_or_ne x b\n  ¬∑ simpa [concat, IccInclusionRight, IccExtendCM, projIccCM, inclusion, hb]\n  ¬∑ have h : ¬¨ x ‚â§ b := lt_of_le_of_ne hx.1 (Ne.symm hxb) |>.not_le\n    simp [concat, hb, IccInclusionRight, h, IccExtendCM, projIccCM, projIcc, inclusion, hx.2, hx.1]\n\n"}
{"name":"ContinuousMap.concat_left","module":"Mathlib.Topology.ContinuousMap.Interval","initialProofState":"Œ± : Type u_1\ninst‚úù‚Åµ : LinearOrder Œ±\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : OrderTopology Œ±\na b c : Œ±\ninst‚úù¬≤ : Fact (LE.le a b)\ninst‚úù¬π : Fact (LE.le b c)\nE : Type u_2\ninst‚úù : TopologicalSpace E\nf : ContinuousMap (‚Üë(Set.Icc a b)) E\ng : ContinuousMap (‚Üë(Set.Icc b c)) E\nhb : Eq (f Top.top) (g Bot.bot)\nt : ‚Üë(Set.Icc a c)\nht : LE.le (‚Üët) b\n‚ä¢ Eq ((f.concat g) t) (f ‚ü®‚Üët, ‚ãØ‚ü©)","decl":"@[simp]\ntheorem concat_left (hb : f ‚ä§ = g ‚ä•) {t : Icc a c} (ht : t ‚â§ b) :\n    concat f g t = f ‚ü®t, t.2.1, ht‚ü© := by\n  nth_rewrite 2 [‚Üê concat_comp_IccInclusionLeft hb]\n  rfl\n\n"}
{"name":"ContinuousMap.concat_right","module":"Mathlib.Topology.ContinuousMap.Interval","initialProofState":"Œ± : Type u_1\ninst‚úù‚Åµ : LinearOrder Œ±\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : OrderTopology Œ±\na b c : Œ±\ninst‚úù¬≤ : Fact (LE.le a b)\ninst‚úù¬π : Fact (LE.le b c)\nE : Type u_2\ninst‚úù : TopologicalSpace E\nf : ContinuousMap (‚Üë(Set.Icc a b)) E\ng : ContinuousMap (‚Üë(Set.Icc b c)) E\nhb : Eq (f Top.top) (g Bot.bot)\nt : ‚Üë(Set.Icc a c)\nht : LE.le b ‚Üët\n‚ä¢ Eq ((f.concat g) t) (g ‚ü®‚Üët, ‚ãØ‚ü©)","decl":"@[simp]\ntheorem concat_right (hb : f ‚ä§ = g ‚ä•) {t : Icc a c} (ht : b ‚â§ t) :\n    concat f g t = g ‚ü®t, ht, t.2.2‚ü© := by\n  nth_rewrite 2 [‚Üê concat_comp_IccInclusionRight hb]\n  rfl\n\n"}
{"name":"ContinuousMap.tendsto_concat","module":"Mathlib.Topology.ContinuousMap.Interval","initialProofState":"Œ± : Type u_1\ninst‚úù‚Åµ : LinearOrder Œ±\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : OrderTopology Œ±\na b c : Œ±\ninst‚úù¬≤ : Fact (LE.le a b)\ninst‚úù¬π : Fact (LE.le b c)\nE : Type u_2\ninst‚úù : TopologicalSpace E\nf : ContinuousMap (‚Üë(Set.Icc a b)) E\ng : ContinuousMap (‚Üë(Set.Icc b c)) E\nŒπ : Type u_3\np : Filter Œπ\nF : Œπ ‚Üí ContinuousMap (‚Üë(Set.Icc a b)) E\nG : Œπ ‚Üí ContinuousMap (‚Üë(Set.Icc b c)) E\nhfg : Filter.Eventually (fun i => Eq ((F i) Top.top) ((G i) Bot.bot)) p\nhfg' : Eq (f Top.top) (g Bot.bot)\nhf : Filter.Tendsto F p (nhds f)\nhg : Filter.Tendsto G p (nhds g)\n‚ä¢ Filter.Tendsto (fun i => (F i).concat (G i)) p (nhds (f.concat g))","decl":"theorem tendsto_concat {Œπ : Type*} {p : Filter Œπ} {F : Œπ ‚Üí C(Icc a b, E)} {G : Œπ ‚Üí C(Icc b c, E)}\n    (hfg : ‚àÄ·∂† i in p, (F i) ‚ä§ = (G i) ‚ä•) (hfg' : f ‚ä§ = g ‚ä•)\n    (hf : Tendsto F p (ùìù f)) (hg : Tendsto G p (ùìù g)) :\n    Tendsto (fun i => concat (F i) (G i)) p (ùìù (concat f g)) := by\n  rw [tendsto_nhds_compactOpen] at hf hg ‚ä¢\n  rintro K hK U hU hfgU\n  have h : b ‚àà Icc a c := ‚ü®Fact.out, Fact.out‚ü©\n  let K‚ÇÅ : Set (Icc a b) := projIccCM '' (Subtype.val '' (K ‚à© Iic ‚ü®b, h‚ü©))\n  let K‚ÇÇ : Set (Icc b c) := projIccCM '' (Subtype.val '' (K ‚à© Ici ‚ü®b, h‚ü©))\n  have hK‚ÇÅ : IsCompact K‚ÇÅ :=\n    hK.inter_right isClosed_Iic |>.image continuous_subtype_val |>.image projIccCM.continuous\n  have hK‚ÇÇ : IsCompact K‚ÇÇ :=\n    hK.inter_right isClosed_Ici |>.image continuous_subtype_val |>.image projIccCM.continuous\n  have hfU : MapsTo f K‚ÇÅ U := by\n    rw [‚Üê concat_comp_IccInclusionLeft hfg']\n    apply hfgU.comp\n    rintro x ‚ü®y, ‚ü®‚ü®z, hz‚ü©, ‚ü®h1, (h2 : z ‚â§ b)‚ü©, rfl‚ü©, rfl‚ü©\n    simpa [projIccCM, projIcc, h2, hz.1] using h1\n  have hgU : MapsTo g K‚ÇÇ U := by\n    rw [‚Üê concat_comp_IccInclusionRight hfg']\n    apply hfgU.comp\n    rintro x ‚ü®y, ‚ü®‚ü®z, hz‚ü©, ‚ü®h1, (h2 : b ‚â§ z)‚ü©, rfl‚ü©, rfl‚ü©\n    simpa [projIccCM, projIcc, h2, hz.2] using h1\n  filter_upwards [hf K‚ÇÅ hK‚ÇÅ U hU hfU, hg K‚ÇÇ hK‚ÇÇ U hU hgU, hfg] with i hf hg hfg x hx\n  by_cases hxb : x ‚â§ b\n  ¬∑ rw [concat_left hfg hxb]\n    refine hf ‚ü®x, ‚ü®x, ‚ü®hx, hxb‚ü©, rfl‚ü©, ?_‚ü©\n    simp [projIccCM, projIcc, hxb, x.2.1]\n  ¬∑ replace hxb : b ‚â§ x := lt_of_not_le hxb |>.le\n    rw [concat_right hfg hxb]\n    refine hg ‚ü®x, ‚ü®x, ‚ü®hx, hxb‚ü©, rfl‚ü©, ?_‚ü©\n    simp [projIccCM, projIcc, hxb, x.2.2]\n\n"}
{"name":"ContinuousMap.concatCM_left","module":"Mathlib.Topology.ContinuousMap.Interval","initialProofState":"Œ± : Type u_1\ninst‚úù‚Åµ : LinearOrder Œ±\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : OrderTopology Œ±\na b c : Œ±\ninst‚úù¬≤ : Fact (LE.le a b)\ninst‚úù¬π : Fact (LE.le b c)\nE : Type u_2\ninst‚úù : TopologicalSpace E\nx : ‚Üë(Set.Icc a c)\nhx : LE.le (‚Üëx) b\nfg : Subtype fun fg => Eq (fg.1 Top.top) (fg.2 Bot.bot)\n‚ä¢ Eq ((ContinuousMap.concatCM fg) x) ((‚Üëfg).1 ‚ü®‚Üëx, ‚ãØ‚ü©)","decl":"@[simp]\ntheorem concatCM_left {x : Icc a c} (hx : x ‚â§ b)\n    {fg : {fg : C(Icc a b, E) √ó C(Icc b c, E) // fg.1 ‚ä§ = fg.2 ‚ä•}} :\n    concatCM fg x = fg.1.1 ‚ü®x.1, x.2.1, hx‚ü© := by\n  exact concat_left fg.2 hx\n\n"}
{"name":"ContinuousMap.concatCM_right","module":"Mathlib.Topology.ContinuousMap.Interval","initialProofState":"Œ± : Type u_1\ninst‚úù‚Åµ : LinearOrder Œ±\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : OrderTopology Œ±\na b c : Œ±\ninst‚úù¬≤ : Fact (LE.le a b)\ninst‚úù¬π : Fact (LE.le b c)\nE : Type u_2\ninst‚úù : TopologicalSpace E\nx : ‚Üë(Set.Icc a c)\nhx : LE.le b ‚Üëx\nfg : Subtype fun fg => Eq (fg.1 Top.top) (fg.2 Bot.bot)\n‚ä¢ Eq ((ContinuousMap.concatCM fg) x) ((‚Üëfg).2 ‚ü®‚Üëx, ‚ãØ‚ü©)","decl":"@[simp]\ntheorem concatCM_right {x : Icc a c} (hx : b ‚â§ x)\n    {fg : {fg : C(Icc a b, E) √ó C(Icc b c, E) // fg.1 ‚ä§ = fg.2 ‚ä•}} :\n    concatCM fg x = fg.1.2 ‚ü®x.1, hx, x.2.2‚ü© :=\n  concat_right fg.2 hx\n\n"}
