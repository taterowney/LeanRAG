{"name":"CategoryTheory.kernelOpUnop_inv","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.kernelOpUnop f).inv (CategoryTheory.Limits.cokernel.desc f (CategoryTheory.Limits.kernel.ι f.op).unop ⋯)","decl":"/-- The kernel of `f.op` is the opposite of `cokernel f`. -/\n@[simps]\ndef kernelOpUnop : (kernel f.op).unop ≅ cokernel f where\n  hom := (kernel.lift f.op (cokernel.π f).op <| by simp [← op_comp]).unop\n  inv :=\n    cokernel.desc f (kernel.ι f.op).unop <| by\n      rw [← f.unop_op, ← unop_comp, f.unop_op]\n      simp\n  hom_inv_id := by\n    rw [← unop_id, ← (cokernel.desc f _ _).unop_op, ← unop_comp]\n    congr 1\n    ext\n    simp [← op_comp]\n  inv_hom_id := by\n    ext\n    simp [← unop_comp]\n\n-- TODO: Generalize (this will work whenever f has a kernel)\n-- (The abelian case is probably sufficient for most applications.)\n"}
{"name":"CategoryTheory.kernelOpUnop_hom","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.kernelOpUnop f).hom (CategoryTheory.Limits.kernel.lift f.op (CategoryTheory.Limits.cokernel.π f).op ⋯).unop","decl":"/-- The kernel of `f.op` is the opposite of `cokernel f`. -/\n@[simps]\ndef kernelOpUnop : (kernel f.op).unop ≅ cokernel f where\n  hom := (kernel.lift f.op (cokernel.π f).op <| by simp [← op_comp]).unop\n  inv :=\n    cokernel.desc f (kernel.ι f.op).unop <| by\n      rw [← f.unop_op, ← unop_comp, f.unop_op]\n      simp\n  hom_inv_id := by\n    rw [← unop_id, ← (cokernel.desc f _ _).unop_op, ← unop_comp]\n    congr 1\n    ext\n    simp [← op_comp]\n  inv_hom_id := by\n    ext\n    simp [← unop_comp]\n\n-- TODO: Generalize (this will work whenever f has a kernel)\n-- (The abelian case is probably sufficient for most applications.)\n"}
{"name":"CategoryTheory.cokernelOpUnop_inv","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.cokernelOpUnop f).inv (CategoryTheory.Limits.cokernel.desc f.op (CategoryTheory.Limits.kernel.ι f).op ⋯).unop","decl":"/-- The cokernel of `f.op` is the opposite of `kernel f`. -/\n@[simps]\ndef cokernelOpUnop : (cokernel f.op).unop ≅ kernel f where\n  hom :=\n    kernel.lift f (cokernel.π f.op).unop <| by\n      rw [← f.unop_op, ← unop_comp, f.unop_op]\n      simp\n  inv := (cokernel.desc f.op (kernel.ι f).op <| by simp [← op_comp]).unop\n  hom_inv_id := by\n    rw [← unop_id, ← (kernel.lift f _ _).unop_op, ← unop_comp]\n    congr 1\n    ext\n    simp [← op_comp]\n  inv_hom_id := by\n    ext\n    simp [← unop_comp]\n\n"}
{"name":"CategoryTheory.cokernelOpUnop_hom","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.cokernelOpUnop f).hom (CategoryTheory.Limits.kernel.lift f (CategoryTheory.Limits.cokernel.π f.op).unop ⋯)","decl":"/-- The cokernel of `f.op` is the opposite of `kernel f`. -/\n@[simps]\ndef cokernelOpUnop : (cokernel f.op).unop ≅ kernel f where\n  hom :=\n    kernel.lift f (cokernel.π f.op).unop <| by\n      rw [← f.unop_op, ← unop_comp, f.unop_op]\n      simp\n  inv := (cokernel.desc f.op (kernel.ι f).op <| by simp [← op_comp]).unop\n  hom_inv_id := by\n    rw [← unop_id, ← (kernel.lift f _ _).unop_op, ← unop_comp]\n    congr 1\n    ext\n    simp [← op_comp]\n  inv_hom_id := by\n    ext\n    simp [← unop_comp]\n\n"}
{"name":"CategoryTheory.kernelUnopOp_hom","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nA B : Opposite C\ng : Quiver.Hom A B\n⊢ Eq (CategoryTheory.kernelUnopOp g).hom (CategoryTheory.Limits.kernel.lift g.unop (CategoryTheory.Limits.cokernel.π g).unop ⋯).op","decl":"/-- The kernel of `g.unop` is the opposite of `cokernel g`. -/\n@[simps!]\ndef kernelUnopOp : Opposite.op (kernel g.unop) ≅ cokernel g :=\n  (cokernelOpUnop g.unop).op\n\n"}
{"name":"CategoryTheory.kernelUnopOp_inv","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nA B : Opposite C\ng : Quiver.Hom A B\n⊢ Eq (CategoryTheory.kernelUnopOp g).inv (CategoryTheory.Limits.cokernel.desc g (CategoryTheory.Limits.kernel.ι g.unop).op ⋯)","decl":"/-- The kernel of `g.unop` is the opposite of `cokernel g`. -/\n@[simps!]\ndef kernelUnopOp : Opposite.op (kernel g.unop) ≅ cokernel g :=\n  (cokernelOpUnop g.unop).op\n\n"}
{"name":"CategoryTheory.cokernelUnopOp_hom","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nA B : Opposite C\ng : Quiver.Hom A B\n⊢ Eq (CategoryTheory.cokernelUnopOp g).hom (CategoryTheory.Limits.kernel.lift g (CategoryTheory.Limits.cokernel.π g.unop).op ⋯)","decl":"/-- The cokernel of `g.unop` is the opposite of `kernel g`. -/\n@[simps!]\ndef cokernelUnopOp : Opposite.op (cokernel g.unop) ≅ kernel g :=\n  (kernelOpUnop g.unop).op\n\n"}
{"name":"CategoryTheory.cokernelUnopOp_inv","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nA B : Opposite C\ng : Quiver.Hom A B\n⊢ Eq (CategoryTheory.cokernelUnopOp g).inv (CategoryTheory.Limits.cokernel.desc g.unop (CategoryTheory.Limits.kernel.ι g).unop ⋯).op","decl":"/-- The cokernel of `g.unop` is the opposite of `kernel g`. -/\n@[simps!]\ndef cokernelUnopOp : Opposite.op (cokernel g.unop) ≅ kernel g :=\n  (kernelOpUnop g.unop).op\n\n"}
{"name":"CategoryTheory.cokernel.π_op","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Limits.cokernel.π f.op).unop (CategoryTheory.CategoryStruct.comp (CategoryTheory.cokernelOpUnop f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.ι f) (CategoryTheory.eqToHom ⋯)))","decl":"theorem cokernel.π_op :\n    (cokernel.π f.op).unop =\n      (cokernelOpUnop f).hom ≫ kernel.ι f ≫ eqToHom (Opposite.unop_op _).symm := by\n  simp [cokernelOpUnop]\n\n"}
{"name":"CategoryTheory.kernel.ι_op","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Limits.kernel.ι f.op).unop (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.π f) (CategoryTheory.kernelOpUnop f).inv))","decl":"theorem kernel.ι_op :\n    (kernel.ι f.op).unop = eqToHom (Opposite.unop_op _) ≫ cokernel.π f ≫ (kernelOpUnop f).inv := by\n  simp [kernelOpUnop]\n\n"}
{"name":"CategoryTheory.kernelOpOp_inv","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.kernelOpOp f).inv (CategoryTheory.Limits.kernel.lift f.op (CategoryTheory.Limits.cokernel.π f).op ⋯)","decl":"/-- The kernel of `f.op` is the opposite of `cokernel f`. -/\n@[simps!]\ndef kernelOpOp : kernel f.op ≅ Opposite.op (cokernel f) :=\n  (kernelOpUnop f).op.symm\n\n"}
{"name":"CategoryTheory.kernelOpOp_hom","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.kernelOpOp f).hom (CategoryTheory.Limits.cokernel.desc f (CategoryTheory.Limits.kernel.ι f.op).unop ⋯).op","decl":"/-- The kernel of `f.op` is the opposite of `cokernel f`. -/\n@[simps!]\ndef kernelOpOp : kernel f.op ≅ Opposite.op (cokernel f) :=\n  (kernelOpUnop f).op.symm\n\n"}
{"name":"CategoryTheory.cokernelOpOp_inv","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.cokernelOpOp f).inv (CategoryTheory.Limits.kernel.lift f (CategoryTheory.Limits.cokernel.π f.op).unop ⋯).op","decl":"/-- The cokernel of `f.op` is the opposite of `kernel f`. -/\n@[simps!]\ndef cokernelOpOp : cokernel f.op ≅ Opposite.op (kernel f) :=\n  (cokernelOpUnop f).op.symm\n\n"}
{"name":"CategoryTheory.cokernelOpOp_hom","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.cokernelOpOp f).hom (CategoryTheory.Limits.cokernel.desc f.op (CategoryTheory.Limits.kernel.ι f).op ⋯)","decl":"/-- The cokernel of `f.op` is the opposite of `kernel f`. -/\n@[simps!]\ndef cokernelOpOp : cokernel f.op ≅ Opposite.op (kernel f) :=\n  (cokernelOpUnop f).op.symm\n\n"}
{"name":"CategoryTheory.kernelUnopUnop_hom","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nA B : Opposite C\ng : Quiver.Hom A B\n⊢ Eq (CategoryTheory.kernelUnopUnop g).hom (CategoryTheory.Limits.cokernel.desc g (CategoryTheory.Limits.kernel.ι g.unop).op ⋯).unop","decl":"/-- The kernel of `g.unop` is the opposite of `cokernel g`. -/\n@[simps!]\ndef kernelUnopUnop : kernel g.unop ≅ (cokernel g).unop :=\n  (kernelUnopOp g).unop.symm\n\n"}
{"name":"CategoryTheory.kernelUnopUnop_inv","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nA B : Opposite C\ng : Quiver.Hom A B\n⊢ Eq (CategoryTheory.kernelUnopUnop g).inv (CategoryTheory.Limits.kernel.lift g.unop (CategoryTheory.Limits.cokernel.π g).unop ⋯)","decl":"/-- The kernel of `g.unop` is the opposite of `cokernel g`. -/\n@[simps!]\ndef kernelUnopUnop : kernel g.unop ≅ (cokernel g).unop :=\n  (kernelUnopOp g).unop.symm\n\n"}
{"name":"CategoryTheory.kernel.ι_unop","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nA B : Opposite C\ng : Quiver.Hom A B\n⊢ Eq (CategoryTheory.Limits.kernel.ι g.unop).op (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.π g) (CategoryTheory.kernelUnopOp g).inv))","decl":"theorem kernel.ι_unop :\n    (kernel.ι g.unop).op = eqToHom (Opposite.op_unop _) ≫ cokernel.π g ≫ (kernelUnopOp g).inv := by\n  simp\n\n"}
{"name":"CategoryTheory.cokernel.π_unop","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nA B : Opposite C\ng : Quiver.Hom A B\n⊢ Eq (CategoryTheory.Limits.cokernel.π g.unop).op (CategoryTheory.CategoryStruct.comp (CategoryTheory.cokernelUnopOp g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.ι g) (CategoryTheory.eqToHom ⋯)))","decl":"theorem cokernel.π_unop :\n    (cokernel.π g.unop).op =\n      (cokernelUnopOp g).hom ≫ kernel.ι g ≫ eqToHom (Opposite.op_unop _).symm := by\n  simp\n\n"}
{"name":"CategoryTheory.cokernelUnopUnop_hom","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nA B : Opposite C\ng : Quiver.Hom A B\n⊢ Eq (CategoryTheory.cokernelUnopUnop g).hom (CategoryTheory.Limits.cokernel.desc g.unop (CategoryTheory.Limits.kernel.ι g).unop ⋯)","decl":"/-- The cokernel of `g.unop` is the opposite of `kernel g`. -/\n@[simps!]\ndef cokernelUnopUnop : cokernel g.unop ≅ (kernel g).unop :=\n  (cokernelUnopOp g).unop.symm\n\n"}
{"name":"CategoryTheory.cokernelUnopUnop_inv","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nA B : Opposite C\ng : Quiver.Hom A B\n⊢ Eq (CategoryTheory.cokernelUnopUnop g).inv (CategoryTheory.Limits.kernel.lift g (CategoryTheory.Limits.cokernel.π g.unop).op ⋯).unop","decl":"/-- The cokernel of `g.unop` is the opposite of `kernel g`. -/\n@[simps!]\ndef cokernelUnopUnop : cokernel g.unop ≅ (kernel g).unop :=\n  (cokernelUnopOp g).unop.symm\n\n"}
{"name":"CategoryTheory.image_ι_op_comp_imageUnopOp_hom","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nA B : Opposite C\ng : Quiver.Hom A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι g.unop).op (CategoryTheory.imageUnopOp g).hom) (CategoryTheory.Limits.factorThruImage g)","decl":"theorem image_ι_op_comp_imageUnopOp_hom :\n    (image.ι g.unop).op ≫ (imageUnopOp g).hom = factorThruImage g := by\n  simp only [imageUnopOp, Iso.trans, Iso.symm, Iso.op, cokernelOpOp_inv, cokernelEpiComp_hom,\n    cokernelCompIsIso_hom, Abelian.coimageIsoImage'_hom, ← Category.assoc, ← op_comp]\n  simp only [Category.assoc, Abelian.imageIsoImage_hom_comp_image_ι, kernel.lift_ι,\n    Quiver.Hom.op_unop, cokernelIsoOfEq_hom_comp_desc_assoc, cokernel.π_desc_assoc,\n    cokernel.π_desc]\n  simp only [eqToHom_refl]\n  rw [IsIso.inv_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.imageUnopOp_hom_comp_image_ι","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nA B : Opposite C\ng : Quiver.Hom A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.imageUnopOp g).hom (CategoryTheory.Limits.image.ι g)) (CategoryTheory.Limits.factorThruImage g.unop).op","decl":"theorem imageUnopOp_hom_comp_image_ι :\n    (imageUnopOp g).hom ≫ image.ι g = (factorThruImage g.unop).op := by\n  simp only [← cancel_epi (image.ι g.unop).op, ← Category.assoc, image_ι_op_comp_imageUnopOp_hom,\n    ← op_comp, image.fac, Quiver.Hom.op_unop]\n\n"}
{"name":"CategoryTheory.factorThruImage_comp_imageUnopOp_inv","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nA B : Opposite C\ng : Quiver.Hom A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage g) (CategoryTheory.imageUnopOp g).inv) (CategoryTheory.Limits.image.ι g.unop).op","decl":"theorem factorThruImage_comp_imageUnopOp_inv :\n    factorThruImage g ≫ (imageUnopOp g).inv = (image.ι g.unop).op := by\n  rw [Iso.comp_inv_eq, image_ι_op_comp_imageUnopOp_hom]\n\n"}
{"name":"CategoryTheory.imageUnopOp_inv_comp_op_factorThruImage","module":"Mathlib.CategoryTheory.Abelian.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nA B : Opposite C\ng : Quiver.Hom A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.imageUnopOp g).inv (CategoryTheory.Limits.factorThruImage g.unop).op) (CategoryTheory.Limits.image.ι g)","decl":"theorem imageUnopOp_inv_comp_op_factorThruImage :\n    (imageUnopOp g).inv ≫ (factorThruImage g.unop).op = image.ι g := by\n  rw [Iso.inv_comp_eq, imageUnopOp_hom_comp_image_ι]\n\n"}
