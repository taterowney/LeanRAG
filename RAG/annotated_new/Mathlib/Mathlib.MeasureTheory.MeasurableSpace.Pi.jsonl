{"name":"MeasurableSpace.pi_eq_generateFrom_projections","module":"Mathlib.MeasureTheory.MeasurableSpace.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nmα : (i : ι) → MeasurableSpace (α i)\n⊢ Eq MeasurableSpace.pi (MeasurableSpace.generateFrom (setOf fun B => Exists fun i => Exists fun A => And (MeasurableSet A) (Eq (Set.preimage (Function.eval i) A) B)))","decl":"lemma MeasurableSpace.pi_eq_generateFrom_projections {mα : ∀ i, MeasurableSpace (α i)} :\n    pi = generateFrom {B | ∃ (i : ι) (A : Set (α i)), MeasurableSet A ∧ eval i ⁻¹' A = B} := by\n  simp only [pi, ← generateFrom_iUnion_measurableSet, iUnion_setOf, measurableSet_comap]\n\n"}
{"name":"IsPiSystem.pi","module":"Mathlib.MeasureTheory.MeasurableSpace.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nC : (i : ι) → Set (Set (α i))\nhC : ∀ (i : ι), IsPiSystem (C i)\n⊢ IsPiSystem (Set.image Set.univ.pi (Set.univ.pi C))","decl":"/-- Boxes formed by π-systems form a π-system. -/\ntheorem IsPiSystem.pi {C : ∀ i, Set (Set (α i))} (hC : ∀ i, IsPiSystem (C i)) :\n    IsPiSystem (pi univ '' pi univ C) := by\n  rintro _ ⟨s₁, hs₁, rfl⟩ _ ⟨s₂, hs₂, rfl⟩ hst\n  rw [← pi_inter_distrib] at hst ⊢; rw [univ_pi_nonempty_iff] at hst\n  exact mem_image_of_mem _ fun i _ => hC i _ (hs₁ i (mem_univ i)) _ (hs₂ i (mem_univ i)) (hst i)\n\n"}
{"name":"isPiSystem_pi","module":"Mathlib.MeasureTheory.MeasurableSpace.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → MeasurableSpace (α i)\n⊢ IsPiSystem (Set.image Set.univ.pi (Set.univ.pi fun i => setOf fun s => MeasurableSet s))","decl":"/-- Boxes form a π-system. -/\ntheorem isPiSystem_pi [∀ i, MeasurableSpace (α i)] :\n    IsPiSystem (pi univ '' pi univ fun i => { s : Set (α i) | MeasurableSet s }) :=\n  IsPiSystem.pi fun _ => isPiSystem_measurableSet\n\n"}
{"name":"IsCountablySpanning.pi","module":"Mathlib.MeasureTheory.MeasurableSpace.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : Finite ι\nC : (i : ι) → Set (Set (α i))\nhC : ∀ (i : ι), IsCountablySpanning (C i)\n⊢ IsCountablySpanning (Set.image Set.univ.pi (Set.univ.pi C))","decl":"/-- Boxes of countably spanning sets are countably spanning. -/\ntheorem IsCountablySpanning.pi {C : ∀ i, Set (Set (α i))} (hC : ∀ i, IsCountablySpanning (C i)) :\n    IsCountablySpanning (pi univ '' pi univ C) := by\n  choose s h1s h2s using hC\n  cases nonempty_encodable (ι → ℕ)\n  let e : ℕ → ι → ℕ := fun n => (@decode (ι → ℕ) _ n).iget\n  refine ⟨fun n => Set.pi univ fun i => s i (e n i), fun n =>\n    mem_image_of_mem _ fun i _ => h1s i _, ?_⟩\n  simp_rw\n    [e, (surjective_decode_iget (ι → ℕ)).iUnion_comp fun x => Set.pi univ fun i => s i (x i),\n    iUnion_univ_pi s, h2s, pi_univ]\n\n"}
{"name":"generateFrom_pi_eq","module":"Mathlib.MeasureTheory.MeasurableSpace.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : Finite ι\nC : (i : ι) → Set (Set (α i))\nhC : ∀ (i : ι), IsCountablySpanning (C i)\n⊢ Eq MeasurableSpace.pi (MeasurableSpace.generateFrom (Set.image Set.univ.pi (Set.univ.pi C)))","decl":"/-- The product of generated σ-algebras is the one generated by boxes, if both generating sets\n  are countably spanning. -/\ntheorem generateFrom_pi_eq {C : ∀ i, Set (Set (α i))} (hC : ∀ i, IsCountablySpanning (C i)) :\n    (@MeasurableSpace.pi _ _ fun i => generateFrom (C i)) =\n    generateFrom (pi univ '' pi univ C) := by\n  classical\n  cases nonempty_encodable ι\n  apply le_antisymm\n  · refine iSup_le ?_; intro i; rw [comap_generateFrom]\n    apply generateFrom_le; rintro _ ⟨s, hs, rfl⟩\n    choose t h1t h2t using hC\n    simp_rw [eval_preimage, ← h2t]\n    rw [← @iUnion_const _ ℕ _ s]\n    have : Set.pi univ (update (fun i' : ι => iUnion (t i')) i (⋃ _ : ℕ, s)) =\n        Set.pi univ fun k => ⋃ j : ℕ,\n        @update ι (fun i' => Set (α i')) _ (fun i' => t i' j) i s k := by\n      ext; simp_rw [mem_univ_pi]; apply forall_congr'; intro i'\n      by_cases h : i' = i\n      · subst h; simp\n      · rw [← Ne] at h; simp [h]\n    rw [this, ← iUnion_univ_pi]\n    apply MeasurableSet.iUnion\n    intro n; apply measurableSet_generateFrom\n    apply mem_image_of_mem; intro j _; dsimp only\n    by_cases h : j = i\n    · subst h; rwa [update_self]\n    · rw [update_of_ne h]; apply h1t\n  · apply generateFrom_le; rintro _ ⟨s, hs, rfl⟩\n    rw [univ_pi_eq_iInter]; apply MeasurableSet.iInter; intro i\n    apply @measurable_pi_apply _ _ (fun i => generateFrom (C i))\n    exact measurableSet_generateFrom (hs i (mem_univ i))\n\n"}
{"name":"generateFrom_eq_pi","module":"Mathlib.MeasureTheory.MeasurableSpace.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : Finite ι\nh : (i : ι) → MeasurableSpace (α i)\nC : (i : ι) → Set (Set (α i))\nhC : ∀ (i : ι), Eq (MeasurableSpace.generateFrom (C i)) (h i)\nh2C : ∀ (i : ι), IsCountablySpanning (C i)\n⊢ Eq (MeasurableSpace.generateFrom (Set.image Set.univ.pi (Set.univ.pi C))) MeasurableSpace.pi","decl":"/-- If `C` and `D` generate the σ-algebras on `α` resp. `β`, then rectangles formed by `C` and `D`\n  generate the σ-algebra on `α × β`. -/\ntheorem generateFrom_eq_pi [h : ∀ i, MeasurableSpace (α i)] {C : ∀ i, Set (Set (α i))}\n    (hC : ∀ i, generateFrom (C i) = h i) (h2C : ∀ i, IsCountablySpanning (C i)) :\n    generateFrom (pi univ '' pi univ C) = MeasurableSpace.pi := by\n  simp only [← funext hC, generateFrom_pi_eq h2C]\n\n"}
{"name":"generateFrom_pi","module":"Mathlib.MeasureTheory.MeasurableSpace.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : Finite ι\ninst✝ : (i : ι) → MeasurableSpace (α i)\n⊢ Eq (MeasurableSpace.generateFrom (Set.image Set.univ.pi (Set.univ.pi fun i => setOf fun s => MeasurableSet s))) MeasurableSpace.pi","decl":"/-- The product σ-algebra is generated from boxes, i.e. `s ×ˢ t` for sets `s : set α` and\n  `t : set β`. -/\ntheorem generateFrom_pi [∀ i, MeasurableSpace (α i)] :\n    generateFrom (pi univ '' pi univ fun i => { s : Set (α i) | MeasurableSet s }) =\n      MeasurableSpace.pi :=\n  generateFrom_eq_pi (fun _ => generateFrom_measurableSet) fun _ =>\n    isCountablySpanning_measurableSet\n\n"}
