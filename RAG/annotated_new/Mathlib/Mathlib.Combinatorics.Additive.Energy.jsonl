{"name":"Finset.addEnergy_mono","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns₁ s₂ t₁ t₂ : Finset α\nhs : HasSubset.Subset s₁ s₂\nht : HasSubset.Subset t₁ t₂\n⊢ LE.le (s₁.addEnergy t₁) (s₂.addEnergy t₂)","decl":"@[to_additive (attr := gcongr)]\nlemma mulEnergy_mono (hs : s₁ ⊆ s₂) (ht : t₁ ⊆ t₂) : Eₘ[s₁, t₁] ≤ Eₘ[s₂, t₂] := by\n  unfold mulEnergy; gcongr\n\n"}
{"name":"Finset.mulEnergy_mono","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns₁ s₂ t₁ t₂ : Finset α\nhs : HasSubset.Subset s₁ s₂\nht : HasSubset.Subset t₁ t₂\n⊢ LE.le (s₁.mulEnergy t₁) (s₂.mulEnergy t₂)","decl":"@[to_additive (attr := gcongr)]\nlemma mulEnergy_mono (hs : s₁ ⊆ s₂) (ht : t₁ ⊆ t₂) : Eₘ[s₁, t₁] ≤ Eₘ[s₂, t₂] := by\n  unfold mulEnergy; gcongr\n\n"}
{"name":"Finset.addEnergy_mono_left","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns₁ s₂ t : Finset α\nhs : HasSubset.Subset s₁ s₂\n⊢ LE.le (s₁.addEnergy t) (s₂.addEnergy t)","decl":"@[to_additive] lemma mulEnergy_mono_left (hs : s₁ ⊆ s₂) : Eₘ[s₁, t] ≤ Eₘ[s₂, t] :=\n  mulEnergy_mono hs Subset.rfl\n\n"}
{"name":"Finset.mulEnergy_mono_left","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns₁ s₂ t : Finset α\nhs : HasSubset.Subset s₁ s₂\n⊢ LE.le (s₁.mulEnergy t) (s₂.mulEnergy t)","decl":"@[to_additive] lemma mulEnergy_mono_left (hs : s₁ ⊆ s₂) : Eₘ[s₁, t] ≤ Eₘ[s₂, t] :=\n  mulEnergy_mono hs Subset.rfl\n\n"}
{"name":"Finset.addEnergy_mono_right","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t₁ t₂ : Finset α\nht : HasSubset.Subset t₁ t₂\n⊢ LE.le (s.addEnergy t₁) (s.addEnergy t₂)","decl":"@[to_additive] lemma mulEnergy_mono_right (ht : t₁ ⊆ t₂) : Eₘ[s, t₁] ≤ Eₘ[s, t₂] :=\n  mulEnergy_mono Subset.rfl ht\n\n"}
{"name":"Finset.mulEnergy_mono_right","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t₁ t₂ : Finset α\nht : HasSubset.Subset t₁ t₂\n⊢ LE.le (s.mulEnergy t₁) (s.mulEnergy t₂)","decl":"@[to_additive] lemma mulEnergy_mono_right (ht : t₁ ⊆ t₂) : Eₘ[s, t₁] ≤ Eₘ[s, t₂] :=\n  mulEnergy_mono Subset.rfl ht\n\n"}
{"name":"Finset.le_mulEnergy","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Finset α\n⊢ LE.le (HMul.hMul s.card t.card) (s.mulEnergy t)","decl":"@[to_additive] lemma le_mulEnergy : s.card * t.card ≤ Eₘ[s, t] := by\n  rw [← card_product]\n  refine\n    card_le_card_of_injOn (@fun x => ((x.1, x.1), x.2, x.2)) (by simp) fun a _ b _ => ?_\n  simp only [Prod.mk.inj_iff, and_self_iff, and_imp]\n  exact Prod.ext\n\n"}
{"name":"Finset.le_addEnergy","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Finset α\n⊢ LE.le (HMul.hMul s.card t.card) (s.addEnergy t)","decl":"@[to_additive] lemma le_mulEnergy : s.card * t.card ≤ Eₘ[s, t] := by\n  rw [← card_product]\n  refine\n    card_le_card_of_injOn (@fun x => ((x.1, x.1), x.2, x.2)) (by simp) fun a _ b _ => ?_\n  simp only [Prod.mk.inj_iff, and_self_iff, and_imp]\n  exact Prod.ext\n\n"}
{"name":"Finset.mulEnergy_pos","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Finset α\nhs : s.Nonempty\nht : t.Nonempty\n⊢ LT.lt 0 (s.mulEnergy t)","decl":"@[to_additive] lemma mulEnergy_pos (hs : s.Nonempty) (ht : t.Nonempty) : 0 < Eₘ[s, t] :=\n  (mul_pos hs.card_pos ht.card_pos).trans_le le_mulEnergy\n\n"}
{"name":"Finset.addEnergy_pos","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Finset α\nhs : s.Nonempty\nht : t.Nonempty\n⊢ LT.lt 0 (s.addEnergy t)","decl":"@[to_additive] lemma mulEnergy_pos (hs : s.Nonempty) (ht : t.Nonempty) : 0 < Eₘ[s, t] :=\n  (mul_pos hs.card_pos ht.card_pos).trans_le le_mulEnergy\n\n"}
{"name":"Finset.mulEnergy_empty_left","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\nt : Finset α\n⊢ Eq (EmptyCollection.emptyCollection.mulEnergy t) 0","decl":"@[to_additive (attr := simp)] lemma mulEnergy_empty_left : Eₘ[∅, t] = 0 := by simp [mulEnergy]\n\n"}
{"name":"Finset.addEnergy_empty_left","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Add α\nt : Finset α\n⊢ Eq (EmptyCollection.emptyCollection.addEnergy t) 0","decl":"@[to_additive (attr := simp)] lemma mulEnergy_empty_left : Eₘ[∅, t] = 0 := by simp [mulEnergy]\n\n"}
{"name":"Finset.addEnergy_empty_right","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns : Finset α\n⊢ Eq (s.addEnergy EmptyCollection.emptyCollection) 0","decl":"@[to_additive (attr := simp)] lemma mulEnergy_empty_right : Eₘ[s, ∅] = 0 := by simp [mulEnergy]\n\n"}
{"name":"Finset.mulEnergy_empty_right","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns : Finset α\n⊢ Eq (s.mulEnergy EmptyCollection.emptyCollection) 0","decl":"@[to_additive (attr := simp)] lemma mulEnergy_empty_right : Eₘ[s, ∅] = 0 := by simp [mulEnergy]\n\n"}
{"name":"Finset.mulEnergy_pos_iff","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Finset α\n⊢ Iff (LT.lt 0 (s.mulEnergy t)) (And s.Nonempty t.Nonempty)","decl":"@[to_additive (attr := simp)] lemma mulEnergy_pos_iff : 0 < Eₘ[s, t] ↔ s.Nonempty ∧ t.Nonempty where\n  mp h := of_not_not fun H => by\n    simp_rw [not_and_or, not_nonempty_iff_eq_empty] at H\n    obtain rfl | rfl := H <;> simp [Nat.not_lt_zero] at h\n  mpr h := mulEnergy_pos h.1 h.2\n\n"}
{"name":"Finset.addEnergy_pos_iff","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Finset α\n⊢ Iff (LT.lt 0 (s.addEnergy t)) (And s.Nonempty t.Nonempty)","decl":"@[to_additive (attr := simp)] lemma mulEnergy_pos_iff : 0 < Eₘ[s, t] ↔ s.Nonempty ∧ t.Nonempty where\n  mp h := of_not_not fun H => by\n    simp_rw [not_and_or, not_nonempty_iff_eq_empty] at H\n    obtain rfl | rfl := H <;> simp [Nat.not_lt_zero] at h\n  mpr h := mulEnergy_pos h.1 h.2\n\n"}
{"name":"Finset.addEnergy_eq_zero_iff","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Finset α\n⊢ Iff (Eq (s.addEnergy t) 0) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[to_additive (attr := simp)] lemma mulEnergy_eq_zero_iff : Eₘ[s, t] = 0 ↔ s = ∅ ∨ t = ∅ := by\n  simp [← (Nat.zero_le _).not_gt_iff_eq, not_and_or, imp_iff_or_not, or_comm]\n\n"}
{"name":"Finset.mulEnergy_eq_zero_iff","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Finset α\n⊢ Iff (Eq (s.mulEnergy t) 0) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[to_additive (attr := simp)] lemma mulEnergy_eq_zero_iff : Eₘ[s, t] = 0 ↔ s = ∅ ∨ t = ∅ := by\n  simp [← (Nat.zero_le _).not_gt_iff_eq, not_and_or, imp_iff_or_not, or_comm]\n\n"}
{"name":"Finset.mulEnergy_eq_card_filter","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Finset α\n⊢ Eq (s.mulEnergy t) (Finset.filter (fun x => Finset.mulEnergy_eq_card_filter.match_1 (fun x => Prop) x fun a b c d => Eq (HMul.hMul a b) (HMul.hMul c d)) (SProd.sprod (SProd.sprod s t) (SProd.sprod s t))).card","decl":"@[to_additive] lemma mulEnergy_eq_card_filter (s t : Finset α) :\n    Eₘ[s, t] = (((s ×ˢ t) ×ˢ s ×ˢ t).filter fun ((a, b), c, d) ↦ a * b = c * d).card :=\n  card_equiv (.prodProdProdComm _ _ _ _) (by simp [and_and_and_comm])\n\n"}
{"name":"Finset.addEnergy_eq_card_filter","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Finset α\n⊢ Eq (s.addEnergy t) (Finset.filter (fun x => Finset.addEnergy_eq_card_filter.match_1 (fun x => Prop) x fun a b c d => Eq (HAdd.hAdd a b) (HAdd.hAdd c d)) (SProd.sprod (SProd.sprod s t) (SProd.sprod s t))).card","decl":"@[to_additive] lemma mulEnergy_eq_card_filter (s t : Finset α) :\n    Eₘ[s, t] = (((s ×ˢ t) ×ˢ s ×ˢ t).filter fun ((a, b), c, d) ↦ a * b = c * d).card :=\n  card_equiv (.prodProdProdComm _ _ _ _) (by simp [and_and_and_comm])\n\n"}
{"name":"Finset.addEnergy_eq_sum_sq'","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Finset α\n⊢ Eq (s.addEnergy t) ((HAdd.hAdd s t).sum fun a => HPow.hPow (Finset.filter (fun x => Finset.addEnergy_eq_sum_sq'.match_1 (fun x => Prop) x fun x y => Eq (HAdd.hAdd x y) a) (SProd.sprod s t)).card 2)","decl":"@[to_additive] lemma mulEnergy_eq_sum_sq' (s t : Finset α) :\n    Eₘ[s, t] = ∑ a ∈ s * t, ((s ×ˢ t).filter fun (x, y) ↦ x * y = a).card ^ 2 := by\n  simp_rw [mulEnergy_eq_card_filter, sq, ← card_product]\n  rw [← card_disjiUnion]\n  -- The `swap`, `ext` and `simp` calls significantly reduce heartbeats\n  swap\n  · simp only [Set.PairwiseDisjoint, Set.Pairwise, coe_mul, ne_eq, disjoint_left, mem_product,\n      mem_filter, not_and, and_imp, Prod.forall]\n    aesop\n  · congr\n    ext\n    simp only [mem_filter, mem_product, disjiUnion_eq_biUnion, mem_biUnion]\n    aesop (add unsafe mul_mem_mul)\n\n"}
{"name":"Finset.mulEnergy_eq_sum_sq'","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Finset α\n⊢ Eq (s.mulEnergy t) ((HMul.hMul s t).sum fun a => HPow.hPow (Finset.filter (fun x => Finset.mulEnergy_eq_sum_sq'.match_1 (fun x => Prop) x fun x y => Eq (HMul.hMul x y) a) (SProd.sprod s t)).card 2)","decl":"@[to_additive] lemma mulEnergy_eq_sum_sq' (s t : Finset α) :\n    Eₘ[s, t] = ∑ a ∈ s * t, ((s ×ˢ t).filter fun (x, y) ↦ x * y = a).card ^ 2 := by\n  simp_rw [mulEnergy_eq_card_filter, sq, ← card_product]\n  rw [← card_disjiUnion]\n  -- The `swap`, `ext` and `simp` calls significantly reduce heartbeats\n  swap\n  · simp only [Set.PairwiseDisjoint, Set.Pairwise, coe_mul, ne_eq, disjoint_left, mem_product,\n      mem_filter, not_and, and_imp, Prod.forall]\n    aesop\n  · congr\n    ext\n    simp only [mem_filter, mem_product, disjiUnion_eq_biUnion, mem_biUnion]\n    aesop (add unsafe mul_mem_mul)\n\n"}
{"name":"Finset.addEnergy_eq_sum_sq","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : Add α\ninst✝ : Fintype α\ns t : Finset α\n⊢ Eq (s.addEnergy t) (Finset.univ.sum fun a => HPow.hPow (Finset.filter (fun x => Finset.addEnergy_eq_sum_sq'.match_1 (fun x => Prop) x fun x y => Eq (HAdd.hAdd x y) a) (SProd.sprod s t)).card 2)","decl":"@[to_additive] lemma mulEnergy_eq_sum_sq [Fintype α] (s t : Finset α) :\n    Eₘ[s, t] = ∑ a, ((s ×ˢ t).filter fun (x, y) ↦ x * y = a).card ^ 2 := by\n  rw [mulEnergy_eq_sum_sq']\n  exact Fintype.sum_subset <| by aesop (add simp [filter_eq_empty_iff, mul_mem_mul])\n\n"}
{"name":"Finset.mulEnergy_eq_sum_sq","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : Mul α\ninst✝ : Fintype α\ns t : Finset α\n⊢ Eq (s.mulEnergy t) (Finset.univ.sum fun a => HPow.hPow (Finset.filter (fun x => Finset.mulEnergy_eq_sum_sq'.match_1 (fun x => Prop) x fun x y => Eq (HMul.hMul x y) a) (SProd.sprod s t)).card 2)","decl":"@[to_additive] lemma mulEnergy_eq_sum_sq [Fintype α] (s t : Finset α) :\n    Eₘ[s, t] = ∑ a, ((s ×ˢ t).filter fun (x, y) ↦ x * y = a).card ^ 2 := by\n  rw [mulEnergy_eq_sum_sq']\n  exact Fintype.sum_subset <| by aesop (add simp [filter_eq_empty_iff, mul_mem_mul])\n\n"}
{"name":"Finset.card_sq_le_card_mul_mulEnergy","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t u : Finset α\n⊢ LE.le (HPow.hPow (Finset.filter (fun x => Finset.mulEnergy_eq_sum_sq'.match_1 (fun x => Prop) x fun a b => Membership.mem u (HMul.hMul a b)) (SProd.sprod s t)).card 2) (HMul.hMul u.card (s.mulEnergy t))","decl":"@[to_additive card_sq_le_card_mul_addEnergy]\nlemma card_sq_le_card_mul_mulEnergy (s t u : Finset α) :\n    ((s ×ˢ t).filter fun (a, b) ↦ a * b ∈ u).card ^ 2 ≤ u.card * Eₘ[s, t] := by\n  calc\n    _ = (∑ c ∈ u, ((s ×ˢ t).filter fun (a, b) ↦ a * b = c).card) ^ 2 := by\n        rw [← sum_card_fiberwise_eq_card_filter]\n    _ ≤ u.card * ∑ c ∈ u, ((s ×ˢ t).filter fun (a, b) ↦ a * b = c).card ^ 2 := by\n        simpa using sum_mul_sq_le_sq_mul_sq (R := ℕ) _ 1 _\n    _ ≤ u.card * ∑ c ∈ s * t, ((s ×ˢ t).filter fun (a, b) ↦ a * b = c).card ^ 2 := by\n        refine mul_le_mul_left' (sum_le_sum_of_ne_zero ?_) _\n        aesop (add simp [filter_eq_empty_iff]) (add unsafe mul_mem_mul)\n    _ = u.card * Eₘ[s, t] := by rw [mulEnergy_eq_sum_sq']\n\n"}
{"name":"Finset.card_sq_le_card_mul_addEnergy","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t u : Finset α\n⊢ LE.le (HPow.hPow (Finset.filter (fun x => Finset.addEnergy_eq_sum_sq'.match_1 (fun x => Prop) x fun a b => Membership.mem u (HAdd.hAdd a b)) (SProd.sprod s t)).card 2) (HMul.hMul u.card (s.addEnergy t))","decl":"@[to_additive card_sq_le_card_mul_addEnergy]\nlemma card_sq_le_card_mul_mulEnergy (s t u : Finset α) :\n    ((s ×ˢ t).filter fun (a, b) ↦ a * b ∈ u).card ^ 2 ≤ u.card * Eₘ[s, t] := by\n  calc\n    _ = (∑ c ∈ u, ((s ×ˢ t).filter fun (a, b) ↦ a * b = c).card) ^ 2 := by\n        rw [← sum_card_fiberwise_eq_card_filter]\n    _ ≤ u.card * ∑ c ∈ u, ((s ×ˢ t).filter fun (a, b) ↦ a * b = c).card ^ 2 := by\n        simpa using sum_mul_sq_le_sq_mul_sq (R := ℕ) _ 1 _\n    _ ≤ u.card * ∑ c ∈ s * t, ((s ×ˢ t).filter fun (a, b) ↦ a * b = c).card ^ 2 := by\n        refine mul_le_mul_left' (sum_le_sum_of_ne_zero ?_) _\n        aesop (add simp [filter_eq_empty_iff]) (add unsafe mul_mem_mul)\n    _ = u.card * Eₘ[s, t] := by rw [mulEnergy_eq_sum_sq']\n\n"}
{"name":"Finset.le_card_add_mul_addEnergy","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Finset α\n⊢ LE.le (HMul.hMul (HPow.hPow s.card 2) (HPow.hPow t.card 2)) (HMul.hMul (HAdd.hAdd s t).card (s.addEnergy t))","decl":"@[to_additive le_card_add_mul_addEnergy] lemma le_card_add_mul_mulEnergy (s t : Finset α) :\n    s.card ^ 2 * t.card ^ 2 ≤ (s * t).card * Eₘ[s, t] :=\n  calc\n    _ = ((s ×ˢ t).filter fun (a, b) ↦ a * b ∈ s * t).card ^ 2 := by\n      rw [filter_eq_self.2, card_product, mul_pow]; aesop (add unsafe mul_mem_mul)\n    _ ≤ (s * t).card * Eₘ[s, t] := card_sq_le_card_mul_mulEnergy _ _ _\n\n"}
{"name":"Finset.le_card_add_mul_mulEnergy","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Finset α\n⊢ LE.le (HMul.hMul (HPow.hPow s.card 2) (HPow.hPow t.card 2)) (HMul.hMul (HMul.hMul s t).card (s.mulEnergy t))","decl":"@[to_additive le_card_add_mul_addEnergy] lemma le_card_add_mul_mulEnergy (s t : Finset α) :\n    s.card ^ 2 * t.card ^ 2 ≤ (s * t).card * Eₘ[s, t] :=\n  calc\n    _ = ((s ×ˢ t).filter fun (a, b) ↦ a * b ∈ s * t).card ^ 2 := by\n      rw [filter_eq_self.2, card_product, mul_pow]; aesop (add unsafe mul_mem_mul)\n    _ ≤ (s * t).card * Eₘ[s, t] := card_sq_le_card_mul_mulEnergy _ _ _\n\n"}
{"name":"Finset.mulEnergy_comm","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : CommMonoid α\ns t : Finset α\n⊢ Eq (s.mulEnergy t) (t.mulEnergy s)","decl":"@[to_additive] lemma mulEnergy_comm (s t : Finset α) : Eₘ[s, t] = Eₘ[t, s] := by\n  rw [mulEnergy, ← Finset.card_map (Equiv.prodComm _ _).toEmbedding, map_filter]\n  simp [-Finset.card_map, eq_comm, mulEnergy, mul_comm, map_eq_image, Function.comp_def]\n\n"}
{"name":"Finset.addEnergy_comm","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddCommMonoid α\ns t : Finset α\n⊢ Eq (s.addEnergy t) (t.addEnergy s)","decl":"@[to_additive] lemma mulEnergy_comm (s t : Finset α) : Eₘ[s, t] = Eₘ[t, s] := by\n  rw [mulEnergy, ← Finset.card_map (Equiv.prodComm _ _).toEmbedding, map_filter]\n  simp [-Finset.card_map, eq_comm, mulEnergy, mul_comm, map_eq_image, Function.comp_def]\n\n"}
{"name":"Finset.mulEnergy_univ_left","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : CommGroup α\ninst✝ : Fintype α\nt : Finset α\n⊢ Eq (Finset.univ.mulEnergy t) (HMul.hMul (Fintype.card α) (HPow.hPow t.card 2))","decl":"@[to_additive (attr := simp)]\nlemma mulEnergy_univ_left : Eₘ[univ, t] = Fintype.card α * t.card ^ 2 := by\n  simp only [mulEnergy, univ_product_univ, Fintype.card, sq, ← card_product]\n  let f : α × α × α → (α × α) × α × α := fun x => ((x.1 * x.2.2, x.1 * x.2.1), x.2)\n  have : (↑((univ : Finset α) ×ˢ t ×ˢ t) : Set (α × α × α)).InjOn f := by\n    rintro ⟨a₁, b₁, c₁⟩ _ ⟨a₂, b₂, c₂⟩ h₂ h\n    simp_rw [f, Prod.ext_iff] at h\n    obtain ⟨h, rfl, rfl⟩ := h\n    rw [mul_right_cancel h.1]\n  rw [← card_image_of_injOn this]\n  congr with a\n  simp only [mem_filter, mem_product, mem_univ, true_and, mem_image, exists_prop,\n    Prod.exists]\n  refine ⟨fun h => ⟨a.1.1 * a.2.2⁻¹, _, _, h.1, by simp [f, mul_right_comm, h.2]⟩, ?_⟩\n  rintro ⟨b, c, d, hcd, rfl⟩\n  simpa [f, mul_right_comm]\n\n"}
{"name":"Finset.addEnergy_univ_left","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : AddCommGroup α\ninst✝ : Fintype α\nt : Finset α\n⊢ Eq (Finset.univ.addEnergy t) (HMul.hMul (Fintype.card α) (HPow.hPow t.card 2))","decl":"@[to_additive (attr := simp)]\nlemma mulEnergy_univ_left : Eₘ[univ, t] = Fintype.card α * t.card ^ 2 := by\n  simp only [mulEnergy, univ_product_univ, Fintype.card, sq, ← card_product]\n  let f : α × α × α → (α × α) × α × α := fun x => ((x.1 * x.2.2, x.1 * x.2.1), x.2)\n  have : (↑((univ : Finset α) ×ˢ t ×ˢ t) : Set (α × α × α)).InjOn f := by\n    rintro ⟨a₁, b₁, c₁⟩ _ ⟨a₂, b₂, c₂⟩ h₂ h\n    simp_rw [f, Prod.ext_iff] at h\n    obtain ⟨h, rfl, rfl⟩ := h\n    rw [mul_right_cancel h.1]\n  rw [← card_image_of_injOn this]\n  congr with a\n  simp only [mem_filter, mem_product, mem_univ, true_and, mem_image, exists_prop,\n    Prod.exists]\n  refine ⟨fun h => ⟨a.1.1 * a.2.2⁻¹, _, _, h.1, by simp [f, mul_right_comm, h.2]⟩, ?_⟩\n  rintro ⟨b, c, d, hcd, rfl⟩\n  simpa [f, mul_right_comm]\n\n"}
{"name":"Finset.mulEnergy_univ_right","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : CommGroup α\ninst✝ : Fintype α\ns : Finset α\n⊢ Eq (s.mulEnergy Finset.univ) (HMul.hMul (Fintype.card α) (HPow.hPow s.card 2))","decl":"@[to_additive (attr := simp)]\nlemma mulEnergy_univ_right : Eₘ[s, univ] = Fintype.card α * s.card ^ 2 := by\n  rw [mulEnergy_comm, mulEnergy_univ_left]\n\n"}
{"name":"Finset.addEnergy_univ_right","module":"Mathlib.Combinatorics.Additive.Energy","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : AddCommGroup α\ninst✝ : Fintype α\ns : Finset α\n⊢ Eq (s.addEnergy Finset.univ) (HMul.hMul (Fintype.card α) (HPow.hPow s.card 2))","decl":"@[to_additive (attr := simp)]\nlemma mulEnergy_univ_right : Eₘ[s, univ] = Fintype.card α * s.card ^ 2 := by\n  rw [mulEnergy_comm, mulEnergy_univ_left]\n\n"}
