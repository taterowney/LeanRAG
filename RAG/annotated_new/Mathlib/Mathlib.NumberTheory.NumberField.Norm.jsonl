{"name":"Algebra.coe_norm_int","module":"Mathlib.NumberTheory.NumberField.Norm","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : NumberField.RingOfIntegers K\n⊢ Eq (↑((Algebra.norm Int) x)) ((Algebra.norm Rat) ↑x)","decl":"theorem Algebra.coe_norm_int : (Algebra.norm ℤ x : ℚ) = Algebra.norm ℚ (x : K) :=\n  (Algebra.norm_localization (R := ℤ) (Rₘ := ℚ) (S := 𝓞 K) (Sₘ := K) (nonZeroDivisors ℤ) x).symm\n\n"}
{"name":"Algebra.coe_trace_int","module":"Mathlib.NumberTheory.NumberField.Norm","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : NumberField.RingOfIntegers K\n⊢ Eq (↑((Algebra.trace Int (NumberField.RingOfIntegers K)) x)) ((Algebra.trace Rat K) ↑x)","decl":"theorem Algebra.coe_trace_int : (Algebra.trace ℤ _ x : ℚ) = Algebra.trace ℚ K (x : K) :=\n  (Algebra.trace_localization (R := ℤ) (Rₘ := ℚ) (S := 𝓞 K) (Sₘ := K) (nonZeroDivisors ℤ) x).symm\n\n"}
{"name":"RingOfIntegers.coe_norm","module":"Mathlib.NumberTheory.NumberField.Norm","initialProofState":"L : Type u_1\nK : Type u_2\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : FiniteDimensional K L\ninst✝ : Algebra.IsSeparable K L\nx : NumberField.RingOfIntegers L\n⊢ Eq (↑((RingOfIntegers.norm K) x)) ((Algebra.norm K) ↑x)","decl":"@[simp] lemma coe_norm [Algebra.IsSeparable K L] (x : 𝓞 L) :\n  norm K x = Algebra.norm K (x : L) := rfl\n\n"}
{"name":"RingOfIntegers.coe_algebraMap_norm","module":"Mathlib.NumberTheory.NumberField.Norm","initialProofState":"L : Type u_1\nK : Type u_2\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : FiniteDimensional K L\ninst✝ : Algebra.IsSeparable K L\nx : NumberField.RingOfIntegers L\n⊢ Eq (↑((algebraMap (NumberField.RingOfIntegers K) (NumberField.RingOfIntegers L)) ((RingOfIntegers.norm K) x))) ((algebraMap K L) ((Algebra.norm K) ↑x))","decl":"theorem coe_algebraMap_norm [Algebra.IsSeparable K L] (x : 𝓞 L) :\n    (algebraMap (𝓞 K) (𝓞 L) (norm K x) : L) = algebraMap K L (Algebra.norm K (x : L)) :=\n  rfl\n\n"}
{"name":"RingOfIntegers.algebraMap_norm_algebraMap","module":"Mathlib.NumberTheory.NumberField.Norm","initialProofState":"L : Type u_1\nK : Type u_2\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : FiniteDimensional K L\ninst✝ : Algebra.IsSeparable K L\nx : NumberField.RingOfIntegers K\n⊢ Eq ((algebraMap (NumberField.RingOfIntegers K) K) ((RingOfIntegers.norm K) ((algebraMap (NumberField.RingOfIntegers K) (NumberField.RingOfIntegers L)) x))) ((Algebra.norm K) ((algebraMap K L) ((algebraMap (NumberField.RingOfIntegers K) K) x)))","decl":"theorem algebraMap_norm_algebraMap [Algebra.IsSeparable K L] (x : 𝓞 K) :\n    algebraMap _ K (norm K (algebraMap (𝓞 K) (𝓞 L) x)) =\n      Algebra.norm K (algebraMap K L (algebraMap _ _ x)) := rfl\n\n"}
{"name":"RingOfIntegers.norm_algebraMap","module":"Mathlib.NumberTheory.NumberField.Norm","initialProofState":"L : Type u_1\nK : Type u_2\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : FiniteDimensional K L\ninst✝ : Algebra.IsSeparable K L\nx : NumberField.RingOfIntegers K\n⊢ Eq ((RingOfIntegers.norm K) ((algebraMap (NumberField.RingOfIntegers K) (NumberField.RingOfIntegers L)) x)) (HPow.hPow x (Module.finrank K L))","decl":"theorem norm_algebraMap [Algebra.IsSeparable K L] (x : 𝓞 K) :\n    norm K (algebraMap (𝓞 K) (𝓞 L) x) = x ^ finrank K L := by\n  rw [RingOfIntegers.ext_iff, RingOfIntegers.coe_eq_algebraMap,\n    RingOfIntegers.algebraMap_norm_algebraMap, Algebra.norm_algebraMap,\n    RingOfIntegers.coe_eq_algebraMap, map_pow]\n\n"}
{"name":"RingOfIntegers.isUnit_norm_of_isGalois","module":"Mathlib.NumberTheory.NumberField.Norm","initialProofState":"L : Type u_1\nK : Type u_2\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : FiniteDimensional K L\ninst✝ : IsGalois K L\nx : NumberField.RingOfIntegers L\n⊢ Iff (IsUnit ((RingOfIntegers.norm K) x)) (IsUnit x)","decl":"theorem isUnit_norm_of_isGalois [IsGalois K L] {x : 𝓞 L} : IsUnit (norm K x) ↔ IsUnit x := by\n  classical\n  refine ⟨fun hx => ?_, IsUnit.map _⟩\n  replace hx : IsUnit (algebraMap (𝓞 K) (𝓞 L) <| norm K x) := hx.map (algebraMap (𝓞 K) <| 𝓞 L)\n  refine @isUnit_of_mul_isUnit_right (𝓞 L) _\n    ⟨(univ \\ {AlgEquiv.refl}).prod fun σ : L ≃ₐ[K] L => σ x,\n      prod_mem fun σ _ => x.2.map (σ : L →+* L).toIntAlgHom⟩ _ ?_\n  convert hx using 1\n  ext\n  convert_to ((univ \\ {AlgEquiv.refl}).prod fun σ : L ≃ₐ[K] L => σ x) *\n    ∏ σ ∈ {(AlgEquiv.refl : L ≃ₐ[K] L)}, σ x = _\n  · rw [prod_singleton, AlgEquiv.coe_refl, _root_.id, RingOfIntegers.coe_eq_algebraMap, map_mul,\n      RingOfIntegers.map_mk]\n  · rw [prod_sdiff <| subset_univ _, ← norm_eq_prod_automorphisms, coe_algebraMap_norm]\n\n"}
{"name":"RingOfIntegers.dvd_norm","module":"Mathlib.NumberTheory.NumberField.Norm","initialProofState":"L : Type u_1\nK : Type u_2\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : FiniteDimensional K L\ninst✝ : IsGalois K L\nx : NumberField.RingOfIntegers L\n⊢ Dvd.dvd x ((algebraMap (NumberField.RingOfIntegers K) (NumberField.RingOfIntegers L)) ((RingOfIntegers.norm K) x))","decl":"/-- If `L/K` is a finite Galois extension of fields, then, for all `(x : 𝓞 L)` we have that\n`x ∣ algebraMap (𝓞 K) (𝓞 L) (norm K x)`. -/\ntheorem dvd_norm [IsGalois K L] (x : 𝓞 L) : x ∣ algebraMap (𝓞 K) (𝓞 L) (norm K x) := by\n  classical\n  have hint :\n    IsIntegral ℤ (∏ σ ∈ univ.erase (AlgEquiv.refl : L ≃ₐ[K] L), σ x) :=\n    IsIntegral.prod _ (fun σ _ =>\n      ((RingOfIntegers.isIntegral_coe x).map σ))\n  refine ⟨⟨_, hint⟩, ?_⟩\n  ext\n  rw [coe_algebraMap_norm K x, norm_eq_prod_automorphisms]\n  simp [← Finset.mul_prod_erase _ _ (mem_univ AlgEquiv.refl)]\n\n"}
{"name":"RingOfIntegers.norm_norm","module":"Mathlib.NumberTheory.NumberField.Norm","initialProofState":"L : Type u_1\nK : Type u_2\ninst✝¹² : Field K\ninst✝¹¹ : Field L\ninst✝¹⁰ : Algebra K L\ninst✝⁹ : FiniteDimensional K L\nF : Type u_3\ninst✝⁸ : Field F\ninst✝⁷ : Algebra K F\ninst✝⁶ : Algebra.IsSeparable K F\ninst✝⁵ : FiniteDimensional K F\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : Algebra F L\ninst✝² : Algebra.IsSeparable F L\ninst✝¹ : FiniteDimensional F L\ninst✝ : IsScalarTower K F L\nx : NumberField.RingOfIntegers L\n⊢ Eq ((RingOfIntegers.norm K) ((RingOfIntegers.norm F) x)) ((RingOfIntegers.norm K) x)","decl":"theorem norm_norm [Algebra.IsSeparable K L] [Algebra F L] [Algebra.IsSeparable F L]\n    [FiniteDimensional F L] [IsScalarTower K F L] (x : 𝓞 L) : norm K (norm F x) = norm K x := by\n  rw [RingOfIntegers.ext_iff, coe_norm, coe_norm, coe_norm, Algebra.norm_norm]\n\n"}
{"name":"RingOfIntegers.isUnit_norm","module":"Mathlib.NumberTheory.NumberField.Norm","initialProofState":"K : Type u_2\ninst✝⁵ : Field K\nF : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Algebra K F\ninst✝² : Algebra.IsSeparable K F\ninst✝¹ : FiniteDimensional K F\ninst✝ : CharZero K\nx : NumberField.RingOfIntegers F\n⊢ Iff (IsUnit ((RingOfIntegers.norm K) x)) (IsUnit x)","decl":"theorem isUnit_norm [CharZero K] {x : 𝓞 F} : IsUnit (norm K x) ↔ IsUnit x := by\n  letI : Algebra K (AlgebraicClosure K) := AlgebraicClosure.instAlgebra K\n  let L := normalClosure K F (AlgebraicClosure F)\n  haveI : FiniteDimensional F L := FiniteDimensional.right K F L\n  haveI : IsAlgClosure K (AlgebraicClosure F) :=\n    IsAlgClosure.ofAlgebraic K F (AlgebraicClosure F)\n  haveI : IsGalois F L := IsGalois.tower_top_of_isGalois K F L\n  calc\n    IsUnit (norm K x) ↔ IsUnit ((norm K) x ^ finrank F L) :=\n      (isUnit_pow_iff (pos_iff_ne_zero.mp finrank_pos)).symm\n    _ ↔ IsUnit (norm K (algebraMap (𝓞 F) (𝓞 L) x)) := by\n      rw [← norm_norm K F (algebraMap (𝓞 F) (𝓞 L) x), norm_algebraMap F _, map_pow]\n    _ ↔ IsUnit (algebraMap (𝓞 F) (𝓞 L) x) := isUnit_norm_of_isGalois K\n    _ ↔ IsUnit (norm F (algebraMap (𝓞 F) (𝓞 L) x)) := (isUnit_norm_of_isGalois F).symm\n    _ ↔ IsUnit (x ^ finrank F L) := (congr_arg IsUnit (norm_algebraMap F _)).to_iff\n    _ ↔ IsUnit x := isUnit_pow_iff (pos_iff_ne_zero.mp finrank_pos)\n\n"}
