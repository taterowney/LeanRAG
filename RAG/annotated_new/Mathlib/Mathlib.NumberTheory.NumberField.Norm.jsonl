{"name":"Algebra.coe_norm_int","module":"Mathlib.NumberTheory.NumberField.Norm","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.RingOfIntegers K\nâŠ¢ Eq (â†‘((Algebra.norm Int) x)) ((Algebra.norm Rat) â†‘x)","decl":"theorem Algebra.coe_norm_int : (Algebra.norm â„¤ x : â„š) = Algebra.norm â„š (x : K) :=\n  (Algebra.norm_localization (R := â„¤) (Râ‚˜ := â„š) (S := ğ“ K) (Sâ‚˜ := K) (nonZeroDivisors â„¤) x).symm\n\n"}
{"name":"Algebra.coe_trace_int","module":"Mathlib.NumberTheory.NumberField.Norm","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.RingOfIntegers K\nâŠ¢ Eq (â†‘((Algebra.trace Int (NumberField.RingOfIntegers K)) x)) ((Algebra.trace Rat K) â†‘x)","decl":"theorem Algebra.coe_trace_int : (Algebra.trace â„¤ _ x : â„š) = Algebra.trace â„š K (x : K) :=\n  (Algebra.trace_localization (R := â„¤) (Râ‚˜ := â„š) (S := ğ“ K) (Sâ‚˜ := K) (nonZeroDivisors â„¤) x).symm\n\n"}
{"name":"RingOfIntegers.coe_norm","module":"Mathlib.NumberTheory.NumberField.Norm","initialProofState":"L : Type u_1\nK : Type u_2\ninstâœâ´ : Field K\ninstâœÂ³ : Field L\ninstâœÂ² : Algebra K L\ninstâœÂ¹ : FiniteDimensional K L\ninstâœ : Algebra.IsSeparable K L\nx : NumberField.RingOfIntegers L\nâŠ¢ Eq (â†‘((RingOfIntegers.norm K) x)) ((Algebra.norm K) â†‘x)","decl":"@[simp] lemma coe_norm [Algebra.IsSeparable K L] (x : ğ“ L) :\n  norm K x = Algebra.norm K (x : L) := rfl\n\n"}
{"name":"RingOfIntegers.coe_algebraMap_norm","module":"Mathlib.NumberTheory.NumberField.Norm","initialProofState":"L : Type u_1\nK : Type u_2\ninstâœâ´ : Field K\ninstâœÂ³ : Field L\ninstâœÂ² : Algebra K L\ninstâœÂ¹ : FiniteDimensional K L\ninstâœ : Algebra.IsSeparable K L\nx : NumberField.RingOfIntegers L\nâŠ¢ Eq (â†‘((algebraMap (NumberField.RingOfIntegers K) (NumberField.RingOfIntegers L)) ((RingOfIntegers.norm K) x))) ((algebraMap K L) ((Algebra.norm K) â†‘x))","decl":"theorem coe_algebraMap_norm [Algebra.IsSeparable K L] (x : ğ“ L) :\n    (algebraMap (ğ“ K) (ğ“ L) (norm K x) : L) = algebraMap K L (Algebra.norm K (x : L)) :=\n  rfl\n\n"}
{"name":"RingOfIntegers.algebraMap_norm_algebraMap","module":"Mathlib.NumberTheory.NumberField.Norm","initialProofState":"L : Type u_1\nK : Type u_2\ninstâœâ´ : Field K\ninstâœÂ³ : Field L\ninstâœÂ² : Algebra K L\ninstâœÂ¹ : FiniteDimensional K L\ninstâœ : Algebra.IsSeparable K L\nx : NumberField.RingOfIntegers K\nâŠ¢ Eq ((algebraMap (NumberField.RingOfIntegers K) K) ((RingOfIntegers.norm K) ((algebraMap (NumberField.RingOfIntegers K) (NumberField.RingOfIntegers L)) x))) ((Algebra.norm K) ((algebraMap K L) ((algebraMap (NumberField.RingOfIntegers K) K) x)))","decl":"theorem algebraMap_norm_algebraMap [Algebra.IsSeparable K L] (x : ğ“ K) :\n    algebraMap _ K (norm K (algebraMap (ğ“ K) (ğ“ L) x)) =\n      Algebra.norm K (algebraMap K L (algebraMap _ _ x)) := rfl\n\n"}
{"name":"RingOfIntegers.norm_algebraMap","module":"Mathlib.NumberTheory.NumberField.Norm","initialProofState":"L : Type u_1\nK : Type u_2\ninstâœâ´ : Field K\ninstâœÂ³ : Field L\ninstâœÂ² : Algebra K L\ninstâœÂ¹ : FiniteDimensional K L\ninstâœ : Algebra.IsSeparable K L\nx : NumberField.RingOfIntegers K\nâŠ¢ Eq ((RingOfIntegers.norm K) ((algebraMap (NumberField.RingOfIntegers K) (NumberField.RingOfIntegers L)) x)) (HPow.hPow x (Module.finrank K L))","decl":"theorem norm_algebraMap [Algebra.IsSeparable K L] (x : ğ“ K) :\n    norm K (algebraMap (ğ“ K) (ğ“ L) x) = x ^ finrank K L := by\n  rw [RingOfIntegers.ext_iff, RingOfIntegers.coe_eq_algebraMap,\n    RingOfIntegers.algebraMap_norm_algebraMap, Algebra.norm_algebraMap,\n    RingOfIntegers.coe_eq_algebraMap, map_pow]\n\n"}
{"name":"RingOfIntegers.isUnit_norm_of_isGalois","module":"Mathlib.NumberTheory.NumberField.Norm","initialProofState":"L : Type u_1\nK : Type u_2\ninstâœâ´ : Field K\ninstâœÂ³ : Field L\ninstâœÂ² : Algebra K L\ninstâœÂ¹ : FiniteDimensional K L\ninstâœ : IsGalois K L\nx : NumberField.RingOfIntegers L\nâŠ¢ Iff (IsUnit ((RingOfIntegers.norm K) x)) (IsUnit x)","decl":"theorem isUnit_norm_of_isGalois [IsGalois K L] {x : ğ“ L} : IsUnit (norm K x) â†” IsUnit x := by\n  classical\n  refine âŸ¨fun hx => ?_, IsUnit.map _âŸ©\n  replace hx : IsUnit (algebraMap (ğ“ K) (ğ“ L) <| norm K x) := hx.map (algebraMap (ğ“ K) <| ğ“ L)\n  refine @isUnit_of_mul_isUnit_right (ğ“ L) _\n    âŸ¨(univ \\ {AlgEquiv.refl}).prod fun Ïƒ : L â‰ƒâ‚[K] L => Ïƒ x,\n      prod_mem fun Ïƒ _ => x.2.map (Ïƒ : L â†’+* L).toIntAlgHomâŸ© _ ?_\n  convert hx using 1\n  ext\n  convert_to ((univ \\ {AlgEquiv.refl}).prod fun Ïƒ : L â‰ƒâ‚[K] L => Ïƒ x) *\n    âˆ Ïƒ âˆˆ {(AlgEquiv.refl : L â‰ƒâ‚[K] L)}, Ïƒ x = _\n  Â· rw [prod_singleton, AlgEquiv.coe_refl, _root_.id, RingOfIntegers.coe_eq_algebraMap, map_mul,\n      RingOfIntegers.map_mk]\n  Â· rw [prod_sdiff <| subset_univ _, â† norm_eq_prod_automorphisms, coe_algebraMap_norm]\n\n"}
{"name":"RingOfIntegers.dvd_norm","module":"Mathlib.NumberTheory.NumberField.Norm","initialProofState":"L : Type u_1\nK : Type u_2\ninstâœâ´ : Field K\ninstâœÂ³ : Field L\ninstâœÂ² : Algebra K L\ninstâœÂ¹ : FiniteDimensional K L\ninstâœ : IsGalois K L\nx : NumberField.RingOfIntegers L\nâŠ¢ Dvd.dvd x ((algebraMap (NumberField.RingOfIntegers K) (NumberField.RingOfIntegers L)) ((RingOfIntegers.norm K) x))","decl":"/-- If `L/K` is a finite Galois extension of fields, then, for all `(x : ğ“ L)` we have that\n`x âˆ£ algebraMap (ğ“ K) (ğ“ L) (norm K x)`. -/\ntheorem dvd_norm [IsGalois K L] (x : ğ“ L) : x âˆ£ algebraMap (ğ“ K) (ğ“ L) (norm K x) := by\n  classical\n  have hint :\n    IsIntegral â„¤ (âˆ Ïƒ âˆˆ univ.erase (AlgEquiv.refl : L â‰ƒâ‚[K] L), Ïƒ x) :=\n    IsIntegral.prod _ (fun Ïƒ _ =>\n      ((RingOfIntegers.isIntegral_coe x).map Ïƒ))\n  refine âŸ¨âŸ¨_, hintâŸ©, ?_âŸ©\n  ext\n  rw [coe_algebraMap_norm K x, norm_eq_prod_automorphisms]\n  simp [â† Finset.mul_prod_erase _ _ (mem_univ AlgEquiv.refl)]\n\n"}
{"name":"RingOfIntegers.norm_norm","module":"Mathlib.NumberTheory.NumberField.Norm","initialProofState":"L : Type u_1\nK : Type u_2\ninstâœÂ¹Â² : Field K\ninstâœÂ¹Â¹ : Field L\ninstâœÂ¹â° : Algebra K L\ninstâœâ¹ : FiniteDimensional K L\nF : Type u_3\ninstâœâ¸ : Field F\ninstâœâ· : Algebra K F\ninstâœâ¶ : Algebra.IsSeparable K F\ninstâœâµ : FiniteDimensional K F\ninstâœâ´ : Algebra.IsSeparable K L\ninstâœÂ³ : Algebra F L\ninstâœÂ² : Algebra.IsSeparable F L\ninstâœÂ¹ : FiniteDimensional F L\ninstâœ : IsScalarTower K F L\nx : NumberField.RingOfIntegers L\nâŠ¢ Eq ((RingOfIntegers.norm K) ((RingOfIntegers.norm F) x)) ((RingOfIntegers.norm K) x)","decl":"theorem norm_norm [Algebra.IsSeparable K L] [Algebra F L] [Algebra.IsSeparable F L]\n    [FiniteDimensional F L] [IsScalarTower K F L] (x : ğ“ L) : norm K (norm F x) = norm K x := by\n  rw [RingOfIntegers.ext_iff, coe_norm, coe_norm, coe_norm, Algebra.norm_norm]\n\n"}
{"name":"RingOfIntegers.isUnit_norm","module":"Mathlib.NumberTheory.NumberField.Norm","initialProofState":"K : Type u_2\ninstâœâµ : Field K\nF : Type u_3\ninstâœâ´ : Field F\ninstâœÂ³ : Algebra K F\ninstâœÂ² : Algebra.IsSeparable K F\ninstâœÂ¹ : FiniteDimensional K F\ninstâœ : CharZero K\nx : NumberField.RingOfIntegers F\nâŠ¢ Iff (IsUnit ((RingOfIntegers.norm K) x)) (IsUnit x)","decl":"theorem isUnit_norm [CharZero K] {x : ğ“ F} : IsUnit (norm K x) â†” IsUnit x := by\n  letI : Algebra K (AlgebraicClosure K) := AlgebraicClosure.instAlgebra K\n  let L := normalClosure K F (AlgebraicClosure F)\n  haveI : FiniteDimensional F L := FiniteDimensional.right K F L\n  haveI : IsAlgClosure K (AlgebraicClosure F) :=\n    IsAlgClosure.ofAlgebraic K F (AlgebraicClosure F)\n  haveI : IsGalois F L := IsGalois.tower_top_of_isGalois K F L\n  calc\n    IsUnit (norm K x) â†” IsUnit ((norm K) x ^ finrank F L) :=\n      (isUnit_pow_iff (pos_iff_ne_zero.mp finrank_pos)).symm\n    _ â†” IsUnit (norm K (algebraMap (ğ“ F) (ğ“ L) x)) := by\n      rw [â† norm_norm K F (algebraMap (ğ“ F) (ğ“ L) x), norm_algebraMap F _, map_pow]\n    _ â†” IsUnit (algebraMap (ğ“ F) (ğ“ L) x) := isUnit_norm_of_isGalois K\n    _ â†” IsUnit (norm F (algebraMap (ğ“ F) (ğ“ L) x)) := (isUnit_norm_of_isGalois F).symm\n    _ â†” IsUnit (x ^ finrank F L) := (congr_arg IsUnit (norm_algebraMap F _)).to_iff\n    _ â†” IsUnit x := isUnit_pow_iff (pos_iff_ne_zero.mp finrank_pos)\n\n"}
