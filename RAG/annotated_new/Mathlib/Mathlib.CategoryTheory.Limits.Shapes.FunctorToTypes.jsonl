{"name":"CategoryTheory.FunctorToTypes.prod.fst_app","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\nx✝ : C\na : (CategoryTheory.FunctorToTypes.prod F G).obj x✝\n⊢ Eq (CategoryTheory.FunctorToTypes.prod.fst.app x✝ a) a.1","decl":"/-- The first projection of `prod F G`, onto `F`. -/\n@[simps]\ndef prod.fst : prod F G ⟶ F where\n  app _ a := a.1\n\n"}
{"name":"CategoryTheory.FunctorToTypes.prod.snd_app","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\nx✝ : C\na : (CategoryTheory.FunctorToTypes.prod F G).obj x✝\n⊢ Eq (CategoryTheory.FunctorToTypes.prod.snd.app x✝ a) a.2","decl":"/-- The second projection of `prod F G`, onto `G`. -/\n@[simps]\ndef prod.snd : prod F G ⟶ G where\n  app _ a := a.2\n\n"}
{"name":"CategoryTheory.FunctorToTypes.prod.lift_app","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF F₁ F₂ : CategoryTheory.Functor C (Type w)\nτ₁ : Quiver.Hom F F₁\nτ₂ : Quiver.Hom F F₂\nx : C\ny : F.obj x\n⊢ Eq ((CategoryTheory.FunctorToTypes.prod.lift τ₁ τ₂).app x y) { fst := τ₁.app x y, snd := τ₂.app x y }","decl":"/-- Given natural transformations `F ⟶ F₁` and `F ⟶ F₂`, construct\na natural transformation `F ⟶ prod F₁ F₂`. -/\n@[simps]\ndef prod.lift {F₁ F₂ : C ⥤ Type w} (τ₁ : F ⟶ F₁) (τ₂ : F ⟶ F₂) :\n    F ⟶ prod F₁ F₂ where\n  app x y := ⟨τ₁.app x y, τ₂.app x y⟩\n  naturality _ _ _ := by\n    ext a\n    simp only [types_comp_apply, FunctorToTypes.naturality]\n    aesop\n\n"}
{"name":"CategoryTheory.FunctorToTypes.prod.lift_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF F₁ F₂ : CategoryTheory.Functor C (Type w)\nτ₁ : Quiver.Hom F F₁\nτ₂ : Quiver.Hom F F₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.FunctorToTypes.prod.lift τ₁ τ₂) CategoryTheory.FunctorToTypes.prod.fst) τ₁","decl":"@[simp]\nlemma prod.lift_fst {F₁ F₂ : C ⥤ Type w} (τ₁ : F ⟶ F₁) (τ₂ : F ⟶ F₂) :\n    prod.lift τ₁ τ₂ ≫ prod.fst = τ₁ := rfl\n\n"}
{"name":"CategoryTheory.FunctorToTypes.prod.lift_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF F₁ F₂ : CategoryTheory.Functor C (Type w)\nτ₁ : Quiver.Hom F F₁\nτ₂ : Quiver.Hom F F₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.FunctorToTypes.prod.lift τ₁ τ₂) CategoryTheory.FunctorToTypes.prod.snd) τ₂","decl":"@[simp]\nlemma prod.lift_snd {F₁ F₂ : C ⥤ Type w} (τ₁ : F ⟶ F₁) (τ₂ : F ⟶ F₂) :\n    prod.lift τ₁ τ₂ ≫ prod.snd = τ₂ := rfl\n\n"}
{"name":"CategoryTheory.FunctorToTypes.binaryProductCone_pt_map","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\na : Prod (F.obj X✝) (G.obj X✝)\n⊢ Eq ((CategoryTheory.FunctorToTypes.binaryProductCone F G).pt.map f a) { fst := F.map f a.1, snd := G.map f a.2 }","decl":"/-- The binary fan whose point is `prod F G`. -/\n@[simps!]\ndef binaryProductCone : BinaryFan F G :=\n  BinaryFan.mk prod.fst prod.snd\n\n"}
{"name":"CategoryTheory.FunctorToTypes.binaryProductCone_π_app","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\nx✝ : CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair\n⊢ Eq ((CategoryTheory.FunctorToTypes.binaryProductCone F G).π.app x✝) (CategoryTheory.Limits.WalkingPair.swap.match_1 (fun j => Quiver.Hom (CategoryTheory.FunctorToTypes.prod F G) ((CategoryTheory.Limits.pair F G).obj { as := j })) x✝.as (fun _ => CategoryTheory.FunctorToTypes.prod.fst) fun _ => CategoryTheory.FunctorToTypes.prod.snd)","decl":"/-- The binary fan whose point is `prod F G`. -/\n@[simps!]\ndef binaryProductCone : BinaryFan F G :=\n  BinaryFan.mk prod.fst prod.snd\n\n"}
{"name":"CategoryTheory.FunctorToTypes.binaryProductCone_pt_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\na : C\n⊢ Eq ((CategoryTheory.FunctorToTypes.binaryProductCone F G).pt.obj a) (Prod (F.obj a) (G.obj a))","decl":"/-- The binary fan whose point is `prod F G`. -/\n@[simps!]\ndef binaryProductCone : BinaryFan F G :=\n  BinaryFan.mk prod.fst prod.snd\n\n"}
{"name":"CategoryTheory.FunctorToTypes.binaryProductLimit_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\ns : CategoryTheory.Limits.BinaryFan F G\n⊢ Eq ((CategoryTheory.FunctorToTypes.binaryProductLimit F G).lift s) (CategoryTheory.FunctorToTypes.prod.lift s.fst s.snd)","decl":"/-- `prod F G` is a limit cone. -/\n@[simps]\ndef binaryProductLimit : IsLimit (binaryProductCone F G) where\n  lift (s : BinaryFan F G) := prod.lift s.fst s.snd\n  fac _ := fun ⟨j⟩ ↦ WalkingPair.casesOn j rfl rfl\n  uniq _ _ h := by\n    simp only [← h ⟨WalkingPair.right⟩, ← h ⟨WalkingPair.left⟩]\n    congr\n\n"}
{"name":"CategoryTheory.FunctorToTypes.binaryProductIso_hom_comp_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.FunctorToTypes.binaryProductIso F G).hom CategoryTheory.FunctorToTypes.prod.fst) CategoryTheory.Limits.prod.fst","decl":"@[simp]\nlemma binaryProductIso_hom_comp_fst :\n    (binaryProductIso F G).hom ≫ prod.fst = Limits.prod.fst := rfl\n\n"}
{"name":"CategoryTheory.FunctorToTypes.binaryProductIso_hom_comp_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.FunctorToTypes.binaryProductIso F G).hom CategoryTheory.FunctorToTypes.prod.snd) CategoryTheory.Limits.prod.snd","decl":"@[simp]\nlemma binaryProductIso_hom_comp_snd :\n    (binaryProductIso F G).hom ≫ prod.snd = Limits.prod.snd := rfl\n\n"}
{"name":"CategoryTheory.FunctorToTypes.binaryProductIso_inv_comp_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.FunctorToTypes.binaryProductIso F G).inv CategoryTheory.Limits.prod.fst) CategoryTheory.FunctorToTypes.prod.fst","decl":"@[simp]\nlemma binaryProductIso_inv_comp_fst :\n    (binaryProductIso F G).inv ≫ Limits.prod.fst = prod.fst := by\n  simp [binaryProductIso, binaryProductLimitCone]\n\n"}
{"name":"CategoryTheory.FunctorToTypes.binaryProductIso_inv_comp_fst_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\na : C\nz : (CategoryTheory.FunctorToTypes.prod F G).obj a\n⊢ Eq (CategoryTheory.Limits.prod.fst.app a ((CategoryTheory.FunctorToTypes.binaryProductIso F G).inv.app a z)) z.1","decl":"@[simp]\nlemma binaryProductIso_inv_comp_fst_apply (a : C) (z : (prod F G).obj a) :\n    (Limits.prod.fst (X := F)).app a ((binaryProductIso F G).inv.app a z) = z.1 :=\n  congr_fun (congr_app (binaryProductIso_inv_comp_fst F G) a) z\n\n"}
{"name":"CategoryTheory.FunctorToTypes.binaryProductIso_inv_comp_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.FunctorToTypes.binaryProductIso F G).inv CategoryTheory.Limits.prod.snd) CategoryTheory.FunctorToTypes.prod.snd","decl":"@[simp]\nlemma binaryProductIso_inv_comp_snd :\n    (binaryProductIso F G).inv ≫ Limits.prod.snd = prod.snd := by\n  simp [binaryProductIso, binaryProductLimitCone]\n\n"}
{"name":"CategoryTheory.FunctorToTypes.binaryProductIso_inv_comp_snd_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\na : C\nz : (CategoryTheory.FunctorToTypes.prod F G).obj a\n⊢ Eq (CategoryTheory.Limits.prod.snd.app a ((CategoryTheory.FunctorToTypes.binaryProductIso F G).inv.app a z)) z.2","decl":"@[simp]\nlemma binaryProductIso_inv_comp_snd_apply (a : C) (z : (prod F G).obj a) :\n    (Limits.prod.snd (X := F)).app a ((binaryProductIso F G).inv.app a z) = z.2 :=\n  congr_fun (congr_app (binaryProductIso_inv_comp_snd F G) a) z\n\n"}
{"name":"CategoryTheory.FunctorToTypes.prodMk_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\na : C\nx : F.obj a\ny : G.obj a\n⊢ Eq (CategoryTheory.Limits.prod.fst.app a (CategoryTheory.FunctorToTypes.prodMk x y)) x","decl":"@[simp]\nlemma prodMk_fst {a : C} (x : F.obj a) (y : G.obj a) :\n    (Limits.prod.fst (X := F)).app a (prodMk x y) = x := by\n  simp only [prodMk, binaryProductIso_inv_comp_fst_apply]\n\n"}
{"name":"CategoryTheory.FunctorToTypes.prodMk_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\na : C\nx : F.obj a\ny : G.obj a\n⊢ Eq (CategoryTheory.Limits.prod.snd.app a (CategoryTheory.FunctorToTypes.prodMk x y)) y","decl":"@[simp]\nlemma prodMk_snd {a : C} (x : F.obj a) (y : G.obj a) :\n    (Limits.prod.snd (X := F)).app a (prodMk x y) = y := by\n  simp only [prodMk, binaryProductIso_inv_comp_snd_apply]\n\n"}
{"name":"CategoryTheory.FunctorToTypes.prod_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\na : C\nz w : (CategoryTheory.FunctorToTypes.prod F G).obj a\n⊢ Iff (Eq z w) (And (Eq z.1 w.1) (Eq z.2 w.2))","decl":"@[ext]\nlemma prod_ext {a : C} (z w : (prod F G).obj a) (h1 : z.1 = w.1) (h2 : z.2 = w.2) :\n    z = w := Prod.ext h1 h2\n\n"}
{"name":"CategoryTheory.FunctorToTypes.prod_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\na : C\nz w : (CategoryTheory.FunctorToTypes.prod F G).obj a\nh1 : Eq z.1 w.1\nh2 : Eq z.2 w.2\n⊢ Eq z w","decl":"@[ext]\nlemma prod_ext {a : C} (z w : (prod F G).obj a) (h1 : z.1 = w.1) (h2 : z.2 = w.2) :\n    z = w := Prod.ext h1 h2\n\n"}
{"name":"CategoryTheory.FunctorToTypes.binaryProductEquiv_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\na : C\nz : (CategoryTheory.Limits.prod F G).obj a\n⊢ Eq ((CategoryTheory.FunctorToTypes.binaryProductEquiv F G a) z) { fst := ((CategoryTheory.FunctorToTypes.binaryProductIso F G).hom.app a z).1, snd := ((CategoryTheory.FunctorToTypes.binaryProductIso F G).hom.app a z).2 }","decl":"/-- `(F ⨯ G).obj a` is in bijection with the product of `F.obj a` and `G.obj a`. -/\n@[simps]\nnoncomputable\ndef binaryProductEquiv (a : C) : (F ⨯ G).obj a ≃ (F.obj a) × (G.obj a) where\n  toFun z := ⟨((binaryProductIso F G).hom.app a z).1, ((binaryProductIso F G).hom.app a z).2⟩\n  invFun z := prodMk z.1 z.2\n  left_inv _ := by simp [prodMk]\n  right_inv _ := by simp [prodMk]\n\n"}
{"name":"CategoryTheory.FunctorToTypes.binaryProductEquiv_symm_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\na : C\nz : Prod (F.obj a) (G.obj a)\n⊢ Eq ((CategoryTheory.FunctorToTypes.binaryProductEquiv F G a).symm z) (CategoryTheory.FunctorToTypes.prodMk z.1 z.2)","decl":"/-- `(F ⨯ G).obj a` is in bijection with the product of `F.obj a` and `G.obj a`. -/\n@[simps]\nnoncomputable\ndef binaryProductEquiv (a : C) : (F ⨯ G).obj a ≃ (F.obj a) × (G.obj a) where\n  toFun z := ⟨((binaryProductIso F G).hom.app a z).1, ((binaryProductIso F G).hom.app a z).2⟩\n  invFun z := prodMk z.1 z.2\n  left_inv _ := by simp [prodMk]\n  right_inv _ := by simp [prodMk]\n\n"}
{"name":"CategoryTheory.FunctorToTypes.prod_ext'_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\na : C\nz w : (CategoryTheory.Limits.prod F G).obj a\n⊢ Iff (Eq z w) (And (Eq (CategoryTheory.Limits.prod.fst.app a z) (CategoryTheory.Limits.prod.fst.app a w)) (Eq (CategoryTheory.Limits.prod.snd.app a z) (CategoryTheory.Limits.prod.snd.app a w)))","decl":"@[ext]\nlemma prod_ext' (a : C) (z w : (F ⨯ G).obj a)\n    (h1 : (Limits.prod.fst (X := F)).app a z = (Limits.prod.fst (X := F)).app a w)\n    (h2 : (Limits.prod.snd (X := F)).app a z = (Limits.prod.snd (X := F)).app a w) :\n    z = w := by\n  apply Equiv.injective (binaryProductEquiv F G a)\n  aesop\n\n"}
{"name":"CategoryTheory.FunctorToTypes.prod_ext'","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\na : C\nz w : (CategoryTheory.Limits.prod F G).obj a\nh1 : Eq (CategoryTheory.Limits.prod.fst.app a z) (CategoryTheory.Limits.prod.fst.app a w)\nh2 : Eq (CategoryTheory.Limits.prod.snd.app a z) (CategoryTheory.Limits.prod.snd.app a w)\n⊢ Eq z w","decl":"@[ext]\nlemma prod_ext' (a : C) (z w : (F ⨯ G).obj a)\n    (h1 : (Limits.prod.fst (X := F)).app a z = (Limits.prod.fst (X := F)).app a w)\n    (h2 : (Limits.prod.snd (X := F)).app a z = (Limits.prod.snd (X := F)).app a w) :\n    z = w := by\n  apply Equiv.injective (binaryProductEquiv F G a)\n  aesop\n\n"}
{"name":"CategoryTheory.FunctorToTypes.coprod.inl_app","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\nx✝ : C\nx : F.obj x✝\n⊢ Eq (CategoryTheory.FunctorToTypes.coprod.inl.app x✝ x) (Sum.inl x)","decl":"/-- The left inclusion of `F` into `coprod F G`. -/\n@[simps]\ndef coprod.inl : F ⟶ coprod F G where\n  app _ x := .inl x\n\n"}
{"name":"CategoryTheory.FunctorToTypes.coprod.inr_app","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\nx✝ : C\nx : G.obj x✝\n⊢ Eq (CategoryTheory.FunctorToTypes.coprod.inr.app x✝ x) (Sum.inr x)","decl":"/-- The right inclusion of `G` into `coprod F G`. -/\n@[simps]\ndef coprod.inr : G ⟶ coprod F G where\n  app _ x := .inr x\n\n"}
{"name":"CategoryTheory.FunctorToTypes.coprod.desc_app","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF F₁ F₂ : CategoryTheory.Functor C (Type w)\nτ₁ : Quiver.Hom F₁ F\nτ₂ : Quiver.Hom F₂ F\na : C\nx : (CategoryTheory.FunctorToTypes.coprod F₁ F₂).obj a\n⊢ Eq ((CategoryTheory.FunctorToTypes.coprod.desc τ₁ τ₂).app a x) (Sum.casesOn (motive := fun t => Eq x t → F.obj a) x (fun x_1 h => τ₁.app a x_1) (fun x_1 h => τ₂.app a x_1) ⋯)","decl":"/-- Given natural transformations `F₁ ⟶ F` and `F₂ ⟶ F`, construct\na natural transformation `coprod F₁ F₂ ⟶ F`. -/\n@[simps]\ndef coprod.desc {F₁ F₂ : C ⥤ Type w} (τ₁ : F₁ ⟶ F) (τ₂ : F₂ ⟶ F) :\n    coprod F₁ F₂ ⟶ F where\n  app a x := by\n     cases x with\n     | inl x => exact τ₁.app a x\n     | inr x => exact τ₂.app a x\n  naturality _ _ _ := by\n    ext x\n    cases x with | _ => simp only [coprod, types_comp_apply, FunctorToTypes.naturality]\n\n"}
{"name":"CategoryTheory.FunctorToTypes.coprod.desc_inl","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF F₁ F₂ : CategoryTheory.Functor C (Type w)\nτ₁ : Quiver.Hom F₁ F\nτ₂ : Quiver.Hom F₂ F\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.FunctorToTypes.coprod.inl (CategoryTheory.FunctorToTypes.coprod.desc τ₁ τ₂)) τ₁","decl":"@[simp]\nlemma coprod.desc_inl {F₁ F₂ : C ⥤ Type w} (τ₁ : F₁ ⟶ F) (τ₂ : F₂ ⟶ F) :\n    coprod.inl ≫ coprod.desc τ₁ τ₂ = τ₁ := rfl\n\n"}
{"name":"CategoryTheory.FunctorToTypes.coprod.desc_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF F₁ F₂ : CategoryTheory.Functor C (Type w)\nτ₁ : Quiver.Hom F₁ F\nτ₂ : Quiver.Hom F₂ F\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.FunctorToTypes.coprod.inr (CategoryTheory.FunctorToTypes.coprod.desc τ₁ τ₂)) τ₂","decl":"@[simp]\nlemma coprod.desc_inr {F₁ F₂ : C ⥤ Type w} (τ₁ : F₁ ⟶ F) (τ₂ : F₂ ⟶ F) :\n    coprod.inr ≫ coprod.desc τ₁ τ₂ = τ₂ := rfl\n\n"}
{"name":"CategoryTheory.FunctorToTypes.binaryCoproductCocone_pt_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\na : C\n⊢ Eq ((CategoryTheory.FunctorToTypes.binaryCoproductCocone F G).pt.obj a) (Sum (F.obj a) (G.obj a))","decl":"/-- The binary cofan whose point is `coprod F G`. -/\n@[simps!]\ndef binaryCoproductCocone : BinaryCofan F G :=\n  BinaryCofan.mk coprod.inl coprod.inr\n\n"}
{"name":"CategoryTheory.FunctorToTypes.binaryCoproductCocone_ι_app","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\nx✝ : CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair\n⊢ Eq ((CategoryTheory.FunctorToTypes.binaryCoproductCocone F G).ι.app x✝) (CategoryTheory.Limits.WalkingPair.swap.match_1 (fun j => Quiver.Hom ((CategoryTheory.Limits.pair F G).obj { as := j }) (CategoryTheory.FunctorToTypes.coprod F G)) x✝.as (fun _ => CategoryTheory.FunctorToTypes.coprod.inl) fun _ => CategoryTheory.FunctorToTypes.coprod.inr)","decl":"/-- The binary cofan whose point is `coprod F G`. -/\n@[simps!]\ndef binaryCoproductCocone : BinaryCofan F G :=\n  BinaryCofan.mk coprod.inl coprod.inr\n\n"}
{"name":"CategoryTheory.FunctorToTypes.binaryCoproductCocone_pt_map","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\nx : Sum (F.obj X✝) (G.obj X✝)\n⊢ Eq ((CategoryTheory.FunctorToTypes.binaryCoproductCocone F G).pt.map f x) (Sum.rec (motive := fun t => Eq x t → Sum (F.obj Y✝) (G.obj Y✝)) (fun val h => Sum.inl (F.map f val)) (fun val h => Sum.inr (G.map f val)) x ⋯)","decl":"/-- The binary cofan whose point is `coprod F G`. -/\n@[simps!]\ndef binaryCoproductCocone : BinaryCofan F G :=\n  BinaryCofan.mk coprod.inl coprod.inr\n\n"}
{"name":"CategoryTheory.FunctorToTypes.binaryCoproductColimit_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\ns : CategoryTheory.Limits.BinaryCofan F G\n⊢ Eq ((CategoryTheory.FunctorToTypes.binaryCoproductColimit F G).desc s) (CategoryTheory.FunctorToTypes.coprod.desc s.inl s.inr)","decl":"/-- `coprod F G` is a colimit cocone. -/\n@[simps]\ndef binaryCoproductColimit : IsColimit (binaryCoproductCocone F G) where\n  desc (s : BinaryCofan F G) := coprod.desc s.inl s.inr\n  fac _ := fun ⟨j⟩ ↦ WalkingPair.casesOn j rfl rfl\n  uniq _ _ h := by\n    ext _ x\n    cases x with | _ => simp [← h ⟨WalkingPair.right⟩, ← h ⟨WalkingPair.left⟩]\n\n"}
{"name":"CategoryTheory.FunctorToTypes.inl_comp_binaryCoproductIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl (CategoryTheory.FunctorToTypes.binaryCoproductIso F G).hom) CategoryTheory.FunctorToTypes.coprod.inl","decl":"@[simp]\nlemma inl_comp_binaryCoproductIso_hom :\n    Limits.coprod.inl ≫ (binaryCoproductIso F G).hom = coprod.inl := by\n  simp only [binaryCoproductIso]\n  aesop\n\n"}
{"name":"CategoryTheory.FunctorToTypes.inl_comp_binaryCoproductIso_hom_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\na : C\nx : F.obj a\n⊢ Eq ((CategoryTheory.FunctorToTypes.binaryCoproductIso F G).hom.app a (CategoryTheory.Limits.coprod.inl.app a x)) (Sum.inl x)","decl":"@[simp]\nlemma inl_comp_binaryCoproductIso_hom_apply (a : C) (x : F.obj a) :\n    (binaryCoproductIso F G).hom.app a ((Limits.coprod.inl (X := F)).app a x) = .inl x :=\n  congr_fun (congr_app (inl_comp_binaryCoproductIso_hom F G) a) x\n\n"}
{"name":"CategoryTheory.FunctorToTypes.inr_comp_binaryCoproductIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr (CategoryTheory.FunctorToTypes.binaryCoproductIso F G).hom) CategoryTheory.FunctorToTypes.coprod.inr","decl":"@[simp]\nlemma inr_comp_binaryCoproductIso_hom :\n    Limits.coprod.inr ≫ (binaryCoproductIso F G).hom = coprod.inr := by\n  simp [binaryCoproductIso]\n  aesop\n\n"}
{"name":"CategoryTheory.FunctorToTypes.inr_comp_binaryCoproductIso_hom_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\na : C\nx : G.obj a\n⊢ Eq ((CategoryTheory.FunctorToTypes.binaryCoproductIso F G).hom.app a (CategoryTheory.Limits.coprod.inr.app a x)) (Sum.inr x)","decl":"@[simp]\nlemma inr_comp_binaryCoproductIso_hom_apply (a : C) (x : G.obj a) :\n    (binaryCoproductIso F G).hom.app a ((Limits.coprod.inr (X := F)).app a x) = .inr x :=\n  congr_fun (congr_app (inr_comp_binaryCoproductIso_hom F G) a) x\n\n"}
{"name":"CategoryTheory.FunctorToTypes.inl_comp_binaryCoproductIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.FunctorToTypes.coprod.inl (CategoryTheory.FunctorToTypes.binaryCoproductIso F G).inv) CategoryTheory.Limits.coprod.inl","decl":"@[simp]\nlemma inl_comp_binaryCoproductIso_inv :\n    coprod.inl ≫ (binaryCoproductIso F G).inv = (Limits.coprod.inl (X := F)) := rfl\n\n"}
{"name":"CategoryTheory.FunctorToTypes.inl_comp_binaryCoproductIso_inv_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\na : C\nx : F.obj a\n⊢ Eq ((CategoryTheory.FunctorToTypes.binaryCoproductIso F G).inv.app a (Sum.inl x)) (CategoryTheory.Limits.coprod.inl.app a x)","decl":"@[simp]\nlemma inl_comp_binaryCoproductIso_inv_apply (a : C) (x : F.obj a) :\n    (binaryCoproductIso F G).inv.app a (.inl x) = (Limits.coprod.inl (X := F)).app a x := rfl\n\n"}
{"name":"CategoryTheory.FunctorToTypes.inr_comp_binaryCoproductIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.FunctorToTypes.coprod.inr (CategoryTheory.FunctorToTypes.binaryCoproductIso F G).inv) CategoryTheory.Limits.coprod.inr","decl":"@[simp]\nlemma inr_comp_binaryCoproductIso_inv :\n    coprod.inr ≫ (binaryCoproductIso F G).inv = (Limits.coprod.inr (X := F)) := rfl\n\n"}
{"name":"CategoryTheory.FunctorToTypes.inr_comp_binaryCoproductIso_inv_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\na : C\nx : G.obj a\n⊢ Eq ((CategoryTheory.FunctorToTypes.binaryCoproductIso F G).inv.app a (Sum.inr x)) (CategoryTheory.Limits.coprod.inr.app a x)","decl":"@[simp]\nlemma inr_comp_binaryCoproductIso_inv_apply (a : C) (x : G.obj a) :\n    (binaryCoproductIso F G).inv.app a (.inr x) = (Limits.coprod.inr (X := F)).app a x := rfl\n\n"}
{"name":"CategoryTheory.FunctorToTypes.binaryCoproductEquiv_symm_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\na : C\nz : Sum (F.obj a) (G.obj a)\n⊢ Eq ((CategoryTheory.FunctorToTypes.binaryCoproductEquiv F G a).symm z) ((CategoryTheory.FunctorToTypes.binaryCoproductIso F G).inv.app a z)","decl":"/-- `(F ⨿ G).obj a` is in bijection with disjoint union of `F.obj a` and `G.obj a`. -/\n@[simps]\nnoncomputable\ndef binaryCoproductEquiv (a : C) :\n    (F ⨿ G).obj a ≃ (F.obj a) ⊕ (G.obj a) where\n  toFun z := (binaryCoproductIso F G).hom.app a z\n  invFun z := (binaryCoproductIso F G).inv.app a z\n  left_inv _ := by simp only [hom_inv_id_app_apply]\n  right_inv _ := by simp only [inv_hom_id_app_apply]\n\n"}
{"name":"CategoryTheory.FunctorToTypes.binaryCoproductEquiv_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\na : C\nz : (CategoryTheory.Limits.coprod F G).obj a\n⊢ Eq ((CategoryTheory.FunctorToTypes.binaryCoproductEquiv F G a) z) ((CategoryTheory.FunctorToTypes.binaryCoproductIso F G).hom.app a z)","decl":"/-- `(F ⨿ G).obj a` is in bijection with disjoint union of `F.obj a` and `G.obj a`. -/\n@[simps]\nnoncomputable\ndef binaryCoproductEquiv (a : C) :\n    (F ⨿ G).obj a ≃ (F.obj a) ⊕ (G.obj a) where\n  toFun z := (binaryCoproductIso F G).hom.app a z\n  invFun z := (binaryCoproductIso F G).inv.app a z\n  left_inv _ := by simp only [hom_inv_id_app_apply]\n  right_inv _ := by simp only [inv_hom_id_app_apply]\n\n"}
