{"name":"Equidecomp.mk.sizeOf_spec","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝² : SMul G X\ninst✝¹ : SizeOf X\ninst✝ : SizeOf G\ntoPartialEquiv : PartialEquiv X X\nisDecompOn' : Exists fun S => Equidecomp.IsDecompOn (↑toPartialEquiv) toPartialEquiv.source S\n⊢ Eq (SizeOf.sizeOf { toPartialEquiv := toPartialEquiv, isDecompOn' := isDecompOn' }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toPartialEquiv)) (SizeOf.sizeOf isDecompOn'))","decl":"/-- Let `G` act on a space `X`. An `Equidecomposition` with respect to `X` and `G` is a partial\nbijection `f : PartialEquiv X X` with the property that for some set `elements : Finset G`,\n(which we record), for each `a ∈ f.source`, `f a` can be obtained by applying some `g ∈ elements`\ninstead. We call `f` an equidecomposition of `f.source` with `f.target`.\n\nMore familiarly, `f` is the result of partitioning `f.source` into finitely many pieces,\nthen applying a single element of `G` to each to get a partition of `f.target`.\n-/\nstructure _root_.Equidecomp extends PartialEquiv X X where\n  isDecompOn' : ∃ S : Finset G, IsDecompOn toFun source S\n\n"}
{"name":"Equidecomp.mk.injEq","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝ : SMul G X\ntoPartialEquiv✝ : PartialEquiv X X\nisDecompOn'✝ : Exists fun S => Equidecomp.IsDecompOn (↑toPartialEquiv✝) toPartialEquiv✝.source S\ntoPartialEquiv : PartialEquiv X X\nisDecompOn' : Exists fun S => Equidecomp.IsDecompOn (↑toPartialEquiv) toPartialEquiv.source S\n⊢ Eq (Eq { toPartialEquiv := toPartialEquiv✝, isDecompOn' := isDecompOn'✝ } { toPartialEquiv := toPartialEquiv, isDecompOn' := isDecompOn' }) (Eq toPartialEquiv✝ toPartialEquiv)","decl":"/-- Let `G` act on a space `X`. An `Equidecomposition` with respect to `X` and `G` is a partial\nbijection `f : PartialEquiv X X` with the property that for some set `elements : Finset G`,\n(which we record), for each `a ∈ f.source`, `f a` can be obtained by applying some `g ∈ elements`\ninstead. We call `f` an equidecomposition of `f.source` with `f.target`.\n\nMore familiarly, `f` is the result of partitioning `f.source` into finitely many pieces,\nthen applying a single element of `G` to each to get a partition of `f.target`.\n-/\nstructure _root_.Equidecomp extends PartialEquiv X X where\n  isDecompOn' : ∃ S : Finset G, IsDecompOn toFun source S\n\n"}
{"name":"Equidecomp.mk.inj","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝ : SMul G X\ntoPartialEquiv✝ : PartialEquiv X X\nisDecompOn'✝ : Exists fun S => Equidecomp.IsDecompOn (↑toPartialEquiv✝) toPartialEquiv✝.source S\ntoPartialEquiv : PartialEquiv X X\nisDecompOn' : Exists fun S => Equidecomp.IsDecompOn (↑toPartialEquiv) toPartialEquiv.source S\nx✝ : Eq { toPartialEquiv := toPartialEquiv✝, isDecompOn' := isDecompOn'✝ } { toPartialEquiv := toPartialEquiv, isDecompOn' := isDecompOn' }\n⊢ Eq toPartialEquiv✝ toPartialEquiv","decl":"/-- Let `G` act on a space `X`. An `Equidecomposition` with respect to `X` and `G` is a partial\nbijection `f : PartialEquiv X X` with the property that for some set `elements : Finset G`,\n(which we record), for each `a ∈ f.source`, `f a` can be obtained by applying some `g ∈ elements`\ninstead. We call `f` an equidecomposition of `f.source` with `f.target`.\n\nMore familiarly, `f` is the result of partitioning `f.source` into finitely many pieces,\nthen applying a single element of `G` to each to get a partition of `f.target`.\n-/\nstructure _root_.Equidecomp extends PartialEquiv X X where\n  isDecompOn' : ∃ S : Finset G, IsDecompOn toFun source S\n\n"}
{"name":"Equidecomp.isDecompOn'","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝ : SMul G X\nself : Equidecomp X G\n⊢ Exists fun S => Equidecomp.IsDecompOn (↑self.toPartialEquiv) self.source S","decl":"/-- Let `G` act on a space `X`. An `Equidecomposition` with respect to `X` and `G` is a partial\nbijection `f : PartialEquiv X X` with the property that for some set `elements : Finset G`,\n(which we record), for each `a ∈ f.source`, `f a` can be obtained by applying some `g ∈ elements`\ninstead. We call `f` an equidecomposition of `f.source` with `f.target`.\n\nMore familiarly, `f` is the result of partitioning `f.source` into finitely many pieces,\nthen applying a single element of `G` to each to get a partition of `f.target`.\n-/\nstructure _root_.Equidecomp extends PartialEquiv X X where\n  isDecompOn' : ∃ S : Finset G, IsDecompOn toFun source S\n\n"}
{"name":"Equidecomp.isDecompOn","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝ : SMul G X\nf : Equidecomp X G\n⊢ Equidecomp.IsDecompOn (↑f.toPartialEquiv) f.source f.witness","decl":"theorem isDecompOn (f : Equidecomp X G) : IsDecompOn f f.source f.witness :=\n  f.isDecompOn'.choose_spec\n\n"}
{"name":"Equidecomp.apply_mem_target","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝ : SMul G X\nf : Equidecomp X G\nx : X\nh : Membership.mem f.source x\n⊢ Membership.mem f.target (↑f.toPartialEquiv x)","decl":"@[simp]\ntheorem apply_mem_target {f : Equidecomp X G} {x : X} (h : x ∈ f.source) :\n    f x ∈ f.target := f.toPartialEquiv.map_source h\n\n"}
{"name":"Equidecomp.toPartialEquiv_injective","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝ : SMul G X\n⊢ Function.Injective Equidecomp.toPartialEquiv","decl":"theorem toPartialEquiv_injective : Injective <| toPartialEquiv (X := X) (G := G) := by\n  intro ⟨_, _, _⟩ _ _\n  congr\n\n"}
{"name":"Equidecomp.IsDecompOn.mono","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝ : SMul G X\nf f' : X → X\nA A' : Set X\nS : Finset G\nh : Equidecomp.IsDecompOn f A S\nhA' : HasSubset.Subset A' A\nhf' : Set.EqOn f f' A'\n⊢ Equidecomp.IsDecompOn f' A' S","decl":"theorem IsDecompOn.mono {f f' : X → X} {A A' : Set X} {S : Finset G} (h : IsDecompOn f A S)\n    (hA' : A' ⊆ A) (hf' : EqOn f f' A') : IsDecompOn f' A' S := by\n  intro a ha\n  rw [← hf' ha]\n  exact h a (hA' ha)\n\n"}
{"name":"Equidecomp.restr_source","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝ : SMul G X\nf : Equidecomp X G\nA : Set X\n⊢ Eq (f.restr A).source (Inter.inter f.source A)","decl":"/-- The restriction of an equidecomposition as an equidecomposition. -/\n@[simps!]\ndef restr (f : Equidecomp X G) (A : Set X) : Equidecomp X G where\n  toPartialEquiv := f.toPartialEquiv.restr A\n  isDecompOn' := ⟨f.witness,\n    f.isDecompOn.mono (source_restr_subset_source _ _) fun _ ↦ congrFun rfl⟩\n\n"}
{"name":"Equidecomp.restr_invFun","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝ : SMul G X\nf : Equidecomp X G\nA : Set X\na✝ : X\n⊢ Eq ((f.restr A).invFun a✝) (↑f.symm a✝)","decl":"/-- The restriction of an equidecomposition as an equidecomposition. -/\n@[simps!]\ndef restr (f : Equidecomp X G) (A : Set X) : Equidecomp X G where\n  toPartialEquiv := f.toPartialEquiv.restr A\n  isDecompOn' := ⟨f.witness,\n    f.isDecompOn.mono (source_restr_subset_source _ _) fun _ ↦ congrFun rfl⟩\n\n"}
{"name":"Equidecomp.restr_toFun","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝ : SMul G X\nf : Equidecomp X G\nA : Set X\na✝ : X\n⊢ Eq (↑(f.restr A).toPartialEquiv a✝) (↑f.toPartialEquiv a✝)","decl":"/-- The restriction of an equidecomposition as an equidecomposition. -/\n@[simps!]\ndef restr (f : Equidecomp X G) (A : Set X) : Equidecomp X G where\n  toPartialEquiv := f.toPartialEquiv.restr A\n  isDecompOn' := ⟨f.witness,\n    f.isDecompOn.mono (source_restr_subset_source _ _) fun _ ↦ congrFun rfl⟩\n\n"}
{"name":"Equidecomp.restr_target","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝ : SMul G X\nf : Equidecomp X G\nA : Set X\n⊢ Eq (f.restr A).target (Inter.inter f.target (Set.preimage (↑f.symm) A))","decl":"/-- The restriction of an equidecomposition as an equidecomposition. -/\n@[simps!]\ndef restr (f : Equidecomp X G) (A : Set X) : Equidecomp X G where\n  toPartialEquiv := f.toPartialEquiv.restr A\n  isDecompOn' := ⟨f.witness,\n    f.isDecompOn.mono (source_restr_subset_source _ _) fun _ ↦ congrFun rfl⟩\n\n"}
{"name":"Equidecomp.toPartialEquiv_restr","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝ : SMul G X\nf : Equidecomp X G\nA : Set X\n⊢ Eq (f.restr A).toPartialEquiv (f.restr A)","decl":"@[simp]\ntheorem toPartialEquiv_restr (f : Equidecomp X G) (A : Set X) :\n    (f.restr A).toPartialEquiv = f.toPartialEquiv.restr A := rfl\n\n"}
{"name":"Equidecomp.source_restr","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝ : SMul G X\nf : Equidecomp X G\nA : Set X\nhA : HasSubset.Subset A f.source\n⊢ Eq (f.restr A).source A","decl":"theorem source_restr (f : Equidecomp X G) {A : Set X} (hA : A ⊆ f.source) :\n    (f.restr A).source = A := by rw [restr_source, inter_eq_self_of_subset_right hA]\n\n"}
{"name":"Equidecomp.restr_of_source_subset","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝ : SMul G X\nf : Equidecomp X G\nA : Set X\nhA : HasSubset.Subset f.source A\n⊢ Eq (f.restr A) f","decl":"theorem restr_of_source_subset {f : Equidecomp X G} {A : Set X} (hA : f.source ⊆ A) :\n    f.restr A = f := by\n  apply toPartialEquiv_injective\n  rw [toPartialEquiv_restr, PartialEquiv.restr_eq_of_source_subset hA]\n\n"}
{"name":"Equidecomp.restr_univ","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝ : SMul G X\nf : Equidecomp X G\n⊢ Eq (f.restr Set.univ) f","decl":"@[simp]\ntheorem restr_univ (f : Equidecomp X G) : f.restr univ = f :=\n  restr_of_source_subset <| subset_univ _\n\n"}
{"name":"Equidecomp.refl_toPartialEquiv","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝¹ : Monoid G\ninst✝ : MulAction G X\n⊢ Eq (Equidecomp.refl X G).toPartialEquiv (PartialEquiv.refl X)","decl":"/-- The identity function is an equidecomposition of the space with itself. -/\n@[simps toPartialEquiv]\ndef refl : Equidecomp X G where\n  toPartialEquiv := .refl _\n  isDecompOn' := ⟨{1}, by simp [IsDecompOn]⟩\n\n"}
{"name":"Equidecomp.IsDecompOn.comp'","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝¹ : Monoid G\ninst✝ : MulAction G X\ng f : X → X\nB A : Set X\nT S : Finset G\nhg : Equidecomp.IsDecompOn g B T\nhf : Equidecomp.IsDecompOn f A S\n⊢ Equidecomp.IsDecompOn (Function.comp g f) (Inter.inter A (Set.preimage f B)) (HMul.hMul T S)","decl":"theorem IsDecompOn.comp' {g f : X → X} {B A : Set X} {T S : Finset G}\n    (hg : IsDecompOn g B T) (hf : IsDecompOn f A S) :\n    IsDecompOn (g ∘ f) (A ∩ f ⁻¹' B) (T * S)  := by\n  intro _ ⟨aA, aB⟩\n  rcases hf _ aA with ⟨γ, γ_mem, hγ⟩\n  rcases hg _ aB with ⟨δ, δ_mem, hδ⟩\n  use δ * γ, Finset.mul_mem_mul δ_mem γ_mem\n  rwa [mul_smul, ← hγ]\n\n"}
{"name":"Equidecomp.IsDecompOn.comp","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝¹ : Monoid G\ninst✝ : MulAction G X\ng f : X → X\nB A : Set X\nT S : Finset G\nhg : Equidecomp.IsDecompOn g B T\nhf : Equidecomp.IsDecompOn f A S\nh : Set.MapsTo f A B\n⊢ Equidecomp.IsDecompOn (Function.comp g f) A (HMul.hMul T S)","decl":"theorem IsDecompOn.comp {g f : X → X} {B A : Set X} {T S : Finset G}\n    (hg : IsDecompOn g B T) (hf : IsDecompOn f A S) (h : MapsTo f A B) :\n    IsDecompOn (g ∘ f) A (T * S)  := by\n  rw [left_eq_inter.mpr h]\n  exact hg.comp' hf\n\n"}
{"name":"Equidecomp.trans_toPartialEquiv","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝¹ : Monoid G\ninst✝ : MulAction G X\nf g : Equidecomp X G\n⊢ Eq (f.trans g).toPartialEquiv (f.trans g.toPartialEquiv)","decl":"/-- The composition of two equidecompositions as an equidecomposition. -/\n@[simps toPartialEquiv, trans]\nnoncomputable def trans (f g : Equidecomp X G) : Equidecomp X G where\n  toPartialEquiv := f.toPartialEquiv.trans g.toPartialEquiv\n  isDecompOn' := ⟨g.witness * f.witness, g.isDecompOn.comp' f.isDecompOn⟩\n\n"}
{"name":"Equidecomp.IsDecompOn.of_leftInvOn","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G X\nf g : X → X\nA : Set X\nS : Finset G\nhf : Equidecomp.IsDecompOn f A S\nh : Set.LeftInvOn g f A\n⊢ Equidecomp.IsDecompOn g (Set.image f A) (Inv.inv S)","decl":"theorem IsDecompOn.of_leftInvOn {f g : X → X} {A : Set X} {S : Finset G}\n    (hf : IsDecompOn f A S) (h : LeftInvOn g f A) : IsDecompOn g (f '' A) S⁻¹ := by\n  rintro _ ⟨a, ha, rfl⟩\n  rcases hf a ha with ⟨γ, γ_mem, hγ⟩\n  use γ⁻¹, Finset.inv_mem_inv γ_mem\n  rw [hγ, inv_smul_smul, ← hγ, h ha]\n\n"}
{"name":"Equidecomp.symm_toPartialEquiv","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G X\nf : Equidecomp X G\n⊢ Eq f.symm.toPartialEquiv f.symm","decl":"/-- The inverse function of an equidecomposition as an equidecomposition. -/\n@[symm, simps toPartialEquiv]\nnoncomputable def symm (f : Equidecomp X G) : Equidecomp X G where\n  toPartialEquiv := f.toPartialEquiv.symm\n  isDecompOn' := ⟨f.witness⁻¹, by\n    convert f.isDecompOn.of_leftInvOn f.leftInvOn\n    rw [image_source_eq_target, symm_source]⟩\n\n"}
{"name":"Equidecomp.map_target","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G X\nf : Equidecomp X G\nx : X\nh : Membership.mem f.target x\n⊢ Membership.mem f.source (↑f.symm.toPartialEquiv x)","decl":"theorem map_target {f : Equidecomp X G} {x : X} (h : x ∈ f.target) :\n    f.symm x ∈ f.source := f.toPartialEquiv.map_target h\n\n"}
{"name":"Equidecomp.left_inv","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G X\nf : Equidecomp X G\nx : X\nh : Membership.mem f.source x\n⊢ Eq (↑f.symm (↑f.toPartialEquiv x)) x","decl":"@[simp]\ntheorem left_inv {f : Equidecomp X G} {x : X} (h : x ∈ f.source) :\n    f.toPartialEquiv.symm (f x) = x := f.toPartialEquiv.left_inv h\n\n"}
{"name":"Equidecomp.right_inv","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G X\nf : Equidecomp X G\nx : X\nh : Membership.mem f.target x\n⊢ Eq (↑f.toPartialEquiv (↑f.symm x)) x","decl":"@[simp]\ntheorem right_inv {f : Equidecomp X G} {x : X} (h : x ∈ f.target) :\n    f (f.toPartialEquiv.symm x) = x := f.toPartialEquiv.right_inv h\n\n"}
{"name":"Equidecomp.symm_symm","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G X\nf : Equidecomp X G\n⊢ Eq f.symm.symm f","decl":"@[simp]\ntheorem symm_symm (f : Equidecomp X G) : f.symm.symm = f := rfl\n\n"}
{"name":"Equidecomp.refl_symm","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G X\n⊢ Eq (Equidecomp.refl X G).symm (Equidecomp.refl X G)","decl":"@[simp]\ntheorem refl_symm : (refl X G).symm = refl X G := rfl\n\n"}
{"name":"Equidecomp.restr_refl_symm","module":"Mathlib.Algebra.Group.Action.Equidecomp","initialProofState":"X : Type u_1\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G X\nA : Set X\n⊢ Eq ((Equidecomp.refl X G).restr A).symm ((Equidecomp.refl X G).restr A)","decl":"@[simp]\ntheorem restr_refl_symm (A : Set X) :\n    ((Equidecomp.refl X G).restr A).symm = (Equidecomp.refl X G).restr A := rfl\n\n"}
