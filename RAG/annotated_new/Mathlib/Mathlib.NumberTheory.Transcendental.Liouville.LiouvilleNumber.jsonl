{"name":"LiouvilleNumber.summable","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleNumber","initialProofState":"m : Real\nhm : LT.lt 1 m\n⊢ Summable fun i => HDiv.hDiv 1 (HPow.hPow m i.factorial)","decl":"protected theorem summable {m : ℝ} (hm : 1 < m) : Summable fun i : ℕ => 1 / m ^ i ! :=\n  summable_one_div_pow_of_le hm Nat.self_le_factorial\n\n"}
{"name":"LiouvilleNumber.remainder_summable","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleNumber","initialProofState":"m : Real\nhm : LT.lt 1 m\nk : Nat\n⊢ Summable fun i => HDiv.hDiv 1 (HPow.hPow m (HAdd.hAdd i (HAdd.hAdd k 1)).factorial)","decl":"theorem remainder_summable {m : ℝ} (hm : 1 < m) (k : ℕ) :\n    Summable fun i : ℕ => 1 / m ^ (i + (k + 1))! := by\n  convert (summable_nat_add_iff (k + 1)).2 (LiouvilleNumber.summable hm)\n\n"}
{"name":"LiouvilleNumber.remainder_pos","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleNumber","initialProofState":"m : Real\nhm : LT.lt 1 m\nk : Nat\n⊢ LT.lt 0 (LiouvilleNumber.remainder m k)","decl":"theorem remainder_pos {m : ℝ} (hm : 1 < m) (k : ℕ) : 0 < remainder m k :=\n  tsum_pos (remainder_summable hm k) (fun _ => by positivity) 0 (by positivity)\n\n"}
{"name":"LiouvilleNumber.partialSum_succ","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleNumber","initialProofState":"m : Real\nn : Nat\n⊢ Eq (LiouvilleNumber.partialSum m (HAdd.hAdd n 1)) (HAdd.hAdd (LiouvilleNumber.partialSum m n) (HDiv.hDiv 1 (HPow.hPow m (HAdd.hAdd n 1).factorial)))","decl":"theorem partialSum_succ (m : ℝ) (n : ℕ) :\n    partialSum m (n + 1) = partialSum m n + 1 / m ^ (n + 1)! :=\n  sum_range_succ _ _\n\n"}
{"name":"LiouvilleNumber.partialSum_add_remainder","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleNumber","initialProofState":"m : Real\nhm : LT.lt 1 m\nk : Nat\n⊢ Eq (HAdd.hAdd (LiouvilleNumber.partialSum m k) (LiouvilleNumber.remainder m k)) (liouvilleNumber m)","decl":"/-- Split the sum defining a Liouville number into the first `k` terms and the rest. -/\ntheorem partialSum_add_remainder {m : ℝ} (hm : 1 < m) (k : ℕ) :\n    partialSum m k + remainder m k = liouvilleNumber m :=\n  sum_add_tsum_nat_add _ (LiouvilleNumber.summable hm)\n\n"}
{"name":"LiouvilleNumber.remainder_lt'","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleNumber","initialProofState":"n : Nat\nm : Real\nm1 : LT.lt 1 m\n⊢ LT.lt (LiouvilleNumber.remainder m n) (HMul.hMul (Inv.inv (HSub.hSub 1 (HDiv.hDiv 1 m))) (HDiv.hDiv 1 (HPow.hPow m (HAdd.hAdd n 1).factorial)))","decl":"/-- An upper estimate on the remainder. This estimate works with `m ∈ ℝ` satisfying `1 < m` and is\nstronger than the estimate `LiouvilleNumber.remainder_lt` below. However, the latter estimate is\nmore useful for the proof. -/\ntheorem remainder_lt' (n : ℕ) {m : ℝ} (m1 : 1 < m) :\n    remainder m n < (1 - 1 / m)⁻¹ * (1 / m ^ (n + 1)!) :=\n  -- two useful inequalities\n  have m0 : 0 < m := zero_lt_one.trans m1\n  have mi : 1 / m < 1 := (div_lt_one m0).mpr m1\n  -- to show the strict inequality between these series, we prove that:\n  calc\n    (∑' i, 1 / m ^ (i + (n + 1))!) < ∑' i, 1 / m ^ (i + (n + 1)!) :=\n        -- 1. the second series dominates the first\n        tsum_lt_tsum (fun b => one_div_pow_le_one_div_pow_of_le m1.le\n          (b.add_factorial_succ_le_factorial_add_succ n))\n        -- 2. the term with index `i = 2` of the first series is strictly smaller than\n        -- the corresponding term of the second series\n        (one_div_pow_strictAnti m1 (n.add_factorial_succ_lt_factorial_add_succ (i := 2) le_rfl))\n        -- 3. the first series is summable\n        (remainder_summable m1 n)\n        -- 4. the second series is summable, since its terms grow quickly\n        (summable_one_div_pow_of_le m1 fun _ => le_self_add)\n    -- split the sum in the exponent and massage\n    _ = ∑' i : ℕ, (1 / m) ^ i * (1 / m ^ (n + 1)!) := by\n      simp only [pow_add, one_div, mul_inv, inv_pow]\n    -- factor the constant `(1 / m ^ (n + 1)!)` out of the series\n    _ = (∑' i, (1 / m) ^ i) * (1 / m ^ (n + 1)!) := tsum_mul_right\n    -- the series is the geometric series\n    _ = (1 - 1 / m)⁻¹ * (1 / m ^ (n + 1)!) := by rw [tsum_geometric_of_lt_one (by positivity) mi]\n\n"}
{"name":"LiouvilleNumber.aux_calc","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleNumber","initialProofState":"n : Nat\nm : Real\nhm : LE.le 2 m\n⊢ LE.le (HMul.hMul (Inv.inv (HSub.hSub 1 (HDiv.hDiv 1 m))) (HDiv.hDiv 1 (HPow.hPow m (HAdd.hAdd n 1).factorial))) (HDiv.hDiv 1 (HPow.hPow (HPow.hPow m n.factorial) n))","decl":"theorem aux_calc (n : ℕ) {m : ℝ} (hm : 2 ≤ m) :\n    (1 - 1 / m)⁻¹ * (1 / m ^ (n + 1)!) ≤ 1 / (m ^ n !) ^ n :=\n  calc\n    (1 - 1 / m)⁻¹ * (1 / m ^ (n + 1)!) ≤ 2 * (1 / m ^ (n + 1)!) :=\n      -- the second factors coincide (and are non-negative),\n      -- the first factors satisfy the inequality `sub_one_div_inv_le_two`\n      mul_le_mul_of_nonneg_right (sub_one_div_inv_le_two hm) (by positivity)\n    _ = 2 / m ^ (n + 1)! := mul_one_div 2 _\n    _ = 2 / m ^ (n ! * (n + 1)) := (congr_arg (2 / ·) (congr_arg (Pow.pow m) (mul_comm _ _)))\n    _ ≤ 1 / m ^ (n ! * n) := by\n      -- [NB: in this block, I do not follow the brace convention for subgoals -- I wait until\n      -- I solve all extraneous goals at once with `exact pow_pos (zero_lt_two.trans_le hm) _`.]\n      -- Clear denominators and massage*\n      apply (div_le_div_iff₀ _ _).mpr\n      focus\n        conv_rhs => rw [one_mul, mul_add, pow_add, mul_one, pow_mul, mul_comm, ← pow_mul]\n        -- the second factors coincide, so we prove the inequality of the first factors*\n        refine (mul_le_mul_right ?_).mpr ?_\n      -- solve all the inequalities `0 < m ^ ??`\n      any_goals exact pow_pos (zero_lt_two.trans_le hm) _\n      -- `2 ≤ m ^ n!` is a consequence of monotonicity of exponentiation at `2 ≤ m`.\n      exact _root_.trans (_root_.trans hm (pow_one _).symm.le)\n        (pow_right_mono₀ (one_le_two.trans hm) n.factorial_pos)\n    _ = 1 / (m ^ n !) ^ n := congr_arg (1 / ·) (pow_mul m n ! n)\n\n"}
{"name":"LiouvilleNumber.remainder_lt","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleNumber","initialProofState":"n : Nat\nm : Real\nm2 : LE.le 2 m\n⊢ LT.lt (LiouvilleNumber.remainder m n) (HDiv.hDiv 1 (HPow.hPow (HPow.hPow m n.factorial) n))","decl":"/-- An upper estimate on the remainder. This estimate works with `m ∈ ℝ` satisfying `2 ≤ m` and is\nweaker than the estimate `LiouvilleNumber.remainder_lt'` above. However, this estimate is\nmore useful for the proof. -/\ntheorem remainder_lt (n : ℕ) {m : ℝ} (m2 : 2 ≤ m) : remainder m n < 1 / (m ^ n !) ^ n :=\n  (remainder_lt' n <| one_lt_two.trans_le m2).trans_le (aux_calc _ m2)\n\n"}
{"name":"LiouvilleNumber.partialSum_eq_rat","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleNumber","initialProofState":"m : Nat\nhm : LT.lt 0 m\nk : Nat\n⊢ Exists fun p => Eq (LiouvilleNumber.partialSum (↑m) k) (HDiv.hDiv ↑p ↑(HPow.hPow m k.factorial))","decl":"/-- The sum of the `k` initial terms of the Liouville number to base `m` is a ratio of natural\nnumbers where the denominator is `m ^ k!`. -/\ntheorem partialSum_eq_rat {m : ℕ} (hm : 0 < m) (k : ℕ) :\n    ∃ p : ℕ, partialSum m k = p / ((m ^ k ! :) : ℝ) := by\n  induction' k with k h\n  · exact ⟨1, by rw [partialSum, range_one, sum_singleton, Nat.cast_one, Nat.factorial,\n      pow_one, pow_one]⟩\n  · rcases h with ⟨p_k, h_k⟩\n    use p_k * m ^ ((k + 1)! - k !) + 1\n    rw [partialSum_succ, h_k, div_add_div, div_eq_div_iff, add_mul]\n    · norm_cast\n      rw [add_mul, one_mul, Nat.factorial_succ, add_mul, one_mul, add_tsub_cancel_right, pow_add]\n      simp [mul_assoc]\n    all_goals positivity\n\n"}
{"name":"liouville_liouvilleNumber","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleNumber","initialProofState":"m : Nat\nhm : LE.le 2 m\n⊢ Liouville (liouvilleNumber ↑m)","decl":"theorem liouville_liouvilleNumber {m : ℕ} (hm : 2 ≤ m) : Liouville (liouvilleNumber m) := by\n  -- two useful inequalities\n  have mZ1 : 1 < (m : ℤ) := by norm_cast\n  have m1 : 1 < (m : ℝ) := by norm_cast\n  intro n\n  -- the first `n` terms sum to `p / m ^ k!`\n  rcases partialSum_eq_rat (zero_lt_two.trans_le hm) n with ⟨p, hp⟩\n  refine ⟨p, m ^ n !, one_lt_pow₀ mZ1 n.factorial_ne_zero, ?_⟩\n  push_cast\n  rw [Nat.cast_pow] at hp\n  -- separate out the sum of the first `n` terms and the rest\n  rw [← partialSum_add_remainder m1 n, ← hp]\n  have hpos := remainder_pos m1 n\n  simpa [abs_of_pos hpos, hpos.ne'] using @remainder_lt n m (by assumption_mod_cast)\n\n"}
{"name":"transcendental_liouvilleNumber","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleNumber","initialProofState":"m : Nat\nhm : LE.le 2 m\n⊢ Transcendental Int (liouvilleNumber ↑m)","decl":"theorem transcendental_liouvilleNumber {m : ℕ} (hm : 2 ≤ m) :\n    Transcendental ℤ (liouvilleNumber m) :=\n  (liouville_liouvilleNumber hm).transcendental\n"}
