{"name":"CategoryTheory.Limits.CoproductDisjoint.mono_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.DisjointCoproduct","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX₁✝ X₂✝ : C\nself : CategoryTheory.Limits.CoproductDisjoint X₁✝ X₂✝\nX : C\nX₁ : Quiver.Hom X₁✝ X\nX₂ : Quiver.Hom X₂✝ X\n_cX : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.BinaryCofan.mk X₁ X₂)\n⊢ CategoryTheory.Mono X₂","decl":"/-- Given any pullback diagram of the form\n\n```\nZ  ⟶ X₁\n↓    ↓\nX₂ ⟶ X\n```\n\nwhere `X₁ ⟶ X ← X₂` is a coproduct diagram, then `Z` is initial, and both `X₁ ⟶ X` and `X₂ ⟶ X`\nare mono.\n-/\nclass CoproductDisjoint (X₁ X₂ : C) where\n  isInitialOfIsPullbackOfIsCoproduct :\n    ∀ {X Z} {pX₁ : X₁ ⟶ X} {pX₂ : X₂ ⟶ X} {f : Z ⟶ X₁} {g : Z ⟶ X₂}\n      (_cX : IsColimit (BinaryCofan.mk pX₁ pX₂)) {comm : f ≫ pX₁ = g ≫ pX₂},\n      IsLimit (PullbackCone.mk _ _ comm) → IsInitial Z\n  mono_inl : ∀ (X) (X₁ : X₁ ⟶ X) (X₂ : X₂ ⟶ X) (_cX : IsColimit (BinaryCofan.mk X₁ X₂)), Mono X₁\n  mono_inr : ∀ (X) (X₁ : X₁ ⟶ X) (X₂ : X₂ ⟶ X) (_cX : IsColimit (BinaryCofan.mk X₁ X₂)), Mono X₂\n\n"}
{"name":"CategoryTheory.Limits.CoproductDisjoint.mono_inl","module":"Mathlib.CategoryTheory.Limits.Shapes.DisjointCoproduct","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX₁✝ X₂✝ : C\nself : CategoryTheory.Limits.CoproductDisjoint X₁✝ X₂✝\nX : C\nX₁ : Quiver.Hom X₁✝ X\nX₂ : Quiver.Hom X₂✝ X\n_cX : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.BinaryCofan.mk X₁ X₂)\n⊢ CategoryTheory.Mono X₁","decl":"/-- Given any pullback diagram of the form\n\n```\nZ  ⟶ X₁\n↓    ↓\nX₂ ⟶ X\n```\n\nwhere `X₁ ⟶ X ← X₂` is a coproduct diagram, then `Z` is initial, and both `X₁ ⟶ X` and `X₂ ⟶ X`\nare mono.\n-/\nclass CoproductDisjoint (X₁ X₂ : C) where\n  isInitialOfIsPullbackOfIsCoproduct :\n    ∀ {X Z} {pX₁ : X₁ ⟶ X} {pX₂ : X₂ ⟶ X} {f : Z ⟶ X₁} {g : Z ⟶ X₂}\n      (_cX : IsColimit (BinaryCofan.mk pX₁ pX₂)) {comm : f ≫ pX₁ = g ≫ pX₂},\n      IsLimit (PullbackCone.mk _ _ comm) → IsInitial Z\n  mono_inl : ∀ (X) (X₁ : X₁ ⟶ X) (X₂ : X₂ ⟶ X) (_cX : IsColimit (BinaryCofan.mk X₁ X₂)), Mono X₁\n  mono_inr : ∀ (X) (X₁ : X₁ ⟶ X) (X₂ : X₂ ⟶ X) (_cX : IsColimit (BinaryCofan.mk X₁ X₂)), Mono X₂\n\n"}
{"name":"CategoryTheory.Limits.instMonoInlOfCoproductDisjoint","module":"Mathlib.CategoryTheory.Limits.Shapes.DisjointCoproduct","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX₁ X₂ : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct X₁ X₂\ninst✝ : CategoryTheory.Limits.CoproductDisjoint X₁ X₂\n⊢ CategoryTheory.Mono CategoryTheory.Limits.coprod.inl","decl":"instance {X₁ X₂ : C} [HasBinaryCoproduct X₁ X₂] [CoproductDisjoint X₁ X₂] :\n    Mono (coprod.inl : X₁ ⟶ X₁ ⨿ X₂) :=\n  CoproductDisjoint.mono_inl _ _ _ (coprodIsCoprod _ _)\n\n"}
{"name":"CategoryTheory.Limits.instMonoInrOfCoproductDisjoint","module":"Mathlib.CategoryTheory.Limits.Shapes.DisjointCoproduct","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX₁ X₂ : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct X₁ X₂\ninst✝ : CategoryTheory.Limits.CoproductDisjoint X₁ X₂\n⊢ CategoryTheory.Mono CategoryTheory.Limits.coprod.inr","decl":"instance {X₁ X₂ : C} [HasBinaryCoproduct X₁ X₂] [CoproductDisjoint X₁ X₂] :\n    Mono (coprod.inr : X₂ ⟶ X₁ ⨿ X₂) :=\n  CoproductDisjoint.mono_inr _ _ _ (coprodIsCoprod _ _)\n\n"}
{"name":"CategoryTheory.Limits.initialMonoClass_of_disjoint_coproducts","module":"Mathlib.CategoryTheory.Limits.Shapes.DisjointCoproduct","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.CoproductsDisjoint C\n⊢ CategoryTheory.Limits.InitialMonoClass C","decl":"/-- If `C` has disjoint coproducts, any morphism out of initial is mono. Note it isn't true in\ngeneral that `C` has strict initial objects, for instance consider the category of types and\npartial functions. -/\ntheorem initialMonoClass_of_disjoint_coproducts [CoproductsDisjoint C] : InitialMonoClass C where\n  isInitial_mono_from X hI :=\n    CoproductDisjoint.mono_inl X (IsInitial.to hI X) (CategoryTheory.CategoryStruct.id X)\n      { desc := fun s : BinaryCofan _ _ => s.inr\n        fac := fun _s j =>\n          Discrete.casesOn j fun j => WalkingPair.casesOn j (hI.hom_ext _ _) (id_comp _)\n        uniq := fun (_s : BinaryCofan _ _) _m w =>\n          (id_comp _).symm.trans (w ⟨WalkingPair.right⟩) }\n\n"}
