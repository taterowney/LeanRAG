{"name":"TopCat.Presheaf.generateEquivalenceOpensLe_functor'_map","module":"Mathlib.Topology.Sheaves.SheafCondition.OpensLeCover","initialProofState":"X : TopCat\nι : Type w\nU : ι → TopologicalSpace.Opens ↑X\nY : TopologicalSpace.Opens ↑X\nhY : Eq Y (iSup U)\nx✝¹ x✝ : CategoryTheory.FullSubcategory fun f => (CategoryTheory.Sieve.generate (TopCat.Presheaf.presieveOfCoveringAux U Y)).arrows f.hom\ng : Quiver.Hom x✝¹ x✝\n⊢ Eq ((TopCat.Presheaf.generateEquivalenceOpensLe_functor' U hY).map g) g.left","decl":"/-- Given a family of opens `U` and an open `Y` equal to the union of opens in `U`, we may\n    take the presieve on `Y` associated to `U` and the sieve generated by it, and form the\n    full subcategory (subposet) of opens contained in `Y` (`over Y`) consisting of arrows\n    in the sieve. This full subcategory is equivalent to `OpensLeCover U`, the (poset)\n    category of opens contained in some `U i`. -/\n@[simps]\ndef generateEquivalenceOpensLe_functor' (hY : Y = iSup U) :\n    (FullSubcategory fun f : Over Y => (Sieve.generate (presieveOfCoveringAux U Y)).arrows f.hom) ⥤\n    OpensLeCover U :=\n{ obj := fun f =>\n    ⟨f.1.left,\n      let ⟨_, h, _, ⟨i, hY⟩, _⟩ := f.2\n      ⟨i, hY ▸ h.le⟩⟩\n  map := fun {_ _} g => g.left }\n\n-- Porting note: split it out to prevent timeout\n"}
{"name":"TopCat.Presheaf.generateEquivalenceOpensLe_functor'_obj_obj","module":"Mathlib.Topology.Sheaves.SheafCondition.OpensLeCover","initialProofState":"X : TopCat\nι : Type w\nU : ι → TopologicalSpace.Opens ↑X\nY : TopologicalSpace.Opens ↑X\nhY : Eq Y (iSup U)\nf : CategoryTheory.FullSubcategory fun f => (CategoryTheory.Sieve.generate (TopCat.Presheaf.presieveOfCoveringAux U Y)).arrows f.hom\n⊢ Eq ((TopCat.Presheaf.generateEquivalenceOpensLe_functor' U hY).obj f).obj f.obj.left","decl":"/-- Given a family of opens `U` and an open `Y` equal to the union of opens in `U`, we may\n    take the presieve on `Y` associated to `U` and the sieve generated by it, and form the\n    full subcategory (subposet) of opens contained in `Y` (`over Y`) consisting of arrows\n    in the sieve. This full subcategory is equivalent to `OpensLeCover U`, the (poset)\n    category of opens contained in some `U i`. -/\n@[simps]\ndef generateEquivalenceOpensLe_functor' (hY : Y = iSup U) :\n    (FullSubcategory fun f : Over Y => (Sieve.generate (presieveOfCoveringAux U Y)).arrows f.hom) ⥤\n    OpensLeCover U :=\n{ obj := fun f =>\n    ⟨f.1.left,\n      let ⟨_, h, _, ⟨i, hY⟩, _⟩ := f.2\n      ⟨i, hY ▸ h.le⟩⟩\n  map := fun {_ _} g => g.left }\n\n-- Porting note: split it out to prevent timeout\n"}
{"name":"TopCat.Presheaf.generateEquivalenceOpensLe_inverse'_obj_obj_hom","module":"Mathlib.Topology.Sheaves.SheafCondition.OpensLeCover","initialProofState":"X : TopCat\nι : Type w\nU : ι → TopologicalSpace.Opens ↑X\nY : TopologicalSpace.Opens ↑X\nhY : Eq Y (iSup U)\nV : TopCat.Presheaf.SheafCondition.OpensLeCover U\n⊢ Eq ((TopCat.Presheaf.generateEquivalenceOpensLe_inverse' U hY).obj V).obj.hom (CategoryTheory.homOfLE ⋯)","decl":"/-- Given a family of opens `U` and an open `Y` equal to the union of opens in `U`, we may\n    take the presieve on `Y` associated to `U` and the sieve generated by it, and form the\n    full subcategory (subposet) of opens contained in `Y` (`over Y`) consisting of arrows\n    in the sieve. This full subcategory is equivalent to `OpensLeCover U`, the (poset)\n    category of opens contained in some `U i`. -/\n@[simps]\ndef generateEquivalenceOpensLe_inverse' (hY : Y = iSup U) :\n    OpensLeCover U ⥤\n    (FullSubcategory fun f : Over Y =>\n      (Sieve.generate (presieveOfCoveringAux U Y)).arrows f.hom) where\n  obj := fun V => ⟨⟨V.obj, ⟨⟨⟩⟩, homOfLE <| hY ▸ (V.2.choose_spec.trans (le_iSup U (V.2.choose)))⟩,\n    ⟨U V.2.choose, V.2.choose_spec.hom, homOfLE <| hY ▸ le_iSup U V.2.choose,\n      ⟨V.2.choose, rfl⟩, rfl⟩⟩\n  map {_ _} g := Over.homMk g\n  map_id _ := by\n    refine Over.OverMorphism.ext ?_\n    simp only [Functor.id_obj, Sieve.generate_apply, Functor.const_obj_obj, Over.homMk_left,\n      eq_iff_true_of_subsingleton]\n  map_comp {_ _ _} f g := by\n    refine Over.OverMorphism.ext ?_\n    simp only [Functor.id_obj, Sieve.generate_apply, Functor.const_obj_obj, Over.homMk_left,\n      eq_iff_true_of_subsingleton]\n\n"}
{"name":"TopCat.Presheaf.generateEquivalenceOpensLe_inverse'_obj_obj_left","module":"Mathlib.Topology.Sheaves.SheafCondition.OpensLeCover","initialProofState":"X : TopCat\nι : Type w\nU : ι → TopologicalSpace.Opens ↑X\nY : TopologicalSpace.Opens ↑X\nhY : Eq Y (iSup U)\nV : TopCat.Presheaf.SheafCondition.OpensLeCover U\n⊢ Eq ((TopCat.Presheaf.generateEquivalenceOpensLe_inverse' U hY).obj V).obj.left V.obj","decl":"/-- Given a family of opens `U` and an open `Y` equal to the union of opens in `U`, we may\n    take the presieve on `Y` associated to `U` and the sieve generated by it, and form the\n    full subcategory (subposet) of opens contained in `Y` (`over Y`) consisting of arrows\n    in the sieve. This full subcategory is equivalent to `OpensLeCover U`, the (poset)\n    category of opens contained in some `U i`. -/\n@[simps]\ndef generateEquivalenceOpensLe_inverse' (hY : Y = iSup U) :\n    OpensLeCover U ⥤\n    (FullSubcategory fun f : Over Y =>\n      (Sieve.generate (presieveOfCoveringAux U Y)).arrows f.hom) where\n  obj := fun V => ⟨⟨V.obj, ⟨⟨⟩⟩, homOfLE <| hY ▸ (V.2.choose_spec.trans (le_iSup U (V.2.choose)))⟩,\n    ⟨U V.2.choose, V.2.choose_spec.hom, homOfLE <| hY ▸ le_iSup U V.2.choose,\n      ⟨V.2.choose, rfl⟩, rfl⟩⟩\n  map {_ _} g := Over.homMk g\n  map_id _ := by\n    refine Over.OverMorphism.ext ?_\n    simp only [Functor.id_obj, Sieve.generate_apply, Functor.const_obj_obj, Over.homMk_left,\n      eq_iff_true_of_subsingleton]\n  map_comp {_ _ _} f g := by\n    refine Over.OverMorphism.ext ?_\n    simp only [Functor.id_obj, Sieve.generate_apply, Functor.const_obj_obj, Over.homMk_left,\n      eq_iff_true_of_subsingleton]\n\n"}
{"name":"TopCat.Presheaf.generateEquivalenceOpensLe_inverse'_obj_obj_right_as","module":"Mathlib.Topology.Sheaves.SheafCondition.OpensLeCover","initialProofState":"X : TopCat\nι : Type w\nU : ι → TopologicalSpace.Opens ↑X\nY : TopologicalSpace.Opens ↑X\nhY : Eq Y (iSup U)\nV : TopCat.Presheaf.SheafCondition.OpensLeCover U\n⊢ Eq ((TopCat.Presheaf.generateEquivalenceOpensLe_inverse' U hY).obj V).obj.right.as PUnit.unit","decl":"/-- Given a family of opens `U` and an open `Y` equal to the union of opens in `U`, we may\n    take the presieve on `Y` associated to `U` and the sieve generated by it, and form the\n    full subcategory (subposet) of opens contained in `Y` (`over Y`) consisting of arrows\n    in the sieve. This full subcategory is equivalent to `OpensLeCover U`, the (poset)\n    category of opens contained in some `U i`. -/\n@[simps]\ndef generateEquivalenceOpensLe_inverse' (hY : Y = iSup U) :\n    OpensLeCover U ⥤\n    (FullSubcategory fun f : Over Y =>\n      (Sieve.generate (presieveOfCoveringAux U Y)).arrows f.hom) where\n  obj := fun V => ⟨⟨V.obj, ⟨⟨⟩⟩, homOfLE <| hY ▸ (V.2.choose_spec.trans (le_iSup U (V.2.choose)))⟩,\n    ⟨U V.2.choose, V.2.choose_spec.hom, homOfLE <| hY ▸ le_iSup U V.2.choose,\n      ⟨V.2.choose, rfl⟩, rfl⟩⟩\n  map {_ _} g := Over.homMk g\n  map_id _ := by\n    refine Over.OverMorphism.ext ?_\n    simp only [Functor.id_obj, Sieve.generate_apply, Functor.const_obj_obj, Over.homMk_left,\n      eq_iff_true_of_subsingleton]\n  map_comp {_ _ _} f g := by\n    refine Over.OverMorphism.ext ?_\n    simp only [Functor.id_obj, Sieve.generate_apply, Functor.const_obj_obj, Over.homMk_left,\n      eq_iff_true_of_subsingleton]\n\n"}
{"name":"TopCat.Presheaf.generateEquivalenceOpensLe_inverse'_map","module":"Mathlib.Topology.Sheaves.SheafCondition.OpensLeCover","initialProofState":"X : TopCat\nι : Type w\nU : ι → TopologicalSpace.Opens ↑X\nY : TopologicalSpace.Opens ↑X\nhY : Eq Y (iSup U)\nx✝¹ x✝ : TopCat.Presheaf.SheafCondition.OpensLeCover U\ng : Quiver.Hom x✝¹ x✝\n⊢ Eq ((TopCat.Presheaf.generateEquivalenceOpensLe_inverse' U hY).map g) (CategoryTheory.Over.homMk g ⋯)","decl":"/-- Given a family of opens `U` and an open `Y` equal to the union of opens in `U`, we may\n    take the presieve on `Y` associated to `U` and the sieve generated by it, and form the\n    full subcategory (subposet) of opens contained in `Y` (`over Y`) consisting of arrows\n    in the sieve. This full subcategory is equivalent to `OpensLeCover U`, the (poset)\n    category of opens contained in some `U i`. -/\n@[simps]\ndef generateEquivalenceOpensLe_inverse' (hY : Y = iSup U) :\n    OpensLeCover U ⥤\n    (FullSubcategory fun f : Over Y =>\n      (Sieve.generate (presieveOfCoveringAux U Y)).arrows f.hom) where\n  obj := fun V => ⟨⟨V.obj, ⟨⟨⟩⟩, homOfLE <| hY ▸ (V.2.choose_spec.trans (le_iSup U (V.2.choose)))⟩,\n    ⟨U V.2.choose, V.2.choose_spec.hom, homOfLE <| hY ▸ le_iSup U V.2.choose,\n      ⟨V.2.choose, rfl⟩, rfl⟩⟩\n  map {_ _} g := Over.homMk g\n  map_id _ := by\n    refine Over.OverMorphism.ext ?_\n    simp only [Functor.id_obj, Sieve.generate_apply, Functor.const_obj_obj, Over.homMk_left,\n      eq_iff_true_of_subsingleton]\n  map_comp {_ _ _} f g := by\n    refine Over.OverMorphism.ext ?_\n    simp only [Functor.id_obj, Sieve.generate_apply, Functor.const_obj_obj, Over.homMk_left,\n      eq_iff_true_of_subsingleton]\n\n"}
{"name":"TopCat.Presheaf.generateEquivalenceOpensLe_counitIso","module":"Mathlib.Topology.Sheaves.SheafCondition.OpensLeCover","initialProofState":"X : TopCat\nι : Type w\nU : ι → TopologicalSpace.Opens ↑X\nY : TopologicalSpace.Opens ↑X\nhY : Eq Y (iSup U)\n⊢ Eq (TopCat.Presheaf.generateEquivalenceOpensLe U hY).counitIso (CategoryTheory.eqToIso ⋯)","decl":"/-- Given a family of opens `U` and an open `Y` equal to the union of opens in `U`, we may\n    take the presieve on `Y` associated to `U` and the sieve generated by it, and form the\n    full subcategory (subposet) of opens contained in `Y` (`over Y`) consisting of arrows\n    in the sieve. This full subcategory is equivalent to `OpensLeCover U`, the (poset)\n    category of opens contained in some `U i`. -/\n@[simps]\ndef generateEquivalenceOpensLe (hY : Y = iSup U) :\n    (FullSubcategory fun f : Over Y => (Sieve.generate (presieveOfCoveringAux U Y)).arrows f.hom) ≌\n    OpensLeCover U where\n  -- Porting note: split it out to prevent timeout\n  functor := generateEquivalenceOpensLe_functor' _ hY\n  inverse := generateEquivalenceOpensLe_inverse' _ hY\n  unitIso := eqToIso <| CategoryTheory.Functor.ext\n    (by rintro ⟨⟨_, _⟩, _⟩; dsimp; congr)\n    (by intros; refine Over.OverMorphism.ext ?_; simp)\n  counitIso := eqToIso <| CategoryTheory.Functor.hext\n    (by intro; refine FullSubcategory.ext ?_; rfl) (by intros; rfl)\n\n"}
{"name":"TopCat.Presheaf.generateEquivalenceOpensLe_functor","module":"Mathlib.Topology.Sheaves.SheafCondition.OpensLeCover","initialProofState":"X : TopCat\nι : Type w\nU : ι → TopologicalSpace.Opens ↑X\nY : TopologicalSpace.Opens ↑X\nhY : Eq Y (iSup U)\n⊢ Eq (TopCat.Presheaf.generateEquivalenceOpensLe U hY).functor (TopCat.Presheaf.generateEquivalenceOpensLe_functor' U hY)","decl":"/-- Given a family of opens `U` and an open `Y` equal to the union of opens in `U`, we may\n    take the presieve on `Y` associated to `U` and the sieve generated by it, and form the\n    full subcategory (subposet) of opens contained in `Y` (`over Y`) consisting of arrows\n    in the sieve. This full subcategory is equivalent to `OpensLeCover U`, the (poset)\n    category of opens contained in some `U i`. -/\n@[simps]\ndef generateEquivalenceOpensLe (hY : Y = iSup U) :\n    (FullSubcategory fun f : Over Y => (Sieve.generate (presieveOfCoveringAux U Y)).arrows f.hom) ≌\n    OpensLeCover U where\n  -- Porting note: split it out to prevent timeout\n  functor := generateEquivalenceOpensLe_functor' _ hY\n  inverse := generateEquivalenceOpensLe_inverse' _ hY\n  unitIso := eqToIso <| CategoryTheory.Functor.ext\n    (by rintro ⟨⟨_, _⟩, _⟩; dsimp; congr)\n    (by intros; refine Over.OverMorphism.ext ?_; simp)\n  counitIso := eqToIso <| CategoryTheory.Functor.hext\n    (by intro; refine FullSubcategory.ext ?_; rfl) (by intros; rfl)\n\n"}
{"name":"TopCat.Presheaf.generateEquivalenceOpensLe_unitIso","module":"Mathlib.Topology.Sheaves.SheafCondition.OpensLeCover","initialProofState":"X : TopCat\nι : Type w\nU : ι → TopologicalSpace.Opens ↑X\nY : TopologicalSpace.Opens ↑X\nhY : Eq Y (iSup U)\n⊢ Eq (TopCat.Presheaf.generateEquivalenceOpensLe U hY).unitIso (CategoryTheory.eqToIso ⋯)","decl":"/-- Given a family of opens `U` and an open `Y` equal to the union of opens in `U`, we may\n    take the presieve on `Y` associated to `U` and the sieve generated by it, and form the\n    full subcategory (subposet) of opens contained in `Y` (`over Y`) consisting of arrows\n    in the sieve. This full subcategory is equivalent to `OpensLeCover U`, the (poset)\n    category of opens contained in some `U i`. -/\n@[simps]\ndef generateEquivalenceOpensLe (hY : Y = iSup U) :\n    (FullSubcategory fun f : Over Y => (Sieve.generate (presieveOfCoveringAux U Y)).arrows f.hom) ≌\n    OpensLeCover U where\n  -- Porting note: split it out to prevent timeout\n  functor := generateEquivalenceOpensLe_functor' _ hY\n  inverse := generateEquivalenceOpensLe_inverse' _ hY\n  unitIso := eqToIso <| CategoryTheory.Functor.ext\n    (by rintro ⟨⟨_, _⟩, _⟩; dsimp; congr)\n    (by intros; refine Over.OverMorphism.ext ?_; simp)\n  counitIso := eqToIso <| CategoryTheory.Functor.hext\n    (by intro; refine FullSubcategory.ext ?_; rfl) (by intros; rfl)\n\n"}
{"name":"TopCat.Presheaf.generateEquivalenceOpensLe_inverse","module":"Mathlib.Topology.Sheaves.SheafCondition.OpensLeCover","initialProofState":"X : TopCat\nι : Type w\nU : ι → TopologicalSpace.Opens ↑X\nY : TopologicalSpace.Opens ↑X\nhY : Eq Y (iSup U)\n⊢ Eq (TopCat.Presheaf.generateEquivalenceOpensLe U hY).inverse (TopCat.Presheaf.generateEquivalenceOpensLe_inverse' U hY)","decl":"/-- Given a family of opens `U` and an open `Y` equal to the union of opens in `U`, we may\n    take the presieve on `Y` associated to `U` and the sieve generated by it, and form the\n    full subcategory (subposet) of opens contained in `Y` (`over Y`) consisting of arrows\n    in the sieve. This full subcategory is equivalent to `OpensLeCover U`, the (poset)\n    category of opens contained in some `U i`. -/\n@[simps]\ndef generateEquivalenceOpensLe (hY : Y = iSup U) :\n    (FullSubcategory fun f : Over Y => (Sieve.generate (presieveOfCoveringAux U Y)).arrows f.hom) ≌\n    OpensLeCover U where\n  -- Porting note: split it out to prevent timeout\n  functor := generateEquivalenceOpensLe_functor' _ hY\n  inverse := generateEquivalenceOpensLe_inverse' _ hY\n  unitIso := eqToIso <| CategoryTheory.Functor.ext\n    (by rintro ⟨⟨_, _⟩, _⟩; dsimp; congr)\n    (by intros; refine Over.OverMorphism.ext ?_; simp)\n  counitIso := eqToIso <| CategoryTheory.Functor.hext\n    (by intro; refine FullSubcategory.ext ?_; rfl) (by intros; rfl)\n\n"}
{"name":"TopCat.Presheaf.whiskerIsoMapGenerateCocone_inv_hom","module":"Mathlib.Topology.Sheaves.SheafCondition.OpensLeCover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type w\nU : ι → TopologicalSpace.Opens ↑X\nY : TopologicalSpace.Opens ↑X\nhY : Eq Y (iSup U)\n⊢ Eq (F.whiskerIsoMapGenerateCocone U hY).inv.hom (F.map (CategoryTheory.eqToHom ⋯))","decl":"/-- Given a family of opens `opensLeCoverCocone U` is essentially the natural cocone\n    associated to the sieve generated by the presieve associated to `U` with indexing\n    category changed using the above equivalence. -/\n@[simps]\ndef whiskerIsoMapGenerateCocone (hY : Y = iSup U) :\n    (F.mapCone (opensLeCoverCocone U).op).whisker (generateEquivalenceOpensLe U hY).op.functor ≅\n      F.mapCone (Sieve.generate (presieveOfCoveringAux U Y)).arrows.cocone.op where\n  hom :=\n    { hom := F.map (eqToHom (congr_arg op hY.symm))\n      w := fun j => by\n        erw [← F.map_comp]\n        dsimp\n        congr 1 }\n  inv :=\n    { hom := F.map (eqToHom (congr_arg op hY))\n      w := fun j => by\n        erw [← F.map_comp]\n        dsimp\n        congr 1 }\n  hom_inv_id := by\n    ext\n    simp [eqToHom_map]\n  inv_hom_id := by\n    ext\n    simp [eqToHom_map]\n\n"}
{"name":"TopCat.Presheaf.whiskerIsoMapGenerateCocone_hom_hom","module":"Mathlib.Topology.Sheaves.SheafCondition.OpensLeCover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type w\nU : ι → TopologicalSpace.Opens ↑X\nY : TopologicalSpace.Opens ↑X\nhY : Eq Y (iSup U)\n⊢ Eq (F.whiskerIsoMapGenerateCocone U hY).hom.hom (F.map (CategoryTheory.eqToHom ⋯))","decl":"/-- Given a family of opens `opensLeCoverCocone U` is essentially the natural cocone\n    associated to the sieve generated by the presieve associated to `U` with indexing\n    category changed using the above equivalence. -/\n@[simps]\ndef whiskerIsoMapGenerateCocone (hY : Y = iSup U) :\n    (F.mapCone (opensLeCoverCocone U).op).whisker (generateEquivalenceOpensLe U hY).op.functor ≅\n      F.mapCone (Sieve.generate (presieveOfCoveringAux U Y)).arrows.cocone.op where\n  hom :=\n    { hom := F.map (eqToHom (congr_arg op hY.symm))\n      w := fun j => by\n        erw [← F.map_comp]\n        dsimp\n        congr 1 }\n  inv :=\n    { hom := F.map (eqToHom (congr_arg op hY))\n      w := fun j => by\n        erw [← F.map_comp]\n        dsimp\n        congr 1 }\n  hom_inv_id := by\n    ext\n    simp [eqToHom_map]\n  inv_hom_id := by\n    ext\n    simp [eqToHom_map]\n\n"}
{"name":"TopCat.Presheaf.isSheaf_iff_isSheafOpensLeCover","module":"Mathlib.Topology.Sheaves.SheafCondition.OpensLeCover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : TopCat\nF : TopCat.Presheaf C X\n⊢ Iff F.IsSheaf F.IsSheafOpensLeCover","decl":"/-- A presheaf `(opens X)ᵒᵖ ⥤ C` on a topological space `X` is a sheaf on the site `opens X` iff\n    it satisfies the `IsSheafOpensLeCover` sheaf condition. The latter is not the\n    official definition of sheaves on spaces, but has the advantage that it does not\n    require `has_products C`. -/\ntheorem isSheaf_iff_isSheafOpensLeCover : F.IsSheaf ↔ F.IsSheafOpensLeCover := by\n  refine (Presheaf.isSheaf_iff_isLimit _ _).trans ?_\n  constructor\n  · intro h ι U\n    rw [(isLimitOpensLeEquivGenerate₁ F U rfl).nonempty_congr]\n    apply h\n    apply presieveOfCovering.mem_grothendieckTopology\n  · intro h Y S\n    rw [← Sieve.generate_sieve S]\n    intro hS\n    rw [← (isLimitOpensLeEquivGenerate₂ F S.1 hS).nonempty_congr]\n    apply h\n\n"}
