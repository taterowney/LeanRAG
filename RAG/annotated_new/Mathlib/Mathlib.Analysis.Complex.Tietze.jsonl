{"name":"TietzeExtension.of_tvs","module":"Mathlib.Analysis.Complex.Tietze","initialProofState":"ğ•œ : Type v\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nE : Type w\ninstâœâ¸ : AddCommGroup E\ninstâœâ· : Module ğ•œ E\ninstâœâ¶ : TopologicalSpace E\ninstâœâµ : TopologicalAddGroup E\ninstâœâ´ : ContinuousSMul ğ•œ E\ninstâœÂ³ : T2Space E\ninstâœÂ² : FiniteDimensional ğ•œ E\ninstâœÂ¹ : CompleteSpace ğ•œ\ninstâœ : TietzeExtension ğ•œ\nâŠ¢ TietzeExtension E","decl":"theorem TietzeExtension.of_tvs (ğ•œ : Type v) [NontriviallyNormedField ğ•œ] {E : Type w}\n    [AddCommGroup E] [Module ğ•œ E] [TopologicalSpace E] [TopologicalAddGroup E] [ContinuousSMul ğ•œ E]\n    [T2Space E] [FiniteDimensional ğ•œ E] [CompleteSpace ğ•œ] [TietzeExtension.{u, v} ğ•œ] :\n    TietzeExtension.{u, w} E :=\n  Basis.ofVectorSpace ğ•œ E |>.equivFun.toContinuousLinearEquiv.toHomeomorph |> .of_homeo\n\n"}
{"name":"Complex.instTietzeExtension","module":"Mathlib.Analysis.Complex.Tietze","initialProofState":"âŠ¢ TietzeExtension Complex","decl":"instance Complex.instTietzeExtension : TietzeExtension â„‚ :=\n  TietzeExtension.of_tvs â„\n\n"}
{"name":"RCLike.instTietzeExtension","module":"Mathlib.Analysis.Complex.Tietze","initialProofState":"ğ•œ : Type u_1\ninstâœ : RCLike ğ•œ\nâŠ¢ TietzeExtension ğ•œ","decl":"instance (priority := 900) RCLike.instTietzeExtension {ğ•œ : Type*} [RCLike ğ•œ] :\n    TietzeExtension ğ•œ := TietzeExtension.of_tvs â„\n\n"}
{"name":"RCLike.instTietzeExtensionTVS","module":"Mathlib.Analysis.Complex.Tietze","initialProofState":"ğ•œ : Type v\ninstâœâ· : RCLike ğ•œ\nE : Type w\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œ E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : TopologicalAddGroup E\ninstâœÂ² : ContinuousSMul ğ•œ E\ninstâœÂ¹ : T2Space E\ninstâœ : FiniteDimensional ğ•œ E\nâŠ¢ TietzeExtension E","decl":"instance RCLike.instTietzeExtensionTVS {ğ•œ : Type v} [RCLike ğ•œ] {E : Type w}\n    [AddCommGroup E] [Module ğ•œ E] [TopologicalSpace E] [TopologicalAddGroup E]\n    [ContinuousSMul ğ•œ E] [T2Space E] [FiniteDimensional ğ•œ E] :\n    TietzeExtension.{u, w} E :=\n  TietzeExtension.of_tvs ğ•œ\n\n"}
{"name":"Set.instTietzeExtensionUnitBall","module":"Mathlib.Analysis.Complex.Tietze","initialProofState":"ğ•œ : Type v\ninstâœÂ³ : RCLike ğ•œ\nE : Type w\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\nâŠ¢ TietzeExtension â†‘(Metric.ball 0 1)","decl":"instance Set.instTietzeExtensionUnitBall {ğ•œ : Type v} [RCLike ğ•œ] {E : Type w}\n    [NormedAddCommGroup E] [NormedSpace ğ•œ E] [FiniteDimensional ğ•œ E] :\n    TietzeExtension.{u, w} (Metric.ball (0 : E) 1) :=\n  have : NormedSpace â„ E := NormedSpace.restrictScalars â„ ğ•œ E\n  .of_homeo Homeomorph.unitBall.symm\n\n"}
{"name":"Set.instTietzeExtensionUnitClosedBall","module":"Mathlib.Analysis.Complex.Tietze","initialProofState":"ğ•œ : Type v\ninstâœÂ³ : RCLike ğ•œ\nE : Type w\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\nâŠ¢ TietzeExtension â†‘(Metric.closedBall 0 1)","decl":"instance Set.instTietzeExtensionUnitClosedBall {ğ•œ : Type v} [RCLike ğ•œ] {E : Type w}\n    [NormedAddCommGroup E] [NormedSpace ğ•œ E] [FiniteDimensional ğ•œ E] :\n    TietzeExtension.{u, w} (Metric.closedBall (0 : E) 1) := by\n  have : NormedSpace â„ E := NormedSpace.restrictScalars â„ ğ•œ E\n  have : IsScalarTower â„ ğ•œ E := Real.isScalarTower\n  -- I didn't find this retract in Mathlib.\n  let g : E â†’ E := fun x â†¦ â€–xâ€–â»Â¹ â€¢ x\n  classical\n  suffices this : Continuous (piecewise (Metric.closedBall 0 1) id g) by\n    refine .of_retract âŸ¨Subtype.val, by fun_propâŸ© âŸ¨_, this.codRestrict fun x â†¦ ?_âŸ© ?_\n    Â· by_cases hx : x âˆˆ Metric.closedBall 0 1\n      Â· simpa [piecewise_eq_of_mem (hi := hx)] using hx\n      Â· simp only [g, piecewise_eq_of_not_mem (hi := hx), RCLike.real_smul_eq_coe_smul (K := ğ•œ)]\n        by_cases hx' : x = 0 <;> simp [hx']\n    Â· ext x\n      simp [piecewise_eq_of_mem (hi := x.property)]\n  refine continuous_piecewise (fun x hx â†¦ ?_) continuousOn_id ?_\n  Â· replace hx : â€–xâ€– = 1 := by simpa [frontier_closedBall (0 : E) one_ne_zero] using hx\n    simp [g, hx]\n  Â· refine continuousOn_id.norm.invâ‚€ ?_ |>.smul continuousOn_id\n    simp only [closure_compl, interior_closedBall (0 : E) one_ne_zero, mem_compl_iff,\n      Metric.mem_ball, dist_zero_right, not_lt, id_eq, ne_eq, norm_eq_zero]\n    exact fun x hx â†¦ norm_pos_iff.mp <| one_pos.trans_le hx\n\n"}
{"name":"Metric.instTietzeExtensionBall","module":"Mathlib.Analysis.Complex.Tietze","initialProofState":"ğ•œ : Type v\ninstâœÂ³ : RCLike ğ•œ\nE : Type w\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\nr : Real\nhr : LT.lt 0 r\nâŠ¢ TietzeExtension â†‘(Metric.ball 0 r)","decl":"theorem Metric.instTietzeExtensionBall {ğ•œ : Type v} [RCLike ğ•œ] {E : Type w}\n    [NormedAddCommGroup E] [NormedSpace ğ•œ E] [FiniteDimensional ğ•œ E] {r : â„} (hr : 0 < r) :\n    TietzeExtension.{u, w} (Metric.ball (0 : E) r) :=\n  have : NormedSpace â„ E := NormedSpace.restrictScalars â„ ğ•œ E\n  .of_homeo <| show (Metric.ball (0 : E) r) â‰ƒâ‚œ (Metric.ball (0 : E) 1) from\n    PartialHomeomorph.unitBallBall (0 : E) r hr |>.toHomeomorphSourceTarget.symm\n\n"}
{"name":"Metric.instTietzeExtensionClosedBall","module":"Mathlib.Analysis.Complex.Tietze","initialProofState":"ğ•œ : Type v\ninstâœÂ³ : RCLike ğ•œ\nE : Type w\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\ny : E\nr : Real\nhr : LT.lt 0 r\nâŠ¢ TietzeExtension â†‘(Metric.closedBall y r)","decl":"theorem Metric.instTietzeExtensionClosedBall (ğ•œ : Type v) [RCLike ğ•œ] {E : Type w}\n    [NormedAddCommGroup E] [NormedSpace ğ•œ E] [FiniteDimensional ğ•œ E] (y : E) {r : â„} (hr : 0 < r) :\n    TietzeExtension.{u, w} (Metric.closedBall y r) :=\n  .of_homeo <| by\n    show (Metric.closedBall y r) â‰ƒâ‚œ (Metric.closedBall (0 : E) 1)\n    symm\n    apply (DilationEquiv.smulTorsor y (k := (r : ğ•œ)) <| by exact_mod_cast hr.ne').toHomeomorph.sets\n    ext x\n    simp only [mem_closedBall, dist_zero_right, DilationEquiv.coe_toHomeomorph, Set.mem_preimage,\n      DilationEquiv.smulTorsor_apply, vadd_eq_add, dist_add_self_left, norm_smul,\n      RCLike.norm_ofReal, abs_of_nonneg hr.le]\n    exact (mul_le_iff_le_one_right hr).symm\n\n"}
{"name":"BoundedContinuousFunction.exists_norm_eq_restrict_eq","module":"Mathlib.Analysis.Complex.Tietze","initialProofState":"X : Type u\ninstâœâµ : TopologicalSpace X\ninstâœâ´ : NormalSpace X\ns : Set X\nhs : IsClosed s\nğ•œ : Type v\ninstâœÂ³ : RCLike ğ•œ\nE : Type w\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\nf : BoundedContinuousFunction (â†‘s) E\nâŠ¢ Exists fun g => And (Eq (Norm.norm g) (Norm.norm f)) (Eq (g.restrict s) f)","decl":"include ğ•œ hs in\n/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version with a closed\nembedding and bundled composition. If `e : C(X, Y)` is a closed embedding of a topological space\ninto a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous function, then there exists\na bounded continuous function `g : Y â†’áµ‡ â„` of the same norm such that `g âˆ˜ e = f`. -/\ntheorem exists_norm_eq_restrict_eq (f : s â†’áµ‡ E) :\n    âˆƒ g : X â†’áµ‡ E, â€–gâ€– = â€–fâ€– âˆ§ g.restrict s = f := by\n  by_cases hf : â€–fâ€– = 0; Â· exact âŸ¨0, by aesopâŸ©\n  have := Metric.instTietzeExtensionClosedBall.{u, v} ğ•œ (0 : E) (by aesop : 0 < â€–fâ€–)\n  have hf' x : f x âˆˆ Metric.closedBall 0 â€–fâ€– := by simpa using f.norm_coe_le_norm x\n  obtain âŸ¨g, hg_mem, hgâŸ© := (f : C(s, E)).exists_forall_mem_restrict_eq hs hf'\n  simp only [Metric.mem_closedBall, dist_zero_right] at hg_mem\n  let g' : X â†’áµ‡ E := .ofNormedAddCommGroup g (map_continuous g) â€–fâ€– hg_mem\n  refine âŸ¨g', ?_, by ext x; congrm($(hg) x)âŸ©\n  apply le_antisymm ((g'.norm_le <| by positivity).mpr hg_mem)\n  refine (f.norm_le <| by positivity).mpr fun x â†¦ ?_\n  have hx : f x = g' x := by simpa using congr($(hg) x).symm\n  rw [hx]\n  exact g'.norm_le (norm_nonneg g') |>.mp le_rfl x\n\n"}
