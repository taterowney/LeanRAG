{"name":"TietzeExtension.of_tvs","module":"Mathlib.Analysis.Complex.Tietze","initialProofState":"𝕜 : Type v\ninst✝⁹ : NontriviallyNormedField 𝕜\nE : Type w\ninst✝⁸ : AddCommGroup E\ninst✝⁷ : Module 𝕜 E\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : TopologicalAddGroup E\ninst✝⁴ : ContinuousSMul 𝕜 E\ninst✝³ : T2Space E\ninst✝² : FiniteDimensional 𝕜 E\ninst✝¹ : CompleteSpace 𝕜\ninst✝ : TietzeExtension 𝕜\n⊢ TietzeExtension E","decl":"theorem TietzeExtension.of_tvs (𝕜 : Type v) [NontriviallyNormedField 𝕜] {E : Type w}\n    [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [TopologicalAddGroup E] [ContinuousSMul 𝕜 E]\n    [T2Space E] [FiniteDimensional 𝕜 E] [CompleteSpace 𝕜] [TietzeExtension.{u, v} 𝕜] :\n    TietzeExtension.{u, w} E :=\n  Basis.ofVectorSpace 𝕜 E |>.equivFun.toContinuousLinearEquiv.toHomeomorph |> .of_homeo\n\n"}
{"name":"Complex.instTietzeExtension","module":"Mathlib.Analysis.Complex.Tietze","initialProofState":"⊢ TietzeExtension Complex","decl":"instance Complex.instTietzeExtension : TietzeExtension ℂ :=\n  TietzeExtension.of_tvs ℝ\n\n"}
{"name":"RCLike.instTietzeExtension","module":"Mathlib.Analysis.Complex.Tietze","initialProofState":"𝕜 : Type u_1\ninst✝ : RCLike 𝕜\n⊢ TietzeExtension 𝕜","decl":"instance (priority := 900) RCLike.instTietzeExtension {𝕜 : Type*} [RCLike 𝕜] :\n    TietzeExtension 𝕜 := TietzeExtension.of_tvs ℝ\n\n"}
{"name":"RCLike.instTietzeExtensionTVS","module":"Mathlib.Analysis.Complex.Tietze","initialProofState":"𝕜 : Type v\ninst✝⁷ : RCLike 𝕜\nE : Type w\ninst✝⁶ : AddCommGroup E\ninst✝⁵ : Module 𝕜 E\ninst✝⁴ : TopologicalSpace E\ninst✝³ : TopologicalAddGroup E\ninst✝² : ContinuousSMul 𝕜 E\ninst✝¹ : T2Space E\ninst✝ : FiniteDimensional 𝕜 E\n⊢ TietzeExtension E","decl":"instance RCLike.instTietzeExtensionTVS {𝕜 : Type v} [RCLike 𝕜] {E : Type w}\n    [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [TopologicalAddGroup E]\n    [ContinuousSMul 𝕜 E] [T2Space E] [FiniteDimensional 𝕜 E] :\n    TietzeExtension.{u, w} E :=\n  TietzeExtension.of_tvs 𝕜\n\n"}
{"name":"Set.instTietzeExtensionUnitBall","module":"Mathlib.Analysis.Complex.Tietze","initialProofState":"𝕜 : Type v\ninst✝³ : RCLike 𝕜\nE : Type w\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : FiniteDimensional 𝕜 E\n⊢ TietzeExtension ↑(Metric.ball 0 1)","decl":"instance Set.instTietzeExtensionUnitBall {𝕜 : Type v} [RCLike 𝕜] {E : Type w}\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] [FiniteDimensional 𝕜 E] :\n    TietzeExtension.{u, w} (Metric.ball (0 : E) 1) :=\n  have : NormedSpace ℝ E := NormedSpace.restrictScalars ℝ 𝕜 E\n  .of_homeo Homeomorph.unitBall.symm\n\n"}
{"name":"Set.instTietzeExtensionUnitClosedBall","module":"Mathlib.Analysis.Complex.Tietze","initialProofState":"𝕜 : Type v\ninst✝³ : RCLike 𝕜\nE : Type w\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : FiniteDimensional 𝕜 E\n⊢ TietzeExtension ↑(Metric.closedBall 0 1)","decl":"instance Set.instTietzeExtensionUnitClosedBall {𝕜 : Type v} [RCLike 𝕜] {E : Type w}\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] [FiniteDimensional 𝕜 E] :\n    TietzeExtension.{u, w} (Metric.closedBall (0 : E) 1) := by\n  have : NormedSpace ℝ E := NormedSpace.restrictScalars ℝ 𝕜 E\n  have : IsScalarTower ℝ 𝕜 E := Real.isScalarTower\n  -- I didn't find this retract in Mathlib.\n  let g : E → E := fun x ↦ ‖x‖⁻¹ • x\n  classical\n  suffices this : Continuous (piecewise (Metric.closedBall 0 1) id g) by\n    refine .of_retract ⟨Subtype.val, by fun_prop⟩ ⟨_, this.codRestrict fun x ↦ ?_⟩ ?_\n    · by_cases hx : x ∈ Metric.closedBall 0 1\n      · simpa [piecewise_eq_of_mem (hi := hx)] using hx\n      · simp only [g, piecewise_eq_of_not_mem (hi := hx), RCLike.real_smul_eq_coe_smul (K := 𝕜)]\n        by_cases hx' : x = 0 <;> simp [hx']\n    · ext x\n      simp [piecewise_eq_of_mem (hi := x.property)]\n  refine continuous_piecewise (fun x hx ↦ ?_) continuousOn_id ?_\n  · replace hx : ‖x‖ = 1 := by simpa [frontier_closedBall (0 : E) one_ne_zero] using hx\n    simp [g, hx]\n  · refine continuousOn_id.norm.inv₀ ?_ |>.smul continuousOn_id\n    simp only [closure_compl, interior_closedBall (0 : E) one_ne_zero, mem_compl_iff,\n      Metric.mem_ball, dist_zero_right, not_lt, id_eq, ne_eq, norm_eq_zero]\n    exact fun x hx ↦ norm_pos_iff.mp <| one_pos.trans_le hx\n\n"}
{"name":"Metric.instTietzeExtensionBall","module":"Mathlib.Analysis.Complex.Tietze","initialProofState":"𝕜 : Type v\ninst✝³ : RCLike 𝕜\nE : Type w\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : FiniteDimensional 𝕜 E\nr : Real\nhr : LT.lt 0 r\n⊢ TietzeExtension ↑(Metric.ball 0 r)","decl":"theorem Metric.instTietzeExtensionBall {𝕜 : Type v} [RCLike 𝕜] {E : Type w}\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] [FiniteDimensional 𝕜 E] {r : ℝ} (hr : 0 < r) :\n    TietzeExtension.{u, w} (Metric.ball (0 : E) r) :=\n  have : NormedSpace ℝ E := NormedSpace.restrictScalars ℝ 𝕜 E\n  .of_homeo <| show (Metric.ball (0 : E) r) ≃ₜ (Metric.ball (0 : E) 1) from\n    PartialHomeomorph.unitBallBall (0 : E) r hr |>.toHomeomorphSourceTarget.symm\n\n"}
{"name":"Metric.instTietzeExtensionClosedBall","module":"Mathlib.Analysis.Complex.Tietze","initialProofState":"𝕜 : Type v\ninst✝³ : RCLike 𝕜\nE : Type w\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : FiniteDimensional 𝕜 E\ny : E\nr : Real\nhr : LT.lt 0 r\n⊢ TietzeExtension ↑(Metric.closedBall y r)","decl":"theorem Metric.instTietzeExtensionClosedBall (𝕜 : Type v) [RCLike 𝕜] {E : Type w}\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] [FiniteDimensional 𝕜 E] (y : E) {r : ℝ} (hr : 0 < r) :\n    TietzeExtension.{u, w} (Metric.closedBall y r) :=\n  .of_homeo <| by\n    show (Metric.closedBall y r) ≃ₜ (Metric.closedBall (0 : E) 1)\n    symm\n    apply (DilationEquiv.smulTorsor y (k := (r : 𝕜)) <| by exact_mod_cast hr.ne').toHomeomorph.sets\n    ext x\n    simp only [mem_closedBall, dist_zero_right, DilationEquiv.coe_toHomeomorph, Set.mem_preimage,\n      DilationEquiv.smulTorsor_apply, vadd_eq_add, dist_add_self_left, norm_smul,\n      RCLike.norm_ofReal, abs_of_nonneg hr.le]\n    exact (mul_le_iff_le_one_right hr).symm\n\n"}
{"name":"BoundedContinuousFunction.exists_norm_eq_restrict_eq","module":"Mathlib.Analysis.Complex.Tietze","initialProofState":"X : Type u\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : NormalSpace X\ns : Set X\nhs : IsClosed s\n𝕜 : Type v\ninst✝³ : RCLike 𝕜\nE : Type w\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : FiniteDimensional 𝕜 E\nf : BoundedContinuousFunction (↑s) E\n⊢ Exists fun g => And (Eq (Norm.norm g) (Norm.norm f)) (Eq (g.restrict s) f)","decl":"include 𝕜 hs in\n/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version with a closed\nembedding and bundled composition. If `e : C(X, Y)` is a closed embedding of a topological space\ninto a normal topological space and `f : X →ᵇ ℝ` is a bounded continuous function, then there exists\na bounded continuous function `g : Y →ᵇ ℝ` of the same norm such that `g ∘ e = f`. -/\ntheorem exists_norm_eq_restrict_eq (f : s →ᵇ E) :\n    ∃ g : X →ᵇ E, ‖g‖ = ‖f‖ ∧ g.restrict s = f := by\n  by_cases hf : ‖f‖ = 0; · exact ⟨0, by aesop⟩\n  have := Metric.instTietzeExtensionClosedBall.{u, v} 𝕜 (0 : E) (by aesop : 0 < ‖f‖)\n  have hf' x : f x ∈ Metric.closedBall 0 ‖f‖ := by simpa using f.norm_coe_le_norm x\n  obtain ⟨g, hg_mem, hg⟩ := (f : C(s, E)).exists_forall_mem_restrict_eq hs hf'\n  simp only [Metric.mem_closedBall, dist_zero_right] at hg_mem\n  let g' : X →ᵇ E := .ofNormedAddCommGroup g (map_continuous g) ‖f‖ hg_mem\n  refine ⟨g', ?_, by ext x; congrm($(hg) x)⟩\n  apply le_antisymm ((g'.norm_le <| by positivity).mpr hg_mem)\n  refine (f.norm_le <| by positivity).mpr fun x ↦ ?_\n  have hx : f x = g' x := by simpa using congr($(hg) x).symm\n  rw [hx]\n  exact g'.norm_le (norm_nonneg g') |>.mp le_rfl x\n\n"}
