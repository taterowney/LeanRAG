{"name":"CategoryTheory.Preadditive.comp_add","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Preadditive C\nP Q R : C\nf : Quiver.Hom P Q\ng g' : Quiver.Hom Q R\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (HAdd.hAdd g g')) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f g'))","decl":"/-- A category is called preadditive if `P ⟶ Q` is an abelian group such that composition is\n    linear in both variables. -/\nclass Preadditive where\n  homGroup : ∀ P Q : C, AddCommGroup (P ⟶ Q) := by infer_instance\n  add_comp : ∀ (P Q R : C) (f f' : P ⟶ Q) (g : Q ⟶ R), (f + f') ≫ g = f ≫ g + f' ≫ g := by\n    aesop_cat\n  comp_add : ∀ (P Q R : C) (f : P ⟶ Q) (g g' : Q ⟶ R), f ≫ (g + g') = f ≫ g + f ≫ g' := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Preadditive.add_comp","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Preadditive C\nP Q R : C\nf f' : Quiver.Hom P Q\ng : Quiver.Hom Q R\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HAdd.hAdd f f') g) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f' g))","decl":"/-- A category is called preadditive if `P ⟶ Q` is an abelian group such that composition is\n    linear in both variables. -/\nclass Preadditive where\n  homGroup : ∀ P Q : C, AddCommGroup (P ⟶ Q) := by infer_instance\n  add_comp : ∀ (P Q R : C) (f f' : P ⟶ Q) (g : Q ⟶ R), (f + f') ≫ g = f ≫ g + f' ≫ g := by\n    aesop_cat\n  comp_add : ∀ (P Q R : C) (f : P ⟶ Q) (g g' : Q ⟶ R), f ≫ (g + g') = f ≫ g + f ≫ g' := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Preadditive.add_comp_assoc","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Preadditive C\nP Q R : C\nf f' : Quiver.Hom P Q\ng : Quiver.Hom Q R\nZ : C\nh : Quiver.Hom R Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HAdd.hAdd f f') (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.CategoryStruct.comp (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f' g)) h)","decl":"attribute [reassoc, simp] Preadditive.add_comp\n\n"}
{"name":"CategoryTheory.Preadditive.comp_add_assoc","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Preadditive C\nP Q R : C\nf : Quiver.Hom P Q\ng g' : Quiver.Hom Q R\nZ : C\nh : Quiver.Hom R Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (HAdd.hAdd g g') h)) (CategoryTheory.CategoryStruct.comp (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f g')) h)","decl":"attribute [reassoc] Preadditive.comp_add\n\n"}
{"name":"CategoryTheory.Preadditive.sub_comp_assoc","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nP Q R : C\nf f' : Quiver.Hom P Q\ng : Quiver.Hom Q R\nZ : C\nh : Quiver.Hom R Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HSub.hSub f f') (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.CategoryStruct.comp (HSub.hSub (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f' g)) h)","decl":"@[reassoc, simp]\ntheorem sub_comp : (f - f') ≫ g = f ≫ g - f' ≫ g :=\n  map_sub (rightComp P g) f f'\n\n-- simp can prove the reassoc version\n"}
{"name":"CategoryTheory.Preadditive.sub_comp","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nP Q R : C\nf f' : Quiver.Hom P Q\ng : Quiver.Hom Q R\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HSub.hSub f f') g) (HSub.hSub (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f' g))","decl":"@[reassoc, simp]\ntheorem sub_comp : (f - f') ≫ g = f ≫ g - f' ≫ g :=\n  map_sub (rightComp P g) f f'\n\n-- simp can prove the reassoc version\n"}
{"name":"CategoryTheory.Preadditive.comp_sub_assoc","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nP Q R : C\nf : Quiver.Hom P Q\ng g' : Quiver.Hom Q R\nZ : C\nh : Quiver.Hom R Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (HSub.hSub g g') h)) (CategoryTheory.CategoryStruct.comp (HSub.hSub (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f g')) h)","decl":"@[reassoc, simp]\ntheorem comp_sub : f ≫ (g - g') = f ≫ g - f ≫ g' :=\n  map_sub (leftComp R f) g g'\n\n-- simp can prove the reassoc version\n"}
{"name":"CategoryTheory.Preadditive.comp_sub","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nP Q R : C\nf : Quiver.Hom P Q\ng g' : Quiver.Hom Q R\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (HSub.hSub g g')) (HSub.hSub (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f g'))","decl":"@[reassoc, simp]\ntheorem comp_sub : f ≫ (g - g') = f ≫ g - f ≫ g' :=\n  map_sub (leftComp R f) g g'\n\n-- simp can prove the reassoc version\n"}
{"name":"CategoryTheory.Preadditive.neg_comp","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nP Q R : C\nf : Quiver.Hom P Q\ng : Quiver.Hom Q R\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Neg.neg f) g) (Neg.neg (CategoryTheory.CategoryStruct.comp f g))","decl":"@[reassoc, simp]\ntheorem neg_comp : (-f) ≫ g = -f ≫ g :=\n  map_neg (rightComp P g) f\n\n-- simp can prove the reassoc version\n"}
{"name":"CategoryTheory.Preadditive.neg_comp_assoc","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nP Q R : C\nf : Quiver.Hom P Q\ng : Quiver.Hom Q R\nZ : C\nh : Quiver.Hom R Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Neg.neg f) (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.CategoryStruct.comp (Neg.neg (CategoryTheory.CategoryStruct.comp f g)) h)","decl":"@[reassoc, simp]\ntheorem neg_comp : (-f) ≫ g = -f ≫ g :=\n  map_neg (rightComp P g) f\n\n-- simp can prove the reassoc version\n"}
{"name":"CategoryTheory.Preadditive.comp_neg","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nP Q R : C\nf : Quiver.Hom P Q\ng : Quiver.Hom Q R\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (Neg.neg g)) (Neg.neg (CategoryTheory.CategoryStruct.comp f g))","decl":"@[reassoc, simp]\ntheorem comp_neg : f ≫ (-g) = -f ≫ g :=\n  map_neg (leftComp R f) g\n\n"}
{"name":"CategoryTheory.Preadditive.comp_neg_assoc","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nP Q R : C\nf : Quiver.Hom P Q\ng : Quiver.Hom Q R\nZ : C\nh : Quiver.Hom R Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (Neg.neg g) h)) (CategoryTheory.CategoryStruct.comp (Neg.neg (CategoryTheory.CategoryStruct.comp f g)) h)","decl":"@[reassoc, simp]\ntheorem comp_neg : f ≫ (-g) = -f ≫ g :=\n  map_neg (leftComp R f) g\n\n"}
{"name":"CategoryTheory.Preadditive.neg_comp_neg","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nP Q R : C\nf : Quiver.Hom P Q\ng : Quiver.Hom Q R\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Neg.neg f) (Neg.neg g)) (CategoryTheory.CategoryStruct.comp f g)","decl":"@[reassoc]\ntheorem neg_comp_neg : (-f) ≫ (-g) = f ≫ g := by simp\n\n"}
{"name":"CategoryTheory.Preadditive.neg_comp_neg_assoc","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nP Q R : C\nf : Quiver.Hom P Q\ng : Quiver.Hom Q R\nZ : C\nh : Quiver.Hom R Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Neg.neg f) (CategoryTheory.CategoryStruct.comp (Neg.neg g) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc]\ntheorem neg_comp_neg : (-f) ≫ (-g) = f ≫ g := by simp\n\n"}
{"name":"CategoryTheory.Preadditive.nsmul_comp","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nP Q R : C\nf : Quiver.Hom P Q\ng : Quiver.Hom Q R\nn : Nat\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HSMul.hSMul n f) g) (HSMul.hSMul n (CategoryTheory.CategoryStruct.comp f g))","decl":"theorem nsmul_comp (n : ℕ) : (n • f) ≫ g = n • f ≫ g :=\n  map_nsmul (rightComp P g) n f\n\n"}
{"name":"CategoryTheory.Preadditive.comp_nsmul","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nP Q R : C\nf : Quiver.Hom P Q\ng : Quiver.Hom Q R\nn : Nat\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (HSMul.hSMul n g)) (HSMul.hSMul n (CategoryTheory.CategoryStruct.comp f g))","decl":"theorem comp_nsmul (n : ℕ) : f ≫ (n • g) = n • f ≫ g :=\n  map_nsmul (leftComp R f) n g\n\n"}
{"name":"CategoryTheory.Preadditive.zsmul_comp","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nP Q R : C\nf : Quiver.Hom P Q\ng : Quiver.Hom Q R\nn : Int\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HSMul.hSMul n f) g) (HSMul.hSMul n (CategoryTheory.CategoryStruct.comp f g))","decl":"theorem zsmul_comp (n : ℤ) : (n • f) ≫ g = n • f ≫ g :=\n  map_zsmul (rightComp P g) n f\n\n"}
{"name":"CategoryTheory.Preadditive.comp_zsmul","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nP Q R : C\nf : Quiver.Hom P Q\ng : Quiver.Hom Q R\nn : Int\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (HSMul.hSMul n g)) (HSMul.hSMul n (CategoryTheory.CategoryStruct.comp f g))","decl":"theorem comp_zsmul (n : ℤ) : f ≫ (n • g) = n • f ≫ g :=\n  map_zsmul (leftComp R f) n g\n\n"}
{"name":"CategoryTheory.Preadditive.comp_sum","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nP Q R : C\nJ : Type u_1\ns : Finset J\nf : Quiver.Hom P Q\ng : J → Quiver.Hom Q R\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (s.sum fun j => g j)) (s.sum fun j => CategoryTheory.CategoryStruct.comp f (g j))","decl":"@[reassoc]\ntheorem comp_sum {P Q R : C} {J : Type*} (s : Finset J) (f : P ⟶ Q) (g : J → (Q ⟶ R)) :\n    (f ≫ ∑ j ∈ s, g j) = ∑ j ∈ s, f ≫ g j :=\n  map_sum (leftComp R f) _ _\n\n"}
{"name":"CategoryTheory.Preadditive.comp_sum_assoc","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nP Q R : C\nJ : Type u_1\ns : Finset J\nf : Quiver.Hom P Q\ng : J → Quiver.Hom Q R\nZ : C\nh : Quiver.Hom R Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (s.sum fun j => g j) h)) (CategoryTheory.CategoryStruct.comp (s.sum fun j => CategoryTheory.CategoryStruct.comp f (g j)) h)","decl":"@[reassoc]\ntheorem comp_sum {P Q R : C} {J : Type*} (s : Finset J) (f : P ⟶ Q) (g : J → (Q ⟶ R)) :\n    (f ≫ ∑ j ∈ s, g j) = ∑ j ∈ s, f ≫ g j :=\n  map_sum (leftComp R f) _ _\n\n"}
{"name":"CategoryTheory.Preadditive.sum_comp_assoc","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nP Q R : C\nJ : Type u_1\ns : Finset J\nf : J → Quiver.Hom P Q\ng : Quiver.Hom Q R\nZ : C\nh : Quiver.Hom R Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (s.sum fun j => f j) (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.CategoryStruct.comp (s.sum fun j => CategoryTheory.CategoryStruct.comp (f j) g) h)","decl":"@[reassoc]\ntheorem sum_comp {P Q R : C} {J : Type*} (s : Finset J) (f : J → (P ⟶ Q)) (g : Q ⟶ R) :\n    (∑ j ∈ s, f j) ≫ g = ∑ j ∈ s, f j ≫ g :=\n  map_sum (rightComp P g) _ _\n\n"}
{"name":"CategoryTheory.Preadditive.sum_comp","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nP Q R : C\nJ : Type u_1\ns : Finset J\nf : J → Quiver.Hom P Q\ng : Quiver.Hom Q R\n⊢ Eq (CategoryTheory.CategoryStruct.comp (s.sum fun j => f j) g) (s.sum fun j => CategoryTheory.CategoryStruct.comp (f j) g)","decl":"@[reassoc]\ntheorem sum_comp {P Q R : C} {J : Type*} (s : Finset J) (f : J → (P ⟶ Q)) (g : Q ⟶ R) :\n    (∑ j ∈ s, f j) ≫ g = ∑ j ∈ s, f j ≫ g :=\n  map_sum (rightComp P g) _ _\n\n"}
{"name":"CategoryTheory.Preadditive.instEpiNegHom","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nP Q : C\nf : Quiver.Hom P Q\ninst✝ : CategoryTheory.Epi f\n⊢ CategoryTheory.Epi (Neg.neg f)","decl":"instance {P Q : C} {f : P ⟶ Q} [Epi f] : Epi (-f) :=\n  ⟨fun g g' H => by rwa [neg_comp, neg_comp, ← comp_neg, ← comp_neg, cancel_epi, neg_inj] at H⟩\n\n"}
{"name":"CategoryTheory.Preadditive.instMonoNegHom","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nP Q : C\nf : Quiver.Hom P Q\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.Mono (Neg.neg f)","decl":"instance {P Q : C} {f : P ⟶ Q} [Mono f] : Mono (-f) :=\n  ⟨fun g g' H => by rwa [comp_neg, comp_neg, ← neg_comp, ← neg_comp, cancel_mono, neg_inj] at H⟩\n\n"}
{"name":"CategoryTheory.Preadditive.mono_of_cancel_zero","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nQ R : C\nf : Quiver.Hom Q R\nh : ∀ {P : C} (g : Quiver.Hom P Q), Eq (CategoryTheory.CategoryStruct.comp g f) 0 → Eq g 0\n⊢ CategoryTheory.Mono f","decl":"theorem mono_of_cancel_zero {Q R : C} (f : Q ⟶ R) (h : ∀ {P : C} (g : P ⟶ Q), g ≫ f = 0 → g = 0) :\n    Mono f where\n  right_cancellation := fun {Z} g₁ g₂ hg =>\n    sub_eq_zero.1 <| h _ <| (map_sub (rightComp Z f) g₁ g₂).trans <| sub_eq_zero.2 hg\n\n"}
{"name":"CategoryTheory.Preadditive.mono_iff_cancel_zero","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nQ R : C\nf : Quiver.Hom Q R\n⊢ Iff (CategoryTheory.Mono f) (∀ (P : C) (g : Quiver.Hom P Q), Eq (CategoryTheory.CategoryStruct.comp g f) 0 → Eq g 0)","decl":"theorem mono_iff_cancel_zero {Q R : C} (f : Q ⟶ R) :\n    Mono f ↔ ∀ (P : C) (g : P ⟶ Q), g ≫ f = 0 → g = 0 :=\n  ⟨fun _ _ _ => zero_of_comp_mono _, mono_of_cancel_zero f⟩\n\n"}
{"name":"CategoryTheory.Preadditive.mono_of_kernel_zero","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair f 0)\nw : Eq (CategoryTheory.Limits.kernel.ι f) 0\n⊢ CategoryTheory.Mono f","decl":"theorem mono_of_kernel_zero {X Y : C} {f : X ⟶ Y} [HasLimit (parallelPair f 0)]\n    (w : kernel.ι f = 0) : Mono f :=\n  mono_of_cancel_zero f fun g h => by rw [← kernel.lift_ι f g h, w, Limits.comp_zero]\n\n"}
{"name":"CategoryTheory.Preadditive.mono_of_isZero_kernel'","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.KernelFork f\nhc : CategoryTheory.Limits.IsLimit c\nh : CategoryTheory.Limits.IsZero c.pt\n⊢ CategoryTheory.Mono f","decl":"lemma mono_of_isZero_kernel' {X Y : C} {f : X ⟶ Y} (c : KernelFork f) (hc : IsLimit c)\n    (h : IsZero c.pt) : Mono f := mono_of_cancel_zero _ (fun g hg => by\n  obtain ⟨a, ha⟩ := KernelFork.IsLimit.lift' hc _ hg\n  rw [← ha, h.eq_of_tgt a 0, Limits.zero_comp])\n\n"}
{"name":"CategoryTheory.Preadditive.mono_of_isZero_kernel","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel f\nh : CategoryTheory.Limits.IsZero (CategoryTheory.Limits.kernel f)\n⊢ CategoryTheory.Mono f","decl":"lemma mono_of_isZero_kernel {X Y : C} (f : X ⟶ Y) [HasKernel f] (h : IsZero (kernel f)) :\n    Mono f :=\n  mono_of_isZero_kernel' _ (kernelIsKernel _) h\n\n"}
{"name":"CategoryTheory.Preadditive.epi_of_cancel_zero","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nP Q : C\nf : Quiver.Hom P Q\nh : ∀ {R : C} (g : Quiver.Hom Q R), Eq (CategoryTheory.CategoryStruct.comp f g) 0 → Eq g 0\n⊢ CategoryTheory.Epi f","decl":"theorem epi_of_cancel_zero {P Q : C} (f : P ⟶ Q) (h : ∀ {R : C} (g : Q ⟶ R), f ≫ g = 0 → g = 0) :\n    Epi f :=\n  ⟨fun {Z} g g' hg =>\n    sub_eq_zero.1 <| h _ <| (map_sub (leftComp Z f) g g').trans <| sub_eq_zero.2 hg⟩\n\n"}
{"name":"CategoryTheory.Preadditive.epi_iff_cancel_zero","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nP Q : C\nf : Quiver.Hom P Q\n⊢ Iff (CategoryTheory.Epi f) (∀ (R : C) (g : Quiver.Hom Q R), Eq (CategoryTheory.CategoryStruct.comp f g) 0 → Eq g 0)","decl":"theorem epi_iff_cancel_zero {P Q : C} (f : P ⟶ Q) :\n    Epi f ↔ ∀ (R : C) (g : Q ⟶ R), f ≫ g = 0 → g = 0 :=\n  ⟨fun _ _ _ => zero_of_epi_comp _, epi_of_cancel_zero f⟩\n\n"}
{"name":"CategoryTheory.Preadditive.epi_of_cokernel_zero","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.parallelPair f 0)\nw : Eq (CategoryTheory.Limits.cokernel.π f) 0\n⊢ CategoryTheory.Epi f","decl":"theorem epi_of_cokernel_zero {X Y : C} {f : X ⟶ Y} [HasColimit (parallelPair f 0)]\n    (w : cokernel.π f = 0) : Epi f :=\n  epi_of_cancel_zero f fun g h => by rw [← cokernel.π_desc f g h, w, Limits.zero_comp]\n\n"}
{"name":"CategoryTheory.Preadditive.epi_of_isZero_cokernel'","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.CokernelCofork f\nhc : CategoryTheory.Limits.IsColimit c\nh : CategoryTheory.Limits.IsZero c.pt\n⊢ CategoryTheory.Epi f","decl":"lemma epi_of_isZero_cokernel' {X Y : C} {f : X ⟶ Y} (c : CokernelCofork f) (hc : IsColimit c)\n    (h : IsZero c.pt) : Epi f := epi_of_cancel_zero _ (fun g hg => by\n  obtain ⟨a, ha⟩ := CokernelCofork.IsColimit.desc' hc _ hg\n  rw [← ha, h.eq_of_src a 0, Limits.comp_zero])\n\n"}
{"name":"CategoryTheory.Preadditive.epi_of_isZero_cokernel","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasCokernel f\nh : CategoryTheory.Limits.IsZero (CategoryTheory.Limits.cokernel f)\n⊢ CategoryTheory.Epi f","decl":"lemma epi_of_isZero_cokernel {X Y : C} (f : X ⟶ Y) [HasCokernel f] (h : IsZero (cokernel f)) :\n    Epi f :=\n  epi_of_isZero_cokernel' _ (cokernelIsCokernel _) h\n\n"}
{"name":"CategoryTheory.Preadditive.IsIso.comp_left_eq_zero","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nP Q R : C\nf : Quiver.Hom P Q\ng : Quiver.Hom Q R\ninst✝ : CategoryTheory.IsIso f\n⊢ Iff (Eq (CategoryTheory.CategoryStruct.comp f g) 0) (Eq g 0)","decl":"@[simp]\ntheorem comp_left_eq_zero [IsIso f] : f ≫ g = 0 ↔ g = 0 := by\n  rw [← IsIso.eq_inv_comp, Limits.comp_zero]\n\n"}
{"name":"CategoryTheory.Preadditive.IsIso.comp_right_eq_zero","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nP Q R : C\nf : Quiver.Hom P Q\ng : Quiver.Hom Q R\ninst✝ : CategoryTheory.IsIso g\n⊢ Iff (Eq (CategoryTheory.CategoryStruct.comp f g) 0) (Eq f 0)","decl":"@[simp]\ntheorem comp_right_eq_zero [IsIso g] : f ≫ g = 0 ↔ f = 0 := by\n  rw [← IsIso.eq_comp_inv, Limits.zero_comp]\n\n"}
{"name":"CategoryTheory.Preadditive.mono_of_kernel_iso_zero","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair f 0)\nw : CategoryTheory.Iso (CategoryTheory.Limits.kernel f) 0\n⊢ CategoryTheory.Mono f","decl":"theorem mono_of_kernel_iso_zero {X Y : C} {f : X ⟶ Y} [HasLimit (parallelPair f 0)]\n    (w : kernel f ≅ 0) : Mono f :=\n  mono_of_kernel_zero (zero_of_source_iso_zero _ w)\n\n"}
{"name":"CategoryTheory.Preadditive.epi_of_cokernel_iso_zero","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.parallelPair f 0)\nw : CategoryTheory.Iso (CategoryTheory.Limits.cokernel f) 0\n⊢ CategoryTheory.Epi f","decl":"theorem epi_of_cokernel_iso_zero {X Y : C} {f : X ⟶ Y} [HasColimit (parallelPair f 0)]\n    (w : cokernel f ≅ 0) : Epi f :=\n  epi_of_cokernel_zero (zero_of_target_iso_zero _ w)\n\n"}
{"name":"CategoryTheory.Preadditive.forkOfKernelFork_pt","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nf g : Quiver.Hom X Y\nc : CategoryTheory.Limits.KernelFork (HSub.hSub f g)\n⊢ Eq (CategoryTheory.Preadditive.forkOfKernelFork c).pt c.pt","decl":"/-- Map a kernel cone on the difference of two morphisms to the equalizer fork. -/\n@[simps! pt]\ndef forkOfKernelFork (c : KernelFork (f - g)) : Fork f g :=\n  Fork.ofι c.ι <| by rw [← sub_eq_zero, ← comp_sub, c.condition]\n\n"}
{"name":"CategoryTheory.Preadditive.forkOfKernelFork_ι","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nf g : Quiver.Hom X Y\nc : CategoryTheory.Limits.KernelFork (HSub.hSub f g)\n⊢ Eq (CategoryTheory.Preadditive.forkOfKernelFork c).ι (CategoryTheory.Limits.Fork.ι c)","decl":"@[simp]\ntheorem forkOfKernelFork_ι (c : KernelFork (f - g)) : (forkOfKernelFork c).ι = c.ι :=\n  rfl\n\n"}
{"name":"CategoryTheory.Preadditive.kernelForkOfFork_ι","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nf g : Quiver.Hom X Y\nc : CategoryTheory.Limits.Fork f g\n⊢ Eq (CategoryTheory.Limits.Fork.ι (CategoryTheory.Preadditive.kernelForkOfFork c)) c.ι","decl":"@[simp]\ntheorem kernelForkOfFork_ι (c : Fork f g) : (kernelForkOfFork c).ι = c.ι :=\n  rfl\n\n"}
{"name":"CategoryTheory.Preadditive.kernelForkOfFork_ofι","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nf g : Quiver.Hom X Y\nP : C\nι : Quiver.Hom P X\nw : Eq (CategoryTheory.CategoryStruct.comp ι f) (CategoryTheory.CategoryStruct.comp ι g)\n⊢ Eq (CategoryTheory.Preadditive.kernelForkOfFork (CategoryTheory.Limits.Fork.ofι ι w)) (CategoryTheory.Limits.KernelFork.ofι ι ⋯)","decl":"@[simp]\ntheorem kernelForkOfFork_ofι {P : C} (ι : P ⟶ X) (w : ι ≫ f = ι ≫ g) :\n    kernelForkOfFork (Fork.ofι ι w) = KernelFork.ofι ι (by simp [w]) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Preadditive.isLimitForkOfKernelFork_lift","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nf g : Quiver.Hom X Y\nc : CategoryTheory.Limits.KernelFork (HSub.hSub f g)\ni : CategoryTheory.Limits.IsLimit c\ns : CategoryTheory.Limits.Fork f g\n⊢ Eq ((CategoryTheory.Preadditive.isLimitForkOfKernelFork i).lift s) (i.lift (CategoryTheory.Preadditive.kernelForkOfFork s))","decl":"@[simp]\ntheorem isLimitForkOfKernelFork_lift {c : KernelFork (f - g)} (i : IsLimit c) (s : Fork f g) :\n    (isLimitForkOfKernelFork i).lift s = i.lift (kernelForkOfFork s) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Preadditive.hasEqualizer_of_hasKernel","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\nf g : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel (HSub.hSub f g)\n⊢ CategoryTheory.Limits.HasEqualizer f g","decl":"/-- A preadditive category has an equalizer for `f` and `g` if it has a kernel for `f - g`. -/\ntheorem hasEqualizer_of_hasKernel [HasKernel (f - g)] : HasEqualizer f g :=\n  HasLimit.mk\n    { cone := forkOfKernelFork _\n      isLimit := isLimitForkOfKernelFork (equalizerIsEqualizer (f - g) 0) }\n\n"}
{"name":"CategoryTheory.Preadditive.hasKernel_of_hasEqualizer","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\nf g : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasEqualizer f g\n⊢ CategoryTheory.Limits.HasKernel (HSub.hSub f g)","decl":"/-- A preadditive category has a kernel for `f - g` if it has an equalizer for `f` and `g`. -/\ntheorem hasKernel_of_hasEqualizer [HasEqualizer f g] : HasKernel (f - g) :=\n  HasLimit.mk\n    { cone := kernelForkOfFork (equalizer.fork f g)\n      isLimit := isLimitKernelForkOfFork (limit.isLimit (parallelPair f g)) }\n\n"}
{"name":"CategoryTheory.Preadditive.coforkOfCokernelCofork_pt","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nf g : Quiver.Hom X Y\nc : CategoryTheory.Limits.CokernelCofork (HSub.hSub f g)\n⊢ Eq (CategoryTheory.Preadditive.coforkOfCokernelCofork c).pt c.pt","decl":"/-- Map a cokernel cocone on the difference of two morphisms to the coequalizer cofork. -/\n@[simps! pt]\ndef coforkOfCokernelCofork (c : CokernelCofork (f - g)) : Cofork f g :=\n  Cofork.ofπ c.π <| by rw [← sub_eq_zero, ← sub_comp, c.condition]\n\n"}
{"name":"CategoryTheory.Preadditive.coforkOfCokernelCofork_π","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nf g : Quiver.Hom X Y\nc : CategoryTheory.Limits.CokernelCofork (HSub.hSub f g)\n⊢ Eq (CategoryTheory.Preadditive.coforkOfCokernelCofork c).π (CategoryTheory.Limits.Cofork.π c)","decl":"@[simp]\ntheorem coforkOfCokernelCofork_π (c : CokernelCofork (f - g)) :\n    (coforkOfCokernelCofork c).π = c.π :=\n  rfl\n\n"}
{"name":"CategoryTheory.Preadditive.cokernelCoforkOfCofork_π","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nf g : Quiver.Hom X Y\nc : CategoryTheory.Limits.Cofork f g\n⊢ Eq (CategoryTheory.Limits.Cofork.π (CategoryTheory.Preadditive.cokernelCoforkOfCofork c)) c.π","decl":"@[simp]\ntheorem cokernelCoforkOfCofork_π (c : Cofork f g) : (cokernelCoforkOfCofork c).π = c.π :=\n  rfl\n\n"}
{"name":"CategoryTheory.Preadditive.cokernelCoforkOfCofork_ofπ","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nf g : Quiver.Hom X Y\nP : C\nπ : Quiver.Hom Y P\nw : Eq (CategoryTheory.CategoryStruct.comp f π) (CategoryTheory.CategoryStruct.comp g π)\n⊢ Eq (CategoryTheory.Preadditive.cokernelCoforkOfCofork (CategoryTheory.Limits.Cofork.ofπ π w)) (CategoryTheory.Limits.CokernelCofork.ofπ π ⋯)","decl":"@[simp]\ntheorem cokernelCoforkOfCofork_ofπ {P : C} (π : Y ⟶ P) (w : f ≫ π = g ≫ π) :\n    cokernelCoforkOfCofork (Cofork.ofπ π w) = CokernelCofork.ofπ π (by simp [w]) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Preadditive.isColimitCoforkOfCokernelCofork_desc","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nf g : Quiver.Hom X Y\nc : CategoryTheory.Limits.CokernelCofork (HSub.hSub f g)\ni : CategoryTheory.Limits.IsColimit c\ns : CategoryTheory.Limits.Cofork f g\n⊢ Eq ((CategoryTheory.Preadditive.isColimitCoforkOfCokernelCofork i).desc s) (i.desc (CategoryTheory.Preadditive.cokernelCoforkOfCofork s))","decl":"@[simp]\ntheorem isColimitCoforkOfCokernelCofork_desc {c : CokernelCofork (f - g)} (i : IsColimit c)\n    (s : Cofork f g) :\n    (isColimitCoforkOfCokernelCofork i).desc s = i.desc (cokernelCoforkOfCofork s) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Preadditive.hasCoequalizer_of_hasCokernel","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\nf g : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasCokernel (HSub.hSub f g)\n⊢ CategoryTheory.Limits.HasCoequalizer f g","decl":"/-- A preadditive category has a coequalizer for `f` and `g` if it has a cokernel for `f - g`. -/\ntheorem hasCoequalizer_of_hasCokernel [HasCokernel (f - g)] : HasCoequalizer f g :=\n  HasColimit.mk\n    { cocone := coforkOfCokernelCofork _\n      isColimit := isColimitCoforkOfCokernelCofork (coequalizerIsCoequalizer (f - g) 0) }\n\n"}
{"name":"CategoryTheory.Preadditive.hasCokernel_of_hasCoequalizer","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\nf g : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasCoequalizer f g\n⊢ CategoryTheory.Limits.HasCokernel (HSub.hSub f g)","decl":"/-- A preadditive category has a cokernel for `f - g` if it has a coequalizer for `f` and `g`. -/\ntheorem hasCokernel_of_hasCoequalizer [HasCoequalizer f g] : HasCokernel (f - g) :=\n  HasColimit.mk\n    { cocone := cokernelCoforkOfCofork (coequalizer.cofork f g)\n      isColimit := isColimitCokernelCoforkOfCofork (colimit.isColimit (parallelPair f g)) }\n\n"}
{"name":"CategoryTheory.Preadditive.hasEqualizers_of_hasKernels","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasKernels C\n⊢ CategoryTheory.Limits.HasEqualizers C","decl":"/-- If a preadditive category has all kernels, then it also has all equalizers. -/\ntheorem hasEqualizers_of_hasKernels [HasKernels C] : HasEqualizers C :=\n  @hasEqualizers_of_hasLimit_parallelPair _ _ fun {_} {_} f g => hasEqualizer_of_hasKernel f g\n\n"}
{"name":"CategoryTheory.Preadditive.hasCoequalizers_of_hasCokernels","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasCokernels C\n⊢ CategoryTheory.Limits.HasCoequalizers C","decl":"/-- If a preadditive category has all cokernels, then it also has all coequalizers. -/\ntheorem hasCoequalizers_of_hasCokernels [HasCokernels C] : HasCoequalizers C :=\n  @hasCoequalizers_of_hasColimit_parallelPair _ _ fun {_} {_} f g =>\n    hasCoequalizer_of_hasCokernel f g\n\n"}
{"name":"CategoryTheory.Preadditive.smul_iso_hom","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\na : Units Int\ne : CategoryTheory.Iso X Y\n⊢ Eq (HSMul.hSMul a e).hom (HSMul.hSMul a e.hom)","decl":"@[simp]\nlemma smul_iso_hom (a : Units ℤ) (e : X ≅ Y) : (a • e).hom = a • e.hom := rfl\n\n"}
{"name":"CategoryTheory.Preadditive.smul_iso_inv","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\na : Units Int\ne : CategoryTheory.Iso X Y\n⊢ Eq (HSMul.hSMul a e).inv (HSMul.hSMul (Inv.inv a) e.inv)","decl":"@[simp]\nlemma smul_iso_inv (a : Units ℤ) (e : X ≅ Y) : (a • e).inv = a⁻¹ • e.inv := rfl\n\n"}
{"name":"CategoryTheory.Preadditive.neg_iso_hom","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\ne : CategoryTheory.Iso X Y\n⊢ Eq (Neg.neg e).hom (Neg.neg e.hom)","decl":"@[simp]\nlemma neg_iso_hom (e : X ≅ Y) : (-e).hom = -e.hom := rfl\n\n"}
{"name":"CategoryTheory.Preadditive.neg_iso_inv","module":"Mathlib.CategoryTheory.Preadditive.Basic","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\ne : CategoryTheory.Iso X Y\n⊢ Eq (Neg.neg e).inv (Neg.neg e.inv)","decl":"@[simp]\nlemma neg_iso_inv (e : X ≅ Y) : (-e).inv = -e.inv := rfl\n\n"}
