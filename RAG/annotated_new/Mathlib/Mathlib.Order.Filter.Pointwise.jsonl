{"name":"Filter.mem_zero","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Zero α\ns : Set α\n⊢ Iff (Membership.mem 0 s) (Membership.mem s 0)","decl":"@[to_additive (attr := simp)]\ntheorem mem_one : s ∈ (1 : Filter α) ↔ (1 : α) ∈ s :=\n  mem_pure\n\n"}
{"name":"Filter.mem_one","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : One α\ns : Set α\n⊢ Iff (Membership.mem 1 s) (Membership.mem s 1)","decl":"@[to_additive (attr := simp)]\ntheorem mem_one : s ∈ (1 : Filter α) ↔ (1 : α) ∈ s :=\n  mem_pure\n\n"}
{"name":"Filter.one_mem_one","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : One α\n⊢ Membership.mem 1 1","decl":"@[to_additive]\ntheorem one_mem_one : (1 : Set α) ∈ (1 : Filter α) :=\n  mem_pure.2 Set.one_mem_one\n\n"}
{"name":"Filter.zero_mem_zero","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Zero α\n⊢ Membership.mem 0 0","decl":"@[to_additive]\ntheorem one_mem_one : (1 : Set α) ∈ (1 : Filter α) :=\n  mem_pure.2 Set.one_mem_one\n\n"}
{"name":"Filter.pure_zero","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Zero α\n⊢ Eq (Pure.pure 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem pure_one : pure 1 = (1 : Filter α) :=\n  rfl\n\n"}
{"name":"Filter.pure_one","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : One α\n⊢ Eq (Pure.pure 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem pure_one : pure 1 = (1 : Filter α) :=\n  rfl\n\n"}
{"name":"Filter.one_prod","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : One α\nl : Filter β\n⊢ Eq (SProd.sprod 1 l) (Filter.map (fun x => { fst := 1, snd := x }) l)","decl":"@[to_additive (attr := simp) zero_prod]\ntheorem one_prod {l : Filter β} : (1 : Filter α) ×ˢ l = map (1, ·) l := pure_prod\n\n"}
{"name":"Filter.zero_prod","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : Zero α\nl : Filter β\n⊢ Eq (SProd.sprod 0 l) (Filter.map (fun x => { fst := 0, snd := x }) l)","decl":"@[to_additive (attr := simp) zero_prod]\ntheorem one_prod {l : Filter β} : (1 : Filter α) ×ˢ l = map (1, ·) l := pure_prod\n\n"}
{"name":"Filter.prod_zero","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : Zero α\nl : Filter β\n⊢ Eq (SProd.sprod l 0) (Filter.map (fun x => { fst := x, snd := 0 }) l)","decl":"@[to_additive (attr := simp) prod_zero]\ntheorem prod_one {l : Filter β} : l ×ˢ (1 : Filter α) = map (·, 1) l := prod_pure\n\n"}
{"name":"Filter.prod_one","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : One α\nl : Filter β\n⊢ Eq (SProd.sprod l 1) (Filter.map (fun x => { fst := x, snd := 1 }) l)","decl":"@[to_additive (attr := simp) prod_zero]\ntheorem prod_one {l : Filter β} : l ×ˢ (1 : Filter α) = map (·, 1) l := prod_pure\n\n"}
{"name":"Filter.principal_zero","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Zero α\n⊢ Eq (Filter.principal 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem principal_one : 𝓟 1 = (1 : Filter α) :=\n  principal_singleton _\n\n"}
{"name":"Filter.principal_one","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : One α\n⊢ Eq (Filter.principal 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem principal_one : 𝓟 1 = (1 : Filter α) :=\n  principal_singleton _\n\n"}
{"name":"Filter.one_neBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : One α\n⊢ Filter.NeBot 1","decl":"@[to_additive]\ntheorem one_neBot : (1 : Filter α).NeBot :=\n  Filter.pure_neBot\n\n"}
{"name":"Filter.zero_neBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Zero α\n⊢ Filter.NeBot 0","decl":"@[to_additive]\ntheorem one_neBot : (1 : Filter α).NeBot :=\n  Filter.pure_neBot\n\n"}
{"name":"Filter.map_zero'","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : Zero α\nf : α → β\n⊢ Eq (Filter.map f 0) (Pure.pure (f 0))","decl":"@[to_additive (attr := simp)]\nprotected theorem map_one' (f : α → β) : (1 : Filter α).map f = pure (f 1) :=\n  rfl\n\n"}
{"name":"Filter.map_one'","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : One α\nf : α → β\n⊢ Eq (Filter.map f 1) (Pure.pure (f 1))","decl":"@[to_additive (attr := simp)]\nprotected theorem map_one' (f : α → β) : (1 : Filter α).map f = pure (f 1) :=\n  rfl\n\n"}
{"name":"Filter.nonpos_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Zero α\nf : Filter α\n⊢ Iff (LE.le f 0) (Membership.mem f 0)","decl":"@[to_additive (attr := simp)]\ntheorem le_one_iff : f ≤ 1 ↔ (1 : Set α) ∈ f :=\n  le_pure_iff\n\n"}
{"name":"Filter.le_one_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : One α\nf : Filter α\n⊢ Iff (LE.le f 1) (Membership.mem f 1)","decl":"@[to_additive (attr := simp)]\ntheorem le_one_iff : f ≤ 1 ↔ (1 : Set α) ∈ f :=\n  le_pure_iff\n\n"}
{"name":"Filter.NeBot.nonpos_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Zero α\nf : Filter α\nh : f.NeBot\n⊢ Iff (LE.le f 0) (Eq f 0)","decl":"@[to_additive]\nprotected theorem NeBot.le_one_iff (h : f.NeBot) : f ≤ 1 ↔ f = 1 :=\n  h.le_pure_iff\n\n"}
{"name":"Filter.NeBot.le_one_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : One α\nf : Filter α\nh : f.NeBot\n⊢ Iff (LE.le f 1) (Eq f 1)","decl":"@[to_additive]\nprotected theorem NeBot.le_one_iff (h : f.NeBot) : f ≤ 1 ↔ f = 1 :=\n  h.le_pure_iff\n\n"}
{"name":"Filter.eventually_zero","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Zero α\np : α → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) 0) (p 0)","decl":"@[to_additive (attr := simp)]\ntheorem eventually_one {p : α → Prop} : (∀ᶠ x in 1, p x) ↔ p 1 :=\n  eventually_pure\n\n"}
{"name":"Filter.eventually_one","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : One α\np : α → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) 1) (p 1)","decl":"@[to_additive (attr := simp)]\ntheorem eventually_one {p : α → Prop} : (∀ᶠ x in 1, p x) ↔ p 1 :=\n  eventually_pure\n\n"}
{"name":"Filter.tendsto_one","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : One α\na : Filter β\nf : β → α\n⊢ Iff (Filter.Tendsto f a 1) (Filter.Eventually (fun x => Eq (f x) 1) a)","decl":"@[to_additive (attr := simp)]\ntheorem tendsto_one {a : Filter β} {f : β → α} : Tendsto f a 1 ↔ ∀ᶠ x in a, f x = 1 :=\n  tendsto_pure\n\n"}
{"name":"Filter.tendsto_zero","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : Zero α\na : Filter β\nf : β → α\n⊢ Iff (Filter.Tendsto f a 0) (Filter.Eventually (fun x => Eq (f x) 0) a)","decl":"@[to_additive (attr := simp)]\ntheorem tendsto_one {a : Filter β} {f : β → α} : Tendsto f a 1 ↔ ∀ᶠ x in a, f x = 1 :=\n  tendsto_pure\n\n"}
{"name":"Filter.zero_prod_zero","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Zero α\ninst✝ : Zero β\n⊢ Eq (SProd.sprod 0 0) 0","decl":"@[to_additive zero_prod_zero]\ntheorem one_prod_one [One β] : (1 : Filter α) ×ˢ (1 : Filter β) = 1 :=\n  prod_pure_pure\n\n"}
{"name":"Filter.one_prod_one","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : One α\ninst✝ : One β\n⊢ Eq (SProd.sprod 1 1) 1","decl":"@[to_additive zero_prod_zero]\ntheorem one_prod_one [One β] : (1 : Filter α) ×ˢ (1 : Filter β) = 1 :=\n  prod_pure_pure\n\n"}
{"name":"Filter.zero_sum_zero","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Zero α\ninst✝ : Zero β\n⊢ Eq (SProd.sprod 0 0) 0","decl":"@[deprecated (since := \"2024-08-16\")] alias zero_sum_zero := zero_prod_zero\n\n"}
{"name":"Filter.coe_pureOneHom","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : One α\n⊢ Eq (⇑Filter.pureOneHom) Pure.pure","decl":"@[to_additive (attr := simp)]\ntheorem coe_pureOneHom : (pureOneHom : α → Filter α) = pure :=\n  rfl\n\n"}
{"name":"Filter.coe_pureZeroHom","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Zero α\n⊢ Eq (⇑Filter.pureZeroHom) Pure.pure","decl":"@[to_additive (attr := simp)]\ntheorem coe_pureOneHom : (pureOneHom : α → Filter α) = pure :=\n  rfl\n\n"}
{"name":"Filter.pureOneHom_apply","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : One α\na : α\n⊢ Eq (Filter.pureOneHom a) (Pure.pure a)","decl":"@[to_additive (attr := simp)]\ntheorem pureOneHom_apply (a : α) : pureOneHom a = pure a :=\n  rfl\n\n"}
{"name":"Filter.pureZeroHom_apply","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Zero α\na : α\n⊢ Eq (Filter.pureZeroHom a) (Pure.pure a)","decl":"@[to_additive (attr := simp)]\ntheorem pureOneHom_apply (a : α) : pureOneHom a = pure a :=\n  rfl\n\n"}
{"name":"Filter.map_one","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : One α\ninst✝² : One β\ninst✝¹ : FunLike F α β\ninst✝ : OneHomClass F α β\nφ : F\n⊢ Eq (Filter.map (⇑φ) 1) 1","decl":"@[to_additive]\nprotected theorem map_one [FunLike F α β] [OneHomClass F α β] (φ : F) : map φ 1 = 1 := by\n  simp\n\n"}
{"name":"Filter.map_zero","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Zero α\ninst✝² : Zero β\ninst✝¹ : FunLike F α β\ninst✝ : ZeroHomClass F α β\nφ : F\n⊢ Eq (Filter.map (⇑φ) 0) 0","decl":"@[to_additive]\nprotected theorem map_one [FunLike F α β] [OneHomClass F α β] (φ : F) : map φ 1 = 1 := by\n  simp\n\n"}
{"name":"Filter.map_neg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Neg α\nf : Filter α\n⊢ Eq (Filter.map Neg.neg f) (Neg.neg f)","decl":"@[to_additive (attr := simp)]\nprotected theorem map_inv : f.map Inv.inv = f⁻¹ :=\n  rfl\n\n"}
{"name":"Filter.map_inv","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Inv α\nf : Filter α\n⊢ Eq (Filter.map Inv.inv f) (Inv.inv f)","decl":"@[to_additive (attr := simp)]\nprotected theorem map_inv : f.map Inv.inv = f⁻¹ :=\n  rfl\n\n"}
{"name":"Filter.mem_neg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Neg α\nf : Filter α\ns : Set α\n⊢ Iff (Membership.mem (Neg.neg f) s) (Membership.mem f (Set.preimage Neg.neg s))","decl":"@[to_additive]\ntheorem mem_inv : s ∈ f⁻¹ ↔ Inv.inv ⁻¹' s ∈ f :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_inv","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Inv α\nf : Filter α\ns : Set α\n⊢ Iff (Membership.mem (Inv.inv f) s) (Membership.mem f (Set.preimage Inv.inv s))","decl":"@[to_additive]\ntheorem mem_inv : s ∈ f⁻¹ ↔ Inv.inv ⁻¹' s ∈ f :=\n  Iff.rfl\n\n"}
{"name":"Filter.neg_le_neg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Neg α\nf g : Filter α\nhf : LE.le f g\n⊢ LE.le (Neg.neg f) (Neg.neg g)","decl":"@[to_additive]\nprotected theorem inv_le_inv (hf : f ≤ g) : f⁻¹ ≤ g⁻¹ :=\n  map_mono hf\n\n"}
{"name":"Filter.inv_le_inv","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Inv α\nf g : Filter α\nhf : LE.le f g\n⊢ LE.le (Inv.inv f) (Inv.inv g)","decl":"@[to_additive]\nprotected theorem inv_le_inv (hf : f ≤ g) : f⁻¹ ≤ g⁻¹ :=\n  map_mono hf\n\n"}
{"name":"Filter.inv_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Inv α\na : α\n⊢ Eq (Inv.inv (Pure.pure a)) (Pure.pure (Inv.inv a))","decl":"@[to_additive (attr := simp)]\ntheorem inv_pure : (pure a : Filter α)⁻¹ = pure a⁻¹ :=\n  rfl\n\n"}
{"name":"Filter.neg_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Neg α\na : α\n⊢ Eq (Neg.neg (Pure.pure a)) (Pure.pure (Neg.neg a))","decl":"@[to_additive (attr := simp)]\ntheorem inv_pure : (pure a : Filter α)⁻¹ = pure a⁻¹ :=\n  rfl\n\n"}
{"name":"Filter.inv_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Inv α\nf : Filter α\n⊢ Iff (Eq (Inv.inv f) Bot.bot) (Eq f Bot.bot)","decl":"@[to_additive (attr := simp)]\ntheorem inv_eq_bot_iff : f⁻¹ = ⊥ ↔ f = ⊥ :=\n  map_eq_bot_iff\n\n"}
{"name":"Filter.neg_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Neg α\nf : Filter α\n⊢ Iff (Eq (Neg.neg f) Bot.bot) (Eq f Bot.bot)","decl":"@[to_additive (attr := simp)]\ntheorem inv_eq_bot_iff : f⁻¹ = ⊥ ↔ f = ⊥ :=\n  map_eq_bot_iff\n\n"}
{"name":"Filter.neBot_neg_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Neg α\nf : Filter α\n⊢ Iff (Neg.neg f).NeBot f.NeBot","decl":"@[to_additive (attr := simp)]\ntheorem neBot_inv_iff : f⁻¹.NeBot ↔ NeBot f :=\n  map_neBot_iff _\n\n"}
{"name":"Filter.neBot_inv_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Inv α\nf : Filter α\n⊢ Iff (Inv.inv f).NeBot f.NeBot","decl":"@[to_additive (attr := simp)]\ntheorem neBot_inv_iff : f⁻¹.NeBot ↔ NeBot f :=\n  map_neBot_iff _\n\n"}
{"name":"Filter.NeBot.inv","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Inv α\nf : Filter α\na✝ : f.NeBot\n⊢ (Inv.inv f).NeBot","decl":"@[to_additive]\nprotected theorem NeBot.inv : f.NeBot → f⁻¹.NeBot := fun h => h.map _\n\n"}
{"name":"Filter.NeBot.neg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Neg α\nf : Filter α\na✝ : f.NeBot\n⊢ (Neg.neg f).NeBot","decl":"@[to_additive]\nprotected theorem NeBot.inv : f.NeBot → f⁻¹.NeBot := fun h => h.map _\n\n"}
{"name":"Filter.inv.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝¹ : Inv α\nf : Filter α\ninst✝ : f.NeBot\n⊢ (Inv.inv f).NeBot","decl":"@[to_additive neg.instNeBot]\nlemma inv.instNeBot [NeBot f] : NeBot f⁻¹ := .inv ‹_›\n\n"}
{"name":"Filter.neg.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝¹ : Neg α\nf : Filter α\ninst✝ : f.NeBot\n⊢ (Neg.neg f).NeBot","decl":"@[to_additive neg.instNeBot]\nlemma inv.instNeBot [NeBot f] : NeBot f⁻¹ := .inv ‹_›\n\n"}
{"name":"Filter.comap_neg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : InvolutiveNeg α\nf : Filter α\n⊢ Eq (Filter.comap Neg.neg f) (Neg.neg f)","decl":"@[to_additive (attr := simp)]\nprotected lemma comap_inv : comap Inv.inv f = f⁻¹ :=\n  .symm <| map_eq_comap_of_inverse (inv_comp_inv _) (inv_comp_inv _)\n\n"}
{"name":"Filter.comap_inv","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : InvolutiveInv α\nf : Filter α\n⊢ Eq (Filter.comap Inv.inv f) (Inv.inv f)","decl":"@[to_additive (attr := simp)]\nprotected lemma comap_inv : comap Inv.inv f = f⁻¹ :=\n  .symm <| map_eq_comap_of_inverse (inv_comp_inv _) (inv_comp_inv _)\n\n"}
{"name":"Filter.neg_mem_neg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : InvolutiveNeg α\nf : Filter α\ns : Set α\nhs : Membership.mem f s\n⊢ Membership.mem (Neg.neg f) (Neg.neg s)","decl":"@[to_additive]\ntheorem inv_mem_inv (hs : s ∈ f) : s⁻¹ ∈ f⁻¹ := by rwa [mem_inv, inv_preimage, inv_inv]\n\n"}
{"name":"Filter.inv_mem_inv","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : InvolutiveInv α\nf : Filter α\ns : Set α\nhs : Membership.mem f s\n⊢ Membership.mem (Inv.inv f) (Inv.inv s)","decl":"@[to_additive]\ntheorem inv_mem_inv (hs : s ∈ f) : s⁻¹ ∈ f⁻¹ := by rwa [mem_inv, inv_preimage, inv_inv]\n\n"}
{"name":"Filter.inv_le_inv_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : InvolutiveInv α\nf g : Filter α\n⊢ Iff (LE.le (Inv.inv f) (Inv.inv g)) (LE.le f g)","decl":"@[to_additive (attr := simp)]\nprotected theorem inv_le_inv_iff : f⁻¹ ≤ g⁻¹ ↔ f ≤ g :=\n  ⟨fun h => inv_inv f ▸ inv_inv g ▸ Filter.inv_le_inv h, Filter.inv_le_inv⟩\n\n"}
{"name":"Filter.neg_le_neg_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : InvolutiveNeg α\nf g : Filter α\n⊢ Iff (LE.le (Neg.neg f) (Neg.neg g)) (LE.le f g)","decl":"@[to_additive (attr := simp)]\nprotected theorem inv_le_inv_iff : f⁻¹ ≤ g⁻¹ ↔ f ≤ g :=\n  ⟨fun h => inv_inv f ▸ inv_inv g ▸ Filter.inv_le_inv h, Filter.inv_le_inv⟩\n\n"}
{"name":"Filter.inv_le_iff_le_inv","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : InvolutiveInv α\nf g : Filter α\n⊢ Iff (LE.le (Inv.inv f) g) (LE.le f (Inv.inv g))","decl":"@[to_additive]\ntheorem inv_le_iff_le_inv : f⁻¹ ≤ g ↔ f ≤ g⁻¹ := by rw [← Filter.inv_le_inv_iff, inv_inv]\n\n"}
{"name":"Filter.neg_le_iff_le_neg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : InvolutiveNeg α\nf g : Filter α\n⊢ Iff (LE.le (Neg.neg f) g) (LE.le f (Neg.neg g))","decl":"@[to_additive]\ntheorem inv_le_iff_le_inv : f⁻¹ ≤ g ↔ f ≤ g⁻¹ := by rw [← Filter.inv_le_inv_iff, inv_inv]\n\n"}
{"name":"Filter.neg_le_self","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : InvolutiveNeg α\nf : Filter α\n⊢ Iff (LE.le (Neg.neg f) f) (Eq (Neg.neg f) f)","decl":"@[to_additive (attr := simp)]\ntheorem inv_le_self : f⁻¹ ≤ f ↔ f⁻¹ = f :=\n  ⟨fun h => h.antisymm <| inv_le_iff_le_inv.1 h, Eq.le⟩\n\n"}
{"name":"Filter.inv_le_self","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : InvolutiveInv α\nf : Filter α\n⊢ Iff (LE.le (Inv.inv f) f) (Eq (Inv.inv f) f)","decl":"@[to_additive (attr := simp)]\ntheorem inv_le_self : f⁻¹ ≤ f ↔ f⁻¹ = f :=\n  ⟨fun h => h.antisymm <| inv_le_iff_le_inv.1 h, Eq.le⟩\n\n"}
{"name":"Filter.inv_atTop","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"G : Type u_7\ninst✝ : OrderedCommGroup G\n⊢ Eq (Inv.inv Filter.atTop) Filter.atBot","decl":"@[to_additive (attr := simp)]\nlemma inv_atTop {G : Type*} [OrderedCommGroup G] : (atTop : Filter G)⁻¹ = atBot :=\n  (OrderIso.inv G).map_atTop\n\n"}
{"name":"Filter.neg_atTop","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"G : Type u_7\ninst✝ : OrderedAddCommGroup G\n⊢ Eq (Neg.neg Filter.atTop) Filter.atBot","decl":"@[to_additive (attr := simp)]\nlemma inv_atTop {G : Type*} [OrderedCommGroup G] : (atTop : Filter G)⁻¹ = atBot :=\n  (OrderIso.inv G).map_atTop\n\n"}
{"name":"Filter.map₂_add","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Add α\nf g : Filter α\n⊢ Eq (Filter.map₂ (fun x1 x2 => HAdd.hAdd x1 x2) f g) (HAdd.hAdd f g)","decl":"@[to_additive (attr := simp)]\ntheorem map₂_mul : map₂ (· * ·) f g = f * g :=\n  rfl\n\n"}
{"name":"Filter.map₂_mul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Mul α\nf g : Filter α\n⊢ Eq (Filter.map₂ (fun x1 x2 => HMul.hMul x1 x2) f g) (HMul.hMul f g)","decl":"@[to_additive (attr := simp)]\ntheorem map₂_mul : map₂ (· * ·) f g = f * g :=\n  rfl\n\n"}
{"name":"Filter.mem_mul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Mul α\nf g : Filter α\ns : Set α\n⊢ Iff (Membership.mem (HMul.hMul f g) s) (Exists fun t₁ => And (Membership.mem f t₁) (Exists fun t₂ => And (Membership.mem g t₂) (HasSubset.Subset (HMul.hMul t₁ t₂) s)))","decl":"@[to_additive]\ntheorem mem_mul : s ∈ f * g ↔ ∃ t₁ ∈ f, ∃ t₂ ∈ g, t₁ * t₂ ⊆ s :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_add","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Add α\nf g : Filter α\ns : Set α\n⊢ Iff (Membership.mem (HAdd.hAdd f g) s) (Exists fun t₁ => And (Membership.mem f t₁) (Exists fun t₂ => And (Membership.mem g t₂) (HasSubset.Subset (HAdd.hAdd t₁ t₂) s)))","decl":"@[to_additive]\ntheorem mem_mul : s ∈ f * g ↔ ∃ t₁ ∈ f, ∃ t₂ ∈ g, t₁ * t₂ ⊆ s :=\n  Iff.rfl\n\n"}
{"name":"Filter.add_mem_add","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Add α\nf g : Filter α\ns t : Set α\na✝¹ : Membership.mem f s\na✝ : Membership.mem g t\n⊢ Membership.mem (HAdd.hAdd f g) (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem mul_mem_mul : s ∈ f → t ∈ g → s * t ∈ f * g :=\n  image2_mem_map₂\n\n"}
{"name":"Filter.mul_mem_mul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Mul α\nf g : Filter α\ns t : Set α\na✝¹ : Membership.mem f s\na✝ : Membership.mem g t\n⊢ Membership.mem (HMul.hMul f g) (HMul.hMul s t)","decl":"@[to_additive]\ntheorem mul_mem_mul : s ∈ f → t ∈ g → s * t ∈ f * g :=\n  image2_mem_map₂\n\n"}
{"name":"Filter.bot_add","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Add α\ng : Filter α\n⊢ Eq (HAdd.hAdd Bot.bot g) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem bot_mul : ⊥ * g = ⊥ :=\n  map₂_bot_left\n\n"}
{"name":"Filter.bot_mul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Mul α\ng : Filter α\n⊢ Eq (HMul.hMul Bot.bot g) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem bot_mul : ⊥ * g = ⊥ :=\n  map₂_bot_left\n\n"}
{"name":"Filter.add_bot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Add α\nf : Filter α\n⊢ Eq (HAdd.hAdd f Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem mul_bot : f * ⊥ = ⊥ :=\n  map₂_bot_right\n\n"}
{"name":"Filter.mul_bot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Mul α\nf : Filter α\n⊢ Eq (HMul.hMul f Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem mul_bot : f * ⊥ = ⊥ :=\n  map₂_bot_right\n\n"}
{"name":"Filter.mul_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Mul α\nf g : Filter α\n⊢ Iff (Eq (HMul.hMul f g) Bot.bot) (Or (Eq f Bot.bot) (Eq g Bot.bot))","decl":"@[to_additive (attr := simp)]\ntheorem mul_eq_bot_iff : f * g = ⊥ ↔ f = ⊥ ∨ g = ⊥ :=\n  map₂_eq_bot_iff\n\n"}
{"name":"Filter.add_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Add α\nf g : Filter α\n⊢ Iff (Eq (HAdd.hAdd f g) Bot.bot) (Or (Eq f Bot.bot) (Eq g Bot.bot))","decl":"@[to_additive (attr := simp)]\ntheorem mul_eq_bot_iff : f * g = ⊥ ↔ f = ⊥ ∨ g = ⊥ :=\n  map₂_eq_bot_iff\n\n"}
{"name":"Filter.add_neBot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Add α\nf g : Filter α\n⊢ Iff (HAdd.hAdd f g).NeBot (And f.NeBot g.NeBot)","decl":"@[to_additive (attr := simp)] -- TODO: make this a scoped instance in the `Pointwise` namespace\nlemma mul_neBot_iff : (f * g).NeBot ↔ f.NeBot ∧ g.NeBot :=\n  map₂_neBot_iff\n\n"}
{"name":"Filter.mul_neBot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Mul α\nf g : Filter α\n⊢ Iff (HMul.hMul f g).NeBot (And f.NeBot g.NeBot)","decl":"@[to_additive (attr := simp)] -- TODO: make this a scoped instance in the `Pointwise` namespace\nlemma mul_neBot_iff : (f * g).NeBot ↔ f.NeBot ∧ g.NeBot :=\n  map₂_neBot_iff\n\n"}
{"name":"Filter.NeBot.mul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Mul α\nf g : Filter α\na✝¹ : f.NeBot\na✝ : g.NeBot\n⊢ (HMul.hMul f g).NeBot","decl":"@[to_additive]\nprotected theorem NeBot.mul : NeBot f → NeBot g → NeBot (f * g) :=\n  NeBot.map₂\n\n"}
{"name":"Filter.NeBot.add","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Add α\nf g : Filter α\na✝¹ : f.NeBot\na✝ : g.NeBot\n⊢ (HAdd.hAdd f g).NeBot","decl":"@[to_additive]\nprotected theorem NeBot.mul : NeBot f → NeBot g → NeBot (f * g) :=\n  NeBot.map₂\n\n"}
{"name":"Filter.NeBot.of_mul_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Mul α\nf g : Filter α\na✝ : (HMul.hMul f g).NeBot\n⊢ f.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_mul_left : (f * g).NeBot → f.NeBot :=\n  NeBot.of_map₂_left\n\n"}
{"name":"Filter.NeBot.of_add_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Add α\nf g : Filter α\na✝ : (HAdd.hAdd f g).NeBot\n⊢ f.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_mul_left : (f * g).NeBot → f.NeBot :=\n  NeBot.of_map₂_left\n\n"}
{"name":"Filter.NeBot.of_add_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Add α\nf g : Filter α\na✝ : (HAdd.hAdd f g).NeBot\n⊢ g.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_mul_right : (f * g).NeBot → g.NeBot :=\n  NeBot.of_map₂_right\n\n"}
{"name":"Filter.NeBot.of_mul_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Mul α\nf g : Filter α\na✝ : (HMul.hMul f g).NeBot\n⊢ g.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_mul_right : (f * g).NeBot → g.NeBot :=\n  NeBot.of_map₂_right\n\n"}
{"name":"Filter.add.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝² : Add α\nf g : Filter α\ninst✝¹ : f.NeBot\ninst✝ : g.NeBot\n⊢ (HAdd.hAdd f g).NeBot","decl":"@[to_additive add.instNeBot]\nprotected lemma mul.instNeBot [NeBot f] [NeBot g] : NeBot (f * g) := .mul ‹_› ‹_›\n\n"}
{"name":"Filter.mul.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝² : Mul α\nf g : Filter α\ninst✝¹ : f.NeBot\ninst✝ : g.NeBot\n⊢ (HMul.hMul f g).NeBot","decl":"@[to_additive add.instNeBot]\nprotected lemma mul.instNeBot [NeBot f] [NeBot g] : NeBot (f * g) := .mul ‹_› ‹_›\n\n"}
{"name":"Filter.pure_mul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Mul α\ng : Filter α\na : α\n⊢ Eq (HMul.hMul (Pure.pure a) g) (Filter.map (fun x => HMul.hMul a x) g)","decl":"@[to_additive (attr := simp)]\ntheorem pure_mul : pure a * g = g.map (a * ·) :=\n  map₂_pure_left\n\n"}
{"name":"Filter.pure_add","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Add α\ng : Filter α\na : α\n⊢ Eq (HAdd.hAdd (Pure.pure a) g) (Filter.map (fun x => HAdd.hAdd a x) g)","decl":"@[to_additive (attr := simp)]\ntheorem pure_mul : pure a * g = g.map (a * ·) :=\n  map₂_pure_left\n\n"}
{"name":"Filter.mul_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Mul α\nf : Filter α\nb : α\n⊢ Eq (HMul.hMul f (Pure.pure b)) (Filter.map (fun x => HMul.hMul x b) f)","decl":"@[to_additive (attr := simp)]\ntheorem mul_pure : f * pure b = f.map (· * b) :=\n  map₂_pure_right\n\n"}
{"name":"Filter.add_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Add α\nf : Filter α\nb : α\n⊢ Eq (HAdd.hAdd f (Pure.pure b)) (Filter.map (fun x => HAdd.hAdd x b) f)","decl":"@[to_additive (attr := simp)]\ntheorem mul_pure : f * pure b = f.map (· * b) :=\n  map₂_pure_right\n\n"}
{"name":"Filter.pure_mul_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Mul α\na b : α\n⊢ Eq (HMul.hMul (Pure.pure a) (Pure.pure b)) (Pure.pure (HMul.hMul a b))","decl":"@[to_additive]\ntheorem pure_mul_pure : (pure a : Filter α) * pure b = pure (a * b) := by simp\n\n"}
{"name":"Filter.pure_add_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Add α\na b : α\n⊢ Eq (HAdd.hAdd (Pure.pure a) (Pure.pure b)) (Pure.pure (HAdd.hAdd a b))","decl":"@[to_additive]\ntheorem pure_mul_pure : (pure a : Filter α) * pure b = pure (a * b) := by simp\n\n"}
{"name":"Filter.le_mul_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Mul α\nf g h : Filter α\n⊢ Iff (LE.le h (HMul.hMul f g)) (∀ ⦃s : Set α⦄, Membership.mem f s → ∀ ⦃t : Set α⦄, Membership.mem g t → Membership.mem h (HMul.hMul s t))","decl":"@[to_additive (attr := simp)]\ntheorem le_mul_iff : h ≤ f * g ↔ ∀ ⦃s⦄, s ∈ f → ∀ ⦃t⦄, t ∈ g → s * t ∈ h :=\n  le_map₂_iff\n\n"}
{"name":"Filter.le_add_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Add α\nf g h : Filter α\n⊢ Iff (LE.le h (HAdd.hAdd f g)) (∀ ⦃s : Set α⦄, Membership.mem f s → ∀ ⦃t : Set α⦄, Membership.mem g t → Membership.mem h (HAdd.hAdd s t))","decl":"@[to_additive (attr := simp)]\ntheorem le_mul_iff : h ≤ f * g ↔ ∀ ⦃s⦄, s ∈ f → ∀ ⦃t⦄, t ∈ g → s * t ∈ h :=\n  le_map₂_iff\n\n"}
{"name":"Filter.addLeftMono","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Add α\n⊢ AddLeftMono (Filter α)","decl":"@[to_additive]\ninstance mulLeftMono : MulLeftMono (Filter α) :=\n  ⟨fun _ _ _ => map₂_mono_left⟩\n\n"}
{"name":"Filter.mulLeftMono","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Mul α\n⊢ MulLeftMono (Filter α)","decl":"@[to_additive]\ninstance mulLeftMono : MulLeftMono (Filter α) :=\n  ⟨fun _ _ _ => map₂_mono_left⟩\n\n"}
{"name":"Filter.addRightMono","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Add α\n⊢ AddRightMono (Filter α)","decl":"@[to_additive]\ninstance mulRightMono : MulRightMono (Filter α) :=\n  ⟨fun _ _ _ => map₂_mono_right⟩\n\n"}
{"name":"Filter.mulRightMono","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Mul α\n⊢ MulRightMono (Filter α)","decl":"@[to_additive]\ninstance mulRightMono : MulRightMono (Filter α) :=\n  ⟨fun _ _ _ => map₂_mono_right⟩\n\n"}
{"name":"Filter.map_mul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Mul α\ninst✝² : Mul β\nf₁ f₂ : Filter α\ninst✝¹ : FunLike F α β\ninst✝ : MulHomClass F α β\nm : F\n⊢ Eq (Filter.map (⇑m) (HMul.hMul f₁ f₂)) (HMul.hMul (Filter.map (⇑m) f₁) (Filter.map (⇑m) f₂))","decl":"@[to_additive]\nprotected theorem map_mul [FunLike F α β] [MulHomClass F α β] (m : F) :\n    (f₁ * f₂).map m = f₁.map m * f₂.map m :=\n  map_map₂_distrib <| map_mul m\n\n"}
{"name":"Filter.map_add","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Add α\ninst✝² : Add β\nf₁ f₂ : Filter α\ninst✝¹ : FunLike F α β\ninst✝ : AddHomClass F α β\nm : F\n⊢ Eq (Filter.map (⇑m) (HAdd.hAdd f₁ f₂)) (HAdd.hAdd (Filter.map (⇑m) f₁) (Filter.map (⇑m) f₂))","decl":"@[to_additive]\nprotected theorem map_mul [FunLike F α β] [MulHomClass F α β] (m : F) :\n    (f₁ * f₂).map m = f₁.map m * f₂.map m :=\n  map_map₂_distrib <| map_mul m\n\n"}
{"name":"Filter.coe_pureAddHom","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Add α\n⊢ Eq (⇑Filter.pureAddHom) Pure.pure","decl":"@[to_additive (attr := simp)]\ntheorem coe_pureMulHom : (pureMulHom : α → Filter α) = pure :=\n  rfl\n\n"}
{"name":"Filter.coe_pureMulHom","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Mul α\n⊢ Eq (⇑Filter.pureMulHom) Pure.pure","decl":"@[to_additive (attr := simp)]\ntheorem coe_pureMulHom : (pureMulHom : α → Filter α) = pure :=\n  rfl\n\n"}
{"name":"Filter.pureAddHom_apply","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Add α\na : α\n⊢ Eq (Filter.pureAddHom a) (Pure.pure a)","decl":"@[to_additive (attr := simp)]\ntheorem pureMulHom_apply (a : α) : pureMulHom a = pure a :=\n  rfl\n\n"}
{"name":"Filter.pureMulHom_apply","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Mul α\na : α\n⊢ Eq (Filter.pureMulHom a) (Pure.pure a)","decl":"@[to_additive (attr := simp)]\ntheorem pureMulHom_apply (a : α) : pureMulHom a = pure a :=\n  rfl\n\n"}
{"name":"Filter.map₂_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Div α\nf g : Filter α\n⊢ Eq (Filter.map₂ (fun x1 x2 => HDiv.hDiv x1 x2) f g) (HDiv.hDiv f g)","decl":"@[to_additive (attr := simp)]\ntheorem map₂_div : map₂ (· / ·) f g = f / g :=\n  rfl\n\n"}
{"name":"Filter.map₂_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Sub α\nf g : Filter α\n⊢ Eq (Filter.map₂ (fun x1 x2 => HSub.hSub x1 x2) f g) (HSub.hSub f g)","decl":"@[to_additive (attr := simp)]\ntheorem map₂_div : map₂ (· / ·) f g = f / g :=\n  rfl\n\n"}
{"name":"Filter.mem_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Sub α\nf g : Filter α\ns : Set α\n⊢ Iff (Membership.mem (HSub.hSub f g) s) (Exists fun t₁ => And (Membership.mem f t₁) (Exists fun t₂ => And (Membership.mem g t₂) (HasSubset.Subset (HSub.hSub t₁ t₂) s)))","decl":"@[to_additive]\ntheorem mem_div : s ∈ f / g ↔ ∃ t₁ ∈ f, ∃ t₂ ∈ g, t₁ / t₂ ⊆ s :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Div α\nf g : Filter α\ns : Set α\n⊢ Iff (Membership.mem (HDiv.hDiv f g) s) (Exists fun t₁ => And (Membership.mem f t₁) (Exists fun t₂ => And (Membership.mem g t₂) (HasSubset.Subset (HDiv.hDiv t₁ t₂) s)))","decl":"@[to_additive]\ntheorem mem_div : s ∈ f / g ↔ ∃ t₁ ∈ f, ∃ t₂ ∈ g, t₁ / t₂ ⊆ s :=\n  Iff.rfl\n\n"}
{"name":"Filter.sub_mem_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Sub α\nf g : Filter α\ns t : Set α\na✝¹ : Membership.mem f s\na✝ : Membership.mem g t\n⊢ Membership.mem (HSub.hSub f g) (HSub.hSub s t)","decl":"@[to_additive]\ntheorem div_mem_div : s ∈ f → t ∈ g → s / t ∈ f / g :=\n  image2_mem_map₂\n\n"}
{"name":"Filter.div_mem_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Div α\nf g : Filter α\ns t : Set α\na✝¹ : Membership.mem f s\na✝ : Membership.mem g t\n⊢ Membership.mem (HDiv.hDiv f g) (HDiv.hDiv s t)","decl":"@[to_additive]\ntheorem div_mem_div : s ∈ f → t ∈ g → s / t ∈ f / g :=\n  image2_mem_map₂\n\n"}
{"name":"Filter.bot_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Sub α\ng : Filter α\n⊢ Eq (HSub.hSub Bot.bot g) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem bot_div : ⊥ / g = ⊥ :=\n  map₂_bot_left\n\n"}
{"name":"Filter.bot_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Div α\ng : Filter α\n⊢ Eq (HDiv.hDiv Bot.bot g) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem bot_div : ⊥ / g = ⊥ :=\n  map₂_bot_left\n\n"}
{"name":"Filter.sub_bot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Sub α\nf : Filter α\n⊢ Eq (HSub.hSub f Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem div_bot : f / ⊥ = ⊥ :=\n  map₂_bot_right\n\n"}
{"name":"Filter.div_bot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Div α\nf : Filter α\n⊢ Eq (HDiv.hDiv f Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem div_bot : f / ⊥ = ⊥ :=\n  map₂_bot_right\n\n"}
{"name":"Filter.div_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Div α\nf g : Filter α\n⊢ Iff (Eq (HDiv.hDiv f g) Bot.bot) (Or (Eq f Bot.bot) (Eq g Bot.bot))","decl":"@[to_additive (attr := simp)]\ntheorem div_eq_bot_iff : f / g = ⊥ ↔ f = ⊥ ∨ g = ⊥ :=\n  map₂_eq_bot_iff\n\n"}
{"name":"Filter.sub_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Sub α\nf g : Filter α\n⊢ Iff (Eq (HSub.hSub f g) Bot.bot) (Or (Eq f Bot.bot) (Eq g Bot.bot))","decl":"@[to_additive (attr := simp)]\ntheorem div_eq_bot_iff : f / g = ⊥ ↔ f = ⊥ ∨ g = ⊥ :=\n  map₂_eq_bot_iff\n\n"}
{"name":"Filter.div_neBot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Div α\nf g : Filter α\n⊢ Iff (HDiv.hDiv f g).NeBot (And f.NeBot g.NeBot)","decl":"@[to_additive (attr := simp)]\ntheorem div_neBot_iff : (f / g).NeBot ↔ f.NeBot ∧ g.NeBot :=\n  map₂_neBot_iff\n\n"}
{"name":"Filter.sub_neBot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Sub α\nf g : Filter α\n⊢ Iff (HSub.hSub f g).NeBot (And f.NeBot g.NeBot)","decl":"@[to_additive (attr := simp)]\ntheorem div_neBot_iff : (f / g).NeBot ↔ f.NeBot ∧ g.NeBot :=\n  map₂_neBot_iff\n\n"}
{"name":"Filter.NeBot.sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Sub α\nf g : Filter α\na✝¹ : f.NeBot\na✝ : g.NeBot\n⊢ (HSub.hSub f g).NeBot","decl":"@[to_additive]\nprotected theorem NeBot.div : NeBot f → NeBot g → NeBot (f / g) :=\n  NeBot.map₂\n\n"}
{"name":"Filter.NeBot.div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Div α\nf g : Filter α\na✝¹ : f.NeBot\na✝ : g.NeBot\n⊢ (HDiv.hDiv f g).NeBot","decl":"@[to_additive]\nprotected theorem NeBot.div : NeBot f → NeBot g → NeBot (f / g) :=\n  NeBot.map₂\n\n"}
{"name":"Filter.NeBot.of_div_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Div α\nf g : Filter α\na✝ : (HDiv.hDiv f g).NeBot\n⊢ f.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_div_left : (f / g).NeBot → f.NeBot :=\n  NeBot.of_map₂_left\n\n"}
{"name":"Filter.NeBot.of_sub_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Sub α\nf g : Filter α\na✝ : (HSub.hSub f g).NeBot\n⊢ f.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_div_left : (f / g).NeBot → f.NeBot :=\n  NeBot.of_map₂_left\n\n"}
{"name":"Filter.NeBot.of_div_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Div α\nf g : Filter α\na✝ : (HDiv.hDiv f g).NeBot\n⊢ g.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_div_right : (f / g).NeBot → g.NeBot :=\n  NeBot.of_map₂_right\n\n"}
{"name":"Filter.NeBot.of_sub_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Sub α\nf g : Filter α\na✝ : (HSub.hSub f g).NeBot\n⊢ g.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_div_right : (f / g).NeBot → g.NeBot :=\n  NeBot.of_map₂_right\n\n"}
{"name":"Filter.div.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝² : Div α\nf g : Filter α\ninst✝¹ : f.NeBot\ninst✝ : g.NeBot\n⊢ (HDiv.hDiv f g).NeBot","decl":"@[to_additive sub.instNeBot]\nlemma div.instNeBot [NeBot f] [NeBot g] : NeBot (f / g) := .div ‹_› ‹_›\n\n"}
{"name":"Filter.sub.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝² : Sub α\nf g : Filter α\ninst✝¹ : f.NeBot\ninst✝ : g.NeBot\n⊢ (HSub.hSub f g).NeBot","decl":"@[to_additive sub.instNeBot]\nlemma div.instNeBot [NeBot f] [NeBot g] : NeBot (f / g) := .div ‹_› ‹_›\n\n"}
{"name":"Filter.pure_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Sub α\ng : Filter α\na : α\n⊢ Eq (HSub.hSub (Pure.pure a) g) (Filter.map (fun x => HSub.hSub a x) g)","decl":"@[to_additive (attr := simp)]\ntheorem pure_div : pure a / g = g.map (a / ·) :=\n  map₂_pure_left\n\n"}
{"name":"Filter.pure_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Div α\ng : Filter α\na : α\n⊢ Eq (HDiv.hDiv (Pure.pure a) g) (Filter.map (fun x => HDiv.hDiv a x) g)","decl":"@[to_additive (attr := simp)]\ntheorem pure_div : pure a / g = g.map (a / ·) :=\n  map₂_pure_left\n\n"}
{"name":"Filter.div_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Div α\nf : Filter α\nb : α\n⊢ Eq (HDiv.hDiv f (Pure.pure b)) (Filter.map (fun x => HDiv.hDiv x b) f)","decl":"@[to_additive (attr := simp)]\ntheorem div_pure : f / pure b = f.map (· / b) :=\n  map₂_pure_right\n\n"}
{"name":"Filter.sub_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Sub α\nf : Filter α\nb : α\n⊢ Eq (HSub.hSub f (Pure.pure b)) (Filter.map (fun x => HSub.hSub x b) f)","decl":"@[to_additive (attr := simp)]\ntheorem div_pure : f / pure b = f.map (· / b) :=\n  map₂_pure_right\n\n"}
{"name":"Filter.pure_sub_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Sub α\na b : α\n⊢ Eq (HSub.hSub (Pure.pure a) (Pure.pure b)) (Pure.pure (HSub.hSub a b))","decl":"@[to_additive]\ntheorem pure_div_pure : (pure a : Filter α) / pure b = pure (a / b) := by simp\n\n"}
{"name":"Filter.pure_div_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Div α\na b : α\n⊢ Eq (HDiv.hDiv (Pure.pure a) (Pure.pure b)) (Pure.pure (HDiv.hDiv a b))","decl":"@[to_additive]\ntheorem pure_div_pure : (pure a : Filter α) / pure b = pure (a / b) := by simp\n\n"}
{"name":"Filter.div_le_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Div α\nf₁ f₂ g₁ g₂ : Filter α\na✝¹ : LE.le f₁ f₂\na✝ : LE.le g₁ g₂\n⊢ LE.le (HDiv.hDiv f₁ g₁) (HDiv.hDiv f₂ g₂)","decl":"@[to_additive]\nprotected theorem div_le_div : f₁ ≤ f₂ → g₁ ≤ g₂ → f₁ / g₁ ≤ f₂ / g₂ :=\n  map₂_mono\n\n"}
{"name":"Filter.sub_le_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Sub α\nf₁ f₂ g₁ g₂ : Filter α\na✝¹ : LE.le f₁ f₂\na✝ : LE.le g₁ g₂\n⊢ LE.le (HSub.hSub f₁ g₁) (HSub.hSub f₂ g₂)","decl":"@[to_additive]\nprotected theorem div_le_div : f₁ ≤ f₂ → g₁ ≤ g₂ → f₁ / g₁ ≤ f₂ / g₂ :=\n  map₂_mono\n\n"}
{"name":"Filter.div_le_div_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Div α\nf g₁ g₂ : Filter α\na✝ : LE.le g₁ g₂\n⊢ LE.le (HDiv.hDiv f g₁) (HDiv.hDiv f g₂)","decl":"@[to_additive]\nprotected theorem div_le_div_left : g₁ ≤ g₂ → f / g₁ ≤ f / g₂ :=\n  map₂_mono_left\n\n"}
{"name":"Filter.sub_le_sub_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Sub α\nf g₁ g₂ : Filter α\na✝ : LE.le g₁ g₂\n⊢ LE.le (HSub.hSub f g₁) (HSub.hSub f g₂)","decl":"@[to_additive]\nprotected theorem div_le_div_left : g₁ ≤ g₂ → f / g₁ ≤ f / g₂ :=\n  map₂_mono_left\n\n"}
{"name":"Filter.sub_le_sub_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Sub α\nf₁ f₂ g : Filter α\na✝ : LE.le f₁ f₂\n⊢ LE.le (HSub.hSub f₁ g) (HSub.hSub f₂ g)","decl":"@[to_additive]\nprotected theorem div_le_div_right : f₁ ≤ f₂ → f₁ / g ≤ f₂ / g :=\n  map₂_mono_right\n\n"}
{"name":"Filter.div_le_div_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Div α\nf₁ f₂ g : Filter α\na✝ : LE.le f₁ f₂\n⊢ LE.le (HDiv.hDiv f₁ g) (HDiv.hDiv f₂ g)","decl":"@[to_additive]\nprotected theorem div_le_div_right : f₁ ≤ f₂ → f₁ / g ≤ f₂ / g :=\n  map₂_mono_right\n\n"}
{"name":"Filter.le_sub_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Sub α\nf g h : Filter α\n⊢ Iff (LE.le h (HSub.hSub f g)) (∀ ⦃s : Set α⦄, Membership.mem f s → ∀ ⦃t : Set α⦄, Membership.mem g t → Membership.mem h (HSub.hSub s t))","decl":"@[to_additive (attr := simp)]\nprotected theorem le_div_iff : h ≤ f / g ↔ ∀ ⦃s⦄, s ∈ f → ∀ ⦃t⦄, t ∈ g → s / t ∈ h :=\n  le_map₂_iff\n\n"}
{"name":"Filter.le_div_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Div α\nf g h : Filter α\n⊢ Iff (LE.le h (HDiv.hDiv f g)) (∀ ⦃s : Set α⦄, Membership.mem f s → ∀ ⦃t : Set α⦄, Membership.mem g t → Membership.mem h (HDiv.hDiv s t))","decl":"@[to_additive (attr := simp)]\nprotected theorem le_div_iff : h ≤ f / g ↔ ∀ ⦃s⦄, s ∈ f → ∀ ⦃t⦄, t ∈ g → s / t ∈ h :=\n  le_map₂_iff\n\n"}
{"name":"Filter.covariant_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Div α\n⊢ CovariantClass (Filter α) (Filter α) (fun x1 x2 => HDiv.hDiv x1 x2) fun x1 x2 => LE.le x1 x2","decl":"@[to_additive]\ninstance covariant_div : CovariantClass (Filter α) (Filter α) (· / ·) (· ≤ ·) :=\n  ⟨fun _ _ _ => map₂_mono_left⟩\n\n"}
{"name":"Filter.covariant_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Sub α\n⊢ CovariantClass (Filter α) (Filter α) (fun x1 x2 => HSub.hSub x1 x2) fun x1 x2 => LE.le x1 x2","decl":"@[to_additive]\ninstance covariant_div : CovariantClass (Filter α) (Filter α) (· / ·) (· ≤ ·) :=\n  ⟨fun _ _ _ => map₂_mono_left⟩\n\n"}
{"name":"Filter.covariant_swap_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Div α\n⊢ CovariantClass (Filter α) (Filter α) (Function.swap fun x1 x2 => HDiv.hDiv x1 x2) fun x1 x2 => LE.le x1 x2","decl":"@[to_additive]\ninstance covariant_swap_div : CovariantClass (Filter α) (Filter α) (swap (· / ·)) (· ≤ ·) :=\n  ⟨fun _ _ _ => map₂_mono_right⟩\n\n"}
{"name":"Filter.covariant_swap_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Sub α\n⊢ CovariantClass (Filter α) (Filter α) (Function.swap fun x1 x2 => HSub.hSub x1 x2) fun x1 x2 => LE.le x1 x2","decl":"@[to_additive]\ninstance covariant_swap_div : CovariantClass (Filter α) (Filter α) (swap (· / ·)) (· ≤ ·) :=\n  ⟨fun _ _ _ => map₂_mono_right⟩\n\n"}
{"name":"Filter.comap_mul_comap_le","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : MulOneClass α\ninst✝² : MulOneClass β\ninst✝¹ : FunLike F α β\ninst✝ : MulHomClass F α β\nm : F\nf g : Filter β\n⊢ LE.le (HMul.hMul (Filter.comap (⇑m) f) (Filter.comap (⇑m) g)) (Filter.comap (⇑m) (HMul.hMul f g))","decl":"@[to_additive]\ntheorem comap_mul_comap_le [MulHomClass F α β] (m : F) {f g : Filter β} :\n    f.comap m * g.comap m ≤ (f * g).comap m := fun _ ⟨_, ⟨t₁, ht₁, t₂, ht₂, t₁t₂⟩, mt⟩ =>\n  ⟨m ⁻¹' t₁, ⟨t₁, ht₁, Subset.rfl⟩, m ⁻¹' t₂, ⟨t₂, ht₂, Subset.rfl⟩,\n    (preimage_mul_preimage_subset _).trans <| (preimage_mono t₁t₂).trans mt⟩\n\n"}
{"name":"Filter.comap_add_comap_le","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddZeroClass α\ninst✝² : AddZeroClass β\ninst✝¹ : FunLike F α β\ninst✝ : AddHomClass F α β\nm : F\nf g : Filter β\n⊢ LE.le (HAdd.hAdd (Filter.comap (⇑m) f) (Filter.comap (⇑m) g)) (Filter.comap (⇑m) (HAdd.hAdd f g))","decl":"@[to_additive]\ntheorem comap_mul_comap_le [MulHomClass F α β] (m : F) {f g : Filter β} :\n    f.comap m * g.comap m ≤ (f * g).comap m := fun _ ⟨_, ⟨t₁, ht₁, t₂, ht₂, t₁t₂⟩, mt⟩ =>\n  ⟨m ⁻¹' t₁, ⟨t₁, ht₁, Subset.rfl⟩, m ⁻¹' t₂, ⟨t₂, ht₂, Subset.rfl⟩,\n    (preimage_mul_preimage_subset _).trans <| (preimage_mono t₁t₂).trans mt⟩\n\n"}
{"name":"Filter.Tendsto.add_add","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddZeroClass α\ninst✝² : AddZeroClass β\ninst✝¹ : FunLike F α β\ninst✝ : AddHomClass F α β\nm : F\nf₁ g₁ : Filter α\nf₂ g₂ : Filter β\na✝¹ : Filter.Tendsto (⇑m) f₁ f₂\na✝ : Filter.Tendsto (⇑m) g₁ g₂\n⊢ Filter.Tendsto (⇑m) (HAdd.hAdd f₁ g₁) (HAdd.hAdd f₂ g₂)","decl":"@[to_additive]\ntheorem Tendsto.mul_mul [MulHomClass F α β] (m : F) {f₁ g₁ : Filter α} {f₂ g₂ : Filter β} :\n    Tendsto m f₁ f₂ → Tendsto m g₁ g₂ → Tendsto m (f₁ * g₁) (f₂ * g₂) := fun hf hg =>\n  (Filter.map_mul m).trans_le <| mul_le_mul' hf hg\n\n"}
{"name":"Filter.Tendsto.mul_mul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : MulOneClass α\ninst✝² : MulOneClass β\ninst✝¹ : FunLike F α β\ninst✝ : MulHomClass F α β\nm : F\nf₁ g₁ : Filter α\nf₂ g₂ : Filter β\na✝¹ : Filter.Tendsto (⇑m) f₁ f₂\na✝ : Filter.Tendsto (⇑m) g₁ g₂\n⊢ Filter.Tendsto (⇑m) (HMul.hMul f₁ g₁) (HMul.hMul f₂ g₂)","decl":"@[to_additive]\ntheorem Tendsto.mul_mul [MulHomClass F α β] (m : F) {f₁ g₁ : Filter α} {f₂ g₂ : Filter β} :\n    Tendsto m f₁ f₂ → Tendsto m g₁ g₂ → Tendsto m (f₁ * g₁) (f₂ * g₂) := fun hf hg =>\n  (Filter.map_mul m).trans_le <| mul_le_mul' hf hg\n\n"}
{"name":"Filter.coe_pureAddMonoidHom","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : AddZeroClass α\n⊢ Eq (⇑Filter.pureAddMonoidHom) Pure.pure","decl":"@[to_additive (attr := simp)]\ntheorem coe_pureMonoidHom : (pureMonoidHom : α → Filter α) = pure :=\n  rfl\n\n"}
{"name":"Filter.coe_pureMonoidHom","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : MulOneClass α\n⊢ Eq (⇑Filter.pureMonoidHom) Pure.pure","decl":"@[to_additive (attr := simp)]\ntheorem coe_pureMonoidHom : (pureMonoidHom : α → Filter α) = pure :=\n  rfl\n\n"}
{"name":"Filter.pureAddMonoidHom_apply","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : AddZeroClass α\na : α\n⊢ Eq (Filter.pureAddMonoidHom a) (Pure.pure a)","decl":"@[to_additive (attr := simp)]\ntheorem pureMonoidHom_apply (a : α) : pureMonoidHom a = pure a :=\n  rfl\n\n"}
{"name":"Filter.pureMonoidHom_apply","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : MulOneClass α\na : α\n⊢ Eq (Filter.pureMonoidHom a) (Pure.pure a)","decl":"@[to_additive (attr := simp)]\ntheorem pureMonoidHom_apply (a : α) : pureMonoidHom a = pure a :=\n  rfl\n\n"}
{"name":"Filter.pow_mem_pow","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Monoid α\nf : Filter α\ns : Set α\nhs : Membership.mem f s\nn : Nat\n⊢ Membership.mem (HPow.hPow f n) (HPow.hPow s n)","decl":"@[to_additive]\ntheorem pow_mem_pow (hs : s ∈ f) : ∀ n : ℕ, s ^ n ∈ f ^ n\n  | 0 => by\n    rw [pow_zero]\n    exact one_mem_one\n  | n + 1 => by\n    rw [pow_succ]\n    exact mul_mem_mul (pow_mem_pow hs n) hs\n\n"}
{"name":"Filter.nsmul_mem_nsmul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\nf : Filter α\ns : Set α\nhs : Membership.mem f s\nn : Nat\n⊢ Membership.mem (HSMul.hSMul n f) (HSMul.hSMul n s)","decl":"@[to_additive]\ntheorem pow_mem_pow (hs : s ∈ f) : ∀ n : ℕ, s ^ n ∈ f ^ n\n  | 0 => by\n    rw [pow_zero]\n    exact one_mem_one\n  | n + 1 => by\n    rw [pow_succ]\n    exact mul_mem_mul (pow_mem_pow hs n) hs\n\n"}
{"name":"Filter.nsmul_bot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\nn : Nat\nhn : Ne n 0\n⊢ Eq (HSMul.hSMul n Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp) nsmul_bot]\ntheorem bot_pow {n : ℕ} (hn : n ≠ 0) : (⊥ : Filter α) ^ n = ⊥ := by\n  rw [← Nat.sub_one_add_one hn, pow_succ', bot_mul]\n\n"}
{"name":"Filter.bot_pow","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Monoid α\nn : Nat\nhn : Ne n 0\n⊢ Eq (HPow.hPow Bot.bot n) Bot.bot","decl":"@[to_additive (attr := simp) nsmul_bot]\ntheorem bot_pow {n : ℕ} (hn : n ≠ 0) : (⊥ : Filter α) ^ n = ⊥ := by\n  rw [← Nat.sub_one_add_one hn, pow_succ', bot_mul]\n\n"}
{"name":"Filter.add_top_of_nonneg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\nf : Filter α\nhf : LE.le 0 f\n⊢ Eq (HAdd.hAdd f Top.top) Top.top","decl":"@[to_additive]\ntheorem mul_top_of_one_le (hf : 1 ≤ f) : f * ⊤ = ⊤ := by\n  refine top_le_iff.1 fun s => ?_\n  simp only [mem_mul, mem_top, exists_and_left, exists_eq_left]\n  rintro ⟨t, ht, hs⟩\n  rwa [mul_univ_of_one_mem (mem_one.1 <| hf ht), univ_subset_iff] at hs\n\n"}
{"name":"Filter.mul_top_of_one_le","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Monoid α\nf : Filter α\nhf : LE.le 1 f\n⊢ Eq (HMul.hMul f Top.top) Top.top","decl":"@[to_additive]\ntheorem mul_top_of_one_le (hf : 1 ≤ f) : f * ⊤ = ⊤ := by\n  refine top_le_iff.1 fun s => ?_\n  simp only [mem_mul, mem_top, exists_and_left, exists_eq_left]\n  rintro ⟨t, ht, hs⟩\n  rwa [mul_univ_of_one_mem (mem_one.1 <| hf ht), univ_subset_iff] at hs\n\n"}
{"name":"Filter.top_add_of_nonneg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\nf : Filter α\nhf : LE.le 0 f\n⊢ Eq (HAdd.hAdd Top.top f) Top.top","decl":"@[to_additive]\ntheorem top_mul_of_one_le (hf : 1 ≤ f) : ⊤ * f = ⊤ := by\n  refine top_le_iff.1 fun s => ?_\n  simp only [mem_mul, mem_top, exists_and_left, exists_eq_left]\n  rintro ⟨t, ht, hs⟩\n  rwa [univ_mul_of_one_mem (mem_one.1 <| hf ht), univ_subset_iff] at hs\n\n"}
{"name":"Filter.top_mul_of_one_le","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Monoid α\nf : Filter α\nhf : LE.le 1 f\n⊢ Eq (HMul.hMul Top.top f) Top.top","decl":"@[to_additive]\ntheorem top_mul_of_one_le (hf : 1 ≤ f) : ⊤ * f = ⊤ := by\n  refine top_le_iff.1 fun s => ?_\n  simp only [mem_mul, mem_top, exists_and_left, exists_eq_left]\n  rintro ⟨t, ht, hs⟩\n  rwa [univ_mul_of_one_mem (mem_one.1 <| hf ht), univ_subset_iff] at hs\n\n"}
{"name":"Filter.top_add_top","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\n⊢ Eq (HAdd.hAdd Top.top Top.top) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem top_mul_top : (⊤ : Filter α) * ⊤ = ⊤ :=\n  mul_top_of_one_le le_top\n\n"}
{"name":"Filter.top_mul_top","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Monoid α\n⊢ Eq (HMul.hMul Top.top Top.top) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem top_mul_top : (⊤ : Filter α) * ⊤ = ⊤ :=\n  mul_top_of_one_le le_top\n\n"}
{"name":"Filter.nsmul_top","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\nn : Nat\na✝ : Ne n 0\n⊢ Eq (HSMul.hSMul n Top.top) Top.top","decl":"@[to_additive nsmul_top]\ntheorem top_pow : ∀ {n : ℕ}, n ≠ 0 → (⊤ : Filter α) ^ n = ⊤\n  | 0 => fun h => (h rfl).elim\n  | 1 => fun _ => pow_one _\n  | n + 2 => fun _ => by rw [pow_succ, top_pow n.succ_ne_zero, top_mul_top]\n\n"}
{"name":"Filter.top_pow","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Monoid α\nn : Nat\na✝ : Ne n 0\n⊢ Eq (HPow.hPow Top.top n) Top.top","decl":"@[to_additive nsmul_top]\ntheorem top_pow : ∀ {n : ℕ}, n ≠ 0 → (⊤ : Filter α) ^ n = ⊤\n  | 0 => fun h => (h rfl).elim\n  | 1 => fun _ => pow_one _\n  | n + 2 => fun _ => by rw [pow_succ, top_pow n.succ_ne_zero, top_mul_top]\n\n"}
{"name":"IsAddUnit.filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\na : α\na✝ : IsAddUnit a\n⊢ IsAddUnit (Pure.pure a)","decl":"@[to_additive]\nprotected theorem _root_.IsUnit.filter : IsUnit a → IsUnit (pure a : Filter α) :=\n  IsUnit.map (pureMonoidHom : α →* Filter α)\n\n"}
{"name":"IsUnit.filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Monoid α\na : α\na✝ : IsUnit a\n⊢ IsUnit (Pure.pure a)","decl":"@[to_additive]\nprotected theorem _root_.IsUnit.filter : IsUnit a → IsUnit (pure a : Filter α) :=\n  IsUnit.map (pureMonoidHom : α →* Filter α)\n\n"}
{"name":"Filter.mul_eq_one_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : DivisionMonoid α\nf g : Filter α\n⊢ Iff (Eq (HMul.hMul f g) 1) (Exists fun a => Exists fun b => And (Eq f (Pure.pure a)) (And (Eq g (Pure.pure b)) (Eq (HMul.hMul a b) 1)))","decl":"@[to_additive]\nprotected theorem mul_eq_one_iff : f * g = 1 ↔ ∃ a b, f = pure a ∧ g = pure b ∧ a * b = 1 := by\n  refine ⟨fun hfg => ?_, ?_⟩\n  · obtain ⟨t₁, h₁, t₂, h₂, h⟩ : (1 : Set α) ∈ f * g := hfg.symm ▸ one_mem_one\n    have hfg : (f * g).NeBot := hfg.symm.subst one_neBot\n    rw [(hfg.nonempty_of_mem <| mul_mem_mul h₁ h₂).subset_one_iff, Set.mul_eq_one_iff] at h\n    obtain ⟨a, b, rfl, rfl, h⟩ := h\n    refine ⟨a, b, ?_, ?_, h⟩\n    · rwa [← hfg.of_mul_left.le_pure_iff, le_pure_iff]\n    · rwa [← hfg.of_mul_right.le_pure_iff, le_pure_iff]\n  · rintro ⟨a, b, rfl, rfl, h⟩\n    rw [pure_mul_pure, h, pure_one]\n\n"}
{"name":"Filter.add_eq_zero_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : SubtractionMonoid α\nf g : Filter α\n⊢ Iff (Eq (HAdd.hAdd f g) 0) (Exists fun a => Exists fun b => And (Eq f (Pure.pure a)) (And (Eq g (Pure.pure b)) (Eq (HAdd.hAdd a b) 0)))","decl":"@[to_additive]\nprotected theorem mul_eq_one_iff : f * g = 1 ↔ ∃ a b, f = pure a ∧ g = pure b ∧ a * b = 1 := by\n  refine ⟨fun hfg => ?_, ?_⟩\n  · obtain ⟨t₁, h₁, t₂, h₂, h⟩ : (1 : Set α) ∈ f * g := hfg.symm ▸ one_mem_one\n    have hfg : (f * g).NeBot := hfg.symm.subst one_neBot\n    rw [(hfg.nonempty_of_mem <| mul_mem_mul h₁ h₂).subset_one_iff, Set.mul_eq_one_iff] at h\n    obtain ⟨a, b, rfl, rfl, h⟩ := h\n    refine ⟨a, b, ?_, ?_, h⟩\n    · rwa [← hfg.of_mul_left.le_pure_iff, le_pure_iff]\n    · rwa [← hfg.of_mul_right.le_pure_iff, le_pure_iff]\n  · rintro ⟨a, b, rfl, rfl, h⟩\n    rw [pure_mul_pure, h, pure_one]\n\n"}
{"name":"Filter.isAddUnit_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : SubtractionMonoid α\nf : Filter α\n⊢ Iff (IsAddUnit f) (Exists fun a => And (Eq f (Pure.pure a)) (IsAddUnit a))","decl":"@[to_additive]\ntheorem isUnit_iff : IsUnit f ↔ ∃ a, f = pure a ∧ IsUnit a := by\n  constructor\n  · rintro ⟨u, rfl⟩\n    obtain ⟨a, b, ha, hb, h⟩ := Filter.mul_eq_one_iff.1 u.mul_inv\n    refine ⟨a, ha, ⟨a, b, h, pure_injective ?_⟩, rfl⟩\n    rw [← pure_mul_pure, ← ha, ← hb]\n    exact u.inv_mul\n  · rintro ⟨a, rfl, ha⟩\n    exact ha.filter\n\n"}
{"name":"Filter.isUnit_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : DivisionMonoid α\nf : Filter α\n⊢ Iff (IsUnit f) (Exists fun a => And (Eq f (Pure.pure a)) (IsUnit a))","decl":"@[to_additive]\ntheorem isUnit_iff : IsUnit f ↔ ∃ a, f = pure a ∧ IsUnit a := by\n  constructor\n  · rintro ⟨u, rfl⟩\n    obtain ⟨a, b, ha, hb, h⟩ := Filter.mul_eq_one_iff.1 u.mul_inv\n    refine ⟨a, ha, ⟨a, b, h, pure_injective ?_⟩, rfl⟩\n    rw [← pure_mul_pure, ← ha, ← hb]\n    exact u.inv_mul\n  · rintro ⟨a, rfl, ha⟩\n    exact ha.filter\n\n"}
{"name":"Filter.mul_add_subset","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Distrib α\nf g h : Filter α\n⊢ LE.le (HMul.hMul f (HAdd.hAdd g h)) (HAdd.hAdd (HMul.hMul f g) (HMul.hMul f h))","decl":"theorem mul_add_subset : f * (g + h) ≤ f * g + f * h :=\n  map₂_distrib_le_left mul_add\n\n"}
{"name":"Filter.add_mul_subset","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Distrib α\nf g h : Filter α\n⊢ LE.le (HMul.hMul (HAdd.hAdd f g) h) (HAdd.hAdd (HMul.hMul f h) (HMul.hMul g h))","decl":"theorem add_mul_subset : (f + g) * h ≤ f * h + g * h :=\n  map₂_distrib_le_right add_mul\n\n"}
{"name":"Filter.NeBot.mul_zero_nonneg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : MulZeroClass α\nf : Filter α\nhf : f.NeBot\n⊢ LE.le 0 (HMul.hMul f 0)","decl":"theorem NeBot.mul_zero_nonneg (hf : f.NeBot) : 0 ≤ f * 0 :=\n  le_mul_iff.2 fun _ h₁ _ h₂ =>\n    let ⟨_, ha⟩ := hf.nonempty_of_mem h₁\n    ⟨_, ha, _, h₂, mul_zero _⟩\n\n"}
{"name":"Filter.NeBot.zero_mul_nonneg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : MulZeroClass α\ng : Filter α\nhg : g.NeBot\n⊢ LE.le 0 (HMul.hMul 0 g)","decl":"theorem NeBot.zero_mul_nonneg (hg : g.NeBot) : 0 ≤ 0 * g :=\n  le_mul_iff.2 fun _ h₁ _ h₂ =>\n    let ⟨_, hb⟩ := hg.nonempty_of_mem h₂\n    ⟨_, h₁, _, hb, zero_mul _⟩\n\n"}
{"name":"Filter.one_le_div_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Group α\nf g : Filter α\n⊢ Iff (LE.le 1 (HDiv.hDiv f g)) (Not (Disjoint f g))","decl":"@[to_additive (attr := simp 1100)]\nprotected theorem one_le_div_iff : 1 ≤ f / g ↔ ¬Disjoint f g := by\n  refine ⟨fun h hfg => ?_, ?_⟩\n  · obtain ⟨s, hs, t, ht, hst⟩ := hfg.le_bot (mem_bot : ∅ ∈ ⊥)\n    exact Set.one_mem_div_iff.1 (h <| div_mem_div hs ht) (disjoint_iff.2 hst.symm)\n  · rintro h s ⟨t₁, h₁, t₂, h₂, hs⟩\n    exact hs (Set.one_mem_div_iff.2 fun ht => h <| disjoint_of_disjoint_of_mem ht h₁ h₂)\n\n"}
{"name":"Filter.nonneg_sub_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\nf g : Filter α\n⊢ Iff (LE.le 0 (HSub.hSub f g)) (Not (Disjoint f g))","decl":"@[to_additive (attr := simp 1100)]\nprotected theorem one_le_div_iff : 1 ≤ f / g ↔ ¬Disjoint f g := by\n  refine ⟨fun h hfg => ?_, ?_⟩\n  · obtain ⟨s, hs, t, ht, hst⟩ := hfg.le_bot (mem_bot : ∅ ∈ ⊥)\n    exact Set.one_mem_div_iff.1 (h <| div_mem_div hs ht) (disjoint_iff.2 hst.symm)\n  · rintro h s ⟨t₁, h₁, t₂, h₂, hs⟩\n    exact hs (Set.one_mem_div_iff.2 fun ht => h <| disjoint_of_disjoint_of_mem ht h₁ h₂)\n\n"}
{"name":"Filter.not_one_le_div_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Group α\nf g : Filter α\n⊢ Iff (Not (LE.le 1 (HDiv.hDiv f g))) (Disjoint f g)","decl":"@[to_additive]\ntheorem not_one_le_div_iff : ¬1 ≤ f / g ↔ Disjoint f g :=\n  Filter.one_le_div_iff.not_left\n\n"}
{"name":"Filter.not_nonneg_sub_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\nf g : Filter α\n⊢ Iff (Not (LE.le 0 (HSub.hSub f g))) (Disjoint f g)","decl":"@[to_additive]\ntheorem not_one_le_div_iff : ¬1 ≤ f / g ↔ Disjoint f g :=\n  Filter.one_le_div_iff.not_left\n\n"}
{"name":"Filter.NeBot.nonneg_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\nf : Filter α\nh : f.NeBot\n⊢ LE.le 0 (HSub.hSub f f)","decl":"@[to_additive]\ntheorem NeBot.one_le_div (h : f.NeBot) : 1 ≤ f / f := by\n  rintro s ⟨t₁, h₁, t₂, h₂, hs⟩\n  obtain ⟨a, ha₁, ha₂⟩ := Set.not_disjoint_iff.1 (h.not_disjoint h₁ h₂)\n  rw [mem_one, ← div_self' a]\n  exact hs (Set.div_mem_div ha₁ ha₂)\n\n"}
{"name":"Filter.NeBot.one_le_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Group α\nf : Filter α\nh : f.NeBot\n⊢ LE.le 1 (HDiv.hDiv f f)","decl":"@[to_additive]\ntheorem NeBot.one_le_div (h : f.NeBot) : 1 ≤ f / f := by\n  rintro s ⟨t₁, h₁, t₂, h₂, hs⟩\n  obtain ⟨a, ha₁, ha₂⟩ := Set.not_disjoint_iff.1 (h.not_disjoint h₁ h₂)\n  rw [mem_one, ← div_self' a]\n  exact hs (Set.div_mem_div ha₁ ha₂)\n\n"}
{"name":"Filter.isAddUnit_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\na : α\n⊢ IsAddUnit (Pure.pure a)","decl":"@[to_additive]\ntheorem isUnit_pure (a : α) : IsUnit (pure a : Filter α) :=\n  (Group.isUnit a).filter\n\n"}
{"name":"Filter.isUnit_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Group α\na : α\n⊢ IsUnit (Pure.pure a)","decl":"@[to_additive]\ntheorem isUnit_pure (a : α) : IsUnit (pure a : Filter α) :=\n  (Group.isUnit a).filter\n\n"}
{"name":"Filter.isUnit_iff_singleton","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : Group α\nf : Filter α\n⊢ Iff (IsUnit f) (Exists fun a => Eq f (Pure.pure a))","decl":"@[simp]\ntheorem isUnit_iff_singleton : IsUnit f ↔ ∃ a, f = pure a := by\n  simp only [isUnit_iff, Group.isUnit, and_true]\n\n"}
{"name":"Filter.map_inv'","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Group α\ninst✝² : DivisionMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nm : F\nf : Filter α\n⊢ Eq (Filter.map (⇑m) (Inv.inv f)) (Inv.inv (Filter.map (⇑m) f))","decl":"@[to_additive]\ntheorem map_inv' : f⁻¹.map m = (f.map m)⁻¹ :=\n  Semiconj.filter_map (map_inv m) f\n\n"}
{"name":"Filter.map_neg'","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddGroup α\ninst✝² : SubtractionMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nm : F\nf : Filter α\n⊢ Eq (Filter.map (⇑m) (Neg.neg f)) (Neg.neg (Filter.map (⇑m) f))","decl":"@[to_additive]\ntheorem map_inv' : f⁻¹.map m = (f.map m)⁻¹ :=\n  Semiconj.filter_map (map_inv m) f\n\n"}
{"name":"Filter.Tendsto.inv_inv","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Group α\ninst✝² : DivisionMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nm : F\nf₁ : Filter α\nf₂ : Filter β\na✝ : Filter.Tendsto (⇑m) f₁ f₂\n⊢ Filter.Tendsto (⇑m) (Inv.inv f₁) (Inv.inv f₂)","decl":"@[to_additive]\nprotected theorem Tendsto.inv_inv : Tendsto m f₁ f₂ → Tendsto m f₁⁻¹ f₂⁻¹ := fun hf =>\n  (Filter.map_inv' m).trans_le <| Filter.inv_le_inv hf\n\n"}
{"name":"Filter.Tendsto.neg_neg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddGroup α\ninst✝² : SubtractionMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nm : F\nf₁ : Filter α\nf₂ : Filter β\na✝ : Filter.Tendsto (⇑m) f₁ f₂\n⊢ Filter.Tendsto (⇑m) (Neg.neg f₁) (Neg.neg f₂)","decl":"@[to_additive]\nprotected theorem Tendsto.inv_inv : Tendsto m f₁ f₂ → Tendsto m f₁⁻¹ f₂⁻¹ := fun hf =>\n  (Filter.map_inv' m).trans_le <| Filter.inv_le_inv hf\n\n"}
{"name":"Filter.map_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddGroup α\ninst✝² : SubtractionMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nm : F\nf g : Filter α\n⊢ Eq (Filter.map (⇑m) (HSub.hSub f g)) (HSub.hSub (Filter.map (⇑m) f) (Filter.map (⇑m) g))","decl":"@[to_additive]\nprotected theorem map_div : (f / g).map m = f.map m / g.map m :=\n  map_map₂_distrib <| map_div m\n\n"}
{"name":"Filter.map_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Group α\ninst✝² : DivisionMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nm : F\nf g : Filter α\n⊢ Eq (Filter.map (⇑m) (HDiv.hDiv f g)) (HDiv.hDiv (Filter.map (⇑m) f) (Filter.map (⇑m) g))","decl":"@[to_additive]\nprotected theorem map_div : (f / g).map m = f.map m / g.map m :=\n  map_map₂_distrib <| map_div m\n\n"}
{"name":"Filter.Tendsto.div_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Group α\ninst✝² : DivisionMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nm : F\nf₁ g₁ : Filter α\nf₂ g₂ : Filter β\nhf : Filter.Tendsto (⇑m) f₁ f₂\nhg : Filter.Tendsto (⇑m) g₁ g₂\n⊢ Filter.Tendsto (⇑m) (HDiv.hDiv f₁ g₁) (HDiv.hDiv f₂ g₂)","decl":"@[to_additive]\nprotected theorem Tendsto.div_div (hf : Tendsto m f₁ f₂) (hg : Tendsto m g₁ g₂) :\n    Tendsto m (f₁ / g₁) (f₂ / g₂) :=\n  (Filter.map_div m).trans_le <| Filter.div_le_div hf hg\n\n"}
{"name":"Filter.Tendsto.sub_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddGroup α\ninst✝² : SubtractionMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nm : F\nf₁ g₁ : Filter α\nf₂ g₂ : Filter β\nhf : Filter.Tendsto (⇑m) f₁ f₂\nhg : Filter.Tendsto (⇑m) g₁ g₂\n⊢ Filter.Tendsto (⇑m) (HSub.hSub f₁ g₁) (HSub.hSub f₂ g₂)","decl":"@[to_additive]\nprotected theorem Tendsto.div_div (hf : Tendsto m f₁ f₂) (hg : Tendsto m g₁ g₂) :\n    Tendsto m (f₁ / g₁) (f₂ / g₂) :=\n  (Filter.map_div m).trans_le <| Filter.div_le_div hf hg\n\n"}
{"name":"Filter.NeBot.div_zero_nonneg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : GroupWithZero α\nf : Filter α\nhf : f.NeBot\n⊢ LE.le 0 (HDiv.hDiv f 0)","decl":"theorem NeBot.div_zero_nonneg (hf : f.NeBot) : 0 ≤ f / 0 :=\n  Filter.le_div_iff.2 fun _ h₁ _ h₂ =>\n    let ⟨_, ha⟩ := hf.nonempty_of_mem h₁\n    ⟨_, ha, _, h₂, div_zero _⟩\n\n"}
{"name":"Filter.NeBot.zero_div_nonneg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\ninst✝ : GroupWithZero α\ng : Filter α\nhg : g.NeBot\n⊢ LE.le 0 (HDiv.hDiv 0 g)","decl":"theorem NeBot.zero_div_nonneg (hg : g.NeBot) : 0 ≤ 0 / g :=\n  Filter.le_div_iff.2 fun _ h₁ _ h₂ =>\n    let ⟨_, hb⟩ := hg.nonempty_of_mem h₂\n    ⟨_, h₁, _, hb, zero_div _⟩\n\n"}
{"name":"Filter.map₂_vadd","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf : Filter α\ng : Filter β\n⊢ Eq (Filter.map₂ (fun x1 x2 => HVAdd.hVAdd x1 x2) f g) (HVAdd.hVAdd f g)","decl":"@[to_additive (attr := simp)]\ntheorem map₂_smul : map₂ (· • ·) f g = f • g :=\n  rfl\n\n"}
{"name":"Filter.map₂_smul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf : Filter α\ng : Filter β\n⊢ Eq (Filter.map₂ (fun x1 x2 => HSMul.hSMul x1 x2) f g) (HSMul.hSMul f g)","decl":"@[to_additive (attr := simp)]\ntheorem map₂_smul : map₂ (· • ·) f g = f • g :=\n  rfl\n\n"}
{"name":"Filter.mem_vadd","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf : Filter α\ng : Filter β\nt : Set β\n⊢ Iff (Membership.mem (HVAdd.hVAdd f g) t) (Exists fun t₁ => And (Membership.mem f t₁) (Exists fun t₂ => And (Membership.mem g t₂) (HasSubset.Subset (HVAdd.hVAdd t₁ t₂) t)))","decl":"@[to_additive]\ntheorem mem_smul : t ∈ f • g ↔ ∃ t₁ ∈ f, ∃ t₂ ∈ g, t₁ • t₂ ⊆ t :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_smul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf : Filter α\ng : Filter β\nt : Set β\n⊢ Iff (Membership.mem (HSMul.hSMul f g) t) (Exists fun t₁ => And (Membership.mem f t₁) (Exists fun t₂ => And (Membership.mem g t₂) (HasSubset.Subset (HSMul.hSMul t₁ t₂) t)))","decl":"@[to_additive]\ntheorem mem_smul : t ∈ f • g ↔ ∃ t₁ ∈ f, ∃ t₂ ∈ g, t₁ • t₂ ⊆ t :=\n  Iff.rfl\n\n"}
{"name":"Filter.smul_mem_smul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf : Filter α\ng : Filter β\ns : Set α\nt : Set β\na✝¹ : Membership.mem f s\na✝ : Membership.mem g t\n⊢ Membership.mem (HSMul.hSMul f g) (HSMul.hSMul s t)","decl":"@[to_additive]\ntheorem smul_mem_smul : s ∈ f → t ∈ g → s • t ∈ f • g :=\n  image2_mem_map₂\n\n"}
{"name":"Filter.vadd_mem_vadd","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf : Filter α\ng : Filter β\ns : Set α\nt : Set β\na✝¹ : Membership.mem f s\na✝ : Membership.mem g t\n⊢ Membership.mem (HVAdd.hVAdd f g) (HVAdd.hVAdd s t)","decl":"@[to_additive]\ntheorem smul_mem_smul : s ∈ f → t ∈ g → s • t ∈ f • g :=\n  image2_mem_map₂\n\n"}
{"name":"Filter.bot_vadd","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ng : Filter β\n⊢ Eq (HVAdd.hVAdd Bot.bot g) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem bot_smul : (⊥ : Filter α) • g = ⊥ :=\n  map₂_bot_left\n\n"}
{"name":"Filter.bot_smul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ng : Filter β\n⊢ Eq (HSMul.hSMul Bot.bot g) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem bot_smul : (⊥ : Filter α) • g = ⊥ :=\n  map₂_bot_left\n\n"}
{"name":"Filter.vadd_bot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf : Filter α\n⊢ Eq (HVAdd.hVAdd f Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem smul_bot : f • (⊥ : Filter β) = ⊥ :=\n  map₂_bot_right\n\n"}
{"name":"Filter.smul_bot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf : Filter α\n⊢ Eq (HSMul.hSMul f Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem smul_bot : f • (⊥ : Filter β) = ⊥ :=\n  map₂_bot_right\n\n"}
{"name":"Filter.vadd_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf : Filter α\ng : Filter β\n⊢ Iff (Eq (HVAdd.hVAdd f g) Bot.bot) (Or (Eq f Bot.bot) (Eq g Bot.bot))","decl":"@[to_additive (attr := simp)]\ntheorem smul_eq_bot_iff : f • g = ⊥ ↔ f = ⊥ ∨ g = ⊥ :=\n  map₂_eq_bot_iff\n\n"}
{"name":"Filter.smul_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf : Filter α\ng : Filter β\n⊢ Iff (Eq (HSMul.hSMul f g) Bot.bot) (Or (Eq f Bot.bot) (Eq g Bot.bot))","decl":"@[to_additive (attr := simp)]\ntheorem smul_eq_bot_iff : f • g = ⊥ ↔ f = ⊥ ∨ g = ⊥ :=\n  map₂_eq_bot_iff\n\n"}
{"name":"Filter.smul_neBot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf : Filter α\ng : Filter β\n⊢ Iff (HSMul.hSMul f g).NeBot (And f.NeBot g.NeBot)","decl":"@[to_additive (attr := simp)]\ntheorem smul_neBot_iff : (f • g).NeBot ↔ f.NeBot ∧ g.NeBot :=\n  map₂_neBot_iff\n\n"}
{"name":"Filter.vadd_neBot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf : Filter α\ng : Filter β\n⊢ Iff (HVAdd.hVAdd f g).NeBot (And f.NeBot g.NeBot)","decl":"@[to_additive (attr := simp)]\ntheorem smul_neBot_iff : (f • g).NeBot ↔ f.NeBot ∧ g.NeBot :=\n  map₂_neBot_iff\n\n"}
{"name":"Filter.NeBot.smul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf : Filter α\ng : Filter β\na✝¹ : f.NeBot\na✝ : g.NeBot\n⊢ (HSMul.hSMul f g).NeBot","decl":"@[to_additive]\nprotected theorem NeBot.smul : NeBot f → NeBot g → NeBot (f • g) :=\n  NeBot.map₂\n\n"}
{"name":"Filter.NeBot.vadd","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf : Filter α\ng : Filter β\na✝¹ : f.NeBot\na✝ : g.NeBot\n⊢ (HVAdd.hVAdd f g).NeBot","decl":"@[to_additive]\nprotected theorem NeBot.smul : NeBot f → NeBot g → NeBot (f • g) :=\n  NeBot.map₂\n\n"}
{"name":"Filter.NeBot.of_smul_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf : Filter α\ng : Filter β\na✝ : (HSMul.hSMul f g).NeBot\n⊢ f.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_smul_left : (f • g).NeBot → f.NeBot :=\n  NeBot.of_map₂_left\n\n"}
{"name":"Filter.NeBot.of_vadd_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf : Filter α\ng : Filter β\na✝ : (HVAdd.hVAdd f g).NeBot\n⊢ f.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_smul_left : (f • g).NeBot → f.NeBot :=\n  NeBot.of_map₂_left\n\n"}
{"name":"Filter.NeBot.of_vadd_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf : Filter α\ng : Filter β\na✝ : (HVAdd.hVAdd f g).NeBot\n⊢ g.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_smul_right : (f • g).NeBot → g.NeBot :=\n  NeBot.of_map₂_right\n\n"}
{"name":"Filter.NeBot.of_smul_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf : Filter α\ng : Filter β\na✝ : (HSMul.hSMul f g).NeBot\n⊢ g.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_smul_right : (f • g).NeBot → g.NeBot :=\n  NeBot.of_map₂_right\n\n"}
{"name":"Filter.vadd.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : VAdd α β\nf : Filter α\ng : Filter β\ninst✝¹ : f.NeBot\ninst✝ : g.NeBot\n⊢ (HVAdd.hVAdd f g).NeBot","decl":"@[to_additive vadd.instNeBot]\nlemma smul.instNeBot [NeBot f] [NeBot g] : NeBot (f • g) := .smul ‹_› ‹_›\n\n"}
{"name":"Filter.smul.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : SMul α β\nf : Filter α\ng : Filter β\ninst✝¹ : f.NeBot\ninst✝ : g.NeBot\n⊢ (HSMul.hSMul f g).NeBot","decl":"@[to_additive vadd.instNeBot]\nlemma smul.instNeBot [NeBot f] [NeBot g] : NeBot (f • g) := .smul ‹_› ‹_›\n\n"}
{"name":"Filter.pure_smul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ng : Filter β\na : α\n⊢ Eq (HSMul.hSMul (Pure.pure a) g) (Filter.map (fun x => HSMul.hSMul a x) g)","decl":"@[to_additive (attr := simp)]\ntheorem pure_smul : (pure a : Filter α) • g = g.map (a • ·) :=\n  map₂_pure_left\n\n"}
{"name":"Filter.pure_vadd","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ng : Filter β\na : α\n⊢ Eq (HVAdd.hVAdd (Pure.pure a) g) (Filter.map (fun x => HVAdd.hVAdd a x) g)","decl":"@[to_additive (attr := simp)]\ntheorem pure_smul : (pure a : Filter α) • g = g.map (a • ·) :=\n  map₂_pure_left\n\n"}
{"name":"Filter.vadd_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf : Filter α\nb : β\n⊢ Eq (HVAdd.hVAdd f (Pure.pure b)) (Filter.map (fun x => HVAdd.hVAdd x b) f)","decl":"@[to_additive (attr := simp)]\ntheorem smul_pure : f • pure b = f.map (· • b) :=\n  map₂_pure_right\n\n"}
{"name":"Filter.smul_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf : Filter α\nb : β\n⊢ Eq (HSMul.hSMul f (Pure.pure b)) (Filter.map (fun x => HSMul.hSMul x b) f)","decl":"@[to_additive (attr := simp)]\ntheorem smul_pure : f • pure b = f.map (· • b) :=\n  map₂_pure_right\n\n"}
{"name":"Filter.pure_vadd_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\na : α\nb : β\n⊢ Eq (HVAdd.hVAdd (Pure.pure a) (Pure.pure b)) (Pure.pure (HVAdd.hVAdd a b))","decl":"@[to_additive]\ntheorem pure_smul_pure : (pure a : Filter α) • (pure b : Filter β) = pure (a • b) := by simp\n\n"}
{"name":"Filter.pure_smul_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\na : α\nb : β\n⊢ Eq (HSMul.hSMul (Pure.pure a) (Pure.pure b)) (Pure.pure (HSMul.hSMul a b))","decl":"@[to_additive]\ntheorem pure_smul_pure : (pure a : Filter α) • (pure b : Filter β) = pure (a • b) := by simp\n\n"}
{"name":"Filter.vadd_le_vadd","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf₁ f₂ : Filter α\ng₁ g₂ : Filter β\na✝¹ : LE.le f₁ f₂\na✝ : LE.le g₁ g₂\n⊢ LE.le (HVAdd.hVAdd f₁ g₁) (HVAdd.hVAdd f₂ g₂)","decl":"@[to_additive]\ntheorem smul_le_smul : f₁ ≤ f₂ → g₁ ≤ g₂ → f₁ • g₁ ≤ f₂ • g₂ :=\n  map₂_mono\n\n"}
{"name":"Filter.smul_le_smul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf₁ f₂ : Filter α\ng₁ g₂ : Filter β\na✝¹ : LE.le f₁ f₂\na✝ : LE.le g₁ g₂\n⊢ LE.le (HSMul.hSMul f₁ g₁) (HSMul.hSMul f₂ g₂)","decl":"@[to_additive]\ntheorem smul_le_smul : f₁ ≤ f₂ → g₁ ≤ g₂ → f₁ • g₁ ≤ f₂ • g₂ :=\n  map₂_mono\n\n"}
{"name":"Filter.vadd_le_vadd_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf : Filter α\ng₁ g₂ : Filter β\na✝ : LE.le g₁ g₂\n⊢ LE.le (HVAdd.hVAdd f g₁) (HVAdd.hVAdd f g₂)","decl":"@[to_additive]\ntheorem smul_le_smul_left : g₁ ≤ g₂ → f • g₁ ≤ f • g₂ :=\n  map₂_mono_left\n\n"}
{"name":"Filter.smul_le_smul_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf : Filter α\ng₁ g₂ : Filter β\na✝ : LE.le g₁ g₂\n⊢ LE.le (HSMul.hSMul f g₁) (HSMul.hSMul f g₂)","decl":"@[to_additive]\ntheorem smul_le_smul_left : g₁ ≤ g₂ → f • g₁ ≤ f • g₂ :=\n  map₂_mono_left\n\n"}
{"name":"Filter.vadd_le_vadd_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf₁ f₂ : Filter α\ng : Filter β\na✝ : LE.le f₁ f₂\n⊢ LE.le (HVAdd.hVAdd f₁ g) (HVAdd.hVAdd f₂ g)","decl":"@[to_additive]\ntheorem smul_le_smul_right : f₁ ≤ f₂ → f₁ • g ≤ f₂ • g :=\n  map₂_mono_right\n\n"}
{"name":"Filter.smul_le_smul_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf₁ f₂ : Filter α\ng : Filter β\na✝ : LE.le f₁ f₂\n⊢ LE.le (HSMul.hSMul f₁ g) (HSMul.hSMul f₂ g)","decl":"@[to_additive]\ntheorem smul_le_smul_right : f₁ ≤ f₂ → f₁ • g ≤ f₂ • g :=\n  map₂_mono_right\n\n"}
{"name":"Filter.le_vadd_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf : Filter α\ng h : Filter β\n⊢ Iff (LE.le h (HVAdd.hVAdd f g)) (∀ ⦃s : Set α⦄, Membership.mem f s → ∀ ⦃t : Set β⦄, Membership.mem g t → Membership.mem h (HVAdd.hVAdd s t))","decl":"@[to_additive (attr := simp)]\ntheorem le_smul_iff : h ≤ f • g ↔ ∀ ⦃s⦄, s ∈ f → ∀ ⦃t⦄, t ∈ g → s • t ∈ h :=\n  le_map₂_iff\n\n"}
{"name":"Filter.le_smul_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf : Filter α\ng h : Filter β\n⊢ Iff (LE.le h (HSMul.hSMul f g)) (∀ ⦃s : Set α⦄, Membership.mem f s → ∀ ⦃t : Set β⦄, Membership.mem g t → Membership.mem h (HSMul.hSMul s t))","decl":"@[to_additive (attr := simp)]\ntheorem le_smul_iff : h ≤ f • g ↔ ∀ ⦃s⦄, s ∈ f → ∀ ⦃t⦄, t ∈ g → s • t ∈ h :=\n  le_map₂_iff\n\n"}
{"name":"Filter.covariant_vadd","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\n⊢ CovariantClass (Filter α) (Filter β) (fun x1 x2 => HVAdd.hVAdd x1 x2) fun x1 x2 => LE.le x1 x2","decl":"@[to_additive]\ninstance covariant_smul : CovariantClass (Filter α) (Filter β) (· • ·) (· ≤ ·) :=\n  ⟨fun _ _ _ => map₂_mono_left⟩\n\n"}
{"name":"Filter.covariant_smul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\n⊢ CovariantClass (Filter α) (Filter β) (fun x1 x2 => HSMul.hSMul x1 x2) fun x1 x2 => LE.le x1 x2","decl":"@[to_additive]\ninstance covariant_smul : CovariantClass (Filter α) (Filter β) (· • ·) (· ≤ ·) :=\n  ⟨fun _ _ _ => map₂_mono_left⟩\n\n"}
{"name":"Filter.map₂_vsub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\nf g : Filter β\n⊢ Eq (Filter.map₂ (fun x1 x2 => VSub.vsub x1 x2) f g) (VSub.vsub f g)","decl":"@[simp]\ntheorem map₂_vsub : map₂ (· -ᵥ ·) f g = f -ᵥ g :=\n  rfl\n\n"}
{"name":"Filter.mem_vsub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\nf g : Filter β\ns : Set α\n⊢ Iff (Membership.mem (VSub.vsub f g) s) (Exists fun t₁ => And (Membership.mem f t₁) (Exists fun t₂ => And (Membership.mem g t₂) (HasSubset.Subset (VSub.vsub t₁ t₂) s)))","decl":"theorem mem_vsub {s : Set α} : s ∈ f -ᵥ g ↔ ∃ t₁ ∈ f, ∃ t₂ ∈ g, t₁ -ᵥ t₂ ⊆ s :=\n  Iff.rfl\n\n"}
{"name":"Filter.vsub_mem_vsub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\nf g : Filter β\ns t : Set β\na✝¹ : Membership.mem f s\na✝ : Membership.mem g t\n⊢ Membership.mem (VSub.vsub f g) (VSub.vsub s t)","decl":"theorem vsub_mem_vsub : s ∈ f → t ∈ g → s -ᵥ t ∈ f -ᵥ g :=\n  image2_mem_map₂\n\n"}
{"name":"Filter.bot_vsub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ng : Filter β\n⊢ Eq (VSub.vsub Bot.bot g) Bot.bot","decl":"@[simp]\ntheorem bot_vsub : (⊥ : Filter β) -ᵥ g = ⊥ :=\n  map₂_bot_left\n\n"}
{"name":"Filter.vsub_bot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\nf : Filter β\n⊢ Eq (VSub.vsub f Bot.bot) Bot.bot","decl":"@[simp]\ntheorem vsub_bot : f -ᵥ (⊥ : Filter β) = ⊥ :=\n  map₂_bot_right\n\n"}
{"name":"Filter.vsub_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\nf g : Filter β\n⊢ Iff (Eq (VSub.vsub f g) Bot.bot) (Or (Eq f Bot.bot) (Eq g Bot.bot))","decl":"@[simp]\ntheorem vsub_eq_bot_iff : f -ᵥ g = ⊥ ↔ f = ⊥ ∨ g = ⊥ :=\n  map₂_eq_bot_iff\n\n"}
{"name":"Filter.vsub_neBot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\nf g : Filter β\n⊢ Iff (VSub.vsub f g).NeBot (And f.NeBot g.NeBot)","decl":"@[simp]\ntheorem vsub_neBot_iff : (f -ᵥ g : Filter α).NeBot ↔ f.NeBot ∧ g.NeBot :=\n  map₂_neBot_iff\n\n"}
{"name":"Filter.NeBot.vsub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\nf g : Filter β\na✝¹ : f.NeBot\na✝ : g.NeBot\n⊢ (VSub.vsub f g).NeBot","decl":"protected theorem NeBot.vsub : NeBot f → NeBot g → NeBot (f -ᵥ g) :=\n  NeBot.map₂\n\n"}
{"name":"Filter.NeBot.of_vsub_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\nf g : Filter β\na✝ : (VSub.vsub f g).NeBot\n⊢ f.NeBot","decl":"theorem NeBot.of_vsub_left : (f -ᵥ g : Filter α).NeBot → f.NeBot :=\n  NeBot.of_map₂_left\n\n"}
{"name":"Filter.NeBot.of_vsub_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\nf g : Filter β\na✝ : (VSub.vsub f g).NeBot\n⊢ g.NeBot","decl":"theorem NeBot.of_vsub_right : (f -ᵥ g : Filter α).NeBot → g.NeBot :=\n  NeBot.of_map₂_right\n\n"}
{"name":"Filter.vsub.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : VSub α β\nf g : Filter β\ninst✝¹ : f.NeBot\ninst✝ : g.NeBot\n⊢ (VSub.vsub f g).NeBot","decl":"lemma vsub.instNeBot [NeBot f] [NeBot g] : NeBot (f -ᵥ g) := .vsub ‹_› ‹_›\n\n"}
{"name":"Filter.pure_vsub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ng : Filter β\na : β\n⊢ Eq (VSub.vsub (Pure.pure a) g) (Filter.map (fun x => VSub.vsub a x) g)","decl":"@[simp]\ntheorem pure_vsub : (pure a : Filter β) -ᵥ g = g.map (a -ᵥ ·) :=\n  map₂_pure_left\n\n"}
{"name":"Filter.vsub_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\nf : Filter β\nb : β\n⊢ Eq (VSub.vsub f (Pure.pure b)) (Filter.map (fun x => VSub.vsub x b) f)","decl":"@[simp]\ntheorem vsub_pure : f -ᵥ pure b = f.map (· -ᵥ b) :=\n  map₂_pure_right\n\n"}
{"name":"Filter.pure_vsub_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\na b : β\n⊢ Eq (VSub.vsub (Pure.pure a) (Pure.pure b)) (Pure.pure (VSub.vsub a b))","decl":"theorem pure_vsub_pure : (pure a : Filter β) -ᵥ pure b = (pure (a -ᵥ b) : Filter α) := by simp\n\n"}
{"name":"Filter.vsub_le_vsub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\nf₁ f₂ g₁ g₂ : Filter β\na✝¹ : LE.le f₁ f₂\na✝ : LE.le g₁ g₂\n⊢ LE.le (VSub.vsub f₁ g₁) (VSub.vsub f₂ g₂)","decl":"theorem vsub_le_vsub : f₁ ≤ f₂ → g₁ ≤ g₂ → f₁ -ᵥ g₁ ≤ f₂ -ᵥ g₂ :=\n  map₂_mono\n\n"}
{"name":"Filter.vsub_le_vsub_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\nf g₁ g₂ : Filter β\na✝ : LE.le g₁ g₂\n⊢ LE.le (VSub.vsub f g₁) (VSub.vsub f g₂)","decl":"theorem vsub_le_vsub_left : g₁ ≤ g₂ → f -ᵥ g₁ ≤ f -ᵥ g₂ :=\n  map₂_mono_left\n\n"}
{"name":"Filter.vsub_le_vsub_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\nf₁ f₂ g : Filter β\na✝ : LE.le f₁ f₂\n⊢ LE.le (VSub.vsub f₁ g) (VSub.vsub f₂ g)","decl":"theorem vsub_le_vsub_right : f₁ ≤ f₂ → f₁ -ᵥ g ≤ f₂ -ᵥ g :=\n  map₂_mono_right\n\n"}
{"name":"Filter.le_vsub_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\nf g : Filter β\nh : Filter α\n⊢ Iff (LE.le h (VSub.vsub f g)) (∀ ⦃s : Set β⦄, Membership.mem f s → ∀ ⦃t : Set β⦄, Membership.mem g t → Membership.mem h (VSub.vsub s t))","decl":"@[simp]\ntheorem le_vsub_iff : h ≤ f -ᵥ g ↔ ∀ ⦃s⦄, s ∈ f → ∀ ⦃t⦄, t ∈ g → s -ᵥ t ∈ h :=\n  le_map₂_iff\n\n"}
{"name":"Filter.map_smul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf : Filter β\na : α\n⊢ Eq (Filter.map (fun b => HSMul.hSMul a b) f) (HSMul.hSMul a f)","decl":"@[to_additive (attr := simp)]\nprotected theorem map_smul : map (fun b => a • b) f = a • f :=\n  rfl\n\n"}
{"name":"Filter.map_vadd","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf : Filter β\na : α\n⊢ Eq (Filter.map (fun b => HVAdd.hVAdd a b) f) (HVAdd.hVAdd a f)","decl":"@[to_additive (attr := simp)]\nprotected theorem map_smul : map (fun b => a • b) f = a • f :=\n  rfl\n\n"}
{"name":"Filter.mem_vadd_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf : Filter β\ns : Set β\na : α\n⊢ Iff (Membership.mem (HVAdd.hVAdd a f) s) (Membership.mem f (Set.preimage (fun x => HVAdd.hVAdd a x) s))","decl":"@[to_additive]\ntheorem mem_smul_filter : s ∈ a • f ↔ (a • ·) ⁻¹' s ∈ f := Iff.rfl\n\n"}
{"name":"Filter.mem_smul_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf : Filter β\ns : Set β\na : α\n⊢ Iff (Membership.mem (HSMul.hSMul a f) s) (Membership.mem f (Set.preimage (fun x => HSMul.hSMul a x) s))","decl":"@[to_additive]\ntheorem mem_smul_filter : s ∈ a • f ↔ (a • ·) ⁻¹' s ∈ f := Iff.rfl\n\n"}
{"name":"Filter.smul_set_mem_smul_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf : Filter β\ns : Set β\na : α\na✝ : Membership.mem f s\n⊢ Membership.mem (HSMul.hSMul a f) (HSMul.hSMul a s)","decl":"@[to_additive]\ntheorem smul_set_mem_smul_filter : s ∈ f → a • s ∈ a • f :=\n  image_mem_map\n\n"}
{"name":"Filter.vadd_set_mem_vadd_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf : Filter β\ns : Set β\na : α\na✝ : Membership.mem f s\n⊢ Membership.mem (HVAdd.hVAdd a f) (HVAdd.hVAdd a s)","decl":"@[to_additive]\ntheorem smul_set_mem_smul_filter : s ∈ f → a • s ∈ a • f :=\n  image_mem_map\n\n"}
{"name":"Filter.smul_filter_bot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\na : α\n⊢ Eq (HSMul.hSMul a Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem smul_filter_bot : a • (⊥ : Filter β) = ⊥ :=\n  map_bot\n\n"}
{"name":"Filter.vadd_filter_bot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\na : α\n⊢ Eq (HVAdd.hVAdd a Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem smul_filter_bot : a • (⊥ : Filter β) = ⊥ :=\n  map_bot\n\n"}
{"name":"Filter.vadd_filter_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf : Filter β\na : α\n⊢ Iff (Eq (HVAdd.hVAdd a f) Bot.bot) (Eq f Bot.bot)","decl":"@[to_additive (attr := simp)]\ntheorem smul_filter_eq_bot_iff : a • f = ⊥ ↔ f = ⊥ :=\n  map_eq_bot_iff\n\n"}
{"name":"Filter.smul_filter_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf : Filter β\na : α\n⊢ Iff (Eq (HSMul.hSMul a f) Bot.bot) (Eq f Bot.bot)","decl":"@[to_additive (attr := simp)]\ntheorem smul_filter_eq_bot_iff : a • f = ⊥ ↔ f = ⊥ :=\n  map_eq_bot_iff\n\n"}
{"name":"Filter.smul_filter_neBot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf : Filter β\na : α\n⊢ Iff (HSMul.hSMul a f).NeBot f.NeBot","decl":"@[to_additive (attr := simp)]\ntheorem smul_filter_neBot_iff : (a • f).NeBot ↔ f.NeBot :=\n  map_neBot_iff _\n\n"}
{"name":"Filter.vadd_filter_neBot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf : Filter β\na : α\n⊢ Iff (HVAdd.hVAdd a f).NeBot f.NeBot","decl":"@[to_additive (attr := simp)]\ntheorem smul_filter_neBot_iff : (a • f).NeBot ↔ f.NeBot :=\n  map_neBot_iff _\n\n"}
{"name":"Filter.NeBot.smul_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf : Filter β\na : α\na✝ : f.NeBot\n⊢ (HSMul.hSMul a f).NeBot","decl":"@[to_additive]\ntheorem NeBot.smul_filter : f.NeBot → (a • f).NeBot := fun h => h.map _\n\n"}
{"name":"Filter.NeBot.vadd_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf : Filter β\na : α\na✝ : f.NeBot\n⊢ (HVAdd.hVAdd a f).NeBot","decl":"@[to_additive]\ntheorem NeBot.smul_filter : f.NeBot → (a • f).NeBot := fun h => h.map _\n\n"}
{"name":"Filter.NeBot.of_vadd_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf : Filter β\na : α\na✝ : (HVAdd.hVAdd a f).NeBot\n⊢ f.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_smul_filter : (a • f).NeBot → f.NeBot :=\n  NeBot.of_map\n\n"}
{"name":"Filter.NeBot.of_smul_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf : Filter β\na : α\na✝ : (HSMul.hSMul a f).NeBot\n⊢ f.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_smul_filter : (a • f).NeBot → f.NeBot :=\n  NeBot.of_map\n\n"}
{"name":"Filter.vadd_filter.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VAdd α β\nf : Filter β\na : α\ninst✝ : f.NeBot\n⊢ (HVAdd.hVAdd a f).NeBot","decl":"@[to_additive vadd_filter.instNeBot]\nlemma smul_filter.instNeBot [NeBot f] : NeBot (a • f) := .smul_filter ‹_›\n\n"}
{"name":"Filter.smul_filter.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SMul α β\nf : Filter β\na : α\ninst✝ : f.NeBot\n⊢ (HSMul.hSMul a f).NeBot","decl":"@[to_additive vadd_filter.instNeBot]\nlemma smul_filter.instNeBot [NeBot f] : NeBot (a • f) := .smul_filter ‹_›\n\n"}
{"name":"Filter.vadd_filter_le_vadd_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nf₁ f₂ : Filter β\na : α\nhf : LE.le f₁ f₂\n⊢ LE.le (HVAdd.hVAdd a f₁) (HVAdd.hVAdd a f₂)","decl":"@[to_additive]\ntheorem smul_filter_le_smul_filter (hf : f₁ ≤ f₂) : a • f₁ ≤ a • f₂ :=\n  map_mono hf\n\n"}
{"name":"Filter.smul_filter_le_smul_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nf₁ f₂ : Filter β\na : α\nhf : LE.le f₁ f₂\n⊢ LE.le (HSMul.hSMul a f₁) (HSMul.hSMul a f₂)","decl":"@[to_additive]\ntheorem smul_filter_le_smul_filter (hf : f₁ ≤ f₂) : a • f₁ ≤ a • f₂ :=\n  map_mono hf\n\n"}
{"name":"Filter.covariant_vadd_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\n⊢ CovariantClass α (Filter β) (fun x1 x2 => HVAdd.hVAdd x1 x2) fun x1 x2 => LE.le x1 x2","decl":"@[to_additive]\ninstance covariant_smul_filter : CovariantClass α (Filter β) (· • ·) (· ≤ ·) :=\n  ⟨fun _ => @map_mono β β _⟩\n\n"}
{"name":"Filter.covariant_smul_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\n⊢ CovariantClass α (Filter β) (fun x1 x2 => HSMul.hSMul x1 x2) fun x1 x2 => LE.le x1 x2","decl":"@[to_additive]\ninstance covariant_smul_filter : CovariantClass α (Filter β) (· • ·) (· ≤ ·) :=\n  ⟨fun _ => @map_mono β β _⟩\n\n"}
{"name":"Filter.vaddCommClass_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : VAdd α γ\ninst✝¹ : VAdd β γ\ninst✝ : VAddCommClass α β γ\n⊢ VAddCommClass α β (Filter γ)","decl":"@[to_additive]\ninstance smulCommClass_filter [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass α β (Filter γ) :=\n  ⟨fun _ _ _ => map_comm (funext <| smul_comm _ _) _⟩\n\n"}
{"name":"Filter.smulCommClass_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : SMul α γ\ninst✝¹ : SMul β γ\ninst✝ : SMulCommClass α β γ\n⊢ SMulCommClass α β (Filter γ)","decl":"@[to_additive]\ninstance smulCommClass_filter [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass α β (Filter γ) :=\n  ⟨fun _ _ _ => map_comm (funext <| smul_comm _ _) _⟩\n\n"}
{"name":"Filter.smulCommClass_filter'","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : SMul α γ\ninst✝¹ : SMul β γ\ninst✝ : SMulCommClass α β γ\n⊢ SMulCommClass α (Filter β) (Filter γ)","decl":"@[to_additive]\ninstance smulCommClass_filter' [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass α (Filter β) (Filter γ) :=\n  ⟨fun a _ _ => map_map₂_distrib_right <| smul_comm a⟩\n\n"}
{"name":"Filter.vaddCommClass_filter'","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : VAdd α γ\ninst✝¹ : VAdd β γ\ninst✝ : VAddCommClass α β γ\n⊢ VAddCommClass α (Filter β) (Filter γ)","decl":"@[to_additive]\ninstance smulCommClass_filter' [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass α (Filter β) (Filter γ) :=\n  ⟨fun a _ _ => map_map₂_distrib_right <| smul_comm a⟩\n\n"}
{"name":"Filter.smulCommClass_filter''","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : SMul α γ\ninst✝¹ : SMul β γ\ninst✝ : SMulCommClass α β γ\n⊢ SMulCommClass (Filter α) β (Filter γ)","decl":"@[to_additive]\ninstance smulCommClass_filter'' [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass (Filter α) β (Filter γ) :=\n  haveI := SMulCommClass.symm α β γ\n  SMulCommClass.symm _ _ _\n\n"}
{"name":"Filter.vaddCommClass_filter''","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : VAdd α γ\ninst✝¹ : VAdd β γ\ninst✝ : VAddCommClass α β γ\n⊢ VAddCommClass (Filter α) β (Filter γ)","decl":"@[to_additive]\ninstance smulCommClass_filter'' [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass (Filter α) β (Filter γ) :=\n  haveI := SMulCommClass.symm α β γ\n  SMulCommClass.symm _ _ _\n\n"}
{"name":"Filter.vaddCommClass","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : VAdd α γ\ninst✝¹ : VAdd β γ\ninst✝ : VAddCommClass α β γ\n⊢ VAddCommClass (Filter α) (Filter β) (Filter γ)","decl":"@[to_additive]\ninstance smulCommClass [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass (Filter α) (Filter β) (Filter γ) :=\n  ⟨fun _ _ _ => map₂_left_comm smul_comm⟩\n\n"}
{"name":"Filter.smulCommClass","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : SMul α γ\ninst✝¹ : SMul β γ\ninst✝ : SMulCommClass α β γ\n⊢ SMulCommClass (Filter α) (Filter β) (Filter γ)","decl":"@[to_additive]\ninstance smulCommClass [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass (Filter α) (Filter β) (Filter γ) :=\n  ⟨fun _ _ _ => map₂_left_comm smul_comm⟩\n\n"}
{"name":"Filter.isScalarTower","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : SMul α β\ninst✝² : SMul α γ\ninst✝¹ : SMul β γ\ninst✝ : IsScalarTower α β γ\n⊢ IsScalarTower α β (Filter γ)","decl":"@[to_additive vaddAssocClass]\ninstance isScalarTower [SMul α β] [SMul α γ] [SMul β γ] [IsScalarTower α β γ] :\n    IsScalarTower α β (Filter γ) :=\n  ⟨fun a b f => by simp only [← Filter.map_smul, map_map, smul_assoc]; rfl⟩\n\n"}
{"name":"Filter.vaddAssocClass","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : VAdd α β\ninst✝² : VAdd α γ\ninst✝¹ : VAdd β γ\ninst✝ : VAddAssocClass α β γ\n⊢ VAddAssocClass α β (Filter γ)","decl":"@[to_additive vaddAssocClass]\ninstance isScalarTower [SMul α β] [SMul α γ] [SMul β γ] [IsScalarTower α β γ] :\n    IsScalarTower α β (Filter γ) :=\n  ⟨fun a b f => by simp only [← Filter.map_smul, map_map, smul_assoc]; rfl⟩\n\n"}
{"name":"Filter.vaddAssocClass'","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : VAdd α β\ninst✝² : VAdd α γ\ninst✝¹ : VAdd β γ\ninst✝ : VAddAssocClass α β γ\n⊢ VAddAssocClass α (Filter β) (Filter γ)","decl":"@[to_additive vaddAssocClass']\ninstance isScalarTower' [SMul α β] [SMul α γ] [SMul β γ] [IsScalarTower α β γ] :\n    IsScalarTower α (Filter β) (Filter γ) :=\n  ⟨fun a f g => by\n    refine (map_map₂_distrib_left fun _ _ => ?_).symm\n    exact (smul_assoc a _ _).symm⟩\n\n"}
{"name":"Filter.isScalarTower'","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : SMul α β\ninst✝² : SMul α γ\ninst✝¹ : SMul β γ\ninst✝ : IsScalarTower α β γ\n⊢ IsScalarTower α (Filter β) (Filter γ)","decl":"@[to_additive vaddAssocClass']\ninstance isScalarTower' [SMul α β] [SMul α γ] [SMul β γ] [IsScalarTower α β γ] :\n    IsScalarTower α (Filter β) (Filter γ) :=\n  ⟨fun a f g => by\n    refine (map_map₂_distrib_left fun _ _ => ?_).symm\n    exact (smul_assoc a _ _).symm⟩\n\n"}
{"name":"Filter.isScalarTower''","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : SMul α β\ninst✝² : SMul α γ\ninst✝¹ : SMul β γ\ninst✝ : IsScalarTower α β γ\n⊢ IsScalarTower (Filter α) (Filter β) (Filter γ)","decl":"@[to_additive vaddAssocClass'']\ninstance isScalarTower'' [SMul α β] [SMul α γ] [SMul β γ] [IsScalarTower α β γ] :\n    IsScalarTower (Filter α) (Filter β) (Filter γ) :=\n  ⟨fun _ _ _ => map₂_assoc smul_assoc⟩\n\n"}
{"name":"Filter.vaddAssocClass''","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : VAdd α β\ninst✝² : VAdd α γ\ninst✝¹ : VAdd β γ\ninst✝ : VAddAssocClass α β γ\n⊢ VAddAssocClass (Filter α) (Filter β) (Filter γ)","decl":"@[to_additive vaddAssocClass'']\ninstance isScalarTower'' [SMul α β] [SMul α γ] [SMul β γ] [IsScalarTower α β γ] :\n    IsScalarTower (Filter α) (Filter β) (Filter γ) :=\n  ⟨fun _ _ _ => map₂_assoc smul_assoc⟩\n\n"}
{"name":"Filter.isCentralScalar","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : SMul α β\ninst✝¹ : SMul (MulOpposite α) β\ninst✝ : IsCentralScalar α β\n⊢ IsCentralScalar α (Filter β)","decl":"@[to_additive]\ninstance isCentralScalar [SMul α β] [SMul αᵐᵒᵖ β] [IsCentralScalar α β] :\n    IsCentralScalar α (Filter β) :=\n  ⟨fun _ f => (congr_arg fun m => map m f) <| funext fun _ => op_smul_eq_smul _ _⟩\n\n"}
{"name":"Filter.isCentralVAdd","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : VAdd α β\ninst✝¹ : VAdd (AddOpposite α) β\ninst✝ : IsCentralVAdd α β\n⊢ IsCentralVAdd α (Filter β)","decl":"@[to_additive]\ninstance isCentralScalar [SMul α β] [SMul αᵐᵒᵖ β] [IsCentralScalar α β] :\n    IsCentralScalar α (Filter β) :=\n  ⟨fun _ f => (congr_arg fun m => map m f) <| funext fun _ => op_smul_eq_smul _ _⟩\n\n"}
{"name":"Filter.NeBot.smul_zero_nonneg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Zero α\ninst✝¹ : Zero β\ninst✝ : SMulWithZero α β\nf : Filter α\nhf : f.NeBot\n⊢ LE.le 0 (HSMul.hSMul f 0)","decl":"theorem NeBot.smul_zero_nonneg (hf : f.NeBot) : 0 ≤ f • (0 : Filter β) :=\n  le_smul_iff.2 fun _ h₁ _ h₂ =>\n    let ⟨_, ha⟩ := hf.nonempty_of_mem h₁\n    ⟨_, ha, _, h₂, smul_zero _⟩\n\n"}
{"name":"Filter.NeBot.zero_smul_nonneg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Zero α\ninst✝¹ : Zero β\ninst✝ : SMulWithZero α β\ng : Filter β\nhg : g.NeBot\n⊢ LE.le 0 (HSMul.hSMul 0 g)","decl":"theorem NeBot.zero_smul_nonneg (hg : g.NeBot) : 0 ≤ (0 : Filter α) • g :=\n  le_smul_iff.2 fun _ h₁ _ h₂ =>\n    let ⟨_, hb⟩ := hg.nonempty_of_mem h₂\n    ⟨_, h₁, _, hb, zero_smul _ _⟩\n\n"}
{"name":"Filter.zero_smul_filter_nonpos","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Zero α\ninst✝¹ : Zero β\ninst✝ : SMulWithZero α β\ng : Filter β\n⊢ LE.le (HSMul.hSMul 0 g) 0","decl":"theorem zero_smul_filter_nonpos : (0 : α) • g ≤ 0 := by\n  refine fun s hs => mem_smul_filter.2 ?_\n  convert @univ_mem _ g\n  refine eq_univ_iff_forall.2 fun a => ?_\n  rwa [mem_preimage, zero_smul]\n\n"}
{"name":"Filter.zero_smul_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Zero α\ninst✝¹ : Zero β\ninst✝ : SMulWithZero α β\ng : Filter β\nhg : g.NeBot\n⊢ Eq (HSMul.hSMul 0 g) 0","decl":"theorem zero_smul_filter (hg : g.NeBot) : (0 : α) • g = 0 :=\n  zero_smul_filter_nonpos.antisymm <|\n    le_map_iff.2 fun s hs => by\n      simp_rw [zero_smul, (hg.nonempty_of_mem hs).image_const]\n      exact zero_mem_zero\n\n"}
