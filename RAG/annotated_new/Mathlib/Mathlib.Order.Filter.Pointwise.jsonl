{"name":"Filter.mem_zero","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Zero Î±\ns : Set Î±\nâŠ¢ Iff (Membership.mem 0 s) (Membership.mem s 0)","decl":"@[to_additive (attr := simp)]\ntheorem mem_one : s âˆˆ (1 : Filter Î±) â†” (1 : Î±) âˆˆ s :=\n  mem_pure\n\n"}
{"name":"Filter.mem_one","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : One Î±\ns : Set Î±\nâŠ¢ Iff (Membership.mem 1 s) (Membership.mem s 1)","decl":"@[to_additive (attr := simp)]\ntheorem mem_one : s âˆˆ (1 : Filter Î±) â†” (1 : Î±) âˆˆ s :=\n  mem_pure\n\n"}
{"name":"Filter.one_mem_one","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : One Î±\nâŠ¢ Membership.mem 1 1","decl":"@[to_additive]\ntheorem one_mem_one : (1 : Set Î±) âˆˆ (1 : Filter Î±) :=\n  mem_pure.2 Set.one_mem_one\n\n"}
{"name":"Filter.zero_mem_zero","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Zero Î±\nâŠ¢ Membership.mem 0 0","decl":"@[to_additive]\ntheorem one_mem_one : (1 : Set Î±) âˆˆ (1 : Filter Î±) :=\n  mem_pure.2 Set.one_mem_one\n\n"}
{"name":"Filter.pure_zero","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Zero Î±\nâŠ¢ Eq (Pure.pure 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem pure_one : pure 1 = (1 : Filter Î±) :=\n  rfl\n\n"}
{"name":"Filter.pure_one","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : One Î±\nâŠ¢ Eq (Pure.pure 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem pure_one : pure 1 = (1 : Filter Î±) :=\n  rfl\n\n"}
{"name":"Filter.one_prod","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : One Î±\nl : Filter Î²\nâŠ¢ Eq (SProd.sprod 1 l) (Filter.map (fun x => { fst := 1, snd := x }) l)","decl":"@[to_additive (attr := simp) zero_prod]\ntheorem one_prod {l : Filter Î²} : (1 : Filter Î±) Ã—Ë¢ l = map (1, Â·) l := pure_prod\n\n"}
{"name":"Filter.zero_prod","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : Zero Î±\nl : Filter Î²\nâŠ¢ Eq (SProd.sprod 0 l) (Filter.map (fun x => { fst := 0, snd := x }) l)","decl":"@[to_additive (attr := simp) zero_prod]\ntheorem one_prod {l : Filter Î²} : (1 : Filter Î±) Ã—Ë¢ l = map (1, Â·) l := pure_prod\n\n"}
{"name":"Filter.prod_zero","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : Zero Î±\nl : Filter Î²\nâŠ¢ Eq (SProd.sprod l 0) (Filter.map (fun x => { fst := x, snd := 0 }) l)","decl":"@[to_additive (attr := simp) prod_zero]\ntheorem prod_one {l : Filter Î²} : l Ã—Ë¢ (1 : Filter Î±) = map (Â·, 1) l := prod_pure\n\n"}
{"name":"Filter.prod_one","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : One Î±\nl : Filter Î²\nâŠ¢ Eq (SProd.sprod l 1) (Filter.map (fun x => { fst := x, snd := 1 }) l)","decl":"@[to_additive (attr := simp) prod_zero]\ntheorem prod_one {l : Filter Î²} : l Ã—Ë¢ (1 : Filter Î±) = map (Â·, 1) l := prod_pure\n\n"}
{"name":"Filter.principal_zero","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Zero Î±\nâŠ¢ Eq (Filter.principal 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem principal_one : ğ“Ÿ 1 = (1 : Filter Î±) :=\n  principal_singleton _\n\n"}
{"name":"Filter.principal_one","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : One Î±\nâŠ¢ Eq (Filter.principal 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem principal_one : ğ“Ÿ 1 = (1 : Filter Î±) :=\n  principal_singleton _\n\n"}
{"name":"Filter.one_neBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : One Î±\nâŠ¢ Filter.NeBot 1","decl":"@[to_additive]\ntheorem one_neBot : (1 : Filter Î±).NeBot :=\n  Filter.pure_neBot\n\n"}
{"name":"Filter.zero_neBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Zero Î±\nâŠ¢ Filter.NeBot 0","decl":"@[to_additive]\ntheorem one_neBot : (1 : Filter Î±).NeBot :=\n  Filter.pure_neBot\n\n"}
{"name":"Filter.map_zero'","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : Zero Î±\nf : Î± â†’ Î²\nâŠ¢ Eq (Filter.map f 0) (Pure.pure (f 0))","decl":"@[to_additive (attr := simp)]\nprotected theorem map_one' (f : Î± â†’ Î²) : (1 : Filter Î±).map f = pure (f 1) :=\n  rfl\n\n"}
{"name":"Filter.map_one'","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : One Î±\nf : Î± â†’ Î²\nâŠ¢ Eq (Filter.map f 1) (Pure.pure (f 1))","decl":"@[to_additive (attr := simp)]\nprotected theorem map_one' (f : Î± â†’ Î²) : (1 : Filter Î±).map f = pure (f 1) :=\n  rfl\n\n"}
{"name":"Filter.nonpos_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Zero Î±\nf : Filter Î±\nâŠ¢ Iff (LE.le f 0) (Membership.mem f 0)","decl":"@[to_additive (attr := simp)]\ntheorem le_one_iff : f â‰¤ 1 â†” (1 : Set Î±) âˆˆ f :=\n  le_pure_iff\n\n"}
{"name":"Filter.le_one_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : One Î±\nf : Filter Î±\nâŠ¢ Iff (LE.le f 1) (Membership.mem f 1)","decl":"@[to_additive (attr := simp)]\ntheorem le_one_iff : f â‰¤ 1 â†” (1 : Set Î±) âˆˆ f :=\n  le_pure_iff\n\n"}
{"name":"Filter.NeBot.nonpos_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Zero Î±\nf : Filter Î±\nh : f.NeBot\nâŠ¢ Iff (LE.le f 0) (Eq f 0)","decl":"@[to_additive]\nprotected theorem NeBot.le_one_iff (h : f.NeBot) : f â‰¤ 1 â†” f = 1 :=\n  h.le_pure_iff\n\n"}
{"name":"Filter.NeBot.le_one_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : One Î±\nf : Filter Î±\nh : f.NeBot\nâŠ¢ Iff (LE.le f 1) (Eq f 1)","decl":"@[to_additive]\nprotected theorem NeBot.le_one_iff (h : f.NeBot) : f â‰¤ 1 â†” f = 1 :=\n  h.le_pure_iff\n\n"}
{"name":"Filter.eventually_zero","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Zero Î±\np : Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => p x) 0) (p 0)","decl":"@[to_additive (attr := simp)]\ntheorem eventually_one {p : Î± â†’ Prop} : (âˆ€á¶  x in 1, p x) â†” p 1 :=\n  eventually_pure\n\n"}
{"name":"Filter.eventually_one","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : One Î±\np : Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => p x) 1) (p 1)","decl":"@[to_additive (attr := simp)]\ntheorem eventually_one {p : Î± â†’ Prop} : (âˆ€á¶  x in 1, p x) â†” p 1 :=\n  eventually_pure\n\n"}
{"name":"Filter.tendsto_one","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : One Î±\na : Filter Î²\nf : Î² â†’ Î±\nâŠ¢ Iff (Filter.Tendsto f a 1) (Filter.Eventually (fun x => Eq (f x) 1) a)","decl":"@[to_additive (attr := simp)]\ntheorem tendsto_one {a : Filter Î²} {f : Î² â†’ Î±} : Tendsto f a 1 â†” âˆ€á¶  x in a, f x = 1 :=\n  tendsto_pure\n\n"}
{"name":"Filter.tendsto_zero","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : Zero Î±\na : Filter Î²\nf : Î² â†’ Î±\nâŠ¢ Iff (Filter.Tendsto f a 0) (Filter.Eventually (fun x => Eq (f x) 0) a)","decl":"@[to_additive (attr := simp)]\ntheorem tendsto_one {a : Filter Î²} {f : Î² â†’ Î±} : Tendsto f a 1 â†” âˆ€á¶  x in a, f x = 1 :=\n  tendsto_pure\n\n"}
{"name":"Filter.zero_prod_zero","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : Zero Î±\ninstâœ : Zero Î²\nâŠ¢ Eq (SProd.sprod 0 0) 0","decl":"@[to_additive zero_prod_zero]\ntheorem one_prod_one [One Î²] : (1 : Filter Î±) Ã—Ë¢ (1 : Filter Î²) = 1 :=\n  prod_pure_pure\n\n"}
{"name":"Filter.one_prod_one","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : One Î±\ninstâœ : One Î²\nâŠ¢ Eq (SProd.sprod 1 1) 1","decl":"@[to_additive zero_prod_zero]\ntheorem one_prod_one [One Î²] : (1 : Filter Î±) Ã—Ë¢ (1 : Filter Î²) = 1 :=\n  prod_pure_pure\n\n"}
{"name":"Filter.zero_sum_zero","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : Zero Î±\ninstâœ : Zero Î²\nâŠ¢ Eq (SProd.sprod 0 0) 0","decl":"@[deprecated (since := \"2024-08-16\")] alias zero_sum_zero := zero_prod_zero\n\n"}
{"name":"Filter.coe_pureOneHom","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : One Î±\nâŠ¢ Eq (â‡‘Filter.pureOneHom) Pure.pure","decl":"@[to_additive (attr := simp)]\ntheorem coe_pureOneHom : (pureOneHom : Î± â†’ Filter Î±) = pure :=\n  rfl\n\n"}
{"name":"Filter.coe_pureZeroHom","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Zero Î±\nâŠ¢ Eq (â‡‘Filter.pureZeroHom) Pure.pure","decl":"@[to_additive (attr := simp)]\ntheorem coe_pureOneHom : (pureOneHom : Î± â†’ Filter Î±) = pure :=\n  rfl\n\n"}
{"name":"Filter.pureOneHom_apply","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : One Î±\na : Î±\nâŠ¢ Eq (Filter.pureOneHom a) (Pure.pure a)","decl":"@[to_additive (attr := simp)]\ntheorem pureOneHom_apply (a : Î±) : pureOneHom a = pure a :=\n  rfl\n\n"}
{"name":"Filter.pureZeroHom_apply","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Zero Î±\na : Î±\nâŠ¢ Eq (Filter.pureZeroHom a) (Pure.pure a)","decl":"@[to_additive (attr := simp)]\ntheorem pureOneHom_apply (a : Î±) : pureOneHom a = pure a :=\n  rfl\n\n"}
{"name":"Filter.map_one","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : One Î±\ninstâœÂ² : One Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : OneHomClass F Î± Î²\nÏ† : F\nâŠ¢ Eq (Filter.map (â‡‘Ï†) 1) 1","decl":"@[to_additive]\nprotected theorem map_one [FunLike F Î± Î²] [OneHomClass F Î± Î²] (Ï† : F) : map Ï† 1 = 1 := by\n  simp\n\n"}
{"name":"Filter.map_zero","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : Zero Î±\ninstâœÂ² : Zero Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : ZeroHomClass F Î± Î²\nÏ† : F\nâŠ¢ Eq (Filter.map (â‡‘Ï†) 0) 0","decl":"@[to_additive]\nprotected theorem map_one [FunLike F Î± Î²] [OneHomClass F Î± Î²] (Ï† : F) : map Ï† 1 = 1 := by\n  simp\n\n"}
{"name":"Filter.map_neg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Neg Î±\nf : Filter Î±\nâŠ¢ Eq (Filter.map Neg.neg f) (Neg.neg f)","decl":"@[to_additive (attr := simp)]\nprotected theorem map_inv : f.map Inv.inv = fâ»Â¹ :=\n  rfl\n\n"}
{"name":"Filter.map_inv","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Inv Î±\nf : Filter Î±\nâŠ¢ Eq (Filter.map Inv.inv f) (Inv.inv f)","decl":"@[to_additive (attr := simp)]\nprotected theorem map_inv : f.map Inv.inv = fâ»Â¹ :=\n  rfl\n\n"}
{"name":"Filter.mem_neg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Neg Î±\nf : Filter Î±\ns : Set Î±\nâŠ¢ Iff (Membership.mem (Neg.neg f) s) (Membership.mem f (Set.preimage Neg.neg s))","decl":"@[to_additive]\ntheorem mem_inv : s âˆˆ fâ»Â¹ â†” Inv.inv â»Â¹' s âˆˆ f :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_inv","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Inv Î±\nf : Filter Î±\ns : Set Î±\nâŠ¢ Iff (Membership.mem (Inv.inv f) s) (Membership.mem f (Set.preimage Inv.inv s))","decl":"@[to_additive]\ntheorem mem_inv : s âˆˆ fâ»Â¹ â†” Inv.inv â»Â¹' s âˆˆ f :=\n  Iff.rfl\n\n"}
{"name":"Filter.neg_le_neg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Neg Î±\nf g : Filter Î±\nhf : LE.le f g\nâŠ¢ LE.le (Neg.neg f) (Neg.neg g)","decl":"@[to_additive]\nprotected theorem inv_le_inv (hf : f â‰¤ g) : fâ»Â¹ â‰¤ gâ»Â¹ :=\n  map_mono hf\n\n"}
{"name":"Filter.inv_le_inv","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Inv Î±\nf g : Filter Î±\nhf : LE.le f g\nâŠ¢ LE.le (Inv.inv f) (Inv.inv g)","decl":"@[to_additive]\nprotected theorem inv_le_inv (hf : f â‰¤ g) : fâ»Â¹ â‰¤ gâ»Â¹ :=\n  map_mono hf\n\n"}
{"name":"Filter.inv_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Inv Î±\na : Î±\nâŠ¢ Eq (Inv.inv (Pure.pure a)) (Pure.pure (Inv.inv a))","decl":"@[to_additive (attr := simp)]\ntheorem inv_pure : (pure a : Filter Î±)â»Â¹ = pure aâ»Â¹ :=\n  rfl\n\n"}
{"name":"Filter.neg_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Neg Î±\na : Î±\nâŠ¢ Eq (Neg.neg (Pure.pure a)) (Pure.pure (Neg.neg a))","decl":"@[to_additive (attr := simp)]\ntheorem inv_pure : (pure a : Filter Î±)â»Â¹ = pure aâ»Â¹ :=\n  rfl\n\n"}
{"name":"Filter.inv_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Inv Î±\nf : Filter Î±\nâŠ¢ Iff (Eq (Inv.inv f) Bot.bot) (Eq f Bot.bot)","decl":"@[to_additive (attr := simp)]\ntheorem inv_eq_bot_iff : fâ»Â¹ = âŠ¥ â†” f = âŠ¥ :=\n  map_eq_bot_iff\n\n"}
{"name":"Filter.neg_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Neg Î±\nf : Filter Î±\nâŠ¢ Iff (Eq (Neg.neg f) Bot.bot) (Eq f Bot.bot)","decl":"@[to_additive (attr := simp)]\ntheorem inv_eq_bot_iff : fâ»Â¹ = âŠ¥ â†” f = âŠ¥ :=\n  map_eq_bot_iff\n\n"}
{"name":"Filter.neBot_neg_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Neg Î±\nf : Filter Î±\nâŠ¢ Iff (Neg.neg f).NeBot f.NeBot","decl":"@[to_additive (attr := simp)]\ntheorem neBot_inv_iff : fâ»Â¹.NeBot â†” NeBot f :=\n  map_neBot_iff _\n\n"}
{"name":"Filter.neBot_inv_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Inv Î±\nf : Filter Î±\nâŠ¢ Iff (Inv.inv f).NeBot f.NeBot","decl":"@[to_additive (attr := simp)]\ntheorem neBot_inv_iff : fâ»Â¹.NeBot â†” NeBot f :=\n  map_neBot_iff _\n\n"}
{"name":"Filter.NeBot.inv","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Inv Î±\nf : Filter Î±\naâœ : f.NeBot\nâŠ¢ (Inv.inv f).NeBot","decl":"@[to_additive]\nprotected theorem NeBot.inv : f.NeBot â†’ fâ»Â¹.NeBot := fun h => h.map _\n\n"}
{"name":"Filter.NeBot.neg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Neg Î±\nf : Filter Î±\naâœ : f.NeBot\nâŠ¢ (Neg.neg f).NeBot","decl":"@[to_additive]\nprotected theorem NeBot.inv : f.NeBot â†’ fâ»Â¹.NeBot := fun h => h.map _\n\n"}
{"name":"Filter.inv.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœÂ¹ : Inv Î±\nf : Filter Î±\ninstâœ : f.NeBot\nâŠ¢ (Inv.inv f).NeBot","decl":"@[to_additive neg.instNeBot]\nlemma inv.instNeBot [NeBot f] : NeBot fâ»Â¹ := .inv â€¹_â€º\n\n"}
{"name":"Filter.neg.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœÂ¹ : Neg Î±\nf : Filter Î±\ninstâœ : f.NeBot\nâŠ¢ (Neg.neg f).NeBot","decl":"@[to_additive neg.instNeBot]\nlemma inv.instNeBot [NeBot f] : NeBot fâ»Â¹ := .inv â€¹_â€º\n\n"}
{"name":"Filter.comap_neg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : InvolutiveNeg Î±\nf : Filter Î±\nâŠ¢ Eq (Filter.comap Neg.neg f) (Neg.neg f)","decl":"@[to_additive (attr := simp)]\nprotected lemma comap_inv : comap Inv.inv f = fâ»Â¹ :=\n  .symm <| map_eq_comap_of_inverse (inv_comp_inv _) (inv_comp_inv _)\n\n"}
{"name":"Filter.comap_inv","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : InvolutiveInv Î±\nf : Filter Î±\nâŠ¢ Eq (Filter.comap Inv.inv f) (Inv.inv f)","decl":"@[to_additive (attr := simp)]\nprotected lemma comap_inv : comap Inv.inv f = fâ»Â¹ :=\n  .symm <| map_eq_comap_of_inverse (inv_comp_inv _) (inv_comp_inv _)\n\n"}
{"name":"Filter.neg_mem_neg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : InvolutiveNeg Î±\nf : Filter Î±\ns : Set Î±\nhs : Membership.mem f s\nâŠ¢ Membership.mem (Neg.neg f) (Neg.neg s)","decl":"@[to_additive]\ntheorem inv_mem_inv (hs : s âˆˆ f) : sâ»Â¹ âˆˆ fâ»Â¹ := by rwa [mem_inv, inv_preimage, inv_inv]\n\n"}
{"name":"Filter.inv_mem_inv","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : InvolutiveInv Î±\nf : Filter Î±\ns : Set Î±\nhs : Membership.mem f s\nâŠ¢ Membership.mem (Inv.inv f) (Inv.inv s)","decl":"@[to_additive]\ntheorem inv_mem_inv (hs : s âˆˆ f) : sâ»Â¹ âˆˆ fâ»Â¹ := by rwa [mem_inv, inv_preimage, inv_inv]\n\n"}
{"name":"Filter.inv_le_inv_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : InvolutiveInv Î±\nf g : Filter Î±\nâŠ¢ Iff (LE.le (Inv.inv f) (Inv.inv g)) (LE.le f g)","decl":"@[to_additive (attr := simp)]\nprotected theorem inv_le_inv_iff : fâ»Â¹ â‰¤ gâ»Â¹ â†” f â‰¤ g :=\n  âŸ¨fun h => inv_inv f â–¸ inv_inv g â–¸ Filter.inv_le_inv h, Filter.inv_le_invâŸ©\n\n"}
{"name":"Filter.neg_le_neg_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : InvolutiveNeg Î±\nf g : Filter Î±\nâŠ¢ Iff (LE.le (Neg.neg f) (Neg.neg g)) (LE.le f g)","decl":"@[to_additive (attr := simp)]\nprotected theorem inv_le_inv_iff : fâ»Â¹ â‰¤ gâ»Â¹ â†” f â‰¤ g :=\n  âŸ¨fun h => inv_inv f â–¸ inv_inv g â–¸ Filter.inv_le_inv h, Filter.inv_le_invâŸ©\n\n"}
{"name":"Filter.inv_le_iff_le_inv","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : InvolutiveInv Î±\nf g : Filter Î±\nâŠ¢ Iff (LE.le (Inv.inv f) g) (LE.le f (Inv.inv g))","decl":"@[to_additive]\ntheorem inv_le_iff_le_inv : fâ»Â¹ â‰¤ g â†” f â‰¤ gâ»Â¹ := by rw [â† Filter.inv_le_inv_iff, inv_inv]\n\n"}
{"name":"Filter.neg_le_iff_le_neg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : InvolutiveNeg Î±\nf g : Filter Î±\nâŠ¢ Iff (LE.le (Neg.neg f) g) (LE.le f (Neg.neg g))","decl":"@[to_additive]\ntheorem inv_le_iff_le_inv : fâ»Â¹ â‰¤ g â†” f â‰¤ gâ»Â¹ := by rw [â† Filter.inv_le_inv_iff, inv_inv]\n\n"}
{"name":"Filter.neg_le_self","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : InvolutiveNeg Î±\nf : Filter Î±\nâŠ¢ Iff (LE.le (Neg.neg f) f) (Eq (Neg.neg f) f)","decl":"@[to_additive (attr := simp)]\ntheorem inv_le_self : fâ»Â¹ â‰¤ f â†” fâ»Â¹ = f :=\n  âŸ¨fun h => h.antisymm <| inv_le_iff_le_inv.1 h, Eq.leâŸ©\n\n"}
{"name":"Filter.inv_le_self","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : InvolutiveInv Î±\nf : Filter Î±\nâŠ¢ Iff (LE.le (Inv.inv f) f) (Eq (Inv.inv f) f)","decl":"@[to_additive (attr := simp)]\ntheorem inv_le_self : fâ»Â¹ â‰¤ f â†” fâ»Â¹ = f :=\n  âŸ¨fun h => h.antisymm <| inv_le_iff_le_inv.1 h, Eq.leâŸ©\n\n"}
{"name":"Filter.inv_atTop","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"G : Type u_7\ninstâœ : OrderedCommGroup G\nâŠ¢ Eq (Inv.inv Filter.atTop) Filter.atBot","decl":"@[to_additive (attr := simp)]\nlemma inv_atTop {G : Type*} [OrderedCommGroup G] : (atTop : Filter G)â»Â¹ = atBot :=\n  (OrderIso.inv G).map_atTop\n\n"}
{"name":"Filter.neg_atTop","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"G : Type u_7\ninstâœ : OrderedAddCommGroup G\nâŠ¢ Eq (Neg.neg Filter.atTop) Filter.atBot","decl":"@[to_additive (attr := simp)]\nlemma inv_atTop {G : Type*} [OrderedCommGroup G] : (atTop : Filter G)â»Â¹ = atBot :=\n  (OrderIso.inv G).map_atTop\n\n"}
{"name":"Filter.mapâ‚‚_add","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Add Î±\nf g : Filter Î±\nâŠ¢ Eq (Filter.mapâ‚‚ (fun x1 x2 => HAdd.hAdd x1 x2) f g) (HAdd.hAdd f g)","decl":"@[to_additive (attr := simp)]\ntheorem mapâ‚‚_mul : mapâ‚‚ (Â· * Â·) f g = f * g :=\n  rfl\n\n"}
{"name":"Filter.mapâ‚‚_mul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Mul Î±\nf g : Filter Î±\nâŠ¢ Eq (Filter.mapâ‚‚ (fun x1 x2 => HMul.hMul x1 x2) f g) (HMul.hMul f g)","decl":"@[to_additive (attr := simp)]\ntheorem mapâ‚‚_mul : mapâ‚‚ (Â· * Â·) f g = f * g :=\n  rfl\n\n"}
{"name":"Filter.mem_mul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Mul Î±\nf g : Filter Î±\ns : Set Î±\nâŠ¢ Iff (Membership.mem (HMul.hMul f g) s) (Exists fun tâ‚ => And (Membership.mem f tâ‚) (Exists fun tâ‚‚ => And (Membership.mem g tâ‚‚) (HasSubset.Subset (HMul.hMul tâ‚ tâ‚‚) s)))","decl":"@[to_additive]\ntheorem mem_mul : s âˆˆ f * g â†” âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, tâ‚ * tâ‚‚ âŠ† s :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_add","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Add Î±\nf g : Filter Î±\ns : Set Î±\nâŠ¢ Iff (Membership.mem (HAdd.hAdd f g) s) (Exists fun tâ‚ => And (Membership.mem f tâ‚) (Exists fun tâ‚‚ => And (Membership.mem g tâ‚‚) (HasSubset.Subset (HAdd.hAdd tâ‚ tâ‚‚) s)))","decl":"@[to_additive]\ntheorem mem_mul : s âˆˆ f * g â†” âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, tâ‚ * tâ‚‚ âŠ† s :=\n  Iff.rfl\n\n"}
{"name":"Filter.add_mem_add","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Add Î±\nf g : Filter Î±\ns t : Set Î±\naâœÂ¹ : Membership.mem f s\naâœ : Membership.mem g t\nâŠ¢ Membership.mem (HAdd.hAdd f g) (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem mul_mem_mul : s âˆˆ f â†’ t âˆˆ g â†’ s * t âˆˆ f * g :=\n  image2_mem_mapâ‚‚\n\n"}
{"name":"Filter.mul_mem_mul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Mul Î±\nf g : Filter Î±\ns t : Set Î±\naâœÂ¹ : Membership.mem f s\naâœ : Membership.mem g t\nâŠ¢ Membership.mem (HMul.hMul f g) (HMul.hMul s t)","decl":"@[to_additive]\ntheorem mul_mem_mul : s âˆˆ f â†’ t âˆˆ g â†’ s * t âˆˆ f * g :=\n  image2_mem_mapâ‚‚\n\n"}
{"name":"Filter.bot_add","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Add Î±\ng : Filter Î±\nâŠ¢ Eq (HAdd.hAdd Bot.bot g) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem bot_mul : âŠ¥ * g = âŠ¥ :=\n  mapâ‚‚_bot_left\n\n"}
{"name":"Filter.bot_mul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Mul Î±\ng : Filter Î±\nâŠ¢ Eq (HMul.hMul Bot.bot g) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem bot_mul : âŠ¥ * g = âŠ¥ :=\n  mapâ‚‚_bot_left\n\n"}
{"name":"Filter.add_bot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Add Î±\nf : Filter Î±\nâŠ¢ Eq (HAdd.hAdd f Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem mul_bot : f * âŠ¥ = âŠ¥ :=\n  mapâ‚‚_bot_right\n\n"}
{"name":"Filter.mul_bot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Mul Î±\nf : Filter Î±\nâŠ¢ Eq (HMul.hMul f Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem mul_bot : f * âŠ¥ = âŠ¥ :=\n  mapâ‚‚_bot_right\n\n"}
{"name":"Filter.mul_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Mul Î±\nf g : Filter Î±\nâŠ¢ Iff (Eq (HMul.hMul f g) Bot.bot) (Or (Eq f Bot.bot) (Eq g Bot.bot))","decl":"@[to_additive (attr := simp)]\ntheorem mul_eq_bot_iff : f * g = âŠ¥ â†” f = âŠ¥ âˆ¨ g = âŠ¥ :=\n  mapâ‚‚_eq_bot_iff\n\n"}
{"name":"Filter.add_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Add Î±\nf g : Filter Î±\nâŠ¢ Iff (Eq (HAdd.hAdd f g) Bot.bot) (Or (Eq f Bot.bot) (Eq g Bot.bot))","decl":"@[to_additive (attr := simp)]\ntheorem mul_eq_bot_iff : f * g = âŠ¥ â†” f = âŠ¥ âˆ¨ g = âŠ¥ :=\n  mapâ‚‚_eq_bot_iff\n\n"}
{"name":"Filter.add_neBot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Add Î±\nf g : Filter Î±\nâŠ¢ Iff (HAdd.hAdd f g).NeBot (And f.NeBot g.NeBot)","decl":"@[to_additive (attr := simp)] -- TODO: make this a scoped instance in the `Pointwise` namespace\nlemma mul_neBot_iff : (f * g).NeBot â†” f.NeBot âˆ§ g.NeBot :=\n  mapâ‚‚_neBot_iff\n\n"}
{"name":"Filter.mul_neBot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Mul Î±\nf g : Filter Î±\nâŠ¢ Iff (HMul.hMul f g).NeBot (And f.NeBot g.NeBot)","decl":"@[to_additive (attr := simp)] -- TODO: make this a scoped instance in the `Pointwise` namespace\nlemma mul_neBot_iff : (f * g).NeBot â†” f.NeBot âˆ§ g.NeBot :=\n  mapâ‚‚_neBot_iff\n\n"}
{"name":"Filter.NeBot.mul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Mul Î±\nf g : Filter Î±\naâœÂ¹ : f.NeBot\naâœ : g.NeBot\nâŠ¢ (HMul.hMul f g).NeBot","decl":"@[to_additive]\nprotected theorem NeBot.mul : NeBot f â†’ NeBot g â†’ NeBot (f * g) :=\n  NeBot.mapâ‚‚\n\n"}
{"name":"Filter.NeBot.add","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Add Î±\nf g : Filter Î±\naâœÂ¹ : f.NeBot\naâœ : g.NeBot\nâŠ¢ (HAdd.hAdd f g).NeBot","decl":"@[to_additive]\nprotected theorem NeBot.mul : NeBot f â†’ NeBot g â†’ NeBot (f * g) :=\n  NeBot.mapâ‚‚\n\n"}
{"name":"Filter.NeBot.of_mul_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Mul Î±\nf g : Filter Î±\naâœ : (HMul.hMul f g).NeBot\nâŠ¢ f.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_mul_left : (f * g).NeBot â†’ f.NeBot :=\n  NeBot.of_mapâ‚‚_left\n\n"}
{"name":"Filter.NeBot.of_add_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Add Î±\nf g : Filter Î±\naâœ : (HAdd.hAdd f g).NeBot\nâŠ¢ f.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_mul_left : (f * g).NeBot â†’ f.NeBot :=\n  NeBot.of_mapâ‚‚_left\n\n"}
{"name":"Filter.NeBot.of_add_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Add Î±\nf g : Filter Î±\naâœ : (HAdd.hAdd f g).NeBot\nâŠ¢ g.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_mul_right : (f * g).NeBot â†’ g.NeBot :=\n  NeBot.of_mapâ‚‚_right\n\n"}
{"name":"Filter.NeBot.of_mul_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Mul Î±\nf g : Filter Î±\naâœ : (HMul.hMul f g).NeBot\nâŠ¢ g.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_mul_right : (f * g).NeBot â†’ g.NeBot :=\n  NeBot.of_mapâ‚‚_right\n\n"}
{"name":"Filter.add.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœÂ² : Add Î±\nf g : Filter Î±\ninstâœÂ¹ : f.NeBot\ninstâœ : g.NeBot\nâŠ¢ (HAdd.hAdd f g).NeBot","decl":"@[to_additive add.instNeBot]\nprotected lemma mul.instNeBot [NeBot f] [NeBot g] : NeBot (f * g) := .mul â€¹_â€º â€¹_â€º\n\n"}
{"name":"Filter.mul.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœÂ² : Mul Î±\nf g : Filter Î±\ninstâœÂ¹ : f.NeBot\ninstâœ : g.NeBot\nâŠ¢ (HMul.hMul f g).NeBot","decl":"@[to_additive add.instNeBot]\nprotected lemma mul.instNeBot [NeBot f] [NeBot g] : NeBot (f * g) := .mul â€¹_â€º â€¹_â€º\n\n"}
{"name":"Filter.pure_mul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Mul Î±\ng : Filter Î±\na : Î±\nâŠ¢ Eq (HMul.hMul (Pure.pure a) g) (Filter.map (fun x => HMul.hMul a x) g)","decl":"@[to_additive (attr := simp)]\ntheorem pure_mul : pure a * g = g.map (a * Â·) :=\n  mapâ‚‚_pure_left\n\n"}
{"name":"Filter.pure_add","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Add Î±\ng : Filter Î±\na : Î±\nâŠ¢ Eq (HAdd.hAdd (Pure.pure a) g) (Filter.map (fun x => HAdd.hAdd a x) g)","decl":"@[to_additive (attr := simp)]\ntheorem pure_mul : pure a * g = g.map (a * Â·) :=\n  mapâ‚‚_pure_left\n\n"}
{"name":"Filter.mul_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Mul Î±\nf : Filter Î±\nb : Î±\nâŠ¢ Eq (HMul.hMul f (Pure.pure b)) (Filter.map (fun x => HMul.hMul x b) f)","decl":"@[to_additive (attr := simp)]\ntheorem mul_pure : f * pure b = f.map (Â· * b) :=\n  mapâ‚‚_pure_right\n\n"}
{"name":"Filter.add_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Add Î±\nf : Filter Î±\nb : Î±\nâŠ¢ Eq (HAdd.hAdd f (Pure.pure b)) (Filter.map (fun x => HAdd.hAdd x b) f)","decl":"@[to_additive (attr := simp)]\ntheorem mul_pure : f * pure b = f.map (Â· * b) :=\n  mapâ‚‚_pure_right\n\n"}
{"name":"Filter.pure_mul_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Mul Î±\na b : Î±\nâŠ¢ Eq (HMul.hMul (Pure.pure a) (Pure.pure b)) (Pure.pure (HMul.hMul a b))","decl":"@[to_additive]\ntheorem pure_mul_pure : (pure a : Filter Î±) * pure b = pure (a * b) := by simp\n\n"}
{"name":"Filter.pure_add_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Add Î±\na b : Î±\nâŠ¢ Eq (HAdd.hAdd (Pure.pure a) (Pure.pure b)) (Pure.pure (HAdd.hAdd a b))","decl":"@[to_additive]\ntheorem pure_mul_pure : (pure a : Filter Î±) * pure b = pure (a * b) := by simp\n\n"}
{"name":"Filter.le_mul_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Mul Î±\nf g h : Filter Î±\nâŠ¢ Iff (LE.le h (HMul.hMul f g)) (âˆ€ â¦ƒs : Set Î±â¦„, Membership.mem f s â†’ âˆ€ â¦ƒt : Set Î±â¦„, Membership.mem g t â†’ Membership.mem h (HMul.hMul s t))","decl":"@[to_additive (attr := simp)]\ntheorem le_mul_iff : h â‰¤ f * g â†” âˆ€ â¦ƒsâ¦„, s âˆˆ f â†’ âˆ€ â¦ƒtâ¦„, t âˆˆ g â†’ s * t âˆˆ h :=\n  le_mapâ‚‚_iff\n\n"}
{"name":"Filter.le_add_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Add Î±\nf g h : Filter Î±\nâŠ¢ Iff (LE.le h (HAdd.hAdd f g)) (âˆ€ â¦ƒs : Set Î±â¦„, Membership.mem f s â†’ âˆ€ â¦ƒt : Set Î±â¦„, Membership.mem g t â†’ Membership.mem h (HAdd.hAdd s t))","decl":"@[to_additive (attr := simp)]\ntheorem le_mul_iff : h â‰¤ f * g â†” âˆ€ â¦ƒsâ¦„, s âˆˆ f â†’ âˆ€ â¦ƒtâ¦„, t âˆˆ g â†’ s * t âˆˆ h :=\n  le_mapâ‚‚_iff\n\n"}
{"name":"Filter.addLeftMono","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Add Î±\nâŠ¢ AddLeftMono (Filter Î±)","decl":"@[to_additive]\ninstance mulLeftMono : MulLeftMono (Filter Î±) :=\n  âŸ¨fun _ _ _ => mapâ‚‚_mono_leftâŸ©\n\n"}
{"name":"Filter.mulLeftMono","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Mul Î±\nâŠ¢ MulLeftMono (Filter Î±)","decl":"@[to_additive]\ninstance mulLeftMono : MulLeftMono (Filter Î±) :=\n  âŸ¨fun _ _ _ => mapâ‚‚_mono_leftâŸ©\n\n"}
{"name":"Filter.addRightMono","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Add Î±\nâŠ¢ AddRightMono (Filter Î±)","decl":"@[to_additive]\ninstance mulRightMono : MulRightMono (Filter Î±) :=\n  âŸ¨fun _ _ _ => mapâ‚‚_mono_rightâŸ©\n\n"}
{"name":"Filter.mulRightMono","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Mul Î±\nâŠ¢ MulRightMono (Filter Î±)","decl":"@[to_additive]\ninstance mulRightMono : MulRightMono (Filter Î±) :=\n  âŸ¨fun _ _ _ => mapâ‚‚_mono_rightâŸ©\n\n"}
{"name":"Filter.map_mul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : Mul Î±\ninstâœÂ² : Mul Î²\nfâ‚ fâ‚‚ : Filter Î±\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : MulHomClass F Î± Î²\nm : F\nâŠ¢ Eq (Filter.map (â‡‘m) (HMul.hMul fâ‚ fâ‚‚)) (HMul.hMul (Filter.map (â‡‘m) fâ‚) (Filter.map (â‡‘m) fâ‚‚))","decl":"@[to_additive]\nprotected theorem map_mul [FunLike F Î± Î²] [MulHomClass F Î± Î²] (m : F) :\n    (fâ‚ * fâ‚‚).map m = fâ‚.map m * fâ‚‚.map m :=\n  map_mapâ‚‚_distrib <| map_mul m\n\n"}
{"name":"Filter.map_add","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : Add Î±\ninstâœÂ² : Add Î²\nfâ‚ fâ‚‚ : Filter Î±\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : AddHomClass F Î± Î²\nm : F\nâŠ¢ Eq (Filter.map (â‡‘m) (HAdd.hAdd fâ‚ fâ‚‚)) (HAdd.hAdd (Filter.map (â‡‘m) fâ‚) (Filter.map (â‡‘m) fâ‚‚))","decl":"@[to_additive]\nprotected theorem map_mul [FunLike F Î± Î²] [MulHomClass F Î± Î²] (m : F) :\n    (fâ‚ * fâ‚‚).map m = fâ‚.map m * fâ‚‚.map m :=\n  map_mapâ‚‚_distrib <| map_mul m\n\n"}
{"name":"Filter.coe_pureAddHom","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Add Î±\nâŠ¢ Eq (â‡‘Filter.pureAddHom) Pure.pure","decl":"@[to_additive (attr := simp)]\ntheorem coe_pureMulHom : (pureMulHom : Î± â†’ Filter Î±) = pure :=\n  rfl\n\n"}
{"name":"Filter.coe_pureMulHom","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Mul Î±\nâŠ¢ Eq (â‡‘Filter.pureMulHom) Pure.pure","decl":"@[to_additive (attr := simp)]\ntheorem coe_pureMulHom : (pureMulHom : Î± â†’ Filter Î±) = pure :=\n  rfl\n\n"}
{"name":"Filter.pureAddHom_apply","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Add Î±\na : Î±\nâŠ¢ Eq (Filter.pureAddHom a) (Pure.pure a)","decl":"@[to_additive (attr := simp)]\ntheorem pureMulHom_apply (a : Î±) : pureMulHom a = pure a :=\n  rfl\n\n"}
{"name":"Filter.pureMulHom_apply","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Mul Î±\na : Î±\nâŠ¢ Eq (Filter.pureMulHom a) (Pure.pure a)","decl":"@[to_additive (attr := simp)]\ntheorem pureMulHom_apply (a : Î±) : pureMulHom a = pure a :=\n  rfl\n\n"}
{"name":"Filter.mapâ‚‚_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Div Î±\nf g : Filter Î±\nâŠ¢ Eq (Filter.mapâ‚‚ (fun x1 x2 => HDiv.hDiv x1 x2) f g) (HDiv.hDiv f g)","decl":"@[to_additive (attr := simp)]\ntheorem mapâ‚‚_div : mapâ‚‚ (Â· / Â·) f g = f / g :=\n  rfl\n\n"}
{"name":"Filter.mapâ‚‚_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Sub Î±\nf g : Filter Î±\nâŠ¢ Eq (Filter.mapâ‚‚ (fun x1 x2 => HSub.hSub x1 x2) f g) (HSub.hSub f g)","decl":"@[to_additive (attr := simp)]\ntheorem mapâ‚‚_div : mapâ‚‚ (Â· / Â·) f g = f / g :=\n  rfl\n\n"}
{"name":"Filter.mem_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Sub Î±\nf g : Filter Î±\ns : Set Î±\nâŠ¢ Iff (Membership.mem (HSub.hSub f g) s) (Exists fun tâ‚ => And (Membership.mem f tâ‚) (Exists fun tâ‚‚ => And (Membership.mem g tâ‚‚) (HasSubset.Subset (HSub.hSub tâ‚ tâ‚‚) s)))","decl":"@[to_additive]\ntheorem mem_div : s âˆˆ f / g â†” âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, tâ‚ / tâ‚‚ âŠ† s :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Div Î±\nf g : Filter Î±\ns : Set Î±\nâŠ¢ Iff (Membership.mem (HDiv.hDiv f g) s) (Exists fun tâ‚ => And (Membership.mem f tâ‚) (Exists fun tâ‚‚ => And (Membership.mem g tâ‚‚) (HasSubset.Subset (HDiv.hDiv tâ‚ tâ‚‚) s)))","decl":"@[to_additive]\ntheorem mem_div : s âˆˆ f / g â†” âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, tâ‚ / tâ‚‚ âŠ† s :=\n  Iff.rfl\n\n"}
{"name":"Filter.sub_mem_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Sub Î±\nf g : Filter Î±\ns t : Set Î±\naâœÂ¹ : Membership.mem f s\naâœ : Membership.mem g t\nâŠ¢ Membership.mem (HSub.hSub f g) (HSub.hSub s t)","decl":"@[to_additive]\ntheorem div_mem_div : s âˆˆ f â†’ t âˆˆ g â†’ s / t âˆˆ f / g :=\n  image2_mem_mapâ‚‚\n\n"}
{"name":"Filter.div_mem_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Div Î±\nf g : Filter Î±\ns t : Set Î±\naâœÂ¹ : Membership.mem f s\naâœ : Membership.mem g t\nâŠ¢ Membership.mem (HDiv.hDiv f g) (HDiv.hDiv s t)","decl":"@[to_additive]\ntheorem div_mem_div : s âˆˆ f â†’ t âˆˆ g â†’ s / t âˆˆ f / g :=\n  image2_mem_mapâ‚‚\n\n"}
{"name":"Filter.bot_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Sub Î±\ng : Filter Î±\nâŠ¢ Eq (HSub.hSub Bot.bot g) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem bot_div : âŠ¥ / g = âŠ¥ :=\n  mapâ‚‚_bot_left\n\n"}
{"name":"Filter.bot_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Div Î±\ng : Filter Î±\nâŠ¢ Eq (HDiv.hDiv Bot.bot g) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem bot_div : âŠ¥ / g = âŠ¥ :=\n  mapâ‚‚_bot_left\n\n"}
{"name":"Filter.sub_bot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Sub Î±\nf : Filter Î±\nâŠ¢ Eq (HSub.hSub f Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem div_bot : f / âŠ¥ = âŠ¥ :=\n  mapâ‚‚_bot_right\n\n"}
{"name":"Filter.div_bot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Div Î±\nf : Filter Î±\nâŠ¢ Eq (HDiv.hDiv f Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem div_bot : f / âŠ¥ = âŠ¥ :=\n  mapâ‚‚_bot_right\n\n"}
{"name":"Filter.div_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Div Î±\nf g : Filter Î±\nâŠ¢ Iff (Eq (HDiv.hDiv f g) Bot.bot) (Or (Eq f Bot.bot) (Eq g Bot.bot))","decl":"@[to_additive (attr := simp)]\ntheorem div_eq_bot_iff : f / g = âŠ¥ â†” f = âŠ¥ âˆ¨ g = âŠ¥ :=\n  mapâ‚‚_eq_bot_iff\n\n"}
{"name":"Filter.sub_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Sub Î±\nf g : Filter Î±\nâŠ¢ Iff (Eq (HSub.hSub f g) Bot.bot) (Or (Eq f Bot.bot) (Eq g Bot.bot))","decl":"@[to_additive (attr := simp)]\ntheorem div_eq_bot_iff : f / g = âŠ¥ â†” f = âŠ¥ âˆ¨ g = âŠ¥ :=\n  mapâ‚‚_eq_bot_iff\n\n"}
{"name":"Filter.div_neBot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Div Î±\nf g : Filter Î±\nâŠ¢ Iff (HDiv.hDiv f g).NeBot (And f.NeBot g.NeBot)","decl":"@[to_additive (attr := simp)]\ntheorem div_neBot_iff : (f / g).NeBot â†” f.NeBot âˆ§ g.NeBot :=\n  mapâ‚‚_neBot_iff\n\n"}
{"name":"Filter.sub_neBot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Sub Î±\nf g : Filter Î±\nâŠ¢ Iff (HSub.hSub f g).NeBot (And f.NeBot g.NeBot)","decl":"@[to_additive (attr := simp)]\ntheorem div_neBot_iff : (f / g).NeBot â†” f.NeBot âˆ§ g.NeBot :=\n  mapâ‚‚_neBot_iff\n\n"}
{"name":"Filter.NeBot.sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Sub Î±\nf g : Filter Î±\naâœÂ¹ : f.NeBot\naâœ : g.NeBot\nâŠ¢ (HSub.hSub f g).NeBot","decl":"@[to_additive]\nprotected theorem NeBot.div : NeBot f â†’ NeBot g â†’ NeBot (f / g) :=\n  NeBot.mapâ‚‚\n\n"}
{"name":"Filter.NeBot.div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Div Î±\nf g : Filter Î±\naâœÂ¹ : f.NeBot\naâœ : g.NeBot\nâŠ¢ (HDiv.hDiv f g).NeBot","decl":"@[to_additive]\nprotected theorem NeBot.div : NeBot f â†’ NeBot g â†’ NeBot (f / g) :=\n  NeBot.mapâ‚‚\n\n"}
{"name":"Filter.NeBot.of_div_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Div Î±\nf g : Filter Î±\naâœ : (HDiv.hDiv f g).NeBot\nâŠ¢ f.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_div_left : (f / g).NeBot â†’ f.NeBot :=\n  NeBot.of_mapâ‚‚_left\n\n"}
{"name":"Filter.NeBot.of_sub_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Sub Î±\nf g : Filter Î±\naâœ : (HSub.hSub f g).NeBot\nâŠ¢ f.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_div_left : (f / g).NeBot â†’ f.NeBot :=\n  NeBot.of_mapâ‚‚_left\n\n"}
{"name":"Filter.NeBot.of_div_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Div Î±\nf g : Filter Î±\naâœ : (HDiv.hDiv f g).NeBot\nâŠ¢ g.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_div_right : (f / g).NeBot â†’ g.NeBot :=\n  NeBot.of_mapâ‚‚_right\n\n"}
{"name":"Filter.NeBot.of_sub_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Sub Î±\nf g : Filter Î±\naâœ : (HSub.hSub f g).NeBot\nâŠ¢ g.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_div_right : (f / g).NeBot â†’ g.NeBot :=\n  NeBot.of_mapâ‚‚_right\n\n"}
{"name":"Filter.div.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœÂ² : Div Î±\nf g : Filter Î±\ninstâœÂ¹ : f.NeBot\ninstâœ : g.NeBot\nâŠ¢ (HDiv.hDiv f g).NeBot","decl":"@[to_additive sub.instNeBot]\nlemma div.instNeBot [NeBot f] [NeBot g] : NeBot (f / g) := .div â€¹_â€º â€¹_â€º\n\n"}
{"name":"Filter.sub.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœÂ² : Sub Î±\nf g : Filter Î±\ninstâœÂ¹ : f.NeBot\ninstâœ : g.NeBot\nâŠ¢ (HSub.hSub f g).NeBot","decl":"@[to_additive sub.instNeBot]\nlemma div.instNeBot [NeBot f] [NeBot g] : NeBot (f / g) := .div â€¹_â€º â€¹_â€º\n\n"}
{"name":"Filter.pure_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Sub Î±\ng : Filter Î±\na : Î±\nâŠ¢ Eq (HSub.hSub (Pure.pure a) g) (Filter.map (fun x => HSub.hSub a x) g)","decl":"@[to_additive (attr := simp)]\ntheorem pure_div : pure a / g = g.map (a / Â·) :=\n  mapâ‚‚_pure_left\n\n"}
{"name":"Filter.pure_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Div Î±\ng : Filter Î±\na : Î±\nâŠ¢ Eq (HDiv.hDiv (Pure.pure a) g) (Filter.map (fun x => HDiv.hDiv a x) g)","decl":"@[to_additive (attr := simp)]\ntheorem pure_div : pure a / g = g.map (a / Â·) :=\n  mapâ‚‚_pure_left\n\n"}
{"name":"Filter.div_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Div Î±\nf : Filter Î±\nb : Î±\nâŠ¢ Eq (HDiv.hDiv f (Pure.pure b)) (Filter.map (fun x => HDiv.hDiv x b) f)","decl":"@[to_additive (attr := simp)]\ntheorem div_pure : f / pure b = f.map (Â· / b) :=\n  mapâ‚‚_pure_right\n\n"}
{"name":"Filter.sub_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Sub Î±\nf : Filter Î±\nb : Î±\nâŠ¢ Eq (HSub.hSub f (Pure.pure b)) (Filter.map (fun x => HSub.hSub x b) f)","decl":"@[to_additive (attr := simp)]\ntheorem div_pure : f / pure b = f.map (Â· / b) :=\n  mapâ‚‚_pure_right\n\n"}
{"name":"Filter.pure_sub_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Sub Î±\na b : Î±\nâŠ¢ Eq (HSub.hSub (Pure.pure a) (Pure.pure b)) (Pure.pure (HSub.hSub a b))","decl":"@[to_additive]\ntheorem pure_div_pure : (pure a : Filter Î±) / pure b = pure (a / b) := by simp\n\n"}
{"name":"Filter.pure_div_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Div Î±\na b : Î±\nâŠ¢ Eq (HDiv.hDiv (Pure.pure a) (Pure.pure b)) (Pure.pure (HDiv.hDiv a b))","decl":"@[to_additive]\ntheorem pure_div_pure : (pure a : Filter Î±) / pure b = pure (a / b) := by simp\n\n"}
{"name":"Filter.div_le_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Div Î±\nfâ‚ fâ‚‚ gâ‚ gâ‚‚ : Filter Î±\naâœÂ¹ : LE.le fâ‚ fâ‚‚\naâœ : LE.le gâ‚ gâ‚‚\nâŠ¢ LE.le (HDiv.hDiv fâ‚ gâ‚) (HDiv.hDiv fâ‚‚ gâ‚‚)","decl":"@[to_additive]\nprotected theorem div_le_div : fâ‚ â‰¤ fâ‚‚ â†’ gâ‚ â‰¤ gâ‚‚ â†’ fâ‚ / gâ‚ â‰¤ fâ‚‚ / gâ‚‚ :=\n  mapâ‚‚_mono\n\n"}
{"name":"Filter.sub_le_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Sub Î±\nfâ‚ fâ‚‚ gâ‚ gâ‚‚ : Filter Î±\naâœÂ¹ : LE.le fâ‚ fâ‚‚\naâœ : LE.le gâ‚ gâ‚‚\nâŠ¢ LE.le (HSub.hSub fâ‚ gâ‚) (HSub.hSub fâ‚‚ gâ‚‚)","decl":"@[to_additive]\nprotected theorem div_le_div : fâ‚ â‰¤ fâ‚‚ â†’ gâ‚ â‰¤ gâ‚‚ â†’ fâ‚ / gâ‚ â‰¤ fâ‚‚ / gâ‚‚ :=\n  mapâ‚‚_mono\n\n"}
{"name":"Filter.div_le_div_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Div Î±\nf gâ‚ gâ‚‚ : Filter Î±\naâœ : LE.le gâ‚ gâ‚‚\nâŠ¢ LE.le (HDiv.hDiv f gâ‚) (HDiv.hDiv f gâ‚‚)","decl":"@[to_additive]\nprotected theorem div_le_div_left : gâ‚ â‰¤ gâ‚‚ â†’ f / gâ‚ â‰¤ f / gâ‚‚ :=\n  mapâ‚‚_mono_left\n\n"}
{"name":"Filter.sub_le_sub_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Sub Î±\nf gâ‚ gâ‚‚ : Filter Î±\naâœ : LE.le gâ‚ gâ‚‚\nâŠ¢ LE.le (HSub.hSub f gâ‚) (HSub.hSub f gâ‚‚)","decl":"@[to_additive]\nprotected theorem div_le_div_left : gâ‚ â‰¤ gâ‚‚ â†’ f / gâ‚ â‰¤ f / gâ‚‚ :=\n  mapâ‚‚_mono_left\n\n"}
{"name":"Filter.sub_le_sub_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Sub Î±\nfâ‚ fâ‚‚ g : Filter Î±\naâœ : LE.le fâ‚ fâ‚‚\nâŠ¢ LE.le (HSub.hSub fâ‚ g) (HSub.hSub fâ‚‚ g)","decl":"@[to_additive]\nprotected theorem div_le_div_right : fâ‚ â‰¤ fâ‚‚ â†’ fâ‚ / g â‰¤ fâ‚‚ / g :=\n  mapâ‚‚_mono_right\n\n"}
{"name":"Filter.div_le_div_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Div Î±\nfâ‚ fâ‚‚ g : Filter Î±\naâœ : LE.le fâ‚ fâ‚‚\nâŠ¢ LE.le (HDiv.hDiv fâ‚ g) (HDiv.hDiv fâ‚‚ g)","decl":"@[to_additive]\nprotected theorem div_le_div_right : fâ‚ â‰¤ fâ‚‚ â†’ fâ‚ / g â‰¤ fâ‚‚ / g :=\n  mapâ‚‚_mono_right\n\n"}
{"name":"Filter.le_sub_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Sub Î±\nf g h : Filter Î±\nâŠ¢ Iff (LE.le h (HSub.hSub f g)) (âˆ€ â¦ƒs : Set Î±â¦„, Membership.mem f s â†’ âˆ€ â¦ƒt : Set Î±â¦„, Membership.mem g t â†’ Membership.mem h (HSub.hSub s t))","decl":"@[to_additive (attr := simp)]\nprotected theorem le_div_iff : h â‰¤ f / g â†” âˆ€ â¦ƒsâ¦„, s âˆˆ f â†’ âˆ€ â¦ƒtâ¦„, t âˆˆ g â†’ s / t âˆˆ h :=\n  le_mapâ‚‚_iff\n\n"}
{"name":"Filter.le_div_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Div Î±\nf g h : Filter Î±\nâŠ¢ Iff (LE.le h (HDiv.hDiv f g)) (âˆ€ â¦ƒs : Set Î±â¦„, Membership.mem f s â†’ âˆ€ â¦ƒt : Set Î±â¦„, Membership.mem g t â†’ Membership.mem h (HDiv.hDiv s t))","decl":"@[to_additive (attr := simp)]\nprotected theorem le_div_iff : h â‰¤ f / g â†” âˆ€ â¦ƒsâ¦„, s âˆˆ f â†’ âˆ€ â¦ƒtâ¦„, t âˆˆ g â†’ s / t âˆˆ h :=\n  le_mapâ‚‚_iff\n\n"}
{"name":"Filter.covariant_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Div Î±\nâŠ¢ CovariantClass (Filter Î±) (Filter Î±) (fun x1 x2 => HDiv.hDiv x1 x2) fun x1 x2 => LE.le x1 x2","decl":"@[to_additive]\ninstance covariant_div : CovariantClass (Filter Î±) (Filter Î±) (Â· / Â·) (Â· â‰¤ Â·) :=\n  âŸ¨fun _ _ _ => mapâ‚‚_mono_leftâŸ©\n\n"}
{"name":"Filter.covariant_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Sub Î±\nâŠ¢ CovariantClass (Filter Î±) (Filter Î±) (fun x1 x2 => HSub.hSub x1 x2) fun x1 x2 => LE.le x1 x2","decl":"@[to_additive]\ninstance covariant_div : CovariantClass (Filter Î±) (Filter Î±) (Â· / Â·) (Â· â‰¤ Â·) :=\n  âŸ¨fun _ _ _ => mapâ‚‚_mono_leftâŸ©\n\n"}
{"name":"Filter.covariant_swap_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Div Î±\nâŠ¢ CovariantClass (Filter Î±) (Filter Î±) (Function.swap fun x1 x2 => HDiv.hDiv x1 x2) fun x1 x2 => LE.le x1 x2","decl":"@[to_additive]\ninstance covariant_swap_div : CovariantClass (Filter Î±) (Filter Î±) (swap (Â· / Â·)) (Â· â‰¤ Â·) :=\n  âŸ¨fun _ _ _ => mapâ‚‚_mono_rightâŸ©\n\n"}
{"name":"Filter.covariant_swap_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Sub Î±\nâŠ¢ CovariantClass (Filter Î±) (Filter Î±) (Function.swap fun x1 x2 => HSub.hSub x1 x2) fun x1 x2 => LE.le x1 x2","decl":"@[to_additive]\ninstance covariant_swap_div : CovariantClass (Filter Î±) (Filter Î±) (swap (Â· / Â·)) (Â· â‰¤ Â·) :=\n  âŸ¨fun _ _ _ => mapâ‚‚_mono_rightâŸ©\n\n"}
{"name":"Filter.comap_mul_comap_le","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : MulOneClass Î±\ninstâœÂ² : MulOneClass Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : MulHomClass F Î± Î²\nm : F\nf g : Filter Î²\nâŠ¢ LE.le (HMul.hMul (Filter.comap (â‡‘m) f) (Filter.comap (â‡‘m) g)) (Filter.comap (â‡‘m) (HMul.hMul f g))","decl":"@[to_additive]\ntheorem comap_mul_comap_le [MulHomClass F Î± Î²] (m : F) {f g : Filter Î²} :\n    f.comap m * g.comap m â‰¤ (f * g).comap m := fun _ âŸ¨_, âŸ¨tâ‚, htâ‚, tâ‚‚, htâ‚‚, tâ‚tâ‚‚âŸ©, mtâŸ© =>\n  âŸ¨m â»Â¹' tâ‚, âŸ¨tâ‚, htâ‚, Subset.rflâŸ©, m â»Â¹' tâ‚‚, âŸ¨tâ‚‚, htâ‚‚, Subset.rflâŸ©,\n    (preimage_mul_preimage_subset _).trans <| (preimage_mono tâ‚tâ‚‚).trans mtâŸ©\n\n"}
{"name":"Filter.comap_add_comap_le","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : AddZeroClass Î±\ninstâœÂ² : AddZeroClass Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : AddHomClass F Î± Î²\nm : F\nf g : Filter Î²\nâŠ¢ LE.le (HAdd.hAdd (Filter.comap (â‡‘m) f) (Filter.comap (â‡‘m) g)) (Filter.comap (â‡‘m) (HAdd.hAdd f g))","decl":"@[to_additive]\ntheorem comap_mul_comap_le [MulHomClass F Î± Î²] (m : F) {f g : Filter Î²} :\n    f.comap m * g.comap m â‰¤ (f * g).comap m := fun _ âŸ¨_, âŸ¨tâ‚, htâ‚, tâ‚‚, htâ‚‚, tâ‚tâ‚‚âŸ©, mtâŸ© =>\n  âŸ¨m â»Â¹' tâ‚, âŸ¨tâ‚, htâ‚, Subset.rflâŸ©, m â»Â¹' tâ‚‚, âŸ¨tâ‚‚, htâ‚‚, Subset.rflâŸ©,\n    (preimage_mul_preimage_subset _).trans <| (preimage_mono tâ‚tâ‚‚).trans mtâŸ©\n\n"}
{"name":"Filter.Tendsto.add_add","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : AddZeroClass Î±\ninstâœÂ² : AddZeroClass Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : AddHomClass F Î± Î²\nm : F\nfâ‚ gâ‚ : Filter Î±\nfâ‚‚ gâ‚‚ : Filter Î²\naâœÂ¹ : Filter.Tendsto (â‡‘m) fâ‚ fâ‚‚\naâœ : Filter.Tendsto (â‡‘m) gâ‚ gâ‚‚\nâŠ¢ Filter.Tendsto (â‡‘m) (HAdd.hAdd fâ‚ gâ‚) (HAdd.hAdd fâ‚‚ gâ‚‚)","decl":"@[to_additive]\ntheorem Tendsto.mul_mul [MulHomClass F Î± Î²] (m : F) {fâ‚ gâ‚ : Filter Î±} {fâ‚‚ gâ‚‚ : Filter Î²} :\n    Tendsto m fâ‚ fâ‚‚ â†’ Tendsto m gâ‚ gâ‚‚ â†’ Tendsto m (fâ‚ * gâ‚) (fâ‚‚ * gâ‚‚) := fun hf hg =>\n  (Filter.map_mul m).trans_le <| mul_le_mul' hf hg\n\n"}
{"name":"Filter.Tendsto.mul_mul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : MulOneClass Î±\ninstâœÂ² : MulOneClass Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : MulHomClass F Î± Î²\nm : F\nfâ‚ gâ‚ : Filter Î±\nfâ‚‚ gâ‚‚ : Filter Î²\naâœÂ¹ : Filter.Tendsto (â‡‘m) fâ‚ fâ‚‚\naâœ : Filter.Tendsto (â‡‘m) gâ‚ gâ‚‚\nâŠ¢ Filter.Tendsto (â‡‘m) (HMul.hMul fâ‚ gâ‚) (HMul.hMul fâ‚‚ gâ‚‚)","decl":"@[to_additive]\ntheorem Tendsto.mul_mul [MulHomClass F Î± Î²] (m : F) {fâ‚ gâ‚ : Filter Î±} {fâ‚‚ gâ‚‚ : Filter Î²} :\n    Tendsto m fâ‚ fâ‚‚ â†’ Tendsto m gâ‚ gâ‚‚ â†’ Tendsto m (fâ‚ * gâ‚) (fâ‚‚ * gâ‚‚) := fun hf hg =>\n  (Filter.map_mul m).trans_le <| mul_le_mul' hf hg\n\n"}
{"name":"Filter.coe_pureAddMonoidHom","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : AddZeroClass Î±\nâŠ¢ Eq (â‡‘Filter.pureAddMonoidHom) Pure.pure","decl":"@[to_additive (attr := simp)]\ntheorem coe_pureMonoidHom : (pureMonoidHom : Î± â†’ Filter Î±) = pure :=\n  rfl\n\n"}
{"name":"Filter.coe_pureMonoidHom","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : MulOneClass Î±\nâŠ¢ Eq (â‡‘Filter.pureMonoidHom) Pure.pure","decl":"@[to_additive (attr := simp)]\ntheorem coe_pureMonoidHom : (pureMonoidHom : Î± â†’ Filter Î±) = pure :=\n  rfl\n\n"}
{"name":"Filter.pureAddMonoidHom_apply","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : AddZeroClass Î±\na : Î±\nâŠ¢ Eq (Filter.pureAddMonoidHom a) (Pure.pure a)","decl":"@[to_additive (attr := simp)]\ntheorem pureMonoidHom_apply (a : Î±) : pureMonoidHom a = pure a :=\n  rfl\n\n"}
{"name":"Filter.pureMonoidHom_apply","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : MulOneClass Î±\na : Î±\nâŠ¢ Eq (Filter.pureMonoidHom a) (Pure.pure a)","decl":"@[to_additive (attr := simp)]\ntheorem pureMonoidHom_apply (a : Î±) : pureMonoidHom a = pure a :=\n  rfl\n\n"}
{"name":"Filter.pow_mem_pow","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Monoid Î±\nf : Filter Î±\ns : Set Î±\nhs : Membership.mem f s\nn : Nat\nâŠ¢ Membership.mem (HPow.hPow f n) (HPow.hPow s n)","decl":"@[to_additive]\ntheorem pow_mem_pow (hs : s âˆˆ f) : âˆ€ n : â„•, s ^ n âˆˆ f ^ n\n  | 0 => by\n    rw [pow_zero]\n    exact one_mem_one\n  | n + 1 => by\n    rw [pow_succ]\n    exact mul_mem_mul (pow_mem_pow hs n) hs\n\n"}
{"name":"Filter.nsmul_mem_nsmul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : AddMonoid Î±\nf : Filter Î±\ns : Set Î±\nhs : Membership.mem f s\nn : Nat\nâŠ¢ Membership.mem (HSMul.hSMul n f) (HSMul.hSMul n s)","decl":"@[to_additive]\ntheorem pow_mem_pow (hs : s âˆˆ f) : âˆ€ n : â„•, s ^ n âˆˆ f ^ n\n  | 0 => by\n    rw [pow_zero]\n    exact one_mem_one\n  | n + 1 => by\n    rw [pow_succ]\n    exact mul_mem_mul (pow_mem_pow hs n) hs\n\n"}
{"name":"Filter.nsmul_bot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : AddMonoid Î±\nn : Nat\nhn : Ne n 0\nâŠ¢ Eq (HSMul.hSMul n Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp) nsmul_bot]\ntheorem bot_pow {n : â„•} (hn : n â‰  0) : (âŠ¥ : Filter Î±) ^ n = âŠ¥ := by\n  rw [â† Nat.sub_one_add_one hn, pow_succ', bot_mul]\n\n"}
{"name":"Filter.bot_pow","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Monoid Î±\nn : Nat\nhn : Ne n 0\nâŠ¢ Eq (HPow.hPow Bot.bot n) Bot.bot","decl":"@[to_additive (attr := simp) nsmul_bot]\ntheorem bot_pow {n : â„•} (hn : n â‰  0) : (âŠ¥ : Filter Î±) ^ n = âŠ¥ := by\n  rw [â† Nat.sub_one_add_one hn, pow_succ', bot_mul]\n\n"}
{"name":"Filter.add_top_of_nonneg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : AddMonoid Î±\nf : Filter Î±\nhf : LE.le 0 f\nâŠ¢ Eq (HAdd.hAdd f Top.top) Top.top","decl":"@[to_additive]\ntheorem mul_top_of_one_le (hf : 1 â‰¤ f) : f * âŠ¤ = âŠ¤ := by\n  refine top_le_iff.1 fun s => ?_\n  simp only [mem_mul, mem_top, exists_and_left, exists_eq_left]\n  rintro âŸ¨t, ht, hsâŸ©\n  rwa [mul_univ_of_one_mem (mem_one.1 <| hf ht), univ_subset_iff] at hs\n\n"}
{"name":"Filter.mul_top_of_one_le","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Monoid Î±\nf : Filter Î±\nhf : LE.le 1 f\nâŠ¢ Eq (HMul.hMul f Top.top) Top.top","decl":"@[to_additive]\ntheorem mul_top_of_one_le (hf : 1 â‰¤ f) : f * âŠ¤ = âŠ¤ := by\n  refine top_le_iff.1 fun s => ?_\n  simp only [mem_mul, mem_top, exists_and_left, exists_eq_left]\n  rintro âŸ¨t, ht, hsâŸ©\n  rwa [mul_univ_of_one_mem (mem_one.1 <| hf ht), univ_subset_iff] at hs\n\n"}
{"name":"Filter.top_add_of_nonneg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : AddMonoid Î±\nf : Filter Î±\nhf : LE.le 0 f\nâŠ¢ Eq (HAdd.hAdd Top.top f) Top.top","decl":"@[to_additive]\ntheorem top_mul_of_one_le (hf : 1 â‰¤ f) : âŠ¤ * f = âŠ¤ := by\n  refine top_le_iff.1 fun s => ?_\n  simp only [mem_mul, mem_top, exists_and_left, exists_eq_left]\n  rintro âŸ¨t, ht, hsâŸ©\n  rwa [univ_mul_of_one_mem (mem_one.1 <| hf ht), univ_subset_iff] at hs\n\n"}
{"name":"Filter.top_mul_of_one_le","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Monoid Î±\nf : Filter Î±\nhf : LE.le 1 f\nâŠ¢ Eq (HMul.hMul Top.top f) Top.top","decl":"@[to_additive]\ntheorem top_mul_of_one_le (hf : 1 â‰¤ f) : âŠ¤ * f = âŠ¤ := by\n  refine top_le_iff.1 fun s => ?_\n  simp only [mem_mul, mem_top, exists_and_left, exists_eq_left]\n  rintro âŸ¨t, ht, hsâŸ©\n  rwa [univ_mul_of_one_mem (mem_one.1 <| hf ht), univ_subset_iff] at hs\n\n"}
{"name":"Filter.top_add_top","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : AddMonoid Î±\nâŠ¢ Eq (HAdd.hAdd Top.top Top.top) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem top_mul_top : (âŠ¤ : Filter Î±) * âŠ¤ = âŠ¤ :=\n  mul_top_of_one_le le_top\n\n"}
{"name":"Filter.top_mul_top","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Monoid Î±\nâŠ¢ Eq (HMul.hMul Top.top Top.top) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem top_mul_top : (âŠ¤ : Filter Î±) * âŠ¤ = âŠ¤ :=\n  mul_top_of_one_le le_top\n\n"}
{"name":"Filter.nsmul_top","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : AddMonoid Î±\nn : Nat\naâœ : Ne n 0\nâŠ¢ Eq (HSMul.hSMul n Top.top) Top.top","decl":"@[to_additive nsmul_top]\ntheorem top_pow : âˆ€ {n : â„•}, n â‰  0 â†’ (âŠ¤ : Filter Î±) ^ n = âŠ¤\n  | 0 => fun h => (h rfl).elim\n  | 1 => fun _ => pow_one _\n  | n + 2 => fun _ => by rw [pow_succ, top_pow n.succ_ne_zero, top_mul_top]\n\n"}
{"name":"Filter.top_pow","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Monoid Î±\nn : Nat\naâœ : Ne n 0\nâŠ¢ Eq (HPow.hPow Top.top n) Top.top","decl":"@[to_additive nsmul_top]\ntheorem top_pow : âˆ€ {n : â„•}, n â‰  0 â†’ (âŠ¤ : Filter Î±) ^ n = âŠ¤\n  | 0 => fun h => (h rfl).elim\n  | 1 => fun _ => pow_one _\n  | n + 2 => fun _ => by rw [pow_succ, top_pow n.succ_ne_zero, top_mul_top]\n\n"}
{"name":"IsAddUnit.filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : AddMonoid Î±\na : Î±\naâœ : IsAddUnit a\nâŠ¢ IsAddUnit (Pure.pure a)","decl":"@[to_additive]\nprotected theorem _root_.IsUnit.filter : IsUnit a â†’ IsUnit (pure a : Filter Î±) :=\n  IsUnit.map (pureMonoidHom : Î± â†’* Filter Î±)\n\n"}
{"name":"IsUnit.filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Monoid Î±\na : Î±\naâœ : IsUnit a\nâŠ¢ IsUnit (Pure.pure a)","decl":"@[to_additive]\nprotected theorem _root_.IsUnit.filter : IsUnit a â†’ IsUnit (pure a : Filter Î±) :=\n  IsUnit.map (pureMonoidHom : Î± â†’* Filter Î±)\n\n"}
{"name":"Filter.mul_eq_one_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : DivisionMonoid Î±\nf g : Filter Î±\nâŠ¢ Iff (Eq (HMul.hMul f g) 1) (Exists fun a => Exists fun b => And (Eq f (Pure.pure a)) (And (Eq g (Pure.pure b)) (Eq (HMul.hMul a b) 1)))","decl":"@[to_additive]\nprotected theorem mul_eq_one_iff : f * g = 1 â†” âˆƒ a b, f = pure a âˆ§ g = pure b âˆ§ a * b = 1 := by\n  refine âŸ¨fun hfg => ?_, ?_âŸ©\n  Â· obtain âŸ¨tâ‚, hâ‚, tâ‚‚, hâ‚‚, hâŸ© : (1 : Set Î±) âˆˆ f * g := hfg.symm â–¸ one_mem_one\n    have hfg : (f * g).NeBot := hfg.symm.subst one_neBot\n    rw [(hfg.nonempty_of_mem <| mul_mem_mul hâ‚ hâ‚‚).subset_one_iff, Set.mul_eq_one_iff] at h\n    obtain âŸ¨a, b, rfl, rfl, hâŸ© := h\n    refine âŸ¨a, b, ?_, ?_, hâŸ©\n    Â· rwa [â† hfg.of_mul_left.le_pure_iff, le_pure_iff]\n    Â· rwa [â† hfg.of_mul_right.le_pure_iff, le_pure_iff]\n  Â· rintro âŸ¨a, b, rfl, rfl, hâŸ©\n    rw [pure_mul_pure, h, pure_one]\n\n"}
{"name":"Filter.add_eq_zero_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : SubtractionMonoid Î±\nf g : Filter Î±\nâŠ¢ Iff (Eq (HAdd.hAdd f g) 0) (Exists fun a => Exists fun b => And (Eq f (Pure.pure a)) (And (Eq g (Pure.pure b)) (Eq (HAdd.hAdd a b) 0)))","decl":"@[to_additive]\nprotected theorem mul_eq_one_iff : f * g = 1 â†” âˆƒ a b, f = pure a âˆ§ g = pure b âˆ§ a * b = 1 := by\n  refine âŸ¨fun hfg => ?_, ?_âŸ©\n  Â· obtain âŸ¨tâ‚, hâ‚, tâ‚‚, hâ‚‚, hâŸ© : (1 : Set Î±) âˆˆ f * g := hfg.symm â–¸ one_mem_one\n    have hfg : (f * g).NeBot := hfg.symm.subst one_neBot\n    rw [(hfg.nonempty_of_mem <| mul_mem_mul hâ‚ hâ‚‚).subset_one_iff, Set.mul_eq_one_iff] at h\n    obtain âŸ¨a, b, rfl, rfl, hâŸ© := h\n    refine âŸ¨a, b, ?_, ?_, hâŸ©\n    Â· rwa [â† hfg.of_mul_left.le_pure_iff, le_pure_iff]\n    Â· rwa [â† hfg.of_mul_right.le_pure_iff, le_pure_iff]\n  Â· rintro âŸ¨a, b, rfl, rfl, hâŸ©\n    rw [pure_mul_pure, h, pure_one]\n\n"}
{"name":"Filter.isAddUnit_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : SubtractionMonoid Î±\nf : Filter Î±\nâŠ¢ Iff (IsAddUnit f) (Exists fun a => And (Eq f (Pure.pure a)) (IsAddUnit a))","decl":"@[to_additive]\ntheorem isUnit_iff : IsUnit f â†” âˆƒ a, f = pure a âˆ§ IsUnit a := by\n  constructor\n  Â· rintro âŸ¨u, rflâŸ©\n    obtain âŸ¨a, b, ha, hb, hâŸ© := Filter.mul_eq_one_iff.1 u.mul_inv\n    refine âŸ¨a, ha, âŸ¨a, b, h, pure_injective ?_âŸ©, rflâŸ©\n    rw [â† pure_mul_pure, â† ha, â† hb]\n    exact u.inv_mul\n  Â· rintro âŸ¨a, rfl, haâŸ©\n    exact ha.filter\n\n"}
{"name":"Filter.isUnit_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : DivisionMonoid Î±\nf : Filter Î±\nâŠ¢ Iff (IsUnit f) (Exists fun a => And (Eq f (Pure.pure a)) (IsUnit a))","decl":"@[to_additive]\ntheorem isUnit_iff : IsUnit f â†” âˆƒ a, f = pure a âˆ§ IsUnit a := by\n  constructor\n  Â· rintro âŸ¨u, rflâŸ©\n    obtain âŸ¨a, b, ha, hb, hâŸ© := Filter.mul_eq_one_iff.1 u.mul_inv\n    refine âŸ¨a, ha, âŸ¨a, b, h, pure_injective ?_âŸ©, rflâŸ©\n    rw [â† pure_mul_pure, â† ha, â† hb]\n    exact u.inv_mul\n  Â· rintro âŸ¨a, rfl, haâŸ©\n    exact ha.filter\n\n"}
{"name":"Filter.mul_add_subset","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Distrib Î±\nf g h : Filter Î±\nâŠ¢ LE.le (HMul.hMul f (HAdd.hAdd g h)) (HAdd.hAdd (HMul.hMul f g) (HMul.hMul f h))","decl":"theorem mul_add_subset : f * (g + h) â‰¤ f * g + f * h :=\n  mapâ‚‚_distrib_le_left mul_add\n\n"}
{"name":"Filter.add_mul_subset","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Distrib Î±\nf g h : Filter Î±\nâŠ¢ LE.le (HMul.hMul (HAdd.hAdd f g) h) (HAdd.hAdd (HMul.hMul f h) (HMul.hMul g h))","decl":"theorem add_mul_subset : (f + g) * h â‰¤ f * h + g * h :=\n  mapâ‚‚_distrib_le_right add_mul\n\n"}
{"name":"Filter.NeBot.mul_zero_nonneg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : MulZeroClass Î±\nf : Filter Î±\nhf : f.NeBot\nâŠ¢ LE.le 0 (HMul.hMul f 0)","decl":"theorem NeBot.mul_zero_nonneg (hf : f.NeBot) : 0 â‰¤ f * 0 :=\n  le_mul_iff.2 fun _ hâ‚ _ hâ‚‚ =>\n    let âŸ¨_, haâŸ© := hf.nonempty_of_mem hâ‚\n    âŸ¨_, ha, _, hâ‚‚, mul_zero _âŸ©\n\n"}
{"name":"Filter.NeBot.zero_mul_nonneg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : MulZeroClass Î±\ng : Filter Î±\nhg : g.NeBot\nâŠ¢ LE.le 0 (HMul.hMul 0 g)","decl":"theorem NeBot.zero_mul_nonneg (hg : g.NeBot) : 0 â‰¤ 0 * g :=\n  le_mul_iff.2 fun _ hâ‚ _ hâ‚‚ =>\n    let âŸ¨_, hbâŸ© := hg.nonempty_of_mem hâ‚‚\n    âŸ¨_, hâ‚, _, hb, zero_mul _âŸ©\n\n"}
{"name":"Filter.one_le_div_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Group Î±\nf g : Filter Î±\nâŠ¢ Iff (LE.le 1 (HDiv.hDiv f g)) (Not (Disjoint f g))","decl":"@[to_additive (attr := simp 1100)]\nprotected theorem one_le_div_iff : 1 â‰¤ f / g â†” Â¬Disjoint f g := by\n  refine âŸ¨fun h hfg => ?_, ?_âŸ©\n  Â· obtain âŸ¨s, hs, t, ht, hstâŸ© := hfg.le_bot (mem_bot : âˆ… âˆˆ âŠ¥)\n    exact Set.one_mem_div_iff.1 (h <| div_mem_div hs ht) (disjoint_iff.2 hst.symm)\n  Â· rintro h s âŸ¨tâ‚, hâ‚, tâ‚‚, hâ‚‚, hsâŸ©\n    exact hs (Set.one_mem_div_iff.2 fun ht => h <| disjoint_of_disjoint_of_mem ht hâ‚ hâ‚‚)\n\n"}
{"name":"Filter.nonneg_sub_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : AddGroup Î±\nf g : Filter Î±\nâŠ¢ Iff (LE.le 0 (HSub.hSub f g)) (Not (Disjoint f g))","decl":"@[to_additive (attr := simp 1100)]\nprotected theorem one_le_div_iff : 1 â‰¤ f / g â†” Â¬Disjoint f g := by\n  refine âŸ¨fun h hfg => ?_, ?_âŸ©\n  Â· obtain âŸ¨s, hs, t, ht, hstâŸ© := hfg.le_bot (mem_bot : âˆ… âˆˆ âŠ¥)\n    exact Set.one_mem_div_iff.1 (h <| div_mem_div hs ht) (disjoint_iff.2 hst.symm)\n  Â· rintro h s âŸ¨tâ‚, hâ‚, tâ‚‚, hâ‚‚, hsâŸ©\n    exact hs (Set.one_mem_div_iff.2 fun ht => h <| disjoint_of_disjoint_of_mem ht hâ‚ hâ‚‚)\n\n"}
{"name":"Filter.not_one_le_div_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Group Î±\nf g : Filter Î±\nâŠ¢ Iff (Not (LE.le 1 (HDiv.hDiv f g))) (Disjoint f g)","decl":"@[to_additive]\ntheorem not_one_le_div_iff : Â¬1 â‰¤ f / g â†” Disjoint f g :=\n  Filter.one_le_div_iff.not_left\n\n"}
{"name":"Filter.not_nonneg_sub_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : AddGroup Î±\nf g : Filter Î±\nâŠ¢ Iff (Not (LE.le 0 (HSub.hSub f g))) (Disjoint f g)","decl":"@[to_additive]\ntheorem not_one_le_div_iff : Â¬1 â‰¤ f / g â†” Disjoint f g :=\n  Filter.one_le_div_iff.not_left\n\n"}
{"name":"Filter.NeBot.nonneg_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : AddGroup Î±\nf : Filter Î±\nh : f.NeBot\nâŠ¢ LE.le 0 (HSub.hSub f f)","decl":"@[to_additive]\ntheorem NeBot.one_le_div (h : f.NeBot) : 1 â‰¤ f / f := by\n  rintro s âŸ¨tâ‚, hâ‚, tâ‚‚, hâ‚‚, hsâŸ©\n  obtain âŸ¨a, haâ‚, haâ‚‚âŸ© := Set.not_disjoint_iff.1 (h.not_disjoint hâ‚ hâ‚‚)\n  rw [mem_one, â† div_self' a]\n  exact hs (Set.div_mem_div haâ‚ haâ‚‚)\n\n"}
{"name":"Filter.NeBot.one_le_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Group Î±\nf : Filter Î±\nh : f.NeBot\nâŠ¢ LE.le 1 (HDiv.hDiv f f)","decl":"@[to_additive]\ntheorem NeBot.one_le_div (h : f.NeBot) : 1 â‰¤ f / f := by\n  rintro s âŸ¨tâ‚, hâ‚, tâ‚‚, hâ‚‚, hsâŸ©\n  obtain âŸ¨a, haâ‚, haâ‚‚âŸ© := Set.not_disjoint_iff.1 (h.not_disjoint hâ‚ hâ‚‚)\n  rw [mem_one, â† div_self' a]\n  exact hs (Set.div_mem_div haâ‚ haâ‚‚)\n\n"}
{"name":"Filter.isAddUnit_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : AddGroup Î±\na : Î±\nâŠ¢ IsAddUnit (Pure.pure a)","decl":"@[to_additive]\ntheorem isUnit_pure (a : Î±) : IsUnit (pure a : Filter Î±) :=\n  (Group.isUnit a).filter\n\n"}
{"name":"Filter.isUnit_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Group Î±\na : Î±\nâŠ¢ IsUnit (Pure.pure a)","decl":"@[to_additive]\ntheorem isUnit_pure (a : Î±) : IsUnit (pure a : Filter Î±) :=\n  (Group.isUnit a).filter\n\n"}
{"name":"Filter.isUnit_iff_singleton","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : Group Î±\nf : Filter Î±\nâŠ¢ Iff (IsUnit f) (Exists fun a => Eq f (Pure.pure a))","decl":"@[simp]\ntheorem isUnit_iff_singleton : IsUnit f â†” âˆƒ a, f = pure a := by\n  simp only [isUnit_iff, Group.isUnit, and_true]\n\n"}
{"name":"Filter.map_inv'","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : Group Î±\ninstâœÂ² : DivisionMonoid Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : MonoidHomClass F Î± Î²\nm : F\nf : Filter Î±\nâŠ¢ Eq (Filter.map (â‡‘m) (Inv.inv f)) (Inv.inv (Filter.map (â‡‘m) f))","decl":"@[to_additive]\ntheorem map_inv' : fâ»Â¹.map m = (f.map m)â»Â¹ :=\n  Semiconj.filter_map (map_inv m) f\n\n"}
{"name":"Filter.map_neg'","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : AddGroup Î±\ninstâœÂ² : SubtractionMonoid Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : AddMonoidHomClass F Î± Î²\nm : F\nf : Filter Î±\nâŠ¢ Eq (Filter.map (â‡‘m) (Neg.neg f)) (Neg.neg (Filter.map (â‡‘m) f))","decl":"@[to_additive]\ntheorem map_inv' : fâ»Â¹.map m = (f.map m)â»Â¹ :=\n  Semiconj.filter_map (map_inv m) f\n\n"}
{"name":"Filter.Tendsto.inv_inv","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : Group Î±\ninstâœÂ² : DivisionMonoid Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : MonoidHomClass F Î± Î²\nm : F\nfâ‚ : Filter Î±\nfâ‚‚ : Filter Î²\naâœ : Filter.Tendsto (â‡‘m) fâ‚ fâ‚‚\nâŠ¢ Filter.Tendsto (â‡‘m) (Inv.inv fâ‚) (Inv.inv fâ‚‚)","decl":"@[to_additive]\nprotected theorem Tendsto.inv_inv : Tendsto m fâ‚ fâ‚‚ â†’ Tendsto m fâ‚â»Â¹ fâ‚‚â»Â¹ := fun hf =>\n  (Filter.map_inv' m).trans_le <| Filter.inv_le_inv hf\n\n"}
{"name":"Filter.Tendsto.neg_neg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : AddGroup Î±\ninstâœÂ² : SubtractionMonoid Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : AddMonoidHomClass F Î± Î²\nm : F\nfâ‚ : Filter Î±\nfâ‚‚ : Filter Î²\naâœ : Filter.Tendsto (â‡‘m) fâ‚ fâ‚‚\nâŠ¢ Filter.Tendsto (â‡‘m) (Neg.neg fâ‚) (Neg.neg fâ‚‚)","decl":"@[to_additive]\nprotected theorem Tendsto.inv_inv : Tendsto m fâ‚ fâ‚‚ â†’ Tendsto m fâ‚â»Â¹ fâ‚‚â»Â¹ := fun hf =>\n  (Filter.map_inv' m).trans_le <| Filter.inv_le_inv hf\n\n"}
{"name":"Filter.map_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : AddGroup Î±\ninstâœÂ² : SubtractionMonoid Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : AddMonoidHomClass F Î± Î²\nm : F\nf g : Filter Î±\nâŠ¢ Eq (Filter.map (â‡‘m) (HSub.hSub f g)) (HSub.hSub (Filter.map (â‡‘m) f) (Filter.map (â‡‘m) g))","decl":"@[to_additive]\nprotected theorem map_div : (f / g).map m = f.map m / g.map m :=\n  map_mapâ‚‚_distrib <| map_div m\n\n"}
{"name":"Filter.map_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : Group Î±\ninstâœÂ² : DivisionMonoid Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : MonoidHomClass F Î± Î²\nm : F\nf g : Filter Î±\nâŠ¢ Eq (Filter.map (â‡‘m) (HDiv.hDiv f g)) (HDiv.hDiv (Filter.map (â‡‘m) f) (Filter.map (â‡‘m) g))","decl":"@[to_additive]\nprotected theorem map_div : (f / g).map m = f.map m / g.map m :=\n  map_mapâ‚‚_distrib <| map_div m\n\n"}
{"name":"Filter.Tendsto.div_div","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : Group Î±\ninstâœÂ² : DivisionMonoid Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : MonoidHomClass F Î± Î²\nm : F\nfâ‚ gâ‚ : Filter Î±\nfâ‚‚ gâ‚‚ : Filter Î²\nhf : Filter.Tendsto (â‡‘m) fâ‚ fâ‚‚\nhg : Filter.Tendsto (â‡‘m) gâ‚ gâ‚‚\nâŠ¢ Filter.Tendsto (â‡‘m) (HDiv.hDiv fâ‚ gâ‚) (HDiv.hDiv fâ‚‚ gâ‚‚)","decl":"@[to_additive]\nprotected theorem Tendsto.div_div (hf : Tendsto m fâ‚ fâ‚‚) (hg : Tendsto m gâ‚ gâ‚‚) :\n    Tendsto m (fâ‚ / gâ‚) (fâ‚‚ / gâ‚‚) :=\n  (Filter.map_div m).trans_le <| Filter.div_le_div hf hg\n\n"}
{"name":"Filter.Tendsto.sub_sub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : AddGroup Î±\ninstâœÂ² : SubtractionMonoid Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : AddMonoidHomClass F Î± Î²\nm : F\nfâ‚ gâ‚ : Filter Î±\nfâ‚‚ gâ‚‚ : Filter Î²\nhf : Filter.Tendsto (â‡‘m) fâ‚ fâ‚‚\nhg : Filter.Tendsto (â‡‘m) gâ‚ gâ‚‚\nâŠ¢ Filter.Tendsto (â‡‘m) (HSub.hSub fâ‚ gâ‚) (HSub.hSub fâ‚‚ gâ‚‚)","decl":"@[to_additive]\nprotected theorem Tendsto.div_div (hf : Tendsto m fâ‚ fâ‚‚) (hg : Tendsto m gâ‚ gâ‚‚) :\n    Tendsto m (fâ‚ / gâ‚) (fâ‚‚ / gâ‚‚) :=\n  (Filter.map_div m).trans_le <| Filter.div_le_div hf hg\n\n"}
{"name":"Filter.NeBot.div_zero_nonneg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : GroupWithZero Î±\nf : Filter Î±\nhf : f.NeBot\nâŠ¢ LE.le 0 (HDiv.hDiv f 0)","decl":"theorem NeBot.div_zero_nonneg (hf : f.NeBot) : 0 â‰¤ f / 0 :=\n  Filter.le_div_iff.2 fun _ hâ‚ _ hâ‚‚ =>\n    let âŸ¨_, haâŸ© := hf.nonempty_of_mem hâ‚\n    âŸ¨_, ha, _, hâ‚‚, div_zero _âŸ©\n\n"}
{"name":"Filter.NeBot.zero_div_nonneg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\ninstâœ : GroupWithZero Î±\ng : Filter Î±\nhg : g.NeBot\nâŠ¢ LE.le 0 (HDiv.hDiv 0 g)","decl":"theorem NeBot.zero_div_nonneg (hg : g.NeBot) : 0 â‰¤ 0 / g :=\n  Filter.le_div_iff.2 fun _ hâ‚ _ hâ‚‚ =>\n    let âŸ¨_, hbâŸ© := hg.nonempty_of_mem hâ‚‚\n    âŸ¨_, hâ‚, _, hb, zero_div _âŸ©\n\n"}
{"name":"Filter.mapâ‚‚_vadd","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nf : Filter Î±\ng : Filter Î²\nâŠ¢ Eq (Filter.mapâ‚‚ (fun x1 x2 => HVAdd.hVAdd x1 x2) f g) (HVAdd.hVAdd f g)","decl":"@[to_additive (attr := simp)]\ntheorem mapâ‚‚_smul : mapâ‚‚ (Â· â€¢ Â·) f g = f â€¢ g :=\n  rfl\n\n"}
{"name":"Filter.mapâ‚‚_smul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nf : Filter Î±\ng : Filter Î²\nâŠ¢ Eq (Filter.mapâ‚‚ (fun x1 x2 => HSMul.hSMul x1 x2) f g) (HSMul.hSMul f g)","decl":"@[to_additive (attr := simp)]\ntheorem mapâ‚‚_smul : mapâ‚‚ (Â· â€¢ Â·) f g = f â€¢ g :=\n  rfl\n\n"}
{"name":"Filter.mem_vadd","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nf : Filter Î±\ng : Filter Î²\nt : Set Î²\nâŠ¢ Iff (Membership.mem (HVAdd.hVAdd f g) t) (Exists fun tâ‚ => And (Membership.mem f tâ‚) (Exists fun tâ‚‚ => And (Membership.mem g tâ‚‚) (HasSubset.Subset (HVAdd.hVAdd tâ‚ tâ‚‚) t)))","decl":"@[to_additive]\ntheorem mem_smul : t âˆˆ f â€¢ g â†” âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, tâ‚ â€¢ tâ‚‚ âŠ† t :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_smul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nf : Filter Î±\ng : Filter Î²\nt : Set Î²\nâŠ¢ Iff (Membership.mem (HSMul.hSMul f g) t) (Exists fun tâ‚ => And (Membership.mem f tâ‚) (Exists fun tâ‚‚ => And (Membership.mem g tâ‚‚) (HasSubset.Subset (HSMul.hSMul tâ‚ tâ‚‚) t)))","decl":"@[to_additive]\ntheorem mem_smul : t âˆˆ f â€¢ g â†” âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, tâ‚ â€¢ tâ‚‚ âŠ† t :=\n  Iff.rfl\n\n"}
{"name":"Filter.smul_mem_smul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nf : Filter Î±\ng : Filter Î²\ns : Set Î±\nt : Set Î²\naâœÂ¹ : Membership.mem f s\naâœ : Membership.mem g t\nâŠ¢ Membership.mem (HSMul.hSMul f g) (HSMul.hSMul s t)","decl":"@[to_additive]\ntheorem smul_mem_smul : s âˆˆ f â†’ t âˆˆ g â†’ s â€¢ t âˆˆ f â€¢ g :=\n  image2_mem_mapâ‚‚\n\n"}
{"name":"Filter.vadd_mem_vadd","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nf : Filter Î±\ng : Filter Î²\ns : Set Î±\nt : Set Î²\naâœÂ¹ : Membership.mem f s\naâœ : Membership.mem g t\nâŠ¢ Membership.mem (HVAdd.hVAdd f g) (HVAdd.hVAdd s t)","decl":"@[to_additive]\ntheorem smul_mem_smul : s âˆˆ f â†’ t âˆˆ g â†’ s â€¢ t âˆˆ f â€¢ g :=\n  image2_mem_mapâ‚‚\n\n"}
{"name":"Filter.bot_vadd","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\ng : Filter Î²\nâŠ¢ Eq (HVAdd.hVAdd Bot.bot g) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem bot_smul : (âŠ¥ : Filter Î±) â€¢ g = âŠ¥ :=\n  mapâ‚‚_bot_left\n\n"}
{"name":"Filter.bot_smul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\ng : Filter Î²\nâŠ¢ Eq (HSMul.hSMul Bot.bot g) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem bot_smul : (âŠ¥ : Filter Î±) â€¢ g = âŠ¥ :=\n  mapâ‚‚_bot_left\n\n"}
{"name":"Filter.vadd_bot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nf : Filter Î±\nâŠ¢ Eq (HVAdd.hVAdd f Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem smul_bot : f â€¢ (âŠ¥ : Filter Î²) = âŠ¥ :=\n  mapâ‚‚_bot_right\n\n"}
{"name":"Filter.smul_bot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nf : Filter Î±\nâŠ¢ Eq (HSMul.hSMul f Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem smul_bot : f â€¢ (âŠ¥ : Filter Î²) = âŠ¥ :=\n  mapâ‚‚_bot_right\n\n"}
{"name":"Filter.vadd_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nf : Filter Î±\ng : Filter Î²\nâŠ¢ Iff (Eq (HVAdd.hVAdd f g) Bot.bot) (Or (Eq f Bot.bot) (Eq g Bot.bot))","decl":"@[to_additive (attr := simp)]\ntheorem smul_eq_bot_iff : f â€¢ g = âŠ¥ â†” f = âŠ¥ âˆ¨ g = âŠ¥ :=\n  mapâ‚‚_eq_bot_iff\n\n"}
{"name":"Filter.smul_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nf : Filter Î±\ng : Filter Î²\nâŠ¢ Iff (Eq (HSMul.hSMul f g) Bot.bot) (Or (Eq f Bot.bot) (Eq g Bot.bot))","decl":"@[to_additive (attr := simp)]\ntheorem smul_eq_bot_iff : f â€¢ g = âŠ¥ â†” f = âŠ¥ âˆ¨ g = âŠ¥ :=\n  mapâ‚‚_eq_bot_iff\n\n"}
{"name":"Filter.smul_neBot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nf : Filter Î±\ng : Filter Î²\nâŠ¢ Iff (HSMul.hSMul f g).NeBot (And f.NeBot g.NeBot)","decl":"@[to_additive (attr := simp)]\ntheorem smul_neBot_iff : (f â€¢ g).NeBot â†” f.NeBot âˆ§ g.NeBot :=\n  mapâ‚‚_neBot_iff\n\n"}
{"name":"Filter.vadd_neBot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nf : Filter Î±\ng : Filter Î²\nâŠ¢ Iff (HVAdd.hVAdd f g).NeBot (And f.NeBot g.NeBot)","decl":"@[to_additive (attr := simp)]\ntheorem smul_neBot_iff : (f â€¢ g).NeBot â†” f.NeBot âˆ§ g.NeBot :=\n  mapâ‚‚_neBot_iff\n\n"}
{"name":"Filter.NeBot.smul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nf : Filter Î±\ng : Filter Î²\naâœÂ¹ : f.NeBot\naâœ : g.NeBot\nâŠ¢ (HSMul.hSMul f g).NeBot","decl":"@[to_additive]\nprotected theorem NeBot.smul : NeBot f â†’ NeBot g â†’ NeBot (f â€¢ g) :=\n  NeBot.mapâ‚‚\n\n"}
{"name":"Filter.NeBot.vadd","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nf : Filter Î±\ng : Filter Î²\naâœÂ¹ : f.NeBot\naâœ : g.NeBot\nâŠ¢ (HVAdd.hVAdd f g).NeBot","decl":"@[to_additive]\nprotected theorem NeBot.smul : NeBot f â†’ NeBot g â†’ NeBot (f â€¢ g) :=\n  NeBot.mapâ‚‚\n\n"}
{"name":"Filter.NeBot.of_smul_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nf : Filter Î±\ng : Filter Î²\naâœ : (HSMul.hSMul f g).NeBot\nâŠ¢ f.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_smul_left : (f â€¢ g).NeBot â†’ f.NeBot :=\n  NeBot.of_mapâ‚‚_left\n\n"}
{"name":"Filter.NeBot.of_vadd_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nf : Filter Î±\ng : Filter Î²\naâœ : (HVAdd.hVAdd f g).NeBot\nâŠ¢ f.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_smul_left : (f â€¢ g).NeBot â†’ f.NeBot :=\n  NeBot.of_mapâ‚‚_left\n\n"}
{"name":"Filter.NeBot.of_vadd_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nf : Filter Î±\ng : Filter Î²\naâœ : (HVAdd.hVAdd f g).NeBot\nâŠ¢ g.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_smul_right : (f â€¢ g).NeBot â†’ g.NeBot :=\n  NeBot.of_mapâ‚‚_right\n\n"}
{"name":"Filter.NeBot.of_smul_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nf : Filter Î±\ng : Filter Î²\naâœ : (HSMul.hSMul f g).NeBot\nâŠ¢ g.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_smul_right : (f â€¢ g).NeBot â†’ g.NeBot :=\n  NeBot.of_mapâ‚‚_right\n\n"}
{"name":"Filter.vadd.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ² : VAdd Î± Î²\nf : Filter Î±\ng : Filter Î²\ninstâœÂ¹ : f.NeBot\ninstâœ : g.NeBot\nâŠ¢ (HVAdd.hVAdd f g).NeBot","decl":"@[to_additive vadd.instNeBot]\nlemma smul.instNeBot [NeBot f] [NeBot g] : NeBot (f â€¢ g) := .smul â€¹_â€º â€¹_â€º\n\n"}
{"name":"Filter.smul.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ² : SMul Î± Î²\nf : Filter Î±\ng : Filter Î²\ninstâœÂ¹ : f.NeBot\ninstâœ : g.NeBot\nâŠ¢ (HSMul.hSMul f g).NeBot","decl":"@[to_additive vadd.instNeBot]\nlemma smul.instNeBot [NeBot f] [NeBot g] : NeBot (f â€¢ g) := .smul â€¹_â€º â€¹_â€º\n\n"}
{"name":"Filter.pure_smul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\ng : Filter Î²\na : Î±\nâŠ¢ Eq (HSMul.hSMul (Pure.pure a) g) (Filter.map (fun x => HSMul.hSMul a x) g)","decl":"@[to_additive (attr := simp)]\ntheorem pure_smul : (pure a : Filter Î±) â€¢ g = g.map (a â€¢ Â·) :=\n  mapâ‚‚_pure_left\n\n"}
{"name":"Filter.pure_vadd","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\ng : Filter Î²\na : Î±\nâŠ¢ Eq (HVAdd.hVAdd (Pure.pure a) g) (Filter.map (fun x => HVAdd.hVAdd a x) g)","decl":"@[to_additive (attr := simp)]\ntheorem pure_smul : (pure a : Filter Î±) â€¢ g = g.map (a â€¢ Â·) :=\n  mapâ‚‚_pure_left\n\n"}
{"name":"Filter.vadd_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nf : Filter Î±\nb : Î²\nâŠ¢ Eq (HVAdd.hVAdd f (Pure.pure b)) (Filter.map (fun x => HVAdd.hVAdd x b) f)","decl":"@[to_additive (attr := simp)]\ntheorem smul_pure : f â€¢ pure b = f.map (Â· â€¢ b) :=\n  mapâ‚‚_pure_right\n\n"}
{"name":"Filter.smul_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nf : Filter Î±\nb : Î²\nâŠ¢ Eq (HSMul.hSMul f (Pure.pure b)) (Filter.map (fun x => HSMul.hSMul x b) f)","decl":"@[to_additive (attr := simp)]\ntheorem smul_pure : f â€¢ pure b = f.map (Â· â€¢ b) :=\n  mapâ‚‚_pure_right\n\n"}
{"name":"Filter.pure_vadd_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\na : Î±\nb : Î²\nâŠ¢ Eq (HVAdd.hVAdd (Pure.pure a) (Pure.pure b)) (Pure.pure (HVAdd.hVAdd a b))","decl":"@[to_additive]\ntheorem pure_smul_pure : (pure a : Filter Î±) â€¢ (pure b : Filter Î²) = pure (a â€¢ b) := by simp\n\n"}
{"name":"Filter.pure_smul_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\na : Î±\nb : Î²\nâŠ¢ Eq (HSMul.hSMul (Pure.pure a) (Pure.pure b)) (Pure.pure (HSMul.hSMul a b))","decl":"@[to_additive]\ntheorem pure_smul_pure : (pure a : Filter Î±) â€¢ (pure b : Filter Î²) = pure (a â€¢ b) := by simp\n\n"}
{"name":"Filter.vadd_le_vadd","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nfâ‚ fâ‚‚ : Filter Î±\ngâ‚ gâ‚‚ : Filter Î²\naâœÂ¹ : LE.le fâ‚ fâ‚‚\naâœ : LE.le gâ‚ gâ‚‚\nâŠ¢ LE.le (HVAdd.hVAdd fâ‚ gâ‚) (HVAdd.hVAdd fâ‚‚ gâ‚‚)","decl":"@[to_additive]\ntheorem smul_le_smul : fâ‚ â‰¤ fâ‚‚ â†’ gâ‚ â‰¤ gâ‚‚ â†’ fâ‚ â€¢ gâ‚ â‰¤ fâ‚‚ â€¢ gâ‚‚ :=\n  mapâ‚‚_mono\n\n"}
{"name":"Filter.smul_le_smul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nfâ‚ fâ‚‚ : Filter Î±\ngâ‚ gâ‚‚ : Filter Î²\naâœÂ¹ : LE.le fâ‚ fâ‚‚\naâœ : LE.le gâ‚ gâ‚‚\nâŠ¢ LE.le (HSMul.hSMul fâ‚ gâ‚) (HSMul.hSMul fâ‚‚ gâ‚‚)","decl":"@[to_additive]\ntheorem smul_le_smul : fâ‚ â‰¤ fâ‚‚ â†’ gâ‚ â‰¤ gâ‚‚ â†’ fâ‚ â€¢ gâ‚ â‰¤ fâ‚‚ â€¢ gâ‚‚ :=\n  mapâ‚‚_mono\n\n"}
{"name":"Filter.vadd_le_vadd_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nf : Filter Î±\ngâ‚ gâ‚‚ : Filter Î²\naâœ : LE.le gâ‚ gâ‚‚\nâŠ¢ LE.le (HVAdd.hVAdd f gâ‚) (HVAdd.hVAdd f gâ‚‚)","decl":"@[to_additive]\ntheorem smul_le_smul_left : gâ‚ â‰¤ gâ‚‚ â†’ f â€¢ gâ‚ â‰¤ f â€¢ gâ‚‚ :=\n  mapâ‚‚_mono_left\n\n"}
{"name":"Filter.smul_le_smul_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nf : Filter Î±\ngâ‚ gâ‚‚ : Filter Î²\naâœ : LE.le gâ‚ gâ‚‚\nâŠ¢ LE.le (HSMul.hSMul f gâ‚) (HSMul.hSMul f gâ‚‚)","decl":"@[to_additive]\ntheorem smul_le_smul_left : gâ‚ â‰¤ gâ‚‚ â†’ f â€¢ gâ‚ â‰¤ f â€¢ gâ‚‚ :=\n  mapâ‚‚_mono_left\n\n"}
{"name":"Filter.vadd_le_vadd_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nfâ‚ fâ‚‚ : Filter Î±\ng : Filter Î²\naâœ : LE.le fâ‚ fâ‚‚\nâŠ¢ LE.le (HVAdd.hVAdd fâ‚ g) (HVAdd.hVAdd fâ‚‚ g)","decl":"@[to_additive]\ntheorem smul_le_smul_right : fâ‚ â‰¤ fâ‚‚ â†’ fâ‚ â€¢ g â‰¤ fâ‚‚ â€¢ g :=\n  mapâ‚‚_mono_right\n\n"}
{"name":"Filter.smul_le_smul_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nfâ‚ fâ‚‚ : Filter Î±\ng : Filter Î²\naâœ : LE.le fâ‚ fâ‚‚\nâŠ¢ LE.le (HSMul.hSMul fâ‚ g) (HSMul.hSMul fâ‚‚ g)","decl":"@[to_additive]\ntheorem smul_le_smul_right : fâ‚ â‰¤ fâ‚‚ â†’ fâ‚ â€¢ g â‰¤ fâ‚‚ â€¢ g :=\n  mapâ‚‚_mono_right\n\n"}
{"name":"Filter.le_vadd_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nf : Filter Î±\ng h : Filter Î²\nâŠ¢ Iff (LE.le h (HVAdd.hVAdd f g)) (âˆ€ â¦ƒs : Set Î±â¦„, Membership.mem f s â†’ âˆ€ â¦ƒt : Set Î²â¦„, Membership.mem g t â†’ Membership.mem h (HVAdd.hVAdd s t))","decl":"@[to_additive (attr := simp)]\ntheorem le_smul_iff : h â‰¤ f â€¢ g â†” âˆ€ â¦ƒsâ¦„, s âˆˆ f â†’ âˆ€ â¦ƒtâ¦„, t âˆˆ g â†’ s â€¢ t âˆˆ h :=\n  le_mapâ‚‚_iff\n\n"}
{"name":"Filter.le_smul_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nf : Filter Î±\ng h : Filter Î²\nâŠ¢ Iff (LE.le h (HSMul.hSMul f g)) (âˆ€ â¦ƒs : Set Î±â¦„, Membership.mem f s â†’ âˆ€ â¦ƒt : Set Î²â¦„, Membership.mem g t â†’ Membership.mem h (HSMul.hSMul s t))","decl":"@[to_additive (attr := simp)]\ntheorem le_smul_iff : h â‰¤ f â€¢ g â†” âˆ€ â¦ƒsâ¦„, s âˆˆ f â†’ âˆ€ â¦ƒtâ¦„, t âˆˆ g â†’ s â€¢ t âˆˆ h :=\n  le_mapâ‚‚_iff\n\n"}
{"name":"Filter.covariant_vadd","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nâŠ¢ CovariantClass (Filter Î±) (Filter Î²) (fun x1 x2 => HVAdd.hVAdd x1 x2) fun x1 x2 => LE.le x1 x2","decl":"@[to_additive]\ninstance covariant_smul : CovariantClass (Filter Î±) (Filter Î²) (Â· â€¢ Â·) (Â· â‰¤ Â·) :=\n  âŸ¨fun _ _ _ => mapâ‚‚_mono_leftâŸ©\n\n"}
{"name":"Filter.covariant_smul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nâŠ¢ CovariantClass (Filter Î±) (Filter Î²) (fun x1 x2 => HSMul.hSMul x1 x2) fun x1 x2 => LE.le x1 x2","decl":"@[to_additive]\ninstance covariant_smul : CovariantClass (Filter Î±) (Filter Î²) (Â· â€¢ Â·) (Â· â‰¤ Â·) :=\n  âŸ¨fun _ _ _ => mapâ‚‚_mono_leftâŸ©\n\n"}
{"name":"Filter.mapâ‚‚_vsub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VSub Î± Î²\nf g : Filter Î²\nâŠ¢ Eq (Filter.mapâ‚‚ (fun x1 x2 => VSub.vsub x1 x2) f g) (VSub.vsub f g)","decl":"@[simp]\ntheorem mapâ‚‚_vsub : mapâ‚‚ (Â· -áµ¥ Â·) f g = f -áµ¥ g :=\n  rfl\n\n"}
{"name":"Filter.mem_vsub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VSub Î± Î²\nf g : Filter Î²\ns : Set Î±\nâŠ¢ Iff (Membership.mem (VSub.vsub f g) s) (Exists fun tâ‚ => And (Membership.mem f tâ‚) (Exists fun tâ‚‚ => And (Membership.mem g tâ‚‚) (HasSubset.Subset (VSub.vsub tâ‚ tâ‚‚) s)))","decl":"theorem mem_vsub {s : Set Î±} : s âˆˆ f -áµ¥ g â†” âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, tâ‚ -áµ¥ tâ‚‚ âŠ† s :=\n  Iff.rfl\n\n"}
{"name":"Filter.vsub_mem_vsub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VSub Î± Î²\nf g : Filter Î²\ns t : Set Î²\naâœÂ¹ : Membership.mem f s\naâœ : Membership.mem g t\nâŠ¢ Membership.mem (VSub.vsub f g) (VSub.vsub s t)","decl":"theorem vsub_mem_vsub : s âˆˆ f â†’ t âˆˆ g â†’ s -áµ¥ t âˆˆ f -áµ¥ g :=\n  image2_mem_mapâ‚‚\n\n"}
{"name":"Filter.bot_vsub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VSub Î± Î²\ng : Filter Î²\nâŠ¢ Eq (VSub.vsub Bot.bot g) Bot.bot","decl":"@[simp]\ntheorem bot_vsub : (âŠ¥ : Filter Î²) -áµ¥ g = âŠ¥ :=\n  mapâ‚‚_bot_left\n\n"}
{"name":"Filter.vsub_bot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VSub Î± Î²\nf : Filter Î²\nâŠ¢ Eq (VSub.vsub f Bot.bot) Bot.bot","decl":"@[simp]\ntheorem vsub_bot : f -áµ¥ (âŠ¥ : Filter Î²) = âŠ¥ :=\n  mapâ‚‚_bot_right\n\n"}
{"name":"Filter.vsub_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VSub Î± Î²\nf g : Filter Î²\nâŠ¢ Iff (Eq (VSub.vsub f g) Bot.bot) (Or (Eq f Bot.bot) (Eq g Bot.bot))","decl":"@[simp]\ntheorem vsub_eq_bot_iff : f -áµ¥ g = âŠ¥ â†” f = âŠ¥ âˆ¨ g = âŠ¥ :=\n  mapâ‚‚_eq_bot_iff\n\n"}
{"name":"Filter.vsub_neBot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VSub Î± Î²\nf g : Filter Î²\nâŠ¢ Iff (VSub.vsub f g).NeBot (And f.NeBot g.NeBot)","decl":"@[simp]\ntheorem vsub_neBot_iff : (f -áµ¥ g : Filter Î±).NeBot â†” f.NeBot âˆ§ g.NeBot :=\n  mapâ‚‚_neBot_iff\n\n"}
{"name":"Filter.NeBot.vsub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VSub Î± Î²\nf g : Filter Î²\naâœÂ¹ : f.NeBot\naâœ : g.NeBot\nâŠ¢ (VSub.vsub f g).NeBot","decl":"protected theorem NeBot.vsub : NeBot f â†’ NeBot g â†’ NeBot (f -áµ¥ g) :=\n  NeBot.mapâ‚‚\n\n"}
{"name":"Filter.NeBot.of_vsub_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VSub Î± Î²\nf g : Filter Î²\naâœ : (VSub.vsub f g).NeBot\nâŠ¢ f.NeBot","decl":"theorem NeBot.of_vsub_left : (f -áµ¥ g : Filter Î±).NeBot â†’ f.NeBot :=\n  NeBot.of_mapâ‚‚_left\n\n"}
{"name":"Filter.NeBot.of_vsub_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VSub Î± Î²\nf g : Filter Î²\naâœ : (VSub.vsub f g).NeBot\nâŠ¢ g.NeBot","decl":"theorem NeBot.of_vsub_right : (f -áµ¥ g : Filter Î±).NeBot â†’ g.NeBot :=\n  NeBot.of_mapâ‚‚_right\n\n"}
{"name":"Filter.vsub.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ² : VSub Î± Î²\nf g : Filter Î²\ninstâœÂ¹ : f.NeBot\ninstâœ : g.NeBot\nâŠ¢ (VSub.vsub f g).NeBot","decl":"lemma vsub.instNeBot [NeBot f] [NeBot g] : NeBot (f -áµ¥ g) := .vsub â€¹_â€º â€¹_â€º\n\n"}
{"name":"Filter.pure_vsub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VSub Î± Î²\ng : Filter Î²\na : Î²\nâŠ¢ Eq (VSub.vsub (Pure.pure a) g) (Filter.map (fun x => VSub.vsub a x) g)","decl":"@[simp]\ntheorem pure_vsub : (pure a : Filter Î²) -áµ¥ g = g.map (a -áµ¥ Â·) :=\n  mapâ‚‚_pure_left\n\n"}
{"name":"Filter.vsub_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VSub Î± Î²\nf : Filter Î²\nb : Î²\nâŠ¢ Eq (VSub.vsub f (Pure.pure b)) (Filter.map (fun x => VSub.vsub x b) f)","decl":"@[simp]\ntheorem vsub_pure : f -áµ¥ pure b = f.map (Â· -áµ¥ b) :=\n  mapâ‚‚_pure_right\n\n"}
{"name":"Filter.pure_vsub_pure","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VSub Î± Î²\na b : Î²\nâŠ¢ Eq (VSub.vsub (Pure.pure a) (Pure.pure b)) (Pure.pure (VSub.vsub a b))","decl":"theorem pure_vsub_pure : (pure a : Filter Î²) -áµ¥ pure b = (pure (a -áµ¥ b) : Filter Î±) := by simp\n\n"}
{"name":"Filter.vsub_le_vsub","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VSub Î± Î²\nfâ‚ fâ‚‚ gâ‚ gâ‚‚ : Filter Î²\naâœÂ¹ : LE.le fâ‚ fâ‚‚\naâœ : LE.le gâ‚ gâ‚‚\nâŠ¢ LE.le (VSub.vsub fâ‚ gâ‚) (VSub.vsub fâ‚‚ gâ‚‚)","decl":"theorem vsub_le_vsub : fâ‚ â‰¤ fâ‚‚ â†’ gâ‚ â‰¤ gâ‚‚ â†’ fâ‚ -áµ¥ gâ‚ â‰¤ fâ‚‚ -áµ¥ gâ‚‚ :=\n  mapâ‚‚_mono\n\n"}
{"name":"Filter.vsub_le_vsub_left","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VSub Î± Î²\nf gâ‚ gâ‚‚ : Filter Î²\naâœ : LE.le gâ‚ gâ‚‚\nâŠ¢ LE.le (VSub.vsub f gâ‚) (VSub.vsub f gâ‚‚)","decl":"theorem vsub_le_vsub_left : gâ‚ â‰¤ gâ‚‚ â†’ f -áµ¥ gâ‚ â‰¤ f -áµ¥ gâ‚‚ :=\n  mapâ‚‚_mono_left\n\n"}
{"name":"Filter.vsub_le_vsub_right","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VSub Î± Î²\nfâ‚ fâ‚‚ g : Filter Î²\naâœ : LE.le fâ‚ fâ‚‚\nâŠ¢ LE.le (VSub.vsub fâ‚ g) (VSub.vsub fâ‚‚ g)","decl":"theorem vsub_le_vsub_right : fâ‚ â‰¤ fâ‚‚ â†’ fâ‚ -áµ¥ g â‰¤ fâ‚‚ -áµ¥ g :=\n  mapâ‚‚_mono_right\n\n"}
{"name":"Filter.le_vsub_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VSub Î± Î²\nf g : Filter Î²\nh : Filter Î±\nâŠ¢ Iff (LE.le h (VSub.vsub f g)) (âˆ€ â¦ƒs : Set Î²â¦„, Membership.mem f s â†’ âˆ€ â¦ƒt : Set Î²â¦„, Membership.mem g t â†’ Membership.mem h (VSub.vsub s t))","decl":"@[simp]\ntheorem le_vsub_iff : h â‰¤ f -áµ¥ g â†” âˆ€ â¦ƒsâ¦„, s âˆˆ f â†’ âˆ€ â¦ƒtâ¦„, t âˆˆ g â†’ s -áµ¥ t âˆˆ h :=\n  le_mapâ‚‚_iff\n\n"}
{"name":"Filter.map_smul","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nf : Filter Î²\na : Î±\nâŠ¢ Eq (Filter.map (fun b => HSMul.hSMul a b) f) (HSMul.hSMul a f)","decl":"@[to_additive (attr := simp)]\nprotected theorem map_smul : map (fun b => a â€¢ b) f = a â€¢ f :=\n  rfl\n\n"}
{"name":"Filter.map_vadd","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nf : Filter Î²\na : Î±\nâŠ¢ Eq (Filter.map (fun b => HVAdd.hVAdd a b) f) (HVAdd.hVAdd a f)","decl":"@[to_additive (attr := simp)]\nprotected theorem map_smul : map (fun b => a â€¢ b) f = a â€¢ f :=\n  rfl\n\n"}
{"name":"Filter.mem_vadd_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nf : Filter Î²\ns : Set Î²\na : Î±\nâŠ¢ Iff (Membership.mem (HVAdd.hVAdd a f) s) (Membership.mem f (Set.preimage (fun x => HVAdd.hVAdd a x) s))","decl":"@[to_additive]\ntheorem mem_smul_filter : s âˆˆ a â€¢ f â†” (a â€¢ Â·) â»Â¹' s âˆˆ f := Iff.rfl\n\n"}
{"name":"Filter.mem_smul_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nf : Filter Î²\ns : Set Î²\na : Î±\nâŠ¢ Iff (Membership.mem (HSMul.hSMul a f) s) (Membership.mem f (Set.preimage (fun x => HSMul.hSMul a x) s))","decl":"@[to_additive]\ntheorem mem_smul_filter : s âˆˆ a â€¢ f â†” (a â€¢ Â·) â»Â¹' s âˆˆ f := Iff.rfl\n\n"}
{"name":"Filter.smul_set_mem_smul_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nf : Filter Î²\ns : Set Î²\na : Î±\naâœ : Membership.mem f s\nâŠ¢ Membership.mem (HSMul.hSMul a f) (HSMul.hSMul a s)","decl":"@[to_additive]\ntheorem smul_set_mem_smul_filter : s âˆˆ f â†’ a â€¢ s âˆˆ a â€¢ f :=\n  image_mem_map\n\n"}
{"name":"Filter.vadd_set_mem_vadd_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nf : Filter Î²\ns : Set Î²\na : Î±\naâœ : Membership.mem f s\nâŠ¢ Membership.mem (HVAdd.hVAdd a f) (HVAdd.hVAdd a s)","decl":"@[to_additive]\ntheorem smul_set_mem_smul_filter : s âˆˆ f â†’ a â€¢ s âˆˆ a â€¢ f :=\n  image_mem_map\n\n"}
{"name":"Filter.smul_filter_bot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\na : Î±\nâŠ¢ Eq (HSMul.hSMul a Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem smul_filter_bot : a â€¢ (âŠ¥ : Filter Î²) = âŠ¥ :=\n  map_bot\n\n"}
{"name":"Filter.vadd_filter_bot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\na : Î±\nâŠ¢ Eq (HVAdd.hVAdd a Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem smul_filter_bot : a â€¢ (âŠ¥ : Filter Î²) = âŠ¥ :=\n  map_bot\n\n"}
{"name":"Filter.vadd_filter_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nf : Filter Î²\na : Î±\nâŠ¢ Iff (Eq (HVAdd.hVAdd a f) Bot.bot) (Eq f Bot.bot)","decl":"@[to_additive (attr := simp)]\ntheorem smul_filter_eq_bot_iff : a â€¢ f = âŠ¥ â†” f = âŠ¥ :=\n  map_eq_bot_iff\n\n"}
{"name":"Filter.smul_filter_eq_bot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nf : Filter Î²\na : Î±\nâŠ¢ Iff (Eq (HSMul.hSMul a f) Bot.bot) (Eq f Bot.bot)","decl":"@[to_additive (attr := simp)]\ntheorem smul_filter_eq_bot_iff : a â€¢ f = âŠ¥ â†” f = âŠ¥ :=\n  map_eq_bot_iff\n\n"}
{"name":"Filter.smul_filter_neBot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nf : Filter Î²\na : Î±\nâŠ¢ Iff (HSMul.hSMul a f).NeBot f.NeBot","decl":"@[to_additive (attr := simp)]\ntheorem smul_filter_neBot_iff : (a â€¢ f).NeBot â†” f.NeBot :=\n  map_neBot_iff _\n\n"}
{"name":"Filter.vadd_filter_neBot_iff","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nf : Filter Î²\na : Î±\nâŠ¢ Iff (HVAdd.hVAdd a f).NeBot f.NeBot","decl":"@[to_additive (attr := simp)]\ntheorem smul_filter_neBot_iff : (a â€¢ f).NeBot â†” f.NeBot :=\n  map_neBot_iff _\n\n"}
{"name":"Filter.NeBot.smul_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nf : Filter Î²\na : Î±\naâœ : f.NeBot\nâŠ¢ (HSMul.hSMul a f).NeBot","decl":"@[to_additive]\ntheorem NeBot.smul_filter : f.NeBot â†’ (a â€¢ f).NeBot := fun h => h.map _\n\n"}
{"name":"Filter.NeBot.vadd_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nf : Filter Î²\na : Î±\naâœ : f.NeBot\nâŠ¢ (HVAdd.hVAdd a f).NeBot","decl":"@[to_additive]\ntheorem NeBot.smul_filter : f.NeBot â†’ (a â€¢ f).NeBot := fun h => h.map _\n\n"}
{"name":"Filter.NeBot.of_vadd_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nf : Filter Î²\na : Î±\naâœ : (HVAdd.hVAdd a f).NeBot\nâŠ¢ f.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_smul_filter : (a â€¢ f).NeBot â†’ f.NeBot :=\n  NeBot.of_map\n\n"}
{"name":"Filter.NeBot.of_smul_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nf : Filter Î²\na : Î±\naâœ : (HSMul.hSMul a f).NeBot\nâŠ¢ f.NeBot","decl":"@[to_additive]\ntheorem NeBot.of_smul_filter : (a â€¢ f).NeBot â†’ f.NeBot :=\n  NeBot.of_map\n\n"}
{"name":"Filter.vadd_filter.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : VAdd Î± Î²\nf : Filter Î²\na : Î±\ninstâœ : f.NeBot\nâŠ¢ (HVAdd.hVAdd a f).NeBot","decl":"@[to_additive vadd_filter.instNeBot]\nlemma smul_filter.instNeBot [NeBot f] : NeBot (a â€¢ f) := .smul_filter â€¹_â€º\n\n"}
{"name":"Filter.smul_filter.instNeBot","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : SMul Î± Î²\nf : Filter Î²\na : Î±\ninstâœ : f.NeBot\nâŠ¢ (HSMul.hSMul a f).NeBot","decl":"@[to_additive vadd_filter.instNeBot]\nlemma smul_filter.instNeBot [NeBot f] : NeBot (a â€¢ f) := .smul_filter â€¹_â€º\n\n"}
{"name":"Filter.vadd_filter_le_vadd_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nfâ‚ fâ‚‚ : Filter Î²\na : Î±\nhf : LE.le fâ‚ fâ‚‚\nâŠ¢ LE.le (HVAdd.hVAdd a fâ‚) (HVAdd.hVAdd a fâ‚‚)","decl":"@[to_additive]\ntheorem smul_filter_le_smul_filter (hf : fâ‚ â‰¤ fâ‚‚) : a â€¢ fâ‚ â‰¤ a â€¢ fâ‚‚ :=\n  map_mono hf\n\n"}
{"name":"Filter.smul_filter_le_smul_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nfâ‚ fâ‚‚ : Filter Î²\na : Î±\nhf : LE.le fâ‚ fâ‚‚\nâŠ¢ LE.le (HSMul.hSMul a fâ‚) (HSMul.hSMul a fâ‚‚)","decl":"@[to_additive]\ntheorem smul_filter_le_smul_filter (hf : fâ‚ â‰¤ fâ‚‚) : a â€¢ fâ‚ â‰¤ a â€¢ fâ‚‚ :=\n  map_mono hf\n\n"}
{"name":"Filter.covariant_vadd_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : VAdd Î± Î²\nâŠ¢ CovariantClass Î± (Filter Î²) (fun x1 x2 => HVAdd.hVAdd x1 x2) fun x1 x2 => LE.le x1 x2","decl":"@[to_additive]\ninstance covariant_smul_filter : CovariantClass Î± (Filter Î²) (Â· â€¢ Â·) (Â· â‰¤ Â·) :=\n  âŸ¨fun _ => @map_mono Î² Î² _âŸ©\n\n"}
{"name":"Filter.covariant_smul_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SMul Î± Î²\nâŠ¢ CovariantClass Î± (Filter Î²) (fun x1 x2 => HSMul.hSMul x1 x2) fun x1 x2 => LE.le x1 x2","decl":"@[to_additive]\ninstance covariant_smul_filter : CovariantClass Î± (Filter Î²) (Â· â€¢ Â·) (Â· â‰¤ Â·) :=\n  âŸ¨fun _ => @map_mono Î² Î² _âŸ©\n\n"}
{"name":"Filter.vaddCommClass_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ² : VAdd Î± Î³\ninstâœÂ¹ : VAdd Î² Î³\ninstâœ : VAddCommClass Î± Î² Î³\nâŠ¢ VAddCommClass Î± Î² (Filter Î³)","decl":"@[to_additive]\ninstance smulCommClass_filter [SMul Î± Î³] [SMul Î² Î³] [SMulCommClass Î± Î² Î³] :\n    SMulCommClass Î± Î² (Filter Î³) :=\n  âŸ¨fun _ _ _ => map_comm (funext <| smul_comm _ _) _âŸ©\n\n"}
{"name":"Filter.smulCommClass_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ² : SMul Î± Î³\ninstâœÂ¹ : SMul Î² Î³\ninstâœ : SMulCommClass Î± Î² Î³\nâŠ¢ SMulCommClass Î± Î² (Filter Î³)","decl":"@[to_additive]\ninstance smulCommClass_filter [SMul Î± Î³] [SMul Î² Î³] [SMulCommClass Î± Î² Î³] :\n    SMulCommClass Î± Î² (Filter Î³) :=\n  âŸ¨fun _ _ _ => map_comm (funext <| smul_comm _ _) _âŸ©\n\n"}
{"name":"Filter.smulCommClass_filter'","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ² : SMul Î± Î³\ninstâœÂ¹ : SMul Î² Î³\ninstâœ : SMulCommClass Î± Î² Î³\nâŠ¢ SMulCommClass Î± (Filter Î²) (Filter Î³)","decl":"@[to_additive]\ninstance smulCommClass_filter' [SMul Î± Î³] [SMul Î² Î³] [SMulCommClass Î± Î² Î³] :\n    SMulCommClass Î± (Filter Î²) (Filter Î³) :=\n  âŸ¨fun a _ _ => map_mapâ‚‚_distrib_right <| smul_comm aâŸ©\n\n"}
{"name":"Filter.vaddCommClass_filter'","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ² : VAdd Î± Î³\ninstâœÂ¹ : VAdd Î² Î³\ninstâœ : VAddCommClass Î± Î² Î³\nâŠ¢ VAddCommClass Î± (Filter Î²) (Filter Î³)","decl":"@[to_additive]\ninstance smulCommClass_filter' [SMul Î± Î³] [SMul Î² Î³] [SMulCommClass Î± Î² Î³] :\n    SMulCommClass Î± (Filter Î²) (Filter Î³) :=\n  âŸ¨fun a _ _ => map_mapâ‚‚_distrib_right <| smul_comm aâŸ©\n\n"}
{"name":"Filter.smulCommClass_filter''","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ² : SMul Î± Î³\ninstâœÂ¹ : SMul Î² Î³\ninstâœ : SMulCommClass Î± Î² Î³\nâŠ¢ SMulCommClass (Filter Î±) Î² (Filter Î³)","decl":"@[to_additive]\ninstance smulCommClass_filter'' [SMul Î± Î³] [SMul Î² Î³] [SMulCommClass Î± Î² Î³] :\n    SMulCommClass (Filter Î±) Î² (Filter Î³) :=\n  haveI := SMulCommClass.symm Î± Î² Î³\n  SMulCommClass.symm _ _ _\n\n"}
{"name":"Filter.vaddCommClass_filter''","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ² : VAdd Î± Î³\ninstâœÂ¹ : VAdd Î² Î³\ninstâœ : VAddCommClass Î± Î² Î³\nâŠ¢ VAddCommClass (Filter Î±) Î² (Filter Î³)","decl":"@[to_additive]\ninstance smulCommClass_filter'' [SMul Î± Î³] [SMul Î² Î³] [SMulCommClass Î± Î² Î³] :\n    SMulCommClass (Filter Î±) Î² (Filter Î³) :=\n  haveI := SMulCommClass.symm Î± Î² Î³\n  SMulCommClass.symm _ _ _\n\n"}
{"name":"Filter.vaddCommClass","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ² : VAdd Î± Î³\ninstâœÂ¹ : VAdd Î² Î³\ninstâœ : VAddCommClass Î± Î² Î³\nâŠ¢ VAddCommClass (Filter Î±) (Filter Î²) (Filter Î³)","decl":"@[to_additive]\ninstance smulCommClass [SMul Î± Î³] [SMul Î² Î³] [SMulCommClass Î± Î² Î³] :\n    SMulCommClass (Filter Î±) (Filter Î²) (Filter Î³) :=\n  âŸ¨fun _ _ _ => mapâ‚‚_left_comm smul_commâŸ©\n\n"}
{"name":"Filter.smulCommClass","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ² : SMul Î± Î³\ninstâœÂ¹ : SMul Î² Î³\ninstâœ : SMulCommClass Î± Î² Î³\nâŠ¢ SMulCommClass (Filter Î±) (Filter Î²) (Filter Î³)","decl":"@[to_additive]\ninstance smulCommClass [SMul Î± Î³] [SMul Î² Î³] [SMulCommClass Î± Î² Î³] :\n    SMulCommClass (Filter Î±) (Filter Î²) (Filter Î³) :=\n  âŸ¨fun _ _ _ => mapâ‚‚_left_comm smul_commâŸ©\n\n"}
{"name":"Filter.isScalarTower","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ³ : SMul Î± Î²\ninstâœÂ² : SMul Î± Î³\ninstâœÂ¹ : SMul Î² Î³\ninstâœ : IsScalarTower Î± Î² Î³\nâŠ¢ IsScalarTower Î± Î² (Filter Î³)","decl":"@[to_additive vaddAssocClass]\ninstance isScalarTower [SMul Î± Î²] [SMul Î± Î³] [SMul Î² Î³] [IsScalarTower Î± Î² Î³] :\n    IsScalarTower Î± Î² (Filter Î³) :=\n  âŸ¨fun a b f => by simp only [â† Filter.map_smul, map_map, smul_assoc]; rflâŸ©\n\n"}
{"name":"Filter.vaddAssocClass","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ³ : VAdd Î± Î²\ninstâœÂ² : VAdd Î± Î³\ninstâœÂ¹ : VAdd Î² Î³\ninstâœ : VAddAssocClass Î± Î² Î³\nâŠ¢ VAddAssocClass Î± Î² (Filter Î³)","decl":"@[to_additive vaddAssocClass]\ninstance isScalarTower [SMul Î± Î²] [SMul Î± Î³] [SMul Î² Î³] [IsScalarTower Î± Î² Î³] :\n    IsScalarTower Î± Î² (Filter Î³) :=\n  âŸ¨fun a b f => by simp only [â† Filter.map_smul, map_map, smul_assoc]; rflâŸ©\n\n"}
{"name":"Filter.vaddAssocClass'","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ³ : VAdd Î± Î²\ninstâœÂ² : VAdd Î± Î³\ninstâœÂ¹ : VAdd Î² Î³\ninstâœ : VAddAssocClass Î± Î² Î³\nâŠ¢ VAddAssocClass Î± (Filter Î²) (Filter Î³)","decl":"@[to_additive vaddAssocClass']\ninstance isScalarTower' [SMul Î± Î²] [SMul Î± Î³] [SMul Î² Î³] [IsScalarTower Î± Î² Î³] :\n    IsScalarTower Î± (Filter Î²) (Filter Î³) :=\n  âŸ¨fun a f g => by\n    refine (map_mapâ‚‚_distrib_left fun _ _ => ?_).symm\n    exact (smul_assoc a _ _).symmâŸ©\n\n"}
{"name":"Filter.isScalarTower'","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ³ : SMul Î± Î²\ninstâœÂ² : SMul Î± Î³\ninstâœÂ¹ : SMul Î² Î³\ninstâœ : IsScalarTower Î± Î² Î³\nâŠ¢ IsScalarTower Î± (Filter Î²) (Filter Î³)","decl":"@[to_additive vaddAssocClass']\ninstance isScalarTower' [SMul Î± Î²] [SMul Î± Î³] [SMul Î² Î³] [IsScalarTower Î± Î² Î³] :\n    IsScalarTower Î± (Filter Î²) (Filter Î³) :=\n  âŸ¨fun a f g => by\n    refine (map_mapâ‚‚_distrib_left fun _ _ => ?_).symm\n    exact (smul_assoc a _ _).symmâŸ©\n\n"}
{"name":"Filter.isScalarTower''","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ³ : SMul Î± Î²\ninstâœÂ² : SMul Î± Î³\ninstâœÂ¹ : SMul Î² Î³\ninstâœ : IsScalarTower Î± Î² Î³\nâŠ¢ IsScalarTower (Filter Î±) (Filter Î²) (Filter Î³)","decl":"@[to_additive vaddAssocClass'']\ninstance isScalarTower'' [SMul Î± Î²] [SMul Î± Î³] [SMul Î² Î³] [IsScalarTower Î± Î² Î³] :\n    IsScalarTower (Filter Î±) (Filter Î²) (Filter Î³) :=\n  âŸ¨fun _ _ _ => mapâ‚‚_assoc smul_assocâŸ©\n\n"}
{"name":"Filter.vaddAssocClass''","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ³ : VAdd Î± Î²\ninstâœÂ² : VAdd Î± Î³\ninstâœÂ¹ : VAdd Î² Î³\ninstâœ : VAddAssocClass Î± Î² Î³\nâŠ¢ VAddAssocClass (Filter Î±) (Filter Î²) (Filter Î³)","decl":"@[to_additive vaddAssocClass'']\ninstance isScalarTower'' [SMul Î± Î²] [SMul Î± Î³] [SMul Î² Î³] [IsScalarTower Î± Î² Î³] :\n    IsScalarTower (Filter Î±) (Filter Î²) (Filter Î³) :=\n  âŸ¨fun _ _ _ => mapâ‚‚_assoc smul_assocâŸ©\n\n"}
{"name":"Filter.isCentralScalar","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ² : SMul Î± Î²\ninstâœÂ¹ : SMul (MulOpposite Î±) Î²\ninstâœ : IsCentralScalar Î± Î²\nâŠ¢ IsCentralScalar Î± (Filter Î²)","decl":"@[to_additive]\ninstance isCentralScalar [SMul Î± Î²] [SMul Î±áµáµ’áµ– Î²] [IsCentralScalar Î± Î²] :\n    IsCentralScalar Î± (Filter Î²) :=\n  âŸ¨fun _ f => (congr_arg fun m => map m f) <| funext fun _ => op_smul_eq_smul _ _âŸ©\n\n"}
{"name":"Filter.isCentralVAdd","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ² : VAdd Î± Î²\ninstâœÂ¹ : VAdd (AddOpposite Î±) Î²\ninstâœ : IsCentralVAdd Î± Î²\nâŠ¢ IsCentralVAdd Î± (Filter Î²)","decl":"@[to_additive]\ninstance isCentralScalar [SMul Î± Î²] [SMul Î±áµáµ’áµ– Î²] [IsCentralScalar Î± Î²] :\n    IsCentralScalar Î± (Filter Î²) :=\n  âŸ¨fun _ f => (congr_arg fun m => map m f) <| funext fun _ => op_smul_eq_smul _ _âŸ©\n\n"}
{"name":"Filter.NeBot.smul_zero_nonneg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ² : Zero Î±\ninstâœÂ¹ : Zero Î²\ninstâœ : SMulWithZero Î± Î²\nf : Filter Î±\nhf : f.NeBot\nâŠ¢ LE.le 0 (HSMul.hSMul f 0)","decl":"theorem NeBot.smul_zero_nonneg (hf : f.NeBot) : 0 â‰¤ f â€¢ (0 : Filter Î²) :=\n  le_smul_iff.2 fun _ hâ‚ _ hâ‚‚ =>\n    let âŸ¨_, haâŸ© := hf.nonempty_of_mem hâ‚\n    âŸ¨_, ha, _, hâ‚‚, smul_zero _âŸ©\n\n"}
{"name":"Filter.NeBot.zero_smul_nonneg","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ² : Zero Î±\ninstâœÂ¹ : Zero Î²\ninstâœ : SMulWithZero Î± Î²\ng : Filter Î²\nhg : g.NeBot\nâŠ¢ LE.le 0 (HSMul.hSMul 0 g)","decl":"theorem NeBot.zero_smul_nonneg (hg : g.NeBot) : 0 â‰¤ (0 : Filter Î±) â€¢ g :=\n  le_smul_iff.2 fun _ hâ‚ _ hâ‚‚ =>\n    let âŸ¨_, hbâŸ© := hg.nonempty_of_mem hâ‚‚\n    âŸ¨_, hâ‚, _, hb, zero_smul _ _âŸ©\n\n"}
{"name":"Filter.zero_smul_filter_nonpos","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ² : Zero Î±\ninstâœÂ¹ : Zero Î²\ninstâœ : SMulWithZero Î± Î²\ng : Filter Î²\nâŠ¢ LE.le (HSMul.hSMul 0 g) 0","decl":"theorem zero_smul_filter_nonpos : (0 : Î±) â€¢ g â‰¤ 0 := by\n  refine fun s hs => mem_smul_filter.2 ?_\n  convert @univ_mem _ g\n  refine eq_univ_iff_forall.2 fun a => ?_\n  rwa [mem_preimage, zero_smul]\n\n"}
{"name":"Filter.zero_smul_filter","module":"Mathlib.Order.Filter.Pointwise","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ² : Zero Î±\ninstâœÂ¹ : Zero Î²\ninstâœ : SMulWithZero Î± Î²\ng : Filter Î²\nhg : g.NeBot\nâŠ¢ Eq (HSMul.hSMul 0 g) 0","decl":"theorem zero_smul_filter (hg : g.NeBot) : (0 : Î±) â€¢ g = 0 :=\n  zero_smul_filter_nonpos.antisymm <|\n    le_map_iff.2 fun s hs => by\n      simp_rw [zero_smul, (hg.nonempty_of_mem hs).image_const]\n      exact zero_mem_zero\n\n"}
