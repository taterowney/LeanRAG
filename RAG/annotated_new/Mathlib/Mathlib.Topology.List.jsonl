{"name":"nhds_list","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\nas : List Î±\nâŠ¢ Eq (nhds as) (Traversable.traverse nhds as)","decl":"theorem nhds_list (as : List Î±) : ğ“ as = traverse ğ“ as := by\n  refine nhds_mkOfNhds _ _ ?_ ?_\n  Â· intro l\n    induction l with\n    | nil => exact le_rfl\n    | cons a l ih =>\n      suffices List.cons <$> pure a <*> pure l â‰¤ List.cons <$> ğ“ a <*> traverse ğ“ l by\n        simpa only [functor_norm] using this\n      exact Filter.seq_mono (Filter.map_mono <| pure_le_nhds a) ih\n  Â· intro l s hs\n    rcases (mem_traverse_iff _ _).1 hs with âŸ¨u, hu, husâŸ©\n    clear as hs\n    have : âˆƒ v : List (Set Î±), l.Forallâ‚‚ (fun a s => IsOpen s âˆ§ a âˆˆ s) v âˆ§ sequence v âŠ† s := by\n      induction hu generalizing s with\n      | nil =>\n        exists []\n        simp only [List.forallâ‚‚_nil_left_iff, exists_eq_left]\n        exact âŸ¨trivial, husâŸ©\n      -- porting note -- renamed reordered variables based on previous types\n      | cons ht _ ih =>\n        rcases mem_nhds_iff.1 ht with âŸ¨u, hut, huâŸ©\n        rcases ih _ Subset.rfl with âŸ¨v, hv, hvssâŸ©\n        exact\n          âŸ¨u::v, List.Forallâ‚‚.cons hu hv,\n            Subset.trans (Set.seq_mono (Set.image_subset _ hut) hvss) husâŸ©\n    rcases this with âŸ¨v, hv, hvsâŸ©\n    have : sequence v âˆˆ traverse ğ“ l :=\n      mem_traverse _ _ <| hv.imp fun a s âŸ¨hs, haâŸ© => IsOpen.mem_nhds hs ha\n    refine mem_of_superset this fun u hu â†¦ ?_\n    have hu := (List.mem_traverse _ _).1 hu\n    have : List.Forallâ‚‚ (fun a s => IsOpen s âˆ§ a âˆˆ s) u v := by\n      refine List.Forallâ‚‚.flip ?_\n      replace hv := hv.flip\n      simp only [List.forallâ‚‚_and_left, Function.flip_def] at hv âŠ¢\n      exact âŸ¨hv.1, hu.flipâŸ©\n    refine mem_of_superset ?_ hvs\n    exact mem_traverse _ _ (this.imp fun a s âŸ¨hs, haâŸ© => IsOpen.mem_nhds hs ha)\n\n"}
{"name":"nhds_nil","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\nâŠ¢ Eq (nhds List.nil) (Pure.pure List.nil)","decl":"@[simp]\ntheorem nhds_nil : ğ“ ([] : List Î±) = pure [] := by\n  rw [nhds_list, List.traverse_nil _]\n\n"}
{"name":"nhds_cons","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\na : Î±\nl : List Î±\nâŠ¢ Eq (nhds (List.cons a l)) (Seq.seq (Functor.map List.cons (nhds a)) fun x => nhds l)","decl":"theorem nhds_cons (a : Î±) (l : List Î±) : ğ“ (a::l) = List.cons <$> ğ“ a <*> ğ“ l := by\n  rw [nhds_list, List.traverse_cons _, â† nhds_list]\n\n"}
{"name":"List.tendsto_cons","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\na : Î±\nl : List Î±\nâŠ¢ Filter.Tendsto (fun p => List.cons p.1 p.2) (SProd.sprod (nhds a) (nhds l)) (nhds (List.cons a l))","decl":"theorem List.tendsto_cons {a : Î±} {l : List Î±} :\n    Tendsto (fun p : Î± Ã— List Î± => List.cons p.1 p.2) (ğ“ a Ã—Ë¢ ğ“ l) (ğ“ (a::l)) := by\n  rw [nhds_cons, Tendsto, Filter.map_prod]; exact le_rfl\n\n"}
{"name":"Filter.Tendsto.cons","module":"Mathlib.Topology.List","initialProofState":"Î² : Type u_2\ninstâœ : TopologicalSpace Î²\nÎ± : Type u_3\nf : Î± â†’ Î²\ng : Î± â†’ List Î²\na : Filter Î±\nb : Î²\nl : List Î²\nhf : Filter.Tendsto f a (nhds b)\nhg : Filter.Tendsto g a (nhds l)\nâŠ¢ Filter.Tendsto (fun a => List.cons (f a) (g a)) a (nhds (List.cons b l))","decl":"theorem Filter.Tendsto.cons {Î± : Type*} {f : Î± â†’ Î²} {g : Î± â†’ List Î²} {a : Filter Î±} {b : Î²}\n    {l : List Î²} (hf : Tendsto f a (ğ“ b)) (hg : Tendsto g a (ğ“ l)) :\n    Tendsto (fun a => List.cons (f a) (g a)) a (ğ“ (b::l)) :=\n  List.tendsto_cons.comp (Tendsto.prod_mk hf hg)\n\n"}
{"name":"List.tendsto_cons_iff","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\nÎ² : Type u_3\nf : List Î± â†’ Î²\nb : Filter Î²\na : Î±\nl : List Î±\nâŠ¢ Iff (Filter.Tendsto f (nhds (List.cons a l)) b) (Filter.Tendsto (fun p => f (List.cons p.1 p.2)) (SProd.sprod (nhds a) (nhds l)) b)","decl":"theorem tendsto_cons_iff {Î² : Type*} {f : List Î± â†’ Î²} {b : Filter Î²} {a : Î±} {l : List Î±} :\n    Tendsto f (ğ“ (a::l)) b â†” Tendsto (fun p : Î± Ã— List Î± => f (p.1::p.2)) (ğ“ a Ã—Ë¢ ğ“ l) b := by\n  have : ğ“ (a::l) = (ğ“ a Ã—Ë¢ ğ“ l).map fun p : Î± Ã— List Î± => p.1::p.2 := by\n    simp only [nhds_cons, Filter.prod_eq, (Filter.map_def _ _).symm,\n      (Filter.seq_eq_filter_seq _ _).symm]\n    simp [-Filter.map_def, Function.comp_def, functor_norm]\n  rw [this, Filter.tendsto_map'_iff]; rfl\n\n"}
{"name":"List.continuous_cons","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\nâŠ¢ Continuous fun x => List.cons x.1 x.2","decl":"theorem continuous_cons : Continuous fun x : Î± Ã— List Î± => (x.1::x.2 : List Î±) :=\n  continuous_iff_continuousAt.mpr fun âŸ¨_x, _yâŸ© => continuousAt_fst.cons continuousAt_snd\n\n"}
{"name":"List.tendsto_nhds","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\nÎ² : Type u_3\nf : List Î± â†’ Î²\nr : List Î± â†’ Filter Î²\nh_nil : Filter.Tendsto f (Pure.pure List.nil) (r List.nil)\nh_cons : âˆ€ (l : List Î±) (a : Î±), Filter.Tendsto f (nhds l) (r l) â†’ Filter.Tendsto (fun p => f (List.cons p.1 p.2)) (SProd.sprod (nhds a) (nhds l)) (r (List.cons a l))\nl : List Î±\nâŠ¢ Filter.Tendsto f (nhds l) (r l)","decl":"theorem tendsto_nhds {Î² : Type*} {f : List Î± â†’ Î²} {r : List Î± â†’ Filter Î²}\n    (h_nil : Tendsto f (pure []) (r []))\n    (h_cons :\n      âˆ€ l a,\n        Tendsto f (ğ“ l) (r l) â†’\n          Tendsto (fun p : Î± Ã— List Î± => f (p.1::p.2)) (ğ“ a Ã—Ë¢ ğ“ l) (r (a::l))) :\n    âˆ€ l, Tendsto f (ğ“ l) (r l)\n  | [] => by rwa [nhds_nil]\n  | a::l => by\n    rw [tendsto_cons_iff]; exact h_cons l a (@tendsto_nhds _ _ _ h_nil h_cons l)\n\n"}
{"name":"List.instDiscreteTopology","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : DiscreteTopology Î±\nâŠ¢ DiscreteTopology (List Î±)","decl":"instance [DiscreteTopology Î±] : DiscreteTopology (List Î±) := by\n  rw [discreteTopology_iff_nhds]; intro l; induction l <;> simp [*, nhds_cons]\n\n"}
{"name":"List.continuousAt_length","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\nl : List Î±\nâŠ¢ ContinuousAt List.length l","decl":"theorem continuousAt_length : âˆ€ l : List Î±, ContinuousAt List.length l := by\n  simp only [ContinuousAt, nhds_discrete]\n  refine tendsto_nhds ?_ ?_\n  Â· exact tendsto_pure_pure _ _\n  Â· intro l a ih\n    dsimp only [List.length]\n    refine Tendsto.comp (tendsto_pure_pure (fun x => x + 1) _) ?_\n    exact Tendsto.comp ih tendsto_snd\n\n"}
{"name":"List.tendsto_insertIdx'","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\na : Î±\nn : Nat\nl : List Î±\nâŠ¢ Filter.Tendsto (fun p => List.insertIdx n p.1 p.2) (SProd.sprod (nhds a) (nhds l)) (nhds (List.insertIdx n a l))","decl":"/-- Continuity of `insertIdx` in terms of `Tendsto`. -/\ntheorem tendsto_insertIdx' {a : Î±} :\n    âˆ€ {n : â„•} {l : List Î±},\n      Tendsto (fun p : Î± Ã— List Î± => insertIdx n p.1 p.2) (ğ“ a Ã—Ë¢ ğ“ l) (ğ“ (insertIdx n a l))\n  | 0, _ => tendsto_cons\n  | n + 1, [] => by simp\n  | n + 1, a'::l => by\n    have : ğ“ a Ã—Ë¢ ğ“ (a'::l) =\n        (ğ“ a Ã—Ë¢ (ğ“ a' Ã—Ë¢ ğ“ l)).map fun p : Î± Ã— Î± Ã— List Î± => (p.1, p.2.1::p.2.2) := by\n      simp only [nhds_cons, Filter.prod_eq, â† Filter.map_def, â† Filter.seq_eq_filter_seq]\n      simp [-Filter.map_def, Function.comp_def, functor_norm]\n    rw [this, tendsto_map'_iff]\n    exact\n      (tendsto_fst.comp tendsto_snd).cons\n        ((@tendsto_insertIdx' _ n l).comp <| tendsto_fst.prod_mk <| tendsto_snd.comp tendsto_snd)\n\n"}
{"name":"List.tendsto_insertNth'","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\na : Î±\nn : Nat\nl : List Î±\nâŠ¢ Filter.Tendsto (fun p => List.insertIdx n p.1 p.2) (SProd.sprod (nhds a) (nhds l)) (nhds (List.insertIdx n a l))","decl":"@[deprecated (since := \"2024-10-21\")] alias tendsto_insertNth' := tendsto_insertIdx'\n\n"}
{"name":"List.tendsto_insertIdx","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\nÎ² : Type u_3\nn : Nat\na : Î±\nl : List Î±\nf : Î² â†’ Î±\ng : Î² â†’ List Î±\nb : Filter Î²\nhf : Filter.Tendsto f b (nhds a)\nhg : Filter.Tendsto g b (nhds l)\nâŠ¢ Filter.Tendsto (fun b => List.insertIdx n (f b) (g b)) b (nhds (List.insertIdx n a l))","decl":"theorem tendsto_insertIdx {Î²} {n : â„•} {a : Î±} {l : List Î±} {f : Î² â†’ Î±} {g : Î² â†’ List Î±}\n    {b : Filter Î²} (hf : Tendsto f b (ğ“ a)) (hg : Tendsto g b (ğ“ l)) :\n    Tendsto (fun b : Î² => insertIdx n (f b) (g b)) b (ğ“ (insertIdx n a l)) :=\n  tendsto_insertIdx'.comp (Tendsto.prod_mk hf hg)\n\n"}
{"name":"List.tendsto_insertNth","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\na : Î±\nn : Nat\nl : List Î±\nâŠ¢ Filter.Tendsto (fun p => List.insertIdx n p.1 p.2) (SProd.sprod (nhds a) (nhds l)) (nhds (List.insertIdx n a l))","decl":"@[deprecated (since := \"2024-10-21\")] alias tendsto_insertNth := tendsto_insertIdx'\n\n"}
{"name":"List.continuous_insertIdx","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\nn : Nat\nâŠ¢ Continuous fun p => List.insertIdx n p.1 p.2","decl":"theorem continuous_insertIdx {n : â„•} : Continuous fun p : Î± Ã— List Î± => insertIdx n p.1 p.2 :=\n  continuous_iff_continuousAt.mpr fun âŸ¨a, lâŸ© => by\n    rw [ContinuousAt, nhds_prod_eq]; exact tendsto_insertIdx'\n\n"}
{"name":"List.continuous_insertNth","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\nn : Nat\nâŠ¢ Continuous fun p => List.insertIdx n p.1 p.2","decl":"@[deprecated (since := \"2024-10-21\")] alias continuous_insertNth := continuous_insertIdx\n\n"}
{"name":"List.tendsto_eraseIdx","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\nn : Nat\nl : List Î±\nâŠ¢ Filter.Tendsto (fun x => x.eraseIdx n) (nhds l) (nhds (l.eraseIdx n))","decl":"theorem tendsto_eraseIdx :\n    âˆ€ {n : â„•} {l : List Î±}, Tendsto (eraseIdx Â· n) (ğ“ l) (ğ“ (eraseIdx l n))\n  | _, [] => by rw [nhds_nil]; exact tendsto_pure_nhds _ _\n  | 0, a::l => by rw [tendsto_cons_iff]; exact tendsto_snd\n  | n + 1, a::l => by\n    rw [tendsto_cons_iff]\n    dsimp [eraseIdx]\n    exact tendsto_fst.cons ((@tendsto_eraseIdx n l).comp tendsto_snd)\n\n"}
{"name":"List.continuous_eraseIdx","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\nn : Nat\nâŠ¢ Continuous fun l => l.eraseIdx n","decl":"theorem continuous_eraseIdx {n : â„•} : Continuous fun l : List Î± => eraseIdx l n :=\n  continuous_iff_continuousAt.mpr fun _a => tendsto_eraseIdx\n\n"}
{"name":"List.tendsto_sum","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : AddMonoid Î±\ninstâœ : ContinuousAdd Î±\nl : List Î±\nâŠ¢ Filter.Tendsto List.sum (nhds l) (nhds l.sum)","decl":"@[to_additive]\ntheorem tendsto_prod [Monoid Î±] [ContinuousMul Î±] {l : List Î±} :\n    Tendsto List.prod (ğ“ l) (ğ“ l.prod) := by\n  induction' l with x l ih\n  Â· simp +contextual [nhds_nil, mem_of_mem_nhds, tendsto_pure_left]\n  simp_rw [tendsto_cons_iff, prod_cons]\n  have := continuous_iff_continuousAt.mp continuous_mul (x, l.prod)\n  rw [ContinuousAt, nhds_prod_eq] at this\n  exact this.comp (tendsto_id.prod_map ih)\n\n"}
{"name":"List.tendsto_prod","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Monoid Î±\ninstâœ : ContinuousMul Î±\nl : List Î±\nâŠ¢ Filter.Tendsto List.prod (nhds l) (nhds l.prod)","decl":"@[to_additive]\ntheorem tendsto_prod [Monoid Î±] [ContinuousMul Î±] {l : List Î±} :\n    Tendsto List.prod (ğ“ l) (ğ“ l.prod) := by\n  induction' l with x l ih\n  Â· simp +contextual [nhds_nil, mem_of_mem_nhds, tendsto_pure_left]\n  simp_rw [tendsto_cons_iff, prod_cons]\n  have := continuous_iff_continuousAt.mp continuous_mul (x, l.prod)\n  rw [ContinuousAt, nhds_prod_eq] at this\n  exact this.comp (tendsto_id.prod_map ih)\n\n"}
{"name":"List.continuous_sum","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : AddMonoid Î±\ninstâœ : ContinuousAdd Î±\nâŠ¢ Continuous List.sum","decl":"@[to_additive]\ntheorem continuous_prod [Monoid Î±] [ContinuousMul Î±] : Continuous (prod : List Î± â†’ Î±) :=\n  continuous_iff_continuousAt.mpr fun _l => tendsto_prod\n\n"}
{"name":"List.continuous_prod","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Monoid Î±\ninstâœ : ContinuousMul Î±\nâŠ¢ Continuous List.prod","decl":"@[to_additive]\ntheorem continuous_prod [Monoid Î±] [ContinuousMul Î±] : Continuous (prod : List Î± â†’ Î±) :=\n  continuous_iff_continuousAt.mpr fun _l => tendsto_prod\n\n"}
{"name":"Vector.tendsto_cons","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\nn : Nat\na : Î±\nl : List.Vector Î± n\nâŠ¢ Filter.Tendsto (fun p => List.Vector.cons p.1 p.2) (SProd.sprod (nhds a) (nhds l)) (nhds (List.Vector.cons a l))","decl":"theorem tendsto_cons {n : â„•} {a : Î±} {l : List.Vector Î± n} :\n    Tendsto (fun p : Î± Ã— List.Vector Î± n => p.1 ::áµ¥ p.2) (ğ“ a Ã—Ë¢ ğ“ l) (ğ“ (a ::áµ¥ l)) := by\n  rw [tendsto_subtype_rng, Vector.cons_val]\n  exact tendsto_fst.cons (Tendsto.comp continuousAt_subtype_val tendsto_snd)\n\n"}
{"name":"Vector.tendsto_insertIdx","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\nn : Nat\ni : Fin (HAdd.hAdd n 1)\na : Î±\nl : List.Vector Î± n\nâŠ¢ Filter.Tendsto (fun p => List.Vector.insertIdx p.1 i p.2) (SProd.sprod (nhds a) (nhds l)) (nhds (List.Vector.insertIdx a i l))","decl":"theorem tendsto_insertIdx {n : â„•} {i : Fin (n + 1)} {a : Î±} :\n    âˆ€ {l : List.Vector Î± n},\n      Tendsto (fun p : Î± Ã— List.Vector Î± n => Vector.insertIdx p.1 i p.2) (ğ“ a Ã—Ë¢ ğ“ l)\n        (ğ“ (Vector.insertIdx a i l))\n  | âŸ¨l, hlâŸ© => by\n    rw [Vector.insertIdx, tendsto_subtype_rng]\n    simp only [Vector.insertIdx_val]\n    exact List.tendsto_insertIdx tendsto_fst (Tendsto.comp continuousAt_subtype_val tendsto_snd : _)\n\n"}
{"name":"Vector.tendsto_insertNth","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\na : Î±\nn : Nat\nl : List Î±\nâŠ¢ Filter.Tendsto (fun p => List.insertIdx n p.1 p.2) (SProd.sprod (nhds a) (nhds l)) (nhds (List.insertIdx n a l))","decl":"@[deprecated (since := \"2024-10-21\")] alias tendsto_insertNth := tendsto_insertIdx'\n\n"}
{"name":"Vector.continuous_insertIdx'","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nâŠ¢ Continuous fun p => List.Vector.insertIdx p.1 i p.2","decl":"/-- Continuity of `Vector.insertIdx`. -/\ntheorem continuous_insertIdx' {n : â„•} {i : Fin (n + 1)} :\n    Continuous fun p : Î± Ã— List.Vector Î± n => Vector.insertIdx p.1 i p.2 :=\n  continuous_iff_continuousAt.mpr fun âŸ¨a, lâŸ© => by\n    rw [ContinuousAt, nhds_prod_eq]; exact tendsto_insertIdx\n\n"}
{"name":"Vector.continuous_insertNth'","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nâŠ¢ Continuous fun p => List.Vector.insertIdx p.1 i p.2","decl":"@[deprecated (since := \"2024-10-21\")] alias continuous_insertNth' := continuous_insertIdx'\n\n"}
{"name":"Vector.continuous_insertIdx","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nf : Î² â†’ Î±\ng : Î² â†’ List.Vector Î± n\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous fun b => List.Vector.insertIdx (f b) i (g b)","decl":"theorem continuous_insertIdx {n : â„•} {i : Fin (n + 1)} {f : Î² â†’ Î±} {g : Î² â†’ List.Vector Î± n}\n    (hf : Continuous f) (hg : Continuous g) : Continuous fun b => Vector.insertIdx (f b) i (g b) :=\n  continuous_insertIdx'.comp (hf.prod_mk hg)\n\n"}
{"name":"Vector.continuous_insertNth","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nf : Î² â†’ Î±\ng : Î² â†’ List.Vector Î± n\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous fun b => List.Vector.insertIdx (f b) i (g b)","decl":"@[deprecated (since := \"2024-10-21\")] alias continuous_insertNth := continuous_insertIdx\n\n"}
{"name":"Vector.continuousAt_eraseIdx","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nl : List.Vector Î± (HAdd.hAdd n 1)\nâŠ¢ ContinuousAt (List.Vector.eraseIdx i) l","decl":"theorem continuousAt_eraseIdx {n : â„•} {i : Fin (n + 1)} :\n    âˆ€ {l : List.Vector Î± (n + 1)}, ContinuousAt (List.Vector.eraseIdx i) l\n  | âŸ¨l, hlâŸ© => by\n    rw [ContinuousAt, List.Vector.eraseIdx, tendsto_subtype_rng]\n    simp only [Vector.eraseIdx_val]\n    exact Tendsto.comp List.tendsto_eraseIdx continuousAt_subtype_val\n\n"}
{"name":"Vector.continuous_eraseIdx","module":"Mathlib.Topology.List","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nâŠ¢ Continuous (List.Vector.eraseIdx i)","decl":"theorem continuous_eraseIdx {n : â„•} {i : Fin (n + 1)} :\n    Continuous (List.Vector.eraseIdx i : List.Vector Î± (n + 1) â†’ List.Vector Î± n) :=\n  continuous_iff_continuousAt.mpr fun âŸ¨_a, _lâŸ© => continuousAt_eraseIdx\n\n"}
