{"name":"instBorelSpaceSubtypeMemSubmodule","module":"Mathlib.MeasureTheory.Measure.Haar.Disintegration","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\ninstâœ : NormedSpace ğ•œ E\nT : Submodule ğ•œ E\nâŠ¢ BorelSpace (Subtype fun x => Membership.mem T x)","decl":"instance (T : Submodule ğ•œ E) : BorelSpace T := Subtype.borelSpace _\n"}
{"name":"instOpensMeasurableSpaceSubtypeMemSubmodule","module":"Mathlib.MeasureTheory.Measure.Haar.Disintegration","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\ninstâœ : NormedSpace ğ•œ E\nT : Submodule ğ•œ E\nâŠ¢ OpensMeasurableSpace (Subtype fun x => Membership.mem T x)","decl":"instance (T : Submodule ğ•œ E) : OpensMeasurableSpace T := Subtype.opensMeasurableSpace _\n\n"}
{"name":"LinearMap.exists_map_addHaar_eq_smul_addHaar'","module":"Mathlib.MeasureTheory.Measure.Haar.Disintegration","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ¹Â² : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â¹ : CompleteSpace ğ•œ\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : MeasurableSpace E\ninstâœâ¸ : BorelSpace E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : MeasurableSpace F\ninstâœâ´ : BorelSpace F\ninstâœÂ³ : NormedSpace ğ•œ F\nL : LinearMap (RingHom.id ğ•œ) E F\nÎ¼ : MeasureTheory.Measure E\nÎ½ : MeasureTheory.Measure F\ninstâœÂ² : Î¼.IsAddHaarMeasure\ninstâœÂ¹ : Î½.IsAddHaarMeasure\ninstâœ : LocallyCompactSpace E\nh : Function.Surjective â‡‘L\nâŠ¢ Exists fun c => And (LT.lt 0 c) (And (LT.lt c Top.top) (Eq (MeasureTheory.Measure.map (â‡‘L) Î¼) (HSMul.hSMul (HMul.hMul c (MeasureTheory.Measure.addHaar Set.univ)) Î½)))","decl":"/-- The image of an additive Haar measure under a surjective linear map is proportional to a given\nadditive Haar measure. The proportionality factor will be infinite if the linear map has a\nnontrivial kernel. -/\ntheorem LinearMap.exists_map_addHaar_eq_smul_addHaar' (h : Function.Surjective L) :\n    âˆƒ (c : â„â‰¥0âˆ), 0 < c âˆ§ c < âˆ âˆ§ Î¼.map L = (c * addHaar (univ : Set (LinearMap.ker L))) â€¢ Î½ := by\n  /- This is true for the second projection in product spaces, as the projection of the Haar\n  measure `Î¼S.prod Î¼T` is equal to the Haar measure `Î¼T` multiplied by the total mass of `Î¼S`. This\n  is also true for linear equivalences, as they map Haar measure to Haar measure. The general case\n  follows from these two and linear algebra, as `L` can be interpreted as the composition of the\n  projection `P` on a complement `T` to its kernel `S`, together with a linear equivalence. -/\n  have : FiniteDimensional ğ•œ E := .of_locallyCompactSpace ğ•œ\n  have : ProperSpace F := by\n    rcases subsingleton_or_nontrivial E with hE|hE\n    Â· have : Subsingleton F := Function.Surjective.subsingleton h\n      infer_instance\n    Â· have : ProperSpace ğ•œ := .of_locallyCompact_module ğ•œ E\n      have : FiniteDimensional ğ•œ F := Module.Finite.of_surjective L h\n      exact FiniteDimensional.proper ğ•œ F\n  let S : Submodule ğ•œ E := LinearMap.ker L\n  obtain âŸ¨T, hTâŸ© : âˆƒ T : Submodule ğ•œ E, IsCompl S T := Submodule.exists_isCompl S\n  let M : (S Ã— T) â‰ƒâ‚—[ğ•œ] E := Submodule.prodEquivOfIsCompl S T hT\n  have M_cont : Continuous M.symm := LinearMap.continuous_of_finiteDimensional _\n  let P : S Ã— T â†’â‚—[ğ•œ] T := LinearMap.snd ğ•œ S T\n  have P_cont : Continuous P := LinearMap.continuous_of_finiteDimensional _\n  have I : Function.Bijective (LinearMap.domRestrict L T) :=\n    âŸ¨LinearMap.injective_domRestrict_iff.2 (IsCompl.inf_eq_bot hT.symm),\n    (LinearMap.surjective_domRestrict_iff h).2 hT.symm.sup_eq_topâŸ©\n  let L' : T â‰ƒâ‚—[ğ•œ] F := LinearEquiv.ofBijective (LinearMap.domRestrict L T) I\n  have L'_cont : Continuous L' := LinearMap.continuous_of_finiteDimensional _\n  have A : L = (L' : T â†’â‚—[ğ•œ] F).comp (P.comp (M.symm : E â†’â‚—[ğ•œ] (S Ã— T))) := by\n    ext x\n    obtain âŸ¨y, z, hyzâŸ© : âˆƒ (y : S) (z : T), M.symm x = (y, z) := âŸ¨_, _, rflâŸ©\n    have : x = M (y, z) := by\n      rw [â† hyz]; simp only [LinearEquiv.apply_symm_apply]\n    simp [L', P, M, this]\n  have I : Î¼.map L = ((Î¼.map M.symm).map P).map L' := by\n    rw [Measure.map_map, Measure.map_map, A]\n    Â· rfl\n    Â· exact L'_cont.measurable.comp P_cont.measurable\n    Â· exact M_cont.measurable\n    Â· exact L'_cont.measurable\n    Â· exact P_cont.measurable\n  let Î¼S : Measure S := addHaar\n  let Î¼T : Measure T := addHaar\n  obtain âŸ¨câ‚€, câ‚€_pos, câ‚€_fin, hâ‚€âŸ© :\n      âˆƒ câ‚€ : â„â‰¥0âˆ, câ‚€ â‰  0 âˆ§ câ‚€ â‰  âˆ âˆ§ Î¼.map M.symm = câ‚€ â€¢ Î¼S.prod Î¼T := by\n    have : IsAddHaarMeasure (Î¼.map M.symm) :=\n      M.toContinuousLinearEquiv.symm.isAddHaarMeasure_map Î¼\n    refine âŸ¨addHaarScalarFactor (Î¼.map M.symm) (Î¼S.prod Î¼T), ?_, ENNReal.coe_ne_top,\n      isAddLeftInvariant_eq_smul _ _âŸ©\n    simpa only [ne_eq, ENNReal.coe_eq_zero] using\n      (addHaarScalarFactor_pos_of_isAddHaarMeasure (Î¼.map M.symm) (Î¼S.prod Î¼T)).ne'\n  have J : (Î¼S.prod Î¼T).map P = (Î¼S univ) â€¢ Î¼T := map_snd_prod\n  obtain âŸ¨câ‚, câ‚_pos, câ‚_fin, hâ‚âŸ© : âˆƒ câ‚ : â„â‰¥0âˆ, câ‚ â‰  0 âˆ§ câ‚ â‰  âˆ âˆ§ Î¼T.map L' = câ‚ â€¢ Î½ := by\n    have : IsAddHaarMeasure (Î¼T.map L') :=\n      L'.toContinuousLinearEquiv.isAddHaarMeasure_map Î¼T\n    refine âŸ¨addHaarScalarFactor (Î¼T.map L') Î½, ?_, ENNReal.coe_ne_top,\n      isAddLeftInvariant_eq_smul _ _âŸ©\n    simpa only [ne_eq, ENNReal.coe_eq_zero] using\n      (addHaarScalarFactor_pos_of_isAddHaarMeasure (Î¼T.map L') Î½).ne'\n  refine âŸ¨câ‚€ * câ‚, by simp [pos_iff_ne_zero, câ‚€_pos, câ‚_pos],\n    ENNReal.mul_lt_top câ‚€_fin.lt_top câ‚_fin.lt_top, ?_âŸ©\n  simp only [I, hâ‚€, Measure.map_smul, J, smul_smul, hâ‚]\n  rw [mul_assoc, mul_comm _ câ‚, â† mul_assoc]\n\n"}
{"name":"LinearMap.exists_map_addHaar_eq_smul_addHaar","module":"Mathlib.MeasureTheory.Measure.Haar.Disintegration","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ¹Â² : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â¹ : CompleteSpace ğ•œ\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : MeasurableSpace E\ninstâœâ¸ : BorelSpace E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : MeasurableSpace F\ninstâœâ´ : BorelSpace F\ninstâœÂ³ : NormedSpace ğ•œ F\nL : LinearMap (RingHom.id ğ•œ) E F\nÎ¼ : MeasureTheory.Measure E\nÎ½ : MeasureTheory.Measure F\ninstâœÂ² : Î¼.IsAddHaarMeasure\ninstâœÂ¹ : Î½.IsAddHaarMeasure\ninstâœ : LocallyCompactSpace E\nh : Function.Surjective â‡‘L\nâŠ¢ Exists fun c => And (LT.lt 0 c) (Eq (MeasureTheory.Measure.map (â‡‘L) Î¼) (HSMul.hSMul c Î½))","decl":"/-- The image of an additive Haar measure under a surjective linear map is proportional to a given\nadditive Haar measure, with a positive (but maybe infinite) factor. -/\ntheorem LinearMap.exists_map_addHaar_eq_smul_addHaar (h : Function.Surjective L) :\n    âˆƒ (c : â„â‰¥0âˆ), 0 < c âˆ§ Î¼.map L = c â€¢ Î½ := by\n  rcases L.exists_map_addHaar_eq_smul_addHaar' Î¼ Î½ h with âŸ¨c, c_pos, -, hcâŸ©\n  exact âŸ¨_, by simp [c_pos, NeZero.ne addHaar], hcâŸ©\n\n"}
{"name":"MeasureTheory.ae_comp_linearMap_mem_iff","module":"Mathlib.MeasureTheory.Measure.Haar.Disintegration","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ¹Â² : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â¹ : CompleteSpace ğ•œ\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : MeasurableSpace E\ninstâœâ¸ : BorelSpace E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : MeasurableSpace F\ninstâœâ´ : BorelSpace F\ninstâœÂ³ : NormedSpace ğ•œ F\nL : LinearMap (RingHom.id ğ•œ) E F\nÎ¼ : MeasureTheory.Measure E\nÎ½ : MeasureTheory.Measure F\ninstâœÂ² : Î¼.IsAddHaarMeasure\ninstâœÂ¹ : Î½.IsAddHaarMeasure\ninstâœ : LocallyCompactSpace E\nh : Function.Surjective â‡‘L\ns : Set F\nhs : MeasurableSet s\nâŠ¢ Iff (Filter.Eventually (fun x => Membership.mem s (L x)) (MeasureTheory.ae Î¼)) (Filter.Eventually (fun y => Membership.mem s y) (MeasureTheory.ae Î½))","decl":"/-- Given a surjective linear map `L`, it is equivalent to require a property almost everywhere\nin the source or the target spaces of `L`, with respect to additive Haar measures there. -/\nlemma ae_comp_linearMap_mem_iff (h : Function.Surjective L) {s : Set F} (hs : MeasurableSet s) :\n    (âˆ€áµ x âˆ‚Î¼, L x âˆˆ s) â†” âˆ€áµ y âˆ‚Î½, y âˆˆ s := by\n  have : FiniteDimensional ğ•œ E := .of_locallyCompactSpace ğ•œ\n  have : AEMeasurable L Î¼ := L.continuous_of_finiteDimensional.aemeasurable\n  apply (ae_map_iff this hs).symm.trans\n  rcases L.exists_map_addHaar_eq_smul_addHaar Î¼ Î½ h with âŸ¨c, c_pos, hcâŸ©\n  rw [hc]\n  exact ae_smul_measure_iff c_pos.ne'\n\n"}
{"name":"MeasureTheory.ae_ae_add_linearMap_mem_iff","module":"Mathlib.MeasureTheory.Measure.Haar.Disintegration","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ¹Â³ : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â² : CompleteSpace ğ•œ\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : MeasurableSpace E\ninstâœâ¹ : BorelSpace E\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : MeasurableSpace F\ninstâœâµ : BorelSpace F\ninstâœâ´ : NormedSpace ğ•œ F\nL : LinearMap (RingHom.id ğ•œ) E F\nÎ¼ : MeasureTheory.Measure E\nÎ½ : MeasureTheory.Measure F\ninstâœÂ³ : Î¼.IsAddHaarMeasure\ninstâœÂ² : Î½.IsAddHaarMeasure\ninstâœÂ¹ : LocallyCompactSpace E\ninstâœ : LocallyCompactSpace F\ns : Set F\nhs : MeasurableSet s\nâŠ¢ Iff (Filter.Eventually (fun y => Filter.Eventually (fun x => Membership.mem s (HAdd.hAdd y (L x))) (MeasureTheory.ae Î¼)) (MeasureTheory.ae Î½)) (Filter.Eventually (fun y => Membership.mem s y) (MeasureTheory.ae Î½))","decl":"/-- Given a linear map `L : E â†’ F`, a property holds almost everywhere in `F` if and only if,\nalmost everywhere in `F`, it holds almost everywhere along the subspace spanned by the\nimage of `L`. This is an instance of a disintegration argument for additive Haar measures. -/\nlemma ae_ae_add_linearMap_mem_iff [LocallyCompactSpace F] {s : Set F} (hs : MeasurableSet s) :\n    (âˆ€áµ y âˆ‚Î½, âˆ€áµ x âˆ‚Î¼, y + L x âˆˆ s) â†” âˆ€áµ y âˆ‚Î½, y âˆˆ s := by\n  have : FiniteDimensional ğ•œ E := .of_locallyCompactSpace ğ•œ\n  have : FiniteDimensional ğ•œ F := .of_locallyCompactSpace ğ•œ\n  have : ProperSpace E := .of_locallyCompactSpace ğ•œ\n  have : ProperSpace F := .of_locallyCompactSpace ğ•œ\n  let M : F Ã— E â†’â‚—[ğ•œ] F := LinearMap.id.coprod L\n  have M_cont : Continuous M := M.continuous_of_finiteDimensional\n  -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to change `range_eq_top` into\n  -- `range_eq_top (f := _)`\n  have hM : Function.Surjective M := by\n    simp [M, â† LinearMap.range_eq_top (f := _), LinearMap.range_coprod]\n  have A : âˆ€ x, M x âˆˆ s â†” x âˆˆ M â»Â¹' s := fun x â†¦ Iff.rfl\n  simp_rw [â† ae_comp_linearMap_mem_iff M (Î½.prod Î¼) Î½ hM hs, A]\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  Â· simp only [M, mem_preimage, LinearMap.coprod_apply, LinearMap.id_coe, id_eq]\n  Â· exact M_cont.measurable hs\n\n"}
{"name":"MeasureTheory.ae_mem_of_ae_add_linearMap_mem","module":"Mathlib.MeasureTheory.Measure.Haar.Disintegration","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ¹Â³ : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â² : CompleteSpace ğ•œ\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : MeasurableSpace E\ninstâœâ¹ : BorelSpace E\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : MeasurableSpace F\ninstâœâµ : BorelSpace F\ninstâœâ´ : NormedSpace ğ•œ F\nL : LinearMap (RingHom.id ğ•œ) E F\nÎ¼ : MeasureTheory.Measure E\nÎ½ : MeasureTheory.Measure F\ninstâœÂ³ : Î¼.IsAddHaarMeasure\ninstâœÂ² : Î½.IsAddHaarMeasure\ninstâœÂ¹ : LocallyCompactSpace E\ninstâœ : LocallyCompactSpace F\ns : Set F\nhs : MeasurableSet s\nh : âˆ€ (y : F), Filter.Eventually (fun x => Membership.mem s (HAdd.hAdd y (L x))) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Eventually (fun y => Membership.mem s y) (MeasureTheory.ae Î½)","decl":"/-- To check that a property holds almost everywhere with respect to an additive Haar measure, it\nsuffices to check it almost everywhere along all translates of a given vector subspace. This is an\ninstance of a disintegration argument for additive Haar measures. -/\nlemma ae_mem_of_ae_add_linearMap_mem [LocallyCompactSpace F] {s : Set F} (hs : MeasurableSet s)\n    (h : âˆ€ y, âˆ€áµ x âˆ‚Î¼, y + L x âˆˆ s) : âˆ€áµ y âˆ‚Î½, y âˆˆ s :=\n  (ae_ae_add_linearMap_mem_iff L Î¼ Î½ hs).1 (Filter.Eventually.of_forall h)\n\n"}
