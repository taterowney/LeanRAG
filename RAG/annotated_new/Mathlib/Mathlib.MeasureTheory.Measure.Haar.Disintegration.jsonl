{"name":"instBorelSpaceSubtypeMemSubmodule","module":"Mathlib.MeasureTheory.Measure.Haar.Disintegration","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : MeasurableSpace E\ninst✝¹ : BorelSpace E\ninst✝ : NormedSpace 𝕜 E\nT : Submodule 𝕜 E\n⊢ BorelSpace (Subtype fun x => Membership.mem T x)","decl":"instance (T : Submodule 𝕜 E) : BorelSpace T := Subtype.borelSpace _\n"}
{"name":"instOpensMeasurableSpaceSubtypeMemSubmodule","module":"Mathlib.MeasureTheory.Measure.Haar.Disintegration","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : MeasurableSpace E\ninst✝¹ : BorelSpace E\ninst✝ : NormedSpace 𝕜 E\nT : Submodule 𝕜 E\n⊢ OpensMeasurableSpace (Subtype fun x => Membership.mem T x)","decl":"instance (T : Submodule 𝕜 E) : OpensMeasurableSpace T := Subtype.opensMeasurableSpace _\n\n"}
{"name":"LinearMap.exists_map_addHaar_eq_smul_addHaar'","module":"Mathlib.MeasureTheory.Measure.Haar.Disintegration","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹² : NontriviallyNormedField 𝕜\ninst✝¹¹ : CompleteSpace 𝕜\ninst✝¹⁰ : NormedAddCommGroup E\ninst✝⁹ : MeasurableSpace E\ninst✝⁸ : BorelSpace E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : MeasurableSpace F\ninst✝⁴ : BorelSpace F\ninst✝³ : NormedSpace 𝕜 F\nL : LinearMap (RingHom.id 𝕜) E F\nμ : MeasureTheory.Measure E\nν : MeasureTheory.Measure F\ninst✝² : μ.IsAddHaarMeasure\ninst✝¹ : ν.IsAddHaarMeasure\ninst✝ : LocallyCompactSpace E\nh : Function.Surjective ⇑L\n⊢ Exists fun c => And (LT.lt 0 c) (And (LT.lt c Top.top) (Eq (MeasureTheory.Measure.map (⇑L) μ) (HSMul.hSMul (HMul.hMul c (MeasureTheory.Measure.addHaar Set.univ)) ν)))","decl":"/-- The image of an additive Haar measure under a surjective linear map is proportional to a given\nadditive Haar measure. The proportionality factor will be infinite if the linear map has a\nnontrivial kernel. -/\ntheorem LinearMap.exists_map_addHaar_eq_smul_addHaar' (h : Function.Surjective L) :\n    ∃ (c : ℝ≥0∞), 0 < c ∧ c < ∞ ∧ μ.map L = (c * addHaar (univ : Set (LinearMap.ker L))) • ν := by\n  /- This is true for the second projection in product spaces, as the projection of the Haar\n  measure `μS.prod μT` is equal to the Haar measure `μT` multiplied by the total mass of `μS`. This\n  is also true for linear equivalences, as they map Haar measure to Haar measure. The general case\n  follows from these two and linear algebra, as `L` can be interpreted as the composition of the\n  projection `P` on a complement `T` to its kernel `S`, together with a linear equivalence. -/\n  have : FiniteDimensional 𝕜 E := .of_locallyCompactSpace 𝕜\n  have : ProperSpace F := by\n    rcases subsingleton_or_nontrivial E with hE|hE\n    · have : Subsingleton F := Function.Surjective.subsingleton h\n      infer_instance\n    · have : ProperSpace 𝕜 := .of_locallyCompact_module 𝕜 E\n      have : FiniteDimensional 𝕜 F := Module.Finite.of_surjective L h\n      exact FiniteDimensional.proper 𝕜 F\n  let S : Submodule 𝕜 E := LinearMap.ker L\n  obtain ⟨T, hT⟩ : ∃ T : Submodule 𝕜 E, IsCompl S T := Submodule.exists_isCompl S\n  let M : (S × T) ≃ₗ[𝕜] E := Submodule.prodEquivOfIsCompl S T hT\n  have M_cont : Continuous M.symm := LinearMap.continuous_of_finiteDimensional _\n  let P : S × T →ₗ[𝕜] T := LinearMap.snd 𝕜 S T\n  have P_cont : Continuous P := LinearMap.continuous_of_finiteDimensional _\n  have I : Function.Bijective (LinearMap.domRestrict L T) :=\n    ⟨LinearMap.injective_domRestrict_iff.2 (IsCompl.inf_eq_bot hT.symm),\n    (LinearMap.surjective_domRestrict_iff h).2 hT.symm.sup_eq_top⟩\n  let L' : T ≃ₗ[𝕜] F := LinearEquiv.ofBijective (LinearMap.domRestrict L T) I\n  have L'_cont : Continuous L' := LinearMap.continuous_of_finiteDimensional _\n  have A : L = (L' : T →ₗ[𝕜] F).comp (P.comp (M.symm : E →ₗ[𝕜] (S × T))) := by\n    ext x\n    obtain ⟨y, z, hyz⟩ : ∃ (y : S) (z : T), M.symm x = (y, z) := ⟨_, _, rfl⟩\n    have : x = M (y, z) := by\n      rw [← hyz]; simp only [LinearEquiv.apply_symm_apply]\n    simp [L', P, M, this]\n  have I : μ.map L = ((μ.map M.symm).map P).map L' := by\n    rw [Measure.map_map, Measure.map_map, A]\n    · rfl\n    · exact L'_cont.measurable.comp P_cont.measurable\n    · exact M_cont.measurable\n    · exact L'_cont.measurable\n    · exact P_cont.measurable\n  let μS : Measure S := addHaar\n  let μT : Measure T := addHaar\n  obtain ⟨c₀, c₀_pos, c₀_fin, h₀⟩ :\n      ∃ c₀ : ℝ≥0∞, c₀ ≠ 0 ∧ c₀ ≠ ∞ ∧ μ.map M.symm = c₀ • μS.prod μT := by\n    have : IsAddHaarMeasure (μ.map M.symm) :=\n      M.toContinuousLinearEquiv.symm.isAddHaarMeasure_map μ\n    refine ⟨addHaarScalarFactor (μ.map M.symm) (μS.prod μT), ?_, ENNReal.coe_ne_top,\n      isAddLeftInvariant_eq_smul _ _⟩\n    simpa only [ne_eq, ENNReal.coe_eq_zero] using\n      (addHaarScalarFactor_pos_of_isAddHaarMeasure (μ.map M.symm) (μS.prod μT)).ne'\n  have J : (μS.prod μT).map P = (μS univ) • μT := map_snd_prod\n  obtain ⟨c₁, c₁_pos, c₁_fin, h₁⟩ : ∃ c₁ : ℝ≥0∞, c₁ ≠ 0 ∧ c₁ ≠ ∞ ∧ μT.map L' = c₁ • ν := by\n    have : IsAddHaarMeasure (μT.map L') :=\n      L'.toContinuousLinearEquiv.isAddHaarMeasure_map μT\n    refine ⟨addHaarScalarFactor (μT.map L') ν, ?_, ENNReal.coe_ne_top,\n      isAddLeftInvariant_eq_smul _ _⟩\n    simpa only [ne_eq, ENNReal.coe_eq_zero] using\n      (addHaarScalarFactor_pos_of_isAddHaarMeasure (μT.map L') ν).ne'\n  refine ⟨c₀ * c₁, by simp [pos_iff_ne_zero, c₀_pos, c₁_pos],\n    ENNReal.mul_lt_top c₀_fin.lt_top c₁_fin.lt_top, ?_⟩\n  simp only [I, h₀, Measure.map_smul, J, smul_smul, h₁]\n  rw [mul_assoc, mul_comm _ c₁, ← mul_assoc]\n\n"}
{"name":"LinearMap.exists_map_addHaar_eq_smul_addHaar","module":"Mathlib.MeasureTheory.Measure.Haar.Disintegration","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹² : NontriviallyNormedField 𝕜\ninst✝¹¹ : CompleteSpace 𝕜\ninst✝¹⁰ : NormedAddCommGroup E\ninst✝⁹ : MeasurableSpace E\ninst✝⁸ : BorelSpace E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : MeasurableSpace F\ninst✝⁴ : BorelSpace F\ninst✝³ : NormedSpace 𝕜 F\nL : LinearMap (RingHom.id 𝕜) E F\nμ : MeasureTheory.Measure E\nν : MeasureTheory.Measure F\ninst✝² : μ.IsAddHaarMeasure\ninst✝¹ : ν.IsAddHaarMeasure\ninst✝ : LocallyCompactSpace E\nh : Function.Surjective ⇑L\n⊢ Exists fun c => And (LT.lt 0 c) (Eq (MeasureTheory.Measure.map (⇑L) μ) (HSMul.hSMul c ν))","decl":"/-- The image of an additive Haar measure under a surjective linear map is proportional to a given\nadditive Haar measure, with a positive (but maybe infinite) factor. -/\ntheorem LinearMap.exists_map_addHaar_eq_smul_addHaar (h : Function.Surjective L) :\n    ∃ (c : ℝ≥0∞), 0 < c ∧ μ.map L = c • ν := by\n  rcases L.exists_map_addHaar_eq_smul_addHaar' μ ν h with ⟨c, c_pos, -, hc⟩\n  exact ⟨_, by simp [c_pos, NeZero.ne addHaar], hc⟩\n\n"}
{"name":"MeasureTheory.ae_comp_linearMap_mem_iff","module":"Mathlib.MeasureTheory.Measure.Haar.Disintegration","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹² : NontriviallyNormedField 𝕜\ninst✝¹¹ : CompleteSpace 𝕜\ninst✝¹⁰ : NormedAddCommGroup E\ninst✝⁹ : MeasurableSpace E\ninst✝⁸ : BorelSpace E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : MeasurableSpace F\ninst✝⁴ : BorelSpace F\ninst✝³ : NormedSpace 𝕜 F\nL : LinearMap (RingHom.id 𝕜) E F\nμ : MeasureTheory.Measure E\nν : MeasureTheory.Measure F\ninst✝² : μ.IsAddHaarMeasure\ninst✝¹ : ν.IsAddHaarMeasure\ninst✝ : LocallyCompactSpace E\nh : Function.Surjective ⇑L\ns : Set F\nhs : MeasurableSet s\n⊢ Iff (Filter.Eventually (fun x => Membership.mem s (L x)) (MeasureTheory.ae μ)) (Filter.Eventually (fun y => Membership.mem s y) (MeasureTheory.ae ν))","decl":"/-- Given a surjective linear map `L`, it is equivalent to require a property almost everywhere\nin the source or the target spaces of `L`, with respect to additive Haar measures there. -/\nlemma ae_comp_linearMap_mem_iff (h : Function.Surjective L) {s : Set F} (hs : MeasurableSet s) :\n    (∀ᵐ x ∂μ, L x ∈ s) ↔ ∀ᵐ y ∂ν, y ∈ s := by\n  have : FiniteDimensional 𝕜 E := .of_locallyCompactSpace 𝕜\n  have : AEMeasurable L μ := L.continuous_of_finiteDimensional.aemeasurable\n  apply (ae_map_iff this hs).symm.trans\n  rcases L.exists_map_addHaar_eq_smul_addHaar μ ν h with ⟨c, c_pos, hc⟩\n  rw [hc]\n  exact ae_smul_measure_iff c_pos.ne'\n\n"}
{"name":"MeasureTheory.ae_ae_add_linearMap_mem_iff","module":"Mathlib.MeasureTheory.Measure.Haar.Disintegration","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹³ : NontriviallyNormedField 𝕜\ninst✝¹² : CompleteSpace 𝕜\ninst✝¹¹ : NormedAddCommGroup E\ninst✝¹⁰ : MeasurableSpace E\ninst✝⁹ : BorelSpace E\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : MeasurableSpace F\ninst✝⁵ : BorelSpace F\ninst✝⁴ : NormedSpace 𝕜 F\nL : LinearMap (RingHom.id 𝕜) E F\nμ : MeasureTheory.Measure E\nν : MeasureTheory.Measure F\ninst✝³ : μ.IsAddHaarMeasure\ninst✝² : ν.IsAddHaarMeasure\ninst✝¹ : LocallyCompactSpace E\ninst✝ : LocallyCompactSpace F\ns : Set F\nhs : MeasurableSet s\n⊢ Iff (Filter.Eventually (fun y => Filter.Eventually (fun x => Membership.mem s (HAdd.hAdd y (L x))) (MeasureTheory.ae μ)) (MeasureTheory.ae ν)) (Filter.Eventually (fun y => Membership.mem s y) (MeasureTheory.ae ν))","decl":"/-- Given a linear map `L : E → F`, a property holds almost everywhere in `F` if and only if,\nalmost everywhere in `F`, it holds almost everywhere along the subspace spanned by the\nimage of `L`. This is an instance of a disintegration argument for additive Haar measures. -/\nlemma ae_ae_add_linearMap_mem_iff [LocallyCompactSpace F] {s : Set F} (hs : MeasurableSet s) :\n    (∀ᵐ y ∂ν, ∀ᵐ x ∂μ, y + L x ∈ s) ↔ ∀ᵐ y ∂ν, y ∈ s := by\n  have : FiniteDimensional 𝕜 E := .of_locallyCompactSpace 𝕜\n  have : FiniteDimensional 𝕜 F := .of_locallyCompactSpace 𝕜\n  have : ProperSpace E := .of_locallyCompactSpace 𝕜\n  have : ProperSpace F := .of_locallyCompactSpace 𝕜\n  let M : F × E →ₗ[𝕜] F := LinearMap.id.coprod L\n  have M_cont : Continuous M := M.continuous_of_finiteDimensional\n  -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to change `range_eq_top` into\n  -- `range_eq_top (f := _)`\n  have hM : Function.Surjective M := by\n    simp [M, ← LinearMap.range_eq_top (f := _), LinearMap.range_coprod]\n  have A : ∀ x, M x ∈ s ↔ x ∈ M ⁻¹' s := fun x ↦ Iff.rfl\n  simp_rw [← ae_comp_linearMap_mem_iff M (ν.prod μ) ν hM hs, A]\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · simp only [M, mem_preimage, LinearMap.coprod_apply, LinearMap.id_coe, id_eq]\n  · exact M_cont.measurable hs\n\n"}
{"name":"MeasureTheory.ae_mem_of_ae_add_linearMap_mem","module":"Mathlib.MeasureTheory.Measure.Haar.Disintegration","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹³ : NontriviallyNormedField 𝕜\ninst✝¹² : CompleteSpace 𝕜\ninst✝¹¹ : NormedAddCommGroup E\ninst✝¹⁰ : MeasurableSpace E\ninst✝⁹ : BorelSpace E\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : MeasurableSpace F\ninst✝⁵ : BorelSpace F\ninst✝⁴ : NormedSpace 𝕜 F\nL : LinearMap (RingHom.id 𝕜) E F\nμ : MeasureTheory.Measure E\nν : MeasureTheory.Measure F\ninst✝³ : μ.IsAddHaarMeasure\ninst✝² : ν.IsAddHaarMeasure\ninst✝¹ : LocallyCompactSpace E\ninst✝ : LocallyCompactSpace F\ns : Set F\nhs : MeasurableSet s\nh : ∀ (y : F), Filter.Eventually (fun x => Membership.mem s (HAdd.hAdd y (L x))) (MeasureTheory.ae μ)\n⊢ Filter.Eventually (fun y => Membership.mem s y) (MeasureTheory.ae ν)","decl":"/-- To check that a property holds almost everywhere with respect to an additive Haar measure, it\nsuffices to check it almost everywhere along all translates of a given vector subspace. This is an\ninstance of a disintegration argument for additive Haar measures. -/\nlemma ae_mem_of_ae_add_linearMap_mem [LocallyCompactSpace F] {s : Set F} (hs : MeasurableSet s)\n    (h : ∀ y, ∀ᵐ x ∂μ, y + L x ∈ s) : ∀ᵐ y ∂ν, y ∈ s :=\n  (ae_ae_add_linearMap_mem_iff L μ ν hs).1 (Filter.Eventually.of_forall h)\n\n"}
