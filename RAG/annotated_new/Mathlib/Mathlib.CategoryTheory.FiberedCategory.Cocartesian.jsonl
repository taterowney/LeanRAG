{"name":"CategoryTheory.Functor.IsCocartesian.toIsHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nself : p.IsCocartesian f Ï†\nâŠ¢ p.IsHomLift f Ï†","decl":"/-- A morphism `Ï† : a âŸ¶ b` in `ğ’³` lying over `f : R âŸ¶ S` in `ğ’®` is cocartesian if for all\nmorphisms `Ï†' : a âŸ¶ b'`, also lying over `f`, there exists a unique morphism `Ï‡ : b âŸ¶ b'` lifting\n`ğŸ™ S` such that `Ï†' = Ï† â‰« Ï‡`. -/\nclass IsCocartesian extends IsHomLift p f Ï† : Prop where\n  universal_property {b' : ğ’³} (Ï†' : a âŸ¶ b') [IsHomLift p f Ï†'] :\n      âˆƒ! Ï‡ : b âŸ¶ b', IsHomLift p (ğŸ™ S) Ï‡ âˆ§ Ï† â‰« Ï‡ = Ï†'\n\n"}
{"name":"CategoryTheory.Functor.IsCocartesian.universal_property","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nself : p.IsCocartesian f Ï†\nb' : ğ’³\nÏ†' : Quiver.Hom a b'\ninstâœ : p.IsHomLift f Ï†'\nâŠ¢ ExistsUnique fun Ï‡ => And (p.IsHomLift (CategoryTheory.CategoryStruct.id S) Ï‡) (Eq (CategoryTheory.CategoryStruct.comp Ï† Ï‡) Ï†')","decl":"/-- A morphism `Ï† : a âŸ¶ b` in `ğ’³` lying over `f : R âŸ¶ S` in `ğ’®` is cocartesian if for all\nmorphisms `Ï†' : a âŸ¶ b'`, also lying over `f`, there exists a unique morphism `Ï‡ : b âŸ¶ b'` lifting\n`ğŸ™ S` such that `Ï†' = Ï† â‰« Ï‡`. -/\nclass IsCocartesian extends IsHomLift p f Ï† : Prop where\n  universal_property {b' : ğ’³} (Ï†' : a âŸ¶ b') [IsHomLift p f Ï†'] :\n      âˆƒ! Ï‡ : b âŸ¶ b', IsHomLift p (ğŸ™ S) Ï‡ âˆ§ Ï† â‰« Ï‡ = Ï†'\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.toIsHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nself : p.IsStronglyCocartesian f Ï†\nâŠ¢ p.IsHomLift f Ï†","decl":"/-- A morphism `Ï† : a âŸ¶ b` in `ğ’³` lying over `f : R âŸ¶ S` in `ğ’®` is strongly cocartesian if for\nall morphisms `Ï†' : a âŸ¶ b'` and all diagrams of the form\n```\na --Ï†--> b        b'\n|        |        |\nv        v        v\nR --f--> S --g--> S'\n```\nsuch that `Ï†'` lifts `f â‰« g`, there exists a lift `Ï‡` of `g` such that `Ï†' = Ï‡ â‰« Ï†`. -/\n@[stacks 02XK]\nclass IsStronglyCocartesian extends IsHomLift p f Ï† : Prop where\n  universal_property' {b' : ğ’³} (g : S âŸ¶ p.obj b') (Ï†' : a âŸ¶ b') [IsHomLift p (f â‰« g) Ï†'] :\n      âˆƒ! Ï‡ : b âŸ¶ b', IsHomLift p g Ï‡ âˆ§ Ï† â‰« Ï‡ = Ï†'\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.universal_property'","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nself : p.IsStronglyCocartesian f Ï†\nb' : ğ’³\ng : Quiver.Hom S (p.obj b')\nÏ†' : Quiver.Hom a b'\ninstâœ : p.IsHomLift (CategoryTheory.CategoryStruct.comp f g) Ï†'\nâŠ¢ ExistsUnique fun Ï‡ => And (p.IsHomLift g Ï‡) (Eq (CategoryTheory.CategoryStruct.comp Ï† Ï‡) Ï†')","decl":"/-- A morphism `Ï† : a âŸ¶ b` in `ğ’³` lying over `f : R âŸ¶ S` in `ğ’®` is strongly cocartesian if for\nall morphisms `Ï†' : a âŸ¶ b'` and all diagrams of the form\n```\na --Ï†--> b        b'\n|        |        |\nv        v        v\nR --f--> S --g--> S'\n```\nsuch that `Ï†'` lifts `f â‰« g`, there exists a lift `Ï‡` of `g` such that `Ï†' = Ï‡ â‰« Ï†`. -/\n@[stacks 02XK]\nclass IsStronglyCocartesian extends IsHomLift p f Ï† : Prop where\n  universal_property' {b' : ğ’³} (g : S âŸ¶ p.obj b') (Ï†' : a âŸ¶ b') [IsHomLift p (f â‰« g) Ï†'] :\n      âˆƒ! Ï‡ : b âŸ¶ b', IsHomLift p g Ï‡ âˆ§ Ï† â‰« Ï‡ = Ï†'\n\n"}
{"name":"CategoryTheory.Functor.IsCocartesian.map_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsCocartesian f Ï†\nb' : ğ’³\nÏ†' : Quiver.Hom a b'\ninstâœ : p.IsHomLift f Ï†'\nâŠ¢ p.IsHomLift (CategoryTheory.CategoryStruct.id S) (CategoryTheory.Functor.IsCocartesian.map p f Ï† Ï†')","decl":"instance map_isHomLift : IsHomLift p (ğŸ™ S) (IsCocartesian.map p f Ï† Ï†') :=\n  (Classical.choose_spec <| IsCocartesian.universal_property (p:=p) (f:=f) (Ï†:=Ï†) Ï†').1.1\n\n"}
{"name":"CategoryTheory.Functor.IsCocartesian.fac_assoc","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsCocartesian f Ï†\nb' : ğ’³\nÏ†' : Quiver.Hom a b'\ninstâœ : p.IsHomLift f Ï†'\nZ : ğ’³\nh : Quiver.Hom b' Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp Ï† (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsCocartesian.map p f Ï† Ï†') h)) (CategoryTheory.CategoryStruct.comp Ï†' h)","decl":"@[reassoc (attr := simp)]\nlemma fac : Ï† â‰« IsCocartesian.map p f Ï† Ï†' = Ï†' :=\n  (Classical.choose_spec <| IsCocartesian.universal_property (p:=p) (f:=f) (Ï†:=Ï†) Ï†').1.2\n\n"}
{"name":"CategoryTheory.Functor.IsCocartesian.fac","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsCocartesian f Ï†\nb' : ğ’³\nÏ†' : Quiver.Hom a b'\ninstâœ : p.IsHomLift f Ï†'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp Ï† (CategoryTheory.Functor.IsCocartesian.map p f Ï† Ï†')) Ï†'","decl":"@[reassoc (attr := simp)]\nlemma fac : Ï† â‰« IsCocartesian.map p f Ï† Ï†' = Ï†' :=\n  (Classical.choose_spec <| IsCocartesian.universal_property (p:=p) (f:=f) (Ï†:=Ï†) Ï†').1.2\n\n"}
{"name":"CategoryTheory.Functor.IsCocartesian.map_uniq","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ² : p.IsCocartesian f Ï†\nb' : ğ’³\nÏ†' : Quiver.Hom a b'\ninstâœÂ¹ : p.IsHomLift f Ï†'\nÏˆ : Quiver.Hom b b'\ninstâœ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) Ïˆ\nhÏˆ : Eq (CategoryTheory.CategoryStruct.comp Ï† Ïˆ) Ï†'\nâŠ¢ Eq Ïˆ (CategoryTheory.Functor.IsCocartesian.map p f Ï† Ï†')","decl":"/-- Given a cocartesian morphism `Ï† : a âŸ¶ b` lying over `f : R âŸ¶ S` in `ğ’³`, and another morphism\n`Ï†' : a âŸ¶ b'` which also lifts `f`. Then any morphism `Ïˆ : b âŸ¶ b'` lifting `ğŸ™ S` such that\n`g â‰« Ïˆ = Ï†'` must equal the map induced by the universal property of `Ï†`. -/\nlemma map_uniq (Ïˆ : b âŸ¶ b') [IsHomLift p (ğŸ™ S) Ïˆ] (hÏˆ : Ï† â‰« Ïˆ = Ï†') :\n    Ïˆ = IsCocartesian.map p f Ï† Ï†' :=\n  (Classical.choose_spec <| IsCocartesian.universal_property (p:=p) (f:=f) (Ï†:=Ï†) Ï†').2\n    Ïˆ âŸ¨inferInstance, hÏˆâŸ©\n\n"}
{"name":"CategoryTheory.Functor.IsCocartesian.ext","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ² : p.IsCocartesian f Ï†\nb' : ğ’³\nÏˆ Ïˆ' : Quiver.Hom b b'\ninstâœÂ¹ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) Ïˆ\ninstâœ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) Ïˆ'\nh : Eq (CategoryTheory.CategoryStruct.comp Ï† Ïˆ) (CategoryTheory.CategoryStruct.comp Ï† Ïˆ')\nâŠ¢ Eq Ïˆ Ïˆ'","decl":"/-- Given a cocartesian morphism `Ï† : a âŸ¶ b` lying over `f : R âŸ¶ S` in `ğ’³`, and two morphisms\n`Ïˆ Ïˆ' : b âŸ¶ b'` lifting `ğŸ™ S` such that `Ï† â‰« Ïˆ = Ï† â‰« Ïˆ'`. Then we must have `Ïˆ = Ïˆ'`. -/\nprotected lemma ext (Ï† : a âŸ¶ b) [IsCocartesian p f Ï†] {b' : ğ’³} (Ïˆ Ïˆ' : b âŸ¶ b')\n    [IsHomLift p (ğŸ™ S) Ïˆ] [IsHomLift p (ğŸ™ S) Ïˆ'] (h : Ï† â‰« Ïˆ = Ï† â‰« Ïˆ') : Ïˆ = Ïˆ' := by\n  rw [map_uniq p f Ï† (Ï† â‰« Ïˆ) Ïˆ rfl, map_uniq p f Ï† (Ï† â‰« Ïˆ) Ïˆ' h.symm]\n\n"}
{"name":"CategoryTheory.Functor.IsCocartesian.map_self","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœ : p.IsCocartesian f Ï†\nâŠ¢ Eq (CategoryTheory.Functor.IsCocartesian.map p f Ï† Ï†) (CategoryTheory.CategoryStruct.id b)","decl":"@[simp]\nlemma map_self : IsCocartesian.map p f Ï† Ï† = ğŸ™ b := by\n  subst_hom_lift p f Ï†; symm\n  apply map_uniq\n  simp only [comp_id]\n\n"}
{"name":"CategoryTheory.Functor.IsCocartesian.of_comp_iso","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsCocartesian f Ï†\nb' : ğ’³\nÏ†' : CategoryTheory.Iso b b'\ninstâœ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) Ï†'.hom\nâŠ¢ p.IsCocartesian f (CategoryTheory.CategoryStruct.comp Ï† Ï†'.hom)","decl":"/-- Postcomposing a cocartesian morphism with an isomorphism lifting the identity is cocartesian. -/\ninstance of_comp_iso {b' : ğ’³} (Ï†' : b â‰… b') [IsHomLift p (ğŸ™ S) Ï†'.hom] :\n    IsCocartesian p f (Ï† â‰« Ï†'.hom) where\n  universal_property := by\n    intro c Ïˆ hÏˆ\n    use Ï†'.inv â‰« IsCocartesian.map p f Ï† Ïˆ\n    refine âŸ¨âŸ¨inferInstance, by simpâŸ©, ?_âŸ©\n    rintro Ï„ âŸ¨hÏ„â‚, hÏ„â‚‚âŸ©\n    rw [Iso.eq_inv_comp]\n    apply map_uniq\n    exact ((assoc Ï† _ _) â–¸ hÏ„â‚‚)\n\n"}
{"name":"CategoryTheory.Functor.IsCocartesian.of_iso_comp","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsCocartesian f Ï†\na' : ğ’³\nÏ†' : CategoryTheory.Iso a' a\ninstâœ : p.IsHomLift (CategoryTheory.CategoryStruct.id R) Ï†'.hom\nâŠ¢ p.IsCocartesian f (CategoryTheory.CategoryStruct.comp Ï†'.hom Ï†)","decl":"/-- Precomposing a cocartesian morphism with an isomorphism lifting the identity is cocartesian. -/\ninstance of_iso_comp {a' : ğ’³} (Ï†' : a' â‰… a) [IsHomLift p (ğŸ™ R) Ï†'.hom] :\n    IsCocartesian p f (Ï†'.hom â‰« Ï†) where\n  universal_property := by\n    intro c Ïˆ hÏˆ\n    use IsCocartesian.map p f Ï† (Ï†'.inv â‰« Ïˆ)\n    refine âŸ¨âŸ¨inferInstance, by simpâŸ©, ?_âŸ©\n    rintro Ï„ âŸ¨hÏ„â‚, hÏ„â‚‚âŸ©\n    apply map_uniq\n    simp only [Iso.eq_inv_comp, â† assoc, hÏ„â‚‚]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.universal_property","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsStronglyCocartesian f Ï†\nS' : ğ’®\nb' : ğ’³\ng : Quiver.Hom S S'\nf' : Quiver.Hom R S'\nhf' : Eq f' (CategoryTheory.CategoryStruct.comp f g)\nÏ†' : Quiver.Hom a b'\ninstâœ : p.IsHomLift f' Ï†'\nâŠ¢ ExistsUnique fun Ï‡ => And (p.IsHomLift g Ï‡) (Eq (CategoryTheory.CategoryStruct.comp Ï† Ï‡) Ï†')","decl":"/-- The universal property of a strongly cocartesian morphism.\n\nThis lemma is more flexible with respect to non-definitional equalities than the field\n`universal_property'` of `IsStronglyCocartesian`. -/\nlemma universal_property {S' : ğ’®} {b' : ğ’³} (g : S âŸ¶ S') (f' : R âŸ¶ S') (hf' : f' = f â‰« g)\n    (Ï†' : a âŸ¶ b') [IsHomLift p f' Ï†'] : âˆƒ! Ï‡ : b âŸ¶ b', IsHomLift p g Ï‡ âˆ§ Ï† â‰« Ï‡ = Ï†' := by\n  subst_hom_lift p f' Ï†'; clear a b R S\n  have : p.IsHomLift (f â‰« g) Ï†' := (hf' â–¸ inferInstance)\n  apply IsStronglyCocartesian.universal_property' f\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.isCocartesian_of_isStronglyCocartesian","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœ : p.IsStronglyCocartesian f Ï†\nâŠ¢ p.IsCocartesian f Ï†","decl":"instance isCocartesian_of_isStronglyCocartesian [p.IsStronglyCocartesian f Ï†] :\n    p.IsCocartesian f Ï† where\n  universal_property := fun Ï†' => universal_property p f Ï† (ğŸ™ S) f (comp_id f).symm Ï†'\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.map_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsStronglyCocartesian f Ï†\nS' : ğ’®\nb' : ğ’³\ng : Quiver.Hom S S'\nf' : Quiver.Hom R S'\nhf' : Eq f' (CategoryTheory.CategoryStruct.comp f g)\nÏ†' : Quiver.Hom a b'\ninstâœ : p.IsHomLift f' Ï†'\nâŠ¢ p.IsHomLift g (CategoryTheory.Functor.IsStronglyCocartesian.map p f Ï† hf' Ï†')","decl":"instance map_isHomLift : IsHomLift p g (map p f Ï† hf' Ï†') :=\n  (Classical.choose_spec <| universal_property p f Ï† _ _ hf' Ï†').1.1\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.fac","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsStronglyCocartesian f Ï†\nS' : ğ’®\nb' : ğ’³\ng : Quiver.Hom S S'\nf' : Quiver.Hom R S'\nhf' : Eq f' (CategoryTheory.CategoryStruct.comp f g)\nÏ†' : Quiver.Hom a b'\ninstâœ : p.IsHomLift f' Ï†'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp Ï† (CategoryTheory.Functor.IsStronglyCocartesian.map p f Ï† hf' Ï†')) Ï†'","decl":"@[reassoc (attr := simp)]\nlemma fac : Ï† â‰« (map p f Ï† hf' Ï†') = Ï†' :=\n  (Classical.choose_spec <| universal_property p f Ï† _ _ hf' Ï†').1.2\n\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.fac_assoc","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsStronglyCocartesian f Ï†\nS' : ğ’®\nb' : ğ’³\ng : Quiver.Hom S S'\nf' : Quiver.Hom R S'\nhf' : Eq f' (CategoryTheory.CategoryStruct.comp f g)\nÏ†' : Quiver.Hom a b'\ninstâœ : p.IsHomLift f' Ï†'\nZ : ğ’³\nh : Quiver.Hom b' Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp Ï† (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCocartesian.map p f Ï† hf' Ï†') h)) (CategoryTheory.CategoryStruct.comp Ï†' h)","decl":"@[reassoc (attr := simp)]\nlemma fac : Ï† â‰« (map p f Ï† hf' Ï†') = Ï†' :=\n  (Classical.choose_spec <| universal_property p f Ï† _ _ hf' Ï†').1.2\n\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.map_uniq","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ² : p.IsStronglyCocartesian f Ï†\nS' : ğ’®\nb' : ğ’³\ng : Quiver.Hom S S'\nf' : Quiver.Hom R S'\nhf' : Eq f' (CategoryTheory.CategoryStruct.comp f g)\nÏ†' : Quiver.Hom a b'\ninstâœÂ¹ : p.IsHomLift f' Ï†'\nÏˆ : Quiver.Hom b b'\ninstâœ : p.IsHomLift g Ïˆ\nhÏˆ : Eq (CategoryTheory.CategoryStruct.comp Ï† Ïˆ) Ï†'\nâŠ¢ Eq Ïˆ (CategoryTheory.Functor.IsStronglyCocartesian.map p f Ï† hf' Ï†')","decl":"/-- Given a diagram\n```\na --Ï†--> b        b'\n|        |        |\nv        v        v\nR --f--> S --g--> S'\n```\nsuch that `Ï†` is strongly cocartesian, and morphisms `Ï†' : a âŸ¶ b'`, `Ïˆ : b âŸ¶ b'` such that\n`g â‰« Ïˆ = Ï†'`. Then `Ïˆ` is the map induced by the universal property. -/\nlemma map_uniq (Ïˆ : b âŸ¶ b') [IsHomLift p g Ïˆ] (hÏˆ : Ï† â‰« Ïˆ = Ï†') : Ïˆ = map p f Ï† hf' Ï†' :=\n  (Classical.choose_spec <| universal_property p f Ï† _ _ hf' Ï†').2 Ïˆ âŸ¨inferInstance, hÏˆâŸ©\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.ext","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ² : p.IsStronglyCocartesian f Ï†\nS' : ğ’®\nb' : ğ’³\ng : Quiver.Hom S S'\nÏˆ Ïˆ' : Quiver.Hom b b'\ninstâœÂ¹ : p.IsHomLift g Ïˆ\ninstâœ : p.IsHomLift g Ïˆ'\nh : Eq (CategoryTheory.CategoryStruct.comp Ï† Ïˆ) (CategoryTheory.CategoryStruct.comp Ï† Ïˆ')\nâŠ¢ Eq Ïˆ Ïˆ'","decl":"/-- Given a diagram\n```\na --Ï†--> b        b'\n|        |        |\nv        v        v\nR --f--> S --g--> S'\n```\nsuch that `Ï†` is strongly cocartesian, and morphisms `Ïˆ Ïˆ' : b âŸ¶ b'` such that\n`g â‰« Ïˆ = Ï†' = g â‰« Ïˆ'`. Then we have that `Ïˆ = Ïˆ'`. -/\nprotected lemma ext (Ï† : a âŸ¶ b) [IsStronglyCocartesian p f Ï†] {S' : ğ’®} {b' : ğ’³} (g : S âŸ¶ S')\n    {Ïˆ Ïˆ' : b âŸ¶ b'} [IsHomLift p g Ïˆ] [IsHomLift p g Ïˆ'] (h : Ï† â‰« Ïˆ = Ï† â‰« Ïˆ') : Ïˆ = Ïˆ' := by\n  rw [map_uniq p f Ï† (g := g) rfl (Ï† â‰« Ïˆ) Ïˆ rfl, map_uniq p f Ï† (g := g) rfl (Ï† â‰« Ïˆ) Ïˆ' h.symm]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.map_self","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœ : p.IsStronglyCocartesian f Ï†\nâŠ¢ Eq (CategoryTheory.Functor.IsStronglyCocartesian.map p f Ï† â‹¯ Ï†) (CategoryTheory.CategoryStruct.id b)","decl":"@[simp]\nlemma map_self : map p f Ï† (comp_id f).symm Ï† = ğŸ™ b := by\n  subst_hom_lift p f Ï†; symm\n  apply map_uniq\n  simp only [comp_id]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.map_comp_map","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ² : p.IsStronglyCocartesian f Ï†\nS' S'' : ğ’®\nb' b'' : ğ’³\nf' : Quiver.Hom R S'\nf'' : Quiver.Hom R S''\ng : Quiver.Hom S S'\ng' : Quiver.Hom S' S''\nH : Eq f' (CategoryTheory.CategoryStruct.comp f g)\nH' : Eq f'' (CategoryTheory.CategoryStruct.comp f' g')\nÏ†' : Quiver.Hom a b'\nÏ†'' : Quiver.Hom a b''\ninstâœÂ¹ : p.IsStronglyCocartesian f' Ï†'\ninstâœ : p.IsHomLift f'' Ï†''\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCocartesian.map p f Ï† H Ï†') (CategoryTheory.Functor.IsStronglyCocartesian.map p f' Ï†' H' Ï†'')) (CategoryTheory.Functor.IsStronglyCocartesian.map p f Ï† â‹¯ Ï†'')","decl":"/-- When its possible to compare the two, the composition of two `IsStronglyCocartesian.map` will\nalso be given by a `IsStronglyCocartesian.map`. In other words, given diagrams\n```\na --Ï†--> b        b'         b''\n|        |        |          |\nv        v        v          v\nR --f--> S --g--> S' --g'--> S'\n```\nand\n```\na --Ï†'--> b'\n|         |\nv         v\nR --f'--> S'\n\n```\nand\n```\na --Ï†''--> b''\n|          |\nv          v\nR --f''--> S''\n```\nsuch that `Ï†` and `Ï†'` are strongly cocartesian morphisms, and such that `f' = f â‰« g` and\n`f'' = f' â‰« g'`. Then composing the induced map from `b âŸ¶ b'` with the induced map from\n`b' âŸ¶ b''` gives the induced map from `b âŸ¶ b''`. -/\n@[reassoc (attr := simp)]\nlemma map_comp_map {S' S'' : ğ’®} {b' b'' : ğ’³} {f' : R âŸ¶ S'} {f'' : R âŸ¶ S''} {g : S âŸ¶ S'}\n    {g' : S' âŸ¶ S''} (H : f' = f â‰« g) (H' : f'' = f' â‰« g') (Ï†' : a âŸ¶ b') (Ï†'' : a âŸ¶ b'')\n    [IsStronglyCocartesian p f' Ï†'] [IsHomLift p f'' Ï†''] :\n    map p f Ï† H Ï†' â‰« map p f' Ï†' H' Ï†'' =\n      map p f Ï† (show f'' = f â‰« (g â‰« g') by rwa [â† assoc, â† H]) Ï†'' := by\n  apply map_uniq p f Ï†\n  simp only [fac_assoc, fac]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.map_comp_map_assoc","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ² : p.IsStronglyCocartesian f Ï†\nS' S'' : ğ’®\nb' b'' : ğ’³\nf' : Quiver.Hom R S'\nf'' : Quiver.Hom R S''\ng : Quiver.Hom S S'\ng' : Quiver.Hom S' S''\nH : Eq f' (CategoryTheory.CategoryStruct.comp f g)\nH' : Eq f'' (CategoryTheory.CategoryStruct.comp f' g')\nÏ†' : Quiver.Hom a b'\nÏ†'' : Quiver.Hom a b''\ninstâœÂ¹ : p.IsStronglyCocartesian f' Ï†'\ninstâœ : p.IsHomLift f'' Ï†''\nZ : ğ’³\nh : Quiver.Hom b'' Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCocartesian.map p f Ï† H Ï†') (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCocartesian.map p f' Ï†' H' Ï†'') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCocartesian.map p f Ï† â‹¯ Ï†'') h)","decl":"/-- When its possible to compare the two, the composition of two `IsStronglyCocartesian.map` will\nalso be given by a `IsStronglyCocartesian.map`. In other words, given diagrams\n```\na --Ï†--> b        b'         b''\n|        |        |          |\nv        v        v          v\nR --f--> S --g--> S' --g'--> S'\n```\nand\n```\na --Ï†'--> b'\n|         |\nv         v\nR --f'--> S'\n\n```\nand\n```\na --Ï†''--> b''\n|          |\nv          v\nR --f''--> S''\n```\nsuch that `Ï†` and `Ï†'` are strongly cocartesian morphisms, and such that `f' = f â‰« g` and\n`f'' = f' â‰« g'`. Then composing the induced map from `b âŸ¶ b'` with the induced map from\n`b' âŸ¶ b''` gives the induced map from `b âŸ¶ b''`. -/\n@[reassoc (attr := simp)]\nlemma map_comp_map {S' S'' : ğ’®} {b' b'' : ğ’³} {f' : R âŸ¶ S'} {f'' : R âŸ¶ S''} {g : S âŸ¶ S'}\n    {g' : S' âŸ¶ S''} (H : f' = f â‰« g) (H' : f'' = f' â‰« g') (Ï†' : a âŸ¶ b') (Ï†'' : a âŸ¶ b'')\n    [IsStronglyCocartesian p f' Ï†'] [IsHomLift p f'' Ï†''] :\n    map p f Ï† H Ï†' â‰« map p f' Ï†' H' Ï†'' =\n      map p f Ï† (show f'' = f â‰« (g â‰« g') by rwa [â† assoc, â† H]) Ï†'' := by\n  apply map_uniq p f Ï†\n  simp only [fac_assoc, fac]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.comp","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S T : ğ’®\na b c : ğ’³\nf : Quiver.Hom R S\ng : Quiver.Hom S T\nÏ† : Quiver.Hom a b\nÏˆ : Quiver.Hom b c\ninstâœÂ¹ : p.IsStronglyCocartesian f Ï†\ninstâœ : p.IsStronglyCocartesian g Ïˆ\nâŠ¢ p.IsStronglyCocartesian (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp Ï† Ïˆ)","decl":"/-- Given two strongly cocartesian morphisms `Ï†`, `Ïˆ` as follows\n```\na --Ï†--> b --Ïˆ--> c\n|        |        |\nv        v        v\nR --f--> S --g--> T\n```\nThen the composite `Ï† â‰« Ïˆ` is also strongly cocartesian. -/\ninstance comp [IsStronglyCocartesian p f Ï†] [IsStronglyCocartesian p g Ïˆ] :\n    IsStronglyCocartesian p (f â‰« g) (Ï† â‰« Ïˆ) where\n  universal_property' := by\n    intro c' h Ï„ hÏ„\n    use map p g Ïˆ (f' := g â‰« h) rfl <| map p f Ï† (assoc f g h) Ï„\n    refine âŸ¨âŸ¨inferInstance, ?_âŸ©, ?_âŸ©\n    Â· simp only [assoc, fac]\n    Â· intro Ï€' âŸ¨hÏ€'â‚, hÏ€'â‚‚âŸ©\n      apply map_uniq\n      apply map_uniq\n      simp only [â† hÏ€'â‚‚, assoc]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.of_comp","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S T : ğ’®\na b c : ğ’³\nf : Quiver.Hom R S\ng : Quiver.Hom S T\nÏ† : Quiver.Hom a b\nÏˆ : Quiver.Hom b c\ninstâœÂ² : p.IsStronglyCocartesian f Ï†\ninstâœÂ¹ : p.IsStronglyCocartesian (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp Ï† Ïˆ)\ninstâœ : p.IsHomLift g Ïˆ\nâŠ¢ p.IsStronglyCocartesian g Ïˆ","decl":"/-- Given two commutative squares\n```\na --Ï†--> b --Ïˆ--> c\n|        |        |\nv        v        v\nR --f--> S --g--> T\n```\nsuch that `Ï† â‰« Ïˆ` and `Ï†` are strongly cocartesian, then so is `Ïˆ`. -/\nprotected lemma of_comp [IsStronglyCocartesian p f Ï†] [IsStronglyCocartesian p (f â‰« g) (Ï† â‰« Ïˆ)]\n    [IsHomLift p g Ïˆ] : IsStronglyCocartesian p g Ïˆ where\n  universal_property' := by\n    intro c' h Ï„ hÏ„\n    have hâ‚ : IsHomLift p (f â‰« g â‰« h) (Ï† â‰« Ï„) := by simpa using IsHomLift.comp p f (g â‰« h) Ï† Ï„\n    /- We get a morphism `Ï€ : c âŸ¶ c'` such that `(Ï† â‰« Ïˆ) â‰« Ï€ = Ï† â‰« Ï„` from the universal property\n    of `Ï† â‰« Ïˆ`. This will be the morphism induced by `Ï†`. -/\n    use map p (f â‰« g) (Ï† â‰« Ïˆ) (f' := f â‰« g â‰« h) (assoc f g h).symm (Ï† â‰« Ï„)\n    refine âŸ¨âŸ¨inferInstance, ?_âŸ©, ?_âŸ©\n    /- The fact that `Ïˆ â‰« Ï€ = Ï„` follows from `Ï† â‰« Ïˆ â‰« Ï€ = Ï† â‰« Ï„` and the universal property of\n    `Ï†`. -/\n    Â· apply IsStronglyCocartesian.ext p f Ï† (g â‰« h) <| by simp only [â† assoc, fac]\n    -- Finally, uniqueness of `Ï€` comes from the universal property of `Ï† â‰« Ïˆ`.\n    Â· intro Ï€' âŸ¨hÏ€'â‚, hÏ€'â‚‚âŸ©\n      apply map_uniq\n      simp [hÏ€'â‚‚.symm]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.of_iso","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : CategoryTheory.Iso a b\ninstâœ : p.IsHomLift f Ï†.hom\nâŠ¢ p.IsStronglyCocartesian f Ï†.hom","decl":"instance of_iso (Ï† : a â‰… b) [IsHomLift p f Ï†.hom] : IsStronglyCocartesian p f Ï†.hom where\n  universal_property' := by\n    intro b' g Ï„ hÏ„\n    use Ï†.inv â‰« Ï„\n    refine âŸ¨?_, by aesop_catâŸ©\n    simpa [â† assoc] using (IsHomLift.comp p (isoOfIsoLift p f Ï†).inv (f â‰« g) Ï†.inv Ï„)\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.of_isIso","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsHomLift f Ï†\ninstâœ : CategoryTheory.IsIso Ï†\nâŠ¢ p.IsStronglyCocartesian f Ï†","decl":"instance of_isIso (Ï† : a âŸ¶ b) [IsHomLift p f Ï†] [IsIso Ï†] : IsStronglyCocartesian p f Ï† :=\n  @IsStronglyCocartesian.of_iso _ _ _ _ p _ _ _ _ f (asIso Ï†) (by aesop)\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.isIso_of_base_isIso","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsStronglyCocartesian f Ï†\ninstâœ : CategoryTheory.IsIso f\nâŠ¢ CategoryTheory.IsIso Ï†","decl":"/-- A strongly cocartesian arrow lying over an isomorphism is an isomorphism. -/\nlemma isIso_of_base_isIso (Ï† : a âŸ¶ b) [IsStronglyCocartesian p f Ï†] [IsIso f] : IsIso Ï† := by\n  subst_hom_lift p f Ï†; clear a b R S\n  -- Let `Ï†'` be the morphism induced by applying universal property to `ğŸ™ a` lying over `f â‰« fâ»Â¹`.\n  let Ï†' := map p (p.map Ï†) Ï† (IsIso.hom_inv_id (p.map Ï†)).symm (ğŸ™ a)\n  use Ï†'\n  -- `Ï† â‰« Ï†' = ğŸ™ a` follows immediately from the universal property.\n  have inv_hom : Ï† â‰« Ï†' = ğŸ™ a := fac p (p.map Ï†) Ï† _ (ğŸ™ a)\n  refine âŸ¨inv_hom, ?_âŸ©\n  -- We will now show that `Ï†' â‰« Ï† = ğŸ™ b` by showing that `Ï† â‰« (Ï†' â‰« Ï†) = Ï† â‰« ğŸ™ b`.\n  have hâ‚ : IsHomLift p (ğŸ™ (p.obj b)) (Ï†' â‰« Ï†) := by\n    rw [â† IsIso.inv_hom_id (p.map Ï†)]\n    apply IsHomLift.comp\n  apply IsStronglyCocartesian.ext p (p.map Ï†) Ï† (ğŸ™ (p.obj b))\n  simp only [â† assoc, inv_hom, comp_id, id_comp]\n\n"}
