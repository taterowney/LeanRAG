{"name":"CategoryTheory.Functor.IsCocartesian.toIsHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\nself : p.IsCocartesian f φ\n⊢ p.IsHomLift f φ","decl":"/-- A morphism `φ : a ⟶ b` in `𝒳` lying over `f : R ⟶ S` in `𝒮` is cocartesian if for all\nmorphisms `φ' : a ⟶ b'`, also lying over `f`, there exists a unique morphism `χ : b ⟶ b'` lifting\n`𝟙 S` such that `φ' = φ ≫ χ`. -/\nclass IsCocartesian extends IsHomLift p f φ : Prop where\n  universal_property {b' : 𝒳} (φ' : a ⟶ b') [IsHomLift p f φ'] :\n      ∃! χ : b ⟶ b', IsHomLift p (𝟙 S) χ ∧ φ ≫ χ = φ'\n\n"}
{"name":"CategoryTheory.Functor.IsCocartesian.universal_property","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\nself : p.IsCocartesian f φ\nb' : 𝒳\nφ' : Quiver.Hom a b'\ninst✝ : p.IsHomLift f φ'\n⊢ ExistsUnique fun χ => And (p.IsHomLift (CategoryTheory.CategoryStruct.id S) χ) (Eq (CategoryTheory.CategoryStruct.comp φ χ) φ')","decl":"/-- A morphism `φ : a ⟶ b` in `𝒳` lying over `f : R ⟶ S` in `𝒮` is cocartesian if for all\nmorphisms `φ' : a ⟶ b'`, also lying over `f`, there exists a unique morphism `χ : b ⟶ b'` lifting\n`𝟙 S` such that `φ' = φ ≫ χ`. -/\nclass IsCocartesian extends IsHomLift p f φ : Prop where\n  universal_property {b' : 𝒳} (φ' : a ⟶ b') [IsHomLift p f φ'] :\n      ∃! χ : b ⟶ b', IsHomLift p (𝟙 S) χ ∧ φ ≫ χ = φ'\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.toIsHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\nself : p.IsStronglyCocartesian f φ\n⊢ p.IsHomLift f φ","decl":"/-- A morphism `φ : a ⟶ b` in `𝒳` lying over `f : R ⟶ S` in `𝒮` is strongly cocartesian if for\nall morphisms `φ' : a ⟶ b'` and all diagrams of the form\n```\na --φ--> b        b'\n|        |        |\nv        v        v\nR --f--> S --g--> S'\n```\nsuch that `φ'` lifts `f ≫ g`, there exists a lift `χ` of `g` such that `φ' = χ ≫ φ`. -/\n@[stacks 02XK]\nclass IsStronglyCocartesian extends IsHomLift p f φ : Prop where\n  universal_property' {b' : 𝒳} (g : S ⟶ p.obj b') (φ' : a ⟶ b') [IsHomLift p (f ≫ g) φ'] :\n      ∃! χ : b ⟶ b', IsHomLift p g χ ∧ φ ≫ χ = φ'\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.universal_property'","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\nself : p.IsStronglyCocartesian f φ\nb' : 𝒳\ng : Quiver.Hom S (p.obj b')\nφ' : Quiver.Hom a b'\ninst✝ : p.IsHomLift (CategoryTheory.CategoryStruct.comp f g) φ'\n⊢ ExistsUnique fun χ => And (p.IsHomLift g χ) (Eq (CategoryTheory.CategoryStruct.comp φ χ) φ')","decl":"/-- A morphism `φ : a ⟶ b` in `𝒳` lying over `f : R ⟶ S` in `𝒮` is strongly cocartesian if for\nall morphisms `φ' : a ⟶ b'` and all diagrams of the form\n```\na --φ--> b        b'\n|        |        |\nv        v        v\nR --f--> S --g--> S'\n```\nsuch that `φ'` lifts `f ≫ g`, there exists a lift `χ` of `g` such that `φ' = χ ≫ φ`. -/\n@[stacks 02XK]\nclass IsStronglyCocartesian extends IsHomLift p f φ : Prop where\n  universal_property' {b' : 𝒳} (g : S ⟶ p.obj b') (φ' : a ⟶ b') [IsHomLift p (f ≫ g) φ'] :\n      ∃! χ : b ⟶ b', IsHomLift p g χ ∧ φ ≫ χ = φ'\n\n"}
{"name":"CategoryTheory.Functor.IsCocartesian.map_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsCocartesian f φ\nb' : 𝒳\nφ' : Quiver.Hom a b'\ninst✝ : p.IsHomLift f φ'\n⊢ p.IsHomLift (CategoryTheory.CategoryStruct.id S) (CategoryTheory.Functor.IsCocartesian.map p f φ φ')","decl":"instance map_isHomLift : IsHomLift p (𝟙 S) (IsCocartesian.map p f φ φ') :=\n  (Classical.choose_spec <| IsCocartesian.universal_property (p:=p) (f:=f) (φ:=φ) φ').1.1\n\n"}
{"name":"CategoryTheory.Functor.IsCocartesian.fac_assoc","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsCocartesian f φ\nb' : 𝒳\nφ' : Quiver.Hom a b'\ninst✝ : p.IsHomLift f φ'\nZ : 𝒳\nh : Quiver.Hom b' Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp φ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsCocartesian.map p f φ φ') h)) (CategoryTheory.CategoryStruct.comp φ' h)","decl":"@[reassoc (attr := simp)]\nlemma fac : φ ≫ IsCocartesian.map p f φ φ' = φ' :=\n  (Classical.choose_spec <| IsCocartesian.universal_property (p:=p) (f:=f) (φ:=φ) φ').1.2\n\n"}
{"name":"CategoryTheory.Functor.IsCocartesian.fac","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsCocartesian f φ\nb' : 𝒳\nφ' : Quiver.Hom a b'\ninst✝ : p.IsHomLift f φ'\n⊢ Eq (CategoryTheory.CategoryStruct.comp φ (CategoryTheory.Functor.IsCocartesian.map p f φ φ')) φ'","decl":"@[reassoc (attr := simp)]\nlemma fac : φ ≫ IsCocartesian.map p f φ φ' = φ' :=\n  (Classical.choose_spec <| IsCocartesian.universal_property (p:=p) (f:=f) (φ:=φ) φ').1.2\n\n"}
{"name":"CategoryTheory.Functor.IsCocartesian.map_uniq","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝³ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝² : p.IsCocartesian f φ\nb' : 𝒳\nφ' : Quiver.Hom a b'\ninst✝¹ : p.IsHomLift f φ'\nψ : Quiver.Hom b b'\ninst✝ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) ψ\nhψ : Eq (CategoryTheory.CategoryStruct.comp φ ψ) φ'\n⊢ Eq ψ (CategoryTheory.Functor.IsCocartesian.map p f φ φ')","decl":"/-- Given a cocartesian morphism `φ : a ⟶ b` lying over `f : R ⟶ S` in `𝒳`, and another morphism\n`φ' : a ⟶ b'` which also lifts `f`. Then any morphism `ψ : b ⟶ b'` lifting `𝟙 S` such that\n`g ≫ ψ = φ'` must equal the map induced by the universal property of `φ`. -/\nlemma map_uniq (ψ : b ⟶ b') [IsHomLift p (𝟙 S) ψ] (hψ : φ ≫ ψ = φ') :\n    ψ = IsCocartesian.map p f φ φ' :=\n  (Classical.choose_spec <| IsCocartesian.universal_property (p:=p) (f:=f) (φ:=φ) φ').2\n    ψ ⟨inferInstance, hψ⟩\n\n"}
{"name":"CategoryTheory.Functor.IsCocartesian.ext","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝³ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝² : p.IsCocartesian f φ\nb' : 𝒳\nψ ψ' : Quiver.Hom b b'\ninst✝¹ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) ψ\ninst✝ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) ψ'\nh : Eq (CategoryTheory.CategoryStruct.comp φ ψ) (CategoryTheory.CategoryStruct.comp φ ψ')\n⊢ Eq ψ ψ'","decl":"/-- Given a cocartesian morphism `φ : a ⟶ b` lying over `f : R ⟶ S` in `𝒳`, and two morphisms\n`ψ ψ' : b ⟶ b'` lifting `𝟙 S` such that `φ ≫ ψ = φ ≫ ψ'`. Then we must have `ψ = ψ'`. -/\nprotected lemma ext (φ : a ⟶ b) [IsCocartesian p f φ] {b' : 𝒳} (ψ ψ' : b ⟶ b')\n    [IsHomLift p (𝟙 S) ψ] [IsHomLift p (𝟙 S) ψ'] (h : φ ≫ ψ = φ ≫ ψ') : ψ = ψ' := by\n  rw [map_uniq p f φ (φ ≫ ψ) ψ rfl, map_uniq p f φ (φ ≫ ψ) ψ' h.symm]\n\n"}
{"name":"CategoryTheory.Functor.IsCocartesian.map_self","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝ : p.IsCocartesian f φ\n⊢ Eq (CategoryTheory.Functor.IsCocartesian.map p f φ φ) (CategoryTheory.CategoryStruct.id b)","decl":"@[simp]\nlemma map_self : IsCocartesian.map p f φ φ = 𝟙 b := by\n  subst_hom_lift p f φ; symm\n  apply map_uniq\n  simp only [comp_id]\n\n"}
{"name":"CategoryTheory.Functor.IsCocartesian.of_comp_iso","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsCocartesian f φ\nb' : 𝒳\nφ' : CategoryTheory.Iso b b'\ninst✝ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) φ'.hom\n⊢ p.IsCocartesian f (CategoryTheory.CategoryStruct.comp φ φ'.hom)","decl":"/-- Postcomposing a cocartesian morphism with an isomorphism lifting the identity is cocartesian. -/\ninstance of_comp_iso {b' : 𝒳} (φ' : b ≅ b') [IsHomLift p (𝟙 S) φ'.hom] :\n    IsCocartesian p f (φ ≫ φ'.hom) where\n  universal_property := by\n    intro c ψ hψ\n    use φ'.inv ≫ IsCocartesian.map p f φ ψ\n    refine ⟨⟨inferInstance, by simp⟩, ?_⟩\n    rintro τ ⟨hτ₁, hτ₂⟩\n    rw [Iso.eq_inv_comp]\n    apply map_uniq\n    exact ((assoc φ _ _) ▸ hτ₂)\n\n"}
{"name":"CategoryTheory.Functor.IsCocartesian.of_iso_comp","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsCocartesian f φ\na' : 𝒳\nφ' : CategoryTheory.Iso a' a\ninst✝ : p.IsHomLift (CategoryTheory.CategoryStruct.id R) φ'.hom\n⊢ p.IsCocartesian f (CategoryTheory.CategoryStruct.comp φ'.hom φ)","decl":"/-- Precomposing a cocartesian morphism with an isomorphism lifting the identity is cocartesian. -/\ninstance of_iso_comp {a' : 𝒳} (φ' : a' ≅ a) [IsHomLift p (𝟙 R) φ'.hom] :\n    IsCocartesian p f (φ'.hom ≫ φ) where\n  universal_property := by\n    intro c ψ hψ\n    use IsCocartesian.map p f φ (φ'.inv ≫ ψ)\n    refine ⟨⟨inferInstance, by simp⟩, ?_⟩\n    rintro τ ⟨hτ₁, hτ₂⟩\n    apply map_uniq\n    simp only [Iso.eq_inv_comp, ← assoc, hτ₂]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.universal_property","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsStronglyCocartesian f φ\nS' : 𝒮\nb' : 𝒳\ng : Quiver.Hom S S'\nf' : Quiver.Hom R S'\nhf' : Eq f' (CategoryTheory.CategoryStruct.comp f g)\nφ' : Quiver.Hom a b'\ninst✝ : p.IsHomLift f' φ'\n⊢ ExistsUnique fun χ => And (p.IsHomLift g χ) (Eq (CategoryTheory.CategoryStruct.comp φ χ) φ')","decl":"/-- The universal property of a strongly cocartesian morphism.\n\nThis lemma is more flexible with respect to non-definitional equalities than the field\n`universal_property'` of `IsStronglyCocartesian`. -/\nlemma universal_property {S' : 𝒮} {b' : 𝒳} (g : S ⟶ S') (f' : R ⟶ S') (hf' : f' = f ≫ g)\n    (φ' : a ⟶ b') [IsHomLift p f' φ'] : ∃! χ : b ⟶ b', IsHomLift p g χ ∧ φ ≫ χ = φ' := by\n  subst_hom_lift p f' φ'; clear a b R S\n  have : p.IsHomLift (f ≫ g) φ' := (hf' ▸ inferInstance)\n  apply IsStronglyCocartesian.universal_property' f\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.isCocartesian_of_isStronglyCocartesian","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝ : p.IsStronglyCocartesian f φ\n⊢ p.IsCocartesian f φ","decl":"instance isCocartesian_of_isStronglyCocartesian [p.IsStronglyCocartesian f φ] :\n    p.IsCocartesian f φ where\n  universal_property := fun φ' => universal_property p f φ (𝟙 S) f (comp_id f).symm φ'\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.map_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsStronglyCocartesian f φ\nS' : 𝒮\nb' : 𝒳\ng : Quiver.Hom S S'\nf' : Quiver.Hom R S'\nhf' : Eq f' (CategoryTheory.CategoryStruct.comp f g)\nφ' : Quiver.Hom a b'\ninst✝ : p.IsHomLift f' φ'\n⊢ p.IsHomLift g (CategoryTheory.Functor.IsStronglyCocartesian.map p f φ hf' φ')","decl":"instance map_isHomLift : IsHomLift p g (map p f φ hf' φ') :=\n  (Classical.choose_spec <| universal_property p f φ _ _ hf' φ').1.1\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.fac","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsStronglyCocartesian f φ\nS' : 𝒮\nb' : 𝒳\ng : Quiver.Hom S S'\nf' : Quiver.Hom R S'\nhf' : Eq f' (CategoryTheory.CategoryStruct.comp f g)\nφ' : Quiver.Hom a b'\ninst✝ : p.IsHomLift f' φ'\n⊢ Eq (CategoryTheory.CategoryStruct.comp φ (CategoryTheory.Functor.IsStronglyCocartesian.map p f φ hf' φ')) φ'","decl":"@[reassoc (attr := simp)]\nlemma fac : φ ≫ (map p f φ hf' φ') = φ' :=\n  (Classical.choose_spec <| universal_property p f φ _ _ hf' φ').1.2\n\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.fac_assoc","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsStronglyCocartesian f φ\nS' : 𝒮\nb' : 𝒳\ng : Quiver.Hom S S'\nf' : Quiver.Hom R S'\nhf' : Eq f' (CategoryTheory.CategoryStruct.comp f g)\nφ' : Quiver.Hom a b'\ninst✝ : p.IsHomLift f' φ'\nZ : 𝒳\nh : Quiver.Hom b' Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp φ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCocartesian.map p f φ hf' φ') h)) (CategoryTheory.CategoryStruct.comp φ' h)","decl":"@[reassoc (attr := simp)]\nlemma fac : φ ≫ (map p f φ hf' φ') = φ' :=\n  (Classical.choose_spec <| universal_property p f φ _ _ hf' φ').1.2\n\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.map_uniq","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝³ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝² : p.IsStronglyCocartesian f φ\nS' : 𝒮\nb' : 𝒳\ng : Quiver.Hom S S'\nf' : Quiver.Hom R S'\nhf' : Eq f' (CategoryTheory.CategoryStruct.comp f g)\nφ' : Quiver.Hom a b'\ninst✝¹ : p.IsHomLift f' φ'\nψ : Quiver.Hom b b'\ninst✝ : p.IsHomLift g ψ\nhψ : Eq (CategoryTheory.CategoryStruct.comp φ ψ) φ'\n⊢ Eq ψ (CategoryTheory.Functor.IsStronglyCocartesian.map p f φ hf' φ')","decl":"/-- Given a diagram\n```\na --φ--> b        b'\n|        |        |\nv        v        v\nR --f--> S --g--> S'\n```\nsuch that `φ` is strongly cocartesian, and morphisms `φ' : a ⟶ b'`, `ψ : b ⟶ b'` such that\n`g ≫ ψ = φ'`. Then `ψ` is the map induced by the universal property. -/\nlemma map_uniq (ψ : b ⟶ b') [IsHomLift p g ψ] (hψ : φ ≫ ψ = φ') : ψ = map p f φ hf' φ' :=\n  (Classical.choose_spec <| universal_property p f φ _ _ hf' φ').2 ψ ⟨inferInstance, hψ⟩\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.ext","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝³ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝² : p.IsStronglyCocartesian f φ\nS' : 𝒮\nb' : 𝒳\ng : Quiver.Hom S S'\nψ ψ' : Quiver.Hom b b'\ninst✝¹ : p.IsHomLift g ψ\ninst✝ : p.IsHomLift g ψ'\nh : Eq (CategoryTheory.CategoryStruct.comp φ ψ) (CategoryTheory.CategoryStruct.comp φ ψ')\n⊢ Eq ψ ψ'","decl":"/-- Given a diagram\n```\na --φ--> b        b'\n|        |        |\nv        v        v\nR --f--> S --g--> S'\n```\nsuch that `φ` is strongly cocartesian, and morphisms `ψ ψ' : b ⟶ b'` such that\n`g ≫ ψ = φ' = g ≫ ψ'`. Then we have that `ψ = ψ'`. -/\nprotected lemma ext (φ : a ⟶ b) [IsStronglyCocartesian p f φ] {S' : 𝒮} {b' : 𝒳} (g : S ⟶ S')\n    {ψ ψ' : b ⟶ b'} [IsHomLift p g ψ] [IsHomLift p g ψ'] (h : φ ≫ ψ = φ ≫ ψ') : ψ = ψ' := by\n  rw [map_uniq p f φ (g := g) rfl (φ ≫ ψ) ψ rfl, map_uniq p f φ (g := g) rfl (φ ≫ ψ) ψ' h.symm]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.map_self","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝ : p.IsStronglyCocartesian f φ\n⊢ Eq (CategoryTheory.Functor.IsStronglyCocartesian.map p f φ ⋯ φ) (CategoryTheory.CategoryStruct.id b)","decl":"@[simp]\nlemma map_self : map p f φ (comp_id f).symm φ = 𝟙 b := by\n  subst_hom_lift p f φ; symm\n  apply map_uniq\n  simp only [comp_id]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.map_comp_map","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝³ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝² : p.IsStronglyCocartesian f φ\nS' S'' : 𝒮\nb' b'' : 𝒳\nf' : Quiver.Hom R S'\nf'' : Quiver.Hom R S''\ng : Quiver.Hom S S'\ng' : Quiver.Hom S' S''\nH : Eq f' (CategoryTheory.CategoryStruct.comp f g)\nH' : Eq f'' (CategoryTheory.CategoryStruct.comp f' g')\nφ' : Quiver.Hom a b'\nφ'' : Quiver.Hom a b''\ninst✝¹ : p.IsStronglyCocartesian f' φ'\ninst✝ : p.IsHomLift f'' φ''\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCocartesian.map p f φ H φ') (CategoryTheory.Functor.IsStronglyCocartesian.map p f' φ' H' φ'')) (CategoryTheory.Functor.IsStronglyCocartesian.map p f φ ⋯ φ'')","decl":"/-- When its possible to compare the two, the composition of two `IsStronglyCocartesian.map` will\nalso be given by a `IsStronglyCocartesian.map`. In other words, given diagrams\n```\na --φ--> b        b'         b''\n|        |        |          |\nv        v        v          v\nR --f--> S --g--> S' --g'--> S'\n```\nand\n```\na --φ'--> b'\n|         |\nv         v\nR --f'--> S'\n\n```\nand\n```\na --φ''--> b''\n|          |\nv          v\nR --f''--> S''\n```\nsuch that `φ` and `φ'` are strongly cocartesian morphisms, and such that `f' = f ≫ g` and\n`f'' = f' ≫ g'`. Then composing the induced map from `b ⟶ b'` with the induced map from\n`b' ⟶ b''` gives the induced map from `b ⟶ b''`. -/\n@[reassoc (attr := simp)]\nlemma map_comp_map {S' S'' : 𝒮} {b' b'' : 𝒳} {f' : R ⟶ S'} {f'' : R ⟶ S''} {g : S ⟶ S'}\n    {g' : S' ⟶ S''} (H : f' = f ≫ g) (H' : f'' = f' ≫ g') (φ' : a ⟶ b') (φ'' : a ⟶ b'')\n    [IsStronglyCocartesian p f' φ'] [IsHomLift p f'' φ''] :\n    map p f φ H φ' ≫ map p f' φ' H' φ'' =\n      map p f φ (show f'' = f ≫ (g ≫ g') by rwa [← assoc, ← H]) φ'' := by\n  apply map_uniq p f φ\n  simp only [fac_assoc, fac]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.map_comp_map_assoc","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝³ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝² : p.IsStronglyCocartesian f φ\nS' S'' : 𝒮\nb' b'' : 𝒳\nf' : Quiver.Hom R S'\nf'' : Quiver.Hom R S''\ng : Quiver.Hom S S'\ng' : Quiver.Hom S' S''\nH : Eq f' (CategoryTheory.CategoryStruct.comp f g)\nH' : Eq f'' (CategoryTheory.CategoryStruct.comp f' g')\nφ' : Quiver.Hom a b'\nφ'' : Quiver.Hom a b''\ninst✝¹ : p.IsStronglyCocartesian f' φ'\ninst✝ : p.IsHomLift f'' φ''\nZ : 𝒳\nh : Quiver.Hom b'' Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCocartesian.map p f φ H φ') (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCocartesian.map p f' φ' H' φ'') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCocartesian.map p f φ ⋯ φ'') h)","decl":"/-- When its possible to compare the two, the composition of two `IsStronglyCocartesian.map` will\nalso be given by a `IsStronglyCocartesian.map`. In other words, given diagrams\n```\na --φ--> b        b'         b''\n|        |        |          |\nv        v        v          v\nR --f--> S --g--> S' --g'--> S'\n```\nand\n```\na --φ'--> b'\n|         |\nv         v\nR --f'--> S'\n\n```\nand\n```\na --φ''--> b''\n|          |\nv          v\nR --f''--> S''\n```\nsuch that `φ` and `φ'` are strongly cocartesian morphisms, and such that `f' = f ≫ g` and\n`f'' = f' ≫ g'`. Then composing the induced map from `b ⟶ b'` with the induced map from\n`b' ⟶ b''` gives the induced map from `b ⟶ b''`. -/\n@[reassoc (attr := simp)]\nlemma map_comp_map {S' S'' : 𝒮} {b' b'' : 𝒳} {f' : R ⟶ S'} {f'' : R ⟶ S''} {g : S ⟶ S'}\n    {g' : S' ⟶ S''} (H : f' = f ≫ g) (H' : f'' = f' ≫ g') (φ' : a ⟶ b') (φ'' : a ⟶ b'')\n    [IsStronglyCocartesian p f' φ'] [IsHomLift p f'' φ''] :\n    map p f φ H φ' ≫ map p f' φ' H' φ'' =\n      map p f φ (show f'' = f ≫ (g ≫ g') by rwa [← assoc, ← H]) φ'' := by\n  apply map_uniq p f φ\n  simp only [fac_assoc, fac]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.comp","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S T : 𝒮\na b c : 𝒳\nf : Quiver.Hom R S\ng : Quiver.Hom S T\nφ : Quiver.Hom a b\nψ : Quiver.Hom b c\ninst✝¹ : p.IsStronglyCocartesian f φ\ninst✝ : p.IsStronglyCocartesian g ψ\n⊢ p.IsStronglyCocartesian (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp φ ψ)","decl":"/-- Given two strongly cocartesian morphisms `φ`, `ψ` as follows\n```\na --φ--> b --ψ--> c\n|        |        |\nv        v        v\nR --f--> S --g--> T\n```\nThen the composite `φ ≫ ψ` is also strongly cocartesian. -/\ninstance comp [IsStronglyCocartesian p f φ] [IsStronglyCocartesian p g ψ] :\n    IsStronglyCocartesian p (f ≫ g) (φ ≫ ψ) where\n  universal_property' := by\n    intro c' h τ hτ\n    use map p g ψ (f' := g ≫ h) rfl <| map p f φ (assoc f g h) τ\n    refine ⟨⟨inferInstance, ?_⟩, ?_⟩\n    · simp only [assoc, fac]\n    · intro π' ⟨hπ'₁, hπ'₂⟩\n      apply map_uniq\n      apply map_uniq\n      simp only [← hπ'₂, assoc]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.of_comp","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝³ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S T : 𝒮\na b c : 𝒳\nf : Quiver.Hom R S\ng : Quiver.Hom S T\nφ : Quiver.Hom a b\nψ : Quiver.Hom b c\ninst✝² : p.IsStronglyCocartesian f φ\ninst✝¹ : p.IsStronglyCocartesian (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp φ ψ)\ninst✝ : p.IsHomLift g ψ\n⊢ p.IsStronglyCocartesian g ψ","decl":"/-- Given two commutative squares\n```\na --φ--> b --ψ--> c\n|        |        |\nv        v        v\nR --f--> S --g--> T\n```\nsuch that `φ ≫ ψ` and `φ` are strongly cocartesian, then so is `ψ`. -/\nprotected lemma of_comp [IsStronglyCocartesian p f φ] [IsStronglyCocartesian p (f ≫ g) (φ ≫ ψ)]\n    [IsHomLift p g ψ] : IsStronglyCocartesian p g ψ where\n  universal_property' := by\n    intro c' h τ hτ\n    have h₁ : IsHomLift p (f ≫ g ≫ h) (φ ≫ τ) := by simpa using IsHomLift.comp p f (g ≫ h) φ τ\n    /- We get a morphism `π : c ⟶ c'` such that `(φ ≫ ψ) ≫ π = φ ≫ τ` from the universal property\n    of `φ ≫ ψ`. This will be the morphism induced by `φ`. -/\n    use map p (f ≫ g) (φ ≫ ψ) (f' := f ≫ g ≫ h) (assoc f g h).symm (φ ≫ τ)\n    refine ⟨⟨inferInstance, ?_⟩, ?_⟩\n    /- The fact that `ψ ≫ π = τ` follows from `φ ≫ ψ ≫ π = φ ≫ τ` and the universal property of\n    `φ`. -/\n    · apply IsStronglyCocartesian.ext p f φ (g ≫ h) <| by simp only [← assoc, fac]\n    -- Finally, uniqueness of `π` comes from the universal property of `φ ≫ ψ`.\n    · intro π' ⟨hπ'₁, hπ'₂⟩\n      apply map_uniq\n      simp [hπ'₂.symm]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.of_iso","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : CategoryTheory.Iso a b\ninst✝ : p.IsHomLift f φ.hom\n⊢ p.IsStronglyCocartesian f φ.hom","decl":"instance of_iso (φ : a ≅ b) [IsHomLift p f φ.hom] : IsStronglyCocartesian p f φ.hom where\n  universal_property' := by\n    intro b' g τ hτ\n    use φ.inv ≫ τ\n    refine ⟨?_, by aesop_cat⟩\n    simpa [← assoc] using (IsHomLift.comp p (isoOfIsoLift p f φ).inv (f ≫ g) φ.inv τ)\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.of_isIso","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsHomLift f φ\ninst✝ : CategoryTheory.IsIso φ\n⊢ p.IsStronglyCocartesian f φ","decl":"instance of_isIso (φ : a ⟶ b) [IsHomLift p f φ] [IsIso φ] : IsStronglyCocartesian p f φ :=\n  @IsStronglyCocartesian.of_iso _ _ _ _ p _ _ _ _ f (asIso φ) (by aesop)\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCocartesian.isIso_of_base_isIso","module":"Mathlib.CategoryTheory.FiberedCategory.Cocartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsStronglyCocartesian f φ\ninst✝ : CategoryTheory.IsIso f\n⊢ CategoryTheory.IsIso φ","decl":"/-- A strongly cocartesian arrow lying over an isomorphism is an isomorphism. -/\nlemma isIso_of_base_isIso (φ : a ⟶ b) [IsStronglyCocartesian p f φ] [IsIso f] : IsIso φ := by\n  subst_hom_lift p f φ; clear a b R S\n  -- Let `φ'` be the morphism induced by applying universal property to `𝟙 a` lying over `f ≫ f⁻¹`.\n  let φ' := map p (p.map φ) φ (IsIso.hom_inv_id (p.map φ)).symm (𝟙 a)\n  use φ'\n  -- `φ ≫ φ' = 𝟙 a` follows immediately from the universal property.\n  have inv_hom : φ ≫ φ' = 𝟙 a := fac p (p.map φ) φ _ (𝟙 a)\n  refine ⟨inv_hom, ?_⟩\n  -- We will now show that `φ' ≫ φ = 𝟙 b` by showing that `φ ≫ (φ' ≫ φ) = φ ≫ 𝟙 b`.\n  have h₁ : IsHomLift p (𝟙 (p.obj b)) (φ' ≫ φ) := by\n    rw [← IsIso.inv_hom_id (p.map φ)]\n    apply IsHomLift.comp\n  apply IsStronglyCocartesian.ext p (p.map φ) φ (𝟙 (p.obj b))\n  simp only [← assoc, inv_hom, comp_id, id_comp]\n\n"}
