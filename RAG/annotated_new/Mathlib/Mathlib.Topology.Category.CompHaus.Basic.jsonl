{"name":"CompHaus.instCompactSpaceαTopologicalSpaceToTopTrue","module":"Mathlib.Topology.Category.CompHaus.Basic","initialProofState":"X : CompHaus\n⊢ CompactSpace ↑X.toTop","decl":"instance {X : CompHaus} : CompactSpace X :=\n  X.is_compact\n\n"}
{"name":"CompHaus.instT2SpaceαTopologicalSpaceToTopTrue","module":"Mathlib.Topology.Category.CompHaus.Basic","initialProofState":"X : CompHaus\n⊢ T2Space ↑X.toTop","decl":"instance {X : CompHaus} : T2Space X :=\n  X.is_hausdorff\n\n"}
{"name":"CompHaus.instHasPropTrue","module":"Mathlib.Topology.Category.CompHaus.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ CompHausLike.HasProp (fun x => True) X","decl":"instance : HasProp (fun _ ↦ True) X := ⟨trivial⟩\n\n"}
{"name":"stoneCechObj_toTop_str_IsOpen","module":"Mathlib.Topology.Category.CompHaus.Basic","initialProofState":"X : TopCat\ns : Set (Quotient (t2Setoid (PreStoneCech ↑X)))\n⊢ Eq (TopologicalSpace.IsOpen s) (IsOpen (Set.preimage Quotient.mk' s))","decl":"/-- (Implementation) The object part of the compactification functor from topological spaces to\ncompact Hausdorff spaces.\n-/\n@[simps!]\ndef stoneCechObj (X : TopCat) : CompHaus :=\n  CompHaus.of (StoneCech X)\n\n"}
{"name":"stoneCechObj_toTop_α","module":"Mathlib.Topology.Category.CompHaus.Basic","initialProofState":"X : TopCat\n⊢ Eq (↑(stoneCechObj X).toTop) (StoneCech ↑X)","decl":"/-- (Implementation) The object part of the compactification functor from topological spaces to\ncompact Hausdorff spaces.\n-/\n@[simps!]\ndef stoneCechObj (X : TopCat) : CompHaus :=\n  CompHaus.of (StoneCech X)\n\n"}
{"name":"topToCompHaus_obj","module":"Mathlib.Topology.Category.CompHaus.Basic","initialProofState":"X : TopCat\n⊢ Eq (↑(topToCompHaus.obj X).toTop) (StoneCech ↑X)","decl":"theorem topToCompHaus_obj (X : TopCat) : ↥(topToCompHaus.obj X) = StoneCech X :=\n  rfl\n\n"}
{"name":"CompHaus.hasLimits","module":"Mathlib.Topology.Category.CompHaus.Basic","initialProofState":"⊢ CategoryTheory.Limits.HasLimits CompHaus","decl":"instance CompHaus.hasLimits : Limits.HasLimits CompHaus :=\n  hasLimits_of_hasLimits_createsLimits compHausToTop\n\n"}
{"name":"CompHaus.hasColimits","module":"Mathlib.Topology.Category.CompHaus.Basic","initialProofState":"⊢ CategoryTheory.Limits.HasColimits CompHaus","decl":"instance CompHaus.hasColimits : Limits.HasColimits CompHaus :=\n  hasColimits_of_reflective compHausToTop\n\n"}
{"name":"CompHaus.epi_iff_surjective","module":"Mathlib.Topology.Category.CompHaus.Basic","initialProofState":"X Y : CompHaus\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.Epi f) (Function.Surjective ⇑f)","decl":"theorem epi_iff_surjective {X Y : CompHaus.{u}} (f : X ⟶ Y) : Epi f ↔ Function.Surjective f := by\n  constructor\n  · dsimp [Function.Surjective]\n    contrapose!\n    rintro ⟨y, hy⟩ hf\n    let C := Set.range f\n    have hC : IsClosed C := (isCompact_range f.continuous).isClosed\n    let D := ({y} : Set Y)\n    have hD : IsClosed D := isClosed_singleton\n    have hCD : Disjoint C D := by\n      rw [Set.disjoint_singleton_right]\n      rintro ⟨y', hy'⟩\n      exact hy y' hy'\n    obtain ⟨φ, hφ0, hφ1, hφ01⟩ := exists_continuous_zero_one_of_isClosed hC hD hCD\n    haveI : CompactSpace (ULift.{u} <| Set.Icc (0 : ℝ) 1) := Homeomorph.ulift.symm.compactSpace\n    haveI : T2Space (ULift.{u} <| Set.Icc (0 : ℝ) 1) := Homeomorph.ulift.symm.t2Space\n    let Z := of (ULift.{u} <| Set.Icc (0 : ℝ) 1)\n    let g : Y ⟶ Z :=\n      ⟨fun y' => ⟨⟨φ y', hφ01 y'⟩⟩,\n        continuous_uLift_up.comp (φ.continuous.subtype_mk fun y' => hφ01 y')⟩\n    let h : Y ⟶ Z := ⟨fun _ => ⟨⟨0, Set.left_mem_Icc.mpr zero_le_one⟩⟩, continuous_const⟩\n    have H : h = g := by\n      rw [← cancel_epi f]\n      ext x\n      -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` doesn't apply these two lemmas.\n      apply ULift.ext\n      apply Subtype.ext\n      dsimp\n      -- Porting note: This `change` is not ideal.\n      -- I think lean is having issues understanding when a `ContinuousMap` should be considered\n      -- as a morphism.\n      -- TODO(?): Make morphisms in `CompHaus` (and other topological categories)\n      -- into a one-field-structure.\n      change 0 = φ (f x)\n      simp only [hφ0 (Set.mem_range_self x), Pi.zero_apply]\n    apply_fun fun e => (e y).down.1 at H\n    dsimp [Z] at H\n    change 0 = φ y at H\n    simp only [hφ1 (Set.mem_singleton y), Pi.one_apply] at H\n    exact zero_ne_one H\n  · rw [← CategoryTheory.epi_iff_surjective]\n    apply (forget CompHaus).epi_of_epi_map\n\n"}
