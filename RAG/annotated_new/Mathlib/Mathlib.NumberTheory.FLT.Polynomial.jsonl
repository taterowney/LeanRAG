{"name":"Polynomial.flt_catalan","module":"Mathlib.NumberTheory.FLT.Polynomial","initialProofState":"k : Type u_1\ninst✝¹ : Field k\ninst✝ : DecidableEq k\np q r : Nat\nhp : LT.lt 0 p\nhq : LT.lt 0 q\nhr : LT.lt 0 r\nhineq : LE.le (HAdd.hAdd (HAdd.hAdd (HMul.hMul q r) (HMul.hMul r p)) (HMul.hMul p q)) (HMul.hMul (HMul.hMul p q) r)\nchp : Ne (↑p) 0\nchq : Ne (↑q) 0\nchr : Ne (↑r) 0\na b c : Polynomial k\nha : Ne a 0\nhb : Ne b 0\nhc : Ne c 0\nhab : IsCoprime a b\nu v w : k\nhu : Ne u 0\nhv : Ne v 0\nhw : Ne w 0\nheq : Eq (HAdd.hAdd (HAdd.hAdd (HMul.hMul (Polynomial.C u) (HPow.hPow a p)) (HMul.hMul (Polynomial.C v) (HPow.hPow b q))) (HMul.hMul (Polynomial.C w) (HPow.hPow c r))) 0\n⊢ And (Eq a.natDegree 0) (And (Eq b.natDegree 0) (Eq c.natDegree 0))","decl":"/-- Nonsolvability of the Fermat-Catalan equation. -/\ntheorem Polynomial.flt_catalan\n    {p q r : ℕ} (hp : 0 < p) (hq : 0 < q) (hr : 0 < r)\n    (hineq : q * r + r * p + p * q ≤ p * q * r)\n    (chp : (p : k) ≠ 0) (chq : (q : k) ≠ 0) (chr : (r : k) ≠ 0)\n    {a b c : k[X]} (ha : a ≠ 0) (hb : b ≠ 0) (hc : c ≠ 0) (hab : IsCoprime a b)\n    {u v w : k} (hu : u ≠ 0) (hv : v ≠ 0) (hw : w ≠ 0)\n    (heq : C u * a ^ p + C v * b ^ q + C w * c ^ r = 0) :\n    a.natDegree = 0 ∧ b.natDegree = 0 ∧ c.natDegree = 0 := by\n  -- WLOG argument: essentially three times flt_catalan_aux\n  have hbc : IsCoprime b c := by\n    apply rot_coprime heq hab <;> assumption\n  have heq' : C v * b ^ q + C w * c ^ r + C u * a ^ p = 0 := by\n    rwa [add_rotate] at heq\n  have hca : IsCoprime c a := by\n    apply rot_coprime heq' hbc <;> assumption\n  refine ⟨?_, ?_, ?_⟩\n  · apply flt_catalan_aux heq <;> assumption\n  · rw [add_rotate] at heq hineq\n    rw [mul_rotate] at hineq\n    apply flt_catalan_aux heq <;> assumption\n  · rw [← add_rotate] at heq hineq\n    rw [← mul_rotate] at hineq\n    apply flt_catalan_aux heq <;> assumption\n\n"}
{"name":"Polynomial.flt","module":"Mathlib.NumberTheory.FLT.Polynomial","initialProofState":"k : Type u_1\ninst✝¹ : Field k\ninst✝ : DecidableEq k\nn : Nat\nhn : LE.le 3 n\nchn : Ne (↑n) 0\na b c : Polynomial k\nha : Ne a 0\nhb : Ne b 0\nhc : Ne c 0\nhab : IsCoprime a b\nheq : Eq (HAdd.hAdd (HPow.hPow a n) (HPow.hPow b n)) (HPow.hPow c n)\n⊢ And (Eq a.natDegree 0) (And (Eq b.natDegree 0) (Eq c.natDegree 0))","decl":"theorem Polynomial.flt\n    {n : ℕ} (hn : 3 ≤ n) (chn : (n : k) ≠ 0)\n    {a b c : k[X]} (ha : a ≠ 0) (hb : b ≠ 0) (hc : c ≠ 0)\n    (hab : IsCoprime a b) (heq : a ^ n + b ^ n = c ^ n) :\n    a.natDegree = 0 ∧ b.natDegree = 0 ∧ c.natDegree = 0 := by\n  have hn' : 0 < n := by linarith\n  rw [← sub_eq_zero, ← one_mul (a ^ n), ← one_mul (b ^ n), ← one_mul (c ^ n), sub_eq_add_neg,\n    ← neg_mul] at heq\n  have hone : (1 : k[X]) = C 1 := by rfl\n  have hneg_one : (-1 : k[X]) = C (-1) := by simp only [map_neg, map_one]\n  simp_rw [hneg_one, hone] at heq\n  apply flt_catalan hn' hn' hn' _\n    chn chn chn ha hb hc hab one_ne_zero one_ne_zero (neg_ne_zero.mpr one_ne_zero) heq\n  have eq_lhs : n * n + n * n + n * n = 3 * n * n := by ring\n  rw [eq_lhs, mul_assoc, mul_assoc]\n  exact Nat.mul_le_mul_right (n * n) hn\n\n"}
{"name":"fermatLastTheoremWith'_polynomial","module":"Mathlib.NumberTheory.FLT.Polynomial","initialProofState":"k : Type u_1\ninst✝¹ : Field k\ninst✝ : DecidableEq k\nn : Nat\nhn : LE.le 3 n\nchn : Ne (↑n) 0\n⊢ FermatLastTheoremWith' (Polynomial k) n","decl":"theorem fermatLastTheoremWith'_polynomial {n : ℕ} (hn : 3 ≤ n) (chn : (n : k) ≠ 0) :\n    FermatLastTheoremWith' k[X] n := by\n  rw [FermatLastTheoremWith']\n  intros a b c ha hb hc heq\n  obtain ⟨a', eq_a⟩ := gcd_dvd_left a b\n  obtain ⟨b', eq_b⟩ := gcd_dvd_right a b\n  set d := gcd a b\n  have hd : d ≠ 0 := gcd_ne_zero_of_left ha\n  rw [eq_a, eq_b, mul_pow, mul_pow, ← mul_add] at heq\n  have hdc : d ∣ c := by\n    have hn : 0 < n := by omega\n    have hdncn : d ^ n ∣ c ^ n := ⟨_, heq.symm⟩\n\n    rw [dvd_iff_normalizedFactors_le_normalizedFactors hd hc]\n    rw [dvd_iff_normalizedFactors_le_normalizedFactors\n          (pow_ne_zero n hd) (pow_ne_zero n hc),\n        normalizedFactors_pow, normalizedFactors_pow] at hdncn\n    simp_rw [Multiset.le_iff_count, Multiset.count_nsmul,\n      mul_le_mul_left hn] at hdncn ⊢\n    exact hdncn\n  obtain ⟨c', eq_c⟩ := hdc\n  rw [eq_a, mul_ne_zero_iff] at ha\n  rw [eq_b, mul_ne_zero_iff] at hb\n  rw [eq_c, mul_ne_zero_iff] at hc\n  rw [mul_comm] at eq_a eq_b eq_c\n  refine ⟨d, a', b', c', ⟨eq_a, eq_b, eq_c⟩, ?_⟩\n  rw [eq_c, mul_pow, mul_comm, mul_left_inj' (pow_ne_zero n hd)] at heq\n  suffices goal : a'.natDegree = 0 ∧ b'.natDegree = 0 ∧ c'.natDegree = 0 by\n    simp [natDegree_eq_zero] at goal\n    obtain ⟨⟨ca', ha'⟩, ⟨cb', hb'⟩, ⟨cc', hc'⟩⟩ := goal\n    rw [← ha', ← hb', ← hc']\n    rw [← ha', C_ne_zero] at ha\n    rw [← hb', C_ne_zero] at hb\n    rw [← hc', C_ne_zero] at hc\n    exact ⟨ha.right.isUnit_C, hb.right.isUnit_C, hc.right.isUnit_C⟩\n  apply flt hn chn ha.right hb.right hc.right _ heq\n  convert isCoprime_div_gcd_div_gcd _\n  · exact EuclideanDomain.eq_div_of_mul_eq_left ha.left eq_a.symm\n  · exact EuclideanDomain.eq_div_of_mul_eq_left ha.left eq_b.symm\n  · rw [eq_b]\n    exact mul_ne_zero hb.right hb.left\n"}
