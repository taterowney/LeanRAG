{"name":"Sigma.lex_iff","module":"Mathlib.Data.Sigma.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\na b : Sigma fun i => α i\n⊢ Iff (Sigma.Lex r s a b) (Or (r a.fst b.fst) (Exists fun h => s b.fst (Eq.rec a.snd h) b.snd))","decl":"theorem lex_iff : Lex r s a b ↔ r a.1 b.1 ∨ ∃ h : a.1 = b.1, s b.1 (h.rec a.2) b.2 := by\n  constructor\n  · rintro (⟨a, b, hij⟩ | ⟨a, b, hab⟩)\n    · exact Or.inl hij\n    · exact Or.inr ⟨rfl, hab⟩\n  · obtain ⟨i, a⟩ := a\n    obtain ⟨j, b⟩ := b\n    dsimp only\n    rintro (h | ⟨rfl, h⟩)\n    · exact Lex.left _ _ h\n    · exact Lex.right _ _ h\n\n"}
{"name":"Sigma.Lex.mono","module":"Mathlib.Data.Sigma.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nr₁ r₂ : ι → ι → Prop\ns₁ s₂ : (i : ι) → α i → α i → Prop\nhr : ∀ (a b : ι), r₁ a b → r₂ a b\nhs : ∀ (i : ι) (a b : α i), s₁ i a b → s₂ i a b\na b : Sigma fun i => α i\nh : Sigma.Lex r₁ s₁ a b\n⊢ Sigma.Lex r₂ s₂ a b","decl":"theorem Lex.mono (hr : ∀ a b, r₁ a b → r₂ a b) (hs : ∀ i a b, s₁ i a b → s₂ i a b) {a b : Σ i, α i}\n    (h : Lex r₁ s₁ a b) : Lex r₂ s₂ a b := by\n  obtain ⟨a, b, hij⟩ | ⟨a, b, hab⟩ := h\n  · exact Lex.left _ _ (hr _ _ hij)\n  · exact Lex.right _ _ (hs _ _ _ hab)\n\n"}
{"name":"Sigma.Lex.mono_left","module":"Mathlib.Data.Sigma.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nr₁ r₂ : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\nhr : ∀ (a b : ι), r₁ a b → r₂ a b\na b : Sigma fun i => α i\nh : Sigma.Lex r₁ s a b\n⊢ Sigma.Lex r₂ s a b","decl":"theorem Lex.mono_left (hr : ∀ a b, r₁ a b → r₂ a b) {a b : Σ i, α i} (h : Lex r₁ s a b) :\n    Lex r₂ s a b :=\n  h.mono hr fun _ _ _ => id\n\n"}
{"name":"Sigma.Lex.mono_right","module":"Mathlib.Data.Sigma.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nr : ι → ι → Prop\ns₁ s₂ : (i : ι) → α i → α i → Prop\nhs : ∀ (i : ι) (a b : α i), s₁ i a b → s₂ i a b\na b : Sigma fun i => α i\nh : Sigma.Lex r s₁ a b\n⊢ Sigma.Lex r s₂ a b","decl":"theorem Lex.mono_right (hs : ∀ i a b, s₁ i a b → s₂ i a b) {a b : Σ i, α i} (h : Lex r s₁ a b) :\n    Lex r s₂ a b :=\n  h.mono (fun _ _ => id) hs\n\n"}
{"name":"Sigma.lex_swap","module":"Mathlib.Data.Sigma.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\na b : Sigma fun i => α i\n⊢ Iff (Sigma.Lex (Function.swap r) s a b) (Sigma.Lex r (fun i => Function.swap (s i)) b a)","decl":"theorem lex_swap : Lex (Function.swap r) s a b ↔ Lex r (fun i => Function.swap (s i)) b a := by\n  constructor <;>\n    · rintro (⟨a, b, h⟩ | ⟨a, b, h⟩)\n      exacts [Lex.left _ _ h, Lex.right _ _ h]\n\n"}
{"name":"Sigma.instIsReflLex","module":"Mathlib.Data.Sigma.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\ninst✝ : ∀ (i : ι), IsRefl (α i) (s i)\n⊢ IsRefl (Sigma fun i => α i) (Sigma.Lex r s)","decl":"instance [∀ i, IsRefl (α i) (s i)] : IsRefl _ (Lex r s) :=\n  ⟨fun ⟨_, _⟩ => Lex.right _ _ <| refl _⟩\n\n"}
{"name":"Sigma.instIsIrreflLex","module":"Mathlib.Data.Sigma.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\ninst✝¹ : IsIrrefl ι r\ninst✝ : ∀ (i : ι), IsIrrefl (α i) (s i)\n⊢ IsIrrefl (Sigma fun i => α i) (Sigma.Lex r s)","decl":"instance [IsIrrefl ι r] [∀ i, IsIrrefl (α i) (s i)] : IsIrrefl _ (Lex r s) :=\n  ⟨by\n    rintro _ (⟨a, b, hi⟩ | ⟨a, b, ha⟩)\n    · exact irrefl _ hi\n    · exact irrefl _ ha\n      ⟩\n\n"}
{"name":"Sigma.instIsTransLex","module":"Mathlib.Data.Sigma.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\ninst✝¹ : IsTrans ι r\ninst✝ : ∀ (i : ι), IsTrans (α i) (s i)\n⊢ IsTrans (Sigma fun i => α i) (Sigma.Lex r s)","decl":"instance [IsTrans ι r] [∀ i, IsTrans (α i) (s i)] : IsTrans _ (Lex r s) :=\n  ⟨by\n    rintro _ _ _ (⟨a, b, hij⟩ | ⟨a, b, hab⟩) (⟨_, c, hk⟩ | ⟨_, c, hc⟩)\n    · exact Lex.left _ _ (_root_.trans hij hk)\n    · exact Lex.left _ _ hij\n    · exact Lex.left _ _ hk\n    · exact Lex.right _ _ (_root_.trans hab hc)⟩\n\n"}
{"name":"Sigma.instIsSymmLex","module":"Mathlib.Data.Sigma.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\ninst✝¹ : IsSymm ι r\ninst✝ : ∀ (i : ι), IsSymm (α i) (s i)\n⊢ IsSymm (Sigma fun i => α i) (Sigma.Lex r s)","decl":"instance [IsSymm ι r] [∀ i, IsSymm (α i) (s i)] : IsSymm _ (Lex r s) :=\n  ⟨by\n    rintro _ _ (⟨a, b, hij⟩ | ⟨a, b, hab⟩)\n    · exact Lex.left _ _ (symm hij)\n    · exact Lex.right _ _ (symm hab)\n      ⟩\n\n"}
{"name":"Sigma.instIsAntisymmLexOfIsAsymm","module":"Mathlib.Data.Sigma.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\ninst✝¹ : IsAsymm ι r\ninst✝ : ∀ (i : ι), IsAntisymm (α i) (s i)\n⊢ IsAntisymm (Sigma fun i => α i) (Sigma.Lex r s)","decl":"instance [IsAsymm ι r] [∀ i, IsAntisymm (α i) (s i)] : IsAntisymm _ (Lex r s) :=\n  ⟨by\n    rintro _ _ (⟨a, b, hij⟩ | ⟨a, b, hab⟩) (⟨_, _, hji⟩ | ⟨_, _, hba⟩)\n    · exact (asymm hij hji).elim\n    · exact (irrefl _ hij).elim\n    · exact (irrefl _ hji).elim\n    · exact congr_arg (Sigma.mk _ ·) <| antisymm hab hba⟩\n\n"}
{"name":"Sigma.instIsTotalLexOfIsTrichotomous","module":"Mathlib.Data.Sigma.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\ninst✝¹ : IsTrichotomous ι r\ninst✝ : ∀ (i : ι), IsTotal (α i) (s i)\n⊢ IsTotal (Sigma fun i => α i) (Sigma.Lex r s)","decl":"instance [IsTrichotomous ι r] [∀ i, IsTotal (α i) (s i)] : IsTotal _ (Lex r s) :=\n  ⟨by\n    rintro ⟨i, a⟩ ⟨j, b⟩\n    obtain hij | rfl | hji := trichotomous_of r i j\n    · exact Or.inl (Lex.left _ _ hij)\n    · obtain hab | hba := total_of (s i) a b\n      · exact Or.inl (Lex.right _ _ hab)\n      · exact Or.inr (Lex.right _ _ hba)\n    · exact Or.inr (Lex.left _ _ hji)⟩\n\n"}
{"name":"Sigma.instIsTrichotomousLex","module":"Mathlib.Data.Sigma.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\ninst✝¹ : IsTrichotomous ι r\ninst✝ : ∀ (i : ι), IsTrichotomous (α i) (s i)\n⊢ IsTrichotomous (Sigma fun i => α i) (Sigma.Lex r s)","decl":"instance [IsTrichotomous ι r] [∀ i, IsTrichotomous (α i) (s i)] : IsTrichotomous _ (Lex r s) :=\n  ⟨by\n    rintro ⟨i, a⟩ ⟨j, b⟩\n    obtain hij | rfl | hji := trichotomous_of r i j\n    · exact Or.inl (Lex.left _ _ hij)\n    · obtain hab | rfl | hba := trichotomous_of (s i) a b\n      · exact Or.inl (Lex.right _ _ hab)\n      · exact Or.inr (Or.inl rfl)\n      · exact Or.inr (Or.inr <| Lex.right _ _ hba)\n    · exact Or.inr (Or.inr <| Lex.left _ _ hji)⟩\n\n"}
{"name":"PSigma.lex_iff","module":"Mathlib.Data.Sigma.Lex","initialProofState":"ι : Sort u_1\nα : ι → Sort u_2\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\na b : PSigma fun i => α i\n⊢ Iff (PSigma.Lex r s a b) (Or (r a.fst b.fst) (Exists fun h => s b.fst (Eq.rec a.snd h) b.snd))","decl":"theorem lex_iff {a b : Σ' i, α i} :\n    Lex r s a b ↔ r a.1 b.1 ∨ ∃ h : a.1 = b.1, s b.1 (h.rec a.2) b.2 := by\n  constructor\n  · rintro (⟨a, b, hij⟩ | ⟨i, hab⟩)\n    · exact Or.inl hij\n    · exact Or.inr ⟨rfl, hab⟩\n  · obtain ⟨i, a⟩ := a\n    obtain ⟨j, b⟩ := b\n    dsimp only\n    rintro (h | ⟨rfl, h⟩)\n    · exact Lex.left _ _ h\n    · exact Lex.right _ h\n\n"}
{"name":"PSigma.Lex.mono","module":"Mathlib.Data.Sigma.Lex","initialProofState":"ι : Sort u_1\nα : ι → Sort u_2\nr₁ r₂ : ι → ι → Prop\ns₁ s₂ : (i : ι) → α i → α i → Prop\nhr : ∀ (a b : ι), r₁ a b → r₂ a b\nhs : ∀ (i : ι) (a b : α i), s₁ i a b → s₂ i a b\na b : PSigma fun i => α i\nh : PSigma.Lex r₁ s₁ a b\n⊢ PSigma.Lex r₂ s₂ a b","decl":"theorem Lex.mono {r₁ r₂ : ι → ι → Prop} {s₁ s₂ : ∀ i, α i → α i → Prop}\n    (hr : ∀ a b, r₁ a b → r₂ a b) (hs : ∀ i a b, s₁ i a b → s₂ i a b) {a b : Σ' i, α i}\n    (h : Lex r₁ s₁ a b) : Lex r₂ s₂ a b := by\n  obtain ⟨a, b, hij⟩ | ⟨i, hab⟩ := h\n  · exact Lex.left _ _ (hr _ _ hij)\n  · exact Lex.right _ (hs _ _ _ hab)\n\n"}
{"name":"PSigma.Lex.mono_left","module":"Mathlib.Data.Sigma.Lex","initialProofState":"ι : Sort u_1\nα : ι → Sort u_2\nr₁ r₂ : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\nhr : ∀ (a b : ι), r₁ a b → r₂ a b\na b : PSigma fun i => α i\nh : PSigma.Lex r₁ s a b\n⊢ PSigma.Lex r₂ s a b","decl":"theorem Lex.mono_left {r₁ r₂ : ι → ι → Prop} {s : ∀ i, α i → α i → Prop}\n    (hr : ∀ a b, r₁ a b → r₂ a b) {a b : Σ' i, α i} (h : Lex r₁ s a b) : Lex r₂ s a b :=\n  h.mono hr fun _ _ _ => id\n\n"}
{"name":"PSigma.Lex.mono_right","module":"Mathlib.Data.Sigma.Lex","initialProofState":"ι : Sort u_1\nα : ι → Sort u_2\nr : ι → ι → Prop\ns₁ s₂ : (i : ι) → α i → α i → Prop\nhs : ∀ (i : ι) (a b : α i), s₁ i a b → s₂ i a b\na b : PSigma fun i => α i\nh : PSigma.Lex r s₁ a b\n⊢ PSigma.Lex r s₂ a b","decl":"theorem Lex.mono_right {r : ι → ι → Prop} {s₁ s₂ : ∀ i, α i → α i → Prop}\n    (hs : ∀ i a b, s₁ i a b → s₂ i a b) {a b : Σ' i, α i} (h : Lex r s₁ a b) : Lex r s₂ a b :=\n  h.mono (fun _ _ => id) hs\n\n"}
