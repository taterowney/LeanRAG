{"name":"Matrix.finite_real_spectrum","module":"Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus","initialProofState":"n : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nâŠ¢ (spectrum Real A).Finite","decl":"lemma finite_real_spectrum : (spectrum â„ A).Finite := by\n  rw [â† spectrum.preimage_algebraMap ğ•œ]\n  exact A.finite_spectrum.preimage (NoZeroSMulDivisors.algebraMap_injective â„ ğ•œ).injOn\n\n"}
{"name":"Matrix.instFiniteElemRealSpectrum","module":"Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus","initialProofState":"n : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nâŠ¢ Finite â†‘(spectrum Real A)","decl":"instance : Finite (spectrum â„ A) := A.finite_real_spectrum\n\n"}
{"name":"Matrix.IsHermitian.eigenvalues_eq_spectrum_real","module":"Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus","initialProofState":"n : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\na : Matrix n n ğ•œ\nha : a.IsHermitian\nâŠ¢ Eq (spectrum Real a) (Set.range ha.eigenvalues)","decl":"/-- The `â„`-spectrum of a Hermitian matrix over `RCLike` field is the range of the eigenvalue\nfunction -/\ntheorem eigenvalues_eq_spectrum_real {a : Matrix n n ğ•œ} (ha : IsHermitian a) :\n    spectrum â„ a = Set.range (ha.eigenvalues) := by\n  ext x\n  conv_lhs => rw [ha.spectral_theorem, unitary.spectrum.unitary_conjugate,\n  â† spectrum.algebraMap_mem_iff ğ•œ, spectrum_diagonal, RCLike.algebraMap_eq_ofReal]\n  simp\n\n"}
{"name":"Matrix.IsHermitian.cfcAux_apply","module":"Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus","initialProofState":"n : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nhA : A.IsHermitian\ng : ContinuousMap (â†‘(spectrum Real A)) Real\nâŠ¢ Eq (hA.cfcAux g) (HMul.hMul (HMul.hMul (â†‘hA.eigenvectorUnitary) (Matrix.diagonal (Function.comp RCLike.ofReal (Function.comp â‡‘g fun i => âŸ¨hA.eigenvalues i, â‹¯âŸ©)))) (Star.star â†‘hA.eigenvectorUnitary))","decl":"/-- The star algebra homomorphism underlying the instance of the continuous functional\ncalculus of a Hermitian matrix. This is an auxiliary definition and is not intended\nfor use outside of this file. -/\n@[simps]\nnoncomputable def cfcAux : C(spectrum â„ A, â„) â†’â‹†â‚[â„] (Matrix n n ğ•œ) where\n  toFun := fun g => (eigenvectorUnitary hA : Matrix n n ğ•œ) *\n    diagonal (RCLike.ofReal âˆ˜ g âˆ˜ (fun i â†¦ âŸ¨hA.eigenvalues i, hA.eigenvalues_mem_spectrum_real iâŸ©))\n    * star (eigenvectorUnitary hA : Matrix n n ğ•œ)\n  map_one' := by simp [Pi.one_def (f := fun _ : n â†¦ ğ•œ)]\n  map_mul' f g := by\n    have {a b c d e f : Matrix n n ğ•œ} : (a * b * c) * (d * e * f) = a * (b * (c * d) * e) * f := by\n      simp only [mul_assoc]\n    simp only [this, ContinuousMap.coe_mul, SetLike.coe_mem, unitary.star_mul_self_of_mem, mul_one,\n      diagonal_mul_diagonal, Function.comp_apply]\n    congr! with i\n    simp\n  map_zero' := by simp [Pi.zero_def (f := fun _ : n â†¦ ğ•œ)]\n  map_add' f g := by\n    simp only [ContinuousMap.coe_add, â† add_mul, â† mul_add, diagonal_add, Function.comp_apply]\n    congr! with i\n    simp\n  commutes' r := by\n    simp only [Function.comp_def, algebraMap_apply, smul_eq_mul, mul_one]\n    rw [â† mul_one (algebraMap _ _ _), â† unitary.coe_mul_star_self hA.eigenvectorUnitary,\n      â† Algebra.left_comm, unitary.coe_star, mul_assoc]\n    congr!\n  map_star' f := by\n    simp only [star_trivial, StarMul.star_mul, star_star, star_eq_conjTranspose (diagonal _),\n      diagonal_conjTranspose, mul_assoc]\n    congr!\n    ext\n    simp\n\n"}
{"name":"Matrix.IsHermitian.isClosedEmbedding_cfcAux","module":"Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus","initialProofState":"n : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nhA : A.IsHermitian\nâŠ¢ Topology.IsClosedEmbedding â‡‘hA.cfcAux","decl":"lemma isClosedEmbedding_cfcAux : IsClosedEmbedding hA.cfcAux := by\n  have h0 : FiniteDimensional â„ C(spectrum â„ A, â„) :=\n    FiniteDimensional.of_injective (ContinuousMap.coeFnLinearMap â„ (M := â„)) DFunLike.coe_injective\n  refine LinearMap.isClosedEmbedding_of_injective (ğ•œ := â„) (E := C(spectrum â„ A, â„))\n    (F := Matrix n n ğ•œ) (f := hA.cfcAux) <| LinearMap.ker_eq_bot'.mpr fun f hf â†¦ ?_\n  have h2 :\n      diagonal (RCLike.ofReal âˆ˜ f âˆ˜ fun i â†¦ âŸ¨hA.eigenvalues i, hA.eigenvalues_mem_spectrum_real iâŸ©)\n        = (0 : Matrix n n ğ•œ) := by\n    simp only [LinearMap.coe_coe, cfcAux_apply] at hf\n    replace hf := congr($(hf) * (eigenvectorUnitary hA : Matrix n n ğ•œ))\n    simp only [mul_assoc, SetLike.coe_mem, unitary.star_mul_self_of_mem, mul_one, zero_mul] at hf\n    simpa [â† mul_assoc] using congr((star hA.eigenvectorUnitary : Matrix n n ğ•œ) * $(hf))\n  ext x\n  simp only [ContinuousMap.zero_apply]\n  obtain âŸ¨x, hxâŸ© := x\n  obtain âŸ¨i, rflâŸ© := hA.eigenvalues_eq_spectrum_real â–¸ hx\n  rw [â† diagonal_zero] at h2\n  have := (diagonal_eq_diagonal_iff).mp h2\n  refine RCLike.ofReal_eq_zero.mp (this i)\n\n"}
{"name":"Matrix.IsHermitian.closedEmbedding_cfcAux","module":"Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus","initialProofState":"n : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nhA : A.IsHermitian\nâŠ¢ Topology.IsClosedEmbedding â‡‘hA.cfcAux","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_cfcAux := isClosedEmbedding_cfcAux\n\n"}
{"name":"Matrix.IsHermitian.cfcAux_id","module":"Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus","initialProofState":"n : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nhA : A.IsHermitian\nâŠ¢ Eq (hA.cfcAux (ContinuousMap.restrict (spectrum Real A) (ContinuousMap.id Real))) A","decl":"lemma cfcAux_id : hA.cfcAux (.restrict (spectrum â„ A) (.id â„)) = A := by\n  conv_rhs => rw [hA.spectral_theorem]\n  congr!\n\n"}
{"name":"Matrix.IsHermitian.instContinuousFunctionalCalculus","module":"Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus","initialProofState":"n : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nâŠ¢ ContinuousFunctionalCalculus Real IsSelfAdjoint","decl":"/-- Instance of the continuous functional calculus for a Hermitian matrix over `ğ•œ` with\n`RCLike ğ•œ`. -/\ninstance instContinuousFunctionalCalculus :\n    ContinuousFunctionalCalculus â„ (IsSelfAdjoint : Matrix n n ğ•œ â†’ Prop) where\n  exists_cfc_of_predicate a ha := by\n    replace ha : IsHermitian a := ha\n    refine âŸ¨ha.cfcAux, ha.isClosedEmbedding_cfcAux, ha.cfcAux_id, fun f â†¦ ?map_spec,\n      fun f â†¦ ?hermitianâŸ©\n    case map_spec =>\n      apply Set.eq_of_subset_of_subset\n      Â· rw [â† ContinuousMap.spectrum_eq_range f]\n        apply AlgHom.spectrum_apply_subset\n      Â· rw [cfcAux_apply, unitary.spectrum.unitary_conjugate]\n        rintro - âŸ¨x , rflâŸ©\n        apply spectrum.of_algebraMap_mem ğ•œ\n        simp only [Function.comp_apply, Set.mem_range, spectrum_diagonal]\n        obtain âŸ¨x, hxâŸ© := x\n        obtain âŸ¨i, rflâŸ© := ha.eigenvalues_eq_spectrum_real â–¸ hx\n        exact âŸ¨i, rflâŸ©\n    case hermitian =>\n      simp only [isSelfAdjoint_iff, cfcAux_apply, mul_assoc, star_mul, star_star]\n      rw [star_eq_conjTranspose, diagonal_conjTranspose]\n      congr!\n      simp [Pi.star_def, Function.comp_def]\n  spectrum_nonempty a ha := by\n    obtain (h | h) := isEmpty_or_nonempty n\n    Â· obtain âŸ¨x, y, hxyâŸ© := exists_pair_ne (Matrix n n ğ•œ)\n      exact False.elim <| Matrix.of.symm.injective.ne hxy <| Subsingleton.elim _ _\n    Â· exact eigenvalues_eq_spectrum_real ha â–¸ Set.range_nonempty _\n  predicate_zero := .zero _\n\n"}
{"name":"Matrix.IsHermitian.cfc_eq","module":"Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus","initialProofState":"n : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nhA : A.IsHermitian\nf : Real â†’ Real\nâŠ¢ Eq (cfc f A) (hA.cfc f)","decl":"lemma cfc_eq (f : â„ â†’ â„) : cfc f A = hA.cfc f := by\n  have hA' : IsSelfAdjoint A := hA\n  have := cfcHom_eq_of_continuous_of_map_id hA' hA.cfcAux hA.isClosedEmbedding_cfcAux.continuous\n    hA.cfcAux_id\n  rw [cfc_apply f A hA' (by rw [continuousOn_iff_continuous_restrict]; fun_prop), this]\n  simp only [cfcAux_apply, ContinuousMap.coe_mk, Function.comp_def, Set.restrict_apply,\n    IsHermitian.cfc]\n\n"}
