{"name":"Matrix.finite_real_spectrum","module":"Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus","initialProofState":"n : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n 𝕜\n⊢ (spectrum Real A).Finite","decl":"lemma finite_real_spectrum : (spectrum ℝ A).Finite := by\n  rw [← spectrum.preimage_algebraMap 𝕜]\n  exact A.finite_spectrum.preimage (NoZeroSMulDivisors.algebraMap_injective ℝ 𝕜).injOn\n\n"}
{"name":"Matrix.instFiniteElemRealSpectrum","module":"Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus","initialProofState":"n : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n 𝕜\n⊢ Finite ↑(spectrum Real A)","decl":"instance : Finite (spectrum ℝ A) := A.finite_real_spectrum\n\n"}
{"name":"Matrix.IsHermitian.eigenvalues_eq_spectrum_real","module":"Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus","initialProofState":"n : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\na : Matrix n n 𝕜\nha : a.IsHermitian\n⊢ Eq (spectrum Real a) (Set.range ha.eigenvalues)","decl":"/-- The `ℝ`-spectrum of a Hermitian matrix over `RCLike` field is the range of the eigenvalue\nfunction -/\ntheorem eigenvalues_eq_spectrum_real {a : Matrix n n 𝕜} (ha : IsHermitian a) :\n    spectrum ℝ a = Set.range (ha.eigenvalues) := by\n  ext x\n  conv_lhs => rw [ha.spectral_theorem, unitary.spectrum.unitary_conjugate,\n  ← spectrum.algebraMap_mem_iff 𝕜, spectrum_diagonal, RCLike.algebraMap_eq_ofReal]\n  simp\n\n"}
{"name":"Matrix.IsHermitian.cfcAux_apply","module":"Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus","initialProofState":"n : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n 𝕜\nhA : A.IsHermitian\ng : ContinuousMap (↑(spectrum Real A)) Real\n⊢ Eq (hA.cfcAux g) (HMul.hMul (HMul.hMul (↑hA.eigenvectorUnitary) (Matrix.diagonal (Function.comp RCLike.ofReal (Function.comp ⇑g fun i => ⟨hA.eigenvalues i, ⋯⟩)))) (Star.star ↑hA.eigenvectorUnitary))","decl":"/-- The star algebra homomorphism underlying the instance of the continuous functional\ncalculus of a Hermitian matrix. This is an auxiliary definition and is not intended\nfor use outside of this file. -/\n@[simps]\nnoncomputable def cfcAux : C(spectrum ℝ A, ℝ) →⋆ₐ[ℝ] (Matrix n n 𝕜) where\n  toFun := fun g => (eigenvectorUnitary hA : Matrix n n 𝕜) *\n    diagonal (RCLike.ofReal ∘ g ∘ (fun i ↦ ⟨hA.eigenvalues i, hA.eigenvalues_mem_spectrum_real i⟩))\n    * star (eigenvectorUnitary hA : Matrix n n 𝕜)\n  map_one' := by simp [Pi.one_def (f := fun _ : n ↦ 𝕜)]\n  map_mul' f g := by\n    have {a b c d e f : Matrix n n 𝕜} : (a * b * c) * (d * e * f) = a * (b * (c * d) * e) * f := by\n      simp only [mul_assoc]\n    simp only [this, ContinuousMap.coe_mul, SetLike.coe_mem, unitary.star_mul_self_of_mem, mul_one,\n      diagonal_mul_diagonal, Function.comp_apply]\n    congr! with i\n    simp\n  map_zero' := by simp [Pi.zero_def (f := fun _ : n ↦ 𝕜)]\n  map_add' f g := by\n    simp only [ContinuousMap.coe_add, ← add_mul, ← mul_add, diagonal_add, Function.comp_apply]\n    congr! with i\n    simp\n  commutes' r := by\n    simp only [Function.comp_def, algebraMap_apply, smul_eq_mul, mul_one]\n    rw [← mul_one (algebraMap _ _ _), ← unitary.coe_mul_star_self hA.eigenvectorUnitary,\n      ← Algebra.left_comm, unitary.coe_star, mul_assoc]\n    congr!\n  map_star' f := by\n    simp only [star_trivial, StarMul.star_mul, star_star, star_eq_conjTranspose (diagonal _),\n      diagonal_conjTranspose, mul_assoc]\n    congr!\n    ext\n    simp\n\n"}
{"name":"Matrix.IsHermitian.isClosedEmbedding_cfcAux","module":"Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus","initialProofState":"n : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n 𝕜\nhA : A.IsHermitian\n⊢ Topology.IsClosedEmbedding ⇑hA.cfcAux","decl":"lemma isClosedEmbedding_cfcAux : IsClosedEmbedding hA.cfcAux := by\n  have h0 : FiniteDimensional ℝ C(spectrum ℝ A, ℝ) :=\n    FiniteDimensional.of_injective (ContinuousMap.coeFnLinearMap ℝ (M := ℝ)) DFunLike.coe_injective\n  refine LinearMap.isClosedEmbedding_of_injective (𝕜 := ℝ) (E := C(spectrum ℝ A, ℝ))\n    (F := Matrix n n 𝕜) (f := hA.cfcAux) <| LinearMap.ker_eq_bot'.mpr fun f hf ↦ ?_\n  have h2 :\n      diagonal (RCLike.ofReal ∘ f ∘ fun i ↦ ⟨hA.eigenvalues i, hA.eigenvalues_mem_spectrum_real i⟩)\n        = (0 : Matrix n n 𝕜) := by\n    simp only [LinearMap.coe_coe, cfcAux_apply] at hf\n    replace hf := congr($(hf) * (eigenvectorUnitary hA : Matrix n n 𝕜))\n    simp only [mul_assoc, SetLike.coe_mem, unitary.star_mul_self_of_mem, mul_one, zero_mul] at hf\n    simpa [← mul_assoc] using congr((star hA.eigenvectorUnitary : Matrix n n 𝕜) * $(hf))\n  ext x\n  simp only [ContinuousMap.zero_apply]\n  obtain ⟨x, hx⟩ := x\n  obtain ⟨i, rfl⟩ := hA.eigenvalues_eq_spectrum_real ▸ hx\n  rw [← diagonal_zero] at h2\n  have := (diagonal_eq_diagonal_iff).mp h2\n  refine RCLike.ofReal_eq_zero.mp (this i)\n\n"}
{"name":"Matrix.IsHermitian.closedEmbedding_cfcAux","module":"Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus","initialProofState":"n : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n 𝕜\nhA : A.IsHermitian\n⊢ Topology.IsClosedEmbedding ⇑hA.cfcAux","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_cfcAux := isClosedEmbedding_cfcAux\n\n"}
{"name":"Matrix.IsHermitian.cfcAux_id","module":"Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus","initialProofState":"n : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n 𝕜\nhA : A.IsHermitian\n⊢ Eq (hA.cfcAux (ContinuousMap.restrict (spectrum Real A) (ContinuousMap.id Real))) A","decl":"lemma cfcAux_id : hA.cfcAux (.restrict (spectrum ℝ A) (.id ℝ)) = A := by\n  conv_rhs => rw [hA.spectral_theorem]\n  congr!\n\n"}
{"name":"Matrix.IsHermitian.instContinuousFunctionalCalculus","module":"Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus","initialProofState":"n : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\n⊢ ContinuousFunctionalCalculus Real IsSelfAdjoint","decl":"/-- Instance of the continuous functional calculus for a Hermitian matrix over `𝕜` with\n`RCLike 𝕜`. -/\ninstance instContinuousFunctionalCalculus :\n    ContinuousFunctionalCalculus ℝ (IsSelfAdjoint : Matrix n n 𝕜 → Prop) where\n  exists_cfc_of_predicate a ha := by\n    replace ha : IsHermitian a := ha\n    refine ⟨ha.cfcAux, ha.isClosedEmbedding_cfcAux, ha.cfcAux_id, fun f ↦ ?map_spec,\n      fun f ↦ ?hermitian⟩\n    case map_spec =>\n      apply Set.eq_of_subset_of_subset\n      · rw [← ContinuousMap.spectrum_eq_range f]\n        apply AlgHom.spectrum_apply_subset\n      · rw [cfcAux_apply, unitary.spectrum.unitary_conjugate]\n        rintro - ⟨x , rfl⟩\n        apply spectrum.of_algebraMap_mem 𝕜\n        simp only [Function.comp_apply, Set.mem_range, spectrum_diagonal]\n        obtain ⟨x, hx⟩ := x\n        obtain ⟨i, rfl⟩ := ha.eigenvalues_eq_spectrum_real ▸ hx\n        exact ⟨i, rfl⟩\n    case hermitian =>\n      simp only [isSelfAdjoint_iff, cfcAux_apply, mul_assoc, star_mul, star_star]\n      rw [star_eq_conjTranspose, diagonal_conjTranspose]\n      congr!\n      simp [Pi.star_def, Function.comp_def]\n  spectrum_nonempty a ha := by\n    obtain (h | h) := isEmpty_or_nonempty n\n    · obtain ⟨x, y, hxy⟩ := exists_pair_ne (Matrix n n 𝕜)\n      exact False.elim <| Matrix.of.symm.injective.ne hxy <| Subsingleton.elim _ _\n    · exact eigenvalues_eq_spectrum_real ha ▸ Set.range_nonempty _\n  predicate_zero := .zero _\n\n"}
{"name":"Matrix.IsHermitian.cfc_eq","module":"Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus","initialProofState":"n : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n 𝕜\nhA : A.IsHermitian\nf : Real → Real\n⊢ Eq (cfc f A) (hA.cfc f)","decl":"lemma cfc_eq (f : ℝ → ℝ) : cfc f A = hA.cfc f := by\n  have hA' : IsSelfAdjoint A := hA\n  have := cfcHom_eq_of_continuous_of_map_id hA' hA.cfcAux hA.isClosedEmbedding_cfcAux.continuous\n    hA.cfcAux_id\n  rw [cfc_apply f A hA' (by rw [continuousOn_iff_continuous_restrict]; fun_prop), this]\n  simp only [cfcAux_apply, ContinuousMap.coe_mk, Function.comp_def, Set.restrict_apply,\n    IsHermitian.cfc]\n\n"}
