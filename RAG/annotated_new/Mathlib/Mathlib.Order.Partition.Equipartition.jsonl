{"name":"Finpartition.isEquipartition_iff_card_parts_eq_average","module":"Mathlib.Order.Partition.Equipartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nP : Finpartition s\n⊢ Iff P.IsEquipartition (∀ (a : Finset α), Membership.mem P.parts a → Or (Eq a.card (HDiv.hDiv s.card P.parts.card)) (Eq a.card (HAdd.hAdd (HDiv.hDiv s.card P.parts.card) 1)))","decl":"theorem isEquipartition_iff_card_parts_eq_average :\n    P.IsEquipartition ↔\n      ∀ a : Finset α, a ∈ P.parts → #a = #s / #P.parts ∨ #a = #s / #P.parts + 1 := by\n  simp_rw [IsEquipartition, Finset.equitableOn_iff, P.sum_card_parts]\n\n"}
{"name":"Finpartition.not_isEquipartition","module":"Mathlib.Order.Partition.Equipartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nP : Finpartition s\n⊢ Iff (Not P.IsEquipartition) (Exists fun a => And (Membership.mem P.parts a) (Exists fun b => And (Membership.mem P.parts b) (LT.lt (HAdd.hAdd b.card 1) a.card)))","decl":"lemma not_isEquipartition :\n    ¬P.IsEquipartition ↔ ∃ a ∈ P.parts, ∃ b ∈ P.parts, #b + 1 < #a := Set.not_equitableOn\n\n"}
{"name":"Set.Subsingleton.isEquipartition","module":"Mathlib.Order.Partition.Equipartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nP : Finpartition s\nh : (↑P.parts).Subsingleton\n⊢ P.IsEquipartition","decl":"theorem _root_.Set.Subsingleton.isEquipartition (h : (P.parts : Set (Finset α)).Subsingleton) :\n    P.IsEquipartition :=\n  Set.Subsingleton.equitableOn h _\n\n"}
{"name":"Finpartition.IsEquipartition.card_parts_eq_average","module":"Mathlib.Order.Partition.Equipartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nP : Finpartition s\nhP : P.IsEquipartition\nht : Membership.mem P.parts t\n⊢ Or (Eq t.card (HDiv.hDiv s.card P.parts.card)) (Eq t.card (HAdd.hAdd (HDiv.hDiv s.card P.parts.card) 1))","decl":"theorem IsEquipartition.card_parts_eq_average (hP : P.IsEquipartition) (ht : t ∈ P.parts) :\n    #t = #s / #P.parts ∨ #t = #s / #P.parts + 1 :=\n  P.isEquipartition_iff_card_parts_eq_average.1 hP _ ht\n\n"}
{"name":"Finpartition.IsEquipartition.card_part_eq_average_iff","module":"Mathlib.Order.Partition.Equipartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nP : Finpartition s\nhP : P.IsEquipartition\nht : Membership.mem P.parts t\n⊢ Iff (Eq t.card (HDiv.hDiv s.card P.parts.card)) (Ne t.card (HAdd.hAdd (HDiv.hDiv s.card P.parts.card) 1))","decl":"theorem IsEquipartition.card_part_eq_average_iff (hP : P.IsEquipartition) (ht : t ∈ P.parts) :\n    #t = #s / #P.parts ↔ #t ≠ #s / #P.parts + 1 := by\n  have a := hP.card_parts_eq_average ht\n  have b : ¬(#t = #s / #P.parts ∧ #t = #s / #P.parts + 1) := by\n    by_contra h; exact absurd (h.1 ▸ h.2) (lt_add_one _).ne\n  tauto\n\n"}
{"name":"Finpartition.IsEquipartition.average_le_card_part","module":"Mathlib.Order.Partition.Equipartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nP : Finpartition s\nhP : P.IsEquipartition\nht : Membership.mem P.parts t\n⊢ LE.le (HDiv.hDiv s.card P.parts.card) t.card","decl":"theorem IsEquipartition.average_le_card_part (hP : P.IsEquipartition) (ht : t ∈ P.parts) :\n    #s / #P.parts ≤ #t := by\n  rw [← P.sum_card_parts]\n  exact Finset.EquitableOn.le hP ht\n\n"}
{"name":"Finpartition.IsEquipartition.card_part_le_average_add_one","module":"Mathlib.Order.Partition.Equipartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nP : Finpartition s\nhP : P.IsEquipartition\nht : Membership.mem P.parts t\n⊢ LE.le t.card (HAdd.hAdd (HDiv.hDiv s.card P.parts.card) 1)","decl":"theorem IsEquipartition.card_part_le_average_add_one (hP : P.IsEquipartition) (ht : t ∈ P.parts) :\n    #t ≤ #s / #P.parts + 1 := by\n  rw [← P.sum_card_parts]\n  exact Finset.EquitableOn.le_add_one hP ht\n\n"}
{"name":"Finpartition.IsEquipartition.filter_ne_average_add_one_eq_average","module":"Mathlib.Order.Partition.Equipartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nP : Finpartition s\nhP : P.IsEquipartition\n⊢ Eq (Finset.filter (fun p => Not (Eq p.card (HAdd.hAdd (HDiv.hDiv s.card P.parts.card) 1))) P.parts) (Finset.filter (fun p => Eq p.card (HDiv.hDiv s.card P.parts.card)) P.parts)","decl":"theorem IsEquipartition.filter_ne_average_add_one_eq_average (hP : P.IsEquipartition) :\n    {p ∈ P.parts | ¬#p = #s / #P.parts + 1} = {p ∈ P.parts | #p = #s / #P.parts} := by\n  ext p\n  simp only [mem_filter, and_congr_right_iff]\n  exact fun hp ↦ (hP.card_part_eq_average_iff hp).symm\n\n"}
{"name":"Finpartition.IsEquipartition.card_large_parts_eq_mod","module":"Mathlib.Order.Partition.Equipartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nP : Finpartition s\nhP : P.IsEquipartition\n⊢ Eq (Finset.filter (fun p => Eq p.card (HAdd.hAdd (HDiv.hDiv s.card P.parts.card) 1)) P.parts).card (HMod.hMod s.card P.parts.card)","decl":"/-- An equipartition of a finset with `n` elements into `k` parts has\n`n % k` parts of size `n / k + 1`. -/\ntheorem IsEquipartition.card_large_parts_eq_mod (hP : P.IsEquipartition) :\n    #{p ∈ P.parts | #p = #s / #P.parts + 1} = #s % #P.parts := by\n  have z := P.sum_card_parts\n  rw [← sum_filter_add_sum_filter_not (s := P.parts) (p := fun x ↦ #x = #s / #P.parts + 1),\n    hP.filter_ne_average_add_one_eq_average, sum_const_nat (m := #s / #P.parts + 1) (by simp),\n    sum_const_nat (m := #s / #P.parts) (by simp), ← hP.filter_ne_average_add_one_eq_average,\n    mul_add, add_comm, ← add_assoc, ← add_mul, mul_one, add_comm #_,\n    filter_card_add_filter_neg_card_eq_card, add_comm] at z\n  rw [← add_left_inj, Nat.mod_add_div, z]\n\n"}
{"name":"Finpartition.IsEquipartition.card_small_parts_eq_mod","module":"Mathlib.Order.Partition.Equipartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nP : Finpartition s\nhP : P.IsEquipartition\n⊢ Eq (Finset.filter (fun p => Eq p.card (HDiv.hDiv s.card P.parts.card)) P.parts).card (HSub.hSub P.parts.card (HMod.hMod s.card P.parts.card))","decl":"/-- An equipartition of a finset with `n` elements into `k` parts has\n`n - n % k` parts of size `n / k`. -/\ntheorem IsEquipartition.card_small_parts_eq_mod (hP : P.IsEquipartition) :\n    #{p ∈ P.parts | #p = #s / #P.parts} = #P.parts - #s % #P.parts := by\n  conv_rhs =>\n    arg 1\n    rw [← filter_card_add_filter_neg_card_eq_card (p := fun p ↦ #p = #s / #P.parts + 1)]\n  rw [hP.card_large_parts_eq_mod, add_tsub_cancel_left, hP.filter_ne_average_add_one_eq_average]\n\n"}
{"name":"Finpartition.IsEquipartition.exists_partsEquiv","module":"Mathlib.Order.Partition.Equipartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nP : Finpartition s\nhP : P.IsEquipartition\n⊢ Exists fun f => ∀ (t : Subtype fun x => Membership.mem P.parts x), Iff (Eq (↑t).card (HAdd.hAdd (HDiv.hDiv s.card P.parts.card) 1)) (LT.lt (↑(f t)) (HMod.hMod s.card P.parts.card))","decl":"/-- There exists an enumeration of an equipartition's parts where\nlarger parts map to smaller numbers and vice versa. -/\ntheorem IsEquipartition.exists_partsEquiv (hP : P.IsEquipartition) :\n    ∃ f : P.parts ≃ Fin #P.parts, ∀ t, #t.1 = #s / #P.parts + 1 ↔ f t < #s % #P.parts := by\n  let el := {p ∈ P.parts | #p = #s / #P.parts + 1}.equivFin\n  let es := {p ∈ P.parts | #p = #s / #P.parts}.equivFin\n  simp_rw [mem_filter, hP.card_large_parts_eq_mod] at el\n  simp_rw [mem_filter, hP.card_small_parts_eq_mod] at es\n  let sneg :\n      {x // x ∈ P.parts ∧ ¬#x = #s / #P.parts + 1} ≃ {x // x ∈ P.parts ∧ #x = #s / #P.parts} := by\n    apply (Equiv.refl _).subtypeEquiv\n    simp only [Equiv.refl_apply, and_congr_right_iff]\n    exact fun _ ha ↦ by rw [hP.card_part_eq_average_iff ha, ne_eq]\n  replace el : { x : P.parts // #x.1 = #s / #P.parts + 1 } ≃\n      Fin (#s % #P.parts) := (Equiv.Set.sep ..).symm.trans el\n  replace es : { x : P.parts // ¬#x.1 = #s / #P.parts + 1 } ≃\n      Fin (#P.parts - #s % #P.parts) := (Equiv.Set.sep ..).symm.trans (sneg.trans es)\n  let f := (Equiv.sumCompl _).symm.trans ((el.sumCongr es).trans finSumFinEquiv)\n  use f.trans (finCongr (Nat.add_sub_of_le P.card_mod_card_parts_le))\n  intro ⟨p, _⟩\n  simp_rw [f, Equiv.trans_apply, Equiv.sumCongr_apply, finCongr_apply, Fin.coe_cast]\n  by_cases hc : #p = #s / #P.parts + 1 <;> simp [hc]\n\n"}
{"name":"Finpartition.IsEquipartition.exists_partPreservingEquiv","module":"Mathlib.Order.Partition.Equipartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nP : Finpartition s\nhP : P.IsEquipartition\n⊢ Exists fun f => ∀ (a b : Subtype fun x => Membership.mem s x), Iff (Eq (P.part ↑a) (P.part ↑b)) (Eq (HMod.hMod (↑(f a)) P.parts.card) (HMod.hMod (↑(f b)) P.parts.card))","decl":"/-- Given a finset equipartitioned into `k` parts, its elements can be enumerated such that\nelements in the same part have congruent indices modulo `k`. -/\ntheorem IsEquipartition.exists_partPreservingEquiv (hP : P.IsEquipartition) : ∃ f : s ≃ Fin #s,\n    ∀ a b : s, P.part a = P.part b ↔ f a % #P.parts = f b % #P.parts := by\n  obtain ⟨f, hf⟩ := P.exists_enumeration\n  obtain ⟨g, hg⟩ := hP.exists_partsEquiv\n  let z := fun a ↦ #P.parts * (f a).2 + g (f a).1\n  have gl := fun a ↦ (g (f a).1).2\n  have less : ∀ a, z a < #s := fun a ↦ by\n    rcases hP.card_parts_eq_average (f a).1.2 with (c | c)\n    · calc\n        _ < #P.parts * ((f a).2 + 1) := add_lt_add_left (gl a) _\n        _ ≤ #P.parts * (#s / #P.parts) := mul_le_mul_left' (c ▸ (f a).2.2) _\n        _ ≤ #P.parts * (#s / #P.parts) + #s % #P.parts := Nat.le_add_right ..\n        _ = _ := Nat.div_add_mod ..\n    · rw [← Nat.div_add_mod #s #P.parts]\n      exact add_lt_add_of_le_of_lt (mul_le_mul_left' (by omega) _) ((hg (f a).1).mp c)\n  let z' : s → Fin #s := fun a ↦ ⟨z a, less a⟩\n  have bij : z'.Bijective := by\n    refine (bijective_iff_injective_and_card z').mpr ⟨fun a b e ↦ ?_, by simp⟩\n    simp_rw [z', z, Fin.mk.injEq, mul_comm #P.parts] at e\n    haveI : NeZero #P.parts := ⟨((Nat.zero_le _).trans_lt (gl a)).ne'⟩\n    change (#P.parts).divModEquiv.symm (_, _) = (#P.parts).divModEquiv.symm (_, _) at e\n    simp only [Equiv.apply_eq_iff_eq, Prod.mk.injEq] at e\n    apply_fun f\n    exact Sigma.ext e.2 <| (Fin.heq_ext_iff (by rw [e.2])).mpr e.1\n  use Equiv.ofBijective _ bij\n  intro a b\n  simp_rw [z', z, Equiv.ofBijective_apply, hf a b, Nat.mul_add_mod,\n    Nat.mod_eq_of_lt (gl a), Nat.mod_eq_of_lt (gl b), Fin.val_eq_val, g.apply_eq_iff_eq]\n\n"}
{"name":"Finpartition.bot_isEquipartition","module":"Mathlib.Order.Partition.Equipartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Bot.bot.IsEquipartition","decl":"theorem bot_isEquipartition : (⊥ : Finpartition s).IsEquipartition :=\n  Set.equitableOn_iff_exists_eq_eq_add_one.2 ⟨1, by simp⟩\n\n"}
{"name":"Finpartition.top_isEquipartition","module":"Mathlib.Order.Partition.Equipartition","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ns : Finset α\ninst✝ : Decidable (Eq s Bot.bot)\n⊢ Top.top.IsEquipartition","decl":"theorem top_isEquipartition [Decidable (s = ⊥)] : (⊤ : Finpartition s).IsEquipartition :=\n  Set.Subsingleton.isEquipartition (parts_top_subsingleton _)\n\n"}
{"name":"Finpartition.indiscrete_isEquipartition","module":"Mathlib.Order.Partition.Equipartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nhs : Ne s EmptyCollection.emptyCollection\n⊢ (Finpartition.indiscrete hs).IsEquipartition","decl":"theorem indiscrete_isEquipartition {hs : s ≠ ∅} : (indiscrete hs).IsEquipartition := by\n  rw [IsEquipartition, indiscrete_parts, coe_singleton]\n  exact Set.equitableOn_singleton s _\n\n"}
