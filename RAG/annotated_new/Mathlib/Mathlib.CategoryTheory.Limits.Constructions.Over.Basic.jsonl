{"name":"CategoryTheory.Over.instHasPullbacks","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nB : C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\n⊢ CategoryTheory.Limits.HasPullbacks (CategoryTheory.Over B)","decl":"/-- Make sure we can derive pullbacks in `Over B`. -/\ninstance {B : C} [HasPullbacks C] : HasPullbacks (Over B) := by\n  letI : HasLimitsOfShape (ULiftHom.{v} (ULift.{v} WalkingCospan)) C :=\n    hasLimitsOfShape_of_equivalence (ULiftHomULiftCategory.equiv.{v} _)\n  letI : Category (ULiftHom.{v} (ULift.{v} WalkingCospan)) := inferInstance\n  exact hasLimitsOfShape_of_equivalence (ULiftHomULiftCategory.equiv.{v, v} _).symm\n\n"}
{"name":"CategoryTheory.Over.instHasEqualizers","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nB : C\ninst✝ : CategoryTheory.Limits.HasEqualizers C\n⊢ CategoryTheory.Limits.HasEqualizers (CategoryTheory.Over B)","decl":"/-- Make sure we can derive equalizers in `Over B`. -/\ninstance {B : C} [HasEqualizers C] : HasEqualizers (Over B) := by\n  letI : HasLimitsOfShape (ULiftHom.{v} (ULift.{v} WalkingParallelPair)) C :=\n    hasLimitsOfShape_of_equivalence (ULiftHomULiftCategory.equiv.{v} _)\n  letI : Category (ULiftHom.{v} (ULift.{v} WalkingParallelPair)) := inferInstance\n  exact hasLimitsOfShape_of_equivalence (ULiftHomULiftCategory.equiv.{v, v} _).symm\n\n"}
{"name":"CategoryTheory.Over.hasFiniteLimits","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nB : C\ninst✝ : CategoryTheory.Limits.HasFiniteWidePullbacks C\n⊢ CategoryTheory.Limits.HasFiniteLimits (CategoryTheory.Over B)","decl":"instance hasFiniteLimits {B : C} [HasFiniteWidePullbacks C] : HasFiniteLimits (Over B) := by\n  apply @hasFiniteLimits_of_hasEqualizers_and_finite_products _ _ ?_ ?_\n  · exact ConstructProducts.over_finiteProducts_of_finiteWidePullbacks\n  · apply @hasEqualizers_of_hasPullbacks_and_binary_products _ _ ?_ _\n    haveI : HasPullbacks C := ⟨inferInstance⟩\n    exact ConstructProducts.over_binaryProduct_of_pullback\n\n"}
{"name":"CategoryTheory.Over.hasLimits","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nB : C\ninst✝ : CategoryTheory.Limits.HasWidePullbacks C\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{w, w, v, max u v} (CategoryTheory.Over B)","decl":"instance hasLimits {B : C} [HasWidePullbacks.{w} C] : HasLimitsOfSize.{w, w} (Over B) := by\n  apply @has_limits_of_hasEqualizers_and_products _ _ ?_ ?_\n  · exact ConstructProducts.over_products_of_widePullbacks\n  · apply @hasEqualizers_of_hasPullbacks_and_binary_products _ _ ?_ _\n    haveI : HasPullbacks C := ⟨inferInstance⟩\n    exact ConstructProducts.over_binaryProduct_of_pullback\n\n"}
