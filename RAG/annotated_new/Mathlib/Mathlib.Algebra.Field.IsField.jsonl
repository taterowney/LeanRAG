{"name":"IsField.exists_pair_ne","module":"Mathlib.Algebra.Field.IsField","initialProofState":"R : Type u\ninst✝ : Semiring R\nself : IsField R\n⊢ Exists fun x => Exists fun y => Ne x y","decl":"/-- A predicate to express that a (semi)ring is a (semi)field.\n\nThis is mainly useful because such a predicate does not contain data,\nand can therefore be easily transported along ring isomorphisms.\nAdditionally, this is useful when trying to prove that\na particular ring structure extends to a (semi)field. -/\nstructure IsField (R : Type u) [Semiring R] : Prop where\n  /-- For a semiring to be a field, it must have two distinct elements. -/\n  exists_pair_ne : ∃ x y : R, x ≠ y\n  /-- Fields are commutative. -/\n  mul_comm : ∀ x y : R, x * y = y * x\n  /-- Nonzero elements have multiplicative inverses. -/\n  mul_inv_cancel : ∀ {a : R}, a ≠ 0 → ∃ b, a * b = 1\n\n"}
{"name":"IsField.mul_inv_cancel","module":"Mathlib.Algebra.Field.IsField","initialProofState":"R : Type u\ninst✝ : Semiring R\nself : IsField R\na : R\na✝ : Ne a 0\n⊢ Exists fun b => Eq (HMul.hMul a b) 1","decl":"/-- A predicate to express that a (semi)ring is a (semi)field.\n\nThis is mainly useful because such a predicate does not contain data,\nand can therefore be easily transported along ring isomorphisms.\nAdditionally, this is useful when trying to prove that\na particular ring structure extends to a (semi)field. -/\nstructure IsField (R : Type u) [Semiring R] : Prop where\n  /-- For a semiring to be a field, it must have two distinct elements. -/\n  exists_pair_ne : ∃ x y : R, x ≠ y\n  /-- Fields are commutative. -/\n  mul_comm : ∀ x y : R, x * y = y * x\n  /-- Nonzero elements have multiplicative inverses. -/\n  mul_inv_cancel : ∀ {a : R}, a ≠ 0 → ∃ b, a * b = 1\n\n"}
{"name":"IsField.mul_comm","module":"Mathlib.Algebra.Field.IsField","initialProofState":"R : Type u\ninst✝ : Semiring R\nself : IsField R\nx y : R\n⊢ Eq (HMul.hMul x y) (HMul.hMul y x)","decl":"/-- A predicate to express that a (semi)ring is a (semi)field.\n\nThis is mainly useful because such a predicate does not contain data,\nand can therefore be easily transported along ring isomorphisms.\nAdditionally, this is useful when trying to prove that\na particular ring structure extends to a (semi)field. -/\nstructure IsField (R : Type u) [Semiring R] : Prop where\n  /-- For a semiring to be a field, it must have two distinct elements. -/\n  exists_pair_ne : ∃ x y : R, x ≠ y\n  /-- Fields are commutative. -/\n  mul_comm : ∀ x y : R, x * y = y * x\n  /-- Nonzero elements have multiplicative inverses. -/\n  mul_inv_cancel : ∀ {a : R}, a ≠ 0 → ∃ b, a * b = 1\n\n"}
{"name":"Semifield.toIsField","module":"Mathlib.Algebra.Field.IsField","initialProofState":"R : Type u\ninst✝ : Semifield R\n⊢ IsField R","decl":"/-- Transferring from `Semifield` to `IsField`. -/\ntheorem Semifield.toIsField (R : Type u) [Semifield R] : IsField R where\n  __ := ‹Semifield R›\n  mul_inv_cancel {a} ha := ⟨a⁻¹, mul_inv_cancel₀ ha⟩\n\n"}
{"name":"Field.toIsField","module":"Mathlib.Algebra.Field.IsField","initialProofState":"R : Type u\ninst✝ : Field R\n⊢ IsField R","decl":"/-- Transferring from `Field` to `IsField`. -/\ntheorem Field.toIsField (R : Type u) [Field R] : IsField R :=\n  Semifield.toIsField _\n\n"}
{"name":"IsField.nontrivial","module":"Mathlib.Algebra.Field.IsField","initialProofState":"R : Type u\ninst✝ : Semiring R\nh : IsField R\n⊢ Nontrivial R","decl":"@[simp]\ntheorem IsField.nontrivial {R : Type u} [Semiring R] (h : IsField R) : Nontrivial R :=\n  ⟨h.exists_pair_ne⟩\n\n"}
{"name":"not_isField_of_subsingleton","module":"Mathlib.Algebra.Field.IsField","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : Subsingleton R\n⊢ Not (IsField R)","decl":"@[simp]\ntheorem not_isField_of_subsingleton (R : Type u) [Semiring R] [Subsingleton R] : ¬IsField R :=\n  fun h =>\n  let ⟨_, _, h⟩ := h.exists_pair_ne\n  h (Subsingleton.elim _ _)\n\n"}
{"name":"uniq_inv_of_isField","module":"Mathlib.Algebra.Field.IsField","initialProofState":"R : Type u\ninst✝ : Ring R\nhf : IsField R\nx : R\na✝ : Ne x 0\n⊢ ExistsUnique fun y => Eq (HMul.hMul x y) 1","decl":"/-- For each field, and for each nonzero element of said field, there is a unique inverse.\nSince `IsField` doesn't remember the data of an `inv` function and as such,\na lemma that there is a unique inverse could be useful.\n-/\ntheorem uniq_inv_of_isField (R : Type u) [Ring R] (hf : IsField R) :\n    ∀ x : R, x ≠ 0 → ∃! y : R, x * y = 1 := by\n  intro x hx\n  apply existsUnique_of_exists_of_unique\n  · exact hf.mul_inv_cancel hx\n  · intro y z hxy hxz\n    calc\n      y = y * (x * z) := by rw [hxz, mul_one]\n      _ = x * y * z := by rw [← mul_assoc, hf.mul_comm y x]\n      _ = z := by rw [hxy, one_mul]\n\n"}
