{"name":"MeasurableSpace.map_def","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nf : α → β\ns : Set β\n⊢ Iff (MeasurableSet s) (MeasurableSet (Set.preimage f s))","decl":"lemma map_def {s : Set β} : MeasurableSet[m.map f] s ↔ MeasurableSet[m] (f ⁻¹' s) := Iff.rfl\n\n"}
{"name":"MeasurableSpace.map_id","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\n⊢ Eq (MeasurableSpace.map id m) m","decl":"@[simp]\ntheorem map_id : m.map id = m :=\n  MeasurableSpace.ext fun _ => Iff.rfl\n\n"}
{"name":"MeasurableSpace.map_comp","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\nf : α → β\ng : β → γ\n⊢ Eq (MeasurableSpace.map g (MeasurableSpace.map f m)) (MeasurableSpace.map (Function.comp g f) m)","decl":"@[simp]\ntheorem map_comp {f : α → β} {g : β → γ} : (m.map f).map g = m.map (g ∘ f) :=\n  MeasurableSpace.ext fun _ => Iff.rfl\n\n"}
{"name":"MeasurableSpace.measurableSet_comap","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nm : MeasurableSpace β\n⊢ Iff (MeasurableSet s) (Exists fun s' => And (MeasurableSet s') (Eq (Set.preimage f s') s))","decl":"lemma measurableSet_comap {m : MeasurableSpace β} :\n    MeasurableSet[m.comap f] s ↔ ∃ s', MeasurableSet[m] s' ∧ f ⁻¹' s' = s := .rfl\n\n"}
{"name":"MeasurableSpace.comap_eq_generateFrom","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace β\nf : α → β\n⊢ Eq (MeasurableSpace.comap f m) (MeasurableSpace.generateFrom (setOf fun t => Exists fun s => And (MeasurableSet s) (Eq (Set.preimage f s) t)))","decl":"theorem comap_eq_generateFrom (m : MeasurableSpace β) (f : α → β) :\n    m.comap f = generateFrom { t | ∃ s, MeasurableSet s ∧ f ⁻¹' s = t } :=\n  (@generateFrom_measurableSet _ (.comap f m)).symm\n\n"}
{"name":"MeasurableSpace.comap_id","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\n⊢ Eq (MeasurableSpace.comap id m) m","decl":"@[simp]\ntheorem comap_id : m.comap id = m :=\n  MeasurableSpace.ext fun s => ⟨fun ⟨_, hs', h⟩ => h ▸ hs', fun h => ⟨s, h, rfl⟩⟩\n\n"}
{"name":"MeasurableSpace.comap_comp","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\nf : β → α\ng : γ → β\n⊢ Eq (MeasurableSpace.comap g (MeasurableSpace.comap f m)) (MeasurableSpace.comap (Function.comp f g) m)","decl":"@[simp]\ntheorem comap_comp {f : β → α} {g : γ → β} : (m.comap f).comap g = m.comap (f ∘ g) :=\n  MeasurableSpace.ext fun _ =>\n    ⟨fun ⟨_, ⟨u, h, hu⟩, ht⟩ => ⟨u, h, ht ▸ hu ▸ rfl⟩, fun ⟨t, h, ht⟩ => ⟨f ⁻¹' t, ⟨_, h, rfl⟩, ht⟩⟩\n\n"}
{"name":"MeasurableSpace.comap_le_iff_le_map","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nm' : MeasurableSpace β\nf : α → β\n⊢ Iff (LE.le (MeasurableSpace.comap f m') m) (LE.le m' (MeasurableSpace.map f m))","decl":"theorem comap_le_iff_le_map {f : α → β} : m'.comap f ≤ m ↔ m' ≤ m.map f :=\n  ⟨fun h _s hs => h _ ⟨_, hs, rfl⟩, fun h _s ⟨_t, ht, heq⟩ => heq ▸ h _ ht⟩\n\n"}
{"name":"MeasurableSpace.gc_comap_map","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ GaloisConnection (MeasurableSpace.comap f) (MeasurableSpace.map f)","decl":"theorem gc_comap_map (f : α → β) :\n    GaloisConnection (MeasurableSpace.comap f) (MeasurableSpace.map f) := fun _ _ =>\n  comap_le_iff_le_map\n\n"}
{"name":"MeasurableSpace.map_mono","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm₁ m₂ : MeasurableSpace α\nf : α → β\nh : LE.le m₁ m₂\n⊢ LE.le (MeasurableSpace.map f m₁) (MeasurableSpace.map f m₂)","decl":"theorem map_mono (h : m₁ ≤ m₂) : m₁.map f ≤ m₂.map f :=\n  (gc_comap_map f).monotone_u h\n\n"}
{"name":"MeasurableSpace.monotone_map","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Monotone (MeasurableSpace.map f)","decl":"theorem monotone_map : Monotone (MeasurableSpace.map f) := fun _ _ => map_mono\n\n"}
{"name":"MeasurableSpace.comap_mono","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm₁ m₂ : MeasurableSpace α\ng : β → α\nh : LE.le m₁ m₂\n⊢ LE.le (MeasurableSpace.comap g m₁) (MeasurableSpace.comap g m₂)","decl":"theorem comap_mono (h : m₁ ≤ m₂) : m₁.comap g ≤ m₂.comap g :=\n  (gc_comap_map g).monotone_l h\n\n"}
{"name":"MeasurableSpace.monotone_comap","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ng : β → α\n⊢ Monotone (MeasurableSpace.comap g)","decl":"theorem monotone_comap : Monotone (MeasurableSpace.comap g) := fun _ _ h => comap_mono h\n\n"}
{"name":"MeasurableSpace.comap_bot","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ng : β → α\n⊢ Eq (MeasurableSpace.comap g Bot.bot) Bot.bot","decl":"@[simp]\ntheorem comap_bot : (⊥ : MeasurableSpace α).comap g = ⊥ :=\n  (gc_comap_map g).l_bot\n\n"}
{"name":"MeasurableSpace.comap_sup","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm₁ m₂ : MeasurableSpace α\ng : β → α\n⊢ Eq (MeasurableSpace.comap g (Max.max m₁ m₂)) (Max.max (MeasurableSpace.comap g m₁) (MeasurableSpace.comap g m₂))","decl":"@[simp]\ntheorem comap_sup : (m₁ ⊔ m₂).comap g = m₁.comap g ⊔ m₂.comap g :=\n  (gc_comap_map g).l_sup\n\n"}
{"name":"MeasurableSpace.comap_iSup","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort uι\ng : β → α\nm : ι → MeasurableSpace α\n⊢ Eq (MeasurableSpace.comap g (iSup fun i => m i)) (iSup fun i => MeasurableSpace.comap g (m i))","decl":"@[simp]\ntheorem comap_iSup {m : ι → MeasurableSpace α} : (⨆ i, m i).comap g = ⨆ i, (m i).comap g :=\n  (gc_comap_map g).l_iSup\n\n"}
{"name":"MeasurableSpace.map_top","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (MeasurableSpace.map f Top.top) Top.top","decl":"@[simp]\ntheorem map_top : (⊤ : MeasurableSpace α).map f = ⊤ :=\n  (gc_comap_map f).u_top\n\n"}
{"name":"MeasurableSpace.map_inf","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm₁ m₂ : MeasurableSpace α\nf : α → β\n⊢ Eq (MeasurableSpace.map f (Min.min m₁ m₂)) (Min.min (MeasurableSpace.map f m₁) (MeasurableSpace.map f m₂))","decl":"@[simp]\ntheorem map_inf : (m₁ ⊓ m₂).map f = m₁.map f ⊓ m₂.map f :=\n  (gc_comap_map f).u_inf\n\n"}
{"name":"MeasurableSpace.map_iInf","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort uι\nf : α → β\nm : ι → MeasurableSpace α\n⊢ Eq (MeasurableSpace.map f (iInf fun i => m i)) (iInf fun i => MeasurableSpace.map f (m i))","decl":"@[simp]\ntheorem map_iInf {m : ι → MeasurableSpace α} : (⨅ i, m i).map f = ⨅ i, (m i).map f :=\n  (gc_comap_map f).u_iInf\n\n"}
{"name":"MeasurableSpace.comap_map_le","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nf : α → β\n⊢ LE.le (MeasurableSpace.comap f (MeasurableSpace.map f m)) m","decl":"theorem comap_map_le : (m.map f).comap f ≤ m :=\n  (gc_comap_map f).l_u_le _\n\n"}
{"name":"MeasurableSpace.le_map_comap","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ng : β → α\n⊢ LE.le m (MeasurableSpace.map g (MeasurableSpace.comap g m))","decl":"theorem le_map_comap : m ≤ (m.comap g).map g :=\n  (gc_comap_map g).le_u_l _\n\n"}
{"name":"MeasurableSpace.map_const","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nb : β\n⊢ Eq (MeasurableSpace.map (fun _a => b) m) Top.top","decl":"@[simp] theorem map_const {m} (b : β) : MeasurableSpace.map (fun _a : α ↦ b) m = ⊤ :=\n  eq_top_iff.2 <| fun s _ ↦ by rw [map_def]; by_cases h : b ∈ s <;> simp [h]\n\n"}
{"name":"MeasurableSpace.comap_const","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace β\nb : β\n⊢ Eq (MeasurableSpace.comap (fun _a => b) m) Bot.bot","decl":"@[simp] theorem comap_const {m} (b : β) : MeasurableSpace.comap (fun _a : α => b) m = ⊥ :=\n  eq_bot_iff.2 <| by rintro _ ⟨s, -, rfl⟩; by_cases b ∈ s <;> simp [*]\n\n"}
{"name":"MeasurableSpace.comap_generateFrom","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set (Set β)\n⊢ Eq (MeasurableSpace.comap f (MeasurableSpace.generateFrom s)) (MeasurableSpace.generateFrom (Set.image (Set.preimage f) s))","decl":"theorem comap_generateFrom {f : α → β} {s : Set (Set β)} :\n    (generateFrom s).comap f = generateFrom (preimage f '' s) :=\n  le_antisymm\n    (comap_le_iff_le_map.2 <|\n      generateFrom_le fun _t hts => GenerateMeasurable.basic _ <| mem_image_of_mem _ <| hts)\n    (generateFrom_le fun _t ⟨u, hu, Eq⟩ => Eq ▸ ⟨u, GenerateMeasurable.basic _ hu, rfl⟩)\n\n"}
{"name":"measurable_iff_le_map","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm₁ : MeasurableSpace α\nm₂ : MeasurableSpace β\nf : α → β\n⊢ Iff (Measurable f) (LE.le m₂ (MeasurableSpace.map f m₁))","decl":"theorem measurable_iff_le_map {m₁ : MeasurableSpace α} {m₂ : MeasurableSpace β} {f : α → β} :\n    Measurable f ↔ m₂ ≤ m₁.map f :=\n  Iff.rfl\n\n"}
{"name":"Measurable.le_map","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm₁ : MeasurableSpace α\nm₂ : MeasurableSpace β\nf : α → β\na✝ : Measurable f\n⊢ LE.le m₂ (MeasurableSpace.map f m₁)","decl":"alias ⟨Measurable.le_map, Measurable.of_le_map⟩ := measurable_iff_le_map\n\n"}
{"name":"Measurable.of_le_map","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm₁ : MeasurableSpace α\nm₂ : MeasurableSpace β\nf : α → β\na✝ : LE.le m₂ (MeasurableSpace.map f m₁)\n⊢ Measurable f","decl":"alias ⟨Measurable.le_map, Measurable.of_le_map⟩ := measurable_iff_le_map\n\n"}
{"name":"measurable_iff_comap_le","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm₁ : MeasurableSpace α\nm₂ : MeasurableSpace β\nf : α → β\n⊢ Iff (Measurable f) (LE.le (MeasurableSpace.comap f m₂) m₁)","decl":"theorem measurable_iff_comap_le {m₁ : MeasurableSpace α} {m₂ : MeasurableSpace β} {f : α → β} :\n    Measurable f ↔ m₂.comap f ≤ m₁ :=\n  comap_le_iff_le_map.symm\n\n"}
{"name":"Measurable.comap_le","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm₁ : MeasurableSpace α\nm₂ : MeasurableSpace β\nf : α → β\na✝ : Measurable f\n⊢ LE.le (MeasurableSpace.comap f m₂) m₁","decl":"alias ⟨Measurable.comap_le, Measurable.of_comap_le⟩ := measurable_iff_comap_le\n\n"}
{"name":"Measurable.of_comap_le","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm₁ : MeasurableSpace α\nm₂ : MeasurableSpace β\nf : α → β\na✝ : LE.le (MeasurableSpace.comap f m₂) m₁\n⊢ Measurable f","decl":"alias ⟨Measurable.comap_le, Measurable.of_comap_le⟩ := measurable_iff_comap_le\n\n"}
{"name":"comap_measurable","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace β\nf : α → β\n⊢ Measurable f","decl":"theorem comap_measurable {m : MeasurableSpace β} (f : α → β) : Measurable[m.comap f] f :=\n  fun s hs => ⟨s, hs, rfl⟩\n\n"}
{"name":"Measurable.mono","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nma ma' : MeasurableSpace α\nmb mb' : MeasurableSpace β\nf : α → β\nhf : Measurable f\nha : LE.le ma ma'\nhb : LE.le mb' mb\n⊢ Measurable f","decl":"theorem Measurable.mono {ma ma' : MeasurableSpace α} {mb mb' : MeasurableSpace β} {f : α → β}\n    (hf : @Measurable α β ma mb f) (ha : ma ≤ ma') (hb : mb' ≤ mb) : @Measurable α β ma' mb' f :=\n  fun _t ht => ha _ <| hf <| hb _ ht\n\n"}
{"name":"Measurable.iSup'","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort uι\nmα : ι → MeasurableSpace α\nx✝ : MeasurableSpace β\nf : α → β\ni₀ : ι\nh : Measurable f\n⊢ Measurable f","decl":"lemma Measurable.iSup' {mα : ι → MeasurableSpace α} {_ : MeasurableSpace β} {f : α → β} (i₀ : ι)\n    (h : Measurable[mα i₀] f) :\n    Measurable[⨆ i, mα i] f :=\n  h.mono (le_iSup mα i₀) le_rfl\n\n"}
{"name":"Measurable.sup_of_left","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα mα' : MeasurableSpace α\nx✝ : MeasurableSpace β\nf : α → β\nh : Measurable f\n⊢ Measurable f","decl":"lemma Measurable.sup_of_left {mα mα' : MeasurableSpace α} {_ : MeasurableSpace β} {f : α → β}\n    (h : Measurable[mα] f) :\n    Measurable[mα ⊔ mα'] f :=\n  h.mono le_sup_left le_rfl\n\n"}
{"name":"Measurable.sup_of_right","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα mα' : MeasurableSpace α\nx✝ : MeasurableSpace β\nf : α → β\nh : Measurable f\n⊢ Measurable f","decl":"lemma Measurable.sup_of_right {mα mα' : MeasurableSpace α} {_ : MeasurableSpace β} {f : α → β}\n    (h : Measurable[mα'] f) :\n    Measurable[mα ⊔ mα'] f :=\n  h.mono le_sup_right le_rfl\n\n"}
{"name":"measurable_id''","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nm mα : MeasurableSpace α\nhm : LE.le m mα\n⊢ Measurable id","decl":"theorem measurable_id'' {m mα : MeasurableSpace α} (hm : m ≤ mα) : @Measurable α α mα m id :=\n  measurable_id.mono le_rfl hm\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: add TC `DiscreteMeasurable` + instances\n\n"}
{"name":"measurable_from_top","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace β\nf : α → β\n⊢ Measurable f","decl":"@[measurability]\ntheorem measurable_from_top [MeasurableSpace β] {f : α → β} : Measurable[⊤] f := fun _ _ => trivial\n\n"}
{"name":"measurable_generateFrom","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\ns : Set (Set β)\nf : α → β\nh : ∀ (t : Set β), Membership.mem s t → MeasurableSet (Set.preimage f t)\n⊢ Measurable f","decl":"theorem measurable_generateFrom [MeasurableSpace α] {s : Set (Set β)} {f : α → β}\n    (h : ∀ t ∈ s, MeasurableSet (f ⁻¹' t)) : @Measurable _ _ _ (generateFrom s) f :=\n  Measurable.of_le_map <| generateFrom_le h\n\n"}
{"name":"Subsingleton.measurable","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : Subsingleton α\n⊢ Measurable f","decl":"@[nontriviality, measurability]\ntheorem Subsingleton.measurable [Subsingleton α] : Measurable f := fun _ _ =>\n  @Subsingleton.measurableSet α _ _ _\n\n"}
{"name":"measurable_of_subsingleton_codomain","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : Subsingleton β\nf : α → β\n⊢ Measurable f","decl":"@[nontriviality, measurability]\ntheorem measurable_of_subsingleton_codomain [Subsingleton β] (f : α → β) : Measurable f :=\n  fun s _ => Subsingleton.set_cases MeasurableSet.empty MeasurableSet.univ s\n\n"}
{"name":"measurable_one","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : One α\n⊢ Measurable 1","decl":"@[to_additive (attr := measurability, fun_prop)]\ntheorem measurable_one [One α] : Measurable (1 : β → α) :=\n  @measurable_const _ _ _ _ 1\n\n"}
{"name":"measurable_zero","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : Zero α\n⊢ Measurable 0","decl":"@[to_additive (attr := measurability, fun_prop)]\ntheorem measurable_one [One α] : Measurable (1 : β → α) :=\n  @measurable_const _ _ _ _ 1\n\n"}
{"name":"measurable_of_empty","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : IsEmpty α\nf : α → β\n⊢ Measurable f","decl":"theorem measurable_of_empty [IsEmpty α] (f : α → β) : Measurable f :=\n  Subsingleton.measurable\n\n"}
{"name":"measurable_of_empty_codomain","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : IsEmpty β\nf : α → β\n⊢ Measurable f","decl":"theorem measurable_of_empty_codomain [IsEmpty β] (f : α → β) : Measurable f :=\n  measurable_of_subsingleton_codomain f\n\n"}
{"name":"measurable_const'","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : β → α\nhf : ∀ (x y : β), Eq (f x) (f y)\n⊢ Measurable f","decl":"/-- A version of `measurable_const` that assumes `f x = f y` for all `x, y`. This version works\nfor functions between empty types. -/\ntheorem measurable_const' {f : β → α} (hf : ∀ x y, f x = f y) : Measurable f := by\n  nontriviality β\n  inhabit β\n  convert @measurable_const α β _ _ (f default) using 2\n  apply hf\n\n"}
{"name":"measurable_natCast","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : NatCast α\nn : Nat\n⊢ Measurable ↑n","decl":"@[measurability]\ntheorem measurable_natCast [NatCast α] (n : ℕ) : Measurable (n : β → α) :=\n  @measurable_const α _ _ _ n\n\n"}
{"name":"measurable_intCast","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : IntCast α\nn : Int\n⊢ Measurable ↑n","decl":"@[measurability]\ntheorem measurable_intCast [IntCast α] (n : ℤ) : Measurable (n : β → α) :=\n  @measurable_const α _ _ _ n\n\n"}
{"name":"measurable_of_countable","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\ninst✝¹ : Countable α\ninst✝ : MeasurableSingletonClass α\nf : α → β\n⊢ Measurable f","decl":"theorem measurable_of_countable [Countable α] [MeasurableSingletonClass α] (f : α → β) :\n    Measurable f := fun s _ =>\n  (f ⁻¹' s).to_countable.measurableSet\n\n"}
{"name":"measurable_of_finite","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\ninst✝¹ : Finite α\ninst✝ : MeasurableSingletonClass α\nf : α → β\n⊢ Measurable f","decl":"theorem measurable_of_finite [Finite α] [MeasurableSingletonClass α] (f : α → β) : Measurable f :=\n  measurable_of_countable f\n\n"}
{"name":"Measurable.iterate","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nf : α → α\nhf : Measurable f\nn : Nat\n⊢ Measurable (Nat.iterate f n)","decl":"@[measurability]\ntheorem Measurable.iterate {f : α → α} (hf : Measurable f) : ∀ n, Measurable f^[n]\n  | 0 => measurable_id\n  | n + 1 => (Measurable.iterate hf n).comp hf\n\n"}
{"name":"measurableSet_preimage","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nt : Set β\nhf : Measurable f\nht : MeasurableSet t\n⊢ MeasurableSet (Set.preimage f t)","decl":"@[measurability]\ntheorem measurableSet_preimage {t : Set β} (hf : Measurable f) (ht : MeasurableSet t) :\n    MeasurableSet (f ⁻¹' t) :=\n  hf ht\n\n"}
{"name":"MeasurableSet.preimage","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nt : Set β\nht : MeasurableSet t\nhf : Measurable f\n⊢ MeasurableSet (Set.preimage f t)","decl":"protected theorem MeasurableSet.preimage {t : Set β} (ht : MeasurableSet t) (hf : Measurable f) :\n    MeasurableSet (f ⁻¹' t) :=\n  hf ht\n\n"}
{"name":"Measurable.piecewise","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf g : α → β\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nx✝ : DecidablePred fun x => Membership.mem s x\nhs : MeasurableSet s\nhf : Measurable f\nhg : Measurable g\n⊢ Measurable (s.piecewise f g)","decl":"@[measurability, fun_prop]\nprotected theorem Measurable.piecewise {_ : DecidablePred (· ∈ s)} (hs : MeasurableSet s)\n    (hf : Measurable f) (hg : Measurable g) : Measurable (piecewise s f g) := by\n  intro t ht\n  rw [piecewise_preimage]\n  exact hs.ite (hf ht) (hg ht)\n\n"}
{"name":"Measurable.ite","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\nm : MeasurableSpace α\nmβ : MeasurableSpace β\np : α → Prop\nx✝ : DecidablePred p\nhp : MeasurableSet (setOf fun a => p a)\nhf : Measurable f\nhg : Measurable g\n⊢ Measurable fun x => ite (p x) (f x) (g x)","decl":"/-- This is slightly different from `Measurable.piecewise`. It can be used to show\n`Measurable (ite (x=0) 0 1)` by\n`exact Measurable.ite (measurableSet_singleton 0) measurable_const measurable_const`,\nbut replacing `Measurable.ite` by `Measurable.piecewise` in that example proof does not work. -/\ntheorem Measurable.ite {p : α → Prop} {_ : DecidablePred p} (hp : MeasurableSet { a : α | p a })\n    (hf : Measurable f) (hg : Measurable g) : Measurable fun x => ite (p x) (f x) (g x) :=\n  Measurable.piecewise hp hf hg\n\n"}
{"name":"Measurable.indicator","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : Zero β\nhf : Measurable f\nhs : MeasurableSet s\n⊢ Measurable (s.indicator f)","decl":"@[measurability, fun_prop]\ntheorem Measurable.indicator [Zero β] (hf : Measurable f) (hs : MeasurableSet s) :\n    Measurable (s.indicator f) :=\n  hf.piecewise hs measurable_const\n\n"}
{"name":"measurable_indicator_const_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝² : Zero β\ninst✝¹ : MeasurableSingletonClass β\nb : β\ninst✝ : NeZero b\n⊢ Iff (Measurable (s.indicator fun x => b)) (MeasurableSet s)","decl":"/-- The measurability of a set `A` is equivalent to the measurability of the indicator function\nwhich takes a constant value `b ≠ 0` on a set `A` and `0` elsewhere. -/\nlemma measurable_indicator_const_iff [Zero β] [MeasurableSingletonClass β] (b : β) [NeZero b] :\n    Measurable (s.indicator (fun (_ : α) ↦ b)) ↔ MeasurableSet s := by\n  constructor <;> intro h\n  · convert h (MeasurableSet.singleton (0 : β)).compl\n    ext a\n    simp [NeZero.ne b]\n  · exact measurable_const.indicator h\n\n"}
{"name":"measurableSet_mulSupport","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝¹ : One β\ninst✝ : MeasurableSingletonClass β\nhf : Measurable f\n⊢ MeasurableSet (Function.mulSupport f)","decl":"@[to_additive (attr := measurability)]\ntheorem measurableSet_mulSupport [One β] [MeasurableSingletonClass β] (hf : Measurable f) :\n    MeasurableSet (mulSupport f) :=\n  hf (measurableSet_singleton 1).compl\n\n"}
{"name":"measurableSet_support","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝¹ : Zero β\ninst✝ : MeasurableSingletonClass β\nhf : Measurable f\n⊢ MeasurableSet (Function.support f)","decl":"@[to_additive (attr := measurability)]\ntheorem measurableSet_mulSupport [One β] [MeasurableSingletonClass β] (hf : Measurable f) :\n    MeasurableSet (mulSupport f) :=\n  hf (measurableSet_singleton 1).compl\n\n"}
{"name":"Measurable.measurable_of_countable_ne","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : MeasurableSingletonClass α\nhf : Measurable f\nh : (setOf fun x => Ne (f x) (g x)).Countable\n⊢ Measurable g","decl":"/-- If a function coincides with a measurable function outside of a countable set, it is\nmeasurable. -/\ntheorem Measurable.measurable_of_countable_ne [MeasurableSingletonClass α] (hf : Measurable f)\n    (h : Set.Countable { x | f x ≠ g x }) : Measurable g := by\n  intro t ht\n  have : g ⁻¹' t = g ⁻¹' t ∩ { x | f x = g x }ᶜ ∪ g ⁻¹' t ∩ { x | f x = g x } := by\n    simp [← inter_union_distrib_left]\n  rw [this]\n  refine (h.mono inter_subset_right).measurableSet.union ?_\n  have : g ⁻¹' t ∩ { x : α | f x = g x } = f ⁻¹' t ∩ { x : α | f x = g x } := by\n    ext x\n    simp +contextual\n  rw [this]\n  exact (hf ht).inter h.measurableSet.of_compl\n\n"}
{"name":"measurable_to_countable","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : Countable α\ninst✝ : MeasurableSpace β\nf : β → α\nh : ∀ (y : β), MeasurableSet (Set.preimage f (Singleton.singleton (f y)))\n⊢ Measurable f","decl":"theorem measurable_to_countable [MeasurableSpace α] [Countable α] [MeasurableSpace β] {f : β → α}\n    (h : ∀ y, MeasurableSet (f ⁻¹' {f y})) : Measurable f := fun s _ => by\n  rw [← biUnion_preimage_singleton]\n  refine MeasurableSet.iUnion fun y => MeasurableSet.iUnion fun hy => ?_\n  by_cases hyf : y ∈ range f\n  · rcases hyf with ⟨y, rfl⟩\n    apply h\n  · simp only [preimage_singleton_eq_empty.2 hyf, MeasurableSet.empty]\n\n"}
{"name":"measurable_to_countable'","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : Countable α\ninst✝ : MeasurableSpace β\nf : β → α\nh : ∀ (x : α), MeasurableSet (Set.preimage f (Singleton.singleton x))\n⊢ Measurable f","decl":"theorem measurable_to_countable' [MeasurableSpace α] [Countable α] [MeasurableSpace β] {f : β → α}\n    (h : ∀ x, MeasurableSet (f ⁻¹' {x})) : Measurable f :=\n  measurable_to_countable fun y => h (f y)\n\n"}
{"name":"ENat.measurable_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_6\ninst✝ : MeasurableSpace α\nf : α → ENat\n⊢ Iff (Measurable f) (∀ (n : Nat), MeasurableSet (Set.preimage f (Singleton.singleton ↑n)))","decl":"theorem ENat.measurable_iff {α : Type*} [MeasurableSpace α] {f : α → ℕ∞} :\n    Measurable f ↔ ∀ n : ℕ, MeasurableSet (f ⁻¹' {↑n}) := by\n  refine ⟨fun hf n ↦ hf <| measurableSet_singleton _, fun h ↦ measurable_to_countable' fun n ↦ ?_⟩\n  cases n with\n  | top =>\n    rw [← WithTop.none_eq_top, ← compl_range_some, preimage_compl, ← iUnion_singleton_eq_range,\n      preimage_iUnion]\n    exact .compl <| .iUnion h\n  | coe n => exact h n\n\n"}
{"name":"measurable_unit","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : Unit → α\n⊢ Measurable f","decl":"@[measurability]\ntheorem measurable_unit [MeasurableSpace α] (f : Unit → α) : Measurable f :=\n  measurable_from_top\n\n"}
{"name":"measurable_down","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Measurable ULift.down","decl":"lemma measurable_down : Measurable (ULift.down : ULift α → α) := fun _ ↦ id\n"}
{"name":"measurable_up","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Measurable ULift.up","decl":"lemma measurable_up : Measurable (ULift.up : α → ULift α) := fun _ ↦ id\n\n"}
{"name":"measurableSet_preimage_down","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : Set α\n⊢ Iff (MeasurableSet (Set.preimage ULift.down s)) (MeasurableSet s)","decl":"@[simp] lemma measurableSet_preimage_down {s : Set α} :\n    MeasurableSet (ULift.down ⁻¹' s) ↔ MeasurableSet s := Iff.rfl\n"}
{"name":"measurableSet_preimage_up","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : Set (ULift.{u_6, u_1} α)\n⊢ Iff (MeasurableSet (Set.preimage ULift.up s)) (MeasurableSet s)","decl":"@[simp] lemma measurableSet_preimage_up {s : Set (ULift α)} :\n    MeasurableSet (ULift.up ⁻¹' s) ↔ MeasurableSet s := Iff.rfl\n\n"}
{"name":"measurable_from_nat","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : Nat → α\n⊢ Measurable f","decl":"@[measurability]\ntheorem measurable_from_nat {f : ℕ → α} : Measurable f :=\n  measurable_from_top\n\n"}
{"name":"measurable_to_nat","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → Nat\na✝ : ∀ (y : α), MeasurableSet (Set.preimage f (Singleton.singleton (f y)))\n⊢ Measurable f","decl":"theorem measurable_to_nat {f : α → ℕ} : (∀ y, MeasurableSet (f ⁻¹' {f y})) → Measurable f :=\n  measurable_to_countable\n\n"}
{"name":"measurable_to_bool","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → Bool\nh : MeasurableSet (Set.preimage f (Singleton.singleton Bool.true))\n⊢ Measurable f","decl":"theorem measurable_to_bool {f : α → Bool} (h : MeasurableSet (f ⁻¹' {true})) : Measurable f := by\n  apply measurable_to_countable'\n  rintro (- | -)\n  · convert h.compl\n    rw [← preimage_compl, Bool.compl_singleton, Bool.not_true]\n  exact h\n\n"}
{"name":"measurable_to_prop","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → Prop\nh : MeasurableSet (Set.preimage f (Singleton.singleton True))\n⊢ Measurable f","decl":"theorem measurable_to_prop {f : α → Prop} (h : MeasurableSet (f ⁻¹' {True})) : Measurable f := by\n  refine measurable_to_countable' fun x => ?_\n  by_cases hx : x\n  · simpa [hx] using h\n  · simpa only [hx, ← preimage_compl, Prop.compl_singleton, not_true, preimage_singleton_false]\n      using h.compl\n\n"}
{"name":"measurable_findGreatest'","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\np : α → Nat → Prop\ninst✝ : (x : α) → DecidablePred (p x)\nN : Nat\nhN : ∀ (k : Nat), LE.le k N → MeasurableSet (setOf fun x => Eq (Nat.findGreatest (p x) N) k)\n⊢ Measurable fun x => Nat.findGreatest (p x) N","decl":"theorem measurable_findGreatest' {p : α → ℕ → Prop} [∀ x, DecidablePred (p x)] {N : ℕ}\n    (hN : ∀ k ≤ N, MeasurableSet { x | Nat.findGreatest (p x) N = k }) :\n    Measurable fun x => Nat.findGreatest (p x) N :=\n  measurable_to_nat fun _ => hN _ N.findGreatest_le\n\n"}
{"name":"measurable_findGreatest","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\np : α → Nat → Prop\ninst✝ : (x : α) → DecidablePred (p x)\nN : Nat\nhN : ∀ (k : Nat), LE.le k N → MeasurableSet (setOf fun x => p x k)\n⊢ Measurable fun x => Nat.findGreatest (p x) N","decl":"theorem measurable_findGreatest {p : α → ℕ → Prop} [∀ x, DecidablePred (p x)] {N}\n    (hN : ∀ k ≤ N, MeasurableSet { x | p x k }) : Measurable fun x => Nat.findGreatest (p x) N := by\n  refine measurable_findGreatest' fun k hk => ?_\n  simp only [Nat.findGreatest_eq_iff, setOf_and, setOf_forall, ← compl_setOf]\n  repeat' apply_rules [MeasurableSet.inter, MeasurableSet.const, MeasurableSet.iInter,\n    MeasurableSet.compl, hN] <;> try intros\n\n"}
{"name":"measurable_find","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\np : α → Nat → Prop\ninst✝ : (x : α) → DecidablePred (p x)\nhp : ∀ (x : α), Exists fun N => p x N\nhm : ∀ (k : Nat), MeasurableSet (setOf fun x => p x k)\n⊢ Measurable fun x => Nat.find ⋯","decl":"theorem measurable_find {p : α → ℕ → Prop} [∀ x, DecidablePred (p x)] (hp : ∀ x, ∃ N, p x N)\n    (hm : ∀ k, MeasurableSet { x | p x k }) : Measurable fun x => Nat.find (hp x) := by\n  refine measurable_to_nat fun x => ?_\n  rw [preimage_find_eq_disjointed (fun k => {x | p x k})]\n  exact MeasurableSet.disjointed hm _\n\n"}
{"name":"measurableSet_quotient","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : Setoid α\nt : Set (Quotient s)\n⊢ Iff (MeasurableSet t) (MeasurableSet (Set.preimage Quotient.mk'' t))","decl":"theorem measurableSet_quotient {s : Setoid α} {t : Set (Quotient s)} :\n    MeasurableSet t ↔ MeasurableSet (Quotient.mk'' ⁻¹' t) :=\n  Iff.rfl\n\n"}
{"name":"measurable_from_quotient","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ns : Setoid α\nf : Quotient s → β\n⊢ Iff (Measurable f) (Measurable (Function.comp f Quotient.mk''))","decl":"theorem measurable_from_quotient {s : Setoid α} {f : Quotient s → β} :\n    Measurable f ↔ Measurable (f ∘ Quotient.mk'') :=\n  Iff.rfl\n\n"}
{"name":"measurable_quotient_mk'","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : Setoid α\n⊢ Measurable Quotient.mk'","decl":"@[measurability]\ntheorem measurable_quotient_mk' [s : Setoid α] : Measurable (Quotient.mk' : α → Quotient s) :=\n  fun _ => id\n\n"}
{"name":"measurable_quotient_mk''","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : Setoid α\n⊢ Measurable Quotient.mk''","decl":"@[measurability]\ntheorem measurable_quotient_mk'' {s : Setoid α} : Measurable (Quotient.mk'' : α → Quotient s) :=\n  fun _ => id\n\n"}
{"name":"measurable_quot_mk","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nr : α → α → Prop\n⊢ Measurable (Quot.mk r)","decl":"@[measurability]\ntheorem measurable_quot_mk {r : α → α → Prop} : Measurable (Quot.mk r) := fun _ => id\n\n"}
{"name":"QuotientGroup.measurable_coe","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"G : Type u_6\ninst✝¹ : Group G\ninst✝ : MeasurableSpace G\nS : Subgroup G\n⊢ Measurable QuotientGroup.mk","decl":"@[to_additive (attr := measurability)]\ntheorem QuotientGroup.measurable_coe {G} [Group G] [MeasurableSpace G] {S : Subgroup G} :\n    Measurable ((↑) : G → G ⧸ S) :=\n  measurable_quotient_mk''\n\n"}
{"name":"QuotientAddGroup.measurable_coe","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"G : Type u_6\ninst✝¹ : AddGroup G\ninst✝ : MeasurableSpace G\nS : AddSubgroup G\n⊢ Measurable QuotientAddGroup.mk","decl":"@[to_additive (attr := measurability)]\ntheorem QuotientGroup.measurable_coe {G} [Group G] [MeasurableSpace G] {S : Subgroup G} :\n    Measurable ((↑) : G → G ⧸ S) :=\n  measurable_quotient_mk''\n\n"}
{"name":"QuotientGroup.measurable_from_quotient","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\nG : Type u_6\ninst✝¹ : Group G\ninst✝ : MeasurableSpace G\nS : Subgroup G\nf : HasQuotient.Quotient G S → α\n⊢ Iff (Measurable f) (Measurable (Function.comp f QuotientGroup.mk))","decl":"@[to_additive]\nnonrec theorem QuotientGroup.measurable_from_quotient {G} [Group G] [MeasurableSpace G]\n    {S : Subgroup G} {f : G ⧸ S → α} : Measurable f ↔ Measurable (f ∘ ((↑) : G → G ⧸ S)) :=\n  measurable_from_quotient\n\n"}
{"name":"QuotientAddGroup.measurable_from_quotient","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\nG : Type u_6\ninst✝¹ : AddGroup G\ninst✝ : MeasurableSpace G\nS : AddSubgroup G\nf : HasQuotient.Quotient G S → α\n⊢ Iff (Measurable f) (Measurable (Function.comp f QuotientAddGroup.mk))","decl":"@[to_additive]\nnonrec theorem QuotientGroup.measurable_from_quotient {G} [Group G] [MeasurableSpace G]\n    {S : Subgroup G} {f : G ⧸ S → α} : Measurable f ↔ Measurable (f ∘ ((↑) : G → G ⧸ S)) :=\n  measurable_from_quotient\n\n"}
{"name":"Quotient.instDiscreteMeasurableSpace","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_6\ns : Setoid α\ninst✝¹ : MeasurableSpace α\ninst✝ : DiscreteMeasurableSpace α\n⊢ DiscreteMeasurableSpace (Quotient s)","decl":"instance Quotient.instDiscreteMeasurableSpace {α} {s : Setoid α} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] : DiscreteMeasurableSpace (Quotient s) where\n  forall_measurableSet _ := measurableSet_quotient.2 .of_discrete\n\n"}
{"name":"QuotientGroup.instDiscreteMeasurableSpace","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"G : Type u_6\ninst✝² : Group G\ninst✝¹ : MeasurableSpace G\ninst✝ : DiscreteMeasurableSpace G\nS : Subgroup G\n⊢ DiscreteMeasurableSpace (HasQuotient.Quotient G S)","decl":"@[to_additive]\ninstance QuotientGroup.instDiscreteMeasurableSpace {G} [Group G] [MeasurableSpace G]\n    [DiscreteMeasurableSpace G] (S : Subgroup G) : DiscreteMeasurableSpace (G ⧸ S) :=\n  Quotient.instDiscreteMeasurableSpace\n\n"}
{"name":"QuotientAddGroup.instDiscreteMeasurableSpace","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"G : Type u_6\ninst✝² : AddGroup G\ninst✝¹ : MeasurableSpace G\ninst✝ : DiscreteMeasurableSpace G\nS : AddSubgroup G\n⊢ DiscreteMeasurableSpace (HasQuotient.Quotient G S)","decl":"@[to_additive]\ninstance QuotientGroup.instDiscreteMeasurableSpace {G} [Group G] [MeasurableSpace G]\n    [DiscreteMeasurableSpace G] (S : Subgroup G) : DiscreteMeasurableSpace (G ⧸ S) :=\n  Quotient.instDiscreteMeasurableSpace\n\n"}
{"name":"measurable_subtype_coe","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\np : α → Prop\n⊢ Measurable Subtype.val","decl":"@[measurability]\ntheorem measurable_subtype_coe {p : α → Prop} : Measurable ((↑) : Subtype p → α) :=\n  MeasurableSpace.le_map_comap\n\n"}
{"name":"Subtype.instMeasurableSingletonClass","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\np : α → Prop\ninst✝ : MeasurableSingletonClass α\n⊢ MeasurableSingletonClass (Subtype p)","decl":"instance Subtype.instMeasurableSingletonClass {p : α → Prop} [MeasurableSingletonClass α] :\n    MeasurableSingletonClass (Subtype p) where\n  measurableSet_singleton x :=\n    ⟨{(x : α)}, measurableSet_singleton (x : α), by\n      rw [← image_singleton, preimage_image_eq _ Subtype.val_injective]⟩\n\n"}
{"name":"MeasurableSet.of_subtype_image","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : Set α\nt : Set ↑s\nh : MeasurableSet (Set.image Subtype.val t)\n⊢ MeasurableSet t","decl":"theorem MeasurableSet.of_subtype_image {s : Set α} {t : Set s}\n    (h : MeasurableSet (Subtype.val '' t)) : MeasurableSet t :=\n  ⟨_, h, preimage_image_eq _ Subtype.val_injective⟩\n\n"}
{"name":"MeasurableSet.subtype_image","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : Set α\nt : Set ↑s\nhs : MeasurableSet s\na✝ : MeasurableSet t\n⊢ MeasurableSet (Set.image Subtype.val t)","decl":"theorem MeasurableSet.subtype_image {s : Set α} {t : Set s} (hs : MeasurableSet s) :\n    MeasurableSet t → MeasurableSet (((↑) : s → α) '' t) := by\n  rintro ⟨u, hu, rfl⟩\n  rw [Subtype.image_preimage_coe]\n  exact hs.inter hu\n\n"}
{"name":"Measurable.subtype_coe","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\np : β → Prop\nf : α → Subtype p\nhf : Measurable f\n⊢ Measurable fun a => ↑(f a)","decl":"@[measurability]\ntheorem Measurable.subtype_coe {p : β → Prop} {f : α → Subtype p} (hf : Measurable f) :\n    Measurable fun a : α => (f a : β) :=\n  measurable_subtype_coe.comp hf\n\n"}
{"name":"Measurable.subtype_val","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\np : β → Prop\nf : α → Subtype p\nhf : Measurable f\n⊢ Measurable fun a => ↑(f a)","decl":"alias Measurable.subtype_val := Measurable.subtype_coe\n\n"}
{"name":"Measurable.subtype_mk","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\np : β → Prop\nf : α → β\nhf : Measurable f\nh : ∀ (x : α), p (f x)\n⊢ Measurable fun x => ⟨f x, ⋯⟩","decl":"@[measurability]\ntheorem Measurable.subtype_mk {p : β → Prop} {f : α → β} (hf : Measurable f) {h : ∀ x, p (f x)} :\n    Measurable fun x => (⟨f x, h x⟩ : Subtype p) := fun t ⟨s, hs⟩ =>\n  hs.2 ▸ by simp only [← preimage_comp, Function.comp_def, Subtype.coe_mk, hf hs.1]\n\n"}
{"name":"Measurable.rangeFactorization","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\nhf : Measurable f\n⊢ Measurable (Set.rangeFactorization f)","decl":"@[measurability]\nprotected theorem Measurable.rangeFactorization {f : α → β} (hf : Measurable f) :\n    Measurable (rangeFactorization f) :=\n  hf.subtype_mk\n\n"}
{"name":"Measurable.subtype_map","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\np : α → Prop\nq : β → Prop\nhf : Measurable f\nhpq : ∀ (x : α), p x → q (f x)\n⊢ Measurable (Subtype.map f hpq)","decl":"theorem Measurable.subtype_map {f : α → β} {p : α → Prop} {q : β → Prop} (hf : Measurable f)\n    (hpq : ∀ x, p x → q (f x)) : Measurable (Subtype.map f hpq) :=\n  (hf.comp measurable_subtype_coe).subtype_mk\n\n"}
{"name":"measurable_inclusion","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns t : Set α\nh : HasSubset.Subset s t\n⊢ Measurable (Set.inclusion h)","decl":"theorem measurable_inclusion {s t : Set α} (h : s ⊆ t) : Measurable (inclusion h) :=\n  measurable_id.subtype_map h\n\n"}
{"name":"MeasurableSet.image_inclusion'","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns t : Set α\nh : HasSubset.Subset s t\nu : Set ↑s\nhs : MeasurableSet (Set.preimage Subtype.val s)\nhu : MeasurableSet u\n⊢ MeasurableSet (Set.image (Set.inclusion h) u)","decl":"theorem MeasurableSet.image_inclusion' {s t : Set α} (h : s ⊆ t) {u : Set s}\n    (hs : MeasurableSet (Subtype.val ⁻¹' s : Set t)) (hu : MeasurableSet u) :\n    MeasurableSet (inclusion h '' u) := by\n  rcases hu with ⟨u, hu, rfl⟩\n  convert (measurable_subtype_coe hu).inter hs\n  ext ⟨x, hx⟩\n  simpa [@and_comm _ (_ = x)] using and_comm\n\n"}
{"name":"MeasurableSet.image_inclusion","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns t : Set α\nh : HasSubset.Subset s t\nu : Set ↑s\nhs : MeasurableSet s\nhu : MeasurableSet u\n⊢ MeasurableSet (Set.image (Set.inclusion h) u)","decl":"theorem MeasurableSet.image_inclusion {s t : Set α} (h : s ⊆ t) {u : Set s}\n    (hs : MeasurableSet s) (hu : MeasurableSet u) :\n    MeasurableSet (inclusion h '' u) :=\n  (measurable_subtype_coe hs).image_inclusion' h hu\n\n"}
{"name":"MeasurableSet.of_union_cover","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns t u : Set α\nhs : MeasurableSet s\nht : MeasurableSet t\nh : HasSubset.Subset Set.univ (Union.union s t)\nhsu : MeasurableSet (Set.preimage Subtype.val u)\nhtu : MeasurableSet (Set.preimage Subtype.val u)\n⊢ MeasurableSet u","decl":"theorem MeasurableSet.of_union_cover {s t u : Set α} (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h : univ ⊆ s ∪ t) (hsu : MeasurableSet (((↑) : s → α) ⁻¹' u))\n    (htu : MeasurableSet (((↑) : t → α) ⁻¹' u)) : MeasurableSet u := by\n  convert (hs.subtype_image hsu).union (ht.subtype_image htu)\n  simp [image_preimage_eq_inter_range, ← inter_union_distrib_left, univ_subset_iff.1 h]\n\n"}
{"name":"measurable_of_measurable_union_cover","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\ns t : Set α\nhs : MeasurableSet s\nht : MeasurableSet t\nh : HasSubset.Subset Set.univ (Union.union s t)\nhc : Measurable fun a => f ↑a\nhd : Measurable fun a => f ↑a\n⊢ Measurable f","decl":"theorem measurable_of_measurable_union_cover {f : α → β} (s t : Set α) (hs : MeasurableSet s)\n    (ht : MeasurableSet t) (h : univ ⊆ s ∪ t) (hc : Measurable fun a : s => f a)\n    (hd : Measurable fun a : t => f a) : Measurable f := fun _u hu =>\n  .of_union_cover hs ht h (hc hu) (hd hu)\n\n"}
{"name":"measurable_of_restrict_of_restrict_compl","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\ns : Set α\nhs : MeasurableSet s\nh₁ : Measurable (s.restrict f)\nh₂ : Measurable ((HasCompl.compl s).restrict f)\n⊢ Measurable f","decl":"theorem measurable_of_restrict_of_restrict_compl {f : α → β} {s : Set α} (hs : MeasurableSet s)\n    (h₁ : Measurable (s.restrict f)) (h₂ : Measurable (sᶜ.restrict f)) : Measurable f :=\n  measurable_of_measurable_union_cover s sᶜ hs hs.compl (union_compl_self s).ge h₁ h₂\n\n"}
{"name":"Measurable.dite","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : (x : α) → Decidable (Membership.mem s x)\nf : ↑s → β\nhf : Measurable f\ng : ↑(HasCompl.compl s) → β\nhg : Measurable g\nhs : MeasurableSet s\n⊢ Measurable fun x => dite (Membership.mem s x) (fun hx => f ⟨x, hx⟩) fun hx => g ⟨x, hx⟩","decl":"theorem Measurable.dite [∀ x, Decidable (x ∈ s)] {f : s → β} (hf : Measurable f)\n    {g : (sᶜ : Set α) → β} (hg : Measurable g) (hs : MeasurableSet s) :\n    Measurable fun x => if hx : x ∈ s then f ⟨x, hx⟩ else g ⟨x, hx⟩ :=\n  measurable_of_restrict_of_restrict_compl hs (by simpa) (by simpa)\n\n"}
{"name":"measurable_of_measurable_on_compl_finite","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : MeasurableSingletonClass α\nf : α → β\ns : Set α\nhs : s.Finite\nhf : Measurable ((HasCompl.compl s).restrict f)\n⊢ Measurable f","decl":"theorem measurable_of_measurable_on_compl_finite [MeasurableSingletonClass α] {f : α → β}\n    (s : Set α) (hs : s.Finite) (hf : Measurable (sᶜ.restrict f)) : Measurable f :=\n  have := hs.to_subtype\n  measurable_of_restrict_of_restrict_compl hs.measurableSet (measurable_of_finite _) hf\n\n"}
{"name":"measurable_of_measurable_on_compl_singleton","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : MeasurableSingletonClass α\nf : α → β\na : α\nhf : Measurable ((setOf fun x => Ne x a).restrict f)\n⊢ Measurable f","decl":"theorem measurable_of_measurable_on_compl_singleton [MeasurableSingletonClass α] {f : α → β} (a : α)\n    (hf : Measurable ({ x | x ≠ a }.restrict f)) : Measurable f :=\n  measurable_of_measurable_on_compl_finite {a} (finite_singleton a) hf\n\n"}
{"name":"mem_measurableAtom_self","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"β : Type u_2\ninst✝ : MeasurableSpace β\nx : β\n⊢ Membership.mem (measurableAtom x) x","decl":"@[simp] lemma mem_measurableAtom_self (x : β) : x ∈ measurableAtom x := by\n  simp +contextual [measurableAtom]\n\n"}
{"name":"mem_of_mem_measurableAtom","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"β : Type u_2\ninst✝ : MeasurableSpace β\nx y : β\nh : Membership.mem (measurableAtom x) y\ns : Set β\nhs : MeasurableSet s\nhxs : Membership.mem s x\n⊢ Membership.mem s y","decl":"lemma mem_of_mem_measurableAtom {x y : β} (h : y ∈ measurableAtom x) {s : Set β}\n    (hs : MeasurableSet s) (hxs : x ∈ s) : y ∈ s := by\n  simp only [measurableAtom, mem_iInter] at h\n  exact h s hxs hs\n\n"}
{"name":"measurableAtom_subset","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"β : Type u_2\ninst✝ : MeasurableSpace β\ns : Set β\nx : β\nhs : MeasurableSet s\nhx : Membership.mem s x\n⊢ HasSubset.Subset (measurableAtom x) s","decl":"lemma measurableAtom_subset {s : Set β} {x : β} (hs : MeasurableSet s) (hx : x ∈ s) :\n    measurableAtom x ⊆ s :=\n  iInter₂_subset_of_subset s hx fun ⦃a⦄ ↦ (by simp [hs])\n\n"}
{"name":"measurableAtom_of_measurableSingletonClass","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"β : Type u_2\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSingletonClass β\nx : β\n⊢ Eq (measurableAtom x) (Singleton.singleton x)","decl":"@[simp] lemma measurableAtom_of_measurableSingletonClass [MeasurableSingletonClass β] (x : β) :\n    measurableAtom x = {x} :=\n  Subset.antisymm (measurableAtom_subset (measurableSet_singleton x) rfl) (by simp)\n\n"}
{"name":"MeasurableSet.measurableAtom_of_countable","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"β : Type u_2\ninst✝¹ : MeasurableSpace β\ninst✝ : Countable β\nx : β\n⊢ MeasurableSet (measurableAtom x)","decl":"lemma MeasurableSet.measurableAtom_of_countable [Countable β] (x : β) :\n    MeasurableSet (measurableAtom x) := by\n  have : ∀ (y : β), y ∉ measurableAtom x → ∃ s, x ∈ s ∧ MeasurableSet s ∧ y ∉ s :=\n    fun y hy ↦ by simpa [measurableAtom] using hy\n  choose! s hs using this\n  have : measurableAtom x = ⋂ (y ∈ (measurableAtom x)ᶜ), s y := by\n    apply Subset.antisymm\n    · intro z hz\n      simp only [mem_iInter, mem_compl_iff]\n      intro i hi\n      exact mem_of_mem_measurableAtom hz (hs i hi).2.1 (hs i hi).1\n    · apply compl_subset_compl.1\n      intro z hz\n      simp only [compl_iInter, mem_iUnion, mem_compl_iff, exists_prop]\n      exact ⟨z, hz, (hs z hz).2.2⟩\n  rw [this]\n  exact MeasurableSet.biInter (to_countable (measurableAtom x)ᶜ) (fun i hi ↦ (hs i hi).2.1)\n\n"}
{"name":"measurable_fst","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx✝¹ : MeasurableSpace α\nx✝ : MeasurableSpace β\n⊢ Measurable Prod.fst","decl":"@[measurability]\ntheorem measurable_fst {_ : MeasurableSpace α} {_ : MeasurableSpace β} :\n    Measurable (Prod.fst : α × β → α) :=\n  Measurable.of_comap_le le_sup_left\n\n"}
{"name":"measurable_snd","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx✝¹ : MeasurableSpace α\nx✝ : MeasurableSpace β\n⊢ Measurable Prod.snd","decl":"@[measurability]\ntheorem measurable_snd {_ : MeasurableSpace α} {_ : MeasurableSpace β} :\n    Measurable (Prod.snd : α × β → β) :=\n  Measurable.of_comap_le le_sup_right\n\n"}
{"name":"Measurable.fst","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nmγ : MeasurableSpace γ\nf : α → Prod β γ\nhf : Measurable f\n⊢ Measurable fun a => (f a).1","decl":"@[fun_prop]\ntheorem Measurable.fst {f : α → β × γ} (hf : Measurable f) : Measurable fun a : α => (f a).1 :=\n  measurable_fst.comp hf\n\n"}
{"name":"Measurable.snd","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nmγ : MeasurableSpace γ\nf : α → Prod β γ\nhf : Measurable f\n⊢ Measurable fun a => (f a).2","decl":"@[fun_prop]\ntheorem Measurable.snd {f : α → β × γ} (hf : Measurable f) : Measurable fun a : α => (f a).2 :=\n  measurable_snd.comp hf\n\n"}
{"name":"Measurable.prod","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nmγ : MeasurableSpace γ\nf : α → Prod β γ\nhf₁ : Measurable fun a => (f a).1\nhf₂ : Measurable fun a => (f a).2\n⊢ Measurable f","decl":"@[measurability]\ntheorem Measurable.prod {f : α → β × γ} (hf₁ : Measurable fun a => (f a).1)\n    (hf₂ : Measurable fun a => (f a).2) : Measurable f :=\n  Measurable.of_le_map <|\n    sup_le\n      (by\n        rw [MeasurableSpace.comap_le_iff_le_map, MeasurableSpace.map_comp]\n        exact hf₁)\n      (by\n        rw [MeasurableSpace.comap_le_iff_le_map, MeasurableSpace.map_comp]\n        exact hf₂)\n\n"}
{"name":"Measurable.prod_mk","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nβ : Type u_6\nγ : Type u_7\nx✝¹ : MeasurableSpace β\nx✝ : MeasurableSpace γ\nf : α → β\ng : α → γ\nhf : Measurable f\nhg : Measurable g\n⊢ Measurable fun a => { fst := f a, snd := g a }","decl":"@[fun_prop]\ntheorem Measurable.prod_mk {β γ} {_ : MeasurableSpace β} {_ : MeasurableSpace γ} {f : α → β}\n    {g : α → γ} (hf : Measurable f) (hg : Measurable g) : Measurable fun a : α => (f a, g a) :=\n  Measurable.prod hf hg\n\n"}
{"name":"Measurable.prod_map","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nmγ : MeasurableSpace γ\ninst✝ : MeasurableSpace δ\nf : α → β\ng : γ → δ\nhf : Measurable f\nhg : Measurable g\n⊢ Measurable (Prod.map f g)","decl":"@[fun_prop]\ntheorem Measurable.prod_map [MeasurableSpace δ] {f : α → β} {g : γ → δ} (hf : Measurable f)\n    (hg : Measurable g) : Measurable (Prod.map f g) :=\n  (hf.comp measurable_fst).prod_mk (hg.comp measurable_snd)\n\n"}
{"name":"measurable_prod_mk_left","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nx : α\n⊢ Measurable (Prod.mk x)","decl":"theorem measurable_prod_mk_left {x : α} : Measurable (@Prod.mk _ β x) :=\n  measurable_const.prod_mk measurable_id\n\n"}
{"name":"measurable_prod_mk_right","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ny : β\n⊢ Measurable fun x => { fst := x, snd := y }","decl":"theorem measurable_prod_mk_right {y : β} : Measurable fun x : α => (x, y) :=\n  measurable_id.prod_mk measurable_const\n\n"}
{"name":"Measurable.of_uncurry_left","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nmγ : MeasurableSpace γ\nf : α → β → γ\nhf : Measurable (Function.uncurry f)\nx : α\n⊢ Measurable (f x)","decl":"theorem Measurable.of_uncurry_left {f : α → β → γ} (hf : Measurable (uncurry f)) {x : α} :\n    Measurable (f x) :=\n  hf.comp measurable_prod_mk_left\n\n"}
{"name":"Measurable.of_uncurry_right","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nmγ : MeasurableSpace γ\nf : α → β → γ\nhf : Measurable (Function.uncurry f)\ny : β\n⊢ Measurable fun x => f x y","decl":"theorem Measurable.of_uncurry_right {f : α → β → γ} (hf : Measurable (uncurry f)) {y : β} :\n    Measurable fun x => f x y :=\n  hf.comp measurable_prod_mk_right\n\n"}
{"name":"measurable_prod","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nmγ : MeasurableSpace γ\nf : α → Prod β γ\n⊢ Iff (Measurable f) (And (Measurable fun a => (f a).1) (Measurable fun a => (f a).2))","decl":"theorem measurable_prod {f : α → β × γ} :\n    Measurable f ↔ (Measurable fun a => (f a).1) ∧ Measurable fun a => (f a).2 :=\n  ⟨fun hf => ⟨measurable_fst.comp hf, measurable_snd.comp hf⟩, fun h => Measurable.prod h.1 h.2⟩\n\n"}
{"name":"measurable_swap","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\n⊢ Measurable Prod.swap","decl":"@[fun_prop, measurability]\ntheorem measurable_swap : Measurable (Prod.swap : α × β → β × α) :=\n  Measurable.prod measurable_snd measurable_fst\n\n"}
{"name":"measurable_swap_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nx✝ : MeasurableSpace γ\nf : Prod α β → γ\n⊢ Iff (Measurable (Function.comp f Prod.swap)) (Measurable f)","decl":"theorem measurable_swap_iff {_ : MeasurableSpace γ} {f : α × β → γ} :\n    Measurable (f ∘ Prod.swap) ↔ Measurable f :=\n  ⟨fun hf => hf.comp measurable_swap, fun hf => hf.comp measurable_swap⟩\n\n"}
{"name":"MeasurableSet.prod","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ns : Set α\nt : Set β\nhs : MeasurableSet s\nht : MeasurableSet t\n⊢ MeasurableSet (SProd.sprod s t)","decl":"@[measurability]\nprotected theorem MeasurableSet.prod {s : Set α} {t : Set β} (hs : MeasurableSet s)\n    (ht : MeasurableSet t) : MeasurableSet (s ×ˢ t) :=\n  MeasurableSet.inter (measurable_fst hs) (measurable_snd ht)\n\n"}
{"name":"measurableSet_prod_of_nonempty","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ns : Set α\nt : Set β\nh : (SProd.sprod s t).Nonempty\n⊢ Iff (MeasurableSet (SProd.sprod s t)) (And (MeasurableSet s) (MeasurableSet t))","decl":"theorem measurableSet_prod_of_nonempty {s : Set α} {t : Set β} (h : (s ×ˢ t).Nonempty) :\n    MeasurableSet (s ×ˢ t) ↔ MeasurableSet s ∧ MeasurableSet t := by\n  rcases h with ⟨⟨x, y⟩, hx, hy⟩\n  refine ⟨fun hst => ?_, fun h => h.1.prod h.2⟩\n  have : MeasurableSet ((fun x => (x, y)) ⁻¹' s ×ˢ t) := measurable_prod_mk_right hst\n  have : MeasurableSet (Prod.mk x ⁻¹' s ×ˢ t) := measurable_prod_mk_left hst\n  simp_all\n\n"}
{"name":"measurableSet_prod","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ns : Set α\nt : Set β\n⊢ Iff (MeasurableSet (SProd.sprod s t)) (Or (And (MeasurableSet s) (MeasurableSet t)) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection)))","decl":"theorem measurableSet_prod {s : Set α} {t : Set β} :\n    MeasurableSet (s ×ˢ t) ↔ MeasurableSet s ∧ MeasurableSet t ∨ s = ∅ ∨ t = ∅ := by\n  rcases (s ×ˢ t).eq_empty_or_nonempty with h | h\n  · simp [h, prod_eq_empty_iff.mp h]\n  · simp [← not_nonempty_iff_eq_empty, prod_nonempty_iff.mp h, measurableSet_prod_of_nonempty h]\n\n"}
{"name":"measurableSet_swap_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ns : Set (Prod α β)\n⊢ Iff (MeasurableSet (Set.preimage Prod.swap s)) (MeasurableSet s)","decl":"theorem measurableSet_swap_iff {s : Set (α × β)} :\n    MeasurableSet (Prod.swap ⁻¹' s) ↔ MeasurableSet s :=\n  ⟨fun hs => measurable_swap hs, fun hs => measurable_swap hs⟩\n\n"}
{"name":"Prod.instMeasurableSingletonClass","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝¹ : MeasurableSingletonClass α\ninst✝ : MeasurableSingletonClass β\n⊢ MeasurableSingletonClass (Prod α β)","decl":"instance Prod.instMeasurableSingletonClass\n    [MeasurableSingletonClass α] [MeasurableSingletonClass β] :\n    MeasurableSingletonClass (α × β) :=\n  ⟨fun ⟨a, b⟩ => @singleton_prod_singleton _ _ a b ▸ .prod (.singleton a) (.singleton b)⟩\n\n"}
{"name":"measurable_from_prod_countable'","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : Countable β\nx✝ : MeasurableSpace γ\nf : Prod α β → γ\nhf : ∀ (y : β), Measurable fun x => f { fst := x, snd := y }\nh'f : ∀ (y y' : β) (x : α), Membership.mem (measurableAtom y) y' → Eq (f { fst := x, snd := y' }) (f { fst := x, snd := y })\n⊢ Measurable f","decl":"theorem measurable_from_prod_countable' [Countable β]\n    {_ : MeasurableSpace γ} {f : α × β → γ} (hf : ∀ y, Measurable fun x => f (x, y))\n    (h'f : ∀ y y' x, y' ∈ measurableAtom y → f (x, y') = f (x, y)) :\n    Measurable f := fun s hs => by\n  have : f ⁻¹' s = ⋃ y, ((fun x => f (x, y)) ⁻¹' s) ×ˢ (measurableAtom y : Set β) := by\n    ext1 ⟨x, y⟩\n    simp only [mem_preimage, mem_iUnion, mem_prod]\n    refine ⟨fun h ↦ ⟨y, h, mem_measurableAtom_self y⟩, ?_⟩\n    rintro ⟨y', hy's, hy'⟩\n    rwa [h'f y' y x hy']\n  rw [this]\n  exact .iUnion (fun y ↦ (hf y hs).prod (.measurableAtom_of_countable y))\n\n"}
{"name":"measurable_from_prod_countable","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝¹ : Countable β\ninst✝ : MeasurableSingletonClass β\nx✝ : MeasurableSpace γ\nf : Prod α β → γ\nhf : ∀ (y : β), Measurable fun x => f { fst := x, snd := y }\n⊢ Measurable f","decl":"theorem measurable_from_prod_countable [Countable β] [MeasurableSingletonClass β]\n    {_ : MeasurableSpace γ} {f : α × β → γ} (hf : ∀ y, Measurable fun x => f (x, y)) :\n    Measurable f :=\n  measurable_from_prod_countable' hf (by simp +contextual)\n\n"}
{"name":"Measurable.find","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmβ : MeasurableSpace β\nx✝ : MeasurableSpace α\nf : Nat → α → β\np : Nat → α → Prop\ninst✝ : (n : Nat) → DecidablePred (p n)\nhf : ∀ (n : Nat), Measurable (f n)\nhp : ∀ (n : Nat), MeasurableSet (setOf fun x => p n x)\nh : ∀ (x : α), Exists fun n => p n x\n⊢ Measurable fun x => f (Nat.find ⋯) x","decl":"/-- A piecewise function on countably many pieces is measurable if all the data is measurable. -/\n@[measurability]\ntheorem Measurable.find {_ : MeasurableSpace α} {f : ℕ → α → β} {p : ℕ → α → Prop}\n    [∀ n, DecidablePred (p n)] (hf : ∀ n, Measurable (f n)) (hp : ∀ n, MeasurableSet { x | p n x })\n    (h : ∀ x, ∃ n, p n x) : Measurable fun x => f (Nat.find (h x)) x :=\n  have : Measurable fun p : α × ℕ => f p.2 p.1 := measurable_from_prod_countable fun n => hf n\n  this.comp (Measurable.prod_mk measurable_id (measurable_find h hp))\n\n"}
{"name":"measurable_iUnionLift","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort uι\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : Countable ι\nt : ι → Set α\nf : (i : ι) → ↑(t i) → β\nhtf : ∀ (i j : ι) (x : α) (hxi : Membership.mem (t i) x) (hxj : Membership.mem (t j) x), Eq (f i ⟨x, hxi⟩) (f j ⟨x, hxj⟩)\nT : Set α\nhT : HasSubset.Subset T (Set.iUnion fun i => t i)\nhtm : ∀ (i : ι), MeasurableSet (t i)\nhfm : ∀ (i : ι), Measurable (f i)\n⊢ Measurable (Set.iUnionLift t f htf T hT)","decl":"/-- Let `t i` be a countable covering of a set `T` by measurable sets. Let `f i : t i → β` be a\nfamily of functions that agree on the intersections `t i ∩ t j`. Then the function\n`Set.iUnionLift t f _ _ : T → β`, defined as `f i ⟨x, hx⟩` for `hx : x ∈ t i`, is measurable. -/\ntheorem measurable_iUnionLift [Countable ι] {t : ι → Set α} {f : ∀ i, t i → β}\n    (htf : ∀ (i j) (x : α) (hxi : x ∈ t i) (hxj : x ∈ t j), f i ⟨x, hxi⟩ = f j ⟨x, hxj⟩)\n    {T : Set α} (hT : T ⊆ ⋃ i, t i) (htm : ∀ i, MeasurableSet (t i)) (hfm : ∀ i, Measurable (f i)) :\n    Measurable (iUnionLift t f htf T hT) := fun s hs => by\n  rw [preimage_iUnionLift]\n  exact .preimage (.iUnion fun i => .image_inclusion _ (htm _) (hfm i hs)) (measurable_inclusion _)\n\n"}
{"name":"measurable_liftCover","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort uι\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : Countable ι\nt : ι → Set α\nhtm : ∀ (i : ι), MeasurableSet (t i)\nf : (i : ι) → ↑(t i) → β\nhfm : ∀ (i : ι), Measurable (f i)\nhf : ∀ (i j : ι) (x : α) (hxi : Membership.mem (t i) x) (hxj : Membership.mem (t j) x), Eq (f i ⟨x, hxi⟩) (f j ⟨x, hxj⟩)\nhtU : Eq (Set.iUnion fun i => t i) Set.univ\n⊢ Measurable (Set.liftCover t f hf htU)","decl":"/-- Let `t i` be a countable covering of `α` by measurable sets. Let `f i : t i → β` be a family of\nfunctions that agree on the intersections `t i ∩ t j`. Then the function `Set.liftCover t f _ _`,\ndefined as `f i ⟨x, hx⟩` for `hx : x ∈ t i`, is measurable. -/\ntheorem measurable_liftCover [Countable ι] (t : ι → Set α) (htm : ∀ i, MeasurableSet (t i))\n    (f : ∀ i, t i → β) (hfm : ∀ i, Measurable (f i))\n    (hf : ∀ (i j) (x : α) (hxi : x ∈ t i) (hxj : x ∈ t j), f i ⟨x, hxi⟩ = f j ⟨x, hxj⟩)\n    (htU : ⋃ i, t i = univ) :\n    Measurable (liftCover t f hf htU) := fun s hs => by\n  rw [preimage_liftCover]\n  exact .iUnion fun i => .subtype_image (htm i) <| hfm i hs\n\n"}
{"name":"exists_measurable_piecewise","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nι : Type u_6\ninst✝¹ : Countable ι\ninst✝ : Nonempty ι\nt : ι → Set α\nt_meas : ∀ (n : ι), MeasurableSet (t n)\ng : ι → α → β\nhg : ∀ (n : ι), Measurable (g n)\nht : Pairwise fun i j => Set.EqOn (g i) (g j) (Inter.inter (t i) (t j))\n⊢ Exists fun f => And (Measurable f) (∀ (n : ι), Set.EqOn f (g n) (t n))","decl":"/-- Let `t i` be a nonempty countable family of measurable sets in `α`. Let `g i : α → β` be a\nfamily of measurable functions such that `g i` agrees with `g j` on `t i ∩ t j`. Then there exists\na measurable function `f : α → β` that agrees with each `g i` on `t i`.\n\nWe only need the assumption `[Nonempty ι]` to prove `[Nonempty (α → β)]`. -/\ntheorem exists_measurable_piecewise {ι} [Countable ι] [Nonempty ι] (t : ι → Set α)\n    (t_meas : ∀ n, MeasurableSet (t n)) (g : ι → α → β) (hg : ∀ n, Measurable (g n))\n    (ht : Pairwise fun i j => EqOn (g i) (g j) (t i ∩ t j)) :\n    ∃ f : α → β, Measurable f ∧ ∀ n, EqOn f (g n) (t n) := by\n  inhabit ι\n  set g' : (i : ι) → t i → β := fun i => g i ∘ (↑)\n  -- see https://github.com/leanprover-community/mathlib4/issues/2184\n  have ht' : ∀ (i j) (x : α) (hxi : x ∈ t i) (hxj : x ∈ t j), g' i ⟨x, hxi⟩ = g' j ⟨x, hxj⟩ := by\n    intro i j x hxi hxj\n    rcases eq_or_ne i j with rfl | hij\n    · rfl\n    · exact ht hij ⟨hxi, hxj⟩\n  set f : (⋃ i, t i) → β := iUnionLift t g' ht' _ Subset.rfl\n  have hfm : Measurable f := measurable_iUnionLift _ _ t_meas\n    (fun i => (hg i).comp measurable_subtype_coe)\n  classical\n    refine ⟨fun x => if hx : x ∈ ⋃ i, t i then f ⟨x, hx⟩ else g default x,\n      hfm.dite ((hg default).comp measurable_subtype_coe) (.iUnion t_meas), fun i x hx => ?_⟩\n    simp only [dif_pos (mem_iUnion.2 ⟨i, hx⟩)]\n    exact iUnionLift_of_mem ⟨x, mem_iUnion.2 ⟨i, hx⟩⟩ hx\n\n"}
{"name":"measurable_pi_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nδ : Type u_4\nπ : δ → Type u_6\ninst✝¹ : MeasurableSpace α\ninst✝ : (a : δ) → MeasurableSpace (π a)\ng : α → (a : δ) → π a\n⊢ Iff (Measurable g) (∀ (a : δ), Measurable fun x => g x a)","decl":"theorem measurable_pi_iff {g : α → ∀ a, π a} : Measurable g ↔ ∀ a, Measurable fun x => g x a := by\n  simp_rw [measurable_iff_comap_le, MeasurableSpace.pi, MeasurableSpace.comap_iSup,\n    MeasurableSpace.comap_comp, Function.comp_def, iSup_le_iff]\n\n"}
{"name":"measurable_pi_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝ : (a : δ) → MeasurableSpace (π a)\na : δ\n⊢ Measurable fun f => f a","decl":"@[fun_prop, aesop safe 100 apply (rule_sets := [Measurable])]\ntheorem measurable_pi_apply (a : δ) : Measurable fun f : ∀ a, π a => f a :=\n  measurable_pi_iff.1 measurable_id a\n\n"}
{"name":"Measurable.eval","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nδ : Type u_4\nπ : δ → Type u_6\ninst✝¹ : MeasurableSpace α\ninst✝ : (a : δ) → MeasurableSpace (π a)\na : δ\ng : α → (a : δ) → π a\nhg : Measurable g\n⊢ Measurable fun x => g x a","decl":"@[aesop safe 100 apply (rule_sets := [Measurable])]\ntheorem Measurable.eval {a : δ} {g : α → ∀ a, π a} (hg : Measurable g) :\n    Measurable fun x => g x a :=\n  (measurable_pi_apply a).comp hg\n\n"}
{"name":"measurable_pi_lambda","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nδ : Type u_4\nπ : δ → Type u_6\ninst✝¹ : MeasurableSpace α\ninst✝ : (a : δ) → MeasurableSpace (π a)\nf : α → (a : δ) → π a\nhf : ∀ (a : δ), Measurable fun c => f c a\n⊢ Measurable f","decl":"@[fun_prop, aesop safe 100 apply (rule_sets := [Measurable])]\ntheorem measurable_pi_lambda (f : α → ∀ a, π a) (hf : ∀ a, Measurable fun c => f c a) :\n    Measurable f :=\n  measurable_pi_iff.mpr hf\n\n"}
{"name":"measurable_update'","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝¹ : (a : δ) → MeasurableSpace (π a)\na : δ\ninst✝ : DecidableEq δ\n⊢ Measurable fun p => Function.update p.1 a p.2","decl":"/-- The function `(f, x) ↦ update f a x : (Π a, π a) × π a → Π a, π a` is measurable. -/\ntheorem measurable_update'  {a : δ} [DecidableEq δ] :\n    Measurable (fun p : (∀ i, π i) × π a ↦ update p.1 a p.2) := by\n  rw [measurable_pi_iff]\n  intro j\n  dsimp [update]\n  split_ifs with h\n  · subst h\n    dsimp\n    exact measurable_snd\n  · exact measurable_pi_iff.1 measurable_fst _\n\n"}
{"name":"measurable_uniqueElim","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝¹ : (a : δ) → MeasurableSpace (π a)\ninst✝ : Unique δ\n⊢ Measurable uniqueElim","decl":"theorem measurable_uniqueElim [Unique δ] :\n    Measurable (uniqueElim : π (default : δ) → ∀ i, π i) := by\n  simp_rw [measurable_pi_iff, Unique.forall_iff, uniqueElim_default]; exact measurable_id\n\n"}
{"name":"measurable_updateFinset","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝¹ : (a : δ) → MeasurableSpace (π a)\ninst✝ : DecidableEq δ\ns : Finset δ\nx : (i : δ) → π i\n⊢ Measurable (Function.updateFinset x s)","decl":"theorem measurable_updateFinset [DecidableEq δ] {s : Finset δ} {x : ∀ i, π i} :\n    Measurable (updateFinset x s) := by\n  simp (config := { unfoldPartialApp := true }) only [updateFinset, measurable_pi_iff]\n  intro i\n  by_cases h : i ∈ s <;> simp [h, measurable_pi_apply]\n\n"}
{"name":"measurable_update","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝¹ : (a : δ) → MeasurableSpace (π a)\nf : (a : δ) → π a\na : δ\ninst✝ : DecidableEq δ\n⊢ Measurable (Function.update f a)","decl":"/-- The function `update f a : π a → Π a, π a` is always measurable.\n  This doesn't require `f` to be measurable.\n  This should not be confused with the statement that `update f a x` is measurable. -/\n@[measurability]\ntheorem measurable_update (f : ∀ a : δ, π a) {a : δ} [DecidableEq δ] : Measurable (update f a) :=\n  measurable_update'.comp measurable_prod_mk_left\n\n"}
{"name":"measurable_update_left","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝¹ : (a : δ) → MeasurableSpace (π a)\na : δ\ninst✝ : DecidableEq δ\nx : π a\n⊢ Measurable fun x_1 => Function.update x_1 a x","decl":"theorem measurable_update_left {a : δ} [DecidableEq δ] {x : π a} :\n    Measurable (update · a x) :=\n  measurable_update'.comp measurable_prod_mk_right\n\n"}
{"name":"Set.measurable_restrict","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝ : (a : δ) → MeasurableSpace (π a)\ns : Set δ\n⊢ Measurable s.restrict","decl":"@[measurability, fun_prop]\ntheorem Set.measurable_restrict (s : Set δ) : Measurable (s.restrict (π := π)) :=\n  measurable_pi_lambda _ fun _ ↦ measurable_pi_apply _\n\n"}
{"name":"Set.measurable_restrict₂","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝ : (a : δ) → MeasurableSpace (π a)\ns t : Set δ\nhst : HasSubset.Subset s t\n⊢ Measurable (Set.restrict₂ hst)","decl":"@[measurability, fun_prop]\ntheorem Set.measurable_restrict₂ {s t : Set δ} (hst : s ⊆ t) :\n    Measurable (restrict₂ (π := π) hst) :=\n  measurable_pi_lambda _ fun _ ↦ measurable_pi_apply _\n\n"}
{"name":"Finset.measurable_restrict","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝ : (a : δ) → MeasurableSpace (π a)\ns : Finset δ\n⊢ Measurable s.restrict","decl":"@[measurability, fun_prop]\ntheorem Finset.measurable_restrict (s : Finset δ) : Measurable (s.restrict (π := π)) :=\n  measurable_pi_lambda _ fun _ ↦ measurable_pi_apply _\n\n"}
{"name":"Finset.measurable_restrict₂","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝ : (a : δ) → MeasurableSpace (π a)\ns t : Finset δ\nhst : HasSubset.Subset s t\n⊢ Measurable (Finset.restrict₂ hst)","decl":"@[measurability, fun_prop]\ntheorem Finset.measurable_restrict₂ {s t : Finset δ} (hst : s ⊆ t) :\n    Measurable (Finset.restrict₂ (π := π) hst) :=\n  measurable_pi_lambda _ fun _ ↦ measurable_pi_apply _\n\n"}
{"name":"Set.measurable_restrict_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nγ : Type u_3\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace γ\ns : Set α\nf : α → γ\nhf : Measurable f\n⊢ Measurable (s.restrict f)","decl":"@[measurability, fun_prop]\ntheorem Set.measurable_restrict_apply (s : Set α) {f : α → γ} (hf : Measurable f) :\n    Measurable (s.restrict f) := hf.comp measurable_subtype_coe\n\n"}
{"name":"Set.measurable_restrict₂_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nγ : Type u_3\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace γ\ns t : Set α\nhst : HasSubset.Subset s t\nf : ↑t → γ\nhf : Measurable f\n⊢ Measurable (Set.restrict₂ hst f)","decl":"@[measurability, fun_prop]\ntheorem Set.measurable_restrict₂_apply {s t : Set α} (hst : s ⊆ t)\n    {f : t → γ} (hf : Measurable f) :\n    Measurable (restrict₂ (π := fun _ ↦ γ) hst f) := hf.comp (measurable_inclusion hst)\n\n"}
{"name":"Finset.measurable_restrict_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nγ : Type u_3\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace γ\ns : Finset α\nf : α → γ\nhf : Measurable f\n⊢ Measurable (s.restrict f)","decl":"@[measurability, fun_prop]\ntheorem Finset.measurable_restrict_apply (s : Finset α) {f : α → γ} (hf : Measurable f) :\n    Measurable (s.restrict f) := hf.comp measurable_subtype_coe\n\n"}
{"name":"Finset.measurable_restrict₂_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nγ : Type u_3\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace γ\ns t : Finset α\nhst : HasSubset.Subset s t\nf : (Subtype fun x => Membership.mem t x) → γ\nhf : Measurable f\n⊢ Measurable (Finset.restrict₂ hst f)","decl":"@[measurability, fun_prop]\ntheorem Finset.measurable_restrict₂_apply {s t : Finset α} (hst : s ⊆ t)\n    {f : t → γ} (hf : Measurable f) :\n    Measurable (restrict₂ (π := fun _ ↦ γ) hst f) := hf.comp (measurable_inclusion hst)\n\n"}
{"name":"measurable_eq_mp","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝ : (a : δ) → MeasurableSpace (π a)\ni i' : δ\nh : Eq i i'\n⊢ Measurable ⋯.mp","decl":"variable (π) in\ntheorem measurable_eq_mp {i i' : δ} (h : i = i') : Measurable (congr_arg π h).mp := by\n  cases h\n  exact measurable_id\n\n"}
{"name":"Measurable.eq_mp","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝¹ : (a : δ) → MeasurableSpace (π a)\nβ : Type u_7\ninst✝ : MeasurableSpace β\ni i' : δ\nh : Eq i i'\nf : β → π i\nhf : Measurable f\n⊢ Measurable fun x => ⋯.mp (f x)","decl":"variable (π) in\ntheorem Measurable.eq_mp {β} [MeasurableSpace β] {i i' : δ} (h : i = i') {f : β → π i}\n    (hf : Measurable f) : Measurable fun x => (congr_arg π h).mp (f x) :=\n  (measurable_eq_mp π h).comp hf\n\n"}
{"name":"measurable_piCongrLeft","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nδ' : Type u_5\nπ : δ → Type u_6\ninst✝ : (a : δ) → MeasurableSpace (π a)\nf : Equiv δ' δ\n⊢ Measurable ⇑(Equiv.piCongrLeft π f)","decl":"theorem measurable_piCongrLeft (f : δ' ≃ δ) : Measurable (piCongrLeft π f) := by\n  rw [measurable_pi_iff]\n  intro i\n  simp_rw [piCongrLeft_apply_eq_cast]\n  exact Measurable.eq_mp π (f.apply_symm_apply i) <| measurable_pi_apply <| f.symm i\n\n/- Even though we cannot use projection notation, we still keep a dot to be consistent with similar\n  lemmas, like `MeasurableSet.prod`. -/\n"}
{"name":"MeasurableSet.pi","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝ : (a : δ) → MeasurableSpace (π a)\ns : Set δ\nt : (i : δ) → Set (π i)\nhs : s.Countable\nht : ∀ (i : δ), Membership.mem s i → MeasurableSet (t i)\n⊢ MeasurableSet (s.pi t)","decl":"@[measurability]\nprotected theorem MeasurableSet.pi {s : Set δ} {t : ∀ i : δ, Set (π i)} (hs : s.Countable)\n    (ht : ∀ i ∈ s, MeasurableSet (t i)) : MeasurableSet (s.pi t) := by\n  rw [pi_def]\n  exact MeasurableSet.biInter hs fun i hi => measurable_pi_apply _ (ht i hi)\n\n"}
{"name":"MeasurableSet.univ_pi","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝¹ : (a : δ) → MeasurableSpace (π a)\ninst✝ : Countable δ\nt : (i : δ) → Set (π i)\nht : ∀ (i : δ), MeasurableSet (t i)\n⊢ MeasurableSet (Set.univ.pi t)","decl":"protected theorem MeasurableSet.univ_pi [Countable δ] {t : ∀ i : δ, Set (π i)}\n    (ht : ∀ i, MeasurableSet (t i)) : MeasurableSet (pi univ t) :=\n  MeasurableSet.pi (to_countable _) fun i _ => ht i\n\n"}
{"name":"measurableSet_pi_of_nonempty","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝ : (a : δ) → MeasurableSpace (π a)\ns : Set δ\nt : (i : δ) → Set (π i)\nhs : s.Countable\nh : (s.pi t).Nonempty\n⊢ Iff (MeasurableSet (s.pi t)) (∀ (i : δ), Membership.mem s i → MeasurableSet (t i))","decl":"theorem measurableSet_pi_of_nonempty {s : Set δ} {t : ∀ i, Set (π i)} (hs : s.Countable)\n    (h : (pi s t).Nonempty) : MeasurableSet (pi s t) ↔ ∀ i ∈ s, MeasurableSet (t i) := by\n  classical\n    rcases h with ⟨f, hf⟩\n    refine ⟨fun hst i hi => ?_, MeasurableSet.pi hs⟩\n    convert measurable_update f (a := i) hst\n    rw [update_preimage_pi hi]\n    exact fun j hj _ => hf j hj\n\n"}
{"name":"measurableSet_pi","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝ : (a : δ) → MeasurableSpace (π a)\ns : Set δ\nt : (i : δ) → Set (π i)\nhs : s.Countable\n⊢ Iff (MeasurableSet (s.pi t)) (Or (∀ (i : δ), Membership.mem s i → MeasurableSet (t i)) (Eq (s.pi t) EmptyCollection.emptyCollection))","decl":"theorem measurableSet_pi {s : Set δ} {t : ∀ i, Set (π i)} (hs : s.Countable) :\n    MeasurableSet (pi s t) ↔ (∀ i ∈ s, MeasurableSet (t i)) ∨ pi s t = ∅ := by\n  rcases (pi s t).eq_empty_or_nonempty with h | h\n  · simp [h]\n  · simp [measurableSet_pi_of_nonempty hs, h, ← not_nonempty_iff_eq_empty]\n\n"}
{"name":"Pi.instMeasurableSingletonClass","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝² : (a : δ) → MeasurableSpace (π a)\ninst✝¹ : Countable δ\ninst✝ : ∀ (a : δ), MeasurableSingletonClass (π a)\n⊢ MeasurableSingletonClass ((a : δ) → π a)","decl":"instance Pi.instMeasurableSingletonClass [Countable δ] [∀ a, MeasurableSingletonClass (π a)] :\n    MeasurableSingletonClass (∀ a, π a) :=\n  ⟨fun f => univ_pi_singleton f ▸ MeasurableSet.univ_pi fun t => measurableSet_singleton (f t)⟩\n\n"}
{"name":"measurable_piEquivPiSubtypeProd_symm","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝¹ : (a : δ) → MeasurableSpace (π a)\np : δ → Prop\ninst✝ : DecidablePred p\n⊢ Measurable ⇑(Equiv.piEquivPiSubtypeProd p π).symm","decl":"@[measurability]\ntheorem measurable_piEquivPiSubtypeProd_symm (p : δ → Prop) [DecidablePred p] :\n    Measurable (Equiv.piEquivPiSubtypeProd p π).symm := by\n  refine measurable_pi_iff.2 fun j => ?_\n  by_cases hj : p j\n  · simp only [hj, dif_pos, Equiv.piEquivPiSubtypeProd_symm_apply]\n    have : Measurable fun (f : ∀ i : { x // p x }, π i.1) => f ⟨j, hj⟩ :=\n      measurable_pi_apply (π := fun i : {x // p x} => π i.1) ⟨j, hj⟩\n    exact Measurable.comp this measurable_fst\n  · simp only [hj, Equiv.piEquivPiSubtypeProd_symm_apply, dif_neg, not_false_iff]\n    have : Measurable fun (f : ∀ i : { x // ¬p x }, π i.1) => f ⟨j, hj⟩ :=\n      measurable_pi_apply (π := fun i : {x // ¬p x} => π i.1) ⟨j, hj⟩\n    exact Measurable.comp this measurable_snd\n\n"}
{"name":"measurable_piEquivPiSubtypeProd","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝¹ : (a : δ) → MeasurableSpace (π a)\np : δ → Prop\ninst✝ : DecidablePred p\n⊢ Measurable ⇑(Equiv.piEquivPiSubtypeProd p π)","decl":"@[measurability]\ntheorem measurable_piEquivPiSubtypeProd (p : δ → Prop) [DecidablePred p] :\n    Measurable (Equiv.piEquivPiSubtypeProd p π) :=\n  (measurable_pi_iff.2 fun _ => measurable_pi_apply _).prod_mk\n    (measurable_pi_iff.2 fun _ => measurable_pi_apply _)\n\n"}
{"name":"measurable_tProd_mk","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝ : (x : δ) → MeasurableSpace (π x)\nl : List δ\n⊢ Measurable (List.TProd.mk l)","decl":"theorem measurable_tProd_mk (l : List δ) : Measurable (@TProd.mk δ π l) := by\n  induction' l with i l ih\n  · exact measurable_const\n  · exact (measurable_pi_apply i).prod_mk ih\n\n"}
{"name":"measurable_tProd_elim","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝¹ : (x : δ) → MeasurableSpace (π x)\ninst✝ : DecidableEq δ\nl : List δ\ni : δ\nhi : Membership.mem l i\n⊢ Measurable fun v => v.elim hi","decl":"theorem measurable_tProd_elim [DecidableEq δ] :\n    ∀ {l : List δ} {i : δ} (hi : i ∈ l), Measurable fun v : TProd π l => v.elim hi\n  | i::is, j, hj => by\n    by_cases hji : j = i\n    · subst hji\n      simpa using measurable_fst\n    · simp only [TProd.elim_of_ne _ hji]\n      rw [mem_cons] at hj\n      exact (measurable_tProd_elim (hj.resolve_left hji)).comp measurable_snd\n\n"}
{"name":"measurable_tProd_elim'","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝¹ : (x : δ) → MeasurableSpace (π x)\ninst✝ : DecidableEq δ\nl : List δ\nh : ∀ (i : δ), Membership.mem l i\n⊢ Measurable (List.TProd.elim' h)","decl":"theorem measurable_tProd_elim' [DecidableEq δ] {l : List δ} (h : ∀ i, i ∈ l) :\n    Measurable (TProd.elim' h : TProd π l → ∀ i, π i) :=\n  measurable_pi_lambda _ fun i => measurable_tProd_elim (h i)\n\n"}
{"name":"MeasurableSet.tProd","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"δ : Type u_4\nπ : δ → Type u_6\ninst✝ : (x : δ) → MeasurableSpace (π x)\nl : List δ\ns : (i : δ) → Set (π i)\nhs : ∀ (i : δ), MeasurableSet (s i)\n⊢ MeasurableSet (Set.tprod l s)","decl":"theorem MeasurableSet.tProd (l : List δ) {s : ∀ i, Set (π i)} (hs : ∀ i, MeasurableSet (s i)) :\n    MeasurableSet (Set.tprod l s) := by\n  induction' l with i l ih\n  · exact MeasurableSet.univ\n  · exact (hs i).prod ih\n\n"}
{"name":"measurable_inl","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\n⊢ Measurable Sum.inl","decl":"@[measurability]\ntheorem measurable_inl [MeasurableSpace α] [MeasurableSpace β] : Measurable (@Sum.inl α β) :=\n  Measurable.of_le_map inf_le_left\n\n"}
{"name":"measurable_inr","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\n⊢ Measurable Sum.inr","decl":"@[measurability]\ntheorem measurable_inr [MeasurableSpace α] [MeasurableSpace β] : Measurable (@Sum.inr α β) :=\n  Measurable.of_le_map inf_le_right\n\n"}
{"name":"measurableSet_sum_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ns : Set (Sum α β)\n⊢ Iff (MeasurableSet s) (And (MeasurableSet (Set.preimage Sum.inl s)) (MeasurableSet (Set.preimage Sum.inr s)))","decl":"theorem measurableSet_sum_iff {s : Set (α ⊕ β)} :\n    MeasurableSet s ↔ MeasurableSet (Sum.inl ⁻¹' s) ∧ MeasurableSet (Sum.inr ⁻¹' s) :=\n  Iff.rfl\n\n"}
{"name":"measurable_sum","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nx✝ : MeasurableSpace γ\nf : Sum α β → γ\nhl : Measurable (Function.comp f Sum.inl)\nhr : Measurable (Function.comp f Sum.inr)\n⊢ Measurable f","decl":"theorem measurable_sum {_ : MeasurableSpace γ} {f : α ⊕ β → γ} (hl : Measurable (f ∘ Sum.inl))\n    (hr : Measurable (f ∘ Sum.inr)) : Measurable f :=\n  Measurable.of_comap_le <|\n    le_inf (MeasurableSpace.comap_le_iff_le_map.2 <| hl)\n      (MeasurableSpace.comap_le_iff_le_map.2 <| hr)\n\n"}
{"name":"Measurable.sumElim","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nx✝ : MeasurableSpace γ\nf : α → γ\ng : β → γ\nhf : Measurable f\nhg : Measurable g\n⊢ Measurable (Sum.elim f g)","decl":"@[measurability]\ntheorem Measurable.sumElim {_ : MeasurableSpace γ} {f : α → γ} {g : β → γ} (hf : Measurable f)\n    (hg : Measurable g) : Measurable (Sum.elim f g) :=\n  measurable_sum hf hg\n\n"}
{"name":"Measurable.sumMap","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nx✝¹ : MeasurableSpace γ\nx✝ : MeasurableSpace δ\nf : α → β\ng : γ → δ\nhf : Measurable f\nhg : Measurable g\n⊢ Measurable (Sum.map f g)","decl":"theorem Measurable.sumMap {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {f : α → β} {g : γ → δ}\n    (hf : Measurable f) (hg : Measurable g) : Measurable (Sum.map f g) :=\n  (measurable_inl.comp hf).sumElim (measurable_inr.comp hg)\n\n"}
{"name":"measurableSet_inl_image","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ns : Set α\n⊢ Iff (MeasurableSet (Set.image Sum.inl s)) (MeasurableSet s)","decl":"@[simp] theorem measurableSet_inl_image {s : Set α} :\n    MeasurableSet (Sum.inl '' s : Set (α ⊕ β)) ↔ MeasurableSet s := by\n  simp [measurableSet_sum_iff, Sum.inl_injective.preimage_image]\n\n"}
{"name":"MeasurableSet.inl_image","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ns : Set α\na✝ : MeasurableSet s\n⊢ MeasurableSet (Set.image Sum.inl s)","decl":"alias ⟨_, MeasurableSet.inl_image⟩ := measurableSet_inl_image\n\n"}
{"name":"measurableSet_inr_image","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ns : Set β\n⊢ Iff (MeasurableSet (Set.image Sum.inr s)) (MeasurableSet s)","decl":"@[simp] theorem measurableSet_inr_image {s : Set β} :\n    MeasurableSet (Sum.inr '' s : Set (α ⊕ β)) ↔ MeasurableSet s := by\n  simp [measurableSet_sum_iff, Sum.inr_injective.preimage_image]\n\n"}
{"name":"MeasurableSet.inr_image","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ns : Set β\na✝ : MeasurableSet s\n⊢ MeasurableSet (Set.image Sum.inr s)","decl":"alias ⟨_, MeasurableSet.inr_image⟩ := measurableSet_inr_image\n\n"}
{"name":"measurableSet_range_inl","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmβ : MeasurableSpace β\ninst✝ : MeasurableSpace α\n⊢ MeasurableSet (Set.range Sum.inl)","decl":"theorem measurableSet_range_inl [MeasurableSpace α] :\n    MeasurableSet (range Sum.inl : Set (α ⊕ β)) := by\n  rw [← image_univ]\n  exact MeasurableSet.univ.inl_image\n\n"}
{"name":"measurableSet_range_inr","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmβ : MeasurableSpace β\ninst✝ : MeasurableSpace α\n⊢ MeasurableSet (Set.range Sum.inr)","decl":"theorem measurableSet_range_inr [MeasurableSpace α] :\n    MeasurableSet (range Sum.inr : Set (α ⊕ β)) := by\n  rw [← image_univ]\n  exact MeasurableSet.univ.inr_image\n\n"}
{"name":"measurableSet_setOf","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\np : α → Prop\n⊢ Iff (MeasurableSet (setOf fun a => p a)) (Measurable p)","decl":"@[simp] theorem measurableSet_setOf : MeasurableSet {a | p a} ↔ Measurable p :=\n  ⟨fun h ↦ measurable_to_prop <| by simpa only [preimage_singleton_true], fun h => by\n    simpa using h (measurableSet_singleton True)⟩\n\n"}
{"name":"measurable_mem","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : MeasurableSpace α\n⊢ Iff (Measurable fun x => Membership.mem s x) (MeasurableSet s)","decl":"@[simp] theorem measurable_mem : Measurable (· ∈ s) ↔ MeasurableSet s := measurableSet_setOf.symm\n\n"}
{"name":"Measurable.setOf","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\np : α → Prop\na✝ : Measurable p\n⊢ MeasurableSet (setOf fun a => p a)","decl":"alias ⟨_, Measurable.setOf⟩ := measurableSet_setOf\n\n"}
{"name":"MeasurableSet.mem","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : MeasurableSpace α\na✝ : MeasurableSet s\n⊢ Measurable fun x => Membership.mem s x","decl":"alias ⟨_, MeasurableSet.mem⟩ := measurable_mem\n\n"}
{"name":"Measurable.not","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\np : α → Prop\nhp : Measurable p\n⊢ Measurable fun x => Not (p x)","decl":"lemma Measurable.not (hp : Measurable p) : Measurable (¬ p ·) :=\n  measurableSet_setOf.1 hp.setOf.compl\n\n"}
{"name":"Measurable.and","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\np q : α → Prop\nhp : Measurable p\nhq : Measurable q\n⊢ Measurable fun a => And (p a) (q a)","decl":"lemma Measurable.and (hp : Measurable p) (hq : Measurable q) : Measurable fun a ↦ p a ∧ q a :=\n  measurableSet_setOf.1 <| hp.setOf.inter hq.setOf\n\n"}
{"name":"Measurable.or","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\np q : α → Prop\nhp : Measurable p\nhq : Measurable q\n⊢ Measurable fun a => Or (p a) (q a)","decl":"lemma Measurable.or (hp : Measurable p) (hq : Measurable q) : Measurable fun a ↦ p a ∨ q a :=\n  measurableSet_setOf.1 <| hp.setOf.union hq.setOf\n\n"}
{"name":"Measurable.imp","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\np q : α → Prop\nhp : Measurable p\nhq : Measurable q\n⊢ Measurable fun a => p a → q a","decl":"lemma Measurable.imp (hp : Measurable p) (hq : Measurable q) : Measurable fun a ↦ p a → q a :=\n  measurableSet_setOf.1 <| hp.setOf.himp hq.setOf\n\n"}
{"name":"Measurable.iff","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\np q : α → Prop\nhp : Measurable p\nhq : Measurable q\n⊢ Measurable fun a => Iff (p a) (q a)","decl":"lemma Measurable.iff (hp : Measurable p) (hq : Measurable q) : Measurable fun a ↦ p a ↔ q a :=\n  measurableSet_setOf.1 <| by simp_rw [iff_iff_implies_and_implies]; exact hq.setOf.bihimp hp.setOf\n\n"}
{"name":"Measurable.forall","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nι : Sort uι\ninst✝¹ : MeasurableSpace α\ninst✝ : Countable ι\np : ι → α → Prop\nhp : ∀ (i : ι), Measurable (p i)\n⊢ Measurable fun a => ∀ (i : ι), p i a","decl":"lemma Measurable.forall [Countable ι] {p : ι → α → Prop} (hp : ∀ i, Measurable (p i)) :\n    Measurable fun a ↦ ∀ i, p i a :=\n  measurableSet_setOf.1 <| by rw [setOf_forall]; exact MeasurableSet.iInter fun i ↦ (hp i).setOf\n\n"}
{"name":"Measurable.exists","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nι : Sort uι\ninst✝¹ : MeasurableSpace α\ninst✝ : Countable ι\np : ι → α → Prop\nhp : ∀ (i : ι), Measurable (p i)\n⊢ Measurable fun a => Exists fun i => p i a","decl":"lemma Measurable.exists [Countable ι] {p : ι → α → Prop} (hp : ∀ i, Measurable (p i)) :\n    Measurable fun a ↦ ∃ i, p i a :=\n  measurableSet_setOf.1 <| by rw [setOf_exists]; exact MeasurableSet.iUnion fun i ↦ (hp i).setOf\n\n"}
{"name":"Set.instMeasurableSingletonClass","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : Countable α\n⊢ MeasurableSingletonClass (Set α)","decl":"instance Set.instMeasurableSingletonClass [Countable α] : MeasurableSingletonClass (Set α) := by\n  unfold Set; infer_instance\n\n"}
{"name":"measurable_set_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace β\ng : β → Set α\n⊢ Iff (Measurable g) (∀ (a : α), Measurable fun x => Membership.mem (g x) a)","decl":"lemma measurable_set_iff : Measurable g ↔ ∀ a, Measurable fun x ↦ a ∈ g x := measurable_pi_iff\n\n"}
{"name":"measurable_set_mem","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\na : α\n⊢ Measurable fun s => Membership.mem s a","decl":"@[aesop safe 100 apply (rule_sets := [Measurable])]\nlemma measurable_set_mem (a : α) : Measurable fun s : Set α ↦ a ∈ s := measurable_pi_apply _\n\n"}
{"name":"measurable_set_not_mem","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\na : α\n⊢ Measurable fun s => Not (Membership.mem s a)","decl":"@[aesop safe 100 apply (rule_sets := [Measurable])]\nlemma measurable_set_not_mem (a : α) : Measurable fun s : Set α ↦ a ∉ s :=\n  (Measurable.of_discrete (f := Not)).comp <| measurable_set_mem a\n\n"}
{"name":"measurableSet_mem","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\na : α\n⊢ MeasurableSet (setOf fun s => Membership.mem s a)","decl":"@[aesop safe 100 apply (rule_sets := [Measurable])]\nlemma measurableSet_mem (a : α) : MeasurableSet {s : Set α | a ∈ s} :=\n  measurableSet_setOf.2 <| measurable_set_mem _\n\n"}
{"name":"measurableSet_not_mem","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\na : α\n⊢ MeasurableSet (setOf fun s => Not (Membership.mem s a))","decl":"@[aesop safe 100 apply (rule_sets := [Measurable])]\nlemma measurableSet_not_mem (a : α) : MeasurableSet {s : Set α | a ∉ s} :=\n  measurableSet_setOf.2 <| measurable_set_not_mem _\n\n"}
{"name":"measurable_compl","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\n⊢ Measurable fun x => HasCompl.compl x","decl":"lemma measurable_compl : Measurable ((·ᶜ) : Set α → Set α) :=\n  measurable_set_iff.2 fun _ ↦ measurable_set_not_mem _\n\n"}
{"name":"MeasurableSet.setOf_finite","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : Countable α\n⊢ MeasurableSet (setOf fun s => s.Finite)","decl":"lemma MeasurableSet.setOf_finite [Countable α] : MeasurableSet {s : Set α | s.Finite} :=\n  Countable.setOf_finite.measurableSet\n\n"}
{"name":"MeasurableSet.setOf_infinite","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : Countable α\n⊢ MeasurableSet (setOf fun s => s.Infinite)","decl":"lemma MeasurableSet.setOf_infinite [Countable α] : MeasurableSet {s : Set α | s.Infinite} :=\n  .setOf_finite |> .compl\n\n"}
{"name":"MeasurableSet.sep_finite","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : Countable α\nS : Set (Set α)\nhS : MeasurableSet S\n⊢ MeasurableSet (setOf fun s => And (Membership.mem S s) s.Finite)","decl":"lemma MeasurableSet.sep_finite [Countable α] {S : Set (Set α)} (hS : MeasurableSet S) :\n    MeasurableSet {s ∈ S | s.Finite} :=\n  hS.inter .setOf_finite\n\n"}
{"name":"MeasurableSet.sep_infinite","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : Countable α\nS : Set (Set α)\nhS : MeasurableSet S\n⊢ MeasurableSet (setOf fun s => And (Membership.mem S s) s.Infinite)","decl":"lemma MeasurableSet.sep_infinite [Countable α] {S : Set (Set α)} (hS : MeasurableSet S) :\n    MeasurableSet {s ∈ S | s.Infinite} :=\n  hS.inter .setOf_infinite\n\n"}
{"name":"MeasurableSpace.generateFrom_singleton","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (MeasurableSpace.generateFrom (Singleton.singleton s)) (MeasurableSpace.comap (fun x => Membership.mem s x) Top.top)","decl":"/-- The sigma-algebra generated by a single set `s` is `{∅, s, sᶜ, univ}`. -/\n@[simp] theorem generateFrom_singleton (s : Set α) :\n    generateFrom {s} = MeasurableSpace.comap (· ∈ s) ⊤ := by\n  classical\n  letI : MeasurableSpace α := generateFrom {s}\n  refine le_antisymm (generateFrom_le fun t ht => ⟨{True}, trivial, by simp [ht.symm]⟩) ?_\n  rintro _ ⟨u, -, rfl⟩\n  exact (show MeasurableSet s from GenerateMeasurable.basic _ <| mem_singleton s).mem trivial\n\n"}
{"name":"MeasurableSpace.generateFrom_singleton_le","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : Set α\nhs : MeasurableSet s\n⊢ LE.le (MeasurableSpace.generateFrom (Singleton.singleton s)) m","decl":"lemma generateFrom_singleton_le {m : MeasurableSpace α} {s : Set α} (hs : MeasurableSet s) :\n    MeasurableSpace.generateFrom {s} ≤ m :=\n  generateFrom_le (fun _ ht ↦ mem_singleton_iff.1 ht ▸ hs)\n\n"}
{"name":"MeasureTheory.measurableSet_generateFrom_singleton_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Iff (MeasurableSet t) (Or (Eq t EmptyCollection.emptyCollection) (Or (Eq t s) (Or (Eq t (HasCompl.compl s)) (Eq t Set.univ))))","decl":"theorem measurableSet_generateFrom_singleton_iff {s t : Set α} :\n    MeasurableSet[MeasurableSpace.generateFrom {s}] t ↔ t = ∅ ∨ t = s ∨ t = sᶜ ∨ t = univ := by\n  simp_rw [MeasurableSpace.generateFrom_singleton]\n  change t ∈ {t | _} ↔ _\n  simp_rw [MeasurableSpace.measurableSet_top, true_and, mem_setOf_eq]\n  constructor\n  · rintro ⟨x, rfl⟩\n    by_cases hT : True ∈ x\n    · by_cases hF : False ∈ x\n      · refine Or.inr <| Or.inr <| Or.inr <| subset_antisymm (subset_univ _) ?_\n        suffices x = univ by simp only [this, preimage_univ, subset_refl]\n        refine subset_antisymm (subset_univ _) ?_\n        rw [univ_eq_true_false]\n        rintro - (rfl | rfl)\n        · assumption\n        · assumption\n      · have hx : x = {True} := by\n          ext p\n          refine ⟨fun hp ↦ mem_singleton_iff.2 ?_, fun hp ↦ hp ▸ hT⟩\n          by_contra hpneg\n          rw [eq_iff_iff, iff_true, ← false_iff] at hpneg\n          exact hF (by convert hp)\n        simp [hx]\n    · by_cases hF : False ∈ x\n      · have hx : x = {False} := by\n          ext p\n          refine ⟨fun hp ↦ mem_singleton_iff.2 ?_, fun hp ↦ hp ▸ hF⟩\n          by_contra hpneg\n          simp only [eq_iff_iff, iff_false, not_not] at hpneg\n          refine hT ?_\n          convert hp\n          simpa\n        refine Or.inr <| Or.inr <| Or.inl <| ?_\n        simp [hx]\n        rfl\n      · refine Or.inl <| subset_antisymm ?_ <| empty_subset _\n        suffices x ⊆ ∅ by\n          rw [subset_empty_iff] at this\n          simp only [this, preimage_empty, subset_refl]\n        intro p hp\n        fin_cases p\n        · contradiction\n        · contradiction\n  · rintro (rfl | rfl | rfl | rfl)\n    on_goal 1 => use ∅\n    on_goal 2 => use {True}\n    on_goal 3 => use {False}\n    on_goal 4 => use Set.univ\n    all_goals\n      simp [compl_def]\n\n"}
{"name":"Filter.IsMeasurablyGenerated.exists_measurable_subset","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : Filter α\nself : f.IsMeasurablyGenerated\ns : Set α\na✝ : Membership.mem f s\n⊢ Exists fun t => And (Membership.mem f t) (And (MeasurableSet t) (HasSubset.Subset t s))","decl":"/-- A filter `f` is measurably generates if each `s ∈ f` includes a measurable `t ∈ f`. -/\nclass IsMeasurablyGenerated (f : Filter α) : Prop where\n  exists_measurable_subset : ∀ ⦃s⦄, s ∈ f → ∃ t ∈ f, MeasurableSet t ∧ t ⊆ s\n\n"}
{"name":"Filter.isMeasurablyGenerated_bot","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Bot.bot.IsMeasurablyGenerated","decl":"instance isMeasurablyGenerated_bot : IsMeasurablyGenerated (⊥ : Filter α) :=\n  ⟨fun _ _ => ⟨∅, mem_bot, MeasurableSet.empty, empty_subset _⟩⟩\n\n"}
{"name":"Filter.isMeasurablyGenerated_top","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Top.top.IsMeasurablyGenerated","decl":"instance isMeasurablyGenerated_top : IsMeasurablyGenerated (⊤ : Filter α) :=\n  ⟨fun _s hs => ⟨univ, univ_mem, MeasurableSet.univ, fun x _ => hs x⟩⟩\n\n"}
{"name":"Filter.Eventually.exists_measurable_mem","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\nf : Filter α\ninst✝ : f.IsMeasurablyGenerated\np : α → Prop\nh : Filter.Eventually (fun x => p x) f\n⊢ Exists fun s => And (Membership.mem f s) (And (MeasurableSet s) (∀ (x : α), Membership.mem s x → p x))","decl":"theorem Eventually.exists_measurable_mem {f : Filter α} [IsMeasurablyGenerated f] {p : α → Prop}\n    (h : ∀ᶠ x in f, p x) : ∃ s ∈ f, MeasurableSet s ∧ ∀ x ∈ s, p x :=\n  IsMeasurablyGenerated.exists_measurable_subset h\n\n"}
{"name":"Filter.Eventually.exists_measurable_mem_of_smallSets","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\nf : Filter α\ninst✝ : f.IsMeasurablyGenerated\np : Set α → Prop\nh : Filter.Eventually (fun s => p s) f.smallSets\n⊢ Exists fun s => And (Membership.mem f s) (And (MeasurableSet s) (p s))","decl":"theorem Eventually.exists_measurable_mem_of_smallSets {f : Filter α} [IsMeasurablyGenerated f]\n    {p : Set α → Prop} (h : ∀ᶠ s in f.smallSets, p s) : ∃ s ∈ f, MeasurableSet s ∧ p s :=\n  let ⟨_s, hsf, hs⟩ := eventually_smallSets.1 h\n  let ⟨t, htf, htm, hts⟩ := IsMeasurablyGenerated.exists_measurable_subset hsf\n  ⟨t, htf, htm, hs t hts⟩\n\n"}
{"name":"Filter.inf_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\nf g : Filter α\ninst✝¹ : f.IsMeasurablyGenerated\ninst✝ : g.IsMeasurablyGenerated\n⊢ (Min.min f g).IsMeasurablyGenerated","decl":"instance inf_isMeasurablyGenerated (f g : Filter α) [IsMeasurablyGenerated f]\n    [IsMeasurablyGenerated g] : IsMeasurablyGenerated (f ⊓ g) := by\n  constructor\n  rintro t ⟨sf, hsf, sg, hsg, rfl⟩\n  rcases IsMeasurablyGenerated.exists_measurable_subset hsf with ⟨s'f, hs'f, hmf, hs'sf⟩\n  rcases IsMeasurablyGenerated.exists_measurable_subset hsg with ⟨s'g, hs'g, hmg, hs'sg⟩\n  refine ⟨s'f ∩ s'g, inter_mem_inf hs'f hs'g, hmf.inter hmg, ?_⟩\n  exact inter_subset_inter hs'sf hs'sg\n\n"}
{"name":"Filter.principal_isMeasurablyGenerated_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : Set α\n⊢ Iff (Filter.principal s).IsMeasurablyGenerated (MeasurableSet s)","decl":"theorem principal_isMeasurablyGenerated_iff {s : Set α} :\n    IsMeasurablyGenerated (𝓟 s) ↔ MeasurableSet s := by\n  refine ⟨?_, fun hs => ⟨fun t ht => ⟨s, mem_principal_self s, hs, ht⟩⟩⟩\n  rintro ⟨hs⟩\n  rcases hs (mem_principal_self s) with ⟨t, ht, htm, hts⟩\n  have : t = s := hts.antisymm ht\n  rwa [← this]\n\n"}
{"name":"MeasurableSet.principal_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : Set α\na✝ : MeasurableSet s\n⊢ (Filter.principal s).IsMeasurablyGenerated","decl":"alias ⟨_, _root_.MeasurableSet.principal_isMeasurablyGenerated⟩ :=\n  principal_isMeasurablyGenerated_iff\n\n"}
{"name":"Filter.iInf_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nι : Sort uι\ninst✝¹ : MeasurableSpace α\nf : ι → Filter α\ninst✝ : ∀ (i : ι), (f i).IsMeasurablyGenerated\n⊢ (iInf fun i => f i).IsMeasurablyGenerated","decl":"instance iInf_isMeasurablyGenerated {f : ι → Filter α} [∀ i, IsMeasurablyGenerated (f i)] :\n    IsMeasurablyGenerated (⨅ i, f i) := by\n  refine ⟨fun s hs => ?_⟩\n  rw [← Equiv.plift.surjective.iInf_comp, mem_iInf] at hs\n  rcases hs with ⟨t, ht, ⟨V, hVf, rfl⟩⟩\n  choose U hUf hU using fun i => IsMeasurablyGenerated.exists_measurable_subset (hVf i)\n  refine ⟨⋂ i : t, U i, ?_, ?_, ?_⟩\n  · rw [← Equiv.plift.surjective.iInf_comp, mem_iInf]\n    exact ⟨t, ht, U, hUf, rfl⟩\n  · haveI := ht.countable.toEncodable.countable\n    exact MeasurableSet.iInter fun i => (hU i).1\n  · exact iInter_mono fun i => (hU i).2\n\n"}
{"name":"measurableSet_tendsto","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"β : Type u_2\nγ : Type u_3\nδ : Type u_4\nx✝ : MeasurableSpace β\ninst✝³ : MeasurableSpace γ\ninst✝² : Countable δ\nl : Filter δ\ninst✝¹ : l.IsCountablyGenerated\nl' : Filter γ\ninst✝ : l'.IsCountablyGenerated\nhl' : l'.IsMeasurablyGenerated\nf : δ → β → γ\nhf : ∀ (i : δ), Measurable (f i)\n⊢ MeasurableSet (setOf fun x => Filter.Tendsto (fun n => f n x) l l')","decl":"/-- The set of points for which a sequence of measurable functions converges to a given value\nis measurable. -/\n@[measurability]\nlemma measurableSet_tendsto {_ : MeasurableSpace β} [MeasurableSpace γ]\n    [Countable δ] {l : Filter δ} [l.IsCountablyGenerated]\n    (l' : Filter γ) [l'.IsCountablyGenerated] [hl' : l'.IsMeasurablyGenerated]\n    {f : δ → β → γ} (hf : ∀ i, Measurable (f i)) :\n    MeasurableSet { x | Tendsto (fun n ↦ f n x) l l' } := by\n  rcases l.exists_antitone_basis with ⟨u, hu⟩\n  rcases (Filter.hasBasis_self.mpr hl'.exists_measurable_subset).exists_antitone_subbasis with\n    ⟨v, v_meas, hv⟩\n  simp only [hu.tendsto_iff hv.toHasBasis, true_imp_iff, true_and, setOf_forall, setOf_exists]\n  exact .iInter fun n ↦ .iUnion fun _ ↦ .biInter (to_countable _) fun i _ ↦\n    (v_meas n).2.preimage (hf i)\n\n"}
{"name":"isCountablySpanning_measurableSet","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ IsCountablySpanning (setOf fun s => MeasurableSet s)","decl":"theorem isCountablySpanning_measurableSet [MeasurableSpace α] :\n    IsCountablySpanning { s : Set α | MeasurableSet s } :=\n  ⟨fun _ => univ, fun _ => MeasurableSet.univ, iUnion_const _⟩\n\n"}
{"name":"IsCountablySpanning.prod","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nC : Set (Set α)\nD : Set (Set β)\nhC : IsCountablySpanning C\nhD : IsCountablySpanning D\n⊢ IsCountablySpanning (Set.image2 (fun x1 x2 => SProd.sprod x1 x2) C D)","decl":"/-- Rectangles of countably spanning sets are countably spanning. -/\nlemma IsCountablySpanning.prod {C : Set (Set α)} {D : Set (Set β)} (hC : IsCountablySpanning C)\n    (hD : IsCountablySpanning D) : IsCountablySpanning (image2 (· ×ˢ ·) C D) := by\n  rcases hC, hD with ⟨⟨s, h1s, h2s⟩, t, h1t, h2t⟩\n  refine ⟨fun n => s n.unpair.1 ×ˢ t n.unpair.2, fun n => mem_image2_of_mem (h1s _) (h1t _), ?_⟩\n  rw [iUnion_unpair_prod, h2s, h2t, univ_prod_univ]\n\n"}
{"name":"MeasurableSet.iUnion_of_monotone_of_frequently","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\nι : Type u_6\ninst✝¹ : Preorder ι\ninst✝ : Filter.atTop.IsCountablyGenerated\ns : ι → Set α\nhsm : Monotone s\nhs : Filter.Frequently (fun i => MeasurableSet (s i)) Filter.atTop\n⊢ MeasurableSet (Set.iUnion fun i => s i)","decl":"protected theorem iUnion_of_monotone_of_frequently\n    {ι : Type*} [Preorder ι] [(atTop : Filter ι).IsCountablyGenerated] {s : ι → Set α}\n    (hsm : Monotone s) (hs : ∃ᶠ i in atTop, MeasurableSet (s i)) : MeasurableSet (⋃ i, s i) := by\n  rcases exists_seq_forall_of_frequently hs with ⟨x, hx, hxm⟩\n  rw [← hsm.iUnion_comp_tendsto_atTop hx]\n  exact .iUnion hxm\n\n"}
{"name":"MeasurableSet.iInter_of_antitone_of_frequently","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\nι : Type u_6\ninst✝¹ : Preorder ι\ninst✝ : Filter.atTop.IsCountablyGenerated\ns : ι → Set α\nhsm : Antitone s\nhs : Filter.Frequently (fun i => MeasurableSet (s i)) Filter.atTop\n⊢ MeasurableSet (Set.iInter fun i => s i)","decl":"protected theorem iInter_of_antitone_of_frequently\n    {ι : Type*} [Preorder ι] [(atTop : Filter ι).IsCountablyGenerated] {s : ι → Set α}\n    (hsm : Antitone s) (hs : ∃ᶠ i in atTop, MeasurableSet (s i)) : MeasurableSet (⋂ i, s i) := by\n  rw [← compl_iff, compl_iInter]\n  exact .iUnion_of_monotone_of_frequently (compl_anti.comp hsm) <| hs.mono fun _ ↦ .compl\n\n"}
{"name":"MeasurableSet.iUnion_of_monotone","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝³ : MeasurableSpace α\nι : Type u_6\ninst✝² : Preorder ι\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝ : Filter.atTop.IsCountablyGenerated\ns : ι → Set α\nhsm : Monotone s\nhs : ∀ (i : ι), MeasurableSet (s i)\n⊢ MeasurableSet (Set.iUnion fun i => s i)","decl":"protected theorem iUnion_of_monotone {ι : Type*} [Preorder ι] [IsDirected ι (· ≤ ·)]\n    [(atTop : Filter ι).IsCountablyGenerated] {s : ι → Set α}\n    (hsm : Monotone s) (hs : ∀ i, MeasurableSet (s i)) : MeasurableSet (⋃ i, s i) := by\n  cases isEmpty_or_nonempty ι with\n  | inl _ => simp\n  | inr _ => exact .iUnion_of_monotone_of_frequently hsm <| .of_forall hs\n\n"}
{"name":"MeasurableSet.iInter_of_antitone","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝³ : MeasurableSpace α\nι : Type u_6\ninst✝² : Preorder ι\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝ : Filter.atTop.IsCountablyGenerated\ns : ι → Set α\nhsm : Antitone s\nhs : ∀ (i : ι), MeasurableSet (s i)\n⊢ MeasurableSet (Set.iInter fun i => s i)","decl":"protected theorem iInter_of_antitone {ι : Type*} [Preorder ι] [IsDirected ι (· ≤ ·)]\n    [(atTop : Filter ι).IsCountablyGenerated] {s : ι → Set α}\n    (hsm : Antitone s) (hs : ∀ i, MeasurableSet (s i)) : MeasurableSet (⋂ i, s i) := by\n  rw [← compl_iff, compl_iInter]\n  exact .iUnion_of_monotone (compl_anti.comp hsm) fun i ↦ (hs i).compl\n\n"}
{"name":"MeasurableSet.mem_coe","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\na : α\ns : Subtype MeasurableSet\n⊢ Iff (Membership.mem (↑s) a) (Membership.mem s a)","decl":"@[simp]\ntheorem mem_coe (a : α) (s : Subtype (MeasurableSet : Set α → Prop)) : a ∈ (s : Set α) ↔ a ∈ s :=\n  Iff.rfl\n\n"}
{"name":"MeasurableSet.coe_empty","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Eq (↑EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem coe_empty : ↑(∅ : Subtype (MeasurableSet : Set α → Prop)) = (∅ : Set α) :=\n  rfl\n\n"}
{"name":"MeasurableSet.coe_insert","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSingletonClass α\na : α\ns : Subtype MeasurableSet\n⊢ Eq (↑(Insert.insert a s)) (Insert.insert a ↑s)","decl":"@[simp]\ntheorem coe_insert [MeasurableSingletonClass α] (a : α)\n    (s : Subtype (MeasurableSet : Set α → Prop)) :\n    ↑(Insert.insert a s) = (Insert.insert a s : Set α) :=\n  rfl\n\n"}
{"name":"MeasurableSet.coe_singleton","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSingletonClass α\na : α\n⊢ Eq (↑(Singleton.singleton a)) (Singleton.singleton a)","decl":"@[simp] theorem coe_singleton [MeasurableSingletonClass α] (a : α) :\n    ↑({a} : Subtype (MeasurableSet : Set α → Prop)) = ({a} : Set α) :=\n  rfl\n\n"}
{"name":"MeasurableSet.Subtype.instLawfulSingleton","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSingletonClass α\n⊢ LawfulSingleton α (Subtype MeasurableSet)","decl":"instance Subtype.instLawfulSingleton [MeasurableSingletonClass α] :\n    LawfulSingleton α (Subtype (MeasurableSet : Set α → Prop)) :=\n  ⟨fun _ => Subtype.eq <| insert_emptyc_eq _⟩\n\n"}
{"name":"MeasurableSet.coe_compl","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : Subtype MeasurableSet\n⊢ Eq (↑(HasCompl.compl s)) (HasCompl.compl ↑s)","decl":"@[simp]\ntheorem coe_compl (s : Subtype (MeasurableSet : Set α → Prop)) : ↑sᶜ = (sᶜ : Set α) :=\n  rfl\n\n"}
{"name":"MeasurableSet.coe_union","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns t : Subtype MeasurableSet\n⊢ Eq (↑(Union.union s t)) (Union.union ↑s ↑t)","decl":"@[simp]\ntheorem coe_union (s t : Subtype (MeasurableSet : Set α → Prop)) : ↑(s ∪ t) = (s ∪ t : Set α) :=\n  rfl\n\n"}
{"name":"MeasurableSet.sup_eq_union","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns t : Subtype fun s => MeasurableSet s\n⊢ Eq (Max.max s t) (Union.union s t)","decl":"@[simp]\nprotected theorem sup_eq_union (s t : {s : Set α // MeasurableSet s}) : s ⊔ t = s ∪ t := rfl\n\n"}
{"name":"MeasurableSet.coe_inter","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns t : Subtype MeasurableSet\n⊢ Eq (↑(Inter.inter s t)) (Inter.inter ↑s ↑t)","decl":"@[simp]\ntheorem coe_inter (s t : Subtype (MeasurableSet : Set α → Prop)) : ↑(s ∩ t) = (s ∩ t : Set α) :=\n  rfl\n\n"}
{"name":"MeasurableSet.inf_eq_inter","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns t : Subtype fun s => MeasurableSet s\n⊢ Eq (Min.min s t) (Inter.inter s t)","decl":"@[simp]\nprotected theorem inf_eq_inter (s t : {s : Set α // MeasurableSet s}) : s ⊓ t = s ∩ t := rfl\n\n"}
{"name":"MeasurableSet.coe_sdiff","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns t : Subtype MeasurableSet\n⊢ Eq (↑(SDiff.sdiff s t)) (SDiff.sdiff ↑s ↑t)","decl":"@[simp]\ntheorem coe_sdiff (s t : Subtype (MeasurableSet : Set α → Prop)) : ↑(s \\ t) = (s : Set α) \\ t :=\n  rfl\n\n"}
{"name":"MeasurableSet.coe_himp","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns t : Subtype MeasurableSet\n⊢ Eq (↑(HImp.himp s t)) (HImp.himp ↑s ↑t)","decl":"@[simp]\nlemma coe_himp (s t : Subtype (MeasurableSet : Set α → Prop)) : ↑(s ⇨ t) = (s ⇨ t : Set α) := rfl\n\n"}
{"name":"MeasurableSet.coe_bot","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Eq (↑Bot.bot) Bot.bot","decl":"@[simp]\ntheorem coe_bot : ↑(⊥ : Subtype (MeasurableSet : Set α → Prop)) = (⊥ : Set α) :=\n  rfl\n\n"}
{"name":"MeasurableSet.coe_top","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Eq (↑Top.top) Top.top","decl":"@[simp]\ntheorem coe_top : ↑(⊤ : Subtype (MeasurableSet : Set α → Prop)) = (⊤ : Set α) :=\n  rfl\n\n"}
{"name":"MeasurableSet.measurableSet_blimsup","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : Nat → Set α\np : Nat → Prop\nh : ∀ (n : Nat), p n → MeasurableSet (s n)\n⊢ MeasurableSet (Filter.blimsup s Filter.atTop p)","decl":"@[measurability]\ntheorem measurableSet_blimsup {s : ℕ → Set α} {p : ℕ → Prop} (h : ∀ n, p n → MeasurableSet (s n)) :\n    MeasurableSet <| blimsup s atTop p := by\n  simp only [blimsup_eq_iInf_biSup_of_nat, iSup_eq_iUnion, iInf_eq_iInter]\n  exact .iInter fun _ => .iUnion fun m => .iUnion fun hm => h m hm.1\n\n"}
{"name":"MeasurableSet.measurableSet_bliminf","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : Nat → Set α\np : Nat → Prop\nh : ∀ (n : Nat), p n → MeasurableSet (s n)\n⊢ MeasurableSet (Filter.bliminf s Filter.atTop p)","decl":"@[measurability]\ntheorem measurableSet_bliminf {s : ℕ → Set α} {p : ℕ → Prop} (h : ∀ n, p n → MeasurableSet (s n)) :\n    MeasurableSet <| Filter.bliminf s Filter.atTop p := by\n  simp only [Filter.bliminf_eq_iSup_biInf_of_nat, iInf_eq_iInter, iSup_eq_iUnion]\n  exact .iUnion fun n => .iInter fun m => .iInter fun hm => h m hm.1\n\n"}
{"name":"MeasurableSet.measurableSet_limsup","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : Nat → Set α\nhs : ∀ (n : Nat), MeasurableSet (s n)\n⊢ MeasurableSet (Filter.limsup s Filter.atTop)","decl":"@[measurability]\ntheorem measurableSet_limsup {s : ℕ → Set α} (hs : ∀ n, MeasurableSet <| s n) :\n    MeasurableSet <| Filter.limsup s Filter.atTop := by\n  simpa only [← blimsup_true] using measurableSet_blimsup fun n _ => hs n\n\n"}
{"name":"MeasurableSet.measurableSet_liminf","module":"Mathlib.MeasureTheory.MeasurableSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : Nat → Set α\nhs : ∀ (n : Nat), MeasurableSet (s n)\n⊢ MeasurableSet (Filter.liminf s Filter.atTop)","decl":"@[measurability]\ntheorem measurableSet_liminf {s : ℕ → Set α} (hs : ∀ n, MeasurableSet <| s n) :\n    MeasurableSet <| Filter.liminf s Filter.atTop := by\n  simpa only [← bliminf_true] using measurableSet_bliminf fun n _ => hs n\n\n"}
