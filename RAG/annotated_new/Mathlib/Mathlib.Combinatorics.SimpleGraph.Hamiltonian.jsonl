{"name":"SimpleGraph.Walk.IsHamiltonian.map","module":"Mathlib.Combinatorics.SimpleGraph.Hamiltonian","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nG : SimpleGraph α\na b : α\np : G.Walk a b\nH : SimpleGraph β\nf : G.Hom H\nhf : Function.Bijective ⇑f\nhp : p.IsHamiltonian\n⊢ (SimpleGraph.Walk.map f p).IsHamiltonian","decl":"lemma IsHamiltonian.map {H : SimpleGraph β} (f : G →g H) (hf : Bijective f) (hp : p.IsHamiltonian) :\n    (p.map f).IsHamiltonian := by\n  simp [IsHamiltonian, hf.surjective.forall, hf.injective, hp _]\n\n"}
{"name":"SimpleGraph.Walk.IsHamiltonian.mem_support","module":"Mathlib.Combinatorics.SimpleGraph.Hamiltonian","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nG : SimpleGraph α\na b : α\np : G.Walk a b\nhp : p.IsHamiltonian\nc : α\n⊢ Membership.mem p.support c","decl":"/-- A hamiltonian path visits every vertex. -/\n@[simp] lemma IsHamiltonian.mem_support (hp : p.IsHamiltonian) (c : α) : c ∈ p.support := by\n  simp only [← List.count_pos_iff, hp _, Nat.zero_lt_one]\n\n"}
{"name":"SimpleGraph.Walk.IsHamiltonian.isPath","module":"Mathlib.Combinatorics.SimpleGraph.Hamiltonian","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nG : SimpleGraph α\na b : α\np : G.Walk a b\nhp : p.IsHamiltonian\n⊢ p.IsPath","decl":"/-- Hamiltonian paths are paths. -/\nlemma IsHamiltonian.isPath (hp : p.IsHamiltonian) : p.IsPath :=\n  IsPath.mk' <| List.nodup_iff_count_le_one.2 <| (le_of_eq <| hp ·)\n\n"}
{"name":"SimpleGraph.Walk.IsPath.isHamiltonian_of_mem","module":"Mathlib.Combinatorics.SimpleGraph.Hamiltonian","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nG : SimpleGraph α\na b : α\np : G.Walk a b\nhp : p.IsPath\nhp' : ∀ (w : α), Membership.mem p.support w\n⊢ p.IsHamiltonian","decl":"/-- A path whose support contains every vertex is hamiltonian. -/\nlemma IsPath.isHamiltonian_of_mem (hp : p.IsPath) (hp' : ∀ w, w ∈ p.support) :\n    p.IsHamiltonian := fun _ ↦\n  le_antisymm (List.nodup_iff_count_le_one.1 hp.support_nodup _) (List.count_pos_iff.2 (hp' _))\n\n"}
{"name":"SimpleGraph.Walk.IsPath.isHamiltonian_iff","module":"Mathlib.Combinatorics.SimpleGraph.Hamiltonian","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nG : SimpleGraph α\na b : α\np : G.Walk a b\nhp : p.IsPath\n⊢ Iff p.IsHamiltonian (∀ (w : α), Membership.mem p.support w)","decl":"lemma IsPath.isHamiltonian_iff (hp : p.IsPath) : p.IsHamiltonian ↔ ∀ w, w ∈ p.support :=\n  ⟨(·.mem_support), hp.isHamiltonian_of_mem⟩\n\n"}
{"name":"SimpleGraph.Walk.IsHamiltonian.support_toFinset","module":"Mathlib.Combinatorics.SimpleGraph.Hamiltonian","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\nG : SimpleGraph α\na b : α\np : G.Walk a b\ninst✝ : Fintype α\nhp : p.IsHamiltonian\n⊢ Eq p.support.toFinset Finset.univ","decl":"/-- The support of a hamiltonian walk is the entire vertex set. -/\nlemma IsHamiltonian.support_toFinset (hp : p.IsHamiltonian) : p.support.toFinset = Finset.univ := by\n  simp [eq_univ_iff_forall, hp]\n\n"}
{"name":"SimpleGraph.Walk.IsHamiltonian.length_eq","module":"Mathlib.Combinatorics.SimpleGraph.Hamiltonian","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\nG : SimpleGraph α\na b : α\np : G.Walk a b\ninst✝ : Fintype α\nhp : p.IsHamiltonian\n⊢ Eq p.length (HSub.hSub (Fintype.card α) 1)","decl":"/-- The length of a hamiltonian path is one less than the number of vertices of the graph. -/\nlemma IsHamiltonian.length_eq (hp : p.IsHamiltonian) : p.length = Fintype.card α - 1 :=\n  eq_tsub_of_add_eq <| by\n    rw [← length_support, ← List.sum_toFinset_count_eq_length, Finset.sum_congr rfl fun _ _ ↦ hp _,\n      ← card_eq_sum_ones, hp.support_toFinset, card_univ]\n\n"}
{"name":"SimpleGraph.Walk.IsHamiltonianCycle.isHamiltonian_tail","module":"Mathlib.Combinatorics.SimpleGraph.Hamiltonian","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nG : SimpleGraph α\na : α\np : G.Walk a a\nself : p.IsHamiltonianCycle\n⊢ p.tail.IsHamiltonian","decl":"/-- A hamiltonian cycle is a cycle that visits every vertex once. -/\nstructure IsHamiltonianCycle (p : G.Walk a a) extends p.IsCycle : Prop where\n  isHamiltonian_tail : p.tail.IsHamiltonian\n\n"}
{"name":"SimpleGraph.Walk.IsHamiltonianCycle.toIsCycle","module":"Mathlib.Combinatorics.SimpleGraph.Hamiltonian","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nG : SimpleGraph α\na : α\np : G.Walk a a\nself : p.IsHamiltonianCycle\n⊢ p.IsCycle","decl":"/-- A hamiltonian cycle is a cycle that visits every vertex once. -/\nstructure IsHamiltonianCycle (p : G.Walk a a) extends p.IsCycle : Prop where\n  isHamiltonian_tail : p.tail.IsHamiltonian\n\n"}
{"name":"SimpleGraph.Walk.IsHamiltonianCycle.isCycle","module":"Mathlib.Combinatorics.SimpleGraph.Hamiltonian","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nG : SimpleGraph α\na : α\np : G.Walk a a\nhp : p.IsHamiltonianCycle\n⊢ p.IsCycle","decl":"lemma IsHamiltonianCycle.isCycle (hp : p.IsHamiltonianCycle) : p.IsCycle :=\n  hp.toIsCycle\n\n"}
{"name":"SimpleGraph.Walk.IsHamiltonianCycle.map","module":"Mathlib.Combinatorics.SimpleGraph.Hamiltonian","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nG : SimpleGraph α\na : α\np : G.Walk a a\nH : SimpleGraph β\nf : G.Hom H\nhf : Function.Bijective ⇑f\nhp : p.IsHamiltonianCycle\n⊢ (SimpleGraph.Walk.map f p).IsHamiltonianCycle","decl":"lemma IsHamiltonianCycle.map {H : SimpleGraph β} (f : G →g H) (hf : Bijective f)\n    (hp : p.IsHamiltonianCycle) : (p.map f).IsHamiltonianCycle where\n  toIsCycle := hp.isCycle.map hf.injective\n  isHamiltonian_tail := by\n    simp only [IsHamiltonian, hf.surjective.forall]\n    intro x\n    rcases p with (_ | ⟨y, p⟩)\n    · cases hp.ne_nil rfl\n    simp only [map_cons, getVert_cons_succ, tail_cons_eq, support_copy,support_map]\n    rw [List.count_map_of_injective _ _ hf.injective, ← support_copy, ← tail_cons_eq]\n    exact hp.isHamiltonian_tail _\n\n"}
{"name":"SimpleGraph.Walk.isHamiltonianCycle_isCycle_and_isHamiltonian_tail","module":"Mathlib.Combinatorics.SimpleGraph.Hamiltonian","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nG : SimpleGraph α\na : α\np : G.Walk a a\n⊢ Iff p.IsHamiltonianCycle (And p.IsCycle p.tail.IsHamiltonian)","decl":"lemma isHamiltonianCycle_isCycle_and_isHamiltonian_tail  :\n    p.IsHamiltonianCycle ↔ p.IsCycle ∧ p.tail.IsHamiltonian :=\n  ⟨fun ⟨h, h'⟩ ↦ ⟨h, h'⟩, fun ⟨h, h'⟩ ↦ ⟨h, h'⟩⟩\n\n"}
{"name":"SimpleGraph.Walk.isHamiltonianCycle_iff_isCycle_and_support_count_tail_eq_one","module":"Mathlib.Combinatorics.SimpleGraph.Hamiltonian","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nG : SimpleGraph α\na : α\np : G.Walk a a\n⊢ Iff p.IsHamiltonianCycle (And p.IsCycle (∀ (a_1 : α), Eq (List.count a_1 p.support.tail) 1))","decl":"lemma isHamiltonianCycle_iff_isCycle_and_support_count_tail_eq_one :\n    p.IsHamiltonianCycle ↔ p.IsCycle ∧ ∀ a, (support p).tail.count a = 1 := by\n  simp +contextual [isHamiltonianCycle_isCycle_and_isHamiltonian_tail,\n    IsHamiltonian, support_tail, IsCycle.not_nil, exists_prop]\n\n"}
{"name":"SimpleGraph.Walk.IsHamiltonianCycle.mem_support","module":"Mathlib.Combinatorics.SimpleGraph.Hamiltonian","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nG : SimpleGraph α\na : α\np : G.Walk a a\nhp : p.IsHamiltonianCycle\nb : α\n⊢ Membership.mem p.support b","decl":"/-- A hamiltonian cycle visits every vertex. -/\nlemma IsHamiltonianCycle.mem_support (hp : p.IsHamiltonianCycle) (b : α) :\n    b ∈ p.support :=\n  List.mem_of_mem_tail <| support_tail p hp.1.not_nil ▸ hp.isHamiltonian_tail.mem_support _\n\n"}
{"name":"SimpleGraph.Walk.IsHamiltonianCycle.length_eq","module":"Mathlib.Combinatorics.SimpleGraph.Hamiltonian","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\nG : SimpleGraph α\na : α\np : G.Walk a a\ninst✝ : Fintype α\nhp : p.IsHamiltonianCycle\n⊢ Eq p.length (Fintype.card α)","decl":"/-- The length of a hamiltonian cycle is the number of vertices. -/\nlemma IsHamiltonianCycle.length_eq [Fintype α] (hp : p.IsHamiltonianCycle) :\n    p.length = Fintype.card α := by\n  rw [← length_tail_add_one hp.not_nil, hp.isHamiltonian_tail.length_eq, Nat.sub_add_cancel]\n  rw [Nat.succ_le, Fintype.card_pos_iff]\n  exact ⟨a⟩\n\n"}
{"name":"SimpleGraph.Walk.IsHamiltonianCycle.count_support_self","module":"Mathlib.Combinatorics.SimpleGraph.Hamiltonian","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nG : SimpleGraph α\na : α\np : G.Walk a a\nhp : p.IsHamiltonianCycle\n⊢ Eq (List.count a p.support) 2","decl":"lemma IsHamiltonianCycle.count_support_self (hp : p.IsHamiltonianCycle) :\n    p.support.count a = 2 := by\n  rw [support_eq_cons, List.count_cons_self, ← support_tail _ hp.1.not_nil, hp.isHamiltonian_tail]\n\n"}
{"name":"SimpleGraph.Walk.IsHamiltonianCycle.support_count_of_ne","module":"Mathlib.Combinatorics.SimpleGraph.Hamiltonian","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nG : SimpleGraph α\na b : α\np : G.Walk a a\nhp : p.IsHamiltonianCycle\nh : Ne a b\n⊢ Eq (List.count b p.support) 1","decl":"lemma IsHamiltonianCycle.support_count_of_ne (hp : p.IsHamiltonianCycle) (h : a ≠ b) :\n    p.support.count b = 1 := by\n  rw [← cons_support_tail p hp.1.not_nil, List.count_cons_of_ne h.symm, hp.isHamiltonian_tail]\n\n"}
{"name":"SimpleGraph.IsHamiltonian.mono","module":"Mathlib.Combinatorics.SimpleGraph.Hamiltonian","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\nG : SimpleGraph α\ninst✝ : Fintype α\nH : SimpleGraph α\nhGH : LE.le G H\nhG : G.IsHamiltonian\n⊢ H.IsHamiltonian","decl":"lemma IsHamiltonian.mono {H : SimpleGraph α} (hGH : G ≤ H) (hG : G.IsHamiltonian) :\n    H.IsHamiltonian :=\n  fun hα ↦ let ⟨_, p, hp⟩ := hG hα; ⟨_, p.map <| .ofLE hGH, hp.map _ bijective_id⟩\n\n"}
{"name":"SimpleGraph.IsHamiltonian.connected","module":"Mathlib.Combinatorics.SimpleGraph.Hamiltonian","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\nG : SimpleGraph α\ninst✝ : Fintype α\nhG : G.IsHamiltonian\n⊢ G.Connected","decl":"lemma IsHamiltonian.connected (hG : G.IsHamiltonian) : G.Connected where\n  preconnected a b := by\n    obtain rfl | hab := eq_or_ne a b\n    · rfl\n    have : Nontrivial α := ⟨a, b, hab⟩\n    obtain ⟨_, p, hp⟩ := hG Fintype.one_lt_card.ne'\n    have a_mem := hp.mem_support a\n    have b_mem := hp.mem_support b\n    exact ((p.takeUntil a a_mem).reverse.append <| p.takeUntil b b_mem).reachable\n  nonempty := not_isEmpty_iff.1 fun _ ↦ by simpa using hG <| by simp [@Fintype.card_eq_zero]\n\n"}
