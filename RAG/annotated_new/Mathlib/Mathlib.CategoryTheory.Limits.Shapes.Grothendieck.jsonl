{"name":"CategoryTheory.Limits.hasColimit_Œπ_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Grothendieck","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nH : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} H\nG : CategoryTheory.Functor (CategoryTheory.Grothendieck F) H\ninst‚úù : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.HasColimit (CategoryTheory.Functor.comp (F.map f) ((CategoryTheory.Grothendieck.Œπ F Y).comp G))\nX : C\n‚ä¢ CategoryTheory.Limits.HasColimit ((CategoryTheory.Grothendieck.Œπ F X).comp G)","decl":"@[local instance]\nlemma hasColimit_Œπ_comp : ‚àÄ X, HasColimit (Grothendieck.Œπ F X ‚ãô G) :=\n  fun X => hasColimitOfIso (F := F.map (ùüô _) ‚ãô Grothendieck.Œπ F X ‚ãô G) <|\n    (Functor.leftUnitor (Grothendieck.Œπ F X ‚ãô G)).symm ‚â™‚â´\n    (isoWhiskerRight (eqToIso (F.map_id X).symm) (Grothendieck.Œπ F X ‚ãô G))\n\n"}
{"name":"CategoryTheory.Limits.fiberwiseColimit_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Grothendieck","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nH : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} H\nG : CategoryTheory.Functor (CategoryTheory.Grothendieck F) H\ninst‚úù : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.HasColimit (CategoryTheory.Functor.comp (F.map f) ((CategoryTheory.Grothendieck.Œπ F Y).comp G))\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Limits.fiberwiseColimit G).map f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimMap (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.Grothendieck.ŒπNatTrans f) G) (CategoryTheory.Functor.associator (F.map f) (CategoryTheory.Grothendieck.Œπ F Y) G).hom)) (CategoryTheory.Limits.colimit.pre ((CategoryTheory.Grothendieck.Œπ F Y).comp G) (F.map f)))","decl":"/-- A functor taking a colimit on each fiber of a functor `G : Grothendieck F ‚•§ H`. -/\n@[simps]\ndef fiberwiseColimit : C ‚•§ H where\n  obj X := colimit (Grothendieck.Œπ F X ‚ãô G)\n  map {X Y} f := colimMap (whiskerRight (Grothendieck.ŒπNatTrans f) G ‚â´\n    (Functor.associator _ _ _).hom) ‚â´ colimit.pre (Grothendieck.Œπ F Y ‚ãô G) (F.map f)\n  map_id X := by\n    ext d\n    simp only [Functor.comp_obj, Grothendieck.ŒπNatTrans, Grothendieck.Œπ_obj, Œπ_colimMap_assoc,\n      NatTrans.comp_app, whiskerRight_app, Functor.associator_hom_app, Category.comp_id,\n      colimit.Œπ_pre]\n    conv_rhs => rw [‚Üê colimit.eqToHom_comp_Œπ (Grothendieck.Œπ F X ‚ãô G)\n      (j := (F.map (ùüô X)).obj d) (by simp)]\n    rw [‚Üê eqToHom_map G (by simp), Grothendieck.eqToHom_eq]\n    rfl\n  map_comp {X Y Z} f g := by\n    ext d\n    simp only [Functor.comp_obj, Grothendieck.ŒπNatTrans, Œπ_colimMap_assoc, NatTrans.comp_app,\n      whiskerRight_app, Functor.associator_hom_app, Category.comp_id, colimit.Œπ_pre, Category.assoc,\n      colimit.Œπ_pre_assoc]\n    rw [‚Üê Category.assoc, ‚Üê G.map_comp]\n    conv_rhs => rw [‚Üê colimit.eqToHom_comp_Œπ (Grothendieck.Œπ F Z ‚ãô G)\n      (j := (F.map (f ‚â´ g)).obj d) (by simp)]\n    rw [‚Üê Category.assoc, ‚Üê eqToHom_map G (by simp), ‚Üê G.map_comp, Grothendieck.eqToHom_eq]\n    congr 2\n    fapply Grothendieck.ext\n    ¬∑ simp only [Cat.comp_obj, eqToHom_refl, Category.assoc, Grothendieck.comp_base,\n        Category.comp_id]\n    ¬∑ simp only [Grothendieck.Œπ_obj, Cat.comp_obj, eqToHom_refl, Cat.id_obj,\n        Grothendieck.comp_base, Category.comp_id, Grothendieck.comp_fiber, Functor.map_id]\n      conv_rhs => enter [2, 1]; rw [eqToHom_map (F.map (ùüô Z))]\n      conv_rhs => rw [eqToHom_trans, eqToHom_trans]\n\n"}
{"name":"CategoryTheory.Limits.fiberwiseColimit_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Grothendieck","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nH : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} H\nG : CategoryTheory.Functor (CategoryTheory.Grothendieck F) H\ninst‚úù : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.HasColimit (CategoryTheory.Functor.comp (F.map f) ((CategoryTheory.Grothendieck.Œπ F Y).comp G))\nX : C\n‚ä¢ Eq ((CategoryTheory.Limits.fiberwiseColimit G).obj X) (CategoryTheory.Limits.colimit ((CategoryTheory.Grothendieck.Œπ F X).comp G))","decl":"/-- A functor taking a colimit on each fiber of a functor `G : Grothendieck F ‚•§ H`. -/\n@[simps]\ndef fiberwiseColimit : C ‚•§ H where\n  obj X := colimit (Grothendieck.Œπ F X ‚ãô G)\n  map {X Y} f := colimMap (whiskerRight (Grothendieck.ŒπNatTrans f) G ‚â´\n    (Functor.associator _ _ _).hom) ‚â´ colimit.pre (Grothendieck.Œπ F Y ‚ãô G) (F.map f)\n  map_id X := by\n    ext d\n    simp only [Functor.comp_obj, Grothendieck.ŒπNatTrans, Grothendieck.Œπ_obj, Œπ_colimMap_assoc,\n      NatTrans.comp_app, whiskerRight_app, Functor.associator_hom_app, Category.comp_id,\n      colimit.Œπ_pre]\n    conv_rhs => rw [‚Üê colimit.eqToHom_comp_Œπ (Grothendieck.Œπ F X ‚ãô G)\n      (j := (F.map (ùüô X)).obj d) (by simp)]\n    rw [‚Üê eqToHom_map G (by simp), Grothendieck.eqToHom_eq]\n    rfl\n  map_comp {X Y Z} f g := by\n    ext d\n    simp only [Functor.comp_obj, Grothendieck.ŒπNatTrans, Œπ_colimMap_assoc, NatTrans.comp_app,\n      whiskerRight_app, Functor.associator_hom_app, Category.comp_id, colimit.Œπ_pre, Category.assoc,\n      colimit.Œπ_pre_assoc]\n    rw [‚Üê Category.assoc, ‚Üê G.map_comp]\n    conv_rhs => rw [‚Üê colimit.eqToHom_comp_Œπ (Grothendieck.Œπ F Z ‚ãô G)\n      (j := (F.map (f ‚â´ g)).obj d) (by simp)]\n    rw [‚Üê Category.assoc, ‚Üê eqToHom_map G (by simp), ‚Üê G.map_comp, Grothendieck.eqToHom_eq]\n    congr 2\n    fapply Grothendieck.ext\n    ¬∑ simp only [Cat.comp_obj, eqToHom_refl, Category.assoc, Grothendieck.comp_base,\n        Category.comp_id]\n    ¬∑ simp only [Grothendieck.Œπ_obj, Cat.comp_obj, eqToHom_refl, Cat.id_obj,\n        Grothendieck.comp_base, Category.comp_id, Grothendieck.comp_fiber, Functor.map_id]\n      conv_rhs => enter [2, 1]; rw [eqToHom_map (F.map (ùüô Z))]\n      conv_rhs => rw [eqToHom_trans, eqToHom_trans]\n\n"}
{"name":"CategoryTheory.Limits.fiberwiseColim_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Grothendieck","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nH : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} H\ninst‚úù : ‚àÄ (c : C), CategoryTheory.Limits.HasColimitsOfShape (‚Üë(F.obj c)) H\nG : CategoryTheory.Functor (CategoryTheory.Grothendieck F) H\n‚ä¢ Eq ((CategoryTheory.Limits.fiberwiseColim F H).obj G) (CategoryTheory.Limits.fiberwiseColimit G)","decl":"variable (H) (F) in\n/-- Similar to `colimit` and `colim`, taking fiberwise colimits is a functor\n`(Grothendieck F ‚•§ H) ‚•§ (C ‚•§ H)` between functor categories. -/\n@[simps]\ndef fiberwiseColim [‚àÄ c, HasColimitsOfShape (F.obj c) H] : (Grothendieck F ‚•§ H) ‚•§ (C ‚•§ H) where\n  obj G := fiberwiseColimit G\n  map Œ± :=\n    { app := fun c => colim.map (whiskerLeft _ Œ±)\n      naturality := fun c‚ÇÅ c‚ÇÇ f => by apply colimit.hom_ext; simp }\n  map_id G := by ext; simp; apply Functor.map_id colim\n  map_comp Œ± Œ≤ := by ext; simp; apply Functor.map_comp colim\n\n"}
{"name":"CategoryTheory.Limits.fiberwiseColim_map_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Grothendieck","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nH : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} H\ninst‚úù : ‚àÄ (c : C), CategoryTheory.Limits.HasColimitsOfShape (‚Üë(F.obj c)) H\nX‚úù Y‚úù : CategoryTheory.Functor (CategoryTheory.Grothendieck F) H\nŒ± : Quiver.Hom X‚úù Y‚úù\nc : C\n‚ä¢ Eq (((CategoryTheory.Limits.fiberwiseColim F H).map Œ±).app c) (CategoryTheory.Limits.colim.map (CategoryTheory.whiskerLeft (CategoryTheory.Grothendieck.Œπ F c) Œ±))","decl":"variable (H) (F) in\n/-- Similar to `colimit` and `colim`, taking fiberwise colimits is a functor\n`(Grothendieck F ‚•§ H) ‚•§ (C ‚•§ H)` between functor categories. -/\n@[simps]\ndef fiberwiseColim [‚àÄ c, HasColimitsOfShape (F.obj c) H] : (Grothendieck F ‚•§ H) ‚•§ (C ‚•§ H) where\n  obj G := fiberwiseColimit G\n  map Œ± :=\n    { app := fun c => colim.map (whiskerLeft _ Œ±)\n      naturality := fun c‚ÇÅ c‚ÇÇ f => by apply colimit.hom_ext; simp }\n  map_id G := by ext; simp; apply Functor.map_id colim\n  map_comp Œ± Œ≤ := by ext; simp; apply Functor.map_comp colim\n\n"}
{"name":"CategoryTheory.Limits.natTransIntoForgetCompFiberwiseColimit_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Grothendieck","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nH : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} H\nG : CategoryTheory.Functor (CategoryTheory.Grothendieck F) H\ninst‚úù : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.HasColimit (CategoryTheory.Functor.comp (F.map f) ((CategoryTheory.Grothendieck.Œπ F Y).comp G))\nX : CategoryTheory.Grothendieck F\n‚ä¢ Eq ((CategoryTheory.Limits.natTransIntoForgetCompFiberwiseColimit G).app X) (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.Grothendieck.Œπ F X.base).comp G) X.fiber)","decl":"/-- Every functor `G : Grothendieck F ‚•§ H` induces a natural transformation from `G` to the\ncomposition of the forgetful functor on `Grothendieck F` with the fiberwise colimit on `G`. -/\n@[simps]\ndef natTransIntoForgetCompFiberwiseColimit :\n    G ‚ü∂ Grothendieck.forget F ‚ãô fiberwiseColimit G where\n  app X := colimit.Œπ (Grothendieck.Œπ F X.base ‚ãô G) X.fiber\n  naturality _ _ f := by\n    simp only [Functor.comp_obj, Grothendieck.forget_obj, fiberwiseColimit_obj, Functor.comp_map,\n      Grothendieck.forget_map, fiberwiseColimit_map, Œπ_colimMap_assoc, Grothendieck.Œπ_obj,\n      NatTrans.comp_app, whiskerRight_app, Functor.associator_hom_app, Category.comp_id,\n      colimit.Œπ_pre]\n    rw [‚Üê colimit.w (Grothendieck.Œπ F _ ‚ãô G) f.fiber]\n    simp only [‚Üê Category.assoc, Functor.comp_obj, Functor.comp_map, ‚Üê G.map_comp]\n    congr 2\n    apply Grothendieck.ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.coconeFiberwiseColimitOfCocone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Grothendieck","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nH : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} H\nG : CategoryTheory.Functor (CategoryTheory.Grothendieck F) H\ninst‚úù : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.HasColimit (CategoryTheory.Functor.comp (F.map f) ((CategoryTheory.Grothendieck.Œπ F Y).comp G))\nc : CategoryTheory.Limits.Cocone G\n‚ä¢ Eq (CategoryTheory.Limits.coconeFiberwiseColimitOfCocone c).pt c.pt","decl":"variable {G} in\n/-- A cocone on a functor `G : Grothendieck F ‚•§ H` induces a cocone on the fiberwise colimit\non `G`. -/\n@[simps]\ndef coconeFiberwiseColimitOfCocone (c : Cocone G) : Cocone (fiberwiseColimit G) where\n  pt := c.pt\n  Œπ := { app := fun X => colimit.desc _ (c.whisker (Grothendieck.Œπ F X)),\n         naturality := fun _ _ f => by dsimp; ext; simp }\n\n"}
{"name":"CategoryTheory.Limits.coconeFiberwiseColimitOfCocone_Œπ_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Grothendieck","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nH : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} H\nG : CategoryTheory.Functor (CategoryTheory.Grothendieck F) H\ninst‚úù : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.HasColimit (CategoryTheory.Functor.comp (F.map f) ((CategoryTheory.Grothendieck.Œπ F Y).comp G))\nc : CategoryTheory.Limits.Cocone G\nX : C\n‚ä¢ Eq ((CategoryTheory.Limits.coconeFiberwiseColimitOfCocone c).Œπ.app X) (CategoryTheory.Limits.colimit.desc ((CategoryTheory.Grothendieck.Œπ F X).comp G) (CategoryTheory.Limits.Cocone.whisker (CategoryTheory.Grothendieck.Œπ F X) c))","decl":"variable {G} in\n/-- A cocone on a functor `G : Grothendieck F ‚•§ H` induces a cocone on the fiberwise colimit\non `G`. -/\n@[simps]\ndef coconeFiberwiseColimitOfCocone (c : Cocone G) : Cocone (fiberwiseColimit G) where\n  pt := c.pt\n  Œπ := { app := fun X => colimit.desc _ (c.whisker (Grothendieck.Œπ F X)),\n         naturality := fun _ _ f => by dsimp; ext; simp }\n\n"}
{"name":"CategoryTheory.Limits.hasColimit_fiberwiseColimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Grothendieck","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nH : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} H\nG : CategoryTheory.Functor (CategoryTheory.Grothendieck F) H\ninst‚úù¬π : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.HasColimit (CategoryTheory.Functor.comp (F.map f) ((CategoryTheory.Grothendieck.Œπ F Y).comp G))\ninst‚úù : CategoryTheory.Limits.HasColimit G\n‚ä¢ CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.fiberwiseColimit G)","decl":"lemma hasColimit_fiberwiseColimit [HasColimit G] : HasColimit (fiberwiseColimit G) where\n  exists_colimit := ‚ü®‚ü®_, isColimitCoconeFiberwiseColimitOfCocone (colimit.isColimit _)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.coconeOfCoconeFiberwiseColimit_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Grothendieck","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nH : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} H\nG : CategoryTheory.Functor (CategoryTheory.Grothendieck F) H\ninst‚úù : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.HasColimit (CategoryTheory.Functor.comp (F.map f) ((CategoryTheory.Grothendieck.Œπ F Y).comp G))\nc : CategoryTheory.Limits.Cocone (CategoryTheory.Limits.fiberwiseColimit G)\n‚ä¢ Eq (CategoryTheory.Limits.coconeOfCoconeFiberwiseColimit c).pt c.pt","decl":"/-- For a functor `G : Grothendieck F ‚•§ H`, every cocone over `fiberwiseColimit G` induces a\ncocone over `G` itself. -/\n@[simps]\ndef coconeOfCoconeFiberwiseColimit (c : Cocone (fiberwiseColimit G)) : Cocone G where\n  pt := c.pt\n  Œπ := { app := fun X => colimit.Œπ (Grothendieck.Œπ F X.base ‚ãô G) X.fiber ‚â´ c.Œπ.app X.base\n         naturality := fun {X Y} ‚ü®f, g‚ü© => by\n          simp only [Functor.const_obj_obj, Functor.const_obj_map, Category.comp_id]\n          rw [‚Üê Category.assoc, ‚Üê c.w f, ‚Üê Category.assoc]\n          simp only [fiberwiseColimit_obj, fiberwiseColimit_map, Œπ_colimMap_assoc,\n            Functor.comp_obj, Grothendieck.Œπ_obj, NatTrans.comp_app, whiskerRight_app,\n            Functor.associator_hom_app, Category.comp_id, colimit.Œπ_pre]\n          rw [‚Üê colimit.w _ g, ‚Üê Category.assoc, Functor.comp_map, ‚Üê G.map_comp]\n          congr <;> simp }\n\n"}
{"name":"CategoryTheory.Limits.coconeOfCoconeFiberwiseColimit_Œπ_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Grothendieck","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nH : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} H\nG : CategoryTheory.Functor (CategoryTheory.Grothendieck F) H\ninst‚úù : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.HasColimit (CategoryTheory.Functor.comp (F.map f) ((CategoryTheory.Grothendieck.Œπ F Y).comp G))\nc : CategoryTheory.Limits.Cocone (CategoryTheory.Limits.fiberwiseColimit G)\nX : CategoryTheory.Grothendieck F\n‚ä¢ Eq ((CategoryTheory.Limits.coconeOfCoconeFiberwiseColimit c).Œπ.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.Grothendieck.Œπ F X.base).comp G) X.fiber) (c.Œπ.app X.base))","decl":"/-- For a functor `G : Grothendieck F ‚•§ H`, every cocone over `fiberwiseColimit G` induces a\ncocone over `G` itself. -/\n@[simps]\ndef coconeOfCoconeFiberwiseColimit (c : Cocone (fiberwiseColimit G)) : Cocone G where\n  pt := c.pt\n  Œπ := { app := fun X => colimit.Œπ (Grothendieck.Œπ F X.base ‚ãô G) X.fiber ‚â´ c.Œπ.app X.base\n         naturality := fun {X Y} ‚ü®f, g‚ü© => by\n          simp only [Functor.const_obj_obj, Functor.const_obj_map, Category.comp_id]\n          rw [‚Üê Category.assoc, ‚Üê c.w f, ‚Üê Category.assoc]\n          simp only [fiberwiseColimit_obj, fiberwiseColimit_map, Œπ_colimMap_assoc,\n            Functor.comp_obj, Grothendieck.Œπ_obj, NatTrans.comp_app, whiskerRight_app,\n            Functor.associator_hom_app, Category.comp_id, colimit.Œπ_pre]\n          rw [‚Üê colimit.w _ g, ‚Üê Category.assoc, Functor.comp_map, ‚Üê G.map_comp]\n          congr <;> simp }\n\n"}
{"name":"CategoryTheory.Limits.hasColimit_of_hasColimit_fiberwiseColimit_of_hasColimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Grothendieck","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nH : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} H\nG : CategoryTheory.Functor (CategoryTheory.Grothendieck F) H\ninst‚úù¬π : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.HasColimit (CategoryTheory.Functor.comp (F.map f) ((CategoryTheory.Grothendieck.Œπ F Y).comp G))\ninst‚úù : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.fiberwiseColimit G)\n‚ä¢ CategoryTheory.Limits.HasColimit G","decl":"/-- We can infer that a functor `G : Grothendieck F ‚•§ H`, with `F : C ‚•§ Cat`, has a colimit from\nthe fact that each of its fibers has a colimit and that these fiberwise colimits, as a functor\n`C ‚•§ H` have a colimit. -/\n@[local instance]\nlemma hasColimit_of_hasColimit_fiberwiseColimit_of_hasColimit : HasColimit G where\n  exists_colimit := ‚ü®‚ü®_, isColimitCoconeOfFiberwiseCocone (colimit.isColimit _)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.Œπ_colimitFiberwiseColimitIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Grothendieck","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nH : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} H\nG : CategoryTheory.Functor (CategoryTheory.Grothendieck F) H\ninst‚úù¬π : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.HasColimit (CategoryTheory.Functor.comp (F.map f) ((CategoryTheory.Grothendieck.Œπ F Y).comp G))\ninst‚úù : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.fiberwiseColimit G)\nX : C\nd : ‚Üë(F.obj X)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.Grothendieck.Œπ F X).comp G) d) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ (CategoryTheory.Limits.fiberwiseColimit G) X) (CategoryTheory.Limits.colimitFiberwiseColimitIso G).hom)) (CategoryTheory.Limits.colimit.Œπ G { base := X, fiber := d })","decl":"@[reassoc (attr := simp)]\nlemma Œπ_colimitFiberwiseColimitIso_hom (X : C) (d : F.obj X) :\n    colimit.Œπ (Grothendieck.Œπ F X ‚ãô G) d ‚â´ colimit.Œπ (fiberwiseColimit G) X ‚â´\n      (colimitFiberwiseColimitIso G).hom = colimit.Œπ G ‚ü®X, d‚ü© := by\n  simp [colimitFiberwiseColimitIso]\n\n"}
{"name":"CategoryTheory.Limits.Œπ_colimitFiberwiseColimitIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Grothendieck","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nH : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} H\nG : CategoryTheory.Functor (CategoryTheory.Grothendieck F) H\ninst‚úù¬π : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.HasColimit (CategoryTheory.Functor.comp (F.map f) ((CategoryTheory.Grothendieck.Œπ F Y).comp G))\ninst‚úù : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.fiberwiseColimit G)\nX : C\nd : ‚Üë(F.obj X)\nZ : H\nh : Quiver.Hom (CategoryTheory.Limits.colimit G) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.Grothendieck.Œπ F X).comp G) d) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ (CategoryTheory.Limits.fiberwiseColimit G) X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitFiberwiseColimitIso G).hom h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ G { base := X, fiber := d }) h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_colimitFiberwiseColimitIso_hom (X : C) (d : F.obj X) :\n    colimit.Œπ (Grothendieck.Œπ F X ‚ãô G) d ‚â´ colimit.Œπ (fiberwiseColimit G) X ‚â´\n      (colimitFiberwiseColimitIso G).hom = colimit.Œπ G ‚ü®X, d‚ü© := by\n  simp [colimitFiberwiseColimitIso]\n\n"}
{"name":"CategoryTheory.Limits.Œπ_colimitFiberwiseColimitIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Grothendieck","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nH : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} H\nG : CategoryTheory.Functor (CategoryTheory.Grothendieck F) H\ninst‚úù¬π : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.HasColimit (CategoryTheory.Functor.comp (F.map f) ((CategoryTheory.Grothendieck.Œπ F Y).comp G))\ninst‚úù : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.fiberwiseColimit G)\nX : CategoryTheory.Grothendieck F\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ G X) (CategoryTheory.Limits.colimitFiberwiseColimitIso G).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.Grothendieck.Œπ F X.base).comp G) X.fiber) (CategoryTheory.Limits.colimit.Œπ (CategoryTheory.Limits.fiberwiseColimit G) X.base))","decl":"@[reassoc (attr := simp)]\nlemma Œπ_colimitFiberwiseColimitIso_inv (X : Grothendieck F) :\n    colimit.Œπ G X ‚â´ (colimitFiberwiseColimitIso G).inv =\n    colimit.Œπ (Grothendieck.Œπ F X.base ‚ãô G) X.fiber ‚â´\n      colimit.Œπ (fiberwiseColimit G) X.base := by\n  rw [Iso.comp_inv_eq]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Œπ_colimitFiberwiseColimitIso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Grothendieck","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nH : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} H\nG : CategoryTheory.Functor (CategoryTheory.Grothendieck F) H\ninst‚úù¬π : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.HasColimit (CategoryTheory.Functor.comp (F.map f) ((CategoryTheory.Grothendieck.Œπ F Y).comp G))\ninst‚úù : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.fiberwiseColimit G)\nX : CategoryTheory.Grothendieck F\nZ : H\nh : Quiver.Hom (CategoryTheory.Limits.colimit (CategoryTheory.Limits.fiberwiseColimit G)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ G X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitFiberwiseColimitIso G).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.Grothendieck.Œπ F X.base).comp G) X.fiber) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ (CategoryTheory.Limits.fiberwiseColimit G) X.base) h))","decl":"@[reassoc (attr := simp)]\nlemma Œπ_colimitFiberwiseColimitIso_inv (X : Grothendieck F) :\n    colimit.Œπ G X ‚â´ (colimitFiberwiseColimitIso G).inv =\n    colimit.Œπ (Grothendieck.Œπ F X.base ‚ãô G) X.fiber ‚â´\n      colimit.Œπ (fiberwiseColimit G) X.base := by\n  rw [Iso.comp_inv_eq]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.hasColimitsOfShape_grothendieck","module":"Mathlib.CategoryTheory.Limits.Shapes.Grothendieck","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nH : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} H\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (‚Üë(F.obj X)) H\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape C H\n‚ä¢ CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Grothendieck F) H","decl":"@[instance]\ntheorem hasColimitsOfShape_grothendieck [‚àÄ X, HasColimitsOfShape (F.obj X) H]\n    [HasColimitsOfShape C H] : HasColimitsOfShape (Grothendieck F) H where\n  has_colimit _ := hasColimit_of_hasColimit_fiberwiseColimit_of_hasColimit _\n\n"}
{"name":"CategoryTheory.Limits.fiberwiseColimCompColimIso_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Grothendieck","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nH : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} H\ninst‚úù¬π : ‚àÄ (c : C), CategoryTheory.Limits.HasColimitsOfShape (‚Üë(F.obj c)) H\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape C H\nX : CategoryTheory.Functor (CategoryTheory.Grothendieck F) H\n‚ä¢ Eq (CategoryTheory.Limits.fiberwiseColimCompColimIso.hom.app X) (CategoryTheory.Limits.colimitFiberwiseColimitIso X).hom","decl":"/-- The isomorphism `colimitFiberwiseColimitIso` induces an isomorphism of functors `(J ‚•§ C) ‚•§ C`\nbetween `fiberwiseColim F H ‚ãô colim` and `colim`. -/\n@[simps!]\ndef fiberwiseColimCompColimIso : fiberwiseColim F H ‚ãô colim ‚âÖ colim :=\n  NatIso.ofComponents (fun G => colimitFiberwiseColimitIso G)\n    fun _ => by (iterate 2 apply colimit.hom_ext; intro); simp\n\n"}
{"name":"CategoryTheory.Limits.fiberwiseColimCompColimIso_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Grothendieck","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nH : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} H\ninst‚úù¬π : ‚àÄ (c : C), CategoryTheory.Limits.HasColimitsOfShape (‚Üë(F.obj c)) H\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape C H\nX : CategoryTheory.Functor (CategoryTheory.Grothendieck F) H\n‚ä¢ Eq (CategoryTheory.Limits.fiberwiseColimCompColimIso.inv.app X) (CategoryTheory.Limits.colimitFiberwiseColimitIso X).inv","decl":"/-- The isomorphism `colimitFiberwiseColimitIso` induces an isomorphism of functors `(J ‚•§ C) ‚•§ C`\nbetween `fiberwiseColim F H ‚ãô colim` and `colim`. -/\n@[simps!]\ndef fiberwiseColimCompColimIso : fiberwiseColim F H ‚ãô colim ‚âÖ colim :=\n  NatIso.ofComponents (fun G => colimitFiberwiseColimitIso G)\n    fun _ => by (iterate 2 apply colimit.hom_ext; intro); simp\n\n"}
{"name":"CategoryTheory.Limits.fiberwiseColimCompEvaluationIso_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Grothendieck","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nH : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} H\ninst‚úù : ‚àÄ (c : C), CategoryTheory.Limits.HasColimitsOfShape (‚Üë(F.obj c)) H\nc : C\nX : CategoryTheory.Functor (CategoryTheory.Grothendieck F) H\n‚ä¢ Eq ((CategoryTheory.Limits.fiberwiseColimCompEvaluationIso c).hom.app X) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.colimit ((CategoryTheory.Grothendieck.Œπ F c).comp X)))","decl":"/-- Composing `fiberwiseColim F H` with the evaluation functor `(evaluation C H).obj c` is\nnaturally isomorphic to precomposing the Grothendieck inclusion `Grothendieck.Œπ` to `colim`. -/\n@[simps!]\ndef fiberwiseColimCompEvaluationIso (c : C) :\n    fiberwiseColim F H ‚ãô (evaluation C H).obj c ‚âÖ\n      (whiskeringLeft _ _ _).obj (Grothendieck.Œπ F c) ‚ãô colim :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Limits.fiberwiseColimCompEvaluationIso_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Grothendieck","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nH : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} H\ninst‚úù : ‚àÄ (c : C), CategoryTheory.Limits.HasColimitsOfShape (‚Üë(F.obj c)) H\nc : C\nX : CategoryTheory.Functor (CategoryTheory.Grothendieck F) H\n‚ä¢ Eq ((CategoryTheory.Limits.fiberwiseColimCompEvaluationIso c).inv.app X) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.colimit ((CategoryTheory.Grothendieck.Œπ F c).comp X)))","decl":"/-- Composing `fiberwiseColim F H` with the evaluation functor `(evaluation C H).obj c` is\nnaturally isomorphic to precomposing the Grothendieck inclusion `Grothendieck.Œπ` to `colim`. -/\n@[simps!]\ndef fiberwiseColimCompEvaluationIso (c : C) :\n    fiberwiseColim F H ‚ãô (evaluation C H).obj c ‚âÖ\n      (whiskeringLeft _ _ _).obj (Grothendieck.Œπ F c) ‚ãô colim :=\n  Iso.refl _\n\n"}
