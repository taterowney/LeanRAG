{"name":"Complex.tan_arctan","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arctan","initialProofState":"z : Complex\nh₁ : Ne z Complex.I\nh₂ : Ne z (Neg.neg Complex.I)\n⊢ Eq (Complex.tan z.arctan) z","decl":"theorem tan_arctan {z : ℂ} (h₁ : z ≠ I) (h₂ : z ≠ -I) : tan (arctan z) = z := by\n  unfold tan sin cos\n  rw [div_div_eq_mul_div, div_mul_cancel₀ _ two_ne_zero, ← div_mul_eq_mul_div,\n    -- multiply top and bottom by `exp (arctan z * I)`\n    ← mul_div_mul_right _ _ (exp_ne_zero (arctan z * I)), sub_mul, add_mul,\n    ← exp_add, neg_mul, neg_add_cancel, exp_zero, ← exp_add, ← two_mul]\n  have z₁ : 1 + z * I ≠ 0 := by\n    contrapose! h₁\n    rw [add_eq_zero_iff_neg_eq, ← div_eq_iff I_ne_zero, div_I, neg_one_mul, neg_neg] at h₁\n    exact h₁.symm\n  have z₂ : 1 - z * I ≠ 0 := by\n    contrapose! h₂\n    rw [sub_eq_zero, ← div_eq_iff I_ne_zero, div_I, one_mul] at h₂\n    exact h₂.symm\n  have key : exp (2 * (arctan z * I)) = (1 + z * I) / (1 - z * I) := by\n    rw [arctan, ← mul_rotate, ← mul_assoc,\n      show 2 * (I * (-I / 2)) = 1 by field_simp, one_mul, exp_log]\n    · exact div_ne_zero z₁ z₂\n  -- multiply top and bottom by `1 - z * I`\n  rw [key, ← mul_div_mul_right _ _ z₂, sub_mul, add_mul, div_mul_cancel₀ _ z₂, one_mul,\n    show _ / _ * I = -(I * I) * z by ring, I_mul_I, neg_neg, one_mul]\n\n"}
{"name":"Complex.cos_ne_zero_of_arctan_bounds","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arctan","initialProofState":"z : Complex\nh₀ : Ne z (HDiv.hDiv (↑Real.pi) 2)\nh₁ : LT.lt (Neg.neg (HDiv.hDiv Real.pi 2)) z.re\nh₂ : LE.le z.re (HDiv.hDiv Real.pi 2)\n⊢ Ne (Complex.cos z) 0","decl":"/-- `cos z` is nonzero when the bounds in `arctan_tan` are met (`z` lies in the vertical strip\n`-π / 2 < z.re < π / 2` and `z ≠ π / 2`). -/\nlemma cos_ne_zero_of_arctan_bounds {z : ℂ} (h₀ : z ≠ π / 2) (h₁ : -(π / 2) < z.re)\n    (h₂ : z.re ≤ π / 2) : cos z ≠ 0 := by\n  refine cos_ne_zero_iff.mpr (fun k ↦ ?_)\n  rw [ne_eq, Complex.ext_iff, not_and_or] at h₀ ⊢\n  norm_cast at h₀ ⊢\n  cases' h₀ with nr ni\n  · left; contrapose! nr\n    rw [nr, mul_div_assoc, neg_eq_neg_one_mul, mul_lt_mul_iff_of_pos_right (by positivity)] at h₁\n    rw [nr, ← one_mul (π / 2), mul_div_assoc, mul_le_mul_iff_of_pos_right (by positivity)] at h₂\n    norm_cast at h₁ h₂\n    change -1 < _ at h₁\n    rwa [show 2 * k + 1 = 1 by omega, Int.cast_one, one_mul] at nr\n  · exact Or.inr ni\n\n"}
{"name":"Complex.arctan_tan","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arctan","initialProofState":"z : Complex\nh₀ : Ne z (HDiv.hDiv (↑Real.pi) 2)\nh₁ : LT.lt (Neg.neg (HDiv.hDiv Real.pi 2)) z.re\nh₂ : LE.le z.re (HDiv.hDiv Real.pi 2)\n⊢ Eq (Complex.tan z).arctan z","decl":"theorem arctan_tan {z : ℂ} (h₀ : z ≠ π / 2) (h₁ : -(π / 2) < z.re) (h₂ : z.re ≤ π / 2) :\n    arctan (tan z) = z := by\n  have h := cos_ne_zero_of_arctan_bounds h₀ h₁ h₂\n  unfold arctan tan\n  -- multiply top and bottom by `cos z`\n  rw [← mul_div_mul_right (1 + _) _ h, add_mul, sub_mul, one_mul, ← mul_rotate, mul_div_cancel₀ _ h]\n  conv_lhs =>\n    enter [2, 1, 2]\n    rw [sub_eq_add_neg, ← neg_mul, ← sin_neg, ← cos_neg]\n  rw [← exp_mul_I, ← exp_mul_I, ← exp_sub, show z * I - -z * I = 2 * (I * z) by ring, log_exp,\n    show -I / 2 * (2 * (I * z)) = -(I * I) * z by ring, I_mul_I, neg_neg, one_mul]\n  all_goals norm_num\n  · rwa [← div_lt_iff₀' two_pos, neg_div]\n  · rwa [← le_div_iff₀' two_pos]\n\n"}
{"name":"Complex.ofReal_arctan","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arctan","initialProofState":"x : Real\n⊢ Eq (↑(Real.arctan x)) (↑x).arctan","decl":"@[simp, norm_cast]\ntheorem ofReal_arctan (x : ℝ) : (Real.arctan x : ℂ) = arctan x := by\n  conv_rhs => rw [← Real.tan_arctan x]\n  rw [ofReal_tan, arctan_tan]\n  all_goals norm_cast\n  · rw [← ne_eq]; exact (Real.arctan_lt_pi_div_two _).ne\n  · exact Real.neg_pi_div_two_lt_arctan _\n  · exact (Real.arctan_lt_pi_div_two _).le\n\n"}
{"name":"Complex.arg_one_add_mem_Ioo","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arctan","initialProofState":"z : Complex\nhz : LT.lt (Norm.norm z) 1\n⊢ Membership.mem (Set.Ioo (Neg.neg (HDiv.hDiv Real.pi 2)) (HDiv.hDiv Real.pi 2)) (HAdd.hAdd 1 z).arg","decl":"/-- The argument of `1 + z` for `z` in the open unit disc is always in `(-π / 2, π / 2)`. -/\nlemma arg_one_add_mem_Ioo {z : ℂ} (hz : ‖z‖ < 1) : (1 + z).arg ∈ Set.Ioo (-(π / 2)) (π / 2) := by\n  rw [Set.mem_Ioo, ← abs_lt, abs_arg_lt_pi_div_two_iff, add_re, one_re, ← neg_lt_iff_pos_add']\n  exact Or.inl (abs_lt.mp ((abs_re_le_abs z).trans_lt (norm_eq_abs z ▸ hz))).1\n\n"}
{"name":"Complex.hasSum_arctan_aux","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arctan","initialProofState":"z : Complex\nhz : LT.lt (Norm.norm z) 1\n⊢ Eq (HAdd.hAdd (Complex.log (HAdd.hAdd 1 (HMul.hMul z Complex.I))) (Neg.neg (Complex.log (HSub.hSub 1 (HMul.hMul z Complex.I))))) (Complex.log (HDiv.hDiv (HAdd.hAdd 1 (HMul.hMul z Complex.I)) (HSub.hSub 1 (HMul.hMul z Complex.I))))","decl":"/-- We can combine the logs in `log (1 + z * I) + -log (1 - z * I)` into one.\nThis is only used in `hasSum_arctan`. -/\nlemma hasSum_arctan_aux {z : ℂ} (hz : ‖z‖ < 1) :\n    log (1 + z * I) + -log (1 - z * I) = log ((1 + z * I) / (1 - z * I)) := by\n  have z₁ := mem_slitPlane_iff_arg.mp (mem_slitPlane_of_norm_lt_one (z := z * I) (by simpa))\n  have z₂ := mem_slitPlane_iff_arg.mp (mem_slitPlane_of_norm_lt_one (z := -(z * I)) (by simpa))\n  rw [← sub_eq_add_neg] at z₂\n  rw [← log_inv _ z₂.1, ← (log_mul_eq_add_log_iff z₁.2 (inv_eq_zero.ne.mpr z₂.2)).mpr,\n    div_eq_mul_inv]\n  -- `log_mul_eq_add_log_iff` requires a bound on `arg (1 + z * I) + arg (1 - z * I)⁻¹`.\n  -- `arg_one_add_mem_Ioo` provides sufficiently tight bounds on both terms\n  have b₁ := arg_one_add_mem_Ioo (z := z * I) (by simpa)\n  have b₂ : arg (1 - z * I)⁻¹ ∈ Set.Ioo (-(π / 2)) (π / 2) := by\n    simp_rw [arg_inv, z₂.1, ite_false, Set.neg_mem_Ioo_iff, neg_neg, sub_eq_add_neg]\n    exact arg_one_add_mem_Ioo (by simpa)\n  have c₁ := add_lt_add b₁.1 b₂.1\n  have c₂ := add_lt_add b₁.2 b₂.2\n  rw [show -(π / 2) + -(π / 2) = -π by ring] at c₁\n  rw [show π / 2 + π / 2 = π by ring] at c₂\n  exact ⟨c₁, c₂.le⟩\n\n"}
{"name":"Complex.hasSum_arctan","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arctan","initialProofState":"z : Complex\nhz : LT.lt (Norm.norm z) 1\n⊢ HasSum (fun n => HDiv.hDiv (HMul.hMul (HPow.hPow (-1) n) (HPow.hPow z (HAdd.hAdd (HMul.hMul 2 n) 1))) ↑(HAdd.hAdd (HMul.hMul 2 n) 1)) z.arctan","decl":"/-- The power series expansion of `Complex.arctan`, valid on the open unit disc. -/\ntheorem hasSum_arctan {z : ℂ} (hz : ‖z‖ < 1) :\n    HasSum (fun n : ℕ ↦ (-1) ^ n * z ^ (2 * n + 1) / ↑(2 * n + 1)) (arctan z) := by\n  have := ((hasSum_taylorSeries_log (z := z * I) (by simpa)).add\n    (hasSum_taylorSeries_neg_log (z := z * I) (by simpa))).mul_left (-I / 2)\n  simp_rw [← add_div, ← add_one_mul, hasSum_arctan_aux hz] at this\n  replace := (Nat.divModEquiv 2).symm.hasSum_iff.mpr this\n  dsimp [Function.comp_def] at this\n  simp_rw [← mul_comm 2 _] at this\n  refine this.prod_fiberwise fun k => ?_\n  dsimp only\n  convert hasSum_fintype (_ : Fin 2 → ℂ) using 1\n  rw [Fin.sum_univ_two, Fin.val_zero, Fin.val_one, Odd.neg_one_pow (n := 2 * k + 0 + 1) (by simp),\n    neg_add_cancel, zero_mul, zero_div, mul_zero, zero_add,\n    show 2 * k + 1 + 1 = 2 * (k + 1) by ring, Even.neg_one_pow (n := 2 * (k + 1)) (by simp),\n    ← mul_div_assoc (_ / _), ← mul_assoc, show -I / 2 * (1 + 1) = -I by ring]\n  congr 1\n  rw [mul_pow, pow_succ' I, pow_mul, I_sq,\n    show -I * _ = -(I * I) * (-1) ^ k * z ^ (2 * k + 1) by ring, I_mul_I, neg_neg, one_mul]\n\n"}
{"name":"Real.hasSum_arctan","module":"Mathlib.Analysis.SpecialFunctions.Complex.Arctan","initialProofState":"x : Real\nhx : LT.lt (Norm.norm x) 1\n⊢ HasSum (fun n => HDiv.hDiv (HMul.hMul (HPow.hPow (-1) n) (HPow.hPow x (HAdd.hAdd (HMul.hMul 2 n) 1))) ↑(HAdd.hAdd (HMul.hMul 2 n) 1)) (Real.arctan x)","decl":"/-- The power series expansion of `Real.arctan`, valid on `-1 < x < 1`. -/\ntheorem Real.hasSum_arctan {x : ℝ} (hx : ‖x‖ < 1) :\n    HasSum (fun n : ℕ => (-1) ^ n * x ^ (2 * n + 1) / ↑(2 * n + 1)) (arctan x) :=\n  mod_cast Complex.hasSum_arctan (z := x) (by simpa)\n"}
