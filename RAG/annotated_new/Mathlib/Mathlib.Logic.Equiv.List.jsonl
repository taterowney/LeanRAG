{"name":"List.countable","module":"Mathlib.Logic.Equiv.List","initialProofState":"α : Type u_2\ninst✝ : Countable α\n⊢ Countable (List α)","decl":"instance _root_.List.countable {α : Type*} [Countable α] : Countable (List α) := by\n  haveI := Encodable.ofCountable α\n  infer_instance\n\n"}
{"name":"Encodable.encode_list_nil","module":"Mathlib.Logic.Equiv.List","initialProofState":"α : Type u_1\ninst✝ : Encodable α\n⊢ Eq (Encodable.encode List.nil) 0","decl":"@[simp]\ntheorem encode_list_nil : encode (@nil α) = 0 :=\n  rfl\n\n"}
{"name":"Encodable.encode_list_cons","module":"Mathlib.Logic.Equiv.List","initialProofState":"α : Type u_1\ninst✝ : Encodable α\na : α\nl : List α\n⊢ Eq (Encodable.encode (List.cons a l)) (Nat.pair (Encodable.encode a) (Encodable.encode l)).succ","decl":"@[simp]\ntheorem encode_list_cons (a : α) (l : List α) :\n    encode (a :: l) = succ (pair (encode a) (encode l)) :=\n  rfl\n\n"}
{"name":"Encodable.decode_list_zero","module":"Mathlib.Logic.Equiv.List","initialProofState":"α : Type u_1\ninst✝ : Encodable α\n⊢ Eq (Encodable.decode 0) (Option.some List.nil)","decl":"@[simp]\ntheorem decode_list_zero : decode (α := List α) 0 = some [] :=\n  show decodeList 0 = some [] by rw [decodeList]\n\n"}
{"name":"Encodable.decode_list_succ","module":"Mathlib.Logic.Equiv.List","initialProofState":"α : Type u_1\ninst✝ : Encodable α\nv : Nat\n⊢ Eq (Encodable.decode v.succ) (Seq.seq (Functor.map (fun x1 x2 => List.cons x1 x2) (Encodable.decode (Nat.unpair v).1)) fun x => Encodable.decode (Nat.unpair v).2)","decl":"@[simp, nolint unusedHavesSuffices] -- Porting note: false positive\ntheorem decode_list_succ (v : ℕ) :\n    decode (α := List α) (succ v) =\n      (· :: ·) <$> decode (α := α) v.unpair.1 <*> decode (α := List α) v.unpair.2 :=\n  show decodeList (succ v) = _ by\n    cases' e : unpair v with v₁ v₂\n    simp [decodeList, e]; rfl\n\n"}
{"name":"Encodable.length_le_encode","module":"Mathlib.Logic.Equiv.List","initialProofState":"α : Type u_1\ninst✝ : Encodable α\nl : List α\n⊢ LE.le l.length (Encodable.encode l)","decl":"theorem length_le_encode : ∀ l : List α, length l ≤ encode l\n  | [] => Nat.zero_le _\n  | _ :: l => succ_le_succ <| (length_le_encode l).trans (right_le_pair _ _)\n\n"}
{"name":"Multiset.countable","module":"Mathlib.Logic.Equiv.List","initialProofState":"α : Type u_2\ninst✝ : Countable α\n⊢ Countable (Multiset α)","decl":"/-- If `α` is countable, then so is `Multiset α`. -/\ninstance _root_.Multiset.countable {α : Type*} [Countable α] : Countable (Multiset α) :=\n  Quotient.countable\n\n"}
{"name":"Encodable.List.Vector.countable","module":"Mathlib.Logic.Equiv.List","initialProofState":"α : Type u_1\ninst✝ : Countable α\nn : Nat\n⊢ Countable (List.Vector α n)","decl":"/-- If `α` is countable, then so is `Vector α n`. -/\ninstance List.Vector.countable [Countable α] {n} : Countable (List.Vector α n) :=\n  Subtype.countable\n\n"}
{"name":"Finset.countable","module":"Mathlib.Logic.Equiv.List","initialProofState":"α : Type u_1\ninst✝ : Countable α\n⊢ Countable (Finset α)","decl":"/-- If `α` is countable, then so is `Finset α`. -/\ninstance _root_.Finset.countable [Countable α] : Countable (Finset α) :=\n  Finset.val_injective.countable\n\n-- TODO: Unify with `fintypePi` and find a better name\n"}
{"name":"Encodable.mem_sortedUniv","module":"Mathlib.Logic.Equiv.List","initialProofState":"α : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Encodable α\nx : α\n⊢ Membership.mem (Encodable.sortedUniv α) x","decl":"@[simp]\ntheorem mem_sortedUniv {α} [Fintype α] [Encodable α] (x : α) : x ∈ sortedUniv α :=\n  (Finset.mem_sort _).2 (Finset.mem_univ _)\n\n"}
{"name":"Encodable.length_sortedUniv","module":"Mathlib.Logic.Equiv.List","initialProofState":"α : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Encodable α\n⊢ Eq (Encodable.sortedUniv α).length (Fintype.card α)","decl":"@[simp]\ntheorem length_sortedUniv (α) [Fintype α] [Encodable α] : (sortedUniv α).length = Fintype.card α :=\n  Finset.length_sort _\n\n"}
{"name":"Encodable.sortedUniv_nodup","module":"Mathlib.Logic.Equiv.List","initialProofState":"α : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Encodable α\n⊢ (Encodable.sortedUniv α).Nodup","decl":"@[simp]\ntheorem sortedUniv_nodup (α) [Fintype α] [Encodable α] : (sortedUniv α).Nodup :=\n  Finset.sort_nodup _ _\n\n"}
{"name":"Encodable.sortedUniv_toFinset","module":"Mathlib.Logic.Equiv.List","initialProofState":"α : Type u_2\ninst✝² : Fintype α\ninst✝¹ : Encodable α\ninst✝ : DecidableEq α\n⊢ Eq (Encodable.sortedUniv α).toFinset Finset.univ","decl":"@[simp]\ntheorem sortedUniv_toFinset (α) [Fintype α] [Encodable α] [DecidableEq α] :\n    (sortedUniv α).toFinset = Finset.univ :=\n  Finset.sort_toFinset _ _\n\n"}
{"name":"Denumerable.denumerable_list_aux","module":"Mathlib.Logic.Equiv.List","initialProofState":"α : Type u_1\ninst✝ : Denumerable α\nn : Nat\n⊢ Exists fun a => And (Membership.mem (Encodable.decodeList n) a) (Eq (Encodable.encodeList a) n)","decl":"@[nolint unusedHavesSuffices] -- Porting note: false positive\ntheorem denumerable_list_aux : ∀ n : ℕ, ∃ a ∈ @decodeList α _ n, encodeList a = n\n  | 0 => by rw [decodeList]; exact ⟨_, rfl, rfl⟩\n  | succ v => by\n    cases' e : unpair v with v₁ v₂\n    have h := unpair_right_le v\n    rw [e] at h\n    rcases have : v₂ < succ v := lt_succ_of_le h\n      denumerable_list_aux v₂ with\n      ⟨a, h₁, h₂⟩\n    rw [Option.mem_def] at h₁\n    use ofNat α v₁ :: a\n    simp [decodeList, e, h₂, h₁, encodeList, pair_unpair' e]\n\n"}
{"name":"Denumerable.list_ofNat_zero","module":"Mathlib.Logic.Equiv.List","initialProofState":"α : Type u_1\ninst✝ : Denumerable α\n⊢ Eq (Denumerable.ofNat (List α) 0) List.nil","decl":"@[simp]\ntheorem list_ofNat_zero : ofNat (List α) 0 = [] := by rw [← @encode_list_nil α, ofNat_encode]\n\n"}
{"name":"Denumerable.list_ofNat_succ","module":"Mathlib.Logic.Equiv.List","initialProofState":"α : Type u_1\ninst✝ : Denumerable α\nv : Nat\n⊢ Eq (Denumerable.ofNat (List α) v.succ) (List.cons (Denumerable.ofNat α (Nat.unpair v).1) (Denumerable.ofNat (List α) (Nat.unpair v).2))","decl":"@[simp, nolint unusedHavesSuffices] -- Porting note: false positive\ntheorem list_ofNat_succ (v : ℕ) :\n    ofNat (List α) (succ v) = ofNat α v.unpair.1 :: ofNat (List α) v.unpair.2 :=\n  ofNat_of_decode <|\n    show decodeList (succ v) = _ by\n      cases' e : unpair v with v₁ v₂\n      simp [decodeList, e]\n      rw [show decodeList v₂ = decode (α := List α) v₂ from rfl, decode_eq_ofNat, Option.seq_some]\n\n"}
{"name":"Denumerable.lower_raise","module":"Mathlib.Logic.Equiv.List","initialProofState":"l : List Nat\nn : Nat\n⊢ Eq (Denumerable.lower (Denumerable.raise l n) n) l","decl":"theorem lower_raise : ∀ l n, lower (raise l n) n = l\n  | [], _ => rfl\n  | m :: l, n => by rw [raise, lower, Nat.add_sub_cancel_right, lower_raise l]\n\n"}
{"name":"Denumerable.raise_lower","module":"Mathlib.Logic.Equiv.List","initialProofState":"l : List Nat\nn : Nat\na✝ : List.Sorted (fun x1 x2 => LE.le x1 x2) (List.cons n l)\n⊢ Eq (Denumerable.raise (Denumerable.lower l n) n) l","decl":"theorem raise_lower : ∀ {l n}, List.Sorted (· ≤ ·) (n :: l) → raise (lower l n) n = l\n  | [], _, _ => rfl\n  | m :: l, n, h => by\n    have : n ≤ m := List.rel_of_sorted_cons h _ (l.mem_cons_self _)\n    simp [raise, lower, Nat.sub_add_cancel this, raise_lower h.of_cons]\n\n"}
{"name":"Denumerable.raise_chain","module":"Mathlib.Logic.Equiv.List","initialProofState":"l : List Nat\nn : Nat\n⊢ List.Chain (fun x1 x2 => LE.le x1 x2) n (Denumerable.raise l n)","decl":"theorem raise_chain : ∀ l n, List.Chain (· ≤ ·) n (raise l n)\n  | [], _ => List.Chain.nil\n  | _ :: _, _ => List.Chain.cons (Nat.le_add_left _ _) (raise_chain _ _)\n\n"}
{"name":"Denumerable.raise_sorted","module":"Mathlib.Logic.Equiv.List","initialProofState":"l : List Nat\nn : Nat\n⊢ List.Sorted (fun x1 x2 => LE.le x1 x2) (Denumerable.raise l n)","decl":"/-- `raise l n` is a non-decreasing sequence. -/\ntheorem raise_sorted : ∀ l n, List.Sorted (· ≤ ·) (raise l n)\n  | [], _ => List.sorted_nil\n  | _ :: _, _ => List.chain_iff_pairwise.1 (raise_chain _ _)\n\n"}
{"name":"Denumerable.lower_raise'","module":"Mathlib.Logic.Equiv.List","initialProofState":"l : List Nat\nn : Nat\n⊢ Eq (Denumerable.lower' (Denumerable.raise' l n) n) l","decl":"theorem lower_raise' : ∀ l n, lower' (raise' l n) n = l\n  | [], _ => rfl\n  | m :: l, n => by simp [raise', lower', add_tsub_cancel_right, lower_raise']\n\n"}
{"name":"Denumerable.raise_lower'","module":"Mathlib.Logic.Equiv.List","initialProofState":"l : List Nat\nn : Nat\na✝¹ : ∀ (m : Nat), Membership.mem l m → LE.le n m\na✝ : List.Sorted (fun x1 x2 => LT.lt x1 x2) l\n⊢ Eq (Denumerable.raise' (Denumerable.lower' l n) n) l","decl":"theorem raise_lower' : ∀ {l n}, (∀ m ∈ l, n ≤ m) → List.Sorted (· < ·) l → raise' (lower' l n) n = l\n  | [], _, _, _ => rfl\n  | m :: l, n, h₁, h₂ => by\n    have : n ≤ m := h₁ _ (l.mem_cons_self _)\n    simp [raise', lower', Nat.sub_add_cancel this,\n      raise_lower' (List.rel_of_sorted_cons h₂ : ∀ a ∈ l, m < a) h₂.of_cons]\n\n"}
{"name":"Denumerable.raise'_chain","module":"Mathlib.Logic.Equiv.List","initialProofState":"l : List Nat\nm n : Nat\na✝ : LT.lt m n\n⊢ List.Chain (fun x1 x2 => LT.lt x1 x2) m (Denumerable.raise' l n)","decl":"theorem raise'_chain : ∀ (l) {m n}, m < n → List.Chain (· < ·) m (raise' l n)\n  | [], _, _, _ => List.Chain.nil\n  | _ :: _, _, _, h =>\n    List.Chain.cons (lt_of_lt_of_le h (Nat.le_add_left _ _)) (raise'_chain _ (lt_succ_self _))\n\n"}
{"name":"Denumerable.raise'_sorted","module":"Mathlib.Logic.Equiv.List","initialProofState":"l : List Nat\nn : Nat\n⊢ List.Sorted (fun x1 x2 => LT.lt x1 x2) (Denumerable.raise' l n)","decl":"/-- `raise' l n` is a strictly increasing sequence. -/\ntheorem raise'_sorted : ∀ l n, List.Sorted (· < ·) (raise' l n)\n  | [], _ => List.sorted_nil\n  | _ :: _, _ => List.chain_iff_pairwise.1 (raise'_chain _ (lt_succ_self _))\n\n"}
