{"name":"AddGroupExtension.mk.injEq","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\ninl✝ : AddMonoidHom N E\nrightHom✝ : AddMonoidHom E G\ninl_injective✝ : Function.Injective ⇑inl✝\nrange_inl_eq_ker_rightHom✝ : Eq inl✝.range rightHom✝.ker\nrightHom_surjective✝ : Function.Surjective ⇑rightHom✝\ninl : AddMonoidHom N E\nrightHom : AddMonoidHom E G\ninl_injective : Function.Injective ⇑inl\nrange_inl_eq_ker_rightHom : Eq inl.range rightHom.ker\nrightHom_surjective : Function.Surjective ⇑rightHom\n⊢ Eq (Eq { inl := inl✝, rightHom := rightHom✝, inl_injective := inl_injective✝, range_inl_eq_ker_rightHom := range_inl_eq_ker_rightHom✝, rightHom_surjective := rightHom_surjective✝ } { inl := inl, rightHom := rightHom, inl_injective := inl_injective, range_inl_eq_ker_rightHom := range_inl_eq_ker_rightHom, rightHom_surjective := rightHom_surjective }) (And (Eq inl✝ inl) (Eq rightHom✝ rightHom))","decl":"/-- `AddGroupExtension N E G` is a short exact sequence of additive groups `0 → N → E → G → 0`. -/\nstructure AddGroupExtension [AddGroup N] [AddGroup E] [AddGroup G] where\n  /-- The inclusion homomorphism `N →+ E` -/\n  inl : N →+ E\n  /-- The projection homomorphism `E →+ G` -/\n  rightHom : E →+ G\n  /-- The inclusion map is injective. -/\n  inl_injective : Function.Injective inl\n  /-- The range of the inclusion map is equal to the kernel of the projection map. -/\n  range_inl_eq_ker_rightHom : inl.range = rightHom.ker\n  /-- The projection map is surjective. -/\n  rightHom_surjective : Function.Surjective rightHom\n\n"}
{"name":"AddGroupExtension.inl_injective","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\nself : AddGroupExtension N E G\n⊢ Function.Injective ⇑self.inl","decl":"/-- `AddGroupExtension N E G` is a short exact sequence of additive groups `0 → N → E → G → 0`. -/\nstructure AddGroupExtension [AddGroup N] [AddGroup E] [AddGroup G] where\n  /-- The inclusion homomorphism `N →+ E` -/\n  inl : N →+ E\n  /-- The projection homomorphism `E →+ G` -/\n  rightHom : E →+ G\n  /-- The inclusion map is injective. -/\n  inl_injective : Function.Injective inl\n  /-- The range of the inclusion map is equal to the kernel of the projection map. -/\n  range_inl_eq_ker_rightHom : inl.range = rightHom.ker\n  /-- The projection map is surjective. -/\n  rightHom_surjective : Function.Surjective rightHom\n\n"}
{"name":"AddGroupExtension.mk.inj","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\ninl✝ : AddMonoidHom N E\nrightHom✝ : AddMonoidHom E G\ninl_injective✝ : Function.Injective ⇑inl✝\nrange_inl_eq_ker_rightHom✝ : Eq inl✝.range rightHom✝.ker\nrightHom_surjective✝ : Function.Surjective ⇑rightHom✝\ninl : AddMonoidHom N E\nrightHom : AddMonoidHom E G\ninl_injective : Function.Injective ⇑inl\nrange_inl_eq_ker_rightHom : Eq inl.range rightHom.ker\nrightHom_surjective : Function.Surjective ⇑rightHom\nx✝ : Eq { inl := inl✝, rightHom := rightHom✝, inl_injective := inl_injective✝, range_inl_eq_ker_rightHom := range_inl_eq_ker_rightHom✝, rightHom_surjective := rightHom_surjective✝ } { inl := inl, rightHom := rightHom, inl_injective := inl_injective, range_inl_eq_ker_rightHom := range_inl_eq_ker_rightHom, rightHom_surjective := rightHom_surjective }\n⊢ And (Eq inl✝ inl) (Eq rightHom✝ rightHom)","decl":"/-- `AddGroupExtension N E G` is a short exact sequence of additive groups `0 → N → E → G → 0`. -/\nstructure AddGroupExtension [AddGroup N] [AddGroup E] [AddGroup G] where\n  /-- The inclusion homomorphism `N →+ E` -/\n  inl : N →+ E\n  /-- The projection homomorphism `E →+ G` -/\n  rightHom : E →+ G\n  /-- The inclusion map is injective. -/\n  inl_injective : Function.Injective inl\n  /-- The range of the inclusion map is equal to the kernel of the projection map. -/\n  range_inl_eq_ker_rightHom : inl.range = rightHom.ker\n  /-- The projection map is surjective. -/\n  rightHom_surjective : Function.Surjective rightHom\n\n"}
{"name":"AddGroupExtension.mk.sizeOf_spec","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝⁵ : AddGroup N\ninst✝⁴ : AddGroup E\ninst✝³ : AddGroup G\ninst✝² : SizeOf N\ninst✝¹ : SizeOf E\ninst✝ : SizeOf G\ninl : AddMonoidHom N E\nrightHom : AddMonoidHom E G\ninl_injective : Function.Injective ⇑inl\nrange_inl_eq_ker_rightHom : Eq inl.range rightHom.ker\nrightHom_surjective : Function.Surjective ⇑rightHom\n⊢ Eq (SizeOf.sizeOf { inl := inl, rightHom := rightHom, inl_injective := inl_injective, range_inl_eq_ker_rightHom := range_inl_eq_ker_rightHom, rightHom_surjective := rightHom_surjective }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf inl)) (SizeOf.sizeOf rightHom)) (SizeOf.sizeOf range_inl_eq_ker_rightHom))","decl":"/-- `AddGroupExtension N E G` is a short exact sequence of additive groups `0 → N → E → G → 0`. -/\nstructure AddGroupExtension [AddGroup N] [AddGroup E] [AddGroup G] where\n  /-- The inclusion homomorphism `N →+ E` -/\n  inl : N →+ E\n  /-- The projection homomorphism `E →+ G` -/\n  rightHom : E →+ G\n  /-- The inclusion map is injective. -/\n  inl_injective : Function.Injective inl\n  /-- The range of the inclusion map is equal to the kernel of the projection map. -/\n  range_inl_eq_ker_rightHom : inl.range = rightHom.ker\n  /-- The projection map is surjective. -/\n  rightHom_surjective : Function.Surjective rightHom\n\n"}
{"name":"AddGroupExtension.rightHom_surjective","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\nself : AddGroupExtension N E G\n⊢ Function.Surjective ⇑self.rightHom","decl":"/-- `AddGroupExtension N E G` is a short exact sequence of additive groups `0 → N → E → G → 0`. -/\nstructure AddGroupExtension [AddGroup N] [AddGroup E] [AddGroup G] where\n  /-- The inclusion homomorphism `N →+ E` -/\n  inl : N →+ E\n  /-- The projection homomorphism `E →+ G` -/\n  rightHom : E →+ G\n  /-- The inclusion map is injective. -/\n  inl_injective : Function.Injective inl\n  /-- The range of the inclusion map is equal to the kernel of the projection map. -/\n  range_inl_eq_ker_rightHom : inl.range = rightHom.ker\n  /-- The projection map is surjective. -/\n  rightHom_surjective : Function.Surjective rightHom\n\n"}
{"name":"AddGroupExtension.range_inl_eq_ker_rightHom","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\nself : AddGroupExtension N E G\n⊢ Eq self.inl.range self.rightHom.ker","decl":"/-- `AddGroupExtension N E G` is a short exact sequence of additive groups `0 → N → E → G → 0`. -/\nstructure AddGroupExtension [AddGroup N] [AddGroup E] [AddGroup G] where\n  /-- The inclusion homomorphism `N →+ E` -/\n  inl : N →+ E\n  /-- The projection homomorphism `E →+ G` -/\n  rightHom : E →+ G\n  /-- The inclusion map is injective. -/\n  inl_injective : Function.Injective inl\n  /-- The range of the inclusion map is equal to the kernel of the projection map. -/\n  range_inl_eq_ker_rightHom : inl.range = rightHom.ker\n  /-- The projection map is surjective. -/\n  rightHom_surjective : Function.Surjective rightHom\n\n"}
{"name":"GroupExtension.mk.inj","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\ninl✝ : MonoidHom N E\nrightHom✝ : MonoidHom E G\ninl_injective✝ : Function.Injective ⇑inl✝\nrange_inl_eq_ker_rightHom✝ : Eq inl✝.range rightHom✝.ker\nrightHom_surjective✝ : Function.Surjective ⇑rightHom✝\ninl : MonoidHom N E\nrightHom : MonoidHom E G\ninl_injective : Function.Injective ⇑inl\nrange_inl_eq_ker_rightHom : Eq inl.range rightHom.ker\nrightHom_surjective : Function.Surjective ⇑rightHom\nx✝ : Eq { inl := inl✝, rightHom := rightHom✝, inl_injective := inl_injective✝, range_inl_eq_ker_rightHom := range_inl_eq_ker_rightHom✝, rightHom_surjective := rightHom_surjective✝ } { inl := inl, rightHom := rightHom, inl_injective := inl_injective, range_inl_eq_ker_rightHom := range_inl_eq_ker_rightHom, rightHom_surjective := rightHom_surjective }\n⊢ And (Eq inl✝ inl) (Eq rightHom✝ rightHom)","decl":"/-- `GroupExtension N E G` is a short exact sequence of groups `1 → N → E → G → 1`. -/\n@[to_additive]\nstructure GroupExtension [Group N] [Group E] [Group G] where\n  /-- The inclusion homomorphism `N →* E` -/\n  inl : N →* E\n  /-- The projection homomorphism `E →* G` -/\n  rightHom : E →* G\n  /-- The inclusion map is injective. -/\n  inl_injective : Function.Injective inl\n  /-- The range of the inclusion map is equal to the kernel of the projection map. -/\n  range_inl_eq_ker_rightHom : inl.range = rightHom.ker\n  /-- The projection map is surjective. -/\n  rightHom_surjective : Function.Surjective rightHom\n\n"}
{"name":"GroupExtension.mk.sizeOf_spec","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝⁵ : Group N\ninst✝⁴ : Group E\ninst✝³ : Group G\ninst✝² : SizeOf N\ninst✝¹ : SizeOf E\ninst✝ : SizeOf G\ninl : MonoidHom N E\nrightHom : MonoidHom E G\ninl_injective : Function.Injective ⇑inl\nrange_inl_eq_ker_rightHom : Eq inl.range rightHom.ker\nrightHom_surjective : Function.Surjective ⇑rightHom\n⊢ Eq (SizeOf.sizeOf { inl := inl, rightHom := rightHom, inl_injective := inl_injective, range_inl_eq_ker_rightHom := range_inl_eq_ker_rightHom, rightHom_surjective := rightHom_surjective }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf inl)) (SizeOf.sizeOf rightHom)) (SizeOf.sizeOf range_inl_eq_ker_rightHom))","decl":"/-- `GroupExtension N E G` is a short exact sequence of groups `1 → N → E → G → 1`. -/\n@[to_additive]\nstructure GroupExtension [Group N] [Group E] [Group G] where\n  /-- The inclusion homomorphism `N →* E` -/\n  inl : N →* E\n  /-- The projection homomorphism `E →* G` -/\n  rightHom : E →* G\n  /-- The inclusion map is injective. -/\n  inl_injective : Function.Injective inl\n  /-- The range of the inclusion map is equal to the kernel of the projection map. -/\n  range_inl_eq_ker_rightHom : inl.range = rightHom.ker\n  /-- The projection map is surjective. -/\n  rightHom_surjective : Function.Surjective rightHom\n\n"}
{"name":"GroupExtension.mk.injEq","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\ninl✝ : MonoidHom N E\nrightHom✝ : MonoidHom E G\ninl_injective✝ : Function.Injective ⇑inl✝\nrange_inl_eq_ker_rightHom✝ : Eq inl✝.range rightHom✝.ker\nrightHom_surjective✝ : Function.Surjective ⇑rightHom✝\ninl : MonoidHom N E\nrightHom : MonoidHom E G\ninl_injective : Function.Injective ⇑inl\nrange_inl_eq_ker_rightHom : Eq inl.range rightHom.ker\nrightHom_surjective : Function.Surjective ⇑rightHom\n⊢ Eq (Eq { inl := inl✝, rightHom := rightHom✝, inl_injective := inl_injective✝, range_inl_eq_ker_rightHom := range_inl_eq_ker_rightHom✝, rightHom_surjective := rightHom_surjective✝ } { inl := inl, rightHom := rightHom, inl_injective := inl_injective, range_inl_eq_ker_rightHom := range_inl_eq_ker_rightHom, rightHom_surjective := rightHom_surjective }) (And (Eq inl✝ inl) (Eq rightHom✝ rightHom))","decl":"/-- `GroupExtension N E G` is a short exact sequence of groups `1 → N → E → G → 1`. -/\n@[to_additive]\nstructure GroupExtension [Group N] [Group E] [Group G] where\n  /-- The inclusion homomorphism `N →* E` -/\n  inl : N →* E\n  /-- The projection homomorphism `E →* G` -/\n  rightHom : E →* G\n  /-- The inclusion map is injective. -/\n  inl_injective : Function.Injective inl\n  /-- The range of the inclusion map is equal to the kernel of the projection map. -/\n  range_inl_eq_ker_rightHom : inl.range = rightHom.ker\n  /-- The projection map is surjective. -/\n  rightHom_surjective : Function.Surjective rightHom\n\n"}
{"name":"GroupExtension.rightHom_surjective","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\nself : GroupExtension N E G\n⊢ Function.Surjective ⇑self.rightHom","decl":"/-- `GroupExtension N E G` is a short exact sequence of groups `1 → N → E → G → 1`. -/\n@[to_additive]\nstructure GroupExtension [Group N] [Group E] [Group G] where\n  /-- The inclusion homomorphism `N →* E` -/\n  inl : N →* E\n  /-- The projection homomorphism `E →* G` -/\n  rightHom : E →* G\n  /-- The inclusion map is injective. -/\n  inl_injective : Function.Injective inl\n  /-- The range of the inclusion map is equal to the kernel of the projection map. -/\n  range_inl_eq_ker_rightHom : inl.range = rightHom.ker\n  /-- The projection map is surjective. -/\n  rightHom_surjective : Function.Surjective rightHom\n\n"}
{"name":"GroupExtension.range_inl_eq_ker_rightHom","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\nself : GroupExtension N E G\n⊢ Eq self.inl.range self.rightHom.ker","decl":"/-- `GroupExtension N E G` is a short exact sequence of groups `1 → N → E → G → 1`. -/\n@[to_additive]\nstructure GroupExtension [Group N] [Group E] [Group G] where\n  /-- The inclusion homomorphism `N →* E` -/\n  inl : N →* E\n  /-- The projection homomorphism `E →* G` -/\n  rightHom : E →* G\n  /-- The inclusion map is injective. -/\n  inl_injective : Function.Injective inl\n  /-- The range of the inclusion map is equal to the kernel of the projection map. -/\n  range_inl_eq_ker_rightHom : inl.range = rightHom.ker\n  /-- The projection map is surjective. -/\n  rightHom_surjective : Function.Surjective rightHom\n\n"}
{"name":"GroupExtension.inl_injective","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\nself : GroupExtension N E G\n⊢ Function.Injective ⇑self.inl","decl":"/-- `GroupExtension N E G` is a short exact sequence of groups `1 → N → E → G → 1`. -/\n@[to_additive]\nstructure GroupExtension [Group N] [Group E] [Group G] where\n  /-- The inclusion homomorphism `N →* E` -/\n  inl : N →* E\n  /-- The projection homomorphism `E →* G` -/\n  rightHom : E →* G\n  /-- The inclusion map is injective. -/\n  inl_injective : Function.Injective inl\n  /-- The range of the inclusion map is equal to the kernel of the projection map. -/\n  range_inl_eq_ker_rightHom : inl.range = rightHom.ker\n  /-- The projection map is surjective. -/\n  rightHom_surjective : Function.Surjective rightHom\n\n"}
{"name":"AddGroupExtension.Equiv.mk.injEq","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝³ : AddGroup N\ninst✝² : AddGroup E\ninst✝¹ : AddGroup G\nS : AddGroupExtension N E G\nE' : Type u_4\ninst✝ : AddGroup E'\nS' : AddGroupExtension N E' G\ntoAddMonoidHom✝ : AddMonoidHom E E'\ninl_comm✝ : Eq (toAddMonoidHom✝.comp S.inl) S'.inl\nrightHom_comm✝ : Eq (S'.rightHom.comp toAddMonoidHom✝) S.rightHom\ntoAddMonoidHom : AddMonoidHom E E'\ninl_comm : Eq (toAddMonoidHom.comp S.inl) S'.inl\nrightHom_comm : Eq (S'.rightHom.comp toAddMonoidHom) S.rightHom\n⊢ Eq (Eq { toAddMonoidHom := toAddMonoidHom✝, inl_comm := inl_comm✝, rightHom_comm := rightHom_comm✝ } { toAddMonoidHom := toAddMonoidHom, inl_comm := inl_comm, rightHom_comm := rightHom_comm }) (Eq toAddMonoidHom✝ toAddMonoidHom)","decl":"/-- `AddGroupExtension`s are equivalent iff there is a homomorphism making a commuting diagram. -/\nstructure Equiv {E' : Type*} [AddGroup E'] (S' : AddGroupExtension N E' G) extends E →+ E' where\n  /-- The left-hand side of the diagram commutes. -/\n  inl_comm : toAddMonoidHom.comp S.inl = S'.inl\n  /-- The right-hand side of the diagram commutes. -/\n  rightHom_comm : S'.rightHom.comp toAddMonoidHom = S.rightHom\n\n"}
{"name":"AddGroupExtension.Equiv.inl_comm","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝³ : AddGroup N\ninst✝² : AddGroup E\ninst✝¹ : AddGroup G\nS : AddGroupExtension N E G\nE' : Type u_4\ninst✝ : AddGroup E'\nS' : AddGroupExtension N E' G\nself : S.Equiv S'\n⊢ Eq (self.comp S.inl) S'.inl","decl":"/-- `AddGroupExtension`s are equivalent iff there is a homomorphism making a commuting diagram. -/\nstructure Equiv {E' : Type*} [AddGroup E'] (S' : AddGroupExtension N E' G) extends E →+ E' where\n  /-- The left-hand side of the diagram commutes. -/\n  inl_comm : toAddMonoidHom.comp S.inl = S'.inl\n  /-- The right-hand side of the diagram commutes. -/\n  rightHom_comm : S'.rightHom.comp toAddMonoidHom = S.rightHom\n\n"}
{"name":"AddGroupExtension.Equiv.mk.sizeOf_spec","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝⁷ : AddGroup N\ninst✝⁶ : AddGroup E\ninst✝⁵ : AddGroup G\nS : AddGroupExtension N E G\nE' : Type u_4\ninst✝⁴ : AddGroup E'\nS' : AddGroupExtension N E' G\ninst✝³ : SizeOf N\ninst✝² : SizeOf E\ninst✝¹ : SizeOf G\ninst✝ : SizeOf E'\ntoAddMonoidHom : AddMonoidHom E E'\ninl_comm : Eq (toAddMonoidHom.comp S.inl) S'.inl\nrightHom_comm : Eq (S'.rightHom.comp toAddMonoidHom) S.rightHom\n⊢ Eq (SizeOf.sizeOf { toAddMonoidHom := toAddMonoidHom, inl_comm := inl_comm, rightHom_comm := rightHom_comm }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toAddMonoidHom)) (SizeOf.sizeOf inl_comm)) (SizeOf.sizeOf rightHom_comm))","decl":"/-- `AddGroupExtension`s are equivalent iff there is a homomorphism making a commuting diagram. -/\nstructure Equiv {E' : Type*} [AddGroup E'] (S' : AddGroupExtension N E' G) extends E →+ E' where\n  /-- The left-hand side of the diagram commutes. -/\n  inl_comm : toAddMonoidHom.comp S.inl = S'.inl\n  /-- The right-hand side of the diagram commutes. -/\n  rightHom_comm : S'.rightHom.comp toAddMonoidHom = S.rightHom\n\n"}
{"name":"AddGroupExtension.Equiv.rightHom_comm","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝³ : AddGroup N\ninst✝² : AddGroup E\ninst✝¹ : AddGroup G\nS : AddGroupExtension N E G\nE' : Type u_4\ninst✝ : AddGroup E'\nS' : AddGroupExtension N E' G\nself : S.Equiv S'\n⊢ Eq (S'.rightHom.comp self.toAddMonoidHom) S.rightHom","decl":"/-- `AddGroupExtension`s are equivalent iff there is a homomorphism making a commuting diagram. -/\nstructure Equiv {E' : Type*} [AddGroup E'] (S' : AddGroupExtension N E' G) extends E →+ E' where\n  /-- The left-hand side of the diagram commutes. -/\n  inl_comm : toAddMonoidHom.comp S.inl = S'.inl\n  /-- The right-hand side of the diagram commutes. -/\n  rightHom_comm : S'.rightHom.comp toAddMonoidHom = S.rightHom\n\n"}
{"name":"AddGroupExtension.Equiv.mk.inj","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝³ : AddGroup N\ninst✝² : AddGroup E\ninst✝¹ : AddGroup G\nS : AddGroupExtension N E G\nE' : Type u_4\ninst✝ : AddGroup E'\nS' : AddGroupExtension N E' G\ntoAddMonoidHom✝ : AddMonoidHom E E'\ninl_comm✝ : Eq (toAddMonoidHom✝.comp S.inl) S'.inl\nrightHom_comm✝ : Eq (S'.rightHom.comp toAddMonoidHom✝) S.rightHom\ntoAddMonoidHom : AddMonoidHom E E'\ninl_comm : Eq (toAddMonoidHom.comp S.inl) S'.inl\nrightHom_comm : Eq (S'.rightHom.comp toAddMonoidHom) S.rightHom\nx✝ : Eq { toAddMonoidHom := toAddMonoidHom✝, inl_comm := inl_comm✝, rightHom_comm := rightHom_comm✝ } { toAddMonoidHom := toAddMonoidHom, inl_comm := inl_comm, rightHom_comm := rightHom_comm }\n⊢ Eq toAddMonoidHom✝ toAddMonoidHom","decl":"/-- `AddGroupExtension`s are equivalent iff there is a homomorphism making a commuting diagram. -/\nstructure Equiv {E' : Type*} [AddGroup E'] (S' : AddGroupExtension N E' G) extends E →+ E' where\n  /-- The left-hand side of the diagram commutes. -/\n  inl_comm : toAddMonoidHom.comp S.inl = S'.inl\n  /-- The right-hand side of the diagram commutes. -/\n  rightHom_comm : S'.rightHom.comp toAddMonoidHom = S.rightHom\n\n"}
{"name":"AddGroupExtension.Section.rightInverse_rightHom","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\nS : AddGroupExtension N E G\nself : S.Section\n⊢ Function.RightInverse self.toFun ⇑S.rightHom","decl":"/-- `Section` of an additive group extension is a right inverse to `S.rightHom`. -/\nstructure Section where\n  /-- The underlying function -/\n  toFun : G → E\n  /-- `Section` is a right inverse to `S.rightHom` -/\n  rightInverse_rightHom : Function.RightInverse toFun S.rightHom\n\n"}
{"name":"AddGroupExtension.Section.mk.sizeOf_spec","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝⁵ : AddGroup N\ninst✝⁴ : AddGroup E\ninst✝³ : AddGroup G\nS : AddGroupExtension N E G\ninst✝² : SizeOf N\ninst✝¹ : SizeOf E\ninst✝ : SizeOf G\ntoFun : G → E\nrightInverse_rightHom : Function.RightInverse toFun ⇑S.rightHom\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, rightInverse_rightHom := rightInverse_rightHom }) 1","decl":"/-- `Section` of an additive group extension is a right inverse to `S.rightHom`. -/\nstructure Section where\n  /-- The underlying function -/\n  toFun : G → E\n  /-- `Section` is a right inverse to `S.rightHom` -/\n  rightInverse_rightHom : Function.RightInverse toFun S.rightHom\n\n"}
{"name":"AddGroupExtension.Section.mk.inj","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\nS : AddGroupExtension N E G\ntoFun✝ : G → E\nrightInverse_rightHom✝ : Function.RightInverse toFun✝ ⇑S.rightHom\ntoFun : G → E\nrightInverse_rightHom : Function.RightInverse toFun ⇑S.rightHom\nx✝ : Eq { toFun := toFun✝, rightInverse_rightHom := rightInverse_rightHom✝ } { toFun := toFun, rightInverse_rightHom := rightInverse_rightHom }\n⊢ Eq toFun✝ toFun","decl":"/-- `Section` of an additive group extension is a right inverse to `S.rightHom`. -/\nstructure Section where\n  /-- The underlying function -/\n  toFun : G → E\n  /-- `Section` is a right inverse to `S.rightHom` -/\n  rightInverse_rightHom : Function.RightInverse toFun S.rightHom\n\n"}
{"name":"AddGroupExtension.Section.mk.injEq","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\nS : AddGroupExtension N E G\ntoFun✝ : G → E\nrightInverse_rightHom✝ : Function.RightInverse toFun✝ ⇑S.rightHom\ntoFun : G → E\nrightInverse_rightHom : Function.RightInverse toFun ⇑S.rightHom\n⊢ Eq (Eq { toFun := toFun✝, rightInverse_rightHom := rightInverse_rightHom✝ } { toFun := toFun, rightInverse_rightHom := rightInverse_rightHom }) (Eq toFun✝ toFun)","decl":"/-- `Section` of an additive group extension is a right inverse to `S.rightHom`. -/\nstructure Section where\n  /-- The underlying function -/\n  toFun : G → E\n  /-- `Section` is a right inverse to `S.rightHom` -/\n  rightInverse_rightHom : Function.RightInverse toFun S.rightHom\n\n"}
{"name":"AddGroupExtension.Splitting.mk.sizeOf_spec","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝⁵ : AddGroup N\ninst✝⁴ : AddGroup E\ninst✝³ : AddGroup G\nS : AddGroupExtension N E G\ninst✝² : SizeOf N\ninst✝¹ : SizeOf E\ninst✝ : SizeOf G\ntoAddMonoidHom : AddMonoidHom G E\nrightInverse_rightHom : Function.RightInverse (↑toAddMonoidHom).toFun ⇑S.rightHom\n⊢ Eq (SizeOf.sizeOf { toAddMonoidHom := toAddMonoidHom, rightInverse_rightHom := rightInverse_rightHom }) (HAdd.hAdd 1 (SizeOf.sizeOf toAddMonoidHom))","decl":"/-- `Splitting` of an additive group extension is a section homomorphism. -/\nstructure Splitting extends G →+ E, S.Section\n\n"}
{"name":"AddGroupExtension.Splitting.mk.inj","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\nS : AddGroupExtension N E G\ntoAddMonoidHom✝ : AddMonoidHom G E\nrightInverse_rightHom✝ : Function.RightInverse (↑toAddMonoidHom✝).toFun ⇑S.rightHom\ntoAddMonoidHom : AddMonoidHom G E\nrightInverse_rightHom : Function.RightInverse (↑toAddMonoidHom).toFun ⇑S.rightHom\nx✝ : Eq { toAddMonoidHom := toAddMonoidHom✝, rightInverse_rightHom := rightInverse_rightHom✝ } { toAddMonoidHom := toAddMonoidHom, rightInverse_rightHom := rightInverse_rightHom }\n⊢ Eq toAddMonoidHom✝ toAddMonoidHom","decl":"/-- `Splitting` of an additive group extension is a section homomorphism. -/\nstructure Splitting extends G →+ E, S.Section\n\n"}
{"name":"AddGroupExtension.Splitting.mk.injEq","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\nS : AddGroupExtension N E G\ntoAddMonoidHom✝ : AddMonoidHom G E\nrightInverse_rightHom✝ : Function.RightInverse (↑toAddMonoidHom✝).toFun ⇑S.rightHom\ntoAddMonoidHom : AddMonoidHom G E\nrightInverse_rightHom : Function.RightInverse (↑toAddMonoidHom).toFun ⇑S.rightHom\n⊢ Eq (Eq { toAddMonoidHom := toAddMonoidHom✝, rightInverse_rightHom := rightInverse_rightHom✝ } { toAddMonoidHom := toAddMonoidHom, rightInverse_rightHom := rightInverse_rightHom }) (Eq toAddMonoidHom✝ toAddMonoidHom)","decl":"/-- `Splitting` of an additive group extension is a section homomorphism. -/\nstructure Splitting extends G →+ E, S.Section\n\n"}
{"name":"AddGroupExtension.Splitting.rightInverse_rightHom","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\nS : AddGroupExtension N E G\nself : S.Splitting\n⊢ Function.RightInverse (↑self.toAddMonoidHom).toFun ⇑S.rightHom","decl":"/-- `Splitting` of an additive group extension is a section homomorphism. -/\nstructure Splitting extends G →+ E, S.Section\n\n"}
{"name":"GroupExtension.normal_inl_range","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\nS : GroupExtension N E G\n⊢ S.inl.range.Normal","decl":"/-- The range of the inclusion map is a normal subgroup. -/\n@[to_additive \"The range of the inclusion map is a normal additive subgroup.\" ]\ninstance normal_inl_range : S.inl.range.Normal :=\n  S.range_inl_eq_ker_rightHom ▸ S.rightHom.normal_ker\n\n"}
{"name":"AddGroupExtension.normal_inl_range","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\nS : AddGroupExtension N E G\n⊢ S.inl.range.Normal","decl":"/-- The range of the inclusion map is a normal subgroup. -/\n@[to_additive \"The range of the inclusion map is a normal additive subgroup.\" ]\ninstance normal_inl_range : S.inl.range.Normal :=\n  S.range_inl_eq_ker_rightHom ▸ S.rightHom.normal_ker\n\n"}
{"name":"GroupExtension.rightHom_inl","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\nS : GroupExtension N E G\nn : N\n⊢ Eq (S.rightHom (S.inl n)) 1","decl":"@[to_additive (attr := simp)]\ntheorem rightHom_inl (n : N) : S.rightHom (S.inl n) = 1 := by\n  rw [← MonoidHom.mem_ker, ← S.range_inl_eq_ker_rightHom, MonoidHom.mem_range]\n  exact exists_apply_eq_apply S.inl n\n\n"}
{"name":"AddGroupExtension.rightHom_inl","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\nS : AddGroupExtension N E G\nn : N\n⊢ Eq (S.rightHom (S.inl n)) 0","decl":"@[to_additive (attr := simp)]\ntheorem rightHom_inl (n : N) : S.rightHom (S.inl n) = 1 := by\n  rw [← MonoidHom.mem_ker, ← S.range_inl_eq_ker_rightHom, MonoidHom.mem_range]\n  exact exists_apply_eq_apply S.inl n\n\n"}
{"name":"GroupExtension.rightHom_comp_inl","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\nS : GroupExtension N E G\n⊢ Eq (S.rightHom.comp S.inl) 1","decl":"@[to_additive (attr := simp)]\ntheorem rightHom_comp_inl : S.rightHom.comp S.inl = 1 := by\n  ext n\n  rw [MonoidHom.one_apply, MonoidHom.comp_apply]\n  exact S.rightHom_inl n\n\n"}
{"name":"AddGroupExtension.rightHom_comp_inl","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\nS : AddGroupExtension N E G\n⊢ Eq (S.rightHom.comp S.inl) 0","decl":"@[to_additive (attr := simp)]\ntheorem rightHom_comp_inl : S.rightHom.comp S.inl = 1 := by\n  ext n\n  rw [MonoidHom.one_apply, MonoidHom.comp_apply]\n  exact S.rightHom_inl n\n\n"}
{"name":"GroupExtension.inl_conjAct_comm","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\nS : GroupExtension N E G\ne : E\nn : N\n⊢ Eq (S.inl ((S.conjAct e) n)) (HMul.hMul (HMul.hMul e (S.inl n)) (Inv.inv e))","decl":"/-- The inclusion and a conjugation commute. -/\ntheorem inl_conjAct_comm {e : E} {n : N} : S.inl (S.conjAct e n) = e * S.inl n * e⁻¹ := by\n  simp only [conjAct, MonoidHom.coe_mk, OneHom.coe_mk, MulEquiv.trans_apply,\n    MonoidHom.apply_ofInjective_symm, MulAut.conjNormal_apply, MonoidHom.ofInjective_apply]\n\n"}
{"name":"GroupExtension.Equiv.mk.sizeOf_spec","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝⁷ : Group N\ninst✝⁶ : Group E\ninst✝⁵ : Group G\nS : GroupExtension N E G\nE' : Type u_4\ninst✝⁴ : Group E'\nS' : GroupExtension N E' G\ninst✝³ : SizeOf N\ninst✝² : SizeOf E\ninst✝¹ : SizeOf G\ninst✝ : SizeOf E'\ntoMonoidHom : MonoidHom E E'\ninl_comm : Eq (toMonoidHom.comp S.inl) S'.inl\nrightHom_comm : Eq (S'.rightHom.comp toMonoidHom) S.rightHom\n⊢ Eq (SizeOf.sizeOf { toMonoidHom := toMonoidHom, inl_comm := inl_comm, rightHom_comm := rightHom_comm }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toMonoidHom)) (SizeOf.sizeOf inl_comm)) (SizeOf.sizeOf rightHom_comm))","decl":"/-- `GroupExtension`s are equivalent iff there is a homomorphism making a commuting diagram. -/\n@[to_additive]\nstructure Equiv {E' : Type*} [Group E'] (S' : GroupExtension N E' G) extends E →* E' where\n  /-- The left-hand side of the diagram commutes. -/\n  inl_comm : toMonoidHom.comp S.inl = S'.inl\n  /-- The right-hand side of the diagram commutes. -/\n  rightHom_comm : S'.rightHom.comp toMonoidHom = S.rightHom\n\n"}
{"name":"GroupExtension.Equiv.inl_comm","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝³ : Group N\ninst✝² : Group E\ninst✝¹ : Group G\nS : GroupExtension N E G\nE' : Type u_4\ninst✝ : Group E'\nS' : GroupExtension N E' G\nself : S.Equiv S'\n⊢ Eq (self.comp S.inl) S'.inl","decl":"/-- `GroupExtension`s are equivalent iff there is a homomorphism making a commuting diagram. -/\n@[to_additive]\nstructure Equiv {E' : Type*} [Group E'] (S' : GroupExtension N E' G) extends E →* E' where\n  /-- The left-hand side of the diagram commutes. -/\n  inl_comm : toMonoidHom.comp S.inl = S'.inl\n  /-- The right-hand side of the diagram commutes. -/\n  rightHom_comm : S'.rightHom.comp toMonoidHom = S.rightHom\n\n"}
{"name":"GroupExtension.Equiv.rightHom_comm","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝³ : Group N\ninst✝² : Group E\ninst✝¹ : Group G\nS : GroupExtension N E G\nE' : Type u_4\ninst✝ : Group E'\nS' : GroupExtension N E' G\nself : S.Equiv S'\n⊢ Eq (S'.rightHom.comp self.toMonoidHom) S.rightHom","decl":"/-- `GroupExtension`s are equivalent iff there is a homomorphism making a commuting diagram. -/\n@[to_additive]\nstructure Equiv {E' : Type*} [Group E'] (S' : GroupExtension N E' G) extends E →* E' where\n  /-- The left-hand side of the diagram commutes. -/\n  inl_comm : toMonoidHom.comp S.inl = S'.inl\n  /-- The right-hand side of the diagram commutes. -/\n  rightHom_comm : S'.rightHom.comp toMonoidHom = S.rightHom\n\n"}
{"name":"GroupExtension.Equiv.mk.injEq","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝³ : Group N\ninst✝² : Group E\ninst✝¹ : Group G\nS : GroupExtension N E G\nE' : Type u_4\ninst✝ : Group E'\nS' : GroupExtension N E' G\ntoMonoidHom✝ : MonoidHom E E'\ninl_comm✝ : Eq (toMonoidHom✝.comp S.inl) S'.inl\nrightHom_comm✝ : Eq (S'.rightHom.comp toMonoidHom✝) S.rightHom\ntoMonoidHom : MonoidHom E E'\ninl_comm : Eq (toMonoidHom.comp S.inl) S'.inl\nrightHom_comm : Eq (S'.rightHom.comp toMonoidHom) S.rightHom\n⊢ Eq (Eq { toMonoidHom := toMonoidHom✝, inl_comm := inl_comm✝, rightHom_comm := rightHom_comm✝ } { toMonoidHom := toMonoidHom, inl_comm := inl_comm, rightHom_comm := rightHom_comm }) (Eq toMonoidHom✝ toMonoidHom)","decl":"/-- `GroupExtension`s are equivalent iff there is a homomorphism making a commuting diagram. -/\n@[to_additive]\nstructure Equiv {E' : Type*} [Group E'] (S' : GroupExtension N E' G) extends E →* E' where\n  /-- The left-hand side of the diagram commutes. -/\n  inl_comm : toMonoidHom.comp S.inl = S'.inl\n  /-- The right-hand side of the diagram commutes. -/\n  rightHom_comm : S'.rightHom.comp toMonoidHom = S.rightHom\n\n"}
{"name":"GroupExtension.Equiv.mk.inj","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝³ : Group N\ninst✝² : Group E\ninst✝¹ : Group G\nS : GroupExtension N E G\nE' : Type u_4\ninst✝ : Group E'\nS' : GroupExtension N E' G\ntoMonoidHom✝ : MonoidHom E E'\ninl_comm✝ : Eq (toMonoidHom✝.comp S.inl) S'.inl\nrightHom_comm✝ : Eq (S'.rightHom.comp toMonoidHom✝) S.rightHom\ntoMonoidHom : MonoidHom E E'\ninl_comm : Eq (toMonoidHom.comp S.inl) S'.inl\nrightHom_comm : Eq (S'.rightHom.comp toMonoidHom) S.rightHom\nx✝ : Eq { toMonoidHom := toMonoidHom✝, inl_comm := inl_comm✝, rightHom_comm := rightHom_comm✝ } { toMonoidHom := toMonoidHom, inl_comm := inl_comm, rightHom_comm := rightHom_comm }\n⊢ Eq toMonoidHom✝ toMonoidHom","decl":"/-- `GroupExtension`s are equivalent iff there is a homomorphism making a commuting diagram. -/\n@[to_additive]\nstructure Equiv {E' : Type*} [Group E'] (S' : GroupExtension N E' G) extends E →* E' where\n  /-- The left-hand side of the diagram commutes. -/\n  inl_comm : toMonoidHom.comp S.inl = S'.inl\n  /-- The right-hand side of the diagram commutes. -/\n  rightHom_comm : S'.rightHom.comp toMonoidHom = S.rightHom\n\n"}
{"name":"GroupExtension.Section.mk.injEq","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\nS : GroupExtension N E G\ntoFun✝ : G → E\nrightInverse_rightHom✝ : Function.RightInverse toFun✝ ⇑S.rightHom\ntoFun : G → E\nrightInverse_rightHom : Function.RightInverse toFun ⇑S.rightHom\n⊢ Eq (Eq { toFun := toFun✝, rightInverse_rightHom := rightInverse_rightHom✝ } { toFun := toFun, rightInverse_rightHom := rightInverse_rightHom }) (Eq toFun✝ toFun)","decl":"/-- `Section` of a group extension is a right inverse to `S.rightHom`. -/\n@[to_additive]\nstructure Section where\n  /-- The underlying function -/\n  toFun : G → E\n  /-- `Section` is a right inverse to `S.rightHom` -/\n  rightInverse_rightHom : Function.RightInverse toFun S.rightHom\n\n"}
{"name":"GroupExtension.Section.mk.inj","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\nS : GroupExtension N E G\ntoFun✝ : G → E\nrightInverse_rightHom✝ : Function.RightInverse toFun✝ ⇑S.rightHom\ntoFun : G → E\nrightInverse_rightHom : Function.RightInverse toFun ⇑S.rightHom\nx✝ : Eq { toFun := toFun✝, rightInverse_rightHom := rightInverse_rightHom✝ } { toFun := toFun, rightInverse_rightHom := rightInverse_rightHom }\n⊢ Eq toFun✝ toFun","decl":"/-- `Section` of a group extension is a right inverse to `S.rightHom`. -/\n@[to_additive]\nstructure Section where\n  /-- The underlying function -/\n  toFun : G → E\n  /-- `Section` is a right inverse to `S.rightHom` -/\n  rightInverse_rightHom : Function.RightInverse toFun S.rightHom\n\n"}
{"name":"GroupExtension.Section.mk.sizeOf_spec","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝⁵ : Group N\ninst✝⁴ : Group E\ninst✝³ : Group G\nS : GroupExtension N E G\ninst✝² : SizeOf N\ninst✝¹ : SizeOf E\ninst✝ : SizeOf G\ntoFun : G → E\nrightInverse_rightHom : Function.RightInverse toFun ⇑S.rightHom\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, rightInverse_rightHom := rightInverse_rightHom }) 1","decl":"/-- `Section` of a group extension is a right inverse to `S.rightHom`. -/\n@[to_additive]\nstructure Section where\n  /-- The underlying function -/\n  toFun : G → E\n  /-- `Section` is a right inverse to `S.rightHom` -/\n  rightInverse_rightHom : Function.RightInverse toFun S.rightHom\n\n"}
{"name":"GroupExtension.Section.rightInverse_rightHom","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\nS : GroupExtension N E G\nself : S.Section\n⊢ Function.RightInverse self.toFun ⇑S.rightHom","decl":"/-- `Section` of a group extension is a right inverse to `S.rightHom`. -/\n@[to_additive]\nstructure Section where\n  /-- The underlying function -/\n  toFun : G → E\n  /-- `Section` is a right inverse to `S.rightHom` -/\n  rightInverse_rightHom : Function.RightInverse toFun S.rightHom\n\n"}
{"name":"AddGroupExtension.Section.coe_mk","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\nS : AddGroupExtension N E G\nσ : G → E\nhσ : Function.RightInverse σ ⇑S.rightHom\n⊢ Eq (⇑{ toFun := σ, rightInverse_rightHom := hσ }) σ","decl":"@[to_additive (attr := simp)]\ntheorem coe_mk (σ : G → E) (hσ : Function.RightInverse σ S.rightHom) : (mk σ hσ : G → E) = σ := rfl\n\n"}
{"name":"GroupExtension.Section.coe_mk","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\nS : GroupExtension N E G\nσ : G → E\nhσ : Function.RightInverse σ ⇑S.rightHom\n⊢ Eq (⇑{ toFun := σ, rightInverse_rightHom := hσ }) σ","decl":"@[to_additive (attr := simp)]\ntheorem coe_mk (σ : G → E) (hσ : Function.RightInverse σ S.rightHom) : (mk σ hσ : G → E) = σ := rfl\n\n"}
{"name":"AddGroupExtension.Section.rightHom_section","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\nS : AddGroupExtension N E G\nσ : S.Section\ng : G\n⊢ Eq (S.rightHom (σ g)) g","decl":"@[to_additive (attr := simp)]\ntheorem rightHom_section (g : G) : S.rightHom (σ g) = g := σ.rightInverse_rightHom g\n\n"}
{"name":"GroupExtension.Section.rightHom_section","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\nS : GroupExtension N E G\nσ : S.Section\ng : G\n⊢ Eq (S.rightHom (σ g)) g","decl":"@[to_additive (attr := simp)]\ntheorem rightHom_section (g : G) : S.rightHom (σ g) = g := σ.rightInverse_rightHom g\n\n"}
{"name":"AddGroupExtension.Section.rightHom_comp_section","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\nS : AddGroupExtension N E G\nσ : S.Section\n⊢ Eq (Function.comp ⇑S.rightHom ⇑σ) id","decl":"@[to_additive (attr := simp)]\ntheorem rightHom_comp_section : S.rightHom ∘ σ = id := σ.rightInverse_rightHom.comp_eq_id\n\n"}
{"name":"GroupExtension.Section.rightHom_comp_section","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\nS : GroupExtension N E G\nσ : S.Section\n⊢ Eq (Function.comp ⇑S.rightHom ⇑σ) id","decl":"@[to_additive (attr := simp)]\ntheorem rightHom_comp_section : S.rightHom ∘ σ = id := σ.rightInverse_rightHom.comp_eq_id\n\n"}
{"name":"GroupExtension.Splitting.mk.injEq","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\nS : GroupExtension N E G\ntoMonoidHom✝ : MonoidHom G E\nrightInverse_rightHom✝ : Function.RightInverse (↑toMonoidHom✝).toFun ⇑S.rightHom\ntoMonoidHom : MonoidHom G E\nrightInverse_rightHom : Function.RightInverse (↑toMonoidHom).toFun ⇑S.rightHom\n⊢ Eq (Eq { toMonoidHom := toMonoidHom✝, rightInverse_rightHom := rightInverse_rightHom✝ } { toMonoidHom := toMonoidHom, rightInverse_rightHom := rightInverse_rightHom }) (Eq toMonoidHom✝ toMonoidHom)","decl":"/-- `Splitting` of a group extension is a section homomorphism. -/\n@[to_additive]\nstructure Splitting extends G →* E, S.Section\n\n"}
{"name":"GroupExtension.Splitting.mk.inj","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\nS : GroupExtension N E G\ntoMonoidHom✝ : MonoidHom G E\nrightInverse_rightHom✝ : Function.RightInverse (↑toMonoidHom✝).toFun ⇑S.rightHom\ntoMonoidHom : MonoidHom G E\nrightInverse_rightHom : Function.RightInverse (↑toMonoidHom).toFun ⇑S.rightHom\nx✝ : Eq { toMonoidHom := toMonoidHom✝, rightInverse_rightHom := rightInverse_rightHom✝ } { toMonoidHom := toMonoidHom, rightInverse_rightHom := rightInverse_rightHom }\n⊢ Eq toMonoidHom✝ toMonoidHom","decl":"/-- `Splitting` of a group extension is a section homomorphism. -/\n@[to_additive]\nstructure Splitting extends G →* E, S.Section\n\n"}
{"name":"GroupExtension.Splitting.mk.sizeOf_spec","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝⁵ : Group N\ninst✝⁴ : Group E\ninst✝³ : Group G\nS : GroupExtension N E G\ninst✝² : SizeOf N\ninst✝¹ : SizeOf E\ninst✝ : SizeOf G\ntoMonoidHom : MonoidHom G E\nrightInverse_rightHom : Function.RightInverse (↑toMonoidHom).toFun ⇑S.rightHom\n⊢ Eq (SizeOf.sizeOf { toMonoidHom := toMonoidHom, rightInverse_rightHom := rightInverse_rightHom }) (HAdd.hAdd 1 (SizeOf.sizeOf toMonoidHom))","decl":"/-- `Splitting` of a group extension is a section homomorphism. -/\n@[to_additive]\nstructure Splitting extends G →* E, S.Section\n\n"}
{"name":"GroupExtension.Splitting.rightInverse_rightHom","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\nS : GroupExtension N E G\nself : S.Splitting\n⊢ Function.RightInverse (↑self.toMonoidHom).toFun ⇑S.rightHom","decl":"/-- `Splitting` of a group extension is a section homomorphism. -/\n@[to_additive]\nstructure Splitting extends G →* E, S.Section\n\n"}
{"name":"GroupExtension.Splitting.instMonoidHomClass","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\nS : GroupExtension N E G\n⊢ MonoidHomClass S.Splitting G E","decl":"@[to_additive]\ninstance : MonoidHomClass S.Splitting G E where\n  map_mul s := s.map_mul'\n  map_one s := s.map_one'\n\n"}
{"name":"AddGroupExtension.Splitting.instAddMonoidHomClass","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\nS : AddGroupExtension N E G\n⊢ AddMonoidHomClass S.Splitting G E","decl":"@[to_additive]\ninstance : MonoidHomClass S.Splitting G E where\n  map_mul s := s.map_mul'\n  map_one s := s.map_one'\n\n"}
{"name":"GroupExtension.Splitting.coe_mk","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\nS : GroupExtension N E G\ns : MonoidHom G E\nhs : Function.RightInverse ⇑s ⇑S.rightHom\n⊢ Eq ⇑{ toMonoidHom := s, rightInverse_rightHom := hs } ⇑s","decl":"@[to_additive (attr := simp)]\ntheorem coe_mk (s : G →* E) (hs : Function.RightInverse s S.rightHom) : (mk s hs : G → E) = s := rfl\n\n"}
{"name":"AddGroupExtension.Splitting.coe_mk","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\nS : AddGroupExtension N E G\ns : AddMonoidHom G E\nhs : Function.RightInverse ⇑s ⇑S.rightHom\n⊢ Eq ⇑{ toAddMonoidHom := s, rightInverse_rightHom := hs } ⇑s","decl":"@[to_additive (attr := simp)]\ntheorem coe_mk (s : G →* E) (hs : Function.RightInverse s S.rightHom) : (mk s hs : G → E) = s := rfl\n\n"}
{"name":"GroupExtension.Splitting.coe_monoidHom_mk","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\nS : GroupExtension N E G\ns : MonoidHom G E\nhs : Function.RightInverse ⇑s ⇑S.rightHom\n⊢ Eq (↑{ toMonoidHom := s, rightInverse_rightHom := hs }) s","decl":"@[to_additive (attr := simp)]\ntheorem coe_monoidHom_mk (s : G →* E) (hs : Function.RightInverse s S.rightHom) :\n    (mk s hs : G →* E) = s := rfl\n\n"}
{"name":"AddGroupExtension.Splitting.coe_addMonoidHom_mk","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\nS : AddGroupExtension N E G\ns : AddMonoidHom G E\nhs : Function.RightInverse ⇑s ⇑S.rightHom\n⊢ Eq (↑{ toAddMonoidHom := s, rightInverse_rightHom := hs }) s","decl":"@[to_additive (attr := simp)]\ntheorem coe_monoidHom_mk (s : G →* E) (hs : Function.RightInverse s S.rightHom) :\n    (mk s hs : G →* E) = s := rfl\n\n"}
{"name":"GroupExtension.Splitting.rightHom_splitting","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\nS : GroupExtension N E G\ns : S.Splitting\ng : G\n⊢ Eq (S.rightHom (s g)) g","decl":"@[to_additive (attr := simp)]\ntheorem rightHom_splitting (g : G) : S.rightHom (s g) = g := s.rightInverse_rightHom g\n\n"}
{"name":"AddGroupExtension.Splitting.rightHom_splitting","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\nS : AddGroupExtension N E G\ns : S.Splitting\ng : G\n⊢ Eq (S.rightHom (s g)) g","decl":"@[to_additive (attr := simp)]\ntheorem rightHom_splitting (g : G) : S.rightHom (s g) = g := s.rightInverse_rightHom g\n\n"}
{"name":"GroupExtension.Splitting.rightHom_comp_splitting","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : Group N\ninst✝¹ : Group E\ninst✝ : Group G\nS : GroupExtension N E G\ns : S.Splitting\n⊢ Eq (S.rightHom.comp ↑s) (MonoidHom.id G)","decl":"@[to_additive (attr := simp)]\ntheorem rightHom_comp_splitting : S.rightHom.comp s = MonoidHom.id G := by\n  ext g\n  simp only [MonoidHom.comp_apply, MonoidHom.id_apply, MonoidHom.coe_coe, rightHom_splitting]\n\n"}
{"name":"AddGroupExtension.Splitting.rightHom_comp_splitting","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst✝² : AddGroup N\ninst✝¹ : AddGroup E\ninst✝ : AddGroup G\nS : AddGroupExtension N E G\ns : S.Splitting\n⊢ Eq (S.rightHom.comp ↑s) (AddMonoidHom.id G)","decl":"@[to_additive (attr := simp)]\ntheorem rightHom_comp_splitting : S.rightHom.comp s = MonoidHom.id G := by\n  ext g\n  simp only [MonoidHom.comp_apply, MonoidHom.id_apply, MonoidHom.coe_coe, rightHom_splitting]\n\n"}
{"name":"SemidirectProduct.toGroupExtension_inl","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nG : Type u_3\ninst✝¹ : Group G\ninst✝ : Group N\nφ : MonoidHom G (MulAut N)\n⊢ Eq (SemidirectProduct.toGroupExtension φ).inl SemidirectProduct.inl","decl":"theorem toGroupExtension_inl : (toGroupExtension φ).inl = SemidirectProduct.inl := rfl\n\n"}
{"name":"SemidirectProduct.toGroupExtension_rightHom","module":"Mathlib.GroupTheory.GroupExtension.Defs","initialProofState":"N : Type u_1\nG : Type u_3\ninst✝¹ : Group G\ninst✝ : Group N\nφ : MonoidHom G (MulAut N)\n⊢ Eq (SemidirectProduct.toGroupExtension φ).rightHom SemidirectProduct.rightHom","decl":"theorem toGroupExtension_rightHom : (toGroupExtension φ).rightHom = SemidirectProduct.rightHom :=\n  rfl\n\n"}
