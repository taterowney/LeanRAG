{"name":"Monotone.biUnion_Ico_Ioc_map_succ","module":"Mathlib.Order.SuccPred.IntervalSucc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : LinearOrder α\ninst✝² : SuccOrder α\ninst✝¹ : IsSuccArchimedean α\ninst✝ : LinearOrder β\nf : α → β\nhf : Monotone f\nm n : α\n⊢ Eq (Set.iUnion fun i => Set.iUnion fun h => Set.Ioc (f i) (f (Order.succ i))) (Set.Ioc (f m) (f n))","decl":"/-- If `α` is a linear archimedean succ order and `β` is a linear order, then for any monotone\nfunction `f` and `m n : α`, the union of intervals `Set.Ioc (f i) (f (Order.succ i))`, `m ≤ i < n`,\nis equal to `Set.Ioc (f m) (f n)` -/\ntheorem biUnion_Ico_Ioc_map_succ [SuccOrder α] [IsSuccArchimedean α] [LinearOrder β] {f : α → β}\n    (hf : Monotone f) (m n : α) : ⋃ i ∈ Ico m n, Ioc (f i) (f (succ i)) = Ioc (f m) (f n) := by\n  rcases le_total n m with hnm | hmn\n  · rw [Ico_eq_empty_of_le hnm, Ioc_eq_empty_of_le (hf hnm), biUnion_empty]\n  · refine Succ.rec ?_ ?_ hmn\n    · simp only [Ioc_self, Ico_self, biUnion_empty]\n    · intro k hmk ihk\n      rw [← Ioc_union_Ioc_eq_Ioc (hf hmk) (hf <| le_succ _), union_comm, ← ihk]\n      by_cases hk : IsMax k\n      · rw [hk.succ_eq, Ioc_self, empty_union]\n      · rw [Ico_succ_right_eq_insert_of_not_isMax hmk hk, biUnion_insert]\n\n"}
{"name":"Monotone.pairwise_disjoint_on_Ioc_succ","module":"Mathlib.Order.SuccPred.IntervalSucc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\ninst✝ : Preorder β\nf : α → β\nhf : Monotone f\n⊢ Pairwise (Function.onFun Disjoint fun n => Set.Ioc (f n) (f (Order.succ n)))","decl":"/-- If `α` is a linear succ order, `β` is a preorder, and `f : α → β` is a monotone function, then\nthe intervals `Set.Ioc (f n) (f (Order.succ n))` are pairwise disjoint. -/\ntheorem pairwise_disjoint_on_Ioc_succ [SuccOrder α] [Preorder β] {f : α → β} (hf : Monotone f) :\n    Pairwise (Disjoint on fun n => Ioc (f n) (f (succ n))) :=\n  (pairwise_disjoint_on _).2 fun _ _ hmn =>\n    disjoint_iff_inf_le.mpr fun _ ⟨⟨_, h₁⟩, ⟨h₂, _⟩⟩ =>\n      h₂.not_le <| h₁.trans <| hf <| succ_le_of_lt hmn\n\n"}
{"name":"Monotone.pairwise_disjoint_on_Ico_succ","module":"Mathlib.Order.SuccPred.IntervalSucc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\ninst✝ : Preorder β\nf : α → β\nhf : Monotone f\n⊢ Pairwise (Function.onFun Disjoint fun n => Set.Ico (f n) (f (Order.succ n)))","decl":"/-- If `α` is a linear succ order, `β` is a preorder, and `f : α → β` is a monotone function, then\nthe intervals `Set.Ico (f n) (f (Order.succ n))` are pairwise disjoint. -/\ntheorem pairwise_disjoint_on_Ico_succ [SuccOrder α] [Preorder β] {f : α → β} (hf : Monotone f) :\n    Pairwise (Disjoint on fun n => Ico (f n) (f (succ n))) :=\n  (pairwise_disjoint_on _).2 fun _ _ hmn =>\n    disjoint_iff_inf_le.mpr fun _ ⟨⟨_, h₁⟩, ⟨h₂, _⟩⟩ =>\n      h₁.not_le <| (hf <| succ_le_of_lt hmn).trans h₂\n\n"}
{"name":"Monotone.pairwise_disjoint_on_Ioo_succ","module":"Mathlib.Order.SuccPred.IntervalSucc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\ninst✝ : Preorder β\nf : α → β\nhf : Monotone f\n⊢ Pairwise (Function.onFun Disjoint fun n => Set.Ioo (f n) (f (Order.succ n)))","decl":"/-- If `α` is a linear succ order, `β` is a preorder, and `f : α → β` is a monotone function, then\nthe intervals `Set.Ioo (f n) (f (Order.succ n))` are pairwise disjoint. -/\ntheorem pairwise_disjoint_on_Ioo_succ [SuccOrder α] [Preorder β] {f : α → β} (hf : Monotone f) :\n    Pairwise (Disjoint on fun n => Ioo (f n) (f (succ n))) :=\n  hf.pairwise_disjoint_on_Ico_succ.mono fun _ _ h => h.mono Ioo_subset_Ico_self Ioo_subset_Ico_self\n\n"}
{"name":"Monotone.pairwise_disjoint_on_Ioc_pred","module":"Mathlib.Order.SuccPred.IntervalSucc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\ninst✝ : Preorder β\nf : α → β\nhf : Monotone f\n⊢ Pairwise (Function.onFun Disjoint fun n => Set.Ioc (f (Order.pred n)) (f n))","decl":"/-- If `α` is a linear pred order, `β` is a preorder, and `f : α → β` is a monotone function, then\nthe intervals `Set.Ioc (f Order.pred n) (f n)` are pairwise disjoint. -/\ntheorem pairwise_disjoint_on_Ioc_pred [PredOrder α] [Preorder β] {f : α → β} (hf : Monotone f) :\n    Pairwise (Disjoint on fun n => Ioc (f (pred n)) (f n)) := by\n  simpa only [(· ∘ ·), dual_Ico] using hf.dual.pairwise_disjoint_on_Ico_succ\n\n"}
{"name":"Monotone.pairwise_disjoint_on_Ico_pred","module":"Mathlib.Order.SuccPred.IntervalSucc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\ninst✝ : Preorder β\nf : α → β\nhf : Monotone f\n⊢ Pairwise (Function.onFun Disjoint fun n => Set.Ico (f (Order.pred n)) (f n))","decl":"/-- If `α` is a linear pred order, `β` is a preorder, and `f : α → β` is a monotone function, then\nthe intervals `Set.Ico (f Order.pred n) (f n)` are pairwise disjoint. -/\ntheorem pairwise_disjoint_on_Ico_pred [PredOrder α] [Preorder β] {f : α → β} (hf : Monotone f) :\n    Pairwise (Disjoint on fun n => Ico (f (pred n)) (f n)) := by\n  simpa only [(· ∘ ·), dual_Ioc] using hf.dual.pairwise_disjoint_on_Ioc_succ\n\n"}
{"name":"Monotone.pairwise_disjoint_on_Ioo_pred","module":"Mathlib.Order.SuccPred.IntervalSucc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\ninst✝ : Preorder β\nf : α → β\nhf : Monotone f\n⊢ Pairwise (Function.onFun Disjoint fun n => Set.Ioo (f (Order.pred n)) (f n))","decl":"/-- If `α` is a linear pred order, `β` is a preorder, and `f : α → β` is a monotone function, then\nthe intervals `Set.Ioo (f Order.pred n) (f n)` are pairwise disjoint. -/\ntheorem pairwise_disjoint_on_Ioo_pred [PredOrder α] [Preorder β] {f : α → β} (hf : Monotone f) :\n    Pairwise (Disjoint on fun n => Ioo (f (pred n)) (f n)) := by\n  simpa only [(· ∘ ·), dual_Ioo] using hf.dual.pairwise_disjoint_on_Ioo_succ\n\n"}
{"name":"Antitone.pairwise_disjoint_on_Ioc_succ","module":"Mathlib.Order.SuccPred.IntervalSucc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\ninst✝ : Preorder β\nf : α → β\nhf : Antitone f\n⊢ Pairwise (Function.onFun Disjoint fun n => Set.Ioc (f (Order.succ n)) (f n))","decl":"/-- If `α` is a linear succ order, `β` is a preorder, and `f : α → β` is an antitone function, then\nthe intervals `Set.Ioc (f (Order.succ n)) (f n)` are pairwise disjoint. -/\ntheorem pairwise_disjoint_on_Ioc_succ [SuccOrder α] [Preorder β] {f : α → β} (hf : Antitone f) :\n    Pairwise (Disjoint on fun n => Ioc (f (succ n)) (f n)) :=\n  hf.dual_left.pairwise_disjoint_on_Ioc_pred\n\n"}
{"name":"Antitone.pairwise_disjoint_on_Ico_succ","module":"Mathlib.Order.SuccPred.IntervalSucc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\ninst✝ : Preorder β\nf : α → β\nhf : Antitone f\n⊢ Pairwise (Function.onFun Disjoint fun n => Set.Ico (f (Order.succ n)) (f n))","decl":"/-- If `α` is a linear succ order, `β` is a preorder, and `f : α → β` is an antitone function, then\nthe intervals `Set.Ico (f (Order.succ n)) (f n)` are pairwise disjoint. -/\ntheorem pairwise_disjoint_on_Ico_succ [SuccOrder α] [Preorder β] {f : α → β} (hf : Antitone f) :\n    Pairwise (Disjoint on fun n => Ico (f (succ n)) (f n)) :=\n  hf.dual_left.pairwise_disjoint_on_Ico_pred\n\n"}
{"name":"Antitone.pairwise_disjoint_on_Ioo_succ","module":"Mathlib.Order.SuccPred.IntervalSucc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\ninst✝ : Preorder β\nf : α → β\nhf : Antitone f\n⊢ Pairwise (Function.onFun Disjoint fun n => Set.Ioo (f (Order.succ n)) (f n))","decl":"/-- If `α` is a linear succ order, `β` is a preorder, and `f : α → β` is an antitone function, then\nthe intervals `Set.Ioo (f (Order.succ n)) (f n)` are pairwise disjoint. -/\ntheorem pairwise_disjoint_on_Ioo_succ [SuccOrder α] [Preorder β] {f : α → β} (hf : Antitone f) :\n    Pairwise (Disjoint on fun n => Ioo (f (succ n)) (f n)) :=\n  hf.dual_left.pairwise_disjoint_on_Ioo_pred\n\n"}
{"name":"Antitone.pairwise_disjoint_on_Ioc_pred","module":"Mathlib.Order.SuccPred.IntervalSucc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\ninst✝ : Preorder β\nf : α → β\nhf : Antitone f\n⊢ Pairwise (Function.onFun Disjoint fun n => Set.Ioc (f n) (f (Order.pred n)))","decl":"/-- If `α` is a linear pred order, `β` is a preorder, and `f : α → β` is an antitone function, then\nthe intervals `Set.Ioc (f n) (f (Order.pred n))` are pairwise disjoint. -/\ntheorem pairwise_disjoint_on_Ioc_pred [PredOrder α] [Preorder β] {f : α → β} (hf : Antitone f) :\n    Pairwise (Disjoint on fun n => Ioc (f n) (f (pred n))) :=\n  hf.dual_left.pairwise_disjoint_on_Ioc_succ\n\n"}
{"name":"Antitone.pairwise_disjoint_on_Ico_pred","module":"Mathlib.Order.SuccPred.IntervalSucc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\ninst✝ : Preorder β\nf : α → β\nhf : Antitone f\n⊢ Pairwise (Function.onFun Disjoint fun n => Set.Ico (f n) (f (Order.pred n)))","decl":"/-- If `α` is a linear pred order, `β` is a preorder, and `f : α → β` is an antitone function, then\nthe intervals `Set.Ico (f n) (f (Order.pred n))` are pairwise disjoint. -/\ntheorem pairwise_disjoint_on_Ico_pred [PredOrder α] [Preorder β] {f : α → β} (hf : Antitone f) :\n    Pairwise (Disjoint on fun n => Ico (f n) (f (pred n))) :=\n  hf.dual_left.pairwise_disjoint_on_Ico_succ\n\n"}
{"name":"Antitone.pairwise_disjoint_on_Ioo_pred","module":"Mathlib.Order.SuccPred.IntervalSucc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\ninst✝ : Preorder β\nf : α → β\nhf : Antitone f\n⊢ Pairwise (Function.onFun Disjoint fun n => Set.Ioo (f n) (f (Order.pred n)))","decl":"/-- If `α` is a linear pred order, `β` is a preorder, and `f : α → β` is an antitone function, then\nthe intervals `Set.Ioo (f n) (f (Order.pred n))` are pairwise disjoint. -/\ntheorem pairwise_disjoint_on_Ioo_pred [PredOrder α] [Preorder β] {f : α → β} (hf : Antitone f) :\n    Pairwise (Disjoint on fun n => Ioo (f n) (f (pred n))) :=\n  hf.dual_left.pairwise_disjoint_on_Ioo_succ\n\n"}
