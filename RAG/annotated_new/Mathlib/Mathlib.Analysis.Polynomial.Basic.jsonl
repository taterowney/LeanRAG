{"name":"Polynomial.eventually_no_roots","module":"Mathlib.Analysis.Polynomial.Basic","initialProofState":"𝕜 : Type u_1\ninst✝ : NormedLinearOrderedField 𝕜\nP : Polynomial 𝕜\nhP : Ne P 0\n⊢ Filter.Eventually (fun x => Not (P.IsRoot x)) Filter.atTop","decl":"theorem eventually_no_roots (hP : P ≠ 0) : ∀ᶠ x in atTop, ¬P.IsRoot x :=\n  atTop_le_cofinite <| (finite_setOf_isRoot hP).compl_mem_cofinite\n\n"}
{"name":"Polynomial.isEquivalent_atTop_lead","module":"Mathlib.Analysis.Polynomial.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NormedLinearOrderedField 𝕜\nP : Polynomial 𝕜\ninst✝ : OrderTopology 𝕜\n⊢ Asymptotics.IsEquivalent Filter.atTop (fun x => Polynomial.eval x P) fun x => HMul.hMul P.leadingCoeff (HPow.hPow x P.natDegree)","decl":"theorem isEquivalent_atTop_lead :\n    (fun x => eval x P) ~[atTop] fun x => P.leadingCoeff * x ^ P.natDegree := by\n  by_cases h : P = 0\n  · simp [h, IsEquivalent.refl]\n  · simp only [Polynomial.eval_eq_sum_range, sum_range_succ]\n    exact\n      IsLittleO.add_isEquivalent\n        (IsLittleO.sum fun i hi =>\n          IsLittleO.const_mul_left\n            ((IsLittleO.const_mul_right fun hz => h <| leadingCoeff_eq_zero.mp hz) <|\n              isLittleO_pow_pow_atTop_of_lt (mem_range.mp hi))\n            _)\n        IsEquivalent.refl\n\n"}
{"name":"Polynomial.tendsto_atTop_of_leadingCoeff_nonneg","module":"Mathlib.Analysis.Polynomial.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NormedLinearOrderedField 𝕜\nP : Polynomial 𝕜\ninst✝ : OrderTopology 𝕜\nhdeg : LT.lt 0 P.degree\nhnng : LE.le 0 P.leadingCoeff\n⊢ Filter.Tendsto (fun x => Polynomial.eval x P) Filter.atTop Filter.atTop","decl":"theorem tendsto_atTop_of_leadingCoeff_nonneg (hdeg : 0 < P.degree) (hnng : 0 ≤ P.leadingCoeff) :\n    Tendsto (fun x => eval x P) atTop atTop :=\n  P.isEquivalent_atTop_lead.symm.tendsto_atTop <|\n    tendsto_const_mul_pow_atTop (natDegree_pos_iff_degree_pos.2 hdeg).ne' <|\n      hnng.lt_of_ne' <| leadingCoeff_ne_zero.mpr <| ne_zero_of_degree_gt hdeg\n\n"}
{"name":"Polynomial.tendsto_atTop_iff_leadingCoeff_nonneg","module":"Mathlib.Analysis.Polynomial.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NormedLinearOrderedField 𝕜\nP : Polynomial 𝕜\ninst✝ : OrderTopology 𝕜\n⊢ Iff (Filter.Tendsto (fun x => Polynomial.eval x P) Filter.atTop Filter.atTop) (And (LT.lt 0 P.degree) (LE.le 0 P.leadingCoeff))","decl":"theorem tendsto_atTop_iff_leadingCoeff_nonneg :\n    Tendsto (fun x => eval x P) atTop atTop ↔ 0 < P.degree ∧ 0 ≤ P.leadingCoeff := by\n  refine ⟨fun h => ?_, fun h => tendsto_atTop_of_leadingCoeff_nonneg P h.1 h.2⟩\n  have : Tendsto (fun x => P.leadingCoeff * x ^ P.natDegree) atTop atTop :=\n    (isEquivalent_atTop_lead P).tendsto_atTop h\n  rw [tendsto_const_mul_pow_atTop_iff, ← pos_iff_ne_zero, natDegree_pos_iff_degree_pos] at this\n  exact ⟨this.1, this.2.le⟩\n\n"}
{"name":"Polynomial.tendsto_atBot_iff_leadingCoeff_nonpos","module":"Mathlib.Analysis.Polynomial.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NormedLinearOrderedField 𝕜\nP : Polynomial 𝕜\ninst✝ : OrderTopology 𝕜\n⊢ Iff (Filter.Tendsto (fun x => Polynomial.eval x P) Filter.atTop Filter.atBot) (And (LT.lt 0 P.degree) (LE.le P.leadingCoeff 0))","decl":"theorem tendsto_atBot_iff_leadingCoeff_nonpos :\n    Tendsto (fun x => eval x P) atTop atBot ↔ 0 < P.degree ∧ P.leadingCoeff ≤ 0 := by\n  simp only [← tendsto_neg_atTop_iff, ← eval_neg, tendsto_atTop_iff_leadingCoeff_nonneg,\n    degree_neg, leadingCoeff_neg, neg_nonneg]\n\n"}
{"name":"Polynomial.tendsto_atBot_of_leadingCoeff_nonpos","module":"Mathlib.Analysis.Polynomial.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NormedLinearOrderedField 𝕜\nP : Polynomial 𝕜\ninst✝ : OrderTopology 𝕜\nhdeg : LT.lt 0 P.degree\nhnps : LE.le P.leadingCoeff 0\n⊢ Filter.Tendsto (fun x => Polynomial.eval x P) Filter.atTop Filter.atBot","decl":"theorem tendsto_atBot_of_leadingCoeff_nonpos (hdeg : 0 < P.degree) (hnps : P.leadingCoeff ≤ 0) :\n    Tendsto (fun x => eval x P) atTop atBot :=\n  P.tendsto_atBot_iff_leadingCoeff_nonpos.2 ⟨hdeg, hnps⟩\n\n"}
{"name":"Polynomial.abs_tendsto_atTop","module":"Mathlib.Analysis.Polynomial.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NormedLinearOrderedField 𝕜\nP : Polynomial 𝕜\ninst✝ : OrderTopology 𝕜\nhdeg : LT.lt 0 P.degree\n⊢ Filter.Tendsto (fun x => abs (Polynomial.eval x P)) Filter.atTop Filter.atTop","decl":"theorem abs_tendsto_atTop (hdeg : 0 < P.degree) :\n    Tendsto (fun x => abs <| eval x P) atTop atTop := by\n  rcases le_total 0 P.leadingCoeff with hP | hP\n  · exact tendsto_abs_atTop_atTop.comp (P.tendsto_atTop_of_leadingCoeff_nonneg hdeg hP)\n  · exact tendsto_abs_atBot_atTop.comp (P.tendsto_atBot_of_leadingCoeff_nonpos hdeg hP)\n\n"}
{"name":"Polynomial.abs_isBoundedUnder_iff","module":"Mathlib.Analysis.Polynomial.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NormedLinearOrderedField 𝕜\nP : Polynomial 𝕜\ninst✝ : OrderTopology 𝕜\n⊢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) Filter.atTop fun x => abs (Polynomial.eval x P)) (LE.le P.degree 0)","decl":"theorem abs_isBoundedUnder_iff :\n    (IsBoundedUnder (· ≤ ·) atTop fun x => |eval x P|) ↔ P.degree ≤ 0 := by\n  refine ⟨fun h => ?_, fun h => ⟨|P.coeff 0|, eventually_map.mpr (Eventually.of_forall\n    (forall_imp (fun _ => le_of_eq) fun x => congr_arg abs <| _root_.trans (congr_arg (eval x)\n    (eq_C_of_degree_le_zero h)) eval_C))⟩⟩\n  contrapose! h\n  exact not_isBoundedUnder_of_tendsto_atTop (abs_tendsto_atTop P h)\n\n"}
{"name":"Polynomial.abs_tendsto_atTop_iff","module":"Mathlib.Analysis.Polynomial.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NormedLinearOrderedField 𝕜\nP : Polynomial 𝕜\ninst✝ : OrderTopology 𝕜\n⊢ Iff (Filter.Tendsto (fun x => abs (Polynomial.eval x P)) Filter.atTop Filter.atTop) (LT.lt 0 P.degree)","decl":"theorem abs_tendsto_atTop_iff : Tendsto (fun x => abs <| eval x P) atTop atTop ↔ 0 < P.degree :=\n  ⟨fun h => not_le.mp (mt (abs_isBoundedUnder_iff P).mpr (not_isBoundedUnder_of_tendsto_atTop h)),\n    abs_tendsto_atTop P⟩\n\n"}
{"name":"Polynomial.tendsto_nhds_iff","module":"Mathlib.Analysis.Polynomial.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NormedLinearOrderedField 𝕜\nP : Polynomial 𝕜\ninst✝ : OrderTopology 𝕜\nc : 𝕜\n⊢ Iff (Filter.Tendsto (fun x => Polynomial.eval x P) Filter.atTop (nhds c)) (And (Eq P.leadingCoeff c) (LE.le P.degree 0))","decl":"theorem tendsto_nhds_iff {c : 𝕜} :\n    Tendsto (fun x => eval x P) atTop (𝓝 c) ↔ P.leadingCoeff = c ∧ P.degree ≤ 0 := by\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · have := P.isEquivalent_atTop_lead.tendsto_nhds h\n    by_cases hP : P.leadingCoeff = 0\n    · simp only [hP, zero_mul, tendsto_const_nhds_iff] at this\n      exact ⟨_root_.trans hP this, by simp [leadingCoeff_eq_zero.1 hP]⟩\n    · rw [tendsto_const_mul_pow_nhds_iff hP, natDegree_eq_zero_iff_degree_le_zero] at this\n      exact this.symm\n  · refine P.isEquivalent_atTop_lead.symm.tendsto_nhds ?_\n    have : P.natDegree = 0 := natDegree_eq_zero_iff_degree_le_zero.2 h.2\n    simp only [h.1, this, pow_zero, mul_one]\n    exact tendsto_const_nhds\n\n"}
{"name":"Polynomial.isEquivalent_atTop_div","module":"Mathlib.Analysis.Polynomial.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NormedLinearOrderedField 𝕜\nP Q : Polynomial 𝕜\ninst✝ : OrderTopology 𝕜\n⊢ Asymptotics.IsEquivalent Filter.atTop (fun x => HDiv.hDiv (Polynomial.eval x P) (Polynomial.eval x Q)) fun x => HMul.hMul (HDiv.hDiv P.leadingCoeff Q.leadingCoeff) (HPow.hPow x (HSub.hSub ↑P.natDegree ↑Q.natDegree))","decl":"theorem isEquivalent_atTop_div :\n    (fun x => eval x P / eval x Q) ~[atTop] fun x =>\n      P.leadingCoeff / Q.leadingCoeff * x ^ (P.natDegree - Q.natDegree : ℤ) := by\n  by_cases hP : P = 0\n  · simp [hP, IsEquivalent.refl]\n  by_cases hQ : Q = 0\n  · simp [hQ, IsEquivalent.refl]\n  refine\n    (P.isEquivalent_atTop_lead.symm.div Q.isEquivalent_atTop_lead.symm).symm.trans\n      (EventuallyEq.isEquivalent ((eventually_gt_atTop 0).mono fun x hx => ?_))\n  simp [← div_mul_div_comm, hP, hQ, zpow_sub₀ hx.ne.symm]\n\n"}
{"name":"Polynomial.div_tendsto_zero_of_degree_lt","module":"Mathlib.Analysis.Polynomial.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NormedLinearOrderedField 𝕜\nP Q : Polynomial 𝕜\ninst✝ : OrderTopology 𝕜\nhdeg : LT.lt P.degree Q.degree\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (Polynomial.eval x P) (Polynomial.eval x Q)) Filter.atTop (nhds 0)","decl":"theorem div_tendsto_zero_of_degree_lt (hdeg : P.degree < Q.degree) :\n    Tendsto (fun x => eval x P / eval x Q) atTop (𝓝 0) := by\n  by_cases hP : P = 0\n  · simp [hP, tendsto_const_nhds]\n  rw [← natDegree_lt_natDegree_iff hP] at hdeg\n  refine (isEquivalent_atTop_div P Q).symm.tendsto_nhds ?_\n  rw [← mul_zero]\n  refine (tendsto_zpow_atTop_zero ?_).const_mul _\n  omega\n\n"}
{"name":"Polynomial.div_tendsto_zero_iff_degree_lt","module":"Mathlib.Analysis.Polynomial.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NormedLinearOrderedField 𝕜\nP Q : Polynomial 𝕜\ninst✝ : OrderTopology 𝕜\nhQ : Ne Q 0\n⊢ Iff (Filter.Tendsto (fun x => HDiv.hDiv (Polynomial.eval x P) (Polynomial.eval x Q)) Filter.atTop (nhds 0)) (LT.lt P.degree Q.degree)","decl":"theorem div_tendsto_zero_iff_degree_lt (hQ : Q ≠ 0) :\n    Tendsto (fun x => eval x P / eval x Q) atTop (𝓝 0) ↔ P.degree < Q.degree := by\n  refine ⟨fun h => ?_, div_tendsto_zero_of_degree_lt P Q⟩\n  by_cases hPQ : P.leadingCoeff / Q.leadingCoeff = 0\n  · simp only [div_eq_mul_inv, inv_eq_zero, mul_eq_zero] at hPQ\n    cases' hPQ with hP0 hQ0\n    · rw [leadingCoeff_eq_zero.1 hP0, degree_zero]\n      exact bot_lt_iff_ne_bot.2 fun hQ' => hQ (degree_eq_bot.1 hQ')\n    · exact absurd (leadingCoeff_eq_zero.1 hQ0) hQ\n  · have := (isEquivalent_atTop_div P Q).tendsto_nhds h\n    rw [tendsto_const_mul_zpow_atTop_nhds_iff hPQ] at this\n    cases' this with h h\n    · exact absurd h.2 hPQ\n    · rw [sub_lt_iff_lt_add, zero_add, Int.ofNat_lt] at h\n      exact degree_lt_degree h.1\n\n"}
{"name":"Polynomial.div_tendsto_leadingCoeff_div_of_degree_eq","module":"Mathlib.Analysis.Polynomial.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NormedLinearOrderedField 𝕜\nP Q : Polynomial 𝕜\ninst✝ : OrderTopology 𝕜\nhdeg : Eq P.degree Q.degree\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (Polynomial.eval x P) (Polynomial.eval x Q)) Filter.atTop (nhds (HDiv.hDiv P.leadingCoeff Q.leadingCoeff))","decl":"theorem div_tendsto_leadingCoeff_div_of_degree_eq (hdeg : P.degree = Q.degree) :\n    Tendsto (fun x => eval x P / eval x Q) atTop (𝓝 <| P.leadingCoeff / Q.leadingCoeff) := by\n  refine (isEquivalent_atTop_div P Q).symm.tendsto_nhds ?_\n  rw [show (P.natDegree : ℤ) = Q.natDegree by simp [hdeg, natDegree]]\n  simp [tendsto_const_nhds]\n\n"}
{"name":"Polynomial.div_tendsto_atTop_of_degree_gt'","module":"Mathlib.Analysis.Polynomial.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NormedLinearOrderedField 𝕜\nP Q : Polynomial 𝕜\ninst✝ : OrderTopology 𝕜\nhdeg : LT.lt Q.degree P.degree\nhpos : LT.lt 0 (HDiv.hDiv P.leadingCoeff Q.leadingCoeff)\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (Polynomial.eval x P) (Polynomial.eval x Q)) Filter.atTop Filter.atTop","decl":"theorem div_tendsto_atTop_of_degree_gt' (hdeg : Q.degree < P.degree)\n    (hpos : 0 < P.leadingCoeff / Q.leadingCoeff) :\n    Tendsto (fun x => eval x P / eval x Q) atTop atTop := by\n  have hQ : Q ≠ 0 := fun h => by\n    simp only [h, div_zero, leadingCoeff_zero] at hpos\n    exact hpos.false\n  rw [← natDegree_lt_natDegree_iff hQ] at hdeg\n  refine (isEquivalent_atTop_div P Q).symm.tendsto_atTop ?_\n  apply Tendsto.const_mul_atTop hpos\n  apply tendsto_zpow_atTop_atTop\n  omega\n\n"}
{"name":"Polynomial.div_tendsto_atTop_of_degree_gt","module":"Mathlib.Analysis.Polynomial.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NormedLinearOrderedField 𝕜\nP Q : Polynomial 𝕜\ninst✝ : OrderTopology 𝕜\nhdeg : LT.lt Q.degree P.degree\nhQ : Ne Q 0\nhnng : LE.le 0 (HDiv.hDiv P.leadingCoeff Q.leadingCoeff)\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (Polynomial.eval x P) (Polynomial.eval x Q)) Filter.atTop Filter.atTop","decl":"theorem div_tendsto_atTop_of_degree_gt (hdeg : Q.degree < P.degree) (hQ : Q ≠ 0)\n    (hnng : 0 ≤ P.leadingCoeff / Q.leadingCoeff) :\n    Tendsto (fun x => eval x P / eval x Q) atTop atTop :=\n  have ratio_pos : 0 < P.leadingCoeff / Q.leadingCoeff :=\n    lt_of_le_of_ne hnng\n      (div_ne_zero (fun h => ne_zero_of_degree_gt hdeg <| leadingCoeff_eq_zero.mp h) fun h =>\n          hQ <| leadingCoeff_eq_zero.mp h).symm\n  div_tendsto_atTop_of_degree_gt' P Q hdeg ratio_pos\n\n"}
{"name":"Polynomial.div_tendsto_atBot_of_degree_gt'","module":"Mathlib.Analysis.Polynomial.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NormedLinearOrderedField 𝕜\nP Q : Polynomial 𝕜\ninst✝ : OrderTopology 𝕜\nhdeg : LT.lt Q.degree P.degree\nhneg : LT.lt (HDiv.hDiv P.leadingCoeff Q.leadingCoeff) 0\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (Polynomial.eval x P) (Polynomial.eval x Q)) Filter.atTop Filter.atBot","decl":"theorem div_tendsto_atBot_of_degree_gt' (hdeg : Q.degree < P.degree)\n    (hneg : P.leadingCoeff / Q.leadingCoeff < 0) :\n    Tendsto (fun x => eval x P / eval x Q) atTop atBot := by\n  have hQ : Q ≠ 0 := fun h => by\n    simp only [h, div_zero, leadingCoeff_zero] at hneg\n    exact hneg.false\n  rw [← natDegree_lt_natDegree_iff hQ] at hdeg\n  refine (isEquivalent_atTop_div P Q).symm.tendsto_atBot ?_\n  apply Tendsto.const_mul_atTop_of_neg hneg\n  apply tendsto_zpow_atTop_atTop\n  omega\n\n"}
{"name":"Polynomial.div_tendsto_atBot_of_degree_gt","module":"Mathlib.Analysis.Polynomial.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NormedLinearOrderedField 𝕜\nP Q : Polynomial 𝕜\ninst✝ : OrderTopology 𝕜\nhdeg : LT.lt Q.degree P.degree\nhQ : Ne Q 0\nhnps : LE.le (HDiv.hDiv P.leadingCoeff Q.leadingCoeff) 0\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (Polynomial.eval x P) (Polynomial.eval x Q)) Filter.atTop Filter.atBot","decl":"theorem div_tendsto_atBot_of_degree_gt (hdeg : Q.degree < P.degree) (hQ : Q ≠ 0)\n    (hnps : P.leadingCoeff / Q.leadingCoeff ≤ 0) :\n    Tendsto (fun x => eval x P / eval x Q) atTop atBot :=\n  have ratio_neg : P.leadingCoeff / Q.leadingCoeff < 0 :=\n    lt_of_le_of_ne hnps\n      (div_ne_zero (fun h => ne_zero_of_degree_gt hdeg <| leadingCoeff_eq_zero.mp h) fun h =>\n        hQ <| leadingCoeff_eq_zero.mp h)\n  div_tendsto_atBot_of_degree_gt' P Q hdeg ratio_neg\n\n"}
{"name":"Polynomial.abs_div_tendsto_atTop_of_degree_gt","module":"Mathlib.Analysis.Polynomial.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NormedLinearOrderedField 𝕜\nP Q : Polynomial 𝕜\ninst✝ : OrderTopology 𝕜\nhdeg : LT.lt Q.degree P.degree\nhQ : Ne Q 0\n⊢ Filter.Tendsto (fun x => abs (HDiv.hDiv (Polynomial.eval x P) (Polynomial.eval x Q))) Filter.atTop Filter.atTop","decl":"theorem abs_div_tendsto_atTop_of_degree_gt (hdeg : Q.degree < P.degree) (hQ : Q ≠ 0) :\n    Tendsto (fun x => |eval x P / eval x Q|) atTop atTop := by\n  by_cases h : 0 ≤ P.leadingCoeff / Q.leadingCoeff\n  · exact tendsto_abs_atTop_atTop.comp (P.div_tendsto_atTop_of_degree_gt Q hdeg hQ h)\n  · push_neg at h\n    exact tendsto_abs_atBot_atTop.comp (P.div_tendsto_atBot_of_degree_gt Q hdeg hQ h.le)\n\n"}
{"name":"Polynomial.isBigO_of_degree_le","module":"Mathlib.Analysis.Polynomial.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NormedLinearOrderedField 𝕜\nP Q : Polynomial 𝕜\ninst✝ : OrderTopology 𝕜\nh : LE.le P.degree Q.degree\n⊢ Asymptotics.IsBigO Filter.atTop (fun x => Polynomial.eval x P) fun x => Polynomial.eval x Q","decl":"theorem isBigO_of_degree_le (h : P.degree ≤ Q.degree) :\n    (fun x => eval x P) =O[atTop] fun x => eval x Q := by\n  by_cases hp : P = 0\n  · simpa [hp] using isBigO_zero (fun x => eval x Q) atTop\n  · have hq : Q ≠ 0 := ne_zero_of_degree_ge_degree h hp\n    have hPQ : ∀ᶠ x : 𝕜 in atTop, eval x Q = 0 → eval x P = 0 :=\n      Filter.mem_of_superset (Polynomial.eventually_no_roots Q hq) fun x h h' => absurd h' h\n    cases' le_iff_lt_or_eq.mp h with h h\n    · exact isBigO_of_div_tendsto_nhds hPQ 0 (div_tendsto_zero_of_degree_lt P Q h)\n    · exact isBigO_of_div_tendsto_nhds hPQ _ (div_tendsto_leadingCoeff_div_of_degree_eq P Q h)\n\n"}
