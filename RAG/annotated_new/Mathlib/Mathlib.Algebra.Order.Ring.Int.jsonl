{"name":"Int.isCompl_even_odd","module":"Mathlib.Algebra.Order.Ring.Int","initialProofState":"⊢ IsCompl (setOf fun n => Even n) (setOf fun n => Odd n)","decl":"lemma isCompl_even_odd : IsCompl { n : ℤ | Even n } { n | Odd n } := by\n  simp [← not_even_iff_odd, ← Set.compl_setOf, isCompl_compl]\n\n"}
{"name":"Nat.cast_natAbs","module":"Mathlib.Algebra.Order.Ring.Int","initialProofState":"α : Type u_1\ninst✝ : AddGroupWithOne α\nn : Int\n⊢ Eq ↑n.natAbs ↑(abs n)","decl":"lemma _root_.Nat.cast_natAbs {α : Type*} [AddGroupWithOne α] (n : ℤ) : (n.natAbs : α) = |n| := by\n  rw [← natCast_natAbs, Int.cast_natCast]\n\n"}
{"name":"Int.cast_mul_eq_zsmul_cast","module":"Mathlib.Algebra.Order.Ring.Int","initialProofState":"α : Type u_1\ninst✝ : AddCommGroupWithOne α\nm n : Int\n⊢ Eq (↑(HMul.hMul m n)) (HSMul.hSMul m ↑n)","decl":"/-- Note this holds in marginally more generality than `Int.cast_mul` -/\nlemma cast_mul_eq_zsmul_cast {α : Type*} [AddCommGroupWithOne α] :\n    ∀ m n : ℤ, ↑(m * n) = m • (n : α) :=\n  fun m ↦ Int.induction_on m (by simp) (fun _ ih ↦ by simp [add_mul, add_zsmul, ih]) fun _ ih ↦ by\n    simp only [sub_mul, one_mul, cast_sub, ih, sub_zsmul, one_zsmul, ← sub_eq_add_neg, forall_const]\n\n"}
{"name":"Int.two_le_iff_pos_of_even","module":"Mathlib.Algebra.Order.Ring.Int","initialProofState":"m : Int\neven : Even m\n⊢ Iff (LE.le 2 m) (LT.lt 0 m)","decl":"lemma two_le_iff_pos_of_even {m : ℤ} (even : Even m) : 2 ≤ m ↔ 0 < m :=\n  le_iff_pos_of_dvd (by decide) even.two_dvd\n\n"}
{"name":"Int.add_two_le_iff_lt_of_even_sub","module":"Mathlib.Algebra.Order.Ring.Int","initialProofState":"m n : Int\neven : Even (HSub.hSub n m)\n⊢ Iff (LE.le (HAdd.hAdd m 2) n) (LT.lt m n)","decl":"lemma add_two_le_iff_lt_of_even_sub {m n : ℤ} (even : Even (n - m)) : m + 2 ≤ n ↔ m < n := by\n  rw [add_comm]; exact le_add_iff_lt_of_dvd_sub (by decide) even.two_dvd\n\n"}
