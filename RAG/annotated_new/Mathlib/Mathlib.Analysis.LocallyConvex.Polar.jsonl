{"name":"LinearMap.polar_mem_iff","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedCommRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\ns : Set E\ny : F\n⊢ Iff (Membership.mem (B.polar s) y) (∀ (x : E), Membership.mem s x → LE.le (Norm.norm ((B x) y)) 1)","decl":"theorem polar_mem_iff (s : Set E) (y : F) : y ∈ B.polar s ↔ ∀ x ∈ s, ‖B x y‖ ≤ 1 :=\n  Iff.rfl\n\n"}
{"name":"LinearMap.polar_mem","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedCommRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\ns : Set E\ny : F\nhy : Membership.mem (B.polar s) y\nx : E\na✝ : Membership.mem s x\n⊢ LE.le (Norm.norm ((B x) y)) 1","decl":"theorem polar_mem (s : Set E) (y : F) (hy : y ∈ B.polar s) : ∀ x ∈ s, ‖B x y‖ ≤ 1 :=\n  hy\n\n"}
{"name":"LinearMap.zero_mem_polar","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedCommRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\ns : Set E\n⊢ Membership.mem (B.polar s) 0","decl":"@[simp]\ntheorem zero_mem_polar (s : Set E) : (0 : F) ∈ B.polar s := fun _ _ => by\n  simp only [map_zero, norm_zero, zero_le_one]\n\n"}
{"name":"LinearMap.polar_nonempty","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedCommRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\ns : Set E\n⊢ (B.polar s).Nonempty","decl":"theorem polar_nonempty (s : Set E) : Set.Nonempty (B.polar s) := by\n  use 0\n  exact zero_mem_polar B s\n\n"}
{"name":"LinearMap.polar_eq_iInter","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedCommRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\ns : Set E\n⊢ Eq (B.polar s) (Set.iInter fun x => Set.iInter fun h => setOf fun y => LE.le (Norm.norm ((B x) y)) 1)","decl":"theorem polar_eq_iInter {s : Set E} : B.polar s = ⋂ x ∈ s, { y : F | ‖B x y‖ ≤ 1 } := by\n  ext\n  simp only [polar_mem_iff, Set.mem_iInter, Set.mem_setOf_eq]\n\n"}
{"name":"LinearMap.polar_gc","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedCommRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\n⊢ GaloisConnection (Function.comp (⇑OrderDual.toDual) B.polar) (Function.comp B.flip.polar ⇑OrderDual.ofDual)","decl":"/-- The map `B.polar : Set E → Set F` forms an order-reversing Galois connection with\n`B.flip.polar : Set F → Set E`. We use `OrderDual.toDual` and `OrderDual.ofDual` to express\nthat `polar` is order-reversing. -/\ntheorem polar_gc :\n    GaloisConnection (OrderDual.toDual ∘ B.polar) (B.flip.polar ∘ OrderDual.ofDual) := fun _ _ =>\n  ⟨fun h _ hx _ hy => h hy _ hx, fun h _ hx _ hy => h hy _ hx⟩\n\n"}
{"name":"LinearMap.polar_iUnion","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedCommRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\nι : Sort u_4\ns : ι → Set E\n⊢ Eq (B.polar (Set.iUnion fun i => s i)) (Set.iInter fun i => B.polar (s i))","decl":"@[simp]\ntheorem polar_iUnion {ι} {s : ι → Set E} : B.polar (⋃ i, s i) = ⋂ i, B.polar (s i) :=\n  B.polar_gc.l_iSup\n\n"}
{"name":"LinearMap.polar_union","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedCommRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\ns t : Set E\n⊢ Eq (B.polar (Union.union s t)) (Inter.inter (B.polar s) (B.polar t))","decl":"@[simp]\ntheorem polar_union {s t : Set E} : B.polar (s ∪ t) = B.polar s ∩ B.polar t :=\n  B.polar_gc.l_sup\n\n"}
{"name":"LinearMap.polar_antitone","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedCommRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\n⊢ Antitone B.polar","decl":"theorem polar_antitone : Antitone (B.polar : Set E → Set F) :=\n  B.polar_gc.monotone_l\n\n"}
{"name":"LinearMap.polar_empty","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedCommRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\n⊢ Eq (B.polar EmptyCollection.emptyCollection) Set.univ","decl":"@[simp]\ntheorem polar_empty : B.polar ∅ = Set.univ :=\n  B.polar_gc.l_bot\n\n"}
{"name":"LinearMap.polar_singleton","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedCommRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\na : E\n⊢ Eq (B.polar (Singleton.singleton a)) (setOf fun y => LE.le (Norm.norm ((B a) y)) 1)","decl":"@[simp]\ntheorem polar_singleton {a : E} : B.polar {a} = { y | ‖B a y‖ ≤ 1 } := le_antisymm\n  (fun _ hy => hy _ rfl)\n  (fun y hy => (polar_mem_iff _ _ _).mp (fun _ hb => by rw [Set.mem_singleton_iff.mp hb]; exact hy))\n\n"}
{"name":"LinearMap.mem_polar_singleton","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedCommRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\nx : E\ny : F\n⊢ Iff (Membership.mem (B.polar (Singleton.singleton x)) y) (LE.le (Norm.norm ((B x) y)) 1)","decl":"theorem mem_polar_singleton {x : E} (y : F) : y ∈ B.polar {x} ↔ ‖B x y‖ ≤ 1 := by\n  simp only [polar_singleton, Set.mem_setOf_eq]\n\n"}
{"name":"LinearMap.polar_zero","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedCommRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\n⊢ Eq (B.polar (Singleton.singleton 0)) Set.univ","decl":"theorem polar_zero : B.polar ({0} : Set E) = Set.univ := by\n  simp only [polar_singleton, map_zero, zero_apply, norm_zero, zero_le_one, Set.setOf_true]\n\n"}
{"name":"LinearMap.subset_bipolar","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedCommRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\ns : Set E\n⊢ HasSubset.Subset s (B.flip.polar (B.polar s))","decl":"theorem subset_bipolar (s : Set E) : s ⊆ B.flip.polar (B.polar s) := fun x hx y hy => by\n  rw [B.flip_apply]\n  exact hy x hx\n\n"}
{"name":"LinearMap.tripolar_eq_polar","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedCommRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\ns : Set E\n⊢ Eq (B.polar (B.flip.polar (B.polar s))) (B.polar s)","decl":"@[simp]\ntheorem tripolar_eq_polar (s : Set E) : B.polar (B.flip.polar (B.polar s)) = B.polar s :=\n  (B.polar_antitone (B.subset_bipolar s)).antisymm (subset_bipolar B.flip (B.polar s))\n\n"}
{"name":"LinearMap.polar_weak_closed","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedCommRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\ns : Set E\n⊢ IsClosed (B.polar s)","decl":"/-- The polar set is closed in the weak topology induced by `B.flip`. -/\ntheorem polar_weak_closed (s : Set E) : IsClosed[WeakBilin.instTopologicalSpace B.flip]\n    (B.polar s) := by\n  rw [polar_eq_iInter]\n  refine isClosed_iInter fun x => isClosed_iInter fun _ => ?_\n  exact isClosed_le (WeakBilin.eval_continuous B.flip x).norm continuous_const\n\n"}
{"name":"LinearMap.sInter_polar_finite_subset_eq_polar","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedCommRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\ns : Set E\n⊢ Eq (Set.image B.polar (setOf fun F => And F.Finite (HasSubset.Subset F s))).sInter (B.polar s)","decl":"theorem sInter_polar_finite_subset_eq_polar (s : Set E) :\n    ⋂₀ (B.polar '' { F | F.Finite ∧ F ⊆ s }) = B.polar s := by\n  ext x\n  simp only [Set.sInter_image, Set.mem_setOf_eq, Set.mem_iInter, and_imp]\n  refine ⟨fun hx a ha ↦ ?_, fun hx F _ hF₂ => polar_antitone _ hF₂ hx⟩\n  simpa [mem_polar_singleton] using hx _ (Set.finite_singleton a) (Set.singleton_subset_iff.mpr ha)\n\n"}
{"name":"LinearMap.polar_univ","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\nh : B.SeparatingRight\n⊢ Eq (B.polar Set.univ) (Singleton.singleton 0)","decl":"theorem polar_univ (h : SeparatingRight B) : B.polar Set.univ = {(0 : F)} := by\n  rw [Set.eq_singleton_iff_unique_mem]\n  refine ⟨by simp only [zero_mem_polar], fun y hy => h _ fun x => ?_⟩\n  refine norm_le_zero_iff.mp (le_of_forall_gt_imp_ge_of_dense fun ε hε => ?_)\n  rcases NormedField.exists_norm_lt 𝕜 hε with ⟨c, hc, hcε⟩\n  calc\n    ‖B x y‖ = ‖c‖ * ‖B (c⁻¹ • x) y‖ := by\n      rw [B.map_smul, LinearMap.smul_apply, Algebra.id.smul_eq_mul, norm_mul, norm_inv,\n        mul_inv_cancel_left₀ hc.ne']\n    _ ≤ ε * 1 := by gcongr; exact hy _ trivial\n    _ = ε := mul_one _\n\n"}
{"name":"LinearMap.polar_subMulAction","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : AddCommMonoid E\ninst✝⁴ : AddCommMonoid F\ninst✝³ : Module 𝕜 E\ninst✝² : Module 𝕜 F\nB : LinearMap (RingHom.id 𝕜) E (LinearMap (RingHom.id 𝕜) F 𝕜)\nS : Type u_4\ninst✝¹ : SetLike S E\ninst✝ : SMulMemClass S 𝕜 E\nm : S\n⊢ Eq (B.polar ↑m) (setOf fun y => ∀ (x : E), Membership.mem m x → Eq ((B x) y) 0)","decl":"theorem polar_subMulAction {S : Type*} [SetLike S E] [SMulMemClass S 𝕜 E] (m : S) :\n    B.polar m = { y | ∀ x ∈ m, B x y = 0 } := by\n  ext y\n  constructor\n  · intro hy x hx\n    obtain ⟨r, hr⟩ := NormedField.exists_lt_norm 𝕜 ‖B x y‖⁻¹\n    contrapose! hr\n    rw [← one_div, le_div_iff₀ (norm_pos_iff.2 hr)]\n    simpa using hy _ (SMulMemClass.smul_mem r hx)\n  · intro h x hx\n    simp [h x hx]\n\n"}
