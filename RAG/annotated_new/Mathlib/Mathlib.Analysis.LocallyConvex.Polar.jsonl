{"name":"LinearMap.polar_mem_iff","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedCommRing ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nB : LinearMap (RingHom.id ğ•œ) E (LinearMap (RingHom.id ğ•œ) F ğ•œ)\ns : Set E\ny : F\nâŠ¢ Iff (Membership.mem (B.polar s) y) (âˆ€ (x : E), Membership.mem s x â†’ LE.le (Norm.norm ((B x) y)) 1)","decl":"theorem polar_mem_iff (s : Set E) (y : F) : y âˆˆ B.polar s â†” âˆ€ x âˆˆ s, â€–B x yâ€– â‰¤ 1 :=\n  Iff.rfl\n\n"}
{"name":"LinearMap.polar_mem","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedCommRing ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nB : LinearMap (RingHom.id ğ•œ) E (LinearMap (RingHom.id ğ•œ) F ğ•œ)\ns : Set E\ny : F\nhy : Membership.mem (B.polar s) y\nx : E\naâœ : Membership.mem s x\nâŠ¢ LE.le (Norm.norm ((B x) y)) 1","decl":"theorem polar_mem (s : Set E) (y : F) (hy : y âˆˆ B.polar s) : âˆ€ x âˆˆ s, â€–B x yâ€– â‰¤ 1 :=\n  hy\n\n"}
{"name":"LinearMap.zero_mem_polar","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedCommRing ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nB : LinearMap (RingHom.id ğ•œ) E (LinearMap (RingHom.id ğ•œ) F ğ•œ)\ns : Set E\nâŠ¢ Membership.mem (B.polar s) 0","decl":"@[simp]\ntheorem zero_mem_polar (s : Set E) : (0 : F) âˆˆ B.polar s := fun _ _ => by\n  simp only [map_zero, norm_zero, zero_le_one]\n\n"}
{"name":"LinearMap.polar_nonempty","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedCommRing ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nB : LinearMap (RingHom.id ğ•œ) E (LinearMap (RingHom.id ğ•œ) F ğ•œ)\ns : Set E\nâŠ¢ (B.polar s).Nonempty","decl":"theorem polar_nonempty (s : Set E) : Set.Nonempty (B.polar s) := by\n  use 0\n  exact zero_mem_polar B s\n\n"}
{"name":"LinearMap.polar_eq_iInter","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedCommRing ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nB : LinearMap (RingHom.id ğ•œ) E (LinearMap (RingHom.id ğ•œ) F ğ•œ)\ns : Set E\nâŠ¢ Eq (B.polar s) (Set.iInter fun x => Set.iInter fun h => setOf fun y => LE.le (Norm.norm ((B x) y)) 1)","decl":"theorem polar_eq_iInter {s : Set E} : B.polar s = â‹‚ x âˆˆ s, { y : F | â€–B x yâ€– â‰¤ 1 } := by\n  ext\n  simp only [polar_mem_iff, Set.mem_iInter, Set.mem_setOf_eq]\n\n"}
{"name":"LinearMap.polar_gc","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedCommRing ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nB : LinearMap (RingHom.id ğ•œ) E (LinearMap (RingHom.id ğ•œ) F ğ•œ)\nâŠ¢ GaloisConnection (Function.comp (â‡‘OrderDual.toDual) B.polar) (Function.comp B.flip.polar â‡‘OrderDual.ofDual)","decl":"/-- The map `B.polar : Set E â†’ Set F` forms an order-reversing Galois connection with\n`B.flip.polar : Set F â†’ Set E`. We use `OrderDual.toDual` and `OrderDual.ofDual` to express\nthat `polar` is order-reversing. -/\ntheorem polar_gc :\n    GaloisConnection (OrderDual.toDual âˆ˜ B.polar) (B.flip.polar âˆ˜ OrderDual.ofDual) := fun _ _ =>\n  âŸ¨fun h _ hx _ hy => h hy _ hx, fun h _ hx _ hy => h hy _ hxâŸ©\n\n"}
{"name":"LinearMap.polar_iUnion","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedCommRing ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nB : LinearMap (RingHom.id ğ•œ) E (LinearMap (RingHom.id ğ•œ) F ğ•œ)\nÎ¹ : Sort u_4\ns : Î¹ â†’ Set E\nâŠ¢ Eq (B.polar (Set.iUnion fun i => s i)) (Set.iInter fun i => B.polar (s i))","decl":"@[simp]\ntheorem polar_iUnion {Î¹} {s : Î¹ â†’ Set E} : B.polar (â‹ƒ i, s i) = â‹‚ i, B.polar (s i) :=\n  B.polar_gc.l_iSup\n\n"}
{"name":"LinearMap.polar_union","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedCommRing ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nB : LinearMap (RingHom.id ğ•œ) E (LinearMap (RingHom.id ğ•œ) F ğ•œ)\ns t : Set E\nâŠ¢ Eq (B.polar (Union.union s t)) (Inter.inter (B.polar s) (B.polar t))","decl":"@[simp]\ntheorem polar_union {s t : Set E} : B.polar (s âˆª t) = B.polar s âˆ© B.polar t :=\n  B.polar_gc.l_sup\n\n"}
{"name":"LinearMap.polar_antitone","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedCommRing ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nB : LinearMap (RingHom.id ğ•œ) E (LinearMap (RingHom.id ğ•œ) F ğ•œ)\nâŠ¢ Antitone B.polar","decl":"theorem polar_antitone : Antitone (B.polar : Set E â†’ Set F) :=\n  B.polar_gc.monotone_l\n\n"}
{"name":"LinearMap.polar_empty","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedCommRing ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nB : LinearMap (RingHom.id ğ•œ) E (LinearMap (RingHom.id ğ•œ) F ğ•œ)\nâŠ¢ Eq (B.polar EmptyCollection.emptyCollection) Set.univ","decl":"@[simp]\ntheorem polar_empty : B.polar âˆ… = Set.univ :=\n  B.polar_gc.l_bot\n\n"}
{"name":"LinearMap.polar_singleton","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedCommRing ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nB : LinearMap (RingHom.id ğ•œ) E (LinearMap (RingHom.id ğ•œ) F ğ•œ)\na : E\nâŠ¢ Eq (B.polar (Singleton.singleton a)) (setOf fun y => LE.le (Norm.norm ((B a) y)) 1)","decl":"@[simp]\ntheorem polar_singleton {a : E} : B.polar {a} = { y | â€–B a yâ€– â‰¤ 1 } := le_antisymm\n  (fun _ hy => hy _ rfl)\n  (fun y hy => (polar_mem_iff _ _ _).mp (fun _ hb => by rw [Set.mem_singleton_iff.mp hb]; exact hy))\n\n"}
{"name":"LinearMap.mem_polar_singleton","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedCommRing ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nB : LinearMap (RingHom.id ğ•œ) E (LinearMap (RingHom.id ğ•œ) F ğ•œ)\nx : E\ny : F\nâŠ¢ Iff (Membership.mem (B.polar (Singleton.singleton x)) y) (LE.le (Norm.norm ((B x) y)) 1)","decl":"theorem mem_polar_singleton {x : E} (y : F) : y âˆˆ B.polar {x} â†” â€–B x yâ€– â‰¤ 1 := by\n  simp only [polar_singleton, Set.mem_setOf_eq]\n\n"}
{"name":"LinearMap.polar_zero","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedCommRing ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nB : LinearMap (RingHom.id ğ•œ) E (LinearMap (RingHom.id ğ•œ) F ğ•œ)\nâŠ¢ Eq (B.polar (Singleton.singleton 0)) Set.univ","decl":"theorem polar_zero : B.polar ({0} : Set E) = Set.univ := by\n  simp only [polar_singleton, map_zero, zero_apply, norm_zero, zero_le_one, Set.setOf_true]\n\n"}
{"name":"LinearMap.subset_bipolar","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedCommRing ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nB : LinearMap (RingHom.id ğ•œ) E (LinearMap (RingHom.id ğ•œ) F ğ•œ)\ns : Set E\nâŠ¢ HasSubset.Subset s (B.flip.polar (B.polar s))","decl":"theorem subset_bipolar (s : Set E) : s âŠ† B.flip.polar (B.polar s) := fun x hx y hy => by\n  rw [B.flip_apply]\n  exact hy x hx\n\n"}
{"name":"LinearMap.tripolar_eq_polar","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedCommRing ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nB : LinearMap (RingHom.id ğ•œ) E (LinearMap (RingHom.id ğ•œ) F ğ•œ)\ns : Set E\nâŠ¢ Eq (B.polar (B.flip.polar (B.polar s))) (B.polar s)","decl":"@[simp]\ntheorem tripolar_eq_polar (s : Set E) : B.polar (B.flip.polar (B.polar s)) = B.polar s :=\n  (B.polar_antitone (B.subset_bipolar s)).antisymm (subset_bipolar B.flip (B.polar s))\n\n"}
{"name":"LinearMap.polar_weak_closed","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedCommRing ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nB : LinearMap (RingHom.id ğ•œ) E (LinearMap (RingHom.id ğ•œ) F ğ•œ)\ns : Set E\nâŠ¢ IsClosed (B.polar s)","decl":"/-- The polar set is closed in the weak topology induced by `B.flip`. -/\ntheorem polar_weak_closed (s : Set E) : IsClosed[WeakBilin.instTopologicalSpace B.flip]\n    (B.polar s) := by\n  rw [polar_eq_iInter]\n  refine isClosed_iInter fun x => isClosed_iInter fun _ => ?_\n  exact isClosed_le (WeakBilin.eval_continuous B.flip x).norm continuous_const\n\n"}
{"name":"LinearMap.sInter_polar_finite_subset_eq_polar","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedCommRing ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nB : LinearMap (RingHom.id ğ•œ) E (LinearMap (RingHom.id ğ•œ) F ğ•œ)\ns : Set E\nâŠ¢ Eq (Set.image B.polar (setOf fun F => And F.Finite (HasSubset.Subset F s))).sInter (B.polar s)","decl":"theorem sInter_polar_finite_subset_eq_polar (s : Set E) :\n    â‹‚â‚€ (B.polar '' { F | F.Finite âˆ§ F âŠ† s }) = B.polar s := by\n  ext x\n  simp only [Set.sInter_image, Set.mem_setOf_eq, Set.mem_iInter, and_imp]\n  refine âŸ¨fun hx a ha â†¦ ?_, fun hx F _ hFâ‚‚ => polar_antitone _ hFâ‚‚ hxâŸ©\n  simpa [mem_polar_singleton] using hx _ (Set.finite_singleton a) (Set.singleton_subset_iff.mpr ha)\n\n"}
{"name":"LinearMap.polar_univ","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nB : LinearMap (RingHom.id ğ•œ) E (LinearMap (RingHom.id ğ•œ) F ğ•œ)\nh : B.SeparatingRight\nâŠ¢ Eq (B.polar Set.univ) (Singleton.singleton 0)","decl":"theorem polar_univ (h : SeparatingRight B) : B.polar Set.univ = {(0 : F)} := by\n  rw [Set.eq_singleton_iff_unique_mem]\n  refine âŸ¨by simp only [zero_mem_polar], fun y hy => h _ fun x => ?_âŸ©\n  refine norm_le_zero_iff.mp (le_of_forall_gt_imp_ge_of_dense fun Îµ hÎµ => ?_)\n  rcases NormedField.exists_norm_lt ğ•œ hÎµ with âŸ¨c, hc, hcÎµâŸ©\n  calc\n    â€–B x yâ€– = â€–câ€– * â€–B (câ»Â¹ â€¢ x) yâ€– := by\n      rw [B.map_smul, LinearMap.smul_apply, Algebra.id.smul_eq_mul, norm_mul, norm_inv,\n        mul_inv_cancel_leftâ‚€ hc.ne']\n    _ â‰¤ Îµ * 1 := by gcongr; exact hy _ trivial\n    _ = Îµ := mul_one _\n\n"}
{"name":"LinearMap.polar_subMulAction","module":"Mathlib.Analysis.LocallyConvex.Polar","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : AddCommMonoid E\ninstâœâ´ : AddCommMonoid F\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : Module ğ•œ F\nB : LinearMap (RingHom.id ğ•œ) E (LinearMap (RingHom.id ğ•œ) F ğ•œ)\nS : Type u_4\ninstâœÂ¹ : SetLike S E\ninstâœ : SMulMemClass S ğ•œ E\nm : S\nâŠ¢ Eq (B.polar â†‘m) (setOf fun y => âˆ€ (x : E), Membership.mem m x â†’ Eq ((B x) y) 0)","decl":"theorem polar_subMulAction {S : Type*} [SetLike S E] [SMulMemClass S ğ•œ E] (m : S) :\n    B.polar m = { y | âˆ€ x âˆˆ m, B x y = 0 } := by\n  ext y\n  constructor\n  Â· intro hy x hx\n    obtain âŸ¨r, hrâŸ© := NormedField.exists_lt_norm ğ•œ â€–B x yâ€–â»Â¹\n    contrapose! hr\n    rw [â† one_div, le_div_iffâ‚€ (norm_pos_iff.2 hr)]\n    simpa using hy _ (SMulMemClass.smul_mem r hx)\n  Â· intro h x hx\n    simp [h x hx]\n\n"}
