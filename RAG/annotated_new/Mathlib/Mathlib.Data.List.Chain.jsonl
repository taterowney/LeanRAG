{"name":"List.chain_iff","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u_1\nR : α → α → Prop\na✝¹ : α\na✝ : List α\n⊢ Iff (List.Chain R a✝¹ a✝) (Or (Eq a✝ List.nil) (Exists fun b => Exists fun l => And (R a✝¹ b) (And (List.Chain R b l) (Eq a✝ (List.cons b l)))))","decl":"mk_iff_of_inductive_prop List.Chain List.chain_iff\n\n"}
{"name":"List.Chain.iff","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR S : α → α → Prop\nH : ∀ (a b : α), Iff (R a b) (S a b)\na : α\nl : List α\n⊢ Iff (List.Chain R a l) (List.Chain S a l)","decl":"theorem Chain.iff {S : α → α → Prop} (H : ∀ a b, R a b ↔ S a b) {a : α} {l : List α} :\n    Chain R a l ↔ Chain S a l :=\n  ⟨Chain.imp fun a b => (H a b).1, Chain.imp fun a b => (H a b).2⟩\n\n"}
{"name":"List.Chain.iff_mem","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\na : α\nl : List α\n⊢ Iff (List.Chain R a l) (List.Chain (fun x y => And (Membership.mem (List.cons a l) x) (And (Membership.mem l y) (R x y))) a l)","decl":"theorem Chain.iff_mem {a : α} {l : List α} :\n    Chain R a l ↔ Chain (fun x y => x ∈ a :: l ∧ y ∈ l ∧ R x y) a l :=\n  ⟨fun p => by\n    induction p with\n    | nil => exact nil\n    | @cons _ _ _ r _ IH =>\n      constructor\n      · exact ⟨mem_cons_self _ _, mem_cons_self _ _, r⟩\n      · exact IH.imp fun a b ⟨am, bm, h⟩ => ⟨mem_cons_of_mem _ am, mem_cons_of_mem _ bm, h⟩,\n    Chain.imp fun _ _ h => h.2.2⟩\n\n"}
{"name":"List.chain_singleton","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\na b : α\n⊢ Iff (List.Chain R a (List.cons b List.nil)) (R a b)","decl":"theorem chain_singleton {a b : α} : Chain R a [b] ↔ R a b := by\n  simp only [chain_cons, Chain.nil, and_true]\n\n"}
{"name":"List.chain_split","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\na b : α\nl₁ l₂ : List α\n⊢ Iff (List.Chain R a (HAppend.hAppend l₁ (List.cons b l₂))) (And (List.Chain R a (HAppend.hAppend l₁ (List.cons b List.nil))) (List.Chain R b l₂))","decl":"theorem chain_split {a b : α} {l₁ l₂ : List α} :\n    Chain R a (l₁ ++ b :: l₂) ↔ Chain R a (l₁ ++ [b]) ∧ Chain R b l₂ := by\n  induction' l₁ with x l₁ IH generalizing a <;>\n    simp only [*, nil_append, cons_append, Chain.nil, chain_cons, and_true, and_assoc]\n\n"}
{"name":"List.chain_append_cons_cons","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\na b c : α\nl₁ l₂ : List α\n⊢ Iff (List.Chain R a (HAppend.hAppend l₁ (List.cons b (List.cons c l₂)))) (And (List.Chain R a (HAppend.hAppend l₁ (List.cons b List.nil))) (And (R b c) (List.Chain R c l₂)))","decl":"@[simp]\ntheorem chain_append_cons_cons {a b c : α} {l₁ l₂ : List α} :\n    Chain R a (l₁ ++ b :: c :: l₂) ↔ Chain R a (l₁ ++ [b]) ∧ R b c ∧ Chain R c l₂ := by\n  rw [chain_split, chain_cons]\n\n"}
{"name":"List.chain_iff_forall₂","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\na : α\nl : List α\n⊢ Iff (List.Chain R a l) (Or (Eq l List.nil) (List.Forall₂ R (List.cons a l.dropLast) l))","decl":"theorem chain_iff_forall₂ :\n    ∀ {a : α} {l : List α}, Chain R a l ↔ l = [] ∨ Forall₂ R (a :: dropLast l) l\n  | a, [] => by simp\n  | a, b :: l => by\n    by_cases h : l = [] <;>\n    simp [@chain_iff_forall₂ b l, dropLast, *]\n\n"}
{"name":"List.chain_append_singleton_iff_forall₂","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nl : List α\na b : α\n⊢ Iff (List.Chain R a (HAppend.hAppend l (List.cons b List.nil))) (List.Forall₂ R (List.cons a l) (HAppend.hAppend l (List.cons b List.nil)))","decl":"theorem chain_append_singleton_iff_forall₂ :\n    Chain R a (l ++ [b]) ↔ Forall₂ R (a :: l) (l ++ [b]) := by simp [chain_iff_forall₂]\n\n"}
{"name":"List.chain_map","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nβ : Type v\nR : α → α → Prop\nf : β → α\nb : β\nl : List β\n⊢ Iff (List.Chain R (f b) (List.map f l)) (List.Chain (fun a b => R (f a) (f b)) b l)","decl":"theorem chain_map (f : β → α) {b : β} {l : List β} :\n    Chain R (f b) (map f l) ↔ Chain (fun a b : β => R (f a) (f b)) b l := by\n  induction l generalizing b <;> simp only [map, Chain.nil, chain_cons, *]\n\n"}
{"name":"List.chain_of_chain_map","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nβ : Type v\nR : α → α → Prop\nS : β → β → Prop\nf : α → β\nH : ∀ (a b : α), S (f a) (f b) → R a b\na : α\nl : List α\np : List.Chain S (f a) (List.map f l)\n⊢ List.Chain R a l","decl":"theorem chain_of_chain_map {S : β → β → Prop} (f : α → β) (H : ∀ a b : α, S (f a) (f b) → R a b)\n    {a : α} {l : List α} (p : Chain S (f a) (map f l)) : Chain R a l :=\n  ((chain_map f).1 p).imp H\n\n"}
{"name":"List.chain_map_of_chain","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nβ : Type v\nR : α → α → Prop\nS : β → β → Prop\nf : α → β\nH : ∀ (a b : α), R a b → S (f a) (f b)\na : α\nl : List α\np : List.Chain R a l\n⊢ List.Chain S (f a) (List.map f l)","decl":"theorem chain_map_of_chain {S : β → β → Prop} (f : α → β) (H : ∀ a b : α, R a b → S (f a) (f b))\n    {a : α} {l : List α} (p : Chain R a l) : Chain S (f a) (map f l) :=\n  (chain_map f).2 <| p.imp H\n\n"}
{"name":"List.chain_pmap_of_chain","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nβ : Type v\nR : α → α → Prop\nS : β → β → Prop\np : α → Prop\nf : (a : α) → p a → β\nH : ∀ (a b : α) (ha : p a) (hb : p b), R a b → S (f a ha) (f b hb)\na : α\nl : List α\nhl₁ : List.Chain R a l\nha : p a\nhl₂ : ∀ (a : α), Membership.mem l a → p a\n⊢ List.Chain S (f a ha) (List.pmap f l hl₂)","decl":"theorem chain_pmap_of_chain {S : β → β → Prop} {p : α → Prop} {f : ∀ a, p a → β}\n    (H : ∀ a b ha hb, R a b → S (f a ha) (f b hb)) {a : α} {l : List α} (hl₁ : Chain R a l)\n    (ha : p a) (hl₂ : ∀ a ∈ l, p a) : Chain S (f a ha) (List.pmap f l hl₂) := by\n  induction' l with lh lt l_ih generalizing a\n  · simp\n  · simp [H _ _ _ _ (rel_of_chain_cons hl₁), l_ih (chain_of_chain_cons hl₁)]\n\n"}
{"name":"List.chain_of_chain_pmap","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nβ : Type v\nR : α → α → Prop\nS : β → β → Prop\np : α → Prop\nf : (a : α) → p a → β\nl : List α\nhl₁ : ∀ (a : α), Membership.mem l a → p a\na : α\nha : p a\nhl₂ : List.Chain S (f a ha) (List.pmap f l hl₁)\nH : ∀ (a b : α) (ha : p a) (hb : p b), S (f a ha) (f b hb) → R a b\n⊢ List.Chain R a l","decl":"theorem chain_of_chain_pmap {S : β → β → Prop} {p : α → Prop} (f : ∀ a, p a → β) {l : List α}\n    (hl₁ : ∀ a ∈ l, p a) {a : α} (ha : p a) (hl₂ : Chain S (f a ha) (List.pmap f l hl₁))\n    (H : ∀ a b ha hb, S (f a ha) (f b hb) → R a b) : Chain R a l := by\n  induction' l with lh lt l_ih generalizing a\n  · simp\n  · simp [H _ _ _ _ (rel_of_chain_cons hl₂), l_ih _ _ (chain_of_chain_cons hl₂)]\n\n"}
{"name":"List.Chain.pairwise","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\ninst✝ : IsTrans α R\na : α\nl : List α\na✝ : List.Chain R a l\n⊢ List.Pairwise R (List.cons a l)","decl":"protected theorem Chain.pairwise [IsTrans α R] :\n    ∀ {a : α} {l : List α}, Chain R a l → Pairwise R (a :: l)\n  | _, [], Chain.nil => pairwise_singleton _ _\n  | a, _, @Chain.cons _ _ _ b l h hb =>\n    hb.pairwise.cons\n      (by\n        simp only [mem_cons, forall_eq_or_imp, h, true_and]\n        exact fun c hc => _root_.trans h (rel_of_pairwise_cons hb.pairwise hc))\n\n"}
{"name":"List.chain_iff_pairwise","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\ninst✝ : IsTrans α R\na : α\nl : List α\n⊢ Iff (List.Chain R a l) (List.Pairwise R (List.cons a l))","decl":"theorem chain_iff_pairwise [IsTrans α R] {a : α} {l : List α} : Chain R a l ↔ Pairwise R (a :: l) :=\n  ⟨Chain.pairwise, Pairwise.chain⟩\n\n"}
{"name":"List.Chain.sublist","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nl₁ l₂ : List α\na : α\ninst✝ : IsTrans α R\nhl : List.Chain R a l₂\nh : l₁.Sublist l₂\n⊢ List.Chain R a l₁","decl":"protected theorem Chain.sublist [IsTrans α R] (hl : l₂.Chain R a) (h : l₁ <+ l₂) :\n    l₁.Chain R a := by\n  rw [chain_iff_pairwise] at hl ⊢\n  exact hl.sublist (h.cons_cons a)\n\n"}
{"name":"List.Chain.rel","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nl : List α\na b : α\ninst✝ : IsTrans α R\nhl : List.Chain R a l\nhb : Membership.mem l b\n⊢ R a b","decl":"protected theorem Chain.rel [IsTrans α R] (hl : l.Chain R a) (hb : b ∈ l) : R a b := by\n  rw [chain_iff_pairwise] at hl\n  exact rel_of_pairwise_cons hl hb\n\n"}
{"name":"List.chain_iff_get","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\na : α\nl : List α\n⊢ Iff (List.Chain R a l) (And (∀ (h : LT.lt 0 l.length), R a (l.get ⟨0, h⟩)) (∀ (i : Nat), LT.lt i (HSub.hSub l.length 1) → R (l.get ⟨i, ⋯⟩) (l.get ⟨HAdd.hAdd i 1, ⋯⟩)))","decl":"theorem chain_iff_get {R} : ∀ {a : α} {l : List α}, Chain R a l ↔\n    (∀ h : 0 < length l, R a (get l ⟨0, h⟩)) ∧\n      ∀ (i : ℕ) (h : i < l.length - 1),\n        R (get l ⟨i, by omega⟩) (get l ⟨i+1, by omega⟩)\n  | a, [] => iff_of_true (by simp) ⟨fun h => by simp at h, fun _ h => by simp at h⟩\n  | a, b :: t => by\n    rw [chain_cons, @chain_iff_get _ _ t]\n    constructor\n    · rintro ⟨R, ⟨h0, h⟩⟩\n      constructor\n      · intro _\n        exact R\n      intro i w\n      cases' i with i\n      · apply h0\n      · exact h i (by simp only [length_cons] at w; omega)\n    rintro ⟨h0, h⟩; constructor\n    · apply h0\n      simp\n    constructor\n    · apply h 0\n    intro i w\n    exact h (i+1) (by simp only [length_cons]; omega)\n\n"}
{"name":"List.chain_replicate_of_rel","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nr : α → α → Prop\nn : Nat\na : α\nh : r a a\n⊢ List.Chain r a (List.replicate n a)","decl":"theorem chain_replicate_of_rel (n : ℕ) {a : α} (h : r a a) : Chain r a (replicate n a) :=\n  match n with\n  | 0 => Chain.nil\n  | n + 1 => Chain.cons h (chain_replicate_of_rel n h)\n\n"}
{"name":"List.chain_eq_iff_eq_replicate","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\na : α\nl : List α\n⊢ Iff (List.Chain (fun x1 x2 => Eq x1 x2) a l) (Eq l (List.replicate l.length a))","decl":"theorem chain_eq_iff_eq_replicate {a : α} {l : List α} :\n    Chain (· = ·) a l ↔ l = replicate l.length a :=\n  match l with\n  | [] => by simp\n  | b :: l => by\n    rw [chain_cons]\n    simp (config := {contextual := true}) [eq_comm, replicate_succ, chain_eq_iff_eq_replicate]\n\n"}
{"name":"List.Chain'.imp","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR S : α → α → Prop\nH : ∀ (a b : α), R a b → S a b\nl : List α\np : List.Chain' R l\n⊢ List.Chain' S l","decl":"theorem Chain'.imp {S : α → α → Prop} (H : ∀ a b, R a b → S a b) {l : List α} (p : Chain' R l) :\n    Chain' S l := by cases l <;> [trivial; exact Chain.imp H p]\n\n"}
{"name":"List.Chain'.iff","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR S : α → α → Prop\nH : ∀ (a b : α), Iff (R a b) (S a b)\nl : List α\n⊢ Iff (List.Chain' R l) (List.Chain' S l)","decl":"theorem Chain'.iff {S : α → α → Prop} (H : ∀ a b, R a b ↔ S a b) {l : List α} :\n    Chain' R l ↔ Chain' S l :=\n  ⟨Chain'.imp fun a b => (H a b).1, Chain'.imp fun a b => (H a b).2⟩\n\n"}
{"name":"List.Chain'.iff_mem","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nl : List α\n⊢ Iff (List.Chain' R l) (List.Chain' (fun x y => And (Membership.mem l x) (And (Membership.mem l y) (R x y))) l)","decl":"theorem Chain'.iff_mem : ∀ {l : List α}, Chain' R l ↔ Chain' (fun x y => x ∈ l ∧ y ∈ l ∧ R x y) l\n  | [] => Iff.rfl\n  | _ :: _ =>\n    ⟨fun h => (Chain.iff_mem.1 h).imp fun _ _ ⟨h₁, h₂, h₃⟩ => ⟨h₁, mem_cons.2 (Or.inr h₂), h₃⟩,\n      Chain'.imp fun _ _ h => h.2.2⟩\n\n"}
{"name":"List.chain'_nil","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\n⊢ List.Chain' R List.nil","decl":"@[simp]\ntheorem chain'_nil : Chain' R [] :=\n  trivial\n\n"}
{"name":"List.chain'_singleton","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\na : α\n⊢ List.Chain' R (List.cons a List.nil)","decl":"@[simp]\ntheorem chain'_singleton (a : α) : Chain' R [a] :=\n  Chain.nil\n\n"}
{"name":"List.chain'_cons","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nx y : α\nl : List α\n⊢ Iff (List.Chain' R (List.cons x (List.cons y l))) (And (R x y) (List.Chain' R (List.cons y l)))","decl":"@[simp]\ntheorem chain'_cons {x y l} : Chain' R (x :: y :: l) ↔ R x y ∧ Chain' R (y :: l) :=\n  chain_cons\n\n"}
{"name":"List.chain'_isInfix","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nl : List α\n⊢ List.Chain' (fun x y => (List.cons x (List.cons y List.nil)).IsInfix l) l","decl":"theorem chain'_isInfix : ∀ l : List α, Chain' (fun x y => [x, y] <:+: l) l\n  | [] => chain'_nil\n  | [_] => chain'_singleton _\n  | a :: b :: l =>\n    chain'_cons.2\n      ⟨⟨[], l, by simp⟩, (chain'_isInfix (b :: l)).imp fun _ _ h => h.trans ⟨[a], [], by simp⟩⟩\n\n"}
{"name":"List.chain'_split","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\na : α\nl₁ l₂ : List α\n⊢ Iff (List.Chain' R (HAppend.hAppend l₁ (List.cons a l₂))) (And (List.Chain' R (HAppend.hAppend l₁ (List.cons a List.nil))) (List.Chain' R (List.cons a l₂)))","decl":"theorem chain'_split {a : α} :\n    ∀ {l₁ l₂ : List α}, Chain' R (l₁ ++ a :: l₂) ↔ Chain' R (l₁ ++ [a]) ∧ Chain' R (a :: l₂)\n  | [], _ => (and_iff_right (chain'_singleton a)).symm\n  | _ :: _, _ => chain_split\n\n"}
{"name":"List.chain'_append_cons_cons","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nb c : α\nl₁ l₂ : List α\n⊢ Iff (List.Chain' R (HAppend.hAppend l₁ (List.cons b (List.cons c l₂)))) (And (List.Chain' R (HAppend.hAppend l₁ (List.cons b List.nil))) (And (R b c) (List.Chain' R (List.cons c l₂))))","decl":"@[simp]\ntheorem chain'_append_cons_cons {b c : α} {l₁ l₂ : List α} :\n    Chain' R (l₁ ++ b :: c :: l₂) ↔ Chain' R (l₁ ++ [b]) ∧ R b c ∧ Chain' R (c :: l₂) := by\n  rw [chain'_split, chain'_cons]\n\n"}
{"name":"List.chain'_map","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nβ : Type v\nR : α → α → Prop\nf : β → α\nl : List β\n⊢ Iff (List.Chain' R (List.map f l)) (List.Chain' (fun a b => R (f a) (f b)) l)","decl":"theorem chain'_map (f : β → α) {l : List β} :\n    Chain' R (map f l) ↔ Chain' (fun a b : β => R (f a) (f b)) l := by\n  cases l <;> [rfl; exact chain_map _]\n\n"}
{"name":"List.chain'_of_chain'_map","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nβ : Type v\nR : α → α → Prop\nS : β → β → Prop\nf : α → β\nH : ∀ (a b : α), S (f a) (f b) → R a b\nl : List α\np : List.Chain' S (List.map f l)\n⊢ List.Chain' R l","decl":"theorem chain'_of_chain'_map {S : β → β → Prop} (f : α → β) (H : ∀ a b : α, S (f a) (f b) → R a b)\n    {l : List α} (p : Chain' S (map f l)) : Chain' R l :=\n  ((chain'_map f).1 p).imp H\n\n"}
{"name":"List.chain'_map_of_chain'","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nβ : Type v\nR : α → α → Prop\nS : β → β → Prop\nf : α → β\nH : ∀ (a b : α), R a b → S (f a) (f b)\nl : List α\np : List.Chain' R l\n⊢ List.Chain' S (List.map f l)","decl":"theorem chain'_map_of_chain' {S : β → β → Prop} (f : α → β) (H : ∀ a b : α, R a b → S (f a) (f b))\n    {l : List α} (p : Chain' R l) : Chain' S (map f l) :=\n  (chain'_map f).2 <| p.imp H\n\n"}
{"name":"List.Pairwise.chain'","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nl : List α\na✝ : List.Pairwise R l\n⊢ List.Chain' R l","decl":"theorem Pairwise.chain' : ∀ {l : List α}, Pairwise R l → Chain' R l\n  | [], _ => trivial\n  | _ :: _, h => Pairwise.chain h\n\n"}
{"name":"List.chain'_iff_pairwise","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\ninst✝ : IsTrans α R\nl : List α\n⊢ Iff (List.Chain' R l) (List.Pairwise R l)","decl":"theorem chain'_iff_pairwise [IsTrans α R] : ∀ {l : List α}, Chain' R l ↔ Pairwise R l\n  | [] => (iff_true_intro Pairwise.nil).symm\n  | _ :: _ => chain_iff_pairwise\n\n"}
{"name":"List.Chain'.sublist","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nl₁ l₂ : List α\ninst✝ : IsTrans α R\nhl : List.Chain' R l₂\nh : l₁.Sublist l₂\n⊢ List.Chain' R l₁","decl":"protected theorem Chain'.sublist [IsTrans α R] (hl : l₂.Chain' R) (h : l₁ <+ l₂) : l₁.Chain' R := by\n  rw [chain'_iff_pairwise] at hl ⊢\n  exact hl.sublist h\n\n"}
{"name":"List.Chain'.cons","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nx y : α\nl : List α\nh₁ : R x y\nh₂ : List.Chain' R (List.cons y l)\n⊢ List.Chain' R (List.cons x (List.cons y l))","decl":"theorem Chain'.cons {x y l} (h₁ : R x y) (h₂ : Chain' R (y :: l)) : Chain' R (x :: y :: l) :=\n  chain'_cons.2 ⟨h₁, h₂⟩\n\n"}
{"name":"List.Chain'.tail","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nl : List α\na✝ : List.Chain' R l\n⊢ List.Chain' R l.tail","decl":"theorem Chain'.tail : ∀ {l}, Chain' R l → Chain' R l.tail\n  | [], _ => trivial\n  | [_], _ => trivial\n  | _ :: _ :: _, h => (chain'_cons.mp h).right\n\n"}
{"name":"List.Chain'.rel_head","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nx y : α\nl : List α\nh : List.Chain' R (List.cons x (List.cons y l))\n⊢ R x y","decl":"theorem Chain'.rel_head {x y l} (h : Chain' R (x :: y :: l)) : R x y :=\n  rel_of_chain_cons h\n\n"}
{"name":"List.Chain'.rel_head?","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nx : α\nl : List α\nh : List.Chain' R (List.cons x l)\ny : α\nhy : Membership.mem l.head? y\n⊢ R x y","decl":"theorem Chain'.rel_head? {x l} (h : Chain' R (x :: l)) ⦃y⦄ (hy : y ∈ head? l) : R x y := by\n  rw [← cons_head?_tail hy] at h\n  exact h.rel_head\n\n"}
{"name":"List.Chain'.cons'","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nx : α\nl : List α\na✝¹ : List.Chain' R l\na✝ : ∀ (y : α), Membership.mem l.head? y → R x y\n⊢ List.Chain' R (List.cons x l)","decl":"theorem Chain'.cons' {x} : ∀ {l : List α}, Chain' R l → (∀ y ∈ l.head?, R x y) → Chain' R (x :: l)\n  | [], _, _ => chain'_singleton x\n  | _ :: _, hl, H => hl.cons <| H _ rfl\n\n"}
{"name":"List.chain'_cons'","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nx : α\nl : List α\n⊢ Iff (List.Chain' R (List.cons x l)) (And (∀ (y : α), Membership.mem l.head? y → R x y) (List.Chain' R l))","decl":"theorem chain'_cons' {x l} : Chain' R (x :: l) ↔ (∀ y ∈ head? l, R x y) ∧ Chain' R l :=\n  ⟨fun h => ⟨h.rel_head?, h.tail⟩, fun ⟨h₁, h₂⟩ => h₂.cons' h₁⟩\n\n"}
{"name":"List.chain'_append","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nl₁ l₂ : List α\n⊢ Iff (List.Chain' R (HAppend.hAppend l₁ l₂)) (And (List.Chain' R l₁) (And (List.Chain' R l₂) (∀ (x : α), Membership.mem l₁.getLast? x → ∀ (y : α), Membership.mem l₂.head? y → R x y)))","decl":"theorem chain'_append :\n    ∀ {l₁ l₂ : List α},\n      Chain' R (l₁ ++ l₂) ↔ Chain' R l₁ ∧ Chain' R l₂ ∧ ∀ x ∈ l₁.getLast?, ∀ y ∈ l₂.head?, R x y\n  | [], l => by simp\n  | [a], l => by simp [chain'_cons', and_comm]\n  | a :: b :: l₁, l₂ => by\n    rw [cons_append, cons_append, chain'_cons, chain'_cons, ← cons_append, chain'_append, and_assoc]\n    simp\n\n"}
{"name":"List.Chain'.append","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nl₁ l₂ : List α\nh₁ : List.Chain' R l₁\nh₂ : List.Chain' R l₂\nh : ∀ (x : α), Membership.mem l₁.getLast? x → ∀ (y : α), Membership.mem l₂.head? y → R x y\n⊢ List.Chain' R (HAppend.hAppend l₁ l₂)","decl":"theorem Chain'.append (h₁ : Chain' R l₁) (h₂ : Chain' R l₂)\n    (h : ∀ x ∈ l₁.getLast?, ∀ y ∈ l₂.head?, R x y) : Chain' R (l₁ ++ l₂) :=\n  chain'_append.2 ⟨h₁, h₂, h⟩\n\n"}
{"name":"List.Chain'.left_of_append","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nl₁ l₂ : List α\nh : List.Chain' R (HAppend.hAppend l₁ l₂)\n⊢ List.Chain' R l₁","decl":"theorem Chain'.left_of_append (h : Chain' R (l₁ ++ l₂)) : Chain' R l₁ :=\n  (chain'_append.1 h).1\n\n"}
{"name":"List.Chain'.right_of_append","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nl₁ l₂ : List α\nh : List.Chain' R (HAppend.hAppend l₁ l₂)\n⊢ List.Chain' R l₂","decl":"theorem Chain'.right_of_append (h : Chain' R (l₁ ++ l₂)) : Chain' R l₂ :=\n  (chain'_append.1 h).2.1\n\n"}
{"name":"List.Chain'.infix","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nl l₁ : List α\nh : List.Chain' R l\nh' : l₁.IsInfix l\n⊢ List.Chain' R l₁","decl":"theorem Chain'.infix (h : Chain' R l) (h' : l₁ <:+: l) : Chain' R l₁ := by\n  rcases h' with ⟨l₂, l₃, rfl⟩\n  exact h.left_of_append.right_of_append\n\n"}
{"name":"List.Chain'.suffix","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nl l₁ : List α\nh : List.Chain' R l\nh' : l₁.IsSuffix l\n⊢ List.Chain' R l₁","decl":"theorem Chain'.suffix (h : Chain' R l) (h' : l₁ <:+ l) : Chain' R l₁ :=\n  h.infix h'.isInfix\n\n"}
{"name":"List.Chain'.prefix","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nl l₁ : List α\nh : List.Chain' R l\nh' : l₁.IsPrefix l\n⊢ List.Chain' R l₁","decl":"theorem Chain'.prefix (h : Chain' R l) (h' : l₁ <+: l) : Chain' R l₁ :=\n  h.infix h'.isInfix\n\n"}
{"name":"List.Chain'.drop","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nl : List α\nh : List.Chain' R l\nn : Nat\n⊢ List.Chain' R (List.drop n l)","decl":"theorem Chain'.drop (h : Chain' R l) (n : ℕ) : Chain' R (drop n l) :=\n  h.suffix (drop_suffix _ _)\n\n"}
{"name":"List.Chain'.init","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nl : List α\nh : List.Chain' R l\n⊢ List.Chain' R l.dropLast","decl":"theorem Chain'.init (h : Chain' R l) : Chain' R l.dropLast :=\n  h.prefix l.dropLast_prefix\n\n"}
{"name":"List.Chain'.take","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nl : List α\nh : List.Chain' R l\nn : Nat\n⊢ List.Chain' R (List.take n l)","decl":"theorem Chain'.take (h : Chain' R l) (n : ℕ) : Chain' R (take n l) :=\n  h.prefix (take_prefix _ _)\n\n"}
{"name":"List.chain'_pair","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nx y : α\n⊢ Iff (List.Chain' R (List.cons x (List.cons y List.nil))) (R x y)","decl":"theorem chain'_pair {x y} : Chain' R [x, y] ↔ R x y := by\n  simp only [chain'_singleton, chain'_cons, and_true]\n\n"}
{"name":"List.Chain'.imp_head","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nx y : α\nh : ∀ {z : α}, R x z → R y z\nl : List α\nhl : List.Chain' R (List.cons x l)\n⊢ List.Chain' R (List.cons y l)","decl":"theorem Chain'.imp_head {x y} (h : ∀ {z}, R x z → R y z) {l} (hl : Chain' R (x :: l)) :\n    Chain' R (y :: l) :=\n  hl.tail.cons' fun _ hz => h <| hl.rel_head? hz\n\n"}
{"name":"List.chain'_reverse","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nl : List α\n⊢ Iff (List.Chain' R l.reverse) (List.Chain' (flip R) l)","decl":"theorem chain'_reverse : ∀ {l}, Chain' R (reverse l) ↔ Chain' (flip R) l\n  | [] => Iff.rfl\n  | [a] => by simp only [chain'_singleton, reverse_singleton]\n  | a :: b :: l => by\n    rw [chain'_cons, reverse_cons, reverse_cons, append_assoc, cons_append, nil_append,\n      chain'_split, ← reverse_cons, @chain'_reverse (b :: l), and_comm, chain'_pair, flip]\n\n"}
{"name":"List.chain'_iff_get","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nl : List α\n⊢ Iff (List.Chain' R l) (∀ (i : Nat), LT.lt i (HSub.hSub l.length 1) → R (l.get ⟨i, ⋯⟩) (l.get ⟨HAdd.hAdd i 1, ⋯⟩))","decl":"theorem chain'_iff_get {R} : ∀ {l : List α}, Chain' R l ↔\n    ∀ (i : ℕ) (h : i < length l - 1),\n      R (get l ⟨i, by omega⟩) (get l ⟨i + 1, by omega⟩)\n  | [] => iff_of_true (by simp) (fun _ h => by simp at h)\n  | [a] => iff_of_true (by simp) (fun _ h => by simp at h)\n  | a :: b :: t => by\n    rw [← and_forall_add_one, chain'_cons, chain'_iff_get]\n    simp\n\n"}
{"name":"List.Chain'.append_overlap","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nl₁ l₂ l₃ : List α\nh₁ : List.Chain' R (HAppend.hAppend l₁ l₂)\nh₂ : List.Chain' R (HAppend.hAppend l₂ l₃)\nhn : Ne l₂ List.nil\n⊢ List.Chain' R (HAppend.hAppend (HAppend.hAppend l₁ l₂) l₃)","decl":"/-- If `l₁ l₂` and `l₃` are lists and `l₁ ++ l₂` and `l₂ ++ l₃` both satisfy\n  `Chain' R`, then so does `l₁ ++ l₂ ++ l₃` provided `l₂ ≠ []` -/\ntheorem Chain'.append_overlap {l₁ l₂ l₃ : List α} (h₁ : Chain' R (l₁ ++ l₂))\n    (h₂ : Chain' R (l₂ ++ l₃)) (hn : l₂ ≠ []) : Chain' R (l₁ ++ l₂ ++ l₃) :=\n  h₁.append h₂.right_of_append <| by\n    simpa only [getLast?_append_of_ne_nil _ hn] using (chain'_append.1 h₂).2.2\n\n"}
{"name":"List.chain'_flatten","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nL : List (List α)\na✝ : Not (Membership.mem L List.nil)\n⊢ Iff (List.Chain' R L.flatten) (And (∀ (l : List α), Membership.mem L l → List.Chain' R l) (List.Chain' (fun l₁ l₂ => ∀ (x : α), Membership.mem l₁.getLast? x → ∀ (y : α), Membership.mem l₂.head? y → R x y) L))","decl":"lemma chain'_flatten : ∀ {L : List (List α)}, [] ∉ L →\n    (Chain' R L.flatten ↔ (∀ l ∈ L, Chain' R l) ∧\n    L.Chain' (fun l₁ l₂ => ∀ᵉ (x ∈ l₁.getLast?) (y ∈ l₂.head?), R x y))\n| [], _ => by simp\n| [l], _ => by simp [flatten]\n| (l₁ :: l₂ :: L), hL => by\n    rw [mem_cons, not_or, ← Ne] at hL\n    rw [flatten, chain'_append, chain'_flatten hL.2, forall_mem_cons, chain'_cons]\n    rw [mem_cons, not_or, ← Ne] at hL\n    simp only [forall_mem_cons, and_assoc, flatten, head?_append_of_ne_nil _ hL.2.1.symm]\n    exact Iff.rfl.and (Iff.rfl.and <| Iff.rfl.and and_comm)\n\n"}
{"name":"List.chain'_join","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nR : α → α → Prop\nL : List (List α)\na✝ : Not (Membership.mem L List.nil)\n⊢ Iff (List.Chain' R L.flatten) (And (∀ (l : List α), Membership.mem L l → List.Chain' R l) (List.Chain' (fun l₁ l₂ => ∀ (x : α), Membership.mem l₁.getLast? x → ∀ (y : α), Membership.mem l₂.head? y → R x y) L))","decl":"@[deprecated (since := \"2024-10-15\")] alias chain'_join := chain'_flatten\n\n"}
{"name":"List.chain'_attachWith","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nl : List α\np : α → Prop\nh : ∀ (x : α), Membership.mem l x → p x\nr : (Subtype fun a => p a) → (Subtype fun a => p a) → Prop\n⊢ Iff (List.Chain' r (l.attachWith p h)) (List.Chain' (fun a b => Exists fun ha => Exists fun hb => r ⟨a, ha⟩ ⟨b, hb⟩) l)","decl":"theorem chain'_attachWith {l : List α} {p : α → Prop} (h : ∀ x ∈ l, p x)\n    {r : {a // p a} → {a // p a} → Prop} :\n    (l.attachWith p h).Chain' r ↔ l.Chain' fun a b ↦ ∃ ha hb, r ⟨a, ha⟩ ⟨b, hb⟩ := by\n  induction l with\n  | nil => rfl\n  | cons a l IH =>\n    rw [attachWith_cons, chain'_cons', chain'_cons', IH, and_congr_left]\n    simp_rw [head?_attachWith]\n    intros\n    constructor <;>\n    intro hc b (hb : _ = _)\n    · simp_rw [hb, Option.pbind_some] at hc\n      have hb' := h b (mem_cons_of_mem a (mem_of_mem_head? hb))\n      exact ⟨h a (mem_cons_self a l), hb', hc ⟨b, hb'⟩ rfl⟩\n    · cases l <;> aesop\n\n"}
{"name":"List.chain'_attach","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nl : List α\nr : (Subtype fun a => Membership.mem l a) → (Subtype fun a => Membership.mem l a) → Prop\n⊢ Iff (List.Chain' r l.attach) (List.Chain' (fun a b => Exists fun ha => Exists fun hb => r ⟨a, ha⟩ ⟨b, hb⟩) l)","decl":"theorem chain'_attach {l : List α} {r : {a // a ∈ l} → {a // a ∈ l} → Prop} :\n    l.attach.Chain' r ↔ l.Chain' fun a b ↦ ∃ ha hb, r ⟨a, ha⟩ ⟨b, hb⟩ :=\n  chain'_attachWith fun _ ↦ id\n\n"}
{"name":"List.exists_chain_of_relationReflTransGen","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nr : α → α → Prop\na b : α\nh : Relation.ReflTransGen r a b\n⊢ Exists fun l => And (List.Chain r a l) (Eq ((List.cons a l).getLast ⋯) b)","decl":"/-- If `a` and `b` are related by the reflexive transitive closure of `r`, then there is an\n`r`-chain starting from `a` and ending on `b`.\nThe converse of `relationReflTransGen_of_exists_chain`.\n-/\ntheorem exists_chain_of_relationReflTransGen (h : Relation.ReflTransGen r a b) :\n    ∃ l, Chain r a l ∧ getLast (a :: l) (cons_ne_nil _ _) = b := by\n  refine Relation.ReflTransGen.head_induction_on h ?_ ?_\n  · exact ⟨[], Chain.nil, rfl⟩\n  · intro c d e _ ih\n    obtain ⟨l, hl₁, hl₂⟩ := ih\n    refine ⟨d :: l, Chain.cons e hl₁, ?_⟩\n    rwa [getLast_cons_cons]\n\n"}
{"name":"List.Chain.induction","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nr : α → α → Prop\na : α\np : α → Prop\nl : List α\nh : List.Chain r a l\ncarries : ∀ ⦃x y : α⦄, r x y → p x → p y\ninitial : p a\ni : α\na✝ : Membership.mem l i\n⊢ p i","decl":"/-- Given a chain from `a` to `b`, and a predicate true at `a`, if `r x y → p x → p y` then\nthe predicate is true everywhere in the chain.\nThat is, we can propagate the predicate down the chain.\n-/\ntheorem Chain.induction (p : α → Prop) (l : List α) (h : Chain r a l)\n    (carries : ∀ ⦃x y : α⦄, r x y → p x → p y) (initial : p a) : ∀ i ∈ l, p i := by\n  induction h with\n  | nil => simp\n  | @cons a b t hab _ h_ind =>\n    simp only [mem_cons, forall_eq_or_imp]\n    exact ⟨carries hab initial, h_ind (carries hab initial)⟩\n\n"}
{"name":"List.Chain'.induction","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nr : α → α → Prop\np : α → Prop\nl : List α\nh : List.Chain' r l\ncarries : ∀ ⦃x y : α⦄, r x y → p x → p y\ninitial : ∀ (lne : Ne l List.nil), p (l.head lne)\ni : α\na✝ : Membership.mem l i\n⊢ p i","decl":"/-- A version of `List.Chain.induction` for `List.Chain'`\n-/\ntheorem Chain'.induction (p : α → Prop) (l : List α) (h : Chain' r l)\n    (carries : ∀ ⦃x y : α⦄, r x y → p x → p y) (initial : (lne : l ≠ []) → p (l.head lne)) :\n    ∀ i ∈ l, p i := by\n  unfold Chain' at h\n  split at h\n  · simp\n  · simp_all only [ne_eq, not_false_eq_true, head_cons, true_implies, mem_cons, forall_eq_or_imp,\n      true_and, reduceCtorEq]\n    exact h.induction p _ carries initial\n\n"}
{"name":"List.Chain.backwards_induction","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nr : α → α → Prop\na b : α\np : α → Prop\nl : List α\nh : List.Chain r a l\nhb : Eq ((List.cons a l).getLast ⋯) b\ncarries : ∀ ⦃x y : α⦄, r x y → p y → p x\nfinal : p b\ni : α\na✝ : Membership.mem (List.cons a l) i\n⊢ p i","decl":"/-- Given a chain from `a` to `b`, and a predicate true at `b`, if `r x y → p y → p x` then\nthe predicate is true everywhere in the chain and at `a`.\nThat is, we can propagate the predicate up the chain.\n-/\ntheorem Chain.backwards_induction (p : α → Prop) (l : List α) (h : Chain r a l)\n    (hb : getLast (a :: l) (cons_ne_nil _ _) = b) (carries : ∀ ⦃x y : α⦄, r x y → p y → p x)\n    (final : p b) : ∀ i ∈ a :: l, p i := by\n  have : Chain' (flip (flip r)) (a :: l) := by simpa [Chain']\n  replace this := chain'_reverse.mpr this\n  simp_rw (config := {singlePass := true}) [← List.mem_reverse]\n  apply this.induction _ _ (fun _ _ h ↦ carries h)\n  simpa only [ne_eq, reverse_eq_nil_iff, not_false_eq_true, head_reverse, forall_true_left, hb,\n    reduceCtorEq]\n\n"}
{"name":"List.Chain.backwards_induction_head","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nr : α → α → Prop\na b : α\np : α → Prop\nl : List α\nh : List.Chain r a l\nhb : Eq ((List.cons a l).getLast ⋯) b\ncarries : ∀ ⦃x y : α⦄, r x y → p y → p x\nfinal : p b\n⊢ p a","decl":"/-- Given a chain from `a` to `b`, and a predicate true at `b`, if `r x y → p y → p x` then\nthe predicate is true at `a`.\nThat is, we can propagate the predicate all the way up the chain.\n-/\n@[elab_as_elim]\ntheorem Chain.backwards_induction_head (p : α → Prop) (l : List α) (h : Chain r a l)\n    (hb : getLast (a :: l) (cons_ne_nil _ _) = b) (carries : ∀ ⦃x y : α⦄, r x y → p y → p x)\n    (final : p b) : p a :=\n  (Chain.backwards_induction p l h hb carries final) _ (mem_cons_self _ _)\n\n"}
{"name":"List.relationReflTransGen_of_exists_chain","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nr : α → α → Prop\na b : α\nl : List α\nhl₁ : List.Chain r a l\nhl₂ : Eq ((List.cons a l).getLast ⋯) b\n⊢ Relation.ReflTransGen r a b","decl":"/--\nIf there is an `r`-chain starting from `a` and ending at `b`, then `a` and `b` are related by the\nreflexive transitive closure of `r`. The converse of `exists_chain_of_relationReflTransGen`.\n-/\ntheorem relationReflTransGen_of_exists_chain (l : List α) (hl₁ : Chain r a l)\n    (hl₂ : getLast (a :: l) (cons_ne_nil _ _) = b) : Relation.ReflTransGen r a b :=\n  Chain.backwards_induction_head _ l hl₁ hl₂ (fun _ _ => Relation.ReflTransGen.head)\n    Relation.ReflTransGen.refl\n\n"}
{"name":"List.Chain'.cons_of_le","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\ninst✝ : LinearOrder α\na : α\nas m : List α\nha : List.Chain' (fun x1 x2 => GT.gt x1 x2) (List.cons a as)\nhm : List.Chain' (fun x1 x2 => GT.gt x1 x2) m\nhmas : LE.le m as\n⊢ List.Chain' (fun x1 x2 => GT.gt x1 x2) (List.cons a m)","decl":"theorem Chain'.cons_of_le [LinearOrder α] {a : α} {as m : List α}\n    (ha : List.Chain' (· > ·) (a :: as)) (hm : List.Chain' (· > ·) m) (hmas : m ≤ as) :\n    List.Chain' (· > ·) (a :: m) := by\n  cases m with\n  | nil => simp only [List.chain'_singleton]\n  | cons b bs =>\n    apply hm.cons\n    cases as with\n    | nil =>\n      simp only [le_iff_lt_or_eq, reduceCtorEq, or_false] at hmas\n      exact (List.not_lt_nil _ hmas).elim\n    | cons a' as =>\n      rw [List.chain'_cons] at ha\n      refine gt_of_gt_of_ge ha.1 ?_\n      rw [le_iff_lt_or_eq] at hmas\n      cases' hmas with hmas hmas\n      · by_contra! hh\n        rw [← not_le] at hmas\n        apply hmas\n        apply le_of_lt\n        exact (List.lt_iff_lex_lt _ _).mp (List.Lex.rel hh)\n      · simp_all only [List.cons.injEq, le_refl]\n\n"}
{"name":"List.Chain'.chain","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u_1\nR : α → α → Prop\nl : List α\nv : α\nhl : List.Chain' R l\nhv : ∀ (lne : Ne l List.nil), R v (l.head lne)\n⊢ List.Chain R v l","decl":"lemma Chain'.chain {α : Type*} {R : α → α → Prop} {l : List α} {v : α}\n    (hl : l.Chain' R) (hv : (lne : l ≠ []) → R v (l.head lne)) : l.Chain R v := by\n  rw [List.chain_iff_get]\n  constructor\n  · intro h\n    rw [List.get_mk_zero]\n    apply hv\n  · exact List.chain'_iff_get.mp hl\n\n"}
{"name":"List.Chain'.iterate_eq_of_apply_eq","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u_1\nf : α → α\nl : List α\nhl : List.Chain' (fun x y => Eq (f x) y) l\ni : Nat\nhi : LT.lt i l.length\n⊢ Eq (Nat.iterate f i (GetElem.getElem l 0 ⋯)) (GetElem.getElem l i ⋯)","decl":"lemma Chain'.iterate_eq_of_apply_eq {α : Type*} {f : α → α} {l : List α}\n    (hl : l.Chain' (fun x y ↦ f x = y)) (i : ℕ) (hi : i < l.length) :\n    f^[i] l[0] = l[i] := by\n  induction' i with i h\n  · rfl\n  · rw [Function.iterate_succ', Function.comp_apply, h (by omega)]\n    rw [List.chain'_iff_get] at hl\n    apply hl\n    omega\n\n"}
{"name":"List.chain'_replicate_of_rel","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nr : α → α → Prop\nn : Nat\na : α\nh : r a a\n⊢ List.Chain' r (List.replicate n a)","decl":"theorem chain'_replicate_of_rel (n : ℕ) {a : α} (h : r a a) : Chain' r (replicate n a) :=\n  match n with\n  | 0 => chain'_nil\n  | n + 1 => chain_replicate_of_rel n h\n\n"}
{"name":"List.chain'_eq_iff_eq_replicate","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u\nl : List α\n⊢ Iff (List.Chain' (fun x1 x2 => Eq x1 x2) l) (∀ (a : α), Membership.mem l.head? a → Eq l (List.replicate l.length a))","decl":"theorem chain'_eq_iff_eq_replicate {l : List α} :\n    Chain' (· = ·) l ↔ ∀ a ∈ l.head?, l = replicate l.length a :=\n  match l with\n  | [] => by simp\n  | a :: l => by simp [Chain', chain_eq_iff_eq_replicate, replicate_succ]\n\n"}
{"name":"Acc.list_chain'","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\nl : List.chains r\nacc : ∀ (a : α), Membership.mem (↑l).head? a → Acc r a\n⊢ Acc (List.lex_chains r) l","decl":"/-- If an `r`-decreasing chain `l` is empty or its head is accessible by `r`, then\n  `l` is accessible by the lexicographic order `List.Lex r`. -/\ntheorem Acc.list_chain' {l : List.chains r} (acc : ∀ a ∈ l.val.head?, Acc r a) :\n    Acc (List.lex_chains r) l := by\n  obtain ⟨_ | ⟨a, l⟩, hl⟩ := l\n  · apply Acc.intro; rintro ⟨_⟩ ⟨_⟩\n  specialize acc a _\n  · rw [List.head?_cons, Option.mem_some_iff]\n  /- For an r-decreasing chain of the form a :: l, apply induction on a -/\n  induction acc generalizing l with\n  | intro a _ ih =>\n    /- Bundle l with a proof that it is r-decreasing to form l' -/\n    have hl' := (List.chain'_cons'.1 hl).2\n    let l' : List.chains r := ⟨l, hl'⟩\n    have : Acc (List.lex_chains r) l' := by\n      cases' l with b l\n      · apply Acc.intro; rintro ⟨_⟩ ⟨_⟩\n      /- l' is accessible by induction hypothesis -/\n      · apply ih b (List.chain'_cons.1 hl).1\n    /- make l' a free variable and induct on l' -/\n    revert hl\n    rw [(by rfl : l = l'.1)]\n    clear_value l'\n    induction this with\n    | intro l _ ihl =>\n      intro hl\n      apply Acc.intro\n      rintro ⟨_ | ⟨b, m⟩, hm⟩ (_ | hr | hr)\n      · apply Acc.intro; rintro ⟨_⟩ ⟨_⟩\n      · apply ihl ⟨m, (List.chain'_cons'.1 hm).2⟩ hr\n      · apply ih b hr\n\n"}
{"name":"WellFounded.list_chain'","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\nhwf : WellFounded r\n⊢ WellFounded (List.lex_chains r)","decl":"/-- If `r` is well-founded, the lexicographic order on `r`-decreasing chains is also. -/\ntheorem WellFounded.list_chain' (hwf : WellFounded r) :\n    WellFounded (List.lex_chains r) :=\n  ⟨fun _ ↦ Acc.list_chain' (fun _ _ => hwf.apply _)⟩\n\n"}
{"name":"instIsWellFoundedChainsLex_chains","module":"Mathlib.Data.List.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\nhwf : IsWellFounded α r\n⊢ IsWellFounded (List.chains r) (List.lex_chains r)","decl":"instance [hwf : IsWellFounded α r] :\n    IsWellFounded (List.chains r) (List.lex_chains r) :=\n  ⟨hwf.wf.list_chain'⟩\n"}
