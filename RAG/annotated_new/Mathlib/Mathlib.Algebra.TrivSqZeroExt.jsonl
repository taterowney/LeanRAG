{"name":"TrivSqZeroExt.fst_mk","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\nr : R\nm : M\n⊢ Eq (TrivSqZeroExt.fst { fst := r, snd := m }) r","decl":"@[simp]\ntheorem fst_mk (r : R) (m : M) : fst (r, m) = r :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.snd_mk","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\nr : R\nm : M\n⊢ Eq (TrivSqZeroExt.snd { fst := r, snd := m }) m","decl":"@[simp]\ntheorem snd_mk (r : R) (m : M) : snd (r, m) = m :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.ext_iff","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\nx y : TrivSqZeroExt R M\n⊢ Iff (Eq x y) (And (Eq x.fst y.fst) (Eq x.snd y.snd))","decl":"@[ext]\ntheorem ext {x y : tsze R M} (h1 : x.fst = y.fst) (h2 : x.snd = y.snd) : x = y :=\n  Prod.ext h1 h2\n\n"}
{"name":"TrivSqZeroExt.ext","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\nx y : TrivSqZeroExt R M\nh1 : Eq x.fst y.fst\nh2 : Eq x.snd y.snd\n⊢ Eq x y","decl":"@[ext]\ntheorem ext {x y : tsze R M} (h1 : x.fst = y.fst) (h2 : x.snd = y.snd) : x = y :=\n  Prod.ext h1 h2\n\n"}
{"name":"TrivSqZeroExt.fst_inl","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝ : Zero M\nr : R\n⊢ Eq (TrivSqZeroExt.inl r).fst r","decl":"@[simp]\ntheorem fst_inl [Zero M] (r : R) : (inl r : tsze R M).fst = r :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.snd_inl","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝ : Zero M\nr : R\n⊢ Eq (TrivSqZeroExt.inl r).snd 0","decl":"@[simp]\ntheorem snd_inl [Zero M] (r : R) : (inl r : tsze R M).snd = 0 :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.fst_comp_inl","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝ : Zero M\n⊢ Eq (Function.comp TrivSqZeroExt.fst TrivSqZeroExt.inl) id","decl":"@[simp]\ntheorem fst_comp_inl [Zero M] : fst ∘ (inl : R → tsze R M) = id :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.snd_comp_inl","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝ : Zero M\n⊢ Eq (Function.comp TrivSqZeroExt.snd TrivSqZeroExt.inl) 0","decl":"@[simp]\ntheorem snd_comp_inl [Zero M] : snd ∘ (inl : R → tsze R M) = 0 :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.fst_inr","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝ : Zero R\nm : M\n⊢ Eq (TrivSqZeroExt.inr m).fst 0","decl":"@[simp]\ntheorem fst_inr [Zero R] (m : M) : (inr m : tsze R M).fst = 0 :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.snd_inr","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝ : Zero R\nm : M\n⊢ Eq (TrivSqZeroExt.inr m).snd m","decl":"@[simp]\ntheorem snd_inr [Zero R] (m : M) : (inr m : tsze R M).snd = m :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.fst_comp_inr","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝ : Zero R\n⊢ Eq (Function.comp TrivSqZeroExt.fst TrivSqZeroExt.inr) 0","decl":"@[simp]\ntheorem fst_comp_inr [Zero R] : fst ∘ (inr : M → tsze R M) = 0 :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.snd_comp_inr","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝ : Zero R\n⊢ Eq (Function.comp TrivSqZeroExt.snd TrivSqZeroExt.inr) id","decl":"@[simp]\ntheorem snd_comp_inr [Zero R] : snd ∘ (inr : M → tsze R M) = id :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.fst_surjective","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝ : Nonempty M\n⊢ Function.Surjective TrivSqZeroExt.fst","decl":"theorem fst_surjective [Nonempty M] : Function.Surjective (fst : tsze R M → R) :=\n  Prod.fst_surjective\n\n"}
{"name":"TrivSqZeroExt.snd_surjective","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝ : Nonempty R\n⊢ Function.Surjective TrivSqZeroExt.snd","decl":"theorem snd_surjective [Nonempty R] : Function.Surjective (snd : tsze R M → M) :=\n  Prod.snd_surjective\n\n"}
{"name":"TrivSqZeroExt.inl_injective","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝ : Zero M\n⊢ Function.Injective TrivSqZeroExt.inl","decl":"theorem inl_injective [Zero M] : Function.Injective (inl : R → tsze R M) :=\n  Function.LeftInverse.injective <| fst_inl _\n\n"}
{"name":"TrivSqZeroExt.inr_injective","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝ : Zero R\n⊢ Function.Injective TrivSqZeroExt.inr","decl":"theorem inr_injective [Zero R] : Function.Injective (inr : M → tsze R M) :=\n  Function.LeftInverse.injective <| snd_inr _\n\n"}
{"name":"TrivSqZeroExt.isScalarTower","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"T : Type u_1\nS : Type u_2\nR : Type u\nM : Type v\ninst✝⁶ : SMul T R\ninst✝⁵ : SMul T M\ninst✝⁴ : SMul S R\ninst✝³ : SMul S M\ninst✝² : SMul T S\ninst✝¹ : IsScalarTower T S R\ninst✝ : IsScalarTower T S M\n⊢ IsScalarTower T S (TrivSqZeroExt R M)","decl":"instance isScalarTower [SMul T R] [SMul T M] [SMul S R] [SMul S M] [SMul T S]\n    [IsScalarTower T S R] [IsScalarTower T S M] : IsScalarTower T S (tsze R M) :=\n  Prod.isScalarTower\n\n"}
{"name":"TrivSqZeroExt.smulCommClass","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"T : Type u_1\nS : Type u_2\nR : Type u\nM : Type v\ninst✝⁵ : SMul T R\ninst✝⁴ : SMul T M\ninst✝³ : SMul S R\ninst✝² : SMul S M\ninst✝¹ : SMulCommClass T S R\ninst✝ : SMulCommClass T S M\n⊢ SMulCommClass T S (TrivSqZeroExt R M)","decl":"instance smulCommClass [SMul T R] [SMul T M] [SMul S R] [SMul S M]\n    [SMulCommClass T S R] [SMulCommClass T S M] : SMulCommClass T S (tsze R M) :=\n  Prod.smulCommClass\n\n"}
{"name":"TrivSqZeroExt.isCentralScalar","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"S : Type u_2\nR : Type u\nM : Type v\ninst✝⁵ : SMul S R\ninst✝⁴ : SMul S M\ninst✝³ : SMul (MulOpposite S) R\ninst✝² : SMul (MulOpposite S) M\ninst✝¹ : IsCentralScalar S R\ninst✝ : IsCentralScalar S M\n⊢ IsCentralScalar S (TrivSqZeroExt R M)","decl":"instance isCentralScalar [SMul S R] [SMul S M] [SMul Sᵐᵒᵖ R] [SMul Sᵐᵒᵖ M] [IsCentralScalar S R]\n    [IsCentralScalar S M] : IsCentralScalar S (tsze R M) :=\n  Prod.isCentralScalar\n\n"}
{"name":"TrivSqZeroExt.instNontrivial_of_left","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝¹ : Nontrivial R\ninst✝ : Nonempty M\n⊢ Nontrivial (TrivSqZeroExt R M)","decl":"/-- The trivial square-zero extension is nontrivial if it is over a nontrivial ring. -/\ninstance instNontrivial_of_left {R M : Type*} [Nontrivial R] [Nonempty M] :\n    Nontrivial (TrivSqZeroExt R M) :=\n  fst_surjective.nontrivial\n\n"}
{"name":"TrivSqZeroExt.instNontrivial_of_right","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝¹ : Nonempty R\ninst✝ : Nontrivial M\n⊢ Nontrivial (TrivSqZeroExt R M)","decl":"/-- The trivial square-zero extension is nontrivial if it is over a nontrivial module. -/\ninstance instNontrivial_of_right {R M : Type*} [Nonempty R] [Nontrivial M] :\n    Nontrivial (TrivSqZeroExt R M) :=\n  snd_surjective.nontrivial\n\n"}
{"name":"TrivSqZeroExt.fst_zero","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Zero R\ninst✝ : Zero M\n⊢ Eq (TrivSqZeroExt.fst 0) 0","decl":"@[simp]\ntheorem fst_zero [Zero R] [Zero M] : (0 : tsze R M).fst = 0 :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.snd_zero","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Zero R\ninst✝ : Zero M\n⊢ Eq (TrivSqZeroExt.snd 0) 0","decl":"@[simp]\ntheorem snd_zero [Zero R] [Zero M] : (0 : tsze R M).snd = 0 :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.fst_add","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Add R\ninst✝ : Add M\nx₁ x₂ : TrivSqZeroExt R M\n⊢ Eq (HAdd.hAdd x₁ x₂).fst (HAdd.hAdd x₁.fst x₂.fst)","decl":"@[simp]\ntheorem fst_add [Add R] [Add M] (x₁ x₂ : tsze R M) : (x₁ + x₂).fst = x₁.fst + x₂.fst :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.snd_add","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Add R\ninst✝ : Add M\nx₁ x₂ : TrivSqZeroExt R M\n⊢ Eq (HAdd.hAdd x₁ x₂).snd (HAdd.hAdd x₁.snd x₂.snd)","decl":"@[simp]\ntheorem snd_add [Add R] [Add M] (x₁ x₂ : tsze R M) : (x₁ + x₂).snd = x₁.snd + x₂.snd :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.fst_neg","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Neg R\ninst✝ : Neg M\nx : TrivSqZeroExt R M\n⊢ Eq (Neg.neg x).fst (Neg.neg x.fst)","decl":"@[simp]\ntheorem fst_neg [Neg R] [Neg M] (x : tsze R M) : (-x).fst = -x.fst :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.snd_neg","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Neg R\ninst✝ : Neg M\nx : TrivSqZeroExt R M\n⊢ Eq (Neg.neg x).snd (Neg.neg x.snd)","decl":"@[simp]\ntheorem snd_neg [Neg R] [Neg M] (x : tsze R M) : (-x).snd = -x.snd :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.fst_sub","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Sub R\ninst✝ : Sub M\nx₁ x₂ : TrivSqZeroExt R M\n⊢ Eq (HSub.hSub x₁ x₂).fst (HSub.hSub x₁.fst x₂.fst)","decl":"@[simp]\ntheorem fst_sub [Sub R] [Sub M] (x₁ x₂ : tsze R M) : (x₁ - x₂).fst = x₁.fst - x₂.fst :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.snd_sub","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Sub R\ninst✝ : Sub M\nx₁ x₂ : TrivSqZeroExt R M\n⊢ Eq (HSub.hSub x₁ x₂).snd (HSub.hSub x₁.snd x₂.snd)","decl":"@[simp]\ntheorem snd_sub [Sub R] [Sub M] (x₁ x₂ : tsze R M) : (x₁ - x₂).snd = x₁.snd - x₂.snd :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.fst_smul","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"S : Type u_2\nR : Type u\nM : Type v\ninst✝¹ : SMul S R\ninst✝ : SMul S M\ns : S\nx : TrivSqZeroExt R M\n⊢ Eq (HSMul.hSMul s x).fst (HSMul.hSMul s x.fst)","decl":"@[simp]\ntheorem fst_smul [SMul S R] [SMul S M] (s : S) (x : tsze R M) : (s • x).fst = s • x.fst :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.snd_smul","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"S : Type u_2\nR : Type u\nM : Type v\ninst✝¹ : SMul S R\ninst✝ : SMul S M\ns : S\nx : TrivSqZeroExt R M\n⊢ Eq (HSMul.hSMul s x).snd (HSMul.hSMul s x.snd)","decl":"@[simp]\ntheorem snd_smul [SMul S R] [SMul S M] (s : S) (x : tsze R M) : (s • x).snd = s • x.snd :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.fst_sum","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\nι : Type u_3\ninst✝¹ : AddCommMonoid R\ninst✝ : AddCommMonoid M\ns : Finset ι\nf : ι → TrivSqZeroExt R M\n⊢ Eq (s.sum fun i => f i).fst (s.sum fun i => (f i).fst)","decl":"theorem fst_sum {ι} [AddCommMonoid R] [AddCommMonoid M] (s : Finset ι) (f : ι → tsze R M) :\n    (∑ i ∈ s, f i).fst = ∑ i ∈ s, (f i).fst :=\n  Prod.fst_sum\n\n"}
{"name":"TrivSqZeroExt.snd_sum","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\nι : Type u_3\ninst✝¹ : AddCommMonoid R\ninst✝ : AddCommMonoid M\ns : Finset ι\nf : ι → TrivSqZeroExt R M\n⊢ Eq (s.sum fun i => f i).snd (s.sum fun i => (f i).snd)","decl":"theorem snd_sum {ι} [AddCommMonoid R] [AddCommMonoid M] (s : Finset ι) (f : ι → tsze R M) :\n    (∑ i ∈ s, f i).snd = ∑ i ∈ s, (f i).snd :=\n  Prod.snd_sum\n\n"}
{"name":"TrivSqZeroExt.inl_zero","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Zero R\ninst✝ : Zero M\n⊢ Eq (TrivSqZeroExt.inl 0) 0","decl":"@[simp]\ntheorem inl_zero [Zero R] [Zero M] : (inl 0 : tsze R M) = 0 :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.inl_add","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Add R\ninst✝ : AddZeroClass M\nr₁ r₂ : R\n⊢ Eq (TrivSqZeroExt.inl (HAdd.hAdd r₁ r₂)) (HAdd.hAdd (TrivSqZeroExt.inl r₁) (TrivSqZeroExt.inl r₂))","decl":"@[simp]\ntheorem inl_add [Add R] [AddZeroClass M] (r₁ r₂ : R) :\n    (inl (r₁ + r₂) : tsze R M) = inl r₁ + inl r₂ :=\n  ext rfl (add_zero 0).symm\n\n"}
{"name":"TrivSqZeroExt.inl_neg","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Neg R\ninst✝ : SubNegZeroMonoid M\nr : R\n⊢ Eq (TrivSqZeroExt.inl (Neg.neg r)) (Neg.neg (TrivSqZeroExt.inl r))","decl":"@[simp]\ntheorem inl_neg [Neg R] [SubNegZeroMonoid M] (r : R) : (inl (-r) : tsze R M) = -inl r :=\n  ext rfl neg_zero.symm\n\n"}
{"name":"TrivSqZeroExt.inl_sub","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Sub R\ninst✝ : SubNegZeroMonoid M\nr₁ r₂ : R\n⊢ Eq (TrivSqZeroExt.inl (HSub.hSub r₁ r₂)) (HSub.hSub (TrivSqZeroExt.inl r₁) (TrivSqZeroExt.inl r₂))","decl":"@[simp]\ntheorem inl_sub [Sub R] [SubNegZeroMonoid M] (r₁ r₂ : R) :\n    (inl (r₁ - r₂) : tsze R M) = inl r₁ - inl r₂ :=\n  ext rfl (sub_zero _).symm\n\n"}
{"name":"TrivSqZeroExt.inl_smul","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"S : Type u_2\nR : Type u\nM : Type v\ninst✝³ : Monoid S\ninst✝² : AddMonoid M\ninst✝¹ : SMul S R\ninst✝ : DistribMulAction S M\ns : S\nr : R\n⊢ Eq (TrivSqZeroExt.inl (HSMul.hSMul s r)) (HSMul.hSMul s (TrivSqZeroExt.inl r))","decl":"@[simp]\ntheorem inl_smul [Monoid S] [AddMonoid M] [SMul S R] [DistribMulAction S M] (s : S) (r : R) :\n    (inl (s • r) : tsze R M) = s • inl r :=\n  ext rfl (smul_zero s).symm\n\n"}
{"name":"TrivSqZeroExt.inl_sum","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\nι : Type u_3\ninst✝¹ : AddCommMonoid R\ninst✝ : AddCommMonoid M\ns : Finset ι\nf : ι → R\n⊢ Eq (TrivSqZeroExt.inl (s.sum fun i => f i)) (s.sum fun i => TrivSqZeroExt.inl (f i))","decl":"theorem inl_sum {ι} [AddCommMonoid R] [AddCommMonoid M] (s : Finset ι) (f : ι → R) :\n    (inl (∑ i ∈ s, f i) : tsze R M) = ∑ i ∈ s, inl (f i) :=\n  map_sum (LinearMap.inl ℕ _ _) _ _\n\n"}
{"name":"TrivSqZeroExt.inr_zero","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Zero R\ninst✝ : Zero M\n⊢ Eq (TrivSqZeroExt.inr 0) 0","decl":"@[simp]\ntheorem inr_zero [Zero R] [Zero M] : (inr 0 : tsze R M) = 0 :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.inr_add","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : AddZeroClass R\ninst✝ : AddZeroClass M\nm₁ m₂ : M\n⊢ Eq (TrivSqZeroExt.inr (HAdd.hAdd m₁ m₂)) (HAdd.hAdd (TrivSqZeroExt.inr m₁) (TrivSqZeroExt.inr m₂))","decl":"@[simp]\ntheorem inr_add [AddZeroClass R] [AddZeroClass M] (m₁ m₂ : M) :\n    (inr (m₁ + m₂) : tsze R M) = inr m₁ + inr m₂ :=\n  ext (add_zero 0).symm rfl\n\n"}
{"name":"TrivSqZeroExt.inr_neg","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : SubNegZeroMonoid R\ninst✝ : Neg M\nm : M\n⊢ Eq (TrivSqZeroExt.inr (Neg.neg m)) (Neg.neg (TrivSqZeroExt.inr m))","decl":"@[simp]\ntheorem inr_neg [SubNegZeroMonoid R] [Neg M] (m : M) : (inr (-m) : tsze R M) = -inr m :=\n  ext neg_zero.symm rfl\n\n"}
{"name":"TrivSqZeroExt.inr_sub","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : SubNegZeroMonoid R\ninst✝ : Sub M\nm₁ m₂ : M\n⊢ Eq (TrivSqZeroExt.inr (HSub.hSub m₁ m₂)) (HSub.hSub (TrivSqZeroExt.inr m₁) (TrivSqZeroExt.inr m₂))","decl":"@[simp]\ntheorem inr_sub [SubNegZeroMonoid R] [Sub M] (m₁ m₂ : M) :\n    (inr (m₁ - m₂) : tsze R M) = inr m₁ - inr m₂ :=\n  ext (sub_zero _).symm rfl\n\n"}
{"name":"TrivSqZeroExt.inr_smul","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"S : Type u_2\nR : Type u\nM : Type v\ninst✝³ : Zero R\ninst✝² : Zero S\ninst✝¹ : SMulWithZero S R\ninst✝ : SMul S M\nr : S\nm : M\n⊢ Eq (TrivSqZeroExt.inr (HSMul.hSMul r m)) (HSMul.hSMul r (TrivSqZeroExt.inr m))","decl":"@[simp]\ntheorem inr_smul [Zero R] [Zero S] [SMulWithZero S R] [SMul S M] (r : S) (m : M) :\n    (inr (r • m) : tsze R M) = r • inr m :=\n  ext (smul_zero _).symm rfl\n\n"}
{"name":"TrivSqZeroExt.inr_sum","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\nι : Type u_3\ninst✝¹ : AddCommMonoid R\ninst✝ : AddCommMonoid M\ns : Finset ι\nf : ι → M\n⊢ Eq (TrivSqZeroExt.inr (s.sum fun i => f i)) (s.sum fun i => TrivSqZeroExt.inr (f i))","decl":"theorem inr_sum {ι} [AddCommMonoid R] [AddCommMonoid M] (s : Finset ι) (f : ι → M) :\n    (inr (∑ i ∈ s, f i) : tsze R M) = ∑ i ∈ s, inr (f i) :=\n  map_sum (LinearMap.inr ℕ _ _) _ _\n\n"}
{"name":"TrivSqZeroExt.inl_fst_add_inr_snd_eq","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : AddZeroClass R\ninst✝ : AddZeroClass M\nx : TrivSqZeroExt R M\n⊢ Eq (HAdd.hAdd (TrivSqZeroExt.inl x.fst) (TrivSqZeroExt.inr x.snd)) x","decl":"theorem inl_fst_add_inr_snd_eq [AddZeroClass R] [AddZeroClass M] (x : tsze R M) :\n    inl x.fst + inr x.snd = x :=\n  ext (add_zero x.1) (zero_add x.2)\n\n"}
{"name":"TrivSqZeroExt.ind","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝¹ : AddZeroClass R\ninst✝ : AddZeroClass M\nP : TrivSqZeroExt R M → Prop\ninl_add_inr : ∀ (r : R) (m : M), P (HAdd.hAdd (TrivSqZeroExt.inl r) (TrivSqZeroExt.inr m))\nx : TrivSqZeroExt R M\n⊢ P x","decl":"/-- To show a property hold on all `TrivSqZeroExt R M` it suffices to show it holds\non terms of the form `inl r + inr m`. -/\n@[elab_as_elim, induction_eliminator, cases_eliminator]\ntheorem ind {R M} [AddZeroClass R] [AddZeroClass M] {P : TrivSqZeroExt R M → Prop}\n    (inl_add_inr : ∀ r m, P (inl r + inr m)) (x) : P x :=\n  inl_fst_add_inr_snd_eq x ▸ inl_add_inr x.1 x.2\n\n"}
{"name":"TrivSqZeroExt.linearMap_ext","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"S : Type u_2\nR : Type u\nM : Type v\nN : Type u_3\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid N\ninst✝² : Module S R\ninst✝¹ : Module S M\ninst✝ : Module S N\nf g : LinearMap (RingHom.id S) (TrivSqZeroExt R M) N\nhl : ∀ (r : R), Eq (f (TrivSqZeroExt.inl r)) (g (TrivSqZeroExt.inl r))\nhr : ∀ (m : M), Eq (f (TrivSqZeroExt.inr m)) (g (TrivSqZeroExt.inr m))\n⊢ Eq f g","decl":"/-- This cannot be marked `@[ext]` as it ends up being used instead of `LinearMap.prod_ext` when\nworking with `R × M`. -/\ntheorem linearMap_ext {N} [Semiring S] [AddCommMonoid R] [AddCommMonoid M] [AddCommMonoid N]\n    [Module S R] [Module S M] [Module S N] ⦃f g : tsze R M →ₗ[S] N⦄\n    (hl : ∀ r, f (inl r) = g (inl r)) (hr : ∀ m, f (inr m) = g (inr m)) : f = g :=\n  LinearMap.prod_ext (LinearMap.ext hl) (LinearMap.ext hr)\n\n"}
{"name":"TrivSqZeroExt.inrHom_apply","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nm : M\n⊢ Eq ((TrivSqZeroExt.inrHom R M) m) (TrivSqZeroExt.inr m)","decl":"/-- The canonical `R`-linear inclusion `M → TrivSqZeroExt R M`. -/\n@[simps apply]\ndef inrHom [Semiring R] [AddCommMonoid M] [Module R M] : M →ₗ[R] tsze R M :=\n  { LinearMap.inr R R M with toFun := inr }\n\n"}
{"name":"TrivSqZeroExt.sndHom_apply","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : TrivSqZeroExt R M\n⊢ Eq ((TrivSqZeroExt.sndHom R M) x) x.snd","decl":"/-- The canonical `R`-linear projection `TrivSqZeroExt R M → M`. -/\n@[simps apply]\ndef sndHom [Semiring R] [AddCommMonoid M] [Module R M] : tsze R M →ₗ[R] M :=\n  { LinearMap.snd _ _ _ with toFun := snd }\n\n"}
{"name":"TrivSqZeroExt.fst_one","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : One R\ninst✝ : Zero M\n⊢ Eq (TrivSqZeroExt.fst 1) 1","decl":"@[simp]\ntheorem fst_one [One R] [Zero M] : (1 : tsze R M).fst = 1 :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.snd_one","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : One R\ninst✝ : Zero M\n⊢ Eq (TrivSqZeroExt.snd 1) 0","decl":"@[simp]\ntheorem snd_one [One R] [Zero M] : (1 : tsze R M).snd = 0 :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.fst_mul","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Mul R\ninst✝² : Add M\ninst✝¹ : SMul R M\ninst✝ : SMul (MulOpposite R) M\nx₁ x₂ : TrivSqZeroExt R M\n⊢ Eq (HMul.hMul x₁ x₂).fst (HMul.hMul x₁.fst x₂.fst)","decl":"@[simp]\ntheorem fst_mul [Mul R] [Add M] [SMul R M] [SMul Rᵐᵒᵖ M] (x₁ x₂ : tsze R M) :\n    (x₁ * x₂).fst = x₁.fst * x₂.fst :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.snd_mul","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Mul R\ninst✝² : Add M\ninst✝¹ : SMul R M\ninst✝ : SMul (MulOpposite R) M\nx₁ x₂ : TrivSqZeroExt R M\n⊢ Eq (HMul.hMul x₁ x₂).snd (HAdd.hAdd (HSMul.hSMul x₁.fst x₂.snd) (HSMul.hSMul (MulOpposite.op x₂.fst) x₁.snd))","decl":"@[simp]\ntheorem snd_mul [Mul R] [Add M] [SMul R M] [SMul Rᵐᵒᵖ M] (x₁ x₂ : tsze R M) :\n    (x₁ * x₂).snd = x₁.fst •> x₂.snd + x₁.snd <• x₂.fst :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.inl_one","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : One R\ninst✝ : Zero M\n⊢ Eq (TrivSqZeroExt.inl 1) 1","decl":"@[simp]\ntheorem inl_one [One R] [Zero M] : (inl 1 : tsze R M) = 1 :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.inl_mul","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Monoid R\ninst✝² : AddMonoid M\ninst✝¹ : DistribMulAction R M\ninst✝ : DistribMulAction (MulOpposite R) M\nr₁ r₂ : R\n⊢ Eq (TrivSqZeroExt.inl (HMul.hMul r₁ r₂)) (HMul.hMul (TrivSqZeroExt.inl r₁) (TrivSqZeroExt.inl r₂))","decl":"@[simp]\ntheorem inl_mul [Monoid R] [AddMonoid M] [DistribMulAction R M] [DistribMulAction Rᵐᵒᵖ M]\n    (r₁ r₂ : R) : (inl (r₁ * r₂) : tsze R M) = inl r₁ * inl r₂ :=\n  ext rfl <| show (0 : M) = r₁ •> (0 : M) + (0 : M) <• r₂ by rw [smul_zero, zero_add, smul_zero]\n\n"}
{"name":"TrivSqZeroExt.inl_mul_inl","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Monoid R\ninst✝² : AddMonoid M\ninst✝¹ : DistribMulAction R M\ninst✝ : DistribMulAction (MulOpposite R) M\nr₁ r₂ : R\n⊢ Eq (HMul.hMul (TrivSqZeroExt.inl r₁) (TrivSqZeroExt.inl r₂)) (TrivSqZeroExt.inl (HMul.hMul r₁ r₂))","decl":"theorem inl_mul_inl [Monoid R] [AddMonoid M] [DistribMulAction R M] [DistribMulAction Rᵐᵒᵖ M]\n    (r₁ r₂ : R) : (inl r₁ * inl r₂ : tsze R M) = inl (r₁ * r₂) :=\n  (inl_mul M r₁ r₂).symm\n\n"}
{"name":"TrivSqZeroExt.inr_mul_inr","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module (MulOpposite R) M\nm₁ m₂ : M\n⊢ Eq (HMul.hMul (TrivSqZeroExt.inr m₁) (TrivSqZeroExt.inr m₂)) 0","decl":"@[simp]\ntheorem inr_mul_inr [Semiring R] [AddCommMonoid M] [Module R M] [Module Rᵐᵒᵖ M] (m₁ m₂ : M) :\n    (inr m₁ * inr m₂ : tsze R M) = 0 :=\n  ext (mul_zero _) <|\n    show (0 : R) •> m₂ + m₁ <• (0 : R) = 0 by rw [zero_smul, zero_add, op_zero, zero_smul]\n\n"}
{"name":"TrivSqZeroExt.inl_mul_inr","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module (MulOpposite R) M\nr : R\nm : M\n⊢ Eq (HMul.hMul (TrivSqZeroExt.inl r) (TrivSqZeroExt.inr m)) (TrivSqZeroExt.inr (HSMul.hSMul r m))","decl":"theorem inl_mul_inr [Semiring R] [AddCommMonoid M] [Module R M] [Module Rᵐᵒᵖ M] (r : R) (m : M) :\n    (inl r * inr m : tsze R M) = inr (r • m) :=\n  ext (mul_zero r) <|\n    show r • m + (0 : Rᵐᵒᵖ) • (0 : M) = r • m by rw [smul_zero, add_zero]\n\n"}
{"name":"TrivSqZeroExt.inr_mul_inl","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module (MulOpposite R) M\nr : R\nm : M\n⊢ Eq (HMul.hMul (TrivSqZeroExt.inr m) (TrivSqZeroExt.inl r)) (TrivSqZeroExt.inr (HSMul.hSMul (MulOpposite.op r) m))","decl":"theorem inr_mul_inl [Semiring R] [AddCommMonoid M] [Module R M] [Module Rᵐᵒᵖ M] (r : R) (m : M) :\n    (inr m * inl r : tsze R M) = inr (m <• r) :=\n  ext (zero_mul r) <|\n    show (0 : R) •> (0 : M) + m <• r = m <• r by rw [smul_zero, zero_add]\n\n"}
{"name":"TrivSqZeroExt.inl_mul_eq_smul","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module (MulOpposite R) M\nr : R\nx : TrivSqZeroExt R M\n⊢ Eq (HMul.hMul (TrivSqZeroExt.inl r) x) (HSMul.hSMul r x)","decl":"theorem inl_mul_eq_smul [Semiring R] [AddCommMonoid M] [Module R M] [Module Rᵐᵒᵖ M]\n    (r : R) (x : tsze R M) :\n    inl r * x = r •> x :=\n  ext rfl (by dsimp; rw [smul_zero, add_zero])\n\n"}
{"name":"TrivSqZeroExt.mul_inl_eq_op_smul","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module (MulOpposite R) M\nx : TrivSqZeroExt R M\nr : R\n⊢ Eq (HMul.hMul x (TrivSqZeroExt.inl r)) (HSMul.hSMul (MulOpposite.op r) x)","decl":"theorem mul_inl_eq_op_smul [Semiring R] [AddCommMonoid M] [Module R M] [Module Rᵐᵒᵖ M]\n    (x : tsze R M) (r : R) :\n    x * inl r = x <• r :=\n  ext rfl (by dsimp; rw [smul_zero, zero_add])\n\n"}
{"name":"TrivSqZeroExt.fst_natCast","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : AddMonoidWithOne R\ninst✝ : AddMonoid M\nn : Nat\n⊢ Eq (↑n).fst ↑n","decl":"@[simp]\ntheorem fst_natCast [AddMonoidWithOne R] [AddMonoid M] (n : ℕ) : (n : tsze R M).fst = n :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.snd_natCast","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : AddMonoidWithOne R\ninst✝ : AddMonoid M\nn : Nat\n⊢ Eq (↑n).snd 0","decl":"@[simp]\ntheorem snd_natCast [AddMonoidWithOne R] [AddMonoid M] (n : ℕ) : (n : tsze R M).snd = 0 :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.inl_natCast","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : AddMonoidWithOne R\ninst✝ : AddMonoid M\nn : Nat\n⊢ Eq (TrivSqZeroExt.inl ↑n) ↑n","decl":"@[simp]\ntheorem inl_natCast [AddMonoidWithOne R] [AddMonoid M] (n : ℕ) : (inl n : tsze R M) = n :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.fst_intCast","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : AddGroupWithOne R\ninst✝ : AddGroup M\nz : Int\n⊢ Eq (↑z).fst ↑z","decl":"@[simp]\ntheorem fst_intCast [AddGroupWithOne R] [AddGroup M] (z : ℤ) : (z : tsze R M).fst = z :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.snd_intCast","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : AddGroupWithOne R\ninst✝ : AddGroup M\nz : Int\n⊢ Eq (↑z).snd 0","decl":"@[simp]\ntheorem snd_intCast [AddGroupWithOne R] [AddGroup M] (z : ℤ) : (z : tsze R M).snd = 0 :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.inl_intCast","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : AddGroupWithOne R\ninst✝ : AddGroup M\nz : Int\n⊢ Eq (TrivSqZeroExt.inl ↑z) ↑z","decl":"@[simp]\ntheorem inl_intCast [AddGroupWithOne R] [AddGroup M] (z : ℤ) : (inl z : tsze R M) = z :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.fst_pow","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Monoid R\ninst✝² : AddMonoid M\ninst✝¹ : DistribMulAction R M\ninst✝ : DistribMulAction (MulOpposite R) M\nx : TrivSqZeroExt R M\nn : Nat\n⊢ Eq (HPow.hPow x n).fst (HPow.hPow x.fst n)","decl":"@[simp]\ntheorem fst_pow [Monoid R] [AddMonoid M] [DistribMulAction R M] [DistribMulAction Rᵐᵒᵖ M]\n    (x : tsze R M) (n : ℕ) : fst (x ^ n) = x.fst ^ n :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.snd_pow_eq_sum","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Monoid R\ninst✝² : AddMonoid M\ninst✝¹ : DistribMulAction R M\ninst✝ : DistribMulAction (MulOpposite R) M\nx : TrivSqZeroExt R M\nn : Nat\n⊢ Eq (HPow.hPow x n).snd (List.map (fun i => HSMul.hSMul (MulOpposite.op (HPow.hPow x.fst i)) (HSMul.hSMul (HPow.hPow x.fst (HSub.hSub n.pred i)) x.snd)) (List.range n)).sum","decl":"theorem snd_pow_eq_sum [Monoid R] [AddMonoid M] [DistribMulAction R M] [DistribMulAction Rᵐᵒᵖ M]\n    (x : tsze R M) (n : ℕ) :\n    snd (x ^ n) = ((List.range n).map fun i => x.fst ^ (n.pred - i) •> x.snd <• x.fst ^ i).sum :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.snd_pow_of_smul_comm","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Monoid R\ninst✝³ : AddMonoid M\ninst✝² : DistribMulAction R M\ninst✝¹ : DistribMulAction (MulOpposite R) M\ninst✝ : SMulCommClass R (MulOpposite R) M\nx : TrivSqZeroExt R M\nn : Nat\nh : Eq (HSMul.hSMul (MulOpposite.op x.fst) x.snd) (HSMul.hSMul x.fst x.snd)\n⊢ Eq (HPow.hPow x n).snd (HSMul.hSMul n (HSMul.hSMul (HPow.hPow x.fst n.pred) x.snd))","decl":"theorem snd_pow_of_smul_comm [Monoid R] [AddMonoid M] [DistribMulAction R M]\n    [DistribMulAction Rᵐᵒᵖ M] [SMulCommClass R Rᵐᵒᵖ M] (x : tsze R M) (n : ℕ)\n    (h : x.snd <• x.fst = x.fst •> x.snd) : snd (x ^ n) = n • x.fst ^ n.pred •> x.snd := by\n  simp_rw [snd_pow_eq_sum, ← smul_comm (_ : R) (_ : Rᵐᵒᵖ), aux, smul_smul, ← pow_add]\n  match n with\n  | 0 => rw [Nat.pred_zero, pow_zero, List.range_zero, zero_smul, List.map_nil, List.sum_nil]\n  | (Nat.succ n) =>\n    simp_rw [Nat.pred_succ]\n    refine (List.sum_eq_card_nsmul _ (x.fst ^ n • x.snd) ?_).trans ?_\n    · rintro m hm\n      simp_rw [List.mem_map, List.mem_range] at hm\n      obtain ⟨i, hi, rfl⟩ := hm\n      rw [Nat.sub_add_cancel (Nat.lt_succ_iff.mp hi)]\n    · rw [List.length_map, List.length_range]\nwhere\n  aux : ∀ n : ℕ, x.snd <• x.fst ^ n = x.fst ^ n •> x.snd := by\n    intro n\n    induction n with\n    | zero => simp\n    | succ n ih =>\n      rw [pow_succ, op_mul, mul_smul, mul_smul, ← h, smul_comm (_ : R) (op x.fst) x.snd, ih]\n\n"}
{"name":"TrivSqZeroExt.snd_pow_of_smul_comm.aux","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Monoid R\ninst✝² : AddMonoid M\ninst✝¹ : DistribMulAction R M\ninst✝ : DistribMulAction (MulOpposite R) M\nx : TrivSqZeroExt R M\nn : Nat\n⊢ Eq (HSMul.hSMul (MulOpposite.op (HPow.hPow x.fst n)) x.snd) (HSMul.hSMul (HPow.hPow x.fst n) x.snd)","decl":"theorem snd_pow_of_smul_comm [Monoid R] [AddMonoid M] [DistribMulAction R M]\n    [DistribMulAction Rᵐᵒᵖ M] [SMulCommClass R Rᵐᵒᵖ M] (x : tsze R M) (n : ℕ)\n    (h : x.snd <• x.fst = x.fst •> x.snd) : snd (x ^ n) = n • x.fst ^ n.pred •> x.snd := by\n  simp_rw [snd_pow_eq_sum, ← smul_comm (_ : R) (_ : Rᵐᵒᵖ), aux, smul_smul, ← pow_add]\n  match n with\n  | 0 => rw [Nat.pred_zero, pow_zero, List.range_zero, zero_smul, List.map_nil, List.sum_nil]\n  | (Nat.succ n) =>\n    simp_rw [Nat.pred_succ]\n    refine (List.sum_eq_card_nsmul _ (x.fst ^ n • x.snd) ?_).trans ?_\n    · rintro m hm\n      simp_rw [List.mem_map, List.mem_range] at hm\n      obtain ⟨i, hi, rfl⟩ := hm\n      rw [Nat.sub_add_cancel (Nat.lt_succ_iff.mp hi)]\n    · rw [List.length_map, List.length_range]\nwhere\n  aux : ∀ n : ℕ, x.snd <• x.fst ^ n = x.fst ^ n •> x.snd := by\n    intro n\n    induction n with\n    | zero => simp\n    | succ n ih =>\n      rw [pow_succ, op_mul, mul_smul, mul_smul, ← h, smul_comm (_ : R) (op x.fst) x.snd, ih]\n\n"}
{"name":"TrivSqZeroExt.snd_pow_of_smul_comm'","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Monoid R\ninst✝³ : AddMonoid M\ninst✝² : DistribMulAction R M\ninst✝¹ : DistribMulAction (MulOpposite R) M\ninst✝ : SMulCommClass R (MulOpposite R) M\nx : TrivSqZeroExt R M\nn : Nat\nh : Eq (HSMul.hSMul (MulOpposite.op x.fst) x.snd) (HSMul.hSMul x.fst x.snd)\n⊢ Eq (HPow.hPow x n).snd (HSMul.hSMul n (HSMul.hSMul (MulOpposite.op (HPow.hPow x.fst n.pred)) x.snd))","decl":"theorem snd_pow_of_smul_comm' [Monoid R] [AddMonoid M] [DistribMulAction R M]\n    [DistribMulAction Rᵐᵒᵖ M] [SMulCommClass R Rᵐᵒᵖ M] (x : tsze R M) (n : ℕ)\n    (h : x.snd <• x.fst = x.fst •> x.snd) : snd (x ^ n) = n • (x.snd <• x.fst ^ n.pred) := by\n  rw [snd_pow_of_smul_comm _ _ h, snd_pow_of_smul_comm.aux _ h]\n\n"}
{"name":"TrivSqZeroExt.snd_pow","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : CommMonoid R\ninst✝³ : AddMonoid M\ninst✝² : DistribMulAction R M\ninst✝¹ : DistribMulAction (MulOpposite R) M\ninst✝ : IsCentralScalar R M\nx : TrivSqZeroExt R M\nn : Nat\n⊢ Eq (HPow.hPow x n).snd (HSMul.hSMul n (HSMul.hSMul (HPow.hPow x.fst n.pred) x.snd))","decl":"@[simp]\ntheorem snd_pow [CommMonoid R] [AddMonoid M] [DistribMulAction R M] [DistribMulAction Rᵐᵒᵖ M]\n    [IsCentralScalar R M] (x : tsze R M) (n : ℕ) : snd (x ^ n) = n • x.fst ^ n.pred • x.snd :=\n  snd_pow_of_smul_comm _ _ (op_smul_eq_smul _ _)\n\n"}
{"name":"TrivSqZeroExt.inl_pow","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Monoid R\ninst✝² : AddMonoid M\ninst✝¹ : DistribMulAction R M\ninst✝ : DistribMulAction (MulOpposite R) M\nr : R\nn : Nat\n⊢ Eq (HPow.hPow (TrivSqZeroExt.inl r) n) (TrivSqZeroExt.inl (HPow.hPow r n))","decl":"@[simp]\ntheorem inl_pow [Monoid R] [AddMonoid M] [DistribMulAction R M] [DistribMulAction Rᵐᵒᵖ M] (r : R)\n    (n : ℕ) : (inl r ^ n : tsze R M) = inl (r ^ n) :=\n  ext rfl <| by simp [snd_pow_eq_sum, List.map_const']\n\n"}
{"name":"TrivSqZeroExt.fst_list_prod","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Monoid R\ninst✝³ : AddMonoid M\ninst✝² : DistribMulAction R M\ninst✝¹ : DistribMulAction (MulOpposite R) M\ninst✝ : SMulCommClass R (MulOpposite R) M\nl : List (TrivSqZeroExt R M)\n⊢ Eq l.prod.fst (List.map TrivSqZeroExt.fst l).prod","decl":"theorem fst_list_prod [Monoid R] [AddMonoid M] [DistribMulAction R M] [DistribMulAction Rᵐᵒᵖ M]\n    [SMulCommClass R Rᵐᵒᵖ M] (l : List (tsze R M)) : l.prod.fst = (l.map fst).prod :=\n  map_list_prod ({ toFun := fst, map_one' := fst_one, map_mul' := fst_mul } : tsze R M →* R) _\n\n"}
{"name":"TrivSqZeroExt.snd_list_prod","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module (MulOpposite R) M\ninst✝ : SMulCommClass R (MulOpposite R) M\nl : List (TrivSqZeroExt R M)\n⊢ Eq l.prod.snd (List.map (fun x => HSMul.hSMul (MulOpposite.op (List.drop x.1.succ (List.map TrivSqZeroExt.fst l)).prod) (HSMul.hSMul (List.take x.1 (List.map TrivSqZeroExt.fst l)).prod x.2.snd)) l.enum).sum","decl":"/-- The second element of a product $\\prod_{i=0}^n (r_i + m_i)$ is a sum of terms of the form\n$r_0\\cdots r_{i-1}m_ir_{i+1}\\cdots r_n$. -/\ntheorem snd_list_prod [Semiring R] [AddCommMonoid M] [Module R M] [Module Rᵐᵒᵖ M]\n    [SMulCommClass R Rᵐᵒᵖ M] (l : List (tsze R M)) :\n    l.prod.snd =\n      (l.enum.map fun x : ℕ × tsze R M =>\n          ((l.map fst).take x.1).prod •> x.snd.snd <• ((l.map fst).drop x.1.succ).prod).sum := by\n  induction l with\n  | nil => simp\n  | cons x xs ih =>\n    rw [List.enum_cons, ← List.map_fst_add_enum_eq_enumFrom]\n    simp_rw [List.map_cons, List.map_map, Function.comp_def, Prod.map_snd, Prod.map_fst, id,\n      List.take_zero, List.take_succ_cons, List.prod_nil, List.prod_cons, snd_mul, one_smul,\n      List.drop, mul_smul, List.sum_cons, fst_list_prod, ih, List.smul_sum, List.map_map,\n      ← smul_comm (_ : R) (_ : Rᵐᵒᵖ)]\n    exact add_comm _ _\n\n"}
{"name":"TrivSqZeroExt.inlHom_apply","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module (MulOpposite R) M\nr : R\n⊢ Eq ((TrivSqZeroExt.inlHom R M) r) (TrivSqZeroExt.inl r)","decl":"/-- The canonical inclusion of rings `R → TrivSqZeroExt R M`. -/\n@[simps apply]\ndef inlHom [Semiring R] [AddCommMonoid M] [Module R M] [Module Rᵐᵒᵖ M] : R →+* tsze R M where\n  toFun := inl\n  map_one' := inl_one M\n  map_mul' := inl_mul M\n  map_zero' := inl_zero M\n  map_add' := inl_add M\n\n"}
{"name":"TrivSqZeroExt.fst_inv","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Neg M\ninst✝² : Inv R\ninst✝¹ : SMul (MulOpposite R) M\ninst✝ : SMul R M\nx : TrivSqZeroExt R M\n⊢ Eq (Inv.inv x).fst (Inv.inv x.fst)","decl":"@[simp] theorem fst_inv (x : tsze R M) : fst x⁻¹ = (fst x)⁻¹ :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.snd_inv","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Neg M\ninst✝² : Inv R\ninst✝¹ : SMul (MulOpposite R) M\ninst✝ : SMul R M\nx : TrivSqZeroExt R M\n⊢ Eq (Inv.inv x).snd (Neg.neg (HSMul.hSMul (MulOpposite.op (Inv.inv x.fst)) (HSMul.hSMul (Inv.inv x.fst) x.snd)))","decl":"@[simp] theorem snd_inv (x : tsze R M) : snd x⁻¹ = -((fst x)⁻¹ •> snd x <• (fst x)⁻¹) :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.fst_invOf","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Semiring R\ninst✝³ : Module (MulOpposite R) M\ninst✝² : Module R M\nx : TrivSqZeroExt R M\ninst✝¹ : Invertible x\ninst✝ : Invertible x.fst\n⊢ Eq (Invertible.invOf x).fst (Invertible.invOf x.fst)","decl":"theorem fst_invOf (x : tsze R M) [Invertible x] [Invertible x.fst] : (⅟x).fst = ⅟(x.fst) := by\n  letI := invertibleFstOfInvertible x\n  convert (rfl : _ = ⅟ x.fst)\n\n"}
{"name":"TrivSqZeroExt.mul_left_eq_one","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Semiring R\ninst✝¹ : Module (MulOpposite R) M\ninst✝ : Module R M\nr : R\nx : TrivSqZeroExt R M\nh : Eq (HMul.hMul r x.fst) 1\n⊢ Eq (HMul.hMul (HAdd.hAdd (TrivSqZeroExt.inl r) (TrivSqZeroExt.inr (Neg.neg (HSMul.hSMul (MulOpposite.op r) (HSMul.hSMul r x.snd))))) x) 1","decl":"theorem mul_left_eq_one (r : R) (x : tsze R M) (h : r * x.fst = 1) :\n    (inl r + inr (-((r •> x.snd) <• r))) * x = 1 := by\n  ext <;> dsimp\n  · rw [add_zero, h]\n  · rw [add_zero, zero_add, smul_neg, op_smul_op_smul, h, op_one, one_smul,\n      add_neg_cancel]\n\n"}
{"name":"TrivSqZeroExt.mul_right_eq_one","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Semiring R\ninst✝¹ : Module (MulOpposite R) M\ninst✝ : Module R M\nx : TrivSqZeroExt R M\nr : R\nh : Eq (HMul.hMul x.fst r) 1\n⊢ Eq (HMul.hMul x (HAdd.hAdd (TrivSqZeroExt.inl r) (TrivSqZeroExt.inr (Neg.neg (HSMul.hSMul r (HSMul.hSMul (MulOpposite.op r) x.snd)))))) 1","decl":"theorem mul_right_eq_one (x : tsze R M) (r : R) (h : x.fst * r = 1) :\n    x * (inl r + inr (-(r •> (x.snd <• r)))) = 1 := by\n  ext <;> dsimp\n  · rw [add_zero, h]\n  · rw [add_zero, zero_add, smul_neg, smul_smul, h, one_smul, neg_add_cancel]\n\n"}
{"name":"TrivSqZeroExt.snd_invOf","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Semiring R\ninst✝⁴ : Module (MulOpposite R) M\ninst✝³ : Module R M\ninst✝² : SMulCommClass R (MulOpposite R) M\nx : TrivSqZeroExt R M\ninst✝¹ : Invertible x\ninst✝ : Invertible x.fst\n⊢ Eq (Invertible.invOf x).snd (Neg.neg (HSMul.hSMul (MulOpposite.op (Invertible.invOf x.fst)) (HSMul.hSMul (Invertible.invOf x.fst) x.snd)))","decl":"theorem snd_invOf (x : tsze R M) [Invertible x] [Invertible x.fst] :\n    (⅟x).snd = -(⅟x.fst •> x.snd <• ⅟x.fst) := by\n  letI := invertibleOfInvertibleFst x\n  convert congr_arg (TrivSqZeroExt.snd (R := R) (M := M)) (_ : _ = ⅟ x)\n  convert rfl\n\n"}
{"name":"TrivSqZeroExt.invertibleEquivInvertibleFst_apply_invOf","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : AddCommGroup M\ninst✝³ : Semiring R\ninst✝² : Module (MulOpposite R) M\ninst✝¹ : Module R M\ninst✝ : SMulCommClass R (MulOpposite R) M\nx : TrivSqZeroExt R M\nx✝ : Invertible x\n⊢ Eq (Invertible.invOf x.fst) (Invertible.invOf x).fst","decl":"/-- Together `TrivSqZeroExt.detInvertibleOfInvertible` and `TrivSqZeroExt.invertibleOfDetInvertible`\nform an equivalence, although both sides of the equiv are subsingleton anyway. -/\n@[simps]\ndef invertibleEquivInvertibleFst (x : tsze R M) : Invertible x ≃ Invertible x.fst where\n  toFun _ := invertibleFstOfInvertible x\n  invFun _ := invertibleOfInvertibleFst x\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _\n\n"}
{"name":"TrivSqZeroExt.invertibleEquivInvertibleFst_symm_apply_invOf","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : AddCommGroup M\ninst✝³ : Semiring R\ninst✝² : Module (MulOpposite R) M\ninst✝¹ : Module R M\ninst✝ : SMulCommClass R (MulOpposite R) M\nx : TrivSqZeroExt R M\nx✝ : Invertible x.fst\n⊢ Eq (Invertible.invOf x) { fst := Invertible.invOf x.fst, snd := Neg.neg (HSMul.hSMul (MulOpposite.op (Invertible.invOf x.fst)) (HSMul.hSMul (Invertible.invOf x.fst) x.snd)) }","decl":"/-- Together `TrivSqZeroExt.detInvertibleOfInvertible` and `TrivSqZeroExt.invertibleOfDetInvertible`\nform an equivalence, although both sides of the equiv are subsingleton anyway. -/\n@[simps]\ndef invertibleEquivInvertibleFst (x : tsze R M) : Invertible x ≃ Invertible x.fst where\n  toFun _ := invertibleFstOfInvertible x\n  invFun _ := invertibleOfInvertibleFst x\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _\n\n"}
{"name":"TrivSqZeroExt.isUnit_iff_isUnit_fst","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : AddCommGroup M\ninst✝³ : Semiring R\ninst✝² : Module (MulOpposite R) M\ninst✝¹ : Module R M\ninst✝ : SMulCommClass R (MulOpposite R) M\nx : TrivSqZeroExt R M\n⊢ Iff (IsUnit x) (IsUnit x.fst)","decl":"/-- When lowered to a prop, `Matrix.invertibleEquivInvertibleFst` forms an `iff`. -/\ntheorem isUnit_iff_isUnit_fst {x : tsze R M} : IsUnit x ↔ IsUnit x.fst := by\n  simp only [← nonempty_invertible_iff_isUnit, (invertibleEquivInvertibleFst x).nonempty_congr]\n\n"}
{"name":"TrivSqZeroExt.isUnit_inl_iff","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : AddCommGroup M\ninst✝³ : Semiring R\ninst✝² : Module (MulOpposite R) M\ninst✝¹ : Module R M\ninst✝ : SMulCommClass R (MulOpposite R) M\nr : R\n⊢ Iff (IsUnit (TrivSqZeroExt.inl r)) (IsUnit r)","decl":"@[simp]\ntheorem isUnit_inl_iff {r : R} : IsUnit (inl r : tsze R M) ↔ IsUnit r := by\n  rw [isUnit_iff_isUnit_fst, fst_inl]\n\n"}
{"name":"TrivSqZeroExt.isUnit_inr_iff","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : AddCommGroup M\ninst✝³ : Semiring R\ninst✝² : Module (MulOpposite R) M\ninst✝¹ : Module R M\ninst✝ : SMulCommClass R (MulOpposite R) M\nm : M\n⊢ Iff (IsUnit (TrivSqZeroExt.inr m)) (Subsingleton R)","decl":"@[simp]\ntheorem isUnit_inr_iff {m : M} : IsUnit (inr m : tsze R M) ↔ Subsingleton R := by\n  simp_rw [isUnit_iff_isUnit_fst, fst_inr, isUnit_zero_iff, subsingleton_iff_zero_eq_one]\n\n"}
{"name":"TrivSqZeroExt.inv_inl","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : DivisionSemiring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module (MulOpposite R) M\ninst✝ : Module R M\nr : R\n⊢ Eq (Inv.inv (TrivSqZeroExt.inl r)) (TrivSqZeroExt.inl (Inv.inv r))","decl":"protected theorem inv_inl (r : R) :\n    (inl r)⁻¹ = (inl (r⁻¹ : R) : tsze R M) := by\n  ext\n  · rw [fst_inv, fst_inl, fst_inl]\n  · rw [snd_inv, fst_inl, snd_inl, snd_inl, smul_zero, smul_zero, neg_zero]\n\n"}
{"name":"TrivSqZeroExt.inv_inr","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : DivisionSemiring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module (MulOpposite R) M\ninst✝ : Module R M\nm : M\n⊢ Eq (Inv.inv (TrivSqZeroExt.inr m)) 0","decl":"@[simp]\ntheorem inv_inr (m : M) : (inr m)⁻¹ = (0 : tsze R M) := by\n  ext\n  · rw [fst_inv, fst_inr, fst_zero, inv_zero]\n  · rw [snd_inv, snd_inr, fst_inr, inv_zero, op_zero, zero_smul, snd_zero, neg_zero]\n\n"}
{"name":"TrivSqZeroExt.inv_zero","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : DivisionSemiring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module (MulOpposite R) M\ninst✝ : Module R M\n⊢ Eq (Inv.inv 0) 0","decl":"@[simp]\nprotected theorem inv_zero : (0 : tsze R M)⁻¹ = (0 : tsze R M) := by\n  rw [← inl_zero, TrivSqZeroExt.inv_inl, inv_zero]\n\n"}
{"name":"TrivSqZeroExt.inv_one","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : DivisionSemiring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module (MulOpposite R) M\ninst✝ : Module R M\n⊢ Eq (Inv.inv 1) 1","decl":"@[simp]\nprotected theorem inv_one : (1 : tsze R M)⁻¹ = (1 : tsze R M) := by\n  rw [← inl_one, TrivSqZeroExt.inv_inl, inv_one]\n\n"}
{"name":"TrivSqZeroExt.inv_mul_cancel","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : DivisionSemiring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module (MulOpposite R) M\ninst✝ : Module R M\nx : TrivSqZeroExt R M\nhx : Ne x.fst 0\n⊢ Eq (HMul.hMul (Inv.inv x) x) 1","decl":"protected theorem inv_mul_cancel {x : tsze R M} (hx : fst x ≠ 0) : x⁻¹ * x = 1 := by\n  convert mul_left_eq_one _ _ (_root_.inv_mul_cancel₀ hx) using 2\n  ext <;> simp\n\n"}
{"name":"TrivSqZeroExt.invOf_eq_inv","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : DivisionSemiring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module (MulOpposite R) M\ninst✝² : Module R M\ninst✝¹ : SMulCommClass R (MulOpposite R) M\nx : TrivSqZeroExt R M\ninst✝ : Invertible x\n⊢ Eq (Invertible.invOf x) (Inv.inv x)","decl":"@[simp] theorem invOf_eq_inv (x : tsze R M) [Invertible x] : ⅟x = x⁻¹ := by\n  letI := invertibleFstOfInvertible x\n  ext <;> simp [fst_invOf, snd_invOf]\n\n"}
{"name":"TrivSqZeroExt.mul_inv_cancel","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : DivisionSemiring R\ninst✝³ : AddCommGroup M\ninst✝² : Module (MulOpposite R) M\ninst✝¹ : Module R M\ninst✝ : SMulCommClass R (MulOpposite R) M\nx : TrivSqZeroExt R M\nhx : Ne x.fst 0\n⊢ Eq (HMul.hMul x (Inv.inv x)) 1","decl":"protected theorem mul_inv_cancel {x : tsze R M} (hx : fst x ≠ 0) : x * x⁻¹ = 1 := by\n  have : Invertible x.fst := Units.invertible (.mk0 _ hx)\n  have := invertibleOfInvertibleFst x\n  rw [← invOf_eq_inv, mul_invOf_self]\n\n"}
{"name":"TrivSqZeroExt.mul_inv_rev","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : DivisionSemiring R\ninst✝³ : AddCommGroup M\ninst✝² : Module (MulOpposite R) M\ninst✝¹ : Module R M\ninst✝ : SMulCommClass R (MulOpposite R) M\na b : TrivSqZeroExt R M\n⊢ Eq (Inv.inv (HMul.hMul a b)) (HMul.hMul (Inv.inv b) (Inv.inv a))","decl":"protected theorem mul_inv_rev (a b : tsze R M) :\n    (a * b)⁻¹ = b⁻¹ * a⁻¹ := by\n  ext\n  · rw [fst_inv, fst_mul, fst_mul, mul_inv_rev, fst_inv, fst_inv]\n  · simp only [snd_inv, snd_mul, fst_mul, fst_inv]\n    simp only [neg_smul, smul_neg, smul_add]\n    simp_rw [mul_inv_rev, smul_comm (_ : R), op_smul_op_smul, smul_smul, add_comm, neg_add]\n    obtain ha0 | ha := eq_or_ne (fst a) 0\n    · simp [ha0]\n    obtain hb0 | hb := eq_or_ne (fst b) 0\n    · simp [hb0]\n    rw [inv_mul_cancel_right₀ ha, mul_inv_cancel_left₀ hb]\n\n"}
{"name":"TrivSqZeroExt.inv_inv","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : DivisionSemiring R\ninst✝³ : AddCommGroup M\ninst✝² : Module (MulOpposite R) M\ninst✝¹ : Module R M\ninst✝ : SMulCommClass R (MulOpposite R) M\nx : TrivSqZeroExt R M\nhx : Ne x.fst 0\n⊢ Eq (Inv.inv (Inv.inv x)) x","decl":"protected theorem inv_inv {x : tsze R M} (hx : fst x ≠ 0) : x⁻¹⁻¹ = x :=\n  -- adapted from `Matrix.nonsing_inv_nonsing_inv`\n  calc\n    x⁻¹⁻¹ = 1 * x⁻¹⁻¹ := by rw [one_mul]\n    _ = x * x⁻¹ * x⁻¹⁻¹ := by rw [TrivSqZeroExt.mul_inv_cancel hx]\n    _ = x := by\n      rw [mul_assoc, TrivSqZeroExt.mul_inv_cancel, mul_one]\n      rw [fst_inv]\n      apply inv_ne_zero hx\n\n"}
{"name":"TrivSqZeroExt.isUnit_inv_iff","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : DivisionSemiring R\ninst✝³ : AddCommGroup M\ninst✝² : Module (MulOpposite R) M\ninst✝¹ : Module R M\ninst✝ : SMulCommClass R (MulOpposite R) M\nx : TrivSqZeroExt R M\n⊢ Iff (IsUnit (Inv.inv x)) (IsUnit x)","decl":"@[simp]\ntheorem isUnit_inv_iff {x : tsze R M} : IsUnit x⁻¹ ↔ IsUnit x := by\n  simp_rw [isUnit_iff_isUnit_fst, fst_inv, isUnit_iff_ne_zero, ne_eq, inv_eq_zero]\n\n"}
{"name":"TrivSqZeroExt.inv_neg","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R : Type u\nM : Type v\ninst✝³ : DivisionRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module (MulOpposite R) M\ninst✝ : Module R M\nx : TrivSqZeroExt R M\n⊢ Eq (Inv.inv (Neg.neg x)) (Neg.neg (Inv.inv x))","decl":"protected theorem inv_neg {x : tsze R M} : (-x)⁻¹ = -(x⁻¹) := by\n  ext <;> simp [inv_neg]\n\n"}
{"name":"TrivSqZeroExt.algebraMap_eq_inl","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R' : Type u\nM : Type v\ninst✝⁴ : CommSemiring R'\ninst✝³ : AddCommMonoid M\ninst✝² : Module R' M\ninst✝¹ : Module (MulOpposite R') M\ninst✝ : IsCentralScalar R' M\n⊢ Eq (⇑(algebraMap R' (TrivSqZeroExt R' M))) TrivSqZeroExt.inl","decl":"theorem algebraMap_eq_inl : ⇑(algebraMap R' (tsze R' M)) = inl :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.algebraMap_eq_inlHom","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R' : Type u\nM : Type v\ninst✝⁴ : CommSemiring R'\ninst✝³ : AddCommMonoid M\ninst✝² : Module R' M\ninst✝¹ : Module (MulOpposite R') M\ninst✝ : IsCentralScalar R' M\n⊢ Eq (algebraMap R' (TrivSqZeroExt R' M)) (TrivSqZeroExt.inlHom R' M)","decl":"theorem algebraMap_eq_inlHom : algebraMap R' (tsze R' M) = inlHom R' M :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.algebraMap_eq_inl'","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"S : Type u_1\nR : Type u\nM : Type v\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Algebra S R\ninst✝⁵ : Module S M\ninst✝⁴ : Module R M\ninst✝³ : Module (MulOpposite R) M\ninst✝² : SMulCommClass R (MulOpposite R) M\ninst✝¹ : IsScalarTower S R M\ninst✝ : IsScalarTower S (MulOpposite R) M\ns : S\n⊢ Eq ((algebraMap S (TrivSqZeroExt R M)) s) (TrivSqZeroExt.inl ((algebraMap S R) s))","decl":"theorem algebraMap_eq_inl' (s : S) : algebraMap S (tsze R M) s = inl (algebraMap S R s) :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.fstHom_apply","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"S : Type u_1\nR : Type u\nM : Type v\ninst✝⁷ : CommSemiring S\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Algebra S R\ninst✝³ : Module S M\ninst✝² : Module R M\ninst✝¹ : Module (MulOpposite R) M\ninst✝ : SMulCommClass R (MulOpposite R) M\nx : TrivSqZeroExt R M\n⊢ Eq ((TrivSqZeroExt.fstHom S R M) x) x.fst","decl":"/-- The canonical `S`-algebra projection `TrivSqZeroExt R M → R`. -/\n@[simps]\ndef fstHom : tsze R M →ₐ[S] R where\n  toFun := fst\n  map_one' := fst_one\n  map_mul' := fst_mul\n  map_zero' := fst_zero (M := M)\n  map_add' := fst_add\n  commutes' _r := fst_inl M _\n\n"}
{"name":"TrivSqZeroExt.inlAlgHom_apply","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"S : Type u_1\nR : Type u\nM : Type v\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Algebra S R\ninst✝⁵ : Module S M\ninst✝⁴ : Module R M\ninst✝³ : Module (MulOpposite R) M\ninst✝² : SMulCommClass R (MulOpposite R) M\ninst✝¹ : IsScalarTower S R M\ninst✝ : IsScalarTower S (MulOpposite R) M\nr : R\n⊢ Eq ((TrivSqZeroExt.inlAlgHom S R M) r) (TrivSqZeroExt.inl r)","decl":"/-- The canonical `S`-algebra inclusion `R → TrivSqZeroExt R M`. -/\n@[simps]\ndef inlAlgHom : R →ₐ[S] tsze R M where\n  toFun := inl\n  map_one' := inl_one _\n  map_mul' := inl_mul _\n  map_zero' := inl_zero (M := M)\n  map_add' := inl_add _\n  commutes' _r := (algebraMap_eq_inl' _ _ _ _).symm\n\n"}
{"name":"TrivSqZeroExt.algHom_ext","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R' : Type u\nM : Type v\ninst✝⁶ : CommSemiring R'\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R' M\ninst✝³ : Module (MulOpposite R') M\ninst✝² : IsCentralScalar R' M\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra R' A\nf g : AlgHom R' (TrivSqZeroExt R' M) A\nh : ∀ (m : M), Eq (f (TrivSqZeroExt.inr m)) (g (TrivSqZeroExt.inr m))\n⊢ Eq f g","decl":"theorem algHom_ext {A} [Semiring A] [Algebra R' A] ⦃f g : tsze R' M →ₐ[R'] A⦄\n    (h : ∀ m, f (inr m) = g (inr m)) : f = g :=\n  AlgHom.toLinearMap_injective <|\n    linearMap_ext (fun _r => (f.commutes _).trans (g.commutes _).symm) h\n\n"}
{"name":"TrivSqZeroExt.algHom_ext'","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"S : Type u_1\nR : Type u\nM : Type v\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Semiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Algebra S R\ninst✝⁷ : Module S M\ninst✝⁶ : Module R M\ninst✝⁵ : Module (MulOpposite R) M\ninst✝⁴ : SMulCommClass R (MulOpposite R) M\ninst✝³ : IsScalarTower S R M\ninst✝² : IsScalarTower S (MulOpposite R) M\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra S A\nf g : AlgHom S (TrivSqZeroExt R M) A\nhinl : Eq (f.comp (TrivSqZeroExt.inlAlgHom S R M)) (g.comp (TrivSqZeroExt.inlAlgHom S R M))\nhinr : Eq (f.toLinearMap.comp (↑S (TrivSqZeroExt.inrHom R M))) (g.toLinearMap.comp (↑S (TrivSqZeroExt.inrHom R M)))\n⊢ Eq f g","decl":"@[ext]\ntheorem algHom_ext' {A} [Semiring A] [Algebra S A] ⦃f g : tsze R M →ₐ[S] A⦄\n    (hinl : f.comp (inlAlgHom S R M) = g.comp (inlAlgHom S R M))\n    (hinr : f.toLinearMap.comp (inrHom R M |>.restrictScalars S) =\n      g.toLinearMap.comp (inrHom R M |>.restrictScalars S)) : f = g :=\n  AlgHom.toLinearMap_injective <|\n    linearMap_ext (AlgHom.congr_fun hinl) (LinearMap.congr_fun hinr)\n\n"}
{"name":"TrivSqZeroExt.algHom_ext'_iff","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"S : Type u_1\nR : Type u\nM : Type v\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Semiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Algebra S R\ninst✝⁷ : Module S M\ninst✝⁶ : Module R M\ninst✝⁵ : Module (MulOpposite R) M\ninst✝⁴ : SMulCommClass R (MulOpposite R) M\ninst✝³ : IsScalarTower S R M\ninst✝² : IsScalarTower S (MulOpposite R) M\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra S A\nf g : AlgHom S (TrivSqZeroExt R M) A\n⊢ Iff (Eq f g) (And (Eq (f.comp (TrivSqZeroExt.inlAlgHom S R M)) (g.comp (TrivSqZeroExt.inlAlgHom S R M))) (Eq (f.toLinearMap.comp (↑S (TrivSqZeroExt.inrHom R M))) (g.toLinearMap.comp (↑S (TrivSqZeroExt.inrHom R M)))))","decl":"@[ext]\ntheorem algHom_ext' {A} [Semiring A] [Algebra S A] ⦃f g : tsze R M →ₐ[S] A⦄\n    (hinl : f.comp (inlAlgHom S R M) = g.comp (inlAlgHom S R M))\n    (hinr : f.toLinearMap.comp (inrHom R M |>.restrictScalars S) =\n      g.toLinearMap.comp (inrHom R M |>.restrictScalars S)) : f = g :=\n  AlgHom.toLinearMap_injective <|\n    linearMap_ext (AlgHom.congr_fun hinl) (LinearMap.congr_fun hinr)\n\n"}
{"name":"TrivSqZeroExt.lift_def","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"S : Type u_1\nR : Type u\nM : Type v\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Semiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Algebra S R\ninst✝⁷ : Module S M\ninst✝⁶ : Module R M\ninst✝⁵ : Module (MulOpposite R) M\ninst✝⁴ : SMulCommClass R (MulOpposite R) M\ninst✝³ : IsScalarTower S R M\ninst✝² : IsScalarTower S (MulOpposite R) M\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra S A\nf : AlgHom S R A\ng : LinearMap (RingHom.id S) M A\nhg : ∀ (x y : M), Eq (HMul.hMul (g x) (g y)) 0\nhfg : ∀ (r : R) (x : M), Eq (g (HSMul.hSMul r x)) (HMul.hMul (f r) (g x))\nhgf : ∀ (r : R) (x : M), Eq (g (HSMul.hSMul (MulOpposite.op r) x)) (HMul.hMul (g x) (f r))\nx : TrivSqZeroExt R M\n⊢ Eq ((TrivSqZeroExt.lift f g hg hfg hgf) x) (HAdd.hAdd (f x.fst) (g x.snd))","decl":"theorem lift_def (f : R →ₐ[S] A) (g : M →ₗ[S] A)\n    (hg : ∀ x y, g x * g y = 0)\n    (hfg : ∀ r x, g (r • x) = f r * g x)\n    (hgf : ∀ r x, g (op r • x) = g x * f r) (x : tsze R M) :\n    lift f g hg hfg hgf x = f x.fst + g x.snd :=\n  rfl\n\n"}
{"name":"TrivSqZeroExt.lift_apply_inl","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"S : Type u_1\nR : Type u\nM : Type v\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Semiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Algebra S R\ninst✝⁷ : Module S M\ninst✝⁶ : Module R M\ninst✝⁵ : Module (MulOpposite R) M\ninst✝⁴ : SMulCommClass R (MulOpposite R) M\ninst✝³ : IsScalarTower S R M\ninst✝² : IsScalarTower S (MulOpposite R) M\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra S A\nf : AlgHom S R A\ng : LinearMap (RingHom.id S) M A\nhg : ∀ (x y : M), Eq (HMul.hMul (g x) (g y)) 0\nhfg : ∀ (r : R) (x : M), Eq (g (HSMul.hSMul r x)) (HMul.hMul (f r) (g x))\nhgf : ∀ (r : R) (x : M), Eq (g (HSMul.hSMul (MulOpposite.op r) x)) (HMul.hMul (g x) (f r))\nr : R\n⊢ Eq ((TrivSqZeroExt.lift f g hg hfg hgf) (TrivSqZeroExt.inl r)) (f r)","decl":"@[simp]\ntheorem lift_apply_inl (f : R →ₐ[S] A) (g : M →ₗ[S] A)\n    (hg : ∀ x y, g x * g y = 0)\n    (hfg : ∀ r x, g (r •> x) = f r * g x)\n    (hgf : ∀ r x, g (x <• r) = g x * f r)\n    (r : R) :\n    lift f g hg hfg hgf (inl r) = f r :=\n  show f r + g 0 = f r by rw [map_zero, add_zero]\n\n"}
{"name":"TrivSqZeroExt.lift_apply_inr","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"S : Type u_1\nR : Type u\nM : Type v\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Semiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Algebra S R\ninst✝⁷ : Module S M\ninst✝⁶ : Module R M\ninst✝⁵ : Module (MulOpposite R) M\ninst✝⁴ : SMulCommClass R (MulOpposite R) M\ninst✝³ : IsScalarTower S R M\ninst✝² : IsScalarTower S (MulOpposite R) M\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra S A\nf : AlgHom S R A\ng : LinearMap (RingHom.id S) M A\nhg : ∀ (x y : M), Eq (HMul.hMul (g x) (g y)) 0\nhfg : ∀ (r : R) (x : M), Eq (g (HSMul.hSMul r x)) (HMul.hMul (f r) (g x))\nhgf : ∀ (r : R) (x : M), Eq (g (HSMul.hSMul (MulOpposite.op r) x)) (HMul.hMul (g x) (f r))\nm : M\n⊢ Eq ((TrivSqZeroExt.lift f g hg hfg hgf) (TrivSqZeroExt.inr m)) (g m)","decl":"@[simp]\ntheorem lift_apply_inr (f : R →ₐ[S] A) (g : M →ₗ[S] A)\n    (hg : ∀ x y, g x * g y = 0)\n    (hfg : ∀ r x, g (r •> x) = f r * g x)\n    (hgf : ∀ r x, g (x <• r) = g x * f r)\n    (m : M) :\n    lift f g hg hfg hgf (inr m) = g m :=\n  show f 0 + g m = g m by rw [map_zero, zero_add]\n\n"}
{"name":"TrivSqZeroExt.lift_comp_inlHom","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"S : Type u_1\nR : Type u\nM : Type v\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Semiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Algebra S R\ninst✝⁷ : Module S M\ninst✝⁶ : Module R M\ninst✝⁵ : Module (MulOpposite R) M\ninst✝⁴ : SMulCommClass R (MulOpposite R) M\ninst✝³ : IsScalarTower S R M\ninst✝² : IsScalarTower S (MulOpposite R) M\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra S A\nf : AlgHom S R A\ng : LinearMap (RingHom.id S) M A\nhg : ∀ (x y : M), Eq (HMul.hMul (g x) (g y)) 0\nhfg : ∀ (r : R) (x : M), Eq (g (HSMul.hSMul r x)) (HMul.hMul (f r) (g x))\nhgf : ∀ (r : R) (x : M), Eq (g (HSMul.hSMul (MulOpposite.op r) x)) (HMul.hMul (g x) (f r))\n⊢ Eq ((TrivSqZeroExt.lift f g hg hfg hgf).comp (TrivSqZeroExt.inlAlgHom S R M)) f","decl":"@[simp]\ntheorem lift_comp_inlHom (f : R →ₐ[S] A) (g : M →ₗ[S] A)\n    (hg : ∀ x y, g x * g y = 0)\n    (hfg : ∀ r x, g (r •> x) = f r * g x)\n    (hgf : ∀ r x, g (x <• r) = g x * f r) :\n    (lift f g hg hfg hgf).comp (inlAlgHom S R M) = f :=\n  AlgHom.ext <| lift_apply_inl f g hg hfg hgf\n\n"}
{"name":"TrivSqZeroExt.lift_comp_inrHom","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"S : Type u_1\nR : Type u\nM : Type v\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Semiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Algebra S R\ninst✝⁷ : Module S M\ninst✝⁶ : Module R M\ninst✝⁵ : Module (MulOpposite R) M\ninst✝⁴ : SMulCommClass R (MulOpposite R) M\ninst✝³ : IsScalarTower S R M\ninst✝² : IsScalarTower S (MulOpposite R) M\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra S A\nf : AlgHom S R A\ng : LinearMap (RingHom.id S) M A\nhg : ∀ (x y : M), Eq (HMul.hMul (g x) (g y)) 0\nhfg : ∀ (r : R) (x : M), Eq (g (HSMul.hSMul r x)) (HMul.hMul (f r) (g x))\nhgf : ∀ (r : R) (x : M), Eq (g (HSMul.hSMul (MulOpposite.op r) x)) (HMul.hMul (g x) (f r))\n⊢ Eq ((TrivSqZeroExt.lift f g hg hfg hgf).toLinearMap.comp (↑S (TrivSqZeroExt.inrHom R M))) g","decl":"@[simp]\ntheorem lift_comp_inrHom (f : R →ₐ[S] A) (g : M →ₗ[S] A)\n    (hg : ∀ x y, g x * g y = 0)\n    (hfg : ∀ r x, g (r •> x) = f r * g x)\n    (hgf : ∀ r x, g (x <• r) = g x * f r) :\n    (lift f g hg hfg hgf).toLinearMap.comp (inrHom R M |>.restrictScalars S) = g :=\n  LinearMap.ext <| lift_apply_inr f g hg hfg hgf\n\n"}
{"name":"TrivSqZeroExt.lift_inlAlgHom_inrHom","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"S : Type u_1\nR : Type u\nM : Type v\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Algebra S R\ninst✝⁵ : Module S M\ninst✝⁴ : Module R M\ninst✝³ : Module (MulOpposite R) M\ninst✝² : SMulCommClass R (MulOpposite R) M\ninst✝¹ : IsScalarTower S R M\ninst✝ : IsScalarTower S (MulOpposite R) M\n⊢ Eq (TrivSqZeroExt.lift (TrivSqZeroExt.inlAlgHom S R M) (↑S (TrivSqZeroExt.inrHom R M)) ⋯ ⋯ ⋯) (AlgHom.id S (TrivSqZeroExt R M))","decl":"/-- When applied to `inr` and `inl` themselves, `lift` is the identity. -/\n@[simp]\ntheorem lift_inlAlgHom_inrHom :\n    lift (inlAlgHom _ _ _) (inrHom R M |>.restrictScalars S)\n      (inr_mul_inr R) (fun _ _ => (inl_mul_inr _ _).symm) (fun _ _ => (inr_mul_inl _ _).symm) =\n    AlgHom.id S (tsze R M) :=\n  algHom_ext' (lift_comp_inlHom _ _ _ _ _) (lift_comp_inrHom _ _ _ _ _)\n\n"}
{"name":"TrivSqZeroExt.liftEquiv_symm_apply_coe","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"S : Type u_1\nR : Type u\nM : Type v\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Semiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Algebra S R\ninst✝⁷ : Module S M\ninst✝⁶ : Module R M\ninst✝⁵ : Module (MulOpposite R) M\ninst✝⁴ : SMulCommClass R (MulOpposite R) M\ninst✝³ : IsScalarTower S R M\ninst✝² : IsScalarTower S (MulOpposite R) M\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra S A\nF : AlgHom S (TrivSqZeroExt R M) A\n⊢ Eq ↑(TrivSqZeroExt.liftEquiv.symm F) { fst := F.comp (TrivSqZeroExt.inlAlgHom S R M), snd := F.toLinearMap.comp (↑S (TrivSqZeroExt.inrHom R M)) }","decl":"/-- A universal property of the trivial square-zero extension, providing a unique\n`TrivSqZeroExt R M →ₐ[R] A` for every pair of maps `f : R →ₐ[S] A` and `g : M →ₗ[S] A`,\nwhere the range of `g` has no non-zero products, and scaling the input to `g` on the left or right\namounts to a corresponding multiplication by `f` in the output.\n\nThis isomorphism is named to match the very similar `Complex.lift`. -/\n@[simps! apply symm_apply_coe]\ndef liftEquiv :\n    {fg : (R →ₐ[S] A) × (M →ₗ[S] A) //\n      (∀ x y, fg.2 x * fg.2 y = 0) ∧\n      (∀ r x, fg.2 (r •> x) = fg.1 r * fg.2 x) ∧\n      (∀ r x, fg.2 (x <• r) = fg.2 x * fg.1 r)} ≃ (tsze R M →ₐ[S] A) where\n  toFun fg := lift fg.val.1 fg.val.2 fg.prop.1 fg.prop.2.1 fg.prop.2.2\n  invFun F :=\n    ⟨(F.comp (inlAlgHom _ _ _), F.toLinearMap ∘ₗ (inrHom _ _ |>.restrictScalars _)),\n      (fun _x _y =>\n        (map_mul F _ _).symm.trans <| (F.congr_arg <| inr_mul_inr _ _ _).trans (map_zero F)),\n      (fun _r _x => (F.congr_arg (inl_mul_inr _ _).symm).trans (map_mul F _ _)),\n      (fun _r _x => (F.congr_arg (inr_mul_inl _ _).symm).trans (map_mul F _ _))⟩\n  left_inv _f := Subtype.ext <| Prod.ext (lift_comp_inlHom _ _ _ _ _) (lift_comp_inrHom _ _ _ _ _)\n  right_inv _F := algHom_ext' (lift_comp_inlHom _ _ _ _ _) (lift_comp_inrHom _ _ _ _ _)\n\n"}
{"name":"TrivSqZeroExt.liftEquiv_apply","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"S : Type u_1\nR : Type u\nM : Type v\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Semiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Algebra S R\ninst✝⁷ : Module S M\ninst✝⁶ : Module R M\ninst✝⁵ : Module (MulOpposite R) M\ninst✝⁴ : SMulCommClass R (MulOpposite R) M\ninst✝³ : IsScalarTower S R M\ninst✝² : IsScalarTower S (MulOpposite R) M\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra S A\nfg : Subtype fun fg => And (∀ (x y : M), Eq (HMul.hMul (fg.2 x) (fg.2 y)) 0) (And (∀ (r : R) (x : M), Eq (fg.2 (HSMul.hSMul r x)) (HMul.hMul (fg.1 r) (fg.2 x))) (∀ (r : R) (x : M), Eq (fg.2 (HSMul.hSMul (MulOpposite.op r) x)) (HMul.hMul (fg.2 x) (fg.1 r))))\n⊢ Eq (TrivSqZeroExt.liftEquiv fg) (TrivSqZeroExt.lift (↑fg).1 (↑fg).2 ⋯ ⋯ ⋯)","decl":"/-- A universal property of the trivial square-zero extension, providing a unique\n`TrivSqZeroExt R M →ₐ[R] A` for every pair of maps `f : R →ₐ[S] A` and `g : M →ₗ[S] A`,\nwhere the range of `g` has no non-zero products, and scaling the input to `g` on the left or right\namounts to a corresponding multiplication by `f` in the output.\n\nThis isomorphism is named to match the very similar `Complex.lift`. -/\n@[simps! apply symm_apply_coe]\ndef liftEquiv :\n    {fg : (R →ₐ[S] A) × (M →ₗ[S] A) //\n      (∀ x y, fg.2 x * fg.2 y = 0) ∧\n      (∀ r x, fg.2 (r •> x) = fg.1 r * fg.2 x) ∧\n      (∀ r x, fg.2 (x <• r) = fg.2 x * fg.1 r)} ≃ (tsze R M →ₐ[S] A) where\n  toFun fg := lift fg.val.1 fg.val.2 fg.prop.1 fg.prop.2.1 fg.prop.2.2\n  invFun F :=\n    ⟨(F.comp (inlAlgHom _ _ _), F.toLinearMap ∘ₗ (inrHom _ _ |>.restrictScalars _)),\n      (fun _x _y =>\n        (map_mul F _ _).symm.trans <| (F.congr_arg <| inr_mul_inr _ _ _).trans (map_zero F)),\n      (fun _r _x => (F.congr_arg (inl_mul_inr _ _).symm).trans (map_mul F _ _)),\n      (fun _r _x => (F.congr_arg (inr_mul_inl _ _).symm).trans (map_mul F _ _))⟩\n  left_inv _f := Subtype.ext <| Prod.ext (lift_comp_inlHom _ _ _ _ _) (lift_comp_inrHom _ _ _ _ _)\n  right_inv _F := algHom_ext' (lift_comp_inlHom _ _ _ _ _) (lift_comp_inrHom _ _ _ _ _)\n\n"}
{"name":"TrivSqZeroExt.liftEquivOfComm_apply","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R' : Type u\nM : Type v\ninst✝⁶ : CommSemiring R'\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R' M\ninst✝³ : Module (MulOpposite R') M\ninst✝² : IsCentralScalar R' M\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra R' A\na✝ : Subtype fun f => ∀ (x y : M), Eq (HMul.hMul (f x) (f y)) 0\n⊢ Eq (TrivSqZeroExt.liftEquivOfComm a✝) (TrivSqZeroExt.lift (Algebra.ofId R' A) ↑a✝ ⋯ ⋯ ⋯)","decl":"/-- A simplified version of `TrivSqZeroExt.liftEquiv` for the commutative case. -/\n@[simps! apply symm_apply_coe]\ndef liftEquivOfComm :\n    { f : M →ₗ[R'] A // ∀ x y, f x * f y = 0 } ≃ (tsze R' M →ₐ[R'] A) := by\n  refine Equiv.trans ?_ liftEquiv\n  exact {\n    toFun := fun f => ⟨(Algebra.ofId _ _, f.val), f.prop,\n      fun r x => by simp [Algebra.smul_def, Algebra.ofId_apply],\n      fun r x => by simp [Algebra.smul_def, Algebra.ofId_apply, Algebra.commutes]⟩\n    invFun := fun fg => ⟨fg.val.2, fg.prop.1⟩\n    left_inv := fun f => rfl\n    right_inv := fun fg => Subtype.ext <|\n      Prod.ext (AlgHom.toLinearMap_injective <| LinearMap.ext_ring <| by simp)\n      rfl }\n\n"}
{"name":"TrivSqZeroExt.liftEquivOfComm_symm_apply_coe","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R' : Type u\nM : Type v\ninst✝⁶ : CommSemiring R'\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R' M\ninst✝³ : Module (MulOpposite R') M\ninst✝² : IsCentralScalar R' M\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra R' A\na✝ : AlgHom R' (TrivSqZeroExt R' M) A\n⊢ Eq (↑(TrivSqZeroExt.liftEquivOfComm.symm a✝)) (a✝.toLinearMap.comp (↑R' (TrivSqZeroExt.inrHom R' M)))","decl":"/-- A simplified version of `TrivSqZeroExt.liftEquiv` for the commutative case. -/\n@[simps! apply symm_apply_coe]\ndef liftEquivOfComm :\n    { f : M →ₗ[R'] A // ∀ x y, f x * f y = 0 } ≃ (tsze R' M →ₐ[R'] A) := by\n  refine Equiv.trans ?_ liftEquiv\n  exact {\n    toFun := fun f => ⟨(Algebra.ofId _ _, f.val), f.prop,\n      fun r x => by simp [Algebra.smul_def, Algebra.ofId_apply],\n      fun r x => by simp [Algebra.smul_def, Algebra.ofId_apply, Algebra.commutes]⟩\n    invFun := fun fg => ⟨fg.val.2, fg.prop.1⟩\n    left_inv := fun f => rfl\n    right_inv := fun fg => Subtype.ext <|\n      Prod.ext (AlgHom.toLinearMap_injective <| LinearMap.ext_ring <| by simp)\n      rfl }\n\n"}
{"name":"TrivSqZeroExt.map_inl","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R' : Type u\nM : Type v\ninst✝⁸ : CommSemiring R'\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R' M\ninst✝⁵ : Module (MulOpposite R') M\ninst✝⁴ : IsCentralScalar R' M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R' N\ninst✝¹ : Module (MulOpposite R') N\ninst✝ : IsCentralScalar R' N\nf : LinearMap (RingHom.id R') M N\nr : R'\n⊢ Eq ((TrivSqZeroExt.map f) (TrivSqZeroExt.inl r)) (TrivSqZeroExt.inl r)","decl":"@[simp]\ntheorem map_inl (f : M →ₗ[R'] N) (r : R') : map f (inl r) = inl r := by\n  rw [map, liftEquivOfComm_apply, lift_apply_inl, Algebra.ofId_apply, algebraMap_eq_inl]\n\n"}
{"name":"TrivSqZeroExt.map_inr","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R' : Type u\nM : Type v\ninst✝⁸ : CommSemiring R'\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R' M\ninst✝⁵ : Module (MulOpposite R') M\ninst✝⁴ : IsCentralScalar R' M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R' N\ninst✝¹ : Module (MulOpposite R') N\ninst✝ : IsCentralScalar R' N\nf : LinearMap (RingHom.id R') M N\nx : M\n⊢ Eq ((TrivSqZeroExt.map f) (TrivSqZeroExt.inr x)) (TrivSqZeroExt.inr (f x))","decl":"@[simp]\ntheorem map_inr (f : M →ₗ[R'] N) (x : M) : map f (inr x) = inr (f x) := by\n  rw [map, liftEquivOfComm_apply, lift_apply_inr, LinearMap.comp_apply, inrHom_apply]\n\n"}
{"name":"TrivSqZeroExt.fst_map","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R' : Type u\nM : Type v\ninst✝⁸ : CommSemiring R'\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R' M\ninst✝⁵ : Module (MulOpposite R') M\ninst✝⁴ : IsCentralScalar R' M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R' N\ninst✝¹ : Module (MulOpposite R') N\ninst✝ : IsCentralScalar R' N\nf : LinearMap (RingHom.id R') M N\nx : TrivSqZeroExt R' M\n⊢ Eq ((TrivSqZeroExt.map f) x).fst x.fst","decl":"@[simp]\ntheorem fst_map (f : M →ₗ[R'] N) (x : TrivSqZeroExt R' M) : fst (map f x) = fst x := by\n  simp [map, lift_def, Algebra.ofId_apply, algebraMap_eq_inl]\n\n"}
{"name":"TrivSqZeroExt.snd_map","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R' : Type u\nM : Type v\ninst✝⁸ : CommSemiring R'\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R' M\ninst✝⁵ : Module (MulOpposite R') M\ninst✝⁴ : IsCentralScalar R' M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R' N\ninst✝¹ : Module (MulOpposite R') N\ninst✝ : IsCentralScalar R' N\nf : LinearMap (RingHom.id R') M N\nx : TrivSqZeroExt R' M\n⊢ Eq ((TrivSqZeroExt.map f) x).snd (f x.snd)","decl":"@[simp]\ntheorem snd_map (f : M →ₗ[R'] N) (x : TrivSqZeroExt R' M) : snd (map f x) = f (snd x) := by\n  simp [map, lift_def, Algebra.ofId_apply, algebraMap_eq_inl]\n\n"}
{"name":"TrivSqZeroExt.map_comp_inlAlgHom","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R' : Type u\nM : Type v\ninst✝⁸ : CommSemiring R'\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R' M\ninst✝⁵ : Module (MulOpposite R') M\ninst✝⁴ : IsCentralScalar R' M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R' N\ninst✝¹ : Module (MulOpposite R') N\ninst✝ : IsCentralScalar R' N\nf : LinearMap (RingHom.id R') M N\n⊢ Eq ((TrivSqZeroExt.map f).comp (TrivSqZeroExt.inlAlgHom R' R' M)) (TrivSqZeroExt.inlAlgHom R' R' N)","decl":"@[simp]\ntheorem map_comp_inlAlgHom (f : M →ₗ[R'] N) :\n    (map f).comp (inlAlgHom R' R' M) = inlAlgHom R' R' N :=\n  AlgHom.ext <| map_inl _\n\n"}
{"name":"TrivSqZeroExt.map_comp_inrHom","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R' : Type u\nM : Type v\ninst✝⁸ : CommSemiring R'\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R' M\ninst✝⁵ : Module (MulOpposite R') M\ninst✝⁴ : IsCentralScalar R' M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R' N\ninst✝¹ : Module (MulOpposite R') N\ninst✝ : IsCentralScalar R' N\nf : LinearMap (RingHom.id R') M N\n⊢ Eq ((TrivSqZeroExt.map f).toLinearMap.comp (TrivSqZeroExt.inrHom R' M)) ((TrivSqZeroExt.inrHom R' N).comp f)","decl":"@[simp]\ntheorem map_comp_inrHom (f : M →ₗ[R'] N) :\n    (map f).toLinearMap ∘ₗ inrHom R' M = inrHom R' N ∘ₗ f :=\n  LinearMap.ext <| map_inr _\n\n"}
{"name":"TrivSqZeroExt.fstHom_comp_map","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R' : Type u\nM : Type v\ninst✝⁸ : CommSemiring R'\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R' M\ninst✝⁵ : Module (MulOpposite R') M\ninst✝⁴ : IsCentralScalar R' M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R' N\ninst✝¹ : Module (MulOpposite R') N\ninst✝ : IsCentralScalar R' N\nf : LinearMap (RingHom.id R') M N\n⊢ Eq ((TrivSqZeroExt.fstHom R' R' N).comp (TrivSqZeroExt.map f)) (TrivSqZeroExt.fstHom R' R' M)","decl":"@[simp]\ntheorem fstHom_comp_map (f : M →ₗ[R'] N) :\n    (fstHom R' R' N).comp (map f) = fstHom R' R' M :=\n  AlgHom.ext <| fst_map _\n\n"}
{"name":"TrivSqZeroExt.sndHom_comp_map","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R' : Type u\nM : Type v\ninst✝⁸ : CommSemiring R'\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R' M\ninst✝⁵ : Module (MulOpposite R') M\ninst✝⁴ : IsCentralScalar R' M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R' N\ninst✝¹ : Module (MulOpposite R') N\ninst✝ : IsCentralScalar R' N\nf : LinearMap (RingHom.id R') M N\n⊢ Eq ((TrivSqZeroExt.sndHom R' N).comp (TrivSqZeroExt.map f).toLinearMap) (f.comp (TrivSqZeroExt.sndHom R' M))","decl":"@[simp]\ntheorem sndHom_comp_map (f : M →ₗ[R'] N) :\n    sndHom R' N ∘ₗ (map f).toLinearMap = f ∘ₗ sndHom R' M :=\n  LinearMap.ext <| snd_map _\n\n"}
{"name":"TrivSqZeroExt.map_id","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R' : Type u\nM : Type v\ninst✝⁴ : CommSemiring R'\ninst✝³ : AddCommMonoid M\ninst✝² : Module R' M\ninst✝¹ : Module (MulOpposite R') M\ninst✝ : IsCentralScalar R' M\n⊢ Eq (TrivSqZeroExt.map LinearMap.id) (AlgHom.id R' (TrivSqZeroExt R' M))","decl":"@[simp]\ntheorem map_id : map (LinearMap.id : M →ₗ[R'] M) = AlgHom.id R' _ := by\n  apply algHom_ext\n  simp only [map_inr, LinearMap.id_coe, id_eq, AlgHom.coe_id, forall_const]\n\n"}
{"name":"TrivSqZeroExt.map_comp_map","module":"Mathlib.Algebra.TrivSqZeroExt","initialProofState":"R' : Type u\nM : Type v\ninst✝¹² : CommSemiring R'\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : Module R' M\ninst✝⁹ : Module (MulOpposite R') M\ninst✝⁸ : IsCentralScalar R' M\nN : Type u_3\nP : Type u_4\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R' N\ninst✝⁵ : Module (MulOpposite R') N\ninst✝⁴ : IsCentralScalar R' N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R' P\ninst✝¹ : Module (MulOpposite R') P\ninst✝ : IsCentralScalar R' P\nf : LinearMap (RingHom.id R') M N\ng : LinearMap (RingHom.id R') N P\n⊢ Eq (TrivSqZeroExt.map (g.comp f)) ((TrivSqZeroExt.map g).comp (TrivSqZeroExt.map f))","decl":"theorem map_comp_map (f : M →ₗ[R'] N) (g : N →ₗ[R'] P) :\n    map (g.comp f) = (map g).comp (map f) := by\n  apply algHom_ext\n  simp only [map_inr, LinearMap.coe_comp, Function.comp_apply, AlgHom.coe_comp, forall_const]\n\n"}
