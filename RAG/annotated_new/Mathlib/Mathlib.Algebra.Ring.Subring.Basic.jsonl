{"name":"Subring.toSubsemiring_strictMono","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ StrictMono Subring.toSubsemiring","decl":"@[mono]\ntheorem toSubsemiring_strictMono : StrictMono (toSubsemiring : Subring R → Subsemiring R) :=\n  fun _ _ => id\n\n"}
{"name":"Subring.toSubsemiring_mono","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ Monotone Subring.toSubsemiring","decl":"@[mono]\ntheorem toSubsemiring_mono : Monotone (toSubsemiring : Subring R → Subsemiring R) :=\n  toSubsemiring_strictMono.monotone\n\n"}
{"name":"Subring.toSubsemiring_lt_toSubsemiring","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns t : Subring R\nhst : LT.lt s t\n⊢ LT.lt s.toSubsemiring t.toSubsemiring","decl":"@[gcongr]\nlemma toSubsemiring_lt_toSubsemiring (hst : s < t) : s.toSubsemiring < t.toSubsemiring := hst\n\n"}
{"name":"Subring.toSubsemiring_le_toSubsemiring","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns t : Subring R\nhst : LE.le s t\n⊢ LE.le s.toSubsemiring t.toSubsemiring","decl":"@[gcongr]\nlemma toSubsemiring_le_toSubsemiring (hst : s ≤ t) : s.toSubsemiring ≤ t.toSubsemiring := hst\n\n"}
{"name":"Subring.toAddSubgroup_strictMono","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ StrictMono Subring.toAddSubgroup","decl":"@[mono]\ntheorem toAddSubgroup_strictMono : StrictMono (toAddSubgroup : Subring R → AddSubgroup R) :=\n  fun _ _ => id\n\n"}
{"name":"Subring.toAddSubgroup_mono","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ Monotone Subring.toAddSubgroup","decl":"@[mono]\ntheorem toAddSubgroup_mono : Monotone (toAddSubgroup : Subring R → AddSubgroup R) :=\n  toAddSubgroup_strictMono.monotone\n\n"}
{"name":"Subring.toAddSubgroup_lt_toAddSubgroup","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns t : Subring R\nhst : LT.lt s t\n⊢ LT.lt s.toAddSubgroup t.toAddSubgroup","decl":"@[gcongr]\nlemma toAddSubgroup_lt_toAddSubgroup (hst : s < t) : s.toAddSubgroup < t.toAddSubgroup := hst\n\n"}
{"name":"Subring.toAddSubgroup_le_toAddSubgroup","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns t : Subring R\nhst : LE.le s t\n⊢ LE.le s.toAddSubgroup t.toAddSubgroup","decl":"@[gcongr]\nlemma toAddSubgroup_le_toAddSubgroup (hst : s ≤ t) : s.toAddSubgroup ≤ t.toAddSubgroup := hst\n\n"}
{"name":"Subring.toSubmonoid_strictMono","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ StrictMono fun s => s.toSubmonoid","decl":"@[mono]\ntheorem toSubmonoid_strictMono : StrictMono (fun s : Subring R => s.toSubmonoid) := fun _ _ => id\n\n"}
{"name":"Subring.toSubmonoid_mono","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ Monotone fun s => s.toSubmonoid","decl":"@[mono]\ntheorem toSubmonoid_mono : Monotone (fun s : Subring R => s.toSubmonoid) :=\n  toSubmonoid_strictMono.monotone\n\n"}
{"name":"Subring.list_prod_mem","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\nl : List R\na✝ : ∀ (x : R), Membership.mem l x → Membership.mem s x\n⊢ Membership.mem s l.prod","decl":"/-- Product of a list of elements in a subring is in the subring. -/\nprotected theorem list_prod_mem {l : List R} : (∀ x ∈ l, x ∈ s) → l.prod ∈ s :=\n  list_prod_mem\n\n"}
{"name":"Subring.list_sum_mem","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\nl : List R\na✝ : ∀ (x : R), Membership.mem l x → Membership.mem s x\n⊢ Membership.mem s l.sum","decl":"/-- Sum of a list of elements in a subring is in the subring. -/\nprotected theorem list_sum_mem {l : List R} : (∀ x ∈ l, x ∈ s) → l.sum ∈ s :=\n  list_sum_mem\n\n"}
{"name":"Subring.multiset_prod_mem","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\ns : Subring R\nm : Multiset R\na✝ : ∀ (a : R), Membership.mem m a → Membership.mem s a\n⊢ Membership.mem s m.prod","decl":"/-- Product of a multiset of elements in a subring of a `CommRing` is in the subring. -/\nprotected theorem multiset_prod_mem {R} [CommRing R] (s : Subring R) (m : Multiset R) :\n    (∀ a ∈ m, a ∈ s) → m.prod ∈ s :=\n  multiset_prod_mem _\n\n"}
{"name":"Subring.multiset_sum_mem","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\ns : Subring R\nm : Multiset R\na✝ : ∀ (a : R), Membership.mem m a → Membership.mem s a\n⊢ Membership.mem s m.sum","decl":"/-- Sum of a multiset of elements in a `Subring` of a `Ring` is\nin the `Subring`. -/\nprotected theorem multiset_sum_mem {R} [Ring R] (s : Subring R) (m : Multiset R) :\n    (∀ a ∈ m, a ∈ s) → m.sum ∈ s :=\n  multiset_sum_mem _\n\n"}
{"name":"Subring.prod_mem","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\ns : Subring R\nι : Type u_2\nt : Finset ι\nf : ι → R\nh : ∀ (c : ι), Membership.mem t c → Membership.mem s (f c)\n⊢ Membership.mem s (t.prod fun i => f i)","decl":"/-- Product of elements of a subring of a `CommRing` indexed by a `Finset` is in the\n    subring. -/\nprotected theorem prod_mem {R : Type*} [CommRing R] (s : Subring R) {ι : Type*} {t : Finset ι}\n    {f : ι → R} (h : ∀ c ∈ t, f c ∈ s) : (∏ i ∈ t, f i) ∈ s :=\n  prod_mem h\n\n"}
{"name":"Subring.sum_mem","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\ns : Subring R\nι : Type u_2\nt : Finset ι\nf : ι → R\nh : ∀ (c : ι), Membership.mem t c → Membership.mem s (f c)\n⊢ Membership.mem s (t.sum fun i => f i)","decl":"/-- Sum of elements in a `Subring` of a `Ring` indexed by a `Finset`\nis in the `Subring`. -/\nprotected theorem sum_mem {R : Type*} [Ring R] (s : Subring R) {ι : Type*} {t : Finset ι}\n    {f : ι → R} (h : ∀ c ∈ t, f c ∈ s) : (∑ i ∈ t, f i) ∈ s :=\n  sum_mem h\n\n"}
{"name":"Subring.mem_top","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nx : R\n⊢ Membership.mem Top.top x","decl":"@[simp]\ntheorem mem_top (x : R) : x ∈ (⊤ : Subring R) :=\n  Set.mem_univ x\n\n"}
{"name":"Subring.coe_top","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ Eq (↑Top.top) Set.univ","decl":"@[simp]\ntheorem coe_top : ((⊤ : Subring R) : Set R) = Set.univ :=\n  rfl\n\n"}
{"name":"Subring.topEquiv_apply","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nr : Subtype fun x => Membership.mem Top.top x\n⊢ Eq (Subring.topEquiv r) ↑r","decl":"/-- The ring equiv between the top element of `Subring R` and `R`. -/\n@[simps!]\ndef topEquiv : (⊤ : Subring R) ≃+* R :=\n  Subsemiring.topEquiv\n\n"}
{"name":"Subring.topEquiv_symm_apply_coe","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nr : R\n⊢ Eq (↑(Subring.topEquiv.symm r)) r","decl":"/-- The ring equiv between the top element of `Subring R` and `R`. -/\n@[simps!]\ndef topEquiv : (⊤ : Subring R) ≃+* R :=\n  Subsemiring.topEquiv\n\n"}
{"name":"Subring.card_top","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : Fintype R\n⊢ Eq (Fintype.card (Subtype fun x => Membership.mem Top.top x)) (Fintype.card R)","decl":"theorem card_top (R) [Ring R] [Fintype R] : Fintype.card (⊤ : Subring R) = Fintype.card R :=\n  Fintype.card_congr topEquiv.toEquiv\n\n"}
{"name":"Subring.coe_comap","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\ns : Subring S\nf : RingHom R S\n⊢ Eq (↑(Subring.comap f s)) (Set.preimage ⇑f ↑s)","decl":"@[simp]\ntheorem coe_comap (s : Subring S) (f : R →+* S) : (s.comap f : Set R) = f ⁻¹' s :=\n  rfl\n\n"}
{"name":"Subring.mem_comap","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\ns : Subring S\nf : RingHom R S\nx : R\n⊢ Iff (Membership.mem (Subring.comap f s) x) (Membership.mem s (f x))","decl":"@[simp]\ntheorem mem_comap {s : Subring S} {f : R →+* S} {x : R} : x ∈ s.comap f ↔ f x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Subring.comap_comap","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\nT : Type w\ninst✝² : Ring R\ninst✝¹ : Ring S\ninst✝ : Ring T\ns : Subring T\ng : RingHom S T\nf : RingHom R S\n⊢ Eq (Subring.comap f (Subring.comap g s)) (Subring.comap (g.comp f) s)","decl":"theorem comap_comap (s : Subring T) (g : S →+* T) (f : R →+* S) :\n    (s.comap g).comap f = s.comap (g.comp f) :=\n  rfl\n\n"}
{"name":"Subring.coe_map","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\ns : Subring R\n⊢ Eq (↑(Subring.map f s)) (Set.image ⇑f ↑s)","decl":"@[simp]\ntheorem coe_map (f : R →+* S) (s : Subring R) : (s.map f : Set S) = f '' s :=\n  rfl\n\n"}
{"name":"Subring.mem_map","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\ns : Subring R\ny : S\n⊢ Iff (Membership.mem (Subring.map f s) y) (Exists fun x => And (Membership.mem s x) (Eq (f x) y))","decl":"@[simp]\ntheorem mem_map {f : R →+* S} {s : Subring R} {y : S} : y ∈ s.map f ↔ ∃ x ∈ s, f x = y := Iff.rfl\n\n"}
{"name":"Subring.map_id","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\n⊢ Eq (Subring.map (RingHom.id R) s) s","decl":"@[simp]\ntheorem map_id : s.map (RingHom.id R) = s :=\n  SetLike.coe_injective <| Set.image_id _\n\n"}
{"name":"Subring.map_map","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\nT : Type w\ninst✝² : Ring R\ninst✝¹ : Ring S\ninst✝ : Ring T\ns : Subring R\ng : RingHom S T\nf : RingHom R S\n⊢ Eq (Subring.map g (Subring.map f s)) (Subring.map (g.comp f) s)","decl":"theorem map_map (g : S →+* T) (f : R →+* S) : (s.map f).map g = s.map (g.comp f) :=\n  SetLike.coe_injective <| Set.image_image _ _ _\n\n"}
{"name":"Subring.map_le_iff_le_comap","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\ns : Subring R\nt : Subring S\n⊢ Iff (LE.le (Subring.map f s) t) (LE.le s (Subring.comap f t))","decl":"theorem map_le_iff_le_comap {f : R →+* S} {s : Subring R} {t : Subring S} :\n    s.map f ≤ t ↔ s ≤ t.comap f :=\n  Set.image_subset_iff\n\n"}
{"name":"Subring.gc_map_comap","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\n⊢ GaloisConnection (Subring.map f) (Subring.comap f)","decl":"theorem gc_map_comap (f : R →+* S) : GaloisConnection (map f) (comap f) := fun _ _ =>\n  map_le_iff_le_comap\n\n"}
{"name":"Subring.coe_equivMapOfInjective_apply","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\ns : Subring R\nf : RingHom R S\nhf : Function.Injective ⇑f\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (↑((s.equivMapOfInjective f hf) x)) (f ↑x)","decl":"@[simp]\ntheorem coe_equivMapOfInjective_apply (f : R →+* S) (hf : Function.Injective f) (x : s) :\n    (equivMapOfInjective s f hf x : S) = f x :=\n  rfl\n\n"}
{"name":"RingHom.coe_range","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\n⊢ Eq (↑f.range) (Set.range ⇑f)","decl":"@[simp]\ntheorem coe_range : (f.range : Set S) = Set.range f :=\n  rfl\n\n"}
{"name":"RingHom.mem_range","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\ny : S\n⊢ Iff (Membership.mem f.range y) (Exists fun x => Eq (f x) y)","decl":"@[simp]\ntheorem mem_range {f : R →+* S} {y : S} : y ∈ f.range ↔ ∃ x, f x = y :=\n  Iff.rfl\n\n"}
{"name":"RingHom.range_eq_map","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\n⊢ Eq f.range (Subring.map f Top.top)","decl":"theorem range_eq_map (f : R →+* S) : f.range = Subring.map f ⊤ := by\n  ext\n  simp\n\n"}
{"name":"RingHom.mem_range_self","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\nx : R\n⊢ Membership.mem f.range (f x)","decl":"theorem mem_range_self (f : R →+* S) (x : R) : f x ∈ f.range :=\n  mem_range.mpr ⟨x, rfl⟩\n\n"}
{"name":"RingHom.map_range","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\nT : Type w\ninst✝² : Ring R\ninst✝¹ : Ring S\ninst✝ : Ring T\ng : RingHom S T\nf : RingHom R S\n⊢ Eq (Subring.map g f.range) (g.comp f).range","decl":"theorem map_range : f.range.map g = (g.comp f).range := by\n  simpa only [range_eq_map] using (⊤ : Subring R).map_map g f\n\n"}
{"name":"Subring.coe_bot","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ Eq (↑Bot.bot) (Set.range Int.cast)","decl":"theorem coe_bot : ((⊥ : Subring R) : Set R) = Set.range ((↑) : ℤ → R) :=\n  RingHom.coe_range (Int.castRingHom R)\n\n"}
{"name":"Subring.mem_bot","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nx : R\n⊢ Iff (Membership.mem Bot.bot x) (Exists fun n => Eq (↑n) x)","decl":"theorem mem_bot {x : R} : x ∈ (⊥ : Subring R) ↔ ∃ n : ℤ, ↑n = x :=\n  RingHom.mem_range\n\n"}
{"name":"Subring.coe_inf","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\np p' : Subring R\n⊢ Eq (↑(Min.min p p')) (Inter.inter ↑p ↑p')","decl":"@[simp]\ntheorem coe_inf (p p' : Subring R) : ((p ⊓ p' : Subring R) : Set R) = (p : Set R) ∩ p' :=\n  rfl\n\n"}
{"name":"Subring.mem_inf","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\np p' : Subring R\nx : R\n⊢ Iff (Membership.mem (Min.min p p') x) (And (Membership.mem p x) (Membership.mem p' x))","decl":"@[simp]\ntheorem mem_inf {p p' : Subring R} {x : R} : x ∈ p ⊓ p' ↔ x ∈ p ∧ x ∈ p' :=\n  Iff.rfl\n\n"}
{"name":"Subring.coe_sInf","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nS : Set (Subring R)\n⊢ Eq (↑(InfSet.sInf S)) (Set.iInter fun s => Set.iInter fun h => ↑s)","decl":"@[simp, norm_cast]\ntheorem coe_sInf (S : Set (Subring R)) : ((sInf S : Subring R) : Set R) = ⋂ s ∈ S, ↑s :=\n  rfl\n\n"}
{"name":"Subring.mem_sInf","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nS : Set (Subring R)\nx : R\n⊢ Iff (Membership.mem (InfSet.sInf S) x) (∀ (p : Subring R), Membership.mem S p → Membership.mem p x)","decl":"theorem mem_sInf {S : Set (Subring R)} {x : R} : x ∈ sInf S ↔ ∀ p ∈ S, x ∈ p :=\n  Set.mem_iInter₂\n\n"}
{"name":"Subring.coe_iInf","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nι : Sort u_1\nS : ι → Subring R\n⊢ Eq (↑(iInf fun i => S i)) (Set.iInter fun i => ↑(S i))","decl":"@[simp, norm_cast]\ntheorem coe_iInf {ι : Sort*} {S : ι → Subring R} : (↑(⨅ i, S i) : Set R) = ⋂ i, S i := by\n  simp only [iInf, coe_sInf, Set.biInter_range]\n\n"}
{"name":"Subring.mem_iInf","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nι : Sort u_1\nS : ι → Subring R\nx : R\n⊢ Iff (Membership.mem (iInf fun i => S i) x) (∀ (i : ι), Membership.mem (S i) x)","decl":"theorem mem_iInf {ι : Sort*} {S : ι → Subring R} {x : R} : (x ∈ ⨅ i, S i) ↔ ∀ i, x ∈ S i := by\n  simp only [iInf, mem_sInf, Set.forall_mem_range]\n\n"}
{"name":"Subring.sInf_toSubmonoid","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set (Subring R)\n⊢ Eq (InfSet.sInf s).toSubmonoid (iInf fun t => iInf fun h => t.toSubmonoid)","decl":"@[simp]\ntheorem sInf_toSubmonoid (s : Set (Subring R)) :\n    (sInf s).toSubmonoid = ⨅ t ∈ s, t.toSubmonoid :=\n  mk'_toSubmonoid _ _\n\n"}
{"name":"Subring.sInf_toAddSubgroup","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set (Subring R)\n⊢ Eq (InfSet.sInf s).toAddSubgroup (iInf fun t => iInf fun h => t.toAddSubgroup)","decl":"@[simp]\ntheorem sInf_toAddSubgroup (s : Set (Subring R)) :\n    (sInf s).toAddSubgroup = ⨅ t ∈ s, Subring.toAddSubgroup t :=\n  mk'_toAddSubgroup _ _\n\n"}
{"name":"Subring.eq_top_iff'","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nA : Subring R\n⊢ Iff (Eq A Top.top) (∀ (x : R), Membership.mem A x)","decl":"theorem eq_top_iff' (A : Subring R) : A = ⊤ ↔ ∀ x : R, x ∈ A :=\n  eq_top_iff.trans ⟨fun h m => h <| mem_top m, fun h m _ => h m⟩\n\n"}
{"name":"Subring.coe_center","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ Eq (↑(Subring.center R)) (Set.center R)","decl":"theorem coe_center : ↑(center R) = Set.center R :=\n  rfl\n\n"}
{"name":"Subring.center_toSubsemiring","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ Eq (Subring.center R).toSubsemiring (Subsemiring.center R)","decl":"@[simp]\ntheorem center_toSubsemiring : (center R).toSubsemiring = Subsemiring.center R :=\n  rfl\n\n"}
{"name":"Subring.mem_center_iff","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nz : R\n⊢ Iff (Membership.mem (Subring.center R) z) (∀ (g : R), Eq (HMul.hMul g z) (HMul.hMul z g))","decl":"theorem mem_center_iff {z : R} : z ∈ center R ↔ ∀ g, g * z = z * g :=\n  Subsemigroup.mem_center_iff\n\n"}
{"name":"Subring.center_eq_top","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Subring.center R) Top.top","decl":"@[simp]\ntheorem center_eq_top (R) [CommRing R] : center R = ⊤ :=\n  SetLike.coe_injective (Set.center_eq_univ R)\n\n"}
{"name":"Subring.centerCongr_apply_coe","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\ne : RingEquiv R S\nr : Subtype fun x => Membership.mem (Subsemigroup.center R) x\n⊢ Eq (↑((Subring.centerCongr e) r)) (e ↑r)","decl":"/-- The center of isomorphic (not necessarily associative) rings are isomorphic. -/\n@[simps!] def centerCongr (e : R ≃+* S) : center R ≃+* center S :=\n  NonUnitalSubsemiring.centerCongr e\n\n"}
{"name":"Subring.centerCongr_symm_apply_coe","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\ne : RingEquiv R S\ns : Subtype fun x => Membership.mem (Subsemigroup.center S) x\n⊢ Eq (↑((Subring.centerCongr e).symm s)) ((↑e).symm ↑s)","decl":"/-- The center of isomorphic (not necessarily associative) rings are isomorphic. -/\n@[simps!] def centerCongr (e : R ≃+* S) : center R ≃+* center S :=\n  NonUnitalSubsemiring.centerCongr e\n\n"}
{"name":"Subring.centerToMulOpposite_apply_coe","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nr : Subtype fun x => Membership.mem (Subsemigroup.center R) x\n⊢ Eq (↑(Subring.centerToMulOpposite r)) (MulOpposite.op ↑r)","decl":"/-- The center of a (not necessarily associative) ring\nis isomorphic to the center of its opposite. -/\n@[simps!] def centerToMulOpposite : center R ≃+* center Rᵐᵒᵖ :=\n  NonUnitalSubsemiring.centerToMulOpposite\n\n"}
{"name":"Subring.centerToMulOpposite_symm_apply_coe","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nr : Subtype fun x => Membership.mem (Subsemigroup.center (MulOpposite R)) x\n⊢ Eq (↑(Subring.centerToMulOpposite.symm r)) (MulOpposite.unop ↑r)","decl":"/-- The center of a (not necessarily associative) ring\nis isomorphic to the center of its opposite. -/\n@[simps!] def centerToMulOpposite : center R ≃+* center Rᵐᵒᵖ :=\n  NonUnitalSubsemiring.centerToMulOpposite\n\n"}
{"name":"Subring.center.coe_inv","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\na : Subtype fun x => Membership.mem (Subring.center K) x\n⊢ Eq (↑(Inv.inv a)) (Inv.inv ↑a)","decl":"@[simp]\ntheorem center.coe_inv (a : center K) : ((a⁻¹ : center K) : K) = (a : K)⁻¹ :=\n  rfl\n\n"}
{"name":"Subring.center.coe_div","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\na b : Subtype fun x => Membership.mem (Subring.center K) x\n⊢ Eq (↑(HDiv.hDiv a b)) (HDiv.hDiv ↑a ↑b)","decl":"@[simp]\ntheorem center.coe_div (a b : center K) : ((a / b : center K) : K) = (a : K) / (b : K) :=\n  rfl\n\n"}
{"name":"Subring.coe_centralizer","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set R\n⊢ Eq (↑(Subring.centralizer s)) s.centralizer","decl":"@[simp, norm_cast]\ntheorem coe_centralizer (s : Set R) : (centralizer s : Set R) = s.centralizer :=\n  rfl\n\n"}
{"name":"Subring.centralizer_toSubmonoid","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set R\n⊢ Eq (Subring.centralizer s).toSubmonoid (Submonoid.centralizer s)","decl":"theorem centralizer_toSubmonoid (s : Set R) :\n    (centralizer s).toSubmonoid = Submonoid.centralizer s :=\n  rfl\n\n"}
{"name":"Subring.centralizer_toSubsemiring","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set R\n⊢ Eq (Subring.centralizer s).toSubsemiring (Subsemiring.centralizer s)","decl":"theorem centralizer_toSubsemiring (s : Set R) :\n    (centralizer s).toSubsemiring = Subsemiring.centralizer s :=\n  rfl\n\n"}
{"name":"Subring.mem_centralizer_iff","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set R\nz : R\n⊢ Iff (Membership.mem (Subring.centralizer s) z) (∀ (g : R), Membership.mem s g → Eq (HMul.hMul g z) (HMul.hMul z g))","decl":"theorem mem_centralizer_iff {s : Set R} {z : R} : z ∈ centralizer s ↔ ∀ g ∈ s, g * z = z * g :=\n  Iff.rfl\n\n"}
{"name":"Subring.center_le_centralizer","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set R\n⊢ LE.le (Subring.center R) (Subring.centralizer s)","decl":"theorem center_le_centralizer (s) : center R ≤ centralizer s :=\n  s.center_subset_centralizer\n\n"}
{"name":"Subring.centralizer_le","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns t : Set R\nh : HasSubset.Subset s t\n⊢ LE.le (Subring.centralizer t) (Subring.centralizer s)","decl":"theorem centralizer_le (s t : Set R) (h : s ⊆ t) : centralizer t ≤ centralizer s :=\n  Set.centralizer_subset h\n\n"}
{"name":"Subring.centralizer_eq_top_iff_subset","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set R\n⊢ Iff (Eq (Subring.centralizer s) Top.top) (HasSubset.Subset s ↑(Subring.center R))","decl":"@[simp]\ntheorem centralizer_eq_top_iff_subset {s : Set R} : centralizer s = ⊤ ↔ s ⊆ center R :=\n  SetLike.ext'_iff.trans Set.centralizer_eq_top_iff_subset\n\n"}
{"name":"Subring.centralizer_univ","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ Eq (Subring.centralizer Set.univ) (Subring.center R)","decl":"@[simp]\ntheorem centralizer_univ : centralizer Set.univ = center R :=\n  SetLike.ext' (Set.centralizer_univ R)\n\n"}
{"name":"Subring.mem_closure","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nx : R\ns : Set R\n⊢ Iff (Membership.mem (Subring.closure s) x) (∀ (S : Subring R), HasSubset.Subset s ↑S → Membership.mem S x)","decl":"theorem mem_closure {x : R} {s : Set R} : x ∈ closure s ↔ ∀ S : Subring R, s ⊆ S → x ∈ S :=\n  mem_sInf\n\n"}
{"name":"Subring.subset_closure","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set R\n⊢ HasSubset.Subset s ↑(Subring.closure s)","decl":"/-- The subring generated by a set includes the set. -/\n@[simp, aesop safe 20 apply (rule_sets := [SetLike])]\ntheorem subset_closure {s : Set R} : s ⊆ closure s := fun _ hx => mem_closure.2 fun _ hS => hS hx\n\n"}
{"name":"Subring.not_mem_of_not_mem_closure","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set R\nP : R\nhP : Not (Membership.mem (Subring.closure s) P)\n⊢ Not (Membership.mem s P)","decl":"theorem not_mem_of_not_mem_closure {s : Set R} {P : R} (hP : P ∉ closure s) : P ∉ s := fun h =>\n  hP (subset_closure h)\n\n"}
{"name":"Subring.closure_le","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set R\nt : Subring R\n⊢ Iff (LE.le (Subring.closure s) t) (HasSubset.Subset s ↑t)","decl":"/-- A subring `t` includes `closure s` if and only if it includes `s`. -/\n@[simp]\ntheorem closure_le {s : Set R} {t : Subring R} : closure s ≤ t ↔ s ⊆ t :=\n  ⟨Set.Subset.trans subset_closure, fun h => sInf_le h⟩\n\n"}
{"name":"Subring.closure_mono","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns t : Set R\nh : HasSubset.Subset s t\n⊢ LE.le (Subring.closure s) (Subring.closure t)","decl":"/-- Subring closure of a set is monotone in its argument: if `s ⊆ t`,\nthen `closure s ≤ closure t`. -/\n@[gcongr]\ntheorem closure_mono ⦃s t : Set R⦄ (h : s ⊆ t) : closure s ≤ closure t :=\n  closure_le.2 <| Set.Subset.trans h subset_closure\n\n"}
{"name":"Subring.closure_eq_of_le","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set R\nt : Subring R\nh₁ : HasSubset.Subset s ↑t\nh₂ : LE.le t (Subring.closure s)\n⊢ Eq (Subring.closure s) t","decl":"theorem closure_eq_of_le {s : Set R} {t : Subring R} (h₁ : s ⊆ t) (h₂ : t ≤ closure s) :\n    closure s = t :=\n  le_antisymm (closure_le.2 h₁) h₂\n\n"}
{"name":"Subring.closure_induction","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set R\np : (x : R) → Membership.mem (Subring.closure s) x → Prop\nmem : ∀ (x : R) (hx : Membership.mem s x), p x ⋯\nzero : p 0 ⋯\none : p 1 ⋯\nadd : ∀ (x y : R) (hx : Membership.mem (Subring.closure s) x) (hy : Membership.mem (Subring.closure s) y), p x hx → p y hy → p (HAdd.hAdd x y) ⋯\nneg : ∀ (x : R) (hx : Membership.mem (Subring.closure s) x), p x hx → p (Neg.neg x) ⋯\nmul : ∀ (x y : R) (hx : Membership.mem (Subring.closure s) x) (hy : Membership.mem (Subring.closure s) y), p x hx → p y hy → p (HMul.hMul x y) ⋯\nx : R\nhx : Membership.mem (Subring.closure s) x\n⊢ p x hx","decl":"/-- An induction principle for closure membership. If `p` holds for `0`, `1`, and all elements\nof `s`, and is preserved under addition, negation, and multiplication, then `p` holds for all\nelements of the closure of `s`. -/\n@[elab_as_elim]\ntheorem closure_induction {s : Set R} {p : (x : R) → x ∈ closure s → Prop}\n    (mem : ∀ (x) (hx : x ∈ s), p x (subset_closure hx))\n    (zero : p 0 (zero_mem _)) (one : p 1 (one_mem _))\n    (add : ∀ x y hx hy, p x hx → p y hy → p (x + y) (add_mem hx hy))\n    (neg : ∀ x hx, p x hx → p (-x) (neg_mem hx))\n    (mul : ∀ x y hx hy, p x hx → p y hy → p (x * y) (mul_mem hx hy))\n    {x} (hx : x ∈ closure s)  : p x hx :=\n  let K : Subring R :=\n    { carrier := { x | ∃ hx, p x hx }\n      mul_mem' := fun ⟨_, hpx⟩ ⟨_, hpy⟩ ↦ ⟨_, mul _ _ _ _ hpx hpy⟩\n      add_mem' := fun ⟨_, hpx⟩ ⟨_, hpy⟩ ↦ ⟨_, add _ _ _ _ hpx hpy⟩\n      neg_mem' := fun ⟨_, hpx⟩ ↦ ⟨_, neg _ _ hpx⟩\n      zero_mem' := ⟨_, zero⟩\n      one_mem' := ⟨_, one⟩ }\n  closure_le (t := K) |>.mpr (fun y hy ↦ ⟨subset_closure hy, mem y hy⟩) hx |>.elim fun _ ↦ id\n\n"}
{"name":"Subring.closure_induction'","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set R\np : (x : R) → Membership.mem (Subring.closure s) x → Prop\nmem : ∀ (x : R) (hx : Membership.mem s x), p x ⋯\nzero : p 0 ⋯\none : p 1 ⋯\nadd : ∀ (x y : R) (hx : Membership.mem (Subring.closure s) x) (hy : Membership.mem (Subring.closure s) y), p x hx → p y hy → p (HAdd.hAdd x y) ⋯\nneg : ∀ (x : R) (hx : Membership.mem (Subring.closure s) x), p x hx → p (Neg.neg x) ⋯\nmul : ∀ (x y : R) (hx : Membership.mem (Subring.closure s) x) (hy : Membership.mem (Subring.closure s) y), p x hx → p y hy → p (HMul.hMul x y) ⋯\nx : R\nhx : Membership.mem (Subring.closure s) x\n⊢ p x hx","decl":"@[deprecated closure_induction (since := \"2024-10-10\")]\nalias closure_induction' := closure_induction\n\n"}
{"name":"Subring.closure_induction₂","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set R\np : (x y : R) → Membership.mem (Subring.closure s) x → Membership.mem (Subring.closure s) y → Prop\nmem_mem : ∀ (x y : R) (hx : Membership.mem s x) (hy : Membership.mem s y), p x y ⋯ ⋯\nzero_left : ∀ (x : R) (hx : Membership.mem (Subring.closure s) x), p 0 x ⋯ hx\nzero_right : ∀ (x : R) (hx : Membership.mem (Subring.closure s) x), p x 0 hx ⋯\none_left : ∀ (x : R) (hx : Membership.mem (Subring.closure s) x), p 1 x ⋯ hx\none_right : ∀ (x : R) (hx : Membership.mem (Subring.closure s) x), p x 1 hx ⋯\nneg_left : ∀ (x y : R) (hx : Membership.mem (Subring.closure s) x) (hy : Membership.mem (Subring.closure s) y), p x y hx hy → p (Neg.neg x) y ⋯ hy\nneg_right : ∀ (x y : R) (hx : Membership.mem (Subring.closure s) x) (hy : Membership.mem (Subring.closure s) y), p x y hx hy → p x (Neg.neg y) hx ⋯\nadd_left : ∀ (x y z : R) (hx : Membership.mem (Subring.closure s) x) (hy : Membership.mem (Subring.closure s) y) (hz : Membership.mem (Subring.closure s) z), p x z hx hz → p y z hy hz → p (HAdd.hAdd x y) z ⋯ hz\nadd_right : ∀ (x y z : R) (hx : Membership.mem (Subring.closure s) x) (hy : Membership.mem (Subring.closure s) y) (hz : Membership.mem (Subring.closure s) z), p x y hx hy → p x z hx hz → p x (HAdd.hAdd y z) hx ⋯\nmul_left : ∀ (x y z : R) (hx : Membership.mem (Subring.closure s) x) (hy : Membership.mem (Subring.closure s) y) (hz : Membership.mem (Subring.closure s) z), p x z hx hz → p y z hy hz → p (HMul.hMul x y) z ⋯ hz\nmul_right : ∀ (x y z : R) (hx : Membership.mem (Subring.closure s) x) (hy : Membership.mem (Subring.closure s) y) (hz : Membership.mem (Subring.closure s) z), p x y hx hy → p x z hx hz → p x (HMul.hMul y z) hx ⋯\nx y : R\nhx : Membership.mem (Subring.closure s) x\nhy : Membership.mem (Subring.closure s) y\n⊢ p x y hx hy","decl":"/-- An induction principle for closure membership, for predicates with two arguments. -/\n@[elab_as_elim]\ntheorem closure_induction₂ {s : Set R} {p : (x y : R) → x ∈ closure s → y ∈ closure s → Prop}\n    (mem_mem : ∀ (x) (y) (hx : x ∈ s) (hy : y ∈ s), p x y (subset_closure hx) (subset_closure hy))\n    (zero_left : ∀ x hx, p 0 x (zero_mem _) hx) (zero_right : ∀ x hx, p x 0 hx (zero_mem _))\n    (one_left : ∀ x hx, p 1 x (one_mem _) hx) (one_right : ∀ x hx, p x 1 hx (one_mem _))\n    (neg_left : ∀ x y hx hy, p x y hx hy → p (-x) y (neg_mem hx) hy)\n    (neg_right : ∀ x y hx hy, p x y hx hy → p x (-y) hx (neg_mem hy))\n    (add_left : ∀ x y z hx hy hz, p x z hx hz → p y z hy hz → p (x + y) z (add_mem hx hy) hz)\n    (add_right : ∀ x y z hx hy hz, p x y hx hy → p x z hx hz → p x (y + z) hx (add_mem hy hz))\n    (mul_left : ∀ x y z hx hy hz, p x z hx hz → p y z hy hz → p (x * y) z (mul_mem hx hy) hz)\n    (mul_right : ∀ x y z hx hy hz, p x y hx hy → p x z hx hz → p x (y * z) hx (mul_mem hy hz))\n    {x y : R} (hx : x ∈ closure s) (hy : y ∈ closure s) :\n    p x y hx hy := by\n  induction hy using closure_induction with\n  | mem z hz => induction hx using closure_induction with\n    | mem _ h => exact mem_mem _ _ h hz\n    | zero => exact zero_left _ _\n    | one => exact one_left _ _\n    | mul _ _ _ _ h₁ h₂ => exact mul_left _ _ _ _ _ _ h₁ h₂\n    | add _ _ _ _ h₁ h₂ => exact add_left _ _ _ _ _ _ h₁ h₂\n    | neg _ _ h => exact neg_left _ _ _ _ h\n  | zero => exact zero_right x hx\n  | one => exact one_right x hx\n  | mul _ _ _ _ h₁ h₂ => exact mul_right _ _ _ _ _ _ h₁ h₂\n  | add _ _ _ _ h₁ h₂ => exact add_right _ _ _ _ _ _ h₁ h₂\n  | neg _ _ h => exact neg_right _ _ _ _ h\n\n"}
{"name":"Subring.mem_closure_iff","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set R\nx : R\n⊢ Iff (Membership.mem (Subring.closure s) x) (Membership.mem (AddSubgroup.closure ↑(Submonoid.closure s)) x)","decl":"theorem mem_closure_iff {s : Set R} {x} :\n    x ∈ closure s ↔ x ∈ AddSubgroup.closure (Submonoid.closure s : Set R) :=\n  ⟨fun h => by\n    induction h using closure_induction with\n    | mem _ hx => exact AddSubgroup.subset_closure (Submonoid.subset_closure hx)\n    | zero => exact zero_mem _\n    | one => exact AddSubgroup.subset_closure (one_mem _)\n    | add _ _ _ _ hx hy => exact add_mem hx hy\n    | neg _ _ hx => exact neg_mem hx\n    | mul _ _ _hx _hy hx hy =>\n      clear _hx _hy\n      induction hx, hy using AddSubgroup.closure_induction₂ with\n      | mem _ _ hx hy => exact AddSubgroup.subset_closure (mul_mem hx hy)\n      | one_left => simpa using zero_mem _\n      | one_right => simpa using zero_mem _\n      | mul_left _ _ _ _ _ _ h₁ h₂ => simpa [add_mul] using add_mem h₁ h₂\n      | mul_right _ _ _ _ _ _ h₁ h₂ => simpa [mul_add] using add_mem h₁ h₂\n      | inv_left _ _ _ _ h => simpa [neg_mul] using neg_mem h\n      | inv_right _ _ _ _ h => simpa [mul_neg] using neg_mem h,\n    fun h => by\n      induction h using AddSubgroup.closure_induction with\n      | mem x hx =>\n        induction hx using Submonoid.closure_induction with\n        | mem _ h => exact subset_closure h\n        | one => exact one_mem _\n        | mul _ _ _ _ h₁ h₂ => exact mul_mem h₁ h₂\n      | one => exact zero_mem _\n      | mul _ _ _ _ h₁ h₂ => exact add_mem h₁ h₂\n      | inv _ _ h => exact neg_mem h⟩\n\n"}
{"name":"Subring.closure_le_centralizer_centralizer","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set R\n⊢ LE.le (Subring.closure s) (Subring.centralizer ↑(Subring.centralizer s))","decl":"lemma closure_le_centralizer_centralizer (s : Set R) :\n    closure s ≤ centralizer (centralizer s) :=\n  closure_le.mpr Set.subset_centralizer_centralizer\n\n"}
{"name":"Subring.exists_list_of_mem_closure","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set R\nx : R\nhx : Membership.mem (Subring.closure s) x\n⊢ Exists fun L => And (∀ (t : List R), Membership.mem L t → ∀ (y : R), Membership.mem t y → Or (Membership.mem s y) (Eq y (-1))) (Eq (List.map List.prod L).sum x)","decl":"theorem exists_list_of_mem_closure {s : Set R} {x : R} (hx : x ∈ closure s) :\n    ∃ L : List (List R), (∀ t ∈ L, ∀ y ∈ t, y ∈ s ∨ y = (-1 : R)) ∧ (L.map List.prod).sum = x := by\n  rw [mem_closure_iff] at hx\n  induction hx using AddSubgroup.closure_induction with\n  | mem _ hx =>\n    obtain ⟨l, hl, h⟩ := Submonoid.exists_list_of_mem_closure hx\n    exact ⟨[l], by simp [h]; clear_aux_decl; tauto⟩\n  | one => exact ⟨[], List.forall_mem_nil _, rfl⟩\n  | mul _ _ _ _ hL hM =>\n    obtain ⟨⟨L, HL1, HL2⟩, ⟨M, HM1, HM2⟩⟩ := And.intro hL hM\n    exact ⟨L ++ M, List.forall_mem_append.2 ⟨HL1, HM1⟩, by\n      rw [List.map_append, List.sum_append, HL2, HM2]⟩\n  | inv _ _ hL =>\n    obtain ⟨L, hL⟩ := hL\n    exact ⟨L.map (List.cons (-1)),\n      List.forall_mem_map.2 fun j hj => List.forall_mem_cons.2 ⟨Or.inr rfl, hL.1 j hj⟩,\n      hL.2 ▸\n        List.recOn L (by simp)\n          (by simp +contextual [List.map_cons, add_comm])⟩\n\n"}
{"name":"Subring.closure_eq","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\n⊢ Eq (Subring.closure ↑s) s","decl":"/-- Closure of a subring `S` equals `S`. -/\n@[simp]\ntheorem closure_eq (s : Subring R) : closure (s : Set R) = s :=\n  (Subring.gi R).l_u_eq s\n\n"}
{"name":"Subring.closure_empty","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ Eq (Subring.closure EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem closure_empty : closure (∅ : Set R) = ⊥ :=\n  (Subring.gi R).gc.l_bot\n\n"}
{"name":"Subring.closure_univ","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ Eq (Subring.closure Set.univ) Top.top","decl":"@[simp]\ntheorem closure_univ : closure (Set.univ : Set R) = ⊤ :=\n  @coe_top R _ ▸ closure_eq ⊤\n\n"}
{"name":"Subring.closure_union","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns t : Set R\n⊢ Eq (Subring.closure (Union.union s t)) (Max.max (Subring.closure s) (Subring.closure t))","decl":"theorem closure_union (s t : Set R) : closure (s ∪ t) = closure s ⊔ closure t :=\n  (Subring.gi R).gc.l_sup\n\n"}
{"name":"Subring.closure_iUnion","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nι : Sort u_1\ns : ι → Set R\n⊢ Eq (Subring.closure (Set.iUnion fun i => s i)) (iSup fun i => Subring.closure (s i))","decl":"theorem closure_iUnion {ι} (s : ι → Set R) : closure (⋃ i, s i) = ⨆ i, closure (s i) :=\n  (Subring.gi R).gc.l_iSup\n\n"}
{"name":"Subring.closure_sUnion","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set (Set R)\n⊢ Eq (Subring.closure s.sUnion) (iSup fun t => iSup fun h => Subring.closure t)","decl":"theorem closure_sUnion (s : Set (Set R)) : closure (⋃₀ s) = ⨆ t ∈ s, closure t :=\n  (Subring.gi R).gc.l_sSup\n\n"}
{"name":"Subring.map_sup","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\ns t : Subring R\nf : RingHom R S\n⊢ Eq (Subring.map f (Max.max s t)) (Max.max (Subring.map f s) (Subring.map f t))","decl":"theorem map_sup (s t : Subring R) (f : R →+* S) : (s ⊔ t).map f = s.map f ⊔ t.map f :=\n  (gc_map_comap f).l_sup\n\n"}
{"name":"Subring.map_iSup","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nι : Sort u_1\nf : RingHom R S\ns : ι → Subring R\n⊢ Eq (Subring.map f (iSup s)) (iSup fun i => Subring.map f (s i))","decl":"theorem map_iSup {ι : Sort*} (f : R →+* S) (s : ι → Subring R) :\n    (iSup s).map f = ⨆ i, (s i).map f :=\n  (gc_map_comap f).l_iSup\n\n"}
{"name":"Subring.map_inf","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\ns t : Subring R\nf : RingHom R S\nhf : Function.Injective ⇑f\n⊢ Eq (Subring.map f (Min.min s t)) (Min.min (Subring.map f s) (Subring.map f t))","decl":"theorem map_inf (s t : Subring R) (f : R →+* S) (hf : Function.Injective f) :\n    (s ⊓ t).map f = s.map f ⊓ t.map f := SetLike.coe_injective (Set.image_inter hf)\n\n"}
{"name":"Subring.map_iInf","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : Ring R\ninst✝¹ : Ring S\nι : Sort u_1\ninst✝ : Nonempty ι\nf : RingHom R S\nhf : Function.Injective ⇑f\ns : ι → Subring R\n⊢ Eq (Subring.map f (iInf s)) (iInf fun i => Subring.map f (s i))","decl":"theorem map_iInf {ι : Sort*} [Nonempty ι] (f : R →+* S) (hf : Function.Injective f)\n    (s : ι → Subring R) : (iInf s).map f = ⨅ i, (s i).map f := by\n  apply SetLike.coe_injective\n  simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe ∘ s)\n\n"}
{"name":"Subring.comap_inf","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\ns t : Subring S\nf : RingHom R S\n⊢ Eq (Subring.comap f (Min.min s t)) (Min.min (Subring.comap f s) (Subring.comap f t))","decl":"theorem comap_inf (s t : Subring S) (f : R →+* S) : (s ⊓ t).comap f = s.comap f ⊓ t.comap f :=\n  (gc_map_comap f).u_inf\n\n"}
{"name":"Subring.comap_iInf","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nι : Sort u_1\nf : RingHom R S\ns : ι → Subring S\n⊢ Eq (Subring.comap f (iInf s)) (iInf fun i => Subring.comap f (s i))","decl":"theorem comap_iInf {ι : Sort*} (f : R →+* S) (s : ι → Subring S) :\n    (iInf s).comap f = ⨅ i, (s i).comap f :=\n  (gc_map_comap f).u_iInf\n\n"}
{"name":"Subring.map_bot","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\n⊢ Eq (Subring.map f Bot.bot) Bot.bot","decl":"@[simp]\ntheorem map_bot (f : R →+* S) : (⊥ : Subring R).map f = ⊥ :=\n  (gc_map_comap f).l_bot\n\n"}
{"name":"Subring.comap_top","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\n⊢ Eq (Subring.comap f Top.top) Top.top","decl":"@[simp]\ntheorem comap_top (f : R →+* S) : (⊤ : Subring S).comap f = ⊤ :=\n  (gc_map_comap f).u_top\n\n"}
{"name":"Subring.coe_prod","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\ns : Subring R\nt : Subring S\n⊢ Eq (↑(s.prod t)) (SProd.sprod ↑s ↑t)","decl":"@[norm_cast]\ntheorem coe_prod (s : Subring R) (t : Subring S) :\n    (s.prod t : Set (R × S)) = (s : Set R) ×ˢ (t : Set S) :=\n  rfl\n\n"}
{"name":"Subring.mem_prod","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\ns : Subring R\nt : Subring S\np : Prod R S\n⊢ Iff (Membership.mem (s.prod t) p) (And (Membership.mem s p.1) (Membership.mem t p.2))","decl":"theorem mem_prod {s : Subring R} {t : Subring S} {p : R × S} : p ∈ s.prod t ↔ p.1 ∈ s ∧ p.2 ∈ t :=\n  Iff.rfl\n\n"}
{"name":"Subring.prod_mono","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\ns₁ s₂ : Subring R\nhs : LE.le s₁ s₂\nt₁ t₂ : Subring S\nht : LE.le t₁ t₂\n⊢ LE.le (s₁.prod t₁) (s₂.prod t₂)","decl":"@[gcongr, mono]\ntheorem prod_mono ⦃s₁ s₂ : Subring R⦄ (hs : s₁ ≤ s₂) ⦃t₁ t₂ : Subring S⦄ (ht : t₁ ≤ t₂) :\n    s₁.prod t₁ ≤ s₂.prod t₂ :=\n  Set.prod_mono hs ht\n\n"}
{"name":"Subring.prod_mono_right","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\ns : Subring R\n⊢ Monotone fun t => s.prod t","decl":"theorem prod_mono_right (s : Subring R) : Monotone fun t : Subring S => s.prod t :=\n  prod_mono (le_refl s)\n\n"}
{"name":"Subring.prod_mono_left","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nt : Subring S\n⊢ Monotone fun s => s.prod t","decl":"theorem prod_mono_left (t : Subring S) : Monotone fun s : Subring R => s.prod t := fun _ _ hs =>\n  prod_mono hs (le_refl t)\n\n"}
{"name":"Subring.prod_top","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\ns : Subring R\n⊢ Eq (s.prod Top.top) (Subring.comap (RingHom.fst R S) s)","decl":"theorem prod_top (s : Subring R) : s.prod (⊤ : Subring S) = s.comap (RingHom.fst R S) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_fst]\n\n"}
{"name":"Subring.top_prod","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\ns : Subring S\n⊢ Eq (Top.top.prod s) (Subring.comap (RingHom.snd R S) s)","decl":"theorem top_prod (s : Subring S) : (⊤ : Subring R).prod s = s.comap (RingHom.snd R S) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_snd]\n\n"}
{"name":"Subring.top_prod_top","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\n⊢ Eq (Top.top.prod Top.top) Top.top","decl":"@[simp]\ntheorem top_prod_top : (⊤ : Subring R).prod (⊤ : Subring S) = ⊤ :=\n  (top_prod _).trans <| comap_top _\n\n"}
{"name":"Subring.mem_iSup_of_directed","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nι : Sort u_1\nhι : Nonempty ι\nS : ι → Subring R\nhS : Directed (fun x1 x2 => LE.le x1 x2) S\nx : R\n⊢ Iff (Membership.mem (iSup fun i => S i) x) (Exists fun i => Membership.mem (S i) x)","decl":"/-- The underlying set of a non-empty directed sSup of subrings is just a union of the subrings.\n  Note that this fails without the directedness assumption (the union of two subrings is\n  typically not a subring) -/\ntheorem mem_iSup_of_directed {ι} [hι : Nonempty ι] {S : ι → Subring R} (hS : Directed (· ≤ ·) S)\n    {x : R} : (x ∈ ⨆ i, S i) ↔ ∃ i, x ∈ S i := by\n  refine ⟨?_, fun ⟨i, hi⟩ ↦ le_iSup S i hi⟩\n  let U : Subring R :=\n    Subring.mk' (⋃ i, (S i : Set R)) (⨆ i, (S i).toSubmonoid) (⨆ i, (S i).toAddSubgroup)\n      (Submonoid.coe_iSup_of_directed hS) (AddSubgroup.coe_iSup_of_directed hS)\n  suffices ⨆ i, S i ≤ U by simpa [U] using @this x\n  exact iSup_le fun i x hx ↦ Set.mem_iUnion.2 ⟨i, hx⟩\n\n"}
{"name":"Subring.coe_iSup_of_directed","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nι : Sort u_1\nhι : Nonempty ι\nS : ι → Subring R\nhS : Directed (fun x1 x2 => LE.le x1 x2) S\n⊢ Eq (↑(iSup fun i => S i)) (Set.iUnion fun i => ↑(S i))","decl":"theorem coe_iSup_of_directed {ι} [hι : Nonempty ι] {S : ι → Subring R} (hS : Directed (· ≤ ·) S) :\n    ((⨆ i, S i : Subring R) : Set R) = ⋃ i, S i :=\n  Set.ext fun x ↦ by simp [mem_iSup_of_directed hS]\n\n"}
{"name":"Subring.mem_sSup_of_directedOn","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nS : Set (Subring R)\nSne : S.Nonempty\nhS : DirectedOn (fun x1 x2 => LE.le x1 x2) S\nx : R\n⊢ Iff (Membership.mem (SupSet.sSup S) x) (Exists fun s => And (Membership.mem S s) (Membership.mem s x))","decl":"theorem mem_sSup_of_directedOn {S : Set (Subring R)} (Sne : S.Nonempty) (hS : DirectedOn (· ≤ ·) S)\n    {x : R} : x ∈ sSup S ↔ ∃ s ∈ S, x ∈ s := by\n  haveI : Nonempty S := Sne.to_subtype\n  simp only [sSup_eq_iSup', mem_iSup_of_directed hS.directed_val, SetCoe.exists, Subtype.coe_mk,\n    exists_prop]\n\n"}
{"name":"Subring.coe_sSup_of_directedOn","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nS : Set (Subring R)\nSne : S.Nonempty\nhS : DirectedOn (fun x1 x2 => LE.le x1 x2) S\n⊢ Eq (↑(SupSet.sSup S)) (Set.iUnion fun s => Set.iUnion fun h => ↑s)","decl":"theorem coe_sSup_of_directedOn {S : Set (Subring R)} (Sne : S.Nonempty)\n    (hS : DirectedOn (· ≤ ·) S) : (↑(sSup S) : Set R) = ⋃ s ∈ S, ↑s :=\n  Set.ext fun x => by simp [mem_sSup_of_directedOn Sne hS]\n\n"}
{"name":"Subring.mem_map_equiv","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingEquiv R S\nK : Subring R\nx : S\n⊢ Iff (Membership.mem (Subring.map (↑f) K) x) (Membership.mem K (f.symm x))","decl":"theorem mem_map_equiv {f : R ≃+* S} {K : Subring R} {x : S} :\n    x ∈ K.map (f : R →+* S) ↔ f.symm x ∈ K :=\n  @Set.mem_image_equiv _ _ (K : Set R) f.toEquiv x\n\n"}
{"name":"Subring.map_equiv_eq_comap_symm","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingEquiv R S\nK : Subring R\n⊢ Eq (Subring.map (↑f) K) (Subring.comap (↑f.symm) K)","decl":"theorem map_equiv_eq_comap_symm (f : R ≃+* S) (K : Subring R) :\n    K.map (f : R →+* S) = K.comap f.symm :=\n  SetLike.coe_injective (f.toEquiv.image_eq_preimage K)\n\n"}
{"name":"Subring.comap_equiv_eq_map_symm","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingEquiv R S\nK : Subring S\n⊢ Eq (Subring.comap (↑f) K) (Subring.map (↑f.symm) K)","decl":"theorem comap_equiv_eq_map_symm (f : R ≃+* S) (K : Subring S) :\n    K.comap (f : R →+* S) = K.map f.symm :=\n  (map_equiv_eq_comap_symm f.symm K).symm\n\n"}
{"name":"RingHom.coe_rangeRestrict","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\nx : R\n⊢ Eq (↑(f.rangeRestrict x)) (f x)","decl":"@[simp]\ntheorem coe_rangeRestrict (f : R →+* S) (x : R) : (f.rangeRestrict x : S) = f x :=\n  rfl\n\n"}
{"name":"RingHom.rangeRestrict_surjective","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\n⊢ Function.Surjective ⇑f.rangeRestrict","decl":"theorem rangeRestrict_surjective (f : R →+* S) : Function.Surjective f.rangeRestrict :=\n  fun ⟨_y, hy⟩ =>\n  let ⟨x, hx⟩ := mem_range.mp hy\n  ⟨x, Subtype.ext hx⟩\n\n"}
{"name":"RingHom.range_eq_top","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\n⊢ Iff (Eq f.range Top.top) (Function.Surjective ⇑f)","decl":"theorem range_eq_top {f : R →+* S} :\n    f.range = (⊤ : Subring S) ↔ Function.Surjective f :=\n  SetLike.ext'_iff.trans <| Iff.trans (by rw [coe_range, coe_top]) Set.range_eq_univ\n\n"}
{"name":"RingHom.range_top_iff_surjective","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\n⊢ Iff (Eq f.range Top.top) (Function.Surjective ⇑f)","decl":"@[deprecated (since := \"2024-11-11\")] alias range_top_iff_surjective := range_eq_top\n\n"}
{"name":"RingHom.range_eq_top_of_surjective","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\nhf : Function.Surjective ⇑f\n⊢ Eq f.range Top.top","decl":"/-- The range of a surjective ring homomorphism is the whole of the codomain. -/\n@[simp]\ntheorem range_eq_top_of_surjective (f : R →+* S) (hf : Function.Surjective f) :\n    f.range = (⊤ : Subring S) :=\n  range_eq_top.2 hf\n\n"}
{"name":"RingHom.range_top_of_surjective","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\nhf : Function.Surjective ⇑f\n⊢ Eq f.range Top.top","decl":"@[deprecated (since := \"2024-11-11\")] alias range_top_of_surjective := range_eq_top_of_surjective\n\n"}
{"name":"RingHom.eqLocus_same","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝¹ : Ring R\nS : Type v\ninst✝ : Semiring S\nf : RingHom R S\n⊢ Eq (f.eqLocus f) Top.top","decl":"@[simp]\ntheorem eqLocus_same (f : R →+* S) : f.eqLocus f = ⊤ :=\n  SetLike.ext fun _ => eq_self_iff_true _\n\n"}
{"name":"RingHom.eqOn_set_closure","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝¹ : Ring R\nS : Type v\ninst✝ : Semiring S\nf g : RingHom R S\ns : Set R\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Set.EqOn ⇑f ⇑g ↑(Subring.closure s)","decl":"/-- If two ring homomorphisms are equal on a set, then they are equal on its subring closure. -/\ntheorem eqOn_set_closure {f g : R →+* S} {s : Set R} (h : Set.EqOn f g s) :\n    Set.EqOn f g (closure s) :=\n  show closure s ≤ f.eqLocus g from closure_le.2 h\n\n"}
{"name":"RingHom.eq_of_eqOn_set_top","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝¹ : Ring R\nS : Type v\ninst✝ : Semiring S\nf g : RingHom R S\nh : Set.EqOn ⇑f ⇑g ↑Top.top\n⊢ Eq f g","decl":"theorem eq_of_eqOn_set_top {f g : R →+* S} (h : Set.EqOn f g (⊤ : Subring R)) : f = g :=\n  ext fun _x => h trivial\n\n"}
{"name":"RingHom.eq_of_eqOn_set_dense","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝¹ : Ring R\nS : Type v\ninst✝ : Semiring S\ns : Set R\nhs : Eq (Subring.closure s) Top.top\nf g : RingHom R S\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Eq f g","decl":"theorem eq_of_eqOn_set_dense {s : Set R} (hs : closure s = ⊤) {f g : R →+* S} (h : s.EqOn f g) :\n    f = g :=\n  eq_of_eqOn_set_top <| hs ▸ eqOn_set_closure h\n\n"}
{"name":"RingHom.closure_preimage_le","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\ns : Set S\n⊢ LE.le (Subring.closure (Set.preimage (⇑f) s)) (Subring.comap f (Subring.closure s))","decl":"theorem closure_preimage_le (f : R →+* S) (s : Set S) : closure (f ⁻¹' s) ≤ (closure s).comap f :=\n  closure_le.2 fun _ hx => SetLike.mem_coe.2 <| mem_comap.2 <| subset_closure hx\n\n"}
{"name":"RingHom.map_closure","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\ns : Set R\n⊢ Eq (Subring.map f (Subring.closure s)) (Subring.closure (Set.image (⇑f) s))","decl":"/-- The image under a ring homomorphism of the subring generated by a set equals\nthe subring generated by the image of the set. -/\ntheorem map_closure (f : R →+* S) (s : Set R) : (closure s).map f = closure (f '' s) :=\n  Set.image_preimage.l_comm_of_u_comm (gc_map_comap f) (Subring.gi S).gc (Subring.gi R).gc\n    fun _ ↦ rfl\n\n"}
{"name":"Subring.range_subtype","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\n⊢ Eq s.subtype.range s","decl":"@[simp]\ntheorem range_subtype (s : Subring R) : s.subtype.range = s :=\n  SetLike.coe_injective <| (coe_rangeS _).trans Subtype.range_coe\n\n"}
{"name":"Subring.range_fst","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\n⊢ Eq (RingHom.fst R S).rangeS Top.top","decl":"theorem range_fst : (fst R S).rangeS = ⊤ :=\n  (fst R S).rangeS_top_of_surjective <| Prod.fst_surjective\n\n"}
{"name":"Subring.range_snd","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\n⊢ Eq (RingHom.snd R S).rangeS Top.top","decl":"theorem range_snd : (snd R S).rangeS = ⊤ :=\n  (snd R S).rangeS_top_of_surjective <| Prod.snd_surjective\n\n"}
{"name":"Subring.prod_bot_sup_bot_prod","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\ns : Subring R\nt : Subring S\n⊢ Eq (Max.max (s.prod Bot.bot) (Bot.bot.prod t)) (s.prod t)","decl":"@[simp]\ntheorem prod_bot_sup_bot_prod (s : Subring R) (t : Subring S) : s.prod ⊥ ⊔ prod ⊥ t = s.prod t :=\n  le_antisymm (sup_le (prod_mono_right s bot_le) (prod_mono_left t bot_le)) fun p hp =>\n    Prod.fst_mul_snd p ▸\n      mul_mem\n        ((le_sup_left : s.prod ⊥ ≤ s.prod ⊥ ⊔ prod ⊥ t) ⟨hp.1, SetLike.mem_coe.2 <| one_mem ⊥⟩)\n        ((le_sup_right : prod ⊥ t ≤ s.prod ⊥ ⊔ prod ⊥ t) ⟨SetLike.mem_coe.2 <| one_mem ⊥, hp.2⟩)\n\n"}
{"name":"RingEquiv.ofLeftInverse_apply","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\ng : S → R\nf : RingHom R S\nh : Function.LeftInverse g ⇑f\nx : R\n⊢ Eq (↑((RingEquiv.ofLeftInverse h) x)) (f x)","decl":"@[simp]\ntheorem ofLeftInverse_apply {g : S → R} {f : R →+* S} (h : Function.LeftInverse g f) (x : R) :\n    ↑(ofLeftInverse h x) = f x :=\n  rfl\n\n"}
{"name":"RingEquiv.ofLeftInverse_symm_apply","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\ng : S → R\nf : RingHom R S\nh : Function.LeftInverse g ⇑f\nx : Subtype fun x => Membership.mem f.range x\n⊢ Eq ((RingEquiv.ofLeftInverse h).symm x) (g ↑x)","decl":"@[simp]\ntheorem ofLeftInverse_symm_apply {g : S → R} {f : R →+* S} (h : Function.LeftInverse g f)\n    (x : f.range) : (ofLeftInverse h).symm x = g x :=\n  rfl\n\n"}
{"name":"Subring.InClosure.recOn","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set R\nC : R → Prop\nx : R\nhx : Membership.mem (Subring.closure s) x\nh1 : C 1\nhneg1 : C (-1)\nhs : ∀ (z : R), Membership.mem s z → ∀ (n : R), C n → C (HMul.hMul z n)\nha : ∀ {x y : R}, C x → C y → C (HAdd.hAdd x y)\n⊢ C x","decl":"@[elab_as_elim]\nprotected theorem InClosure.recOn {C : R → Prop} {x : R} (hx : x ∈ closure s) (h1 : C 1)\n    (hneg1 : C (-1)) (hs : ∀ z ∈ s, ∀ n, C n → C (z * n)) (ha : ∀ {x y}, C x → C y → C (x + y)) :\n    C x := by\n  have h0 : C 0 := add_neg_cancel (1 : R) ▸ ha h1 hneg1\n  rcases exists_list_of_mem_closure hx with ⟨L, HL, rfl⟩\n  clear hx\n  induction' L with hd tl ih\n  · exact h0\n  rw [List.forall_mem_cons] at HL\n  suffices C (List.prod hd) by\n    rw [List.map_cons, List.sum_cons]\n    exact ha this (ih HL.2)\n  replace HL := HL.1\n  clear ih tl\n  rsuffices ⟨L, HL', HP | HP⟩ :\n    ∃ L : List R, (∀ x ∈ L, x ∈ s) ∧ (List.prod hd = List.prod L ∨ List.prod hd = -List.prod L)\n  · rw [HP]\n    clear HP HL hd\n    induction' L with hd tl ih\n    · exact h1\n    rw [List.forall_mem_cons] at HL'\n    rw [List.prod_cons]\n    exact hs _ HL'.1 _ (ih HL'.2)\n  · rw [HP]\n    clear HP HL hd\n    induction' L with hd tl ih\n    · exact hneg1\n    rw [List.prod_cons, neg_mul_eq_mul_neg]\n    rw [List.forall_mem_cons] at HL'\n    exact hs _ HL'.1 _ (ih HL'.2)\n  induction' hd with hd tl ih\n  · exact ⟨[], List.forall_mem_nil _, Or.inl rfl⟩\n  rw [List.forall_mem_cons] at HL\n  rcases ih HL.2 with ⟨L, HL', HP | HP⟩ <;> cases' HL.1 with hhd hhd\n  · exact\n      ⟨hd::L, List.forall_mem_cons.2 ⟨hhd, HL'⟩,\n        Or.inl <| by rw [List.prod_cons, List.prod_cons, HP]⟩\n  · exact ⟨L, HL', Or.inr <| by rw [List.prod_cons, hhd, neg_one_mul, HP]⟩\n  · exact\n      ⟨hd::L, List.forall_mem_cons.2 ⟨hhd, HL'⟩,\n        Or.inr <| by rw [List.prod_cons, List.prod_cons, HP, neg_mul_eq_mul_neg]⟩\n  · exact ⟨L, HL', Or.inl <| by rw [List.prod_cons, hhd, HP, neg_one_mul, neg_neg]⟩\n\n"}
{"name":"Subring.closure_preimage_le","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\ns : Set S\n⊢ LE.le (Subring.closure (Set.preimage (⇑f) s)) (Subring.comap f (Subring.closure s))","decl":"theorem closure_preimage_le (f : R →+* S) (s : Set S) : closure (f ⁻¹' s) ≤ (closure s).comap f :=\n  closure_le.2 fun _ hx => SetLike.mem_coe.2 <| mem_comap.2 <| subset_closure hx\n\n"}
{"name":"Subring.smul_def","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝¹ : Ring R\nα : Type u_1\ninst✝ : SMul R α\nS : Subring R\ng : Subtype fun x => Membership.mem S x\nm : α\n⊢ Eq (HSMul.hSMul g m) (HSMul.hSMul (↑g) m)","decl":"theorem smul_def [SMul R α] {S : Subring R} (g : S) (m : α) : g • m = (g : R) • m :=\n  rfl\n\n-- Porting note: Lean can find this instance already\n"}
{"name":"Subring.smulCommClass_left","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝³ : Ring R\nα : Type u_1\nβ : Type u_2\ninst✝² : SMul R β\ninst✝¹ : SMul α β\ninst✝ : SMulCommClass R α β\nS : Subring R\n⊢ SMulCommClass (Subtype fun x => Membership.mem S x) α β","decl":"instance smulCommClass_left [SMul R β] [SMul α β] [SMulCommClass R α β] (S : Subring R) :\n    SMulCommClass S α β :=\n  inferInstanceAs (SMulCommClass S.toSubsemiring α β)\n\n-- Porting note: Lean can find this instance already\n"}
{"name":"Subring.smulCommClass_right","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝³ : Ring R\nα : Type u_1\nβ : Type u_2\ninst✝² : SMul α β\ninst✝¹ : SMul R β\ninst✝ : SMulCommClass α R β\nS : Subring R\n⊢ SMulCommClass α (Subtype fun x => Membership.mem S x) β","decl":"instance smulCommClass_right [SMul α β] [SMul R β] [SMulCommClass α R β] (S : Subring R) :\n    SMulCommClass α S β :=\n  inferInstanceAs (SMulCommClass α S.toSubsemiring β)\n\n-- Porting note: Lean can find this instance already\n"}
{"name":"Subring.instIsScalarTowerSubtypeMem","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝⁴ : Ring R\nα : Type u_1\nβ : Type u_2\ninst✝³ : SMul α β\ninst✝² : SMul R α\ninst✝¹ : SMul R β\ninst✝ : IsScalarTower R α β\nS : Subring R\n⊢ IsScalarTower (Subtype fun x => Membership.mem S x) α β","decl":"/-- Note that this provides `IsScalarTower S R R` which is needed by `smul_mul_assoc`. -/\ninstance [SMul α β] [SMul R α] [SMul R β] [IsScalarTower R α β] (S : Subring R) :\n    IsScalarTower S α β :=\n  inferInstanceAs (IsScalarTower S.toSubsemiring α β)\n\n-- Porting note: Lean can find this instance already\n"}
{"name":"Subring.instFaithfulSMulSubtypeMem","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝² : Ring R\nα : Type u_1\ninst✝¹ : SMul R α\ninst✝ : FaithfulSMul R α\nS : Subring R\n⊢ FaithfulSMul (Subtype fun x => Membership.mem S x) α","decl":"instance [SMul R α] [FaithfulSMul R α] (S : Subring R) : FaithfulSMul S α :=\n  inferInstanceAs (FaithfulSMul S.toSubsemiring α)\n\n-- Porting note: Lean can find this instance already\n"}
{"name":"Subring.center.smulCommClass_left","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ SMulCommClass (Subtype fun x => Membership.mem (Subring.center R) x) R R","decl":"/-- The center of a semiring acts commutatively on that semiring. -/\ninstance center.smulCommClass_left : SMulCommClass (center R) R R :=\n  Subsemiring.center.smulCommClass_left\n\n"}
{"name":"Subring.center.smulCommClass_right","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ SMulCommClass R (Subtype fun x => Membership.mem (Subring.center R) x) R","decl":"/-- The center of a semiring acts commutatively on that semiring. -/\ninstance center.smulCommClass_right : SMulCommClass R (center R) R :=\n  Subsemiring.center.smulCommClass_right\n\n"}
{"name":"Subring.map_comap_eq","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\nt : Subring S\n⊢ Eq (Subring.map f (Subring.comap f t)) (Min.min t f.range)","decl":"theorem map_comap_eq (f : R →+* S) (t : Subring S) : (t.comap f).map f = t ⊓ f.range :=\n  SetLike.coe_injective Set.image_preimage_eq_inter_range\n\n"}
{"name":"Subring.map_comap_eq_self","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\nt : Subring S\nh : LE.le t f.range\n⊢ Eq (Subring.map f (Subring.comap f t)) t","decl":"theorem map_comap_eq_self\n    {f : R →+* S} {t : Subring S} (h : t ≤ f.range) : (t.comap f).map f = t := by\n  simpa only [inf_of_le_left h] using Subring.map_comap_eq f t\n\n"}
{"name":"Subring.map_comap_eq_self_of_surjective","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\nhf : Function.Surjective ⇑f\nt : Subring S\n⊢ Eq (Subring.map f (Subring.comap f t)) t","decl":"theorem map_comap_eq_self_of_surjective\n    {f : R →+* S} (hf : Function.Surjective f) (t : Subring S) : (t.comap f).map f = t :=\n  map_comap_eq_self <| by simp [hf]\n\n"}
{"name":"Subring.comap_map_eq","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\ns : Subring R\n⊢ Eq (Subring.comap f (Subring.map f s)) (Max.max s (Subring.closure (Set.preimage (⇑f) (Singleton.singleton 0))))","decl":"theorem comap_map_eq (f : R →+* S) (s : Subring R) :\n    (s.map f).comap f = s ⊔ closure (f ⁻¹' {0}) := by\n  apply le_antisymm\n  · intro x hx\n    rw [mem_comap, mem_map] at hx\n    obtain ⟨y, hy, hxy⟩ := hx\n    replace hxy : x - y ∈ f ⁻¹' {0} := by simp [hxy]\n    rw [← closure_eq s, ← closure_union, ← add_sub_cancel y x]\n    exact Subring.add_mem _ (subset_closure <| Or.inl hy) (subset_closure <| Or.inr hxy)\n  · rw [← map_le_iff_le_comap, map_sup, f.map_closure]\n    apply le_of_eq\n    rw [sup_eq_left, closure_le]\n    exact (Set.image_preimage_subset f {0}).trans (Set.singleton_subset_iff.2 (s.map f).zero_mem)\n\n"}
{"name":"Subring.comap_map_eq_self","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\ns : Subring R\nh : HasSubset.Subset (Set.preimage (⇑f) (Singleton.singleton 0)) ↑s\n⊢ Eq (Subring.comap f (Subring.map f s)) s","decl":"theorem comap_map_eq_self {f : R →+* S} {s : Subring R}\n    (h : f ⁻¹' {0} ⊆ s) : (s.map f).comap f = s := by\n  convert comap_map_eq f s\n  rwa [left_eq_sup, closure_le]\n\n"}
{"name":"Subring.comap_map_eq_self_of_injective","module":"Mathlib.Algebra.Ring.Subring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\nhf : Function.Injective ⇑f\ns : Subring R\n⊢ Eq (Subring.comap f (Subring.map f s)) s","decl":"theorem comap_map_eq_self_of_injective\n    {f : R →+* S} (hf : Function.Injective f) (s : Subring R) : (s.map f).comap f = s :=\n  SetLike.coe_injective (Set.preimage_image_eq _ hf)\n\n"}
