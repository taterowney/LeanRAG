{"name":"FreeAddMonoid.toList_symm","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\n⊢ Eq FreeAddMonoid.toList.symm FreeAddMonoid.ofList","decl":"@[to_additive (attr := simp)]\ntheorem toList_symm : (@toList α).symm = ofList := rfl\n\n"}
{"name":"FreeMonoid.toList_symm","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\n⊢ Eq FreeMonoid.toList.symm FreeMonoid.ofList","decl":"@[to_additive (attr := simp)]\ntheorem toList_symm : (@toList α).symm = ofList := rfl\n\n"}
{"name":"FreeMonoid.ofList_symm","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\n⊢ Eq FreeMonoid.ofList.symm FreeMonoid.toList","decl":"@[to_additive (attr := simp)]\ntheorem ofList_symm : (@ofList α).symm = toList := rfl\n\n"}
{"name":"FreeAddMonoid.ofList_symm","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\n⊢ Eq FreeAddMonoid.ofList.symm FreeAddMonoid.toList","decl":"@[to_additive (attr := simp)]\ntheorem ofList_symm : (@ofList α).symm = toList := rfl\n\n"}
{"name":"FreeMonoid.toList_ofList","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (FreeMonoid.toList (FreeMonoid.ofList l)) l","decl":"@[to_additive (attr := simp)]\ntheorem toList_ofList (l : List α) : toList (ofList l) = l := rfl\n\n"}
{"name":"FreeAddMonoid.toList_ofList","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (FreeAddMonoid.toList (FreeAddMonoid.ofList l)) l","decl":"@[to_additive (attr := simp)]\ntheorem toList_ofList (l : List α) : toList (ofList l) = l := rfl\n\n"}
{"name":"FreeMonoid.ofList_toList","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nxs : FreeMonoid α\n⊢ Eq (FreeMonoid.ofList (FreeMonoid.toList xs)) xs","decl":"@[to_additive (attr := simp)]\ntheorem ofList_toList (xs : FreeMonoid α) : ofList (toList xs) = xs := rfl\n\n"}
{"name":"FreeAddMonoid.ofList_toList","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nxs : FreeAddMonoid α\n⊢ Eq (FreeAddMonoid.ofList (FreeAddMonoid.toList xs)) xs","decl":"@[to_additive (attr := simp)]\ntheorem ofList_toList (xs : FreeMonoid α) : ofList (toList xs) = xs := rfl\n\n"}
{"name":"FreeMonoid.toList_comp_ofList","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\n⊢ Eq (Function.comp ⇑FreeMonoid.toList ⇑FreeMonoid.ofList) id","decl":"@[to_additive (attr := simp)]\ntheorem toList_comp_ofList : @toList α ∘ ofList = id := rfl\n\n"}
{"name":"FreeAddMonoid.toList_comp_ofList","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\n⊢ Eq (Function.comp ⇑FreeAddMonoid.toList ⇑FreeAddMonoid.ofList) id","decl":"@[to_additive (attr := simp)]\ntheorem toList_comp_ofList : @toList α ∘ ofList = id := rfl\n\n"}
{"name":"FreeMonoid.ofList_comp_toList","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\n⊢ Eq (Function.comp ⇑FreeMonoid.ofList ⇑FreeMonoid.toList) id","decl":"@[to_additive (attr := simp)]\ntheorem ofList_comp_toList : @ofList α ∘ toList = id := rfl\n\n"}
{"name":"FreeAddMonoid.ofList_comp_toList","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\n⊢ Eq (Function.comp ⇑FreeAddMonoid.ofList ⇑FreeAddMonoid.toList) id","decl":"@[to_additive (attr := simp)]\ntheorem ofList_comp_toList : @ofList α ∘ toList = id := rfl\n\n"}
{"name":"FreeMonoid.toList_one","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\n⊢ Eq (FreeMonoid.toList 1) List.nil","decl":"@[to_additive (attr := simp)]\ntheorem toList_one : toList (1 : FreeMonoid α) = [] := rfl\n\n"}
{"name":"FreeAddMonoid.toList_zero","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\n⊢ Eq (FreeAddMonoid.toList 0) List.nil","decl":"@[to_additive (attr := simp)]\ntheorem toList_one : toList (1 : FreeMonoid α) = [] := rfl\n\n"}
{"name":"FreeMonoid.ofList_nil","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\n⊢ Eq (FreeMonoid.ofList List.nil) 1","decl":"@[to_additive (attr := simp)]\ntheorem ofList_nil : ofList ([] : List α) = 1 := rfl\n\n"}
{"name":"FreeAddMonoid.ofList_nil","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\n⊢ Eq (FreeAddMonoid.ofList List.nil) 0","decl":"@[to_additive (attr := simp)]\ntheorem ofList_nil : ofList ([] : List α) = 1 := rfl\n\n"}
{"name":"FreeAddMonoid.toList_add","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nxs ys : FreeAddMonoid α\n⊢ Eq (FreeAddMonoid.toList (HAdd.hAdd xs ys)) (HAppend.hAppend (FreeAddMonoid.toList xs) (FreeAddMonoid.toList ys))","decl":"@[to_additive (attr := simp)]\ntheorem toList_mul (xs ys : FreeMonoid α) : toList (xs * ys) = toList xs ++ toList ys := rfl\n\n"}
{"name":"FreeMonoid.toList_mul","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nxs ys : FreeMonoid α\n⊢ Eq (FreeMonoid.toList (HMul.hMul xs ys)) (HAppend.hAppend (FreeMonoid.toList xs) (FreeMonoid.toList ys))","decl":"@[to_additive (attr := simp)]\ntheorem toList_mul (xs ys : FreeMonoid α) : toList (xs * ys) = toList xs ++ toList ys := rfl\n\n"}
{"name":"FreeAddMonoid.ofList_append","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nxs ys : List α\n⊢ Eq (FreeAddMonoid.ofList (HAppend.hAppend xs ys)) (HAdd.hAdd (FreeAddMonoid.ofList xs) (FreeAddMonoid.ofList ys))","decl":"@[to_additive (attr := simp)]\ntheorem ofList_append (xs ys : List α) : ofList (xs ++ ys) = ofList xs * ofList ys := rfl\n\n"}
{"name":"FreeMonoid.ofList_append","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nxs ys : List α\n⊢ Eq (FreeMonoid.ofList (HAppend.hAppend xs ys)) (HMul.hMul (FreeMonoid.ofList xs) (FreeMonoid.ofList ys))","decl":"@[to_additive (attr := simp)]\ntheorem ofList_append (xs ys : List α) : ofList (xs ++ ys) = ofList xs * ofList ys := rfl\n\n"}
{"name":"FreeMonoid.toList_prod","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nxs : List (FreeMonoid α)\n⊢ Eq (FreeMonoid.toList xs.prod) (List.map (⇑FreeMonoid.toList) xs).flatten","decl":"@[to_additive (attr := simp)]\ntheorem toList_prod (xs : List (FreeMonoid α)) : toList xs.prod = (xs.map toList).flatten := by\n  induction xs <;> simp [*, List.flatten]\n\n"}
{"name":"FreeAddMonoid.toList_sum","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nxs : List (FreeAddMonoid α)\n⊢ Eq (FreeAddMonoid.toList xs.sum) (List.map (⇑FreeAddMonoid.toList) xs).flatten","decl":"@[to_additive (attr := simp)]\ntheorem toList_prod (xs : List (FreeMonoid α)) : toList xs.prod = (xs.map toList).flatten := by\n  induction xs <;> simp [*, List.flatten]\n\n"}
{"name":"FreeMonoid.ofList_flatten","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nxs : List (List α)\n⊢ Eq (FreeMonoid.ofList xs.flatten) (List.map (⇑FreeMonoid.ofList) xs).prod","decl":"@[to_additive (attr := simp)]\ntheorem ofList_flatten (xs : List (List α)) : ofList xs.flatten = (xs.map ofList).prod :=\n  toList.injective <| by simp\n\n"}
{"name":"FreeAddMonoid.ofList_flatten","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nxs : List (List α)\n⊢ Eq (FreeAddMonoid.ofList xs.flatten) (List.map (⇑FreeAddMonoid.ofList) xs).sum","decl":"@[to_additive (attr := simp)]\ntheorem ofList_flatten (xs : List (List α)) : ofList xs.flatten = (xs.map ofList).prod :=\n  toList.injective <| by simp\n\n"}
{"name":"FreeMonoid.ofList_join","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nxs : List (List α)\n⊢ Eq (FreeMonoid.ofList xs.flatten) (List.map (⇑FreeMonoid.ofList) xs).prod","decl":"@[deprecated (since := \"2024-10-15\")] alias ofList_join := ofList_flatten\n"}
{"name":"FreeAddMonoid.ofList_join","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nxs : List (List α)\n⊢ Eq (FreeAddMonoid.ofList xs.flatten) (List.map (⇑FreeAddMonoid.ofList) xs).sum","decl":"@[deprecated (since := \"2024-10-15\")]\nalias _root_.FreeAddMonoid.ofList_join := _root_.FreeAddMonoid.ofList_flatten\n\n"}
{"name":"FreeMonoid.toList_of","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nx : α\n⊢ Eq (FreeMonoid.toList (FreeMonoid.of x)) (List.cons x List.nil)","decl":"@[to_additive (attr := simp)]\ntheorem toList_of (x : α) : toList (of x) = [x] := rfl\n\n"}
{"name":"FreeAddMonoid.toList_of","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nx : α\n⊢ Eq (FreeAddMonoid.toList (FreeAddMonoid.of x)) (List.cons x List.nil)","decl":"@[to_additive (attr := simp)]\ntheorem toList_of (x : α) : toList (of x) = [x] := rfl\n\n"}
{"name":"FreeMonoid.ofList_singleton","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nx : α\n⊢ Eq (FreeMonoid.ofList (List.cons x List.nil)) (FreeMonoid.of x)","decl":"@[to_additive]\ntheorem ofList_singleton (x : α) : ofList [x] = of x := rfl\n\n"}
{"name":"FreeAddMonoid.ofList_singleton","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nx : α\n⊢ Eq (FreeAddMonoid.ofList (List.cons x List.nil)) (FreeAddMonoid.of x)","decl":"@[to_additive]\ntheorem ofList_singleton (x : α) : ofList [x] = of x := rfl\n\n"}
{"name":"FreeMonoid.ofList_cons","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nx : α\nxs : List α\n⊢ Eq (FreeMonoid.ofList (List.cons x xs)) (HMul.hMul (FreeMonoid.of x) (FreeMonoid.ofList xs))","decl":"@[to_additive (attr := simp)]\ntheorem ofList_cons (x : α) (xs : List α) : ofList (x :: xs) = of x * ofList xs := rfl\n\n"}
{"name":"FreeAddMonoid.ofList_cons","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nx : α\nxs : List α\n⊢ Eq (FreeAddMonoid.ofList (List.cons x xs)) (HAdd.hAdd (FreeAddMonoid.of x) (FreeAddMonoid.ofList xs))","decl":"@[to_additive (attr := simp)]\ntheorem ofList_cons (x : α) (xs : List α) : ofList (x :: xs) = of x * ofList xs := rfl\n\n"}
{"name":"FreeAddMonoid.toList_of_add","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nx : α\nxs : FreeAddMonoid α\n⊢ Eq (FreeAddMonoid.toList (HAdd.hAdd (FreeAddMonoid.of x) xs)) (List.cons x (FreeAddMonoid.toList xs))","decl":"@[to_additive]\ntheorem toList_of_mul (x : α) (xs : FreeMonoid α) : toList (of x * xs) = x :: toList xs := rfl\n\n"}
{"name":"FreeMonoid.toList_of_mul","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nx : α\nxs : FreeMonoid α\n⊢ Eq (FreeMonoid.toList (HMul.hMul (FreeMonoid.of x) xs)) (List.cons x (FreeMonoid.toList xs))","decl":"@[to_additive]\ntheorem toList_of_mul (x : α) (xs : FreeMonoid α) : toList (of x * xs) = x :: toList xs := rfl\n\n"}
{"name":"FreeAddMonoid.of_injective","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\n⊢ Function.Injective FreeAddMonoid.of","decl":"@[to_additive]\ntheorem of_injective : Function.Injective (@of α) := List.singleton_injective\n\n"}
{"name":"FreeMonoid.of_injective","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\n⊢ Function.Injective FreeMonoid.of","decl":"@[to_additive]\ntheorem of_injective : Function.Injective (@of α) := List.singleton_injective\n\n"}
{"name":"FreeMonoid.length_one","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\n⊢ Eq (FreeMonoid.length 1) 0","decl":"@[to_additive (attr := simp)]\ntheorem length_one : length (1 : FreeMonoid α) = 0 := rfl\n\n"}
{"name":"FreeAddMonoid.length_zero","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\n⊢ Eq (FreeAddMonoid.length 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem length_one : length (1 : FreeMonoid α) = 0 := rfl\n\n"}
{"name":"FreeMonoid.length_eq_zero","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\na : FreeMonoid α\n⊢ Iff (Eq a.length 0) (Eq a 1)","decl":"@[to_additive (attr := simp)]\ntheorem length_eq_zero : length a = 0 ↔ a = 1 := List.length_eq_zero\n\n"}
{"name":"FreeAddMonoid.length_eq_zero","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\na : FreeAddMonoid α\n⊢ Iff (Eq a.length 0) (Eq a 0)","decl":"@[to_additive (attr := simp)]\ntheorem length_eq_zero : length a = 0 ↔ a = 1 := List.length_eq_zero\n\n"}
{"name":"FreeMonoid.length_of","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nm : α\n⊢ Eq (FreeMonoid.of m).length 1","decl":"@[to_additive (attr := simp)]\ntheorem length_of (m : α) : length (of m) = 1 := rfl\n\n"}
{"name":"FreeAddMonoid.length_of","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nm : α\n⊢ Eq (FreeAddMonoid.of m).length 1","decl":"@[to_additive (attr := simp)]\ntheorem length_of (m : α) : length (of m) = 1 := rfl\n\n"}
{"name":"FreeMonoid.length_eq_one","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\na : FreeMonoid α\n⊢ Iff (Eq a.length 1) (Exists fun m => Eq a (FreeMonoid.of m))","decl":"@[to_additive existing]\ntheorem length_eq_one : length a = 1 ↔ ∃ m, a = FreeMonoid.of m :=\n  List.length_eq_one\n\n"}
{"name":"FreeAddMonoid.length_eq_two","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nv : FreeAddMonoid α\n⊢ Iff (Eq v.length 2) (Exists fun c => Exists fun d => Eq v (HAdd.hAdd (FreeAddMonoid.of c) (FreeAddMonoid.of d)))","decl":"@[to_additive]\ntheorem length_eq_two {v : FreeMonoid α} :\n    v.length = 2 ↔ ∃ c d, v = FreeMonoid.of c * FreeMonoid.of d := List.length_eq_two\n\n"}
{"name":"FreeMonoid.length_eq_two","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nv : FreeMonoid α\n⊢ Iff (Eq v.length 2) (Exists fun c => Exists fun d => Eq v (HMul.hMul (FreeMonoid.of c) (FreeMonoid.of d)))","decl":"@[to_additive]\ntheorem length_eq_two {v : FreeMonoid α} :\n    v.length = 2 ↔ ∃ c d, v = FreeMonoid.of c * FreeMonoid.of d := List.length_eq_two\n\n"}
{"name":"FreeAddMonoid.length_eq_three","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nv : FreeAddMonoid α\n⊢ Iff (Eq v.length 3) (Exists fun a => Exists fun b => Exists fun c => Eq v (HAdd.hAdd (HAdd.hAdd (FreeAddMonoid.of a) (FreeAddMonoid.of b)) (FreeAddMonoid.of c)))","decl":"@[to_additive]\ntheorem length_eq_three {v : FreeMonoid α} : v.length = 3 ↔ ∃ (a b c : α), v = of a * of b * of c :=\n  List.length_eq_three\n\n"}
{"name":"FreeMonoid.length_eq_three","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nv : FreeMonoid α\n⊢ Iff (Eq v.length 3) (Exists fun a => Exists fun b => Exists fun c => Eq v (HMul.hMul (HMul.hMul (FreeMonoid.of a) (FreeMonoid.of b)) (FreeMonoid.of c)))","decl":"@[to_additive]\ntheorem length_eq_three {v : FreeMonoid α} : v.length = 3 ↔ ∃ (a b c : α), v = of a * of b * of c :=\n  List.length_eq_three\n\n"}
{"name":"FreeMonoid.length_mul","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\na b : FreeMonoid α\n⊢ Eq (HMul.hMul a b).length (HAdd.hAdd a.length b.length)","decl":"@[to_additive (attr := simp)]\ntheorem length_mul (a b : FreeMonoid α) : (a * b).length = a.length + b.length :=\n  List.length_append _ _\n\n"}
{"name":"FreeAddMonoid.length_add","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\na b : FreeAddMonoid α\n⊢ Eq (HAdd.hAdd a b).length (HAdd.hAdd a.length b.length)","decl":"@[to_additive (attr := simp)]\ntheorem length_mul (a b : FreeMonoid α) : (a * b).length = a.length + b.length :=\n  List.length_append _ _\n\n"}
{"name":"FreeMonoid.of_ne_one","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\na : α\n⊢ Ne (FreeMonoid.of a) 1","decl":"@[to_additive (attr := simp)]\ntheorem of_ne_one (a : α) : of a ≠ 1 := by\n  intro h\n  have := congrArg FreeMonoid.length h\n  simp only [length_of, length_one, Nat.succ_ne_self] at this\n\n"}
{"name":"FreeAddMonoid.of_ne_zero","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\na : α\n⊢ Ne (FreeAddMonoid.of a) 0","decl":"@[to_additive (attr := simp)]\ntheorem of_ne_one (a : α) : of a ≠ 1 := by\n  intro h\n  have := congrArg FreeMonoid.length h\n  simp only [length_of, length_one, Nat.succ_ne_self] at this\n\n"}
{"name":"FreeMonoid.one_ne_of","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\na : α\n⊢ Ne 1 (FreeMonoid.of a)","decl":"@[to_additive (attr := simp)]\ntheorem one_ne_of (a : α) : 1 ≠ of a := of_ne_one _ |>.symm\n\n"}
{"name":"FreeAddMonoid.zero_ne_of","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\na : α\n⊢ Ne 0 (FreeAddMonoid.of a)","decl":"@[to_additive (attr := simp)]\ntheorem one_ne_of (a : α) : 1 ≠ of a := of_ne_one _ |>.symm\n\n"}
{"name":"FreeAddMonoid.not_mem_zero","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nm : α\n⊢ Not (Membership.mem 0 m)","decl":"@[to_additive]\ntheorem not_mem_one : ¬ m ∈ (1 : FreeMonoid α) := List.not_mem_nil _\n\n"}
{"name":"FreeMonoid.not_mem_one","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nm : α\n⊢ Not (Membership.mem 1 m)","decl":"@[to_additive]\ntheorem not_mem_one : ¬ m ∈ (1 : FreeMonoid α) := List.not_mem_nil _\n\n"}
{"name":"FreeAddMonoid.mem_of","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nm n : α\n⊢ Iff (Membership.mem (FreeAddMonoid.of n) m) (Eq m n)","decl":"@[to_additive (attr := simp)]\ntheorem mem_of {n : α} : m ∈ of n ↔ m = n := List.mem_singleton\n\n"}
{"name":"FreeMonoid.mem_of","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nm n : α\n⊢ Iff (Membership.mem (FreeMonoid.of n) m) (Eq m n)","decl":"@[to_additive (attr := simp)]\ntheorem mem_of {n : α} : m ∈ of n ↔ m = n := List.mem_singleton\n\n"}
{"name":"FreeMonoid.mem_of_self","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nm : α\n⊢ Membership.mem (FreeMonoid.of m) m","decl":"@[to_additive]\ntheorem mem_of_self : m ∈ of m := List.mem_singleton_self _\n\n"}
{"name":"FreeAddMonoid.mem_of_self","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nm : α\n⊢ Membership.mem (FreeAddMonoid.of m) m","decl":"@[to_additive]\ntheorem mem_of_self : m ∈ of m := List.mem_singleton_self _\n\n"}
{"name":"FreeMonoid.mem_mul","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nm : α\na b : FreeMonoid α\n⊢ Iff (Membership.mem (HMul.hMul a b) m) (Or (Membership.mem a m) (Membership.mem b m))","decl":"@[to_additive (attr := simp)]\ntheorem mem_mul {a b : FreeMonoid α} : m ∈ (a * b) ↔ m ∈ a ∨ m ∈ b := List.mem_append\n\n"}
{"name":"FreeAddMonoid.mem_add","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nm : α\na b : FreeAddMonoid α\n⊢ Iff (Membership.mem (HAdd.hAdd a b) m) (Or (Membership.mem a m) (Membership.mem b m))","decl":"@[to_additive (attr := simp)]\ntheorem mem_mul {a b : FreeMonoid α} : m ∈ (a * b) ↔ m ∈ a ∨ m ∈ b := List.mem_append\n\n"}
{"name":"FreeAddMonoid.recOn_zero","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nC : FreeAddMonoid α → Sort u_6\nh0 : C 0\nih : (x : α) → (xs : FreeAddMonoid α) → C xs → C (HAdd.hAdd (FreeAddMonoid.of x) xs)\n⊢ Eq (FreeAddMonoid.recOn 0 h0 ih) h0","decl":"@[to_additive (attr := simp)]\ntheorem recOn_one {C : FreeMonoid α → Sort*} (h0 : C 1) (ih : ∀ x xs, C xs → C (of x * xs)) :\n    @recOn α C 1 h0 ih = h0 := rfl\n\n"}
{"name":"FreeMonoid.recOn_one","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nC : FreeMonoid α → Sort u_6\nh0 : C 1\nih : (x : α) → (xs : FreeMonoid α) → C xs → C (HMul.hMul (FreeMonoid.of x) xs)\n⊢ Eq (FreeMonoid.recOn 1 h0 ih) h0","decl":"@[to_additive (attr := simp)]\ntheorem recOn_one {C : FreeMonoid α → Sort*} (h0 : C 1) (ih : ∀ x xs, C xs → C (of x * xs)) :\n    @recOn α C 1 h0 ih = h0 := rfl\n\n"}
{"name":"FreeAddMonoid.recOn_of_add","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nC : FreeAddMonoid α → Sort u_6\nx : α\nxs : FreeAddMonoid α\nh0 : C 0\nih : (x : α) → (xs : FreeAddMonoid α) → C xs → C (HAdd.hAdd (FreeAddMonoid.of x) xs)\n⊢ Eq ((HAdd.hAdd (FreeAddMonoid.of x) xs).recOn h0 ih) (ih x xs (xs.recOn h0 ih))","decl":"@[to_additive (attr := simp)]\ntheorem recOn_of_mul {C : FreeMonoid α → Sort*} (x : α) (xs : FreeMonoid α) (h0 : C 1)\n    (ih : ∀ x xs, C xs → C (of x * xs)) : @recOn α C (of x * xs) h0 ih = ih x xs (recOn xs h0 ih) :=\n  rfl\n\n"}
{"name":"FreeMonoid.recOn_of_mul","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nC : FreeMonoid α → Sort u_6\nx : α\nxs : FreeMonoid α\nh0 : C 1\nih : (x : α) → (xs : FreeMonoid α) → C xs → C (HMul.hMul (FreeMonoid.of x) xs)\n⊢ Eq ((HMul.hMul (FreeMonoid.of x) xs).recOn h0 ih) (ih x xs (xs.recOn h0 ih))","decl":"@[to_additive (attr := simp)]\ntheorem recOn_of_mul {C : FreeMonoid α → Sort*} (x : α) (xs : FreeMonoid α) (h0 : C 1)\n    (ih : ∀ x xs, C xs → C (of x * xs)) : @recOn α C (of x * xs) h0 ih = ih x xs (recOn xs h0 ih) :=\n  rfl\n\n"}
{"name":"FreeMonoid.inductionOn","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nC : FreeMonoid α → Prop\nz : FreeMonoid α\none : C 1\nof : ∀ (x : α), C (FreeMonoid.of x)\nmul : ∀ (x y : FreeMonoid α), C x → C y → C (HMul.hMul x y)\n⊢ C z","decl":"/-- An induction principle on free monoids, with cases for `1`, `FreeMonoid.of` and `*`. -/\n@[to_additive (attr := elab_as_elim, induction_eliminator)\n\"An induction principle on free monoids, with cases for `0`, `FreeAddMonoid.of` and `+`.\"]\nprotected theorem inductionOn {C : FreeMonoid α → Prop} (z : FreeMonoid α) (one : C 1)\n    (of : ∀ (x : α), C (FreeMonoid.of x)) (mul : ∀ (x y : FreeMonoid α), C x → C y → C (x * y)) :\n  C z := List.rec one (fun _ _ ih => mul [_] _ (of _) ih) z\n\n"}
{"name":"FreeAddMonoid.inductionOn","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nC : FreeAddMonoid α → Prop\nz : FreeAddMonoid α\none : C 0\nof : ∀ (x : α), C (FreeAddMonoid.of x)\nmul : ∀ (x y : FreeAddMonoid α), C x → C y → C (HAdd.hAdd x y)\n⊢ C z","decl":"/-- An induction principle on free monoids, with cases for `1`, `FreeMonoid.of` and `*`. -/\n@[to_additive (attr := elab_as_elim, induction_eliminator)\n\"An induction principle on free monoids, with cases for `0`, `FreeAddMonoid.of` and `+`.\"]\nprotected theorem inductionOn {C : FreeMonoid α → Prop} (z : FreeMonoid α) (one : C 1)\n    (of : ∀ (x : α), C (FreeMonoid.of x)) (mul : ∀ (x y : FreeMonoid α), C x → C y → C (x * y)) :\n  C z := List.rec one (fun _ _ ih => mul [_] _ (of _) ih) z\n\n"}
{"name":"FreeMonoid.inductionOn'","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\np : FreeMonoid α → Prop\na : FreeMonoid α\none : p 1\nmul_of : ∀ (b : α) (a : FreeMonoid α), p a → p (HMul.hMul (FreeMonoid.of b) a)\n⊢ p a","decl":"/-- An induction principle for free monoids which mirrors induction on lists, with cases analogous\nto the empty list and cons -/\n@[to_additive (attr := elab_as_elim) \"An induction principle for free monoids which mirrors\ninduction on lists, with cases analogous to the empty list and cons\"]\nprotected theorem inductionOn' {p : FreeMonoid α → Prop} (a : FreeMonoid α)\n    (one : p (1 : FreeMonoid α)) (mul_of : ∀ b a, p a → p (of b * a)) : p a :=\n  List.rec one (fun _ _ tail_ih => mul_of _ _ tail_ih) a\n\n"}
{"name":"FreeAddMonoid.inductionOn'","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\np : FreeAddMonoid α → Prop\na : FreeAddMonoid α\none : p 0\nmul_of : ∀ (b : α) (a : FreeAddMonoid α), p a → p (HAdd.hAdd (FreeAddMonoid.of b) a)\n⊢ p a","decl":"/-- An induction principle for free monoids which mirrors induction on lists, with cases analogous\nto the empty list and cons -/\n@[to_additive (attr := elab_as_elim) \"An induction principle for free monoids which mirrors\ninduction on lists, with cases analogous to the empty list and cons\"]\nprotected theorem inductionOn' {p : FreeMonoid α → Prop} (a : FreeMonoid α)\n    (one : p (1 : FreeMonoid α)) (mul_of : ∀ b a, p a → p (of b * a)) : p a :=\n  List.rec one (fun _ _ tail_ih => mul_of _ _ tail_ih) a\n\n"}
{"name":"FreeMonoid.casesOn_one","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nC : FreeMonoid α → Sort u_6\nh0 : C 1\nih : (x : α) → (xs : FreeMonoid α) → C (HMul.hMul (FreeMonoid.of x) xs)\n⊢ Eq (FreeMonoid.casesOn 1 h0 ih) h0","decl":"@[to_additive (attr := simp)]\ntheorem casesOn_one {C : FreeMonoid α → Sort*} (h0 : C 1) (ih : ∀ x xs, C (of x * xs)) :\n    @casesOn α C 1 h0 ih = h0 := rfl\n\n"}
{"name":"FreeAddMonoid.casesOn_zero","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nC : FreeAddMonoid α → Sort u_6\nh0 : C 0\nih : (x : α) → (xs : FreeAddMonoid α) → C (HAdd.hAdd (FreeAddMonoid.of x) xs)\n⊢ Eq (FreeAddMonoid.casesOn 0 h0 ih) h0","decl":"@[to_additive (attr := simp)]\ntheorem casesOn_one {C : FreeMonoid α → Sort*} (h0 : C 1) (ih : ∀ x xs, C (of x * xs)) :\n    @casesOn α C 1 h0 ih = h0 := rfl\n\n"}
{"name":"FreeMonoid.casesOn_of_mul","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nC : FreeMonoid α → Sort u_6\nx : α\nxs : FreeMonoid α\nh0 : C 1\nih : (x : α) → (xs : FreeMonoid α) → C (HMul.hMul (FreeMonoid.of x) xs)\n⊢ Eq ((HMul.hMul (FreeMonoid.of x) xs).casesOn h0 ih) (ih x xs)","decl":"@[to_additive (attr := simp)]\ntheorem casesOn_of_mul {C : FreeMonoid α → Sort*} (x : α) (xs : FreeMonoid α) (h0 : C 1)\n    (ih : ∀ x xs, C (of x * xs)) : @casesOn α C (of x * xs) h0 ih = ih x xs := rfl\n\n"}
{"name":"FreeAddMonoid.casesOn_of_add","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nC : FreeAddMonoid α → Sort u_6\nx : α\nxs : FreeAddMonoid α\nh0 : C 0\nih : (x : α) → (xs : FreeAddMonoid α) → C (HAdd.hAdd (FreeAddMonoid.of x) xs)\n⊢ Eq ((HAdd.hAdd (FreeAddMonoid.of x) xs).casesOn h0 ih) (ih x xs)","decl":"@[to_additive (attr := simp)]\ntheorem casesOn_of_mul {C : FreeMonoid α → Sort*} (x : α) (xs : FreeMonoid α) (h0 : C 1)\n    (ih : ∀ x xs, C (of x * xs)) : @casesOn α C (of x * xs) h0 ih = ih x xs := rfl\n\n"}
{"name":"FreeAddMonoid.hom_eq","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝ : AddMonoid M\nf g : AddMonoidHom (FreeAddMonoid α) M\nh : ∀ (x : α), Eq (f (FreeAddMonoid.of x)) (g (FreeAddMonoid.of x))\n⊢ Eq f g","decl":"@[to_additive (attr := ext)]\ntheorem hom_eq ⦃f g : FreeMonoid α →* M⦄ (h : ∀ x, f (of x) = g (of x)) : f = g :=\n  MonoidHom.ext fun l ↦ recOn l (f.map_one.trans g.map_one.symm)\n    (fun x xs hxs ↦ by simp only [h, hxs, MonoidHom.map_mul])\n\n"}
{"name":"FreeAddMonoid.hom_eq_iff","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝ : AddMonoid M\nf g : AddMonoidHom (FreeAddMonoid α) M\n⊢ Iff (Eq f g) (∀ (x : α), Eq (f (FreeAddMonoid.of x)) (g (FreeAddMonoid.of x)))","decl":"@[to_additive (attr := ext)]\ntheorem hom_eq ⦃f g : FreeMonoid α →* M⦄ (h : ∀ x, f (of x) = g (of x)) : f = g :=\n  MonoidHom.ext fun l ↦ recOn l (f.map_one.trans g.map_one.symm)\n    (fun x xs hxs ↦ by simp only [h, hxs, MonoidHom.map_mul])\n\n"}
{"name":"FreeMonoid.hom_eq","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝ : Monoid M\nf g : MonoidHom (FreeMonoid α) M\nh : ∀ (x : α), Eq (f (FreeMonoid.of x)) (g (FreeMonoid.of x))\n⊢ Eq f g","decl":"@[to_additive (attr := ext)]\ntheorem hom_eq ⦃f g : FreeMonoid α →* M⦄ (h : ∀ x, f (of x) = g (of x)) : f = g :=\n  MonoidHom.ext fun l ↦ recOn l (f.map_one.trans g.map_one.symm)\n    (fun x xs hxs ↦ by simp only [h, hxs, MonoidHom.map_mul])\n\n"}
{"name":"FreeMonoid.hom_eq_iff","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝ : Monoid M\nf g : MonoidHom (FreeMonoid α) M\n⊢ Iff (Eq f g) (∀ (x : α), Eq (f (FreeMonoid.of x)) (g (FreeMonoid.of x)))","decl":"@[to_additive (attr := ext)]\ntheorem hom_eq ⦃f g : FreeMonoid α →* M⦄ (h : ∀ x, f (of x) = g (of x)) : f = g :=\n  MonoidHom.ext fun l ↦ recOn l (f.map_one.trans g.map_one.symm)\n    (fun x xs hxs ↦ by simp only [h, hxs, MonoidHom.map_mul])\n\n"}
{"name":"FreeAddMonoid.sumAux_eq","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nl : List M\n⊢ Eq (FreeAddMonoid.sumAux l) l.sum","decl":"@[to_additive]\nlemma prodAux_eq : ∀ l : List M, FreeMonoid.prodAux l = l.prod\n  | [] => rfl\n  | (_ :: xs) => by simp [prodAux, List.prod_eq_foldl]\n\n"}
{"name":"FreeMonoid.prodAux_eq","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nl : List M\n⊢ Eq (FreeMonoid.prodAux l) l.prod","decl":"@[to_additive]\nlemma prodAux_eq : ∀ l : List M, FreeMonoid.prodAux l = l.prod\n  | [] => rfl\n  | (_ :: xs) => by simp [prodAux, List.prod_eq_foldl]\n\n"}
{"name":"FreeMonoid.lift_ofList","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝ : Monoid M\nf : α → M\nl : List α\n⊢ Eq ((FreeMonoid.lift f) (FreeMonoid.ofList l)) (List.map f l).prod","decl":"@[to_additive (attr := simp)]\ntheorem lift_ofList (f : α → M) (l : List α) : lift f (ofList l) = (l.map f).prod :=\n  prodAux_eq _\n\n"}
{"name":"FreeAddMonoid.lift_ofList","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝ : AddMonoid M\nf : α → M\nl : List α\n⊢ Eq ((FreeAddMonoid.lift f) (FreeAddMonoid.ofList l)) (List.map f l).sum","decl":"@[to_additive (attr := simp)]\ntheorem lift_ofList (f : α → M) (l : List α) : lift f (ofList l) = (l.map f).prod :=\n  prodAux_eq _\n\n"}
{"name":"FreeAddMonoid.lift_symm_apply","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝ : AddMonoid M\nf : AddMonoidHom (FreeAddMonoid α) M\n⊢ Eq (FreeAddMonoid.lift.symm f) (Function.comp (⇑f) FreeAddMonoid.of)","decl":"@[to_additive (attr := simp)]\ntheorem lift_symm_apply (f : FreeMonoid α →* M) : lift.symm f = f ∘ of := rfl\n\n"}
{"name":"FreeMonoid.lift_symm_apply","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝ : Monoid M\nf : MonoidHom (FreeMonoid α) M\n⊢ Eq (FreeMonoid.lift.symm f) (Function.comp (⇑f) FreeMonoid.of)","decl":"@[to_additive (attr := simp)]\ntheorem lift_symm_apply (f : FreeMonoid α →* M) : lift.symm f = f ∘ of := rfl\n\n"}
{"name":"FreeAddMonoid.lift_apply","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝ : AddMonoid M\nf : α → M\nl : FreeAddMonoid α\n⊢ Eq ((FreeAddMonoid.lift f) l) (List.map f (FreeAddMonoid.toList l)).sum","decl":"@[to_additive]\ntheorem lift_apply (f : α → M) (l : FreeMonoid α) : lift f l = ((toList l).map f).prod :=\n  prodAux_eq _\n\n"}
{"name":"FreeMonoid.lift_apply","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝ : Monoid M\nf : α → M\nl : FreeMonoid α\n⊢ Eq ((FreeMonoid.lift f) l) (List.map f (FreeMonoid.toList l)).prod","decl":"@[to_additive]\ntheorem lift_apply (f : α → M) (l : FreeMonoid α) : lift f l = ((toList l).map f).prod :=\n  prodAux_eq _\n\n"}
{"name":"FreeAddMonoid.lift_comp_of","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝ : AddMonoid M\nf : α → M\n⊢ Eq (Function.comp (⇑(FreeAddMonoid.lift f)) FreeAddMonoid.of) f","decl":"@[to_additive]\ntheorem lift_comp_of (f : α → M) : lift f ∘ of = f := rfl\n\n"}
{"name":"FreeMonoid.lift_comp_of","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝ : Monoid M\nf : α → M\n⊢ Eq (Function.comp (⇑(FreeMonoid.lift f)) FreeMonoid.of) f","decl":"@[to_additive]\ntheorem lift_comp_of (f : α → M) : lift f ∘ of = f := rfl\n\n"}
{"name":"FreeMonoid.lift_eval_of","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝ : Monoid M\nf : α → M\nx : α\n⊢ Eq ((FreeMonoid.lift f) (FreeMonoid.of x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_eval_of (f : α → M) (x : α) : lift f (of x) = f x := rfl\n\n"}
{"name":"FreeAddMonoid.lift_eval_of","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝ : AddMonoid M\nf : α → M\nx : α\n⊢ Eq ((FreeAddMonoid.lift f) (FreeAddMonoid.of x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_eval_of (f : α → M) (x : α) : lift f (of x) = f x := rfl\n\n"}
{"name":"FreeMonoid.lift_restrict","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝ : Monoid M\nf : MonoidHom (FreeMonoid α) M\n⊢ Eq (FreeMonoid.lift (Function.comp (⇑f) FreeMonoid.of)) f","decl":"@[to_additive (attr := simp)]\ntheorem lift_restrict (f : FreeMonoid α →* M) : lift (f ∘ of) = f := lift.apply_symm_apply f\n\n"}
{"name":"FreeAddMonoid.lift_restrict","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝ : AddMonoid M\nf : AddMonoidHom (FreeAddMonoid α) M\n⊢ Eq (FreeAddMonoid.lift (Function.comp (⇑f) FreeAddMonoid.of)) f","decl":"@[to_additive (attr := simp)]\ntheorem lift_restrict (f : FreeMonoid α →* M) : lift (f ∘ of) = f := lift.apply_symm_apply f\n\n"}
{"name":"FreeMonoid.comp_lift","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝¹ : Monoid M\nN : Type u_5\ninst✝ : Monoid N\ng : MonoidHom M N\nf : α → M\n⊢ Eq (g.comp (FreeMonoid.lift f)) (FreeMonoid.lift (Function.comp (⇑g) f))","decl":"@[to_additive]\ntheorem comp_lift (g : M →* N) (f : α → M) : g.comp (lift f) = lift (g ∘ f) := by\n  ext\n  simp\n\n"}
{"name":"FreeAddMonoid.comp_lift","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝¹ : AddMonoid M\nN : Type u_5\ninst✝ : AddMonoid N\ng : AddMonoidHom M N\nf : α → M\n⊢ Eq (g.comp (FreeAddMonoid.lift f)) (FreeAddMonoid.lift (Function.comp (⇑g) f))","decl":"@[to_additive]\ntheorem comp_lift (g : M →* N) (f : α → M) : g.comp (lift f) = lift (g ∘ f) := by\n  ext\n  simp\n\n"}
{"name":"FreeMonoid.hom_map_lift","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝¹ : Monoid M\nN : Type u_5\ninst✝ : Monoid N\ng : MonoidHom M N\nf : α → M\nx : FreeMonoid α\n⊢ Eq (g ((FreeMonoid.lift f) x)) ((FreeMonoid.lift (Function.comp (⇑g) f)) x)","decl":"@[to_additive]\ntheorem hom_map_lift (g : M →* N) (f : α → M) (x : FreeMonoid α) : g (lift f x) = lift (g ∘ f) x :=\n  DFunLike.ext_iff.1 (comp_lift g f) x\n\n"}
{"name":"FreeAddMonoid.hom_map_lift","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝¹ : AddMonoid M\nN : Type u_5\ninst✝ : AddMonoid N\ng : AddMonoidHom M N\nf : α → M\nx : FreeAddMonoid α\n⊢ Eq (g ((FreeAddMonoid.lift f) x)) ((FreeAddMonoid.lift (Function.comp (⇑g) f)) x)","decl":"@[to_additive]\ntheorem hom_map_lift (g : M →* N) (f : α → M) (x : FreeMonoid α) : g (lift f x) = lift (g ∘ f) x :=\n  DFunLike.ext_iff.1 (comp_lift g f) x\n\n"}
{"name":"FreeAddMonoid.vadd_def","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β → β\nl : FreeAddMonoid α\nb : β\n⊢ Eq (HVAdd.hVAdd l b) (List.foldr f b (FreeAddMonoid.toList l))","decl":"@[to_additive]\ntheorem smul_def (f : α → β → β) (l : FreeMonoid α) (b : β) :\n    haveI := mkMulAction f\n    l • b = l.toList.foldr f b := rfl\n\n"}
{"name":"FreeMonoid.smul_def","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β → β\nl : FreeMonoid α\nb : β\n⊢ Eq (HSMul.hSMul l b) (List.foldr f b (FreeMonoid.toList l))","decl":"@[to_additive]\ntheorem smul_def (f : α → β → β) (l : FreeMonoid α) (b : β) :\n    haveI := mkMulAction f\n    l • b = l.toList.foldr f b := rfl\n\n"}
{"name":"FreeMonoid.ofList_smul","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β → β\nl : List α\nb : β\n⊢ Eq (HSMul.hSMul (FreeMonoid.ofList l) b) (List.foldr f b l)","decl":"@[to_additive]\ntheorem ofList_smul (f : α → β → β) (l : List α) (b : β) :\n    haveI := mkMulAction f\n    ofList l • b = l.foldr f b := rfl\n\n"}
{"name":"FreeAddMonoid.ofList_vadd","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β → β\nl : List α\nb : β\n⊢ Eq (HVAdd.hVAdd (FreeAddMonoid.ofList l) b) (List.foldr f b l)","decl":"@[to_additive]\ntheorem ofList_smul (f : α → β → β) (l : List α) (b : β) :\n    haveI := mkMulAction f\n    ofList l • b = l.foldr f b := rfl\n\n"}
{"name":"FreeMonoid.of_smul","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β → β\nx : α\ny : β\n⊢ Eq (HSMul.hSMul (FreeMonoid.of x) y) (f x y)","decl":"@[to_additive (attr := simp)]\ntheorem of_smul (f : α → β → β) (x : α) (y : β) :\n    (haveI := mkMulAction f\n    of x • y) = f x y := rfl\n\n"}
{"name":"FreeAddMonoid.of_vadd","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β → β\nx : α\ny : β\n⊢ Eq (HVAdd.hVAdd (FreeAddMonoid.of x) y) (f x y)","decl":"@[to_additive (attr := simp)]\ntheorem of_smul (f : α → β → β) (x : α) (y : β) :\n    (haveI := mkMulAction f\n    of x • y) = f x y := rfl\n\n"}
{"name":"FreeAddMonoid.map_of","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx : α\n⊢ Eq ((FreeAddMonoid.map f) (FreeAddMonoid.of x)) (FreeAddMonoid.of (f x))","decl":"@[to_additive (attr := simp)]\ntheorem map_of (f : α → β) (x : α) : map f (of x) = of (f x) := rfl\n\n"}
{"name":"FreeMonoid.map_of","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx : α\n⊢ Eq ((FreeMonoid.map f) (FreeMonoid.of x)) (FreeMonoid.of (f x))","decl":"@[to_additive (attr := simp)]\ntheorem map_of (f : α → β) (x : α) : map f (of x) = of (f x) := rfl\n\n"}
{"name":"FreeAddMonoid.mem_map","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : FreeAddMonoid α\nm : β\n⊢ Iff (Membership.mem ((FreeAddMonoid.map f) a) m) (Exists fun n => And (Membership.mem a n) (Eq (f n) m))","decl":"@[to_additive]\ntheorem mem_map {m : β} : m ∈ map f a ↔ ∃ n ∈ a, f n = m := List.mem_map\n\n"}
{"name":"FreeMonoid.mem_map","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : FreeMonoid α\nm : β\n⊢ Iff (Membership.mem ((FreeMonoid.map f) a) m) (Exists fun n => And (Membership.mem a n) (Eq (f n) m))","decl":"@[to_additive]\ntheorem mem_map {m : β} : m ∈ map f a ↔ ∃ n ∈ a, f n = m := List.mem_map\n\n"}
{"name":"FreeAddMonoid.map_map","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nα₁ : Type u_6\ng : α₁ → α\nx : FreeAddMonoid α₁\n⊢ Eq ((FreeAddMonoid.map f) ((FreeAddMonoid.map g) x)) ((FreeAddMonoid.map (Function.comp f g)) x)","decl":"@[to_additive]\ntheorem map_map {α₁ : Type*} {g : α₁ → α} {x : FreeMonoid α₁} :\n    map f (map g x) = map (f ∘ g) x := by\n  unfold map\n  simp only [MonoidHom.coe_mk, OneHom.coe_mk, toList_ofList, List.map_map]\n\n"}
{"name":"FreeMonoid.map_map","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nα₁ : Type u_6\ng : α₁ → α\nx : FreeMonoid α₁\n⊢ Eq ((FreeMonoid.map f) ((FreeMonoid.map g) x)) ((FreeMonoid.map (Function.comp f g)) x)","decl":"@[to_additive]\ntheorem map_map {α₁ : Type*} {g : α₁ → α} {x : FreeMonoid α₁} :\n    map f (map g x) = map (f ∘ g) x := by\n  unfold map\n  simp only [MonoidHom.coe_mk, OneHom.coe_mk, toList_ofList, List.map_map]\n\n"}
{"name":"FreeAddMonoid.toList_map","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nxs : FreeAddMonoid α\n⊢ Eq (FreeAddMonoid.toList ((FreeAddMonoid.map f) xs)) (List.map f (FreeAddMonoid.toList xs))","decl":"@[to_additive]\ntheorem toList_map (f : α → β) (xs : FreeMonoid α) : toList (map f xs) = xs.toList.map f := rfl\n\n"}
{"name":"FreeMonoid.toList_map","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nxs : FreeMonoid α\n⊢ Eq (FreeMonoid.toList ((FreeMonoid.map f) xs)) (List.map f (FreeMonoid.toList xs))","decl":"@[to_additive]\ntheorem toList_map (f : α → β) (xs : FreeMonoid α) : toList (map f xs) = xs.toList.map f := rfl\n\n"}
{"name":"FreeAddMonoid.ofList_map","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nxs : List α\n⊢ Eq (FreeAddMonoid.ofList (List.map f xs)) ((FreeAddMonoid.map f) (FreeAddMonoid.ofList xs))","decl":"@[to_additive]\ntheorem ofList_map (f : α → β) (xs : List α) : ofList (xs.map f) = map f (ofList xs) := rfl\n\n"}
{"name":"FreeMonoid.ofList_map","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nxs : List α\n⊢ Eq (FreeMonoid.ofList (List.map f xs)) ((FreeMonoid.map f) (FreeMonoid.ofList xs))","decl":"@[to_additive]\ntheorem ofList_map (f : α → β) (xs : List α) : ofList (xs.map f) = map f (ofList xs) := rfl\n\n"}
{"name":"FreeMonoid.lift_of_comp_eq_map","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (FreeMonoid.lift fun x => FreeMonoid.of (f x)) (FreeMonoid.map f)","decl":"@[to_additive]\ntheorem lift_of_comp_eq_map (f : α → β) : (lift fun x ↦ of (f x)) = map f := hom_eq fun _ ↦ rfl\n\n"}
{"name":"FreeAddMonoid.lift_of_comp_eq_map","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (FreeAddMonoid.lift fun x => FreeAddMonoid.of (f x)) (FreeAddMonoid.map f)","decl":"@[to_additive]\ntheorem lift_of_comp_eq_map (f : α → β) : (lift fun x ↦ of (f x)) = map f := hom_eq fun _ ↦ rfl\n\n"}
{"name":"FreeAddMonoid.map_comp","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ng : β → γ\nf : α → β\n⊢ Eq (FreeAddMonoid.map (Function.comp g f)) ((FreeAddMonoid.map g).comp (FreeAddMonoid.map f))","decl":"@[to_additive]\ntheorem map_comp (g : β → γ) (f : α → β) : map (g ∘ f) = (map g).comp (map f) := hom_eq fun _ ↦ rfl\n\n"}
{"name":"FreeMonoid.map_comp","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ng : β → γ\nf : α → β\n⊢ Eq (FreeMonoid.map (Function.comp g f)) ((FreeMonoid.map g).comp (FreeMonoid.map f))","decl":"@[to_additive]\ntheorem map_comp (g : β → γ) (f : α → β) : map (g ∘ f) = (map g).comp (map f) := hom_eq fun _ ↦ rfl\n\n"}
{"name":"FreeMonoid.map_id","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\n⊢ Eq (FreeMonoid.map id) (MonoidHom.id (FreeMonoid α))","decl":"@[to_additive (attr := simp)]\ntheorem map_id : map (@id α) = MonoidHom.id (FreeMonoid α) := hom_eq fun _ ↦ rfl\n\n"}
{"name":"FreeAddMonoid.map_id","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\n⊢ Eq (FreeAddMonoid.map id) (AddMonoidHom.id (FreeAddMonoid α))","decl":"@[to_additive (attr := simp)]\ntheorem map_id : map (@id α) = MonoidHom.id (FreeMonoid α) := hom_eq fun _ ↦ rfl\n\n"}
{"name":"FreeMonoid.map_symm_apply_map_eq","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx : FreeMonoid α\ne : Equiv α β\n⊢ Eq ((FreeMonoid.map ⇑e.symm) ((FreeMonoid.map ⇑e) x)) x","decl":"@[to_additive (attr := simp)]\ntheorem map_symm_apply_map_eq {x : FreeMonoid α} (e : α ≃ β) :\n    (map ⇑e.symm) ((map ⇑e) x) = x := by simp [map_map]\n\n"}
{"name":"FreeAddMonoid.map_symm_apply_map_eq","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx : FreeAddMonoid α\ne : Equiv α β\n⊢ Eq ((FreeAddMonoid.map ⇑e.symm) ((FreeAddMonoid.map ⇑e) x)) x","decl":"@[to_additive (attr := simp)]\ntheorem map_symm_apply_map_eq {x : FreeMonoid α} (e : α ≃ β) :\n    (map ⇑e.symm) ((map ⇑e) x) = x := by simp [map_map]\n\n"}
{"name":"FreeMonoid.map_apply_map_symm_eq","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx : FreeMonoid β\ne : Equiv α β\n⊢ Eq ((FreeMonoid.map ⇑e) ((FreeMonoid.map ⇑e.symm) x)) x","decl":"@[to_additive (attr := simp)]\ntheorem map_apply_map_symm_eq {x : FreeMonoid β} (e : α ≃ β) :\n    (map ⇑e) ((map ⇑e.symm) x) = x := by simp [map_map]\n\n"}
{"name":"FreeAddMonoid.map_apply_map_symm_eq","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx : FreeAddMonoid β\ne : Equiv α β\n⊢ Eq ((FreeAddMonoid.map ⇑e) ((FreeAddMonoid.map ⇑e.symm) x)) x","decl":"@[to_additive (attr := simp)]\ntheorem map_apply_map_symm_eq {x : FreeMonoid β} (e : α ≃ β) :\n    (map ⇑e) ((map ⇑e.symm) x) = x := by simp [map_map]\n\n"}
{"name":"FreeMonoid.map_surjective","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Iff (Function.Surjective ⇑(FreeMonoid.map f)) (Function.Surjective f)","decl":"@[to_additive (attr := simp)]\ntheorem map_surjective {f : α → β} : Function.Surjective (map f) ↔ Function.Surjective f := by\n  constructor\n  · intro fs d\n    rcases fs (FreeMonoid.of d) with ⟨b, hb⟩\n    induction' b using FreeMonoid.inductionOn' with head _ _\n    · have H := congr_arg length hb\n      simp only [length_one, length_of, Nat.zero_ne_one, map_one] at H\n    simp only [map_mul, map_of] at hb\n    use head\n    have H := congr_arg length hb\n    simp only [length_mul, length_of, add_right_eq_self, length_eq_zero] at H\n    rw [H, mul_one] at hb\n    exact FreeMonoid.of_injective hb\n  intro fs d\n  induction' d using FreeMonoid.inductionOn' with head tail ih\n  · use 1\n    rfl\n  specialize fs head\n  rcases fs with ⟨a, rfl⟩\n  rcases ih with ⟨b, rfl⟩\n  use FreeMonoid.of a * b\n  rfl\n\n"}
{"name":"FreeAddMonoid.map_surjective","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Iff (Function.Surjective ⇑(FreeAddMonoid.map f)) (Function.Surjective f)","decl":"@[to_additive (attr := simp)]\ntheorem map_surjective {f : α → β} : Function.Surjective (map f) ↔ Function.Surjective f := by\n  constructor\n  · intro fs d\n    rcases fs (FreeMonoid.of d) with ⟨b, hb⟩\n    induction' b using FreeMonoid.inductionOn' with head _ _\n    · have H := congr_arg length hb\n      simp only [length_one, length_of, Nat.zero_ne_one, map_one] at H\n    simp only [map_mul, map_of] at hb\n    use head\n    have H := congr_arg length hb\n    simp only [length_mul, length_of, add_right_eq_self, length_eq_zero] at H\n    rw [H, mul_one] at hb\n    exact FreeMonoid.of_injective hb\n  intro fs d\n  induction' d using FreeMonoid.inductionOn' with head tail ih\n  · use 1\n    rfl\n  specialize fs head\n  rcases fs with ⟨a, rfl⟩\n  rcases ih with ⟨b, rfl⟩\n  use FreeMonoid.of a * b\n  rfl\n\n"}
{"name":"FreeAddMonoid.reverse_of","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\na : α\n⊢ Eq (FreeAddMonoid.of a).reverse (FreeAddMonoid.of a)","decl":"@[to_additive (attr := simp)]\ntheorem reverse_of (a : α) : reverse (of a) = of a := rfl\n\n"}
{"name":"FreeMonoid.reverse_of","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\na : α\n⊢ Eq (FreeMonoid.of a).reverse (FreeMonoid.of a)","decl":"@[to_additive (attr := simp)]\ntheorem reverse_of (a : α) : reverse (of a) = of a := rfl\n\n"}
{"name":"FreeMonoid.reverse_mul","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\na b : FreeMonoid α\n⊢ Eq (HMul.hMul a b).reverse (HMul.hMul b.reverse a.reverse)","decl":"@[to_additive]\ntheorem reverse_mul {a b : FreeMonoid α} : reverse (a * b) = reverse b * reverse a :=\n  List.reverse_append _ _\n\n"}
{"name":"FreeAddMonoid.reverse_add","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\na b : FreeAddMonoid α\n⊢ Eq (HAdd.hAdd a b).reverse (HAdd.hAdd b.reverse a.reverse)","decl":"@[to_additive]\ntheorem reverse_mul {a b : FreeMonoid α} : reverse (a * b) = reverse b * reverse a :=\n  List.reverse_append _ _\n\n"}
{"name":"FreeMonoid.reverse_reverse","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\na : FreeMonoid α\n⊢ Eq a.reverse.reverse a","decl":"@[to_additive (attr := simp)]\ntheorem reverse_reverse {a : FreeMonoid α} : reverse (reverse a) = a := by\n  apply List.reverse_reverse\n\n"}
{"name":"FreeAddMonoid.reverse_reverse","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\na : FreeAddMonoid α\n⊢ Eq a.reverse.reverse a","decl":"@[to_additive (attr := simp)]\ntheorem reverse_reverse {a : FreeMonoid α} : reverse (reverse a) = a := by\n  apply List.reverse_reverse\n\n"}
{"name":"FreeAddMonoid.length_reverse","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\na : FreeAddMonoid α\n⊢ Eq a.reverse.length a.length","decl":"@[to_additive (attr := simp)]\ntheorem length_reverse {a : FreeMonoid α} : a.reverse.length = a.length :=\n  List.length_reverse _\n\n"}
{"name":"FreeMonoid.length_reverse","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_1\na : FreeMonoid α\n⊢ Eq a.reverse.length a.length","decl":"@[to_additive (attr := simp)]\ntheorem length_reverse {a : FreeMonoid α} : a.reverse.length = a.length :=\n  List.length_reverse _\n\n"}
{"name":"FreeAddMonoid.freeAddMonoidCongr_of","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ne : Equiv α β\na : α\n⊢ Eq ((FreeAddMonoid.freeAddMonoidCongr e) (FreeAddMonoid.of a)) (FreeAddMonoid.of (e a))","decl":"@[to_additive (attr := simp)]\ntheorem freeMonoidCongr_of (e : α ≃ β) (a : α) : freeMonoidCongr e (of a) = of (e a) := rfl\n\n"}
{"name":"FreeMonoid.freeMonoidCongr_of","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ne : Equiv α β\na : α\n⊢ Eq ((FreeMonoid.freeMonoidCongr e) (FreeMonoid.of a)) (FreeMonoid.of (e a))","decl":"@[to_additive (attr := simp)]\ntheorem freeMonoidCongr_of (e : α ≃ β) (a : α) : freeMonoidCongr e (of a) = of (e a) := rfl\n\n"}
{"name":"FreeAddMonoid.freeAddMonoidCongr_symm_of","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ne : Equiv α β\nb : β\n⊢ Eq ((FreeAddMonoid.freeAddMonoidCongr e.symm) (FreeAddMonoid.of b)) (FreeAddMonoid.of (e.symm b))","decl":"@[to_additive (attr := simp)]\ntheorem freeMonoidCongr_symm_of (e : α ≃ β) (b : β) :\n    freeMonoidCongr e.symm (of b) = of (e.symm b) := rfl\n\n"}
{"name":"FreeMonoid.freeMonoidCongr_symm_of","module":"Mathlib.Algebra.FreeMonoid.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ne : Equiv α β\nb : β\n⊢ Eq ((FreeMonoid.freeMonoidCongr e.symm) (FreeMonoid.of b)) (FreeMonoid.of (e.symm b))","decl":"@[to_additive (attr := simp)]\ntheorem freeMonoidCongr_symm_of (e : α ≃ β) (b : β) :\n    freeMonoidCongr e.symm (of b) = of (e.symm b) := rfl\n\n"}
