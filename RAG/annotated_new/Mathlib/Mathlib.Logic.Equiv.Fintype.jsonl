{"name":"Function.Embedding.toEquivRange_apply","module":"Mathlib.Logic.Equiv.Fintype","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq β\nf : Function.Embedding α β\na : α\n⊢ Eq (f.toEquivRange a) ⟨f a, ⋯⟩","decl":"@[simp]\ntheorem Function.Embedding.toEquivRange_apply (a : α) :\n    f.toEquivRange a = ⟨f a, Set.mem_range_self a⟩ :=\n  rfl\n\n"}
{"name":"Function.Embedding.toEquivRange_symm_apply_self","module":"Mathlib.Logic.Equiv.Fintype","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq β\nf : Function.Embedding α β\na : α\n⊢ Eq (f.toEquivRange.symm ⟨f a, ⋯⟩) a","decl":"@[simp]\ntheorem Function.Embedding.toEquivRange_symm_apply_self (a : α) :\n    f.toEquivRange.symm ⟨f a, Set.mem_range_self a⟩ = a := by simp [Equiv.symm_apply_eq]\n\n"}
{"name":"Function.Embedding.toEquivRange_eq_ofInjective","module":"Mathlib.Logic.Equiv.Fintype","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq β\nf : Function.Embedding α β\n⊢ Eq f.toEquivRange (Equiv.ofInjective ⇑f ⋯)","decl":"theorem Function.Embedding.toEquivRange_eq_ofInjective :\n    f.toEquivRange = Equiv.ofInjective f f.injective := by\n  ext\n  simp\n\n"}
{"name":"Equiv.Perm.viaFintypeEmbedding_apply_image","module":"Mathlib.Logic.Equiv.Fintype","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq β\ne : Equiv.Perm α\nf : Function.Embedding α β\na : α\n⊢ Eq ((e.viaFintypeEmbedding f) (f a)) (f (e a))","decl":"@[simp]\ntheorem Equiv.Perm.viaFintypeEmbedding_apply_image (a : α) :\n    e.viaFintypeEmbedding f (f a) = f (e a) := by\n  rw [Equiv.Perm.viaFintypeEmbedding]\n  convert Equiv.Perm.extendDomain_apply_image e (Function.Embedding.toEquivRange f) a\n\n"}
{"name":"Equiv.Perm.viaFintypeEmbedding_apply_mem_range","module":"Mathlib.Logic.Equiv.Fintype","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq β\ne : Equiv.Perm α\nf : Function.Embedding α β\nb : β\nh : Membership.mem (Set.range ⇑f) b\n⊢ Eq ((e.viaFintypeEmbedding f) b) (f (e (f.invOfMemRange ⟨b, h⟩)))","decl":"theorem Equiv.Perm.viaFintypeEmbedding_apply_mem_range {b : β} (h : b ∈ Set.range f) :\n    e.viaFintypeEmbedding f b = f (e (f.invOfMemRange ⟨b, h⟩)) := by\n  simp only [viaFintypeEmbedding, Function.Embedding.invOfMemRange]\n  rw [Equiv.Perm.extendDomain_apply_subtype]\n  congr\n\n"}
{"name":"Equiv.Perm.viaFintypeEmbedding_apply_not_mem_range","module":"Mathlib.Logic.Equiv.Fintype","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq β\ne : Equiv.Perm α\nf : Function.Embedding α β\nb : β\nh : Not (Membership.mem (Set.range ⇑f) b)\n⊢ Eq ((e.viaFintypeEmbedding f) b) b","decl":"theorem Equiv.Perm.viaFintypeEmbedding_apply_not_mem_range {b : β} (h : b ∉ Set.range f) :\n    e.viaFintypeEmbedding f b = b := by\n  rwa [Equiv.Perm.viaFintypeEmbedding, Equiv.Perm.extendDomain_apply_not_subtype]\n\n"}
{"name":"Equiv.Perm.viaFintypeEmbedding_sign","module":"Mathlib.Logic.Equiv.Fintype","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Fintype α\ninst✝² : DecidableEq β\ne : Equiv.Perm α\nf : Function.Embedding α β\ninst✝¹ : DecidableEq α\ninst✝ : Fintype β\n⊢ Eq (Equiv.Perm.sign (e.viaFintypeEmbedding f)) (Equiv.Perm.sign e)","decl":"@[simp]\ntheorem Equiv.Perm.viaFintypeEmbedding_sign [DecidableEq α] [Fintype β] :\n    Equiv.Perm.sign (e.viaFintypeEmbedding f) = Equiv.Perm.sign e := by\n  simp [Equiv.Perm.viaFintypeEmbedding]\n\n"}
{"name":"Equiv.extendSubtype_apply_of_mem","module":"Mathlib.Logic.Equiv.Fintype","initialProofState":"α : Type u_1\ninst✝² : Finite α\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\ne : Equiv (Subtype fun x => p x) (Subtype fun x => q x)\nx : α\nhx : p x\n⊢ Eq (e.extendSubtype x) ↑(e ⟨x, hx⟩)","decl":"theorem extendSubtype_apply_of_mem (e : { x // p x } ≃ { x // q x }) (x) (hx : p x) :\n    e.extendSubtype x = e ⟨x, hx⟩ := by\n  dsimp only [extendSubtype]\n  simp only [subtypeCongr, Equiv.trans_apply, Equiv.sumCongr_apply]\n  rw [sumCompl_apply_symm_of_pos _ _ hx, Sum.map_inl, sumCompl_apply_inl]\n\n"}
{"name":"Equiv.extendSubtype_mem","module":"Mathlib.Logic.Equiv.Fintype","initialProofState":"α : Type u_1\ninst✝² : Finite α\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\ne : Equiv (Subtype fun x => p x) (Subtype fun x => q x)\nx : α\nhx : p x\n⊢ q (e.extendSubtype x)","decl":"theorem extendSubtype_mem (e : { x // p x } ≃ { x // q x }) (x) (hx : p x) :\n    q (e.extendSubtype x) := by\n  convert (e ⟨x, hx⟩).2\n  rw [e.extendSubtype_apply_of_mem _ hx]\n\n"}
{"name":"Equiv.extendSubtype_apply_of_not_mem","module":"Mathlib.Logic.Equiv.Fintype","initialProofState":"α : Type u_1\ninst✝² : Finite α\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\ne : Equiv (Subtype fun x => p x) (Subtype fun x => q x)\nx : α\nhx : Not (p x)\n⊢ Eq (e.extendSubtype x) ↑(e.toCompl ⟨x, hx⟩)","decl":"theorem extendSubtype_apply_of_not_mem (e : { x // p x } ≃ { x // q x }) (x) (hx : ¬p x) :\n    e.extendSubtype x = e.toCompl ⟨x, hx⟩ := by\n  dsimp only [extendSubtype]\n  simp only [subtypeCongr, Equiv.trans_apply, Equiv.sumCongr_apply]\n  rw [sumCompl_apply_symm_of_neg _ _ hx, Sum.map_inr, sumCompl_apply_inr]\n\n"}
{"name":"Equiv.extendSubtype_not_mem","module":"Mathlib.Logic.Equiv.Fintype","initialProofState":"α : Type u_1\ninst✝² : Finite α\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\ne : Equiv (Subtype fun x => p x) (Subtype fun x => q x)\nx : α\nhx : Not (p x)\n⊢ Not (q (e.extendSubtype x))","decl":"theorem extendSubtype_not_mem (e : { x // p x } ≃ { x // q x }) (x) (hx : ¬p x) :\n    ¬q (e.extendSubtype x) := by\n  convert (e.toCompl ⟨x, hx⟩).2\n  rw [e.extendSubtype_apply_of_not_mem _ hx]\n\n"}
