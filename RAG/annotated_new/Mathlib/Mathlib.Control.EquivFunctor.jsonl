{"name":"EquivFunctor.map_trans'","module":"Mathlib.Control.EquivFunctor","initialProofState":"f : Type u₀ → Type u₁\nself : EquivFunctor f\nα β γ : Type u₀\nk : Equiv α β\nh : Equiv β γ\n⊢ Eq (EquivFunctor.map (k.trans h)) (Function.comp (EquivFunctor.map h) (EquivFunctor.map k))","decl":"/-- An `EquivFunctor` is only functorial with respect to equivalences.\n\nTo construct an `EquivFunctor`, it suffices to supply just the function `f α → f β` from\nan equivalence `α ≃ β`, and then prove the functor laws. It's then a consequence that\nthis function is part of an equivalence, provided by `EquivFunctor.mapEquiv`.\n-/\nclass EquivFunctor (f : Type u₀ → Type u₁) where\n  /-- The action of `f` on isomorphisms. -/\n  map : ∀ {α β}, α ≃ β → f α → f β\n  /-- `map` of `f` preserves the identity morphism. -/\n  map_refl' : ∀ α, map (Equiv.refl α) = @id (f α) := by rfl\n  /-- `map` is functorial on equivalences. -/\n  map_trans' : ∀ {α β γ} (k : α ≃ β) (h : β ≃ γ), map (k.trans h) = map h ∘ map k := by rfl\n\n"}
{"name":"EquivFunctor.map_refl'","module":"Mathlib.Control.EquivFunctor","initialProofState":"f : Type u₀ → Type u₁\nself : EquivFunctor f\nα : Type u₀\n⊢ Eq (EquivFunctor.map (Equiv.refl α)) id","decl":"/-- An `EquivFunctor` is only functorial with respect to equivalences.\n\nTo construct an `EquivFunctor`, it suffices to supply just the function `f α → f β` from\nan equivalence `α ≃ β`, and then prove the functor laws. It's then a consequence that\nthis function is part of an equivalence, provided by `EquivFunctor.mapEquiv`.\n-/\nclass EquivFunctor (f : Type u₀ → Type u₁) where\n  /-- The action of `f` on isomorphisms. -/\n  map : ∀ {α β}, α ≃ β → f α → f β\n  /-- `map` of `f` preserves the identity morphism. -/\n  map_refl' : ∀ α, map (Equiv.refl α) = @id (f α) := by rfl\n  /-- `map` is functorial on equivalences. -/\n  map_trans' : ∀ {α β γ} (k : α ≃ β) (h : β ≃ γ), map (k.trans h) = map h ∘ map k := by rfl\n\n"}
{"name":"EquivFunctor.mapEquiv_apply","module":"Mathlib.Control.EquivFunctor","initialProofState":"f : Type u₀ → Type u₁\ninst✝ : EquivFunctor f\nα β : Type u₀\ne : Equiv α β\nx : f α\n⊢ Eq ((EquivFunctor.mapEquiv f e) x) (EquivFunctor.map e x)","decl":"@[simp]\ntheorem mapEquiv_apply (x : f α) : mapEquiv f e x = EquivFunctor.map e x :=\n  rfl\n\n"}
{"name":"EquivFunctor.mapEquiv_symm_apply","module":"Mathlib.Control.EquivFunctor","initialProofState":"f : Type u₀ → Type u₁\ninst✝ : EquivFunctor f\nα β : Type u₀\ne : Equiv α β\ny : f β\n⊢ Eq ((EquivFunctor.mapEquiv f e).symm y) (EquivFunctor.map e.symm y)","decl":"theorem mapEquiv_symm_apply (y : f β) : (mapEquiv f e).symm y = EquivFunctor.map e.symm y :=\n  rfl\n\n"}
{"name":"EquivFunctor.mapEquiv_refl","module":"Mathlib.Control.EquivFunctor","initialProofState":"f : Type u₀ → Type u₁\ninst✝ : EquivFunctor f\nα : Type u₀\n⊢ Eq (EquivFunctor.mapEquiv f (Equiv.refl α)) (Equiv.refl (f α))","decl":"@[simp]\ntheorem mapEquiv_refl (α) : mapEquiv f (Equiv.refl α) = Equiv.refl (f α) := by\n ext; simp [mapEquiv]\n\n"}
{"name":"EquivFunctor.mapEquiv_symm","module":"Mathlib.Control.EquivFunctor","initialProofState":"f : Type u₀ → Type u₁\ninst✝ : EquivFunctor f\nα β : Type u₀\ne : Equiv α β\n⊢ Eq (EquivFunctor.mapEquiv f e).symm (EquivFunctor.mapEquiv f e.symm)","decl":"@[simp]\ntheorem mapEquiv_symm : (mapEquiv f e).symm = mapEquiv f e.symm :=\n  Equiv.ext <| mapEquiv_symm_apply f e\n\n"}
{"name":"EquivFunctor.mapEquiv_trans","module":"Mathlib.Control.EquivFunctor","initialProofState":"f : Type u₀ → Type u₁\ninst✝ : EquivFunctor f\nα β γ : Type u₀\nab : Equiv α β\nbc : Equiv β γ\n⊢ Eq ((EquivFunctor.mapEquiv f ab).trans (EquivFunctor.mapEquiv f bc)) (EquivFunctor.mapEquiv f (ab.trans bc))","decl":"/-- The composition of `mapEquiv`s is carried over the `EquivFunctor`.\nFor plain `Functor`s, this lemma is named `map_map` when applied\nor `map_comp_map` when not applied.\n-/\n@[simp]\ntheorem mapEquiv_trans {γ : Type u₀} (ab : α ≃ β) (bc : β ≃ γ) :\n    (mapEquiv f ab).trans (mapEquiv f bc) = mapEquiv f (ab.trans bc) :=\n  Equiv.ext fun x => by simp [mapEquiv, map_trans']\n\n"}
{"name":"EquivFunctor.mapEquiv.injective","module":"Mathlib.Control.EquivFunctor","initialProofState":"f : Type u₀ → Type u₁\ninst✝¹ : Applicative f\ninst✝ : LawfulApplicative f\nα β : Type u₀\nh : ∀ (γ : Type u₀), Function.Injective Pure.pure\n⊢ Function.Injective (EquivFunctor.mapEquiv f)","decl":"theorem mapEquiv.injective (f : Type u₀ → Type u₁)\n    [Applicative f] [LawfulApplicative f] {α β : Type u₀}\n    (h : ∀ γ, Function.Injective (pure : γ → f γ)) :\n      Function.Injective (@EquivFunctor.mapEquiv f _ α β) :=\n  fun e₁ e₂ H =>\n    Equiv.ext fun x => h β (by simpa [EquivFunctor.map] using Equiv.congr_fun H (pure x))\n\n"}
