{"name":"CategoryTheory.PreservesImage.iso_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Images","initialProofState":"A : Type u₁\nB : Type u₂\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} B\ninst✝⁵ : CategoryTheory.Limits.HasEqualizers A\ninst✝⁴ : CategoryTheory.Limits.HasImages A\ninst✝³ : CategoryTheory.StrongEpiCategory B\ninst✝² : CategoryTheory.Limits.HasImages B\nL : CategoryTheory.Functor A B\ninst✝¹ : ∀ {X Y Z : A} (f : Quiver.Hom X Z) (g : Quiver.Hom Y Z), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) L\ninst✝ : ∀ {X Y Z : A} (f : Quiver.Hom X Y) (g : Quiver.Hom X Z), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) L\nX Y : A\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.PreservesImage.iso L f).hom (CategoryTheory.Limits.image.lift (CategoryTheory.Limits.MonoFactorisation.mk (L.obj (CategoryTheory.Limits.image f)) (L.map (CategoryTheory.Limits.image.ι f)) (L.map (CategoryTheory.Limits.factorThruImage f)) ⋯))","decl":"/-- If a functor preserves span and cospan, then it preserves images.\n-/\n@[simps!]\ndef iso {X Y : A} (f : X ⟶ Y) : image (L.map f) ≅ L.obj (image f) :=\n  let aux1 : StrongEpiMonoFactorisation (L.map f) :=\n    { I := L.obj (Limits.image f)\n      m := L.map <| Limits.image.ι _\n      m_mono := preserves_mono_of_preservesLimit _ _\n      e := L.map <| factorThruImage _\n      e_strong_epi := @strongEpi_of_epi B _ _ _ _ _ (preserves_epi_of_preservesColimit L _)\n      fac := by rw [← L.map_comp, Limits.image.fac] }\n  IsImage.isoExt (Image.isImage (L.map f)) aux1.toMonoIsImage\n\n"}
{"name":"CategoryTheory.PreservesImage.iso_inv","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Images","initialProofState":"A : Type u₁\nB : Type u₂\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} B\ninst✝⁵ : CategoryTheory.Limits.HasEqualizers A\ninst✝⁴ : CategoryTheory.Limits.HasImages A\ninst✝³ : CategoryTheory.StrongEpiCategory B\ninst✝² : CategoryTheory.Limits.HasImages B\nL : CategoryTheory.Functor A B\ninst✝¹ : ∀ {X Y Z : A} (f : Quiver.Hom X Z) (g : Quiver.Hom Y Z), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) L\ninst✝ : ∀ {X Y Z : A} (f : Quiver.Hom X Y) (g : Quiver.Hom X Z), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) L\nX Y : A\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.PreservesImage.iso L f).inv ((CategoryTheory.Limits.StrongEpiMonoFactorisation.mk (CategoryTheory.Limits.MonoFactorisation.mk (L.obj (CategoryTheory.Limits.image f)) (L.map (CategoryTheory.Limits.image.ι f)) (L.map (CategoryTheory.Limits.factorThruImage f)) ⋯)).toMonoIsImage.lift (CategoryTheory.Limits.Image.monoFactorisation (L.map f)))","decl":"/-- If a functor preserves span and cospan, then it preserves images.\n-/\n@[simps!]\ndef iso {X Y : A} (f : X ⟶ Y) : image (L.map f) ≅ L.obj (image f) :=\n  let aux1 : StrongEpiMonoFactorisation (L.map f) :=\n    { I := L.obj (Limits.image f)\n      m := L.map <| Limits.image.ι _\n      m_mono := preserves_mono_of_preservesLimit _ _\n      e := L.map <| factorThruImage _\n      e_strong_epi := @strongEpi_of_epi B _ _ _ _ _ (preserves_epi_of_preservesColimit L _)\n      fac := by rw [← L.map_comp, Limits.image.fac] }\n  IsImage.isoExt (Image.isImage (L.map f)) aux1.toMonoIsImage\n\n"}
{"name":"CategoryTheory.PreservesImage.factorThruImage_comp_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Images","initialProofState":"A : Type u₁\nB : Type u₂\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} B\ninst✝⁵ : CategoryTheory.Limits.HasEqualizers A\ninst✝⁴ : CategoryTheory.Limits.HasImages A\ninst✝³ : CategoryTheory.StrongEpiCategory B\ninst✝² : CategoryTheory.Limits.HasImages B\nL : CategoryTheory.Functor A B\ninst✝¹ : ∀ {X Y Z : A} (f : Quiver.Hom X Z) (g : Quiver.Hom Y Z), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) L\ninst✝ : ∀ {X Y Z : A} (f : Quiver.Hom X Y) (g : Quiver.Hom X Z), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) L\nX Y : A\nf : Quiver.Hom X Y\nZ : B\nh : Quiver.Hom (L.obj (CategoryTheory.Limits.image f)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage (L.map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.PreservesImage.iso L f).hom h)) (CategoryTheory.CategoryStruct.comp (L.map (CategoryTheory.Limits.factorThruImage f)) h)","decl":"@[reassoc]\ntheorem factorThruImage_comp_hom {X Y : A} (f : X ⟶ Y) :\n    factorThruImage (L.map f) ≫ (iso L f).hom = L.map (factorThruImage f) := by simp\n\n"}
{"name":"CategoryTheory.PreservesImage.factorThruImage_comp_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Images","initialProofState":"A : Type u₁\nB : Type u₂\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} B\ninst✝⁵ : CategoryTheory.Limits.HasEqualizers A\ninst✝⁴ : CategoryTheory.Limits.HasImages A\ninst✝³ : CategoryTheory.StrongEpiCategory B\ninst✝² : CategoryTheory.Limits.HasImages B\nL : CategoryTheory.Functor A B\ninst✝¹ : ∀ {X Y Z : A} (f : Quiver.Hom X Z) (g : Quiver.Hom Y Z), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) L\ninst✝ : ∀ {X Y Z : A} (f : Quiver.Hom X Y) (g : Quiver.Hom X Z), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) L\nX Y : A\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage (L.map f)) (CategoryTheory.PreservesImage.iso L f).hom) (L.map (CategoryTheory.Limits.factorThruImage f))","decl":"@[reassoc]\ntheorem factorThruImage_comp_hom {X Y : A} (f : X ⟶ Y) :\n    factorThruImage (L.map f) ≫ (iso L f).hom = L.map (factorThruImage f) := by simp\n\n"}
{"name":"CategoryTheory.PreservesImage.hom_comp_map_image_ι","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Images","initialProofState":"A : Type u₁\nB : Type u₂\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} B\ninst✝⁵ : CategoryTheory.Limits.HasEqualizers A\ninst✝⁴ : CategoryTheory.Limits.HasImages A\ninst✝³ : CategoryTheory.StrongEpiCategory B\ninst✝² : CategoryTheory.Limits.HasImages B\nL : CategoryTheory.Functor A B\ninst✝¹ : ∀ {X Y Z : A} (f : Quiver.Hom X Z) (g : Quiver.Hom Y Z), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) L\ninst✝ : ∀ {X Y Z : A} (f : Quiver.Hom X Y) (g : Quiver.Hom X Z), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) L\nX Y : A\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.PreservesImage.iso L f).hom (L.map (CategoryTheory.Limits.image.ι f))) (CategoryTheory.Limits.image.ι (L.map f))","decl":"@[reassoc]\ntheorem hom_comp_map_image_ι {X Y : A} (f : X ⟶ Y) :\n    (iso L f).hom ≫ L.map (image.ι f) = image.ι (L.map f) := by rw [iso_hom, image.lift_fac]\n\n"}
{"name":"CategoryTheory.PreservesImage.hom_comp_map_image_ι_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Images","initialProofState":"A : Type u₁\nB : Type u₂\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} B\ninst✝⁵ : CategoryTheory.Limits.HasEqualizers A\ninst✝⁴ : CategoryTheory.Limits.HasImages A\ninst✝³ : CategoryTheory.StrongEpiCategory B\ninst✝² : CategoryTheory.Limits.HasImages B\nL : CategoryTheory.Functor A B\ninst✝¹ : ∀ {X Y Z : A} (f : Quiver.Hom X Z) (g : Quiver.Hom Y Z), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) L\ninst✝ : ∀ {X Y Z : A} (f : Quiver.Hom X Y) (g : Quiver.Hom X Z), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) L\nX Y : A\nf : Quiver.Hom X Y\nZ : B\nh : Quiver.Hom (L.obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.PreservesImage.iso L f).hom (CategoryTheory.CategoryStruct.comp (L.map (CategoryTheory.Limits.image.ι f)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι (L.map f)) h)","decl":"@[reassoc]\ntheorem hom_comp_map_image_ι {X Y : A} (f : X ⟶ Y) :\n    (iso L f).hom ≫ L.map (image.ι f) = image.ι (L.map f) := by rw [iso_hom, image.lift_fac]\n\n"}
{"name":"CategoryTheory.PreservesImage.inv_comp_image_ι_map","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Images","initialProofState":"A : Type u₁\nB : Type u₂\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} B\ninst✝⁵ : CategoryTheory.Limits.HasEqualizers A\ninst✝⁴ : CategoryTheory.Limits.HasImages A\ninst✝³ : CategoryTheory.StrongEpiCategory B\ninst✝² : CategoryTheory.Limits.HasImages B\nL : CategoryTheory.Functor A B\ninst✝¹ : ∀ {X Y Z : A} (f : Quiver.Hom X Z) (g : Quiver.Hom Y Z), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) L\ninst✝ : ∀ {X Y Z : A} (f : Quiver.Hom X Y) (g : Quiver.Hom X Z), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) L\nX Y : A\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.PreservesImage.iso L f).inv (CategoryTheory.Limits.image.ι (L.map f))) (L.map (CategoryTheory.Limits.image.ι f))","decl":"@[reassoc]\ntheorem inv_comp_image_ι_map {X Y : A} (f : X ⟶ Y) :\n    (iso L f).inv ≫ image.ι (L.map f) = L.map (image.ι f) := by simp\n\n"}
{"name":"CategoryTheory.PreservesImage.inv_comp_image_ι_map_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Images","initialProofState":"A : Type u₁\nB : Type u₂\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} B\ninst✝⁵ : CategoryTheory.Limits.HasEqualizers A\ninst✝⁴ : CategoryTheory.Limits.HasImages A\ninst✝³ : CategoryTheory.StrongEpiCategory B\ninst✝² : CategoryTheory.Limits.HasImages B\nL : CategoryTheory.Functor A B\ninst✝¹ : ∀ {X Y Z : A} (f : Quiver.Hom X Z) (g : Quiver.Hom Y Z), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) L\ninst✝ : ∀ {X Y Z : A} (f : Quiver.Hom X Y) (g : Quiver.Hom X Z), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) L\nX Y : A\nf : Quiver.Hom X Y\nZ : B\nh : Quiver.Hom (L.obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.PreservesImage.iso L f).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι (L.map f)) h)) (CategoryTheory.CategoryStruct.comp (L.map (CategoryTheory.Limits.image.ι f)) h)","decl":"@[reassoc]\ntheorem inv_comp_image_ι_map {X Y : A} (f : X ⟶ Y) :\n    (iso L f).inv ≫ image.ι (L.map f) = L.map (image.ι f) := by simp\n\n"}
