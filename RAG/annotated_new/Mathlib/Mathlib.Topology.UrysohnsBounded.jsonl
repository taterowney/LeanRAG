{"name":"exists_bounded_zero_one_of_closed","module":"Mathlib.Topology.UrysohnsBounded","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : NormalSpace X\ns t : Set X\nhs : IsClosed s\nht : IsClosed t\nhd : Disjoint s t\n⊢ Exists fun f => And (Set.EqOn (⇑f) 0 s) (And (Set.EqOn (⇑f) 1 t) (∀ (x : X), Membership.mem (Set.Icc 0 1) (f x)))","decl":"/-- **Urysohn's lemma**: if `s` and `t` are two disjoint closed sets in a normal topological\nspace `X`, then there exists a continuous function `f : X → ℝ` such that\n\n* `f` equals zero on `s`;\n* `f` equals one on `t`;\n* `0 ≤ f x ≤ 1` for all `x`.\n-/\ntheorem exists_bounded_zero_one_of_closed {X : Type*} [TopologicalSpace X] [NormalSpace X]\n    {s t : Set X} (hs : IsClosed s) (ht : IsClosed t) (hd : Disjoint s t) :\n    ∃ f : X →ᵇ ℝ, EqOn f 0 s ∧ EqOn f 1 t ∧ ∀ x, f x ∈ Icc (0 : ℝ) 1 :=\n  let ⟨f, hfs, hft, hf⟩ := exists_continuous_zero_one_of_isClosed hs ht hd\n  ⟨⟨f, 1, fun _ _ => Real.dist_le_of_mem_Icc_01 (hf _) (hf _)⟩, hfs, hft, hf⟩\n\n"}
{"name":"exists_bounded_mem_Icc_of_closed_of_le","module":"Mathlib.Topology.UrysohnsBounded","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : NormalSpace X\ns t : Set X\nhs : IsClosed s\nht : IsClosed t\nhd : Disjoint s t\na b : Real\nhle : LE.le a b\n⊢ Exists fun f => And (Set.EqOn (⇑f) (Function.const X a) s) (And (Set.EqOn (⇑f) (Function.const X b) t) (∀ (x : X), Membership.mem (Set.Icc a b) (f x)))","decl":"/-- Urysohn's lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`,\nand `a ≤ b` are two real numbers, then there exists a continuous function `f : X → ℝ` such that\n\n* `f` equals `a` on `s`;\n* `f` equals `b` on `t`;\n* `a ≤ f x ≤ b` for all `x`.\n-/\ntheorem exists_bounded_mem_Icc_of_closed_of_le {X : Type*} [TopologicalSpace X] [NormalSpace X]\n    {s t : Set X} (hs : IsClosed s) (ht : IsClosed t) (hd : Disjoint s t) {a b : ℝ} (hle : a ≤ b) :\n    ∃ f : X →ᵇ ℝ, EqOn f (Function.const X a) s ∧ EqOn f (Function.const X b) t ∧\n    ∀ x, f x ∈ Icc a b :=\n  let ⟨f, hfs, hft, hf01⟩ := exists_bounded_zero_one_of_closed hs ht hd\n  ⟨BoundedContinuousFunction.const X a + (b - a) • f, fun x hx => by simp [hfs hx], fun x hx => by\n    simp [hft hx], fun x =>\n    ⟨by dsimp; nlinarith [(hf01 x).1], by dsimp; nlinarith [(hf01 x).2]⟩⟩\n"}
