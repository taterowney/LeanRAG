{"name":"Basis.parallelepiped_basisFun","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"Î¹ : Type u_1\ninstâœ : Fintype Î¹\nâŠ¢ Eq (Pi.basisFun Real Î¹).parallelepiped (TopologicalSpace.PositiveCompacts.piIcc01 Î¹)","decl":"/-- The parallelepiped formed from the standard basis for `Î¹ â†’ â„` is `[0,1]^Î¹` -/\ntheorem Basis.parallelepiped_basisFun (Î¹ : Type*) [Fintype Î¹] :\n    (Pi.basisFun â„ Î¹).parallelepiped = TopologicalSpace.PositiveCompacts.piIcc01 Î¹ :=\n  SetLike.coe_injective <| by\n    refine Eq.trans ?_ ((uIcc_of_le ?_).trans (Set.pi_univ_Icc _ _).symm)\n    Â· classical convert parallelepiped_single (Î¹ := Î¹) 1\n    Â· exact zero_le_one\n\n"}
{"name":"Basis.parallelepiped_eq_map","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"Î¹ : Type u_1\nE : Type u_2\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nb : Basis Î¹ Real E\nâŠ¢ Eq b.parallelepiped (TopologicalSpace.PositiveCompacts.map â‡‘b.equivFun.symm â‹¯ â‹¯ (TopologicalSpace.PositiveCompacts.piIcc01 Î¹))","decl":"/-- A parallelepiped can be expressed on the standard basis. -/\ntheorem Basis.parallelepiped_eq_map  {Î¹ E : Type*} [Fintype Î¹] [NormedAddCommGroup E]\n    [NormedSpace â„ E] (b : Basis Î¹ â„ E) :\n    b.parallelepiped = (PositiveCompacts.piIcc01 Î¹).map b.equivFun.symm\n      b.equivFunL.symm.continuous b.equivFunL.symm.isOpenMap := by\n  classical\n  rw [â† Basis.parallelepiped_basisFun, â† Basis.parallelepiped_map]\n  congr with x\n  simp [Pi.single_apply]\n\n"}
{"name":"Basis.map_addHaar","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"Î¹ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ¹â° : Fintype Î¹\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedAddCommGroup F\ninstâœâ· : NormedSpace Real E\ninstâœâ¶ : NormedSpace Real F\ninstâœâµ : MeasurableSpace E\ninstâœâ´ : MeasurableSpace F\ninstâœÂ³ : BorelSpace E\ninstâœÂ² : BorelSpace F\ninstâœÂ¹ : SecondCountableTopology F\ninstâœ : SigmaCompactSpace F\nb : Basis Î¹ Real E\nf : ContinuousLinearEquiv (RingHom.id Real) E F\nâŠ¢ Eq (MeasureTheory.Measure.map (â‡‘f) b.addHaar) (b.map f.toLinearEquiv).addHaar","decl":"theorem Basis.map_addHaar {Î¹ E F : Type*} [Fintype Î¹] [NormedAddCommGroup E] [NormedAddCommGroup F]\n    [NormedSpace â„ E] [NormedSpace â„ F] [MeasurableSpace E] [MeasurableSpace F] [BorelSpace E]\n    [BorelSpace F] [SecondCountableTopology F] [SigmaCompactSpace F]\n    (b : Basis Î¹ â„ E) (f : E â‰ƒL[â„] F) :\n    map f b.addHaar = (b.map f.toLinearEquiv).addHaar := by\n  have : IsAddHaarMeasure (map f b.addHaar) :=\n    AddEquiv.isAddHaarMeasure_map b.addHaar f.toAddEquiv f.continuous f.symm.continuous\n  rw [eq_comm, Basis.addHaar_eq_iff, Measure.map_apply f.continuous.measurable\n    (PositiveCompacts.isCompact _).measurableSet, Basis.coe_parallelepiped, Basis.coe_map]\n  erw [â† image_parallelepiped, f.toEquiv.preimage_image, addHaar_self]\n\n"}
{"name":"MeasureTheory.addHaarMeasure_eq_volume","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"âŠ¢ Eq (MeasureTheory.Measure.addHaarMeasure TopologicalSpace.PositiveCompacts.Icc01) MeasureTheory.MeasureSpace.volume","decl":"/-- The Haar measure equals the Lebesgue measure on `â„`. -/\ntheorem addHaarMeasure_eq_volume : addHaarMeasure Icc01 = volume := by\n  convert (addHaarMeasure_unique volume Icc01).symm; simp [Icc01]\n\n"}
{"name":"MeasureTheory.addHaarMeasure_eq_volume_pi","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"Î¹ : Type u_1\ninstâœ : Fintype Î¹\nâŠ¢ Eq (MeasureTheory.Measure.addHaarMeasure (TopologicalSpace.PositiveCompacts.piIcc01 Î¹)) MeasureTheory.MeasureSpace.volume","decl":"/-- The Haar measure equals the Lebesgue measure on `â„^Î¹`. -/\ntheorem addHaarMeasure_eq_volume_pi (Î¹ : Type*) [Fintype Î¹] :\n    addHaarMeasure (piIcc01 Î¹) = volume := by\n  convert (addHaarMeasure_unique volume (piIcc01 Î¹)).symm\n  simp only [piIcc01, volume_pi_pi fun _ => Icc (0 : â„) 1, PositiveCompacts.coe_mk,\n    Compacts.coe_mk, Finset.prod_const_one, ENNReal.ofReal_one, Real.volume_Icc, one_smul, sub_zero]\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: remove this instance?\n"}
{"name":"MeasureTheory.isAddHaarMeasure_volume_pi","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"Î¹ : Type u_1\ninstâœ : Fintype Î¹\nâŠ¢ MeasureTheory.MeasureSpace.volume.IsAddHaarMeasure","decl":"instance isAddHaarMeasure_volume_pi (Î¹ : Type*) [Fintype Î¹] :\n    IsAddHaarMeasure (volume : Measure (Î¹ â†’ â„)) :=\n  inferInstance\n\n"}
{"name":"MeasureTheory.Measure.addHaar_eq_zero_of_disjoint_translates_aux","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\ns : Set E\nu : Nat â†’ E\nsb : Bornology.IsBounded s\nhu : Bornology.IsBounded (Set.range u)\nhs : Pairwise (Function.onFun Disjoint fun n => HAdd.hAdd (Singleton.singleton (u n)) s)\nh's : MeasurableSet s\nâŠ¢ Eq (Î¼ s) 0","decl":"/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem addHaar_eq_zero_of_disjoint_translates_aux {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace â„ E] [MeasurableSpace E] [BorelSpace E] [FiniteDimensional â„ E] (Î¼ : Measure E)\n    [IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E) (sb : IsBounded s) (hu : IsBounded (range u))\n    (hs : Pairwise (Disjoint on fun n => {u n} + s)) (h's : MeasurableSet s) : Î¼ s = 0 := by\n  by_contra h\n  apply lt_irrefl âˆ\n  calc\n    âˆ = âˆ‘' _ : â„•, Î¼ s := (ENNReal.tsum_const_eq_top_of_ne_zero h).symm\n    _ = âˆ‘' n : â„•, Î¼ ({u n} + s) := by\n      congr 1; ext1 n; simp only [image_add_left, measure_preimage_add, singleton_add]\n    _ = Î¼ (â‹ƒ n, {u n} + s) := Eq.symm <| measure_iUnion hs fun n => by\n      simpa only [image_add_left, singleton_add] using measurable_id.const_add _ h's\n    _ = Î¼ (range u + s) := by rw [â† iUnion_add, iUnion_singleton_eq_range]\n    _ < âˆ := (hu.add sb).measure_lt_top\n\n"}
{"name":"MeasureTheory.Measure.addHaar_eq_zero_of_disjoint_translates","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\ns : Set E\nu : Nat â†’ E\nhu : Bornology.IsBounded (Set.range u)\nhs : Pairwise (Function.onFun Disjoint fun n => HAdd.hAdd (Singleton.singleton (u n)) s)\nh's : MeasurableSet s\nâŠ¢ Eq (Î¼ s) 0","decl":"/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. -/\ntheorem addHaar_eq_zero_of_disjoint_translates {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace â„ E] [MeasurableSpace E] [BorelSpace E] [FiniteDimensional â„ E] (Î¼ : Measure E)\n    [IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E) (hu : IsBounded (range u))\n    (hs : Pairwise (Disjoint on fun n => {u n} + s)) (h's : MeasurableSet s) : Î¼ s = 0 := by\n  suffices H : âˆ€ R, Î¼ (s âˆ© closedBall 0 R) = 0 by\n    apply le_antisymm _ (zero_le _)\n    calc\n      Î¼ s â‰¤ âˆ‘' n : â„•, Î¼ (s âˆ© closedBall 0 n) := by\n        conv_lhs => rw [â† iUnion_inter_closedBall_nat s 0]\n        exact measure_iUnion_le _\n      _ = 0 := by simp only [H, tsum_zero]\n  intro R\n  apply addHaar_eq_zero_of_disjoint_translates_aux Î¼ u\n    (isBounded_closedBall.subset inter_subset_right) hu _ (h's.inter measurableSet_closedBall)\n  refine pairwise_disjoint_mono hs fun n => ?_\n  exact add_subset_add Subset.rfl inter_subset_left\n\n"}
{"name":"MeasureTheory.Measure.addHaar_submodule","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\ns : Submodule Real E\nhs : Ne s Top.top\nâŠ¢ Eq (Î¼ â†‘s) 0","decl":"/-- A strict vector subspace has measure zero. -/\ntheorem addHaar_submodule {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E] [MeasurableSpace E]\n    [BorelSpace E] [FiniteDimensional â„ E] (Î¼ : Measure E) [IsAddHaarMeasure Î¼] (s : Submodule â„ E)\n    (hs : s â‰  âŠ¤) : Î¼ s = 0 := by\n  obtain âŸ¨x, hxâŸ© : âˆƒ x, x âˆ‰ s := by\n    simpa only [Submodule.eq_top_iff', not_exists, Ne, not_forall] using hs\n  obtain âŸ¨c, cpos, coneâŸ© : âˆƒ c : â„, 0 < c âˆ§ c < 1 := âŸ¨1 / 2, by norm_num, by norm_numâŸ©\n  have A : IsBounded (range fun n : â„• => c ^ n â€¢ x) :=\n    have : Tendsto (fun n : â„• => c ^ n â€¢ x) atTop (ğ“ ((0 : â„) â€¢ x)) :=\n      (tendsto_pow_atTop_nhds_zero_of_lt_one cpos.le cone).smul_const x\n    isBounded_range_of_tendsto _ this\n  apply addHaar_eq_zero_of_disjoint_translates Î¼ _ A _\n    (Submodule.closed_of_finiteDimensional s).measurableSet\n  intro m n hmn\n  simp only [Function.onFun, image_add_left, singleton_add, disjoint_left, mem_preimage,\n    SetLike.mem_coe]\n  intro y hym hyn\n  have A : (c ^ n - c ^ m) â€¢ x âˆˆ s := by\n    convert s.sub_mem hym hyn using 1\n    simp only [sub_smul, neg_sub_neg, add_sub_add_right_eq_sub]\n  have H : c ^ n - c ^ m â‰  0 := by\n    simpa only [sub_eq_zero, Ne] using (pow_right_strictAntiâ‚€ cpos cone).injective.ne hmn.symm\n  have : x âˆˆ s := by\n    convert s.smul_mem (c ^ n - c ^ m)â»Â¹ A\n    rw [smul_smul, inv_mul_cancelâ‚€ H, one_smul]\n  exact hx this\n\n"}
{"name":"MeasureTheory.Measure.addHaar_affineSubspace","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\ns : AffineSubspace Real E\nhs : Ne s Top.top\nâŠ¢ Eq (Î¼ â†‘s) 0","decl":"/-- A strict affine subspace has measure zero. -/\ntheorem addHaar_affineSubspace {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E]\n    [MeasurableSpace E] [BorelSpace E] [FiniteDimensional â„ E] (Î¼ : Measure E) [IsAddHaarMeasure Î¼]\n    (s : AffineSubspace â„ E) (hs : s â‰  âŠ¤) : Î¼ s = 0 := by\n  rcases s.eq_bot_or_nonempty with (rfl | hne)\n  Â· rw [AffineSubspace.bot_coe, measure_empty]\n  rw [Ne, â† AffineSubspace.direction_eq_top_iff_of_nonempty hne] at hs\n  rcases hne with âŸ¨x, hx : x âˆˆ sâŸ©\n  simpa only [AffineSubspace.coe_direction_eq_vsub_set_right hx, vsub_eq_sub, sub_eq_add_neg,\n    image_add_right, neg_neg, measure_preimage_add_right] using addHaar_submodule Î¼ s.direction hs\n\n"}
{"name":"MeasureTheory.Measure.map_linearMap_addHaar_pi_eq_smul_addHaar","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"Î¹ : Type u_1\ninstâœÂ¹ : Finite Î¹\nf : LinearMap (RingHom.id Real) (Î¹ â†’ Real) (Î¹ â†’ Real)\nhf : Ne (LinearMap.det f) 0\nÎ¼ : MeasureTheory.Measure (Î¹ â†’ Real)\ninstâœ : Î¼.IsAddHaarMeasure\nâŠ¢ Eq (MeasureTheory.Measure.map (â‡‘f) Î¼) (HSMul.hSMul (ENNReal.ofReal (abs (Inv.inv (LinearMap.det f)))) Î¼)","decl":"theorem map_linearMap_addHaar_pi_eq_smul_addHaar {Î¹ : Type*} [Finite Î¹] {f : (Î¹ â†’ â„) â†’â‚—[â„] Î¹ â†’ â„}\n    (hf : LinearMap.det f â‰  0) (Î¼ : Measure (Î¹ â†’ â„)) [IsAddHaarMeasure Î¼] :\n    Measure.map f Î¼ = ENNReal.ofReal (abs (LinearMap.det f)â»Â¹) â€¢ Î¼ := by\n  cases nonempty_fintype Î¹\n  /- We have already proved the result for the Lebesgue product measure, using matrices.\n    We deduce it for any Haar measure by uniqueness (up to scalar multiplication). -/\n  have := addHaarMeasure_unique Î¼ (piIcc01 Î¹)\n  rw [this, addHaarMeasure_eq_volume_pi, Measure.map_smul,\n    Real.map_linearMap_volume_pi_eq_smul_volume_pi hf, smul_comm]\n\n"}
{"name":"MeasureTheory.Measure.map_linearMap_addHaar_eq_smul_addHaar","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nf : LinearMap (RingHom.id Real) E E\nhf : Ne (LinearMap.det f) 0\nâŠ¢ Eq (MeasureTheory.Measure.map (â‡‘f) Î¼) (HSMul.hSMul (ENNReal.ofReal (abs (Inv.inv (LinearMap.det f)))) Î¼)","decl":"theorem map_linearMap_addHaar_eq_smul_addHaar {f : E â†’â‚—[â„] E} (hf : LinearMap.det f â‰  0) :\n    Measure.map f Î¼ = ENNReal.ofReal |(LinearMap.det f)â»Â¹| â€¢ Î¼ := by\n  -- we reduce to the case of `E = Î¹ â†’ â„`, for which we have already proved the result using\n  -- matrices in `map_linearMap_addHaar_pi_eq_smul_addHaar`.\n  let Î¹ := Fin (finrank â„ E)\n  haveI : FiniteDimensional â„ (Î¹ â†’ â„) := by infer_instance\n  have : finrank â„ E = finrank â„ (Î¹ â†’ â„) := by simp [Î¹]\n  have e : E â‰ƒâ‚—[â„] Î¹ â†’ â„ := LinearEquiv.ofFinrankEq E (Î¹ â†’ â„) this\n  -- next line is to avoid `g` getting reduced by `simp`.\n  obtain âŸ¨g, hgâŸ© : âˆƒ g, g = (e : E â†’â‚—[â„] Î¹ â†’ â„).comp (f.comp (e.symm : (Î¹ â†’ â„) â†’â‚—[â„] E)) := âŸ¨_, rflâŸ©\n  have gdet : LinearMap.det g = LinearMap.det f := by rw [hg]; exact LinearMap.det_conj f e\n  rw [â† gdet] at hf âŠ¢\n  have fg : f = (e.symm : (Î¹ â†’ â„) â†’â‚—[â„] E).comp (g.comp (e : E â†’â‚—[â„] Î¹ â†’ â„)) := by\n    ext x\n    simp only [LinearEquiv.coe_coe, Function.comp_apply, LinearMap.coe_comp,\n      LinearEquiv.symm_apply_apply, hg]\n  simp only [fg, LinearEquiv.coe_coe, LinearMap.coe_comp]\n  have Ce : Continuous e := (e : E â†’â‚—[â„] Î¹ â†’ â„).continuous_of_finiteDimensional\n  have Cg : Continuous g := LinearMap.continuous_of_finiteDimensional g\n  have Cesymm : Continuous e.symm := (e.symm : (Î¹ â†’ â„) â†’â‚—[â„] E).continuous_of_finiteDimensional\n  rw [â† map_map Cesymm.measurable (Cg.comp Ce).measurable, â† map_map Cg.measurable Ce.measurable]\n  haveI : IsAddHaarMeasure (map e Î¼) := (e : E â‰ƒ+ (Î¹ â†’ â„)).isAddHaarMeasure_map Î¼ Ce Cesymm\n  have ecomp : e.symm âˆ˜ e = id := by\n    ext x; simp only [id, Function.comp_apply, LinearEquiv.symm_apply_apply]\n  rw [map_linearMap_addHaar_pi_eq_smul_addHaar hf (map e Î¼), Measure.map_smul,\n    map_map Cesymm.measurable Ce.measurable, ecomp, Measure.map_id]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_preimage_linearMap","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nf : LinearMap (RingHom.id Real) E E\nhf : Ne (LinearMap.det f) 0\ns : Set E\nâŠ¢ Eq (Î¼ (Set.preimage (â‡‘f) s)) (HMul.hMul (ENNReal.ofReal (abs (Inv.inv (LinearMap.det f)))) (Î¼ s))","decl":"/-- The preimage of a set `s` under a linear map `f` with nonzero determinant has measure\nequal to `Î¼ s` times the absolute value of the inverse of the determinant of `f`. -/\n@[simp]\ntheorem addHaar_preimage_linearMap {f : E â†’â‚—[â„] E} (hf : LinearMap.det f â‰  0) (s : Set E) :\n    Î¼ (f â»Â¹' s) = ENNReal.ofReal |(LinearMap.det f)â»Â¹| * Î¼ s :=\n  calc\n    Î¼ (f â»Â¹' s) = Measure.map f Î¼ s :=\n      ((f.equivOfDetNeZero hf).toContinuousLinearEquiv.toHomeomorph.toMeasurableEquiv.map_apply\n          s).symm\n    _ = ENNReal.ofReal |(LinearMap.det f)â»Â¹| * Î¼ s := by\n      rw [map_linearMap_addHaar_eq_smul_addHaar Î¼ hf]; rfl\n\n"}
{"name":"MeasureTheory.Measure.addHaar_preimage_continuousLinearMap","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nf : ContinuousLinearMap (RingHom.id Real) E E\nhf : Ne (LinearMap.det â†‘f) 0\ns : Set E\nâŠ¢ Eq (Î¼ (Set.preimage (â‡‘f) s)) (HMul.hMul (ENNReal.ofReal (abs (Inv.inv (LinearMap.det â†‘f)))) (Î¼ s))","decl":"/-- The preimage of a set `s` under a continuous linear map `f` with nonzero determinant has measure\nequal to `Î¼ s` times the absolute value of the inverse of the determinant of `f`. -/\n@[simp]\ntheorem addHaar_preimage_continuousLinearMap {f : E â†’L[â„] E}\n    (hf : LinearMap.det (f : E â†’â‚—[â„] E) â‰  0) (s : Set E) :\n    Î¼ (f â»Â¹' s) = ENNReal.ofReal (abs (LinearMap.det (f : E â†’â‚—[â„] E))â»Â¹) * Î¼ s :=\n  addHaar_preimage_linearMap Î¼ hf s\n\n"}
{"name":"MeasureTheory.Measure.addHaar_preimage_linearEquiv","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nf : LinearEquiv (RingHom.id Real) E E\ns : Set E\nâŠ¢ Eq (Î¼ (Set.preimage (â‡‘f) s)) (HMul.hMul (ENNReal.ofReal (abs (LinearMap.det â†‘f.symm))) (Î¼ s))","decl":"/-- The preimage of a set `s` under a linear equiv `f` has measure\nequal to `Î¼ s` times the absolute value of the inverse of the determinant of `f`. -/\n@[simp]\ntheorem addHaar_preimage_linearEquiv (f : E â‰ƒâ‚—[â„] E) (s : Set E) :\n    Î¼ (f â»Â¹' s) = ENNReal.ofReal |LinearMap.det (f.symm : E â†’â‚—[â„] E)| * Î¼ s := by\n  have A : LinearMap.det (f : E â†’â‚—[â„] E) â‰  0 := (LinearEquiv.isUnit_det' f).ne_zero\n  convert addHaar_preimage_linearMap Î¼ A s\n  simp only [LinearEquiv.det_coe_symm]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_preimage_continuousLinearEquiv","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nf : ContinuousLinearEquiv (RingHom.id Real) E E\ns : Set E\nâŠ¢ Eq (Î¼ (Set.preimage (â‡‘f) s)) (HMul.hMul (ENNReal.ofReal (abs (LinearMap.det â†‘â†‘f.symm))) (Î¼ s))","decl":"/-- The preimage of a set `s` under a continuous linear equiv `f` has measure\nequal to `Î¼ s` times the absolute value of the inverse of the determinant of `f`. -/\n@[simp]\ntheorem addHaar_preimage_continuousLinearEquiv (f : E â‰ƒL[â„] E) (s : Set E) :\n    Î¼ (f â»Â¹' s) = ENNReal.ofReal |LinearMap.det (f.symm : E â†’â‚—[â„] E)| * Î¼ s :=\n  addHaar_preimage_linearEquiv Î¼ _ s\n\n"}
{"name":"MeasureTheory.Measure.addHaar_image_linearMap","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nf : LinearMap (RingHom.id Real) E E\ns : Set E\nâŠ¢ Eq (Î¼ (Set.image (â‡‘f) s)) (HMul.hMul (ENNReal.ofReal (abs (LinearMap.det f))) (Î¼ s))","decl":"/-- The image of a set `s` under a linear map `f` has measure\nequal to `Î¼ s` times the absolute value of the determinant of `f`. -/\n@[simp]\ntheorem addHaar_image_linearMap (f : E â†’â‚—[â„] E) (s : Set E) :\n    Î¼ (f '' s) = ENNReal.ofReal |LinearMap.det f| * Î¼ s := by\n  rcases ne_or_eq (LinearMap.det f) 0 with (hf | hf)\n  Â· let g := (f.equivOfDetNeZero hf).toContinuousLinearEquiv\n    change Î¼ (g '' s) = _\n    rw [ContinuousLinearEquiv.image_eq_preimage g s, addHaar_preimage_continuousLinearEquiv]\n    congr\n  Â· simp only [hf, zero_mul, ENNReal.ofReal_zero, abs_zero]\n    have : Î¼ (LinearMap.range f) = 0 :=\n      addHaar_submodule Î¼ _ (LinearMap.range_lt_top_of_det_eq_zero hf).ne\n    exact le_antisymm (le_trans (measure_mono (image_subset_range _ _)) this.le) (zero_le _)\n\n"}
{"name":"MeasureTheory.Measure.addHaar_image_continuousLinearMap","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nf : ContinuousLinearMap (RingHom.id Real) E E\ns : Set E\nâŠ¢ Eq (Î¼ (Set.image (â‡‘f) s)) (HMul.hMul (ENNReal.ofReal (abs (LinearMap.det â†‘f))) (Î¼ s))","decl":"/-- The image of a set `s` under a continuous linear map `f` has measure\nequal to `Î¼ s` times the absolute value of the determinant of `f`. -/\n@[simp]\ntheorem addHaar_image_continuousLinearMap (f : E â†’L[â„] E) (s : Set E) :\n    Î¼ (f '' s) = ENNReal.ofReal |LinearMap.det (f : E â†’â‚—[â„] E)| * Î¼ s :=\n  addHaar_image_linearMap Î¼ _ s\n\n"}
{"name":"MeasureTheory.Measure.addHaar_image_continuousLinearEquiv","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nf : ContinuousLinearEquiv (RingHom.id Real) E E\ns : Set E\nâŠ¢ Eq (Î¼ (Set.image (â‡‘f) s)) (HMul.hMul (ENNReal.ofReal (abs (LinearMap.det â†‘â†‘f))) (Î¼ s))","decl":"/-- The image of a set `s` under a continuous linear equiv `f` has measure\nequal to `Î¼ s` times the absolute value of the determinant of `f`. -/\n@[simp]\ntheorem addHaar_image_continuousLinearEquiv (f : E â‰ƒL[â„] E) (s : Set E) :\n    Î¼ (f '' s) = ENNReal.ofReal |LinearMap.det (f : E â†’â‚—[â„] E)| * Î¼ s :=\n  Î¼.addHaar_image_linearMap (f : E â†’â‚—[â„] E) s\n\n"}
{"name":"MeasureTheory.Measure.LinearMap.quasiMeasurePreserving","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nf : LinearMap (RingHom.id Real) E E\nhf : Ne (LinearMap.det f) 0\nâŠ¢ MeasureTheory.Measure.QuasiMeasurePreserving (â‡‘f) Î¼ Î¼","decl":"theorem LinearMap.quasiMeasurePreserving (f : E â†’â‚—[â„] E) (hf : LinearMap.det f â‰  0) :\n    QuasiMeasurePreserving f Î¼ Î¼ := by\n  refine âŸ¨f.continuous_of_finiteDimensional.measurable, ?_âŸ©\n  rw [map_linearMap_addHaar_eq_smul_addHaar Î¼ hf]\n  exact smul_absolutelyContinuous\n\n"}
{"name":"MeasureTheory.Measure.ContinuousLinearMap.quasiMeasurePreserving","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nf : ContinuousLinearMap (RingHom.id Real) E E\nhf : Ne f.det 0\nâŠ¢ MeasureTheory.Measure.QuasiMeasurePreserving (â‡‘f) Î¼ Î¼","decl":"theorem ContinuousLinearMap.quasiMeasurePreserving (f : E â†’L[â„] E) (hf : f.det â‰  0) :\n    QuasiMeasurePreserving f Î¼ Î¼ :=\n  LinearMap.quasiMeasurePreserving Î¼ (f : E â†’â‚—[â„] E) hf\n\n"}
{"name":"MeasureTheory.Measure.map_addHaar_smul","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nr : Real\nhr : Ne r 0\nâŠ¢ Eq (MeasureTheory.Measure.map (fun x => HSMul.hSMul r x) Î¼) (HSMul.hSMul (ENNReal.ofReal (abs (Inv.inv (HPow.hPow r (Module.finrank Real E))))) Î¼)","decl":"theorem map_addHaar_smul {r : â„} (hr : r â‰  0) :\n    Measure.map (r â€¢ Â·) Î¼ = ENNReal.ofReal (abs (r ^ finrank â„ E)â»Â¹) â€¢ Î¼ := by\n  let f : E â†’â‚—[â„] E := r â€¢ (1 : E â†’â‚—[â„] E)\n  change Measure.map f Î¼ = _\n  have hf : LinearMap.det f â‰  0 := by\n    simp only [f, mul_one, LinearMap.det_smul, Ne, MonoidHom.map_one]\n    intro h\n    exact hr (pow_eq_zero h)\n  simp only [f, map_linearMap_addHaar_eq_smul_addHaar Î¼ hf, mul_one, LinearMap.det_smul, map_one]\n\n"}
{"name":"MeasureTheory.Measure.quasiMeasurePreserving_smul","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nr : Real\nhr : Ne r 0\nâŠ¢ MeasureTheory.Measure.QuasiMeasurePreserving (fun x => HSMul.hSMul r x) Î¼ Î¼","decl":"theorem quasiMeasurePreserving_smul {r : â„} (hr : r â‰  0) :\n    QuasiMeasurePreserving (r â€¢ Â·) Î¼ Î¼ := by\n  refine âŸ¨measurable_const_smul r, ?_âŸ©\n  rw [map_addHaar_smul Î¼ hr]\n  exact smul_absolutelyContinuous\n\n"}
{"name":"MeasureTheory.Measure.addHaar_preimage_smul","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nr : Real\nhr : Ne r 0\ns : Set E\nâŠ¢ Eq (Î¼ (Set.preimage (fun x => HSMul.hSMul r x) s)) (HMul.hMul (ENNReal.ofReal (abs (Inv.inv (HPow.hPow r (Module.finrank Real E))))) (Î¼ s))","decl":"@[simp]\ntheorem addHaar_preimage_smul {r : â„} (hr : r â‰  0) (s : Set E) :\n    Î¼ ((r â€¢ Â·) â»Â¹' s) = ENNReal.ofReal (abs (r ^ finrank â„ E)â»Â¹) * Î¼ s :=\n  calc\n    Î¼ ((r â€¢ Â·) â»Â¹' s) = Measure.map (r â€¢ Â·) Î¼ s :=\n      ((Homeomorph.smul (isUnit_iff_ne_zero.2 hr).unit).toMeasurableEquiv.map_apply s).symm\n    _ = ENNReal.ofReal (abs (r ^ finrank â„ E)â»Â¹) * Î¼ s := by\n      rw [map_addHaar_smul Î¼ hr, coe_smul, Pi.smul_apply, smul_eq_mul]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_smul","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nr : Real\ns : Set E\nâŠ¢ Eq (Î¼ (HSMul.hSMul r s)) (HMul.hMul (ENNReal.ofReal (abs (HPow.hPow r (Module.finrank Real E)))) (Î¼ s))","decl":"/-- Rescaling a set by a factor `r` multiplies its measure by `abs (r ^ dim)`. -/\n@[simp]\ntheorem addHaar_smul (r : â„) (s : Set E) :\n    Î¼ (r â€¢ s) = ENNReal.ofReal (abs (r ^ finrank â„ E)) * Î¼ s := by\n  rcases ne_or_eq r 0 with (h | rfl)\n  Â· rw [â† preimage_smul_invâ‚€ h, addHaar_preimage_smul Î¼ (inv_ne_zero h), inv_pow, inv_inv]\n  rcases eq_empty_or_nonempty s with (rfl | hs)\n  Â· simp only [measure_empty, mul_zero, smul_set_empty]\n  rw [zero_smul_set hs, â† singleton_zero]\n  by_cases h : finrank â„ E = 0\n  Â· haveI : Subsingleton E := finrank_zero_iff.1 h\n    simp only [h, one_mul, ENNReal.ofReal_one, abs_one, Subsingleton.eq_univ_of_nonempty hs,\n      pow_zero, Subsingleton.eq_univ_of_nonempty (singleton_nonempty (0 : E))]\n  Â· haveI : Nontrivial E := nontrivial_of_finrank_pos (bot_lt_iff_ne_bot.2 h)\n    simp only [h, zero_mul, ENNReal.ofReal_zero, abs_zero, Ne, not_false_iff,\n      zero_pow, measure_singleton]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_smul_of_nonneg","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nr : Real\nhr : LE.le 0 r\ns : Set E\nâŠ¢ Eq (Î¼ (HSMul.hSMul r s)) (HMul.hMul (ENNReal.ofReal (HPow.hPow r (Module.finrank Real E))) (Î¼ s))","decl":"theorem addHaar_smul_of_nonneg {r : â„} (hr : 0 â‰¤ r) (s : Set E) :\n    Î¼ (r â€¢ s) = ENNReal.ofReal (r ^ finrank â„ E) * Î¼ s := by\n  rw [addHaar_smul, abs_pow, abs_of_nonneg hr]\n\n"}
{"name":"MeasureTheory.Measure.NullMeasurableSet.const_smul","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\ns : Set E\nhs : MeasureTheory.NullMeasurableSet s Î¼\nr : Real\nâŠ¢ MeasureTheory.NullMeasurableSet (HSMul.hSMul r s) Î¼","decl":"theorem NullMeasurableSet.const_smul (hs : NullMeasurableSet s Î¼) (r : â„) :\n    NullMeasurableSet (r â€¢ s) Î¼ := by\n  obtain rfl | hs' := s.eq_empty_or_nonempty\n  Â· simp\n  obtain rfl | hr := eq_or_ne r 0\n  Â· simpa [zero_smul_set hs'] using nullMeasurableSet_singleton _\n  obtain âŸ¨t, ht, hstâŸ© := hs\n  refine âŸ¨_, ht.const_smul_of_ne_zero hr, ?_âŸ©\n  rw [â† measure_symmDiff_eq_zero_iff] at hst âŠ¢\n  rw [â† smul_set_symmDiffâ‚€ hr, addHaar_smul Î¼, hst, mul_zero]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_image_homothety","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nx : E\nr : Real\ns : Set E\nâŠ¢ Eq (Î¼ (Set.image (â‡‘(AffineMap.homothety x r)) s)) (HMul.hMul (ENNReal.ofReal (abs (HPow.hPow r (Module.finrank Real E)))) (Î¼ s))","decl":"@[simp]\ntheorem addHaar_image_homothety (x : E) (r : â„) (s : Set E) :\n    Î¼ (AffineMap.homothety x r '' s) = ENNReal.ofReal (abs (r ^ finrank â„ E)) * Î¼ s :=\n  calc\n    Î¼ (AffineMap.homothety x r '' s) = Î¼ ((fun y => y + x) '' (r â€¢ (fun y => y + -x) '' s)) := by\n      simp only [â† image_smul, image_image, â† sub_eq_add_neg]; rfl\n    _ = ENNReal.ofReal (abs (r ^ finrank â„ E)) * Î¼ s := by\n      simp only [image_add_right, measure_preimage_add_right, addHaar_smul]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_ball_center","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nx : E\nr : Real\nâŠ¢ Eq (Î¼ (Metric.ball x r)) (Î¼ (Metric.ball 0 r))","decl":"theorem addHaar_ball_center {E : Type*} [NormedAddCommGroup E] [MeasurableSpace E] [BorelSpace E]\n    (Î¼ : Measure E) [IsAddHaarMeasure Î¼] (x : E) (r : â„) : Î¼ (ball x r) = Î¼ (ball (0 : E) r) := by\n  have : ball (0 : E) r = (x + Â·) â»Â¹' ball x r := by simp [preimage_add_ball]\n  rw [this, measure_preimage_add]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_closedBall_center","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nx : E\nr : Real\nâŠ¢ Eq (Î¼ (Metric.closedBall x r)) (Î¼ (Metric.closedBall 0 r))","decl":"theorem addHaar_closedBall_center {E : Type*} [NormedAddCommGroup E] [MeasurableSpace E]\n    [BorelSpace E] (Î¼ : Measure E) [IsAddHaarMeasure Î¼] (x : E) (r : â„) :\n    Î¼ (closedBall x r) = Î¼ (closedBall (0 : E) r) := by\n  have : closedBall (0 : E) r = (x + Â·) â»Â¹' closedBall x r := by simp [preimage_add_closedBall]\n  rw [this, measure_preimage_add]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_ball_mul_of_pos","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nx : E\nr : Real\nhr : LT.lt 0 r\ns : Real\nâŠ¢ Eq (Î¼ (Metric.ball x (HMul.hMul r s))) (HMul.hMul (ENNReal.ofReal (HPow.hPow r (Module.finrank Real E))) (Î¼ (Metric.ball 0 s)))","decl":"theorem addHaar_ball_mul_of_pos (x : E) {r : â„} (hr : 0 < r) (s : â„) :\n    Î¼ (ball x (r * s)) = ENNReal.ofReal (r ^ finrank â„ E) * Î¼ (ball 0 s) := by\n  have : ball (0 : E) (r * s) = r â€¢ ball (0 : E) s := by\n    simp only [_root_.smul_ball hr.ne' (0 : E) s, Real.norm_eq_abs, abs_of_nonneg hr.le, smul_zero]\n  simp only [this, addHaar_smul, abs_of_nonneg hr.le, addHaar_ball_center, abs_pow]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_ball_of_pos","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nx : E\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Eq (Î¼ (Metric.ball x r)) (HMul.hMul (ENNReal.ofReal (HPow.hPow r (Module.finrank Real E))) (Î¼ (Metric.ball 0 1)))","decl":"theorem addHaar_ball_of_pos (x : E) {r : â„} (hr : 0 < r) :\n    Î¼ (ball x r) = ENNReal.ofReal (r ^ finrank â„ E) * Î¼ (ball 0 1) := by\n  rw [â† addHaar_ball_mul_of_pos Î¼ x hr, mul_one]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_ball_mul","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\ninstâœâ´ : MeasurableSpace E\ninstâœÂ³ : BorelSpace E\ninstâœÂ² : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ¹ : Î¼.IsAddHaarMeasure\ninstâœ : Nontrivial E\nx : E\nr : Real\nhr : LE.le 0 r\ns : Real\nâŠ¢ Eq (Î¼ (Metric.ball x (HMul.hMul r s))) (HMul.hMul (ENNReal.ofReal (HPow.hPow r (Module.finrank Real E))) (Î¼ (Metric.ball 0 s)))","decl":"theorem addHaar_ball_mul [Nontrivial E] (x : E) {r : â„} (hr : 0 â‰¤ r) (s : â„) :\n    Î¼ (ball x (r * s)) = ENNReal.ofReal (r ^ finrank â„ E) * Î¼ (ball 0 s) := by\n  rcases hr.eq_or_lt with (rfl | h)\n  Â· simp only [zero_pow (finrank_pos (R := â„) (M := E)).ne', measure_empty, zero_mul,\n      ENNReal.ofReal_zero, ball_zero]\n  Â· exact addHaar_ball_mul_of_pos Î¼ x h s\n\n"}
{"name":"MeasureTheory.Measure.addHaar_ball","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\ninstâœâ´ : MeasurableSpace E\ninstâœÂ³ : BorelSpace E\ninstâœÂ² : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ¹ : Î¼.IsAddHaarMeasure\ninstâœ : Nontrivial E\nx : E\nr : Real\nhr : LE.le 0 r\nâŠ¢ Eq (Î¼ (Metric.ball x r)) (HMul.hMul (ENNReal.ofReal (HPow.hPow r (Module.finrank Real E))) (Î¼ (Metric.ball 0 1)))","decl":"theorem addHaar_ball [Nontrivial E] (x : E) {r : â„} (hr : 0 â‰¤ r) :\n    Î¼ (ball x r) = ENNReal.ofReal (r ^ finrank â„ E) * Î¼ (ball 0 1) := by\n  rw [â† addHaar_ball_mul Î¼ x hr, mul_one]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_closedBall_mul_of_pos","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nx : E\nr : Real\nhr : LT.lt 0 r\ns : Real\nâŠ¢ Eq (Î¼ (Metric.closedBall x (HMul.hMul r s))) (HMul.hMul (ENNReal.ofReal (HPow.hPow r (Module.finrank Real E))) (Î¼ (Metric.closedBall 0 s)))","decl":"theorem addHaar_closedBall_mul_of_pos (x : E) {r : â„} (hr : 0 < r) (s : â„) :\n    Î¼ (closedBall x (r * s)) = ENNReal.ofReal (r ^ finrank â„ E) * Î¼ (closedBall 0 s) := by\n  have : closedBall (0 : E) (r * s) = r â€¢ closedBall (0 : E) s := by\n    simp [smul_closedBall' hr.ne' (0 : E), abs_of_nonneg hr.le]\n  simp only [this, addHaar_smul, abs_of_nonneg hr.le, addHaar_closedBall_center, abs_pow]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_closedBall_mul","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nx : E\nr : Real\nhr : LE.le 0 r\ns : Real\nhs : LE.le 0 s\nâŠ¢ Eq (Î¼ (Metric.closedBall x (HMul.hMul r s))) (HMul.hMul (ENNReal.ofReal (HPow.hPow r (Module.finrank Real E))) (Î¼ (Metric.closedBall 0 s)))","decl":"theorem addHaar_closedBall_mul (x : E) {r : â„} (hr : 0 â‰¤ r) {s : â„} (hs : 0 â‰¤ s) :\n    Î¼ (closedBall x (r * s)) = ENNReal.ofReal (r ^ finrank â„ E) * Î¼ (closedBall 0 s) := by\n  have : closedBall (0 : E) (r * s) = r â€¢ closedBall (0 : E) s := by\n    simp [smul_closedBall r (0 : E) hs, abs_of_nonneg hr]\n  simp only [this, addHaar_smul, abs_of_nonneg hr, addHaar_closedBall_center, abs_pow]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_closedBall'","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nx : E\nr : Real\nhr : LE.le 0 r\nâŠ¢ Eq (Î¼ (Metric.closedBall x r)) (HMul.hMul (ENNReal.ofReal (HPow.hPow r (Module.finrank Real E))) (Î¼ (Metric.closedBall 0 1)))","decl":"/-- The measure of a closed ball can be expressed in terms of the measure of the closed unit ball.\nUse instead `addHaar_closedBall`, which uses the measure of the open unit ball as a standard\nform. -/\ntheorem addHaar_closedBall' (x : E) {r : â„} (hr : 0 â‰¤ r) :\n    Î¼ (closedBall x r) = ENNReal.ofReal (r ^ finrank â„ E) * Î¼ (closedBall 0 1) := by\n  rw [â† addHaar_closedBall_mul Î¼ x hr zero_le_one, mul_one]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_unitClosedBall_eq_addHaar_unitBall","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nâŠ¢ Eq (Î¼ (Metric.closedBall 0 1)) (Î¼ (Metric.ball 0 1))","decl":"theorem addHaar_unitClosedBall_eq_addHaar_unitBall :\n    Î¼ (closedBall (0 : E) 1) = Î¼ (ball 0 1) := by\n  apply le_antisymm _ (measure_mono ball_subset_closedBall)\n  have A : Tendsto\n      (fun r : â„ => ENNReal.ofReal (r ^ finrank â„ E) * Î¼ (closedBall (0 : E) 1)) (ğ“[<] 1)\n        (ğ“ (ENNReal.ofReal ((1 : â„) ^ finrank â„ E) * Î¼ (closedBall (0 : E) 1))) := by\n    refine ENNReal.Tendsto.mul ?_ (by simp) tendsto_const_nhds (by simp)\n    exact ENNReal.tendsto_ofReal ((tendsto_id'.2 nhdsWithin_le_nhds).pow _)\n  simp only [one_pow, one_mul, ENNReal.ofReal_one] at A\n  refine le_of_tendsto A ?_\n  filter_upwards [Ioo_mem_nhdsLT zero_lt_one] with r hr\n  rw [â† addHaar_closedBall' Î¼ (0 : E) hr.1.le]\n  exact measure_mono (closedBall_subset_ball hr.2)\n\n"}
{"name":"MeasureTheory.Measure.addHaar_closed_unit_ball_eq_addHaar_unit_ball","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nâŠ¢ Eq (Î¼ (Metric.closedBall 0 1)) (Î¼ (Metric.ball 0 1))","decl":"@[deprecated (since := \"2024-12-01\")]\nalias addHaar_closed_unit_ball_eq_addHaar_unit_ball := addHaar_unitClosedBall_eq_addHaar_unitBall\n\n"}
{"name":"MeasureTheory.Measure.addHaar_closedBall","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nx : E\nr : Real\nhr : LE.le 0 r\nâŠ¢ Eq (Î¼ (Metric.closedBall x r)) (HMul.hMul (ENNReal.ofReal (HPow.hPow r (Module.finrank Real E))) (Î¼ (Metric.ball 0 1)))","decl":"theorem addHaar_closedBall (x : E) {r : â„} (hr : 0 â‰¤ r) :\n    Î¼ (closedBall x r) = ENNReal.ofReal (r ^ finrank â„ E) * Î¼ (ball 0 1) := by\n  rw [addHaar_closedBall' Î¼ x hr, addHaar_unitClosedBall_eq_addHaar_unitBall]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_closedBall_eq_addHaar_ball","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\ninstâœâ´ : MeasurableSpace E\ninstâœÂ³ : BorelSpace E\ninstâœÂ² : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ¹ : Î¼.IsAddHaarMeasure\ninstâœ : Nontrivial E\nx : E\nr : Real\nâŠ¢ Eq (Î¼ (Metric.closedBall x r)) (Î¼ (Metric.ball x r))","decl":"theorem addHaar_closedBall_eq_addHaar_ball [Nontrivial E] (x : E) (r : â„) :\n    Î¼ (closedBall x r) = Î¼ (ball x r) := by\n  by_cases h : r < 0\n  Â· rw [Metric.closedBall_eq_empty.mpr h, Metric.ball_eq_empty.mpr h.le]\n  push_neg at h\n  rw [addHaar_closedBall Î¼ x h, addHaar_ball Î¼ x h]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_sphere_of_ne_zero","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nx : E\nr : Real\nhr : Ne r 0\nâŠ¢ Eq (Î¼ (Metric.sphere x r)) 0","decl":"theorem addHaar_sphere_of_ne_zero (x : E) {r : â„} (hr : r â‰  0) : Î¼ (sphere x r) = 0 := by\n  rcases hr.lt_or_lt with (h | h)\n  Â· simp only [empty_diff, measure_empty, â† closedBall_diff_ball, closedBall_eq_empty.2 h]\n  Â· rw [â† closedBall_diff_ball,\n      measure_diff ball_subset_closedBall measurableSet_ball.nullMeasurableSet\n        measure_ball_lt_top.ne,\n      addHaar_ball_of_pos Î¼ _ h, addHaar_closedBall Î¼ _ h.le, tsub_self]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_sphere","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\ninstâœâ´ : MeasurableSpace E\ninstâœÂ³ : BorelSpace E\ninstâœÂ² : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ¹ : Î¼.IsAddHaarMeasure\ninstâœ : Nontrivial E\nx : E\nr : Real\nâŠ¢ Eq (Î¼ (Metric.sphere x r)) 0","decl":"theorem addHaar_sphere [Nontrivial E] (x : E) (r : â„) : Î¼ (sphere x r) = 0 := by\n  rcases eq_or_ne r 0 with (rfl | h)\n  Â· rw [sphere_zero, measure_singleton]\n  Â· exact addHaar_sphere_of_ne_zero Î¼ x h\n\n"}
{"name":"MeasureTheory.Measure.addHaar_singleton_add_smul_div_singleton_add_smul","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nr : Real\nhr : Ne r 0\nx y : E\ns t : Set E\nâŠ¢ Eq (HDiv.hDiv (Î¼ (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r s))) (Î¼ (HAdd.hAdd (Singleton.singleton y) (HSMul.hSMul r t)))) (HDiv.hDiv (Î¼ s) (Î¼ t))","decl":"theorem addHaar_singleton_add_smul_div_singleton_add_smul {r : â„} (hr : r â‰  0) (x y : E)\n    (s t : Set E) : Î¼ ({x} + r â€¢ s) / Î¼ ({y} + r â€¢ t) = Î¼ s / Î¼ t :=\n  calc\n    Î¼ ({x} + r â€¢ s) / Î¼ ({y} + r â€¢ t) = ENNReal.ofReal (|r| ^ finrank â„ E) * Î¼ s *\n        (ENNReal.ofReal (|r| ^ finrank â„ E) * Î¼ t)â»Â¹ := by\n      simp only [div_eq_mul_inv, addHaar_smul, image_add_left, measure_preimage_add, abs_pow,\n        singleton_add]\n    _ = ENNReal.ofReal (|r| ^ finrank â„ E) * (ENNReal.ofReal (|r| ^ finrank â„ E))â»Â¹ *\n          (Î¼ s * (Î¼ t)â»Â¹) := by\n      rw [ENNReal.mul_inv]\n      Â· ring\n      Â· simp only [pow_pos (abs_pos.mpr hr), ENNReal.ofReal_eq_zero, not_le, Ne, true_or]\n      Â· simp only [ENNReal.ofReal_ne_top, true_or, Ne, not_false_iff]\n    _ = Î¼ s / Î¼ t := by\n      rw [ENNReal.mul_inv_cancel, one_mul, div_eq_mul_inv]\n      Â· simp only [pow_pos (abs_pos.mpr hr), ENNReal.ofReal_eq_zero, not_le, Ne]\n      Â· simp only [ENNReal.ofReal_ne_top, Ne, not_false_iff]\n\n"}
{"name":"MeasureTheory.Measure.isUnifLocDoublingMeasureOfIsAddHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : MeasurableSpace E\nÎ¼ : MeasureTheory.Measure E\nâŠ¢ IsUnifLocDoublingMeasure Î¼","decl":"instance (priority := 100) isUnifLocDoublingMeasureOfIsAddHaarMeasure :\n    IsUnifLocDoublingMeasure Î¼ := by\n  refine âŸ¨âŸ¨(2 : â„â‰¥0) ^ finrank â„ E, ?_âŸ©âŸ©\n  filter_upwards [self_mem_nhdsWithin] with r hr x\n  rw [addHaar_closedBall_mul Î¼ x zero_le_two (le_of_lt hr), addHaar_closedBall_center Î¼ x,\n    ENNReal.ofReal, Real.toNNReal_pow zero_le_two]\n  simp only [Real.toNNReal_ofNat, le_refl]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_parallelepiped","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"Î¹ : Type u_2\nG : Type u_3\ninstâœâµ : Fintype Î¹\ninstâœâ´ : DecidableEq Î¹\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace Real G\ninstâœÂ¹ : MeasurableSpace G\ninstâœ : BorelSpace G\nb : Basis Î¹ Real G\nv : Î¹ â†’ G\nâŠ¢ Eq (b.addHaar (parallelepiped v)) (ENNReal.ofReal (abs (b.det v)))","decl":"theorem addHaar_parallelepiped (b : Basis Î¹ â„ G) (v : Î¹ â†’ G) :\n    b.addHaar (parallelepiped v) = ENNReal.ofReal |b.det v| := by\n  have : FiniteDimensional â„ G := FiniteDimensional.of_fintype_basis b\n  have A : parallelepiped v = b.constr â„• v '' parallelepiped b := by\n    rw [image_parallelepiped]\n    -- Porting note: was `congr 1 with i` but Lean 4 `congr` applies `ext` first\n    refine congr_arg _ <| funext fun i â†¦ ?_\n    exact (b.constr_basis â„• v i).symm\n  rw [A, addHaar_image_linearMap, b.addHaar_self, mul_one, â† LinearMap.det_toMatrix b,\n    â† Basis.toMatrix_eq_toMatrix_constr, Basis.det_apply]\n\n"}
{"name":"AlternatingMap.measure_def","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"G : Type u_4\ninstâœâ´ : NormedAddCommGroup G\ninstâœÂ³ : NormedSpace Real G\ninstâœÂ² : MeasurableSpace G\ninstâœÂ¹ : BorelSpace G\ninstâœ : FiniteDimensional Real G\nn : Nat\n_i : Fact (Eq (Module.finrank Real G) n)\nÏ‰ : AlternatingMap Real G Real (Fin n)\nâŠ¢ Eq Ï‰.measure (HSMul.hSMul (NNNorm.nnnorm (Ï‰ â‡‘(Module.finBasisOfFinrankEq Real G â‹¯))) (Module.finBasisOfFinrankEq Real G â‹¯).addHaar)","decl":"/-- The Lebesgue measure associated to an alternating map. It gives measure `|Ï‰ v|` to the\nparallelepiped spanned by the vectors `vâ‚, ..., vâ‚™`. Note that it is not always a Haar measure,\nas it can be zero, but it is always locally finite and translation invariant. -/\nnoncomputable irreducible_def _root_.AlternatingMap.measure (Ï‰ : G [â‹€^Fin n]â†’â‚—[â„] â„) :\n    Measure G :=\n  â€–Ï‰ (finBasisOfFinrankEq â„ G _i.out)â€–â‚Š â€¢ (finBasisOfFinrankEq â„ G _i.out).addHaar\n\n"}
{"name":"AlternatingMap.measure_parallelepiped","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"G : Type u_3\ninstâœâ´ : NormedAddCommGroup G\ninstâœÂ³ : NormedSpace Real G\ninstâœÂ² : MeasurableSpace G\ninstâœÂ¹ : BorelSpace G\ninstâœ : FiniteDimensional Real G\nn : Nat\n_i : Fact (Eq (Module.finrank Real G) n)\nÏ‰ : AlternatingMap Real G Real (Fin n)\nv : Fin n â†’ G\nâŠ¢ Eq (Ï‰.measure (parallelepiped v)) (ENNReal.ofReal (abs (Ï‰ v)))","decl":"theorem _root_.AlternatingMap.measure_parallelepiped (Ï‰ : G [â‹€^Fin n]â†’â‚—[â„] â„)\n    (v : Fin n â†’ G) : Ï‰.measure (parallelepiped v) = ENNReal.ofReal |Ï‰ v| := by\n  conv_rhs => rw [Ï‰.eq_smul_basis_det (finBasisOfFinrankEq â„ G _i.out)]\n  simp only [addHaar_parallelepiped, AlternatingMap.measure, coe_nnreal_smul_apply,\n    AlternatingMap.smul_apply, Algebra.id.smul_eq_mul, abs_mul, ENNReal.ofReal_mul (abs_nonneg _),\n    â† Real.enorm_eq_ofReal_abs, enorm]\n\n"}
{"name":"MeasureTheory.Measure.instIsAddLeftInvariantMeasure","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"G : Type u_3\ninstâœâ´ : NormedAddCommGroup G\ninstâœÂ³ : NormedSpace Real G\ninstâœÂ² : MeasurableSpace G\ninstâœÂ¹ : BorelSpace G\ninstâœ : FiniteDimensional Real G\nn : Nat\n_i : Fact (Eq (Module.finrank Real G) n)\nÏ‰ : AlternatingMap Real G Real (Fin n)\nâŠ¢ Ï‰.measure.IsAddLeftInvariant","decl":"instance (Ï‰ : G [â‹€^Fin n]â†’â‚—[â„] â„) : IsAddLeftInvariant Ï‰.measure := by\n  rw [AlternatingMap.measure]; infer_instance\n\n"}
{"name":"MeasureTheory.Measure.instIsLocallyFiniteMeasureMeasure","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"G : Type u_3\ninstâœâ´ : NormedAddCommGroup G\ninstâœÂ³ : NormedSpace Real G\ninstâœÂ² : MeasurableSpace G\ninstâœÂ¹ : BorelSpace G\ninstâœ : FiniteDimensional Real G\nn : Nat\n_i : Fact (Eq (Module.finrank Real G) n)\nÏ‰ : AlternatingMap Real G Real (Fin n)\nâŠ¢ MeasureTheory.IsLocallyFiniteMeasure Ï‰.measure","decl":"instance (Ï‰ : G [â‹€^Fin n]â†’â‚—[â„] â„) : IsLocallyFiniteMeasure Ï‰.measure := by\n  rw [AlternatingMap.measure]; infer_instance\n\n"}
{"name":"MeasureTheory.Measure.tendsto_addHaar_inter_smul_zero_of_density_zero_aux1","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\ns : Set E\nx : E\nh : Filter.Tendsto (fun r => HDiv.hDiv (Î¼ (Inter.inter s (Metric.closedBall x r))) (Î¼ (Metric.closedBall x r))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)\nt u : Set E\nh'u : Ne (Î¼ u) 0\nt_bound : HasSubset.Subset t (Metric.closedBall 0 1)\nâŠ¢ Filter.Tendsto (fun r => HDiv.hDiv (Î¼ (Inter.inter s (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r t)))) (Î¼ (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r u)))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)","decl":"theorem tendsto_addHaar_inter_smul_zero_of_density_zero_aux1 (s : Set E) (x : E)\n    (h : Tendsto (fun r => Î¼ (s âˆ© closedBall x r) / Î¼ (closedBall x r)) (ğ“[>] 0) (ğ“ 0)) (t : Set E)\n    (u : Set E) (h'u : Î¼ u â‰  0) (t_bound : t âŠ† closedBall 0 1) :\n    Tendsto (fun r : â„ => Î¼ (s âˆ© ({x} + r â€¢ t)) / Î¼ ({x} + r â€¢ u)) (ğ“[>] 0) (ğ“ 0) := by\n  have A : Tendsto (fun r : â„ => Î¼ (s âˆ© ({x} + r â€¢ t)) / Î¼ (closedBall x r)) (ğ“[>] 0) (ğ“ 0) := by\n    apply\n      tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds h\n        (Eventually.of_forall fun b => zero_le _)\n    filter_upwards [self_mem_nhdsWithin]\n    rintro r (rpos : 0 < r)\n    rw [â† affinity_unitClosedBall rpos.le, singleton_add, â† image_vadd]\n    gcongr\n  have B :\n    Tendsto (fun r : â„ => Î¼ (closedBall x r) / Î¼ ({x} + r â€¢ u)) (ğ“[>] 0)\n      (ğ“ (Î¼ (closedBall x 1) / Î¼ ({x} + u))) := by\n    apply tendsto_const_nhds.congr' _\n    filter_upwards [self_mem_nhdsWithin]\n    rintro r (rpos : 0 < r)\n    have : closedBall x r = {x} + r â€¢ closedBall (0 : E) 1 := by\n      simp only [_root_.smul_closedBall, Real.norm_of_nonneg rpos.le, zero_le_one, add_zero,\n        mul_one, singleton_add_closedBall, smul_zero]\n    simp only [this, addHaar_singleton_add_smul_div_singleton_add_smul Î¼ rpos.ne']\n    simp only [addHaar_closedBall_center, image_add_left, measure_preimage_add, singleton_add]\n  have C : Tendsto (fun r : â„ =>\n        Î¼ (s âˆ© ({x} + r â€¢ t)) / Î¼ (closedBall x r) * (Î¼ (closedBall x r) / Î¼ ({x} + r â€¢ u)))\n      (ğ“[>] 0) (ğ“ (0 * (Î¼ (closedBall x 1) / Î¼ ({x} + u)))) := by\n    apply ENNReal.Tendsto.mul A _ B (Or.inr ENNReal.zero_ne_top)\n    simp only [ne_eq, not_true, singleton_add, image_add_left, measure_preimage_add, false_or,\n      ENNReal.div_eq_top, h'u, not_and, and_false]\n    intro aux\n    exact (measure_closedBall_lt_top.ne aux).elim\n    -- Porting note: it used to be enough to pass `measure_closedBall_lt_top.ne` to `simp`\n    -- and avoid the `intro; exact` dance.\n  simp only [zero_mul] at C\n  apply C.congr' _\n  filter_upwards [self_mem_nhdsWithin]\n  rintro r (rpos : 0 < r)\n  calc\n    Î¼ (s âˆ© ({x} + r â€¢ t)) / Î¼ (closedBall x r) * (Î¼ (closedBall x r) / Î¼ ({x} + r â€¢ u)) =\n        Î¼ (closedBall x r) * (Î¼ (closedBall x r))â»Â¹ * (Î¼ (s âˆ© ({x} + r â€¢ t)) / Î¼ ({x} + r â€¢ u)) :=\n      by simp only [div_eq_mul_inv]; ring\n    _ = Î¼ (s âˆ© ({x} + r â€¢ t)) / Î¼ ({x} + r â€¢ u) := by\n      rw [ENNReal.mul_inv_cancel (measure_closedBall_pos Î¼ x rpos).ne'\n          measure_closedBall_lt_top.ne,\n        one_mul]\n\n"}
{"name":"MeasureTheory.Measure.tendsto_addHaar_inter_smul_zero_of_density_zero_aux2","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\ns : Set E\nx : E\nh : Filter.Tendsto (fun r => HDiv.hDiv (Î¼ (Inter.inter s (Metric.closedBall x r))) (Î¼ (Metric.closedBall x r))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)\nt u : Set E\nh'u : Ne (Î¼ u) 0\nR : Real\nRpos : LT.lt 0 R\nt_bound : HasSubset.Subset t (Metric.closedBall 0 R)\nâŠ¢ Filter.Tendsto (fun r => HDiv.hDiv (Î¼ (Inter.inter s (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r t)))) (Î¼ (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r u)))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)","decl":"theorem tendsto_addHaar_inter_smul_zero_of_density_zero_aux2 (s : Set E) (x : E)\n    (h : Tendsto (fun r => Î¼ (s âˆ© closedBall x r) / Î¼ (closedBall x r)) (ğ“[>] 0) (ğ“ 0)) (t : Set E)\n    (u : Set E) (h'u : Î¼ u â‰  0) (R : â„) (Rpos : 0 < R) (t_bound : t âŠ† closedBall 0 R) :\n    Tendsto (fun r : â„ => Î¼ (s âˆ© ({x} + r â€¢ t)) / Î¼ ({x} + r â€¢ u)) (ğ“[>] 0) (ğ“ 0) := by\n  set t' := Râ»Â¹ â€¢ t with ht'\n  set u' := Râ»Â¹ â€¢ u with hu'\n  have A : Tendsto (fun r : â„ => Î¼ (s âˆ© ({x} + r â€¢ t')) / Î¼ ({x} + r â€¢ u')) (ğ“[>] 0) (ğ“ 0) := by\n    apply tendsto_addHaar_inter_smul_zero_of_density_zero_aux1 Î¼ s x h t' u'\n    Â· simp only [u', h'u, (pow_pos Rpos _).ne', abs_nonpos_iff, addHaar_smul, not_false_iff,\n        ENNReal.ofReal_eq_zero, inv_eq_zero, inv_pow, Ne, or_self_iff, mul_eq_zero]\n    Â· refine (smul_set_mono t_bound).trans_eq ?_\n      rw [smul_closedBall _ _ Rpos.le, smul_zero, Real.norm_of_nonneg (inv_nonneg.2 Rpos.le),\n        inv_mul_cancelâ‚€ Rpos.ne']\n  have B : Tendsto (fun r : â„ => R * r) (ğ“[>] 0) (ğ“[>] (R * 0)) := by\n    apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within\n    Â· exact (tendsto_const_nhds.mul tendsto_id).mono_left nhdsWithin_le_nhds\n    Â· filter_upwards [self_mem_nhdsWithin]\n      intro r rpos\n      rw [mul_zero]\n      exact mul_pos Rpos rpos\n  rw [mul_zero] at B\n  apply (A.comp B).congr' _\n  filter_upwards [self_mem_nhdsWithin]\n  rintro r -\n  have T : (R * r) â€¢ t' = r â€¢ t := by\n    rw [mul_comm, ht', smul_smul, mul_assoc, mul_inv_cancelâ‚€ Rpos.ne', mul_one]\n  have U : (R * r) â€¢ u' = r â€¢ u := by\n    rw [mul_comm, hu', smul_smul, mul_assoc, mul_inv_cancelâ‚€ Rpos.ne', mul_one]\n  dsimp\n  rw [T, U]\n\n"}
{"name":"MeasureTheory.Measure.tendsto_addHaar_inter_smul_zero_of_density_zero","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\ns : Set E\nx : E\nh : Filter.Tendsto (fun r => HDiv.hDiv (Î¼ (Inter.inter s (Metric.closedBall x r))) (Î¼ (Metric.closedBall x r))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)\nt : Set E\nht : MeasurableSet t\nh''t : Ne (Î¼ t) Top.top\nâŠ¢ Filter.Tendsto (fun r => HDiv.hDiv (Î¼ (Inter.inter s (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r t)))) (Î¼ (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r t)))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)","decl":"/-- Consider a point `x` at which a set `s` has density zero, with respect to closed balls. Then it\nalso has density zero with respect to any measurable set `t`: the proportion of points in `s`\nbelonging to a rescaled copy `{x} + r â€¢ t` of `t` tends to zero as `r` tends to zero. -/\ntheorem tendsto_addHaar_inter_smul_zero_of_density_zero (s : Set E) (x : E)\n    (h : Tendsto (fun r => Î¼ (s âˆ© closedBall x r) / Î¼ (closedBall x r)) (ğ“[>] 0) (ğ“ 0)) (t : Set E)\n    (ht : MeasurableSet t) (h''t : Î¼ t â‰  âˆ) :\n    Tendsto (fun r : â„ => Î¼ (s âˆ© ({x} + r â€¢ t)) / Î¼ ({x} + r â€¢ t)) (ğ“[>] 0) (ğ“ 0) := by\n  refine tendsto_order.2 âŸ¨fun a' ha' => (ENNReal.not_lt_zero ha').elim, fun Îµ (Îµpos : 0 < Îµ) => ?_âŸ©\n  rcases eq_or_ne (Î¼ t) 0 with (h't | h't)\n  Â· filter_upwards with r\n    suffices H : Î¼ (s âˆ© ({x} + r â€¢ t)) = 0 by\n      rw [H]; simpa only [ENNReal.zero_div] using Îµpos\n    apply le_antisymm _ (zero_le _)\n    calc\n      Î¼ (s âˆ© ({x} + r â€¢ t)) â‰¤ Î¼ ({x} + r â€¢ t) := measure_mono inter_subset_right\n      _ = 0 := by\n        simp only [h't, addHaar_smul, image_add_left, measure_preimage_add, singleton_add,\n          mul_zero]\n  obtain âŸ¨n, npos, hnâŸ© : âˆƒ n : â„•, 0 < n âˆ§ Î¼ (t \\ closedBall 0 n) < Îµ / 2 * Î¼ t := by\n    have A :\n      Tendsto (fun n : â„• => Î¼ (t \\ closedBall 0 n)) atTop\n        (ğ“ (Î¼ (â‹‚ n : â„•, t \\ closedBall 0 n))) := by\n      have N : âˆƒ n : â„•, Î¼ (t \\ closedBall 0 n) â‰  âˆ :=\n        âŸ¨0, ((measure_mono diff_subset).trans_lt h''t.lt_top).neâŸ©\n      refine tendsto_measure_iInter_atTop\n        (fun n â†¦ (ht.diff measurableSet_closedBall).nullMeasurableSet) (fun m n hmn â†¦ ?_) N\n      exact diff_subset_diff Subset.rfl (closedBall_subset_closedBall (Nat.cast_le.2 hmn))\n    have : â‹‚ n : â„•, t \\ closedBall 0 n = âˆ… := by\n      simp_rw [diff_eq, â† inter_iInter, iInter_eq_compl_iUnion_compl, compl_compl,\n        iUnion_closedBall_nat, compl_univ, inter_empty]\n    simp only [this, measure_empty] at A\n    have I : 0 < Îµ / 2 * Î¼ t := ENNReal.mul_pos (ENNReal.half_pos Îµpos.ne').ne' h't\n    exact (Eventually.and (Ioi_mem_atTop 0) ((tendsto_order.1 A).2 _ I)).exists\n  have L :\n    Tendsto (fun r : â„ => Î¼ (s âˆ© ({x} + r â€¢ (t âˆ© closedBall 0 n))) / Î¼ ({x} + r â€¢ t)) (ğ“[>] 0)\n      (ğ“ 0) :=\n    tendsto_addHaar_inter_smul_zero_of_density_zero_aux2 Î¼ s x h _ t h't n (Nat.cast_pos.2 npos)\n      inter_subset_right\n  filter_upwards [(tendsto_order.1 L).2 _ (ENNReal.half_pos Îµpos.ne'), self_mem_nhdsWithin]\n  rintro r hr (rpos : 0 < r)\n  have I :\n    Î¼ (s âˆ© ({x} + r â€¢ t)) â‰¤\n      Î¼ (s âˆ© ({x} + r â€¢ (t âˆ© closedBall 0 n))) + Î¼ ({x} + r â€¢ (t \\ closedBall 0 n)) :=\n    calc\n      Î¼ (s âˆ© ({x} + r â€¢ t)) =\n          Î¼ (s âˆ© ({x} + r â€¢ (t âˆ© closedBall 0 n)) âˆª s âˆ© ({x} + r â€¢ (t \\ closedBall 0 n))) := by\n        rw [â† inter_union_distrib_left, â† add_union, â† smul_set_union, inter_union_diff]\n      _ â‰¤ Î¼ (s âˆ© ({x} + r â€¢ (t âˆ© closedBall 0 n))) + Î¼ (s âˆ© ({x} + r â€¢ (t \\ closedBall 0 n))) :=\n        measure_union_le _ _\n      _ â‰¤ Î¼ (s âˆ© ({x} + r â€¢ (t âˆ© closedBall 0 n))) + Î¼ ({x} + r â€¢ (t \\ closedBall 0 n)) := by\n        gcongr; apply inter_subset_right\n  calc\n    Î¼ (s âˆ© ({x} + r â€¢ t)) / Î¼ ({x} + r â€¢ t) â‰¤\n        (Î¼ (s âˆ© ({x} + r â€¢ (t âˆ© closedBall 0 n))) + Î¼ ({x} + r â€¢ (t \\ closedBall 0 n))) /\n          Î¼ ({x} + r â€¢ t) := by gcongr\n    _ < Îµ / 2 + Îµ / 2 := by\n      rw [ENNReal.add_div]\n      apply ENNReal.add_lt_add hr _\n      rwa [addHaar_singleton_add_smul_div_singleton_add_smul Î¼ rpos.ne',\n        ENNReal.div_lt_iff (Or.inl h't) (Or.inl h''t)]\n    _ = Îµ := ENNReal.add_halves _\n\n"}
{"name":"MeasureTheory.Measure.tendsto_addHaar_inter_smul_one_of_density_one_aux","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\ns : Set E\nhs : MeasurableSet s\nx : E\nh : Filter.Tendsto (fun r => HDiv.hDiv (Î¼ (Inter.inter s (Metric.closedBall x r))) (Î¼ (Metric.closedBall x r))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 1)\nt : Set E\nht : MeasurableSet t\nh't : Ne (Î¼ t) 0\nh''t : Ne (Î¼ t) Top.top\nâŠ¢ Filter.Tendsto (fun r => HDiv.hDiv (Î¼ (Inter.inter s (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r t)))) (Î¼ (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r t)))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 1)","decl":"theorem tendsto_addHaar_inter_smul_one_of_density_one_aux (s : Set E) (hs : MeasurableSet s)\n    (x : E) (h : Tendsto (fun r => Î¼ (s âˆ© closedBall x r) / Î¼ (closedBall x r)) (ğ“[>] 0) (ğ“ 1))\n    (t : Set E) (ht : MeasurableSet t) (h't : Î¼ t â‰  0) (h''t : Î¼ t â‰  âˆ) :\n    Tendsto (fun r : â„ => Î¼ (s âˆ© ({x} + r â€¢ t)) / Î¼ ({x} + r â€¢ t)) (ğ“[>] 0) (ğ“ 1) := by\n  have I : âˆ€ u v, Î¼ u â‰  0 â†’ Î¼ u â‰  âˆ â†’ MeasurableSet v â†’\n    Î¼ u / Î¼ u - Î¼ (vá¶œ âˆ© u) / Î¼ u = Î¼ (v âˆ© u) / Î¼ u := by\n    intro u v uzero utop vmeas\n    simp_rw [div_eq_mul_inv]\n    rw [â† ENNReal.sub_mul]; swap\n    Â· simp only [uzero, ENNReal.inv_eq_top, imp_true_iff, Ne, not_false_iff]\n    congr 1\n    rw [inter_comm _ u, inter_comm _ u, eq_comm]\n    exact ENNReal.eq_sub_of_add_eq' utop (measure_inter_add_diff u vmeas)\n  have L : Tendsto (fun r => Î¼ (sá¶œ âˆ© closedBall x r) / Î¼ (closedBall x r)) (ğ“[>] 0) (ğ“ 0) := by\n    have A : Tendsto (fun r => Î¼ (closedBall x r) / Î¼ (closedBall x r)) (ğ“[>] 0) (ğ“ 1) := by\n      apply tendsto_const_nhds.congr' _\n      filter_upwards [self_mem_nhdsWithin]\n      intro r hr\n      rw [div_eq_mul_inv, ENNReal.mul_inv_cancel]\n      Â· exact (measure_closedBall_pos Î¼ _ hr).ne'\n      Â· exact measure_closedBall_lt_top.ne\n    have B := ENNReal.Tendsto.sub A h (Or.inl ENNReal.one_ne_top)\n    simp only [tsub_self] at B\n    apply B.congr' _\n    filter_upwards [self_mem_nhdsWithin]\n    rintro r (rpos : 0 < r)\n    convert I (closedBall x r) sá¶œ (measure_closedBall_pos Î¼ _ rpos).ne'\n      measure_closedBall_lt_top.ne hs.compl\n    rw [compl_compl]\n  have L' : Tendsto (fun r : â„ => Î¼ (sá¶œ âˆ© ({x} + r â€¢ t)) / Î¼ ({x} + r â€¢ t)) (ğ“[>] 0) (ğ“ 0) :=\n    tendsto_addHaar_inter_smul_zero_of_density_zero Î¼ sá¶œ x L t ht h''t\n  have L'' : Tendsto (fun r : â„ => Î¼ ({x} + r â€¢ t) / Î¼ ({x} + r â€¢ t)) (ğ“[>] 0) (ğ“ 1) := by\n    apply tendsto_const_nhds.congr' _\n    filter_upwards [self_mem_nhdsWithin]\n    rintro r (rpos : 0 < r)\n    rw [addHaar_singleton_add_smul_div_singleton_add_smul Î¼ rpos.ne', ENNReal.div_self h't h''t]\n  have := ENNReal.Tendsto.sub L'' L' (Or.inl ENNReal.one_ne_top)\n  simp only [tsub_zero] at this\n  apply this.congr' _\n  filter_upwards [self_mem_nhdsWithin]\n  rintro r (rpos : 0 < r)\n  refine I ({x} + r â€¢ t) s ?_ ?_ hs\n  Â· simp only [h't, abs_of_nonneg rpos.le, pow_pos rpos, addHaar_smul, image_add_left,\n      ENNReal.ofReal_eq_zero, not_le, or_false, Ne, measure_preimage_add, abs_pow,\n      singleton_add, mul_eq_zero]\n  Â· simp [h''t, ENNReal.ofReal_ne_top, addHaar_smul, image_add_left, ENNReal.mul_eq_top,\n      Ne, not_false_iff, measure_preimage_add, singleton_add, or_self_iff]\n\n"}
{"name":"MeasureTheory.Measure.tendsto_addHaar_inter_smul_one_of_density_one","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\ns : Set E\nx : E\nh : Filter.Tendsto (fun r => HDiv.hDiv (Î¼ (Inter.inter s (Metric.closedBall x r))) (Î¼ (Metric.closedBall x r))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 1)\nt : Set E\nht : MeasurableSet t\nh't : Ne (Î¼ t) 0\nh''t : Ne (Î¼ t) Top.top\nâŠ¢ Filter.Tendsto (fun r => HDiv.hDiv (Î¼ (Inter.inter s (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r t)))) (Î¼ (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r t)))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 1)","decl":"/-- Consider a point `x` at which a set `s` has density one, with respect to closed balls (i.e.,\na Lebesgue density point of `s`). Then `s` has also density one at `x` with respect to any\nmeasurable set `t`: the proportion of points in `s` belonging to a rescaled copy `{x} + r â€¢ t`\nof `t` tends to one as `r` tends to zero. -/\ntheorem tendsto_addHaar_inter_smul_one_of_density_one (s : Set E) (x : E)\n    (h : Tendsto (fun r => Î¼ (s âˆ© closedBall x r) / Î¼ (closedBall x r)) (ğ“[>] 0) (ğ“ 1)) (t : Set E)\n    (ht : MeasurableSet t) (h't : Î¼ t â‰  0) (h''t : Î¼ t â‰  âˆ) :\n    Tendsto (fun r : â„ => Î¼ (s âˆ© ({x} + r â€¢ t)) / Î¼ ({x} + r â€¢ t)) (ğ“[>] 0) (ğ“ 1) := by\n  have : Tendsto (fun r : â„ => Î¼ (toMeasurable Î¼ s âˆ© ({x} + r â€¢ t)) / Î¼ ({x} + r â€¢ t))\n    (ğ“[>] 0) (ğ“ 1) := by\n    apply\n      tendsto_addHaar_inter_smul_one_of_density_one_aux Î¼ _ (measurableSet_toMeasurable _ _) _ _\n        t ht h't h''t\n    apply tendsto_of_tendsto_of_tendsto_of_le_of_le' h tendsto_const_nhds\n    Â· refine Eventually.of_forall fun r â†¦ ?_\n      gcongr\n      apply subset_toMeasurable\n    Â· filter_upwards [self_mem_nhdsWithin]\n      rintro r -\n      apply ENNReal.div_le_of_le_mul\n      rw [one_mul]\n      exact measure_mono inter_subset_right\n  refine this.congr fun r => ?_\n  congr 1\n  apply measure_toMeasurable_inter_of_sFinite\n  simp only [image_add_left, singleton_add]\n  apply (continuous_add_left (-x)).measurable (ht.const_smulâ‚€ r)\n\n"}
{"name":"MeasureTheory.Measure.eventually_nonempty_inter_smul_of_density_one","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\ns : Set E\nx : E\nh : Filter.Tendsto (fun r => HDiv.hDiv (Î¼ (Inter.inter s (Metric.closedBall x r))) (Î¼ (Metric.closedBall x r))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 1)\nt : Set E\nht : MeasurableSet t\nh't : Ne (Î¼ t) 0\nâŠ¢ Filter.Eventually (fun r => (Inter.inter s (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r t))).Nonempty) (nhdsWithin 0 (Set.Ioi 0))","decl":"/-- Consider a point `x` at which a set `s` has density one, with respect to closed balls (i.e.,\na Lebesgue density point of `s`). Then `s` intersects the rescaled copies `{x} + r â€¢ t` of a given\nset `t` with positive measure, for any small enough `r`. -/\ntheorem eventually_nonempty_inter_smul_of_density_one (s : Set E) (x : E)\n    (h : Tendsto (fun r => Î¼ (s âˆ© closedBall x r) / Î¼ (closedBall x r)) (ğ“[>] 0) (ğ“ 1)) (t : Set E)\n    (ht : MeasurableSet t) (h't : Î¼ t â‰  0) :\n    âˆ€á¶  r in ğ“[>] (0 : â„), (s âˆ© ({x} + r â€¢ t)).Nonempty := by\n  obtain âŸ¨t', t'_meas, t't, t'pos, t'topâŸ© : âˆƒ t', MeasurableSet t' âˆ§ t' âŠ† t âˆ§ 0 < Î¼ t' âˆ§ Î¼ t' < âŠ¤ :=\n    exists_subset_measure_lt_top ht h't.bot_lt\n  filter_upwards [(tendsto_order.1\n          (tendsto_addHaar_inter_smul_one_of_density_one Î¼ s x h t' t'_meas t'pos.ne' t'top.ne)).1\n      0 zero_lt_one]\n  intro r hr\n  have : Î¼ (s âˆ© ({x} + r â€¢ t')) â‰  0 := fun h' => by\n    simp only [ENNReal.not_lt_zero, ENNReal.zero_div, h'] at hr\n  have : (s âˆ© ({x} + r â€¢ t')).Nonempty := nonempty_of_measure_ne_zero this\n  apply this.mono (inter_subset_inter Subset.rfl _)\n  exact add_subset_add Subset.rfl (smul_set_mono t't)\n\n"}
