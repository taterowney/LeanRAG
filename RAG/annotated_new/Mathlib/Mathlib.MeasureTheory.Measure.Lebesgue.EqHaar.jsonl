{"name":"Basis.parallelepiped_basisFun","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\n‚ä¢ Eq (Pi.basisFun Real Œπ).parallelepiped (TopologicalSpace.PositiveCompacts.piIcc01 Œπ)","decl":"/-- The parallelepiped formed from the standard basis for `Œπ ‚Üí ‚Ñù` is `[0,1]^Œπ` -/\ntheorem Basis.parallelepiped_basisFun (Œπ : Type*) [Fintype Œπ] :\n    (Pi.basisFun ‚Ñù Œπ).parallelepiped = TopologicalSpace.PositiveCompacts.piIcc01 Œπ :=\n  SetLike.coe_injective <| by\n    refine Eq.trans ?_ ((uIcc_of_le ?_).trans (Set.pi_univ_Icc _ _).symm)\n    ¬∑ classical convert parallelepiped_single (Œπ := Œπ) 1\n    ¬∑ exact zero_le_one\n\n"}
{"name":"Basis.parallelepiped_eq_map","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"Œπ : Type u_1\nE : Type u_2\ninst‚úù¬≤ : Fintype Œπ\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nb : Basis Œπ Real E\n‚ä¢ Eq b.parallelepiped (TopologicalSpace.PositiveCompacts.map ‚áëb.equivFun.symm ‚ãØ ‚ãØ (TopologicalSpace.PositiveCompacts.piIcc01 Œπ))","decl":"/-- A parallelepiped can be expressed on the standard basis. -/\ntheorem Basis.parallelepiped_eq_map  {Œπ E : Type*} [Fintype Œπ] [NormedAddCommGroup E]\n    [NormedSpace ‚Ñù E] (b : Basis Œπ ‚Ñù E) :\n    b.parallelepiped = (PositiveCompacts.piIcc01 Œπ).map b.equivFun.symm\n      b.equivFunL.symm.continuous b.equivFunL.symm.isOpenMap := by\n  classical\n  rw [‚Üê Basis.parallelepiped_basisFun, ‚Üê Basis.parallelepiped_map]\n  congr with x\n  simp [Pi.single_apply]\n\n"}
{"name":"Basis.map_addHaar","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"Œπ : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬π‚Å∞ : Fintype Œπ\ninst‚úù‚Åπ : NormedAddCommGroup E\ninst‚úù‚Å∏ : NormedAddCommGroup F\ninst‚úù‚Å∑ : NormedSpace Real E\ninst‚úù‚Å∂ : NormedSpace Real F\ninst‚úù‚Åµ : MeasurableSpace E\ninst‚úù‚Å¥ : MeasurableSpace F\ninst‚úù¬≥ : BorelSpace E\ninst‚úù¬≤ : BorelSpace F\ninst‚úù¬π : SecondCountableTopology F\ninst‚úù : SigmaCompactSpace F\nb : Basis Œπ Real E\nf : ContinuousLinearEquiv (RingHom.id Real) E F\n‚ä¢ Eq (MeasureTheory.Measure.map (‚áëf) b.addHaar) (b.map f.toLinearEquiv).addHaar","decl":"theorem Basis.map_addHaar {Œπ E F : Type*} [Fintype Œπ] [NormedAddCommGroup E] [NormedAddCommGroup F]\n    [NormedSpace ‚Ñù E] [NormedSpace ‚Ñù F] [MeasurableSpace E] [MeasurableSpace F] [BorelSpace E]\n    [BorelSpace F] [SecondCountableTopology F] [SigmaCompactSpace F]\n    (b : Basis Œπ ‚Ñù E) (f : E ‚âÉL[‚Ñù] F) :\n    map f b.addHaar = (b.map f.toLinearEquiv).addHaar := by\n  have : IsAddHaarMeasure (map f b.addHaar) :=\n    AddEquiv.isAddHaarMeasure_map b.addHaar f.toAddEquiv f.continuous f.symm.continuous\n  rw [eq_comm, Basis.addHaar_eq_iff, Measure.map_apply f.continuous.measurable\n    (PositiveCompacts.isCompact _).measurableSet, Basis.coe_parallelepiped, Basis.coe_map]\n  erw [‚Üê image_parallelepiped, f.toEquiv.preimage_image, addHaar_self]\n\n"}
{"name":"MeasureTheory.addHaarMeasure_eq_volume","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"‚ä¢ Eq (MeasureTheory.Measure.addHaarMeasure TopologicalSpace.PositiveCompacts.Icc01) MeasureTheory.MeasureSpace.volume","decl":"/-- The Haar measure equals the Lebesgue measure on `‚Ñù`. -/\ntheorem addHaarMeasure_eq_volume : addHaarMeasure Icc01 = volume := by\n  convert (addHaarMeasure_unique volume Icc01).symm; simp [Icc01]\n\n"}
{"name":"MeasureTheory.addHaarMeasure_eq_volume_pi","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\n‚ä¢ Eq (MeasureTheory.Measure.addHaarMeasure (TopologicalSpace.PositiveCompacts.piIcc01 Œπ)) MeasureTheory.MeasureSpace.volume","decl":"/-- The Haar measure equals the Lebesgue measure on `‚Ñù^Œπ`. -/\ntheorem addHaarMeasure_eq_volume_pi (Œπ : Type*) [Fintype Œπ] :\n    addHaarMeasure (piIcc01 Œπ) = volume := by\n  convert (addHaarMeasure_unique volume (piIcc01 Œπ)).symm\n  simp only [piIcc01, volume_pi_pi fun _ => Icc (0 : ‚Ñù) 1, PositiveCompacts.coe_mk,\n    Compacts.coe_mk, Finset.prod_const_one, ENNReal.ofReal_one, Real.volume_Icc, one_smul, sub_zero]\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: remove this instance?\n"}
{"name":"MeasureTheory.isAddHaarMeasure_volume_pi","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\n‚ä¢ MeasureTheory.MeasureSpace.volume.IsAddHaarMeasure","decl":"instance isAddHaarMeasure_volume_pi (Œπ : Type*) [Fintype Œπ] :\n    IsAddHaarMeasure (volume : Measure (Œπ ‚Üí ‚Ñù)) :=\n  inferInstance\n\n"}
{"name":"MeasureTheory.Measure.addHaar_eq_zero_of_disjoint_translates_aux","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\ns : Set E\nu : Nat ‚Üí E\nsb : Bornology.IsBounded s\nhu : Bornology.IsBounded (Set.range u)\nhs : Pairwise (Function.onFun Disjoint fun n => HAdd.hAdd (Singleton.singleton (u n)) s)\nh's : MeasurableSet s\n‚ä¢ Eq (Œº s) 0","decl":"/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem addHaar_eq_zero_of_disjoint_translates_aux {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace ‚Ñù E] [MeasurableSpace E] [BorelSpace E] [FiniteDimensional ‚Ñù E] (Œº : Measure E)\n    [IsAddHaarMeasure Œº] {s : Set E} (u : ‚Ñï ‚Üí E) (sb : IsBounded s) (hu : IsBounded (range u))\n    (hs : Pairwise (Disjoint on fun n => {u n} + s)) (h's : MeasurableSet s) : Œº s = 0 := by\n  by_contra h\n  apply lt_irrefl ‚àû\n  calc\n    ‚àû = ‚àë' _ : ‚Ñï, Œº s := (ENNReal.tsum_const_eq_top_of_ne_zero h).symm\n    _ = ‚àë' n : ‚Ñï, Œº ({u n} + s) := by\n      congr 1; ext1 n; simp only [image_add_left, measure_preimage_add, singleton_add]\n    _ = Œº (‚ãÉ n, {u n} + s) := Eq.symm <| measure_iUnion hs fun n => by\n      simpa only [image_add_left, singleton_add] using measurable_id.const_add _ h's\n    _ = Œº (range u + s) := by rw [‚Üê iUnion_add, iUnion_singleton_eq_range]\n    _ < ‚àû := (hu.add sb).measure_lt_top\n\n"}
{"name":"MeasureTheory.Measure.addHaar_eq_zero_of_disjoint_translates","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\ns : Set E\nu : Nat ‚Üí E\nhu : Bornology.IsBounded (Set.range u)\nhs : Pairwise (Function.onFun Disjoint fun n => HAdd.hAdd (Singleton.singleton (u n)) s)\nh's : MeasurableSet s\n‚ä¢ Eq (Œº s) 0","decl":"/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. -/\ntheorem addHaar_eq_zero_of_disjoint_translates {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace ‚Ñù E] [MeasurableSpace E] [BorelSpace E] [FiniteDimensional ‚Ñù E] (Œº : Measure E)\n    [IsAddHaarMeasure Œº] {s : Set E} (u : ‚Ñï ‚Üí E) (hu : IsBounded (range u))\n    (hs : Pairwise (Disjoint on fun n => {u n} + s)) (h's : MeasurableSet s) : Œº s = 0 := by\n  suffices H : ‚àÄ R, Œº (s ‚à© closedBall 0 R) = 0 by\n    apply le_antisymm _ (zero_le _)\n    calc\n      Œº s ‚â§ ‚àë' n : ‚Ñï, Œº (s ‚à© closedBall 0 n) := by\n        conv_lhs => rw [‚Üê iUnion_inter_closedBall_nat s 0]\n        exact measure_iUnion_le _\n      _ = 0 := by simp only [H, tsum_zero]\n  intro R\n  apply addHaar_eq_zero_of_disjoint_translates_aux Œº u\n    (isBounded_closedBall.subset inter_subset_right) hu _ (h's.inter measurableSet_closedBall)\n  refine pairwise_disjoint_mono hs fun n => ?_\n  exact add_subset_add Subset.rfl inter_subset_left\n\n"}
{"name":"MeasureTheory.Measure.addHaar_submodule","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\ns : Submodule Real E\nhs : Ne s Top.top\n‚ä¢ Eq (Œº ‚Üës) 0","decl":"/-- A strict vector subspace has measure zero. -/\ntheorem addHaar_submodule {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [MeasurableSpace E]\n    [BorelSpace E] [FiniteDimensional ‚Ñù E] (Œº : Measure E) [IsAddHaarMeasure Œº] (s : Submodule ‚Ñù E)\n    (hs : s ‚â† ‚ä§) : Œº s = 0 := by\n  obtain ‚ü®x, hx‚ü© : ‚àÉ x, x ‚àâ s := by\n    simpa only [Submodule.eq_top_iff', not_exists, Ne, not_forall] using hs\n  obtain ‚ü®c, cpos, cone‚ü© : ‚àÉ c : ‚Ñù, 0 < c ‚àß c < 1 := ‚ü®1 / 2, by norm_num, by norm_num‚ü©\n  have A : IsBounded (range fun n : ‚Ñï => c ^ n ‚Ä¢ x) :=\n    have : Tendsto (fun n : ‚Ñï => c ^ n ‚Ä¢ x) atTop (ùìù ((0 : ‚Ñù) ‚Ä¢ x)) :=\n      (tendsto_pow_atTop_nhds_zero_of_lt_one cpos.le cone).smul_const x\n    isBounded_range_of_tendsto _ this\n  apply addHaar_eq_zero_of_disjoint_translates Œº _ A _\n    (Submodule.closed_of_finiteDimensional s).measurableSet\n  intro m n hmn\n  simp only [Function.onFun, image_add_left, singleton_add, disjoint_left, mem_preimage,\n    SetLike.mem_coe]\n  intro y hym hyn\n  have A : (c ^ n - c ^ m) ‚Ä¢ x ‚àà s := by\n    convert s.sub_mem hym hyn using 1\n    simp only [sub_smul, neg_sub_neg, add_sub_add_right_eq_sub]\n  have H : c ^ n - c ^ m ‚â† 0 := by\n    simpa only [sub_eq_zero, Ne] using (pow_right_strictAnti‚ÇÄ cpos cone).injective.ne hmn.symm\n  have : x ‚àà s := by\n    convert s.smul_mem (c ^ n - c ^ m)‚Åª¬π A\n    rw [smul_smul, inv_mul_cancel‚ÇÄ H, one_smul]\n  exact hx this\n\n"}
{"name":"MeasureTheory.Measure.addHaar_affineSubspace","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\ns : AffineSubspace Real E\nhs : Ne s Top.top\n‚ä¢ Eq (Œº ‚Üës) 0","decl":"/-- A strict affine subspace has measure zero. -/\ntheorem addHaar_affineSubspace {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]\n    [MeasurableSpace E] [BorelSpace E] [FiniteDimensional ‚Ñù E] (Œº : Measure E) [IsAddHaarMeasure Œº]\n    (s : AffineSubspace ‚Ñù E) (hs : s ‚â† ‚ä§) : Œº s = 0 := by\n  rcases s.eq_bot_or_nonempty with (rfl | hne)\n  ¬∑ rw [AffineSubspace.bot_coe, measure_empty]\n  rw [Ne, ‚Üê AffineSubspace.direction_eq_top_iff_of_nonempty hne] at hs\n  rcases hne with ‚ü®x, hx : x ‚àà s‚ü©\n  simpa only [AffineSubspace.coe_direction_eq_vsub_set_right hx, vsub_eq_sub, sub_eq_add_neg,\n    image_add_right, neg_neg, measure_preimage_add_right] using addHaar_submodule Œº s.direction hs\n\n"}
{"name":"MeasureTheory.Measure.map_linearMap_addHaar_pi_eq_smul_addHaar","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"Œπ : Type u_1\ninst‚úù¬π : Finite Œπ\nf : LinearMap (RingHom.id Real) (Œπ ‚Üí Real) (Œπ ‚Üí Real)\nhf : Ne (LinearMap.det f) 0\nŒº : MeasureTheory.Measure (Œπ ‚Üí Real)\ninst‚úù : Œº.IsAddHaarMeasure\n‚ä¢ Eq (MeasureTheory.Measure.map (‚áëf) Œº) (HSMul.hSMul (ENNReal.ofReal (abs (Inv.inv (LinearMap.det f)))) Œº)","decl":"theorem map_linearMap_addHaar_pi_eq_smul_addHaar {Œπ : Type*} [Finite Œπ] {f : (Œπ ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] Œπ ‚Üí ‚Ñù}\n    (hf : LinearMap.det f ‚â† 0) (Œº : Measure (Œπ ‚Üí ‚Ñù)) [IsAddHaarMeasure Œº] :\n    Measure.map f Œº = ENNReal.ofReal (abs (LinearMap.det f)‚Åª¬π) ‚Ä¢ Œº := by\n  cases nonempty_fintype Œπ\n  /- We have already proved the result for the Lebesgue product measure, using matrices.\n    We deduce it for any Haar measure by uniqueness (up to scalar multiplication). -/\n  have := addHaarMeasure_unique Œº (piIcc01 Œπ)\n  rw [this, addHaarMeasure_eq_volume_pi, Measure.map_smul,\n    Real.map_linearMap_volume_pi_eq_smul_volume_pi hf, smul_comm]\n\n"}
{"name":"MeasureTheory.Measure.map_linearMap_addHaar_eq_smul_addHaar","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nf : LinearMap (RingHom.id Real) E E\nhf : Ne (LinearMap.det f) 0\n‚ä¢ Eq (MeasureTheory.Measure.map (‚áëf) Œº) (HSMul.hSMul (ENNReal.ofReal (abs (Inv.inv (LinearMap.det f)))) Œº)","decl":"theorem map_linearMap_addHaar_eq_smul_addHaar {f : E ‚Üí‚Çó[‚Ñù] E} (hf : LinearMap.det f ‚â† 0) :\n    Measure.map f Œº = ENNReal.ofReal |(LinearMap.det f)‚Åª¬π| ‚Ä¢ Œº := by\n  -- we reduce to the case of `E = Œπ ‚Üí ‚Ñù`, for which we have already proved the result using\n  -- matrices in `map_linearMap_addHaar_pi_eq_smul_addHaar`.\n  let Œπ := Fin (finrank ‚Ñù E)\n  haveI : FiniteDimensional ‚Ñù (Œπ ‚Üí ‚Ñù) := by infer_instance\n  have : finrank ‚Ñù E = finrank ‚Ñù (Œπ ‚Üí ‚Ñù) := by simp [Œπ]\n  have e : E ‚âÉ‚Çó[‚Ñù] Œπ ‚Üí ‚Ñù := LinearEquiv.ofFinrankEq E (Œπ ‚Üí ‚Ñù) this\n  -- next line is to avoid `g` getting reduced by `simp`.\n  obtain ‚ü®g, hg‚ü© : ‚àÉ g, g = (e : E ‚Üí‚Çó[‚Ñù] Œπ ‚Üí ‚Ñù).comp (f.comp (e.symm : (Œπ ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] E)) := ‚ü®_, rfl‚ü©\n  have gdet : LinearMap.det g = LinearMap.det f := by rw [hg]; exact LinearMap.det_conj f e\n  rw [‚Üê gdet] at hf ‚ä¢\n  have fg : f = (e.symm : (Œπ ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] E).comp (g.comp (e : E ‚Üí‚Çó[‚Ñù] Œπ ‚Üí ‚Ñù)) := by\n    ext x\n    simp only [LinearEquiv.coe_coe, Function.comp_apply, LinearMap.coe_comp,\n      LinearEquiv.symm_apply_apply, hg]\n  simp only [fg, LinearEquiv.coe_coe, LinearMap.coe_comp]\n  have Ce : Continuous e := (e : E ‚Üí‚Çó[‚Ñù] Œπ ‚Üí ‚Ñù).continuous_of_finiteDimensional\n  have Cg : Continuous g := LinearMap.continuous_of_finiteDimensional g\n  have Cesymm : Continuous e.symm := (e.symm : (Œπ ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] E).continuous_of_finiteDimensional\n  rw [‚Üê map_map Cesymm.measurable (Cg.comp Ce).measurable, ‚Üê map_map Cg.measurable Ce.measurable]\n  haveI : IsAddHaarMeasure (map e Œº) := (e : E ‚âÉ+ (Œπ ‚Üí ‚Ñù)).isAddHaarMeasure_map Œº Ce Cesymm\n  have ecomp : e.symm ‚àò e = id := by\n    ext x; simp only [id, Function.comp_apply, LinearEquiv.symm_apply_apply]\n  rw [map_linearMap_addHaar_pi_eq_smul_addHaar hf (map e Œº), Measure.map_smul,\n    map_map Cesymm.measurable Ce.measurable, ecomp, Measure.map_id]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_preimage_linearMap","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nf : LinearMap (RingHom.id Real) E E\nhf : Ne (LinearMap.det f) 0\ns : Set E\n‚ä¢ Eq (Œº (Set.preimage (‚áëf) s)) (HMul.hMul (ENNReal.ofReal (abs (Inv.inv (LinearMap.det f)))) (Œº s))","decl":"/-- The preimage of a set `s` under a linear map `f` with nonzero determinant has measure\nequal to `Œº s` times the absolute value of the inverse of the determinant of `f`. -/\n@[simp]\ntheorem addHaar_preimage_linearMap {f : E ‚Üí‚Çó[‚Ñù] E} (hf : LinearMap.det f ‚â† 0) (s : Set E) :\n    Œº (f ‚Åª¬π' s) = ENNReal.ofReal |(LinearMap.det f)‚Åª¬π| * Œº s :=\n  calc\n    Œº (f ‚Åª¬π' s) = Measure.map f Œº s :=\n      ((f.equivOfDetNeZero hf).toContinuousLinearEquiv.toHomeomorph.toMeasurableEquiv.map_apply\n          s).symm\n    _ = ENNReal.ofReal |(LinearMap.det f)‚Åª¬π| * Œº s := by\n      rw [map_linearMap_addHaar_eq_smul_addHaar Œº hf]; rfl\n\n"}
{"name":"MeasureTheory.Measure.addHaar_preimage_continuousLinearMap","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nf : ContinuousLinearMap (RingHom.id Real) E E\nhf : Ne (LinearMap.det ‚Üëf) 0\ns : Set E\n‚ä¢ Eq (Œº (Set.preimage (‚áëf) s)) (HMul.hMul (ENNReal.ofReal (abs (Inv.inv (LinearMap.det ‚Üëf)))) (Œº s))","decl":"/-- The preimage of a set `s` under a continuous linear map `f` with nonzero determinant has measure\nequal to `Œº s` times the absolute value of the inverse of the determinant of `f`. -/\n@[simp]\ntheorem addHaar_preimage_continuousLinearMap {f : E ‚ÜíL[‚Ñù] E}\n    (hf : LinearMap.det (f : E ‚Üí‚Çó[‚Ñù] E) ‚â† 0) (s : Set E) :\n    Œº (f ‚Åª¬π' s) = ENNReal.ofReal (abs (LinearMap.det (f : E ‚Üí‚Çó[‚Ñù] E))‚Åª¬π) * Œº s :=\n  addHaar_preimage_linearMap Œº hf s\n\n"}
{"name":"MeasureTheory.Measure.addHaar_preimage_linearEquiv","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nf : LinearEquiv (RingHom.id Real) E E\ns : Set E\n‚ä¢ Eq (Œº (Set.preimage (‚áëf) s)) (HMul.hMul (ENNReal.ofReal (abs (LinearMap.det ‚Üëf.symm))) (Œº s))","decl":"/-- The preimage of a set `s` under a linear equiv `f` has measure\nequal to `Œº s` times the absolute value of the inverse of the determinant of `f`. -/\n@[simp]\ntheorem addHaar_preimage_linearEquiv (f : E ‚âÉ‚Çó[‚Ñù] E) (s : Set E) :\n    Œº (f ‚Åª¬π' s) = ENNReal.ofReal |LinearMap.det (f.symm : E ‚Üí‚Çó[‚Ñù] E)| * Œº s := by\n  have A : LinearMap.det (f : E ‚Üí‚Çó[‚Ñù] E) ‚â† 0 := (LinearEquiv.isUnit_det' f).ne_zero\n  convert addHaar_preimage_linearMap Œº A s\n  simp only [LinearEquiv.det_coe_symm]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_preimage_continuousLinearEquiv","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nf : ContinuousLinearEquiv (RingHom.id Real) E E\ns : Set E\n‚ä¢ Eq (Œº (Set.preimage (‚áëf) s)) (HMul.hMul (ENNReal.ofReal (abs (LinearMap.det ‚Üë‚Üëf.symm))) (Œº s))","decl":"/-- The preimage of a set `s` under a continuous linear equiv `f` has measure\nequal to `Œº s` times the absolute value of the inverse of the determinant of `f`. -/\n@[simp]\ntheorem addHaar_preimage_continuousLinearEquiv (f : E ‚âÉL[‚Ñù] E) (s : Set E) :\n    Œº (f ‚Åª¬π' s) = ENNReal.ofReal |LinearMap.det (f.symm : E ‚Üí‚Çó[‚Ñù] E)| * Œº s :=\n  addHaar_preimage_linearEquiv Œº _ s\n\n"}
{"name":"MeasureTheory.Measure.addHaar_image_linearMap","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nf : LinearMap (RingHom.id Real) E E\ns : Set E\n‚ä¢ Eq (Œº (Set.image (‚áëf) s)) (HMul.hMul (ENNReal.ofReal (abs (LinearMap.det f))) (Œº s))","decl":"/-- The image of a set `s` under a linear map `f` has measure\nequal to `Œº s` times the absolute value of the determinant of `f`. -/\n@[simp]\ntheorem addHaar_image_linearMap (f : E ‚Üí‚Çó[‚Ñù] E) (s : Set E) :\n    Œº (f '' s) = ENNReal.ofReal |LinearMap.det f| * Œº s := by\n  rcases ne_or_eq (LinearMap.det f) 0 with (hf | hf)\n  ¬∑ let g := (f.equivOfDetNeZero hf).toContinuousLinearEquiv\n    change Œº (g '' s) = _\n    rw [ContinuousLinearEquiv.image_eq_preimage g s, addHaar_preimage_continuousLinearEquiv]\n    congr\n  ¬∑ simp only [hf, zero_mul, ENNReal.ofReal_zero, abs_zero]\n    have : Œº (LinearMap.range f) = 0 :=\n      addHaar_submodule Œº _ (LinearMap.range_lt_top_of_det_eq_zero hf).ne\n    exact le_antisymm (le_trans (measure_mono (image_subset_range _ _)) this.le) (zero_le _)\n\n"}
{"name":"MeasureTheory.Measure.addHaar_image_continuousLinearMap","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nf : ContinuousLinearMap (RingHom.id Real) E E\ns : Set E\n‚ä¢ Eq (Œº (Set.image (‚áëf) s)) (HMul.hMul (ENNReal.ofReal (abs (LinearMap.det ‚Üëf))) (Œº s))","decl":"/-- The image of a set `s` under a continuous linear map `f` has measure\nequal to `Œº s` times the absolute value of the determinant of `f`. -/\n@[simp]\ntheorem addHaar_image_continuousLinearMap (f : E ‚ÜíL[‚Ñù] E) (s : Set E) :\n    Œº (f '' s) = ENNReal.ofReal |LinearMap.det (f : E ‚Üí‚Çó[‚Ñù] E)| * Œº s :=\n  addHaar_image_linearMap Œº _ s\n\n"}
{"name":"MeasureTheory.Measure.addHaar_image_continuousLinearEquiv","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nf : ContinuousLinearEquiv (RingHom.id Real) E E\ns : Set E\n‚ä¢ Eq (Œº (Set.image (‚áëf) s)) (HMul.hMul (ENNReal.ofReal (abs (LinearMap.det ‚Üë‚Üëf))) (Œº s))","decl":"/-- The image of a set `s` under a continuous linear equiv `f` has measure\nequal to `Œº s` times the absolute value of the determinant of `f`. -/\n@[simp]\ntheorem addHaar_image_continuousLinearEquiv (f : E ‚âÉL[‚Ñù] E) (s : Set E) :\n    Œº (f '' s) = ENNReal.ofReal |LinearMap.det (f : E ‚Üí‚Çó[‚Ñù] E)| * Œº s :=\n  Œº.addHaar_image_linearMap (f : E ‚Üí‚Çó[‚Ñù] E) s\n\n"}
{"name":"MeasureTheory.Measure.LinearMap.quasiMeasurePreserving","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nf : LinearMap (RingHom.id Real) E E\nhf : Ne (LinearMap.det f) 0\n‚ä¢ MeasureTheory.Measure.QuasiMeasurePreserving (‚áëf) Œº Œº","decl":"theorem LinearMap.quasiMeasurePreserving (f : E ‚Üí‚Çó[‚Ñù] E) (hf : LinearMap.det f ‚â† 0) :\n    QuasiMeasurePreserving f Œº Œº := by\n  refine ‚ü®f.continuous_of_finiteDimensional.measurable, ?_‚ü©\n  rw [map_linearMap_addHaar_eq_smul_addHaar Œº hf]\n  exact smul_absolutelyContinuous\n\n"}
{"name":"MeasureTheory.Measure.ContinuousLinearMap.quasiMeasurePreserving","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nf : ContinuousLinearMap (RingHom.id Real) E E\nhf : Ne f.det 0\n‚ä¢ MeasureTheory.Measure.QuasiMeasurePreserving (‚áëf) Œº Œº","decl":"theorem ContinuousLinearMap.quasiMeasurePreserving (f : E ‚ÜíL[‚Ñù] E) (hf : f.det ‚â† 0) :\n    QuasiMeasurePreserving f Œº Œº :=\n  LinearMap.quasiMeasurePreserving Œº (f : E ‚Üí‚Çó[‚Ñù] E) hf\n\n"}
{"name":"MeasureTheory.Measure.map_addHaar_smul","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nr : Real\nhr : Ne r 0\n‚ä¢ Eq (MeasureTheory.Measure.map (fun x => HSMul.hSMul r x) Œº) (HSMul.hSMul (ENNReal.ofReal (abs (Inv.inv (HPow.hPow r (Module.finrank Real E))))) Œº)","decl":"theorem map_addHaar_smul {r : ‚Ñù} (hr : r ‚â† 0) :\n    Measure.map (r ‚Ä¢ ¬∑) Œº = ENNReal.ofReal (abs (r ^ finrank ‚Ñù E)‚Åª¬π) ‚Ä¢ Œº := by\n  let f : E ‚Üí‚Çó[‚Ñù] E := r ‚Ä¢ (1 : E ‚Üí‚Çó[‚Ñù] E)\n  change Measure.map f Œº = _\n  have hf : LinearMap.det f ‚â† 0 := by\n    simp only [f, mul_one, LinearMap.det_smul, Ne, MonoidHom.map_one]\n    intro h\n    exact hr (pow_eq_zero h)\n  simp only [f, map_linearMap_addHaar_eq_smul_addHaar Œº hf, mul_one, LinearMap.det_smul, map_one]\n\n"}
{"name":"MeasureTheory.Measure.quasiMeasurePreserving_smul","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nr : Real\nhr : Ne r 0\n‚ä¢ MeasureTheory.Measure.QuasiMeasurePreserving (fun x => HSMul.hSMul r x) Œº Œº","decl":"theorem quasiMeasurePreserving_smul {r : ‚Ñù} (hr : r ‚â† 0) :\n    QuasiMeasurePreserving (r ‚Ä¢ ¬∑) Œº Œº := by\n  refine ‚ü®measurable_const_smul r, ?_‚ü©\n  rw [map_addHaar_smul Œº hr]\n  exact smul_absolutelyContinuous\n\n"}
{"name":"MeasureTheory.Measure.addHaar_preimage_smul","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nr : Real\nhr : Ne r 0\ns : Set E\n‚ä¢ Eq (Œº (Set.preimage (fun x => HSMul.hSMul r x) s)) (HMul.hMul (ENNReal.ofReal (abs (Inv.inv (HPow.hPow r (Module.finrank Real E))))) (Œº s))","decl":"@[simp]\ntheorem addHaar_preimage_smul {r : ‚Ñù} (hr : r ‚â† 0) (s : Set E) :\n    Œº ((r ‚Ä¢ ¬∑) ‚Åª¬π' s) = ENNReal.ofReal (abs (r ^ finrank ‚Ñù E)‚Åª¬π) * Œº s :=\n  calc\n    Œº ((r ‚Ä¢ ¬∑) ‚Åª¬π' s) = Measure.map (r ‚Ä¢ ¬∑) Œº s :=\n      ((Homeomorph.smul (isUnit_iff_ne_zero.2 hr).unit).toMeasurableEquiv.map_apply s).symm\n    _ = ENNReal.ofReal (abs (r ^ finrank ‚Ñù E)‚Åª¬π) * Œº s := by\n      rw [map_addHaar_smul Œº hr, coe_smul, Pi.smul_apply, smul_eq_mul]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_smul","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nr : Real\ns : Set E\n‚ä¢ Eq (Œº (HSMul.hSMul r s)) (HMul.hMul (ENNReal.ofReal (abs (HPow.hPow r (Module.finrank Real E)))) (Œº s))","decl":"/-- Rescaling a set by a factor `r` multiplies its measure by `abs (r ^ dim)`. -/\n@[simp]\ntheorem addHaar_smul (r : ‚Ñù) (s : Set E) :\n    Œº (r ‚Ä¢ s) = ENNReal.ofReal (abs (r ^ finrank ‚Ñù E)) * Œº s := by\n  rcases ne_or_eq r 0 with (h | rfl)\n  ¬∑ rw [‚Üê preimage_smul_inv‚ÇÄ h, addHaar_preimage_smul Œº (inv_ne_zero h), inv_pow, inv_inv]\n  rcases eq_empty_or_nonempty s with (rfl | hs)\n  ¬∑ simp only [measure_empty, mul_zero, smul_set_empty]\n  rw [zero_smul_set hs, ‚Üê singleton_zero]\n  by_cases h : finrank ‚Ñù E = 0\n  ¬∑ haveI : Subsingleton E := finrank_zero_iff.1 h\n    simp only [h, one_mul, ENNReal.ofReal_one, abs_one, Subsingleton.eq_univ_of_nonempty hs,\n      pow_zero, Subsingleton.eq_univ_of_nonempty (singleton_nonempty (0 : E))]\n  ¬∑ haveI : Nontrivial E := nontrivial_of_finrank_pos (bot_lt_iff_ne_bot.2 h)\n    simp only [h, zero_mul, ENNReal.ofReal_zero, abs_zero, Ne, not_false_iff,\n      zero_pow, measure_singleton]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_smul_of_nonneg","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nr : Real\nhr : LE.le 0 r\ns : Set E\n‚ä¢ Eq (Œº (HSMul.hSMul r s)) (HMul.hMul (ENNReal.ofReal (HPow.hPow r (Module.finrank Real E))) (Œº s))","decl":"theorem addHaar_smul_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) (s : Set E) :\n    Œº (r ‚Ä¢ s) = ENNReal.ofReal (r ^ finrank ‚Ñù E) * Œº s := by\n  rw [addHaar_smul, abs_pow, abs_of_nonneg hr]\n\n"}
{"name":"MeasureTheory.Measure.NullMeasurableSet.const_smul","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\ns : Set E\nhs : MeasureTheory.NullMeasurableSet s Œº\nr : Real\n‚ä¢ MeasureTheory.NullMeasurableSet (HSMul.hSMul r s) Œº","decl":"theorem NullMeasurableSet.const_smul (hs : NullMeasurableSet s Œº) (r : ‚Ñù) :\n    NullMeasurableSet (r ‚Ä¢ s) Œº := by\n  obtain rfl | hs' := s.eq_empty_or_nonempty\n  ¬∑ simp\n  obtain rfl | hr := eq_or_ne r 0\n  ¬∑ simpa [zero_smul_set hs'] using nullMeasurableSet_singleton _\n  obtain ‚ü®t, ht, hst‚ü© := hs\n  refine ‚ü®_, ht.const_smul_of_ne_zero hr, ?_‚ü©\n  rw [‚Üê measure_symmDiff_eq_zero_iff] at hst ‚ä¢\n  rw [‚Üê smul_set_symmDiff‚ÇÄ hr, addHaar_smul Œº, hst, mul_zero]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_image_homothety","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nx : E\nr : Real\ns : Set E\n‚ä¢ Eq (Œº (Set.image (‚áë(AffineMap.homothety x r)) s)) (HMul.hMul (ENNReal.ofReal (abs (HPow.hPow r (Module.finrank Real E)))) (Œº s))","decl":"@[simp]\ntheorem addHaar_image_homothety (x : E) (r : ‚Ñù) (s : Set E) :\n    Œº (AffineMap.homothety x r '' s) = ENNReal.ofReal (abs (r ^ finrank ‚Ñù E)) * Œº s :=\n  calc\n    Œº (AffineMap.homothety x r '' s) = Œº ((fun y => y + x) '' (r ‚Ä¢ (fun y => y + -x) '' s)) := by\n      simp only [‚Üê image_smul, image_image, ‚Üê sub_eq_add_neg]; rfl\n    _ = ENNReal.ofReal (abs (r ^ finrank ‚Ñù E)) * Œº s := by\n      simp only [image_add_right, measure_preimage_add_right, addHaar_smul]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_ball_center","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : MeasurableSpace E\ninst‚úù¬π : BorelSpace E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nx : E\nr : Real\n‚ä¢ Eq (Œº (Metric.ball x r)) (Œº (Metric.ball 0 r))","decl":"theorem addHaar_ball_center {E : Type*} [NormedAddCommGroup E] [MeasurableSpace E] [BorelSpace E]\n    (Œº : Measure E) [IsAddHaarMeasure Œº] (x : E) (r : ‚Ñù) : Œº (ball x r) = Œº (ball (0 : E) r) := by\n  have : ball (0 : E) r = (x + ¬∑) ‚Åª¬π' ball x r := by simp [preimage_add_ball]\n  rw [this, measure_preimage_add]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_closedBall_center","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : MeasurableSpace E\ninst‚úù¬π : BorelSpace E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nx : E\nr : Real\n‚ä¢ Eq (Œº (Metric.closedBall x r)) (Œº (Metric.closedBall 0 r))","decl":"theorem addHaar_closedBall_center {E : Type*} [NormedAddCommGroup E] [MeasurableSpace E]\n    [BorelSpace E] (Œº : Measure E) [IsAddHaarMeasure Œº] (x : E) (r : ‚Ñù) :\n    Œº (closedBall x r) = Œº (closedBall (0 : E) r) := by\n  have : closedBall (0 : E) r = (x + ¬∑) ‚Åª¬π' closedBall x r := by simp [preimage_add_closedBall]\n  rw [this, measure_preimage_add]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_ball_mul_of_pos","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nx : E\nr : Real\nhr : LT.lt 0 r\ns : Real\n‚ä¢ Eq (Œº (Metric.ball x (HMul.hMul r s))) (HMul.hMul (ENNReal.ofReal (HPow.hPow r (Module.finrank Real E))) (Œº (Metric.ball 0 s)))","decl":"theorem addHaar_ball_mul_of_pos (x : E) {r : ‚Ñù} (hr : 0 < r) (s : ‚Ñù) :\n    Œº (ball x (r * s)) = ENNReal.ofReal (r ^ finrank ‚Ñù E) * Œº (ball 0 s) := by\n  have : ball (0 : E) (r * s) = r ‚Ä¢ ball (0 : E) s := by\n    simp only [_root_.smul_ball hr.ne' (0 : E) s, Real.norm_eq_abs, abs_of_nonneg hr.le, smul_zero]\n  simp only [this, addHaar_smul, abs_of_nonneg hr.le, addHaar_ball_center, abs_pow]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_ball_of_pos","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nx : E\nr : Real\nhr : LT.lt 0 r\n‚ä¢ Eq (Œº (Metric.ball x r)) (HMul.hMul (ENNReal.ofReal (HPow.hPow r (Module.finrank Real E))) (Œº (Metric.ball 0 1)))","decl":"theorem addHaar_ball_of_pos (x : E) {r : ‚Ñù} (hr : 0 < r) :\n    Œº (ball x r) = ENNReal.ofReal (r ^ finrank ‚Ñù E) * Œº (ball 0 1) := by\n  rw [‚Üê addHaar_ball_mul_of_pos Œº x hr, mul_one]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_ball_mul","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : MeasurableSpace E\ninst‚úù¬≥ : BorelSpace E\ninst‚úù¬≤ : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù¬π : Œº.IsAddHaarMeasure\ninst‚úù : Nontrivial E\nx : E\nr : Real\nhr : LE.le 0 r\ns : Real\n‚ä¢ Eq (Œº (Metric.ball x (HMul.hMul r s))) (HMul.hMul (ENNReal.ofReal (HPow.hPow r (Module.finrank Real E))) (Œº (Metric.ball 0 s)))","decl":"theorem addHaar_ball_mul [Nontrivial E] (x : E) {r : ‚Ñù} (hr : 0 ‚â§ r) (s : ‚Ñù) :\n    Œº (ball x (r * s)) = ENNReal.ofReal (r ^ finrank ‚Ñù E) * Œº (ball 0 s) := by\n  rcases hr.eq_or_lt with (rfl | h)\n  ¬∑ simp only [zero_pow (finrank_pos (R := ‚Ñù) (M := E)).ne', measure_empty, zero_mul,\n      ENNReal.ofReal_zero, ball_zero]\n  ¬∑ exact addHaar_ball_mul_of_pos Œº x h s\n\n"}
{"name":"MeasureTheory.Measure.addHaar_ball","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : MeasurableSpace E\ninst‚úù¬≥ : BorelSpace E\ninst‚úù¬≤ : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù¬π : Œº.IsAddHaarMeasure\ninst‚úù : Nontrivial E\nx : E\nr : Real\nhr : LE.le 0 r\n‚ä¢ Eq (Œº (Metric.ball x r)) (HMul.hMul (ENNReal.ofReal (HPow.hPow r (Module.finrank Real E))) (Œº (Metric.ball 0 1)))","decl":"theorem addHaar_ball [Nontrivial E] (x : E) {r : ‚Ñù} (hr : 0 ‚â§ r) :\n    Œº (ball x r) = ENNReal.ofReal (r ^ finrank ‚Ñù E) * Œº (ball 0 1) := by\n  rw [‚Üê addHaar_ball_mul Œº x hr, mul_one]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_closedBall_mul_of_pos","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nx : E\nr : Real\nhr : LT.lt 0 r\ns : Real\n‚ä¢ Eq (Œº (Metric.closedBall x (HMul.hMul r s))) (HMul.hMul (ENNReal.ofReal (HPow.hPow r (Module.finrank Real E))) (Œº (Metric.closedBall 0 s)))","decl":"theorem addHaar_closedBall_mul_of_pos (x : E) {r : ‚Ñù} (hr : 0 < r) (s : ‚Ñù) :\n    Œº (closedBall x (r * s)) = ENNReal.ofReal (r ^ finrank ‚Ñù E) * Œº (closedBall 0 s) := by\n  have : closedBall (0 : E) (r * s) = r ‚Ä¢ closedBall (0 : E) s := by\n    simp [smul_closedBall' hr.ne' (0 : E), abs_of_nonneg hr.le]\n  simp only [this, addHaar_smul, abs_of_nonneg hr.le, addHaar_closedBall_center, abs_pow]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_closedBall_mul","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nx : E\nr : Real\nhr : LE.le 0 r\ns : Real\nhs : LE.le 0 s\n‚ä¢ Eq (Œº (Metric.closedBall x (HMul.hMul r s))) (HMul.hMul (ENNReal.ofReal (HPow.hPow r (Module.finrank Real E))) (Œº (Metric.closedBall 0 s)))","decl":"theorem addHaar_closedBall_mul (x : E) {r : ‚Ñù} (hr : 0 ‚â§ r) {s : ‚Ñù} (hs : 0 ‚â§ s) :\n    Œº (closedBall x (r * s)) = ENNReal.ofReal (r ^ finrank ‚Ñù E) * Œº (closedBall 0 s) := by\n  have : closedBall (0 : E) (r * s) = r ‚Ä¢ closedBall (0 : E) s := by\n    simp [smul_closedBall r (0 : E) hs, abs_of_nonneg hr]\n  simp only [this, addHaar_smul, abs_of_nonneg hr, addHaar_closedBall_center, abs_pow]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_closedBall'","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nx : E\nr : Real\nhr : LE.le 0 r\n‚ä¢ Eq (Œº (Metric.closedBall x r)) (HMul.hMul (ENNReal.ofReal (HPow.hPow r (Module.finrank Real E))) (Œº (Metric.closedBall 0 1)))","decl":"/-- The measure of a closed ball can be expressed in terms of the measure of the closed unit ball.\nUse instead `addHaar_closedBall`, which uses the measure of the open unit ball as a standard\nform. -/\ntheorem addHaar_closedBall' (x : E) {r : ‚Ñù} (hr : 0 ‚â§ r) :\n    Œº (closedBall x r) = ENNReal.ofReal (r ^ finrank ‚Ñù E) * Œº (closedBall 0 1) := by\n  rw [‚Üê addHaar_closedBall_mul Œº x hr zero_le_one, mul_one]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_unitClosedBall_eq_addHaar_unitBall","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\n‚ä¢ Eq (Œº (Metric.closedBall 0 1)) (Œº (Metric.ball 0 1))","decl":"theorem addHaar_unitClosedBall_eq_addHaar_unitBall :\n    Œº (closedBall (0 : E) 1) = Œº (ball 0 1) := by\n  apply le_antisymm _ (measure_mono ball_subset_closedBall)\n  have A : Tendsto\n      (fun r : ‚Ñù => ENNReal.ofReal (r ^ finrank ‚Ñù E) * Œº (closedBall (0 : E) 1)) (ùìù[<] 1)\n        (ùìù (ENNReal.ofReal ((1 : ‚Ñù) ^ finrank ‚Ñù E) * Œº (closedBall (0 : E) 1))) := by\n    refine ENNReal.Tendsto.mul ?_ (by simp) tendsto_const_nhds (by simp)\n    exact ENNReal.tendsto_ofReal ((tendsto_id'.2 nhdsWithin_le_nhds).pow _)\n  simp only [one_pow, one_mul, ENNReal.ofReal_one] at A\n  refine le_of_tendsto A ?_\n  filter_upwards [Ioo_mem_nhdsLT zero_lt_one] with r hr\n  rw [‚Üê addHaar_closedBall' Œº (0 : E) hr.1.le]\n  exact measure_mono (closedBall_subset_ball hr.2)\n\n"}
{"name":"MeasureTheory.Measure.addHaar_closed_unit_ball_eq_addHaar_unit_ball","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\n‚ä¢ Eq (Œº (Metric.closedBall 0 1)) (Œº (Metric.ball 0 1))","decl":"@[deprecated (since := \"2024-12-01\")]\nalias addHaar_closed_unit_ball_eq_addHaar_unit_ball := addHaar_unitClosedBall_eq_addHaar_unitBall\n\n"}
{"name":"MeasureTheory.Measure.addHaar_closedBall","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nx : E\nr : Real\nhr : LE.le 0 r\n‚ä¢ Eq (Œº (Metric.closedBall x r)) (HMul.hMul (ENNReal.ofReal (HPow.hPow r (Module.finrank Real E))) (Œº (Metric.ball 0 1)))","decl":"theorem addHaar_closedBall (x : E) {r : ‚Ñù} (hr : 0 ‚â§ r) :\n    Œº (closedBall x r) = ENNReal.ofReal (r ^ finrank ‚Ñù E) * Œº (ball 0 1) := by\n  rw [addHaar_closedBall' Œº x hr, addHaar_unitClosedBall_eq_addHaar_unitBall]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_closedBall_eq_addHaar_ball","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : MeasurableSpace E\ninst‚úù¬≥ : BorelSpace E\ninst‚úù¬≤ : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù¬π : Œº.IsAddHaarMeasure\ninst‚úù : Nontrivial E\nx : E\nr : Real\n‚ä¢ Eq (Œº (Metric.closedBall x r)) (Œº (Metric.ball x r))","decl":"theorem addHaar_closedBall_eq_addHaar_ball [Nontrivial E] (x : E) (r : ‚Ñù) :\n    Œº (closedBall x r) = Œº (ball x r) := by\n  by_cases h : r < 0\n  ¬∑ rw [Metric.closedBall_eq_empty.mpr h, Metric.ball_eq_empty.mpr h.le]\n  push_neg at h\n  rw [addHaar_closedBall Œº x h, addHaar_ball Œº x h]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_sphere_of_ne_zero","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nx : E\nr : Real\nhr : Ne r 0\n‚ä¢ Eq (Œº (Metric.sphere x r)) 0","decl":"theorem addHaar_sphere_of_ne_zero (x : E) {r : ‚Ñù} (hr : r ‚â† 0) : Œº (sphere x r) = 0 := by\n  rcases hr.lt_or_lt with (h | h)\n  ¬∑ simp only [empty_diff, measure_empty, ‚Üê closedBall_diff_ball, closedBall_eq_empty.2 h]\n  ¬∑ rw [‚Üê closedBall_diff_ball,\n      measure_diff ball_subset_closedBall measurableSet_ball.nullMeasurableSet\n        measure_ball_lt_top.ne,\n      addHaar_ball_of_pos Œº _ h, addHaar_closedBall Œº _ h.le, tsub_self]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_sphere","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : MeasurableSpace E\ninst‚úù¬≥ : BorelSpace E\ninst‚úù¬≤ : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù¬π : Œº.IsAddHaarMeasure\ninst‚úù : Nontrivial E\nx : E\nr : Real\n‚ä¢ Eq (Œº (Metric.sphere x r)) 0","decl":"theorem addHaar_sphere [Nontrivial E] (x : E) (r : ‚Ñù) : Œº (sphere x r) = 0 := by\n  rcases eq_or_ne r 0 with (rfl | h)\n  ¬∑ rw [sphere_zero, measure_singleton]\n  ¬∑ exact addHaar_sphere_of_ne_zero Œº x h\n\n"}
{"name":"MeasureTheory.Measure.addHaar_singleton_add_smul_div_singleton_add_smul","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\nr : Real\nhr : Ne r 0\nx y : E\ns t : Set E\n‚ä¢ Eq (HDiv.hDiv (Œº (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r s))) (Œº (HAdd.hAdd (Singleton.singleton y) (HSMul.hSMul r t)))) (HDiv.hDiv (Œº s) (Œº t))","decl":"theorem addHaar_singleton_add_smul_div_singleton_add_smul {r : ‚Ñù} (hr : r ‚â† 0) (x y : E)\n    (s t : Set E) : Œº ({x} + r ‚Ä¢ s) / Œº ({y} + r ‚Ä¢ t) = Œº s / Œº t :=\n  calc\n    Œº ({x} + r ‚Ä¢ s) / Œº ({y} + r ‚Ä¢ t) = ENNReal.ofReal (|r| ^ finrank ‚Ñù E) * Œº s *\n        (ENNReal.ofReal (|r| ^ finrank ‚Ñù E) * Œº t)‚Åª¬π := by\n      simp only [div_eq_mul_inv, addHaar_smul, image_add_left, measure_preimage_add, abs_pow,\n        singleton_add]\n    _ = ENNReal.ofReal (|r| ^ finrank ‚Ñù E) * (ENNReal.ofReal (|r| ^ finrank ‚Ñù E))‚Åª¬π *\n          (Œº s * (Œº t)‚Åª¬π) := by\n      rw [ENNReal.mul_inv]\n      ¬∑ ring\n      ¬∑ simp only [pow_pos (abs_pos.mpr hr), ENNReal.ofReal_eq_zero, not_le, Ne, true_or]\n      ¬∑ simp only [ENNReal.ofReal_ne_top, true_or, Ne, not_false_iff]\n    _ = Œº s / Œº t := by\n      rw [ENNReal.mul_inv_cancel, one_mul, div_eq_mul_inv]\n      ¬∑ simp only [pow_pos (abs_pos.mpr hr), ENNReal.ofReal_eq_zero, not_le, Ne]\n      ¬∑ simp only [ENNReal.ofReal_ne_top, Ne, not_false_iff]\n\n"}
{"name":"MeasureTheory.Measure.isUnifLocDoublingMeasureOfIsAddHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : MeasurableSpace E\nŒº : MeasureTheory.Measure E\n‚ä¢ IsUnifLocDoublingMeasure Œº","decl":"instance (priority := 100) isUnifLocDoublingMeasureOfIsAddHaarMeasure :\n    IsUnifLocDoublingMeasure Œº := by\n  refine ‚ü®‚ü®(2 : ‚Ñù‚â•0) ^ finrank ‚Ñù E, ?_‚ü©‚ü©\n  filter_upwards [self_mem_nhdsWithin] with r hr x\n  rw [addHaar_closedBall_mul Œº x zero_le_two (le_of_lt hr), addHaar_closedBall_center Œº x,\n    ENNReal.ofReal, Real.toNNReal_pow zero_le_two]\n  simp only [Real.toNNReal_ofNat, le_refl]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_parallelepiped","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"Œπ : Type u_2\nG : Type u_3\ninst‚úù‚Åµ : Fintype Œπ\ninst‚úù‚Å¥ : DecidableEq Œπ\ninst‚úù¬≥ : NormedAddCommGroup G\ninst‚úù¬≤ : NormedSpace Real G\ninst‚úù¬π : MeasurableSpace G\ninst‚úù : BorelSpace G\nb : Basis Œπ Real G\nv : Œπ ‚Üí G\n‚ä¢ Eq (b.addHaar (parallelepiped v)) (ENNReal.ofReal (abs (b.det v)))","decl":"theorem addHaar_parallelepiped (b : Basis Œπ ‚Ñù G) (v : Œπ ‚Üí G) :\n    b.addHaar (parallelepiped v) = ENNReal.ofReal |b.det v| := by\n  have : FiniteDimensional ‚Ñù G := FiniteDimensional.of_fintype_basis b\n  have A : parallelepiped v = b.constr ‚Ñï v '' parallelepiped b := by\n    rw [image_parallelepiped]\n    -- Porting note: was `congr 1 with i` but Lean 4 `congr` applies `ext` first\n    refine congr_arg _ <| funext fun i ‚Ü¶ ?_\n    exact (b.constr_basis ‚Ñï v i).symm\n  rw [A, addHaar_image_linearMap, b.addHaar_self, mul_one, ‚Üê LinearMap.det_toMatrix b,\n    ‚Üê Basis.toMatrix_eq_toMatrix_constr, Basis.det_apply]\n\n"}
{"name":"AlternatingMap.measure_def","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"G : Type u_4\ninst‚úù‚Å¥ : NormedAddCommGroup G\ninst‚úù¬≥ : NormedSpace Real G\ninst‚úù¬≤ : MeasurableSpace G\ninst‚úù¬π : BorelSpace G\ninst‚úù : FiniteDimensional Real G\nn : Nat\n_i : Fact (Eq (Module.finrank Real G) n)\nœâ : AlternatingMap Real G Real (Fin n)\n‚ä¢ Eq œâ.measure (HSMul.hSMul (NNNorm.nnnorm (œâ ‚áë(Module.finBasisOfFinrankEq Real G ‚ãØ))) (Module.finBasisOfFinrankEq Real G ‚ãØ).addHaar)","decl":"/-- The Lebesgue measure associated to an alternating map. It gives measure `|œâ v|` to the\nparallelepiped spanned by the vectors `v‚ÇÅ, ..., v‚Çô`. Note that it is not always a Haar measure,\nas it can be zero, but it is always locally finite and translation invariant. -/\nnoncomputable irreducible_def _root_.AlternatingMap.measure (œâ : G [‚ãÄ^Fin n]‚Üí‚Çó[‚Ñù] ‚Ñù) :\n    Measure G :=\n  ‚Äñœâ (finBasisOfFinrankEq ‚Ñù G _i.out)‚Äñ‚Çä ‚Ä¢ (finBasisOfFinrankEq ‚Ñù G _i.out).addHaar\n\n"}
{"name":"AlternatingMap.measure_parallelepiped","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"G : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup G\ninst‚úù¬≥ : NormedSpace Real G\ninst‚úù¬≤ : MeasurableSpace G\ninst‚úù¬π : BorelSpace G\ninst‚úù : FiniteDimensional Real G\nn : Nat\n_i : Fact (Eq (Module.finrank Real G) n)\nœâ : AlternatingMap Real G Real (Fin n)\nv : Fin n ‚Üí G\n‚ä¢ Eq (œâ.measure (parallelepiped v)) (ENNReal.ofReal (abs (œâ v)))","decl":"theorem _root_.AlternatingMap.measure_parallelepiped (œâ : G [‚ãÄ^Fin n]‚Üí‚Çó[‚Ñù] ‚Ñù)\n    (v : Fin n ‚Üí G) : œâ.measure (parallelepiped v) = ENNReal.ofReal |œâ v| := by\n  conv_rhs => rw [œâ.eq_smul_basis_det (finBasisOfFinrankEq ‚Ñù G _i.out)]\n  simp only [addHaar_parallelepiped, AlternatingMap.measure, coe_nnreal_smul_apply,\n    AlternatingMap.smul_apply, Algebra.id.smul_eq_mul, abs_mul, ENNReal.ofReal_mul (abs_nonneg _),\n    ‚Üê Real.enorm_eq_ofReal_abs, enorm]\n\n"}
{"name":"MeasureTheory.Measure.instIsAddLeftInvariantMeasure","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"G : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup G\ninst‚úù¬≥ : NormedSpace Real G\ninst‚úù¬≤ : MeasurableSpace G\ninst‚úù¬π : BorelSpace G\ninst‚úù : FiniteDimensional Real G\nn : Nat\n_i : Fact (Eq (Module.finrank Real G) n)\nœâ : AlternatingMap Real G Real (Fin n)\n‚ä¢ œâ.measure.IsAddLeftInvariant","decl":"instance (œâ : G [‚ãÄ^Fin n]‚Üí‚Çó[‚Ñù] ‚Ñù) : IsAddLeftInvariant œâ.measure := by\n  rw [AlternatingMap.measure]; infer_instance\n\n"}
{"name":"MeasureTheory.Measure.instIsLocallyFiniteMeasureMeasure","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"G : Type u_3\ninst‚úù‚Å¥ : NormedAddCommGroup G\ninst‚úù¬≥ : NormedSpace Real G\ninst‚úù¬≤ : MeasurableSpace G\ninst‚úù¬π : BorelSpace G\ninst‚úù : FiniteDimensional Real G\nn : Nat\n_i : Fact (Eq (Module.finrank Real G) n)\nœâ : AlternatingMap Real G Real (Fin n)\n‚ä¢ MeasureTheory.IsLocallyFiniteMeasure œâ.measure","decl":"instance (œâ : G [‚ãÄ^Fin n]‚Üí‚Çó[‚Ñù] ‚Ñù) : IsLocallyFiniteMeasure œâ.measure := by\n  rw [AlternatingMap.measure]; infer_instance\n\n"}
{"name":"MeasureTheory.Measure.tendsto_addHaar_inter_smul_zero_of_density_zero_aux1","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\ns : Set E\nx : E\nh : Filter.Tendsto (fun r => HDiv.hDiv (Œº (Inter.inter s (Metric.closedBall x r))) (Œº (Metric.closedBall x r))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)\nt u : Set E\nh'u : Ne (Œº u) 0\nt_bound : HasSubset.Subset t (Metric.closedBall 0 1)\n‚ä¢ Filter.Tendsto (fun r => HDiv.hDiv (Œº (Inter.inter s (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r t)))) (Œº (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r u)))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)","decl":"theorem tendsto_addHaar_inter_smul_zero_of_density_zero_aux1 (s : Set E) (x : E)\n    (h : Tendsto (fun r => Œº (s ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 0)) (t : Set E)\n    (u : Set E) (h'u : Œº u ‚â† 0) (t_bound : t ‚äÜ closedBall 0 1) :\n    Tendsto (fun r : ‚Ñù => Œº (s ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ u)) (ùìù[>] 0) (ùìù 0) := by\n  have A : Tendsto (fun r : ‚Ñù => Œº (s ‚à© ({x} + r ‚Ä¢ t)) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 0) := by\n    apply\n      tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds h\n        (Eventually.of_forall fun b => zero_le _)\n    filter_upwards [self_mem_nhdsWithin]\n    rintro r (rpos : 0 < r)\n    rw [‚Üê affinity_unitClosedBall rpos.le, singleton_add, ‚Üê image_vadd]\n    gcongr\n  have B :\n    Tendsto (fun r : ‚Ñù => Œº (closedBall x r) / Œº ({x} + r ‚Ä¢ u)) (ùìù[>] 0)\n      (ùìù (Œº (closedBall x 1) / Œº ({x} + u))) := by\n    apply tendsto_const_nhds.congr' _\n    filter_upwards [self_mem_nhdsWithin]\n    rintro r (rpos : 0 < r)\n    have : closedBall x r = {x} + r ‚Ä¢ closedBall (0 : E) 1 := by\n      simp only [_root_.smul_closedBall, Real.norm_of_nonneg rpos.le, zero_le_one, add_zero,\n        mul_one, singleton_add_closedBall, smul_zero]\n    simp only [this, addHaar_singleton_add_smul_div_singleton_add_smul Œº rpos.ne']\n    simp only [addHaar_closedBall_center, image_add_left, measure_preimage_add, singleton_add]\n  have C : Tendsto (fun r : ‚Ñù =>\n        Œº (s ‚à© ({x} + r ‚Ä¢ t)) / Œº (closedBall x r) * (Œº (closedBall x r) / Œº ({x} + r ‚Ä¢ u)))\n      (ùìù[>] 0) (ùìù (0 * (Œº (closedBall x 1) / Œº ({x} + u)))) := by\n    apply ENNReal.Tendsto.mul A _ B (Or.inr ENNReal.zero_ne_top)\n    simp only [ne_eq, not_true, singleton_add, image_add_left, measure_preimage_add, false_or,\n      ENNReal.div_eq_top, h'u, not_and, and_false]\n    intro aux\n    exact (measure_closedBall_lt_top.ne aux).elim\n    -- Porting note: it used to be enough to pass `measure_closedBall_lt_top.ne` to `simp`\n    -- and avoid the `intro; exact` dance.\n  simp only [zero_mul] at C\n  apply C.congr' _\n  filter_upwards [self_mem_nhdsWithin]\n  rintro r (rpos : 0 < r)\n  calc\n    Œº (s ‚à© ({x} + r ‚Ä¢ t)) / Œº (closedBall x r) * (Œº (closedBall x r) / Œº ({x} + r ‚Ä¢ u)) =\n        Œº (closedBall x r) * (Œº (closedBall x r))‚Åª¬π * (Œº (s ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ u)) :=\n      by simp only [div_eq_mul_inv]; ring\n    _ = Œº (s ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ u) := by\n      rw [ENNReal.mul_inv_cancel (measure_closedBall_pos Œº x rpos).ne'\n          measure_closedBall_lt_top.ne,\n        one_mul]\n\n"}
{"name":"MeasureTheory.Measure.tendsto_addHaar_inter_smul_zero_of_density_zero_aux2","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\ns : Set E\nx : E\nh : Filter.Tendsto (fun r => HDiv.hDiv (Œº (Inter.inter s (Metric.closedBall x r))) (Œº (Metric.closedBall x r))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)\nt u : Set E\nh'u : Ne (Œº u) 0\nR : Real\nRpos : LT.lt 0 R\nt_bound : HasSubset.Subset t (Metric.closedBall 0 R)\n‚ä¢ Filter.Tendsto (fun r => HDiv.hDiv (Œº (Inter.inter s (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r t)))) (Œº (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r u)))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)","decl":"theorem tendsto_addHaar_inter_smul_zero_of_density_zero_aux2 (s : Set E) (x : E)\n    (h : Tendsto (fun r => Œº (s ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 0)) (t : Set E)\n    (u : Set E) (h'u : Œº u ‚â† 0) (R : ‚Ñù) (Rpos : 0 < R) (t_bound : t ‚äÜ closedBall 0 R) :\n    Tendsto (fun r : ‚Ñù => Œº (s ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ u)) (ùìù[>] 0) (ùìù 0) := by\n  set t' := R‚Åª¬π ‚Ä¢ t with ht'\n  set u' := R‚Åª¬π ‚Ä¢ u with hu'\n  have A : Tendsto (fun r : ‚Ñù => Œº (s ‚à© ({x} + r ‚Ä¢ t')) / Œº ({x} + r ‚Ä¢ u')) (ùìù[>] 0) (ùìù 0) := by\n    apply tendsto_addHaar_inter_smul_zero_of_density_zero_aux1 Œº s x h t' u'\n    ¬∑ simp only [u', h'u, (pow_pos Rpos _).ne', abs_nonpos_iff, addHaar_smul, not_false_iff,\n        ENNReal.ofReal_eq_zero, inv_eq_zero, inv_pow, Ne, or_self_iff, mul_eq_zero]\n    ¬∑ refine (smul_set_mono t_bound).trans_eq ?_\n      rw [smul_closedBall _ _ Rpos.le, smul_zero, Real.norm_of_nonneg (inv_nonneg.2 Rpos.le),\n        inv_mul_cancel‚ÇÄ Rpos.ne']\n  have B : Tendsto (fun r : ‚Ñù => R * r) (ùìù[>] 0) (ùìù[>] (R * 0)) := by\n    apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within\n    ¬∑ exact (tendsto_const_nhds.mul tendsto_id).mono_left nhdsWithin_le_nhds\n    ¬∑ filter_upwards [self_mem_nhdsWithin]\n      intro r rpos\n      rw [mul_zero]\n      exact mul_pos Rpos rpos\n  rw [mul_zero] at B\n  apply (A.comp B).congr' _\n  filter_upwards [self_mem_nhdsWithin]\n  rintro r -\n  have T : (R * r) ‚Ä¢ t' = r ‚Ä¢ t := by\n    rw [mul_comm, ht', smul_smul, mul_assoc, mul_inv_cancel‚ÇÄ Rpos.ne', mul_one]\n  have U : (R * r) ‚Ä¢ u' = r ‚Ä¢ u := by\n    rw [mul_comm, hu', smul_smul, mul_assoc, mul_inv_cancel‚ÇÄ Rpos.ne', mul_one]\n  dsimp\n  rw [T, U]\n\n"}
{"name":"MeasureTheory.Measure.tendsto_addHaar_inter_smul_zero_of_density_zero","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\ns : Set E\nx : E\nh : Filter.Tendsto (fun r => HDiv.hDiv (Œº (Inter.inter s (Metric.closedBall x r))) (Œº (Metric.closedBall x r))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)\nt : Set E\nht : MeasurableSet t\nh''t : Ne (Œº t) Top.top\n‚ä¢ Filter.Tendsto (fun r => HDiv.hDiv (Œº (Inter.inter s (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r t)))) (Œº (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r t)))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)","decl":"/-- Consider a point `x` at which a set `s` has density zero, with respect to closed balls. Then it\nalso has density zero with respect to any measurable set `t`: the proportion of points in `s`\nbelonging to a rescaled copy `{x} + r ‚Ä¢ t` of `t` tends to zero as `r` tends to zero. -/\ntheorem tendsto_addHaar_inter_smul_zero_of_density_zero (s : Set E) (x : E)\n    (h : Tendsto (fun r => Œº (s ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 0)) (t : Set E)\n    (ht : MeasurableSet t) (h''t : Œº t ‚â† ‚àû) :\n    Tendsto (fun r : ‚Ñù => Œº (s ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 0) := by\n  refine tendsto_order.2 ‚ü®fun a' ha' => (ENNReal.not_lt_zero ha').elim, fun Œµ (Œµpos : 0 < Œµ) => ?_‚ü©\n  rcases eq_or_ne (Œº t) 0 with (h't | h't)\n  ¬∑ filter_upwards with r\n    suffices H : Œº (s ‚à© ({x} + r ‚Ä¢ t)) = 0 by\n      rw [H]; simpa only [ENNReal.zero_div] using Œµpos\n    apply le_antisymm _ (zero_le _)\n    calc\n      Œº (s ‚à© ({x} + r ‚Ä¢ t)) ‚â§ Œº ({x} + r ‚Ä¢ t) := measure_mono inter_subset_right\n      _ = 0 := by\n        simp only [h't, addHaar_smul, image_add_left, measure_preimage_add, singleton_add,\n          mul_zero]\n  obtain ‚ü®n, npos, hn‚ü© : ‚àÉ n : ‚Ñï, 0 < n ‚àß Œº (t \\ closedBall 0 n) < Œµ / 2 * Œº t := by\n    have A :\n      Tendsto (fun n : ‚Ñï => Œº (t \\ closedBall 0 n)) atTop\n        (ùìù (Œº (‚ãÇ n : ‚Ñï, t \\ closedBall 0 n))) := by\n      have N : ‚àÉ n : ‚Ñï, Œº (t \\ closedBall 0 n) ‚â† ‚àû :=\n        ‚ü®0, ((measure_mono diff_subset).trans_lt h''t.lt_top).ne‚ü©\n      refine tendsto_measure_iInter_atTop\n        (fun n ‚Ü¶ (ht.diff measurableSet_closedBall).nullMeasurableSet) (fun m n hmn ‚Ü¶ ?_) N\n      exact diff_subset_diff Subset.rfl (closedBall_subset_closedBall (Nat.cast_le.2 hmn))\n    have : ‚ãÇ n : ‚Ñï, t \\ closedBall 0 n = ‚àÖ := by\n      simp_rw [diff_eq, ‚Üê inter_iInter, iInter_eq_compl_iUnion_compl, compl_compl,\n        iUnion_closedBall_nat, compl_univ, inter_empty]\n    simp only [this, measure_empty] at A\n    have I : 0 < Œµ / 2 * Œº t := ENNReal.mul_pos (ENNReal.half_pos Œµpos.ne').ne' h't\n    exact (Eventually.and (Ioi_mem_atTop 0) ((tendsto_order.1 A).2 _ I)).exists\n  have L :\n    Tendsto (fun r : ‚Ñù => Œº (s ‚à© ({x} + r ‚Ä¢ (t ‚à© closedBall 0 n))) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0)\n      (ùìù 0) :=\n    tendsto_addHaar_inter_smul_zero_of_density_zero_aux2 Œº s x h _ t h't n (Nat.cast_pos.2 npos)\n      inter_subset_right\n  filter_upwards [(tendsto_order.1 L).2 _ (ENNReal.half_pos Œµpos.ne'), self_mem_nhdsWithin]\n  rintro r hr (rpos : 0 < r)\n  have I :\n    Œº (s ‚à© ({x} + r ‚Ä¢ t)) ‚â§\n      Œº (s ‚à© ({x} + r ‚Ä¢ (t ‚à© closedBall 0 n))) + Œº ({x} + r ‚Ä¢ (t \\ closedBall 0 n)) :=\n    calc\n      Œº (s ‚à© ({x} + r ‚Ä¢ t)) =\n          Œº (s ‚à© ({x} + r ‚Ä¢ (t ‚à© closedBall 0 n)) ‚à™ s ‚à© ({x} + r ‚Ä¢ (t \\ closedBall 0 n))) := by\n        rw [‚Üê inter_union_distrib_left, ‚Üê add_union, ‚Üê smul_set_union, inter_union_diff]\n      _ ‚â§ Œº (s ‚à© ({x} + r ‚Ä¢ (t ‚à© closedBall 0 n))) + Œº (s ‚à© ({x} + r ‚Ä¢ (t \\ closedBall 0 n))) :=\n        measure_union_le _ _\n      _ ‚â§ Œº (s ‚à© ({x} + r ‚Ä¢ (t ‚à© closedBall 0 n))) + Œº ({x} + r ‚Ä¢ (t \\ closedBall 0 n)) := by\n        gcongr; apply inter_subset_right\n  calc\n    Œº (s ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ t) ‚â§\n        (Œº (s ‚à© ({x} + r ‚Ä¢ (t ‚à© closedBall 0 n))) + Œº ({x} + r ‚Ä¢ (t \\ closedBall 0 n))) /\n          Œº ({x} + r ‚Ä¢ t) := by gcongr\n    _ < Œµ / 2 + Œµ / 2 := by\n      rw [ENNReal.add_div]\n      apply ENNReal.add_lt_add hr _\n      rwa [addHaar_singleton_add_smul_div_singleton_add_smul Œº rpos.ne',\n        ENNReal.div_lt_iff (Or.inl h't) (Or.inl h''t)]\n    _ = Œµ := ENNReal.add_halves _\n\n"}
{"name":"MeasureTheory.Measure.tendsto_addHaar_inter_smul_one_of_density_one_aux","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\ns : Set E\nhs : MeasurableSet s\nx : E\nh : Filter.Tendsto (fun r => HDiv.hDiv (Œº (Inter.inter s (Metric.closedBall x r))) (Œº (Metric.closedBall x r))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 1)\nt : Set E\nht : MeasurableSet t\nh't : Ne (Œº t) 0\nh''t : Ne (Œº t) Top.top\n‚ä¢ Filter.Tendsto (fun r => HDiv.hDiv (Œº (Inter.inter s (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r t)))) (Œº (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r t)))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 1)","decl":"theorem tendsto_addHaar_inter_smul_one_of_density_one_aux (s : Set E) (hs : MeasurableSet s)\n    (x : E) (h : Tendsto (fun r => Œº (s ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 1))\n    (t : Set E) (ht : MeasurableSet t) (h't : Œº t ‚â† 0) (h''t : Œº t ‚â† ‚àû) :\n    Tendsto (fun r : ‚Ñù => Œº (s ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 1) := by\n  have I : ‚àÄ u v, Œº u ‚â† 0 ‚Üí Œº u ‚â† ‚àû ‚Üí MeasurableSet v ‚Üí\n    Œº u / Œº u - Œº (v·∂ú ‚à© u) / Œº u = Œº (v ‚à© u) / Œº u := by\n    intro u v uzero utop vmeas\n    simp_rw [div_eq_mul_inv]\n    rw [‚Üê ENNReal.sub_mul]; swap\n    ¬∑ simp only [uzero, ENNReal.inv_eq_top, imp_true_iff, Ne, not_false_iff]\n    congr 1\n    rw [inter_comm _ u, inter_comm _ u, eq_comm]\n    exact ENNReal.eq_sub_of_add_eq' utop (measure_inter_add_diff u vmeas)\n  have L : Tendsto (fun r => Œº (s·∂ú ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 0) := by\n    have A : Tendsto (fun r => Œº (closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 1) := by\n      apply tendsto_const_nhds.congr' _\n      filter_upwards [self_mem_nhdsWithin]\n      intro r hr\n      rw [div_eq_mul_inv, ENNReal.mul_inv_cancel]\n      ¬∑ exact (measure_closedBall_pos Œº _ hr).ne'\n      ¬∑ exact measure_closedBall_lt_top.ne\n    have B := ENNReal.Tendsto.sub A h (Or.inl ENNReal.one_ne_top)\n    simp only [tsub_self] at B\n    apply B.congr' _\n    filter_upwards [self_mem_nhdsWithin]\n    rintro r (rpos : 0 < r)\n    convert I (closedBall x r) s·∂ú (measure_closedBall_pos Œº _ rpos).ne'\n      measure_closedBall_lt_top.ne hs.compl\n    rw [compl_compl]\n  have L' : Tendsto (fun r : ‚Ñù => Œº (s·∂ú ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 0) :=\n    tendsto_addHaar_inter_smul_zero_of_density_zero Œº s·∂ú x L t ht h''t\n  have L'' : Tendsto (fun r : ‚Ñù => Œº ({x} + r ‚Ä¢ t) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 1) := by\n    apply tendsto_const_nhds.congr' _\n    filter_upwards [self_mem_nhdsWithin]\n    rintro r (rpos : 0 < r)\n    rw [addHaar_singleton_add_smul_div_singleton_add_smul Œº rpos.ne', ENNReal.div_self h't h''t]\n  have := ENNReal.Tendsto.sub L'' L' (Or.inl ENNReal.one_ne_top)\n  simp only [tsub_zero] at this\n  apply this.congr' _\n  filter_upwards [self_mem_nhdsWithin]\n  rintro r (rpos : 0 < r)\n  refine I ({x} + r ‚Ä¢ t) s ?_ ?_ hs\n  ¬∑ simp only [h't, abs_of_nonneg rpos.le, pow_pos rpos, addHaar_smul, image_add_left,\n      ENNReal.ofReal_eq_zero, not_le, or_false, Ne, measure_preimage_add, abs_pow,\n      singleton_add, mul_eq_zero]\n  ¬∑ simp [h''t, ENNReal.ofReal_ne_top, addHaar_smul, image_add_left, ENNReal.mul_eq_top,\n      Ne, not_false_iff, measure_preimage_add, singleton_add, or_self_iff]\n\n"}
{"name":"MeasureTheory.Measure.tendsto_addHaar_inter_smul_one_of_density_one","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\ns : Set E\nx : E\nh : Filter.Tendsto (fun r => HDiv.hDiv (Œº (Inter.inter s (Metric.closedBall x r))) (Œº (Metric.closedBall x r))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 1)\nt : Set E\nht : MeasurableSet t\nh't : Ne (Œº t) 0\nh''t : Ne (Œº t) Top.top\n‚ä¢ Filter.Tendsto (fun r => HDiv.hDiv (Œº (Inter.inter s (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r t)))) (Œº (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r t)))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 1)","decl":"/-- Consider a point `x` at which a set `s` has density one, with respect to closed balls (i.e.,\na Lebesgue density point of `s`). Then `s` has also density one at `x` with respect to any\nmeasurable set `t`: the proportion of points in `s` belonging to a rescaled copy `{x} + r ‚Ä¢ t`\nof `t` tends to one as `r` tends to zero. -/\ntheorem tendsto_addHaar_inter_smul_one_of_density_one (s : Set E) (x : E)\n    (h : Tendsto (fun r => Œº (s ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 1)) (t : Set E)\n    (ht : MeasurableSet t) (h't : Œº t ‚â† 0) (h''t : Œº t ‚â† ‚àû) :\n    Tendsto (fun r : ‚Ñù => Œº (s ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 1) := by\n  have : Tendsto (fun r : ‚Ñù => Œº (toMeasurable Œº s ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ t))\n    (ùìù[>] 0) (ùìù 1) := by\n    apply\n      tendsto_addHaar_inter_smul_one_of_density_one_aux Œº _ (measurableSet_toMeasurable _ _) _ _\n        t ht h't h''t\n    apply tendsto_of_tendsto_of_tendsto_of_le_of_le' h tendsto_const_nhds\n    ¬∑ refine Eventually.of_forall fun r ‚Ü¶ ?_\n      gcongr\n      apply subset_toMeasurable\n    ¬∑ filter_upwards [self_mem_nhdsWithin]\n      rintro r -\n      apply ENNReal.div_le_of_le_mul\n      rw [one_mul]\n      exact measure_mono inter_subset_right\n  refine this.congr fun r => ?_\n  congr 1\n  apply measure_toMeasurable_inter_of_sFinite\n  simp only [image_add_left, singleton_add]\n  apply (continuous_add_left (-x)).measurable (ht.const_smul‚ÇÄ r)\n\n"}
{"name":"MeasureTheory.Measure.eventually_nonempty_inter_smul_of_density_one","module":"Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : FiniteDimensional Real E\nŒº : MeasureTheory.Measure E\ninst‚úù : Œº.IsAddHaarMeasure\ns : Set E\nx : E\nh : Filter.Tendsto (fun r => HDiv.hDiv (Œº (Inter.inter s (Metric.closedBall x r))) (Œº (Metric.closedBall x r))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 1)\nt : Set E\nht : MeasurableSet t\nh't : Ne (Œº t) 0\n‚ä¢ Filter.Eventually (fun r => (Inter.inter s (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r t))).Nonempty) (nhdsWithin 0 (Set.Ioi 0))","decl":"/-- Consider a point `x` at which a set `s` has density one, with respect to closed balls (i.e.,\na Lebesgue density point of `s`). Then `s` intersects the rescaled copies `{x} + r ‚Ä¢ t` of a given\nset `t` with positive measure, for any small enough `r`. -/\ntheorem eventually_nonempty_inter_smul_of_density_one (s : Set E) (x : E)\n    (h : Tendsto (fun r => Œº (s ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 1)) (t : Set E)\n    (ht : MeasurableSet t) (h't : Œº t ‚â† 0) :\n    ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), (s ‚à© ({x} + r ‚Ä¢ t)).Nonempty := by\n  obtain ‚ü®t', t'_meas, t't, t'pos, t'top‚ü© : ‚àÉ t', MeasurableSet t' ‚àß t' ‚äÜ t ‚àß 0 < Œº t' ‚àß Œº t' < ‚ä§ :=\n    exists_subset_measure_lt_top ht h't.bot_lt\n  filter_upwards [(tendsto_order.1\n          (tendsto_addHaar_inter_smul_one_of_density_one Œº s x h t' t'_meas t'pos.ne' t'top.ne)).1\n      0 zero_lt_one]\n  intro r hr\n  have : Œº (s ‚à© ({x} + r ‚Ä¢ t')) ‚â† 0 := fun h' => by\n    simp only [ENNReal.not_lt_zero, ENNReal.zero_div, h'] at hr\n  have : (s ‚à© ({x} + r ‚Ä¢ t')).Nonempty := nonempty_of_measure_ne_zero this\n  apply this.mono (inter_subset_inter Subset.rfl _)\n  exact add_subset_add Subset.rfl (smul_set_mono t't)\n\n"}
