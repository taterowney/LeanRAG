{"name":"Pi.single_smul","module":"Mathlib.Algebra.GroupWithZero.Action.Pi","initialProofState":"I : Type u\nf : I → Type v\nα : Type u_1\ninst✝³ : Monoid α\ninst✝² : (i : I) → AddMonoid (f i)\ninst✝¹ : (i : I) → DistribMulAction α (f i)\ninst✝ : DecidableEq I\ni : I\nr : α\nx : f i\n⊢ Eq (Pi.single i (HSMul.hSMul r x)) (HSMul.hSMul r (Pi.single i x))","decl":"theorem single_smul {α} [Monoid α] [∀ i, AddMonoid <| f i] [∀ i, DistribMulAction α <| f i]\n    [DecidableEq I] (i : I) (r : α) (x : f i) : single i (r • x) = r • single i x :=\n  single_op (fun i : I => (r • · : f i → f i)) (fun _ => smul_zero _) _ _\n\n-- Porting note: Lean4 cannot infer the non-dependent function `f := fun _ => β`\n"}
{"name":"Pi.single_smul'","module":"Mathlib.Algebra.GroupWithZero.Action.Pi","initialProofState":"I : Type u\nα : Type u_1\nβ : Type u_2\ninst✝³ : Monoid α\ninst✝² : AddMonoid β\ninst✝¹ : DistribMulAction α β\ninst✝ : DecidableEq I\ni : I\nr : α\nx : β\n⊢ Eq (Pi.single i (HSMul.hSMul r x)) (HSMul.hSMul r (Pi.single i x))","decl":"/-- A version of `Pi.single_smul` for non-dependent functions. It is useful in cases where Lean\nfails to apply `Pi.single_smul`. -/\ntheorem single_smul' {α β} [Monoid α] [AddMonoid β] [DistribMulAction α β] [DecidableEq I] (i : I)\n    (r : α) (x : β) : single (f := fun _ => β) i (r • x) = r • single (f := fun _ => β) i x :=\n  single_smul (f := fun _ => β) i r x\n\n"}
{"name":"Pi.single_smul₀","module":"Mathlib.Algebra.GroupWithZero.Action.Pi","initialProofState":"I : Type u\nf : I → Type v\ng : I → Type u_1\ninst✝³ : (i : I) → MonoidWithZero (f i)\ninst✝² : (i : I) → AddMonoid (g i)\ninst✝¹ : (i : I) → DistribMulAction (f i) (g i)\ninst✝ : DecidableEq I\ni : I\nr : f i\nx : g i\n⊢ Eq (Pi.single i (HSMul.hSMul r x)) (HSMul.hSMul (Pi.single i r) (Pi.single i x))","decl":"theorem single_smul₀ {g : I → Type*} [∀ i, MonoidWithZero (f i)] [∀ i, AddMonoid (g i)]\n    [∀ i, DistribMulAction (f i) (g i)] [DecidableEq I] (i : I) (r : f i) (x : g i) :\n    single i (r • x) = single i r • single i x :=\n  single_op₂ (fun i : I => ((· • ·) : f i → g i → g i)) (fun _ => smul_zero _) _ _ _\n\n"}
