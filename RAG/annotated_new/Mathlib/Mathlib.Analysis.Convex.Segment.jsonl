{"name":"segment_eq_imageâ‚‚","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nx y : E\nâŠ¢ Eq (segment ğ•œ x y) (Set.image (fun p => HAdd.hAdd (HSMul.hSMul p.1 x) (HSMul.hSMul p.2 y)) (setOf fun p => And (LE.le 0 p.1) (And (LE.le 0 p.2) (Eq (HAdd.hAdd p.1 p.2) 1))))","decl":"theorem segment_eq_imageâ‚‚ (x y : E) :\n    [x -[ğ•œ] y] =\n      (fun p : ğ•œ Ã— ğ•œ => p.1 â€¢ x + p.2 â€¢ y) '' { p | 0 â‰¤ p.1 âˆ§ 0 â‰¤ p.2 âˆ§ p.1 + p.2 = 1 } := by\n  simp only [segment, image, Prod.exists, mem_setOf_eq, exists_prop, and_assoc]\n\n"}
{"name":"openSegment_eq_imageâ‚‚","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nx y : E\nâŠ¢ Eq (openSegment ğ•œ x y) (Set.image (fun p => HAdd.hAdd (HSMul.hSMul p.1 x) (HSMul.hSMul p.2 y)) (setOf fun p => And (LT.lt 0 p.1) (And (LT.lt 0 p.2) (Eq (HAdd.hAdd p.1 p.2) 1))))","decl":"theorem openSegment_eq_imageâ‚‚ (x y : E) :\n    openSegment ğ•œ x y =\n      (fun p : ğ•œ Ã— ğ•œ => p.1 â€¢ x + p.2 â€¢ y) '' { p | 0 < p.1 âˆ§ 0 < p.2 âˆ§ p.1 + p.2 = 1 } := by\n  simp only [openSegment, image, Prod.exists, mem_setOf_eq, exists_prop, and_assoc]\n\n"}
{"name":"segment_symm","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nx y : E\nâŠ¢ Eq (segment ğ•œ x y) (segment ğ•œ y x)","decl":"theorem segment_symm (x y : E) : [x -[ğ•œ] y] = [y -[ğ•œ] x] :=\n  Set.ext fun _ =>\n    âŸ¨fun âŸ¨a, b, ha, hb, hab, HâŸ© => âŸ¨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans HâŸ©,\n      fun âŸ¨a, b, ha, hb, hab, HâŸ© =>\n      âŸ¨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans HâŸ©âŸ©\n\n"}
{"name":"openSegment_symm","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nx y : E\nâŠ¢ Eq (openSegment ğ•œ x y) (openSegment ğ•œ y x)","decl":"theorem openSegment_symm (x y : E) : openSegment ğ•œ x y = openSegment ğ•œ y x :=\n  Set.ext fun _ =>\n    âŸ¨fun âŸ¨a, b, ha, hb, hab, HâŸ© => âŸ¨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans HâŸ©,\n      fun âŸ¨a, b, ha, hb, hab, HâŸ© =>\n      âŸ¨b, a, hb, ha, (add_comm _ _).trans hab, (add_comm _ _).trans HâŸ©âŸ©\n\n"}
{"name":"openSegment_subset_segment","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nx y : E\nâŠ¢ HasSubset.Subset (openSegment ğ•œ x y) (segment ğ•œ x y)","decl":"theorem openSegment_subset_segment (x y : E) : openSegment ğ•œ x y âŠ† [x -[ğ•œ] y] :=\n  fun _ âŸ¨a, b, ha, hb, hab, hzâŸ© => âŸ¨a, b, ha.le, hb.le, hab, hzâŸ©\n\n"}
{"name":"segment_subset_iff","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\ns : Set E\nx y : E\nâŠ¢ Iff (HasSubset.Subset (segment ğ•œ x y) s) (âˆ€ (a b : ğ•œ), LE.le 0 a â†’ LE.le 0 b â†’ Eq (HAdd.hAdd a b) 1 â†’ Membership.mem s (HAdd.hAdd (HSMul.hSMul a x) (HSMul.hSMul b y)))","decl":"theorem segment_subset_iff :\n    [x -[ğ•œ] y] âŠ† s â†” âˆ€ a b : ğ•œ, 0 â‰¤ a â†’ 0 â‰¤ b â†’ a + b = 1 â†’ a â€¢ x + b â€¢ y âˆˆ s :=\n  âŸ¨fun H a b ha hb hab => H âŸ¨a, b, ha, hb, hab, rflâŸ©, fun H _ âŸ¨a, b, ha, hb, hab, hzâŸ© =>\n    hz â–¸ H a b ha hb habâŸ©\n\n"}
{"name":"openSegment_subset_iff","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\ns : Set E\nx y : E\nâŠ¢ Iff (HasSubset.Subset (openSegment ğ•œ x y) s) (âˆ€ (a b : ğ•œ), LT.lt 0 a â†’ LT.lt 0 b â†’ Eq (HAdd.hAdd a b) 1 â†’ Membership.mem s (HAdd.hAdd (HSMul.hSMul a x) (HSMul.hSMul b y)))","decl":"theorem openSegment_subset_iff :\n    openSegment ğ•œ x y âŠ† s â†” âˆ€ a b : ğ•œ, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ x + b â€¢ y âˆˆ s :=\n  âŸ¨fun H a b ha hb hab => H âŸ¨a, b, ha, hb, hab, rflâŸ©, fun H _ âŸ¨a, b, ha, hb, hab, hzâŸ© =>\n    hz â–¸ H a b ha hb habâŸ©\n\n"}
{"name":"left_mem_segment","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : MulActionWithZero ğ•œ E\nx y : E\nâŠ¢ Membership.mem (segment ğ•œ x y) x","decl":"theorem left_mem_segment (x y : E) : x âˆˆ [x -[ğ•œ] y] :=\n  âŸ¨1, 0, zero_le_one, le_refl 0, add_zero 1, by rw [zero_smul, one_smul, add_zero]âŸ©\n\n"}
{"name":"right_mem_segment","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : MulActionWithZero ğ•œ E\nx y : E\nâŠ¢ Membership.mem (segment ğ•œ x y) y","decl":"theorem right_mem_segment (x y : E) : y âˆˆ [x -[ğ•œ] y] :=\n  segment_symm ğ•œ y x â–¸ left_mem_segment ğ•œ y x\n\n"}
{"name":"segment_same","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : Module ğ•œ E\nx : E\nâŠ¢ Eq (segment ğ•œ x x) (Singleton.singleton x)","decl":"@[simp]\ntheorem segment_same (x : E) : [x -[ğ•œ] x] = {x} :=\n  Set.ext fun z =>\n    âŸ¨fun âŸ¨a, b, _, _, hab, hzâŸ© => by\n      simpa only [(add_smul _ _ _).symm, mem_singleton_iff, hab, one_smul, eq_comm] using hz,\n      fun h => mem_singleton_iff.1 h â–¸ left_mem_segment ğ•œ z zâŸ©\n\n"}
{"name":"insert_endpoints_openSegment","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : Module ğ•œ E\nx y : E\nâŠ¢ Eq (Insert.insert x (Insert.insert y (openSegment ğ•œ x y))) (segment ğ•œ x y)","decl":"theorem insert_endpoints_openSegment (x y : E) :\n    insert x (insert y (openSegment ğ•œ x y)) = [x -[ğ•œ] y] := by\n  simp only [subset_antisymm_iff, insert_subset_iff, left_mem_segment, right_mem_segment,\n    openSegment_subset_segment, true_and]\n  rintro z âŸ¨a, b, ha, hb, hab, rflâŸ©\n  refine hb.eq_or_gt.imp ?_ fun hb' => ha.eq_or_gt.imp ?_ fun ha' => ?_\n  Â· rintro rfl\n    rw [â† add_zero a, hab, one_smul, zero_smul, add_zero]\n  Â· rintro rfl\n    rw [â† zero_add b, hab, one_smul, zero_smul, zero_add]\n  Â· exact âŸ¨a, b, ha', hb', hab, rflâŸ©\n\n"}
{"name":"mem_openSegment_of_ne_left_right","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : Module ğ•œ E\nx y z : E\nhx : Ne x z\nhy : Ne y z\nhz : Membership.mem (segment ğ•œ x y) z\nâŠ¢ Membership.mem (openSegment ğ•œ x y) z","decl":"theorem mem_openSegment_of_ne_left_right (hx : x â‰  z) (hy : y â‰  z) (hz : z âˆˆ [x -[ğ•œ] y]) :\n    z âˆˆ openSegment ğ•œ x y := by\n  rw [â† insert_endpoints_openSegment] at hz\n  exact (hz.resolve_left hx.symm).resolve_left hy.symm\n\n"}
{"name":"openSegment_subset_iff_segment_subset","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : Module ğ•œ E\ns : Set E\nx y : E\nhx : Membership.mem s x\nhy : Membership.mem s y\nâŠ¢ Iff (HasSubset.Subset (openSegment ğ•œ x y) s) (HasSubset.Subset (segment ğ•œ x y) s)","decl":"theorem openSegment_subset_iff_segment_subset (hx : x âˆˆ s) (hy : y âˆˆ s) :\n    openSegment ğ•œ x y âŠ† s â†” [x -[ğ•œ] y] âŠ† s := by\n  simp only [â† insert_endpoints_openSegment, insert_subset_iff, *, true_and]\n\n"}
{"name":"openSegment_same","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : OrderedRing ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Nontrivial ğ•œ\ninstâœ : DenselyOrdered ğ•œ\nx : E\nâŠ¢ Eq (openSegment ğ•œ x x) (Singleton.singleton x)","decl":"@[simp]\ntheorem openSegment_same (x : E) : openSegment ğ•œ x x = {x} :=\n  Set.ext fun z =>\n    âŸ¨fun âŸ¨a, b, _, _, hab, hzâŸ© => by\n      simpa only [â† add_smul, mem_singleton_iff, hab, one_smul, eq_comm] using hz,\n    fun h : z = x => by\n      obtain âŸ¨a, haâ‚€, haâ‚âŸ© := DenselyOrdered.dense (0 : ğ•œ) 1 zero_lt_one\n      refine âŸ¨a, 1 - a, haâ‚€, sub_pos_of_lt haâ‚, add_sub_cancel _ _, ?_âŸ©\n      rw [â† add_smul, add_sub_cancel, one_smul, h]âŸ©\n\n"}
{"name":"segment_eq_image","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nx y : E\nâŠ¢ Eq (segment ğ•œ x y) (Set.image (fun Î¸ => HAdd.hAdd (HSMul.hSMul (HSub.hSub 1 Î¸) x) (HSMul.hSMul Î¸ y)) (Set.Icc 0 1))","decl":"theorem segment_eq_image (x y : E) :\n    [x -[ğ•œ] y] = (fun Î¸ : ğ•œ => (1 - Î¸) â€¢ x + Î¸ â€¢ y) '' Icc (0 : ğ•œ) 1 :=\n  Set.ext fun _ =>\n    âŸ¨fun âŸ¨a, b, ha, hb, hab, hzâŸ© =>\n      âŸ¨b, âŸ¨hb, hab â–¸ le_add_of_nonneg_left haâŸ©, hab â–¸ hz â–¸ by simp only [add_sub_cancel_right]âŸ©,\n      fun âŸ¨Î¸, âŸ¨hÎ¸â‚€, hÎ¸â‚âŸ©, hzâŸ© => âŸ¨1 - Î¸, Î¸, sub_nonneg.2 hÎ¸â‚, hÎ¸â‚€, sub_add_cancel _ _, hzâŸ©âŸ©\n\n"}
{"name":"openSegment_eq_image","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nx y : E\nâŠ¢ Eq (openSegment ğ•œ x y) (Set.image (fun Î¸ => HAdd.hAdd (HSMul.hSMul (HSub.hSub 1 Î¸) x) (HSMul.hSMul Î¸ y)) (Set.Ioo 0 1))","decl":"theorem openSegment_eq_image (x y : E) :\n    openSegment ğ•œ x y = (fun Î¸ : ğ•œ => (1 - Î¸) â€¢ x + Î¸ â€¢ y) '' Ioo (0 : ğ•œ) 1 :=\n  Set.ext fun _ =>\n    âŸ¨fun âŸ¨a, b, ha, hb, hab, hzâŸ© =>\n      âŸ¨b, âŸ¨hb, hab â–¸ lt_add_of_pos_left _ haâŸ©, hab â–¸ hz â–¸ by simp only [add_sub_cancel_right]âŸ©,\n      fun âŸ¨Î¸, âŸ¨hÎ¸â‚€, hÎ¸â‚âŸ©, hzâŸ© => âŸ¨1 - Î¸, Î¸, sub_pos.2 hÎ¸â‚, hÎ¸â‚€, sub_add_cancel _ _, hzâŸ©âŸ©\n\n"}
{"name":"segment_eq_image'","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nx y : E\nâŠ¢ Eq (segment ğ•œ x y) (Set.image (fun Î¸ => HAdd.hAdd x (HSMul.hSMul Î¸ (HSub.hSub y x))) (Set.Icc 0 1))","decl":"theorem segment_eq_image' (x y : E) :\n    [x -[ğ•œ] y] = (fun Î¸ : ğ•œ => x + Î¸ â€¢ (y - x)) '' Icc (0 : ğ•œ) 1 := by\n  convert segment_eq_image ğ•œ x y using 2\n  simp only [smul_sub, sub_smul, one_smul]\n  abel\n\n"}
{"name":"openSegment_eq_image'","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nx y : E\nâŠ¢ Eq (openSegment ğ•œ x y) (Set.image (fun Î¸ => HAdd.hAdd x (HSMul.hSMul Î¸ (HSub.hSub y x))) (Set.Ioo 0 1))","decl":"theorem openSegment_eq_image' (x y : E) :\n    openSegment ğ•œ x y = (fun Î¸ : ğ•œ => x + Î¸ â€¢ (y - x)) '' Ioo (0 : ğ•œ) 1 := by\n  convert openSegment_eq_image ğ•œ x y using 2\n  simp only [smul_sub, sub_smul, one_smul]\n  abel\n\n"}
{"name":"segment_eq_image_lineMap","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nx y : E\nâŠ¢ Eq (segment ğ•œ x y) (Set.image (â‡‘(AffineMap.lineMap x y)) (Set.Icc 0 1))","decl":"theorem segment_eq_image_lineMap (x y : E) : [x -[ğ•œ] y] =\n    AffineMap.lineMap x y '' Icc (0 : ğ•œ) 1 := by\n  convert segment_eq_image ğ•œ x y using 2\n  exact AffineMap.lineMap_apply_module _ _ _\n\n"}
{"name":"openSegment_eq_image_lineMap","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nx y : E\nâŠ¢ Eq (openSegment ğ•œ x y) (Set.image (â‡‘(AffineMap.lineMap x y)) (Set.Ioo 0 1))","decl":"theorem openSegment_eq_image_lineMap (x y : E) :\n    openSegment ğ•œ x y = AffineMap.lineMap x y '' Ioo (0 : ğ•œ) 1 := by\n  convert openSegment_eq_image ğ•œ x y using 2\n  exact AffineMap.lineMap_apply_module _ _ _\n\n"}
{"name":"image_segment","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : OrderedRing ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : AddCommGroup F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nf : AffineMap ğ•œ E F\na b : E\nâŠ¢ Eq (Set.image (â‡‘f) (segment ğ•œ a b)) (segment ğ•œ (f a) (f b))","decl":"@[simp]\ntheorem image_segment (f : E â†’áµƒ[ğ•œ] F) (a b : E) : f '' [a -[ğ•œ] b] = [f a -[ğ•œ] f b] :=\n  Set.ext fun x => by\n    simp_rw [segment_eq_image_lineMap, mem_image, exists_exists_and_eq_and, AffineMap.apply_lineMap]\n\n"}
{"name":"image_openSegment","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : OrderedRing ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : AddCommGroup F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nf : AffineMap ğ•œ E F\na b : E\nâŠ¢ Eq (Set.image (â‡‘f) (openSegment ğ•œ a b)) (openSegment ğ•œ (f a) (f b))","decl":"@[simp]\ntheorem image_openSegment (f : E â†’áµƒ[ğ•œ] F) (a b : E) :\n    f '' openSegment ğ•œ a b = openSegment ğ•œ (f a) (f b) :=\n  Set.ext fun x => by\n    simp_rw [openSegment_eq_image_lineMap, mem_image, exists_exists_and_eq_and,\n      AffineMap.apply_lineMap]\n\n"}
{"name":"vadd_segment","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nG : Type u_4\ninstâœâµ : OrderedRing ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : AddCommGroup G\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : AddTorsor G E\ninstâœ : VAddCommClass G E E\na : G\nb c : E\nâŠ¢ Eq (HVAdd.hVAdd a (segment ğ•œ b c)) (segment ğ•œ (HVAdd.hVAdd a b) (HVAdd.hVAdd a c))","decl":"@[simp]\ntheorem vadd_segment [AddTorsor G E] [VAddCommClass G E E] (a : G) (b c : E) :\n    a +áµ¥ [b -[ğ•œ] c] = [a +áµ¥ b -[ğ•œ] a +áµ¥ c] :=\n  image_segment ğ•œ âŸ¨_, LinearMap.id, fun _ _ => vadd_comm _ _ _âŸ© b c\n\n"}
{"name":"vadd_openSegment","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nG : Type u_4\ninstâœâµ : OrderedRing ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : AddCommGroup G\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : AddTorsor G E\ninstâœ : VAddCommClass G E E\na : G\nb c : E\nâŠ¢ Eq (HVAdd.hVAdd a (openSegment ğ•œ b c)) (openSegment ğ•œ (HVAdd.hVAdd a b) (HVAdd.hVAdd a c))","decl":"@[simp]\ntheorem vadd_openSegment [AddTorsor G E] [VAddCommClass G E E] (a : G) (b c : E) :\n    a +áµ¥ openSegment ğ•œ b c = openSegment ğ•œ (a +áµ¥ b) (a +áµ¥ c) :=\n  image_openSegment ğ•œ âŸ¨_, LinearMap.id, fun _ _ => vadd_comm _ _ _âŸ© b c\n\n"}
{"name":"mem_segment_translate","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\na x b c : E\nâŠ¢ Iff (Membership.mem (segment ğ•œ (HAdd.hAdd a b) (HAdd.hAdd a c)) (HAdd.hAdd a x)) (Membership.mem (segment ğ•œ b c) x)","decl":"@[simp]\ntheorem mem_segment_translate (a : E) {x b c} : a + x âˆˆ [a + b -[ğ•œ] a + c] â†” x âˆˆ [b -[ğ•œ] c] := by\n  simp_rw [â† vadd_eq_add, â† vadd_segment, vadd_mem_vadd_set_iff]\n\n"}
{"name":"mem_openSegment_translate","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\na x b c : E\nâŠ¢ Iff (Membership.mem (openSegment ğ•œ (HAdd.hAdd a b) (HAdd.hAdd a c)) (HAdd.hAdd a x)) (Membership.mem (openSegment ğ•œ b c) x)","decl":"@[simp]\ntheorem mem_openSegment_translate (a : E) {x b c : E} :\n    a + x âˆˆ openSegment ğ•œ (a + b) (a + c) â†” x âˆˆ openSegment ğ•œ b c := by\n  simp_rw [â† vadd_eq_add, â† vadd_openSegment, vadd_mem_vadd_set_iff]\n\n"}
{"name":"segment_translate_preimage","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\na b c : E\nâŠ¢ Eq (Set.preimage (fun x => HAdd.hAdd a x) (segment ğ•œ (HAdd.hAdd a b) (HAdd.hAdd a c))) (segment ğ•œ b c)","decl":"theorem segment_translate_preimage (a b c : E) :\n    (fun x => a + x) â»Â¹' [a + b -[ğ•œ] a + c] = [b -[ğ•œ] c] :=\n  Set.ext fun _ => mem_segment_translate ğ•œ a\n\n"}
{"name":"openSegment_translate_preimage","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\na b c : E\nâŠ¢ Eq (Set.preimage (fun x => HAdd.hAdd a x) (openSegment ğ•œ (HAdd.hAdd a b) (HAdd.hAdd a c))) (openSegment ğ•œ b c)","decl":"theorem openSegment_translate_preimage (a b c : E) :\n    (fun x => a + x) â»Â¹' openSegment ğ•œ (a + b) (a + c) = openSegment ğ•œ b c :=\n  Set.ext fun _ => mem_openSegment_translate ğ•œ a\n\n"}
{"name":"segment_translate_image","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\na b c : E\nâŠ¢ Eq (Set.image (fun x => HAdd.hAdd a x) (segment ğ•œ b c)) (segment ğ•œ (HAdd.hAdd a b) (HAdd.hAdd a c))","decl":"theorem segment_translate_image (a b c : E) : (fun x => a + x) '' [b -[ğ•œ] c] = [a + b -[ğ•œ] a + c] :=\n  segment_translate_preimage ğ•œ a b c â–¸ image_preimage_eq _ <| add_left_surjective a\n\n"}
{"name":"openSegment_translate_image","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\na b c : E\nâŠ¢ Eq (Set.image (fun x => HAdd.hAdd a x) (openSegment ğ•œ b c)) (openSegment ğ•œ (HAdd.hAdd a b) (HAdd.hAdd a c))","decl":"theorem openSegment_translate_image (a b c : E) :\n    (fun x => a + x) '' openSegment ğ•œ b c = openSegment ğ•œ (a + b) (a + c) :=\n  openSegment_translate_preimage ğ•œ a b c â–¸ image_preimage_eq _ <| add_left_surjective a\n\n"}
{"name":"segment_inter_eq_endpoint_of_linearIndependent_sub","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nc x y : E\nh : LinearIndependent ğ•œ (Matrix.vecCons (HSub.hSub x c) (Matrix.vecCons (HSub.hSub y c) Matrix.vecEmpty))\nâŠ¢ Eq (Inter.inter (segment ğ•œ c x) (segment ğ•œ c y)) (Singleton.singleton c)","decl":"lemma segment_inter_eq_endpoint_of_linearIndependent_sub\n    {c x y : E} (h : LinearIndependent ğ•œ ![x - c, y - c]) :\n    [c -[ğ•œ] x] âˆ© [c -[ğ•œ] y] = {c} := by\n  apply Subset.antisymm; swap\n  Â· simp [singleton_subset_iff, left_mem_segment]\n  intro z âŸ¨hzt, hzsâŸ©\n  rw [segment_eq_image, mem_image] at hzt hzs\n  rcases hzt with âŸ¨p, âŸ¨p0, p1âŸ©, rflâŸ©\n  rcases hzs with âŸ¨q, âŸ¨q0, q1âŸ©, HâŸ©\n  have Hx : x = (x - c) + c := by abel\n  have Hy : y = (y - c) + c := by abel\n  rw [Hx, Hy, smul_add, smul_add] at H\n  have : c + q â€¢ (y - c) = c + p â€¢ (x - c) := by\n    convert H using 1 <;> simp [sub_smul]\n  obtain âŸ¨rfl, rflâŸ© : p = 0 âˆ§ q = 0 := h.eq_zero_of_pair' ((add_right_inj c).1 this).symm\n  simp\n\n"}
{"name":"sameRay_of_mem_segment","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : StrictOrderedCommRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nx y z : E\nh : Membership.mem (segment ğ•œ y z) x\nâŠ¢ SameRay ğ•œ (HSub.hSub x y) (HSub.hSub z x)","decl":"theorem sameRay_of_mem_segment [StrictOrderedCommRing ğ•œ] [AddCommGroup E] [Module ğ•œ E] {x y z : E}\n    (h : x âˆˆ [y -[ğ•œ] z]) : SameRay ğ•œ (x - y) (z - x) := by\n  rw [segment_eq_image'] at h\n  rcases h with âŸ¨Î¸, âŸ¨hÎ¸â‚€, hÎ¸â‚âŸ©, rflâŸ©\n  simpa only [add_sub_cancel_left, â† sub_sub, sub_smul, one_smul] using\n    (SameRay.sameRay_nonneg_smul_left (z - y) hÎ¸â‚€).nonneg_smul_right (sub_nonneg.2 hÎ¸â‚)\n\n"}
{"name":"segment_inter_eq_endpoint_of_linearIndependent_of_ne","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : OrderedCommRing ğ•œ\ninstâœÂ² : NoZeroDivisors ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nx y : E\nh : LinearIndependent ğ•œ (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty))\ns t : ğ•œ\nhs : Ne s t\nc : E\nâŠ¢ Eq (Inter.inter (segment ğ•œ (HAdd.hAdd c x) (HAdd.hAdd c (HSMul.hSMul t y))) (segment ğ•œ (HAdd.hAdd c x) (HAdd.hAdd c (HSMul.hSMul s y)))) (Singleton.singleton (HAdd.hAdd c x))","decl":"lemma segment_inter_eq_endpoint_of_linearIndependent_of_ne [OrderedCommRing ğ•œ] [NoZeroDivisors ğ•œ]\n    [AddCommGroup E] [Module ğ•œ E]\n    {x y : E} (h : LinearIndependent ğ•œ ![x, y]) {s t : ğ•œ} (hs : s â‰  t) (c : E) :\n    [c + x -[ğ•œ] c + t â€¢ y] âˆ© [c + x -[ğ•œ] c + s â€¢ y] = {c + x} := by\n  apply segment_inter_eq_endpoint_of_linearIndependent_sub\n  simp only [add_sub_add_left_eq_sub]\n  suffices H : LinearIndependent ğ•œ ![(-1 : ğ•œ) â€¢ x + t â€¢ y, (-1 : ğ•œ) â€¢ x + s â€¢ y] by\n    convert H using 1; simp only [neg_smul, one_smul]; abel_nf\n  apply h.linear_combination_pair_of_det_ne_zero\n  contrapose! hs\n  apply Eq.symm\n  simpa [neg_mul, one_mul, mul_neg, mul_one, sub_neg_eq_add, add_comm _ t,\n    â† sub_eq_add_neg, sub_eq_zero] using hs\n\n"}
{"name":"midpoint_mem_segment","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : LinearOrderedRing ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Invertible 2\nx y : E\nâŠ¢ Membership.mem (segment ğ•œ x y) (midpoint ğ•œ x y)","decl":"theorem midpoint_mem_segment [Invertible (2 : ğ•œ)] (x y : E) : midpoint ğ•œ x y âˆˆ [x -[ğ•œ] y] := by\n  rw [segment_eq_image_lineMap]\n  exact âŸ¨â…Ÿ 2, âŸ¨invOf_nonneg.mpr zero_le_two, invOf_le_one one_le_twoâŸ©, rflâŸ©\n\n"}
{"name":"mem_segment_sub_add","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : LinearOrderedRing ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Invertible 2\nx y : E\nâŠ¢ Membership.mem (segment ğ•œ (HSub.hSub x y) (HAdd.hAdd x y)) x","decl":"theorem mem_segment_sub_add [Invertible (2 : ğ•œ)] (x y : E) : x âˆˆ [x - y -[ğ•œ] x + y] := by\n  convert @midpoint_mem_segment ğ•œ _ _ _ _ _ (x - y) (x + y)\n  rw [midpoint_sub_add]\n\n"}
{"name":"mem_segment_add_sub","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : LinearOrderedRing ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Invertible 2\nx y : E\nâŠ¢ Membership.mem (segment ğ•œ (HAdd.hAdd x y) (HSub.hSub x y)) x","decl":"theorem mem_segment_add_sub [Invertible (2 : ğ•œ)] (x y : E) : x âˆˆ [x + y -[ğ•œ] x - y] := by\n  convert @midpoint_mem_segment ğ•œ _ _ _ _ _ (x + y) (x - y)\n  rw [midpoint_add_sub]\n\n"}
{"name":"left_mem_openSegment_iff","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : LinearOrderedRing ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\nx y : E\ninstâœÂ¹ : DenselyOrdered ğ•œ\ninstâœ : NoZeroSMulDivisors ğ•œ E\nâŠ¢ Iff (Membership.mem (openSegment ğ•œ x y) x) (Eq x y)","decl":"@[simp]\ntheorem left_mem_openSegment_iff [DenselyOrdered ğ•œ] [NoZeroSMulDivisors ğ•œ E] :\n    x âˆˆ openSegment ğ•œ x y â†” x = y := by\n  constructor\n  Â· rintro âŸ¨a, b, _, hb, hab, hxâŸ©\n    refine smul_right_injective _ hb.ne' ((add_right_inj (a â€¢ x)).1 ?_)\n    rw [hx, â† add_smul, hab, one_smul]\n  Â· rintro rfl\n    rw [openSegment_same]\n    exact mem_singleton _\n\n"}
{"name":"right_mem_openSegment_iff","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : LinearOrderedRing ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\nx y : E\ninstâœÂ¹ : DenselyOrdered ğ•œ\ninstâœ : NoZeroSMulDivisors ğ•œ E\nâŠ¢ Iff (Membership.mem (openSegment ğ•œ x y) y) (Eq x y)","decl":"@[simp]\ntheorem right_mem_openSegment_iff [DenselyOrdered ğ•œ] [NoZeroSMulDivisors ğ•œ E] :\n    y âˆˆ openSegment ğ•œ x y â†” x = y := by rw [openSegment_symm, left_mem_openSegment_iff, eq_comm]\n\n"}
{"name":"mem_segment_iff_div","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : LinearOrderedSemifield ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nx y z : E\nâŠ¢ Iff (Membership.mem (segment ğ•œ y z) x) (Exists fun a => Exists fun b => And (LE.le 0 a) (And (LE.le 0 b) (And (LT.lt 0 (HAdd.hAdd a b)) (Eq (HAdd.hAdd (HSMul.hSMul (HDiv.hDiv a (HAdd.hAdd a b)) y) (HSMul.hSMul (HDiv.hDiv b (HAdd.hAdd a b)) z)) x))))","decl":"theorem mem_segment_iff_div :\n    x âˆˆ [y -[ğ•œ] z] â†”\n      âˆƒ a b : ğ•œ, 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ§ 0 < a + b âˆ§ (a / (a + b)) â€¢ y + (b / (a + b)) â€¢ z = x := by\n  constructor\n  Â· rintro âŸ¨a, b, ha, hb, hab, rflâŸ©\n    use a, b, ha, hb\n    simp [*]\n  Â· rintro âŸ¨a, b, ha, hb, hab, rflâŸ©\n    refine âŸ¨a / (a + b), b / (a + b), by positivity, by positivity, ?_, rflâŸ©\n    rw [â† add_div, div_self hab.ne']\n\n"}
{"name":"mem_openSegment_iff_div","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : LinearOrderedSemifield ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nx y z : E\nâŠ¢ Iff (Membership.mem (openSegment ğ•œ y z) x) (Exists fun a => Exists fun b => And (LT.lt 0 a) (And (LT.lt 0 b) (Eq (HAdd.hAdd (HSMul.hSMul (HDiv.hDiv a (HAdd.hAdd a b)) y) (HSMul.hSMul (HDiv.hDiv b (HAdd.hAdd a b)) z)) x)))","decl":"theorem mem_openSegment_iff_div : x âˆˆ openSegment ğ•œ y z â†”\n    âˆƒ a b : ğ•œ, 0 < a âˆ§ 0 < b âˆ§ (a / (a + b)) â€¢ y + (b / (a + b)) â€¢ z = x := by\n  constructor\n  Â· rintro âŸ¨a, b, ha, hb, hab, rflâŸ©\n    use a, b, ha, hb\n    rw [hab, div_one, div_one]\n  Â· rintro âŸ¨a, b, ha, hb, rflâŸ©\n    have hab : 0 < a + b := add_pos' ha hb\n    refine âŸ¨a / (a + b), b / (a + b), by positivity, by positivity, ?_, rflâŸ©\n    rw [â† add_div, div_self hab.ne']\n\n"}
{"name":"mem_segment_iff_sameRay","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nx y z : E\nâŠ¢ Iff (Membership.mem (segment ğ•œ y z) x) (SameRay ğ•œ (HSub.hSub x y) (HSub.hSub z x))","decl":"theorem mem_segment_iff_sameRay : x âˆˆ [y -[ğ•œ] z] â†” SameRay ğ•œ (x - y) (z - x) := by\n  refine âŸ¨sameRay_of_mem_segment, fun h => ?_âŸ©\n  rcases h.exists_eq_smul_add with âŸ¨a, b, ha, hb, hab, hxy, hzxâŸ©\n  rw [add_comm, sub_add_sub_cancel] at hxy hzx\n  rw [â† mem_segment_translate _ (-x), neg_add_cancel]\n  refine âŸ¨b, a, hb, ha, add_comm a b â–¸ hab, ?_âŸ©\n  rw [â† sub_eq_neg_add, â† neg_sub, hxy, â† sub_eq_neg_add, hzx, smul_neg, smul_comm, neg_add_cancel]\n\n"}
{"name":"openSegment_subset_union","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nx y z : E\nhz : Membership.mem (Set.range â‡‘(AffineMap.lineMap x y)) z\nâŠ¢ HasSubset.Subset (openSegment ğ•œ x y) (Insert.insert z (Union.union (openSegment ğ•œ x z) (openSegment ğ•œ z y)))","decl":"/-- If `z = lineMap x y c` is a point on the line passing through `x` and `y`, then the open\nsegment `openSegment ğ•œ x y` is included in the union of the open segments `openSegment ğ•œ x z`,\n`openSegment ğ•œ z y`, and the point `z`. Informally, `(x, y) âŠ† {z} âˆª (x, z) âˆª (z, y)`. -/\ntheorem openSegment_subset_union (x y : E) {z : E} (hz : z âˆˆ range (lineMap x y : ğ•œ â†’ E)) :\n    openSegment ğ•œ x y âŠ† insert z (openSegment ğ•œ x z âˆª openSegment ğ•œ z y) := by\n  rcases hz with âŸ¨c, rflâŸ©\n  simp only [openSegment_eq_image_lineMap, â† mapsTo']\n  rintro a âŸ¨hâ‚€, hâ‚âŸ©\n  rcases lt_trichotomy a c with (hac | rfl | hca)\n  Â· right\n    left\n    have hc : 0 < c := hâ‚€.trans hac\n    refine âŸ¨a / c, âŸ¨div_pos hâ‚€ hc, (div_lt_one hc).2 hacâŸ©, ?_âŸ©\n    simp only [â† homothety_eq_lineMap, â† homothety_mul_apply, div_mul_cancelâ‚€ _ hc.ne']\n  Â· left\n    rfl\n  Â· right\n    right\n    have hc : 0 < 1 - c := sub_pos.2 (hca.trans hâ‚)\n    simp only [â† lineMap_apply_one_sub y]\n    refine\n      âŸ¨(a - c) / (1 - c), âŸ¨div_pos (sub_pos.2 hca) hc, (div_lt_one hc).2 <| sub_lt_sub_right hâ‚ _âŸ©,\n        ?_âŸ©\n    simp only [â† homothety_eq_lineMap, â† homothety_mul_apply, sub_mul, one_mul,\n      div_mul_cancelâ‚€ _ hc.ne', sub_sub_sub_cancel_right]\n\n"}
{"name":"segment_subset_Icc","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : OrderedSemiring ğ•œ\ninstâœÂ² : OrderedAddCommMonoid E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : OrderedSMul ğ•œ E\nx y : E\nh : LE.le x y\nâŠ¢ HasSubset.Subset (segment ğ•œ x y) (Set.Icc x y)","decl":"theorem segment_subset_Icc (h : x â‰¤ y) : [x -[ğ•œ] y] âŠ† Icc x y := by\n  rintro z âŸ¨a, b, ha, hb, hab, rflâŸ©\n  constructor\n  Â· calc\n      x = a â€¢ x + b â€¢ x := (Convex.combo_self hab _).symm\n      _ â‰¤ a â€¢ x + b â€¢ y := by gcongr\n  Â· calc\n      a â€¢ x + b â€¢ y â‰¤ a â€¢ y + b â€¢ y := by gcongr\n      _ = y := Convex.combo_self hab _\n\n"}
{"name":"openSegment_subset_Ioo","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : OrderedSemiring ğ•œ\ninstâœÂ² : OrderedCancelAddCommMonoid E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : OrderedSMul ğ•œ E\nx y : E\nh : LT.lt x y\nâŠ¢ HasSubset.Subset (openSegment ğ•œ x y) (Set.Ioo x y)","decl":"theorem openSegment_subset_Ioo (h : x < y) : openSegment ğ•œ x y âŠ† Ioo x y := by\n  rintro z âŸ¨a, b, ha, hb, hab, rflâŸ©\n  constructor\n  Â· calc\n      x = a â€¢ x + b â€¢ x := (Convex.combo_self hab _).symm\n      _ < a â€¢ x + b â€¢ y := by gcongr\n  Â· calc\n      a â€¢ x + b â€¢ y < a â€¢ y + b â€¢ y := by gcongr\n      _ = y := Convex.combo_self hab _\n\n"}
{"name":"segment_subset_uIcc","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : OrderedSemiring ğ•œ\ninstâœÂ² : LinearOrderedAddCommMonoid E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : OrderedSMul ğ•œ E\nx y : E\nâŠ¢ HasSubset.Subset (segment ğ•œ x y) (Set.uIcc x y)","decl":"theorem segment_subset_uIcc (x y : E) : [x -[ğ•œ] y] âŠ† uIcc x y := by\n  rcases le_total x y with h | h\n  Â· rw [uIcc_of_le h]\n    exact segment_subset_Icc h\n  Â· rw [uIcc_of_ge h, segment_symm]\n    exact segment_subset_Icc h\n\n"}
{"name":"Convex.min_le_combo","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : OrderedSemiring ğ•œ\ninstâœÂ² : LinearOrderedAddCommMonoid E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : OrderedSMul ğ•œ E\na b : ğ•œ\nx y : E\nha : LE.le 0 a\nhb : LE.le 0 b\nhab : Eq (HAdd.hAdd a b) 1\nâŠ¢ LE.le (Min.min x y) (HAdd.hAdd (HSMul.hSMul a x) (HSMul.hSMul b y))","decl":"theorem Convex.min_le_combo (x y : E) (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (hab : a + b = 1) :\n    min x y â‰¤ a â€¢ x + b â€¢ y :=\n  (segment_subset_uIcc x y âŸ¨_, _, ha, hb, hab, rflâŸ©).1\n\n"}
{"name":"Convex.combo_le_max","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : OrderedSemiring ğ•œ\ninstâœÂ² : LinearOrderedAddCommMonoid E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : OrderedSMul ğ•œ E\na b : ğ•œ\nx y : E\nha : LE.le 0 a\nhb : LE.le 0 b\nhab : Eq (HAdd.hAdd a b) 1\nâŠ¢ LE.le (HAdd.hAdd (HSMul.hSMul a x) (HSMul.hSMul b y)) (Max.max x y)","decl":"theorem Convex.combo_le_max (x y : E) (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (hab : a + b = 1) :\n    a â€¢ x + b â€¢ y â‰¤ max x y :=\n  (segment_subset_uIcc x y âŸ¨_, _, ha, hb, hab, rflâŸ©).2\n\n"}
{"name":"Icc_subset_segment","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\nx y : ğ•œ\nâŠ¢ HasSubset.Subset (Set.Icc x y) (segment ğ•œ x y)","decl":"theorem Icc_subset_segment : Icc x y âŠ† [x -[ğ•œ] y] := by\n  rintro z âŸ¨hxz, hyzâŸ©\n  obtain rfl | h := (hxz.trans hyz).eq_or_lt\n  Â· rw [segment_same]\n    exact hyz.antisymm hxz\n  rw [â† sub_nonneg] at hxz hyz\n  rw [â† sub_pos] at h\n  refine âŸ¨(y - z) / (y - x), (z - x) / (y - x), div_nonneg hyz h.le, div_nonneg hxz h.le, ?_, ?_âŸ©\n  Â· rw [â† add_div, sub_add_sub_cancel, div_self h.ne']\n  Â· rw [smul_eq_mul, smul_eq_mul, â† mul_div_right_comm, â† mul_div_right_comm, â† add_div,\n      div_eq_iff h.ne', add_comm, sub_mul, sub_mul, mul_comm x, sub_add_sub_cancel, mul_sub]\n\n"}
{"name":"segment_eq_Icc","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\nx y : ğ•œ\nh : LE.le x y\nâŠ¢ Eq (segment ğ•œ x y) (Set.Icc x y)","decl":"@[simp]\ntheorem segment_eq_Icc (h : x â‰¤ y) : [x -[ğ•œ] y] = Icc x y :=\n  (segment_subset_Icc h).antisymm Icc_subset_segment\n\n"}
{"name":"Ioo_subset_openSegment","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\nx y : ğ•œ\nâŠ¢ HasSubset.Subset (Set.Ioo x y) (openSegment ğ•œ x y)","decl":"theorem Ioo_subset_openSegment : Ioo x y âŠ† openSegment ğ•œ x y := fun _ hz =>\n  mem_openSegment_of_ne_left_right hz.1.ne hz.2.ne' <| Icc_subset_segment <| Ioo_subset_Icc_self hz\n\n"}
{"name":"openSegment_eq_Ioo","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\nx y : ğ•œ\nh : LT.lt x y\nâŠ¢ Eq (openSegment ğ•œ x y) (Set.Ioo x y)","decl":"@[simp]\ntheorem openSegment_eq_Ioo (h : x < y) : openSegment ğ•œ x y = Ioo x y :=\n  (openSegment_subset_Ioo h).antisymm Ioo_subset_openSegment\n\n"}
{"name":"segment_eq_Icc'","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\nx y : ğ•œ\nâŠ¢ Eq (segment ğ•œ x y) (Set.Icc (Min.min x y) (Max.max x y))","decl":"theorem segment_eq_Icc' (x y : ğ•œ) : [x -[ğ•œ] y] = Icc (min x y) (max x y) := by\n  rcases le_total x y with h | h\n  Â· rw [segment_eq_Icc h, max_eq_right h, min_eq_left h]\n  Â· rw [segment_symm, segment_eq_Icc h, max_eq_left h, min_eq_right h]\n\n"}
{"name":"openSegment_eq_Ioo'","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\nx y : ğ•œ\nhxy : Ne x y\nâŠ¢ Eq (openSegment ğ•œ x y) (Set.Ioo (Min.min x y) (Max.max x y))","decl":"theorem openSegment_eq_Ioo' (hxy : x â‰  y) : openSegment ğ•œ x y = Ioo (min x y) (max x y) := by\n  cases' hxy.lt_or_lt with h h\n  Â· rw [openSegment_eq_Ioo h, max_eq_right h.le, min_eq_left h.le]\n  Â· rw [openSegment_symm, openSegment_eq_Ioo h, max_eq_left h.le, min_eq_right h.le]\n\n"}
{"name":"segment_eq_uIcc","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\nx y : ğ•œ\nâŠ¢ Eq (segment ğ•œ x y) (Set.uIcc x y)","decl":"theorem segment_eq_uIcc (x y : ğ•œ) : [x -[ğ•œ] y] = uIcc x y :=\n  segment_eq_Icc' _ _\n\n"}
{"name":"Convex.mem_Icc","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\nx y z : ğ•œ\nh : LE.le x y\nâŠ¢ Iff (Membership.mem (Set.Icc x y) z) (Exists fun a => Exists fun b => And (LE.le 0 a) (And (LE.le 0 b) (And (Eq (HAdd.hAdd a b) 1) (Eq (HAdd.hAdd (HMul.hMul a x) (HMul.hMul b y)) z))))","decl":"/-- A point is in an `Icc` iff it can be expressed as a convex combination of the endpoints. -/\ntheorem Convex.mem_Icc (h : x â‰¤ y) :\n    z âˆˆ Icc x y â†” âˆƒ a b, 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ§ a + b = 1 âˆ§ a * x + b * y = z := by\n  simp only [â† segment_eq_Icc h, segment, mem_setOf_eq, smul_eq_mul, exists_and_left]\n\n"}
{"name":"Convex.mem_Ioo","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\nx y z : ğ•œ\nh : LT.lt x y\nâŠ¢ Iff (Membership.mem (Set.Ioo x y) z) (Exists fun a => Exists fun b => And (LT.lt 0 a) (And (LT.lt 0 b) (And (Eq (HAdd.hAdd a b) 1) (Eq (HAdd.hAdd (HMul.hMul a x) (HMul.hMul b y)) z))))","decl":"/-- A point is in an `Ioo` iff it can be expressed as a strict convex combination of the endpoints.\n-/\ntheorem Convex.mem_Ioo (h : x < y) :\n    z âˆˆ Ioo x y â†” âˆƒ a b, 0 < a âˆ§ 0 < b âˆ§ a + b = 1 âˆ§ a * x + b * y = z := by\n  simp only [â† openSegment_eq_Ioo h, openSegment, smul_eq_mul, exists_and_left, mem_setOf_eq]\n\n"}
{"name":"Convex.mem_Ioc","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\nx y z : ğ•œ\nh : LT.lt x y\nâŠ¢ Iff (Membership.mem (Set.Ioc x y) z) (Exists fun a => Exists fun b => And (LE.le 0 a) (And (LT.lt 0 b) (And (Eq (HAdd.hAdd a b) 1) (Eq (HAdd.hAdd (HMul.hMul a x) (HMul.hMul b y)) z))))","decl":"/-- A point is in an `Ioc` iff it can be expressed as a semistrict convex combination of the\nendpoints. -/\ntheorem Convex.mem_Ioc (h : x < y) :\n    z âˆˆ Ioc x y â†” âˆƒ a b, 0 â‰¤ a âˆ§ 0 < b âˆ§ a + b = 1 âˆ§ a * x + b * y = z := by\n  refine âŸ¨fun hz => ?_, ?_âŸ©\n  Â· obtain âŸ¨a, b, ha, hb, hab, rflâŸ© := (Convex.mem_Icc h.le).1 (Ioc_subset_Icc_self hz)\n    obtain rfl | hb' := hb.eq_or_lt\n    Â· rw [add_zero] at hab\n      rw [hab, one_mul, zero_mul, add_zero] at hz\n      exact (hz.1.ne rfl).elim\n    Â· exact âŸ¨a, b, ha, hb', hab, rflâŸ©\n  Â· rintro âŸ¨a, b, ha, hb, hab, rflâŸ©\n    obtain rfl | ha' := ha.eq_or_lt\n    Â· rw [zero_add] at hab\n      rwa [hab, one_mul, zero_mul, zero_add, right_mem_Ioc]\n    Â· exact Ioo_subset_Ioc_self ((Convex.mem_Ioo h).2 âŸ¨a, b, ha', hb, hab, rflâŸ©)\n\n"}
{"name":"Convex.mem_Ico","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\nx y z : ğ•œ\nh : LT.lt x y\nâŠ¢ Iff (Membership.mem (Set.Ico x y) z) (Exists fun a => Exists fun b => And (LT.lt 0 a) (And (LE.le 0 b) (And (Eq (HAdd.hAdd a b) 1) (Eq (HAdd.hAdd (HMul.hMul a x) (HMul.hMul b y)) z))))","decl":"/-- A point is in an `Ico` iff it can be expressed as a semistrict convex combination of the\nendpoints. -/\ntheorem Convex.mem_Ico (h : x < y) :\n    z âˆˆ Ico x y â†” âˆƒ a b, 0 < a âˆ§ 0 â‰¤ b âˆ§ a + b = 1 âˆ§ a * x + b * y = z := by\n  refine âŸ¨fun hz => ?_, ?_âŸ©\n  Â· obtain âŸ¨a, b, ha, hb, hab, rflâŸ© := (Convex.mem_Icc h.le).1 (Ico_subset_Icc_self hz)\n    obtain rfl | ha' := ha.eq_or_lt\n    Â· rw [zero_add] at hab\n      rw [hab, one_mul, zero_mul, zero_add] at hz\n      exact (hz.2.ne rfl).elim\n    Â· exact âŸ¨a, b, ha', hb, hab, rflâŸ©\n  Â· rintro âŸ¨a, b, ha, hb, hab, rflâŸ©\n    obtain rfl | hb' := hb.eq_or_lt\n    Â· rw [add_zero] at hab\n      rwa [hab, one_mul, zero_mul, add_zero, left_mem_Ico]\n    Â· exact Ioo_subset_Ico_self ((Convex.mem_Ioo h).2 âŸ¨a, b, ha, hb', hab, rflâŸ©)\n\n"}
{"name":"Prod.segment_subset","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : OrderedSemiring ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nx y : Prod E F\nâŠ¢ HasSubset.Subset (segment ğ•œ x y) (SProd.sprod (segment ğ•œ x.1 y.1) (segment ğ•œ x.2 y.2))","decl":"theorem segment_subset (x y : E Ã— F) : segment ğ•œ x y âŠ† segment ğ•œ x.1 y.1 Ã—Ë¢ segment ğ•œ x.2 y.2 := by\n  rintro z âŸ¨a, b, ha, hb, hab, hzâŸ©\n  exact âŸ¨âŸ¨a, b, ha, hb, hab, congr_arg Prod.fst hzâŸ©, a, b, ha, hb, hab, congr_arg Prod.snd hzâŸ©\n\n"}
{"name":"Prod.openSegment_subset","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : OrderedSemiring ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nx y : Prod E F\nâŠ¢ HasSubset.Subset (openSegment ğ•œ x y) (SProd.sprod (openSegment ğ•œ x.1 y.1) (openSegment ğ•œ x.2 y.2))","decl":"theorem openSegment_subset (x y : E Ã— F) :\n    openSegment ğ•œ x y âŠ† openSegment ğ•œ x.1 y.1 Ã—Ë¢ openSegment ğ•œ x.2 y.2 := by\n  rintro z âŸ¨a, b, ha, hb, hab, hzâŸ©\n  exact âŸ¨âŸ¨a, b, ha, hb, hab, congr_arg Prod.fst hzâŸ©, a, b, ha, hb, hab, congr_arg Prod.snd hzâŸ©\n\n"}
{"name":"Prod.image_mk_segment_left","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : OrderedSemiring ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nxâ‚ xâ‚‚ : E\ny : F\nâŠ¢ Eq (Set.image (fun x => { fst := x, snd := y }) (segment ğ•œ xâ‚ xâ‚‚)) (segment ğ•œ { fst := xâ‚, snd := y } { fst := xâ‚‚, snd := y })","decl":"theorem image_mk_segment_left (xâ‚ xâ‚‚ : E) (y : F) :\n    (fun x => (x, y)) '' [xâ‚ -[ğ•œ] xâ‚‚] = [(xâ‚, y) -[ğ•œ] (xâ‚‚, y)] := by\n  rw [segment_eq_imageâ‚‚, segment_eq_imageâ‚‚, image_image]\n  refine EqOn.image_eq fun a ha â†¦ ?_\n  simp [Convex.combo_self ha.2.2]\n\n"}
{"name":"Prod.image_mk_segment_right","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : OrderedSemiring ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nx : E\nyâ‚ yâ‚‚ : F\nâŠ¢ Eq (Set.image (fun y => { fst := x, snd := y }) (segment ğ•œ yâ‚ yâ‚‚)) (segment ğ•œ { fst := x, snd := yâ‚ } { fst := x, snd := yâ‚‚ })","decl":"theorem image_mk_segment_right (x : E) (yâ‚ yâ‚‚ : F) :\n    (fun y => (x, y)) '' [yâ‚ -[ğ•œ] yâ‚‚] = [(x, yâ‚) -[ğ•œ] (x, yâ‚‚)] := by\n  rw [segment_eq_imageâ‚‚, segment_eq_imageâ‚‚, image_image]\n  refine EqOn.image_eq fun a ha â†¦ ?_\n  simp [Convex.combo_self ha.2.2]\n\n"}
{"name":"Prod.image_mk_openSegment_left","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : OrderedSemiring ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nxâ‚ xâ‚‚ : E\ny : F\nâŠ¢ Eq (Set.image (fun x => { fst := x, snd := y }) (openSegment ğ•œ xâ‚ xâ‚‚)) (openSegment ğ•œ { fst := xâ‚, snd := y } { fst := xâ‚‚, snd := y })","decl":"theorem image_mk_openSegment_left (xâ‚ xâ‚‚ : E) (y : F) :\n    (fun x => (x, y)) '' openSegment ğ•œ xâ‚ xâ‚‚ = openSegment ğ•œ (xâ‚, y) (xâ‚‚, y) := by\n  rw [openSegment_eq_imageâ‚‚, openSegment_eq_imageâ‚‚, image_image]\n  refine EqOn.image_eq fun a ha â†¦ ?_\n  simp [Convex.combo_self ha.2.2]\n\n"}
{"name":"Prod.image_mk_openSegment_right","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : OrderedSemiring ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nx : E\nyâ‚ yâ‚‚ : F\nâŠ¢ Eq (Set.image (fun y => { fst := x, snd := y }) (openSegment ğ•œ yâ‚ yâ‚‚)) (openSegment ğ•œ { fst := x, snd := yâ‚ } { fst := x, snd := yâ‚‚ })","decl":"@[simp]\ntheorem image_mk_openSegment_right (x : E) (yâ‚ yâ‚‚ : F) :\n    (fun y => (x, y)) '' openSegment ğ•œ yâ‚ yâ‚‚ = openSegment ğ•œ (x, yâ‚) (x, yâ‚‚) := by\n  rw [openSegment_eq_imageâ‚‚, openSegment_eq_imageâ‚‚, image_image]\n  refine EqOn.image_eq fun a ha â†¦ ?_\n  simp [Convex.combo_self ha.2.2]\n\n"}
{"name":"Pi.segment_subset","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : (i : Î¹) â†’ AddCommMonoid (Ï€ i)\ninstâœ : (i : Î¹) â†’ Module ğ•œ (Ï€ i)\ns : Set Î¹\nx y : (i : Î¹) â†’ Ï€ i\nâŠ¢ HasSubset.Subset (segment ğ•œ x y) (s.pi fun i => segment ğ•œ (x i) (y i))","decl":"theorem segment_subset (x y : âˆ€ i, Ï€ i) : segment ğ•œ x y âŠ† s.pi fun i => segment ğ•œ (x i) (y i) := by\n  rintro z âŸ¨a, b, ha, hb, hab, hzâŸ© i -\n  exact âŸ¨a, b, ha, hb, hab, congr_fun hz iâŸ©\n\n"}
{"name":"Pi.openSegment_subset","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : (i : Î¹) â†’ AddCommMonoid (Ï€ i)\ninstâœ : (i : Î¹) â†’ Module ğ•œ (Ï€ i)\ns : Set Î¹\nx y : (i : Î¹) â†’ Ï€ i\nâŠ¢ HasSubset.Subset (openSegment ğ•œ x y) (s.pi fun i => openSegment ğ•œ (x i) (y i))","decl":"theorem openSegment_subset (x y : âˆ€ i, Ï€ i) :\n    openSegment ğ•œ x y âŠ† s.pi fun i => openSegment ğ•œ (x i) (y i) := by\n  rintro z âŸ¨a, b, ha, hb, hab, hzâŸ© i -\n  exact âŸ¨a, b, ha, hb, hab, congr_fun hz iâŸ©\n\n"}
{"name":"Pi.image_update_segment","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\ninstâœÂ³ : OrderedSemiring ğ•œ\ninstâœÂ² : (i : Î¹) â†’ AddCommMonoid (Ï€ i)\ninstâœÂ¹ : (i : Î¹) â†’ Module ğ•œ (Ï€ i)\ninstâœ : DecidableEq Î¹\ni : Î¹\nxâ‚ xâ‚‚ : Ï€ i\ny : (i : Î¹) â†’ Ï€ i\nâŠ¢ Eq (Set.image (Function.update y i) (segment ğ•œ xâ‚ xâ‚‚)) (segment ğ•œ (Function.update y i xâ‚) (Function.update y i xâ‚‚))","decl":"theorem image_update_segment (i : Î¹) (xâ‚ xâ‚‚ : Ï€ i) (y : âˆ€ i, Ï€ i) :\n    update y i '' [xâ‚ -[ğ•œ] xâ‚‚] = [update y i xâ‚ -[ğ•œ] update y i xâ‚‚] := by\n  rw [segment_eq_imageâ‚‚, segment_eq_imageâ‚‚, image_image]\n  refine EqOn.image_eq fun a ha â†¦ ?_\n  simp only [â† update_smul, â† update_add, Convex.combo_self ha.2.2]\n\n"}
{"name":"Pi.image_update_openSegment","module":"Mathlib.Analysis.Convex.Segment","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\ninstâœÂ³ : OrderedSemiring ğ•œ\ninstâœÂ² : (i : Î¹) â†’ AddCommMonoid (Ï€ i)\ninstâœÂ¹ : (i : Î¹) â†’ Module ğ•œ (Ï€ i)\ninstâœ : DecidableEq Î¹\ni : Î¹\nxâ‚ xâ‚‚ : Ï€ i\ny : (i : Î¹) â†’ Ï€ i\nâŠ¢ Eq (Set.image (Function.update y i) (openSegment ğ•œ xâ‚ xâ‚‚)) (openSegment ğ•œ (Function.update y i xâ‚) (Function.update y i xâ‚‚))","decl":"theorem image_update_openSegment (i : Î¹) (xâ‚ xâ‚‚ : Ï€ i) (y : âˆ€ i, Ï€ i) :\n    update y i '' openSegment ğ•œ xâ‚ xâ‚‚ = openSegment ğ•œ (update y i xâ‚) (update y i xâ‚‚) := by\n  rw [openSegment_eq_imageâ‚‚, openSegment_eq_imageâ‚‚, image_image]\n  refine EqOn.image_eq fun a ha â†¦ ?_\n  simp only [â† update_smul, â† update_add, Convex.combo_self ha.2.2]\n\n"}
