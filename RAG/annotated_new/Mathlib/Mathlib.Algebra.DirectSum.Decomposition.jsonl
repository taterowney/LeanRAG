{"name":"DirectSum.Decomposition.right_inv","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝³ : DecidableEq ι\ninst✝² : AddCommMonoid M\ninst✝¹ : SetLike σ M\ninst✝ : AddSubmonoidClass σ M\nℳ : ι → σ\nself : DirectSum.Decomposition ℳ\n⊢ Function.RightInverse (⇑(DirectSum.coeAddMonoidHom ℳ)) DirectSum.Decomposition.decompose'","decl":"/-- A decomposition is an equivalence between an additive monoid `M` and a direct sum of additive\nsubmonoids `ℳ i` of that `M`, such that the \"recomposition\" is canonical. This definition also\nworks for additive groups and modules.\n\nThis is a version of `DirectSum.IsInternal` which comes with a constructive inverse to the\ncanonical \"recomposition\" rather than just a proof that the \"recomposition\" is bijective.\n\nOften it is easier to construct a term of this type via `Decomposition.ofAddHom` or\n`Decomposition.ofLinearMap`. -/\nclass Decomposition where\n  decompose' : M → ⨁ i, ℳ i\n  left_inv : Function.LeftInverse (DirectSum.coeAddMonoidHom ℳ) decompose'\n  right_inv : Function.RightInverse (DirectSum.coeAddMonoidHom ℳ) decompose'\n\n"}
{"name":"DirectSum.Decomposition.left_inv","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝³ : DecidableEq ι\ninst✝² : AddCommMonoid M\ninst✝¹ : SetLike σ M\ninst✝ : AddSubmonoidClass σ M\nℳ : ι → σ\nself : DirectSum.Decomposition ℳ\n⊢ Function.LeftInverse (⇑(DirectSum.coeAddMonoidHom ℳ)) DirectSum.Decomposition.decompose'","decl":"/-- A decomposition is an equivalence between an additive monoid `M` and a direct sum of additive\nsubmonoids `ℳ i` of that `M`, such that the \"recomposition\" is canonical. This definition also\nworks for additive groups and modules.\n\nThis is a version of `DirectSum.IsInternal` which comes with a constructive inverse to the\ncanonical \"recomposition\" rather than just a proof that the \"recomposition\" is bijective.\n\nOften it is easier to construct a term of this type via `Decomposition.ofAddHom` or\n`Decomposition.ofLinearMap`. -/\nclass Decomposition where\n  decompose' : M → ⨁ i, ℳ i\n  left_inv : Function.LeftInverse (DirectSum.coeAddMonoidHom ℳ) decompose'\n  right_inv : Function.RightInverse (DirectSum.coeAddMonoidHom ℳ) decompose'\n\n"}
{"name":"DirectSum.instSubsingletonDecomposition","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝³ : DecidableEq ι\ninst✝² : AddCommMonoid M\ninst✝¹ : SetLike σ M\ninst✝ : AddSubmonoidClass σ M\nℳ : ι → σ\n⊢ Subsingleton (DirectSum.Decomposition ℳ)","decl":"/-- `DirectSum.Decomposition` instances, while carrying data, are always equal. -/\ninstance : Subsingleton (Decomposition ℳ) :=\n  ⟨fun x y ↦ by\n    obtain ⟨_, _, xr⟩ := x\n    obtain ⟨_, yl, _⟩ := y\n    congr\n    exact Function.LeftInverse.eq_rightInverse xr yl⟩\n\n"}
{"name":"DirectSum.Decomposition.isInternal","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommMonoid M\ninst✝² : SetLike σ M\ninst✝¹ : AddSubmonoidClass σ M\nℳ : ι → σ\ninst✝ : DirectSum.Decomposition ℳ\n⊢ DirectSum.IsInternal ℳ","decl":"protected theorem Decomposition.isInternal : DirectSum.IsInternal ℳ :=\n  ⟨Decomposition.right_inv.injective, Decomposition.left_inv.surjective⟩\n\n"}
{"name":"DirectSum.Decomposition.inductionOn","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommMonoid M\ninst✝² : SetLike σ M\ninst✝¹ : AddSubmonoidClass σ M\nℳ : ι → σ\ninst✝ : DirectSum.Decomposition ℳ\np : M → Prop\nh_zero : p 0\nh_homogeneous : ∀ {i : ι} (m : Subtype fun x => Membership.mem (ℳ i) x), p ↑m\nh_add : ∀ (m m' : M), p m → p m' → p (HAdd.hAdd m m')\nm : M\n⊢ p m","decl":"protected theorem Decomposition.inductionOn {p : M → Prop} (h_zero : p 0)\n    (h_homogeneous : ∀ {i} (m : ℳ i), p (m : M)) (h_add : ∀ m m' : M, p m → p m' → p (m + m')) :\n    ∀ m, p m := by\n  let ℳ' : ι → AddSubmonoid M := fun i ↦\n    (⟨⟨ℳ i, fun x y ↦ AddMemClass.add_mem x y⟩, (ZeroMemClass.zero_mem _)⟩ : AddSubmonoid M)\n  haveI t : DirectSum.Decomposition ℳ' :=\n    { decompose' := DirectSum.decompose ℳ\n      left_inv := fun _ ↦ (decompose ℳ).left_inv _\n      right_inv := fun _ ↦ (decompose ℳ).right_inv _ }\n  have mem : ∀ m, m ∈ iSup ℳ' := fun _m ↦\n    (DirectSum.IsInternal.addSubmonoid_iSup_eq_top ℳ' (Decomposition.isInternal ℳ')).symm ▸ trivial\n  -- Porting note: needs to use @ even though no implicit argument is provided\n  exact fun m ↦ @AddSubmonoid.iSup_induction _ _ _ ℳ' _ _ (mem m)\n    (fun i m h ↦ h_homogeneous ⟨m, h⟩) h_zero h_add\n--  exact fun m ↦\n--    AddSubmonoid.iSup_induction ℳ' (mem m) (fun i m h ↦ h_homogeneous ⟨m, h⟩) h_zero h_add\n\n"}
{"name":"DirectSum.Decomposition.decompose'_eq","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommMonoid M\ninst✝² : SetLike σ M\ninst✝¹ : AddSubmonoidClass σ M\nℳ : ι → σ\ninst✝ : DirectSum.Decomposition ℳ\n⊢ Eq DirectSum.Decomposition.decompose' ⇑(DirectSum.decompose ℳ)","decl":"@[simp]\ntheorem Decomposition.decompose'_eq : Decomposition.decompose' = decompose ℳ := rfl\n\n"}
{"name":"DirectSum.decompose_symm_of","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommMonoid M\ninst✝² : SetLike σ M\ninst✝¹ : AddSubmonoidClass σ M\nℳ : ι → σ\ninst✝ : DirectSum.Decomposition ℳ\ni : ι\nx : Subtype fun x => Membership.mem (ℳ i) x\n⊢ Eq ((DirectSum.decompose ℳ).symm ((DirectSum.of (fun i => Subtype fun x => Membership.mem (ℳ i) x) i) x)) ↑x","decl":"@[simp]\ntheorem decompose_symm_of {i : ι} (x : ℳ i) : (decompose ℳ).symm (DirectSum.of _ i x) = x :=\n  DirectSum.coeAddMonoidHom_of ℳ _ _\n\n"}
{"name":"DirectSum.decompose_coe","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommMonoid M\ninst✝² : SetLike σ M\ninst✝¹ : AddSubmonoidClass σ M\nℳ : ι → σ\ninst✝ : DirectSum.Decomposition ℳ\ni : ι\nx : Subtype fun x => Membership.mem (ℳ i) x\n⊢ Eq ((DirectSum.decompose ℳ) ↑x) ((DirectSum.of (fun i => Subtype fun x => Membership.mem (ℳ i) x) i) x)","decl":"@[simp]\ntheorem decompose_coe {i : ι} (x : ℳ i) : decompose ℳ (x : M) = DirectSum.of _ i x := by\n  rw [← decompose_symm_of _, Equiv.apply_symm_apply]\n\n"}
{"name":"DirectSum.decompose_of_mem","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommMonoid M\ninst✝² : SetLike σ M\ninst✝¹ : AddSubmonoidClass σ M\nℳ : ι → σ\ninst✝ : DirectSum.Decomposition ℳ\nx : M\ni : ι\nhx : Membership.mem (ℳ i) x\n⊢ Eq ((DirectSum.decompose ℳ) x) ((DirectSum.of (fun i => Subtype fun x => Membership.mem (ℳ i) x) i) ⟨x, hx⟩)","decl":"theorem decompose_of_mem {x : M} {i : ι} (hx : x ∈ ℳ i) :\n    decompose ℳ x = DirectSum.of (fun i ↦ ℳ i) i ⟨x, hx⟩ :=\n  decompose_coe _ ⟨x, hx⟩\n\n"}
{"name":"DirectSum.decompose_of_mem_same","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommMonoid M\ninst✝² : SetLike σ M\ninst✝¹ : AddSubmonoidClass σ M\nℳ : ι → σ\ninst✝ : DirectSum.Decomposition ℳ\nx : M\ni : ι\nhx : Membership.mem (ℳ i) x\n⊢ Eq (↑(((DirectSum.decompose ℳ) x) i)) x","decl":"theorem decompose_of_mem_same {x : M} {i : ι} (hx : x ∈ ℳ i) : (decompose ℳ x i : M) = x := by\n  rw [decompose_of_mem _ hx, DirectSum.of_eq_same, Subtype.coe_mk]\n\n"}
{"name":"DirectSum.decompose_of_mem_ne","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommMonoid M\ninst✝² : SetLike σ M\ninst✝¹ : AddSubmonoidClass σ M\nℳ : ι → σ\ninst✝ : DirectSum.Decomposition ℳ\nx : M\ni j : ι\nhx : Membership.mem (ℳ i) x\nhij : Ne i j\n⊢ Eq (↑(((DirectSum.decompose ℳ) x) j)) 0","decl":"theorem decompose_of_mem_ne {x : M} {i j : ι} (hx : x ∈ ℳ i) (hij : i ≠ j) :\n    (decompose ℳ x j : M) = 0 := by\n  rw [decompose_of_mem _ hx, DirectSum.of_eq_of_ne _ _ _ hij, ZeroMemClass.coe_zero]\n\n"}
{"name":"DirectSum.degree_eq_of_mem_mem","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommMonoid M\ninst✝² : SetLike σ M\ninst✝¹ : AddSubmonoidClass σ M\nℳ : ι → σ\ninst✝ : DirectSum.Decomposition ℳ\nx : M\ni j : ι\nhxi : Membership.mem (ℳ i) x\nhxj : Membership.mem (ℳ j) x\nhx : Ne x 0\n⊢ Eq i j","decl":"theorem degree_eq_of_mem_mem {x : M} {i j : ι} (hxi : x ∈ ℳ i) (hxj : x ∈ ℳ j) (hx : x ≠ 0) :\n    i = j := by\n  contrapose! hx; rw [← decompose_of_mem_same ℳ hxj, decompose_of_mem_ne ℳ hxi hx]\n\n"}
{"name":"DirectSum.decomposeAddEquiv_apply","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommMonoid M\ninst✝² : SetLike σ M\ninst✝¹ : AddSubmonoidClass σ M\nℳ : ι → σ\ninst✝ : DirectSum.Decomposition ℳ\na✝ : M\n⊢ Eq ((DirectSum.decomposeAddEquiv ℳ) a✝) ((DirectSum.decompose ℳ) a✝)","decl":"/-- If `M` is graded by `ι` with degree `i` component `ℳ i`, then it is isomorphic as\nan additive monoid to a direct sum of components. -/\n@[simps!]\ndef decomposeAddEquiv : M ≃+ ⨁ i, ℳ i :=\n  AddEquiv.symm { (decompose ℳ).symm with map_add' := map_add (DirectSum.coeAddMonoidHom ℳ) }\n\n"}
{"name":"DirectSum.decomposeAddEquiv_symm_apply","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommMonoid M\ninst✝² : SetLike σ M\ninst✝¹ : AddSubmonoidClass σ M\nℳ : ι → σ\ninst✝ : DirectSum.Decomposition ℳ\na✝ : DirectSum ι fun i => Subtype fun x => Membership.mem (ℳ i) x\n⊢ Eq ((DirectSum.decomposeAddEquiv ℳ).symm a✝) ((DirectSum.decompose ℳ).symm a✝)","decl":"/-- If `M` is graded by `ι` with degree `i` component `ℳ i`, then it is isomorphic as\nan additive monoid to a direct sum of components. -/\n@[simps!]\ndef decomposeAddEquiv : M ≃+ ⨁ i, ℳ i :=\n  AddEquiv.symm { (decompose ℳ).symm with map_add' := map_add (DirectSum.coeAddMonoidHom ℳ) }\n\n"}
{"name":"DirectSum.decompose_zero","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommMonoid M\ninst✝² : SetLike σ M\ninst✝¹ : AddSubmonoidClass σ M\nℳ : ι → σ\ninst✝ : DirectSum.Decomposition ℳ\n⊢ Eq ((DirectSum.decompose ℳ) 0) 0","decl":"@[simp]\ntheorem decompose_zero : decompose ℳ (0 : M) = 0 :=\n  map_zero (decomposeAddEquiv ℳ)\n\n"}
{"name":"DirectSum.decompose_symm_zero","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommMonoid M\ninst✝² : SetLike σ M\ninst✝¹ : AddSubmonoidClass σ M\nℳ : ι → σ\ninst✝ : DirectSum.Decomposition ℳ\n⊢ Eq ((DirectSum.decompose ℳ).symm 0) 0","decl":"@[simp]\ntheorem decompose_symm_zero : (decompose ℳ).symm 0 = (0 : M) :=\n  map_zero (decomposeAddEquiv ℳ).symm\n\n"}
{"name":"DirectSum.decompose_add","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommMonoid M\ninst✝² : SetLike σ M\ninst✝¹ : AddSubmonoidClass σ M\nℳ : ι → σ\ninst✝ : DirectSum.Decomposition ℳ\nx y : M\n⊢ Eq ((DirectSum.decompose ℳ) (HAdd.hAdd x y)) (HAdd.hAdd ((DirectSum.decompose ℳ) x) ((DirectSum.decompose ℳ) y))","decl":"@[simp]\ntheorem decompose_add (x y : M) : decompose ℳ (x + y) = decompose ℳ x + decompose ℳ y :=\n  map_add (decomposeAddEquiv ℳ) x y\n\n"}
{"name":"DirectSum.decompose_symm_add","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommMonoid M\ninst✝² : SetLike σ M\ninst✝¹ : AddSubmonoidClass σ M\nℳ : ι → σ\ninst✝ : DirectSum.Decomposition ℳ\nx y : DirectSum ι fun i => Subtype fun x => Membership.mem (ℳ i) x\n⊢ Eq ((DirectSum.decompose ℳ).symm (HAdd.hAdd x y)) (HAdd.hAdd ((DirectSum.decompose ℳ).symm x) ((DirectSum.decompose ℳ).symm y))","decl":"@[simp]\ntheorem decompose_symm_add (x y : ⨁ i, ℳ i) :\n    (decompose ℳ).symm (x + y) = (decompose ℳ).symm x + (decompose ℳ).symm y :=\n  map_add (decomposeAddEquiv ℳ).symm x y\n\n"}
{"name":"DirectSum.decompose_sum","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommMonoid M\ninst✝² : SetLike σ M\ninst✝¹ : AddSubmonoidClass σ M\nℳ : ι → σ\ninst✝ : DirectSum.Decomposition ℳ\nι' : Type u_5\ns : Finset ι'\nf : ι' → M\n⊢ Eq ((DirectSum.decompose ℳ) (s.sum fun i => f i)) (s.sum fun i => (DirectSum.decompose ℳ) (f i))","decl":"@[simp]\ntheorem decompose_sum {ι'} (s : Finset ι') (f : ι' → M) :\n    decompose ℳ (∑ i ∈ s, f i) = ∑ i ∈ s, decompose ℳ (f i) :=\n  map_sum (decomposeAddEquiv ℳ) f s\n\n"}
{"name":"DirectSum.decompose_symm_sum","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommMonoid M\ninst✝² : SetLike σ M\ninst✝¹ : AddSubmonoidClass σ M\nℳ : ι → σ\ninst✝ : DirectSum.Decomposition ℳ\nι' : Type u_5\ns : Finset ι'\nf : ι' → DirectSum ι fun i => Subtype fun x => Membership.mem (ℳ i) x\n⊢ Eq ((DirectSum.decompose ℳ).symm (s.sum fun i => f i)) (s.sum fun i => (DirectSum.decompose ℳ).symm (f i))","decl":"@[simp]\ntheorem decompose_symm_sum {ι'} (s : Finset ι') (f : ι' → ⨁ i, ℳ i) :\n    (decompose ℳ).symm (∑ i ∈ s, f i) = ∑ i ∈ s, (decompose ℳ).symm (f i) :=\n  map_sum (decomposeAddEquiv ℳ).symm f s\n\n"}
{"name":"DirectSum.sum_support_decompose","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : AddCommMonoid M\ninst✝³ : SetLike σ M\ninst✝² : AddSubmonoidClass σ M\nℳ : ι → σ\ninst✝¹ : DirectSum.Decomposition ℳ\ninst✝ : (i : ι) → (x : Subtype fun x => Membership.mem (ℳ i) x) → Decidable (Ne x 0)\nr : M\n⊢ Eq ((DFinsupp.support ((DirectSum.decompose ℳ) r)).sum fun i => ↑(((DirectSum.decompose ℳ) r) i)) r","decl":"theorem sum_support_decompose [∀ (i) (x : ℳ i), Decidable (x ≠ 0)] (r : M) :\n    (∑ i ∈ (decompose ℳ r).support, (decompose ℳ r i : M)) = r := by\n  conv_rhs =>\n    rw [← (decompose ℳ).symm_apply_apply r, ← sum_support_of (decompose ℳ r)]\n  rw [decompose_symm_sum]\n  simp_rw [decompose_symm_of]\n\n"}
{"name":"DirectSum.decompose_neg","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommGroup M\ninst✝² : SetLike σ M\ninst✝¹ : AddSubgroupClass σ M\nℳ : ι → σ\ninst✝ : DirectSum.Decomposition ℳ\nx : M\n⊢ Eq ((DirectSum.decompose ℳ) (Neg.neg x)) (Neg.neg ((DirectSum.decompose ℳ) x))","decl":"@[simp]\ntheorem decompose_neg (x : M) : decompose ℳ (-x) = -decompose ℳ x :=\n  map_neg (decomposeAddEquiv ℳ) x\n\n"}
{"name":"DirectSum.decompose_symm_neg","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommGroup M\ninst✝² : SetLike σ M\ninst✝¹ : AddSubgroupClass σ M\nℳ : ι → σ\ninst✝ : DirectSum.Decomposition ℳ\nx : DirectSum ι fun i => Subtype fun x => Membership.mem (ℳ i) x\n⊢ Eq ((DirectSum.decompose ℳ).symm (Neg.neg x)) (Neg.neg ((DirectSum.decompose ℳ).symm x))","decl":"@[simp]\ntheorem decompose_symm_neg (x : ⨁ i, ℳ i) : (decompose ℳ).symm (-x) = -(decompose ℳ).symm x :=\n  map_neg (decomposeAddEquiv ℳ).symm x\n\n"}
{"name":"DirectSum.decompose_sub","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommGroup M\ninst✝² : SetLike σ M\ninst✝¹ : AddSubgroupClass σ M\nℳ : ι → σ\ninst✝ : DirectSum.Decomposition ℳ\nx y : M\n⊢ Eq ((DirectSum.decompose ℳ) (HSub.hSub x y)) (HSub.hSub ((DirectSum.decompose ℳ) x) ((DirectSum.decompose ℳ) y))","decl":"@[simp]\ntheorem decompose_sub (x y : M) : decompose ℳ (x - y) = decompose ℳ x - decompose ℳ y :=\n  map_sub (decomposeAddEquiv ℳ) x y\n\n"}
{"name":"DirectSum.decompose_symm_sub","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nM : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommGroup M\ninst✝² : SetLike σ M\ninst✝¹ : AddSubgroupClass σ M\nℳ : ι → σ\ninst✝ : DirectSum.Decomposition ℳ\nx y : DirectSum ι fun i => Subtype fun x => Membership.mem (ℳ i) x\n⊢ Eq ((DirectSum.decompose ℳ).symm (HSub.hSub x y)) (HSub.hSub ((DirectSum.decompose ℳ).symm x) ((DirectSum.decompose ℳ).symm y))","decl":"@[simp]\ntheorem decompose_symm_sub (x y : ⨁ i, ℳ i) :\n    (decompose ℳ).symm (x - y) = (decompose ℳ).symm x - (decompose ℳ).symm y :=\n  map_sub (decomposeAddEquiv ℳ).symm x y\n\n"}
{"name":"DirectSum.decomposeLinearEquiv_apply","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁴ : DecidableEq ι\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nℳ : ι → Submodule R M\ninst✝ : DirectSum.Decomposition ℳ\nm : M\n⊢ Eq ((DirectSum.decomposeLinearEquiv ℳ) m) ((DirectSum.decompose ℳ) m)","decl":"@[simp] theorem decomposeLinearEquiv_apply (m : M) :\n    decomposeLinearEquiv ℳ m = decompose ℳ m := rfl\n\n"}
{"name":"DirectSum.decomposeLinearEquiv_symm_apply","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁴ : DecidableEq ι\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nℳ : ι → Submodule R M\ninst✝ : DirectSum.Decomposition ℳ\nm : DirectSum ι fun i => Subtype fun x => Membership.mem (ℳ i) x\n⊢ Eq ((DirectSum.decomposeLinearEquiv ℳ).symm m) ((DirectSum.decompose ℳ).symm m)","decl":"@[simp] theorem decomposeLinearEquiv_symm_apply (m : ⨁ i, ℳ i) :\n    (decomposeLinearEquiv ℳ).symm m = (decompose ℳ).symm m := rfl\n\n"}
{"name":"DirectSum.decompose_smul","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁴ : DecidableEq ι\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nℳ : ι → Submodule R M\ninst✝ : DirectSum.Decomposition ℳ\nr : R\nx : M\n⊢ Eq ((DirectSum.decompose ℳ) (HSMul.hSMul r x)) (HSMul.hSMul r ((DirectSum.decompose ℳ) x))","decl":"@[simp]\ntheorem decompose_smul (r : R) (x : M) : decompose ℳ (r • x) = r • decompose ℳ x :=\n  map_smul (decomposeLinearEquiv ℳ) r x\n\n"}
{"name":"DirectSum.decomposeLinearEquiv_symm_comp_lof","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁴ : DecidableEq ι\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nℳ : ι → Submodule R M\ninst✝ : DirectSum.Decomposition ℳ\ni : ι\n⊢ Eq ((↑(DirectSum.decomposeLinearEquiv ℳ).symm).comp (DirectSum.lof R ι (fun x => Subtype fun x_1 => Membership.mem (ℳ x) x_1) i)) (ℳ i).subtype","decl":"@[simp] theorem decomposeLinearEquiv_symm_comp_lof (i : ι) :\n    (decomposeLinearEquiv ℳ).symm ∘ₗ lof R ι (ℳ ·) i = (ℳ i).subtype :=\n  LinearMap.ext <| decompose_symm_of _\n\n"}
{"name":"DirectSum.decompose_lhom_ext","module":"Mathlib.Algebra.DirectSum.Decomposition","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nℳ : ι → Submodule R M\ninst✝² : DirectSum.Decomposition ℳ\nN : Type u_5\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nf g : LinearMap (RingHom.id R) M N\nh : ∀ (i : ι), Eq (f.comp (ℳ i).subtype) (g.comp (ℳ i).subtype)\n⊢ Eq f g","decl":"/-- Two linear maps from a module with a decomposition agree if they agree on every piece.\n\nNote this cannot be `@[ext]` as `ℳ` cannot be inferred. -/\ntheorem decompose_lhom_ext {N} [AddCommMonoid N] [Module R N] ⦃f g : M →ₗ[R] N⦄\n    (h : ∀ i, f ∘ₗ (ℳ i).subtype = g ∘ₗ (ℳ i).subtype) : f = g :=\n  LinearMap.ext <| (decomposeLinearEquiv ℳ).symm.surjective.forall.mpr <|\n    suffices f ∘ₗ (decomposeLinearEquiv ℳ).symm\n           = (g ∘ₗ (decomposeLinearEquiv ℳ).symm : (⨁ i, ℳ i) →ₗ[R] N) from\n      DFunLike.congr_fun this\n    linearMap_ext _ fun i => by\n      simp_rw [LinearMap.comp_assoc, decomposeLinearEquiv_symm_comp_lof ℳ i, h]\n\n"}
