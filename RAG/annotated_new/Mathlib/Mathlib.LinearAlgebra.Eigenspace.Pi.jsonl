{"name":"Module.End.mem_iInf_maxGenEigenspace_iff","module":"Mathlib.LinearAlgebra.Eigenspace.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_4\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : ι → Module.End R M\nχ : ι → R\nm : M\n⊢ Iff (Membership.mem (iInf fun i => (f i).maxGenEigenspace (χ i)) m) (∀ (j : ι), Exists fun k => Eq ((HPow.hPow (HSub.hSub (f j) (HSMul.hSMul (χ j) 1)) k) m) 0)","decl":"theorem mem_iInf_maxGenEigenspace_iff (χ : ι → R) (m : M) :\n    m ∈ ⨅ i, (f i).maxGenEigenspace (χ i) ↔ ∀ j, ∃ k : ℕ, ((f j - χ j • ↑1) ^ k) m = 0 := by\n  simp\n\n"}
{"name":"Submodule.inf_iInf_maxGenEigenspace_of_forall_mapsTo","module":"Mathlib.LinearAlgebra.Eigenspace.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_4\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : ι → Module.End R M\nμ : ι → R\np : Submodule R M\nhfp : ∀ (i : ι), Set.MapsTo ⇑(f i) ↑p ↑p\n⊢ Eq (Min.min p (iInf fun i => (f i).maxGenEigenspace (μ i))) (Submodule.map p.subtype (iInf fun i => Module.End.maxGenEigenspace (LinearMap.restrict (f i) ⋯) (μ i)))","decl":"/-- Given a family of endomorphisms `i ↦ f i`, a family of candidate eigenvalues `i ↦ μ i`, and a\nsubmodule `p` which is invariant wrt every `f i`, the intersection of `p` with the simultaneous\nmaximal generalised eigenspace (taken over all `i`), is the same as the simultaneous maximal\ngeneralised eigenspace of the `f i` restricted to `p`. -/\nlemma _root_.Submodule.inf_iInf_maxGenEigenspace_of_forall_mapsTo {μ : ι → R}\n    (p : Submodule R M) (hfp : ∀ i, MapsTo (f i) p p) :\n    p ⊓ ⨅ i, (f i).maxGenEigenspace (μ i) =\n      (⨅ i, maxGenEigenspace ((f i).restrict (hfp i)) (μ i)).map p.subtype := by\n  cases isEmpty_or_nonempty ι\n  · simp [iInf_of_isEmpty]\n  · simp_rw [inf_iInf, p.inf_genEigenspace _ (hfp _), Submodule.map_iInf _ p.injective_subtype]\n\n"}
{"name":"Module.End.iInf_maxGenEigenspace_restrict_map_subtype_eq","module":"Mathlib.LinearAlgebra.Eigenspace.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_4\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : ι → Module.End R M\nμ : ι → R\ni : ι\nh : ∀ (j : ι), Set.MapsTo ⇑(f j) ↑((f i).maxGenEigenspace (μ i)) ↑((f i).maxGenEigenspace (μ i))\n⊢ Eq (Submodule.map ((f i).maxGenEigenspace (μ i)).subtype (iInf fun j => (fun j => Module.End.maxGenEigenspace (LinearMap.restrict (f j) ⋯) (μ j)) j)) (iInf fun j => (f j).maxGenEigenspace (μ j))","decl":"/-- Given a family of endomorphisms `i ↦ f i`, a family of candidate eigenvalues `i ↦ μ i`, and a\ndistinguished index `i` whose maximal generalised `μ i`-eigenspace is invariant wrt every `f j`,\ntaking simultaneous maximal generalised eigenspaces is unaffected by first restricting to the\ndistinguished generalised `μ i`-eigenspace. -/\nlemma iInf_maxGenEigenspace_restrict_map_subtype_eq\n    {μ : ι → R} (i : ι)\n    (h : ∀ j, MapsTo (f j) ((f i).maxGenEigenspace (μ i)) ((f i).maxGenEigenspace (μ i))) :\n    letI p := (f i).maxGenEigenspace (μ i)\n    letI q (j : ι) := maxGenEigenspace ((f j).restrict (h j)) (μ j)\n    (⨅ j, q j).map p.subtype = ⨅ j, (f j).maxGenEigenspace (μ j) := by\n  have : Nonempty ι := ⟨i⟩\n  set p := (f i).maxGenEigenspace (μ i)\n  have : ⨅ j, (f j).maxGenEigenspace (μ j) = p ⊓ ⨅ j, (f j).maxGenEigenspace (μ j) := by\n    refine le_antisymm ?_ inf_le_right\n    simpa only [le_inf_iff, le_refl, and_true] using iInf_le _ _\n  rw [Submodule.map_iInf _ p.injective_subtype, this, Submodule.inf_iInf]\n  conv_rhs =>\n    enter [1]\n    ext\n    rw [p.inf_genEigenspace (f _) (h _)]\n\n"}
{"name":"Module.End.disjoint_iInf_maxGenEigenspace","module":"Mathlib.LinearAlgebra.Eigenspace.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_4\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nf : ι → Module.End R M\ninst✝ : NoZeroSMulDivisors R M\nχ₁ χ₂ : ι → R\nh : Ne χ₁ χ₂\n⊢ Disjoint (iInf fun i => (f i).maxGenEigenspace (χ₁ i)) (iInf fun i => (f i).maxGenEigenspace (χ₂ i))","decl":"lemma disjoint_iInf_maxGenEigenspace {χ₁ χ₂ : ι → R} (h : χ₁ ≠ χ₂) :\n    Disjoint (⨅ i, (f i).maxGenEigenspace (χ₁ i)) (⨅ i, (f i).maxGenEigenspace (χ₂ i)) := by\n  obtain ⟨j, hj⟩ : ∃ j, χ₁ j ≠ χ₂ j := Function.ne_iff.mp h\n  exact (End.disjoint_genEigenspace (f j) hj ⊤ ⊤).mono (iInf_le _ j) (iInf_le _ j)\n\n"}
{"name":"Module.End.injOn_iInf_maxGenEigenspace","module":"Mathlib.LinearAlgebra.Eigenspace.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_4\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nf : ι → Module.End R M\ninst✝ : NoZeroSMulDivisors R M\n⊢ Set.InjOn (fun χ => iInf fun i => (f i).maxGenEigenspace (χ i)) (setOf fun χ => Ne (iInf fun i => (f i).maxGenEigenspace (χ i)) Bot.bot)","decl":"lemma injOn_iInf_maxGenEigenspace :\n    InjOn (fun χ : ι → R ↦ ⨅ i, (f i).maxGenEigenspace (χ i))\n      {χ | ⨅ i, (f i).maxGenEigenspace (χ i) ≠ ⊥} := by\n  rintro χ₁ _ χ₂\n    hχ₂ (hχ₁₂ : ⨅ i, (f i).maxGenEigenspace (χ₁ i) = ⨅ i, (f i).maxGenEigenspace (χ₂ i))\n  contrapose! hχ₂\n  simpa [hχ₁₂] using disjoint_iInf_maxGenEigenspace f hχ₂\n\n"}
{"name":"Module.End.independent_iInf_maxGenEigenspace_of_forall_mapsTo","module":"Mathlib.LinearAlgebra.Eigenspace.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_4\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nf : ι → Module.End R M\ninst✝ : NoZeroSMulDivisors R M\nh : ∀ (i j : ι) (φ : R), Set.MapsTo ⇑(f i) ↑((f j).maxGenEigenspace φ) ↑((f j).maxGenEigenspace φ)\n⊢ iSupIndep fun χ => iInf fun i => (f i).maxGenEigenspace (χ i)","decl":"lemma independent_iInf_maxGenEigenspace_of_forall_mapsTo\n    (h : ∀ i j φ, MapsTo (f i) ((f j).maxGenEigenspace φ) ((f j).maxGenEigenspace φ)) :\n    iSupIndep fun χ : ι → R ↦ ⨅ i, (f i).maxGenEigenspace (χ i) := by\n  replace h (l : ι) (χ : ι → R) :\n      MapsTo (f l) (⨅ i, (f i).maxGenEigenspace (χ i)) (⨅ i, (f i).maxGenEigenspace (χ i)) := by\n    intro x hx\n    simp only [iInf_eq_iInter, mem_iInter, SetLike.mem_coe] at hx ⊢\n    exact fun i ↦ h l i (χ i) (hx i)\n  classical\n  suffices ∀ χ (s : Finset (ι → R)) (_ : χ ∉ s),\n      Disjoint (⨅ i, (f i).maxGenEigenspace (χ i))\n        (s.sup fun (χ : ι → R) ↦ ⨅ i, (f i).maxGenEigenspace (χ i)) by\n    simpa only [iSupIndep_iff_supIndep_of_injOn (injOn_iInf_maxGenEigenspace f),\n      Finset.supIndep_iff_disjoint_erase] using fun s χ _ ↦ this _ _ (s.not_mem_erase χ)\n  intro χ₁ s\n  induction s using Finset.induction_on with\n  | empty => simp\n  | insert _n ih =>\n  rename_i χ₂ s\n  intro hχ₁₂\n  obtain ⟨hχ₁₂ : χ₁ ≠ χ₂, hχ₁ : χ₁ ∉ s⟩ := by rwa [Finset.mem_insert, not_or] at hχ₁₂\n  specialize ih hχ₁\n  rw [Finset.sup_insert, disjoint_iff, Submodule.eq_bot_iff]\n  rintro x ⟨hx, hx'⟩\n  simp only [SetLike.mem_coe] at hx hx'\n  suffices x ∈ ⨅ i, (f i).maxGenEigenspace (χ₂ i) by\n    rw [← Submodule.mem_bot (R := R), ← (disjoint_iInf_maxGenEigenspace f hχ₁₂).eq_bot]\n    exact ⟨hx, this⟩\n  obtain ⟨y, hy, z, hz, rfl⟩ := Submodule.mem_sup.mp hx'; clear hx'\n  suffices ∀ l, ∃ (k : ℕ),\n      ((f l - algebraMap R (Module.End R M) (χ₂ l)) ^ k) (y + z) ∈\n      (⨅ i, (f i).maxGenEigenspace (χ₁ i)) ⊓\n        Finset.sup s fun χ ↦ ⨅ i, (f i).maxGenEigenspace (χ i) by\n    simpa [ih.eq_bot, Submodule.mem_bot] using this\n  intro l\n  let g : Module.End R M := f l - algebraMap R (Module.End R M) (χ₂ l)\n  obtain ⟨k, hk : (g ^ k) y = 0⟩ := (mem_iInf_maxGenEigenspace_iff _ _ _).mp hy l\n  have aux (f : End R M) (φ : R) (k : ℕ) (p : Submodule R M) (hp : MapsTo f p p) :\n      MapsTo ((f - algebraMap R (Module.End R M) φ) ^ k) p p := by\n    rw [LinearMap.coe_pow]\n    exact MapsTo.iterate (fun m hm ↦ p.sub_mem (hp hm) (p.smul_mem _ hm)) k\n  refine ⟨k, Submodule.mem_inf.mp ⟨?_, ?_⟩⟩\n  · refine aux (f l) (χ₂ l) k (⨅ i, (f i).maxGenEigenspace (χ₁ i)) ?_ hx\n    simp only [Submodule.iInf_coe]\n    exact h l χ₁\n  · rw [map_add, hk, zero_add]\n    suffices (s.sup fun χ ↦ (⨅ i, (f i).maxGenEigenspace (χ i))).map (g ^ k) ≤\n        s.sup fun χ ↦ (⨅ i, (f i).maxGenEigenspace (χ i)) by\n      refine this (Submodule.mem_map_of_mem ?_)\n      simp_rw [Finset.sup_eq_iSup, ← Finset.sup_eq_iSup] at hz\n      exact hz\n    simp_rw [Finset.sup_eq_iSup, Submodule.map_iSup (ι := ι → R), Submodule.map_iSup (ι := _ ∈ s)]\n    refine iSup₂_mono fun χ _ ↦ ?_\n    rintro - ⟨u, hu, rfl⟩\n    refine aux (f l) (χ₂ l) k (⨅ i, (f i).maxGenEigenspace (χ i)) ?_ hu\n    simp only [Submodule.iInf_coe]\n    exact h l χ\n\n"}
{"name":"Module.End.iSup_iInf_maxGenEigenspace_eq_top_of_forall_mapsTo","module":"Mathlib.LinearAlgebra.Eigenspace.Pi","initialProofState":"ι : Type u_1\nK : Type u_3\nM : Type u_4\ninst✝³ : Field K\ninst✝² : AddCommGroup M\ninst✝¹ : Module K M\ninst✝ : FiniteDimensional K M\nf : ι → Module.End K M\nh : ∀ (i j : ι) (φ : K), Set.MapsTo ⇑(f i) ↑((f j).maxGenEigenspace φ) ↑((f j).maxGenEigenspace φ)\nh' : ∀ (i : ι), Eq (iSup fun μ => (f i).maxGenEigenspace μ) Top.top\n⊢ Eq (iSup fun χ => iInf fun i => (f i).maxGenEigenspace (χ i)) Top.top","decl":"/-- Given a family of endomorphisms `i ↦ f i` which are compatible in the sense that every maximal\ngeneralised eigenspace of `f i` is invariant wrt `f j`, if each `f i` is triangularizable, the\nfamily is simultaneously triangularizable. -/\nlemma iSup_iInf_maxGenEigenspace_eq_top_of_forall_mapsTo [FiniteDimensional K M]\n    (f : ι → End K M)\n    (h : ∀ i j φ, MapsTo (f i) ((f j).maxGenEigenspace φ) ((f j).maxGenEigenspace φ))\n    (h' : ∀ i, ⨆ μ, (f i).maxGenEigenspace μ = ⊤) :\n    ⨆ χ : ι → K, ⨅ i, (f i).maxGenEigenspace (χ i) = ⊤ := by\n  generalize h_dim : finrank K M = n\n  induction n using Nat.strongRecOn generalizing M with | ind n ih => ?_\n  obtain this | ⟨i : ι, hy : ¬ ∃ φ, (f i).maxGenEigenspace φ = ⊤⟩ :=\n    forall_or_exists_not (fun j : ι ↦ ∃ φ : K, (f j).maxGenEigenspace φ = ⊤)\n  · choose χ hχ using this\n    replace hχ : ⨅ i, (f i).maxGenEigenspace (χ i) = ⊤ := by simpa\n    simp_rw [eq_top_iff] at hχ ⊢\n    exact le_trans hχ <| le_iSup (fun χ : ι → K ↦ ⨅ i, (f i).maxGenEigenspace (χ i)) χ\n  · replace hy : ∀ φ, finrank K ((f i).maxGenEigenspace φ) < n := fun φ ↦ by\n      simp_rw [not_exists, ← lt_top_iff_ne_top] at hy; exact h_dim ▸ Submodule.finrank_lt (hy φ)\n    have hi (j : ι) (φ : K) :\n        MapsTo (f j) ((f i).maxGenEigenspace φ) ((f i).maxGenEigenspace φ) := by\n      exact h j i φ\n    replace ih (φ : K) :\n        ⨆ χ : ι → K, ⨅ j, maxGenEigenspace ((f j).restrict (hi j φ)) (χ j) = ⊤ := by\n      apply ih _ (hy φ)\n      · intro j k μ\n        exact mapsTo_restrict_maxGenEigenspace_restrict_of_mapsTo (f j) (f k) _ _ (h j k μ)\n      · exact fun j ↦ Module.End.genEigenspace_restrict_eq_top _ (h' j)\n      · rfl\n    replace ih (φ : K) :\n        ⨆ (χ : ι → K) (_ : χ i = φ), ⨅ j, maxGenEigenspace ((f j).restrict (hi j φ)) (χ j) = ⊤ := by\n      suffices ∀ χ : ι → K, χ i ≠ φ → ⨅ j, maxGenEigenspace ((f j).restrict (hi j φ)) (χ j) = ⊥ by\n        specialize ih φ; rw [iSup_split, biSup_congr this] at ih; simpa using ih\n      intro χ hχ\n      rw [eq_bot_iff, ← ((f i).maxGenEigenspace φ).ker_subtype, LinearMap.ker,\n        ← Submodule.map_le_iff_le_comap, ← Submodule.inf_iInf_maxGenEigenspace_of_forall_mapsTo,\n        ← disjoint_iff_inf_le]\n      exact ((f i).disjoint_genEigenspace hχ.symm _ _).mono_right (iInf_le _ i)\n    replace ih (φ : K) :\n        ⨆ (χ : ι → K) (_ : χ i = φ), ⨅ j, maxGenEigenspace (f j) (χ j) =\n        maxGenEigenspace (f i) φ := by\n      have (χ : ι → K) (hχ : χ i = φ) : ⨅ j, maxGenEigenspace (f j) (χ j) =\n          (⨅ j, maxGenEigenspace ((f j).restrict (hi j φ)) (χ j)).map\n            ((f i).maxGenEigenspace φ).subtype := by\n        rw [← hχ, iInf_maxGenEigenspace_restrict_map_subtype_eq]\n      simp_rw [biSup_congr this, ← Submodule.map_iSup, ih, Submodule.map_top,\n        Submodule.range_subtype]\n    simpa only [← ih, iSup_comm (ι := K), iSup_iSup_eq_right] using h' i\n\n"}
{"name":"Module.End.iSup_iInf_maxGenEigenspace_eq_top_of_iSup_maxGenEigenspace_eq_top_of_commute","module":"Mathlib.LinearAlgebra.Eigenspace.Pi","initialProofState":"ι : Type u_1\nK : Type u_3\nM : Type u_4\ninst✝³ : Field K\ninst✝² : AddCommGroup M\ninst✝¹ : Module K M\ninst✝ : FiniteDimensional K M\nf : ι → Module.End K M\nh : Pairwise fun i j => Commute (f i) (f j)\nh' : ∀ (i : ι), Eq (iSup fun μ => (f i).maxGenEigenspace μ) Top.top\n⊢ Eq (iSup fun χ => iInf fun i => (f i).maxGenEigenspace (χ i)) Top.top","decl":"/-- A commuting family of triangularizable endomorphisms is simultaneously triangularizable. -/\ntheorem iSup_iInf_maxGenEigenspace_eq_top_of_iSup_maxGenEigenspace_eq_top_of_commute\n    [FiniteDimensional K M] (f : ι → Module.End K M) (h : Pairwise fun i j ↦ Commute (f i) (f j))\n    (h' : ∀ i, ⨆ μ, (f i).maxGenEigenspace μ = ⊤) :\n    ⨆ χ : ι → K, ⨅ i, (f i).maxGenEigenspace (χ i) = ⊤ := by\n  refine Module.End.iSup_iInf_maxGenEigenspace_eq_top_of_forall_mapsTo _\n    (fun i j ↦ Module.End.mapsTo_maxGenEigenspace_of_comm ?_) h'\n  rcases eq_or_ne j i with rfl | hij <;> tauto\n\n"}
