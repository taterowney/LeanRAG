{"name":"ContinuousSMul.of_nhds_zero","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninstâœâ¶ : Ring R\ninstâœâµ : TopologicalSpace R\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : TopologicalRing R\ninstâœ : TopologicalAddGroup M\nhmul : Filter.Tendsto (fun p => HSMul.hSMul p.1 p.2) (SProd.sprod (nhds 0) (nhds 0)) (nhds 0)\nhmulleft : âˆ€ (m : M), Filter.Tendsto (fun a => HSMul.hSMul a m) (nhds 0) (nhds 0)\nhmulright : âˆ€ (a : R), Filter.Tendsto (fun m => HSMul.hSMul a m) (nhds 0) (nhds 0)\nâŠ¢ ContinuousSMul R M","decl":"theorem ContinuousSMul.of_nhds_zero [TopologicalRing R] [TopologicalAddGroup M]\n    (hmul : Tendsto (fun p : R Ã— M => p.1 â€¢ p.2) (ğ“ 0 Ã—Ë¢ ğ“ 0) (ğ“ 0))\n    (hmulleft : âˆ€ m : M, Tendsto (fun a : R => a â€¢ m) (ğ“ 0) (ğ“ 0))\n    (hmulright : âˆ€ a : R, Tendsto (fun m : M => a â€¢ m) (ğ“ 0) (ğ“ 0)) : ContinuousSMul R M where\n  continuous_smul := by\n    rw [â† nhds_prod_eq] at hmul\n    refine continuous_of_continuousAt_zeroâ‚‚ (AddMonoidHom.smul : R â†’+ M â†’+ M) ?_ ?_ ?_ <;>\n      simpa [ContinuousAt]\n\n"}
{"name":"Submodule.eq_top_of_nonempty_interior'","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninstâœâ· : Ring R\ninstâœâ¶ : TopologicalSpace R\ninstâœâµ : TopologicalSpace M\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : ContinuousAdd M\ninstâœÂ² : Module R M\ninstâœÂ¹ : ContinuousSMul R M\ninstâœ : (nhdsWithin 0 (setOf fun x => IsUnit x)).NeBot\ns : Submodule R M\nhs : (interior â†‘s).Nonempty\nâŠ¢ Eq s Top.top","decl":"/-- If `M` is a topological module over `R` and `0` is a limit of invertible elements of `R`, then\n`âŠ¤` is the only submodule of `M` with a nonempty interior.\nThis is the case, e.g., if `R` is a nontrivially normed field. -/\ntheorem Submodule.eq_top_of_nonempty_interior' [NeBot (ğ“[{ x : R | IsUnit x }] 0)]\n    (s : Submodule R M) (hs : (interior (s : Set M)).Nonempty) : s = âŠ¤ := by\n  rcases hs with âŸ¨y, hyâŸ©\n  refine Submodule.eq_top_iff'.2 fun x => ?_\n  rw [mem_interior_iff_mem_nhds] at hy\n  have : Tendsto (fun c : R => y + c â€¢ x) (ğ“[{ x : R | IsUnit x }] 0) (ğ“ (y + (0 : R) â€¢ x)) :=\n    tendsto_const_nhds.add ((tendsto_nhdsWithin_of_tendsto_nhds tendsto_id).smul tendsto_const_nhds)\n  rw [zero_smul, add_zero] at this\n  obtain âŸ¨_, hu : y + _ â€¢ _ âˆˆ s, u, rflâŸ© :=\n    nonempty_of_mem (inter_mem (Filter.mem_map.1 (this hy)) self_mem_nhdsWithin)\n  have hy' : y âˆˆ â†‘s := mem_of_mem_nhds hy\n  rwa [s.add_mem_iff_right hy', â† Units.smul_def, s.smul_mem_iff' u] at hu\n\n"}
{"name":"Module.punctured_nhds_neBot","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninstâœâ¹ : Ring R\ninstâœâ¸ : TopologicalSpace R\ninstâœâ· : TopologicalSpace M\ninstâœâ¶ : AddCommGroup M\ninstâœâµ : ContinuousAdd M\ninstâœâ´ : Module R M\ninstâœÂ³ : ContinuousSMul R M\ninstâœÂ² : Nontrivial M\ninstâœÂ¹ : (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))).NeBot\ninstâœ : NoZeroSMulDivisors R M\nx : M\nâŠ¢ (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).NeBot","decl":"/-- Let `R` be a topological ring such that zero is not an isolated point (e.g., a nontrivially\nnormed field, see `NormedField.punctured_nhds_neBot`). Let `M` be a nontrivial module over `R`\nsuch that `c â€¢ x = 0` implies `c = 0 âˆ¨ x = 0`. Then `M` has no isolated points. We formulate this\nusing `NeBot (ğ“[â‰ ] x)`.\n\nThis lemma is not an instance because Lean would need to find `[ContinuousSMul ?m_1 M]` with\nunknown `?m_1`. We register this as an instance for `R = â„` in `Real.punctured_nhds_module_neBot`.\nOne can also use `haveI := Module.punctured_nhds_neBot R M` in a proof.\n-/\ntheorem Module.punctured_nhds_neBot [Nontrivial M] [NeBot (ğ“[â‰ ] (0 : R))] [NoZeroSMulDivisors R M]\n    (x : M) : NeBot (ğ“[â‰ ] x) := by\n  rcases exists_ne (0 : M) with âŸ¨y, hyâŸ©\n  suffices Tendsto (fun c : R => x + c â€¢ y) (ğ“[â‰ ] 0) (ğ“[â‰ ] x) from this.neBot\n  refine Tendsto.inf ?_ (tendsto_principal_principal.2 <| ?_)\n  Â· convert tendsto_const_nhds.add ((@tendsto_id R _).smul_const y)\n    rw [zero_smul, add_zero]\n  Â· intro c hc\n    simpa [hy] using hc\n\n"}
{"name":"continuousSMul_induced","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u_1\nMâ‚ : Type u_2\nMâ‚‚ : Type u_3\ninstâœâ´ : SMul R Mâ‚\ninstâœÂ³ : SMul R Mâ‚‚\nu : TopologicalSpace R\nt : TopologicalSpace Mâ‚‚\ninstâœÂ² : ContinuousSMul R Mâ‚‚\nF : Type u_4\ninstâœÂ¹ : FunLike F Mâ‚ Mâ‚‚\ninstâœ : MulActionHomClass F R Mâ‚ Mâ‚‚\nf : F\nâŠ¢ ContinuousSMul R Mâ‚","decl":"theorem continuousSMul_induced : @ContinuousSMul R Mâ‚ _ u (t.induced f) :=\n  let _ : TopologicalSpace Mâ‚ := t.induced f\n  IsInducing.continuousSMul âŸ¨rflâŸ© continuous_id (map_smul f _ _)\n\n"}
{"name":"TopologicalSpace.IsSeparable.span","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninstâœâ· : AddCommMonoid M\ninstâœâ¶ : Semiring R\ninstâœâµ : Module R M\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : TopologicalSpace R\ninstâœÂ² : TopologicalSpace.SeparableSpace R\ninstâœÂ¹ : ContinuousAdd M\ninstâœ : ContinuousSMul R M\ns : Set M\nhs : TopologicalSpace.IsSeparable s\nâŠ¢ TopologicalSpace.IsSeparable â†‘(Submodule.span R s)","decl":"/-- The span of a separable subset with respect to a separable scalar ring is again separable. -/\nlemma TopologicalSpace.IsSeparable.span {R M : Type*} [AddCommMonoid M] [Semiring R] [Module R M]\n    [TopologicalSpace M] [TopologicalSpace R] [SeparableSpace R]\n    [ContinuousAdd M] [ContinuousSMul R M] {s : Set M} (hs : IsSeparable s) :\n    IsSeparable (Submodule.span R s : Set M) := by\n  rw [span_eq_iUnion_nat]\n  refine .iUnion fun n â†¦ .image ?_ ?_\n  Â· have : IsSeparable {f : Fin n â†’ R Ã— M | âˆ€ (i : Fin n), f i âˆˆ Set.univ Ã—Ë¢ s} := by\n      apply isSeparable_pi (fun i â†¦ .prod (.of_separableSpace Set.univ) hs)\n    rwa [Set.univ_prod] at this\n  Â· apply continuous_finset_sum _ (fun i _ â†¦ ?_)\n    exact (continuous_fst.comp (continuous_apply i)).smul (continuous_snd.comp (continuous_apply i))\n\n"}
{"name":"Submodule.topologicalAddGroup","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : TopologicalSpace Î²\ninstâœÂ³ : Ring Î±\ninstâœÂ² : AddCommGroup Î²\ninstâœÂ¹ : Module Î± Î²\ninstâœ : TopologicalAddGroup Î²\nS : Submodule Î± Î²\nâŠ¢ TopologicalAddGroup (Subtype fun x => Membership.mem S x)","decl":"instance topologicalAddGroup [Ring Î±] [AddCommGroup Î²] [Module Î± Î²] [TopologicalAddGroup Î²]\n    (S : Submodule Î± Î²) : TopologicalAddGroup S :=\n  inferInstanceAs (TopologicalAddGroup S.toAddSubgroup)\n\n"}
{"name":"Submodule.mapsTo_smul_closure","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœâ´ : Semiring R\ninstâœÂ³ : TopologicalSpace M\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module R M\ninstâœ : ContinuousConstSMul R M\ns : Submodule R M\nc : R\nâŠ¢ Set.MapsTo (fun x => HSMul.hSMul c x) (closure â†‘s) (closure â†‘s)","decl":"theorem Submodule.mapsTo_smul_closure (s : Submodule R M) (c : R) :\n    Set.MapsTo (c â€¢ Â·) (closure s : Set M) (closure s) :=\n  have : Set.MapsTo (c â€¢ Â·) (s : Set M) s := fun _ h â†¦ s.smul_mem c h\n  this.closure (continuous_const_smul c)\n\n"}
{"name":"Submodule.smul_closure_subset","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœâ´ : Semiring R\ninstâœÂ³ : TopologicalSpace M\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module R M\ninstâœ : ContinuousConstSMul R M\ns : Submodule R M\nc : R\nâŠ¢ HasSubset.Subset (HSMul.hSMul c (closure â†‘s)) (closure â†‘s)","decl":"theorem Submodule.smul_closure_subset (s : Submodule R M) (c : R) :\n    c â€¢ closure (s : Set M) âŠ† closure (s : Set M) :=\n  (s.mapsTo_smul_closure c).image_subset\n\n"}
{"name":"Submodule.topologicalClosure_coe","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœâµ : Semiring R\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\ninstâœÂ¹ : ContinuousConstSMul R M\ninstâœ : ContinuousAdd M\ns : Submodule R M\nâŠ¢ Eq (â†‘s.topologicalClosure) (closure â†‘s)","decl":"@[simp]\ntheorem Submodule.topologicalClosure_coe (s : Submodule R M) :\n    (s.topologicalClosure : Set M) = closure (s : Set M) :=\n  rfl\n\n"}
{"name":"Submodule.le_topologicalClosure","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœâµ : Semiring R\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\ninstâœÂ¹ : ContinuousConstSMul R M\ninstâœ : ContinuousAdd M\ns : Submodule R M\nâŠ¢ LE.le s s.topologicalClosure","decl":"theorem Submodule.le_topologicalClosure (s : Submodule R M) : s â‰¤ s.topologicalClosure :=\n  subset_closure\n\n"}
{"name":"Submodule.closure_subset_topologicalClosure_span","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœâµ : Semiring R\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\ninstâœÂ¹ : ContinuousConstSMul R M\ninstâœ : ContinuousAdd M\ns : Set M\nâŠ¢ HasSubset.Subset (closure s) â†‘(Submodule.span R s).topologicalClosure","decl":"theorem Submodule.closure_subset_topologicalClosure_span (s : Set M) :\n    closure s âŠ† (span R s).topologicalClosure := by\n  rw [Submodule.topologicalClosure_coe]\n  exact closure_mono subset_span\n\n"}
{"name":"Submodule.isClosed_topologicalClosure","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœâµ : Semiring R\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\ninstâœÂ¹ : ContinuousConstSMul R M\ninstâœ : ContinuousAdd M\ns : Submodule R M\nâŠ¢ IsClosed â†‘s.topologicalClosure","decl":"theorem Submodule.isClosed_topologicalClosure (s : Submodule R M) :\n    IsClosed (s.topologicalClosure : Set M) := isClosed_closure\n\n"}
{"name":"Submodule.topologicalClosure_minimal","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœâµ : Semiring R\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\ninstâœÂ¹ : ContinuousConstSMul R M\ninstâœ : ContinuousAdd M\ns t : Submodule R M\nh : LE.le s t\nht : IsClosed â†‘t\nâŠ¢ LE.le s.topologicalClosure t","decl":"theorem Submodule.topologicalClosure_minimal (s : Submodule R M) {t : Submodule R M} (h : s â‰¤ t)\n    (ht : IsClosed (t : Set M)) : s.topologicalClosure â‰¤ t :=\n  closure_minimal h ht\n\n"}
{"name":"Submodule.topologicalClosure_mono","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœâµ : Semiring R\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\ninstâœÂ¹ : ContinuousConstSMul R M\ninstâœ : ContinuousAdd M\ns t : Submodule R M\nh : LE.le s t\nâŠ¢ LE.le s.topologicalClosure t.topologicalClosure","decl":"theorem Submodule.topologicalClosure_mono {s : Submodule R M} {t : Submodule R M} (h : s â‰¤ t) :\n    s.topologicalClosure â‰¤ t.topologicalClosure :=\n  closure_mono h\n\n"}
{"name":"IsClosed.submodule_topologicalClosure_eq","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœâµ : Semiring R\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\ninstâœÂ¹ : ContinuousConstSMul R M\ninstâœ : ContinuousAdd M\ns : Submodule R M\nhs : IsClosed â†‘s\nâŠ¢ Eq s.topologicalClosure s","decl":"/-- The topological closure of a closed submodule `s` is equal to `s`. -/\ntheorem IsClosed.submodule_topologicalClosure_eq {s : Submodule R M} (hs : IsClosed (s : Set M)) :\n    s.topologicalClosure = s :=\n  SetLike.ext' hs.closure_eq\n\n"}
{"name":"Submodule.dense_iff_topologicalClosure_eq_top","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœâµ : Semiring R\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\ninstâœÂ¹ : ContinuousConstSMul R M\ninstâœ : ContinuousAdd M\ns : Submodule R M\nâŠ¢ Iff (Dense â†‘s) (Eq s.topologicalClosure Top.top)","decl":"/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem Submodule.dense_iff_topologicalClosure_eq_top {s : Submodule R M} :\n    Dense (s : Set M) â†” s.topologicalClosure = âŠ¤ := by\n  rw [â† SetLike.coe_set_eq, dense_iff_closure_eq]\n  simp\n\n"}
{"name":"Submodule.topologicalClosure.completeSpace","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\ninstâœâ¶ : Semiring R\nM' : Type u_1\ninstâœâµ : AddCommMonoid M'\ninstâœâ´ : Module R M'\ninstâœÂ³ : UniformSpace M'\ninstâœÂ² : ContinuousAdd M'\ninstâœÂ¹ : ContinuousConstSMul R M'\ninstâœ : CompleteSpace M'\nU : Submodule R M'\nâŠ¢ CompleteSpace (Subtype fun x => Membership.mem U.topologicalClosure x)","decl":"instance Submodule.topologicalClosure.completeSpace {M' : Type*} [AddCommMonoid M'] [Module R M']\n    [UniformSpace M'] [ContinuousAdd M'] [ContinuousConstSMul R M'] [CompleteSpace M']\n    (U : Submodule R M') : CompleteSpace U.topologicalClosure :=\n  isClosed_closure.completeSpace_coe\n\n"}
{"name":"Submodule.isClosed_or_dense_of_isCoatom","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœâµ : Semiring R\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\ninstâœÂ¹ : ContinuousConstSMul R M\ninstâœ : ContinuousAdd M\ns : Submodule R M\nhs : IsCoatom s\nâŠ¢ Or (IsClosed â†‘s) (Dense â†‘s)","decl":"/-- A maximal proper subspace of a topological module (i.e a `Submodule` satisfying `IsCoatom`)\nis either closed or dense. -/\ntheorem Submodule.isClosed_or_dense_of_isCoatom (s : Submodule R M) (hs : IsCoatom s) :\n    IsClosed (s : Set M) âˆ¨ Dense (s : Set M) := by\n  refine (hs.le_iff.mp s.le_topologicalClosure).symm.imp ?_ dense_iff_topologicalClosure_eq_top.mpr\n  exact fun h â†¦ h â–¸ isClosed_closure\n\n"}
{"name":"LinearMap.continuous_on_pi","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"Î¹ : Type u_1\nR : Type u_2\nM : Type u_3\ninstâœâ· : Finite Î¹\ninstâœâ¶ : Semiring R\ninstâœâµ : TopologicalSpace R\ninstâœâ´ : AddCommMonoid M\ninstâœÂ³ : Module R M\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ContinuousAdd M\ninstâœ : ContinuousSMul R M\nf : LinearMap (RingHom.id R) (Î¹ â†’ R) M\nâŠ¢ Continuous â‡‘f","decl":"theorem LinearMap.continuous_on_pi {Î¹ : Type*} {R : Type*} {M : Type*} [Finite Î¹] [Semiring R]\n    [TopologicalSpace R] [AddCommMonoid M] [Module R M] [TopologicalSpace M] [ContinuousAdd M]\n    [ContinuousSMul R M] (f : (Î¹ â†’ R) â†’â‚—[R] M) : Continuous f := by\n  cases nonempty_fintype Î¹\n  classical\n    -- for the proof, write `f` in the standard basis, and use that each coordinate is a continuous\n    -- function.\n    have : (f : (Î¹ â†’ R) â†’ M) = fun x => âˆ‘ i : Î¹, x i â€¢ f fun j => if i = j then 1 else 0 := by\n      ext x\n      exact f.pi_apply_eq_sum_univ x\n    rw [this]\n    refine continuous_finset_sum _ fun i _ => ?_\n    exact (continuous_apply i).smul continuous_const\n\n"}
{"name":"linearMapOfMemClosureRangeCoe_apply","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"Mâ‚ : Type u_1\nMâ‚‚ : Type u_2\nR : Type u_4\nS : Type u_5\ninstâœâ¹ : TopologicalSpace Mâ‚‚\ninstâœâ¸ : T2Space Mâ‚‚\ninstâœâ· : Semiring R\ninstâœâ¶ : Semiring S\ninstâœâµ : AddCommMonoid Mâ‚\ninstâœâ´ : AddCommMonoid Mâ‚‚\ninstâœÂ³ : Module R Mâ‚\ninstâœÂ² : Module S Mâ‚‚\ninstâœÂ¹ : ContinuousConstSMul S Mâ‚‚\ninstâœ : ContinuousAdd Mâ‚‚\nÏƒ : RingHom R S\nf : Mâ‚ â†’ Mâ‚‚\nhf : Membership.mem (closure (Set.range DFunLike.coe)) f\nâŠ¢ Eq (â‡‘(linearMapOfMemClosureRangeCoe f hf)) (â†‘(addMonoidHomOfMemClosureRangeCoe f hf)).toFun","decl":"/-- Constructs a bundled linear map from a function and a proof that this function belongs to the\nclosure of the set of linear maps. -/\n@[simps (config := .asFn)]\ndef linearMapOfMemClosureRangeCoe (f : Mâ‚ â†’ Mâ‚‚)\n    (hf : f âˆˆ closure (Set.range ((â†‘) : (Mâ‚ â†’â‚›â‚—[Ïƒ] Mâ‚‚) â†’ Mâ‚ â†’ Mâ‚‚))) : Mâ‚ â†’â‚›â‚—[Ïƒ] Mâ‚‚ :=\n  { addMonoidHomOfMemClosureRangeCoe f hf with\n    map_smul' := (isClosed_setOf_map_smul Mâ‚ Mâ‚‚ Ïƒ).closure_subset_iff.2\n      (Set.range_subset_iff.2 LinearMap.map_smulâ‚›â‚—) hf }\n\n"}
{"name":"linearMapOfTendsto_apply","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"Mâ‚ : Type u_1\nMâ‚‚ : Type u_2\nÎ± : Type u_3\nR : Type u_4\nS : Type u_5\ninstâœÂ¹â° : TopologicalSpace Mâ‚‚\ninstâœâ¹ : T2Space Mâ‚‚\ninstâœâ¸ : Semiring R\ninstâœâ· : Semiring S\ninstâœâ¶ : AddCommMonoid Mâ‚\ninstâœâµ : AddCommMonoid Mâ‚‚\ninstâœâ´ : Module R Mâ‚\ninstâœÂ³ : Module S Mâ‚‚\ninstâœÂ² : ContinuousConstSMul S Mâ‚‚\ninstâœÂ¹ : ContinuousAdd Mâ‚‚\nÏƒ : RingHom R S\nl : Filter Î±\nf : Mâ‚ â†’ Mâ‚‚\ng : Î± â†’ LinearMap Ïƒ Mâ‚ Mâ‚‚\ninstâœ : l.NeBot\nh : Filter.Tendsto (fun a x => (g a) x) l (nhds f)\nâŠ¢ Eq (â‡‘(linearMapOfTendsto f g h)) f","decl":"/-- Construct a bundled linear map from a pointwise limit of linear maps -/\n@[simps! (config := .asFn)]\ndef linearMapOfTendsto (f : Mâ‚ â†’ Mâ‚‚) (g : Î± â†’ Mâ‚ â†’â‚›â‚—[Ïƒ] Mâ‚‚) [l.NeBot]\n    (h : Tendsto (fun a x => g a x) l (ğ“ f)) : Mâ‚ â†’â‚›â‚—[Ïƒ] Mâ‚‚ :=\n  linearMapOfMemClosureRangeCoe f <|\n    mem_closure_of_tendsto h <| Eventually.of_forall fun _ => Set.mem_range_self _\n\n"}
{"name":"LinearMap.isClosed_range_coe","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"Mâ‚ : Type u_1\nMâ‚‚ : Type u_2\nR : Type u_4\nS : Type u_5\ninstâœâ¹ : TopologicalSpace Mâ‚‚\ninstâœâ¸ : T2Space Mâ‚‚\ninstâœâ· : Semiring R\ninstâœâ¶ : Semiring S\ninstâœâµ : AddCommMonoid Mâ‚\ninstâœâ´ : AddCommMonoid Mâ‚‚\ninstâœÂ³ : Module R Mâ‚\ninstâœÂ² : Module S Mâ‚‚\ninstâœÂ¹ : ContinuousConstSMul S Mâ‚‚\ninstâœ : ContinuousAdd Mâ‚‚\nÏƒ : RingHom R S\nâŠ¢ IsClosed (Set.range DFunLike.coe)","decl":"theorem LinearMap.isClosed_range_coe : IsClosed (Set.range ((â†‘) : (Mâ‚ â†’â‚›â‚—[Ïƒ] Mâ‚‚) â†’ Mâ‚ â†’ Mâ‚‚)) :=\n  isClosed_of_closure_subset fun f hf => âŸ¨linearMapOfMemClosureRangeCoe f hf, rflâŸ©\n\n"}
{"name":"Submodule.isOpenMap_mkQ","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninstâœâ´ : Ring R\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : TopologicalSpace M\nS : Submodule R M\ninstâœ : ContinuousAdd M\nâŠ¢ IsOpenMap â‡‘S.mkQ","decl":"theorem isOpenMap_mkQ [ContinuousAdd M] : IsOpenMap S.mkQ :=\n  QuotientAddGroup.isOpenMap_coe\n\n"}
{"name":"Submodule.isOpenQuotientMap_mkQ","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninstâœâ´ : Ring R\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : TopologicalSpace M\nS : Submodule R M\ninstâœ : ContinuousAdd M\nâŠ¢ IsOpenQuotientMap â‡‘S.mkQ","decl":"theorem isOpenQuotientMap_mkQ [ContinuousAdd M] : IsOpenQuotientMap S.mkQ :=\n  QuotientAddGroup.isOpenQuotientMap_mk\n\n"}
{"name":"Submodule.topologicalAddGroup_quotient","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninstâœâ´ : Ring R\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : TopologicalSpace M\nS : Submodule R M\ninstâœ : TopologicalAddGroup M\nâŠ¢ TopologicalAddGroup (HasQuotient.Quotient M S)","decl":"instance topologicalAddGroup_quotient [TopologicalAddGroup M] : TopologicalAddGroup (M â§¸ S) :=\n  inferInstanceAs <| TopologicalAddGroup (M â§¸ S.toAddSubgroup)\n\n"}
{"name":"Submodule.continuousSMul_quotient","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninstâœâ¶ : Ring R\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : TopologicalSpace M\nS : Submodule R M\ninstâœÂ² : TopologicalSpace R\ninstâœÂ¹ : TopologicalAddGroup M\ninstâœ : ContinuousSMul R M\nâŠ¢ ContinuousSMul R (HasQuotient.Quotient M S)","decl":"instance continuousSMul_quotient [TopologicalSpace R] [TopologicalAddGroup M] [ContinuousSMul R M] :\n    ContinuousSMul R (M â§¸ S) where\n  continuous_smul := by\n    rw [â† (IsOpenQuotientMap.id.prodMap S.isOpenQuotientMap_mkQ).continuous_comp_iff]\n    exact continuous_quot_mk.comp continuous_smul\n\n"}
{"name":"Submodule.t3_quotient_of_isClosed","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninstâœâµ : Ring R\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : TopologicalSpace M\nS : Submodule R M\ninstâœÂ¹ : TopologicalAddGroup M\ninstâœ : IsClosed â†‘S\nâŠ¢ T3Space (HasQuotient.Quotient M S)","decl":"instance t3_quotient_of_isClosed [TopologicalAddGroup M] [IsClosed (S : Set M)] :\n    T3Space (M â§¸ S) :=\n  letI : IsClosed (S.toAddSubgroup : Set M) := â€¹_â€º\n  QuotientAddGroup.instT3Space S.toAddSubgroup\n\n"}
