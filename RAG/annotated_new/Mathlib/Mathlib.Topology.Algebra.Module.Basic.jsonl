{"name":"ContinuousSMul.of_nhds_zero","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁶ : Ring R\ninst✝⁵ : TopologicalSpace R\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : TopologicalRing R\ninst✝ : TopologicalAddGroup M\nhmul : Filter.Tendsto (fun p => HSMul.hSMul p.1 p.2) (SProd.sprod (nhds 0) (nhds 0)) (nhds 0)\nhmulleft : ∀ (m : M), Filter.Tendsto (fun a => HSMul.hSMul a m) (nhds 0) (nhds 0)\nhmulright : ∀ (a : R), Filter.Tendsto (fun m => HSMul.hSMul a m) (nhds 0) (nhds 0)\n⊢ ContinuousSMul R M","decl":"theorem ContinuousSMul.of_nhds_zero [TopologicalRing R] [TopologicalAddGroup M]\n    (hmul : Tendsto (fun p : R × M => p.1 • p.2) (𝓝 0 ×ˢ 𝓝 0) (𝓝 0))\n    (hmulleft : ∀ m : M, Tendsto (fun a : R => a • m) (𝓝 0) (𝓝 0))\n    (hmulright : ∀ a : R, Tendsto (fun m : M => a • m) (𝓝 0) (𝓝 0)) : ContinuousSMul R M where\n  continuous_smul := by\n    rw [← nhds_prod_eq] at hmul\n    refine continuous_of_continuousAt_zero₂ (AddMonoidHom.smul : R →+ M →+ M) ?_ ?_ ?_ <;>\n      simpa [ContinuousAt]\n\n"}
{"name":"Submodule.eq_top_of_nonempty_interior'","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁷ : Ring R\ninst✝⁶ : TopologicalSpace R\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : AddCommGroup M\ninst✝³ : ContinuousAdd M\ninst✝² : Module R M\ninst✝¹ : ContinuousSMul R M\ninst✝ : (nhdsWithin 0 (setOf fun x => IsUnit x)).NeBot\ns : Submodule R M\nhs : (interior ↑s).Nonempty\n⊢ Eq s Top.top","decl":"/-- If `M` is a topological module over `R` and `0` is a limit of invertible elements of `R`, then\n`⊤` is the only submodule of `M` with a nonempty interior.\nThis is the case, e.g., if `R` is a nontrivially normed field. -/\ntheorem Submodule.eq_top_of_nonempty_interior' [NeBot (𝓝[{ x : R | IsUnit x }] 0)]\n    (s : Submodule R M) (hs : (interior (s : Set M)).Nonempty) : s = ⊤ := by\n  rcases hs with ⟨y, hy⟩\n  refine Submodule.eq_top_iff'.2 fun x => ?_\n  rw [mem_interior_iff_mem_nhds] at hy\n  have : Tendsto (fun c : R => y + c • x) (𝓝[{ x : R | IsUnit x }] 0) (𝓝 (y + (0 : R) • x)) :=\n    tendsto_const_nhds.add ((tendsto_nhdsWithin_of_tendsto_nhds tendsto_id).smul tendsto_const_nhds)\n  rw [zero_smul, add_zero] at this\n  obtain ⟨_, hu : y + _ • _ ∈ s, u, rfl⟩ :=\n    nonempty_of_mem (inter_mem (Filter.mem_map.1 (this hy)) self_mem_nhdsWithin)\n  have hy' : y ∈ ↑s := mem_of_mem_nhds hy\n  rwa [s.add_mem_iff_right hy', ← Units.smul_def, s.smul_mem_iff' u] at hu\n\n"}
{"name":"Module.punctured_nhds_neBot","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁹ : Ring R\ninst✝⁸ : TopologicalSpace R\ninst✝⁷ : TopologicalSpace M\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : ContinuousAdd M\ninst✝⁴ : Module R M\ninst✝³ : ContinuousSMul R M\ninst✝² : Nontrivial M\ninst✝¹ : (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))).NeBot\ninst✝ : NoZeroSMulDivisors R M\nx : M\n⊢ (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).NeBot","decl":"/-- Let `R` be a topological ring such that zero is not an isolated point (e.g., a nontrivially\nnormed field, see `NormedField.punctured_nhds_neBot`). Let `M` be a nontrivial module over `R`\nsuch that `c • x = 0` implies `c = 0 ∨ x = 0`. Then `M` has no isolated points. We formulate this\nusing `NeBot (𝓝[≠] x)`.\n\nThis lemma is not an instance because Lean would need to find `[ContinuousSMul ?m_1 M]` with\nunknown `?m_1`. We register this as an instance for `R = ℝ` in `Real.punctured_nhds_module_neBot`.\nOne can also use `haveI := Module.punctured_nhds_neBot R M` in a proof.\n-/\ntheorem Module.punctured_nhds_neBot [Nontrivial M] [NeBot (𝓝[≠] (0 : R))] [NoZeroSMulDivisors R M]\n    (x : M) : NeBot (𝓝[≠] x) := by\n  rcases exists_ne (0 : M) with ⟨y, hy⟩\n  suffices Tendsto (fun c : R => x + c • y) (𝓝[≠] 0) (𝓝[≠] x) from this.neBot\n  refine Tendsto.inf ?_ (tendsto_principal_principal.2 <| ?_)\n  · convert tendsto_const_nhds.add ((@tendsto_id R _).smul_const y)\n    rw [zero_smul, add_zero]\n  · intro c hc\n    simpa [hy] using hc\n\n"}
{"name":"continuousSMul_induced","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\ninst✝⁴ : SMul R M₁\ninst✝³ : SMul R M₂\nu : TopologicalSpace R\nt : TopologicalSpace M₂\ninst✝² : ContinuousSMul R M₂\nF : Type u_4\ninst✝¹ : FunLike F M₁ M₂\ninst✝ : MulActionHomClass F R M₁ M₂\nf : F\n⊢ ContinuousSMul R M₁","decl":"theorem continuousSMul_induced : @ContinuousSMul R M₁ _ u (t.induced f) :=\n  let _ : TopologicalSpace M₁ := t.induced f\n  IsInducing.continuousSMul ⟨rfl⟩ continuous_id (map_smul f _ _)\n\n"}
{"name":"TopologicalSpace.IsSeparable.span","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Semiring R\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : TopologicalSpace R\ninst✝² : TopologicalSpace.SeparableSpace R\ninst✝¹ : ContinuousAdd M\ninst✝ : ContinuousSMul R M\ns : Set M\nhs : TopologicalSpace.IsSeparable s\n⊢ TopologicalSpace.IsSeparable ↑(Submodule.span R s)","decl":"/-- The span of a separable subset with respect to a separable scalar ring is again separable. -/\nlemma TopologicalSpace.IsSeparable.span {R M : Type*} [AddCommMonoid M] [Semiring R] [Module R M]\n    [TopologicalSpace M] [TopologicalSpace R] [SeparableSpace R]\n    [ContinuousAdd M] [ContinuousSMul R M] {s : Set M} (hs : IsSeparable s) :\n    IsSeparable (Submodule.span R s : Set M) := by\n  rw [span_eq_iUnion_nat]\n  refine .iUnion fun n ↦ .image ?_ ?_\n  · have : IsSeparable {f : Fin n → R × M | ∀ (i : Fin n), f i ∈ Set.univ ×ˢ s} := by\n      apply isSeparable_pi (fun i ↦ .prod (.of_separableSpace Set.univ) hs)\n    rwa [Set.univ_prod] at this\n  · apply continuous_finset_sum _ (fun i _ ↦ ?_)\n    exact (continuous_fst.comp (continuous_apply i)).smul (continuous_snd.comp (continuous_apply i))\n\n"}
{"name":"Submodule.topologicalAddGroup","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : TopologicalSpace β\ninst✝³ : Ring α\ninst✝² : AddCommGroup β\ninst✝¹ : Module α β\ninst✝ : TopologicalAddGroup β\nS : Submodule α β\n⊢ TopologicalAddGroup (Subtype fun x => Membership.mem S x)","decl":"instance topologicalAddGroup [Ring α] [AddCommGroup β] [Module α β] [TopologicalAddGroup β]\n    (S : Submodule α β) : TopologicalAddGroup S :=\n  inferInstanceAs (TopologicalAddGroup S.toAddSubgroup)\n\n"}
{"name":"Submodule.mapsTo_smul_closure","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : ContinuousConstSMul R M\ns : Submodule R M\nc : R\n⊢ Set.MapsTo (fun x => HSMul.hSMul c x) (closure ↑s) (closure ↑s)","decl":"theorem Submodule.mapsTo_smul_closure (s : Submodule R M) (c : R) :\n    Set.MapsTo (c • ·) (closure s : Set M) (closure s) :=\n  have : Set.MapsTo (c • ·) (s : Set M) s := fun _ h ↦ s.smul_mem c h\n  this.closure (continuous_const_smul c)\n\n"}
{"name":"Submodule.smul_closure_subset","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : ContinuousConstSMul R M\ns : Submodule R M\nc : R\n⊢ HasSubset.Subset (HSMul.hSMul c (closure ↑s)) (closure ↑s)","decl":"theorem Submodule.smul_closure_subset (s : Submodule R M) (c : R) :\n    c • closure (s : Set M) ⊆ closure (s : Set M) :=\n  (s.mapsTo_smul_closure c).image_subset\n\n"}
{"name":"Submodule.topologicalClosure_coe","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : ContinuousConstSMul R M\ninst✝ : ContinuousAdd M\ns : Submodule R M\n⊢ Eq (↑s.topologicalClosure) (closure ↑s)","decl":"@[simp]\ntheorem Submodule.topologicalClosure_coe (s : Submodule R M) :\n    (s.topologicalClosure : Set M) = closure (s : Set M) :=\n  rfl\n\n"}
{"name":"Submodule.le_topologicalClosure","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : ContinuousConstSMul R M\ninst✝ : ContinuousAdd M\ns : Submodule R M\n⊢ LE.le s s.topologicalClosure","decl":"theorem Submodule.le_topologicalClosure (s : Submodule R M) : s ≤ s.topologicalClosure :=\n  subset_closure\n\n"}
{"name":"Submodule.closure_subset_topologicalClosure_span","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : ContinuousConstSMul R M\ninst✝ : ContinuousAdd M\ns : Set M\n⊢ HasSubset.Subset (closure s) ↑(Submodule.span R s).topologicalClosure","decl":"theorem Submodule.closure_subset_topologicalClosure_span (s : Set M) :\n    closure s ⊆ (span R s).topologicalClosure := by\n  rw [Submodule.topologicalClosure_coe]\n  exact closure_mono subset_span\n\n"}
{"name":"Submodule.isClosed_topologicalClosure","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : ContinuousConstSMul R M\ninst✝ : ContinuousAdd M\ns : Submodule R M\n⊢ IsClosed ↑s.topologicalClosure","decl":"theorem Submodule.isClosed_topologicalClosure (s : Submodule R M) :\n    IsClosed (s.topologicalClosure : Set M) := isClosed_closure\n\n"}
{"name":"Submodule.topologicalClosure_minimal","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : ContinuousConstSMul R M\ninst✝ : ContinuousAdd M\ns t : Submodule R M\nh : LE.le s t\nht : IsClosed ↑t\n⊢ LE.le s.topologicalClosure t","decl":"theorem Submodule.topologicalClosure_minimal (s : Submodule R M) {t : Submodule R M} (h : s ≤ t)\n    (ht : IsClosed (t : Set M)) : s.topologicalClosure ≤ t :=\n  closure_minimal h ht\n\n"}
{"name":"Submodule.topologicalClosure_mono","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : ContinuousConstSMul R M\ninst✝ : ContinuousAdd M\ns t : Submodule R M\nh : LE.le s t\n⊢ LE.le s.topologicalClosure t.topologicalClosure","decl":"theorem Submodule.topologicalClosure_mono {s : Submodule R M} {t : Submodule R M} (h : s ≤ t) :\n    s.topologicalClosure ≤ t.topologicalClosure :=\n  closure_mono h\n\n"}
{"name":"IsClosed.submodule_topologicalClosure_eq","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : ContinuousConstSMul R M\ninst✝ : ContinuousAdd M\ns : Submodule R M\nhs : IsClosed ↑s\n⊢ Eq s.topologicalClosure s","decl":"/-- The topological closure of a closed submodule `s` is equal to `s`. -/\ntheorem IsClosed.submodule_topologicalClosure_eq {s : Submodule R M} (hs : IsClosed (s : Set M)) :\n    s.topologicalClosure = s :=\n  SetLike.ext' hs.closure_eq\n\n"}
{"name":"Submodule.dense_iff_topologicalClosure_eq_top","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : ContinuousConstSMul R M\ninst✝ : ContinuousAdd M\ns : Submodule R M\n⊢ Iff (Dense ↑s) (Eq s.topologicalClosure Top.top)","decl":"/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem Submodule.dense_iff_topologicalClosure_eq_top {s : Submodule R M} :\n    Dense (s : Set M) ↔ s.topologicalClosure = ⊤ := by\n  rw [← SetLike.coe_set_eq, dense_iff_closure_eq]\n  simp\n\n"}
{"name":"Submodule.topologicalClosure.completeSpace","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\nM' : Type u_1\ninst✝⁵ : AddCommMonoid M'\ninst✝⁴ : Module R M'\ninst✝³ : UniformSpace M'\ninst✝² : ContinuousAdd M'\ninst✝¹ : ContinuousConstSMul R M'\ninst✝ : CompleteSpace M'\nU : Submodule R M'\n⊢ CompleteSpace (Subtype fun x => Membership.mem U.topologicalClosure x)","decl":"instance Submodule.topologicalClosure.completeSpace {M' : Type*} [AddCommMonoid M'] [Module R M']\n    [UniformSpace M'] [ContinuousAdd M'] [ContinuousConstSMul R M'] [CompleteSpace M']\n    (U : Submodule R M') : CompleteSpace U.topologicalClosure :=\n  isClosed_closure.completeSpace_coe\n\n"}
{"name":"Submodule.isClosed_or_dense_of_isCoatom","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : ContinuousConstSMul R M\ninst✝ : ContinuousAdd M\ns : Submodule R M\nhs : IsCoatom s\n⊢ Or (IsClosed ↑s) (Dense ↑s)","decl":"/-- A maximal proper subspace of a topological module (i.e a `Submodule` satisfying `IsCoatom`)\nis either closed or dense. -/\ntheorem Submodule.isClosed_or_dense_of_isCoatom (s : Submodule R M) (hs : IsCoatom s) :\n    IsClosed (s : Set M) ∨ Dense (s : Set M) := by\n  refine (hs.le_iff.mp s.le_topologicalClosure).symm.imp ?_ dense_iff_topologicalClosure_eq_top.mpr\n  exact fun h ↦ h ▸ isClosed_closure\n\n"}
{"name":"LinearMap.continuous_on_pi","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁷ : Finite ι\ninst✝⁶ : Semiring R\ninst✝⁵ : TopologicalSpace R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : TopologicalSpace M\ninst✝¹ : ContinuousAdd M\ninst✝ : ContinuousSMul R M\nf : LinearMap (RingHom.id R) (ι → R) M\n⊢ Continuous ⇑f","decl":"theorem LinearMap.continuous_on_pi {ι : Type*} {R : Type*} {M : Type*} [Finite ι] [Semiring R]\n    [TopologicalSpace R] [AddCommMonoid M] [Module R M] [TopologicalSpace M] [ContinuousAdd M]\n    [ContinuousSMul R M] (f : (ι → R) →ₗ[R] M) : Continuous f := by\n  cases nonempty_fintype ι\n  classical\n    -- for the proof, write `f` in the standard basis, and use that each coordinate is a continuous\n    -- function.\n    have : (f : (ι → R) → M) = fun x => ∑ i : ι, x i • f fun j => if i = j then 1 else 0 := by\n      ext x\n      exact f.pi_apply_eq_sum_univ x\n    rw [this]\n    refine continuous_finset_sum _ fun i _ => ?_\n    exact (continuous_apply i).smul continuous_const\n\n"}
{"name":"linearMapOfMemClosureRangeCoe_apply","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"M₁ : Type u_1\nM₂ : Type u_2\nR : Type u_4\nS : Type u_5\ninst✝⁹ : TopologicalSpace M₂\ninst✝⁸ : T2Space M₂\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₁\ninst✝² : Module S M₂\ninst✝¹ : ContinuousConstSMul S M₂\ninst✝ : ContinuousAdd M₂\nσ : RingHom R S\nf : M₁ → M₂\nhf : Membership.mem (closure (Set.range DFunLike.coe)) f\n⊢ Eq (⇑(linearMapOfMemClosureRangeCoe f hf)) (↑(addMonoidHomOfMemClosureRangeCoe f hf)).toFun","decl":"/-- Constructs a bundled linear map from a function and a proof that this function belongs to the\nclosure of the set of linear maps. -/\n@[simps (config := .asFn)]\ndef linearMapOfMemClosureRangeCoe (f : M₁ → M₂)\n    (hf : f ∈ closure (Set.range ((↑) : (M₁ →ₛₗ[σ] M₂) → M₁ → M₂))) : M₁ →ₛₗ[σ] M₂ :=\n  { addMonoidHomOfMemClosureRangeCoe f hf with\n    map_smul' := (isClosed_setOf_map_smul M₁ M₂ σ).closure_subset_iff.2\n      (Set.range_subset_iff.2 LinearMap.map_smulₛₗ) hf }\n\n"}
{"name":"linearMapOfTendsto_apply","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"M₁ : Type u_1\nM₂ : Type u_2\nα : Type u_3\nR : Type u_4\nS : Type u_5\ninst✝¹⁰ : TopologicalSpace M₂\ninst✝⁹ : T2Space M₂\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring S\ninst✝⁶ : AddCommMonoid M₁\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M₁\ninst✝³ : Module S M₂\ninst✝² : ContinuousConstSMul S M₂\ninst✝¹ : ContinuousAdd M₂\nσ : RingHom R S\nl : Filter α\nf : M₁ → M₂\ng : α → LinearMap σ M₁ M₂\ninst✝ : l.NeBot\nh : Filter.Tendsto (fun a x => (g a) x) l (nhds f)\n⊢ Eq (⇑(linearMapOfTendsto f g h)) f","decl":"/-- Construct a bundled linear map from a pointwise limit of linear maps -/\n@[simps! (config := .asFn)]\ndef linearMapOfTendsto (f : M₁ → M₂) (g : α → M₁ →ₛₗ[σ] M₂) [l.NeBot]\n    (h : Tendsto (fun a x => g a x) l (𝓝 f)) : M₁ →ₛₗ[σ] M₂ :=\n  linearMapOfMemClosureRangeCoe f <|\n    mem_closure_of_tendsto h <| Eventually.of_forall fun _ => Set.mem_range_self _\n\n"}
{"name":"LinearMap.isClosed_range_coe","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"M₁ : Type u_1\nM₂ : Type u_2\nR : Type u_4\nS : Type u_5\ninst✝⁹ : TopologicalSpace M₂\ninst✝⁸ : T2Space M₂\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₁\ninst✝² : Module S M₂\ninst✝¹ : ContinuousConstSMul S M₂\ninst✝ : ContinuousAdd M₂\nσ : RingHom R S\n⊢ IsClosed (Set.range DFunLike.coe)","decl":"theorem LinearMap.isClosed_range_coe : IsClosed (Set.range ((↑) : (M₁ →ₛₗ[σ] M₂) → M₁ → M₂)) :=\n  isClosed_of_closure_subset fun f hf => ⟨linearMapOfMemClosureRangeCoe f hf, rfl⟩\n\n"}
{"name":"Submodule.isOpenMap_mkQ","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : TopologicalSpace M\nS : Submodule R M\ninst✝ : ContinuousAdd M\n⊢ IsOpenMap ⇑S.mkQ","decl":"theorem isOpenMap_mkQ [ContinuousAdd M] : IsOpenMap S.mkQ :=\n  QuotientAddGroup.isOpenMap_coe\n\n"}
{"name":"Submodule.isOpenQuotientMap_mkQ","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : TopologicalSpace M\nS : Submodule R M\ninst✝ : ContinuousAdd M\n⊢ IsOpenQuotientMap ⇑S.mkQ","decl":"theorem isOpenQuotientMap_mkQ [ContinuousAdd M] : IsOpenQuotientMap S.mkQ :=\n  QuotientAddGroup.isOpenQuotientMap_mk\n\n"}
{"name":"Submodule.topologicalAddGroup_quotient","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : TopologicalSpace M\nS : Submodule R M\ninst✝ : TopologicalAddGroup M\n⊢ TopologicalAddGroup (HasQuotient.Quotient M S)","decl":"instance topologicalAddGroup_quotient [TopologicalAddGroup M] : TopologicalAddGroup (M ⧸ S) :=\n  inferInstanceAs <| TopologicalAddGroup (M ⧸ S.toAddSubgroup)\n\n"}
{"name":"Submodule.continuousSMul_quotient","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\nS : Submodule R M\ninst✝² : TopologicalSpace R\ninst✝¹ : TopologicalAddGroup M\ninst✝ : ContinuousSMul R M\n⊢ ContinuousSMul R (HasQuotient.Quotient M S)","decl":"instance continuousSMul_quotient [TopologicalSpace R] [TopologicalAddGroup M] [ContinuousSMul R M] :\n    ContinuousSMul R (M ⧸ S) where\n  continuous_smul := by\n    rw [← (IsOpenQuotientMap.id.prodMap S.isOpenQuotientMap_mkQ).continuous_comp_iff]\n    exact continuous_quot_mk.comp continuous_smul\n\n"}
{"name":"Submodule.t3_quotient_of_isClosed","module":"Mathlib.Topology.Algebra.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : TopologicalSpace M\nS : Submodule R M\ninst✝¹ : TopologicalAddGroup M\ninst✝ : IsClosed ↑S\n⊢ T3Space (HasQuotient.Quotient M S)","decl":"instance t3_quotient_of_isClosed [TopologicalAddGroup M] [IsClosed (S : Set M)] :\n    T3Space (M ⧸ S) :=\n  letI : IsClosed (S.toAddSubgroup : Set M) := ‹_›\n  QuotientAddGroup.instT3Space S.toAddSubgroup\n\n"}
