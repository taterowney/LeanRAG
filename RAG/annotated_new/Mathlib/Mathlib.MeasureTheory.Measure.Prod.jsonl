{"name":"measurable_measure_prod_mk_left_finite","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.IsFiniteMeasure ν\ns : Set (Prod α β)\nhs : MeasurableSet s\n⊢ Measurable fun x => ν (Set.preimage (Prod.mk x) s)","decl":"/-- If `ν` is a finite measure, and `s ⊆ α × β` is measurable, then `x ↦ ν { y | (x, y) ∈ s }` is\n  a measurable function. `measurable_measure_prod_mk_left` is strictly more general. -/\ntheorem measurable_measure_prod_mk_left_finite [IsFiniteMeasure ν] {s : Set (α × β)}\n    (hs : MeasurableSet s) : Measurable fun x => ν (Prod.mk x ⁻¹' s) := by\n  induction s, hs using induction_on_inter generateFrom_prod.symm isPiSystem_prod with\n  | empty => simp\n  | basic s hs =>\n    obtain ⟨s, hs, t, -, rfl⟩ := hs\n    classical simpa only [mk_preimage_prod_right_eq_if, measure_if]\n      using measurable_const.indicator hs\n  | compl s hs ihs =>\n    simp_rw [preimage_compl, measure_compl (measurable_prod_mk_left hs) (measure_ne_top ν _)]\n    exact ihs.const_sub _\n  | iUnion f hfd hfm ihf =>\n    have (a : α) : ν (Prod.mk a ⁻¹' ⋃ i, f i) = ∑' i, ν (Prod.mk a ⁻¹' f i) := by\n      rw [preimage_iUnion, measure_iUnion]\n      exacts [hfd.mono fun _ _ ↦ .preimage _, fun i ↦ measurable_prod_mk_left (hfm i)]\n    simpa only [this] using Measurable.ennreal_tsum ihf\n\n"}
{"name":"measurable_measure_prod_mk_left","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\ns : Set (Prod α β)\nhs : MeasurableSet s\n⊢ Measurable fun x => ν (Set.preimage (Prod.mk x) s)","decl":"/-- If `ν` is an s-finite measure, and `s ⊆ α × β` is measurable, then `x ↦ ν { y | (x, y) ∈ s }`\n  is a measurable function. -/\ntheorem measurable_measure_prod_mk_left [SFinite ν] {s : Set (α × β)} (hs : MeasurableSet s) :\n    Measurable fun x => ν (Prod.mk x ⁻¹' s) := by\n  rw [← sum_sfiniteSeq ν]\n  simp_rw [Measure.sum_apply_of_countable]\n  exact Measurable.ennreal_tsum (fun i ↦ measurable_measure_prod_mk_left_finite hs)\n\n"}
{"name":"measurable_measure_prod_mk_right","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\ns : Set (Prod α β)\nhs : MeasurableSet s\n⊢ Measurable fun y => μ (Set.preimage (fun x => { fst := x, snd := y }) s)","decl":"/-- If `μ` is a σ-finite measure, and `s ⊆ α × β` is measurable, then `y ↦ μ { x | (x, y) ∈ s }` is\n  a measurable function. -/\ntheorem measurable_measure_prod_mk_right {μ : Measure α} [SFinite μ] {s : Set (α × β)}\n    (hs : MeasurableSet s) : Measurable fun y => μ ((fun x => (x, y)) ⁻¹' s) :=\n  measurable_measure_prod_mk_left (measurableSet_swap_iff.mpr hs)\n\n"}
{"name":"Measurable.map_prod_mk_left","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\n⊢ Measurable fun x => MeasureTheory.Measure.map (Prod.mk x) ν","decl":"theorem Measurable.map_prod_mk_left [SFinite ν] :\n    Measurable fun x : α => map (Prod.mk x) ν := by\n  apply measurable_of_measurable_coe; intro s hs\n  simp_rw [map_apply measurable_prod_mk_left hs]\n  exact measurable_measure_prod_mk_left hs\n\n"}
{"name":"Measurable.map_prod_mk_right","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\n⊢ Measurable fun y => MeasureTheory.Measure.map (fun x => { fst := x, snd := y }) μ","decl":"theorem Measurable.map_prod_mk_right {μ : Measure α} [SFinite μ] :\n    Measurable fun y : β => map (fun x : α => (x, y)) μ := by\n  apply measurable_of_measurable_coe; intro s hs\n  simp_rw [map_apply measurable_prod_mk_right hs]\n  exact measurable_measure_prod_mk_right hs\n\n"}
{"name":"Measurable.lintegral_prod_right'","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\nf : Prod α β → ENNReal\na✝ : Measurable f\n⊢ Measurable fun x => MeasureTheory.lintegral ν fun y => f { fst := x, snd := y }","decl":"/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\n  Tonelli's theorem is measurable. -/\ntheorem Measurable.lintegral_prod_right' [SFinite ν] :\n    ∀ {f : α × β → ℝ≥0∞}, Measurable f → Measurable fun x => ∫⁻ y, f (x, y) ∂ν := by\n  have m := @measurable_prod_mk_left\n  refine Measurable.ennreal_induction (P := fun f => Measurable fun (x : α) => ∫⁻ y, f (x, y) ∂ν)\n    ?_ ?_ ?_\n  · intro c s hs\n    simp only [← indicator_comp_right]\n    suffices Measurable fun x => c * ν (Prod.mk x ⁻¹' s) by simpa [lintegral_indicator (m hs)]\n    exact (measurable_measure_prod_mk_left hs).const_mul _\n  · rintro f g - hf - h2f h2g\n    simp only [Pi.add_apply]\n    conv => enter [1, x]; erw [lintegral_add_left (hf.comp m)]\n    exact h2f.add h2g\n  · intro f hf h2f h3f\n    have : ∀ x, Monotone fun n y => f n (x, y) := fun x i j hij y => h2f hij (x, y)\n    conv => enter [1, x]; erw [lintegral_iSup (fun n => (hf n).comp m) (this x)]\n    exact .iSup h3f\n\n"}
{"name":"Measurable.lintegral_prod_right","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\nf : α → β → ENNReal\nhf : Measurable (Function.uncurry f)\n⊢ Measurable fun x => MeasureTheory.lintegral ν fun y => f x y","decl":"/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\n  Tonelli's theorem is measurable.\n  This version has the argument `f` in curried form. -/\ntheorem Measurable.lintegral_prod_right [SFinite ν] {f : α → β → ℝ≥0∞}\n    (hf : Measurable (uncurry f)) : Measurable fun x => ∫⁻ y, f x y ∂ν :=\n  hf.lintegral_prod_right'\n\n"}
{"name":"Measurable.lintegral_prod_left'","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\nf : Prod α β → ENNReal\nhf : Measurable f\n⊢ Measurable fun y => MeasureTheory.lintegral μ fun x => f { fst := x, snd := y }","decl":"/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\n  the symmetric version of Tonelli's theorem is measurable. -/\ntheorem Measurable.lintegral_prod_left' [SFinite μ] {f : α × β → ℝ≥0∞} (hf : Measurable f) :\n    Measurable fun y => ∫⁻ x, f (x, y) ∂μ :=\n  (measurable_swap_iff.mpr hf).lintegral_prod_right'\n\n"}
{"name":"Measurable.lintegral_prod_left","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\nf : α → β → ENNReal\nhf : Measurable (Function.uncurry f)\n⊢ Measurable fun y => MeasureTheory.lintegral μ fun x => f x y","decl":"/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\n  the symmetric version of Tonelli's theorem is measurable.\n  This version has the argument `f` in curried form. -/\ntheorem Measurable.lintegral_prod_left [SFinite μ] {f : α → β → ℝ≥0∞}\n    (hf : Measurable (uncurry f)) : Measurable fun y => ∫⁻ x, f x y ∂μ :=\n  hf.lintegral_prod_left'\n\n"}
{"name":"MeasureTheory.Measure.prod_def","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\n⊢ Eq (μ.prod ν) (μ.bind fun x => MeasureTheory.Measure.map (Prod.mk x) ν)","decl":"/-- The binary product of measures. They are defined for arbitrary measures, but we basically\n  prove all properties under the assumption that at least one of them is s-finite. -/\nprotected irreducible_def prod (μ : Measure α) (ν : Measure β) : Measure (α × β) :=\n  bind μ fun x : α => map (Prod.mk x) ν\n\n"}
{"name":"MeasureTheory.Measure.volume_eq_prod","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : MeasureTheory.MeasureSpace α\ninst✝ : MeasureTheory.MeasureSpace β\n⊢ Eq MeasureTheory.MeasureSpace.volume (MeasureTheory.MeasureSpace.volume.prod MeasureTheory.MeasureSpace.volume)","decl":"theorem volume_eq_prod (α β) [MeasureSpace α] [MeasureSpace β] :\n    (volume : Measure (α × β)) = (volume : Measure α).prod (volume : Measure β) :=\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.prod_apply","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\ns : Set (Prod α β)\nhs : MeasurableSet s\n⊢ Eq ((μ.prod ν) s) (MeasureTheory.lintegral μ fun x => ν (Set.preimage (Prod.mk x) s))","decl":"theorem prod_apply {s : Set (α × β)} (hs : MeasurableSet s) :\n    μ.prod ν s = ∫⁻ x, ν (Prod.mk x ⁻¹' s) ∂μ := by\n  simp_rw [Measure.prod, bind_apply hs (Measurable.map_prod_mk_left (ν := ν)),\n    map_apply measurable_prod_mk_left hs]\n\n"}
{"name":"MeasureTheory.Measure.prod_prod","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\ns : Set α\nt : Set β\n⊢ Eq ((μ.prod ν) (SProd.sprod s t)) (HMul.hMul (μ s) (ν t))","decl":"/-- The product measure of the product of two sets is the product of their measures. Note that we\ndo not need the sets to be measurable. -/\n@[simp]\ntheorem prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by\n  classical\n  apply le_antisymm\n  · set S := toMeasurable μ s\n    set T := toMeasurable ν t\n    have hSTm : MeasurableSet (S ×ˢ T) :=\n      (measurableSet_toMeasurable _ _).prod (measurableSet_toMeasurable _ _)\n    calc\n      μ.prod ν (s ×ˢ t) ≤ μ.prod ν (S ×ˢ T) := by gcongr <;> apply subset_toMeasurable\n      _ = μ S * ν T := by\n        rw [prod_apply hSTm]\n        simp_rw [S, mk_preimage_prod_right_eq_if, measure_if,\n          lintegral_indicator (measurableSet_toMeasurable _ _), lintegral_const,\n          restrict_apply_univ, mul_comm]\n      _ = μ s * ν t := by rw [measure_toMeasurable, measure_toMeasurable]\n  · -- Formalization is based on https://mathoverflow.net/a/254134/136589\n    set ST := toMeasurable (μ.prod ν) (s ×ˢ t)\n    have hSTm : MeasurableSet ST := measurableSet_toMeasurable _ _\n    have hST : s ×ˢ t ⊆ ST := subset_toMeasurable _ _\n    set f : α → ℝ≥0∞ := fun x => ν (Prod.mk x ⁻¹' ST)\n    have hfm : Measurable f := measurable_measure_prod_mk_left hSTm\n    set s' : Set α := { x | ν t ≤ f x }\n    have hss' : s ⊆ s' := fun x hx => measure_mono fun y hy => hST <| mk_mem_prod hx hy\n    calc\n      μ s * ν t ≤ μ s' * ν t := by gcongr\n      _ = ∫⁻ _ in s', ν t ∂μ := by rw [setLIntegral_const, mul_comm]\n      _ ≤ ∫⁻ x in s', f x ∂μ := setLIntegral_mono hfm fun x => id\n      _ ≤ ∫⁻ x, f x ∂μ := lintegral_mono' restrict_le_self le_rfl\n      _ = μ.prod ν ST := (prod_apply hSTm).symm\n      _ = μ.prod ν (s ×ˢ t) := measure_toMeasurable _\n\n"}
{"name":"MeasureTheory.Measure.map_fst_prod","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\n⊢ Eq (MeasureTheory.Measure.map Prod.fst (μ.prod ν)) (HSMul.hSMul (ν Set.univ) μ)","decl":"@[simp] lemma map_fst_prod : Measure.map Prod.fst (μ.prod ν) = (ν univ) • μ := by\n  ext s hs\n  simp [Measure.map_apply measurable_fst hs, ← prod_univ, mul_comm]\n\n"}
{"name":"MeasureTheory.Measure.map_snd_prod","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\n⊢ Eq (MeasureTheory.Measure.map Prod.snd (μ.prod ν)) (HSMul.hSMul (μ Set.univ) ν)","decl":"@[simp] lemma map_snd_prod : Measure.map Prod.snd (μ.prod ν) = (μ univ) • ν := by\n  ext s hs\n  simp [Measure.map_apply measurable_snd hs, ← univ_prod]\n\n"}
{"name":"MeasureTheory.Measure.prod.instIsOpenPosMeasure","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"X : Type u_4\nY : Type u_5\ninst✝⁴ : TopologicalSpace X\ninst✝³ : TopologicalSpace Y\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝² : μ.IsOpenPosMeasure\nm' : MeasurableSpace Y\nν : MeasureTheory.Measure Y\ninst✝¹ : ν.IsOpenPosMeasure\ninst✝ : MeasureTheory.SFinite ν\n⊢ (μ.prod ν).IsOpenPosMeasure","decl":"instance prod.instIsOpenPosMeasure {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {m : MeasurableSpace X} {μ : Measure X} [IsOpenPosMeasure μ] {m' : MeasurableSpace Y}\n    {ν : Measure Y} [IsOpenPosMeasure ν] [SFinite ν] : IsOpenPosMeasure (μ.prod ν) := by\n  constructor\n  rintro U U_open ⟨⟨x, y⟩, hxy⟩\n  rcases isOpen_prod_iff.1 U_open x y hxy with ⟨u, v, u_open, v_open, xu, yv, huv⟩\n  refine ne_of_gt (lt_of_lt_of_le ?_ (measure_mono huv))\n  simp only [prod_prod, CanonicallyOrderedAdd.mul_pos]\n  constructor\n  · exact u_open.measure_pos μ ⟨x, xu⟩\n  · exact v_open.measure_pos ν ⟨y, yv⟩\n\n"}
{"name":"MeasureTheory.Measure.instIsOpenPosMeasureProdVolumeOfSFinite","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"X : Type u_4\nY : Type u_5\ninst✝⁶ : TopologicalSpace X\ninst✝⁵ : MeasureTheory.MeasureSpace X\ninst✝⁴ : MeasureTheory.MeasureSpace.volume.IsOpenPosMeasure\ninst✝³ : TopologicalSpace Y\ninst✝² : MeasureTheory.MeasureSpace Y\ninst✝¹ : MeasureTheory.MeasureSpace.volume.IsOpenPosMeasure\ninst✝ : MeasureTheory.SFinite MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.MeasureSpace.volume.IsOpenPosMeasure","decl":"instance {X Y : Type*}\n    [TopologicalSpace X] [MeasureSpace X] [IsOpenPosMeasure (volume : Measure X)]\n    [TopologicalSpace Y] [MeasureSpace Y] [IsOpenPosMeasure (volume : Measure Y)]\n    [SFinite (volume : Measure Y)] : IsOpenPosMeasure (volume : Measure (X × Y)) :=\n  prod.instIsOpenPosMeasure\n\n"}
{"name":"MeasureTheory.Measure.prod.instIsFiniteMeasure","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_4\nβ : Type u_5\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : MeasureTheory.IsFiniteMeasure ν\n⊢ MeasureTheory.IsFiniteMeasure (μ.prod ν)","decl":"instance prod.instIsFiniteMeasure {α β : Type*} {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    (μ : Measure α) (ν : Measure β) [IsFiniteMeasure μ] [IsFiniteMeasure ν] :\n    IsFiniteMeasure (μ.prod ν) := by\n  constructor\n  rw [← univ_prod_univ, prod_prod]\n  exact mul_lt_top (measure_lt_top _ _) (measure_lt_top _ _)\n\n"}
{"name":"MeasureTheory.Measure.instIsFiniteMeasureProdVolume","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝³ : MeasureTheory.MeasureSpace α\ninst✝² : MeasureTheory.MeasureSpace β\ninst✝¹ : MeasureTheory.IsFiniteMeasure MeasureTheory.MeasureSpace.volume\ninst✝ : MeasureTheory.IsFiniteMeasure MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.IsFiniteMeasure MeasureTheory.MeasureSpace.volume","decl":"instance {α β : Type*} [MeasureSpace α] [MeasureSpace β] [IsFiniteMeasure (volume : Measure α)]\n    [IsFiniteMeasure (volume : Measure β)] : IsFiniteMeasure (volume : Measure (α × β)) :=\n  prod.instIsFiniteMeasure _ _\n\n"}
{"name":"MeasureTheory.Measure.prod.instIsProbabilityMeasure","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_4\nβ : Type u_5\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.IsProbabilityMeasure μ\ninst✝ : MeasureTheory.IsProbabilityMeasure ν\n⊢ MeasureTheory.IsProbabilityMeasure (μ.prod ν)","decl":"instance prod.instIsProbabilityMeasure {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} (μ : Measure α) (ν : Measure β) [IsProbabilityMeasure μ]\n    [IsProbabilityMeasure ν] : IsProbabilityMeasure (μ.prod ν) :=\n  ⟨by rw [← univ_prod_univ, prod_prod, measure_univ, measure_univ, mul_one]⟩\n\n"}
{"name":"MeasureTheory.Measure.instIsProbabilityMeasureProdVolume","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝³ : MeasureTheory.MeasureSpace α\ninst✝² : MeasureTheory.MeasureSpace β\ninst✝¹ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\ninst✝ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume","decl":"instance {α β : Type*} [MeasureSpace α] [MeasureSpace β]\n    [IsProbabilityMeasure (volume : Measure α)] [IsProbabilityMeasure (volume : Measure β)] :\n    IsProbabilityMeasure (volume : Measure (α × β)) :=\n  prod.instIsProbabilityMeasure _ _\n\n"}
{"name":"MeasureTheory.Measure.prod.instIsFiniteMeasureOnCompacts","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace β\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝² : MeasureTheory.IsFiniteMeasureOnCompacts μ\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts ν\ninst✝ : MeasureTheory.SFinite ν\n⊢ MeasureTheory.IsFiniteMeasureOnCompacts (μ.prod ν)","decl":"instance prod.instIsFiniteMeasureOnCompacts {α β : Type*} [TopologicalSpace α] [TopologicalSpace β]\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β} (μ : Measure α) (ν : Measure β)\n    [IsFiniteMeasureOnCompacts μ] [IsFiniteMeasureOnCompacts ν] [SFinite ν] :\n    IsFiniteMeasureOnCompacts (μ.prod ν) := by\n  refine ⟨fun K hK => ?_⟩\n  set L := (Prod.fst '' K) ×ˢ (Prod.snd '' K) with hL\n  have : K ⊆ L := by\n    rintro ⟨x, y⟩ hxy\n    simp only [L, prod_mk_mem_set_prod_eq, mem_image, Prod.exists, exists_and_right,\n      exists_eq_right]\n    exact ⟨⟨y, hxy⟩, ⟨x, hxy⟩⟩\n  apply lt_of_le_of_lt (measure_mono this)\n  rw [hL, prod_prod]\n  exact mul_lt_top (hK.image continuous_fst).measure_lt_top (hK.image continuous_snd).measure_lt_top\n\n"}
{"name":"MeasureTheory.Measure.instIsFiniteMeasureOnCompactsProdVolumeOfSFinite","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"X : Type u_4\nY : Type u_5\ninst✝⁶ : TopologicalSpace X\ninst✝⁵ : MeasureTheory.MeasureSpace X\ninst✝⁴ : MeasureTheory.IsFiniteMeasureOnCompacts MeasureTheory.MeasureSpace.volume\ninst✝³ : TopologicalSpace Y\ninst✝² : MeasureTheory.MeasureSpace Y\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts MeasureTheory.MeasureSpace.volume\ninst✝ : MeasureTheory.SFinite MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.IsFiniteMeasureOnCompacts MeasureTheory.MeasureSpace.volume","decl":"instance {X Y : Type*}\n    [TopologicalSpace X] [MeasureSpace X] [IsFiniteMeasureOnCompacts (volume : Measure X)]\n    [TopologicalSpace Y] [MeasureSpace Y] [IsFiniteMeasureOnCompacts (volume : Measure Y)]\n    [SFinite (volume : Measure Y)] : IsFiniteMeasureOnCompacts (volume : Measure (X × Y)) :=\n  prod.instIsFiniteMeasureOnCompacts _ _\n\n"}
{"name":"MeasureTheory.Measure.prod.instNoAtoms_fst","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.NoAtoms μ\n⊢ MeasureTheory.NoAtoms (μ.prod ν)","decl":"instance prod.instNoAtoms_fst [NoAtoms μ] :\n    NoAtoms (Measure.prod μ ν) := by\n  refine NoAtoms.mk (fun x => ?_)\n  rw [← Set.singleton_prod_singleton, Measure.prod_prod, measure_singleton, zero_mul]\n\n"}
{"name":"MeasureTheory.Measure.prod.instNoAtoms_snd","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.NoAtoms ν\n⊢ MeasureTheory.NoAtoms (μ.prod ν)","decl":"instance prod.instNoAtoms_snd [NoAtoms ν] :\n    NoAtoms (Measure.prod μ ν) := by\n  refine NoAtoms.mk (fun x => ?_)\n  rw [← Set.singleton_prod_singleton, Measure.prod_prod, measure_singleton (μ := ν), mul_zero]\n\n"}
{"name":"MeasureTheory.Measure.ae_measure_lt_top","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\ns : Set (Prod α β)\nhs : MeasurableSet s\nh2s : Ne ((μ.prod ν) s) Top.top\n⊢ Filter.Eventually (fun x => LT.lt (ν (Set.preimage (Prod.mk x) s)) Top.top) (MeasureTheory.ae μ)","decl":"theorem ae_measure_lt_top {s : Set (α × β)} (hs : MeasurableSet s) (h2s : (μ.prod ν) s ≠ ∞) :\n    ∀ᵐ x ∂μ, ν (Prod.mk x ⁻¹' s) < ∞ := by\n  rw [prod_apply hs] at h2s\n  exact ae_lt_top (measurable_measure_prod_mk_left hs) h2s\n\n"}
{"name":"MeasureTheory.Measure.measure_prod_null","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\ns : Set (Prod α β)\nhs : MeasurableSet s\n⊢ Iff (Eq ((μ.prod ν) s) 0) ((MeasureTheory.ae μ).EventuallyEq (fun x => ν (Set.preimage (Prod.mk x) s)) 0)","decl":"/-- Note: the assumption `hs` cannot be dropped. For a counterexample, see\n  Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/\ntheorem measure_prod_null {s : Set (α × β)} (hs : MeasurableSet s) :\n    μ.prod ν s = 0 ↔ (fun x => ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  rw [prod_apply hs, lintegral_eq_zero_iff (measurable_measure_prod_mk_left hs)]\n\n"}
{"name":"MeasureTheory.Measure.measure_ae_null_of_prod_null","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\ns : Set (Prod α β)\nh : Eq ((μ.prod ν) s) 0\n⊢ (MeasureTheory.ae μ).EventuallyEq (fun x => ν (Set.preimage (Prod.mk x) s)) 0","decl":"/-- Note: the converse is not true without assuming that `s` is measurable. For a counterexample,\n  see Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/\ntheorem measure_ae_null_of_prod_null {s : Set (α × β)} (h : μ.prod ν s = 0) :\n    (fun x => ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  obtain ⟨t, hst, mt, ht⟩ := exists_measurable_superset_of_null h\n  rw [measure_prod_null mt] at ht\n  rw [eventuallyLE_antisymm_iff]\n  exact\n    ⟨EventuallyLE.trans_eq (Eventually.of_forall fun x => measure_mono (preimage_mono hst))\n        ht,\n      Eventually.of_forall fun x => zero_le _⟩\n\n"}
{"name":"MeasureTheory.Measure.AbsolutelyContinuous.prod","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nμ μ' : MeasureTheory.Measure α\nν ν' : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : MeasureTheory.SFinite ν'\nh1 : μ.AbsolutelyContinuous μ'\nh2 : ν.AbsolutelyContinuous ν'\n⊢ (μ.prod ν).AbsolutelyContinuous (μ'.prod ν')","decl":"theorem AbsolutelyContinuous.prod [SFinite ν'] (h1 : μ ≪ μ') (h2 : ν ≪ ν') :\n    μ.prod ν ≪ μ'.prod ν' := by\n  refine AbsolutelyContinuous.mk fun s hs h2s => ?_\n  rw [measure_prod_null hs] at h2s ⊢\n  exact (h2s.filter_mono h1.ae_le).mono fun _ h => h2 h\n\n"}
{"name":"MeasureTheory.Measure.ae_ae_of_ae_prod","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\np : Prod α β → Prop\nh : Filter.Eventually (fun z => p z) (MeasureTheory.ae (μ.prod ν))\n⊢ Filter.Eventually (fun x => Filter.Eventually (fun y => p { fst := x, snd := y }) (MeasureTheory.ae ν)) (MeasureTheory.ae μ)","decl":"/-- Note: the converse is not true. For a counterexample, see\n  Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. It is true if the set is\n  measurable, see `ae_prod_mem_iff_ae_ae_mem`. -/\ntheorem ae_ae_of_ae_prod {p : α × β → Prop} (h : ∀ᵐ z ∂μ.prod ν, p z) :\n    ∀ᵐ x ∂μ, ∀ᵐ y ∂ν, p (x, y) :=\n  measure_ae_null_of_prod_null h\n\n"}
{"name":"MeasureTheory.Measure.ae_ae_eq_curry_of_prod","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\nγ : Type u_4\nf g : Prod α β → γ\nh : (MeasureTheory.ae (μ.prod ν)).EventuallyEq f g\n⊢ Filter.Eventually (fun x => (MeasureTheory.ae ν).EventuallyEq (Function.curry f x) (Function.curry g x)) (MeasureTheory.ae μ)","decl":"theorem ae_ae_eq_curry_of_prod {γ : Type*} {f g : α × β → γ} (h : f =ᵐ[μ.prod ν] g) :\n    ∀ᵐ x ∂μ, curry f x =ᵐ[ν] curry g x :=\n  ae_ae_of_ae_prod h\n\n"}
{"name":"MeasureTheory.Measure.ae_ae_eq_of_ae_eq_uncurry","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\nγ : Type u_4\nf g : α → β → γ\nh : (MeasureTheory.ae (μ.prod ν)).EventuallyEq (Function.uncurry f) (Function.uncurry g)\n⊢ Filter.Eventually (fun x => (MeasureTheory.ae ν).EventuallyEq (f x) (g x)) (MeasureTheory.ae μ)","decl":"theorem ae_ae_eq_of_ae_eq_uncurry {γ : Type*} {f g : α → β → γ}\n    (h : uncurry f =ᵐ[μ.prod ν] uncurry g) : ∀ᵐ x ∂μ, f x =ᵐ[ν] g x :=\n  ae_ae_eq_curry_of_prod h\n\n"}
{"name":"MeasureTheory.Measure.ae_prod_iff_ae_ae","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\np : Prod α β → Prop\nhp : MeasurableSet (setOf fun x => p x)\n⊢ Iff (Filter.Eventually (fun z => p z) (MeasureTheory.ae (μ.prod ν))) (Filter.Eventually (fun x => Filter.Eventually (fun y => p { fst := x, snd := y }) (MeasureTheory.ae ν)) (MeasureTheory.ae μ))","decl":"theorem ae_prod_iff_ae_ae {p : α × β → Prop} (hp : MeasurableSet {x | p x}) :\n    (∀ᵐ z ∂μ.prod ν, p z) ↔ ∀ᵐ x ∂μ, ∀ᵐ y ∂ν, p (x, y) :=\n  measure_prod_null hp.compl\n\n"}
{"name":"MeasureTheory.Measure.ae_prod_mem_iff_ae_ae_mem","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\ns : Set (Prod α β)\nhs : MeasurableSet s\n⊢ Iff (Filter.Eventually (fun z => Membership.mem s z) (MeasureTheory.ae (μ.prod ν))) (Filter.Eventually (fun x => Filter.Eventually (fun y => Membership.mem s { fst := x, snd := y }) (MeasureTheory.ae ν)) (MeasureTheory.ae μ))","decl":"theorem ae_prod_mem_iff_ae_ae_mem {s : Set (α × β)} (hs : MeasurableSet s) :\n    (∀ᵐ z ∂μ.prod ν, z ∈ s) ↔ ∀ᵐ x ∂μ, ∀ᵐ y ∂ν, (x, y) ∈ s :=\n  measure_prod_null hs.compl\n\n"}
{"name":"MeasureTheory.Measure.quasiMeasurePreserving_fst","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving Prod.fst (μ.prod ν) μ","decl":"theorem quasiMeasurePreserving_fst : QuasiMeasurePreserving Prod.fst (μ.prod ν) μ := by\n  refine ⟨measurable_fst, AbsolutelyContinuous.mk fun s hs h2s => ?_⟩\n  rw [map_apply measurable_fst hs, ← prod_univ, prod_prod, h2s, zero_mul]\n\n"}
{"name":"MeasureTheory.Measure.quasiMeasurePreserving_snd","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving Prod.snd (μ.prod ν) ν","decl":"theorem quasiMeasurePreserving_snd : QuasiMeasurePreserving Prod.snd (μ.prod ν) ν := by\n  refine ⟨measurable_snd, AbsolutelyContinuous.mk fun s hs h2s => ?_⟩\n  rw [map_apply measurable_snd hs, ← univ_prod, prod_prod, h2s, mul_zero]\n\n"}
{"name":"MeasureTheory.Measure.set_prod_ae_eq","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\ns s' : Set α\nt t' : Set β\nhs : (MeasureTheory.ae μ).EventuallyEq s s'\nht : (MeasureTheory.ae ν).EventuallyEq t t'\n⊢ (MeasureTheory.ae (μ.prod ν)).EventuallyEq (SProd.sprod s t) (SProd.sprod s' t')","decl":"lemma set_prod_ae_eq {s s' : Set α} {t t' : Set β} (hs : s =ᵐ[μ] s') (ht : t =ᵐ[ν] t') :\n    (s ×ˢ t : Set (α × β)) =ᵐ[μ.prod ν] (s' ×ˢ t' : Set (α × β)) :=\n  (quasiMeasurePreserving_fst.preimage_ae_eq hs).inter\n    (quasiMeasurePreserving_snd.preimage_ae_eq ht)\n\n"}
{"name":"MeasureTheory.Measure.measure_prod_compl_eq_zero","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\ns : Set α\nt : Set β\ns_ae_univ : Eq (μ (HasCompl.compl s)) 0\nt_ae_univ : Eq (ν (HasCompl.compl t)) 0\n⊢ Eq ((μ.prod ν) (HasCompl.compl (SProd.sprod s t))) 0","decl":"lemma measure_prod_compl_eq_zero {s : Set α} {t : Set β}\n    (s_ae_univ : μ sᶜ = 0) (t_ae_univ : ν tᶜ = 0) :\n    μ.prod ν (s ×ˢ t)ᶜ = 0 := by\n  rw [Set.compl_prod_eq_union, measure_union_null_iff]\n  simp [s_ae_univ, t_ae_univ]\n\n"}
{"name":"MeasureTheory.NullMeasurableSet.prod","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\ns : Set α\nt : Set β\ns_mble : MeasureTheory.NullMeasurableSet s μ\nt_mble : MeasureTheory.NullMeasurableSet t ν\n⊢ MeasureTheory.NullMeasurableSet (SProd.sprod s t) (μ.prod ν)","decl":"lemma _root_.MeasureTheory.NullMeasurableSet.prod {s : Set α} {t : Set β}\n    (s_mble : NullMeasurableSet s μ) (t_mble : NullMeasurableSet t ν) :\n    NullMeasurableSet (s ×ˢ t) (μ.prod ν) :=\n  let ⟨s₀, mble_s₀, s_aeeq_s₀⟩ := s_mble\n  let ⟨t₀, mble_t₀, t_aeeq_t₀⟩ := t_mble\n  ⟨s₀ ×ˢ t₀, ⟨mble_s₀.prod mble_t₀, set_prod_ae_eq s_aeeq_s₀ t_aeeq_t₀⟩⟩\n\n"}
{"name":"MeasureTheory.NullMeasurableSet.right_of_prod","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\ns : Set α\nt : Set β\nh : MeasureTheory.NullMeasurableSet (SProd.sprod s t) (μ.prod ν)\nhs : Ne (μ s) 0\n⊢ MeasureTheory.NullMeasurableSet t ν","decl":"/-- If `s ×ˢ t` is a null measurable set and `μ s ≠ 0`, then `t` is a null measurable set. -/\nlemma _root_.MeasureTheory.NullMeasurableSet.right_of_prod {s : Set α} {t : Set β}\n    (h : NullMeasurableSet (s ×ˢ t) (μ.prod ν)) (hs : μ s ≠ 0) : NullMeasurableSet t ν := by\n  rcases h with ⟨u, hum, hu⟩\n  obtain ⟨x, hxs, hx⟩ : ∃ x ∈ s, (Prod.mk x ⁻¹' (s ×ˢ t)) =ᵐ[ν] (Prod.mk x ⁻¹' u) :=\n    ((frequently_ae_iff.2 hs).and_eventually (ae_ae_eq_curry_of_prod hu)).exists\n  refine ⟨Prod.mk x ⁻¹' u, measurable_prod_mk_left hum, ?_⟩\n  rwa [mk_preimage_prod_right hxs] at hx\n\n"}
{"name":"MeasureTheory.NullMeasurableSet.of_preimage_snd","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : NeZero μ\nt : Set β\nh : MeasureTheory.NullMeasurableSet (Set.preimage Prod.snd t) (μ.prod ν)\n⊢ MeasureTheory.NullMeasurableSet t ν","decl":"/-- If `Prod.snd ⁻¹' t` is a null measurable set and `μ ≠ 0`, then `t` is a null measurable set. -/\nlemma _root_.MeasureTheory.NullMeasurableSet.of_preimage_snd [NeZero μ] {t : Set β}\n    (h : NullMeasurableSet (Prod.snd ⁻¹' t) (μ.prod ν)) : NullMeasurableSet t ν :=\n  .right_of_prod (by rwa [univ_prod]) (NeZero.ne (μ univ))\n\n"}
{"name":"MeasureTheory.Measure.nullMeasurableSet_preimage_snd","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : NeZero μ\nt : Set β\n⊢ Iff (MeasureTheory.NullMeasurableSet (Set.preimage Prod.snd t) (μ.prod ν)) (MeasureTheory.NullMeasurableSet t ν)","decl":"/-- `Prod.snd ⁻¹' t` is null measurable w.r.t. `μ.prod ν` iff `t` is null measurable w.r.t. `ν`\nprovided that `μ ≠ 0`. -/\nlemma nullMeasurableSet_preimage_snd [NeZero μ] {t : Set β} :\n    NullMeasurableSet (Prod.snd ⁻¹' t) (μ.prod ν) ↔ NullMeasurableSet t ν :=\n  ⟨.of_preimage_snd, (.preimage · quasiMeasurePreserving_snd)⟩\n\n"}
{"name":"MeasureTheory.Measure.nullMeasurable_comp_snd","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : MeasurableSpace α\ninst✝³ : MeasurableSpace β\ninst✝² : MeasurableSpace γ\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : NeZero μ\nf : β → γ\n⊢ Iff (MeasureTheory.NullMeasurable (Function.comp f Prod.snd) (μ.prod ν)) (MeasureTheory.NullMeasurable f ν)","decl":"lemma nullMeasurable_comp_snd [NeZero μ] {f : β → γ} :\n    NullMeasurable (f ∘ Prod.snd) (μ.prod ν) ↔ NullMeasurable f ν :=\n  forall₂_congr fun s _ ↦ nullMeasurableSet_preimage_snd (t := f ⁻¹' s)\n\n"}
{"name":"MeasureTheory.Measure.prod_sum_left","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nι : Type u_4\nm : ι → MeasureTheory.Measure α\nμ : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite μ\n⊢ Eq ((MeasureTheory.Measure.sum m).prod μ) (MeasureTheory.Measure.sum fun i => (m i).prod μ)","decl":"lemma prod_sum_left {ι : Type*} (m : ι → Measure α) (μ : Measure β) [SFinite μ] :\n    (Measure.sum m).prod μ = Measure.sum (fun i ↦ (m i).prod μ) := by\n  ext s hs\n  simp only [prod_apply hs, lintegral_sum_measure, hs, sum_apply, ENNReal.tsum_prod']\n\n"}
{"name":"MeasureTheory.Measure.prod_sum_right","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nι' : Type u_4\ninst✝¹ : Countable ι'\nm : MeasureTheory.Measure α\nm' : ι' → MeasureTheory.Measure β\ninst✝ : ∀ (n : ι'), MeasureTheory.SFinite (m' n)\n⊢ Eq (m.prod (MeasureTheory.Measure.sum m')) (MeasureTheory.Measure.sum fun p => m.prod (m' p))","decl":"lemma prod_sum_right {ι' : Type*} [Countable ι'] (m : Measure α) (m' : ι' → Measure β)\n    [∀ n, SFinite (m' n)] :\n    m.prod (Measure.sum m') = Measure.sum (fun p ↦ m.prod (m' p)) := by\n  ext s hs\n  simp only [prod_apply hs, lintegral_sum_measure, hs, sum_apply, ENNReal.tsum_prod']\n  have M : ∀ x, MeasurableSet (Prod.mk x ⁻¹' s) := fun x => measurable_prod_mk_left hs\n  simp_rw [Measure.sum_apply _ (M _)]\n  rw [lintegral_tsum (fun i ↦ (measurable_measure_prod_mk_left hs).aemeasurable)]\n\n"}
{"name":"MeasureTheory.Measure.prod_sum","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nι : Type u_4\nι' : Type u_5\ninst✝¹ : Countable ι'\nm : ι → MeasureTheory.Measure α\nm' : ι' → MeasureTheory.Measure β\ninst✝ : ∀ (n : ι'), MeasureTheory.SFinite (m' n)\n⊢ Eq ((MeasureTheory.Measure.sum m).prod (MeasureTheory.Measure.sum m')) (MeasureTheory.Measure.sum fun p => (m p.1).prod (m' p.2))","decl":"lemma prod_sum {ι ι' : Type*} [Countable ι'] (m : ι → Measure α) (m' : ι' → Measure β)\n    [∀ n, SFinite (m' n)] :\n    (Measure.sum m).prod (Measure.sum m') =\n      Measure.sum (fun (p : ι × ι') ↦ (m p.1).prod (m' p.2)) := by\n  simp_rw [prod_sum_left, prod_sum_right, sum_sum]\n\n"}
{"name":"MeasureTheory.Measure.prod.instSigmaFinite","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_4\nβ : Type u_5\nx✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\nx✝ : MeasurableSpace β\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SigmaFinite ν\n⊢ MeasureTheory.SigmaFinite (μ.prod ν)","decl":"instance prod.instSigmaFinite {α β : Type*} {_ : MeasurableSpace α} {μ : Measure α}\n    [SigmaFinite μ] {_ : MeasurableSpace β} {ν : Measure β} [SigmaFinite ν] :\n    SigmaFinite (μ.prod ν) :=\n  (μ.toFiniteSpanningSetsIn.prod ν.toFiniteSpanningSetsIn).sigmaFinite\n\n"}
{"name":"MeasureTheory.Measure.prod.instSFinite","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_4\nβ : Type u_5\nx✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SFinite μ\nx✝ : MeasurableSpace β\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\n⊢ MeasureTheory.SFinite (μ.prod ν)","decl":"instance prod.instSFinite {α β : Type*} {_ : MeasurableSpace α} {μ : Measure α}\n    [SFinite μ] {_ : MeasurableSpace β} {ν : Measure β} [SFinite ν] :\n    SFinite (μ.prod ν) := by\n  have : μ.prod ν =\n      Measure.sum (fun (p : ℕ × ℕ) ↦ (sfiniteSeq μ p.1).prod (sfiniteSeq ν p.2)) := by\n    conv_lhs => rw [← sum_sfiniteSeq μ, ← sum_sfiniteSeq ν]\n    apply prod_sum\n  rw [this]\n  infer_instance\n\n"}
{"name":"MeasureTheory.Measure.instSigmaFiniteProdVolume","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝³ : MeasureTheory.MeasureSpace α\ninst✝² : MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ninst✝¹ : MeasureTheory.MeasureSpace β\ninst✝ : MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume","decl":"instance {α β} [MeasureSpace α] [SigmaFinite (volume : Measure α)]\n    [MeasureSpace β] [SigmaFinite (volume : Measure β)] : SigmaFinite (volume : Measure (α × β)) :=\n  prod.instSigmaFinite\n\n"}
{"name":"MeasureTheory.Measure.instSFiniteProdVolume","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝³ : MeasureTheory.MeasureSpace α\ninst✝² : MeasureTheory.SFinite MeasureTheory.MeasureSpace.volume\ninst✝¹ : MeasureTheory.MeasureSpace β\ninst✝ : MeasureTheory.SFinite MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.SFinite MeasureTheory.MeasureSpace.volume","decl":"instance {α β} [MeasureSpace α] [SFinite (volume : Measure α)]\n    [MeasureSpace β] [SFinite (volume : Measure β)] : SFinite (volume : Measure (α × β)) :=\n  prod.instSFinite\n\n"}
{"name":"MeasureTheory.Measure.prod_eq_generateFrom","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\nC : Set (Set α)\nD : Set (Set β)\nhC : Eq (MeasurableSpace.generateFrom C) inst✝¹\nhD : Eq (MeasurableSpace.generateFrom D) inst✝\nh2C : IsPiSystem C\nh2D : IsPiSystem D\nh3C : μ.FiniteSpanningSetsIn C\nh3D : ν.FiniteSpanningSetsIn D\nμν : MeasureTheory.Measure (Prod α β)\nh₁ : ∀ (s : Set α), Membership.mem C s → ∀ (t : Set β), Membership.mem D t → Eq (μν (SProd.sprod s t)) (HMul.hMul (μ s) (ν t))\n⊢ Eq (μ.prod ν) μν","decl":"/-- A measure on a product space equals the product measure if they are equal on rectangles\n  with as sides sets that generate the corresponding σ-algebras. -/\ntheorem prod_eq_generateFrom {μ : Measure α} {ν : Measure β} {C : Set (Set α)} {D : Set (Set β)}\n    (hC : generateFrom C = ‹_›) (hD : generateFrom D = ‹_›) (h2C : IsPiSystem C)\n    (h2D : IsPiSystem D) (h3C : μ.FiniteSpanningSetsIn C) (h3D : ν.FiniteSpanningSetsIn D)\n    {μν : Measure (α × β)} (h₁ : ∀ s ∈ C, ∀ t ∈ D, μν (s ×ˢ t) = μ s * ν t) : μ.prod ν = μν := by\n  refine\n    (h3C.prod h3D).ext\n      (generateFrom_eq_prod hC hD h3C.isCountablySpanning h3D.isCountablySpanning).symm\n      (h2C.prod h2D) ?_\n  rintro _ ⟨s, hs, t, ht, rfl⟩\n  haveI := h3D.sigmaFinite\n  rw [h₁ s hs t ht, prod_prod]\n\n/- Note that the next theorem is not true for s-finite measures: let `μ = ν = ∞ • Leb` on `[0,1]`\n(they are  s-finite as countable sums of the finite Lebesgue measure), and let `μν = μ.prod ν + λ`\nwhere `λ` is Lebesgue measure on the diagonal. Then both measures give infinite mass to rectangles\n`s × t` whose sides have positive Lebesgue measure, and `0` measure when one of the sides has zero\nLebesgue measure. And yet they do not coincide, as the first one gives zero mass to the diagonal,\nand the second one gives mass one.\n-/\n"}
{"name":"MeasureTheory.Measure.prod_eq","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SigmaFinite ν\nμν : MeasureTheory.Measure (Prod α β)\nh : ∀ (s : Set α) (t : Set β), MeasurableSet s → MeasurableSet t → Eq (μν (SProd.sprod s t)) (HMul.hMul (μ s) (ν t))\n⊢ Eq (μ.prod ν) μν","decl":"/-- A measure on a product space equals the product measure of sigma-finite measures if they are\nequal on rectangles. -/\ntheorem prod_eq {μ : Measure α} [SigmaFinite μ] {ν : Measure β} [SigmaFinite ν]\n    {μν : Measure (α × β)}\n    (h : ∀ s t, MeasurableSet s → MeasurableSet t → μν (s ×ˢ t) = μ s * ν t) : μ.prod ν = μν :=\n  prod_eq_generateFrom generateFrom_measurableSet generateFrom_measurableSet\n    isPiSystem_measurableSet isPiSystem_measurableSet μ.toFiniteSpanningSetsIn\n    ν.toFiniteSpanningSetsIn fun s hs t ht => h s t hs ht\n\n"}
{"name":"MeasureTheory.Measure.prod_swap","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : MeasureTheory.SFinite μ\n⊢ Eq (MeasureTheory.Measure.map Prod.swap (μ.prod ν)) (ν.prod μ)","decl":"theorem prod_swap : map Prod.swap (μ.prod ν) = ν.prod μ := by\n  have : sum (fun (i : ℕ × ℕ) ↦ map Prod.swap ((sfiniteSeq μ i.1).prod (sfiniteSeq ν i.2)))\n       = sum (fun (i : ℕ × ℕ) ↦ map Prod.swap ((sfiniteSeq μ i.2).prod (sfiniteSeq ν i.1))) := by\n    ext s hs\n    rw [sum_apply _ hs, sum_apply _ hs]\n    exact ((Equiv.prodComm ℕ ℕ).tsum_eq _).symm\n  rw [← sum_sfiniteSeq μ, ← sum_sfiniteSeq ν, prod_sum, prod_sum,\n    map_sum measurable_swap.aemeasurable, this]\n  congr 1\n  ext1 i\n  refine (prod_eq ?_).symm\n  intro s t hs ht\n  simp_rw [map_apply measurable_swap (hs.prod ht), preimage_swap_prod, prod_prod, mul_comm]\n\n"}
{"name":"MeasureTheory.Measure.measurePreserving_swap","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : MeasureTheory.SFinite μ\n⊢ MeasureTheory.MeasurePreserving Prod.swap (μ.prod ν) (ν.prod μ)","decl":"theorem measurePreserving_swap : MeasurePreserving Prod.swap (μ.prod ν) (ν.prod μ) :=\n  ⟨measurable_swap, prod_swap⟩\n\n"}
{"name":"MeasureTheory.Measure.prod_apply_symm","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : MeasureTheory.SFinite μ\ns : Set (Prod α β)\nhs : MeasurableSet s\n⊢ Eq ((μ.prod ν) s) (MeasureTheory.lintegral ν fun y => μ (Set.preimage (fun x => { fst := x, snd := y }) s))","decl":"theorem prod_apply_symm {s : Set (α × β)} (hs : MeasurableSet s) :\n    μ.prod ν s = ∫⁻ y, μ ((fun x => (x, y)) ⁻¹' s) ∂ν := by\n  rw [← prod_swap, map_apply measurable_swap hs, prod_apply (measurable_swap hs)]\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.ae_ae_comm","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : MeasureTheory.SFinite μ\np : α → β → Prop\nh : MeasurableSet (setOf fun x => p x.1 x.2)\n⊢ Iff (Filter.Eventually (fun x => Filter.Eventually (fun y => p x y) (MeasureTheory.ae ν)) (MeasureTheory.ae μ)) (Filter.Eventually (fun y => Filter.Eventually (fun x => p x y) (MeasureTheory.ae μ)) (MeasureTheory.ae ν))","decl":"theorem ae_ae_comm {p : α → β → Prop} (h : MeasurableSet {x : α × β | p x.1 x.2}) :\n    (∀ᵐ x ∂μ, ∀ᵐ y ∂ν, p x y) ↔ ∀ᵐ y ∂ν, ∀ᵐ x ∂μ, p x y := calc\n  _ ↔ ∀ᵐ x ∂μ.prod ν, p x.1 x.2 := .symm <| ae_prod_iff_ae_ae h\n  _ ↔ ∀ᵐ x ∂ν.prod μ, p x.2 x.1 := by rw [← prod_swap, ae_map_iff (by fun_prop) h]; simp\n  _ ↔ ∀ᵐ y ∂ν, ∀ᵐ x ∂μ, p x y := ae_prod_iff_ae_ae <| measurable_swap h\n\n"}
{"name":"MeasureTheory.NullMeasurableSet.left_of_prod","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : MeasureTheory.SFinite μ\ns : Set α\nt : Set β\nh : MeasureTheory.NullMeasurableSet (SProd.sprod s t) (μ.prod ν)\nht : Ne (ν t) 0\n⊢ MeasureTheory.NullMeasurableSet s μ","decl":"/-- If `s ×ˢ t` is a null measurable set and `ν t ≠ 0`, then `s` is a null measurable set. -/\nlemma _root_.MeasureTheory.NullMeasurableSet.left_of_prod {s : Set α} {t : Set β}\n    (h : NullMeasurableSet (s ×ˢ t) (μ.prod ν)) (ht : ν t ≠ 0) : NullMeasurableSet s μ := by\n  refine .right_of_prod ?_ ht\n  rw [← preimage_swap_prod]\n  exact h.preimage measurePreserving_swap.quasiMeasurePreserving\n\n"}
{"name":"MeasureTheory.NullMeasurableSet.of_preimage_fst","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : MeasurableSpace α\ninst✝³ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : NeZero ν\ns : Set α\nh : MeasureTheory.NullMeasurableSet (Set.preimage Prod.fst s) (μ.prod ν)\n⊢ MeasureTheory.NullMeasurableSet s μ","decl":"/-- If `Prod.fst ⁻¹' s` is a null measurable set and `ν ≠ 0`, then `s` is a null measurable set. -/\nlemma _root_.MeasureTheory.NullMeasurableSet.of_preimage_fst [NeZero ν] {s : Set α}\n    (h : NullMeasurableSet (Prod.fst ⁻¹' s) (μ.prod ν)) : NullMeasurableSet s μ :=\n  .left_of_prod (by rwa [prod_univ]) (NeZero.ne (ν univ))\n\n"}
{"name":"MeasureTheory.Measure.nullMeasurableSet_preimage_fst","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : MeasurableSpace α\ninst✝³ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : NeZero ν\ns : Set α\n⊢ Iff (MeasureTheory.NullMeasurableSet (Set.preimage Prod.fst s) (μ.prod ν)) (MeasureTheory.NullMeasurableSet s μ)","decl":"/-- `Prod.fst ⁻¹' s` is null measurable w.r.t. `μ.prod ν` iff `s` is null measurable w.r.t. `μ`\nprovided that `ν ≠ 0`. -/\nlemma nullMeasurableSet_preimage_fst [NeZero ν] {s : Set α} :\n    NullMeasurableSet (Prod.fst ⁻¹' s) (μ.prod ν) ↔ NullMeasurableSet s μ :=\n  ⟨.of_preimage_fst, (.preimage · quasiMeasurePreserving_fst)⟩\n\n"}
{"name":"MeasureTheory.Measure.nullMeasurable_comp_fst","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁵ : MeasurableSpace α\ninst✝⁴ : MeasurableSpace β\ninst✝³ : MeasurableSpace γ\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : NeZero ν\nf : α → γ\n⊢ Iff (MeasureTheory.NullMeasurable (Function.comp f Prod.fst) (μ.prod ν)) (MeasureTheory.NullMeasurable f μ)","decl":"lemma nullMeasurable_comp_fst [NeZero ν] {f : α → γ} :\n    NullMeasurable (f ∘ Prod.fst) (μ.prod ν) ↔ NullMeasurable f μ :=\n  forall₂_congr fun s _ ↦ nullMeasurableSet_preimage_fst (s := f ⁻¹' s)\n\n"}
{"name":"MeasureTheory.Measure.nullMeasurableSet_prod_of_ne_zero","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : MeasureTheory.SFinite μ\ns : Set α\nt : Set β\nhs : Ne (μ s) 0\nht : Ne (ν t) 0\n⊢ Iff (MeasureTheory.NullMeasurableSet (SProd.sprod s t) (μ.prod ν)) (And (MeasureTheory.NullMeasurableSet s μ) (MeasureTheory.NullMeasurableSet t ν))","decl":"/-- The product of two non-null sets is null measurable\nif and only if both of them are null measurable. -/\nlemma nullMeasurableSet_prod_of_ne_zero {s : Set α} {t : Set β} (hs : μ s ≠ 0) (ht : ν t ≠ 0) :\n    NullMeasurableSet (s ×ˢ t) (μ.prod ν) ↔ NullMeasurableSet s μ ∧ NullMeasurableSet t ν :=\n  ⟨fun h ↦ ⟨h.left_of_prod ht, h.right_of_prod hs⟩, fun ⟨hs, ht⟩ ↦ hs.prod ht⟩\n\n"}
{"name":"MeasureTheory.Measure.nullMeasurableSet_prod","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : MeasureTheory.SFinite μ\ns : Set α\nt : Set β\n⊢ Iff (MeasureTheory.NullMeasurableSet (SProd.sprod s t) (μ.prod ν)) (Or (And (MeasureTheory.NullMeasurableSet s μ) (MeasureTheory.NullMeasurableSet t ν)) (Or (Eq (μ s) 0) (Eq (ν t) 0)))","decl":"/-- The product of two sets is null measurable\nif and only if both of them are null measurable or one of them has measure zero. -/\nlemma nullMeasurableSet_prod {s : Set α} {t : Set β} :\n    NullMeasurableSet (s ×ˢ t) (μ.prod ν) ↔\n      NullMeasurableSet s μ ∧ NullMeasurableSet t ν ∨ μ s = 0 ∨ ν t = 0 := by\n  rcases eq_or_ne (μ s) 0 with hs | hs; · simp [NullMeasurableSet.of_null, *]\n  rcases eq_or_ne (ν t) 0 with ht | ht; · simp [NullMeasurableSet.of_null, *]\n  simp [*, nullMeasurableSet_prod_of_ne_zero]\n\n"}
{"name":"MeasureTheory.Measure.prodAssoc_prod","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁵ : MeasurableSpace α\ninst✝⁴ : MeasurableSpace β\ninst✝³ : MeasurableSpace γ\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\nτ : MeasureTheory.Measure γ\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : MeasureTheory.SFinite τ\n⊢ Eq (MeasureTheory.Measure.map (⇑MeasurableEquiv.prodAssoc) ((μ.prod ν).prod τ)) (μ.prod (ν.prod τ))","decl":"theorem prodAssoc_prod [SFinite τ] :\n    map MeasurableEquiv.prodAssoc ((μ.prod ν).prod τ) = μ.prod (ν.prod τ) := by\n  have : sum (fun (p : ℕ × ℕ × ℕ) ↦\n        (sfiniteSeq μ p.1).prod ((sfiniteSeq ν p.2.1).prod (sfiniteSeq τ p.2.2)))\n      = sum (fun (p : (ℕ × ℕ) × ℕ) ↦\n        (sfiniteSeq μ p.1.1).prod ((sfiniteSeq ν p.1.2).prod (sfiniteSeq τ p.2))) := by\n    ext s hs\n    rw [sum_apply _ hs, sum_apply _ hs, ← (Equiv.prodAssoc _ _ _).tsum_eq]\n    simp only [Equiv.prodAssoc_apply]\n  rw [← sum_sfiniteSeq μ, ← sum_sfiniteSeq ν, ← sum_sfiniteSeq τ, prod_sum, prod_sum,\n    map_sum MeasurableEquiv.prodAssoc.measurable.aemeasurable, prod_sum, prod_sum, this]\n  congr\n  ext1 i\n  refine (prod_eq_generateFrom generateFrom_measurableSet generateFrom_prod\n    isPiSystem_measurableSet isPiSystem_prod ((sfiniteSeq μ i.1.1)).toFiniteSpanningSetsIn\n    ((sfiniteSeq ν i.1.2).toFiniteSpanningSetsIn.prod (sfiniteSeq τ i.2).toFiniteSpanningSetsIn)\n      ?_).symm\n  rintro s hs _ ⟨t, ht, u, hu, rfl⟩; rw [mem_setOf_eq] at hs ht hu\n  simp_rw [map_apply (MeasurableEquiv.measurable _) (hs.prod (ht.prod hu)),\n    MeasurableEquiv.prodAssoc, MeasurableEquiv.coe_mk, Equiv.prod_assoc_preimage, prod_prod,\n    mul_assoc]\n\n"}
{"name":"MeasureTheory.Measure.prod_restrict","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : MeasureTheory.SFinite μ\ns : Set α\nt : Set β\n⊢ Eq ((μ.restrict s).prod (ν.restrict t)) ((μ.prod ν).restrict (SProd.sprod s t))","decl":"theorem prod_restrict (s : Set α) (t : Set β) :\n    (μ.restrict s).prod (ν.restrict t) = (μ.prod ν).restrict (s ×ˢ t) := by\n  rw [← sum_sfiniteSeq μ, ← sum_sfiniteSeq ν, restrict_sum_of_countable, restrict_sum_of_countable,\n    prod_sum, prod_sum, restrict_sum_of_countable]\n  congr 1\n  ext1 i\n  refine prod_eq fun s' t' hs' ht' => ?_\n  rw [restrict_apply (hs'.prod ht'), prod_inter_prod, prod_prod, restrict_apply hs',\n    restrict_apply ht']\n\n"}
{"name":"MeasureTheory.Measure.restrict_prod_eq_prod_univ","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : MeasureTheory.SFinite μ\ns : Set α\n⊢ Eq ((μ.restrict s).prod ν) ((μ.prod ν).restrict (SProd.sprod s Set.univ))","decl":"theorem restrict_prod_eq_prod_univ (s : Set α) :\n    (μ.restrict s).prod ν = (μ.prod ν).restrict (s ×ˢ univ) := by\n  have : ν = ν.restrict Set.univ := Measure.restrict_univ.symm\n  rw [this, Measure.prod_restrict, ← this]\n\n"}
{"name":"MeasureTheory.Measure.prod_dirac","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\ny : β\n⊢ Eq (μ.prod (MeasureTheory.Measure.dirac y)) (MeasureTheory.Measure.map (fun x => { fst := x, snd := y }) μ)","decl":"theorem prod_dirac (y : β) : μ.prod (dirac y) = map (fun x => (x, y)) μ := by\n  classical\n  rw [← sum_sfiniteSeq μ, prod_sum_left, map_sum measurable_prod_mk_right.aemeasurable]\n  congr\n  ext1 i\n  refine prod_eq fun s t hs ht => ?_\n  simp_rw [map_apply measurable_prod_mk_right (hs.prod ht), mk_preimage_prod_left_eq_if, measure_if,\n    dirac_apply' _ ht, ← indicator_mul_right _ fun _ => sfiniteSeq μ i s, Pi.one_apply, mul_one]\n\n"}
{"name":"MeasureTheory.Measure.dirac_prod","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\nx : α\n⊢ Eq ((MeasureTheory.Measure.dirac x).prod ν) (MeasureTheory.Measure.map (Prod.mk x) ν)","decl":"theorem dirac_prod (x : α) : (dirac x).prod ν = map (Prod.mk x) ν := by\n  classical\n  rw [← sum_sfiniteSeq ν, prod_sum_right, map_sum measurable_prod_mk_left.aemeasurable]\n  congr\n  ext1 i\n  refine prod_eq fun s t hs ht => ?_\n  simp_rw [map_apply measurable_prod_mk_left (hs.prod ht), mk_preimage_prod_right_eq_if, measure_if,\n    dirac_apply' _ hs, ← indicator_mul_left _ _ fun _ => sfiniteSeq ν i t, Pi.one_apply, one_mul]\n\n"}
{"name":"MeasureTheory.Measure.dirac_prod_dirac","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nx : α\ny : β\n⊢ Eq ((MeasureTheory.Measure.dirac x).prod (MeasureTheory.Measure.dirac y)) (MeasureTheory.Measure.dirac { fst := x, snd := y })","decl":"theorem dirac_prod_dirac {x : α} {y : β} : (dirac x).prod (dirac y) = dirac (x, y) := by\n  rw [prod_dirac, map_dirac measurable_prod_mk_right]\n\n"}
{"name":"MeasureTheory.Measure.prod_add","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : MeasurableSpace α\ninst✝³ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : MeasureTheory.SFinite μ\nν' : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν'\n⊢ Eq (μ.prod (HAdd.hAdd ν ν')) (HAdd.hAdd (μ.prod ν) (μ.prod ν'))","decl":"theorem prod_add (ν' : Measure β) [SFinite ν'] : μ.prod (ν + ν') = μ.prod ν + μ.prod ν' := by\n  simp_rw [← sum_sfiniteSeq ν, ← sum_sfiniteSeq ν', sum_add_sum, ← sum_sfiniteSeq μ, prod_sum,\n    sum_add_sum]\n  congr\n  ext1 i\n  refine prod_eq fun s t _ _ => ?_\n  simp_rw [add_apply, prod_prod, left_distrib]\n\n"}
{"name":"MeasureTheory.Measure.add_prod","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : MeasurableSpace α\ninst✝³ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : MeasureTheory.SFinite μ\nμ' : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ'\n⊢ Eq ((HAdd.hAdd μ μ').prod ν) (HAdd.hAdd (μ.prod ν) (μ'.prod ν))","decl":"theorem add_prod (μ' : Measure α) [SFinite μ'] : (μ + μ').prod ν = μ.prod ν + μ'.prod ν := by\n  simp_rw [← sum_sfiniteSeq μ, ← sum_sfiniteSeq μ', sum_add_sum, ← sum_sfiniteSeq ν, prod_sum,\n    sum_add_sum]\n  congr\n  ext1 i\n  refine prod_eq fun s t _ _ => ?_\n  simp_rw [add_apply, prod_prod, right_distrib]\n\n"}
{"name":"MeasureTheory.Measure.zero_prod","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nν : MeasureTheory.Measure β\n⊢ Eq (MeasureTheory.Measure.prod 0 ν) 0","decl":"@[simp]\ntheorem zero_prod (ν : Measure β) : (0 : Measure α).prod ν = 0 := by\n  rw [Measure.prod]\n  exact bind_zero_left _\n\n"}
{"name":"MeasureTheory.Measure.prod_zero","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ : MeasureTheory.Measure α\n⊢ Eq (μ.prod 0) 0","decl":"@[simp]\ntheorem prod_zero (μ : Measure α) : μ.prod (0 : Measure β) = 0 := by simp [Measure.prod]\n\n"}
{"name":"MeasureTheory.Measure.map_prod_map","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁵ : MeasurableSpace α\ninst✝⁴ : MeasurableSpace β\ninst✝³ : MeasurableSpace γ\nδ : Type u_4\ninst✝² : MeasurableSpace δ\nf : α → β\ng : γ → δ\nμa : MeasureTheory.Measure α\nμc : MeasureTheory.Measure γ\ninst✝¹ : MeasureTheory.SFinite μa\ninst✝ : MeasureTheory.SFinite μc\nhf : Measurable f\nhg : Measurable g\n⊢ Eq ((MeasureTheory.Measure.map f μa).prod (MeasureTheory.Measure.map g μc)) (MeasureTheory.Measure.map (Prod.map f g) (μa.prod μc))","decl":"theorem map_prod_map {δ} [MeasurableSpace δ] {f : α → β} {g : γ → δ} (μa : Measure α)\n    (μc : Measure γ) [SFinite μa] [SFinite μc] (hf : Measurable f) (hg : Measurable g) :\n    (map f μa).prod (map g μc) = map (Prod.map f g) (μa.prod μc) := by\n  simp_rw [← sum_sfiniteSeq μa, ← sum_sfiniteSeq μc, map_sum hf.aemeasurable,\n    map_sum hg.aemeasurable, prod_sum, map_sum (hf.prod_map hg).aemeasurable]\n  congr\n  ext1 i\n  refine prod_eq fun s t hs ht => ?_\n  rw [map_apply (hf.prod_map hg) (hs.prod ht), map_apply hf hs, map_apply hg ht]\n  exact prod_prod (f ⁻¹' s) (g ⁻¹' t)\n\n"}
{"name":"MeasureTheory.MeasurePreserving.skew_product","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁵ : MeasurableSpace α\ninst✝⁴ : MeasurableSpace β\ninst✝³ : MeasurableSpace γ\nδ : Type u_4\ninst✝² : MeasurableSpace δ\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\nμc : MeasureTheory.Measure γ\nμd : MeasureTheory.Measure δ\ninst✝¹ : MeasureTheory.SFinite μa\ninst✝ : MeasureTheory.SFinite μc\nf : α → β\nhf : MeasureTheory.MeasurePreserving f μa μb\ng : α → γ → δ\nhgm : Measurable (Function.uncurry g)\nhg : Filter.Eventually (fun a => Eq (MeasureTheory.Measure.map (g a) μc) μd) (MeasureTheory.ae μa)\n⊢ MeasureTheory.MeasurePreserving (fun p => { fst := f p.1, snd := g p.1 p.2 }) (μa.prod μc) (μb.prod μd)","decl":"/-- Let `f : α → β` be a measure preserving map.\nFor a.e. all `a`, let `g a : γ → δ` be a measure preserving map.\nAlso suppose that `g` is measurable as a function of two arguments.\nThen the map `fun (a, c) ↦ (f a, g a c)` is a measure preserving map\nfor the product measures on `α × γ` and `β × δ`.\n\nSome authors call a map of the form `fun (a, c) ↦ (f a, g a c)` a *skew product* over `f`,\nthus the choice of a name.\n-/\ntheorem skew_product [SFinite μa] [SFinite μc] {f : α → β} (hf : MeasurePreserving f μa μb)\n    {g : α → γ → δ} (hgm : Measurable (uncurry g)) (hg : ∀ᵐ a ∂μa, map (g a) μc = μd) :\n    MeasurePreserving (fun p : α × γ => (f p.1, g p.1 p.2)) (μa.prod μc) (μb.prod μd) := by\n  have : Measurable fun p : α × γ => (f p.1, g p.1 p.2) := (hf.1.comp measurable_fst).prod_mk hgm\n  use this\n  /- if `μa = 0`, then the lemma is trivial, otherwise we can use `hg`\n    to deduce `SFinite μd`. -/\n  rcases eq_zero_or_neZero μa with rfl | _\n  · simp [← hf.map_eq]\n  have sf : SFinite μd := by\n    obtain ⟨a, ha⟩ : ∃ a, map (g a) μc = μd := hg.exists\n    rw [← ha]\n    infer_instance\n  -- Thus we can use the integral formula for the product measure, and compute things explicitly\n  ext s hs\n  rw [map_apply this hs, prod_apply (this hs), prod_apply hs,\n    ← hf.lintegral_comp (measurable_measure_prod_mk_left hs)]\n  apply lintegral_congr_ae\n  filter_upwards [hg] with a ha\n  rw [← ha, map_apply hgm.of_uncurry_left (measurable_prod_mk_left hs), preimage_preimage,\n    preimage_preimage]\n\n"}
{"name":"MeasureTheory.MeasurePreserving.prod","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁵ : MeasurableSpace α\ninst✝⁴ : MeasurableSpace β\ninst✝³ : MeasurableSpace γ\nδ : Type u_4\ninst✝² : MeasurableSpace δ\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\nμc : MeasureTheory.Measure γ\nμd : MeasureTheory.Measure δ\ninst✝¹ : MeasureTheory.SFinite μa\ninst✝ : MeasureTheory.SFinite μc\nf : α → β\ng : γ → δ\nhf : MeasureTheory.MeasurePreserving f μa μb\nhg : MeasureTheory.MeasurePreserving g μc μd\n⊢ MeasureTheory.MeasurePreserving (Prod.map f g) (μa.prod μc) (μb.prod μd)","decl":"/-- If `f : α → β` sends the measure `μa` to `μb` and `g : γ → δ` sends the measure `μc` to `μd`,\nthen `Prod.map f g` sends `μa.prod μc` to `μb.prod μd`. -/\nprotected theorem prod [SFinite μa] [SFinite μc] {f : α → β} {g : γ → δ}\n    (hf : MeasurePreserving f μa μb) (hg : MeasurePreserving g μc μd) :\n    MeasurePreserving (Prod.map f g) (μa.prod μc) (μb.prod μd) :=\n  have : Measurable (uncurry fun _ : α => g) := hg.1.comp measurable_snd\n  hf.skew_product this <| ae_of_all _ fun _ => hg.map_eq\n\n"}
{"name":"MeasureTheory.QuasiMeasurePreserving.prod_of_right","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\ninst✝¹ : MeasurableSpace γ\nf : Prod α β → γ\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\nτ : MeasureTheory.Measure γ\nhf : Measurable f\ninst✝ : MeasureTheory.SFinite ν\nh2f : Filter.Eventually (fun x => MeasureTheory.Measure.QuasiMeasurePreserving (fun y => f { fst := x, snd := y }) ν τ) (MeasureTheory.ae μ)\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving f (μ.prod ν) τ","decl":"theorem prod_of_right {f : α × β → γ} {μ : Measure α} {ν : Measure β} {τ : Measure γ}\n    (hf : Measurable f) [SFinite ν]\n    (h2f : ∀ᵐ x ∂μ, QuasiMeasurePreserving (fun y => f (x, y)) ν τ) :\n    QuasiMeasurePreserving f (μ.prod ν) τ := by\n  refine ⟨hf, ?_⟩\n  refine AbsolutelyContinuous.mk fun s hs h2s => ?_\n  rw [map_apply hf hs, prod_apply (hf hs)]; simp_rw [preimage_preimage]\n  rw [lintegral_congr_ae (h2f.mono fun x hx => hx.preimage_null h2s), lintegral_zero]\n\n"}
{"name":"MeasureTheory.QuasiMeasurePreserving.prod_of_left","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_4\nβ : Type u_5\nγ : Type u_6\ninst✝⁴ : MeasurableSpace α\ninst✝³ : MeasurableSpace β\ninst✝² : MeasurableSpace γ\nf : Prod α β → γ\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\nτ : MeasureTheory.Measure γ\nhf : Measurable f\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : MeasureTheory.SFinite ν\nh2f : Filter.Eventually (fun y => MeasureTheory.Measure.QuasiMeasurePreserving (fun x => f { fst := x, snd := y }) μ τ) (MeasureTheory.ae ν)\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving f (μ.prod ν) τ","decl":"theorem prod_of_left {α β γ} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n    {f : α × β → γ} {μ : Measure α} {ν : Measure β} {τ : Measure γ} (hf : Measurable f)\n    [SFinite μ] [SFinite ν]\n    (h2f : ∀ᵐ y ∂ν, QuasiMeasurePreserving (fun x => f (x, y)) μ τ) :\n    QuasiMeasurePreserving f (μ.prod ν) τ := by\n  rw [← prod_swap]\n  convert (QuasiMeasurePreserving.prod_of_right (hf.comp measurable_swap) h2f).comp\n      ((measurable_swap.measurePreserving (ν.prod μ)).symm\n          MeasurableEquiv.prodComm).quasiMeasurePreserving\n\n"}
{"name":"AEMeasurable.prod_swap","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : MeasurableSpace α\ninst✝³ : MeasurableSpace β\ninst✝² : MeasurableSpace γ\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : MeasureTheory.SFinite ν\nf : Prod β α → γ\nhf : AEMeasurable f (ν.prod μ)\n⊢ AEMeasurable (fun z => f z.swap) (μ.prod ν)","decl":"theorem AEMeasurable.prod_swap [SFinite μ] [SFinite ν] {f : β × α → γ}\n    (hf : AEMeasurable f (ν.prod μ)) : AEMeasurable (fun z : α × β => f z.swap) (μ.prod ν) := by\n  rw [← Measure.prod_swap] at hf\n  exact hf.comp_measurable measurable_swap\n\n-- TODO: make this theorem usable with `fun_prop`\n"}
{"name":"AEMeasurable.fst","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\ninst✝¹ : MeasurableSpace γ\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\nf : α → γ\nhf : AEMeasurable f μ\n⊢ AEMeasurable (fun z => f z.1) (μ.prod ν)","decl":"theorem AEMeasurable.fst [SFinite ν] {f : α → γ} (hf : AEMeasurable f μ) :\n    AEMeasurable (fun z : α × β => f z.1) (μ.prod ν) :=\n  hf.comp_quasiMeasurePreserving quasiMeasurePreserving_fst\n\n-- TODO: make this theorem usable with `fun_prop`\n"}
{"name":"AEMeasurable.snd","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\ninst✝¹ : MeasurableSpace γ\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\nf : β → γ\nhf : AEMeasurable f ν\n⊢ AEMeasurable (fun z => f z.2) (μ.prod ν)","decl":"theorem AEMeasurable.snd [SFinite ν] {f : β → γ} (hf : AEMeasurable f ν) :\n    AEMeasurable (fun z : α × β => f z.2) (μ.prod ν) :=\n  hf.comp_quasiMeasurePreserving quasiMeasurePreserving_snd\n\n"}
{"name":"MeasureTheory.lintegral_prod_swap","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : MeasureTheory.SFinite μ\nf : Prod α β → ENNReal\n⊢ Eq (MeasureTheory.lintegral (ν.prod μ) fun z => f z.swap) (MeasureTheory.lintegral (μ.prod ν) fun z => f z)","decl":"theorem lintegral_prod_swap [SFinite μ] (f : α × β → ℝ≥0∞) :\n    ∫⁻ z, f z.swap ∂ν.prod μ = ∫⁻ z, f z ∂μ.prod ν :=\n  measurePreserving_swap.lintegral_comp_emb MeasurableEquiv.prodComm.measurableEmbedding f\n\n"}
{"name":"MeasureTheory.lintegral_prod_of_measurable","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\nf : Prod α β → ENNReal\na✝ : Measurable f\n⊢ Eq (MeasureTheory.lintegral (μ.prod ν) fun z => f z) (MeasureTheory.lintegral μ fun x => MeasureTheory.lintegral ν fun y => f { fst := x, snd := y })","decl":"/-- **Tonelli's Theorem**: For `ℝ≥0∞`-valued measurable functions on `α × β`,\n  the integral of `f` is equal to the iterated integral. -/\ntheorem lintegral_prod_of_measurable :\n    ∀ (f : α × β → ℝ≥0∞), Measurable f → ∫⁻ z, f z ∂μ.prod ν = ∫⁻ x, ∫⁻ y, f (x, y) ∂ν ∂μ := by\n  have m := @measurable_prod_mk_left\n  refine Measurable.ennreal_induction\n    (P := fun f => ∫⁻ z, f z ∂μ.prod ν = ∫⁻ x, ∫⁻ y, f (x, y) ∂ν ∂μ) ?_ ?_ ?_\n  · intro c s hs\n    conv_rhs =>\n      enter [2, x, 2, y]\n      rw [← indicator_comp_right, const_def, const_comp, ← const_def]\n    conv_rhs =>\n      enter [2, x]\n      rw [lintegral_indicator (m (x := x) hs), lintegral_const,\n        Measure.restrict_apply MeasurableSet.univ, univ_inter]\n    simp [hs, lintegral_const_mul, measurable_measure_prod_mk_left (ν := ν) hs, prod_apply]\n  · rintro f g - hf _ h2f h2g\n    simp only [Pi.add_apply]\n    conv_lhs => rw [lintegral_add_left hf]\n    conv_rhs => enter [2, x]; erw [lintegral_add_left (hf.comp (m (x := x)))]\n    simp [lintegral_add_left, Measurable.lintegral_prod_right', hf, h2f, h2g]\n  · intro f hf h2f h3f\n    have kf : ∀ x n, Measurable fun y => f n (x, y) := fun x n => (hf n).comp m\n    have k2f : ∀ x, Monotone fun n y => f n (x, y) := fun x i j hij y => h2f hij (x, y)\n    have lf : ∀ n, Measurable fun x => ∫⁻ y, f n (x, y) ∂ν := fun n => (hf n).lintegral_prod_right'\n    have l2f : Monotone fun n x => ∫⁻ y, f n (x, y) ∂ν := fun i j hij x =>\n      lintegral_mono (k2f x hij)\n    simp only [lintegral_iSup hf h2f, lintegral_iSup (kf _), k2f, lintegral_iSup lf l2f, h3f]\n\n"}
{"name":"MeasureTheory.lintegral_prod","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\nf : Prod α β → ENNReal\nhf : AEMeasurable f (μ.prod ν)\n⊢ Eq (MeasureTheory.lintegral (μ.prod ν) fun z => f z) (MeasureTheory.lintegral μ fun x => MeasureTheory.lintegral ν fun y => f { fst := x, snd := y })","decl":"/-- **Tonelli's Theorem**: For `ℝ≥0∞`-valued almost everywhere measurable functions on `α × β`,\n  the integral of `f` is equal to the iterated integral. -/\ntheorem lintegral_prod (f : α × β → ℝ≥0∞) (hf : AEMeasurable f (μ.prod ν)) :\n    ∫⁻ z, f z ∂μ.prod ν = ∫⁻ x, ∫⁻ y, f (x, y) ∂ν ∂μ := by\n  have A : ∫⁻ z, f z ∂μ.prod ν = ∫⁻ z, hf.mk f z ∂μ.prod ν := lintegral_congr_ae hf.ae_eq_mk\n  have B : (∫⁻ x, ∫⁻ y, f (x, y) ∂ν ∂μ) = ∫⁻ x, ∫⁻ y, hf.mk f (x, y) ∂ν ∂μ := by\n    apply lintegral_congr_ae\n    filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk] with _ ha using lintegral_congr_ae ha\n  rw [A, B, lintegral_prod_of_measurable _ hf.measurable_mk]\n\n"}
{"name":"MeasureTheory.lintegral_prod_symm","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : MeasureTheory.SFinite μ\nf : Prod α β → ENNReal\nhf : AEMeasurable f (μ.prod ν)\n⊢ Eq (MeasureTheory.lintegral (μ.prod ν) fun z => f z) (MeasureTheory.lintegral ν fun y => MeasureTheory.lintegral μ fun x => f { fst := x, snd := y })","decl":"/-- The symmetric version of Tonelli's Theorem: For `ℝ≥0∞`-valued almost everywhere measurable\nfunctions on `α × β`, the integral of `f` is equal to the iterated integral, in reverse order. -/\ntheorem lintegral_prod_symm [SFinite μ] (f : α × β → ℝ≥0∞) (hf : AEMeasurable f (μ.prod ν)) :\n    ∫⁻ z, f z ∂μ.prod ν = ∫⁻ y, ∫⁻ x, f (x, y) ∂μ ∂ν := by\n  simp_rw [← lintegral_prod_swap f]\n  exact lintegral_prod _ hf.prod_swap\n\n"}
{"name":"MeasureTheory.lintegral_prod_symm'","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : MeasureTheory.SFinite μ\nf : Prod α β → ENNReal\nhf : Measurable f\n⊢ Eq (MeasureTheory.lintegral (μ.prod ν) fun z => f z) (MeasureTheory.lintegral ν fun y => MeasureTheory.lintegral μ fun x => f { fst := x, snd := y })","decl":"/-- The symmetric version of Tonelli's Theorem: For `ℝ≥0∞`-valued measurable\nfunctions on `α × β`, the integral of `f` is equal to the iterated integral, in reverse order. -/\ntheorem lintegral_prod_symm' [SFinite μ] (f : α × β → ℝ≥0∞) (hf : Measurable f) :\n    ∫⁻ z, f z ∂μ.prod ν = ∫⁻ y, ∫⁻ x, f (x, y) ∂μ ∂ν :=\n  lintegral_prod_symm f hf.aemeasurable\n\n"}
{"name":"MeasureTheory.lintegral_lintegral","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\nf : α → β → ENNReal\nhf : AEMeasurable (Function.uncurry f) (μ.prod ν)\n⊢ Eq (MeasureTheory.lintegral μ fun x => MeasureTheory.lintegral ν fun y => f x y) (MeasureTheory.lintegral (μ.prod ν) fun z => f z.1 z.2)","decl":"/-- The reversed version of **Tonelli's Theorem**. In this version `f` is in curried form, which\nmakes it easier for the elaborator to figure out `f` automatically. -/\ntheorem lintegral_lintegral ⦃f : α → β → ℝ≥0∞⦄ (hf : AEMeasurable (uncurry f) (μ.prod ν)) :\n    ∫⁻ x, ∫⁻ y, f x y ∂ν ∂μ = ∫⁻ z, f z.1 z.2 ∂μ.prod ν :=\n  (lintegral_prod _ hf).symm\n\n"}
{"name":"MeasureTheory.lintegral_lintegral_symm","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : MeasureTheory.SFinite μ\nf : α → β → ENNReal\nhf : AEMeasurable (Function.uncurry f) (μ.prod ν)\n⊢ Eq (MeasureTheory.lintegral μ fun x => MeasureTheory.lintegral ν fun y => f x y) (MeasureTheory.lintegral (ν.prod μ) fun z => f z.2 z.1)","decl":"/-- The reversed version of **Tonelli's Theorem** (symmetric version). In this version `f` is in\ncurried form, which makes it easier for the elaborator to figure out `f` automatically. -/\ntheorem lintegral_lintegral_symm [SFinite μ] ⦃f : α → β → ℝ≥0∞⦄\n    (hf : AEMeasurable (uncurry f) (μ.prod ν)) :\n    ∫⁻ x, ∫⁻ y, f x y ∂ν ∂μ = ∫⁻ z, f z.2 z.1 ∂ν.prod μ :=\n  (lintegral_prod_symm _ hf.prod_swap).symm\n\n"}
{"name":"MeasureTheory.lintegral_lintegral_swap","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : MeasureTheory.SFinite μ\nf : α → β → ENNReal\nhf : AEMeasurable (Function.uncurry f) (μ.prod ν)\n⊢ Eq (MeasureTheory.lintegral μ fun x => MeasureTheory.lintegral ν fun y => f x y) (MeasureTheory.lintegral ν fun y => MeasureTheory.lintegral μ fun x => f x y)","decl":"/-- Change the order of Lebesgue integration. -/\ntheorem lintegral_lintegral_swap [SFinite μ] ⦃f : α → β → ℝ≥0∞⦄\n    (hf : AEMeasurable (uncurry f) (μ.prod ν)) :\n    ∫⁻ x, ∫⁻ y, f x y ∂ν ∂μ = ∫⁻ y, ∫⁻ x, f x y ∂μ ∂ν :=\n  (lintegral_lintegral hf).trans (lintegral_prod_symm _ hf)\n\n"}
{"name":"MeasureTheory.lintegral_prod_mul","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite ν\nf : α → ENNReal\ng : β → ENNReal\nhf : AEMeasurable f μ\nhg : AEMeasurable g ν\n⊢ Eq (MeasureTheory.lintegral (μ.prod ν) fun z => HMul.hMul (f z.1) (g z.2)) (HMul.hMul (MeasureTheory.lintegral μ fun x => f x) (MeasureTheory.lintegral ν fun y => g y))","decl":"theorem lintegral_prod_mul {f : α → ℝ≥0∞} {g : β → ℝ≥0∞} (hf : AEMeasurable f μ)\n    (hg : AEMeasurable g ν) : ∫⁻ z, f z.1 * g z.2 ∂μ.prod ν = (∫⁻ x, f x ∂μ) * ∫⁻ y, g y ∂ν := by\n  simp [lintegral_prod _ (hf.fst.mul hg.snd), lintegral_lintegral_mul hf hg]\n\n"}
{"name":"MeasureTheory.Measure.fst_apply","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nρ : MeasureTheory.Measure (Prod α β)\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (ρ.fst s) (ρ (Set.preimage Prod.fst s))","decl":"theorem fst_apply {s : Set α} (hs : MeasurableSet s) : ρ.fst s = ρ (Prod.fst ⁻¹' s) := by\n  rw [fst, Measure.map_apply measurable_fst hs]\n\n"}
{"name":"MeasureTheory.Measure.fst_univ","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nρ : MeasureTheory.Measure (Prod α β)\n⊢ Eq (ρ.fst Set.univ) (ρ Set.univ)","decl":"theorem fst_univ : ρ.fst univ = ρ univ := by rw [fst_apply MeasurableSet.univ, preimage_univ]\n\n"}
{"name":"MeasureTheory.Measure.fst_zero","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\n⊢ Eq (MeasureTheory.Measure.fst 0) 0","decl":"@[simp] theorem fst_zero : fst (0 : Measure (α × β)) = 0 := by simp [fst]\n\n"}
{"name":"MeasureTheory.Measure.instSFiniteFstOfProd","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nρ : MeasureTheory.Measure (Prod α β)\ninst✝ : MeasureTheory.SFinite ρ\n⊢ MeasureTheory.SFinite ρ.fst","decl":"instance [SFinite ρ] : SFinite ρ.fst := by\n  rw [fst]\n  infer_instance\n\n"}
{"name":"MeasureTheory.Measure.fst.instIsFiniteMeasure","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nρ : MeasureTheory.Measure (Prod α β)\ninst✝ : MeasureTheory.IsFiniteMeasure ρ\n⊢ MeasureTheory.IsFiniteMeasure ρ.fst","decl":"instance fst.instIsFiniteMeasure [IsFiniteMeasure ρ] : IsFiniteMeasure ρ.fst := by\n  rw [fst]\n  infer_instance\n\n"}
{"name":"MeasureTheory.Measure.fst.instIsProbabilityMeasure","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nρ : MeasureTheory.Measure (Prod α β)\ninst✝ : MeasureTheory.IsProbabilityMeasure ρ\n⊢ MeasureTheory.IsProbabilityMeasure ρ.fst","decl":"instance fst.instIsProbabilityMeasure [IsProbabilityMeasure ρ] : IsProbabilityMeasure ρ.fst where\n  measure_univ := by\n    rw [fst_univ]\n    exact measure_univ\n\n"}
{"name":"MeasureTheory.Measure.fst.instIsZeroOrProbabilityMeasure","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nρ : MeasureTheory.Measure (Prod α β)\ninst✝ : MeasureTheory.IsZeroOrProbabilityMeasure ρ\n⊢ MeasureTheory.IsZeroOrProbabilityMeasure ρ.fst","decl":"instance fst.instIsZeroOrProbabilityMeasure [IsZeroOrProbabilityMeasure ρ] :\n    IsZeroOrProbabilityMeasure ρ.fst := by\n  rcases eq_zero_or_isProbabilityMeasure ρ with h | h\n  · simp only [h, fst_zero]\n    infer_instance\n  · infer_instance\n\n"}
{"name":"MeasureTheory.Measure.fst_prod","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : MeasureTheory.IsProbabilityMeasure ν\n⊢ Eq (μ.prod ν).fst μ","decl":"@[simp]\nlemma fst_prod [IsProbabilityMeasure ν] : (μ.prod ν).fst = μ := by\n  ext1 s hs\n  rw [fst_apply hs, ← prod_univ, prod_prod, measure_univ, mul_one]\n\n"}
{"name":"MeasureTheory.Measure.fst_map_prod_mk₀","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nX : α → β\nY : α → γ\nμ : MeasureTheory.Measure α\nhY : AEMeasurable Y μ\n⊢ Eq (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ).fst (MeasureTheory.Measure.map X μ)","decl":"theorem fst_map_prod_mk₀ {X : α → β} {Y : α → γ} {μ : Measure α}\n    (hY : AEMeasurable Y μ) : (μ.map fun a => (X a, Y a)).fst = μ.map X := by\n  by_cases hX : AEMeasurable X μ\n  · ext1 s hs\n    rw [Measure.fst_apply hs, Measure.map_apply_of_aemeasurable (hX.prod_mk hY) (measurable_fst hs),\n      Measure.map_apply_of_aemeasurable hX hs, ← prod_univ, mk_preimage_prod, preimage_univ,\n      inter_univ]\n  · have : ¬AEMeasurable (fun x ↦ (X x, Y x)) μ := by\n      contrapose! hX; exact measurable_fst.comp_aemeasurable hX\n    simp [map_of_not_aemeasurable, hX, this]\n\n"}
{"name":"MeasureTheory.Measure.fst_map_prod_mk","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nX : α → β\nY : α → γ\nμ : MeasureTheory.Measure α\nhY : Measurable Y\n⊢ Eq (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ).fst (MeasureTheory.Measure.map X μ)","decl":"theorem fst_map_prod_mk {X : α → β} {Y : α → γ} {μ : Measure α}\n    (hY : Measurable Y) : (μ.map fun a => (X a, Y a)).fst = μ.map X :=\n  fst_map_prod_mk₀ hY.aemeasurable\n\n"}
{"name":"MeasureTheory.Measure.fst_add","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ ν : MeasureTheory.Measure (Prod α β)\n⊢ Eq (HAdd.hAdd μ ν).fst (HAdd.hAdd μ.fst ν.fst)","decl":"@[simp]\nlemma fst_add {μ ν : Measure (α × β)} : (μ + ν).fst = μ.fst + ν.fst := by\n  ext s hs\n  simp_rw [coe_add, Pi.add_apply, fst_apply hs, coe_add, Pi.add_apply]\n\n"}
{"name":"MeasureTheory.Measure.fst_sum","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nι : Type u_4\nμ : ι → MeasureTheory.Measure (Prod α β)\n⊢ Eq (MeasureTheory.Measure.sum μ).fst (MeasureTheory.Measure.sum fun n => (μ n).fst)","decl":"lemma fst_sum {ι : Type*} (μ : ι → Measure (α × β)) : (sum μ).fst = sum (fun n ↦ (μ n).fst) := by\n  ext s hs\n  rw [fst_apply hs, sum_apply, sum_apply _ hs]\n  · simp_rw [fst_apply hs]\n  · exact measurable_fst hs\n\n"}
{"name":"MeasureTheory.Measure.fst_mono","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nρ μ : MeasureTheory.Measure (Prod α β)\nh : LE.le ρ μ\n⊢ LE.le ρ.fst μ.fst","decl":"@[gcongr]\ntheorem fst_mono {μ : Measure (α × β)} (h : ρ ≤ μ) : ρ.fst ≤ μ.fst := map_mono h measurable_fst\n\n"}
{"name":"MeasureTheory.Measure.snd_apply","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nρ : MeasureTheory.Measure (Prod α β)\ns : Set β\nhs : MeasurableSet s\n⊢ Eq (ρ.snd s) (ρ (Set.preimage Prod.snd s))","decl":"theorem snd_apply {s : Set β} (hs : MeasurableSet s) : ρ.snd s = ρ (Prod.snd ⁻¹' s) := by\n  rw [snd, Measure.map_apply measurable_snd hs]\n\n"}
{"name":"MeasureTheory.Measure.snd_univ","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nρ : MeasureTheory.Measure (Prod α β)\n⊢ Eq (ρ.snd Set.univ) (ρ Set.univ)","decl":"theorem snd_univ : ρ.snd univ = ρ univ := by rw [snd_apply MeasurableSet.univ, preimage_univ]\n\n"}
{"name":"MeasureTheory.Measure.snd_zero","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\n⊢ Eq (MeasureTheory.Measure.snd 0) 0","decl":"@[simp] theorem snd_zero : snd (0 : Measure (α × β)) = 0 := by simp [snd]\n\n"}
{"name":"MeasureTheory.Measure.instSFiniteSndOfProd","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nρ : MeasureTheory.Measure (Prod α β)\ninst✝ : MeasureTheory.SFinite ρ\n⊢ MeasureTheory.SFinite ρ.snd","decl":"instance [SFinite ρ] : SFinite ρ.snd := by\n  rw [snd]\n  infer_instance\n\n"}
{"name":"MeasureTheory.Measure.snd.instIsFiniteMeasure","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nρ : MeasureTheory.Measure (Prod α β)\ninst✝ : MeasureTheory.IsFiniteMeasure ρ\n⊢ MeasureTheory.IsFiniteMeasure ρ.snd","decl":"instance snd.instIsFiniteMeasure [IsFiniteMeasure ρ] : IsFiniteMeasure ρ.snd := by\n  rw [snd]\n  infer_instance\n\n"}
{"name":"MeasureTheory.Measure.snd.instIsProbabilityMeasure","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nρ : MeasureTheory.Measure (Prod α β)\ninst✝ : MeasureTheory.IsProbabilityMeasure ρ\n⊢ MeasureTheory.IsProbabilityMeasure ρ.snd","decl":"instance snd.instIsProbabilityMeasure [IsProbabilityMeasure ρ] : IsProbabilityMeasure ρ.snd where\n  measure_univ := by\n    rw [snd_univ]\n    exact measure_univ\n\n"}
{"name":"MeasureTheory.Measure.snd.instIsZeroOrProbabilityMeasure","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nρ : MeasureTheory.Measure (Prod α β)\ninst✝ : MeasureTheory.IsZeroOrProbabilityMeasure ρ\n⊢ MeasureTheory.IsZeroOrProbabilityMeasure ρ.snd","decl":"instance snd.instIsZeroOrProbabilityMeasure [IsZeroOrProbabilityMeasure ρ] :\n    IsZeroOrProbabilityMeasure ρ.snd := by\n  rcases eq_zero_or_isProbabilityMeasure ρ with h | h\n  · simp only [h, snd_zero]\n    infer_instance\n  · infer_instance\n\n"}
{"name":"MeasureTheory.Measure.snd_prod","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite ν\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\n⊢ Eq (μ.prod ν).snd ν","decl":"@[simp]\nlemma snd_prod [IsProbabilityMeasure μ] : (μ.prod ν).snd = ν := by\n  ext1 s hs\n  rw [snd_apply hs, ← univ_prod, prod_prod, measure_univ, one_mul]\n\n"}
{"name":"MeasureTheory.Measure.snd_map_prod_mk₀","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nX : α → β\nY : α → γ\nμ : MeasureTheory.Measure α\nhX : AEMeasurable X μ\n⊢ Eq (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ).snd (MeasureTheory.Measure.map Y μ)","decl":"theorem snd_map_prod_mk₀ {X : α → β} {Y : α → γ} {μ : Measure α} (hX : AEMeasurable X μ) :\n    (μ.map fun a => (X a, Y a)).snd = μ.map Y := by\n  by_cases hY : AEMeasurable Y μ\n  · ext1 s hs\n    rw [Measure.snd_apply hs, Measure.map_apply_of_aemeasurable (hX.prod_mk hY) (measurable_snd hs),\n      Measure.map_apply_of_aemeasurable hY hs, ← univ_prod, mk_preimage_prod, preimage_univ,\n      univ_inter]\n  · have : ¬AEMeasurable (fun x ↦ (X x, Y x)) μ := by\n      contrapose! hY; exact measurable_snd.comp_aemeasurable hY\n    simp [map_of_not_aemeasurable, hY, this]\n\n"}
{"name":"MeasureTheory.Measure.snd_map_prod_mk","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nX : α → β\nY : α → γ\nμ : MeasureTheory.Measure α\nhX : Measurable X\n⊢ Eq (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ).snd (MeasureTheory.Measure.map Y μ)","decl":"theorem snd_map_prod_mk {X : α → β} {Y : α → γ} {μ : Measure α} (hX : Measurable X) :\n    (μ.map fun a => (X a, Y a)).snd = μ.map Y :=\n  snd_map_prod_mk₀ hX.aemeasurable\n\n"}
{"name":"MeasureTheory.Measure.snd_add","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ ν : MeasureTheory.Measure (Prod α β)\n⊢ Eq (HAdd.hAdd μ ν).snd (HAdd.hAdd μ.snd ν.snd)","decl":"@[simp]\nlemma snd_add {μ ν : Measure (α × β)} : (μ + ν).snd = μ.snd + ν.snd := by\n  ext s hs\n  simp_rw [coe_add, Pi.add_apply, snd_apply hs, coe_add, Pi.add_apply]\n\n"}
{"name":"MeasureTheory.Measure.snd_sum","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nι : Type u_4\nμ : ι → MeasureTheory.Measure (Prod α β)\n⊢ Eq (MeasureTheory.Measure.sum μ).snd (MeasureTheory.Measure.sum fun n => (μ n).snd)","decl":"lemma snd_sum {ι : Type*} (μ : ι → Measure (α × β)) : (sum μ).snd = sum (fun n ↦ (μ n).snd) := by\n  ext s hs\n  rw [snd_apply hs, sum_apply, sum_apply _ hs]\n  · simp_rw [snd_apply hs]\n  · exact measurable_snd hs\n\n"}
{"name":"MeasureTheory.Measure.snd_mono","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nρ μ : MeasureTheory.Measure (Prod α β)\nh : LE.le ρ μ\n⊢ LE.le ρ.snd μ.snd","decl":"@[gcongr]\ntheorem snd_mono {μ : Measure (α × β)} (h : ρ ≤ μ) : ρ.snd ≤ μ.snd := map_mono h measurable_snd\n\n"}
{"name":"MeasureTheory.Measure.fst_map_swap","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nρ : MeasureTheory.Measure (Prod α β)\n⊢ Eq (MeasureTheory.Measure.map Prod.swap ρ).fst ρ.snd","decl":"@[simp] lemma fst_map_swap : (ρ.map Prod.swap).fst = ρ.snd := by\n  rw [Measure.fst, Measure.map_map measurable_fst measurable_swap]\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.snd_map_swap","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nρ : MeasureTheory.Measure (Prod α β)\n⊢ Eq (MeasureTheory.Measure.map Prod.swap ρ).snd ρ.fst","decl":"@[simp] lemma snd_map_swap : (ρ.map Prod.swap).snd = ρ.fst := by\n  rw [Measure.snd, Measure.map_map measurable_snd measurable_swap]\n  rfl\n\n"}
{"name":"MeasureTheory.measurePreserving_prodAssoc","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : MeasurableSpace α\ninst✝³ : MeasurableSpace β\ninst✝² : MeasurableSpace γ\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\nμc : MeasureTheory.Measure γ\ninst✝¹ : MeasureTheory.SFinite μb\ninst✝ : MeasureTheory.SFinite μc\n⊢ MeasureTheory.MeasurePreserving (⇑MeasurableEquiv.prodAssoc) ((μa.prod μb).prod μc) (μa.prod (μb.prod μc))","decl":"/-- The measurable equiv induced by the equiv `(α × β) × γ ≃ α × (β × γ)` is measure preserving. -/\ntheorem _root_.MeasureTheory.measurePreserving_prodAssoc (μa : Measure α) (μb : Measure β)\n    (μc : Measure γ) [SFinite μb] [SFinite μc] :\n    MeasurePreserving (MeasurableEquiv.prodAssoc : (α × β) × γ ≃ᵐ α × β × γ)\n      ((μa.prod μb).prod μc) (μa.prod (μb.prod μc)) where\n  measurable := MeasurableEquiv.prodAssoc.measurable\n  map_eq := by\n    ext s hs\n    have A (x : α) : MeasurableSet (Prod.mk x ⁻¹' s) := measurable_prod_mk_left hs\n    have B : MeasurableSet (MeasurableEquiv.prodAssoc ⁻¹' s) :=\n      MeasurableEquiv.prodAssoc.measurable hs\n    simp_rw [map_apply MeasurableEquiv.prodAssoc.measurable hs, prod_apply hs, prod_apply (A _),\n      prod_apply B, lintegral_prod _ (measurable_measure_prod_mk_left B).aemeasurable]\n    rfl\n\n"}
{"name":"MeasureTheory.volume_preserving_prodAssoc","module":"Mathlib.MeasureTheory.Measure.Prod","initialProofState":"α₁ : Type u_4\nβ₁ : Type u_5\nγ₁ : Type u_6\ninst✝⁴ : MeasureTheory.MeasureSpace α₁\ninst✝³ : MeasureTheory.MeasureSpace β₁\ninst✝² : MeasureTheory.MeasureSpace γ₁\ninst✝¹ : MeasureTheory.SFinite MeasureTheory.MeasureSpace.volume\ninst✝ : MeasureTheory.SFinite MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.MeasurePreserving (⇑MeasurableEquiv.prodAssoc) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"theorem _root_.MeasureTheory.volume_preserving_prodAssoc {α₁ β₁ γ₁ : Type*} [MeasureSpace α₁]\n    [MeasureSpace β₁] [MeasureSpace γ₁] [SFinite (volume : Measure β₁)]\n    [SFinite (volume : Measure γ₁)] :\n    MeasurePreserving (MeasurableEquiv.prodAssoc : (α₁ × β₁) × γ₁ ≃ᵐ α₁ × β₁ × γ₁) :=\n  MeasureTheory.measurePreserving_prodAssoc volume volume volume\n\n"}
