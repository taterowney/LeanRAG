{"name":"CantorScheme.map_mem","module":"Mathlib.Topology.MetricSpace.CantorScheme","initialProofState":"β : Type u_1\nα : Type u_2\nA : List β → Set α\nx : ↑(CantorScheme.inducedMap A).fst\nn : Nat\n⊢ Membership.mem (A (PiNat.res (↑x) n)) ((CantorScheme.inducedMap A).snd x)","decl":"/-- If `x` is in the domain of the induced map of a scheme `A`,\nits image under this map is in each set along the corresponding branch. -/\ntheorem map_mem (x : (inducedMap A).1) (n : ℕ) : (inducedMap A).2 x ∈ A (res x n) := by\n  have := x.property.some_mem\n  rw [mem_iInter] at this\n  exact this n\n\n"}
{"name":"CantorScheme.ClosureAntitone.antitone","module":"Mathlib.Topology.MetricSpace.CantorScheme","initialProofState":"β : Type u_1\nα : Type u_2\nA : List β → Set α\ninst✝ : TopologicalSpace α\nhA : CantorScheme.ClosureAntitone A\n⊢ CantorScheme.Antitone A","decl":"protected theorem ClosureAntitone.antitone [TopologicalSpace α] (hA : ClosureAntitone A) :\n    CantorScheme.Antitone A := fun l a => subset_closure.trans (hA l a)\n\n"}
{"name":"CantorScheme.Antitone.closureAntitone","module":"Mathlib.Topology.MetricSpace.CantorScheme","initialProofState":"β : Type u_1\nα : Type u_2\nA : List β → Set α\ninst✝ : TopologicalSpace α\nhanti : CantorScheme.Antitone A\nhclosed : ∀ (l : List β), IsClosed (A l)\n⊢ CantorScheme.ClosureAntitone A","decl":"protected theorem Antitone.closureAntitone [TopologicalSpace α] (hanti : CantorScheme.Antitone A)\n    (hclosed : ∀ l, IsClosed (A l)) : ClosureAntitone A := fun _ _ =>\n  (hclosed _).closure_eq.subset.trans (hanti _ _)\n\n"}
{"name":"CantorScheme.Disjoint.map_injective","module":"Mathlib.Topology.MetricSpace.CantorScheme","initialProofState":"β : Type u_1\nα : Type u_2\nA : List β → Set α\nhA : CantorScheme.Disjoint A\n⊢ Function.Injective (CantorScheme.inducedMap A).snd","decl":"/-- A scheme where the children of each set are pairwise disjoint induces an injective map. -/\ntheorem Disjoint.map_injective (hA : CantorScheme.Disjoint A) : Injective (inducedMap A).2 := by\n  rintro ⟨x, hx⟩ ⟨y, hy⟩ hxy\n  refine Subtype.coe_injective (res_injective ?_)\n  dsimp\n  ext n : 1\n  induction' n with n ih; · simp\n  simp only [res_succ, cons.injEq]\n  refine ⟨?_, ih⟩\n  contrapose hA\n  simp only [CantorScheme.Disjoint, _root_.Pairwise, Ne, not_forall, exists_prop]\n  refine ⟨res x n, _, _, hA, ?_⟩\n  rw [not_disjoint_iff]\n  refine ⟨(inducedMap A).2 ⟨x, hx⟩, ?_, ?_⟩\n  · rw [← res_succ]\n    apply map_mem\n  rw [hxy, ih, ← res_succ]\n  apply map_mem\n\n"}
{"name":"CantorScheme.VanishingDiam.dist_lt","module":"Mathlib.Topology.MetricSpace.CantorScheme","initialProofState":"β : Type u_1\nα : Type u_2\nA : List β → Set α\ninst✝ : PseudoMetricSpace α\nhA : CantorScheme.VanishingDiam A\nε : Real\nε_pos : LT.lt 0 ε\nx : Nat → β\n⊢ Exists fun n => ∀ (y : α), Membership.mem (A (PiNat.res x n)) y → ∀ (z : α), Membership.mem (A (PiNat.res x n)) z → LT.lt (Dist.dist y z) ε","decl":"theorem VanishingDiam.dist_lt (hA : VanishingDiam A) (ε : ℝ) (ε_pos : 0 < ε) (x : ℕ → β) :\n    ∃ n : ℕ, ∀ (y) (_ : y ∈ A (res x n)) (z) (_ : z ∈ A (res x n)), dist y z < ε := by\n  specialize hA x\n  rw [ENNReal.tendsto_atTop_zero] at hA\n  cases' hA (ENNReal.ofReal (ε / 2)) (by\n    simp only [gt_iff_lt, ENNReal.ofReal_pos]\n    linarith) with n hn\n  use n\n  intro y hy z hz\n  rw [← ENNReal.ofReal_lt_ofReal_iff ε_pos, ← edist_dist]\n  apply lt_of_le_of_lt (EMetric.edist_le_diam_of_mem hy hz)\n  apply lt_of_le_of_lt (hn _ (le_refl _))\n  rw [ENNReal.ofReal_lt_ofReal_iff ε_pos]\n  linarith\n\n"}
{"name":"CantorScheme.VanishingDiam.map_continuous","module":"Mathlib.Topology.MetricSpace.CantorScheme","initialProofState":"β : Type u_1\nα : Type u_2\nA : List β → Set α\ninst✝² : PseudoMetricSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : DiscreteTopology β\nhA : CantorScheme.VanishingDiam A\n⊢ Continuous (CantorScheme.inducedMap A).snd","decl":"/-- A scheme with vanishing diameter along each branch induces a continuous map. -/\ntheorem VanishingDiam.map_continuous [TopologicalSpace β] [DiscreteTopology β]\n    (hA : VanishingDiam A) : Continuous (inducedMap A).2 := by\n  rw [Metric.continuous_iff']\n  rintro ⟨x, hx⟩ ε ε_pos\n  cases' hA.dist_lt _ ε_pos x with n hn\n  rw [_root_.eventually_nhds_iff]\n  refine ⟨(↑)⁻¹' cylinder x n, ?_, ?_, by simp⟩\n  · rintro ⟨y, hy⟩ hyx\n    rw [mem_preimage, Subtype.coe_mk, cylinder_eq_res, mem_setOf] at hyx\n    apply hn\n    · rw [← hyx]\n      apply map_mem\n    apply map_mem\n  apply continuous_subtype_val.isOpen_preimage\n  apply isOpen_cylinder\n\n"}
{"name":"CantorScheme.ClosureAntitone.map_of_vanishingDiam","module":"Mathlib.Topology.MetricSpace.CantorScheme","initialProofState":"β : Type u_1\nα : Type u_2\nA : List β → Set α\ninst✝¹ : PseudoMetricSpace α\ninst✝ : CompleteSpace α\nhdiam : CantorScheme.VanishingDiam A\nhanti : CantorScheme.ClosureAntitone A\nhnonempty : ∀ (l : List β), (A l).Nonempty\n⊢ Eq (CantorScheme.inducedMap A).fst Set.univ","decl":"/-- A scheme on a complete space with vanishing diameter\nsuch that each set contains the closure of its children\ninduces a total map. -/\ntheorem ClosureAntitone.map_of_vanishingDiam [CompleteSpace α] (hdiam : VanishingDiam A)\n    (hanti : ClosureAntitone A) (hnonempty : ∀ l, (A l).Nonempty) : (inducedMap A).1 = univ := by\n  rw [eq_univ_iff_forall]\n  intro x\n  choose u hu using fun n => hnonempty (res x n)\n  have umem : ∀ n m : ℕ, n ≤ m → u m ∈ A (res x n) := by\n    have : Antitone fun n : ℕ => A (res x n) := by\n      refine antitone_nat_of_succ_le ?_\n      intro n\n      apply hanti.antitone\n    intro n m hnm\n    exact this hnm (hu _)\n  have : CauchySeq u := by\n    rw [Metric.cauchySeq_iff]\n    intro ε ε_pos\n    cases' hdiam.dist_lt _ ε_pos x with n hn\n    use n\n    intro m₀ hm₀ m₁ hm₁\n    apply hn <;> apply umem <;> assumption\n  cases' cauchySeq_tendsto_of_complete this with y hy\n  use y\n  rw [mem_iInter]\n  intro n\n  apply hanti _ (x n)\n  apply mem_closure_of_tendsto hy\n  rw [eventually_atTop]\n  exact ⟨n.succ, umem _⟩\n\n"}
