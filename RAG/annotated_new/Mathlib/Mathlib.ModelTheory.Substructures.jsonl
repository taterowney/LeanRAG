{"name":"FirstOrder.Language.closedUnder_univ","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nn : Nat\nf : L.Functions n\n⊢ FirstOrder.Language.ClosedUnder f Set.univ","decl":"@[simp]\ntheorem closedUnder_univ : ClosedUnder f (univ : Set M) := fun _ _ => mem_univ _\n\n"}
{"name":"FirstOrder.Language.ClosedUnder.inter","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nn : Nat\nf : L.Functions n\ns t : Set M\nhs : FirstOrder.Language.ClosedUnder f s\nht : FirstOrder.Language.ClosedUnder f t\n⊢ FirstOrder.Language.ClosedUnder f (Inter.inter s t)","decl":"theorem inter (hs : ClosedUnder f s) (ht : ClosedUnder f t) : ClosedUnder f (s ∩ t) := fun x h =>\n  mem_inter (hs x fun i => mem_of_mem_inter_left (h i)) (ht x fun i => mem_of_mem_inter_right (h i))\n\n"}
{"name":"FirstOrder.Language.ClosedUnder.inf","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nn : Nat\nf : L.Functions n\ns t : Set M\nhs : FirstOrder.Language.ClosedUnder f s\nht : FirstOrder.Language.ClosedUnder f t\n⊢ FirstOrder.Language.ClosedUnder f (Min.min s t)","decl":"theorem inf (hs : ClosedUnder f s) (ht : ClosedUnder f t) : ClosedUnder f (s ⊓ t) :=\n  hs.inter ht\n\n"}
{"name":"FirstOrder.Language.ClosedUnder.sInf","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nn : Nat\nf : L.Functions n\nS : Set (Set M)\nhS : ∀ (s : Set M), Membership.mem S s → FirstOrder.Language.ClosedUnder f s\n⊢ FirstOrder.Language.ClosedUnder f (InfSet.sInf S)","decl":"theorem sInf (hS : ∀ s, s ∈ S → ClosedUnder f s) : ClosedUnder f (sInf S) := fun x h s hs =>\n  hS s hs x fun i => h i s hs\n\n"}
{"name":"FirstOrder.Language.Substructure.fun_mem","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nself : L.Substructure M\nn : Nat\nf : L.Functions n\n⊢ FirstOrder.Language.ClosedUnder f self.carrier","decl":"/-- A substructure of a structure `M` is a set closed under application of function symbols. -/\nstructure Substructure where\n  carrier : Set M\n  fun_mem : ∀ {n}, ∀ f : L.Functions n, ClosedUnder f carrier\n\n"}
{"name":"FirstOrder.Language.Substructure.mk.injEq","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\ncarrier✝ : Set M\nfun_mem✝ : ∀ {n : Nat} (f : L.Functions n), FirstOrder.Language.ClosedUnder f carrier✝\ncarrier : Set M\nfun_mem : ∀ {n : Nat} (f : L.Functions n), FirstOrder.Language.ClosedUnder f carrier\n⊢ Eq (Eq { carrier := carrier✝, fun_mem := fun_mem✝ } { carrier := carrier, fun_mem := fun_mem }) (Eq carrier✝ carrier)","decl":"/-- A substructure of a structure `M` is a set closed under application of function symbols. -/\nstructure Substructure where\n  carrier : Set M\n  fun_mem : ∀ {n}, ∀ f : L.Functions n, ClosedUnder f carrier\n\n"}
{"name":"FirstOrder.Language.Substructure.mk.inj","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\ncarrier✝ : Set M\nfun_mem✝ : ∀ {n : Nat} (f : L.Functions n), FirstOrder.Language.ClosedUnder f carrier✝\ncarrier : Set M\nfun_mem : ∀ {n : Nat} (f : L.Functions n), FirstOrder.Language.ClosedUnder f carrier\nx✝ : Eq { carrier := carrier✝, fun_mem := fun_mem✝ } { carrier := carrier, fun_mem := fun_mem }\n⊢ Eq carrier✝ carrier","decl":"/-- A substructure of a structure `M` is a set closed under application of function symbols. -/\nstructure Substructure where\n  carrier : Set M\n  fun_mem : ∀ {n}, ∀ f : L.Functions n, ClosedUnder f carrier\n\n"}
{"name":"FirstOrder.Language.Substructure.mk.sizeOf_spec","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\ninst✝ : SizeOf M\ncarrier : Set M\nfun_mem : ∀ {n : Nat} (f : L.Functions n), FirstOrder.Language.ClosedUnder f carrier\n⊢ Eq (SizeOf.sizeOf { carrier := carrier, fun_mem := fun_mem }) 1","decl":"/-- A substructure of a structure `M` is a set closed under application of function symbols. -/\nstructure Substructure where\n  carrier : Set M\n  fun_mem : ∀ {n}, ∀ f : L.Functions n, ClosedUnder f carrier\n\n"}
{"name":"FirstOrder.Language.Substructure.mem_carrier","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\ns : L.Substructure M\nx : M\n⊢ Iff (Membership.mem (↑s) x) (Membership.mem s x)","decl":"@[simp]\ntheorem mem_carrier {s : L.Substructure M} {x : M} : x ∈ s.carrier ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.Substructure.ext_iff","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS T : L.Substructure M\n⊢ Iff (Eq S T) (∀ (x : M), Iff (Membership.mem S x) (Membership.mem T x))","decl":"/-- Two substructures are equal if they have the same elements. -/\n@[ext]\ntheorem ext {S T : L.Substructure M} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n\n"}
{"name":"FirstOrder.Language.Substructure.ext","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS T : L.Substructure M\nh : ∀ (x : M), Iff (Membership.mem S x) (Membership.mem T x)\n⊢ Eq S T","decl":"/-- Two substructures are equal if they have the same elements. -/\n@[ext]\ntheorem ext {S T : L.Substructure M} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n\n"}
{"name":"FirstOrder.Language.Term.realize_mem","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS : L.Substructure M\nα : Type u_3\nt : L.Term α\nxs : α → M\nh : ∀ (a : α), Membership.mem S (xs a)\n⊢ Membership.mem S (FirstOrder.Language.Term.realize xs t)","decl":"theorem Term.realize_mem {α : Type*} (t : L.Term α) (xs : α → M) (h : ∀ a, xs a ∈ S) :\n    t.realize xs ∈ S := by\n  induction' t with a n f ts ih\n  · exact h a\n  · exact Substructure.fun_mem _ _ _ ih\n\n"}
{"name":"FirstOrder.Language.Substructure.coe_copy","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS : L.Substructure M\ns : Set M\nhs : Eq s ↑S\n⊢ Eq (↑(S.copy s hs)) s","decl":"@[simp]\ntheorem coe_copy {s : Set M} (hs : s = S) : (S.copy s hs : Set M) = s :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Substructure.copy_eq","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS : L.Substructure M\ns : Set M\nhs : Eq s ↑S\n⊢ Eq (S.copy s hs) S","decl":"theorem copy_eq {s : Set M} (hs : s = S) : S.copy s hs = S :=\n  SetLike.coe_injective hs\n\n"}
{"name":"FirstOrder.Language.Substructure.constants_mem","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS : L.Substructure M\nc : L.Constants\n⊢ Membership.mem S ↑c","decl":"theorem constants_mem (c : L.Constants) : (c : M) ∈ S :=\n  mem_carrier.2 (S.fun_mem c _ finZeroElim)\n\n"}
{"name":"FirstOrder.Language.Substructure.mem_top","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nx : M\n⊢ Membership.mem Top.top x","decl":"@[simp]\ntheorem mem_top (x : M) : x ∈ (⊤ : L.Substructure M) :=\n  Set.mem_univ x\n\n"}
{"name":"FirstOrder.Language.Substructure.coe_top","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\n⊢ Eq (↑Top.top) Set.univ","decl":"@[simp]\ntheorem coe_top : ((⊤ : L.Substructure M) : Set M) = Set.univ :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Substructure.coe_inf","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\np p' : L.Substructure M\n⊢ Eq (↑(Min.min p p')) (Inter.inter ↑p ↑p')","decl":"@[simp]\ntheorem coe_inf (p p' : L.Substructure M) :\n    ((p ⊓ p' : L.Substructure M) : Set M) = (p : Set M) ∩ (p' : Set M) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Substructure.mem_inf","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\np p' : L.Substructure M\nx : M\n⊢ Iff (Membership.mem (Min.min p p') x) (And (Membership.mem p x) (Membership.mem p' x))","decl":"@[simp]\ntheorem mem_inf {p p' : L.Substructure M} {x : M} : x ∈ p ⊓ p' ↔ x ∈ p ∧ x ∈ p' :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.Substructure.coe_sInf","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS : Set (L.Substructure M)\n⊢ Eq (↑(InfSet.sInf S)) (Set.iInter fun s => Set.iInter fun h => ↑s)","decl":"@[simp, norm_cast]\ntheorem coe_sInf (S : Set (L.Substructure M)) :\n    ((sInf S : L.Substructure M) : Set M) = ⋂ s ∈ S, (s : Set M) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Substructure.mem_sInf","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS : Set (L.Substructure M)\nx : M\n⊢ Iff (Membership.mem (InfSet.sInf S) x) (∀ (p : L.Substructure M), Membership.mem S p → Membership.mem p x)","decl":"theorem mem_sInf {S : Set (L.Substructure M)} {x : M} : x ∈ sInf S ↔ ∀ p ∈ S, x ∈ p :=\n  Set.mem_iInter₂\n\n"}
{"name":"FirstOrder.Language.Substructure.mem_iInf","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nι : Sort u_3\nS : ι → L.Substructure M\nx : M\n⊢ Iff (Membership.mem (iInf fun i => S i) x) (∀ (i : ι), Membership.mem (S i) x)","decl":"theorem mem_iInf {ι : Sort*} {S : ι → L.Substructure M} {x : M} :\n    (x ∈ ⨅ i, S i) ↔ ∀ i, x ∈ S i := by simp only [iInf, mem_sInf, Set.forall_mem_range]\n\n"}
{"name":"FirstOrder.Language.Substructure.coe_iInf","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nι : Sort u_3\nS : ι → L.Substructure M\n⊢ Eq (↑(iInf fun i => S i)) (Set.iInter fun i => ↑(S i))","decl":"@[simp, norm_cast]\ntheorem coe_iInf {ι : Sort*} {S : ι → L.Substructure M} :\n    ((⨅ i, S i : L.Substructure M) : Set M) = ⋂ i, (S i : Set M) := by\n  simp only [iInf, coe_sInf, Set.biInter_range]\n\n"}
{"name":"FirstOrder.Language.Substructure.mem_closure","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\ns : Set M\nx : M\n⊢ Iff (Membership.mem ((FirstOrder.Language.Substructure.closure L).toFun s) x) (∀ (S : L.Substructure M), HasSubset.Subset s ↑S → Membership.mem S x)","decl":"theorem mem_closure {x : M} : x ∈ closure L s ↔ ∀ S : L.Substructure M, s ⊆ S → x ∈ S :=\n  mem_sInf\n\n"}
{"name":"FirstOrder.Language.Substructure.subset_closure","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\ns : Set M\n⊢ HasSubset.Subset s ↑((FirstOrder.Language.Substructure.closure L).toFun s)","decl":"/-- The substructure generated by a set includes the set. -/\n@[simp]\ntheorem subset_closure : s ⊆ closure L s :=\n  (closure L).le_closure s\n\n"}
{"name":"FirstOrder.Language.Substructure.not_mem_of_not_mem_closure","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\ns : Set M\nP : M\nhP : Not (Membership.mem ((FirstOrder.Language.Substructure.closure L).toFun s) P)\n⊢ Not (Membership.mem s P)","decl":"theorem not_mem_of_not_mem_closure {P : M} (hP : P ∉ closure L s) : P ∉ s := fun h =>\n  hP (subset_closure h)\n\n"}
{"name":"FirstOrder.Language.Substructure.closed","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS : L.Substructure M\n⊢ (FirstOrder.Language.Substructure.closure L).closed ↑S","decl":"@[simp]\ntheorem closed (S : L.Substructure M) : (closure L).closed (S : Set M) :=\n  congr rfl ((closure L).eq_of_le Set.Subset.rfl fun _x xS => mem_closure.2 fun _T hT => hT xS)\n\n"}
{"name":"FirstOrder.Language.Substructure.closure_le","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS : L.Substructure M\ns : Set M\n⊢ Iff (LE.le ((FirstOrder.Language.Substructure.closure L).toFun s) S) (HasSubset.Subset s ↑S)","decl":"/-- A substructure `S` includes `closure L s` if and only if it includes `s`. -/\n@[simp]\ntheorem closure_le : closure L s ≤ S ↔ s ⊆ S :=\n  (closure L).closure_le_closed_iff_le s S.closed\n\n"}
{"name":"FirstOrder.Language.Substructure.closure_mono","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\ns t : Set M\nh : HasSubset.Subset s t\n⊢ LE.le ((FirstOrder.Language.Substructure.closure L).toFun s) ((FirstOrder.Language.Substructure.closure L).toFun t)","decl":"/-- Substructure closure of a set is monotone in its argument: if `s ⊆ t`,\nthen `closure L s ≤ closure L t`. -/\n@[gcongr]\ntheorem closure_mono ⦃s t : Set M⦄ (h : s ⊆ t) : closure L s ≤ closure L t :=\n  (closure L).monotone h\n\n"}
{"name":"FirstOrder.Language.Substructure.closure_eq_of_le","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS : L.Substructure M\ns : Set M\nh₁ : HasSubset.Subset s ↑S\nh₂ : LE.le S ((FirstOrder.Language.Substructure.closure L).toFun s)\n⊢ Eq ((FirstOrder.Language.Substructure.closure L).toFun s) S","decl":"theorem closure_eq_of_le (h₁ : s ⊆ S) (h₂ : S ≤ closure L s) : closure L s = S :=\n  (closure L).eq_of_le h₁ h₂\n\n"}
{"name":"FirstOrder.Language.Substructure.coe_closure_eq_range_term_realize","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\ns : Set M\n⊢ Eq (↑((FirstOrder.Language.Substructure.closure L).toFun s)) (Set.range (FirstOrder.Language.Term.realize Subtype.val))","decl":"theorem coe_closure_eq_range_term_realize :\n    (closure L s : Set M) = range (@Term.realize L _ _ _ ((↑) : s → M)) := by\n  let S : L.Substructure M := ⟨range (Term.realize (L := L) ((↑) : s → M)), fun {n} f x hx => by\n    simp only [mem_range] at *\n    refine ⟨func f fun i => Classical.choose (hx i), ?_⟩\n    simp only [Term.realize, fun i => Classical.choose_spec (hx i)]⟩\n  change _ = (S : Set M)\n  rw [← SetLike.ext'_iff]\n  refine closure_eq_of_le (fun x hx => ⟨var ⟨x, hx⟩, rfl⟩) (le_sInf fun S' hS' => ?_)\n  rintro _ ⟨t, rfl⟩\n  exact t.realize_mem _ fun i => hS' i.2\n\n"}
{"name":"FirstOrder.Language.Substructure.small_closure","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\ns : Set M\ninst✝ : Small.{u, w} ↑s\n⊢ Small.{u, w} (Subtype fun x => Membership.mem ((FirstOrder.Language.Substructure.closure L).toFun s) x)","decl":"instance small_closure [Small.{u} s] : Small.{u} (closure L s) := by\n  rw [← SetLike.coe_sort_coe, Substructure.coe_closure_eq_range_term_realize]\n  exact small_range _\n\n"}
{"name":"FirstOrder.Language.Substructure.mem_closure_iff_exists_term","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\ns : Set M\nx : M\n⊢ Iff (Membership.mem ((FirstOrder.Language.Substructure.closure L).toFun s) x) (Exists fun t => Eq (FirstOrder.Language.Term.realize Subtype.val t) x)","decl":"theorem mem_closure_iff_exists_term {x : M} :\n    x ∈ closure L s ↔ ∃ t : L.Term s, t.realize ((↑) : s → M) = x := by\n  rw [← SetLike.mem_coe, coe_closure_eq_range_term_realize, mem_range]\n\n"}
{"name":"FirstOrder.Language.Substructure.lift_card_closure_le_card_term","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\ns : Set M\n⊢ LE.le (Cardinal.lift.{max u w, w} (Cardinal.mk (Subtype fun x => Membership.mem ((FirstOrder.Language.Substructure.closure L).toFun s) x))) (Cardinal.mk (L.Term ↑s))","decl":"theorem lift_card_closure_le_card_term : Cardinal.lift.{max u w} #(closure L s) ≤ #(L.Term s) := by\n  rw [← SetLike.coe_sort_coe, coe_closure_eq_range_term_realize]\n  rw [← Cardinal.lift_id'.{w, max u w} #(L.Term s)]\n  exact Cardinal.mk_range_le_lift\n\n"}
{"name":"FirstOrder.Language.Substructure.lift_card_closure_le","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\ns : Set M\n⊢ LE.le (Cardinal.lift.{u, w} (Cardinal.mk (Subtype fun x => Membership.mem ((FirstOrder.Language.Substructure.closure L).toFun s) x))) (Max.max Cardinal.aleph0 (HAdd.hAdd (Cardinal.lift.{u, w} (Cardinal.mk ↑s)) (Cardinal.lift.{w, u} (Cardinal.mk (Sigma fun i => L.Functions i)))))","decl":"theorem lift_card_closure_le :\n    Cardinal.lift.{u, w} #(closure L s) ≤\n      max ℵ₀ (Cardinal.lift.{u, w} #s + Cardinal.lift.{w, u} #(Σi, L.Functions i)) := by\n  rw [← lift_umax]\n  refine lift_card_closure_le_card_term.trans (Term.card_le.trans ?_)\n  rw [mk_sum, lift_umax.{w, u}]\n\n"}
{"name":"FirstOrder.Language.Substructure.mem_closed_iff","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\ns : Set M\n⊢ Iff (Membership.mem (FirstOrder.Language.Substructure.closure L).closed s) (∀ {n : Nat} (f : L.Functions n), FirstOrder.Language.ClosedUnder f s)","decl":"lemma mem_closed_iff (s : Set M) :\n    s ∈ (closure L).closed ↔ ∀ {n}, ∀ f : L.Functions n, ClosedUnder f s := by\n  refine ⟨fun h n f => ?_, fun h => ?_⟩\n  · rw [← h]\n    exact Substructure.fun_mem _ _\n  · have h' : closure L s = ⟨s, h⟩ := closure_eq_of_le (refl _) subset_closure\n    exact congr_arg _ h'\n\n"}
{"name":"FirstOrder.Language.Substructure.mem_closed_of_isRelational","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\ninst✝ : L.IsRelational\ns : Set M\n⊢ Membership.mem (FirstOrder.Language.Substructure.closure L).closed s","decl":"lemma mem_closed_of_isRelational [L.IsRelational] (s : Set M) : s ∈ (closure L).closed :=\n  (mem_closed_iff s).2 isEmptyElim\n\n"}
{"name":"FirstOrder.Language.Substructure.closure_eq_of_isRelational","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\ninst✝ : L.IsRelational\ns : Set M\n⊢ Eq (↑((FirstOrder.Language.Substructure.closure L).toFun s)) s","decl":"@[simp]\nlemma closure_eq_of_isRelational [L.IsRelational] (s : Set M) : closure L s = s :=\n  LowerAdjoint.closure_eq_self_of_mem_closed _ (mem_closed_of_isRelational L s)\n\n"}
{"name":"FirstOrder.Language.Substructure.mem_closure_iff_of_isRelational","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\ninst✝ : L.IsRelational\ns : Set M\nm : M\n⊢ Iff (Membership.mem ((FirstOrder.Language.Substructure.closure L).toFun s) m) (Membership.mem s m)","decl":"@[simp]\nlemma mem_closure_iff_of_isRelational [L.IsRelational] (s : Set M) (m : M) :\n    m ∈ closure L s ↔ m ∈ s := by\n  rw [← SetLike.mem_coe, closure_eq_of_isRelational]\n\n"}
{"name":"Set.Countable.substructure_closure","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\ns : Set M\ninst✝ : Countable (Sigma fun l => L.Functions l)\nh : s.Countable\n⊢ Countable (Subtype fun x => Membership.mem ((FirstOrder.Language.Substructure.closure L).toFun s) x)","decl":"theorem _root_.Set.Countable.substructure_closure\n    [Countable (Σl, L.Functions l)] (h : s.Countable) : Countable.{w + 1} (closure L s) := by\n  haveI : Countable s := h.to_subtype\n  rw [← mk_le_aleph0_iff, ← lift_le_aleph0]\n  exact lift_card_closure_le_card_term.trans mk_le_aleph0\n\n"}
{"name":"FirstOrder.Language.Substructure.closure_induction","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\ns : Set M\np : M → Prop\nx : M\nh : Membership.mem ((FirstOrder.Language.Substructure.closure L).toFun s) x\nHs : ∀ (x : M), Membership.mem s x → p x\nHfun : ∀ {n : Nat} (f : L.Functions n), FirstOrder.Language.ClosedUnder f (setOf p)\n⊢ p x","decl":"/-- An induction principle for closure membership. If `p` holds for all elements of `s`, and\nis preserved under function symbols, then `p` holds for all elements of the closure of `s`. -/\n@[elab_as_elim]\ntheorem closure_induction {p : M → Prop} {x} (h : x ∈ closure L s) (Hs : ∀ x ∈ s, p x)\n    (Hfun : ∀ {n : ℕ} (f : L.Functions n), ClosedUnder f (setOf p)) : p x :=\n  (@closure_le L M _ ⟨setOf p, fun {_} => Hfun⟩ _).2 Hs h\n\n"}
{"name":"FirstOrder.Language.Substructure.dense_induction","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\np : M → Prop\nx : M\ns : Set M\nhs : Eq ((FirstOrder.Language.Substructure.closure L).toFun s) Top.top\nHs : ∀ (x : M), Membership.mem s x → p x\nHfun : ∀ {n : Nat} (f : L.Functions n), FirstOrder.Language.ClosedUnder f (setOf p)\n⊢ p x","decl":"/-- If `s` is a dense set in a structure `M`, `Substructure.closure L s = ⊤`, then in order to prove\nthat some predicate `p` holds for all `x : M` it suffices to verify `p x` for `x ∈ s`, and verify\nthat `p` is preserved under function symbols. -/\n@[elab_as_elim]\ntheorem dense_induction {p : M → Prop} (x : M) {s : Set M} (hs : closure L s = ⊤)\n    (Hs : ∀ x ∈ s, p x) (Hfun : ∀ {n : ℕ} (f : L.Functions n), ClosedUnder f (setOf p)) : p x := by\n  have : ∀ x ∈ closure L s, p x := fun x hx => closure_induction hx Hs fun {n} => Hfun\n  simpa [hs] using this x\n\n"}
{"name":"FirstOrder.Language.Substructure.closure_eq","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS : L.Substructure M\n⊢ Eq ((FirstOrder.Language.Substructure.closure L).toFun ↑S) S","decl":"/-- Closure of a substructure `S` equals `S`. -/\n@[simp]\ntheorem closure_eq : closure L (S : Set M) = S :=\n  (Substructure.gi L M).l_u_eq S\n\n"}
{"name":"FirstOrder.Language.Substructure.closure_empty","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\n⊢ Eq ((FirstOrder.Language.Substructure.closure L).toFun EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem closure_empty : closure L (∅ : Set M) = ⊥ :=\n  (Substructure.gi L M).gc.l_bot\n\n"}
{"name":"FirstOrder.Language.Substructure.closure_univ","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\n⊢ Eq ((FirstOrder.Language.Substructure.closure L).toFun Set.univ) Top.top","decl":"@[simp]\ntheorem closure_univ : closure L (univ : Set M) = ⊤ :=\n  @coe_top L M _ ▸ closure_eq ⊤\n\n"}
{"name":"FirstOrder.Language.Substructure.closure_union","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\ns t : Set M\n⊢ Eq ((FirstOrder.Language.Substructure.closure L).toFun (Union.union s t)) (Max.max ((FirstOrder.Language.Substructure.closure L).toFun s) ((FirstOrder.Language.Substructure.closure L).toFun t))","decl":"theorem closure_union (s t : Set M) : closure L (s ∪ t) = closure L s ⊔ closure L t :=\n  (Substructure.gi L M).gc.l_sup\n\n"}
{"name":"FirstOrder.Language.Substructure.closure_iUnion","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nι : Sort u_3\ns : ι → Set M\n⊢ Eq ((FirstOrder.Language.Substructure.closure L).toFun (Set.iUnion fun i => s i)) (iSup fun i => (FirstOrder.Language.Substructure.closure L).toFun (s i))","decl":"theorem closure_iUnion {ι} (s : ι → Set M) : closure L (⋃ i, s i) = ⨆ i, closure L (s i) :=\n  (Substructure.gi L M).gc.l_iSup\n\n"}
{"name":"FirstOrder.Language.Substructure.closure_insert","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\ns : Set M\nm : M\n⊢ Eq ((FirstOrder.Language.Substructure.closure L).toFun (Insert.insert m s)) (Max.max ((FirstOrder.Language.Substructure.closure L).toFun (Singleton.singleton m)) ((FirstOrder.Language.Substructure.closure L).toFun s))","decl":"theorem closure_insert (s : Set M) (m : M) : closure L (insert m s) = closure L {m} ⊔ closure L s :=\n  closure_union {m} s\n\n"}
{"name":"FirstOrder.Language.Substructure.small_bot","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\n⊢ Small.{u, w} (Subtype fun x => Membership.mem Bot.bot x)","decl":"instance small_bot : Small.{u} (⊥ : L.Substructure M) := by\n  rw [← closure_empty]\n  haveI : Small.{u} (∅ : Set M) := small_subsingleton _\n  exact Substructure.small_closure\n\n"}
{"name":"FirstOrder.Language.Substructure.iSup_eq_closure","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nι : Sort u_3\nS : ι → L.Substructure M\n⊢ Eq (iSup fun i => S i) ((FirstOrder.Language.Substructure.closure L).toFun (Set.iUnion fun i => ↑(S i)))","decl":"theorem iSup_eq_closure {ι : Sort*} (S : ι → L.Substructure M) :\n    ⨆ i, S i = closure L (⋃ i, (S i : Set M)) := by simp_rw [closure_iUnion, closure_eq]\n\n-- This proof uses the fact that `Substructure.closure` is finitary.\n"}
{"name":"FirstOrder.Language.Substructure.mem_iSup_of_directed","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nι : Type u_3\nhι : Nonempty ι\nS : ι → L.Substructure M\nhS : Directed (fun x1 x2 => LE.le x1 x2) S\nx : M\n⊢ Iff (Membership.mem (iSup fun i => S i) x) (Exists fun i => Membership.mem (S i) x)","decl":"theorem mem_iSup_of_directed {ι : Type*} [hι : Nonempty ι] {S : ι → L.Substructure M}\n    (hS : Directed (· ≤ ·) S) {x : M} :\n    x ∈ ⨆ i, S i ↔ ∃ i, x ∈ S i := by\n  refine ⟨?_, fun ⟨i, hi⟩ ↦ le_iSup S i hi⟩\n  suffices x ∈ closure L (⋃ i, (S i : Set M)) → ∃ i, x ∈ S i by\n    simpa only [closure_iUnion, closure_eq (S _)] using this\n  refine fun hx ↦ closure_induction hx (fun _ ↦ mem_iUnion.1) (fun f v hC ↦ ?_)\n  simp_rw [Set.mem_setOf] at *\n  have ⟨i, hi⟩ := hS.finite_le (fun i ↦ Classical.choose (hC i))\n  refine ⟨i, (S i).fun_mem f v (fun j ↦ hi j (Classical.choose_spec (hC j)))⟩\n\n-- This proof uses the fact that `Substructure.closure` is finitary.\n"}
{"name":"FirstOrder.Language.Substructure.mem_sSup_of_directedOn","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS : Set (L.Substructure M)\nSne : S.Nonempty\nhS : DirectedOn (fun x1 x2 => LE.le x1 x2) S\nx : M\n⊢ Iff (Membership.mem (SupSet.sSup S) x) (Exists fun s => And (Membership.mem S s) (Membership.mem s x))","decl":"theorem mem_sSup_of_directedOn {S : Set (L.Substructure M)} (Sne : S.Nonempty)\n    (hS : DirectedOn (· ≤ ·) S) {x : M} :\n    x ∈ sSup S ↔ ∃ s ∈ S, x ∈ s := by\n  haveI : Nonempty S := Sne.to_subtype\n  simp only [sSup_eq_iSup', mem_iSup_of_directed hS.directed_val, Subtype.exists, exists_prop]\n\n"}
{"name":"FirstOrder.Language.Substructure.instIsEmptySubtypeMemBotOfConstants","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\ninst✝ : IsEmpty L.Constants\n⊢ IsEmpty (Subtype fun x => Membership.mem Bot.bot x)","decl":"instance [IsEmpty L.Constants] : IsEmpty (⊥ : L.Substructure M) := by\n  refine (isEmpty_subtype _).2 (fun x => ?_)\n  have h : (∅ : Set M) ∈ (closure L).closed := by\n    rw [mem_closed_iff]\n    intro n f\n    cases n\n    · exact isEmptyElim f\n    · intro x hx\n      simp only [mem_empty_iff_false, forall_const] at hx\n  rw [← closure_empty, ← SetLike.mem_coe, h]\n  exact Set.not_mem_empty _\n\n"}
{"name":"FirstOrder.Language.Substructure.coe_comap","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nφ : L.Hom M N\nS : L.Substructure N\n⊢ Eq (↑(FirstOrder.Language.Substructure.comap φ S)) (Set.preimage ⇑φ ↑S)","decl":"/-- The preimage of a substructure along a homomorphism is a substructure. -/\n@[simps]\ndef comap (φ : M →[L] N) (S : L.Substructure N) : L.Substructure M where\n  carrier := φ ⁻¹' S\n  fun_mem {n} f x hx := by\n    rw [mem_preimage, φ.map_fun]\n    exact S.fun_mem f (φ ∘ x) hx\n\n"}
{"name":"FirstOrder.Language.Substructure.mem_comap","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nS : L.Substructure N\nf : L.Hom M N\nx : M\n⊢ Iff (Membership.mem (FirstOrder.Language.Substructure.comap f S) x) (Membership.mem S (f x))","decl":"@[simp]\ntheorem mem_comap {S : L.Substructure N} {f : M →[L] N} {x : M} : x ∈ S.comap f ↔ f x ∈ S :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.Substructure.comap_comap","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\ninst✝ : L.Structure P\nS : L.Substructure P\ng : L.Hom N P\nf : L.Hom M N\n⊢ Eq (FirstOrder.Language.Substructure.comap f (FirstOrder.Language.Substructure.comap g S)) (FirstOrder.Language.Substructure.comap (g.comp f) S)","decl":"theorem comap_comap (S : L.Substructure P) (g : N →[L] P) (f : M →[L] N) :\n    (S.comap g).comap f = S.comap (g.comp f) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Substructure.comap_id","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nP : Type u_2\ninst✝ : L.Structure P\nS : L.Substructure P\n⊢ Eq (FirstOrder.Language.Substructure.comap (FirstOrder.Language.Hom.id L P) S) S","decl":"@[simp]\ntheorem comap_id (S : L.Substructure P) : S.comap (Hom.id _ _) = S :=\n  ext (by simp)\n\n"}
{"name":"FirstOrder.Language.Substructure.coe_map","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nφ : L.Hom M N\nS : L.Substructure M\n⊢ Eq (↑(FirstOrder.Language.Substructure.map φ S)) (Set.image ⇑φ ↑S)","decl":"/-- The image of a substructure along a homomorphism is a substructure. -/\n@[simps]\ndef map (φ : M →[L] N) (S : L.Substructure M) : L.Substructure N where\n  carrier := φ '' S\n  fun_mem {n} f x hx :=\n    (mem_image _ _ _).1\n      ⟨funMap f fun i => Classical.choose (hx i),\n        S.fun_mem f _ fun i => (Classical.choose_spec (hx i)).1, by\n        simp only [Hom.map_fun, SetLike.mem_coe]\n        exact congr rfl (funext fun i => (Classical.choose_spec (hx i)).2)⟩\n\n"}
{"name":"FirstOrder.Language.Substructure.mem_map","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\nS : L.Substructure M\ny : N\n⊢ Iff (Membership.mem (FirstOrder.Language.Substructure.map f S) y) (Exists fun x => And (Membership.mem S x) (Eq (f x) y))","decl":"@[simp]\ntheorem mem_map {f : M →[L] N} {S : L.Substructure M} {y : N} :\n    y ∈ S.map f ↔ ∃ x ∈ S, f x = y :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.Substructure.mem_map_of_mem","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\nS : L.Substructure M\nx : M\nhx : Membership.mem S x\n⊢ Membership.mem (FirstOrder.Language.Substructure.map f S) (f x)","decl":"theorem mem_map_of_mem (f : M →[L] N) {S : L.Substructure M} {x : M} (hx : x ∈ S) : f x ∈ S.map f :=\n  mem_image_of_mem f hx\n\n"}
{"name":"FirstOrder.Language.Substructure.apply_coe_mem_map","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\nS : L.Substructure M\nx : Subtype fun x => Membership.mem S x\n⊢ Membership.mem (FirstOrder.Language.Substructure.map f S) (f ↑x)","decl":"theorem apply_coe_mem_map (f : M →[L] N) (S : L.Substructure M) (x : S) : f x ∈ S.map f :=\n  mem_map_of_mem f x.prop\n\n"}
{"name":"FirstOrder.Language.Substructure.map_map","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\ninst✝ : L.Structure P\nS : L.Substructure M\ng : L.Hom N P\nf : L.Hom M N\n⊢ Eq (FirstOrder.Language.Substructure.map g (FirstOrder.Language.Substructure.map f S)) (FirstOrder.Language.Substructure.map (g.comp f) S)","decl":"theorem map_map (g : N →[L] P) (f : M →[L] N) : (S.map f).map g = S.map (g.comp f) :=\n  SetLike.coe_injective <| image_image _ _ _\n\n"}
{"name":"FirstOrder.Language.Substructure.map_le_iff_le_comap","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\nS : L.Substructure M\nT : L.Substructure N\n⊢ Iff (LE.le (FirstOrder.Language.Substructure.map f S) T) (LE.le S (FirstOrder.Language.Substructure.comap f T))","decl":"theorem map_le_iff_le_comap {f : M →[L] N} {S : L.Substructure M} {T : L.Substructure N} :\n    S.map f ≤ T ↔ S ≤ T.comap f :=\n  image_subset_iff\n\n"}
{"name":"FirstOrder.Language.Substructure.gc_map_comap","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\n⊢ GaloisConnection (FirstOrder.Language.Substructure.map f) (FirstOrder.Language.Substructure.comap f)","decl":"theorem gc_map_comap (f : M →[L] N) : GaloisConnection (map f) (comap f) := fun _ _ =>\n  map_le_iff_le_comap\n\n"}
{"name":"FirstOrder.Language.Substructure.map_le_of_le_comap","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nS : L.Substructure M\nT : L.Substructure N\nf : L.Hom M N\na✝ : LE.le S (FirstOrder.Language.Substructure.comap f T)\n⊢ LE.le (FirstOrder.Language.Substructure.map f S) T","decl":"theorem map_le_of_le_comap {T : L.Substructure N} {f : M →[L] N} : S ≤ T.comap f → S.map f ≤ T :=\n  (gc_map_comap f).l_le\n\n"}
{"name":"FirstOrder.Language.Substructure.le_comap_of_map_le","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nS : L.Substructure M\nT : L.Substructure N\nf : L.Hom M N\na✝ : LE.le (FirstOrder.Language.Substructure.map f S) T\n⊢ LE.le S (FirstOrder.Language.Substructure.comap f T)","decl":"theorem le_comap_of_map_le {T : L.Substructure N} {f : M →[L] N} : S.map f ≤ T → S ≤ T.comap f :=\n  (gc_map_comap f).le_u\n\n"}
{"name":"FirstOrder.Language.Substructure.le_comap_map","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nS : L.Substructure M\nf : L.Hom M N\n⊢ LE.le S (FirstOrder.Language.Substructure.comap f (FirstOrder.Language.Substructure.map f S))","decl":"theorem le_comap_map {f : M →[L] N} : S ≤ (S.map f).comap f :=\n  (gc_map_comap f).le_u_l _\n\n"}
{"name":"FirstOrder.Language.Substructure.map_comap_le","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nS : L.Substructure N\nf : L.Hom M N\n⊢ LE.le (FirstOrder.Language.Substructure.map f (FirstOrder.Language.Substructure.comap f S)) S","decl":"theorem map_comap_le {S : L.Substructure N} {f : M →[L] N} : (S.comap f).map f ≤ S :=\n  (gc_map_comap f).l_u_le _\n\n"}
{"name":"FirstOrder.Language.Substructure.monotone_map","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\n⊢ Monotone (FirstOrder.Language.Substructure.map f)","decl":"theorem monotone_map {f : M →[L] N} : Monotone (map f) :=\n  (gc_map_comap f).monotone_l\n\n"}
{"name":"FirstOrder.Language.Substructure.monotone_comap","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\n⊢ Monotone (FirstOrder.Language.Substructure.comap f)","decl":"theorem monotone_comap {f : M →[L] N} : Monotone (comap f) :=\n  (gc_map_comap f).monotone_u\n\n"}
{"name":"FirstOrder.Language.Substructure.map_comap_map","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nS : L.Substructure M\nf : L.Hom M N\n⊢ Eq (FirstOrder.Language.Substructure.map f (FirstOrder.Language.Substructure.comap f (FirstOrder.Language.Substructure.map f S))) (FirstOrder.Language.Substructure.map f S)","decl":"@[simp]\ntheorem map_comap_map {f : M →[L] N} : ((S.map f).comap f).map f = S.map f :=\n  (gc_map_comap f).l_u_l_eq_l _\n\n"}
{"name":"FirstOrder.Language.Substructure.comap_map_comap","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nS : L.Substructure N\nf : L.Hom M N\n⊢ Eq (FirstOrder.Language.Substructure.comap f (FirstOrder.Language.Substructure.map f (FirstOrder.Language.Substructure.comap f S))) (FirstOrder.Language.Substructure.comap f S)","decl":"@[simp]\ntheorem comap_map_comap {S : L.Substructure N} {f : M →[L] N} :\n    ((S.comap f).map f).comap f = S.comap f :=\n  (gc_map_comap f).u_l_u_eq_u _\n\n"}
{"name":"FirstOrder.Language.Substructure.map_sup","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nS T : L.Substructure M\nf : L.Hom M N\n⊢ Eq (FirstOrder.Language.Substructure.map f (Max.max S T)) (Max.max (FirstOrder.Language.Substructure.map f S) (FirstOrder.Language.Substructure.map f T))","decl":"theorem map_sup (S T : L.Substructure M) (f : M →[L] N) : (S ⊔ T).map f = S.map f ⊔ T.map f :=\n  (gc_map_comap f).l_sup\n\n"}
{"name":"FirstOrder.Language.Substructure.map_iSup","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nι : Sort u_3\nf : L.Hom M N\ns : ι → L.Substructure M\n⊢ Eq (FirstOrder.Language.Substructure.map f (iSup fun i => s i)) (iSup fun i => FirstOrder.Language.Substructure.map f (s i))","decl":"theorem map_iSup {ι : Sort*} (f : M →[L] N) (s : ι → L.Substructure M) :\n    (⨆ i, s i).map f = ⨆ i, (s i).map f :=\n  (gc_map_comap f).l_iSup\n\n"}
{"name":"FirstOrder.Language.Substructure.comap_inf","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nS T : L.Substructure N\nf : L.Hom M N\n⊢ Eq (FirstOrder.Language.Substructure.comap f (Min.min S T)) (Min.min (FirstOrder.Language.Substructure.comap f S) (FirstOrder.Language.Substructure.comap f T))","decl":"theorem comap_inf (S T : L.Substructure N) (f : M →[L] N) :\n    (S ⊓ T).comap f = S.comap f ⊓ T.comap f :=\n  (gc_map_comap f).u_inf\n\n"}
{"name":"FirstOrder.Language.Substructure.comap_iInf","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nι : Sort u_3\nf : L.Hom M N\ns : ι → L.Substructure N\n⊢ Eq (FirstOrder.Language.Substructure.comap f (iInf fun i => s i)) (iInf fun i => FirstOrder.Language.Substructure.comap f (s i))","decl":"theorem comap_iInf {ι : Sort*} (f : M →[L] N) (s : ι → L.Substructure N) :\n    (⨅ i, s i).comap f = ⨅ i, (s i).comap f :=\n  (gc_map_comap f).u_iInf\n\n"}
{"name":"FirstOrder.Language.Substructure.map_bot","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\n⊢ Eq (FirstOrder.Language.Substructure.map f Bot.bot) Bot.bot","decl":"@[simp]\ntheorem map_bot (f : M →[L] N) : (⊥ : L.Substructure M).map f = ⊥ :=\n  (gc_map_comap f).l_bot\n\n"}
{"name":"FirstOrder.Language.Substructure.comap_top","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\n⊢ Eq (FirstOrder.Language.Substructure.comap f Top.top) Top.top","decl":"@[simp]\ntheorem comap_top (f : M →[L] N) : (⊤ : L.Substructure N).comap f = ⊤ :=\n  (gc_map_comap f).u_top\n\n"}
{"name":"FirstOrder.Language.Substructure.map_id","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS : L.Substructure M\n⊢ Eq (FirstOrder.Language.Substructure.map (FirstOrder.Language.Hom.id L M) S) S","decl":"@[simp]\ntheorem map_id (S : L.Substructure M) : S.map (Hom.id L M) = S :=\n  SetLike.coe_injective <| Set.image_id _\n\n"}
{"name":"FirstOrder.Language.Substructure.map_closure","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\ns : Set M\n⊢ Eq (FirstOrder.Language.Substructure.map f ((FirstOrder.Language.Substructure.closure L).toFun s)) ((FirstOrder.Language.Substructure.closure L).toFun (Set.image (⇑f) s))","decl":"theorem map_closure (f : M →[L] N) (s : Set M) : (closure L s).map f = closure L (f '' s) :=\n  Eq.symm <|\n    closure_eq_of_le (Set.image_subset f subset_closure) <|\n      map_le_iff_le_comap.2 <| closure_le.2 fun x hx => subset_closure ⟨x, hx, rfl⟩\n\n"}
{"name":"FirstOrder.Language.Substructure.closure_image","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\ns : Set M\nf : L.Hom M N\n⊢ Eq ((FirstOrder.Language.Substructure.closure L).toFun (Set.image (⇑f) s)) (FirstOrder.Language.Substructure.map f ((FirstOrder.Language.Substructure.closure L).toFun s))","decl":"@[simp]\ntheorem closure_image (f : M →[L] N) : closure L (f '' s) = map f (closure L s) :=\n  (map_closure f s).symm\n\n"}
{"name":"FirstOrder.Language.Substructure.comap_map_eq_of_injective","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\nhf : Function.Injective ⇑f\nS : L.Substructure M\n⊢ Eq (FirstOrder.Language.Substructure.comap f (FirstOrder.Language.Substructure.map f S)) S","decl":"theorem comap_map_eq_of_injective (S : L.Substructure M) : (S.map f).comap f = S :=\n  (gciMapComap hf).u_l_eq _\n\n"}
{"name":"FirstOrder.Language.Substructure.comap_surjective_of_injective","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\nhf : Function.Injective ⇑f\n⊢ Function.Surjective (FirstOrder.Language.Substructure.comap f)","decl":"theorem comap_surjective_of_injective : Function.Surjective (comap f) :=\n  (gciMapComap hf).u_surjective\n\n"}
{"name":"FirstOrder.Language.Substructure.map_injective_of_injective","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\nhf : Function.Injective ⇑f\n⊢ Function.Injective (FirstOrder.Language.Substructure.map f)","decl":"theorem map_injective_of_injective : Function.Injective (map f) :=\n  (gciMapComap hf).l_injective\n\n"}
{"name":"FirstOrder.Language.Substructure.comap_inf_map_of_injective","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\nhf : Function.Injective ⇑f\nS T : L.Substructure M\n⊢ Eq (FirstOrder.Language.Substructure.comap f (Min.min (FirstOrder.Language.Substructure.map f S) (FirstOrder.Language.Substructure.map f T))) (Min.min S T)","decl":"theorem comap_inf_map_of_injective (S T : L.Substructure M) : (S.map f ⊓ T.map f).comap f = S ⊓ T :=\n  (gciMapComap hf).u_inf_l _ _\n\n"}
{"name":"FirstOrder.Language.Substructure.comap_iInf_map_of_injective","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nι : Type u_3\nf : L.Hom M N\nhf : Function.Injective ⇑f\nS : ι → L.Substructure M\n⊢ Eq (FirstOrder.Language.Substructure.comap f (iInf fun i => FirstOrder.Language.Substructure.map f (S i))) (iInf fun i => S i)","decl":"theorem comap_iInf_map_of_injective (S : ι → L.Substructure M) :\n    (⨅ i, (S i).map f).comap f = ⨅ i, S i :=\n  (gciMapComap hf).u_iInf_l _\n\n"}
{"name":"FirstOrder.Language.Substructure.comap_sup_map_of_injective","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\nhf : Function.Injective ⇑f\nS T : L.Substructure M\n⊢ Eq (FirstOrder.Language.Substructure.comap f (Max.max (FirstOrder.Language.Substructure.map f S) (FirstOrder.Language.Substructure.map f T))) (Max.max S T)","decl":"theorem comap_sup_map_of_injective (S T : L.Substructure M) : (S.map f ⊔ T.map f).comap f = S ⊔ T :=\n  (gciMapComap hf).u_sup_l _ _\n\n"}
{"name":"FirstOrder.Language.Substructure.comap_iSup_map_of_injective","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nι : Type u_3\nf : L.Hom M N\nhf : Function.Injective ⇑f\nS : ι → L.Substructure M\n⊢ Eq (FirstOrder.Language.Substructure.comap f (iSup fun i => FirstOrder.Language.Substructure.map f (S i))) (iSup fun i => S i)","decl":"theorem comap_iSup_map_of_injective (S : ι → L.Substructure M) :\n    (⨆ i, (S i).map f).comap f = ⨆ i, S i :=\n  (gciMapComap hf).u_iSup_l _\n\n"}
{"name":"FirstOrder.Language.Substructure.map_le_map_iff_of_injective","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\nhf : Function.Injective ⇑f\nS T : L.Substructure M\n⊢ Iff (LE.le (FirstOrder.Language.Substructure.map f S) (FirstOrder.Language.Substructure.map f T)) (LE.le S T)","decl":"theorem map_le_map_iff_of_injective {S T : L.Substructure M} : S.map f ≤ T.map f ↔ S ≤ T :=\n  (gciMapComap hf).l_le_l_iff\n\n"}
{"name":"FirstOrder.Language.Substructure.map_strictMono_of_injective","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\nhf : Function.Injective ⇑f\n⊢ StrictMono (FirstOrder.Language.Substructure.map f)","decl":"theorem map_strictMono_of_injective : StrictMono (map f) :=\n  (gciMapComap hf).strictMono_l\n\n"}
{"name":"FirstOrder.Language.Substructure.map_comap_eq_of_surjective","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\nhf : Function.Surjective ⇑f\nS : L.Substructure N\n⊢ Eq (FirstOrder.Language.Substructure.map f (FirstOrder.Language.Substructure.comap f S)) S","decl":"theorem map_comap_eq_of_surjective (S : L.Substructure N) : (S.comap f).map f = S :=\n  (giMapComap hf).l_u_eq _\n\n"}
{"name":"FirstOrder.Language.Substructure.map_surjective_of_surjective","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\nhf : Function.Surjective ⇑f\n⊢ Function.Surjective (FirstOrder.Language.Substructure.map f)","decl":"theorem map_surjective_of_surjective : Function.Surjective (map f) :=\n  (giMapComap hf).l_surjective\n\n"}
{"name":"FirstOrder.Language.Substructure.comap_injective_of_surjective","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\nhf : Function.Surjective ⇑f\n⊢ Function.Injective (FirstOrder.Language.Substructure.comap f)","decl":"theorem comap_injective_of_surjective : Function.Injective (comap f) :=\n  (giMapComap hf).u_injective\n\n"}
{"name":"FirstOrder.Language.Substructure.map_inf_comap_of_surjective","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\nhf : Function.Surjective ⇑f\nS T : L.Substructure N\n⊢ Eq (FirstOrder.Language.Substructure.map f (Min.min (FirstOrder.Language.Substructure.comap f S) (FirstOrder.Language.Substructure.comap f T))) (Min.min S T)","decl":"theorem map_inf_comap_of_surjective (S T : L.Substructure N) :\n    (S.comap f ⊓ T.comap f).map f = S ⊓ T :=\n  (giMapComap hf).l_inf_u _ _\n\n"}
{"name":"FirstOrder.Language.Substructure.map_iInf_comap_of_surjective","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nι : Type u_3\nf : L.Hom M N\nhf : Function.Surjective ⇑f\nS : ι → L.Substructure N\n⊢ Eq (FirstOrder.Language.Substructure.map f (iInf fun i => FirstOrder.Language.Substructure.comap f (S i))) (iInf fun i => S i)","decl":"theorem map_iInf_comap_of_surjective (S : ι → L.Substructure N) :\n    (⨅ i, (S i).comap f).map f = ⨅ i, S i :=\n  (giMapComap hf).l_iInf_u _\n\n"}
{"name":"FirstOrder.Language.Substructure.map_sup_comap_of_surjective","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\nhf : Function.Surjective ⇑f\nS T : L.Substructure N\n⊢ Eq (FirstOrder.Language.Substructure.map f (Max.max (FirstOrder.Language.Substructure.comap f S) (FirstOrder.Language.Substructure.comap f T))) (Max.max S T)","decl":"theorem map_sup_comap_of_surjective (S T : L.Substructure N) :\n    (S.comap f ⊔ T.comap f).map f = S ⊔ T :=\n  (giMapComap hf).l_sup_u _ _\n\n"}
{"name":"FirstOrder.Language.Substructure.map_iSup_comap_of_surjective","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nι : Type u_3\nf : L.Hom M N\nhf : Function.Surjective ⇑f\nS : ι → L.Substructure N\n⊢ Eq (FirstOrder.Language.Substructure.map f (iSup fun i => FirstOrder.Language.Substructure.comap f (S i))) (iSup fun i => S i)","decl":"theorem map_iSup_comap_of_surjective (S : ι → L.Substructure N) :\n    (⨆ i, (S i).comap f).map f = ⨆ i, S i :=\n  (giMapComap hf).l_iSup_u _\n\n"}
{"name":"FirstOrder.Language.Substructure.comap_le_comap_iff_of_surjective","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\nhf : Function.Surjective ⇑f\nS T : L.Substructure N\n⊢ Iff (LE.le (FirstOrder.Language.Substructure.comap f S) (FirstOrder.Language.Substructure.comap f T)) (LE.le S T)","decl":"theorem comap_le_comap_iff_of_surjective {S T : L.Substructure N} : S.comap f ≤ T.comap f ↔ S ≤ T :=\n  (giMapComap hf).u_le_u_iff\n\n"}
{"name":"FirstOrder.Language.Substructure.comap_strictMono_of_surjective","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\nhf : Function.Surjective ⇑f\n⊢ StrictMono (FirstOrder.Language.Substructure.comap f)","decl":"theorem comap_strictMono_of_surjective : StrictMono (comap f) :=\n  (giMapComap hf).strictMono_u\n\n"}
{"name":"FirstOrder.Language.Substructure.coeSubtype","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS : L.Substructure M\n⊢ Eq (⇑S.subtype) Subtype.val","decl":"@[simp]\ntheorem coeSubtype : ⇑S.subtype = ((↑) : S → M) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Substructure.coe_topEquiv","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\n⊢ Eq (⇑FirstOrder.Language.Substructure.topEquiv) Subtype.val","decl":"@[simp]\ntheorem coe_topEquiv :\n    ⇑(topEquiv : (⊤ : L.Substructure M) ≃[L] M) = ((↑) : (⊤ : L.Substructure M) → M) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Substructure.realize_boundedFormula_top","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u_3\nn : Nat\nφ : L.BoundedFormula α n\nv : α → Subtype fun x => Membership.mem Top.top x\nxs : Fin n → Subtype fun x => Membership.mem Top.top x\n⊢ Iff (φ.Realize v xs) (φ.Realize (Function.comp Subtype.val v) (Function.comp Subtype.val xs))","decl":"@[simp]\ntheorem realize_boundedFormula_top {α : Type*} {n : ℕ} {φ : L.BoundedFormula α n}\n    {v : α → (⊤ : L.Substructure M)} {xs : Fin n → (⊤ : L.Substructure M)} :\n    φ.Realize v xs ↔ φ.Realize (((↑) : _ → M) ∘ v) ((↑) ∘ xs) := by\n  rw [← StrongHomClass.realize_boundedFormula Substructure.topEquiv φ]\n  simp\n\n"}
{"name":"FirstOrder.Language.Substructure.realize_formula_top","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u_3\nφ : L.Formula α\nv : α → Subtype fun x => Membership.mem Top.top x\n⊢ Iff (φ.Realize v) (φ.Realize (Function.comp Subtype.val v))","decl":"@[simp]\ntheorem realize_formula_top {α : Type*} {φ : L.Formula α} {v : α → (⊤ : L.Substructure M)} :\n    φ.Realize v ↔ φ.Realize (((↑) : (⊤ : L.Substructure M) → M) ∘ v) := by\n  rw [← StrongHomClass.realize_formula Substructure.topEquiv φ]\n  simp\n\n"}
{"name":"FirstOrder.Language.Substructure.closure_induction'","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\ns : Set M\np : (x : M) → Membership.mem ((FirstOrder.Language.Substructure.closure L).toFun s) x → Prop\nHs : ∀ (x : M) (h : Membership.mem s x), p x ⋯\nHfun : ∀ {n : Nat} (f : L.Functions n), FirstOrder.Language.ClosedUnder f (setOf fun x => Exists fun hx => p x hx)\nx : M\nhx : Membership.mem ((FirstOrder.Language.Substructure.closure L).toFun s) x\n⊢ p x hx","decl":"/-- A dependent version of `Substructure.closure_induction`. -/\n@[elab_as_elim]\ntheorem closure_induction' (s : Set M) {p : ∀ x, x ∈ closure L s → Prop}\n    (Hs : ∀ (x) (h : x ∈ s), p x (subset_closure h))\n    (Hfun : ∀ {n : ℕ} (f : L.Functions n), ClosedUnder f { x | ∃ hx, p x hx }) {x}\n    (hx : x ∈ closure L s) : p x hx := by\n  refine Exists.elim ?_ fun (hx : x ∈ closure L s) (hc : p x hx) => hc\n  exact closure_induction hx (fun x hx => ⟨subset_closure hx, Hs x hx⟩) @Hfun\n\n"}
{"name":"FirstOrder.Language.LHom.mem_substructureReduct","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝² : L.Structure M\nL' : FirstOrder.Language\ninst✝¹ : L'.Structure M\nφ : L.LHom L'\ninst✝ : φ.IsExpansionOn M\nx : M\nS : L'.Substructure M\n⊢ Iff (Membership.mem (φ.substructureReduct S) x) (Membership.mem S x)","decl":"@[simp]\ntheorem mem_substructureReduct {x : M} {S : L'.Substructure M} :\n    x ∈ φ.substructureReduct S ↔ x ∈ S :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.LHom.coe_substructureReduct","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝² : L.Structure M\nL' : FirstOrder.Language\ninst✝¹ : L'.Structure M\nφ : L.LHom L'\ninst✝ : φ.IsExpansionOn M\nS : L'.Substructure M\n⊢ Eq ↑(φ.substructureReduct S) ↑S","decl":"@[simp]\ntheorem coe_substructureReduct {S : L'.Substructure M} : (φ.substructureReduct S : Set M) = ↑S :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Substructure.mem_withConstants","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS : L.Substructure M\nA : Set M\nh : HasSubset.Subset A ↑S\nx : M\n⊢ Iff (Membership.mem (S.withConstants h) x) (Membership.mem S x)","decl":"@[simp]\ntheorem mem_withConstants {x : M} : x ∈ S.withConstants h ↔ x ∈ S :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.Substructure.coe_withConstants","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS : L.Substructure M\nA : Set M\nh : HasSubset.Subset A ↑S\n⊢ Eq ↑(S.withConstants h) ↑S","decl":"@[simp]\ntheorem coe_withConstants : (S.withConstants h : Set M) = ↑S :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Substructure.reduct_withConstants","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS : L.Substructure M\nA : Set M\nh : HasSubset.Subset A ↑S\n⊢ Eq ((L.lhomWithConstants ↑A).substructureReduct (S.withConstants h)) S","decl":"@[simp]\ntheorem reduct_withConstants :\n    (L.lhomWithConstants A).substructureReduct (S.withConstants h) = S := by\n  ext\n  simp\n\n"}
{"name":"FirstOrder.Language.Substructure.subset_closure_withConstants","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nA s : Set M\n⊢ HasSubset.Subset A ↑((FirstOrder.Language.Substructure.closure (L.withConstants ↑A)).toFun s)","decl":"theorem subset_closure_withConstants : A ⊆ closure (L[[A]]) s := by\n  intro a ha\n  simp only [SetLike.mem_coe]\n  let a' : L[[A]].Constants := Sum.inr ⟨a, ha⟩\n  exact constants_mem a'\n\n"}
{"name":"FirstOrder.Language.Substructure.closure_withConstants_eq","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nA s : Set M\n⊢ Eq ((FirstOrder.Language.Substructure.closure (L.withConstants ↑A)).toFun s) (((FirstOrder.Language.Substructure.closure L).toFun (Union.union A s)).withConstants ⋯)","decl":"theorem closure_withConstants_eq :\n    closure (L[[A]]) s =\n      (closure L (A ∪ s)).withConstants ((A.subset_union_left).trans subset_closure) := by\n  refine closure_eq_of_le ((A.subset_union_right).trans subset_closure) ?_\n  rw [← (L.lhomWithConstants A).substructureReduct.le_iff_le]\n  simp only [subset_closure, reduct_withConstants, closure_le, LHom.coe_substructureReduct,\n    Set.union_subset_iff, and_true]\n  exact subset_closure_withConstants\n\n"}
{"name":"FirstOrder.Language.Hom.domRestrict_toFun","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\np : L.Substructure M\na✝ : Subtype fun x => Membership.mem p x\n⊢ Eq ((f.domRestrict p) a✝) (f ↑a✝)","decl":"/-- The restriction of a first-order hom to a substructure `s ⊆ M` gives a hom `s → N`. -/\n@[simps!]\ndef domRestrict (f : M →[L] N) (p : L.Substructure M) : p →[L] N :=\n  f.comp p.subtype.toHom\n\n"}
{"name":"FirstOrder.Language.Hom.codRestrict_toFun_coe","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\np : L.Substructure N\nf : L.Hom M N\nh : ∀ (c : M), Membership.mem p (f c)\nc : M\n⊢ Eq (↑((FirstOrder.Language.Hom.codRestrict p f h) c)) (f c)","decl":"/-- A first-order hom `f : M → N` whose values lie in a substructure `p ⊆ N` can be restricted to a\nhom `M → p`. -/\n@[simps]\ndef codRestrict (p : L.Substructure N) (f : M →[L] N) (h : ∀ c, f c ∈ p) : M →[L] p where\n  toFun c := ⟨f c, h c⟩\n  map_fun' {n} f x := by aesop\n  map_rel' {_} R x h := f.map_rel R x h\n\n"}
{"name":"FirstOrder.Language.Hom.comp_codRestrict","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\ninst✝ : L.Structure P\nf : L.Hom M N\ng : L.Hom N P\np : L.Substructure P\nh : ∀ (b : N), Membership.mem p (g b)\n⊢ Eq ((FirstOrder.Language.Hom.codRestrict p g h).comp f) (FirstOrder.Language.Hom.codRestrict p (g.comp f) ⋯)","decl":"@[simp]\ntheorem comp_codRestrict (f : M →[L] N) (g : N →[L] P) (p : L.Substructure P) (h : ∀ b, g b ∈ p) :\n    ((codRestrict p g h).comp f : M →[L] p) = codRestrict p (g.comp f) fun _ => h _ :=\n  ext fun _ => rfl\n\n"}
{"name":"FirstOrder.Language.Hom.subtype_comp_codRestrict","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\np : L.Substructure N\nh : ∀ (b : M), Membership.mem p (f b)\n⊢ Eq (p.subtype.toHom.comp (FirstOrder.Language.Hom.codRestrict p f h)) f","decl":"@[simp]\ntheorem subtype_comp_codRestrict (f : M →[L] N) (p : L.Substructure N) (h : ∀ b, f b ∈ p) :\n    p.subtype.toHom.comp (codRestrict p f h) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"FirstOrder.Language.Hom.range_coe","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\n⊢ Eq (↑f.range) (Set.range ⇑f)","decl":"theorem range_coe (f : M →[L] N) : (range f : Set N) = Set.range f :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Hom.mem_range","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\nx : N\n⊢ Iff (Membership.mem f.range x) (Exists fun y => Eq (f y) x)","decl":"@[simp]\ntheorem mem_range {f : M →[L] N} {x} : x ∈ range f ↔ ∃ y, f y = x :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.Hom.range_eq_map","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\n⊢ Eq f.range (FirstOrder.Language.Substructure.map f Top.top)","decl":"theorem range_eq_map (f : M →[L] N) : f.range = map f ⊤ := by\n  ext\n  simp\n\n"}
{"name":"FirstOrder.Language.Hom.mem_range_self","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\nx : M\n⊢ Membership.mem f.range (f x)","decl":"theorem mem_range_self (f : M →[L] N) (x : M) : f x ∈ f.range :=\n  ⟨x, rfl⟩\n\n"}
{"name":"FirstOrder.Language.Hom.range_id","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\n⊢ Eq (FirstOrder.Language.Hom.id L M).range Top.top","decl":"@[simp]\ntheorem range_id : range (id L M) = ⊤ :=\n  SetLike.coe_injective Set.range_id\n\n"}
{"name":"FirstOrder.Language.Hom.range_comp","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\ninst✝ : L.Structure P\nf : L.Hom M N\ng : L.Hom N P\n⊢ Eq (g.comp f).range (FirstOrder.Language.Substructure.map g f.range)","decl":"theorem range_comp (f : M →[L] N) (g : N →[L] P) : range (g.comp f : M →[L] P) = map g (range f) :=\n  SetLike.coe_injective (Set.range_comp g f)\n\n"}
{"name":"FirstOrder.Language.Hom.range_comp_le_range","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\ninst✝ : L.Structure P\nf : L.Hom M N\ng : L.Hom N P\n⊢ LE.le (g.comp f).range g.range","decl":"theorem range_comp_le_range (f : M →[L] N) (g : N →[L] P) : range (g.comp f : M →[L] P) ≤ range g :=\n  SetLike.coe_mono (Set.range_comp_subset_range f g)\n\n"}
{"name":"FirstOrder.Language.Hom.range_eq_top","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\n⊢ Iff (Eq f.range Top.top) (Function.Surjective ⇑f)","decl":"theorem range_eq_top {f : M →[L] N} : range f = ⊤ ↔ Function.Surjective f := by\n  rw [SetLike.ext'_iff, range_coe, coe_top, Set.range_eq_univ]\n\n"}
{"name":"FirstOrder.Language.Hom.range_le_iff_comap","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\np : L.Substructure N\n⊢ Iff (LE.le f.range p) (Eq (FirstOrder.Language.Substructure.comap f p) Top.top)","decl":"theorem range_le_iff_comap {f : M →[L] N} {p : L.Substructure N} : range f ≤ p ↔ comap f p = ⊤ := by\n  rw [range_eq_map, map_le_iff_le_comap, eq_top_iff]\n\n"}
{"name":"FirstOrder.Language.Hom.map_le_range","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\np : L.Substructure M\n⊢ LE.le (FirstOrder.Language.Substructure.map f p) f.range","decl":"theorem map_le_range {f : M →[L] N} {p : L.Substructure M} : map f p ≤ range f :=\n  SetLike.coe_mono (Set.image_subset_range f p)\n\n"}
{"name":"FirstOrder.Language.Hom.eqOn_closure","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.Hom M N\ns : Set M\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Set.EqOn ⇑f ⇑g ↑((FirstOrder.Language.Substructure.closure L).toFun s)","decl":"/-- If two `L.Hom`s are equal on a set, then they are equal on its substructure closure. -/\ntheorem eqOn_closure {f g : M →[L] N} {s : Set M} (h : Set.EqOn f g s) :\n    Set.EqOn f g (closure L s) :=\n  show closure L s ≤ f.eqLocus g from closure_le.2 h\n\n"}
{"name":"FirstOrder.Language.Hom.eq_of_eqOn_top","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.Hom M N\nh : Set.EqOn ⇑f ⇑g ↑Top.top\n⊢ Eq f g","decl":"theorem eq_of_eqOn_top {f g : M →[L] N} (h : Set.EqOn f g (⊤ : Substructure L M)) : f = g :=\n  ext fun _ => h trivial\n\n"}
{"name":"FirstOrder.Language.Hom.eq_of_eqOn_dense","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\ns : Set M\nhs : Eq ((FirstOrder.Language.Substructure.closure L).toFun s) Top.top\nf g : L.Hom M N\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Eq f g","decl":"theorem eq_of_eqOn_dense (hs : closure L s = ⊤) {f g : M →[L] N} (h : s.EqOn f g) : f = g :=\n  eq_of_eqOn_top <| hs ▸ eqOn_closure h\n\n"}
{"name":"FirstOrder.Language.Embedding.domRestrict_apply","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Embedding M N\np : L.Substructure M\nx : Subtype fun x => Membership.mem p x\n⊢ Eq ((f.domRestrict p) x) (f ↑x)","decl":"@[simp]\ntheorem domRestrict_apply (f : M ↪[L] N) (p : L.Substructure M) (x : p) : f.domRestrict p x = f x :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Embedding.codRestrict_apply","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\np : L.Substructure N\nf : L.Embedding M N\nh : ∀ (c : M), Membership.mem p (f c)\nx : M\n⊢ Eq (↑((FirstOrder.Language.Embedding.codRestrict p f h) x)) (f x)","decl":"@[simp]\ntheorem codRestrict_apply (p : L.Substructure N) (f : M ↪[L] N) {h} (x : M) :\n    (codRestrict p f h x : N) = f x :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Embedding.codRestrict_apply'","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\np : L.Substructure N\nf : L.Embedding M N\nh : ∀ (c : M), Membership.mem p (f c)\nx : M\n⊢ Eq ((FirstOrder.Language.Embedding.codRestrict p f h) x) ⟨f x, ⋯⟩","decl":"@[simp]\ntheorem codRestrict_apply' (p : L.Substructure N) (f : M ↪[L] N) {h} (x : M) :\n    codRestrict p f h x = ⟨f x, h x⟩ :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Embedding.comp_codRestrict","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\ninst✝ : L.Structure P\nf : L.Embedding M N\ng : L.Embedding N P\np : L.Substructure P\nh : ∀ (b : N), Membership.mem p (g b)\n⊢ Eq ((FirstOrder.Language.Embedding.codRestrict p g h).comp f) (FirstOrder.Language.Embedding.codRestrict p (g.comp f) ⋯)","decl":"@[simp]\ntheorem comp_codRestrict (f : M ↪[L] N) (g : N ↪[L] P) (p : L.Substructure P) (h : ∀ b, g b ∈ p) :\n    ((codRestrict p g h).comp f : M ↪[L] p) = codRestrict p (g.comp f) fun _ => h _ :=\n  ext fun _ => rfl\n\n"}
{"name":"FirstOrder.Language.Embedding.subtype_comp_codRestrict","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Embedding M N\np : L.Substructure N\nh : ∀ (b : M), Membership.mem p (f b)\n⊢ Eq (p.subtype.comp (FirstOrder.Language.Embedding.codRestrict p f h)) f","decl":"@[simp]\ntheorem subtype_comp_codRestrict (f : M ↪[L] N) (p : L.Substructure N) (h : ∀ b, f b ∈ p) :\n    p.subtype.comp (codRestrict p f h) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"FirstOrder.Language.Embedding.substructureEquivMap_apply","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Embedding M N\np : L.Substructure M\nx : Subtype fun x => Membership.mem p x\n⊢ Eq (↑((f.substructureEquivMap p) x)) (f ↑x)","decl":"@[simp]\ntheorem substructureEquivMap_apply (f : M ↪[L] N) (p : L.Substructure M) (x : p) :\n    (f.substructureEquivMap p x : N) = f x :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Embedding.subtype_substructureEquivMap","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Embedding M N\ns : L.Substructure M\n⊢ Eq ((FirstOrder.Language.Substructure.map f.toHom s).subtype.comp (f.substructureEquivMap s).toEmbedding) (f.comp s.subtype)","decl":"@[simp]\ntheorem subtype_substructureEquivMap (f : M ↪[L] N) (s : L.Substructure M) :\n    (subtype _).comp (f.substructureEquivMap s).toEmbedding = f.comp (subtype _) := by\n  ext; rfl\n\n"}
{"name":"FirstOrder.Language.Embedding.equivRange_toEquiv_apply","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Embedding M N\na : M\n⊢ Eq (f.equivRange.toEquiv a) ((FirstOrder.Language.Embedding.codRestrict f.toHom.range f ⋯) a)","decl":"/-- The equivalence between the domain and the range of an embedding `f`. -/\n@[simps toEquiv_apply] noncomputable def equivRange (f : M ↪[L] N) : M ≃[L] f.toHom.range where\n  toFun := codRestrict f.toHom.range f f.toHom.mem_range_self\n  invFun n := Classical.choose n.2\n  left_inv m :=\n    f.injective (Classical.choose_spec (codRestrict f.toHom.range f f.toHom.mem_range_self m).2)\n  right_inv := fun ⟨_, hn⟩ => Subtype.mk_eq_mk.2 (Classical.choose_spec hn)\n  map_fun' {n} f x := by simp\n  map_rel' {n} R x := by simp\n\n"}
{"name":"FirstOrder.Language.Embedding.equivRange_apply","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Embedding M N\nx : M\n⊢ Eq (↑(f.equivRange x)) (f x)","decl":"@[simp]\ntheorem equivRange_apply (f : M ↪[L] N) (x : M) : (f.equivRange x : N) = f x :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Embedding.subtype_equivRange","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Embedding M N\n⊢ Eq (f.toHom.range.subtype.comp f.equivRange.toEmbedding) f","decl":"@[simp]\ntheorem subtype_equivRange (f : M ↪[L] N) : (subtype _).comp f.equivRange.toEmbedding = f := by\n  ext; rfl\n\n"}
{"name":"FirstOrder.Language.Equiv.toHom_range","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Equiv M N\n⊢ Eq f.toHom.range Top.top","decl":"theorem toHom_range (f : M ≃[L] N) : f.toHom.range = ⊤ := by\n  ext n\n  simp only [Hom.mem_range, coe_toHom, Substructure.mem_top, iff_true]\n  exact ⟨f.symm n, apply_symm_apply _ _⟩\n\n"}
{"name":"FirstOrder.Language.Substructure.inclusion_self","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS : L.Substructure M\n⊢ Eq (FirstOrder.Language.Substructure.inclusion ⋯) (FirstOrder.Language.Embedding.refl L (Subtype fun x => Membership.mem S x))","decl":"@[simp]\ntheorem inclusion_self (S : L.Substructure M) : inclusion (le_refl S) = Embedding.refl L S := rfl\n\n"}
{"name":"FirstOrder.Language.Substructure.coe_inclusion","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS T : L.Substructure M\nh : LE.le S T\n⊢ Eq (⇑(FirstOrder.Language.Substructure.inclusion h)) (Set.inclusion h)","decl":"@[simp]\ntheorem coe_inclusion {S T : L.Substructure M} (h : S ≤ T) :\n    (inclusion h : S → T) = Set.inclusion h :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Substructure.range_subtype","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS : L.Substructure M\n⊢ Eq S.subtype.toHom.range S","decl":"theorem range_subtype (S : L.Substructure M) : S.subtype.toHom.range = S := by\n  ext x\n  simp only [Hom.mem_range, Embedding.coe_toHom, coeSubtype]\n  refine ⟨?_, fun h => ⟨⟨x, h⟩, rfl⟩⟩\n  rintro ⟨⟨y, hy⟩, rfl⟩\n  exact hy\n\n"}
{"name":"FirstOrder.Language.Substructure.subtype_comp_inclusion","module":"Mathlib.ModelTheory.Substructures","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS T : L.Substructure M\nh : LE.le S T\n⊢ Eq (T.subtype.comp (FirstOrder.Language.Substructure.inclusion h)) S.subtype","decl":"@[simp]\nlemma subtype_comp_inclusion {S T : L.Substructure M} (h : S ≤ T) :\n    T.subtype.comp (inclusion h) = S.subtype := rfl\n\n"}
