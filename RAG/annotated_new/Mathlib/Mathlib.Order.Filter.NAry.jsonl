{"name":"Filter.mem_map₂_iff","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf : Filter α\ng : Filter β\nu : Set γ\n⊢ Iff (Membership.mem (Filter.map₂ m f g) u) (Exists fun s => And (Membership.mem f s) (Exists fun t => And (Membership.mem g t) (HasSubset.Subset (Set.image2 m s t) u)))","decl":"@[simp 900]\ntheorem mem_map₂_iff : u ∈ map₂ m f g ↔ ∃ s ∈ f, ∃ t ∈ g, image2 m s t ⊆ u :=\n  Iff.rfl\n\n"}
{"name":"Filter.image2_mem_map₂","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf : Filter α\ng : Filter β\ns : Set α\nt : Set β\nhs : Membership.mem f s\nht : Membership.mem g t\n⊢ Membership.mem (Filter.map₂ m f g) (Set.image2 m s t)","decl":"theorem image2_mem_map₂ (hs : s ∈ f) (ht : t ∈ g) : image2 m s t ∈ map₂ m f g :=\n  ⟨_, hs, _, ht, Subset.rfl⟩\n\n"}
{"name":"Filter.map_prod_eq_map₂","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf : Filter α\ng : Filter β\n⊢ Eq (Filter.map (fun p => m p.1 p.2) (SProd.sprod f g)) (Filter.map₂ m f g)","decl":"theorem map_prod_eq_map₂ (m : α → β → γ) (f : Filter α) (g : Filter β) :\n    Filter.map (fun p : α × β => m p.1 p.2) (f ×ˢ g) = map₂ m f g := by\n  rw [map₂, copy_eq, uncurry_def]\n\n"}
{"name":"Filter.map_prod_eq_map₂'","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : Prod α β → γ\nf : Filter α\ng : Filter β\n⊢ Eq (Filter.map m (SProd.sprod f g)) (Filter.map₂ (fun a b => m { fst := a, snd := b }) f g)","decl":"theorem map_prod_eq_map₂' (m : α × β → γ) (f : Filter α) (g : Filter β) :\n    Filter.map m (f ×ˢ g) = map₂ (fun a b => m (a, b)) f g :=\n  map_prod_eq_map₂ m.curry f g\n\n"}
{"name":"Filter.map₂_mk_eq_prod","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nf : Filter α\ng : Filter β\n⊢ Eq (Filter.map₂ Prod.mk f g) (SProd.sprod f g)","decl":"@[simp]\ntheorem map₂_mk_eq_prod (f : Filter α) (g : Filter β) : map₂ Prod.mk f g = f ×ˢ g := by\n  simp only [← map_prod_eq_map₂, map_id']\n\n-- lemma image2_mem_map₂_iff (hm : injective2 m) : image2 m s t ∈ map₂ m f g ↔ s ∈ f ∧ t ∈ g :=\n-- ⟨by { rintro ⟨u, v, hu, hv, h⟩, rw image2_subset_image2_iff hm at h,\n--   exact ⟨mem_of_superset hu h.1, mem_of_superset hv h.2⟩ }, fun h ↦ image2_mem_map₂ h.1 h.2⟩\n"}
{"name":"Filter.map₂_mono","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf₁ f₂ : Filter α\ng₁ g₂ : Filter β\nhf : LE.le f₁ f₂\nhg : LE.le g₁ g₂\n⊢ LE.le (Filter.map₂ m f₁ g₁) (Filter.map₂ m f₂ g₂)","decl":"@[gcongr]\ntheorem map₂_mono (hf : f₁ ≤ f₂) (hg : g₁ ≤ g₂) : map₂ m f₁ g₁ ≤ map₂ m f₂ g₂ :=\n  fun _ ⟨s, hs, t, ht, hst⟩ => ⟨s, hf hs, t, hg ht, hst⟩\n\n"}
{"name":"Filter.map₂_mono_left","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf : Filter α\ng₁ g₂ : Filter β\nh : LE.le g₁ g₂\n⊢ LE.le (Filter.map₂ m f g₁) (Filter.map₂ m f g₂)","decl":"@[gcongr]\ntheorem map₂_mono_left (h : g₁ ≤ g₂) : map₂ m f g₁ ≤ map₂ m f g₂ :=\n  map₂_mono Subset.rfl h\n\n"}
{"name":"Filter.map₂_mono_right","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf₁ f₂ : Filter α\ng : Filter β\nh : LE.le f₁ f₂\n⊢ LE.le (Filter.map₂ m f₁ g) (Filter.map₂ m f₂ g)","decl":"@[gcongr]\ntheorem map₂_mono_right (h : f₁ ≤ f₂) : map₂ m f₁ g ≤ map₂ m f₂ g :=\n  map₂_mono h Subset.rfl\n\n"}
{"name":"Filter.le_map₂_iff","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf : Filter α\ng : Filter β\nh : Filter γ\n⊢ Iff (LE.le h (Filter.map₂ m f g)) (∀ ⦃s : Set α⦄, Membership.mem f s → ∀ ⦃t : Set β⦄, Membership.mem g t → Membership.mem h (Set.image2 m s t))","decl":"@[simp]\ntheorem le_map₂_iff {h : Filter γ} :\n    h ≤ map₂ m f g ↔ ∀ ⦃s⦄, s ∈ f → ∀ ⦃t⦄, t ∈ g → image2 m s t ∈ h :=\n  ⟨fun H _ hs _ ht => H <| image2_mem_map₂ hs ht, fun H _ ⟨_, hs, _, ht, hu⟩ =>\n    mem_of_superset (H hs ht) hu⟩\n\n"}
{"name":"Filter.map₂_eq_bot_iff","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf : Filter α\ng : Filter β\n⊢ Iff (Eq (Filter.map₂ m f g) Bot.bot) (Or (Eq f Bot.bot) (Eq g Bot.bot))","decl":"@[simp]\ntheorem map₂_eq_bot_iff : map₂ m f g = ⊥ ↔ f = ⊥ ∨ g = ⊥ := by simp [← map_prod_eq_map₂]\n\n"}
{"name":"Filter.map₂_bot_left","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\ng : Filter β\n⊢ Eq (Filter.map₂ m Bot.bot g) Bot.bot","decl":"@[simp]\ntheorem map₂_bot_left : map₂ m ⊥ g = ⊥ := map₂_eq_bot_iff.2 <| .inl rfl\n\n"}
{"name":"Filter.map₂_bot_right","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf : Filter α\n⊢ Eq (Filter.map₂ m f Bot.bot) Bot.bot","decl":"@[simp]\ntheorem map₂_bot_right : map₂ m f ⊥ = ⊥ := map₂_eq_bot_iff.2 <| .inr rfl\n\n"}
{"name":"Filter.map₂_neBot_iff","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf : Filter α\ng : Filter β\n⊢ Iff (Filter.map₂ m f g).NeBot (And f.NeBot g.NeBot)","decl":"@[simp]\ntheorem map₂_neBot_iff : (map₂ m f g).NeBot ↔ f.NeBot ∧ g.NeBot := by simp [neBot_iff, not_or]\n\n"}
{"name":"Filter.NeBot.map₂","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf : Filter α\ng : Filter β\nhf : f.NeBot\nhg : g.NeBot\n⊢ (Filter.map₂ m f g).NeBot","decl":"protected theorem NeBot.map₂ (hf : f.NeBot) (hg : g.NeBot) : (map₂ m f g).NeBot :=\n  map₂_neBot_iff.2 ⟨hf, hg⟩\n\n"}
{"name":"Filter.map₂.neBot","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf : Filter α\ng : Filter β\ninst✝¹ : f.NeBot\ninst✝ : g.NeBot\n⊢ (Filter.map₂ m f g).NeBot","decl":"instance map₂.neBot [NeBot f] [NeBot g] : NeBot (map₂ m f g) := .map₂ ‹_› ‹_›\n\n"}
{"name":"Filter.NeBot.of_map₂_left","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf : Filter α\ng : Filter β\nh : (Filter.map₂ m f g).NeBot\n⊢ f.NeBot","decl":"theorem NeBot.of_map₂_left (h : (map₂ m f g).NeBot) : f.NeBot :=\n  (map₂_neBot_iff.1 h).1\n\n"}
{"name":"Filter.NeBot.of_map₂_right","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf : Filter α\ng : Filter β\nh : (Filter.map₂ m f g).NeBot\n⊢ g.NeBot","decl":"theorem NeBot.of_map₂_right (h : (map₂ m f g).NeBot) : g.NeBot :=\n  (map₂_neBot_iff.1 h).2\n\n"}
{"name":"Filter.map₂_sup_left","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf₁ f₂ : Filter α\ng : Filter β\n⊢ Eq (Filter.map₂ m (Max.max f₁ f₂) g) (Max.max (Filter.map₂ m f₁ g) (Filter.map₂ m f₂ g))","decl":"theorem map₂_sup_left : map₂ m (f₁ ⊔ f₂) g = map₂ m f₁ g ⊔ map₂ m f₂ g := by\n  simp_rw [← map_prod_eq_map₂, sup_prod, map_sup]\n\n"}
{"name":"Filter.map₂_sup_right","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf : Filter α\ng₁ g₂ : Filter β\n⊢ Eq (Filter.map₂ m f (Max.max g₁ g₂)) (Max.max (Filter.map₂ m f g₁) (Filter.map₂ m f g₂))","decl":"theorem map₂_sup_right : map₂ m f (g₁ ⊔ g₂) = map₂ m f g₁ ⊔ map₂ m f g₂ := by\n  simp_rw [← map_prod_eq_map₂, prod_sup, map_sup]\n\n"}
{"name":"Filter.map₂_inf_subset_left","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf₁ f₂ : Filter α\ng : Filter β\n⊢ LE.le (Filter.map₂ m (Min.min f₁ f₂) g) (Min.min (Filter.map₂ m f₁ g) (Filter.map₂ m f₂ g))","decl":"theorem map₂_inf_subset_left : map₂ m (f₁ ⊓ f₂) g ≤ map₂ m f₁ g ⊓ map₂ m f₂ g :=\n  Monotone.map_inf_le (fun _ _ ↦ map₂_mono_right) f₁ f₂\n\n"}
{"name":"Filter.map₂_inf_subset_right","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf : Filter α\ng₁ g₂ : Filter β\n⊢ LE.le (Filter.map₂ m f (Min.min g₁ g₂)) (Min.min (Filter.map₂ m f g₁) (Filter.map₂ m f g₂))","decl":"theorem map₂_inf_subset_right : map₂ m f (g₁ ⊓ g₂) ≤ map₂ m f g₁ ⊓ map₂ m f g₂ :=\n  Monotone.map_inf_le (fun _ _ ↦ map₂_mono_left) g₁ g₂\n\n"}
{"name":"Filter.map₂_pure_left","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\ng : Filter β\na : α\n⊢ Eq (Filter.map₂ m (Pure.pure a) g) (Filter.map (m a) g)","decl":"@[simp]\ntheorem map₂_pure_left : map₂ m (pure a) g = g.map (m a) := by\n  rw [← map_prod_eq_map₂, pure_prod, map_map]; rfl\n\n"}
{"name":"Filter.map₂_pure_right","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf : Filter α\nb : β\n⊢ Eq (Filter.map₂ m f (Pure.pure b)) (Filter.map (fun x => m x b) f)","decl":"@[simp]\ntheorem map₂_pure_right : map₂ m f (pure b) = f.map (m · b) := by\n  rw [← map_prod_eq_map₂, prod_pure, map_map]; rfl\n\n"}
{"name":"Filter.map₂_pure","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\na : α\nb : β\n⊢ Eq (Filter.map₂ m (Pure.pure a) (Pure.pure b)) (Pure.pure (m a b))","decl":"theorem map₂_pure : map₂ m (pure a) (pure b) = pure (m a b) := by rw [map₂_pure_right, map_pure]\n\n"}
{"name":"Filter.map₂_swap","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf : Filter α\ng : Filter β\n⊢ Eq (Filter.map₂ m f g) (Filter.map₂ (fun a b => m b a) g f)","decl":"theorem map₂_swap (m : α → β → γ) (f : Filter α) (g : Filter β) :\n    map₂ m f g = map₂ (fun a b => m b a) g f := by\n  rw [← map_prod_eq_map₂, prod_comm, map_map, ← map_prod_eq_map₂, Function.comp_def]\n\n"}
{"name":"Filter.map₂_left","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nf : Filter α\ng : Filter β\ninst✝ : g.NeBot\n⊢ Eq (Filter.map₂ (fun x x_1 => x) f g) f","decl":"@[simp]\ntheorem map₂_left [NeBot g] : map₂ (fun x _ => x) f g = f := by\n  rw [← map_prod_eq_map₂, map_fst_prod]\n\n"}
{"name":"Filter.map₂_right","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nf : Filter α\ng : Filter β\ninst✝ : f.NeBot\n⊢ Eq (Filter.map₂ (fun x y => y) f g) g","decl":"@[simp]\ntheorem map₂_right [NeBot f] : map₂ (fun _ y => y) f g = g := by rw [map₂_swap, map₂_left]\n\n"}
{"name":"Filter.map_map₂","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nδ : Type u_7\nf : Filter α\ng : Filter β\nm : α → β → γ\nn : γ → δ\n⊢ Eq (Filter.map n (Filter.map₂ m f g)) (Filter.map₂ (fun a b => n (m a b)) f g)","decl":"theorem map_map₂ (m : α → β → γ) (n : γ → δ) :\n    (map₂ m f g).map n = map₂ (fun a b => n (m a b)) f g := by\n  rw [← map_prod_eq_map₂, ← map_prod_eq_map₂, map_map]; rfl\n\n"}
{"name":"Filter.map₂_map_left","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nδ : Type u_7\nf : Filter α\ng : Filter β\nm : γ → β → δ\nn : α → γ\n⊢ Eq (Filter.map₂ m (Filter.map n f) g) (Filter.map₂ (fun a b => m (n a) b) f g)","decl":"theorem map₂_map_left (m : γ → β → δ) (n : α → γ) :\n    map₂ m (f.map n) g = map₂ (fun a b => m (n a) b) f g := by\n  rw [← map_prod_eq_map₂, ← map_prod_eq_map₂, ← @map_id _ g, prod_map_map_eq, map_map, map_id]; rfl\n\n"}
{"name":"Filter.map₂_map_right","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nδ : Type u_7\nf : Filter α\ng : Filter β\nm : α → γ → δ\nn : β → γ\n⊢ Eq (Filter.map₂ m f (Filter.map n g)) (Filter.map₂ (fun a b => m a (n b)) f g)","decl":"theorem map₂_map_right (m : α → γ → δ) (n : β → γ) :\n    map₂ m f (g.map n) = map₂ (fun a b => m a (n b)) f g := by\n  rw [map₂_swap, map₂_map_left, map₂_swap]\n\n"}
{"name":"Filter.map₂_curry","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : Prod α β → γ\nf : Filter α\ng : Filter β\n⊢ Eq (Filter.map₂ (Function.curry m) f g) (Filter.map m (SProd.sprod f g))","decl":"@[simp]\ntheorem map₂_curry (m : α × β → γ) (f : Filter α) (g : Filter β) :\n    map₂ m.curry f g = (f ×ˢ g).map m :=\n  (map_prod_eq_map₂' _ _ _).symm\n\n"}
{"name":"Filter.map_uncurry_prod","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf : Filter α\ng : Filter β\n⊢ Eq (Filter.map (Function.uncurry m) (SProd.sprod f g)) (Filter.map₂ m f g)","decl":"@[simp]\ntheorem map_uncurry_prod (m : α → β → γ) (f : Filter α) (g : Filter β) :\n    (f ×ˢ g).map (uncurry m) = map₂ m f g :=\n  (map₂_curry (uncurry m) f g).symm\n\n"}
{"name":"Filter.map₂_assoc","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nδ : Type u_7\nε : Type u_9\nε' : Type u_10\nf : Filter α\ng : Filter β\nm : δ → γ → ε\nn : α → β → δ\nm' : α → ε' → ε\nn' : β → γ → ε'\nh : Filter γ\nh_assoc : ∀ (a : α) (b : β) (c : γ), Eq (m (n a b) c) (m' a (n' b c))\n⊢ Eq (Filter.map₂ m (Filter.map₂ n f g) h) (Filter.map₂ m' f (Filter.map₂ n' g h))","decl":"theorem map₂_assoc {m : δ → γ → ε} {n : α → β → δ} {m' : α → ε' → ε} {n' : β → γ → ε'}\n    {h : Filter γ} (h_assoc : ∀ a b c, m (n a b) c = m' a (n' b c)) :\n    map₂ m (map₂ n f g) h = map₂ m' f (map₂ n' g h) := by\n  rw [← map_prod_eq_map₂ n, ← map_prod_eq_map₂ n', map₂_map_left, map₂_map_right,\n    ← map_prod_eq_map₂, ← map_prod_eq_map₂, ← prod_assoc, map_map]\n  simp only [h_assoc, Function.comp_def, Equiv.prodAssoc_apply]\n\n"}
{"name":"Filter.map₂_comm","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nm : α → β → γ\nf : Filter α\ng : Filter β\nn : β → α → γ\nh_comm : ∀ (a : α) (b : β), Eq (m a b) (n b a)\n⊢ Eq (Filter.map₂ m f g) (Filter.map₂ n g f)","decl":"theorem map₂_comm {n : β → α → γ} (h_comm : ∀ a b, m a b = n b a) : map₂ m f g = map₂ n g f :=\n  (map₂_swap _ _ _).trans <| by simp_rw [h_comm]\n\n"}
{"name":"Filter.map₂_left_comm","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nδ : Type u_7\nδ' : Type u_8\nε : Type u_9\nf : Filter α\ng : Filter β\nh : Filter γ\nm : α → δ → ε\nn : β → γ → δ\nm' : α → γ → δ'\nn' : β → δ' → ε\nh_left_comm : ∀ (a : α) (b : β) (c : γ), Eq (m a (n b c)) (n' b (m' a c))\n⊢ Eq (Filter.map₂ m f (Filter.map₂ n g h)) (Filter.map₂ n' g (Filter.map₂ m' f h))","decl":"theorem map₂_left_comm {m : α → δ → ε} {n : β → γ → δ} {m' : α → γ → δ'} {n' : β → δ' → ε}\n    (h_left_comm : ∀ a b c, m a (n b c) = n' b (m' a c)) :\n    map₂ m f (map₂ n g h) = map₂ n' g (map₂ m' f h) := by\n  rw [map₂_swap m', map₂_swap m]\n  exact map₂_assoc fun _ _ _ => h_left_comm _ _ _\n\n"}
{"name":"Filter.map₂_right_comm","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nγ : Type u_5\nδ : Type u_7\nδ' : Type u_8\nε : Type u_9\nf : Filter α\ng : Filter β\nh : Filter γ\nm : δ → γ → ε\nn : α → β → δ\nm' : α → γ → δ'\nn' : δ' → β → ε\nh_right_comm : ∀ (a : α) (b : β) (c : γ), Eq (m (n a b) c) (n' (m' a c) b)\n⊢ Eq (Filter.map₂ m (Filter.map₂ n f g) h) (Filter.map₂ n' (Filter.map₂ m' f h) g)","decl":"theorem map₂_right_comm {m : δ → γ → ε} {n : α → β → δ} {m' : α → γ → δ'} {n' : δ' → β → ε}\n    (h_right_comm : ∀ a b c, m (n a b) c = n' (m' a c) b) :\n    map₂ m (map₂ n f g) h = map₂ n' (map₂ m' f h) g := by\n  rw [map₂_swap n, map₂_swap n']\n  exact map₂_assoc fun _ _ _ => h_right_comm _ _ _\n\n"}
{"name":"Filter.map_map₂_distrib","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nα' : Type u_2\nβ : Type u_3\nβ' : Type u_4\nγ : Type u_5\nδ : Type u_7\nm : α → β → γ\nf : Filter α\ng : Filter β\nn : γ → δ\nm' : α' → β' → δ\nn₁ : α → α'\nn₂ : β → β'\nh_distrib : ∀ (a : α) (b : β), Eq (n (m a b)) (m' (n₁ a) (n₂ b))\n⊢ Eq (Filter.map n (Filter.map₂ m f g)) (Filter.map₂ m' (Filter.map n₁ f) (Filter.map n₂ g))","decl":"theorem map_map₂_distrib {n : γ → δ} {m' : α' → β' → δ} {n₁ : α → α'} {n₂ : β → β'}\n    (h_distrib : ∀ a b, n (m a b) = m' (n₁ a) (n₂ b)) :\n    (map₂ m f g).map n = map₂ m' (f.map n₁) (g.map n₂) := by\n  simp_rw [map_map₂, map₂_map_left, map₂_map_right, h_distrib]\n\n"}
{"name":"Filter.map_map₂_distrib_left","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nα' : Type u_2\nβ : Type u_3\nγ : Type u_5\nδ : Type u_7\nm : α → β → γ\nf : Filter α\ng : Filter β\nn : γ → δ\nm' : α' → β → δ\nn' : α → α'\nh_distrib : ∀ (a : α) (b : β), Eq (n (m a b)) (m' (n' a) b)\n⊢ Eq (Filter.map n (Filter.map₂ m f g)) (Filter.map₂ m' (Filter.map n' f) g)","decl":"/-- Symmetric statement to `Filter.map₂_map_left_comm`. -/\ntheorem map_map₂_distrib_left {n : γ → δ} {m' : α' → β → δ} {n' : α → α'}\n    (h_distrib : ∀ a b, n (m a b) = m' (n' a) b) : (map₂ m f g).map n = map₂ m' (f.map n') g :=\n  map_map₂_distrib h_distrib\n\n"}
{"name":"Filter.map_map₂_distrib_right","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nβ' : Type u_4\nγ : Type u_5\nδ : Type u_7\nm : α → β → γ\nf : Filter α\ng : Filter β\nn : γ → δ\nm' : α → β' → δ\nn' : β → β'\nh_distrib : ∀ (a : α) (b : β), Eq (n (m a b)) (m' a (n' b))\n⊢ Eq (Filter.map n (Filter.map₂ m f g)) (Filter.map₂ m' f (Filter.map n' g))","decl":"/-- Symmetric statement to `Filter.map_map₂_right_comm`. -/\ntheorem map_map₂_distrib_right {n : γ → δ} {m' : α → β' → δ} {n' : β → β'}\n    (h_distrib : ∀ a b, n (m a b) = m' a (n' b)) : (map₂ m f g).map n = map₂ m' f (g.map n') :=\n  map_map₂_distrib h_distrib\n\n"}
{"name":"Filter.map₂_map_left_comm","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nα' : Type u_2\nβ : Type u_3\nγ : Type u_5\nδ : Type u_7\nf : Filter α\ng : Filter β\nm : α' → β → γ\nn : α → α'\nm' : α → β → δ\nn' : δ → γ\nh_left_comm : ∀ (a : α) (b : β), Eq (m (n a) b) (n' (m' a b))\n⊢ Eq (Filter.map₂ m (Filter.map n f) g) (Filter.map n' (Filter.map₂ m' f g))","decl":"/-- Symmetric statement to `Filter.map_map₂_distrib_left`. -/\ntheorem map₂_map_left_comm {m : α' → β → γ} {n : α → α'} {m' : α → β → δ} {n' : δ → γ}\n    (h_left_comm : ∀ a b, m (n a) b = n' (m' a b)) : map₂ m (f.map n) g = (map₂ m' f g).map n' :=\n  (map_map₂_distrib_left fun a b => (h_left_comm a b).symm).symm\n\n"}
{"name":"Filter.map_map₂_right_comm","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nβ' : Type u_4\nγ : Type u_5\nδ : Type u_7\nf : Filter α\ng : Filter β\nm : α → β' → γ\nn : β → β'\nm' : α → β → δ\nn' : δ → γ\nh_right_comm : ∀ (a : α) (b : β), Eq (m a (n b)) (n' (m' a b))\n⊢ Eq (Filter.map₂ m f (Filter.map n g)) (Filter.map n' (Filter.map₂ m' f g))","decl":"/-- Symmetric statement to `Filter.map_map₂_distrib_right`. -/\ntheorem map_map₂_right_comm {m : α → β' → γ} {n : β → β'} {m' : α → β → δ} {n' : δ → γ}\n    (h_right_comm : ∀ a b, m a (n b) = n' (m' a b)) : map₂ m f (g.map n) = (map₂ m' f g).map n' :=\n  (map_map₂_distrib_right fun a b => (h_right_comm a b).symm).symm\n\n"}
{"name":"Filter.map₂_distrib_le_left","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nβ' : Type u_4\nγ : Type u_5\nγ' : Type u_6\nδ : Type u_7\nε : Type u_9\nf : Filter α\ng : Filter β\nh : Filter γ\nm : α → δ → ε\nn : β → γ → δ\nm₁ : α → β → β'\nm₂ : α → γ → γ'\nn' : β' → γ' → ε\nh_distrib : ∀ (a : α) (b : β) (c : γ), Eq (m a (n b c)) (n' (m₁ a b) (m₂ a c))\n⊢ LE.le (Filter.map₂ m f (Filter.map₂ n g h)) (Filter.map₂ n' (Filter.map₂ m₁ f g) (Filter.map₂ m₂ f h))","decl":"/-- The other direction does not hold because of the `f-f` cross terms on the RHS. -/\ntheorem map₂_distrib_le_left {m : α → δ → ε} {n : β → γ → δ} {m₁ : α → β → β'} {m₂ : α → γ → γ'}\n    {n' : β' → γ' → ε} (h_distrib : ∀ a b c, m a (n b c) = n' (m₁ a b) (m₂ a c)) :\n    map₂ m f (map₂ n g h) ≤ map₂ n' (map₂ m₁ f g) (map₂ m₂ f h) := by\n  rintro s ⟨t₁, ⟨u₁, hu₁, v, hv, ht₁⟩, t₂, ⟨u₂, hu₂, w, hw, ht₂⟩, hs⟩\n  refine ⟨u₁ ∩ u₂, inter_mem hu₁ hu₂, _, image2_mem_map₂ hv hw, ?_⟩\n  refine (image2_distrib_subset_left h_distrib).trans ((image2_subset ?_ ?_).trans hs)\n  · exact (image2_subset_right inter_subset_left).trans ht₁\n  · exact (image2_subset_right inter_subset_right).trans ht₂\n\n"}
{"name":"Filter.map₂_distrib_le_right","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nα' : Type u_2\nβ : Type u_3\nβ' : Type u_4\nγ : Type u_5\nδ : Type u_7\nε : Type u_9\nf : Filter α\ng : Filter β\nh : Filter γ\nm : δ → γ → ε\nn : α → β → δ\nm₁ : α → γ → α'\nm₂ : β → γ → β'\nn' : α' → β' → ε\nh_distrib : ∀ (a : α) (b : β) (c : γ), Eq (m (n a b) c) (n' (m₁ a c) (m₂ b c))\n⊢ LE.le (Filter.map₂ m (Filter.map₂ n f g) h) (Filter.map₂ n' (Filter.map₂ m₁ f h) (Filter.map₂ m₂ g h))","decl":"/-- The other direction does not hold because of the `h`-`h` cross terms on the RHS. -/\ntheorem map₂_distrib_le_right {m : δ → γ → ε} {n : α → β → δ} {m₁ : α → γ → α'} {m₂ : β → γ → β'}\n    {n' : α' → β' → ε} (h_distrib : ∀ a b c, m (n a b) c = n' (m₁ a c) (m₂ b c)) :\n    map₂ m (map₂ n f g) h ≤ map₂ n' (map₂ m₁ f h) (map₂ m₂ g h) := by\n  rintro s ⟨t₁, ⟨u, hu, w₁, hw₁, ht₁⟩, t₂, ⟨v, hv, w₂, hw₂, ht₂⟩, hs⟩\n  refine ⟨_, image2_mem_map₂ hu hv, w₁ ∩ w₂, inter_mem hw₁ hw₂, ?_⟩\n  refine (image2_distrib_subset_right h_distrib).trans ((image2_subset ?_ ?_).trans hs)\n  · exact (image2_subset_left inter_subset_left).trans ht₁\n  · exact (image2_subset_left inter_subset_right).trans ht₂\n\n"}
{"name":"Filter.map_map₂_antidistrib","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nα' : Type u_2\nβ : Type u_3\nβ' : Type u_4\nγ : Type u_5\nδ : Type u_7\nm : α → β → γ\nf : Filter α\ng : Filter β\nn : γ → δ\nm' : β' → α' → δ\nn₁ : β → β'\nn₂ : α → α'\nh_antidistrib : ∀ (a : α) (b : β), Eq (n (m a b)) (m' (n₁ b) (n₂ a))\n⊢ Eq (Filter.map n (Filter.map₂ m f g)) (Filter.map₂ m' (Filter.map n₁ g) (Filter.map n₂ f))","decl":"theorem map_map₂_antidistrib {n : γ → δ} {m' : β' → α' → δ} {n₁ : β → β'} {n₂ : α → α'}\n    (h_antidistrib : ∀ a b, n (m a b) = m' (n₁ b) (n₂ a)) :\n    (map₂ m f g).map n = map₂ m' (g.map n₁) (f.map n₂) := by\n  rw [map₂_swap m]\n  exact map_map₂_distrib fun _ _ => h_antidistrib _ _\n\n"}
{"name":"Filter.map_map₂_antidistrib_left","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nβ' : Type u_4\nγ : Type u_5\nδ : Type u_7\nm : α → β → γ\nf : Filter α\ng : Filter β\nn : γ → δ\nm' : β' → α → δ\nn' : β → β'\nh_antidistrib : ∀ (a : α) (b : β), Eq (n (m a b)) (m' (n' b) a)\n⊢ Eq (Filter.map n (Filter.map₂ m f g)) (Filter.map₂ m' (Filter.map n' g) f)","decl":"/-- Symmetric statement to `Filter.map₂_map_left_anticomm`. -/\ntheorem map_map₂_antidistrib_left {n : γ → δ} {m' : β' → α → δ} {n' : β → β'}\n    (h_antidistrib : ∀ a b, n (m a b) = m' (n' b) a) : (map₂ m f g).map n = map₂ m' (g.map n') f :=\n  map_map₂_antidistrib h_antidistrib\n\n"}
{"name":"Filter.map_map₂_antidistrib_right","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nα' : Type u_2\nβ : Type u_3\nγ : Type u_5\nδ : Type u_7\nm : α → β → γ\nf : Filter α\ng : Filter β\nn : γ → δ\nm' : β → α' → δ\nn' : α → α'\nh_antidistrib : ∀ (a : α) (b : β), Eq (n (m a b)) (m' b (n' a))\n⊢ Eq (Filter.map n (Filter.map₂ m f g)) (Filter.map₂ m' g (Filter.map n' f))","decl":"/-- Symmetric statement to `Filter.map_map₂_right_anticomm`. -/\ntheorem map_map₂_antidistrib_right {n : γ → δ} {m' : β → α' → δ} {n' : α → α'}\n    (h_antidistrib : ∀ a b, n (m a b) = m' b (n' a)) : (map₂ m f g).map n = map₂ m' g (f.map n') :=\n  map_map₂_antidistrib h_antidistrib\n\n"}
{"name":"Filter.map₂_map_left_anticomm","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nα' : Type u_2\nβ : Type u_3\nγ : Type u_5\nδ : Type u_7\nf : Filter α\ng : Filter β\nm : α' → β → γ\nn : α → α'\nm' : β → α → δ\nn' : δ → γ\nh_left_anticomm : ∀ (a : α) (b : β), Eq (m (n a) b) (n' (m' b a))\n⊢ Eq (Filter.map₂ m (Filter.map n f) g) (Filter.map n' (Filter.map₂ m' g f))","decl":"/-- Symmetric statement to `Filter.map_map₂_antidistrib_left`. -/\ntheorem map₂_map_left_anticomm {m : α' → β → γ} {n : α → α'} {m' : β → α → δ} {n' : δ → γ}\n    (h_left_anticomm : ∀ a b, m (n a) b = n' (m' b a)) :\n    map₂ m (f.map n) g = (map₂ m' g f).map n' :=\n  (map_map₂_antidistrib_left fun a b => (h_left_anticomm b a).symm).symm\n\n"}
{"name":"Filter.map_map₂_right_anticomm","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nβ' : Type u_4\nγ : Type u_5\nδ : Type u_7\nf : Filter α\ng : Filter β\nm : α → β' → γ\nn : β → β'\nm' : β → α → δ\nn' : δ → γ\nh_right_anticomm : ∀ (a : α) (b : β), Eq (m a (n b)) (n' (m' b a))\n⊢ Eq (Filter.map₂ m f (Filter.map n g)) (Filter.map n' (Filter.map₂ m' g f))","decl":"/-- Symmetric statement to `Filter.map_map₂_antidistrib_right`. -/\ntheorem map_map₂_right_anticomm {m : α → β' → γ} {n : β → β'} {m' : β → α → δ} {n' : δ → γ}\n    (h_right_anticomm : ∀ a b, m a (n b) = n' (m' b a)) :\n    map₂ m f (g.map n) = (map₂ m' g f).map n' :=\n  (map_map₂_antidistrib_right fun a b => (h_right_anticomm b a).symm).symm\n\n"}
{"name":"Filter.map₂_left_identity","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nf : α → β → β\na : α\nh : ∀ (b : β), Eq (f a b) b\nl : Filter β\n⊢ Eq (Filter.map₂ f (Pure.pure a) l) l","decl":"/-- If `a` is a left identity for `f : α → β → β`, then `pure a` is a left identity for\n`Filter.map₂ f`. -/\ntheorem map₂_left_identity {f : α → β → β} {a : α} (h : ∀ b, f a b = b) (l : Filter β) :\n    map₂ f (pure a) l = l := by rw [map₂_pure_left, show f a = id from funext h, map_id]\n\n"}
{"name":"Filter.map₂_right_identity","module":"Mathlib.Order.Filter.NAry","initialProofState":"α : Type u_1\nβ : Type u_3\nf : α → β → α\nb : β\nh : ∀ (a : α), Eq (f a b) a\nl : Filter α\n⊢ Eq (Filter.map₂ f l (Pure.pure b)) l","decl":"/-- If `b` is a right identity for `f : α → β → α`, then `pure b` is a right identity for\n`Filter.map₂ f`. -/\ntheorem map₂_right_identity {f : α → β → α} {b : β} (h : ∀ a, f a b = a) (l : Filter α) :\n    map₂ f l (pure b) = l := by rw [map₂_pure_right, funext h, map_id']\n\n"}
