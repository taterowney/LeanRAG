{"name":"transfiniteIterate_bot","module":"Mathlib.Order.TransfiniteIteration","initialProofState":"I : Type u\ninst✝⁴ : SupSet I\nφ : I → I\nJ : Type w\ninst✝³ : LinearOrder J\ninst✝² : SuccOrder J\ninst✝¹ : WellFoundedLT J\ninst✝ : OrderBot J\ni₀ : I\n⊢ Eq (transfiniteIterate φ Bot.bot i₀) i₀","decl":"@[simp]\nlemma transfiniteIterate_bot [OrderBot J] (i₀ : I) :\n    transfiniteIterate φ (⊥ : J) i₀ = i₀ := by\n  dsimp [transfiniteIterate]\n  simp only [isMin_iff_eq_bot, SuccOrder.limitRecOn_isMin, id_eq]\n\n"}
{"name":"transfiniteIterate_succ","module":"Mathlib.Order.TransfiniteIteration","initialProofState":"I : Type u\ninst✝³ : SupSet I\nφ : I → I\nJ : Type w\ninst✝² : LinearOrder J\ninst✝¹ : SuccOrder J\ninst✝ : WellFoundedLT J\ni₀ : I\nj : J\nhj : Not (IsMax j)\n⊢ Eq (transfiniteIterate φ (Order.succ j) i₀) (φ (transfiniteIterate φ j i₀))","decl":"lemma transfiniteIterate_succ (i₀ : I) (j : J) (hj : ¬ IsMax j):\n    transfiniteIterate φ (Order.succ j) i₀ =\n      φ (transfiniteIterate φ j i₀) := by\n  dsimp [transfiniteIterate]\n  rw [SuccOrder.limitRecOn_succ_of_not_isMax _ _ _ hj]\n  rfl\n\n"}
{"name":"transfiniteIterate_limit","module":"Mathlib.Order.TransfiniteIteration","initialProofState":"I : Type u\ninst✝³ : SupSet I\nφ : I → I\nJ : Type w\ninst✝² : LinearOrder J\ninst✝¹ : SuccOrder J\ninst✝ : WellFoundedLT J\ni₀ : I\nj : J\nhj : Order.IsSuccLimit j\n⊢ Eq (transfiniteIterate φ j i₀) (iSup fun x => transfiniteIterate φ (↑x) i₀)","decl":"lemma transfiniteIterate_limit (i₀ : I) (j : J) (hj : Order.IsSuccLimit j) :\n    transfiniteIterate φ j i₀ =\n      ⨆ (x : Set.Iio j), transfiniteIterate φ x.1 i₀ := by\n  dsimp [transfiniteIterate]\n  rw [SuccOrder.limitRecOn_of_isSuccLimit _ _ _ hj]\n  simp only [iSup_apply]\n\n"}
{"name":"monotone_transfiniteIterate","module":"Mathlib.Order.TransfiniteIteration","initialProofState":"I : Type u\ninst✝⁴ : CompleteLattice I\nφ : I → I\ni₀ : I\nJ : Type w\ninst✝³ : LinearOrder J\ninst✝² : OrderBot J\ninst✝¹ : SuccOrder J\ninst✝ : WellFoundedLT J\nhφ : ∀ (i : I), LE.le i (φ i)\n⊢ Monotone fun j => transfiniteIterate φ j i₀","decl":"lemma monotone_transfiniteIterate (hφ : ∀ (i : I), i ≤ φ i) :\n    Monotone (fun (j : J) ↦ transfiniteIterate φ j i₀) := by\n  intro k j hkj\n  induction j using SuccOrder.limitRecOn with\n  | hm k hk =>\n      obtain rfl := hk.eq_bot\n      obtain rfl : k = ⊥ := by simpa using hkj\n      rfl\n  | hs k' hk' hkk' =>\n      obtain hkj | rfl := hkj.lt_or_eq\n      · refine (hkk' ((Order.lt_succ_iff_of_not_isMax hk').mp hkj)).trans ?_\n        dsimp\n        rw [transfiniteIterate_succ _ _ _ hk']\n        apply hφ\n      · rfl\n  | hl k' hk' _ =>\n      obtain hkj | rfl := hkj.lt_or_eq\n      · dsimp\n        rw [transfiniteIterate_limit _ _ _ hk']\n        exact le_iSup (fun (⟨l, hl⟩ : Set.Iio k') ↦ transfiniteIterate φ l i₀) ⟨k, hkj⟩\n      · rfl\n\n"}
{"name":"top_mem_range_transfiniteIterate","module":"Mathlib.Order.TransfiniteIteration","initialProofState":"I : Type u\ninst✝⁴ : CompleteLattice I\nφ : I → I\ni₀ : I\nJ : Type w\ninst✝³ : LinearOrder J\ninst✝² : OrderBot J\ninst✝¹ : SuccOrder J\ninst✝ : WellFoundedLT J\nhφ' : ∀ (i : I), Ne i Top.top → LT.lt i (φ i)\nφtop : Eq (φ Top.top) Top.top\nH : Not (Function.Injective fun j => transfiniteIterate φ j i₀)\n⊢ Exists fun j => Eq (transfiniteIterate φ j i₀) Top.top","decl":"lemma top_mem_range_transfiniteIterate\n    (hφ' : ∀ (i : I) (_ : i ≠ ⊤), i < φ i) (φtop : φ ⊤ = ⊤)\n    (H : ¬ Function.Injective (fun (j : J) ↦ transfiniteIterate φ j i₀)) :\n    ∃ (j : J), transfiniteIterate φ j i₀ = ⊤ := by\n  have hφ (i : I) : i ≤ φ i := by\n    by_cases hi : i = ⊤\n    · subst hi\n      rw [φtop]\n    · exact (hφ' i hi).le\n  obtain ⟨j₁, j₂, hj, eq⟩ : ∃ (j₁ j₂ : J) (hj : j₁ < j₂),\n      transfiniteIterate φ j₁ i₀ = transfiniteIterate φ j₂ i₀ := by\n    dsimp [Function.Injective] at H\n    simp only [not_forall] at H\n    obtain ⟨j₁, j₂, eq, hj⟩ := H\n    by_cases hj' : j₁ < j₂\n    · exact ⟨j₁, j₂, hj', eq⟩\n    · simp only [not_lt] at hj'\n      obtain hj' | rfl := hj'.lt_or_eq\n      · exact ⟨j₂, j₁, hj', eq.symm⟩\n      · simp at hj\n  by_contra!\n  suffices transfiniteIterate φ j₁ i₀ < transfiniteIterate φ j₂ i₀ by\n    simp only [eq, lt_self_iff_false] at this\n  have hj₁ : ¬ IsMax j₁ := by\n    simp only [not_isMax_iff]\n    exact ⟨_, hj⟩\n  refine lt_of_lt_of_le (hφ' _ (this j₁)) ?_\n  rw [← transfiniteIterate_succ φ i₀ j₁ hj₁]\n  exact monotone_transfiniteIterate _ _ hφ (Order.succ_le_of_lt hj)\n\n"}
