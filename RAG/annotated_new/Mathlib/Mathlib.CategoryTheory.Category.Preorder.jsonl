{"name":"Preorder.subsingleton_hom","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"Œ± : Type u\ninst‚úù : Preorder Œ±\nU V : Œ±\n‚ä¢ Subsingleton (Quiver.Hom U V)","decl":"instance subsingleton_hom {Œ± : Type u} [Preorder Œ±] (U V : Œ±) :\n  Subsingleton (U ‚ü∂ V) := ‚ü®fun _ _ => ULift.ext _ _ (Subsingleton.elim _ _ )‚ü©\n\n"}
{"name":"CategoryTheory.homOfLE_refl","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst‚úù : Preorder X\nx : X\nh : LE.le x x\n‚ä¢ Eq h.hom (CategoryTheory.CategoryStruct.id x)","decl":"@[simp]\ntheorem homOfLE_refl {x : X} (h : x ‚â§ x) : h.hom = ùüô x :=\n  rfl\n\n"}
{"name":"CategoryTheory.homOfLE_comp","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst‚úù : Preorder X\nx y z : X\nh : LE.le x y\nk : LE.le y z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE h) (CategoryTheory.homOfLE k)) (CategoryTheory.homOfLE ‚ãØ)","decl":"@[simp]\ntheorem homOfLE_comp {x y z : X} (h : x ‚â§ y) (k : y ‚â§ z) :\n    homOfLE h ‚â´ homOfLE k = homOfLE (h.trans k) :=\n  rfl\n\n"}
{"name":"CategoryTheory.leOfHom","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst‚úù : Preorder X\nx y : X\nh : Quiver.Hom x y\n‚ä¢ LE.le x y","decl":"/-- Extract the underlying inequality from a morphism in a preorder category.\n-/\ntheorem leOfHom {x y : X} (h : x ‚ü∂ y) : x ‚â§ y :=\n  h.down.down\n\n"}
{"name":"CategoryTheory.homOfLE_leOfHom","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst‚úù : Preorder X\nx y : X\nh : Quiver.Hom x y\n‚ä¢ Eq ‚ãØ.hom h","decl":"@[simp]\ntheorem homOfLE_leOfHom {x y : X} (h : x ‚ü∂ y) : h.le.hom = h :=\n  rfl\n\n"}
{"name":"CategoryTheory.homOfLE_isIso_of_eq","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst‚úù : Preorder X\nx y : X\nh : LE.le x y\nheq : Eq x y\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.homOfLE h)","decl":"lemma homOfLE_isIso_of_eq {x y : X} (h : x ‚â§ y) (heq : x = y) :\n    IsIso (homOfLE h) :=\n  ‚ü®homOfLE (le_of_eq heq.symm), by simp‚ü©\n\n"}
{"name":"CategoryTheory.homOfLE_comp_eqToHom_assoc","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst‚úù : Preorder X\na b c : X\nhab : LE.le a b\nhbc : Eq b c\nZ : X\nh : Quiver.Hom c Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE hab) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom hbc) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE ‚ãØ) h)","decl":"@[simp, reassoc]\nlemma homOfLE_comp_eqToHom {a b c : X} (hab : a ‚â§ b) (hbc : b = c) :\n    homOfLE hab ‚â´ eqToHom hbc = homOfLE (hab.trans (le_of_eq hbc)) :=\n  rfl\n\n"}
{"name":"CategoryTheory.homOfLE_comp_eqToHom","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst‚úù : Preorder X\na b c : X\nhab : LE.le a b\nhbc : Eq b c\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE hab) (CategoryTheory.eqToHom hbc)) (CategoryTheory.homOfLE ‚ãØ)","decl":"@[simp, reassoc]\nlemma homOfLE_comp_eqToHom {a b c : X} (hab : a ‚â§ b) (hbc : b = c) :\n    homOfLE hab ‚â´ eqToHom hbc = homOfLE (hab.trans (le_of_eq hbc)) :=\n  rfl\n\n"}
{"name":"CategoryTheory.eqToHom_comp_homOfLE","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst‚úù : Preorder X\na b c : X\nhab : Eq a b\nhbc : LE.le b c\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom hab) (CategoryTheory.homOfLE hbc)) (CategoryTheory.homOfLE ‚ãØ)","decl":"@[simp, reassoc]\nlemma eqToHom_comp_homOfLE {a b c : X} (hab : a = b) (hbc : b ‚â§ c) :\n    eqToHom hab ‚â´ homOfLE hbc = homOfLE ((le_of_eq hab).trans hbc) :=\n  rfl\n\n"}
{"name":"CategoryTheory.eqToHom_comp_homOfLE_assoc","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst‚úù : Preorder X\na b c : X\nhab : Eq a b\nhbc : LE.le b c\nZ : X\nh : Quiver.Hom c Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom hab) (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE hbc) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE ‚ãØ) h)","decl":"@[simp, reassoc]\nlemma eqToHom_comp_homOfLE {a b c : X} (hab : a = b) (hbc : b ‚â§ c) :\n    eqToHom hab ‚â´ homOfLE hbc = homOfLE ((le_of_eq hab).trans hbc) :=\n  rfl\n\n"}
{"name":"CategoryTheory.homOfLE_op_comp_eqToHom_assoc","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst‚úù : Preorder X\na b c : X\nhab : LE.le b a\nhbc : Eq { unop := b } { unop := c }\nZ : Opposite X\nh : Quiver.Hom { unop := c } Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE hab).op (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom hbc) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE ‚ãØ).op h)","decl":"@[simp, reassoc]\nlemma homOfLE_op_comp_eqToHom {a b c : X} (hab : b ‚â§ a) (hbc : op b = op c) :\n    (homOfLE hab).op ‚â´ eqToHom hbc = (homOfLE ((le_of_eq (op_injective hbc.symm)).trans hab)).op :=\n  rfl\n\n"}
{"name":"CategoryTheory.homOfLE_op_comp_eqToHom","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst‚úù : Preorder X\na b c : X\nhab : LE.le b a\nhbc : Eq { unop := b } { unop := c }\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE hab).op (CategoryTheory.eqToHom hbc)) (CategoryTheory.homOfLE ‚ãØ).op","decl":"@[simp, reassoc]\nlemma homOfLE_op_comp_eqToHom {a b c : X} (hab : b ‚â§ a) (hbc : op b = op c) :\n    (homOfLE hab).op ‚â´ eqToHom hbc = (homOfLE ((le_of_eq (op_injective hbc.symm)).trans hab)).op :=\n  rfl\n\n"}
{"name":"CategoryTheory.eqToHom_comp_homOfLE_op_assoc","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst‚úù : Preorder X\na b c : X\nhab : Eq { unop := a } { unop := b }\nhbc : LE.le c b\nZ : Opposite X\nh : Quiver.Hom { unop := c } Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom hab) (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE hbc).op h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE ‚ãØ).op h)","decl":"@[simp, reassoc]\nlemma eqToHom_comp_homOfLE_op {a b c : X} (hab : op a = op b) (hbc : c ‚â§ b) :\n    eqToHom hab ‚â´ (homOfLE hbc).op = (homOfLE (hbc.trans (le_of_eq (op_injective hab.symm)))).op :=\n  rfl\n\n"}
{"name":"CategoryTheory.eqToHom_comp_homOfLE_op","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst‚úù : Preorder X\na b c : X\nhab : Eq { unop := a } { unop := b }\nhbc : LE.le c b\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom hab) (CategoryTheory.homOfLE hbc).op) (CategoryTheory.homOfLE ‚ãØ).op","decl":"@[simp, reassoc]\nlemma eqToHom_comp_homOfLE_op {a b c : X} (hab : op a = op b) (hbc : c ‚â§ b) :\n    eqToHom hab ‚â´ (homOfLE hbc).op = (homOfLE (hbc.trans (le_of_eq (op_injective hab.symm)))).op :=\n  rfl\n\n"}
{"name":"CategoryTheory.le_of_op_hom","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst‚úù : Preorder X\nx y : Opposite X\nh : Quiver.Hom x y\n‚ä¢ LE.le (Opposite.unop y) (Opposite.unop x)","decl":"theorem le_of_op_hom {x y : X·µí·µñ} (h : x ‚ü∂ y) : unop y ‚â§ unop x :=\n  h.unop.le\n\n"}
{"name":"CategoryTheory.orderDualEquivalence_functor_map","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst‚úù : Preorder X\nX‚úù Y‚úù : OrderDual X\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.orderDualEquivalence X).functor.map f) (CategoryTheory.homOfLE ‚ãØ).op","decl":"variable (X) in\n/-- The equivalence of categories from the order dual of a preordered type `X`\nto the opposite category of the preorder `X`. -/\n@[simps]\ndef orderDualEquivalence : X·µí·µà ‚âå X·µí·µñ where\n  functor :=\n    { obj := fun x => op (OrderDual.ofDual x)\n      map := fun f => (homOfLE (leOfHom f)).op }\n  inverse :=\n    { obj := fun x => OrderDual.toDual x.unop\n      map := fun f => (homOfLE (leOfHom f.unop)) }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.orderDualEquivalence_inverse_obj","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst‚úù : Preorder X\nx : Opposite X\n‚ä¢ Eq ((CategoryTheory.orderDualEquivalence X).inverse.obj x) (OrderDual.toDual (Opposite.unop x))","decl":"variable (X) in\n/-- The equivalence of categories from the order dual of a preordered type `X`\nto the opposite category of the preorder `X`. -/\n@[simps]\ndef orderDualEquivalence : X·µí·µà ‚âå X·µí·µñ where\n  functor :=\n    { obj := fun x => op (OrderDual.ofDual x)\n      map := fun f => (homOfLE (leOfHom f)).op }\n  inverse :=\n    { obj := fun x => OrderDual.toDual x.unop\n      map := fun f => (homOfLE (leOfHom f.unop)) }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.orderDualEquivalence_counitIso","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst‚úù : Preorder X\n‚ä¢ Eq (CategoryTheory.orderDualEquivalence X).counitIso (CategoryTheory.Iso.refl ({ obj := fun x => OrderDual.toDual (Opposite.unop x), map := fun {X_1 Y} f => CategoryTheory.homOfLE ‚ãØ, map_id := ‚ãØ, map_comp := ‚ãØ }.comp { obj := fun x => { unop := OrderDual.ofDual x }, map := fun {X_1 Y} f => (CategoryTheory.homOfLE ‚ãØ).op, map_id := ‚ãØ, map_comp := ‚ãØ }))","decl":"variable (X) in\n/-- The equivalence of categories from the order dual of a preordered type `X`\nto the opposite category of the preorder `X`. -/\n@[simps]\ndef orderDualEquivalence : X·µí·µà ‚âå X·µí·µñ where\n  functor :=\n    { obj := fun x => op (OrderDual.ofDual x)\n      map := fun f => (homOfLE (leOfHom f)).op }\n  inverse :=\n    { obj := fun x => OrderDual.toDual x.unop\n      map := fun f => (homOfLE (leOfHom f.unop)) }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.orderDualEquivalence_inverse_map","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst‚úù : Preorder X\nX‚úù Y‚úù : Opposite X\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.orderDualEquivalence X).inverse.map f) (CategoryTheory.homOfLE ‚ãØ)","decl":"variable (X) in\n/-- The equivalence of categories from the order dual of a preordered type `X`\nto the opposite category of the preorder `X`. -/\n@[simps]\ndef orderDualEquivalence : X·µí·µà ‚âå X·µí·µñ where\n  functor :=\n    { obj := fun x => op (OrderDual.ofDual x)\n      map := fun f => (homOfLE (leOfHom f)).op }\n  inverse :=\n    { obj := fun x => OrderDual.toDual x.unop\n      map := fun f => (homOfLE (leOfHom f.unop)) }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.orderDualEquivalence_functor_obj","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst‚úù : Preorder X\nx : OrderDual X\n‚ä¢ Eq ((CategoryTheory.orderDualEquivalence X).functor.obj x) { unop := OrderDual.ofDual x }","decl":"variable (X) in\n/-- The equivalence of categories from the order dual of a preordered type `X`\nto the opposite category of the preorder `X`. -/\n@[simps]\ndef orderDualEquivalence : X·µí·µà ‚âå X·µí·µñ where\n  functor :=\n    { obj := fun x => op (OrderDual.ofDual x)\n      map := fun f => (homOfLE (leOfHom f)).op }\n  inverse :=\n    { obj := fun x => OrderDual.toDual x.unop\n      map := fun f => (homOfLE (leOfHom f.unop)) }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.orderDualEquivalence_unitIso","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst‚úù : Preorder X\n‚ä¢ Eq (CategoryTheory.orderDualEquivalence X).unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (OrderDual X)))","decl":"variable (X) in\n/-- The equivalence of categories from the order dual of a preordered type `X`\nto the opposite category of the preorder `X`. -/\n@[simps]\ndef orderDualEquivalence : X·µí·µà ‚âå X·µí·µñ where\n  functor :=\n    { obj := fun x => op (OrderDual.ofDual x)\n      map := fun f => (homOfLE (leOfHom f)).op }\n  inverse :=\n    { obj := fun x => OrderDual.toDual x.unop\n      map := fun f => (homOfLE (leOfHom f.unop)) }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Monotone.functor_obj","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\nY : Type v\ninst‚úù¬π : Preorder X\ninst‚úù : Preorder Y\nf : X ‚Üí Y\nh : Monotone f\n‚ä¢ Eq h.functor.obj f","decl":"@[simp]\ntheorem Monotone.functor_obj {f : X ‚Üí Y} (h : Monotone f) : h.functor.obj = f :=\n  rfl\n\n-- Faithfulness is automatic because preorder categories are thin\n"}
{"name":"instFullFunctor","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\nY : Type v\ninst‚úù¬π : Preorder X\ninst‚úù : Preorder Y\nf : OrderEmbedding X Y\n‚ä¢ ‚ãØ.functor.Full","decl":"instance (f : X ‚Ü™o Y) : f.monotone.functor.Full where\n  map_surjective h := ‚ü®homOfLE (f.map_rel_iff.1 h.le), rfl‚ü©\n\n"}
{"name":"OrderIso.equivalence_unitIso","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\nY : Type v\ninst‚úù¬π : Preorder X\ninst‚úù : Preorder Y\ne : OrderIso X Y\n‚ä¢ Eq e.equivalence.unitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.eqToIso ‚ãØ) ‚ãØ)","decl":"/-- The equivalence of categories `X ‚âå Y` induced by `e : X ‚âÉo Y`. -/\n@[simps]\ndef OrderIso.equivalence (e : X ‚âÉo Y) : X ‚âå Y where\n  functor := e.monotone.functor\n  inverse := e.symm.monotone.functor\n  unitIso := NatIso.ofComponents (fun _ ‚Ü¶ eqToIso (by simp))\n  counitIso := NatIso.ofComponents (fun _ ‚Ü¶ eqToIso (by simp))\n\n"}
{"name":"OrderIso.equivalence_functor","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\nY : Type v\ninst‚úù¬π : Preorder X\ninst‚úù : Preorder Y\ne : OrderIso X Y\n‚ä¢ Eq e.equivalence.functor ‚ãØ.functor","decl":"/-- The equivalence of categories `X ‚âå Y` induced by `e : X ‚âÉo Y`. -/\n@[simps]\ndef OrderIso.equivalence (e : X ‚âÉo Y) : X ‚âå Y where\n  functor := e.monotone.functor\n  inverse := e.symm.monotone.functor\n  unitIso := NatIso.ofComponents (fun _ ‚Ü¶ eqToIso (by simp))\n  counitIso := NatIso.ofComponents (fun _ ‚Ü¶ eqToIso (by simp))\n\n"}
{"name":"OrderIso.equivalence_counitIso","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\nY : Type v\ninst‚úù¬π : Preorder X\ninst‚úù : Preorder Y\ne : OrderIso X Y\n‚ä¢ Eq e.equivalence.counitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.eqToIso ‚ãØ) ‚ãØ)","decl":"/-- The equivalence of categories `X ‚âå Y` induced by `e : X ‚âÉo Y`. -/\n@[simps]\ndef OrderIso.equivalence (e : X ‚âÉo Y) : X ‚âå Y where\n  functor := e.monotone.functor\n  inverse := e.symm.monotone.functor\n  unitIso := NatIso.ofComponents (fun _ ‚Ü¶ eqToIso (by simp))\n  counitIso := NatIso.ofComponents (fun _ ‚Ü¶ eqToIso (by simp))\n\n"}
{"name":"OrderIso.equivalence_inverse","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\nY : Type v\ninst‚úù¬π : Preorder X\ninst‚úù : Preorder Y\ne : OrderIso X Y\n‚ä¢ Eq e.equivalence.inverse ‚ãØ.functor","decl":"/-- The equivalence of categories `X ‚âå Y` induced by `e : X ‚âÉo Y`. -/\n@[simps]\ndef OrderIso.equivalence (e : X ‚âÉo Y) : X ‚âå Y where\n  functor := e.monotone.functor\n  inverse := e.symm.monotone.functor\n  unitIso := NatIso.ofComponents (fun _ ‚Ü¶ eqToIso (by simp))\n  counitIso := NatIso.ofComponents (fun _ ‚Ü¶ eqToIso (by simp))\n\n"}
{"name":"CategoryTheory.Functor.monotone","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\nY : Type v\ninst‚úù¬π : Preorder X\ninst‚úù : Preorder Y\nf : CategoryTheory.Functor X Y\n‚ä¢ Monotone f.obj","decl":"/-- A functor between preorder categories is monotone.\n-/\n@[mono]\ntheorem Functor.monotone (f : X ‚•§ Y) : Monotone f.obj := fun _ _ hxy => (f.map hxy.hom).le\n\n"}
{"name":"CategoryTheory.Iso.to_eq","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst‚úù : PartialOrder X\nx y : X\nf : CategoryTheory.Iso x y\n‚ä¢ Eq x y","decl":"theorem Iso.to_eq {x y : X} (f : x ‚âÖ y) : x = y :=\n  le_antisymm f.hom.le f.inv.le\n\n"}
{"name":"CategoryTheory.Equivalence.toOrderIso_apply","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\nY : Type v\ninst‚úù¬π : PartialOrder X\ninst‚úù : PartialOrder Y\ne : CategoryTheory.Equivalence X Y\nx : X\n‚ä¢ Eq (e.toOrderIso x) (e.functor.obj x)","decl":"@[simp]\ntheorem Equivalence.toOrderIso_apply (e : X ‚âå Y) (x : X) : e.toOrderIso x = e.functor.obj x :=\n  rfl\n\n"}
{"name":"CategoryTheory.Equivalence.toOrderIso_symm_apply","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\nY : Type v\ninst‚úù¬π : PartialOrder X\ninst‚úù : PartialOrder Y\ne : CategoryTheory.Equivalence X Y\ny : Y\n‚ä¢ Eq (e.toOrderIso.symm y) (e.inverse.obj y)","decl":"@[simp]\ntheorem Equivalence.toOrderIso_symm_apply (e : X ‚âå Y) (y : Y) :\n    e.toOrderIso.symm y = e.inverse.obj y :=\n  rfl\n\n"}
