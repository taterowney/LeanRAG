{"name":"Preorder.subsingleton_hom","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"α : Type u\ninst✝ : Preorder α\nU V : α\n⊢ Subsingleton (Quiver.Hom U V)","decl":"instance subsingleton_hom {α : Type u} [Preorder α] (U V : α) :\n  Subsingleton (U ⟶ V) := ⟨fun _ _ => ULift.ext _ _ (Subsingleton.elim _ _ )⟩\n\n"}
{"name":"CategoryTheory.homOfLE_refl","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst✝ : Preorder X\nx : X\nh : LE.le x x\n⊢ Eq h.hom (CategoryTheory.CategoryStruct.id x)","decl":"@[simp]\ntheorem homOfLE_refl {x : X} (h : x ≤ x) : h.hom = 𝟙 x :=\n  rfl\n\n"}
{"name":"CategoryTheory.homOfLE_comp","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst✝ : Preorder X\nx y z : X\nh : LE.le x y\nk : LE.le y z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE h) (CategoryTheory.homOfLE k)) (CategoryTheory.homOfLE ⋯)","decl":"@[simp]\ntheorem homOfLE_comp {x y z : X} (h : x ≤ y) (k : y ≤ z) :\n    homOfLE h ≫ homOfLE k = homOfLE (h.trans k) :=\n  rfl\n\n"}
{"name":"CategoryTheory.leOfHom","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst✝ : Preorder X\nx y : X\nh : Quiver.Hom x y\n⊢ LE.le x y","decl":"/-- Extract the underlying inequality from a morphism in a preorder category.\n-/\ntheorem leOfHom {x y : X} (h : x ⟶ y) : x ≤ y :=\n  h.down.down\n\n"}
{"name":"CategoryTheory.homOfLE_leOfHom","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst✝ : Preorder X\nx y : X\nh : Quiver.Hom x y\n⊢ Eq ⋯.hom h","decl":"@[simp]\ntheorem homOfLE_leOfHom {x y : X} (h : x ⟶ y) : h.le.hom = h :=\n  rfl\n\n"}
{"name":"CategoryTheory.homOfLE_isIso_of_eq","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst✝ : Preorder X\nx y : X\nh : LE.le x y\nheq : Eq x y\n⊢ CategoryTheory.IsIso (CategoryTheory.homOfLE h)","decl":"lemma homOfLE_isIso_of_eq {x y : X} (h : x ≤ y) (heq : x = y) :\n    IsIso (homOfLE h) :=\n  ⟨homOfLE (le_of_eq heq.symm), by simp⟩\n\n"}
{"name":"CategoryTheory.homOfLE_comp_eqToHom_assoc","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst✝ : Preorder X\na b c : X\nhab : LE.le a b\nhbc : Eq b c\nZ : X\nh : Quiver.Hom c Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE hab) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom hbc) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE ⋯) h)","decl":"@[simp, reassoc]\nlemma homOfLE_comp_eqToHom {a b c : X} (hab : a ≤ b) (hbc : b = c) :\n    homOfLE hab ≫ eqToHom hbc = homOfLE (hab.trans (le_of_eq hbc)) :=\n  rfl\n\n"}
{"name":"CategoryTheory.homOfLE_comp_eqToHom","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst✝ : Preorder X\na b c : X\nhab : LE.le a b\nhbc : Eq b c\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE hab) (CategoryTheory.eqToHom hbc)) (CategoryTheory.homOfLE ⋯)","decl":"@[simp, reassoc]\nlemma homOfLE_comp_eqToHom {a b c : X} (hab : a ≤ b) (hbc : b = c) :\n    homOfLE hab ≫ eqToHom hbc = homOfLE (hab.trans (le_of_eq hbc)) :=\n  rfl\n\n"}
{"name":"CategoryTheory.eqToHom_comp_homOfLE","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst✝ : Preorder X\na b c : X\nhab : Eq a b\nhbc : LE.le b c\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom hab) (CategoryTheory.homOfLE hbc)) (CategoryTheory.homOfLE ⋯)","decl":"@[simp, reassoc]\nlemma eqToHom_comp_homOfLE {a b c : X} (hab : a = b) (hbc : b ≤ c) :\n    eqToHom hab ≫ homOfLE hbc = homOfLE ((le_of_eq hab).trans hbc) :=\n  rfl\n\n"}
{"name":"CategoryTheory.eqToHom_comp_homOfLE_assoc","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst✝ : Preorder X\na b c : X\nhab : Eq a b\nhbc : LE.le b c\nZ : X\nh : Quiver.Hom c Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom hab) (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE hbc) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE ⋯) h)","decl":"@[simp, reassoc]\nlemma eqToHom_comp_homOfLE {a b c : X} (hab : a = b) (hbc : b ≤ c) :\n    eqToHom hab ≫ homOfLE hbc = homOfLE ((le_of_eq hab).trans hbc) :=\n  rfl\n\n"}
{"name":"CategoryTheory.homOfLE_op_comp_eqToHom_assoc","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst✝ : Preorder X\na b c : X\nhab : LE.le b a\nhbc : Eq { unop := b } { unop := c }\nZ : Opposite X\nh : Quiver.Hom { unop := c } Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE hab).op (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom hbc) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE ⋯).op h)","decl":"@[simp, reassoc]\nlemma homOfLE_op_comp_eqToHom {a b c : X} (hab : b ≤ a) (hbc : op b = op c) :\n    (homOfLE hab).op ≫ eqToHom hbc = (homOfLE ((le_of_eq (op_injective hbc.symm)).trans hab)).op :=\n  rfl\n\n"}
{"name":"CategoryTheory.homOfLE_op_comp_eqToHom","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst✝ : Preorder X\na b c : X\nhab : LE.le b a\nhbc : Eq { unop := b } { unop := c }\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE hab).op (CategoryTheory.eqToHom hbc)) (CategoryTheory.homOfLE ⋯).op","decl":"@[simp, reassoc]\nlemma homOfLE_op_comp_eqToHom {a b c : X} (hab : b ≤ a) (hbc : op b = op c) :\n    (homOfLE hab).op ≫ eqToHom hbc = (homOfLE ((le_of_eq (op_injective hbc.symm)).trans hab)).op :=\n  rfl\n\n"}
{"name":"CategoryTheory.eqToHom_comp_homOfLE_op_assoc","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst✝ : Preorder X\na b c : X\nhab : Eq { unop := a } { unop := b }\nhbc : LE.le c b\nZ : Opposite X\nh : Quiver.Hom { unop := c } Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom hab) (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE hbc).op h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.homOfLE ⋯).op h)","decl":"@[simp, reassoc]\nlemma eqToHom_comp_homOfLE_op {a b c : X} (hab : op a = op b) (hbc : c ≤ b) :\n    eqToHom hab ≫ (homOfLE hbc).op = (homOfLE (hbc.trans (le_of_eq (op_injective hab.symm)))).op :=\n  rfl\n\n"}
{"name":"CategoryTheory.eqToHom_comp_homOfLE_op","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst✝ : Preorder X\na b c : X\nhab : Eq { unop := a } { unop := b }\nhbc : LE.le c b\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom hab) (CategoryTheory.homOfLE hbc).op) (CategoryTheory.homOfLE ⋯).op","decl":"@[simp, reassoc]\nlemma eqToHom_comp_homOfLE_op {a b c : X} (hab : op a = op b) (hbc : c ≤ b) :\n    eqToHom hab ≫ (homOfLE hbc).op = (homOfLE (hbc.trans (le_of_eq (op_injective hab.symm)))).op :=\n  rfl\n\n"}
{"name":"CategoryTheory.le_of_op_hom","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst✝ : Preorder X\nx y : Opposite X\nh : Quiver.Hom x y\n⊢ LE.le (Opposite.unop y) (Opposite.unop x)","decl":"theorem le_of_op_hom {x y : Xᵒᵖ} (h : x ⟶ y) : unop y ≤ unop x :=\n  h.unop.le\n\n"}
{"name":"CategoryTheory.orderDualEquivalence_functor_map","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst✝ : Preorder X\nX✝ Y✝ : OrderDual X\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.orderDualEquivalence X).functor.map f) (CategoryTheory.homOfLE ⋯).op","decl":"variable (X) in\n/-- The equivalence of categories from the order dual of a preordered type `X`\nto the opposite category of the preorder `X`. -/\n@[simps]\ndef orderDualEquivalence : Xᵒᵈ ≌ Xᵒᵖ where\n  functor :=\n    { obj := fun x => op (OrderDual.ofDual x)\n      map := fun f => (homOfLE (leOfHom f)).op }\n  inverse :=\n    { obj := fun x => OrderDual.toDual x.unop\n      map := fun f => (homOfLE (leOfHom f.unop)) }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.orderDualEquivalence_inverse_obj","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst✝ : Preorder X\nx : Opposite X\n⊢ Eq ((CategoryTheory.orderDualEquivalence X).inverse.obj x) (OrderDual.toDual (Opposite.unop x))","decl":"variable (X) in\n/-- The equivalence of categories from the order dual of a preordered type `X`\nto the opposite category of the preorder `X`. -/\n@[simps]\ndef orderDualEquivalence : Xᵒᵈ ≌ Xᵒᵖ where\n  functor :=\n    { obj := fun x => op (OrderDual.ofDual x)\n      map := fun f => (homOfLE (leOfHom f)).op }\n  inverse :=\n    { obj := fun x => OrderDual.toDual x.unop\n      map := fun f => (homOfLE (leOfHom f.unop)) }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.orderDualEquivalence_counitIso","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst✝ : Preorder X\n⊢ Eq (CategoryTheory.orderDualEquivalence X).counitIso (CategoryTheory.Iso.refl ({ obj := fun x => OrderDual.toDual (Opposite.unop x), map := fun {X_1 Y} f => CategoryTheory.homOfLE ⋯, map_id := ⋯, map_comp := ⋯ }.comp { obj := fun x => { unop := OrderDual.ofDual x }, map := fun {X_1 Y} f => (CategoryTheory.homOfLE ⋯).op, map_id := ⋯, map_comp := ⋯ }))","decl":"variable (X) in\n/-- The equivalence of categories from the order dual of a preordered type `X`\nto the opposite category of the preorder `X`. -/\n@[simps]\ndef orderDualEquivalence : Xᵒᵈ ≌ Xᵒᵖ where\n  functor :=\n    { obj := fun x => op (OrderDual.ofDual x)\n      map := fun f => (homOfLE (leOfHom f)).op }\n  inverse :=\n    { obj := fun x => OrderDual.toDual x.unop\n      map := fun f => (homOfLE (leOfHom f.unop)) }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.orderDualEquivalence_inverse_map","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst✝ : Preorder X\nX✝ Y✝ : Opposite X\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.orderDualEquivalence X).inverse.map f) (CategoryTheory.homOfLE ⋯)","decl":"variable (X) in\n/-- The equivalence of categories from the order dual of a preordered type `X`\nto the opposite category of the preorder `X`. -/\n@[simps]\ndef orderDualEquivalence : Xᵒᵈ ≌ Xᵒᵖ where\n  functor :=\n    { obj := fun x => op (OrderDual.ofDual x)\n      map := fun f => (homOfLE (leOfHom f)).op }\n  inverse :=\n    { obj := fun x => OrderDual.toDual x.unop\n      map := fun f => (homOfLE (leOfHom f.unop)) }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.orderDualEquivalence_functor_obj","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst✝ : Preorder X\nx : OrderDual X\n⊢ Eq ((CategoryTheory.orderDualEquivalence X).functor.obj x) { unop := OrderDual.ofDual x }","decl":"variable (X) in\n/-- The equivalence of categories from the order dual of a preordered type `X`\nto the opposite category of the preorder `X`. -/\n@[simps]\ndef orderDualEquivalence : Xᵒᵈ ≌ Xᵒᵖ where\n  functor :=\n    { obj := fun x => op (OrderDual.ofDual x)\n      map := fun f => (homOfLE (leOfHom f)).op }\n  inverse :=\n    { obj := fun x => OrderDual.toDual x.unop\n      map := fun f => (homOfLE (leOfHom f.unop)) }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.orderDualEquivalence_unitIso","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst✝ : Preorder X\n⊢ Eq (CategoryTheory.orderDualEquivalence X).unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (OrderDual X)))","decl":"variable (X) in\n/-- The equivalence of categories from the order dual of a preordered type `X`\nto the opposite category of the preorder `X`. -/\n@[simps]\ndef orderDualEquivalence : Xᵒᵈ ≌ Xᵒᵖ where\n  functor :=\n    { obj := fun x => op (OrderDual.ofDual x)\n      map := fun f => (homOfLE (leOfHom f)).op }\n  inverse :=\n    { obj := fun x => OrderDual.toDual x.unop\n      map := fun f => (homOfLE (leOfHom f.unop)) }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"Monotone.functor_obj","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : Preorder X\ninst✝ : Preorder Y\nf : X → Y\nh : Monotone f\n⊢ Eq h.functor.obj f","decl":"@[simp]\ntheorem Monotone.functor_obj {f : X → Y} (h : Monotone f) : h.functor.obj = f :=\n  rfl\n\n-- Faithfulness is automatic because preorder categories are thin\n"}
{"name":"instFullFunctor","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : Preorder X\ninst✝ : Preorder Y\nf : OrderEmbedding X Y\n⊢ ⋯.functor.Full","decl":"instance (f : X ↪o Y) : f.monotone.functor.Full where\n  map_surjective h := ⟨homOfLE (f.map_rel_iff.1 h.le), rfl⟩\n\n"}
{"name":"OrderIso.equivalence_unitIso","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : Preorder X\ninst✝ : Preorder Y\ne : OrderIso X Y\n⊢ Eq e.equivalence.unitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.eqToIso ⋯) ⋯)","decl":"/-- The equivalence of categories `X ≌ Y` induced by `e : X ≃o Y`. -/\n@[simps]\ndef OrderIso.equivalence (e : X ≃o Y) : X ≌ Y where\n  functor := e.monotone.functor\n  inverse := e.symm.monotone.functor\n  unitIso := NatIso.ofComponents (fun _ ↦ eqToIso (by simp))\n  counitIso := NatIso.ofComponents (fun _ ↦ eqToIso (by simp))\n\n"}
{"name":"OrderIso.equivalence_functor","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : Preorder X\ninst✝ : Preorder Y\ne : OrderIso X Y\n⊢ Eq e.equivalence.functor ⋯.functor","decl":"/-- The equivalence of categories `X ≌ Y` induced by `e : X ≃o Y`. -/\n@[simps]\ndef OrderIso.equivalence (e : X ≃o Y) : X ≌ Y where\n  functor := e.monotone.functor\n  inverse := e.symm.monotone.functor\n  unitIso := NatIso.ofComponents (fun _ ↦ eqToIso (by simp))\n  counitIso := NatIso.ofComponents (fun _ ↦ eqToIso (by simp))\n\n"}
{"name":"OrderIso.equivalence_counitIso","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : Preorder X\ninst✝ : Preorder Y\ne : OrderIso X Y\n⊢ Eq e.equivalence.counitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.eqToIso ⋯) ⋯)","decl":"/-- The equivalence of categories `X ≌ Y` induced by `e : X ≃o Y`. -/\n@[simps]\ndef OrderIso.equivalence (e : X ≃o Y) : X ≌ Y where\n  functor := e.monotone.functor\n  inverse := e.symm.monotone.functor\n  unitIso := NatIso.ofComponents (fun _ ↦ eqToIso (by simp))\n  counitIso := NatIso.ofComponents (fun _ ↦ eqToIso (by simp))\n\n"}
{"name":"OrderIso.equivalence_inverse","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : Preorder X\ninst✝ : Preorder Y\ne : OrderIso X Y\n⊢ Eq e.equivalence.inverse ⋯.functor","decl":"/-- The equivalence of categories `X ≌ Y` induced by `e : X ≃o Y`. -/\n@[simps]\ndef OrderIso.equivalence (e : X ≃o Y) : X ≌ Y where\n  functor := e.monotone.functor\n  inverse := e.symm.monotone.functor\n  unitIso := NatIso.ofComponents (fun _ ↦ eqToIso (by simp))\n  counitIso := NatIso.ofComponents (fun _ ↦ eqToIso (by simp))\n\n"}
{"name":"CategoryTheory.Functor.monotone","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : Preorder X\ninst✝ : Preorder Y\nf : CategoryTheory.Functor X Y\n⊢ Monotone f.obj","decl":"/-- A functor between preorder categories is monotone.\n-/\n@[mono]\ntheorem Functor.monotone (f : X ⥤ Y) : Monotone f.obj := fun _ _ hxy => (f.map hxy.hom).le\n\n"}
{"name":"CategoryTheory.Iso.to_eq","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\ninst✝ : PartialOrder X\nx y : X\nf : CategoryTheory.Iso x y\n⊢ Eq x y","decl":"theorem Iso.to_eq {x y : X} (f : x ≅ y) : x = y :=\n  le_antisymm f.hom.le f.inv.le\n\n"}
{"name":"CategoryTheory.Equivalence.toOrderIso_apply","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : PartialOrder X\ninst✝ : PartialOrder Y\ne : CategoryTheory.Equivalence X Y\nx : X\n⊢ Eq (e.toOrderIso x) (e.functor.obj x)","decl":"@[simp]\ntheorem Equivalence.toOrderIso_apply (e : X ≌ Y) (x : X) : e.toOrderIso x = e.functor.obj x :=\n  rfl\n\n"}
{"name":"CategoryTheory.Equivalence.toOrderIso_symm_apply","module":"Mathlib.CategoryTheory.Category.Preorder","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : PartialOrder X\ninst✝ : PartialOrder Y\ne : CategoryTheory.Equivalence X Y\ny : Y\n⊢ Eq (e.toOrderIso.symm y) (e.inverse.obj y)","decl":"@[simp]\ntheorem Equivalence.toOrderIso_symm_apply (e : X ≌ Y) (y : Y) :\n    e.toOrderIso.symm y = e.inverse.obj y :=\n  rfl\n\n"}
