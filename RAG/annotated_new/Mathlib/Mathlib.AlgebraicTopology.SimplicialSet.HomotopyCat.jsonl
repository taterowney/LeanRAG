{"name":"SSet.Œ¥‚ÇÇ_zero_comp_œÉ‚ÇÇ_zero_assoc","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"Z : CategoryTheory.FullSubcategory fun a => LE.le a.len 2\nh : Quiver.Hom { obj := SimplexCategory.mk 0, property := ‚ãØ } Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SSet.Œ¥‚ÇÇ 0 ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.comp (SSet.œÉ‚ÇÇ 0 ‚ãØ ‚ãØ) h)) h","decl":"@[reassoc (attr := simp)]\nlemma Œ¥‚ÇÇ_zero_comp_œÉ‚ÇÇ_zero : Œ¥‚ÇÇ (0 : Fin 2) ‚â´ œÉ‚ÇÇ 0 = ùüô _ := SimplexCategory.Œ¥_comp_œÉ_self\n\n"}
{"name":"SSet.Œ¥‚ÇÇ_zero_comp_œÉ‚ÇÇ_zero","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SSet.Œ¥‚ÇÇ 0 ‚ãØ ‚ãØ) (SSet.œÉ‚ÇÇ 0 ‚ãØ ‚ãØ)) (CategoryTheory.CategoryStruct.id { obj := SimplexCategory.mk 0, property := ‚ãØ })","decl":"@[reassoc (attr := simp)]\nlemma Œ¥‚ÇÇ_zero_comp_œÉ‚ÇÇ_zero : Œ¥‚ÇÇ (0 : Fin 2) ‚â´ œÉ‚ÇÇ 0 = ùüô _ := SimplexCategory.Œ¥_comp_œÉ_self\n\n"}
{"name":"SSet.Œ¥‚ÇÇ_one_comp_œÉ‚ÇÇ_zero_assoc","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"Z : CategoryTheory.FullSubcategory fun a => LE.le a.len 2\nh : Quiver.Hom { obj := SimplexCategory.mk 0, property := ‚ãØ } Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SSet.Œ¥‚ÇÇ 1 ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.comp (SSet.œÉ‚ÇÇ 0 ‚ãØ ‚ãØ) h)) h","decl":"@[reassoc (attr := simp)]\nlemma Œ¥‚ÇÇ_one_comp_œÉ‚ÇÇ_zero : Œ¥‚ÇÇ (1 : Fin 2) ‚â´ œÉ‚ÇÇ 0 = ùüô _ := SimplexCategory.Œ¥_comp_œÉ_succ\n\n"}
{"name":"SSet.Œ¥‚ÇÇ_one_comp_œÉ‚ÇÇ_zero","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SSet.Œ¥‚ÇÇ 1 ‚ãØ ‚ãØ) (SSet.œÉ‚ÇÇ 0 ‚ãØ ‚ãØ)) (CategoryTheory.CategoryStruct.id { obj := SimplexCategory.mk 0, property := ‚ãØ })","decl":"@[reassoc (attr := simp)]\nlemma Œ¥‚ÇÇ_one_comp_œÉ‚ÇÇ_zero : Œ¥‚ÇÇ (1 : Fin 2) ‚â´ œÉ‚ÇÇ 0 = ùüô _ := SimplexCategory.Œ¥_comp_œÉ_succ\n\n"}
{"name":"SSet.OneTruncation‚ÇÇ.Hom.ext_iff","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"S : SSet.Truncated 2\nX Y : SSet.OneTruncation‚ÇÇ S\nx y : X.Hom Y\n‚ä¢ Iff (Eq x y) (Eq x.edge y.edge)","decl":"/-- The hom-types of the refl quiver underlying a simplicial set `S` are types of edges in `S _[1]‚ÇÇ`\ntogether with source and target equalities. -/\n@[ext]\nstructure OneTruncation‚ÇÇ.Hom {S : SSet.Truncated 2} (X Y : OneTruncation‚ÇÇ S) where\n  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes the data of a 1-simplex. -/\n  edge : S _[1]‚ÇÇ\n  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes a source equality. -/\n  src_eq : S.map (Œ¥‚ÇÇ 1).op edge = X\n  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes a target equality. -/\n  tgt_eq : S.map (Œ¥‚ÇÇ 0).op edge = Y\n\n"}
{"name":"SSet.OneTruncation‚ÇÇ.Hom.mk.inj","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"S : SSet.Truncated 2\nX Y : SSet.OneTruncation‚ÇÇ S\nedge‚úù : S.obj { unop := { obj := SimplexCategory.mk 1, property := ‚ãØ } }\nsrc_eq‚úù : Eq (S.map (SSet.Œ¥‚ÇÇ 1 ‚ãØ ‚ãØ).op edge‚úù) X\ntgt_eq‚úù : Eq (S.map (SSet.Œ¥‚ÇÇ 0 ‚ãØ ‚ãØ).op edge‚úù) Y\nedge : S.obj { unop := { obj := SimplexCategory.mk 1, property := ‚ãØ } }\nsrc_eq : Eq (S.map (SSet.Œ¥‚ÇÇ 1 ‚ãØ ‚ãØ).op edge) X\ntgt_eq : Eq (S.map (SSet.Œ¥‚ÇÇ 0 ‚ãØ ‚ãØ).op edge) Y\nx‚úù : Eq { edge := edge‚úù, src_eq := src_eq‚úù, tgt_eq := tgt_eq‚úù } { edge := edge, src_eq := src_eq, tgt_eq := tgt_eq }\n‚ä¢ Eq edge‚úù edge","decl":"/-- The hom-types of the refl quiver underlying a simplicial set `S` are types of edges in `S _[1]‚ÇÇ`\ntogether with source and target equalities. -/\n@[ext]\nstructure OneTruncation‚ÇÇ.Hom {S : SSet.Truncated 2} (X Y : OneTruncation‚ÇÇ S) where\n  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes the data of a 1-simplex. -/\n  edge : S _[1]‚ÇÇ\n  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes a source equality. -/\n  src_eq : S.map (Œ¥‚ÇÇ 1).op edge = X\n  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes a target equality. -/\n  tgt_eq : S.map (Œ¥‚ÇÇ 0).op edge = Y\n\n"}
{"name":"SSet.OneTruncation‚ÇÇ.Hom.tgt_eq","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"S : SSet.Truncated 2\nX Y : SSet.OneTruncation‚ÇÇ S\nself : X.Hom Y\n‚ä¢ Eq (S.map (SSet.Œ¥‚ÇÇ 0 ‚ãØ ‚ãØ).op self.edge) Y","decl":"/-- The hom-types of the refl quiver underlying a simplicial set `S` are types of edges in `S _[1]‚ÇÇ`\ntogether with source and target equalities. -/\n@[ext]\nstructure OneTruncation‚ÇÇ.Hom {S : SSet.Truncated 2} (X Y : OneTruncation‚ÇÇ S) where\n  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes the data of a 1-simplex. -/\n  edge : S _[1]‚ÇÇ\n  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes a source equality. -/\n  src_eq : S.map (Œ¥‚ÇÇ 1).op edge = X\n  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes a target equality. -/\n  tgt_eq : S.map (Œ¥‚ÇÇ 0).op edge = Y\n\n"}
{"name":"SSet.OneTruncation‚ÇÇ.Hom.ext","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"S : SSet.Truncated 2\nX Y : SSet.OneTruncation‚ÇÇ S\nx y : X.Hom Y\nedge : Eq x.edge y.edge\n‚ä¢ Eq x y","decl":"/-- The hom-types of the refl quiver underlying a simplicial set `S` are types of edges in `S _[1]‚ÇÇ`\ntogether with source and target equalities. -/\n@[ext]\nstructure OneTruncation‚ÇÇ.Hom {S : SSet.Truncated 2} (X Y : OneTruncation‚ÇÇ S) where\n  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes the data of a 1-simplex. -/\n  edge : S _[1]‚ÇÇ\n  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes a source equality. -/\n  src_eq : S.map (Œ¥‚ÇÇ 1).op edge = X\n  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes a target equality. -/\n  tgt_eq : S.map (Œ¥‚ÇÇ 0).op edge = Y\n\n"}
{"name":"SSet.OneTruncation‚ÇÇ.Hom.src_eq","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"S : SSet.Truncated 2\nX Y : SSet.OneTruncation‚ÇÇ S\nself : X.Hom Y\n‚ä¢ Eq (S.map (SSet.Œ¥‚ÇÇ 1 ‚ãØ ‚ãØ).op self.edge) X","decl":"/-- The hom-types of the refl quiver underlying a simplicial set `S` are types of edges in `S _[1]‚ÇÇ`\ntogether with source and target equalities. -/\n@[ext]\nstructure OneTruncation‚ÇÇ.Hom {S : SSet.Truncated 2} (X Y : OneTruncation‚ÇÇ S) where\n  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes the data of a 1-simplex. -/\n  edge : S _[1]‚ÇÇ\n  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes a source equality. -/\n  src_eq : S.map (Œ¥‚ÇÇ 1).op edge = X\n  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes a target equality. -/\n  tgt_eq : S.map (Œ¥‚ÇÇ 0).op edge = Y\n\n"}
{"name":"SSet.OneTruncation‚ÇÇ.Hom.mk.injEq","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"S : SSet.Truncated 2\nX Y : SSet.OneTruncation‚ÇÇ S\nedge‚úù : S.obj { unop := { obj := SimplexCategory.mk 1, property := ‚ãØ } }\nsrc_eq‚úù : Eq (S.map (SSet.Œ¥‚ÇÇ 1 ‚ãØ ‚ãØ).op edge‚úù) X\ntgt_eq‚úù : Eq (S.map (SSet.Œ¥‚ÇÇ 0 ‚ãØ ‚ãØ).op edge‚úù) Y\nedge : S.obj { unop := { obj := SimplexCategory.mk 1, property := ‚ãØ } }\nsrc_eq : Eq (S.map (SSet.Œ¥‚ÇÇ 1 ‚ãØ ‚ãØ).op edge) X\ntgt_eq : Eq (S.map (SSet.Œ¥‚ÇÇ 0 ‚ãØ ‚ãØ).op edge) Y\n‚ä¢ Eq (Eq { edge := edge‚úù, src_eq := src_eq‚úù, tgt_eq := tgt_eq‚úù } { edge := edge, src_eq := src_eq, tgt_eq := tgt_eq }) (Eq edge‚úù edge)","decl":"/-- The hom-types of the refl quiver underlying a simplicial set `S` are types of edges in `S _[1]‚ÇÇ`\ntogether with source and target equalities. -/\n@[ext]\nstructure OneTruncation‚ÇÇ.Hom {S : SSet.Truncated 2} (X Y : OneTruncation‚ÇÇ S) where\n  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes the data of a 1-simplex. -/\n  edge : S _[1]‚ÇÇ\n  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes a source equality. -/\n  src_eq : S.map (Œ¥‚ÇÇ 1).op edge = X\n  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes a target equality. -/\n  tgt_eq : S.map (Œ¥‚ÇÇ 0).op edge = Y\n\n"}
{"name":"SSet.OneTruncation‚ÇÇ.Hom.mk.sizeOf_spec","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"S : SSet.Truncated 2\nX Y : SSet.OneTruncation‚ÇÇ S\nedge : S.obj { unop := { obj := SimplexCategory.mk 1, property := ‚ãØ } }\nsrc_eq : Eq (S.map (SSet.Œ¥‚ÇÇ 1 ‚ãØ ‚ãØ).op edge) X\ntgt_eq : Eq (S.map (SSet.Œ¥‚ÇÇ 0 ‚ãØ ‚ãØ).op edge) Y\n‚ä¢ Eq (SizeOf.sizeOf { edge := edge, src_eq := src_eq, tgt_eq := tgt_eq }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf edge)) (SizeOf.sizeOf src_eq)) (SizeOf.sizeOf tgt_eq))","decl":"/-- The hom-types of the refl quiver underlying a simplicial set `S` are types of edges in `S _[1]‚ÇÇ`\ntogether with source and target equalities. -/\n@[ext]\nstructure OneTruncation‚ÇÇ.Hom {S : SSet.Truncated 2} (X Y : OneTruncation‚ÇÇ S) where\n  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes the data of a 1-simplex. -/\n  edge : S _[1]‚ÇÇ\n  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes a source equality. -/\n  src_eq : S.map (Œ¥‚ÇÇ 1).op edge = X\n  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes a target equality. -/\n  tgt_eq : S.map (Œ¥‚ÇÇ 0).op edge = Y\n\n"}
{"name":"SSet.OneTruncation‚ÇÇ.id_edge","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"S : SSet.Truncated 2\nX : SSet.OneTruncation‚ÇÇ S\n‚ä¢ Eq (CategoryTheory.ReflQuiver.id X).edge (S.map (SSet.œÉ‚ÇÇ 0 ‚ãØ ‚ãØ).op X)","decl":"@[simp]\nlemma OneTruncation‚ÇÇ.id_edge {S : SSet.Truncated 2} (X : OneTruncation‚ÇÇ S) :\n    OneTruncation‚ÇÇ.Hom.edge (ùüôrq X) = S.map (SSet.œÉ‚ÇÇ 0).op X := rfl\n\n"}
{"name":"SSet.oneTruncation‚ÇÇ_obj","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"S : SSet.Truncated 2\n‚ä¢ Eq (SSet.oneTruncation‚ÇÇ.obj S) (CategoryTheory.ReflQuiv.of (SSet.OneTruncation‚ÇÇ S))","decl":"/-- The functor that carries a 2-truncated simplicial set to its underlying refl quiver. -/\n@[simps]\ndef oneTruncation‚ÇÇ : SSet.Truncated.{u} 2 ‚•§ ReflQuiv.{u, u} where\n  obj S := ReflQuiv.of (OneTruncation‚ÇÇ S)\n  map {S T} F := {\n    obj := F.app (op [0]‚ÇÇ)\n    map := fun f ‚Ü¶\n      { edge := F.app _ f.edge\n        src_eq := by rw [‚Üê FunctorToTypes.naturality, f.src_eq]\n        tgt_eq := by rw [‚Üê FunctorToTypes.naturality, f.tgt_eq] }\n    map_id := fun X ‚Ü¶ OneTruncation‚ÇÇ.Hom.ext (by\n      dsimp\n      rw [‚Üê FunctorToTypes.naturality]) }\n\n"}
{"name":"SSet.oneTruncation‚ÇÇ_map_obj","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"S T : SSet.Truncated 2\nF : Quiver.Hom S T\na‚úù : S.obj { unop := { obj := SimplexCategory.mk 0, property := SSet.oneTruncation‚ÇÇ.proof_1 } }\n‚ä¢ Eq ((SSet.oneTruncation‚ÇÇ.map F).obj a‚úù) (F.app { unop := { obj := SimplexCategory.mk 0, property := SSet.oneTruncation‚ÇÇ.proof_1 } } a‚úù)","decl":"/-- The functor that carries a 2-truncated simplicial set to its underlying refl quiver. -/\n@[simps]\ndef oneTruncation‚ÇÇ : SSet.Truncated.{u} 2 ‚•§ ReflQuiv.{u, u} where\n  obj S := ReflQuiv.of (OneTruncation‚ÇÇ S)\n  map {S T} F := {\n    obj := F.app (op [0]‚ÇÇ)\n    map := fun f ‚Ü¶\n      { edge := F.app _ f.edge\n        src_eq := by rw [‚Üê FunctorToTypes.naturality, f.src_eq]\n        tgt_eq := by rw [‚Üê FunctorToTypes.naturality, f.tgt_eq] }\n    map_id := fun X ‚Ü¶ OneTruncation‚ÇÇ.Hom.ext (by\n      dsimp\n      rw [‚Üê FunctorToTypes.naturality]) }\n\n"}
{"name":"SSet.oneTruncation‚ÇÇ_map_map_edge","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"S T : SSet.Truncated 2\nF : Quiver.Hom S T\nX‚úù Y‚úù : ‚Üë((fun S => CategoryTheory.ReflQuiv.of (SSet.OneTruncation‚ÇÇ S)) S)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((SSet.oneTruncation‚ÇÇ.map F).map f).edge (F.app { unop := { obj := SimplexCategory.mk 1, property := SSet.oneTruncation‚ÇÇ.proof_2 } } f.edge)","decl":"/-- The functor that carries a 2-truncated simplicial set to its underlying refl quiver. -/\n@[simps]\ndef oneTruncation‚ÇÇ : SSet.Truncated.{u} 2 ‚•§ ReflQuiv.{u, u} where\n  obj S := ReflQuiv.of (OneTruncation‚ÇÇ S)\n  map {S T} F := {\n    obj := F.app (op [0]‚ÇÇ)\n    map := fun f ‚Ü¶\n      { edge := F.app _ f.edge\n        src_eq := by rw [‚Üê FunctorToTypes.naturality, f.src_eq]\n        tgt_eq := by rw [‚Üê FunctorToTypes.naturality, f.tgt_eq] }\n    map_id := fun X ‚Ü¶ OneTruncation‚ÇÇ.Hom.ext (by\n      dsimp\n      rw [‚Üê FunctorToTypes.naturality]) }\n\n"}
{"name":"SSet.OneTruncation‚ÇÇ.hom_ext","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"S : SSet.Truncated 2\nx y : SSet.OneTruncation‚ÇÇ S\nf g : Quiver.Hom x y\na‚úù : Eq f.edge g.edge\n‚ä¢ Eq f g","decl":"@[ext]\nlemma OneTruncation‚ÇÇ.hom_ext {S : SSet.Truncated 2} {x y : OneTruncation‚ÇÇ S} {f g : x ‚ü∂ y} :\n    f.edge = g.edge ‚Üí f = g := OneTruncation‚ÇÇ.Hom.ext\n\n"}
{"name":"SSet.OneTruncation‚ÇÇ.hom_ext_iff","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"S : SSet.Truncated 2\nx y : SSet.OneTruncation‚ÇÇ S\nf g : Quiver.Hom x y\n‚ä¢ Iff (Eq f g) (Eq f.edge g.edge)","decl":"@[ext]\nlemma OneTruncation‚ÇÇ.hom_ext {S : SSet.Truncated 2} {x y : OneTruncation‚ÇÇ S} {f g : x ‚ü∂ y} :\n    f.edge = g.edge ‚Üí f = g := OneTruncation‚ÇÇ.Hom.ext\n\n"}
{"name":"SSet.OneTruncation‚ÇÇ.nerveEquiv_apply","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : SSet.OneTruncation‚ÇÇ ((SSet.truncation 2).obj (CategoryTheory.nerve C))\n‚ä¢ Eq (SSet.OneTruncation‚ÇÇ.nerveEquiv X) (CategoryTheory.ComposableArrows.obj' X 0 SSet.OneTruncation‚ÇÇ.nerveEquiv.proof_1)","decl":"/-- An equivalence between the type of objects underlying a category and the type of 0-simplices in\nthe 2-truncated nerve. -/\n@[simps]\ndef OneTruncation‚ÇÇ.nerveEquiv :\n    OneTruncation‚ÇÇ ((SSet.truncation 2).obj (nerve C)) ‚âÉ C where\n  toFun X := X.obj' 0\n  invFun X := .mk‚ÇÄ X\n  left_inv _ := ComposableArrows.ext‚ÇÄ rfl\n  right_inv _ := rfl\n\n"}
{"name":"SSet.OneTruncation‚ÇÇ.nerveEquiv_symm_apply","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\n‚ä¢ Eq (SSet.OneTruncation‚ÇÇ.nerveEquiv.symm X) (CategoryTheory.ComposableArrows.mk‚ÇÄ X)","decl":"/-- An equivalence between the type of objects underlying a category and the type of 0-simplices in\nthe 2-truncated nerve. -/\n@[simps]\ndef OneTruncation‚ÇÇ.nerveEquiv :\n    OneTruncation‚ÇÇ ((SSet.truncation 2).obj (nerve C)) ‚âÉ C where\n  toFun X := X.obj' 0\n  invFun X := .mk‚ÇÄ X\n  left_inv _ := ComposableArrows.ext‚ÇÄ rfl\n  right_inv _ := rfl\n\n"}
{"name":"SSet.OneTruncation‚ÇÇ.ofNerve‚ÇÇ.natIso_hom_app_map","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"X : CategoryTheory.Cat\nX‚úù Y‚úù : ‚Üë(CategoryTheory.Quiv.of (SSet.OneTruncation‚ÇÇ ((SSet.truncation 2).obj (CategoryTheory.nerve ‚Üë(CategoryTheory.Cat.of ‚ÜëX)))))\na : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((SSet.OneTruncation‚ÇÇ.ofNerve‚ÇÇ.natIso.hom.app X).map a) ((SSet.OneTruncation‚ÇÇ.nerveHomEquiv X‚úù Y‚úù) a)","decl":"/-- The refl quiver underlying a nerve is naturally isomorphic to the refl quiver underlying the\ncategory. -/\n@[simps! hom_app_obj hom_app_map inv_app_obj_obj inv_app_obj_map inv_app_map]\ndef OneTruncation‚ÇÇ.ofNerve‚ÇÇ.natIso :\n    nerveFunctor‚ÇÇ.{u,u} ‚ãô SSet.oneTruncation‚ÇÇ ‚âÖ ReflQuiv.forget :=\n  NatIso.ofComponents (fun C => OneTruncation‚ÇÇ.ofNerve‚ÇÇ C) (by\n  ¬∑ intro C D F\n    fapply ReflPrefunctor.ext <;> simp\n    ¬∑ exact fun _ ‚Ü¶ rfl\n    ¬∑ intro X Y f\n      obtain ‚ü®f, rfl, rfl‚ü© := f\n      unfold SSet.oneTruncation‚ÇÇ nerveFunctor‚ÇÇ SSet.truncation SimplicialObject.truncation\n        nerveFunctor toReflPrefunctor\n      simp only [comp_obj, whiskeringLeft_obj_obj, ReflQuiv.of_val, Functor.comp_map,\n        whiskeringLeft_obj_map, whiskerLeft_app, op_obj, whiskeringRight_obj_obj, ofNerve‚ÇÇ,\n        Cat.of_Œ±, nerveEquiv, ComposableArrows.obj', Fin.zero_eta, Fin.isValue,\n        ReflQuiv.comp_eq_comp, Nat.reduceAdd, SimplexCategory.len_mk, id_eq, op_map,\n        Quiver.Hom.unop_op, nerve_map, SimplexCategory.toCat_map, ReflPrefunctor.comp_obj,\n        ReflPrefunctor.comp_map]\n      simp [nerveHomEquiv, ReflQuiv.isoOfEquiv, ReflQuiv.isoOfQuivIso, Quiv.isoOfEquiv])\n\n"}
{"name":"SSet.OneTruncation‚ÇÇ.ofNerve‚ÇÇ.natIso_inv_app_obj_map","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"X : CategoryTheory.Cat\na : ‚Üë(CategoryTheory.Cat.of ‚ÜëX)\nX‚úù Y‚úù : Fin 1\nx‚úù : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((SSet.OneTruncation‚ÇÇ.ofNerve‚ÇÇ.natIso.inv.app X).obj a).map x‚úù) (CategoryTheory.CategoryStruct.id a)","decl":"/-- The refl quiver underlying a nerve is naturally isomorphic to the refl quiver underlying the\ncategory. -/\n@[simps! hom_app_obj hom_app_map inv_app_obj_obj inv_app_obj_map inv_app_map]\ndef OneTruncation‚ÇÇ.ofNerve‚ÇÇ.natIso :\n    nerveFunctor‚ÇÇ.{u,u} ‚ãô SSet.oneTruncation‚ÇÇ ‚âÖ ReflQuiv.forget :=\n  NatIso.ofComponents (fun C => OneTruncation‚ÇÇ.ofNerve‚ÇÇ C) (by\n  ¬∑ intro C D F\n    fapply ReflPrefunctor.ext <;> simp\n    ¬∑ exact fun _ ‚Ü¶ rfl\n    ¬∑ intro X Y f\n      obtain ‚ü®f, rfl, rfl‚ü© := f\n      unfold SSet.oneTruncation‚ÇÇ nerveFunctor‚ÇÇ SSet.truncation SimplicialObject.truncation\n        nerveFunctor toReflPrefunctor\n      simp only [comp_obj, whiskeringLeft_obj_obj, ReflQuiv.of_val, Functor.comp_map,\n        whiskeringLeft_obj_map, whiskerLeft_app, op_obj, whiskeringRight_obj_obj, ofNerve‚ÇÇ,\n        Cat.of_Œ±, nerveEquiv, ComposableArrows.obj', Fin.zero_eta, Fin.isValue,\n        ReflQuiv.comp_eq_comp, Nat.reduceAdd, SimplexCategory.len_mk, id_eq, op_map,\n        Quiver.Hom.unop_op, nerve_map, SimplexCategory.toCat_map, ReflPrefunctor.comp_obj,\n        ReflPrefunctor.comp_map]\n      simp [nerveHomEquiv, ReflQuiv.isoOfEquiv, ReflQuiv.isoOfQuivIso, Quiv.isoOfEquiv])\n\n"}
{"name":"SSet.OneTruncation‚ÇÇ.ofNerve‚ÇÇ.natIso_hom_app_obj","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"X : CategoryTheory.Cat\na : SSet.OneTruncation‚ÇÇ ((SSet.truncation 2).obj (CategoryTheory.nerve ‚Üë(CategoryTheory.Cat.of ‚ÜëX)))\n‚ä¢ Eq ((SSet.OneTruncation‚ÇÇ.ofNerve‚ÇÇ.natIso.hom.app X).obj a) (a.obj 0)","decl":"/-- The refl quiver underlying a nerve is naturally isomorphic to the refl quiver underlying the\ncategory. -/\n@[simps! hom_app_obj hom_app_map inv_app_obj_obj inv_app_obj_map inv_app_map]\ndef OneTruncation‚ÇÇ.ofNerve‚ÇÇ.natIso :\n    nerveFunctor‚ÇÇ.{u,u} ‚ãô SSet.oneTruncation‚ÇÇ ‚âÖ ReflQuiv.forget :=\n  NatIso.ofComponents (fun C => OneTruncation‚ÇÇ.ofNerve‚ÇÇ C) (by\n  ¬∑ intro C D F\n    fapply ReflPrefunctor.ext <;> simp\n    ¬∑ exact fun _ ‚Ü¶ rfl\n    ¬∑ intro X Y f\n      obtain ‚ü®f, rfl, rfl‚ü© := f\n      unfold SSet.oneTruncation‚ÇÇ nerveFunctor‚ÇÇ SSet.truncation SimplicialObject.truncation\n        nerveFunctor toReflPrefunctor\n      simp only [comp_obj, whiskeringLeft_obj_obj, ReflQuiv.of_val, Functor.comp_map,\n        whiskeringLeft_obj_map, whiskerLeft_app, op_obj, whiskeringRight_obj_obj, ofNerve‚ÇÇ,\n        Cat.of_Œ±, nerveEquiv, ComposableArrows.obj', Fin.zero_eta, Fin.isValue,\n        ReflQuiv.comp_eq_comp, Nat.reduceAdd, SimplexCategory.len_mk, id_eq, op_map,\n        Quiver.Hom.unop_op, nerve_map, SimplexCategory.toCat_map, ReflPrefunctor.comp_obj,\n        ReflPrefunctor.comp_map]\n      simp [nerveHomEquiv, ReflQuiv.isoOfEquiv, ReflQuiv.isoOfQuivIso, Quiv.isoOfEquiv])\n\n"}
{"name":"SSet.OneTruncation‚ÇÇ.ofNerve‚ÇÇ.natIso_inv_app_obj_obj","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"X : CategoryTheory.Cat\na : ‚Üë(CategoryTheory.Cat.of ‚ÜëX)\nx‚úù : Fin 1\n‚ä¢ Eq (((SSet.OneTruncation‚ÇÇ.ofNerve‚ÇÇ.natIso.inv.app X).obj a).obj x‚úù) a","decl":"/-- The refl quiver underlying a nerve is naturally isomorphic to the refl quiver underlying the\ncategory. -/\n@[simps! hom_app_obj hom_app_map inv_app_obj_obj inv_app_obj_map inv_app_map]\ndef OneTruncation‚ÇÇ.ofNerve‚ÇÇ.natIso :\n    nerveFunctor‚ÇÇ.{u,u} ‚ãô SSet.oneTruncation‚ÇÇ ‚âÖ ReflQuiv.forget :=\n  NatIso.ofComponents (fun C => OneTruncation‚ÇÇ.ofNerve‚ÇÇ C) (by\n  ¬∑ intro C D F\n    fapply ReflPrefunctor.ext <;> simp\n    ¬∑ exact fun _ ‚Ü¶ rfl\n    ¬∑ intro X Y f\n      obtain ‚ü®f, rfl, rfl‚ü© := f\n      unfold SSet.oneTruncation‚ÇÇ nerveFunctor‚ÇÇ SSet.truncation SimplicialObject.truncation\n        nerveFunctor toReflPrefunctor\n      simp only [comp_obj, whiskeringLeft_obj_obj, ReflQuiv.of_val, Functor.comp_map,\n        whiskeringLeft_obj_map, whiskerLeft_app, op_obj, whiskeringRight_obj_obj, ofNerve‚ÇÇ,\n        Cat.of_Œ±, nerveEquiv, ComposableArrows.obj', Fin.zero_eta, Fin.isValue,\n        ReflQuiv.comp_eq_comp, Nat.reduceAdd, SimplexCategory.len_mk, id_eq, op_map,\n        Quiver.Hom.unop_op, nerve_map, SimplexCategory.toCat_map, ReflPrefunctor.comp_obj,\n        ReflPrefunctor.comp_map]\n      simp [nerveHomEquiv, ReflQuiv.isoOfEquiv, ReflQuiv.isoOfQuivIso, Quiv.isoOfEquiv])\n\n"}
{"name":"SSet.OneTruncation‚ÇÇ.ofNerve‚ÇÇ.natIso_inv_app_map","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"X‚úù : CategoryTheory.Cat\nX Y : ‚Üë(CategoryTheory.Quiv.of ‚Üë(CategoryTheory.Cat.of ‚ÜëX‚úù))\nf : Quiver.Hom X Y\n‚ä¢ Eq ((SSet.OneTruncation‚ÇÇ.ofNerve‚ÇÇ.natIso.inv.app X‚úù).map f) ((SSet.OneTruncation‚ÇÇ.nerveHomEquiv (CategoryTheory.ComposableArrows.mk‚ÇÄ X) (CategoryTheory.ComposableArrows.mk‚ÇÄ Y)).symm f)","decl":"/-- The refl quiver underlying a nerve is naturally isomorphic to the refl quiver underlying the\ncategory. -/\n@[simps! hom_app_obj hom_app_map inv_app_obj_obj inv_app_obj_map inv_app_map]\ndef OneTruncation‚ÇÇ.ofNerve‚ÇÇ.natIso :\n    nerveFunctor‚ÇÇ.{u,u} ‚ãô SSet.oneTruncation‚ÇÇ ‚âÖ ReflQuiv.forget :=\n  NatIso.ofComponents (fun C => OneTruncation‚ÇÇ.ofNerve‚ÇÇ C) (by\n  ¬∑ intro C D F\n    fapply ReflPrefunctor.ext <;> simp\n    ¬∑ exact fun _ ‚Ü¶ rfl\n    ¬∑ intro X Y f\n      obtain ‚ü®f, rfl, rfl‚ü© := f\n      unfold SSet.oneTruncation‚ÇÇ nerveFunctor‚ÇÇ SSet.truncation SimplicialObject.truncation\n        nerveFunctor toReflPrefunctor\n      simp only [comp_obj, whiskeringLeft_obj_obj, ReflQuiv.of_val, Functor.comp_map,\n        whiskeringLeft_obj_map, whiskerLeft_app, op_obj, whiskeringRight_obj_obj, ofNerve‚ÇÇ,\n        Cat.of_Œ±, nerveEquiv, ComposableArrows.obj', Fin.zero_eta, Fin.isValue,\n        ReflQuiv.comp_eq_comp, Nat.reduceAdd, SimplexCategory.len_mk, id_eq, op_map,\n        Quiver.Hom.unop_op, nerve_map, SimplexCategory.toCat_map, ReflPrefunctor.comp_obj,\n        ReflPrefunctor.comp_map]\n      simp [nerveHomEquiv, ReflQuiv.isoOfEquiv, ReflQuiv.isoOfQuivIso, Quiv.isoOfEquiv])\n\n"}
{"name":"SSet.Truncated.HoRel‚ÇÇ.mk'","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"V : SSet.Truncated 2\nœÜ : V.obj { unop := { obj := SimplexCategory.mk 2, property := ‚ãØ } }\nX‚ÇÄ X‚ÇÅ X‚ÇÇ : SSet.OneTruncation‚ÇÇ V\nf‚ÇÄ‚ÇÅ : Quiver.Hom X‚ÇÄ X‚ÇÅ\nf‚ÇÅ‚ÇÇ : Quiver.Hom X‚ÇÅ X‚ÇÇ\nf‚ÇÄ‚ÇÇ : Quiver.Hom X‚ÇÄ X‚ÇÇ\nh‚ÇÄ‚ÇÅ : Eq f‚ÇÄ‚ÇÅ.edge (V.map (SSet.Œ¥‚ÇÇ 2 ‚ãØ ‚ãØ).op œÜ)\nh‚ÇÅ‚ÇÇ : Eq f‚ÇÅ‚ÇÇ.edge (V.map (SSet.Œ¥‚ÇÇ 0 ‚ãØ ‚ãØ).op œÜ)\nh‚ÇÄ‚ÇÇ : Eq f‚ÇÄ‚ÇÇ.edge (V.map (SSet.Œ¥‚ÇÇ 1 ‚ãØ ‚ãØ).op œÜ)\n‚ä¢ SSet.Truncated.HoRel‚ÇÇ { as := X‚ÇÄ } { as := X‚ÇÇ } (Quot.mk (CategoryTheory.Quotient.CompClosure CategoryTheory.Cat.FreeReflRel) f‚ÇÄ‚ÇÇ.toPath) (Quot.mk (CategoryTheory.Quotient.CompClosure CategoryTheory.Cat.FreeReflRel) (f‚ÇÄ‚ÇÅ.toPath.comp f‚ÇÅ‚ÇÇ.toPath))","decl":"/-- A 2-simplex whose faces are identified with certain arrows in `OneTruncation‚ÇÇ V` defines\na term of type `HoRel‚ÇÇ` between those arrows. -/\ntheorem HoRel‚ÇÇ.mk' {V : SSet.Truncated 2} (œÜ : V _[2]‚ÇÇ) {X‚ÇÄ X‚ÇÅ X‚ÇÇ : OneTruncation‚ÇÇ V}\n    (f‚ÇÄ‚ÇÅ : X‚ÇÄ ‚ü∂ X‚ÇÅ) (f‚ÇÅ‚ÇÇ : X‚ÇÅ ‚ü∂ X‚ÇÇ) (f‚ÇÄ‚ÇÇ : X‚ÇÄ ‚ü∂ X‚ÇÇ)\n    (h‚ÇÄ‚ÇÅ : f‚ÇÄ‚ÇÅ.edge = V.map (Œ¥‚ÇÇ 2).op œÜ) (h‚ÇÅ‚ÇÇ : f‚ÇÅ‚ÇÇ.edge = V.map (Œ¥‚ÇÇ 0).op œÜ)\n    (h‚ÇÄ‚ÇÇ : f‚ÇÄ‚ÇÇ.edge = V.map (Œ¥‚ÇÇ 1).op œÜ) :\n    HoRel‚ÇÇ _ _ (Quot.mk _ (Quiver.Hom.toPath f‚ÇÄ‚ÇÇ))\n      (Quot.mk _ ((Quiver.Hom.toPath f‚ÇÄ‚ÇÅ).comp (Quiver.Hom.toPath f‚ÇÅ‚ÇÇ))) := by\n  obtain rfl : X‚ÇÄ = ev0‚ÇÇ œÜ := by\n    rw [‚Üê f‚ÇÄ‚ÇÇ.src_eq, h‚ÇÄ‚ÇÇ, ‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp]\n    rfl\n  obtain rfl : X‚ÇÅ = ev1‚ÇÇ œÜ := by\n    rw [‚Üê f‚ÇÄ‚ÇÅ.tgt_eq, h‚ÇÄ‚ÇÅ, ‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp]\n    rfl\n  obtain rfl : X‚ÇÇ = ev2‚ÇÇ œÜ := by\n    rw [‚Üê f‚ÇÅ‚ÇÇ.tgt_eq, h‚ÇÅ‚ÇÇ, ‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp]\n    rfl\n  obtain rfl : f‚ÇÄ‚ÇÅ = ev01‚ÇÇ œÜ := by ext; assumption\n  obtain rfl : f‚ÇÅ‚ÇÇ = ev12‚ÇÇ œÜ := by ext; assumption\n  obtain rfl : f‚ÇÄ‚ÇÇ = ev02‚ÇÇ œÜ := by ext; assumption\n  constructor\n\n"}
{"name":"SSet.Truncated.HomotopyCategory.lift_unique'","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"V : SSet.Truncated 2\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor V.HomotopyCategory D\nh : Eq ((SSet.Truncated.HomotopyCategory.quotientFunctor V).comp F‚ÇÅ) ((SSet.Truncated.HomotopyCategory.quotientFunctor V).comp F‚ÇÇ)\n‚ä¢ Eq F‚ÇÅ F‚ÇÇ","decl":"/-- By `Quotient.lift_unique'` (not `Quotient.lift`) we have that `quotientFunctor V` is an\nepimorphism. -/\ntheorem HomotopyCategory.lift_unique' (V : SSet.Truncated.{u} 2) {D} [Category D]\n    (F‚ÇÅ F‚ÇÇ : V.HomotopyCategory ‚•§ D)\n    (h : HomotopyCategory.quotientFunctor V ‚ãô F‚ÇÅ = HomotopyCategory.quotientFunctor V ‚ãô F‚ÇÇ) :\n    F‚ÇÅ = F‚ÇÇ :=\n  Quotient.lift_unique' (C := Cat.FreeRefl (OneTruncation‚ÇÇ V))\n    (HoRel‚ÇÇ (V := V)) _ _ h\n\n"}
{"name":"SSet.Truncated.hoFunctor‚ÇÇ_naturality","module":"Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat","initialProofState":"X Y : SSet.Truncated 2\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.Functor.comp ((SSet.oneTruncation‚ÇÇ.comp CategoryTheory.Cat.freeRefl).map f) (SSet.Truncated.HomotopyCategory.quotientFunctor Y)) ((SSet.Truncated.HomotopyCategory.quotientFunctor X).comp (SSet.Truncated.mapHomotopyCategory f))","decl":"theorem hoFunctor‚ÇÇ_naturality {X Y : SSet.Truncated.{u} 2} (f : X ‚ü∂ Y) :\n    (oneTruncation‚ÇÇ ‚ãô Cat.freeRefl).map f ‚ãô SSet.Truncated.HomotopyCategory.quotientFunctor Y =\n      SSet.Truncated.HomotopyCategory.quotientFunctor X ‚ãô mapHomotopyCategory f := rfl\n\n"}
