{"name":"Bundle.TotalSpace.ext","module":"Mathlib.Data.Bundle","initialProofState":"B : Type u_1\nF : Type u_4\nE : B → Type u_5\nx y : Bundle.TotalSpace F E\nproj : Eq x.proj y.proj\nsnd : HEq x.snd y.snd\n⊢ Eq x y","decl":"/-- `Bundle.TotalSpace F E` is the total space of the bundle. It consists of pairs\n`(proj : B, snd : E proj)`.\n-/\n@[ext]\nstructure TotalSpace (F : Type*) (E : B → Type*) where\n  /-- `Bundle.TotalSpace.proj` is the canonical projection `Bundle.TotalSpace F E → B` from the\n  total space to the base space. -/\n  proj : B\n  snd : E proj\n\n"}
{"name":"Bundle.TotalSpace.mk.injEq","module":"Mathlib.Data.Bundle","initialProofState":"B : Type u_1\nF : Type u_4\nE : B → Type u_5\nproj✝ : B\nsnd✝ : E proj✝\nproj : B\nsnd : E proj\n⊢ Eq (Eq { proj := proj✝, snd := snd✝ } { proj := proj, snd := snd }) (And (Eq proj✝ proj) (HEq snd✝ snd))","decl":"/-- `Bundle.TotalSpace F E` is the total space of the bundle. It consists of pairs\n`(proj : B, snd : E proj)`.\n-/\n@[ext]\nstructure TotalSpace (F : Type*) (E : B → Type*) where\n  /-- `Bundle.TotalSpace.proj` is the canonical projection `Bundle.TotalSpace F E → B` from the\n  total space to the base space. -/\n  proj : B\n  snd : E proj\n\n"}
{"name":"Bundle.TotalSpace.mk.sizeOf_spec","module":"Mathlib.Data.Bundle","initialProofState":"B : Type u_1\nF : Type u_4\nE : B → Type u_5\ninst✝² : SizeOf B\ninst✝¹ : SizeOf F\ninst✝ : (a : B) → SizeOf (E a)\nproj : B\nsnd : E proj\n⊢ Eq (SizeOf.sizeOf { proj := proj, snd := snd }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf proj)) (SizeOf.sizeOf snd))","decl":"/-- `Bundle.TotalSpace F E` is the total space of the bundle. It consists of pairs\n`(proj : B, snd : E proj)`.\n-/\n@[ext]\nstructure TotalSpace (F : Type*) (E : B → Type*) where\n  /-- `Bundle.TotalSpace.proj` is the canonical projection `Bundle.TotalSpace F E → B` from the\n  total space to the base space. -/\n  proj : B\n  snd : E proj\n\n"}
{"name":"Bundle.TotalSpace.ext_iff","module":"Mathlib.Data.Bundle","initialProofState":"B : Type u_1\nF : Type u_4\nE : B → Type u_5\nx y : Bundle.TotalSpace F E\n⊢ Iff (Eq x y) (And (Eq x.proj y.proj) (HEq x.snd y.snd))","decl":"/-- `Bundle.TotalSpace F E` is the total space of the bundle. It consists of pairs\n`(proj : B, snd : E proj)`.\n-/\n@[ext]\nstructure TotalSpace (F : Type*) (E : B → Type*) where\n  /-- `Bundle.TotalSpace.proj` is the canonical projection `Bundle.TotalSpace F E → B` from the\n  total space to the base space. -/\n  proj : B\n  snd : E proj\n\n"}
{"name":"Bundle.TotalSpace.mk.inj","module":"Mathlib.Data.Bundle","initialProofState":"B : Type u_1\nF : Type u_4\nE : B → Type u_5\nproj✝ : B\nsnd✝ : E proj✝\nproj : B\nsnd : E proj\nx✝ : Eq { proj := proj✝, snd := snd✝ } { proj := proj, snd := snd }\n⊢ And (Eq proj✝ proj) (HEq snd✝ snd)","decl":"/-- `Bundle.TotalSpace F E` is the total space of the bundle. It consists of pairs\n`(proj : B, snd : E proj)`.\n-/\n@[ext]\nstructure TotalSpace (F : Type*) (E : B → Type*) where\n  /-- `Bundle.TotalSpace.proj` is the canonical projection `Bundle.TotalSpace F E → B` from the\n  total space to the base space. -/\n  proj : B\n  snd : E proj\n\n"}
{"name":"Bundle.TotalSpace.mk_cast","module":"Mathlib.Data.Bundle","initialProofState":"B : Type u_1\nF : Type u_2\nE : B → Type u_3\nx x' : B\nh : Eq x x'\nb : E x\n⊢ Eq (Bundle.TotalSpace.mk' F x' (cast ⋯ b)) { proj := x, snd := b }","decl":"theorem TotalSpace.mk_cast {x x' : B} (h : x = x') (b : E x) :\n    .mk' F x' (cast (congr_arg E h) b) = TotalSpace.mk x b := by subst h; rfl\n\n"}
{"name":"Bundle.TotalSpace.mk_inj","module":"Mathlib.Data.Bundle","initialProofState":"B : Type u_1\nF : Type u_2\nE : B → Type u_3\nb : B\ny y' : E b\n⊢ Iff (Eq (Bundle.TotalSpace.mk' F b y) (Bundle.TotalSpace.mk' F b y')) (Eq y y')","decl":"@[simp 1001, mfld_simps 1001]\ntheorem TotalSpace.mk_inj {b : B} {y y' : E b} : mk' F b y = mk' F b y' ↔ y = y' := by\n  simp [TotalSpace.ext_iff]\n\n"}
{"name":"Bundle.TotalSpace.mk_injective","module":"Mathlib.Data.Bundle","initialProofState":"B : Type u_1\nF : Type u_2\nE : B → Type u_3\nb : B\n⊢ Function.Injective (Bundle.TotalSpace.mk b)","decl":"theorem TotalSpace.mk_injective (b : B) : Injective (mk b : E b → TotalSpace F E) := fun _ _ ↦\n  mk_inj.1\n\n"}
{"name":"Bundle.TotalSpace.eta","module":"Mathlib.Data.Bundle","initialProofState":"B : Type u_1\nF : Type u_2\nE : B → Type u_3\nz : Bundle.TotalSpace F E\n⊢ Eq { proj := z.proj, snd := z.snd } z","decl":"theorem TotalSpace.eta (z : TotalSpace F E) : TotalSpace.mk z.proj z.2 = z := rfl\n\n"}
{"name":"Bundle.TotalSpace.exists","module":"Mathlib.Data.Bundle","initialProofState":"B : Type u_1\nF : Type u_2\nE : B → Type u_3\np : Bundle.TotalSpace F E → Prop\n⊢ Iff (Exists fun x => p x) (Exists fun b => Exists fun y => p { proj := b, snd := y })","decl":"@[simp]\ntheorem TotalSpace.exists {p : TotalSpace F E → Prop} : (∃ x, p x) ↔ ∃ b y, p ⟨b, y⟩ :=\n  ⟨fun ⟨x, hx⟩ ↦ ⟨x.1, x.2, hx⟩, fun ⟨b, y, h⟩ ↦ ⟨⟨b, y⟩, h⟩⟩\n\n"}
{"name":"Bundle.TotalSpace.range_mk","module":"Mathlib.Data.Bundle","initialProofState":"B : Type u_1\nF : Type u_2\nE : B → Type u_3\nb : B\n⊢ Eq (Set.range (Bundle.TotalSpace.mk b)) (Set.preimage Bundle.TotalSpace.proj (Singleton.singleton b))","decl":"@[simp]\ntheorem TotalSpace.range_mk (b : B) : range ((↑) : E b → TotalSpace F E) = π F E ⁻¹' {b} := by\n  apply Subset.antisymm\n  · rintro _ ⟨x, rfl⟩\n    rfl\n  · rintro ⟨_, x⟩ rfl\n    exact ⟨x, rfl⟩\n\n"}
{"name":"Bundle.TotalSpace.toProd_apply","module":"Mathlib.Data.Bundle","initialProofState":"B : Type u_4\nF : Type u_5\nx : Bundle.TotalSpace F fun x => F\n⊢ Eq ((Bundle.TotalSpace.toProd B F) x) { fst := x.proj, snd := x.snd }","decl":"/-- A trivial bundle is equivalent to the product `B × F`. -/\n@[simps (config := { attrs := [`mfld_simps] })]\ndef TotalSpace.toProd (B F : Type*) : (TotalSpace F fun _ : B => F) ≃ B × F where\n  toFun x := (x.1, x.2)\n  invFun x := ⟨x.1, x.2⟩\n  left_inv := fun ⟨_, _⟩ => rfl\n  right_inv := fun ⟨_, _⟩ => rfl\n\n"}
{"name":"Bundle.TotalSpace.toProd_symm_apply_proj","module":"Mathlib.Data.Bundle","initialProofState":"B : Type u_4\nF : Type u_5\nx : Prod B F\n⊢ Eq ((Bundle.TotalSpace.toProd B F).symm x).proj x.fst","decl":"/-- A trivial bundle is equivalent to the product `B × F`. -/\n@[simps (config := { attrs := [`mfld_simps] })]\ndef TotalSpace.toProd (B F : Type*) : (TotalSpace F fun _ : B => F) ≃ B × F where\n  toFun x := (x.1, x.2)\n  invFun x := ⟨x.1, x.2⟩\n  left_inv := fun ⟨_, _⟩ => rfl\n  right_inv := fun ⟨_, _⟩ => rfl\n\n"}
{"name":"Bundle.TotalSpace.toProd_symm_apply_snd","module":"Mathlib.Data.Bundle","initialProofState":"B : Type u_4\nF : Type u_5\nx : Prod B F\n⊢ Eq ((Bundle.TotalSpace.toProd B F).symm x).snd x.snd","decl":"/-- A trivial bundle is equivalent to the product `B × F`. -/\n@[simps (config := { attrs := [`mfld_simps] })]\ndef TotalSpace.toProd (B F : Type*) : (TotalSpace F fun _ : B => F) ≃ B × F where\n  toFun x := (x.1, x.2)\n  invFun x := ⟨x.1, x.2⟩\n  left_inv := fun ⟨_, _⟩ => rfl\n  right_inv := fun ⟨_, _⟩ => rfl\n\n"}
{"name":"Bundle.instNonemptyPullback","module":"Mathlib.Data.Bundle","initialProofState":"B : Type u_1\nE : B → Type u_3\nB' : Type u_4\nf : B' → B\nx : B'\ninst✝ : Nonempty (E (f x))\n⊢ Nonempty (Bundle.Pullback f E x)","decl":"instance {f : B' → B} {x : B'} [Nonempty (E (f x))] : Nonempty ((f *ᵖ E) x) :=\n  ‹Nonempty (E (f x))›\n\n"}
{"name":"Bundle.Pullback.lift_proj","module":"Mathlib.Data.Bundle","initialProofState":"B : Type u_1\nF : Type u_2\nE : B → Type u_3\nB' : Type u_4\nf : B' → B\na✝ : Bundle.TotalSpace F (Bundle.Pullback f E)\n⊢ Eq (Bundle.Pullback.lift f a✝).proj (f a✝.proj)","decl":"/-- The base map `f : B' → B` lifts to a canonical map on the total spaces. -/\n@[simps (config := { attrs := [`mfld_simps] })]\ndef Pullback.lift (f : B' → B) : TotalSpace F (f *ᵖ E) → TotalSpace F E := fun z => ⟨f z.proj, z.2⟩\n\n"}
{"name":"Bundle.Pullback.lift_snd","module":"Mathlib.Data.Bundle","initialProofState":"B : Type u_1\nF : Type u_2\nE : B → Type u_3\nB' : Type u_4\nf : B' → B\na✝ : Bundle.TotalSpace F (Bundle.Pullback f E)\n⊢ Eq (Bundle.Pullback.lift f a✝).snd a✝.snd","decl":"/-- The base map `f : B' → B` lifts to a canonical map on the total spaces. -/\n@[simps (config := { attrs := [`mfld_simps] })]\ndef Pullback.lift (f : B' → B) : TotalSpace F (f *ᵖ E) → TotalSpace F E := fun z => ⟨f z.proj, z.2⟩\n\n"}
{"name":"Bundle.Pullback.lift_mk","module":"Mathlib.Data.Bundle","initialProofState":"B : Type u_1\nF : Type u_2\nE : B → Type u_3\nB' : Type u_4\nf : B' → B\nx : B'\ny : E (f x)\n⊢ Eq (Bundle.Pullback.lift f (Bundle.TotalSpace.mk' F x y)) { proj := f x, snd := y }","decl":"@[simp, mfld_simps]\ntheorem Pullback.lift_mk (f : B' → B) (x : B') (y : E (f x)) :\n    Pullback.lift f (.mk' F x y) = ⟨f x, y⟩ :=\n  rfl\n\n"}
