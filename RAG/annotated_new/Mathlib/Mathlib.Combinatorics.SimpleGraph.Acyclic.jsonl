{"name":"SimpleGraph.IsTree.IsAcyclic","module":"Mathlib.Combinatorics.SimpleGraph.Acyclic","initialProofState":"V : Type u\nG : SimpleGraph V\nself : G.IsTree\n⊢ G.IsAcyclic","decl":"/-- A *tree* is a connected acyclic graph. -/\n@[mk_iff]\nstructure IsTree : Prop where\n  /-- Graph is connected. -/\n  protected isConnected : G.Connected\n  /-- Graph is acyclic. -/\n  protected IsAcyclic : G.IsAcyclic\n\n"}
{"name":"SimpleGraph.IsTree.isConnected","module":"Mathlib.Combinatorics.SimpleGraph.Acyclic","initialProofState":"V : Type u\nG : SimpleGraph V\nself : G.IsTree\n⊢ G.Connected","decl":"/-- A *tree* is a connected acyclic graph. -/\n@[mk_iff]\nstructure IsTree : Prop where\n  /-- Graph is connected. -/\n  protected isConnected : G.Connected\n  /-- Graph is acyclic. -/\n  protected IsAcyclic : G.IsAcyclic\n\n"}
{"name":"SimpleGraph.isTree_iff","module":"Mathlib.Combinatorics.SimpleGraph.Acyclic","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Iff G.IsTree (And G.Connected G.IsAcyclic)","decl":"/-- A *tree* is a connected acyclic graph. -/\n@[mk_iff]\nstructure IsTree : Prop where\n  /-- Graph is connected. -/\n  protected isConnected : G.Connected\n  /-- Graph is acyclic. -/\n  protected IsAcyclic : G.IsAcyclic\n\n"}
{"name":"SimpleGraph.isAcyclic_bot","module":"Mathlib.Combinatorics.SimpleGraph.Acyclic","initialProofState":"V : Type u\n⊢ Bot.bot.IsAcyclic","decl":"@[simp] lemma isAcyclic_bot : IsAcyclic (⊥ : SimpleGraph V) := fun _a _w hw ↦ hw.ne_bot rfl\n\n"}
{"name":"SimpleGraph.isAcyclic_iff_forall_adj_isBridge","module":"Mathlib.Combinatorics.SimpleGraph.Acyclic","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Iff G.IsAcyclic (∀ ⦃v w : V⦄, G.Adj v w → G.IsBridge (Sym2.mk { fst := v, snd := w }))","decl":"theorem isAcyclic_iff_forall_adj_isBridge :\n    G.IsAcyclic ↔ ∀ ⦃v w : V⦄, G.Adj v w → G.IsBridge s(v, w) := by\n  simp_rw [isBridge_iff_adj_and_forall_cycle_not_mem]\n  constructor\n  · intro ha v w hvw\n    apply And.intro hvw\n    intro u p hp\n    cases ha p hp\n  · rintro hb v (_ | ⟨ha, p⟩) hp\n    · exact hp.not_of_nil\n    · apply (hb ha).2 _ hp\n      rw [Walk.edges_cons]\n      apply List.mem_cons_self\n\n"}
{"name":"SimpleGraph.isAcyclic_iff_forall_edge_isBridge","module":"Mathlib.Combinatorics.SimpleGraph.Acyclic","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Iff G.IsAcyclic (∀ ⦃e : Sym2 V⦄, Membership.mem G.edgeSet e → G.IsBridge e)","decl":"theorem isAcyclic_iff_forall_edge_isBridge :\n    G.IsAcyclic ↔ ∀ ⦃e⦄, e ∈ (G.edgeSet) → G.IsBridge e := by\n  simp [isAcyclic_iff_forall_adj_isBridge, Sym2.forall]\n\n"}
{"name":"SimpleGraph.IsAcyclic.path_unique","module":"Mathlib.Combinatorics.SimpleGraph.Acyclic","initialProofState":"V : Type u\nG : SimpleGraph V\nh : G.IsAcyclic\nv w : V\np q : G.Path v w\n⊢ Eq p q","decl":"theorem IsAcyclic.path_unique {G : SimpleGraph V} (h : G.IsAcyclic) {v w : V} (p q : G.Path v w) :\n    p = q := by\n  obtain ⟨p, hp⟩ := p\n  obtain ⟨q, hq⟩ := q\n  rw [Subtype.mk.injEq]\n  induction p with\n  | nil =>\n    cases (Walk.isPath_iff_eq_nil _).mp hq\n    rfl\n  | cons ph p ih =>\n    rw [isAcyclic_iff_forall_adj_isBridge] at h\n    specialize h ph\n    rw [isBridge_iff_adj_and_forall_walk_mem_edges] at h\n    replace h := h.2 (q.append p.reverse)\n    simp only [Walk.edges_append, Walk.edges_reverse, List.mem_append, List.mem_reverse] at h\n    cases' h with h h\n    · cases q with\n      | nil => simp [Walk.isPath_def] at hp\n      | cons _ q =>\n        rw [Walk.cons_isPath_iff] at hp hq\n        simp only [Walk.edges_cons, List.mem_cons, Sym2.eq_iff, true_and] at h\n        rcases h with (⟨h, rfl⟩ | ⟨rfl, rfl⟩) | h\n        · cases ih hp.1 q hq.1\n          rfl\n        · simp at hq\n        · exact absurd (Walk.fst_mem_support_of_mem_edges _ h) hq.2\n    · rw [Walk.cons_isPath_iff] at hp\n      exact absurd (Walk.fst_mem_support_of_mem_edges _ h) hp.2\n\n"}
{"name":"SimpleGraph.isAcyclic_of_path_unique","module":"Mathlib.Combinatorics.SimpleGraph.Acyclic","initialProofState":"V : Type u\nG : SimpleGraph V\nh : ∀ (v w : V) (p q : G.Path v w), Eq p q\n⊢ G.IsAcyclic","decl":"theorem isAcyclic_of_path_unique (h : ∀ (v w : V) (p q : G.Path v w), p = q) : G.IsAcyclic := by\n  intro v c hc\n  simp only [Walk.isCycle_def, Ne] at hc\n  cases c with\n  | nil => cases hc.2.1 rfl\n  | cons ha c' =>\n    simp only [Walk.cons_isTrail_iff, Walk.support_cons, List.tail_cons] at hc\n    specialize h _ _ ⟨c', by simp only [Walk.isPath_def, hc.2]⟩ (Path.singleton ha.symm)\n    rw [Path.singleton, Subtype.mk.injEq] at h\n    simp [h] at hc\n\n"}
{"name":"SimpleGraph.isAcyclic_iff_path_unique","module":"Mathlib.Combinatorics.SimpleGraph.Acyclic","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Iff G.IsAcyclic (∀ ⦃v w : V⦄ (p q : G.Path v w), Eq p q)","decl":"theorem isAcyclic_iff_path_unique : G.IsAcyclic ↔ ∀ ⦃v w : V⦄ (p q : G.Path v w), p = q :=\n  ⟨IsAcyclic.path_unique, isAcyclic_of_path_unique⟩\n\n"}
{"name":"SimpleGraph.isTree_iff_existsUnique_path","module":"Mathlib.Combinatorics.SimpleGraph.Acyclic","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Iff G.IsTree (And (Nonempty V) (∀ (v w : V), ExistsUnique fun p => p.IsPath))","decl":"theorem isTree_iff_existsUnique_path :\n    G.IsTree ↔ Nonempty V ∧ ∀ v w : V, ∃! p : G.Walk v w, p.IsPath := by\n  classical\n  rw [isTree_iff, isAcyclic_iff_path_unique]\n  constructor\n  · rintro ⟨hc, hu⟩\n    refine ⟨hc.nonempty, ?_⟩\n    intro v w\n    let q := (hc v w).some.toPath\n    use q\n    simp only [true_and, Path.isPath]\n    intro p hp\n    specialize hu ⟨p, hp⟩ q\n    exact Subtype.ext_iff.mp hu\n  · rintro ⟨hV, h⟩\n    refine ⟨Connected.mk ?_, ?_⟩\n    · intro v w\n      obtain ⟨p, _⟩ := h v w\n      exact p.reachable\n    · rintro v w ⟨p, hp⟩ ⟨q, hq⟩\n      simp only [ExistsUnique.unique (h v w) hp hq]\n\n"}
{"name":"SimpleGraph.IsTree.existsUnique_path","module":"Mathlib.Combinatorics.SimpleGraph.Acyclic","initialProofState":"V : Type u\nG : SimpleGraph V\nhG : G.IsTree\nv w : V\n⊢ ExistsUnique fun p => p.IsPath","decl":"lemma IsTree.existsUnique_path (hG : G.IsTree) : ∀ v w, ∃! p : G.Walk v w, p.IsPath :=\n  (isTree_iff_existsUnique_path.1 hG).2\n\n"}
{"name":"SimpleGraph.IsTree.card_edgeFinset","module":"Mathlib.Combinatorics.SimpleGraph.Acyclic","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝¹ : Fintype V\ninst✝ : Fintype ↑G.edgeSet\nhG : G.IsTree\n⊢ Eq (HAdd.hAdd G.edgeFinset.card 1) (Fintype.card V)","decl":"lemma IsTree.card_edgeFinset [Fintype V] [Fintype G.edgeSet] (hG : G.IsTree) :\n    Finset.card G.edgeFinset + 1 = Fintype.card V := by\n  have := hG.isConnected.nonempty\n  inhabit V\n  classical\n  have : Finset.card ({default} : Finset V)ᶜ + 1 = Fintype.card V := by\n    rw [Finset.card_compl, Finset.card_singleton, Nat.sub_add_cancel Fintype.card_pos]\n  rw [← this, add_left_inj]\n  choose f hf hf' using (hG.existsUnique_path · default)\n  refine Eq.symm <| Finset.card_bij\n          (fun w hw => ((f w).firstDart <| ?notNil).edge)\n          (fun a ha => ?memEdges) ?inj ?surj\n  case notNil => exact not_nil_of_ne (by simpa using hw)\n  case memEdges => simp\n  case inj =>\n    intros a ha b hb h\n    wlog h' : (f a).length ≤ (f b).length generalizing a b\n    · exact Eq.symm (this _ hb _ ha h.symm (le_of_not_le h'))\n    rw [dart_edge_eq_iff] at h\n    obtain (h | h) := h\n    · exact (congrArg (·.fst) h)\n    · have h1 : ((f a).firstDart <| not_nil_of_ne (by simpa using ha)).snd = b :=\n        congrArg (·.snd) h\n      have h3 := congrArg length (hf' _ ((f _).tail.copy h1 rfl) ?_)\n      · rw [length_copy, ← add_left_inj 1,\n          length_tail_add_one (not_nil_of_ne (by simpa using ha))] at h3\n        omega\n      · simp only [ne_eq, eq_mp_eq_cast, id_eq, isPath_copy]\n        exact (hf _).tail\n  case surj =>\n    simp only [mem_edgeFinset, Finset.mem_compl, Finset.mem_singleton, Sym2.forall, mem_edgeSet]\n    intros x y h\n    wlog h' : (f x).length ≤ (f y).length generalizing x y\n    · rw [Sym2.eq_swap]\n      exact this y x h.symm (le_of_not_le h')\n    refine ⟨y, ?_, dart_edge_eq_mk'_iff.2 <| Or.inr ?_⟩\n    · rintro rfl\n      rw [← hf' _ nil IsPath.nil, length_nil,\n          ← hf' _ (.cons h .nil) (IsPath.nil.cons <| by simpa using h.ne),\n          length_cons, length_nil] at h'\n      simp [Nat.le_zero, Nat.one_ne_zero] at h'\n    rw [← hf' _ (.cons h.symm (f x)) ((cons_isPath_iff _ _).2 ⟨hf _, fun hy => ?contra⟩)]\n    · simp only [firstDart_toProd, getVert_cons_succ, getVert_zero, Prod.swap_prod_mk]\n    case contra =>\n      suffices (f x).takeUntil y hy = .cons h .nil by\n        rw [← take_spec _ hy] at h'\n        simp [this, hf' _ _ ((hf _).dropUntil hy)] at h'\n      refine (hG.existsUnique_path _ _).unique ((hf _).takeUntil _) ?_\n      simp [h.ne]\n\n"}
