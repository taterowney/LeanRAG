{"name":"LieModule.mem_weightSpace","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¶ : CommRing R\ninstâœâµ : LieRing L\ninstâœâ´ : LieAlgebra R L\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : LieRingModule L M\ninstâœ : LieModule R L M\nÏ‡ : L â†’ R\nm : M\nâŠ¢ Iff (Membership.mem (LieModule.weightSpace M Ï‡) m) (âˆ€ (x : L), Eq (Bracket.bracket x m) (HSMul.hSMul (Ï‡ x) m))","decl":"lemma mem_weightSpace (Ï‡ : L â†’ R) (m : M) : m âˆˆ weightSpace M Ï‡ â†” âˆ€ x, â…x, mâ† = Ï‡ x â€¢ m := by\n  simp [weightSpace]\n\n"}
{"name":"LieModule.weight_vector_multiplication","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\ninstâœÂ¹â´ : CommRing R\ninstâœÂ¹Â³ : LieRing L\ninstâœÂ¹Â² : LieAlgebra R L\nMâ‚ : Type u_5\nMâ‚‚ : Type u_6\nMâ‚ƒ : Type u_7\ninstâœÂ¹Â¹ : AddCommGroup Mâ‚\ninstâœÂ¹â° : Module R Mâ‚\ninstâœâ¹ : LieRingModule L Mâ‚\ninstâœâ¸ : LieModule R L Mâ‚\ninstâœâ· : AddCommGroup Mâ‚‚\ninstâœâ¶ : Module R Mâ‚‚\ninstâœâµ : LieRingModule L Mâ‚‚\ninstâœâ´ : LieModule R L Mâ‚‚\ninstâœÂ³ : AddCommGroup Mâ‚ƒ\ninstâœÂ² : Module R Mâ‚ƒ\ninstâœÂ¹ : LieRingModule L Mâ‚ƒ\ninstâœ : LieModule R L Mâ‚ƒ\ng : LieModuleHom R L (TensorProduct R Mâ‚ Mâ‚‚) Mâ‚ƒ\nÏ‡â‚ Ï‡â‚‚ : R\nx : L\nâŠ¢ LE.le (LinearMap.range ((â†‘g).comp (TensorProduct.mapIncl (((LieModule.toEnd R L Mâ‚) x).maxGenEigenspace Ï‡â‚) (((LieModule.toEnd R L Mâ‚‚) x).maxGenEigenspace Ï‡â‚‚)))) (((LieModule.toEnd R L Mâ‚ƒ) x).maxGenEigenspace (HAdd.hAdd Ï‡â‚ Ï‡â‚‚))","decl":"/-- See also `bourbaki1975b` Chapter VII Â§1.1, Proposition 2 (ii). -/\nprotected theorem weight_vector_multiplication (Mâ‚ Mâ‚‚ Mâ‚ƒ : Type*)\n    [AddCommGroup Mâ‚] [Module R Mâ‚] [LieRingModule L Mâ‚] [LieModule R L Mâ‚] [AddCommGroup Mâ‚‚]\n    [Module R Mâ‚‚] [LieRingModule L Mâ‚‚] [LieModule R L Mâ‚‚] [AddCommGroup Mâ‚ƒ] [Module R Mâ‚ƒ]\n    [LieRingModule L Mâ‚ƒ] [LieModule R L Mâ‚ƒ] (g : Mâ‚ âŠ—[R] Mâ‚‚ â†’â‚—â…R,Lâ† Mâ‚ƒ) (Ï‡â‚ Ï‡â‚‚ : R) (x : L) :\n    LinearMap.range ((g : Mâ‚ âŠ—[R] Mâ‚‚ â†’â‚—[R] Mâ‚ƒ).comp (mapIncl ğ•(Mâ‚, Ï‡â‚, x) ğ•(Mâ‚‚, Ï‡â‚‚, x))) â‰¤\n      ğ•(Mâ‚ƒ, Ï‡â‚ + Ï‡â‚‚, x) := by\n  -- Unpack the statement of the goal.\n  intro mâ‚ƒ\n  simp only [TensorProduct.mapIncl, LinearMap.mem_range, LinearMap.coe_comp,\n    LieModuleHom.coe_toLinearMap, Function.comp_apply, Pi.add_apply, exists_imp,\n    Module.End.mem_maxGenEigenspace]\n  rintro t rfl\n  -- Set up some notation.\n  let F : Module.End R Mâ‚ƒ := toEnd R L Mâ‚ƒ x - (Ï‡â‚ + Ï‡â‚‚) â€¢ â†‘1\n  -- The goal is linear in `t` so use induction to reduce to the case that `t` is a pure tensor.\n  refine t.induction_on ?_ ?_ ?_\n  Â· use 0; simp only [LinearMap.map_zero, LieModuleHom.map_zero]\n  swap\n  Â· rintro tâ‚ tâ‚‚ âŸ¨kâ‚, hkâ‚âŸ© âŸ¨kâ‚‚, hkâ‚‚âŸ©; use max kâ‚ kâ‚‚\n    simp only [LieModuleHom.map_add, LinearMap.map_add,\n      LinearMap.pow_map_zero_of_le (le_max_left kâ‚ kâ‚‚) hkâ‚,\n      LinearMap.pow_map_zero_of_le (le_max_right kâ‚ kâ‚‚) hkâ‚‚, add_zero]\n  -- Now the main argument: pure tensors.\n  rintro âŸ¨mâ‚, hmâ‚âŸ© âŸ¨mâ‚‚, hmâ‚‚âŸ©\n  change âˆƒ k, (F ^ k) ((g : Mâ‚ âŠ—[R] Mâ‚‚ â†’â‚—[R] Mâ‚ƒ) (mâ‚ âŠ—â‚œ mâ‚‚)) = (0 : Mâ‚ƒ)\n  -- Eliminate `g` from the picture.\n  let fâ‚ : Module.End R (Mâ‚ âŠ—[R] Mâ‚‚) := (toEnd R L Mâ‚ x - Ï‡â‚ â€¢ â†‘1).rTensor Mâ‚‚\n  let fâ‚‚ : Module.End R (Mâ‚ âŠ—[R] Mâ‚‚) := (toEnd R L Mâ‚‚ x - Ï‡â‚‚ â€¢ â†‘1).lTensor Mâ‚\n  have h_comm_square : F âˆ˜â‚— â†‘g = (g : Mâ‚ âŠ—[R] Mâ‚‚ â†’â‚—[R] Mâ‚ƒ).comp (fâ‚ + fâ‚‚) := by\n    ext mâ‚ mâ‚‚\n    simp only [fâ‚, fâ‚‚, F, â† g.map_lie x (mâ‚ âŠ—â‚œ mâ‚‚), add_smul, sub_tmul, tmul_sub, smul_tmul,\n      lie_tmul_right, tmul_smul, toEnd_apply_apply, LieModuleHom.map_smul,\n      LinearMap.one_apply, LieModuleHom.coe_toLinearMap, LinearMap.smul_apply, Function.comp_apply,\n      LinearMap.coe_comp, LinearMap.rTensor_tmul, LieModuleHom.map_add, LinearMap.add_apply,\n      LieModuleHom.map_sub, LinearMap.sub_apply, LinearMap.lTensor_tmul,\n      AlgebraTensorModule.curry_apply, TensorProduct.curry_apply, LinearMap.toFun_eq_coe,\n      LinearMap.coe_restrictScalars]\n    abel\n  rsuffices âŸ¨k, hkâŸ© : âˆƒ k : â„•, ((fâ‚ + fâ‚‚) ^ k) (mâ‚ âŠ—â‚œ mâ‚‚) = 0\n  Â· use k\n    change (F ^ k) (g.toLinearMap (mâ‚ âŠ—â‚œ[R] mâ‚‚)) = 0\n    rw [â† LinearMap.comp_apply, LinearMap.commute_pow_left_of_commute h_comm_square,\n      LinearMap.comp_apply, hk, LinearMap.map_zero]\n  -- Unpack the information we have about `mâ‚`, `mâ‚‚`.\n  simp only [Module.End.mem_maxGenEigenspace] at hmâ‚ hmâ‚‚\n  obtain âŸ¨kâ‚, hkâ‚âŸ© := hmâ‚\n  obtain âŸ¨kâ‚‚, hkâ‚‚âŸ© := hmâ‚‚\n  have hfâ‚ : (fâ‚ ^ kâ‚) (mâ‚ âŠ—â‚œ mâ‚‚) = 0 := by\n    simp only [fâ‚, hkâ‚, zero_tmul, LinearMap.rTensor_tmul, LinearMap.rTensor_pow]\n  have hfâ‚‚ : (fâ‚‚ ^ kâ‚‚) (mâ‚ âŠ—â‚œ mâ‚‚) = 0 := by\n    simp only [fâ‚‚, hkâ‚‚, tmul_zero, LinearMap.lTensor_tmul, LinearMap.lTensor_pow]\n  -- It's now just an application of the binomial theorem.\n  use kâ‚ + kâ‚‚ - 1\n  have hf_comm : Commute fâ‚ fâ‚‚ := by\n    ext mâ‚ mâ‚‚\n    simp only [fâ‚, fâ‚‚, LinearMap.mul_apply, LinearMap.rTensor_tmul, LinearMap.lTensor_tmul,\n      AlgebraTensorModule.curry_apply, LinearMap.toFun_eq_coe, LinearMap.lTensor_tmul,\n      TensorProduct.curry_apply, LinearMap.coe_restrictScalars]\n  rw [hf_comm.add_pow']\n  simp only [TensorProduct.mapIncl, Submodule.subtype_apply, Finset.sum_apply, Submodule.coe_mk,\n    LinearMap.coeFn_sum, TensorProduct.map_tmul, LinearMap.smul_apply]\n  -- The required sum is zero because each individual term is zero.\n  apply Finset.sum_eq_zero\n  rintro âŸ¨i, jâŸ© hij\n  -- Eliminate the binomial coefficients from the picture.\n  suffices (fâ‚ ^ i * fâ‚‚ ^ j) (mâ‚ âŠ—â‚œ mâ‚‚) = 0 by rw [this]; apply smul_zero\n  -- Finish off with appropriate case analysis.\n  cases' Nat.le_or_le_of_add_eq_add_pred (Finset.mem_antidiagonal.mp hij) with hi hj\n  Â· rw [(hf_comm.pow_pow i j).eq, LinearMap.mul_apply, LinearMap.pow_map_zero_of_le hi hfâ‚,\n      LinearMap.map_zero]\n  Â· rw [LinearMap.mul_apply, LinearMap.pow_map_zero_of_le hj hfâ‚‚, LinearMap.map_zero]\n\n"}
{"name":"LieModule.lie_mem_maxGenEigenspace_toEnd","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¶ : CommRing R\ninstâœâµ : LieRing L\ninstâœâ´ : LieAlgebra R L\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : LieRingModule L M\ninstâœ : LieModule R L M\nÏ‡â‚ Ï‡â‚‚ : R\nx y : L\nm : M\nhy : Membership.mem (((LieModule.toEnd R L L) x).maxGenEigenspace Ï‡â‚) y\nhm : Membership.mem (((LieModule.toEnd R L M) x).maxGenEigenspace Ï‡â‚‚) m\nâŠ¢ Membership.mem (((LieModule.toEnd R L M) x).maxGenEigenspace (HAdd.hAdd Ï‡â‚ Ï‡â‚‚)) (Bracket.bracket y m)","decl":"lemma lie_mem_maxGenEigenspace_toEnd\n    {Ï‡â‚ Ï‡â‚‚ : R} {x y : L} {m : M} (hy : y âˆˆ ğ•(L, Ï‡â‚, x)) (hm : m âˆˆ ğ•(M, Ï‡â‚‚, x)) :\n    â…y, mâ† âˆˆ ğ•(M, Ï‡â‚ + Ï‡â‚‚, x) := by\n  apply LieModule.weight_vector_multiplication L M M (toModuleHom R L M) Ï‡â‚ Ï‡â‚‚\n  simp only [LieModuleHom.coe_toLinearMap, Function.comp_apply, LinearMap.coe_comp,\n    TensorProduct.mapIncl, LinearMap.mem_range]\n  use âŸ¨y, hyâŸ© âŠ—â‚œ âŸ¨m, hmâŸ©\n  simp only [Submodule.subtype_apply, toModuleHom_apply, TensorProduct.map_tmul]\n\n"}
{"name":"LieModule.mem_genWeightSpaceOf","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nÏ‡ : R\nx : L\nm : M\nâŠ¢ Iff (Membership.mem (LieModule.genWeightSpaceOf M Ï‡ x) m) (Exists fun k => Eq ((HPow.hPow (HSub.hSub ((LieModule.toEnd R L M) x) (HSMul.hSMul Ï‡ 1)) k) m) 0)","decl":"theorem mem_genWeightSpaceOf (Ï‡ : R) (x : L) (m : M) :\n    m âˆˆ genWeightSpaceOf M Ï‡ x â†” âˆƒ k : â„•, ((toEnd R L M x - Ï‡ â€¢ â†‘1) ^ k) m = 0 := by\n  simp [genWeightSpaceOf]\n\n"}
{"name":"LieModule.coe_genWeightSpaceOf_zero","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nx : L\nâŠ¢ Eq (â†‘(LieModule.genWeightSpaceOf M 0 x)) (iSup fun k => LinearMap.ker (HPow.hPow ((LieModule.toEnd R L M) x) k))","decl":"theorem coe_genWeightSpaceOf_zero (x : L) :\n    â†‘(genWeightSpaceOf M (0 : R) x) = â¨† k, LinearMap.ker (toEnd R L M x ^ k) := by\n  simp [genWeightSpaceOf, â† Module.End.iSup_genEigenspace_eq]\n\n"}
{"name":"LieModule.mem_genWeightSpace","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nÏ‡ : L â†’ R\nm : M\nâŠ¢ Iff (Membership.mem (LieModule.genWeightSpace M Ï‡) m) (âˆ€ (x : L), Exists fun k => Eq ((HPow.hPow (HSub.hSub ((LieModule.toEnd R L M) x) (HSMul.hSMul (Ï‡ x) 1)) k) m) 0)","decl":"theorem mem_genWeightSpace (Ï‡ : L â†’ R) (m : M) :\n    m âˆˆ genWeightSpace M Ï‡ â†” âˆ€ x, âˆƒ k : â„•, ((toEnd R L M x - Ï‡ x â€¢ â†‘1) ^ k) m = 0 := by\n  simp [genWeightSpace, mem_genWeightSpaceOf]\n\n"}
{"name":"LieModule.genWeightSpace_le_genWeightSpaceOf","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nx : L\nÏ‡ : L â†’ R\nâŠ¢ LE.le (LieModule.genWeightSpace M Ï‡) (LieModule.genWeightSpaceOf M (Ï‡ x) x)","decl":"lemma genWeightSpace_le_genWeightSpaceOf (x : L) (Ï‡ : L â†’ R) :\n    genWeightSpace M Ï‡ â‰¤ genWeightSpaceOf M (Ï‡ x) x :=\n  iInf_le _ x\n\n"}
{"name":"LieModule.weightSpace_le_genWeightSpace","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nÏ‡ : L â†’ R\nâŠ¢ LE.le (LieModule.weightSpace M Ï‡) (LieModule.genWeightSpace M Ï‡)","decl":"lemma weightSpace_le_genWeightSpace (Ï‡ : L â†’ R) :\n    weightSpace M Ï‡ â‰¤ genWeightSpace M Ï‡ := by\n  apply le_iInf\n  intro x\n  rw [â† (LieSubmodule.toSubmodule_orderEmbedding R L M).le_iff_le]\n  apply (iInf_le _ x).trans\n  exact ((toEnd R L M x).genEigenspace (Ï‡ x)).monotone le_top\n\n"}
{"name":"LieModule.Weight.mk.injEq","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\ntoFunâœ : L â†’ R\ngenWeightSpace_ne_bot'âœ : Ne (LieModule.genWeightSpace M toFunâœ) Bot.bot\ntoFun : L â†’ R\ngenWeightSpace_ne_bot' : Ne (LieModule.genWeightSpace M toFun) Bot.bot\nâŠ¢ Eq (Eq { toFun := toFunâœ, genWeightSpace_ne_bot' := genWeightSpace_ne_bot'âœ } { toFun := toFun, genWeightSpace_ne_bot' := genWeightSpace_ne_bot' }) (Eq toFunâœ toFun)","decl":"variable (R L) in\n/-- A weight of a Lie module is a map `L â†’ R` such that the corresponding weight space is\nnon-trivial. -/\nstructure Weight where\n  /-- The family of eigenvalues corresponding to a weight. -/\n  toFun : L â†’ R\n  genWeightSpace_ne_bot' : genWeightSpace M toFun â‰  âŠ¥\n\n"}
{"name":"LieModule.Weight.mk.inj","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\ntoFunâœ : L â†’ R\ngenWeightSpace_ne_bot'âœ : Ne (LieModule.genWeightSpace M toFunâœ) Bot.bot\ntoFun : L â†’ R\ngenWeightSpace_ne_bot' : Ne (LieModule.genWeightSpace M toFun) Bot.bot\nxâœ : Eq { toFun := toFunâœ, genWeightSpace_ne_bot' := genWeightSpace_ne_bot'âœ } { toFun := toFun, genWeightSpace_ne_bot' := genWeightSpace_ne_bot' }\nâŠ¢ Eq toFunâœ toFun","decl":"variable (R L) in\n/-- A weight of a Lie module is a map `L â†’ R` such that the corresponding weight space is\nnon-trivial. -/\nstructure Weight where\n  /-- The family of eigenvalues corresponding to a weight. -/\n  toFun : L â†’ R\n  genWeightSpace_ne_bot' : genWeightSpace M toFun â‰  âŠ¥\n\n"}
{"name":"LieModule.Weight.mk.sizeOf_spec","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœÂ¹â° : CommRing R\ninstâœâ¹ : LieRing L\ninstâœâ¸ : LieAlgebra R L\ninstâœâ· : AddCommGroup M\ninstâœâ¶ : Module R M\ninstâœâµ : LieRingModule L M\ninstâœâ´ : LieModule R L M\ninstâœÂ³ : LieRing.IsNilpotent L\ninstâœÂ² : SizeOf R\ninstâœÂ¹ : SizeOf L\ninstâœ : SizeOf M\ntoFun : L â†’ R\ngenWeightSpace_ne_bot' : Ne (LieModule.genWeightSpace M toFun) Bot.bot\nâŠ¢ Eq (SizeOf.sizeOf { toFun := toFun, genWeightSpace_ne_bot' := genWeightSpace_ne_bot' }) 1","decl":"variable (R L) in\n/-- A weight of a Lie module is a map `L â†’ R` such that the corresponding weight space is\nnon-trivial. -/\nstructure Weight where\n  /-- The family of eigenvalues corresponding to a weight. -/\n  toFun : L â†’ R\n  genWeightSpace_ne_bot' : genWeightSpace M toFun â‰  âŠ¥\n\n"}
{"name":"LieModule.Weight.genWeightSpace_ne_bot'","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nself : LieModule.Weight R L M\nâŠ¢ Ne (LieModule.genWeightSpace M self.toFun) Bot.bot","decl":"variable (R L) in\n/-- A weight of a Lie module is a map `L â†’ R` such that the corresponding weight space is\nnon-trivial. -/\nstructure Weight where\n  /-- The family of eigenvalues corresponding to a weight. -/\n  toFun : L â†’ R\n  genWeightSpace_ne_bot' : genWeightSpace M toFun â‰  âŠ¥\n\n"}
{"name":"LieModule.Weight.coe_weight_mk","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nÏ‡ : L â†’ R\nh : Ne (LieModule.genWeightSpace M Ï‡) Bot.bot\nâŠ¢ Eq (â‡‘{ toFun := Ï‡, genWeightSpace_ne_bot' := h }) Ï‡","decl":"@[simp] lemma coe_weight_mk (Ï‡ : L â†’ R) (h) :\n    (â†‘(âŸ¨Ï‡, hâŸ© : Weight R L M) : L â†’ R) = Ï‡ :=\n  rfl\n\n"}
{"name":"LieModule.Weight.genWeightSpace_ne_bot","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nÏ‡ : LieModule.Weight R L M\nâŠ¢ Ne (LieModule.genWeightSpace M â‡‘Ï‡) Bot.bot","decl":"lemma genWeightSpace_ne_bot (Ï‡ : Weight R L M) : genWeightSpace M Ï‡ â‰  âŠ¥ := Ï‡.genWeightSpace_ne_bot'\n\n"}
{"name":"LieModule.Weight.ext_iff","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nÏ‡â‚ Ï‡â‚‚ : LieModule.Weight R L M\nâŠ¢ Iff (Eq Ï‡â‚ Ï‡â‚‚) (âˆ€ (x : L), Eq (Ï‡â‚ x) (Ï‡â‚‚ x))","decl":"@[ext] lemma ext {Ï‡â‚ Ï‡â‚‚ : Weight R L M} (h : âˆ€ x, Ï‡â‚ x = Ï‡â‚‚ x) : Ï‡â‚ = Ï‡â‚‚ := by\n  cases' Ï‡â‚ with fâ‚ _; cases' Ï‡â‚‚ with fâ‚‚ _; aesop\n\n"}
{"name":"LieModule.Weight.ext","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nÏ‡â‚ Ï‡â‚‚ : LieModule.Weight R L M\nh : âˆ€ (x : L), Eq (Ï‡â‚ x) (Ï‡â‚‚ x)\nâŠ¢ Eq Ï‡â‚ Ï‡â‚‚","decl":"@[ext] lemma ext {Ï‡â‚ Ï‡â‚‚ : Weight R L M} (h : âˆ€ x, Ï‡â‚ x = Ï‡â‚‚ x) : Ï‡â‚ = Ï‡â‚‚ := by\n  cases' Ï‡â‚ with fâ‚ _; cases' Ï‡â‚‚ with fâ‚‚ _; aesop\n\n"}
{"name":"LieModule.Weight.ext_iff'","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nÏ‡â‚ Ï‡â‚‚ : LieModule.Weight R L M\nâŠ¢ Iff (Eq â‡‘Ï‡â‚ â‡‘Ï‡â‚‚) (Eq Ï‡â‚ Ï‡â‚‚)","decl":"lemma ext_iff' {Ï‡â‚ Ï‡â‚‚ : Weight R L M} : (Ï‡â‚ : L â†’ R) = Ï‡â‚‚ â†” Ï‡â‚ = Ï‡â‚‚ := by simp\n\n"}
{"name":"LieModule.Weight.exists_ne_zero","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nÏ‡ : LieModule.Weight R L M\nâŠ¢ Exists fun x => And (Membership.mem (LieModule.genWeightSpace M â‡‘Ï‡) x) (Ne x 0)","decl":"lemma exists_ne_zero (Ï‡ : Weight R L M) :\n    âˆƒ x âˆˆ genWeightSpace M Ï‡, x â‰  0 := by\n  simpa [LieSubmodule.eq_bot_iff] using Ï‡.genWeightSpace_ne_bot\n\n"}
{"name":"LieModule.Weight.instIsEmptyOfSubsingleton","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : Subsingleton M\nâŠ¢ IsEmpty (LieModule.Weight R L M)","decl":"instance [Subsingleton M] : IsEmpty (Weight R L M) :=\n  âŸ¨fun h â†¦ h.2 (Subsingleton.elim _ _)âŸ©\n\n"}
{"name":"LieModule.Weight.coe_zero","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : Nontrivial (Subtype fun x => Membership.mem (LieModule.genWeightSpace M 0) x)\nâŠ¢ Eq (â‡‘0) 0","decl":"@[simp]\nlemma coe_zero [Nontrivial (genWeightSpace M (0 : L â†’ R))] : ((0 : Weight R L M) : L â†’ R) = 0 := rfl\n\n"}
{"name":"LieModule.Weight.zero_apply","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : Nontrivial (Subtype fun x => Membership.mem (LieModule.genWeightSpace M 0) x)\nx : L\nâŠ¢ Eq (0 x) 0","decl":"lemma zero_apply [Nontrivial (genWeightSpace M (0 : L â†’ R))] (x) : (0 : Weight R L M) x = 0 := rfl\n\n"}
{"name":"LieModule.Weight.IsZero.eq","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nÏ‡ : LieModule.Weight R L M\nhÏ‡ : Ï‡.IsZero\nâŠ¢ Eq (â‡‘Ï‡) 0","decl":"@[simp] lemma IsZero.eq {Ï‡ : Weight R L M} (hÏ‡ : Ï‡.IsZero) : (Ï‡ : L â†’ R) = 0 := hÏ‡\n\n"}
{"name":"LieModule.Weight.coe_eq_zero_iff","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nÏ‡ : LieModule.Weight R L M\nâŠ¢ Iff (Eq (â‡‘Ï‡) 0) Ï‡.IsZero","decl":"@[simp] lemma coe_eq_zero_iff (Ï‡ : Weight R L M) : (Ï‡ : L â†’ R) = 0 â†” Ï‡.IsZero := Iff.rfl\n\n"}
{"name":"LieModule.Weight.isZero_iff_eq_zero","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : Nontrivial (Subtype fun x => Membership.mem (LieModule.genWeightSpace M 0) x)\nÏ‡ : LieModule.Weight R L M\nâŠ¢ Iff Ï‡.IsZero (Eq Ï‡ 0)","decl":"lemma isZero_iff_eq_zero [Nontrivial (genWeightSpace M (0 : L â†’ R))] {Ï‡ : Weight R L M} :\n    Ï‡.IsZero â†” Ï‡ = 0 := Weight.ext_iff' (Ï‡â‚‚ := 0)\n\n"}
{"name":"LieModule.Weight.isZero_zero","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : Nontrivial (Subtype fun x => Membership.mem (LieModule.genWeightSpace M 0) x)\nâŠ¢ LieModule.Weight.IsZero 0","decl":"lemma isZero_zero [Nontrivial (genWeightSpace M (0 : L â†’ R))] : IsZero (0 : Weight R L M) := rfl\n\n"}
{"name":"LieModule.Weight.isNonZero_iff_ne_zero","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : Nontrivial (Subtype fun x => Membership.mem (LieModule.genWeightSpace M 0) x)\nÏ‡ : LieModule.Weight R L M\nâŠ¢ Iff Ï‡.IsNonZero (Ne Ï‡ 0)","decl":"lemma isNonZero_iff_ne_zero [Nontrivial (genWeightSpace M (0 : L â†’ R))] {Ï‡ : Weight R L M} :\n    Ï‡.IsNonZero â†” Ï‡ â‰  0 := isZero_iff_eq_zero.not\n\n"}
{"name":"LieModule.Weight.genWeightSpaceOf_ne_bot","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nÏ‡ : LieModule.Weight R L M\nx : L\nâŠ¢ Ne (LieModule.genWeightSpaceOf M (Ï‡ x) x) Bot.bot","decl":"lemma genWeightSpaceOf_ne_bot (Ï‡ : Weight R L M) (x : L) :\n    genWeightSpaceOf M (Ï‡ x) x â‰  âŠ¥ := by\n  have : â¨… x, genWeightSpaceOf M (Ï‡ x) x â‰  âŠ¥ := Ï‡.genWeightSpace_ne_bot\n  contrapose! this\n  rw [eq_bot_iff]\n  exact le_of_le_of_eq (iInf_le _ _) this\n\n"}
{"name":"LieModule.Weight.hasEigenvalueAt","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nÏ‡ : LieModule.Weight R L M\nx : L\nâŠ¢ ((LieModule.toEnd R L M) x).HasEigenvalue (Ï‡ x)","decl":"lemma hasEigenvalueAt (Ï‡ : Weight R L M) (x : L) :\n    (toEnd R L M x).HasEigenvalue (Ï‡ x) := by\n  obtain âŸ¨k : â„•, hk : (toEnd R L M x).genEigenspace (Ï‡ x) k â‰  âŠ¥âŸ© := by\n    simpa [genWeightSpaceOf, â† Module.End.iSup_genEigenspace_eq] using Ï‡.genWeightSpaceOf_ne_bot x\n  exact Module.End.hasEigenvalue_of_hasGenEigenvalue hk\n\n"}
{"name":"LieModule.Weight.apply_eq_zero_of_isNilpotent","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¹ : CommRing R\ninstâœâ¸ : LieRing L\ninstâœâ· : LieAlgebra R L\ninstâœâ¶ : AddCommGroup M\ninstâœâµ : Module R M\ninstâœâ´ : LieRingModule L M\ninstâœÂ³ : LieModule R L M\ninstâœÂ² : LieRing.IsNilpotent L\ninstâœÂ¹ : NoZeroSMulDivisors R M\ninstâœ : IsReduced R\nx : L\nh : IsNilpotent ((LieModule.toEnd R L M) x)\nÏ‡ : LieModule.Weight R L M\nâŠ¢ Eq (Ï‡ x) 0","decl":"lemma apply_eq_zero_of_isNilpotent [NoZeroSMulDivisors R M] [IsReduced R]\n    (x : L) (h : _root_.IsNilpotent (toEnd R L M x)) (Ï‡ : Weight R L M) :\n    Ï‡ x = 0 :=\n  ((Ï‡.hasEigenvalueAt x).isNilpotent_of_isNilpotent h).eq_zero\n\n"}
{"name":"LieModule.zero_genWeightSpace_eq_top_of_nilpotent'","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : LieModule.IsNilpotent L M\nâŠ¢ Eq (LieModule.genWeightSpace M 0) Top.top","decl":"/-- See also the more useful form `LieModule.zero_genWeightSpace_eq_top_of_nilpotent`. -/\n@[simp]\ntheorem zero_genWeightSpace_eq_top_of_nilpotent' [IsNilpotent L M] :\n    genWeightSpace M (0 : L â†’ R) = âŠ¤ := by\n  ext\n  simp [genWeightSpace, genWeightSpaceOf]\n\n"}
{"name":"LieModule.coe_genWeightSpace_of_top","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nÏ‡ : L â†’ R\nâŠ¢ Eq â†‘(LieModule.genWeightSpace M (Function.comp Ï‡ â‡‘Top.top.incl)) â†‘(LieModule.genWeightSpace M Ï‡)","decl":"theorem coe_genWeightSpace_of_top (Ï‡ : L â†’ R) :\n    (genWeightSpace M (Ï‡ âˆ˜ (âŠ¤ : LieSubalgebra R L).incl) : Submodule R M) = genWeightSpace M Ï‡ := by\n  ext m\n  simp only [mem_genWeightSpace, LieSubmodule.mem_toSubmodule, Subtype.forall]\n  apply forall_congr'\n  simp\n\n"}
{"name":"LieModule.zero_genWeightSpace_eq_top_of_nilpotent","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : LieModule.IsNilpotent L M\nâŠ¢ Eq (LieModule.genWeightSpace M 0) Top.top","decl":"@[simp]\ntheorem zero_genWeightSpace_eq_top_of_nilpotent [IsNilpotent L M] :\n    genWeightSpace M (0 : (âŠ¤ : LieSubalgebra R L) â†’ R) = âŠ¤ := by\n  ext m\n  simp only [mem_genWeightSpace, Pi.zero_apply, zero_smul, sub_zero, Subtype.forall,\n    forall_true_left, LieSubalgebra.toEnd_mk, LieSubalgebra.mem_top, LieSubmodule.mem_top, iff_true]\n  intro x\n  obtain âŸ¨k, hkâŸ© := exists_forall_pow_toEnd_eq_zero R L M\n  exact âŸ¨k, by simp [hk x]âŸ©\n\n"}
{"name":"LieModule.exists_genWeightSpace_le_ker_of_isNoetherian","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : IsNoetherian R M\nÏ‡ : L â†’ R\nx : L\nâŠ¢ Exists fun k => LE.le (â†‘(LieModule.genWeightSpace M Ï‡)) (LinearMap.ker (HPow.hPow (HSub.hSub ((LieModule.toEnd R L M) x) ((algebraMap R (Module.End R M)) (Ï‡ x))) k))","decl":"theorem exists_genWeightSpace_le_ker_of_isNoetherian [IsNoetherian R M] (Ï‡ : L â†’ R) (x : L) :\n    âˆƒ k : â„•,\n      genWeightSpace M Ï‡ â‰¤ LinearMap.ker ((toEnd R L M x - algebraMap R _ (Ï‡ x)) ^ k) := by\n  use (toEnd R L M x).maxGenEigenspaceIndex (Ï‡ x)\n  intro m hm\n  replace hm : m âˆˆ (toEnd R L M x).maxGenEigenspace (Ï‡ x) :=\n    genWeightSpace_le_genWeightSpaceOf M x Ï‡ hm\n  rwa [Module.End.maxGenEigenspace_eq, Module.End.genEigenspace_nat] at hm\n\n"}
{"name":"LieModule.exists_genWeightSpace_zero_le_ker_of_isNoetherian","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : IsNoetherian R M\nx : L\nâŠ¢ Exists fun k => LE.le (â†‘(LieModule.genWeightSpace M 0)) (LinearMap.ker (HPow.hPow ((LieModule.toEnd R L M) x) k))","decl":"variable (R) in\ntheorem exists_genWeightSpace_zero_le_ker_of_isNoetherian\n    [IsNoetherian R M] (x : L) :\n    âˆƒ k : â„•, genWeightSpace M (0 : L â†’ R) â‰¤ LinearMap.ker (toEnd R L M x ^ k) := by\n  simpa using exists_genWeightSpace_le_ker_of_isNoetherian M (0 : L â†’ R) x\n\n"}
{"name":"LieModule.isNilpotent_toEnd_sub_algebraMap","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : IsNoetherian R M\nÏ‡ : L â†’ R\nx : L\nâŠ¢ IsNilpotent (HSub.hSub ((LieModule.toEnd R L (Subtype fun x => Membership.mem (LieModule.genWeightSpace M Ï‡) x)) x) ((algebraMap R (Module.End R (Subtype fun x => Membership.mem (LieModule.genWeightSpace M Ï‡) x))) (Ï‡ x)))","decl":"lemma isNilpotent_toEnd_sub_algebraMap [IsNoetherian R M] (Ï‡ : L â†’ R) (x : L) :\n    _root_.IsNilpotent <| toEnd R L (genWeightSpace M Ï‡) x - algebraMap R _ (Ï‡ x) := by\n  have : toEnd R L (genWeightSpace M Ï‡) x - algebraMap R _ (Ï‡ x) =\n      (toEnd R L M x - algebraMap R _ (Ï‡ x)).restrict\n        (fun m hm â†¦ sub_mem (LieSubmodule.lie_mem _ hm) (Submodule.smul_mem _ _ hm)) := by\n    rfl\n  obtain âŸ¨k, hkâŸ© := exists_genWeightSpace_le_ker_of_isNoetherian M Ï‡ x\n  use k\n  ext âŸ¨m, hmâŸ©\n  simp only [this, LinearMap.pow_restrict _, LinearMap.zero_apply, ZeroMemClass.coe_zero,\n    ZeroMemClass.coe_eq_zero]\n  exact ZeroMemClass.coe_eq_zero.mp (hk hm)\n\n"}
{"name":"LieModule.isNilpotent_toEnd_genWeightSpace_zero","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : IsNoetherian R M\nx : L\nâŠ¢ IsNilpotent ((LieModule.toEnd R L (Subtype fun x => Membership.mem (LieModule.genWeightSpace M 0) x)) x)","decl":"/-- A (nilpotent) Lie algebra acts nilpotently on the zero weight space of a Noetherian Lie\nmodule. -/\ntheorem isNilpotent_toEnd_genWeightSpace_zero [IsNoetherian R M] (x : L) :\n    _root_.IsNilpotent <| toEnd R L (genWeightSpace M (0 : L â†’ R)) x := by\n  simpa using isNilpotent_toEnd_sub_algebraMap M (0 : L â†’ R) x\n\n"}
{"name":"LieModule.instIsNilpotentSubtypeMemLieSubmoduleGenWeightSpaceOfNatForallOfIsNoetherian","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : IsNoetherian R M\nâŠ¢ LieModule.IsNilpotent L (Subtype fun x => Membership.mem (LieModule.genWeightSpace M 0) x)","decl":"/-- By Engel's theorem, the zero weight space of a Noetherian Lie module is nilpotent. -/\ninstance [IsNoetherian R M] :\n    IsNilpotent L (genWeightSpace M (0 : L â†’ R)) :=\n  isNilpotent_iff_forall'.mpr <| isNilpotent_toEnd_genWeightSpace_zero M\n\n"}
{"name":"LieModule.genWeightSpace_zero_normalizer_eq_self","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nâŠ¢ Eq (LieModule.genWeightSpace M 0).normalizer (LieModule.genWeightSpace M 0)","decl":"@[simp]\nlemma genWeightSpace_zero_normalizer_eq_self :\n    (genWeightSpace M (0 : L â†’ R)).normalizer = genWeightSpace M 0 := by\n  refine le_antisymm ?_ (LieSubmodule.le_normalizer _)\n  intro m hm\n  rw [LieSubmodule.mem_normalizer] at hm\n  simp only [mem_genWeightSpace, Pi.zero_apply, zero_smul, sub_zero] at hm âŠ¢\n  intro y\n  obtain âŸ¨k, hkâŸ© := hm y y\n  use k + 1\n  simpa [pow_succ, LinearMap.mul_eq_comp]\n\n"}
{"name":"LieModule.iSup_ucs_le_genWeightSpace_zero","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nâŠ¢ LE.le (iSup fun k => LieSubmodule.ucs k Bot.bot) (LieModule.genWeightSpace M 0)","decl":"lemma iSup_ucs_le_genWeightSpace_zero :\n    â¨† k, (âŠ¥ : LieSubmodule R L M).ucs k â‰¤ genWeightSpace M (0 : L â†’ R) := by\n  simpa using\n    LieSubmodule.ucs_le_of_normalizer_eq_self (genWeightSpace_zero_normalizer_eq_self R L M)\n\n"}
{"name":"LieModule.iSup_ucs_eq_genWeightSpace_zero","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : IsNoetherian R M\nâŠ¢ Eq (iSup fun k => LieSubmodule.ucs k Bot.bot) (LieModule.genWeightSpace M 0)","decl":"/-- See also `LieModule.iInf_lowerCentralSeries_eq_posFittingComp`. -/\nlemma iSup_ucs_eq_genWeightSpace_zero [IsNoetherian R M] :\n    â¨† k, (âŠ¥ : LieSubmodule R L M).ucs k = genWeightSpace M (0 : L â†’ R) := by\n  obtain âŸ¨k, hkâŸ© := (LieSubmodule.isNilpotent_iff_exists_self_le_ucs\n    <| genWeightSpace M (0 : L â†’ R)).mp inferInstance\n  refine le_antisymm (iSup_ucs_le_genWeightSpace_zero R L M) (le_trans hk ?_)\n  exact le_iSup (fun k â†¦ (âŠ¥ : LieSubmodule R L M).ucs k) k\n\n"}
{"name":"LieModule.mem_posFittingCompOf","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nx : L\nm : M\nâŠ¢ Iff (Membership.mem (LieModule.posFittingCompOf R M x) m) (âˆ€ (k : Nat), Exists fun n => Eq ((HPow.hPow ((LieModule.toEnd R L M) x) k) n) m)","decl":"variable {M} in\nlemma mem_posFittingCompOf (x : L) (m : M) :\n    m âˆˆ posFittingCompOf R M x â†” âˆ€ (k : â„•), âˆƒ n, (toEnd R L M x ^ k) n = m := by\n  simp [posFittingCompOf]\n\n"}
{"name":"LieModule.posFittingCompOf_le_lowerCentralSeries","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nx : L\nk : Nat\nâŠ¢ LE.le (LieModule.posFittingCompOf R M x) (LieModule.lowerCentralSeries R L M k)","decl":"@[simp] lemma posFittingCompOf_le_lowerCentralSeries (x : L) (k : â„•) :\n    posFittingCompOf R M x â‰¤ lowerCentralSeries R L M k := by\n  suffices âˆ€ m l, (toEnd R L M x ^ l) m âˆˆ lowerCentralSeries R L M l by\n    intro m hm\n    obtain âŸ¨n, rflâŸ© := (mem_posFittingCompOf R x m).mp hm k\n    exact this n k\n  intro m l\n  induction l with\n  | zero => simp\n  | succ l ih =>\n    simp only [lowerCentralSeries_succ, pow_succ', LinearMap.mul_apply]\n    exact LieSubmodule.lie_mem_lie (LieSubmodule.mem_top x) ih\n\n"}
{"name":"LieModule.posFittingCompOf_eq_bot_of_isNilpotent","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : LieModule.IsNilpotent L M\nx : L\nâŠ¢ Eq (LieModule.posFittingCompOf R M x) Bot.bot","decl":"@[simp] lemma posFittingCompOf_eq_bot_of_isNilpotent\n    [IsNilpotent L M] (x : L) :\n    posFittingCompOf R M x = âŠ¥ := by\n  simp_rw [eq_bot_iff, â† iInf_lowerCentralSeries_eq_bot_of_isNilpotent, le_iInf_iff,\n    posFittingCompOf_le_lowerCentralSeries, forall_const]\n\n"}
{"name":"LieModule.mem_posFittingComp","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nm : M\nâŠ¢ Iff (Membership.mem (LieModule.posFittingComp R L M) m) (Membership.mem (iSup fun x => LieModule.posFittingCompOf R M x) m)","decl":"lemma mem_posFittingComp (m : M) :\n    m âˆˆ posFittingComp R L M â†” m âˆˆ â¨† (x : L), posFittingCompOf R M x := by\n  rfl\n\n"}
{"name":"LieModule.posFittingCompOf_le_posFittingComp","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nx : L\nâŠ¢ LE.le (LieModule.posFittingCompOf R M x) (LieModule.posFittingComp R L M)","decl":"lemma posFittingCompOf_le_posFittingComp (x : L) :\n    posFittingCompOf R M x â‰¤ posFittingComp R L M := by\n  rw [posFittingComp]; exact le_iSup (posFittingCompOf R M) x\n\n"}
{"name":"LieModule.posFittingComp_le_iInf_lowerCentralSeries","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nâŠ¢ LE.le (LieModule.posFittingComp R L M) (iInf fun k => LieModule.lowerCentralSeries R L M k)","decl":"lemma posFittingComp_le_iInf_lowerCentralSeries :\n    posFittingComp R L M â‰¤ â¨… k, lowerCentralSeries R L M k := by\n  simp [posFittingComp]\n\n"}
{"name":"LieModule.iInf_lowerCentralSeries_eq_posFittingComp","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¹ : CommRing R\ninstâœâ¸ : LieRing L\ninstâœâ· : LieAlgebra R L\ninstâœâ¶ : AddCommGroup M\ninstâœâµ : Module R M\ninstâœâ´ : LieRingModule L M\ninstâœÂ³ : LieModule R L M\ninstâœÂ² : LieRing.IsNilpotent L\ninstâœÂ¹ : IsNoetherian R M\ninstâœ : IsArtinian R M\nâŠ¢ Eq (iInf fun k => LieModule.lowerCentralSeries R L M k) (LieModule.posFittingComp R L M)","decl":"/-- See also `LieModule.iSup_ucs_eq_genWeightSpace_zero`. -/\n@[simp] lemma iInf_lowerCentralSeries_eq_posFittingComp\n    [IsNoetherian R M] [IsArtinian R M] :\n    â¨… k, lowerCentralSeries R L M k = posFittingComp R L M := by\n  refine le_antisymm ?_ (posFittingComp_le_iInf_lowerCentralSeries R L M)\n  apply iInf_lcs_le_of_isNilpotent_quot\n  rw [LieModule.isNilpotent_iff_forall' (R := R)]\n  intro x\n  obtain âŸ¨k, hkâŸ© := Filter.eventually_atTop.mp (toEnd R L M x).eventually_iInf_range_pow_eq\n  use k\n  ext âŸ¨mâŸ©\n  set F := posFittingComp R L M\n  replace hk : (toEnd R L M x ^ k) m âˆˆ F := by\n    apply posFittingCompOf_le_posFittingComp R L M x\n    simp_rw [â† LieSubmodule.mem_toSubmodule, posFittingCompOf, hk k (le_refl k)]\n    apply LinearMap.mem_range_self\n  suffices (toEnd R L (M â§¸ F) x ^ k) (LieSubmodule.Quotient.mk (N := F) m) =\n    LieSubmodule.Quotient.mk (N := F) ((toEnd R L M x ^ k) m)\n      by simpa [Submodule.Quotient.quot_mk_eq_mk, this]\n  have := LinearMap.congr_fun (LinearMap.commute_pow_left_of_commute\n    (LieSubmodule.Quotient.toEnd_comp_mk' F x) k) m\n  simpa using this\n\n"}
{"name":"LieModule.posFittingComp_eq_bot_of_isNilpotent","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : LieModule.IsNilpotent L M\nâŠ¢ Eq (LieModule.posFittingComp R L M) Bot.bot","decl":"@[simp] lemma posFittingComp_eq_bot_of_isNilpotent\n    [IsNilpotent L M] :\n    posFittingComp R L M = âŠ¥ := by\n  simp [posFittingComp]\n\n"}
{"name":"LieModule.map_posFittingComp_le","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœÂ¹Â¹ : CommRing R\ninstâœÂ¹â° : LieRing L\ninstâœâ¹ : LieAlgebra R L\ninstâœâ¸ : AddCommGroup M\ninstâœâ· : Module R M\ninstâœâ¶ : LieRingModule L M\ninstâœâµ : LieModule R L M\ninstâœâ´ : LieRing.IsNilpotent L\nMâ‚‚ : Type u_5\ninstâœÂ³ : AddCommGroup Mâ‚‚\ninstâœÂ² : Module R Mâ‚‚\ninstâœÂ¹ : LieRingModule L Mâ‚‚\ninstâœ : LieModule R L Mâ‚‚\nf : LieModuleHom R L M Mâ‚‚\nâŠ¢ LE.le (LieSubmodule.map f (LieModule.posFittingComp R L M)) (LieModule.posFittingComp R L Mâ‚‚)","decl":"lemma map_posFittingComp_le :\n    (posFittingComp R L M).map f â‰¤ posFittingComp R L Mâ‚‚ := by\n  rw [posFittingComp, posFittingComp, LieSubmodule.map_iSup]\n  refine iSup_mono fun y â†¦ LieSubmodule.map_le_iff_le_comap.mpr fun m hm â†¦ ?_\n  simp only [mem_posFittingCompOf] at hm\n  simp only [LieSubmodule.mem_comap, mem_posFittingCompOf]\n  intro k\n  obtain âŸ¨n, hnâŸ© := hm k\n  use f n\n  rw [LieModule.toEnd_pow_apply_map, hn]\n\n"}
{"name":"LieModule.map_genWeightSpace_le","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœÂ¹Â¹ : CommRing R\ninstâœÂ¹â° : LieRing L\ninstâœâ¹ : LieAlgebra R L\ninstâœâ¸ : AddCommGroup M\ninstâœâ· : Module R M\ninstâœâ¶ : LieRingModule L M\ninstâœâµ : LieModule R L M\ninstâœâ´ : LieRing.IsNilpotent L\nMâ‚‚ : Type u_5\ninstâœÂ³ : AddCommGroup Mâ‚‚\ninstâœÂ² : Module R Mâ‚‚\ninstâœÂ¹ : LieRingModule L Mâ‚‚\ninstâœ : LieModule R L Mâ‚‚\nÏ‡ : L â†’ R\nf : LieModuleHom R L M Mâ‚‚\nâŠ¢ LE.le (LieSubmodule.map f (LieModule.genWeightSpace M Ï‡)) (LieModule.genWeightSpace Mâ‚‚ Ï‡)","decl":"lemma map_genWeightSpace_le :\n    (genWeightSpace M Ï‡).map f â‰¤ genWeightSpace Mâ‚‚ Ï‡ := by\n  rw [LieSubmodule.map_le_iff_le_comap]\n  intro m hm\n  simp only [LieSubmodule.mem_comap, mem_genWeightSpace]\n  intro x\n  have : (toEnd R L Mâ‚‚ x - Ï‡ x â€¢ â†‘1) âˆ˜â‚— f = f âˆ˜â‚— (toEnd R L M x - Ï‡ x â€¢ â†‘1) := by\n    ext; simp\n  obtain âŸ¨k, hâŸ© := (mem_genWeightSpace _ _ _).mp hm x\n  exact âŸ¨k, by simpa [h] using LinearMap.congr_fun (LinearMap.commute_pow_left_of_commute this k) mâŸ©\n\n"}
{"name":"LieModule.comap_genWeightSpace_eq_of_injective","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœÂ¹Â¹ : CommRing R\ninstâœÂ¹â° : LieRing L\ninstâœâ¹ : LieAlgebra R L\ninstâœâ¸ : AddCommGroup M\ninstâœâ· : Module R M\ninstâœâ¶ : LieRingModule L M\ninstâœâµ : LieModule R L M\ninstâœâ´ : LieRing.IsNilpotent L\nMâ‚‚ : Type u_5\ninstâœÂ³ : AddCommGroup Mâ‚‚\ninstâœÂ² : Module R Mâ‚‚\ninstâœÂ¹ : LieRingModule L Mâ‚‚\ninstâœ : LieModule R L Mâ‚‚\nÏ‡ : L â†’ R\nf : LieModuleHom R L M Mâ‚‚\nhf : Function.Injective â‡‘f\nâŠ¢ Eq (LieSubmodule.comap f (LieModule.genWeightSpace Mâ‚‚ Ï‡)) (LieModule.genWeightSpace M Ï‡)","decl":"lemma comap_genWeightSpace_eq_of_injective (hf : Injective f) :\n    (genWeightSpace Mâ‚‚ Ï‡).comap f = genWeightSpace M Ï‡ := by\n  refine le_antisymm (fun m hm â†¦ ?_) ?_\n  Â· simp only [LieSubmodule.mem_comap, mem_genWeightSpace] at hm\n    simp only [mem_genWeightSpace]\n    intro x\n    have h : (toEnd R L Mâ‚‚ x - Ï‡ x â€¢ â†‘1) âˆ˜â‚— f =\n             f âˆ˜â‚— (toEnd R L M x - Ï‡ x â€¢ â†‘1) := by ext; simp\n    obtain âŸ¨k, hkâŸ© := hm x\n    use k\n    suffices f (((toEnd R L M x - Ï‡ x â€¢ â†‘1) ^ k) m) = 0 by\n      rw [â† f.map_zero] at this; exact hf this\n    simpa [hk] using (LinearMap.congr_fun (LinearMap.commute_pow_left_of_commute h k) m).symm\n  Â· rw [â† LieSubmodule.map_le_iff_le_comap]\n    exact map_genWeightSpace_le f\n\n"}
{"name":"LieModule.map_genWeightSpace_eq_of_injective","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœÂ¹Â¹ : CommRing R\ninstâœÂ¹â° : LieRing L\ninstâœâ¹ : LieAlgebra R L\ninstâœâ¸ : AddCommGroup M\ninstâœâ· : Module R M\ninstâœâ¶ : LieRingModule L M\ninstâœâµ : LieModule R L M\ninstâœâ´ : LieRing.IsNilpotent L\nMâ‚‚ : Type u_5\ninstâœÂ³ : AddCommGroup Mâ‚‚\ninstâœÂ² : Module R Mâ‚‚\ninstâœÂ¹ : LieRingModule L Mâ‚‚\ninstâœ : LieModule R L Mâ‚‚\nÏ‡ : L â†’ R\nf : LieModuleHom R L M Mâ‚‚\nhf : Function.Injective â‡‘f\nâŠ¢ Eq (LieSubmodule.map f (LieModule.genWeightSpace M Ï‡)) (Min.min (LieModule.genWeightSpace Mâ‚‚ Ï‡) f.range)","decl":"lemma map_genWeightSpace_eq_of_injective (hf : Injective f) :\n    (genWeightSpace M Ï‡).map f = genWeightSpace Mâ‚‚ Ï‡ âŠ“ f.range := by\n  refine le_antisymm (le_inf_iff.mpr âŸ¨map_genWeightSpace_le f, LieSubmodule.map_le_range fâŸ©) ?_\n  rintro - âŸ¨hm, âŸ¨m, rflâŸ©âŸ©\n  simp only [â† comap_genWeightSpace_eq_of_injective hf, LieSubmodule.mem_map,\n    LieSubmodule.mem_comap]\n  exact âŸ¨m, hm, rflâŸ©\n\n"}
{"name":"LieModule.map_genWeightSpace_eq","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœÂ¹Â¹ : CommRing R\ninstâœÂ¹â° : LieRing L\ninstâœâ¹ : LieAlgebra R L\ninstâœâ¸ : AddCommGroup M\ninstâœâ· : Module R M\ninstâœâ¶ : LieRingModule L M\ninstâœâµ : LieModule R L M\ninstâœâ´ : LieRing.IsNilpotent L\nMâ‚‚ : Type u_5\ninstâœÂ³ : AddCommGroup Mâ‚‚\ninstâœÂ² : Module R Mâ‚‚\ninstâœÂ¹ : LieRingModule L Mâ‚‚\ninstâœ : LieModule R L Mâ‚‚\nÏ‡ : L â†’ R\ne : LieModuleEquiv R L M Mâ‚‚\nâŠ¢ Eq (LieSubmodule.map e.toLieModuleHom (LieModule.genWeightSpace M Ï‡)) (LieModule.genWeightSpace Mâ‚‚ Ï‡)","decl":"lemma map_genWeightSpace_eq (e : M â‰ƒâ‚—â…R,Lâ† Mâ‚‚) :\n    (genWeightSpace M Ï‡).map e = genWeightSpace Mâ‚‚ Ï‡ := by\n  simp [map_genWeightSpace_eq_of_injective e.injective]\n\n"}
{"name":"LieModule.map_posFittingComp_eq","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœÂ¹Â¹ : CommRing R\ninstâœÂ¹â° : LieRing L\ninstâœâ¹ : LieAlgebra R L\ninstâœâ¸ : AddCommGroup M\ninstâœâ· : Module R M\ninstâœâ¶ : LieRingModule L M\ninstâœâµ : LieModule R L M\ninstâœâ´ : LieRing.IsNilpotent L\nMâ‚‚ : Type u_5\ninstâœÂ³ : AddCommGroup Mâ‚‚\ninstâœÂ² : Module R Mâ‚‚\ninstâœÂ¹ : LieRingModule L Mâ‚‚\ninstâœ : LieModule R L Mâ‚‚\ne : LieModuleEquiv R L M Mâ‚‚\nâŠ¢ Eq (LieSubmodule.map e.toLieModuleHom (LieModule.posFittingComp R L M)) (LieModule.posFittingComp R L Mâ‚‚)","decl":"lemma map_posFittingComp_eq (e : M â‰ƒâ‚—â…R,Lâ† Mâ‚‚) :\n    (posFittingComp R L M).map e = posFittingComp R L Mâ‚‚ := by\n  refine le_antisymm (map_posFittingComp_le _) ?_\n  suffices posFittingComp R L Mâ‚‚ = ((posFittingComp R L Mâ‚‚).map (e.symm : Mâ‚‚ â†’â‚—â…R,Lâ† M)).map e by\n    rw [this]\n    exact LieSubmodule.map_mono (map_posFittingComp_le _)\n  rw [â† LieSubmodule.map_comp]\n  convert LieSubmodule.map_id\n  ext\n  simp\n\n"}
{"name":"LieModule.posFittingComp_map_incl_sup_of_codisjoint","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¹ : CommRing R\ninstâœâ¸ : LieRing L\ninstâœâ· : LieAlgebra R L\ninstâœâ¶ : AddCommGroup M\ninstâœâµ : Module R M\ninstâœâ´ : LieRingModule L M\ninstâœÂ³ : LieModule R L M\ninstâœÂ² : LieRing.IsNilpotent L\ninstâœÂ¹ : IsNoetherian R M\ninstâœ : IsArtinian R M\nNâ‚ Nâ‚‚ : LieSubmodule R L M\nh : Codisjoint Nâ‚ Nâ‚‚\nâŠ¢ Eq (Max.max (LieSubmodule.map Nâ‚.incl (LieModule.posFittingComp R L (Subtype fun x => Membership.mem Nâ‚ x))) (LieSubmodule.map Nâ‚‚.incl (LieModule.posFittingComp R L (Subtype fun x => Membership.mem Nâ‚‚ x)))) (LieModule.posFittingComp R L M)","decl":"lemma posFittingComp_map_incl_sup_of_codisjoint [IsNoetherian R M] [IsArtinian R M]\n    {Nâ‚ Nâ‚‚ : LieSubmodule R L M} (h : Codisjoint Nâ‚ Nâ‚‚) :\n    (posFittingComp R L Nâ‚).map Nâ‚.incl âŠ” (posFittingComp R L Nâ‚‚).map Nâ‚‚.incl =\n    posFittingComp R L M := by\n  obtain âŸ¨l, hlâŸ© := Filter.eventually_atTop.mp <|\n    (eventually_iInf_lowerCentralSeries_eq R L Nâ‚).and <|\n    (eventually_iInf_lowerCentralSeries_eq R L Nâ‚‚).and\n    (eventually_iInf_lowerCentralSeries_eq R L M)\n  obtain âŸ¨hlâ‚, hlâ‚‚, hlâ‚ƒâŸ© := hl l (le_refl _)\n  simp_rw [â† iInf_lowerCentralSeries_eq_posFittingComp, hlâ‚, hlâ‚‚, hlâ‚ƒ,\n    LieSubmodule.lowerCentralSeries_map_eq_lcs, â† LieSubmodule.lcs_sup, lowerCentralSeries,\n    h.eq_top]\n\n"}
{"name":"LieModule.genWeightSpace_genWeightSpaceOf_map_incl","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieRing.IsNilpotent L\nx : L\nÏ‡ : L â†’ R\nâŠ¢ Eq (LieSubmodule.map (LieModule.genWeightSpaceOf M (Ï‡ x) x).incl (LieModule.genWeightSpace (Subtype fun x_1 => Membership.mem (LieModule.genWeightSpaceOf M (Ï‡ x) x) x_1) Ï‡)) (LieModule.genWeightSpace M Ï‡)","decl":"lemma genWeightSpace_genWeightSpaceOf_map_incl (x : L) (Ï‡ : L â†’ R) :\n    (genWeightSpace (genWeightSpaceOf M (Ï‡ x) x) Ï‡).map (genWeightSpaceOf M (Ï‡ x) x).incl =\n    genWeightSpace M Ï‡ := by\n  simpa [map_genWeightSpace_eq_of_injective (genWeightSpaceOf M (Ï‡ x) x).injective_incl]\n    using genWeightSpace_le_genWeightSpaceOf M x Ï‡\n\n"}
{"name":"LieModule.isCompl_genWeightSpaceOf_zero_posFittingCompOf","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¹ : CommRing R\ninstâœâ¸ : LieRing L\ninstâœâ· : LieAlgebra R L\ninstâœâ¶ : AddCommGroup M\ninstâœâµ : Module R M\ninstâœâ´ : LieRingModule L M\ninstâœÂ³ : LieModule R L M\ninstâœÂ² : LieRing.IsNilpotent L\ninstâœÂ¹ : IsNoetherian R M\ninstâœ : IsArtinian R M\nx : L\nâŠ¢ IsCompl (LieModule.genWeightSpaceOf M 0 x) (LieModule.posFittingCompOf R M x)","decl":"lemma isCompl_genWeightSpaceOf_zero_posFittingCompOf (x : L) :\n    IsCompl (genWeightSpaceOf M 0 x) (posFittingCompOf R M x) := by\n  simpa only [isCompl_iff, codisjoint_iff, disjoint_iff, â† LieSubmodule.toSubmodule_inj,\n    LieSubmodule.sup_toSubmodule, LieSubmodule.inf_toSubmodule,\n    LieSubmodule.top_toSubmodule, LieSubmodule.bot_toSubmodule, coe_genWeightSpaceOf_zero] using\n    (toEnd R L M x).isCompl_iSup_ker_pow_iInf_range_pow\n\n"}
{"name":"LieModule.isCompl_genWeightSpace_zero_posFittingComp","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¹ : CommRing R\ninstâœâ¸ : LieRing L\ninstâœâ· : LieAlgebra R L\ninstâœâ¶ : AddCommGroup M\ninstâœâµ : Module R M\ninstâœâ´ : LieRingModule L M\ninstâœÂ³ : LieModule R L M\ninstâœÂ² : LieRing.IsNilpotent L\ninstâœÂ¹ : IsNoetherian R M\ninstâœ : IsArtinian R M\nâŠ¢ IsCompl (LieModule.genWeightSpace M 0) (LieModule.posFittingComp R L M)","decl":"/-- This is the Fitting decomposition of the Lie module `M`. -/\nlemma isCompl_genWeightSpace_zero_posFittingComp :\n    IsCompl (genWeightSpace M 0) (posFittingComp R L M) := by\n  let P : LieSubmodule R L M â†’ Prop := fun N â†¦ IsCompl (genWeightSpace N 0) (posFittingComp R L N)\n  suffices P âŠ¤ by\n    let e := LieModuleEquiv.ofTop R L M\n    rw [â† map_genWeightSpace_eq e, â† map_posFittingComp_eq e]\n    exact (LieSubmodule.orderIsoMapComap e).isCompl_iff.mp this\n  refine (LieSubmodule.wellFoundedLT_of_isArtinian R L M).induction (C := P) _ fun N hN â†¦ ?_\n  refine isCompl_genWeightSpace_zero_posFittingComp_aux R L N fun N' hN' â†¦ ?_\n  suffices IsCompl (genWeightSpace (N'.map N.incl) 0) (posFittingComp R L (N'.map N.incl)) by\n    let e := LieSubmodule.equivMapOfInjective N' N.injective_incl\n    rw [â† map_genWeightSpace_eq e, â† map_posFittingComp_eq e] at this\n    exact (LieSubmodule.orderIsoMapComap e).isCompl_iff.mpr this\n  exact hN _ (LieSubmodule.map_incl_lt_iff_lt_top.mpr hN')\n\n"}
{"name":"LieModule.disjoint_genWeightSpaceOf","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : NoZeroSMulDivisors R M\nx : L\nÏ†â‚ Ï†â‚‚ : R\nh : Ne Ï†â‚ Ï†â‚‚\nâŠ¢ Disjoint (LieModule.genWeightSpaceOf M Ï†â‚ x) (LieModule.genWeightSpaceOf M Ï†â‚‚ x)","decl":"lemma disjoint_genWeightSpaceOf [NoZeroSMulDivisors R M] {x : L} {Ï†â‚ Ï†â‚‚ : R} (h : Ï†â‚ â‰  Ï†â‚‚) :\n    Disjoint (genWeightSpaceOf M Ï†â‚ x) (genWeightSpaceOf M Ï†â‚‚ x) := by\n  rw [LieSubmodule.disjoint_iff_toSubmodule]\n  dsimp [genWeightSpaceOf]\n  exact Module.End.disjoint_genEigenspace _ h _ _\n\n"}
{"name":"LieModule.disjoint_genWeightSpace","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : NoZeroSMulDivisors R M\nÏ‡â‚ Ï‡â‚‚ : L â†’ R\nh : Ne Ï‡â‚ Ï‡â‚‚\nâŠ¢ Disjoint (LieModule.genWeightSpace M Ï‡â‚) (LieModule.genWeightSpace M Ï‡â‚‚)","decl":"lemma disjoint_genWeightSpace [NoZeroSMulDivisors R M] {Ï‡â‚ Ï‡â‚‚ : L â†’ R} (h : Ï‡â‚ â‰  Ï‡â‚‚) :\n    Disjoint (genWeightSpace M Ï‡â‚) (genWeightSpace M Ï‡â‚‚) := by\n  obtain âŸ¨x, hxâŸ© : âˆƒ x, Ï‡â‚ x â‰  Ï‡â‚‚ x := Function.ne_iff.mp h\n  exact (disjoint_genWeightSpaceOf R L M hx).mono\n    (genWeightSpace_le_genWeightSpaceOf M x Ï‡â‚) (genWeightSpace_le_genWeightSpaceOf M x Ï‡â‚‚)\n\n"}
{"name":"LieModule.injOn_genWeightSpace","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : NoZeroSMulDivisors R M\nâŠ¢ Set.InjOn (fun Ï‡ => LieModule.genWeightSpace M Ï‡) (setOf fun Ï‡ => Ne (LieModule.genWeightSpace M Ï‡) Bot.bot)","decl":"lemma injOn_genWeightSpace [NoZeroSMulDivisors R M] :\n    InjOn (fun (Ï‡ : L â†’ R) â†¦ genWeightSpace M Ï‡) {Ï‡ | genWeightSpace M Ï‡ â‰  âŠ¥} := by\n  rintro Ï‡â‚ _ Ï‡â‚‚ hÏ‡â‚‚ (hÏ‡â‚â‚‚ : genWeightSpace M Ï‡â‚ = genWeightSpace M Ï‡â‚‚)\n  contrapose! hÏ‡â‚‚\n  simpa [hÏ‡â‚â‚‚] using disjoint_genWeightSpace R L M hÏ‡â‚‚\n\n"}
{"name":"LieModule.iSupIndep_genWeightSpace","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : NoZeroSMulDivisors R M\nâŠ¢ iSupIndep fun Ï‡ => LieModule.genWeightSpace M Ï‡","decl":"/-- Lie module weight spaces are independent.\n\nSee also `LieModule.iSupIndep_genWeightSpace'`. -/\nlemma iSupIndep_genWeightSpace [NoZeroSMulDivisors R M] :\n    iSupIndep fun Ï‡ : L â†’ R â†¦ genWeightSpace M Ï‡ := by\n  simp only [LieSubmodule.iSupIndep_iff_toSubmodule, genWeightSpace,\n    LieSubmodule.iInf_toSubmodule]\n  exact Module.End.independent_iInf_maxGenEigenspace_of_forall_mapsTo (toEnd R L M)\n    (fun x y Ï† z â†¦ (genWeightSpaceOf M Ï† y).lie_mem)\n\n"}
{"name":"LieModule.independent_genWeightSpace","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : NoZeroSMulDivisors R M\nâŠ¢ iSupIndep fun Ï‡ => LieModule.genWeightSpace M Ï‡","decl":"@[deprecated (since := \"2024-11-24\")] alias independent_genWeightSpace := iSupIndep_genWeightSpace\n\n"}
{"name":"LieModule.iSupIndep_genWeightSpace'","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : NoZeroSMulDivisors R M\nâŠ¢ iSupIndep fun Ï‡ => LieModule.genWeightSpace M â‡‘Ï‡","decl":"lemma iSupIndep_genWeightSpace' [NoZeroSMulDivisors R M] :\n    iSupIndep fun Ï‡ : Weight R L M â†¦ genWeightSpace M Ï‡ :=\n  (iSupIndep_genWeightSpace R L M).comp <|\n    Subtype.val_injective.comp (Weight.equivSetOf R L M).injective\n\n"}
{"name":"LieModule.independent_genWeightSpace'","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : NoZeroSMulDivisors R M\nâŠ¢ iSupIndep fun Ï‡ => LieModule.genWeightSpace M â‡‘Ï‡","decl":"@[deprecated (since := \"2024-11-24\")] alias independent_genWeightSpace' := iSupIndep_genWeightSpace'\n\n"}
{"name":"LieModule.iSupIndep_genWeightSpaceOf","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : NoZeroSMulDivisors R M\nx : L\nâŠ¢ iSupIndep fun Ï‡ => LieModule.genWeightSpaceOf M Ï‡ x","decl":"lemma iSupIndep_genWeightSpaceOf [NoZeroSMulDivisors R M] (x : L) :\n    iSupIndep fun (Ï‡ : R) â†¦ genWeightSpaceOf M Ï‡ x := by\n  rw [LieSubmodule.iSupIndep_iff_toSubmodule]\n  dsimp [genWeightSpaceOf]\n  exact (toEnd R L M x).independent_genEigenspace _\n\n"}
{"name":"LieModule.independent_genWeightSpaceOf","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : NoZeroSMulDivisors R M\nx : L\nâŠ¢ iSupIndep fun Ï‡ => LieModule.genWeightSpaceOf M Ï‡ x","decl":"@[deprecated (since := \"2024-11-24\")]\nalias independent_genWeightSpaceOf := iSupIndep_genWeightSpaceOf\n\n"}
{"name":"LieModule.finite_genWeightSpaceOf_ne_bot","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¹ : CommRing R\ninstâœâ¸ : LieRing L\ninstâœâ· : LieAlgebra R L\ninstâœâ¶ : AddCommGroup M\ninstâœâµ : Module R M\ninstâœâ´ : LieRingModule L M\ninstâœÂ³ : LieModule R L M\ninstâœÂ² : LieRing.IsNilpotent L\ninstâœÂ¹ : NoZeroSMulDivisors R M\ninstâœ : IsNoetherian R M\nx : L\nâŠ¢ (setOf fun Ï‡ => Ne (LieModule.genWeightSpaceOf M Ï‡ x) Bot.bot).Finite","decl":"lemma finite_genWeightSpaceOf_ne_bot [NoZeroSMulDivisors R M] [IsNoetherian R M] (x : L) :\n    {Ï‡ : R | genWeightSpaceOf M Ï‡ x â‰  âŠ¥}.Finite :=\n  WellFoundedGT.finite_ne_bot_of_iSupIndep (iSupIndep_genWeightSpaceOf R L M x)\n\n"}
{"name":"LieModule.finite_genWeightSpace_ne_bot","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¹ : CommRing R\ninstâœâ¸ : LieRing L\ninstâœâ· : LieAlgebra R L\ninstâœâ¶ : AddCommGroup M\ninstâœâµ : Module R M\ninstâœâ´ : LieRingModule L M\ninstâœÂ³ : LieModule R L M\ninstâœÂ² : LieRing.IsNilpotent L\ninstâœÂ¹ : NoZeroSMulDivisors R M\ninstâœ : IsNoetherian R M\nâŠ¢ (setOf fun Ï‡ => Ne (LieModule.genWeightSpace M Ï‡) Bot.bot).Finite","decl":"lemma finite_genWeightSpace_ne_bot [NoZeroSMulDivisors R M] [IsNoetherian R M] :\n    {Ï‡ : L â†’ R | genWeightSpace M Ï‡ â‰  âŠ¥}.Finite :=\n  WellFoundedGT.finite_ne_bot_of_iSupIndep (iSupIndep_genWeightSpace R L M)\n\n"}
{"name":"LieModule.Weight.instFinite","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¹ : CommRing R\ninstâœâ¸ : LieRing L\ninstâœâ· : LieAlgebra R L\ninstâœâ¶ : AddCommGroup M\ninstâœâµ : Module R M\ninstâœâ´ : LieRingModule L M\ninstâœÂ³ : LieModule R L M\ninstâœÂ² : LieRing.IsNilpotent L\ninstâœÂ¹ : NoZeroSMulDivisors R M\ninstâœ : IsNoetherian R M\nâŠ¢ Finite (LieModule.Weight R L M)","decl":"instance Weight.instFinite [NoZeroSMulDivisors R M] [IsNoetherian R M] :\n    Finite (Weight R L M) := by\n  have : Finite {Ï‡ : L â†’ R | genWeightSpace M Ï‡ â‰  âŠ¥} := finite_genWeightSpace_ne_bot R L M\n  exact Finite.of_injective (equivSetOf R L M) (equivSetOf R L M).injective\n\n"}
{"name":"LieModule.IsTriangularizable.maxGenEigenspace_eq_top","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¶ : CommRing R\ninstâœâµ : LieRing L\ninstâœâ´ : LieAlgebra R L\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : LieRingModule L M\ninstâœ : LieModule R L M\nself : LieModule.IsTriangularizable R L M\nx : L\nâŠ¢ Eq (iSup fun Ï† => ((LieModule.toEnd R L M) x).maxGenEigenspace Ï†) Top.top","decl":"/-- A Lie module `M` of a Lie algebra `L` is triangularizable if the endomorphism of `M` defined by\nany `x : L` is triangularizable. -/\nclass IsTriangularizable : Prop where\n  maxGenEigenspace_eq_top : âˆ€ x, â¨† Ï†, (toEnd R L M x).maxGenEigenspace Ï† = âŠ¤\n\n"}
{"name":"LieModule.instIsTriangularizableSubtypeMemLieSubalgebra","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\nL' : LieSubalgebra R L\ninstâœ : LieModule.IsTriangularizable R L M\nâŠ¢ LieModule.IsTriangularizable R (Subtype fun x => Membership.mem L' x) M","decl":"instance (L' : LieSubalgebra R L) [IsTriangularizable R L M] : IsTriangularizable R L' M where\n  maxGenEigenspace_eq_top x := IsTriangularizable.maxGenEigenspace_eq_top (x : L)\n\n"}
{"name":"LieModule.instIsTriangularizableSubtypeMemLieSubmodule","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\nI : LieIdeal R L\ninstâœ : LieModule.IsTriangularizable R L M\nâŠ¢ LieModule.IsTriangularizable R (Subtype fun x => Membership.mem I x) M","decl":"instance (I : LieIdeal R L) [IsTriangularizable R L M] : IsTriangularizable R I M where\n  maxGenEigenspace_eq_top x := IsTriangularizable.maxGenEigenspace_eq_top (x : L)\n\n"}
{"name":"LieModule.instIsTriangularizableSubtypeEndMemLieSubalgebraRangeToEnd","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : LieModule.IsTriangularizable R L M\nâŠ¢ LieModule.IsTriangularizable R (Subtype fun x => Membership.mem (LieModule.toEnd R L M).range x) M","decl":"instance [IsTriangularizable R L M] : IsTriangularizable R (LieModule.toEnd R L M).range M where\n  maxGenEigenspace_eq_top := by\n    rintro âŸ¨-, x, rflâŸ©\n    exact IsTriangularizable.maxGenEigenspace_eq_top x\n\n"}
{"name":"LieModule.iSup_genWeightSpaceOf_eq_top","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : LieRing L\ninstâœâ¶ : LieAlgebra R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieRing.IsNilpotent L\ninstâœ : LieModule.IsTriangularizable R L M\nx : L\nâŠ¢ Eq (iSup fun Ï† => LieModule.genWeightSpaceOf M Ï† x) Top.top","decl":"@[simp]\nlemma iSup_genWeightSpaceOf_eq_top [IsTriangularizable R L M] (x : L) :\n    â¨† (Ï† : R), genWeightSpaceOf M Ï† x = âŠ¤ := by\n  rw [â† LieSubmodule.toSubmodule_inj, LieSubmodule.iSup_toSubmodule,\n    LieSubmodule.top_toSubmodule]\n  dsimp [genWeightSpaceOf]\n  exact IsTriangularizable.maxGenEigenspace_eq_top x\n\n"}
{"name":"LieModule.trace_toEnd_genWeightSpace","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœÂ¹Â¹ : CommRing R\ninstâœÂ¹â° : LieRing L\ninstâœâ¹ : LieAlgebra R L\ninstâœâ¸ : AddCommGroup M\ninstâœâ· : Module R M\ninstâœâ¶ : LieRingModule L M\ninstâœâµ : LieModule R L M\ninstâœâ´ : LieRing.IsNilpotent L\ninstâœÂ³ : IsDomain R\ninstâœÂ² : IsPrincipalIdealRing R\ninstâœÂ¹ : Module.Free R M\ninstâœ : Module.Finite R M\nÏ‡ : L â†’ R\nx : L\nâŠ¢ Eq ((LinearMap.trace R (Subtype fun x => Membership.mem (LieModule.genWeightSpace M Ï‡) x)) ((LieModule.toEnd R L (Subtype fun x => Membership.mem (LieModule.genWeightSpace M Ï‡) x)) x)) (HSMul.hSMul (Module.finrank R (Subtype fun x => Membership.mem (LieModule.genWeightSpace M Ï‡) x)) (Ï‡ x))","decl":"open LinearMap Module in\n@[simp]\nlemma trace_toEnd_genWeightSpace [IsDomain R] [IsPrincipalIdealRing R]\n    [Module.Free R M] [Module.Finite R M] (Ï‡ : L â†’ R) (x : L) :\n    trace R _ (toEnd R L (genWeightSpace M Ï‡) x) = finrank R (genWeightSpace M Ï‡) â€¢ Ï‡ x := by\n  suffices _root_.IsNilpotent ((toEnd R L (genWeightSpace M Ï‡) x) - Ï‡ x â€¢ LinearMap.id) by\n    replace this := (isNilpotent_trace_of_isNilpotent this).eq_zero\n    rwa [map_sub, map_smul, trace_id, sub_eq_zero, smul_eq_mul, mul_comm,\n      â† nsmul_eq_mul] at this\n  rw [â† Module.algebraMap_end_eq_smul_id]\n  exact isNilpotent_toEnd_sub_algebraMap M Ï‡ x\n\n"}
{"name":"LieModule.instIsTriangularizableOfIsAlgClosed","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"K : Type u_1\nL : Type u_3\nM : Type u_4\ninstâœâ¸ : LieRing L\ninstâœâ· : AddCommGroup M\ninstâœâ¶ : LieRingModule L M\ninstâœâµ : Field K\ninstâœâ´ : LieAlgebra K L\ninstâœÂ³ : Module K M\ninstâœÂ² : LieModule K L M\ninstâœÂ¹ : FiniteDimensional K M\ninstâœ : IsAlgClosed K\nâŠ¢ LieModule.IsTriangularizable K L M","decl":"instance instIsTriangularizableOfIsAlgClosed [IsAlgClosed K] : IsTriangularizable K L M :=\n  âŸ¨fun _ â†¦ Module.End.iSup_maxGenEigenspace_eq_top _âŸ©\n\n"}
{"name":"LieModule.instIsTriangularizableSubtypeMemLieSubmodule_1","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"K : Type u_1\nL : Type u_3\nM : Type u_4\ninstâœâ· : LieRing L\ninstâœâ¶ : AddCommGroup M\ninstâœâµ : LieRingModule L M\ninstâœâ´ : Field K\ninstâœÂ³ : LieAlgebra K L\ninstâœÂ² : Module K M\ninstâœÂ¹ : LieModule K L M\nN : LieSubmodule K L M\ninstâœ : LieModule.IsTriangularizable K L M\nâŠ¢ LieModule.IsTriangularizable K L (Subtype fun x => Membership.mem N x)","decl":"instance (N : LieSubmodule K L M) [IsTriangularizable K L M] : IsTriangularizable K L N := by\n  refine âŸ¨fun y â†¦ ?_âŸ©\n  rw [â† N.toEnd_restrict_eq_toEnd y]\n  exact Module.End.genEigenspace_restrict_eq_top _ (IsTriangularizable.maxGenEigenspace_eq_top y)\n\n"}
{"name":"LieModule.iSup_genWeightSpace_eq_top","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"K : Type u_1\nL : Type u_3\nM : Type u_4\ninstâœâ¹ : LieRing L\ninstâœâ¸ : AddCommGroup M\ninstâœâ· : LieRingModule L M\ninstâœâ¶ : LieRing.IsNilpotent L\ninstâœâµ : Field K\ninstâœâ´ : LieAlgebra K L\ninstâœÂ³ : Module K M\ninstâœÂ² : LieModule K L M\ninstâœÂ¹ : FiniteDimensional K M\ninstâœ : LieModule.IsTriangularizable K L M\nâŠ¢ Eq (iSup fun Ï‡ => LieModule.genWeightSpace M Ï‡) Top.top","decl":"/-- For a triangularizable Lie module in finite dimensions, the weight spaces span the entire space.\n\nSee also `LieModule.iSup_genWeightSpace_eq_top'`. -/\nlemma iSup_genWeightSpace_eq_top [IsTriangularizable K L M] :\n    â¨† Ï‡ : L â†’ K, genWeightSpace M Ï‡ = âŠ¤ := by\n  simp only [â† LieSubmodule.toSubmodule_inj, LieSubmodule.iSup_toSubmodule,\n    LieSubmodule.iInf_toSubmodule, LieSubmodule.top_toSubmodule, genWeightSpace]\n  refine Module.End.iSup_iInf_maxGenEigenspace_eq_top_of_forall_mapsTo (toEnd K L M)\n    (fun x y Ï† z â†¦ (genWeightSpaceOf M Ï† y).lie_mem) ?_\n  apply IsTriangularizable.maxGenEigenspace_eq_top\n\n"}
{"name":"LieModule.iSup_genWeightSpace_eq_top'","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"K : Type u_1\nL : Type u_3\nM : Type u_4\ninstâœâ¹ : LieRing L\ninstâœâ¸ : AddCommGroup M\ninstâœâ· : LieRingModule L M\ninstâœâ¶ : LieRing.IsNilpotent L\ninstâœâµ : Field K\ninstâœâ´ : LieAlgebra K L\ninstâœÂ³ : Module K M\ninstâœÂ² : LieModule K L M\ninstâœÂ¹ : FiniteDimensional K M\ninstâœ : LieModule.IsTriangularizable K L M\nâŠ¢ Eq (iSup fun Ï‡ => LieModule.genWeightSpace M â‡‘Ï‡) Top.top","decl":"lemma iSup_genWeightSpace_eq_top' [IsTriangularizable K L M] :\n    â¨† Ï‡ : Weight K L M, genWeightSpace M Ï‡ = âŠ¤ := by\n  have := iSup_genWeightSpace_eq_top K L M\n  erw [â† iSup_ne_bot_subtype, â† (Weight.equivSetOf K L M).iSup_comp] at this\n  exact this\n\n"}
