{"name":"LieModule.mem_weightSpace","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nχ : L → R\nm : M\n⊢ Iff (Membership.mem (LieModule.weightSpace M χ) m) (∀ (x : L), Eq (Bracket.bracket x m) (HSMul.hSMul (χ x) m))","decl":"lemma mem_weightSpace (χ : L → R) (m : M) : m ∈ weightSpace M χ ↔ ∀ x, ⁅x, m⁆ = χ x • m := by\n  simp [weightSpace]\n\n"}
{"name":"LieModule.weight_vector_multiplication","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\ninst✝¹⁴ : CommRing R\ninst✝¹³ : LieRing L\ninst✝¹² : LieAlgebra R L\nM₁ : Type u_5\nM₂ : Type u_6\nM₃ : Type u_7\ninst✝¹¹ : AddCommGroup M₁\ninst✝¹⁰ : Module R M₁\ninst✝⁹ : LieRingModule L M₁\ninst✝⁸ : LieModule R L M₁\ninst✝⁷ : AddCommGroup M₂\ninst✝⁶ : Module R M₂\ninst✝⁵ : LieRingModule L M₂\ninst✝⁴ : LieModule R L M₂\ninst✝³ : AddCommGroup M₃\ninst✝² : Module R M₃\ninst✝¹ : LieRingModule L M₃\ninst✝ : LieModule R L M₃\ng : LieModuleHom R L (TensorProduct R M₁ M₂) M₃\nχ₁ χ₂ : R\nx : L\n⊢ LE.le (LinearMap.range ((↑g).comp (TensorProduct.mapIncl (((LieModule.toEnd R L M₁) x).maxGenEigenspace χ₁) (((LieModule.toEnd R L M₂) x).maxGenEigenspace χ₂)))) (((LieModule.toEnd R L M₃) x).maxGenEigenspace (HAdd.hAdd χ₁ χ₂))","decl":"/-- See also `bourbaki1975b` Chapter VII §1.1, Proposition 2 (ii). -/\nprotected theorem weight_vector_multiplication (M₁ M₂ M₃ : Type*)\n    [AddCommGroup M₁] [Module R M₁] [LieRingModule L M₁] [LieModule R L M₁] [AddCommGroup M₂]\n    [Module R M₂] [LieRingModule L M₂] [LieModule R L M₂] [AddCommGroup M₃] [Module R M₃]\n    [LieRingModule L M₃] [LieModule R L M₃] (g : M₁ ⊗[R] M₂ →ₗ⁅R,L⁆ M₃) (χ₁ χ₂ : R) (x : L) :\n    LinearMap.range ((g : M₁ ⊗[R] M₂ →ₗ[R] M₃).comp (mapIncl 𝕎(M₁, χ₁, x) 𝕎(M₂, χ₂, x))) ≤\n      𝕎(M₃, χ₁ + χ₂, x) := by\n  -- Unpack the statement of the goal.\n  intro m₃\n  simp only [TensorProduct.mapIncl, LinearMap.mem_range, LinearMap.coe_comp,\n    LieModuleHom.coe_toLinearMap, Function.comp_apply, Pi.add_apply, exists_imp,\n    Module.End.mem_maxGenEigenspace]\n  rintro t rfl\n  -- Set up some notation.\n  let F : Module.End R M₃ := toEnd R L M₃ x - (χ₁ + χ₂) • ↑1\n  -- The goal is linear in `t` so use induction to reduce to the case that `t` is a pure tensor.\n  refine t.induction_on ?_ ?_ ?_\n  · use 0; simp only [LinearMap.map_zero, LieModuleHom.map_zero]\n  swap\n  · rintro t₁ t₂ ⟨k₁, hk₁⟩ ⟨k₂, hk₂⟩; use max k₁ k₂\n    simp only [LieModuleHom.map_add, LinearMap.map_add,\n      LinearMap.pow_map_zero_of_le (le_max_left k₁ k₂) hk₁,\n      LinearMap.pow_map_zero_of_le (le_max_right k₁ k₂) hk₂, add_zero]\n  -- Now the main argument: pure tensors.\n  rintro ⟨m₁, hm₁⟩ ⟨m₂, hm₂⟩\n  change ∃ k, (F ^ k) ((g : M₁ ⊗[R] M₂ →ₗ[R] M₃) (m₁ ⊗ₜ m₂)) = (0 : M₃)\n  -- Eliminate `g` from the picture.\n  let f₁ : Module.End R (M₁ ⊗[R] M₂) := (toEnd R L M₁ x - χ₁ • ↑1).rTensor M₂\n  let f₂ : Module.End R (M₁ ⊗[R] M₂) := (toEnd R L M₂ x - χ₂ • ↑1).lTensor M₁\n  have h_comm_square : F ∘ₗ ↑g = (g : M₁ ⊗[R] M₂ →ₗ[R] M₃).comp (f₁ + f₂) := by\n    ext m₁ m₂\n    simp only [f₁, f₂, F, ← g.map_lie x (m₁ ⊗ₜ m₂), add_smul, sub_tmul, tmul_sub, smul_tmul,\n      lie_tmul_right, tmul_smul, toEnd_apply_apply, LieModuleHom.map_smul,\n      LinearMap.one_apply, LieModuleHom.coe_toLinearMap, LinearMap.smul_apply, Function.comp_apply,\n      LinearMap.coe_comp, LinearMap.rTensor_tmul, LieModuleHom.map_add, LinearMap.add_apply,\n      LieModuleHom.map_sub, LinearMap.sub_apply, LinearMap.lTensor_tmul,\n      AlgebraTensorModule.curry_apply, TensorProduct.curry_apply, LinearMap.toFun_eq_coe,\n      LinearMap.coe_restrictScalars]\n    abel\n  rsuffices ⟨k, hk⟩ : ∃ k : ℕ, ((f₁ + f₂) ^ k) (m₁ ⊗ₜ m₂) = 0\n  · use k\n    change (F ^ k) (g.toLinearMap (m₁ ⊗ₜ[R] m₂)) = 0\n    rw [← LinearMap.comp_apply, LinearMap.commute_pow_left_of_commute h_comm_square,\n      LinearMap.comp_apply, hk, LinearMap.map_zero]\n  -- Unpack the information we have about `m₁`, `m₂`.\n  simp only [Module.End.mem_maxGenEigenspace] at hm₁ hm₂\n  obtain ⟨k₁, hk₁⟩ := hm₁\n  obtain ⟨k₂, hk₂⟩ := hm₂\n  have hf₁ : (f₁ ^ k₁) (m₁ ⊗ₜ m₂) = 0 := by\n    simp only [f₁, hk₁, zero_tmul, LinearMap.rTensor_tmul, LinearMap.rTensor_pow]\n  have hf₂ : (f₂ ^ k₂) (m₁ ⊗ₜ m₂) = 0 := by\n    simp only [f₂, hk₂, tmul_zero, LinearMap.lTensor_tmul, LinearMap.lTensor_pow]\n  -- It's now just an application of the binomial theorem.\n  use k₁ + k₂ - 1\n  have hf_comm : Commute f₁ f₂ := by\n    ext m₁ m₂\n    simp only [f₁, f₂, LinearMap.mul_apply, LinearMap.rTensor_tmul, LinearMap.lTensor_tmul,\n      AlgebraTensorModule.curry_apply, LinearMap.toFun_eq_coe, LinearMap.lTensor_tmul,\n      TensorProduct.curry_apply, LinearMap.coe_restrictScalars]\n  rw [hf_comm.add_pow']\n  simp only [TensorProduct.mapIncl, Submodule.subtype_apply, Finset.sum_apply, Submodule.coe_mk,\n    LinearMap.coeFn_sum, TensorProduct.map_tmul, LinearMap.smul_apply]\n  -- The required sum is zero because each individual term is zero.\n  apply Finset.sum_eq_zero\n  rintro ⟨i, j⟩ hij\n  -- Eliminate the binomial coefficients from the picture.\n  suffices (f₁ ^ i * f₂ ^ j) (m₁ ⊗ₜ m₂) = 0 by rw [this]; apply smul_zero\n  -- Finish off with appropriate case analysis.\n  cases' Nat.le_or_le_of_add_eq_add_pred (Finset.mem_antidiagonal.mp hij) with hi hj\n  · rw [(hf_comm.pow_pow i j).eq, LinearMap.mul_apply, LinearMap.pow_map_zero_of_le hi hf₁,\n      LinearMap.map_zero]\n  · rw [LinearMap.mul_apply, LinearMap.pow_map_zero_of_le hj hf₂, LinearMap.map_zero]\n\n"}
{"name":"LieModule.lie_mem_maxGenEigenspace_toEnd","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nχ₁ χ₂ : R\nx y : L\nm : M\nhy : Membership.mem (((LieModule.toEnd R L L) x).maxGenEigenspace χ₁) y\nhm : Membership.mem (((LieModule.toEnd R L M) x).maxGenEigenspace χ₂) m\n⊢ Membership.mem (((LieModule.toEnd R L M) x).maxGenEigenspace (HAdd.hAdd χ₁ χ₂)) (Bracket.bracket y m)","decl":"lemma lie_mem_maxGenEigenspace_toEnd\n    {χ₁ χ₂ : R} {x y : L} {m : M} (hy : y ∈ 𝕎(L, χ₁, x)) (hm : m ∈ 𝕎(M, χ₂, x)) :\n    ⁅y, m⁆ ∈ 𝕎(M, χ₁ + χ₂, x) := by\n  apply LieModule.weight_vector_multiplication L M M (toModuleHom R L M) χ₁ χ₂\n  simp only [LieModuleHom.coe_toLinearMap, Function.comp_apply, LinearMap.coe_comp,\n    TensorProduct.mapIncl, LinearMap.mem_range]\n  use ⟨y, hy⟩ ⊗ₜ ⟨m, hm⟩\n  simp only [Submodule.subtype_apply, toModuleHom_apply, TensorProduct.map_tmul]\n\n"}
{"name":"LieModule.mem_genWeightSpaceOf","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nχ : R\nx : L\nm : M\n⊢ Iff (Membership.mem (LieModule.genWeightSpaceOf M χ x) m) (Exists fun k => Eq ((HPow.hPow (HSub.hSub ((LieModule.toEnd R L M) x) (HSMul.hSMul χ 1)) k) m) 0)","decl":"theorem mem_genWeightSpaceOf (χ : R) (x : L) (m : M) :\n    m ∈ genWeightSpaceOf M χ x ↔ ∃ k : ℕ, ((toEnd R L M x - χ • ↑1) ^ k) m = 0 := by\n  simp [genWeightSpaceOf]\n\n"}
{"name":"LieModule.coe_genWeightSpaceOf_zero","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nx : L\n⊢ Eq (↑(LieModule.genWeightSpaceOf M 0 x)) (iSup fun k => LinearMap.ker (HPow.hPow ((LieModule.toEnd R L M) x) k))","decl":"theorem coe_genWeightSpaceOf_zero (x : L) :\n    ↑(genWeightSpaceOf M (0 : R) x) = ⨆ k, LinearMap.ker (toEnd R L M x ^ k) := by\n  simp [genWeightSpaceOf, ← Module.End.iSup_genEigenspace_eq]\n\n"}
{"name":"LieModule.mem_genWeightSpace","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nχ : L → R\nm : M\n⊢ Iff (Membership.mem (LieModule.genWeightSpace M χ) m) (∀ (x : L), Exists fun k => Eq ((HPow.hPow (HSub.hSub ((LieModule.toEnd R L M) x) (HSMul.hSMul (χ x) 1)) k) m) 0)","decl":"theorem mem_genWeightSpace (χ : L → R) (m : M) :\n    m ∈ genWeightSpace M χ ↔ ∀ x, ∃ k : ℕ, ((toEnd R L M x - χ x • ↑1) ^ k) m = 0 := by\n  simp [genWeightSpace, mem_genWeightSpaceOf]\n\n"}
{"name":"LieModule.genWeightSpace_le_genWeightSpaceOf","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nx : L\nχ : L → R\n⊢ LE.le (LieModule.genWeightSpace M χ) (LieModule.genWeightSpaceOf M (χ x) x)","decl":"lemma genWeightSpace_le_genWeightSpaceOf (x : L) (χ : L → R) :\n    genWeightSpace M χ ≤ genWeightSpaceOf M (χ x) x :=\n  iInf_le _ x\n\n"}
{"name":"LieModule.weightSpace_le_genWeightSpace","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nχ : L → R\n⊢ LE.le (LieModule.weightSpace M χ) (LieModule.genWeightSpace M χ)","decl":"lemma weightSpace_le_genWeightSpace (χ : L → R) :\n    weightSpace M χ ≤ genWeightSpace M χ := by\n  apply le_iInf\n  intro x\n  rw [← (LieSubmodule.toSubmodule_orderEmbedding R L M).le_iff_le]\n  apply (iInf_le _ x).trans\n  exact ((toEnd R L M x).genEigenspace (χ x)).monotone le_top\n\n"}
{"name":"LieModule.Weight.mk.injEq","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\ntoFun✝ : L → R\ngenWeightSpace_ne_bot'✝ : Ne (LieModule.genWeightSpace M toFun✝) Bot.bot\ntoFun : L → R\ngenWeightSpace_ne_bot' : Ne (LieModule.genWeightSpace M toFun) Bot.bot\n⊢ Eq (Eq { toFun := toFun✝, genWeightSpace_ne_bot' := genWeightSpace_ne_bot'✝ } { toFun := toFun, genWeightSpace_ne_bot' := genWeightSpace_ne_bot' }) (Eq toFun✝ toFun)","decl":"variable (R L) in\n/-- A weight of a Lie module is a map `L → R` such that the corresponding weight space is\nnon-trivial. -/\nstructure Weight where\n  /-- The family of eigenvalues corresponding to a weight. -/\n  toFun : L → R\n  genWeightSpace_ne_bot' : genWeightSpace M toFun ≠ ⊥\n\n"}
{"name":"LieModule.Weight.mk.inj","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\ntoFun✝ : L → R\ngenWeightSpace_ne_bot'✝ : Ne (LieModule.genWeightSpace M toFun✝) Bot.bot\ntoFun : L → R\ngenWeightSpace_ne_bot' : Ne (LieModule.genWeightSpace M toFun) Bot.bot\nx✝ : Eq { toFun := toFun✝, genWeightSpace_ne_bot' := genWeightSpace_ne_bot'✝ } { toFun := toFun, genWeightSpace_ne_bot' := genWeightSpace_ne_bot' }\n⊢ Eq toFun✝ toFun","decl":"variable (R L) in\n/-- A weight of a Lie module is a map `L → R` such that the corresponding weight space is\nnon-trivial. -/\nstructure Weight where\n  /-- The family of eigenvalues corresponding to a weight. -/\n  toFun : L → R\n  genWeightSpace_ne_bot' : genWeightSpace M toFun ≠ ⊥\n\n"}
{"name":"LieModule.Weight.mk.sizeOf_spec","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : SizeOf R\ninst✝¹ : SizeOf L\ninst✝ : SizeOf M\ntoFun : L → R\ngenWeightSpace_ne_bot' : Ne (LieModule.genWeightSpace M toFun) Bot.bot\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, genWeightSpace_ne_bot' := genWeightSpace_ne_bot' }) 1","decl":"variable (R L) in\n/-- A weight of a Lie module is a map `L → R` such that the corresponding weight space is\nnon-trivial. -/\nstructure Weight where\n  /-- The family of eigenvalues corresponding to a weight. -/\n  toFun : L → R\n  genWeightSpace_ne_bot' : genWeightSpace M toFun ≠ ⊥\n\n"}
{"name":"LieModule.Weight.genWeightSpace_ne_bot'","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nself : LieModule.Weight R L M\n⊢ Ne (LieModule.genWeightSpace M self.toFun) Bot.bot","decl":"variable (R L) in\n/-- A weight of a Lie module is a map `L → R` such that the corresponding weight space is\nnon-trivial. -/\nstructure Weight where\n  /-- The family of eigenvalues corresponding to a weight. -/\n  toFun : L → R\n  genWeightSpace_ne_bot' : genWeightSpace M toFun ≠ ⊥\n\n"}
{"name":"LieModule.Weight.coe_weight_mk","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nχ : L → R\nh : Ne (LieModule.genWeightSpace M χ) Bot.bot\n⊢ Eq (⇑{ toFun := χ, genWeightSpace_ne_bot' := h }) χ","decl":"@[simp] lemma coe_weight_mk (χ : L → R) (h) :\n    (↑(⟨χ, h⟩ : Weight R L M) : L → R) = χ :=\n  rfl\n\n"}
{"name":"LieModule.Weight.genWeightSpace_ne_bot","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nχ : LieModule.Weight R L M\n⊢ Ne (LieModule.genWeightSpace M ⇑χ) Bot.bot","decl":"lemma genWeightSpace_ne_bot (χ : Weight R L M) : genWeightSpace M χ ≠ ⊥ := χ.genWeightSpace_ne_bot'\n\n"}
{"name":"LieModule.Weight.ext_iff","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nχ₁ χ₂ : LieModule.Weight R L M\n⊢ Iff (Eq χ₁ χ₂) (∀ (x : L), Eq (χ₁ x) (χ₂ x))","decl":"@[ext] lemma ext {χ₁ χ₂ : Weight R L M} (h : ∀ x, χ₁ x = χ₂ x) : χ₁ = χ₂ := by\n  cases' χ₁ with f₁ _; cases' χ₂ with f₂ _; aesop\n\n"}
{"name":"LieModule.Weight.ext","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nχ₁ χ₂ : LieModule.Weight R L M\nh : ∀ (x : L), Eq (χ₁ x) (χ₂ x)\n⊢ Eq χ₁ χ₂","decl":"@[ext] lemma ext {χ₁ χ₂ : Weight R L M} (h : ∀ x, χ₁ x = χ₂ x) : χ₁ = χ₂ := by\n  cases' χ₁ with f₁ _; cases' χ₂ with f₂ _; aesop\n\n"}
{"name":"LieModule.Weight.ext_iff'","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nχ₁ χ₂ : LieModule.Weight R L M\n⊢ Iff (Eq ⇑χ₁ ⇑χ₂) (Eq χ₁ χ₂)","decl":"lemma ext_iff' {χ₁ χ₂ : Weight R L M} : (χ₁ : L → R) = χ₂ ↔ χ₁ = χ₂ := by simp\n\n"}
{"name":"LieModule.Weight.exists_ne_zero","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nχ : LieModule.Weight R L M\n⊢ Exists fun x => And (Membership.mem (LieModule.genWeightSpace M ⇑χ) x) (Ne x 0)","decl":"lemma exists_ne_zero (χ : Weight R L M) :\n    ∃ x ∈ genWeightSpace M χ, x ≠ 0 := by\n  simpa [LieSubmodule.eq_bot_iff] using χ.genWeightSpace_ne_bot\n\n"}
{"name":"LieModule.Weight.instIsEmptyOfSubsingleton","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : Subsingleton M\n⊢ IsEmpty (LieModule.Weight R L M)","decl":"instance [Subsingleton M] : IsEmpty (Weight R L M) :=\n  ⟨fun h ↦ h.2 (Subsingleton.elim _ _)⟩\n\n"}
{"name":"LieModule.Weight.coe_zero","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : Nontrivial (Subtype fun x => Membership.mem (LieModule.genWeightSpace M 0) x)\n⊢ Eq (⇑0) 0","decl":"@[simp]\nlemma coe_zero [Nontrivial (genWeightSpace M (0 : L → R))] : ((0 : Weight R L M) : L → R) = 0 := rfl\n\n"}
{"name":"LieModule.Weight.zero_apply","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : Nontrivial (Subtype fun x => Membership.mem (LieModule.genWeightSpace M 0) x)\nx : L\n⊢ Eq (0 x) 0","decl":"lemma zero_apply [Nontrivial (genWeightSpace M (0 : L → R))] (x) : (0 : Weight R L M) x = 0 := rfl\n\n"}
{"name":"LieModule.Weight.IsZero.eq","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nχ : LieModule.Weight R L M\nhχ : χ.IsZero\n⊢ Eq (⇑χ) 0","decl":"@[simp] lemma IsZero.eq {χ : Weight R L M} (hχ : χ.IsZero) : (χ : L → R) = 0 := hχ\n\n"}
{"name":"LieModule.Weight.coe_eq_zero_iff","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nχ : LieModule.Weight R L M\n⊢ Iff (Eq (⇑χ) 0) χ.IsZero","decl":"@[simp] lemma coe_eq_zero_iff (χ : Weight R L M) : (χ : L → R) = 0 ↔ χ.IsZero := Iff.rfl\n\n"}
{"name":"LieModule.Weight.isZero_iff_eq_zero","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : Nontrivial (Subtype fun x => Membership.mem (LieModule.genWeightSpace M 0) x)\nχ : LieModule.Weight R L M\n⊢ Iff χ.IsZero (Eq χ 0)","decl":"lemma isZero_iff_eq_zero [Nontrivial (genWeightSpace M (0 : L → R))] {χ : Weight R L M} :\n    χ.IsZero ↔ χ = 0 := Weight.ext_iff' (χ₂ := 0)\n\n"}
{"name":"LieModule.Weight.isZero_zero","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : Nontrivial (Subtype fun x => Membership.mem (LieModule.genWeightSpace M 0) x)\n⊢ LieModule.Weight.IsZero 0","decl":"lemma isZero_zero [Nontrivial (genWeightSpace M (0 : L → R))] : IsZero (0 : Weight R L M) := rfl\n\n"}
{"name":"LieModule.Weight.isNonZero_iff_ne_zero","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : Nontrivial (Subtype fun x => Membership.mem (LieModule.genWeightSpace M 0) x)\nχ : LieModule.Weight R L M\n⊢ Iff χ.IsNonZero (Ne χ 0)","decl":"lemma isNonZero_iff_ne_zero [Nontrivial (genWeightSpace M (0 : L → R))] {χ : Weight R L M} :\n    χ.IsNonZero ↔ χ ≠ 0 := isZero_iff_eq_zero.not\n\n"}
{"name":"LieModule.Weight.genWeightSpaceOf_ne_bot","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nχ : LieModule.Weight R L M\nx : L\n⊢ Ne (LieModule.genWeightSpaceOf M (χ x) x) Bot.bot","decl":"lemma genWeightSpaceOf_ne_bot (χ : Weight R L M) (x : L) :\n    genWeightSpaceOf M (χ x) x ≠ ⊥ := by\n  have : ⨅ x, genWeightSpaceOf M (χ x) x ≠ ⊥ := χ.genWeightSpace_ne_bot\n  contrapose! this\n  rw [eq_bot_iff]\n  exact le_of_le_of_eq (iInf_le _ _) this\n\n"}
{"name":"LieModule.Weight.hasEigenvalueAt","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nχ : LieModule.Weight R L M\nx : L\n⊢ ((LieModule.toEnd R L M) x).HasEigenvalue (χ x)","decl":"lemma hasEigenvalueAt (χ : Weight R L M) (x : L) :\n    (toEnd R L M x).HasEigenvalue (χ x) := by\n  obtain ⟨k : ℕ, hk : (toEnd R L M x).genEigenspace (χ x) k ≠ ⊥⟩ := by\n    simpa [genWeightSpaceOf, ← Module.End.iSup_genEigenspace_eq] using χ.genWeightSpaceOf_ne_bot x\n  exact Module.End.hasEigenvalue_of_hasGenEigenvalue hk\n\n"}
{"name":"LieModule.Weight.apply_eq_zero_of_isNilpotent","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁹ : CommRing R\ninst✝⁸ : LieRing L\ninst✝⁷ : LieAlgebra R L\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : LieRingModule L M\ninst✝³ : LieModule R L M\ninst✝² : LieRing.IsNilpotent L\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsReduced R\nx : L\nh : IsNilpotent ((LieModule.toEnd R L M) x)\nχ : LieModule.Weight R L M\n⊢ Eq (χ x) 0","decl":"lemma apply_eq_zero_of_isNilpotent [NoZeroSMulDivisors R M] [IsReduced R]\n    (x : L) (h : _root_.IsNilpotent (toEnd R L M x)) (χ : Weight R L M) :\n    χ x = 0 :=\n  ((χ.hasEigenvalueAt x).isNilpotent_of_isNilpotent h).eq_zero\n\n"}
{"name":"LieModule.zero_genWeightSpace_eq_top_of_nilpotent'","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : LieModule.IsNilpotent L M\n⊢ Eq (LieModule.genWeightSpace M 0) Top.top","decl":"/-- See also the more useful form `LieModule.zero_genWeightSpace_eq_top_of_nilpotent`. -/\n@[simp]\ntheorem zero_genWeightSpace_eq_top_of_nilpotent' [IsNilpotent L M] :\n    genWeightSpace M (0 : L → R) = ⊤ := by\n  ext\n  simp [genWeightSpace, genWeightSpaceOf]\n\n"}
{"name":"LieModule.coe_genWeightSpace_of_top","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nχ : L → R\n⊢ Eq ↑(LieModule.genWeightSpace M (Function.comp χ ⇑Top.top.incl)) ↑(LieModule.genWeightSpace M χ)","decl":"theorem coe_genWeightSpace_of_top (χ : L → R) :\n    (genWeightSpace M (χ ∘ (⊤ : LieSubalgebra R L).incl) : Submodule R M) = genWeightSpace M χ := by\n  ext m\n  simp only [mem_genWeightSpace, LieSubmodule.mem_toSubmodule, Subtype.forall]\n  apply forall_congr'\n  simp\n\n"}
{"name":"LieModule.zero_genWeightSpace_eq_top_of_nilpotent","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : LieModule.IsNilpotent L M\n⊢ Eq (LieModule.genWeightSpace M 0) Top.top","decl":"@[simp]\ntheorem zero_genWeightSpace_eq_top_of_nilpotent [IsNilpotent L M] :\n    genWeightSpace M (0 : (⊤ : LieSubalgebra R L) → R) = ⊤ := by\n  ext m\n  simp only [mem_genWeightSpace, Pi.zero_apply, zero_smul, sub_zero, Subtype.forall,\n    forall_true_left, LieSubalgebra.toEnd_mk, LieSubalgebra.mem_top, LieSubmodule.mem_top, iff_true]\n  intro x\n  obtain ⟨k, hk⟩ := exists_forall_pow_toEnd_eq_zero R L M\n  exact ⟨k, by simp [hk x]⟩\n\n"}
{"name":"LieModule.exists_genWeightSpace_le_ker_of_isNoetherian","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : IsNoetherian R M\nχ : L → R\nx : L\n⊢ Exists fun k => LE.le (↑(LieModule.genWeightSpace M χ)) (LinearMap.ker (HPow.hPow (HSub.hSub ((LieModule.toEnd R L M) x) ((algebraMap R (Module.End R M)) (χ x))) k))","decl":"theorem exists_genWeightSpace_le_ker_of_isNoetherian [IsNoetherian R M] (χ : L → R) (x : L) :\n    ∃ k : ℕ,\n      genWeightSpace M χ ≤ LinearMap.ker ((toEnd R L M x - algebraMap R _ (χ x)) ^ k) := by\n  use (toEnd R L M x).maxGenEigenspaceIndex (χ x)\n  intro m hm\n  replace hm : m ∈ (toEnd R L M x).maxGenEigenspace (χ x) :=\n    genWeightSpace_le_genWeightSpaceOf M x χ hm\n  rwa [Module.End.maxGenEigenspace_eq, Module.End.genEigenspace_nat] at hm\n\n"}
{"name":"LieModule.exists_genWeightSpace_zero_le_ker_of_isNoetherian","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : IsNoetherian R M\nx : L\n⊢ Exists fun k => LE.le (↑(LieModule.genWeightSpace M 0)) (LinearMap.ker (HPow.hPow ((LieModule.toEnd R L M) x) k))","decl":"variable (R) in\ntheorem exists_genWeightSpace_zero_le_ker_of_isNoetherian\n    [IsNoetherian R M] (x : L) :\n    ∃ k : ℕ, genWeightSpace M (0 : L → R) ≤ LinearMap.ker (toEnd R L M x ^ k) := by\n  simpa using exists_genWeightSpace_le_ker_of_isNoetherian M (0 : L → R) x\n\n"}
{"name":"LieModule.isNilpotent_toEnd_sub_algebraMap","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : IsNoetherian R M\nχ : L → R\nx : L\n⊢ IsNilpotent (HSub.hSub ((LieModule.toEnd R L (Subtype fun x => Membership.mem (LieModule.genWeightSpace M χ) x)) x) ((algebraMap R (Module.End R (Subtype fun x => Membership.mem (LieModule.genWeightSpace M χ) x))) (χ x)))","decl":"lemma isNilpotent_toEnd_sub_algebraMap [IsNoetherian R M] (χ : L → R) (x : L) :\n    _root_.IsNilpotent <| toEnd R L (genWeightSpace M χ) x - algebraMap R _ (χ x) := by\n  have : toEnd R L (genWeightSpace M χ) x - algebraMap R _ (χ x) =\n      (toEnd R L M x - algebraMap R _ (χ x)).restrict\n        (fun m hm ↦ sub_mem (LieSubmodule.lie_mem _ hm) (Submodule.smul_mem _ _ hm)) := by\n    rfl\n  obtain ⟨k, hk⟩ := exists_genWeightSpace_le_ker_of_isNoetherian M χ x\n  use k\n  ext ⟨m, hm⟩\n  simp only [this, LinearMap.pow_restrict _, LinearMap.zero_apply, ZeroMemClass.coe_zero,\n    ZeroMemClass.coe_eq_zero]\n  exact ZeroMemClass.coe_eq_zero.mp (hk hm)\n\n"}
{"name":"LieModule.isNilpotent_toEnd_genWeightSpace_zero","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : IsNoetherian R M\nx : L\n⊢ IsNilpotent ((LieModule.toEnd R L (Subtype fun x => Membership.mem (LieModule.genWeightSpace M 0) x)) x)","decl":"/-- A (nilpotent) Lie algebra acts nilpotently on the zero weight space of a Noetherian Lie\nmodule. -/\ntheorem isNilpotent_toEnd_genWeightSpace_zero [IsNoetherian R M] (x : L) :\n    _root_.IsNilpotent <| toEnd R L (genWeightSpace M (0 : L → R)) x := by\n  simpa using isNilpotent_toEnd_sub_algebraMap M (0 : L → R) x\n\n"}
{"name":"LieModule.instIsNilpotentSubtypeMemLieSubmoduleGenWeightSpaceOfNatForallOfIsNoetherian","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : IsNoetherian R M\n⊢ LieModule.IsNilpotent L (Subtype fun x => Membership.mem (LieModule.genWeightSpace M 0) x)","decl":"/-- By Engel's theorem, the zero weight space of a Noetherian Lie module is nilpotent. -/\ninstance [IsNoetherian R M] :\n    IsNilpotent L (genWeightSpace M (0 : L → R)) :=\n  isNilpotent_iff_forall'.mpr <| isNilpotent_toEnd_genWeightSpace_zero M\n\n"}
{"name":"LieModule.genWeightSpace_zero_normalizer_eq_self","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\n⊢ Eq (LieModule.genWeightSpace M 0).normalizer (LieModule.genWeightSpace M 0)","decl":"@[simp]\nlemma genWeightSpace_zero_normalizer_eq_self :\n    (genWeightSpace M (0 : L → R)).normalizer = genWeightSpace M 0 := by\n  refine le_antisymm ?_ (LieSubmodule.le_normalizer _)\n  intro m hm\n  rw [LieSubmodule.mem_normalizer] at hm\n  simp only [mem_genWeightSpace, Pi.zero_apply, zero_smul, sub_zero] at hm ⊢\n  intro y\n  obtain ⟨k, hk⟩ := hm y y\n  use k + 1\n  simpa [pow_succ, LinearMap.mul_eq_comp]\n\n"}
{"name":"LieModule.iSup_ucs_le_genWeightSpace_zero","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\n⊢ LE.le (iSup fun k => LieSubmodule.ucs k Bot.bot) (LieModule.genWeightSpace M 0)","decl":"lemma iSup_ucs_le_genWeightSpace_zero :\n    ⨆ k, (⊥ : LieSubmodule R L M).ucs k ≤ genWeightSpace M (0 : L → R) := by\n  simpa using\n    LieSubmodule.ucs_le_of_normalizer_eq_self (genWeightSpace_zero_normalizer_eq_self R L M)\n\n"}
{"name":"LieModule.iSup_ucs_eq_genWeightSpace_zero","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : IsNoetherian R M\n⊢ Eq (iSup fun k => LieSubmodule.ucs k Bot.bot) (LieModule.genWeightSpace M 0)","decl":"/-- See also `LieModule.iInf_lowerCentralSeries_eq_posFittingComp`. -/\nlemma iSup_ucs_eq_genWeightSpace_zero [IsNoetherian R M] :\n    ⨆ k, (⊥ : LieSubmodule R L M).ucs k = genWeightSpace M (0 : L → R) := by\n  obtain ⟨k, hk⟩ := (LieSubmodule.isNilpotent_iff_exists_self_le_ucs\n    <| genWeightSpace M (0 : L → R)).mp inferInstance\n  refine le_antisymm (iSup_ucs_le_genWeightSpace_zero R L M) (le_trans hk ?_)\n  exact le_iSup (fun k ↦ (⊥ : LieSubmodule R L M).ucs k) k\n\n"}
{"name":"LieModule.mem_posFittingCompOf","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nx : L\nm : M\n⊢ Iff (Membership.mem (LieModule.posFittingCompOf R M x) m) (∀ (k : Nat), Exists fun n => Eq ((HPow.hPow ((LieModule.toEnd R L M) x) k) n) m)","decl":"variable {M} in\nlemma mem_posFittingCompOf (x : L) (m : M) :\n    m ∈ posFittingCompOf R M x ↔ ∀ (k : ℕ), ∃ n, (toEnd R L M x ^ k) n = m := by\n  simp [posFittingCompOf]\n\n"}
{"name":"LieModule.posFittingCompOf_le_lowerCentralSeries","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nx : L\nk : Nat\n⊢ LE.le (LieModule.posFittingCompOf R M x) (LieModule.lowerCentralSeries R L M k)","decl":"@[simp] lemma posFittingCompOf_le_lowerCentralSeries (x : L) (k : ℕ) :\n    posFittingCompOf R M x ≤ lowerCentralSeries R L M k := by\n  suffices ∀ m l, (toEnd R L M x ^ l) m ∈ lowerCentralSeries R L M l by\n    intro m hm\n    obtain ⟨n, rfl⟩ := (mem_posFittingCompOf R x m).mp hm k\n    exact this n k\n  intro m l\n  induction l with\n  | zero => simp\n  | succ l ih =>\n    simp only [lowerCentralSeries_succ, pow_succ', LinearMap.mul_apply]\n    exact LieSubmodule.lie_mem_lie (LieSubmodule.mem_top x) ih\n\n"}
{"name":"LieModule.posFittingCompOf_eq_bot_of_isNilpotent","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : LieModule.IsNilpotent L M\nx : L\n⊢ Eq (LieModule.posFittingCompOf R M x) Bot.bot","decl":"@[simp] lemma posFittingCompOf_eq_bot_of_isNilpotent\n    [IsNilpotent L M] (x : L) :\n    posFittingCompOf R M x = ⊥ := by\n  simp_rw [eq_bot_iff, ← iInf_lowerCentralSeries_eq_bot_of_isNilpotent, le_iInf_iff,\n    posFittingCompOf_le_lowerCentralSeries, forall_const]\n\n"}
{"name":"LieModule.mem_posFittingComp","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nm : M\n⊢ Iff (Membership.mem (LieModule.posFittingComp R L M) m) (Membership.mem (iSup fun x => LieModule.posFittingCompOf R M x) m)","decl":"lemma mem_posFittingComp (m : M) :\n    m ∈ posFittingComp R L M ↔ m ∈ ⨆ (x : L), posFittingCompOf R M x := by\n  rfl\n\n"}
{"name":"LieModule.posFittingCompOf_le_posFittingComp","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nx : L\n⊢ LE.le (LieModule.posFittingCompOf R M x) (LieModule.posFittingComp R L M)","decl":"lemma posFittingCompOf_le_posFittingComp (x : L) :\n    posFittingCompOf R M x ≤ posFittingComp R L M := by\n  rw [posFittingComp]; exact le_iSup (posFittingCompOf R M) x\n\n"}
{"name":"LieModule.posFittingComp_le_iInf_lowerCentralSeries","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\n⊢ LE.le (LieModule.posFittingComp R L M) (iInf fun k => LieModule.lowerCentralSeries R L M k)","decl":"lemma posFittingComp_le_iInf_lowerCentralSeries :\n    posFittingComp R L M ≤ ⨅ k, lowerCentralSeries R L M k := by\n  simp [posFittingComp]\n\n"}
{"name":"LieModule.iInf_lowerCentralSeries_eq_posFittingComp","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁹ : CommRing R\ninst✝⁸ : LieRing L\ninst✝⁷ : LieAlgebra R L\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : LieRingModule L M\ninst✝³ : LieModule R L M\ninst✝² : LieRing.IsNilpotent L\ninst✝¹ : IsNoetherian R M\ninst✝ : IsArtinian R M\n⊢ Eq (iInf fun k => LieModule.lowerCentralSeries R L M k) (LieModule.posFittingComp R L M)","decl":"/-- See also `LieModule.iSup_ucs_eq_genWeightSpace_zero`. -/\n@[simp] lemma iInf_lowerCentralSeries_eq_posFittingComp\n    [IsNoetherian R M] [IsArtinian R M] :\n    ⨅ k, lowerCentralSeries R L M k = posFittingComp R L M := by\n  refine le_antisymm ?_ (posFittingComp_le_iInf_lowerCentralSeries R L M)\n  apply iInf_lcs_le_of_isNilpotent_quot\n  rw [LieModule.isNilpotent_iff_forall' (R := R)]\n  intro x\n  obtain ⟨k, hk⟩ := Filter.eventually_atTop.mp (toEnd R L M x).eventually_iInf_range_pow_eq\n  use k\n  ext ⟨m⟩\n  set F := posFittingComp R L M\n  replace hk : (toEnd R L M x ^ k) m ∈ F := by\n    apply posFittingCompOf_le_posFittingComp R L M x\n    simp_rw [← LieSubmodule.mem_toSubmodule, posFittingCompOf, hk k (le_refl k)]\n    apply LinearMap.mem_range_self\n  suffices (toEnd R L (M ⧸ F) x ^ k) (LieSubmodule.Quotient.mk (N := F) m) =\n    LieSubmodule.Quotient.mk (N := F) ((toEnd R L M x ^ k) m)\n      by simpa [Submodule.Quotient.quot_mk_eq_mk, this]\n  have := LinearMap.congr_fun (LinearMap.commute_pow_left_of_commute\n    (LieSubmodule.Quotient.toEnd_comp_mk' F x) k) m\n  simpa using this\n\n"}
{"name":"LieModule.posFittingComp_eq_bot_of_isNilpotent","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : LieModule.IsNilpotent L M\n⊢ Eq (LieModule.posFittingComp R L M) Bot.bot","decl":"@[simp] lemma posFittingComp_eq_bot_of_isNilpotent\n    [IsNilpotent L M] :\n    posFittingComp R L M = ⊥ := by\n  simp [posFittingComp]\n\n"}
{"name":"LieModule.map_posFittingComp_le","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : LieRing L\ninst✝⁹ : LieAlgebra R L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : LieRingModule L M\ninst✝⁵ : LieModule R L M\ninst✝⁴ : LieRing.IsNilpotent L\nM₂ : Type u_5\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : LieRingModule L M₂\ninst✝ : LieModule R L M₂\nf : LieModuleHom R L M M₂\n⊢ LE.le (LieSubmodule.map f (LieModule.posFittingComp R L M)) (LieModule.posFittingComp R L M₂)","decl":"lemma map_posFittingComp_le :\n    (posFittingComp R L M).map f ≤ posFittingComp R L M₂ := by\n  rw [posFittingComp, posFittingComp, LieSubmodule.map_iSup]\n  refine iSup_mono fun y ↦ LieSubmodule.map_le_iff_le_comap.mpr fun m hm ↦ ?_\n  simp only [mem_posFittingCompOf] at hm\n  simp only [LieSubmodule.mem_comap, mem_posFittingCompOf]\n  intro k\n  obtain ⟨n, hn⟩ := hm k\n  use f n\n  rw [LieModule.toEnd_pow_apply_map, hn]\n\n"}
{"name":"LieModule.map_genWeightSpace_le","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : LieRing L\ninst✝⁹ : LieAlgebra R L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : LieRingModule L M\ninst✝⁵ : LieModule R L M\ninst✝⁴ : LieRing.IsNilpotent L\nM₂ : Type u_5\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : LieRingModule L M₂\ninst✝ : LieModule R L M₂\nχ : L → R\nf : LieModuleHom R L M M₂\n⊢ LE.le (LieSubmodule.map f (LieModule.genWeightSpace M χ)) (LieModule.genWeightSpace M₂ χ)","decl":"lemma map_genWeightSpace_le :\n    (genWeightSpace M χ).map f ≤ genWeightSpace M₂ χ := by\n  rw [LieSubmodule.map_le_iff_le_comap]\n  intro m hm\n  simp only [LieSubmodule.mem_comap, mem_genWeightSpace]\n  intro x\n  have : (toEnd R L M₂ x - χ x • ↑1) ∘ₗ f = f ∘ₗ (toEnd R L M x - χ x • ↑1) := by\n    ext; simp\n  obtain ⟨k, h⟩ := (mem_genWeightSpace _ _ _).mp hm x\n  exact ⟨k, by simpa [h] using LinearMap.congr_fun (LinearMap.commute_pow_left_of_commute this k) m⟩\n\n"}
{"name":"LieModule.comap_genWeightSpace_eq_of_injective","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : LieRing L\ninst✝⁹ : LieAlgebra R L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : LieRingModule L M\ninst✝⁵ : LieModule R L M\ninst✝⁴ : LieRing.IsNilpotent L\nM₂ : Type u_5\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : LieRingModule L M₂\ninst✝ : LieModule R L M₂\nχ : L → R\nf : LieModuleHom R L M M₂\nhf : Function.Injective ⇑f\n⊢ Eq (LieSubmodule.comap f (LieModule.genWeightSpace M₂ χ)) (LieModule.genWeightSpace M χ)","decl":"lemma comap_genWeightSpace_eq_of_injective (hf : Injective f) :\n    (genWeightSpace M₂ χ).comap f = genWeightSpace M χ := by\n  refine le_antisymm (fun m hm ↦ ?_) ?_\n  · simp only [LieSubmodule.mem_comap, mem_genWeightSpace] at hm\n    simp only [mem_genWeightSpace]\n    intro x\n    have h : (toEnd R L M₂ x - χ x • ↑1) ∘ₗ f =\n             f ∘ₗ (toEnd R L M x - χ x • ↑1) := by ext; simp\n    obtain ⟨k, hk⟩ := hm x\n    use k\n    suffices f (((toEnd R L M x - χ x • ↑1) ^ k) m) = 0 by\n      rw [← f.map_zero] at this; exact hf this\n    simpa [hk] using (LinearMap.congr_fun (LinearMap.commute_pow_left_of_commute h k) m).symm\n  · rw [← LieSubmodule.map_le_iff_le_comap]\n    exact map_genWeightSpace_le f\n\n"}
{"name":"LieModule.map_genWeightSpace_eq_of_injective","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : LieRing L\ninst✝⁹ : LieAlgebra R L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : LieRingModule L M\ninst✝⁵ : LieModule R L M\ninst✝⁴ : LieRing.IsNilpotent L\nM₂ : Type u_5\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : LieRingModule L M₂\ninst✝ : LieModule R L M₂\nχ : L → R\nf : LieModuleHom R L M M₂\nhf : Function.Injective ⇑f\n⊢ Eq (LieSubmodule.map f (LieModule.genWeightSpace M χ)) (Min.min (LieModule.genWeightSpace M₂ χ) f.range)","decl":"lemma map_genWeightSpace_eq_of_injective (hf : Injective f) :\n    (genWeightSpace M χ).map f = genWeightSpace M₂ χ ⊓ f.range := by\n  refine le_antisymm (le_inf_iff.mpr ⟨map_genWeightSpace_le f, LieSubmodule.map_le_range f⟩) ?_\n  rintro - ⟨hm, ⟨m, rfl⟩⟩\n  simp only [← comap_genWeightSpace_eq_of_injective hf, LieSubmodule.mem_map,\n    LieSubmodule.mem_comap]\n  exact ⟨m, hm, rfl⟩\n\n"}
{"name":"LieModule.map_genWeightSpace_eq","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : LieRing L\ninst✝⁹ : LieAlgebra R L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : LieRingModule L M\ninst✝⁵ : LieModule R L M\ninst✝⁴ : LieRing.IsNilpotent L\nM₂ : Type u_5\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : LieRingModule L M₂\ninst✝ : LieModule R L M₂\nχ : L → R\ne : LieModuleEquiv R L M M₂\n⊢ Eq (LieSubmodule.map e.toLieModuleHom (LieModule.genWeightSpace M χ)) (LieModule.genWeightSpace M₂ χ)","decl":"lemma map_genWeightSpace_eq (e : M ≃ₗ⁅R,L⁆ M₂) :\n    (genWeightSpace M χ).map e = genWeightSpace M₂ χ := by\n  simp [map_genWeightSpace_eq_of_injective e.injective]\n\n"}
{"name":"LieModule.map_posFittingComp_eq","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : LieRing L\ninst✝⁹ : LieAlgebra R L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : LieRingModule L M\ninst✝⁵ : LieModule R L M\ninst✝⁴ : LieRing.IsNilpotent L\nM₂ : Type u_5\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : LieRingModule L M₂\ninst✝ : LieModule R L M₂\ne : LieModuleEquiv R L M M₂\n⊢ Eq (LieSubmodule.map e.toLieModuleHom (LieModule.posFittingComp R L M)) (LieModule.posFittingComp R L M₂)","decl":"lemma map_posFittingComp_eq (e : M ≃ₗ⁅R,L⁆ M₂) :\n    (posFittingComp R L M).map e = posFittingComp R L M₂ := by\n  refine le_antisymm (map_posFittingComp_le _) ?_\n  suffices posFittingComp R L M₂ = ((posFittingComp R L M₂).map (e.symm : M₂ →ₗ⁅R,L⁆ M)).map e by\n    rw [this]\n    exact LieSubmodule.map_mono (map_posFittingComp_le _)\n  rw [← LieSubmodule.map_comp]\n  convert LieSubmodule.map_id\n  ext\n  simp\n\n"}
{"name":"LieModule.posFittingComp_map_incl_sup_of_codisjoint","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁹ : CommRing R\ninst✝⁸ : LieRing L\ninst✝⁷ : LieAlgebra R L\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : LieRingModule L M\ninst✝³ : LieModule R L M\ninst✝² : LieRing.IsNilpotent L\ninst✝¹ : IsNoetherian R M\ninst✝ : IsArtinian R M\nN₁ N₂ : LieSubmodule R L M\nh : Codisjoint N₁ N₂\n⊢ Eq (Max.max (LieSubmodule.map N₁.incl (LieModule.posFittingComp R L (Subtype fun x => Membership.mem N₁ x))) (LieSubmodule.map N₂.incl (LieModule.posFittingComp R L (Subtype fun x => Membership.mem N₂ x)))) (LieModule.posFittingComp R L M)","decl":"lemma posFittingComp_map_incl_sup_of_codisjoint [IsNoetherian R M] [IsArtinian R M]\n    {N₁ N₂ : LieSubmodule R L M} (h : Codisjoint N₁ N₂) :\n    (posFittingComp R L N₁).map N₁.incl ⊔ (posFittingComp R L N₂).map N₂.incl =\n    posFittingComp R L M := by\n  obtain ⟨l, hl⟩ := Filter.eventually_atTop.mp <|\n    (eventually_iInf_lowerCentralSeries_eq R L N₁).and <|\n    (eventually_iInf_lowerCentralSeries_eq R L N₂).and\n    (eventually_iInf_lowerCentralSeries_eq R L M)\n  obtain ⟨hl₁, hl₂, hl₃⟩ := hl l (le_refl _)\n  simp_rw [← iInf_lowerCentralSeries_eq_posFittingComp, hl₁, hl₂, hl₃,\n    LieSubmodule.lowerCentralSeries_map_eq_lcs, ← LieSubmodule.lcs_sup, lowerCentralSeries,\n    h.eq_top]\n\n"}
{"name":"LieModule.genWeightSpace_genWeightSpaceOf_map_incl","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nx : L\nχ : L → R\n⊢ Eq (LieSubmodule.map (LieModule.genWeightSpaceOf M (χ x) x).incl (LieModule.genWeightSpace (Subtype fun x_1 => Membership.mem (LieModule.genWeightSpaceOf M (χ x) x) x_1) χ)) (LieModule.genWeightSpace M χ)","decl":"lemma genWeightSpace_genWeightSpaceOf_map_incl (x : L) (χ : L → R) :\n    (genWeightSpace (genWeightSpaceOf M (χ x) x) χ).map (genWeightSpaceOf M (χ x) x).incl =\n    genWeightSpace M χ := by\n  simpa [map_genWeightSpace_eq_of_injective (genWeightSpaceOf M (χ x) x).injective_incl]\n    using genWeightSpace_le_genWeightSpaceOf M x χ\n\n"}
{"name":"LieModule.isCompl_genWeightSpaceOf_zero_posFittingCompOf","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁹ : CommRing R\ninst✝⁸ : LieRing L\ninst✝⁷ : LieAlgebra R L\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : LieRingModule L M\ninst✝³ : LieModule R L M\ninst✝² : LieRing.IsNilpotent L\ninst✝¹ : IsNoetherian R M\ninst✝ : IsArtinian R M\nx : L\n⊢ IsCompl (LieModule.genWeightSpaceOf M 0 x) (LieModule.posFittingCompOf R M x)","decl":"lemma isCompl_genWeightSpaceOf_zero_posFittingCompOf (x : L) :\n    IsCompl (genWeightSpaceOf M 0 x) (posFittingCompOf R M x) := by\n  simpa only [isCompl_iff, codisjoint_iff, disjoint_iff, ← LieSubmodule.toSubmodule_inj,\n    LieSubmodule.sup_toSubmodule, LieSubmodule.inf_toSubmodule,\n    LieSubmodule.top_toSubmodule, LieSubmodule.bot_toSubmodule, coe_genWeightSpaceOf_zero] using\n    (toEnd R L M x).isCompl_iSup_ker_pow_iInf_range_pow\n\n"}
{"name":"LieModule.isCompl_genWeightSpace_zero_posFittingComp","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁹ : CommRing R\ninst✝⁸ : LieRing L\ninst✝⁷ : LieAlgebra R L\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : LieRingModule L M\ninst✝³ : LieModule R L M\ninst✝² : LieRing.IsNilpotent L\ninst✝¹ : IsNoetherian R M\ninst✝ : IsArtinian R M\n⊢ IsCompl (LieModule.genWeightSpace M 0) (LieModule.posFittingComp R L M)","decl":"/-- This is the Fitting decomposition of the Lie module `M`. -/\nlemma isCompl_genWeightSpace_zero_posFittingComp :\n    IsCompl (genWeightSpace M 0) (posFittingComp R L M) := by\n  let P : LieSubmodule R L M → Prop := fun N ↦ IsCompl (genWeightSpace N 0) (posFittingComp R L N)\n  suffices P ⊤ by\n    let e := LieModuleEquiv.ofTop R L M\n    rw [← map_genWeightSpace_eq e, ← map_posFittingComp_eq e]\n    exact (LieSubmodule.orderIsoMapComap e).isCompl_iff.mp this\n  refine (LieSubmodule.wellFoundedLT_of_isArtinian R L M).induction (C := P) _ fun N hN ↦ ?_\n  refine isCompl_genWeightSpace_zero_posFittingComp_aux R L N fun N' hN' ↦ ?_\n  suffices IsCompl (genWeightSpace (N'.map N.incl) 0) (posFittingComp R L (N'.map N.incl)) by\n    let e := LieSubmodule.equivMapOfInjective N' N.injective_incl\n    rw [← map_genWeightSpace_eq e, ← map_posFittingComp_eq e] at this\n    exact (LieSubmodule.orderIsoMapComap e).isCompl_iff.mpr this\n  exact hN _ (LieSubmodule.map_incl_lt_iff_lt_top.mpr hN')\n\n"}
{"name":"LieModule.disjoint_genWeightSpaceOf","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : NoZeroSMulDivisors R M\nx : L\nφ₁ φ₂ : R\nh : Ne φ₁ φ₂\n⊢ Disjoint (LieModule.genWeightSpaceOf M φ₁ x) (LieModule.genWeightSpaceOf M φ₂ x)","decl":"lemma disjoint_genWeightSpaceOf [NoZeroSMulDivisors R M] {x : L} {φ₁ φ₂ : R} (h : φ₁ ≠ φ₂) :\n    Disjoint (genWeightSpaceOf M φ₁ x) (genWeightSpaceOf M φ₂ x) := by\n  rw [LieSubmodule.disjoint_iff_toSubmodule]\n  dsimp [genWeightSpaceOf]\n  exact Module.End.disjoint_genEigenspace _ h _ _\n\n"}
{"name":"LieModule.disjoint_genWeightSpace","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : NoZeroSMulDivisors R M\nχ₁ χ₂ : L → R\nh : Ne χ₁ χ₂\n⊢ Disjoint (LieModule.genWeightSpace M χ₁) (LieModule.genWeightSpace M χ₂)","decl":"lemma disjoint_genWeightSpace [NoZeroSMulDivisors R M] {χ₁ χ₂ : L → R} (h : χ₁ ≠ χ₂) :\n    Disjoint (genWeightSpace M χ₁) (genWeightSpace M χ₂) := by\n  obtain ⟨x, hx⟩ : ∃ x, χ₁ x ≠ χ₂ x := Function.ne_iff.mp h\n  exact (disjoint_genWeightSpaceOf R L M hx).mono\n    (genWeightSpace_le_genWeightSpaceOf M x χ₁) (genWeightSpace_le_genWeightSpaceOf M x χ₂)\n\n"}
{"name":"LieModule.injOn_genWeightSpace","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : NoZeroSMulDivisors R M\n⊢ Set.InjOn (fun χ => LieModule.genWeightSpace M χ) (setOf fun χ => Ne (LieModule.genWeightSpace M χ) Bot.bot)","decl":"lemma injOn_genWeightSpace [NoZeroSMulDivisors R M] :\n    InjOn (fun (χ : L → R) ↦ genWeightSpace M χ) {χ | genWeightSpace M χ ≠ ⊥} := by\n  rintro χ₁ _ χ₂ hχ₂ (hχ₁₂ : genWeightSpace M χ₁ = genWeightSpace M χ₂)\n  contrapose! hχ₂\n  simpa [hχ₁₂] using disjoint_genWeightSpace R L M hχ₂\n\n"}
{"name":"LieModule.iSupIndep_genWeightSpace","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : NoZeroSMulDivisors R M\n⊢ iSupIndep fun χ => LieModule.genWeightSpace M χ","decl":"/-- Lie module weight spaces are independent.\n\nSee also `LieModule.iSupIndep_genWeightSpace'`. -/\nlemma iSupIndep_genWeightSpace [NoZeroSMulDivisors R M] :\n    iSupIndep fun χ : L → R ↦ genWeightSpace M χ := by\n  simp only [LieSubmodule.iSupIndep_iff_toSubmodule, genWeightSpace,\n    LieSubmodule.iInf_toSubmodule]\n  exact Module.End.independent_iInf_maxGenEigenspace_of_forall_mapsTo (toEnd R L M)\n    (fun x y φ z ↦ (genWeightSpaceOf M φ y).lie_mem)\n\n"}
{"name":"LieModule.independent_genWeightSpace","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : NoZeroSMulDivisors R M\n⊢ iSupIndep fun χ => LieModule.genWeightSpace M χ","decl":"@[deprecated (since := \"2024-11-24\")] alias independent_genWeightSpace := iSupIndep_genWeightSpace\n\n"}
{"name":"LieModule.iSupIndep_genWeightSpace'","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : NoZeroSMulDivisors R M\n⊢ iSupIndep fun χ => LieModule.genWeightSpace M ⇑χ","decl":"lemma iSupIndep_genWeightSpace' [NoZeroSMulDivisors R M] :\n    iSupIndep fun χ : Weight R L M ↦ genWeightSpace M χ :=\n  (iSupIndep_genWeightSpace R L M).comp <|\n    Subtype.val_injective.comp (Weight.equivSetOf R L M).injective\n\n"}
{"name":"LieModule.independent_genWeightSpace'","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : NoZeroSMulDivisors R M\n⊢ iSupIndep fun χ => LieModule.genWeightSpace M ⇑χ","decl":"@[deprecated (since := \"2024-11-24\")] alias independent_genWeightSpace' := iSupIndep_genWeightSpace'\n\n"}
{"name":"LieModule.iSupIndep_genWeightSpaceOf","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : NoZeroSMulDivisors R M\nx : L\n⊢ iSupIndep fun χ => LieModule.genWeightSpaceOf M χ x","decl":"lemma iSupIndep_genWeightSpaceOf [NoZeroSMulDivisors R M] (x : L) :\n    iSupIndep fun (χ : R) ↦ genWeightSpaceOf M χ x := by\n  rw [LieSubmodule.iSupIndep_iff_toSubmodule]\n  dsimp [genWeightSpaceOf]\n  exact (toEnd R L M x).independent_genEigenspace _\n\n"}
{"name":"LieModule.independent_genWeightSpaceOf","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : NoZeroSMulDivisors R M\nx : L\n⊢ iSupIndep fun χ => LieModule.genWeightSpaceOf M χ x","decl":"@[deprecated (since := \"2024-11-24\")]\nalias independent_genWeightSpaceOf := iSupIndep_genWeightSpaceOf\n\n"}
{"name":"LieModule.finite_genWeightSpaceOf_ne_bot","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁹ : CommRing R\ninst✝⁸ : LieRing L\ninst✝⁷ : LieAlgebra R L\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : LieRingModule L M\ninst✝³ : LieModule R L M\ninst✝² : LieRing.IsNilpotent L\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nx : L\n⊢ (setOf fun χ => Ne (LieModule.genWeightSpaceOf M χ x) Bot.bot).Finite","decl":"lemma finite_genWeightSpaceOf_ne_bot [NoZeroSMulDivisors R M] [IsNoetherian R M] (x : L) :\n    {χ : R | genWeightSpaceOf M χ x ≠ ⊥}.Finite :=\n  WellFoundedGT.finite_ne_bot_of_iSupIndep (iSupIndep_genWeightSpaceOf R L M x)\n\n"}
{"name":"LieModule.finite_genWeightSpace_ne_bot","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁹ : CommRing R\ninst✝⁸ : LieRing L\ninst✝⁷ : LieAlgebra R L\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : LieRingModule L M\ninst✝³ : LieModule R L M\ninst✝² : LieRing.IsNilpotent L\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\n⊢ (setOf fun χ => Ne (LieModule.genWeightSpace M χ) Bot.bot).Finite","decl":"lemma finite_genWeightSpace_ne_bot [NoZeroSMulDivisors R M] [IsNoetherian R M] :\n    {χ : L → R | genWeightSpace M χ ≠ ⊥}.Finite :=\n  WellFoundedGT.finite_ne_bot_of_iSupIndep (iSupIndep_genWeightSpace R L M)\n\n"}
{"name":"LieModule.Weight.instFinite","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁹ : CommRing R\ninst✝⁸ : LieRing L\ninst✝⁷ : LieAlgebra R L\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : LieRingModule L M\ninst✝³ : LieModule R L M\ninst✝² : LieRing.IsNilpotent L\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\n⊢ Finite (LieModule.Weight R L M)","decl":"instance Weight.instFinite [NoZeroSMulDivisors R M] [IsNoetherian R M] :\n    Finite (Weight R L M) := by\n  have : Finite {χ : L → R | genWeightSpace M χ ≠ ⊥} := finite_genWeightSpace_ne_bot R L M\n  exact Finite.of_injective (equivSetOf R L M) (equivSetOf R L M).injective\n\n"}
{"name":"LieModule.IsTriangularizable.maxGenEigenspace_eq_top","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nself : LieModule.IsTriangularizable R L M\nx : L\n⊢ Eq (iSup fun φ => ((LieModule.toEnd R L M) x).maxGenEigenspace φ) Top.top","decl":"/-- A Lie module `M` of a Lie algebra `L` is triangularizable if the endomorphism of `M` defined by\nany `x : L` is triangularizable. -/\nclass IsTriangularizable : Prop where\n  maxGenEigenspace_eq_top : ∀ x, ⨆ φ, (toEnd R L M x).maxGenEigenspace φ = ⊤\n\n"}
{"name":"LieModule.instIsTriangularizableSubtypeMemLieSubalgebra","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\nL' : LieSubalgebra R L\ninst✝ : LieModule.IsTriangularizable R L M\n⊢ LieModule.IsTriangularizable R (Subtype fun x => Membership.mem L' x) M","decl":"instance (L' : LieSubalgebra R L) [IsTriangularizable R L M] : IsTriangularizable R L' M where\n  maxGenEigenspace_eq_top x := IsTriangularizable.maxGenEigenspace_eq_top (x : L)\n\n"}
{"name":"LieModule.instIsTriangularizableSubtypeMemLieSubmodule","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\nI : LieIdeal R L\ninst✝ : LieModule.IsTriangularizable R L M\n⊢ LieModule.IsTriangularizable R (Subtype fun x => Membership.mem I x) M","decl":"instance (I : LieIdeal R L) [IsTriangularizable R L M] : IsTriangularizable R I M where\n  maxGenEigenspace_eq_top x := IsTriangularizable.maxGenEigenspace_eq_top (x : L)\n\n"}
{"name":"LieModule.instIsTriangularizableSubtypeEndMemLieSubalgebraRangeToEnd","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieModule.IsTriangularizable R L M\n⊢ LieModule.IsTriangularizable R (Subtype fun x => Membership.mem (LieModule.toEnd R L M).range x) M","decl":"instance [IsTriangularizable R L M] : IsTriangularizable R (LieModule.toEnd R L M).range M where\n  maxGenEigenspace_eq_top := by\n    rintro ⟨-, x, rfl⟩\n    exact IsTriangularizable.maxGenEigenspace_eq_top x\n\n"}
{"name":"LieModule.iSup_genWeightSpaceOf_eq_top","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : LieModule.IsTriangularizable R L M\nx : L\n⊢ Eq (iSup fun φ => LieModule.genWeightSpaceOf M φ x) Top.top","decl":"@[simp]\nlemma iSup_genWeightSpaceOf_eq_top [IsTriangularizable R L M] (x : L) :\n    ⨆ (φ : R), genWeightSpaceOf M φ x = ⊤ := by\n  rw [← LieSubmodule.toSubmodule_inj, LieSubmodule.iSup_toSubmodule,\n    LieSubmodule.top_toSubmodule]\n  dsimp [genWeightSpaceOf]\n  exact IsTriangularizable.maxGenEigenspace_eq_top x\n\n"}
{"name":"LieModule.trace_toEnd_genWeightSpace","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : LieRing L\ninst✝⁹ : LieAlgebra R L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : LieRingModule L M\ninst✝⁵ : LieModule R L M\ninst✝⁴ : LieRing.IsNilpotent L\ninst✝³ : IsDomain R\ninst✝² : IsPrincipalIdealRing R\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\nχ : L → R\nx : L\n⊢ Eq ((LinearMap.trace R (Subtype fun x => Membership.mem (LieModule.genWeightSpace M χ) x)) ((LieModule.toEnd R L (Subtype fun x => Membership.mem (LieModule.genWeightSpace M χ) x)) x)) (HSMul.hSMul (Module.finrank R (Subtype fun x => Membership.mem (LieModule.genWeightSpace M χ) x)) (χ x))","decl":"open LinearMap Module in\n@[simp]\nlemma trace_toEnd_genWeightSpace [IsDomain R] [IsPrincipalIdealRing R]\n    [Module.Free R M] [Module.Finite R M] (χ : L → R) (x : L) :\n    trace R _ (toEnd R L (genWeightSpace M χ) x) = finrank R (genWeightSpace M χ) • χ x := by\n  suffices _root_.IsNilpotent ((toEnd R L (genWeightSpace M χ) x) - χ x • LinearMap.id) by\n    replace this := (isNilpotent_trace_of_isNilpotent this).eq_zero\n    rwa [map_sub, map_smul, trace_id, sub_eq_zero, smul_eq_mul, mul_comm,\n      ← nsmul_eq_mul] at this\n  rw [← Module.algebraMap_end_eq_smul_id]\n  exact isNilpotent_toEnd_sub_algebraMap M χ x\n\n"}
{"name":"LieModule.instIsTriangularizableOfIsAlgClosed","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"K : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝⁸ : LieRing L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : LieRingModule L M\ninst✝⁵ : Field K\ninst✝⁴ : LieAlgebra K L\ninst✝³ : Module K M\ninst✝² : LieModule K L M\ninst✝¹ : FiniteDimensional K M\ninst✝ : IsAlgClosed K\n⊢ LieModule.IsTriangularizable K L M","decl":"instance instIsTriangularizableOfIsAlgClosed [IsAlgClosed K] : IsTriangularizable K L M :=\n  ⟨fun _ ↦ Module.End.iSup_maxGenEigenspace_eq_top _⟩\n\n"}
{"name":"LieModule.instIsTriangularizableSubtypeMemLieSubmodule_1","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"K : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝⁷ : LieRing L\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : Field K\ninst✝³ : LieAlgebra K L\ninst✝² : Module K M\ninst✝¹ : LieModule K L M\nN : LieSubmodule K L M\ninst✝ : LieModule.IsTriangularizable K L M\n⊢ LieModule.IsTriangularizable K L (Subtype fun x => Membership.mem N x)","decl":"instance (N : LieSubmodule K L M) [IsTriangularizable K L M] : IsTriangularizable K L N := by\n  refine ⟨fun y ↦ ?_⟩\n  rw [← N.toEnd_restrict_eq_toEnd y]\n  exact Module.End.genEigenspace_restrict_eq_top _ (IsTriangularizable.maxGenEigenspace_eq_top y)\n\n"}
{"name":"LieModule.iSup_genWeightSpace_eq_top","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"K : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝⁹ : LieRing L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : LieRingModule L M\ninst✝⁶ : LieRing.IsNilpotent L\ninst✝⁵ : Field K\ninst✝⁴ : LieAlgebra K L\ninst✝³ : Module K M\ninst✝² : LieModule K L M\ninst✝¹ : FiniteDimensional K M\ninst✝ : LieModule.IsTriangularizable K L M\n⊢ Eq (iSup fun χ => LieModule.genWeightSpace M χ) Top.top","decl":"/-- For a triangularizable Lie module in finite dimensions, the weight spaces span the entire space.\n\nSee also `LieModule.iSup_genWeightSpace_eq_top'`. -/\nlemma iSup_genWeightSpace_eq_top [IsTriangularizable K L M] :\n    ⨆ χ : L → K, genWeightSpace M χ = ⊤ := by\n  simp only [← LieSubmodule.toSubmodule_inj, LieSubmodule.iSup_toSubmodule,\n    LieSubmodule.iInf_toSubmodule, LieSubmodule.top_toSubmodule, genWeightSpace]\n  refine Module.End.iSup_iInf_maxGenEigenspace_eq_top_of_forall_mapsTo (toEnd K L M)\n    (fun x y φ z ↦ (genWeightSpaceOf M φ y).lie_mem) ?_\n  apply IsTriangularizable.maxGenEigenspace_eq_top\n\n"}
{"name":"LieModule.iSup_genWeightSpace_eq_top'","module":"Mathlib.Algebra.Lie.Weights.Basic","initialProofState":"K : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝⁹ : LieRing L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : LieRingModule L M\ninst✝⁶ : LieRing.IsNilpotent L\ninst✝⁵ : Field K\ninst✝⁴ : LieAlgebra K L\ninst✝³ : Module K M\ninst✝² : LieModule K L M\ninst✝¹ : FiniteDimensional K M\ninst✝ : LieModule.IsTriangularizable K L M\n⊢ Eq (iSup fun χ => LieModule.genWeightSpace M ⇑χ) Top.top","decl":"lemma iSup_genWeightSpace_eq_top' [IsTriangularizable K L M] :\n    ⨆ χ : Weight K L M, genWeightSpace M χ = ⊤ := by\n  have := iSup_genWeightSpace_eq_top K L M\n  erw [← iSup_ne_bot_subtype, ← (Weight.equivSetOf K L M).iSup_comp] at this\n  exact this\n\n"}
