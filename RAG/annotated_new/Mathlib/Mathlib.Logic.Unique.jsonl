{"name":"Unique.mk.sizeOf_spec","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u\ninst✝ : SizeOf α\ntoInhabited : Inhabited α\nuniq : ∀ (a : α), Eq a Inhabited.default\n⊢ Eq (SizeOf.sizeOf { toInhabited := toInhabited, uniq := uniq }) (HAdd.hAdd 1 (SizeOf.sizeOf toInhabited))","decl":"set_option genInjectivity false in\n/-- `Unique α` expresses that `α` is a type with a unique term `default`.\n\nThis is implemented as a type, rather than a `Prop`-valued predicate,\nfor good definitional properties of the default term. -/\n@[ext]\nstructure Unique (α : Sort u) extends Inhabited α where\n  /-- In a `Unique` type, every term is equal to the default element (from `Inhabited`). -/\n  uniq : ∀ a : α, a = default\n\n"}
{"name":"Unique.ext","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u\nx y : Unique α\ndefault : Eq Inhabited.default Inhabited.default\n⊢ Eq x y","decl":"set_option genInjectivity false in\n/-- `Unique α` expresses that `α` is a type with a unique term `default`.\n\nThis is implemented as a type, rather than a `Prop`-valued predicate,\nfor good definitional properties of the default term. -/\n@[ext]\nstructure Unique (α : Sort u) extends Inhabited α where\n  /-- In a `Unique` type, every term is equal to the default element (from `Inhabited`). -/\n  uniq : ∀ a : α, a = default\n\n"}
{"name":"Unique.ext_iff","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u\nx y : Unique α\n⊢ Iff (Eq x y) (Eq Inhabited.default Inhabited.default)","decl":"set_option genInjectivity false in\n/-- `Unique α` expresses that `α` is a type with a unique term `default`.\n\nThis is implemented as a type, rather than a `Prop`-valued predicate,\nfor good definitional properties of the default term. -/\n@[ext]\nstructure Unique (α : Sort u) extends Inhabited α where\n  /-- In a `Unique` type, every term is equal to the default element (from `Inhabited`). -/\n  uniq : ∀ a : α, a = default\n\n"}
{"name":"Unique.uniq","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u\nself : Unique α\na : α\n⊢ Eq a Inhabited.default","decl":"set_option genInjectivity false in\n/-- `Unique α` expresses that `α` is a type with a unique term `default`.\n\nThis is implemented as a type, rather than a `Prop`-valued predicate,\nfor good definitional properties of the default term. -/\n@[ext]\nstructure Unique (α : Sort u) extends Inhabited α where\n  /-- In a `Unique` type, every term is equal to the default element (from `Inhabited`). -/\n  uniq : ∀ a : α, a = default\n\n"}
{"name":"unique_iff_existsUnique","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u\n⊢ Iff (Nonempty (Unique α)) (ExistsUnique fun x => True)","decl":"theorem unique_iff_existsUnique (α : Sort u) : Nonempty (Unique α) ↔ ∃! _ : α, True :=\n  ⟨fun ⟨u⟩ ↦ ⟨u.default, trivial, fun a _ ↦ u.uniq a⟩,\n   fun ⟨a, _, h⟩ ↦ ⟨⟨⟨a⟩, fun _ ↦ h _ trivial⟩⟩⟩\n\n"}
{"name":"unique_iff_exists_unique","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u\n⊢ Iff (Nonempty (Unique α)) (ExistsUnique fun x => True)","decl":"@[deprecated (since := \"2024-12-17\")] alias unique_iff_exists_unique := unique_iff_existsUnique\n\n"}
{"name":"unique_subtype_iff_existsUnique","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u_1\np : α → Prop\n⊢ Iff (Nonempty (Unique (Subtype p))) (ExistsUnique fun a => p a)","decl":"theorem unique_subtype_iff_existsUnique {α} (p : α → Prop) :\n    Nonempty (Unique (Subtype p)) ↔ ∃! a, p a :=\n  ⟨fun ⟨u⟩ ↦ ⟨u.default.1, u.default.2, fun a h ↦ congr_arg Subtype.val (u.uniq ⟨a, h⟩)⟩,\n   fun ⟨a, ha, he⟩ ↦ ⟨⟨⟨⟨a, ha⟩⟩, fun ⟨b, hb⟩ ↦ by\n      congr\n      exact he b hb⟩⟩⟩\n\n"}
{"name":"unique_subtype_iff_exists_unique","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u_1\np : α → Prop\n⊢ Iff (Nonempty (Unique (Subtype p))) (ExistsUnique fun a => p a)","decl":"@[deprecated (since := \"2024-12-17\")]\nalias unique_subtype_iff_exists_unique := unique_subtype_iff_existsUnique\n\n"}
{"name":"PUnit.default_eq_unit","module":"Mathlib.Logic.Unique","initialProofState":"⊢ Eq Inhabited.default PUnit.unit","decl":"@[simp]\ntheorem PUnit.default_eq_unit : (default : PUnit) = PUnit.unit :=\n  rfl\n\n"}
{"name":"Unique.eq_default","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u_1\ninst✝ : Unique α\na : α\n⊢ Eq a Inhabited.default","decl":"theorem eq_default (a : α) : a = default :=\n  uniq _ a\n\n"}
{"name":"Unique.default_eq","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u_1\ninst✝ : Unique α\na : α\n⊢ Eq Inhabited.default a","decl":"theorem default_eq (a : α) : default = a :=\n  (uniq _ a).symm\n\n-- see Note [lower instance priority]\n"}
{"name":"Unique.instSubsingleton","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u_1\ninst✝ : Unique α\n⊢ Subsingleton α","decl":"instance (priority := 100) instSubsingleton : Subsingleton α :=\n  subsingleton_of_forall_eq _ eq_default\n\n"}
{"name":"Unique.forall_iff","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u_1\ninst✝ : Unique α\np : α → Prop\n⊢ Iff (∀ (a : α), p a) (p Inhabited.default)","decl":"theorem forall_iff {p : α → Prop} : (∀ a, p a) ↔ p default :=\n  ⟨fun h ↦ h _, fun h x ↦ by rwa [Unique.eq_default x]⟩\n\n"}
{"name":"Unique.exists_iff","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u_1\ninst✝ : Unique α\np : α → Prop\n⊢ Iff (Exists p) (p Inhabited.default)","decl":"theorem exists_iff {p : α → Prop} : Exists p ↔ p default :=\n  ⟨fun ⟨a, ha⟩ ↦ eq_default a ▸ ha, Exists.intro default⟩\n\n"}
{"name":"Unique.subsingleton_unique'","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u_1\nh₁ h₂ : Unique α\n⊢ Eq h₁ h₂","decl":"@[ext]\nprotected theorem subsingleton_unique' : ∀ h₁ h₂ : Unique α, h₁ = h₂\n  | ⟨⟨x⟩, h⟩, ⟨⟨y⟩, _⟩ => by congr; rw [h x, h y]\n\n"}
{"name":"Unique.subsingleton_unique'_iff","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u_1\nh₁ h₂ : Unique α\n⊢ Iff (Eq h₁ h₂) True","decl":"@[ext]\nprotected theorem subsingleton_unique' : ∀ h₁ h₂ : Unique α, h₁ = h₂\n  | ⟨⟨x⟩, h⟩, ⟨⟨y⟩, _⟩ => by congr; rw [h x, h y]\n\n"}
{"name":"Unique.subsingleton_unique","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u_1\n⊢ Subsingleton (Unique α)","decl":"instance subsingleton_unique : Subsingleton (Unique α) :=\n  ⟨Unique.subsingleton_unique'⟩\n\n"}
{"name":"nonempty_unique","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u\ninst✝¹ : Subsingleton α\ninst✝ : Nonempty α\n⊢ Nonempty (Unique α)","decl":"theorem nonempty_unique (α : Sort u) [Subsingleton α] [Nonempty α] : Nonempty (Unique α) := by\n  inhabit α\n  exact ⟨Unique.mk' α⟩\n\n"}
{"name":"unique_iff_subsingleton_and_nonempty","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u\n⊢ Iff (Nonempty (Unique α)) (And (Subsingleton α) (Nonempty α))","decl":"theorem unique_iff_subsingleton_and_nonempty (α : Sort u) :\n    Nonempty (Unique α) ↔ Subsingleton α ∧ Nonempty α :=\n  ⟨fun ⟨u⟩ ↦ by constructor <;> exact inferInstance,\n   fun ⟨hs, hn⟩ ↦ nonempty_unique α⟩\n\n"}
{"name":"Pi.default_def","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u_1\nβ : α → Sort v\ninst✝ : (a : α) → Inhabited (β a)\n⊢ Eq Inhabited.default fun a => Inhabited.default","decl":"@[simp]\ntheorem Pi.default_def {β : α → Sort v} [∀ a, Inhabited (β a)] :\n    @default (∀ a, β a) _ = fun a : α ↦ @default (β a) _ :=\n  rfl\n\n"}
{"name":"Pi.default_apply","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u_1\nβ : α → Sort v\ninst✝ : (a : α) → Inhabited (β a)\na : α\n⊢ Eq (Inhabited.default a) Inhabited.default","decl":"theorem Pi.default_apply {β : α → Sort v} [∀ a, Inhabited (β a)] (a : α) :\n    @default (∀ a, β a) _ a = default :=\n  rfl\n\n"}
{"name":"eq_const_of_subsingleton","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝ : Subsingleton α\nf : α → β\na : α\n⊢ Eq f (Function.const α (f a))","decl":"theorem eq_const_of_subsingleton {β : Sort*} [Subsingleton α] (f : α → β) (a : α) :\n    f = Function.const α (f a) :=\n  funext fun x ↦ Subsingleton.elim x a ▸ rfl\n\n"}
{"name":"eq_const_of_unique","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝ : Unique α\nf : α → β\n⊢ Eq f (Function.const α (f Inhabited.default))","decl":"theorem eq_const_of_unique {β : Sort*} [Unique α] (f : α → β) : f = Function.const α (f default) :=\n  eq_const_of_subsingleton ..\n\n"}
{"name":"heq_const_of_unique","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u_1\ninst✝ : Unique α\nβ : α → Sort v\nf : (a : α) → β a\n⊢ HEq f (Function.const α (f Inhabited.default))","decl":"theorem heq_const_of_unique [Unique α] {β : α → Sort v} (f : ∀ a, β a) :\n    HEq f (Function.const α (f default)) :=\n  (Function.hfunext rfl) fun i _ _ ↦ by rw [Subsingleton.elim i default]; rfl\n\n"}
{"name":"Function.Injective.subsingleton","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\nhf : Function.Injective f\ninst✝ : Subsingleton β\n⊢ Subsingleton α","decl":"/-- If the codomain of an injective function is a subsingleton, then the domain\nis a subsingleton as well. -/\nprotected theorem Injective.subsingleton (hf : Injective f) [Subsingleton β] : Subsingleton α :=\n  ⟨fun _ _ ↦ hf <| Subsingleton.elim _ _⟩\n\n"}
{"name":"Function.Surjective.subsingleton","module":"Mathlib.Logic.Unique","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\ninst✝ : Subsingleton α\nhf : Function.Surjective f\n⊢ Subsingleton β","decl":"/-- If the domain of a surjective function is a subsingleton, then the codomain is a subsingleton as\nwell. -/\nprotected theorem Surjective.subsingleton [Subsingleton α] (hf : Surjective f) : Subsingleton β :=\n  ⟨hf.forall₂.2 fun x y ↦ congr_arg f <| Subsingleton.elim x y⟩\n\n"}
{"name":"uniqueElim_default","module":"Mathlib.Logic.Unique","initialProofState":"ι : Sort u_2\nα : ι → Sort u_3\nx✝ : Unique ι\nx : α Inhabited.default\n⊢ Eq (uniqueElim x Inhabited.default) x","decl":"@[simp]\ntheorem uniqueElim_default {_ : Unique ι} (x : α (default : ι)) : uniqueElim x (default : ι) = x :=\n  rfl\n\n"}
{"name":"uniqueElim_const","module":"Mathlib.Logic.Unique","initialProofState":"ι : Sort u_2\nβ : Sort u_4\nx✝ : Unique ι\nx : β\ni : ι\n⊢ Eq (uniqueElim x i) x","decl":"@[simp]\ntheorem uniqueElim_const {β : Sort*} {_ : Unique ι} (x : β) (i : ι) :\n    uniqueElim (α := fun _ ↦ β) x i = x :=\n  rfl\n\n"}
{"name":"Unique.bijective","module":"Mathlib.Logic.Unique","initialProofState":"A : Sort u_2\nB : Sort u_3\ninst✝¹ : Unique A\ninst✝ : Unique B\nf : A → B\n⊢ Function.Bijective f","decl":"attribute [local simp] eq_iff_true_of_subsingleton in\ntheorem Unique.bijective {A B} [Unique A] [Unique B] {f : A → B} : Function.Bijective f := by\n  rw [Function.bijective_iff_has_inverse]\n  refine ⟨default, ?_, ?_⟩ <;> intro x <;> simp\n\n"}
{"name":"Option.subsingleton_iff_isEmpty","module":"Mathlib.Logic.Unique","initialProofState":"α : Type u\n⊢ Iff (Subsingleton (Option α)) (IsEmpty α)","decl":"/-- `Option α` is a `Subsingleton` if and only if `α` is empty. -/\ntheorem subsingleton_iff_isEmpty {α : Type u} : Subsingleton (Option α) ↔ IsEmpty α :=\n  ⟨fun h ↦ ⟨fun x ↦ Option.noConfusion <| @Subsingleton.elim _ h x none⟩,\n   fun h ↦ ⟨fun x y ↦\n     Option.casesOn x (Option.casesOn y rfl fun x ↦ h.elim x) fun x ↦ h.elim x⟩⟩\n\n"}
