{"name":"PosNum.cast_one","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝¹ : One α\ninst✝ : Add α\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem cast_one [One α] [Add α] : ((1 : PosNum) : α) = 1 :=\n  rfl\n\n"}
{"name":"PosNum.cast_one'","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝¹ : One α\ninst✝ : Add α\n⊢ Eq (↑PosNum.one) 1","decl":"@[simp]\ntheorem cast_one' [One α] [Add α] : (PosNum.one : α) = 1 :=\n  rfl\n\n"}
{"name":"PosNum.cast_bit0","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝¹ : One α\ninst✝ : Add α\nn : PosNum\n⊢ Eq (↑n.bit0) (HAdd.hAdd ↑n ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_bit0 [One α] [Add α] (n : PosNum) : (n.bit0 : α) = (n : α) + n :=\n  rfl\n\n"}
{"name":"PosNum.cast_bit1","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝¹ : One α\ninst✝ : Add α\nn : PosNum\n⊢ Eq (↑n.bit1) (HAdd.hAdd (HAdd.hAdd ↑n ↑n) 1)","decl":"@[simp, norm_cast]\ntheorem cast_bit1 [One α] [Add α] (n : PosNum) : (n.bit1 : α) = ((n : α) + n) + 1 :=\n  rfl\n\n"}
{"name":"PosNum.cast_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : AddMonoidWithOne α\nn : PosNum\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast]\ntheorem cast_to_nat [AddMonoidWithOne α] : ∀ n : PosNum, ((n : ℕ) : α) = n\n  | 1 => Nat.cast_one\n  | bit0 p => by dsimp; rw [Nat.cast_add, p.cast_to_nat]\n  | bit1 p => by dsimp; rw [Nat.cast_add, Nat.cast_add, Nat.cast_one, p.cast_to_nat]\n\n"}
{"name":"PosNum.to_nat_to_int","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\n⊢ Eq ↑↑n ↑n","decl":"@[norm_cast]\ntheorem to_nat_to_int (n : PosNum) : ((n : ℕ) : ℤ) = n :=\n  cast_to_nat _\n\n"}
{"name":"PosNum.cast_to_int","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : AddGroupWithOne α\nn : PosNum\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast]\ntheorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by\n  rw [← to_nat_to_int, Int.cast_natCast, cast_to_nat]\n\n"}
{"name":"PosNum.succ_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\n⊢ Eq (↑n.succ) (HAdd.hAdd (↑n) 1)","decl":"theorem succ_to_nat : ∀ n, (succ n : ℕ) = n + 1\n  | 1 => rfl\n  | bit0 _ => rfl\n  | bit1 p =>\n    (congr_arg (fun n ↦ n + n) (succ_to_nat p)).trans <|\n      show ↑p + 1 + ↑p + 1 = ↑p + ↑p + 1 + 1 by simp [add_left_comm]\n\n"}
{"name":"PosNum.one_add","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\n⊢ Eq (HAdd.hAdd 1 n) n.succ","decl":"theorem one_add (n : PosNum) : 1 + n = succ n := by cases n <;> rfl\n\n"}
{"name":"PosNum.add_one","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\n⊢ Eq (HAdd.hAdd n 1) n.succ","decl":"theorem add_one (n : PosNum) : n + 1 = succ n := by cases n <;> rfl\n\n"}
{"name":"PosNum.add_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : PosNum\n⊢ Eq (↑(HAdd.hAdd m n)) (HAdd.hAdd ↑m ↑n)","decl":"@[norm_cast]\ntheorem add_to_nat : ∀ m n, ((m + n : PosNum) : ℕ) = m + n\n  | 1, b => by rw [one_add b, succ_to_nat, add_comm, cast_one]\n  | a, 1 => by rw [add_one a, succ_to_nat, cast_one]\n  | bit0 a, bit0 b => (congr_arg (fun n ↦ n + n) (add_to_nat a b)).trans <| add_add_add_comm _ _ _ _\n  | bit0 a, bit1 b =>\n    (congr_arg (fun n ↦ (n + n) + 1) (add_to_nat a b)).trans <|\n      show (a + b + (a + b) + 1 : ℕ) = a + a + (b + b + 1) by simp [add_left_comm]\n  | bit1 a, bit0 b =>\n    (congr_arg (fun n ↦ (n + n) + 1) (add_to_nat a b)).trans <|\n      show (a + b + (a + b) + 1 : ℕ) = a + a + 1 + (b + b) by simp [add_comm, add_left_comm]\n  | bit1 a, bit1 b =>\n    show (succ (a + b) + succ (a + b) : ℕ) = a + a + 1 + (b + b + 1) by\n      rw [succ_to_nat, add_to_nat a b]; simp [add_left_comm]\n\n"}
{"name":"PosNum.add_succ","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : PosNum\n⊢ Eq (HAdd.hAdd m n.succ) (HAdd.hAdd m n).succ","decl":"theorem add_succ : ∀ m n : PosNum, m + succ n = succ (m + n)\n  | 1, b => by simp [one_add]\n  | bit0 a, 1 => congr_arg bit0 (add_one a)\n  | bit1 a, 1 => congr_arg bit1 (add_one a)\n  | bit0 _, bit0 _ => rfl\n  | bit0 a, bit1 b => congr_arg bit0 (add_succ a b)\n  | bit1 _, bit0 _ => rfl\n  | bit1 a, bit1 b => congr_arg bit1 (add_succ a b)\n\n"}
{"name":"PosNum.bit0_of_bit0","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\n⊢ Eq (HAdd.hAdd n n) n.bit0","decl":"theorem bit0_of_bit0 : ∀ n, n + n = bit0 n\n  | 1 => rfl\n  | bit0 p => congr_arg bit0 (bit0_of_bit0 p)\n  | bit1 p => show bit0 (succ (p + p)) = _ by rw [bit0_of_bit0 p, succ]\n\n"}
{"name":"PosNum.bit1_of_bit1","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\n⊢ Eq (HAdd.hAdd (HAdd.hAdd n n) 1) n.bit1","decl":"theorem bit1_of_bit1 (n : PosNum) : (n + n) + 1 = bit1 n :=\n  show (n + n) + 1 = bit1 n by rw [add_one, bit0_of_bit0, succ]\n\n"}
{"name":"PosNum.mul_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : PosNum\n⊢ Eq (↑(HMul.hMul m n)) (HMul.hMul ↑m ↑n)","decl":"@[norm_cast]\ntheorem mul_to_nat (m) : ∀ n, ((m * n : PosNum) : ℕ) = m * n\n  | 1 => (mul_one _).symm\n  | bit0 p => show (↑(m * p) + ↑(m * p) : ℕ) = ↑m * (p + p) by rw [mul_to_nat m p, left_distrib]\n  | bit1 p =>\n    (add_to_nat (bit0 (m * p)) m).trans <|\n      show (↑(m * p) + ↑(m * p) + ↑m : ℕ) = ↑m * (p + p) + m by rw [mul_to_nat m p, left_distrib]\n\n"}
{"name":"PosNum.to_nat_pos","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\n⊢ LT.lt 0 ↑n","decl":"theorem to_nat_pos : ∀ n : PosNum, 0 < (n : ℕ)\n  | 1 => Nat.zero_lt_one\n  | bit0 p =>\n    let h := to_nat_pos p\n    add_pos h h\n  | bit1 _p => Nat.succ_pos _\n\n"}
{"name":"PosNum.cmp_to_nat_lemma","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : PosNum\na✝ : LT.lt ↑m ↑n\n⊢ LT.lt ↑m.bit1 ↑n.bit0","decl":"theorem cmp_to_nat_lemma {m n : PosNum} : (m : ℕ) < n → (bit1 m : ℕ) < bit0 n :=\n  show (m : ℕ) < n → (m + m + 1 + 1 : ℕ) ≤ n + n by\n    intro h; rw [Nat.add_right_comm m m 1, add_assoc]; exact Nat.add_le_add h h\n\n"}
{"name":"PosNum.cmp_swap","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : PosNum\n⊢ Eq (m.cmp n).swap (n.cmp m)","decl":"theorem cmp_swap (m) : ∀ n, (cmp m n).swap = cmp n m := by\n  induction' m with m IH m IH <;> intro n <;> cases' n with n n <;> unfold cmp <;>\n    try { rfl } <;> rw [← IH] <;> cases cmp m n <;> rfl\n\n"}
{"name":"PosNum.cmp_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : PosNum\n⊢ Ordering.casesOn (m.cmp n) (LT.lt ↑m ↑n) (Eq m n) (LT.lt ↑n ↑m)","decl":"theorem cmp_to_nat : ∀ m n, (Ordering.casesOn (cmp m n) ((m : ℕ) < n) (m = n) ((n : ℕ) < m) : Prop)\n  | 1, 1 => rfl\n  | bit0 a, 1 =>\n    let h : (1 : ℕ) ≤ a := to_nat_pos a\n    Nat.add_le_add h h\n  | bit1 a, 1 => Nat.succ_lt_succ <| to_nat_pos <| bit0 a\n  | 1, bit0 b =>\n    let h : (1 : ℕ) ≤ b := to_nat_pos b\n    Nat.add_le_add h h\n  | 1, bit1 b => Nat.succ_lt_succ <| to_nat_pos <| bit0 b\n  | bit0 a, bit0 b => by\n    dsimp [cmp]\n    have := cmp_to_nat a b; revert this; cases cmp a b <;> dsimp <;> intro this\n    · exact Nat.add_lt_add this this\n    · rw [this]\n    · exact Nat.add_lt_add this this\n  | bit0 a, bit1 b => by\n    dsimp [cmp]\n    have := cmp_to_nat a b; revert this; cases cmp a b <;> dsimp <;> intro this\n    · exact Nat.le_succ_of_le (Nat.add_lt_add this this)\n    · rw [this]\n      apply Nat.lt_succ_self\n    · exact cmp_to_nat_lemma this\n  | bit1 a, bit0 b => by\n    dsimp [cmp]\n    have := cmp_to_nat a b; revert this; cases cmp a b <;> dsimp <;> intro this\n    · exact cmp_to_nat_lemma this\n    · rw [this]\n      apply Nat.lt_succ_self\n    · exact Nat.le_succ_of_le (Nat.add_lt_add this this)\n  | bit1 a, bit1 b => by\n    dsimp [cmp]\n    have := cmp_to_nat a b; revert this; cases cmp a b <;> dsimp <;> intro this\n    · exact Nat.succ_lt_succ (Nat.add_lt_add this this)\n    · rw [this]\n    · exact Nat.succ_lt_succ (Nat.add_lt_add this this)\n\n"}
{"name":"PosNum.lt_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : PosNum\n⊢ Iff (LT.lt ↑m ↑n) (LT.lt m n)","decl":"@[norm_cast]\ntheorem lt_to_nat {m n : PosNum} : (m : ℕ) < n ↔ m < n :=\n  show (m : ℕ) < n ↔ cmp m n = Ordering.lt from\n    match cmp m n, cmp_to_nat m n with\n    | Ordering.lt, h => by simp only at h; simp [h]\n    | Ordering.eq, h => by simp only at h; simp [h, lt_irrefl]\n    | Ordering.gt, h => by simp [not_lt_of_gt h]\n\n"}
{"name":"PosNum.le_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : PosNum\n⊢ Iff (LE.le ↑m ↑n) (LE.le m n)","decl":"@[norm_cast]\ntheorem le_to_nat {m n : PosNum} : (m : ℕ) ≤ n ↔ m ≤ n := by\n  rw [← not_lt]; exact not_congr lt_to_nat\n\n"}
{"name":"Num.add_zero","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq (HAdd.hAdd n 0) n","decl":"theorem add_zero (n : Num) : n + 0 = n := by cases n <;> rfl\n\n"}
{"name":"Num.zero_add","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq (HAdd.hAdd 0 n) n","decl":"theorem zero_add (n : Num) : 0 + n = n := by cases n <;> rfl\n\n"}
{"name":"Num.add_one","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq (HAdd.hAdd n 1) n.succ","decl":"theorem add_one : ∀ n : Num, n + 1 = succ n\n  | 0 => rfl\n  | pos p => by cases p <;> rfl\n\n"}
{"name":"Num.add_succ","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Num\n⊢ Eq (HAdd.hAdd m n.succ) (HAdd.hAdd m n).succ","decl":"theorem add_succ : ∀ m n : Num, m + succ n = succ (m + n)\n  | 0, n => by simp [zero_add]\n  | pos p, 0 => show pos (p + 1) = succ (pos p + 0) by rw [PosNum.add_one, add_zero, succ, succ']\n  | pos _, pos _ => congr_arg pos (PosNum.add_succ _ _)\n\n"}
{"name":"Num.bit0_of_bit0","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq (HAdd.hAdd n n) n.bit0","decl":"theorem bit0_of_bit0 : ∀ n : Num, n + n = n.bit0\n  | 0 => rfl\n  | pos p => congr_arg pos p.bit0_of_bit0\n\n"}
{"name":"Num.bit1_of_bit1","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq (HAdd.hAdd (HAdd.hAdd n n) 1) n.bit1","decl":"theorem bit1_of_bit1 : ∀ n : Num, (n + n) + 1 = n.bit1\n  | 0 => rfl\n  | pos p => congr_arg pos p.bit1_of_bit1\n\n"}
{"name":"Num.ofNat'_zero","module":"Mathlib.Data.Num.Lemmas","initialProofState":"⊢ Eq (Num.ofNat' 0) 0","decl":"@[simp]\ntheorem ofNat'_zero : Num.ofNat' 0 = 0 := by simp [Num.ofNat']\n\n"}
{"name":"Num.ofNat'_bit","module":"Mathlib.Data.Num.Lemmas","initialProofState":"b : Bool\nn : Nat\n⊢ Eq (Num.ofNat' (Nat.bit b n)) (cond b Num.bit1 Num.bit0 (Num.ofNat' n))","decl":"theorem ofNat'_bit (b n) : ofNat' (Nat.bit b n) = cond b Num.bit1 Num.bit0 (ofNat' n) :=\n  Nat.binaryRec_eq _ _ (.inl rfl)\n\n"}
{"name":"Num.ofNat'_one","module":"Mathlib.Data.Num.Lemmas","initialProofState":"⊢ Eq (Num.ofNat' 1) 1","decl":"@[simp]\ntheorem ofNat'_one : Num.ofNat' 1 = 1 := by erw [ofNat'_bit true 0, cond, ofNat'_zero]; rfl\n\n"}
{"name":"Num.bit1_succ","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq n.bit1.succ n.succ.bit0","decl":"theorem bit1_succ : ∀ n : Num, n.bit1.succ = n.succ.bit0\n  | 0 => rfl\n  | pos _n => rfl\n\n"}
{"name":"Num.ofNat'_succ","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Nat\n⊢ Eq (Num.ofNat' (HAdd.hAdd n 1)) (HAdd.hAdd (Num.ofNat' n) 1)","decl":"theorem ofNat'_succ : ∀ {n}, ofNat' (n + 1) = ofNat' n + 1 :=\n  @(Nat.binaryRec (by simp [zero_add]) fun b n ih => by\n    cases b\n    · erw [ofNat'_bit true n, ofNat'_bit]\n      simp only [← bit1_of_bit1, ← bit0_of_bit0, cond]\n    · rw [show n.bit true + 1 = (n + 1).bit false by simp [Nat.bit, mul_add],\n        ofNat'_bit, ofNat'_bit, ih]\n      simp only [cond, add_one, bit1_succ])\n\n"}
{"name":"Num.add_ofNat'","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Nat\n⊢ Eq (Num.ofNat' (HAdd.hAdd m n)) (HAdd.hAdd (Num.ofNat' m) (Num.ofNat' n))","decl":"@[simp]\ntheorem add_ofNat' (m n) : Num.ofNat' (m + n) = Num.ofNat' m + Num.ofNat' n := by\n  induction n\n  · simp only [Nat.add_zero, ofNat'_zero, add_zero]\n  · simp only [Nat.add_succ, Nat.add_zero, ofNat'_succ, add_one, add_succ, *]\n\n"}
{"name":"Num.cast_zero","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝² : Zero α\ninst✝¹ : One α\ninst✝ : Add α\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem cast_zero [Zero α] [One α] [Add α] : ((0 : Num) : α) = 0 :=\n  rfl\n\n"}
{"name":"Num.cast_zero'","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝² : Zero α\ninst✝¹ : One α\ninst✝ : Add α\n⊢ Eq (↑Num.zero) 0","decl":"@[simp]\ntheorem cast_zero' [Zero α] [One α] [Add α] : (Num.zero : α) = 0 :=\n  rfl\n\n"}
{"name":"Num.cast_one","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝² : Zero α\ninst✝¹ : One α\ninst✝ : Add α\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem cast_one [Zero α] [One α] [Add α] : ((1 : Num) : α) = 1 :=\n  rfl\n\n"}
{"name":"Num.cast_pos","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝² : Zero α\ninst✝¹ : One α\ninst✝ : Add α\nn : PosNum\n⊢ Eq ↑(Num.pos n) ↑n","decl":"@[simp]\ntheorem cast_pos [Zero α] [One α] [Add α] (n : PosNum) : (Num.pos n : α) = n :=\n  rfl\n\n"}
{"name":"Num.succ'_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq (↑n.succ') (HAdd.hAdd (↑n) 1)","decl":"theorem succ'_to_nat : ∀ n, (succ' n : ℕ) = n + 1\n  | 0 => (Nat.zero_add _).symm\n  | pos _p => PosNum.succ_to_nat _\n\n"}
{"name":"Num.succ_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq (↑n.succ) (HAdd.hAdd (↑n) 1)","decl":"theorem succ_to_nat (n) : (succ n : ℕ) = n + 1 :=\n  succ'_to_nat n\n\n"}
{"name":"Num.cast_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : AddMonoidWithOne α\nn : Num\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast]\ntheorem cast_to_nat [AddMonoidWithOne α] : ∀ n : Num, ((n : ℕ) : α) = n\n  | 0 => Nat.cast_zero\n  | pos p => p.cast_to_nat\n\n"}
{"name":"Num.add_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Num\n⊢ Eq (↑(HAdd.hAdd m n)) (HAdd.hAdd ↑m ↑n)","decl":"@[norm_cast]\ntheorem add_to_nat : ∀ m n, ((m + n : Num) : ℕ) = m + n\n  | 0, 0 => rfl\n  | 0, pos _q => (Nat.zero_add _).symm\n  | pos _p, 0 => rfl\n  | pos _p, pos _q => PosNum.add_to_nat _ _\n\n"}
{"name":"Num.mul_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Num\n⊢ Eq (↑(HMul.hMul m n)) (HMul.hMul ↑m ↑n)","decl":"@[norm_cast]\ntheorem mul_to_nat : ∀ m n, ((m * n : Num) : ℕ) = m * n\n  | 0, 0 => rfl\n  | 0, pos _q => (zero_mul _).symm\n  | pos _p, 0 => rfl\n  | pos _p, pos _q => PosNum.mul_to_nat _ _\n\n"}
{"name":"Num.cmp_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Num\n⊢ Ordering.casesOn (m.cmp n) (LT.lt ↑m ↑n) (Eq m n) (LT.lt ↑n ↑m)","decl":"theorem cmp_to_nat : ∀ m n, (Ordering.casesOn (cmp m n) ((m : ℕ) < n) (m = n) ((n : ℕ) < m) : Prop)\n  | 0, 0 => rfl\n  | 0, pos _ => to_nat_pos _\n  | pos _, 0 => to_nat_pos _\n  | pos a, pos b => by\n    have := PosNum.cmp_to_nat a b; revert this; dsimp [cmp]; cases PosNum.cmp a b\n    exacts [id, congr_arg pos, id]\n\n"}
{"name":"Num.lt_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Num\n⊢ Iff (LT.lt ↑m ↑n) (LT.lt m n)","decl":"@[norm_cast]\ntheorem lt_to_nat {m n : Num} : (m : ℕ) < n ↔ m < n :=\n  show (m : ℕ) < n ↔ cmp m n = Ordering.lt from\n    match cmp m n, cmp_to_nat m n with\n    | Ordering.lt, h => by simp only at h; simp [h]\n    | Ordering.eq, h => by simp only at h; simp [h, lt_irrefl]\n    | Ordering.gt, h => by simp [not_lt_of_gt h]\n\n"}
{"name":"Num.le_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Num\n⊢ Iff (LE.le ↑m ↑n) (LE.le m n)","decl":"@[norm_cast]\ntheorem le_to_nat {m n : Num} : (m : ℕ) ≤ n ↔ m ≤ n := by\n  rw [← not_lt]; exact not_congr lt_to_nat\n\n"}
{"name":"PosNum.of_to_nat'","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\n⊢ Eq (Num.ofNat' ↑n) (Num.pos n)","decl":"@[simp]\ntheorem of_to_nat' : ∀ n : PosNum, Num.ofNat' (n : ℕ) = Num.pos n\n  | 1 => by erw [@Num.ofNat'_bit true 0, Num.ofNat'_zero]; rfl\n  | bit0 p => by\n      simpa only [Nat.bit_false, cond_false, two_mul, of_to_nat' p] using Num.ofNat'_bit false p\n  | bit1 p => by\n      simpa only [Nat.bit_true, cond_true, two_mul, of_to_nat' p] using Num.ofNat'_bit true p\n\n"}
{"name":"Num.of_to_nat'","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq (Num.ofNat' ↑n) n","decl":"@[simp, norm_cast]\ntheorem of_to_nat' : ∀ n : Num, Num.ofNat' (n : ℕ) = n\n  | 0 => ofNat'_zero\n  | pos p => p.of_to_nat'\n\n"}
{"name":"Num.toNat_injective","module":"Mathlib.Data.Num.Lemmas","initialProofState":"⊢ Function.Injective castNum","decl":"lemma toNat_injective : Injective (castNum : Num → ℕ) := LeftInverse.injective of_to_nat'\n\n"}
{"name":"Num.to_nat_inj","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Num\n⊢ Iff (Eq ↑m ↑n) (Eq m n)","decl":"@[norm_cast]\ntheorem to_nat_inj {m n : Num} : (m : ℕ) = n ↔ m = n := toNat_injective.eq_iff\n\n"}
{"name":"Num.add_of_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Nat\n⊢ Eq (↑(HAdd.hAdd m n)) (HAdd.hAdd ↑m ↑n)","decl":"@[norm_cast]\ntheorem add_of_nat (m n) : ((m + n : ℕ) : Num) = m + n :=\n  add_ofNat' _ _\n\n"}
{"name":"Num.to_nat_to_int","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq ↑↑n ↑n","decl":"@[norm_cast]\ntheorem to_nat_to_int (n : Num) : ((n : ℕ) : ℤ) = n :=\n  cast_to_nat _\n\n"}
{"name":"Num.cast_to_int","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : AddGroupWithOne α\nn : Num\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast]\ntheorem cast_to_int {α} [AddGroupWithOne α] (n : Num) : ((n : ℤ) : α) = n := by\n  rw [← to_nat_to_int, Int.cast_natCast, cast_to_nat]\n\n"}
{"name":"Num.to_of_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Nat\n⊢ Eq (↑↑n) n","decl":"theorem to_of_nat : ∀ n : ℕ, ((n : Num) : ℕ) = n\n  | 0 => by rw [Nat.cast_zero, cast_zero]\n  | n + 1 => by rw [Nat.cast_succ, add_one, succ_to_nat, to_of_nat n]\n\n"}
{"name":"Num.of_natCast","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : AddMonoidWithOne α\nn : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast]\ntheorem of_natCast {α} [AddMonoidWithOne α] (n : ℕ) : ((n : Num) : α) = n := by\n  rw [← cast_to_nat, to_of_nat]\n\n"}
{"name":"Num.of_nat_inj","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Nat\n⊢ Iff (Eq ↑m ↑n) (Eq m n)","decl":"@[norm_cast]\ntheorem of_nat_inj {m n : ℕ} : (m : Num) = n ↔ m = n :=\n  ⟨fun h => Function.LeftInverse.injective to_of_nat h, congr_arg _⟩\n\n-- Porting note: The priority should be `high`er than `cast_to_nat`.\n"}
{"name":"Num.of_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq (↑↑n) n","decl":"@[simp high, norm_cast]\ntheorem of_to_nat : ∀ n : Num, ((n : ℕ) : Num) = n :=\n  of_to_nat'\n\n"}
{"name":"Num.dvd_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Num\n⊢ Iff (Dvd.dvd ↑m ↑n) (Dvd.dvd m n)","decl":"@[norm_cast]\ntheorem dvd_to_nat (m n : Num) : (m : ℕ) ∣ n ↔ m ∣ n :=\n  ⟨fun ⟨k, e⟩ => ⟨k, by rw [← of_to_nat n, e]; simp⟩, fun ⟨k, e⟩ => ⟨k, by simp [e, mul_to_nat]⟩⟩\n\n"}
{"name":"PosNum.of_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\n⊢ Eq (↑↑n) (Num.pos n)","decl":"@[simp high, norm_cast]\ntheorem of_to_nat : ∀ n : PosNum, ((n : ℕ) : Num) = Num.pos n :=\n  of_to_nat'\n\n"}
{"name":"PosNum.to_nat_inj","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : PosNum\n⊢ Iff (Eq ↑m ↑n) (Eq m n)","decl":"@[norm_cast]\ntheorem to_nat_inj {m n : PosNum} : (m : ℕ) = n ↔ m = n :=\n  ⟨fun h => Num.pos.inj <| by rw [← PosNum.of_to_nat, ← PosNum.of_to_nat, h], congr_arg _⟩\n\n"}
{"name":"PosNum.pred'_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\n⊢ Eq (↑n.pred') (↑n).pred","decl":"theorem pred'_to_nat : ∀ n, (pred' n : ℕ) = Nat.pred n\n  | 1 => rfl\n  | bit0 n =>\n    have : Nat.succ ↑(pred' n) = ↑n := by\n      rw [pred'_to_nat n, Nat.succ_pred_eq_of_pos (to_nat_pos n)]\n    match (motive :=\n        ∀ k : Num, Nat.succ ↑k = ↑n → ↑(Num.casesOn k 1 bit1 : PosNum) = Nat.pred (n + n))\n      pred' n, this with\n    | 0, (h : ((1 : Num) : ℕ) = n) => by rw [← to_nat_inj.1 h]; rfl\n    | Num.pos p, (h : Nat.succ ↑p = n) => by rw [← h]; exact (Nat.succ_add p p).symm\n  | bit1 _ => rfl\n\n"}
{"name":"PosNum.pred'_succ'","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq n.succ'.pred' n","decl":"@[simp]\ntheorem pred'_succ' (n) : pred' (succ' n) = n :=\n  Num.to_nat_inj.1 <| by rw [pred'_to_nat, succ'_to_nat, Nat.add_one, Nat.pred_succ]\n\n"}
{"name":"PosNum.succ'_pred'","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\n⊢ Eq n.pred'.succ' n","decl":"@[simp]\ntheorem succ'_pred' (n) : succ' (pred' n) = n :=\n  to_nat_inj.1 <| by\n    rw [succ'_to_nat, pred'_to_nat, Nat.add_one, Nat.succ_pred_eq_of_pos (to_nat_pos _)]\n\n"}
{"name":"PosNum.dvd_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : PosNum\n⊢ Iff (Dvd.dvd ↑m ↑n) (Dvd.dvd m n)","decl":"@[norm_cast]\ntheorem dvd_to_nat {m n : PosNum} : (m : ℕ) ∣ n ↔ m ∣ n :=\n  Num.dvd_to_nat (pos m) (pos n)\n\n"}
{"name":"PosNum.size_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\n⊢ Eq (↑n.size) (↑n).size","decl":"theorem size_to_nat : ∀ n, (size n : ℕ) = Nat.size n\n  | 1 => Nat.size_one.symm\n  | bit0 n => by\n      rw [size, succ_to_nat, size_to_nat n, cast_bit0, ← two_mul]\n      erw [@Nat.size_bit false n]\n      have := to_nat_pos n\n      dsimp [Nat.bit]; omega\n  | bit1 n => by\n      rw [size, succ_to_nat, size_to_nat n, cast_bit1, ← two_mul]\n      erw [@Nat.size_bit true n]\n      dsimp [Nat.bit]; omega\n\n"}
{"name":"PosNum.size_eq_natSize","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\n⊢ Eq (↑n.size) n.natSize","decl":"theorem size_eq_natSize : ∀ n, (size n : ℕ) = natSize n\n  | 1 => rfl\n  | bit0 n => by rw [size, succ_to_nat, natSize, size_eq_natSize n]\n  | bit1 n => by rw [size, succ_to_nat, natSize, size_eq_natSize n]\n\n"}
{"name":"PosNum.natSize_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\n⊢ Eq n.natSize (↑n).size","decl":"theorem natSize_to_nat (n) : natSize n = Nat.size n := by rw [← size_eq_natSize, size_to_nat]\n\n"}
{"name":"PosNum.natSize_pos","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\n⊢ LT.lt 0 n.natSize","decl":"theorem natSize_pos (n) : 0 < natSize n := by cases n <;> apply Nat.succ_pos\n\n"}
{"name":"PosNum.cast_to_num","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\n⊢ Eq (↑n) (Num.pos n)","decl":"@[simp]\ntheorem cast_to_num (n : PosNum) : ↑n = Num.pos n := by rw [← cast_to_nat, ← of_to_nat n]\n\n"}
{"name":"PosNum.bit_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"b : Bool\nn : PosNum\n⊢ Eq (↑(PosNum.bit b n)) (Nat.bit b ↑n)","decl":"@[simp, norm_cast]\ntheorem bit_to_nat (b n) : (bit b n : ℕ) = Nat.bit b n := by cases b <;> simp [bit, two_mul]\n\n"}
{"name":"PosNum.cast_add","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : AddMonoidWithOne α\nm n : PosNum\n⊢ Eq (↑(HAdd.hAdd m n)) (HAdd.hAdd ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_add [AddMonoidWithOne α] (m n) : ((m + n : PosNum) : α) = m + n := by\n  rw [← cast_to_nat, add_to_nat, Nat.cast_add, cast_to_nat, cast_to_nat]\n\n"}
{"name":"PosNum.cast_succ","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : AddMonoidWithOne α\nn : PosNum\n⊢ Eq (↑n.succ) (HAdd.hAdd (↑n) 1)","decl":"@[simp 500, norm_cast]\ntheorem cast_succ [AddMonoidWithOne α] (n : PosNum) : (succ n : α) = n + 1 := by\n  rw [← add_one, cast_add, cast_one]\n\n"}
{"name":"PosNum.cast_inj","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝¹ : AddMonoidWithOne α\ninst✝ : CharZero α\nm n : PosNum\n⊢ Iff (Eq ↑m ↑n) (Eq m n)","decl":"@[simp, norm_cast]\ntheorem cast_inj [AddMonoidWithOne α] [CharZero α] {m n : PosNum} : (m : α) = n ↔ m = n := by\n  rw [← cast_to_nat m, ← cast_to_nat n, Nat.cast_inj, to_nat_inj]\n\n"}
{"name":"PosNum.one_le_cast","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedSemiring α\nn : PosNum\n⊢ LE.le 1 ↑n","decl":"@[simp]\ntheorem one_le_cast [LinearOrderedSemiring α] (n : PosNum) : (1 : α) ≤ n := by\n  rw [← cast_to_nat, ← Nat.cast_one, Nat.cast_le (α := α)]; apply to_nat_pos\n\n"}
{"name":"PosNum.cast_pos","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedSemiring α\nn : PosNum\n⊢ LT.lt 0 ↑n","decl":"@[simp]\ntheorem cast_pos [LinearOrderedSemiring α] (n : PosNum) : 0 < (n : α) :=\n  lt_of_lt_of_le zero_lt_one (one_le_cast n)\n\n"}
{"name":"PosNum.cast_mul","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : Semiring α\nm n : PosNum\n⊢ Eq (↑(HMul.hMul m n)) (HMul.hMul ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_mul [Semiring α] (m n) : ((m * n : PosNum) : α) = m * n := by\n  rw [← cast_to_nat, mul_to_nat, Nat.cast_mul, cast_to_nat, cast_to_nat]\n\n"}
{"name":"PosNum.cmp_eq","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : PosNum\n⊢ Iff (Eq (m.cmp n) Ordering.eq) (Eq m n)","decl":"@[simp]\ntheorem cmp_eq (m n) : cmp m n = Ordering.eq ↔ m = n := by\n  have := cmp_to_nat m n\n  -- Porting note: `cases` didn't rewrite at `this`, so `revert` & `intro` are required.\n  revert this; cases cmp m n <;> intro this <;> simp at this ⊢ <;> try { exact this } <;>\n    simp [show m ≠ n from fun e => by rw [e] at this;exact lt_irrefl _ this]\n\n"}
{"name":"PosNum.cast_lt","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedSemiring α\nm n : PosNum\n⊢ Iff (LT.lt ↑m ↑n) (LT.lt m n)","decl":"@[simp, norm_cast]\ntheorem cast_lt [LinearOrderedSemiring α] {m n : PosNum} : (m : α) < n ↔ m < n := by\n  rw [← cast_to_nat m, ← cast_to_nat n, Nat.cast_lt (α := α), lt_to_nat]\n\n"}
{"name":"PosNum.cast_le","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedSemiring α\nm n : PosNum\n⊢ Iff (LE.le ↑m ↑n) (LE.le m n)","decl":"@[simp, norm_cast]\ntheorem cast_le [LinearOrderedSemiring α] {m n : PosNum} : (m : α) ≤ n ↔ m ≤ n := by\n  rw [← not_lt]; exact not_congr cast_lt\n\n"}
{"name":"Num.bit_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"b : Bool\nn : Num\n⊢ Eq (↑(Num.bit b n)) (Nat.bit b ↑n)","decl":"theorem bit_to_nat (b n) : (bit b n : ℕ) = Nat.bit b n := by\n  cases b <;> cases n <;> simp [bit, two_mul] <;> rfl\n\n"}
{"name":"Num.cast_succ'","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : AddMonoidWithOne α\nn : Num\n⊢ Eq (↑n.succ') (HAdd.hAdd (↑n) 1)","decl":"theorem cast_succ' [AddMonoidWithOne α] (n) : (succ' n : α) = n + 1 := by\n  rw [← PosNum.cast_to_nat, succ'_to_nat, Nat.cast_add_one, cast_to_nat]\n\n"}
{"name":"Num.cast_succ","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : AddMonoidWithOne α\nn : Num\n⊢ Eq (↑n.succ) (HAdd.hAdd (↑n) 1)","decl":"theorem cast_succ [AddMonoidWithOne α] (n) : (succ n : α) = n + 1 :=\n  cast_succ' n\n\n"}
{"name":"Num.cast_add","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : Semiring α\nm n : Num\n⊢ Eq (↑(HAdd.hAdd m n)) (HAdd.hAdd ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_add [Semiring α] (m n) : ((m + n : Num) : α) = m + n := by\n  rw [← cast_to_nat, add_to_nat, Nat.cast_add, cast_to_nat, cast_to_nat]\n\n"}
{"name":"Num.cast_bit0","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : Semiring α\nn : Num\n⊢ Eq (↑n.bit0) (HMul.hMul 2 ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_bit0 [Semiring α] (n : Num) : (n.bit0 : α) = 2 * (n : α) := by\n  rw [← bit0_of_bit0, two_mul, cast_add]\n\n"}
{"name":"Num.cast_bit1","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : Semiring α\nn : Num\n⊢ Eq (↑n.bit1) (HAdd.hAdd (HMul.hMul 2 ↑n) 1)","decl":"@[simp, norm_cast]\ntheorem cast_bit1 [Semiring α] (n : Num) : (n.bit1 : α) = 2 * (n : α) + 1 := by\n  rw [← bit1_of_bit1, bit0_of_bit0, cast_add, cast_bit0]; rfl\n\n"}
{"name":"Num.cast_mul","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : Semiring α\nm n : Num\n⊢ Eq (↑(HMul.hMul m n)) (HMul.hMul ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_mul [Semiring α] : ∀ m n, ((m * n : Num) : α) = m * n\n  | 0, 0 => (zero_mul _).symm\n  | 0, pos _q => (zero_mul _).symm\n  | pos _p, 0 => (mul_zero _).symm\n  | pos _p, pos _q => PosNum.cast_mul _ _\n\n"}
{"name":"Num.size_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq (↑n.size) (↑n).size","decl":"theorem size_to_nat : ∀ n, (size n : ℕ) = Nat.size n\n  | 0 => Nat.size_zero.symm\n  | pos p => p.size_to_nat\n\n"}
{"name":"Num.size_eq_natSize","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq (↑n.size) n.natSize","decl":"theorem size_eq_natSize : ∀ n, (size n : ℕ) = natSize n\n  | 0 => rfl\n  | pos p => p.size_eq_natSize\n\n"}
{"name":"Num.natSize_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq n.natSize (↑n).size","decl":"theorem natSize_to_nat (n) : natSize n = Nat.size n := by rw [← size_eq_natSize, size_to_nat]\n\n"}
{"name":"Num.ofNat'_eq","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Nat\n⊢ Eq (Num.ofNat' n) ↑n","decl":"@[simp 999]\ntheorem ofNat'_eq : ∀ n, Num.ofNat' n = n :=\n  Nat.binaryRec (by simp) fun b n IH => by\n    rw [ofNat'] at IH ⊢\n    rw [Nat.binaryRec_eq _ _ (.inl rfl), IH]\n    -- Porting note: `Nat.cast_bit0` & `Nat.cast_bit1` are not `simp` theorems anymore.\n    cases b <;> simp only [cond_false, cond_true, Nat.bit, two_mul, Nat.cast_add, Nat.cast_one]\n    · rw [bit0_of_bit0]\n    · rw [bit1_of_bit1]\n\n"}
{"name":"Num.zneg_toZNum","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq (Neg.neg n.toZNum) n.toZNumNeg","decl":"theorem zneg_toZNum (n : Num) : -n.toZNum = n.toZNumNeg := by cases n <;> rfl\n\n"}
{"name":"Num.zneg_toZNumNeg","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq (Neg.neg n.toZNumNeg) n.toZNum","decl":"theorem zneg_toZNumNeg (n : Num) : -n.toZNumNeg = n.toZNum := by cases n <;> rfl\n\n"}
{"name":"Num.toZNum_inj","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Num\n⊢ Iff (Eq m.toZNum n.toZNum) (Eq m n)","decl":"theorem toZNum_inj {m n : Num} : m.toZNum = n.toZNum ↔ m = n :=\n  ⟨fun h => by cases m <;> cases n <;> cases h <;> rfl, congr_arg _⟩\n\n\n"}
{"name":"Num.cast_toZNum","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝³ : Zero α\ninst✝² : One α\ninst✝¹ : Add α\ninst✝ : Neg α\nn : Num\n⊢ Eq ↑n.toZNum ↑n","decl":"@[simp]\ntheorem cast_toZNum [Zero α] [One α] [Add α] [Neg α] : ∀ n : Num, (n.toZNum : α) = n\n  | 0 => rfl\n  | Num.pos _p => rfl\n\n"}
{"name":"Num.cast_toZNumNeg","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : One α\nn : Num\n⊢ Eq (↑n.toZNumNeg) (Neg.neg ↑n)","decl":"@[simp]\ntheorem cast_toZNumNeg [AddGroup α] [One α] : ∀ n : Num, (n.toZNumNeg : α) = -n\n  | 0 => neg_zero.symm\n  | Num.pos _p => rfl\n\n"}
{"name":"Num.add_toZNum","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Num\n⊢ Eq (HAdd.hAdd m n).toZNum (HAdd.hAdd m.toZNum n.toZNum)","decl":"@[simp]\ntheorem add_toZNum (m n : Num) : Num.toZNum (m + n) = m.toZNum + n.toZNum := by\n  cases m <;> cases n <;> rfl\n\n"}
{"name":"PosNum.pred_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\nh : LT.lt 1 n\n⊢ Eq (↑n.pred) (↑n).pred","decl":"theorem pred_to_nat {n : PosNum} (h : 1 < n) : (pred n : ℕ) = Nat.pred n := by\n  unfold pred\n  cases e : pred' n\n  · have : (1 : ℕ) ≤ Nat.pred n := Nat.pred_le_pred ((@cast_lt ℕ _ _ _).2 h)\n    rw [← pred'_to_nat, e] at this\n    exact absurd this (by decide)\n  · rw [← pred'_to_nat, e]\n    rfl\n\n"}
{"name":"PosNum.sub'_one","module":"Mathlib.Data.Num.Lemmas","initialProofState":"a : PosNum\n⊢ Eq (a.sub' 1) a.pred'.toZNum","decl":"theorem sub'_one (a : PosNum) : sub' a 1 = (pred' a).toZNum := by cases a <;> rfl\n\n"}
{"name":"PosNum.one_sub'","module":"Mathlib.Data.Num.Lemmas","initialProofState":"a : PosNum\n⊢ Eq (PosNum.sub' 1 a) a.pred'.toZNumNeg","decl":"theorem one_sub' (a : PosNum) : sub' 1 a = (pred' a).toZNumNeg := by cases a <;> rfl\n\n"}
{"name":"PosNum.lt_iff_cmp","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : PosNum\n⊢ Iff (LT.lt m n) (Eq (m.cmp n) Ordering.lt)","decl":"theorem lt_iff_cmp {m n} : m < n ↔ cmp m n = Ordering.lt :=\n  Iff.rfl\n\n"}
{"name":"PosNum.le_iff_cmp","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : PosNum\n⊢ Iff (LE.le m n) (Ne (m.cmp n) Ordering.gt)","decl":"theorem le_iff_cmp {m n} : m ≤ n ↔ cmp m n ≠ Ordering.gt :=\n  not_congr <| lt_iff_cmp.trans <| by rw [← cmp_swap]; cases cmp m n <;> decide\n\n"}
{"name":"Num.pred_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq (↑n.pred) (↑n).pred","decl":"theorem pred_to_nat : ∀ n : Num, (pred n : ℕ) = Nat.pred n\n  | 0 => rfl\n  | pos p => by rw [pred, PosNum.pred'_to_nat]; rfl\n\n"}
{"name":"Num.ppred_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq (Functor.map castNum n.ppred) (↑n).ppred","decl":"theorem ppred_to_nat : ∀ n : Num, (↑) <$> ppred n = Nat.ppred n\n  | 0 => rfl\n  | pos p => by\n    rw [ppred, Option.map_some, Nat.ppred_eq_some.2]\n    rw [PosNum.pred'_to_nat, Nat.succ_pred_eq_of_pos (PosNum.to_nat_pos _)]\n    rfl\n\n"}
{"name":"Num.cmp_swap","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Num\n⊢ Eq (m.cmp n).swap (n.cmp m)","decl":"theorem cmp_swap (m n) : (cmp m n).swap = cmp n m := by\n  cases m <;> cases n <;> try { rfl }; apply PosNum.cmp_swap\n\n"}
{"name":"Num.cmp_eq","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Num\n⊢ Iff (Eq (m.cmp n) Ordering.eq) (Eq m n)","decl":"theorem cmp_eq (m n) : cmp m n = Ordering.eq ↔ m = n := by\n  have := cmp_to_nat m n\n  -- Porting note: `cases` didn't rewrite at `this`, so `revert` & `intro` are required.\n  revert this; cases cmp m n <;> intro this <;> simp at this ⊢ <;> try { exact this } <;>\n    simp [show m ≠ n from fun e => by rw [e] at this; exact lt_irrefl _ this]\n\n"}
{"name":"Num.cast_lt","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedSemiring α\nm n : Num\n⊢ Iff (LT.lt ↑m ↑n) (LT.lt m n)","decl":"@[simp, norm_cast]\ntheorem cast_lt [LinearOrderedSemiring α] {m n : Num} : (m : α) < n ↔ m < n := by\n  rw [← cast_to_nat m, ← cast_to_nat n, Nat.cast_lt (α := α), lt_to_nat]\n\n"}
{"name":"Num.cast_le","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedSemiring α\nm n : Num\n⊢ Iff (LE.le ↑m ↑n) (LE.le m n)","decl":"@[simp, norm_cast]\ntheorem cast_le [LinearOrderedSemiring α] {m n : Num} : (m : α) ≤ n ↔ m ≤ n := by\n  rw [← not_lt]; exact not_congr cast_lt\n\n"}
{"name":"Num.cast_inj","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedSemiring α\nm n : Num\n⊢ Iff (Eq ↑m ↑n) (Eq m n)","decl":"@[simp, norm_cast]\ntheorem cast_inj [LinearOrderedSemiring α] {m n : Num} : (m : α) = n ↔ m = n := by\n  rw [← cast_to_nat m, ← cast_to_nat n, Nat.cast_inj, to_nat_inj]\n\n"}
{"name":"Num.lt_iff_cmp","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Num\n⊢ Iff (LT.lt m n) (Eq (m.cmp n) Ordering.lt)","decl":"theorem lt_iff_cmp {m n} : m < n ↔ cmp m n = Ordering.lt :=\n  Iff.rfl\n\n"}
{"name":"Num.le_iff_cmp","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Num\n⊢ Iff (LE.le m n) (Ne (m.cmp n) Ordering.gt)","decl":"theorem le_iff_cmp {m n} : m ≤ n ↔ cmp m n ≠ Ordering.gt :=\n  not_congr <| lt_iff_cmp.trans <| by rw [← cmp_swap]; cases cmp m n <;> decide\n\n"}
{"name":"Num.castNum_eq_bitwise","module":"Mathlib.Data.Num.Lemmas","initialProofState":"f : Num → Num → Num\ng : Bool → Bool → Bool\np : PosNum → PosNum → Num\ngff : Eq (g Bool.false Bool.false) Bool.false\nf00 : Eq (f 0 0) 0\nf0n : ∀ (n : PosNum), Eq (f 0 (Num.pos n)) (cond (g Bool.false Bool.true) (Num.pos n) 0)\nfn0 : ∀ (n : PosNum), Eq (f (Num.pos n) 0) (cond (g Bool.true Bool.false) (Num.pos n) 0)\nfnn : ∀ (m n : PosNum), Eq (f (Num.pos m) (Num.pos n)) (p m n)\np11 : Eq (p 1 1) (cond (g Bool.true Bool.true) 1 0)\np1b : ∀ (b : Bool) (n : PosNum), Eq (p 1 (PosNum.bit b n)) (Num.bit (g Bool.true b) (cond (g Bool.false Bool.true) (Num.pos n) 0))\npb1 : ∀ (a : Bool) (m : PosNum), Eq (p (PosNum.bit a m) 1) (Num.bit (g a Bool.true) (cond (g Bool.true Bool.false) (Num.pos m) 0))\npbb : ∀ (a b : Bool) (m n : PosNum), Eq (p (PosNum.bit a m) (PosNum.bit b n)) (Num.bit (g a b) (p m n))\nm n : Num\n⊢ Eq (↑(f m n)) (Nat.bitwise g ↑m ↑n)","decl":"theorem castNum_eq_bitwise {f : Num → Num → Num} {g : Bool → Bool → Bool}\n    (p : PosNum → PosNum → Num)\n    (gff : g false false = false) (f00 : f 0 0 = 0)\n    (f0n : ∀ n, f 0 (pos n) = cond (g false true) (pos n) 0)\n    (fn0 : ∀ n, f (pos n) 0 = cond (g true false) (pos n) 0)\n    (fnn : ∀ m n, f (pos m) (pos n) = p m n) (p11 : p 1 1 = cond (g true true) 1 0)\n    (p1b : ∀ b n, p 1 (PosNum.bit b n) = bit (g true b) (cond (g false true) (pos n) 0))\n    (pb1 : ∀ a m, p (PosNum.bit a m) 1 = bit (g a true) (cond (g true false) (pos m) 0))\n    (pbb : ∀ a b m n, p (PosNum.bit a m) (PosNum.bit b n) = bit (g a b) (p m n)) :\n    ∀ m n : Num, (f m n : ℕ) = Nat.bitwise g m n := by\n  intros m n\n  cases' m with m <;> cases' n with n <;>\n      try simp only [show zero = 0 from rfl, show ((0 : Num) : ℕ) = 0 from rfl]\n  · rw [f00, Nat.bitwise_zero]; rfl\n  · rw [f0n, Nat.bitwise_zero_left]\n    cases g false true <;> rfl\n  · rw [fn0, Nat.bitwise_zero_right]\n    cases g true false <;> rfl\n  · rw [fnn]\n    have : ∀ (b) (n : PosNum), (cond b (↑n) 0 : ℕ) = ↑(cond b (pos n) 0 : Num) := by\n      intros b _; cases b <;> rfl\n    induction' m with m IH m IH generalizing n <;> cases' n with n n\n    any_goals simp only [show one = 1 from rfl, show pos 1 = 1 from rfl,\n      show PosNum.bit0 = PosNum.bit false from rfl, show PosNum.bit1 = PosNum.bit true from rfl,\n      show ((1 : Num) : ℕ) = Nat.bit true 0 from rfl]\n    all_goals\n      repeat\n        rw [show ∀ b n, (pos (PosNum.bit b n) : ℕ) = Nat.bit b ↑n by\n          intros b _; cases b <;> simp_all]\n      rw [Nat.bitwise_bit gff]\n    any_goals rw [Nat.bitwise_zero, p11]; cases g true true <;> rfl\n    any_goals rw [Nat.bitwise_zero_left, ← Bool.cond_eq_ite, this, ← bit_to_nat, p1b]\n    any_goals rw [Nat.bitwise_zero_right, ← Bool.cond_eq_ite, this, ← bit_to_nat, pb1]\n    all_goals\n      rw [← show ∀ n : PosNum, ↑(p m n) = Nat.bitwise g ↑m ↑n from IH]\n      rw [← bit_to_nat, pbb]\n\n"}
{"name":"Num.castNum_or","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Num\n⊢ Eq (↑(HOr.hOr m n)) (HOr.hOr ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem castNum_or : ∀ m n : Num, ↑(m ||| n) = (↑m ||| ↑n : ℕ) := by\n  -- Porting note: A name of an implicit local hypothesis is not available so\n  --               `cases_type*` is used.\n  apply castNum_eq_bitwise fun x y => pos (PosNum.lor x y) <;>\n   intros <;> (try cases_type* Bool) <;> rfl\n\n"}
{"name":"Num.castNum_and","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Num\n⊢ Eq (↑(HAnd.hAnd m n)) (HAnd.hAnd ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem castNum_and : ∀ m n : Num, ↑(m &&& n) = (↑m &&& ↑n : ℕ) := by\n  apply castNum_eq_bitwise PosNum.land <;> intros <;> (try cases_type* Bool) <;> rfl\n\n"}
{"name":"Num.castNum_ldiff","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Num\n⊢ Eq (↑(m.ldiff n)) ((↑m).ldiff ↑n)","decl":"@[simp, norm_cast]\ntheorem castNum_ldiff : ∀ m n : Num, (ldiff m n : ℕ) = Nat.ldiff m n := by\n  apply castNum_eq_bitwise PosNum.ldiff <;> intros <;> (try cases_type* Bool) <;> rfl\n\n"}
{"name":"Num.castNum_xor","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Num\n⊢ Eq (↑(HXor.hXor m n)) (HXor.hXor ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem castNum_xor : ∀ m n : Num, ↑(m ^^^ n) = (↑m ^^^ ↑n : ℕ) := by\n  apply castNum_eq_bitwise PosNum.lxor <;> intros <;> (try cases_type* Bool) <;> rfl\n\n"}
{"name":"Num.castNum_shiftLeft","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m : Num\nn : Nat\n⊢ Eq (↑(HShiftLeft.hShiftLeft m n)) (HShiftLeft.hShiftLeft (↑m) n)","decl":"@[simp, norm_cast]\ntheorem castNum_shiftLeft (m : Num) (n : Nat) : ↑(m <<< n) = (m : ℕ) <<< (n : ℕ) := by\n  cases m <;> dsimp only [← shiftl_eq_shiftLeft, shiftl]\n  · symm\n    apply Nat.zero_shiftLeft\n  simp only [cast_pos]\n  induction' n with n IH\n  · rfl\n  simp [PosNum.shiftl_succ_eq_bit0_shiftl, Nat.shiftLeft_succ, IH, pow_succ, ← mul_assoc, mul_comm,\n        -shiftl_eq_shiftLeft, -PosNum.shiftl_eq_shiftLeft, shiftl, mul_two]\n\n"}
{"name":"Num.castNum_shiftRight","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m : Num\nn : Nat\n⊢ Eq (↑(HShiftRight.hShiftRight m n)) (HShiftRight.hShiftRight (↑m) n)","decl":"@[simp, norm_cast]\ntheorem castNum_shiftRight (m : Num) (n : Nat) : ↑(m >>> n) = (m : ℕ) >>> (n : ℕ) := by\n  cases' m with m <;> dsimp only [← shiftr_eq_shiftRight, shiftr]\n  · symm\n    apply Nat.zero_shiftRight\n  induction' n with n IH generalizing m\n  · cases m <;> rfl\n  have hdiv2 : ∀ m, Nat.div2 (m + m) = m := by intro; rw [Nat.div2_val]; omega\n  cases' m with m m <;> dsimp only [PosNum.shiftr, ← PosNum.shiftr_eq_shiftRight]\n  · rw [Nat.shiftRight_eq_div_pow]\n    symm\n    apply Nat.div_eq_of_lt\n    simp\n  · trans\n    · apply IH\n    change Nat.shiftRight m n = Nat.shiftRight (m + m + 1) (n + 1)\n    rw [add_comm n 1, @Nat.shiftRight_eq _ (1 + n), Nat.shiftRight_add]\n    apply congr_arg fun x => Nat.shiftRight x n\n    simp [-add_assoc, Nat.shiftRight_succ, Nat.shiftRight_zero, ← Nat.div2_val, hdiv2]\n  · trans\n    · apply IH\n    change Nat.shiftRight m n = Nat.shiftRight (m + m) (n + 1)\n    rw [add_comm n 1,  @Nat.shiftRight_eq _ (1 + n), Nat.shiftRight_add]\n    apply congr_arg fun x => Nat.shiftRight x n\n    simp [-add_assoc, Nat.shiftRight_succ, Nat.shiftRight_zero, ← Nat.div2_val, hdiv2]\n\n"}
{"name":"Num.castNum_testBit","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m : Num\nn : Nat\n⊢ Eq (m.testBit n) ((↑m).testBit n)","decl":"@[simp]\ntheorem castNum_testBit (m n) : testBit m n = Nat.testBit m n := by\n  -- Porting note: `unfold` → `dsimp only`\n  cases m with dsimp only [testBit]\n  | zero =>\n    rw [show (Num.zero : Nat) = 0 from rfl, Nat.zero_testBit]\n  | pos m =>\n    rw [cast_pos]\n    induction' n with n IH generalizing m <;> cases' m with m m\n        <;> simp only [PosNum.testBit]\n    · rfl\n    · rw [PosNum.cast_bit1, ← two_mul, ← congr_fun Nat.bit_true, Nat.testBit_bit_zero]\n    · rw [PosNum.cast_bit0, ← two_mul, ← congr_fun Nat.bit_false, Nat.testBit_bit_zero]\n    · simp [Nat.testBit_add_one]\n    · rw [PosNum.cast_bit1, ← two_mul, ← congr_fun Nat.bit_true, Nat.testBit_bit_succ, IH]\n    · rw [PosNum.cast_bit0, ← two_mul, ← congr_fun Nat.bit_false, Nat.testBit_bit_succ, IH]\n\n"}
{"name":"ZNum.cast_zero","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝³ : Zero α\ninst✝² : One α\ninst✝¹ : Add α\ninst✝ : Neg α\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem cast_zero [Zero α] [One α] [Add α] [Neg α] : ((0 : ZNum) : α) = 0 :=\n  rfl\n\n"}
{"name":"ZNum.cast_zero'","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝³ : Zero α\ninst✝² : One α\ninst✝¹ : Add α\ninst✝ : Neg α\n⊢ Eq (↑ZNum.zero) 0","decl":"@[simp]\ntheorem cast_zero' [Zero α] [One α] [Add α] [Neg α] : (ZNum.zero : α) = 0 :=\n  rfl\n\n"}
{"name":"ZNum.cast_one","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝³ : Zero α\ninst✝² : One α\ninst✝¹ : Add α\ninst✝ : Neg α\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem cast_one [Zero α] [One α] [Add α] [Neg α] : ((1 : ZNum) : α) = 1 :=\n  rfl\n\n"}
{"name":"ZNum.cast_pos","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝³ : Zero α\ninst✝² : One α\ninst✝¹ : Add α\ninst✝ : Neg α\nn : PosNum\n⊢ Eq ↑(ZNum.pos n) ↑n","decl":"@[simp]\ntheorem cast_pos [Zero α] [One α] [Add α] [Neg α] (n : PosNum) : (pos n : α) = n :=\n  rfl\n\n"}
{"name":"ZNum.cast_neg","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝³ : Zero α\ninst✝² : One α\ninst✝¹ : Add α\ninst✝ : Neg α\nn : PosNum\n⊢ Eq (↑(ZNum.neg n)) (Neg.neg ↑n)","decl":"@[simp]\ntheorem cast_neg [Zero α] [One α] [Add α] [Neg α] (n : PosNum) : (neg n : α) = -n :=\n  rfl\n\n"}
{"name":"ZNum.cast_zneg","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : One α\nn : ZNum\n⊢ Eq (↑(Neg.neg n)) (Neg.neg ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_zneg [AddGroup α] [One α] : ∀ n, ((-n : ZNum) : α) = -n\n  | 0 => neg_zero.symm\n  | pos _p => rfl\n  | neg _p => (neg_neg _).symm\n\n"}
{"name":"ZNum.neg_zero","module":"Mathlib.Data.Num.Lemmas","initialProofState":"⊢ Eq (-0) 0","decl":"theorem neg_zero : (-0 : ZNum) = 0 :=\n  rfl\n\n"}
{"name":"ZNum.zneg_pos","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\n⊢ Eq (Neg.neg (ZNum.pos n)) (ZNum.neg n)","decl":"theorem zneg_pos (n : PosNum) : -pos n = neg n :=\n  rfl\n\n"}
{"name":"ZNum.zneg_neg","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\n⊢ Eq (Neg.neg (ZNum.neg n)) (ZNum.pos n)","decl":"theorem zneg_neg (n : PosNum) : -neg n = pos n :=\n  rfl\n\n"}
{"name":"ZNum.zneg_zneg","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : ZNum\n⊢ Eq (Neg.neg (Neg.neg n)) n","decl":"theorem zneg_zneg (n : ZNum) : - -n = n := by cases n <;> rfl\n\n"}
{"name":"ZNum.zneg_bit1","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : ZNum\n⊢ Eq (Neg.neg n.bit1) (Neg.neg n).bitm1","decl":"theorem zneg_bit1 (n : ZNum) : -n.bit1 = (-n).bitm1 := by cases n <;> rfl\n\n"}
{"name":"ZNum.zneg_bitm1","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : ZNum\n⊢ Eq (Neg.neg n.bitm1) (Neg.neg n).bit1","decl":"theorem zneg_bitm1 (n : ZNum) : -n.bitm1 = (-n).bit1 := by cases n <;> rfl\n\n"}
{"name":"ZNum.zneg_succ","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : ZNum\n⊢ Eq (Neg.neg n.succ) (Neg.neg n).pred","decl":"theorem zneg_succ (n : ZNum) : -n.succ = (-n).pred := by\n  cases n <;> try { rfl }; rw [succ, Num.zneg_toZNumNeg]; rfl\n\n"}
{"name":"ZNum.zneg_pred","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : ZNum\n⊢ Eq (Neg.neg n.pred) (Neg.neg n).succ","decl":"theorem zneg_pred (n : ZNum) : -n.pred = (-n).succ := by\n  rw [← zneg_zneg (succ (-n)), zneg_succ, zneg_zneg]\n\n"}
{"name":"ZNum.abs_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : ZNum\n⊢ Eq (↑n.abs) (↑n).natAbs","decl":"@[simp]\ntheorem abs_to_nat : ∀ n, (abs n : ℕ) = Int.natAbs n\n  | 0 => rfl\n  | pos p => congr_arg Int.natAbs p.to_nat_to_int\n  | neg p => show Int.natAbs ((p : ℕ) : ℤ) = Int.natAbs (-p) by rw [p.to_nat_to_int, Int.natAbs_neg]\n\n"}
{"name":"ZNum.abs_toZNum","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq n.toZNum.abs n","decl":"@[simp]\ntheorem abs_toZNum : ∀ n : Num, abs n.toZNum = n\n  | 0 => rfl\n  | Num.pos _p => rfl\n\n"}
{"name":"ZNum.cast_to_int","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : AddGroupWithOne α\nn : ZNum\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast]\ntheorem cast_to_int [AddGroupWithOne α] : ∀ n : ZNum, ((n : ℤ) : α) = n\n  | 0 => by rw [cast_zero, cast_zero, Int.cast_zero]\n  | pos p => by rw [cast_pos, cast_pos, PosNum.cast_to_int]\n  | neg p => by rw [cast_neg, cast_neg, Int.cast_neg, PosNum.cast_to_int]\n\n"}
{"name":"ZNum.bit0_of_bit0","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : ZNum\n⊢ Eq (HAdd.hAdd n n) n.bit0","decl":"theorem bit0_of_bit0 : ∀ n : ZNum, n + n = n.bit0\n  | 0 => rfl\n  | pos a => congr_arg pos a.bit0_of_bit0\n  | neg a => congr_arg neg a.bit0_of_bit0\n\n"}
{"name":"ZNum.bit1_of_bit1","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : ZNum\n⊢ Eq (HAdd.hAdd (HAdd.hAdd n n) 1) n.bit1","decl":"theorem bit1_of_bit1 : ∀ n : ZNum, n + n + 1 = n.bit1\n  | 0 => rfl\n  | pos a => congr_arg pos a.bit1_of_bit1\n  | neg a => show PosNum.sub' 1 (a + a) = _ by rw [PosNum.one_sub', a.bit0_of_bit0]; rfl\n\n"}
{"name":"ZNum.cast_bit0","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : AddGroupWithOne α\nn : ZNum\n⊢ Eq (↑n.bit0) (HAdd.hAdd ↑n ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_bit0 [AddGroupWithOne α] : ∀ n : ZNum, (n.bit0 : α) = (n : α) + n\n  | 0 => (add_zero _).symm\n  | pos p => by rw [ZNum.bit0, cast_pos, cast_pos]; rfl\n  | neg p => by\n    rw [ZNum.bit0, cast_neg, cast_neg, PosNum.cast_bit0, neg_add_rev]\n\n"}
{"name":"ZNum.cast_bit1","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : AddGroupWithOne α\nn : ZNum\n⊢ Eq (↑n.bit1) (HAdd.hAdd (HAdd.hAdd ↑n ↑n) 1)","decl":"@[simp, norm_cast]\ntheorem cast_bit1 [AddGroupWithOne α] : ∀ n : ZNum, (n.bit1 : α) = ((n : α) + n) + 1\n  | 0 => by simp [ZNum.bit1]\n  | pos p => by rw [ZNum.bit1, cast_pos, cast_pos]; rfl\n  | neg p => by\n    rw [ZNum.bit1, cast_neg, cast_neg]\n    cases' e : pred' p with a <;>\n      have ep : p = _ := (succ'_pred' p).symm.trans (congr_arg Num.succ' e)\n    · conv at ep => change p = 1\n      subst p\n      simp\n    -- Porting note: `rw [Num.succ']` yields a `match` pattern.\n    · dsimp only [Num.succ'] at ep\n      subst p\n      have : (↑(-↑a : ℤ) : α) = -1 + ↑(-↑a + 1 : ℤ) := by simp [add_comm (- ↑a : ℤ) 1]\n      simpa using this\n\n"}
{"name":"ZNum.cast_bitm1","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : AddGroupWithOne α\nn : ZNum\n⊢ Eq (↑n.bitm1) (HSub.hSub (HAdd.hAdd ↑n ↑n) 1)","decl":"@[simp]\ntheorem cast_bitm1 [AddGroupWithOne α] (n : ZNum) : (n.bitm1 : α) = (n : α) + n - 1 := by\n  conv =>\n    lhs\n    rw [← zneg_zneg n]\n  rw [← zneg_bit1, cast_zneg, cast_bit1]\n  have : ((-1 + n + n : ℤ) : α) = (n + n + -1 : ℤ) := by simp [add_comm, add_left_comm]\n  simpa [sub_eq_add_neg] using this\n\n"}
{"name":"ZNum.add_zero","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : ZNum\n⊢ Eq (HAdd.hAdd n 0) n","decl":"theorem add_zero (n : ZNum) : n + 0 = n := by cases n <;> rfl\n\n"}
{"name":"ZNum.zero_add","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : ZNum\n⊢ Eq (HAdd.hAdd 0 n) n","decl":"theorem zero_add (n : ZNum) : 0 + n = n := by cases n <;> rfl\n\n"}
{"name":"ZNum.add_one","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : ZNum\n⊢ Eq (HAdd.hAdd n 1) n.succ","decl":"theorem add_one : ∀ n : ZNum, n + 1 = succ n\n  | 0 => rfl\n  | pos p => congr_arg pos p.add_one\n  | neg p => by cases p <;> rfl\n\n"}
{"name":"PosNum.cast_to_znum","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\n⊢ Eq (↑n) (ZNum.pos n)","decl":"theorem cast_to_znum : ∀ n : PosNum, (n : ZNum) = ZNum.pos n\n  | 1 => rfl\n  | bit0 p => by\n      have := congr_arg ZNum.bit0 (cast_to_znum p)\n      rwa [← ZNum.bit0_of_bit0] at this\n  | bit1 p => by\n      have := congr_arg ZNum.bit1 (cast_to_znum p)\n      rwa [← ZNum.bit1_of_bit1] at this\n\n"}
{"name":"PosNum.cast_sub'","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : AddGroupWithOne α\nm n : PosNum\n⊢ Eq (↑(m.sub' n)) (HSub.hSub ↑m ↑n)","decl":"theorem cast_sub' [AddGroupWithOne α] : ∀ m n : PosNum, (sub' m n : α) = m - n\n  | a, 1 => by\n    rw [sub'_one, Num.cast_toZNum, ← Num.cast_to_nat, pred'_to_nat, ← Nat.sub_one]\n    simp [PosNum.cast_pos]\n  | 1, b => by\n    rw [one_sub', Num.cast_toZNumNeg, ← neg_sub, neg_inj, ← Num.cast_to_nat, pred'_to_nat,\n        ← Nat.sub_one]\n    simp [PosNum.cast_pos]\n  | bit0 a, bit0 b => by\n    rw [sub', ZNum.cast_bit0, cast_sub' a b]\n    have : ((a + -b + (a + -b) : ℤ) : α) = a + a + (-b + -b) := by simp [add_left_comm]\n    simpa [sub_eq_add_neg] using this\n  | bit0 a, bit1 b => by\n    rw [sub', ZNum.cast_bitm1, cast_sub' a b]\n    have : ((-b + (a + (-b + -1)) : ℤ) : α) = (a + -1 + (-b + -b) : ℤ) := by\n      simp [add_comm, add_left_comm]\n    simpa [sub_eq_add_neg] using this\n  | bit1 a, bit0 b => by\n    rw [sub', ZNum.cast_bit1, cast_sub' a b]\n    have : ((-b + (a + (-b + 1)) : ℤ) : α) = (a + 1 + (-b + -b) : ℤ) := by\n      simp [add_comm, add_left_comm]\n    simpa [sub_eq_add_neg] using this\n  | bit1 a, bit1 b => by\n    rw [sub', ZNum.cast_bit0, cast_sub' a b]\n    have : ((-b + (a + -b) : ℤ) : α) = a + (-b + -b) := by simp [add_left_comm]\n    simpa [sub_eq_add_neg] using this\n\n"}
{"name":"PosNum.to_nat_eq_succ_pred","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\n⊢ Eq (↑n) (HAdd.hAdd (↑n.pred') 1)","decl":"theorem to_nat_eq_succ_pred (n : PosNum) : (n : ℕ) = n.pred' + 1 := by\n  rw [← Num.succ'_to_nat, n.succ'_pred']\n\n"}
{"name":"PosNum.to_int_eq_succ_pred","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : PosNum\n⊢ Eq (↑n) (HAdd.hAdd (↑↑n.pred') 1)","decl":"theorem to_int_eq_succ_pred (n : PosNum) : (n : ℤ) = (n.pred' : ℕ) + 1 := by\n  rw [← n.to_nat_to_int, to_nat_eq_succ_pred]; rfl\n\n"}
{"name":"Num.cast_sub'","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : AddGroupWithOne α\nm n : Num\n⊢ Eq (↑(m.sub' n)) (HSub.hSub ↑m ↑n)","decl":"@[simp]\ntheorem cast_sub' [AddGroupWithOne α] : ∀ m n : Num, (sub' m n : α) = m - n\n  | 0, 0 => (sub_zero _).symm\n  | pos _a, 0 => (sub_zero _).symm\n  | 0, pos _b => (zero_sub _).symm\n  | pos _a, pos _b => PosNum.cast_sub' _ _\n\n"}
{"name":"Num.toZNum_succ","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq n.succ.toZNum n.toZNum.succ","decl":"theorem toZNum_succ : ∀ n : Num, n.succ.toZNum = n.toZNum.succ\n  | 0 => rfl\n  | pos _n => rfl\n\n"}
{"name":"Num.toZNumNeg_succ","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq n.succ.toZNumNeg n.toZNumNeg.pred","decl":"theorem toZNumNeg_succ : ∀ n : Num, n.succ.toZNumNeg = n.toZNumNeg.pred\n  | 0 => rfl\n  | pos _n => rfl\n\n"}
{"name":"Num.pred_succ","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : ZNum\n⊢ Eq n.pred.succ n","decl":"@[simp]\ntheorem pred_succ : ∀ n : ZNum, n.pred.succ = n\n  | 0 => rfl\n  | ZNum.neg p => show toZNumNeg (pos p).succ'.pred' = _ by rw [PosNum.pred'_succ']; rfl\n  | ZNum.pos p => by rw [ZNum.pred, ← toZNum_succ, Num.succ, PosNum.succ'_pred', toZNum]\n\n-- Porting note: `erw [ZNum.ofInt', ZNum.ofInt']` yields `match` so\n--               `change` & `dsimp` are required.\n"}
{"name":"Num.succ_ofInt'","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Int\n⊢ Eq (ZNum.ofInt' (HAdd.hAdd n 1)) (HAdd.hAdd (ZNum.ofInt' n) 1)","decl":"theorem succ_ofInt' : ∀ n, ZNum.ofInt' (n + 1) = ZNum.ofInt' n + 1\n  | (n : ℕ) => by\n    change ZNum.ofInt' (n + 1 : ℕ) = ZNum.ofInt' (n : ℕ) + 1\n    dsimp only [ZNum.ofInt', ZNum.ofInt']\n    rw [Num.ofNat'_succ, Num.add_one, toZNum_succ, ZNum.add_one]\n  | -[0+1] => by\n    change ZNum.ofInt' 0 = ZNum.ofInt' (-[0+1]) + 1\n    dsimp only [ZNum.ofInt', ZNum.ofInt']\n    rw [ofNat'_succ, ofNat'_zero]; rfl\n  | -[(n + 1)+1] => by\n    change ZNum.ofInt' -[n+1] = ZNum.ofInt' -[(n + 1)+1] + 1\n    dsimp only [ZNum.ofInt', ZNum.ofInt']\n    rw [@Num.ofNat'_succ (n + 1), Num.add_one, toZNumNeg_succ,\n      @ofNat'_succ n, Num.add_one, ZNum.add_one, pred_succ]\n\n"}
{"name":"Num.ofInt'_toZNum","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Nat\n⊢ Eq (↑n).toZNum (ZNum.ofInt' ↑n)","decl":"theorem ofInt'_toZNum : ∀ n : ℕ, toZNum n = ZNum.ofInt' n\n  | 0 => rfl\n  | n + 1 => by\n    rw [Nat.cast_succ, Num.add_one, toZNum_succ, ofInt'_toZNum n, Nat.cast_succ, succ_ofInt',\n      ZNum.add_one]\n\n"}
{"name":"Num.mem_ofZNum'","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m : Num\nn : ZNum\n⊢ Iff (Membership.mem (Num.ofZNum' n) m) (Eq n m.toZNum)","decl":"theorem mem_ofZNum' : ∀ {m : Num} {n : ZNum}, m ∈ ofZNum' n ↔ n = toZNum m\n  | 0, 0 => ⟨fun _ => rfl, fun _ => rfl⟩\n  | pos _, 0 => ⟨nofun, nofun⟩\n  | m, ZNum.pos p =>\n    Option.some_inj.trans <| by cases m <;> constructor <;> intro h <;> try cases h <;> rfl\n  | m, ZNum.neg p => ⟨nofun, fun h => by cases m <;> cases h⟩\n\n"}
{"name":"Num.ofZNum'_toNat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : ZNum\n⊢ Eq (Functor.map castNum (Num.ofZNum' n)) (↑n).toNat'","decl":"theorem ofZNum'_toNat : ∀ n : ZNum, (↑) <$> ofZNum' n = Int.toNat' n\n  | 0 => rfl\n  | ZNum.pos p => show _ = Int.toNat' p by rw [← PosNum.to_nat_to_int p]; rfl\n  | ZNum.neg p =>\n    (congr_arg fun x => Int.toNat' (-x)) <|\n      show ((p.pred' + 1 : ℕ) : ℤ) = p by rw [← succ'_to_nat]; simp\n\n"}
{"name":"Num.ofZNum_toNat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : ZNum\n⊢ Eq (↑(Num.ofZNum n)) (↑n).toNat","decl":"@[simp]\ntheorem ofZNum_toNat : ∀ n : ZNum, (ofZNum n : ℕ) = Int.toNat n\n  | 0 => rfl\n  | ZNum.pos p => show _ = Int.toNat p by rw [← PosNum.to_nat_to_int p]; rfl\n  | ZNum.neg p =>\n    (congr_arg fun x => Int.toNat (-x)) <|\n      show ((p.pred' + 1 : ℕ) : ℤ) = p by rw [← succ'_to_nat]; simp\n\n"}
{"name":"Num.cast_ofZNum","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : AddGroupWithOne α\nn : ZNum\n⊢ Eq ↑(Num.ofZNum n) ↑(↑n).toNat","decl":"@[simp]\ntheorem cast_ofZNum [AddGroupWithOne α] (n : ZNum) : (ofZNum n : α) = Int.toNat n := by\n  rw [← cast_to_nat, ofZNum_toNat]\n\n"}
{"name":"Num.sub_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Num\n⊢ Eq (↑(HSub.hSub m n)) (HSub.hSub ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem sub_to_nat (m n) : ((m - n : Num) : ℕ) = m - n :=\n  show (ofZNum _ : ℕ) = _ by\n    rw [ofZNum_toNat, cast_sub', ← to_nat_to_int, ← to_nat_to_int, Int.toNat_sub]\n\n"}
{"name":"ZNum.cast_add","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : AddGroupWithOne α\nm n : ZNum\n⊢ Eq (↑(HAdd.hAdd m n)) (HAdd.hAdd ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_add [AddGroupWithOne α] : ∀ m n, ((m + n : ZNum) : α) = m + n\n  | 0, a => by cases a <;> exact (_root_.zero_add _).symm\n  | b, 0 => by cases b <;> exact (_root_.add_zero _).symm\n  | pos _, pos _ => PosNum.cast_add _ _\n  | pos a, neg b => by simpa only [sub_eq_add_neg] using PosNum.cast_sub' (α := α) _ _\n  | neg a, pos b =>\n    have : (↑b + -↑a : α) = -↑a + ↑b := by\n      rw [← PosNum.cast_to_int a, ← PosNum.cast_to_int b, ← Int.cast_neg, ← Int.cast_add (-a)]\n      simp [add_comm]\n    (PosNum.cast_sub' _ _).trans <| (sub_eq_add_neg _ _).trans this\n  | neg a, neg b =>\n    show -(↑(a + b) : α) = -a + -b by\n      rw [PosNum.cast_add, neg_eq_iff_eq_neg, neg_add_rev, neg_neg, neg_neg,\n          ← PosNum.cast_to_int a, ← PosNum.cast_to_int b, ← Int.cast_add, ← Int.cast_add, add_comm]\n\n"}
{"name":"ZNum.cast_succ","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : AddGroupWithOne α\nn : ZNum\n⊢ Eq (↑n.succ) (HAdd.hAdd (↑n) 1)","decl":"@[simp]\ntheorem cast_succ [AddGroupWithOne α] (n) : ((succ n : ZNum) : α) = n + 1 := by\n  rw [← add_one, cast_add, cast_one]\n\n"}
{"name":"ZNum.mul_to_int","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : ZNum\n⊢ Eq (↑(HMul.hMul m n)) (HMul.hMul ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem mul_to_int : ∀ m n, ((m * n : ZNum) : ℤ) = m * n\n  | 0, a => by cases a <;> exact (zero_mul _).symm\n  | b, 0 => by cases b <;> exact (mul_zero _).symm\n  | pos a, pos b => PosNum.cast_mul a b\n  | pos a, neg b => show -↑(a * b) = ↑a * -↑b by rw [PosNum.cast_mul, neg_mul_eq_mul_neg]\n  | neg a, pos b => show -↑(a * b) = -↑a * ↑b by rw [PosNum.cast_mul, neg_mul_eq_neg_mul]\n  | neg a, neg b => show ↑(a * b) = -↑a * -↑b by rw [PosNum.cast_mul, neg_mul_neg]\n\n"}
{"name":"ZNum.cast_mul","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : Ring α\nm n : ZNum\n⊢ Eq (↑(HMul.hMul m n)) (HMul.hMul ↑m ↑n)","decl":"theorem cast_mul [Ring α] (m n) : ((m * n : ZNum) : α) = m * n := by\n  rw [← cast_to_int, mul_to_int, Int.cast_mul, cast_to_int, cast_to_int]\n\n"}
{"name":"ZNum.ofInt'_neg","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Int\n⊢ Eq (ZNum.ofInt' (Neg.neg n)) (Neg.neg (ZNum.ofInt' n))","decl":"theorem ofInt'_neg : ∀ n : ℤ, ofInt' (-n) = -ofInt' n\n  | -[n+1] => show ofInt' (n + 1 : ℕ) = _ by simp only [ofInt', Num.zneg_toZNumNeg]\n  | 0 => show Num.toZNum (Num.ofNat' 0) = -Num.toZNum (Num.ofNat' 0) by rw [Num.ofNat'_zero]; rfl\n  | (n + 1 : ℕ) => show Num.toZNumNeg _ = -Num.toZNum _ by rw [Num.zneg_toZNum]\n\n-- Porting note: `erw [ofInt']` yields `match` so `dsimp` is required.\n"}
{"name":"ZNum.of_to_int'","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : ZNum\n⊢ Eq (ZNum.ofInt' ↑n) n","decl":"theorem of_to_int' : ∀ n : ZNum, ZNum.ofInt' n = n\n  | 0 => by dsimp [ofInt', cast_zero]; erw [Num.ofNat'_zero, Num.toZNum]\n  | pos a => by rw [cast_pos, ← PosNum.cast_to_nat, ← Num.ofInt'_toZNum, PosNum.of_to_nat]; rfl\n  | neg a => by\n    rw [cast_neg, ofInt'_neg, ← PosNum.cast_to_nat, ← Num.ofInt'_toZNum, PosNum.of_to_nat]; rfl\n\n"}
{"name":"ZNum.to_int_inj","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : ZNum\n⊢ Iff (Eq ↑m ↑n) (Eq m n)","decl":"theorem to_int_inj {m n : ZNum} : (m : ℤ) = n ↔ m = n :=\n  ⟨fun h => Function.LeftInverse.injective of_to_int' h, congr_arg _⟩\n\n"}
{"name":"ZNum.cmp_to_int","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : ZNum\n⊢ Ordering.casesOn (m.cmp n) (LT.lt ↑m ↑n) (Eq m n) (LT.lt ↑n ↑m)","decl":"theorem cmp_to_int : ∀ m n, (Ordering.casesOn (cmp m n) ((m : ℤ) < n) (m = n) ((n : ℤ) < m) : Prop)\n  | 0, 0 => rfl\n  | pos a, pos b => by\n    have := PosNum.cmp_to_nat a b; revert this; dsimp [cmp]\n    cases PosNum.cmp a b <;> dsimp <;> [simp; exact congr_arg pos; simp [GT.gt]]\n  | neg a, neg b => by\n    have := PosNum.cmp_to_nat b a; revert this; dsimp [cmp]\n    cases PosNum.cmp b a <;> dsimp <;> [simp; simp +contextual; simp [GT.gt]]\n  | pos _, 0 => PosNum.cast_pos _\n  | pos _, neg _ => lt_trans (neg_lt_zero.2 <| PosNum.cast_pos _) (PosNum.cast_pos _)\n  | 0, neg _ => neg_lt_zero.2 <| PosNum.cast_pos _\n  | neg _, 0 => neg_lt_zero.2 <| PosNum.cast_pos _\n  | neg _, pos _ => lt_trans (neg_lt_zero.2 <| PosNum.cast_pos _) (PosNum.cast_pos _)\n  | 0, pos _ => PosNum.cast_pos _\n\n"}
{"name":"ZNum.lt_to_int","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : ZNum\n⊢ Iff (LT.lt ↑m ↑n) (LT.lt m n)","decl":"@[norm_cast]\ntheorem lt_to_int {m n : ZNum} : (m : ℤ) < n ↔ m < n :=\n  show (m : ℤ) < n ↔ cmp m n = Ordering.lt from\n    match cmp m n, cmp_to_int m n with\n    | Ordering.lt, h => by simp only at h; simp [h]\n    | Ordering.eq, h => by simp only at h; simp [h, lt_irrefl]\n    | Ordering.gt, h => by simp [not_lt_of_gt h]\n\n"}
{"name":"ZNum.le_to_int","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : ZNum\n⊢ Iff (LE.le ↑m ↑n) (LE.le m n)","decl":"theorem le_to_int {m n : ZNum} : (m : ℤ) ≤ n ↔ m ≤ n := by\n  rw [← not_lt]; exact not_congr lt_to_int\n\n"}
{"name":"ZNum.cast_lt","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\nm n : ZNum\n⊢ Iff (LT.lt ↑m ↑n) (LT.lt m n)","decl":"@[simp, norm_cast]\ntheorem cast_lt [LinearOrderedRing α] {m n : ZNum} : (m : α) < n ↔ m < n := by\n  rw [← cast_to_int m, ← cast_to_int n, Int.cast_lt, lt_to_int]\n\n"}
{"name":"ZNum.cast_le","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\nm n : ZNum\n⊢ Iff (LE.le ↑m ↑n) (LE.le m n)","decl":"@[simp, norm_cast]\ntheorem cast_le [LinearOrderedRing α] {m n : ZNum} : (m : α) ≤ n ↔ m ≤ n := by\n  rw [← not_lt]; exact not_congr cast_lt\n\n"}
{"name":"ZNum.cast_inj","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\nm n : ZNum\n⊢ Iff (Eq ↑m ↑n) (Eq m n)","decl":"@[simp, norm_cast]\ntheorem cast_inj [LinearOrderedRing α] {m n : ZNum} : (m : α) = n ↔ m = n := by\n  rw [← cast_to_int m, ← cast_to_int n, Int.cast_inj (α := α), to_int_inj]\n\n"}
{"name":"ZNum.cast_sub","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : Ring α\nm n : ZNum\n⊢ Eq (↑(HSub.hSub m n)) (HSub.hSub ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_sub [Ring α] (m n) : ((m - n : ZNum) : α) = m - n := by simp [sub_eq_neg_add]\n\n"}
{"name":"ZNum.neg_of_int","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Int\n⊢ Eq (↑(Neg.neg n)) (Neg.neg ↑n)","decl":"@[norm_cast]\ntheorem neg_of_int : ∀ n, ((-n : ℤ) : ZNum) = -n\n  | (_ + 1 : ℕ) => rfl\n  | 0 => by rw [Int.cast_neg]\n  | -[_+1] => (zneg_zneg _).symm\n\n"}
{"name":"ZNum.ofInt'_eq","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Int\n⊢ Eq (ZNum.ofInt' n) ↑n","decl":"@[simp]\ntheorem ofInt'_eq : ∀ n : ℤ, ZNum.ofInt' n = n\n  | (n : ℕ) => rfl\n  | -[n+1] => by\n    show Num.toZNumNeg (n + 1 : ℕ) = -(n + 1 : ℕ)\n    rw [← neg_inj, neg_neg, Nat.cast_succ, Num.add_one, Num.zneg_toZNumNeg, Num.toZNum_succ,\n      Nat.cast_succ, ZNum.add_one]\n    rfl\n\n"}
{"name":"ZNum.of_nat_toZNum","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Nat\n⊢ Eq (↑n).toZNum ↑n","decl":"@[simp]\ntheorem of_nat_toZNum (n : ℕ) : Num.toZNum n = n :=\n  rfl\n\n-- Porting note: The priority should be `high`er than `cast_to_int`.\n"}
{"name":"ZNum.of_to_int","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : ZNum\n⊢ Eq (↑↑n) n","decl":"@[simp high, norm_cast]\ntheorem of_to_int (n : ZNum) : ((n : ℤ) : ZNum) = n := by rw [← ofInt'_eq, of_to_int']\n\n"}
{"name":"ZNum.to_of_int","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Int\n⊢ Eq (↑↑n) n","decl":"theorem to_of_int (n : ℤ) : ((n : ZNum) : ℤ) = n :=\n  Int.inductionOn' n 0 (by simp) (by simp) (by simp)\n\n"}
{"name":"ZNum.of_nat_toZNumNeg","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Nat\n⊢ Eq (↑n).toZNumNeg (Neg.neg ↑n)","decl":"@[simp]\ntheorem of_nat_toZNumNeg (n : ℕ) : Num.toZNumNeg n = -n := by rw [← of_nat_toZNum, Num.zneg_toZNum]\n\n"}
{"name":"ZNum.of_intCast","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : AddGroupWithOne α\nn : Int\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast]\ntheorem of_intCast [AddGroupWithOne α] (n : ℤ) : ((n : ZNum) : α) = n := by\n  rw [← cast_to_int, to_of_int]\n\n"}
{"name":"ZNum.of_natCast","module":"Mathlib.Data.Num.Lemmas","initialProofState":"α : Type u_1\ninst✝ : AddGroupWithOne α\nn : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast]\ntheorem of_natCast [AddGroupWithOne α] (n : ℕ) : ((n : ZNum) : α) = n := by\n  rw [← Int.cast_natCast, of_intCast, Int.cast_natCast]\n\n"}
{"name":"ZNum.dvd_to_int","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : ZNum\n⊢ Iff (Dvd.dvd ↑m ↑n) (Dvd.dvd m n)","decl":"@[simp, norm_cast]\ntheorem dvd_to_int (m n : ZNum) : (m : ℤ) ∣ n ↔ m ∣ n :=\n  ⟨fun ⟨k, e⟩ => ⟨k, by rw [← of_to_int n, e]; simp⟩, fun ⟨k, e⟩ => ⟨k, by simp [e]⟩⟩\n\n"}
{"name":"PosNum.divMod_to_nat_aux","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n d : PosNum\nq r : Num\nh₁ : Eq (HAdd.hAdd (↑r) (HMul.hMul (↑d) (HAdd.hAdd ↑q ↑q))) ↑n\nh₂ : LT.lt (↑r) (HMul.hMul 2 ↑d)\n⊢ And (Eq (HAdd.hAdd (↑(d.divModAux q r).2) (HMul.hMul ↑d ↑(d.divModAux q r).1)) ↑n) (LT.lt ↑(d.divModAux q r).2 ↑d)","decl":"theorem divMod_to_nat_aux {n d : PosNum} {q r : Num} (h₁ : (r : ℕ) + d * ((q : ℕ) + q) = n)\n    (h₂ : (r : ℕ) < 2 * d) :\n    ((divModAux d q r).2 + d * (divModAux d q r).1 : ℕ) = ↑n ∧ ((divModAux d q r).2 : ℕ) < d := by\n  unfold divModAux\n  have : ∀ {r₂}, Num.ofZNum' (Num.sub' r (Num.pos d)) = some r₂ ↔ (r : ℕ) = r₂ + d := by\n    intro r₂\n    apply Num.mem_ofZNum'.trans\n    rw [← ZNum.to_int_inj, Num.cast_toZNum, Num.cast_sub', sub_eq_iff_eq_add, ← Int.natCast_inj]\n    simp\n  cases' e : Num.ofZNum' (Num.sub' r (Num.pos d)) with r₂\n  · rw [Num.cast_bit0, two_mul]\n    refine ⟨h₁, lt_of_not_ge fun h => ?_⟩\n    cases' Nat.le.dest h with r₂ e'\n    rw [← Num.to_of_nat r₂, add_comm] at e'\n    cases e.symm.trans (this.2 e'.symm)\n  · have := this.1 e\n    simp only [Num.cast_bit1]\n    constructor\n    · rwa [two_mul, add_comm _ 1, mul_add, mul_one, ← add_assoc, ← this]\n    · rwa [this, two_mul, add_lt_add_iff_right] at h₂\n\n"}
{"name":"PosNum.divMod_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"d n : PosNum\n⊢ And (Eq (HDiv.hDiv ↑n ↑d) ↑(d.divMod n).1) (Eq (HMod.hMod ↑n ↑d) ↑(d.divMod n).2)","decl":"theorem divMod_to_nat (d n : PosNum) :\n    (n / d : ℕ) = (divMod d n).1 ∧ (n % d : ℕ) = (divMod d n).2 := by\n  rw [Nat.div_mod_unique (PosNum.cast_pos _)]\n  induction' n with n IH n IH\n  · exact\n      divMod_to_nat_aux (by simp) (Nat.mul_le_mul_left 2 (PosNum.cast_pos d : (0 : ℕ) < d))\n  · unfold divMod\n    -- Porting note: `cases'` didn't rewrite at `this`, so `revert` & `intro` are required.\n    revert IH; cases' divMod d n with q r; intro IH\n    simp only [divMod] at IH ⊢\n    apply divMod_to_nat_aux <;> simp only [Num.cast_bit1, cast_bit1]\n    · rw [← two_mul, ← two_mul, add_right_comm, mul_left_comm, ← mul_add, IH.1]\n    · omega\n  · unfold divMod\n    -- Porting note: `cases'` didn't rewrite at `this`, so `revert` & `intro` are required.\n    revert IH; cases' divMod d n with q r; intro IH\n    simp only [divMod] at IH ⊢\n    apply divMod_to_nat_aux\n    · simp only [Num.cast_bit0, cast_bit0]\n      rw [← two_mul, ← two_mul, mul_left_comm, ← mul_add, ← IH.1]\n    · simpa using IH.2\n\n"}
{"name":"PosNum.div'_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n d : PosNum\n⊢ Eq (↑(n.div' d)) (HDiv.hDiv ↑n ↑d)","decl":"@[simp]\ntheorem div'_to_nat (n d) : (div' n d : ℕ) = n / d :=\n  (divMod_to_nat _ _).1.symm\n\n"}
{"name":"PosNum.mod'_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n d : PosNum\n⊢ Eq (↑(n.mod' d)) (HMod.hMod ↑n ↑d)","decl":"@[simp]\ntheorem mod'_to_nat (n d) : (mod' n d : ℕ) = n % d :=\n  (divMod_to_nat _ _).2.symm\n\n"}
{"name":"Num.div_zero","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq (HDiv.hDiv n 0) 0","decl":"@[simp]\nprotected theorem div_zero (n : Num) : n / 0 = 0 :=\n  show n.div 0 = 0 by\n    cases n\n    · rfl\n    · simp [Num.div]\n\n"}
{"name":"Num.div_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n d : Num\n⊢ Eq (↑(HDiv.hDiv n d)) (HDiv.hDiv ↑n ↑d)","decl":"@[simp, norm_cast]\ntheorem div_to_nat : ∀ n d, ((n / d : Num) : ℕ) = n / d\n  | 0, 0 => by simp\n  | 0, pos _ => (Nat.zero_div _).symm\n  | pos _, 0 => (Nat.div_zero _).symm\n  | pos _, pos _ => PosNum.div'_to_nat _ _\n\n"}
{"name":"Num.mod_zero","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Num\n⊢ Eq (HMod.hMod n 0) n","decl":"@[simp]\nprotected theorem mod_zero (n : Num) : n % 0 = n :=\n  show n.mod 0 = n by\n    cases n\n    · rfl\n    · simp [Num.mod]\n\n"}
{"name":"Num.mod_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n d : Num\n⊢ Eq (↑(HMod.hMod n d)) (HMod.hMod ↑n ↑d)","decl":"@[simp, norm_cast]\ntheorem mod_to_nat : ∀ n d, ((n % d : Num) : ℕ) = n % d\n  | 0, 0 => by simp\n  | 0, pos _ => (Nat.zero_mod _).symm\n  | pos _, 0 => (Nat.mod_zero _).symm\n  | pos _, pos _ => PosNum.mod'_to_nat _ _\n\n"}
{"name":"Num.gcd_to_nat_aux","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : Nat\na b : Num\na✝¹ : LE.le a b\na✝ : LE.le (HMul.hMul a b).natSize n\n⊢ Eq (↑(Num.gcdAux n a b)) ((↑a).gcd ↑b)","decl":"theorem gcd_to_nat_aux :\n    ∀ {n} {a b : Num}, a ≤ b → (a * b).natSize ≤ n → (gcdAux n a b : ℕ) = Nat.gcd a b\n  | 0, 0, _, _ab, _h => (Nat.gcd_zero_left _).symm\n  | 0, pos _, 0, ab, _h => (not_lt_of_ge ab).elim rfl\n  | 0, pos _, pos _, _ab, h => (not_lt_of_le h).elim <| PosNum.natSize_pos _\n  | Nat.succ _, 0, _, _ab, _h => (Nat.gcd_zero_left _).symm\n  | Nat.succ n, pos a, b, ab, h => by\n    simp only [gcdAux, cast_pos]\n    rw [Nat.gcd_rec, gcd_to_nat_aux, mod_to_nat]\n    · rfl\n    · rw [← le_to_nat, mod_to_nat]\n      exact le_of_lt (Nat.mod_lt _ (PosNum.cast_pos _))\n    rw [natSize_to_nat, mul_to_nat, Nat.size_le] at h ⊢\n    rw [mod_to_nat, mul_comm]\n    rw [pow_succ, ← Nat.mod_add_div b (pos a)] at h\n    refine lt_of_mul_lt_mul_right (lt_of_le_of_lt ?_ h) (Nat.zero_le 2)\n    rw [mul_two, mul_add]\n    refine\n      add_le_add_left\n        (Nat.mul_le_mul_left _ (le_trans (le_of_lt (Nat.mod_lt _ (PosNum.cast_pos _))) ?_)) _\n    suffices 1 ≤ _ by simpa using Nat.mul_le_mul_left (pos a) this\n    rw [Nat.le_div_iff_mul_le a.cast_pos, one_mul]\n    exact le_to_nat.2 ab\n\n"}
{"name":"Num.gcd_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"a b : Num\n⊢ Eq (↑(a.gcd b)) ((↑a).gcd ↑b)","decl":"@[simp]\ntheorem gcd_to_nat : ∀ a b, (gcd a b : ℕ) = Nat.gcd a b := by\n  have : ∀ a b : Num, (a * b).natSize ≤ a.natSize + b.natSize := by\n    intros\n    simp only [natSize_to_nat, cast_mul]\n    rw [Nat.size_le, pow_add]\n    exact mul_lt_mul'' (Nat.lt_size_self _) (Nat.lt_size_self _) (Nat.zero_le _) (Nat.zero_le _)\n  intros\n  unfold gcd\n  split_ifs with h\n  · exact gcd_to_nat_aux h (this _ _)\n  · rw [Nat.gcd_comm]\n    exact gcd_to_nat_aux (le_of_not_le h) (this _ _)\n\n"}
{"name":"Num.dvd_iff_mod_eq_zero","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : Num\n⊢ Iff (Dvd.dvd m n) (Eq (HMod.hMod n m) 0)","decl":"theorem dvd_iff_mod_eq_zero {m n : Num} : m ∣ n ↔ n % m = 0 := by\n  rw [← dvd_to_nat, Nat.dvd_iff_mod_eq_zero, ← to_nat_inj, mod_to_nat]; rfl\n\n"}
{"name":"ZNum.div_zero","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n : ZNum\n⊢ Eq (HDiv.hDiv n 0) 0","decl":"@[simp]\nprotected theorem div_zero (n : ZNum) : n / 0 = 0 :=\n  show n.div 0 = 0 by cases n <;> rfl\n\n"}
{"name":"ZNum.div_to_int","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n d : ZNum\n⊢ Eq (↑(HDiv.hDiv n d)) (HDiv.hDiv ↑n ↑d)","decl":"@[simp, norm_cast]\ntheorem div_to_int : ∀ n d, ((n / d : ZNum) : ℤ) = n / d\n  | 0, 0 => by simp [Int.ediv_zero]\n  | 0, pos _ => (Int.zero_ediv _).symm\n  | 0, neg _ => (Int.zero_ediv _).symm\n  | pos _, 0 => (Int.ediv_zero _).symm\n  | neg _, 0 => (Int.ediv_zero _).symm\n  | pos n, pos d => (Num.cast_toZNum _).trans <| by rw [← Num.to_nat_to_int]; simp\n  | pos n, neg d => (Num.cast_toZNumNeg _).trans <| by rw [← Num.to_nat_to_int]; simp\n  | neg n, pos d =>\n    show -_ = -_ / ↑d by\n      rw [n.to_int_eq_succ_pred, d.to_int_eq_succ_pred, ← PosNum.to_nat_to_int, Num.succ'_to_nat,\n        Num.div_to_nat]\n      change -[n.pred' / ↑d+1] = -[n.pred' / (d.pred' + 1)+1]\n      rw [d.to_nat_eq_succ_pred]\n  | neg n, neg d =>\n    show ↑(PosNum.pred' n / Num.pos d).succ' = -_ / -↑d by\n      rw [n.to_int_eq_succ_pred, d.to_int_eq_succ_pred, ← PosNum.to_nat_to_int, Num.succ'_to_nat,\n        Num.div_to_nat]\n      change (Nat.succ (_ / d) : ℤ) = Nat.succ (n.pred' / (d.pred' + 1))\n      rw [d.to_nat_eq_succ_pred]\n\n"}
{"name":"ZNum.mod_to_int","module":"Mathlib.Data.Num.Lemmas","initialProofState":"n d : ZNum\n⊢ Eq (↑(HMod.hMod n d)) (HMod.hMod ↑n ↑d)","decl":"@[simp, norm_cast]\ntheorem mod_to_int : ∀ n d, ((n % d : ZNum) : ℤ) = n % d\n  | 0, _ => (Int.zero_emod _).symm\n  | pos n, d =>\n    (Num.cast_toZNum _).trans <| by\n      rw [← Num.to_nat_to_int, cast_pos, Num.mod_to_nat, ← PosNum.to_nat_to_int, abs_to_nat]\n      rfl\n  | neg n, d =>\n    (Num.cast_sub' _ _).trans <| by\n      rw [← Num.to_nat_to_int, cast_neg, ← Num.to_nat_to_int, Num.succ_to_nat, Num.mod_to_nat,\n          abs_to_nat, ← Int.subNatNat_eq_coe, n.to_int_eq_succ_pred]\n      rfl\n\n"}
{"name":"ZNum.gcd_to_nat","module":"Mathlib.Data.Num.Lemmas","initialProofState":"a b : ZNum\n⊢ Eq (↑(a.gcd b)) ((↑a).gcd ↑b)","decl":"@[simp]\ntheorem gcd_to_nat (a b) : (gcd a b : ℕ) = Int.gcd a b :=\n  (Num.gcd_to_nat _ _).trans <| by simp only [abs_to_nat]; rfl\n\n"}
{"name":"ZNum.dvd_iff_mod_eq_zero","module":"Mathlib.Data.Num.Lemmas","initialProofState":"m n : ZNum\n⊢ Iff (Dvd.dvd m n) (Eq (HMod.hMod n m) 0)","decl":"theorem dvd_iff_mod_eq_zero {m n : ZNum} : m ∣ n ↔ n % m = 0 := by\n  rw [← dvd_to_int, Int.dvd_iff_emod_eq_zero, ← to_int_inj, mod_to_int]; rfl\n\n"}
