{"name":"MvPolynomial.instCharP","module":"Mathlib.RingTheory.MvPolynomial.Basic","initialProofState":"σ : Type u\nR : Type v\ninst✝¹ : CommSemiring R\np : Nat\ninst✝ : CharP R p\n⊢ CharP (MvPolynomial σ R) p","decl":"instance [CharP R p] : CharP (MvPolynomial σ R) p where\n  cast_eq_zero_iff' n := by rw [← C_eq_coe_nat, ← C_0, C_inj, CharP.cast_eq_zero_iff R p]\n\n"}
{"name":"MvPolynomial.instCharZero","module":"Mathlib.RingTheory.MvPolynomial.Basic","initialProofState":"σ : Type u\nR : Type v\ninst✝¹ : CommSemiring R\ninst✝ : CharZero R\n⊢ CharZero (MvPolynomial σ R)","decl":"instance [CharZero R] : CharZero (MvPolynomial σ R) where\n  cast_injective x y hxy := by rwa [← C_eq_coe_nat, ← C_eq_coe_nat, C_inj, Nat.cast_inj] at hxy\n\n"}
{"name":"MvPolynomial.mapRange_eq_map","module":"Mathlib.RingTheory.MvPolynomial.Basic","initialProofState":"σ : Type u\nR : Type u_1\nS : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\np : MvPolynomial σ R\nf : RingHom R S\n⊢ Eq (Finsupp.mapRange ⇑f ⋯ p) ((MvPolynomial.map f) p)","decl":"theorem mapRange_eq_map {R S : Type*} [CommSemiring R] [CommSemiring S] (p : MvPolynomial σ R)\n    (f : R →+* S) : Finsupp.mapRange f f.map_zero p = map f p := by\n  rw [p.as_sum, Finsupp.mapRange_finset_sum, map_sum (map f)]\n  refine Finset.sum_congr rfl fun n _ => ?_\n  rw [map_monomial, ← single_eq_monomial, Finsupp.mapRange_single, single_eq_monomial]\n\n"}
{"name":"MvPolynomial.restrictSupport_mono","module":"Mathlib.RingTheory.MvPolynomial.Basic","initialProofState":"σ : Type u\nR : Type v\ninst✝ : CommSemiring R\ns t : Set (Finsupp σ Nat)\nh : HasSubset.Subset s t\n⊢ LE.le (MvPolynomial.restrictSupport R s) (MvPolynomial.restrictSupport R t)","decl":"theorem restrictSupport_mono {s t : Set (σ →₀ ℕ)} (h : s ⊆ t) :\n    restrictSupport R s ≤ restrictSupport R t := Finsupp.supported_mono h\n\n"}
{"name":"MvPolynomial.mem_restrictTotalDegree","module":"Mathlib.RingTheory.MvPolynomial.Basic","initialProofState":"σ : Type u\nR : Type v\ninst✝ : CommSemiring R\nm : Nat\np : MvPolynomial σ R\n⊢ Iff (Membership.mem (MvPolynomial.restrictTotalDegree σ R m) p) (LE.le p.totalDegree m)","decl":"theorem mem_restrictTotalDegree (p : MvPolynomial σ R) :\n    p ∈ restrictTotalDegree σ R m ↔ p.totalDegree ≤ m := by\n  rw [totalDegree, Finset.sup_le_iff]\n  rfl\n\n"}
{"name":"MvPolynomial.mem_restrictDegree","module":"Mathlib.RingTheory.MvPolynomial.Basic","initialProofState":"σ : Type u\nR : Type v\ninst✝ : CommSemiring R\np : MvPolynomial σ R\nn : Nat\n⊢ Iff (Membership.mem (MvPolynomial.restrictDegree σ R n) p) (∀ (s : Finsupp σ Nat), Membership.mem p.support s → ∀ (i : σ), LE.le (s i) n)","decl":"theorem mem_restrictDegree (p : MvPolynomial σ R) (n : ℕ) :\n    p ∈ restrictDegree σ R n ↔ ∀ s ∈ p.support, ∀ i, (s : σ →₀ ℕ) i ≤ n := by\n  rw [restrictDegree, restrictSupport, Finsupp.mem_supported]\n  rfl\n\n"}
{"name":"MvPolynomial.mem_restrictDegree_iff_sup","module":"Mathlib.RingTheory.MvPolynomial.Basic","initialProofState":"σ : Type u\nR : Type v\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\np : MvPolynomial σ R\nn : Nat\n⊢ Iff (Membership.mem (MvPolynomial.restrictDegree σ R n) p) (∀ (i : σ), LE.le (Multiset.count i p.degrees) n)","decl":"theorem mem_restrictDegree_iff_sup [DecidableEq σ] (p : MvPolynomial σ R) (n : ℕ) :\n    p ∈ restrictDegree σ R n ↔ ∀ i, p.degrees.count i ≤ n := by\n  simp only [mem_restrictDegree, degrees_def, Multiset.count_finset_sup, Finsupp.count_toMultiset,\n    Finset.sup_le_iff]\n  exact ⟨fun h n s hs => h s hs n, fun h s hs n => h n s hs⟩\n\n"}
{"name":"MvPolynomial.restrictTotalDegree_le_restrictDegree","module":"Mathlib.RingTheory.MvPolynomial.Basic","initialProofState":"σ : Type u\nR : Type v\ninst✝ : CommSemiring R\nm : Nat\n⊢ LE.le (MvPolynomial.restrictTotalDegree σ R m) (MvPolynomial.restrictDegree σ R m)","decl":"theorem restrictTotalDegree_le_restrictDegree (m : ℕ) :\n    restrictTotalDegree σ R m ≤ restrictDegree σ R m :=\n  fun p hp ↦ (mem_restrictDegree _ _ _).mpr fun s hs i ↦ (degreeOf_le_iff.mp\n    (degreeOf_le_totalDegree p i) s hs).trans ((mem_restrictTotalDegree _ _ _).mp hp)\n\n"}
{"name":"MvPolynomial.coe_basisMonomials","module":"Mathlib.RingTheory.MvPolynomial.Basic","initialProofState":"σ : Type u\nR : Type v\ninst✝ : CommSemiring R\n⊢ Eq ⇑(MvPolynomial.basisMonomials σ R) fun s => (MvPolynomial.monomial s) 1","decl":"@[simp]\ntheorem coe_basisMonomials :\n    (basisMonomials σ R : (σ →₀ ℕ) → MvPolynomial σ R) = fun s => monomial s 1 :=\n  rfl\n\n"}
{"name":"MvPolynomial.instFree","module":"Mathlib.RingTheory.MvPolynomial.Basic","initialProofState":"σ : Type u\nR : Type v\ninst✝ : CommSemiring R\n⊢ Module.Free R (MvPolynomial σ R)","decl":"/-- The `R`-module `MvPolynomial σ R` is free. -/\ninstance : Module.Free R (MvPolynomial σ R) :=\n  Module.Free.of_basis (MvPolynomial.basisMonomials σ R)\n\n"}
{"name":"MvPolynomial.linearIndependent_X","module":"Mathlib.RingTheory.MvPolynomial.Basic","initialProofState":"σ : Type u\nR : Type v\ninst✝ : CommSemiring R\n⊢ LinearIndependent R MvPolynomial.X","decl":"theorem linearIndependent_X : LinearIndependent R (X : σ → MvPolynomial σ R) :=\n  (basisMonomials σ R).linearIndependent.comp (fun s : σ => Finsupp.single s 1)\n    (Finsupp.single_left_injective one_ne_zero)\n\n"}
{"name":"MvPolynomial.instFiniteSubtypeMemSubmoduleRestrictDegreeOfFinite","module":"Mathlib.RingTheory.MvPolynomial.Basic","initialProofState":"σ : Type u\nR : Type v\ninst✝¹ : CommSemiring R\ninst✝ : Finite σ\nN : Nat\n⊢ Module.Finite R (Subtype fun x => Membership.mem (MvPolynomial.restrictDegree σ R N) x)","decl":"instance [Finite σ] (N : ℕ) : Module.Finite R (restrictDegree σ R N) :=\n  have := finite_setOf_bounded σ N\n  Module.Finite.of_basis (basisRestrictSupport R _)\n\n"}
{"name":"MvPolynomial.instFiniteSubtypeMemSubmoduleRestrictTotalDegreeOfFinite","module":"Mathlib.RingTheory.MvPolynomial.Basic","initialProofState":"σ : Type u\nR : Type v\ninst✝¹ : CommSemiring R\ninst✝ : Finite σ\nN : Nat\n⊢ Module.Finite R (Subtype fun x => Membership.mem (MvPolynomial.restrictTotalDegree σ R N) x)","decl":"instance [Finite σ] (N : ℕ) : Module.Finite R (restrictTotalDegree σ R N) :=\n  have := finite_setOf_bounded σ N\n  have : Finite {s : σ →₀ ℕ | s.sum (fun _ e ↦ e) ≤ N} := by\n    rw [Set.finite_coe_iff] at this ⊢\n    exact this.subset fun n hn i ↦ (eq_or_ne (n i) 0).elim\n      (fun h ↦ h.trans_le N.zero_le) fun h ↦\n        (Finset.single_le_sum (fun _ _ ↦ Nat.zero_le _) <| Finsupp.mem_support_iff.mpr h).trans hn\n  Module.Finite.of_basis (basisRestrictSupport R _)\n\n"}
{"name":"MvPolynomial.algebraMap_def","module":"Mathlib.RingTheory.MvPolynomial.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nσ : Type u_3\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\n⊢ Eq (algebraMap (MvPolynomial σ R) (MvPolynomial σ S)) (MvPolynomial.map (algebraMap R S))","decl":"@[simp]\nlemma algebraMap_def :\n    algebraMap (MvPolynomial σ R) (MvPolynomial σ S) = MvPolynomial.map (algebraMap R S) :=\n  rfl\n\n"}
{"name":"MvPolynomial.instIsScalarTower","module":"Mathlib.RingTheory.MvPolynomial.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nσ : Type u_3\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\n⊢ IsScalarTower R (MvPolynomial σ R) (MvPolynomial σ S)","decl":"instance : IsScalarTower R (MvPolynomial σ R) (MvPolynomial σ S) :=\n  IsScalarTower.of_algebraMap_eq' (by ext; simp)\n\n"}
