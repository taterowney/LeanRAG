{"name":"CategoryTheory.Limits.IndizationClosedUnderFilteredColimitsAux.exists_nonempty_limit_obj_of_colimit","module":"Mathlib.CategoryTheory.Limits.Indization.FilteredColimits","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nI : Type v\ninst✝⁴ : CategoryTheory.SmallCategory I\nF : CategoryTheory.Functor I (CategoryTheory.Functor (Opposite C) (Type v))\nJ : Type v\ninst✝³ : CategoryTheory.SmallCategory J\ninst✝² : CategoryTheory.FinCategory J\nG : CategoryTheory.Functor J (CategoryTheory.CostructuredArrow CategoryTheory.yoneda (CategoryTheory.Limits.colimit F))\nK : Type v\ninst✝¹ : CategoryTheory.SmallCategory K\nH : CategoryTheory.Functor K (CategoryTheory.Over (CategoryTheory.Limits.colimit F))\ninst✝ : CategoryTheory.IsFiltered K\nh : Nonempty (CategoryTheory.Limits.limit ((G.op.comp (CategoryTheory.CostructuredArrow.toOver CategoryTheory.yoneda (CategoryTheory.Limits.colimit F)).op).comp (CategoryTheory.yoneda.obj (CategoryTheory.Limits.colimit H))))\n⊢ Exists fun k => Nonempty (CategoryTheory.Limits.limit ((G.op.comp (CategoryTheory.CostructuredArrow.toOver CategoryTheory.yoneda (CategoryTheory.Limits.colimit F)).op).comp (CategoryTheory.yoneda.obj (H.obj k))))","decl":"theorem exists_nonempty_limit_obj_of_colimit [IsFiltered K]\n    (h : Nonempty <| limit <| 𝒢 ⋙ yoneda.obj (colimit H)) :\n    ∃ k, Nonempty <| limit <| 𝒢 ⋙ yoneda.obj (H.obj k) := by\n  obtain ⟨t⟩ := h\n  let t₂ := limMap (compYonedaColimitIsoColimitCompYoneda F G H).hom t\n  let t₃ := (colimitLimitIso (H ⋙ yoneda ⋙ (whiskeringLeft _ _ _).obj 𝒢).flip).inv t₂\n  obtain ⟨k, y, -⟩ := Types.jointly_surjective'.{v, max u v} t₃\n  refine ⟨k, ⟨?_⟩⟩\n  let z := (limitObjIsoLimitCompEvaluation (H ⋙ yoneda ⋙ (whiskeringLeft _ _ _).obj 𝒢).flip k).hom y\n  let y := flipCompEvaluation (H ⋙ yoneda ⋙ (whiskeringLeft _ _ _).obj 𝒢) k\n  exact (lim.mapIso y).hom z\n\n"}
{"name":"CategoryTheory.Limits.IndizationClosedUnderFilteredColimitsAux.exists_nonempty_limit_obj_of_isColimit","module":"Mathlib.CategoryTheory.Limits.Indization.FilteredColimits","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nI : Type v\ninst✝⁴ : CategoryTheory.SmallCategory I\nF : CategoryTheory.Functor I (CategoryTheory.Functor (Opposite C) (Type v))\nJ : Type v\ninst✝³ : CategoryTheory.SmallCategory J\ninst✝² : CategoryTheory.FinCategory J\nG : CategoryTheory.Functor J (CategoryTheory.CostructuredArrow CategoryTheory.yoneda (CategoryTheory.Limits.colimit F))\nK : Type v\ninst✝¹ : CategoryTheory.SmallCategory K\nH : CategoryTheory.Functor K (CategoryTheory.Over (CategoryTheory.Limits.colimit F))\ninst✝ : CategoryTheory.IsFiltered K\nc : CategoryTheory.Limits.Cocone H\nhc : CategoryTheory.Limits.IsColimit c\nT : CategoryTheory.Over (CategoryTheory.Limits.colimit F)\nhT : CategoryTheory.Iso c.pt T\nh : Nonempty (CategoryTheory.Limits.limit ((G.op.comp (CategoryTheory.CostructuredArrow.toOver CategoryTheory.yoneda (CategoryTheory.Limits.colimit F)).op).comp (CategoryTheory.yoneda.obj T)))\n⊢ Exists fun k => Nonempty (CategoryTheory.Limits.limit ((G.op.comp (CategoryTheory.CostructuredArrow.toOver CategoryTheory.yoneda (CategoryTheory.Limits.colimit F)).op).comp (CategoryTheory.yoneda.obj (H.obj k))))","decl":"theorem exists_nonempty_limit_obj_of_isColimit [IsFiltered K] {c : Cocone H} (hc : IsColimit c)\n    (T : Over (colimit F)) (hT : c.pt ≅ T)\n    (h : Nonempty <| limit <| 𝒢 ⋙ yoneda.obj T) :\n    ∃ k, Nonempty <| limit <| 𝒢 ⋙ yoneda.obj (H.obj k) := by\n  refine exists_nonempty_limit_obj_of_colimit F G H ?_\n  suffices T ≅ colimit H from Nonempty.map (lim.map (whiskerLeft 𝒢 (yoneda.map this.hom))) h\n  refine hT.symm ≪≫ IsColimit.coconePointUniqueUpToIso hc (colimit.isColimit _)\n\n"}
{"name":"CategoryTheory.Limits.IndizationClosedUnderFilteredColimitsAux.isFiltered","module":"Mathlib.CategoryTheory.Limits.Indization.FilteredColimits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type v\ninst✝¹ : CategoryTheory.SmallCategory I\nF : CategoryTheory.Functor I (CategoryTheory.Functor (Opposite C) (Type v))\ninst✝ : CategoryTheory.IsFiltered I\nhF : ∀ (i : I), CategoryTheory.Limits.IsIndObject (F.obj i)\n⊢ CategoryTheory.IsFiltered (CategoryTheory.CostructuredArrow CategoryTheory.yoneda (CategoryTheory.Limits.colimit F))","decl":"theorem isFiltered [IsFiltered I] (hF : ∀ i, IsIndObject (F.obj i)) :\n    IsFiltered (CostructuredArrow yoneda (colimit F)) := by\n  -- It suffices to show that for any functor `G : J ⥤ CostructuredArrow yoneda (colimit F)` with\n  -- `J` finite there is some `X` such that the set\n  -- `lim Hom_{CostructuredArrow yoneda (colimit F)}(G·, X)` is nonempty.\n  refine IsFiltered.iff_nonempty_limit.mpr (fun {J _ _} G => ?_)\n\n  -- We begin by remarking that `lim Hom_{Over (colimit F)}(yG·, 𝟙 (colimit F))` is nonempty,\n  -- simply because `𝟙 (colimit F)` is the terminal object. Here `y` is the functor\n  -- `CostructuredArrow yoneda (colimit F) ⥤ Over (colimit F)` induced by `yoneda`.\n  have h₁ : Nonempty (limit (G.op ⋙ (toOver _ _).op ⋙ yoneda.obj (Over.mk (𝟙 (colimit F))))) :=\n    ⟨Types.Limit.mk _ (fun j => Over.mkIdTerminal.from _) (by simp)⟩\n\n  -- `𝟙 (colimit F)` is the colimit of the diagram in `Over (colimit F)` given by the arrows of\n  -- the form `Fi ⟶ colimit F`. Thus, pulling the colimit out of the hom functor and commuting\n  -- the finite limit with the filtered colimit, we obtain\n  -- `lim_j Hom_{Over (colimit F)}(yGj, 𝟙 (colimit F)) ≅`\n  --   `colim_i lim_j Hom_{Over (colimit F)}(yGj, colimit.ι F i)`, and so we find `i` such that\n  -- the limit is non-empty.\n  obtain ⟨i, hi⟩ := exists_nonempty_limit_obj_of_isColimit F G _\n    (colimit.isColimitToOver F) _ (Iso.refl _) h₁\n\n  -- `F.obj i` is a small filtered colimit of representables, say of the functor `H : K ⥤ C`, so\n  -- `𝟙 (F.obj i)` is the colimit of the arrows of the form `yHk ⟶ Fi` in `Over Fi`.\n  -- Then `colimit.ι F i` is the colimit of the arrows of the form\n  -- `H.obj F ⟶ F.obj i ⟶ colimit F` in `Over (colimit F)`.\n  obtain ⟨⟨P⟩⟩ := hF i\n  let hc : IsColimit ((Over.map (colimit.ι F i)).mapCocone P.cocone.toOver) :=\n    isColimitOfPreserves (Over.map _) (Over.isColimitToOver P.coconeIsColimit)\n\n  -- Again, we pull the colimit out of the hom functor and commute limit and colimit to obtain\n  -- `lim_j Hom_{Over (colimit F)}(yGj, colimit.ι F i) ≅`\n  --   `colim_k lim_j Hom_{Over (colimit F)}(yGj, yHk)`, and so we find `k` such that the limit\n  -- is non-empty.\n  obtain ⟨k, hk⟩ : ∃ k, Nonempty (limit (G.op ⋙ (toOver yoneda (colimit F)).op ⋙\n      yoneda.obj ((toOver yoneda (colimit F)).obj <|\n        (pre P.F yoneda (colimit F)).obj <| (map (colimit.ι F i)).obj <| mk _))) :=\n    exists_nonempty_limit_obj_of_isColimit F G _ hc _ (Iso.refl _) hi\n\n  have htO : (toOver yoneda (colimit F)).FullyFaithful := .ofFullyFaithful _\n  -- Since the inclusion `y : CostructuredArrow yoneda (colimit F) ⥤ Over (colimit F)` is fully\n  -- faithful, `lim_j Hom_{Over (colimit F)}(yGj, yHk) ≅`\n  --   `lim_j Hom_{CostructuredArrow yoneda (colimit F)}(Gj, Hk)` and so `Hk` is the object we're\n  -- looking for.\n  let q := htO.homNatIsoMaxRight\n  obtain ⟨t'⟩ := Nonempty.map (limMap (isoWhiskerLeft G.op (q _)).hom) hk\n  exact ⟨_, ⟨((preservesLimitIso uliftFunctor.{u, v} _).inv t').down⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.isIndObject_colimit","module":"Mathlib.CategoryTheory.Limits.Indization.FilteredColimits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type v\ninst✝¹ : CategoryTheory.SmallCategory I\ninst✝ : CategoryTheory.IsFiltered I\nF : CategoryTheory.Functor I (CategoryTheory.Functor (Opposite C) (Type v))\nhF : ∀ (i : I), CategoryTheory.Limits.IsIndObject (F.obj i)\n⊢ CategoryTheory.Limits.IsIndObject (CategoryTheory.Limits.colimit F)","decl":"theorem isIndObject_colimit (I : Type v) [SmallCategory I] [IsFiltered I]\n    (F : I ⥤ Cᵒᵖ ⥤ Type v) (hF : ∀ i, IsIndObject (F.obj i)) : IsIndObject (colimit F) := by\n  have : IsFiltered (CostructuredArrow yoneda (colimit F)) :=\n    IndizationClosedUnderFilteredColimitsAux.isFiltered F hF\n  refine (isIndObject_iff _).mpr ⟨this, ?_⟩\n\n  -- It remains to show that `CostructuredArrow yoneda (colimit F)` is finally small. Because we\n  -- have already shown it is filtered, it suffices to exhibit a small weakly terminal set. For this\n  -- we use that all the `CostructuredArrow yoneda (F.obj i)` have small weakly terminal sets.\n  have : ∀ i, ∃ (s : Set (CostructuredArrow yoneda (F.obj i))) (_ : Small.{v} s),\n      ∀ i, ∃ j ∈ s, Nonempty (i ⟶ j) :=\n    fun i => (hF i).finallySmall.exists_small_weakly_terminal_set\n  choose s hs j hjs hj using this\n  refine finallySmall_of_small_weakly_terminal_set\n    (⋃ i, (map (colimit.ι F i)).obj '' (s i)) (fun A => ?_)\n  obtain ⟨i, y, hy⟩ := FunctorToTypes.jointly_surjective'.{v, v} F _ (yonedaEquiv A.hom)\n  let y' : CostructuredArrow yoneda (F.obj i) := mk (yonedaEquiv.symm y)\n  obtain ⟨x⟩ := hj _ y'\n  refine ⟨(map (colimit.ι F i)).obj (j i y'), ?_, ⟨?_⟩⟩\n  · simp only [Set.mem_iUnion, Set.mem_image]\n    exact ⟨i, j i y', hjs _ _, rfl⟩\n  · refine ?_ ≫ (map (colimit.ι F i)).map x\n    refine homMk (𝟙 A.left) (yonedaEquiv.injective ?_)\n    simp [-EmbeddingLike.apply_eq_iff_eq, hy, yonedaEquiv_comp, y']\n\n"}
