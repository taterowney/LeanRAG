{"name":"CategoryTheory.Limits.IndizationClosedUnderFilteredColimitsAux.exists_nonempty_limit_obj_of_colimit","module":"Mathlib.CategoryTheory.Limits.Indization.FilteredColimits","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\nI : Type v\ninstâœâ´ : CategoryTheory.SmallCategory I\nF : CategoryTheory.Functor I (CategoryTheory.Functor (Opposite C) (Type v))\nJ : Type v\ninstâœÂ³ : CategoryTheory.SmallCategory J\ninstâœÂ² : CategoryTheory.FinCategory J\nG : CategoryTheory.Functor J (CategoryTheory.CostructuredArrow CategoryTheory.yoneda (CategoryTheory.Limits.colimit F))\nK : Type v\ninstâœÂ¹ : CategoryTheory.SmallCategory K\nH : CategoryTheory.Functor K (CategoryTheory.Over (CategoryTheory.Limits.colimit F))\ninstâœ : CategoryTheory.IsFiltered K\nh : Nonempty (CategoryTheory.Limits.limit ((G.op.comp (CategoryTheory.CostructuredArrow.toOver CategoryTheory.yoneda (CategoryTheory.Limits.colimit F)).op).comp (CategoryTheory.yoneda.obj (CategoryTheory.Limits.colimit H))))\nâŠ¢ Exists fun k => Nonempty (CategoryTheory.Limits.limit ((G.op.comp (CategoryTheory.CostructuredArrow.toOver CategoryTheory.yoneda (CategoryTheory.Limits.colimit F)).op).comp (CategoryTheory.yoneda.obj (H.obj k))))","decl":"theorem exists_nonempty_limit_obj_of_colimit [IsFiltered K]\n    (h : Nonempty <| limit <| ğ’¢ â‹™ yoneda.obj (colimit H)) :\n    âˆƒ k, Nonempty <| limit <| ğ’¢ â‹™ yoneda.obj (H.obj k) := by\n  obtain âŸ¨tâŸ© := h\n  let tâ‚‚ := limMap (compYonedaColimitIsoColimitCompYoneda F G H).hom t\n  let tâ‚ƒ := (colimitLimitIso (H â‹™ yoneda â‹™ (whiskeringLeft _ _ _).obj ğ’¢).flip).inv tâ‚‚\n  obtain âŸ¨k, y, -âŸ© := Types.jointly_surjective'.{v, max u v} tâ‚ƒ\n  refine âŸ¨k, âŸ¨?_âŸ©âŸ©\n  let z := (limitObjIsoLimitCompEvaluation (H â‹™ yoneda â‹™ (whiskeringLeft _ _ _).obj ğ’¢).flip k).hom y\n  let y := flipCompEvaluation (H â‹™ yoneda â‹™ (whiskeringLeft _ _ _).obj ğ’¢) k\n  exact (lim.mapIso y).hom z\n\n"}
{"name":"CategoryTheory.Limits.IndizationClosedUnderFilteredColimitsAux.exists_nonempty_limit_obj_of_isColimit","module":"Mathlib.CategoryTheory.Limits.Indization.FilteredColimits","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\nI : Type v\ninstâœâ´ : CategoryTheory.SmallCategory I\nF : CategoryTheory.Functor I (CategoryTheory.Functor (Opposite C) (Type v))\nJ : Type v\ninstâœÂ³ : CategoryTheory.SmallCategory J\ninstâœÂ² : CategoryTheory.FinCategory J\nG : CategoryTheory.Functor J (CategoryTheory.CostructuredArrow CategoryTheory.yoneda (CategoryTheory.Limits.colimit F))\nK : Type v\ninstâœÂ¹ : CategoryTheory.SmallCategory K\nH : CategoryTheory.Functor K (CategoryTheory.Over (CategoryTheory.Limits.colimit F))\ninstâœ : CategoryTheory.IsFiltered K\nc : CategoryTheory.Limits.Cocone H\nhc : CategoryTheory.Limits.IsColimit c\nT : CategoryTheory.Over (CategoryTheory.Limits.colimit F)\nhT : CategoryTheory.Iso c.pt T\nh : Nonempty (CategoryTheory.Limits.limit ((G.op.comp (CategoryTheory.CostructuredArrow.toOver CategoryTheory.yoneda (CategoryTheory.Limits.colimit F)).op).comp (CategoryTheory.yoneda.obj T)))\nâŠ¢ Exists fun k => Nonempty (CategoryTheory.Limits.limit ((G.op.comp (CategoryTheory.CostructuredArrow.toOver CategoryTheory.yoneda (CategoryTheory.Limits.colimit F)).op).comp (CategoryTheory.yoneda.obj (H.obj k))))","decl":"theorem exists_nonempty_limit_obj_of_isColimit [IsFiltered K] {c : Cocone H} (hc : IsColimit c)\n    (T : Over (colimit F)) (hT : c.pt â‰… T)\n    (h : Nonempty <| limit <| ğ’¢ â‹™ yoneda.obj T) :\n    âˆƒ k, Nonempty <| limit <| ğ’¢ â‹™ yoneda.obj (H.obj k) := by\n  refine exists_nonempty_limit_obj_of_colimit F G H ?_\n  suffices T â‰… colimit H from Nonempty.map (lim.map (whiskerLeft ğ’¢ (yoneda.map this.hom))) h\n  refine hT.symm â‰ªâ‰« IsColimit.coconePointUniqueUpToIso hc (colimit.isColimit _)\n\n"}
{"name":"CategoryTheory.Limits.IndizationClosedUnderFilteredColimitsAux.isFiltered","module":"Mathlib.CategoryTheory.Limits.Indization.FilteredColimits","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type v\ninstâœÂ¹ : CategoryTheory.SmallCategory I\nF : CategoryTheory.Functor I (CategoryTheory.Functor (Opposite C) (Type v))\ninstâœ : CategoryTheory.IsFiltered I\nhF : âˆ€ (i : I), CategoryTheory.Limits.IsIndObject (F.obj i)\nâŠ¢ CategoryTheory.IsFiltered (CategoryTheory.CostructuredArrow CategoryTheory.yoneda (CategoryTheory.Limits.colimit F))","decl":"theorem isFiltered [IsFiltered I] (hF : âˆ€ i, IsIndObject (F.obj i)) :\n    IsFiltered (CostructuredArrow yoneda (colimit F)) := by\n  -- It suffices to show that for any functor `G : J â¥¤ CostructuredArrow yoneda (colimit F)` with\n  -- `J` finite there is some `X` such that the set\n  -- `lim Hom_{CostructuredArrow yoneda (colimit F)}(GÂ·, X)` is nonempty.\n  refine IsFiltered.iff_nonempty_limit.mpr (fun {J _ _} G => ?_)\n\n  -- We begin by remarking that `lim Hom_{Over (colimit F)}(yGÂ·, ğŸ™ (colimit F))` is nonempty,\n  -- simply because `ğŸ™ (colimit F)` is the terminal object. Here `y` is the functor\n  -- `CostructuredArrow yoneda (colimit F) â¥¤ Over (colimit F)` induced by `yoneda`.\n  have hâ‚ : Nonempty (limit (G.op â‹™ (toOver _ _).op â‹™ yoneda.obj (Over.mk (ğŸ™ (colimit F))))) :=\n    âŸ¨Types.Limit.mk _ (fun j => Over.mkIdTerminal.from _) (by simp)âŸ©\n\n  -- `ğŸ™ (colimit F)` is the colimit of the diagram in `Over (colimit F)` given by the arrows of\n  -- the form `Fi âŸ¶ colimit F`. Thus, pulling the colimit out of the hom functor and commuting\n  -- the finite limit with the filtered colimit, we obtain\n  -- `lim_j Hom_{Over (colimit F)}(yGj, ğŸ™ (colimit F)) â‰…`\n  --   `colim_i lim_j Hom_{Over (colimit F)}(yGj, colimit.Î¹ F i)`, and so we find `i` such that\n  -- the limit is non-empty.\n  obtain âŸ¨i, hiâŸ© := exists_nonempty_limit_obj_of_isColimit F G _\n    (colimit.isColimitToOver F) _ (Iso.refl _) hâ‚\n\n  -- `F.obj i` is a small filtered colimit of representables, say of the functor `H : K â¥¤ C`, so\n  -- `ğŸ™ (F.obj i)` is the colimit of the arrows of the form `yHk âŸ¶ Fi` in `Over Fi`.\n  -- Then `colimit.Î¹ F i` is the colimit of the arrows of the form\n  -- `H.obj F âŸ¶ F.obj i âŸ¶ colimit F` in `Over (colimit F)`.\n  obtain âŸ¨âŸ¨PâŸ©âŸ© := hF i\n  let hc : IsColimit ((Over.map (colimit.Î¹ F i)).mapCocone P.cocone.toOver) :=\n    isColimitOfPreserves (Over.map _) (Over.isColimitToOver P.coconeIsColimit)\n\n  -- Again, we pull the colimit out of the hom functor and commute limit and colimit to obtain\n  -- `lim_j Hom_{Over (colimit F)}(yGj, colimit.Î¹ F i) â‰…`\n  --   `colim_k lim_j Hom_{Over (colimit F)}(yGj, yHk)`, and so we find `k` such that the limit\n  -- is non-empty.\n  obtain âŸ¨k, hkâŸ© : âˆƒ k, Nonempty (limit (G.op â‹™ (toOver yoneda (colimit F)).op â‹™\n      yoneda.obj ((toOver yoneda (colimit F)).obj <|\n        (pre P.F yoneda (colimit F)).obj <| (map (colimit.Î¹ F i)).obj <| mk _))) :=\n    exists_nonempty_limit_obj_of_isColimit F G _ hc _ (Iso.refl _) hi\n\n  have htO : (toOver yoneda (colimit F)).FullyFaithful := .ofFullyFaithful _\n  -- Since the inclusion `y : CostructuredArrow yoneda (colimit F) â¥¤ Over (colimit F)` is fully\n  -- faithful, `lim_j Hom_{Over (colimit F)}(yGj, yHk) â‰…`\n  --   `lim_j Hom_{CostructuredArrow yoneda (colimit F)}(Gj, Hk)` and so `Hk` is the object we're\n  -- looking for.\n  let q := htO.homNatIsoMaxRight\n  obtain âŸ¨t'âŸ© := Nonempty.map (limMap (isoWhiskerLeft G.op (q _)).hom) hk\n  exact âŸ¨_, âŸ¨((preservesLimitIso uliftFunctor.{u, v} _).inv t').downâŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Limits.isIndObject_colimit","module":"Mathlib.CategoryTheory.Limits.Indization.FilteredColimits","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type v\ninstâœÂ¹ : CategoryTheory.SmallCategory I\ninstâœ : CategoryTheory.IsFiltered I\nF : CategoryTheory.Functor I (CategoryTheory.Functor (Opposite C) (Type v))\nhF : âˆ€ (i : I), CategoryTheory.Limits.IsIndObject (F.obj i)\nâŠ¢ CategoryTheory.Limits.IsIndObject (CategoryTheory.Limits.colimit F)","decl":"theorem isIndObject_colimit (I : Type v) [SmallCategory I] [IsFiltered I]\n    (F : I â¥¤ Cáµ’áµ– â¥¤ Type v) (hF : âˆ€ i, IsIndObject (F.obj i)) : IsIndObject (colimit F) := by\n  have : IsFiltered (CostructuredArrow yoneda (colimit F)) :=\n    IndizationClosedUnderFilteredColimitsAux.isFiltered F hF\n  refine (isIndObject_iff _).mpr âŸ¨this, ?_âŸ©\n\n  -- It remains to show that `CostructuredArrow yoneda (colimit F)` is finally small. Because we\n  -- have already shown it is filtered, it suffices to exhibit a small weakly terminal set. For this\n  -- we use that all the `CostructuredArrow yoneda (F.obj i)` have small weakly terminal sets.\n  have : âˆ€ i, âˆƒ (s : Set (CostructuredArrow yoneda (F.obj i))) (_ : Small.{v} s),\n      âˆ€ i, âˆƒ j âˆˆ s, Nonempty (i âŸ¶ j) :=\n    fun i => (hF i).finallySmall.exists_small_weakly_terminal_set\n  choose s hs j hjs hj using this\n  refine finallySmall_of_small_weakly_terminal_set\n    (â‹ƒ i, (map (colimit.Î¹ F i)).obj '' (s i)) (fun A => ?_)\n  obtain âŸ¨i, y, hyâŸ© := FunctorToTypes.jointly_surjective'.{v, v} F _ (yonedaEquiv A.hom)\n  let y' : CostructuredArrow yoneda (F.obj i) := mk (yonedaEquiv.symm y)\n  obtain âŸ¨xâŸ© := hj _ y'\n  refine âŸ¨(map (colimit.Î¹ F i)).obj (j i y'), ?_, âŸ¨?_âŸ©âŸ©\n  Â· simp only [Set.mem_iUnion, Set.mem_image]\n    exact âŸ¨i, j i y', hjs _ _, rflâŸ©\n  Â· refine ?_ â‰« (map (colimit.Î¹ F i)).map x\n    refine homMk (ğŸ™ A.left) (yonedaEquiv.injective ?_)\n    simp [-EmbeddingLike.apply_eq_iff_eq, hy, yonedaEquiv_comp, y']\n\n"}
