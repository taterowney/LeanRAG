{"name":"CategoryTheory.Localization.hasSmallLocalizedShiftedHom_iff","module":"Mathlib.CategoryTheory.Localization.SmallShiftedHom","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\nW : CategoryTheory.MorphismProperty C\nM : Type w'\ninst✝⁴ : AddMonoid M\ninst✝³ : CategoryTheory.HasShift C M\ninst✝² : CategoryTheory.HasShift D M\nL : CategoryTheory.Functor C D\ninst✝¹ : L.IsLocalization W\ninst✝ : L.CommShift M\nX Y : C\n⊢ Iff (CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M X Y) (∀ (a b : M), Small.{w, v₂} (Quiver.Hom ((CategoryTheory.shiftFunctor D a).obj (L.obj X)) ((CategoryTheory.shiftFunctor D b).obj (L.obj Y))))","decl":"lemma hasSmallLocalizedShiftedHom_iff\n    (L : C ⥤ D) [L.IsLocalization W] [L.CommShift M] (X Y : C) :\n    HasSmallLocalizedShiftedHom.{w} W M X Y ↔\n      ∀ (a b : M), Small.{w} ((L.obj X)⟦a⟧ ⟶ (L.obj Y)⟦b⟧) := by\n  dsimp [HasSmallLocalizedShiftedHom]\n  have eq := fun (a b : M) ↦ small_congr.{w}\n    (Iso.homCongr ((L.commShiftIso a).app X) ((L.commShiftIso b).app Y))\n  dsimp at eq\n  simp only [hasSmallLocalizedHom_iff _ L, eq]\n\n"}
{"name":"CategoryTheory.Localization.hasSmallLocalizedShiftedHom_iff_target","module":"Mathlib.CategoryTheory.Localization.SmallShiftedHom","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nW : CategoryTheory.MorphismProperty C\nM : Type w'\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\nX Y : C\ninst✝ : W.IsCompatibleWithShift M\nY' : C\nf : Quiver.Hom Y Y'\nhf : W f\n⊢ Iff (CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M X Y) (CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M X Y')","decl":"variable {Y} in\nlemma hasSmallLocalizedShiftedHom_iff_target [W.IsCompatibleWithShift M]\n    {Y' : C} (f : Y ⟶  Y') (hf : W f) :\n    HasSmallLocalizedShiftedHom.{w} W M X Y ↔ HasSmallLocalizedShiftedHom.{w} W M X Y' :=\n  forall_congr' (fun a ↦ forall_congr' (fun b ↦\n    hasSmallLocalizedHom_iff_target W (X⟦a⟧) (f⟦b⟧') (W.shift hf b)))\n\n"}
{"name":"CategoryTheory.Localization.hasSmallLocalizedShiftedHom_iff_source","module":"Mathlib.CategoryTheory.Localization.SmallShiftedHom","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nW : CategoryTheory.MorphismProperty C\nM : Type w'\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\nX : C\ninst✝ : W.IsCompatibleWithShift M\nX' : C\nf : Quiver.Hom X X'\nhf : W f\nY : C\n⊢ Iff (CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M X Y) (CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M X' Y)","decl":"variable {X} in\nlemma hasSmallLocalizedShiftedHom_iff_source [W.IsCompatibleWithShift M]\n    {X' : C} (f : X ⟶  X') (hf : W f) (Y : C) :\n    HasSmallLocalizedShiftedHom.{w} W M X Y ↔ HasSmallLocalizedShiftedHom.{w} W M X' Y :=\n  forall_congr' (fun a ↦ forall_congr' (fun b ↦\n    hasSmallLocalizedHom_iff_source W (f⟦a⟧') (W.shift hf a) (Y⟦b⟧)))\n\n"}
{"name":"CategoryTheory.Localization.hasSmallLocalizedHom_of_hasSmallLocalizedShiftedHom₀","module":"Mathlib.CategoryTheory.Localization.SmallShiftedHom","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nW : CategoryTheory.MorphismProperty C\nM : Type w'\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\nX Y : C\ninst✝ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M X Y\n⊢ CategoryTheory.Localization.HasSmallLocalizedHom W X Y","decl":"include M in\nlemma hasSmallLocalizedHom_of_hasSmallLocalizedShiftedHom₀ :\n    HasSmallLocalizedHom.{w} W X Y :=\n  (hasSmallLocalizedHom_iff_of_isos W\n    ((shiftFunctorZero C M).app X) ((shiftFunctorZero C M).app Y)).1 inferInstance\n\n"}
{"name":"CategoryTheory.Localization.instHasSmallLocalizedHomObjShiftFunctor","module":"Mathlib.CategoryTheory.Localization.SmallShiftedHom","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nW : CategoryTheory.MorphismProperty C\nM : Type w'\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\nX Y : C\ninst✝ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M X Y\nm : M\n⊢ CategoryTheory.Localization.HasSmallLocalizedHom W X ((CategoryTheory.shiftFunctor C m).obj Y)","decl":"instance (m : M) : HasSmallLocalizedHom.{w} W X (Y⟦m⟧) :=\n  (hasSmallLocalizedHom_iff_of_isos W\n    ((shiftFunctorZero C M).app X) (Iso.refl (Y⟦m⟧))).1 inferInstance\n\n"}
{"name":"CategoryTheory.Localization.instHasSmallLocalizedHomObjShiftFunctor_1","module":"Mathlib.CategoryTheory.Localization.SmallShiftedHom","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nW : CategoryTheory.MorphismProperty C\nM : Type w'\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\nX Y : C\ninst✝ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M X Y\nm : M\n⊢ CategoryTheory.Localization.HasSmallLocalizedHom W ((CategoryTheory.shiftFunctor C m).obj X) Y","decl":"instance (m : M) : HasSmallLocalizedHom.{w} W (X⟦m⟧) Y :=\n  (hasSmallLocalizedHom_iff_of_isos W\n    (Iso.refl (X⟦m⟧)) ((shiftFunctorZero C M).app Y)).1 inferInstance\n\n"}
{"name":"CategoryTheory.Localization.instHasSmallLocalizedHomObjShiftFunctor_2","module":"Mathlib.CategoryTheory.Localization.SmallShiftedHom","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nW : CategoryTheory.MorphismProperty C\nM : Type w'\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\nX Y : C\ninst✝ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M X Y\nm m' n : M\n⊢ CategoryTheory.Localization.HasSmallLocalizedHom W ((CategoryTheory.shiftFunctor C m').obj ((CategoryTheory.shiftFunctor C m).obj X)) ((CategoryTheory.shiftFunctor C n).obj Y)","decl":"instance (m m' n : M) : HasSmallLocalizedHom.{w} W (X⟦m⟧⟦m'⟧) (Y⟦n⟧) :=\n  (hasSmallLocalizedHom_iff_of_isos W\n    ((shiftFunctorAdd C m m').app X) (Iso.refl (Y⟦n⟧))).1 inferInstance\n\n"}
{"name":"CategoryTheory.Localization.instHasSmallLocalizedHomObjShiftFunctor_3","module":"Mathlib.CategoryTheory.Localization.SmallShiftedHom","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nW : CategoryTheory.MorphismProperty C\nM : Type w'\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\nX Y : C\ninst✝ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M X Y\nm n n' : M\n⊢ CategoryTheory.Localization.HasSmallLocalizedHom W ((CategoryTheory.shiftFunctor C m).obj X) ((CategoryTheory.shiftFunctor C n').obj ((CategoryTheory.shiftFunctor C n).obj Y))","decl":"instance (m n n' : M) : HasSmallLocalizedHom.{w} W (X⟦m⟧) (Y⟦n⟧⟦n'⟧) :=\n  (hasSmallLocalizedHom_iff_of_isos W\n    (Iso.refl (X⟦m⟧)) ((shiftFunctorAdd C n n').app Y)).1 inferInstance\n\n"}
{"name":"CategoryTheory.Localization.SmallHom.equiv_shift","module":"Mathlib.CategoryTheory.Localization.SmallShiftedHom","initialProofState":"C : Type u₁\ninst✝⁹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁸ : CategoryTheory.Category.{v₂, u₂} D\nW : CategoryTheory.MorphismProperty C\nM : Type w'\ninst✝⁷ : AddMonoid M\ninst✝⁶ : CategoryTheory.HasShift C M\ninst✝⁵ : CategoryTheory.HasShift D M\ninst✝⁴ : W.IsCompatibleWithShift M\nL : CategoryTheory.Functor C D\ninst✝³ : L.IsLocalization W\ninst✝² : L.CommShift M\nX Y : C\ninst✝¹ : CategoryTheory.Localization.HasSmallLocalizedHom W X Y\nf : CategoryTheory.Localization.SmallHom W X Y\na : M\ninst✝ : CategoryTheory.Localization.HasSmallLocalizedHom W ((CategoryTheory.shiftFunctor C a).obj X) ((CategoryTheory.shiftFunctor C a).obj Y)\n⊢ Eq ((CategoryTheory.Localization.SmallHom.equiv W L) (f.shift a)) (CategoryTheory.CategoryStruct.comp ((L.commShiftIso a).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map ((CategoryTheory.Localization.SmallHom.equiv W L) f)) ((L.commShiftIso a).inv.app Y)))","decl":"lemma equiv_shift : equiv W L (f.shift a) =\n    (L.commShiftIso a).hom.app X ≫ (equiv W L f)⟦a⟧' ≫ (L.commShiftIso a).inv.app Y :=\n  (W.shiftLocalizerMorphism a).equiv_smallHomMap _ _ _ (L.commShiftIso a) f\n\n"}
{"name":"CategoryTheory.Localization.SmallShiftedHom.equiv_shift'","module":"Mathlib.CategoryTheory.Localization.SmallShiftedHom","initialProofState":"C : Type u₁\ninst✝⁹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁸ : CategoryTheory.Category.{v₂, u₂} D\nW : CategoryTheory.MorphismProperty C\nM : Type w'\ninst✝⁷ : AddMonoid M\ninst✝⁶ : CategoryTheory.HasShift C M\ninst✝⁵ : CategoryTheory.HasShift D M\nL : CategoryTheory.Functor C D\ninst✝⁴ : L.IsLocalization W\ninst✝³ : L.CommShift M\nX Y : C\ninst✝² : W.IsCompatibleWithShift M\na : M\ninst✝¹ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M X Y\ninst✝ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M Y Y\nf : CategoryTheory.Localization.SmallShiftedHom W X Y a\nn a' : M\nh : Eq (HAdd.hAdd a n) a'\n⊢ Eq ((CategoryTheory.Localization.SmallHom.equiv W L) (f.shift n a' h)) (CategoryTheory.CategoryStruct.comp ((L.commShiftIso n).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D n).map ((CategoryTheory.Localization.SmallHom.equiv W L) f)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D n).map ((L.commShiftIso a).hom.app Y)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' D a n a' h).inv.app (L.obj Y)) ((L.commShiftIso a').inv.app Y)))))","decl":"lemma equiv_shift' {a : M} [HasSmallLocalizedShiftedHom.{w} W M X Y]\n    [HasSmallLocalizedShiftedHom.{w} W M Y Y]\n    (f : SmallShiftedHom.{w} W X Y a) (n a' : M) (h : a + n = a') :\n    SmallHom.equiv W L (f.shift n a' h) = (L.commShiftIso n).hom.app X ≫\n      (SmallHom.equiv W L f)⟦n⟧' ≫ ((L.commShiftIso a).hom.app Y)⟦n⟧' ≫\n        (shiftFunctorAdd' D a n a' h).inv.app (L.obj Y) ≫ (L.commShiftIso a').inv.app Y := by\n  simp only [shift, SmallHom.equiv_comp, SmallHom.equiv_shift, SmallHom.equiv_mk, assoc,\n    L.commShiftIso_add' h, Functor.CommShift.isoAdd'_inv_app, Iso.inv_hom_id_app_assoc,\n    ← Functor.map_comp_assoc, Iso.hom_inv_id_app, Functor.comp_obj, comp_id]\n\n"}
{"name":"CategoryTheory.Localization.SmallShiftedHom.equiv_shift","module":"Mathlib.CategoryTheory.Localization.SmallShiftedHom","initialProofState":"C : Type u₁\ninst✝⁹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁸ : CategoryTheory.Category.{v₂, u₂} D\nW : CategoryTheory.MorphismProperty C\nM : Type w'\ninst✝⁷ : AddMonoid M\ninst✝⁶ : CategoryTheory.HasShift C M\ninst✝⁵ : CategoryTheory.HasShift D M\nL : CategoryTheory.Functor C D\ninst✝⁴ : L.IsLocalization W\ninst✝³ : L.CommShift M\nX Y : C\ninst✝² : W.IsCompatibleWithShift M\na : M\ninst✝¹ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M X Y\ninst✝ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M Y Y\nf : CategoryTheory.Localization.SmallShiftedHom W X Y a\nn a' : M\nh : Eq (HAdd.hAdd a n) a'\n⊢ Eq ((CategoryTheory.Localization.SmallShiftedHom.equiv W L) (f.shift n a' h)) (CategoryTheory.CategoryStruct.comp ((L.commShiftIso n).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D n).map ((CategoryTheory.Localization.SmallShiftedHom.equiv W L) f)) ((CategoryTheory.shiftFunctorAdd' D a n a' h).inv.app (L.obj Y))))","decl":"lemma equiv_shift {a : M} [HasSmallLocalizedShiftedHom.{w} W M X Y]\n    [HasSmallLocalizedShiftedHom.{w} W M Y Y]\n    (f : SmallShiftedHom.{w} W X Y a) (n a' : M) (h : a + n = a') :\n    equiv W L (f.shift n a' h) = (L.commShiftIso n).hom.app X ≫ (equiv W L f)⟦n⟧' ≫\n      (shiftFunctorAdd' D a n a' h).inv.app (L.obj Y) := by\n  dsimp [equiv]\n  erw [Iso.homToEquiv_apply, Iso.homToEquiv_apply, equiv_shift']\n  simp only [Functor.comp_obj, Iso.app_hom, assoc, Iso.inv_hom_id_app, comp_id, Functor.map_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.Localization.SmallShiftedHom.equiv_comp","module":"Mathlib.CategoryTheory.Localization.SmallShiftedHom","initialProofState":"C : Type u₁\ninst✝¹¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹⁰ : CategoryTheory.Category.{v₂, u₂} D\nW : CategoryTheory.MorphismProperty C\nM : Type w'\ninst✝⁹ : AddMonoid M\ninst✝⁸ : CategoryTheory.HasShift C M\ninst✝⁷ : CategoryTheory.HasShift D M\nL : CategoryTheory.Functor C D\ninst✝⁶ : L.IsLocalization W\ninst✝⁵ : L.CommShift M\nX Y Z : C\ninst✝⁴ : W.IsCompatibleWithShift M\ninst✝³ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M X Y\ninst✝² : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M Y Z\ninst✝¹ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M X Z\ninst✝ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M Z Z\na b c : M\nf : CategoryTheory.Localization.SmallShiftedHom W X Y a\ng : CategoryTheory.Localization.SmallShiftedHom W Y Z b\nh : Eq (HAdd.hAdd b a) c\n⊢ Eq ((CategoryTheory.Localization.SmallShiftedHom.equiv W L) (f.comp g h)) (((CategoryTheory.Localization.SmallShiftedHom.equiv W L) f).comp ((CategoryTheory.Localization.SmallShiftedHom.equiv W L) g) h)","decl":"lemma equiv_comp [HasSmallLocalizedShiftedHom.{w} W M X Y]\n    [HasSmallLocalizedShiftedHom.{w} W M Y Z] [HasSmallLocalizedShiftedHom.{w} W M X Z]\n    [HasSmallLocalizedShiftedHom.{w} W M Z Z] {a b c : M}\n    (f : SmallShiftedHom.{w} W X Y a) (g : SmallShiftedHom.{w} W Y Z b) (h : b + a = c) :\n    equiv W L (f.comp g h) = (equiv W L f).comp (equiv W L g) h := by\n  dsimp [comp, equiv, ShiftedHom.comp]\n  erw [Iso.homToEquiv_apply, Iso.homToEquiv_apply, Iso.homToEquiv_apply, SmallHom.equiv_comp]\n  simp only [equiv_shift', Functor.comp_obj, Iso.app_hom, assoc, Iso.inv_hom_id_app,\n    comp_id, Functor.map_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.Localization.SmallShiftedHom.equiv_mk₀","module":"Mathlib.CategoryTheory.Localization.SmallShiftedHom","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\nW : CategoryTheory.MorphismProperty C\nM : Type w'\ninst✝⁵ : AddMonoid M\ninst✝⁴ : CategoryTheory.HasShift C M\ninst✝³ : CategoryTheory.HasShift D M\nL : CategoryTheory.Functor C D\ninst✝² : L.IsLocalization W\ninst✝¹ : L.CommShift M\nX Y : C\ninst✝ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M X Y\nm₀ : M\nhm₀ : Eq m₀ 0\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.Localization.SmallShiftedHom.equiv W L) (CategoryTheory.Localization.SmallShiftedHom.mk₀ W m₀ hm₀ f)) (CategoryTheory.ShiftedHom.mk₀ m₀ hm₀ (L.map f))","decl":"@[simp]\nlemma equiv_mk₀ [HasSmallLocalizedShiftedHom.{w} W M X Y]\n    (m₀ : M) (hm₀ : m₀ = 0) (f : X ⟶ Y) :\n    equiv W L (SmallShiftedHom.mk₀ W m₀ hm₀ f) =\n      ShiftedHom.mk₀ m₀ hm₀ (L.map f) := by\n  subst hm₀\n  dsimp [equiv, mk₀]\n  erw [SmallHom.equiv_mk, Iso.homToEquiv_apply, Functor.map_comp]\n  dsimp [equiv, mk₀, ShiftedHom.mk₀, shiftFunctorZero']\n  simp only [comp_id, L.commShiftIso_zero, Functor.CommShift.isoZero_hom_app, assoc,\n    ← Functor.map_comp_assoc, Iso.inv_hom_id_app, Functor.id_obj, Functor.map_id, id_comp]\n\n"}
{"name":"CategoryTheory.Localization.SmallShiftedHom.comp_assoc","module":"Mathlib.CategoryTheory.Localization.SmallShiftedHom","initialProofState":"C : Type u₁\ninst✝¹¹ : CategoryTheory.Category.{v₁, u₁} C\nW : CategoryTheory.MorphismProperty C\nM : Type w'\ninst✝¹⁰ : AddMonoid M\ninst✝⁹ : CategoryTheory.HasShift C M\ninst✝⁸ : W.IsCompatibleWithShift M\nX Y Z T : C\na₁ a₂ a₃ a₁₂ a₂₃ a : M\ninst✝⁷ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M X Y\ninst✝⁶ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M X Z\ninst✝⁵ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M X T\ninst✝⁴ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M Y Z\ninst✝³ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M Y T\ninst✝² : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M Z T\ninst✝¹ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M Z Z\ninst✝ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M T T\nα : CategoryTheory.Localization.SmallShiftedHom W X Y a₁\nβ : CategoryTheory.Localization.SmallShiftedHom W Y Z a₂\nγ : CategoryTheory.Localization.SmallShiftedHom W Z T a₃\nh₁₂ : Eq (HAdd.hAdd a₂ a₁) a₁₂\nh₂₃ : Eq (HAdd.hAdd a₃ a₂) a₂₃\nh : Eq (HAdd.hAdd (HAdd.hAdd a₃ a₂) a₁) a\n⊢ Eq ((α.comp β h₁₂).comp γ ⋯) (α.comp (β.comp γ h₂₃) ⋯)","decl":"lemma comp_assoc {X Y Z T : C} {a₁ a₂ a₃ a₁₂ a₂₃ a : M}\n    [HasSmallLocalizedShiftedHom.{w} W M X Y] [HasSmallLocalizedShiftedHom.{w} W M X Z]\n    [HasSmallLocalizedShiftedHom.{w} W M X T] [HasSmallLocalizedShiftedHom.{w} W M Y Z]\n    [HasSmallLocalizedShiftedHom.{w} W M Y T] [HasSmallLocalizedShiftedHom.{w} W M Z T]\n    [HasSmallLocalizedShiftedHom.{w} W M Z Z] [HasSmallLocalizedShiftedHom.{w} W M T T]\n    (α : SmallShiftedHom.{w} W X Y a₁) (β : SmallShiftedHom.{w} W Y Z a₂)\n    (γ : SmallShiftedHom.{w} W Z T a₃)\n    (h₁₂ : a₂ + a₁ = a₁₂) (h₂₃ : a₃ + a₂ = a₂₃) (h : a₃ + a₂ + a₁ = a) :\n    (α.comp β h₁₂).comp γ (show a₃ + a₁₂ = a by rw [← h₁₂, ← add_assoc, h]) =\n      α.comp (β.comp γ h₂₃) (by rw [← h₂₃, h]) := by\n  apply (equiv W W.Q).injective\n  simp only [equiv_comp, ShiftedHom.comp_assoc _ _ _ h₁₂ h₂₃ h]\n\n"}
{"name":"CategoryTheory.Localization.SmallShiftedHom.equiv_chgUniv","module":"Mathlib.CategoryTheory.Localization.SmallShiftedHom","initialProofState":"C : Type u₁\ninst✝⁸ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁷ : CategoryTheory.Category.{v₂, u₂} D\nW : CategoryTheory.MorphismProperty C\nM : Type w'\ninst✝⁶ : AddMonoid M\ninst✝⁵ : CategoryTheory.HasShift C M\ninst✝⁴ : CategoryTheory.HasShift D M\nL : CategoryTheory.Functor C D\ninst✝³ : L.IsLocalization W\ninst✝² : L.CommShift M\nX Y : C\nm : M\ninst✝¹ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M X Y\ninst✝ : CategoryTheory.Localization.HasSmallLocalizedShiftedHom W M X Y\ne : CategoryTheory.Localization.SmallShiftedHom W X Y m\n⊢ Eq ((CategoryTheory.Localization.SmallShiftedHom.equiv W L) (CategoryTheory.Localization.SmallShiftedHom.chgUniv e)) ((CategoryTheory.Localization.SmallShiftedHom.equiv W L) e)","decl":"lemma equiv_chgUniv (L : C ⥤ D) [L.IsLocalization W] [L.CommShift M] {X Y : C} {m : M}\n    [HasSmallLocalizedShiftedHom.{w} W M X Y]\n    [HasSmallLocalizedShiftedHom.{w''} W M X Y]\n    (e : SmallShiftedHom.{w} W X Y m) :\n    equiv W L (chgUniv.{w''} e) = equiv W L e := by\n  dsimp [equiv]\n  congr\n  apply SmallHom.equiv_chgUniv\n\n"}
