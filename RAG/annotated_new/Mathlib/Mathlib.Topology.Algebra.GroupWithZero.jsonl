{"name":"Filter.Tendsto.div_const","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nG₀ : Type u_3\ninst✝² : DivInvMonoid G₀\ninst✝¹ : TopologicalSpace G₀\ninst✝ : ContinuousMul G₀\nf : α → G₀\nl : Filter α\nx : G₀\nhf : Filter.Tendsto f l (nhds x)\ny : G₀\n⊢ Filter.Tendsto (fun a => HDiv.hDiv (f a) y) l (nhds (HDiv.hDiv x y))","decl":"theorem Filter.Tendsto.div_const {x : G₀} (hf : Tendsto f l (𝓝 x)) (y : G₀) :\n    Tendsto (fun a => f a / y) l (𝓝 (x / y)) := by\n  simpa only [div_eq_mul_inv] using hf.mul tendsto_const_nhds\n\n"}
{"name":"ContinuousAt.div_const","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nG₀ : Type u_3\ninst✝³ : DivInvMonoid G₀\ninst✝² : TopologicalSpace G₀\ninst✝¹ : ContinuousMul G₀\nf : α → G₀\ninst✝ : TopologicalSpace α\na : α\nhf : ContinuousAt f a\ny : G₀\n⊢ ContinuousAt (fun x => HDiv.hDiv (f x) y) a","decl":"nonrec theorem ContinuousAt.div_const {a : α} (hf : ContinuousAt f a) (y : G₀) :\n    ContinuousAt (fun x => f x / y) a :=\n  hf.div_const y\n\n"}
{"name":"ContinuousWithinAt.div_const","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nG₀ : Type u_3\ninst✝³ : DivInvMonoid G₀\ninst✝² : TopologicalSpace G₀\ninst✝¹ : ContinuousMul G₀\nf : α → G₀\ns : Set α\ninst✝ : TopologicalSpace α\na : α\nhf : ContinuousWithinAt f s a\ny : G₀\n⊢ ContinuousWithinAt (fun x => HDiv.hDiv (f x) y) s a","decl":"nonrec theorem ContinuousWithinAt.div_const {a} (hf : ContinuousWithinAt f s a) (y : G₀) :\n    ContinuousWithinAt (fun x => f x / y) s a :=\n  hf.div_const _\n\n"}
{"name":"ContinuousOn.div_const","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nG₀ : Type u_3\ninst✝³ : DivInvMonoid G₀\ninst✝² : TopologicalSpace G₀\ninst✝¹ : ContinuousMul G₀\nf : α → G₀\ns : Set α\ninst✝ : TopologicalSpace α\nhf : ContinuousOn f s\ny : G₀\n⊢ ContinuousOn (fun x => HDiv.hDiv (f x) y) s","decl":"theorem ContinuousOn.div_const (hf : ContinuousOn f s) (y : G₀) :\n    ContinuousOn (fun x => f x / y) s := by\n  simpa only [div_eq_mul_inv] using hf.mul continuousOn_const\n\n"}
{"name":"Continuous.div_const","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nG₀ : Type u_3\ninst✝³ : DivInvMonoid G₀\ninst✝² : TopologicalSpace G₀\ninst✝¹ : ContinuousMul G₀\nf : α → G₀\ninst✝ : TopologicalSpace α\nhf : Continuous f\ny : G₀\n⊢ Continuous fun x => HDiv.hDiv (f x) y","decl":"@[continuity, fun_prop]\ntheorem Continuous.div_const (hf : Continuous f) (y : G₀) : Continuous fun x => f x / y := by\n  simpa only [div_eq_mul_inv] using hf.mul continuous_const\n\n"}
{"name":"HasContinuousInv₀.continuousAt_inv₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"G₀ : Type u_4\ninst✝² : Zero G₀\ninst✝¹ : Inv G₀\ninst✝ : TopologicalSpace G₀\nself : HasContinuousInv₀ G₀\nx : G₀\na✝ : Ne x 0\n⊢ ContinuousAt Inv.inv x","decl":"/-- A type with `0` and `Inv` such that `fun x ↦ x⁻¹` is continuous at all nonzero points. Any\nnormed (semi)field has this property. -/\nclass HasContinuousInv₀ (G₀ : Type*) [Zero G₀] [Inv G₀] [TopologicalSpace G₀] : Prop where\n  /-- The map `fun x ↦ x⁻¹` is continuous at all nonzero points. -/\n  continuousAt_inv₀ : ∀ ⦃x : G₀⦄, x ≠ 0 → ContinuousAt Inv.inv x\n\n"}
{"name":"tendsto_inv₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"G₀ : Type u_3\ninst✝³ : Zero G₀\ninst✝² : Inv G₀\ninst✝¹ : TopologicalSpace G₀\ninst✝ : HasContinuousInv₀ G₀\nx : G₀\nhx : Ne x 0\n⊢ Filter.Tendsto Inv.inv (nhds x) (nhds (Inv.inv x))","decl":"theorem tendsto_inv₀ {x : G₀} (hx : x ≠ 0) : Tendsto Inv.inv (𝓝 x) (𝓝 x⁻¹) :=\n  continuousAt_inv₀ hx\n\n"}
{"name":"continuousOn_inv₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"G₀ : Type u_3\ninst✝³ : Zero G₀\ninst✝² : Inv G₀\ninst✝¹ : TopologicalSpace G₀\ninst✝ : HasContinuousInv₀ G₀\n⊢ ContinuousOn Inv.inv (HasCompl.compl (Singleton.singleton 0))","decl":"theorem continuousOn_inv₀ : ContinuousOn (Inv.inv : G₀ → G₀) {0}ᶜ := fun _x hx =>\n  (continuousAt_inv₀ hx).continuousWithinAt\n\n"}
{"name":"Filter.Tendsto.inv₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nG₀ : Type u_3\ninst✝³ : Zero G₀\ninst✝² : Inv G₀\ninst✝¹ : TopologicalSpace G₀\ninst✝ : HasContinuousInv₀ G₀\nl : Filter α\nf : α → G₀\na : G₀\nhf : Filter.Tendsto f l (nhds a)\nha : Ne a 0\n⊢ Filter.Tendsto (fun x => Inv.inv (f x)) l (nhds (Inv.inv a))","decl":"/-- If a function converges to a nonzero value, its inverse converges to the inverse of this value.\nWe use the name `Filter.Tendsto.inv₀` as `Filter.Tendsto.inv` is already used in multiplicative\ntopological groups. -/\ntheorem Filter.Tendsto.inv₀ {a : G₀} (hf : Tendsto f l (𝓝 a)) (ha : a ≠ 0) :\n    Tendsto (fun x => (f x)⁻¹) l (𝓝 a⁻¹) :=\n  (tendsto_inv₀ ha).comp hf\n\n"}
{"name":"ContinuousWithinAt.inv₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nG₀ : Type u_3\ninst✝⁴ : Zero G₀\ninst✝³ : Inv G₀\ninst✝² : TopologicalSpace G₀\ninst✝¹ : HasContinuousInv₀ G₀\nf : α → G₀\ns : Set α\na : α\ninst✝ : TopologicalSpace α\nhf : ContinuousWithinAt f s a\nha : Ne (f a) 0\n⊢ ContinuousWithinAt (fun x => Inv.inv (f x)) s a","decl":"nonrec theorem ContinuousWithinAt.inv₀ (hf : ContinuousWithinAt f s a) (ha : f a ≠ 0) :\n    ContinuousWithinAt (fun x => (f x)⁻¹) s a :=\n  hf.inv₀ ha\n\n"}
{"name":"ContinuousAt.inv₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nG₀ : Type u_3\ninst✝⁴ : Zero G₀\ninst✝³ : Inv G₀\ninst✝² : TopologicalSpace G₀\ninst✝¹ : HasContinuousInv₀ G₀\nf : α → G₀\na : α\ninst✝ : TopologicalSpace α\nhf : ContinuousAt f a\nha : Ne (f a) 0\n⊢ ContinuousAt (fun x => Inv.inv (f x)) a","decl":"@[fun_prop]\nnonrec theorem ContinuousAt.inv₀ (hf : ContinuousAt f a) (ha : f a ≠ 0) :\n    ContinuousAt (fun x => (f x)⁻¹) a :=\n  hf.inv₀ ha\n\n"}
{"name":"Continuous.inv₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nG₀ : Type u_3\ninst✝⁴ : Zero G₀\ninst✝³ : Inv G₀\ninst✝² : TopologicalSpace G₀\ninst✝¹ : HasContinuousInv₀ G₀\nf : α → G₀\ninst✝ : TopologicalSpace α\nhf : Continuous f\nh0 : ∀ (x : α), Ne (f x) 0\n⊢ Continuous fun x => Inv.inv (f x)","decl":"@[continuity, fun_prop]\ntheorem Continuous.inv₀ (hf : Continuous f) (h0 : ∀ x, f x ≠ 0) : Continuous fun x => (f x)⁻¹ :=\n  continuous_iff_continuousAt.2 fun x => (hf.tendsto x).inv₀ (h0 x)\n\n"}
{"name":"ContinuousOn.inv₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nG₀ : Type u_3\ninst✝⁴ : Zero G₀\ninst✝³ : Inv G₀\ninst✝² : TopologicalSpace G₀\ninst✝¹ : HasContinuousInv₀ G₀\nf : α → G₀\ns : Set α\ninst✝ : TopologicalSpace α\nhf : ContinuousOn f s\nh0 : ∀ (x : α), Membership.mem s x → Ne (f x) 0\n⊢ ContinuousOn (fun x => Inv.inv (f x)) s","decl":"@[fun_prop]\ntheorem ContinuousOn.inv₀ (hf : ContinuousOn f s) (h0 : ∀ x ∈ s, f x ≠ 0) :\n    ContinuousOn (fun x => (f x)⁻¹) s := fun x hx => (hf x hx).inv₀ (h0 x hx)\n\n"}
{"name":"Units.isEmbedding_val₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"G₀ : Type u_3\ninst✝² : GroupWithZero G₀\ninst✝¹ : TopologicalSpace G₀\ninst✝ : HasContinuousInv₀ G₀\n⊢ Topology.IsEmbedding Units.val","decl":"/-- If `G₀` is a group with zero with topology such that `x ↦ x⁻¹` is continuous at all nonzero\npoints. Then the coercion `G₀ˣ → G₀` is a topological embedding. -/\ntheorem Units.isEmbedding_val₀ [GroupWithZero G₀] [TopologicalSpace G₀] [HasContinuousInv₀ G₀] :\n    IsEmbedding (val : G₀ˣ → G₀) :=\n  embedding_val_mk <| (continuousOn_inv₀ (G₀ := G₀)).mono fun _ ↦ IsUnit.ne_zero\n\n"}
{"name":"Units.embedding_val₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"G₀ : Type u_3\ninst✝² : GroupWithZero G₀\ninst✝¹ : TopologicalSpace G₀\ninst✝ : HasContinuousInv₀ G₀\n⊢ Topology.IsEmbedding Units.val","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Units.embedding_val₀ := Units.isEmbedding_val₀\n\n"}
{"name":"nhds_inv₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"G₀ : Type u_3\ninst✝² : GroupWithZero G₀\ninst✝¹ : TopologicalSpace G₀\ninst✝ : HasContinuousInv₀ G₀\nx : G₀\nhx : Ne x 0\n⊢ Eq (nhds (Inv.inv x)) (Inv.inv (nhds x))","decl":"lemma nhds_inv₀ (hx : x ≠ 0) : 𝓝 x⁻¹ = (𝓝 x)⁻¹ := by\n  refine le_antisymm (inv_le_iff_le_inv.1 ?_) (tendsto_inv₀ hx)\n  simpa only [inv_inv] using tendsto_inv₀ (inv_ne_zero hx)\n\n"}
{"name":"tendsto_inv_iff₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nG₀ : Type u_3\ninst✝² : GroupWithZero G₀\ninst✝¹ : TopologicalSpace G₀\ninst✝ : HasContinuousInv₀ G₀\nx : G₀\nl : Filter α\nf : α → G₀\nhx : Ne x 0\n⊢ Iff (Filter.Tendsto (fun x => Inv.inv (f x)) l (nhds (Inv.inv x))) (Filter.Tendsto f l (nhds x))","decl":"lemma tendsto_inv_iff₀ {l : Filter α} {f : α → G₀} (hx : x ≠ 0) :\n    Tendsto (fun x ↦ (f x)⁻¹) l (𝓝 x⁻¹) ↔ Tendsto f l (𝓝 x) := by\n  simp only [nhds_inv₀ hx, ← Filter.comap_inv, tendsto_comap_iff, Function.comp_def, inv_inv]\n\n"}
{"name":"Filter.Tendsto.div","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nG₀ : Type u_3\ninst✝³ : GroupWithZero G₀\ninst✝² : TopologicalSpace G₀\ninst✝¹ : HasContinuousInv₀ G₀\ninst✝ : ContinuousMul G₀\nf g : α → G₀\nl : Filter α\na b : G₀\nhf : Filter.Tendsto f l (nhds a)\nhg : Filter.Tendsto g l (nhds b)\nhy : Ne b 0\n⊢ Filter.Tendsto (HDiv.hDiv f g) l (nhds (HDiv.hDiv a b))","decl":"theorem Filter.Tendsto.div {l : Filter α} {a b : G₀} (hf : Tendsto f l (𝓝 a))\n    (hg : Tendsto g l (𝓝 b)) (hy : b ≠ 0) : Tendsto (f / g) l (𝓝 (a / b)) := by\n  simpa only [div_eq_mul_inv] using hf.mul (hg.inv₀ hy)\n\n"}
{"name":"Filter.tendsto_mul_iff_of_ne_zero","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nG₀ : Type u_3\ninst✝⁴ : GroupWithZero G₀\ninst✝³ : TopologicalSpace G₀\ninst✝² : HasContinuousInv₀ G₀\ninst✝¹ : ContinuousMul G₀\ninst✝ : T1Space G₀\nf g : α → G₀\nl : Filter α\nx y : G₀\nhg : Filter.Tendsto g l (nhds y)\nhy : Ne y 0\n⊢ Iff (Filter.Tendsto (fun n => HMul.hMul (f n) (g n)) l (nhds (HMul.hMul x y))) (Filter.Tendsto f l (nhds x))","decl":"theorem Filter.tendsto_mul_iff_of_ne_zero [T1Space G₀] {f g : α → G₀} {l : Filter α} {x y : G₀}\n    (hg : Tendsto g l (𝓝 y)) (hy : y ≠ 0) :\n    Tendsto (fun n => f n * g n) l (𝓝 <| x * y) ↔ Tendsto f l (𝓝 x) := by\n  refine ⟨fun hfg => ?_, fun hf => hf.mul hg⟩\n  rw [← mul_div_cancel_right₀ x hy]\n  refine Tendsto.congr' ?_ (hfg.div hg hy)\n  exact (hg.eventually_ne hy).mono fun n hn => mul_div_cancel_right₀ _ hn\n\n"}
{"name":"ContinuousWithinAt.div","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nG₀ : Type u_3\ninst✝⁴ : GroupWithZero G₀\ninst✝³ : TopologicalSpace G₀\ninst✝² : HasContinuousInv₀ G₀\ninst✝¹ : ContinuousMul G₀\nf g : α → G₀\ninst✝ : TopologicalSpace α\ns : Set α\na : α\nhf : ContinuousWithinAt f s a\nhg : ContinuousWithinAt g s a\nh₀ : Ne (g a) 0\n⊢ ContinuousWithinAt (HDiv.hDiv f g) s a","decl":"nonrec theorem ContinuousWithinAt.div (hf : ContinuousWithinAt f s a)\n    (hg : ContinuousWithinAt g s a) (h₀ : g a ≠ 0) : ContinuousWithinAt (f / g) s a :=\n  hf.div hg h₀\n\n"}
{"name":"ContinuousOn.div","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nG₀ : Type u_3\ninst✝⁴ : GroupWithZero G₀\ninst✝³ : TopologicalSpace G₀\ninst✝² : HasContinuousInv₀ G₀\ninst✝¹ : ContinuousMul G₀\nf g : α → G₀\ninst✝ : TopologicalSpace α\ns : Set α\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nh₀ : ∀ (x : α), Membership.mem s x → Ne (g x) 0\n⊢ ContinuousOn (HDiv.hDiv f g) s","decl":"theorem ContinuousOn.div (hf : ContinuousOn f s) (hg : ContinuousOn g s) (h₀ : ∀ x ∈ s, g x ≠ 0) :\n    ContinuousOn (f / g) s := fun x hx => (hf x hx).div (hg x hx) (h₀ x hx)\n\n"}
{"name":"ContinuousAt.div","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nG₀ : Type u_3\ninst✝⁴ : GroupWithZero G₀\ninst✝³ : TopologicalSpace G₀\ninst✝² : HasContinuousInv₀ G₀\ninst✝¹ : ContinuousMul G₀\nf g : α → G₀\ninst✝ : TopologicalSpace α\na : α\nhf : ContinuousAt f a\nhg : ContinuousAt g a\nh₀ : Ne (g a) 0\n⊢ ContinuousAt (HDiv.hDiv f g) a","decl":"/-- Continuity at a point of the result of dividing two functions continuous at that point, where\nthe denominator is nonzero. -/\nnonrec theorem ContinuousAt.div (hf : ContinuousAt f a) (hg : ContinuousAt g a) (h₀ : g a ≠ 0) :\n    ContinuousAt (f / g) a :=\n  hf.div hg h₀\n\n"}
{"name":"Continuous.div","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nG₀ : Type u_3\ninst✝⁴ : GroupWithZero G₀\ninst✝³ : TopologicalSpace G₀\ninst✝² : HasContinuousInv₀ G₀\ninst✝¹ : ContinuousMul G₀\nf g : α → G₀\ninst✝ : TopologicalSpace α\nhf : Continuous f\nhg : Continuous g\nh₀ : ∀ (x : α), Ne (g x) 0\n⊢ Continuous (HDiv.hDiv f g)","decl":"@[continuity]\ntheorem Continuous.div (hf : Continuous f) (hg : Continuous g) (h₀ : ∀ x, g x ≠ 0) :\n    Continuous (f / g) := by simpa only [div_eq_mul_inv] using hf.mul (hg.inv₀ h₀)\n\n"}
{"name":"continuousOn_div","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"G₀ : Type u_3\ninst✝³ : GroupWithZero G₀\ninst✝² : TopologicalSpace G₀\ninst✝¹ : HasContinuousInv₀ G₀\ninst✝ : ContinuousMul G₀\n⊢ ContinuousOn (fun p => HDiv.hDiv p.1 p.2) (setOf fun p => Ne p.2 0)","decl":"theorem continuousOn_div : ContinuousOn (fun p : G₀ × G₀ => p.1 / p.2) { p | p.2 ≠ 0 } :=\n  continuousOn_fst.div continuousOn_snd fun _ => id\n\n"}
{"name":"Continuous.div₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nG₀ : Type u_3\ninst✝⁴ : GroupWithZero G₀\ninst✝³ : TopologicalSpace G₀\ninst✝² : HasContinuousInv₀ G₀\ninst✝¹ : ContinuousMul G₀\nf g : α → G₀\ninst✝ : TopologicalSpace α\nhf : Continuous f\nhg : Continuous g\nh₀ : ∀ (x : α), Ne (g x) 0\n⊢ Continuous fun x => HDiv.hDiv (f x) (g x)","decl":"@[fun_prop]\ntheorem Continuous.div₀ (hf : Continuous f) (hg : Continuous g) (h₀ : ∀ x, g x ≠ 0) :\n    Continuous (fun x => f x / g x) := by\n  simpa only [div_eq_mul_inv] using hf.mul (hg.inv₀ h₀)\n\n"}
{"name":"ContinuousAt.div₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nG₀ : Type u_3\ninst✝⁴ : GroupWithZero G₀\ninst✝³ : TopologicalSpace G₀\ninst✝² : HasContinuousInv₀ G₀\ninst✝¹ : ContinuousMul G₀\nf g : α → G₀\ninst✝ : TopologicalSpace α\na : α\nhf : ContinuousAt f a\nhg : ContinuousAt g a\nh₀ : Ne (g a) 0\n⊢ ContinuousAt (fun x => HDiv.hDiv (f x) (g x)) a","decl":"@[fun_prop]\ntheorem ContinuousAt.div₀ (hf : ContinuousAt f a) (hg : ContinuousAt g a) (h₀ : g a ≠ 0) :\n    ContinuousAt (fun x => f x / g x) a := ContinuousAt.div hf hg h₀\n\n"}
{"name":"ContinuousOn.div₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nG₀ : Type u_3\ninst✝⁴ : GroupWithZero G₀\ninst✝³ : TopologicalSpace G₀\ninst✝² : HasContinuousInv₀ G₀\ninst✝¹ : ContinuousMul G₀\nf g : α → G₀\ninst✝ : TopologicalSpace α\ns : Set α\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nh₀ : ∀ (x : α), Membership.mem s x → Ne (g x) 0\n⊢ ContinuousOn (fun x => HDiv.hDiv (f x) (g x)) s","decl":"@[fun_prop]\ntheorem ContinuousOn.div₀ (hf : ContinuousOn f s) (hg : ContinuousOn g s) (h₀ : ∀ x ∈ s, g x ≠ 0) :\n    ContinuousOn (fun x => f x / g x) s := ContinuousOn.div hf hg h₀\n\n"}
{"name":"ContinuousAt.comp_div_cases","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nβ : Type u_2\nG₀ : Type u_3\ninst✝⁵ : GroupWithZero G₀\ninst✝⁴ : TopologicalSpace G₀\ninst✝³ : HasContinuousInv₀ G₀\ninst✝² : ContinuousMul G₀\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\na : α\nf g : α → G₀\nh : α → G₀ → β\nhf : ContinuousAt f a\nhg : ContinuousAt g a\nhh : Ne (g a) 0 → ContinuousAt (Function.HasUncurry.uncurry h) { fst := a, snd := HDiv.hDiv (f a) (g a) }\nh2h : Eq (g a) 0 → Filter.Tendsto (Function.HasUncurry.uncurry h) (SProd.sprod (nhds a) Top.top) (nhds (h a 0))\n⊢ ContinuousAt (fun x => h x (HDiv.hDiv (f x) (g x))) a","decl":"/-- The function `f x / g x` is discontinuous when `g x = 0`. However, under appropriate\nconditions, `h x (f x / g x)` is still continuous.  The condition is that if `g a = 0` then `h x y`\nmust tend to `h a 0` when `x` tends to `a`, with no information about `y`. This is represented by\nthe `⊤` filter.  Note: `tendsto_prod_top_iff` characterizes this convergence in uniform spaces.  See\nalso `Filter.prod_top` and `Filter.mem_prod_top`. -/\ntheorem ContinuousAt.comp_div_cases {f g : α → G₀} (h : α → G₀ → β) (hf : ContinuousAt f a)\n    (hg : ContinuousAt g a) (hh : g a ≠ 0 → ContinuousAt (↿h) (a, f a / g a))\n    (h2h : g a = 0 → Tendsto (↿h) (𝓝 a ×ˢ ⊤) (𝓝 (h a 0))) :\n    ContinuousAt (fun x => h x (f x / g x)) a := by\n  show ContinuousAt (↿h ∘ fun x => (x, f x / g x)) a\n  by_cases hga : g a = 0\n  · rw [ContinuousAt]\n    simp_rw [comp_apply, hga, div_zero]\n    exact (h2h hga).comp (continuousAt_id.prod_mk tendsto_top)\n  · exact ContinuousAt.comp (hh hga) (continuousAt_id.prod (hf.div hg hga))\n\n"}
{"name":"Continuous.comp_div_cases","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nβ : Type u_2\nG₀ : Type u_3\ninst✝⁵ : GroupWithZero G₀\ninst✝⁴ : TopologicalSpace G₀\ninst✝³ : HasContinuousInv₀ G₀\ninst✝² : ContinuousMul G₀\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf g : α → G₀\nh : α → G₀ → β\nhf : Continuous f\nhg : Continuous g\nhh : ∀ (a : α), Ne (g a) 0 → ContinuousAt (Function.HasUncurry.uncurry h) { fst := a, snd := HDiv.hDiv (f a) (g a) }\nh2h : ∀ (a : α), Eq (g a) 0 → Filter.Tendsto (Function.HasUncurry.uncurry h) (SProd.sprod (nhds a) Top.top) (nhds (h a 0))\n⊢ Continuous fun x => h x (HDiv.hDiv (f x) (g x))","decl":"/-- `h x (f x / g x)` is continuous under certain conditions, even if the denominator is sometimes\n  `0`. See docstring of `ContinuousAt.comp_div_cases`. -/\ntheorem Continuous.comp_div_cases {f g : α → G₀} (h : α → G₀ → β) (hf : Continuous f)\n    (hg : Continuous g) (hh : ∀ a, g a ≠ 0 → ContinuousAt (↿h) (a, f a / g a))\n    (h2h : ∀ a, g a = 0 → Tendsto (↿h) (𝓝 a ×ˢ ⊤) (𝓝 (h a 0))) :\n    Continuous fun x => h x (f x / g x) :=\n  continuous_iff_continuousAt.mpr fun a =>\n    hf.continuousAt.comp_div_cases _ hg.continuousAt (hh a) (h2h a)\n\n"}
{"name":"Homeomorph.coe_mulLeft₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : GroupWithZero α\ninst✝ : ContinuousMul α\nc : α\nhc : Ne c 0\n⊢ Eq ⇑(Homeomorph.mulLeft₀ c hc) fun x => HMul.hMul c x","decl":"@[simp]\ntheorem coe_mulLeft₀ (c : α) (hc : c ≠ 0) : ⇑(Homeomorph.mulLeft₀ c hc) = (c * ·) :=\n  rfl\n\n"}
{"name":"Homeomorph.mulLeft₀_symm_apply","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : GroupWithZero α\ninst✝ : ContinuousMul α\nc : α\nhc : Ne c 0\n⊢ Eq ⇑(Homeomorph.mulLeft₀ c hc).symm fun x => HMul.hMul (Inv.inv c) x","decl":"@[simp]\ntheorem mulLeft₀_symm_apply (c : α) (hc : c ≠ 0) :\n    ((Homeomorph.mulLeft₀ c hc).symm : α → α) = (c⁻¹ * ·) :=\n  rfl\n\n"}
{"name":"Homeomorph.coe_mulRight₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : GroupWithZero α\ninst✝ : ContinuousMul α\nc : α\nhc : Ne c 0\n⊢ Eq ⇑(Homeomorph.mulRight₀ c hc) fun x => HMul.hMul x c","decl":"@[simp]\ntheorem coe_mulRight₀ (c : α) (hc : c ≠ 0) : ⇑(Homeomorph.mulRight₀ c hc) = (· * c) :=\n  rfl\n\n"}
{"name":"Homeomorph.mulRight₀_symm_apply","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : GroupWithZero α\ninst✝ : ContinuousMul α\nc : α\nhc : Ne c 0\n⊢ Eq ⇑(Homeomorph.mulRight₀ c hc).symm fun x => HMul.hMul x (Inv.inv c)","decl":"@[simp]\ntheorem mulRight₀_symm_apply (c : α) (hc : c ≠ 0) :\n    ((Homeomorph.mulRight₀ c hc).symm : α → α) = (· * c⁻¹) :=\n  rfl\n\n"}
{"name":"map_mul_left_nhds₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"G₀ : Type u_3\ninst✝² : TopologicalSpace G₀\ninst✝¹ : GroupWithZero G₀\ninst✝ : ContinuousMul G₀\na : G₀\nha : Ne a 0\nb : G₀\n⊢ Eq (Filter.map (fun x => HMul.hMul a x) (nhds b)) (nhds (HMul.hMul a b))","decl":"theorem map_mul_left_nhds₀ (ha : a ≠ 0) (b : G₀) : map (a * ·) (𝓝 b) = 𝓝 (a * b) :=\n  (Homeomorph.mulLeft₀ a ha).map_nhds_eq b\n\n"}
{"name":"map_mul_left_nhds_one₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"G₀ : Type u_3\ninst✝² : TopologicalSpace G₀\ninst✝¹ : GroupWithZero G₀\ninst✝ : ContinuousMul G₀\na : G₀\nha : Ne a 0\n⊢ Eq (Filter.map (fun x => HMul.hMul a x) (nhds 1)) (nhds a)","decl":"theorem map_mul_left_nhds_one₀ (ha : a ≠ 0) : map (a * ·) (𝓝 1) = 𝓝 (a) := by\n  rw [map_mul_left_nhds₀ ha, mul_one]\n\n"}
{"name":"map_mul_right_nhds₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"G₀ : Type u_3\ninst✝² : TopologicalSpace G₀\ninst✝¹ : GroupWithZero G₀\ninst✝ : ContinuousMul G₀\na : G₀\nha : Ne a 0\nb : G₀\n⊢ Eq (Filter.map (fun x => HMul.hMul x a) (nhds b)) (nhds (HMul.hMul b a))","decl":"theorem map_mul_right_nhds₀ (ha : a ≠ 0) (b : G₀) : map (· * a) (𝓝 b) = 𝓝 (b * a) :=\n  (Homeomorph.mulRight₀ a ha).map_nhds_eq b\n\n"}
{"name":"map_mul_right_nhds_one₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"G₀ : Type u_3\ninst✝² : TopologicalSpace G₀\ninst✝¹ : GroupWithZero G₀\ninst✝ : ContinuousMul G₀\na : G₀\nha : Ne a 0\n⊢ Eq (Filter.map (fun x => HMul.hMul x a) (nhds 1)) (nhds a)","decl":"theorem map_mul_right_nhds_one₀ (ha : a ≠ 0) : map (· * a) (𝓝 1) = 𝓝 (a) := by\n  rw [map_mul_right_nhds₀ ha, one_mul]\n\n"}
{"name":"nhds_translation_mul_inv₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"G₀ : Type u_3\ninst✝² : TopologicalSpace G₀\ninst✝¹ : GroupWithZero G₀\ninst✝ : ContinuousMul G₀\na : G₀\nha : Ne a 0\n⊢ Eq (Filter.comap (fun x => HMul.hMul x (Inv.inv a)) (nhds 1)) (nhds a)","decl":"theorem nhds_translation_mul_inv₀ (ha : a ≠ 0) : comap (· * a⁻¹) (𝓝 1) = 𝓝 a :=\n  ((Homeomorph.mulRight₀ a ha).symm.comap_nhds_eq 1).trans <| by simp\n\n"}
{"name":"HasContinuousInv₀.of_nhds_one","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"G₀ : Type u_3\ninst✝² : TopologicalSpace G₀\ninst✝¹ : GroupWithZero G₀\ninst✝ : ContinuousMul G₀\nh : Filter.Tendsto Inv.inv (nhds 1) (nhds 1)\n⊢ HasContinuousInv₀ G₀","decl":"/-- If a group with zero has continuous multiplication and `fun x ↦ x⁻¹` is continuous at one,\nthen it is continuous at any unit. -/\ntheorem HasContinuousInv₀.of_nhds_one (h : Tendsto Inv.inv (𝓝 (1 : G₀)) (𝓝 1)) :\n    HasContinuousInv₀ G₀ where\n  continuousAt_inv₀ x hx := by\n    have hx' := inv_ne_zero hx\n    rw [ContinuousAt, ← map_mul_left_nhds_one₀ hx, ← nhds_translation_mul_inv₀ hx',\n      tendsto_map'_iff, tendsto_comap_iff]\n    simpa only [Function.comp_def, mul_inv_rev, mul_inv_cancel_right₀ hx']\n\n"}
{"name":"continuousAt_zpow₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"G₀ : Type u_3\ninst✝³ : GroupWithZero G₀\ninst✝² : TopologicalSpace G₀\ninst✝¹ : HasContinuousInv₀ G₀\ninst✝ : ContinuousMul G₀\nx : G₀\nm : Int\nh : Or (Ne x 0) (LE.le 0 m)\n⊢ ContinuousAt (fun x => HPow.hPow x m) x","decl":"theorem continuousAt_zpow₀ (x : G₀) (m : ℤ) (h : x ≠ 0 ∨ 0 ≤ m) :\n    ContinuousAt (fun x => x ^ m) x := by\n  cases' m with m m\n  · simpa only [Int.ofNat_eq_coe, zpow_natCast] using continuousAt_pow x m\n  · simp only [zpow_negSucc]\n    have hx : x ≠ 0 := h.resolve_right (Int.negSucc_lt_zero m).not_le\n    exact (continuousAt_pow x (m + 1)).inv₀ (pow_ne_zero _ hx)\n\n"}
{"name":"continuousOn_zpow₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"G₀ : Type u_3\ninst✝³ : GroupWithZero G₀\ninst✝² : TopologicalSpace G₀\ninst✝¹ : HasContinuousInv₀ G₀\ninst✝ : ContinuousMul G₀\nm : Int\n⊢ ContinuousOn (fun x => HPow.hPow x m) (HasCompl.compl (Singleton.singleton 0))","decl":"theorem continuousOn_zpow₀ (m : ℤ) : ContinuousOn (fun x : G₀ => x ^ m) {0}ᶜ := fun _x hx =>\n  (continuousAt_zpow₀ _ _ (Or.inl hx)).continuousWithinAt\n\n"}
{"name":"Filter.Tendsto.zpow₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"α : Type u_1\nG₀ : Type u_3\ninst✝³ : GroupWithZero G₀\ninst✝² : TopologicalSpace G₀\ninst✝¹ : HasContinuousInv₀ G₀\ninst✝ : ContinuousMul G₀\nf : α → G₀\nl : Filter α\na : G₀\nhf : Filter.Tendsto f l (nhds a)\nm : Int\nh : Or (Ne a 0) (LE.le 0 m)\n⊢ Filter.Tendsto (fun x => HPow.hPow (f x) m) l (nhds (HPow.hPow a m))","decl":"theorem Filter.Tendsto.zpow₀ {f : α → G₀} {l : Filter α} {a : G₀} (hf : Tendsto f l (𝓝 a)) (m : ℤ)\n    (h : a ≠ 0 ∨ 0 ≤ m) : Tendsto (fun x => f x ^ m) l (𝓝 (a ^ m)) :=\n  (continuousAt_zpow₀ _ m h).tendsto.comp hf\n\n"}
{"name":"ContinuousAt.zpow₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"G₀ : Type u_3\ninst✝⁴ : GroupWithZero G₀\ninst✝³ : TopologicalSpace G₀\ninst✝² : HasContinuousInv₀ G₀\ninst✝¹ : ContinuousMul G₀\nX : Type u_4\ninst✝ : TopologicalSpace X\na : X\nf : X → G₀\nhf : ContinuousAt f a\nm : Int\nh : Or (Ne (f a) 0) (LE.le 0 m)\n⊢ ContinuousAt (fun x => HPow.hPow (f x) m) a","decl":"@[fun_prop]\nnonrec theorem ContinuousAt.zpow₀ (hf : ContinuousAt f a) (m : ℤ) (h : f a ≠ 0 ∨ 0 ≤ m) :\n    ContinuousAt (fun x => f x ^ m) a :=\n  hf.zpow₀ m h\n\n"}
{"name":"ContinuousWithinAt.zpow₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"G₀ : Type u_3\ninst✝⁴ : GroupWithZero G₀\ninst✝³ : TopologicalSpace G₀\ninst✝² : HasContinuousInv₀ G₀\ninst✝¹ : ContinuousMul G₀\nX : Type u_4\ninst✝ : TopologicalSpace X\na : X\ns : Set X\nf : X → G₀\nhf : ContinuousWithinAt f s a\nm : Int\nh : Or (Ne (f a) 0) (LE.le 0 m)\n⊢ ContinuousWithinAt (fun x => HPow.hPow (f x) m) s a","decl":"nonrec theorem ContinuousWithinAt.zpow₀ (hf : ContinuousWithinAt f s a) (m : ℤ)\n    (h : f a ≠ 0 ∨ 0 ≤ m) : ContinuousWithinAt (fun x => f x ^ m) s a :=\n  hf.zpow₀ m h\n\n"}
{"name":"ContinuousOn.zpow₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"G₀ : Type u_3\ninst✝⁴ : GroupWithZero G₀\ninst✝³ : TopologicalSpace G₀\ninst✝² : HasContinuousInv₀ G₀\ninst✝¹ : ContinuousMul G₀\nX : Type u_4\ninst✝ : TopologicalSpace X\ns : Set X\nf : X → G₀\nhf : ContinuousOn f s\nm : Int\nh : ∀ (a : X), Membership.mem s a → Or (Ne (f a) 0) (LE.le 0 m)\n⊢ ContinuousOn (fun x => HPow.hPow (f x) m) s","decl":"@[fun_prop]\ntheorem ContinuousOn.zpow₀ (hf : ContinuousOn f s) (m : ℤ) (h : ∀ a ∈ s, f a ≠ 0 ∨ 0 ≤ m) :\n    ContinuousOn (fun x => f x ^ m) s := fun a ha => (hf a ha).zpow₀ m (h a ha)\n\n"}
{"name":"Continuous.zpow₀","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"G₀ : Type u_3\ninst✝⁴ : GroupWithZero G₀\ninst✝³ : TopologicalSpace G₀\ninst✝² : HasContinuousInv₀ G₀\ninst✝¹ : ContinuousMul G₀\nX : Type u_4\ninst✝ : TopologicalSpace X\nf : X → G₀\nhf : Continuous f\nm : Int\nh0 : ∀ (a : X), Or (Ne (f a) 0) (LE.le 0 m)\n⊢ Continuous fun x => HPow.hPow (f x) m","decl":"@[continuity, fun_prop]\ntheorem Continuous.zpow₀ (hf : Continuous f) (m : ℤ) (h0 : ∀ a, f a ≠ 0 ∨ 0 ≤ m) :\n    Continuous fun x => f x ^ m :=\n  continuous_iff_continuousAt.2 fun x => (hf.tendsto x).zpow₀ m (h0 x)\n\n"}
