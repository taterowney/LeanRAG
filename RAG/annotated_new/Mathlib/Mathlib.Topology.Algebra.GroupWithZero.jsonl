{"name":"Filter.Tendsto.div_const","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nGâ‚€ : Type u_3\ninstâœÂ² : DivInvMonoid Gâ‚€\ninstâœÂ¹ : TopologicalSpace Gâ‚€\ninstâœ : ContinuousMul Gâ‚€\nf : Î± â†’ Gâ‚€\nl : Filter Î±\nx : Gâ‚€\nhf : Filter.Tendsto f l (nhds x)\ny : Gâ‚€\nâŠ¢ Filter.Tendsto (fun a => HDiv.hDiv (f a) y) l (nhds (HDiv.hDiv x y))","decl":"theorem Filter.Tendsto.div_const {x : Gâ‚€} (hf : Tendsto f l (ğ“ x)) (y : Gâ‚€) :\n    Tendsto (fun a => f a / y) l (ğ“ (x / y)) := by\n  simpa only [div_eq_mul_inv] using hf.mul tendsto_const_nhds\n\n"}
{"name":"ContinuousAt.div_const","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nGâ‚€ : Type u_3\ninstâœÂ³ : DivInvMonoid Gâ‚€\ninstâœÂ² : TopologicalSpace Gâ‚€\ninstâœÂ¹ : ContinuousMul Gâ‚€\nf : Î± â†’ Gâ‚€\ninstâœ : TopologicalSpace Î±\na : Î±\nhf : ContinuousAt f a\ny : Gâ‚€\nâŠ¢ ContinuousAt (fun x => HDiv.hDiv (f x) y) a","decl":"nonrec theorem ContinuousAt.div_const {a : Î±} (hf : ContinuousAt f a) (y : Gâ‚€) :\n    ContinuousAt (fun x => f x / y) a :=\n  hf.div_const y\n\n"}
{"name":"ContinuousWithinAt.div_const","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nGâ‚€ : Type u_3\ninstâœÂ³ : DivInvMonoid Gâ‚€\ninstâœÂ² : TopologicalSpace Gâ‚€\ninstâœÂ¹ : ContinuousMul Gâ‚€\nf : Î± â†’ Gâ‚€\ns : Set Î±\ninstâœ : TopologicalSpace Î±\na : Î±\nhf : ContinuousWithinAt f s a\ny : Gâ‚€\nâŠ¢ ContinuousWithinAt (fun x => HDiv.hDiv (f x) y) s a","decl":"nonrec theorem ContinuousWithinAt.div_const {a} (hf : ContinuousWithinAt f s a) (y : Gâ‚€) :\n    ContinuousWithinAt (fun x => f x / y) s a :=\n  hf.div_const _\n\n"}
{"name":"ContinuousOn.div_const","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nGâ‚€ : Type u_3\ninstâœÂ³ : DivInvMonoid Gâ‚€\ninstâœÂ² : TopologicalSpace Gâ‚€\ninstâœÂ¹ : ContinuousMul Gâ‚€\nf : Î± â†’ Gâ‚€\ns : Set Î±\ninstâœ : TopologicalSpace Î±\nhf : ContinuousOn f s\ny : Gâ‚€\nâŠ¢ ContinuousOn (fun x => HDiv.hDiv (f x) y) s","decl":"theorem ContinuousOn.div_const (hf : ContinuousOn f s) (y : Gâ‚€) :\n    ContinuousOn (fun x => f x / y) s := by\n  simpa only [div_eq_mul_inv] using hf.mul continuousOn_const\n\n"}
{"name":"Continuous.div_const","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nGâ‚€ : Type u_3\ninstâœÂ³ : DivInvMonoid Gâ‚€\ninstâœÂ² : TopologicalSpace Gâ‚€\ninstâœÂ¹ : ContinuousMul Gâ‚€\nf : Î± â†’ Gâ‚€\ninstâœ : TopologicalSpace Î±\nhf : Continuous f\ny : Gâ‚€\nâŠ¢ Continuous fun x => HDiv.hDiv (f x) y","decl":"@[continuity, fun_prop]\ntheorem Continuous.div_const (hf : Continuous f) (y : Gâ‚€) : Continuous fun x => f x / y := by\n  simpa only [div_eq_mul_inv] using hf.mul continuous_const\n\n"}
{"name":"HasContinuousInvâ‚€.continuousAt_invâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Gâ‚€ : Type u_4\ninstâœÂ² : Zero Gâ‚€\ninstâœÂ¹ : Inv Gâ‚€\ninstâœ : TopologicalSpace Gâ‚€\nself : HasContinuousInvâ‚€ Gâ‚€\nx : Gâ‚€\naâœ : Ne x 0\nâŠ¢ ContinuousAt Inv.inv x","decl":"/-- A type with `0` and `Inv` such that `fun x â†¦ xâ»Â¹` is continuous at all nonzero points. Any\nnormed (semi)field has this property. -/\nclass HasContinuousInvâ‚€ (Gâ‚€ : Type*) [Zero Gâ‚€] [Inv Gâ‚€] [TopologicalSpace Gâ‚€] : Prop where\n  /-- The map `fun x â†¦ xâ»Â¹` is continuous at all nonzero points. -/\n  continuousAt_invâ‚€ : âˆ€ â¦ƒx : Gâ‚€â¦„, x â‰  0 â†’ ContinuousAt Inv.inv x\n\n"}
{"name":"tendsto_invâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Gâ‚€ : Type u_3\ninstâœÂ³ : Zero Gâ‚€\ninstâœÂ² : Inv Gâ‚€\ninstâœÂ¹ : TopologicalSpace Gâ‚€\ninstâœ : HasContinuousInvâ‚€ Gâ‚€\nx : Gâ‚€\nhx : Ne x 0\nâŠ¢ Filter.Tendsto Inv.inv (nhds x) (nhds (Inv.inv x))","decl":"theorem tendsto_invâ‚€ {x : Gâ‚€} (hx : x â‰  0) : Tendsto Inv.inv (ğ“ x) (ğ“ xâ»Â¹) :=\n  continuousAt_invâ‚€ hx\n\n"}
{"name":"continuousOn_invâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Gâ‚€ : Type u_3\ninstâœÂ³ : Zero Gâ‚€\ninstâœÂ² : Inv Gâ‚€\ninstâœÂ¹ : TopologicalSpace Gâ‚€\ninstâœ : HasContinuousInvâ‚€ Gâ‚€\nâŠ¢ ContinuousOn Inv.inv (HasCompl.compl (Singleton.singleton 0))","decl":"theorem continuousOn_invâ‚€ : ContinuousOn (Inv.inv : Gâ‚€ â†’ Gâ‚€) {0}á¶œ := fun _x hx =>\n  (continuousAt_invâ‚€ hx).continuousWithinAt\n\n"}
{"name":"Filter.Tendsto.invâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nGâ‚€ : Type u_3\ninstâœÂ³ : Zero Gâ‚€\ninstâœÂ² : Inv Gâ‚€\ninstâœÂ¹ : TopologicalSpace Gâ‚€\ninstâœ : HasContinuousInvâ‚€ Gâ‚€\nl : Filter Î±\nf : Î± â†’ Gâ‚€\na : Gâ‚€\nhf : Filter.Tendsto f l (nhds a)\nha : Ne a 0\nâŠ¢ Filter.Tendsto (fun x => Inv.inv (f x)) l (nhds (Inv.inv a))","decl":"/-- If a function converges to a nonzero value, its inverse converges to the inverse of this value.\nWe use the name `Filter.Tendsto.invâ‚€` as `Filter.Tendsto.inv` is already used in multiplicative\ntopological groups. -/\ntheorem Filter.Tendsto.invâ‚€ {a : Gâ‚€} (hf : Tendsto f l (ğ“ a)) (ha : a â‰  0) :\n    Tendsto (fun x => (f x)â»Â¹) l (ğ“ aâ»Â¹) :=\n  (tendsto_invâ‚€ ha).comp hf\n\n"}
{"name":"ContinuousWithinAt.invâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nGâ‚€ : Type u_3\ninstâœâ´ : Zero Gâ‚€\ninstâœÂ³ : Inv Gâ‚€\ninstâœÂ² : TopologicalSpace Gâ‚€\ninstâœÂ¹ : HasContinuousInvâ‚€ Gâ‚€\nf : Î± â†’ Gâ‚€\ns : Set Î±\na : Î±\ninstâœ : TopologicalSpace Î±\nhf : ContinuousWithinAt f s a\nha : Ne (f a) 0\nâŠ¢ ContinuousWithinAt (fun x => Inv.inv (f x)) s a","decl":"nonrec theorem ContinuousWithinAt.invâ‚€ (hf : ContinuousWithinAt f s a) (ha : f a â‰  0) :\n    ContinuousWithinAt (fun x => (f x)â»Â¹) s a :=\n  hf.invâ‚€ ha\n\n"}
{"name":"ContinuousAt.invâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nGâ‚€ : Type u_3\ninstâœâ´ : Zero Gâ‚€\ninstâœÂ³ : Inv Gâ‚€\ninstâœÂ² : TopologicalSpace Gâ‚€\ninstâœÂ¹ : HasContinuousInvâ‚€ Gâ‚€\nf : Î± â†’ Gâ‚€\na : Î±\ninstâœ : TopologicalSpace Î±\nhf : ContinuousAt f a\nha : Ne (f a) 0\nâŠ¢ ContinuousAt (fun x => Inv.inv (f x)) a","decl":"@[fun_prop]\nnonrec theorem ContinuousAt.invâ‚€ (hf : ContinuousAt f a) (ha : f a â‰  0) :\n    ContinuousAt (fun x => (f x)â»Â¹) a :=\n  hf.invâ‚€ ha\n\n"}
{"name":"Continuous.invâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nGâ‚€ : Type u_3\ninstâœâ´ : Zero Gâ‚€\ninstâœÂ³ : Inv Gâ‚€\ninstâœÂ² : TopologicalSpace Gâ‚€\ninstâœÂ¹ : HasContinuousInvâ‚€ Gâ‚€\nf : Î± â†’ Gâ‚€\ninstâœ : TopologicalSpace Î±\nhf : Continuous f\nh0 : âˆ€ (x : Î±), Ne (f x) 0\nâŠ¢ Continuous fun x => Inv.inv (f x)","decl":"@[continuity, fun_prop]\ntheorem Continuous.invâ‚€ (hf : Continuous f) (h0 : âˆ€ x, f x â‰  0) : Continuous fun x => (f x)â»Â¹ :=\n  continuous_iff_continuousAt.2 fun x => (hf.tendsto x).invâ‚€ (h0 x)\n\n"}
{"name":"ContinuousOn.invâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nGâ‚€ : Type u_3\ninstâœâ´ : Zero Gâ‚€\ninstâœÂ³ : Inv Gâ‚€\ninstâœÂ² : TopologicalSpace Gâ‚€\ninstâœÂ¹ : HasContinuousInvâ‚€ Gâ‚€\nf : Î± â†’ Gâ‚€\ns : Set Î±\ninstâœ : TopologicalSpace Î±\nhf : ContinuousOn f s\nh0 : âˆ€ (x : Î±), Membership.mem s x â†’ Ne (f x) 0\nâŠ¢ ContinuousOn (fun x => Inv.inv (f x)) s","decl":"@[fun_prop]\ntheorem ContinuousOn.invâ‚€ (hf : ContinuousOn f s) (h0 : âˆ€ x âˆˆ s, f x â‰  0) :\n    ContinuousOn (fun x => (f x)â»Â¹) s := fun x hx => (hf x hx).invâ‚€ (h0 x hx)\n\n"}
{"name":"Units.isEmbedding_valâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Gâ‚€ : Type u_3\ninstâœÂ² : GroupWithZero Gâ‚€\ninstâœÂ¹ : TopologicalSpace Gâ‚€\ninstâœ : HasContinuousInvâ‚€ Gâ‚€\nâŠ¢ Topology.IsEmbedding Units.val","decl":"/-- If `Gâ‚€` is a group with zero with topology such that `x â†¦ xâ»Â¹` is continuous at all nonzero\npoints. Then the coercion `Gâ‚€Ë£ â†’ Gâ‚€` is a topological embedding. -/\ntheorem Units.isEmbedding_valâ‚€ [GroupWithZero Gâ‚€] [TopologicalSpace Gâ‚€] [HasContinuousInvâ‚€ Gâ‚€] :\n    IsEmbedding (val : Gâ‚€Ë£ â†’ Gâ‚€) :=\n  embedding_val_mk <| (continuousOn_invâ‚€ (Gâ‚€ := Gâ‚€)).mono fun _ â†¦ IsUnit.ne_zero\n\n"}
{"name":"Units.embedding_valâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Gâ‚€ : Type u_3\ninstâœÂ² : GroupWithZero Gâ‚€\ninstâœÂ¹ : TopologicalSpace Gâ‚€\ninstâœ : HasContinuousInvâ‚€ Gâ‚€\nâŠ¢ Topology.IsEmbedding Units.val","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Units.embedding_valâ‚€ := Units.isEmbedding_valâ‚€\n\n"}
{"name":"nhds_invâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Gâ‚€ : Type u_3\ninstâœÂ² : GroupWithZero Gâ‚€\ninstâœÂ¹ : TopologicalSpace Gâ‚€\ninstâœ : HasContinuousInvâ‚€ Gâ‚€\nx : Gâ‚€\nhx : Ne x 0\nâŠ¢ Eq (nhds (Inv.inv x)) (Inv.inv (nhds x))","decl":"lemma nhds_invâ‚€ (hx : x â‰  0) : ğ“ xâ»Â¹ = (ğ“ x)â»Â¹ := by\n  refine le_antisymm (inv_le_iff_le_inv.1 ?_) (tendsto_invâ‚€ hx)\n  simpa only [inv_inv] using tendsto_invâ‚€ (inv_ne_zero hx)\n\n"}
{"name":"tendsto_inv_iffâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nGâ‚€ : Type u_3\ninstâœÂ² : GroupWithZero Gâ‚€\ninstâœÂ¹ : TopologicalSpace Gâ‚€\ninstâœ : HasContinuousInvâ‚€ Gâ‚€\nx : Gâ‚€\nl : Filter Î±\nf : Î± â†’ Gâ‚€\nhx : Ne x 0\nâŠ¢ Iff (Filter.Tendsto (fun x => Inv.inv (f x)) l (nhds (Inv.inv x))) (Filter.Tendsto f l (nhds x))","decl":"lemma tendsto_inv_iffâ‚€ {l : Filter Î±} {f : Î± â†’ Gâ‚€} (hx : x â‰  0) :\n    Tendsto (fun x â†¦ (f x)â»Â¹) l (ğ“ xâ»Â¹) â†” Tendsto f l (ğ“ x) := by\n  simp only [nhds_invâ‚€ hx, â† Filter.comap_inv, tendsto_comap_iff, Function.comp_def, inv_inv]\n\n"}
{"name":"Filter.Tendsto.div","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nGâ‚€ : Type u_3\ninstâœÂ³ : GroupWithZero Gâ‚€\ninstâœÂ² : TopologicalSpace Gâ‚€\ninstâœÂ¹ : HasContinuousInvâ‚€ Gâ‚€\ninstâœ : ContinuousMul Gâ‚€\nf g : Î± â†’ Gâ‚€\nl : Filter Î±\na b : Gâ‚€\nhf : Filter.Tendsto f l (nhds a)\nhg : Filter.Tendsto g l (nhds b)\nhy : Ne b 0\nâŠ¢ Filter.Tendsto (HDiv.hDiv f g) l (nhds (HDiv.hDiv a b))","decl":"theorem Filter.Tendsto.div {l : Filter Î±} {a b : Gâ‚€} (hf : Tendsto f l (ğ“ a))\n    (hg : Tendsto g l (ğ“ b)) (hy : b â‰  0) : Tendsto (f / g) l (ğ“ (a / b)) := by\n  simpa only [div_eq_mul_inv] using hf.mul (hg.invâ‚€ hy)\n\n"}
{"name":"Filter.tendsto_mul_iff_of_ne_zero","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nGâ‚€ : Type u_3\ninstâœâ´ : GroupWithZero Gâ‚€\ninstâœÂ³ : TopologicalSpace Gâ‚€\ninstâœÂ² : HasContinuousInvâ‚€ Gâ‚€\ninstâœÂ¹ : ContinuousMul Gâ‚€\ninstâœ : T1Space Gâ‚€\nf g : Î± â†’ Gâ‚€\nl : Filter Î±\nx y : Gâ‚€\nhg : Filter.Tendsto g l (nhds y)\nhy : Ne y 0\nâŠ¢ Iff (Filter.Tendsto (fun n => HMul.hMul (f n) (g n)) l (nhds (HMul.hMul x y))) (Filter.Tendsto f l (nhds x))","decl":"theorem Filter.tendsto_mul_iff_of_ne_zero [T1Space Gâ‚€] {f g : Î± â†’ Gâ‚€} {l : Filter Î±} {x y : Gâ‚€}\n    (hg : Tendsto g l (ğ“ y)) (hy : y â‰  0) :\n    Tendsto (fun n => f n * g n) l (ğ“ <| x * y) â†” Tendsto f l (ğ“ x) := by\n  refine âŸ¨fun hfg => ?_, fun hf => hf.mul hgâŸ©\n  rw [â† mul_div_cancel_rightâ‚€ x hy]\n  refine Tendsto.congr' ?_ (hfg.div hg hy)\n  exact (hg.eventually_ne hy).mono fun n hn => mul_div_cancel_rightâ‚€ _ hn\n\n"}
{"name":"ContinuousWithinAt.div","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nGâ‚€ : Type u_3\ninstâœâ´ : GroupWithZero Gâ‚€\ninstâœÂ³ : TopologicalSpace Gâ‚€\ninstâœÂ² : HasContinuousInvâ‚€ Gâ‚€\ninstâœÂ¹ : ContinuousMul Gâ‚€\nf g : Î± â†’ Gâ‚€\ninstâœ : TopologicalSpace Î±\ns : Set Î±\na : Î±\nhf : ContinuousWithinAt f s a\nhg : ContinuousWithinAt g s a\nhâ‚€ : Ne (g a) 0\nâŠ¢ ContinuousWithinAt (HDiv.hDiv f g) s a","decl":"nonrec theorem ContinuousWithinAt.div (hf : ContinuousWithinAt f s a)\n    (hg : ContinuousWithinAt g s a) (hâ‚€ : g a â‰  0) : ContinuousWithinAt (f / g) s a :=\n  hf.div hg hâ‚€\n\n"}
{"name":"ContinuousOn.div","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nGâ‚€ : Type u_3\ninstâœâ´ : GroupWithZero Gâ‚€\ninstâœÂ³ : TopologicalSpace Gâ‚€\ninstâœÂ² : HasContinuousInvâ‚€ Gâ‚€\ninstâœÂ¹ : ContinuousMul Gâ‚€\nf g : Î± â†’ Gâ‚€\ninstâœ : TopologicalSpace Î±\ns : Set Î±\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nhâ‚€ : âˆ€ (x : Î±), Membership.mem s x â†’ Ne (g x) 0\nâŠ¢ ContinuousOn (HDiv.hDiv f g) s","decl":"theorem ContinuousOn.div (hf : ContinuousOn f s) (hg : ContinuousOn g s) (hâ‚€ : âˆ€ x âˆˆ s, g x â‰  0) :\n    ContinuousOn (f / g) s := fun x hx => (hf x hx).div (hg x hx) (hâ‚€ x hx)\n\n"}
{"name":"ContinuousAt.div","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nGâ‚€ : Type u_3\ninstâœâ´ : GroupWithZero Gâ‚€\ninstâœÂ³ : TopologicalSpace Gâ‚€\ninstâœÂ² : HasContinuousInvâ‚€ Gâ‚€\ninstâœÂ¹ : ContinuousMul Gâ‚€\nf g : Î± â†’ Gâ‚€\ninstâœ : TopologicalSpace Î±\na : Î±\nhf : ContinuousAt f a\nhg : ContinuousAt g a\nhâ‚€ : Ne (g a) 0\nâŠ¢ ContinuousAt (HDiv.hDiv f g) a","decl":"/-- Continuity at a point of the result of dividing two functions continuous at that point, where\nthe denominator is nonzero. -/\nnonrec theorem ContinuousAt.div (hf : ContinuousAt f a) (hg : ContinuousAt g a) (hâ‚€ : g a â‰  0) :\n    ContinuousAt (f / g) a :=\n  hf.div hg hâ‚€\n\n"}
{"name":"Continuous.div","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nGâ‚€ : Type u_3\ninstâœâ´ : GroupWithZero Gâ‚€\ninstâœÂ³ : TopologicalSpace Gâ‚€\ninstâœÂ² : HasContinuousInvâ‚€ Gâ‚€\ninstâœÂ¹ : ContinuousMul Gâ‚€\nf g : Î± â†’ Gâ‚€\ninstâœ : TopologicalSpace Î±\nhf : Continuous f\nhg : Continuous g\nhâ‚€ : âˆ€ (x : Î±), Ne (g x) 0\nâŠ¢ Continuous (HDiv.hDiv f g)","decl":"@[continuity]\ntheorem Continuous.div (hf : Continuous f) (hg : Continuous g) (hâ‚€ : âˆ€ x, g x â‰  0) :\n    Continuous (f / g) := by simpa only [div_eq_mul_inv] using hf.mul (hg.invâ‚€ hâ‚€)\n\n"}
{"name":"continuousOn_div","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Gâ‚€ : Type u_3\ninstâœÂ³ : GroupWithZero Gâ‚€\ninstâœÂ² : TopologicalSpace Gâ‚€\ninstâœÂ¹ : HasContinuousInvâ‚€ Gâ‚€\ninstâœ : ContinuousMul Gâ‚€\nâŠ¢ ContinuousOn (fun p => HDiv.hDiv p.1 p.2) (setOf fun p => Ne p.2 0)","decl":"theorem continuousOn_div : ContinuousOn (fun p : Gâ‚€ Ã— Gâ‚€ => p.1 / p.2) { p | p.2 â‰  0 } :=\n  continuousOn_fst.div continuousOn_snd fun _ => id\n\n"}
{"name":"Continuous.divâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nGâ‚€ : Type u_3\ninstâœâ´ : GroupWithZero Gâ‚€\ninstâœÂ³ : TopologicalSpace Gâ‚€\ninstâœÂ² : HasContinuousInvâ‚€ Gâ‚€\ninstâœÂ¹ : ContinuousMul Gâ‚€\nf g : Î± â†’ Gâ‚€\ninstâœ : TopologicalSpace Î±\nhf : Continuous f\nhg : Continuous g\nhâ‚€ : âˆ€ (x : Î±), Ne (g x) 0\nâŠ¢ Continuous fun x => HDiv.hDiv (f x) (g x)","decl":"@[fun_prop]\ntheorem Continuous.divâ‚€ (hf : Continuous f) (hg : Continuous g) (hâ‚€ : âˆ€ x, g x â‰  0) :\n    Continuous (fun x => f x / g x) := by\n  simpa only [div_eq_mul_inv] using hf.mul (hg.invâ‚€ hâ‚€)\n\n"}
{"name":"ContinuousAt.divâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nGâ‚€ : Type u_3\ninstâœâ´ : GroupWithZero Gâ‚€\ninstâœÂ³ : TopologicalSpace Gâ‚€\ninstâœÂ² : HasContinuousInvâ‚€ Gâ‚€\ninstâœÂ¹ : ContinuousMul Gâ‚€\nf g : Î± â†’ Gâ‚€\ninstâœ : TopologicalSpace Î±\na : Î±\nhf : ContinuousAt f a\nhg : ContinuousAt g a\nhâ‚€ : Ne (g a) 0\nâŠ¢ ContinuousAt (fun x => HDiv.hDiv (f x) (g x)) a","decl":"@[fun_prop]\ntheorem ContinuousAt.divâ‚€ (hf : ContinuousAt f a) (hg : ContinuousAt g a) (hâ‚€ : g a â‰  0) :\n    ContinuousAt (fun x => f x / g x) a := ContinuousAt.div hf hg hâ‚€\n\n"}
{"name":"ContinuousOn.divâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nGâ‚€ : Type u_3\ninstâœâ´ : GroupWithZero Gâ‚€\ninstâœÂ³ : TopologicalSpace Gâ‚€\ninstâœÂ² : HasContinuousInvâ‚€ Gâ‚€\ninstâœÂ¹ : ContinuousMul Gâ‚€\nf g : Î± â†’ Gâ‚€\ninstâœ : TopologicalSpace Î±\ns : Set Î±\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nhâ‚€ : âˆ€ (x : Î±), Membership.mem s x â†’ Ne (g x) 0\nâŠ¢ ContinuousOn (fun x => HDiv.hDiv (f x) (g x)) s","decl":"@[fun_prop]\ntheorem ContinuousOn.divâ‚€ (hf : ContinuousOn f s) (hg : ContinuousOn g s) (hâ‚€ : âˆ€ x âˆˆ s, g x â‰  0) :\n    ContinuousOn (fun x => f x / g x) s := ContinuousOn.div hf hg hâ‚€\n\n"}
{"name":"ContinuousAt.comp_div_cases","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nGâ‚€ : Type u_3\ninstâœâµ : GroupWithZero Gâ‚€\ninstâœâ´ : TopologicalSpace Gâ‚€\ninstâœÂ³ : HasContinuousInvâ‚€ Gâ‚€\ninstâœÂ² : ContinuousMul Gâ‚€\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\na : Î±\nf g : Î± â†’ Gâ‚€\nh : Î± â†’ Gâ‚€ â†’ Î²\nhf : ContinuousAt f a\nhg : ContinuousAt g a\nhh : Ne (g a) 0 â†’ ContinuousAt (Function.HasUncurry.uncurry h) { fst := a, snd := HDiv.hDiv (f a) (g a) }\nh2h : Eq (g a) 0 â†’ Filter.Tendsto (Function.HasUncurry.uncurry h) (SProd.sprod (nhds a) Top.top) (nhds (h a 0))\nâŠ¢ ContinuousAt (fun x => h x (HDiv.hDiv (f x) (g x))) a","decl":"/-- The function `f x / g x` is discontinuous when `g x = 0`. However, under appropriate\nconditions, `h x (f x / g x)` is still continuous.  The condition is that if `g a = 0` then `h x y`\nmust tend to `h a 0` when `x` tends to `a`, with no information about `y`. This is represented by\nthe `âŠ¤` filter.  Note: `tendsto_prod_top_iff` characterizes this convergence in uniform spaces.  See\nalso `Filter.prod_top` and `Filter.mem_prod_top`. -/\ntheorem ContinuousAt.comp_div_cases {f g : Î± â†’ Gâ‚€} (h : Î± â†’ Gâ‚€ â†’ Î²) (hf : ContinuousAt f a)\n    (hg : ContinuousAt g a) (hh : g a â‰  0 â†’ ContinuousAt (â†¿h) (a, f a / g a))\n    (h2h : g a = 0 â†’ Tendsto (â†¿h) (ğ“ a Ã—Ë¢ âŠ¤) (ğ“ (h a 0))) :\n    ContinuousAt (fun x => h x (f x / g x)) a := by\n  show ContinuousAt (â†¿h âˆ˜ fun x => (x, f x / g x)) a\n  by_cases hga : g a = 0\n  Â· rw [ContinuousAt]\n    simp_rw [comp_apply, hga, div_zero]\n    exact (h2h hga).comp (continuousAt_id.prod_mk tendsto_top)\n  Â· exact ContinuousAt.comp (hh hga) (continuousAt_id.prod (hf.div hg hga))\n\n"}
{"name":"Continuous.comp_div_cases","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nGâ‚€ : Type u_3\ninstâœâµ : GroupWithZero Gâ‚€\ninstâœâ´ : TopologicalSpace Gâ‚€\ninstâœÂ³ : HasContinuousInvâ‚€ Gâ‚€\ninstâœÂ² : ContinuousMul Gâ‚€\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\nf g : Î± â†’ Gâ‚€\nh : Î± â†’ Gâ‚€ â†’ Î²\nhf : Continuous f\nhg : Continuous g\nhh : âˆ€ (a : Î±), Ne (g a) 0 â†’ ContinuousAt (Function.HasUncurry.uncurry h) { fst := a, snd := HDiv.hDiv (f a) (g a) }\nh2h : âˆ€ (a : Î±), Eq (g a) 0 â†’ Filter.Tendsto (Function.HasUncurry.uncurry h) (SProd.sprod (nhds a) Top.top) (nhds (h a 0))\nâŠ¢ Continuous fun x => h x (HDiv.hDiv (f x) (g x))","decl":"/-- `h x (f x / g x)` is continuous under certain conditions, even if the denominator is sometimes\n  `0`. See docstring of `ContinuousAt.comp_div_cases`. -/\ntheorem Continuous.comp_div_cases {f g : Î± â†’ Gâ‚€} (h : Î± â†’ Gâ‚€ â†’ Î²) (hf : Continuous f)\n    (hg : Continuous g) (hh : âˆ€ a, g a â‰  0 â†’ ContinuousAt (â†¿h) (a, f a / g a))\n    (h2h : âˆ€ a, g a = 0 â†’ Tendsto (â†¿h) (ğ“ a Ã—Ë¢ âŠ¤) (ğ“ (h a 0))) :\n    Continuous fun x => h x (f x / g x) :=\n  continuous_iff_continuousAt.mpr fun a =>\n    hf.continuousAt.comp_div_cases _ hg.continuousAt (hh a) (h2h a)\n\n"}
{"name":"Homeomorph.coe_mulLeftâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : GroupWithZero Î±\ninstâœ : ContinuousMul Î±\nc : Î±\nhc : Ne c 0\nâŠ¢ Eq â‡‘(Homeomorph.mulLeftâ‚€ c hc) fun x => HMul.hMul c x","decl":"@[simp]\ntheorem coe_mulLeftâ‚€ (c : Î±) (hc : c â‰  0) : â‡‘(Homeomorph.mulLeftâ‚€ c hc) = (c * Â·) :=\n  rfl\n\n"}
{"name":"Homeomorph.mulLeftâ‚€_symm_apply","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : GroupWithZero Î±\ninstâœ : ContinuousMul Î±\nc : Î±\nhc : Ne c 0\nâŠ¢ Eq â‡‘(Homeomorph.mulLeftâ‚€ c hc).symm fun x => HMul.hMul (Inv.inv c) x","decl":"@[simp]\ntheorem mulLeftâ‚€_symm_apply (c : Î±) (hc : c â‰  0) :\n    ((Homeomorph.mulLeftâ‚€ c hc).symm : Î± â†’ Î±) = (câ»Â¹ * Â·) :=\n  rfl\n\n"}
{"name":"Homeomorph.coe_mulRightâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : GroupWithZero Î±\ninstâœ : ContinuousMul Î±\nc : Î±\nhc : Ne c 0\nâŠ¢ Eq â‡‘(Homeomorph.mulRightâ‚€ c hc) fun x => HMul.hMul x c","decl":"@[simp]\ntheorem coe_mulRightâ‚€ (c : Î±) (hc : c â‰  0) : â‡‘(Homeomorph.mulRightâ‚€ c hc) = (Â· * c) :=\n  rfl\n\n"}
{"name":"Homeomorph.mulRightâ‚€_symm_apply","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : GroupWithZero Î±\ninstâœ : ContinuousMul Î±\nc : Î±\nhc : Ne c 0\nâŠ¢ Eq â‡‘(Homeomorph.mulRightâ‚€ c hc).symm fun x => HMul.hMul x (Inv.inv c)","decl":"@[simp]\ntheorem mulRightâ‚€_symm_apply (c : Î±) (hc : c â‰  0) :\n    ((Homeomorph.mulRightâ‚€ c hc).symm : Î± â†’ Î±) = (Â· * câ»Â¹) :=\n  rfl\n\n"}
{"name":"map_mul_left_nhdsâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Gâ‚€ : Type u_3\ninstâœÂ² : TopologicalSpace Gâ‚€\ninstâœÂ¹ : GroupWithZero Gâ‚€\ninstâœ : ContinuousMul Gâ‚€\na : Gâ‚€\nha : Ne a 0\nb : Gâ‚€\nâŠ¢ Eq (Filter.map (fun x => HMul.hMul a x) (nhds b)) (nhds (HMul.hMul a b))","decl":"theorem map_mul_left_nhdsâ‚€ (ha : a â‰  0) (b : Gâ‚€) : map (a * Â·) (ğ“ b) = ğ“ (a * b) :=\n  (Homeomorph.mulLeftâ‚€ a ha).map_nhds_eq b\n\n"}
{"name":"map_mul_left_nhds_oneâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Gâ‚€ : Type u_3\ninstâœÂ² : TopologicalSpace Gâ‚€\ninstâœÂ¹ : GroupWithZero Gâ‚€\ninstâœ : ContinuousMul Gâ‚€\na : Gâ‚€\nha : Ne a 0\nâŠ¢ Eq (Filter.map (fun x => HMul.hMul a x) (nhds 1)) (nhds a)","decl":"theorem map_mul_left_nhds_oneâ‚€ (ha : a â‰  0) : map (a * Â·) (ğ“ 1) = ğ“ (a) := by\n  rw [map_mul_left_nhdsâ‚€ ha, mul_one]\n\n"}
{"name":"map_mul_right_nhdsâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Gâ‚€ : Type u_3\ninstâœÂ² : TopologicalSpace Gâ‚€\ninstâœÂ¹ : GroupWithZero Gâ‚€\ninstâœ : ContinuousMul Gâ‚€\na : Gâ‚€\nha : Ne a 0\nb : Gâ‚€\nâŠ¢ Eq (Filter.map (fun x => HMul.hMul x a) (nhds b)) (nhds (HMul.hMul b a))","decl":"theorem map_mul_right_nhdsâ‚€ (ha : a â‰  0) (b : Gâ‚€) : map (Â· * a) (ğ“ b) = ğ“ (b * a) :=\n  (Homeomorph.mulRightâ‚€ a ha).map_nhds_eq b\n\n"}
{"name":"map_mul_right_nhds_oneâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Gâ‚€ : Type u_3\ninstâœÂ² : TopologicalSpace Gâ‚€\ninstâœÂ¹ : GroupWithZero Gâ‚€\ninstâœ : ContinuousMul Gâ‚€\na : Gâ‚€\nha : Ne a 0\nâŠ¢ Eq (Filter.map (fun x => HMul.hMul x a) (nhds 1)) (nhds a)","decl":"theorem map_mul_right_nhds_oneâ‚€ (ha : a â‰  0) : map (Â· * a) (ğ“ 1) = ğ“ (a) := by\n  rw [map_mul_right_nhdsâ‚€ ha, one_mul]\n\n"}
{"name":"nhds_translation_mul_invâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Gâ‚€ : Type u_3\ninstâœÂ² : TopologicalSpace Gâ‚€\ninstâœÂ¹ : GroupWithZero Gâ‚€\ninstâœ : ContinuousMul Gâ‚€\na : Gâ‚€\nha : Ne a 0\nâŠ¢ Eq (Filter.comap (fun x => HMul.hMul x (Inv.inv a)) (nhds 1)) (nhds a)","decl":"theorem nhds_translation_mul_invâ‚€ (ha : a â‰  0) : comap (Â· * aâ»Â¹) (ğ“ 1) = ğ“ a :=\n  ((Homeomorph.mulRightâ‚€ a ha).symm.comap_nhds_eq 1).trans <| by simp\n\n"}
{"name":"HasContinuousInvâ‚€.of_nhds_one","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Gâ‚€ : Type u_3\ninstâœÂ² : TopologicalSpace Gâ‚€\ninstâœÂ¹ : GroupWithZero Gâ‚€\ninstâœ : ContinuousMul Gâ‚€\nh : Filter.Tendsto Inv.inv (nhds 1) (nhds 1)\nâŠ¢ HasContinuousInvâ‚€ Gâ‚€","decl":"/-- If a group with zero has continuous multiplication and `fun x â†¦ xâ»Â¹` is continuous at one,\nthen it is continuous at any unit. -/\ntheorem HasContinuousInvâ‚€.of_nhds_one (h : Tendsto Inv.inv (ğ“ (1 : Gâ‚€)) (ğ“ 1)) :\n    HasContinuousInvâ‚€ Gâ‚€ where\n  continuousAt_invâ‚€ x hx := by\n    have hx' := inv_ne_zero hx\n    rw [ContinuousAt, â† map_mul_left_nhds_oneâ‚€ hx, â† nhds_translation_mul_invâ‚€ hx',\n      tendsto_map'_iff, tendsto_comap_iff]\n    simpa only [Function.comp_def, mul_inv_rev, mul_inv_cancel_rightâ‚€ hx']\n\n"}
{"name":"continuousAt_zpowâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Gâ‚€ : Type u_3\ninstâœÂ³ : GroupWithZero Gâ‚€\ninstâœÂ² : TopologicalSpace Gâ‚€\ninstâœÂ¹ : HasContinuousInvâ‚€ Gâ‚€\ninstâœ : ContinuousMul Gâ‚€\nx : Gâ‚€\nm : Int\nh : Or (Ne x 0) (LE.le 0 m)\nâŠ¢ ContinuousAt (fun x => HPow.hPow x m) x","decl":"theorem continuousAt_zpowâ‚€ (x : Gâ‚€) (m : â„¤) (h : x â‰  0 âˆ¨ 0 â‰¤ m) :\n    ContinuousAt (fun x => x ^ m) x := by\n  cases' m with m m\n  Â· simpa only [Int.ofNat_eq_coe, zpow_natCast] using continuousAt_pow x m\n  Â· simp only [zpow_negSucc]\n    have hx : x â‰  0 := h.resolve_right (Int.negSucc_lt_zero m).not_le\n    exact (continuousAt_pow x (m + 1)).invâ‚€ (pow_ne_zero _ hx)\n\n"}
{"name":"continuousOn_zpowâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Gâ‚€ : Type u_3\ninstâœÂ³ : GroupWithZero Gâ‚€\ninstâœÂ² : TopologicalSpace Gâ‚€\ninstâœÂ¹ : HasContinuousInvâ‚€ Gâ‚€\ninstâœ : ContinuousMul Gâ‚€\nm : Int\nâŠ¢ ContinuousOn (fun x => HPow.hPow x m) (HasCompl.compl (Singleton.singleton 0))","decl":"theorem continuousOn_zpowâ‚€ (m : â„¤) : ContinuousOn (fun x : Gâ‚€ => x ^ m) {0}á¶œ := fun _x hx =>\n  (continuousAt_zpowâ‚€ _ _ (Or.inl hx)).continuousWithinAt\n\n"}
{"name":"Filter.Tendsto.zpowâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Î± : Type u_1\nGâ‚€ : Type u_3\ninstâœÂ³ : GroupWithZero Gâ‚€\ninstâœÂ² : TopologicalSpace Gâ‚€\ninstâœÂ¹ : HasContinuousInvâ‚€ Gâ‚€\ninstâœ : ContinuousMul Gâ‚€\nf : Î± â†’ Gâ‚€\nl : Filter Î±\na : Gâ‚€\nhf : Filter.Tendsto f l (nhds a)\nm : Int\nh : Or (Ne a 0) (LE.le 0 m)\nâŠ¢ Filter.Tendsto (fun x => HPow.hPow (f x) m) l (nhds (HPow.hPow a m))","decl":"theorem Filter.Tendsto.zpowâ‚€ {f : Î± â†’ Gâ‚€} {l : Filter Î±} {a : Gâ‚€} (hf : Tendsto f l (ğ“ a)) (m : â„¤)\n    (h : a â‰  0 âˆ¨ 0 â‰¤ m) : Tendsto (fun x => f x ^ m) l (ğ“ (a ^ m)) :=\n  (continuousAt_zpowâ‚€ _ m h).tendsto.comp hf\n\n"}
{"name":"ContinuousAt.zpowâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Gâ‚€ : Type u_3\ninstâœâ´ : GroupWithZero Gâ‚€\ninstâœÂ³ : TopologicalSpace Gâ‚€\ninstâœÂ² : HasContinuousInvâ‚€ Gâ‚€\ninstâœÂ¹ : ContinuousMul Gâ‚€\nX : Type u_4\ninstâœ : TopologicalSpace X\na : X\nf : X â†’ Gâ‚€\nhf : ContinuousAt f a\nm : Int\nh : Or (Ne (f a) 0) (LE.le 0 m)\nâŠ¢ ContinuousAt (fun x => HPow.hPow (f x) m) a","decl":"@[fun_prop]\nnonrec theorem ContinuousAt.zpowâ‚€ (hf : ContinuousAt f a) (m : â„¤) (h : f a â‰  0 âˆ¨ 0 â‰¤ m) :\n    ContinuousAt (fun x => f x ^ m) a :=\n  hf.zpowâ‚€ m h\n\n"}
{"name":"ContinuousWithinAt.zpowâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Gâ‚€ : Type u_3\ninstâœâ´ : GroupWithZero Gâ‚€\ninstâœÂ³ : TopologicalSpace Gâ‚€\ninstâœÂ² : HasContinuousInvâ‚€ Gâ‚€\ninstâœÂ¹ : ContinuousMul Gâ‚€\nX : Type u_4\ninstâœ : TopologicalSpace X\na : X\ns : Set X\nf : X â†’ Gâ‚€\nhf : ContinuousWithinAt f s a\nm : Int\nh : Or (Ne (f a) 0) (LE.le 0 m)\nâŠ¢ ContinuousWithinAt (fun x => HPow.hPow (f x) m) s a","decl":"nonrec theorem ContinuousWithinAt.zpowâ‚€ (hf : ContinuousWithinAt f s a) (m : â„¤)\n    (h : f a â‰  0 âˆ¨ 0 â‰¤ m) : ContinuousWithinAt (fun x => f x ^ m) s a :=\n  hf.zpowâ‚€ m h\n\n"}
{"name":"ContinuousOn.zpowâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Gâ‚€ : Type u_3\ninstâœâ´ : GroupWithZero Gâ‚€\ninstâœÂ³ : TopologicalSpace Gâ‚€\ninstâœÂ² : HasContinuousInvâ‚€ Gâ‚€\ninstâœÂ¹ : ContinuousMul Gâ‚€\nX : Type u_4\ninstâœ : TopologicalSpace X\ns : Set X\nf : X â†’ Gâ‚€\nhf : ContinuousOn f s\nm : Int\nh : âˆ€ (a : X), Membership.mem s a â†’ Or (Ne (f a) 0) (LE.le 0 m)\nâŠ¢ ContinuousOn (fun x => HPow.hPow (f x) m) s","decl":"@[fun_prop]\ntheorem ContinuousOn.zpowâ‚€ (hf : ContinuousOn f s) (m : â„¤) (h : âˆ€ a âˆˆ s, f a â‰  0 âˆ¨ 0 â‰¤ m) :\n    ContinuousOn (fun x => f x ^ m) s := fun a ha => (hf a ha).zpowâ‚€ m (h a ha)\n\n"}
{"name":"Continuous.zpowâ‚€","module":"Mathlib.Topology.Algebra.GroupWithZero","initialProofState":"Gâ‚€ : Type u_3\ninstâœâ´ : GroupWithZero Gâ‚€\ninstâœÂ³ : TopologicalSpace Gâ‚€\ninstâœÂ² : HasContinuousInvâ‚€ Gâ‚€\ninstâœÂ¹ : ContinuousMul Gâ‚€\nX : Type u_4\ninstâœ : TopologicalSpace X\nf : X â†’ Gâ‚€\nhf : Continuous f\nm : Int\nh0 : âˆ€ (a : X), Or (Ne (f a) 0) (LE.le 0 m)\nâŠ¢ Continuous fun x => HPow.hPow (f x) m","decl":"@[continuity, fun_prop]\ntheorem Continuous.zpowâ‚€ (hf : Continuous f) (m : â„¤) (h0 : âˆ€ a, f a â‰  0 âˆ¨ 0 â‰¤ m) :\n    Continuous fun x => f x ^ m :=\n  continuous_iff_continuousAt.2 fun x => (hf.tendsto x).zpowâ‚€ m (h0 x)\n\n"}
