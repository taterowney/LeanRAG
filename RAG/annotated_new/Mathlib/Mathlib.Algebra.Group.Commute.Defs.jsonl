{"name":"addCommute_iff_eq","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : Add S\na b : S\n⊢ Iff (AddCommute a b) (Eq (HAdd.hAdd a b) (HAdd.hAdd b a))","decl":"/--\nTwo elements `a` and `b` commute if `a * b = b * a`.\n-/\n@[to_additive]\ntheorem commute_iff_eq [Mul S] (a b : S) : Commute a b ↔ a * b = b * a := Iff.rfl\n\n"}
{"name":"commute_iff_eq","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : Mul S\na b : S\n⊢ Iff (Commute a b) (Eq (HMul.hMul a b) (HMul.hMul b a))","decl":"/--\nTwo elements `a` and `b` commute if `a * b = b * a`.\n-/\n@[to_additive]\ntheorem commute_iff_eq [Mul S] (a b : S) : Commute a b ↔ a * b = b * a := Iff.rfl\n\n"}
{"name":"AddCommute.eq","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : Add S\na b : S\nh : AddCommute a b\n⊢ Eq (HAdd.hAdd a b) (HAdd.hAdd b a)","decl":"/-- Equality behind `Commute a b`; useful for rewriting. -/\n@[to_additive \"Equality behind `AddCommute a b`; useful for rewriting.\"]\nprotected theorem eq {a b : S} (h : Commute a b) : a * b = b * a :=\n  h\n\n"}
{"name":"Commute.eq","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : Mul S\na b : S\nh : Commute a b\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"/-- Equality behind `Commute a b`; useful for rewriting. -/\n@[to_additive \"Equality behind `AddCommute a b`; useful for rewriting.\"]\nprotected theorem eq {a b : S} (h : Commute a b) : a * b = b * a :=\n  h\n\n"}
{"name":"Commute.refl","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : Mul S\na : S\n⊢ Commute a a","decl":"/-- Any element commutes with itself. -/\n@[to_additive (attr := refl, simp) \"Any element commutes with itself.\"]\nprotected theorem refl (a : S) : Commute a a :=\n  Eq.refl (a * a)\n\n"}
{"name":"AddCommute.refl","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : Add S\na : S\n⊢ AddCommute a a","decl":"/-- Any element commutes with itself. -/\n@[to_additive (attr := refl, simp) \"Any element commutes with itself.\"]\nprotected theorem refl (a : S) : Commute a a :=\n  Eq.refl (a * a)\n\n"}
{"name":"AddCommute.symm","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : Add S\na b : S\nh : AddCommute a b\n⊢ AddCommute b a","decl":"/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\n@[to_additive (attr := symm) \"If `a` commutes with `b`, then `b` commutes with `a`.\"]\nprotected theorem symm {a b : S} (h : Commute a b) : Commute b a :=\n  Eq.symm h\n\n"}
{"name":"Commute.symm","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : Mul S\na b : S\nh : Commute a b\n⊢ Commute b a","decl":"/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\n@[to_additive (attr := symm) \"If `a` commutes with `b`, then `b` commutes with `a`.\"]\nprotected theorem symm {a b : S} (h : Commute a b) : Commute b a :=\n  Eq.symm h\n\n"}
{"name":"Commute.semiconjBy","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : Mul S\na b : S\nh : Commute a b\n⊢ SemiconjBy a b b","decl":"@[to_additive]\nprotected theorem semiconjBy {a b : S} (h : Commute a b) : SemiconjBy a b b :=\n  h\n\n"}
{"name":"AddCommute.addSemiconjBy","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : Add S\na b : S\nh : AddCommute a b\n⊢ AddSemiconjBy a b b","decl":"@[to_additive]\nprotected theorem semiconjBy {a b : S} (h : Commute a b) : SemiconjBy a b b :=\n  h\n\n"}
{"name":"Commute.symm_iff","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : Mul S\na b : S\n⊢ Iff (Commute a b) (Commute b a)","decl":"@[to_additive]\nprotected theorem symm_iff {a b : S} : Commute a b ↔ Commute b a :=\n  ⟨Commute.symm, Commute.symm⟩\n\n"}
{"name":"AddCommute.symm_iff","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : Add S\na b : S\n⊢ Iff (AddCommute a b) (AddCommute b a)","decl":"@[to_additive]\nprotected theorem symm_iff {a b : S} : Commute a b ↔ Commute b a :=\n  ⟨Commute.symm, Commute.symm⟩\n\n"}
{"name":"Commute.instIsRefl","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : Mul S\n⊢ IsRefl S Commute","decl":"@[to_additive]\ninstance : IsRefl S Commute :=\n  ⟨Commute.refl⟩\n\n-- This instance is useful for `Finset.noncommProd`\n"}
{"name":"AddCommute.instIsRefl","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : Add S\n⊢ IsRefl S AddCommute","decl":"@[to_additive]\ninstance : IsRefl S Commute :=\n  ⟨Commute.refl⟩\n\n-- This instance is useful for `Finset.noncommProd`\n"}
{"name":"Commute.on_isRefl","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"G : Type u_1\nS : Type u_3\ninst✝ : Mul S\nf : G → S\n⊢ IsRefl G fun a b => Commute (f a) (f b)","decl":"@[to_additive]\ninstance on_isRefl {f : G → S} : IsRefl G fun a b => Commute (f a) (f b) :=\n  ⟨fun _ => Commute.refl _⟩\n\n"}
{"name":"AddCommute.on_isRefl","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"G : Type u_1\nS : Type u_3\ninst✝ : Add S\nf : G → S\n⊢ IsRefl G fun a b => AddCommute (f a) (f b)","decl":"@[to_additive]\ninstance on_isRefl {f : G → S} : IsRefl G fun a b => Commute (f a) (f b) :=\n  ⟨fun _ => Commute.refl _⟩\n\n"}
{"name":"Commute.mul_right","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : Semigroup S\na b c : S\nhab : Commute a b\nhac : Commute a c\n⊢ Commute a (HMul.hMul b c)","decl":"/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\n@[to_additive (attr := simp)\n\"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"]\ntheorem mul_right (hab : Commute a b) (hac : Commute a c) : Commute a (b * c) :=\n  SemiconjBy.mul_right hab hac\n-- I think `ₓ` is necessary because of the `mul` vs `HMul` distinction\n\n"}
{"name":"AddCommute.add_right","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : AddSemigroup S\na b c : S\nhab : AddCommute a b\nhac : AddCommute a c\n⊢ AddCommute a (HAdd.hAdd b c)","decl":"/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\n@[to_additive (attr := simp)\n\"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"]\ntheorem mul_right (hab : Commute a b) (hac : Commute a c) : Commute a (b * c) :=\n  SemiconjBy.mul_right hab hac\n-- I think `ₓ` is necessary because of the `mul` vs `HMul` distinction\n\n"}
{"name":"AddCommute.add_left","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : AddSemigroup S\na b c : S\nhac : AddCommute a c\nhbc : AddCommute b c\n⊢ AddCommute (HAdd.hAdd a b) c","decl":"/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\n@[to_additive (attr := simp)\n\"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"]\ntheorem mul_left (hac : Commute a c) (hbc : Commute b c) : Commute (a * b) c :=\n  SemiconjBy.mul_left hac hbc\n-- I think `ₓ` is necessary because of the `mul` vs `HMul` distinction\n\n"}
{"name":"Commute.mul_left","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : Semigroup S\na b c : S\nhac : Commute a c\nhbc : Commute b c\n⊢ Commute (HMul.hMul a b) c","decl":"/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\n@[to_additive (attr := simp)\n\"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"]\ntheorem mul_left (hac : Commute a c) (hbc : Commute b c) : Commute (a * b) c :=\n  SemiconjBy.mul_left hac hbc\n-- I think `ₓ` is necessary because of the `mul` vs `HMul` distinction\n\n"}
{"name":"AddCommute.right_comm","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : AddSemigroup S\nb c : S\nh : AddCommute b c\na : S\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a b) c) (HAdd.hAdd (HAdd.hAdd a c) b)","decl":"@[to_additive]\nprotected theorem right_comm (h : Commute b c) (a : S) : a * b * c = a * c * b := by\n  simp only [mul_assoc, h.eq]\n-- I think `ₓ` is necessary because of the `mul` vs `HMul` distinction\n\n"}
{"name":"Commute.right_comm","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : Semigroup S\nb c : S\nh : Commute b c\na : S\n⊢ Eq (HMul.hMul (HMul.hMul a b) c) (HMul.hMul (HMul.hMul a c) b)","decl":"@[to_additive]\nprotected theorem right_comm (h : Commute b c) (a : S) : a * b * c = a * c * b := by\n  simp only [mul_assoc, h.eq]\n-- I think `ₓ` is necessary because of the `mul` vs `HMul` distinction\n\n"}
{"name":"Commute.left_comm","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : Semigroup S\na b : S\nh : Commute a b\nc : S\n⊢ Eq (HMul.hMul a (HMul.hMul b c)) (HMul.hMul b (HMul.hMul a c))","decl":"@[to_additive]\nprotected theorem left_comm (h : Commute a b) (c) : a * (b * c) = b * (a * c) := by\n  simp only [← mul_assoc, h.eq]\n-- I think `ₓ` is necessary because of the `mul` vs `HMul` distinction\n\n"}
{"name":"AddCommute.left_comm","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : AddSemigroup S\na b : S\nh : AddCommute a b\nc : S\n⊢ Eq (HAdd.hAdd a (HAdd.hAdd b c)) (HAdd.hAdd b (HAdd.hAdd a c))","decl":"@[to_additive]\nprotected theorem left_comm (h : Commute a b) (c) : a * (b * c) = b * (a * c) := by\n  simp only [← mul_assoc, h.eq]\n-- I think `ₓ` is necessary because of the `mul` vs `HMul` distinction\n\n"}
{"name":"Commute.mul_mul_mul_comm","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : Semigroup S\nb c : S\nhbc : Commute b c\na d : S\n⊢ Eq (HMul.hMul (HMul.hMul a b) (HMul.hMul c d)) (HMul.hMul (HMul.hMul a c) (HMul.hMul b d))","decl":"@[to_additive]\nprotected theorem mul_mul_mul_comm (hbc : Commute b c) (a d : S) :\n    a * b * (c * d) = a * c * (b * d) := by simp only [hbc.left_comm, mul_assoc]\n\n"}
{"name":"AddCommute.add_add_add_comm","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : AddSemigroup S\nb c : S\nhbc : AddCommute b c\na d : S\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a b) (HAdd.hAdd c d)) (HAdd.hAdd (HAdd.hAdd a c) (HAdd.hAdd b d))","decl":"@[to_additive]\nprotected theorem mul_mul_mul_comm (hbc : Commute b c) (a d : S) :\n    a * b * (c * d) = a * c * (b * d) := by simp only [hbc.left_comm, mul_assoc]\n\n"}
{"name":"Commute.all","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : CommMagma S\na b : S\n⊢ Commute a b","decl":"@[to_additive]\nprotected theorem all [CommMagma S] (a b : S) : Commute a b :=\n  mul_comm a b\n\n"}
{"name":"AddCommute.all","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"S : Type u_3\ninst✝ : AddCommMagma S\na b : S\n⊢ AddCommute a b","decl":"@[to_additive]\nprotected theorem all [CommMagma S] (a b : S) : Commute a b :=\n  mul_comm a b\n\n"}
{"name":"Commute.one_right","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\na : M\n⊢ Commute a 1","decl":"@[to_additive (attr := simp)]\ntheorem one_right (a : M) : Commute a 1 :=\n  SemiconjBy.one_right a\n-- I think `ₓ` is necessary because `One.toOfNat1` appears in the Lean 4 version\n\n"}
{"name":"AddCommute.zero_right","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\na : M\n⊢ AddCommute a 0","decl":"@[to_additive (attr := simp)]\ntheorem one_right (a : M) : Commute a 1 :=\n  SemiconjBy.one_right a\n-- I think `ₓ` is necessary because `One.toOfNat1` appears in the Lean 4 version\n\n"}
{"name":"AddCommute.zero_left","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\na : M\n⊢ AddCommute 0 a","decl":"@[to_additive (attr := simp)]\ntheorem one_left (a : M) : Commute 1 a :=\n  SemiconjBy.one_left a\n-- I think `ₓ` is necessary because `One.toOfNat1` appears in the Lean 4 version\n\n"}
{"name":"Commute.one_left","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\na : M\n⊢ Commute 1 a","decl":"@[to_additive (attr := simp)]\ntheorem one_left (a : M) : Commute 1 a :=\n  SemiconjBy.one_left a\n-- I think `ₓ` is necessary because `One.toOfNat1` appears in the Lean 4 version\n\n"}
{"name":"Commute.pow_right","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na b : M\nh : Commute a b\nn : Nat\n⊢ Commute a (HPow.hPow b n)","decl":"@[to_additive (attr := simp)]\ntheorem pow_right (h : Commute a b) (n : ℕ) : Commute a (b ^ n) :=\n  SemiconjBy.pow_right h n\n-- `MulOneClass.toHasMul` vs. `MulOneClass.toMul`\n\n"}
{"name":"AddCommute.nsmul_right","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na b : M\nh : AddCommute a b\nn : Nat\n⊢ AddCommute a (HSMul.hSMul n b)","decl":"@[to_additive (attr := simp)]\ntheorem pow_right (h : Commute a b) (n : ℕ) : Commute a (b ^ n) :=\n  SemiconjBy.pow_right h n\n-- `MulOneClass.toHasMul` vs. `MulOneClass.toMul`\n\n"}
{"name":"Commute.pow_left","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na b : M\nh : Commute a b\nn : Nat\n⊢ Commute (HPow.hPow a n) b","decl":"@[to_additive (attr := simp)]\ntheorem pow_left (h : Commute a b) (n : ℕ) : Commute (a ^ n) b :=\n  (h.symm.pow_right n).symm\n-- `MulOneClass.toHasMul` vs. `MulOneClass.toMul`\n\n-- todo: should nat power be called `nsmul` here?\n"}
{"name":"AddCommute.nsmul_left","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na b : M\nh : AddCommute a b\nn : Nat\n⊢ AddCommute (HSMul.hSMul n a) b","decl":"@[to_additive (attr := simp)]\ntheorem pow_left (h : Commute a b) (n : ℕ) : Commute (a ^ n) b :=\n  (h.symm.pow_right n).symm\n-- `MulOneClass.toHasMul` vs. `MulOneClass.toMul`\n\n-- todo: should nat power be called `nsmul` here?\n"}
{"name":"Commute.pow_pow","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na b : M\nh : Commute a b\nm n : Nat\n⊢ Commute (HPow.hPow a m) (HPow.hPow b n)","decl":"@[to_additive (attr := simp)]\ntheorem pow_pow (h : Commute a b) (m n : ℕ) : Commute (a ^ m) (b ^ n) :=\n  (h.pow_left m).pow_right n\n-- `MulOneClass.toHasMul` vs. `MulOneClass.toMul`\n\n"}
{"name":"AddCommute.nsmul_nsmul","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na b : M\nh : AddCommute a b\nm n : Nat\n⊢ AddCommute (HSMul.hSMul m a) (HSMul.hSMul n b)","decl":"@[to_additive (attr := simp)]\ntheorem pow_pow (h : Commute a b) (m n : ℕ) : Commute (a ^ m) (b ^ n) :=\n  (h.pow_left m).pow_right n\n-- `MulOneClass.toHasMul` vs. `MulOneClass.toMul`\n\n"}
{"name":"Commute.self_pow","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na : M\nn : Nat\n⊢ Commute a (HPow.hPow a n)","decl":"@[to_additive]\ntheorem self_pow (a : M) (n : ℕ) : Commute a (a ^ n) :=\n  (Commute.refl a).pow_right n\n-- `MulOneClass.toHasMul` vs. `MulOneClass.toMul`\n\n"}
{"name":"AddCommute.self_nsmul","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na : M\nn : Nat\n⊢ AddCommute a (HSMul.hSMul n a)","decl":"@[to_additive]\ntheorem self_pow (a : M) (n : ℕ) : Commute a (a ^ n) :=\n  (Commute.refl a).pow_right n\n-- `MulOneClass.toHasMul` vs. `MulOneClass.toMul`\n\n"}
{"name":"Commute.pow_self","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na : M\nn : Nat\n⊢ Commute (HPow.hPow a n) a","decl":"@[to_additive]\ntheorem pow_self (a : M) (n : ℕ) : Commute (a ^ n) a :=\n  (Commute.refl a).pow_left n\n-- `MulOneClass.toHasMul` vs. `MulOneClass.toMul`\n\n"}
{"name":"AddCommute.nsmul_self","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na : M\nn : Nat\n⊢ AddCommute (HSMul.hSMul n a) a","decl":"@[to_additive]\ntheorem pow_self (a : M) (n : ℕ) : Commute (a ^ n) a :=\n  (Commute.refl a).pow_left n\n-- `MulOneClass.toHasMul` vs. `MulOneClass.toMul`\n\n"}
{"name":"Commute.pow_pow_self","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na : M\nm n : Nat\n⊢ Commute (HPow.hPow a m) (HPow.hPow a n)","decl":"@[to_additive]\ntheorem pow_pow_self (a : M) (m n : ℕ) : Commute (a ^ m) (a ^ n) :=\n  (Commute.refl a).pow_pow m n\n-- `MulOneClass.toHasMul` vs. `MulOneClass.toMul`\n\n"}
{"name":"AddCommute.nsmul_nsmul_self","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na : M\nm n : Nat\n⊢ AddCommute (HSMul.hSMul m a) (HSMul.hSMul n a)","decl":"@[to_additive]\ntheorem pow_pow_self (a : M) (m n : ℕ) : Commute (a ^ m) (a ^ n) :=\n  (Commute.refl a).pow_pow m n\n-- `MulOneClass.toHasMul` vs. `MulOneClass.toMul`\n\n"}
{"name":"Commute.mul_pow","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na b : M\nh : Commute a b\nn : Nat\n⊢ Eq (HPow.hPow (HMul.hMul a b) n) (HMul.hMul (HPow.hPow a n) (HPow.hPow b n))","decl":"@[to_additive] lemma mul_pow (h : Commute a b) : ∀ n, (a * b) ^ n = a ^ n * b ^ n\n  | 0 => by rw [pow_zero, pow_zero, pow_zero, one_mul]\n  | n + 1 => by simp only [pow_succ', h.mul_pow n, ← mul_assoc, (h.pow_left n).right_comm]\n\n"}
{"name":"AddCommute.add_nsmul","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na b : M\nh : AddCommute a b\nn : Nat\n⊢ Eq (HSMul.hSMul n (HAdd.hAdd a b)) (HAdd.hAdd (HSMul.hSMul n a) (HSMul.hSMul n b))","decl":"@[to_additive] lemma mul_pow (h : Commute a b) : ∀ n, (a * b) ^ n = a ^ n * b ^ n\n  | 0 => by rw [pow_zero, pow_zero, pow_zero, one_mul]\n  | n + 1 => by simp only [pow_succ', h.mul_pow n, ← mul_assoc, (h.pow_left n).right_comm]\n\n"}
{"name":"Commute.mul_inv","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"G : Type u_1\ninst✝ : DivisionMonoid G\na b : G\nhab : Commute a b\n⊢ Eq (Inv.inv (HMul.hMul a b)) (HMul.hMul (Inv.inv a) (Inv.inv b))","decl":"@[to_additive]\nprotected theorem mul_inv (hab : Commute a b) : (a * b)⁻¹ = a⁻¹ * b⁻¹ := by rw [hab.eq, mul_inv_rev]\n\n"}
{"name":"AddCommute.add_neg","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"G : Type u_1\ninst✝ : SubtractionMonoid G\na b : G\nhab : AddCommute a b\n⊢ Eq (Neg.neg (HAdd.hAdd a b)) (HAdd.hAdd (Neg.neg a) (Neg.neg b))","decl":"@[to_additive]\nprotected theorem mul_inv (hab : Commute a b) : (a * b)⁻¹ = a⁻¹ * b⁻¹ := by rw [hab.eq, mul_inv_rev]\n\n"}
{"name":"Commute.inv","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"G : Type u_1\ninst✝ : DivisionMonoid G\na b : G\nhab : Commute a b\n⊢ Eq (Inv.inv (HMul.hMul a b)) (HMul.hMul (Inv.inv a) (Inv.inv b))","decl":"@[to_additive]\nprotected theorem inv (hab : Commute a b) : (a * b)⁻¹ = a⁻¹ * b⁻¹ := by rw [hab.eq, mul_inv_rev]\n\n"}
{"name":"AddCommute.neg","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"G : Type u_1\ninst✝ : SubtractionMonoid G\na b : G\nhab : AddCommute a b\n⊢ Eq (Neg.neg (HAdd.hAdd a b)) (HAdd.hAdd (Neg.neg a) (Neg.neg b))","decl":"@[to_additive]\nprotected theorem inv (hab : Commute a b) : (a * b)⁻¹ = a⁻¹ * b⁻¹ := by rw [hab.eq, mul_inv_rev]\n\n"}
{"name":"Commute.mul_zpow","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"G : Type u_1\ninst✝ : DivisionMonoid G\na b : G\nh : Commute a b\nn : Int\n⊢ Eq (HPow.hPow (HMul.hMul a b) n) (HMul.hMul (HPow.hPow a n) (HPow.hPow b n))","decl":"@[to_additive AddCommute.zsmul_add]\nprotected lemma mul_zpow (h : Commute a b) : ∀ n : ℤ, (a * b) ^ n = a ^ n * b ^ n\n  | (n : ℕ)    => by simp [zpow_natCast, h.mul_pow n]\n  | .negSucc n => by simp [h.mul_pow, (h.pow_pow _ _).eq, mul_inv_rev]\n\n"}
{"name":"AddCommute.zsmul_add","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"G : Type u_1\ninst✝ : SubtractionMonoid G\na b : G\nh : AddCommute a b\nn : Int\n⊢ Eq (HSMul.hSMul n (HAdd.hAdd a b)) (HAdd.hAdd (HSMul.hSMul n a) (HSMul.hSMul n b))","decl":"@[to_additive AddCommute.zsmul_add]\nprotected lemma mul_zpow (h : Commute a b) : ∀ n : ℤ, (a * b) ^ n = a ^ n * b ^ n\n  | (n : ℕ)    => by simp [zpow_natCast, h.mul_pow n]\n  | .negSucc n => by simp [h.mul_pow, (h.pow_pow _ _).eq, mul_inv_rev]\n\n"}
{"name":"Commute.mul_inv_cancel","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\na b : G\nh : Commute a b\n⊢ Eq (HMul.hMul (HMul.hMul a b) (Inv.inv a)) b","decl":"@[to_additive]\nprotected theorem mul_inv_cancel (h : Commute a b) : a * b * a⁻¹ = b := by\n  rw [h.eq, mul_inv_cancel_right]\n\n"}
{"name":"AddCommute.add_neg_cancel","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na b : G\nh : AddCommute a b\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a b) (Neg.neg a)) b","decl":"@[to_additive]\nprotected theorem mul_inv_cancel (h : Commute a b) : a * b * a⁻¹ = b := by\n  rw [h.eq, mul_inv_cancel_right]\n\n"}
{"name":"AddCommute.add_neg_cancel_assoc","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na b : G\nh : AddCommute a b\n⊢ Eq (HAdd.hAdd a (HAdd.hAdd b (Neg.neg a))) b","decl":"@[to_additive]\ntheorem mul_inv_cancel_assoc (h : Commute a b) : a * (b * a⁻¹) = b := by\n  rw [← mul_assoc, h.mul_inv_cancel]\n\n"}
{"name":"Commute.mul_inv_cancel_assoc","module":"Mathlib.Algebra.Group.Commute.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\na b : G\nh : Commute a b\n⊢ Eq (HMul.hMul a (HMul.hMul b (Inv.inv a))) b","decl":"@[to_additive]\ntheorem mul_inv_cancel_assoc (h : Commute a b) : a * (b * a⁻¹) = b := by\n  rw [← mul_assoc, h.mul_inv_cancel]\n\n"}
