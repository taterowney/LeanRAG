{"name":"CategoryTheory.WellPowered.subobject_small","module":"Mathlib.CategoryTheory.Subobject.WellPowered","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v, u₁} C\ninst✝ : CategoryTheory.LocallySmall.{w, v, u₁} C\nself : CategoryTheory.WellPowered.{w, v, u₁} C\nX : C\n⊢ Small.{w, max u₁ v} (CategoryTheory.Subobject X)","decl":"/--\nA category (with morphisms in `Type v`) is well-powered relative to a universe `w`\nif it is locally small and `Subobject X` is `w`-small for every `X`.\n\nWe show in `wellPowered_of_essentiallySmall_monoOver` and `essentiallySmall_monoOver`\nthat this is the case if and only if `MonoOver X` is `w`-essentially small for every `X`.\n-/\n@[pp_with_univ]\nclass WellPowered [LocallySmall.{w} C] : Prop where\n  subobject_small : ∀ X : C, Small.{w} (Subobject X) := by infer_instance\n\n"}
{"name":"CategoryTheory.small_subobject","module":"Mathlib.CategoryTheory.Subobject.WellPowered","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\ninst✝¹ : CategoryTheory.LocallySmall.{w, v, u₁} C\ninst✝ : CategoryTheory.WellPowered.{w, v, u₁} C\nX : C\n⊢ Small.{w, max u₁ v} (CategoryTheory.Subobject X)","decl":"instance small_subobject [LocallySmall.{w} C] [WellPowered C] (X : C) :\n    Small.{w} (Subobject X) :=\n  WellPowered.subobject_small X\n\n"}
{"name":"CategoryTheory.wellPowered_of_smallCategory","module":"Mathlib.CategoryTheory.Subobject.WellPowered","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.SmallCategory C\n⊢ CategoryTheory.WellPowered.{u₁, u₁, u₁} C","decl":"instance (priority := 100) wellPowered_of_smallCategory (C : Type u₁) [SmallCategory C] :\n    WellPowered.{u₁} C where\n\n"}
{"name":"CategoryTheory.essentiallySmall_monoOver_iff_small_subobject","module":"Mathlib.CategoryTheory.Subobject.WellPowered","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nX : C\n⊢ Iff (CategoryTheory.EssentiallySmall.{w, v, max u₁ v} (CategoryTheory.MonoOver X)) (Small.{w, max u₁ v} (CategoryTheory.Subobject X))","decl":"theorem essentiallySmall_monoOver_iff_small_subobject (X : C) :\n    EssentiallySmall.{w} (MonoOver X) ↔ Small.{w} (Subobject X) :=\n  essentiallySmall_iff_of_thin\n\n"}
{"name":"CategoryTheory.wellPowered_of_essentiallySmall_monoOver","module":"Mathlib.CategoryTheory.Subobject.WellPowered","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v, u₁} C\ninst✝ : CategoryTheory.LocallySmall.{w, v, u₁} C\nh : ∀ (X : C), CategoryTheory.EssentiallySmall.{w, v, max u₁ v} (CategoryTheory.MonoOver X)\n⊢ CategoryTheory.WellPowered.{w, v, u₁} C","decl":"theorem wellPowered_of_essentiallySmall_monoOver [LocallySmall.{w} C]\n    (h : ∀ X : C, EssentiallySmall.{w} (MonoOver X)) :\n    WellPowered.{w} C :=\n  { subobject_small := fun X => (essentiallySmall_monoOver_iff_small_subobject X).mp (h X) }\n\n"}
{"name":"CategoryTheory.essentiallySmall_monoOver","module":"Mathlib.CategoryTheory.Subobject.WellPowered","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\ninst✝¹ : CategoryTheory.LocallySmall.{w, v, u₁} C\ninst✝ : CategoryTheory.WellPowered.{w, v, u₁} C\nX : C\n⊢ CategoryTheory.EssentiallySmall.{w, v, max u₁ v} (CategoryTheory.MonoOver X)","decl":"instance essentiallySmall_monoOver (X : C) : EssentiallySmall.{w} (MonoOver X) :=\n  (essentiallySmall_monoOver_iff_small_subobject X).mpr (WellPowered.subobject_small X)\n\n"}
{"name":"CategoryTheory.wellPowered_of_equiv","module":"Mathlib.CategoryTheory.Subobject.WellPowered","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\ninst✝² : CategoryTheory.LocallySmall.{w, v, u₁} C\ninst✝¹ : CategoryTheory.LocallySmall.{w, v₂, u₂} D\ninst✝ : CategoryTheory.WellPowered.{w, v, u₁} C\n⊢ CategoryTheory.WellPowered.{w, v₂, u₂} D","decl":"theorem wellPowered_of_equiv (e : C ≌ D) [LocallySmall.{w} C] [LocallySmall.{w} D]\n    [WellPowered.{w} C] : WellPowered.{w} D :=\n  wellPowered_of_essentiallySmall_monoOver fun X =>\n    (essentiallySmall_congr (MonoOver.congr X e.symm)).2 <| by infer_instance\n\n"}
{"name":"CategoryTheory.wellPowered_congr","module":"Mathlib.CategoryTheory.Subobject.WellPowered","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\ninst✝¹ : CategoryTheory.LocallySmall.{w, v, u₁} C\ninst✝ : CategoryTheory.LocallySmall.{w, v₂, u₂} D\n⊢ Iff (CategoryTheory.WellPowered.{w, v, u₁} C) (CategoryTheory.WellPowered.{w, v₂, u₂} D)","decl":"/-- Being well-powered is preserved by equivalences. -/\ntheorem wellPowered_congr (e : C ≌ D) [LocallySmall.{w} C] [LocallySmall.{w} D] :\n    WellPowered.{w} C ↔ WellPowered.{w} D :=\n  ⟨fun _ => wellPowered_of_equiv e, fun _ => wellPowered_of_equiv e.symm⟩\n\n"}
{"name":"CategoryTheory.instWellPoweredShrinkHoms","module":"Mathlib.CategoryTheory.Subobject.WellPowered","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\ninst✝¹ : CategoryTheory.LocallySmall.{w, v, u₁} C\ninst✝ : CategoryTheory.WellPowered.{w, v, u₁} C\n⊢ CategoryTheory.WellPowered.{w, w, u₁} (CategoryTheory.ShrinkHoms.{u₁} C)","decl":"instance [LocallySmall.{w} C] [WellPowered.{w} C] :\n    WellPowered.{w, w} (ShrinkHoms C) :=\n  wellPowered_of_equiv.{w} (ShrinkHoms.equivalence.{w} C)\n\n"}
