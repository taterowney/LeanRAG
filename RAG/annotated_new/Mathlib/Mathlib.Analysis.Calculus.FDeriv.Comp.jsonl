{"name":"HasFDerivAtFilter.comp","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nL : Filter E\ng : F â†’ G\ng' : ContinuousLinearMap (RingHom.id ğ•œ) F G\nL' : Filter F\nhg : HasFDerivAtFilter g g' (f x) L'\nhf : HasFDerivAtFilter f f' x L\nhL : Filter.Tendsto f L L'\nâŠ¢ HasFDerivAtFilter (Function.comp g f) (g'.comp f') x L","decl":"theorem HasFDerivAtFilter.comp {g : F â†’ G} {g' : F â†’L[ğ•œ] G} {L' : Filter F}\n    (hg : HasFDerivAtFilter g g' (f x) L') (hf : HasFDerivAtFilter f f' x L) (hL : Tendsto f L L') :\n    HasFDerivAtFilter (g âˆ˜ f) (g'.comp f') x L := by\n  let eqâ‚ := (g'.isBigO_comp _ _).trans_isLittleO hf.isLittleO\n  let eqâ‚‚ := (hg.isLittleO.comp_tendsto hL).trans_isBigO hf.isBigO_sub\n  refine .of_isLittleO <| eqâ‚‚.triangle <| eqâ‚.congr_left fun x' => ?_\n  simp\n\n/- A readable version of the previous theorem, a general form of the chain rule. -/\n"}
{"name":"HasFDerivWithinAt.comp","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\ng : F â†’ G\ng' : ContinuousLinearMap (RingHom.id ğ•œ) F G\nt : Set F\nhg : HasFDerivWithinAt g g' t (f x)\nhf : HasFDerivWithinAt f f' s x\nhst : Set.MapsTo f s t\nâŠ¢ HasFDerivWithinAt (Function.comp g f) (g'.comp f') s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.comp {g : F â†’ G} {g' : F â†’L[ğ•œ] G} {t : Set F}\n    (hg : HasFDerivWithinAt g g' t (f x)) (hf : HasFDerivWithinAt f f' s x) (hst : MapsTo f s t) :\n    HasFDerivWithinAt (g âˆ˜ f) (g'.comp f') s x :=\n  HasFDerivAtFilter.comp x hg hf <| hf.continuousWithinAt.tendsto_nhdsWithin hst\n\n"}
{"name":"HasFDerivAt.comp_hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\ng : F â†’ G\ng' : ContinuousLinearMap (RingHom.id ğ•œ) F G\nhg : HasFDerivAt g g' (f x)\nhf : HasFDerivWithinAt f f' s x\nâŠ¢ HasFDerivWithinAt (Function.comp g f) (g'.comp f') s x","decl":"@[fun_prop]\ntheorem HasFDerivAt.comp_hasFDerivWithinAt {g : F â†’ G} {g' : F â†’L[ğ•œ] G}\n    (hg : HasFDerivAt g g' (f x)) (hf : HasFDerivWithinAt f f' s x) :\n    HasFDerivWithinAt (g âˆ˜ f) (g'.comp f') s x :=\n  hg.comp x hf hf.continuousWithinAt\n\n"}
{"name":"HasFDerivWithinAt.comp_of_tendsto","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\ng : F â†’ G\ng' : ContinuousLinearMap (RingHom.id ğ•œ) F G\nt : Set F\nhg : HasFDerivWithinAt g g' t (f x)\nhf : HasFDerivWithinAt f f' s x\nhst : Filter.Tendsto f (nhdsWithin x s) (nhdsWithin (f x) t)\nâŠ¢ HasFDerivWithinAt (Function.comp g f) (g'.comp f') s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.comp_of_tendsto {g : F â†’ G} {g' : F â†’L[ğ•œ] G} {t : Set F}\n    (hg : HasFDerivWithinAt g g' t (f x)) (hf : HasFDerivWithinAt f f' s x)\n    (hst : Tendsto f (ğ“[s] x) (ğ“[t] f x)) : HasFDerivWithinAt (g âˆ˜ f) (g'.comp f') s x :=\n  HasFDerivAtFilter.comp x hg hf hst\n\n"}
{"name":"HasFDerivWithinAt.comp_of_mem","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\ng : F â†’ G\ng' : ContinuousLinearMap (RingHom.id ğ•œ) F G\nt : Set F\nhg : HasFDerivWithinAt g g' t (f x)\nhf : HasFDerivWithinAt f f' s x\nhst : Filter.Tendsto f (nhdsWithin x s) (nhdsWithin (f x) t)\nâŠ¢ HasFDerivWithinAt (Function.comp g f) (g'.comp f') s x","decl":"@[deprecated (since := \"2024-10-18\")]\nalias HasFDerivWithinAt.comp_of_mem := HasFDerivWithinAt.comp_of_tendsto\n\n"}
{"name":"HasFDerivAt.comp","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ng : F â†’ G\ng' : ContinuousLinearMap (RingHom.id ğ•œ) F G\nhg : HasFDerivAt g g' (f x)\nhf : HasFDerivAt f f' x\nâŠ¢ HasFDerivAt (Function.comp g f) (g'.comp f') x","decl":"/-- The chain rule. -/\n@[fun_prop]\ntheorem HasFDerivAt.comp {g : F â†’ G} {g' : F â†’L[ğ•œ] G} (hg : HasFDerivAt g g' (f x))\n    (hf : HasFDerivAt f f' x) : HasFDerivAt (g âˆ˜ f) (g'.comp f') x :=\n  HasFDerivAtFilter.comp x hg hf hf.continuousAt\n\n"}
{"name":"DifferentiableWithinAt.comp","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nx : E\ns : Set E\ng : F â†’ G\nt : Set F\nhg : DifferentiableWithinAt ğ•œ g t (f x)\nhf : DifferentiableWithinAt ğ•œ f s x\nh : Set.MapsTo f s t\nâŠ¢ DifferentiableWithinAt ğ•œ (Function.comp g f) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.comp {g : F â†’ G} {t : Set F}\n    (hg : DifferentiableWithinAt ğ•œ g t (f x)) (hf : DifferentiableWithinAt ğ•œ f s x)\n    (h : MapsTo f s t) : DifferentiableWithinAt ğ•œ (g âˆ˜ f) s x :=\n  (hg.hasFDerivWithinAt.comp x hf.hasFDerivWithinAt h).differentiableWithinAt\n\n"}
{"name":"DifferentiableWithinAt.comp'","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nx : E\ns : Set E\ng : F â†’ G\nt : Set F\nhg : DifferentiableWithinAt ğ•œ g t (f x)\nhf : DifferentiableWithinAt ğ•œ f s x\nâŠ¢ DifferentiableWithinAt ğ•œ (Function.comp g f) (Inter.inter s (Set.preimage f t)) x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.comp' {g : F â†’ G} {t : Set F}\n    (hg : DifferentiableWithinAt ğ•œ g t (f x)) (hf : DifferentiableWithinAt ğ•œ f s x) :\n    DifferentiableWithinAt ğ•œ (g âˆ˜ f) (s âˆ© f â»Â¹' t) x :=\n  hg.comp x (hf.mono inter_subset_left) inter_subset_right\n\n"}
{"name":"DifferentiableAt.comp","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nx : E\ng : F â†’ G\nhg : DifferentiableAt ğ•œ g (f x)\nhf : DifferentiableAt ğ•œ f x\nâŠ¢ DifferentiableAt ğ•œ (Function.comp g f) x","decl":"@[fun_prop]\ntheorem DifferentiableAt.comp {g : F â†’ G} (hg : DifferentiableAt ğ•œ g (f x))\n    (hf : DifferentiableAt ğ•œ f x) : DifferentiableAt ğ•œ (g âˆ˜ f) x :=\n  (hg.hasFDerivAt.comp x hf.hasFDerivAt).differentiableAt\n\n"}
{"name":"DifferentiableAt.comp_differentiableWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nx : E\ns : Set E\ng : F â†’ G\nhg : DifferentiableAt ğ•œ g (f x)\nhf : DifferentiableWithinAt ğ•œ f s x\nâŠ¢ DifferentiableWithinAt ğ•œ (Function.comp g f) s x","decl":"@[fun_prop]\ntheorem DifferentiableAt.comp_differentiableWithinAt {g : F â†’ G} (hg : DifferentiableAt ğ•œ g (f x))\n    (hf : DifferentiableWithinAt ğ•œ f s x) : DifferentiableWithinAt ğ•œ (g âˆ˜ f) s x :=\n  hg.differentiableWithinAt.comp x hf (mapsTo_univ _ _)\n\n"}
{"name":"fderivWithin_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nx : E\ns : Set E\ng : F â†’ G\nt : Set F\nhg : DifferentiableWithinAt ğ•œ g t (f x)\nhf : DifferentiableWithinAt ğ•œ f s x\nh : Set.MapsTo f s t\nhxs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (fderivWithin ğ•œ (Function.comp g f) s x) ((fderivWithin ğ•œ g t (f x)).comp (fderivWithin ğ•œ f s x))","decl":"theorem fderivWithin_comp {g : F â†’ G} {t : Set F} (hg : DifferentiableWithinAt ğ•œ g t (f x))\n    (hf : DifferentiableWithinAt ğ•œ f s x) (h : MapsTo f s t) (hxs : UniqueDiffWithinAt ğ•œ s x) :\n    fderivWithin ğ•œ (g âˆ˜ f) s x = (fderivWithin ğ•œ g t (f x)).comp (fderivWithin ğ•œ f s x) :=\n  (hg.hasFDerivWithinAt.comp x hf.hasFDerivWithinAt h).fderivWithin hxs\n\n"}
{"name":"fderivWithin.comp","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nx : E\ns : Set E\ng : F â†’ G\nt : Set F\nhg : DifferentiableWithinAt ğ•œ g t (f x)\nhf : DifferentiableWithinAt ğ•œ f s x\nh : Set.MapsTo f s t\nhxs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (fderivWithin ğ•œ (Function.comp g f) s x) ((fderivWithin ğ•œ g t (f x)).comp (fderivWithin ğ•œ f s x))","decl":"@[deprecated (since := \"2024-10-31\")] alias fderivWithin.comp := fderivWithin_comp\n\n"}
{"name":"fderivWithin_comp_of_eq","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nx : E\ns : Set E\ng : F â†’ G\nt : Set F\ny : F\nhg : DifferentiableWithinAt ğ•œ g t y\nhf : DifferentiableWithinAt ğ•œ f s x\nh : Set.MapsTo f s t\nhxs : UniqueDiffWithinAt ğ•œ s x\nhy : Eq (f x) y\nâŠ¢ Eq (fderivWithin ğ•œ (Function.comp g f) s x) ((fderivWithin ğ•œ g t (f x)).comp (fderivWithin ğ•œ f s x))","decl":"theorem fderivWithin_comp_of_eq {g : F â†’ G} {t : Set F} {y : F}\n    (hg : DifferentiableWithinAt ğ•œ g t y) (hf : DifferentiableWithinAt ğ•œ f s x) (h : MapsTo f s t)\n    (hxs : UniqueDiffWithinAt ğ•œ s x) (hy : f x = y) :\n    fderivWithin ğ•œ (g âˆ˜ f) s x = (fderivWithin ğ•œ g t (f x)).comp (fderivWithin ğ•œ f s x) := by\n  subst hy; exact fderivWithin_comp _ hg hf h hxs\n\n"}
{"name":"fderivWithin_comp'","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nx : E\ns : Set E\ng : F â†’ G\nt : Set F\nhg : DifferentiableWithinAt ğ•œ g t (f x)\nhf : DifferentiableWithinAt ğ•œ f s x\nh : Set.MapsTo f s t\nhxs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (fderivWithin ğ•œ (fun y => g (f y)) s x) ((fderivWithin ğ•œ g t (f x)).comp (fderivWithin ğ•œ f s x))","decl":"/-- A variant for the derivative of a composition, written without `âˆ˜`. -/\ntheorem fderivWithin_comp' {g : F â†’ G} {t : Set F} (hg : DifferentiableWithinAt ğ•œ g t (f x))\n    (hf : DifferentiableWithinAt ğ•œ f s x) (h : MapsTo f s t) (hxs : UniqueDiffWithinAt ğ•œ s x) :\n    fderivWithin ğ•œ (fun y â†¦ g (f y)) s x\n      = (fderivWithin ğ•œ g t (f x)).comp (fderivWithin ğ•œ f s x) :=\n  fderivWithin_comp _ hg hf h hxs\n\n"}
{"name":"fderivWithin_comp_of_eq'","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nx : E\ns : Set E\ng : F â†’ G\nt : Set F\ny : F\nhg : DifferentiableWithinAt ğ•œ g t y\nhf : DifferentiableWithinAt ğ•œ f s x\nh : Set.MapsTo f s t\nhxs : UniqueDiffWithinAt ğ•œ s x\nhy : Eq (f x) y\nâŠ¢ Eq (fderivWithin ğ•œ (fun y => g (f y)) s x) ((fderivWithin ğ•œ g t (f x)).comp (fderivWithin ğ•œ f s x))","decl":"/-- A variant for the derivative of a composition, written without `âˆ˜`. -/\ntheorem fderivWithin_comp_of_eq' {g : F â†’ G} {t : Set F} {y : F}\n    (hg : DifferentiableWithinAt ğ•œ g t y) (hf : DifferentiableWithinAt ğ•œ f s x) (h : MapsTo f s t)\n    (hxs : UniqueDiffWithinAt ğ•œ s x) (hy : f x = y) :\n    fderivWithin ğ•œ (fun y â†¦ g (f y)) s x\n      = (fderivWithin ğ•œ g t (f x)).comp (fderivWithin ğ•œ f s x) := by\n  subst hy; exact fderivWithin_comp _ hg hf h hxs\n\n"}
{"name":"fderivWithin_fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ng : F â†’ G\nf : E â†’ F\nx : E\ny : F\ns : Set E\nt : Set F\nhg : DifferentiableWithinAt ğ•œ g t y\nhf : DifferentiableWithinAt ğ•œ f s x\nh : Set.MapsTo f s t\nhxs : UniqueDiffWithinAt ğ•œ s x\nhy : Eq (f x) y\nv : E\nâŠ¢ Eq ((fderivWithin ğ•œ g t y) ((fderivWithin ğ•œ f s x) v)) ((fderivWithin ğ•œ (Function.comp g f) s x) v)","decl":"/-- A version of `fderivWithin_comp` that is useful to rewrite the composition of two derivatives\n  into a single derivative. This version always applies, but creates a new side-goal `f x = y`. -/\ntheorem fderivWithin_fderivWithin {g : F â†’ G} {f : E â†’ F} {x : E} {y : F} {s : Set E} {t : Set F}\n    (hg : DifferentiableWithinAt ğ•œ g t y) (hf : DifferentiableWithinAt ğ•œ f s x) (h : MapsTo f s t)\n    (hxs : UniqueDiffWithinAt ğ•œ s x) (hy : f x = y) (v : E) :\n    fderivWithin ğ•œ g t y (fderivWithin ğ•œ f s x v) = fderivWithin ğ•œ (g âˆ˜ f) s x v := by\n  subst y\n  rw [fderivWithin_comp x hg hf h hxs, coe_comp', Function.comp_apply]\n\n"}
{"name":"fderivWithin_compâ‚ƒ","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nG' : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nf : E â†’ F\nx : E\ns : Set E\ng' : G â†’ G'\ng : F â†’ G\nt : Set F\nu : Set G\ny : F\ny' : G\nhg' : DifferentiableWithinAt ğ•œ g' u y'\nhg : DifferentiableWithinAt ğ•œ g t y\nhf : DifferentiableWithinAt ğ•œ f s x\nh2g : Set.MapsTo g t u\nh2f : Set.MapsTo f s t\nh3g : Eq (g y) y'\nh3f : Eq (f x) y\nhxs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (fderivWithin ğ•œ (Function.comp g' (Function.comp g f)) s x) ((fderivWithin ğ•œ g' u y').comp ((fderivWithin ğ•œ g t y).comp (fderivWithin ğ•œ f s x)))","decl":"/-- Ternary version of `fderivWithin_comp`, with equality assumptions of basepoints added, in\n  order to apply more easily as a rewrite from right-to-left. -/\ntheorem fderivWithin_compâ‚ƒ {g' : G â†’ G'} {g : F â†’ G} {t : Set F} {u : Set G} {y : F} {y' : G}\n    (hg' : DifferentiableWithinAt ğ•œ g' u y') (hg : DifferentiableWithinAt ğ•œ g t y)\n    (hf : DifferentiableWithinAt ğ•œ f s x) (h2g : MapsTo g t u) (h2f : MapsTo f s t) (h3g : g y = y')\n    (h3f : f x = y) (hxs : UniqueDiffWithinAt ğ•œ s x) :\n    fderivWithin ğ•œ (g' âˆ˜ g âˆ˜ f) s x =\n      (fderivWithin ğ•œ g' u y').comp ((fderivWithin ğ•œ g t y).comp (fderivWithin ğ•œ f s x)) := by\n  substs h3g h3f\n  exact (hg'.hasFDerivWithinAt.comp x (hg.hasFDerivWithinAt.comp x hf.hasFDerivWithinAt h2f) <|\n    h2g.comp h2f).fderivWithin hxs\n\n"}
{"name":"fderivWithin.compâ‚ƒ","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nG' : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nf : E â†’ F\nx : E\ns : Set E\ng' : G â†’ G'\ng : F â†’ G\nt : Set F\nu : Set G\ny : F\ny' : G\nhg' : DifferentiableWithinAt ğ•œ g' u y'\nhg : DifferentiableWithinAt ğ•œ g t y\nhf : DifferentiableWithinAt ğ•œ f s x\nh2g : Set.MapsTo g t u\nh2f : Set.MapsTo f s t\nh3g : Eq (g y) y'\nh3f : Eq (f x) y\nhxs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (fderivWithin ğ•œ (Function.comp g' (Function.comp g f)) s x) ((fderivWithin ğ•œ g' u y').comp ((fderivWithin ğ•œ g t y).comp (fderivWithin ğ•œ f s x)))","decl":"@[deprecated (since := \"2024-10-31\")] alias fderivWithin.compâ‚ƒ := fderivWithin_compâ‚ƒ\n\n"}
{"name":"fderiv_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nx : E\ng : F â†’ G\nhg : DifferentiableAt ğ•œ g (f x)\nhf : DifferentiableAt ğ•œ f x\nâŠ¢ Eq (fderiv ğ•œ (Function.comp g f) x) ((fderiv ğ•œ g (f x)).comp (fderiv ğ•œ f x))","decl":"theorem fderiv_comp {g : F â†’ G} (hg : DifferentiableAt ğ•œ g (f x)) (hf : DifferentiableAt ğ•œ f x) :\n    fderiv ğ•œ (g âˆ˜ f) x = (fderiv ğ•œ g (f x)).comp (fderiv ğ•œ f x) :=\n  (hg.hasFDerivAt.comp x hf.hasFDerivAt).fderiv\n\n"}
{"name":"fderiv.comp","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nx : E\ng : F â†’ G\nhg : DifferentiableAt ğ•œ g (f x)\nhf : DifferentiableAt ğ•œ f x\nâŠ¢ Eq (fderiv ğ•œ (Function.comp g f) x) ((fderiv ğ•œ g (f x)).comp (fderiv ğ•œ f x))","decl":"@[deprecated (since := \"2024-10-31\")] alias fderiv.comp := fderiv_comp\n\n"}
{"name":"fderiv_comp'","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nx : E\ng : F â†’ G\nhg : DifferentiableAt ğ•œ g (f x)\nhf : DifferentiableAt ğ•œ f x\nâŠ¢ Eq (fderiv ğ•œ (fun y => g (f y)) x) ((fderiv ğ•œ g (f x)).comp (fderiv ğ•œ f x))","decl":"/-- A variant for the derivative of a composition, written without `âˆ˜`. -/\ntheorem fderiv_comp' {g : F â†’ G} (hg : DifferentiableAt ğ•œ g (f x)) (hf : DifferentiableAt ğ•œ f x) :\n    fderiv ğ•œ (fun y â†¦ g (f y)) x = (fderiv ğ•œ g (f x)).comp (fderiv ğ•œ f x) :=\n  fderiv_comp x hg hf\n\n"}
{"name":"fderiv_comp_fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nx : E\ns : Set E\ng : F â†’ G\nhg : DifferentiableAt ğ•œ g (f x)\nhf : DifferentiableWithinAt ğ•œ f s x\nhxs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (fderivWithin ğ•œ (Function.comp g f) s x) ((fderiv ğ•œ g (f x)).comp (fderivWithin ğ•œ f s x))","decl":"theorem fderiv_comp_fderivWithin {g : F â†’ G} (hg : DifferentiableAt ğ•œ g (f x))\n    (hf : DifferentiableWithinAt ğ•œ f s x) (hxs : UniqueDiffWithinAt ğ•œ s x) :\n    fderivWithin ğ•œ (g âˆ˜ f) s x = (fderiv ğ•œ g (f x)).comp (fderivWithin ğ•œ f s x) :=\n  (hg.hasFDerivAt.comp_hasFDerivWithinAt x hf.hasFDerivWithinAt).fderivWithin hxs\n\n"}
{"name":"fderiv.comp_fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nx : E\ns : Set E\ng : F â†’ G\nhg : DifferentiableAt ğ•œ g (f x)\nhf : DifferentiableWithinAt ğ•œ f s x\nhxs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (fderivWithin ğ•œ (Function.comp g f) s x) ((fderiv ğ•œ g (f x)).comp (fderivWithin ğ•œ f s x))","decl":"@[deprecated (since := \"2024-10-31\")] alias fderiv.comp_fderivWithin := fderiv_comp_fderivWithin\n\n"}
{"name":"DifferentiableOn.comp","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\ns : Set E\ng : F â†’ G\nt : Set F\nhg : DifferentiableOn ğ•œ g t\nhf : DifferentiableOn ğ•œ f s\nst : Set.MapsTo f s t\nâŠ¢ DifferentiableOn ğ•œ (Function.comp g f) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.comp {g : F â†’ G} {t : Set F} (hg : DifferentiableOn ğ•œ g t)\n    (hf : DifferentiableOn ğ•œ f s) (st : MapsTo f s t) : DifferentiableOn ğ•œ (g âˆ˜ f) s :=\n  fun x hx => DifferentiableWithinAt.comp x (hg (f x) (st hx)) (hf x hx) st\n\n"}
{"name":"Differentiable.comp","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\ng : F â†’ G\nhg : Differentiable ğ•œ g\nhf : Differentiable ğ•œ f\nâŠ¢ Differentiable ğ•œ (Function.comp g f)","decl":"@[fun_prop]\ntheorem Differentiable.comp {g : F â†’ G} (hg : Differentiable ğ•œ g) (hf : Differentiable ğ•œ f) :\n    Differentiable ğ•œ (g âˆ˜ f) :=\n  fun x => DifferentiableAt.comp x (hg (f x)) (hf x)\n\n"}
{"name":"Differentiable.comp_differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\ns : Set E\ng : F â†’ G\nhg : Differentiable ğ•œ g\nhf : DifferentiableOn ğ•œ f s\nâŠ¢ DifferentiableOn ğ•œ (Function.comp g f) s","decl":"@[fun_prop]\ntheorem Differentiable.comp_differentiableOn {g : F â†’ G} (hg : Differentiable ğ•œ g)\n    (hf : DifferentiableOn ğ•œ f s) : DifferentiableOn ğ•œ (g âˆ˜ f) s :=\n  hg.differentiableOn.comp hf (mapsTo_univ _ _)\n\n"}
{"name":"HasStrictFDerivAt.comp","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ng : F â†’ G\ng' : ContinuousLinearMap (RingHom.id ğ•œ) F G\nhg : HasStrictFDerivAt g g' (f x)\nhf : HasStrictFDerivAt f f' x\nâŠ¢ HasStrictFDerivAt (fun x => g (f x)) (g'.comp f') x","decl":"/-- The chain rule for derivatives in the sense of strict differentiability. -/\n@[fun_prop]\nprotected theorem HasStrictFDerivAt.comp {g : F â†’ G} {g' : F â†’L[ğ•œ] G}\n    (hg : HasStrictFDerivAt g g' (f x)) (hf : HasStrictFDerivAt f f' x) :\n    HasStrictFDerivAt (fun x => g (f x)) (g'.comp f') x :=\n  .of_isLittleO <|\n    ((hg.isLittleO.comp_tendsto (hf.continuousAt.prodMap' hf.continuousAt)).trans_isBigO\n        hf.isBigO_sub).triangle <| by\n      simpa only [g'.map_sub, f'.coe_comp'] using (g'.isBigO_comp _ _).trans_isLittleO hf.isLittleO\n\n"}
{"name":"Differentiable.iterate","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : E â†’ E\nhf : Differentiable ğ•œ f\nn : Nat\nâŠ¢ Differentiable ğ•œ (Nat.iterate f n)","decl":"@[fun_prop]\nprotected theorem Differentiable.iterate {f : E â†’ E} (hf : Differentiable ğ•œ f) (n : â„•) :\n    Differentiable ğ•œ f^[n] :=\n  Nat.recOn n differentiable_id fun _ ihn => ihn.comp hf\n\n"}
{"name":"DifferentiableOn.iterate","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ns : Set E\nf : E â†’ E\nhf : DifferentiableOn ğ•œ f s\nhs : Set.MapsTo f s s\nn : Nat\nâŠ¢ DifferentiableOn ğ•œ (Nat.iterate f n) s","decl":"@[fun_prop]\nprotected theorem DifferentiableOn.iterate {f : E â†’ E} (hf : DifferentiableOn ğ•œ f s)\n    (hs : MapsTo f s s) (n : â„•) : DifferentiableOn ğ•œ f^[n] s :=\n  Nat.recOn n differentiableOn_id fun _ ihn => ihn.comp hf hs\n\n"}
{"name":"HasFDerivAtFilter.iterate","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nL : Filter E\nf : E â†’ E\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhf : HasFDerivAtFilter f f' x L\nhL : Filter.Tendsto f L L\nhx : Eq (f x) x\nn : Nat\nâŠ¢ HasFDerivAtFilter (Nat.iterate f n) (HPow.hPow f' n) x L","decl":"protected theorem HasFDerivAtFilter.iterate {f : E â†’ E} {f' : E â†’L[ğ•œ] E}\n    (hf : HasFDerivAtFilter f f' x L) (hL : Tendsto f L L) (hx : f x = x) (n : â„•) :\n    HasFDerivAtFilter f^[n] (f' ^ n) x L := by\n  induction n with\n  | zero => exact hasFDerivAtFilter_id x L\n  | succ n ihn =>\n    rw [Function.iterate_succ, pow_succ]\n    rw [â† hx] at ihn\n    exact ihn.comp x hf hL\n\n"}
{"name":"HasFDerivAt.iterate","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nf : E â†’ E\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhf : HasFDerivAt f f' x\nhx : Eq (f x) x\nn : Nat\nâŠ¢ HasFDerivAt (Nat.iterate f n) (HPow.hPow f' n) x","decl":"@[fun_prop]\nprotected theorem HasFDerivAt.iterate {f : E â†’ E} {f' : E â†’L[ğ•œ] E} (hf : HasFDerivAt f f' x)\n    (hx : f x = x) (n : â„•) : HasFDerivAt f^[n] (f' ^ n) x := by\n  refine HasFDerivAtFilter.iterate hf ?_ hx n\n  -- Porting note: was `convert hf.continuousAt`\n  convert hf.continuousAt.tendsto\n  exact hx.symm\n\n"}
{"name":"HasFDerivWithinAt.iterate","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\ns : Set E\nf : E â†’ E\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhf : HasFDerivWithinAt f f' s x\nhx : Eq (f x) x\nhs : Set.MapsTo f s s\nn : Nat\nâŠ¢ HasFDerivWithinAt (Nat.iterate f n) (HPow.hPow f' n) s x","decl":"@[fun_prop]\nprotected theorem HasFDerivWithinAt.iterate {f : E â†’ E} {f' : E â†’L[ğ•œ] E}\n    (hf : HasFDerivWithinAt f f' s x) (hx : f x = x) (hs : MapsTo f s s) (n : â„•) :\n    HasFDerivWithinAt f^[n] (f' ^ n) s x := by\n  refine HasFDerivAtFilter.iterate hf ?_ hx n\n  rw [_root_.nhdsWithin] -- Porting note: Added `rw` to get rid of an error\n  convert tendsto_inf.2 âŸ¨hf.continuousWithinAt, _âŸ©\n  exacts [hx.symm, (tendsto_principal_principal.2 hs).mono_left inf_le_right]\n\n"}
{"name":"HasStrictFDerivAt.iterate","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nf : E â†’ E\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhf : HasStrictFDerivAt f f' x\nhx : Eq (f x) x\nn : Nat\nâŠ¢ HasStrictFDerivAt (Nat.iterate f n) (HPow.hPow f' n) x","decl":"@[fun_prop]\nprotected theorem HasStrictFDerivAt.iterate {f : E â†’ E} {f' : E â†’L[ğ•œ] E}\n    (hf : HasStrictFDerivAt f f' x) (hx : f x = x) (n : â„•) :\n    HasStrictFDerivAt f^[n] (f' ^ n) x := by\n  induction n with\n  | zero => exact hasStrictFDerivAt_id x\n  | succ n ihn =>\n    rw [Function.iterate_succ, pow_succ]\n    rw [â† hx] at ihn\n    exact ihn.comp x hf\n\n"}
{"name":"DifferentiableAt.iterate","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nf : E â†’ E\nhf : DifferentiableAt ğ•œ f x\nhx : Eq (f x) x\nn : Nat\nâŠ¢ DifferentiableAt ğ•œ (Nat.iterate f n) x","decl":"@[fun_prop]\nprotected theorem DifferentiableAt.iterate {f : E â†’ E} (hf : DifferentiableAt ğ•œ f x) (hx : f x = x)\n    (n : â„•) : DifferentiableAt ğ•œ f^[n] x :=\n  (hf.hasFDerivAt.iterate hx n).differentiableAt\n\n"}
{"name":"DifferentiableWithinAt.iterate","module":"Mathlib.Analysis.Calculus.FDeriv.Comp","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\ns : Set E\nf : E â†’ E\nhf : DifferentiableWithinAt ğ•œ f s x\nhx : Eq (f x) x\nhs : Set.MapsTo f s s\nn : Nat\nâŠ¢ DifferentiableWithinAt ğ•œ (Nat.iterate f n) s x","decl":"@[fun_prop]\nprotected theorem DifferentiableWithinAt.iterate {f : E â†’ E} (hf : DifferentiableWithinAt ğ•œ f s x)\n    (hx : f x = x) (hs : MapsTo f s s) (n : â„•) : DifferentiableWithinAt ğ•œ f^[n] s x :=\n  (hf.hasFDerivWithinAt.iterate hx hs n).differentiableWithinAt\n\n"}
