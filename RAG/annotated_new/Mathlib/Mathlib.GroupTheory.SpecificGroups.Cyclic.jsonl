{"name":"IsAddCyclic.exists_generator","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : IsAddCyclic α\n⊢ Exists fun g => ∀ (x : α), Membership.mem (AddSubgroup.zmultiples g) x","decl":"@[to_additive]\ntheorem IsCyclic.exists_generator [Group α] [IsCyclic α] : ∃ g : α, ∀ x, x ∈ zpowers g :=\n  exists_zpow_surjective α\n\n"}
{"name":"IsCyclic.exists_generator","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : IsCyclic α\n⊢ Exists fun g => ∀ (x : α), Membership.mem (Subgroup.zpowers g) x","decl":"@[to_additive]\ntheorem IsCyclic.exists_generator [Group α] [IsCyclic α] : ∃ g : α, ∀ x, x ∈ zpowers g :=\n  exists_zpow_surjective α\n\n"}
{"name":"isAddCyclic_iff_exists_zmultiples_eq_top","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\n⊢ Iff (IsAddCyclic α) (Exists fun g => Eq (AddSubgroup.zmultiples g) Top.top)","decl":"@[to_additive]\ntheorem isCyclic_iff_exists_zpowers_eq_top [Group α] : IsCyclic α ↔ ∃ g : α, zpowers g = ⊤ := by\n  simp only [eq_top_iff', mem_zpowers_iff]\n  exact ⟨fun ⟨h⟩ ↦ h, fun h ↦ ⟨h⟩⟩\n\n"}
{"name":"isCyclic_iff_exists_zpowers_eq_top","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : Group α\n⊢ Iff (IsCyclic α) (Exists fun g => Eq (Subgroup.zpowers g) Top.top)","decl":"@[to_additive]\ntheorem isCyclic_iff_exists_zpowers_eq_top [Group α] : IsCyclic α ↔ ∃ g : α, zpowers g = ⊤ := by\n  simp only [eq_top_iff', mem_zpowers_iff]\n  exact ⟨fun ⟨h⟩ ↦ h, fun h ↦ ⟨h⟩⟩\n\n"}
{"name":"isAddCyclic_of_subsingleton","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : Subsingleton α\n⊢ IsAddCyclic α","decl":"@[to_additive]\ninstance (priority := 100) isCyclic_of_subsingleton [Group α] [Subsingleton α] : IsCyclic α :=\n  ⟨⟨1, fun _ => ⟨0, Subsingleton.elim _ _⟩⟩⟩\n\n"}
{"name":"isCyclic_of_subsingleton","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : Subsingleton α\n⊢ IsCyclic α","decl":"@[to_additive]\ninstance (priority := 100) isCyclic_of_subsingleton [Group α] [Subsingleton α] : IsCyclic α :=\n  ⟨⟨1, fun _ => ⟨0, Subsingleton.elim _ _⟩⟩⟩\n\n"}
{"name":"isCyclic_multiplicative_iff","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\n⊢ Iff (IsCyclic (Multiplicative α)) (IsAddCyclic α)","decl":"@[simp]\ntheorem isCyclic_multiplicative_iff [AddGroup α] : IsCyclic (Multiplicative α) ↔ IsAddCyclic α :=\n  ⟨fun H ↦ ⟨H.1⟩, fun H ↦ ⟨H.1⟩⟩\n\n"}
{"name":"isCyclic_multiplicative","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : IsAddCyclic α\n⊢ IsCyclic (Multiplicative α)","decl":"instance isCyclic_multiplicative [AddGroup α] [IsAddCyclic α] : IsCyclic (Multiplicative α) :=\n  isCyclic_multiplicative_iff.mpr inferInstance\n\n"}
{"name":"isAddCyclic_additive_iff","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : Group α\n⊢ Iff (IsAddCyclic (Additive α)) (IsCyclic α)","decl":"@[simp]\ntheorem isAddCyclic_additive_iff [Group α] : IsAddCyclic (Additive α) ↔ IsCyclic α :=\n  ⟨fun H ↦ ⟨H.1⟩, fun H ↦ ⟨H.1⟩⟩\n\n"}
{"name":"isAddCyclic_additive","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : IsCyclic α\n⊢ IsAddCyclic (Additive α)","decl":"instance isAddCyclic_additive [Group α] [IsCyclic α] : IsAddCyclic (Additive α) :=\n  isAddCyclic_additive_iff.mpr inferInstance\n\n"}
{"name":"IsCyclic.commutative","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : IsCyclic α\n⊢ Std.Commutative fun x1 x2 => HMul.hMul x1 x2","decl":"@[to_additive]\ninstance IsCyclic.commutative [Group α] [IsCyclic α] :\n    Std.Commutative (· * · : α → α → α) where\n  comm x y :=\n    let ⟨_, hg⟩ := IsCyclic.exists_generator (α := α)\n    let ⟨_, hx⟩ := hg x\n    let ⟨_, hy⟩ := hg y\n    hy ▸ hx ▸ zpow_mul_comm _ _ _\n\n"}
{"name":"IsAddCyclic.commutative","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : IsAddCyclic α\n⊢ Std.Commutative fun x1 x2 => HAdd.hAdd x1 x2","decl":"@[to_additive]\ninstance IsCyclic.commutative [Group α] [IsCyclic α] :\n    Std.Commutative (· * · : α → α → α) where\n  comm x y :=\n    let ⟨_, hg⟩ := IsCyclic.exists_generator (α := α)\n    let ⟨_, hx⟩ := hg x\n    let ⟨_, hy⟩ := hg y\n    hy ▸ hx ▸ zpow_mul_comm _ _ _\n\n"}
{"name":"instIsCommutativeOfIsCyclicSubtypeMemSubgroup","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : IsCyclic (Subtype fun x => Membership.mem H x)\n⊢ H.IsCommutative","decl":"instance [Group G] (H : Subgroup G) [IsCyclic H] : H.IsCommutative :=\n  ⟨IsCyclic.commutative⟩\n\n"}
{"name":"Nontrivial.of_not_isCyclic","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : Group α\nnc : Not (IsCyclic α)\n⊢ Nontrivial α","decl":"/-- A non-cyclic multiplicative group is non-trivial. -/\n@[to_additive \"A non-cyclic additive group is non-trivial.\"]\ntheorem Nontrivial.of_not_isCyclic (nc : ¬IsCyclic α) : Nontrivial α := by\n  contrapose! nc\n  exact @isCyclic_of_subsingleton _ _ (not_nontrivial_iff_subsingleton.mp nc)\n\n"}
{"name":"Nontrivial.of_not_isAddCyclic","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\nnc : Not (IsAddCyclic α)\n⊢ Nontrivial α","decl":"/-- A non-cyclic multiplicative group is non-trivial. -/\n@[to_additive \"A non-cyclic additive group is non-trivial.\"]\ntheorem Nontrivial.of_not_isCyclic (nc : ¬IsCyclic α) : Nontrivial α := by\n  contrapose! nc\n  exact @isCyclic_of_subsingleton _ _ (not_nontrivial_iff_subsingleton.mp nc)\n\n"}
{"name":"AddMonoidHom.map_addCyclic","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nh : IsAddCyclic G\nσ : AddMonoidHom G G\n⊢ Exists fun m => ∀ (g : G), Eq (σ g) (HSMul.hSMul m g)","decl":"@[to_additive]\ntheorem MonoidHom.map_cyclic [h : IsCyclic G] (σ : G →* G) :\n    ∃ m : ℤ, ∀ g : G, σ g = g ^ m := by\n  obtain ⟨h, hG⟩ := IsCyclic.exists_generator (α := G)\n  obtain ⟨m, hm⟩ := hG (σ h)\n  refine ⟨m, fun g => ?_⟩\n  obtain ⟨n, rfl⟩ := hG g\n  rw [MonoidHom.map_zpow, ← hm, ← zpow_mul, ← zpow_mul']\n\n"}
{"name":"MonoidHom.map_cyclic","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝ : Group G\nh : IsCyclic G\nσ : MonoidHom G G\n⊢ Exists fun m => ∀ (g : G), Eq (σ g) (HPow.hPow g m)","decl":"@[to_additive]\ntheorem MonoidHom.map_cyclic [h : IsCyclic G] (σ : G →* G) :\n    ∃ m : ℤ, ∀ g : G, σ g = g ^ m := by\n  obtain ⟨h, hG⟩ := IsCyclic.exists_generator (α := G)\n  obtain ⟨m, hm⟩ := hG (σ h)\n  refine ⟨m, fun g => ?_⟩\n  obtain ⟨n, rfl⟩ := hG g\n  rw [MonoidHom.map_zpow, ← hm, ← zpow_mul, ← zpow_mul']\n\n"}
{"name":"isCyclic_iff_exists_orderOf_eq_natCard","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : Finite α\n⊢ Iff (IsCyclic α) (Exists fun g => Eq (orderOf g) (Nat.card α))","decl":"@[to_additive]\nlemma isCyclic_iff_exists_orderOf_eq_natCard [Finite α] :\n    IsCyclic α ↔ ∃ g : α, orderOf g = Nat.card α := by\n  simp_rw [isCyclic_iff_exists_zpowers_eq_top, ← card_eq_iff_eq_top, Nat.card_zpowers]\n\n"}
{"name":"isAddCyclic_iff_exists_addOrderOf_eq_natCard","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : Finite α\n⊢ Iff (IsAddCyclic α) (Exists fun g => Eq (addOrderOf g) (Nat.card α))","decl":"@[to_additive]\nlemma isCyclic_iff_exists_orderOf_eq_natCard [Finite α] :\n    IsCyclic α ↔ ∃ g : α, orderOf g = Nat.card α := by\n  simp_rw [isCyclic_iff_exists_zpowers_eq_top, ← card_eq_iff_eq_top, Nat.card_zpowers]\n\n"}
{"name":"isCyclic_iff_exists_natCard_le_orderOf","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : Finite α\n⊢ Iff (IsCyclic α) (Exists fun g => LE.le (Nat.card α) (orderOf g))","decl":"@[to_additive]\nlemma isCyclic_iff_exists_natCard_le_orderOf [Finite α] :\n    IsCyclic α ↔ ∃ g : α, Nat.card α ≤ orderOf g := by\n  rw [isCyclic_iff_exists_orderOf_eq_natCard]\n  apply exists_congr\n  intro g\n  exact ⟨Eq.ge, le_antisymm orderOf_le_card⟩\n\n"}
{"name":"isAddCyclic_iff_exists_natCard_le_addOrderOf","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : Finite α\n⊢ Iff (IsAddCyclic α) (Exists fun g => LE.le (Nat.card α) (addOrderOf g))","decl":"@[to_additive]\nlemma isCyclic_iff_exists_natCard_le_orderOf [Finite α] :\n    IsCyclic α ↔ ∃ g : α, Nat.card α ≤ orderOf g := by\n  rw [isCyclic_iff_exists_orderOf_eq_natCard]\n  apply exists_congr\n  intro g\n  exact ⟨Eq.ge, le_antisymm orderOf_le_card⟩\n\n"}
{"name":"isCyclic_iff_exists_ofOrder_eq_natCard","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : Finite α\n⊢ Iff (IsCyclic α) (Exists fun g => Eq (orderOf g) (Nat.card α))","decl":"@[deprecated (since := \"2024-12-20\")]\nalias isCyclic_iff_exists_ofOrder_eq_natCard := isCyclic_iff_exists_orderOf_eq_natCard\n\n"}
{"name":"isAddCyclic_iff_exists_ofOrder_eq_natCard","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : Finite α\n⊢ Iff (IsAddCyclic α) (Exists fun g => Eq (addOrderOf g) (Nat.card α))","decl":"@[deprecated (since := \"2024-12-20\")]\nalias isAddCyclic_iff_exists_ofOrder_eq_natCard := isAddCyclic_iff_exists_addOrderOf_eq_natCard\n\n"}
{"name":"IsCyclic.iff_exists_ofOrder_eq_natCard_of_Fintype","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : Finite α\n⊢ Iff (IsCyclic α) (Exists fun g => Eq (orderOf g) (Nat.card α))","decl":"@[deprecated (since := \"2024-12-20\")]\nalias IsCyclic.iff_exists_ofOrder_eq_natCard_of_Fintype :=\n  isCyclic_iff_exists_orderOf_eq_natCard\n\n"}
{"name":"IsAddCyclic.iff_exists_ofOrder_eq_natCard_of_Fintype","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : Finite α\n⊢ Iff (IsAddCyclic α) (Exists fun g => Eq (addOrderOf g) (Nat.card α))","decl":"@[deprecated (since := \"2024-12-20\")]\nalias IsAddCyclic.iff_exists_ofOrder_eq_natCard_of_Fintype :=\n  isAddCyclic_iff_exists_addOrderOf_eq_natCard\n\n"}
{"name":"isCyclic_of_orderOf_eq_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : Finite α\nx : α\nhx : Eq (orderOf x) (Nat.card α)\n⊢ IsCyclic α","decl":"@[to_additive]\ntheorem isCyclic_of_orderOf_eq_card [Finite α] (x : α) (hx : orderOf x = Nat.card α) :\n    IsCyclic α :=\n  isCyclic_iff_exists_orderOf_eq_natCard.mpr ⟨x, hx⟩\n\n"}
{"name":"isAddCyclic_of_addOrderOf_eq_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : Finite α\nx : α\nhx : Eq (addOrderOf x) (Nat.card α)\n⊢ IsAddCyclic α","decl":"@[to_additive]\ntheorem isCyclic_of_orderOf_eq_card [Finite α] (x : α) (hx : orderOf x = Nat.card α) :\n    IsCyclic α :=\n  isCyclic_iff_exists_orderOf_eq_natCard.mpr ⟨x, hx⟩\n\n"}
{"name":"isCyclic_of_card_le_orderOf","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : Finite α\nx : α\nhx : LE.le (Nat.card α) (orderOf x)\n⊢ IsCyclic α","decl":"@[to_additive]\ntheorem isCyclic_of_card_le_orderOf [Finite α] (x : α) (hx : Nat.card α ≤ orderOf x) :\n    IsCyclic α :=\n  isCyclic_iff_exists_natCard_le_orderOf.mpr ⟨x, hx⟩\n\n"}
{"name":"isAddCyclic_of_card_le_addOrderOf","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : Finite α\nx : α\nhx : LE.le (Nat.card α) (addOrderOf x)\n⊢ IsAddCyclic α","decl":"@[to_additive]\ntheorem isCyclic_of_card_le_orderOf [Finite α] (x : α) (hx : Nat.card α ≤ orderOf x) :\n    IsCyclic α :=\n  isCyclic_iff_exists_natCard_le_orderOf.mpr ⟨x, hx⟩\n\n"}
{"name":"Subgroup.eq_bot_or_eq_top_of_prime_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝ : Group G\nH : Subgroup G\nhp : Fact (Nat.Prime (Nat.card G))\n⊢ Or (Eq H Bot.bot) (Eq H Top.top)","decl":"@[to_additive]\ntheorem Subgroup.eq_bot_or_eq_top_of_prime_card\n    (H : Subgroup G) [hp : Fact (Nat.card G).Prime] : H = ⊥ ∨ H = ⊤ := by\n  have : Finite G := Nat.finite_of_card_ne_zero hp.1.ne_zero\n  have := card_subgroup_dvd_card H\n  rwa [Nat.dvd_prime hp.1, ← eq_bot_iff_card, card_eq_iff_eq_top] at this\n\n"}
{"name":"AddSubgroup.eq_bot_or_eq_top_of_prime_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nH : AddSubgroup G\nhp : Fact (Nat.Prime (Nat.card G))\n⊢ Or (Eq H Bot.bot) (Eq H Top.top)","decl":"@[to_additive]\ntheorem Subgroup.eq_bot_or_eq_top_of_prime_card\n    (H : Subgroup G) [hp : Fact (Nat.card G).Prime] : H = ⊥ ∨ H = ⊤ := by\n  have : Finite G := Nat.finite_of_card_ne_zero hp.1.ne_zero\n  have := card_subgroup_dvd_card H\n  rwa [Nat.dvd_prime hp.1, ← eq_bot_iff_card, card_eq_iff_eq_top] at this\n\n"}
{"name":"zmultiples_eq_top_of_prime_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\np : Nat\nhp : Fact (Nat.Prime p)\nh : Eq (Nat.card G) p\ng : G\nhg : Ne g 0\n⊢ Eq (AddSubgroup.zmultiples g) Top.top","decl":"/-- Any non-identity element of a finite group of prime order generates the group. -/\n@[to_additive \"Any non-identity element of a finite group of prime order generates the group.\"]\ntheorem zpowers_eq_top_of_prime_card {p : ℕ}\n    [hp : Fact p.Prime] (h : Nat.card G = p) {g : G} (hg : g ≠ 1) : zpowers g = ⊤ := by\n  subst h\n  have := (zpowers g).eq_bot_or_eq_top_of_prime_card\n  rwa [zpowers_eq_bot, or_iff_right hg] at this\n\n"}
{"name":"zpowers_eq_top_of_prime_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝ : Group G\np : Nat\nhp : Fact (Nat.Prime p)\nh : Eq (Nat.card G) p\ng : G\nhg : Ne g 1\n⊢ Eq (Subgroup.zpowers g) Top.top","decl":"/-- Any non-identity element of a finite group of prime order generates the group. -/\n@[to_additive \"Any non-identity element of a finite group of prime order generates the group.\"]\ntheorem zpowers_eq_top_of_prime_card {p : ℕ}\n    [hp : Fact p.Prime] (h : Nat.card G = p) {g : G} (hg : g ≠ 1) : zpowers g = ⊤ := by\n  subst h\n  have := (zpowers g).eq_bot_or_eq_top_of_prime_card\n  rwa [zpowers_eq_bot, or_iff_right hg] at this\n\n"}
{"name":"mem_zmultiples_of_prime_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\np : Nat\nhp : Fact (Nat.Prime p)\nh : Eq (Nat.card G) p\ng g' : G\nhg : Ne g 0\n⊢ Membership.mem (AddSubgroup.zmultiples g) g'","decl":"@[to_additive]\ntheorem mem_zpowers_of_prime_card {p : ℕ} [hp : Fact p.Prime]\n    (h : Nat.card G = p) {g g' : G} (hg : g ≠ 1) : g' ∈ zpowers g := by\n  simp_rw [zpowers_eq_top_of_prime_card h hg, Subgroup.mem_top]\n\n"}
{"name":"mem_zpowers_of_prime_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝ : Group G\np : Nat\nhp : Fact (Nat.Prime p)\nh : Eq (Nat.card G) p\ng g' : G\nhg : Ne g 1\n⊢ Membership.mem (Subgroup.zpowers g) g'","decl":"@[to_additive]\ntheorem mem_zpowers_of_prime_card {p : ℕ} [hp : Fact p.Prime]\n    (h : Nat.card G = p) {g g' : G} (hg : g ≠ 1) : g' ∈ zpowers g := by\n  simp_rw [zpowers_eq_top_of_prime_card h hg, Subgroup.mem_top]\n\n"}
{"name":"mem_powers_of_prime_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝ : Group G\np : Nat\nhp : Fact (Nat.Prime p)\nh : Eq (Nat.card G) p\ng g' : G\nhg : Ne g 1\n⊢ Membership.mem (Submonoid.powers g) g'","decl":"@[to_additive]\ntheorem mem_powers_of_prime_card {p : ℕ} [hp : Fact p.Prime]\n    (h : Nat.card G = p) {g g' : G} (hg : g ≠ 1) : g' ∈ Submonoid.powers g := by\n  have : Finite G := Nat.finite_of_card_ne_zero (h ▸ hp.1.ne_zero)\n  rw [mem_powers_iff_mem_zpowers]\n  exact mem_zpowers_of_prime_card h hg\n\n"}
{"name":"mem_multiples_of_prime_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\np : Nat\nhp : Fact (Nat.Prime p)\nh : Eq (Nat.card G) p\ng g' : G\nhg : Ne g 0\n⊢ Membership.mem (AddSubmonoid.multiples g) g'","decl":"@[to_additive]\ntheorem mem_powers_of_prime_card {p : ℕ} [hp : Fact p.Prime]\n    (h : Nat.card G = p) {g g' : G} (hg : g ≠ 1) : g' ∈ Submonoid.powers g := by\n  have : Finite G := Nat.finite_of_card_ne_zero (h ▸ hp.1.ne_zero)\n  rw [mem_powers_iff_mem_zpowers]\n  exact mem_zpowers_of_prime_card h hg\n\n"}
{"name":"powers_eq_top_of_prime_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝ : Group G\np : Nat\nhp : Fact (Nat.Prime p)\nh : Eq (Nat.card G) p\ng : G\nhg : Ne g 1\n⊢ Eq (Submonoid.powers g) Top.top","decl":"@[to_additive]\ntheorem powers_eq_top_of_prime_card {p : ℕ}\n    [hp : Fact p.Prime] (h : Nat.card G = p) {g : G} (hg : g ≠ 1) : Submonoid.powers g = ⊤ := by\n  ext x\n  simp [mem_powers_of_prime_card h hg]\n\n"}
{"name":"multiples_eq_top_of_prime_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\np : Nat\nhp : Fact (Nat.Prime p)\nh : Eq (Nat.card G) p\ng : G\nhg : Ne g 0\n⊢ Eq (AddSubmonoid.multiples g) Top.top","decl":"@[to_additive]\ntheorem powers_eq_top_of_prime_card {p : ℕ}\n    [hp : Fact p.Prime] (h : Nat.card G = p) {g : G} (hg : g ≠ 1) : Submonoid.powers g = ⊤ := by\n  ext x\n  simp [mem_powers_of_prime_card h hg]\n\n"}
{"name":"isCyclic_of_prime_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : Group α\np : Nat\nhp : Fact (Nat.Prime p)\nh : Eq (Nat.card α) p\n⊢ IsCyclic α","decl":"/-- A finite group of prime order is cyclic. -/\n@[to_additive \"A finite group of prime order is cyclic.\"]\ntheorem isCyclic_of_prime_card {p : ℕ} [hp : Fact p.Prime]\n    (h : Nat.card α = p) : IsCyclic α := by\n  have : Finite α := Nat.finite_of_card_ne_zero (h ▸ hp.1.ne_zero)\n  have : Nontrivial α := Finite.one_lt_card_iff_nontrivial.mp (h ▸ hp.1.one_lt)\n  obtain ⟨g, hg⟩ : ∃ g : α, g ≠ 1 := exists_ne 1\n  exact ⟨g, fun g' ↦ mem_zpowers_of_prime_card h hg⟩\n\n"}
{"name":"isAddCyclic_of_prime_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\np : Nat\nhp : Fact (Nat.Prime p)\nh : Eq (Nat.card α) p\n⊢ IsAddCyclic α","decl":"/-- A finite group of prime order is cyclic. -/\n@[to_additive \"A finite group of prime order is cyclic.\"]\ntheorem isCyclic_of_prime_card {p : ℕ} [hp : Fact p.Prime]\n    (h : Nat.card α = p) : IsCyclic α := by\n  have : Finite α := Nat.finite_of_card_ne_zero (h ▸ hp.1.ne_zero)\n  have : Nontrivial α := Finite.one_lt_card_iff_nontrivial.mp (h ▸ hp.1.one_lt)\n  obtain ⟨g, hg⟩ : ∃ g : α, g ≠ 1 := exists_ne 1\n  exact ⟨g, fun g' ↦ mem_zpowers_of_prime_card h hg⟩\n\n"}
{"name":"isAddCyclic_of_card_dvd_prime","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\np : Nat\nhp : Fact (Nat.Prime p)\nh : Dvd.dvd (Nat.card α) p\n⊢ IsAddCyclic α","decl":"/-- A finite group of order dividing a prime is cyclic. -/\n@[to_additive \"A finite group of order dividing a prime is cyclic.\"]\ntheorem isCyclic_of_card_dvd_prime {p : ℕ} [hp : Fact p.Prime]\n    (h : Nat.card α ∣ p) : IsCyclic α := by\n  rcases (Nat.dvd_prime hp.out).mp h with h | h\n  · exact @isCyclic_of_subsingleton α _ (Nat.card_eq_one_iff_unique.mp h).1\n  · exact isCyclic_of_prime_card h\n\n"}
{"name":"isCyclic_of_card_dvd_prime","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : Group α\np : Nat\nhp : Fact (Nat.Prime p)\nh : Dvd.dvd (Nat.card α) p\n⊢ IsCyclic α","decl":"/-- A finite group of order dividing a prime is cyclic. -/\n@[to_additive \"A finite group of order dividing a prime is cyclic.\"]\ntheorem isCyclic_of_card_dvd_prime {p : ℕ} [hp : Fact p.Prime]\n    (h : Nat.card α ∣ p) : IsCyclic α := by\n  rcases (Nat.dvd_prime hp.out).mp h with h | h\n  · exact @isCyclic_of_subsingleton α _ (Nat.card_eq_one_iff_unique.mp h).1\n  · exact isCyclic_of_prime_card h\n\n"}
{"name":"isCyclic_of_surjective","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\nG' : Type u_3\ninst✝³ : Group G\ninst✝² : Group G'\nF : Type u_4\nhH : IsCyclic G'\ninst✝¹ : FunLike F G' G\ninst✝ : MonoidHomClass F G' G\nf : F\nhf : Function.Surjective ⇑f\n⊢ IsCyclic G","decl":"@[to_additive]\ntheorem isCyclic_of_surjective {F : Type*} [hH : IsCyclic G']\n    [FunLike F G' G] [MonoidHomClass F G' G] (f : F) (hf : Function.Surjective f) :\n    IsCyclic G := by\n  obtain ⟨x, hx⟩ := hH\n  refine ⟨f x, fun a ↦ ?_⟩\n  obtain ⟨a, rfl⟩ := hf a\n  obtain ⟨n, rfl⟩ := hx a\n  exact ⟨n, (map_zpow _ _ _).symm⟩\n\n"}
{"name":"isAddCyclic_of_surjective","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\nG' : Type u_3\ninst✝³ : AddGroup G\ninst✝² : AddGroup G'\nF : Type u_4\nhH : IsAddCyclic G'\ninst✝¹ : FunLike F G' G\ninst✝ : AddMonoidHomClass F G' G\nf : F\nhf : Function.Surjective ⇑f\n⊢ IsAddCyclic G","decl":"@[to_additive]\ntheorem isCyclic_of_surjective {F : Type*} [hH : IsCyclic G']\n    [FunLike F G' G] [MonoidHomClass F G' G] (f : F) (hf : Function.Surjective f) :\n    IsCyclic G := by\n  obtain ⟨x, hx⟩ := hH\n  refine ⟨f x, fun a ↦ ?_⟩\n  obtain ⟨a, rfl⟩ := hf a\n  obtain ⟨n, rfl⟩ := hx a\n  exact ⟨n, (map_zpow _ _ _).symm⟩\n\n"}
{"name":"addOrderOf_eq_card_of_forall_mem_zmultiples","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ng : α\nhx : ∀ (x : α), Membership.mem (AddSubgroup.zmultiples g) x\n⊢ Eq (addOrderOf g) (Nat.card α)","decl":"@[to_additive]\ntheorem orderOf_eq_card_of_forall_mem_zpowers {g : α} (hx : ∀ x, x ∈ zpowers g) :\n    orderOf g = Nat.card α := by\n  rw [← Nat.card_zpowers, (zpowers g).eq_top_iff'.mpr hx, card_top]\n\n"}
{"name":"orderOf_eq_card_of_forall_mem_zpowers","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : Group α\ng : α\nhx : ∀ (x : α), Membership.mem (Subgroup.zpowers g) x\n⊢ Eq (orderOf g) (Nat.card α)","decl":"@[to_additive]\ntheorem orderOf_eq_card_of_forall_mem_zpowers {g : α} (hx : ∀ x, x ∈ zpowers g) :\n    orderOf g = Nat.card α := by\n  rw [← Nat.card_zpowers, (zpowers g).eq_top_iff'.mpr hx, card_top]\n\n"}
{"name":"orderOf_generator_eq_natCard","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : Group α\ng : α\nhx : ∀ (x : α), Membership.mem (Subgroup.zpowers g) x\n⊢ Eq (orderOf g) (Nat.card α)","decl":"@[deprecated (since := \"2024-11-15\")]\nalias orderOf_generator_eq_natCard := orderOf_eq_card_of_forall_mem_zpowers\n\n"}
{"name":"addOrderOf_generator_eq_natCard","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ng : α\nhx : ∀ (x : α), Membership.mem (AddSubgroup.zmultiples g) x\n⊢ Eq (addOrderOf g) (Nat.card α)","decl":"@[deprecated (since := \"2024-11-15\")]\nalias addOrderOf_generator_eq_natCard := addOrderOf_eq_card_of_forall_mem_zmultiples\n\n"}
{"name":"exists_pow_ne_one_of_isCyclic","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝ : Group G\nG_cyclic : IsCyclic G\nk : Nat\nk_pos : Ne k 0\nk_lt_card_G : LT.lt k (Nat.card G)\n⊢ Exists fun a => Ne (HPow.hPow a k) 1","decl":"@[to_additive]\ntheorem exists_pow_ne_one_of_isCyclic [G_cyclic : IsCyclic G]\n    {k : ℕ} (k_pos : k ≠ 0) (k_lt_card_G : k < Nat.card G) : ∃ a : G, a ^ k ≠ 1 := by\n  have : Finite G := Nat.finite_of_card_ne_zero (Nat.not_eq_zero_of_lt k_lt_card_G)\n  rcases G_cyclic with ⟨a, ha⟩\n  use a\n  contrapose! k_lt_card_G\n  convert orderOf_le_of_pow_eq_one k_pos.bot_lt k_lt_card_G\n  rw [← Nat.card_zpowers, eq_comm, card_eq_iff_eq_top, eq_top_iff]\n  exact fun x _ ↦ ha x\n\n"}
{"name":"exists_nsmul_ne_zero_of_isAddCyclic","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nG_cyclic : IsAddCyclic G\nk : Nat\nk_pos : Ne k 0\nk_lt_card_G : LT.lt k (Nat.card G)\n⊢ Exists fun a => Ne (HSMul.hSMul k a) 0","decl":"@[to_additive]\ntheorem exists_pow_ne_one_of_isCyclic [G_cyclic : IsCyclic G]\n    {k : ℕ} (k_pos : k ≠ 0) (k_lt_card_G : k < Nat.card G) : ∃ a : G, a ^ k ≠ 1 := by\n  have : Finite G := Nat.finite_of_card_ne_zero (Nat.not_eq_zero_of_lt k_lt_card_G)\n  rcases G_cyclic with ⟨a, ha⟩\n  use a\n  contrapose! k_lt_card_G\n  convert orderOf_le_of_pow_eq_one k_pos.bot_lt k_lt_card_G\n  rw [← Nat.card_zpowers, eq_comm, card_eq_iff_eq_top, eq_top_iff]\n  exact fun x _ ↦ ha x\n\n"}
{"name":"Infinite.addOrderOf_eq_zero_of_forall_mem_zmultiples","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : Infinite α\ng : α\nh : ∀ (x : α), Membership.mem (AddSubgroup.zmultiples g) x\n⊢ Eq (addOrderOf g) 0","decl":"@[to_additive]\ntheorem Infinite.orderOf_eq_zero_of_forall_mem_zpowers [Infinite α] {g : α}\n    (h : ∀ x, x ∈ zpowers g) : orderOf g = 0 := by\n  rw [orderOf_eq_card_of_forall_mem_zpowers h, Nat.card_eq_zero_of_infinite]\n\n"}
{"name":"Infinite.orderOf_eq_zero_of_forall_mem_zpowers","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : Infinite α\ng : α\nh : ∀ (x : α), Membership.mem (Subgroup.zpowers g) x\n⊢ Eq (orderOf g) 0","decl":"@[to_additive]\ntheorem Infinite.orderOf_eq_zero_of_forall_mem_zpowers [Infinite α] {g : α}\n    (h : ∀ x, x ∈ zpowers g) : orderOf g = 0 := by\n  rw [orderOf_eq_card_of_forall_mem_zpowers h, Nat.card_eq_zero_of_infinite]\n\n"}
{"name":"Bot.isAddCyclic","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\n⊢ IsAddCyclic (Subtype fun x => Membership.mem Bot.bot x)","decl":"@[to_additive]\ninstance Bot.isCyclic : IsCyclic (⊥ : Subgroup α) :=\n  ⟨⟨1, fun x => ⟨0, Subtype.eq <| (zpow_zero (1 : α)).trans <| Eq.symm (Subgroup.mem_bot.1 x.2)⟩⟩⟩\n\n"}
{"name":"Bot.isCyclic","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : Group α\n⊢ IsCyclic (Subtype fun x => Membership.mem Bot.bot x)","decl":"@[to_additive]\ninstance Bot.isCyclic : IsCyclic (⊥ : Subgroup α) :=\n  ⟨⟨1, fun x => ⟨0, Subtype.eq <| (zpow_zero (1 : α)).trans <| Eq.symm (Subgroup.mem_bot.1 x.2)⟩⟩⟩\n\n"}
{"name":"Subgroup.isCyclic","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : IsCyclic α\nH : Subgroup α\n⊢ IsCyclic (Subtype fun x => Membership.mem H x)","decl":"@[to_additive]\ninstance Subgroup.isCyclic [IsCyclic α] (H : Subgroup α) : IsCyclic H :=\n  haveI := Classical.propDecidable\n  let ⟨g, hg⟩ := IsCyclic.exists_generator (α := α)\n  if hx : ∃ x : α, x ∈ H ∧ x ≠ (1 : α) then\n    let ⟨x, hx₁, hx₂⟩ := hx\n    let ⟨k, hk⟩ := hg x\n    have hk : g ^ k = x := hk\n    have hex : ∃ n : ℕ, 0 < n ∧ g ^ n ∈ H :=\n      ⟨k.natAbs,\n        Nat.pos_of_ne_zero fun h => hx₂ <| by\n          rw [← hk, Int.natAbs_eq_zero.mp h, zpow_zero], by\n            cases' k with k k\n            · rw [Int.ofNat_eq_coe, Int.natAbs_cast k, ← zpow_natCast, ← Int.ofNat_eq_coe, hk]\n              exact hx₁\n            · rw [Int.natAbs_negSucc, ← Subgroup.inv_mem_iff H]; simp_all⟩\n    ⟨⟨⟨g ^ Nat.find hex, (Nat.find_spec hex).2⟩, fun ⟨x, hx⟩ =>\n        let ⟨k, hk⟩ := hg x\n        have hk : g ^ k = x := hk\n        have hk₂ : g ^ ((Nat.find hex : ℤ) * (k / Nat.find hex : ℤ)) ∈ H := by\n          rw [zpow_mul]\n          apply H.zpow_mem\n          exact mod_cast (Nat.find_spec hex).2\n        have hk₃ : g ^ (k % Nat.find hex : ℤ) ∈ H :=\n          (Subgroup.mul_mem_cancel_right H hk₂).1 <| by\n            rw [← zpow_add, Int.emod_add_ediv, hk]; exact hx\n        have hk₄ : k % Nat.find hex = (k % Nat.find hex).natAbs := by\n          rw [Int.natAbs_of_nonneg\n              (Int.emod_nonneg _ (Int.natCast_ne_zero_iff_pos.2 (Nat.find_spec hex).1))]\n        have hk₅ : g ^ (k % Nat.find hex).natAbs ∈ H := by rwa [← zpow_natCast, ← hk₄]\n        have hk₆ : (k % (Nat.find hex : ℤ)).natAbs = 0 :=\n          by_contradiction fun h =>\n            Nat.find_min hex\n              (Int.ofNat_lt.1 <| by\n                rw [← hk₄]; exact Int.emod_lt_of_pos _ (Int.natCast_pos.2 (Nat.find_spec hex).1))\n              ⟨Nat.pos_of_ne_zero h, hk₅⟩\n        ⟨k / (Nat.find hex : ℤ),\n          Subtype.ext_iff_val.2\n            (by\n              suffices g ^ ((Nat.find hex : ℤ) * (k / Nat.find hex : ℤ)) = x by simpa [zpow_mul]\n              rw [Int.mul_ediv_cancel'\n                  (Int.dvd_of_emod_eq_zero (Int.natAbs_eq_zero.mp hk₆)),\n                hk])⟩⟩⟩\n  else by\n    have : H = (⊥ : Subgroup α) :=\n      Subgroup.ext fun x =>\n        ⟨fun h => by simp at *; tauto, fun h => by rw [Subgroup.mem_bot.1 h]; exact H.one_mem⟩\n    subst this; infer_instance\n\n"}
{"name":"AddSubgroup.isAddCyclic","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : IsAddCyclic α\nH : AddSubgroup α\n⊢ IsAddCyclic (Subtype fun x => Membership.mem H x)","decl":"@[to_additive]\ninstance Subgroup.isCyclic [IsCyclic α] (H : Subgroup α) : IsCyclic H :=\n  haveI := Classical.propDecidable\n  let ⟨g, hg⟩ := IsCyclic.exists_generator (α := α)\n  if hx : ∃ x : α, x ∈ H ∧ x ≠ (1 : α) then\n    let ⟨x, hx₁, hx₂⟩ := hx\n    let ⟨k, hk⟩ := hg x\n    have hk : g ^ k = x := hk\n    have hex : ∃ n : ℕ, 0 < n ∧ g ^ n ∈ H :=\n      ⟨k.natAbs,\n        Nat.pos_of_ne_zero fun h => hx₂ <| by\n          rw [← hk, Int.natAbs_eq_zero.mp h, zpow_zero], by\n            cases' k with k k\n            · rw [Int.ofNat_eq_coe, Int.natAbs_cast k, ← zpow_natCast, ← Int.ofNat_eq_coe, hk]\n              exact hx₁\n            · rw [Int.natAbs_negSucc, ← Subgroup.inv_mem_iff H]; simp_all⟩\n    ⟨⟨⟨g ^ Nat.find hex, (Nat.find_spec hex).2⟩, fun ⟨x, hx⟩ =>\n        let ⟨k, hk⟩ := hg x\n        have hk : g ^ k = x := hk\n        have hk₂ : g ^ ((Nat.find hex : ℤ) * (k / Nat.find hex : ℤ)) ∈ H := by\n          rw [zpow_mul]\n          apply H.zpow_mem\n          exact mod_cast (Nat.find_spec hex).2\n        have hk₃ : g ^ (k % Nat.find hex : ℤ) ∈ H :=\n          (Subgroup.mul_mem_cancel_right H hk₂).1 <| by\n            rw [← zpow_add, Int.emod_add_ediv, hk]; exact hx\n        have hk₄ : k % Nat.find hex = (k % Nat.find hex).natAbs := by\n          rw [Int.natAbs_of_nonneg\n              (Int.emod_nonneg _ (Int.natCast_ne_zero_iff_pos.2 (Nat.find_spec hex).1))]\n        have hk₅ : g ^ (k % Nat.find hex).natAbs ∈ H := by rwa [← zpow_natCast, ← hk₄]\n        have hk₆ : (k % (Nat.find hex : ℤ)).natAbs = 0 :=\n          by_contradiction fun h =>\n            Nat.find_min hex\n              (Int.ofNat_lt.1 <| by\n                rw [← hk₄]; exact Int.emod_lt_of_pos _ (Int.natCast_pos.2 (Nat.find_spec hex).1))\n              ⟨Nat.pos_of_ne_zero h, hk₅⟩\n        ⟨k / (Nat.find hex : ℤ),\n          Subtype.ext_iff_val.2\n            (by\n              suffices g ^ ((Nat.find hex : ℤ) * (k / Nat.find hex : ℤ)) = x by simpa [zpow_mul]\n              rw [Int.mul_ediv_cancel'\n                  (Int.dvd_of_emod_eq_zero (Int.natAbs_eq_zero.mp hk₆)),\n                hk])⟩⟩⟩\n  else by\n    have : H = (⊥ : Subgroup α) :=\n      Subgroup.ext fun x =>\n        ⟨fun h => by simp at *; tauto, fun h => by rw [Subgroup.mem_bot.1 h]; exact H.one_mem⟩\n    subst this; infer_instance\n\n"}
{"name":"isAddCyclic_of_injective","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\nG' : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : AddGroup G'\ninst✝ : IsAddCyclic G'\nf : AddMonoidHom G G'\nhf : Function.Injective ⇑f\n⊢ IsAddCyclic G","decl":"@[to_additive]\ntheorem isCyclic_of_injective [IsCyclic G'] (f : G →* G') (hf : Function.Injective f) :\n    IsCyclic G :=\n  isCyclic_of_surjective (MonoidHom.ofInjective hf).symm (MonoidHom.ofInjective hf).symm.surjective\n\n"}
{"name":"isCyclic_of_injective","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\nG' : Type u_3\ninst✝² : Group G\ninst✝¹ : Group G'\ninst✝ : IsCyclic G'\nf : MonoidHom G G'\nhf : Function.Injective ⇑f\n⊢ IsCyclic G","decl":"@[to_additive]\ntheorem isCyclic_of_injective [IsCyclic G'] (f : G →* G') (hf : Function.Injective f) :\n    IsCyclic G :=\n  isCyclic_of_surjective (MonoidHom.ofInjective hf).symm (MonoidHom.ofInjective hf).symm.surjective\n\n"}
{"name":"Subgroup.isCyclic_of_le","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝¹ : Group G\nH H' : Subgroup G\nh : LE.le H H'\ninst✝ : IsCyclic (Subtype fun x => Membership.mem H' x)\n⊢ IsCyclic (Subtype fun x => Membership.mem H x)","decl":"@[to_additive]\nlemma Subgroup.isCyclic_of_le {H H' : Subgroup G} (h : H ≤ H') [IsCyclic H'] : IsCyclic H :=\n  isCyclic_of_injective (Subgroup.inclusion h) (Subgroup.inclusion_injective h)\n\n"}
{"name":"AddSubgroup.isAddCyclic_of_le","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝¹ : AddGroup G\nH H' : AddSubgroup G\nh : LE.le H H'\ninst✝ : IsAddCyclic (Subtype fun x => Membership.mem H' x)\n⊢ IsAddCyclic (Subtype fun x => Membership.mem H x)","decl":"@[to_additive]\nlemma Subgroup.isCyclic_of_le {H H' : Subgroup G} (h : H ≤ H') [IsCyclic H'] : IsCyclic H :=\n  isCyclic_of_injective (Subgroup.inclusion h) (Subgroup.inclusion_injective h)\n\n"}
{"name":"IsAddCyclic.card_nsmul_eq_zero_le","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝³ : AddGroup α\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\ninst✝ : IsAddCyclic α\nn : Nat\nhn0 : LT.lt 0 n\n⊢ LE.le (Finset.filter (fun a => Eq (HSMul.hSMul n a) 0) Finset.univ).card n","decl":"open scoped Classical in\n@[to_additive IsAddCyclic.card_nsmul_eq_zero_le]\ntheorem IsCyclic.card_pow_eq_one_le [DecidableEq α] [Fintype α] [IsCyclic α] {n : ℕ} (hn0 : 0 < n) :\n    #{a : α | a ^ n = 1} ≤ n :=\n  let ⟨g, hg⟩ := IsCyclic.exists_generator (α := α)\n  calc\n    #{a : α | a ^ n = 1} ≤\n        #(zpowers (g ^ (Fintype.card α / Nat.gcd n (Fintype.card α))) : Set α).toFinset :=\n      card_le_card fun x hx =>\n        let ⟨m, hm⟩ := show x ∈ Submonoid.powers g from mem_powers_iff_mem_zpowers.2 <| hg x\n        Set.mem_toFinset.2\n          ⟨(m / (Fintype.card α / Nat.gcd n (Fintype.card α)) : ℕ), by\n            dsimp at hm\n            have hgmn : g ^ (m * Nat.gcd n (Fintype.card α)) = 1 := by\n              rw [pow_mul, hm, ← pow_gcd_card_eq_one_iff]; exact (mem_filter.1 hx).2\n            dsimp only\n            rw [zpow_natCast, ← pow_mul, Nat.mul_div_cancel_left', hm]\n            refine Nat.dvd_of_mul_dvd_mul_right (gcd_pos_of_pos_left (Fintype.card α) hn0) ?_\n            conv_lhs =>\n              rw [Nat.div_mul_cancel (Nat.gcd_dvd_right _ _), ← Nat.card_eq_fintype_card,\n                ← orderOf_eq_card_of_forall_mem_zpowers hg]\n            exact orderOf_dvd_of_pow_eq_one hgmn⟩\n    _ ≤ n := by\n      let ⟨m, hm⟩ := Nat.gcd_dvd_right n (Fintype.card α)\n      have hm0 : 0 < m :=\n        Nat.pos_of_ne_zero fun hm0 => by\n          rw [hm0, mul_zero, Fintype.card_eq_zero_iff] at hm\n          exact hm.elim' 1\n      simp only [Set.toFinset_card, SetLike.coe_sort_coe]\n      rw [Fintype.card_zpowers, orderOf_pow g, orderOf_eq_card_of_forall_mem_zpowers hg,\n        Nat.card_eq_fintype_card]\n      nth_rw 2 [hm]; nth_rw 3 [hm]\n      rw [Nat.mul_div_cancel_left _ (gcd_pos_of_pos_left _ hn0), gcd_mul_left_left, hm,\n        Nat.mul_div_cancel _ hm0]\n      exact le_of_dvd hn0 (Nat.gcd_dvd_left _ _)\n\n"}
{"name":"IsCyclic.card_pow_eq_one_le","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝³ : Group α\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\ninst✝ : IsCyclic α\nn : Nat\nhn0 : LT.lt 0 n\n⊢ LE.le (Finset.filter (fun a => Eq (HPow.hPow a n) 1) Finset.univ).card n","decl":"open scoped Classical in\n@[to_additive IsAddCyclic.card_nsmul_eq_zero_le]\ntheorem IsCyclic.card_pow_eq_one_le [DecidableEq α] [Fintype α] [IsCyclic α] {n : ℕ} (hn0 : 0 < n) :\n    #{a : α | a ^ n = 1} ≤ n :=\n  let ⟨g, hg⟩ := IsCyclic.exists_generator (α := α)\n  calc\n    #{a : α | a ^ n = 1} ≤\n        #(zpowers (g ^ (Fintype.card α / Nat.gcd n (Fintype.card α))) : Set α).toFinset :=\n      card_le_card fun x hx =>\n        let ⟨m, hm⟩ := show x ∈ Submonoid.powers g from mem_powers_iff_mem_zpowers.2 <| hg x\n        Set.mem_toFinset.2\n          ⟨(m / (Fintype.card α / Nat.gcd n (Fintype.card α)) : ℕ), by\n            dsimp at hm\n            have hgmn : g ^ (m * Nat.gcd n (Fintype.card α)) = 1 := by\n              rw [pow_mul, hm, ← pow_gcd_card_eq_one_iff]; exact (mem_filter.1 hx).2\n            dsimp only\n            rw [zpow_natCast, ← pow_mul, Nat.mul_div_cancel_left', hm]\n            refine Nat.dvd_of_mul_dvd_mul_right (gcd_pos_of_pos_left (Fintype.card α) hn0) ?_\n            conv_lhs =>\n              rw [Nat.div_mul_cancel (Nat.gcd_dvd_right _ _), ← Nat.card_eq_fintype_card,\n                ← orderOf_eq_card_of_forall_mem_zpowers hg]\n            exact orderOf_dvd_of_pow_eq_one hgmn⟩\n    _ ≤ n := by\n      let ⟨m, hm⟩ := Nat.gcd_dvd_right n (Fintype.card α)\n      have hm0 : 0 < m :=\n        Nat.pos_of_ne_zero fun hm0 => by\n          rw [hm0, mul_zero, Fintype.card_eq_zero_iff] at hm\n          exact hm.elim' 1\n      simp only [Set.toFinset_card, SetLike.coe_sort_coe]\n      rw [Fintype.card_zpowers, orderOf_pow g, orderOf_eq_card_of_forall_mem_zpowers hg,\n        Nat.card_eq_fintype_card]\n      nth_rw 2 [hm]; nth_rw 3 [hm]\n      rw [Nat.mul_div_cancel_left _ (gcd_pos_of_pos_left _ hn0), gcd_mul_left_left, hm,\n        Nat.mul_div_cancel _ hm0]\n      exact le_of_dvd hn0 (Nat.gcd_dvd_left _ _)\n\n"}
{"name":"IsAddCyclic.exists_addMonoid_generator","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝² : AddGroup α\ninst✝¹ : Finite α\ninst✝ : IsAddCyclic α\n⊢ Exists fun x => ∀ (y : α), Membership.mem (AddSubmonoid.multiples x) y","decl":"@[to_additive]\ntheorem IsCyclic.exists_monoid_generator [Finite α] [IsCyclic α] :\n    ∃ x : α, ∀ y : α, y ∈ Submonoid.powers x := by\n  simp_rw [mem_powers_iff_mem_zpowers]\n  exact IsCyclic.exists_generator\n\n"}
{"name":"IsCyclic.exists_monoid_generator","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝² : Group α\ninst✝¹ : Finite α\ninst✝ : IsCyclic α\n⊢ Exists fun x => ∀ (y : α), Membership.mem (Submonoid.powers x) y","decl":"@[to_additive]\ntheorem IsCyclic.exists_monoid_generator [Finite α] [IsCyclic α] :\n    ∃ x : α, ∀ y : α, y ∈ Submonoid.powers x := by\n  simp_rw [mem_powers_iff_mem_zpowers]\n  exact IsCyclic.exists_generator\n\n"}
{"name":"IsAddCyclic.exists_ofOrder_eq_natCard","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\nh : IsAddCyclic α\n⊢ Exists fun g => Eq (addOrderOf g) (Nat.card α)","decl":"@[to_additive]\nlemma IsCyclic.exists_ofOrder_eq_natCard [h : IsCyclic α] : ∃ g : α, orderOf g = Nat.card α := by\n  obtain ⟨g, hg⟩ := h.exists_generator\n  use g\n  rw [← card_zpowers g, (eq_top_iff' (zpowers g)).mpr hg]\n  exact Nat.card_congr (Equiv.Set.univ α)\n\n"}
{"name":"IsCyclic.exists_ofOrder_eq_natCard","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : Group α\nh : IsCyclic α\n⊢ Exists fun g => Eq (orderOf g) (Nat.card α)","decl":"@[to_additive]\nlemma IsCyclic.exists_ofOrder_eq_natCard [h : IsCyclic α] : ∃ g : α, orderOf g = Nat.card α := by\n  obtain ⟨g, hg⟩ := h.exists_generator\n  use g\n  rw [← card_zpowers g, (eq_top_iff' (zpowers g)).mpr hg]\n  exact Nat.card_congr (Equiv.Set.univ α)\n\n"}
{"name":"MulDistribMulAction.toMonoidHomZModOfIsCyclic_apply","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝³ : Group G\nM : Type u_4\ninst✝² : Monoid M\ninst✝¹ : IsCyclic G\ninst✝ : MulDistribMulAction M G\nn : Nat\nhn : Eq (Nat.card G) n\nm : M\ng : G\nk : Int\nh : Eq ((MulDistribMulAction.toMonoidHomZModOfIsCyclic G M hn) m) ↑k\n⊢ Eq (HSMul.hSMul m g) (HPow.hPow g k)","decl":"theorem MulDistribMulAction.toMonoidHomZModOfIsCyclic_apply {M : Type*} [Monoid M] [IsCyclic G]\n    [MulDistribMulAction M G] {n : ℕ} (hn : Nat.card G = n) (m : M) (g : G) (k : ℤ)\n    (h : toMonoidHomZModOfIsCyclic G M hn m = k) : m • g = g ^ k := by\n  rw [← MulDistribMulAction.toMonoidHom_apply,\n    (MulDistribMulAction.toMonoidHom G m).map_cyclic.choose_spec g, zpow_eq_zpow_iff_modEq]\n  apply Int.ModEq.of_dvd (Int.natCast_dvd_natCast.mpr (orderOf_dvd_natCard g))\n  rwa [hn, ← ZMod.intCast_eq_intCast_iff]\n\n"}
{"name":"IsAddCyclic.unique_zsmul_zmod","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\na : α\ninst✝¹ : AddGroup α\ninst✝ : Fintype α\nha : ∀ (x : α), Membership.mem (AddSubgroup.zmultiples a) x\nx : α\n⊢ ExistsUnique fun n => Eq x (HSMul.hSMul n.val a)","decl":"@[to_additive]\ntheorem IsCyclic.unique_zpow_zmod (ha : ∀ x : α, x ∈ zpowers a) (x : α) :\n    ∃! n : ZMod (Fintype.card α), x = a ^ n.val := by\n  obtain ⟨n, rfl⟩ := ha x\n  refine ⟨n, (?_ : a ^ n = _), fun y (hy : a ^ n = _) ↦ ?_⟩\n  · rw [← zpow_natCast, zpow_eq_zpow_iff_modEq, orderOf_eq_card_of_forall_mem_zpowers ha,\n      Int.modEq_comm, Int.modEq_iff_add_fac, Nat.card_eq_fintype_card, ← ZMod.intCast_eq_iff]\n  · rw [← zpow_natCast, zpow_eq_zpow_iff_modEq, orderOf_eq_card_of_forall_mem_zpowers ha,\n      Nat.card_eq_fintype_card, ← ZMod.intCast_eq_intCast_iff] at hy\n    simp [hy]\n\n"}
{"name":"IsCyclic.unique_zpow_zmod","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\na : α\ninst✝¹ : Group α\ninst✝ : Fintype α\nha : ∀ (x : α), Membership.mem (Subgroup.zpowers a) x\nx : α\n⊢ ExistsUnique fun n => Eq x (HPow.hPow a n.val)","decl":"@[to_additive]\ntheorem IsCyclic.unique_zpow_zmod (ha : ∀ x : α, x ∈ zpowers a) (x : α) :\n    ∃! n : ZMod (Fintype.card α), x = a ^ n.val := by\n  obtain ⟨n, rfl⟩ := ha x\n  refine ⟨n, (?_ : a ^ n = _), fun y (hy : a ^ n = _) ↦ ?_⟩\n  · rw [← zpow_natCast, zpow_eq_zpow_iff_modEq, orderOf_eq_card_of_forall_mem_zpowers ha,\n      Int.modEq_comm, Int.modEq_iff_add_fac, Nat.card_eq_fintype_card, ← ZMod.intCast_eq_iff]\n  · rw [← zpow_natCast, zpow_eq_zpow_iff_modEq, orderOf_eq_card_of_forall_mem_zpowers ha,\n      Nat.card_eq_fintype_card, ← ZMod.intCast_eq_intCast_iff] at hy\n    simp [hy]\n\n"}
{"name":"IsAddCyclic.image_range_addOrderOf","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\na : α\ninst✝² : AddGroup α\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nha : ∀ (x : α), Membership.mem (AddSubgroup.zmultiples a) x\n⊢ Eq (Finset.image (fun i => HSMul.hSMul i a) (Finset.range (addOrderOf a))) Finset.univ","decl":"@[to_additive]\ntheorem IsCyclic.image_range_orderOf (ha : ∀ x : α, x ∈ zpowers a) :\n    Finset.image (fun i => a ^ i) (range (orderOf a)) = univ := by\n  simp_rw [← SetLike.mem_coe] at ha\n  simp only [_root_.image_range_orderOf, Set.eq_univ_iff_forall.mpr ha, Set.toFinset_univ]\n\n"}
{"name":"IsCyclic.image_range_orderOf","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\na : α\ninst✝² : Group α\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nha : ∀ (x : α), Membership.mem (Subgroup.zpowers a) x\n⊢ Eq (Finset.image (fun i => HPow.hPow a i) (Finset.range (orderOf a))) Finset.univ","decl":"@[to_additive]\ntheorem IsCyclic.image_range_orderOf (ha : ∀ x : α, x ∈ zpowers a) :\n    Finset.image (fun i => a ^ i) (range (orderOf a)) = univ := by\n  simp_rw [← SetLike.mem_coe] at ha\n  simp only [_root_.image_range_orderOf, Set.eq_univ_iff_forall.mpr ha, Set.toFinset_univ]\n\n"}
{"name":"IsCyclic.image_range_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\na : α\ninst✝² : Group α\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nha : ∀ (x : α), Membership.mem (Subgroup.zpowers a) x\n⊢ Eq (Finset.image (fun i => HPow.hPow a i) (Finset.range (Nat.card α))) Finset.univ","decl":"@[to_additive]\ntheorem IsCyclic.image_range_card (ha : ∀ x : α, x ∈ zpowers a) :\n    Finset.image (fun i => a ^ i) (range (Nat.card α)) = univ := by\n  rw [← orderOf_eq_card_of_forall_mem_zpowers ha, IsCyclic.image_range_orderOf ha]\n\n"}
{"name":"IsAddCyclic.image_range_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\na : α\ninst✝² : AddGroup α\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nha : ∀ (x : α), Membership.mem (AddSubgroup.zmultiples a) x\n⊢ Eq (Finset.image (fun i => HSMul.hSMul i a) (Finset.range (Nat.card α))) Finset.univ","decl":"@[to_additive]\ntheorem IsCyclic.image_range_card (ha : ∀ x : α, x ∈ zpowers a) :\n    Finset.image (fun i => a ^ i) (range (Nat.card α)) = univ := by\n  rw [← orderOf_eq_card_of_forall_mem_zpowers ha, IsCyclic.image_range_orderOf ha]\n\n"}
{"name":"IsAddCyclic.ext","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝² : AddGroup G\ninst✝¹ : Finite G\ninst✝ : IsAddCyclic G\nd : Nat\na b : ZMod d\nhGcard : Eq (Nat.card G) d\nh : ∀ (t : G), Eq (HSMul.hSMul a.val t) (HSMul.hSMul b.val t)\n⊢ Eq a b","decl":"@[to_additive]\nlemma IsCyclic.ext [Finite G] [IsCyclic G] {d : ℕ} {a b : ZMod d}\n    (hGcard : Nat.card G = d) (h : ∀ t : G, t ^ a.val = t ^ b.val) : a = b := by\n  have : NeZero (Nat.card G) := ⟨Nat.card_pos.ne'⟩\n  obtain ⟨g, hg⟩ := IsCyclic.exists_generator (α := G)\n  specialize h g\n  subst hGcard\n  rw [pow_eq_pow_iff_modEq, orderOf_eq_card_of_forall_mem_zpowers hg,\n    ← ZMod.natCast_eq_natCast_iff] at h\n  simpa [ZMod.natCast_val, ZMod.cast_id'] using h\n\n"}
{"name":"IsCyclic.ext","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝² : Group G\ninst✝¹ : Finite G\ninst✝ : IsCyclic G\nd : Nat\na b : ZMod d\nhGcard : Eq (Nat.card G) d\nh : ∀ (t : G), Eq (HPow.hPow t a.val) (HPow.hPow t b.val)\n⊢ Eq a b","decl":"@[to_additive]\nlemma IsCyclic.ext [Finite G] [IsCyclic G] {d : ℕ} {a b : ZMod d}\n    (hGcard : Nat.card G = d) (h : ∀ t : G, t ^ a.val = t ^ b.val) : a = b := by\n  have : NeZero (Nat.card G) := ⟨Nat.card_pos.ne'⟩\n  obtain ⟨g, hg⟩ := IsCyclic.exists_generator (α := G)\n  specialize h g\n  subst hGcard\n  rw [pow_eq_pow_iff_modEq, orderOf_eq_card_of_forall_mem_zpowers hg,\n    ← ZMod.natCast_eq_natCast_iff] at h\n  simpa [ZMod.natCast_val, ZMod.cast_id'] using h\n\n"}
{"name":"card_addOrderOf_eq_totient_aux₂","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝² : AddGroup α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nhn : ∀ (n : Nat), LT.lt 0 n → LE.le (Finset.filter (fun a => Eq (HSMul.hSMul n a) 0) Finset.univ).card n\nd : Nat\nhd : Dvd.dvd d (Fintype.card α)\n⊢ Eq (Finset.filter (fun a => Eq (addOrderOf a) d) Finset.univ).card d.totient","decl":"@[to_additive]\ntheorem card_orderOf_eq_totient_aux₂ {d : ℕ} (hd : d ∣ Fintype.card α) :\n    #{a : α | orderOf a = d} = φ d := by\n  let c := Fintype.card α\n  have hc0 : 0 < c := Fintype.card_pos_iff.2 ⟨1⟩\n  apply card_orderOf_eq_totient_aux₁ hn hd\n  by_contra h0\n  -- Must qualify `Finset.card_eq_zero` because of https://github.com/leanprover/lean4/issues/2849\n  simp_rw [not_lt, Nat.le_zero, Finset.card_eq_zero] at h0\n  apply lt_irrefl c\n  calc\n    c = ∑ m ∈ c.divisors, #{a : α | orderOf a = m} := by\n      simp only [sum_card_orderOf_eq_card_pow_eq_one hc0.ne']\n      apply congr_arg card\n      simp [c]\n    _ = ∑ m ∈ c.divisors.erase d, #{a : α | orderOf a = m} := by\n      rw [eq_comm]\n      refine sum_subset (erase_subset _ _) fun m hm₁ hm₂ => ?_\n      have : m = d := by\n        contrapose! hm₂\n        exact mem_erase_of_ne_of_mem hm₂ hm₁\n      simp [this, h0]\n    _ ≤ ∑ m ∈ c.divisors.erase d, φ m := by\n      refine sum_le_sum fun m hm => ?_\n      have hmc : m ∣ c := by\n        simp only [mem_erase, mem_divisors] at hm\n        tauto\n      obtain h1 | h1 := (#{a : α | orderOf a = m}).eq_zero_or_pos\n      · simp [h1]\n      · simp [card_orderOf_eq_totient_aux₁ hn hmc h1]\n    _ < ∑ m ∈ c.divisors, φ m :=\n      sum_erase_lt_of_pos (mem_divisors.2 ⟨hd, hc0.ne'⟩) (totient_pos.2 (pos_of_dvd_of_pos hd hc0))\n    _ = c := sum_totient _\n\n"}
{"name":"card_orderOf_eq_totient_aux₂","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝² : Group α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nhn : ∀ (n : Nat), LT.lt 0 n → LE.le (Finset.filter (fun a => Eq (HPow.hPow a n) 1) Finset.univ).card n\nd : Nat\nhd : Dvd.dvd d (Fintype.card α)\n⊢ Eq (Finset.filter (fun a => Eq (orderOf a) d) Finset.univ).card d.totient","decl":"@[to_additive]\ntheorem card_orderOf_eq_totient_aux₂ {d : ℕ} (hd : d ∣ Fintype.card α) :\n    #{a : α | orderOf a = d} = φ d := by\n  let c := Fintype.card α\n  have hc0 : 0 < c := Fintype.card_pos_iff.2 ⟨1⟩\n  apply card_orderOf_eq_totient_aux₁ hn hd\n  by_contra h0\n  -- Must qualify `Finset.card_eq_zero` because of https://github.com/leanprover/lean4/issues/2849\n  simp_rw [not_lt, Nat.le_zero, Finset.card_eq_zero] at h0\n  apply lt_irrefl c\n  calc\n    c = ∑ m ∈ c.divisors, #{a : α | orderOf a = m} := by\n      simp only [sum_card_orderOf_eq_card_pow_eq_one hc0.ne']\n      apply congr_arg card\n      simp [c]\n    _ = ∑ m ∈ c.divisors.erase d, #{a : α | orderOf a = m} := by\n      rw [eq_comm]\n      refine sum_subset (erase_subset _ _) fun m hm₁ hm₂ => ?_\n      have : m = d := by\n        contrapose! hm₂\n        exact mem_erase_of_ne_of_mem hm₂ hm₁\n      simp [this, h0]\n    _ ≤ ∑ m ∈ c.divisors.erase d, φ m := by\n      refine sum_le_sum fun m hm => ?_\n      have hmc : m ∣ c := by\n        simp only [mem_erase, mem_divisors] at hm\n        tauto\n      obtain h1 | h1 := (#{a : α | orderOf a = m}).eq_zero_or_pos\n      · simp [h1]\n      · simp [card_orderOf_eq_totient_aux₁ hn hmc h1]\n    _ < ∑ m ∈ c.divisors, φ m :=\n      sum_erase_lt_of_pos (mem_divisors.2 ⟨hd, hc0.ne'⟩) (totient_pos.2 (pos_of_dvd_of_pos hd hc0))\n    _ = c := sum_totient _\n\n"}
{"name":"isAddCyclic_of_card_nsmul_eq_zero_le","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝² : AddGroup α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nhn : ∀ (n : Nat), LT.lt 0 n → LE.le (Finset.filter (fun a => Eq (HSMul.hSMul n a) 0) Finset.univ).card n\n⊢ IsAddCyclic α","decl":"@[to_additive isAddCyclic_of_card_nsmul_eq_zero_le, stacks 09HX \"This theorem is stronger than \\\n09HX. It removes the abelian condition, and requires only `≤` instead of `=`.\"]\ntheorem isCyclic_of_card_pow_eq_one_le : IsCyclic α :=\n  have : Finset.Nonempty {a : α | orderOf a = Nat.card α} :=\n    card_pos.1 <| by\n      rw [Nat.card_eq_fintype_card, card_orderOf_eq_totient_aux₂ hn dvd_rfl, totient_pos]\n      apply Fintype.card_pos\n  let ⟨x, hx⟩ := this\n  isCyclic_of_orderOf_eq_card x (Finset.mem_filter.1 hx).2\n\n"}
{"name":"isCyclic_of_card_pow_eq_one_le","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝² : Group α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nhn : ∀ (n : Nat), LT.lt 0 n → LE.le (Finset.filter (fun a => Eq (HPow.hPow a n) 1) Finset.univ).card n\n⊢ IsCyclic α","decl":"@[to_additive isAddCyclic_of_card_nsmul_eq_zero_le, stacks 09HX \"This theorem is stronger than \\\n09HX. It removes the abelian condition, and requires only `≤` instead of `=`.\"]\ntheorem isCyclic_of_card_pow_eq_one_le : IsCyclic α :=\n  have : Finset.Nonempty {a : α | orderOf a = Nat.card α} :=\n    card_pos.1 <| by\n      rw [Nat.card_eq_fintype_card, card_orderOf_eq_totient_aux₂ hn dvd_rfl, totient_pos]\n      apply Fintype.card_pos\n  let ⟨x, hx⟩ := this\n  isCyclic_of_orderOf_eq_card x (Finset.mem_filter.1 hx).2\n\n"}
{"name":"IsAddCyclic.card_addOrderOf_eq_totient","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝² : AddGroup α\ninst✝¹ : IsAddCyclic α\ninst✝ : Fintype α\nd : Nat\nhd : Dvd.dvd d (Fintype.card α)\n⊢ Eq (Finset.filter (fun a => Eq (addOrderOf a) d) Finset.univ).card d.totient","decl":"@[to_additive]\nlemma IsCyclic.card_orderOf_eq_totient [IsCyclic α] [Fintype α] {d : ℕ} (hd : d ∣ Fintype.card α) :\n    #{a : α | orderOf a = d} = totient d := by\n  classical apply card_orderOf_eq_totient_aux₂ (fun n => IsCyclic.card_pow_eq_one_le) hd\n\n"}
{"name":"IsCyclic.card_orderOf_eq_totient","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝² : Group α\ninst✝¹ : IsCyclic α\ninst✝ : Fintype α\nd : Nat\nhd : Dvd.dvd d (Fintype.card α)\n⊢ Eq (Finset.filter (fun a => Eq (orderOf a) d) Finset.univ).card d.totient","decl":"@[to_additive]\nlemma IsCyclic.card_orderOf_eq_totient [IsCyclic α] [Fintype α] {d : ℕ} (hd : d ∣ Fintype.card α) :\n    #{a : α | orderOf a = d} = totient d := by\n  classical apply card_orderOf_eq_totient_aux₂ (fun n => IsCyclic.card_pow_eq_one_le) hd\n\n"}
{"name":"isSimpleAddGroup_of_prime_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\np : Nat\nhp : Fact (Nat.Prime p)\nh : Eq (Nat.card α) p\n⊢ IsSimpleAddGroup α","decl":"/-- A finite group of prime order is simple. -/\n@[to_additive \"A finite group of prime order is simple.\"]\ntheorem isSimpleGroup_of_prime_card {p : ℕ} [hp : Fact p.Prime]\n    (h : Nat.card α = p) : IsSimpleGroup α := by\n  subst h\n  have : Finite α := Nat.finite_of_card_ne_zero hp.1.ne_zero\n  have : Nontrivial α := Finite.one_lt_card_iff_nontrivial.mp hp.1.one_lt\n  exact ⟨fun H _ => H.eq_bot_or_eq_top_of_prime_card⟩\n\n"}
{"name":"isSimpleGroup_of_prime_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : Group α\np : Nat\nhp : Fact (Nat.Prime p)\nh : Eq (Nat.card α) p\n⊢ IsSimpleGroup α","decl":"/-- A finite group of prime order is simple. -/\n@[to_additive \"A finite group of prime order is simple.\"]\ntheorem isSimpleGroup_of_prime_card {p : ℕ} [hp : Fact p.Prime]\n    (h : Nat.card α = p) : IsSimpleGroup α := by\n  subst h\n  have : Finite α := Nat.finite_of_card_ne_zero hp.1.ne_zero\n  have : Nontrivial α := Finite.one_lt_card_iff_nontrivial.mp hp.1.one_lt\n  exact ⟨fun H _ => H.eq_bot_or_eq_top_of_prime_card⟩\n\n"}
{"name":"commutative_of_addCyclic_center_quotient","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\nG' : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : AddGroup G'\ninst✝ : IsAddCyclic G'\nf : AddMonoidHom G G'\nhf : LE.le f.ker (AddSubgroup.center G)\na b : G\n⊢ Eq (HAdd.hAdd a b) (HAdd.hAdd b a)","decl":"/-- A group is commutative if the quotient by the center is cyclic.\n  Also see `commGroupOfCyclicCenterQuotient` for the `CommGroup` instance. -/\n@[to_additive\n      \"A group is commutative if the quotient by the center is cyclic.\n      Also see `addCommGroupOfCyclicCenterQuotient` for the `AddCommGroup` instance.\"]\ntheorem commutative_of_cyclic_center_quotient [IsCyclic G'] (f : G →* G') (hf : f.ker ≤ center G)\n    (a b : G) : a * b = b * a :=\n  let ⟨⟨x, y, (hxy : f y = x)⟩, (hx : ∀ a : f.range, a ∈ zpowers _)⟩ :=\n    IsCyclic.exists_generator (α := f.range)\n  let ⟨m, hm⟩ := hx ⟨f a, a, rfl⟩\n  let ⟨n, hn⟩ := hx ⟨f b, b, rfl⟩\n  have hm : x ^ m = f a := by simpa [Subtype.ext_iff] using hm\n  have hn : x ^ n = f b := by simpa [Subtype.ext_iff] using hn\n  have ha : y ^ (-m) * a ∈ center G :=\n    hf (by rw [f.mem_ker, f.map_mul, f.map_zpow, hxy, zpow_neg x m, hm, inv_mul_cancel])\n  have hb : y ^ (-n) * b ∈ center G :=\n    hf (by rw [f.mem_ker, f.map_mul, f.map_zpow, hxy, zpow_neg x n, hn, inv_mul_cancel])\n  calc\n    a * b = y ^ m * (y ^ (-m) * a * y ^ n) * (y ^ (-n) * b) := by simp [mul_assoc]\n    _ = y ^ m * (y ^ n * (y ^ (-m) * a)) * (y ^ (-n) * b) := by rw [mem_center_iff.1 ha]\n    _ = y ^ m * y ^ n * y ^ (-m) * (a * (y ^ (-n) * b)) := by simp [mul_assoc]\n    _ = y ^ m * y ^ n * y ^ (-m) * (y ^ (-n) * b * a) := by rw [mem_center_iff.1 hb]\n    _ = b * a := by group\n\n"}
{"name":"commutative_of_cyclic_center_quotient","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\nG' : Type u_3\ninst✝² : Group G\ninst✝¹ : Group G'\ninst✝ : IsCyclic G'\nf : MonoidHom G G'\nhf : LE.le f.ker (Subgroup.center G)\na b : G\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"/-- A group is commutative if the quotient by the center is cyclic.\n  Also see `commGroupOfCyclicCenterQuotient` for the `CommGroup` instance. -/\n@[to_additive\n      \"A group is commutative if the quotient by the center is cyclic.\n      Also see `addCommGroupOfCyclicCenterQuotient` for the `AddCommGroup` instance.\"]\ntheorem commutative_of_cyclic_center_quotient [IsCyclic G'] (f : G →* G') (hf : f.ker ≤ center G)\n    (a b : G) : a * b = b * a :=\n  let ⟨⟨x, y, (hxy : f y = x)⟩, (hx : ∀ a : f.range, a ∈ zpowers _)⟩ :=\n    IsCyclic.exists_generator (α := f.range)\n  let ⟨m, hm⟩ := hx ⟨f a, a, rfl⟩\n  let ⟨n, hn⟩ := hx ⟨f b, b, rfl⟩\n  have hm : x ^ m = f a := by simpa [Subtype.ext_iff] using hm\n  have hn : x ^ n = f b := by simpa [Subtype.ext_iff] using hn\n  have ha : y ^ (-m) * a ∈ center G :=\n    hf (by rw [f.mem_ker, f.map_mul, f.map_zpow, hxy, zpow_neg x m, hm, inv_mul_cancel])\n  have hb : y ^ (-n) * b ∈ center G :=\n    hf (by rw [f.mem_ker, f.map_mul, f.map_zpow, hxy, zpow_neg x n, hn, inv_mul_cancel])\n  calc\n    a * b = y ^ m * (y ^ (-m) * a * y ^ n) * (y ^ (-n) * b) := by simp [mul_assoc]\n    _ = y ^ m * (y ^ n * (y ^ (-m) * a)) * (y ^ (-n) * b) := by rw [mem_center_iff.1 ha]\n    _ = y ^ m * y ^ n * y ^ (-m) * (a * (y ^ (-n) * b)) := by simp [mul_assoc]\n    _ = y ^ m * y ^ n * y ^ (-m) * (y ^ (-n) * b * a) := by rw [mem_center_iff.1 hb]\n    _ = b * a := by group\n\n"}
{"name":"IsSimpleAddGroup.isAddCyclic","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\n⊢ IsAddCyclic α","decl":"@[to_additive]\ninstance (priority := 100) isCyclic : IsCyclic α := by\n  nontriviality α\n  obtain ⟨g, hg⟩ := exists_ne (1 : α)\n  have : Subgroup.zpowers g = ⊤ :=\n    (eq_bot_or_eq_top (Subgroup.zpowers g)).resolve_left (Subgroup.zpowers_ne_bot.2 hg)\n  exact ⟨⟨g, (Subgroup.eq_top_iff' _).1 this⟩⟩\n\n"}
{"name":"IsSimpleGroup.isCyclic","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : CommGroup α\n⊢ IsCyclic α","decl":"@[to_additive]\ninstance (priority := 100) isCyclic : IsCyclic α := by\n  nontriviality α\n  obtain ⟨g, hg⟩ := exists_ne (1 : α)\n  have : Subgroup.zpowers g = ⊤ :=\n    (eq_bot_or_eq_top (Subgroup.zpowers g)).resolve_left (Subgroup.zpowers_ne_bot.2 hg)\n  exact ⟨⟨g, (Subgroup.eq_top_iff' _).1 this⟩⟩\n\n"}
{"name":"IsSimpleAddGroup.prime_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝² : AddCommGroup α\ninst✝¹ : IsSimpleAddGroup α\ninst✝ : Finite α\n⊢ Nat.Prime (Nat.card α)","decl":"@[to_additive]\ntheorem prime_card [Finite α] : (Nat.card α).Prime := by\n  have h0 : 0 < Nat.card α := Nat.card_pos\n  obtain ⟨g, hg⟩ := IsCyclic.exists_generator (α := α)\n  rw [Nat.prime_def]\n  refine ⟨Finite.one_lt_card_iff_nontrivial.2 inferInstance, fun n hn => ?_⟩\n  refine (IsSimpleOrder.eq_bot_or_eq_top (Subgroup.zpowers (g ^ n))).symm.imp ?_ ?_\n  · intro h\n    have hgo := orderOf_pow (n := n) g\n    rw [orderOf_eq_card_of_forall_mem_zpowers hg, Nat.gcd_eq_right_iff_dvd.1 hn,\n      orderOf_eq_card_of_forall_mem_zpowers, eq_comm,\n      Nat.div_eq_iff_eq_mul_left (Nat.pos_of_dvd_of_pos hn h0) hn] at hgo\n    · exact (mul_left_cancel₀ (ne_of_gt h0) ((mul_one (Nat.card α)).trans hgo)).symm\n    · intro x\n      rw [h]\n      exact Subgroup.mem_top _\n  · intro h\n    apply le_antisymm (Nat.le_of_dvd h0 hn)\n    rw [← orderOf_eq_card_of_forall_mem_zpowers hg]\n    apply orderOf_le_of_pow_eq_one (Nat.pos_of_dvd_of_pos hn h0)\n    rw [← Subgroup.mem_bot, ← h]\n    exact Subgroup.mem_zpowers _\n\n"}
{"name":"IsSimpleGroup.prime_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝² : CommGroup α\ninst✝¹ : IsSimpleGroup α\ninst✝ : Finite α\n⊢ Nat.Prime (Nat.card α)","decl":"@[to_additive]\ntheorem prime_card [Finite α] : (Nat.card α).Prime := by\n  have h0 : 0 < Nat.card α := Nat.card_pos\n  obtain ⟨g, hg⟩ := IsCyclic.exists_generator (α := α)\n  rw [Nat.prime_def]\n  refine ⟨Finite.one_lt_card_iff_nontrivial.2 inferInstance, fun n hn => ?_⟩\n  refine (IsSimpleOrder.eq_bot_or_eq_top (Subgroup.zpowers (g ^ n))).symm.imp ?_ ?_\n  · intro h\n    have hgo := orderOf_pow (n := n) g\n    rw [orderOf_eq_card_of_forall_mem_zpowers hg, Nat.gcd_eq_right_iff_dvd.1 hn,\n      orderOf_eq_card_of_forall_mem_zpowers, eq_comm,\n      Nat.div_eq_iff_eq_mul_left (Nat.pos_of_dvd_of_pos hn h0) hn] at hgo\n    · exact (mul_left_cancel₀ (ne_of_gt h0) ((mul_one (Nat.card α)).trans hgo)).symm\n    · intro x\n      rw [h]\n      exact Subgroup.mem_top _\n  · intro h\n    apply le_antisymm (Nat.le_of_dvd h0 hn)\n    rw [← orderOf_eq_card_of_forall_mem_zpowers hg]\n    apply orderOf_le_of_pow_eq_one (Nat.pos_of_dvd_of_pos hn h0)\n    rw [← Subgroup.mem_bot, ← h]\n    exact Subgroup.mem_zpowers _\n\n"}
{"name":"AddCommGroup.is_simple_iff_isAddCyclic_and_prime_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : Finite α\ninst✝ : AddCommGroup α\n⊢ Iff (IsSimpleAddGroup α) (And (IsAddCyclic α) (Nat.Prime (Nat.card α)))","decl":"@[to_additive]\ntheorem CommGroup.is_simple_iff_isCyclic_and_prime_card [Finite α] [CommGroup α] :\n    IsSimpleGroup α ↔ IsCyclic α ∧ (Nat.card α).Prime := by\n  constructor\n  · intro h\n    exact ⟨IsSimpleGroup.isCyclic, IsSimpleGroup.prime_card⟩\n  · rintro ⟨_, hp⟩\n    haveI : Fact (Nat.card α).Prime := ⟨hp⟩\n    exact isSimpleGroup_of_prime_card rfl\n\n"}
{"name":"CommGroup.is_simple_iff_isCyclic_and_prime_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : Finite α\ninst✝ : CommGroup α\n⊢ Iff (IsSimpleGroup α) (And (IsCyclic α) (Nat.Prime (Nat.card α)))","decl":"@[to_additive]\ntheorem CommGroup.is_simple_iff_isCyclic_and_prime_card [Finite α] [CommGroup α] :\n    IsSimpleGroup α ↔ IsCyclic α ∧ (Nat.card α).Prime := by\n  constructor\n  · intro h\n    exact ⟨IsSimpleGroup.isCyclic, IsSimpleGroup.prime_card⟩\n  · rintro ⟨_, hp⟩\n    haveI : Fact (Nat.card α).Prime := ⟨hp⟩\n    exact isSimpleGroup_of_prime_card rfl\n\n"}
{"name":"instIsAddCyclicInt","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"⊢ IsAddCyclic Int","decl":"instance : IsAddCyclic ℤ := ⟨1, fun n ↦ ⟨n, by simp only [smul_eq_mul, mul_one]⟩⟩\n\n"}
{"name":"ZMod.instIsAddCyclic","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"n : Nat\n⊢ IsAddCyclic (ZMod n)","decl":"instance ZMod.instIsAddCyclic (n : ℕ) : IsAddCyclic (ZMod n) :=\n  isAddCyclic_of_surjective (Int.castRingHom _) ZMod.intCast_surjective\n\n"}
{"name":"ZMod.instIsSimpleAddGroup","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ IsSimpleAddGroup (ZMod p)","decl":"instance ZMod.instIsSimpleAddGroup {p : ℕ} [Fact p.Prime] : IsSimpleAddGroup (ZMod p) :=\n  AddCommGroup.is_simple_iff_isAddCyclic_and_prime_card.2\n    ⟨inferInstance, by simpa using (Fact.out : p.Prime)⟩\n\n"}
{"name":"IsAddCyclic.exponent_eq_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : IsAddCyclic α\n⊢ Eq (AddMonoid.exponent α) (Nat.card α)","decl":"@[to_additive]\ntheorem IsCyclic.exponent_eq_card [Group α] [IsCyclic α] :\n    exponent α = Nat.card α := by\n  obtain ⟨g, hg⟩ := IsCyclic.exists_ofOrder_eq_natCard (α := α)\n  apply Nat.dvd_antisymm Group.exponent_dvd_nat_card\n  rw [← hg]\n  exact order_dvd_exponent _\n\n"}
{"name":"IsCyclic.exponent_eq_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : IsCyclic α\n⊢ Eq (Monoid.exponent α) (Nat.card α)","decl":"@[to_additive]\ntheorem IsCyclic.exponent_eq_card [Group α] [IsCyclic α] :\n    exponent α = Nat.card α := by\n  obtain ⟨g, hg⟩ := IsCyclic.exists_ofOrder_eq_natCard (α := α)\n  apply Nat.dvd_antisymm Group.exponent_dvd_nat_card\n  rw [← hg]\n  exact order_dvd_exponent _\n\n"}
{"name":"IsAddCyclic.of_exponent_eq_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\ninst✝ : Finite α\nh : Eq (AddMonoid.exponent α) (Nat.card α)\n⊢ IsAddCyclic α","decl":"@[to_additive]\ntheorem IsCyclic.of_exponent_eq_card [CommGroup α] [Finite α] (h : exponent α = Nat.card α) :\n    IsCyclic α :=\n  let ⟨_⟩ := nonempty_fintype α\n  let ⟨g, _, hg⟩ := Finset.mem_image.mp (Finset.max'_mem _ _)\n  isCyclic_of_orderOf_eq_card g <| hg.trans <| exponent_eq_max'_orderOf.symm.trans h\n\n"}
{"name":"IsCyclic.of_exponent_eq_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : CommGroup α\ninst✝ : Finite α\nh : Eq (Monoid.exponent α) (Nat.card α)\n⊢ IsCyclic α","decl":"@[to_additive]\ntheorem IsCyclic.of_exponent_eq_card [CommGroup α] [Finite α] (h : exponent α = Nat.card α) :\n    IsCyclic α :=\n  let ⟨_⟩ := nonempty_fintype α\n  let ⟨g, _, hg⟩ := Finset.mem_image.mp (Finset.max'_mem _ _)\n  isCyclic_of_orderOf_eq_card g <| hg.trans <| exponent_eq_max'_orderOf.symm.trans h\n\n"}
{"name":"IsCyclic.iff_exponent_eq_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : CommGroup α\ninst✝ : Finite α\n⊢ Iff (IsCyclic α) (Eq (Monoid.exponent α) (Nat.card α))","decl":"@[to_additive]\ntheorem IsCyclic.iff_exponent_eq_card [CommGroup α] [Finite α] :\n    IsCyclic α ↔ exponent α = Nat.card α :=\n  ⟨fun _ => IsCyclic.exponent_eq_card, IsCyclic.of_exponent_eq_card⟩\n\n"}
{"name":"IsAddCyclic.iff_exponent_eq_card","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\ninst✝ : Finite α\n⊢ Iff (IsAddCyclic α) (Eq (AddMonoid.exponent α) (Nat.card α))","decl":"@[to_additive]\ntheorem IsCyclic.iff_exponent_eq_card [CommGroup α] [Finite α] :\n    IsCyclic α ↔ exponent α = Nat.card α :=\n  ⟨fun _ => IsCyclic.exponent_eq_card, IsCyclic.of_exponent_eq_card⟩\n\n"}
{"name":"IsCyclic.exponent_eq_zero_of_infinite","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝² : Group α\ninst✝¹ : IsCyclic α\ninst✝ : Infinite α\n⊢ Eq (Monoid.exponent α) 0","decl":"@[to_additive]\ntheorem IsCyclic.exponent_eq_zero_of_infinite [Group α] [IsCyclic α] [Infinite α] :\n    exponent α = 0 :=\n  let ⟨_, hg⟩ := IsCyclic.exists_generator (α := α)\n  exponent_eq_zero_of_order_zero <| Infinite.orderOf_eq_zero_of_forall_mem_zpowers hg\n\n"}
{"name":"IsAddCyclic.exponent_eq_zero_of_infinite","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝² : AddGroup α\ninst✝¹ : IsAddCyclic α\ninst✝ : Infinite α\n⊢ Eq (AddMonoid.exponent α) 0","decl":"@[to_additive]\ntheorem IsCyclic.exponent_eq_zero_of_infinite [Group α] [IsCyclic α] [Infinite α] :\n    exponent α = 0 :=\n  let ⟨_, hg⟩ := IsCyclic.exists_generator (α := α)\n  exponent_eq_zero_of_order_zero <| Infinite.orderOf_eq_zero_of_forall_mem_zpowers hg\n\n"}
{"name":"ZMod.exponent","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"n : Nat\n⊢ Eq (AddMonoid.exponent (ZMod n)) n","decl":"@[simp]\nprotected theorem ZMod.exponent (n : ℕ) : AddMonoid.exponent (ZMod n) = n := by\n  rw [IsAddCyclic.exponent_eq_card, Nat.card_zmod]\n\n"}
{"name":"not_isAddCyclic_iff_exponent_eq_prime","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\np : Nat\nhp : Nat.Prime p\nhα : Eq (Nat.card α) (HPow.hPow p 2)\n⊢ Iff (Not (IsAddCyclic α)) (Eq (AddMonoid.exponent α) p)","decl":"/-- A group of order `p ^ 2` is not cyclic if and only if its exponent is `p`. -/\n@[to_additive]\nlemma not_isCyclic_iff_exponent_eq_prime [Group α] {p : ℕ} (hp : p.Prime)\n    (hα : Nat.card α = p ^ 2) : ¬ IsCyclic α ↔ Monoid.exponent α = p := by\n  -- G is a nontrivial fintype of cardinality `p ^ 2`\n  have : Finite α := Nat.finite_of_card_ne_zero (hα ▸ pow_ne_zero 2 hp.ne_zero)\n  have : Nontrivial α := Finite.one_lt_card_iff_nontrivial.mp\n    (hα ▸ one_lt_pow₀ hp.one_lt two_ne_zero)\n  /- in the forward direction, we apply `exponent_eq_prime_iff`, and the reverse direction follows\n  immediately because if `α` has exponent `p`, it has no element of order `p ^ 2`. -/\n  refine ⟨fun h_cyc ↦ (Monoid.exponent_eq_prime_iff hp).mpr fun g hg ↦ ?_, fun h_exp h_cyc ↦ by\n    obtain (rfl|rfl) := eq_zero_or_one_of_sq_eq_self <| hα ▸ h_exp ▸ (h_cyc.exponent_eq_card).symm\n    · exact Nat.not_prime_zero hp\n    · exact Nat.not_prime_one hp⟩\n  /- we must show every non-identity element has order `p`. By Lagrange's theorem, the only possible\n  orders of `g` are `1`, `p`, or `p ^ 2`. It can't be the former because `g ≠ 1`, and it can't\n  the latter because the group isn't cyclic. -/\n  have := (Nat.mem_divisors (m := p ^ 2)).mpr ⟨hα ▸ orderOf_dvd_natCard (x := g), by aesop⟩\n  simp? [Nat.divisors_prime_pow hp 2] at this says\n    simp only [Nat.divisors_prime_pow hp 2, Nat.reduceAdd, Finset.mem_map, Finset.mem_range,\n      Function.Embedding.coeFn_mk] at this\n  obtain ⟨a, ha, ha'⟩ := this\n  interval_cases a\n  · exact False.elim <| hg <| orderOf_eq_one_iff.mp <| by aesop\n  · aesop\n  · exact False.elim <| h_cyc <| isCyclic_of_orderOf_eq_card g <| by aesop\n\n"}
{"name":"not_isCyclic_iff_exponent_eq_prime","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"α : Type u_1\ninst✝ : Group α\np : Nat\nhp : Nat.Prime p\nhα : Eq (Nat.card α) (HPow.hPow p 2)\n⊢ Iff (Not (IsCyclic α)) (Eq (Monoid.exponent α) p)","decl":"/-- A group of order `p ^ 2` is not cyclic if and only if its exponent is `p`. -/\n@[to_additive]\nlemma not_isCyclic_iff_exponent_eq_prime [Group α] {p : ℕ} (hp : p.Prime)\n    (hα : Nat.card α = p ^ 2) : ¬ IsCyclic α ↔ Monoid.exponent α = p := by\n  -- G is a nontrivial fintype of cardinality `p ^ 2`\n  have : Finite α := Nat.finite_of_card_ne_zero (hα ▸ pow_ne_zero 2 hp.ne_zero)\n  have : Nontrivial α := Finite.one_lt_card_iff_nontrivial.mp\n    (hα ▸ one_lt_pow₀ hp.one_lt two_ne_zero)\n  /- in the forward direction, we apply `exponent_eq_prime_iff`, and the reverse direction follows\n  immediately because if `α` has exponent `p`, it has no element of order `p ^ 2`. -/\n  refine ⟨fun h_cyc ↦ (Monoid.exponent_eq_prime_iff hp).mpr fun g hg ↦ ?_, fun h_exp h_cyc ↦ by\n    obtain (rfl|rfl) := eq_zero_or_one_of_sq_eq_self <| hα ▸ h_exp ▸ (h_cyc.exponent_eq_card).symm\n    · exact Nat.not_prime_zero hp\n    · exact Nat.not_prime_one hp⟩\n  /- we must show every non-identity element has order `p`. By Lagrange's theorem, the only possible\n  orders of `g` are `1`, `p`, or `p ^ 2`. It can't be the former because `g ≠ 1`, and it can't\n  the latter because the group isn't cyclic. -/\n  have := (Nat.mem_divisors (m := p ^ 2)).mpr ⟨hα ▸ orderOf_dvd_natCard (x := g), by aesop⟩\n  simp? [Nat.divisors_prime_pow hp 2] at this says\n    simp only [Nat.divisors_prime_pow hp 2, Nat.reduceAdd, Finset.mem_map, Finset.mem_range,\n      Function.Embedding.coeFn_mk] at this\n  obtain ⟨a, ha, ha'⟩ := this\n  interval_cases a\n  · exact False.elim <| hg <| orderOf_eq_one_iff.mp <| by aesop\n  · aesop\n  · exact False.elim <| h_cyc <| isCyclic_of_orderOf_eq_card g <| by aesop\n\n"}
{"name":"zmultiplesHom_ker_eq","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\ng : G\n⊢ Eq ((zmultiplesHom G) g).ker (AddSubgroup.zmultiples ↑(addOrderOf g))","decl":"/-- The kernel of `zmultiplesHom G g` is equal to the additive subgroup generated by\n    `addOrderOf g`. -/\ntheorem zmultiplesHom_ker_eq [AddGroup G] (g : G) :\n    (zmultiplesHom G g).ker = zmultiples ↑(addOrderOf g) := by\n  ext\n  simp_rw [AddMonoidHom.mem_ker, mem_zmultiples_iff, zmultiplesHom_apply,\n    ← addOrderOf_dvd_iff_zsmul_eq_zero, zsmul_eq_mul', Int.cast_id, dvd_def, eq_comm]\n\n"}
{"name":"zpowersHom_ker_eq","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝ : Group G\ng : G\n⊢ Eq ((zpowersHom G) g).ker (Subgroup.zpowers (Multiplicative.ofAdd ↑(orderOf g)))","decl":"/-- The kernel of `zpowersHom G g` is equal to the subgroup generated by `orderOf g`. -/\ntheorem zpowersHom_ker_eq [Group G] (g : G) :\n    (zpowersHom G g).ker = zpowers (Multiplicative.ofAdd ↑(orderOf g)) :=\n  congr_arg AddSubgroup.toSubgroup <| zmultiplesHom_ker_eq (Additive.ofMul g)\n\n"}
{"name":"IsCyclic.mulAutMulEquiv_symm_apply_symm_apply","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝ : Group G\nh : IsCyclic G\na✝¹ : Units (ZMod (Nat.card G))\na✝ : G\n⊢ Eq ((MulEquiv.symm ((IsCyclic.mulAutMulEquiv G).symm a✝¹)) a✝) ((zmodCyclicMulEquiv h) (Multiplicative.ofAdd (HSMul.hSMul (Inv.inv a✝¹) (Multiplicative.toAdd ((zmodCyclicMulEquiv h).symm a✝)))))","decl":"variable (G) in\n/-- The automorphism group of a cyclic group is isomorphic to the multiplicative group of ZMod. -/\n@[simps!]\nnoncomputable def IsCyclic.mulAutMulEquiv [Group G] [h : IsCyclic G] :\n    MulAut G ≃* (ZMod (Nat.card G))ˣ :=\n  ((MulAut.congr (zmodCyclicMulEquiv h)).symm.trans\n    (MulAutMultiplicative (ZMod (Nat.card G)))).trans (ZMod.AddAutEquivUnits (Nat.card G))\n\n"}
{"name":"IsCyclic.mulAutMulEquiv_symm_apply_apply","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝ : Group G\nh : IsCyclic G\na✝¹ : Units (ZMod (Nat.card G))\na✝ : G\n⊢ Eq (((IsCyclic.mulAutMulEquiv G).symm a✝¹) a✝) ((zmodCyclicMulEquiv h) (Multiplicative.ofAdd (HSMul.hSMul a✝¹ (Multiplicative.toAdd ((zmodCyclicMulEquiv h).symm a✝)))))","decl":"variable (G) in\n/-- The automorphism group of a cyclic group is isomorphic to the multiplicative group of ZMod. -/\n@[simps!]\nnoncomputable def IsCyclic.mulAutMulEquiv [Group G] [h : IsCyclic G] :\n    MulAut G ≃* (ZMod (Nat.card G))ˣ :=\n  ((MulAut.congr (zmodCyclicMulEquiv h)).symm.trans\n    (MulAutMultiplicative (ZMod (Nat.card G)))).trans (ZMod.AddAutEquivUnits (Nat.card G))\n\n"}
{"name":"IsCyclic.val_inv_mulAutMulEquiv_apply","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝ : Group G\nh : IsCyclic G\na✝ : MulAut G\n⊢ Eq (↑(Inv.inv ((IsCyclic.mulAutMulEquiv G) a✝))) ((Inv.inv ((MulAutMultiplicative (ZMod (Nat.card G))) ((zmodCyclicMulEquiv h).trans (MulEquiv.trans a✝ (zmodCyclicMulEquiv h).symm)))) 1)","decl":"variable (G) in\n/-- The automorphism group of a cyclic group is isomorphic to the multiplicative group of ZMod. -/\n@[simps!]\nnoncomputable def IsCyclic.mulAutMulEquiv [Group G] [h : IsCyclic G] :\n    MulAut G ≃* (ZMod (Nat.card G))ˣ :=\n  ((MulAut.congr (zmodCyclicMulEquiv h)).symm.trans\n    (MulAutMultiplicative (ZMod (Nat.card G)))).trans (ZMod.AddAutEquivUnits (Nat.card G))\n\n"}
{"name":"IsCyclic.val_mulAutMulEquiv_apply","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝ : Group G\nh : IsCyclic G\na✝ : MulAut G\n⊢ Eq (↑((IsCyclic.mulAutMulEquiv G) a✝)) (Multiplicative.toAdd ((zmodCyclicMulEquiv h).symm (a✝ ((zmodCyclicMulEquiv h) (Multiplicative.ofAdd 1)))))","decl":"variable (G) in\n/-- The automorphism group of a cyclic group is isomorphic to the multiplicative group of ZMod. -/\n@[simps!]\nnoncomputable def IsCyclic.mulAutMulEquiv [Group G] [h : IsCyclic G] :\n    MulAut G ≃* (ZMod (Nat.card G))ˣ :=\n  ((MulAut.congr (zmodCyclicMulEquiv h)).symm.trans\n    (MulAutMultiplicative (ZMod (Nat.card G)))).trans (ZMod.AddAutEquivUnits (Nat.card G))\n\n"}
{"name":"IsCyclic.card_mulAut","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\ninst✝¹ : Group G\ninst✝ : Finite G\nh : IsCyclic G\n⊢ Eq (Nat.card (MulAut G)) (Nat.card G).totient","decl":"variable (G) in\ntheorem IsCyclic.card_mulAut [Group G] [Finite G] [h : IsCyclic G] :\n    Nat.card (MulAut G) = Nat.totient (Nat.card G) := by\n  have : NeZero (Nat.card G) := ⟨Nat.card_pos.ne'⟩\n  rw [← ZMod.card_units_eq_totient, ← Nat.card_eq_fintype_card]\n  exact Nat.card_congr (mulAutMulEquiv G)\n\n"}
{"name":"addMonoidHomOfForallMemZmultiples_apply_gen","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\nG' : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\ng : G\nhg : ∀ (x : G), Membership.mem (AddSubgroup.zmultiples g) x\ng' : G'\nhg' : Dvd.dvd (addOrderOf g') (addOrderOf g)\n⊢ Eq ((addMonoidHomOfForallMemZmultiples hg hg') g) g'","decl":"@[to_additive (attr := simp)]\nlemma monoidHomOfForallMemZpowers_apply_gen :\n    monoidHomOfForallMemZpowers hg hg' g = g' := by\n  simp only [monoidHomOfForallMemZpowers, MonoidHom.coe_mk, OneHom.coe_mk]\n  nth_rw 2 [← zpow_one g']\n  rw [zpow_eq_zpow_iff_modEq]\n  apply Int.ModEq.of_dvd (Int.natCast_dvd_natCast.mpr hg')\n  rw [← zpow_eq_zpow_iff_modEq, zpow_one]\n  exact Classical.choose_spec <| mem_zpowers_iff.mp <| hg g\n\n"}
{"name":"monoidHomOfForallMemZpowers_apply_gen","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\nG' : Type u_3\ninst✝¹ : Group G\ninst✝ : Group G'\ng : G\nhg : ∀ (x : G), Membership.mem (Subgroup.zpowers g) x\ng' : G'\nhg' : Dvd.dvd (orderOf g') (orderOf g)\n⊢ Eq ((monoidHomOfForallMemZpowers hg hg') g) g'","decl":"@[to_additive (attr := simp)]\nlemma monoidHomOfForallMemZpowers_apply_gen :\n    monoidHomOfForallMemZpowers hg hg' g = g' := by\n  simp only [monoidHomOfForallMemZpowers, MonoidHom.coe_mk, OneHom.coe_mk]\n  nth_rw 2 [← zpow_one g']\n  rw [zpow_eq_zpow_iff_modEq]\n  apply Int.ModEq.of_dvd (Int.natCast_dvd_natCast.mpr hg')\n  rw [← zpow_eq_zpow_iff_modEq, zpow_one]\n  exact Classical.choose_spec <| mem_zpowers_iff.mp <| hg g\n\n"}
{"name":"AddMonoidHom.eq_iff_eq_on_generator","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\nG' : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\ng : G\nhg : ∀ (x : G), Membership.mem (AddSubgroup.zmultiples g) x\nf₁ f₂ : AddMonoidHom G G'\n⊢ Iff (Eq f₁ f₂) (Eq (f₁ g) (f₂ g))","decl":"/-- Two group homomorphisms `G →* G'` are equal if and only if they agree on a generator of `G`. -/\n@[to_additive\n   \"Two homomorphisms `G →+ G'` of additive groups are equal if and only if they agree\n   on a generator of `G`.\"]\nlemma MonoidHom.eq_iff_eq_on_generator (f₁ f₂ : G →* G') : f₁ = f₂ ↔ f₁ g = f₂ g := by\n  rw [DFunLike.ext_iff]\n  refine ⟨fun H ↦ H g, fun H x ↦ ?_⟩\n  obtain ⟨n, hn⟩ := mem_zpowers_iff.mp <| hg x\n  rw [← hn, map_zpow, map_zpow, H]\n\n"}
{"name":"MonoidHom.eq_iff_eq_on_generator","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\nG' : Type u_3\ninst✝¹ : Group G\ninst✝ : Group G'\ng : G\nhg : ∀ (x : G), Membership.mem (Subgroup.zpowers g) x\nf₁ f₂ : MonoidHom G G'\n⊢ Iff (Eq f₁ f₂) (Eq (f₁ g) (f₂ g))","decl":"/-- Two group homomorphisms `G →* G'` are equal if and only if they agree on a generator of `G`. -/\n@[to_additive\n   \"Two homomorphisms `G →+ G'` of additive groups are equal if and only if they agree\n   on a generator of `G`.\"]\nlemma MonoidHom.eq_iff_eq_on_generator (f₁ f₂ : G →* G') : f₁ = f₂ ↔ f₁ g = f₂ g := by\n  rw [DFunLike.ext_iff]\n  refine ⟨fun H ↦ H g, fun H x ↦ ?_⟩\n  obtain ⟨n, hn⟩ := mem_zpowers_iff.mp <| hg x\n  rw [← hn, map_zpow, map_zpow, H]\n\n"}
{"name":"AddEquiv.eq_iff_eq_on_generator","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\nG' : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\ng : G\nhg : ∀ (x : G), Membership.mem (AddSubgroup.zmultiples g) x\nf₁ f₂ : AddEquiv G G'\n⊢ Iff (Eq f₁ f₂) (Eq (f₁ g) (f₂ g))","decl":"/-- Two group isomorphisms `G ≃* G'` are equal if and only if they agree on a generator of `G`. -/\n@[to_additive\n   \"Two isomorphisms `G ≃+ G'` of additive groups are equal if and only if they agree\n   on a generator of `G`.\"]\nlemma MulEquiv.eq_iff_eq_on_generator (f₁ f₂ : G ≃* G') : f₁ = f₂ ↔ f₁ g = f₂ g :=\n  (Function.Injective.eq_iff toMonoidHom_injective).symm.trans <|\n    MonoidHom.eq_iff_eq_on_generator hg ..\n\n"}
{"name":"MulEquiv.eq_iff_eq_on_generator","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\nG' : Type u_3\ninst✝¹ : Group G\ninst✝ : Group G'\ng : G\nhg : ∀ (x : G), Membership.mem (Subgroup.zpowers g) x\nf₁ f₂ : MulEquiv G G'\n⊢ Iff (Eq f₁ f₂) (Eq (f₁ g) (f₂ g))","decl":"/-- Two group isomorphisms `G ≃* G'` are equal if and only if they agree on a generator of `G`. -/\n@[to_additive\n   \"Two isomorphisms `G ≃+ G'` of additive groups are equal if and only if they agree\n   on a generator of `G`.\"]\nlemma MulEquiv.eq_iff_eq_on_generator (f₁ f₂ : G ≃* G') : f₁ = f₂ ↔ f₁ g = f₂ g :=\n  (Function.Injective.eq_iff toMonoidHom_injective).symm.trans <|\n    MonoidHom.eq_iff_eq_on_generator hg ..\n\n"}
{"name":"mulEquivOfOrderOfEq_apply_gen","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\nG' : Type u_3\ninst✝¹ : Group G\ninst✝ : Group G'\ng : G\nhg : ∀ (x : G), Membership.mem (Subgroup.zpowers g) x\ng' : G'\nhg' : ∀ (x : G'), Membership.mem (Subgroup.zpowers g') x\nh : Eq (orderOf g) (orderOf g')\n⊢ Eq ((mulEquivOfOrderOfEq hg hg' h) g) g'","decl":"@[to_additive (attr := simp)]\nlemma mulEquivOfOrderOfEq_apply_gen : mulEquivOfOrderOfEq hg hg' h g = g' :=\n  monoidHomOfForallMemZpowers_apply_gen hg h.symm.dvd\n\n"}
{"name":"addEquivOfAddOrderOfEq_apply_gen","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\nG' : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\ng : G\nhg : ∀ (x : G), Membership.mem (AddSubgroup.zmultiples g) x\ng' : G'\nhg' : ∀ (x : G'), Membership.mem (AddSubgroup.zmultiples g') x\nh : Eq (addOrderOf g) (addOrderOf g')\n⊢ Eq ((addEquivOfAddOrderOfEq hg hg' h) g) g'","decl":"@[to_additive (attr := simp)]\nlemma mulEquivOfOrderOfEq_apply_gen : mulEquivOfOrderOfEq hg hg' h g = g' :=\n  monoidHomOfForallMemZpowers_apply_gen hg h.symm.dvd\n\n"}
{"name":"mulEquivOfOrderOfEq_symm","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\nG' : Type u_3\ninst✝¹ : Group G\ninst✝ : Group G'\ng : G\nhg : ∀ (x : G), Membership.mem (Subgroup.zpowers g) x\ng' : G'\nhg' : ∀ (x : G'), Membership.mem (Subgroup.zpowers g') x\nh : Eq (orderOf g) (orderOf g')\n⊢ Eq (mulEquivOfOrderOfEq hg hg' h).symm (mulEquivOfOrderOfEq hg' hg ⋯)","decl":"@[to_additive (attr := simp)]\nlemma mulEquivOfOrderOfEq_symm :\n    (mulEquivOfOrderOfEq hg hg' h).symm = mulEquivOfOrderOfEq hg' hg h.symm := rfl\n\n"}
{"name":"addEquivOfAddOrderOfEq_symm","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\nG' : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\ng : G\nhg : ∀ (x : G), Membership.mem (AddSubgroup.zmultiples g) x\ng' : G'\nhg' : ∀ (x : G'), Membership.mem (AddSubgroup.zmultiples g') x\nh : Eq (addOrderOf g) (addOrderOf g')\n⊢ Eq (addEquivOfAddOrderOfEq hg hg' h).symm (addEquivOfAddOrderOfEq hg' hg ⋯)","decl":"@[to_additive (attr := simp)]\nlemma mulEquivOfOrderOfEq_symm :\n    (mulEquivOfOrderOfEq hg hg' h).symm = mulEquivOfOrderOfEq hg' hg h.symm := rfl\n\n"}
{"name":"addEquivOfAddOrderOfEq_symm_apply_gen","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\nG' : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\ng : G\nhg : ∀ (x : G), Membership.mem (AddSubgroup.zmultiples g) x\ng' : G'\nhg' : ∀ (x : G'), Membership.mem (AddSubgroup.zmultiples g') x\nh : Eq (addOrderOf g) (addOrderOf g')\n⊢ Eq ((addEquivOfAddOrderOfEq hg hg' h).symm g') g","decl":"@[to_additive] -- `simp` can prove this by a combination of the two preceding lemmas\nlemma mulEquivOfOrderOfEq_symm_apply_gen : (mulEquivOfOrderOfEq hg hg' h).symm g' = g :=\n  monoidHomOfForallMemZpowers_apply_gen hg' h.dvd\n\n"}
{"name":"mulEquivOfOrderOfEq_symm_apply_gen","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"G : Type u_2\nG' : Type u_3\ninst✝¹ : Group G\ninst✝ : Group G'\ng : G\nhg : ∀ (x : G), Membership.mem (Subgroup.zpowers g) x\ng' : G'\nhg' : ∀ (x : G'), Membership.mem (Subgroup.zpowers g') x\nh : Eq (orderOf g) (orderOf g')\n⊢ Eq ((mulEquivOfOrderOfEq hg hg' h).symm g') g","decl":"@[to_additive] -- `simp` can prove this by a combination of the two preceding lemmas\nlemma mulEquivOfOrderOfEq_symm_apply_gen : (mulEquivOfOrderOfEq hg hg' h).symm g' = g :=\n  monoidHomOfForallMemZpowers_apply_gen hg' h.dvd\n\n"}
{"name":"DihedralGroup.not_isCyclic","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"n : Nat\nh1 : Ne n 1\n⊢ Not (IsCyclic (DihedralGroup n))","decl":"lemma DihedralGroup.not_isCyclic {n : ℕ} (h1 : n ≠ 1) : ¬IsCyclic (DihedralGroup n) := fun h' => by\n  by_cases h2 : n = 2\n  · simpa [exponent, card, h2] using h'.exponent_eq_card\n  · exact not_commutative h1 h2 h'.commutative\n\n"}
{"name":"DihedralGroup.isCyclic_iff","module":"Mathlib.GroupTheory.SpecificGroups.Cyclic","initialProofState":"n : Nat\n⊢ Iff (IsCyclic (DihedralGroup n)) (Eq n 1)","decl":"lemma DihedralGroup.isCyclic_iff {n : ℕ} :\n    IsCyclic (DihedralGroup n) ↔ n = 1 where\n  mp := by contrapose; exact not_isCyclic\n  mpr := by rintro rfl; exact isCyclic_of_prime_card (p := 2) nat_card\n"}
