{"name":"disjointed_apply","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : GeneralizedBooleanAlgebra α\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → α\ni : ι\n⊢ Eq (disjointed f i) (SDiff.sdiff (f i) ((Finset.Iio i).sup f))","decl":"lemma disjointed_apply (f : ι → α) (i : ι) : disjointed f i = f i \\ (Iio i).sup f := rfl\n\n"}
{"name":"disjointed_of_isMin","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : GeneralizedBooleanAlgebra α\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → α\ni : ι\nhn : IsMin i\n⊢ Eq (disjointed f i) (f i)","decl":"lemma disjointed_of_isMin (f : ι → α) {i : ι} (hn : IsMin i) :\n    disjointed f i = f i := by\n  have : Iio i = ∅ := by rwa [← Finset.coe_eq_empty, coe_Iio, Set.Iio_eq_empty_iff]\n  simp only [disjointed_apply, this, sup_empty, sdiff_bot]\n\n"}
{"name":"disjointed_bot","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝³ : GeneralizedBooleanAlgebra α\ninst✝² : Preorder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : OrderBot ι\nf : ι → α\n⊢ Eq (disjointed f Bot.bot) (f Bot.bot)","decl":"@[simp] lemma disjointed_bot [OrderBot ι] (f : ι → α) : disjointed f ⊥ = f ⊥ :=\n  disjointed_of_isMin _ isMin_bot\n\n"}
{"name":"disjointed_le_id","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : GeneralizedBooleanAlgebra α\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\n⊢ LE.le disjointed id","decl":"theorem disjointed_le_id : disjointed ≤ (id : (ι → α) → ι → α) :=\n  fun _ _ ↦ sdiff_le\n\n"}
{"name":"disjointed_le","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : GeneralizedBooleanAlgebra α\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → α\n⊢ LE.le (disjointed f) f","decl":"theorem disjointed_le (f : ι → α) : disjointed f ≤ f :=\n  disjointed_le_id f\n\n"}
{"name":"disjoint_disjointed_of_lt","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : GeneralizedBooleanAlgebra α\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → α\ni j : ι\nh : LT.lt i j\n⊢ Disjoint (disjointed f i) (disjointed f j)","decl":"theorem disjoint_disjointed_of_lt (f : ι → α) {i j : ι} (h : i < j) :\n    Disjoint (disjointed f i) (disjointed f j) :=\n  (disjoint_sdiff_self_right.mono_left <| le_sup (mem_Iio.mpr h)).mono_left (disjointed_le f i)\n\n"}
{"name":"disjointed_eq_self","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : GeneralizedBooleanAlgebra α\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → α\ni : ι\nhf : ∀ (j : ι), LT.lt j i → Disjoint (f j) (f i)\n⊢ Eq (disjointed f i) (f i)","decl":"lemma disjointed_eq_self {f : ι → α} {i : ι} (hf : ∀ j < i, Disjoint (f j) (f i)) :\n    disjointed f i = f i := by\n  rw [disjointed_apply, sdiff_eq_left, disjoint_iff, sup_inf_distrib_left,\n    sup_congr rfl <| fun j hj ↦ disjoint_iff.mp <| (hf _ (mem_Iio.mp hj)).symm]\n  exact sup_bot _\n\n/- NB: The original statement for `ι = ℕ` was a `def` and worked for `p : α → Sort*`. I couldn't\nprove the `Sort*` version for general `ι`, but all instances of `disjointedRec` in the library are\nfor Prop anyway. -/\n"}
{"name":"disjointedRec","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : GeneralizedBooleanAlgebra α\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → α\np : α → Prop\nhdiff : ∀ ⦃t : α⦄ ⦃i : ι⦄, p t → p (SDiff.sdiff t (f i))\ni : ι\na✝ : p (f i)\n⊢ p (disjointed f i)","decl":"/--\nAn induction principle for `disjointed`. To prove something about `disjointed f i`, it's\nenough to prove it for `f i` and being able to extend through diffs.\n-/\nlemma disjointedRec {f : ι → α} {p : α → Prop} (hdiff : ∀ ⦃t i⦄, p t → p (t \\ f i)) :\n    ∀ ⦃i⦄, p (f i) → p (disjointed f i) := by\n  classical\n  intro i hpi\n  rw [disjointed]\n  suffices ∀ (s : Finset ι), p (f i \\ s.sup f) from this _\n  intro s\n  induction s using Finset.induction with\n  | empty => simpa only [sup_empty, sdiff_bot] using hpi\n  | insert ht IH =>\n    rw [sup_insert, sup_comm, ← sdiff_sdiff]\n    exact hdiff IH\n\n"}
{"name":"partialSups_disjointed","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : GeneralizedBooleanAlgebra α\ninst✝¹ : PartialOrder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → α\n⊢ Eq (partialSups (disjointed f)) (partialSups f)","decl":"@[simp]\ntheorem partialSups_disjointed (f : ι → α) :\n    partialSups (disjointed f) = partialSups f := by\n  -- This seems to be much more awkward than the case of linear orders, because the supremum\n  -- in the definition of `disjointed` can involve multiple \"paths\" through the poset.\n  classical\n  -- We argue by induction on the size of `Iio i`.\n  suffices ∀ r i (hi : #(Iio i) ≤ r), partialSups (disjointed f) i = partialSups f i from\n    OrderHom.ext _ _ (funext fun i ↦ this _ i le_rfl)\n  intro r i hi\n  induction r generalizing i with\n  | zero =>\n   -- Base case: `n` is minimal, so `partialSups f i = partialSups (disjointed f) n = f i`.\n    simp only [Nat.le_zero, card_eq_zero] at hi\n    simp only [partialSups_apply, Iic_eq_cons_Iio, hi, disjointed_apply, sup'_eq_sup, sup_cons,\n      sup_empty, sdiff_bot]\n  | succ n ih =>\n    -- Induction step: first WLOG arrange that `#(Iio i) = r + 1`\n    rcases lt_or_eq_of_le hi with hn | hn\n    · exact ih _ <| Nat.le_of_lt_succ hn\n    simp only [partialSups_apply (disjointed f), Iic_eq_cons_Iio, sup'_eq_sup, sup_cons]\n    -- Key claim: we can write `Iio i` as a union of (finitely many) `Ici` intervals.\n    have hun : (Iio i).biUnion Iic = Iio i := by\n      ext r; simpa using ⟨fun ⟨a, ha⟩ ↦ ha.2.trans_lt ha.1, fun hr ↦ ⟨r, hr, le_rfl⟩⟩\n    -- Use claim and `sup_biUnion` to rewrite the supremum in the definition of `disjointed f`\n    -- in terms of suprema over `Iic`'s. Then the RHS is a `sup` over `partialSups`, which we\n    -- can rewrite via the induction hypothesis.\n    rw [← hun, sup_biUnion, sup_congr rfl (g := partialSups f)]\n    · simp only [funext (partialSups_apply f), sup'_eq_sup, ← sup_biUnion, hun]\n      simp only [disjointed, sdiff_sup_self, Iic_eq_cons_Iio, sup_cons]\n    · simp only [partialSups, sup'_eq_sup, OrderHom.coe_mk] at ih ⊢\n      refine fun x hx ↦ ih x ?_\n      -- Remains to show `∀ x in Iio i, #(Iio x) ≤ r`.\n      rw [← Nat.lt_add_one_iff, ← hn]\n      apply lt_of_lt_of_le (b := #(Iic x))\n      · simpa only [Iic_eq_cons_Iio, card_cons] using Nat.lt_succ_self _\n      · refine card_le_card (fun r hr ↦ ?_)\n        simp only [mem_Iic, mem_Iio] at hx hr ⊢\n        exact hr.trans_lt hx\n\n"}
{"name":"Fintype.sup_disjointed","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝³ : GeneralizedBooleanAlgebra α\ninst✝² : PartialOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : Fintype ι\nf : ι → α\n⊢ Eq (Finset.univ.sup (disjointed f)) (Finset.univ.sup f)","decl":"lemma Fintype.sup_disjointed [Fintype ι] (f : ι → α) :\n    univ.sup (disjointed f) = univ.sup f := by\n  classical\n  have hun : univ.biUnion Iic = (univ : Finset ι) := by\n    ext r; simpa only [mem_biUnion, mem_univ, mem_Iic, true_and, iff_true] using ⟨r, le_rfl⟩\n  rw [← hun, sup_biUnion, sup_biUnion, sup_congr rfl (fun i _ ↦ ?_)]\n  rw [← sup'_eq_sup nonempty_Iic, ← sup'_eq_sup nonempty_Iic,\n    ← partialSups_apply, ← partialSups_apply, partialSups_disjointed]\n\n"}
{"name":"disjointed_partialSups","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : GeneralizedBooleanAlgebra α\ninst✝¹ : PartialOrder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → α\n⊢ Eq (disjointed ⇑(partialSups f)) (disjointed f)","decl":"lemma disjointed_partialSups (f : ι → α) :\n    disjointed (partialSups f) = disjointed f := by\n  classical\n  ext i\n  have step1 : f i \\ (Iio i).sup f = partialSups f i \\ (Iio i).sup f := by\n    rw [sdiff_eq_symm (sdiff_le.trans (le_partialSups f i))]\n    simp only [funext (partialSups_apply f), sup'_eq_sup]\n    rw [sdiff_sdiff_eq_sdiff_sup (sup_mono Iio_subset_Iic_self), sup_eq_right]\n    simp only [Iic_eq_cons_Iio, sup_cons, sup_sdiff_left_self, sdiff_le_iff, le_sup_right]\n  simp only [disjointed_apply, step1, funext (partialSups_apply f), sup'_eq_sup, ← sup_biUnion]\n  congr 2 with r\n  simpa only [mem_biUnion, mem_Iio, mem_Iic] using\n    ⟨fun ⟨a, ha⟩ ↦ ha.2.trans_lt ha.1, fun hr ↦ ⟨r, hr, le_rfl⟩⟩\n\n"}
{"name":"disjointed_unique","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : GeneralizedBooleanAlgebra α\ninst✝¹ : PartialOrder ι\ninst✝ : LocallyFiniteOrderBot ι\nf d : ι → α\nhdisj : ∀ {i j : ι}, LT.lt i j → Disjoint (d i) (d j)\nhsups : Eq (partialSups d) (partialSups f)\n⊢ Eq d (disjointed f)","decl":"/-- `disjointed f` is the unique map `d : ι → α` such that `d` has the same partial sups as `f`,\nand `d i` and `d j` are disjoint whenever `i < j`. -/\ntheorem disjointed_unique {f d : ι → α} (hdisj : ∀ {i j : ι} (_ : i < j), Disjoint (d i) (d j))\n    (hsups : partialSups d = partialSups f) :\n    d = disjointed f := by\n  rw [← disjointed_partialSups, ← hsups, disjointed_partialSups]\n  exact funext fun _ ↦ (disjointed_eq_self (fun _ hj ↦ hdisj hj)).symm\n\n"}
{"name":"disjoint_disjointed","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : GeneralizedBooleanAlgebra α\ninst✝¹ : LinearOrder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → α\n⊢ Pairwise (Function.onFun Disjoint (disjointed f))","decl":"theorem disjoint_disjointed (f : ι → α) : Pairwise (Disjoint on disjointed f) :=\n  (pairwise_disjoint_on _).mpr fun _ _ ↦ disjoint_disjointed_of_lt f\n\n"}
{"name":"disjointed_unique'","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : GeneralizedBooleanAlgebra α\ninst✝¹ : LinearOrder ι\ninst✝ : LocallyFiniteOrderBot ι\nf d : ι → α\nhdisj : Pairwise (Function.onFun Disjoint d)\nhsups : Eq (partialSups d) (partialSups f)\n⊢ Eq d (disjointed f)","decl":"/-- `disjointed f` is the unique sequence that is pairwise disjoint and has the same partial sups\nas `f`. -/\ntheorem disjointed_unique' {f d : ι → α} (hdisj : Pairwise (Disjoint on d))\n    (hsups : partialSups d = partialSups f) : d = disjointed f :=\n  disjointed_unique (fun hij ↦ hdisj hij.ne) hsups\n\n"}
{"name":"disjointed_succ","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝³ : GeneralizedBooleanAlgebra α\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : SuccOrder ι\nf : ι → α\ni : ι\nhi : Not (IsMax i)\n⊢ Eq (disjointed f (Order.succ i)) (SDiff.sdiff (f (Order.succ i)) ((partialSups f) i))","decl":"lemma disjointed_succ (f : ι → α) {i : ι} (hi : ¬IsMax i) :\n    disjointed f (succ i) = f (succ i) \\ partialSups f i := by\n  rw [disjointed_apply, partialSups_apply, sup'_eq_sup]\n  congr 2 with m\n  simpa only [mem_Iio, mem_Iic] using lt_succ_iff_of_not_isMax hi\n\n"}
{"name":"Monotone.disjointed_succ","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝³ : GeneralizedBooleanAlgebra α\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : SuccOrder ι\nf : ι → α\nhf : Monotone f\ni : ι\nhn : Not (IsMax i)\n⊢ Eq (disjointed f (Order.succ i)) (SDiff.sdiff (f (Order.succ i)) (f i))","decl":"protected lemma Monotone.disjointed_succ {f : ι → α} (hf : Monotone f) {i : ι} (hn : ¬IsMax i) :\n    disjointed f (succ i) = f (succ i) \\ f i := by\n  rwa [disjointed_succ, hf.partialSups_eq]\n\n"}
{"name":"Monotone.disjointed_succ_sup","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝³ : GeneralizedBooleanAlgebra α\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : SuccOrder ι\nf : ι → α\nhf : Monotone f\ni : ι\n⊢ Eq (Max.max (disjointed f (Order.succ i)) (f i)) (f (Order.succ i))","decl":"/-- Note this lemma does not require `¬IsMax i`, unlike `disjointed_succ`. -/\nlemma Monotone.disjointed_succ_sup {f : ι → α} (hf : Monotone f) (i : ι) :\n    disjointed f (succ i) ⊔ f i = f (succ i) := by\n  by_cases h : IsMax i\n  · simpa only [succ_eq_iff_isMax.mpr h, sup_eq_right] using disjointed_le f i\n  · rw [disjointed_apply]\n    have : Iio (succ i) = Iic i := by\n      ext\n      simp only [mem_Iio, lt_succ_iff_eq_or_lt_of_not_isMax h, mem_Iic, le_iff_lt_or_eq, Or.comm]\n    rw [this, ← sup'_eq_sup, ← partialSups_apply, hf.partialSups_eq,\n      sdiff_sup_cancel <| hf <| le_succ i]\n\n"}
{"name":"Fintype.exists_disjointed_le","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\ninst✝¹ : GeneralizedBooleanAlgebra α\nι : Type u_3\ninst✝ : Fintype ι\nf : ι → α\n⊢ Exists fun g => And (LE.le g f) (And (Eq (Finset.univ.sup g) (Finset.univ.sup f)) (Pairwise (Function.onFun Disjoint g)))","decl":"/-- For any finite family of elements `f : ι → α`, we can find a pairwise-disjoint family `g`\nbounded above by `f` and having the same supremum. This is non-canonical, depending on an arbitrary\nchoice of ordering of `ι`. -/\nlemma Fintype.exists_disjointed_le {ι : Type*} [Fintype ι] {f : ι → α} :\n    ∃ g, g ≤ f ∧ univ.sup g = univ.sup f ∧ Pairwise (Disjoint on g) := by\n  rcases isEmpty_or_nonempty ι with hι | hι\n  ·  -- do `ι = ∅` separately since `⊤ : Fin n` isn't defined for `n = 0`\n    exact ⟨f, le_rfl, rfl, Subsingleton.pairwise⟩\n  let R : ι ≃ Fin _ := equivFin ι\n  let f' : Fin _ → α := f ∘ R.symm\n  have hf' : f = f' ∘ R := by ext; simp only [Function.comp_apply, Equiv.symm_apply_apply, f']\n  refine ⟨disjointed f' ∘ R, ?_, ?_, ?_⟩\n  · intro n\n    simpa only [hf'] using disjointed_le f' (R n)\n  · simpa only [← sup_image, image_univ_equiv, hf'] using sup_disjointed f'\n  · exact fun i j hij ↦ disjoint_disjointed f' (R.injective.ne hij)\n\n"}
{"name":"iSup_disjointed","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : CompleteBooleanAlgebra α\ninst✝¹ : PartialOrder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → α\n⊢ Eq (iSup fun i => disjointed f i) (iSup fun i => f i)","decl":"theorem iSup_disjointed [PartialOrder ι] [LocallyFiniteOrderBot ι] (f : ι → α) :\n    ⨆ i, disjointed f i = ⨆ i, f i :=\n  iSup_eq_iSup_of_partialSups_eq_partialSups (partialSups_disjointed f)\n\n"}
{"name":"disjointed_eq_inf_compl","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : CompleteBooleanAlgebra α\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → α\ni : ι\n⊢ Eq (disjointed f i) (Min.min (f i) (iInf fun j => iInf fun h => HasCompl.compl (f j)))","decl":"theorem disjointed_eq_inf_compl [Preorder ι] [LocallyFiniteOrderBot ι] (f : ι → α) (i : ι) :\n    disjointed f i = f i ⊓ ⨅ j < i, (f j)ᶜ := by\n  simp only [disjointed_apply, Finset.sup_eq_iSup, mem_Iio, sdiff_eq, compl_iSup]\n\n"}
{"name":"disjointed_subset","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → Set α\ni : ι\n⊢ HasSubset.Subset (disjointed f i) (f i)","decl":"theorem disjointed_subset [Preorder ι] [LocallyFiniteOrderBot ι] (f : ι → Set α) (i : ι) :\n    disjointed f i ⊆ f i :=\n  disjointed_le f i\n\n"}
{"name":"iUnion_disjointed","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝¹ : PartialOrder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → Set α\n⊢ Eq (Set.iUnion fun i => disjointed f i) (Set.iUnion fun i => f i)","decl":"theorem iUnion_disjointed [PartialOrder ι] [LocallyFiniteOrderBot ι] {f : ι → Set α} :\n    ⋃ i, disjointed f i = ⋃ i, f i :=\n  iSup_disjointed f\n\n"}
{"name":"disjointed_eq_inter_compl","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → Set α\ni : ι\n⊢ Eq (disjointed f i) (Inter.inter (f i) (Set.iInter fun j => Set.iInter fun h => HasCompl.compl (f j)))","decl":"theorem disjointed_eq_inter_compl [Preorder ι] [LocallyFiniteOrderBot ι] (f : ι → Set α) (i : ι) :\n    disjointed f i = f i ∩ ⋂ j < i, (f j)ᶜ :=\n  disjointed_eq_inf_compl f i\n\n"}
{"name":"preimage_find_eq_disjointed","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\ns : Nat → Set α\nH : ∀ (x : α), Exists fun n => Membership.mem (s n) x\ninst✝ : (x : α) → (n : Nat) → Decidable (Membership.mem (s n) x)\nn : Nat\n⊢ Eq (Set.preimage (fun x => Nat.find ⋯) (Singleton.singleton n)) (disjointed s n)","decl":"theorem preimage_find_eq_disjointed (s : ℕ → Set α) (H : ∀ x, ∃ n, x ∈ s n)\n    [∀ x n, Decidable (x ∈ s n)] (n : ℕ) : (fun x => Nat.find (H x)) ⁻¹' {n} = disjointed s n := by\n  ext x\n  simp [Nat.find_eq_iff, disjointed_eq_inter_compl]\n\n"}
{"name":"disjointed_zero","module":"Mathlib.Order.Disjointed","initialProofState":"α : Type u_1\ninst✝ : GeneralizedBooleanAlgebra α\nf : Nat → α\n⊢ Eq (disjointed f 0) (f 0)","decl":"@[simp]\ntheorem disjointed_zero (f : ℕ → α) : disjointed f 0 = f 0 :=\n  disjointed_bot f\n\n"}
