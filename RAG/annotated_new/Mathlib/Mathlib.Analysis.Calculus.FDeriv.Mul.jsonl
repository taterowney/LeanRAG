{"name":"HasStrictFDerivAt.clm_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nx : E\nH : Type u_5\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousLinearMap (RingHom.id 𝕜) G H\nc' : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) G H)\nd : E → ContinuousLinearMap (RingHom.id 𝕜) F G\nd' : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F G)\nhc : HasStrictFDerivAt c c' x\nhd : HasStrictFDerivAt d d' x\n⊢ HasStrictFDerivAt (fun y => (c y).comp (d y)) (HAdd.hAdd (((ContinuousLinearMap.compL 𝕜 F G H) (c x)).comp d') (((ContinuousLinearMap.compL 𝕜 F G H).flip (d x)).comp c')) x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.clm_comp (hc : HasStrictFDerivAt c c' x) (hd : HasStrictFDerivAt d d' x) :\n    HasStrictFDerivAt (fun y => (c y).comp (d y))\n      ((compL 𝕜 F G H (c x)).comp d' + ((compL 𝕜 F G H).flip (d x)).comp c') x := by\n  have := isBoundedBilinearMap_comp.hasStrictFDerivAt (c x, d x)\n  have := this.comp x (hc.prod hd)\n  exact this\n\n"}
{"name":"HasFDerivWithinAt.clm_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nx : E\ns : Set E\nH : Type u_5\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousLinearMap (RingHom.id 𝕜) G H\nc' : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) G H)\nd : E → ContinuousLinearMap (RingHom.id 𝕜) F G\nd' : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F G)\nhc : HasFDerivWithinAt c c' s x\nhd : HasFDerivWithinAt d d' s x\n⊢ HasFDerivWithinAt (fun y => (c y).comp (d y)) (HAdd.hAdd (((ContinuousLinearMap.compL 𝕜 F G H) (c x)).comp d') (((ContinuousLinearMap.compL 𝕜 F G H).flip (d x)).comp c')) s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.clm_comp (hc : HasFDerivWithinAt c c' s x)\n    (hd : HasFDerivWithinAt d d' s x) :\n    HasFDerivWithinAt (fun y => (c y).comp (d y))\n      ((compL 𝕜 F G H (c x)).comp d' + ((compL 𝕜 F G H).flip (d x)).comp c') s x := by\n  exact (isBoundedBilinearMap_comp.hasFDerivAt (c x, d x) :).comp_hasFDerivWithinAt x <| hc.prod hd\n\n"}
{"name":"HasFDerivAt.clm_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nx : E\nH : Type u_5\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousLinearMap (RingHom.id 𝕜) G H\nc' : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) G H)\nd : E → ContinuousLinearMap (RingHom.id 𝕜) F G\nd' : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F G)\nhc : HasFDerivAt c c' x\nhd : HasFDerivAt d d' x\n⊢ HasFDerivAt (fun y => (c y).comp (d y)) (HAdd.hAdd (((ContinuousLinearMap.compL 𝕜 F G H) (c x)).comp d') (((ContinuousLinearMap.compL 𝕜 F G H).flip (d x)).comp c')) x","decl":"@[fun_prop]\ntheorem HasFDerivAt.clm_comp (hc : HasFDerivAt c c' x) (hd : HasFDerivAt d d' x) :\n    HasFDerivAt (fun y => (c y).comp (d y))\n      ((compL 𝕜 F G H (c x)).comp d' + ((compL 𝕜 F G H).flip (d x)).comp c') x := by\n  exact (isBoundedBilinearMap_comp.hasFDerivAt (c x, d x) :).comp x <| hc.prod hd\n\n"}
{"name":"DifferentiableWithinAt.clm_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nx : E\ns : Set E\nH : Type u_5\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousLinearMap (RingHom.id 𝕜) G H\nd : E → ContinuousLinearMap (RingHom.id 𝕜) F G\nhc : DifferentiableWithinAt 𝕜 c s x\nhd : DifferentiableWithinAt 𝕜 d s x\n⊢ DifferentiableWithinAt 𝕜 (fun y => (c y).comp (d y)) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.clm_comp (hc : DifferentiableWithinAt 𝕜 c s x)\n    (hd : DifferentiableWithinAt 𝕜 d s x) :\n    DifferentiableWithinAt 𝕜 (fun y => (c y).comp (d y)) s x :=\n  (hc.hasFDerivWithinAt.clm_comp hd.hasFDerivWithinAt).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.clm_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nx : E\nH : Type u_5\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousLinearMap (RingHom.id 𝕜) G H\nd : E → ContinuousLinearMap (RingHom.id 𝕜) F G\nhc : DifferentiableAt 𝕜 c x\nhd : DifferentiableAt 𝕜 d x\n⊢ DifferentiableAt 𝕜 (fun y => (c y).comp (d y)) x","decl":"@[fun_prop]\ntheorem DifferentiableAt.clm_comp (hc : DifferentiableAt 𝕜 c x) (hd : DifferentiableAt 𝕜 d x) :\n    DifferentiableAt 𝕜 (fun y => (c y).comp (d y)) x :=\n  (hc.hasFDerivAt.clm_comp hd.hasFDerivAt).differentiableAt\n\n"}
{"name":"DifferentiableOn.clm_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ns : Set E\nH : Type u_5\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousLinearMap (RingHom.id 𝕜) G H\nd : E → ContinuousLinearMap (RingHom.id 𝕜) F G\nhc : DifferentiableOn 𝕜 c s\nhd : DifferentiableOn 𝕜 d s\n⊢ DifferentiableOn 𝕜 (fun y => (c y).comp (d y)) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.clm_comp (hc : DifferentiableOn 𝕜 c s) (hd : DifferentiableOn 𝕜 d s) :\n    DifferentiableOn 𝕜 (fun y => (c y).comp (d y)) s := fun x hx => (hc x hx).clm_comp (hd x hx)\n\n"}
{"name":"Differentiable.clm_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nH : Type u_5\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousLinearMap (RingHom.id 𝕜) G H\nd : E → ContinuousLinearMap (RingHom.id 𝕜) F G\nhc : Differentiable 𝕜 c\nhd : Differentiable 𝕜 d\n⊢ Differentiable 𝕜 fun y => (c y).comp (d y)","decl":"@[fun_prop]\ntheorem Differentiable.clm_comp (hc : Differentiable 𝕜 c) (hd : Differentiable 𝕜 d) :\n    Differentiable 𝕜 fun y => (c y).comp (d y) := fun x => (hc x).clm_comp (hd x)\n\n"}
{"name":"fderivWithin_clm_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nx : E\ns : Set E\nH : Type u_5\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousLinearMap (RingHom.id 𝕜) G H\nd : E → ContinuousLinearMap (RingHom.id 𝕜) F G\nhxs : UniqueDiffWithinAt 𝕜 s x\nhc : DifferentiableWithinAt 𝕜 c s x\nhd : DifferentiableWithinAt 𝕜 d s x\n⊢ Eq (fderivWithin 𝕜 (fun y => (c y).comp (d y)) s x) (HAdd.hAdd (((ContinuousLinearMap.compL 𝕜 F G H) (c x)).comp (fderivWithin 𝕜 d s x)) (((ContinuousLinearMap.compL 𝕜 F G H).flip (d x)).comp (fderivWithin 𝕜 c s x)))","decl":"theorem fderivWithin_clm_comp (hxs : UniqueDiffWithinAt 𝕜 s x) (hc : DifferentiableWithinAt 𝕜 c s x)\n    (hd : DifferentiableWithinAt 𝕜 d s x) :\n    fderivWithin 𝕜 (fun y => (c y).comp (d y)) s x =\n      (compL 𝕜 F G H (c x)).comp (fderivWithin 𝕜 d s x) +\n        ((compL 𝕜 F G H).flip (d x)).comp (fderivWithin 𝕜 c s x) :=\n  (hc.hasFDerivWithinAt.clm_comp hd.hasFDerivWithinAt).fderivWithin hxs\n\n"}
{"name":"fderiv_clm_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nx : E\nH : Type u_5\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousLinearMap (RingHom.id 𝕜) G H\nd : E → ContinuousLinearMap (RingHom.id 𝕜) F G\nhc : DifferentiableAt 𝕜 c x\nhd : DifferentiableAt 𝕜 d x\n⊢ Eq (fderiv 𝕜 (fun y => (c y).comp (d y)) x) (HAdd.hAdd (((ContinuousLinearMap.compL 𝕜 F G H) (c x)).comp (fderiv 𝕜 d x)) (((ContinuousLinearMap.compL 𝕜 F G H).flip (d x)).comp (fderiv 𝕜 c x)))","decl":"theorem fderiv_clm_comp (hc : DifferentiableAt 𝕜 c x) (hd : DifferentiableAt 𝕜 d x) :\n    fderiv 𝕜 (fun y => (c y).comp (d y)) x =\n      (compL 𝕜 F G H (c x)).comp (fderiv 𝕜 d x) +\n        ((compL 𝕜 F G H).flip (d x)).comp (fderiv 𝕜 c x) :=\n  (hc.hasFDerivAt.clm_comp hd.hasFDerivAt).fderiv\n\n"}
{"name":"HasStrictFDerivAt.clm_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nx : E\nH : Type u_5\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousLinearMap (RingHom.id 𝕜) G H\nc' : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) G H)\nu : E → G\nu' : ContinuousLinearMap (RingHom.id 𝕜) E G\nhc : HasStrictFDerivAt c c' x\nhu : HasStrictFDerivAt u u' x\n⊢ HasStrictFDerivAt (fun y => (c y) (u y)) (HAdd.hAdd ((c x).comp u') (c'.flip (u x))) x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.clm_apply (hc : HasStrictFDerivAt c c' x)\n    (hu : HasStrictFDerivAt u u' x) :\n    HasStrictFDerivAt (fun y => (c y) (u y)) ((c x).comp u' + c'.flip (u x)) x :=\n  (isBoundedBilinearMap_apply.hasStrictFDerivAt (c x, u x)).comp x (hc.prod hu)\n\n"}
{"name":"HasFDerivWithinAt.clm_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nx : E\ns : Set E\nH : Type u_5\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousLinearMap (RingHom.id 𝕜) G H\nc' : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) G H)\nu : E → G\nu' : ContinuousLinearMap (RingHom.id 𝕜) E G\nhc : HasFDerivWithinAt c c' s x\nhu : HasFDerivWithinAt u u' s x\n⊢ HasFDerivWithinAt (fun y => (c y) (u y)) (HAdd.hAdd ((c x).comp u') (c'.flip (u x))) s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.clm_apply (hc : HasFDerivWithinAt c c' s x)\n    (hu : HasFDerivWithinAt u u' s x) :\n    HasFDerivWithinAt (fun y => (c y) (u y)) ((c x).comp u' + c'.flip (u x)) s x := by\n  exact (isBoundedBilinearMap_apply.hasFDerivAt (c x, u x) :).comp_hasFDerivWithinAt x (hc.prod hu)\n\n"}
{"name":"HasFDerivAt.clm_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nx : E\nH : Type u_5\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousLinearMap (RingHom.id 𝕜) G H\nc' : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) G H)\nu : E → G\nu' : ContinuousLinearMap (RingHom.id 𝕜) E G\nhc : HasFDerivAt c c' x\nhu : HasFDerivAt u u' x\n⊢ HasFDerivAt (fun y => (c y) (u y)) (HAdd.hAdd ((c x).comp u') (c'.flip (u x))) x","decl":"@[fun_prop]\ntheorem HasFDerivAt.clm_apply (hc : HasFDerivAt c c' x) (hu : HasFDerivAt u u' x) :\n    HasFDerivAt (fun y => (c y) (u y)) ((c x).comp u' + c'.flip (u x)) x := by\n  exact (isBoundedBilinearMap_apply.hasFDerivAt (c x, u x) :).comp x (hc.prod hu)\n\n"}
{"name":"DifferentiableWithinAt.clm_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nx : E\ns : Set E\nH : Type u_5\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousLinearMap (RingHom.id 𝕜) G H\nu : E → G\nhc : DifferentiableWithinAt 𝕜 c s x\nhu : DifferentiableWithinAt 𝕜 u s x\n⊢ DifferentiableWithinAt 𝕜 (fun y => (c y) (u y)) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.clm_apply (hc : DifferentiableWithinAt 𝕜 c s x)\n    (hu : DifferentiableWithinAt 𝕜 u s x) : DifferentiableWithinAt 𝕜 (fun y => (c y) (u y)) s x :=\n  (hc.hasFDerivWithinAt.clm_apply hu.hasFDerivWithinAt).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.clm_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nx : E\nH : Type u_5\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousLinearMap (RingHom.id 𝕜) G H\nu : E → G\nhc : DifferentiableAt 𝕜 c x\nhu : DifferentiableAt 𝕜 u x\n⊢ DifferentiableAt 𝕜 (fun y => (c y) (u y)) x","decl":"@[fun_prop]\ntheorem DifferentiableAt.clm_apply (hc : DifferentiableAt 𝕜 c x) (hu : DifferentiableAt 𝕜 u x) :\n    DifferentiableAt 𝕜 (fun y => (c y) (u y)) x :=\n  (hc.hasFDerivAt.clm_apply hu.hasFDerivAt).differentiableAt\n\n"}
{"name":"DifferentiableOn.clm_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ns : Set E\nH : Type u_5\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousLinearMap (RingHom.id 𝕜) G H\nu : E → G\nhc : DifferentiableOn 𝕜 c s\nhu : DifferentiableOn 𝕜 u s\n⊢ DifferentiableOn 𝕜 (fun y => (c y) (u y)) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.clm_apply (hc : DifferentiableOn 𝕜 c s) (hu : DifferentiableOn 𝕜 u s) :\n    DifferentiableOn 𝕜 (fun y => (c y) (u y)) s := fun x hx => (hc x hx).clm_apply (hu x hx)\n\n"}
{"name":"Differentiable.clm_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nH : Type u_5\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousLinearMap (RingHom.id 𝕜) G H\nu : E → G\nhc : Differentiable 𝕜 c\nhu : Differentiable 𝕜 u\n⊢ Differentiable 𝕜 fun y => (c y) (u y)","decl":"@[fun_prop]\ntheorem Differentiable.clm_apply (hc : Differentiable 𝕜 c) (hu : Differentiable 𝕜 u) :\n    Differentiable 𝕜 fun y => (c y) (u y) := fun x => (hc x).clm_apply (hu x)\n\n"}
{"name":"fderivWithin_clm_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nx : E\ns : Set E\nH : Type u_5\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousLinearMap (RingHom.id 𝕜) G H\nu : E → G\nhxs : UniqueDiffWithinAt 𝕜 s x\nhc : DifferentiableWithinAt 𝕜 c s x\nhu : DifferentiableWithinAt 𝕜 u s x\n⊢ Eq (fderivWithin 𝕜 (fun y => (c y) (u y)) s x) (HAdd.hAdd ((c x).comp (fderivWithin 𝕜 u s x)) ((fderivWithin 𝕜 c s x).flip (u x)))","decl":"theorem fderivWithin_clm_apply (hxs : UniqueDiffWithinAt 𝕜 s x)\n    (hc : DifferentiableWithinAt 𝕜 c s x) (hu : DifferentiableWithinAt 𝕜 u s x) :\n    fderivWithin 𝕜 (fun y => (c y) (u y)) s x =\n      (c x).comp (fderivWithin 𝕜 u s x) + (fderivWithin 𝕜 c s x).flip (u x) :=\n  (hc.hasFDerivWithinAt.clm_apply hu.hasFDerivWithinAt).fderivWithin hxs\n\n"}
{"name":"fderiv_clm_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nx : E\nH : Type u_5\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousLinearMap (RingHom.id 𝕜) G H\nu : E → G\nhc : DifferentiableAt 𝕜 c x\nhu : DifferentiableAt 𝕜 u x\n⊢ Eq (fderiv 𝕜 (fun y => (c y) (u y)) x) (HAdd.hAdd ((c x).comp (fderiv 𝕜 u x)) ((fderiv 𝕜 c x).flip (u x)))","decl":"theorem fderiv_clm_apply (hc : DifferentiableAt 𝕜 c x) (hu : DifferentiableAt 𝕜 u x) :\n    fderiv 𝕜 (fun y => (c y) (u y)) x = (c x).comp (fderiv 𝕜 u x) + (fderiv 𝕜 c x).flip (u x) :=\n  (hc.hasFDerivAt.clm_apply hu.hasFDerivAt).fderiv\n\n"}
{"name":"HasStrictFDerivAt.continuousMultilinear_apply_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\nx : E\nι : Type u_5\ninst✝⁴ : Fintype ι\nM : ι → Type u_6\ninst✝³ : (i : ι) → NormedAddCommGroup (M i)\ninst✝² : (i : ι) → NormedSpace 𝕜 (M i)\nH : Type u_7\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousMultilinearMap 𝕜 M H\nc' : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousMultilinearMap 𝕜 M H)\nhc : HasStrictFDerivAt c c' x\nu : (i : ι) → M i\n⊢ HasStrictFDerivAt (fun y => (c y) u) (c'.flipMultilinear u) x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.continuousMultilinear_apply_const (hc : HasStrictFDerivAt c c' x)\n    (u : ∀ i, M i) : HasStrictFDerivAt (fun y ↦ (c y) u) (c'.flipMultilinear u) x :=\n  (ContinuousMultilinearMap.apply 𝕜 M H u).hasStrictFDerivAt.comp x hc\n\n"}
{"name":"HasFDerivWithinAt.continuousMultilinear_apply_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\nx : E\ns : Set E\nι : Type u_5\ninst✝⁴ : Fintype ι\nM : ι → Type u_6\ninst✝³ : (i : ι) → NormedAddCommGroup (M i)\ninst✝² : (i : ι) → NormedSpace 𝕜 (M i)\nH : Type u_7\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousMultilinearMap 𝕜 M H\nc' : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousMultilinearMap 𝕜 M H)\nhc : HasFDerivWithinAt c c' s x\nu : (i : ι) → M i\n⊢ HasFDerivWithinAt (fun y => (c y) u) (c'.flipMultilinear u) s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.continuousMultilinear_apply_const (hc : HasFDerivWithinAt c c' s x)\n    (u : ∀ i, M i) :\n    HasFDerivWithinAt (fun y ↦ (c y) u) (c'.flipMultilinear u) s x :=\n  (ContinuousMultilinearMap.apply 𝕜 M H u).hasFDerivAt.comp_hasFDerivWithinAt x hc\n\n"}
{"name":"HasFDerivAt.continuousMultilinear_apply_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\nx : E\nι : Type u_5\ninst✝⁴ : Fintype ι\nM : ι → Type u_6\ninst✝³ : (i : ι) → NormedAddCommGroup (M i)\ninst✝² : (i : ι) → NormedSpace 𝕜 (M i)\nH : Type u_7\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousMultilinearMap 𝕜 M H\nc' : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousMultilinearMap 𝕜 M H)\nhc : HasFDerivAt c c' x\nu : (i : ι) → M i\n⊢ HasFDerivAt (fun y => (c y) u) (c'.flipMultilinear u) x","decl":"@[fun_prop]\ntheorem HasFDerivAt.continuousMultilinear_apply_const (hc : HasFDerivAt c c' x) (u : ∀ i, M i) :\n    HasFDerivAt (fun y ↦ (c y) u) (c'.flipMultilinear u) x :=\n  (ContinuousMultilinearMap.apply 𝕜 M H u).hasFDerivAt.comp x hc\n\n"}
{"name":"DifferentiableWithinAt.continuousMultilinear_apply_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\nx : E\ns : Set E\nι : Type u_5\ninst✝⁴ : Fintype ι\nM : ι → Type u_6\ninst✝³ : (i : ι) → NormedAddCommGroup (M i)\ninst✝² : (i : ι) → NormedSpace 𝕜 (M i)\nH : Type u_7\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousMultilinearMap 𝕜 M H\nhc : DifferentiableWithinAt 𝕜 c s x\nu : (i : ι) → M i\n⊢ DifferentiableWithinAt 𝕜 (fun y => (c y) u) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.continuousMultilinear_apply_const\n    (hc : DifferentiableWithinAt 𝕜 c s x) (u : ∀ i, M i) :\n    DifferentiableWithinAt 𝕜 (fun y ↦ (c y) u) s x :=\n  (hc.hasFDerivWithinAt.continuousMultilinear_apply_const u).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.continuousMultilinear_apply_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\nx : E\nι : Type u_5\ninst✝⁴ : Fintype ι\nM : ι → Type u_6\ninst✝³ : (i : ι) → NormedAddCommGroup (M i)\ninst✝² : (i : ι) → NormedSpace 𝕜 (M i)\nH : Type u_7\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousMultilinearMap 𝕜 M H\nhc : DifferentiableAt 𝕜 c x\nu : (i : ι) → M i\n⊢ DifferentiableAt 𝕜 (fun y => (c y) u) x","decl":"@[fun_prop]\ntheorem DifferentiableAt.continuousMultilinear_apply_const (hc : DifferentiableAt 𝕜 c x)\n    (u : ∀ i, M i) :\n    DifferentiableAt 𝕜 (fun y ↦ (c y) u) x :=\n  (hc.hasFDerivAt.continuousMultilinear_apply_const u).differentiableAt\n\n"}
{"name":"DifferentiableOn.continuousMultilinear_apply_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\ns : Set E\nι : Type u_5\ninst✝⁴ : Fintype ι\nM : ι → Type u_6\ninst✝³ : (i : ι) → NormedAddCommGroup (M i)\ninst✝² : (i : ι) → NormedSpace 𝕜 (M i)\nH : Type u_7\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousMultilinearMap 𝕜 M H\nhc : DifferentiableOn 𝕜 c s\nu : (i : ι) → M i\n⊢ DifferentiableOn 𝕜 (fun y => (c y) u) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.continuousMultilinear_apply_const (hc : DifferentiableOn 𝕜 c s)\n    (u : ∀ i, M i) : DifferentiableOn 𝕜 (fun y ↦ (c y) u) s :=\n  fun x hx ↦ (hc x hx).continuousMultilinear_apply_const u\n\n"}
{"name":"Differentiable.continuousMultilinear_apply_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\nι : Type u_5\ninst✝⁴ : Fintype ι\nM : ι → Type u_6\ninst✝³ : (i : ι) → NormedAddCommGroup (M i)\ninst✝² : (i : ι) → NormedSpace 𝕜 (M i)\nH : Type u_7\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousMultilinearMap 𝕜 M H\nhc : Differentiable 𝕜 c\nu : (i : ι) → M i\n⊢ Differentiable 𝕜 fun y => (c y) u","decl":"@[fun_prop]\ntheorem Differentiable.continuousMultilinear_apply_const (hc : Differentiable 𝕜 c) (u : ∀ i, M i) :\n    Differentiable 𝕜 fun y ↦ (c y) u := fun x ↦ (hc x).continuousMultilinear_apply_const u\n\n"}
{"name":"fderivWithin_continuousMultilinear_apply_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\nx : E\ns : Set E\nι : Type u_5\ninst✝⁴ : Fintype ι\nM : ι → Type u_6\ninst✝³ : (i : ι) → NormedAddCommGroup (M i)\ninst✝² : (i : ι) → NormedSpace 𝕜 (M i)\nH : Type u_7\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousMultilinearMap 𝕜 M H\nhxs : UniqueDiffWithinAt 𝕜 s x\nhc : DifferentiableWithinAt 𝕜 c s x\nu : (i : ι) → M i\n⊢ Eq (fderivWithin 𝕜 (fun y => (c y) u) s x) ((fderivWithin 𝕜 c s x).flipMultilinear u)","decl":"theorem fderivWithin_continuousMultilinear_apply_const (hxs : UniqueDiffWithinAt 𝕜 s x)\n    (hc : DifferentiableWithinAt 𝕜 c s x) (u : ∀ i, M i) :\n    fderivWithin 𝕜 (fun y ↦ (c y) u) s x = ((fderivWithin 𝕜 c s x).flipMultilinear u) :=\n  (hc.hasFDerivWithinAt.continuousMultilinear_apply_const u).fderivWithin hxs\n\n"}
{"name":"fderiv_continuousMultilinear_apply_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\nx : E\nι : Type u_5\ninst✝⁴ : Fintype ι\nM : ι → Type u_6\ninst✝³ : (i : ι) → NormedAddCommGroup (M i)\ninst✝² : (i : ι) → NormedSpace 𝕜 (M i)\nH : Type u_7\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousMultilinearMap 𝕜 M H\nhc : DifferentiableAt 𝕜 c x\nu : (i : ι) → M i\n⊢ Eq (fderiv 𝕜 (fun y => (c y) u) x) ((fderiv 𝕜 c x).flipMultilinear u)","decl":"theorem fderiv_continuousMultilinear_apply_const (hc : DifferentiableAt 𝕜 c x) (u : ∀ i, M i) :\n    (fderiv 𝕜 (fun y ↦ (c y) u) x) = (fderiv 𝕜 c x).flipMultilinear u :=\n  (hc.hasFDerivAt.continuousMultilinear_apply_const u).fderiv\n\n"}
{"name":"fderivWithin_continuousMultilinear_apply_const_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\nx : E\ns : Set E\nι : Type u_5\ninst✝⁴ : Fintype ι\nM : ι → Type u_6\ninst✝³ : (i : ι) → NormedAddCommGroup (M i)\ninst✝² : (i : ι) → NormedSpace 𝕜 (M i)\nH : Type u_7\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousMultilinearMap 𝕜 M H\nhxs : UniqueDiffWithinAt 𝕜 s x\nhc : DifferentiableWithinAt 𝕜 c s x\nu : (i : ι) → M i\nm : E\n⊢ Eq ((fderivWithin 𝕜 (fun y => (c y) u) s x) m) (((fderivWithin 𝕜 c s x) m) u)","decl":"/-- Application of a `ContinuousMultilinearMap` to a constant commutes with `fderivWithin`. -/\ntheorem fderivWithin_continuousMultilinear_apply_const_apply (hxs : UniqueDiffWithinAt 𝕜 s x)\n    (hc : DifferentiableWithinAt 𝕜 c s x) (u : ∀ i, M i) (m : E) :\n    (fderivWithin 𝕜 (fun y ↦ (c y) u) s x) m = (fderivWithin 𝕜 c s x) m u := by\n  simp [fderivWithin_continuousMultilinear_apply_const hxs hc]\n\n"}
{"name":"fderiv_continuousMultilinear_apply_const_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\nx : E\nι : Type u_5\ninst✝⁴ : Fintype ι\nM : ι → Type u_6\ninst✝³ : (i : ι) → NormedAddCommGroup (M i)\ninst✝² : (i : ι) → NormedSpace 𝕜 (M i)\nH : Type u_7\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nc : E → ContinuousMultilinearMap 𝕜 M H\nhc : DifferentiableAt 𝕜 c x\nu : (i : ι) → M i\nm : E\n⊢ Eq ((fderiv 𝕜 (fun y => (c y) u) x) m) (((fderiv 𝕜 c x) m) u)","decl":"/-- Application of a `ContinuousMultilinearMap` to a constant commutes with `fderiv`. -/\ntheorem fderiv_continuousMultilinear_apply_const_apply (hc : DifferentiableAt 𝕜 c x)\n    (u : ∀ i, M i) (m : E) :\n    (fderiv 𝕜 (fun y ↦ (c y) u) x) m = (fderiv 𝕜 c x) m u := by\n  simp [fderiv_continuousMultilinear_apply_const hc]\n\n"}
{"name":"HasStrictFDerivAt.smul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\n𝕜' : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : E → 𝕜'\nc' : ContinuousLinearMap (RingHom.id 𝕜) E 𝕜'\nhc : HasStrictFDerivAt c c' x\nhf : HasStrictFDerivAt f f' x\n⊢ HasStrictFDerivAt (fun y => HSMul.hSMul (c y) (f y)) (HAdd.hAdd (HSMul.hSMul (c x) f') (c'.smulRight (f x))) x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.smul (hc : HasStrictFDerivAt c c' x) (hf : HasStrictFDerivAt f f' x) :\n    HasStrictFDerivAt (fun y => c y • f y) (c x • f' + c'.smulRight (f x)) x :=\n  (isBoundedBilinearMap_smul.hasStrictFDerivAt (c x, f x)).comp x <| hc.prod hf\n\n"}
{"name":"HasFDerivWithinAt.smul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\n𝕜' : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : E → 𝕜'\nc' : ContinuousLinearMap (RingHom.id 𝕜) E 𝕜'\nhc : HasFDerivWithinAt c c' s x\nhf : HasFDerivWithinAt f f' s x\n⊢ HasFDerivWithinAt (fun y => HSMul.hSMul (c y) (f y)) (HAdd.hAdd (HSMul.hSMul (c x) f') (c'.smulRight (f x))) s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.smul (hc : HasFDerivWithinAt c c' s x) (hf : HasFDerivWithinAt f f' s x) :\n    HasFDerivWithinAt (fun y => c y • f y) (c x • f' + c'.smulRight (f x)) s x := by\n  exact (isBoundedBilinearMap_smul.hasFDerivAt (𝕜 := 𝕜) (c x, f x) :).comp_hasFDerivWithinAt x <|\n    hc.prod hf\n\n"}
{"name":"HasFDerivAt.smul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\n𝕜' : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : E → 𝕜'\nc' : ContinuousLinearMap (RingHom.id 𝕜) E 𝕜'\nhc : HasFDerivAt c c' x\nhf : HasFDerivAt f f' x\n⊢ HasFDerivAt (fun y => HSMul.hSMul (c y) (f y)) (HAdd.hAdd (HSMul.hSMul (c x) f') (c'.smulRight (f x))) x","decl":"@[fun_prop]\ntheorem HasFDerivAt.smul (hc : HasFDerivAt c c' x) (hf : HasFDerivAt f f' x) :\n    HasFDerivAt (fun y => c y • f y) (c x • f' + c'.smulRight (f x)) x := by\n  exact (isBoundedBilinearMap_smul.hasFDerivAt (𝕜 := 𝕜) (c x, f x) :).comp x <| hc.prod hf\n\n"}
{"name":"DifferentiableWithinAt.smul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\n𝕜' : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : E → 𝕜'\nhc : DifferentiableWithinAt 𝕜 c s x\nhf : DifferentiableWithinAt 𝕜 f s x\n⊢ DifferentiableWithinAt 𝕜 (fun y => HSMul.hSMul (c y) (f y)) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.smul (hc : DifferentiableWithinAt 𝕜 c s x)\n    (hf : DifferentiableWithinAt 𝕜 f s x) : DifferentiableWithinAt 𝕜 (fun y => c y • f y) s x :=\n  (hc.hasFDerivWithinAt.smul hf.hasFDerivWithinAt).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.smul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : E → F\nx : E\n𝕜' : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : E → 𝕜'\nhc : DifferentiableAt 𝕜 c x\nhf : DifferentiableAt 𝕜 f x\n⊢ DifferentiableAt 𝕜 (fun y => HSMul.hSMul (c y) (f y)) x","decl":"@[simp, fun_prop]\ntheorem DifferentiableAt.smul (hc : DifferentiableAt 𝕜 c x) (hf : DifferentiableAt 𝕜 f x) :\n    DifferentiableAt 𝕜 (fun y => c y • f y) x :=\n  (hc.hasFDerivAt.smul hf.hasFDerivAt).differentiableAt\n\n"}
{"name":"DifferentiableOn.smul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\n𝕜' : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : E → 𝕜'\nhc : DifferentiableOn 𝕜 c s\nhf : DifferentiableOn 𝕜 f s\n⊢ DifferentiableOn 𝕜 (fun y => HSMul.hSMul (c y) (f y)) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.smul (hc : DifferentiableOn 𝕜 c s) (hf : DifferentiableOn 𝕜 f s) :\n    DifferentiableOn 𝕜 (fun y => c y • f y) s := fun x hx => (hc x hx).smul (hf x hx)\n\n"}
{"name":"Differentiable.smul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : E → F\n𝕜' : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : E → 𝕜'\nhc : Differentiable 𝕜 c\nhf : Differentiable 𝕜 f\n⊢ Differentiable 𝕜 fun y => HSMul.hSMul (c y) (f y)","decl":"@[simp, fun_prop]\ntheorem Differentiable.smul (hc : Differentiable 𝕜 c) (hf : Differentiable 𝕜 f) :\n    Differentiable 𝕜 fun y => c y • f y := fun x => (hc x).smul (hf x)\n\n"}
{"name":"fderivWithin_smul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\n𝕜' : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : E → 𝕜'\nhxs : UniqueDiffWithinAt 𝕜 s x\nhc : DifferentiableWithinAt 𝕜 c s x\nhf : DifferentiableWithinAt 𝕜 f s x\n⊢ Eq (fderivWithin 𝕜 (fun y => HSMul.hSMul (c y) (f y)) s x) (HAdd.hAdd (HSMul.hSMul (c x) (fderivWithin 𝕜 f s x)) ((fderivWithin 𝕜 c s x).smulRight (f x)))","decl":"theorem fderivWithin_smul (hxs : UniqueDiffWithinAt 𝕜 s x) (hc : DifferentiableWithinAt 𝕜 c s x)\n    (hf : DifferentiableWithinAt 𝕜 f s x) :\n    fderivWithin 𝕜 (fun y => c y • f y) s x =\n      c x • fderivWithin 𝕜 f s x + (fderivWithin 𝕜 c s x).smulRight (f x) :=\n  (hc.hasFDerivWithinAt.smul hf.hasFDerivWithinAt).fderivWithin hxs\n\n"}
{"name":"fderiv_smul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : E → F\nx : E\n𝕜' : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : E → 𝕜'\nhc : DifferentiableAt 𝕜 c x\nhf : DifferentiableAt 𝕜 f x\n⊢ Eq (fderiv 𝕜 (fun y => HSMul.hSMul (c y) (f y)) x) (HAdd.hAdd (HSMul.hSMul (c x) (fderiv 𝕜 f x)) ((fderiv 𝕜 c x).smulRight (f x)))","decl":"theorem fderiv_smul (hc : DifferentiableAt 𝕜 c x) (hf : DifferentiableAt 𝕜 f x) :\n    fderiv 𝕜 (fun y => c y • f y) x = c x • fderiv 𝕜 f x + (fderiv 𝕜 c x).smulRight (f x) :=\n  (hc.hasFDerivAt.smul hf.hasFDerivAt).fderiv\n\n"}
{"name":"HasStrictFDerivAt.smul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nx : E\n𝕜' : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : E → 𝕜'\nc' : ContinuousLinearMap (RingHom.id 𝕜) E 𝕜'\nhc : HasStrictFDerivAt c c' x\nf : F\n⊢ HasStrictFDerivAt (fun y => HSMul.hSMul (c y) f) (c'.smulRight f) x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.smul_const (hc : HasStrictFDerivAt c c' x) (f : F) :\n    HasStrictFDerivAt (fun y => c y • f) (c'.smulRight f) x := by\n  simpa only [smul_zero, zero_add] using hc.smul (hasStrictFDerivAt_const f x)\n\n"}
{"name":"HasFDerivWithinAt.smul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nx : E\ns : Set E\n𝕜' : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : E → 𝕜'\nc' : ContinuousLinearMap (RingHom.id 𝕜) E 𝕜'\nhc : HasFDerivWithinAt c c' s x\nf : F\n⊢ HasFDerivWithinAt (fun y => HSMul.hSMul (c y) f) (c'.smulRight f) s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.smul_const (hc : HasFDerivWithinAt c c' s x) (f : F) :\n    HasFDerivWithinAt (fun y => c y • f) (c'.smulRight f) s x := by\n  simpa only [smul_zero, zero_add] using hc.smul (hasFDerivWithinAt_const f x s)\n\n"}
{"name":"HasFDerivAt.smul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nx : E\n𝕜' : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : E → 𝕜'\nc' : ContinuousLinearMap (RingHom.id 𝕜) E 𝕜'\nhc : HasFDerivAt c c' x\nf : F\n⊢ HasFDerivAt (fun y => HSMul.hSMul (c y) f) (c'.smulRight f) x","decl":"@[fun_prop]\ntheorem HasFDerivAt.smul_const (hc : HasFDerivAt c c' x) (f : F) :\n    HasFDerivAt (fun y => c y • f) (c'.smulRight f) x := by\n  simpa only [smul_zero, zero_add] using hc.smul (hasFDerivAt_const f x)\n\n"}
{"name":"DifferentiableWithinAt.smul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nx : E\ns : Set E\n𝕜' : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : E → 𝕜'\nhc : DifferentiableWithinAt 𝕜 c s x\nf : F\n⊢ DifferentiableWithinAt 𝕜 (fun y => HSMul.hSMul (c y) f) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.smul_const (hc : DifferentiableWithinAt 𝕜 c s x) (f : F) :\n    DifferentiableWithinAt 𝕜 (fun y => c y • f) s x :=\n  (hc.hasFDerivWithinAt.smul_const f).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.smul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nx : E\n𝕜' : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : E → 𝕜'\nhc : DifferentiableAt 𝕜 c x\nf : F\n⊢ DifferentiableAt 𝕜 (fun y => HSMul.hSMul (c y) f) x","decl":"@[fun_prop]\ntheorem DifferentiableAt.smul_const (hc : DifferentiableAt 𝕜 c x) (f : F) :\n    DifferentiableAt 𝕜 (fun y => c y • f) x :=\n  (hc.hasFDerivAt.smul_const f).differentiableAt\n\n"}
{"name":"DifferentiableOn.smul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ns : Set E\n𝕜' : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : E → 𝕜'\nhc : DifferentiableOn 𝕜 c s\nf : F\n⊢ DifferentiableOn 𝕜 (fun y => HSMul.hSMul (c y) f) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.smul_const (hc : DifferentiableOn 𝕜 c s) (f : F) :\n    DifferentiableOn 𝕜 (fun y => c y • f) s := fun x hx => (hc x hx).smul_const f\n\n"}
{"name":"Differentiable.smul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\n𝕜' : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : E → 𝕜'\nhc : Differentiable 𝕜 c\nf : F\n⊢ Differentiable 𝕜 fun y => HSMul.hSMul (c y) f","decl":"@[fun_prop]\ntheorem Differentiable.smul_const (hc : Differentiable 𝕜 c) (f : F) :\n    Differentiable 𝕜 fun y => c y • f := fun x => (hc x).smul_const f\n\n"}
{"name":"fderivWithin_smul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nx : E\ns : Set E\n𝕜' : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : E → 𝕜'\nhxs : UniqueDiffWithinAt 𝕜 s x\nhc : DifferentiableWithinAt 𝕜 c s x\nf : F\n⊢ Eq (fderivWithin 𝕜 (fun y => HSMul.hSMul (c y) f) s x) ((fderivWithin 𝕜 c s x).smulRight f)","decl":"theorem fderivWithin_smul_const (hxs : UniqueDiffWithinAt 𝕜 s x)\n    (hc : DifferentiableWithinAt 𝕜 c s x) (f : F) :\n    fderivWithin 𝕜 (fun y => c y • f) s x = (fderivWithin 𝕜 c s x).smulRight f :=\n  (hc.hasFDerivWithinAt.smul_const f).fderivWithin hxs\n\n"}
{"name":"fderiv_smul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nx : E\n𝕜' : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : E → 𝕜'\nhc : DifferentiableAt 𝕜 c x\nf : F\n⊢ Eq (fderiv 𝕜 (fun y => HSMul.hSMul (c y) f) x) ((fderiv 𝕜 c x).smulRight f)","decl":"theorem fderiv_smul_const (hc : DifferentiableAt 𝕜 c x) (f : F) :\n    fderiv 𝕜 (fun y => c y • f) x = (fderiv 𝕜 c x).smulRight f :=\n  (hc.hasFDerivAt.smul_const f).fderiv\n\n"}
{"name":"HasStrictFDerivAt.mul'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na b : E → 𝔸\na' b' : ContinuousLinearMap (RingHom.id 𝕜) E 𝔸\nx : E\nha : HasStrictFDerivAt a a' x\nhb : HasStrictFDerivAt b b' x\n⊢ HasStrictFDerivAt (fun y => HMul.hMul (a y) (b y)) (HAdd.hAdd (HSMul.hSMul (a x) b') (a'.smulRight (b x))) x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.mul' {x : E} (ha : HasStrictFDerivAt a a' x)\n    (hb : HasStrictFDerivAt b b' x) :\n    HasStrictFDerivAt (fun y => a y * b y) (a x • b' + a'.smulRight (b x)) x :=\n  ((ContinuousLinearMap.mul 𝕜 𝔸).isBoundedBilinearMap.hasStrictFDerivAt (a x, b x)).comp x\n    (ha.prod hb)\n\n"}
{"name":"HasStrictFDerivAt.mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\n𝔸' : Type u_6\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nc d : E → 𝔸'\nc' d' : ContinuousLinearMap (RingHom.id 𝕜) E 𝔸'\nhc : HasStrictFDerivAt c c' x\nhd : HasStrictFDerivAt d d' x\n⊢ HasStrictFDerivAt (fun y => HMul.hMul (c y) (d y)) (HAdd.hAdd (HSMul.hSMul (c x) d') (HSMul.hSMul (d x) c')) x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.mul (hc : HasStrictFDerivAt c c' x) (hd : HasStrictFDerivAt d d' x) :\n    HasStrictFDerivAt (fun y => c y * d y) (c x • d' + d x • c') x := by\n  convert hc.mul' hd\n  ext z\n  apply mul_comm\n\n"}
{"name":"HasFDerivWithinAt.mul'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\ns : Set E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na b : E → 𝔸\na' b' : ContinuousLinearMap (RingHom.id 𝕜) E 𝔸\nha : HasFDerivWithinAt a a' s x\nhb : HasFDerivWithinAt b b' s x\n⊢ HasFDerivWithinAt (fun y => HMul.hMul (a y) (b y)) (HAdd.hAdd (HSMul.hSMul (a x) b') (a'.smulRight (b x))) s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.mul' (ha : HasFDerivWithinAt a a' s x) (hb : HasFDerivWithinAt b b' s x) :\n    HasFDerivWithinAt (fun y => a y * b y) (a x • b' + a'.smulRight (b x)) s x := by\n  exact ((ContinuousLinearMap.mul 𝕜 𝔸).isBoundedBilinearMap.hasFDerivAt\n    (a x, b x)).comp_hasFDerivWithinAt x (ha.prod hb)\n\n"}
{"name":"HasFDerivWithinAt.mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\ns : Set E\n𝔸' : Type u_6\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nc d : E → 𝔸'\nc' d' : ContinuousLinearMap (RingHom.id 𝕜) E 𝔸'\nhc : HasFDerivWithinAt c c' s x\nhd : HasFDerivWithinAt d d' s x\n⊢ HasFDerivWithinAt (fun y => HMul.hMul (c y) (d y)) (HAdd.hAdd (HSMul.hSMul (c x) d') (HSMul.hSMul (d x) c')) s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.mul (hc : HasFDerivWithinAt c c' s x) (hd : HasFDerivWithinAt d d' s x) :\n    HasFDerivWithinAt (fun y => c y * d y) (c x • d' + d x • c') s x := by\n  convert hc.mul' hd\n  ext z\n  apply mul_comm\n\n"}
{"name":"HasFDerivAt.mul'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na b : E → 𝔸\na' b' : ContinuousLinearMap (RingHom.id 𝕜) E 𝔸\nha : HasFDerivAt a a' x\nhb : HasFDerivAt b b' x\n⊢ HasFDerivAt (fun y => HMul.hMul (a y) (b y)) (HAdd.hAdd (HSMul.hSMul (a x) b') (a'.smulRight (b x))) x","decl":"@[fun_prop]\ntheorem HasFDerivAt.mul' (ha : HasFDerivAt a a' x) (hb : HasFDerivAt b b' x) :\n    HasFDerivAt (fun y => a y * b y) (a x • b' + a'.smulRight (b x)) x := by\n  exact ((ContinuousLinearMap.mul 𝕜 𝔸).isBoundedBilinearMap.hasFDerivAt\n    (a x, b x)).comp x (ha.prod hb)\n\n"}
{"name":"HasFDerivAt.mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\n𝔸' : Type u_6\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nc d : E → 𝔸'\nc' d' : ContinuousLinearMap (RingHom.id 𝕜) E 𝔸'\nhc : HasFDerivAt c c' x\nhd : HasFDerivAt d d' x\n⊢ HasFDerivAt (fun y => HMul.hMul (c y) (d y)) (HAdd.hAdd (HSMul.hSMul (c x) d') (HSMul.hSMul (d x) c')) x","decl":"@[fun_prop]\ntheorem HasFDerivAt.mul (hc : HasFDerivAt c c' x) (hd : HasFDerivAt d d' x) :\n    HasFDerivAt (fun y => c y * d y) (c x • d' + d x • c') x := by\n  convert hc.mul' hd\n  ext z\n  apply mul_comm\n\n"}
{"name":"DifferentiableWithinAt.mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\ns : Set E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na b : E → 𝔸\nha : DifferentiableWithinAt 𝕜 a s x\nhb : DifferentiableWithinAt 𝕜 b s x\n⊢ DifferentiableWithinAt 𝕜 (fun y => HMul.hMul (a y) (b y)) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.mul (ha : DifferentiableWithinAt 𝕜 a s x)\n    (hb : DifferentiableWithinAt 𝕜 b s x) : DifferentiableWithinAt 𝕜 (fun y => a y * b y) s x :=\n  (ha.hasFDerivWithinAt.mul' hb.hasFDerivWithinAt).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na b : E → 𝔸\nha : DifferentiableAt 𝕜 a x\nhb : DifferentiableAt 𝕜 b x\n⊢ DifferentiableAt 𝕜 (fun y => HMul.hMul (a y) (b y)) x","decl":"@[simp, fun_prop]\ntheorem DifferentiableAt.mul (ha : DifferentiableAt 𝕜 a x) (hb : DifferentiableAt 𝕜 b x) :\n    DifferentiableAt 𝕜 (fun y => a y * b y) x :=\n  (ha.hasFDerivAt.mul' hb.hasFDerivAt).differentiableAt\n\n"}
{"name":"DifferentiableOn.mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ns : Set E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na b : E → 𝔸\nha : DifferentiableOn 𝕜 a s\nhb : DifferentiableOn 𝕜 b s\n⊢ DifferentiableOn 𝕜 (fun y => HMul.hMul (a y) (b y)) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.mul (ha : DifferentiableOn 𝕜 a s) (hb : DifferentiableOn 𝕜 b s) :\n    DifferentiableOn 𝕜 (fun y => a y * b y) s := fun x hx => (ha x hx).mul (hb x hx)\n\n"}
{"name":"Differentiable.mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na b : E → 𝔸\nha : Differentiable 𝕜 a\nhb : Differentiable 𝕜 b\n⊢ Differentiable 𝕜 fun y => HMul.hMul (a y) (b y)","decl":"@[simp, fun_prop]\ntheorem Differentiable.mul (ha : Differentiable 𝕜 a) (hb : Differentiable 𝕜 b) :\n    Differentiable 𝕜 fun y => a y * b y := fun x => (ha x).mul (hb x)\n\n"}
{"name":"DifferentiableWithinAt.pow","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\ns : Set E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\nha : DifferentiableWithinAt 𝕜 a s x\nn : Nat\n⊢ DifferentiableWithinAt 𝕜 (fun x => HPow.hPow (a x) n) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.pow (ha : DifferentiableWithinAt 𝕜 a s x) :\n    ∀ n : ℕ, DifferentiableWithinAt 𝕜 (fun x => a x ^ n) s x\n  | 0 => by simp only [pow_zero, differentiableWithinAt_const]\n  | n + 1 => by simp only [pow_succ', DifferentiableWithinAt.pow ha n, ha.mul]\n\n"}
{"name":"DifferentiableAt.pow","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\nha : DifferentiableAt 𝕜 a x\nn : Nat\n⊢ DifferentiableAt 𝕜 (fun x => HPow.hPow (a x) n) x","decl":"@[simp, fun_prop]\ntheorem DifferentiableAt.pow (ha : DifferentiableAt 𝕜 a x) (n : ℕ) :\n    DifferentiableAt 𝕜 (fun x => a x ^ n) x :=\n  differentiableWithinAt_univ.mp <| ha.differentiableWithinAt.pow n\n\n"}
{"name":"DifferentiableOn.pow","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ns : Set E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\nha : DifferentiableOn 𝕜 a s\nn : Nat\n⊢ DifferentiableOn 𝕜 (fun x => HPow.hPow (a x) n) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.pow (ha : DifferentiableOn 𝕜 a s) (n : ℕ) :\n    DifferentiableOn 𝕜 (fun x => a x ^ n) s := fun x h => (ha x h).pow n\n\n"}
{"name":"Differentiable.pow","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\nha : Differentiable 𝕜 a\nn : Nat\n⊢ Differentiable 𝕜 fun x => HPow.hPow (a x) n","decl":"@[simp, fun_prop]\ntheorem Differentiable.pow (ha : Differentiable 𝕜 a) (n : ℕ) : Differentiable 𝕜 fun x => a x ^ n :=\n  fun x => (ha x).pow n\n\n"}
{"name":"fderivWithin_mul'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\ns : Set E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na b : E → 𝔸\nhxs : UniqueDiffWithinAt 𝕜 s x\nha : DifferentiableWithinAt 𝕜 a s x\nhb : DifferentiableWithinAt 𝕜 b s x\n⊢ Eq (fderivWithin 𝕜 (fun y => HMul.hMul (a y) (b y)) s x) (HAdd.hAdd (HSMul.hSMul (a x) (fderivWithin 𝕜 b s x)) ((fderivWithin 𝕜 a s x).smulRight (b x)))","decl":"theorem fderivWithin_mul' (hxs : UniqueDiffWithinAt 𝕜 s x) (ha : DifferentiableWithinAt 𝕜 a s x)\n    (hb : DifferentiableWithinAt 𝕜 b s x) :\n    fderivWithin 𝕜 (fun y => a y * b y) s x =\n      a x • fderivWithin 𝕜 b s x + (fderivWithin 𝕜 a s x).smulRight (b x) :=\n  (ha.hasFDerivWithinAt.mul' hb.hasFDerivWithinAt).fderivWithin hxs\n\n"}
{"name":"fderivWithin_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\ns : Set E\n𝔸' : Type u_6\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nc d : E → 𝔸'\nhxs : UniqueDiffWithinAt 𝕜 s x\nhc : DifferentiableWithinAt 𝕜 c s x\nhd : DifferentiableWithinAt 𝕜 d s x\n⊢ Eq (fderivWithin 𝕜 (fun y => HMul.hMul (c y) (d y)) s x) (HAdd.hAdd (HSMul.hSMul (c x) (fderivWithin 𝕜 d s x)) (HSMul.hSMul (d x) (fderivWithin 𝕜 c s x)))","decl":"theorem fderivWithin_mul (hxs : UniqueDiffWithinAt 𝕜 s x) (hc : DifferentiableWithinAt 𝕜 c s x)\n    (hd : DifferentiableWithinAt 𝕜 d s x) :\n    fderivWithin 𝕜 (fun y => c y * d y) s x =\n      c x • fderivWithin 𝕜 d s x + d x • fderivWithin 𝕜 c s x :=\n  (hc.hasFDerivWithinAt.mul hd.hasFDerivWithinAt).fderivWithin hxs\n\n"}
{"name":"fderiv_mul'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na b : E → 𝔸\nha : DifferentiableAt 𝕜 a x\nhb : DifferentiableAt 𝕜 b x\n⊢ Eq (fderiv 𝕜 (fun y => HMul.hMul (a y) (b y)) x) (HAdd.hAdd (HSMul.hSMul (a x) (fderiv 𝕜 b x)) ((fderiv 𝕜 a x).smulRight (b x)))","decl":"theorem fderiv_mul' (ha : DifferentiableAt 𝕜 a x) (hb : DifferentiableAt 𝕜 b x) :\n    fderiv 𝕜 (fun y => a y * b y) x = a x • fderiv 𝕜 b x + (fderiv 𝕜 a x).smulRight (b x) :=\n  (ha.hasFDerivAt.mul' hb.hasFDerivAt).fderiv\n\n"}
{"name":"fderiv_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\n𝔸' : Type u_6\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nc d : E → 𝔸'\nhc : DifferentiableAt 𝕜 c x\nhd : DifferentiableAt 𝕜 d x\n⊢ Eq (fderiv 𝕜 (fun y => HMul.hMul (c y) (d y)) x) (HAdd.hAdd (HSMul.hSMul (c x) (fderiv 𝕜 d x)) (HSMul.hSMul (d x) (fderiv 𝕜 c x)))","decl":"theorem fderiv_mul (hc : DifferentiableAt 𝕜 c x) (hd : DifferentiableAt 𝕜 d x) :\n    fderiv 𝕜 (fun y => c y * d y) x = c x • fderiv 𝕜 d x + d x • fderiv 𝕜 c x :=\n  (hc.hasFDerivAt.mul hd.hasFDerivAt).fderiv\n\n"}
{"name":"HasStrictFDerivAt.mul_const'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\na' : ContinuousLinearMap (RingHom.id 𝕜) E 𝔸\nha : HasStrictFDerivAt a a' x\nb : 𝔸\n⊢ HasStrictFDerivAt (fun y => HMul.hMul (a y) b) (a'.smulRight b) x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.mul_const' (ha : HasStrictFDerivAt a a' x) (b : 𝔸) :\n    HasStrictFDerivAt (fun y => a y * b) (a'.smulRight b) x :=\n  ((ContinuousLinearMap.mul 𝕜 𝔸).flip b).hasStrictFDerivAt.comp x ha\n\n"}
{"name":"HasStrictFDerivAt.mul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\n𝔸' : Type u_6\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nc : E → 𝔸'\nc' : ContinuousLinearMap (RingHom.id 𝕜) E 𝔸'\nhc : HasStrictFDerivAt c c' x\nd : 𝔸'\n⊢ HasStrictFDerivAt (fun y => HMul.hMul (c y) d) (HSMul.hSMul d c') x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.mul_const (hc : HasStrictFDerivAt c c' x) (d : 𝔸') :\n    HasStrictFDerivAt (fun y => c y * d) (d • c') x := by\n  convert hc.mul_const' d\n  ext z\n  apply mul_comm\n\n"}
{"name":"HasFDerivWithinAt.mul_const'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\ns : Set E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\na' : ContinuousLinearMap (RingHom.id 𝕜) E 𝔸\nha : HasFDerivWithinAt a a' s x\nb : 𝔸\n⊢ HasFDerivWithinAt (fun y => HMul.hMul (a y) b) (a'.smulRight b) s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.mul_const' (ha : HasFDerivWithinAt a a' s x) (b : 𝔸) :\n    HasFDerivWithinAt (fun y => a y * b) (a'.smulRight b) s x :=\n  ((ContinuousLinearMap.mul 𝕜 𝔸).flip b).hasFDerivAt.comp_hasFDerivWithinAt x ha\n\n"}
{"name":"HasFDerivWithinAt.mul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\ns : Set E\n𝔸' : Type u_6\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nc : E → 𝔸'\nc' : ContinuousLinearMap (RingHom.id 𝕜) E 𝔸'\nhc : HasFDerivWithinAt c c' s x\nd : 𝔸'\n⊢ HasFDerivWithinAt (fun y => HMul.hMul (c y) d) (HSMul.hSMul d c') s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.mul_const (hc : HasFDerivWithinAt c c' s x) (d : 𝔸') :\n    HasFDerivWithinAt (fun y => c y * d) (d • c') s x := by\n  convert hc.mul_const' d\n  ext z\n  apply mul_comm\n\n"}
{"name":"HasFDerivAt.mul_const'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\na' : ContinuousLinearMap (RingHom.id 𝕜) E 𝔸\nha : HasFDerivAt a a' x\nb : 𝔸\n⊢ HasFDerivAt (fun y => HMul.hMul (a y) b) (a'.smulRight b) x","decl":"@[fun_prop]\ntheorem HasFDerivAt.mul_const' (ha : HasFDerivAt a a' x) (b : 𝔸) :\n    HasFDerivAt (fun y => a y * b) (a'.smulRight b) x :=\n  ((ContinuousLinearMap.mul 𝕜 𝔸).flip b).hasFDerivAt.comp x ha\n\n"}
{"name":"HasFDerivAt.mul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\n𝔸' : Type u_6\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nc : E → 𝔸'\nc' : ContinuousLinearMap (RingHom.id 𝕜) E 𝔸'\nhc : HasFDerivAt c c' x\nd : 𝔸'\n⊢ HasFDerivAt (fun y => HMul.hMul (c y) d) (HSMul.hSMul d c') x","decl":"@[fun_prop]\ntheorem HasFDerivAt.mul_const (hc : HasFDerivAt c c' x) (d : 𝔸') :\n    HasFDerivAt (fun y => c y * d) (d • c') x := by\n  convert hc.mul_const' d\n  ext z\n  apply mul_comm\n\n"}
{"name":"DifferentiableWithinAt.mul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\ns : Set E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\nha : DifferentiableWithinAt 𝕜 a s x\nb : 𝔸\n⊢ DifferentiableWithinAt 𝕜 (fun y => HMul.hMul (a y) b) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.mul_const (ha : DifferentiableWithinAt 𝕜 a s x) (b : 𝔸) :\n    DifferentiableWithinAt 𝕜 (fun y => a y * b) s x :=\n  (ha.hasFDerivWithinAt.mul_const' b).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.mul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\nha : DifferentiableAt 𝕜 a x\nb : 𝔸\n⊢ DifferentiableAt 𝕜 (fun y => HMul.hMul (a y) b) x","decl":"@[fun_prop]\ntheorem DifferentiableAt.mul_const (ha : DifferentiableAt 𝕜 a x) (b : 𝔸) :\n    DifferentiableAt 𝕜 (fun y => a y * b) x :=\n  (ha.hasFDerivAt.mul_const' b).differentiableAt\n\n"}
{"name":"DifferentiableOn.mul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ns : Set E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\nha : DifferentiableOn 𝕜 a s\nb : 𝔸\n⊢ DifferentiableOn 𝕜 (fun y => HMul.hMul (a y) b) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.mul_const (ha : DifferentiableOn 𝕜 a s) (b : 𝔸) :\n    DifferentiableOn 𝕜 (fun y => a y * b) s := fun x hx => (ha x hx).mul_const b\n\n"}
{"name":"Differentiable.mul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\nha : Differentiable 𝕜 a\nb : 𝔸\n⊢ Differentiable 𝕜 fun y => HMul.hMul (a y) b","decl":"@[fun_prop]\ntheorem Differentiable.mul_const (ha : Differentiable 𝕜 a) (b : 𝔸) :\n    Differentiable 𝕜 fun y => a y * b := fun x => (ha x).mul_const b\n\n"}
{"name":"fderivWithin_mul_const'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\ns : Set E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\nhxs : UniqueDiffWithinAt 𝕜 s x\nha : DifferentiableWithinAt 𝕜 a s x\nb : 𝔸\n⊢ Eq (fderivWithin 𝕜 (fun y => HMul.hMul (a y) b) s x) ((fderivWithin 𝕜 a s x).smulRight b)","decl":"theorem fderivWithin_mul_const' (hxs : UniqueDiffWithinAt 𝕜 s x)\n    (ha : DifferentiableWithinAt 𝕜 a s x) (b : 𝔸) :\n    fderivWithin 𝕜 (fun y => a y * b) s x = (fderivWithin 𝕜 a s x).smulRight b :=\n  (ha.hasFDerivWithinAt.mul_const' b).fderivWithin hxs\n\n"}
{"name":"fderivWithin_mul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\ns : Set E\n𝔸' : Type u_6\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nc : E → 𝔸'\nhxs : UniqueDiffWithinAt 𝕜 s x\nhc : DifferentiableWithinAt 𝕜 c s x\nd : 𝔸'\n⊢ Eq (fderivWithin 𝕜 (fun y => HMul.hMul (c y) d) s x) (HSMul.hSMul d (fderivWithin 𝕜 c s x))","decl":"theorem fderivWithin_mul_const (hxs : UniqueDiffWithinAt 𝕜 s x)\n    (hc : DifferentiableWithinAt 𝕜 c s x) (d : 𝔸') :\n    fderivWithin 𝕜 (fun y => c y * d) s x = d • fderivWithin 𝕜 c s x :=\n  (hc.hasFDerivWithinAt.mul_const d).fderivWithin hxs\n\n"}
{"name":"fderiv_mul_const'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\nha : DifferentiableAt 𝕜 a x\nb : 𝔸\n⊢ Eq (fderiv 𝕜 (fun y => HMul.hMul (a y) b) x) ((fderiv 𝕜 a x).smulRight b)","decl":"theorem fderiv_mul_const' (ha : DifferentiableAt 𝕜 a x) (b : 𝔸) :\n    fderiv 𝕜 (fun y => a y * b) x = (fderiv 𝕜 a x).smulRight b :=\n  (ha.hasFDerivAt.mul_const' b).fderiv\n\n"}
{"name":"fderiv_mul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\n𝔸' : Type u_6\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nc : E → 𝔸'\nhc : DifferentiableAt 𝕜 c x\nd : 𝔸'\n⊢ Eq (fderiv 𝕜 (fun y => HMul.hMul (c y) d) x) (HSMul.hSMul d (fderiv 𝕜 c x))","decl":"theorem fderiv_mul_const (hc : DifferentiableAt 𝕜 c x) (d : 𝔸') :\n    fderiv 𝕜 (fun y => c y * d) x = d • fderiv 𝕜 c x :=\n  (hc.hasFDerivAt.mul_const d).fderiv\n\n"}
{"name":"HasStrictFDerivAt.const_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\na' : ContinuousLinearMap (RingHom.id 𝕜) E 𝔸\nha : HasStrictFDerivAt a a' x\nb : 𝔸\n⊢ HasStrictFDerivAt (fun y => HMul.hMul b (a y)) (HSMul.hSMul b a') x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.const_mul (ha : HasStrictFDerivAt a a' x) (b : 𝔸) :\n    HasStrictFDerivAt (fun y => b * a y) (b • a') x :=\n  ((ContinuousLinearMap.mul 𝕜 𝔸) b).hasStrictFDerivAt.comp x ha\n\n"}
{"name":"HasFDerivWithinAt.const_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\ns : Set E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\na' : ContinuousLinearMap (RingHom.id 𝕜) E 𝔸\nha : HasFDerivWithinAt a a' s x\nb : 𝔸\n⊢ HasFDerivWithinAt (fun y => HMul.hMul b (a y)) (HSMul.hSMul b a') s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.const_mul (ha : HasFDerivWithinAt a a' s x) (b : 𝔸) :\n    HasFDerivWithinAt (fun y => b * a y) (b • a') s x :=\n  ((ContinuousLinearMap.mul 𝕜 𝔸) b).hasFDerivAt.comp_hasFDerivWithinAt x ha\n\n"}
{"name":"HasFDerivAt.const_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\na' : ContinuousLinearMap (RingHom.id 𝕜) E 𝔸\nha : HasFDerivAt a a' x\nb : 𝔸\n⊢ HasFDerivAt (fun y => HMul.hMul b (a y)) (HSMul.hSMul b a') x","decl":"@[fun_prop]\ntheorem HasFDerivAt.const_mul (ha : HasFDerivAt a a' x) (b : 𝔸) :\n    HasFDerivAt (fun y => b * a y) (b • a') x :=\n  ((ContinuousLinearMap.mul 𝕜 𝔸) b).hasFDerivAt.comp x ha\n\n"}
{"name":"DifferentiableWithinAt.const_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\ns : Set E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\nha : DifferentiableWithinAt 𝕜 a s x\nb : 𝔸\n⊢ DifferentiableWithinAt 𝕜 (fun y => HMul.hMul b (a y)) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.const_mul (ha : DifferentiableWithinAt 𝕜 a s x) (b : 𝔸) :\n    DifferentiableWithinAt 𝕜 (fun y => b * a y) s x :=\n  (ha.hasFDerivWithinAt.const_mul b).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.const_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\nha : DifferentiableAt 𝕜 a x\nb : 𝔸\n⊢ DifferentiableAt 𝕜 (fun y => HMul.hMul b (a y)) x","decl":"@[fun_prop]\ntheorem DifferentiableAt.const_mul (ha : DifferentiableAt 𝕜 a x) (b : 𝔸) :\n    DifferentiableAt 𝕜 (fun y => b * a y) x :=\n  (ha.hasFDerivAt.const_mul b).differentiableAt\n\n"}
{"name":"DifferentiableOn.const_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ns : Set E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\nha : DifferentiableOn 𝕜 a s\nb : 𝔸\n⊢ DifferentiableOn 𝕜 (fun y => HMul.hMul b (a y)) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.const_mul (ha : DifferentiableOn 𝕜 a s) (b : 𝔸) :\n    DifferentiableOn 𝕜 (fun y => b * a y) s := fun x hx => (ha x hx).const_mul b\n\n"}
{"name":"Differentiable.const_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\nha : Differentiable 𝕜 a\nb : 𝔸\n⊢ Differentiable 𝕜 fun y => HMul.hMul b (a y)","decl":"@[fun_prop]\ntheorem Differentiable.const_mul (ha : Differentiable 𝕜 a) (b : 𝔸) :\n    Differentiable 𝕜 fun y => b * a y := fun x => (ha x).const_mul b\n\n"}
{"name":"fderivWithin_const_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\ns : Set E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\nhxs : UniqueDiffWithinAt 𝕜 s x\nha : DifferentiableWithinAt 𝕜 a s x\nb : 𝔸\n⊢ Eq (fderivWithin 𝕜 (fun y => HMul.hMul b (a y)) s x) (HSMul.hSMul b (fderivWithin 𝕜 a s x))","decl":"theorem fderivWithin_const_mul (hxs : UniqueDiffWithinAt 𝕜 s x)\n    (ha : DifferentiableWithinAt 𝕜 a s x) (b : 𝔸) :\n    fderivWithin 𝕜 (fun y => b * a y) s x = b • fderivWithin 𝕜 a s x :=\n  (ha.hasFDerivWithinAt.const_mul b).fderivWithin hxs\n\n"}
{"name":"fderiv_const_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\n𝔸 : Type u_5\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\na : E → 𝔸\nha : DifferentiableAt 𝕜 a x\nb : 𝔸\n⊢ Eq (fderiv 𝕜 (fun y => HMul.hMul b (a y)) x) (HSMul.hSMul b (fderiv 𝕜 a x))","decl":"theorem fderiv_const_mul (ha : DifferentiableAt 𝕜 a x) (b : 𝔸) :\n    fderiv 𝕜 (fun y => b * a y) x = b • fderiv 𝕜 a x :=\n  (ha.hasFDerivAt.const_mul b).fderiv\n\n"}
{"name":"hasStrictFDerivAt_list_prod'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nι : Type u_5\n𝔸 : Type u_6\ninst✝² : NormedRing 𝔸\ninst✝¹ : NormedAlgebra 𝕜 𝔸\ninst✝ : Fintype ι\nl : List ι\nx : ι → 𝔸\n⊢ HasStrictFDerivAt (fun x => (List.map x l).prod) (Finset.univ.sum fun i => HSMul.hSMul (List.map x (List.take (↑i) l)).prod ((ContinuousLinearMap.proj (GetElem.getElem l i ⋯)).smulRight (List.map x (List.drop (↑i).succ l)).prod)) x","decl":"@[fun_prop]\ntheorem hasStrictFDerivAt_list_prod' [Fintype ι] {l : List ι} {x : ι → 𝔸} :\n    HasStrictFDerivAt (𝕜 := 𝕜) (fun x ↦ (l.map x).prod)\n      (∑ i : Fin l.length, ((l.take i).map x).prod •\n        smulRight (proj l[i]) ((l.drop (.succ i)).map x).prod) x := by\n  induction l with\n  | nil => simp [hasStrictFDerivAt_const]\n  | cons a l IH =>\n    simp only [List.map_cons, List.prod_cons, ← proj_apply (R := 𝕜) (φ := fun _ : ι ↦ 𝔸) a]\n    exact .congr_fderiv (.mul' (ContinuousLinearMap.hasStrictFDerivAt _) IH)\n      (by ext; simp [Fin.sum_univ_succ, Finset.mul_sum, mul_assoc, add_comm])\n\n"}
{"name":"hasStrictFDerivAt_list_prod_finRange'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\n𝔸 : Type u_6\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nn : Nat\nx : Fin n → 𝔸\n⊢ HasStrictFDerivAt (fun x => (List.map x (List.finRange n)).prod) (Finset.univ.sum fun i => HSMul.hSMul (List.map x (List.take (↑i) (List.finRange n))).prod ((ContinuousLinearMap.proj i).smulRight (List.map x (List.drop (↑i).succ (List.finRange n))).prod)) x","decl":"@[fun_prop]\ntheorem hasStrictFDerivAt_list_prod_finRange' {n : ℕ} {x : Fin n → 𝔸} :\n    HasStrictFDerivAt (𝕜 := 𝕜) (fun x ↦ ((List.finRange n).map x).prod)\n      (∑ i : Fin n, (((List.finRange n).take i).map x).prod •\n        smulRight (proj i) (((List.finRange n).drop (.succ i)).map x).prod) x :=\n  hasStrictFDerivAt_list_prod'.congr_fderiv <|\n    Finset.sum_equiv (finCongr (List.length_finRange n)) (by simp) (by simp [Fin.forall_iff])\n\n"}
{"name":"hasStrictFDerivAt_list_prod_attach'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nι : Type u_5\n𝔸 : Type u_6\ninst✝² : NormedRing 𝔸\ninst✝¹ : NormedAlgebra 𝕜 𝔸\ninst✝ : DecidableEq ι\nl : List ι\nx : (Subtype fun i => Membership.mem l i) → 𝔸\n⊢ HasStrictFDerivAt (fun x => (List.map x l.attach).prod) (Finset.univ.sum fun i => HSMul.hSMul (List.map x (List.take (↑i) l.attach)).prod ((ContinuousLinearMap.proj (GetElem.getElem l.attach (Fin.cast ⋯ i) ⋯)).smulRight (List.map x (List.drop (↑i).succ l.attach)).prod)) x","decl":"@[fun_prop]\ntheorem hasStrictFDerivAt_list_prod_attach' [DecidableEq ι] {l : List ι} {x : {i // i ∈ l} → 𝔸} :\n    HasStrictFDerivAt (𝕜 := 𝕜) (fun x ↦ (l.attach.map x).prod)\n      (∑ i : Fin l.length, ((l.attach.take i).map x).prod •\n        smulRight (proj l.attach[i.cast List.length_attach.symm])\n          ((l.attach.drop (.succ i)).map x).prod) x :=\n  hasStrictFDerivAt_list_prod'.congr_fderiv <| Eq.symm <|\n    Finset.sum_equiv (finCongr List.length_attach.symm) (by simp) (by simp)\n\n"}
{"name":"hasFDerivAt_list_prod'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nι : Type u_5\n𝔸' : Type u_7\ninst✝² : NormedCommRing 𝔸'\ninst✝¹ : NormedAlgebra 𝕜 𝔸'\ninst✝ : Fintype ι\nl : List ι\nx : ι → 𝔸'\n⊢ HasFDerivAt (fun x => (List.map x l).prod) (Finset.univ.sum fun i => HSMul.hSMul (List.map x (List.take (↑i) l)).prod ((ContinuousLinearMap.proj (GetElem.getElem l i ⋯)).smulRight (List.map x (List.drop (↑i).succ l)).prod)) x","decl":"@[fun_prop]\ntheorem hasFDerivAt_list_prod' [Fintype ι] {l : List ι} {x : ι → 𝔸'} :\n    HasFDerivAt (𝕜 := 𝕜) (fun x ↦ (l.map x).prod)\n      (∑ i : Fin l.length, ((l.take i).map x).prod •\n        smulRight (proj l[i]) ((l.drop (.succ i)).map x).prod) x :=\n  hasStrictFDerivAt_list_prod'.hasFDerivAt\n\n"}
{"name":"hasFDerivAt_list_prod_finRange'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\n𝔸 : Type u_6\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nn : Nat\nx : Fin n → 𝔸\n⊢ HasFDerivAt (fun x => (List.map x (List.finRange n)).prod) (Finset.univ.sum fun i => HSMul.hSMul (List.map x (List.take (↑i) (List.finRange n))).prod ((ContinuousLinearMap.proj i).smulRight (List.map x (List.drop (↑i).succ (List.finRange n))).prod)) x","decl":"@[fun_prop]\ntheorem hasFDerivAt_list_prod_finRange' {n : ℕ} {x : Fin n → 𝔸} :\n    HasFDerivAt (𝕜 := 𝕜) (fun x ↦ ((List.finRange n).map x).prod)\n      (∑ i : Fin n, (((List.finRange n).take i).map x).prod •\n        smulRight (proj i) (((List.finRange n).drop (.succ i)).map x).prod) x :=\n  (hasStrictFDerivAt_list_prod_finRange').hasFDerivAt\n\n"}
{"name":"hasFDerivAt_list_prod_attach'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nι : Type u_5\n𝔸 : Type u_6\ninst✝² : NormedRing 𝔸\ninst✝¹ : NormedAlgebra 𝕜 𝔸\ninst✝ : DecidableEq ι\nl : List ι\nx : (Subtype fun i => Membership.mem l i) → 𝔸\n⊢ HasFDerivAt (fun x => (List.map x l.attach).prod) (Finset.univ.sum fun i => HSMul.hSMul (List.map x (List.take (↑i) l.attach)).prod ((ContinuousLinearMap.proj (GetElem.getElem l.attach (Fin.cast ⋯ i) ⋯)).smulRight (List.map x (List.drop (↑i).succ l.attach)).prod)) x","decl":"@[fun_prop]\ntheorem hasFDerivAt_list_prod_attach' [DecidableEq ι] {l : List ι} {x : {i // i ∈ l} → 𝔸} :\n    HasFDerivAt (𝕜 := 𝕜) (fun x ↦ (l.attach.map x).prod)\n      (∑ i : Fin l.length, ((l.attach.take i).map x).prod •\n        smulRight (proj l.attach[i.cast List.length_attach.symm])\n          ((l.attach.drop (.succ i)).map x).prod) x :=\n  hasStrictFDerivAt_list_prod_attach'.hasFDerivAt\n\n"}
{"name":"hasStrictFDerivAt_list_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nι : Type u_5\n𝔸' : Type u_7\ninst✝³ : NormedCommRing 𝔸'\ninst✝² : NormedAlgebra 𝕜 𝔸'\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nl : List ι\nx : ι → 𝔸'\n⊢ HasStrictFDerivAt (fun x => (List.map x l).prod) (List.map (fun i => HSMul.hSMul (List.map x (l.erase i)).prod (ContinuousLinearMap.proj i)) l).sum x","decl":"/--\nAuxiliary lemma for `hasStrictFDerivAt_multiset_prod`.\n\nFor `NormedCommRing 𝔸'`, can rewrite as `Multiset` using `Multiset.prod_coe`.\n-/\n@[fun_prop]\ntheorem hasStrictFDerivAt_list_prod [DecidableEq ι] [Fintype ι] {l : List ι} {x : ι → 𝔸'} :\n    HasStrictFDerivAt (𝕜 := 𝕜) (fun x ↦ (l.map x).prod)\n      (l.map fun i ↦ ((l.erase i).map x).prod • proj i).sum x := by\n  refine hasStrictFDerivAt_list_prod'.congr_fderiv ?_\n  conv_rhs => arg 1; arg 2; rw [← List.finRange_map_get l]\n  simp only [List.map_map, ← List.sum_toFinset _ (List.nodup_finRange _), List.toFinset_finRange,\n    Function.comp_def, ((List.erase_getElem _).map _).prod_eq, List.eraseIdx_eq_take_drop_succ,\n    List.map_append, List.prod_append, List.get_eq_getElem, Fin.getElem_fin, Nat.succ_eq_add_one]\n  exact Finset.sum_congr rfl fun i _ ↦ by\n    ext; simp only [smul_apply, smulRight_apply, smul_eq_mul]; ring\n\n"}
{"name":"hasStrictFDerivAt_multiset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nι : Type u_5\n𝔸' : Type u_7\ninst✝³ : NormedCommRing 𝔸'\ninst✝² : NormedAlgebra 𝕜 𝔸'\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nu : Multiset ι\nx : ι → 𝔸'\n⊢ HasStrictFDerivAt (fun x => (Multiset.map x u).prod) (Multiset.map (fun i => HSMul.hSMul (Multiset.map x (u.erase i)).prod (ContinuousLinearMap.proj i)) u).sum x","decl":"@[fun_prop]\ntheorem hasStrictFDerivAt_multiset_prod [DecidableEq ι] [Fintype ι] {u : Multiset ι} {x : ι → 𝔸'} :\n    HasStrictFDerivAt (𝕜 := 𝕜) (fun x ↦ (u.map x).prod)\n      (u.map (fun i ↦ ((u.erase i).map x).prod • proj i)).sum x :=\n  u.inductionOn fun l ↦ by simpa using hasStrictFDerivAt_list_prod\n\n"}
{"name":"hasFDerivAt_multiset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nι : Type u_5\n𝔸' : Type u_7\ninst✝³ : NormedCommRing 𝔸'\ninst✝² : NormedAlgebra 𝕜 𝔸'\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nu : Multiset ι\nx : ι → 𝔸'\n⊢ HasFDerivAt (fun x => (Multiset.map x u).prod) (Multiset.map (fun i => HSMul.hSMul (Multiset.map x (u.erase i)).prod (ContinuousLinearMap.proj i)) u).sum x","decl":"@[fun_prop]\ntheorem hasFDerivAt_multiset_prod [DecidableEq ι] [Fintype ι] {u : Multiset ι} {x : ι → 𝔸'} :\n    HasFDerivAt (𝕜 := 𝕜) (fun x ↦ (u.map x).prod)\n      (Multiset.sum (u.map (fun i ↦ ((u.erase i).map x).prod • proj i))) x :=\n  hasStrictFDerivAt_multiset_prod.hasFDerivAt\n\n"}
{"name":"hasStrictFDerivAt_finset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nι : Type u_5\n𝔸' : Type u_7\ninst✝³ : NormedCommRing 𝔸'\ninst✝² : NormedAlgebra 𝕜 𝔸'\nu : Finset ι\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nx : ι → 𝔸'\n⊢ HasStrictFDerivAt (fun x => u.prod fun i => x i) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => x j) (ContinuousLinearMap.proj i)) x","decl":"theorem hasStrictFDerivAt_finset_prod [DecidableEq ι] [Fintype ι] {x : ι → 𝔸'} :\n    HasStrictFDerivAt (𝕜 := 𝕜) (∏ i ∈ u, · i) (∑ i ∈ u, (∏ j ∈ u.erase i, x j) • proj i) x := by\n  simp only [Finset.sum_eq_multiset_sum, Finset.prod_eq_multiset_prod]\n  exact hasStrictFDerivAt_multiset_prod\n\n"}
{"name":"hasFDerivAt_finset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nι : Type u_5\n𝔸' : Type u_7\ninst✝³ : NormedCommRing 𝔸'\ninst✝² : NormedAlgebra 𝕜 𝔸'\nu : Finset ι\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nx : ι → 𝔸'\n⊢ HasFDerivAt (fun x => u.prod fun i => x i) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => x j) (ContinuousLinearMap.proj i)) x","decl":"theorem hasFDerivAt_finset_prod [DecidableEq ι] [Fintype ι] {x : ι → 𝔸'} :\n    HasFDerivAt (𝕜 := 𝕜) (∏ i ∈ u, · i) (∑ i ∈ u, (∏ j ∈ u.erase i, x j) • proj i) x :=\n  hasStrictFDerivAt_finset_prod.hasFDerivAt\n\n"}
{"name":"HasStrictFDerivAt.list_prod'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nι : Type u_5\n𝔸 : Type u_6\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nf : ι → E → 𝔸\nf' : ι → ContinuousLinearMap (RingHom.id 𝕜) E 𝔸\nl : List ι\nx : E\nh : ∀ (i : ι), Membership.mem l i → HasStrictFDerivAt (fun x => f i x) (f' i) x\n⊢ HasStrictFDerivAt (fun x => (List.map (fun x_1 => f x_1 x) l).prod) (Finset.univ.sum fun i => HSMul.hSMul (List.map (fun x_1 => f x_1 x) (List.take (↑i) l)).prod ((f' (GetElem.getElem l i ⋯)).smulRight (List.map (fun x_1 => f x_1 x) (List.drop (↑i).succ l)).prod)) x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.list_prod' {l : List ι} {x : E}\n    (h : ∀ i ∈ l, HasStrictFDerivAt (f i ·) (f' i) x) :\n    HasStrictFDerivAt (fun x ↦ (l.map (f · x)).prod)\n      (∑ i : Fin l.length, ((l.take i).map (f · x)).prod •\n        smulRight (f' l[i]) ((l.drop (.succ i)).map (f · x)).prod) x := by\n  simp_rw [Fin.getElem_fin, ← l.get_eq_getElem, ← List.finRange_map_get l, List.map_map]\n  -- After #19108, we have to be optimistic with `:)`s; otherwise Lean decides it need to find\n  -- `NormedAddCommGroup (List 𝔸)` which is nonsense.\n  refine .congr_fderiv (hasStrictFDerivAt_list_prod_finRange'.comp x\n    (hasStrictFDerivAt_pi.mpr fun i ↦ h (l.get i) (List.getElem_mem ..)) :) ?_\n  ext m\n  simp_rw [List.map_take, List.map_drop, List.map_map, comp_apply, sum_apply, smul_apply,\n    smulRight_apply, proj_apply, pi_apply, Function.comp_def]\n\n"}
{"name":"HasFDerivAt.list_prod'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nι : Type u_5\n𝔸 : Type u_6\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nf : ι → E → 𝔸\nf' : ι → ContinuousLinearMap (RingHom.id 𝕜) E 𝔸\nl : List ι\nx : E\nh : ∀ (i : ι), Membership.mem l i → HasFDerivAt (fun x => f i x) (f' i) x\n⊢ HasFDerivAt (fun x => (List.map (fun x_1 => f x_1 x) l).prod) (Finset.univ.sum fun i => HSMul.hSMul (List.map (fun x_1 => f x_1 x) (List.take (↑i) l)).prod ((f' (GetElem.getElem l i ⋯)).smulRight (List.map (fun x_1 => f x_1 x) (List.drop (↑i).succ l)).prod)) x","decl":"/--\nUnlike `HasFDerivAt.finset_prod`, supports non-commutative multiply and duplicate elements.\n-/\n@[fun_prop]\ntheorem HasFDerivAt.list_prod' {l : List ι} {x : E}\n    (h : ∀ i ∈ l, HasFDerivAt (f i ·) (f' i) x) :\n    HasFDerivAt (fun x ↦ (l.map (f · x)).prod)\n      (∑ i : Fin l.length, ((l.take i).map (f · x)).prod •\n        smulRight (f' l[i]) ((l.drop (.succ i)).map (f · x)).prod) x := by\n  simp_rw [Fin.getElem_fin, ← l.get_eq_getElem, ← List.finRange_map_get l, List.map_map]\n  refine .congr_fderiv (hasFDerivAt_list_prod_finRange'.comp x\n    (hasFDerivAt_pi.mpr fun i ↦ h (l.get i) (l.get_mem i)) :) ?_\n  ext m\n  simp_rw [List.map_take, List.map_drop, List.map_map, comp_apply, sum_apply, smul_apply,\n    smulRight_apply, proj_apply, pi_apply, Function.comp_def]\n\n"}
{"name":"HasFDerivWithinAt.list_prod'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ns : Set E\nι : Type u_5\n𝔸 : Type u_6\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nf : ι → E → 𝔸\nf' : ι → ContinuousLinearMap (RingHom.id 𝕜) E 𝔸\nl : List ι\nx : E\nh : ∀ (i : ι), Membership.mem l i → HasFDerivWithinAt (fun x => f i x) (f' i) s x\n⊢ HasFDerivWithinAt (fun x => (List.map (fun x_1 => f x_1 x) l).prod) (Finset.univ.sum fun i => HSMul.hSMul (List.map (fun x_1 => f x_1 x) (List.take (↑i) l)).prod ((f' (GetElem.getElem l i ⋯)).smulRight (List.map (fun x_1 => f x_1 x) (List.drop (↑i).succ l)).prod)) s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.list_prod' {l : List ι} {x : E}\n    (h : ∀ i ∈ l, HasFDerivWithinAt (f i ·) (f' i) s x) :\n    HasFDerivWithinAt (fun x ↦ (l.map (f · x)).prod)\n      (∑ i : Fin l.length, ((l.take i).map (f · x)).prod •\n        smulRight (f' l[i]) ((l.drop (.succ i)).map (f · x)).prod) s x := by\n  simp_rw [Fin.getElem_fin, ← l.get_eq_getElem, ← List.finRange_map_get l, List.map_map]\n  refine .congr_fderiv (hasFDerivAt_list_prod_finRange'.comp_hasFDerivWithinAt x\n    (hasFDerivWithinAt_pi.mpr fun i ↦ h (l.get i) (l.get_mem i)) :) ?_\n  ext m\n  simp_rw [List.map_take, List.map_drop, List.map_map, comp_apply, sum_apply, smul_apply,\n    smulRight_apply, proj_apply, pi_apply, Function.comp_def]\n\n"}
{"name":"fderiv_list_prod'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nι : Type u_5\n𝔸 : Type u_6\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nf : ι → E → 𝔸\nl : List ι\nx : E\nh : ∀ (i : ι), Membership.mem l i → DifferentiableAt 𝕜 (fun x => f i x) x\n⊢ Eq (fderiv 𝕜 (fun x => (List.map (fun x_1 => f x_1 x) l).prod) x) (Finset.univ.sum fun i => HSMul.hSMul (List.map (fun x_1 => f x_1 x) (List.take (↑i) l)).prod ((fderiv 𝕜 (fun x => f (GetElem.getElem l i ⋯) x) x).smulRight (List.map (fun x_1 => f x_1 x) (List.drop (↑i).succ l)).prod))","decl":"theorem fderiv_list_prod' {l : List ι} {x : E}\n    (h : ∀ i ∈ l, DifferentiableAt 𝕜 (f i ·) x) :\n    fderiv 𝕜 (fun x ↦ (l.map (f · x)).prod) x =\n      ∑ i : Fin l.length, ((l.take i).map (f · x)).prod •\n        smulRight (fderiv 𝕜 (fun x ↦ f l[i] x) x) ((l.drop (.succ i)).map (f · x)).prod :=\n  (HasFDerivAt.list_prod' fun i hi ↦ (h i hi).hasFDerivAt).fderiv\n\n"}
{"name":"fderivWithin_list_prod'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ns : Set E\nι : Type u_5\n𝔸 : Type u_6\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nf : ι → E → 𝔸\nl : List ι\nx : E\nhxs : UniqueDiffWithinAt 𝕜 s x\nh : ∀ (i : ι), Membership.mem l i → DifferentiableWithinAt 𝕜 (fun x => f i x) s x\n⊢ Eq (fderivWithin 𝕜 (fun x => (List.map (fun x_1 => f x_1 x) l).prod) s x) (Finset.univ.sum fun i => HSMul.hSMul (List.map (fun x_1 => f x_1 x) (List.take (↑i) l)).prod ((fderivWithin 𝕜 (fun x => f (GetElem.getElem l i ⋯) x) s x).smulRight (List.map (fun x_1 => f x_1 x) (List.drop (↑i).succ l)).prod))","decl":"theorem fderivWithin_list_prod' {l : List ι} {x : E}\n    (hxs : UniqueDiffWithinAt 𝕜 s x) (h : ∀ i ∈ l, DifferentiableWithinAt 𝕜 (f i ·) s x) :\n    fderivWithin 𝕜 (fun x ↦ (l.map (f · x)).prod) s x =\n      ∑ i : Fin l.length, ((l.take i).map (f · x)).prod •\n        smulRight (fderivWithin 𝕜 (fun x ↦ f l[i] x) s x) ((l.drop (.succ i)).map (f · x)).prod :=\n  (HasFDerivWithinAt.list_prod' fun i hi ↦ (h i hi).hasFDerivWithinAt).fderivWithin hxs\n\n"}
{"name":"HasStrictFDerivAt.multiset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_5\n𝔸' : Type u_7\ninst✝² : NormedCommRing 𝔸'\ninst✝¹ : NormedAlgebra 𝕜 𝔸'\ng : ι → E → 𝔸'\ng' : ι → ContinuousLinearMap (RingHom.id 𝕜) E 𝔸'\ninst✝ : DecidableEq ι\nu : Multiset ι\nx : E\nh : ∀ (i : ι), Membership.mem u i → HasStrictFDerivAt (fun x => g i x) (g' i) x\n⊢ HasStrictFDerivAt (fun x => (Multiset.map (fun x_1 => g x_1 x) u).prod) (Multiset.map (fun i => HSMul.hSMul (Multiset.map (fun x_1 => g x_1 x) (u.erase i)).prod (g' i)) u).sum x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.multiset_prod [DecidableEq ι] {u : Multiset ι} {x : E}\n    (h : ∀ i ∈ u, HasStrictFDerivAt (g i ·) (g' i) x) :\n    HasStrictFDerivAt (fun x ↦ (u.map (g · x)).prod)\n      (u.map fun i ↦ ((u.erase i).map (g · x)).prod • g' i).sum x := by\n  simp only [← Multiset.attach_map_val u, Multiset.map_map]\n  exact .congr_fderiv\n    (hasStrictFDerivAt_multiset_prod.comp x <|\n      hasStrictFDerivAt_pi.mpr fun i ↦ h (Subtype.val i) i.prop :)\n    (by ext; simp [Finset.sum_multiset_map_count, u.erase_attach_map (g · x)])\n\n"}
{"name":"HasFDerivAt.multiset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_5\n𝔸' : Type u_7\ninst✝² : NormedCommRing 𝔸'\ninst✝¹ : NormedAlgebra 𝕜 𝔸'\ng : ι → E → 𝔸'\ng' : ι → ContinuousLinearMap (RingHom.id 𝕜) E 𝔸'\ninst✝ : DecidableEq ι\nu : Multiset ι\nx : E\nh : ∀ (i : ι), Membership.mem u i → HasFDerivAt (fun x => g i x) (g' i) x\n⊢ HasFDerivAt (fun x => (Multiset.map (fun x_1 => g x_1 x) u).prod) (Multiset.map (fun i => HSMul.hSMul (Multiset.map (fun x_1 => g x_1 x) (u.erase i)).prod (g' i)) u).sum x","decl":"/--\nUnlike `HasFDerivAt.finset_prod`, supports duplicate elements.\n-/\n@[fun_prop]\ntheorem HasFDerivAt.multiset_prod [DecidableEq ι] {u : Multiset ι} {x : E}\n    (h : ∀ i ∈ u, HasFDerivAt (g i ·) (g' i) x) :\n    HasFDerivAt (fun x ↦ (u.map (g · x)).prod)\n      (u.map fun i ↦ ((u.erase i).map (g · x)).prod • g' i).sum x := by\n  simp only [← Multiset.attach_map_val u, Multiset.map_map]\n  exact .congr_fderiv\n    (hasFDerivAt_multiset_prod.comp x <| hasFDerivAt_pi.mpr fun i ↦ h (Subtype.val i) i.prop :)\n    (by ext; simp [Finset.sum_multiset_map_count, u.erase_attach_map (g · x)])\n\n"}
{"name":"HasFDerivWithinAt.multiset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ns : Set E\nι : Type u_5\n𝔸' : Type u_7\ninst✝² : NormedCommRing 𝔸'\ninst✝¹ : NormedAlgebra 𝕜 𝔸'\ng : ι → E → 𝔸'\ng' : ι → ContinuousLinearMap (RingHom.id 𝕜) E 𝔸'\ninst✝ : DecidableEq ι\nu : Multiset ι\nx : E\nh : ∀ (i : ι), Membership.mem u i → HasFDerivWithinAt (fun x => g i x) (g' i) s x\n⊢ HasFDerivWithinAt (fun x => (Multiset.map (fun x_1 => g x_1 x) u).prod) (Multiset.map (fun i => HSMul.hSMul (Multiset.map (fun x_1 => g x_1 x) (u.erase i)).prod (g' i)) u).sum s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.multiset_prod [DecidableEq ι] {u : Multiset ι} {x : E}\n    (h : ∀ i ∈ u, HasFDerivWithinAt (g i ·) (g' i) s x) :\n    HasFDerivWithinAt (fun x ↦ (u.map (g · x)).prod)\n      (u.map fun i ↦ ((u.erase i).map (g · x)).prod • g' i).sum s x := by\n  simp only [← Multiset.attach_map_val u, Multiset.map_map]\n  exact .congr_fderiv\n    (hasFDerivAt_multiset_prod.comp_hasFDerivWithinAt x <|\n      hasFDerivWithinAt_pi.mpr fun i ↦ h (Subtype.val i) i.prop :)\n    (by ext; simp [Finset.sum_multiset_map_count, u.erase_attach_map (g · x)])\n\n"}
{"name":"fderiv_multiset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_5\n𝔸' : Type u_7\ninst✝² : NormedCommRing 𝔸'\ninst✝¹ : NormedAlgebra 𝕜 𝔸'\ng : ι → E → 𝔸'\ninst✝ : DecidableEq ι\nu : Multiset ι\nx : E\nh : ∀ (i : ι), Membership.mem u i → DifferentiableAt 𝕜 (fun x => g i x) x\n⊢ Eq (fderiv 𝕜 (fun x => (Multiset.map (fun x_1 => g x_1 x) u).prod) x) (Multiset.map (fun i => HSMul.hSMul (Multiset.map (fun x_1 => g x_1 x) (u.erase i)).prod (fderiv 𝕜 (g i) x)) u).sum","decl":"theorem fderiv_multiset_prod [DecidableEq ι] {u : Multiset ι} {x : E}\n    (h : ∀ i ∈ u, DifferentiableAt 𝕜 (g i ·) x) :\n    fderiv 𝕜 (fun x ↦ (u.map (g · x)).prod) x =\n      (u.map fun i ↦ ((u.erase i).map (g · x)).prod • fderiv 𝕜 (g i) x).sum :=\n  (HasFDerivAt.multiset_prod fun i hi ↦ (h i hi).hasFDerivAt).fderiv\n\n"}
{"name":"fderivWithin_multiset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ns : Set E\nι : Type u_5\n𝔸' : Type u_7\ninst✝² : NormedCommRing 𝔸'\ninst✝¹ : NormedAlgebra 𝕜 𝔸'\ng : ι → E → 𝔸'\ninst✝ : DecidableEq ι\nu : Multiset ι\nx : E\nhxs : UniqueDiffWithinAt 𝕜 s x\nh : ∀ (i : ι), Membership.mem u i → DifferentiableWithinAt 𝕜 (fun x => g i x) s x\n⊢ Eq (fderivWithin 𝕜 (fun x => (Multiset.map (fun x_1 => g x_1 x) u).prod) s x) (Multiset.map (fun i => HSMul.hSMul (Multiset.map (fun x_1 => g x_1 x) (u.erase i)).prod (fderivWithin 𝕜 (g i) s x)) u).sum","decl":"theorem fderivWithin_multiset_prod [DecidableEq ι] {u : Multiset ι} {x : E}\n    (hxs : UniqueDiffWithinAt 𝕜 s x) (h : ∀ i ∈ u, DifferentiableWithinAt 𝕜 (g i ·) s x) :\n    fderivWithin 𝕜 (fun x ↦ (u.map (g · x)).prod) s x =\n      (u.map fun i ↦ ((u.erase i).map (g · x)).prod • fderivWithin 𝕜 (g i) s x).sum :=\n  (HasFDerivWithinAt.multiset_prod fun i hi ↦ (h i hi).hasFDerivWithinAt).fderivWithin hxs\n\n"}
{"name":"HasStrictFDerivAt.finset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_5\n𝔸' : Type u_7\ninst✝² : NormedCommRing 𝔸'\ninst✝¹ : NormedAlgebra 𝕜 𝔸'\nu : Finset ι\ng : ι → E → 𝔸'\ng' : ι → ContinuousLinearMap (RingHom.id 𝕜) E 𝔸'\ninst✝ : DecidableEq ι\nx : E\nhg : ∀ (i : ι), Membership.mem u i → HasStrictFDerivAt (g i) (g' i) x\n⊢ HasStrictFDerivAt (fun x => u.prod fun i => g i x) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => g j x) (g' i)) x","decl":"theorem HasStrictFDerivAt.finset_prod [DecidableEq ι] {x : E}\n    (hg : ∀ i ∈ u, HasStrictFDerivAt (g i) (g' i) x) :\n    HasStrictFDerivAt (∏ i ∈ u, g i ·) (∑ i ∈ u, (∏ j ∈ u.erase i, g j x) • g' i) x := by\n  simpa [← Finset.prod_attach u] using .congr_fderiv\n    (hasStrictFDerivAt_finset_prod.comp x <| hasStrictFDerivAt_pi.mpr fun i ↦ hg i i.prop)\n    (by ext; simp [Finset.prod_erase_attach (g · x), ← u.sum_attach])\n\n"}
{"name":"HasFDerivAt.finset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_5\n𝔸' : Type u_7\ninst✝² : NormedCommRing 𝔸'\ninst✝¹ : NormedAlgebra 𝕜 𝔸'\nu : Finset ι\ng : ι → E → 𝔸'\ng' : ι → ContinuousLinearMap (RingHom.id 𝕜) E 𝔸'\ninst✝ : DecidableEq ι\nx : E\nhg : ∀ (i : ι), Membership.mem u i → HasFDerivAt (g i) (g' i) x\n⊢ HasFDerivAt (fun x => u.prod fun i => g i x) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => g j x) (g' i)) x","decl":"theorem HasFDerivAt.finset_prod [DecidableEq ι] {x : E}\n    (hg : ∀ i ∈ u, HasFDerivAt (g i) (g' i) x) :\n    HasFDerivAt (∏ i ∈ u, g i ·) (∑ i ∈ u, (∏ j ∈ u.erase i, g j x) • g' i) x := by\n  simpa [← Finset.prod_attach u] using .congr_fderiv\n    (hasFDerivAt_finset_prod.comp x <| hasFDerivAt_pi.mpr fun i ↦ hg (Subtype.val i) i.prop :)\n    (by ext; simp [Finset.prod_erase_attach (g · x), ← u.sum_attach])\n\n"}
{"name":"HasFDerivWithinAt.finset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ns : Set E\nι : Type u_5\n𝔸' : Type u_7\ninst✝² : NormedCommRing 𝔸'\ninst✝¹ : NormedAlgebra 𝕜 𝔸'\nu : Finset ι\ng : ι → E → 𝔸'\ng' : ι → ContinuousLinearMap (RingHom.id 𝕜) E 𝔸'\ninst✝ : DecidableEq ι\nx : E\nhg : ∀ (i : ι), Membership.mem u i → HasFDerivWithinAt (g i) (g' i) s x\n⊢ HasFDerivWithinAt (fun x => u.prod fun i => g i x) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => g j x) (g' i)) s x","decl":"theorem HasFDerivWithinAt.finset_prod [DecidableEq ι] {x : E}\n    (hg : ∀ i ∈ u, HasFDerivWithinAt (g i) (g' i) s x) :\n    HasFDerivWithinAt (∏ i ∈ u, g i ·) (∑ i ∈ u, (∏ j ∈ u.erase i, g j x) • g' i) s x := by\n  simpa [← Finset.prod_attach u] using .congr_fderiv\n    (hasFDerivAt_finset_prod.comp_hasFDerivWithinAt x <|\n      hasFDerivWithinAt_pi.mpr fun i ↦ hg (Subtype.val i) i.prop :)\n    (by ext; simp [Finset.prod_erase_attach (g · x), ← u.sum_attach])\n\n"}
{"name":"fderiv_finset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_5\n𝔸' : Type u_7\ninst✝² : NormedCommRing 𝔸'\ninst✝¹ : NormedAlgebra 𝕜 𝔸'\nu : Finset ι\ng : ι → E → 𝔸'\ninst✝ : DecidableEq ι\nx : E\nhg : ∀ (i : ι), Membership.mem u i → DifferentiableAt 𝕜 (g i) x\n⊢ Eq (fderiv 𝕜 (fun x => u.prod fun i => g i x) x) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => g j x) (fderiv 𝕜 (g i) x))","decl":"theorem fderiv_finset_prod [DecidableEq ι] {x : E} (hg : ∀ i ∈ u, DifferentiableAt 𝕜 (g i) x) :\n    fderiv 𝕜 (∏ i ∈ u, g i ·) x = ∑ i ∈ u, (∏ j ∈ u.erase i, (g j x)) • fderiv 𝕜 (g i) x :=\n  (HasFDerivAt.finset_prod fun i hi ↦ (hg i hi).hasFDerivAt).fderiv\n\n"}
{"name":"fderivWithin_finset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ns : Set E\nι : Type u_5\n𝔸' : Type u_7\ninst✝² : NormedCommRing 𝔸'\ninst✝¹ : NormedAlgebra 𝕜 𝔸'\nu : Finset ι\ng : ι → E → 𝔸'\ninst✝ : DecidableEq ι\nx : E\nhxs : UniqueDiffWithinAt 𝕜 s x\nhg : ∀ (i : ι), Membership.mem u i → DifferentiableWithinAt 𝕜 (g i) s x\n⊢ Eq (fderivWithin 𝕜 (fun x => u.prod fun i => g i x) s x) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => g j x) (fderivWithin 𝕜 (g i) s x))","decl":"theorem fderivWithin_finset_prod [DecidableEq ι] {x : E} (hxs : UniqueDiffWithinAt 𝕜 s x)\n    (hg : ∀ i ∈ u, DifferentiableWithinAt 𝕜 (g i) s x) :\n    fderivWithin 𝕜 (∏ i ∈ u, g i ·) s x =\n      ∑ i ∈ u, (∏ j ∈ u.erase i, (g j x)) • fderivWithin 𝕜 (g i) s x :=\n  (HasFDerivWithinAt.finset_prod fun i hi ↦ (hg i hi).hasFDerivWithinAt).fderivWithin hxs\n\n"}
{"name":"hasFDerivAt_ring_inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nR : Type u_5\ninst✝² : NormedRing R\ninst✝¹ : HasSummableGeomSeries R\ninst✝ : NormedAlgebra 𝕜 R\nx : Units R\n⊢ HasFDerivAt Ring.inverse (Neg.neg (((ContinuousLinearMap.mulLeftRight 𝕜 R) ↑(Inv.inv x)) ↑(Inv.inv x))) ↑x","decl":"/-- At an invertible element `x` of a normed algebra `R`, the Fréchet derivative of the inversion\noperation is the linear map `fun t ↦ - x⁻¹ * t * x⁻¹`.\n\nTODO (low prio): prove a version without assumption `[HasSummableGeomSeries R]` but within the set\nof units. -/\n@[fun_prop]\ntheorem hasFDerivAt_ring_inverse (x : Rˣ) :\n    HasFDerivAt Ring.inverse (-mulLeftRight 𝕜 R ↑x⁻¹ ↑x⁻¹) x :=\n  have : (fun t : R => Ring.inverse (↑x + t) - ↑x⁻¹ + ↑x⁻¹ * t * ↑x⁻¹) =o[𝓝 0] id :=\n    (inverse_add_norm_diff_second_order x).trans_isLittleO (isLittleO_norm_pow_id one_lt_two)\n  by simpa [hasFDerivAt_iff_isLittleO_nhds_zero] using this\n\n"}
{"name":"differentiableAt_inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nR : Type u_5\ninst✝² : NormedRing R\ninst✝¹ : HasSummableGeomSeries R\ninst✝ : NormedAlgebra 𝕜 R\nx : R\nhx : IsUnit x\n⊢ DifferentiableAt 𝕜 Ring.inverse x","decl":"@[fun_prop]\ntheorem differentiableAt_inverse {x : R} (hx : IsUnit x) :\n    DifferentiableAt 𝕜 (@Ring.inverse R _) x :=\n  let ⟨u, hu⟩ := hx; hu ▸ (hasFDerivAt_ring_inverse u).differentiableAt\n\n"}
{"name":"differentiableWithinAt_inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nR : Type u_5\ninst✝² : NormedRing R\ninst✝¹ : HasSummableGeomSeries R\ninst✝ : NormedAlgebra 𝕜 R\nx : R\nhx : IsUnit x\ns : Set R\n⊢ DifferentiableWithinAt 𝕜 Ring.inverse s x","decl":"@[fun_prop]\ntheorem differentiableWithinAt_inverse {x : R} (hx : IsUnit x) (s : Set R) :\n    DifferentiableWithinAt 𝕜 (@Ring.inverse R _) s x :=\n  (differentiableAt_inverse hx).differentiableWithinAt\n\n"}
{"name":"differentiableOn_inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nR : Type u_5\ninst✝² : NormedRing R\ninst✝¹ : HasSummableGeomSeries R\ninst✝ : NormedAlgebra 𝕜 R\n⊢ DifferentiableOn 𝕜 Ring.inverse (setOf fun x => IsUnit x)","decl":"@[fun_prop]\ntheorem differentiableOn_inverse : DifferentiableOn 𝕜 (@Ring.inverse R _) {x | IsUnit x} :=\n  fun _x hx => differentiableWithinAt_inverse hx _\n\n"}
{"name":"fderiv_inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nR : Type u_5\ninst✝² : NormedRing R\ninst✝¹ : HasSummableGeomSeries R\ninst✝ : NormedAlgebra 𝕜 R\nx : Units R\n⊢ Eq (fderiv 𝕜 Ring.inverse ↑x) (Neg.neg (((ContinuousLinearMap.mulLeftRight 𝕜 R) ↑(Inv.inv x)) ↑(Inv.inv x)))","decl":"theorem fderiv_inverse (x : Rˣ) : fderiv 𝕜 (@Ring.inverse R _) x = -mulLeftRight 𝕜 R ↑x⁻¹ ↑x⁻¹ :=\n  (hasFDerivAt_ring_inverse x).fderiv\n\n"}
{"name":"hasStrictFDerivAt_ring_inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nR : Type u_5\ninst✝² : NormedRing R\ninst✝¹ : HasSummableGeomSeries R\ninst✝ : NormedAlgebra 𝕜 R\nx : Units R\n⊢ HasStrictFDerivAt Ring.inverse (Neg.neg (((ContinuousLinearMap.mulLeftRight 𝕜 R) ↑(Inv.inv x)) ↑(Inv.inv x))) ↑x","decl":"theorem hasStrictFDerivAt_ring_inverse (x : Rˣ) :\n    HasStrictFDerivAt Ring.inverse (-mulLeftRight 𝕜 R ↑x⁻¹ ↑x⁻¹) x := by\n  convert (analyticAt_inverse (𝕜 := 𝕜) x).hasStrictFDerivAt\n  exact (fderiv_inverse x).symm\n\n"}
{"name":"DifferentiableWithinAt.inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nR : Type u_5\ninst✝² : NormedRing R\ninst✝¹ : HasSummableGeomSeries R\ninst✝ : NormedAlgebra 𝕜 R\nh : E → R\nz : E\nS : Set E\nhf : DifferentiableWithinAt 𝕜 h S z\nhz : IsUnit (h z)\n⊢ DifferentiableWithinAt 𝕜 (fun x => Ring.inverse (h x)) S z","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.inverse (hf : DifferentiableWithinAt 𝕜 h S z) (hz : IsUnit (h z)) :\n    DifferentiableWithinAt 𝕜 (fun x => Ring.inverse (h x)) S z :=\n  (differentiableAt_inverse hz).comp_differentiableWithinAt z hf\n\n"}
{"name":"DifferentiableAt.inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nR : Type u_5\ninst✝² : NormedRing R\ninst✝¹ : HasSummableGeomSeries R\ninst✝ : NormedAlgebra 𝕜 R\nh : E → R\nz : E\nhf : DifferentiableAt 𝕜 h z\nhz : IsUnit (h z)\n⊢ DifferentiableAt 𝕜 (fun x => Ring.inverse (h x)) z","decl":"@[simp, fun_prop]\ntheorem DifferentiableAt.inverse (hf : DifferentiableAt 𝕜 h z) (hz : IsUnit (h z)) :\n    DifferentiableAt 𝕜 (fun x => Ring.inverse (h x)) z :=\n  (differentiableAt_inverse hz).comp z hf\n\n"}
{"name":"DifferentiableOn.inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nR : Type u_5\ninst✝² : NormedRing R\ninst✝¹ : HasSummableGeomSeries R\ninst✝ : NormedAlgebra 𝕜 R\nh : E → R\nS : Set E\nhf : DifferentiableOn 𝕜 h S\nhz : ∀ (x : E), Membership.mem S x → IsUnit (h x)\n⊢ DifferentiableOn 𝕜 (fun x => Ring.inverse (h x)) S","decl":"@[fun_prop]\ntheorem DifferentiableOn.inverse (hf : DifferentiableOn 𝕜 h S) (hz : ∀ x ∈ S, IsUnit (h x)) :\n    DifferentiableOn 𝕜 (fun x => Ring.inverse (h x)) S := fun x h => (hf x h).inverse (hz x h)\n\n"}
{"name":"Differentiable.inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nR : Type u_5\ninst✝² : NormedRing R\ninst✝¹ : HasSummableGeomSeries R\ninst✝ : NormedAlgebra 𝕜 R\nh : E → R\nhf : Differentiable 𝕜 h\nhz : ∀ (x : E), IsUnit (h x)\n⊢ Differentiable 𝕜 fun x => Ring.inverse (h x)","decl":"@[simp, fun_prop]\ntheorem Differentiable.inverse (hf : Differentiable 𝕜 h) (hz : ∀ x, IsUnit (h x)) :\n    Differentiable 𝕜 fun x => Ring.inverse (h x) := fun x => (hf x).inverse (hz x)\n\n"}
{"name":"hasStrictFDerivAt_inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nR : Type u_5\ninst✝¹ : NormedDivisionRing R\ninst✝ : NormedAlgebra 𝕜 R\nx : R\nhx : Ne x 0\n⊢ HasStrictFDerivAt Inv.inv (Neg.neg (((ContinuousLinearMap.mulLeftRight 𝕜 R) (Inv.inv x)) (Inv.inv x))) x","decl":"/-- At an invertible element `x` of a normed division algebra `R`, the inversion is strictly\ndifferentiable, with derivative the linear map `fun t ↦ - x⁻¹ * t * x⁻¹`. For a nicer formula in\nthe commutative case, see `hasStrictFDerivAt_inv`. -/\ntheorem hasStrictFDerivAt_inv' {x : R} (hx : x ≠ 0) :\n    HasStrictFDerivAt Inv.inv (-mulLeftRight 𝕜 R x⁻¹ x⁻¹) x := by\n  simpa using hasStrictFDerivAt_ring_inverse (Units.mk0 _ hx)\n\n"}
{"name":"hasFDerivAt_inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nR : Type u_5\ninst✝¹ : NormedDivisionRing R\ninst✝ : NormedAlgebra 𝕜 R\nx : R\nhx : Ne x 0\n⊢ HasFDerivAt Inv.inv (Neg.neg (((ContinuousLinearMap.mulLeftRight 𝕜 R) (Inv.inv x)) (Inv.inv x))) x","decl":"/-- At an invertible element `x` of a normed division algebra `R`, the Fréchet derivative of the\ninversion operation is the linear map `fun t ↦ - x⁻¹ * t * x⁻¹`. For a nicer formula in the\ncommutative case, see `hasFDerivAt_inv`. -/\n@[fun_prop]\ntheorem hasFDerivAt_inv' {x : R} (hx : x ≠ 0) :\n    HasFDerivAt Inv.inv (-mulLeftRight 𝕜 R x⁻¹ x⁻¹) x := by\n  simpa using hasFDerivAt_ring_inverse (Units.mk0 _ hx)\n\n"}
{"name":"differentiableAt_inv","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nR : Type u_5\ninst✝¹ : NormedDivisionRing R\ninst✝ : NormedAlgebra 𝕜 R\nx : R\nhx : Ne x 0\n⊢ DifferentiableAt 𝕜 Inv.inv x","decl":"@[fun_prop]\ntheorem differentiableAt_inv {x : R} (hx : x ≠ 0) : DifferentiableAt 𝕜 Inv.inv x :=\n  (hasFDerivAt_inv' hx).differentiableAt\n\n"}
{"name":"differentiableAt_inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nR : Type u_5\ninst✝¹ : NormedDivisionRing R\ninst✝ : NormedAlgebra 𝕜 R\nx : R\nhx : Ne x 0\n⊢ DifferentiableAt 𝕜 Inv.inv x","decl":"@[deprecated (since := \"2024-09-21\")] alias differentiableAt_inv' := differentiableAt_inv\n\n"}
{"name":"differentiableWithinAt_inv","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nR : Type u_5\ninst✝¹ : NormedDivisionRing R\ninst✝ : NormedAlgebra 𝕜 R\nx : R\nhx : Ne x 0\ns : Set R\n⊢ DifferentiableWithinAt 𝕜 (fun x => Inv.inv x) s x","decl":"@[fun_prop]\ntheorem differentiableWithinAt_inv {x : R} (hx : x ≠ 0) (s : Set R) :\n    DifferentiableWithinAt 𝕜 (fun x => x⁻¹) s x :=\n  (differentiableAt_inv hx).differentiableWithinAt\n\n"}
{"name":"differentiableWithinAt_inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nR : Type u_5\ninst✝¹ : NormedDivisionRing R\ninst✝ : NormedAlgebra 𝕜 R\nx : R\nhx : Ne x 0\ns : Set R\n⊢ DifferentiableWithinAt 𝕜 (fun x => Inv.inv x) s x","decl":"@[deprecated (since := \"2024-09-21\")]\nalias differentiableWithinAt_inv' := differentiableWithinAt_inv\n\n"}
{"name":"differentiableOn_inv","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nR : Type u_5\ninst✝¹ : NormedDivisionRing R\ninst✝ : NormedAlgebra 𝕜 R\n⊢ DifferentiableOn 𝕜 (fun x => Inv.inv x) (setOf fun x => Ne x 0)","decl":"@[fun_prop]\ntheorem differentiableOn_inv : DifferentiableOn 𝕜 (fun x : R => x⁻¹) {x | x ≠ 0} := fun _x hx =>\n  differentiableWithinAt_inv hx _\n\n"}
{"name":"differentiableOn_inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nR : Type u_5\ninst✝¹ : NormedDivisionRing R\ninst✝ : NormedAlgebra 𝕜 R\n⊢ DifferentiableOn 𝕜 (fun x => Inv.inv x) (setOf fun x => Ne x 0)","decl":"@[deprecated (since := \"2024-09-21\")] alias differentiableOn_inv' := differentiableOn_inv\n\n"}
{"name":"fderiv_inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nR : Type u_5\ninst✝¹ : NormedDivisionRing R\ninst✝ : NormedAlgebra 𝕜 R\nx : R\nhx : Ne x 0\n⊢ Eq (fderiv 𝕜 Inv.inv x) (Neg.neg (((ContinuousLinearMap.mulLeftRight 𝕜 R) (Inv.inv x)) (Inv.inv x)))","decl":"/-- Non-commutative version of `fderiv_inv` -/\ntheorem fderiv_inv' {x : R} (hx : x ≠ 0) : fderiv 𝕜 Inv.inv x = -mulLeftRight 𝕜 R x⁻¹ x⁻¹ :=\n  (hasFDerivAt_inv' hx).fderiv\n\n"}
{"name":"fderivWithin_inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nR : Type u_5\ninst✝¹ : NormedDivisionRing R\ninst✝ : NormedAlgebra 𝕜 R\ns : Set R\nx : R\nhx : Ne x 0\nhxs : UniqueDiffWithinAt 𝕜 s x\n⊢ Eq (fderivWithin 𝕜 (fun x => Inv.inv x) s x) (Neg.neg (((ContinuousLinearMap.mulLeftRight 𝕜 R) (Inv.inv x)) (Inv.inv x)))","decl":"/-- Non-commutative version of `fderivWithin_inv` -/\ntheorem fderivWithin_inv' {s : Set R} {x : R} (hx : x ≠ 0) (hxs : UniqueDiffWithinAt 𝕜 s x) :\n    fderivWithin 𝕜 (fun x => x⁻¹) s x = -mulLeftRight 𝕜 R x⁻¹ x⁻¹ := by\n  rw [DifferentiableAt.fderivWithin (differentiableAt_inv hx) hxs]\n  exact fderiv_inv' hx\n\n"}
{"name":"DifferentiableWithinAt.inv","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nR : Type u_5\ninst✝¹ : NormedDivisionRing R\ninst✝ : NormedAlgebra 𝕜 R\nh : E → R\nz : E\nS : Set E\nhf : DifferentiableWithinAt 𝕜 h S z\nhz : Ne (h z) 0\n⊢ DifferentiableWithinAt 𝕜 (fun x => Inv.inv (h x)) S z","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.inv (hf : DifferentiableWithinAt 𝕜 h S z) (hz : h z ≠ 0) :\n    DifferentiableWithinAt 𝕜 (fun x => (h x)⁻¹) S z :=\n  (differentiableAt_inv hz).comp_differentiableWithinAt z hf\n\n"}
{"name":"DifferentiableWithinAt.inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nR : Type u_5\ninst✝¹ : NormedDivisionRing R\ninst✝ : NormedAlgebra 𝕜 R\nh : E → R\nz : E\nS : Set E\nhf : DifferentiableWithinAt 𝕜 h S z\nhz : Ne (h z) 0\n⊢ DifferentiableWithinAt 𝕜 (fun x => Inv.inv (h x)) S z","decl":"@[deprecated (since := \"2024-09-21\")]\nalias DifferentiableWithinAt.inv' := DifferentiableWithinAt.inv\n\n"}
{"name":"DifferentiableAt.inv","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nR : Type u_5\ninst✝¹ : NormedDivisionRing R\ninst✝ : NormedAlgebra 𝕜 R\nh : E → R\nz : E\nhf : DifferentiableAt 𝕜 h z\nhz : Ne (h z) 0\n⊢ DifferentiableAt 𝕜 (fun x => Inv.inv (h x)) z","decl":"@[simp, fun_prop]\ntheorem DifferentiableAt.inv (hf : DifferentiableAt 𝕜 h z) (hz : h z ≠ 0) :\n    DifferentiableAt 𝕜 (fun x => (h x)⁻¹) z :=\n  (differentiableAt_inv hz).comp z hf\n\n"}
{"name":"DifferentiableAt.inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nR : Type u_5\ninst✝¹ : NormedDivisionRing R\ninst✝ : NormedAlgebra 𝕜 R\nh : E → R\nz : E\nhf : DifferentiableAt 𝕜 h z\nhz : Ne (h z) 0\n⊢ DifferentiableAt 𝕜 (fun x => Inv.inv (h x)) z","decl":"@[deprecated (since := \"2024-09-21\")] alias DifferentiableAt.inv' := DifferentiableAt.inv\n\n"}
{"name":"DifferentiableOn.inv","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nR : Type u_5\ninst✝¹ : NormedDivisionRing R\ninst✝ : NormedAlgebra 𝕜 R\nh : E → R\nS : Set E\nhf : DifferentiableOn 𝕜 h S\nhz : ∀ (x : E), Membership.mem S x → Ne (h x) 0\n⊢ DifferentiableOn 𝕜 (fun x => Inv.inv (h x)) S","decl":"@[fun_prop]\ntheorem DifferentiableOn.inv (hf : DifferentiableOn 𝕜 h S) (hz : ∀ x ∈ S, h x ≠ 0) :\n    DifferentiableOn 𝕜 (fun x => (h x)⁻¹) S := fun x h => (hf x h).inv (hz x h)\n\n"}
{"name":"DifferentiableOn.inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nR : Type u_5\ninst✝¹ : NormedDivisionRing R\ninst✝ : NormedAlgebra 𝕜 R\nh : E → R\nS : Set E\nhf : DifferentiableOn 𝕜 h S\nhz : ∀ (x : E), Membership.mem S x → Ne (h x) 0\n⊢ DifferentiableOn 𝕜 (fun x => Inv.inv (h x)) S","decl":"@[deprecated (since := \"2024-09-21\")] alias DifferentiableOn.inv' := DifferentiableOn.inv\n\n"}
{"name":"Differentiable.inv","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nR : Type u_5\ninst✝¹ : NormedDivisionRing R\ninst✝ : NormedAlgebra 𝕜 R\nh : E → R\nhf : Differentiable 𝕜 h\nhz : ∀ (x : E), Ne (h x) 0\n⊢ Differentiable 𝕜 fun x => Inv.inv (h x)","decl":"@[simp, fun_prop]\ntheorem Differentiable.inv (hf : Differentiable 𝕜 h) (hz : ∀ x, h x ≠ 0) :\n    Differentiable 𝕜 fun x => (h x)⁻¹ := fun x => (hf x).inv (hz x)\n\n"}
{"name":"Differentiable.inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nR : Type u_5\ninst✝¹ : NormedDivisionRing R\ninst✝ : NormedAlgebra 𝕜 R\nh : E → R\nhf : Differentiable 𝕜 h\nhz : ∀ (x : E), Ne (h x) 0\n⊢ Differentiable 𝕜 fun x => Inv.inv (h x)","decl":"@[deprecated (since := \"2024-09-21\")] alias Differentiable.inv' := Differentiable.inv\n\n"}
