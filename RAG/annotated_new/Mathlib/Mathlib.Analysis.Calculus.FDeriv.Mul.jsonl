{"name":"HasStrictFDerivAt.clm_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nx : E\nH : Type u_5\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) G H\nc' : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) G H)\nd : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nd' : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) F G)\nhc : HasStrictFDerivAt c c' x\nhd : HasStrictFDerivAt d d' x\nâŠ¢ HasStrictFDerivAt (fun y => (c y).comp (d y)) (HAdd.hAdd (((ContinuousLinearMap.compL ğ•œ F G H) (c x)).comp d') (((ContinuousLinearMap.compL ğ•œ F G H).flip (d x)).comp c')) x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.clm_comp (hc : HasStrictFDerivAt c c' x) (hd : HasStrictFDerivAt d d' x) :\n    HasStrictFDerivAt (fun y => (c y).comp (d y))\n      ((compL ğ•œ F G H (c x)).comp d' + ((compL ğ•œ F G H).flip (d x)).comp c') x := by\n  have := isBoundedBilinearMap_comp.hasStrictFDerivAt (c x, d x)\n  have := this.comp x (hc.prod hd)\n  exact this\n\n"}
{"name":"HasFDerivWithinAt.clm_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nx : E\ns : Set E\nH : Type u_5\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) G H\nc' : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) G H)\nd : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nd' : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) F G)\nhc : HasFDerivWithinAt c c' s x\nhd : HasFDerivWithinAt d d' s x\nâŠ¢ HasFDerivWithinAt (fun y => (c y).comp (d y)) (HAdd.hAdd (((ContinuousLinearMap.compL ğ•œ F G H) (c x)).comp d') (((ContinuousLinearMap.compL ğ•œ F G H).flip (d x)).comp c')) s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.clm_comp (hc : HasFDerivWithinAt c c' s x)\n    (hd : HasFDerivWithinAt d d' s x) :\n    HasFDerivWithinAt (fun y => (c y).comp (d y))\n      ((compL ğ•œ F G H (c x)).comp d' + ((compL ğ•œ F G H).flip (d x)).comp c') s x := by\n  exact (isBoundedBilinearMap_comp.hasFDerivAt (c x, d x) :).comp_hasFDerivWithinAt x <| hc.prod hd\n\n"}
{"name":"HasFDerivAt.clm_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nx : E\nH : Type u_5\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) G H\nc' : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) G H)\nd : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nd' : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) F G)\nhc : HasFDerivAt c c' x\nhd : HasFDerivAt d d' x\nâŠ¢ HasFDerivAt (fun y => (c y).comp (d y)) (HAdd.hAdd (((ContinuousLinearMap.compL ğ•œ F G H) (c x)).comp d') (((ContinuousLinearMap.compL ğ•œ F G H).flip (d x)).comp c')) x","decl":"@[fun_prop]\ntheorem HasFDerivAt.clm_comp (hc : HasFDerivAt c c' x) (hd : HasFDerivAt d d' x) :\n    HasFDerivAt (fun y => (c y).comp (d y))\n      ((compL ğ•œ F G H (c x)).comp d' + ((compL ğ•œ F G H).flip (d x)).comp c') x := by\n  exact (isBoundedBilinearMap_comp.hasFDerivAt (c x, d x) :).comp x <| hc.prod hd\n\n"}
{"name":"DifferentiableWithinAt.clm_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nx : E\ns : Set E\nH : Type u_5\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) G H\nd : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nhc : DifferentiableWithinAt ğ•œ c s x\nhd : DifferentiableWithinAt ğ•œ d s x\nâŠ¢ DifferentiableWithinAt ğ•œ (fun y => (c y).comp (d y)) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.clm_comp (hc : DifferentiableWithinAt ğ•œ c s x)\n    (hd : DifferentiableWithinAt ğ•œ d s x) :\n    DifferentiableWithinAt ğ•œ (fun y => (c y).comp (d y)) s x :=\n  (hc.hasFDerivWithinAt.clm_comp hd.hasFDerivWithinAt).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.clm_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nx : E\nH : Type u_5\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) G H\nd : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nhc : DifferentiableAt ğ•œ c x\nhd : DifferentiableAt ğ•œ d x\nâŠ¢ DifferentiableAt ğ•œ (fun y => (c y).comp (d y)) x","decl":"@[fun_prop]\ntheorem DifferentiableAt.clm_comp (hc : DifferentiableAt ğ•œ c x) (hd : DifferentiableAt ğ•œ d x) :\n    DifferentiableAt ğ•œ (fun y => (c y).comp (d y)) x :=\n  (hc.hasFDerivAt.clm_comp hd.hasFDerivAt).differentiableAt\n\n"}
{"name":"DifferentiableOn.clm_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ns : Set E\nH : Type u_5\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) G H\nd : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nhc : DifferentiableOn ğ•œ c s\nhd : DifferentiableOn ğ•œ d s\nâŠ¢ DifferentiableOn ğ•œ (fun y => (c y).comp (d y)) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.clm_comp (hc : DifferentiableOn ğ•œ c s) (hd : DifferentiableOn ğ•œ d s) :\n    DifferentiableOn ğ•œ (fun y => (c y).comp (d y)) s := fun x hx => (hc x hx).clm_comp (hd x hx)\n\n"}
{"name":"Differentiable.clm_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nH : Type u_5\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) G H\nd : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nhc : Differentiable ğ•œ c\nhd : Differentiable ğ•œ d\nâŠ¢ Differentiable ğ•œ fun y => (c y).comp (d y)","decl":"@[fun_prop]\ntheorem Differentiable.clm_comp (hc : Differentiable ğ•œ c) (hd : Differentiable ğ•œ d) :\n    Differentiable ğ•œ fun y => (c y).comp (d y) := fun x => (hc x).clm_comp (hd x)\n\n"}
{"name":"fderivWithin_clm_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nx : E\ns : Set E\nH : Type u_5\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) G H\nd : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nhxs : UniqueDiffWithinAt ğ•œ s x\nhc : DifferentiableWithinAt ğ•œ c s x\nhd : DifferentiableWithinAt ğ•œ d s x\nâŠ¢ Eq (fderivWithin ğ•œ (fun y => (c y).comp (d y)) s x) (HAdd.hAdd (((ContinuousLinearMap.compL ğ•œ F G H) (c x)).comp (fderivWithin ğ•œ d s x)) (((ContinuousLinearMap.compL ğ•œ F G H).flip (d x)).comp (fderivWithin ğ•œ c s x)))","decl":"theorem fderivWithin_clm_comp (hxs : UniqueDiffWithinAt ğ•œ s x) (hc : DifferentiableWithinAt ğ•œ c s x)\n    (hd : DifferentiableWithinAt ğ•œ d s x) :\n    fderivWithin ğ•œ (fun y => (c y).comp (d y)) s x =\n      (compL ğ•œ F G H (c x)).comp (fderivWithin ğ•œ d s x) +\n        ((compL ğ•œ F G H).flip (d x)).comp (fderivWithin ğ•œ c s x) :=\n  (hc.hasFDerivWithinAt.clm_comp hd.hasFDerivWithinAt).fderivWithin hxs\n\n"}
{"name":"fderiv_clm_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nx : E\nH : Type u_5\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) G H\nd : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nhc : DifferentiableAt ğ•œ c x\nhd : DifferentiableAt ğ•œ d x\nâŠ¢ Eq (fderiv ğ•œ (fun y => (c y).comp (d y)) x) (HAdd.hAdd (((ContinuousLinearMap.compL ğ•œ F G H) (c x)).comp (fderiv ğ•œ d x)) (((ContinuousLinearMap.compL ğ•œ F G H).flip (d x)).comp (fderiv ğ•œ c x)))","decl":"theorem fderiv_clm_comp (hc : DifferentiableAt ğ•œ c x) (hd : DifferentiableAt ğ•œ d x) :\n    fderiv ğ•œ (fun y => (c y).comp (d y)) x =\n      (compL ğ•œ F G H (c x)).comp (fderiv ğ•œ d x) +\n        ((compL ğ•œ F G H).flip (d x)).comp (fderiv ğ•œ c x) :=\n  (hc.hasFDerivAt.clm_comp hd.hasFDerivAt).fderiv\n\n"}
{"name":"HasStrictFDerivAt.clm_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nx : E\nH : Type u_5\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) G H\nc' : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) G H)\nu : E â†’ G\nu' : ContinuousLinearMap (RingHom.id ğ•œ) E G\nhc : HasStrictFDerivAt c c' x\nhu : HasStrictFDerivAt u u' x\nâŠ¢ HasStrictFDerivAt (fun y => (c y) (u y)) (HAdd.hAdd ((c x).comp u') (c'.flip (u x))) x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.clm_apply (hc : HasStrictFDerivAt c c' x)\n    (hu : HasStrictFDerivAt u u' x) :\n    HasStrictFDerivAt (fun y => (c y) (u y)) ((c x).comp u' + c'.flip (u x)) x :=\n  (isBoundedBilinearMap_apply.hasStrictFDerivAt (c x, u x)).comp x (hc.prod hu)\n\n"}
{"name":"HasFDerivWithinAt.clm_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nx : E\ns : Set E\nH : Type u_5\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) G H\nc' : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) G H)\nu : E â†’ G\nu' : ContinuousLinearMap (RingHom.id ğ•œ) E G\nhc : HasFDerivWithinAt c c' s x\nhu : HasFDerivWithinAt u u' s x\nâŠ¢ HasFDerivWithinAt (fun y => (c y) (u y)) (HAdd.hAdd ((c x).comp u') (c'.flip (u x))) s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.clm_apply (hc : HasFDerivWithinAt c c' s x)\n    (hu : HasFDerivWithinAt u u' s x) :\n    HasFDerivWithinAt (fun y => (c y) (u y)) ((c x).comp u' + c'.flip (u x)) s x := by\n  exact (isBoundedBilinearMap_apply.hasFDerivAt (c x, u x) :).comp_hasFDerivWithinAt x (hc.prod hu)\n\n"}
{"name":"HasFDerivAt.clm_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nx : E\nH : Type u_5\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) G H\nc' : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) G H)\nu : E â†’ G\nu' : ContinuousLinearMap (RingHom.id ğ•œ) E G\nhc : HasFDerivAt c c' x\nhu : HasFDerivAt u u' x\nâŠ¢ HasFDerivAt (fun y => (c y) (u y)) (HAdd.hAdd ((c x).comp u') (c'.flip (u x))) x","decl":"@[fun_prop]\ntheorem HasFDerivAt.clm_apply (hc : HasFDerivAt c c' x) (hu : HasFDerivAt u u' x) :\n    HasFDerivAt (fun y => (c y) (u y)) ((c x).comp u' + c'.flip (u x)) x := by\n  exact (isBoundedBilinearMap_apply.hasFDerivAt (c x, u x) :).comp x (hc.prod hu)\n\n"}
{"name":"DifferentiableWithinAt.clm_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nx : E\ns : Set E\nH : Type u_5\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) G H\nu : E â†’ G\nhc : DifferentiableWithinAt ğ•œ c s x\nhu : DifferentiableWithinAt ğ•œ u s x\nâŠ¢ DifferentiableWithinAt ğ•œ (fun y => (c y) (u y)) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.clm_apply (hc : DifferentiableWithinAt ğ•œ c s x)\n    (hu : DifferentiableWithinAt ğ•œ u s x) : DifferentiableWithinAt ğ•œ (fun y => (c y) (u y)) s x :=\n  (hc.hasFDerivWithinAt.clm_apply hu.hasFDerivWithinAt).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.clm_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nx : E\nH : Type u_5\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) G H\nu : E â†’ G\nhc : DifferentiableAt ğ•œ c x\nhu : DifferentiableAt ğ•œ u x\nâŠ¢ DifferentiableAt ğ•œ (fun y => (c y) (u y)) x","decl":"@[fun_prop]\ntheorem DifferentiableAt.clm_apply (hc : DifferentiableAt ğ•œ c x) (hu : DifferentiableAt ğ•œ u x) :\n    DifferentiableAt ğ•œ (fun y => (c y) (u y)) x :=\n  (hc.hasFDerivAt.clm_apply hu.hasFDerivAt).differentiableAt\n\n"}
{"name":"DifferentiableOn.clm_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ns : Set E\nH : Type u_5\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) G H\nu : E â†’ G\nhc : DifferentiableOn ğ•œ c s\nhu : DifferentiableOn ğ•œ u s\nâŠ¢ DifferentiableOn ğ•œ (fun y => (c y) (u y)) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.clm_apply (hc : DifferentiableOn ğ•œ c s) (hu : DifferentiableOn ğ•œ u s) :\n    DifferentiableOn ğ•œ (fun y => (c y) (u y)) s := fun x hx => (hc x hx).clm_apply (hu x hx)\n\n"}
{"name":"Differentiable.clm_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nH : Type u_5\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) G H\nu : E â†’ G\nhc : Differentiable ğ•œ c\nhu : Differentiable ğ•œ u\nâŠ¢ Differentiable ğ•œ fun y => (c y) (u y)","decl":"@[fun_prop]\ntheorem Differentiable.clm_apply (hc : Differentiable ğ•œ c) (hu : Differentiable ğ•œ u) :\n    Differentiable ğ•œ fun y => (c y) (u y) := fun x => (hc x).clm_apply (hu x)\n\n"}
{"name":"fderivWithin_clm_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nx : E\ns : Set E\nH : Type u_5\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) G H\nu : E â†’ G\nhxs : UniqueDiffWithinAt ğ•œ s x\nhc : DifferentiableWithinAt ğ•œ c s x\nhu : DifferentiableWithinAt ğ•œ u s x\nâŠ¢ Eq (fderivWithin ğ•œ (fun y => (c y) (u y)) s x) (HAdd.hAdd ((c x).comp (fderivWithin ğ•œ u s x)) ((fderivWithin ğ•œ c s x).flip (u x)))","decl":"theorem fderivWithin_clm_apply (hxs : UniqueDiffWithinAt ğ•œ s x)\n    (hc : DifferentiableWithinAt ğ•œ c s x) (hu : DifferentiableWithinAt ğ•œ u s x) :\n    fderivWithin ğ•œ (fun y => (c y) (u y)) s x =\n      (c x).comp (fderivWithin ğ•œ u s x) + (fderivWithin ğ•œ c s x).flip (u x) :=\n  (hc.hasFDerivWithinAt.clm_apply hu.hasFDerivWithinAt).fderivWithin hxs\n\n"}
{"name":"fderiv_clm_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nx : E\nH : Type u_5\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) G H\nu : E â†’ G\nhc : DifferentiableAt ğ•œ c x\nhu : DifferentiableAt ğ•œ u x\nâŠ¢ Eq (fderiv ğ•œ (fun y => (c y) (u y)) x) (HAdd.hAdd ((c x).comp (fderiv ğ•œ u x)) ((fderiv ğ•œ c x).flip (u x)))","decl":"theorem fderiv_clm_apply (hc : DifferentiableAt ğ•œ c x) (hu : DifferentiableAt ğ•œ u x) :\n    fderiv ğ•œ (fun y => (c y) (u y)) x = (c x).comp (fderiv ğ•œ u x) + (fderiv ğ•œ c x).flip (u x) :=\n  (hc.hasFDerivAt.clm_apply hu.hasFDerivAt).fderiv\n\n"}
{"name":"HasStrictFDerivAt.continuousMultilinear_apply_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nx : E\nÎ¹ : Type u_5\ninstâœâ´ : Fintype Î¹\nM : Î¹ â†’ Type u_6\ninstâœÂ³ : (i : Î¹) â†’ NormedAddCommGroup (M i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (M i)\nH : Type u_7\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousMultilinearMap ğ•œ M H\nc' : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousMultilinearMap ğ•œ M H)\nhc : HasStrictFDerivAt c c' x\nu : (i : Î¹) â†’ M i\nâŠ¢ HasStrictFDerivAt (fun y => (c y) u) (c'.flipMultilinear u) x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.continuousMultilinear_apply_const (hc : HasStrictFDerivAt c c' x)\n    (u : âˆ€ i, M i) : HasStrictFDerivAt (fun y â†¦ (c y) u) (c'.flipMultilinear u) x :=\n  (ContinuousMultilinearMap.apply ğ•œ M H u).hasStrictFDerivAt.comp x hc\n\n"}
{"name":"HasFDerivWithinAt.continuousMultilinear_apply_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nx : E\ns : Set E\nÎ¹ : Type u_5\ninstâœâ´ : Fintype Î¹\nM : Î¹ â†’ Type u_6\ninstâœÂ³ : (i : Î¹) â†’ NormedAddCommGroup (M i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (M i)\nH : Type u_7\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousMultilinearMap ğ•œ M H\nc' : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousMultilinearMap ğ•œ M H)\nhc : HasFDerivWithinAt c c' s x\nu : (i : Î¹) â†’ M i\nâŠ¢ HasFDerivWithinAt (fun y => (c y) u) (c'.flipMultilinear u) s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.continuousMultilinear_apply_const (hc : HasFDerivWithinAt c c' s x)\n    (u : âˆ€ i, M i) :\n    HasFDerivWithinAt (fun y â†¦ (c y) u) (c'.flipMultilinear u) s x :=\n  (ContinuousMultilinearMap.apply ğ•œ M H u).hasFDerivAt.comp_hasFDerivWithinAt x hc\n\n"}
{"name":"HasFDerivAt.continuousMultilinear_apply_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nx : E\nÎ¹ : Type u_5\ninstâœâ´ : Fintype Î¹\nM : Î¹ â†’ Type u_6\ninstâœÂ³ : (i : Î¹) â†’ NormedAddCommGroup (M i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (M i)\nH : Type u_7\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousMultilinearMap ğ•œ M H\nc' : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousMultilinearMap ğ•œ M H)\nhc : HasFDerivAt c c' x\nu : (i : Î¹) â†’ M i\nâŠ¢ HasFDerivAt (fun y => (c y) u) (c'.flipMultilinear u) x","decl":"@[fun_prop]\ntheorem HasFDerivAt.continuousMultilinear_apply_const (hc : HasFDerivAt c c' x) (u : âˆ€ i, M i) :\n    HasFDerivAt (fun y â†¦ (c y) u) (c'.flipMultilinear u) x :=\n  (ContinuousMultilinearMap.apply ğ•œ M H u).hasFDerivAt.comp x hc\n\n"}
{"name":"DifferentiableWithinAt.continuousMultilinear_apply_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nx : E\ns : Set E\nÎ¹ : Type u_5\ninstâœâ´ : Fintype Î¹\nM : Î¹ â†’ Type u_6\ninstâœÂ³ : (i : Î¹) â†’ NormedAddCommGroup (M i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (M i)\nH : Type u_7\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousMultilinearMap ğ•œ M H\nhc : DifferentiableWithinAt ğ•œ c s x\nu : (i : Î¹) â†’ M i\nâŠ¢ DifferentiableWithinAt ğ•œ (fun y => (c y) u) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.continuousMultilinear_apply_const\n    (hc : DifferentiableWithinAt ğ•œ c s x) (u : âˆ€ i, M i) :\n    DifferentiableWithinAt ğ•œ (fun y â†¦ (c y) u) s x :=\n  (hc.hasFDerivWithinAt.continuousMultilinear_apply_const u).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.continuousMultilinear_apply_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nx : E\nÎ¹ : Type u_5\ninstâœâ´ : Fintype Î¹\nM : Î¹ â†’ Type u_6\ninstâœÂ³ : (i : Î¹) â†’ NormedAddCommGroup (M i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (M i)\nH : Type u_7\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousMultilinearMap ğ•œ M H\nhc : DifferentiableAt ğ•œ c x\nu : (i : Î¹) â†’ M i\nâŠ¢ DifferentiableAt ğ•œ (fun y => (c y) u) x","decl":"@[fun_prop]\ntheorem DifferentiableAt.continuousMultilinear_apply_const (hc : DifferentiableAt ğ•œ c x)\n    (u : âˆ€ i, M i) :\n    DifferentiableAt ğ•œ (fun y â†¦ (c y) u) x :=\n  (hc.hasFDerivAt.continuousMultilinear_apply_const u).differentiableAt\n\n"}
{"name":"DifferentiableOn.continuousMultilinear_apply_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\ns : Set E\nÎ¹ : Type u_5\ninstâœâ´ : Fintype Î¹\nM : Î¹ â†’ Type u_6\ninstâœÂ³ : (i : Î¹) â†’ NormedAddCommGroup (M i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (M i)\nH : Type u_7\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousMultilinearMap ğ•œ M H\nhc : DifferentiableOn ğ•œ c s\nu : (i : Î¹) â†’ M i\nâŠ¢ DifferentiableOn ğ•œ (fun y => (c y) u) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.continuousMultilinear_apply_const (hc : DifferentiableOn ğ•œ c s)\n    (u : âˆ€ i, M i) : DifferentiableOn ğ•œ (fun y â†¦ (c y) u) s :=\n  fun x hx â†¦ (hc x hx).continuousMultilinear_apply_const u\n\n"}
{"name":"Differentiable.continuousMultilinear_apply_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nÎ¹ : Type u_5\ninstâœâ´ : Fintype Î¹\nM : Î¹ â†’ Type u_6\ninstâœÂ³ : (i : Î¹) â†’ NormedAddCommGroup (M i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (M i)\nH : Type u_7\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousMultilinearMap ğ•œ M H\nhc : Differentiable ğ•œ c\nu : (i : Î¹) â†’ M i\nâŠ¢ Differentiable ğ•œ fun y => (c y) u","decl":"@[fun_prop]\ntheorem Differentiable.continuousMultilinear_apply_const (hc : Differentiable ğ•œ c) (u : âˆ€ i, M i) :\n    Differentiable ğ•œ fun y â†¦ (c y) u := fun x â†¦ (hc x).continuousMultilinear_apply_const u\n\n"}
{"name":"fderivWithin_continuousMultilinear_apply_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nx : E\ns : Set E\nÎ¹ : Type u_5\ninstâœâ´ : Fintype Î¹\nM : Î¹ â†’ Type u_6\ninstâœÂ³ : (i : Î¹) â†’ NormedAddCommGroup (M i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (M i)\nH : Type u_7\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousMultilinearMap ğ•œ M H\nhxs : UniqueDiffWithinAt ğ•œ s x\nhc : DifferentiableWithinAt ğ•œ c s x\nu : (i : Î¹) â†’ M i\nâŠ¢ Eq (fderivWithin ğ•œ (fun y => (c y) u) s x) ((fderivWithin ğ•œ c s x).flipMultilinear u)","decl":"theorem fderivWithin_continuousMultilinear_apply_const (hxs : UniqueDiffWithinAt ğ•œ s x)\n    (hc : DifferentiableWithinAt ğ•œ c s x) (u : âˆ€ i, M i) :\n    fderivWithin ğ•œ (fun y â†¦ (c y) u) s x = ((fderivWithin ğ•œ c s x).flipMultilinear u) :=\n  (hc.hasFDerivWithinAt.continuousMultilinear_apply_const u).fderivWithin hxs\n\n"}
{"name":"fderiv_continuousMultilinear_apply_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nx : E\nÎ¹ : Type u_5\ninstâœâ´ : Fintype Î¹\nM : Î¹ â†’ Type u_6\ninstâœÂ³ : (i : Î¹) â†’ NormedAddCommGroup (M i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (M i)\nH : Type u_7\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousMultilinearMap ğ•œ M H\nhc : DifferentiableAt ğ•œ c x\nu : (i : Î¹) â†’ M i\nâŠ¢ Eq (fderiv ğ•œ (fun y => (c y) u) x) ((fderiv ğ•œ c x).flipMultilinear u)","decl":"theorem fderiv_continuousMultilinear_apply_const (hc : DifferentiableAt ğ•œ c x) (u : âˆ€ i, M i) :\n    (fderiv ğ•œ (fun y â†¦ (c y) u) x) = (fderiv ğ•œ c x).flipMultilinear u :=\n  (hc.hasFDerivAt.continuousMultilinear_apply_const u).fderiv\n\n"}
{"name":"fderivWithin_continuousMultilinear_apply_const_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nx : E\ns : Set E\nÎ¹ : Type u_5\ninstâœâ´ : Fintype Î¹\nM : Î¹ â†’ Type u_6\ninstâœÂ³ : (i : Î¹) â†’ NormedAddCommGroup (M i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (M i)\nH : Type u_7\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousMultilinearMap ğ•œ M H\nhxs : UniqueDiffWithinAt ğ•œ s x\nhc : DifferentiableWithinAt ğ•œ c s x\nu : (i : Î¹) â†’ M i\nm : E\nâŠ¢ Eq ((fderivWithin ğ•œ (fun y => (c y) u) s x) m) (((fderivWithin ğ•œ c s x) m) u)","decl":"/-- Application of a `ContinuousMultilinearMap` to a constant commutes with `fderivWithin`. -/\ntheorem fderivWithin_continuousMultilinear_apply_const_apply (hxs : UniqueDiffWithinAt ğ•œ s x)\n    (hc : DifferentiableWithinAt ğ•œ c s x) (u : âˆ€ i, M i) (m : E) :\n    (fderivWithin ğ•œ (fun y â†¦ (c y) u) s x) m = (fderivWithin ğ•œ c s x) m u := by\n  simp [fderivWithin_continuousMultilinear_apply_const hxs hc]\n\n"}
{"name":"fderiv_continuousMultilinear_apply_const_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nx : E\nÎ¹ : Type u_5\ninstâœâ´ : Fintype Î¹\nM : Î¹ â†’ Type u_6\ninstâœÂ³ : (i : Î¹) â†’ NormedAddCommGroup (M i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (M i)\nH : Type u_7\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nc : E â†’ ContinuousMultilinearMap ğ•œ M H\nhc : DifferentiableAt ğ•œ c x\nu : (i : Î¹) â†’ M i\nm : E\nâŠ¢ Eq ((fderiv ğ•œ (fun y => (c y) u) x) m) (((fderiv ğ•œ c x) m) u)","decl":"/-- Application of a `ContinuousMultilinearMap` to a constant commutes with `fderiv`. -/\ntheorem fderiv_continuousMultilinear_apply_const_apply (hc : DifferentiableAt ğ•œ c x)\n    (u : âˆ€ i, M i) (m : E) :\n    (fderiv ğ•œ (fun y â†¦ (c y) u) x) m = (fderiv ğ•œ c x) m u := by\n  simp [fderiv_continuousMultilinear_apply_const hc]\n\n"}
{"name":"HasStrictFDerivAt.smul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nğ•œ' : Type u_5\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : E â†’ ğ•œ'\nc' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ•œ'\nhc : HasStrictFDerivAt c c' x\nhf : HasStrictFDerivAt f f' x\nâŠ¢ HasStrictFDerivAt (fun y => HSMul.hSMul (c y) (f y)) (HAdd.hAdd (HSMul.hSMul (c x) f') (c'.smulRight (f x))) x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.smul (hc : HasStrictFDerivAt c c' x) (hf : HasStrictFDerivAt f f' x) :\n    HasStrictFDerivAt (fun y => c y â€¢ f y) (c x â€¢ f' + c'.smulRight (f x)) x :=\n  (isBoundedBilinearMap_smul.hasStrictFDerivAt (c x, f x)).comp x <| hc.prod hf\n\n"}
{"name":"HasFDerivWithinAt.smul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nğ•œ' : Type u_5\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : E â†’ ğ•œ'\nc' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ•œ'\nhc : HasFDerivWithinAt c c' s x\nhf : HasFDerivWithinAt f f' s x\nâŠ¢ HasFDerivWithinAt (fun y => HSMul.hSMul (c y) (f y)) (HAdd.hAdd (HSMul.hSMul (c x) f') (c'.smulRight (f x))) s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.smul (hc : HasFDerivWithinAt c c' s x) (hf : HasFDerivWithinAt f f' s x) :\n    HasFDerivWithinAt (fun y => c y â€¢ f y) (c x â€¢ f' + c'.smulRight (f x)) s x := by\n  exact (isBoundedBilinearMap_smul.hasFDerivAt (ğ•œ := ğ•œ) (c x, f x) :).comp_hasFDerivWithinAt x <|\n    hc.prod hf\n\n"}
{"name":"HasFDerivAt.smul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nğ•œ' : Type u_5\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : E â†’ ğ•œ'\nc' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ•œ'\nhc : HasFDerivAt c c' x\nhf : HasFDerivAt f f' x\nâŠ¢ HasFDerivAt (fun y => HSMul.hSMul (c y) (f y)) (HAdd.hAdd (HSMul.hSMul (c x) f') (c'.smulRight (f x))) x","decl":"@[fun_prop]\ntheorem HasFDerivAt.smul (hc : HasFDerivAt c c' x) (hf : HasFDerivAt f f' x) :\n    HasFDerivAt (fun y => c y â€¢ f y) (c x â€¢ f' + c'.smulRight (f x)) x := by\n  exact (isBoundedBilinearMap_smul.hasFDerivAt (ğ•œ := ğ•œ) (c x, f x) :).comp x <| hc.prod hf\n\n"}
{"name":"DifferentiableWithinAt.smul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nğ•œ' : Type u_5\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : E â†’ ğ•œ'\nhc : DifferentiableWithinAt ğ•œ c s x\nhf : DifferentiableWithinAt ğ•œ f s x\nâŠ¢ DifferentiableWithinAt ğ•œ (fun y => HSMul.hSMul (c y) (f y)) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.smul (hc : DifferentiableWithinAt ğ•œ c s x)\n    (hf : DifferentiableWithinAt ğ•œ f s x) : DifferentiableWithinAt ğ•œ (fun y => c y â€¢ f y) s x :=\n  (hc.hasFDerivWithinAt.smul hf.hasFDerivWithinAt).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.smul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nğ•œ' : Type u_5\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : E â†’ ğ•œ'\nhc : DifferentiableAt ğ•œ c x\nhf : DifferentiableAt ğ•œ f x\nâŠ¢ DifferentiableAt ğ•œ (fun y => HSMul.hSMul (c y) (f y)) x","decl":"@[simp, fun_prop]\ntheorem DifferentiableAt.smul (hc : DifferentiableAt ğ•œ c x) (hf : DifferentiableAt ğ•œ f x) :\n    DifferentiableAt ğ•œ (fun y => c y â€¢ f y) x :=\n  (hc.hasFDerivAt.smul hf.hasFDerivAt).differentiableAt\n\n"}
{"name":"DifferentiableOn.smul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nğ•œ' : Type u_5\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : E â†’ ğ•œ'\nhc : DifferentiableOn ğ•œ c s\nhf : DifferentiableOn ğ•œ f s\nâŠ¢ DifferentiableOn ğ•œ (fun y => HSMul.hSMul (c y) (f y)) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.smul (hc : DifferentiableOn ğ•œ c s) (hf : DifferentiableOn ğ•œ f s) :\n    DifferentiableOn ğ•œ (fun y => c y â€¢ f y) s := fun x hx => (hc x hx).smul (hf x hx)\n\n"}
{"name":"Differentiable.smul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : E â†’ F\nğ•œ' : Type u_5\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : E â†’ ğ•œ'\nhc : Differentiable ğ•œ c\nhf : Differentiable ğ•œ f\nâŠ¢ Differentiable ğ•œ fun y => HSMul.hSMul (c y) (f y)","decl":"@[simp, fun_prop]\ntheorem Differentiable.smul (hc : Differentiable ğ•œ c) (hf : Differentiable ğ•œ f) :\n    Differentiable ğ•œ fun y => c y â€¢ f y := fun x => (hc x).smul (hf x)\n\n"}
{"name":"fderivWithin_smul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nğ•œ' : Type u_5\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : E â†’ ğ•œ'\nhxs : UniqueDiffWithinAt ğ•œ s x\nhc : DifferentiableWithinAt ğ•œ c s x\nhf : DifferentiableWithinAt ğ•œ f s x\nâŠ¢ Eq (fderivWithin ğ•œ (fun y => HSMul.hSMul (c y) (f y)) s x) (HAdd.hAdd (HSMul.hSMul (c x) (fderivWithin ğ•œ f s x)) ((fderivWithin ğ•œ c s x).smulRight (f x)))","decl":"theorem fderivWithin_smul (hxs : UniqueDiffWithinAt ğ•œ s x) (hc : DifferentiableWithinAt ğ•œ c s x)\n    (hf : DifferentiableWithinAt ğ•œ f s x) :\n    fderivWithin ğ•œ (fun y => c y â€¢ f y) s x =\n      c x â€¢ fderivWithin ğ•œ f s x + (fderivWithin ğ•œ c s x).smulRight (f x) :=\n  (hc.hasFDerivWithinAt.smul hf.hasFDerivWithinAt).fderivWithin hxs\n\n"}
{"name":"fderiv_smul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nğ•œ' : Type u_5\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : E â†’ ğ•œ'\nhc : DifferentiableAt ğ•œ c x\nhf : DifferentiableAt ğ•œ f x\nâŠ¢ Eq (fderiv ğ•œ (fun y => HSMul.hSMul (c y) (f y)) x) (HAdd.hAdd (HSMul.hSMul (c x) (fderiv ğ•œ f x)) ((fderiv ğ•œ c x).smulRight (f x)))","decl":"theorem fderiv_smul (hc : DifferentiableAt ğ•œ c x) (hf : DifferentiableAt ğ•œ f x) :\n    fderiv ğ•œ (fun y => c y â€¢ f y) x = c x â€¢ fderiv ğ•œ f x + (fderiv ğ•œ c x).smulRight (f x) :=\n  (hc.hasFDerivAt.smul hf.hasFDerivAt).fderiv\n\n"}
{"name":"HasStrictFDerivAt.smul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : E\nğ•œ' : Type u_5\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : E â†’ ğ•œ'\nc' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ•œ'\nhc : HasStrictFDerivAt c c' x\nf : F\nâŠ¢ HasStrictFDerivAt (fun y => HSMul.hSMul (c y) f) (c'.smulRight f) x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.smul_const (hc : HasStrictFDerivAt c c' x) (f : F) :\n    HasStrictFDerivAt (fun y => c y â€¢ f) (c'.smulRight f) x := by\n  simpa only [smul_zero, zero_add] using hc.smul (hasStrictFDerivAt_const f x)\n\n"}
{"name":"HasFDerivWithinAt.smul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : E\ns : Set E\nğ•œ' : Type u_5\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : E â†’ ğ•œ'\nc' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ•œ'\nhc : HasFDerivWithinAt c c' s x\nf : F\nâŠ¢ HasFDerivWithinAt (fun y => HSMul.hSMul (c y) f) (c'.smulRight f) s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.smul_const (hc : HasFDerivWithinAt c c' s x) (f : F) :\n    HasFDerivWithinAt (fun y => c y â€¢ f) (c'.smulRight f) s x := by\n  simpa only [smul_zero, zero_add] using hc.smul (hasFDerivWithinAt_const f x s)\n\n"}
{"name":"HasFDerivAt.smul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : E\nğ•œ' : Type u_5\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : E â†’ ğ•œ'\nc' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ•œ'\nhc : HasFDerivAt c c' x\nf : F\nâŠ¢ HasFDerivAt (fun y => HSMul.hSMul (c y) f) (c'.smulRight f) x","decl":"@[fun_prop]\ntheorem HasFDerivAt.smul_const (hc : HasFDerivAt c c' x) (f : F) :\n    HasFDerivAt (fun y => c y â€¢ f) (c'.smulRight f) x := by\n  simpa only [smul_zero, zero_add] using hc.smul (hasFDerivAt_const f x)\n\n"}
{"name":"DifferentiableWithinAt.smul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : E\ns : Set E\nğ•œ' : Type u_5\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : E â†’ ğ•œ'\nhc : DifferentiableWithinAt ğ•œ c s x\nf : F\nâŠ¢ DifferentiableWithinAt ğ•œ (fun y => HSMul.hSMul (c y) f) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.smul_const (hc : DifferentiableWithinAt ğ•œ c s x) (f : F) :\n    DifferentiableWithinAt ğ•œ (fun y => c y â€¢ f) s x :=\n  (hc.hasFDerivWithinAt.smul_const f).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.smul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : E\nğ•œ' : Type u_5\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : E â†’ ğ•œ'\nhc : DifferentiableAt ğ•œ c x\nf : F\nâŠ¢ DifferentiableAt ğ•œ (fun y => HSMul.hSMul (c y) f) x","decl":"@[fun_prop]\ntheorem DifferentiableAt.smul_const (hc : DifferentiableAt ğ•œ c x) (f : F) :\n    DifferentiableAt ğ•œ (fun y => c y â€¢ f) x :=\n  (hc.hasFDerivAt.smul_const f).differentiableAt\n\n"}
{"name":"DifferentiableOn.smul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ns : Set E\nğ•œ' : Type u_5\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : E â†’ ğ•œ'\nhc : DifferentiableOn ğ•œ c s\nf : F\nâŠ¢ DifferentiableOn ğ•œ (fun y => HSMul.hSMul (c y) f) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.smul_const (hc : DifferentiableOn ğ•œ c s) (f : F) :\n    DifferentiableOn ğ•œ (fun y => c y â€¢ f) s := fun x hx => (hc x hx).smul_const f\n\n"}
{"name":"Differentiable.smul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nğ•œ' : Type u_5\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : E â†’ ğ•œ'\nhc : Differentiable ğ•œ c\nf : F\nâŠ¢ Differentiable ğ•œ fun y => HSMul.hSMul (c y) f","decl":"@[fun_prop]\ntheorem Differentiable.smul_const (hc : Differentiable ğ•œ c) (f : F) :\n    Differentiable ğ•œ fun y => c y â€¢ f := fun x => (hc x).smul_const f\n\n"}
{"name":"fderivWithin_smul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : E\ns : Set E\nğ•œ' : Type u_5\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : E â†’ ğ•œ'\nhxs : UniqueDiffWithinAt ğ•œ s x\nhc : DifferentiableWithinAt ğ•œ c s x\nf : F\nâŠ¢ Eq (fderivWithin ğ•œ (fun y => HSMul.hSMul (c y) f) s x) ((fderivWithin ğ•œ c s x).smulRight f)","decl":"theorem fderivWithin_smul_const (hxs : UniqueDiffWithinAt ğ•œ s x)\n    (hc : DifferentiableWithinAt ğ•œ c s x) (f : F) :\n    fderivWithin ğ•œ (fun y => c y â€¢ f) s x = (fderivWithin ğ•œ c s x).smulRight f :=\n  (hc.hasFDerivWithinAt.smul_const f).fderivWithin hxs\n\n"}
{"name":"fderiv_smul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : E\nğ•œ' : Type u_5\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : E â†’ ğ•œ'\nhc : DifferentiableAt ğ•œ c x\nf : F\nâŠ¢ Eq (fderiv ğ•œ (fun y => HSMul.hSMul (c y) f) x) ((fderiv ğ•œ c x).smulRight f)","decl":"theorem fderiv_smul_const (hc : DifferentiableAt ğ•œ c x) (f : F) :\n    fderiv ğ•œ (fun y => c y â€¢ f) x = (fderiv ğ•œ c x).smulRight f :=\n  (hc.hasFDerivAt.smul_const f).fderiv\n\n"}
{"name":"HasStrictFDerivAt.mul'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na b : E â†’ ğ”¸\na' b' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸\nx : E\nha : HasStrictFDerivAt a a' x\nhb : HasStrictFDerivAt b b' x\nâŠ¢ HasStrictFDerivAt (fun y => HMul.hMul (a y) (b y)) (HAdd.hAdd (HSMul.hSMul (a x) b') (a'.smulRight (b x))) x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.mul' {x : E} (ha : HasStrictFDerivAt a a' x)\n    (hb : HasStrictFDerivAt b b' x) :\n    HasStrictFDerivAt (fun y => a y * b y) (a x â€¢ b' + a'.smulRight (b x)) x :=\n  ((ContinuousLinearMap.mul ğ•œ ğ”¸).isBoundedBilinearMap.hasStrictFDerivAt (a x, b x)).comp x\n    (ha.prod hb)\n\n"}
{"name":"HasStrictFDerivAt.mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nğ”¸' : Type u_6\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nc d : E â†’ ğ”¸'\nc' d' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸'\nhc : HasStrictFDerivAt c c' x\nhd : HasStrictFDerivAt d d' x\nâŠ¢ HasStrictFDerivAt (fun y => HMul.hMul (c y) (d y)) (HAdd.hAdd (HSMul.hSMul (c x) d') (HSMul.hSMul (d x) c')) x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.mul (hc : HasStrictFDerivAt c c' x) (hd : HasStrictFDerivAt d d' x) :\n    HasStrictFDerivAt (fun y => c y * d y) (c x â€¢ d' + d x â€¢ c') x := by\n  convert hc.mul' hd\n  ext z\n  apply mul_comm\n\n"}
{"name":"HasFDerivWithinAt.mul'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\ns : Set E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na b : E â†’ ğ”¸\na' b' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸\nha : HasFDerivWithinAt a a' s x\nhb : HasFDerivWithinAt b b' s x\nâŠ¢ HasFDerivWithinAt (fun y => HMul.hMul (a y) (b y)) (HAdd.hAdd (HSMul.hSMul (a x) b') (a'.smulRight (b x))) s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.mul' (ha : HasFDerivWithinAt a a' s x) (hb : HasFDerivWithinAt b b' s x) :\n    HasFDerivWithinAt (fun y => a y * b y) (a x â€¢ b' + a'.smulRight (b x)) s x := by\n  exact ((ContinuousLinearMap.mul ğ•œ ğ”¸).isBoundedBilinearMap.hasFDerivAt\n    (a x, b x)).comp_hasFDerivWithinAt x (ha.prod hb)\n\n"}
{"name":"HasFDerivWithinAt.mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\ns : Set E\nğ”¸' : Type u_6\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nc d : E â†’ ğ”¸'\nc' d' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸'\nhc : HasFDerivWithinAt c c' s x\nhd : HasFDerivWithinAt d d' s x\nâŠ¢ HasFDerivWithinAt (fun y => HMul.hMul (c y) (d y)) (HAdd.hAdd (HSMul.hSMul (c x) d') (HSMul.hSMul (d x) c')) s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.mul (hc : HasFDerivWithinAt c c' s x) (hd : HasFDerivWithinAt d d' s x) :\n    HasFDerivWithinAt (fun y => c y * d y) (c x â€¢ d' + d x â€¢ c') s x := by\n  convert hc.mul' hd\n  ext z\n  apply mul_comm\n\n"}
{"name":"HasFDerivAt.mul'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na b : E â†’ ğ”¸\na' b' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸\nha : HasFDerivAt a a' x\nhb : HasFDerivAt b b' x\nâŠ¢ HasFDerivAt (fun y => HMul.hMul (a y) (b y)) (HAdd.hAdd (HSMul.hSMul (a x) b') (a'.smulRight (b x))) x","decl":"@[fun_prop]\ntheorem HasFDerivAt.mul' (ha : HasFDerivAt a a' x) (hb : HasFDerivAt b b' x) :\n    HasFDerivAt (fun y => a y * b y) (a x â€¢ b' + a'.smulRight (b x)) x := by\n  exact ((ContinuousLinearMap.mul ğ•œ ğ”¸).isBoundedBilinearMap.hasFDerivAt\n    (a x, b x)).comp x (ha.prod hb)\n\n"}
{"name":"HasFDerivAt.mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nğ”¸' : Type u_6\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nc d : E â†’ ğ”¸'\nc' d' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸'\nhc : HasFDerivAt c c' x\nhd : HasFDerivAt d d' x\nâŠ¢ HasFDerivAt (fun y => HMul.hMul (c y) (d y)) (HAdd.hAdd (HSMul.hSMul (c x) d') (HSMul.hSMul (d x) c')) x","decl":"@[fun_prop]\ntheorem HasFDerivAt.mul (hc : HasFDerivAt c c' x) (hd : HasFDerivAt d d' x) :\n    HasFDerivAt (fun y => c y * d y) (c x â€¢ d' + d x â€¢ c') x := by\n  convert hc.mul' hd\n  ext z\n  apply mul_comm\n\n"}
{"name":"DifferentiableWithinAt.mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\ns : Set E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na b : E â†’ ğ”¸\nha : DifferentiableWithinAt ğ•œ a s x\nhb : DifferentiableWithinAt ğ•œ b s x\nâŠ¢ DifferentiableWithinAt ğ•œ (fun y => HMul.hMul (a y) (b y)) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.mul (ha : DifferentiableWithinAt ğ•œ a s x)\n    (hb : DifferentiableWithinAt ğ•œ b s x) : DifferentiableWithinAt ğ•œ (fun y => a y * b y) s x :=\n  (ha.hasFDerivWithinAt.mul' hb.hasFDerivWithinAt).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na b : E â†’ ğ”¸\nha : DifferentiableAt ğ•œ a x\nhb : DifferentiableAt ğ•œ b x\nâŠ¢ DifferentiableAt ğ•œ (fun y => HMul.hMul (a y) (b y)) x","decl":"@[simp, fun_prop]\ntheorem DifferentiableAt.mul (ha : DifferentiableAt ğ•œ a x) (hb : DifferentiableAt ğ•œ b x) :\n    DifferentiableAt ğ•œ (fun y => a y * b y) x :=\n  (ha.hasFDerivAt.mul' hb.hasFDerivAt).differentiableAt\n\n"}
{"name":"DifferentiableOn.mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ns : Set E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na b : E â†’ ğ”¸\nha : DifferentiableOn ğ•œ a s\nhb : DifferentiableOn ğ•œ b s\nâŠ¢ DifferentiableOn ğ•œ (fun y => HMul.hMul (a y) (b y)) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.mul (ha : DifferentiableOn ğ•œ a s) (hb : DifferentiableOn ğ•œ b s) :\n    DifferentiableOn ğ•œ (fun y => a y * b y) s := fun x hx => (ha x hx).mul (hb x hx)\n\n"}
{"name":"Differentiable.mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na b : E â†’ ğ”¸\nha : Differentiable ğ•œ a\nhb : Differentiable ğ•œ b\nâŠ¢ Differentiable ğ•œ fun y => HMul.hMul (a y) (b y)","decl":"@[simp, fun_prop]\ntheorem Differentiable.mul (ha : Differentiable ğ•œ a) (hb : Differentiable ğ•œ b) :\n    Differentiable ğ•œ fun y => a y * b y := fun x => (ha x).mul (hb x)\n\n"}
{"name":"DifferentiableWithinAt.pow","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\ns : Set E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\nha : DifferentiableWithinAt ğ•œ a s x\nn : Nat\nâŠ¢ DifferentiableWithinAt ğ•œ (fun x => HPow.hPow (a x) n) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.pow (ha : DifferentiableWithinAt ğ•œ a s x) :\n    âˆ€ n : â„•, DifferentiableWithinAt ğ•œ (fun x => a x ^ n) s x\n  | 0 => by simp only [pow_zero, differentiableWithinAt_const]\n  | n + 1 => by simp only [pow_succ', DifferentiableWithinAt.pow ha n, ha.mul]\n\n"}
{"name":"DifferentiableAt.pow","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\nha : DifferentiableAt ğ•œ a x\nn : Nat\nâŠ¢ DifferentiableAt ğ•œ (fun x => HPow.hPow (a x) n) x","decl":"@[simp, fun_prop]\ntheorem DifferentiableAt.pow (ha : DifferentiableAt ğ•œ a x) (n : â„•) :\n    DifferentiableAt ğ•œ (fun x => a x ^ n) x :=\n  differentiableWithinAt_univ.mp <| ha.differentiableWithinAt.pow n\n\n"}
{"name":"DifferentiableOn.pow","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ns : Set E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\nha : DifferentiableOn ğ•œ a s\nn : Nat\nâŠ¢ DifferentiableOn ğ•œ (fun x => HPow.hPow (a x) n) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.pow (ha : DifferentiableOn ğ•œ a s) (n : â„•) :\n    DifferentiableOn ğ•œ (fun x => a x ^ n) s := fun x h => (ha x h).pow n\n\n"}
{"name":"Differentiable.pow","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\nha : Differentiable ğ•œ a\nn : Nat\nâŠ¢ Differentiable ğ•œ fun x => HPow.hPow (a x) n","decl":"@[simp, fun_prop]\ntheorem Differentiable.pow (ha : Differentiable ğ•œ a) (n : â„•) : Differentiable ğ•œ fun x => a x ^ n :=\n  fun x => (ha x).pow n\n\n"}
{"name":"fderivWithin_mul'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\ns : Set E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na b : E â†’ ğ”¸\nhxs : UniqueDiffWithinAt ğ•œ s x\nha : DifferentiableWithinAt ğ•œ a s x\nhb : DifferentiableWithinAt ğ•œ b s x\nâŠ¢ Eq (fderivWithin ğ•œ (fun y => HMul.hMul (a y) (b y)) s x) (HAdd.hAdd (HSMul.hSMul (a x) (fderivWithin ğ•œ b s x)) ((fderivWithin ğ•œ a s x).smulRight (b x)))","decl":"theorem fderivWithin_mul' (hxs : UniqueDiffWithinAt ğ•œ s x) (ha : DifferentiableWithinAt ğ•œ a s x)\n    (hb : DifferentiableWithinAt ğ•œ b s x) :\n    fderivWithin ğ•œ (fun y => a y * b y) s x =\n      a x â€¢ fderivWithin ğ•œ b s x + (fderivWithin ğ•œ a s x).smulRight (b x) :=\n  (ha.hasFDerivWithinAt.mul' hb.hasFDerivWithinAt).fderivWithin hxs\n\n"}
{"name":"fderivWithin_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\ns : Set E\nğ”¸' : Type u_6\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nc d : E â†’ ğ”¸'\nhxs : UniqueDiffWithinAt ğ•œ s x\nhc : DifferentiableWithinAt ğ•œ c s x\nhd : DifferentiableWithinAt ğ•œ d s x\nâŠ¢ Eq (fderivWithin ğ•œ (fun y => HMul.hMul (c y) (d y)) s x) (HAdd.hAdd (HSMul.hSMul (c x) (fderivWithin ğ•œ d s x)) (HSMul.hSMul (d x) (fderivWithin ğ•œ c s x)))","decl":"theorem fderivWithin_mul (hxs : UniqueDiffWithinAt ğ•œ s x) (hc : DifferentiableWithinAt ğ•œ c s x)\n    (hd : DifferentiableWithinAt ğ•œ d s x) :\n    fderivWithin ğ•œ (fun y => c y * d y) s x =\n      c x â€¢ fderivWithin ğ•œ d s x + d x â€¢ fderivWithin ğ•œ c s x :=\n  (hc.hasFDerivWithinAt.mul hd.hasFDerivWithinAt).fderivWithin hxs\n\n"}
{"name":"fderiv_mul'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na b : E â†’ ğ”¸\nha : DifferentiableAt ğ•œ a x\nhb : DifferentiableAt ğ•œ b x\nâŠ¢ Eq (fderiv ğ•œ (fun y => HMul.hMul (a y) (b y)) x) (HAdd.hAdd (HSMul.hSMul (a x) (fderiv ğ•œ b x)) ((fderiv ğ•œ a x).smulRight (b x)))","decl":"theorem fderiv_mul' (ha : DifferentiableAt ğ•œ a x) (hb : DifferentiableAt ğ•œ b x) :\n    fderiv ğ•œ (fun y => a y * b y) x = a x â€¢ fderiv ğ•œ b x + (fderiv ğ•œ a x).smulRight (b x) :=\n  (ha.hasFDerivAt.mul' hb.hasFDerivAt).fderiv\n\n"}
{"name":"fderiv_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nğ”¸' : Type u_6\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nc d : E â†’ ğ”¸'\nhc : DifferentiableAt ğ•œ c x\nhd : DifferentiableAt ğ•œ d x\nâŠ¢ Eq (fderiv ğ•œ (fun y => HMul.hMul (c y) (d y)) x) (HAdd.hAdd (HSMul.hSMul (c x) (fderiv ğ•œ d x)) (HSMul.hSMul (d x) (fderiv ğ•œ c x)))","decl":"theorem fderiv_mul (hc : DifferentiableAt ğ•œ c x) (hd : DifferentiableAt ğ•œ d x) :\n    fderiv ğ•œ (fun y => c y * d y) x = c x â€¢ fderiv ğ•œ d x + d x â€¢ fderiv ğ•œ c x :=\n  (hc.hasFDerivAt.mul hd.hasFDerivAt).fderiv\n\n"}
{"name":"HasStrictFDerivAt.mul_const'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\na' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸\nha : HasStrictFDerivAt a a' x\nb : ğ”¸\nâŠ¢ HasStrictFDerivAt (fun y => HMul.hMul (a y) b) (a'.smulRight b) x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.mul_const' (ha : HasStrictFDerivAt a a' x) (b : ğ”¸) :\n    HasStrictFDerivAt (fun y => a y * b) (a'.smulRight b) x :=\n  ((ContinuousLinearMap.mul ğ•œ ğ”¸).flip b).hasStrictFDerivAt.comp x ha\n\n"}
{"name":"HasStrictFDerivAt.mul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nğ”¸' : Type u_6\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nc : E â†’ ğ”¸'\nc' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸'\nhc : HasStrictFDerivAt c c' x\nd : ğ”¸'\nâŠ¢ HasStrictFDerivAt (fun y => HMul.hMul (c y) d) (HSMul.hSMul d c') x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.mul_const (hc : HasStrictFDerivAt c c' x) (d : ğ”¸') :\n    HasStrictFDerivAt (fun y => c y * d) (d â€¢ c') x := by\n  convert hc.mul_const' d\n  ext z\n  apply mul_comm\n\n"}
{"name":"HasFDerivWithinAt.mul_const'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\ns : Set E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\na' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸\nha : HasFDerivWithinAt a a' s x\nb : ğ”¸\nâŠ¢ HasFDerivWithinAt (fun y => HMul.hMul (a y) b) (a'.smulRight b) s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.mul_const' (ha : HasFDerivWithinAt a a' s x) (b : ğ”¸) :\n    HasFDerivWithinAt (fun y => a y * b) (a'.smulRight b) s x :=\n  ((ContinuousLinearMap.mul ğ•œ ğ”¸).flip b).hasFDerivAt.comp_hasFDerivWithinAt x ha\n\n"}
{"name":"HasFDerivWithinAt.mul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\ns : Set E\nğ”¸' : Type u_6\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nc : E â†’ ğ”¸'\nc' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸'\nhc : HasFDerivWithinAt c c' s x\nd : ğ”¸'\nâŠ¢ HasFDerivWithinAt (fun y => HMul.hMul (c y) d) (HSMul.hSMul d c') s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.mul_const (hc : HasFDerivWithinAt c c' s x) (d : ğ”¸') :\n    HasFDerivWithinAt (fun y => c y * d) (d â€¢ c') s x := by\n  convert hc.mul_const' d\n  ext z\n  apply mul_comm\n\n"}
{"name":"HasFDerivAt.mul_const'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\na' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸\nha : HasFDerivAt a a' x\nb : ğ”¸\nâŠ¢ HasFDerivAt (fun y => HMul.hMul (a y) b) (a'.smulRight b) x","decl":"@[fun_prop]\ntheorem HasFDerivAt.mul_const' (ha : HasFDerivAt a a' x) (b : ğ”¸) :\n    HasFDerivAt (fun y => a y * b) (a'.smulRight b) x :=\n  ((ContinuousLinearMap.mul ğ•œ ğ”¸).flip b).hasFDerivAt.comp x ha\n\n"}
{"name":"HasFDerivAt.mul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nğ”¸' : Type u_6\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nc : E â†’ ğ”¸'\nc' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸'\nhc : HasFDerivAt c c' x\nd : ğ”¸'\nâŠ¢ HasFDerivAt (fun y => HMul.hMul (c y) d) (HSMul.hSMul d c') x","decl":"@[fun_prop]\ntheorem HasFDerivAt.mul_const (hc : HasFDerivAt c c' x) (d : ğ”¸') :\n    HasFDerivAt (fun y => c y * d) (d â€¢ c') x := by\n  convert hc.mul_const' d\n  ext z\n  apply mul_comm\n\n"}
{"name":"DifferentiableWithinAt.mul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\ns : Set E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\nha : DifferentiableWithinAt ğ•œ a s x\nb : ğ”¸\nâŠ¢ DifferentiableWithinAt ğ•œ (fun y => HMul.hMul (a y) b) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.mul_const (ha : DifferentiableWithinAt ğ•œ a s x) (b : ğ”¸) :\n    DifferentiableWithinAt ğ•œ (fun y => a y * b) s x :=\n  (ha.hasFDerivWithinAt.mul_const' b).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.mul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\nha : DifferentiableAt ğ•œ a x\nb : ğ”¸\nâŠ¢ DifferentiableAt ğ•œ (fun y => HMul.hMul (a y) b) x","decl":"@[fun_prop]\ntheorem DifferentiableAt.mul_const (ha : DifferentiableAt ğ•œ a x) (b : ğ”¸) :\n    DifferentiableAt ğ•œ (fun y => a y * b) x :=\n  (ha.hasFDerivAt.mul_const' b).differentiableAt\n\n"}
{"name":"DifferentiableOn.mul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ns : Set E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\nha : DifferentiableOn ğ•œ a s\nb : ğ”¸\nâŠ¢ DifferentiableOn ğ•œ (fun y => HMul.hMul (a y) b) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.mul_const (ha : DifferentiableOn ğ•œ a s) (b : ğ”¸) :\n    DifferentiableOn ğ•œ (fun y => a y * b) s := fun x hx => (ha x hx).mul_const b\n\n"}
{"name":"Differentiable.mul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\nha : Differentiable ğ•œ a\nb : ğ”¸\nâŠ¢ Differentiable ğ•œ fun y => HMul.hMul (a y) b","decl":"@[fun_prop]\ntheorem Differentiable.mul_const (ha : Differentiable ğ•œ a) (b : ğ”¸) :\n    Differentiable ğ•œ fun y => a y * b := fun x => (ha x).mul_const b\n\n"}
{"name":"fderivWithin_mul_const'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\ns : Set E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\nhxs : UniqueDiffWithinAt ğ•œ s x\nha : DifferentiableWithinAt ğ•œ a s x\nb : ğ”¸\nâŠ¢ Eq (fderivWithin ğ•œ (fun y => HMul.hMul (a y) b) s x) ((fderivWithin ğ•œ a s x).smulRight b)","decl":"theorem fderivWithin_mul_const' (hxs : UniqueDiffWithinAt ğ•œ s x)\n    (ha : DifferentiableWithinAt ğ•œ a s x) (b : ğ”¸) :\n    fderivWithin ğ•œ (fun y => a y * b) s x = (fderivWithin ğ•œ a s x).smulRight b :=\n  (ha.hasFDerivWithinAt.mul_const' b).fderivWithin hxs\n\n"}
{"name":"fderivWithin_mul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\ns : Set E\nğ”¸' : Type u_6\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nc : E â†’ ğ”¸'\nhxs : UniqueDiffWithinAt ğ•œ s x\nhc : DifferentiableWithinAt ğ•œ c s x\nd : ğ”¸'\nâŠ¢ Eq (fderivWithin ğ•œ (fun y => HMul.hMul (c y) d) s x) (HSMul.hSMul d (fderivWithin ğ•œ c s x))","decl":"theorem fderivWithin_mul_const (hxs : UniqueDiffWithinAt ğ•œ s x)\n    (hc : DifferentiableWithinAt ğ•œ c s x) (d : ğ”¸') :\n    fderivWithin ğ•œ (fun y => c y * d) s x = d â€¢ fderivWithin ğ•œ c s x :=\n  (hc.hasFDerivWithinAt.mul_const d).fderivWithin hxs\n\n"}
{"name":"fderiv_mul_const'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\nha : DifferentiableAt ğ•œ a x\nb : ğ”¸\nâŠ¢ Eq (fderiv ğ•œ (fun y => HMul.hMul (a y) b) x) ((fderiv ğ•œ a x).smulRight b)","decl":"theorem fderiv_mul_const' (ha : DifferentiableAt ğ•œ a x) (b : ğ”¸) :\n    fderiv ğ•œ (fun y => a y * b) x = (fderiv ğ•œ a x).smulRight b :=\n  (ha.hasFDerivAt.mul_const' b).fderiv\n\n"}
{"name":"fderiv_mul_const","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nğ”¸' : Type u_6\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nc : E â†’ ğ”¸'\nhc : DifferentiableAt ğ•œ c x\nd : ğ”¸'\nâŠ¢ Eq (fderiv ğ•œ (fun y => HMul.hMul (c y) d) x) (HSMul.hSMul d (fderiv ğ•œ c x))","decl":"theorem fderiv_mul_const (hc : DifferentiableAt ğ•œ c x) (d : ğ”¸') :\n    fderiv ğ•œ (fun y => c y * d) x = d â€¢ fderiv ğ•œ c x :=\n  (hc.hasFDerivAt.mul_const d).fderiv\n\n"}
{"name":"HasStrictFDerivAt.const_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\na' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸\nha : HasStrictFDerivAt a a' x\nb : ğ”¸\nâŠ¢ HasStrictFDerivAt (fun y => HMul.hMul b (a y)) (HSMul.hSMul b a') x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.const_mul (ha : HasStrictFDerivAt a a' x) (b : ğ”¸) :\n    HasStrictFDerivAt (fun y => b * a y) (b â€¢ a') x :=\n  ((ContinuousLinearMap.mul ğ•œ ğ”¸) b).hasStrictFDerivAt.comp x ha\n\n"}
{"name":"HasFDerivWithinAt.const_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\ns : Set E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\na' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸\nha : HasFDerivWithinAt a a' s x\nb : ğ”¸\nâŠ¢ HasFDerivWithinAt (fun y => HMul.hMul b (a y)) (HSMul.hSMul b a') s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.const_mul (ha : HasFDerivWithinAt a a' s x) (b : ğ”¸) :\n    HasFDerivWithinAt (fun y => b * a y) (b â€¢ a') s x :=\n  ((ContinuousLinearMap.mul ğ•œ ğ”¸) b).hasFDerivAt.comp_hasFDerivWithinAt x ha\n\n"}
{"name":"HasFDerivAt.const_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\na' : ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸\nha : HasFDerivAt a a' x\nb : ğ”¸\nâŠ¢ HasFDerivAt (fun y => HMul.hMul b (a y)) (HSMul.hSMul b a') x","decl":"@[fun_prop]\ntheorem HasFDerivAt.const_mul (ha : HasFDerivAt a a' x) (b : ğ”¸) :\n    HasFDerivAt (fun y => b * a y) (b â€¢ a') x :=\n  ((ContinuousLinearMap.mul ğ•œ ğ”¸) b).hasFDerivAt.comp x ha\n\n"}
{"name":"DifferentiableWithinAt.const_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\ns : Set E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\nha : DifferentiableWithinAt ğ•œ a s x\nb : ğ”¸\nâŠ¢ DifferentiableWithinAt ğ•œ (fun y => HMul.hMul b (a y)) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.const_mul (ha : DifferentiableWithinAt ğ•œ a s x) (b : ğ”¸) :\n    DifferentiableWithinAt ğ•œ (fun y => b * a y) s x :=\n  (ha.hasFDerivWithinAt.const_mul b).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.const_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\nha : DifferentiableAt ğ•œ a x\nb : ğ”¸\nâŠ¢ DifferentiableAt ğ•œ (fun y => HMul.hMul b (a y)) x","decl":"@[fun_prop]\ntheorem DifferentiableAt.const_mul (ha : DifferentiableAt ğ•œ a x) (b : ğ”¸) :\n    DifferentiableAt ğ•œ (fun y => b * a y) x :=\n  (ha.hasFDerivAt.const_mul b).differentiableAt\n\n"}
{"name":"DifferentiableOn.const_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ns : Set E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\nha : DifferentiableOn ğ•œ a s\nb : ğ”¸\nâŠ¢ DifferentiableOn ğ•œ (fun y => HMul.hMul b (a y)) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.const_mul (ha : DifferentiableOn ğ•œ a s) (b : ğ”¸) :\n    DifferentiableOn ğ•œ (fun y => b * a y) s := fun x hx => (ha x hx).const_mul b\n\n"}
{"name":"Differentiable.const_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\nha : Differentiable ğ•œ a\nb : ğ”¸\nâŠ¢ Differentiable ğ•œ fun y => HMul.hMul b (a y)","decl":"@[fun_prop]\ntheorem Differentiable.const_mul (ha : Differentiable ğ•œ a) (b : ğ”¸) :\n    Differentiable ğ•œ fun y => b * a y := fun x => (ha x).const_mul b\n\n"}
{"name":"fderivWithin_const_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\ns : Set E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\nhxs : UniqueDiffWithinAt ğ•œ s x\nha : DifferentiableWithinAt ğ•œ a s x\nb : ğ”¸\nâŠ¢ Eq (fderivWithin ğ•œ (fun y => HMul.hMul b (a y)) s x) (HSMul.hSMul b (fderivWithin ğ•œ a s x))","decl":"theorem fderivWithin_const_mul (hxs : UniqueDiffWithinAt ğ•œ s x)\n    (ha : DifferentiableWithinAt ğ•œ a s x) (b : ğ”¸) :\n    fderivWithin ğ•œ (fun y => b * a y) s x = b â€¢ fderivWithin ğ•œ a s x :=\n  (ha.hasFDerivWithinAt.const_mul b).fderivWithin hxs\n\n"}
{"name":"fderiv_const_mul","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nğ”¸ : Type u_5\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\na : E â†’ ğ”¸\nha : DifferentiableAt ğ•œ a x\nb : ğ”¸\nâŠ¢ Eq (fderiv ğ•œ (fun y => HMul.hMul b (a y)) x) (HSMul.hSMul b (fderiv ğ•œ a x))","decl":"theorem fderiv_const_mul (ha : DifferentiableAt ğ•œ a x) (b : ğ”¸) :\n    fderiv ğ•œ (fun y => b * a y) x = b â€¢ fderiv ğ•œ a x :=\n  (ha.hasFDerivAt.const_mul b).fderiv\n\n"}
{"name":"hasStrictFDerivAt_list_prod'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_5\nğ”¸ : Type u_6\ninstâœÂ² : NormedRing ğ”¸\ninstâœÂ¹ : NormedAlgebra ğ•œ ğ”¸\ninstâœ : Fintype Î¹\nl : List Î¹\nx : Î¹ â†’ ğ”¸\nâŠ¢ HasStrictFDerivAt (fun x => (List.map x l).prod) (Finset.univ.sum fun i => HSMul.hSMul (List.map x (List.take (â†‘i) l)).prod ((ContinuousLinearMap.proj (GetElem.getElem l i â‹¯)).smulRight (List.map x (List.drop (â†‘i).succ l)).prod)) x","decl":"@[fun_prop]\ntheorem hasStrictFDerivAt_list_prod' [Fintype Î¹] {l : List Î¹} {x : Î¹ â†’ ğ”¸} :\n    HasStrictFDerivAt (ğ•œ := ğ•œ) (fun x â†¦ (l.map x).prod)\n      (âˆ‘ i : Fin l.length, ((l.take i).map x).prod â€¢\n        smulRight (proj l[i]) ((l.drop (.succ i)).map x).prod) x := by\n  induction l with\n  | nil => simp [hasStrictFDerivAt_const]\n  | cons a l IH =>\n    simp only [List.map_cons, List.prod_cons, â† proj_apply (R := ğ•œ) (Ï† := fun _ : Î¹ â†¦ ğ”¸) a]\n    exact .congr_fderiv (.mul' (ContinuousLinearMap.hasStrictFDerivAt _) IH)\n      (by ext; simp [Fin.sum_univ_succ, Finset.mul_sum, mul_assoc, add_comm])\n\n"}
{"name":"hasStrictFDerivAt_list_prod_finRange'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nğ”¸ : Type u_6\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nn : Nat\nx : Fin n â†’ ğ”¸\nâŠ¢ HasStrictFDerivAt (fun x => (List.map x (List.finRange n)).prod) (Finset.univ.sum fun i => HSMul.hSMul (List.map x (List.take (â†‘i) (List.finRange n))).prod ((ContinuousLinearMap.proj i).smulRight (List.map x (List.drop (â†‘i).succ (List.finRange n))).prod)) x","decl":"@[fun_prop]\ntheorem hasStrictFDerivAt_list_prod_finRange' {n : â„•} {x : Fin n â†’ ğ”¸} :\n    HasStrictFDerivAt (ğ•œ := ğ•œ) (fun x â†¦ ((List.finRange n).map x).prod)\n      (âˆ‘ i : Fin n, (((List.finRange n).take i).map x).prod â€¢\n        smulRight (proj i) (((List.finRange n).drop (.succ i)).map x).prod) x :=\n  hasStrictFDerivAt_list_prod'.congr_fderiv <|\n    Finset.sum_equiv (finCongr (List.length_finRange n)) (by simp) (by simp [Fin.forall_iff])\n\n"}
{"name":"hasStrictFDerivAt_list_prod_attach'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_5\nğ”¸ : Type u_6\ninstâœÂ² : NormedRing ğ”¸\ninstâœÂ¹ : NormedAlgebra ğ•œ ğ”¸\ninstâœ : DecidableEq Î¹\nl : List Î¹\nx : (Subtype fun i => Membership.mem l i) â†’ ğ”¸\nâŠ¢ HasStrictFDerivAt (fun x => (List.map x l.attach).prod) (Finset.univ.sum fun i => HSMul.hSMul (List.map x (List.take (â†‘i) l.attach)).prod ((ContinuousLinearMap.proj (GetElem.getElem l.attach (Fin.cast â‹¯ i) â‹¯)).smulRight (List.map x (List.drop (â†‘i).succ l.attach)).prod)) x","decl":"@[fun_prop]\ntheorem hasStrictFDerivAt_list_prod_attach' [DecidableEq Î¹] {l : List Î¹} {x : {i // i âˆˆ l} â†’ ğ”¸} :\n    HasStrictFDerivAt (ğ•œ := ğ•œ) (fun x â†¦ (l.attach.map x).prod)\n      (âˆ‘ i : Fin l.length, ((l.attach.take i).map x).prod â€¢\n        smulRight (proj l.attach[i.cast List.length_attach.symm])\n          ((l.attach.drop (.succ i)).map x).prod) x :=\n  hasStrictFDerivAt_list_prod'.congr_fderiv <| Eq.symm <|\n    Finset.sum_equiv (finCongr List.length_attach.symm) (by simp) (by simp)\n\n"}
{"name":"hasFDerivAt_list_prod'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_5\nğ”¸' : Type u_7\ninstâœÂ² : NormedCommRing ğ”¸'\ninstâœÂ¹ : NormedAlgebra ğ•œ ğ”¸'\ninstâœ : Fintype Î¹\nl : List Î¹\nx : Î¹ â†’ ğ”¸'\nâŠ¢ HasFDerivAt (fun x => (List.map x l).prod) (Finset.univ.sum fun i => HSMul.hSMul (List.map x (List.take (â†‘i) l)).prod ((ContinuousLinearMap.proj (GetElem.getElem l i â‹¯)).smulRight (List.map x (List.drop (â†‘i).succ l)).prod)) x","decl":"@[fun_prop]\ntheorem hasFDerivAt_list_prod' [Fintype Î¹] {l : List Î¹} {x : Î¹ â†’ ğ”¸'} :\n    HasFDerivAt (ğ•œ := ğ•œ) (fun x â†¦ (l.map x).prod)\n      (âˆ‘ i : Fin l.length, ((l.take i).map x).prod â€¢\n        smulRight (proj l[i]) ((l.drop (.succ i)).map x).prod) x :=\n  hasStrictFDerivAt_list_prod'.hasFDerivAt\n\n"}
{"name":"hasFDerivAt_list_prod_finRange'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nğ”¸ : Type u_6\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nn : Nat\nx : Fin n â†’ ğ”¸\nâŠ¢ HasFDerivAt (fun x => (List.map x (List.finRange n)).prod) (Finset.univ.sum fun i => HSMul.hSMul (List.map x (List.take (â†‘i) (List.finRange n))).prod ((ContinuousLinearMap.proj i).smulRight (List.map x (List.drop (â†‘i).succ (List.finRange n))).prod)) x","decl":"@[fun_prop]\ntheorem hasFDerivAt_list_prod_finRange' {n : â„•} {x : Fin n â†’ ğ”¸} :\n    HasFDerivAt (ğ•œ := ğ•œ) (fun x â†¦ ((List.finRange n).map x).prod)\n      (âˆ‘ i : Fin n, (((List.finRange n).take i).map x).prod â€¢\n        smulRight (proj i) (((List.finRange n).drop (.succ i)).map x).prod) x :=\n  (hasStrictFDerivAt_list_prod_finRange').hasFDerivAt\n\n"}
{"name":"hasFDerivAt_list_prod_attach'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_5\nğ”¸ : Type u_6\ninstâœÂ² : NormedRing ğ”¸\ninstâœÂ¹ : NormedAlgebra ğ•œ ğ”¸\ninstâœ : DecidableEq Î¹\nl : List Î¹\nx : (Subtype fun i => Membership.mem l i) â†’ ğ”¸\nâŠ¢ HasFDerivAt (fun x => (List.map x l.attach).prod) (Finset.univ.sum fun i => HSMul.hSMul (List.map x (List.take (â†‘i) l.attach)).prod ((ContinuousLinearMap.proj (GetElem.getElem l.attach (Fin.cast â‹¯ i) â‹¯)).smulRight (List.map x (List.drop (â†‘i).succ l.attach)).prod)) x","decl":"@[fun_prop]\ntheorem hasFDerivAt_list_prod_attach' [DecidableEq Î¹] {l : List Î¹} {x : {i // i âˆˆ l} â†’ ğ”¸} :\n    HasFDerivAt (ğ•œ := ğ•œ) (fun x â†¦ (l.attach.map x).prod)\n      (âˆ‘ i : Fin l.length, ((l.attach.take i).map x).prod â€¢\n        smulRight (proj l.attach[i.cast List.length_attach.symm])\n          ((l.attach.drop (.succ i)).map x).prod) x :=\n  hasStrictFDerivAt_list_prod_attach'.hasFDerivAt\n\n"}
{"name":"hasStrictFDerivAt_list_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_5\nğ”¸' : Type u_7\ninstâœÂ³ : NormedCommRing ğ”¸'\ninstâœÂ² : NormedAlgebra ğ•œ ğ”¸'\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\nl : List Î¹\nx : Î¹ â†’ ğ”¸'\nâŠ¢ HasStrictFDerivAt (fun x => (List.map x l).prod) (List.map (fun i => HSMul.hSMul (List.map x (l.erase i)).prod (ContinuousLinearMap.proj i)) l).sum x","decl":"/--\nAuxiliary lemma for `hasStrictFDerivAt_multiset_prod`.\n\nFor `NormedCommRing ğ”¸'`, can rewrite as `Multiset` using `Multiset.prod_coe`.\n-/\n@[fun_prop]\ntheorem hasStrictFDerivAt_list_prod [DecidableEq Î¹] [Fintype Î¹] {l : List Î¹} {x : Î¹ â†’ ğ”¸'} :\n    HasStrictFDerivAt (ğ•œ := ğ•œ) (fun x â†¦ (l.map x).prod)\n      (l.map fun i â†¦ ((l.erase i).map x).prod â€¢ proj i).sum x := by\n  refine hasStrictFDerivAt_list_prod'.congr_fderiv ?_\n  conv_rhs => arg 1; arg 2; rw [â† List.finRange_map_get l]\n  simp only [List.map_map, â† List.sum_toFinset _ (List.nodup_finRange _), List.toFinset_finRange,\n    Function.comp_def, ((List.erase_getElem _).map _).prod_eq, List.eraseIdx_eq_take_drop_succ,\n    List.map_append, List.prod_append, List.get_eq_getElem, Fin.getElem_fin, Nat.succ_eq_add_one]\n  exact Finset.sum_congr rfl fun i _ â†¦ by\n    ext; simp only [smul_apply, smulRight_apply, smul_eq_mul]; ring\n\n"}
{"name":"hasStrictFDerivAt_multiset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_5\nğ”¸' : Type u_7\ninstâœÂ³ : NormedCommRing ğ”¸'\ninstâœÂ² : NormedAlgebra ğ•œ ğ”¸'\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\nu : Multiset Î¹\nx : Î¹ â†’ ğ”¸'\nâŠ¢ HasStrictFDerivAt (fun x => (Multiset.map x u).prod) (Multiset.map (fun i => HSMul.hSMul (Multiset.map x (u.erase i)).prod (ContinuousLinearMap.proj i)) u).sum x","decl":"@[fun_prop]\ntheorem hasStrictFDerivAt_multiset_prod [DecidableEq Î¹] [Fintype Î¹] {u : Multiset Î¹} {x : Î¹ â†’ ğ”¸'} :\n    HasStrictFDerivAt (ğ•œ := ğ•œ) (fun x â†¦ (u.map x).prod)\n      (u.map (fun i â†¦ ((u.erase i).map x).prod â€¢ proj i)).sum x :=\n  u.inductionOn fun l â†¦ by simpa using hasStrictFDerivAt_list_prod\n\n"}
{"name":"hasFDerivAt_multiset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_5\nğ”¸' : Type u_7\ninstâœÂ³ : NormedCommRing ğ”¸'\ninstâœÂ² : NormedAlgebra ğ•œ ğ”¸'\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\nu : Multiset Î¹\nx : Î¹ â†’ ğ”¸'\nâŠ¢ HasFDerivAt (fun x => (Multiset.map x u).prod) (Multiset.map (fun i => HSMul.hSMul (Multiset.map x (u.erase i)).prod (ContinuousLinearMap.proj i)) u).sum x","decl":"@[fun_prop]\ntheorem hasFDerivAt_multiset_prod [DecidableEq Î¹] [Fintype Î¹] {u : Multiset Î¹} {x : Î¹ â†’ ğ”¸'} :\n    HasFDerivAt (ğ•œ := ğ•œ) (fun x â†¦ (u.map x).prod)\n      (Multiset.sum (u.map (fun i â†¦ ((u.erase i).map x).prod â€¢ proj i))) x :=\n  hasStrictFDerivAt_multiset_prod.hasFDerivAt\n\n"}
{"name":"hasStrictFDerivAt_finset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_5\nğ”¸' : Type u_7\ninstâœÂ³ : NormedCommRing ğ”¸'\ninstâœÂ² : NormedAlgebra ğ•œ ğ”¸'\nu : Finset Î¹\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\nx : Î¹ â†’ ğ”¸'\nâŠ¢ HasStrictFDerivAt (fun x => u.prod fun i => x i) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => x j) (ContinuousLinearMap.proj i)) x","decl":"theorem hasStrictFDerivAt_finset_prod [DecidableEq Î¹] [Fintype Î¹] {x : Î¹ â†’ ğ”¸'} :\n    HasStrictFDerivAt (ğ•œ := ğ•œ) (âˆ i âˆˆ u, Â· i) (âˆ‘ i âˆˆ u, (âˆ j âˆˆ u.erase i, x j) â€¢ proj i) x := by\n  simp only [Finset.sum_eq_multiset_sum, Finset.prod_eq_multiset_prod]\n  exact hasStrictFDerivAt_multiset_prod\n\n"}
{"name":"hasFDerivAt_finset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_5\nğ”¸' : Type u_7\ninstâœÂ³ : NormedCommRing ğ”¸'\ninstâœÂ² : NormedAlgebra ğ•œ ğ”¸'\nu : Finset Î¹\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\nx : Î¹ â†’ ğ”¸'\nâŠ¢ HasFDerivAt (fun x => u.prod fun i => x i) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => x j) (ContinuousLinearMap.proj i)) x","decl":"theorem hasFDerivAt_finset_prod [DecidableEq Î¹] [Fintype Î¹] {x : Î¹ â†’ ğ”¸'} :\n    HasFDerivAt (ğ•œ := ğ•œ) (âˆ i âˆˆ u, Â· i) (âˆ‘ i âˆˆ u, (âˆ j âˆˆ u.erase i, x j) â€¢ proj i) x :=\n  hasStrictFDerivAt_finset_prod.hasFDerivAt\n\n"}
{"name":"HasStrictFDerivAt.list_prod'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nÎ¹ : Type u_5\nğ”¸ : Type u_6\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nf : Î¹ â†’ E â†’ ğ”¸\nf' : Î¹ â†’ ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸\nl : List Î¹\nx : E\nh : âˆ€ (i : Î¹), Membership.mem l i â†’ HasStrictFDerivAt (fun x => f i x) (f' i) x\nâŠ¢ HasStrictFDerivAt (fun x => (List.map (fun x_1 => f x_1 x) l).prod) (Finset.univ.sum fun i => HSMul.hSMul (List.map (fun x_1 => f x_1 x) (List.take (â†‘i) l)).prod ((f' (GetElem.getElem l i â‹¯)).smulRight (List.map (fun x_1 => f x_1 x) (List.drop (â†‘i).succ l)).prod)) x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.list_prod' {l : List Î¹} {x : E}\n    (h : âˆ€ i âˆˆ l, HasStrictFDerivAt (f i Â·) (f' i) x) :\n    HasStrictFDerivAt (fun x â†¦ (l.map (f Â· x)).prod)\n      (âˆ‘ i : Fin l.length, ((l.take i).map (f Â· x)).prod â€¢\n        smulRight (f' l[i]) ((l.drop (.succ i)).map (f Â· x)).prod) x := by\n  simp_rw [Fin.getElem_fin, â† l.get_eq_getElem, â† List.finRange_map_get l, List.map_map]\n  -- After #19108, we have to be optimistic with `:)`s; otherwise Lean decides it need to find\n  -- `NormedAddCommGroup (List ğ”¸)` which is nonsense.\n  refine .congr_fderiv (hasStrictFDerivAt_list_prod_finRange'.comp x\n    (hasStrictFDerivAt_pi.mpr fun i â†¦ h (l.get i) (List.getElem_mem ..)) :) ?_\n  ext m\n  simp_rw [List.map_take, List.map_drop, List.map_map, comp_apply, sum_apply, smul_apply,\n    smulRight_apply, proj_apply, pi_apply, Function.comp_def]\n\n"}
{"name":"HasFDerivAt.list_prod'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nÎ¹ : Type u_5\nğ”¸ : Type u_6\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nf : Î¹ â†’ E â†’ ğ”¸\nf' : Î¹ â†’ ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸\nl : List Î¹\nx : E\nh : âˆ€ (i : Î¹), Membership.mem l i â†’ HasFDerivAt (fun x => f i x) (f' i) x\nâŠ¢ HasFDerivAt (fun x => (List.map (fun x_1 => f x_1 x) l).prod) (Finset.univ.sum fun i => HSMul.hSMul (List.map (fun x_1 => f x_1 x) (List.take (â†‘i) l)).prod ((f' (GetElem.getElem l i â‹¯)).smulRight (List.map (fun x_1 => f x_1 x) (List.drop (â†‘i).succ l)).prod)) x","decl":"/--\nUnlike `HasFDerivAt.finset_prod`, supports non-commutative multiply and duplicate elements.\n-/\n@[fun_prop]\ntheorem HasFDerivAt.list_prod' {l : List Î¹} {x : E}\n    (h : âˆ€ i âˆˆ l, HasFDerivAt (f i Â·) (f' i) x) :\n    HasFDerivAt (fun x â†¦ (l.map (f Â· x)).prod)\n      (âˆ‘ i : Fin l.length, ((l.take i).map (f Â· x)).prod â€¢\n        smulRight (f' l[i]) ((l.drop (.succ i)).map (f Â· x)).prod) x := by\n  simp_rw [Fin.getElem_fin, â† l.get_eq_getElem, â† List.finRange_map_get l, List.map_map]\n  refine .congr_fderiv (hasFDerivAt_list_prod_finRange'.comp x\n    (hasFDerivAt_pi.mpr fun i â†¦ h (l.get i) (l.get_mem i)) :) ?_\n  ext m\n  simp_rw [List.map_take, List.map_drop, List.map_map, comp_apply, sum_apply, smul_apply,\n    smulRight_apply, proj_apply, pi_apply, Function.comp_def]\n\n"}
{"name":"HasFDerivWithinAt.list_prod'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ns : Set E\nÎ¹ : Type u_5\nğ”¸ : Type u_6\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nf : Î¹ â†’ E â†’ ğ”¸\nf' : Î¹ â†’ ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸\nl : List Î¹\nx : E\nh : âˆ€ (i : Î¹), Membership.mem l i â†’ HasFDerivWithinAt (fun x => f i x) (f' i) s x\nâŠ¢ HasFDerivWithinAt (fun x => (List.map (fun x_1 => f x_1 x) l).prod) (Finset.univ.sum fun i => HSMul.hSMul (List.map (fun x_1 => f x_1 x) (List.take (â†‘i) l)).prod ((f' (GetElem.getElem l i â‹¯)).smulRight (List.map (fun x_1 => f x_1 x) (List.drop (â†‘i).succ l)).prod)) s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.list_prod' {l : List Î¹} {x : E}\n    (h : âˆ€ i âˆˆ l, HasFDerivWithinAt (f i Â·) (f' i) s x) :\n    HasFDerivWithinAt (fun x â†¦ (l.map (f Â· x)).prod)\n      (âˆ‘ i : Fin l.length, ((l.take i).map (f Â· x)).prod â€¢\n        smulRight (f' l[i]) ((l.drop (.succ i)).map (f Â· x)).prod) s x := by\n  simp_rw [Fin.getElem_fin, â† l.get_eq_getElem, â† List.finRange_map_get l, List.map_map]\n  refine .congr_fderiv (hasFDerivAt_list_prod_finRange'.comp_hasFDerivWithinAt x\n    (hasFDerivWithinAt_pi.mpr fun i â†¦ h (l.get i) (l.get_mem i)) :) ?_\n  ext m\n  simp_rw [List.map_take, List.map_drop, List.map_map, comp_apply, sum_apply, smul_apply,\n    smulRight_apply, proj_apply, pi_apply, Function.comp_def]\n\n"}
{"name":"fderiv_list_prod'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nÎ¹ : Type u_5\nğ”¸ : Type u_6\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nf : Î¹ â†’ E â†’ ğ”¸\nl : List Î¹\nx : E\nh : âˆ€ (i : Î¹), Membership.mem l i â†’ DifferentiableAt ğ•œ (fun x => f i x) x\nâŠ¢ Eq (fderiv ğ•œ (fun x => (List.map (fun x_1 => f x_1 x) l).prod) x) (Finset.univ.sum fun i => HSMul.hSMul (List.map (fun x_1 => f x_1 x) (List.take (â†‘i) l)).prod ((fderiv ğ•œ (fun x => f (GetElem.getElem l i â‹¯) x) x).smulRight (List.map (fun x_1 => f x_1 x) (List.drop (â†‘i).succ l)).prod))","decl":"theorem fderiv_list_prod' {l : List Î¹} {x : E}\n    (h : âˆ€ i âˆˆ l, DifferentiableAt ğ•œ (f i Â·) x) :\n    fderiv ğ•œ (fun x â†¦ (l.map (f Â· x)).prod) x =\n      âˆ‘ i : Fin l.length, ((l.take i).map (f Â· x)).prod â€¢\n        smulRight (fderiv ğ•œ (fun x â†¦ f l[i] x) x) ((l.drop (.succ i)).map (f Â· x)).prod :=\n  (HasFDerivAt.list_prod' fun i hi â†¦ (h i hi).hasFDerivAt).fderiv\n\n"}
{"name":"fderivWithin_list_prod'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ns : Set E\nÎ¹ : Type u_5\nğ”¸ : Type u_6\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nf : Î¹ â†’ E â†’ ğ”¸\nl : List Î¹\nx : E\nhxs : UniqueDiffWithinAt ğ•œ s x\nh : âˆ€ (i : Î¹), Membership.mem l i â†’ DifferentiableWithinAt ğ•œ (fun x => f i x) s x\nâŠ¢ Eq (fderivWithin ğ•œ (fun x => (List.map (fun x_1 => f x_1 x) l).prod) s x) (Finset.univ.sum fun i => HSMul.hSMul (List.map (fun x_1 => f x_1 x) (List.take (â†‘i) l)).prod ((fderivWithin ğ•œ (fun x => f (GetElem.getElem l i â‹¯) x) s x).smulRight (List.map (fun x_1 => f x_1 x) (List.drop (â†‘i).succ l)).prod))","decl":"theorem fderivWithin_list_prod' {l : List Î¹} {x : E}\n    (hxs : UniqueDiffWithinAt ğ•œ s x) (h : âˆ€ i âˆˆ l, DifferentiableWithinAt ğ•œ (f i Â·) s x) :\n    fderivWithin ğ•œ (fun x â†¦ (l.map (f Â· x)).prod) s x =\n      âˆ‘ i : Fin l.length, ((l.take i).map (f Â· x)).prod â€¢\n        smulRight (fderivWithin ğ•œ (fun x â†¦ f l[i] x) s x) ((l.drop (.succ i)).map (f Â· x)).prod :=\n  (HasFDerivWithinAt.list_prod' fun i hi â†¦ (h i hi).hasFDerivWithinAt).fderivWithin hxs\n\n"}
{"name":"HasStrictFDerivAt.multiset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_5\nğ”¸' : Type u_7\ninstâœÂ² : NormedCommRing ğ”¸'\ninstâœÂ¹ : NormedAlgebra ğ•œ ğ”¸'\ng : Î¹ â†’ E â†’ ğ”¸'\ng' : Î¹ â†’ ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸'\ninstâœ : DecidableEq Î¹\nu : Multiset Î¹\nx : E\nh : âˆ€ (i : Î¹), Membership.mem u i â†’ HasStrictFDerivAt (fun x => g i x) (g' i) x\nâŠ¢ HasStrictFDerivAt (fun x => (Multiset.map (fun x_1 => g x_1 x) u).prod) (Multiset.map (fun i => HSMul.hSMul (Multiset.map (fun x_1 => g x_1 x) (u.erase i)).prod (g' i)) u).sum x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.multiset_prod [DecidableEq Î¹] {u : Multiset Î¹} {x : E}\n    (h : âˆ€ i âˆˆ u, HasStrictFDerivAt (g i Â·) (g' i) x) :\n    HasStrictFDerivAt (fun x â†¦ (u.map (g Â· x)).prod)\n      (u.map fun i â†¦ ((u.erase i).map (g Â· x)).prod â€¢ g' i).sum x := by\n  simp only [â† Multiset.attach_map_val u, Multiset.map_map]\n  exact .congr_fderiv\n    (hasStrictFDerivAt_multiset_prod.comp x <|\n      hasStrictFDerivAt_pi.mpr fun i â†¦ h (Subtype.val i) i.prop :)\n    (by ext; simp [Finset.sum_multiset_map_count, u.erase_attach_map (g Â· x)])\n\n"}
{"name":"HasFDerivAt.multiset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_5\nğ”¸' : Type u_7\ninstâœÂ² : NormedCommRing ğ”¸'\ninstâœÂ¹ : NormedAlgebra ğ•œ ğ”¸'\ng : Î¹ â†’ E â†’ ğ”¸'\ng' : Î¹ â†’ ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸'\ninstâœ : DecidableEq Î¹\nu : Multiset Î¹\nx : E\nh : âˆ€ (i : Î¹), Membership.mem u i â†’ HasFDerivAt (fun x => g i x) (g' i) x\nâŠ¢ HasFDerivAt (fun x => (Multiset.map (fun x_1 => g x_1 x) u).prod) (Multiset.map (fun i => HSMul.hSMul (Multiset.map (fun x_1 => g x_1 x) (u.erase i)).prod (g' i)) u).sum x","decl":"/--\nUnlike `HasFDerivAt.finset_prod`, supports duplicate elements.\n-/\n@[fun_prop]\ntheorem HasFDerivAt.multiset_prod [DecidableEq Î¹] {u : Multiset Î¹} {x : E}\n    (h : âˆ€ i âˆˆ u, HasFDerivAt (g i Â·) (g' i) x) :\n    HasFDerivAt (fun x â†¦ (u.map (g Â· x)).prod)\n      (u.map fun i â†¦ ((u.erase i).map (g Â· x)).prod â€¢ g' i).sum x := by\n  simp only [â† Multiset.attach_map_val u, Multiset.map_map]\n  exact .congr_fderiv\n    (hasFDerivAt_multiset_prod.comp x <| hasFDerivAt_pi.mpr fun i â†¦ h (Subtype.val i) i.prop :)\n    (by ext; simp [Finset.sum_multiset_map_count, u.erase_attach_map (g Â· x)])\n\n"}
{"name":"HasFDerivWithinAt.multiset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ns : Set E\nÎ¹ : Type u_5\nğ”¸' : Type u_7\ninstâœÂ² : NormedCommRing ğ”¸'\ninstâœÂ¹ : NormedAlgebra ğ•œ ğ”¸'\ng : Î¹ â†’ E â†’ ğ”¸'\ng' : Î¹ â†’ ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸'\ninstâœ : DecidableEq Î¹\nu : Multiset Î¹\nx : E\nh : âˆ€ (i : Î¹), Membership.mem u i â†’ HasFDerivWithinAt (fun x => g i x) (g' i) s x\nâŠ¢ HasFDerivWithinAt (fun x => (Multiset.map (fun x_1 => g x_1 x) u).prod) (Multiset.map (fun i => HSMul.hSMul (Multiset.map (fun x_1 => g x_1 x) (u.erase i)).prod (g' i)) u).sum s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.multiset_prod [DecidableEq Î¹] {u : Multiset Î¹} {x : E}\n    (h : âˆ€ i âˆˆ u, HasFDerivWithinAt (g i Â·) (g' i) s x) :\n    HasFDerivWithinAt (fun x â†¦ (u.map (g Â· x)).prod)\n      (u.map fun i â†¦ ((u.erase i).map (g Â· x)).prod â€¢ g' i).sum s x := by\n  simp only [â† Multiset.attach_map_val u, Multiset.map_map]\n  exact .congr_fderiv\n    (hasFDerivAt_multiset_prod.comp_hasFDerivWithinAt x <|\n      hasFDerivWithinAt_pi.mpr fun i â†¦ h (Subtype.val i) i.prop :)\n    (by ext; simp [Finset.sum_multiset_map_count, u.erase_attach_map (g Â· x)])\n\n"}
{"name":"fderiv_multiset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_5\nğ”¸' : Type u_7\ninstâœÂ² : NormedCommRing ğ”¸'\ninstâœÂ¹ : NormedAlgebra ğ•œ ğ”¸'\ng : Î¹ â†’ E â†’ ğ”¸'\ninstâœ : DecidableEq Î¹\nu : Multiset Î¹\nx : E\nh : âˆ€ (i : Î¹), Membership.mem u i â†’ DifferentiableAt ğ•œ (fun x => g i x) x\nâŠ¢ Eq (fderiv ğ•œ (fun x => (Multiset.map (fun x_1 => g x_1 x) u).prod) x) (Multiset.map (fun i => HSMul.hSMul (Multiset.map (fun x_1 => g x_1 x) (u.erase i)).prod (fderiv ğ•œ (g i) x)) u).sum","decl":"theorem fderiv_multiset_prod [DecidableEq Î¹] {u : Multiset Î¹} {x : E}\n    (h : âˆ€ i âˆˆ u, DifferentiableAt ğ•œ (g i Â·) x) :\n    fderiv ğ•œ (fun x â†¦ (u.map (g Â· x)).prod) x =\n      (u.map fun i â†¦ ((u.erase i).map (g Â· x)).prod â€¢ fderiv ğ•œ (g i) x).sum :=\n  (HasFDerivAt.multiset_prod fun i hi â†¦ (h i hi).hasFDerivAt).fderiv\n\n"}
{"name":"fderivWithin_multiset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ns : Set E\nÎ¹ : Type u_5\nğ”¸' : Type u_7\ninstâœÂ² : NormedCommRing ğ”¸'\ninstâœÂ¹ : NormedAlgebra ğ•œ ğ”¸'\ng : Î¹ â†’ E â†’ ğ”¸'\ninstâœ : DecidableEq Î¹\nu : Multiset Î¹\nx : E\nhxs : UniqueDiffWithinAt ğ•œ s x\nh : âˆ€ (i : Î¹), Membership.mem u i â†’ DifferentiableWithinAt ğ•œ (fun x => g i x) s x\nâŠ¢ Eq (fderivWithin ğ•œ (fun x => (Multiset.map (fun x_1 => g x_1 x) u).prod) s x) (Multiset.map (fun i => HSMul.hSMul (Multiset.map (fun x_1 => g x_1 x) (u.erase i)).prod (fderivWithin ğ•œ (g i) s x)) u).sum","decl":"theorem fderivWithin_multiset_prod [DecidableEq Î¹] {u : Multiset Î¹} {x : E}\n    (hxs : UniqueDiffWithinAt ğ•œ s x) (h : âˆ€ i âˆˆ u, DifferentiableWithinAt ğ•œ (g i Â·) s x) :\n    fderivWithin ğ•œ (fun x â†¦ (u.map (g Â· x)).prod) s x =\n      (u.map fun i â†¦ ((u.erase i).map (g Â· x)).prod â€¢ fderivWithin ğ•œ (g i) s x).sum :=\n  (HasFDerivWithinAt.multiset_prod fun i hi â†¦ (h i hi).hasFDerivWithinAt).fderivWithin hxs\n\n"}
{"name":"HasStrictFDerivAt.finset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_5\nğ”¸' : Type u_7\ninstâœÂ² : NormedCommRing ğ”¸'\ninstâœÂ¹ : NormedAlgebra ğ•œ ğ”¸'\nu : Finset Î¹\ng : Î¹ â†’ E â†’ ğ”¸'\ng' : Î¹ â†’ ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸'\ninstâœ : DecidableEq Î¹\nx : E\nhg : âˆ€ (i : Î¹), Membership.mem u i â†’ HasStrictFDerivAt (g i) (g' i) x\nâŠ¢ HasStrictFDerivAt (fun x => u.prod fun i => g i x) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => g j x) (g' i)) x","decl":"theorem HasStrictFDerivAt.finset_prod [DecidableEq Î¹] {x : E}\n    (hg : âˆ€ i âˆˆ u, HasStrictFDerivAt (g i) (g' i) x) :\n    HasStrictFDerivAt (âˆ i âˆˆ u, g i Â·) (âˆ‘ i âˆˆ u, (âˆ j âˆˆ u.erase i, g j x) â€¢ g' i) x := by\n  simpa [â† Finset.prod_attach u] using .congr_fderiv\n    (hasStrictFDerivAt_finset_prod.comp x <| hasStrictFDerivAt_pi.mpr fun i â†¦ hg i i.prop)\n    (by ext; simp [Finset.prod_erase_attach (g Â· x), â† u.sum_attach])\n\n"}
{"name":"HasFDerivAt.finset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_5\nğ”¸' : Type u_7\ninstâœÂ² : NormedCommRing ğ”¸'\ninstâœÂ¹ : NormedAlgebra ğ•œ ğ”¸'\nu : Finset Î¹\ng : Î¹ â†’ E â†’ ğ”¸'\ng' : Î¹ â†’ ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸'\ninstâœ : DecidableEq Î¹\nx : E\nhg : âˆ€ (i : Î¹), Membership.mem u i â†’ HasFDerivAt (g i) (g' i) x\nâŠ¢ HasFDerivAt (fun x => u.prod fun i => g i x) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => g j x) (g' i)) x","decl":"theorem HasFDerivAt.finset_prod [DecidableEq Î¹] {x : E}\n    (hg : âˆ€ i âˆˆ u, HasFDerivAt (g i) (g' i) x) :\n    HasFDerivAt (âˆ i âˆˆ u, g i Â·) (âˆ‘ i âˆˆ u, (âˆ j âˆˆ u.erase i, g j x) â€¢ g' i) x := by\n  simpa [â† Finset.prod_attach u] using .congr_fderiv\n    (hasFDerivAt_finset_prod.comp x <| hasFDerivAt_pi.mpr fun i â†¦ hg (Subtype.val i) i.prop :)\n    (by ext; simp [Finset.prod_erase_attach (g Â· x), â† u.sum_attach])\n\n"}
{"name":"HasFDerivWithinAt.finset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ns : Set E\nÎ¹ : Type u_5\nğ”¸' : Type u_7\ninstâœÂ² : NormedCommRing ğ”¸'\ninstâœÂ¹ : NormedAlgebra ğ•œ ğ”¸'\nu : Finset Î¹\ng : Î¹ â†’ E â†’ ğ”¸'\ng' : Î¹ â†’ ContinuousLinearMap (RingHom.id ğ•œ) E ğ”¸'\ninstâœ : DecidableEq Î¹\nx : E\nhg : âˆ€ (i : Î¹), Membership.mem u i â†’ HasFDerivWithinAt (g i) (g' i) s x\nâŠ¢ HasFDerivWithinAt (fun x => u.prod fun i => g i x) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => g j x) (g' i)) s x","decl":"theorem HasFDerivWithinAt.finset_prod [DecidableEq Î¹] {x : E}\n    (hg : âˆ€ i âˆˆ u, HasFDerivWithinAt (g i) (g' i) s x) :\n    HasFDerivWithinAt (âˆ i âˆˆ u, g i Â·) (âˆ‘ i âˆˆ u, (âˆ j âˆˆ u.erase i, g j x) â€¢ g' i) s x := by\n  simpa [â† Finset.prod_attach u] using .congr_fderiv\n    (hasFDerivAt_finset_prod.comp_hasFDerivWithinAt x <|\n      hasFDerivWithinAt_pi.mpr fun i â†¦ hg (Subtype.val i) i.prop :)\n    (by ext; simp [Finset.prod_erase_attach (g Â· x), â† u.sum_attach])\n\n"}
{"name":"fderiv_finset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_5\nğ”¸' : Type u_7\ninstâœÂ² : NormedCommRing ğ”¸'\ninstâœÂ¹ : NormedAlgebra ğ•œ ğ”¸'\nu : Finset Î¹\ng : Î¹ â†’ E â†’ ğ”¸'\ninstâœ : DecidableEq Î¹\nx : E\nhg : âˆ€ (i : Î¹), Membership.mem u i â†’ DifferentiableAt ğ•œ (g i) x\nâŠ¢ Eq (fderiv ğ•œ (fun x => u.prod fun i => g i x) x) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => g j x) (fderiv ğ•œ (g i) x))","decl":"theorem fderiv_finset_prod [DecidableEq Î¹] {x : E} (hg : âˆ€ i âˆˆ u, DifferentiableAt ğ•œ (g i) x) :\n    fderiv ğ•œ (âˆ i âˆˆ u, g i Â·) x = âˆ‘ i âˆˆ u, (âˆ j âˆˆ u.erase i, (g j x)) â€¢ fderiv ğ•œ (g i) x :=\n  (HasFDerivAt.finset_prod fun i hi â†¦ (hg i hi).hasFDerivAt).fderiv\n\n"}
{"name":"fderivWithin_finset_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ns : Set E\nÎ¹ : Type u_5\nğ”¸' : Type u_7\ninstâœÂ² : NormedCommRing ğ”¸'\ninstâœÂ¹ : NormedAlgebra ğ•œ ğ”¸'\nu : Finset Î¹\ng : Î¹ â†’ E â†’ ğ”¸'\ninstâœ : DecidableEq Î¹\nx : E\nhxs : UniqueDiffWithinAt ğ•œ s x\nhg : âˆ€ (i : Î¹), Membership.mem u i â†’ DifferentiableWithinAt ğ•œ (g i) s x\nâŠ¢ Eq (fderivWithin ğ•œ (fun x => u.prod fun i => g i x) s x) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => g j x) (fderivWithin ğ•œ (g i) s x))","decl":"theorem fderivWithin_finset_prod [DecidableEq Î¹] {x : E} (hxs : UniqueDiffWithinAt ğ•œ s x)\n    (hg : âˆ€ i âˆˆ u, DifferentiableWithinAt ğ•œ (g i) s x) :\n    fderivWithin ğ•œ (âˆ i âˆˆ u, g i Â·) s x =\n      âˆ‘ i âˆˆ u, (âˆ j âˆˆ u.erase i, (g j x)) â€¢ fderivWithin ğ•œ (g i) s x :=\n  (HasFDerivWithinAt.finset_prod fun i hi â†¦ (hg i hi).hasFDerivWithinAt).fderivWithin hxs\n\n"}
{"name":"hasFDerivAt_ring_inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nR : Type u_5\ninstâœÂ² : NormedRing R\ninstâœÂ¹ : HasSummableGeomSeries R\ninstâœ : NormedAlgebra ğ•œ R\nx : Units R\nâŠ¢ HasFDerivAt Ring.inverse (Neg.neg (((ContinuousLinearMap.mulLeftRight ğ•œ R) â†‘(Inv.inv x)) â†‘(Inv.inv x))) â†‘x","decl":"/-- At an invertible element `x` of a normed algebra `R`, the FrÃ©chet derivative of the inversion\noperation is the linear map `fun t â†¦ - xâ»Â¹ * t * xâ»Â¹`.\n\nTODO (low prio): prove a version without assumption `[HasSummableGeomSeries R]` but within the set\nof units. -/\n@[fun_prop]\ntheorem hasFDerivAt_ring_inverse (x : RË£) :\n    HasFDerivAt Ring.inverse (-mulLeftRight ğ•œ R â†‘xâ»Â¹ â†‘xâ»Â¹) x :=\n  have : (fun t : R => Ring.inverse (â†‘x + t) - â†‘xâ»Â¹ + â†‘xâ»Â¹ * t * â†‘xâ»Â¹) =o[ğ“ 0] id :=\n    (inverse_add_norm_diff_second_order x).trans_isLittleO (isLittleO_norm_pow_id one_lt_two)\n  by simpa [hasFDerivAt_iff_isLittleO_nhds_zero] using this\n\n"}
{"name":"differentiableAt_inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nR : Type u_5\ninstâœÂ² : NormedRing R\ninstâœÂ¹ : HasSummableGeomSeries R\ninstâœ : NormedAlgebra ğ•œ R\nx : R\nhx : IsUnit x\nâŠ¢ DifferentiableAt ğ•œ Ring.inverse x","decl":"@[fun_prop]\ntheorem differentiableAt_inverse {x : R} (hx : IsUnit x) :\n    DifferentiableAt ğ•œ (@Ring.inverse R _) x :=\n  let âŸ¨u, huâŸ© := hx; hu â–¸ (hasFDerivAt_ring_inverse u).differentiableAt\n\n"}
{"name":"differentiableWithinAt_inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nR : Type u_5\ninstâœÂ² : NormedRing R\ninstâœÂ¹ : HasSummableGeomSeries R\ninstâœ : NormedAlgebra ğ•œ R\nx : R\nhx : IsUnit x\ns : Set R\nâŠ¢ DifferentiableWithinAt ğ•œ Ring.inverse s x","decl":"@[fun_prop]\ntheorem differentiableWithinAt_inverse {x : R} (hx : IsUnit x) (s : Set R) :\n    DifferentiableWithinAt ğ•œ (@Ring.inverse R _) s x :=\n  (differentiableAt_inverse hx).differentiableWithinAt\n\n"}
{"name":"differentiableOn_inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nR : Type u_5\ninstâœÂ² : NormedRing R\ninstâœÂ¹ : HasSummableGeomSeries R\ninstâœ : NormedAlgebra ğ•œ R\nâŠ¢ DifferentiableOn ğ•œ Ring.inverse (setOf fun x => IsUnit x)","decl":"@[fun_prop]\ntheorem differentiableOn_inverse : DifferentiableOn ğ•œ (@Ring.inverse R _) {x | IsUnit x} :=\n  fun _x hx => differentiableWithinAt_inverse hx _\n\n"}
{"name":"fderiv_inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nR : Type u_5\ninstâœÂ² : NormedRing R\ninstâœÂ¹ : HasSummableGeomSeries R\ninstâœ : NormedAlgebra ğ•œ R\nx : Units R\nâŠ¢ Eq (fderiv ğ•œ Ring.inverse â†‘x) (Neg.neg (((ContinuousLinearMap.mulLeftRight ğ•œ R) â†‘(Inv.inv x)) â†‘(Inv.inv x)))","decl":"theorem fderiv_inverse (x : RË£) : fderiv ğ•œ (@Ring.inverse R _) x = -mulLeftRight ğ•œ R â†‘xâ»Â¹ â†‘xâ»Â¹ :=\n  (hasFDerivAt_ring_inverse x).fderiv\n\n"}
{"name":"hasStrictFDerivAt_ring_inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nR : Type u_5\ninstâœÂ² : NormedRing R\ninstâœÂ¹ : HasSummableGeomSeries R\ninstâœ : NormedAlgebra ğ•œ R\nx : Units R\nâŠ¢ HasStrictFDerivAt Ring.inverse (Neg.neg (((ContinuousLinearMap.mulLeftRight ğ•œ R) â†‘(Inv.inv x)) â†‘(Inv.inv x))) â†‘x","decl":"theorem hasStrictFDerivAt_ring_inverse (x : RË£) :\n    HasStrictFDerivAt Ring.inverse (-mulLeftRight ğ•œ R â†‘xâ»Â¹ â†‘xâ»Â¹) x := by\n  convert (analyticAt_inverse (ğ•œ := ğ•œ) x).hasStrictFDerivAt\n  exact (fderiv_inverse x).symm\n\n"}
{"name":"DifferentiableWithinAt.inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nR : Type u_5\ninstâœÂ² : NormedRing R\ninstâœÂ¹ : HasSummableGeomSeries R\ninstâœ : NormedAlgebra ğ•œ R\nh : E â†’ R\nz : E\nS : Set E\nhf : DifferentiableWithinAt ğ•œ h S z\nhz : IsUnit (h z)\nâŠ¢ DifferentiableWithinAt ğ•œ (fun x => Ring.inverse (h x)) S z","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.inverse (hf : DifferentiableWithinAt ğ•œ h S z) (hz : IsUnit (h z)) :\n    DifferentiableWithinAt ğ•œ (fun x => Ring.inverse (h x)) S z :=\n  (differentiableAt_inverse hz).comp_differentiableWithinAt z hf\n\n"}
{"name":"DifferentiableAt.inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nR : Type u_5\ninstâœÂ² : NormedRing R\ninstâœÂ¹ : HasSummableGeomSeries R\ninstâœ : NormedAlgebra ğ•œ R\nh : E â†’ R\nz : E\nhf : DifferentiableAt ğ•œ h z\nhz : IsUnit (h z)\nâŠ¢ DifferentiableAt ğ•œ (fun x => Ring.inverse (h x)) z","decl":"@[simp, fun_prop]\ntheorem DifferentiableAt.inverse (hf : DifferentiableAt ğ•œ h z) (hz : IsUnit (h z)) :\n    DifferentiableAt ğ•œ (fun x => Ring.inverse (h x)) z :=\n  (differentiableAt_inverse hz).comp z hf\n\n"}
{"name":"DifferentiableOn.inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nR : Type u_5\ninstâœÂ² : NormedRing R\ninstâœÂ¹ : HasSummableGeomSeries R\ninstâœ : NormedAlgebra ğ•œ R\nh : E â†’ R\nS : Set E\nhf : DifferentiableOn ğ•œ h S\nhz : âˆ€ (x : E), Membership.mem S x â†’ IsUnit (h x)\nâŠ¢ DifferentiableOn ğ•œ (fun x => Ring.inverse (h x)) S","decl":"@[fun_prop]\ntheorem DifferentiableOn.inverse (hf : DifferentiableOn ğ•œ h S) (hz : âˆ€ x âˆˆ S, IsUnit (h x)) :\n    DifferentiableOn ğ•œ (fun x => Ring.inverse (h x)) S := fun x h => (hf x h).inverse (hz x h)\n\n"}
{"name":"Differentiable.inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nR : Type u_5\ninstâœÂ² : NormedRing R\ninstâœÂ¹ : HasSummableGeomSeries R\ninstâœ : NormedAlgebra ğ•œ R\nh : E â†’ R\nhf : Differentiable ğ•œ h\nhz : âˆ€ (x : E), IsUnit (h x)\nâŠ¢ Differentiable ğ•œ fun x => Ring.inverse (h x)","decl":"@[simp, fun_prop]\ntheorem Differentiable.inverse (hf : Differentiable ğ•œ h) (hz : âˆ€ x, IsUnit (h x)) :\n    Differentiable ğ•œ fun x => Ring.inverse (h x) := fun x => (hf x).inverse (hz x)\n\n"}
{"name":"hasStrictFDerivAt_inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nR : Type u_5\ninstâœÂ¹ : NormedDivisionRing R\ninstâœ : NormedAlgebra ğ•œ R\nx : R\nhx : Ne x 0\nâŠ¢ HasStrictFDerivAt Inv.inv (Neg.neg (((ContinuousLinearMap.mulLeftRight ğ•œ R) (Inv.inv x)) (Inv.inv x))) x","decl":"/-- At an invertible element `x` of a normed division algebra `R`, the inversion is strictly\ndifferentiable, with derivative the linear map `fun t â†¦ - xâ»Â¹ * t * xâ»Â¹`. For a nicer formula in\nthe commutative case, see `hasStrictFDerivAt_inv`. -/\ntheorem hasStrictFDerivAt_inv' {x : R} (hx : x â‰  0) :\n    HasStrictFDerivAt Inv.inv (-mulLeftRight ğ•œ R xâ»Â¹ xâ»Â¹) x := by\n  simpa using hasStrictFDerivAt_ring_inverse (Units.mk0 _ hx)\n\n"}
{"name":"hasFDerivAt_inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nR : Type u_5\ninstâœÂ¹ : NormedDivisionRing R\ninstâœ : NormedAlgebra ğ•œ R\nx : R\nhx : Ne x 0\nâŠ¢ HasFDerivAt Inv.inv (Neg.neg (((ContinuousLinearMap.mulLeftRight ğ•œ R) (Inv.inv x)) (Inv.inv x))) x","decl":"/-- At an invertible element `x` of a normed division algebra `R`, the FrÃ©chet derivative of the\ninversion operation is the linear map `fun t â†¦ - xâ»Â¹ * t * xâ»Â¹`. For a nicer formula in the\ncommutative case, see `hasFDerivAt_inv`. -/\n@[fun_prop]\ntheorem hasFDerivAt_inv' {x : R} (hx : x â‰  0) :\n    HasFDerivAt Inv.inv (-mulLeftRight ğ•œ R xâ»Â¹ xâ»Â¹) x := by\n  simpa using hasFDerivAt_ring_inverse (Units.mk0 _ hx)\n\n"}
{"name":"differentiableAt_inv","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nR : Type u_5\ninstâœÂ¹ : NormedDivisionRing R\ninstâœ : NormedAlgebra ğ•œ R\nx : R\nhx : Ne x 0\nâŠ¢ DifferentiableAt ğ•œ Inv.inv x","decl":"@[fun_prop]\ntheorem differentiableAt_inv {x : R} (hx : x â‰  0) : DifferentiableAt ğ•œ Inv.inv x :=\n  (hasFDerivAt_inv' hx).differentiableAt\n\n"}
{"name":"differentiableAt_inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nR : Type u_5\ninstâœÂ¹ : NormedDivisionRing R\ninstâœ : NormedAlgebra ğ•œ R\nx : R\nhx : Ne x 0\nâŠ¢ DifferentiableAt ğ•œ Inv.inv x","decl":"@[deprecated (since := \"2024-09-21\")] alias differentiableAt_inv' := differentiableAt_inv\n\n"}
{"name":"differentiableWithinAt_inv","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nR : Type u_5\ninstâœÂ¹ : NormedDivisionRing R\ninstâœ : NormedAlgebra ğ•œ R\nx : R\nhx : Ne x 0\ns : Set R\nâŠ¢ DifferentiableWithinAt ğ•œ (fun x => Inv.inv x) s x","decl":"@[fun_prop]\ntheorem differentiableWithinAt_inv {x : R} (hx : x â‰  0) (s : Set R) :\n    DifferentiableWithinAt ğ•œ (fun x => xâ»Â¹) s x :=\n  (differentiableAt_inv hx).differentiableWithinAt\n\n"}
{"name":"differentiableWithinAt_inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nR : Type u_5\ninstâœÂ¹ : NormedDivisionRing R\ninstâœ : NormedAlgebra ğ•œ R\nx : R\nhx : Ne x 0\ns : Set R\nâŠ¢ DifferentiableWithinAt ğ•œ (fun x => Inv.inv x) s x","decl":"@[deprecated (since := \"2024-09-21\")]\nalias differentiableWithinAt_inv' := differentiableWithinAt_inv\n\n"}
{"name":"differentiableOn_inv","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nR : Type u_5\ninstâœÂ¹ : NormedDivisionRing R\ninstâœ : NormedAlgebra ğ•œ R\nâŠ¢ DifferentiableOn ğ•œ (fun x => Inv.inv x) (setOf fun x => Ne x 0)","decl":"@[fun_prop]\ntheorem differentiableOn_inv : DifferentiableOn ğ•œ (fun x : R => xâ»Â¹) {x | x â‰  0} := fun _x hx =>\n  differentiableWithinAt_inv hx _\n\n"}
{"name":"differentiableOn_inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nR : Type u_5\ninstâœÂ¹ : NormedDivisionRing R\ninstâœ : NormedAlgebra ğ•œ R\nâŠ¢ DifferentiableOn ğ•œ (fun x => Inv.inv x) (setOf fun x => Ne x 0)","decl":"@[deprecated (since := \"2024-09-21\")] alias differentiableOn_inv' := differentiableOn_inv\n\n"}
{"name":"fderiv_inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nR : Type u_5\ninstâœÂ¹ : NormedDivisionRing R\ninstâœ : NormedAlgebra ğ•œ R\nx : R\nhx : Ne x 0\nâŠ¢ Eq (fderiv ğ•œ Inv.inv x) (Neg.neg (((ContinuousLinearMap.mulLeftRight ğ•œ R) (Inv.inv x)) (Inv.inv x)))","decl":"/-- Non-commutative version of `fderiv_inv` -/\ntheorem fderiv_inv' {x : R} (hx : x â‰  0) : fderiv ğ•œ Inv.inv x = -mulLeftRight ğ•œ R xâ»Â¹ xâ»Â¹ :=\n  (hasFDerivAt_inv' hx).fderiv\n\n"}
{"name":"fderivWithin_inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nR : Type u_5\ninstâœÂ¹ : NormedDivisionRing R\ninstâœ : NormedAlgebra ğ•œ R\ns : Set R\nx : R\nhx : Ne x 0\nhxs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (fderivWithin ğ•œ (fun x => Inv.inv x) s x) (Neg.neg (((ContinuousLinearMap.mulLeftRight ğ•œ R) (Inv.inv x)) (Inv.inv x)))","decl":"/-- Non-commutative version of `fderivWithin_inv` -/\ntheorem fderivWithin_inv' {s : Set R} {x : R} (hx : x â‰  0) (hxs : UniqueDiffWithinAt ğ•œ s x) :\n    fderivWithin ğ•œ (fun x => xâ»Â¹) s x = -mulLeftRight ğ•œ R xâ»Â¹ xâ»Â¹ := by\n  rw [DifferentiableAt.fderivWithin (differentiableAt_inv hx) hxs]\n  exact fderiv_inv' hx\n\n"}
{"name":"DifferentiableWithinAt.inv","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nR : Type u_5\ninstâœÂ¹ : NormedDivisionRing R\ninstâœ : NormedAlgebra ğ•œ R\nh : E â†’ R\nz : E\nS : Set E\nhf : DifferentiableWithinAt ğ•œ h S z\nhz : Ne (h z) 0\nâŠ¢ DifferentiableWithinAt ğ•œ (fun x => Inv.inv (h x)) S z","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.inv (hf : DifferentiableWithinAt ğ•œ h S z) (hz : h z â‰  0) :\n    DifferentiableWithinAt ğ•œ (fun x => (h x)â»Â¹) S z :=\n  (differentiableAt_inv hz).comp_differentiableWithinAt z hf\n\n"}
{"name":"DifferentiableWithinAt.inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nR : Type u_5\ninstâœÂ¹ : NormedDivisionRing R\ninstâœ : NormedAlgebra ğ•œ R\nh : E â†’ R\nz : E\nS : Set E\nhf : DifferentiableWithinAt ğ•œ h S z\nhz : Ne (h z) 0\nâŠ¢ DifferentiableWithinAt ğ•œ (fun x => Inv.inv (h x)) S z","decl":"@[deprecated (since := \"2024-09-21\")]\nalias DifferentiableWithinAt.inv' := DifferentiableWithinAt.inv\n\n"}
{"name":"DifferentiableAt.inv","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nR : Type u_5\ninstâœÂ¹ : NormedDivisionRing R\ninstâœ : NormedAlgebra ğ•œ R\nh : E â†’ R\nz : E\nhf : DifferentiableAt ğ•œ h z\nhz : Ne (h z) 0\nâŠ¢ DifferentiableAt ğ•œ (fun x => Inv.inv (h x)) z","decl":"@[simp, fun_prop]\ntheorem DifferentiableAt.inv (hf : DifferentiableAt ğ•œ h z) (hz : h z â‰  0) :\n    DifferentiableAt ğ•œ (fun x => (h x)â»Â¹) z :=\n  (differentiableAt_inv hz).comp z hf\n\n"}
{"name":"DifferentiableAt.inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nR : Type u_5\ninstâœÂ¹ : NormedDivisionRing R\ninstâœ : NormedAlgebra ğ•œ R\nh : E â†’ R\nz : E\nhf : DifferentiableAt ğ•œ h z\nhz : Ne (h z) 0\nâŠ¢ DifferentiableAt ğ•œ (fun x => Inv.inv (h x)) z","decl":"@[deprecated (since := \"2024-09-21\")] alias DifferentiableAt.inv' := DifferentiableAt.inv\n\n"}
{"name":"DifferentiableOn.inv","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nR : Type u_5\ninstâœÂ¹ : NormedDivisionRing R\ninstâœ : NormedAlgebra ğ•œ R\nh : E â†’ R\nS : Set E\nhf : DifferentiableOn ğ•œ h S\nhz : âˆ€ (x : E), Membership.mem S x â†’ Ne (h x) 0\nâŠ¢ DifferentiableOn ğ•œ (fun x => Inv.inv (h x)) S","decl":"@[fun_prop]\ntheorem DifferentiableOn.inv (hf : DifferentiableOn ğ•œ h S) (hz : âˆ€ x âˆˆ S, h x â‰  0) :\n    DifferentiableOn ğ•œ (fun x => (h x)â»Â¹) S := fun x h => (hf x h).inv (hz x h)\n\n"}
{"name":"DifferentiableOn.inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nR : Type u_5\ninstâœÂ¹ : NormedDivisionRing R\ninstâœ : NormedAlgebra ğ•œ R\nh : E â†’ R\nS : Set E\nhf : DifferentiableOn ğ•œ h S\nhz : âˆ€ (x : E), Membership.mem S x â†’ Ne (h x) 0\nâŠ¢ DifferentiableOn ğ•œ (fun x => Inv.inv (h x)) S","decl":"@[deprecated (since := \"2024-09-21\")] alias DifferentiableOn.inv' := DifferentiableOn.inv\n\n"}
{"name":"Differentiable.inv","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nR : Type u_5\ninstâœÂ¹ : NormedDivisionRing R\ninstâœ : NormedAlgebra ğ•œ R\nh : E â†’ R\nhf : Differentiable ğ•œ h\nhz : âˆ€ (x : E), Ne (h x) 0\nâŠ¢ Differentiable ğ•œ fun x => Inv.inv (h x)","decl":"@[simp, fun_prop]\ntheorem Differentiable.inv (hf : Differentiable ğ•œ h) (hz : âˆ€ x, h x â‰  0) :\n    Differentiable ğ•œ fun x => (h x)â»Â¹ := fun x => (hf x).inv (hz x)\n\n"}
{"name":"Differentiable.inv'","module":"Mathlib.Analysis.Calculus.FDeriv.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nR : Type u_5\ninstâœÂ¹ : NormedDivisionRing R\ninstâœ : NormedAlgebra ğ•œ R\nh : E â†’ R\nhf : Differentiable ğ•œ h\nhz : âˆ€ (x : E), Ne (h x) 0\nâŠ¢ Differentiable ğ•œ fun x => Inv.inv (h x)","decl":"@[deprecated (since := \"2024-09-21\")] alias Differentiable.inv' := Differentiable.inv\n\n"}
