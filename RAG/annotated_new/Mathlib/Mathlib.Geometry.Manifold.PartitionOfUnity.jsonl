{"name":"SmoothBumpCovering.mk.sizeOf_spec","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : NormedSpace Real E\nH : Type uH\ninstâœâ¸ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâ· : TopologicalSpace M\ninstâœâ¶ : ChartedSpace H M\ninstâœâµ : FiniteDimensional Real E\ns : optParam (Set M) Set.univ\ninstâœâ´ : SizeOf Î¹\ninstâœÂ³ : SizeOf E\ninstâœÂ² : SizeOf H\ninstâœÂ¹ : SizeOf M\ninstâœ : (a : M) â†’ SizeOf (s a)\nc : Î¹ â†’ M\ntoFun : (i : Î¹) â†’ SmoothBumpFunction I (c i)\nc_mem' : âˆ€ (i : Î¹), Membership.mem s (c i)\nlocallyFinite' : LocallyFinite fun i => Function.support â†‘(toFun i)\neventuallyEq_one' : âˆ€ (x : M), Membership.mem s x â†’ Exists fun i => (nhds x).EventuallyEq (â†‘(toFun i)) 1\nâŠ¢ Eq (SizeOf.sizeOf { c := c, toFun := toFun, c_mem' := c_mem', locallyFinite' := locallyFinite', eventuallyEq_one' := eventuallyEq_one' }) 1","decl":"/-- We say that a collection of `SmoothBumpFunction`s is a `SmoothBumpCovering` of a set `s` if\n\n* `(f i).c âˆˆ s` for all `i`;\n* the family `fun i â†¦ support (f i)` is locally finite;\n* for each point `x âˆˆ s` there exists `i` such that `f i =á¶ [ð“ x] 1`;\n  in other words, `x` belongs to the interior of `{y | f i y = 1}`;\n\nIf `M` is a finite dimensional real manifold which is a `Ïƒ`-compact Hausdorff topological space,\nthen for every covering `U : M â†’ Set M`, `âˆ€ x, U x âˆˆ ð“ x`, there exists a `SmoothBumpCovering`\nsubordinate to `U`, see `SmoothBumpCovering.exists_isSubordinate`.\n\nThis covering can be used, e.g., to construct a partition of unity and to prove the weak\nWhitney embedding theorem. -/\nstructure SmoothBumpCovering [FiniteDimensional â„ E] (s : Set M := univ) where\n  /-- The center point of each bump in the smooth covering. -/\n  c : Î¹ â†’ M\n  /-- A smooth bump function around `c i`. -/\n  toFun : âˆ€ i, SmoothBumpFunction I (c i)\n  /-- All the bump functions in the covering are centered at points in `s`. -/\n  c_mem' : âˆ€ i, c i âˆˆ s\n  /-- Around each point, there are only finitely many nonzero bump functions in the family. -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- Around each point in `s`, one of the bump functions is equal to `1`. -/\n  eventuallyEq_one' : âˆ€ x âˆˆ s, âˆƒ i, toFun i =á¶ [ð“ x] 1\n\n"}
{"name":"SmoothBumpCovering.mk.inj","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\nH : Type uH\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : FiniteDimensional Real E\ns : Set M\ncâœ : Î¹ â†’ M\ntoFunâœ : (i : Î¹) â†’ SmoothBumpFunction I (câœ i)\nc_mem'âœ : âˆ€ (i : Î¹), Membership.mem s (câœ i)\nlocallyFinite'âœ : LocallyFinite fun i => Function.support â†‘(toFunâœ i)\neventuallyEq_one'âœ : âˆ€ (x : M), Membership.mem s x â†’ Exists fun i => (nhds x).EventuallyEq (â†‘(toFunâœ i)) 1\nc : Î¹ â†’ M\ntoFun : (i : Î¹) â†’ SmoothBumpFunction I (c i)\nc_mem' : âˆ€ (i : Î¹), Membership.mem s (c i)\nlocallyFinite' : LocallyFinite fun i => Function.support â†‘(toFun i)\neventuallyEq_one' : âˆ€ (x : M), Membership.mem s x â†’ Exists fun i => (nhds x).EventuallyEq (â†‘(toFun i)) 1\nxâœ : Eq { c := câœ, toFun := toFunâœ, c_mem' := c_mem'âœ, locallyFinite' := locallyFinite'âœ, eventuallyEq_one' := eventuallyEq_one'âœ } { c := c, toFun := toFun, c_mem' := c_mem', locallyFinite' := locallyFinite', eventuallyEq_one' := eventuallyEq_one' }\nâŠ¢ And (Eq câœ c) (HEq toFunâœ toFun)","decl":"/-- We say that a collection of `SmoothBumpFunction`s is a `SmoothBumpCovering` of a set `s` if\n\n* `(f i).c âˆˆ s` for all `i`;\n* the family `fun i â†¦ support (f i)` is locally finite;\n* for each point `x âˆˆ s` there exists `i` such that `f i =á¶ [ð“ x] 1`;\n  in other words, `x` belongs to the interior of `{y | f i y = 1}`;\n\nIf `M` is a finite dimensional real manifold which is a `Ïƒ`-compact Hausdorff topological space,\nthen for every covering `U : M â†’ Set M`, `âˆ€ x, U x âˆˆ ð“ x`, there exists a `SmoothBumpCovering`\nsubordinate to `U`, see `SmoothBumpCovering.exists_isSubordinate`.\n\nThis covering can be used, e.g., to construct a partition of unity and to prove the weak\nWhitney embedding theorem. -/\nstructure SmoothBumpCovering [FiniteDimensional â„ E] (s : Set M := univ) where\n  /-- The center point of each bump in the smooth covering. -/\n  c : Î¹ â†’ M\n  /-- A smooth bump function around `c i`. -/\n  toFun : âˆ€ i, SmoothBumpFunction I (c i)\n  /-- All the bump functions in the covering are centered at points in `s`. -/\n  c_mem' : âˆ€ i, c i âˆˆ s\n  /-- Around each point, there are only finitely many nonzero bump functions in the family. -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- Around each point in `s`, one of the bump functions is equal to `1`. -/\n  eventuallyEq_one' : âˆ€ x âˆˆ s, âˆƒ i, toFun i =á¶ [ð“ x] 1\n\n"}
{"name":"SmoothBumpCovering.locallyFinite'","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\nH : Type uH\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : FiniteDimensional Real E\ns : optParam (Set M) Set.univ\nself : SmoothBumpCovering Î¹ I M s\nâŠ¢ LocallyFinite fun i => Function.support â†‘(self.toFun i)","decl":"/-- We say that a collection of `SmoothBumpFunction`s is a `SmoothBumpCovering` of a set `s` if\n\n* `(f i).c âˆˆ s` for all `i`;\n* the family `fun i â†¦ support (f i)` is locally finite;\n* for each point `x âˆˆ s` there exists `i` such that `f i =á¶ [ð“ x] 1`;\n  in other words, `x` belongs to the interior of `{y | f i y = 1}`;\n\nIf `M` is a finite dimensional real manifold which is a `Ïƒ`-compact Hausdorff topological space,\nthen for every covering `U : M â†’ Set M`, `âˆ€ x, U x âˆˆ ð“ x`, there exists a `SmoothBumpCovering`\nsubordinate to `U`, see `SmoothBumpCovering.exists_isSubordinate`.\n\nThis covering can be used, e.g., to construct a partition of unity and to prove the weak\nWhitney embedding theorem. -/\nstructure SmoothBumpCovering [FiniteDimensional â„ E] (s : Set M := univ) where\n  /-- The center point of each bump in the smooth covering. -/\n  c : Î¹ â†’ M\n  /-- A smooth bump function around `c i`. -/\n  toFun : âˆ€ i, SmoothBumpFunction I (c i)\n  /-- All the bump functions in the covering are centered at points in `s`. -/\n  c_mem' : âˆ€ i, c i âˆˆ s\n  /-- Around each point, there are only finitely many nonzero bump functions in the family. -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- Around each point in `s`, one of the bump functions is equal to `1`. -/\n  eventuallyEq_one' : âˆ€ x âˆˆ s, âˆƒ i, toFun i =á¶ [ð“ x] 1\n\n"}
{"name":"SmoothBumpCovering.mk.injEq","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\nH : Type uH\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : FiniteDimensional Real E\ns : Set M\ncâœ : Î¹ â†’ M\ntoFunâœ : (i : Î¹) â†’ SmoothBumpFunction I (câœ i)\nc_mem'âœ : âˆ€ (i : Î¹), Membership.mem s (câœ i)\nlocallyFinite'âœ : LocallyFinite fun i => Function.support â†‘(toFunâœ i)\neventuallyEq_one'âœ : âˆ€ (x : M), Membership.mem s x â†’ Exists fun i => (nhds x).EventuallyEq (â†‘(toFunâœ i)) 1\nc : Î¹ â†’ M\ntoFun : (i : Î¹) â†’ SmoothBumpFunction I (c i)\nc_mem' : âˆ€ (i : Î¹), Membership.mem s (c i)\nlocallyFinite' : LocallyFinite fun i => Function.support â†‘(toFun i)\neventuallyEq_one' : âˆ€ (x : M), Membership.mem s x â†’ Exists fun i => (nhds x).EventuallyEq (â†‘(toFun i)) 1\nâŠ¢ Eq (Eq { c := câœ, toFun := toFunâœ, c_mem' := c_mem'âœ, locallyFinite' := locallyFinite'âœ, eventuallyEq_one' := eventuallyEq_one'âœ } { c := c, toFun := toFun, c_mem' := c_mem', locallyFinite' := locallyFinite', eventuallyEq_one' := eventuallyEq_one' }) (And (Eq câœ c) (HEq toFunâœ toFun))","decl":"/-- We say that a collection of `SmoothBumpFunction`s is a `SmoothBumpCovering` of a set `s` if\n\n* `(f i).c âˆˆ s` for all `i`;\n* the family `fun i â†¦ support (f i)` is locally finite;\n* for each point `x âˆˆ s` there exists `i` such that `f i =á¶ [ð“ x] 1`;\n  in other words, `x` belongs to the interior of `{y | f i y = 1}`;\n\nIf `M` is a finite dimensional real manifold which is a `Ïƒ`-compact Hausdorff topological space,\nthen for every covering `U : M â†’ Set M`, `âˆ€ x, U x âˆˆ ð“ x`, there exists a `SmoothBumpCovering`\nsubordinate to `U`, see `SmoothBumpCovering.exists_isSubordinate`.\n\nThis covering can be used, e.g., to construct a partition of unity and to prove the weak\nWhitney embedding theorem. -/\nstructure SmoothBumpCovering [FiniteDimensional â„ E] (s : Set M := univ) where\n  /-- The center point of each bump in the smooth covering. -/\n  c : Î¹ â†’ M\n  /-- A smooth bump function around `c i`. -/\n  toFun : âˆ€ i, SmoothBumpFunction I (c i)\n  /-- All the bump functions in the covering are centered at points in `s`. -/\n  c_mem' : âˆ€ i, c i âˆˆ s\n  /-- Around each point, there are only finitely many nonzero bump functions in the family. -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- Around each point in `s`, one of the bump functions is equal to `1`. -/\n  eventuallyEq_one' : âˆ€ x âˆˆ s, âˆƒ i, toFun i =á¶ [ð“ x] 1\n\n"}
{"name":"SmoothBumpCovering.eventuallyEq_one'","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\nH : Type uH\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : FiniteDimensional Real E\ns : optParam (Set M) Set.univ\nself : SmoothBumpCovering Î¹ I M s\nx : M\naâœ : Membership.mem s x\nâŠ¢ Exists fun i => (nhds x).EventuallyEq (â†‘(self.toFun i)) 1","decl":"/-- We say that a collection of `SmoothBumpFunction`s is a `SmoothBumpCovering` of a set `s` if\n\n* `(f i).c âˆˆ s` for all `i`;\n* the family `fun i â†¦ support (f i)` is locally finite;\n* for each point `x âˆˆ s` there exists `i` such that `f i =á¶ [ð“ x] 1`;\n  in other words, `x` belongs to the interior of `{y | f i y = 1}`;\n\nIf `M` is a finite dimensional real manifold which is a `Ïƒ`-compact Hausdorff topological space,\nthen for every covering `U : M â†’ Set M`, `âˆ€ x, U x âˆˆ ð“ x`, there exists a `SmoothBumpCovering`\nsubordinate to `U`, see `SmoothBumpCovering.exists_isSubordinate`.\n\nThis covering can be used, e.g., to construct a partition of unity and to prove the weak\nWhitney embedding theorem. -/\nstructure SmoothBumpCovering [FiniteDimensional â„ E] (s : Set M := univ) where\n  /-- The center point of each bump in the smooth covering. -/\n  c : Î¹ â†’ M\n  /-- A smooth bump function around `c i`. -/\n  toFun : âˆ€ i, SmoothBumpFunction I (c i)\n  /-- All the bump functions in the covering are centered at points in `s`. -/\n  c_mem' : âˆ€ i, c i âˆˆ s\n  /-- Around each point, there are only finitely many nonzero bump functions in the family. -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- Around each point in `s`, one of the bump functions is equal to `1`. -/\n  eventuallyEq_one' : âˆ€ x âˆˆ s, âˆƒ i, toFun i =á¶ [ð“ x] 1\n\n"}
{"name":"SmoothBumpCovering.c_mem'","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\nH : Type uH\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : FiniteDimensional Real E\ns : optParam (Set M) Set.univ\nself : SmoothBumpCovering Î¹ I M s\ni : Î¹\nâŠ¢ Membership.mem s (self.c i)","decl":"/-- We say that a collection of `SmoothBumpFunction`s is a `SmoothBumpCovering` of a set `s` if\n\n* `(f i).c âˆˆ s` for all `i`;\n* the family `fun i â†¦ support (f i)` is locally finite;\n* for each point `x âˆˆ s` there exists `i` such that `f i =á¶ [ð“ x] 1`;\n  in other words, `x` belongs to the interior of `{y | f i y = 1}`;\n\nIf `M` is a finite dimensional real manifold which is a `Ïƒ`-compact Hausdorff topological space,\nthen for every covering `U : M â†’ Set M`, `âˆ€ x, U x âˆˆ ð“ x`, there exists a `SmoothBumpCovering`\nsubordinate to `U`, see `SmoothBumpCovering.exists_isSubordinate`.\n\nThis covering can be used, e.g., to construct a partition of unity and to prove the weak\nWhitney embedding theorem. -/\nstructure SmoothBumpCovering [FiniteDimensional â„ E] (s : Set M := univ) where\n  /-- The center point of each bump in the smooth covering. -/\n  c : Î¹ â†’ M\n  /-- A smooth bump function around `c i`. -/\n  toFun : âˆ€ i, SmoothBumpFunction I (c i)\n  /-- All the bump functions in the covering are centered at points in `s`. -/\n  c_mem' : âˆ€ i, c i âˆˆ s\n  /-- Around each point, there are only finitely many nonzero bump functions in the family. -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- Around each point in `s`, one of the bump functions is equal to `1`. -/\n  eventuallyEq_one' : âˆ€ x âˆˆ s, âˆƒ i, toFun i =á¶ [ð“ x] 1\n\n"}
{"name":"SmoothPartitionOfUnity.sum_le_one'","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : optParam (Set M) Set.univ\nself : SmoothPartitionOfUnity Î¹ I M s\nx : M\nâŠ¢ LE.le (finsum fun i => (self.toFun i) x) 1","decl":"/-- We say that a collection of functions form a smooth partition of unity on a set `s` if\n\n* all functions are infinitely smooth and nonnegative;\n* the family `fun i â†¦ support (f i)` is locally finite;\n* for all `x âˆˆ s` the sum `âˆ‘á¶  i, f i x` equals one;\n* for all `x`, the sum `âˆ‘á¶  i, f i x` is less than or equal to one. -/\nstructure SmoothPartitionOfUnity (s : Set M := univ) where\n  /-- The family of functions forming the partition of unity. -/\n  toFun : Î¹ â†’ C^âˆžâŸ®I, M; ð“˜(â„), â„âŸ¯\n  /-- Around each point, there are only finitely many nonzero functions in the family. -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- All the functions in the partition of unity are nonnegative. -/\n  nonneg' : âˆ€ i x, 0 â‰¤ toFun i x\n  /-- The functions in the partition of unity add up to `1` at any point of `s`. -/\n  sum_eq_one' : âˆ€ x âˆˆ s, âˆ‘á¶  i, toFun i x = 1\n  /-- The functions in the partition of unity add up to at most `1` everywhere. -/\n  sum_le_one' : âˆ€ x, âˆ‘á¶  i, toFun i x â‰¤ 1\n\n"}
{"name":"SmoothPartitionOfUnity.nonneg'","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : optParam (Set M) Set.univ\nself : SmoothPartitionOfUnity Î¹ I M s\ni : Î¹\nx : M\nâŠ¢ LE.le 0 ((self.toFun i) x)","decl":"/-- We say that a collection of functions form a smooth partition of unity on a set `s` if\n\n* all functions are infinitely smooth and nonnegative;\n* the family `fun i â†¦ support (f i)` is locally finite;\n* for all `x âˆˆ s` the sum `âˆ‘á¶  i, f i x` equals one;\n* for all `x`, the sum `âˆ‘á¶  i, f i x` is less than or equal to one. -/\nstructure SmoothPartitionOfUnity (s : Set M := univ) where\n  /-- The family of functions forming the partition of unity. -/\n  toFun : Î¹ â†’ C^âˆžâŸ®I, M; ð“˜(â„), â„âŸ¯\n  /-- Around each point, there are only finitely many nonzero functions in the family. -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- All the functions in the partition of unity are nonnegative. -/\n  nonneg' : âˆ€ i x, 0 â‰¤ toFun i x\n  /-- The functions in the partition of unity add up to `1` at any point of `s`. -/\n  sum_eq_one' : âˆ€ x âˆˆ s, âˆ‘á¶  i, toFun i x = 1\n  /-- The functions in the partition of unity add up to at most `1` everywhere. -/\n  sum_le_one' : âˆ€ x, âˆ‘á¶  i, toFun i x â‰¤ 1\n\n"}
{"name":"SmoothPartitionOfUnity.locallyFinite'","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : optParam (Set M) Set.univ\nself : SmoothPartitionOfUnity Î¹ I M s\nâŠ¢ LocallyFinite fun i => Function.support â‡‘(self.toFun i)","decl":"/-- We say that a collection of functions form a smooth partition of unity on a set `s` if\n\n* all functions are infinitely smooth and nonnegative;\n* the family `fun i â†¦ support (f i)` is locally finite;\n* for all `x âˆˆ s` the sum `âˆ‘á¶  i, f i x` equals one;\n* for all `x`, the sum `âˆ‘á¶  i, f i x` is less than or equal to one. -/\nstructure SmoothPartitionOfUnity (s : Set M := univ) where\n  /-- The family of functions forming the partition of unity. -/\n  toFun : Î¹ â†’ C^âˆžâŸ®I, M; ð“˜(â„), â„âŸ¯\n  /-- Around each point, there are only finitely many nonzero functions in the family. -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- All the functions in the partition of unity are nonnegative. -/\n  nonneg' : âˆ€ i x, 0 â‰¤ toFun i x\n  /-- The functions in the partition of unity add up to `1` at any point of `s`. -/\n  sum_eq_one' : âˆ€ x âˆˆ s, âˆ‘á¶  i, toFun i x = 1\n  /-- The functions in the partition of unity add up to at most `1` everywhere. -/\n  sum_le_one' : âˆ€ x, âˆ‘á¶  i, toFun i x â‰¤ 1\n\n"}
{"name":"SmoothPartitionOfUnity.sum_eq_one'","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : optParam (Set M) Set.univ\nself : SmoothPartitionOfUnity Î¹ I M s\nx : M\naâœ : Membership.mem s x\nâŠ¢ Eq (finsum fun i => (self.toFun i) x) 1","decl":"/-- We say that a collection of functions form a smooth partition of unity on a set `s` if\n\n* all functions are infinitely smooth and nonnegative;\n* the family `fun i â†¦ support (f i)` is locally finite;\n* for all `x âˆˆ s` the sum `âˆ‘á¶  i, f i x` equals one;\n* for all `x`, the sum `âˆ‘á¶  i, f i x` is less than or equal to one. -/\nstructure SmoothPartitionOfUnity (s : Set M := univ) where\n  /-- The family of functions forming the partition of unity. -/\n  toFun : Î¹ â†’ C^âˆžâŸ®I, M; ð“˜(â„), â„âŸ¯\n  /-- Around each point, there are only finitely many nonzero functions in the family. -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- All the functions in the partition of unity are nonnegative. -/\n  nonneg' : âˆ€ i x, 0 â‰¤ toFun i x\n  /-- The functions in the partition of unity add up to `1` at any point of `s`. -/\n  sum_eq_one' : âˆ€ x âˆˆ s, âˆ‘á¶  i, toFun i x = 1\n  /-- The functions in the partition of unity add up to at most `1` everywhere. -/\n  sum_le_one' : âˆ€ x, âˆ‘á¶  i, toFun i x â‰¤ 1\n\n"}
{"name":"SmoothPartitionOfUnity.mk.inj","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\ntoFunâœ : Î¹ â†’ ContMDiffMap I (modelWithCornersSelf Real Real) M Real â†‘Top.top\nlocallyFinite'âœ : LocallyFinite fun i => Function.support â‡‘(toFunâœ i)\nnonneg'âœ : âˆ€ (i : Î¹) (x : M), LE.le 0 ((toFunâœ i) x)\nsum_eq_one'âœ : âˆ€ (x : M), Membership.mem s x â†’ Eq (finsum fun i => (toFunâœ i) x) 1\nsum_le_one'âœ : âˆ€ (x : M), LE.le (finsum fun i => (toFunâœ i) x) 1\ntoFun : Î¹ â†’ ContMDiffMap I (modelWithCornersSelf Real Real) M Real â†‘Top.top\nlocallyFinite' : LocallyFinite fun i => Function.support â‡‘(toFun i)\nnonneg' : âˆ€ (i : Î¹) (x : M), LE.le 0 ((toFun i) x)\nsum_eq_one' : âˆ€ (x : M), Membership.mem s x â†’ Eq (finsum fun i => (toFun i) x) 1\nsum_le_one' : âˆ€ (x : M), LE.le (finsum fun i => (toFun i) x) 1\nxâœ : Eq { toFun := toFunâœ, locallyFinite' := locallyFinite'âœ, nonneg' := nonneg'âœ, sum_eq_one' := sum_eq_one'âœ, sum_le_one' := sum_le_one'âœ } { toFun := toFun, locallyFinite' := locallyFinite', nonneg' := nonneg', sum_eq_one' := sum_eq_one', sum_le_one' := sum_le_one' }\nâŠ¢ Eq toFunâœ toFun","decl":"/-- We say that a collection of functions form a smooth partition of unity on a set `s` if\n\n* all functions are infinitely smooth and nonnegative;\n* the family `fun i â†¦ support (f i)` is locally finite;\n* for all `x âˆˆ s` the sum `âˆ‘á¶  i, f i x` equals one;\n* for all `x`, the sum `âˆ‘á¶  i, f i x` is less than or equal to one. -/\nstructure SmoothPartitionOfUnity (s : Set M := univ) where\n  /-- The family of functions forming the partition of unity. -/\n  toFun : Î¹ â†’ C^âˆžâŸ®I, M; ð“˜(â„), â„âŸ¯\n  /-- Around each point, there are only finitely many nonzero functions in the family. -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- All the functions in the partition of unity are nonnegative. -/\n  nonneg' : âˆ€ i x, 0 â‰¤ toFun i x\n  /-- The functions in the partition of unity add up to `1` at any point of `s`. -/\n  sum_eq_one' : âˆ€ x âˆˆ s, âˆ‘á¶  i, toFun i x = 1\n  /-- The functions in the partition of unity add up to at most `1` everywhere. -/\n  sum_le_one' : âˆ€ x, âˆ‘á¶  i, toFun i x â‰¤ 1\n\n"}
{"name":"SmoothPartitionOfUnity.mk.sizeOf_spec","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace Real E\nH : Type uH\ninstâœâ· : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\ns : optParam (Set M) Set.univ\ninstâœâ´ : SizeOf Î¹\ninstâœÂ³ : SizeOf E\ninstâœÂ² : SizeOf H\ninstâœÂ¹ : SizeOf M\ninstâœ : (a : M) â†’ SizeOf (s a)\ntoFun : Î¹ â†’ ContMDiffMap I (modelWithCornersSelf Real Real) M Real â†‘Top.top\nlocallyFinite' : LocallyFinite fun i => Function.support â‡‘(toFun i)\nnonneg' : âˆ€ (i : Î¹) (x : M), LE.le 0 ((toFun i) x)\nsum_eq_one' : âˆ€ (x : M), Membership.mem s x â†’ Eq (finsum fun i => (toFun i) x) 1\nsum_le_one' : âˆ€ (x : M), LE.le (finsum fun i => (toFun i) x) 1\nâŠ¢ Eq (SizeOf.sizeOf { toFun := toFun, locallyFinite' := locallyFinite', nonneg' := nonneg', sum_eq_one' := sum_eq_one', sum_le_one' := sum_le_one' }) 1","decl":"/-- We say that a collection of functions form a smooth partition of unity on a set `s` if\n\n* all functions are infinitely smooth and nonnegative;\n* the family `fun i â†¦ support (f i)` is locally finite;\n* for all `x âˆˆ s` the sum `âˆ‘á¶  i, f i x` equals one;\n* for all `x`, the sum `âˆ‘á¶  i, f i x` is less than or equal to one. -/\nstructure SmoothPartitionOfUnity (s : Set M := univ) where\n  /-- The family of functions forming the partition of unity. -/\n  toFun : Î¹ â†’ C^âˆžâŸ®I, M; ð“˜(â„), â„âŸ¯\n  /-- Around each point, there are only finitely many nonzero functions in the family. -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- All the functions in the partition of unity are nonnegative. -/\n  nonneg' : âˆ€ i x, 0 â‰¤ toFun i x\n  /-- The functions in the partition of unity add up to `1` at any point of `s`. -/\n  sum_eq_one' : âˆ€ x âˆˆ s, âˆ‘á¶  i, toFun i x = 1\n  /-- The functions in the partition of unity add up to at most `1` everywhere. -/\n  sum_le_one' : âˆ€ x, âˆ‘á¶  i, toFun i x â‰¤ 1\n\n"}
{"name":"SmoothPartitionOfUnity.mk.injEq","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\ntoFunâœ : Î¹ â†’ ContMDiffMap I (modelWithCornersSelf Real Real) M Real â†‘Top.top\nlocallyFinite'âœ : LocallyFinite fun i => Function.support â‡‘(toFunâœ i)\nnonneg'âœ : âˆ€ (i : Î¹) (x : M), LE.le 0 ((toFunâœ i) x)\nsum_eq_one'âœ : âˆ€ (x : M), Membership.mem s x â†’ Eq (finsum fun i => (toFunâœ i) x) 1\nsum_le_one'âœ : âˆ€ (x : M), LE.le (finsum fun i => (toFunâœ i) x) 1\ntoFun : Î¹ â†’ ContMDiffMap I (modelWithCornersSelf Real Real) M Real â†‘Top.top\nlocallyFinite' : LocallyFinite fun i => Function.support â‡‘(toFun i)\nnonneg' : âˆ€ (i : Î¹) (x : M), LE.le 0 ((toFun i) x)\nsum_eq_one' : âˆ€ (x : M), Membership.mem s x â†’ Eq (finsum fun i => (toFun i) x) 1\nsum_le_one' : âˆ€ (x : M), LE.le (finsum fun i => (toFun i) x) 1\nâŠ¢ Eq (Eq { toFun := toFunâœ, locallyFinite' := locallyFinite'âœ, nonneg' := nonneg'âœ, sum_eq_one' := sum_eq_one'âœ, sum_le_one' := sum_le_one'âœ } { toFun := toFun, locallyFinite' := locallyFinite', nonneg' := nonneg', sum_eq_one' := sum_eq_one', sum_le_one' := sum_le_one' }) (Eq toFunâœ toFun)","decl":"/-- We say that a collection of functions form a smooth partition of unity on a set `s` if\n\n* all functions are infinitely smooth and nonnegative;\n* the family `fun i â†¦ support (f i)` is locally finite;\n* for all `x âˆˆ s` the sum `âˆ‘á¶  i, f i x` equals one;\n* for all `x`, the sum `âˆ‘á¶  i, f i x` is less than or equal to one. -/\nstructure SmoothPartitionOfUnity (s : Set M := univ) where\n  /-- The family of functions forming the partition of unity. -/\n  toFun : Î¹ â†’ C^âˆžâŸ®I, M; ð“˜(â„), â„âŸ¯\n  /-- Around each point, there are only finitely many nonzero functions in the family. -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- All the functions in the partition of unity are nonnegative. -/\n  nonneg' : âˆ€ i x, 0 â‰¤ toFun i x\n  /-- The functions in the partition of unity add up to `1` at any point of `s`. -/\n  sum_eq_one' : âˆ€ x âˆˆ s, âˆ‘á¶  i, toFun i x = 1\n  /-- The functions in the partition of unity add up to at most `1` everywhere. -/\n  sum_le_one' : âˆ€ x, âˆ‘á¶  i, toFun i x â‰¤ 1\n\n"}
{"name":"SmoothPartitionOfUnity.locallyFinite","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : SmoothPartitionOfUnity Î¹ I M s\nâŠ¢ LocallyFinite fun i => Function.support â‡‘(f i)","decl":"protected theorem locallyFinite : LocallyFinite fun i => support (f i) :=\n  f.locallyFinite'\n\n"}
{"name":"SmoothPartitionOfUnity.nonneg","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : SmoothPartitionOfUnity Î¹ I M s\ni : Î¹\nx : M\nâŠ¢ LE.le 0 ((f i) x)","decl":"theorem nonneg (i : Î¹) (x : M) : 0 â‰¤ f i x :=\n  f.nonneg' i x\n\n"}
{"name":"SmoothPartitionOfUnity.sum_eq_one","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : SmoothPartitionOfUnity Î¹ I M s\nx : M\nhx : Membership.mem s x\nâŠ¢ Eq (finsum fun i => (f i) x) 1","decl":"theorem sum_eq_one {x} (hx : x âˆˆ s) : âˆ‘á¶  i, f i x = 1 :=\n  f.sum_eq_one' x hx\n\n"}
{"name":"SmoothPartitionOfUnity.exists_pos_of_mem","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : SmoothPartitionOfUnity Î¹ I M s\nx : M\nhx : Membership.mem s x\nâŠ¢ Exists fun i => LT.lt 0 ((f i) x)","decl":"theorem exists_pos_of_mem {x} (hx : x âˆˆ s) : âˆƒ i, 0 < f i x := by\n  by_contra! h\n  have H : âˆ€ i, f i x = 0 := fun i â†¦ le_antisymm (h i) (f.nonneg i x)\n  have := f.sum_eq_one hx\n  simp_rw [H] at this\n  simpa\n\n"}
{"name":"SmoothPartitionOfUnity.sum_le_one","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : SmoothPartitionOfUnity Î¹ I M s\nx : M\nâŠ¢ LE.le (finsum fun i => (f i) x) 1","decl":"theorem sum_le_one (x : M) : âˆ‘á¶  i, f i x â‰¤ 1 :=\n  f.sum_le_one' x\n\n"}
{"name":"SmoothPartitionOfUnity.toPartitionOfUnity_toFun","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : SmoothPartitionOfUnity Î¹ I M s\ni : Î¹\nâŠ¢ Eq (f.toPartitionOfUnity i) â†‘(f i)","decl":"/-- Reinterpret a smooth partition of unity as a continuous partition of unity. -/\n@[simps]\ndef toPartitionOfUnity : PartitionOfUnity Î¹ M s :=\n  { f with toFun := fun i => f i }\n\n"}
{"name":"SmoothPartitionOfUnity.contMDiff_sum","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : SmoothPartitionOfUnity Î¹ I M s\nâŠ¢ ContMDiff I (modelWithCornersSelf Real Real) â†‘Top.top fun x => finsum fun i => (f i) x","decl":"theorem contMDiff_sum : ContMDiff I ð“˜(â„) âˆž fun x => âˆ‘á¶  i, f i x :=\n  contMDiff_finsum (fun i => (f i).contMDiff) f.locallyFinite\n\n"}
{"name":"SmoothPartitionOfUnity.smooth_sum","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : SmoothPartitionOfUnity Î¹ I M s\nâŠ¢ ContMDiff I (modelWithCornersSelf Real Real) â†‘Top.top fun x => finsum fun i => (f i) x","decl":"@[deprecated (since := \"2024-11-21\")] alias smooth_sum := contMDiff_sum\n\n"}
{"name":"SmoothPartitionOfUnity.le_one","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : SmoothPartitionOfUnity Î¹ I M s\ni : Î¹\nx : M\nâŠ¢ LE.le ((f i) x) 1","decl":"theorem le_one (i : Î¹) (x : M) : f i x â‰¤ 1 :=\n  f.toPartitionOfUnity.le_one i x\n\n"}
{"name":"SmoothPartitionOfUnity.sum_nonneg","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : SmoothPartitionOfUnity Î¹ I M s\nx : M\nâŠ¢ LE.le 0 (finsum fun i => (f i) x)","decl":"theorem sum_nonneg (x : M) : 0 â‰¤ âˆ‘á¶  i, f i x :=\n  f.toPartitionOfUnity.sum_nonneg x\n\n"}
{"name":"SmoothPartitionOfUnity.finsum_smul_mem_convex","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\nF : Type uF\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : SmoothPartitionOfUnity Î¹ I M s\ng : Î¹ â†’ M â†’ F\nt : Set F\nx : M\nhx : Membership.mem s x\nhg : âˆ€ (i : Î¹), Ne ((f i) x) 0 â†’ Membership.mem t (g i x)\nht : Convex Real t\nâŠ¢ Membership.mem t (finsum fun i => HSMul.hSMul ((f i) x) (g i x))","decl":"theorem finsum_smul_mem_convex {g : Î¹ â†’ M â†’ F} {t : Set F} {x : M} (hx : x âˆˆ s)\n    (hg : âˆ€ i, f i x â‰  0 â†’ g i x âˆˆ t) (ht : Convex â„ t) : âˆ‘á¶  i, f i x â€¢ g i x âˆˆ t :=\n  ht.finsum_mem (fun _ => f.nonneg _ _) (f.sum_eq_one hx) hg\n\n"}
{"name":"SmoothPartitionOfUnity.contMDiff_smul","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\nF : Type uF\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : SmoothPartitionOfUnity Î¹ I M s\nn : ENat\ng : M â†’ F\ni : Î¹\nhg : âˆ€ (x : M), Membership.mem (tsupport â‡‘(f i)) x â†’ ContMDiffAt I (modelWithCornersSelf Real F) (â†‘n) g x\nâŠ¢ ContMDiff I (modelWithCornersSelf Real F) â†‘n fun x => HSMul.hSMul ((f i) x) (g x)","decl":"theorem contMDiff_smul {g : M â†’ F} {i} (hg : âˆ€ x âˆˆ tsupport (f i), ContMDiffAt I ð“˜(â„, F) n g x) :\n    ContMDiff I ð“˜(â„, F) n fun x => f i x â€¢ g x :=\n  contMDiff_of_tsupport fun x hx =>\n    ((f i).contMDiff.contMDiffAt.of_le (mod_cast le_top)).smul <| hg x\n      <| tsupport_smul_subset_left _ _ hx\n\n"}
{"name":"SmoothPartitionOfUnity.smooth_smul","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\nF : Type uF\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : SmoothPartitionOfUnity Î¹ I M s\nn : ENat\ng : M â†’ F\ni : Î¹\nhg : âˆ€ (x : M), Membership.mem (tsupport â‡‘(f i)) x â†’ ContMDiffAt I (modelWithCornersSelf Real F) (â†‘n) g x\nâŠ¢ ContMDiff I (modelWithCornersSelf Real F) â†‘n fun x => HSMul.hSMul ((f i) x) (g x)","decl":"@[deprecated (since := \"2024-11-21\")] alias smooth_smul := contMDiff_smul\n\n"}
{"name":"SmoothPartitionOfUnity.contMDiff_finsum_smul","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\nF : Type uF\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : SmoothPartitionOfUnity Î¹ I M s\nn : ENat\ng : Î¹ â†’ M â†’ F\nhg : âˆ€ (i : Î¹) (x : M), Membership.mem (tsupport â‡‘(f i)) x â†’ ContMDiffAt I (modelWithCornersSelf Real F) (â†‘n) (g i) x\nâŠ¢ ContMDiff I (modelWithCornersSelf Real F) â†‘n fun x => finsum fun i => HSMul.hSMul ((f i) x) (g i x)","decl":"/-- If `f` is a smooth partition of unity on a set `s : Set M` and `g : Î¹ â†’ M â†’ F` is a family of\nfunctions such that `g i` is $C^n$ smooth at every point of the topological support of `f i`, then\nthe sum `fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is smooth on the whole manifold. -/\ntheorem contMDiff_finsum_smul {g : Î¹ â†’ M â†’ F}\n    (hg : âˆ€ (i), âˆ€ x âˆˆ tsupport (f i), ContMDiffAt I ð“˜(â„, F) n (g i) x) :\n    ContMDiff I ð“˜(â„, F) n fun x => âˆ‘á¶  i, f i x â€¢ g i x :=\n  (contMDiff_finsum fun i => f.contMDiff_smul (hg i)) <|\n    f.locallyFinite.subset fun _ => support_smul_subset_left _ _\n\n"}
{"name":"SmoothPartitionOfUnity.smooth_finsum_smul","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\nF : Type uF\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : SmoothPartitionOfUnity Î¹ I M s\nn : ENat\ng : Î¹ â†’ M â†’ F\nhg : âˆ€ (i : Î¹) (x : M), Membership.mem (tsupport â‡‘(f i)) x â†’ ContMDiffAt I (modelWithCornersSelf Real F) (â†‘n) (g i) x\nâŠ¢ ContMDiff I (modelWithCornersSelf Real F) â†‘n fun x => finsum fun i => HSMul.hSMul ((f i) x) (g i x)","decl":"@[deprecated (since := \"2024-11-21\")] alias smooth_finsum_smul := contMDiff_finsum_smul\n\n"}
{"name":"SmoothPartitionOfUnity.contMDiffAt_finsum","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\nF : Type uF\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : SmoothPartitionOfUnity Î¹ I M s\nn : ENat\nxâ‚€ : M\ng : Î¹ â†’ M â†’ F\nhÏ† : âˆ€ (i : Î¹), Membership.mem (tsupport â‡‘(f i)) xâ‚€ â†’ ContMDiffAt I (modelWithCornersSelf Real F) (â†‘n) (g i) xâ‚€\nâŠ¢ ContMDiffAt I (modelWithCornersSelf Real F) (â†‘n) (fun x => finsum fun i => HSMul.hSMul ((f i) x) (g i x)) xâ‚€","decl":"theorem contMDiffAt_finsum {xâ‚€ : M} {g : Î¹ â†’ M â†’ F}\n    (hÏ† : âˆ€ i, xâ‚€ âˆˆ tsupport (f i) â†’ ContMDiffAt I ð“˜(â„, F) n (g i) xâ‚€) :\n    ContMDiffAt I ð“˜(â„, F) n (fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x) xâ‚€ := by\n  refine _root_.contMDiffAt_finsum (f.locallyFinite.smul_left _) fun i â†¦ ?_\n  by_cases hx : xâ‚€ âˆˆ tsupport (f i)\n  Â· exact ContMDiffAt.smul ((f i).contMDiff.of_le (mod_cast le_top)).contMDiffAt (hÏ† i hx)\n  Â· exact contMDiffAt_of_not_mem (compl_subset_compl.mpr\n      (tsupport_smul_subset_left (f i) (g i)) hx) n\n\n"}
{"name":"SmoothPartitionOfUnity.contDiffAt_finsum","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nn : ENat\ns : Set E\nf : SmoothPartitionOfUnity Î¹ (modelWithCornersSelf Real E) E s\nxâ‚€ : E\ng : Î¹ â†’ E â†’ F\nhÏ† : âˆ€ (i : Î¹), Membership.mem (tsupport â‡‘(f i)) xâ‚€ â†’ ContDiffAt Real (â†‘n) (g i) xâ‚€\nâŠ¢ ContDiffAt Real (â†‘n) (fun x => finsum fun i => HSMul.hSMul ((f i) x) (g i x)) xâ‚€","decl":"theorem contDiffAt_finsum {s : Set E} (f : SmoothPartitionOfUnity Î¹ ð“˜(â„, E) E s) {xâ‚€ : E}\n    {g : Î¹ â†’ E â†’ F} (hÏ† : âˆ€ i, xâ‚€ âˆˆ tsupport (f i) â†’ ContDiffAt â„ n (g i) xâ‚€) :\n    ContDiffAt â„ n (fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x) xâ‚€ := by\n  simp only [â† contMDiffAt_iff_contDiffAt] at *\n  exact f.contMDiffAt_finsum hÏ†\n\n"}
{"name":"SmoothPartitionOfUnity.mem_finsupport","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nÏ : SmoothPartitionOfUnity Î¹ I M s\nxâ‚€ : M\ni : Î¹\nâŠ¢ Iff (Membership.mem (Ï.finsupport xâ‚€) i) (Membership.mem (Function.support fun i => (Ï i) xâ‚€) i)","decl":"@[simp]\ntheorem mem_finsupport {i : Î¹} : i âˆˆ Ï.finsupport xâ‚€ â†” i âˆˆ support fun i â†¦ Ï i xâ‚€ :=\n  Ï.toPartitionOfUnity.mem_finsupport xâ‚€\n\n"}
{"name":"SmoothPartitionOfUnity.coe_finsupport","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nÏ : SmoothPartitionOfUnity Î¹ I M s\nxâ‚€ : M\nâŠ¢ Eq (â†‘(Ï.finsupport xâ‚€)) (Function.support fun i => (Ï i) xâ‚€)","decl":"@[simp]\ntheorem coe_finsupport : (Ï.finsupport xâ‚€ : Set Î¹) = support fun i â†¦ Ï i xâ‚€ :=\n  Ï.toPartitionOfUnity.coe_finsupport xâ‚€\n\n"}
{"name":"SmoothPartitionOfUnity.sum_finsupport","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nÏ : SmoothPartitionOfUnity Î¹ I M s\nxâ‚€ : M\nhxâ‚€ : Membership.mem s xâ‚€\nâŠ¢ Eq ((Ï.finsupport xâ‚€).sum fun i => (Ï i) xâ‚€) 1","decl":"theorem sum_finsupport (hxâ‚€ : xâ‚€ âˆˆ s) : âˆ‘ i âˆˆ Ï.finsupport xâ‚€, Ï i xâ‚€ = 1 :=\n  Ï.toPartitionOfUnity.sum_finsupport hxâ‚€\n\n"}
{"name":"SmoothPartitionOfUnity.sum_finsupport'","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nIâœ : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nÏ : SmoothPartitionOfUnity Î¹ Iâœ M s\nxâ‚€ : M\nhxâ‚€ : Membership.mem s xâ‚€\nI : Finset Î¹\nhI : HasSubset.Subset (Ï.finsupport xâ‚€) I\nâŠ¢ Eq (I.sum fun i => (Ï i) xâ‚€) 1","decl":"theorem sum_finsupport' (hxâ‚€ : xâ‚€ âˆˆ s) {I : Finset Î¹} (hI : Ï.finsupport xâ‚€ âŠ† I) :\n    âˆ‘ i âˆˆ I, Ï i xâ‚€ = 1 :=\n  Ï.toPartitionOfUnity.sum_finsupport' hxâ‚€ hI\n\n"}
{"name":"SmoothPartitionOfUnity.sum_finsupport_smul_eq_finsum","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\nH : Type uH\ninstâœâ´ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ³ : TopologicalSpace M\ninstâœÂ² : ChartedSpace H M\ns : Set M\nÏ : SmoothPartitionOfUnity Î¹ I M s\nxâ‚€ : M\nA : Type u_1\ninstâœÂ¹ : AddCommGroup A\ninstâœ : Module Real A\nÏ† : Î¹ â†’ M â†’ A\nâŠ¢ Eq ((Ï.finsupport xâ‚€).sum fun i => HSMul.hSMul ((Ï i) xâ‚€) (Ï† i xâ‚€)) (finsum fun i => HSMul.hSMul ((Ï i) xâ‚€) (Ï† i xâ‚€))","decl":"theorem sum_finsupport_smul_eq_finsum {A : Type*} [AddCommGroup A] [Module â„ A] (Ï† : Î¹ â†’ M â†’ A) :\n    âˆ‘ i âˆˆ Ï.finsupport xâ‚€, Ï i xâ‚€ â€¢ Ï† i xâ‚€ = âˆ‘á¶  i, Ï i xâ‚€ â€¢ Ï† i xâ‚€ :=\n  Ï.toPartitionOfUnity.sum_finsupport_smul_eq_finsum Ï†\n\n"}
{"name":"SmoothPartitionOfUnity.finite_tsupport","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nÏ : SmoothPartitionOfUnity Î¹ I M s\nxâ‚€ : M\nâŠ¢ (setOf fun i => Membership.mem (tsupport â‡‘(Ï i)) xâ‚€).Finite","decl":"/-- The `tsupport`s of a smooth partition of unity are locally finite. -/\ntheorem finite_tsupport : {i | xâ‚€ âˆˆ tsupport (Ï i)}.Finite :=\n  Ï.toPartitionOfUnity.finite_tsupport _\n\n"}
{"name":"SmoothPartitionOfUnity.mem_fintsupport_iff","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nÏ : SmoothPartitionOfUnity Î¹ I M s\nxâ‚€ : M\ni : Î¹\nâŠ¢ Iff (Membership.mem (Ï.fintsupport xâ‚€) i) (Membership.mem (tsupport â‡‘(Ï i)) xâ‚€)","decl":"theorem mem_fintsupport_iff (i : Î¹) : i âˆˆ Ï.fintsupport xâ‚€ â†” xâ‚€ âˆˆ tsupport (Ï i) :=\n  Finite.mem_toFinset _\n\n"}
{"name":"SmoothPartitionOfUnity.eventually_fintsupport_subset","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nÏ : SmoothPartitionOfUnity Î¹ I M s\nxâ‚€ : M\nâŠ¢ Filter.Eventually (fun y => HasSubset.Subset (Ï.fintsupport y) (Ï.fintsupport xâ‚€)) (nhds xâ‚€)","decl":"theorem eventually_fintsupport_subset : âˆ€á¶  y in ð“ xâ‚€, Ï.fintsupport y âŠ† Ï.fintsupport xâ‚€ :=\n  Ï.toPartitionOfUnity.eventually_fintsupport_subset _\n\n"}
{"name":"SmoothPartitionOfUnity.finsupport_subset_fintsupport","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nÏ : SmoothPartitionOfUnity Î¹ I M s\nxâ‚€ : M\nâŠ¢ HasSubset.Subset (Ï.finsupport xâ‚€) (Ï.fintsupport xâ‚€)","decl":"theorem finsupport_subset_fintsupport : Ï.finsupport xâ‚€ âŠ† Ï.fintsupport xâ‚€ :=\n  Ï.toPartitionOfUnity.finsupport_subset_fintsupport xâ‚€\n\n"}
{"name":"SmoothPartitionOfUnity.eventually_finsupport_subset","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nÏ : SmoothPartitionOfUnity Î¹ I M s\nxâ‚€ : M\nâŠ¢ Filter.Eventually (fun y => HasSubset.Subset (Ï.finsupport y) (Ï.fintsupport xâ‚€)) (nhds xâ‚€)","decl":"theorem eventually_finsupport_subset : âˆ€á¶  y in ð“ xâ‚€, Ï.finsupport y âŠ† Ï.fintsupport xâ‚€ :=\n  Ï.toPartitionOfUnity.eventually_finsupport_subset xâ‚€\n\n"}
{"name":"SmoothPartitionOfUnity.isSubordinate_toPartitionOfUnity","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : SmoothPartitionOfUnity Î¹ I M s\nU : Î¹ â†’ Set M\nâŠ¢ Iff (f.toPartitionOfUnity.IsSubordinate U) (f.IsSubordinate U)","decl":"@[simp]\ntheorem isSubordinate_toPartitionOfUnity :\n    f.toPartitionOfUnity.IsSubordinate U â†” f.IsSubordinate U :=\n  Iff.rfl\n\n"}
{"name":"SmoothPartitionOfUnity.IsSubordinate.toPartitionOfUnity","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : SmoothPartitionOfUnity Î¹ I M s\nU : Î¹ â†’ Set M\naâœ : f.IsSubordinate U\nâŠ¢ f.toPartitionOfUnity.IsSubordinate U","decl":"alias âŸ¨_, IsSubordinate.toPartitionOfUnityâŸ© := isSubordinate_toPartitionOfUnity\n\n"}
{"name":"SmoothPartitionOfUnity.IsSubordinate.contMDiff_finsum_smul","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\nF : Type uF\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : SmoothPartitionOfUnity Î¹ I M s\nn : ENat\nU : Î¹ â†’ Set M\ng : Î¹ â†’ M â†’ F\nhf : f.IsSubordinate U\nho : âˆ€ (i : Î¹), IsOpen (U i)\nhg : âˆ€ (i : Î¹), ContMDiffOn I (modelWithCornersSelf Real F) (â†‘n) (g i) (U i)\nâŠ¢ ContMDiff I (modelWithCornersSelf Real F) â†‘n fun x => finsum fun i => HSMul.hSMul ((f i) x) (g i x)","decl":"/-- If `f` is a smooth partition of unity on a set `s : Set M` subordinate to a family of open sets\n`U : Î¹ â†’ Set M` and `g : Î¹ â†’ M â†’ F` is a family of functions such that `g i` is $C^n$ smooth on\n`U i`, then the sum `fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is $C^n$ smooth on the whole manifold. -/\ntheorem IsSubordinate.contMDiff_finsum_smul {g : Î¹ â†’ M â†’ F} (hf : f.IsSubordinate U)\n    (ho : âˆ€ i, IsOpen (U i)) (hg : âˆ€ i, ContMDiffOn I ð“˜(â„, F) n (g i) (U i)) :\n    ContMDiff I ð“˜(â„, F) n fun x => âˆ‘á¶  i, f i x â€¢ g i x :=\n  f.contMDiff_finsum_smul fun i _ hx => (hg i).contMDiffAt <| (ho i).mem_nhds (hf i hx)\n\n"}
{"name":"SmoothPartitionOfUnity.IsSubordinate.smooth_finsum_smul","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\nF : Type uF\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : SmoothPartitionOfUnity Î¹ I M s\nn : ENat\nU : Î¹ â†’ Set M\ng : Î¹ â†’ M â†’ F\nhf : f.IsSubordinate U\nho : âˆ€ (i : Î¹), IsOpen (U i)\nhg : âˆ€ (i : Î¹), ContMDiffOn I (modelWithCornersSelf Real F) (â†‘n) (g i) (U i)\nâŠ¢ ContMDiff I (modelWithCornersSelf Real F) â†‘n fun x => finsum fun i => HSMul.hSMul ((f i) x) (g i x)","decl":"@[deprecated (since := \"2024-11-21\")]\nalias IsSubordinate.smooth_finsum_smul := IsSubordinate.contMDiff_finsum_smul\n\n"}
{"name":"BumpCovering.contMDiff_toPartitionOfUnity","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : BumpCovering Î¹ M s\nhf : âˆ€ (i : Î¹), ContMDiff I (modelWithCornersSelf Real Real) â†‘Top.top â‡‘(f i)\ni : Î¹\nâŠ¢ ContMDiff I (modelWithCornersSelf Real Real) â†‘Top.top â‡‘(f.toPartitionOfUnity i)","decl":"theorem contMDiff_toPartitionOfUnity {E : Type uE} [NormedAddCommGroup E] [NormedSpace â„ E]\n    {H : Type uH} [TopologicalSpace H] {I : ModelWithCorners â„ E H} {M : Type uM}\n    [TopologicalSpace M] [ChartedSpace H M] {s : Set M} (f : BumpCovering Î¹ M s)\n    (hf : âˆ€ i, ContMDiff I ð“˜(â„) âˆž (f i)) (i : Î¹) : ContMDiff I ð“˜(â„) âˆž (f.toPartitionOfUnity i) :=\n  (hf i).mul <| (contMDiff_finprod_cond fun j _ => contMDiff_const.sub (hf j)) <| by\n    simp only [Pi.sub_def, mulSupport_one_sub]\n    exact f.locallyFinite\n\n"}
{"name":"BumpCovering.smooth_toPartitionOfUnity","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : BumpCovering Î¹ M s\nhf : âˆ€ (i : Î¹), ContMDiff I (modelWithCornersSelf Real Real) â†‘Top.top â‡‘(f i)\ni : Î¹\nâŠ¢ ContMDiff I (modelWithCornersSelf Real Real) â†‘Top.top â‡‘(f.toPartitionOfUnity i)","decl":"@[deprecated (since := \"2024-11-21\")]\nalias smooth_toPartitionOfUnity := contMDiff_toPartitionOfUnity\n\n"}
{"name":"BumpCovering.toSmoothPartitionOfUnity_toPartitionOfUnity","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : BumpCovering Î¹ M s\nhf : âˆ€ (i : Î¹), ContMDiff I (modelWithCornersSelf Real Real) â†‘Top.top â‡‘(f i)\nâŠ¢ Eq (f.toSmoothPartitionOfUnity hf).toPartitionOfUnity f.toPartitionOfUnity","decl":"@[simp]\ntheorem toSmoothPartitionOfUnity_toPartitionOfUnity (f : BumpCovering Î¹ M s)\n    (hf : âˆ€ i, ContMDiff I ð“˜(â„) âˆž (f i)) :\n    (f.toSmoothPartitionOfUnity hf).toPartitionOfUnity = f.toPartitionOfUnity :=\n  rfl\n\n"}
{"name":"BumpCovering.coe_toSmoothPartitionOfUnity","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : BumpCovering Î¹ M s\nhf : âˆ€ (i : Î¹), ContMDiff I (modelWithCornersSelf Real Real) â†‘Top.top â‡‘(f i)\ni : Î¹\nâŠ¢ Eq â‡‘((f.toSmoothPartitionOfUnity hf) i) â‡‘(f.toPartitionOfUnity i)","decl":"@[simp]\ntheorem coe_toSmoothPartitionOfUnity (f : BumpCovering Î¹ M s) (hf : âˆ€ i, ContMDiff I ð“˜(â„) âˆž (f i))\n    (i : Î¹) : â‡‘(f.toSmoothPartitionOfUnity hf i) = f.toPartitionOfUnity i :=\n  rfl\n\n"}
{"name":"BumpCovering.IsSubordinate.toSmoothPartitionOfUnity","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type uH\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nf : BumpCovering Î¹ M s\nU : Î¹ â†’ Set M\nh : f.IsSubordinate U\nhf : âˆ€ (i : Î¹), ContMDiff I (modelWithCornersSelf Real Real) â†‘Top.top â‡‘(f i)\nâŠ¢ (f.toSmoothPartitionOfUnity hf).IsSubordinate U","decl":"theorem IsSubordinate.toSmoothPartitionOfUnity {f : BumpCovering Î¹ M s} {U : Î¹ â†’ Set M}\n    (h : f.IsSubordinate U) (hf : âˆ€ i, ContMDiff I ð“˜(â„) âˆž (f i)) :\n    (f.toSmoothPartitionOfUnity hf).IsSubordinate U :=\n  h.toPartitionOfUnity\n\n"}
{"name":"SmoothBumpCovering.IsSubordinate.support_subset","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\nH : Type uH\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : FiniteDimensional Real E\ns : Set M\nfs : SmoothBumpCovering Î¹ I M s\nU : M â†’ Set M\nh : fs.IsSubordinate U\ni : Î¹\nâŠ¢ HasSubset.Subset (Function.support â†‘(fs.toFun i)) (U (fs.c i))","decl":"theorem IsSubordinate.support_subset {fs : SmoothBumpCovering Î¹ I M s} {U : M â†’ Set M}\n    (h : fs.IsSubordinate U) (i : Î¹) : support (fs i) âŠ† U (fs.c i) :=\n  Subset.trans subset_closure (h i)\n\n"}
{"name":"SmoothBumpCovering.exists_isSubordinate","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"E : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\nH : Type uH\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace H M\ninstâœÂ² : FiniteDimensional Real E\ns : Set M\nU : M â†’ Set M\ninstâœÂ¹ : T2Space M\ninstâœ : SigmaCompactSpace M\nhs : IsClosed s\nhU : âˆ€ (x : M), Membership.mem s x â†’ Membership.mem (nhds x) (U x)\nâŠ¢ Exists fun Î¹ => Exists fun f => f.IsSubordinate U","decl":"variable (I) in\n/-- Let `M` be a smooth manifold modelled on a finite dimensional real vector space.\nSuppose also that `M` is a Hausdorff `Ïƒ`-compact topological space. Let `s` be a closed set\nin `M` and `U : M â†’ Set M` be a collection of sets such that `U x âˆˆ ð“ x` for every `x âˆˆ s`.\nThen there exists a smooth bump covering of `s` that is subordinate to `U`. -/\ntheorem exists_isSubordinate [T2Space M] [SigmaCompactSpace M] (hs : IsClosed s)\n    (hU : âˆ€ x âˆˆ s, U x âˆˆ ð“ x) :\n    âˆƒ (Î¹ : Type uM) (f : SmoothBumpCovering Î¹ I M s), f.IsSubordinate U := by\n  -- First we deduce some missing instances\n  haveI : LocallyCompactSpace H := I.locallyCompactSpace\n  haveI : LocallyCompactSpace M := ChartedSpace.locallyCompactSpace H M\n  -- Next we choose a covering by supports of smooth bump functions\n  have hB := fun x hx => SmoothBumpFunction.nhds_basis_support (I := I) (hU x hx)\n  rcases refinement_of_locallyCompact_sigmaCompact_of_nhds_basis_set hs hB with\n    âŸ¨Î¹, c, f, hf, hsub', hfinâŸ©\n  choose hcs hfU using hf\n  -- Then we use the shrinking lemma to get a covering by smaller open\n  rcases exists_subset_iUnion_closed_subset hs (fun i => (f i).isOpen_support)\n    (fun x _ => hfin.point_finite x) hsub' with âŸ¨V, hsV, hVc, hVfâŸ©\n  choose r hrR hr using fun i => (f i).exists_r_pos_lt_subset_ball (hVc i) (hVf i)\n  refine âŸ¨Î¹, âŸ¨c, fun i => (f i).updateRIn (r i) (hrR i), hcs, ?_, fun x hx => ?_âŸ©, fun i => ?_âŸ©\n  Â· simpa only [SmoothBumpFunction.support_updateRIn]\n  Â· refine (mem_iUnion.1 <| hsV hx).imp fun i hi => ?_\n    exact ((f i).updateRIn _ _).eventuallyEq_one_of_dist_lt\n      ((f i).support_subset_source <| hVf _ hi) (hr i hi).2\n  Â· simpa only [SmoothBumpFunction.support_updateRIn, tsupport] using hfU i\n\n"}
{"name":"SmoothBumpCovering.locallyFinite","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\nH : Type uH\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : FiniteDimensional Real E\ns : Set M\nfs : SmoothBumpCovering Î¹ I M s\nâŠ¢ LocallyFinite fun i => Function.support â†‘(fs.toFun i)","decl":"protected theorem locallyFinite : LocallyFinite fun i => support (fs i) :=\n  fs.locallyFinite'\n\n"}
{"name":"SmoothBumpCovering.point_finite","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\nH : Type uH\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : FiniteDimensional Real E\ns : Set M\nfs : SmoothBumpCovering Î¹ I M s\nx : M\nâŠ¢ (setOf fun i => Ne (â†‘(fs.toFun i) x) 0).Finite","decl":"protected theorem point_finite (x : M) : {i | fs i x â‰  0}.Finite :=\n  fs.locallyFinite.point_finite x\n\n"}
{"name":"SmoothBumpCovering.eventuallyEq_one","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\nH : Type uH\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : FiniteDimensional Real E\ns : Set M\nfs : SmoothBumpCovering Î¹ I M s\nx : M\nhx : Membership.mem s x\nâŠ¢ (nhds x).EventuallyEq (â†‘(fs.toFun (fs.ind x hx))) 1","decl":"theorem eventuallyEq_one (x : M) (hx : x âˆˆ s) : fs (fs.ind x hx) =á¶ [ð“ x] 1 :=\n  (fs.eventuallyEq_one' x hx).choose_spec\n\n"}
{"name":"SmoothBumpCovering.apply_ind","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\nH : Type uH\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : FiniteDimensional Real E\ns : Set M\nfs : SmoothBumpCovering Î¹ I M s\nx : M\nhx : Membership.mem s x\nâŠ¢ Eq (â†‘(fs.toFun (fs.ind x hx)) x) 1","decl":"theorem apply_ind (x : M) (hx : x âˆˆ s) : fs (fs.ind x hx) x = 1 :=\n  (fs.eventuallyEq_one x hx).eq_of_nhds\n\n"}
{"name":"SmoothBumpCovering.mem_support_ind","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\nH : Type uH\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : FiniteDimensional Real E\ns : Set M\nfs : SmoothBumpCovering Î¹ I M s\nx : M\nhx : Membership.mem s x\nâŠ¢ Membership.mem (Function.support â†‘(fs.toFun (fs.ind x hx))) x","decl":"theorem mem_support_ind (x : M) (hx : x âˆˆ s) : x âˆˆ support (fs <| fs.ind x hx) := by\n  simp [fs.apply_ind x hx]\n\n"}
{"name":"SmoothBumpCovering.mem_chartAt_source_of_eq_one","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\nH : Type uH\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : FiniteDimensional Real E\ns : Set M\nfs : SmoothBumpCovering Î¹ I M s\ni : Î¹\nx : M\nh : Eq (â†‘(fs.toFun i) x) 1\nâŠ¢ Membership.mem (chartAt H (fs.c i)).source x","decl":"theorem mem_chartAt_source_of_eq_one {i : Î¹} {x : M} (h : fs i x = 1) :\n    x âˆˆ (chartAt H (fs.c i)).source :=\n  (fs i).support_subset_source <| by simp [h]\n\n"}
{"name":"SmoothBumpCovering.mem_extChartAt_source_of_eq_one","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\nH : Type uH\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : FiniteDimensional Real E\ns : Set M\nfs : SmoothBumpCovering Î¹ I M s\ni : Î¹\nx : M\nh : Eq (â†‘(fs.toFun i) x) 1\nâŠ¢ Membership.mem (extChartAt I (fs.c i)).source x","decl":"theorem mem_extChartAt_source_of_eq_one {i : Î¹} {x : M} (h : fs i x = 1) :\n    x âˆˆ (extChartAt I (fs.c i)).source := by\n  rw [extChartAt_source]; exact fs.mem_chartAt_source_of_eq_one h\n\n"}
{"name":"SmoothBumpCovering.mem_chartAt_ind_source","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\nH : Type uH\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : FiniteDimensional Real E\ns : Set M\nfs : SmoothBumpCovering Î¹ I M s\nx : M\nhx : Membership.mem s x\nâŠ¢ Membership.mem (chartAt H (fs.c (fs.ind x hx))).source x","decl":"theorem mem_chartAt_ind_source (x : M) (hx : x âˆˆ s) : x âˆˆ (chartAt H (fs.c (fs.ind x hx))).source :=\n  fs.mem_chartAt_source_of_eq_one (fs.apply_ind x hx)\n\n"}
{"name":"SmoothBumpCovering.mem_extChartAt_ind_source","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\nH : Type uH\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : FiniteDimensional Real E\ns : Set M\nfs : SmoothBumpCovering Î¹ I M s\nx : M\nhx : Membership.mem s x\nâŠ¢ Membership.mem (extChartAt I (fs.c (fs.ind x hx))).source x","decl":"theorem mem_extChartAt_ind_source (x : M) (hx : x âˆˆ s) :\n    x âˆˆ (extChartAt I (fs.c (fs.ind x hx))).source :=\n  fs.mem_extChartAt_source_of_eq_one (fs.apply_ind x hx)\n\n"}
{"name":"SmoothBumpCovering.isSubordinate_toBumpCovering","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\nH : Type uH\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace H M\ninstâœÂ² : FiniteDimensional Real E\ns : Set M\ninstâœÂ¹ : T2Space M\ninstâœ : IsManifold I (â†‘Top.top) M\nf : SmoothBumpCovering Î¹ I M s\nU : M â†’ Set M\nâŠ¢ Iff (f.toBumpCovering.IsSubordinate fun i => U (f.c i)) (f.IsSubordinate U)","decl":"@[simp, nolint simpNF]\ntheorem isSubordinate_toBumpCovering {f : SmoothBumpCovering Î¹ I M s} {U : M â†’ Set M} :\n    (f.toBumpCovering.IsSubordinate fun i => U (f.c i)) â†” f.IsSubordinate U :=\n  Iff.rfl\n\n"}
{"name":"SmoothBumpCovering.IsSubordinate.toBumpCovering","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\nH : Type uH\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace H M\ninstâœÂ² : FiniteDimensional Real E\ns : Set M\ninstâœÂ¹ : T2Space M\ninstâœ : IsManifold I (â†‘Top.top) M\nf : SmoothBumpCovering Î¹ I M s\nU : M â†’ Set M\naâœ : f.IsSubordinate U\nâŠ¢ f.toBumpCovering.IsSubordinate fun i => U (f.c i)","decl":"alias âŸ¨_, IsSubordinate.toBumpCoveringâŸ© := isSubordinate_toBumpCovering\n\n"}
{"name":"SmoothBumpCovering.toSmoothPartitionOfUnity_apply","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\nH : Type uH\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace H M\ninstâœÂ² : FiniteDimensional Real E\ns : Set M\nfs : SmoothBumpCovering Î¹ I M s\ninstâœÂ¹ : T2Space M\ninstâœ : IsManifold I (â†‘Top.top) M\ni : Î¹\nx : M\nâŠ¢ Eq ((fs.toSmoothPartitionOfUnity i) x) (HMul.hMul (â†‘(fs.toFun i) x) (finprod fun j => finprod fun x_1 => HSub.hSub 1 (â†‘(fs.toFun j) x)))","decl":"theorem toSmoothPartitionOfUnity_apply (i : Î¹) (x : M) :\n    fs.toSmoothPartitionOfUnity i x = fs i x * âˆá¶  (j) (_ : WellOrderingRel j i), (1 - fs j x) :=\n  rfl\n\n"}
{"name":"SmoothBumpCovering.toSmoothPartitionOfUnity_eq_mul_prod","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\nH : Type uH\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace H M\ninstâœÂ² : FiniteDimensional Real E\ns : Set M\nfs : SmoothBumpCovering Î¹ I M s\ninstâœÂ¹ : T2Space M\ninstâœ : IsManifold I (â†‘Top.top) M\ni : Î¹\nx : M\nt : Finset Î¹\nht : âˆ€ (j : Î¹), WellOrderingRel j i â†’ Ne (â†‘(fs.toFun j) x) 0 â†’ Membership.mem t j\nâŠ¢ Eq ((fs.toSmoothPartitionOfUnity i) x) (HMul.hMul (â†‘(fs.toFun i) x) ((Finset.filter (fun j => WellOrderingRel j i) t).prod fun j => HSub.hSub 1 (â†‘(fs.toFun j) x)))","decl":"open Classical in\ntheorem toSmoothPartitionOfUnity_eq_mul_prod (i : Î¹) (x : M) (t : Finset Î¹)\n    (ht : âˆ€ j, WellOrderingRel j i â†’ fs j x â‰  0 â†’ j âˆˆ t) :\n    fs.toSmoothPartitionOfUnity i x =\n      fs i x * âˆ j âˆˆ t.filter fun j => WellOrderingRel j i, (1 - fs j x) :=\n  fs.toBumpCovering.toPartitionOfUnity_eq_mul_prod i x t ht\n\n"}
{"name":"SmoothBumpCovering.exists_finset_toSmoothPartitionOfUnity_eventuallyEq","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\nH : Type uH\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace H M\ninstâœÂ² : FiniteDimensional Real E\ns : Set M\nfs : SmoothBumpCovering Î¹ I M s\ninstâœÂ¹ : T2Space M\ninstâœ : IsManifold I (â†‘Top.top) M\ni : Î¹\nx : M\nâŠ¢ Exists fun t => (nhds x).EventuallyEq (â‡‘(fs.toSmoothPartitionOfUnity i)) (HMul.hMul (â†‘(fs.toFun i)) ((Finset.filter (fun j => WellOrderingRel j i) t).prod fun j => HSub.hSub 1 â†‘(fs.toFun j)))","decl":"open Classical in\ntheorem exists_finset_toSmoothPartitionOfUnity_eventuallyEq (i : Î¹) (x : M) :\n    âˆƒ t : Finset Î¹,\n      fs.toSmoothPartitionOfUnity i =á¶ [ð“ x]\n        fs i * âˆ j âˆˆ t.filter fun j => WellOrderingRel j i, ((1 : M â†’ â„) - fs j) := by\n  -- Porting note: was defeq, now the continuous lemma uses bundled homs\n  simpa using fs.toBumpCovering.exists_finset_toPartitionOfUnity_eventuallyEq i x\n\n"}
{"name":"SmoothBumpCovering.toSmoothPartitionOfUnity_zero_of_zero","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\nH : Type uH\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace H M\ninstâœÂ² : FiniteDimensional Real E\ns : Set M\nfs : SmoothBumpCovering Î¹ I M s\ninstâœÂ¹ : T2Space M\ninstâœ : IsManifold I (â†‘Top.top) M\ni : Î¹\nx : M\nh : Eq (â†‘(fs.toFun i) x) 0\nâŠ¢ Eq ((fs.toSmoothPartitionOfUnity i) x) 0","decl":"theorem toSmoothPartitionOfUnity_zero_of_zero {i : Î¹} {x : M} (h : fs i x = 0) :\n    fs.toSmoothPartitionOfUnity i x = 0 :=\n  fs.toBumpCovering.toPartitionOfUnity_zero_of_zero h\n\n"}
{"name":"SmoothBumpCovering.support_toSmoothPartitionOfUnity_subset","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\nH : Type uH\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace H M\ninstâœÂ² : FiniteDimensional Real E\ns : Set M\nfs : SmoothBumpCovering Î¹ I M s\ninstâœÂ¹ : T2Space M\ninstâœ : IsManifold I (â†‘Top.top) M\ni : Î¹\nâŠ¢ HasSubset.Subset (Function.support â‡‘(fs.toSmoothPartitionOfUnity i)) (Function.support â†‘(fs.toFun i))","decl":"theorem support_toSmoothPartitionOfUnity_subset (i : Î¹) :\n    support (fs.toSmoothPartitionOfUnity i) âŠ† support (fs i) :=\n  fs.toBumpCovering.support_toPartitionOfUnity_subset i\n\n"}
{"name":"SmoothBumpCovering.IsSubordinate.toSmoothPartitionOfUnity","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\nH : Type uH\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace H M\ninstâœÂ² : FiniteDimensional Real E\ns : Set M\ninstâœÂ¹ : T2Space M\ninstâœ : IsManifold I (â†‘Top.top) M\nf : SmoothBumpCovering Î¹ I M s\nU : M â†’ Set M\nh : f.IsSubordinate U\nâŠ¢ f.toSmoothPartitionOfUnity.IsSubordinate fun i => U (f.c i)","decl":"theorem IsSubordinate.toSmoothPartitionOfUnity {f : SmoothBumpCovering Î¹ I M s} {U : M â†’ Set M}\n    (h : f.IsSubordinate U) : f.toSmoothPartitionOfUnity.IsSubordinate fun i => U (f.c i) :=\n  h.toBumpCovering.toPartitionOfUnity\n\n"}
{"name":"SmoothBumpCovering.sum_toSmoothPartitionOfUnity_eq","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\nH : Type uH\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace H M\ninstâœÂ² : FiniteDimensional Real E\ns : Set M\nfs : SmoothBumpCovering Î¹ I M s\ninstâœÂ¹ : T2Space M\ninstâœ : IsManifold I (â†‘Top.top) M\nx : M\nâŠ¢ Eq (finsum fun i => (fs.toSmoothPartitionOfUnity i) x) (HSub.hSub 1 (finprod fun i => HSub.hSub 1 (â†‘(fs.toFun i) x)))","decl":"theorem sum_toSmoothPartitionOfUnity_eq (x : M) :\n    âˆ‘á¶  i, fs.toSmoothPartitionOfUnity i x = 1 - âˆá¶  i, (1 - fs i x) :=\n  fs.toBumpCovering.sum_toPartitionOfUnity_eq x\n\n"}
{"name":"exists_smooth_zero_one_of_isClosed","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"E : Type uE\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Real E\nH : Type uH\ninstâœâ¶ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâµ : TopologicalSpace M\ninstâœâ´ : ChartedSpace H M\ninstâœÂ³ : FiniteDimensional Real E\ninstâœÂ² : IsManifold I (â†‘Top.top) M\ninstâœÂ¹ : T2Space M\ninstâœ : SigmaCompactSpace M\ns t : Set M\nhs : IsClosed s\nht : IsClosed t\nhd : Disjoint s t\nâŠ¢ Exists fun f => And (Set.EqOn (â‡‘f) 0 s) (And (Set.EqOn (â‡‘f) 1 t) (âˆ€ (x : M), Membership.mem (Set.Icc 0 1) (f x)))","decl":"/-- Given two disjoint closed sets `s, t` in a Hausdorff Ïƒ-compact finite dimensional manifold,\nthere exists an infinitely smooth function that is equal to `0` on `s` and to `1` on `t`.\nSee also `exists_msmooth_zero_iff_one_iff_of_isClosed`, which ensures additionally that\n`f` is equal to `0` exactly on `s` and to `1` exactly on `t`. -/\ntheorem exists_smooth_zero_one_of_isClosed [T2Space M] [SigmaCompactSpace M] {s t : Set M}\n    (hs : IsClosed s) (ht : IsClosed t) (hd : Disjoint s t) :\n    âˆƒ f : C^âˆžâŸ®I, M; ð“˜(â„), â„âŸ¯, EqOn f 0 s âˆ§ EqOn f 1 t âˆ§ âˆ€ x, f x âˆˆ Icc 0 1 := by\n  have : âˆ€ x âˆˆ t, sá¶œ âˆˆ ð“ x := fun x hx => hs.isOpen_compl.mem_nhds (disjoint_right.1 hd hx)\n  rcases SmoothBumpCovering.exists_isSubordinate I ht this with âŸ¨Î¹, f, hfâŸ©\n  set g := f.toSmoothPartitionOfUnity\n  refine\n    âŸ¨âŸ¨_, g.contMDiff_sumâŸ©, fun x hx => ?_, fun x => g.sum_eq_one, fun x =>\n      âŸ¨g.sum_nonneg x, g.sum_le_one xâŸ©âŸ©\n  suffices âˆ€ i, g i x = 0 by simp only [this, ContMDiffMap.coeFn_mk, finsum_zero, Pi.zero_apply]\n  refine fun i => f.toSmoothPartitionOfUnity_zero_of_zero ?_\n  exact nmem_support.1 (subset_compl_comm.1 (hf.support_subset i) hx)\n\n"}
{"name":"exists_smooth_zero_one_nhds_of_isClosed","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"E : Type uE\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace Real E\nH : Type uH\ninstâœâ· : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\ninstâœâ´ : FiniteDimensional Real E\ninstâœÂ³ : IsManifold I (â†‘Top.top) M\ninstâœÂ² : T2Space M\ninstâœÂ¹ : NormalSpace M\ninstâœ : SigmaCompactSpace M\ns t : Set M\nhs : IsClosed s\nht : IsClosed t\nhd : Disjoint s t\nâŠ¢ Exists fun f => And (Filter.Eventually (fun x => Eq (f x) 0) (nhdsSet s)) (And (Filter.Eventually (fun x => Eq (f x) 1) (nhdsSet t)) (âˆ€ (x : M), Membership.mem (Set.Icc 0 1) (f x)))","decl":"/-- Given two disjoint closed sets `s, t` in a Hausdorff normal Ïƒ-compact finite dimensional\nmanifold `M`, there exists a smooth function `f : M â†’ [0,1]` that vanishes in a neighbourhood of `s`\nand is equal to `1` in a neighbourhood of `t`. -/\ntheorem exists_smooth_zero_one_nhds_of_isClosed [T2Space M] [NormalSpace M] [SigmaCompactSpace M]\n    {s t : Set M} (hs : IsClosed s) (ht : IsClosed t) (hd : Disjoint s t) :\n    âˆƒ f : C^âˆžâŸ®I, M; ð“˜(â„), â„âŸ¯, (âˆ€á¶  x in ð“Ë¢ s, f x = 0) âˆ§ (âˆ€á¶  x in ð“Ë¢ t, f x = 1) âˆ§\n      âˆ€ x, f x âˆˆ Icc 0 1 := by\n  obtain âŸ¨u, u_op, hsu, hutâŸ© := normal_exists_closure_subset hs ht.isOpen_compl\n    (subset_compl_iff_disjoint_left.mpr hd.symm)\n  obtain âŸ¨v, v_op, htv, hvuâŸ© := normal_exists_closure_subset ht isClosed_closure.isOpen_compl\n    (subset_compl_comm.mp hut)\n  obtain âŸ¨f, hfu, hfv, hfâŸ© := exists_smooth_zero_one_of_isClosed I isClosed_closure isClosed_closure\n    (subset_compl_iff_disjoint_left.mp hvu)\n  refine âŸ¨f, ?_, ?_, hfâŸ©\n  Â· exact eventually_of_mem (mem_of_superset (u_op.mem_nhdsSet.mpr hsu) subset_closure) hfu\n  Â· exact eventually_of_mem (mem_of_superset (v_op.mem_nhdsSet.mpr htv) subset_closure) hfv\n\n"}
{"name":"exists_smooth_one_nhds_of_subset_interior","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"E : Type uE\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace Real E\nH : Type uH\ninstâœâ· : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\ninstâœâ´ : FiniteDimensional Real E\ninstâœÂ³ : IsManifold I (â†‘Top.top) M\ninstâœÂ² : T2Space M\ninstâœÂ¹ : NormalSpace M\ninstâœ : SigmaCompactSpace M\ns t : Set M\nhs : IsClosed s\nhd : HasSubset.Subset s (interior t)\nâŠ¢ Exists fun f => And (Filter.Eventually (fun x => Eq (f x) 1) (nhdsSet s)) (And (âˆ€ (x : M), Not (Membership.mem t x) â†’ Eq (f x) 0) (âˆ€ (x : M), Membership.mem (Set.Icc 0 1) (f x)))","decl":"/-- Given two sets `s, t` in a Hausdorff normal Ïƒ-compact finite-dimensional manifold `M`\nwith `s` open and `s âŠ† interior t`, there is a smooth function `f : M â†’ [0,1]` which is equal to `s`\nin a neighbourhood of `s` and has support contained in `t`. -/\ntheorem exists_smooth_one_nhds_of_subset_interior [T2Space M] [NormalSpace M] [SigmaCompactSpace M]\n    {s t : Set M} (hs : IsClosed s) (hd : s âŠ† interior t) :\n    âˆƒ f : C^âˆžâŸ®I, M; ð“˜(â„), â„âŸ¯, (âˆ€á¶  x in ð“Ë¢ s, f x = 1) âˆ§ (âˆ€ x âˆ‰ t, f x = 0) âˆ§\n      âˆ€ x, f x âˆˆ Icc 0 1 := by\n  rcases exists_smooth_zero_one_nhds_of_isClosed I isOpen_interior.isClosed_compl hs\n    (by rwa [â† subset_compl_iff_disjoint_left, compl_compl]) with âŸ¨f, h0, h1, hfâŸ©\n  refine âŸ¨f, h1, fun x hx â†¦ ?_, hfâŸ©\n  exact h0.self_of_nhdsSet _ fun hx' â†¦ hx <| interior_subset hx'\n\n"}
{"name":"SmoothPartitionOfUnity.exists_isSubordinate","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Real E\nH : Type uH\ninstâœâ¶ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâµ : TopologicalSpace M\ninstâœâ´ : ChartedSpace H M\ninstâœÂ³ : FiniteDimensional Real E\ninstâœÂ² : IsManifold I (â†‘Top.top) M\ninstâœÂ¹ : T2Space M\ninstâœ : SigmaCompactSpace M\ns : Set M\nhs : IsClosed s\nU : Î¹ â†’ Set M\nho : âˆ€ (i : Î¹), IsOpen (U i)\nhU : HasSubset.Subset s (Set.iUnion fun i => U i)\nâŠ¢ Exists fun f => f.IsSubordinate U","decl":"/-- If `X` is a paracompact normal topological space and `U` is an open covering of a closed set\n`s`, then there exists a `SmoothPartitionOfUnity Î¹ M s` that is subordinate to `U`. -/\ntheorem exists_isSubordinate {s : Set M} (hs : IsClosed s) (U : Î¹ â†’ Set M) (ho : âˆ€ i, IsOpen (U i))\n    (hU : s âŠ† â‹ƒ i, U i) : âˆƒ f : SmoothPartitionOfUnity Î¹ I M s, f.IsSubordinate U := by\n  haveI : LocallyCompactSpace H := I.locallyCompactSpace\n  haveI : LocallyCompactSpace M := ChartedSpace.locallyCompactSpace H M\n  -- porting note(https://github.com/leanprover/std4/issues/116):\n  -- split `rcases` into `have` + `rcases`\n  have := BumpCovering.exists_isSubordinate_of_prop (ContMDiff I ð“˜(â„) âˆž) ?_ hs U ho hU\n  Â· rcases this with âŸ¨f, hf, hfUâŸ©\n    exact âŸ¨f.toSmoothPartitionOfUnity hf, hfU.toSmoothPartitionOfUnity hfâŸ©\n  Â· intro s t hs ht hd\n    rcases exists_smooth_zero_one_of_isClosed I hs ht hd with âŸ¨f, hfâŸ©\n    exact âŸ¨f, f.contMDiff, hfâŸ©\n\n"}
{"name":"SmoothPartitionOfUnity.exists_isSubordinate_chartAt_source_of_isClosed","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"E : Type uE\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Real E\nH : Type uH\ninstâœâ¶ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâµ : TopologicalSpace M\ninstâœâ´ : ChartedSpace H M\ninstâœÂ³ : FiniteDimensional Real E\ninstâœÂ² : IsManifold I (â†‘Top.top) M\ninstâœÂ¹ : T2Space M\ninstâœ : SigmaCompactSpace M\ns : Set M\nhs : IsClosed s\nâŠ¢ Exists fun f => f.IsSubordinate fun x => (chartAt H â†‘x).source","decl":"theorem exists_isSubordinate_chartAt_source_of_isClosed {s : Set M} (hs : IsClosed s) :\n    âˆƒ f : SmoothPartitionOfUnity s I M s,\n      f.IsSubordinate (fun x â†¦ (chartAt H (x : M)).source) := by\n  apply exists_isSubordinate _ hs _ (fun i â†¦ (chartAt H _).open_source) (fun x hx â†¦ ?_)\n  exact mem_iUnion_of_mem âŸ¨x, hxâŸ© (mem_chart_source H x)\n\n"}
{"name":"SmoothPartitionOfUnity.exists_isSubordinate_chartAt_source","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"E : Type uE\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Real E\nH : Type uH\ninstâœâ¶ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâµ : TopologicalSpace M\ninstâœâ´ : ChartedSpace H M\ninstâœÂ³ : FiniteDimensional Real E\ninstâœÂ² : IsManifold I (â†‘Top.top) M\ninstâœÂ¹ : T2Space M\ninstâœ : SigmaCompactSpace M\nâŠ¢ Exists fun f => f.IsSubordinate fun x => (chartAt H x).source","decl":"theorem exists_isSubordinate_chartAt_source :\n    âˆƒ f : SmoothPartitionOfUnity M I M univ, f.IsSubordinate (fun x â†¦ (chartAt H x).source) := by\n  apply exists_isSubordinate _ isClosed_univ _ (fun i â†¦ (chartAt H _).open_source) (fun x _ â†¦ ?_)\n  exact mem_iUnion_of_mem x (mem_chart_source H x)\n\n"}
{"name":"exists_contMDiffOn_forall_mem_convex_of_local","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"E : Type uE\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : NormedSpace Real E\nF : Type uF\ninstâœâ¸ : NormedAddCommGroup F\ninstâœâ· : NormedSpace Real F\nH : Type uH\ninstâœâ¶ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâµ : TopologicalSpace M\ninstâœâ´ : ChartedSpace H M\ninstâœÂ³ : FiniteDimensional Real E\ninstâœÂ² : IsManifold I (â†‘Top.top) M\ninstâœÂ¹ : SigmaCompactSpace M\ninstâœ : T2Space M\nt : M â†’ Set F\nn : ENat\nht : âˆ€ (x : M), Convex Real (t x)\nHloc : âˆ€ (x : M), Exists fun U => And (Membership.mem (nhds x) U) (Exists fun g => And (ContMDiffOn I (modelWithCornersSelf Real F) (â†‘n) g U) (âˆ€ (y : M), Membership.mem U y â†’ Membership.mem (t y) (g y)))\nâŠ¢ Exists fun g => âˆ€ (x : M), Membership.mem (t x) (g x)","decl":"/-- Let `M` be a Ïƒ-compact Hausdorff finite dimensional topological manifold. Let `t : M â†’ Set F`\nbe a family of convex sets. Suppose that for each point `x : M` there exists a neighborhood\n`U âˆˆ ð“ x` and a function `g : M â†’ F` such that `g` is $C^n$ smooth on `U` and `g y âˆˆ t y` for all\n`y âˆˆ U`. Then there exists a $C^n$ smooth function `g : C^âˆžâŸ®I, M; ð“˜(â„, F), FâŸ¯` such that `g x âˆˆ t x`\nfor all `x`. See also `exists_smooth_forall_mem_convex_of_local` and\n`exists_smooth_forall_mem_convex_of_local_const`. -/\ntheorem exists_contMDiffOn_forall_mem_convex_of_local (ht : âˆ€ x, Convex â„ (t x))\n    (Hloc : âˆ€ x : M, âˆƒ U âˆˆ ð“ x, âˆƒ g : M â†’ F, ContMDiffOn I ð“˜(â„, F) n g U âˆ§ âˆ€ y âˆˆ U, g y âˆˆ t y) :\n    âˆƒ g : C^nâŸ®I, M; ð“˜(â„, F), FâŸ¯, âˆ€ x, g x âˆˆ t x := by\n  choose U hU g hgs hgt using Hloc\n  obtain âŸ¨f, hfâŸ© :=\n    SmoothPartitionOfUnity.exists_isSubordinate I isClosed_univ (fun x => interior (U x))\n      (fun x => isOpen_interior) fun x _ => mem_iUnion.2 âŸ¨x, mem_interior_iff_mem_nhds.2 (hU x)âŸ©\n  refine âŸ¨âŸ¨fun x => âˆ‘á¶  i, f i x â€¢ g i x,\n      hf.contMDiff_finsum_smul (fun i => isOpen_interior) fun i => (hgs i).mono interior_subsetâŸ©,\n    fun x => f.finsum_smul_mem_convex (mem_univ x) (fun i hi => hgt _ _ ?_) (ht _)âŸ©\n  exact interior_subset (hf _ <| subset_closure hi)\n\n"}
{"name":"exists_smooth_forall_mem_convex_of_local","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"E : Type uE\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : NormedSpace Real E\nF : Type uF\ninstâœâ¸ : NormedAddCommGroup F\ninstâœâ· : NormedSpace Real F\nH : Type uH\ninstâœâ¶ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâµ : TopologicalSpace M\ninstâœâ´ : ChartedSpace H M\ninstâœÂ³ : FiniteDimensional Real E\ninstâœÂ² : IsManifold I (â†‘Top.top) M\ninstâœÂ¹ : SigmaCompactSpace M\ninstâœ : T2Space M\nt : M â†’ Set F\nht : âˆ€ (x : M), Convex Real (t x)\nHloc : âˆ€ (x : M), Exists fun U => And (Membership.mem (nhds x) U) (Exists fun g => And (ContMDiffOn I (modelWithCornersSelf Real F) (â†‘Top.top) g U) (âˆ€ (y : M), Membership.mem U y â†’ Membership.mem (t y) (g y)))\nâŠ¢ Exists fun g => âˆ€ (x : M), Membership.mem (t x) (g x)","decl":"/-- Let `M` be a Ïƒ-compact Hausdorff finite dimensional topological manifold. Let `t : M â†’ Set F`\nbe a family of convex sets. Suppose that for each point `x : M` there exists a neighborhood\n`U âˆˆ ð“ x` and a function `g : M â†’ F` such that `g` is smooth on `U` and `g y âˆˆ t y` for all `y âˆˆ U`.\nThen there exists a smooth function `g : C^âˆžâŸ®I, M; ð“˜(â„, F), FâŸ¯` such that `g x âˆˆ t x` for all `x`.\nSee also `exists_contMDiffOn_forall_mem_convex_of_local` and\n`exists_smooth_forall_mem_convex_of_local_const`. -/\ntheorem exists_smooth_forall_mem_convex_of_local (ht : âˆ€ x, Convex â„ (t x))\n    (Hloc : âˆ€ x : M, âˆƒ U âˆˆ ð“ x, âˆƒ g : M â†’ F, ContMDiffOn I ð“˜(â„, F) âˆž g U âˆ§ âˆ€ y âˆˆ U, g y âˆˆ t y) :\n    âˆƒ g : C^âˆžâŸ®I, M; ð“˜(â„, F), FâŸ¯, âˆ€ x, g x âˆˆ t x :=\n  exists_contMDiffOn_forall_mem_convex_of_local I ht Hloc\n\n"}
{"name":"exists_smooth_forall_mem_convex_of_local_const","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"E : Type uE\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : NormedSpace Real E\nF : Type uF\ninstâœâ¸ : NormedAddCommGroup F\ninstâœâ· : NormedSpace Real F\nH : Type uH\ninstâœâ¶ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâµ : TopologicalSpace M\ninstâœâ´ : ChartedSpace H M\ninstâœÂ³ : FiniteDimensional Real E\ninstâœÂ² : IsManifold I (â†‘Top.top) M\ninstâœÂ¹ : SigmaCompactSpace M\ninstâœ : T2Space M\nt : M â†’ Set F\nht : âˆ€ (x : M), Convex Real (t x)\nHloc : âˆ€ (x : M), Exists fun c => Filter.Eventually (fun y => Membership.mem (t y) c) (nhds x)\nâŠ¢ Exists fun g => âˆ€ (x : M), Membership.mem (t x) (g x)","decl":"/-- Let `M` be a Ïƒ-compact Hausdorff finite dimensional topological manifold. Let `t : M â†’ Set F` be\na family of convex sets. Suppose that for each point `x : M` there exists a vector `c : F` such that\nfor all `y` in a neighborhood of `x` we have `c âˆˆ t y`. Then there exists a smooth function\n`g : C^âˆžâŸ®I, M; ð“˜(â„, F), FâŸ¯` such that `g x âˆˆ t x` for all `x`.  See also\n`exists_contMDiffOn_forall_mem_convex_of_local` and `exists_smooth_forall_mem_convex_of_local`. -/\ntheorem exists_smooth_forall_mem_convex_of_local_const (ht : âˆ€ x, Convex â„ (t x))\n    (Hloc : âˆ€ x : M, âˆƒ c : F, âˆ€á¶  y in ð“ x, c âˆˆ t y) : âˆƒ g : C^âˆžâŸ®I, M; ð“˜(â„, F), FâŸ¯, âˆ€ x, g x âˆˆ t x :=\n  exists_smooth_forall_mem_convex_of_local I ht fun x =>\n    let âŸ¨c, hcâŸ© := Hloc x\n    âŸ¨_, hc, fun _ => c, contMDiffOn_const, fun _ => idâŸ©\n\n"}
{"name":"Emetric.exists_smooth_forall_closedBall_subset","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\nH : Type uH\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners Real E H\ninstâœâ´ : FiniteDimensional Real E\nM : Type u_1\ninstâœÂ³ : EMetricSpace M\ninstâœÂ² : ChartedSpace H M\ninstâœÂ¹ : IsManifold I (â†‘Top.top) M\ninstâœ : SigmaCompactSpace M\nK U : Î¹ â†’ Set M\nhK : âˆ€ (i : Î¹), IsClosed (K i)\nhU : âˆ€ (i : Î¹), IsOpen (U i)\nhKU : âˆ€ (i : Î¹), HasSubset.Subset (K i) (U i)\nhfin : LocallyFinite K\nâŠ¢ Exists fun Î´ => And (âˆ€ (x : M), LT.lt 0 (Î´ x)) (âˆ€ (i : Î¹) (x : M), Membership.mem (K i) x â†’ HasSubset.Subset (EMetric.closedBall x (ENNReal.ofReal (Î´ x))) (U i))","decl":"/-- Let `M` be a smooth Ïƒ-compact manifold with extended distance. Let `K : Î¹ â†’ Set M` be a locally\nfinite family of closed sets, let `U : Î¹ â†’ Set M` be a family of open sets such that `K i âŠ† U i` for\nall `i`. Then there exists a positive smooth function `Î´ : M â†’ â„â‰¥0` such that for any `i` and\n`x âˆˆ K i`, we have `EMetric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem Emetric.exists_smooth_forall_closedBall_subset {M} [EMetricSpace M] [ChartedSpace H M]\n    [IsManifold I âˆž M] [SigmaCompactSpace M] {K : Î¹ â†’ Set M} {U : Î¹ â†’ Set M}\n    (hK : âˆ€ i, IsClosed (K i)) (hU : âˆ€ i, IsOpen (U i)) (hKU : âˆ€ i, K i âŠ† U i)\n    (hfin : LocallyFinite K) :\n    âˆƒ Î´ : C^âˆžâŸ®I, M; ð“˜(â„, â„), â„âŸ¯,\n      (âˆ€ x, 0 < Î´ x) âˆ§ âˆ€ (i), âˆ€ x âˆˆ K i, EMetric.closedBall x (ENNReal.ofReal (Î´ x)) âŠ† U i := by\n  simpa only [mem_inter_iff, forall_and, mem_preimage, mem_iInter, @forall_swap Î¹ M]\n    using exists_smooth_forall_mem_convex_of_local_const I\n      EMetric.exists_forall_closedBall_subset_auxâ‚‚\n      (EMetric.exists_forall_closedBall_subset_auxâ‚ hK hU hKU hfin)\n\n"}
{"name":"Metric.exists_smooth_forall_closedBall_subset","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"Î¹ : Type uÎ¹\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\nH : Type uH\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners Real E H\ninstâœâ´ : FiniteDimensional Real E\nM : Type u_1\ninstâœÂ³ : MetricSpace M\ninstâœÂ² : ChartedSpace H M\ninstâœÂ¹ : IsManifold I (â†‘Top.top) M\ninstâœ : SigmaCompactSpace M\nK U : Î¹ â†’ Set M\nhK : âˆ€ (i : Î¹), IsClosed (K i)\nhU : âˆ€ (i : Î¹), IsOpen (U i)\nhKU : âˆ€ (i : Î¹), HasSubset.Subset (K i) (U i)\nhfin : LocallyFinite K\nâŠ¢ Exists fun Î´ => And (âˆ€ (x : M), LT.lt 0 (Î´ x)) (âˆ€ (i : Î¹) (x : M), Membership.mem (K i) x â†’ HasSubset.Subset (Metric.closedBall x (Î´ x)) (U i))","decl":"/-- Let `M` be a smooth Ïƒ-compact manifold with a metric. Let `K : Î¹ â†’ Set M` be a locally finite\nfamily of closed sets, let `U : Î¹ â†’ Set M` be a family of open sets such that `K i âŠ† U i` for all\n`i`. Then there exists a positive smooth function `Î´ : M â†’ â„â‰¥0` such that for any `i` and `x âˆˆ K i`,\nwe have `Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem Metric.exists_smooth_forall_closedBall_subset {M} [MetricSpace M] [ChartedSpace H M]\n    [IsManifold I âˆž M] [SigmaCompactSpace M] {K : Î¹ â†’ Set M} {U : Î¹ â†’ Set M}\n    (hK : âˆ€ i, IsClosed (K i)) (hU : âˆ€ i, IsOpen (U i)) (hKU : âˆ€ i, K i âŠ† U i)\n    (hfin : LocallyFinite K) :\n    âˆƒ Î´ : C^âˆžâŸ®I, M; ð“˜(â„, â„), â„âŸ¯,\n      (âˆ€ x, 0 < Î´ x) âˆ§ âˆ€ (i), âˆ€ x âˆˆ K i, Metric.closedBall x (Î´ x) âŠ† U i := by\n  rcases Emetric.exists_smooth_forall_closedBall_subset I hK hU hKU hfin with âŸ¨Î´, hÎ´0, hÎ´âŸ©\n  refine âŸ¨Î´, hÎ´0, fun i x hx => ?_âŸ©\n  rw [â† Metric.emetric_closedBall (hÎ´0 _).le]\n  exact hÎ´ i x hx\n\n"}
{"name":"IsOpen.exists_msmooth_support_eq_aux","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"E : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nH : Type uH\ninstâœÂ¹ : TopologicalSpace H\nI : ModelWithCorners Real E H\ninstâœ : FiniteDimensional Real E\ns : Set H\nhs : IsOpen s\nâŠ¢ Exists fun f => And (Eq (Function.support f) s) (And (ContMDiff I (modelWithCornersSelf Real Real) (â†‘Top.top) f) (HasSubset.Subset (Set.range f) (Set.Icc 0 1)))","decl":"lemma IsOpen.exists_msmooth_support_eq_aux {s : Set H} (hs : IsOpen s) :\n    âˆƒ f : H â†’ â„, f.support = s âˆ§ ContMDiff I ð“˜(â„) âˆž f âˆ§ Set.range f âŠ† Set.Icc 0 1 := by\n  have h's : IsOpen (I.symm â»Â¹' s) := I.continuous_symm.isOpen_preimage _ hs\n  rcases h's.exists_smooth_support_eq with âŸ¨f, f_supp, f_diff, f_rangeâŸ©\n  refine âŸ¨f âˆ˜ I, ?_, ?_, ?_âŸ©\n  Â· rw [support_comp_eq_preimage, f_supp, â† preimage_comp]\n    simp only [ModelWithCorners.symm_comp_self, preimage_id_eq, id_eq]\n  Â· exact f_diff.comp_contMDiff contMDiff_model\n  Â· exact Subset.trans (range_comp_subset_range _ _) f_range\n\n"}
{"name":"IsOpen.exists_msmooth_support_eq","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"E : Type uE\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Real E\nH : Type uH\ninstâœâ¶ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâµ : TopologicalSpace M\ninstâœâ´ : ChartedSpace H M\ninstâœÂ³ : FiniteDimensional Real E\ninstâœÂ² : IsManifold I (â†‘Top.top) M\ninstâœÂ¹ : SigmaCompactSpace M\ninstâœ : T2Space M\ns : Set M\nhs : IsOpen s\nâŠ¢ Exists fun f => And (Eq (Function.support f) s) (And (ContMDiff I (modelWithCornersSelf Real Real) (â†‘Top.top) f) (âˆ€ (x : M), LE.le 0 (f x)))","decl":"/-- Given an open set in a finite-dimensional real manifold, there exists a nonnegative smooth\nfunction with support equal to `s`. -/\ntheorem IsOpen.exists_msmooth_support_eq {s : Set M} (hs : IsOpen s) :\n    âˆƒ f : M â†’ â„, f.support = s âˆ§ ContMDiff I ð“˜(â„) âˆž f âˆ§ âˆ€ x, 0 â‰¤ f x := by\n  rcases SmoothPartitionOfUnity.exists_isSubordinate_chartAt_source I M with âŸ¨f, hfâŸ©\n  have A : âˆ€ (c : M), âˆƒ g : H â†’ â„,\n      g.support = (chartAt H c).target âˆ© (chartAt H c).symm â»Â¹' s âˆ§\n      ContMDiff I ð“˜(â„) âˆž g âˆ§ Set.range g âŠ† Set.Icc 0 1 := by\n    intro i\n    apply IsOpen.exists_msmooth_support_eq_aux\n    exact PartialHomeomorph.isOpen_inter_preimage_symm _ hs\n  choose g g_supp g_diff hg using A\n  have h'g : âˆ€ c x, 0 â‰¤ g c x := fun c x â†¦ (hg c (mem_range_self (f := g c) x)).1\n  have h''g : âˆ€ c x, 0 â‰¤ f c x * g c (chartAt H c x) :=\n    fun c x â†¦ mul_nonneg (f.nonneg c x) (h'g c _)\n  refine âŸ¨fun x â†¦ âˆ‘á¶  c, f c x * g c (chartAt H c x), ?_, ?_, ?_âŸ©\n  Â· refine support_eq_iff.2 âŸ¨fun x hx â†¦ ?_, fun x hx â†¦ ?_âŸ©\n    Â· apply ne_of_gt\n      have B : âˆƒ c, 0 < f c x * g c (chartAt H c x) := by\n        obtain âŸ¨c, hcâŸ© : âˆƒ c, 0 < f c x := f.exists_pos_of_mem (mem_univ x)\n        refine âŸ¨c, mul_pos hc ?_âŸ©\n        apply lt_of_le_of_ne (h'g _ _) (Ne.symm _)\n        rw [â† mem_support, g_supp, â† mem_preimage, preimage_inter]\n        have Hx : x âˆˆ tsupport (f c) := subset_tsupport _ (ne_of_gt hc)\n        simp [(chartAt H c).left_inv (hf c Hx), hx, (chartAt H c).map_source (hf c Hx)]\n      apply finsum_pos' (fun c â†¦ h''g c x) B\n      apply (f.locallyFinite.point_finite x).subset\n      apply compl_subset_compl.2\n      rintro c (hc : f c x = 0)\n      simpa only [mul_eq_zero] using Or.inl hc\n    Â· apply finsum_eq_zero_of_forall_eq_zero\n      intro c\n      by_cases Hx : x âˆˆ tsupport (f c)\n      Â· suffices g c (chartAt H c x) = 0 by simp only [this, mul_zero]\n        rw [â† nmem_support, g_supp, â† mem_preimage, preimage_inter]\n        contrapose! hx\n        simp only [mem_inter_iff, mem_preimage, (chartAt H c).left_inv (hf c Hx)] at hx\n        exact hx.2\n      Â· have : x âˆ‰ support (f c) := by contrapose! Hx; exact subset_tsupport _ Hx\n        rw [nmem_support] at this\n        simp [this]\n  Â· apply SmoothPartitionOfUnity.contMDiff_finsum_smul\n    intro c x hx\n    apply (g_diff c (chartAt H c x)).comp\n    exact contMDiffAt_of_mem_maximalAtlas (IsManifold.chart_mem_maximalAtlas _)\n      (hf c hx)\n  Â· intro x\n    apply finsum_nonneg (fun c â†¦ h''g c x)\n\n"}
{"name":"exists_msmooth_support_eq_eq_one_iff","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"E : Type uE\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Real E\nH : Type uH\ninstâœâ¶ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâµ : TopologicalSpace M\ninstâœâ´ : ChartedSpace H M\ninstâœÂ³ : FiniteDimensional Real E\ninstâœÂ² : IsManifold I (â†‘Top.top) M\ninstâœÂ¹ : SigmaCompactSpace M\ninstâœ : T2Space M\ns t : Set M\nhs : IsOpen s\nht : IsClosed t\nh : HasSubset.Subset t s\nâŠ¢ Exists fun f => And (ContMDiff I (modelWithCornersSelf Real Real) (â†‘Top.top) f) (And (HasSubset.Subset (Set.range f) (Set.Icc 0 1)) (And (Eq (Function.support f) s) (âˆ€ (x : M), Iff (Membership.mem t x) (Eq (f x) 1))))","decl":"/-- Given an open set `s` containing a closed set `t` in a finite-dimensional real manifold, there\nexists a smooth function with support equal to `s`, taking values in `[0,1]`, and equal to `1`\nexactly on `t`. -/\ntheorem exists_msmooth_support_eq_eq_one_iff\n    {s t : Set M} (hs : IsOpen s) (ht : IsClosed t) (h : t âŠ† s) :\n    âˆƒ f : M â†’ â„, ContMDiff I ð“˜(â„) âˆž f âˆ§ range f âŠ† Icc 0 1 âˆ§ support f = s\n      âˆ§ (âˆ€ x, x âˆˆ t â†” f x = 1) := by\n  /- Take `f` with support equal to `s`, and `g` with support equal to `tá¶œ`. Then `f / (f + g)`\n  satisfies the conclusion of the theorem. -/\n  rcases hs.exists_msmooth_support_eq I with âŸ¨f, f_supp, f_diff, f_posâŸ©\n  rcases ht.isOpen_compl.exists_msmooth_support_eq I with âŸ¨g, g_supp, g_diff, g_posâŸ©\n  have A : âˆ€ x, 0 < f x + g x := by\n    intro x\n    by_cases xs : x âˆˆ support f\n    Â· have : 0 < f x := lt_of_le_of_ne (f_pos x) (Ne.symm xs)\n      linarith [g_pos x]\n    Â· have : 0 < g x := by\n        classical\n        apply lt_of_le_of_ne (g_pos x) (Ne.symm ?_)\n        rw [â† mem_support, g_supp]\n        contrapose! xs\n        simp? at xs says simp only [mem_compl_iff, Decidable.not_not] at xs\n        exact h.trans f_supp.symm.subset xs\n      linarith [f_pos x]\n  refine âŸ¨fun x â†¦ f x / (f x + g x), ?_, ?_, ?_, ?_âŸ©\n  -- show that `f / (f + g)` is smooth\n  Â· exact f_diff.divâ‚€ (f_diff.add g_diff) (fun x â†¦ ne_of_gt (A x))\n  -- show that the range is included in `[0, 1]`\n  Â· refine range_subset_iff.2 (fun x â†¦ âŸ¨div_nonneg (f_pos x) (A x).le, ?_âŸ©)\n    apply div_le_one_of_leâ‚€ _ (A x).le\n    simpa only [le_add_iff_nonneg_right] using g_pos x\n  -- show that the support is `s`\n  Â· have B : support (fun x â†¦ f x + g x) = univ := eq_univ_of_forall (fun x â†¦ (A x).ne')\n    simp only [support_div, f_supp, B, inter_univ]\n  -- show that the function equals one exactly on `t`\n  Â· intro x\n    simp [div_eq_one_iff_eq (A x).ne', self_eq_add_right, â† nmem_support, g_supp]\n\n"}
{"name":"exists_msmooth_zero_iff_one_iff_of_isClosed","module":"Mathlib.Geometry.Manifold.PartitionOfUnity","initialProofState":"E : Type uE\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Real E\nH : Type uH\ninstâœâ¶ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type uM\ninstâœâµ : TopologicalSpace M\ninstâœâ´ : ChartedSpace H M\ninstâœÂ³ : FiniteDimensional Real E\ninstâœÂ² : IsManifold I (â†‘Top.top) M\ninstâœÂ¹ : SigmaCompactSpace M\ninstâœ : T2Space M\ns t : Set M\nhs : IsClosed s\nht : IsClosed t\nhd : Disjoint s t\nâŠ¢ Exists fun f => And (ContMDiff I (modelWithCornersSelf Real Real) (â†‘Top.top) f) (And (HasSubset.Subset (Set.range f) (Set.Icc 0 1)) (And (âˆ€ (x : M), Iff (Membership.mem s x) (Eq (f x) 0)) (âˆ€ (x : M), Iff (Membership.mem t x) (Eq (f x) 1))))","decl":"/-- Given two disjoint closed sets `s, t` in a Hausdorff Ïƒ-compact finite dimensional manifold,\nthere exists an infinitely smooth function that is equal to `0` exactly on `s` and to `1`\nexactly on `t`. See also `exists_smooth_zero_one_of_isClosed` for a slightly weaker version. -/\ntheorem exists_msmooth_zero_iff_one_iff_of_isClosed {s t : Set M}\n    (hs : IsClosed s) (ht : IsClosed t) (hd : Disjoint s t) :\n    âˆƒ f : M â†’ â„, ContMDiff I ð“˜(â„) âˆž f âˆ§ range f âŠ† Icc 0 1 âˆ§ (âˆ€ x, x âˆˆ s â†” f x = 0)\n      âˆ§ (âˆ€ x, x âˆˆ t â†” f x = 1) := by\n  rcases exists_msmooth_support_eq_eq_one_iff I hs.isOpen_compl ht hd.subset_compl_left with\n    âŸ¨f, f_diff, f_range, fs, ftâŸ©\n  refine âŸ¨f, f_diff, f_range, ?_, ftâŸ©\n  simp [â† nmem_support, fs]\n"}
