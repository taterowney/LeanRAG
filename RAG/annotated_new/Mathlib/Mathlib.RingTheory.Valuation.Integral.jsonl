{"name":"Valuation.Integers.mem_of_integral","module":"Mathlib.RingTheory.Valuation.Integral","initialProofState":"R : Type u\nΓ₀ : Type v\ninst✝³ : CommRing R\ninst✝² : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation R Γ₀\nO : Type w\ninst✝¹ : CommRing O\ninst✝ : Algebra O R\nhv : v.Integers O\nx : R\nhx : IsIntegral O x\n⊢ Membership.mem v.integer x","decl":"theorem mem_of_integral {x : R} (hx : IsIntegral O x) : x ∈ v.integer :=\n  let ⟨p, hpm, hpx⟩ := hx\n  le_of_not_lt fun hvx : 1 < v x => by\n    rw [hpm.as_sum, eval₂_add, eval₂_pow, eval₂_X, eval₂_finset_sum, add_eq_zero_iff_eq_neg] at hpx\n    replace hpx := congr_arg v hpx; refine ne_of_gt ?_ hpx\n    rw [v.map_neg, v.map_pow]\n    refine v.map_sum_lt' (zero_lt_one.trans_le (one_le_pow_of_one_le' hvx.le _)) fun i hi => ?_\n    rw [eval₂_mul, eval₂_pow, eval₂_C, eval₂_X, v.map_mul, v.map_pow, ←\n      one_mul (v x ^ p.natDegree)]\n    cases' (hv.2 <| p.coeff i).lt_or_eq with hvpi hvpi\n    · exact mul_lt_mul'' hvpi (pow_lt_pow_right₀ hvx <| Finset.mem_range.1 hi) zero_le' zero_le'\n    · rw [hvpi, one_mul, one_mul]; exact pow_lt_pow_right₀ hvx (Finset.mem_range.1 hi)\n\n"}
{"name":"Valuation.Integers.integralClosure","module":"Mathlib.RingTheory.Valuation.Integral","initialProofState":"R : Type u\nΓ₀ : Type v\ninst✝³ : CommRing R\ninst✝² : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation R Γ₀\nO : Type w\ninst✝¹ : CommRing O\ninst✝ : Algebra O R\nhv : v.Integers O\n⊢ Eq (integralClosure O R) Bot.bot","decl":"protected theorem integralClosure : integralClosure O R = ⊥ :=\n  bot_unique fun _ hr =>\n    let ⟨x, hx⟩ := hv.3 (hv.mem_of_integral hr)\n    Algebra.mem_bot.2 ⟨x, hx⟩\n\n"}
{"name":"Valuation.Integers.integrallyClosed","module":"Mathlib.RingTheory.Valuation.Integral","initialProofState":"K : Type u\nΓ₀ : Type v\ninst✝⁴ : Field K\ninst✝³ : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation K Γ₀\nO : Type w\ninst✝² : CommRing O\ninst✝¹ : Algebra O K\ninst✝ : IsFractionRing O K\nhv : v.Integers O\n⊢ IsIntegrallyClosed O","decl":"include hv in\ntheorem integrallyClosed : IsIntegrallyClosed O :=\n  (IsIntegrallyClosed.integralClosure_eq_bot_iff K).mp (Valuation.Integers.integralClosure hv)\n\n"}
