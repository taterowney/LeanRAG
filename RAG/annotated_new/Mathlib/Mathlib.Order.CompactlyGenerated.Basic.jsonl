{"name":"CompleteLattice.isCompactElement_iff","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nk : α\n⊢ Iff (CompleteLattice.IsCompactElement k) (∀ (ι : Type u) (s : ι → α), LE.le k (iSup s) → Exists fun t => LE.le k (t.sup s))","decl":"theorem isCompactElement_iff.{u} {α : Type u} [CompleteLattice α] (k : α) :\n    CompleteLattice.IsCompactElement k ↔\n      ∀ (ι : Type u) (s : ι → α), k ≤ iSup s → ∃ t : Finset ι, k ≤ t.sup s := by\n  classical\n    constructor\n    · intro H ι s hs\n      obtain ⟨t, ht, ht'⟩ := H (Set.range s) hs\n      have : ∀ x : t, ∃ i, s i = x := fun x => ht x.prop\n      choose f hf using this\n      refine ⟨Finset.univ.image f, ht'.trans ?_⟩\n      rw [Finset.sup_le_iff]\n      intro b hb\n      rw [← show s (f ⟨b, hb⟩) = id b from hf _]\n      exact Finset.le_sup (Finset.mem_image_of_mem f <| Finset.mem_univ (Subtype.mk b hb))\n    · intro H s hs\n      obtain ⟨t, ht⟩ :=\n        H s Subtype.val\n          (by\n            delta iSup\n            rwa [Subtype.range_coe])\n      refine ⟨t.image Subtype.val, by simp, ht.trans ?_⟩\n      rw [Finset.sup_le_iff]\n      exact fun x hx => @Finset.le_sup _ _ _ _ _ id _ (Finset.mem_image_of_mem Subtype.val hx)\n\n"}
{"name":"CompleteLattice.isCompactElement_iff_le_of_directed_sSup_le","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\nk : α\n⊢ Iff (CompleteLattice.IsCompactElement k) (∀ (s : Set α), s.Nonempty → DirectedOn (fun x1 x2 => LE.le x1 x2) s → LE.le k (SupSet.sSup s) → Exists fun x => And (Membership.mem s x) (LE.le k x))","decl":"/-- An element `k` is compact if and only if any directed set with `sSup` above\n`k` already got above `k` at some point in the set. -/\ntheorem isCompactElement_iff_le_of_directed_sSup_le (k : α) :\n    IsCompactElement k ↔\n      ∀ s : Set α, s.Nonempty → DirectedOn (· ≤ ·) s → k ≤ sSup s → ∃ x : α, x ∈ s ∧ k ≤ x := by\n  classical\n    constructor\n    · intro hk s hne hdir hsup\n      obtain ⟨t, ht⟩ := hk s hsup\n      -- certainly every element of t is below something in s, since ↑t ⊆ s.\n      have t_below_s : ∀ x ∈ t, ∃ y ∈ s, x ≤ y := fun x hxt => ⟨x, ht.left hxt, le_rfl⟩\n      obtain ⟨x, ⟨hxs, hsupx⟩⟩ := Finset.sup_le_of_le_directed s hne hdir t t_below_s\n      exact ⟨x, ⟨hxs, le_trans ht.right hsupx⟩⟩\n    · intro hk s hsup\n      -- Consider the set of finite joins of elements of the (plain) set s.\n      let S : Set α := { x | ∃ t : Finset α, ↑t ⊆ s ∧ x = t.sup id }\n      -- S is directed, nonempty, and still has sup above k.\n      have dir_US : DirectedOn (· ≤ ·) S := by\n        rintro x ⟨c, hc⟩ y ⟨d, hd⟩\n        use x ⊔ y\n        constructor\n        · use c ∪ d\n          constructor\n          · simp only [hc.left, hd.left, Set.union_subset_iff, Finset.coe_union, and_self_iff]\n          · simp only [hc.right, hd.right, Finset.sup_union]\n        simp only [and_self_iff, le_sup_left, le_sup_right]\n      have sup_S : sSup s ≤ sSup S := by\n        apply sSup_le_sSup\n        intro x hx\n        use {x}\n        simpa only [and_true, id, Finset.coe_singleton, eq_self_iff_true,\n          Finset.sup_singleton, Set.singleton_subset_iff]\n      have Sne : S.Nonempty := by\n        suffices ⊥ ∈ S from Set.nonempty_of_mem this\n        use ∅\n        simp only [Set.empty_subset, Finset.coe_empty, Finset.sup_empty, eq_self_iff_true,\n          and_self_iff]\n      -- Now apply the defn of compact and finish.\n      obtain ⟨j, ⟨hjS, hjk⟩⟩ := hk S Sne dir_US (le_trans hsup sup_S)\n      obtain ⟨t, ⟨htS, htsup⟩⟩ := hjS\n      use t\n      exact ⟨htS, by rwa [← htsup]⟩\n\n"}
{"name":"CompleteLattice.IsCompactElement.exists_finset_of_le_iSup","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\nk : α\nhk : CompleteLattice.IsCompactElement k\nι : Type u_3\nf : ι → α\nh : LE.le k (iSup fun i => f i)\n⊢ Exists fun s => LE.le k (iSup fun i => iSup fun h => f i)","decl":"theorem IsCompactElement.exists_finset_of_le_iSup {k : α} (hk : IsCompactElement k) {ι : Type*}\n    (f : ι → α) (h : k ≤ ⨆ i, f i) : ∃ s : Finset ι, k ≤ ⨆ i ∈ s, f i := by\n  classical\n    let g : Finset ι → α := fun s => ⨆ i ∈ s, f i\n    have h1 : DirectedOn (· ≤ ·) (Set.range g) := by\n      rintro - ⟨s, rfl⟩ - ⟨t, rfl⟩\n      exact\n        ⟨g (s ∪ t), ⟨s ∪ t, rfl⟩, iSup_le_iSup_of_subset Finset.subset_union_left,\n          iSup_le_iSup_of_subset Finset.subset_union_right⟩\n    have h2 : k ≤ sSup (Set.range g) :=\n      h.trans\n        (iSup_le fun i =>\n          le_sSup_of_le ⟨{i}, rfl⟩\n            (le_iSup_of_le i (le_iSup_of_le (Finset.mem_singleton_self i) le_rfl)))\n    obtain ⟨-, ⟨s, rfl⟩, hs⟩ :=\n      (isCompactElement_iff_le_of_directed_sSup_le α k).mp hk (Set.range g) (Set.range_nonempty g)\n        h1 h2\n    exact ⟨s, hs⟩\n\n"}
{"name":"CompleteLattice.IsCompactElement.directed_sSup_lt_of_lt","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_3\ninst✝ : CompleteLattice α\nk : α\nhk : CompleteLattice.IsCompactElement k\ns : Set α\nhemp : s.Nonempty\nhdir : DirectedOn (fun x1 x2 => LE.le x1 x2) s\nhbelow : ∀ (x : α), Membership.mem s x → LT.lt x k\n⊢ LT.lt (SupSet.sSup s) k","decl":"/-- A compact element `k` has the property that any directed set lying strictly below `k` has\nits `sSup` strictly below `k`. -/\ntheorem IsCompactElement.directed_sSup_lt_of_lt {α : Type*} [CompleteLattice α] {k : α}\n    (hk : IsCompactElement k) {s : Set α} (hemp : s.Nonempty) (hdir : DirectedOn (· ≤ ·) s)\n    (hbelow : ∀ x ∈ s, x < k) : sSup s < k := by\n  rw [isCompactElement_iff_le_of_directed_sSup_le] at hk\n  by_contra h\n  have sSup' : sSup s ≤ k := sSup_le s k fun s hs => (hbelow s hs).le\n  replace sSup : sSup s = k := eq_iff_le_not_lt.mpr ⟨sSup', h⟩\n  obtain ⟨x, hxs, hkx⟩ := hk s hemp hdir sSup.symm.le\n  obtain hxk := hbelow x hxs\n  exact hxk.ne (hxk.le.antisymm hkx)\n\n"}
{"name":"CompleteLattice.isCompactElement_finsetSup","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CompleteLattice α\nf : β → α\ns : Finset β\nh : ∀ (x : β), Membership.mem s x → CompleteLattice.IsCompactElement (f x)\n⊢ CompleteLattice.IsCompactElement (s.sup f)","decl":"theorem isCompactElement_finsetSup {α β : Type*} [CompleteLattice α] {f : β → α} (s : Finset β)\n    (h : ∀ x ∈ s, IsCompactElement (f x)) : IsCompactElement (s.sup f) := by\n  classical\n    rw [isCompactElement_iff_le_of_directed_sSup_le]\n    intro d hemp hdir hsup\n    rw [← Function.id_comp f]\n    rw [← Finset.sup_image]\n    apply Finset.sup_le_of_le_directed d hemp hdir\n    rintro x hx\n    obtain ⟨p, ⟨hps, rfl⟩⟩ := Finset.mem_image.mp hx\n    specialize h p hps\n    rw [isCompactElement_iff_le_of_directed_sSup_le] at h\n    specialize h d hemp hdir (le_trans (Finset.le_sup hps) hsup)\n    simpa only [exists_prop]\n\n"}
{"name":"CompleteLattice.WellFoundedGT.isSupFiniteCompact","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : WellFoundedGT α\n⊢ CompleteLattice.IsSupFiniteCompact α","decl":"theorem WellFoundedGT.isSupFiniteCompact [WellFoundedGT α] :\n    IsSupFiniteCompact α := fun s => by\n  let S := { x | ∃ t : Finset α, ↑t ⊆ s ∧ t.sup id = x }\n  obtain ⟨m, ⟨t, ⟨ht₁, rfl⟩⟩, hm⟩ := wellFounded_gt.has_min S ⟨⊥, ∅, by simp⟩\n  refine ⟨t, ht₁, (sSup_le _ _ fun y hy => ?_).antisymm ?_⟩\n  · classical\n    rw [eq_of_le_of_not_lt (Finset.sup_mono (t.subset_insert y))\n        (hm _ ⟨insert y t, by simp [Set.insert_subset_iff, hy, ht₁]⟩)]\n    simp\n  · rw [Finset.sup_id_eq_sSup]\n    exact sSup_le_sSup ht₁\n\n"}
{"name":"CompleteLattice.IsSupFiniteCompact.isSupClosedCompact","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\nh : CompleteLattice.IsSupFiniteCompact α\n⊢ CompleteLattice.IsSupClosedCompact α","decl":"theorem IsSupFiniteCompact.isSupClosedCompact (h : IsSupFiniteCompact α) :\n    IsSupClosedCompact α := by\n  intro s hne hsc; obtain ⟨t, ht₁, ht₂⟩ := h s; clear h\n  rcases t.eq_empty_or_nonempty with h | h\n  · subst h\n    rw [Finset.sup_empty] at ht₂\n    rw [ht₂]\n    simp [eq_singleton_bot_of_sSup_eq_bot_of_nonempty ht₂ hne]\n  · rw [ht₂]\n    exact hsc.finsetSup_mem h ht₁\n\n"}
{"name":"CompleteLattice.IsSupClosedCompact.wellFoundedGT","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\nh : CompleteLattice.IsSupClosedCompact α\n⊢ WellFoundedGT α","decl":"theorem IsSupClosedCompact.wellFoundedGT (h : IsSupClosedCompact α) :\n    WellFoundedGT α where\n  wf := by\n    refine RelEmbedding.wellFounded_iff_no_descending_seq.mpr ⟨fun a => ?_⟩\n    suffices sSup (Set.range a) ∈ Set.range a by\n      obtain ⟨n, hn⟩ := Set.mem_range.mp this\n      have h' : sSup (Set.range a) < a (n + 1) := by\n        change _ > _\n        simp [← hn, a.map_rel_iff]\n      apply lt_irrefl (a (n + 1))\n      apply lt_of_le_of_lt _ h'\n      apply le_sSup\n      apply Set.mem_range_self\n    apply h (Set.range a)\n    · use a 37\n      apply Set.mem_range_self\n    · rintro x ⟨m, hm⟩ y ⟨n, hn⟩\n      use m ⊔ n\n      rw [← hm, ← hn]\n      apply RelHomClass.map_sup a\n\n"}
{"name":"CompleteLattice.isSupFiniteCompact_iff_all_elements_compact","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\n⊢ Iff (CompleteLattice.IsSupFiniteCompact α) (∀ (k : α), CompleteLattice.IsCompactElement k)","decl":"theorem isSupFiniteCompact_iff_all_elements_compact :\n    IsSupFiniteCompact α ↔ ∀ k : α, IsCompactElement k := by\n  refine ⟨fun h k s hs => ?_, fun h s => ?_⟩\n  · obtain ⟨t, ⟨hts, htsup⟩⟩ := h s\n    use t, hts\n    rwa [← htsup]\n  · obtain ⟨t, ⟨hts, htsup⟩⟩ := h (sSup s) s (by rfl)\n    have : sSup s = t.sup id := by\n      suffices t.sup id ≤ sSup s by apply le_antisymm <;> assumption\n      simp only [id, Finset.sup_le_iff]\n      intro x hx\n      exact le_sSup _ _ (hts hx)\n    exact ⟨t, hts, this⟩\n\n"}
{"name":"CompleteLattice.wellFoundedGT_characterisations","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\n⊢ (List.cons (WellFoundedGT α) (List.cons (CompleteLattice.IsSupFiniteCompact α) (List.cons (CompleteLattice.IsSupClosedCompact α) (List.cons (∀ (k : α), CompleteLattice.IsCompactElement k) List.nil)))).TFAE","decl":"open List in\ntheorem wellFoundedGT_characterisations : List.TFAE\n    [WellFoundedGT α, IsSupFiniteCompact α, IsSupClosedCompact α, ∀ k : α, IsCompactElement k] := by\n  tfae_have 1 → 2 := @WellFoundedGT.isSupFiniteCompact α _\n  tfae_have 2 → 3 := IsSupFiniteCompact.isSupClosedCompact α\n  tfae_have 3 → 1 := IsSupClosedCompact.wellFoundedGT α\n  tfae_have 2 ↔ 4 := isSupFiniteCompact_iff_all_elements_compact α\n  tfae_finish\n\n"}
{"name":"CompleteLattice.wellFoundedGT_iff_isSupFiniteCompact","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\n⊢ Iff (WellFoundedGT α) (CompleteLattice.IsSupFiniteCompact α)","decl":"theorem wellFoundedGT_iff_isSupFiniteCompact :\n    WellFoundedGT α ↔ IsSupFiniteCompact α :=\n  (wellFoundedGT_characterisations α).out 0 1\n\n"}
{"name":"CompleteLattice.isSupFiniteCompact_iff_isSupClosedCompact","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\n⊢ Iff (CompleteLattice.IsSupFiniteCompact α) (CompleteLattice.IsSupClosedCompact α)","decl":"theorem isSupFiniteCompact_iff_isSupClosedCompact : IsSupFiniteCompact α ↔ IsSupClosedCompact α :=\n  (wellFoundedGT_characterisations α).out 1 2\n\n"}
{"name":"CompleteLattice.isSupClosedCompact_iff_wellFoundedGT","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\n⊢ Iff (CompleteLattice.IsSupClosedCompact α) (WellFoundedGT α)","decl":"theorem isSupClosedCompact_iff_wellFoundedGT :\n    IsSupClosedCompact α ↔ WellFoundedGT α :=\n  (wellFoundedGT_characterisations α).out 2 0\n\n"}
{"name":"CompleteLattice.IsSupFiniteCompact.wellFoundedGT","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\na✝ : CompleteLattice.IsSupFiniteCompact α\n⊢ WellFoundedGT α","decl":"alias ⟨_, IsSupFiniteCompact.wellFoundedGT⟩ := wellFoundedGT_iff_isSupFiniteCompact\n\n"}
{"name":"CompleteLattice.IsSupClosedCompact.isSupFiniteCompact","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\na✝ : CompleteLattice.IsSupClosedCompact α\n⊢ CompleteLattice.IsSupFiniteCompact α","decl":"alias ⟨_, IsSupClosedCompact.isSupFiniteCompact⟩ := isSupFiniteCompact_iff_isSupClosedCompact\n\n"}
{"name":"CompleteLattice.WellFoundedGT.isSupClosedCompact","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\na✝ : WellFoundedGT α\n⊢ CompleteLattice.IsSupClosedCompact α","decl":"alias ⟨_, WellFoundedGT.isSupClosedCompact⟩ := isSupClosedCompact_iff_wellFoundedGT\n\n"}
{"name":"WellFoundedGT.finite_of_sSupIndep","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : WellFoundedGT α\ns : Set α\nhs : sSupIndep s\n⊢ s.Finite","decl":"theorem WellFoundedGT.finite_of_sSupIndep [WellFoundedGT α] {s : Set α}\n    (hs : sSupIndep s) : s.Finite := by\n  classical\n    refine Set.not_infinite.mp fun contra => ?_\n    obtain ⟨t, ht₁, ht₂⟩ := CompleteLattice.WellFoundedGT.isSupFiniteCompact α s\n    replace contra : ∃ x : α, x ∈ s ∧ x ≠ ⊥ ∧ x ∉ t := by\n      have : (s \\ (insert ⊥ t : Finset α)).Infinite := contra.diff (Finset.finite_toSet _)\n      obtain ⟨x, hx₁, hx₂⟩ := this.nonempty\n      exact ⟨x, hx₁, by simpa [not_or] using hx₂⟩\n    obtain ⟨x, hx₀, hx₁, hx₂⟩ := contra\n    replace hs : x ⊓ sSup s = ⊥ := by\n      have := hs.mono (by simp [ht₁, hx₀, -Set.union_singleton] : ↑t ∪ {x} ≤ s) (by simp : x ∈ _)\n      simpa [Disjoint, hx₂, ← t.sup_id_eq_sSup, ← ht₂] using this.eq_bot\n    apply hx₁\n    rw [← hs, eq_comm, inf_eq_left]\n    exact le_sSup hx₀\n\n"}
{"name":"CompleteLattice.WellFoundedGT.finite_of_setIndependent","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : WellFoundedGT α\ns : Set α\nhs : sSupIndep s\n⊢ s.Finite","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.WellFoundedGT.finite_of_setIndependent := WellFoundedGT.finite_of_sSupIndep\n\n"}
{"name":"WellFoundedGT.finite_ne_bot_of_iSupIndep","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : WellFoundedGT α\nι : Type u_3\nt : ι → α\nht : iSupIndep t\n⊢ (setOf fun i => Ne (t i) Bot.bot).Finite","decl":"theorem WellFoundedGT.finite_ne_bot_of_iSupIndep [WellFoundedGT α]\n    {ι : Type*} {t : ι → α} (ht : iSupIndep t) : Set.Finite {i | t i ≠ ⊥} := by\n  refine Finite.of_finite_image (Finite.subset ?_ (image_subset_range t _)) ht.injOn\n  exact WellFoundedGT.finite_of_sSupIndep ht.sSupIndep_range\n\n"}
{"name":"CompleteLattice.WellFoundedGT.finite_ne_bot_of_independent","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : WellFoundedGT α\nι : Type u_3\nt : ι → α\nht : iSupIndep t\n⊢ (setOf fun i => Ne (t i) Bot.bot).Finite","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.WellFoundedGT.finite_ne_bot_of_independent :=\n  WellFoundedGT.finite_ne_bot_of_iSupIndep\n\n"}
{"name":"WellFoundedGT.finite_of_iSupIndep","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : WellFoundedGT α\nι : Type u_3\nt : ι → α\nht : iSupIndep t\nh_ne_bot : ∀ (i : ι), Ne (t i) Bot.bot\n⊢ Finite ι","decl":"theorem WellFoundedGT.finite_of_iSupIndep [WellFoundedGT α] {ι : Type*}\n    {t : ι → α} (ht : iSupIndep t) (h_ne_bot : ∀ i, t i ≠ ⊥) : Finite ι :=\n  haveI := (WellFoundedGT.finite_of_sSupIndep ht.sSupIndep_range).to_subtype\n  Finite.of_injective_finite_range (ht.injective h_ne_bot)\n\n"}
{"name":"CompleteLattice.WellFoundedGT.finite_of_independent","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : WellFoundedGT α\nι : Type u_3\nt : ι → α\nht : iSupIndep t\nh_ne_bot : ∀ (i : ι), Ne (t i) Bot.bot\n⊢ Finite ι","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.WellFoundedGT.finite_of_independent := WellFoundedGT.finite_of_iSupIndep\n\n"}
{"name":"WellFoundedLT.finite_of_sSupIndep","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : WellFoundedLT α\ns : Set α\nhs : sSupIndep s\n⊢ s.Finite","decl":"theorem WellFoundedLT.finite_of_sSupIndep [WellFoundedLT α] {s : Set α}\n    (hs : sSupIndep s) : s.Finite := by\n  by_contra inf\n  let e := (Infinite.diff inf <| finite_singleton ⊥).to_subtype.natEmbedding\n  let a n := ⨆ i ≥ n, (e i).1\n  have sup_le n : (e n).1 ⊔ a (n + 1) ≤ a n := sup_le_iff.mpr ⟨le_iSup₂_of_le n le_rfl le_rfl,\n    iSup₂_le fun i hi ↦ le_iSup₂_of_le i (n.le_succ.trans hi) le_rfl⟩\n  have lt n : a (n + 1) < a n := (Disjoint.right_lt_sup_of_left_ne_bot\n    ((hs (e n).2.1).mono_right <| iSup₂_le fun i hi ↦ le_sSup ?_) (e n).2.2).trans_le (sup_le n)\n  · exact (RelEmbedding.natGT a lt).not_wellFounded_of_decreasing_seq wellFounded_lt\n  exact ⟨(e i).2.1, fun h ↦ n.lt_succ_self.not_le <| hi.trans_eq <| e.2 <| Subtype.val_injective h⟩\n\n"}
{"name":"CompleteLattice.WellFoundedLT.finite_of_setIndependent","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : WellFoundedLT α\ns : Set α\nhs : sSupIndep s\n⊢ s.Finite","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.WellFoundedLT.finite_of_setIndependent := WellFoundedLT.finite_of_sSupIndep\n\n"}
{"name":"WellFoundedLT.finite_ne_bot_of_iSupIndep","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : WellFoundedLT α\nι : Type u_3\nt : ι → α\nht : iSupIndep t\n⊢ (setOf fun i => Ne (t i) Bot.bot).Finite","decl":"theorem WellFoundedLT.finite_ne_bot_of_iSupIndep [WellFoundedLT α]\n    {ι : Type*} {t : ι → α} (ht : iSupIndep t) : Set.Finite {i | t i ≠ ⊥} := by\n  refine Finite.of_finite_image (Finite.subset ?_ (image_subset_range t _)) ht.injOn\n  exact WellFoundedLT.finite_of_sSupIndep ht.sSupIndep_range\n\n"}
{"name":"CompleteLattice.WellFoundedLT.finite_ne_bot_of_independent","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : WellFoundedLT α\nι : Type u_3\nt : ι → α\nht : iSupIndep t\n⊢ (setOf fun i => Ne (t i) Bot.bot).Finite","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.WellFoundedLT.finite_ne_bot_of_independent :=\n  WellFoundedLT.finite_ne_bot_of_iSupIndep\n\n"}
{"name":"WellFoundedLT.finite_of_iSupIndep","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : WellFoundedLT α\nι : Type u_3\nt : ι → α\nht : iSupIndep t\nh_ne_bot : ∀ (i : ι), Ne (t i) Bot.bot\n⊢ Finite ι","decl":"theorem WellFoundedLT.finite_of_iSupIndep [WellFoundedLT α] {ι : Type*}\n    {t : ι → α} (ht : iSupIndep t) (h_ne_bot : ∀ i, t i ≠ ⊥) : Finite ι :=\n  haveI := (WellFoundedLT.finite_of_sSupIndep ht.sSupIndep_range).to_subtype\n  Finite.of_injective_finite_range (ht.injective h_ne_bot)\n\n"}
{"name":"CompleteLattice.WellFoundedLT.finite_of_independent","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : WellFoundedLT α\nι : Type u_3\nt : ι → α\nht : iSupIndep t\nh_ne_bot : ∀ (i : ι), Ne (t i) Bot.bot\n⊢ Finite ι","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.WellFoundedLT.finite_of_independent := WellFoundedLT.finite_of_iSupIndep\n\n"}
{"name":"IsCompactlyGenerated.exists_sSup_eq","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_3\ninst✝ : CompleteLattice α\nself : IsCompactlyGenerated α\nx : α\n⊢ Exists fun s => And (∀ (x : α), Membership.mem s x → CompleteLattice.IsCompactElement x) (Eq (SupSet.sSup s) x)","decl":"/-- A complete lattice is said to be compactly generated if any\nelement is the `sSup` of compact elements. -/\nclass IsCompactlyGenerated (α : Type*) [CompleteLattice α] : Prop where\n  /-- In a compactly generated complete lattice,\n    every element is the `sSup` of some set of compact elements. -/\n  exists_sSup_eq : ∀ x : α, ∃ s : Set α, (∀ x ∈ s, CompleteLattice.IsCompactElement x) ∧ sSup s = x\n\n"}
{"name":"sSup_compact_le_eq","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : IsCompactlyGenerated α\nb : α\n⊢ Eq (SupSet.sSup (setOf fun c => And (CompleteLattice.IsCompactElement c) (LE.le c b))) b","decl":"@[simp]\ntheorem sSup_compact_le_eq (b) :\n    sSup { c : α | CompleteLattice.IsCompactElement c ∧ c ≤ b } = b := by\n  rcases IsCompactlyGenerated.exists_sSup_eq b with ⟨s, hs, rfl⟩\n  exact le_antisymm (sSup_le fun c hc => hc.2) (sSup_le_sSup fun c cs => ⟨hs c cs, le_sSup cs⟩)\n\n"}
{"name":"sSup_compact_eq_top","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : IsCompactlyGenerated α\n⊢ Eq (SupSet.sSup (setOf fun a => CompleteLattice.IsCompactElement a)) Top.top","decl":"@[simp]\ntheorem sSup_compact_eq_top : sSup { a : α | CompleteLattice.IsCompactElement a } = ⊤ := by\n  refine Eq.trans (congr rfl (Set.ext fun x => ?_)) (sSup_compact_le_eq ⊤)\n  exact (and_iff_left le_top).symm\n\n"}
{"name":"le_iff_compact_le_imp","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : IsCompactlyGenerated α\na b : α\n⊢ Iff (LE.le a b) (∀ (c : α), CompleteLattice.IsCompactElement c → LE.le c a → LE.le c b)","decl":"theorem le_iff_compact_le_imp {a b : α} :\n    a ≤ b ↔ ∀ c : α, CompleteLattice.IsCompactElement c → c ≤ a → c ≤ b :=\n  ⟨fun ab _ _ ca => le_trans ca ab, fun h => by\n    rw [← sSup_compact_le_eq a, ← sSup_compact_le_eq b]\n    exact sSup_le_sSup fun c hc => ⟨hc.1, h c hc.1 hc.2⟩⟩\n\n"}
{"name":"DirectedOn.inf_sSup_eq","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : IsCompactlyGenerated α\na : α\ns : Set α\nh : DirectedOn (fun x1 x2 => LE.le x1 x2) s\n⊢ Eq (Min.min a (SupSet.sSup s)) (iSup fun b => iSup fun h => Min.min a b)","decl":"/-- This property is sometimes referred to as `α` being upper continuous. -/\ntheorem DirectedOn.inf_sSup_eq (h : DirectedOn (· ≤ ·) s) : a ⊓ sSup s = ⨆ b ∈ s, a ⊓ b :=\n  le_antisymm\n    (by\n      rw [le_iff_compact_le_imp]\n      by_cases hs : s.Nonempty\n      · intro c hc hcinf\n        rw [le_inf_iff] at hcinf\n        rw [CompleteLattice.isCompactElement_iff_le_of_directed_sSup_le] at hc\n        rcases hc s hs h hcinf.2 with ⟨d, ds, cd⟩\n        refine (le_inf hcinf.1 cd).trans (le_trans ?_ (le_iSup₂ d ds))\n        rfl\n      · rw [Set.not_nonempty_iff_eq_empty] at hs\n        simp [hs])\n    iSup_inf_le_inf_sSup\n\n"}
{"name":"DirectedOn.sSup_inf_eq","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : IsCompactlyGenerated α\na : α\ns : Set α\nh : DirectedOn (fun x1 x2 => LE.le x1 x2) s\n⊢ Eq (Min.min (SupSet.sSup s) a) (iSup fun b => iSup fun h => Min.min b a)","decl":"/-- This property is sometimes referred to as `α` being upper continuous. -/\nprotected theorem DirectedOn.sSup_inf_eq (h : DirectedOn (· ≤ ·) s) :\n    sSup s ⊓ a = ⨆ b ∈ s, b ⊓ a := by\n  simp_rw [inf_comm _ a, h.inf_sSup_eq]\n\n"}
{"name":"Directed.inf_iSup_eq","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"ι : Sort u_1\nα : Type u_2\ninst✝¹ : CompleteLattice α\nf : ι → α\ninst✝ : IsCompactlyGenerated α\na : α\nh : Directed (fun x1 x2 => LE.le x1 x2) f\n⊢ Eq (Min.min a (iSup fun i => f i)) (iSup fun i => Min.min a (f i))","decl":"protected theorem Directed.inf_iSup_eq (h : Directed (· ≤ ·) f) :\n    (a ⊓ ⨆ i, f i) = ⨆ i, a ⊓ f i := by\n  rw [iSup, h.directedOn_range.inf_sSup_eq, iSup_range]\n\n"}
{"name":"Directed.iSup_inf_eq","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"ι : Sort u_1\nα : Type u_2\ninst✝¹ : CompleteLattice α\nf : ι → α\ninst✝ : IsCompactlyGenerated α\na : α\nh : Directed (fun x1 x2 => LE.le x1 x2) f\n⊢ Eq (Min.min (iSup fun i => f i) a) (iSup fun i => Min.min (f i) a)","decl":"protected theorem Directed.iSup_inf_eq (h : Directed (· ≤ ·) f) :\n    (⨆ i, f i) ⊓ a = ⨆ i, f i ⊓ a := by\n  rw [iSup, h.directedOn_range.sSup_inf_eq, iSup_range]\n\n"}
{"name":"DirectedOn.disjoint_sSup_right","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : IsCompactlyGenerated α\na : α\ns : Set α\nh : DirectedOn (fun x1 x2 => LE.le x1 x2) s\n⊢ Iff (Disjoint a (SupSet.sSup s)) (∀ ⦃b : α⦄, Membership.mem s b → Disjoint a b)","decl":"protected theorem DirectedOn.disjoint_sSup_right (h : DirectedOn (· ≤ ·) s) :\n    Disjoint a (sSup s) ↔ ∀ ⦃b⦄, b ∈ s → Disjoint a b := by\n  simp_rw [disjoint_iff, h.inf_sSup_eq, iSup_eq_bot]\n\n"}
{"name":"DirectedOn.disjoint_sSup_left","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : IsCompactlyGenerated α\na : α\ns : Set α\nh : DirectedOn (fun x1 x2 => LE.le x1 x2) s\n⊢ Iff (Disjoint (SupSet.sSup s) a) (∀ ⦃b : α⦄, Membership.mem s b → Disjoint b a)","decl":"protected theorem DirectedOn.disjoint_sSup_left (h : DirectedOn (· ≤ ·) s) :\n    Disjoint (sSup s) a ↔ ∀ ⦃b⦄, b ∈ s → Disjoint b a := by\n  simp_rw [disjoint_iff, h.sSup_inf_eq, iSup_eq_bot]\n\n"}
{"name":"Directed.disjoint_iSup_right","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"ι : Sort u_1\nα : Type u_2\ninst✝¹ : CompleteLattice α\nf : ι → α\ninst✝ : IsCompactlyGenerated α\na : α\nh : Directed (fun x1 x2 => LE.le x1 x2) f\n⊢ Iff (Disjoint a (iSup fun i => f i)) (∀ (i : ι), Disjoint a (f i))","decl":"protected theorem Directed.disjoint_iSup_right (h : Directed (· ≤ ·) f) :\n    Disjoint a (⨆ i, f i) ↔ ∀ i, Disjoint a (f i) := by\n  simp_rw [disjoint_iff, h.inf_iSup_eq, iSup_eq_bot]\n\n"}
{"name":"Directed.disjoint_iSup_left","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"ι : Sort u_1\nα : Type u_2\ninst✝¹ : CompleteLattice α\nf : ι → α\ninst✝ : IsCompactlyGenerated α\na : α\nh : Directed (fun x1 x2 => LE.le x1 x2) f\n⊢ Iff (Disjoint (iSup fun i => f i) a) (∀ (i : ι), Disjoint (f i) a)","decl":"protected theorem Directed.disjoint_iSup_left (h : Directed (· ≤ ·) f) :\n    Disjoint (⨆ i, f i) a ↔ ∀ i, Disjoint (f i) a := by\n  simp_rw [disjoint_iff, h.iSup_inf_eq, iSup_eq_bot]\n\n"}
{"name":"inf_sSup_eq_iSup_inf_sup_finset","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : IsCompactlyGenerated α\na : α\ns : Set α\n⊢ Eq (Min.min a (SupSet.sSup s)) (iSup fun t => iSup fun x => Min.min a (t.sup id))","decl":"/-- This property is equivalent to `α` being upper continuous. -/\ntheorem inf_sSup_eq_iSup_inf_sup_finset :\n    a ⊓ sSup s = ⨆ (t : Finset α) (_ : ↑t ⊆ s), a ⊓ t.sup id :=\n  le_antisymm\n    (by\n      rw [le_iff_compact_le_imp]\n      intro c hc hcinf\n      rw [le_inf_iff] at hcinf\n      rcases hc s hcinf.2 with ⟨t, ht1, ht2⟩\n      refine (le_inf hcinf.1 ht2).trans (le_trans ?_ (le_iSup₂ t ht1))\n      rfl)\n    (iSup_le fun t =>\n      iSup_le fun h => inf_le_inf_left _ ((Finset.sup_id_eq_sSup t).symm ▸ sSup_le_sSup h))\n\n"}
{"name":"sSupIndep_iff_finite","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : IsCompactlyGenerated α\ns : Set α\n⊢ Iff (sSupIndep s) (∀ (t : Finset α), HasSubset.Subset (↑t) s → sSupIndep ↑t)","decl":"theorem sSupIndep_iff_finite {s : Set α} :\n    sSupIndep s ↔\n      ∀ t : Finset α, ↑t ⊆ s → sSupIndep (↑t : Set α) :=\n  ⟨fun hs _ ht => hs.mono ht, fun h a ha => by\n    rw [disjoint_iff, inf_sSup_eq_iSup_inf_sup_finset, iSup_eq_bot]\n    intro t\n    rw [iSup_eq_bot, Finset.sup_id_eq_sSup]\n    intro ht\n    classical\n      have h' := (h (insert a t) ?_ (t.mem_insert_self a)).eq_bot\n      · rwa [Finset.coe_insert, Set.insert_diff_self_of_not_mem] at h'\n        exact fun con => ((Set.mem_diff a).1 (ht con)).2 (Set.mem_singleton a)\n      · rw [Finset.coe_insert, Set.insert_subset_iff]\n        exact ⟨ha, Set.Subset.trans ht diff_subset⟩⟩\n\n"}
{"name":"CompleteLattice.setIndependent_iff_finite","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : IsCompactlyGenerated α\ns : Set α\n⊢ Iff (sSupIndep s) (∀ (t : Finset α), HasSubset.Subset (↑t) s → sSupIndep ↑t)","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.setIndependent_iff_finite := sSupIndep_iff_finite\n\n"}
{"name":"iSupIndep_iff_supIndep_of_injOn","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : IsCompactlyGenerated α\nι : Type u_3\nf : ι → α\nhf : Set.InjOn f (setOf fun i => Ne (f i) Bot.bot)\n⊢ Iff (iSupIndep f) (∀ (s : Finset ι), s.SupIndep f)","decl":"lemma iSupIndep_iff_supIndep_of_injOn {ι : Type*} {f : ι → α}\n    (hf : InjOn f {i | f i ≠ ⊥}) :\n    iSupIndep f ↔ ∀ (s : Finset ι), s.SupIndep f := by\n  refine ⟨fun h ↦ h.supIndep', fun h ↦ iSupIndep_def'.mpr fun i ↦ ?_⟩\n  simp_rw [disjoint_iff, inf_sSup_eq_iSup_inf_sup_finset, iSup_eq_bot, ← disjoint_iff]\n  intro s hs\n  classical\n  rw [← Finset.sup_erase_bot]\n  set t := s.erase ⊥\n  replace hf : InjOn f (f ⁻¹' t) := fun i hi j _ hij ↦ by\n    refine hf ?_ ?_ hij <;> aesop (add norm simp [t])\n  have : (Finset.erase (insert i (t.preimage _ hf)) i).image f = t := by\n    ext a\n    simp only [Finset.mem_preimage, Finset.mem_erase, ne_eq, Finset.mem_insert, true_or, not_true,\n      Finset.erase_insert_eq_erase, not_and, Finset.mem_image, t]\n    refine ⟨by aesop, fun ⟨ha, has⟩ ↦ ?_⟩\n    obtain ⟨j, hj, rfl⟩ := hs has\n    exact ⟨j, ⟨hj, ha, has⟩, rfl⟩\n  rw [← this, Finset.sup_image]\n  specialize h (insert i (t.preimage _ hf))\n  rw [Finset.supIndep_iff_disjoint_erase] at h\n  exact h i (Finset.mem_insert_self i _)\n\n"}
{"name":"CompleteLattice.independent_iff_supIndep_of_injOn","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : IsCompactlyGenerated α\nι : Type u_3\nf : ι → α\nhf : Set.InjOn f (setOf fun i => Ne (f i) Bot.bot)\n⊢ Iff (iSupIndep f) (∀ (s : Finset ι), s.SupIndep f)","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.independent_iff_supIndep_of_injOn := iSupIndep_iff_supIndep_of_injOn\n\n"}
{"name":"sSupIndep_iUnion_of_directed","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : IsCompactlyGenerated α\nη : Type u_3\ns : η → Set α\nhs : Directed (fun x1 x2 => HasSubset.Subset x1 x2) s\nh : ∀ (i : η), sSupIndep (s i)\n⊢ sSupIndep (Set.iUnion fun i => s i)","decl":"theorem sSupIndep_iUnion_of_directed {η : Type*} {s : η → Set α}\n    (hs : Directed (· ⊆ ·) s) (h : ∀ i, sSupIndep (s i)) :\n    sSupIndep (⋃ i, s i) := by\n  by_cases hη : Nonempty η\n  · rw [sSupIndep_iff_finite]\n    intro t ht\n    obtain ⟨I, fi, hI⟩ := Set.finite_subset_iUnion t.finite_toSet ht\n    obtain ⟨i, hi⟩ := hs.finset_le fi.toFinset\n    exact (h i).mono\n        (Set.Subset.trans hI <| Set.iUnion₂_subset fun j hj => hi j (fi.mem_toFinset.2 hj))\n  · rintro a ⟨_, ⟨i, _⟩, _⟩\n    exfalso\n    exact hη ⟨i⟩\n\n"}
{"name":"CompleteLattice.setIndependent_iUnion_of_directed","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : IsCompactlyGenerated α\nη : Type u_3\ns : η → Set α\nhs : Directed (fun x1 x2 => HasSubset.Subset x1 x2) s\nh : ∀ (i : η), sSupIndep (s i)\n⊢ sSupIndep (Set.iUnion fun i => s i)","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.setIndependent_iUnion_of_directed := sSupIndep_iUnion_of_directed\n\n"}
{"name":"iSupIndep_sUnion_of_directed","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : IsCompactlyGenerated α\ns : Set (Set α)\nhs : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) s\nh : ∀ (a : Set α), Membership.mem s a → sSupIndep a\n⊢ sSupIndep s.sUnion","decl":"theorem iSupIndep_sUnion_of_directed {s : Set (Set α)} (hs : DirectedOn (· ⊆ ·) s)\n    (h : ∀ a ∈ s, sSupIndep a) : sSupIndep (⋃₀ s) := by\n  rw [Set.sUnion_eq_iUnion]\n  exact sSupIndep_iUnion_of_directed hs.directed_val (by simpa using h)\n\n"}
{"name":"CompleteLattice.independent_sUnion_of_directed","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : IsCompactlyGenerated α\ns : Set (Set α)\nhs : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) s\nh : ∀ (a : Set α), Membership.mem s a → sSupIndep a\n⊢ sSupIndep s.sUnion","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.independent_sUnion_of_directed := iSupIndep_sUnion_of_directed\n\n"}
{"name":"CompleteLattice.isCompactlyGenerated_of_wellFoundedGT","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\nh : WellFoundedGT α\n⊢ IsCompactlyGenerated α","decl":"theorem isCompactlyGenerated_of_wellFoundedGT [h : WellFoundedGT α] :\n    IsCompactlyGenerated α := by\n  rw [wellFoundedGT_iff_isSupFiniteCompact, isSupFiniteCompact_iff_all_elements_compact] at h\n  -- x is the join of the set of compact elements {x}\n  exact ⟨fun x => ⟨{x}, ⟨fun x _ => h x, sSup_singleton⟩⟩⟩\n\n"}
{"name":"CompleteLattice.WellFounded.isSupFiniteCompact","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : WellFoundedGT α\n⊢ CompleteLattice.IsSupFiniteCompact α","decl":"@[deprecated (since := \"2024-10-07\")]\nalias WellFounded.isSupFiniteCompact := WellFoundedGT.isSupFiniteCompact\n"}
{"name":"CompleteLattice.IsSupClosedCompact.wellFounded","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\nh : CompleteLattice.IsSupClosedCompact α\n⊢ WellFoundedGT α","decl":"@[deprecated (since := \"2024-10-07\")]\nalias IsSupClosedCompact.wellFounded := IsSupClosedCompact.wellFoundedGT\n"}
{"name":"CompleteLattice.wellFounded_characterisations","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\n⊢ (List.cons (WellFoundedGT α) (List.cons (CompleteLattice.IsSupFiniteCompact α) (List.cons (CompleteLattice.IsSupClosedCompact α) (List.cons (∀ (k : α), CompleteLattice.IsCompactElement k) List.nil)))).TFAE","decl":"@[deprecated (since := \"2024-10-07\")]\nalias wellFounded_characterisations := wellFoundedGT_characterisations\n"}
{"name":"CompleteLattice.wellFounded_iff_isSupFiniteCompact","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\n⊢ Iff (WellFoundedGT α) (CompleteLattice.IsSupFiniteCompact α)","decl":"@[deprecated (since := \"2024-10-07\")]\nalias wellFounded_iff_isSupFiniteCompact := wellFoundedGT_iff_isSupFiniteCompact\n"}
{"name":"CompleteLattice.isSupClosedCompact_iff_wellFounded","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\n⊢ Iff (CompleteLattice.IsSupClosedCompact α) (WellFoundedGT α)","decl":"@[deprecated (since := \"2024-10-07\")]\nalias isSupClosedCompact_iff_wellFounded := isSupClosedCompact_iff_wellFoundedGT\n"}
{"name":"CompleteLattice.IsSupFiniteCompact.wellFounded","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\na✝ : CompleteLattice.IsSupFiniteCompact α\n⊢ WellFoundedGT α","decl":"@[deprecated (since := \"2024-10-07\")]\nalias IsSupFiniteCompact.wellFounded := IsSupFiniteCompact.wellFoundedGT\n"}
{"name":"WellFounded.isSupClosedCompact","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\na✝ : WellFoundedGT α\n⊢ CompleteLattice.IsSupClosedCompact α","decl":"@[deprecated (since := \"2024-10-07\")]\nalias _root_.WellFounded.isSupClosedCompact := WellFoundedGT.isSupClosedCompact\n"}
{"name":"CompleteLattice.WellFounded.finite_of_setIndependent","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : WellFoundedGT α\ns : Set α\nhs : sSupIndep s\n⊢ s.Finite","decl":"@[deprecated (since := \"2024-10-07\")]\nalias WellFounded.finite_of_setIndependent := WellFoundedGT.finite_of_sSupIndep\n"}
{"name":"CompleteLattice.WellFounded.finite_ne_bot_of_independent","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : WellFoundedGT α\nι : Type u_3\nt : ι → α\nht : iSupIndep t\n⊢ (setOf fun i => Ne (t i) Bot.bot).Finite","decl":"@[deprecated (since := \"2024-10-07\")]\nalias WellFounded.finite_ne_bot_of_independent := WellFoundedGT.finite_ne_bot_of_iSupIndep\n"}
{"name":"CompleteLattice.WellFounded.finite_of_independent","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : WellFoundedGT α\nι : Type u_3\nt : ι → α\nht : iSupIndep t\nh_ne_bot : ∀ (i : ι), Ne (t i) Bot.bot\n⊢ Finite ι","decl":"@[deprecated (since := \"2024-10-07\")]\nalias WellFounded.finite_of_independent := WellFoundedGT.finite_of_iSupIndep\n"}
{"name":"CompleteLattice.isCompactlyGenerated_of_wellFounded","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\nh : WellFoundedGT α\n⊢ IsCompactlyGenerated α","decl":"@[deprecated (since := \"2024-10-07\")]\nalias isCompactlyGenerated_of_wellFounded := isCompactlyGenerated_of_wellFoundedGT\n\n"}
{"name":"CompleteLattice.Iic_coatomic_of_compact_element","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\nk : α\nh : CompleteLattice.IsCompactElement k\n⊢ IsCoatomic ↑(Set.Iic k)","decl":"/-- A compact element `k` has the property that any `b < k` lies below a \"maximal element below\n`k`\", which is to say `[⊥, k]` is coatomic. -/\ntheorem Iic_coatomic_of_compact_element {k : α} (h : IsCompactElement k) :\n    IsCoatomic (Set.Iic k) := by\n  constructor\n  rintro ⟨b, hbk⟩\n  obtain rfl | H := eq_or_ne b k\n  · left; ext; simp only [Set.Iic.coe_top, Subtype.coe_mk]\n  right\n  have ⟨a, ba, h⟩ := zorn_le_nonempty₀ (Set.Iio k) ?_ b (lt_of_le_of_ne hbk H)\n  · refine ⟨⟨a, le_of_lt h.prop⟩, ⟨ne_of_lt h.prop, fun c hck => by_contradiction fun c₀ => ?_⟩, ba⟩\n    cases h.eq_of_le (y := c.1) (lt_of_le_of_ne c.2 fun con ↦ c₀ (Subtype.ext con)) hck.le\n    exact lt_irrefl _ hck\n  · intro S SC cC I _\n    by_cases hS : S.Nonempty\n    · refine ⟨sSup S, h.directed_sSup_lt_of_lt hS cC.directedOn SC, ?_⟩\n      intro; apply le_sSup\n    exact\n      ⟨b, lt_of_le_of_ne hbk H, by\n        simp only [Set.not_nonempty_iff_eq_empty.mp hS, Set.mem_empty_iff_false, forall_const,\n          forall_prop_of_false, not_false_iff]⟩\n\n"}
{"name":"CompleteLattice.coatomic_of_top_compact","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\nh : CompleteLattice.IsCompactElement Top.top\n⊢ IsCoatomic α","decl":"theorem coatomic_of_top_compact (h : IsCompactElement (⊤ : α)) : IsCoatomic α :=\n  (@OrderIso.IicTop α _ _).isCoatomic_iff.mp (Iic_coatomic_of_compact_element h)\n\n"}
{"name":"isAtomic_of_complementedLattice","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : ComplementedLattice α\n⊢ IsAtomic α","decl":"instance (priority := 100) isAtomic_of_complementedLattice [ComplementedLattice α] : IsAtomic α :=\n  ⟨fun b => by\n    by_cases h : { c : α | CompleteLattice.IsCompactElement c ∧ c ≤ b } ⊆ {⊥}\n    · left\n      rw [← sSup_compact_le_eq b, sSup_eq_bot]\n      exact h\n    · rcases Set.not_subset.1 h with ⟨c, ⟨hc, hcb⟩, hcbot⟩\n      right\n      have hc' := CompleteLattice.Iic_coatomic_of_compact_element hc\n      rw [← isAtomic_iff_isCoatomic] at hc'\n      haveI := hc'\n      obtain con | ⟨a, ha, hac⟩ := eq_bot_or_exists_atom_le (⟨c, le_refl c⟩ : Set.Iic c)\n      · exfalso\n        apply hcbot\n        simp only [Subtype.ext_iff, Set.Iic.coe_bot, Subtype.coe_mk] at con\n        exact con\n      rw [← Subtype.coe_le_coe, Subtype.coe_mk] at hac\n      exact ⟨a, ha.of_isAtom_coe_Iic, hac.trans hcb⟩⟩\n\n"}
{"name":"isAtomistic_of_complementedLattice","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : ComplementedLattice α\n⊢ IsAtomistic α","decl":"/-- See [Lemma 5.1][calugareanu]. -/\ninstance (priority := 100) isAtomistic_of_complementedLattice [ComplementedLattice α] :\n    IsAtomistic α :=\n  ⟨fun b =>\n    ⟨{ a | IsAtom a ∧ a ≤ b }, by\n      symm\n      have hle : sSup { a : α | IsAtom a ∧ a ≤ b } ≤ b := sSup_le fun _ => And.right\n      apply (lt_or_eq_of_le hle).resolve_left _\n      intro con\n      obtain ⟨c, hc⟩ := exists_isCompl (⟨sSup { a : α | IsAtom a ∧ a ≤ b }, hle⟩ : Set.Iic b)\n      obtain rfl | ⟨a, ha, hac⟩ := eq_bot_or_exists_atom_le c\n      · exact ne_of_lt con (Subtype.ext_iff.1 (eq_top_of_isCompl_bot hc))\n      · apply ha.1\n        rw [eq_bot_iff]\n        apply le_trans (le_inf _ hac) hc.disjoint.le_bot\n        rw [← Subtype.coe_le_coe, Subtype.coe_mk]\n        exact le_sSup ⟨ha.of_isAtom_coe_Iic, a.2⟩, fun _ => And.left⟩⟩\n\n"}
{"name":"exists_sSupIndep_isCompl_sSup_atoms","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝² : CompleteLattice α\ninst✝¹ : IsModularLattice α\ninst✝ : IsCompactlyGenerated α\nh : Eq (SupSet.sSup (setOf fun a => IsAtom a)) Top.top\nb : α\n⊢ Exists fun s => And (sSupIndep s) (And (IsCompl b (SupSet.sSup s)) (∀ ⦃a : α⦄, Membership.mem s a → IsAtom a))","decl":"/-- In an atomic lattice, every element `b` has a complement of the form `sSup s`, where each\nelement of `s` is an atom. See also `complementedLattice_of_sSup_atoms_eq_top`. -/\ntheorem exists_sSupIndep_isCompl_sSup_atoms (h : sSup { a : α | IsAtom a } = ⊤) (b : α) :\n    ∃ s : Set α, sSupIndep s ∧\n    IsCompl b (sSup s) ∧ ∀ ⦃a⦄, a ∈ s → IsAtom a := by\n  -- porting note(https://github.com/leanprover-community/mathlib4/issues/5732):\n  -- `obtain` chokes on the placeholder.\n  have zorn := zorn_subset\n    (S := {s : Set α | sSupIndep s ∧ Disjoint b (sSup s) ∧ ∀ a ∈ s, IsAtom a})\n    fun c hc1 hc2 =>\n      ⟨⋃₀ c,\n        ⟨iSupIndep_sUnion_of_directed hc2.directedOn fun s hs => (hc1 hs).1, ?_,\n          fun a ⟨s, sc, as⟩ => (hc1 sc).2.2 a as⟩,\n        fun _ => Set.subset_sUnion_of_mem⟩\n  swap\n  · rw [sSup_sUnion, ← sSup_image, DirectedOn.disjoint_sSup_right]\n    · rintro _ ⟨s, hs, rfl⟩\n      exact (hc1 hs).2.1\n    · rw [directedOn_image]\n      exact hc2.directedOn.mono @fun s t => sSup_le_sSup\n  simp_rw [maximal_subset_iff] at zorn\n  obtain ⟨s, ⟨s_ind, b_inf_Sup_s, s_atoms⟩, s_max⟩ := zorn\n  refine ⟨s, s_ind, ⟨b_inf_Sup_s, ?_⟩, s_atoms⟩\n  rw [codisjoint_iff_le_sup, ← h, sSup_le_iff]\n  intro a ha\n  rw [← inf_eq_left]\n  refine (ha.le_iff.mp inf_le_left).resolve_left fun con => ha.1 ?_\n  rw [← con, eq_comm, inf_eq_left]\n  refine (le_sSup ?_).trans le_sup_right\n  rw [← disjoint_iff] at con\n  have a_dis_Sup_s : Disjoint a (sSup s) := con.mono_right le_sup_right\n  rw [s_max ⟨fun x hx => ?_, ?_, fun x hx => ?_⟩ Set.subset_union_left]\n  · exact Set.mem_union_right _ (Set.mem_singleton _)\n  · rw [sSup_union, sSup_singleton]\n    exact b_inf_Sup_s.disjoint_sup_right_of_disjoint_sup_left con.symm\n  · rw [Set.mem_union, Set.mem_singleton_iff] at hx\n    obtain rfl | xa := eq_or_ne x a\n    · simp only [Set.mem_singleton, Set.insert_diff_of_mem, Set.union_singleton]\n      exact con.mono_right ((sSup_le_sSup Set.diff_subset).trans le_sup_right)\n    · have h : (s ∪ {a}) \\ {x} = s \\ {x} ∪ {a} := by\n        simp only [Set.union_singleton]\n        rw [Set.insert_diff_of_not_mem]\n        rw [Set.mem_singleton_iff]\n        exact Ne.symm xa\n      rw [h, sSup_union, sSup_singleton]\n      apply\n        (s_ind (hx.resolve_right xa)).disjoint_sup_right_of_disjoint_sup_left\n          (a_dis_Sup_s.mono_right _).symm\n      rw [← sSup_insert, Set.insert_diff_singleton, Set.insert_eq_of_mem (hx.resolve_right xa)]\n  · rw [Set.mem_union, Set.mem_singleton_iff] at hx\n    obtain hx | rfl := hx\n    · exact s_atoms x hx\n    · exact ha\n\n"}
{"name":"exists_setIndependent_isCompl_sSup_atoms","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝² : CompleteLattice α\ninst✝¹ : IsModularLattice α\ninst✝ : IsCompactlyGenerated α\nh : Eq (SupSet.sSup (setOf fun a => IsAtom a)) Top.top\nb : α\n⊢ Exists fun s => And (sSupIndep s) (And (IsCompl b (SupSet.sSup s)) (∀ ⦃a : α⦄, Membership.mem s a → IsAtom a))","decl":"@[deprecated (since := \"2024-11-24\")]\nalias exists_setIndependent_isCompl_sSup_atoms := exists_sSupIndep_isCompl_sSup_atoms\n\n"}
{"name":"exists_sSupIndep_of_sSup_atoms_eq_top","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝² : CompleteLattice α\ninst✝¹ : IsModularLattice α\ninst✝ : IsCompactlyGenerated α\nh : Eq (SupSet.sSup (setOf fun a => IsAtom a)) Top.top\n⊢ Exists fun s => And (sSupIndep s) (And (Eq (SupSet.sSup s) Top.top) (∀ ⦃a : α⦄, Membership.mem s a → IsAtom a))","decl":"theorem exists_sSupIndep_of_sSup_atoms_eq_top (h : sSup { a : α | IsAtom a } = ⊤) :\n    ∃ s : Set α, sSupIndep s ∧ sSup s = ⊤ ∧ ∀ ⦃a⦄, a ∈ s → IsAtom a :=\n  let ⟨s, s_ind, s_top, s_atoms⟩ := exists_sSupIndep_isCompl_sSup_atoms h ⊥\n  ⟨s, s_ind, eq_top_of_isCompl_bot s_top.symm, s_atoms⟩\n\n"}
{"name":"exists_setIndependent_of_sSup_atoms_eq_top","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝² : CompleteLattice α\ninst✝¹ : IsModularLattice α\ninst✝ : IsCompactlyGenerated α\nh : Eq (SupSet.sSup (setOf fun a => IsAtom a)) Top.top\n⊢ Exists fun s => And (sSupIndep s) (And (Eq (SupSet.sSup s) Top.top) (∀ ⦃a : α⦄, Membership.mem s a → IsAtom a))","decl":"@[deprecated (since := \"2024-11-24\")]\nalias exists_setIndependent_of_sSup_atoms_eq_top := exists_sSupIndep_of_sSup_atoms_eq_top\n\n"}
{"name":"complementedLattice_of_sSup_atoms_eq_top","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝² : CompleteLattice α\ninst✝¹ : IsModularLattice α\ninst✝ : IsCompactlyGenerated α\nh : Eq (SupSet.sSup (setOf fun a => IsAtom a)) Top.top\n⊢ ComplementedLattice α","decl":"/-- See [Theorem 6.6][calugareanu]. -/\ntheorem complementedLattice_of_sSup_atoms_eq_top (h : sSup { a : α | IsAtom a } = ⊤) :\n    ComplementedLattice α :=\n  ⟨fun b =>\n    let ⟨s, _, s_top, _⟩ := exists_sSupIndep_isCompl_sSup_atoms h b\n    ⟨sSup s, s_top⟩⟩\n\n"}
{"name":"complementedLattice_of_isAtomistic","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝³ : CompleteLattice α\ninst✝² : IsModularLattice α\ninst✝¹ : IsCompactlyGenerated α\ninst✝ : IsAtomistic α\n⊢ ComplementedLattice α","decl":"/-- See [Theorem 6.6][calugareanu]. -/\ntheorem complementedLattice_of_isAtomistic [IsAtomistic α] : ComplementedLattice α :=\n  complementedLattice_of_sSup_atoms_eq_top sSup_atoms_eq_top\n\n"}
{"name":"complementedLattice_iff_isAtomistic","module":"Mathlib.Order.CompactlyGenerated.Basic","initialProofState":"α : Type u_2\ninst✝² : CompleteLattice α\ninst✝¹ : IsModularLattice α\ninst✝ : IsCompactlyGenerated α\n⊢ Iff (ComplementedLattice α) (IsAtomistic α)","decl":"theorem complementedLattice_iff_isAtomistic : ComplementedLattice α ↔ IsAtomistic α := by\n  constructor <;> intros\n  · exact isAtomistic_of_complementedLattice\n  · exact complementedLattice_of_isAtomistic\n\n"}
