{"name":"CategoryTheory.Arrow.cechNerve_obj","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow C\ninst✝ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nn : Opposite SimplexCategory\n⊢ Eq (f.cechNerve.obj n) (CategoryTheory.Limits.widePullback f.right (fun x => f.left) fun x => f.hom)","decl":"/-- The Čech nerve associated to an arrow. -/\n@[simps]\ndef cechNerve : SimplicialObject C where\n  obj n := widePullback.{0} f.right (fun _ : Fin (n.unop.len + 1) => f.left) fun _ => f.hom\n  map g := WidePullback.lift (WidePullback.base _)\n    (fun i => WidePullback.π _ (g.unop.toOrderHom i)) (by simp)\n\n"}
{"name":"CategoryTheory.Arrow.cechNerve_map","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow C\ninst✝ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nX✝ Y✝ : Opposite SimplexCategory\ng : Quiver.Hom X✝ Y✝\n⊢ Eq (f.cechNerve.map g) (CategoryTheory.Limits.WidePullback.lift (CategoryTheory.Limits.WidePullback.base fun x => f.hom) (fun i => CategoryTheory.Limits.WidePullback.π (fun x => f.hom) ((SimplexCategory.Hom.toOrderHom g.unop) i)) ⋯)","decl":"/-- The Čech nerve associated to an arrow. -/\n@[simps]\ndef cechNerve : SimplicialObject C where\n  obj n := widePullback.{0} f.right (fun _ : Fin (n.unop.len + 1) => f.left) fun _ => f.hom\n  map g := WidePullback.lift (WidePullback.base _)\n    (fun i => WidePullback.π _ (g.unop.toOrderHom i)) (by simp)\n\n"}
{"name":"CategoryTheory.Arrow.mapCechNerve_app","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝¹ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\ninst✝ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePullback g.right (fun x => g.left) fun x => g.hom\nF : Quiver.Hom f g\nn : Opposite SimplexCategory\n⊢ Eq ((CategoryTheory.Arrow.mapCechNerve F).app n) (CategoryTheory.Limits.WidePullback.lift (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.base fun x => f.hom) F.right) (fun i => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.π (fun x => f.hom) i) F.left) ⋯)","decl":"/-- The morphism between Čech nerves associated to a morphism of arrows. -/\n@[simps]\ndef mapCechNerve {f g : Arrow C}\n    [∀ n : ℕ, HasWidePullback f.right (fun _ : Fin (n + 1) => f.left) fun _ => f.hom]\n    [∀ n : ℕ, HasWidePullback g.right (fun _ : Fin (n + 1) => g.left) fun _ => g.hom] (F : f ⟶ g) :\n    f.cechNerve ⟶ g.cechNerve where\n  app n :=\n    WidePullback.lift (WidePullback.base _ ≫ F.right) (fun i => WidePullback.π _ i ≫ F.left)\n      fun j => by simp\n\n"}
{"name":"CategoryTheory.Arrow.augmentedCechNerve_hom_app","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow C\ninst✝ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nx✝ : Opposite SimplexCategory\n⊢ Eq (f.augmentedCechNerve.hom.app x✝) (CategoryTheory.Limits.WidePullback.base fun x => f.hom)","decl":"/-- The augmented Čech nerve associated to an arrow. -/\n@[simps]\ndef augmentedCechNerve : SimplicialObject.Augmented C where\n  left := f.cechNerve\n  right := f.right\n  hom := { app := fun _ => WidePullback.base _ }\n\n"}
{"name":"CategoryTheory.Arrow.augmentedCechNerve_left","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow C\ninst✝ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\n⊢ Eq f.augmentedCechNerve.left f.cechNerve","decl":"/-- The augmented Čech nerve associated to an arrow. -/\n@[simps]\ndef augmentedCechNerve : SimplicialObject.Augmented C where\n  left := f.cechNerve\n  right := f.right\n  hom := { app := fun _ => WidePullback.base _ }\n\n"}
{"name":"CategoryTheory.Arrow.augmentedCechNerve_right","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow C\ninst✝ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\n⊢ Eq f.augmentedCechNerve.right f.right","decl":"/-- The augmented Čech nerve associated to an arrow. -/\n@[simps]\ndef augmentedCechNerve : SimplicialObject.Augmented C where\n  left := f.cechNerve\n  right := f.right\n  hom := { app := fun _ => WidePullback.base _ }\n\n"}
{"name":"CategoryTheory.Arrow.mapAugmentedCechNerve_left","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝¹ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\ninst✝ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePullback g.right (fun x => g.left) fun x => g.hom\nF : Quiver.Hom f g\n⊢ Eq (CategoryTheory.Arrow.mapAugmentedCechNerve F).left (CategoryTheory.Arrow.mapCechNerve F)","decl":"/-- The morphism between augmented Čech nerve associated to a morphism of arrows. -/\n@[simps]\ndef mapAugmentedCechNerve {f g : Arrow C}\n    [∀ n : ℕ, HasWidePullback f.right (fun _ : Fin (n + 1) => f.left) fun _ => f.hom]\n    [∀ n : ℕ, HasWidePullback g.right (fun _ : Fin (n + 1) => g.left) fun _ => g.hom] (F : f ⟶ g) :\n    f.augmentedCechNerve ⟶ g.augmentedCechNerve where\n  left := mapCechNerve F\n  right := F.right\n\n"}
{"name":"CategoryTheory.Arrow.mapAugmentedCechNerve_right","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝¹ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\ninst✝ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePullback g.right (fun x => g.left) fun x => g.hom\nF : Quiver.Hom f g\n⊢ Eq (CategoryTheory.Arrow.mapAugmentedCechNerve F).right F.right","decl":"/-- The morphism between augmented Čech nerve associated to a morphism of arrows. -/\n@[simps]\ndef mapAugmentedCechNerve {f g : Arrow C}\n    [∀ n : ℕ, HasWidePullback f.right (fun _ : Fin (n + 1) => f.left) fun _ => f.hom]\n    [∀ n : ℕ, HasWidePullback g.right (fun _ : Fin (n + 1) => g.left) fun _ => g.hom] (F : f ⟶ g) :\n    f.augmentedCechNerve ⟶ g.augmentedCechNerve where\n  left := mapCechNerve F\n  right := F.right\n\n"}
{"name":"CategoryTheory.SimplicialObject.cechNerve_map","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nX✝ Y✝ : CategoryTheory.Arrow C\nF : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.SimplicialObject.cechNerve.map F) (CategoryTheory.Arrow.mapCechNerve F)","decl":"/-- The Čech nerve construction, as a functor from `Arrow C`. -/\n@[simps]\ndef cechNerve : Arrow C ⥤ SimplicialObject C where\n  obj f := f.cechNerve\n  map F := Arrow.mapCechNerve F\n\n"}
{"name":"CategoryTheory.SimplicialObject.cechNerve_obj","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nf : CategoryTheory.Arrow C\n⊢ Eq (CategoryTheory.SimplicialObject.cechNerve.obj f) f.cechNerve","decl":"/-- The Čech nerve construction, as a functor from `Arrow C`. -/\n@[simps]\ndef cechNerve : Arrow C ⥤ SimplicialObject C where\n  obj f := f.cechNerve\n  map F := Arrow.mapCechNerve F\n\n"}
{"name":"CategoryTheory.SimplicialObject.augmentedCechNerve_map_right","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nX✝ Y✝ : CategoryTheory.Arrow C\nF : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.SimplicialObject.augmentedCechNerve.map F).right F.right","decl":"/-- The augmented Čech nerve construction, as a functor from `Arrow C`. -/\n@[simps!]\ndef augmentedCechNerve : Arrow C ⥤ SimplicialObject.Augmented C where\n  obj f := f.augmentedCechNerve\n  map F := Arrow.mapAugmentedCechNerve F\n\n"}
{"name":"CategoryTheory.SimplicialObject.augmentedCechNerve_obj_left_map","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nf : CategoryTheory.Arrow C\nX✝ Y✝ : Opposite SimplexCategory\ng : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.SimplicialObject.augmentedCechNerve.obj f).left.map g) (CategoryTheory.Limits.WidePullback.lift (CategoryTheory.Limits.WidePullback.base fun x => f.hom) (fun i => CategoryTheory.Limits.WidePullback.π (fun x => f.hom) ((SimplexCategory.Hom.toOrderHom g.unop) i)) ⋯)","decl":"/-- The augmented Čech nerve construction, as a functor from `Arrow C`. -/\n@[simps!]\ndef augmentedCechNerve : Arrow C ⥤ SimplicialObject.Augmented C where\n  obj f := f.augmentedCechNerve\n  map F := Arrow.mapAugmentedCechNerve F\n\n"}
{"name":"CategoryTheory.SimplicialObject.augmentedCechNerve_obj_right","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nf : CategoryTheory.Arrow C\n⊢ Eq (CategoryTheory.SimplicialObject.augmentedCechNerve.obj f).right f.right","decl":"/-- The augmented Čech nerve construction, as a functor from `Arrow C`. -/\n@[simps!]\ndef augmentedCechNerve : Arrow C ⥤ SimplicialObject.Augmented C where\n  obj f := f.augmentedCechNerve\n  map F := Arrow.mapAugmentedCechNerve F\n\n"}
{"name":"CategoryTheory.SimplicialObject.augmentedCechNerve_obj_hom_app","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nf : CategoryTheory.Arrow C\nx✝ : Opposite SimplexCategory\n⊢ Eq ((CategoryTheory.SimplicialObject.augmentedCechNerve.obj f).hom.app x✝) (CategoryTheory.Limits.WidePullback.base fun x => f.hom)","decl":"/-- The augmented Čech nerve construction, as a functor from `Arrow C`. -/\n@[simps!]\ndef augmentedCechNerve : Arrow C ⥤ SimplicialObject.Augmented C where\n  obj f := f.augmentedCechNerve\n  map F := Arrow.mapAugmentedCechNerve F\n\n"}
{"name":"CategoryTheory.SimplicialObject.augmentedCechNerve_map_left_app","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nX✝ Y✝ : CategoryTheory.Arrow C\nF : Quiver.Hom X✝ Y✝\nn : Opposite SimplexCategory\n⊢ Eq ((CategoryTheory.SimplicialObject.augmentedCechNerve.map F).left.app n) (CategoryTheory.Limits.WidePullback.lift (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.base fun x => X✝.hom) F.right) (fun i => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.π (fun x => X✝.hom) i) F.left) ⋯)","decl":"/-- The augmented Čech nerve construction, as a functor from `Arrow C`. -/\n@[simps!]\ndef augmentedCechNerve : Arrow C ⥤ SimplicialObject.Augmented C where\n  obj f := f.augmentedCechNerve\n  map F := Arrow.mapAugmentedCechNerve F\n\n"}
{"name":"CategoryTheory.SimplicialObject.augmentedCechNerve_obj_left_obj","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nf : CategoryTheory.Arrow C\nn : Opposite SimplexCategory\n⊢ Eq ((CategoryTheory.SimplicialObject.augmentedCechNerve.obj f).left.obj n) (CategoryTheory.Limits.widePullback f.right (fun x => f.left) fun x => f.hom)","decl":"/-- The augmented Čech nerve construction, as a functor from `Arrow C`. -/\n@[simps!]\ndef augmentedCechNerve : Arrow C ⥤ SimplicialObject.Augmented C where\n  obj f := f.augmentedCechNerve\n  map F := Arrow.mapAugmentedCechNerve F\n\n"}
{"name":"CategoryTheory.SimplicialObject.equivalenceRightToLeft_right","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nX : CategoryTheory.SimplicialObject.Augmented C\nF : CategoryTheory.Arrow C\nG : Quiver.Hom X F.augmentedCechNerve\n⊢ Eq (CategoryTheory.SimplicialObject.equivalenceRightToLeft X F G).right G.right","decl":"/-- A helper function used in defining the Čech adjunction. -/\n@[simps]\ndef equivalenceRightToLeft (X : SimplicialObject.Augmented C) (F : Arrow C)\n    (G : X ⟶ F.augmentedCechNerve) : Augmented.toArrow.obj X ⟶ F where\n  left := G.left.app _ ≫ WidePullback.π _ 0\n  right := G.right\n  w := by\n    have := G.w\n    apply_fun fun e => e.app (Opposite.op <| SimplexCategory.mk 0) at this\n    simpa using this\n\n"}
{"name":"CategoryTheory.SimplicialObject.equivalenceRightToLeft_left","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nX : CategoryTheory.SimplicialObject.Augmented C\nF : CategoryTheory.Arrow C\nG : Quiver.Hom X F.augmentedCechNerve\n⊢ Eq (CategoryTheory.SimplicialObject.equivalenceRightToLeft X F G).left (CategoryTheory.CategoryStruct.comp (G.left.app { unop := SimplexCategory.mk 0 }) (CategoryTheory.Limits.WidePullback.π (fun x => F.hom) 0))","decl":"/-- A helper function used in defining the Čech adjunction. -/\n@[simps]\ndef equivalenceRightToLeft (X : SimplicialObject.Augmented C) (F : Arrow C)\n    (G : X ⟶ F.augmentedCechNerve) : Augmented.toArrow.obj X ⟶ F where\n  left := G.left.app _ ≫ WidePullback.π _ 0\n  right := G.right\n  w := by\n    have := G.w\n    apply_fun fun e => e.app (Opposite.op <| SimplexCategory.mk 0) at this\n    simpa using this\n\n"}
{"name":"CategoryTheory.SimplicialObject.equivalenceLeftToRight_left_app","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nX : CategoryTheory.SimplicialObject.Augmented C\nF : CategoryTheory.Arrow C\nG : Quiver.Hom (CategoryTheory.SimplicialObject.Augmented.toArrow.obj X) F\nx : Opposite SimplexCategory\n⊢ Eq ((CategoryTheory.SimplicialObject.equivalenceLeftToRight X F G).left.app x) (CategoryTheory.Limits.WidePullback.lift (CategoryTheory.CategoryStruct.comp (X.hom.app x) G.right) (fun i => CategoryTheory.CategoryStruct.comp (X.left.map ((SimplexCategory.mk 0).const (Opposite.unop x) i).op) G.left) ⋯)","decl":"/-- A helper function used in defining the Čech adjunction. -/\n@[simps]\ndef equivalenceLeftToRight (X : SimplicialObject.Augmented C) (F : Arrow C)\n    (G : Augmented.toArrow.obj X ⟶ F) : X ⟶ F.augmentedCechNerve where\n  left :=\n    { app := fun x =>\n        Limits.WidePullback.lift (X.hom.app _ ≫ G.right)\n          (fun i => X.left.map (SimplexCategory.const _ x.unop i).op ≫ G.left) fun i => by simp\n      naturality := by\n        intro x y f\n        dsimp\n        ext\n        · dsimp\n          simp only [WidePullback.lift_π, Category.assoc, ← X.left.map_comp_assoc]\n          rfl\n        · dsimp\n          simp }\n  right := G.right\n\n"}
{"name":"CategoryTheory.SimplicialObject.equivalenceLeftToRight_right","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nX : CategoryTheory.SimplicialObject.Augmented C\nF : CategoryTheory.Arrow C\nG : Quiver.Hom (CategoryTheory.SimplicialObject.Augmented.toArrow.obj X) F\n⊢ Eq (CategoryTheory.SimplicialObject.equivalenceLeftToRight X F G).right G.right","decl":"/-- A helper function used in defining the Čech adjunction. -/\n@[simps]\ndef equivalenceLeftToRight (X : SimplicialObject.Augmented C) (F : Arrow C)\n    (G : Augmented.toArrow.obj X ⟶ F) : X ⟶ F.augmentedCechNerve where\n  left :=\n    { app := fun x =>\n        Limits.WidePullback.lift (X.hom.app _ ≫ G.right)\n          (fun i => X.left.map (SimplexCategory.const _ x.unop i).op ≫ G.left) fun i => by simp\n      naturality := by\n        intro x y f\n        dsimp\n        ext\n        · dsimp\n          simp only [WidePullback.lift_π, Category.assoc, ← X.left.map_comp_assoc]\n          rfl\n        · dsimp\n          simp }\n  right := G.right\n\n"}
{"name":"CategoryTheory.SimplicialObject.cechNerveEquiv_symm_apply","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nX : CategoryTheory.SimplicialObject.Augmented C\nF : CategoryTheory.Arrow C\nG : Quiver.Hom X F.augmentedCechNerve\n⊢ Eq ((CategoryTheory.SimplicialObject.cechNerveEquiv X F).symm G) (CategoryTheory.SimplicialObject.equivalenceRightToLeft X F G)","decl":"/-- A helper function used in defining the Čech adjunction. -/\n@[simps]\ndef cechNerveEquiv (X : SimplicialObject.Augmented C) (F : Arrow C) :\n    (Augmented.toArrow.obj X ⟶ F) ≃ (X ⟶ F.augmentedCechNerve) where\n  toFun := equivalenceLeftToRight _ _\n  invFun := equivalenceRightToLeft _ _\n  left_inv := by\n    intro A\n    ext\n    · dsimp\n      rw [WidePullback.lift_π]\n      nth_rw 2 [← Category.id_comp A.left]\n      congr 1\n      convert X.left.map_id _\n      rw [← op_id]\n      congr 1\n      ext ⟨a, ha⟩\n      change a < 1 at ha\n      change 0 = a\n      omega\n    · rfl\n  right_inv := by\n    intro A\n    ext x : 2\n    · refine WidePullback.hom_ext _ _ _ (fun j => ?_) ?_\n      · dsimp\n        simp\n        rfl\n      · simpa using congr_app A.w.symm x\n    · rfl\n\n"}
{"name":"CategoryTheory.SimplicialObject.cechNerveEquiv_apply","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nX : CategoryTheory.SimplicialObject.Augmented C\nF : CategoryTheory.Arrow C\nG : Quiver.Hom (CategoryTheory.SimplicialObject.Augmented.toArrow.obj X) F\n⊢ Eq ((CategoryTheory.SimplicialObject.cechNerveEquiv X F) G) (CategoryTheory.SimplicialObject.equivalenceLeftToRight X F G)","decl":"/-- A helper function used in defining the Čech adjunction. -/\n@[simps]\ndef cechNerveEquiv (X : SimplicialObject.Augmented C) (F : Arrow C) :\n    (Augmented.toArrow.obj X ⟶ F) ≃ (X ⟶ F.augmentedCechNerve) where\n  toFun := equivalenceLeftToRight _ _\n  invFun := equivalenceRightToLeft _ _\n  left_inv := by\n    intro A\n    ext\n    · dsimp\n      rw [WidePullback.lift_π]\n      nth_rw 2 [← Category.id_comp A.left]\n      congr 1\n      convert X.left.map_id _\n      rw [← op_id]\n      congr 1\n      ext ⟨a, ha⟩\n      change a < 1 at ha\n      change 0 = a\n      omega\n    · rfl\n  right_inv := by\n    intro A\n    ext x : 2\n    · refine WidePullback.hom_ext _ _ _ (fun j => ?_) ?_\n      · dsimp\n        simp\n        rfl\n      · simpa using congr_app A.w.symm x\n    · rfl\n\n"}
{"name":"CategoryTheory.Arrow.cechConerve_obj","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow C\ninst✝ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePushout f.left (fun x => f.right) fun x => f.hom\nn : SimplexCategory\n⊢ Eq (f.cechConerve.obj n) (CategoryTheory.Limits.widePushout f.left (fun x => f.right) fun x => f.hom)","decl":"/-- The Čech conerve associated to an arrow. -/\n@[simps]\ndef cechConerve : CosimplicialObject C where\n  obj n := widePushout f.left (fun _ : Fin (n.len + 1) => f.right) fun _ => f.hom\n  map {x y} g := by\n    refine WidePushout.desc (WidePushout.head _)\n      (fun i => (@WidePushout.ι _ _ _ _ _ (fun _ => f.hom) (_) (g.toOrderHom i))) (fun j => ?_)\n    rw [← WidePushout.arrow_ι]\n\n"}
{"name":"CategoryTheory.Arrow.cechConerve_map","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow C\ninst✝ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePushout f.left (fun x => f.right) fun x => f.hom\nx y : SimplexCategory\ng : Quiver.Hom x y\n⊢ Eq (f.cechConerve.map g) (CategoryTheory.Limits.WidePushout.desc (CategoryTheory.Limits.WidePushout.head fun x => f.hom) (fun i => CategoryTheory.Limits.WidePushout.ι (fun x => f.hom) ((SimplexCategory.Hom.toOrderHom g) i)) ⋯)","decl":"/-- The Čech conerve associated to an arrow. -/\n@[simps]\ndef cechConerve : CosimplicialObject C where\n  obj n := widePushout f.left (fun _ : Fin (n.len + 1) => f.right) fun _ => f.hom\n  map {x y} g := by\n    refine WidePushout.desc (WidePushout.head _)\n      (fun i => (@WidePushout.ι _ _ _ _ _ (fun _ => f.hom) (_) (g.toOrderHom i))) (fun j => ?_)\n    rw [← WidePushout.arrow_ι]\n\n"}
{"name":"CategoryTheory.Arrow.mapCechConerve_app","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝¹ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePushout f.left (fun x => f.right) fun x => f.hom\ninst✝ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePushout g.left (fun x => g.right) fun x => g.hom\nF : Quiver.Hom f g\nn : SimplexCategory\n⊢ Eq ((CategoryTheory.Arrow.mapCechConerve F).app n) (CategoryTheory.Limits.WidePushout.desc (CategoryTheory.CategoryStruct.comp F.left (CategoryTheory.Limits.WidePushout.head fun x => g.hom)) (fun i => CategoryTheory.CategoryStruct.comp F.right (CategoryTheory.Limits.WidePushout.ι (fun x => g.hom) i)) ⋯)","decl":"/-- The morphism between Čech conerves associated to a morphism of arrows. -/\n@[simps]\ndef mapCechConerve {f g : Arrow C}\n    [∀ n : ℕ, HasWidePushout f.left (fun _ : Fin (n + 1) => f.right) fun _ => f.hom]\n    [∀ n : ℕ, HasWidePushout g.left (fun _ : Fin (n + 1) => g.right) fun _ => g.hom] (F : f ⟶ g) :\n    f.cechConerve ⟶ g.cechConerve where\n  app n := WidePushout.desc (F.left ≫ WidePushout.head _)\n    (fun i => F.right ≫ (by apply WidePushout.ι _ i))\n    (fun i => (by rw [← Arrow.w_assoc F, ← WidePushout.arrow_ι]))\n\n"}
{"name":"CategoryTheory.Arrow.augmentedCechConerve_left","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow C\ninst✝ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePushout f.left (fun x => f.right) fun x => f.hom\n⊢ Eq f.augmentedCechConerve.left f.left","decl":"/-- The augmented Čech conerve associated to an arrow. -/\n@[simps]\ndef augmentedCechConerve : CosimplicialObject.Augmented C where\n  left := f.left\n  right := f.cechConerve\n  hom :=\n    { app := fun _ => (WidePushout.head _ : f.left ⟶ _) }\n\n"}
{"name":"CategoryTheory.Arrow.augmentedCechConerve_hom_app","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow C\ninst✝ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePushout f.left (fun x => f.right) fun x => f.hom\nx✝ : SimplexCategory\n⊢ Eq (f.augmentedCechConerve.hom.app x✝) (CategoryTheory.Limits.WidePushout.head fun x => f.hom)","decl":"/-- The augmented Čech conerve associated to an arrow. -/\n@[simps]\ndef augmentedCechConerve : CosimplicialObject.Augmented C where\n  left := f.left\n  right := f.cechConerve\n  hom :=\n    { app := fun _ => (WidePushout.head _ : f.left ⟶ _) }\n\n"}
{"name":"CategoryTheory.Arrow.augmentedCechConerve_right","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow C\ninst✝ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePushout f.left (fun x => f.right) fun x => f.hom\n⊢ Eq f.augmentedCechConerve.right f.cechConerve","decl":"/-- The augmented Čech conerve associated to an arrow. -/\n@[simps]\ndef augmentedCechConerve : CosimplicialObject.Augmented C where\n  left := f.left\n  right := f.cechConerve\n  hom :=\n    { app := fun _ => (WidePushout.head _ : f.left ⟶ _) }\n\n"}
{"name":"CategoryTheory.Arrow.mapAugmentedCechConerve_left","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝¹ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePushout f.left (fun x => f.right) fun x => f.hom\ninst✝ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePushout g.left (fun x => g.right) fun x => g.hom\nF : Quiver.Hom f g\n⊢ Eq (CategoryTheory.Arrow.mapAugmentedCechConerve F).left F.left","decl":"/-- The morphism between augmented Čech conerves associated to a morphism of arrows. -/\n@[simps]\ndef mapAugmentedCechConerve {f g : Arrow C}\n    [∀ n : ℕ, HasWidePushout f.left (fun _ : Fin (n + 1) => f.right) fun _ => f.hom]\n    [∀ n : ℕ, HasWidePushout g.left (fun _ : Fin (n + 1) => g.right) fun _ => g.hom] (F : f ⟶ g) :\n    f.augmentedCechConerve ⟶ g.augmentedCechConerve where\n  left := F.left\n  right := mapCechConerve F\n\n"}
{"name":"CategoryTheory.Arrow.mapAugmentedCechConerve_right","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝¹ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePushout f.left (fun x => f.right) fun x => f.hom\ninst✝ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePushout g.left (fun x => g.right) fun x => g.hom\nF : Quiver.Hom f g\n⊢ Eq (CategoryTheory.Arrow.mapAugmentedCechConerve F).right (CategoryTheory.Arrow.mapCechConerve F)","decl":"/-- The morphism between augmented Čech conerves associated to a morphism of arrows. -/\n@[simps]\ndef mapAugmentedCechConerve {f g : Arrow C}\n    [∀ n : ℕ, HasWidePushout f.left (fun _ : Fin (n + 1) => f.right) fun _ => f.hom]\n    [∀ n : ℕ, HasWidePushout g.left (fun _ : Fin (n + 1) => g.right) fun _ => g.hom] (F : f ⟶ g) :\n    f.augmentedCechConerve ⟶ g.augmentedCechConerve where\n  left := F.left\n  right := mapCechConerve F\n\n"}
{"name":"CategoryTheory.CosimplicialObject.cechConerve_obj","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePushout f.left (fun x => f.right) fun x => f.hom\nf : CategoryTheory.Arrow C\n⊢ Eq (CategoryTheory.CosimplicialObject.cechConerve.obj f) f.cechConerve","decl":"/-- The Čech conerve construction, as a functor from `Arrow C`. -/\n@[simps]\ndef cechConerve : Arrow C ⥤ CosimplicialObject C where\n  obj f := f.cechConerve\n  map F := Arrow.mapCechConerve F\n\n"}
{"name":"CategoryTheory.CosimplicialObject.cechConerve_map","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePushout f.left (fun x => f.right) fun x => f.hom\nX✝ Y✝ : CategoryTheory.Arrow C\nF : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.CosimplicialObject.cechConerve.map F) (CategoryTheory.Arrow.mapCechConerve F)","decl":"/-- The Čech conerve construction, as a functor from `Arrow C`. -/\n@[simps]\ndef cechConerve : Arrow C ⥤ CosimplicialObject C where\n  obj f := f.cechConerve\n  map F := Arrow.mapCechConerve F\n\n"}
{"name":"CategoryTheory.CosimplicialObject.augmentedCechConerve_map","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePushout f.left (fun x => f.right) fun x => f.hom\nX✝ Y✝ : CategoryTheory.Arrow C\nF : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.CosimplicialObject.augmentedCechConerve.map F) (CategoryTheory.Arrow.mapAugmentedCechConerve F)","decl":"/-- The augmented Čech conerve construction, as a functor from `Arrow C`. -/\n@[simps]\ndef augmentedCechConerve : Arrow C ⥤ CosimplicialObject.Augmented C where\n  obj f := f.augmentedCechConerve\n  map F := Arrow.mapAugmentedCechConerve F\n\n"}
{"name":"CategoryTheory.CosimplicialObject.augmentedCechConerve_obj","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePushout f.left (fun x => f.right) fun x => f.hom\nf : CategoryTheory.Arrow C\n⊢ Eq (CategoryTheory.CosimplicialObject.augmentedCechConerve.obj f) f.augmentedCechConerve","decl":"/-- The augmented Čech conerve construction, as a functor from `Arrow C`. -/\n@[simps]\ndef augmentedCechConerve : Arrow C ⥤ CosimplicialObject.Augmented C where\n  obj f := f.augmentedCechConerve\n  map F := Arrow.mapAugmentedCechConerve F\n\n"}
{"name":"CategoryTheory.CosimplicialObject.equivalenceLeftToRight_right","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePushout f.left (fun x => f.right) fun x => f.hom\nF : CategoryTheory.Arrow C\nX : CategoryTheory.CosimplicialObject.Augmented C\nG : Quiver.Hom F.augmentedCechConerve X\n⊢ Eq (CategoryTheory.CosimplicialObject.equivalenceLeftToRight F X G).right (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.ι (fun x => F.hom) 0) (G.right.app (SimplexCategory.mk 0)))","decl":"/-- A helper function used in defining the Čech conerve adjunction. -/\n@[simps]\ndef equivalenceLeftToRight (F : Arrow C) (X : CosimplicialObject.Augmented C)\n    (G : F.augmentedCechConerve ⟶ X) : F ⟶ Augmented.toArrow.obj X where\n  left := G.left\n  right := (WidePushout.ι _ 0 ≫ G.right.app (SimplexCategory.mk 0) :)\n  w := by\n    dsimp\n    rw [@WidePushout.arrow_ι_assoc _ _ _ _ _ (fun (_ : Fin 1) => F.hom)\n      (by dsimp; infer_instance)]\n    exact congr_app G.w (SimplexCategory.mk 0)\n\n"}
{"name":"CategoryTheory.CosimplicialObject.equivalenceLeftToRight_left","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePushout f.left (fun x => f.right) fun x => f.hom\nF : CategoryTheory.Arrow C\nX : CategoryTheory.CosimplicialObject.Augmented C\nG : Quiver.Hom F.augmentedCechConerve X\n⊢ Eq (CategoryTheory.CosimplicialObject.equivalenceLeftToRight F X G).left G.left","decl":"/-- A helper function used in defining the Čech conerve adjunction. -/\n@[simps]\ndef equivalenceLeftToRight (F : Arrow C) (X : CosimplicialObject.Augmented C)\n    (G : F.augmentedCechConerve ⟶ X) : F ⟶ Augmented.toArrow.obj X where\n  left := G.left\n  right := (WidePushout.ι _ 0 ≫ G.right.app (SimplexCategory.mk 0) :)\n  w := by\n    dsimp\n    rw [@WidePushout.arrow_ι_assoc _ _ _ _ _ (fun (_ : Fin 1) => F.hom)\n      (by dsimp; infer_instance)]\n    exact congr_app G.w (SimplexCategory.mk 0)\n\n"}
{"name":"CategoryTheory.CosimplicialObject.equivalenceRightToLeft_right_app","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePushout f.left (fun x => f.right) fun x => f.hom\nF : CategoryTheory.Arrow C\nX : CategoryTheory.CosimplicialObject.Augmented C\nG : Quiver.Hom F (CategoryTheory.CosimplicialObject.Augmented.toArrow.obj X)\nx : SimplexCategory\n⊢ Eq ((CategoryTheory.CosimplicialObject.equivalenceRightToLeft F X G).right.app x) (CategoryTheory.Limits.WidePushout.desc (CategoryTheory.CategoryStruct.comp G.left (X.hom.app x)) (fun i => CategoryTheory.CategoryStruct.comp G.right (X.right.map ((SimplexCategory.mk 0).const x i))) ⋯)","decl":"/-- A helper function used in defining the Čech conerve adjunction. -/\n@[simps!]\ndef equivalenceRightToLeft (F : Arrow C) (X : CosimplicialObject.Augmented C)\n    (G : F ⟶ Augmented.toArrow.obj X) : F.augmentedCechConerve ⟶ X where\n  left := G.left\n  right :=\n    { app := fun x =>\n        Limits.WidePushout.desc (G.left ≫ X.hom.app _)\n          (fun i => G.right ≫ X.right.map (SimplexCategory.const _ x i))\n          (by\n            rintro j\n            rw [← Arrow.w_assoc G]\n            have t := X.hom.naturality (SimplexCategory.const (SimplexCategory.mk 0) x j)\n            dsimp at t ⊢\n            simp only [Category.id_comp] at t\n            rw [← t])\n      naturality := by\n        intro x y f\n        dsimp\n        ext\n        · dsimp\n          simp only [WidePushout.ι_desc_assoc, WidePushout.ι_desc]\n          rw [Category.assoc, ← X.right.map_comp]\n          rfl\n        · dsimp\n          simp [← NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.CosimplicialObject.equivalenceRightToLeft_left","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePushout f.left (fun x => f.right) fun x => f.hom\nF : CategoryTheory.Arrow C\nX : CategoryTheory.CosimplicialObject.Augmented C\nG : Quiver.Hom F (CategoryTheory.CosimplicialObject.Augmented.toArrow.obj X)\n⊢ Eq (CategoryTheory.CosimplicialObject.equivalenceRightToLeft F X G).left G.left","decl":"/-- A helper function used in defining the Čech conerve adjunction. -/\n@[simps!]\ndef equivalenceRightToLeft (F : Arrow C) (X : CosimplicialObject.Augmented C)\n    (G : F ⟶ Augmented.toArrow.obj X) : F.augmentedCechConerve ⟶ X where\n  left := G.left\n  right :=\n    { app := fun x =>\n        Limits.WidePushout.desc (G.left ≫ X.hom.app _)\n          (fun i => G.right ≫ X.right.map (SimplexCategory.const _ x i))\n          (by\n            rintro j\n            rw [← Arrow.w_assoc G]\n            have t := X.hom.naturality (SimplexCategory.const (SimplexCategory.mk 0) x j)\n            dsimp at t ⊢\n            simp only [Category.id_comp] at t\n            rw [← t])\n      naturality := by\n        intro x y f\n        dsimp\n        ext\n        · dsimp\n          simp only [WidePushout.ι_desc_assoc, WidePushout.ι_desc]\n          rw [Category.assoc, ← X.right.map_comp]\n          rfl\n        · dsimp\n          simp [← NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.CosimplicialObject.cechConerveEquiv_apply","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePushout f.left (fun x => f.right) fun x => f.hom\nF : CategoryTheory.Arrow C\nX : CategoryTheory.CosimplicialObject.Augmented C\nG : Quiver.Hom F.augmentedCechConerve X\n⊢ Eq ((CategoryTheory.CosimplicialObject.cechConerveEquiv F X) G) (CategoryTheory.CosimplicialObject.equivalenceLeftToRight F X G)","decl":"/-- A helper function used in defining the Čech conerve adjunction. -/\n@[simps]\ndef cechConerveEquiv (F : Arrow C) (X : CosimplicialObject.Augmented C) :\n    (F.augmentedCechConerve ⟶ X) ≃ (F ⟶ Augmented.toArrow.obj X) where\n  toFun := equivalenceLeftToRight _ _\n  invFun := equivalenceRightToLeft _ _\n  left_inv := by\n    intro A\n    ext x : 2\n    · rfl\n    · refine WidePushout.hom_ext _ _ _ (fun j => ?_) ?_\n      · dsimp\n        simp only [Category.assoc, ← NatTrans.naturality A.right, Arrow.augmentedCechConerve_right,\n          SimplexCategory.len_mk, Arrow.cechConerve_map, colimit.ι_desc,\n          WidePushoutShape.mkCocone_ι_app, colimit.ι_desc_assoc]\n        rfl\n      · dsimp\n        rw [colimit.ι_desc]\n        exact congr_app A.w x\n  right_inv := by\n    intro A\n    ext\n    · rfl\n    · dsimp\n      rw [WidePushout.ι_desc]\n      nth_rw 2 [← Category.comp_id A.right]\n      congr 1\n      convert X.right.map_id _\n      ext ⟨a, ha⟩\n      change a < 1 at ha\n      change 0 = a\n      omega\n\n"}
{"name":"CategoryTheory.CosimplicialObject.cechConerveEquiv_symm_apply","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ (n : Nat) (f : CategoryTheory.Arrow C), CategoryTheory.Limits.HasWidePushout f.left (fun x => f.right) fun x => f.hom\nF : CategoryTheory.Arrow C\nX : CategoryTheory.CosimplicialObject.Augmented C\nG : Quiver.Hom F (CategoryTheory.CosimplicialObject.Augmented.toArrow.obj X)\n⊢ Eq ((CategoryTheory.CosimplicialObject.cechConerveEquiv F X).symm G) (CategoryTheory.CosimplicialObject.equivalenceRightToLeft F X G)","decl":"/-- A helper function used in defining the Čech conerve adjunction. -/\n@[simps]\ndef cechConerveEquiv (F : Arrow C) (X : CosimplicialObject.Augmented C) :\n    (F.augmentedCechConerve ⟶ X) ≃ (F ⟶ Augmented.toArrow.obj X) where\n  toFun := equivalenceLeftToRight _ _\n  invFun := equivalenceRightToLeft _ _\n  left_inv := by\n    intro A\n    ext x : 2\n    · rfl\n    · refine WidePushout.hom_ext _ _ _ (fun j => ?_) ?_\n      · dsimp\n        simp only [Category.assoc, ← NatTrans.naturality A.right, Arrow.augmentedCechConerve_right,\n          SimplexCategory.len_mk, Arrow.cechConerve_map, colimit.ι_desc,\n          WidePushoutShape.mkCocone_ι_app, colimit.ι_desc_assoc]\n        rfl\n      · dsimp\n        rw [colimit.ι_desc]\n        exact congr_app A.w x\n  right_inv := by\n    intro A\n    ext\n    · rfl\n    · dsimp\n      rw [WidePushout.ι_desc]\n      nth_rw 2 [← Category.comp_id A.right]\n      congr 1\n      convert X.right.map_id _\n      ext ⟨a, ha⟩\n      change a < 1 at ha\n      change 0 = a\n      omega\n\n"}
{"name":"CategoryTheory.CechNerveTerminalFrom.hasWidePullback","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\nι : Type w\ninst✝ : Finite ι\nX : C\n⊢ CategoryTheory.Limits.HasWidePullback (CategoryTheory.Arrow.mk (CategoryTheory.Limits.terminal.from X)).right (fun x => (CategoryTheory.Arrow.mk (CategoryTheory.Limits.terminal.from X)).left) fun x => (CategoryTheory.Arrow.mk (CategoryTheory.Limits.terminal.from X)).hom","decl":"instance hasWidePullback [Finite ι] (X : C) :\n    HasWidePullback (Arrow.mk (terminal.from X)).right\n      (fun _ : ι => (Arrow.mk (terminal.from X)).left)\n      (fun _ => (Arrow.mk (terminal.from X)).hom) := by\n  cases nonempty_fintype ι\n  exact ⟨⟨wideCospan.limitCone ι X⟩⟩\n\n-- Porting note: added to make the following definitions work\n"}
{"name":"CategoryTheory.CechNerveTerminalFrom.hasWidePullback'","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\nι : Type w\ninst✝ : Finite ι\nX : C\n⊢ CategoryTheory.Limits.HasWidePullback (CategoryTheory.Limits.terminal C) (fun x => X) fun x => CategoryTheory.Limits.terminal.from X","decl":"instance hasWidePullback' [Finite ι] (X : C) :\n    HasWidePullback (⊤_ C)\n      (fun _ : ι => X)\n      (fun _ => terminal.from X) :=\n  hasWidePullback _ _\n\n-- Porting note: added to make the following definitions work\n"}
{"name":"CategoryTheory.CechNerveTerminalFrom.hasLimit_wideCospan","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\nι : Type w\ninst✝ : Finite ι\nX : C\n⊢ CategoryTheory.Limits.HasLimit (CategoryTheory.CechNerveTerminalFrom.wideCospan ι X)","decl":"instance hasLimit_wideCospan [Finite ι] (X : C) : HasLimit (wideCospan ι X) := hasWidePullback _ _\n\n-- Porting note: added to ease the definition of `iso`\n"}
{"name":"CategoryTheory.CechNerveTerminalFrom.wideCospan.limitIsoPi_inv_comp_pi_assoc","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasTerminal C\nι : Type w\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : Finite ι\nX : C\nj : ι\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CechNerveTerminalFrom.wideCospan.limitIsoPi ι X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.π (fun x => CategoryTheory.Limits.terminal.from X) j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π (fun x => X) j) h)","decl":"@[reassoc (attr := simp)]\nlemma wideCospan.limitIsoPi_inv_comp_pi [Finite ι] (X : C) (j : ι) :\n    (wideCospan.limitIsoPi ι X).inv ≫ WidePullback.π _ j = Pi.π _ j :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ _\n\n"}
{"name":"CategoryTheory.CechNerveTerminalFrom.wideCospan.limitIsoPi_inv_comp_pi","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasTerminal C\nι : Type w\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : Finite ι\nX : C\nj : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CechNerveTerminalFrom.wideCospan.limitIsoPi ι X).inv (CategoryTheory.Limits.WidePullback.π (fun x => CategoryTheory.Limits.terminal.from X) j)) (CategoryTheory.Limits.Pi.π (fun x => X) j)","decl":"@[reassoc (attr := simp)]\nlemma wideCospan.limitIsoPi_inv_comp_pi [Finite ι] (X : C) (j : ι) :\n    (wideCospan.limitIsoPi ι X).inv ≫ WidePullback.π _ j = Pi.π _ j :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ _\n\n"}
{"name":"CategoryTheory.CechNerveTerminalFrom.wideCospan.limitIsoPi_hom_comp_pi","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasTerminal C\nι : Type w\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : Finite ι\nX : C\nj : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CechNerveTerminalFrom.wideCospan.limitIsoPi ι X).hom (CategoryTheory.Limits.Pi.π (fun x => X) j)) (CategoryTheory.Limits.WidePullback.π (fun x => CategoryTheory.Limits.terminal.from X) j)","decl":"@[reassoc (attr := simp)]\nlemma wideCospan.limitIsoPi_hom_comp_pi [Finite ι] (X : C) (j : ι) :\n    (wideCospan.limitIsoPi ι X).hom ≫ Pi.π _ j = WidePullback.π _ j := by\n  rw [← wideCospan.limitIsoPi_inv_comp_pi, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.CechNerveTerminalFrom.wideCospan.limitIsoPi_hom_comp_pi_assoc","module":"Mathlib.AlgebraicTopology.CechNerve","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasTerminal C\nι : Type w\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : Finite ι\nX : C\nj : ι\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CechNerveTerminalFrom.wideCospan.limitIsoPi ι X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π (fun x => X) j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.π (fun x => CategoryTheory.Limits.terminal.from X) j) h)","decl":"@[reassoc (attr := simp)]\nlemma wideCospan.limitIsoPi_hom_comp_pi [Finite ι] (X : C) (j : ι) :\n    (wideCospan.limitIsoPi ι X).hom ≫ Pi.π _ j = WidePullback.π _ j := by\n  rw [← wideCospan.limitIsoPi_inv_comp_pi, Iso.hom_inv_id_assoc]\n\n"}
