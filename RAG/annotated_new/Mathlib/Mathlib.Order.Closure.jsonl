{"name":"ClosureOperator.idempotent'","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nself : ClosureOperator α\nx : α\n⊢ Eq (self.toFun (self.toFun x)) (self.toFun x)","decl":"/-- A closure operator on the preorder `α` is a monotone function which is extensive (every `x`\nis less than its closure) and idempotent. -/\nstructure ClosureOperator [Preorder α] extends α →o α where\n  /-- An element is less than or equal its closure -/\n  le_closure' : ∀ x, x ≤ toFun x\n  /-- Closures are idempotent -/\n  idempotent' : ∀ x, toFun (toFun x) = toFun x\n  /-- Predicate for an element to be closed.\n\n  By default, this is defined as `c.IsClosed x := (c x = x)` (see `isClosed_iff`).\n  We allow an override to fix definitional equalities. -/\n  IsClosed (x : α) : Prop := toFun x = x\n  isClosed_iff {x : α} : IsClosed x ↔ toFun x = x := by aesop\n\n"}
{"name":"ClosureOperator.mk.sizeOf_spec","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SizeOf α\ntoOrderHom : OrderHom α α\nle_closure' : ∀ (x : α), LE.le x (toOrderHom.toFun x)\nidempotent' : ∀ (x : α), Eq (toOrderHom.toFun (toOrderHom.toFun x)) (toOrderHom.toFun x)\nIsClosed : α → Prop\nisClosed_iff : autoParam (∀ {x : α}, Iff (IsClosed x) (Eq (toOrderHom.toFun x) x)) _auto✝\n⊢ Eq (SizeOf.sizeOf { toOrderHom := toOrderHom, le_closure' := le_closure', idempotent' := idempotent', IsClosed := IsClosed, isClosed_iff := isClosed_iff }) (HAdd.hAdd 1 (SizeOf.sizeOf toOrderHom))","decl":"/-- A closure operator on the preorder `α` is a monotone function which is extensive (every `x`\nis less than its closure) and idempotent. -/\nstructure ClosureOperator [Preorder α] extends α →o α where\n  /-- An element is less than or equal its closure -/\n  le_closure' : ∀ x, x ≤ toFun x\n  /-- Closures are idempotent -/\n  idempotent' : ∀ x, toFun (toFun x) = toFun x\n  /-- Predicate for an element to be closed.\n\n  By default, this is defined as `c.IsClosed x := (c x = x)` (see `isClosed_iff`).\n  We allow an override to fix definitional equalities. -/\n  IsClosed (x : α) : Prop := toFun x = x\n  isClosed_iff {x : α} : IsClosed x ↔ toFun x = x := by aesop\n\n"}
{"name":"ClosureOperator.isClosed_iff","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nself : ClosureOperator α\nx : α\n⊢ Iff (self.IsClosed x) (Eq (self.toFun x) x)","decl":"/-- A closure operator on the preorder `α` is a monotone function which is extensive (every `x`\nis less than its closure) and idempotent. -/\nstructure ClosureOperator [Preorder α] extends α →o α where\n  /-- An element is less than or equal its closure -/\n  le_closure' : ∀ x, x ≤ toFun x\n  /-- Closures are idempotent -/\n  idempotent' : ∀ x, toFun (toFun x) = toFun x\n  /-- Predicate for an element to be closed.\n\n  By default, this is defined as `c.IsClosed x := (c x = x)` (see `isClosed_iff`).\n  We allow an override to fix definitional equalities. -/\n  IsClosed (x : α) : Prop := toFun x = x\n  isClosed_iff {x : α} : IsClosed x ↔ toFun x = x := by aesop\n\n"}
{"name":"ClosureOperator.le_closure'","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nself : ClosureOperator α\nx : α\n⊢ LE.le x (self.toFun x)","decl":"/-- A closure operator on the preorder `α` is a monotone function which is extensive (every `x`\nis less than its closure) and idempotent. -/\nstructure ClosureOperator [Preorder α] extends α →o α where\n  /-- An element is less than or equal its closure -/\n  le_closure' : ∀ x, x ≤ toFun x\n  /-- Closures are idempotent -/\n  idempotent' : ∀ x, toFun (toFun x) = toFun x\n  /-- Predicate for an element to be closed.\n\n  By default, this is defined as `c.IsClosed x := (c x = x)` (see `isClosed_iff`).\n  We allow an override to fix definitional equalities. -/\n  IsClosed (x : α) : Prop := toFun x = x\n  isClosed_iff {x : α} : IsClosed x ↔ toFun x = x := by aesop\n\n"}
{"name":"ClosureOperator.mk.inj","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ntoOrderHom✝ : OrderHom α α\nle_closure'✝ : ∀ (x : α), LE.le x (toOrderHom✝.toFun x)\nidempotent'✝ : ∀ (x : α), Eq (toOrderHom✝.toFun (toOrderHom✝.toFun x)) (toOrderHom✝.toFun x)\nIsClosed✝ : α → Prop\nisClosed_iff✝ : autoParam (∀ {x : α}, Iff (IsClosed✝ x) (Eq (toOrderHom✝.toFun x) x)) _auto✝\ntoOrderHom : OrderHom α α\nle_closure' : ∀ (x : α), LE.le x (toOrderHom.toFun x)\nidempotent' : ∀ (x : α), Eq (toOrderHom.toFun (toOrderHom.toFun x)) (toOrderHom.toFun x)\nIsClosed : α → Prop\nisClosed_iff : autoParam (∀ {x : α}, Iff (IsClosed x) (Eq (toOrderHom.toFun x) x)) _auto✝\nx✝ : Eq { toOrderHom := toOrderHom✝, le_closure' := le_closure'✝, idempotent' := idempotent'✝, IsClosed := IsClosed✝, isClosed_iff := isClosed_iff✝ } { toOrderHom := toOrderHom, le_closure' := le_closure', idempotent' := idempotent', IsClosed := IsClosed, isClosed_iff := isClosed_iff }\n⊢ And (Eq toOrderHom✝ toOrderHom) (Eq IsClosed✝ IsClosed)","decl":"/-- A closure operator on the preorder `α` is a monotone function which is extensive (every `x`\nis less than its closure) and idempotent. -/\nstructure ClosureOperator [Preorder α] extends α →o α where\n  /-- An element is less than or equal its closure -/\n  le_closure' : ∀ x, x ≤ toFun x\n  /-- Closures are idempotent -/\n  idempotent' : ∀ x, toFun (toFun x) = toFun x\n  /-- Predicate for an element to be closed.\n\n  By default, this is defined as `c.IsClosed x := (c x = x)` (see `isClosed_iff`).\n  We allow an override to fix definitional equalities. -/\n  IsClosed (x : α) : Prop := toFun x = x\n  isClosed_iff {x : α} : IsClosed x ↔ toFun x = x := by aesop\n\n"}
{"name":"ClosureOperator.mk.injEq","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ntoOrderHom✝ : OrderHom α α\nle_closure'✝ : ∀ (x : α), LE.le x (toOrderHom✝.toFun x)\nidempotent'✝ : ∀ (x : α), Eq (toOrderHom✝.toFun (toOrderHom✝.toFun x)) (toOrderHom✝.toFun x)\nIsClosed✝ : α → Prop\nisClosed_iff✝ : autoParam (∀ {x : α}, Iff (IsClosed✝ x) (Eq (toOrderHom✝.toFun x) x)) _auto✝\ntoOrderHom : OrderHom α α\nle_closure' : ∀ (x : α), LE.le x (toOrderHom.toFun x)\nidempotent' : ∀ (x : α), Eq (toOrderHom.toFun (toOrderHom.toFun x)) (toOrderHom.toFun x)\nIsClosed : α → Prop\nisClosed_iff : autoParam (∀ {x : α}, Iff (IsClosed x) (Eq (toOrderHom.toFun x) x)) _auto✝\n⊢ Eq (Eq { toOrderHom := toOrderHom✝, le_closure' := le_closure'✝, idempotent' := idempotent'✝, IsClosed := IsClosed✝, isClosed_iff := isClosed_iff✝ } { toOrderHom := toOrderHom, le_closure' := le_closure', idempotent' := idempotent', IsClosed := IsClosed, isClosed_iff := isClosed_iff }) (And (Eq toOrderHom✝ toOrderHom) (Eq IsClosed✝ IsClosed))","decl":"/-- A closure operator on the preorder `α` is a monotone function which is extensive (every `x`\nis less than its closure) and idempotent. -/\nstructure ClosureOperator [Preorder α] extends α →o α where\n  /-- An element is less than or equal its closure -/\n  le_closure' : ∀ x, x ≤ toFun x\n  /-- Closures are idempotent -/\n  idempotent' : ∀ x, toFun (toFun x) = toFun x\n  /-- Predicate for an element to be closed.\n\n  By default, this is defined as `c.IsClosed x := (c x = x)` (see `isClosed_iff`).\n  We allow an override to fix definitional equalities. -/\n  IsClosed (x : α) : Prop := toFun x = x\n  isClosed_iff {x : α} : IsClosed x ↔ toFun x = x := by aesop\n\n"}
{"name":"ClosureOperator.instOrderHomClass","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ OrderHomClass (ClosureOperator α) α α","decl":"instance [Preorder α] : OrderHomClass (ClosureOperator α) α α where\n  map_rel f _ _ h := f.mono h\n\n"}
{"name":"ClosureOperator.conjBy_apply","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nc : ClosureOperator α\ne : OrderIso α β\na : β\n⊢ Eq ((c.conjBy e) a) ((e.conj ↑c) a)","decl":"/-- If `c` is a closure operator on `α` and `e` an order-isomorphism\nbetween `α` and `β` then `e ∘ c ∘ e⁻¹` is a closure operator on `β`. -/\n@[simps apply]\ndef conjBy {α β} [Preorder α] [Preorder β] (c : ClosureOperator α)\n    (e : α ≃o β) : ClosureOperator β where\n  toFun := e.conj c\n  IsClosed b := c.IsClosed (e.symm b)\n  monotone' _ _ h :=\n    (map_le_map_iff e).mpr <| c.monotone <| (map_le_map_iff e.symm).mpr h\n  le_closure' _ := e.symm_apply_le.mp (c.le_closure' _)\n  idempotent' _ :=\n    congrArg e <| Eq.trans (congrArg c (e.symm_apply_apply _)) (c.idempotent' _)\n  isClosed_iff := Iff.trans c.isClosed_iff e.eq_symm_apply\n\n"}
{"name":"ClosureOperator.conjBy_refl","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_4\ninst✝ : Preorder α\nc : ClosureOperator α\n⊢ Eq (c.conjBy (OrderIso.refl α)) c","decl":"lemma conjBy_refl {α} [Preorder α] (c : ClosureOperator α) :\n    c.conjBy (OrderIso.refl α) = c := rfl\n\n"}
{"name":"ClosureOperator.conjBy_trans","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_4\nβ : Type u_5\nγ : Type u_6\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ne₁ : OrderIso α β\ne₂ : OrderIso β γ\nc : ClosureOperator α\n⊢ Eq (c.conjBy (e₁.trans e₂)) ((c.conjBy e₁).conjBy e₂)","decl":"lemma conjBy_trans {α β γ} [Preorder α] [Preorder β] [Preorder γ]\n    (e₁ : α ≃o β) (e₂ : β ≃o γ) (c : ClosureOperator α) :\n    c.conjBy (e₁.trans e₂) = (c.conjBy e₁).conjBy e₂ := rfl\n\n"}
{"name":"ClosureOperator.id_isClosed","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nx✝ : α\n⊢ Eq ((ClosureOperator.id α).IsClosed x✝) True","decl":"/-- The identity function as a closure operator. -/\n@[simps!]\ndef id : ClosureOperator α where\n  toOrderHom := OrderHom.id\n  le_closure' _ := le_rfl\n  idempotent' _ := rfl\n  IsClosed _ := True\n\n"}
{"name":"ClosureOperator.id_apply","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na : α\n⊢ Eq ((ClosureOperator.id α) a) a","decl":"/-- The identity function as a closure operator. -/\n@[simps!]\ndef id : ClosureOperator α where\n  toOrderHom := OrderHom.id\n  le_closure' _ := le_rfl\n  idempotent' _ := rfl\n  IsClosed _ := True\n\n"}
{"name":"ClosureOperator.ext_iff","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nc₁ c₂ : ClosureOperator α\n⊢ Iff (Eq c₁ c₂) (∀ (x : α), Eq (c₁ x) (c₂ x))","decl":"@[ext]\ntheorem ext : ∀ c₁ c₂ : ClosureOperator α, (∀ x, c₁ x = c₂ x) → c₁ = c₂ :=\n  DFunLike.ext\n\n"}
{"name":"ClosureOperator.ext","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nc₁ c₂ : ClosureOperator α\na✝ : ∀ (x : α), Eq (c₁ x) (c₂ x)\n⊢ Eq c₁ c₂","decl":"@[ext]\ntheorem ext : ∀ c₁ c₂ : ClosureOperator α, (∀ x, c₁ x = c₂ x) → c₁ = c₂ :=\n  DFunLike.ext\n\n"}
{"name":"ClosureOperator.mk'_apply","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nf : α → α\nhf₁ : Monotone f\nhf₂ : ∀ (x : α), LE.le x (f x)\nhf₃ : ∀ (x : α), LE.le (f (f x)) (f x)\na✝ : α\n⊢ Eq ((ClosureOperator.mk' f hf₁ hf₂ hf₃) a✝) (f a✝)","decl":"/-- Constructor for a closure operator using the weaker idempotency axiom: `f (f x) ≤ f x`. -/\n@[simps]\ndef mk' (f : α → α) (hf₁ : Monotone f) (hf₂ : ∀ x, x ≤ f x) (hf₃ : ∀ x, f (f x) ≤ f x) :\n    ClosureOperator α where\n  toFun := f\n  monotone' := hf₁\n  le_closure' := hf₂\n  idempotent' x := (hf₃ x).antisymm (hf₁ (hf₂ x))\n\n"}
{"name":"ClosureOperator.mk'_isClosed","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nf : α → α\nhf₁ : Monotone f\nhf₂ : ∀ (x : α), LE.le x (f x)\nhf₃ : ∀ (x : α), LE.le (f (f x)) (f x)\nx : α\n⊢ Eq ((ClosureOperator.mk' f hf₁ hf₂ hf₃).IsClosed x) (Eq (f x) x)","decl":"/-- Constructor for a closure operator using the weaker idempotency axiom: `f (f x) ≤ f x`. -/\n@[simps]\ndef mk' (f : α → α) (hf₁ : Monotone f) (hf₂ : ∀ x, x ≤ f x) (hf₃ : ∀ x, f (f x) ≤ f x) :\n    ClosureOperator α where\n  toFun := f\n  monotone' := hf₁\n  le_closure' := hf₂\n  idempotent' x := (hf₃ x).antisymm (hf₁ (hf₂ x))\n\n"}
{"name":"ClosureOperator.mk₂_apply","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nf : α → α\nhf : ∀ (x : α), LE.le x (f x)\nhmin : ∀ ⦃x y : α⦄, LE.le x (f y) → LE.le (f x) (f y)\na✝ : α\n⊢ Eq ((ClosureOperator.mk₂ f hf hmin) a✝) (f a✝)","decl":"/-- Convenience constructor for a closure operator using the weaker minimality axiom:\n`x ≤ f y → f x ≤ f y`, which is sometimes easier to prove in practice. -/\n@[simps]\ndef mk₂ (f : α → α) (hf : ∀ x, x ≤ f x) (hmin : ∀ ⦃x y⦄, x ≤ f y → f x ≤ f y) :\n    ClosureOperator α where\n  toFun := f\n  monotone' _ y hxy := hmin (hxy.trans (hf y))\n  le_closure' := hf\n  idempotent' _ := (hmin le_rfl).antisymm (hf _)\n\n"}
{"name":"ClosureOperator.mk₂_isClosed","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nf : α → α\nhf : ∀ (x : α), LE.le x (f x)\nhmin : ∀ ⦃x y : α⦄, LE.le x (f y) → LE.le (f x) (f y)\nx : α\n⊢ Eq ((ClosureOperator.mk₂ f hf hmin).IsClosed x) (Eq (f x) x)","decl":"/-- Convenience constructor for a closure operator using the weaker minimality axiom:\n`x ≤ f y → f x ≤ f y`, which is sometimes easier to prove in practice. -/\n@[simps]\ndef mk₂ (f : α → α) (hf : ∀ x, x ≤ f x) (hmin : ∀ ⦃x y⦄, x ≤ f y → f x ≤ f y) :\n    ClosureOperator α where\n  toFun := f\n  monotone' _ y hxy := hmin (hxy.trans (hf y))\n  le_closure' := hf\n  idempotent' _ := (hmin le_rfl).antisymm (hf _)\n\n"}
{"name":"ClosureOperator.ofPred_isClosed","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nf : α → α\np : α → Prop\nhf : ∀ (x : α), LE.le x (f x)\nhfp : ∀ (x : α), p (f x)\nhmin : ∀ ⦃x y : α⦄, LE.le x y → p y → LE.le (f x) y\na✝ : α\n⊢ Eq ((ClosureOperator.ofPred f p hf hfp hmin).IsClosed a✝) (p a✝)","decl":"/-- Construct a closure operator from an inflationary function `f` and a \"closedness\" predicate `p`\nwitnessing minimality of `f x` among closed elements greater than `x`. -/\n@[simps!]\ndef ofPred (f : α → α) (p : α → Prop) (hf : ∀ x, x ≤ f x) (hfp : ∀ x, p (f x))\n    (hmin : ∀ ⦃x y⦄, x ≤ y → p y → f x ≤ y) : ClosureOperator α where\n  __ := mk₂ f hf fun _ y hxy => hmin hxy (hfp y)\n  IsClosed := p\n  isClosed_iff := ⟨fun hx ↦ (hmin le_rfl hx).antisymm <| hf _, fun hx ↦ hx ▸ hfp _⟩\n\n"}
{"name":"ClosureOperator.ofPred_apply","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nf : α → α\np : α → Prop\nhf : ∀ (x : α), LE.le x (f x)\nhfp : ∀ (x : α), p (f x)\nhmin : ∀ ⦃x y : α⦄, LE.le x y → p y → LE.le (f x) y\na✝ : α\n⊢ Eq ((ClosureOperator.ofPred f p hf hfp hmin) a✝) (f a✝)","decl":"/-- Construct a closure operator from an inflationary function `f` and a \"closedness\" predicate `p`\nwitnessing minimality of `f x` among closed elements greater than `x`. -/\n@[simps!]\ndef ofPred (f : α → α) (p : α → Prop) (hf : ∀ x, x ≤ f x) (hfp : ∀ x, p (f x))\n    (hmin : ∀ ⦃x y⦄, x ≤ y → p y → f x ≤ y) : ClosureOperator α where\n  __ := mk₂ f hf fun _ y hxy => hmin hxy (hfp y)\n  IsClosed := p\n  isClosed_iff := ⟨fun hx ↦ (hmin le_rfl hx).antisymm <| hf _, fun hx ↦ hx ▸ hfp _⟩\n\n"}
{"name":"ClosureOperator.monotone","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nc : ClosureOperator α\n⊢ Monotone ⇑c","decl":"@[mono]\ntheorem monotone : Monotone c :=\n  c.monotone'\n\n"}
{"name":"ClosureOperator.le_closure","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nc : ClosureOperator α\nx : α\n⊢ LE.le x (c x)","decl":"/-- Every element is less than its closure. This property is sometimes referred to as extensivity or\ninflationarity. -/\ntheorem le_closure (x : α) : x ≤ c x :=\n  c.le_closure' x\n\n"}
{"name":"ClosureOperator.idempotent","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nc : ClosureOperator α\nx : α\n⊢ Eq (c (c x)) (c x)","decl":"@[simp]\ntheorem idempotent (x : α) : c (c x) = c x :=\n  c.idempotent' x\n\n"}
{"name":"ClosureOperator.isClosed_closure","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nc : ClosureOperator α\nx : α\n⊢ c.IsClosed (c x)","decl":"@[simp] lemma isClosed_closure (x : α) : c.IsClosed (c x) := c.isClosed_iff.2 <| c.idempotent x\n\n"}
{"name":"ClosureOperator.IsClosed.closure_eq","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nc : ClosureOperator α\nx : α\na✝ : c.IsClosed x\n⊢ Eq (c x) x","decl":"theorem IsClosed.closure_eq : c.IsClosed x → c x = x := c.isClosed_iff.1\n\n"}
{"name":"ClosureOperator.isClosed_iff_closure_le","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nc : ClosureOperator α\nx : α\n⊢ Iff (c.IsClosed x) (LE.le (c x) x)","decl":"theorem isClosed_iff_closure_le : c.IsClosed x ↔ c x ≤ x :=\n  ⟨fun h ↦ h.closure_eq.le, fun h ↦ c.isClosed_iff.2 <| h.antisymm <| c.le_closure x⟩\n\n"}
{"name":"ClosureOperator.setOf_isClosed_eq_range_closure","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nc : ClosureOperator α\n⊢ Eq (setOf fun x => c.IsClosed x) (Set.range ⇑c)","decl":"/-- The set of closed elements for `c` is exactly its range. -/\ntheorem setOf_isClosed_eq_range_closure : {x | c.IsClosed x} = Set.range c := by\n  ext x; exact ⟨fun hx ↦ ⟨x, hx.closure_eq⟩, by rintro ⟨y, rfl⟩; exact c.isClosed_closure _⟩\n\n"}
{"name":"ClosureOperator.le_closure_iff","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nc : ClosureOperator α\nx y : α\n⊢ Iff (LE.le x (c y)) (LE.le (c x) (c y))","decl":"theorem le_closure_iff : x ≤ c y ↔ c x ≤ c y :=\n  ⟨fun h ↦ c.idempotent y ▸ c.monotone h, (c.le_closure x).trans⟩\n\n"}
{"name":"ClosureOperator.IsClosed.closure_le_iff","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nc : ClosureOperator α\nx y : α\nhy : c.IsClosed y\n⊢ Iff (LE.le (c x) y) (LE.le x y)","decl":"@[simp]\ntheorem IsClosed.closure_le_iff (hy : c.IsClosed y) : c x ≤ y ↔ x ≤ y := by\n  rw [← hy.closure_eq, ← le_closure_iff]\n\n"}
{"name":"ClosureOperator.closure_min","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nc : ClosureOperator α\nx y : α\nhxy : LE.le x y\nhy : c.IsClosed y\n⊢ LE.le (c x) y","decl":"lemma closure_min (hxy : x ≤ y) (hy : c.IsClosed y) : c x ≤ y := hy.closure_le_iff.2 hxy\n\n"}
{"name":"ClosureOperator.closure_isGLB","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nc : ClosureOperator α\nx : α\n⊢ IsGLB (setOf fun y => And (LE.le x y) (c.IsClosed y)) (c x)","decl":"lemma closure_isGLB (x : α) : IsGLB { y | x ≤ y ∧ c.IsClosed y } (c x) where\n  left _ := and_imp.mpr closure_min\n  right _ h := h ⟨c.le_closure x, c.isClosed_closure x⟩\n\n"}
{"name":"ClosureOperator.ext_isClosed","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nc₁ c₂ : ClosureOperator α\nh : ∀ (x : α), Iff (c₁.IsClosed x) (c₂.IsClosed x)\n⊢ Eq c₁ c₂","decl":"theorem ext_isClosed (c₁ c₂ : ClosureOperator α)\n    (h : ∀ x, c₁.IsClosed x ↔ c₂.IsClosed x) : c₁ = c₂ :=\n  ext c₁ c₂ <| fun x => IsGLB.unique (c₁.closure_isGLB x) <|\n    (Set.ext (and_congr_right' <| h ·)).substr (c₂.closure_isGLB x)\n\n"}
{"name":"ClosureOperator.eq_ofPred_closed","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nc : ClosureOperator α\n⊢ Eq c (ClosureOperator.ofPred (⇑c) c.IsClosed ⋯ ⋯ ⋯)","decl":"/-- A closure operator is equal to the closure operator obtained by feeding `c.closed` into the\n`ofPred` constructor. -/\ntheorem eq_ofPred_closed (c : ClosureOperator α) :\n    c = ofPred c c.IsClosed c.le_closure c.isClosed_closure fun _ _ ↦ closure_min := by\n  ext\n  rfl\n\n"}
{"name":"ClosureOperator.closure_top","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\nc : ClosureOperator α\n⊢ Eq (c Top.top) Top.top","decl":"@[simp]\ntheorem closure_top : c ⊤ = ⊤ :=\n  le_top.antisymm (c.le_closure _)\n\n"}
{"name":"ClosureOperator.isClosed_top","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\nc : ClosureOperator α\n⊢ c.IsClosed Top.top","decl":"@[simp] lemma isClosed_top : c.IsClosed ⊤ := c.isClosed_iff.2 c.closure_top\n\n"}
{"name":"ClosureOperator.closure_inf_le","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : SemilatticeInf α\nc : ClosureOperator α\nx y : α\n⊢ LE.le (c (Min.min x y)) (Min.min (c x) (c y))","decl":"theorem closure_inf_le [SemilatticeInf α] (c : ClosureOperator α) (x y : α) :\n    c (x ⊓ y) ≤ c x ⊓ c y :=\n  c.monotone.map_inf_le _ _\n\n"}
{"name":"ClosureOperator.closure_sup_closure_le","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : SemilatticeSup α\nc : ClosureOperator α\nx y : α\n⊢ LE.le (Max.max (c x) (c y)) (c (Max.max x y))","decl":"theorem closure_sup_closure_le (x y : α) : c x ⊔ c y ≤ c (x ⊔ y) :=\n  c.monotone.le_map_sup _ _\n\n"}
{"name":"ClosureOperator.closure_sup_closure_left","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : SemilatticeSup α\nc : ClosureOperator α\nx y : α\n⊢ Eq (c (Max.max (c x) y)) (c (Max.max x y))","decl":"theorem closure_sup_closure_left (x y : α) : c (c x ⊔ y) = c (x ⊔ y) :=\n  (le_closure_iff.1\n        (sup_le (c.monotone le_sup_left) (le_sup_right.trans (c.le_closure _)))).antisymm\n    (c.monotone (sup_le_sup_right (c.le_closure _) _))\n\n"}
{"name":"ClosureOperator.closure_sup_closure_right","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : SemilatticeSup α\nc : ClosureOperator α\nx y : α\n⊢ Eq (c (Max.max x (c y))) (c (Max.max x y))","decl":"theorem closure_sup_closure_right (x y : α) : c (x ⊔ c y) = c (x ⊔ y) := by\n  rw [sup_comm, closure_sup_closure_left, sup_comm (a := x)]\n\n"}
{"name":"ClosureOperator.closure_sup_closure","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : SemilatticeSup α\nc : ClosureOperator α\nx y : α\n⊢ Eq (c (Max.max (c x) (c y))) (c (Max.max x y))","decl":"theorem closure_sup_closure (x y : α) : c (c x ⊔ c y) = c (x ⊔ y) := by\n  rw [closure_sup_closure_left, closure_sup_closure_right]\n\n"}
{"name":"ClosureOperator.ofCompletePred_isClosed","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\np : α → Prop\nhsinf : ∀ (s : Set α), (∀ (a : α), Membership.mem s a → p a) → p (InfSet.sInf s)\na✝ : α\n⊢ Eq ((ClosureOperator.ofCompletePred p hsinf).IsClosed a✝) (p a✝)","decl":"/-- Define a closure operator from a predicate that's preserved under infima. -/\n@[simps!]\ndef ofCompletePred (p : α → Prop) (hsinf : ∀ s, (∀ a ∈ s, p a) → p (sInf s)) : ClosureOperator α :=\n  ofPred (fun a ↦ ⨅ b : {b // a ≤ b ∧ p b}, b) p\n    (fun a ↦ by simp (config := {contextual := true}))\n    (fun _ ↦ hsinf _ <| forall_mem_range.2 fun b ↦ b.2.2)\n    (fun _ b hab hb ↦ iInf_le_of_le ⟨b, hab, hb⟩ le_rfl)\n\n"}
{"name":"ClosureOperator.ofCompletePred_apply","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\np : α → Prop\nhsinf : ∀ (s : Set α), (∀ (a : α), Membership.mem s a → p a) → p (InfSet.sInf s)\na : α\n⊢ Eq ((ClosureOperator.ofCompletePred p hsinf) a) (iInf fun b => ↑b)","decl":"/-- Define a closure operator from a predicate that's preserved under infima. -/\n@[simps!]\ndef ofCompletePred (p : α → Prop) (hsinf : ∀ s, (∀ a ∈ s, p a) → p (sInf s)) : ClosureOperator α :=\n  ofPred (fun a ↦ ⨅ b : {b // a ≤ b ∧ p b}, b) p\n    (fun a ↦ by simp (config := {contextual := true}))\n    (fun _ ↦ hsinf _ <| forall_mem_range.2 fun b ↦ b.2.2)\n    (fun _ b hab hb ↦ iInf_le_of_le ⟨b, hab, hb⟩ le_rfl)\n\n"}
{"name":"ClosureOperator.sInf_isClosed","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nc : ClosureOperator α\nS : Set α\nH : ∀ (x : α), Membership.mem S x → c.IsClosed x\n⊢ c.IsClosed (InfSet.sInf S)","decl":"theorem sInf_isClosed {c : ClosureOperator α} {S : Set α}\n    (H : ∀ x ∈ S, c.IsClosed x) : c.IsClosed (sInf S) :=\n  isClosed_iff_closure_le.mpr <| le_of_le_of_eq c.monotone.map_sInf_le <|\n    Eq.trans (biInf_congr (c.isClosed_iff.mp <| H · ·)) sInf_eq_iInf.symm\n\n"}
{"name":"ClosureOperator.closure_iSup_closure","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nι : Sort u_2\ninst✝ : CompleteLattice α\nc : ClosureOperator α\nf : ι → α\n⊢ Eq (c (iSup fun i => c (f i))) (c (iSup fun i => f i))","decl":"@[simp]\ntheorem closure_iSup_closure (f : ι → α) : c (⨆ i, c (f i)) = c (⨆ i, f i) :=\n  le_antisymm (le_closure_iff.1 <| iSup_le fun i => c.monotone <| le_iSup f i) <|\n    c.monotone <| iSup_mono fun _ => c.le_closure _\n\n"}
{"name":"ClosureOperator.closure_iSup₂_closure","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nι : Sort u_2\nκ : ι → Sort u_3\ninst✝ : CompleteLattice α\nc : ClosureOperator α\nf : (i : ι) → κ i → α\n⊢ Eq (c (iSup fun i => iSup fun j => c (f i j))) (c (iSup fun i => iSup fun j => f i j))","decl":"@[simp]\ntheorem closure_iSup₂_closure (f : ∀ i, κ i → α) :\n    c (⨆ (i) (j), c (f i j)) = c (⨆ (i) (j), f i j) :=\n  le_antisymm (le_closure_iff.1 <| iSup₂_le fun i j => c.monotone <| le_iSup₂ i j) <|\n    c.monotone <| iSup₂_mono fun _ _ => c.le_closure _\n\n"}
{"name":"OrderIso.equivClosureOperator_symm_apply","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderIso α β\nc : ClosureOperator β\n⊢ Eq (e.equivClosureOperator.symm c) (c.conjBy e.symm)","decl":"/-- Conjugating `ClosureOperators` on `α` and on `β` by a fixed isomorphism\n`e : α ≃o β` gives an equivalence `ClosureOperator α ≃ ClosureOperator β`. -/\n@[simps apply symm_apply]\ndef OrderIso.equivClosureOperator {α β} [Preorder α] [Preorder β] (e : α ≃o β) :\n    ClosureOperator α ≃ ClosureOperator β where\n  toFun     c := c.conjBy e\n  invFun    c := c.conjBy e.symm\n  left_inv  c := Eq.trans (c.conjBy_trans _ _).symm\n                 <| Eq.trans (congrArg _ e.self_trans_symm) c.conjBy_refl\n  right_inv c := Eq.trans (c.conjBy_trans _ _).symm\n                 <| Eq.trans (congrArg _ e.symm_trans_self) c.conjBy_refl\n\n"}
{"name":"OrderIso.equivClosureOperator_apply","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderIso α β\nc : ClosureOperator α\n⊢ Eq (e.equivClosureOperator c) (c.conjBy e)","decl":"/-- Conjugating `ClosureOperators` on `α` and on `β` by a fixed isomorphism\n`e : α ≃o β` gives an equivalence `ClosureOperator α ≃ ClosureOperator β`. -/\n@[simps apply symm_apply]\ndef OrderIso.equivClosureOperator {α β} [Preorder α] [Preorder β] (e : α ≃o β) :\n    ClosureOperator α ≃ ClosureOperator β where\n  toFun     c := c.conjBy e\n  invFun    c := c.conjBy e.symm\n  left_inv  c := Eq.trans (c.conjBy_trans _ _).symm\n                 <| Eq.trans (congrArg _ e.self_trans_symm) c.conjBy_refl\n  right_inv c := Eq.trans (c.conjBy_trans _ _).symm\n                 <| Eq.trans (congrArg _ e.symm_trans_self) c.conjBy_refl\n\n"}
{"name":"LowerAdjoint.mk.sizeOf_spec","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝³ : Preorder α\ninst✝² : Preorder β\nu : β → α\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoFun : α → β\ngc' : GaloisConnection toFun u\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, gc' := gc' }) 1","decl":"/-- A lower adjoint of `u` on the preorder `α` is a function `l` such that `l` and `u` form a Galois\nconnection. It allows us to define closure operators whose output does not match the input. In\npractice, `u` is often `(↑) : β → α`. -/\nstructure LowerAdjoint [Preorder α] [Preorder β] (u : β → α) where\n  /-- The underlying function -/\n  toFun : α → β\n  /-- The underlying function is a lower adjoint. -/\n  gc' : GaloisConnection toFun u\n\n"}
{"name":"LowerAdjoint.mk.injEq","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nu : β → α\ntoFun✝ : α → β\ngc'✝ : GaloisConnection toFun✝ u\ntoFun : α → β\ngc' : GaloisConnection toFun u\n⊢ Eq (Eq { toFun := toFun✝, gc' := gc'✝ } { toFun := toFun, gc' := gc' }) (Eq toFun✝ toFun)","decl":"/-- A lower adjoint of `u` on the preorder `α` is a function `l` such that `l` and `u` form a Galois\nconnection. It allows us to define closure operators whose output does not match the input. In\npractice, `u` is often `(↑) : β → α`. -/\nstructure LowerAdjoint [Preorder α] [Preorder β] (u : β → α) where\n  /-- The underlying function -/\n  toFun : α → β\n  /-- The underlying function is a lower adjoint. -/\n  gc' : GaloisConnection toFun u\n\n"}
{"name":"LowerAdjoint.gc'","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nu : β → α\nself : LowerAdjoint u\n⊢ GaloisConnection self.toFun u","decl":"/-- A lower adjoint of `u` on the preorder `α` is a function `l` such that `l` and `u` form a Galois\nconnection. It allows us to define closure operators whose output does not match the input. In\npractice, `u` is often `(↑) : β → α`. -/\nstructure LowerAdjoint [Preorder α] [Preorder β] (u : β → α) where\n  /-- The underlying function -/\n  toFun : α → β\n  /-- The underlying function is a lower adjoint. -/\n  gc' : GaloisConnection toFun u\n\n"}
{"name":"LowerAdjoint.mk.inj","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nu : β → α\ntoFun✝ : α → β\ngc'✝ : GaloisConnection toFun✝ u\ntoFun : α → β\ngc' : GaloisConnection toFun u\nx✝ : Eq { toFun := toFun✝, gc' := gc'✝ } { toFun := toFun, gc' := gc' }\n⊢ Eq toFun✝ toFun","decl":"/-- A lower adjoint of `u` on the preorder `α` is a function `l` such that `l` and `u` form a Galois\nconnection. It allows us to define closure operators whose output does not match the input. In\npractice, `u` is often `(↑) : β → α`. -/\nstructure LowerAdjoint [Preorder α] [Preorder β] (u : β → α) where\n  /-- The underlying function -/\n  toFun : α → β\n  /-- The underlying function is a lower adjoint. -/\n  gc' : GaloisConnection toFun u\n\n"}
{"name":"LowerAdjoint.id_toFun","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\n⊢ Eq ((LowerAdjoint.id α).toFun x) x","decl":"/-- The identity function as a lower adjoint to itself. -/\n@[simps]\nprotected def id [Preorder α] : LowerAdjoint (id : α → α) where\n  toFun x := x\n  gc' := GaloisConnection.id\n\n"}
{"name":"LowerAdjoint.gc","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nu : β → α\nl : LowerAdjoint u\n⊢ GaloisConnection l.toFun u","decl":"theorem gc : GaloisConnection l u :=\n  l.gc'\n\n"}
{"name":"LowerAdjoint.ext_iff","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nu : β → α\nl₁ l₂ : LowerAdjoint u\n⊢ Iff (Eq l₁ l₂) (Eq l₁.toFun l₂.toFun)","decl":"@[ext]\ntheorem ext : ∀ l₁ l₂ : LowerAdjoint u, (l₁ : α → β) = (l₂ : α → β) → l₁ = l₂\n  | ⟨l₁, _⟩, ⟨l₂, _⟩, h => by\n    congr\n\n"}
{"name":"LowerAdjoint.ext","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nu : β → α\nl₁ l₂ : LowerAdjoint u\na✝ : Eq l₁.toFun l₂.toFun\n⊢ Eq l₁ l₂","decl":"@[ext]\ntheorem ext : ∀ l₁ l₂ : LowerAdjoint u, (l₁ : α → β) = (l₂ : α → β) → l₁ = l₂\n  | ⟨l₁, _⟩, ⟨l₂, _⟩, h => by\n    congr\n\n"}
{"name":"LowerAdjoint.monotone","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nu : β → α\nl : LowerAdjoint u\n⊢ Monotone (Function.comp u l.toFun)","decl":"@[mono]\ntheorem monotone : Monotone (u ∘ l) :=\n  l.gc.monotone_u.comp l.gc.monotone_l\n\n"}
{"name":"LowerAdjoint.le_closure","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nu : β → α\nl : LowerAdjoint u\nx : α\n⊢ LE.le x (u (l.toFun x))","decl":"/-- Every element is less than its closure. This property is sometimes referred to as extensivity or\ninflationarity. -/\ntheorem le_closure (x : α) : x ≤ u (l x) :=\n  l.gc.le_u_l _\n\n"}
{"name":"LowerAdjoint.closureOperator_apply","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nu : β → α\nl : LowerAdjoint u\nx : α\n⊢ Eq (l.closureOperator x) (u (l.toFun x))","decl":"/-- Every lower adjoint induces a closure operator given by the composition. This is the partial\norder version of the statement that every adjunction induces a monad. -/\n@[simps]\ndef closureOperator : ClosureOperator α where\n  toFun x := u (l x)\n  monotone' := l.monotone\n  le_closure' := l.le_closure\n  idempotent' x := l.gc.u_l_u_eq_u (l x)\n\n"}
{"name":"LowerAdjoint.closureOperator_isClosed","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nu : β → α\nl : LowerAdjoint u\nx : α\n⊢ Eq (l.closureOperator.IsClosed x) (Eq (u (l.toFun x)) x)","decl":"/-- Every lower adjoint induces a closure operator given by the composition. This is the partial\norder version of the statement that every adjunction induces a monad. -/\n@[simps]\ndef closureOperator : ClosureOperator α where\n  toFun x := u (l x)\n  monotone' := l.monotone\n  le_closure' := l.le_closure\n  idempotent' x := l.gc.u_l_u_eq_u (l x)\n\n"}
{"name":"LowerAdjoint.idempotent","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nu : β → α\nl : LowerAdjoint u\nx : α\n⊢ Eq (u (l.toFun (u (l.toFun x)))) (u (l.toFun x))","decl":"theorem idempotent (x : α) : u (l (u (l x))) = u (l x) :=\n  l.closureOperator.idempotent _\n\n"}
{"name":"LowerAdjoint.le_closure_iff","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nu : β → α\nl : LowerAdjoint u\nx y : α\n⊢ Iff (LE.le x (u (l.toFun y))) (LE.le (u (l.toFun x)) (u (l.toFun y)))","decl":"theorem le_closure_iff (x y : α) : x ≤ u (l y) ↔ u (l x) ≤ u (l y) :=\n  l.closureOperator.le_closure_iff\n\n"}
{"name":"LowerAdjoint.mem_closed_iff","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nu : β → α\nl : LowerAdjoint u\nx : α\n⊢ Iff (Membership.mem l.closed x) (Eq (u (l.toFun x)) x)","decl":"theorem mem_closed_iff (x : α) : x ∈ l.closed ↔ u (l x) = x :=\n  Iff.rfl\n\n"}
{"name":"LowerAdjoint.closure_eq_self_of_mem_closed","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nu : β → α\nl : LowerAdjoint u\nx : α\nh : Membership.mem l.closed x\n⊢ Eq (u (l.toFun x)) x","decl":"theorem closure_eq_self_of_mem_closed {x : α} (h : x ∈ l.closed) : u (l x) = x :=\n  h\n\n"}
{"name":"LowerAdjoint.mem_closed_iff_closure_le","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\nu : β → α\nl : LowerAdjoint u\nx : α\n⊢ Iff (Membership.mem l.closed x) (LE.le (u (l.toFun x)) x)","decl":"theorem mem_closed_iff_closure_le (x : α) : x ∈ l.closed ↔ u (l x) ≤ x :=\n  l.closureOperator.isClosed_iff_closure_le\n\n"}
{"name":"LowerAdjoint.closure_is_closed","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\nu : β → α\nl : LowerAdjoint u\nx : α\n⊢ Membership.mem l.closed (u (l.toFun x))","decl":"@[simp]\ntheorem closure_is_closed (x : α) : u (l x) ∈ l.closed :=\n  l.idempotent x\n\n"}
{"name":"LowerAdjoint.closed_eq_range_close","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\nu : β → α\nl : LowerAdjoint u\n⊢ Eq l.closed (Set.range (Function.comp u l.toFun))","decl":"/-- The set of closed elements for `l` is the range of `u ∘ l`. -/\ntheorem closed_eq_range_close : l.closed = Set.range (u ∘ l) :=\n  l.closureOperator.setOf_isClosed_eq_range_closure\n\n"}
{"name":"LowerAdjoint.closure_le_closed_iff_le","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\nu : β → α\nl : LowerAdjoint u\nx y : α\nhy : l.closed y\n⊢ Iff (LE.le (u (l.toFun x)) y) (LE.le x y)","decl":"@[simp]\ntheorem closure_le_closed_iff_le (x : α) {y : α} (hy : l.closed y) : u (l x) ≤ y ↔ x ≤ y :=\n  (show l.closureOperator.IsClosed y from hy).closure_le_iff\n\n"}
{"name":"LowerAdjoint.closure_top","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝² : PartialOrder α\ninst✝¹ : OrderTop α\ninst✝ : Preorder β\nu : β → α\nl : LowerAdjoint u\n⊢ Eq (u (l.toFun Top.top)) Top.top","decl":"theorem closure_top [PartialOrder α] [OrderTop α] [Preorder β] {u : β → α} (l : LowerAdjoint u) :\n    u (l ⊤) = ⊤ :=\n  l.closureOperator.closure_top\n\n"}
{"name":"LowerAdjoint.closure_inf_le","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : SemilatticeInf α\ninst✝ : Preorder β\nu : β → α\nl : LowerAdjoint u\nx y : α\n⊢ LE.le (u (l.toFun (Min.min x y))) (Min.min (u (l.toFun x)) (u (l.toFun y)))","decl":"theorem closure_inf_le [SemilatticeInf α] [Preorder β] {u : β → α} (l : LowerAdjoint u) (x y : α) :\n    u (l (x ⊓ y)) ≤ u (l x) ⊓ u (l y) :=\n  l.closureOperator.closure_inf_le x y\n\n"}
{"name":"LowerAdjoint.closure_sup_closure_le","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : SemilatticeSup α\ninst✝ : Preorder β\nu : β → α\nl : LowerAdjoint u\nx y : α\n⊢ LE.le (Max.max (u (l.toFun x)) (u (l.toFun y))) (u (l.toFun (Max.max x y)))","decl":"theorem closure_sup_closure_le (x y : α) : u (l x) ⊔ u (l y) ≤ u (l (x ⊔ y)) :=\n  l.closureOperator.closure_sup_closure_le x y\n\n"}
{"name":"LowerAdjoint.closure_sup_closure_left","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : SemilatticeSup α\ninst✝ : Preorder β\nu : β → α\nl : LowerAdjoint u\nx y : α\n⊢ Eq (u (l.toFun (Max.max (u (l.toFun x)) y))) (u (l.toFun (Max.max x y)))","decl":"theorem closure_sup_closure_left (x y : α) : u (l (u (l x) ⊔ y)) = u (l (x ⊔ y)) :=\n  l.closureOperator.closure_sup_closure_left x y\n\n"}
{"name":"LowerAdjoint.closure_sup_closure_right","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : SemilatticeSup α\ninst✝ : Preorder β\nu : β → α\nl : LowerAdjoint u\nx y : α\n⊢ Eq (u (l.toFun (Max.max x (u (l.toFun y))))) (u (l.toFun (Max.max x y)))","decl":"theorem closure_sup_closure_right (x y : α) : u (l (x ⊔ u (l y))) = u (l (x ⊔ y)) :=\n  l.closureOperator.closure_sup_closure_right x y\n\n"}
{"name":"LowerAdjoint.closure_sup_closure","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : SemilatticeSup α\ninst✝ : Preorder β\nu : β → α\nl : LowerAdjoint u\nx y : α\n⊢ Eq (u (l.toFun (Max.max (u (l.toFun x)) (u (l.toFun y))))) (u (l.toFun (Max.max x y)))","decl":"theorem closure_sup_closure (x y : α) : u (l (u (l x) ⊔ u (l y))) = u (l (x ⊔ y)) :=\n  l.closureOperator.closure_sup_closure x y\n\n"}
{"name":"LowerAdjoint.closure_iSup_closure","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nι : Sort u_2\nβ : Type u_4\ninst✝¹ : CompleteLattice α\ninst✝ : Preorder β\nu : β → α\nl : LowerAdjoint u\nf : ι → α\n⊢ Eq (u (l.toFun (iSup fun i => u (l.toFun (f i))))) (u (l.toFun (iSup fun i => f i)))","decl":"theorem closure_iSup_closure (f : ι → α) : u (l (⨆ i, u (l (f i)))) = u (l (⨆ i, f i)) :=\n  l.closureOperator.closure_iSup_closure _\n\n"}
{"name":"LowerAdjoint.closure_iSup₂_closure","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nι : Sort u_2\nκ : ι → Sort u_3\nβ : Type u_4\ninst✝¹ : CompleteLattice α\ninst✝ : Preorder β\nu : β → α\nl : LowerAdjoint u\nf : (i : ι) → κ i → α\n⊢ Eq (u (l.toFun (iSup fun i => iSup fun j => u (l.toFun (f i j))))) (u (l.toFun (iSup fun i => iSup fun j => f i j)))","decl":"theorem closure_iSup₂_closure (f : ∀ i, κ i → α) :\n    u (l <| ⨆ (i) (j), u (l <| f i j)) = u (l <| ⨆ (i) (j), f i j) :=\n  l.closureOperator.closure_iSup₂_closure _\n\n"}
{"name":"LowerAdjoint.subset_closure","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝ : SetLike α β\nl : LowerAdjoint SetLike.coe\ns : Set β\n⊢ HasSubset.Subset s ↑(l.toFun s)","decl":"theorem subset_closure (s : Set β) : s ⊆ l s :=\n  l.le_closure s\n\n"}
{"name":"LowerAdjoint.not_mem_of_not_mem_closure","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝ : SetLike α β\nl : LowerAdjoint SetLike.coe\ns : Set β\nP : β\nhP : Not (Membership.mem (l.toFun s) P)\n⊢ Not (Membership.mem s P)","decl":"theorem not_mem_of_not_mem_closure {s : Set β} {P : β} (hP : P ∉ l s) : P ∉ s := fun h =>\n  hP (subset_closure _ s h)\n\n"}
{"name":"LowerAdjoint.le_iff_subset","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝ : SetLike α β\nl : LowerAdjoint SetLike.coe\ns : Set β\nS : α\n⊢ Iff (LE.le (l.toFun s) S) (HasSubset.Subset s ↑S)","decl":"theorem le_iff_subset (s : Set β) (S : α) : l s ≤ S ↔ s ⊆ S :=\n  l.gc s S\n\n"}
{"name":"LowerAdjoint.mem_iff","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝ : SetLike α β\nl : LowerAdjoint SetLike.coe\ns : Set β\nx : β\n⊢ Iff (Membership.mem (l.toFun s) x) (∀ (S : α), HasSubset.Subset s ↑S → Membership.mem S x)","decl":"theorem mem_iff (s : Set β) (x : β) : x ∈ l s ↔ ∀ S : α, s ⊆ S → x ∈ S := by\n  simp_rw [← SetLike.mem_coe, ← Set.singleton_subset_iff, ← l.le_iff_subset]\n  exact ⟨fun h S => h.trans, fun h => h _ le_rfl⟩\n\n"}
{"name":"LowerAdjoint.eq_of_le","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝ : SetLike α β\nl : LowerAdjoint SetLike.coe\ns : Set β\nS : α\nh₁ : HasSubset.Subset s ↑S\nh₂ : LE.le S (l.toFun s)\n⊢ Eq (l.toFun s) S","decl":"theorem eq_of_le {s : Set β} {S : α} (h₁ : s ⊆ S) (h₂ : S ≤ l s) : l s = S :=\n  ((l.le_iff_subset _ _).2 h₁).antisymm h₂\n\n"}
{"name":"LowerAdjoint.closure_union_closure_subset","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝ : SetLike α β\nl : LowerAdjoint SetLike.coe\nx y : α\n⊢ HasSubset.Subset (Union.union ↑(l.toFun ↑x) ↑(l.toFun ↑y)) ↑(l.toFun (Union.union ↑x ↑y))","decl":"theorem closure_union_closure_subset (x y : α) : (l x : Set β) ∪ l y ⊆ l (x ∪ y) :=\n  l.closure_sup_closure_le x y\n\n"}
{"name":"LowerAdjoint.closure_union_closure_left","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝ : SetLike α β\nl : LowerAdjoint SetLike.coe\nx y : α\n⊢ Eq (l.toFun (Union.union ↑(l.toFun ↑x) ↑y)) (l.toFun (Union.union ↑x ↑y))","decl":"@[simp]\ntheorem closure_union_closure_left (x y : α) : l (l x ∪ y) = l (x ∪ y) :=\n  SetLike.coe_injective (l.closure_sup_closure_left x y)\n\n"}
{"name":"LowerAdjoint.closure_union_closure_right","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝ : SetLike α β\nl : LowerAdjoint SetLike.coe\nx y : α\n⊢ Eq (l.toFun (Union.union ↑x ↑(l.toFun ↑y))) (l.toFun (Union.union ↑x ↑y))","decl":"@[simp]\ntheorem closure_union_closure_right (x y : α) : l (x ∪ l y) = l (x ∪ y) :=\n  SetLike.coe_injective (l.closure_sup_closure_right x y)\n\n"}
{"name":"LowerAdjoint.closure_union_closure","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝ : SetLike α β\nl : LowerAdjoint SetLike.coe\nx y : α\n⊢ Eq (l.toFun (Union.union ↑(l.toFun ↑x) ↑(l.toFun ↑y))) (l.toFun (Union.union ↑x ↑y))","decl":"theorem closure_union_closure (x y : α) : l (l x ∪ l y) = l (x ∪ y) := by\n  rw [closure_union_closure_right, closure_union_closure_left]\n\n"}
{"name":"LowerAdjoint.closure_iUnion_closure","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nι : Sort u_2\nβ : Type u_4\ninst✝ : SetLike α β\nl : LowerAdjoint SetLike.coe\nf : ι → α\n⊢ Eq (l.toFun (Set.iUnion fun i => ↑(l.toFun ↑(f i)))) (l.toFun (Set.iUnion fun i => ↑(f i)))","decl":"@[simp]\ntheorem closure_iUnion_closure (f : ι → α) : l (⋃ i, l (f i)) = l (⋃ i, f i) :=\n  SetLike.coe_injective <| l.closure_iSup_closure _\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"LowerAdjoint.closure_iUnion₂_closure","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nι : Sort u_2\nκ : ι → Sort u_3\nβ : Type u_4\ninst✝ : SetLike α β\nl : LowerAdjoint SetLike.coe\nf : (i : ι) → κ i → α\n⊢ Eq (l.toFun (Set.iUnion fun i => Set.iUnion fun j => ↑(l.toFun ↑(f i j)))) (l.toFun (Set.iUnion fun i => Set.iUnion fun j => ↑(f i j)))","decl":"@[simp]\ntheorem closure_iUnion₂_closure (f : ∀ i, κ i → α) :\n    l (⋃ (i) (j), l (f i j)) = l (⋃ (i) (j), f i j) :=\n  SetLike.coe_injective <| l.closure_iSup₂_closure _\n\n"}
{"name":"GaloisConnection.lowerAdjoint_toFun","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\na✝ : α\n⊢ Eq (gc.lowerAdjoint.toFun a✝) (l a✝)","decl":"/-- Every Galois connection induces a lower adjoint. -/\n@[simps]\ndef GaloisConnection.lowerAdjoint [Preorder α] [Preorder β] {l : α → β} {u : β → α}\n    (gc : GaloisConnection l u) : LowerAdjoint u where\n  toFun := l\n  gc' := gc\n\n"}
{"name":"GaloisConnection.closureOperator_isClosed","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\nx : α\n⊢ Eq (gc.closureOperator.IsClosed x) (Eq (u (l x)) x)","decl":"/-- Every Galois connection induces a closure operator given by the composition. This is the partial\norder version of the statement that every adjunction induces a monad. -/\n@[simps!]\ndef GaloisConnection.closureOperator [PartialOrder α] [Preorder β] {l : α → β} {u : β → α}\n    (gc : GaloisConnection l u) : ClosureOperator α :=\n  gc.lowerAdjoint.closureOperator\n\n"}
{"name":"GaloisConnection.closureOperator_apply","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\nβ : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\nx : α\n⊢ Eq (gc.closureOperator x) (u (l x))","decl":"/-- Every Galois connection induces a closure operator given by the composition. This is the partial\norder version of the statement that every adjunction induces a monad. -/\n@[simps!]\ndef GaloisConnection.closureOperator [PartialOrder α] [Preorder β] {l : α → β} {u : β → α}\n    (gc : GaloisConnection l u) : ClosureOperator α :=\n  gc.lowerAdjoint.closureOperator\n\n"}
{"name":"closureOperator_gi_self","module":"Mathlib.Order.Closure","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nc : ClosureOperator α\n⊢ Eq ⋯.closureOperator c","decl":"/-- The Galois insertion associated to a closure operator can be used to reconstruct the closure\noperator.\nNote that the inverse in the opposite direction does not hold in general. -/\n@[simp]\ntheorem closureOperator_gi_self [PartialOrder α] (c : ClosureOperator α) :\n    c.gi.gc.closureOperator = c := by\n  ext x\n  rfl\n"}
