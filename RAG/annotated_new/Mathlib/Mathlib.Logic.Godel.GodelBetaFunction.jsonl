{"name":"Nat.coprime_mul_succ","module":"Mathlib.Logic.Godel.GodelBetaFunction","initialProofState":"n m a : Nat\nh : LE.le n m\nha : Dvd.dvd (HSub.hSub m n) a\n⊢ (HAdd.hAdd (HMul.hMul n a) 1).Coprime (HAdd.hAdd (HMul.hMul m a) 1)","decl":"lemma coprime_mul_succ {n m a} (h : n ≤ m) (ha : m - n ∣ a) : Coprime (n * a + 1) (m * a + 1) :=\n  Nat.coprime_of_dvd fun p pp hn hm => by\n    have : p ∣ (m - n) * a := by\n      simpa [Nat.succ_sub_succ, ← Nat.mul_sub_right_distrib] using\n        Nat.dvd_sub (Nat.succ_le_succ <| Nat.mul_le_mul_right a h) hm hn\n    have : p ∣ a := by\n      rcases (Nat.Prime.dvd_mul pp).mp this with (hp | hp)\n      · exact Nat.dvd_trans hp ha\n      · exact hp\n    apply pp.ne_one\n    simpa [Nat.add_sub_cancel_left] using Nat.dvd_sub (le_add_right _ _) hn (this.mul_left n)\n\n"}
{"name":"Nat.coprimes_lt","module":"Mathlib.Logic.Godel.GodelBetaFunction","initialProofState":"m : Nat\na : Fin m → Nat\ni : Fin m\n⊢ LT.lt (a i) (Nat.coprimes a i)","decl":"lemma coprimes_lt (a : Fin m → ℕ) (i) : a i < coprimes a i := by\n  have h₁ : a i < supOfSeq a :=\n    Nat.lt_add_one_iff.mpr (le_max_of_le_right <| Finset.le_sup (by simp))\n  have h₂ : supOfSeq a ≤ (i + 1) * (supOfSeq a)! + 1 :=\n    le_trans (self_le_factorial _) (le_trans (Nat.le_mul_of_pos_left (supOfSeq a)! (succ_pos i))\n      (le_add_right _ _))\n  simpa only [coprimes] using lt_of_lt_of_le h₁ h₂\n\n"}
{"name":"Nat.beta_unbeta_coe","module":"Mathlib.Logic.Godel.GodelBetaFunction","initialProofState":"l : List Nat\ni : Fin l.length\n⊢ Eq ((Nat.unbeta l).beta ↑i) (GetElem.getElem l i ⋯)","decl":"/-- **Gödel's Beta Function Lemma** -/\nlemma beta_unbeta_coe (l : List ℕ) (i : Fin l.length) : beta (unbeta l) i = l[i] := by\n  simpa [beta, unbeta, coprimes] using mod_eq_of_modEq\n    ((chineseRemainderOfFinset (l[·]) (coprimes (l[·])) Finset.univ\n      (by simp [coprimes])\n      (by simpa using Set.pairwise_univ.mpr (pairwise_coprime_coprimes _))).prop i (by simp))\n    (coprimes_lt _ _)\n\n"}
