{"name":"Multiset.instAddLeftMono","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\n⊢ AddLeftMono (Multiset α)","decl":"instance instAddLeftMono : AddLeftMono (Multiset α) where elim _s _t _u := Multiset.add_le_add_left\n\n"}
{"name":"Multiset.instAddLeftReflectLE","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\n⊢ AddLeftReflectLE (Multiset α)","decl":"instance instAddLeftReflectLE : AddLeftReflectLE (Multiset α) where\n  elim _s _t _u := Multiset.le_of_add_le_add_left\n\n"}
{"name":"Multiset.mem_of_mem_nsmul","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\na : α\ns : Multiset α\nn : Nat\nh : Membership.mem (HSMul.hSMul n s) a\n⊢ Membership.mem s a","decl":"lemma mem_of_mem_nsmul {a : α} {s : Multiset α} {n : ℕ} (h : a ∈ n • s) : a ∈ s := by\n  induction' n with n ih\n  · rw [zero_nsmul] at h\n    exact absurd h (not_mem_zero _)\n  · rw [succ_nsmul, mem_add] at h\n    exact h.elim ih id\n\n"}
{"name":"Multiset.mem_nsmul","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\na : α\ns : Multiset α\nn : Nat\n⊢ Iff (Membership.mem (HSMul.hSMul n s) a) (And (Ne n 0) (Membership.mem s a))","decl":"@[simp]\nlemma mem_nsmul {a : α} {s : Multiset α} {n : ℕ} : a ∈ n • s ↔ n ≠ 0 ∧ a ∈ s := by\n  refine ⟨fun ha ↦ ⟨?_, mem_of_mem_nsmul ha⟩, fun h ↦ ?_⟩\n  · rintro rfl\n    simp [zero_nsmul] at ha\n  obtain ⟨n, rfl⟩ := exists_eq_succ_of_ne_zero h.1\n  rw [succ_nsmul, mem_add]\n  exact Or.inr h.2\n\n"}
{"name":"Multiset.mem_nsmul_of_ne_zero","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\na : α\ns : Multiset α\nn : Nat\nh0 : Ne n 0\n⊢ Iff (Membership.mem (HSMul.hSMul n s) a) (Membership.mem s a)","decl":"lemma mem_nsmul_of_ne_zero {a : α} {s : Multiset α} {n : ℕ} (h0 : n ≠ 0) : a ∈ n • s ↔ a ∈ s := by\n  simp [*]\n\n"}
{"name":"Multiset.nsmul_cons","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\ns : Multiset α\nn : Nat\na : α\n⊢ Eq (HSMul.hSMul n (Multiset.cons a s)) (HAdd.hAdd (HSMul.hSMul n (Singleton.singleton a)) (HSMul.hSMul n s))","decl":"lemma nsmul_cons {s : Multiset α} (n : ℕ) (a : α) :\n    n • (a ::ₘ s) = n • ({a} : Multiset α) + n • s := by\n  rw [← singleton_add, nsmul_add]\n\n"}
{"name":"Multiset.cardHom_apply","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\na✝ : Multiset α\n⊢ Eq (Multiset.cardHom a✝) a✝.card","decl":"/-- `Multiset.card` bundled as a group hom. -/\n@[simps]\ndef cardHom : Multiset α →+ ℕ where\n  toFun := card\n  map_zero' := card_zero\n  map_add' := card_add\n\n"}
{"name":"Multiset.card_nsmul","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\ns : Multiset α\nn : Nat\n⊢ Eq (HSMul.hSMul n s).card (HMul.hMul n s.card)","decl":"@[simp]\nlemma card_nsmul (s : Multiset α) (n : ℕ) : card (n • s) = n * card s := cardHom.map_nsmul ..\n\n"}
{"name":"Multiset.replicateAddMonoidHom_apply","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\na : α\nn : Nat\n⊢ Eq ((Multiset.replicateAddMonoidHom a) n) (Multiset.replicate n a)","decl":"/-- `Multiset.replicate` as an `AddMonoidHom`. -/\n@[simps]\ndef replicateAddMonoidHom (a : α) : ℕ →+ Multiset α where\n  toFun n := replicate n a\n  map_zero' := replicate_zero a\n  map_add' _ _ := replicate_add _ _ a\n\n"}
{"name":"Multiset.nsmul_replicate","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\na : α\nn m : Nat\n⊢ Eq (HSMul.hSMul n (Multiset.replicate m a)) (Multiset.replicate (HMul.hMul n m) a)","decl":"lemma nsmul_replicate {a : α} (n m : ℕ) : n • replicate m a = replicate (n * m) a :=\n  ((replicateAddMonoidHom a).map_nsmul _ _).symm\n\n"}
{"name":"Multiset.nsmul_singleton","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\na : α\nn : Nat\n⊢ Eq (HSMul.hSMul n (Singleton.singleton a)) (Multiset.replicate n a)","decl":"lemma nsmul_singleton (a : α) (n) : n • ({a} : Multiset α) = replicate n a := by\n  rw [← replicate_one, nsmul_replicate, mul_one]\n\n"}
{"name":"Multiset.mapAddMonoidHom_apply","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Multiset α\n⊢ Eq ((Multiset.mapAddMonoidHom f) s) (Multiset.map f s)","decl":"/-- `Multiset.map` as an `AddMonoidHom`. -/\n@[simps]\ndef mapAddMonoidHom (f : α → β) : Multiset α →+ Multiset β where\n  toFun := map f\n  map_zero' := map_zero _\n  map_add' := map_add _\n\n"}
{"name":"Multiset.coe_mapAddMonoidHom","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (⇑(Multiset.mapAddMonoidHom f)) (Multiset.map f)","decl":"@[simp]\nlemma coe_mapAddMonoidHom (f : α → β) : (mapAddMonoidHom f : Multiset α → Multiset β) = map f := rfl\n\n"}
{"name":"Multiset.map_nsmul","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nn : Nat\ns : Multiset α\n⊢ Eq (Multiset.map f (HSMul.hSMul n s)) (HSMul.hSMul n (Multiset.map f s))","decl":"lemma map_nsmul (f : α → β) (n : ℕ) (s) : map f (n • s) = n • map f s :=\n  (mapAddMonoidHom f).map_nsmul _ _\n\n"}
{"name":"Multiset.instOrderedSub","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ OrderedSub (Multiset α)","decl":"instance : OrderedSub (Multiset α) where tsub_le_iff_right _n _m _k := Multiset.sub_le_iff_le_add\n\n"}
{"name":"Multiset.instExistsAddOfLE","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\n⊢ ExistsAddOfLE (Multiset α)","decl":"instance : ExistsAddOfLE (Multiset α) where\n  exists_add_of_le h := leInductionOn h fun s ↦\n      let ⟨l, p⟩ := s.exists_perm_append; ⟨l, Quot.sound p⟩\n\n"}
{"name":"Multiset.filter_nsmul","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Multiset α\nn : Nat\n⊢ Eq (Multiset.filter p (HSMul.hSMul n s)) (HSMul.hSMul n (Multiset.filter p s))","decl":"lemma filter_nsmul (s : Multiset α) (n : ℕ) : filter p (n • s) = n • filter p s := by\n  refine s.induction_on ?_ ?_\n  · simp only [filter_zero, nsmul_zero]\n  · intro a ha ih\n    rw [nsmul_cons, filter_add, ih, filter_cons, nsmul_add]\n    congr\n    split_ifs with hp <;>\n      · simp only [filter_eq_self, nsmul_zero, filter_eq_nil]\n        intro b hb\n        rwa [mem_singleton.mp (mem_of_mem_nsmul hb)]\n\n"}
{"name":"Multiset.countP_nsmul","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Multiset α\nn : Nat\n⊢ Eq (Multiset.countP p (HSMul.hSMul n s)) (HMul.hMul n (Multiset.countP p s))","decl":"@[simp]\nlemma countP_nsmul (s) (n : ℕ) : countP p (n • s) = n * countP p s := by\n  induction n <;> simp [*, succ_nsmul, succ_mul, zero_nsmul]\n\n"}
{"name":"Multiset.coe_countPAddMonoidHom","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq (⇑(Multiset.countPAddMonoidHom p)) (Multiset.countP p)","decl":"@[simp] lemma coe_countPAddMonoidHom : (countPAddMonoidHom p : Multiset α → ℕ) = countP p := rfl\n\n"}
{"name":"Multiset.dedup_nsmul","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\nn : Nat\nhn : Ne n 0\n⊢ Eq (HSMul.hSMul n s).dedup s.dedup","decl":"@[simp] lemma dedup_nsmul [DecidableEq α] {s : Multiset α} {n : ℕ} (hn : n ≠ 0) :\n    (n • s).dedup = s.dedup := by ext a; by_cases h : a ∈ s <;> simp [h, hn]\n\n"}
{"name":"Multiset.Nodup.le_nsmul_iff_le","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\ns t : Multiset α\nn : Nat\nh : s.Nodup\nhn : Ne n 0\n⊢ Iff (LE.le s (HSMul.hSMul n t)) (LE.le s t)","decl":"lemma Nodup.le_nsmul_iff_le {s t : Multiset α} {n : ℕ} (h : s.Nodup) (hn : n ≠ 0) :\n    s ≤ n • t ↔ s ≤ t := by\n  classical simp [← h.le_dedup_iff_le, Iff.comm, ← h.le_dedup_iff_le, hn]\n\n"}
{"name":"Multiset.coe_countAddMonoidHom","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (⇑(Multiset.countAddMonoidHom a)) (Multiset.count a)","decl":"@[simp]\nlemma coe_countAddMonoidHom (a : α) : (countAddMonoidHom a : Multiset α → ℕ) = count a := rfl\n\n"}
{"name":"Multiset.count_nsmul","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nn : Nat\ns : Multiset α\n⊢ Eq (Multiset.count a (HSMul.hSMul n s)) (HMul.hMul n (Multiset.count a s))","decl":"@[simp]\nlemma count_nsmul (a : α) (n s) : count a (n • s) = n * count a s := by\n  induction n <;> simp [*, succ_nsmul, succ_mul, zero_nsmul]\n\n"}
{"name":"Multiset.addHom_ext_iff","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : AddZeroClass β\nf g : AddMonoidHom (Multiset α) β\n⊢ Iff (Eq f g) (∀ (x : α), Eq (f (Singleton.singleton x)) (g (Singleton.singleton x)))","decl":"@[ext]\nlemma addHom_ext [AddZeroClass β] ⦃f g : Multiset α →+ β⦄ (h : ∀ x, f {x} = g {x}) : f = g := by\n  ext s\n  induction' s using Multiset.induction_on with a s ih\n  · simp only [_root_.map_zero]\n  · simp only [← singleton_add, _root_.map_add, ih, h]\n\n"}
{"name":"Multiset.addHom_ext","module":"Mathlib.Algebra.Order.Group.Multiset","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : AddZeroClass β\nf g : AddMonoidHom (Multiset α) β\nh : ∀ (x : α), Eq (f (Singleton.singleton x)) (g (Singleton.singleton x))\n⊢ Eq f g","decl":"@[ext]\nlemma addHom_ext [AddZeroClass β] ⦃f g : Multiset α →+ β⦄ (h : ∀ x, f {x} = g {x}) : f = g := by\n  ext s\n  induction' s using Multiset.induction_on with a s ih\n  · simp only [_root_.map_zero]\n  · simp only [← singleton_add, _root_.map_add, ih, h]\n\n"}
