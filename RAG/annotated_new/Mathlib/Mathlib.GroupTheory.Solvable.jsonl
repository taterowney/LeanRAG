{"name":"derivedSeries_zero","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Eq (derivedSeries G 0) Top.top","decl":"@[simp]\ntheorem derivedSeries_zero : derivedSeries G 0 = ⊤ :=\n  rfl\n\n"}
{"name":"derivedSeries_succ","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\ninst✝ : Group G\nn : Nat\n⊢ Eq (derivedSeries G (HAdd.hAdd n 1)) (Bracket.bracket (derivedSeries G n) (derivedSeries G n))","decl":"@[simp]\ntheorem derivedSeries_succ (n : ℕ) :\n    derivedSeries G (n + 1) = ⁅derivedSeries G n, derivedSeries G n⁆ :=\n  rfl\n\n-- Porting note: had to provide inductive hypothesis explicitly\n"}
{"name":"derivedSeries_normal","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\ninst✝ : Group G\nn : Nat\n⊢ (derivedSeries G n).Normal","decl":"theorem derivedSeries_normal (n : ℕ) : (derivedSeries G n).Normal := by\n  induction n with\n  | zero => exact (⊤ : Subgroup G).normal_of_characteristic\n  | succ n ih => exact @Subgroup.commutator_normal G _ (derivedSeries G n) (derivedSeries G n) ih ih\n\n-- Porting note: higher simp priority to restore Lean 3 behavior\n"}
{"name":"derivedSeries_one","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Eq (derivedSeries G 1) (commutator G)","decl":"@[simp 1100]\ntheorem derivedSeries_one : derivedSeries G 1 = commutator G :=\n  rfl\n\n"}
{"name":"map_derivedSeries_le_derivedSeries","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nf : MonoidHom G G'\nn : Nat\n⊢ LE.le (Subgroup.map f (derivedSeries G n)) (derivedSeries G' n)","decl":"theorem map_derivedSeries_le_derivedSeries (n : ℕ) :\n    (derivedSeries G n).map f ≤ derivedSeries G' n := by\n  induction n with\n  | zero => exact le_top\n  | succ n ih => simp only [derivedSeries_succ, map_commutator, commutator_mono, ih]\n\n"}
{"name":"derivedSeries_le_map_derivedSeries","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nf : MonoidHom G G'\nhf : Function.Surjective ⇑f\nn : Nat\n⊢ LE.le (derivedSeries G' n) (Subgroup.map f (derivedSeries G n))","decl":"theorem derivedSeries_le_map_derivedSeries (hf : Function.Surjective f) (n : ℕ) :\n    derivedSeries G' n ≤ (derivedSeries G n).map f := by\n  induction n with\n  | zero => exact (map_top_of_surjective f hf).ge\n  | succ n ih => exact commutator_le_map_commutator ih ih\n\n"}
{"name":"map_derivedSeries_eq","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nf : MonoidHom G G'\nhf : Function.Surjective ⇑f\nn : Nat\n⊢ Eq (Subgroup.map f (derivedSeries G n)) (derivedSeries G' n)","decl":"theorem map_derivedSeries_eq (hf : Function.Surjective f) (n : ℕ) :\n    (derivedSeries G n).map f = derivedSeries G' n :=\n  le_antisymm (map_derivedSeries_le_derivedSeries f n) (derivedSeries_le_map_derivedSeries hf n)\n\n"}
{"name":"isSolvable_def","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Iff (IsSolvable G) (Exists fun n => Eq (derivedSeries G n) Bot.bot)","decl":"/-- A group `G` is solvable if its derived series is eventually trivial. We use this definition\n  because it's the most convenient one to work with. -/\n@[mk_iff isSolvable_def]\nclass IsSolvable : Prop where\n  /-- A group `G` is solvable if its derived series is eventually trivial. -/\n  solvable : ∃ n : ℕ, derivedSeries G n = ⊥\n\n"}
{"name":"IsSolvable.solvable","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\ninst✝ : Group G\nself : IsSolvable G\n⊢ Exists fun n => Eq (derivedSeries G n) Bot.bot","decl":"/-- A group `G` is solvable if its derived series is eventually trivial. We use this definition\n  because it's the most convenient one to work with. -/\n@[mk_iff isSolvable_def]\nclass IsSolvable : Prop where\n  /-- A group `G` is solvable if its derived series is eventually trivial. -/\n  solvable : ∃ n : ℕ, derivedSeries G n = ⊥\n\n"}
{"name":"CommGroup.isSolvable","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\n⊢ IsSolvable G","decl":"instance (priority := 100) CommGroup.isSolvable {G : Type*} [CommGroup G] : IsSolvable G :=\n  ⟨⟨1, le_bot_iff.mp (Abelianization.commutator_subset_ker (MonoidHom.id G))⟩⟩\n\n"}
{"name":"isSolvable_of_comm","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_3\nhG : Group G\nh : ∀ (a b : G), Eq (HMul.hMul a b) (HMul.hMul b a)\n⊢ IsSolvable G","decl":"theorem isSolvable_of_comm {G : Type*} [hG : Group G] (h : ∀ a b : G, a * b = b * a) :\n    IsSolvable G := by\n  letI hG' : CommGroup G := { hG with mul_comm := h }\n  cases hG\n  exact CommGroup.isSolvable\n\n"}
{"name":"isSolvable_of_top_eq_bot","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\ninst✝ : Group G\nh : Eq Top.top Bot.bot\n⊢ IsSolvable G","decl":"theorem isSolvable_of_top_eq_bot (h : (⊤ : Subgroup G) = ⊥) : IsSolvable G :=\n  ⟨⟨0, h⟩⟩\n\n"}
{"name":"isSolvable_of_subsingleton","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : Subsingleton G\n⊢ IsSolvable G","decl":"instance (priority := 100) isSolvable_of_subsingleton [Subsingleton G] : IsSolvable G :=\n  isSolvable_of_top_eq_bot G (by simp [eq_iff_true_of_subsingleton])\n\n"}
{"name":"solvable_of_ker_le_range","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\ninst✝² : Group G\nG' : Type u_3\nG'' : Type u_4\ninst✝¹ : Group G'\ninst✝ : Group G''\nf : MonoidHom G' G\ng : MonoidHom G G''\nhfg : LE.le g.ker f.range\nhG' : IsSolvable G'\nhG'' : IsSolvable G''\n⊢ IsSolvable G","decl":"theorem solvable_of_ker_le_range {G' G'' : Type*} [Group G'] [Group G''] (f : G' →* G)\n    (g : G →* G'') (hfg : g.ker ≤ f.range) [hG' : IsSolvable G'] [hG'' : IsSolvable G''] :\n    IsSolvable G := by\n  obtain ⟨n, hn⟩ := id hG''\n  obtain ⟨m, hm⟩ := id hG'\n  refine ⟨⟨n + m, le_bot_iff.mp (Subgroup.map_bot f ▸ hm ▸ ?_)⟩⟩\n  clear hm\n  induction' m with m hm\n  · exact f.range_eq_map ▸ ((derivedSeries G n).map_eq_bot_iff.mp\n      (le_bot_iff.mp ((map_derivedSeries_le_derivedSeries g n).trans hn.le))).trans hfg\n  · exact commutator_le_map_commutator hm hm\n\n"}
{"name":"solvable_of_solvable_injective","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝² : Group G\ninst✝¹ : Group G'\nf : MonoidHom G G'\nhf : Function.Injective ⇑f\ninst✝ : IsSolvable G'\n⊢ IsSolvable G","decl":"theorem solvable_of_solvable_injective (hf : Function.Injective f) [IsSolvable G'] :\n    IsSolvable G :=\n  solvable_of_ker_le_range (1 : G' →* G) f ((f.ker_eq_bot_iff.mpr hf).symm ▸ bot_le)\n\n"}
{"name":"subgroup_solvable_of_solvable","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : IsSolvable G\n⊢ IsSolvable (Subtype fun x => Membership.mem H x)","decl":"instance subgroup_solvable_of_solvable (H : Subgroup G) [IsSolvable G] : IsSolvable H :=\n  solvable_of_solvable_injective H.subtype_injective\n\n"}
{"name":"solvable_of_surjective","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝² : Group G\ninst✝¹ : Group G'\nf : MonoidHom G G'\nhf : Function.Surjective ⇑f\ninst✝ : IsSolvable G\n⊢ IsSolvable G'","decl":"theorem solvable_of_surjective (hf : Function.Surjective f) [IsSolvable G] : IsSolvable G' :=\n  solvable_of_ker_le_range f (1 : G' →* G) (f.range_eq_top_of_surjective hf ▸ le_top)\n\n"}
{"name":"solvable_quotient_of_solvable","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\ninst✝² : Group G\nH : Subgroup G\ninst✝¹ : H.Normal\ninst✝ : IsSolvable G\n⊢ IsSolvable (HasQuotient.Quotient G H)","decl":"instance solvable_quotient_of_solvable (H : Subgroup G) [H.Normal] [IsSolvable G] :\n    IsSolvable (G ⧸ H) :=\n  solvable_of_surjective (QuotientGroup.mk'_surjective H)\n\n"}
{"name":"solvable_prod","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\ninst✝³ : Group G\nG' : Type u_3\ninst✝² : Group G'\ninst✝¹ : IsSolvable G\ninst✝ : IsSolvable G'\n⊢ IsSolvable (Prod G G')","decl":"instance solvable_prod {G' : Type*} [Group G'] [IsSolvable G] [IsSolvable G'] :\n    IsSolvable (G × G') :=\n  solvable_of_ker_le_range (MonoidHom.inl G G') (MonoidHom.snd G G') fun x hx =>\n    ⟨x.1, Prod.ext rfl hx.symm⟩\n\n"}
{"name":"IsSolvable.commutator_lt_top_of_nontrivial","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nhG : IsSolvable G\ninst✝ : Nontrivial G\n⊢ LT.lt (commutator G) Top.top","decl":"variable (G) in\ntheorem IsSolvable.commutator_lt_top_of_nontrivial [hG : IsSolvable G] [Nontrivial G] :\n    commutator G < ⊤ := by\n  rw [lt_top_iff_ne_top]\n  obtain ⟨n, hn⟩ := hG\n  contrapose! hn\n  refine ne_of_eq_of_ne ?_ top_ne_bot\n  induction' n with n h\n  · exact derivedSeries_zero G\n  · rwa [derivedSeries_succ, h]\n\n"}
{"name":"IsSolvable.commutator_lt_of_ne_bot","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : IsSolvable G\nH : Subgroup G\nhH : Ne H Bot.bot\n⊢ LT.lt (Bracket.bracket H H) H","decl":"theorem IsSolvable.commutator_lt_of_ne_bot [IsSolvable G] {H : Subgroup G} (hH : H ≠ ⊥) :\n    ⁅H, H⁆ < H := by\n  rw [← nontrivial_iff_ne_bot] at hH\n  rw [← H.range_subtype, MonoidHom.range_eq_map, ← map_commutator, map_subtype_lt_map_subtype]\n  exact commutator_lt_top_of_nontrivial H\n\n"}
{"name":"isSolvable_iff_commutator_lt","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : WellFoundedLT (Subgroup G)\n⊢ Iff (IsSolvable G) (∀ (H : Subgroup G), Ne H Bot.bot → LT.lt (Bracket.bracket H H) H)","decl":"theorem isSolvable_iff_commutator_lt [WellFoundedLT (Subgroup G)] :\n    IsSolvable G ↔ ∀ H : Subgroup G, H ≠ ⊥ → ⁅H, H⁆ < H := by\n  refine ⟨fun _ _ ↦ IsSolvable.commutator_lt_of_ne_bot, fun h ↦ ?_⟩\n  suffices h : IsSolvable (⊤ : Subgroup G) from\n    solvable_of_surjective (MonoidHom.range_eq_top.mp (range_subtype ⊤))\n  refine WellFoundedLT.induction (C := fun (H : Subgroup G) ↦ IsSolvable H) ⊤ fun H hH ↦ ?_\n  rcases eq_or_ne H ⊥ with rfl | h'\n  · infer_instance\n  · obtain ⟨n, hn⟩ := hH ⁅H, H⁆ (h H h')\n    use n + 1\n    rw [← (map_injective (subtype_injective _)).eq_iff, Subgroup.map_bot] at hn ⊢\n    rw [← hn]\n    clear hn\n    induction' n with n ih\n    · rw [derivedSeries_succ, derivedSeries_zero, derivedSeries_zero, map_commutator,\n        ← MonoidHom.range_eq_map, ← MonoidHom.range_eq_map, range_subtype, range_subtype]\n    · rw [derivedSeries_succ, map_commutator, ih, derivedSeries_succ, map_commutator]\n\n"}
{"name":"IsSimpleGroup.derivedSeries_succ","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : IsSimpleGroup G\nn : Nat\n⊢ Eq (derivedSeries G n.succ) (commutator G)","decl":"theorem IsSimpleGroup.derivedSeries_succ {n : ℕ} : derivedSeries G n.succ = commutator G := by\n  induction n with\n  | zero => exact derivedSeries_one G\n  | succ n ih =>\n    rw [_root_.derivedSeries_succ, ih, _root_.commutator]\n    cases' (commutator_normal (⊤ : Subgroup G) (⊤ : Subgroup G)).eq_bot_or_eq_top with h h\n    · rw [h, commutator_bot_left]\n    · rwa [h]\n\n"}
{"name":"IsSimpleGroup.comm_iff_isSolvable","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : IsSimpleGroup G\n⊢ Iff (∀ (a b : G), Eq (HMul.hMul a b) (HMul.hMul b a)) (IsSolvable G)","decl":"theorem IsSimpleGroup.comm_iff_isSolvable : (∀ a b : G, a * b = b * a) ↔ IsSolvable G :=\n  ⟨isSolvable_of_comm, fun ⟨⟨n, hn⟩⟩ => by\n    cases n\n    · intro a b\n      refine (mem_bot.1 ?_).trans (mem_bot.1 ?_).symm <;>\n        · rw [← hn]\n          exact mem_top _\n    · rw [IsSimpleGroup.derivedSeries_succ] at hn\n      intro a b\n      rw [← mul_inv_eq_one, mul_inv_rev, ← mul_assoc, ← mem_bot, ← hn, commutator_eq_closure]\n      exact subset_closure ⟨a, b, rfl⟩⟩\n\n"}
{"name":"not_solvable_of_mem_derivedSeries","module":"Mathlib.GroupTheory.Solvable","initialProofState":"G : Type u_1\ninst✝ : Group G\ng : G\nh1 : Ne g 1\nh2 : ∀ (n : Nat), Membership.mem (derivedSeries G n) g\n⊢ Not (IsSolvable G)","decl":"theorem not_solvable_of_mem_derivedSeries {g : G} (h1 : g ≠ 1)\n    (h2 : ∀ n : ℕ, g ∈ derivedSeries G n) : ¬IsSolvable G :=\n  mt (isSolvable_def _).mp\n    (not_exists_of_forall_not fun n h =>\n      h1 (Subgroup.mem_bot.mp ((congr_arg (g ∈ ·) h).mp (h2 n))))\n\n"}
{"name":"Equiv.Perm.fin_5_not_solvable","module":"Mathlib.GroupTheory.Solvable","initialProofState":"⊢ Not (IsSolvable (Equiv.Perm (Fin 5)))","decl":"theorem Equiv.Perm.fin_5_not_solvable : ¬IsSolvable (Equiv.Perm (Fin 5)) := by\n  let x : Equiv.Perm (Fin 5) := ⟨![1, 2, 0, 3, 4], ![2, 0, 1, 3, 4], by decide, by decide⟩\n  let y : Equiv.Perm (Fin 5) := ⟨![3, 4, 2, 0, 1], ![3, 4, 2, 0, 1], by decide, by decide⟩\n  let z : Equiv.Perm (Fin 5) := ⟨![0, 3, 2, 1, 4], ![0, 3, 2, 1, 4], by decide, by decide⟩\n  have key : x = z * ⁅x, y * x * y⁻¹⁆ * z⁻¹ := by unfold x y z; decide\n  refine not_solvable_of_mem_derivedSeries (show x ≠ 1 by decide) fun n => ?_\n  induction n with\n  | zero => exact mem_top x\n  | succ n ih =>\n    rw [key, (derivedSeries_normal _ _).mem_comm_iff, inv_mul_cancel_left]\n    exact commutator_mem_commutator ih ((derivedSeries_normal _ _).conj_mem _ ih _)\n\n"}
{"name":"Equiv.Perm.not_solvable","module":"Mathlib.GroupTheory.Solvable","initialProofState":"X : Type u_3\nhX : LE.le 5 (Cardinal.mk X)\n⊢ Not (IsSolvable (Equiv.Perm X))","decl":"theorem Equiv.Perm.not_solvable (X : Type*) (hX : 5 ≤ Cardinal.mk X) :\n    ¬IsSolvable (Equiv.Perm X) := by\n  intro h\n  have key : Nonempty (Fin 5 ↪ X) := by\n    rwa [← Cardinal.lift_mk_le, Cardinal.mk_fin, Cardinal.lift_natCast, Cardinal.lift_id]\n  exact\n    Equiv.Perm.fin_5_not_solvable\n      (solvable_of_solvable_injective (Equiv.Perm.viaEmbeddingHom_injective (Nonempty.some key)))\n\n"}
