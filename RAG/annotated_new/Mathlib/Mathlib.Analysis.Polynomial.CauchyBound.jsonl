{"name":"Polynomial.one_le_cauchyBound","module":"Mathlib.Analysis.Polynomial.CauchyBound","initialProofState":"K : Type u_1\ninst✝ : NormedDivisionRing K\np : Polynomial K\n⊢ LE.le 1 p.cauchyBound","decl":"@[simp]\nlemma one_le_cauchyBound (p : K[X]) : 1 ≤ cauchyBound p := by\n  simp [cauchyBound]\n\n"}
{"name":"Polynomial.cauchyBound_zero","module":"Mathlib.Analysis.Polynomial.CauchyBound","initialProofState":"K : Type u_1\ninst✝ : NormedDivisionRing K\n⊢ Eq (Polynomial.cauchyBound 0) 1","decl":"@[simp]\nlemma cauchyBound_zero : cauchyBound (0 : K[X]) = 1 := by\n  simp [cauchyBound]\n\n"}
{"name":"Polynomial.cauchyBound_C","module":"Mathlib.Analysis.Polynomial.CauchyBound","initialProofState":"K : Type u_1\ninst✝ : NormedDivisionRing K\nx : K\n⊢ Eq (Polynomial.C x).cauchyBound 1","decl":"@[simp]\nlemma cauchyBound_C (x : K) : cauchyBound (C x) = 1 := by\n  simp [cauchyBound]\n\n"}
{"name":"Polynomial.cauchyBound_one","module":"Mathlib.Analysis.Polynomial.CauchyBound","initialProofState":"K : Type u_1\ninst✝ : NormedDivisionRing K\n⊢ Eq (Polynomial.cauchyBound 1) 1","decl":"@[simp]\nlemma cauchyBound_one : cauchyBound (1 : K[X]) = 1 := cauchyBound_C 1\n\n"}
{"name":"Polynomial.cauchyBound_X","module":"Mathlib.Analysis.Polynomial.CauchyBound","initialProofState":"K : Type u_1\ninst✝ : NormedDivisionRing K\n⊢ Eq Polynomial.X.cauchyBound 1","decl":"@[simp]\nlemma cauchyBound_X : cauchyBound (X : K[X]) = 1 := by\n  simp [cauchyBound]\n\n"}
{"name":"Polynomial.cauchyBound_X_add_C","module":"Mathlib.Analysis.Polynomial.CauchyBound","initialProofState":"K : Type u_1\ninst✝ : NormedDivisionRing K\nx : K\n⊢ Eq (HAdd.hAdd Polynomial.X (Polynomial.C x)).cauchyBound (HAdd.hAdd (NNNorm.nnnorm x) 1)","decl":"@[simp]\nlemma cauchyBound_X_add_C (x : K) : cauchyBound (X + C x) = ‖x‖₊ + 1 := by\n  simp [cauchyBound]\n\n"}
{"name":"Polynomial.cauchyBound_X_sub_C","module":"Mathlib.Analysis.Polynomial.CauchyBound","initialProofState":"K : Type u_1\ninst✝ : NormedDivisionRing K\nx : K\n⊢ Eq (HSub.hSub Polynomial.X (Polynomial.C x)).cauchyBound (HAdd.hAdd (NNNorm.nnnorm x) 1)","decl":"@[simp]\nlemma cauchyBound_X_sub_C (x : K) : cauchyBound (X - C x) = ‖x‖₊ + 1 := by\n  simp [cauchyBound]\n\n"}
{"name":"Polynomial.cauchyBound_smul","module":"Mathlib.Analysis.Polynomial.CauchyBound","initialProofState":"K : Type u_1\ninst✝ : NormedDivisionRing K\nx : K\nhx : Ne x 0\np : Polynomial K\n⊢ Eq (HSMul.hSMul x p).cauchyBound p.cauchyBound","decl":"@[simp]\nlemma cauchyBound_smul {x : K} (hx : x ≠ 0) (p : K[X]) : cauchyBound (x • p) = cauchyBound p := by\n  simp only [cauchyBound, (isRegular_of_ne_zero hx).left.isSMulRegular,\n    natDegree_smul_of_smul_regular, coeff_smul, smul_eq_mul, nnnorm_mul, ← mul_finset_sup,\n    leadingCoeff_smul_of_smul_regular, add_left_inj]\n  apply mul_div_mul_left\n  simpa\n\n"}
{"name":"Polynomial.IsRoot.norm_lt_cauchyBound","module":"Mathlib.Analysis.Polynomial.CauchyBound","initialProofState":"K : Type u_1\ninst✝ : NormedDivisionRing K\np : Polynomial K\nhp : Ne p 0\na : K\nh : p.IsRoot a\n⊢ LT.lt (NNNorm.nnnorm a) p.cauchyBound","decl":"/--\n`cauchyBound` is a bound on the norm of polynomial roots.\n-/\ntheorem IsRoot.norm_lt_cauchyBound {p : K[X]} (hp : p ≠ 0) {a : K} (h : p.IsRoot a) :\n    ‖a‖₊ < cauchyBound p := by\n  rw [IsRoot.def, eval_eq_sum_range, range_add_one] at h\n  simp only [mem_range, lt_self_iff_false, not_false_eq_true, sum_insert, coeff_natDegree,\n    add_eq_zero_iff_eq_neg] at h\n  apply_fun nnnorm at h\n  simp only [nnnorm_mul, nnnorm_pow, nnnorm_neg] at h\n  suffices ‖a‖₊ ^ p.natDegree ≤ (cauchyBound p - 1) * ∑ x ∈ range p.natDegree, ‖a‖₊ ^ x by\n    rcases eq_or_ne ‖a‖₊ 1 with ha | ha\n    · simp only [ha, one_pow, sum_const, card_range, nsmul_eq_mul, mul_one, gt_iff_lt] at this ⊢\n      apply lt_of_le_of_ne (by simp)\n      intro nh\n      simp [← nh, tsub_self] at this\n    rcases lt_or_gt_of_ne ha with ha | ha\n    · apply ha.trans_le\n      simp\n    · rw [geom_sum_of_one_lt ha] at this\n      calc\n        ‖a‖₊ = ‖a‖₊ - 1 + 1 := (tsub_add_cancel_of_le ha.le).symm\n        _ = ‖a‖₊ ^ p.natDegree * (‖a‖₊ - 1) / ‖a‖₊ ^ p.natDegree + 1 := by\n          field_simp\n        _ ≤ (cauchyBound p - 1) * ((‖a‖₊ ^ p.natDegree - 1) / (‖a‖₊ - 1)) * (‖a‖₊ - 1)\n            / ‖a‖₊ ^ p.natDegree + 1 := by gcongr\n        _ = (cauchyBound p - 1) * (‖a‖₊ ^ p.natDegree - 1) / ‖a‖₊ ^ p.natDegree + 1 := by\n          congr 2\n          have : ‖a‖₊ - 1 ≠ 0 := fun nh ↦ (ha.trans_le (tsub_eq_zero_iff_le.mp nh)).false\n          field_simp\n        _ < (cauchyBound p - 1) * ‖a‖₊ ^ p.natDegree / ‖a‖₊ ^ p.natDegree + 1 := by\n          gcongr\n          · apply lt_of_le_of_ne (by simp)\n            contrapose! this\n            simp only [← this, zero_mul]\n            apply pow_pos\n            exact zero_lt_one.trans ha\n          simp [zero_lt_one.trans ha]\n        _ = cauchyBound p := by field_simp [tsub_add_cancel_of_le]\n  apply le_of_eq at h\n  have pld : ‖p.leadingCoeff‖₊ ≠ 0 := by simpa\n  calc ‖a‖₊ ^ p.natDegree\n    _ = ‖p.leadingCoeff‖₊ * ‖a‖₊ ^ p.natDegree / ‖p.leadingCoeff‖₊ := by\n      rw [mul_div_cancel_left₀]\n      simpa\n    _ ≤ ‖∑ x ∈ range p.natDegree, p.coeff x * a ^ x‖₊ / ‖p.leadingCoeff‖₊ := by gcongr\n    _ ≤ (∑ x ∈ range p.natDegree, ‖p.coeff x * a ^ x‖₊) / ‖p.leadingCoeff‖₊ := by\n      gcongr\n      apply nnnorm_sum_le\n    _ = (∑ x ∈ range p.natDegree, ‖p.coeff x‖₊ * ‖a‖₊ ^ x) / ‖p.leadingCoeff‖₊ := by simp [abs_mul]\n    _ ≤ (∑ x ∈ range p.natDegree, ‖p.leadingCoeff‖₊ * (cauchyBound p - 1) * ‖a‖₊ ^ x) /\n        ‖p.leadingCoeff‖₊ := by\n      gcongr (∑ x ∈ _, ?_ * _) / _\n      rw [cauchyBound, add_tsub_cancel_right]\n      field_simp\n      apply le_sup (f := (‖p.coeff ·‖₊)) ‹_›\n    _ = (cauchyBound p - 1) * ∑ x ∈ range p.natDegree, ‖a‖₊ ^ x := by\n      simp only [← mul_sum]\n      field_simp\n      ring\n\n"}
