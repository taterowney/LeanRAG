{"name":"CategoryTheory.PreOneHypercover.map_I‚ÇÅ","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : C\nE : CategoryTheory.PreOneHypercover X\nF : CategoryTheory.Functor C D\ni‚ÇÅ i‚ÇÇ : E.I‚ÇÄ\n‚ä¢ Eq ((E.map F).I‚ÇÅ i‚ÇÅ i‚ÇÇ) (E.I‚ÇÅ i‚ÇÅ i‚ÇÇ)","decl":"/-- The image of a 1-pre-hypercover by a functor. -/\n@[simps]\ndef map : PreOneHypercover (F.obj X) where\n  I‚ÇÄ := E.I‚ÇÄ\n  X i := F.obj (E.X i)\n  f i := F.map (E.f i)\n  I‚ÇÅ := E.I‚ÇÅ\n  Y _ _ j := F.obj (E.Y j)\n  p‚ÇÅ _ _ j := F.map (E.p‚ÇÅ j)\n  p‚ÇÇ _ _ j := F.map (E.p‚ÇÇ j)\n  w _ _ j := by simpa using F.congr_map (E.w j)\n\n"}
{"name":"CategoryTheory.PreOneHypercover.map_X","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : C\nE : CategoryTheory.PreOneHypercover X\nF : CategoryTheory.Functor C D\ni : E.I‚ÇÄ\n‚ä¢ Eq ((E.map F).X i) (F.obj (E.X i))","decl":"/-- The image of a 1-pre-hypercover by a functor. -/\n@[simps]\ndef map : PreOneHypercover (F.obj X) where\n  I‚ÇÄ := E.I‚ÇÄ\n  X i := F.obj (E.X i)\n  f i := F.map (E.f i)\n  I‚ÇÅ := E.I‚ÇÅ\n  Y _ _ j := F.obj (E.Y j)\n  p‚ÇÅ _ _ j := F.map (E.p‚ÇÅ j)\n  p‚ÇÇ _ _ j := F.map (E.p‚ÇÇ j)\n  w _ _ j := by simpa using F.congr_map (E.w j)\n\n"}
{"name":"CategoryTheory.PreOneHypercover.map_f","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : C\nE : CategoryTheory.PreOneHypercover X\nF : CategoryTheory.Functor C D\ni : E.I‚ÇÄ\n‚ä¢ Eq ((E.map F).f i) (F.map (E.f i))","decl":"/-- The image of a 1-pre-hypercover by a functor. -/\n@[simps]\ndef map : PreOneHypercover (F.obj X) where\n  I‚ÇÄ := E.I‚ÇÄ\n  X i := F.obj (E.X i)\n  f i := F.map (E.f i)\n  I‚ÇÅ := E.I‚ÇÅ\n  Y _ _ j := F.obj (E.Y j)\n  p‚ÇÅ _ _ j := F.map (E.p‚ÇÅ j)\n  p‚ÇÇ _ _ j := F.map (E.p‚ÇÇ j)\n  w _ _ j := by simpa using F.congr_map (E.w j)\n\n"}
{"name":"CategoryTheory.PreOneHypercover.map_p‚ÇÇ","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : C\nE : CategoryTheory.PreOneHypercover X\nF : CategoryTheory.Functor C D\nx‚úù¬π x‚úù : E.I‚ÇÄ\nj : E.I‚ÇÅ x‚úù¬π x‚úù\n‚ä¢ Eq ((E.map F).p‚ÇÇ j) (F.map (E.p‚ÇÇ j))","decl":"/-- The image of a 1-pre-hypercover by a functor. -/\n@[simps]\ndef map : PreOneHypercover (F.obj X) where\n  I‚ÇÄ := E.I‚ÇÄ\n  X i := F.obj (E.X i)\n  f i := F.map (E.f i)\n  I‚ÇÅ := E.I‚ÇÅ\n  Y _ _ j := F.obj (E.Y j)\n  p‚ÇÅ _ _ j := F.map (E.p‚ÇÅ j)\n  p‚ÇÇ _ _ j := F.map (E.p‚ÇÇ j)\n  w _ _ j := by simpa using F.congr_map (E.w j)\n\n"}
{"name":"CategoryTheory.PreOneHypercover.map_I‚ÇÄ","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : C\nE : CategoryTheory.PreOneHypercover X\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (E.map F).I‚ÇÄ E.I‚ÇÄ","decl":"/-- The image of a 1-pre-hypercover by a functor. -/\n@[simps]\ndef map : PreOneHypercover (F.obj X) where\n  I‚ÇÄ := E.I‚ÇÄ\n  X i := F.obj (E.X i)\n  f i := F.map (E.f i)\n  I‚ÇÅ := E.I‚ÇÅ\n  Y _ _ j := F.obj (E.Y j)\n  p‚ÇÅ _ _ j := F.map (E.p‚ÇÅ j)\n  p‚ÇÇ _ _ j := F.map (E.p‚ÇÇ j)\n  w _ _ j := by simpa using F.congr_map (E.w j)\n\n"}
{"name":"CategoryTheory.PreOneHypercover.map_p‚ÇÅ","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : C\nE : CategoryTheory.PreOneHypercover X\nF : CategoryTheory.Functor C D\nx‚úù¬π x‚úù : E.I‚ÇÄ\nj : E.I‚ÇÅ x‚úù¬π x‚úù\n‚ä¢ Eq ((E.map F).p‚ÇÅ j) (F.map (E.p‚ÇÅ j))","decl":"/-- The image of a 1-pre-hypercover by a functor. -/\n@[simps]\ndef map : PreOneHypercover (F.obj X) where\n  I‚ÇÄ := E.I‚ÇÄ\n  X i := F.obj (E.X i)\n  f i := F.map (E.f i)\n  I‚ÇÅ := E.I‚ÇÅ\n  Y _ _ j := F.obj (E.Y j)\n  p‚ÇÅ _ _ j := F.map (E.p‚ÇÅ j)\n  p‚ÇÇ _ _ j := F.map (E.p‚ÇÇ j)\n  w _ _ j := by simpa using F.congr_map (E.w j)\n\n"}
{"name":"CategoryTheory.PreOneHypercover.map_Y","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : C\nE : CategoryTheory.PreOneHypercover X\nF : CategoryTheory.Functor C D\nx‚úù¬π x‚úù : E.I‚ÇÄ\nj : E.I‚ÇÅ x‚úù¬π x‚úù\n‚ä¢ Eq ((E.map F).Y j) (F.obj (E.Y j))","decl":"/-- The image of a 1-pre-hypercover by a functor. -/\n@[simps]\ndef map : PreOneHypercover (F.obj X) where\n  I‚ÇÄ := E.I‚ÇÄ\n  X i := F.obj (E.X i)\n  f i := F.map (E.f i)\n  I‚ÇÅ := E.I‚ÇÅ\n  Y _ _ j := F.obj (E.Y j)\n  p‚ÇÅ _ _ j := F.map (E.p‚ÇÅ j)\n  p‚ÇÇ _ _ j := F.map (E.p‚ÇÇ j)\n  w _ _ j := by simpa using F.congr_map (E.w j)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.OneHypercover.IsPreservedBy.mem‚ÇÄ","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nE : J.OneHypercover X\nF : CategoryTheory.Functor C D\nK : CategoryTheory.GrothendieckTopology D\nself : E.IsPreservedBy F K\n‚ä¢ Membership.mem (K (F.obj X)) (E.map F).sieve‚ÇÄ","decl":"/-- A 1-hypercover in `C` is preserved by a functor `F : C ‚•§ D` if the mapped 1-pre-hypercover\nin `D` is a 1-hypercover for the given topology on `D`. -/\nclass IsPreservedBy (F : C ‚•§ D) (K : GrothendieckTopology D) : Prop where\n  mem‚ÇÄ : (E.toPreOneHypercover.map F).sieve‚ÇÄ ‚àà K (F.obj X)\n  mem‚ÇÅ (i‚ÇÅ i‚ÇÇ : E.I‚ÇÄ) ‚¶ÉW : D‚¶Ñ (p‚ÇÅ : W ‚ü∂ F.obj (E.X i‚ÇÅ)) (p‚ÇÇ : W ‚ü∂ F.obj (E.X i‚ÇÇ))\n    (w : p‚ÇÅ ‚â´ F.map (E.f i‚ÇÅ) = p‚ÇÇ ‚â´ F.map (E.f i‚ÇÇ)) :\n      (E.toPreOneHypercover.map F).sieve‚ÇÅ p‚ÇÅ p‚ÇÇ ‚àà K W\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.OneHypercover.IsPreservedBy.mem‚ÇÅ","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nE : J.OneHypercover X\nF : CategoryTheory.Functor C D\nK : CategoryTheory.GrothendieckTopology D\nself : E.IsPreservedBy F K\ni‚ÇÅ i‚ÇÇ : E.I‚ÇÄ\nW : D\np‚ÇÅ : Quiver.Hom W (F.obj (E.X i‚ÇÅ))\np‚ÇÇ : Quiver.Hom W (F.obj (E.X i‚ÇÇ))\nw : Eq (CategoryTheory.CategoryStruct.comp p‚ÇÅ (F.map (E.f i‚ÇÅ))) (CategoryTheory.CategoryStruct.comp p‚ÇÇ (F.map (E.f i‚ÇÇ)))\n‚ä¢ Membership.mem (K W) ((E.map F).sieve‚ÇÅ p‚ÇÅ p‚ÇÇ)","decl":"/-- A 1-hypercover in `C` is preserved by a functor `F : C ‚•§ D` if the mapped 1-pre-hypercover\nin `D` is a 1-hypercover for the given topology on `D`. -/\nclass IsPreservedBy (F : C ‚•§ D) (K : GrothendieckTopology D) : Prop where\n  mem‚ÇÄ : (E.toPreOneHypercover.map F).sieve‚ÇÄ ‚àà K (F.obj X)\n  mem‚ÇÅ (i‚ÇÅ i‚ÇÇ : E.I‚ÇÄ) ‚¶ÉW : D‚¶Ñ (p‚ÇÅ : W ‚ü∂ F.obj (E.X i‚ÇÅ)) (p‚ÇÇ : W ‚ü∂ F.obj (E.X i‚ÇÇ))\n    (w : p‚ÇÅ ‚â´ F.map (E.f i‚ÇÅ) = p‚ÇÇ ‚â´ F.map (E.f i‚ÇÇ)) :\n      (E.toPreOneHypercover.map F).sieve‚ÇÅ p‚ÇÅ p‚ÇÇ ‚àà K W\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.OneHypercover.map_toPreOneHypercover","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nE : J.OneHypercover X\nF : CategoryTheory.Functor C D\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù : E.IsPreservedBy F K\n‚ä¢ Eq (E.map F K).toPreOneHypercover (E.map F)","decl":"/-- Given a 1-hypercover `E : J.OneHypercover X` of an object of `C`, a functor `F : C ‚•§ D`\nsuch that `E.IsPreversedBy F K` for a Grothendieck topology `K` on `D`, this is\nthe image of `E` by `F`, as a 1-hypercover of `F.obj X` for `K`. -/\n@[simps toPreOneHypercover]\ndef map (F : C ‚•§ D) (K : GrothendieckTopology D) [E.IsPreservedBy F K] :\n    K.OneHypercover (F.obj X) where\n  toPreOneHypercover := E.toPreOneHypercover.map F\n  mem‚ÇÄ := IsPreservedBy.mem‚ÇÄ\n  mem‚ÇÅ := IsPreservedBy.mem‚ÇÅ\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.OneHypercover.instIsPreservedById","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nE : J.OneHypercover X\n‚ä¢ E.IsPreservedBy (CategoryTheory.Functor.id C) J","decl":"instance : E.IsPreservedBy (ùü≠ C) J where\n  mem‚ÇÄ := E.mem‚ÇÄ\n  mem‚ÇÅ := E.mem‚ÇÅ\n\n"}
{"name":"CategoryTheory.Functor.IsContinuous.op_comp_isSheaf_of_types","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nself : F.IsContinuous J K\nG : CategoryTheory.Sheaf K (Type t)\n‚ä¢ CategoryTheory.Presieve.IsSheaf J (F.op.comp G.val)","decl":"/-- A functor `F` is continuous if the precomposition with `F.op` sends sheaves of `Type t`\nto sheaves. -/\nclass IsContinuous : Prop where\n  op_comp_isSheaf_of_types (G : Sheaf K (Type t)) : Presieve.IsSheaf J (F.op ‚ãô G.val)\n\n"}
{"name":"CategoryTheory.Functor.op_comp_isSheaf_of_types","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù : F.IsContinuous J K\nG : CategoryTheory.Sheaf K (Type t)\n‚ä¢ CategoryTheory.Presieve.IsSheaf J (F.op.comp G.val)","decl":"lemma op_comp_isSheaf_of_types [Functor.IsContinuous.{t} F J K] (G : Sheaf K (Type t)) :\n    Presieve.IsSheaf J (F.op ‚ãô G.val) :=\n  Functor.IsContinuous.op_comp_isSheaf_of_types _\n\n"}
{"name":"CategoryTheory.Functor.op_comp_isSheafOfTypes","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù : F.IsContinuous J K\nG : CategoryTheory.Sheaf K (Type t)\n‚ä¢ CategoryTheory.Presieve.IsSheaf J (F.op.comp G.val)","decl":"@[deprecated (since := \"2024-11-26\")] alias op_comp_isSheafOfTypes := op_comp_isSheaf_of_types\n\n"}
{"name":"CategoryTheory.Functor.op_comp_isSheaf","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA : Type u\ninst‚úù¬π : CategoryTheory.Category.{t, u} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù : F.IsContinuous J K\nG : CategoryTheory.Sheaf K A\n‚ä¢ CategoryTheory.Presheaf.IsSheaf J (F.op.comp G.val)","decl":"lemma op_comp_isSheaf [Functor.IsContinuous.{t} F J K] (G : Sheaf K A) :\n    Presheaf.IsSheaf J (F.op ‚ãô G.val) :=\n  fun T => F.op_comp_isSheaf_of_types J K ‚ü®_, (isSheaf_iff_isSheaf_of_type _ _).2 (G.cond T)‚ü©\n\n"}
{"name":"CategoryTheory.Functor.isContinuous_of_iso","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F‚ÇÅ F‚ÇÇ\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù : F‚ÇÅ.IsContinuous J K\n‚ä¢ F‚ÇÇ.IsContinuous J K","decl":"lemma isContinuous_of_iso {F‚ÇÅ F‚ÇÇ : C ‚•§ D} (e : F‚ÇÅ ‚âÖ F‚ÇÇ)\n    (J : GrothendieckTopology C) (K : GrothendieckTopology D)\n    [Functor.IsContinuous.{t} F‚ÇÅ J K] : Functor.IsContinuous.{t} F‚ÇÇ J K where\n  op_comp_isSheaf_of_types G :=\n    Presieve.isSheaf_iso J (isoWhiskerRight (NatIso.op e.symm) _)\n      (F‚ÇÅ.op_comp_isSheaf_of_types J K G)\n\n"}
{"name":"CategoryTheory.Functor.isContinuous_id","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\n‚ä¢ (CategoryTheory.Functor.id C).IsContinuous J J","decl":"instance isContinuous_id : Functor.IsContinuous.{w} (ùü≠ C) J J where\n  op_comp_isSheaf_of_types G := (isSheaf_iff_isSheaf_of_type _ _).1 G.2\n\n"}
{"name":"CategoryTheory.Functor.isContinuous_comp","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF‚ÇÅ : CategoryTheory.Functor C D\nF‚ÇÇ : CategoryTheory.Functor D E\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nL : CategoryTheory.GrothendieckTopology E\ninst‚úù¬π : F‚ÇÅ.IsContinuous J K\ninst‚úù : F‚ÇÇ.IsContinuous K L\n‚ä¢ (F‚ÇÅ.comp F‚ÇÇ).IsContinuous J L","decl":"lemma isContinuous_comp (F‚ÇÅ : C ‚•§ D) (F‚ÇÇ : D ‚•§ E) (J : GrothendieckTopology C)\n    (K : GrothendieckTopology D) (L : GrothendieckTopology E)\n    [Functor.IsContinuous.{t} F‚ÇÅ J K] [Functor.IsContinuous.{t} F‚ÇÇ K L] :\n    Functor.IsContinuous.{t} (F‚ÇÅ ‚ãô F‚ÇÇ) J L where\n  op_comp_isSheaf_of_types G :=\n    F‚ÇÅ.op_comp_isSheaf_of_types J K\n      ‚ü®_,(isSheaf_iff_isSheaf_of_type _ _).2 (F‚ÇÇ.op_comp_isSheaf_of_types K L G)‚ü©\n\n"}
{"name":"CategoryTheory.Functor.isContinuous_comp'","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF‚ÇÅ : CategoryTheory.Functor C D\nF‚ÇÇ : CategoryTheory.Functor D E\nF‚ÇÅ‚ÇÇ : CategoryTheory.Functor C E\ne : CategoryTheory.Iso (F‚ÇÅ.comp F‚ÇÇ) F‚ÇÅ‚ÇÇ\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nL : CategoryTheory.GrothendieckTopology E\ninst‚úù¬π : F‚ÇÅ.IsContinuous J K\ninst‚úù : F‚ÇÇ.IsContinuous K L\n‚ä¢ F‚ÇÅ‚ÇÇ.IsContinuous J L","decl":"lemma isContinuous_comp' {F‚ÇÅ : C ‚•§ D} {F‚ÇÇ : D ‚•§ E} {F‚ÇÅ‚ÇÇ : C ‚•§ E}\n    (e : F‚ÇÅ ‚ãô F‚ÇÇ ‚âÖ F‚ÇÅ‚ÇÇ) (J : GrothendieckTopology C)\n    (K : GrothendieckTopology D) (L : GrothendieckTopology E)\n    [Functor.IsContinuous.{t} F‚ÇÅ J K] [Functor.IsContinuous.{t} F‚ÇÇ K L] :\n    Functor.IsContinuous.{t} F‚ÇÅ‚ÇÇ J L := by\n  have := Functor.isContinuous_comp F‚ÇÅ F‚ÇÇ J K L\n  apply Functor.isContinuous_of_iso e\n\n"}
{"name":"CategoryTheory.Functor.op_comp_isSheaf_of_preservesOneHypercovers","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{t, u} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù¬π : F.PreservesOneHypercovers J K\ninst‚úù : J.IsGeneratedByOneHypercovers\nP : CategoryTheory.Functor (Opposite D) A\nhP : CategoryTheory.Presheaf.IsSheaf K P\n‚ä¢ CategoryTheory.Presheaf.IsSheaf J (F.op.comp P)","decl":"lemma op_comp_isSheaf_of_preservesOneHypercovers\n    [PreservesOneHypercovers.{w} F J K] [GrothendieckTopology.IsGeneratedByOneHypercovers.{w} J]\n    (P : D·µí·µñ ‚•§ A) (hP : Presheaf.IsSheaf K P) :\n    Presheaf.IsSheaf J (F.op ‚ãô P) := by\n  rw [Presheaf.isSheaf_iff_of_isGeneratedByOneHypercovers.{w}]\n  intro X E\n  exact ‚ü®(E.toPreOneHypercover.isLimitMapMultiforkEquiv F P)\n    ((E.map F K).isLimitMultifork ‚ü®P, hP‚ü©)‚ü©\n\n"}
{"name":"CategoryTheory.Functor.isContinuous_of_preservesOneHypercovers","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù¬π : F.PreservesOneHypercovers J K\ninst‚úù : J.IsGeneratedByOneHypercovers\n‚ä¢ F.IsContinuous J K","decl":"lemma isContinuous_of_preservesOneHypercovers\n    [PreservesOneHypercovers.{w} F J K] [GrothendieckTopology.IsGeneratedByOneHypercovers.{w} J] :\n    IsContinuous.{t} F J K where\n  op_comp_isSheaf_of_types := by\n    rintro ‚ü®P, hP‚ü©\n    rw [‚Üê isSheaf_iff_isSheaf_of_type]\n    exact F.op_comp_isSheaf_of_preservesOneHypercovers J K P hP\n\n"}
{"name":"CategoryTheory.Functor.instIsContinuousOfPreservesOneHypercovers","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù : F.PreservesOneHypercovers J K\n‚ä¢ F.IsContinuous J K","decl":"instance [PreservesOneHypercovers.{max u‚ÇÅ v‚ÇÅ} F J K] :\n    IsContinuous.{t} F J K :=\n  isContinuous_of_preservesOneHypercovers.{max u‚ÇÅ v‚ÇÅ} F J K\n\n"}
{"name":"CategoryTheory.Functor.sheafPushforwardContinuous_obj_val_obj","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA : Type u\ninst‚úù¬π : CategoryTheory.Category.{t, u} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù : F.IsContinuous J K\n‚Ñ± : CategoryTheory.Sheaf K A\nX : Opposite C\n‚ä¢ Eq (((F.sheafPushforwardContinuous A J K).obj ‚Ñ±).val.obj X) (‚Ñ±.val.obj { unop := F.obj (Opposite.unop X) })","decl":"/-- The induced functor `Sheaf K A ‚•§ Sheaf J A` given by `F.op ‚ãô _`\nif `F` is a continuous functor.\n-/\n@[simps!]\ndef sheafPushforwardContinuous : Sheaf K A ‚•§ Sheaf J A where\n  obj ‚Ñ± := ‚ü®F.op ‚ãô ‚Ñ±.val, F.op_comp_isSheaf J K ‚Ñ±‚ü©\n  map f := ‚ü®((whiskeringLeft _ _ _).obj F.op).map f.val‚ü©\n\n"}
{"name":"CategoryTheory.Functor.sheafPushforwardContinuous_map_val_app","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA : Type u\ninst‚úù¬π : CategoryTheory.Category.{t, u} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù : F.IsContinuous J K\nX‚úù Y‚úù : CategoryTheory.Sheaf K A\nf : Quiver.Hom X‚úù Y‚úù\nX : Opposite C\n‚ä¢ Eq (((F.sheafPushforwardContinuous A J K).map f).val.app X) (f.val.app { unop := F.obj (Opposite.unop X) })","decl":"/-- The induced functor `Sheaf K A ‚•§ Sheaf J A` given by `F.op ‚ãô _`\nif `F` is a continuous functor.\n-/\n@[simps!]\ndef sheafPushforwardContinuous : Sheaf K A ‚•§ Sheaf J A where\n  obj ‚Ñ± := ‚ü®F.op ‚ãô ‚Ñ±.val, F.op_comp_isSheaf J K ‚Ñ±‚ü©\n  map f := ‚ü®((whiskeringLeft _ _ _).obj F.op).map f.val‚ü©\n\n"}
{"name":"CategoryTheory.Functor.sheafPushforwardContinuous_obj_val_map","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA : Type u\ninst‚úù¬π : CategoryTheory.Category.{t, u} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù : F.IsContinuous J K\n‚Ñ± : CategoryTheory.Sheaf K A\nX‚úù Y‚úù : Opposite C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((F.sheafPushforwardContinuous A J K).obj ‚Ñ±).val.map f) (‚Ñ±.val.map (F.map f.unop).op)","decl":"/-- The induced functor `Sheaf K A ‚•§ Sheaf J A` given by `F.op ‚ãô _`\nif `F` is a continuous functor.\n-/\n@[simps!]\ndef sheafPushforwardContinuous : Sheaf K A ‚•§ Sheaf J A where\n  obj ‚Ñ± := ‚ü®F.op ‚ãô ‚Ñ±.val, F.op_comp_isSheaf J K ‚Ñ±‚ü©\n  map f := ‚ü®((whiskeringLeft _ _ _).obj F.op).map f.val‚ü©\n\n"}
{"name":"CategoryTheory.Functor.sheafPushforwardContinuousCompSheafToPresheafIso_inv_app_app","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA : Type u\ninst‚úù¬π : CategoryTheory.Category.{t, u} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù : F.IsContinuous J K\nX‚úù : CategoryTheory.Sheaf K A\nX : Opposite C\n‚ä¢ Eq (((F.sheafPushforwardContinuousCompSheafToPresheafIso A J K).inv.app X‚úù).app X) (CategoryTheory.CategoryStruct.id (X‚úù.val.obj { unop := F.obj (Opposite.unop X) }))","decl":"/-- The functor `F.sheafPushforwardContinuous A J K : Sheaf K A ‚•§ Sheaf J A`\nis induced by the precomposition with `F.op`. -/\n@[simps!]\ndef sheafPushforwardContinuousCompSheafToPresheafIso :\n    F.sheafPushforwardContinuous A J K ‚ãô sheafToPresheaf J A ‚âÖ\n      sheafToPresheaf K A ‚ãô (whiskeringLeft _ _ _).obj F.op := Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.sheafPushforwardContinuousCompSheafToPresheafIso_hom_app_app","module":"Mathlib.CategoryTheory.Sites.Continuous","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA : Type u\ninst‚úù¬π : CategoryTheory.Category.{t, u} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù : F.IsContinuous J K\nX‚úù : CategoryTheory.Sheaf K A\nX : Opposite C\n‚ä¢ Eq (((F.sheafPushforwardContinuousCompSheafToPresheafIso A J K).hom.app X‚úù).app X) (CategoryTheory.CategoryStruct.id (X‚úù.val.obj { unop := F.obj (Opposite.unop X) }))","decl":"/-- The functor `F.sheafPushforwardContinuous A J K : Sheaf K A ‚•§ Sheaf J A`\nis induced by the precomposition with `F.op`. -/\n@[simps!]\ndef sheafPushforwardContinuousCompSheafToPresheafIso :\n    F.sheafPushforwardContinuous A J K ‚ãô sheafToPresheaf J A ‚âÖ\n      sheafToPresheaf K A ‚ãô (whiskeringLeft _ _ _).obj F.op := Iso.refl _\n\n"}
