{"name":"Encodable.encodek","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\nself : Encodable α\na : α\n⊢ Eq (Encodable.decode (Encodable.encode a)) (Option.some a)","decl":"/-- Constructively countable type. Made from an explicit injection `encode : α → ℕ` and a partial\ninverse `decode : ℕ → Option α`. Note that finite types *are* countable. See `Denumerable` if you\nwish to enforce infiniteness. -/\nclass Encodable (α : Type*) where\n  /-- Encoding from Type α to ℕ -/\n  encode : α → ℕ\n  -- Porting note: was `decode [] : ℕ → Option α`. This means that `decode` does not take the type\n  --explicitly in Lean4\n  /-- Decoding from ℕ to Option α-/\n  decode : ℕ → Option α\n  /-- Invariant relationship between encoding and decoding -/\n  encodek : ∀ a, decode (encode a) = some a\n\n"}
{"name":"Encodable.encode_injective","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\n⊢ Function.Injective Encodable.encode","decl":"theorem encode_injective [Encodable α] : Function.Injective (@encode α _)\n  | x, y, e => Option.some.inj <| by rw [← encodek, e, encodek]\n\n"}
{"name":"Encodable.encode_inj","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\na b : α\n⊢ Iff (Eq (Encodable.encode a) (Encodable.encode b)) (Eq a b)","decl":"@[simp]\ntheorem encode_inj [Encodable α] {a b : α} : encode a = encode b ↔ a = b :=\n  encode_injective.eq_iff\n\n-- The priority of the instance below is less than the priorities of `Subtype.Countable`\n-- and `Quotient.Countable`\n"}
{"name":"Encodable.countable","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\n⊢ Countable α","decl":"instance (priority := 400) countable [Encodable α] : Countable α where\n  exists_injective_nat' := ⟨_,encode_injective⟩\n\n"}
{"name":"Encodable.surjective_decode_iget","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_3\ninst✝¹ : Encodable α\ninst✝ : Inhabited α\n⊢ Function.Surjective fun n => (Encodable.decode n).iget","decl":"theorem surjective_decode_iget (α : Type*) [Encodable α] [Inhabited α] :\n    Surjective fun n => ((Encodable.decode n).iget : α) := fun x =>\n  ⟨Encodable.encode x, by simp_rw [Encodable.encodek]⟩\n\n"}
{"name":"Encodable.encode_ofEquiv","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : Encodable α\ne : Equiv β α\nb : β\n⊢ Eq (Encodable.encode b) (Encodable.encode (e b))","decl":"theorem encode_ofEquiv {α β} [Encodable α] (e : β ≃ α) (b : β) :\n    @encode _ (ofEquiv _ e) b = encode (e b) :=\n  rfl\n\n-- Porting note: removing @[simp], too powerful\n"}
{"name":"Encodable.decode_ofEquiv","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : Encodable α\ne : Equiv β α\nn : Nat\n⊢ Eq (Encodable.decode n) (Option.map (⇑e.symm) (Encodable.decode n))","decl":"theorem decode_ofEquiv {α β} [Encodable α] (e : β ≃ α) (n : ℕ) :\n    @decode _ (ofEquiv _ e) n = (decode n).map e.symm :=\n  show Option.bind _ _ = Option.map _ _\n  by rw [Option.map_eq_bind]\n\n"}
{"name":"Encodable.encode_nat","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"n : Nat\n⊢ Eq (Encodable.encode n) n","decl":"@[simp]\ntheorem encode_nat (n : ℕ) : encode n = n :=\n  rfl\n\n"}
{"name":"Encodable.decode_nat","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"n : Nat\n⊢ Eq (Encodable.decode n) (Option.some n)","decl":"@[simp 1100]\ntheorem decode_nat (n : ℕ) : decode n = some n :=\n  rfl\n\n"}
{"name":"Encodable.encode_star","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"⊢ Eq (Encodable.encode PUnit.unit) 0","decl":"@[simp]\ntheorem encode_star : encode PUnit.unit = 0 :=\n  rfl\n\n"}
{"name":"Encodable.decode_unit_zero","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"⊢ Eq (Encodable.decode 0) (Option.some PUnit.unit)","decl":"@[simp]\ntheorem decode_unit_zero : decode 0 = some PUnit.unit :=\n  rfl\n\n"}
{"name":"Encodable.decode_unit_succ","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"n : Nat\n⊢ Eq (Encodable.decode n.succ) Option.none","decl":"@[simp]\ntheorem decode_unit_succ (n) : decode (succ n) = (none : Option PUnit) :=\n  rfl\n\n"}
{"name":"Encodable.encode_none","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\n⊢ Eq (Encodable.encode Option.none) 0","decl":"@[simp]\ntheorem encode_none [Encodable α] : encode (@none α) = 0 :=\n  rfl\n\n"}
{"name":"Encodable.encode_some","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\na : α\n⊢ Eq (Encodable.encode (Option.some a)) (Encodable.encode a).succ","decl":"@[simp]\ntheorem encode_some [Encodable α] (a : α) : encode (some a) = succ (encode a) :=\n  rfl\n\n"}
{"name":"Encodable.decode_option_zero","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\n⊢ Eq (Encodable.decode 0) (Option.some Option.none)","decl":"@[simp]\ntheorem decode_option_zero [Encodable α] : (decode 0 : Option (Option α))= some none :=\n  rfl\n\n"}
{"name":"Encodable.decode_option_succ","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\nn : Nat\n⊢ Eq (Encodable.decode n.succ) (Option.map Option.some (Encodable.decode n))","decl":"@[simp]\ntheorem decode_option_succ [Encodable α] (n) :\n    (decode (succ n) : Option (Option α)) = (decode n).map some :=\n  rfl\n\n"}
{"name":"Encodable.mem_decode₂'","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\nn : Nat\na : α\n⊢ Iff (Membership.mem (Encodable.decode₂ α n) a) (And (Membership.mem (Encodable.decode n) a) (Eq (Encodable.encode a) n))","decl":"theorem mem_decode₂' [Encodable α] {n : ℕ} {a : α} :\n    a ∈ decode₂ α n ↔ a ∈ decode n ∧ encode a = n := by\n  simpa [decode₂, bind_eq_some] using\n    ⟨fun ⟨_, h₁, rfl, h₂⟩ => ⟨h₁, h₂⟩, fun ⟨h₁, h₂⟩ => ⟨_, h₁, rfl, h₂⟩⟩\n\n"}
{"name":"Encodable.mem_decode₂","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\nn : Nat\na : α\n⊢ Iff (Membership.mem (Encodable.decode₂ α n) a) (Eq (Encodable.encode a) n)","decl":"theorem mem_decode₂ [Encodable α] {n : ℕ} {a : α} : a ∈ decode₂ α n ↔ encode a = n :=\n  mem_decode₂'.trans (and_iff_right_of_imp fun e => e ▸ encodek _)\n\n"}
{"name":"Encodable.decode₂_eq_some","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\nn : Nat\na : α\n⊢ Iff (Eq (Encodable.decode₂ α n) (Option.some a)) (Eq (Encodable.encode a) n)","decl":"theorem decode₂_eq_some [Encodable α] {n : ℕ} {a : α} : decode₂ α n = some a ↔ encode a = n :=\n  mem_decode₂\n\n"}
{"name":"Encodable.decode₂_encode","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\na : α\n⊢ Eq (Encodable.decode₂ α (Encodable.encode a)) (Option.some a)","decl":"@[simp]\ntheorem decode₂_encode [Encodable α] (a : α) : decode₂ α (encode a) = some a := by\n  ext\n  simp [mem_decode₂, eq_comm, decode₂_eq_some]\n\n"}
{"name":"Encodable.decode₂_ne_none_iff","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\nn : Nat\n⊢ Iff (Ne (Encodable.decode₂ α n) Option.none) (Membership.mem (Set.range Encodable.encode) n)","decl":"theorem decode₂_ne_none_iff [Encodable α] {n : ℕ} :\n    decode₂ α n ≠ none ↔ n ∈ Set.range (encode : α → ℕ) := by\n  simp_rw [Set.range, Set.mem_setOf_eq, Ne, Option.eq_none_iff_forall_not_mem,\n    Encodable.mem_decode₂, not_forall, not_not]\n\n"}
{"name":"Encodable.decode₂_is_partial_inv","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\n⊢ Function.IsPartialInv Encodable.encode (Encodable.decode₂ α)","decl":"theorem decode₂_is_partial_inv [Encodable α] : IsPartialInv encode (decode₂ α) := fun _ _ =>\n  mem_decode₂\n\n"}
{"name":"Encodable.decode₂_inj","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\nn : Nat\na₁ a₂ : α\nh₁ : Membership.mem (Encodable.decode₂ α n) a₁\nh₂ : Membership.mem (Encodable.decode₂ α n) a₂\n⊢ Eq a₁ a₂","decl":"theorem decode₂_inj [Encodable α] {n : ℕ} {a₁ a₂ : α} (h₁ : a₁ ∈ decode₂ α n)\n    (h₂ : a₂ ∈ decode₂ α n) : a₁ = a₂ :=\n  encode_injective <| (mem_decode₂.1 h₁).trans (mem_decode₂.1 h₂).symm\n\n"}
{"name":"Encodable.encodek₂","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\na : α\n⊢ Eq (Encodable.decode₂ α (Encodable.encode a)) (Option.some a)","decl":"theorem encodek₂ [Encodable α] (a : α) : decode₂ α (encode a) = some a :=\n  mem_decode₂.2 rfl\n\n"}
{"name":"Encodable.encode_inl","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Encodable α\ninst✝ : Encodable β\na : α\n⊢ Eq (Encodable.encode (Sum.inl a)) (HMul.hMul 2 (Encodable.encode a))","decl":"@[simp]\ntheorem encode_inl (a : α) : @encode (α ⊕ β) _ (Sum.inl a) = 2 * (encode a) :=\n  rfl\n\n-- Porting note: removing bit0 and bit1 from statement\n"}
{"name":"Encodable.encode_inr","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Encodable α\ninst✝ : Encodable β\nb : β\n⊢ Eq (Encodable.encode (Sum.inr b)) (HAdd.hAdd (HMul.hMul 2 (Encodable.encode b)) 1)","decl":"@[simp]\ntheorem encode_inr (b : β) : @encode (α ⊕ β) _ (Sum.inr b) = 2 * (encode b) + 1 :=\n  rfl\n\n"}
{"name":"Encodable.decode_sum_val","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Encodable α\ninst✝ : Encodable β\nn : Nat\n⊢ Eq (Encodable.decode n) (Encodable.decodeSum n)","decl":"@[simp]\ntheorem decode_sum_val (n : ℕ) : (decode n : Option (α ⊕ β)) = decodeSum n :=\n  rfl\n\n"}
{"name":"Encodable.encode_true","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"⊢ Eq (Encodable.encode Bool.true) 1","decl":"@[simp]\ntheorem encode_true : encode true = 1 :=\n  rfl\n\n"}
{"name":"Encodable.encode_false","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"⊢ Eq (Encodable.encode Bool.false) 0","decl":"@[simp]\ntheorem encode_false : encode false = 0 :=\n  rfl\n\n"}
{"name":"Encodable.decode_zero","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"⊢ Eq (Encodable.decode 0) (Option.some Bool.false)","decl":"@[simp]\ntheorem decode_zero : (decode 0 : Option Bool) = some false :=\n  rfl\n\n"}
{"name":"Encodable.decode_one","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"⊢ Eq (Encodable.decode 1) (Option.some Bool.true)","decl":"@[simp]\ntheorem decode_one : (decode 1 : Option Bool) = some true :=\n  rfl\n\n"}
{"name":"Encodable.decode_ge_two","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"n : Nat\nh : LE.le 2 n\n⊢ Eq (Encodable.decode n) Option.none","decl":"theorem decode_ge_two (n) (h : 2 ≤ n) : (decode n : Option Bool) = none := by\n  suffices decodeSum n = none by\n    change (decodeSum n).bind _ = none\n    rw [this]\n    rfl\n  have : 1 ≤ n / 2 := by\n    rw [Nat.le_div_iff_mul_le]\n    exacts [h, by decide]\n  cases' exists_eq_succ_of_ne_zero (_root_.ne_of_gt this) with m e\n  simp only [decodeSum, boddDiv2_eq, div2_val]; cases bodd n <;> simp [e]\n\n"}
{"name":"Encodable.decode_sigma_val","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\nγ : α → Type u_3\ninst✝¹ : Encodable α\ninst✝ : (a : α) → Encodable (γ a)\nn : Nat\n⊢ Eq (Encodable.decode n) ((Encodable.decode (Nat.unpair n).1).bind fun a => Option.map (Sigma.mk a) (Encodable.decode (Nat.unpair n).2))","decl":"@[simp]\ntheorem decode_sigma_val (n : ℕ) :\n    (decode n : Option (Sigma γ)) =\n      (decode n.unpair.1).bind fun a => (decode n.unpair.2).map <| Sigma.mk a :=\n  rfl\n\n"}
{"name":"Encodable.encode_sigma_val","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\nγ : α → Type u_3\ninst✝¹ : Encodable α\ninst✝ : (a : α) → Encodable (γ a)\na : α\nb : γ a\n⊢ Eq (Encodable.encode ⟨a, b⟩) (Nat.pair (Encodable.encode a) (Encodable.encode b))","decl":"@[simp]\ntheorem encode_sigma_val (a b) : @encode (Sigma γ) _ ⟨a, b⟩ = pair (encode a) (encode b) :=\n  rfl\n\n"}
{"name":"Encodable.decode_prod_val","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Encodable α\ninst✝ : Encodable β\nn : Nat\n⊢ Eq (Encodable.decode n) ((Encodable.decode (Nat.unpair n).1).bind fun a => Option.map (Prod.mk a) (Encodable.decode (Nat.unpair n).2))","decl":"@[simp]\ntheorem decode_prod_val (n : ℕ) :\n    (@decode (α × β) _ n : Option (α × β))\n      = (decode n.unpair.1).bind fun a => (decode n.unpair.2).map <| Prod.mk a := by\n  simp only [decode_ofEquiv, Equiv.symm_symm, decode_sigma_val]\n  cases (decode n.unpair.1 : Option α) <;> cases (decode n.unpair.2 : Option β)\n  <;> rfl\n\n"}
{"name":"Encodable.encode_prod_val","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Encodable α\ninst✝ : Encodable β\na : α\nb : β\n⊢ Eq (Encodable.encode { fst := a, snd := b }) (Nat.pair (Encodable.encode a) (Encodable.encode b))","decl":"@[simp]\ntheorem encode_prod_val (a b) : @encode (α × β) _ (a, b) = pair (encode a) (encode b) :=\n  rfl\n\n"}
{"name":"Encodable.Subtype.encode_eq","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\nP : α → Prop\nencA : Encodable α\ndecP : DecidablePred P\na : Subtype P\n⊢ Eq (Encodable.encode a) (Encodable.encode ↑a)","decl":"theorem Subtype.encode_eq (a : Subtype P) : encode a = encode a.val := by cases a; rfl\n\n"}
{"name":"Encodable.nonempty_encodable","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\n⊢ Iff (Nonempty (Encodable α)) (Countable α)","decl":"@[simp]\ntheorem nonempty_encodable : Nonempty (Encodable α) ↔ Countable α :=\n  ⟨fun ⟨h⟩ => @Encodable.countable α h, fun h => ⟨@ofCountable _ h⟩⟩\n\n"}
{"name":"nonempty_encodable","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Countable α\n⊢ Nonempty (Encodable α)","decl":"/-- See also `nonempty_fintype`, `nonempty_denumerable`. -/\ntheorem nonempty_encodable (α : Type*) [Countable α] : Nonempty (Encodable α) :=\n  ⟨Encodable.ofCountable _⟩\n\n"}
{"name":"instCountablePNat","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"⊢ Countable PNat","decl":"instance : Countable ℕ+ := by delta PNat; infer_instance\n\n-- short-circuit instance search\n"}
{"name":"ULower.down_up","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\na : ULower α\n⊢ Eq (ULower.down a.up) a","decl":"@[simp]\ntheorem down_up {a : ULower α} : down a.up = a :=\n  Equiv.right_inv _ _\n\n"}
{"name":"ULower.up_down","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\na : α\n⊢ Eq (ULower.down a).up a","decl":"@[simp]\ntheorem up_down {a : α} : (down a).up = a := by\n  simp [up, down,Equiv.left_inv _ _, Equiv.symm_apply_apply]\n\n"}
{"name":"ULower.up_eq_up","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\na b : ULower α\n⊢ Iff (Eq a.up b.up) (Eq a b)","decl":"@[simp]\ntheorem up_eq_up {a b : ULower α} : a.up = b.up ↔ a = b :=\n  Equiv.apply_eq_iff_eq _\n\n"}
{"name":"ULower.down_eq_down","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\na b : α\n⊢ Iff (Eq (ULower.down a) (ULower.down b)) (Eq a b)","decl":"@[simp]\ntheorem down_eq_down {a b : α} : down a = down b ↔ a = b :=\n  Equiv.apply_eq_iff_eq _\n\n"}
{"name":"ULower.ext","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\na b : ULower α\na✝ : Eq a.up b.up\n⊢ Eq a b","decl":"@[ext]\nprotected theorem ext {a b : ULower α} : a.up = b.up → a = b :=\n  up_eq_up.1\n\n"}
{"name":"ULower.ext_iff","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\na b : ULower α\n⊢ Iff (Eq a b) (Eq a.up b.up)","decl":"@[ext]\nprotected theorem ext {a b : ULower α} : a.up = b.up → a = b :=\n  up_eq_up.1\n\n"}
{"name":"Encodable.choose_spec","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝¹ : Encodable α\ninst✝ : DecidablePred p\nh : Exists fun x => p x\n⊢ p (Encodable.choose h)","decl":"theorem choose_spec (h : ∃ x, p x) : p (choose h) :=\n  (chooseX h).2\n\n"}
{"name":"Encodable.axiom_of_choice","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_2\nR : (x : α) → β x → Prop\ninst✝¹ : (a : α) → Encodable (β a)\ninst✝ : (x : α) → (y : β x) → Decidable (R x y)\nH : ∀ (x : α), Exists fun y => R x y\n⊢ Exists fun f => ∀ (x : α), R x (f x)","decl":"/-- A constructive version of `Classical.axiom_of_choice` for `Encodable` types. -/\ntheorem axiom_of_choice {α : Type*} {β : α → Type*} {R : ∀ x, β x → Prop} [∀ a, Encodable (β a)]\n    [∀ x y, Decidable (R x y)] (H : ∀ x, ∃ y, R x y) : ∃ f : ∀ a, β a, ∀ x, R x (f x) :=\n  ⟨fun x => choose (H x), fun x => choose_spec (H x)⟩\n\n"}
{"name":"Encodable.skolem","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_2\nP : (x : α) → β x → Prop\ninst✝¹ : (a : α) → Encodable (β a)\ninst✝ : (x : α) → (y : β x) → Decidable (P x y)\n⊢ Iff (∀ (x : α), Exists fun y => P x y) (Exists fun f => ∀ (x : α), P x (f x))","decl":"/-- A constructive version of `Classical.skolem` for `Encodable` types. -/\ntheorem skolem {α : Type*} {β : α → Type*} {P : ∀ x, β x → Prop} [∀ a, Encodable (β a)]\n    [∀ x y, Decidable (P x y)] : (∀ x, ∃ y, P x y) ↔ ∃ f : ∀ a, β a, ∀ x, P x (f x) :=\n  ⟨axiom_of_choice, fun ⟨_, H⟩ x => ⟨_, H x⟩⟩\n\n/-\nThere is a total ordering on the elements of an encodable type, induced by the map to ℕ.\n-/\n"}
{"name":"Encodable.instIsAntisymmPreimageNatCoeEmbeddingEncode'Le","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\n⊢ IsAntisymm α (Order.Preimage ⇑(Encodable.encode' α) fun x1 x2 => LE.le x1 x2)","decl":"instance {α} [Encodable α] : IsAntisymm _ (Encodable.encode' α ⁻¹'o (· ≤ ·)) :=\n  (RelEmbedding.preimage _ _).isAntisymm\n\n"}
{"name":"Encodable.instIsTotalPreimageNatCoeEmbeddingEncode'Le","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ninst✝ : Encodable α\n⊢ IsTotal α (Order.Preimage ⇑(Encodable.encode' α) fun x1 x2 => LE.le x1 x2)","decl":"instance {α} [Encodable α] : IsTotal _ (Encodable.encode' α ⁻¹'o (· ≤ ·)) :=\n  (RelEmbedding.preimage _ _).isTotal\n\n"}
{"name":"Directed.sequence_mono_nat","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Encodable α\ninst✝ : Inhabited α\nr : β → β → Prop\nf : α → β\nhf : Directed r f\nn : Nat\n⊢ r (f (Directed.sequence f hf n)) (f (Directed.sequence f hf (HAdd.hAdd n 1)))","decl":"theorem sequence_mono_nat {r : β → β → Prop} {f : α → β} (hf : Directed r f) (n : ℕ) :\n    r (f (hf.sequence f n)) (f (hf.sequence f (n + 1))) := by\n  dsimp [Directed.sequence]\n  generalize hf.sequence f n = p\n  cases' (decode n : Option α) with a\n  · exact (Classical.choose_spec (hf p p)).1\n  · exact (Classical.choose_spec (hf p a)).1\n\n"}
{"name":"Directed.rel_sequence","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Encodable α\ninst✝ : Inhabited α\nr : β → β → Prop\nf : α → β\nhf : Directed r f\na : α\n⊢ r (f a) (f (Directed.sequence f hf (HAdd.hAdd (Encodable.encode a) 1)))","decl":"theorem rel_sequence {r : β → β → Prop} {f : α → β} (hf : Directed r f) (a : α) :\n    r (f a) (f (hf.sequence f (encode a + 1))) := by\n  simp only [Directed.sequence, add_eq, add_zero, encodek, and_self]\n  exact (Classical.choose_spec (hf _ a)).2\n\n"}
{"name":"Directed.sequence_mono","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Encodable α\ninst✝¹ : Inhabited α\ninst✝ : Preorder β\nf : α → β\nhf : Directed (fun x1 x2 => LE.le x1 x2) f\n⊢ Monotone (Function.comp f (Directed.sequence f hf))","decl":"theorem sequence_mono : Monotone (f ∘ hf.sequence f) :=\n  monotone_nat_of_le_succ <| hf.sequence_mono_nat\n\n"}
{"name":"Directed.le_sequence","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Encodable α\ninst✝¹ : Inhabited α\ninst✝ : Preorder β\nf : α → β\nhf : Directed (fun x1 x2 => LE.le x1 x2) f\na : α\n⊢ LE.le (f a) (f (Directed.sequence f hf (HAdd.hAdd (Encodable.encode a) 1)))","decl":"theorem le_sequence (a : α) : f a ≤ f (hf.sequence f (encode a + 1)) :=\n  hf.rel_sequence a\n\n"}
{"name":"Directed.sequence_anti","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Encodable α\ninst✝¹ : Inhabited α\ninst✝ : Preorder β\nf : α → β\nhf : Directed (fun x1 x2 => GE.ge x1 x2) f\n⊢ Antitone (Function.comp f (Directed.sequence f hf))","decl":"theorem sequence_anti : Antitone (f ∘ hf.sequence f) :=\n  antitone_nat_of_succ_le <| hf.sequence_mono_nat\n\n"}
{"name":"Directed.sequence_le","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Encodable α\ninst✝¹ : Inhabited α\ninst✝ : Preorder β\nf : α → β\nhf : Directed (fun x1 x2 => GE.ge x1 x2) f\na : α\n⊢ LE.le (f (Directed.sequence f hf (HAdd.hAdd (Encodable.encode a) 1))) (f a)","decl":"theorem sequence_le (a : α) : f (hf.sequence f (Encodable.encode a + 1)) ≤ f a :=\n  hf.rel_sequence a\n\n"}
{"name":"Quotient.rep_spec","module":"Mathlib.Logic.Encodable.Basic","initialProofState":"α : Type u_1\ns : Setoid α\ninst✝¹ : DecidableRel fun x1 x2 => HasEquiv.Equiv x1 x2\ninst✝ : Encodable α\nq : Quotient s\n⊢ Eq (Quotient.mk s q.rep) q","decl":"theorem Quotient.rep_spec (q : Quotient s) : ⟦q.rep⟧ = q :=\n  choose_spec (exists_rep q)\n\n"}
