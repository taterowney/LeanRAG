{"name":"UniformSpace.to_regularSpace","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\n‚ä¢ RegularSpace Œ±","decl":"instance (priority := 100) UniformSpace.to_regularSpace : RegularSpace Œ± :=\n  .of_hasBasis\n    (fun _ ‚Ü¶ nhds_basis_uniformity' uniformity_hasBasis_closed)\n    fun a _V hV ‚Ü¶ isClosed_ball a hV.2\n\n"}
{"name":"Filter.HasBasis.specializes_iff_uniformity","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\nŒπ : Sort u_1\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set (Prod Œ± Œ±)\nh : (uniformity Œ±).HasBasis p s\nx y : Œ±\n‚ä¢ Iff (Specializes x y) (‚àÄ (i : Œπ), p i ‚Üí Membership.mem (s i) { fst := x, snd := y })","decl":"theorem Filter.HasBasis.specializes_iff_uniformity {Œπ : Sort*} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set (Œ± √ó Œ±)}\n    (h : (ùì§ Œ±).HasBasis p s) {x y : Œ±} : x ‚§≥ y ‚Üî ‚àÄ i, p i ‚Üí (x, y) ‚àà s i :=\n  (nhds_basis_uniformity h).specializes_iff\n\n"}
{"name":"Filter.HasBasis.inseparable_iff_uniformity","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\nŒπ : Sort u_1\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set (Prod Œ± Œ±)\nh : (uniformity Œ±).HasBasis p s\nx y : Œ±\n‚ä¢ Iff (Inseparable x y) (‚àÄ (i : Œπ), p i ‚Üí Membership.mem (s i) { fst := x, snd := y })","decl":"theorem Filter.HasBasis.inseparable_iff_uniformity {Œπ : Sort*} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set (Œ± √ó Œ±)}\n    (h : (ùì§ Œ±).HasBasis p s) {x y : Œ±} : Inseparable x y ‚Üî ‚àÄ i, p i ‚Üí (x, y) ‚àà s i :=\n  specializes_iff_inseparable.symm.trans h.specializes_iff_uniformity\n\n"}
{"name":"inseparable_iff_ker_uniformity","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\nx y : Œ±\n‚ä¢ Iff (Inseparable x y) (Membership.mem (uniformity Œ±).ker { fst := x, snd := y })","decl":"theorem inseparable_iff_ker_uniformity {x y : Œ±} : Inseparable x y ‚Üî (x, y) ‚àà (ùì§ Œ±).ker :=\n  (ùì§ Œ±).basis_sets.inseparable_iff_uniformity\n\n"}
{"name":"Inseparable.nhds_le_uniformity","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\nx y : Œ±\nh : Inseparable x y\n‚ä¢ LE.le (nhds { fst := x, snd := y }) (uniformity Œ±)","decl":"protected theorem Inseparable.nhds_le_uniformity {x y : Œ±} (h : Inseparable x y) :\n    ùìù (x, y) ‚â§ ùì§ Œ± := by\n  rw [h.prod rfl]\n  apply nhds_le_uniformity\n\n"}
{"name":"inseparable_iff_clusterPt_uniformity","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\nx y : Œ±\n‚ä¢ Iff (Inseparable x y) (ClusterPt { fst := x, snd := y } (uniformity Œ±))","decl":"theorem inseparable_iff_clusterPt_uniformity {x y : Œ±} :\n    Inseparable x y ‚Üî ClusterPt (x, y) (ùì§ Œ±) := by\n  refine ‚ü®fun h ‚Ü¶ .of_nhds_le h.nhds_le_uniformity, fun h ‚Ü¶ ?_‚ü©\n  simp_rw [uniformity_hasBasis_closed.inseparable_iff_uniformity, isClosed_iff_clusterPt]\n  exact fun U ‚ü®hU, hUc‚ü© ‚Ü¶ hUc _ <| h.mono <| le_principal_iff.2 hU\n\n"}
{"name":"t0Space_iff_uniformity","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\n‚ä¢ Iff (T0Space Œ±) (‚àÄ (x y : Œ±), (‚àÄ (r : Set (Prod Œ± Œ±)), Membership.mem (uniformity Œ±) r ‚Üí Membership.mem r { fst := x, snd := y }) ‚Üí Eq x y)","decl":"theorem t0Space_iff_uniformity :\n    T0Space Œ± ‚Üî ‚àÄ x y, (‚àÄ r ‚àà ùì§ Œ±, (x, y) ‚àà r) ‚Üí x = y := by\n  simp only [t0Space_iff_inseparable, inseparable_iff_ker_uniformity, mem_ker, id]\n\n"}
{"name":"t0Space_iff_uniformity'","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\n‚ä¢ Iff (T0Space Œ±) (Pairwise fun x y => Exists fun r => And (Membership.mem (uniformity Œ±) r) (Not (Membership.mem r { fst := x, snd := y })))","decl":"theorem t0Space_iff_uniformity' :\n    T0Space Œ± ‚Üî Pairwise fun x y ‚Ü¶ ‚àÉ r ‚àà ùì§ Œ±, (x, y) ‚àâ r := by\n  simp [t0Space_iff_not_inseparable, inseparable_iff_ker_uniformity]\n\n"}
{"name":"t0Space_iff_ker_uniformity","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\n‚ä¢ Iff (T0Space Œ±) (Eq (uniformity Œ±).ker (Set.diagonal Œ±))","decl":"theorem t0Space_iff_ker_uniformity : T0Space Œ± ‚Üî (ùì§ Œ±).ker = diagonal Œ± := by\n  simp_rw [t0Space_iff_uniformity, subset_antisymm_iff, diagonal_subset_iff, subset_def,\n    Prod.forall, Filter.mem_ker, mem_diagonal_iff, iff_self_and]\n  exact fun _ x s hs ‚Ü¶ refl_mem_uniformity hs\n\n"}
{"name":"eq_of_uniformity","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : T0Space Œ±\nx y : Œ±\nh : ‚àÄ {V : Set (Prod Œ± Œ±)}, Membership.mem (uniformity Œ±) V ‚Üí Membership.mem V { fst := x, snd := y }\n‚ä¢ Eq x y","decl":"theorem eq_of_uniformity {Œ± : Type*} [UniformSpace Œ±] [T0Space Œ±] {x y : Œ±}\n    (h : ‚àÄ {V}, V ‚àà ùì§ Œ± ‚Üí (x, y) ‚àà V) : x = y :=\n  t0Space_iff_uniformity.mp ‚ÄπT0Space Œ±‚Ä∫ x y @h\n\n"}
{"name":"eq_of_uniformity_basis","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : T0Space Œ±\nŒπ : Sort u_2\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set (Prod Œ± Œ±)\nhs : (uniformity Œ±).HasBasis p s\nx y : Œ±\nh : ‚àÄ {i : Œπ}, p i ‚Üí Membership.mem (s i) { fst := x, snd := y }\n‚ä¢ Eq x y","decl":"theorem eq_of_uniformity_basis {Œ± : Type*} [UniformSpace Œ±] [T0Space Œ±] {Œπ : Sort*}\n    {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set (Œ± √ó Œ±)} (hs : (ùì§ Œ±).HasBasis p s) {x y : Œ±}\n    (h : ‚àÄ {i}, p i ‚Üí (x, y) ‚àà s i) : x = y :=\n  (hs.inseparable_iff_uniformity.2 @h).eq\n\n"}
{"name":"eq_of_forall_symmetric","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : T0Space Œ±\nx y : Œ±\nh : ‚àÄ {V : Set (Prod Œ± Œ±)}, Membership.mem (uniformity Œ±) V ‚Üí SymmetricRel V ‚Üí Membership.mem V { fst := x, snd := y }\n‚ä¢ Eq x y","decl":"theorem eq_of_forall_symmetric {Œ± : Type*} [UniformSpace Œ±] [T0Space Œ±] {x y : Œ±}\n    (h : ‚àÄ {V}, V ‚àà ùì§ Œ± ‚Üí SymmetricRel V ‚Üí (x, y) ‚àà V) : x = y :=\n  eq_of_uniformity_basis hasBasis_symmetric (by simpa)\n\n"}
{"name":"eq_of_clusterPt_uniformity","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : T0Space Œ±\nx y : Œ±\nh : ClusterPt { fst := x, snd := y } (uniformity Œ±)\n‚ä¢ Eq x y","decl":"theorem eq_of_clusterPt_uniformity [T0Space Œ±] {x y : Œ±} (h : ClusterPt (x, y) (ùì§ Œ±)) : x = y :=\n  (inseparable_iff_clusterPt_uniformity.2 h).eq\n\n"}
{"name":"Filter.Tendsto.inseparable_iff_uniformity","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\ninst‚úù¬π : UniformSpace Œ±\nŒ≤ : Type u_1\nl : Filter Œ≤\ninst‚úù : l.NeBot\nf g : Œ≤ ‚Üí Œ±\na b : Œ±\nha : Filter.Tendsto f l (nhds a)\nhb : Filter.Tendsto g l (nhds b)\n‚ä¢ Iff (Inseparable a b) (Filter.Tendsto (fun x => { fst := f x, snd := g x }) l (uniformity Œ±))","decl":"theorem Filter.Tendsto.inseparable_iff_uniformity {Œ≤} {l : Filter Œ≤} [NeBot l] {f g : Œ≤ ‚Üí Œ±}\n    {a b : Œ±} (ha : Tendsto f l (ùìù a)) (hb : Tendsto g l (ùìù b)) :\n    Inseparable a b ‚Üî Tendsto (fun x ‚Ü¶ (f x, g x)) l (ùì§ Œ±) := by\n  refine ‚ü®fun h ‚Ü¶ (ha.prod_mk_nhds hb).mono_right h.nhds_le_uniformity, fun h ‚Ü¶ ?_‚ü©\n  rw [inseparable_iff_clusterPt_uniformity]\n  exact (ClusterPt.of_le_nhds (ha.prod_mk_nhds hb)).mono h\n\n"}
{"name":"isClosed_of_spaced_out","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : T0Space Œ±\nV‚ÇÄ : Set (Prod Œ± Œ±)\nV‚ÇÄ_in : Membership.mem (uniformity Œ±) V‚ÇÄ\ns : Set Œ±\nhs : s.Pairwise fun x y => Not (Membership.mem V‚ÇÄ { fst := x, snd := y })\n‚ä¢ IsClosed s","decl":"theorem isClosed_of_spaced_out [T0Space Œ±] {V‚ÇÄ : Set (Œ± √ó Œ±)} (V‚ÇÄ_in : V‚ÇÄ ‚àà ùì§ Œ±) {s : Set Œ±}\n    (hs : s.Pairwise fun x y => (x, y) ‚àâ V‚ÇÄ) : IsClosed s := by\n  rcases comp_symm_mem_uniformity_sets V‚ÇÄ_in with ‚ü®V‚ÇÅ, V‚ÇÅ_in, V‚ÇÅ_symm, h_comp‚ü©\n  apply isClosed_of_closure_subset\n  intro x hx\n  rw [mem_closure_iff_ball] at hx\n  rcases hx V‚ÇÅ_in with ‚ü®y, hy, hy'‚ü©\n  suffices x = y by rwa [this]\n  apply eq_of_forall_symmetric\n  intro V V_in _\n  rcases hx (inter_mem V‚ÇÅ_in V_in) with ‚ü®z, hz, hz'‚ü©\n  obtain rfl : z = y := by\n    by_contra hzy\n    exact hs hz' hy' hzy (h_comp <| mem_comp_of_mem_ball V‚ÇÅ_symm (ball_inter_left x _ _ hz) hy)\n  exact ball_inter_right x _ _ hz\n\n"}
{"name":"isClosed_range_of_spaced_out","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\ninst‚úù¬π : UniformSpace Œ±\nŒπ : Type u_1\ninst‚úù : T0Space Œ±\nV‚ÇÄ : Set (Prod Œ± Œ±)\nV‚ÇÄ_in : Membership.mem (uniformity Œ±) V‚ÇÄ\nf : Œπ ‚Üí Œ±\nhf : Pairwise fun x y => Not (Membership.mem V‚ÇÄ { fst := f x, snd := f y })\n‚ä¢ IsClosed (Set.range f)","decl":"theorem isClosed_range_of_spaced_out {Œπ} [T0Space Œ±] {V‚ÇÄ : Set (Œ± √ó Œ±)} (V‚ÇÄ_in : V‚ÇÄ ‚àà ùì§ Œ±)\n    {f : Œπ ‚Üí Œ±} (hf : Pairwise fun x y => (f x, f y) ‚àâ V‚ÇÄ) : IsClosed (range f) :=\n  isClosed_of_spaced_out V‚ÇÄ_in <| by\n    rintro _ ‚ü®x, rfl‚ü© _ ‚ü®y, rfl‚ü© h\n    exact hf (ne_of_apply_ne f h)\n\n"}
{"name":"SeparationQuotient.comap_map_mk_uniformity","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\n‚ä¢ Eq (Filter.comap (Prod.map SeparationQuotient.mk SeparationQuotient.mk) (Filter.map (Prod.map SeparationQuotient.mk SeparationQuotient.mk) (uniformity Œ±))) (uniformity Œ±)","decl":"theorem comap_map_mk_uniformity : comap (Prod.map mk mk) (map (Prod.map mk mk) (ùì§ Œ±)) = ùì§ Œ± := by\n  refine le_antisymm ?_ le_comap_map\n  refine ((((ùì§ Œ±).basis_sets.map _).comap _).le_basis_iff uniformity_hasBasis_open).2 fun U hU ‚Ü¶ ?_\n  refine ‚ü®U, hU.1, fun (x‚ÇÅ, x‚ÇÇ) ‚ü®(y‚ÇÅ, y‚ÇÇ), hyU, hxy‚ü© ‚Ü¶ ?_‚ü©\n  simp only [Prod.map, Prod.ext_iff, mk_eq_mk] at hxy\n  exact ((hxy.1.prod hxy.2).mem_open_iff hU.2).1 hyU\n\n"}
{"name":"SeparationQuotient.uniformity_eq","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\n‚ä¢ Eq (uniformity (SeparationQuotient Œ±)) (Filter.map (Prod.map SeparationQuotient.mk SeparationQuotient.mk) (uniformity Œ±))","decl":"theorem uniformity_eq : ùì§ (SeparationQuotient Œ±) = (ùì§ Œ±).map (Prod.map mk mk) := rfl\n\n"}
{"name":"SeparationQuotient.uniformContinuous_mk","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\n‚ä¢ UniformContinuous SeparationQuotient.mk","decl":"theorem uniformContinuous_mk : UniformContinuous (mk : Œ± ‚Üí SeparationQuotient Œ±) :=\n  le_rfl\n\n"}
{"name":"SeparationQuotient.uniformContinuous_dom","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : SeparationQuotient Œ± ‚Üí Œ≤\n‚ä¢ Iff (UniformContinuous f) (UniformContinuous (Function.comp f SeparationQuotient.mk))","decl":"theorem uniformContinuous_dom {f : SeparationQuotient Œ± ‚Üí Œ≤} :\n    UniformContinuous f ‚Üî UniformContinuous (f ‚àò mk) :=\n  .rfl\n\n"}
{"name":"SeparationQuotient.uniformContinuous_dom‚ÇÇ","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\nf : Prod (SeparationQuotient Œ±) (SeparationQuotient Œ≤) ‚Üí Œ≥\n‚ä¢ Iff (UniformContinuous f) (UniformContinuous fun p => f { fst := SeparationQuotient.mk p.1, snd := SeparationQuotient.mk p.2 })","decl":"theorem uniformContinuous_dom‚ÇÇ {f : SeparationQuotient Œ± √ó SeparationQuotient Œ≤ ‚Üí Œ≥} :\n    UniformContinuous f ‚Üî UniformContinuous fun p : Œ± √ó Œ≤ ‚Ü¶ f (mk p.1, mk p.2) := by\n  simp only [UniformContinuous, uniformity_prod_eq_prod, uniformity_eq, prod_map_map_eq,\n    tendsto_map'_iff]\n  rfl\n\n"}
{"name":"SeparationQuotient.uniformContinuous_lift","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : ‚àÄ (a b : Œ±), Inseparable a b ‚Üí Eq (f a) (f b)\n‚ä¢ Iff (UniformContinuous (SeparationQuotient.lift f h)) (UniformContinuous f)","decl":"theorem uniformContinuous_lift {f : Œ± ‚Üí Œ≤} (h : ‚àÄ a b, Inseparable a b ‚Üí f a = f b) :\n    UniformContinuous (lift f h) ‚Üî UniformContinuous f :=\n  .rfl\n\n"}
{"name":"SeparationQuotient.uniformContinuous_uncurry_lift‚ÇÇ","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\nf : Œ± ‚Üí Œ≤ ‚Üí Œ≥\nh : ‚àÄ (a : Œ±) (c : Œ≤) (b : Œ±) (d : Œ≤), Inseparable a b ‚Üí Inseparable c d ‚Üí Eq (f a c) (f b d)\n‚ä¢ Iff (UniformContinuous (Function.uncurry (SeparationQuotient.lift‚ÇÇ f h))) (UniformContinuous (Function.uncurry f))","decl":"theorem uniformContinuous_uncurry_lift‚ÇÇ {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥}\n    (h : ‚àÄ a c b d, Inseparable a b ‚Üí Inseparable c d ‚Üí f a c = f b d) :\n    UniformContinuous (uncurry <| lift‚ÇÇ f h) ‚Üî UniformContinuous (uncurry f) :=\n  uniformContinuous_dom‚ÇÇ\n\n"}
{"name":"SeparationQuotient.comap_mk_uniformity","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\n‚ä¢ Eq (Filter.comap (Prod.map SeparationQuotient.mk SeparationQuotient.mk) (uniformity (SeparationQuotient Œ±))) (uniformity Œ±)","decl":"theorem comap_mk_uniformity : (ùì§ (SeparationQuotient Œ±)).comap (Prod.map mk mk) = ùì§ Œ± :=\n  comap_map_mk_uniformity\n\n"}
{"name":"SeparationQuotient.lift'_mk","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : T0Space Œ≤\nf : Œ± ‚Üí Œ≤\nh : UniformContinuous f\na : Œ±\n‚ä¢ Eq (SeparationQuotient.lift' f (SeparationQuotient.mk a)) (f a)","decl":"theorem lift'_mk [T0Space Œ≤] {f : Œ± ‚Üí Œ≤} (h : UniformContinuous f) (a : Œ±) :\n    lift' f (mk a) = f a := by rw [lift', dif_pos h, lift_mk]\n\n"}
{"name":"SeparationQuotient.uniformContinuous_lift'","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : T0Space Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ UniformContinuous (SeparationQuotient.lift' f)","decl":"theorem uniformContinuous_lift' [T0Space Œ≤] (f : Œ± ‚Üí Œ≤) : UniformContinuous (lift' f) := by\n  by_cases hf : UniformContinuous f\n  ¬∑ rwa [lift', dif_pos hf, uniformContinuous_lift]\n  ¬∑ rw [lift', dif_neg hf]\n    exact uniformContinuous_of_const fun a _ => rfl\n\n"}
{"name":"SeparationQuotient.map_mk","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : UniformContinuous f\na : Œ±\n‚ä¢ Eq (SeparationQuotient.map f (SeparationQuotient.mk a)) (SeparationQuotient.mk (f a))","decl":"theorem map_mk {f : Œ± ‚Üí Œ≤} (h : UniformContinuous f) (a : Œ±) : map f (mk a) = mk (f a) := by\n  rw [map, lift'_mk (uniformContinuous_mk.comp h)]; rfl\n\n"}
{"name":"SeparationQuotient.uniformContinuous_map","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ UniformContinuous (SeparationQuotient.map f)","decl":"theorem uniformContinuous_map (f : Œ± ‚Üí Œ≤) : UniformContinuous (map f) :=\n  uniformContinuous_lift' _\n\n"}
{"name":"SeparationQuotient.map_unique","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : UniformContinuous f\ng : SeparationQuotient Œ± ‚Üí SeparationQuotient Œ≤\ncomm : Eq (Function.comp SeparationQuotient.mk f) (Function.comp g SeparationQuotient.mk)\n‚ä¢ Eq (SeparationQuotient.map f) g","decl":"theorem map_unique {f : Œ± ‚Üí Œ≤} (hf : UniformContinuous f)\n    {g : SeparationQuotient Œ± ‚Üí SeparationQuotient Œ≤} (comm : mk ‚àò f = g ‚àò mk) : map f = g := by\n  ext ‚ü®a‚ü©\n  calc\n    map f ‚ü¶a‚üß = ‚ü¶f a‚üß := map_mk hf a\n    _ = g ‚ü¶a‚üß := congr_fun comm a\n\n"}
{"name":"SeparationQuotient.map_id","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\n‚ä¢ Eq (SeparationQuotient.map id) id","decl":"@[simp]\ntheorem map_id : map (@id Œ±) = id := map_unique uniformContinuous_id rfl\n\n"}
{"name":"SeparationQuotient.map_comp","module":"Mathlib.Topology.UniformSpace.Separation","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\nf : Œ± ‚Üí Œ≤\ng : Œ≤ ‚Üí Œ≥\nhf : UniformContinuous f\nhg : UniformContinuous g\n‚ä¢ Eq (Function.comp (SeparationQuotient.map g) (SeparationQuotient.map f)) (SeparationQuotient.map (Function.comp g f))","decl":"theorem map_comp {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} (hf : UniformContinuous f) (hg : UniformContinuous g) :\n    map g ‚àò map f = map (g ‚àò f) :=\n  (map_unique (hg.comp hf) <| by simp only [Function.comp_def, map_mk, hf, hg]).symm\n\n"}
