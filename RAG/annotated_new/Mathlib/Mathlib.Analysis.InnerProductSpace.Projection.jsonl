{"name":"exists_norm_eq_iInf_of_complete_convex","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"F : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nK : Set F\nne : K.Nonempty\nhâ‚ : IsComplete K\nhâ‚‚ : Convex Real K\nu : F\nâŠ¢ Exists fun v => And (Membership.mem K v) (Eq (Norm.norm (HSub.hSub u v)) (iInf fun w => Norm.norm (HSub.hSub u â†‘w)))","decl":"/-- **Existence of minimizers**, aka the **Hilbert projection theorem**.\n\nLet `u` be a point in a real inner product space, and let `K` be a nonempty complete convex subset.\nThen there exists a (unique) `v` in `K` that minimizes the distance `â€–u - vâ€–` to `u`. -/\ntheorem exists_norm_eq_iInf_of_complete_convex {K : Set F} (ne : K.Nonempty) (hâ‚ : IsComplete K)\n    (hâ‚‚ : Convex â„ K) : âˆ€ u : F, âˆƒ v âˆˆ K, â€–u - vâ€– = â¨… w : K, â€–u - wâ€– := fun u => by\n  let Î´ := â¨… w : K, â€–u - wâ€–\n  letI : Nonempty K := ne.to_subtype\n  have zero_le_Î´ : 0 â‰¤ Î´ := le_ciInf fun _ => norm_nonneg _\n  have Î´_le : âˆ€ w : K, Î´ â‰¤ â€–u - wâ€– := ciInf_le âŸ¨0, Set.forall_mem_range.2 fun _ => norm_nonneg _âŸ©\n  have Î´_le' : âˆ€ w âˆˆ K, Î´ â‰¤ â€–u - wâ€– := fun w hw => Î´_le âŸ¨w, hwâŸ©\n  -- Step 1: since `Î´` is the infimum, can find a sequence `w : â„• â†’ K` in `K`\n  -- such that `â€–u - w nâ€– < Î´ + 1 / (n + 1)` (which implies `â€–u - w nâ€– --> Î´`);\n  -- maybe this should be a separate lemma\n  have exists_seq : âˆƒ w : â„• â†’ K, âˆ€ n, â€–u - w nâ€– < Î´ + 1 / (n + 1) := by\n    have hÎ´ : âˆ€ n : â„•, Î´ < Î´ + 1 / (n + 1) := fun n =>\n      lt_add_of_le_of_pos le_rfl Nat.one_div_pos_of_nat\n    have h := fun n => exists_lt_of_ciInf_lt (hÎ´ n)\n    let w : â„• â†’ K := fun n => Classical.choose (h n)\n    exact âŸ¨w, fun n => Classical.choose_spec (h n)âŸ©\n  rcases exists_seq with âŸ¨w, hwâŸ©\n  have norm_tendsto : Tendsto (fun n => â€–u - w nâ€–) atTop (ğ“ Î´) := by\n    have h : Tendsto (fun _ : â„• => Î´) atTop (ğ“ Î´) := tendsto_const_nhds\n    have h' : Tendsto (fun n : â„• => Î´ + 1 / (n + 1)) atTop (ğ“ Î´) := by\n      convert h.add tendsto_one_div_add_atTop_nhds_zero_nat\n      simp only [add_zero]\n    exact tendsto_of_tendsto_of_tendsto_of_le_of_le h h' (fun x => Î´_le _) fun x => le_of_lt (hw _)\n  -- Step 2: Prove that the sequence `w : â„• â†’ K` is a Cauchy sequence\n  have seq_is_cauchy : CauchySeq fun n => (w n : F) := by\n    rw [cauchySeq_iff_le_tendsto_0]\n    -- splits into three goals\n    let b := fun n : â„• => 8 * Î´ * (1 / (n + 1)) + 4 * (1 / (n + 1)) * (1 / (n + 1))\n    use fun n => âˆš(b n)\n    constructor\n    -- first goal :  `âˆ€ (n : â„•), 0 â‰¤ âˆš(b n)`\n    Â· intro n\n      exact sqrt_nonneg _\n    constructor\n    -- second goal : `âˆ€ (n m N : â„•), N â‰¤ n â†’ N â‰¤ m â†’ dist â†‘(w n) â†‘(w m) â‰¤ âˆš(b N)`\n    Â· intro p q N hp hq\n      let wp := (w p : F)\n      let wq := (w q : F)\n      let a := u - wq\n      let b := u - wp\n      let half := 1 / (2 : â„)\n      let div := 1 / ((N : â„) + 1)\n      have :\n        4 * â€–u - half â€¢ (wq + wp)â€– * â€–u - half â€¢ (wq + wp)â€– + â€–wp - wqâ€– * â€–wp - wqâ€– =\n          2 * (â€–aâ€– * â€–aâ€– + â€–bâ€– * â€–bâ€–) :=\n        calc\n          4 * â€–u - half â€¢ (wq + wp)â€– * â€–u - half â€¢ (wq + wp)â€– + â€–wp - wqâ€– * â€–wp - wqâ€– =\n              2 * â€–u - half â€¢ (wq + wp)â€– * (2 * â€–u - half â€¢ (wq + wp)â€–) + â€–wp - wqâ€– * â€–wp - wqâ€– :=\n            by ring\n          _ =\n              absR (2 : â„) * â€–u - half â€¢ (wq + wp)â€– * (absR (2 : â„) * â€–u - half â€¢ (wq + wp)â€–) +\n                â€–wp - wqâ€– * â€–wp - wqâ€– := by\n            rw [_root_.abs_of_nonneg]\n            exact zero_le_two\n          _ =\n              â€–(2 : â„) â€¢ (u - half â€¢ (wq + wp))â€– * â€–(2 : â„) â€¢ (u - half â€¢ (wq + wp))â€– +\n                â€–wp - wqâ€– * â€–wp - wqâ€– := by simp [norm_smul]\n          _ = â€–a + bâ€– * â€–a + bâ€– + â€–a - bâ€– * â€–a - bâ€– := by\n            rw [smul_sub, smul_smul, mul_one_div_cancel (_root_.two_ne_zero : (2 : â„) â‰  0), â†\n              one_add_one_eq_two, add_smul]\n            simp only [one_smul]\n            have eqâ‚ : wp - wq = a - b := (sub_sub_sub_cancel_left _ _ _).symm\n            have eqâ‚‚ : u + u - (wq + wp) = a + b := by\n              show u + u - (wq + wp) = u - wq + (u - wp)\n              abel\n            rw [eqâ‚, eqâ‚‚]\n          _ = 2 * (â€–aâ€– * â€–aâ€– + â€–bâ€– * â€–bâ€–) := parallelogram_law_with_norm â„ _ _\n      have eq : Î´ â‰¤ â€–u - half â€¢ (wq + wp)â€– := by\n        rw [smul_add]\n        apply Î´_le'\n        apply hâ‚‚\n        repeat' exact Subtype.mem _\n        repeat' exact le_of_lt one_half_pos\n        exact add_halves 1\n      have eqâ‚ : 4 * Î´ * Î´ â‰¤ 4 * â€–u - half â€¢ (wq + wp)â€– * â€–u - half â€¢ (wq + wp)â€– := by\n        simp_rw [mul_assoc]\n        gcongr\n      have eqâ‚‚ : â€–aâ€– â‰¤ Î´ + div :=\n          le_trans (le_of_lt <| hw q) (add_le_add_left (Nat.one_div_le_one_div hq) _)\n      have eqâ‚‚' : â€–bâ€– â‰¤ Î´ + div :=\n          le_trans (le_of_lt <| hw p) (add_le_add_left (Nat.one_div_le_one_div hp) _)\n      rw [dist_eq_norm]\n      apply nonneg_le_nonneg_of_sq_le_sq\n      Â· exact sqrt_nonneg _\n      rw [mul_self_sqrt]\n      Â· calc\n        â€–wp - wqâ€– * â€–wp - wqâ€– =\n            2 * (â€–aâ€– * â€–aâ€– + â€–bâ€– * â€–bâ€–) - 4 * â€–u - half â€¢ (wq + wp)â€– * â€–u - half â€¢ (wq + wp)â€– := by\n          simp [â† this]\n        _ â‰¤ 2 * (â€–aâ€– * â€–aâ€– + â€–bâ€– * â€–bâ€–) - 4 * Î´ * Î´ := by gcongr\n        _ â‰¤ 2 * ((Î´ + div) * (Î´ + div) + (Î´ + div) * (Î´ + div)) - 4 * Î´ * Î´ := by gcongr\n        _ = 8 * Î´ * div + 4 * div * div := by ring\n      positivity\n    -- third goal : `Tendsto (fun (n : â„•) => âˆš(b n)) atTop (ğ“ 0)`\n    suffices Tendsto (fun x â†¦ âˆš(8 * Î´ * x + 4 * x * x) : â„ â†’ â„) (ğ“ 0) (ğ“ 0)\n      from this.comp tendsto_one_div_add_atTop_nhds_zero_nat\n    exact Continuous.tendsto' (by fun_prop) _ _ (by simp)\n  -- Step 3: By completeness of `K`, let `w : â„• â†’ K` converge to some `v : K`.\n  -- Prove that it satisfies all requirements.\n  rcases cauchySeq_tendsto_of_isComplete hâ‚ (fun n => Subtype.mem _) seq_is_cauchy with\n    âŸ¨v, hv, w_tendstoâŸ©\n  use v\n  use hv\n  have h_cont : Continuous fun v => â€–u - vâ€– :=\n    Continuous.comp continuous_norm (Continuous.sub continuous_const continuous_id)\n  have : Tendsto (fun n => â€–u - w nâ€–) atTop (ğ“ â€–u - vâ€–) := by\n    convert Tendsto.comp h_cont.continuousAt w_tendsto\n  exact tendsto_nhds_unique this norm_tendsto\n\n"}
{"name":"norm_eq_iInf_iff_real_inner_le_zero","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"F : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nK : Set F\nh : Convex Real K\nu v : F\nhv : Membership.mem K v\nâŠ¢ Iff (Eq (Norm.norm (HSub.hSub u v)) (iInf fun w => Norm.norm (HSub.hSub u â†‘w))) (âˆ€ (w : F), Membership.mem K w â†’ LE.le (Inner.inner (HSub.hSub u v) (HSub.hSub w v)) 0)","decl":"/-- Characterization of minimizers for the projection on a convex set in a real inner product\nspace. -/\ntheorem norm_eq_iInf_iff_real_inner_le_zero {K : Set F} (h : Convex â„ K) {u : F} {v : F}\n    (hv : v âˆˆ K) : (â€–u - vâ€– = â¨… w : K, â€–u - wâ€–) â†” âˆ€ w âˆˆ K, âŸªu - v, w - vâŸ«_â„ â‰¤ 0 := by\n  letI : Nonempty K := âŸ¨âŸ¨v, hvâŸ©âŸ©\n  constructor\n  Â· intro eq w hw\n    let Î´ := â¨… w : K, â€–u - wâ€–\n    let p := âŸªu - v, w - vâŸ«_â„\n    let q := â€–w - vâ€– ^ 2\n    have Î´_le (w : K) : Î´ â‰¤ â€–u - wâ€– := ciInf_le âŸ¨0, fun _ âŸ¨_, hâŸ© => h â–¸ norm_nonneg _âŸ© _\n    have Î´_le' (w) (hw : w âˆˆ K) : Î´ â‰¤ â€–u - wâ€– := Î´_le âŸ¨w, hwâŸ©\n    have (Î¸ : â„) (hÎ¸â‚ : 0 < Î¸) (hÎ¸â‚‚ : Î¸ â‰¤ 1) : 2 * p â‰¤ Î¸ * q := by\n      have : â€–u - vâ€– ^ 2 â‰¤ â€–u - vâ€– ^ 2 - 2 * Î¸ * âŸªu - v, w - vâŸ«_â„ + Î¸ * Î¸ * â€–w - vâ€– ^ 2 :=\n        calc â€–u - vâ€– ^ 2\n          _ â‰¤ â€–u - (Î¸ â€¢ w + (1 - Î¸) â€¢ v)â€– ^ 2 := by\n            simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)\n            rw [eq]; apply Î´_le'\n            apply h hw hv\n            exacts [le_of_lt hÎ¸â‚, sub_nonneg.2 hÎ¸â‚‚, add_sub_cancel _ _]\n          _ = â€–u - v - Î¸ â€¢ (w - v)â€– ^ 2 := by\n            have : u - (Î¸ â€¢ w + (1 - Î¸) â€¢ v) = u - v - Î¸ â€¢ (w - v) := by\n              rw [smul_sub, sub_smul, one_smul]\n              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]\n            rw [this]\n          _ = â€–u - vâ€– ^ 2 - 2 * Î¸ * inner (u - v) (w - v) + Î¸ * Î¸ * â€–w - vâ€– ^ 2 := by\n            rw [@norm_sub_sq â„, inner_smul_right, norm_smul]\n            simp only [sq]\n            show\n              â€–u - vâ€– * â€–u - vâ€– - 2 * (Î¸ * inner (u - v) (w - v)) +\n                absR Î¸ * â€–w - vâ€– * (absR Î¸ * â€–w - vâ€–) =\n              â€–u - vâ€– * â€–u - vâ€– - 2 * Î¸ * inner (u - v) (w - v) + Î¸ * Î¸ * (â€–w - vâ€– * â€–w - vâ€–)\n            rw [abs_of_pos hÎ¸â‚]; ring\n      have eqâ‚ :\n        â€–u - vâ€– ^ 2 - 2 * Î¸ * inner (u - v) (w - v) + Î¸ * Î¸ * â€–w - vâ€– ^ 2 =\n          â€–u - vâ€– ^ 2 + (Î¸ * Î¸ * â€–w - vâ€– ^ 2 - 2 * Î¸ * inner (u - v) (w - v)) := by\n        abel\n      rw [eqâ‚, le_add_iff_nonneg_right] at this\n      have eqâ‚‚ :\n        Î¸ * Î¸ * â€–w - vâ€– ^ 2 - 2 * Î¸ * inner (u - v) (w - v) =\n          Î¸ * (Î¸ * â€–w - vâ€– ^ 2 - 2 * inner (u - v) (w - v)) := by ring\n      rw [eqâ‚‚] at this\n      exact le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hÎ¸â‚)\n    by_cases hq : q = 0\n    Â· rw [hq] at this\n      have : p â‰¤ 0 := by\n        have := this (1 : â„) (by norm_num) (by norm_num)\n        linarith\n      exact this\n    Â· have q_pos : 0 < q := lt_of_le_of_ne (sq_nonneg _) fun h â†¦ hq h.symm\n      by_contra hp\n      rw [not_le] at hp\n      let Î¸ := min (1 : â„) (p / q)\n      have eqâ‚ : Î¸ * q â‰¤ p :=\n        calc\n          Î¸ * q â‰¤ p / q * q := mul_le_mul_of_nonneg_right (min_le_right _ _) (sq_nonneg _)\n          _ = p := div_mul_cancelâ‚€ _ hq\n      have : 2 * p â‰¤ p :=\n        calc\n          2 * p â‰¤ Î¸ * q := by\n            exact this Î¸ (lt_min (by norm_num) (div_pos hp q_pos)) (by norm_num [Î¸])\n          _ â‰¤ p := eqâ‚\n      linarith\n  Â· intro h\n    apply le_antisymm\n    Â· apply le_ciInf\n      intro w\n      apply nonneg_le_nonneg_of_sq_le_sq (norm_nonneg _)\n      have := h w w.2\n      calc\n        â€–u - vâ€– * â€–u - vâ€– â‰¤ â€–u - vâ€– * â€–u - vâ€– - 2 * inner (u - v) ((w : F) - v) := by linarith\n        _ â‰¤ â€–u - vâ€– ^ 2 - 2 * inner (u - v) ((w : F) - v) + â€–(w : F) - vâ€– ^ 2 := by\n          rw [sq]\n          refine le_add_of_nonneg_right ?_\n          exact sq_nonneg _\n        _ = â€–u - v - (w - v)â€– ^ 2 := (@norm_sub_sq â„ _ _ _ _ _ _).symm\n        _ = â€–u - wâ€– * â€–u - wâ€– := by\n          have : u - v - (w - v) = u - w := by abel\n          rw [this, sq]\n    Â· show â¨… w : K, â€–u - wâ€– â‰¤ (fun w : K => â€–u - wâ€–) âŸ¨v, hvâŸ©\n      apply ciInf_le\n      use 0\n      rintro y âŸ¨z, rflâŸ©\n      exact norm_nonneg _\n\n"}
{"name":"exists_norm_eq_iInf_of_complete_subspace","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nh : IsComplete â†‘K\nu : E\nâŠ¢ Exists fun v => And (Membership.mem K v) (Eq (Norm.norm (HSub.hSub u v)) (iInf fun w => Norm.norm (HSub.hSub u â†‘w)))","decl":"/-- Existence of projections on complete subspaces.\nLet `u` be a point in an inner product space, and let `K` be a nonempty complete subspace.\nThen there exists a (unique) `v` in `K` that minimizes the distance `â€–u - vâ€–` to `u`.\nThis point `v` is usually called the orthogonal projection of `u` onto `K`.\n-/\ntheorem exists_norm_eq_iInf_of_complete_subspace (h : IsComplete (â†‘K : Set E)) :\n    âˆ€ u : E, âˆƒ v âˆˆ K, â€–u - vâ€– = â¨… w : (K : Set E), â€–u - wâ€– := by\n  letI : InnerProductSpace â„ E := InnerProductSpace.rclikeToReal ğ•œ E\n  letI : Module â„ E := RestrictScalars.module â„ ğ•œ E\n  let K' : Submodule â„ E := Submodule.restrictScalars â„ K\n  exact exists_norm_eq_iInf_of_complete_convex âŸ¨0, K'.zero_memâŸ© h K'.convex\n\n"}
{"name":"norm_eq_iInf_iff_real_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"F : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nK : Submodule Real F\nu v : F\nhv : Membership.mem K v\nâŠ¢ Iff (Eq (Norm.norm (HSub.hSub u v)) (iInf fun w => Norm.norm (HSub.hSub u â†‘w))) (âˆ€ (w : F), Membership.mem K w â†’ Eq (Inner.inner (HSub.hSub u v) w) 0)","decl":"/-- Characterization of minimizers in the projection on a subspace, in the real case.\nLet `u` be a point in a real inner product space, and let `K` be a nonempty subspace.\nThen point `v` minimizes the distance `â€–u - vâ€–` over points in `K` if and only if\nfor all `w âˆˆ K`, `âŸªu - v, wâŸ« = 0` (i.e., `u - v` is orthogonal to the subspace `K`).\nThis is superseded by `norm_eq_iInf_iff_inner_eq_zero` that gives the same conclusion over\nany `RCLike` field.\n-/\ntheorem norm_eq_iInf_iff_real_inner_eq_zero (K : Submodule â„ F) {u : F} {v : F} (hv : v âˆˆ K) :\n    (â€–u - vâ€– = â¨… w : (â†‘K : Set F), â€–u - wâ€–) â†” âˆ€ w âˆˆ K, âŸªu - v, wâŸ«_â„ = 0 :=\n  Iff.intro\n    (by\n      intro h\n      have h : âˆ€ w âˆˆ K, âŸªu - v, w - vâŸ«_â„ â‰¤ 0 := by\n        rwa [norm_eq_iInf_iff_real_inner_le_zero] at h\n        exacts [K.convex, hv]\n      intro w hw\n      have le : âŸªu - v, wâŸ«_â„ â‰¤ 0 := by\n        let w' := w + v\n        have : w' âˆˆ K := Submodule.add_mem _ hw hv\n        have hâ‚ := h w' this\n        have hâ‚‚ : w' - v = w := by\n          simp only [w', add_neg_cancel_right, sub_eq_add_neg]\n        rw [hâ‚‚] at hâ‚\n        exact hâ‚\n      have ge : âŸªu - v, wâŸ«_â„ â‰¥ 0 := by\n        let w'' := -w + v\n        have : w'' âˆˆ K := Submodule.add_mem _ (Submodule.neg_mem _ hw) hv\n        have hâ‚ := h w'' this\n        have hâ‚‚ : w'' - v = -w := by\n          simp only [w'', neg_inj, add_neg_cancel_right, sub_eq_add_neg]\n        rw [hâ‚‚, inner_neg_right] at hâ‚\n        linarith\n      exact le_antisymm le ge)\n    (by\n      intro h\n      have : âˆ€ w âˆˆ K, âŸªu - v, w - vâŸ«_â„ â‰¤ 0 := by\n        intro w hw\n        let w' := w - v\n        have : w' âˆˆ K := Submodule.sub_mem _ hw hv\n        have hâ‚ := h w' this\n        exact le_of_eq hâ‚\n      rwa [norm_eq_iInf_iff_real_inner_le_zero]\n      exacts [Submodule.convex _, hv])\n\n"}
{"name":"norm_eq_iInf_iff_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nu v : E\nhv : Membership.mem K v\nâŠ¢ Iff (Eq (Norm.norm (HSub.hSub u v)) (iInf fun w => Norm.norm (HSub.hSub u â†‘w))) (âˆ€ (w : E), Membership.mem K w â†’ Eq (Inner.inner (HSub.hSub u v) w) 0)","decl":"/-- Characterization of minimizers in the projection on a subspace.\nLet `u` be a point in an inner product space, and let `K` be a nonempty subspace.\nThen point `v` minimizes the distance `â€–u - vâ€–` over points in `K` if and only if\nfor all `w âˆˆ K`, `âŸªu - v, wâŸ« = 0` (i.e., `u - v` is orthogonal to the subspace `K`)\n-/\ntheorem norm_eq_iInf_iff_inner_eq_zero {u : E} {v : E} (hv : v âˆˆ K) :\n    (â€–u - vâ€– = â¨… w : K, â€–u - wâ€–) â†” âˆ€ w âˆˆ K, âŸªu - v, wâŸ« = 0 := by\n  letI : InnerProductSpace â„ E := InnerProductSpace.rclikeToReal ğ•œ E\n  letI : Module â„ E := RestrictScalars.module â„ ğ•œ E\n  let K' : Submodule â„ E := K.restrictScalars â„\n  constructor\n  Â· intro H\n    have A : âˆ€ w âˆˆ K, re âŸªu - v, wâŸ« = 0 := (norm_eq_iInf_iff_real_inner_eq_zero K' hv).1 H\n    intro w hw\n    apply RCLike.ext\n    Â· simp [A w hw]\n    Â· symm\n      calc\n        im (0 : ğ•œ) = 0 := im.map_zero\n        _ = re âŸªu - v, (-I : ğ•œ) â€¢ wâŸ« := (A _ (K.smul_mem (-I) hw)).symm\n        _ = re (-I * âŸªu - v, wâŸ«) := by rw [inner_smul_right]\n        _ = im âŸªu - v, wâŸ« := by simp\n  Â· intro H\n    have : âˆ€ w âˆˆ K', âŸªu - v, wâŸ«_â„ = 0 := by\n      intro w hw\n      rw [real_inner_eq_re_inner, H w hw]\n      exact zero_re'\n    exact (norm_eq_iInf_iff_real_inner_eq_zero K' hv).2 this\n\n"}
{"name":"HasOrthogonalProjection.exists_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nself : HasOrthogonalProjection K\nv : E\nâŠ¢ Exists fun w => And (Membership.mem K w) (Membership.mem K.orthogonal (HSub.hSub v w))","decl":"/-- A subspace `K : Submodule ğ•œ E` has an orthogonal projection if every vector `v : E` admits an\northogonal projection to `K`. -/\nclass HasOrthogonalProjection (K : Submodule ğ•œ E) : Prop where\n  exists_orthogonal (v : E) : âˆƒ w âˆˆ K, v - w âˆˆ Ká—®\n\n"}
{"name":"HasOrthogonalProjection.ofCompleteSpace","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : CompleteSpace (Subtype fun x => Membership.mem K x)\nâŠ¢ HasOrthogonalProjection K","decl":"instance (priority := 100) HasOrthogonalProjection.ofCompleteSpace [CompleteSpace K] :\n    HasOrthogonalProjection K where\n  exists_orthogonal v := by\n    rcases exists_norm_eq_iInf_of_complete_subspace K (completeSpace_coe_iff_isComplete.mp â€¹_â€º) v\n      with âŸ¨w, hwK, hwâŸ©\n    refine âŸ¨w, hwK, (K.mem_orthogonal' _).2 ?_âŸ©\n    rwa [â† norm_eq_iInf_iff_inner_eq_zero K hwK]\n\n"}
{"name":"instHasOrthogonalProjectionOrthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nâŠ¢ HasOrthogonalProjection K.orthogonal","decl":"instance [HasOrthogonalProjection K] : HasOrthogonalProjection Ká—® where\n  exists_orthogonal v := by\n    rcases HasOrthogonalProjection.exists_orthogonal (K := K) v with âŸ¨w, hwK, hwâŸ©\n    refine âŸ¨_, hw, ?_âŸ©\n    rw [sub_sub_cancel]\n    exact K.le_orthogonal_orthogonal hwK\n\n"}
{"name":"HasOrthogonalProjection.map_linearIsometryEquiv","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœÂ² : HasOrthogonalProjection K\nE' : Type u_4\ninstâœÂ¹ : NormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nf : LinearIsometryEquiv (RingHom.id ğ•œ) E E'\nâŠ¢ HasOrthogonalProjection (Submodule.map (â†‘f.toLinearEquiv) K)","decl":"instance HasOrthogonalProjection.map_linearIsometryEquiv [HasOrthogonalProjection K]\n    {E' : Type*} [NormedAddCommGroup E'] [InnerProductSpace ğ•œ E'] (f : E â‰ƒâ‚—áµ¢[ğ•œ] E') :\n    HasOrthogonalProjection (K.map (f.toLinearEquiv : E â†’â‚—[ğ•œ] E')) where\n  exists_orthogonal v := by\n    rcases HasOrthogonalProjection.exists_orthogonal (K := K) (f.symm v) with âŸ¨w, hwK, hwâŸ©\n    refine âŸ¨f w, Submodule.mem_map_of_mem hwK, Set.forall_mem_image.2 fun u hu â†¦ ?_âŸ©\n    erw [â† f.symm.inner_map_map, f.symm_apply_apply, map_sub, f.symm_apply_apply, hw u hu]\n\n"}
{"name":"HasOrthogonalProjection.map_linearIsometryEquiv'","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœÂ² : HasOrthogonalProjection K\nE' : Type u_4\ninstâœÂ¹ : NormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nf : LinearIsometryEquiv (RingHom.id ğ•œ) E E'\nâŠ¢ HasOrthogonalProjection (Submodule.map f.toLinearIsometry K)","decl":"instance HasOrthogonalProjection.map_linearIsometryEquiv' [HasOrthogonalProjection K]\n    {E' : Type*} [NormedAddCommGroup E'] [InnerProductSpace ğ•œ E'] (f : E â‰ƒâ‚—áµ¢[ğ•œ] E') :\n    HasOrthogonalProjection (K.map f.toLinearIsometry) :=\n  HasOrthogonalProjection.map_linearIsometryEquiv K f\n\n"}
{"name":"instHasOrthogonalProjectionTopSubmodule","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nâŠ¢ HasOrthogonalProjection Top.top","decl":"instance : HasOrthogonalProjection (âŠ¤ : Submodule ğ•œ E) := âŸ¨fun v â†¦ âŸ¨v, trivial, by simpâŸ©âŸ©\n\n"}
{"name":"orthogonalProjectionFn_mem","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nv : E\nâŠ¢ Membership.mem K (orthogonalProjectionFn K v)","decl":"/-- The unbundled orthogonal projection is in the given subspace.\nThis lemma is only intended for use in setting up the bundled version\nand should not be used once that is defined. -/\ntheorem orthogonalProjectionFn_mem (v : E) : orthogonalProjectionFn K v âˆˆ K :=\n  (HasOrthogonalProjection.exists_orthogonal (K := K) v).choose_spec.left\n\n"}
{"name":"orthogonalProjectionFn_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nv w : E\naâœ : Membership.mem K w\nâŠ¢ Eq (Inner.inner (HSub.hSub v (orthogonalProjectionFn K v)) w) 0","decl":"/-- The characterization of the unbundled orthogonal projection.  This\nlemma is only intended for use in setting up the bundled version\nand should not be used once that is defined. -/\ntheorem orthogonalProjectionFn_inner_eq_zero (v : E) :\n    âˆ€ w âˆˆ K, âŸªv - orthogonalProjectionFn K v, wâŸ« = 0 :=\n  (K.mem_orthogonal' _).1 (HasOrthogonalProjection.exists_orthogonal (K := K) v).choose_spec.right\n\n"}
{"name":"eq_orthogonalProjectionFn_of_mem_of_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nu v : E\nhvm : Membership.mem K v\nhvo : âˆ€ (w : E), Membership.mem K w â†’ Eq (Inner.inner (HSub.hSub u v) w) 0\nâŠ¢ Eq (orthogonalProjectionFn K u) v","decl":"/-- The unbundled orthogonal projection is the unique point in `K`\nwith the orthogonality property.  This lemma is only intended for use\nin setting up the bundled version and should not be used once that is\ndefined. -/\ntheorem eq_orthogonalProjectionFn_of_mem_of_inner_eq_zero {u v : E} (hvm : v âˆˆ K)\n    (hvo : âˆ€ w âˆˆ K, âŸªu - v, wâŸ« = 0) : orthogonalProjectionFn K u = v := by\n  rw [â† sub_eq_zero, â† @inner_self_eq_zero ğ•œ]\n  have hvs : orthogonalProjectionFn K u - v âˆˆ K :=\n    Submodule.sub_mem K (orthogonalProjectionFn_mem u) hvm\n  have huo : âŸªu - orthogonalProjectionFn K u, orthogonalProjectionFn K u - vâŸ« = 0 :=\n    orthogonalProjectionFn_inner_eq_zero u _ hvs\n  have huv : âŸªu - v, orthogonalProjectionFn K u - vâŸ« = 0 := hvo _ hvs\n  have houv : âŸªu - v - (u - orthogonalProjectionFn K u), orthogonalProjectionFn K u - vâŸ« = 0 := by\n    rw [inner_sub_left, huo, huv, sub_zero]\n  rwa [sub_sub_sub_cancel_left] at houv\n\n"}
{"name":"orthogonalProjectionFn_norm_sq","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nv : E\nâŠ¢ Eq (HMul.hMul (Norm.norm v) (Norm.norm v)) (HAdd.hAdd (HMul.hMul (Norm.norm (HSub.hSub v (orthogonalProjectionFn K v))) (Norm.norm (HSub.hSub v (orthogonalProjectionFn K v)))) (HMul.hMul (Norm.norm (orthogonalProjectionFn K v)) (Norm.norm (orthogonalProjectionFn K v))))","decl":"theorem orthogonalProjectionFn_norm_sq (v : E) :\n    â€–vâ€– * â€–vâ€– =\n      â€–v - orthogonalProjectionFn K vâ€– * â€–v - orthogonalProjectionFn K vâ€– +\n        â€–orthogonalProjectionFn K vâ€– * â€–orthogonalProjectionFn K vâ€– := by\n  set p := orthogonalProjectionFn K v\n  have h' : âŸªv - p, pâŸ« = 0 :=\n    orthogonalProjectionFn_inner_eq_zero _ _ (orthogonalProjectionFn_mem v)\n  convert norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero (v - p) p h' using 2 <;> simp\n\n"}
{"name":"orthogonalProjectionFn_eq","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nv : E\nâŠ¢ Eq (orthogonalProjectionFn K v) â†‘((orthogonalProjection K) v)","decl":"@[simp]\ntheorem orthogonalProjectionFn_eq (v : E) :\n    orthogonalProjectionFn K v = (orthogonalProjection K v : E) :=\n  rfl\n\n"}
{"name":"orthogonalProjection_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nv w : E\naâœ : Membership.mem K w\nâŠ¢ Eq (Inner.inner (HSub.hSub v â†‘((orthogonalProjection K) v)) w) 0","decl":"/-- The characterization of the orthogonal projection. -/\n@[simp]\ntheorem orthogonalProjection_inner_eq_zero (v : E) :\n    âˆ€ w âˆˆ K, âŸªv - orthogonalProjection K v, wâŸ« = 0 :=\n  orthogonalProjectionFn_inner_eq_zero v\n\n"}
{"name":"sub_orthogonalProjection_mem_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nv : E\nâŠ¢ Membership.mem K.orthogonal (HSub.hSub v â†‘((orthogonalProjection K) v))","decl":"/-- The difference of `v` from its orthogonal projection onto `K` is in `Ká—®`. -/\n@[simp]\ntheorem sub_orthogonalProjection_mem_orthogonal (v : E) : v - orthogonalProjection K v âˆˆ Ká—® := by\n  intro w hw\n  rw [inner_eq_zero_symm]\n  exact orthogonalProjection_inner_eq_zero _ _ hw\n\n"}
{"name":"eq_orthogonalProjection_of_mem_of_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nu v : E\nhvm : Membership.mem K v\nhvo : âˆ€ (w : E), Membership.mem K w â†’ Eq (Inner.inner (HSub.hSub u v) w) 0\nâŠ¢ Eq (â†‘((orthogonalProjection K) u)) v","decl":"/-- The orthogonal projection is the unique point in `K` with the\northogonality property. -/\ntheorem eq_orthogonalProjection_of_mem_of_inner_eq_zero {u v : E} (hvm : v âˆˆ K)\n    (hvo : âˆ€ w âˆˆ K, âŸªu - v, wâŸ« = 0) : (orthogonalProjection K u : E) = v :=\n  eq_orthogonalProjectionFn_of_mem_of_inner_eq_zero hvm hvo\n\n"}
{"name":"eq_orthogonalProjection_of_mem_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nu v : E\nhv : Membership.mem K v\nhvo : Membership.mem K.orthogonal (HSub.hSub u v)\nâŠ¢ Eq (â†‘((orthogonalProjection K) u)) v","decl":"/-- A point in `K` with the orthogonality property (here characterized in terms of `Ká—®`) must be the\northogonal projection. -/\ntheorem eq_orthogonalProjection_of_mem_orthogonal {u v : E} (hv : v âˆˆ K)\n    (hvo : u - v âˆˆ Ká—®) : (orthogonalProjection K u : E) = v :=\n  eq_orthogonalProjectionFn_of_mem_of_inner_eq_zero hv <| (Submodule.mem_orthogonal' _ _).1 hvo\n\n"}
{"name":"eq_orthogonalProjection_of_mem_orthogonal'","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nu v z : E\nhv : Membership.mem K v\nhz : Membership.mem K.orthogonal z\nhu : Eq u (HAdd.hAdd v z)\nâŠ¢ Eq (â†‘((orthogonalProjection K) u)) v","decl":"/-- A point in `K` with the orthogonality property (here characterized in terms of `Ká—®`) must be the\northogonal projection. -/\ntheorem eq_orthogonalProjection_of_mem_orthogonal' {u v z : E}\n    (hv : v âˆˆ K) (hz : z âˆˆ Ká—®) (hu : u = v + z) : (orthogonalProjection K u : E) = v :=\n  eq_orthogonalProjection_of_mem_orthogonal hv (by simpa [hu] )\n\n"}
{"name":"orthogonalProjection_orthogonal_val","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nu : E\nâŠ¢ Eq (â†‘((orthogonalProjection K.orthogonal) u)) (HSub.hSub u â†‘((orthogonalProjection K) u))","decl":"@[simp]\ntheorem orthogonalProjection_orthogonal_val (u : E) :\n    (orthogonalProjection Ká—® u : E) = u - orthogonalProjection K u :=\n  eq_orthogonalProjection_of_mem_orthogonal' (sub_orthogonalProjection_mem_orthogonal _)\n    (K.le_orthogonal_orthogonal (orthogonalProjection K u).2) <| by simp\n\n"}
{"name":"orthogonalProjection_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nu : E\nâŠ¢ Eq ((orthogonalProjection K.orthogonal) u) âŸ¨HSub.hSub u â†‘((orthogonalProjection K) u), â‹¯âŸ©","decl":"theorem orthogonalProjection_orthogonal (u : E) :\n    orthogonalProjection Ká—® u =\n      âŸ¨u - orthogonalProjection K u, sub_orthogonalProjection_mem_orthogonal _âŸ© :=\n  Subtype.eq <| orthogonalProjection_orthogonal_val _\n\n"}
{"name":"orthogonalProjection_minimal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nU : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection U\ny : E\nâŠ¢ Eq (Norm.norm (HSub.hSub y â†‘((orthogonalProjection U) y))) (iInf fun x => Norm.norm (HSub.hSub y â†‘x))","decl":"/-- The orthogonal projection of `y` on `U` minimizes the distance `â€–y - xâ€–` for `x âˆˆ U`. -/\ntheorem orthogonalProjection_minimal {U : Submodule ğ•œ E} [HasOrthogonalProjection U] (y : E) :\n    â€–y - orthogonalProjection U yâ€– = â¨… x : U, â€–y - xâ€– := by\n  rw [norm_eq_iInf_iff_inner_eq_zero _ (Submodule.coe_mem _)]\n  exact orthogonalProjection_inner_eq_zero _\n\n"}
{"name":"eq_orthogonalProjection_of_eq_submodule","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœÂ¹ : HasOrthogonalProjection K\nK' : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K'\nh : Eq K K'\nu : E\nâŠ¢ Eq â†‘((orthogonalProjection K) u) â†‘((orthogonalProjection K') u)","decl":"/-- The orthogonal projections onto equal subspaces are coerced back to the same point in `E`. -/\ntheorem eq_orthogonalProjection_of_eq_submodule {K' : Submodule ğ•œ E} [HasOrthogonalProjection K']\n    (h : K = K') (u : E) : (orthogonalProjection K u : E) = (orthogonalProjection K' u : E) := by\n  subst h; rfl\n\n"}
{"name":"orthogonalProjection_mem_subspace_eq_self","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nv : Subtype fun x => Membership.mem K x\nâŠ¢ Eq ((orthogonalProjection K) â†‘v) v","decl":"/-- The orthogonal projection sends elements of `K` to themselves. -/\n@[simp]\ntheorem orthogonalProjection_mem_subspace_eq_self (v : K) : orthogonalProjection K v = v := by\n  ext\n  apply eq_orthogonalProjection_of_mem_of_inner_eq_zero <;> simp\n\n"}
{"name":"orthogonalProjection_eq_self_iff","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nv : E\nâŠ¢ Iff (Eq (â†‘((orthogonalProjection K) v)) v) (Membership.mem K v)","decl":"/-- A point equals its orthogonal projection if and only if it lies in the subspace. -/\ntheorem orthogonalProjection_eq_self_iff {v : E} : (orthogonalProjection K v : E) = v â†” v âˆˆ K := by\n  refine âŸ¨fun h => ?_, fun h => eq_orthogonalProjection_of_mem_of_inner_eq_zero h ?_âŸ©\n  Â· rw [â† h]\n    simp\n  Â· simp\n\n"}
{"name":"orthogonalProjection_eq_zero_iff","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nv : E\nâŠ¢ Iff (Eq ((orthogonalProjection K) v) 0) (Membership.mem K.orthogonal v)","decl":"@[simp]\ntheorem orthogonalProjection_eq_zero_iff {v : E} : orthogonalProjection K v = 0 â†” v âˆˆ Ká—® := by\n  refine âŸ¨fun h â†¦ ?_, fun h â†¦ Subtype.eq <| eq_orthogonalProjection_of_mem_orthogonal\n    (zero_mem _) ?_âŸ©\n  Â· simpa [h] using sub_orthogonalProjection_mem_orthogonal (K := K) v\n  Â· simpa\n\n"}
{"name":"ker_orthogonalProjection","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nâŠ¢ Eq (LinearMap.ker (orthogonalProjection K)) K.orthogonal","decl":"@[simp]\ntheorem ker_orthogonalProjection : LinearMap.ker (orthogonalProjection K) = Ká—® := by\n  ext; exact orthogonalProjection_eq_zero_iff\n\n"}
{"name":"LinearIsometry.map_orthogonalProjection","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : RCLike ğ•œ\nE : Type u_4\nE' : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup E'\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ E'\nf : LinearIsometry (RingHom.id ğ•œ) E E'\np : Submodule ğ•œ E\ninstâœÂ¹ : HasOrthogonalProjection p\ninstâœ : HasOrthogonalProjection (Submodule.map f.toLinearMap p)\nx : E\nâŠ¢ Eq (f â†‘((orthogonalProjection p) x)) â†‘((orthogonalProjection (Submodule.map f.toLinearMap p)) (f x))","decl":"theorem LinearIsometry.map_orthogonalProjection {E E' : Type*} [NormedAddCommGroup E]\n    [NormedAddCommGroup E'] [InnerProductSpace ğ•œ E] [InnerProductSpace ğ•œ E'] (f : E â†’â‚—áµ¢[ğ•œ] E')\n    (p : Submodule ğ•œ E) [HasOrthogonalProjection p] [HasOrthogonalProjection (p.map f.toLinearMap)]\n    (x : E) : f (orthogonalProjection p x) = orthogonalProjection (p.map f.toLinearMap) (f x) := by\n  refine (eq_orthogonalProjection_of_mem_of_inner_eq_zero ?_ fun y hy => ?_).symm\n  Â· refine Submodule.apply_coe_mem_map _ _\n  rcases hy with âŸ¨x', hx', rfl : f x' = yâŸ©\n  rw [â† f.map_sub, f.inner_map_map, orthogonalProjection_inner_eq_zero x x' hx']\n\n"}
{"name":"LinearIsometry.map_orthogonalProjection'","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : RCLike ğ•œ\nE : Type u_4\nE' : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup E'\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ E'\nf : LinearIsometry (RingHom.id ğ•œ) E E'\np : Submodule ğ•œ E\ninstâœÂ¹ : HasOrthogonalProjection p\ninstâœ : HasOrthogonalProjection (Submodule.map f p)\nx : E\nâŠ¢ Eq (f â†‘((orthogonalProjection p) x)) â†‘((orthogonalProjection (Submodule.map f p)) (f x))","decl":"theorem LinearIsometry.map_orthogonalProjection' {E E' : Type*} [NormedAddCommGroup E]\n    [NormedAddCommGroup E'] [InnerProductSpace ğ•œ E] [InnerProductSpace ğ•œ E'] (f : E â†’â‚—áµ¢[ğ•œ] E')\n    (p : Submodule ğ•œ E) [HasOrthogonalProjection p] [HasOrthogonalProjection (p.map f)] (x : E) :\n    f (orthogonalProjection p x) = orthogonalProjection (p.map f) (f x) :=\n  have : HasOrthogonalProjection (p.map f.toLinearMap) := â€¹_â€º\n  f.map_orthogonalProjection p x\n\n"}
{"name":"orthogonalProjection_map_apply","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : RCLike ğ•œ\nE : Type u_4\nE' : Type u_5\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : InnerProductSpace ğ•œ E'\nf : LinearIsometryEquiv (RingHom.id ğ•œ) E E'\np : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection p\nx : E'\nâŠ¢ Eq (â†‘((orthogonalProjection (Submodule.map (â†‘f.toLinearEquiv) p)) x)) (f â†‘((orthogonalProjection p) (f.symm x)))","decl":"/-- Orthogonal projection onto the `Submodule.map` of a subspace. -/\ntheorem orthogonalProjection_map_apply {E E' : Type*} [NormedAddCommGroup E]\n    [NormedAddCommGroup E'] [InnerProductSpace ğ•œ E] [InnerProductSpace ğ•œ E'] (f : E â‰ƒâ‚—áµ¢[ğ•œ] E')\n    (p : Submodule ğ•œ E) [HasOrthogonalProjection p] (x : E') :\n    (orthogonalProjection (p.map (f.toLinearEquiv : E â†’â‚—[ğ•œ] E')) x : E') =\n      f (orthogonalProjection p (f.symm x)) := by\n  simpa only [f.coe_toLinearIsometry, f.apply_symm_apply] using\n    (f.toLinearIsometry.map_orthogonalProjection' p (f.symm x)).symm\n\n"}
{"name":"orthogonalProjection_bot","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nâŠ¢ Eq (orthogonalProjection Bot.bot) 0","decl":"/-- The orthogonal projection onto the trivial submodule is the zero map. -/\n@[simp]\ntheorem orthogonalProjection_bot : orthogonalProjection (âŠ¥ : Submodule ğ•œ E) = 0 := by ext\n\n"}
{"name":"orthogonalProjection_norm_le","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nâŠ¢ LE.le (Norm.norm (orthogonalProjection K)) 1","decl":"/-- The orthogonal projection has norm `â‰¤ 1`. -/\ntheorem orthogonalProjection_norm_le : â€–orthogonalProjection Kâ€– â‰¤ 1 :=\n  LinearMap.mkContinuous_norm_le _ (by norm_num) _\n\n"}
{"name":"smul_orthogonalProjection_singleton","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nv w : E\nâŠ¢ Eq (HSMul.hSMul â†‘(HPow.hPow (Norm.norm v) 2) â†‘((orthogonalProjection (Submodule.span ğ•œ (Singleton.singleton v))) w)) (HSMul.hSMul (Inner.inner v w) v)","decl":"theorem smul_orthogonalProjection_singleton {v : E} (w : E) :\n    ((â€–vâ€– ^ 2 : â„) : ğ•œ) â€¢ (orthogonalProjection (ğ•œ âˆ™ v) w : E) = âŸªv, wâŸ« â€¢ v := by\n  suffices ((orthogonalProjection (ğ•œ âˆ™ v) (((â€–vâ€– : ğ•œ) ^ 2) â€¢ w)) : E) = âŸªv, wâŸ« â€¢ v by\n    simpa using this\n  apply eq_orthogonalProjection_of_mem_of_inner_eq_zero\n  Â· rw [Submodule.mem_span_singleton]\n    use âŸªv, wâŸ«\n  Â· rw [â† Submodule.mem_orthogonal', Submodule.mem_orthogonal_singleton_iff_inner_left]\n    simp [inner_sub_left, inner_smul_left, inner_self_eq_norm_sq_to_K, mul_comm]\n\n"}
{"name":"orthogonalProjection_singleton","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nv w : E\nâŠ¢ Eq (â†‘((orthogonalProjection (Submodule.span ğ•œ (Singleton.singleton v))) w)) (HSMul.hSMul (HDiv.hDiv (Inner.inner v w) â†‘(HPow.hPow (Norm.norm v) 2)) v)","decl":"/-- Formula for orthogonal projection onto a single vector. -/\ntheorem orthogonalProjection_singleton {v : E} (w : E) :\n    (orthogonalProjection (ğ•œ âˆ™ v) w : E) = (âŸªv, wâŸ« / ((â€–vâ€– ^ 2 : â„) : ğ•œ)) â€¢ v := by\n  by_cases hv : v = 0\n  Â· rw [hv, eq_orthogonalProjection_of_eq_submodule (Submodule.span_zero_singleton ğ•œ)]\n    simp\n  have hv' : â€–vâ€– â‰  0 := ne_of_gt (norm_pos_iff.mpr hv)\n  have key :\n    (((â€–vâ€– ^ 2 : â„) : ğ•œ)â»Â¹ * ((â€–vâ€– ^ 2 : â„) : ğ•œ)) â€¢ ((orthogonalProjection (ğ•œ âˆ™ v) w) : E) =\n      (((â€–vâ€– ^ 2 : â„) : ğ•œ)â»Â¹ * âŸªv, wâŸ«) â€¢ v := by\n    simp [mul_smul, smul_orthogonalProjection_singleton ğ•œ w, -map_pow]\n  convert key using 1 <;> field_simp [hv']\n\n"}
{"name":"orthogonalProjection_unit_singleton","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nv : E\nhv : Eq (Norm.norm v) 1\nw : E\nâŠ¢ Eq (â†‘((orthogonalProjection (Submodule.span ğ•œ (Singleton.singleton v))) w)) (HSMul.hSMul (Inner.inner v w) v)","decl":"/-- Formula for orthogonal projection onto a single unit vector. -/\ntheorem orthogonalProjection_unit_singleton {v : E} (hv : â€–vâ€– = 1) (w : E) :\n    (orthogonalProjection (ğ•œ âˆ™ v) w : E) = âŸªv, wâŸ« â€¢ v := by\n  rw [â† smul_orthogonalProjection_singleton ğ•œ w]\n  simp [hv]\n\n"}
{"name":"reflection_apply","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\np : E\nâŠ¢ Eq ((reflection K) p) (HSub.hSub (HSMul.hSMul 2 â†‘((orthogonalProjection K) p)) p)","decl":"/-- The result of reflecting. -/\ntheorem reflection_apply (p : E) : reflection K p = 2 â€¢ (orthogonalProjection K p : E) - p :=\n  rfl\n\n"}
{"name":"reflection_symm","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nâŠ¢ Eq (reflection K).symm (reflection K)","decl":"/-- Reflection is its own inverse. -/\n@[simp]\ntheorem reflection_symm : (reflection K).symm = reflection K :=\n  rfl\n\n"}
{"name":"reflection_inv","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nâŠ¢ Eq (Inv.inv (reflection K)) (reflection K)","decl":"/-- Reflection is its own inverse. -/\n@[simp]\ntheorem reflection_inv : (reflection K)â»Â¹ = reflection K :=\n  rfl\n\n"}
{"name":"reflection_reflection","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\np : E\nâŠ¢ Eq ((reflection K) ((reflection K) p)) p","decl":"/-- Reflecting twice in the same subspace. -/\n@[simp]\ntheorem reflection_reflection (p : E) : reflection K (reflection K p) = p :=\n  (reflection K).left_inv p\n\n"}
{"name":"reflection_involutive","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nâŠ¢ Function.Involutive â‡‘(reflection K)","decl":"/-- Reflection is involutive. -/\ntheorem reflection_involutive : Function.Involutive (reflection K) :=\n  reflection_reflection K\n\n"}
{"name":"reflection_trans_reflection","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nâŠ¢ Eq ((reflection K).trans (reflection K)) (LinearIsometryEquiv.refl ğ•œ E)","decl":"/-- Reflection is involutive. -/\n@[simp]\ntheorem reflection_trans_reflection :\n    (reflection K).trans (reflection K) = LinearIsometryEquiv.refl ğ•œ E :=\n  LinearIsometryEquiv.ext <| reflection_involutive K\n\n"}
{"name":"reflection_mul_reflection","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nâŠ¢ Eq (HMul.hMul (reflection K) (reflection K)) 1","decl":"/-- Reflection is involutive. -/\n@[simp]\ntheorem reflection_mul_reflection : reflection K * reflection K = 1 :=\n  reflection_trans_reflection _\n\n"}
{"name":"reflection_orthogonal_apply","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nv : E\nâŠ¢ Eq ((reflection K.orthogonal) v) (Neg.neg ((reflection K) v))","decl":"theorem reflection_orthogonal_apply (v : E) : reflection Ká—® v = -reflection K v := by\n  simp [reflection_apply]; abel\n\n"}
{"name":"reflection_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nâŠ¢ Eq (reflection K.orthogonal) ((reflection K).trans (LinearIsometryEquiv.neg ğ•œ))","decl":"theorem reflection_orthogonal : reflection Ká—® = .trans (reflection K) (.neg _) := by\n  ext; apply reflection_orthogonal_apply\n\n"}
{"name":"reflection_singleton_apply","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nu v : E\nâŠ¢ Eq ((reflection (Submodule.span ğ•œ (Singleton.singleton u))) v) (HSub.hSub (HSMul.hSMul 2 (HSMul.hSMul (HDiv.hDiv (Inner.inner u v) (HPow.hPow (â†‘(Norm.norm u)) 2)) u)) v)","decl":"theorem reflection_singleton_apply (u v : E) :\n    reflection (ğ•œ âˆ™ u) v = 2 â€¢ (âŸªu, vâŸ« / ((â€–uâ€– : ğ•œ) ^ 2)) â€¢ u - v := by\n  rw [reflection_apply, orthogonalProjection_singleton, ofReal_pow]\n\n"}
{"name":"reflection_eq_self_iff","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nx : E\nâŠ¢ Iff (Eq ((reflection K) x) x) (Membership.mem K x)","decl":"/-- A point is its own reflection if and only if it is in the subspace. -/\ntheorem reflection_eq_self_iff (x : E) : reflection K x = x â†” x âˆˆ K := by\n  rw [â† orthogonalProjection_eq_self_iff, reflection_apply, sub_eq_iff_eq_add', â† two_smul ğ•œ,\n    two_smul â„•, â† two_smul ğ•œ]\n  refine (smul_right_injective E ?_).eq_iff\n  exact two_ne_zero\n\n"}
{"name":"reflection_mem_subspace_eq_self","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nx : E\nhx : Membership.mem K x\nâŠ¢ Eq ((reflection K) x) x","decl":"theorem reflection_mem_subspace_eq_self {x : E} (hx : x âˆˆ K) : reflection K x = x :=\n  (reflection_eq_self_iff x).mpr hx\n\n"}
{"name":"reflection_map_apply","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : RCLike ğ•œ\nE : Type u_4\nE' : Type u_5\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : InnerProductSpace ğ•œ E'\nf : LinearIsometryEquiv (RingHom.id ğ•œ) E E'\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nx : E'\nâŠ¢ Eq ((reflection (Submodule.map (â†‘f.toLinearEquiv) K)) x) (f ((reflection K) (f.symm x)))","decl":"/-- Reflection in the `Submodule.map` of a subspace. -/\ntheorem reflection_map_apply {E E' : Type*} [NormedAddCommGroup E] [NormedAddCommGroup E']\n    [InnerProductSpace ğ•œ E] [InnerProductSpace ğ•œ E'] (f : E â‰ƒâ‚—áµ¢[ğ•œ] E') (K : Submodule ğ•œ E)\n    [HasOrthogonalProjection K] (x : E') :\n    reflection (K.map (f.toLinearEquiv : E â†’â‚—[ğ•œ] E')) x = f (reflection K (f.symm x)) := by\n  simp [two_smul, reflection_apply, orthogonalProjection_map_apply f K x]\n\n"}
{"name":"reflection_map","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : RCLike ğ•œ\nE : Type u_4\nE' : Type u_5\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : InnerProductSpace ğ•œ E'\nf : LinearIsometryEquiv (RingHom.id ğ•œ) E E'\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nâŠ¢ Eq (reflection (Submodule.map (â†‘f.toLinearEquiv) K)) (f.symm.trans ((reflection K).trans f))","decl":"/-- Reflection in the `Submodule.map` of a subspace. -/\ntheorem reflection_map {E E' : Type*} [NormedAddCommGroup E] [NormedAddCommGroup E']\n    [InnerProductSpace ğ•œ E] [InnerProductSpace ğ•œ E'] (f : E â‰ƒâ‚—áµ¢[ğ•œ] E') (K : Submodule ğ•œ E)\n    [HasOrthogonalProjection K] :\n    reflection (K.map (f.toLinearEquiv : E â†’â‚—[ğ•œ] E')) = f.symm.trans ((reflection K).trans f) :=\n  LinearIsometryEquiv.ext <| reflection_map_apply f K\n\n"}
{"name":"reflection_bot","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nâŠ¢ Eq (reflection Bot.bot) (LinearIsometryEquiv.neg ğ•œ)","decl":"/-- Reflection through the trivial subspace {0} is just negation. -/\n@[simp]\ntheorem reflection_bot : reflection (âŠ¥ : Submodule ğ•œ E) = LinearIsometryEquiv.neg ğ•œ := by\n  ext; simp [reflection_apply]\n\n"}
{"name":"Submodule.sup_orthogonal_inf_of_completeSpace","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nKâ‚ Kâ‚‚ : Submodule ğ•œ E\nh : LE.le Kâ‚ Kâ‚‚\ninstâœ : HasOrthogonalProjection Kâ‚\nâŠ¢ Eq (Max.max Kâ‚ (Min.min Kâ‚.orthogonal Kâ‚‚)) Kâ‚‚","decl":"/-- If `Kâ‚` is complete and contained in `Kâ‚‚`, `Kâ‚` and `Kâ‚á—® âŠ“ Kâ‚‚` span `Kâ‚‚`. -/\ntheorem Submodule.sup_orthogonal_inf_of_completeSpace {Kâ‚ Kâ‚‚ : Submodule ğ•œ E} (h : Kâ‚ â‰¤ Kâ‚‚)\n    [HasOrthogonalProjection Kâ‚] : Kâ‚ âŠ” Kâ‚á—® âŠ“ Kâ‚‚ = Kâ‚‚ := by\n  ext x\n  rw [Submodule.mem_sup]\n  let v : Kâ‚ := orthogonalProjection Kâ‚ x\n  have hvm : x - v âˆˆ Kâ‚á—® := sub_orthogonalProjection_mem_orthogonal x\n  constructor\n  Â· rintro âŸ¨y, hy, z, hz, rflâŸ©\n    exact Kâ‚‚.add_mem (h hy) hz.2\n  Â· exact fun hx => âŸ¨v, v.prop, x - v, âŸ¨hvm, Kâ‚‚.sub_mem hx (h v.prop)âŸ©, add_sub_cancel _ _âŸ©\n\n"}
{"name":"Submodule.sup_orthogonal_of_completeSpace","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nâŠ¢ Eq (Max.max K K.orthogonal) Top.top","decl":"/-- If `K` is complete, `K` and `Ká—®` span the whole space. -/\ntheorem Submodule.sup_orthogonal_of_completeSpace [HasOrthogonalProjection K] : K âŠ” Ká—® = âŠ¤ := by\n  convert Submodule.sup_orthogonal_inf_of_completeSpace (le_top : K â‰¤ âŠ¤) using 2\n  simp\n\n"}
{"name":"Submodule.exists_add_mem_mem_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nv : E\nâŠ¢ Exists fun y => And (Membership.mem K y) (Exists fun z => And (Membership.mem K.orthogonal z) (Eq v (HAdd.hAdd y z)))","decl":"/-- If `K` is complete, any `v` in `E` can be expressed as a sum of elements of `K` and `Ká—®`. -/\ntheorem Submodule.exists_add_mem_mem_orthogonal [HasOrthogonalProjection K] (v : E) :\n    âˆƒ y âˆˆ K, âˆƒ z âˆˆ Ká—®, v = y + z :=\n  âŸ¨orthogonalProjection K v, Subtype.coe_prop _, v - orthogonalProjection K v,\n    sub_orthogonalProjection_mem_orthogonal _, by simpâŸ©\n\n"}
{"name":"Submodule.orthogonal_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nâŠ¢ Eq K.orthogonal.orthogonal K","decl":"/-- If `K` admits an orthogonal projection, then the orthogonal complement of its orthogonal\ncomplement is itself. -/\n@[simp]\ntheorem Submodule.orthogonal_orthogonal [HasOrthogonalProjection K] : Ká—®á—® = K := by\n  ext v\n  constructor\n  Â· obtain âŸ¨y, hy, z, hz, rflâŸ© := K.exists_add_mem_mem_orthogonal v\n    intro hv\n    have hz' : z = 0 := by\n      have hyz : âŸªz, yâŸ« = 0 := by simp [hz y hy, inner_eq_zero_symm]\n      simpa [inner_add_right, hyz] using hv z hz\n    simp [hy, hz']\n  Â· intro hv w hw\n    rw [inner_eq_zero_symm]\n    exact hw v hv\n\n"}
{"name":"Submodule.orthogonal_orthogonal_eq_closure","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : CompleteSpace E\nâŠ¢ Eq K.orthogonal.orthogonal K.topologicalClosure","decl":"/-- In a Hilbert space, the orthogonal complement of the orthogonal complement of a subspace `K`\nis the topological closure of `K`.\n\nNote that the completeness assumption is necessary. Let `E` be the space `â„• â†’â‚€ â„` with inner space\nstructure inherited from `PiLp 2 (fun _ : â„• â†¦ â„)`. Let `K` be the subspace of sequences with the sum\nof all elements equal to zero. Then `Ká—® = âŠ¥`, `Ká—®á—® = âŠ¤`. -/\ntheorem Submodule.orthogonal_orthogonal_eq_closure [CompleteSpace E] :\n    Ká—®á—® = K.topologicalClosure := by\n  refine le_antisymm ?_ ?_\n  Â· convert Submodule.orthogonal_orthogonal_monotone K.le_topologicalClosure using 1\n    rw [K.topologicalClosure.orthogonal_orthogonal]\n  Â· exact K.topologicalClosure_minimal K.le_orthogonal_orthogonal Ká—®.isClosed_orthogonal\n\n"}
{"name":"Submodule.isCompl_orthogonal_of_completeSpace","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nâŠ¢ IsCompl K K.orthogonal","decl":"/-- If `K` admits an orthogonal projection, `K` and `Ká—®` are complements of each other. -/\ntheorem Submodule.isCompl_orthogonal_of_completeSpace [HasOrthogonalProjection K] : IsCompl K Ká—® :=\n  âŸ¨K.orthogonal_disjoint, codisjoint_iff.2 Submodule.sup_orthogonal_of_completeSpaceâŸ©\n\n"}
{"name":"orthogonalComplement_eq_orthogonalComplement","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nK L : Submodule ğ•œ E\ninstâœÂ¹ : HasOrthogonalProjection K\ninstâœ : HasOrthogonalProjection L\nâŠ¢ Iff (Eq K.orthogonal L.orthogonal) (Eq K L)","decl":"@[simp]\ntheorem orthogonalComplement_eq_orthogonalComplement {L : Submodule ğ•œ E} [HasOrthogonalProjection K]\n    [HasOrthogonalProjection L] : Ká—® = Lá—® â†” K = L :=\n  âŸ¨fun h â†¦ by simpa using congr(Submodule.orthogonal $(h)),\n    fun h â†¦ congr(Submodule.orthogonal $(h))âŸ©\n\n"}
{"name":"Submodule.orthogonal_eq_bot_iff","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nâŠ¢ Iff (Eq K.orthogonal Bot.bot) (Eq K Top.top)","decl":"@[simp]\ntheorem Submodule.orthogonal_eq_bot_iff [HasOrthogonalProjection K] : Ká—® = âŠ¥ â†” K = âŠ¤ := by\n  refine âŸ¨?_, fun h => by rw [h, Submodule.top_orthogonal_eq_bot]âŸ©\n  intro h\n  have : K âŠ” Ká—® = âŠ¤ := Submodule.sup_orthogonal_of_completeSpace\n  rwa [h, sup_comm, bot_sup_eq] at this\n\n"}
{"name":"orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nv : E\nhv : Membership.mem K.orthogonal v\nâŠ¢ Eq ((orthogonalProjection K) v) 0","decl":"/-- The orthogonal projection onto `K` of an element of `Ká—®` is zero. -/\ntheorem orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero [HasOrthogonalProjection K]\n    {v : E} (hv : v âˆˆ Ká—®) : orthogonalProjection K v = 0 := by\n  ext\n  convert eq_orthogonalProjection_of_mem_orthogonal (K := K) _ _ <;> simp [hv]\n\n"}
{"name":"Submodule.IsOrtho.orthogonalProjection_comp_subtypeL","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nU V : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection U\nh : U.IsOrtho V\nâŠ¢ Eq ((orthogonalProjection U).comp V.subtypeL) 0","decl":"/-- The projection into `U` from an orthogonal submodule `V` is the zero map. -/\ntheorem Submodule.IsOrtho.orthogonalProjection_comp_subtypeL {U V : Submodule ğ•œ E}\n    [HasOrthogonalProjection U] (h : U âŸ‚ V) : orthogonalProjection U âˆ˜L V.subtypeL = 0 :=\n  ContinuousLinearMap.ext fun v =>\n    orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero <| h.symm v.prop\n\n"}
{"name":"orthogonalProjection_comp_subtypeL_eq_zero_iff","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nU V : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection U\nâŠ¢ Iff (Eq ((orthogonalProjection U).comp V.subtypeL) 0) (U.IsOrtho V)","decl":"/-- The projection into `U` from `V` is the zero map if and only if `U` and `V` are orthogonal. -/\ntheorem orthogonalProjection_comp_subtypeL_eq_zero_iff {U V : Submodule ğ•œ E}\n    [HasOrthogonalProjection U] : orthogonalProjection U âˆ˜L V.subtypeL = 0 â†” U âŸ‚ V :=\n  âŸ¨fun h u hu v hv => by\n    convert orthogonalProjection_inner_eq_zero v u hu using 2\n    have : orthogonalProjection U v = 0 := DFunLike.congr_fun h (âŸ¨_, hvâŸ© : V)\n    rw [this, Submodule.coe_zero, sub_zero], Submodule.IsOrtho.orthogonalProjection_comp_subtypeLâŸ©\n\n"}
{"name":"orthogonalProjection_eq_linear_proj","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nx : E\nâŠ¢ Eq ((orthogonalProjection K) x) ((K.linearProjOfIsCompl K.orthogonal â‹¯) x)","decl":"theorem orthogonalProjection_eq_linear_proj [HasOrthogonalProjection K] (x : E) :\n    orthogonalProjection K x =\n      K.linearProjOfIsCompl _ Submodule.isCompl_orthogonal_of_completeSpace x := by\n  have : IsCompl K Ká—® := Submodule.isCompl_orthogonal_of_completeSpace\n  conv_lhs => rw [â† Submodule.linear_proj_add_linearProjOfIsCompl_eq_self this x]\n  rw [map_add, orthogonalProjection_mem_subspace_eq_self,\n    orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero (Submodule.coe_mem _), add_zero]\n\n"}
{"name":"orthogonalProjection_coe_linearMap_eq_linearProj","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nâŠ¢ Eq (â†‘(orthogonalProjection K)) (K.linearProjOfIsCompl K.orthogonal â‹¯)","decl":"theorem orthogonalProjection_coe_linearMap_eq_linearProj [HasOrthogonalProjection K] :\n    (orthogonalProjection K : E â†’â‚—[ğ•œ] K) =\n      K.linearProjOfIsCompl _ Submodule.isCompl_orthogonal_of_completeSpace :=\n  LinearMap.ext <| orthogonalProjection_eq_linear_proj\n\n"}
{"name":"reflection_mem_subspace_orthogonalComplement_eq_neg","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nv : E\nhv : Membership.mem K.orthogonal v\nâŠ¢ Eq ((reflection K) v) (Neg.neg v)","decl":"/-- The reflection in `K` of an element of `Ká—®` is its negation. -/\ntheorem reflection_mem_subspace_orthogonalComplement_eq_neg [HasOrthogonalProjection K] {v : E}\n    (hv : v âˆˆ Ká—®) : reflection K v = -v := by\n  simp [reflection_apply, orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero hv]\n\n"}
{"name":"orthogonalProjection_mem_subspace_orthogonal_precomplement_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K.orthogonal\nv : E\nhv : Membership.mem K v\nâŠ¢ Eq ((orthogonalProjection K.orthogonal) v) 0","decl":"/-- The orthogonal projection onto `Ká—®` of an element of `K` is zero. -/\ntheorem orthogonalProjection_mem_subspace_orthogonal_precomplement_eq_zero\n    [HasOrthogonalProjection Ká—®] {v : E} (hv : v âˆˆ K) : orthogonalProjection Ká—® v = 0 :=\n  orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero (K.le_orthogonal_orthogonal hv)\n\n"}
{"name":"orthogonalProjection_orthogonalProjection_of_le","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nU V : Submodule ğ•œ E\ninstâœÂ¹ : HasOrthogonalProjection U\ninstâœ : HasOrthogonalProjection V\nh : LE.le U V\nx : E\nâŠ¢ Eq ((orthogonalProjection U) â†‘((orthogonalProjection V) x)) ((orthogonalProjection U) x)","decl":"/-- If `U â‰¤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. -/\ntheorem orthogonalProjection_orthogonalProjection_of_le {U V : Submodule ğ•œ E}\n    [HasOrthogonalProjection U] [HasOrthogonalProjection V] (h : U â‰¤ V) (x : E) :\n    orthogonalProjection U (orthogonalProjection V x) = orthogonalProjection U x :=\n  Eq.symm <| by\n    simpa only [sub_eq_zero, map_sub] using\n      orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero\n        (Submodule.orthogonal_le h (sub_orthogonalProjection_mem_orthogonal x))\n\n"}
{"name":"orthogonalProjection_tendsto_closure_iSup","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\ninstâœÂ² : Preorder Î¹\nU : Î¹ â†’ Submodule ğ•œ E\ninstâœÂ¹ : âˆ€ (i : Î¹), HasOrthogonalProjection (U i)\ninstâœ : HasOrthogonalProjection (iSup fun i => U i).topologicalClosure\nhU : Monotone U\nx : E\nâŠ¢ Filter.Tendsto (fun i => â†‘((orthogonalProjection (U i)) x)) Filter.atTop (nhds â†‘((orthogonalProjection (iSup fun i => U i).topologicalClosure) x))","decl":"/-- Given a monotone family `U` of complete submodules of `E` and a fixed `x : E`,\nthe orthogonal projection of `x` on `U i` tends to the orthogonal projection of `x` on\n`(â¨† i, U i).topologicalClosure` along `atTop`. -/\ntheorem orthogonalProjection_tendsto_closure_iSup {Î¹ : Type*} [Preorder Î¹]\n    (U : Î¹ â†’ Submodule ğ•œ E) [âˆ€ i, HasOrthogonalProjection (U i)]\n    [HasOrthogonalProjection (â¨† i, U i).topologicalClosure] (hU : Monotone U) (x : E) :\n    Filter.Tendsto (fun i => (orthogonalProjection (U i) x : E)) atTop\n      (ğ“ (orthogonalProjection (â¨† i, U i).topologicalClosure x : E)) := by\n  refine .of_neBot_imp fun h â†¦ ?_\n  cases atTop_neBot_iff.mp h\n  let y := (orthogonalProjection (â¨† i, U i).topologicalClosure x : E)\n  have proj_x : âˆ€ i, orthogonalProjection (U i) x = orthogonalProjection (U i) y := fun i =>\n    (orthogonalProjection_orthogonalProjection_of_le\n        ((le_iSup U i).trans (iSup U).le_topologicalClosure) _).symm\n  suffices âˆ€ Îµ > 0, âˆƒ I, âˆ€ i â‰¥ I, â€–(orthogonalProjection (U i) y : E) - yâ€– < Îµ by\n    simpa only [proj_x, NormedAddCommGroup.tendsto_atTop] using this\n  intro Îµ hÎµ\n  obtain âŸ¨a, ha, hayâŸ© : âˆƒ a âˆˆ â¨† i, U i, dist y a < Îµ := by\n    have y_mem : y âˆˆ (â¨† i, U i).topologicalClosure := Submodule.coe_mem _\n    rw [â† SetLike.mem_coe, Submodule.topologicalClosure_coe, Metric.mem_closure_iff] at y_mem\n    exact y_mem Îµ hÎµ\n  rw [dist_eq_norm] at hay\n  obtain âŸ¨I, hIâŸ© : âˆƒ I, a âˆˆ U I := by rwa [Submodule.mem_iSup_of_directed _ hU.directed_le] at ha\n  refine âŸ¨I, fun i (hi : I â‰¤ i) => ?_âŸ©\n  rw [norm_sub_rev, orthogonalProjection_minimal]\n  refine lt_of_le_of_lt ?_ hay\n  change _ â‰¤ â€–y - (âŸ¨a, hU hi hIâŸ© : U i)â€–\n  exact ciInf_le âŸ¨0, Set.forall_mem_range.mpr fun _ => norm_nonneg _âŸ© _\n\n"}
{"name":"orthogonalProjection_tendsto_self","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\ninstâœÂ¹ : Preorder Î¹\nU : Î¹ â†’ Submodule ğ•œ E\ninstâœ : âˆ€ (t : Î¹), HasOrthogonalProjection (U t)\nhU : Monotone U\nx : E\nhU' : LE.le Top.top (iSup fun t => U t).topologicalClosure\nâŠ¢ Filter.Tendsto (fun t => â†‘((orthogonalProjection (U t)) x)) Filter.atTop (nhds x)","decl":"/-- Given a monotone family `U` of complete submodules of `E` with dense span supremum,\nand a fixed `x : E`, the orthogonal projection of `x` on `U i` tends to `x` along `at_top`. -/\ntheorem orthogonalProjection_tendsto_self {Î¹ : Type*} [Preorder Î¹]\n    (U : Î¹ â†’ Submodule ğ•œ E) [âˆ€ t, HasOrthogonalProjection (U t)] (hU : Monotone U) (x : E)\n    (hU' : âŠ¤ â‰¤ (â¨† t, U t).topologicalClosure) :\n    Filter.Tendsto (fun t => (orthogonalProjection (U t) x : E)) atTop (ğ“ x) := by\n  have : HasOrthogonalProjection (â¨† i, U i).topologicalClosure := by\n    rw [top_unique hU']\n    infer_instance\n  convert orthogonalProjection_tendsto_closure_iSup U hU x\n  rw [eq_comm, orthogonalProjection_eq_self_iff, top_unique hU']\n  trivial\n\n"}
{"name":"Submodule.triorthogonal_eq_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : CompleteSpace E\nâŠ¢ Eq K.orthogonal.orthogonal.orthogonal K.orthogonal","decl":"/-- The orthogonal complement satisfies `Ká—®á—®á—® = Ká—®`. -/\ntheorem Submodule.triorthogonal_eq_orthogonal [CompleteSpace E] : Ká—®á—®á—® = Ká—® := by\n  rw [Ká—®.orthogonal_orthogonal_eq_closure]\n  exact K.isClosed_orthogonal.submodule_topologicalClosure_eq\n\n"}
{"name":"Submodule.topologicalClosure_eq_top_iff","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : CompleteSpace E\nâŠ¢ Iff (Eq K.topologicalClosure Top.top) (Eq K.orthogonal Bot.bot)","decl":"/-- The closure of `K` is the full space iff `Ká—®` is trivial. -/\ntheorem Submodule.topologicalClosure_eq_top_iff [CompleteSpace E] :\n    K.topologicalClosure = âŠ¤ â†” Ká—® = âŠ¥ := by\n  rw [â† Submodule.orthogonal_orthogonal_eq_closure]\n  constructor <;> intro h\n  Â· rw [â† Submodule.triorthogonal_eq_orthogonal, h, Submodule.top_orthogonal_eq_bot]\n  Â· rw [h, Submodule.bot_orthogonal_eq_top]\n\n"}
{"name":"Dense.eq_zero_of_inner_left","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nx : E\nhK : Dense â†‘K\nh : âˆ€ (v : Subtype fun x => Membership.mem K x), Eq (Inner.inner x â†‘v) 0\nâŠ¢ Eq x 0","decl":"theorem eq_zero_of_inner_left (hK : Dense (K : Set E)) (h : âˆ€ v : K, âŸªx, vâŸ« = 0) : x = 0 := by\n  have : (âŸªx, Â·âŸ«) = 0 := (continuous_const.inner continuous_id).ext_on\n    hK continuous_const (Subtype.forall.1 h)\n  simpa using congr_fun this x\n\n"}
{"name":"Dense.eq_zero_of_mem_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nx : E\nhK : Dense â†‘K\nh : Membership.mem K.orthogonal x\nâŠ¢ Eq x 0","decl":"theorem eq_zero_of_mem_orthogonal (hK : Dense (K : Set E)) (h : x âˆˆ Ká—®) : x = 0 :=\n  eq_zero_of_inner_left hK fun v â†¦ (mem_orthogonal' _ _).1 h _ v.2\n\n"}
{"name":"Dense.eq_of_sub_mem_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nx y : E\nhK : Dense â†‘K\nh : Membership.mem K.orthogonal (HSub.hSub x y)\nâŠ¢ Eq x y","decl":"/-- If `S` is dense and `x - y âˆˆ Ká—®`, then `x = y`. -/\ntheorem eq_of_sub_mem_orthogonal (hK : Dense (K : Set E)) (h : x - y âˆˆ Ká—®) : x = y :=\n  sub_eq_zero.1 <| eq_zero_of_mem_orthogonal hK h\n\n"}
{"name":"Dense.eq_of_inner_left","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nx y : E\nhK : Dense â†‘K\nh : âˆ€ (v : Subtype fun x => Membership.mem K x), Eq (Inner.inner x â†‘v) (Inner.inner y â†‘v)\nâŠ¢ Eq x y","decl":"theorem eq_of_inner_left (hK : Dense (K : Set E)) (h : âˆ€ v : K, âŸªx, vâŸ« = âŸªy, vâŸ«) : x = y :=\n  hK.eq_of_sub_mem_orthogonal (Submodule.sub_mem_orthogonal_of_inner_left h)\n\n"}
{"name":"Dense.eq_of_inner_right","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nx y : E\nhK : Dense â†‘K\nh : âˆ€ (v : Subtype fun x => Membership.mem K x), Eq (Inner.inner (â†‘v) x) (Inner.inner (â†‘v) y)\nâŠ¢ Eq x y","decl":"theorem eq_of_inner_right (hK : Dense (K : Set E)) (h : âˆ€ v : K, âŸª(v : E), xâŸ« = âŸª(v : E), yâŸ«) :\n    x = y :=\n  hK.eq_of_sub_mem_orthogonal (Submodule.sub_mem_orthogonal_of_inner_right h)\n\n"}
{"name":"Dense.eq_zero_of_inner_right","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nx : E\nhK : Dense â†‘K\nh : âˆ€ (v : Subtype fun x => Membership.mem K x), Eq (Inner.inner (â†‘v) x) 0\nâŠ¢ Eq x 0","decl":"theorem eq_zero_of_inner_right (hK : Dense (K : Set E)) (h : âˆ€ v : K, âŸª(v : E), xâŸ« = 0) : x = 0 :=\n  hK.eq_of_inner_right fun v => by rw [inner_zero_right, h v]\n\n"}
{"name":"reflection_mem_subspace_orthogonal_precomplement_eq_neg","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nv : E\nhv : Membership.mem K v\nâŠ¢ Eq ((reflection K.orthogonal) v) (Neg.neg v)","decl":"/-- The reflection in `Ká—®` of an element of `K` is its negation. -/\ntheorem reflection_mem_subspace_orthogonal_precomplement_eq_neg [HasOrthogonalProjection K] {v : E}\n    (hv : v âˆˆ K) : reflection Ká—® v = -v :=\n  reflection_mem_subspace_orthogonalComplement_eq_neg (K.le_orthogonal_orthogonal hv)\n\n"}
{"name":"orthogonalProjection_orthogonalComplement_singleton_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nv : E\nâŠ¢ Eq ((orthogonalProjection (Submodule.span ğ•œ (Singleton.singleton v)).orthogonal) v) 0","decl":"/-- The orthogonal projection onto `(ğ•œ âˆ™ v)á—®` of `v` is zero. -/\ntheorem orthogonalProjection_orthogonalComplement_singleton_eq_zero (v : E) :\n    orthogonalProjection (ğ•œ âˆ™ v)á—® v = 0 :=\n  orthogonalProjection_mem_subspace_orthogonal_precomplement_eq_zero\n    (Submodule.mem_span_singleton_self v)\n\n"}
{"name":"reflection_orthogonalComplement_singleton_eq_neg","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nv : E\nâŠ¢ Eq ((reflection (Submodule.span ğ•œ (Singleton.singleton v)).orthogonal) v) (Neg.neg v)","decl":"/-- The reflection in `(ğ•œ âˆ™ v)á—®` of `v` is `-v`. -/\ntheorem reflection_orthogonalComplement_singleton_eq_neg (v : E) : reflection (ğ•œ âˆ™ v)á—® v = -v :=\n  reflection_mem_subspace_orthogonal_precomplement_eq_neg (Submodule.mem_span_singleton_self v)\n\n"}
{"name":"reflection_sub","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"F : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nv w : F\nh : Eq (Norm.norm v) (Norm.norm w)\nâŠ¢ Eq ((reflection (Submodule.span Real (Singleton.singleton (HSub.hSub v w))).orthogonal) v) w","decl":"theorem reflection_sub {v w : F} (h : â€–vâ€– = â€–wâ€–) : reflection (â„ âˆ™ (v - w))á—® v = w := by\n  set R : F â‰ƒâ‚—áµ¢[â„] F := reflection (â„ âˆ™ v - w)á—®\n  suffices R v + R v = w + w by\n    apply smul_right_injective F (by norm_num : (2 : â„) â‰  0)\n    simpa [two_smul] using this\n  have hâ‚ : R (v - w) = -(v - w) := reflection_orthogonalComplement_singleton_eq_neg (v - w)\n  have hâ‚‚ : R (v + w) = v + w := by\n    apply reflection_mem_subspace_eq_self\n    rw [Submodule.mem_orthogonal_singleton_iff_inner_left]\n    rw [real_inner_add_sub_eq_zero_iff]\n    exact h\n  convert congr_argâ‚‚ (Â· + Â·) hâ‚‚ hâ‚ using 1\n  Â· simp\n  Â· abel\n\n"}
{"name":"det_reflection","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : FiniteDimensional ğ•œ (Subtype fun x => Membership.mem K x)\nâŠ¢ Eq (LinearMap.det â†‘(reflection K).toLinearEquiv) (HPow.hPow (-1) (Module.finrank ğ•œ (Subtype fun x => Membership.mem K.orthogonal x)))","decl":"@[simp]\ntheorem det_reflection : LinearMap.det (reflection K).toLinearMap = (-1) ^ finrank ğ•œ Ká—® := by\n  by_cases hK : FiniteDimensional ğ•œ Ká—®\n  swap\n  Â· rw [finrank_of_infinite_dimensional hK, pow_zero, LinearMap.det_eq_one_of_finrank_eq_zero]\n    exact finrank_of_infinite_dimensional fun h â†¦ hK (h.finiteDimensional_submodule _)\n  let e := K.prodEquivOfIsCompl _ K.isCompl_orthogonal_of_completeSpace\n  let b := (finBasis ğ•œ K).prod (finBasis ğ•œ Ká—®)\n  have : LinearMap.toMatrix b b (e.symm âˆ˜â‚— (reflection K).toLinearMap âˆ˜â‚— e.symm.symm) =\n      Matrix.fromBlocks 1 0 0 (-1) := by\n    ext (_ | _) (_ | _) <;>\n    simp [LinearMap.toMatrix_apply, b, Matrix.one_apply, Finsupp.single_apply, e, eq_comm,\n      reflection_mem_subspace_eq_self, reflection_mem_subspace_orthogonalComplement_eq_neg]\n  rw [â† LinearMap.det_conj _ e.symm, â† LinearMap.det_toMatrix b, this, Matrix.det_fromBlocks_zeroâ‚‚â‚,\n    Matrix.det_one, one_mul, Matrix.det_neg, Fintype.card_fin, Matrix.det_one, mul_one]\n\n"}
{"name":"linearEquiv_det_reflection","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : FiniteDimensional ğ•œ (Subtype fun x => Membership.mem K x)\nâŠ¢ Eq (LinearEquiv.det (reflection K).toLinearEquiv) (HPow.hPow (-1) (Module.finrank ğ•œ (Subtype fun x => Membership.mem K.orthogonal x)))","decl":"@[simp]\ntheorem linearEquiv_det_reflection : (reflection K).det = (-1) ^ finrank ğ•œ Ká—® := by\n  ext\n  rw [LinearEquiv.coe_det, Units.val_pow_eq_pow_val]\n  exact det_reflection K\n\n"}
{"name":"orthogonalProjection_add_orthogonalProjection_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nw : E\nâŠ¢ Eq (HAdd.hAdd â†‘((orthogonalProjection K) w) â†‘((orthogonalProjection K.orthogonal) w)) w","decl":"/-- If the orthogonal projection to `K` is well-defined, then a vector splits as the sum of its\northogonal projections onto a complete submodule `K` and onto the orthogonal complement of `K`. -/\ntheorem orthogonalProjection_add_orthogonalProjection_orthogonal [HasOrthogonalProjection K]\n    (w : E) : (orthogonalProjection K w : E) + (orthogonalProjection Ká—® w : E) = w := by\n  simp\n\n"}
{"name":"norm_sq_eq_add_norm_sq_projection","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nx : E\nS : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection S\nâŠ¢ Eq (HPow.hPow (Norm.norm x) 2) (HAdd.hAdd (HPow.hPow (Norm.norm ((orthogonalProjection S) x)) 2) (HPow.hPow (Norm.norm ((orthogonalProjection S.orthogonal) x)) 2))","decl":"/-- The Pythagorean theorem, for an orthogonal projection. -/\ntheorem norm_sq_eq_add_norm_sq_projection (x : E) (S : Submodule ğ•œ E) [HasOrthogonalProjection S] :\n    â€–xâ€– ^ 2 = â€–orthogonalProjection S xâ€– ^ 2 + â€–orthogonalProjection Sá—® xâ€– ^ 2 :=\n  calc\n    â€–xâ€– ^ 2 = â€–(orthogonalProjection S x : E) + orthogonalProjection Sá—® xâ€– ^ 2 := by\n      rw [orthogonalProjection_add_orthogonalProjection_orthogonal]\n    _ = â€–orthogonalProjection S xâ€– ^ 2 + â€–orthogonalProjection Sá—® xâ€– ^ 2 := by\n      simp only [sq]\n      exact norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero _ _ <|\n        (S.mem_orthogonal _).1 (orthogonalProjection Sá—® x).2 _ (orthogonalProjection S x).2\n\n"}
{"name":"id_eq_sum_orthogonalProjection_self_orthogonalComplement","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nâŠ¢ Eq (ContinuousLinearMap.id ğ•œ E) (HAdd.hAdd (K.subtypeL.comp (orthogonalProjection K)) (K.orthogonal.subtypeL.comp (orthogonalProjection K.orthogonal)))","decl":"/-- In a complete space `E`, the projection maps onto a complete subspace `K` and its orthogonal\ncomplement sum to the identity. -/\ntheorem id_eq_sum_orthogonalProjection_self_orthogonalComplement [HasOrthogonalProjection K] :\n    ContinuousLinearMap.id ğ•œ E =\n      K.subtypeL.comp (orthogonalProjection K) + Ká—®.subtypeL.comp (orthogonalProjection Ká—®) := by\n  ext w\n  exact (orthogonalProjection_add_orthogonalProjection_orthogonal K w).symm\n\n-- Porting note: The priority should be higher than `Submodule.coe_inner`.\n"}
{"name":"inner_orthogonalProjection_eq_of_mem_right","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nu : Subtype fun x => Membership.mem K x\nv : E\nâŠ¢ Eq (Inner.inner ((orthogonalProjection K) v) u) (Inner.inner v â†‘u)","decl":"@[simp high]\ntheorem inner_orthogonalProjection_eq_of_mem_right [HasOrthogonalProjection K] (u : K) (v : E) :\n    âŸªorthogonalProjection K v, uâŸ« = âŸªv, uâŸ« :=\n  calc\n    âŸªorthogonalProjection K v, uâŸ« = âŸª(orthogonalProjection K v : E), uâŸ« := K.coe_inner _ _\n    _ = âŸª(orthogonalProjection K v : E), uâŸ« + âŸªv - orthogonalProjection K v, uâŸ« := by\n      rw [orthogonalProjection_inner_eq_zero _ _ (Submodule.coe_mem _), add_zero]\n    _ = âŸªv, uâŸ« := by rw [â† inner_add_left, add_sub_cancel]\n\n-- Porting note: The priority should be higher than `Submodule.coe_inner`.\n"}
{"name":"inner_orthogonalProjection_eq_of_mem_left","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nu : Subtype fun x => Membership.mem K x\nv : E\nâŠ¢ Eq (Inner.inner u ((orthogonalProjection K) v)) (Inner.inner (â†‘u) v)","decl":"@[simp high]\ntheorem inner_orthogonalProjection_eq_of_mem_left [HasOrthogonalProjection K] (u : K) (v : E) :\n    âŸªu, orthogonalProjection K vâŸ« = âŸª(u : E), vâŸ« := by\n  rw [â† inner_conj_symm, â† inner_conj_symm (u : E), inner_orthogonalProjection_eq_of_mem_right]\n\n"}
{"name":"inner_orthogonalProjection_left_eq_right","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nu v : E\nâŠ¢ Eq (Inner.inner (â†‘((orthogonalProjection K) u)) v) (Inner.inner u â†‘((orthogonalProjection K) v))","decl":"/-- The orthogonal projection is self-adjoint. -/\ntheorem inner_orthogonalProjection_left_eq_right [HasOrthogonalProjection K] (u v : E) :\n    âŸªâ†‘(orthogonalProjection K u), vâŸ« = âŸªu, orthogonalProjection K vâŸ« := by\n  rw [â† inner_orthogonalProjection_eq_of_mem_left, inner_orthogonalProjection_eq_of_mem_right]\n\n"}
{"name":"orthogonalProjection_isSymmetric","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : HasOrthogonalProjection K\nâŠ¢ (â†‘(K.subtypeL.comp (orthogonalProjection K))).IsSymmetric","decl":"/-- The orthogonal projection is symmetric. -/\ntheorem orthogonalProjection_isSymmetric [HasOrthogonalProjection K] :\n    (K.subtypeL âˆ˜L orthogonalProjection K : E â†’â‚—[ğ•œ] E).IsSymmetric :=\n  inner_orthogonalProjection_left_eq_right K\n\n"}
{"name":"Submodule.finrank_add_inf_finrank_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nKâ‚ Kâ‚‚ : Submodule ğ•œ E\ninstâœ : FiniteDimensional ğ•œ (Subtype fun x => Membership.mem Kâ‚‚ x)\nh : LE.le Kâ‚ Kâ‚‚\nâŠ¢ Eq (HAdd.hAdd (Module.finrank ğ•œ (Subtype fun x => Membership.mem Kâ‚ x)) (Module.finrank ğ•œ (Subtype fun x => Membership.mem (Min.min Kâ‚.orthogonal Kâ‚‚) x))) (Module.finrank ğ•œ (Subtype fun x => Membership.mem Kâ‚‚ x))","decl":"/-- Given a finite-dimensional subspace `Kâ‚‚`, and a subspace `Kâ‚`\ncontained in it, the dimensions of `Kâ‚` and the intersection of its\northogonal subspace with `Kâ‚‚` add to that of `Kâ‚‚`. -/\ntheorem Submodule.finrank_add_inf_finrank_orthogonal {Kâ‚ Kâ‚‚ : Submodule ğ•œ E}\n    [FiniteDimensional ğ•œ Kâ‚‚] (h : Kâ‚ â‰¤ Kâ‚‚) :\n    finrank ğ•œ Kâ‚ + finrank ğ•œ (Kâ‚á—® âŠ“ Kâ‚‚ : Submodule ğ•œ E) = finrank ğ•œ Kâ‚‚ := by\n  haveI : FiniteDimensional ğ•œ Kâ‚ := Submodule.finiteDimensional_of_le h\n  haveI := FiniteDimensional.proper_rclike ğ•œ Kâ‚\n  have hd := Submodule.finrank_sup_add_finrank_inf_eq Kâ‚ (Kâ‚á—® âŠ“ Kâ‚‚)\n  rw [â† inf_assoc, (Submodule.orthogonal_disjoint Kâ‚).eq_bot, bot_inf_eq, finrank_bot,\n    Submodule.sup_orthogonal_inf_of_completeSpace h] at hd\n  rw [add_zero] at hd\n  exact hd.symm\n\n"}
{"name":"Submodule.finrank_add_inf_finrank_orthogonal'","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nKâ‚ Kâ‚‚ : Submodule ğ•œ E\ninstâœ : FiniteDimensional ğ•œ (Subtype fun x => Membership.mem Kâ‚‚ x)\nh : LE.le Kâ‚ Kâ‚‚\nn : Nat\nh_dim : Eq (HAdd.hAdd (Module.finrank ğ•œ (Subtype fun x => Membership.mem Kâ‚ x)) n) (Module.finrank ğ•œ (Subtype fun x => Membership.mem Kâ‚‚ x))\nâŠ¢ Eq (Module.finrank ğ•œ (Subtype fun x => Membership.mem (Min.min Kâ‚.orthogonal Kâ‚‚) x)) n","decl":"/-- Given a finite-dimensional subspace `Kâ‚‚`, and a subspace `Kâ‚`\ncontained in it, the dimensions of `Kâ‚` and the intersection of its\northogonal subspace with `Kâ‚‚` add to that of `Kâ‚‚`. -/\ntheorem Submodule.finrank_add_inf_finrank_orthogonal' {Kâ‚ Kâ‚‚ : Submodule ğ•œ E}\n    [FiniteDimensional ğ•œ Kâ‚‚] (h : Kâ‚ â‰¤ Kâ‚‚) {n : â„•} (h_dim : finrank ğ•œ Kâ‚ + n = finrank ğ•œ Kâ‚‚) :\n    finrank ğ•œ (Kâ‚á—® âŠ“ Kâ‚‚ : Submodule ğ•œ E) = n := by\n  rw [â† add_right_inj (finrank ğ•œ Kâ‚)]\n  simp [Submodule.finrank_add_inf_finrank_orthogonal h, h_dim]\n\n"}
{"name":"Submodule.finrank_add_finrank_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\nK : Submodule ğ•œ E\nâŠ¢ Eq (HAdd.hAdd (Module.finrank ğ•œ (Subtype fun x => Membership.mem K x)) (Module.finrank ğ•œ (Subtype fun x => Membership.mem K.orthogonal x))) (Module.finrank ğ•œ E)","decl":"/-- Given a finite-dimensional space `E` and subspace `K`, the dimensions of `K` and `Ká—®` add to\nthat of `E`. -/\ntheorem Submodule.finrank_add_finrank_orthogonal [FiniteDimensional ğ•œ E] (K : Submodule ğ•œ E) :\n    finrank ğ•œ K + finrank ğ•œ Ká—® = finrank ğ•œ E := by\n  convert Submodule.finrank_add_inf_finrank_orthogonal (le_top : K â‰¤ âŠ¤) using 1\n  Â· rw [inf_top_eq]\n  Â· simp\n\n"}
{"name":"Submodule.finrank_add_finrank_orthogonal'","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\nK : Submodule ğ•œ E\nn : Nat\nh_dim : Eq (HAdd.hAdd (Module.finrank ğ•œ (Subtype fun x => Membership.mem K x)) n) (Module.finrank ğ•œ E)\nâŠ¢ Eq (Module.finrank ğ•œ (Subtype fun x => Membership.mem K.orthogonal x)) n","decl":"/-- Given a finite-dimensional space `E` and subspace `K`, the dimensions of `K` and `Ká—®` add to\nthat of `E`. -/\ntheorem Submodule.finrank_add_finrank_orthogonal' [FiniteDimensional ğ•œ E] {K : Submodule ğ•œ E}\n    {n : â„•} (h_dim : finrank ğ•œ K + n = finrank ğ•œ E) : finrank ğ•œ Ká—® = n := by\n  rw [â† add_right_inj (finrank ğ•œ K)]\n  simp [Submodule.finrank_add_finrank_orthogonal, h_dim]\n\n"}
{"name":"finrank_orthogonal_span_singleton","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nn : Nat\n_i : Fact (Eq (Module.finrank ğ•œ E) (HAdd.hAdd n 1))\nv : E\nhv : Ne v 0\nâŠ¢ Eq (Module.finrank ğ•œ (Subtype fun x => Membership.mem (Submodule.span ğ•œ (Singleton.singleton v)).orthogonal x)) n","decl":"/-- In a finite-dimensional inner product space, the dimension of the orthogonal complement of the\nspan of a nonzero vector is one less than the dimension of the space. -/\ntheorem finrank_orthogonal_span_singleton {n : â„•} [_i : Fact (finrank ğ•œ E = n + 1)] {v : E}\n    (hv : v â‰  0) : finrank ğ•œ (ğ•œ âˆ™ v)á—® = n := by\n  haveI : FiniteDimensional ğ•œ E := .of_fact_finrank_eq_succ n\n  exact Submodule.finrank_add_finrank_orthogonal' <| by\n    simp [finrank_span_singleton hv, _i.elim, add_comm]\n\n"}
{"name":"LinearIsometryEquiv.reflections_generate_dim_aux","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"F : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : InnerProductSpace Real F\ninstâœ : FiniteDimensional Real F\nn : Nat\nÏ† : LinearIsometryEquiv (RingHom.id Real) F F\nhn : LE.le (Module.finrank Real (Subtype fun x => Membership.mem (LinearMap.ker (HSub.hSub (ContinuousLinearMap.id Real F) â†‘{ toLinearEquiv := Ï†.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ })).orthogonal x)) n\nâŠ¢ Exists fun l => And (LE.le l.length n) (Eq Ï† (List.map (fun v => reflection (Submodule.span Real (Singleton.singleton v)).orthogonal) l).prod)","decl":"/-- An element `Ï†` of the orthogonal group of `F` can be factored as a product of reflections, and\nspecifically at most as many reflections as the dimension of the complement of the fixed subspace\nof `Ï†`. -/\ntheorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional â„ F] {n : â„•}\n    (Ï† : F â‰ƒâ‚—áµ¢[â„] F) (hn : finrank â„ (ker (ContinuousLinearMap.id â„ F - Ï†))á—® â‰¤ n) :\n    âˆƒ l : List F, l.length â‰¤ n âˆ§ Ï† = (l.map fun v => reflection (â„ âˆ™ v)á—®).prod := by\n  -- We prove this by strong induction on `n`, the dimension of the orthogonal complement of the\n  -- fixed subspace of the endomorphism `Ï†`\n  induction' n with n IH generalizing Ï†\n  Â· -- Base case: `n = 0`, the fixed subspace is the whole space, so `Ï† = id`\n    refine âŸ¨[], rfl.le, show Ï† = 1 from ?_âŸ©\n    have : ker (ContinuousLinearMap.id â„ F - Ï†) = âŠ¤ := by\n      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn\n    symm\n    ext x\n    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x\n    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,\n      LinearMap.zero_apply] using this\n  Â· -- Inductive step.  Let `W` be the fixed subspace of `Ï†`.  We suppose its complement to have\n    -- dimension at most n + 1.\n    let W := ker (ContinuousLinearMap.id â„ F - Ï†)\n    have hW : âˆ€ w âˆˆ W, Ï† w = w := fun w hw => (sub_eq_zero.mp hw).symm\n    by_cases hn' : finrank â„ Wá—® â‰¤ n\n    Â· obtain âŸ¨V, hVâ‚, hVâ‚‚âŸ© := IH Ï† hn'\n      exact âŸ¨V, hVâ‚.trans n.le_succ, hVâ‚‚âŸ©\n    -- Take a nonzero element `v` of the orthogonal complement of `W`.\n    haveI : Nontrivial Wá—® := nontrivial_of_finrank_pos (by omega : 0 < finrank â„ Wá—®)\n    obtain âŸ¨v, hvâŸ© := exists_ne (0 : Wá—®)\n    have hÏ†v : Ï† v âˆˆ Wá—® := by\n      intro w hw\n      rw [â† hW w hw, LinearIsometryEquiv.inner_map_map]\n      exact v.prop w hw\n    have hv' : (v : F) âˆ‰ W := by\n      intro h\n      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)\n    -- Let `Ï` be the reflection in `v - Ï† v`; this is designed to swap `v` and `Ï† v`\n    let x : F := v - Ï† v\n    let Ï := reflection (â„ âˆ™ x)á—®\n    -- Notation: Let `V` be the fixed subspace of `Ï†.trans Ï`\n    let V := ker (ContinuousLinearMap.id â„ F - Ï†.trans Ï)\n    have hV : âˆ€ w, Ï (Ï† w) = w â†’ w âˆˆ V := by\n      intro w hw\n      change w - Ï (Ï† w) = 0\n      rw [sub_eq_zero, hw]\n    -- Everything fixed by `Ï†` is fixed by `Ï†.trans Ï`\n    have Hâ‚‚V : W â‰¤ V := by\n      intro w hw\n      apply hV\n      rw [hW w hw]\n      refine reflection_mem_subspace_eq_self ?_\n      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]\n      exact Submodule.sub_mem _ v.prop hÏ†v _ hw\n    -- `v` is also fixed by `Ï†.trans Ï`\n    have Hâ‚V : (v : F) âˆˆ V := by\n      apply hV\n      have : Ï v = Ï† v := reflection_sub (Ï†.norm_map v).symm\n      rw [â† this]\n      exact reflection_reflection _ _\n    -- By dimension-counting, the complement of the fixed subspace of `Ï†.trans Ï` has dimension at\n    -- most `n`\n    have : finrank â„ Vá—® â‰¤ n := by\n      change finrank â„ Wá—® â‰¤ n + 1 at hn\n      have : finrank â„ W + 1 â‰¤ finrank â„ V :=\n        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 âŸ¨Hâ‚‚V, v, Hâ‚V, hv'âŸ©)\n      have : finrank â„ V + finrank â„ Vá—® = finrank â„ F := V.finrank_add_finrank_orthogonal\n      have : finrank â„ W + finrank â„ Wá—® = finrank â„ F := W.finrank_add_finrank_orthogonal\n      omega\n    -- So apply the inductive hypothesis to `Ï†.trans Ï`\n    obtain âŸ¨l, hl, hÏ†lâŸ© := IH (Ï * Ï†) this\n    -- Prepend `Ï` to the factorization into reflections obtained for `Ï†.trans Ï`; this gives a\n    -- factorization into reflections for `Ï†`.\n    refine âŸ¨x::l, Nat.succ_le_succ hl, ?_âŸ©\n    rw [List.map_cons, List.prod_cons]\n    have := congr_arg (Ï * Â·) hÏ†l\n    dsimp only at this\n    rwa [â† mul_assoc, reflection_mul_reflection, one_mul] at this\n\n"}
{"name":"LinearIsometryEquiv.reflections_generate_dim","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"F : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : InnerProductSpace Real F\ninstâœ : FiniteDimensional Real F\nÏ† : LinearIsometryEquiv (RingHom.id Real) F F\nâŠ¢ Exists fun l => And (LE.le l.length (Module.finrank Real F)) (Eq Ï† (List.map (fun v => reflection (Submodule.span Real (Singleton.singleton v)).orthogonal) l).prod)","decl":"/-- The orthogonal group of `F` is generated by reflections; specifically each element `Ï†` of the\northogonal group is a product of at most as many reflections as the dimension of `F`.\n\nSpecial case of the **Cartanâ€“DieudonnÃ© theorem**. -/\ntheorem LinearIsometryEquiv.reflections_generate_dim [FiniteDimensional â„ F] (Ï† : F â‰ƒâ‚—áµ¢[â„] F) :\n    âˆƒ l : List F, l.length â‰¤ finrank â„ F âˆ§ Ï† = (l.map fun v => reflection (â„ âˆ™ v)á—®).prod :=\n  let âŸ¨l, hlâ‚, hlâ‚‚âŸ© := Ï†.reflections_generate_dim_aux le_rfl\n  âŸ¨l, hlâ‚.trans (Submodule.finrank_le _), hlâ‚‚âŸ©\n\n"}
{"name":"LinearIsometryEquiv.reflections_generate","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"F : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : InnerProductSpace Real F\ninstâœ : FiniteDimensional Real F\nâŠ¢ Eq (Subgroup.closure (Set.range fun v => reflection (Submodule.span Real (Singleton.singleton v)).orthogonal)) Top.top","decl":"/-- The orthogonal group of `F` is generated by reflections. -/\ntheorem LinearIsometryEquiv.reflections_generate [FiniteDimensional â„ F] :\n    Subgroup.closure (Set.range fun v : F => reflection (â„ âˆ™ v)á—®) = âŠ¤ := by\n  rw [Subgroup.eq_top_iff']\n  intro Ï†\n  rcases Ï†.reflections_generate_dim with âŸ¨l, _, rflâŸ©\n  apply (Subgroup.closure _).list_prod_mem\n  intro x hx\n  rcases List.mem_map.mp hx with âŸ¨a, _, haxâŸ©\n  exact Subgroup.subset_closure âŸ¨a, haxâŸ©\n\n"}
{"name":"OrthogonalFamily.isInternal_iff_of_isComplete","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\ninstâœ : DecidableEq Î¹\nV : Î¹ â†’ Submodule ğ•œ E\nhV : OrthogonalFamily ğ•œ (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeâ‚—áµ¢\nhc : IsComplete â†‘(iSup V)\nâŠ¢ Iff (DirectSum.IsInternal V) (Eq (iSup V).orthogonal Bot.bot)","decl":"/-- An orthogonal family of subspaces of `E` satisfies `DirectSum.IsInternal` (that is,\nthey provide an internal direct sum decomposition of `E`) if and only if their span has trivial\northogonal complement. -/\ntheorem OrthogonalFamily.isInternal_iff_of_isComplete [DecidableEq Î¹] {V : Î¹ â†’ Submodule ğ•œ E}\n    (hV : OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢)\n    (hc : IsComplete (â†‘(iSup V) : Set E)) : DirectSum.IsInternal V â†” (iSup V)á—® = âŠ¥ := by\n  haveI : CompleteSpace (â†¥(iSup V)) := hc.completeSpace_coe\n  simp only [DirectSum.isInternal_submodule_iff_iSupIndep_and_iSup_eq_top, hV.independent,\n    true_and, Submodule.orthogonal_eq_bot_iff]\n\n"}
{"name":"OrthogonalFamily.isInternal_iff","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : FiniteDimensional ğ•œ E\nV : Î¹ â†’ Submodule ğ•œ E\nhV : OrthogonalFamily ğ•œ (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeâ‚—áµ¢\nâŠ¢ Iff (DirectSum.IsInternal V) (Eq (iSup V).orthogonal Bot.bot)","decl":"/-- An orthogonal family of subspaces of `E` satisfies `DirectSum.IsInternal` (that is,\nthey provide an internal direct sum decomposition of `E`) if and only if their span has trivial\northogonal complement. -/\ntheorem OrthogonalFamily.isInternal_iff [DecidableEq Î¹] [FiniteDimensional ğ•œ E]\n    {V : Î¹ â†’ Submodule ğ•œ E} (hV : OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢) :\n    DirectSum.IsInternal V â†” (iSup V)á—® = âŠ¥ :=\n  haveI h := FiniteDimensional.proper_rclike ğ•œ (â†¥(iSup V))\n  hV.isInternal_iff_of_isComplete (completeSpace_coe_iff_isComplete.mp inferInstance)\n\n"}
{"name":"OrthogonalFamily.sum_projection_of_mem_iSup","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\ninstâœÂ¹ : Fintype Î¹\nV : Î¹ â†’ Submodule ğ•œ E\ninstâœ : âˆ€ (i : Î¹), CompleteSpace (Subtype fun x => Membership.mem (V i) x)\nhV : OrthogonalFamily ğ•œ (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeâ‚—áµ¢\nx : E\nhx : Membership.mem (iSup V) x\nâŠ¢ Eq (Finset.univ.sum fun i => â†‘((orthogonalProjection (V i)) x)) x","decl":"/-- If `x` lies within an orthogonal family `v`, it can be expressed as a sum of projections. -/\ntheorem OrthogonalFamily.sum_projection_of_mem_iSup [Fintype Î¹] {V : Î¹ â†’ Submodule ğ•œ E}\n    [âˆ€ i, CompleteSpace (V i)] (hV : OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢)\n    (x : E) (hx : x âˆˆ iSup V) : (âˆ‘ i, (orthogonalProjection (V i) x : E)) = x := by\n  -- Porting note: switch to the better `induction _ using`. Need the primed induction principle,\n  -- the unprimed one doesn't work with `induction` (as it isn't as syntactically general)\n  induction hx using Submodule.iSup_induction' with\n  | mem i x hx =>\n    refine\n      (Finset.sum_eq_single_of_mem i (Finset.mem_univ _) fun j _ hij => ?_).trans\n        (orthogonalProjection_eq_self_iff.mpr hx)\n    rw [orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero, Submodule.coe_zero]\n    exact hV.isOrtho hij.symm hx\n  | zero =>\n    simp_rw [map_zero, Submodule.coe_zero, Finset.sum_const_zero]\n  | add x y _ _ hx hy =>\n    simp_rw [map_add, Submodule.coe_add, Finset.sum_add_distrib]\n    exact congr_argâ‚‚ (Â· + Â·) hx hy\n\n"}
{"name":"OrthogonalFamily.projection_directSum_coeAddHom","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\nV : Î¹ â†’ Submodule ğ•œ E\nhV : OrthogonalFamily ğ•œ (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeâ‚—áµ¢\nx : DirectSum Î¹ fun i => Subtype fun x => Membership.mem (V i) x\ni : Î¹\ninstâœ : CompleteSpace (Subtype fun x => Membership.mem (V i) x)\nâŠ¢ Eq ((orthogonalProjection (V i)) ((DirectSum.coeAddMonoidHom V) x)) (x i)","decl":"/-- If a family of submodules is orthogonal, then the `orthogonalProjection` on a direct sum\nis just the coefficient of that direct sum. -/\ntheorem OrthogonalFamily.projection_directSum_coeAddHom [DecidableEq Î¹] {V : Î¹ â†’ Submodule ğ•œ E}\n    (hV : OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢) (x : â¨ i, V i) (i : Î¹)\n    [CompleteSpace (V i)] :\n    orthogonalProjection (V i) (DirectSum.coeAddMonoidHom V x) = x i := by\n  induction' x using DirectSum.induction_on with j x x y hx hy\n  Â· simp\n  Â· simp_rw [DirectSum.coeAddMonoidHom_of, DirectSum.of]\n    -- Porting note: was in the previous `simp_rw`, no longer works\n    -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n    erw [DFinsupp.singleAddHom_apply]\n    obtain rfl | hij := Decidable.eq_or_ne i j\n    Â· rw [orthogonalProjection_mem_subspace_eq_self, DFinsupp.single_eq_same]\n    Â· rw [orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero,\n        DFinsupp.single_eq_of_ne hij.symm]\n      exact hV.isOrtho hij.symm x.prop\n  Â· simp_rw [map_add]\n    exact congr_argâ‚‚ (Â· + Â·) hx hy\n\n"}
{"name":"maximal_orthonormal_iff_orthogonalComplement_eq_bot","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nv : Set E\nhv : Orthonormal ğ•œ Subtype.val\nâŠ¢ Iff (âˆ€ (u : Set E), Superset u v â†’ Orthonormal ğ•œ Subtype.val â†’ Eq u v) (Eq (Submodule.span ğ•œ v).orthogonal Bot.bot)","decl":"/-- An orthonormal set in an `InnerProductSpace` is maximal, if and only if the orthogonal\ncomplement of its span is empty. -/\ntheorem maximal_orthonormal_iff_orthogonalComplement_eq_bot (hv : Orthonormal ğ•œ ((â†‘) : v â†’ E)) :\n    (âˆ€ u âŠ‡ v, Orthonormal ğ•œ ((â†‘) : u â†’ E) â†’ u = v) â†” (span ğ•œ v)á—® = âŠ¥ := by\n  rw [Submodule.eq_bot_iff]\n  constructor\n  Â· contrapose!\n    -- ** direction 1: nonempty orthogonal complement implies nonmaximal\n    rintro âŸ¨x, hx', hxâŸ©\n    -- take a nonzero vector and normalize it\n    let e := (â€–xâ€–â»Â¹ : ğ•œ) â€¢ x\n    have he : â€–eâ€– = 1 := by simp [e, norm_smul_inv_norm hx]\n    have he' : e âˆˆ (span ğ•œ v)á—® := smul_mem' _ _ hx'\n    have he'' : e âˆ‰ v := by\n      intro hev\n      have : e = 0 := by\n        have : e âˆˆ span ğ•œ v âŠ“ (span ğ•œ v)á—® := âŸ¨subset_span hev, he'âŸ©\n        simpa [(span ğ•œ v).inf_orthogonal_eq_bot] using this\n      have : e â‰  0 := hv.ne_zero âŸ¨e, hevâŸ©\n      contradiction\n    -- put this together with `v` to provide a candidate orthonormal basis for the whole space\n    refine âŸ¨insert e v, v.subset_insert e, âŸ¨?_, ?_âŸ©, (ne_insert_of_not_mem v he'').symmâŸ©\n    Â· -- show that the elements of `insert e v` have unit length\n      rintro âŸ¨a, ha'âŸ©\n      cases' eq_or_mem_of_mem_insert ha' with ha ha\n      Â· simp [ha, he]\n      Â· exact hv.1 âŸ¨a, haâŸ©\n    Â· -- show that the elements of `insert e v` are orthogonal\n      have h_end : âˆ€ a âˆˆ v, âŸªa, eâŸ« = 0 := by\n        intro a ha\n        exact he' a (Submodule.subset_span ha)\n      rintro âŸ¨a, ha'âŸ©\n      cases' eq_or_mem_of_mem_insert ha' with ha ha\n      Â· rintro âŸ¨b, hb'âŸ© hab'\n        have hb : b âˆˆ v := by\n          refine mem_of_mem_insert_of_ne hb' ?_\n          intro hbe'\n          apply hab'\n          simp [ha, hbe']\n        rw [inner_eq_zero_symm]\n        simpa [ha] using h_end b hb\n      rintro âŸ¨b, hb'âŸ© hab'\n      cases' eq_or_mem_of_mem_insert hb' with hb hb\n      Â· simpa [hb] using h_end a ha\n      have : (âŸ¨a, haâŸ© : v) â‰  âŸ¨b, hbâŸ© := by\n        intro hab''\n        apply hab'\n        simpa using hab''\n      exact hv.2 this\n  Â· -- ** direction 2: empty orthogonal complement implies maximal\n    simp only [Subset.antisymm_iff]\n    rintro h u (huv : v âŠ† u) hu\n    refine âŸ¨?_, huvâŸ©\n    intro x hxu\n    refine ((mt (h x)) (hu.ne_zero âŸ¨x, hxuâŸ©)).imp_symm ?_\n    intro hxv y hy\n    have hxv' : (âŸ¨x, hxuâŸ© : u) âˆ‰ ((â†‘) â»Â¹' v : Set u) := by simp [huv, hxv]\n    obtain âŸ¨l, hl, rflâŸ© :\n      âˆƒ l âˆˆ supported ğ•œ ğ•œ ((â†‘) â»Â¹' v : Set u), (linearCombination ğ•œ ((â†‘) : u â†’ E)) l = y := by\n      rw [â† Finsupp.mem_span_image_iff_linearCombination]\n      simp [huv, inter_eq_self_of_subset_right, hy]\n    exact hu.inner_finsupp_eq_zero hxv' hl\n\n"}
{"name":"maximal_orthonormal_iff_basis_of_finiteDimensional","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nv : Set E\ninstâœ : FiniteDimensional ğ•œ E\nhv : Orthonormal ğ•œ Subtype.val\nâŠ¢ Iff (âˆ€ (u : Set E), Superset u v â†’ Orthonormal ğ•œ Subtype.val â†’ Eq u v) (Exists fun b => Eq (â‡‘b) Subtype.val)","decl":"/-- An orthonormal set in a finite-dimensional `InnerProductSpace` is maximal, if and only if it\nis a basis. -/\ntheorem maximal_orthonormal_iff_basis_of_finiteDimensional (hv : Orthonormal ğ•œ ((â†‘) : v â†’ E)) :\n    (âˆ€ u âŠ‡ v, Orthonormal ğ•œ ((â†‘) : u â†’ E) â†’ u = v) â†” âˆƒ b : Basis v ğ•œ E, â‡‘b = ((â†‘) : v â†’ E) := by\n  haveI := FiniteDimensional.proper_rclike ğ•œ (span ğ•œ v)\n  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hv]\n  rw [Submodule.orthogonal_eq_bot_iff]\n  have hv_coe : range ((â†‘) : v â†’ E) = v := by simp\n  constructor\n  Â· refine fun h => âŸ¨Basis.mk hv.linearIndependent _, Basis.coe_mk _ ?_âŸ©\n    convert h.ge\n  Â· rintro âŸ¨h, coe_hâŸ©\n    rw [â† h.span_eq, coe_h, hv_coe]\n\n"}
