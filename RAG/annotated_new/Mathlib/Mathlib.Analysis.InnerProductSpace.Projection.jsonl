{"name":"exists_norm_eq_iInf_of_complete_convex","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"F : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : InnerProductSpace Real F\nK : Set F\nne : K.Nonempty\nh‚ÇÅ : IsComplete K\nh‚ÇÇ : Convex Real K\nu : F\n‚ä¢ Exists fun v => And (Membership.mem K v) (Eq (Norm.norm (HSub.hSub u v)) (iInf fun w => Norm.norm (HSub.hSub u ‚Üëw)))","decl":"/-- **Existence of minimizers**, aka the **Hilbert projection theorem**.\n\nLet `u` be a point in a real inner product space, and let `K` be a nonempty complete convex subset.\nThen there exists a (unique) `v` in `K` that minimizes the distance `‚Äñu - v‚Äñ` to `u`. -/\ntheorem exists_norm_eq_iInf_of_complete_convex {K : Set F} (ne : K.Nonempty) (h‚ÇÅ : IsComplete K)\n    (h‚ÇÇ : Convex ‚Ñù K) : ‚àÄ u : F, ‚àÉ v ‚àà K, ‚Äñu - v‚Äñ = ‚®Ö w : K, ‚Äñu - w‚Äñ := fun u => by\n  let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ\n  letI : Nonempty K := ne.to_subtype\n  have zero_le_Œ¥ : 0 ‚â§ Œ¥ := le_ciInf fun _ => norm_nonneg _\n  have Œ¥_le : ‚àÄ w : K, Œ¥ ‚â§ ‚Äñu - w‚Äñ := ciInf_le ‚ü®0, Set.forall_mem_range.2 fun _ => norm_nonneg _‚ü©\n  have Œ¥_le' : ‚àÄ w ‚àà K, Œ¥ ‚â§ ‚Äñu - w‚Äñ := fun w hw => Œ¥_le ‚ü®w, hw‚ü©\n  -- Step 1: since `Œ¥` is the infimum, can find a sequence `w : ‚Ñï ‚Üí K` in `K`\n  -- such that `‚Äñu - w n‚Äñ < Œ¥ + 1 / (n + 1)` (which implies `‚Äñu - w n‚Äñ --> Œ¥`);\n  -- maybe this should be a separate lemma\n  have exists_seq : ‚àÉ w : ‚Ñï ‚Üí K, ‚àÄ n, ‚Äñu - w n‚Äñ < Œ¥ + 1 / (n + 1) := by\n    have hŒ¥ : ‚àÄ n : ‚Ñï, Œ¥ < Œ¥ + 1 / (n + 1) := fun n =>\n      lt_add_of_le_of_pos le_rfl Nat.one_div_pos_of_nat\n    have h := fun n => exists_lt_of_ciInf_lt (hŒ¥ n)\n    let w : ‚Ñï ‚Üí K := fun n => Classical.choose (h n)\n    exact ‚ü®w, fun n => Classical.choose_spec (h n)‚ü©\n  rcases exists_seq with ‚ü®w, hw‚ü©\n  have norm_tendsto : Tendsto (fun n => ‚Äñu - w n‚Äñ) atTop (ùìù Œ¥) := by\n    have h : Tendsto (fun _ : ‚Ñï => Œ¥) atTop (ùìù Œ¥) := tendsto_const_nhds\n    have h' : Tendsto (fun n : ‚Ñï => Œ¥ + 1 / (n + 1)) atTop (ùìù Œ¥) := by\n      convert h.add tendsto_one_div_add_atTop_nhds_zero_nat\n      simp only [add_zero]\n    exact tendsto_of_tendsto_of_tendsto_of_le_of_le h h' (fun x => Œ¥_le _) fun x => le_of_lt (hw _)\n  -- Step 2: Prove that the sequence `w : ‚Ñï ‚Üí K` is a Cauchy sequence\n  have seq_is_cauchy : CauchySeq fun n => (w n : F) := by\n    rw [cauchySeq_iff_le_tendsto_0]\n    -- splits into three goals\n    let b := fun n : ‚Ñï => 8 * Œ¥ * (1 / (n + 1)) + 4 * (1 / (n + 1)) * (1 / (n + 1))\n    use fun n => ‚àö(b n)\n    constructor\n    -- first goal :  `‚àÄ (n : ‚Ñï), 0 ‚â§ ‚àö(b n)`\n    ¬∑ intro n\n      exact sqrt_nonneg _\n    constructor\n    -- second goal : `‚àÄ (n m N : ‚Ñï), N ‚â§ n ‚Üí N ‚â§ m ‚Üí dist ‚Üë(w n) ‚Üë(w m) ‚â§ ‚àö(b N)`\n    ¬∑ intro p q N hp hq\n      let wp := (w p : F)\n      let wq := (w q : F)\n      let a := u - wq\n      let b := u - wp\n      let half := 1 / (2 : ‚Ñù)\n      let div := 1 / ((N : ‚Ñù) + 1)\n      have :\n        4 * ‚Äñu - half ‚Ä¢ (wq + wp)‚Äñ * ‚Äñu - half ‚Ä¢ (wq + wp)‚Äñ + ‚Äñwp - wq‚Äñ * ‚Äñwp - wq‚Äñ =\n          2 * (‚Äña‚Äñ * ‚Äña‚Äñ + ‚Äñb‚Äñ * ‚Äñb‚Äñ) :=\n        calc\n          4 * ‚Äñu - half ‚Ä¢ (wq + wp)‚Äñ * ‚Äñu - half ‚Ä¢ (wq + wp)‚Äñ + ‚Äñwp - wq‚Äñ * ‚Äñwp - wq‚Äñ =\n              2 * ‚Äñu - half ‚Ä¢ (wq + wp)‚Äñ * (2 * ‚Äñu - half ‚Ä¢ (wq + wp)‚Äñ) + ‚Äñwp - wq‚Äñ * ‚Äñwp - wq‚Äñ :=\n            by ring\n          _ =\n              absR (2 : ‚Ñù) * ‚Äñu - half ‚Ä¢ (wq + wp)‚Äñ * (absR (2 : ‚Ñù) * ‚Äñu - half ‚Ä¢ (wq + wp)‚Äñ) +\n                ‚Äñwp - wq‚Äñ * ‚Äñwp - wq‚Äñ := by\n            rw [_root_.abs_of_nonneg]\n            exact zero_le_two\n          _ =\n              ‚Äñ(2 : ‚Ñù) ‚Ä¢ (u - half ‚Ä¢ (wq + wp))‚Äñ * ‚Äñ(2 : ‚Ñù) ‚Ä¢ (u - half ‚Ä¢ (wq + wp))‚Äñ +\n                ‚Äñwp - wq‚Äñ * ‚Äñwp - wq‚Äñ := by simp [norm_smul]\n          _ = ‚Äña + b‚Äñ * ‚Äña + b‚Äñ + ‚Äña - b‚Äñ * ‚Äña - b‚Äñ := by\n            rw [smul_sub, smul_smul, mul_one_div_cancel (_root_.two_ne_zero : (2 : ‚Ñù) ‚â† 0), ‚Üê\n              one_add_one_eq_two, add_smul]\n            simp only [one_smul]\n            have eq‚ÇÅ : wp - wq = a - b := (sub_sub_sub_cancel_left _ _ _).symm\n            have eq‚ÇÇ : u + u - (wq + wp) = a + b := by\n              show u + u - (wq + wp) = u - wq + (u - wp)\n              abel\n            rw [eq‚ÇÅ, eq‚ÇÇ]\n          _ = 2 * (‚Äña‚Äñ * ‚Äña‚Äñ + ‚Äñb‚Äñ * ‚Äñb‚Äñ) := parallelogram_law_with_norm ‚Ñù _ _\n      have eq : Œ¥ ‚â§ ‚Äñu - half ‚Ä¢ (wq + wp)‚Äñ := by\n        rw [smul_add]\n        apply Œ¥_le'\n        apply h‚ÇÇ\n        repeat' exact Subtype.mem _\n        repeat' exact le_of_lt one_half_pos\n        exact add_halves 1\n      have eq‚ÇÅ : 4 * Œ¥ * Œ¥ ‚â§ 4 * ‚Äñu - half ‚Ä¢ (wq + wp)‚Äñ * ‚Äñu - half ‚Ä¢ (wq + wp)‚Äñ := by\n        simp_rw [mul_assoc]\n        gcongr\n      have eq‚ÇÇ : ‚Äña‚Äñ ‚â§ Œ¥ + div :=\n          le_trans (le_of_lt <| hw q) (add_le_add_left (Nat.one_div_le_one_div hq) _)\n      have eq‚ÇÇ' : ‚Äñb‚Äñ ‚â§ Œ¥ + div :=\n          le_trans (le_of_lt <| hw p) (add_le_add_left (Nat.one_div_le_one_div hp) _)\n      rw [dist_eq_norm]\n      apply nonneg_le_nonneg_of_sq_le_sq\n      ¬∑ exact sqrt_nonneg _\n      rw [mul_self_sqrt]\n      ¬∑ calc\n        ‚Äñwp - wq‚Äñ * ‚Äñwp - wq‚Äñ =\n            2 * (‚Äña‚Äñ * ‚Äña‚Äñ + ‚Äñb‚Äñ * ‚Äñb‚Äñ) - 4 * ‚Äñu - half ‚Ä¢ (wq + wp)‚Äñ * ‚Äñu - half ‚Ä¢ (wq + wp)‚Äñ := by\n          simp [‚Üê this]\n        _ ‚â§ 2 * (‚Äña‚Äñ * ‚Äña‚Äñ + ‚Äñb‚Äñ * ‚Äñb‚Äñ) - 4 * Œ¥ * Œ¥ := by gcongr\n        _ ‚â§ 2 * ((Œ¥ + div) * (Œ¥ + div) + (Œ¥ + div) * (Œ¥ + div)) - 4 * Œ¥ * Œ¥ := by gcongr\n        _ = 8 * Œ¥ * div + 4 * div * div := by ring\n      positivity\n    -- third goal : `Tendsto (fun (n : ‚Ñï) => ‚àö(b n)) atTop (ùìù 0)`\n    suffices Tendsto (fun x ‚Ü¶ ‚àö(8 * Œ¥ * x + 4 * x * x) : ‚Ñù ‚Üí ‚Ñù) (ùìù 0) (ùìù 0)\n      from this.comp tendsto_one_div_add_atTop_nhds_zero_nat\n    exact Continuous.tendsto' (by fun_prop) _ _ (by simp)\n  -- Step 3: By completeness of `K`, let `w : ‚Ñï ‚Üí K` converge to some `v : K`.\n  -- Prove that it satisfies all requirements.\n  rcases cauchySeq_tendsto_of_isComplete h‚ÇÅ (fun n => Subtype.mem _) seq_is_cauchy with\n    ‚ü®v, hv, w_tendsto‚ü©\n  use v\n  use hv\n  have h_cont : Continuous fun v => ‚Äñu - v‚Äñ :=\n    Continuous.comp continuous_norm (Continuous.sub continuous_const continuous_id)\n  have : Tendsto (fun n => ‚Äñu - w n‚Äñ) atTop (ùìù ‚Äñu - v‚Äñ) := by\n    convert Tendsto.comp h_cont.continuousAt w_tendsto\n  exact tendsto_nhds_unique this norm_tendsto\n\n"}
{"name":"norm_eq_iInf_iff_real_inner_le_zero","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"F : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : InnerProductSpace Real F\nK : Set F\nh : Convex Real K\nu v : F\nhv : Membership.mem K v\n‚ä¢ Iff (Eq (Norm.norm (HSub.hSub u v)) (iInf fun w => Norm.norm (HSub.hSub u ‚Üëw))) (‚àÄ (w : F), Membership.mem K w ‚Üí LE.le (Inner.inner (HSub.hSub u v) (HSub.hSub w v)) 0)","decl":"/-- Characterization of minimizers for the projection on a convex set in a real inner product\nspace. -/\ntheorem norm_eq_iInf_iff_real_inner_le_zero {K : Set F} (h : Convex ‚Ñù K) {u : F} {v : F}\n    (hv : v ‚àà K) : (‚Äñu - v‚Äñ = ‚®Ö w : K, ‚Äñu - w‚Äñ) ‚Üî ‚àÄ w ‚àà K, ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0 := by\n  letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©\n  constructor\n  ¬∑ intro eq w hw\n    let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ\n    let p := ‚ü™u - v, w - v‚ü´_‚Ñù\n    let q := ‚Äñw - v‚Äñ ^ 2\n    have Œ¥_le (w : K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := ciInf_le ‚ü®0, fun _ ‚ü®_, h‚ü© => h ‚ñ∏ norm_nonneg _‚ü© _\n    have Œ¥_le' (w) (hw : w ‚àà K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := Œ¥_le ‚ü®w, hw‚ü©\n    have (Œ∏ : ‚Ñù) (hŒ∏‚ÇÅ : 0 < Œ∏) (hŒ∏‚ÇÇ : Œ∏ ‚â§ 1) : 2 * p ‚â§ Œ∏ * q := by\n      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 :=\n        calc ‚Äñu - v‚Äñ ^ 2\n          _ ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by\n            simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)\n            rw [eq]; apply Œ¥_le'\n            apply h hw hv\n            exacts [le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel _ _]\n          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by\n            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by\n              rw [smul_sub, sub_smul, one_smul]\n              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]\n            rw [this]\n          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 := by\n            rw [@norm_sub_sq ‚Ñù, inner_smul_right, norm_smul]\n            simp only [sq]\n            show\n              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * (Œ∏ * inner (u - v) (w - v)) +\n                absR Œ∏ * ‚Äñw - v‚Äñ * (absR Œ∏ * ‚Äñw - v‚Äñ) =\n              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)\n            rw [abs_of_pos hŒ∏‚ÇÅ]; ring\n      have eq‚ÇÅ :\n        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =\n          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by\n        abel\n      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this\n      have eq‚ÇÇ :\n        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) =\n          Œ∏ * (Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * inner (u - v) (w - v)) := by ring\n      rw [eq‚ÇÇ] at this\n      exact le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hŒ∏‚ÇÅ)\n    by_cases hq : q = 0\n    ¬∑ rw [hq] at this\n      have : p ‚â§ 0 := by\n        have := this (1 : ‚Ñù) (by norm_num) (by norm_num)\n        linarith\n      exact this\n    ¬∑ have q_pos : 0 < q := lt_of_le_of_ne (sq_nonneg _) fun h ‚Ü¶ hq h.symm\n      by_contra hp\n      rw [not_le] at hp\n      let Œ∏ := min (1 : ‚Ñù) (p / q)\n      have eq‚ÇÅ : Œ∏ * q ‚â§ p :=\n        calc\n          Œ∏ * q ‚â§ p / q * q := mul_le_mul_of_nonneg_right (min_le_right _ _) (sq_nonneg _)\n          _ = p := div_mul_cancel‚ÇÄ _ hq\n      have : 2 * p ‚â§ p :=\n        calc\n          2 * p ‚â§ Œ∏ * q := by\n            exact this Œ∏ (lt_min (by norm_num) (div_pos hp q_pos)) (by norm_num [Œ∏])\n          _ ‚â§ p := eq‚ÇÅ\n      linarith\n  ¬∑ intro h\n    apply le_antisymm\n    ¬∑ apply le_ciInf\n      intro w\n      apply nonneg_le_nonneg_of_sq_le_sq (norm_nonneg _)\n      have := h w w.2\n      calc\n        ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ ‚â§ ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * inner (u - v) ((w : F) - v) := by linarith\n        _ ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * inner (u - v) ((w : F) - v) + ‚Äñ(w : F) - v‚Äñ ^ 2 := by\n          rw [sq]\n          refine le_add_of_nonneg_right ?_\n          exact sq_nonneg _\n        _ = ‚Äñu - v - (w - v)‚Äñ ^ 2 := (@norm_sub_sq ‚Ñù _ _ _ _ _ _).symm\n        _ = ‚Äñu - w‚Äñ * ‚Äñu - w‚Äñ := by\n          have : u - v - (w - v) = u - w := by abel\n          rw [this, sq]\n    ¬∑ show ‚®Ö w : K, ‚Äñu - w‚Äñ ‚â§ (fun w : K => ‚Äñu - w‚Äñ) ‚ü®v, hv‚ü©\n      apply ciInf_le\n      use 0\n      rintro y ‚ü®z, rfl‚ü©\n      exact norm_nonneg _\n\n"}
{"name":"exists_norm_eq_iInf_of_complete_subspace","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nK : Submodule ùïú E\nh : IsComplete ‚ÜëK\nu : E\n‚ä¢ Exists fun v => And (Membership.mem K v) (Eq (Norm.norm (HSub.hSub u v)) (iInf fun w => Norm.norm (HSub.hSub u ‚Üëw)))","decl":"/-- Existence of projections on complete subspaces.\nLet `u` be a point in an inner product space, and let `K` be a nonempty complete subspace.\nThen there exists a (unique) `v` in `K` that minimizes the distance `‚Äñu - v‚Äñ` to `u`.\nThis point `v` is usually called the orthogonal projection of `u` onto `K`.\n-/\ntheorem exists_norm_eq_iInf_of_complete_subspace (h : IsComplete (‚ÜëK : Set E)) :\n    ‚àÄ u : E, ‚àÉ v ‚àà K, ‚Äñu - v‚Äñ = ‚®Ö w : (K : Set E), ‚Äñu - w‚Äñ := by\n  letI : InnerProductSpace ‚Ñù E := InnerProductSpace.rclikeToReal ùïú E\n  letI : Module ‚Ñù E := RestrictScalars.module ‚Ñù ùïú E\n  let K' : Submodule ‚Ñù E := Submodule.restrictScalars ‚Ñù K\n  exact exists_norm_eq_iInf_of_complete_convex ‚ü®0, K'.zero_mem‚ü© h K'.convex\n\n"}
{"name":"norm_eq_iInf_iff_real_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"F : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : InnerProductSpace Real F\nK : Submodule Real F\nu v : F\nhv : Membership.mem K v\n‚ä¢ Iff (Eq (Norm.norm (HSub.hSub u v)) (iInf fun w => Norm.norm (HSub.hSub u ‚Üëw))) (‚àÄ (w : F), Membership.mem K w ‚Üí Eq (Inner.inner (HSub.hSub u v) w) 0)","decl":"/-- Characterization of minimizers in the projection on a subspace, in the real case.\nLet `u` be a point in a real inner product space, and let `K` be a nonempty subspace.\nThen point `v` minimizes the distance `‚Äñu - v‚Äñ` over points in `K` if and only if\nfor all `w ‚àà K`, `‚ü™u - v, w‚ü´ = 0` (i.e., `u - v` is orthogonal to the subspace `K`).\nThis is superseded by `norm_eq_iInf_iff_inner_eq_zero` that gives the same conclusion over\nany `RCLike` field.\n-/\ntheorem norm_eq_iInf_iff_real_inner_eq_zero (K : Submodule ‚Ñù F) {u : F} {v : F} (hv : v ‚àà K) :\n    (‚Äñu - v‚Äñ = ‚®Ö w : (‚ÜëK : Set F), ‚Äñu - w‚Äñ) ‚Üî ‚àÄ w ‚àà K, ‚ü™u - v, w‚ü´_‚Ñù = 0 :=\n  Iff.intro\n    (by\n      intro h\n      have h : ‚àÄ w ‚àà K, ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0 := by\n        rwa [norm_eq_iInf_iff_real_inner_le_zero] at h\n        exacts [K.convex, hv]\n      intro w hw\n      have le : ‚ü™u - v, w‚ü´_‚Ñù ‚â§ 0 := by\n        let w' := w + v\n        have : w' ‚àà K := Submodule.add_mem _ hw hv\n        have h‚ÇÅ := h w' this\n        have h‚ÇÇ : w' - v = w := by\n          simp only [w', add_neg_cancel_right, sub_eq_add_neg]\n        rw [h‚ÇÇ] at h‚ÇÅ\n        exact h‚ÇÅ\n      have ge : ‚ü™u - v, w‚ü´_‚Ñù ‚â• 0 := by\n        let w'' := -w + v\n        have : w'' ‚àà K := Submodule.add_mem _ (Submodule.neg_mem _ hw) hv\n        have h‚ÇÅ := h w'' this\n        have h‚ÇÇ : w'' - v = -w := by\n          simp only [w'', neg_inj, add_neg_cancel_right, sub_eq_add_neg]\n        rw [h‚ÇÇ, inner_neg_right] at h‚ÇÅ\n        linarith\n      exact le_antisymm le ge)\n    (by\n      intro h\n      have : ‚àÄ w ‚àà K, ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0 := by\n        intro w hw\n        let w' := w - v\n        have : w' ‚àà K := Submodule.sub_mem _ hw hv\n        have h‚ÇÅ := h w' this\n        exact le_of_eq h‚ÇÅ\n      rwa [norm_eq_iInf_iff_real_inner_le_zero]\n      exacts [Submodule.convex _, hv])\n\n"}
{"name":"norm_eq_iInf_iff_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nK : Submodule ùïú E\nu v : E\nhv : Membership.mem K v\n‚ä¢ Iff (Eq (Norm.norm (HSub.hSub u v)) (iInf fun w => Norm.norm (HSub.hSub u ‚Üëw))) (‚àÄ (w : E), Membership.mem K w ‚Üí Eq (Inner.inner (HSub.hSub u v) w) 0)","decl":"/-- Characterization of minimizers in the projection on a subspace.\nLet `u` be a point in an inner product space, and let `K` be a nonempty subspace.\nThen point `v` minimizes the distance `‚Äñu - v‚Äñ` over points in `K` if and only if\nfor all `w ‚àà K`, `‚ü™u - v, w‚ü´ = 0` (i.e., `u - v` is orthogonal to the subspace `K`)\n-/\ntheorem norm_eq_iInf_iff_inner_eq_zero {u : E} {v : E} (hv : v ‚àà K) :\n    (‚Äñu - v‚Äñ = ‚®Ö w : K, ‚Äñu - w‚Äñ) ‚Üî ‚àÄ w ‚àà K, ‚ü™u - v, w‚ü´ = 0 := by\n  letI : InnerProductSpace ‚Ñù E := InnerProductSpace.rclikeToReal ùïú E\n  letI : Module ‚Ñù E := RestrictScalars.module ‚Ñù ùïú E\n  let K' : Submodule ‚Ñù E := K.restrictScalars ‚Ñù\n  constructor\n  ¬∑ intro H\n    have A : ‚àÄ w ‚àà K, re ‚ü™u - v, w‚ü´ = 0 := (norm_eq_iInf_iff_real_inner_eq_zero K' hv).1 H\n    intro w hw\n    apply RCLike.ext\n    ¬∑ simp [A w hw]\n    ¬∑ symm\n      calc\n        im (0 : ùïú) = 0 := im.map_zero\n        _ = re ‚ü™u - v, (-I : ùïú) ‚Ä¢ w‚ü´ := (A _ (K.smul_mem (-I) hw)).symm\n        _ = re (-I * ‚ü™u - v, w‚ü´) := by rw [inner_smul_right]\n        _ = im ‚ü™u - v, w‚ü´ := by simp\n  ¬∑ intro H\n    have : ‚àÄ w ‚àà K', ‚ü™u - v, w‚ü´_‚Ñù = 0 := by\n      intro w hw\n      rw [real_inner_eq_re_inner, H w hw]\n      exact zero_re'\n    exact (norm_eq_iInf_iff_real_inner_eq_zero K' hv).2 this\n\n"}
{"name":"HasOrthogonalProjection.exists_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nK : Submodule ùïú E\nself : HasOrthogonalProjection K\nv : E\n‚ä¢ Exists fun w => And (Membership.mem K w) (Membership.mem K.orthogonal (HSub.hSub v w))","decl":"/-- A subspace `K : Submodule ùïú E` has an orthogonal projection if every vector `v : E` admits an\northogonal projection to `K`. -/\nclass HasOrthogonalProjection (K : Submodule ùïú E) : Prop where\n  exists_orthogonal (v : E) : ‚àÉ w ‚àà K, v - w ‚àà K·óÆ\n\n"}
{"name":"HasOrthogonalProjection.ofCompleteSpace","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : CompleteSpace (Subtype fun x => Membership.mem K x)\n‚ä¢ HasOrthogonalProjection K","decl":"instance (priority := 100) HasOrthogonalProjection.ofCompleteSpace [CompleteSpace K] :\n    HasOrthogonalProjection K where\n  exists_orthogonal v := by\n    rcases exists_norm_eq_iInf_of_complete_subspace K (completeSpace_coe_iff_isComplete.mp ‚Äπ_‚Ä∫) v\n      with ‚ü®w, hwK, hw‚ü©\n    refine ‚ü®w, hwK, (K.mem_orthogonal' _).2 ?_‚ü©\n    rwa [‚Üê norm_eq_iInf_iff_inner_eq_zero K hwK]\n\n"}
{"name":"instHasOrthogonalProjectionOrthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\n‚ä¢ HasOrthogonalProjection K.orthogonal","decl":"instance [HasOrthogonalProjection K] : HasOrthogonalProjection K·óÆ where\n  exists_orthogonal v := by\n    rcases HasOrthogonalProjection.exists_orthogonal (K := K) v with ‚ü®w, hwK, hw‚ü©\n    refine ‚ü®_, hw, ?_‚ü©\n    rw [sub_sub_cancel]\n    exact K.le_orthogonal_orthogonal hwK\n\n"}
{"name":"HasOrthogonalProjection.map_linearIsometryEquiv","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Åµ : RCLike ùïú\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù¬≤ : HasOrthogonalProjection K\nE' : Type u_4\ninst‚úù¬π : NormedAddCommGroup E'\ninst‚úù : InnerProductSpace ùïú E'\nf : LinearIsometryEquiv (RingHom.id ùïú) E E'\n‚ä¢ HasOrthogonalProjection (Submodule.map (‚Üëf.toLinearEquiv) K)","decl":"instance HasOrthogonalProjection.map_linearIsometryEquiv [HasOrthogonalProjection K]\n    {E' : Type*} [NormedAddCommGroup E'] [InnerProductSpace ùïú E'] (f : E ‚âÉ‚Çó·µ¢[ùïú] E') :\n    HasOrthogonalProjection (K.map (f.toLinearEquiv : E ‚Üí‚Çó[ùïú] E')) where\n  exists_orthogonal v := by\n    rcases HasOrthogonalProjection.exists_orthogonal (K := K) (f.symm v) with ‚ü®w, hwK, hw‚ü©\n    refine ‚ü®f w, Submodule.mem_map_of_mem hwK, Set.forall_mem_image.2 fun u hu ‚Ü¶ ?_‚ü©\n    erw [‚Üê f.symm.inner_map_map, f.symm_apply_apply, map_sub, f.symm_apply_apply, hw u hu]\n\n"}
{"name":"HasOrthogonalProjection.map_linearIsometryEquiv'","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Åµ : RCLike ùïú\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù¬≤ : HasOrthogonalProjection K\nE' : Type u_4\ninst‚úù¬π : NormedAddCommGroup E'\ninst‚úù : InnerProductSpace ùïú E'\nf : LinearIsometryEquiv (RingHom.id ùïú) E E'\n‚ä¢ HasOrthogonalProjection (Submodule.map f.toLinearIsometry K)","decl":"instance HasOrthogonalProjection.map_linearIsometryEquiv' [HasOrthogonalProjection K]\n    {E' : Type*} [NormedAddCommGroup E'] [InnerProductSpace ùïú E'] (f : E ‚âÉ‚Çó·µ¢[ùïú] E') :\n    HasOrthogonalProjection (K.map f.toLinearIsometry) :=\n  HasOrthogonalProjection.map_linearIsometryEquiv K f\n\n"}
{"name":"instHasOrthogonalProjectionTopSubmodule","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\n‚ä¢ HasOrthogonalProjection Top.top","decl":"instance : HasOrthogonalProjection (‚ä§ : Submodule ùïú E) := ‚ü®fun v ‚Ü¶ ‚ü®v, trivial, by simp‚ü©‚ü©\n\n"}
{"name":"orthogonalProjectionFn_mem","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nv : E\n‚ä¢ Membership.mem K (orthogonalProjectionFn K v)","decl":"/-- The unbundled orthogonal projection is in the given subspace.\nThis lemma is only intended for use in setting up the bundled version\nand should not be used once that is defined. -/\ntheorem orthogonalProjectionFn_mem (v : E) : orthogonalProjectionFn K v ‚àà K :=\n  (HasOrthogonalProjection.exists_orthogonal (K := K) v).choose_spec.left\n\n"}
{"name":"orthogonalProjectionFn_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nv w : E\na‚úù : Membership.mem K w\n‚ä¢ Eq (Inner.inner (HSub.hSub v (orthogonalProjectionFn K v)) w) 0","decl":"/-- The characterization of the unbundled orthogonal projection.  This\nlemma is only intended for use in setting up the bundled version\nand should not be used once that is defined. -/\ntheorem orthogonalProjectionFn_inner_eq_zero (v : E) :\n    ‚àÄ w ‚àà K, ‚ü™v - orthogonalProjectionFn K v, w‚ü´ = 0 :=\n  (K.mem_orthogonal' _).1 (HasOrthogonalProjection.exists_orthogonal (K := K) v).choose_spec.right\n\n"}
{"name":"eq_orthogonalProjectionFn_of_mem_of_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nu v : E\nhvm : Membership.mem K v\nhvo : ‚àÄ (w : E), Membership.mem K w ‚Üí Eq (Inner.inner (HSub.hSub u v) w) 0\n‚ä¢ Eq (orthogonalProjectionFn K u) v","decl":"/-- The unbundled orthogonal projection is the unique point in `K`\nwith the orthogonality property.  This lemma is only intended for use\nin setting up the bundled version and should not be used once that is\ndefined. -/\ntheorem eq_orthogonalProjectionFn_of_mem_of_inner_eq_zero {u v : E} (hvm : v ‚àà K)\n    (hvo : ‚àÄ w ‚àà K, ‚ü™u - v, w‚ü´ = 0) : orthogonalProjectionFn K u = v := by\n  rw [‚Üê sub_eq_zero, ‚Üê @inner_self_eq_zero ùïú]\n  have hvs : orthogonalProjectionFn K u - v ‚àà K :=\n    Submodule.sub_mem K (orthogonalProjectionFn_mem u) hvm\n  have huo : ‚ü™u - orthogonalProjectionFn K u, orthogonalProjectionFn K u - v‚ü´ = 0 :=\n    orthogonalProjectionFn_inner_eq_zero u _ hvs\n  have huv : ‚ü™u - v, orthogonalProjectionFn K u - v‚ü´ = 0 := hvo _ hvs\n  have houv : ‚ü™u - v - (u - orthogonalProjectionFn K u), orthogonalProjectionFn K u - v‚ü´ = 0 := by\n    rw [inner_sub_left, huo, huv, sub_zero]\n  rwa [sub_sub_sub_cancel_left] at houv\n\n"}
{"name":"orthogonalProjectionFn_norm_sq","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nv : E\n‚ä¢ Eq (HMul.hMul (Norm.norm v) (Norm.norm v)) (HAdd.hAdd (HMul.hMul (Norm.norm (HSub.hSub v (orthogonalProjectionFn K v))) (Norm.norm (HSub.hSub v (orthogonalProjectionFn K v)))) (HMul.hMul (Norm.norm (orthogonalProjectionFn K v)) (Norm.norm (orthogonalProjectionFn K v))))","decl":"theorem orthogonalProjectionFn_norm_sq (v : E) :\n    ‚Äñv‚Äñ * ‚Äñv‚Äñ =\n      ‚Äñv - orthogonalProjectionFn K v‚Äñ * ‚Äñv - orthogonalProjectionFn K v‚Äñ +\n        ‚ÄñorthogonalProjectionFn K v‚Äñ * ‚ÄñorthogonalProjectionFn K v‚Äñ := by\n  set p := orthogonalProjectionFn K v\n  have h' : ‚ü™v - p, p‚ü´ = 0 :=\n    orthogonalProjectionFn_inner_eq_zero _ _ (orthogonalProjectionFn_mem v)\n  convert norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero (v - p) p h' using 2 <;> simp\n\n"}
{"name":"orthogonalProjectionFn_eq","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nv : E\n‚ä¢ Eq (orthogonalProjectionFn K v) ‚Üë((orthogonalProjection K) v)","decl":"@[simp]\ntheorem orthogonalProjectionFn_eq (v : E) :\n    orthogonalProjectionFn K v = (orthogonalProjection K v : E) :=\n  rfl\n\n"}
{"name":"orthogonalProjection_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nv w : E\na‚úù : Membership.mem K w\n‚ä¢ Eq (Inner.inner (HSub.hSub v ‚Üë((orthogonalProjection K) v)) w) 0","decl":"/-- The characterization of the orthogonal projection. -/\n@[simp]\ntheorem orthogonalProjection_inner_eq_zero (v : E) :\n    ‚àÄ w ‚àà K, ‚ü™v - orthogonalProjection K v, w‚ü´ = 0 :=\n  orthogonalProjectionFn_inner_eq_zero v\n\n"}
{"name":"sub_orthogonalProjection_mem_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nv : E\n‚ä¢ Membership.mem K.orthogonal (HSub.hSub v ‚Üë((orthogonalProjection K) v))","decl":"/-- The difference of `v` from its orthogonal projection onto `K` is in `K·óÆ`. -/\n@[simp]\ntheorem sub_orthogonalProjection_mem_orthogonal (v : E) : v - orthogonalProjection K v ‚àà K·óÆ := by\n  intro w hw\n  rw [inner_eq_zero_symm]\n  exact orthogonalProjection_inner_eq_zero _ _ hw\n\n"}
{"name":"eq_orthogonalProjection_of_mem_of_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nu v : E\nhvm : Membership.mem K v\nhvo : ‚àÄ (w : E), Membership.mem K w ‚Üí Eq (Inner.inner (HSub.hSub u v) w) 0\n‚ä¢ Eq (‚Üë((orthogonalProjection K) u)) v","decl":"/-- The orthogonal projection is the unique point in `K` with the\northogonality property. -/\ntheorem eq_orthogonalProjection_of_mem_of_inner_eq_zero {u v : E} (hvm : v ‚àà K)\n    (hvo : ‚àÄ w ‚àà K, ‚ü™u - v, w‚ü´ = 0) : (orthogonalProjection K u : E) = v :=\n  eq_orthogonalProjectionFn_of_mem_of_inner_eq_zero hvm hvo\n\n"}
{"name":"eq_orthogonalProjection_of_mem_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nu v : E\nhv : Membership.mem K v\nhvo : Membership.mem K.orthogonal (HSub.hSub u v)\n‚ä¢ Eq (‚Üë((orthogonalProjection K) u)) v","decl":"/-- A point in `K` with the orthogonality property (here characterized in terms of `K·óÆ`) must be the\northogonal projection. -/\ntheorem eq_orthogonalProjection_of_mem_orthogonal {u v : E} (hv : v ‚àà K)\n    (hvo : u - v ‚àà K·óÆ) : (orthogonalProjection K u : E) = v :=\n  eq_orthogonalProjectionFn_of_mem_of_inner_eq_zero hv <| (Submodule.mem_orthogonal' _ _).1 hvo\n\n"}
{"name":"eq_orthogonalProjection_of_mem_orthogonal'","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nu v z : E\nhv : Membership.mem K v\nhz : Membership.mem K.orthogonal z\nhu : Eq u (HAdd.hAdd v z)\n‚ä¢ Eq (‚Üë((orthogonalProjection K) u)) v","decl":"/-- A point in `K` with the orthogonality property (here characterized in terms of `K·óÆ`) must be the\northogonal projection. -/\ntheorem eq_orthogonalProjection_of_mem_orthogonal' {u v z : E}\n    (hv : v ‚àà K) (hz : z ‚àà K·óÆ) (hu : u = v + z) : (orthogonalProjection K u : E) = v :=\n  eq_orthogonalProjection_of_mem_orthogonal hv (by simpa [hu] )\n\n"}
{"name":"orthogonalProjection_orthogonal_val","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nu : E\n‚ä¢ Eq (‚Üë((orthogonalProjection K.orthogonal) u)) (HSub.hSub u ‚Üë((orthogonalProjection K) u))","decl":"@[simp]\ntheorem orthogonalProjection_orthogonal_val (u : E) :\n    (orthogonalProjection K·óÆ u : E) = u - orthogonalProjection K u :=\n  eq_orthogonalProjection_of_mem_orthogonal' (sub_orthogonalProjection_mem_orthogonal _)\n    (K.le_orthogonal_orthogonal (orthogonalProjection K u).2) <| by simp\n\n"}
{"name":"orthogonalProjection_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nu : E\n‚ä¢ Eq ((orthogonalProjection K.orthogonal) u) ‚ü®HSub.hSub u ‚Üë((orthogonalProjection K) u), ‚ãØ‚ü©","decl":"theorem orthogonalProjection_orthogonal (u : E) :\n    orthogonalProjection K·óÆ u =\n      ‚ü®u - orthogonalProjection K u, sub_orthogonalProjection_mem_orthogonal _‚ü© :=\n  Subtype.eq <| orthogonalProjection_orthogonal_val _\n\n"}
{"name":"orthogonalProjection_minimal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nU : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection U\ny : E\n‚ä¢ Eq (Norm.norm (HSub.hSub y ‚Üë((orthogonalProjection U) y))) (iInf fun x => Norm.norm (HSub.hSub y ‚Üëx))","decl":"/-- The orthogonal projection of `y` on `U` minimizes the distance `‚Äñy - x‚Äñ` for `x ‚àà U`. -/\ntheorem orthogonalProjection_minimal {U : Submodule ùïú E} [HasOrthogonalProjection U] (y : E) :\n    ‚Äñy - orthogonalProjection U y‚Äñ = ‚®Ö x : U, ‚Äñy - x‚Äñ := by\n  rw [norm_eq_iInf_iff_inner_eq_zero _ (Submodule.coe_mem _)]\n  exact orthogonalProjection_inner_eq_zero _\n\n"}
{"name":"eq_orthogonalProjection_of_eq_submodule","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : RCLike ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù¬π : HasOrthogonalProjection K\nK' : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K'\nh : Eq K K'\nu : E\n‚ä¢ Eq ‚Üë((orthogonalProjection K) u) ‚Üë((orthogonalProjection K') u)","decl":"/-- The orthogonal projections onto equal subspaces are coerced back to the same point in `E`. -/\ntheorem eq_orthogonalProjection_of_eq_submodule {K' : Submodule ùïú E} [HasOrthogonalProjection K']\n    (h : K = K') (u : E) : (orthogonalProjection K u : E) = (orthogonalProjection K' u : E) := by\n  subst h; rfl\n\n"}
{"name":"orthogonalProjection_mem_subspace_eq_self","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nv : Subtype fun x => Membership.mem K x\n‚ä¢ Eq ((orthogonalProjection K) ‚Üëv) v","decl":"/-- The orthogonal projection sends elements of `K` to themselves. -/\n@[simp]\ntheorem orthogonalProjection_mem_subspace_eq_self (v : K) : orthogonalProjection K v = v := by\n  ext\n  apply eq_orthogonalProjection_of_mem_of_inner_eq_zero <;> simp\n\n"}
{"name":"orthogonalProjection_eq_self_iff","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nv : E\n‚ä¢ Iff (Eq (‚Üë((orthogonalProjection K) v)) v) (Membership.mem K v)","decl":"/-- A point equals its orthogonal projection if and only if it lies in the subspace. -/\ntheorem orthogonalProjection_eq_self_iff {v : E} : (orthogonalProjection K v : E) = v ‚Üî v ‚àà K := by\n  refine ‚ü®fun h => ?_, fun h => eq_orthogonalProjection_of_mem_of_inner_eq_zero h ?_‚ü©\n  ¬∑ rw [‚Üê h]\n    simp\n  ¬∑ simp\n\n"}
{"name":"orthogonalProjection_eq_zero_iff","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nv : E\n‚ä¢ Iff (Eq ((orthogonalProjection K) v) 0) (Membership.mem K.orthogonal v)","decl":"@[simp]\ntheorem orthogonalProjection_eq_zero_iff {v : E} : orthogonalProjection K v = 0 ‚Üî v ‚àà K·óÆ := by\n  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ Subtype.eq <| eq_orthogonalProjection_of_mem_orthogonal\n    (zero_mem _) ?_‚ü©\n  ¬∑ simpa [h] using sub_orthogonalProjection_mem_orthogonal (K := K) v\n  ¬∑ simpa\n\n"}
{"name":"ker_orthogonalProjection","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\n‚ä¢ Eq (LinearMap.ker (orthogonalProjection K)) K.orthogonal","decl":"@[simp]\ntheorem ker_orthogonalProjection : LinearMap.ker (orthogonalProjection K) = K·óÆ := by\n  ext; exact orthogonalProjection_eq_zero_iff\n\n"}
{"name":"LinearIsometry.map_orthogonalProjection","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å∂ : RCLike ùïú\nE : Type u_4\nE' : Type u_5\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedAddCommGroup E'\ninst‚úù¬≥ : InnerProductSpace ùïú E\ninst‚úù¬≤ : InnerProductSpace ùïú E'\nf : LinearIsometry (RingHom.id ùïú) E E'\np : Submodule ùïú E\ninst‚úù¬π : HasOrthogonalProjection p\ninst‚úù : HasOrthogonalProjection (Submodule.map f.toLinearMap p)\nx : E\n‚ä¢ Eq (f ‚Üë((orthogonalProjection p) x)) ‚Üë((orthogonalProjection (Submodule.map f.toLinearMap p)) (f x))","decl":"theorem LinearIsometry.map_orthogonalProjection {E E' : Type*} [NormedAddCommGroup E]\n    [NormedAddCommGroup E'] [InnerProductSpace ùïú E] [InnerProductSpace ùïú E'] (f : E ‚Üí‚Çó·µ¢[ùïú] E')\n    (p : Submodule ùïú E) [HasOrthogonalProjection p] [HasOrthogonalProjection (p.map f.toLinearMap)]\n    (x : E) : f (orthogonalProjection p x) = orthogonalProjection (p.map f.toLinearMap) (f x) := by\n  refine (eq_orthogonalProjection_of_mem_of_inner_eq_zero ?_ fun y hy => ?_).symm\n  ¬∑ refine Submodule.apply_coe_mem_map _ _\n  rcases hy with ‚ü®x', hx', rfl : f x' = y‚ü©\n  rw [‚Üê f.map_sub, f.inner_map_map, orthogonalProjection_inner_eq_zero x x' hx']\n\n"}
{"name":"LinearIsometry.map_orthogonalProjection'","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å∂ : RCLike ùïú\nE : Type u_4\nE' : Type u_5\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedAddCommGroup E'\ninst‚úù¬≥ : InnerProductSpace ùïú E\ninst‚úù¬≤ : InnerProductSpace ùïú E'\nf : LinearIsometry (RingHom.id ùïú) E E'\np : Submodule ùïú E\ninst‚úù¬π : HasOrthogonalProjection p\ninst‚úù : HasOrthogonalProjection (Submodule.map f p)\nx : E\n‚ä¢ Eq (f ‚Üë((orthogonalProjection p) x)) ‚Üë((orthogonalProjection (Submodule.map f p)) (f x))","decl":"theorem LinearIsometry.map_orthogonalProjection' {E E' : Type*} [NormedAddCommGroup E]\n    [NormedAddCommGroup E'] [InnerProductSpace ùïú E] [InnerProductSpace ùïú E'] (f : E ‚Üí‚Çó·µ¢[ùïú] E')\n    (p : Submodule ùïú E) [HasOrthogonalProjection p] [HasOrthogonalProjection (p.map f)] (x : E) :\n    f (orthogonalProjection p x) = orthogonalProjection (p.map f) (f x) :=\n  have : HasOrthogonalProjection (p.map f.toLinearMap) := ‚Äπ_‚Ä∫\n  f.map_orthogonalProjection p x\n\n"}
{"name":"orthogonalProjection_map_apply","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\ninst‚úù‚Åµ : RCLike ùïú\nE : Type u_4\nE' : Type u_5\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedAddCommGroup E'\ninst‚úù¬≤ : InnerProductSpace ùïú E\ninst‚úù¬π : InnerProductSpace ùïú E'\nf : LinearIsometryEquiv (RingHom.id ùïú) E E'\np : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection p\nx : E'\n‚ä¢ Eq (‚Üë((orthogonalProjection (Submodule.map (‚Üëf.toLinearEquiv) p)) x)) (f ‚Üë((orthogonalProjection p) (f.symm x)))","decl":"/-- Orthogonal projection onto the `Submodule.map` of a subspace. -/\ntheorem orthogonalProjection_map_apply {E E' : Type*} [NormedAddCommGroup E]\n    [NormedAddCommGroup E'] [InnerProductSpace ùïú E] [InnerProductSpace ùïú E'] (f : E ‚âÉ‚Çó·µ¢[ùïú] E')\n    (p : Submodule ùïú E) [HasOrthogonalProjection p] (x : E') :\n    (orthogonalProjection (p.map (f.toLinearEquiv : E ‚Üí‚Çó[ùïú] E')) x : E') =\n      f (orthogonalProjection p (f.symm x)) := by\n  simpa only [f.coe_toLinearIsometry, f.apply_symm_apply] using\n    (f.toLinearIsometry.map_orthogonalProjection' p (f.symm x)).symm\n\n"}
{"name":"orthogonalProjection_bot","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\n‚ä¢ Eq (orthogonalProjection Bot.bot) 0","decl":"/-- The orthogonal projection onto the trivial submodule is the zero map. -/\n@[simp]\ntheorem orthogonalProjection_bot : orthogonalProjection (‚ä• : Submodule ùïú E) = 0 := by ext\n\n"}
{"name":"orthogonalProjection_norm_le","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\n‚ä¢ LE.le (Norm.norm (orthogonalProjection K)) 1","decl":"/-- The orthogonal projection has norm `‚â§ 1`. -/\ntheorem orthogonalProjection_norm_le : ‚ÄñorthogonalProjection K‚Äñ ‚â§ 1 :=\n  LinearMap.mkContinuous_norm_le _ (by norm_num) _\n\n"}
{"name":"smul_orthogonalProjection_singleton","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nv w : E\n‚ä¢ Eq (HSMul.hSMul ‚Üë(HPow.hPow (Norm.norm v) 2) ‚Üë((orthogonalProjection (Submodule.span ùïú (Singleton.singleton v))) w)) (HSMul.hSMul (Inner.inner v w) v)","decl":"theorem smul_orthogonalProjection_singleton {v : E} (w : E) :\n    ((‚Äñv‚Äñ ^ 2 : ‚Ñù) : ùïú) ‚Ä¢ (orthogonalProjection (ùïú ‚àô v) w : E) = ‚ü™v, w‚ü´ ‚Ä¢ v := by\n  suffices ((orthogonalProjection (ùïú ‚àô v) (((‚Äñv‚Äñ : ùïú) ^ 2) ‚Ä¢ w)) : E) = ‚ü™v, w‚ü´ ‚Ä¢ v by\n    simpa using this\n  apply eq_orthogonalProjection_of_mem_of_inner_eq_zero\n  ¬∑ rw [Submodule.mem_span_singleton]\n    use ‚ü™v, w‚ü´\n  ¬∑ rw [‚Üê Submodule.mem_orthogonal', Submodule.mem_orthogonal_singleton_iff_inner_left]\n    simp [inner_sub_left, inner_smul_left, inner_self_eq_norm_sq_to_K, mul_comm]\n\n"}
{"name":"orthogonalProjection_singleton","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nv w : E\n‚ä¢ Eq (‚Üë((orthogonalProjection (Submodule.span ùïú (Singleton.singleton v))) w)) (HSMul.hSMul (HDiv.hDiv (Inner.inner v w) ‚Üë(HPow.hPow (Norm.norm v) 2)) v)","decl":"/-- Formula for orthogonal projection onto a single vector. -/\ntheorem orthogonalProjection_singleton {v : E} (w : E) :\n    (orthogonalProjection (ùïú ‚àô v) w : E) = (‚ü™v, w‚ü´ / ((‚Äñv‚Äñ ^ 2 : ‚Ñù) : ùïú)) ‚Ä¢ v := by\n  by_cases hv : v = 0\n  ¬∑ rw [hv, eq_orthogonalProjection_of_eq_submodule (Submodule.span_zero_singleton ùïú)]\n    simp\n  have hv' : ‚Äñv‚Äñ ‚â† 0 := ne_of_gt (norm_pos_iff.mpr hv)\n  have key :\n    (((‚Äñv‚Äñ ^ 2 : ‚Ñù) : ùïú)‚Åª¬π * ((‚Äñv‚Äñ ^ 2 : ‚Ñù) : ùïú)) ‚Ä¢ ((orthogonalProjection (ùïú ‚àô v) w) : E) =\n      (((‚Äñv‚Äñ ^ 2 : ‚Ñù) : ùïú)‚Åª¬π * ‚ü™v, w‚ü´) ‚Ä¢ v := by\n    simp [mul_smul, smul_orthogonalProjection_singleton ùïú w, -map_pow]\n  convert key using 1 <;> field_simp [hv']\n\n"}
{"name":"orthogonalProjection_unit_singleton","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nv : E\nhv : Eq (Norm.norm v) 1\nw : E\n‚ä¢ Eq (‚Üë((orthogonalProjection (Submodule.span ùïú (Singleton.singleton v))) w)) (HSMul.hSMul (Inner.inner v w) v)","decl":"/-- Formula for orthogonal projection onto a single unit vector. -/\ntheorem orthogonalProjection_unit_singleton {v : E} (hv : ‚Äñv‚Äñ = 1) (w : E) :\n    (orthogonalProjection (ùïú ‚àô v) w : E) = ‚ü™v, w‚ü´ ‚Ä¢ v := by\n  rw [‚Üê smul_orthogonalProjection_singleton ùïú w]\n  simp [hv]\n\n"}
{"name":"reflection_apply","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\np : E\n‚ä¢ Eq ((reflection K) p) (HSub.hSub (HSMul.hSMul 2 ‚Üë((orthogonalProjection K) p)) p)","decl":"/-- The result of reflecting. -/\ntheorem reflection_apply (p : E) : reflection K p = 2 ‚Ä¢ (orthogonalProjection K p : E) - p :=\n  rfl\n\n"}
{"name":"reflection_symm","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\n‚ä¢ Eq (reflection K).symm (reflection K)","decl":"/-- Reflection is its own inverse. -/\n@[simp]\ntheorem reflection_symm : (reflection K).symm = reflection K :=\n  rfl\n\n"}
{"name":"reflection_inv","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\n‚ä¢ Eq (Inv.inv (reflection K)) (reflection K)","decl":"/-- Reflection is its own inverse. -/\n@[simp]\ntheorem reflection_inv : (reflection K)‚Åª¬π = reflection K :=\n  rfl\n\n"}
{"name":"reflection_reflection","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\np : E\n‚ä¢ Eq ((reflection K) ((reflection K) p)) p","decl":"/-- Reflecting twice in the same subspace. -/\n@[simp]\ntheorem reflection_reflection (p : E) : reflection K (reflection K p) = p :=\n  (reflection K).left_inv p\n\n"}
{"name":"reflection_involutive","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\n‚ä¢ Function.Involutive ‚áë(reflection K)","decl":"/-- Reflection is involutive. -/\ntheorem reflection_involutive : Function.Involutive (reflection K) :=\n  reflection_reflection K\n\n"}
{"name":"reflection_trans_reflection","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\n‚ä¢ Eq ((reflection K).trans (reflection K)) (LinearIsometryEquiv.refl ùïú E)","decl":"/-- Reflection is involutive. -/\n@[simp]\ntheorem reflection_trans_reflection :\n    (reflection K).trans (reflection K) = LinearIsometryEquiv.refl ùïú E :=\n  LinearIsometryEquiv.ext <| reflection_involutive K\n\n"}
{"name":"reflection_mul_reflection","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\n‚ä¢ Eq (HMul.hMul (reflection K) (reflection K)) 1","decl":"/-- Reflection is involutive. -/\n@[simp]\ntheorem reflection_mul_reflection : reflection K * reflection K = 1 :=\n  reflection_trans_reflection _\n\n"}
{"name":"reflection_orthogonal_apply","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nv : E\n‚ä¢ Eq ((reflection K.orthogonal) v) (Neg.neg ((reflection K) v))","decl":"theorem reflection_orthogonal_apply (v : E) : reflection K·óÆ v = -reflection K v := by\n  simp [reflection_apply]; abel\n\n"}
{"name":"reflection_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\n‚ä¢ Eq (reflection K.orthogonal) ((reflection K).trans (LinearIsometryEquiv.neg ùïú))","decl":"theorem reflection_orthogonal : reflection K·óÆ = .trans (reflection K) (.neg _) := by\n  ext; apply reflection_orthogonal_apply\n\n"}
{"name":"reflection_singleton_apply","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nu v : E\n‚ä¢ Eq ((reflection (Submodule.span ùïú (Singleton.singleton u))) v) (HSub.hSub (HSMul.hSMul 2 (HSMul.hSMul (HDiv.hDiv (Inner.inner u v) (HPow.hPow (‚Üë(Norm.norm u)) 2)) u)) v)","decl":"theorem reflection_singleton_apply (u v : E) :\n    reflection (ùïú ‚àô u) v = 2 ‚Ä¢ (‚ü™u, v‚ü´ / ((‚Äñu‚Äñ : ùïú) ^ 2)) ‚Ä¢ u - v := by\n  rw [reflection_apply, orthogonalProjection_singleton, ofReal_pow]\n\n"}
{"name":"reflection_eq_self_iff","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nx : E\n‚ä¢ Iff (Eq ((reflection K) x) x) (Membership.mem K x)","decl":"/-- A point is its own reflection if and only if it is in the subspace. -/\ntheorem reflection_eq_self_iff (x : E) : reflection K x = x ‚Üî x ‚àà K := by\n  rw [‚Üê orthogonalProjection_eq_self_iff, reflection_apply, sub_eq_iff_eq_add', ‚Üê two_smul ùïú,\n    two_smul ‚Ñï, ‚Üê two_smul ùïú]\n  refine (smul_right_injective E ?_).eq_iff\n  exact two_ne_zero\n\n"}
{"name":"reflection_mem_subspace_eq_self","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nx : E\nhx : Membership.mem K x\n‚ä¢ Eq ((reflection K) x) x","decl":"theorem reflection_mem_subspace_eq_self {x : E} (hx : x ‚àà K) : reflection K x = x :=\n  (reflection_eq_self_iff x).mpr hx\n\n"}
{"name":"reflection_map_apply","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\ninst‚úù‚Åµ : RCLike ùïú\nE : Type u_4\nE' : Type u_5\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedAddCommGroup E'\ninst‚úù¬≤ : InnerProductSpace ùïú E\ninst‚úù¬π : InnerProductSpace ùïú E'\nf : LinearIsometryEquiv (RingHom.id ùïú) E E'\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nx : E'\n‚ä¢ Eq ((reflection (Submodule.map (‚Üëf.toLinearEquiv) K)) x) (f ((reflection K) (f.symm x)))","decl":"/-- Reflection in the `Submodule.map` of a subspace. -/\ntheorem reflection_map_apply {E E' : Type*} [NormedAddCommGroup E] [NormedAddCommGroup E']\n    [InnerProductSpace ùïú E] [InnerProductSpace ùïú E'] (f : E ‚âÉ‚Çó·µ¢[ùïú] E') (K : Submodule ùïú E)\n    [HasOrthogonalProjection K] (x : E') :\n    reflection (K.map (f.toLinearEquiv : E ‚Üí‚Çó[ùïú] E')) x = f (reflection K (f.symm x)) := by\n  simp [two_smul, reflection_apply, orthogonalProjection_map_apply f K x]\n\n"}
{"name":"reflection_map","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\ninst‚úù‚Åµ : RCLike ùïú\nE : Type u_4\nE' : Type u_5\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedAddCommGroup E'\ninst‚úù¬≤ : InnerProductSpace ùïú E\ninst‚úù¬π : InnerProductSpace ùïú E'\nf : LinearIsometryEquiv (RingHom.id ùïú) E E'\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\n‚ä¢ Eq (reflection (Submodule.map (‚Üëf.toLinearEquiv) K)) (f.symm.trans ((reflection K).trans f))","decl":"/-- Reflection in the `Submodule.map` of a subspace. -/\ntheorem reflection_map {E E' : Type*} [NormedAddCommGroup E] [NormedAddCommGroup E']\n    [InnerProductSpace ùïú E] [InnerProductSpace ùïú E'] (f : E ‚âÉ‚Çó·µ¢[ùïú] E') (K : Submodule ùïú E)\n    [HasOrthogonalProjection K] :\n    reflection (K.map (f.toLinearEquiv : E ‚Üí‚Çó[ùïú] E')) = f.symm.trans ((reflection K).trans f) :=\n  LinearIsometryEquiv.ext <| reflection_map_apply f K\n\n"}
{"name":"reflection_bot","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\n‚ä¢ Eq (reflection Bot.bot) (LinearIsometryEquiv.neg ùïú)","decl":"/-- Reflection through the trivial subspace {0} is just negation. -/\n@[simp]\ntheorem reflection_bot : reflection (‚ä• : Submodule ùïú E) = LinearIsometryEquiv.neg ùïú := by\n  ext; simp [reflection_apply]\n\n"}
{"name":"Submodule.sup_orthogonal_inf_of_completeSpace","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK‚ÇÅ K‚ÇÇ : Submodule ùïú E\nh : LE.le K‚ÇÅ K‚ÇÇ\ninst‚úù : HasOrthogonalProjection K‚ÇÅ\n‚ä¢ Eq (Max.max K‚ÇÅ (Min.min K‚ÇÅ.orthogonal K‚ÇÇ)) K‚ÇÇ","decl":"/-- If `K‚ÇÅ` is complete and contained in `K‚ÇÇ`, `K‚ÇÅ` and `K‚ÇÅ·óÆ ‚äì K‚ÇÇ` span `K‚ÇÇ`. -/\ntheorem Submodule.sup_orthogonal_inf_of_completeSpace {K‚ÇÅ K‚ÇÇ : Submodule ùïú E} (h : K‚ÇÅ ‚â§ K‚ÇÇ)\n    [HasOrthogonalProjection K‚ÇÅ] : K‚ÇÅ ‚äî K‚ÇÅ·óÆ ‚äì K‚ÇÇ = K‚ÇÇ := by\n  ext x\n  rw [Submodule.mem_sup]\n  let v : K‚ÇÅ := orthogonalProjection K‚ÇÅ x\n  have hvm : x - v ‚àà K‚ÇÅ·óÆ := sub_orthogonalProjection_mem_orthogonal x\n  constructor\n  ¬∑ rintro ‚ü®y, hy, z, hz, rfl‚ü©\n    exact K‚ÇÇ.add_mem (h hy) hz.2\n  ¬∑ exact fun hx => ‚ü®v, v.prop, x - v, ‚ü®hvm, K‚ÇÇ.sub_mem hx (h v.prop)‚ü©, add_sub_cancel _ _‚ü©\n\n"}
{"name":"Submodule.sup_orthogonal_of_completeSpace","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\n‚ä¢ Eq (Max.max K K.orthogonal) Top.top","decl":"/-- If `K` is complete, `K` and `K·óÆ` span the whole space. -/\ntheorem Submodule.sup_orthogonal_of_completeSpace [HasOrthogonalProjection K] : K ‚äî K·óÆ = ‚ä§ := by\n  convert Submodule.sup_orthogonal_inf_of_completeSpace (le_top : K ‚â§ ‚ä§) using 2\n  simp\n\n"}
{"name":"Submodule.exists_add_mem_mem_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nv : E\n‚ä¢ Exists fun y => And (Membership.mem K y) (Exists fun z => And (Membership.mem K.orthogonal z) (Eq v (HAdd.hAdd y z)))","decl":"/-- If `K` is complete, any `v` in `E` can be expressed as a sum of elements of `K` and `K·óÆ`. -/\ntheorem Submodule.exists_add_mem_mem_orthogonal [HasOrthogonalProjection K] (v : E) :\n    ‚àÉ y ‚àà K, ‚àÉ z ‚àà K·óÆ, v = y + z :=\n  ‚ü®orthogonalProjection K v, Subtype.coe_prop _, v - orthogonalProjection K v,\n    sub_orthogonalProjection_mem_orthogonal _, by simp‚ü©\n\n"}
{"name":"Submodule.orthogonal_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\n‚ä¢ Eq K.orthogonal.orthogonal K","decl":"/-- If `K` admits an orthogonal projection, then the orthogonal complement of its orthogonal\ncomplement is itself. -/\n@[simp]\ntheorem Submodule.orthogonal_orthogonal [HasOrthogonalProjection K] : K·óÆ·óÆ = K := by\n  ext v\n  constructor\n  ¬∑ obtain ‚ü®y, hy, z, hz, rfl‚ü© := K.exists_add_mem_mem_orthogonal v\n    intro hv\n    have hz' : z = 0 := by\n      have hyz : ‚ü™z, y‚ü´ = 0 := by simp [hz y hy, inner_eq_zero_symm]\n      simpa [inner_add_right, hyz] using hv z hz\n    simp [hy, hz']\n  ¬∑ intro hv w hw\n    rw [inner_eq_zero_symm]\n    exact hw v hv\n\n"}
{"name":"Submodule.orthogonal_orthogonal_eq_closure","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : CompleteSpace E\n‚ä¢ Eq K.orthogonal.orthogonal K.topologicalClosure","decl":"/-- In a Hilbert space, the orthogonal complement of the orthogonal complement of a subspace `K`\nis the topological closure of `K`.\n\nNote that the completeness assumption is necessary. Let `E` be the space `‚Ñï ‚Üí‚ÇÄ ‚Ñù` with inner space\nstructure inherited from `PiLp 2 (fun _ : ‚Ñï ‚Ü¶ ‚Ñù)`. Let `K` be the subspace of sequences with the sum\nof all elements equal to zero. Then `K·óÆ = ‚ä•`, `K·óÆ·óÆ = ‚ä§`. -/\ntheorem Submodule.orthogonal_orthogonal_eq_closure [CompleteSpace E] :\n    K·óÆ·óÆ = K.topologicalClosure := by\n  refine le_antisymm ?_ ?_\n  ¬∑ convert Submodule.orthogonal_orthogonal_monotone K.le_topologicalClosure using 1\n    rw [K.topologicalClosure.orthogonal_orthogonal]\n  ¬∑ exact K.topologicalClosure_minimal K.le_orthogonal_orthogonal K·óÆ.isClosed_orthogonal\n\n"}
{"name":"Submodule.isCompl_orthogonal_of_completeSpace","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\n‚ä¢ IsCompl K K.orthogonal","decl":"/-- If `K` admits an orthogonal projection, `K` and `K·óÆ` are complements of each other. -/\ntheorem Submodule.isCompl_orthogonal_of_completeSpace [HasOrthogonalProjection K] : IsCompl K K·óÆ :=\n  ‚ü®K.orthogonal_disjoint, codisjoint_iff.2 Submodule.sup_orthogonal_of_completeSpace‚ü©\n\n"}
{"name":"orthogonalComplement_eq_orthogonalComplement","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : RCLike ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : InnerProductSpace ùïú E\nK L : Submodule ùïú E\ninst‚úù¬π : HasOrthogonalProjection K\ninst‚úù : HasOrthogonalProjection L\n‚ä¢ Iff (Eq K.orthogonal L.orthogonal) (Eq K L)","decl":"@[simp]\ntheorem orthogonalComplement_eq_orthogonalComplement {L : Submodule ùïú E} [HasOrthogonalProjection K]\n    [HasOrthogonalProjection L] : K·óÆ = L·óÆ ‚Üî K = L :=\n  ‚ü®fun h ‚Ü¶ by simpa using congr(Submodule.orthogonal $(h)),\n    fun h ‚Ü¶ congr(Submodule.orthogonal $(h))‚ü©\n\n"}
{"name":"Submodule.orthogonal_eq_bot_iff","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\n‚ä¢ Iff (Eq K.orthogonal Bot.bot) (Eq K Top.top)","decl":"@[simp]\ntheorem Submodule.orthogonal_eq_bot_iff [HasOrthogonalProjection K] : K·óÆ = ‚ä• ‚Üî K = ‚ä§ := by\n  refine ‚ü®?_, fun h => by rw [h, Submodule.top_orthogonal_eq_bot]‚ü©\n  intro h\n  have : K ‚äî K·óÆ = ‚ä§ := Submodule.sup_orthogonal_of_completeSpace\n  rwa [h, sup_comm, bot_sup_eq] at this\n\n"}
{"name":"orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nv : E\nhv : Membership.mem K.orthogonal v\n‚ä¢ Eq ((orthogonalProjection K) v) 0","decl":"/-- The orthogonal projection onto `K` of an element of `K·óÆ` is zero. -/\ntheorem orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero [HasOrthogonalProjection K]\n    {v : E} (hv : v ‚àà K·óÆ) : orthogonalProjection K v = 0 := by\n  ext\n  convert eq_orthogonalProjection_of_mem_orthogonal (K := K) _ _ <;> simp [hv]\n\n"}
{"name":"Submodule.IsOrtho.orthogonalProjection_comp_subtypeL","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nU V : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection U\nh : U.IsOrtho V\n‚ä¢ Eq ((orthogonalProjection U).comp V.subtypeL) 0","decl":"/-- The projection into `U` from an orthogonal submodule `V` is the zero map. -/\ntheorem Submodule.IsOrtho.orthogonalProjection_comp_subtypeL {U V : Submodule ùïú E}\n    [HasOrthogonalProjection U] (h : U ‚üÇ V) : orthogonalProjection U ‚àòL V.subtypeL = 0 :=\n  ContinuousLinearMap.ext fun v =>\n    orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero <| h.symm v.prop\n\n"}
{"name":"orthogonalProjection_comp_subtypeL_eq_zero_iff","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nU V : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection U\n‚ä¢ Iff (Eq ((orthogonalProjection U).comp V.subtypeL) 0) (U.IsOrtho V)","decl":"/-- The projection into `U` from `V` is the zero map if and only if `U` and `V` are orthogonal. -/\ntheorem orthogonalProjection_comp_subtypeL_eq_zero_iff {U V : Submodule ùïú E}\n    [HasOrthogonalProjection U] : orthogonalProjection U ‚àòL V.subtypeL = 0 ‚Üî U ‚üÇ V :=\n  ‚ü®fun h u hu v hv => by\n    convert orthogonalProjection_inner_eq_zero v u hu using 2\n    have : orthogonalProjection U v = 0 := DFunLike.congr_fun h (‚ü®_, hv‚ü© : V)\n    rw [this, Submodule.coe_zero, sub_zero], Submodule.IsOrtho.orthogonalProjection_comp_subtypeL‚ü©\n\n"}
{"name":"orthogonalProjection_eq_linear_proj","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nx : E\n‚ä¢ Eq ((orthogonalProjection K) x) ((K.linearProjOfIsCompl K.orthogonal ‚ãØ) x)","decl":"theorem orthogonalProjection_eq_linear_proj [HasOrthogonalProjection K] (x : E) :\n    orthogonalProjection K x =\n      K.linearProjOfIsCompl _ Submodule.isCompl_orthogonal_of_completeSpace x := by\n  have : IsCompl K K·óÆ := Submodule.isCompl_orthogonal_of_completeSpace\n  conv_lhs => rw [‚Üê Submodule.linear_proj_add_linearProjOfIsCompl_eq_self this x]\n  rw [map_add, orthogonalProjection_mem_subspace_eq_self,\n    orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero (Submodule.coe_mem _), add_zero]\n\n"}
{"name":"orthogonalProjection_coe_linearMap_eq_linearProj","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\n‚ä¢ Eq (‚Üë(orthogonalProjection K)) (K.linearProjOfIsCompl K.orthogonal ‚ãØ)","decl":"theorem orthogonalProjection_coe_linearMap_eq_linearProj [HasOrthogonalProjection K] :\n    (orthogonalProjection K : E ‚Üí‚Çó[ùïú] K) =\n      K.linearProjOfIsCompl _ Submodule.isCompl_orthogonal_of_completeSpace :=\n  LinearMap.ext <| orthogonalProjection_eq_linear_proj\n\n"}
{"name":"reflection_mem_subspace_orthogonalComplement_eq_neg","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nv : E\nhv : Membership.mem K.orthogonal v\n‚ä¢ Eq ((reflection K) v) (Neg.neg v)","decl":"/-- The reflection in `K` of an element of `K·óÆ` is its negation. -/\ntheorem reflection_mem_subspace_orthogonalComplement_eq_neg [HasOrthogonalProjection K] {v : E}\n    (hv : v ‚àà K·óÆ) : reflection K v = -v := by\n  simp [reflection_apply, orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero hv]\n\n"}
{"name":"orthogonalProjection_mem_subspace_orthogonal_precomplement_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K.orthogonal\nv : E\nhv : Membership.mem K v\n‚ä¢ Eq ((orthogonalProjection K.orthogonal) v) 0","decl":"/-- The orthogonal projection onto `K·óÆ` of an element of `K` is zero. -/\ntheorem orthogonalProjection_mem_subspace_orthogonal_precomplement_eq_zero\n    [HasOrthogonalProjection K·óÆ] {v : E} (hv : v ‚àà K) : orthogonalProjection K·óÆ v = 0 :=\n  orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero (K.le_orthogonal_orthogonal hv)\n\n"}
{"name":"orthogonalProjection_orthogonalProjection_of_le","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : RCLike ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : InnerProductSpace ùïú E\nU V : Submodule ùïú E\ninst‚úù¬π : HasOrthogonalProjection U\ninst‚úù : HasOrthogonalProjection V\nh : LE.le U V\nx : E\n‚ä¢ Eq ((orthogonalProjection U) ‚Üë((orthogonalProjection V) x)) ((orthogonalProjection U) x)","decl":"/-- If `U ‚â§ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. -/\ntheorem orthogonalProjection_orthogonalProjection_of_le {U V : Submodule ùïú E}\n    [HasOrthogonalProjection U] [HasOrthogonalProjection V] (h : U ‚â§ V) (x : E) :\n    orthogonalProjection U (orthogonalProjection V x) = orthogonalProjection U x :=\n  Eq.symm <| by\n    simpa only [sub_eq_zero, map_sub] using\n      orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero\n        (Submodule.orthogonal_le h (sub_orthogonalProjection_mem_orthogonal x))\n\n"}
{"name":"orthogonalProjection_tendsto_closure_iSup","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Åµ : RCLike ùïú\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : InnerProductSpace ùïú E\nŒπ : Type u_4\ninst‚úù¬≤ : Preorder Œπ\nU : Œπ ‚Üí Submodule ùïú E\ninst‚úù¬π : ‚àÄ (i : Œπ), HasOrthogonalProjection (U i)\ninst‚úù : HasOrthogonalProjection (iSup fun i => U i).topologicalClosure\nhU : Monotone U\nx : E\n‚ä¢ Filter.Tendsto (fun i => ‚Üë((orthogonalProjection (U i)) x)) Filter.atTop (nhds ‚Üë((orthogonalProjection (iSup fun i => U i).topologicalClosure) x))","decl":"/-- Given a monotone family `U` of complete submodules of `E` and a fixed `x : E`,\nthe orthogonal projection of `x` on `U i` tends to the orthogonal projection of `x` on\n`(‚®Ü i, U i).topologicalClosure` along `atTop`. -/\ntheorem orthogonalProjection_tendsto_closure_iSup {Œπ : Type*} [Preorder Œπ]\n    (U : Œπ ‚Üí Submodule ùïú E) [‚àÄ i, HasOrthogonalProjection (U i)]\n    [HasOrthogonalProjection (‚®Ü i, U i).topologicalClosure] (hU : Monotone U) (x : E) :\n    Filter.Tendsto (fun i => (orthogonalProjection (U i) x : E)) atTop\n      (ùìù (orthogonalProjection (‚®Ü i, U i).topologicalClosure x : E)) := by\n  refine .of_neBot_imp fun h ‚Ü¶ ?_\n  cases atTop_neBot_iff.mp h\n  let y := (orthogonalProjection (‚®Ü i, U i).topologicalClosure x : E)\n  have proj_x : ‚àÄ i, orthogonalProjection (U i) x = orthogonalProjection (U i) y := fun i =>\n    (orthogonalProjection_orthogonalProjection_of_le\n        ((le_iSup U i).trans (iSup U).le_topologicalClosure) _).symm\n  suffices ‚àÄ Œµ > 0, ‚àÉ I, ‚àÄ i ‚â• I, ‚Äñ(orthogonalProjection (U i) y : E) - y‚Äñ < Œµ by\n    simpa only [proj_x, NormedAddCommGroup.tendsto_atTop] using this\n  intro Œµ hŒµ\n  obtain ‚ü®a, ha, hay‚ü© : ‚àÉ a ‚àà ‚®Ü i, U i, dist y a < Œµ := by\n    have y_mem : y ‚àà (‚®Ü i, U i).topologicalClosure := Submodule.coe_mem _\n    rw [‚Üê SetLike.mem_coe, Submodule.topologicalClosure_coe, Metric.mem_closure_iff] at y_mem\n    exact y_mem Œµ hŒµ\n  rw [dist_eq_norm] at hay\n  obtain ‚ü®I, hI‚ü© : ‚àÉ I, a ‚àà U I := by rwa [Submodule.mem_iSup_of_directed _ hU.directed_le] at ha\n  refine ‚ü®I, fun i (hi : I ‚â§ i) => ?_‚ü©\n  rw [norm_sub_rev, orthogonalProjection_minimal]\n  refine lt_of_le_of_lt ?_ hay\n  change _ ‚â§ ‚Äñy - (‚ü®a, hU hi hI‚ü© : U i)‚Äñ\n  exact ciInf_le ‚ü®0, Set.forall_mem_range.mpr fun _ => norm_nonneg _‚ü© _\n\n"}
{"name":"orthogonalProjection_tendsto_self","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : RCLike ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : InnerProductSpace ùïú E\nŒπ : Type u_4\ninst‚úù¬π : Preorder Œπ\nU : Œπ ‚Üí Submodule ùïú E\ninst‚úù : ‚àÄ (t : Œπ), HasOrthogonalProjection (U t)\nhU : Monotone U\nx : E\nhU' : LE.le Top.top (iSup fun t => U t).topologicalClosure\n‚ä¢ Filter.Tendsto (fun t => ‚Üë((orthogonalProjection (U t)) x)) Filter.atTop (nhds x)","decl":"/-- Given a monotone family `U` of complete submodules of `E` with dense span supremum,\nand a fixed `x : E`, the orthogonal projection of `x` on `U i` tends to `x` along `at_top`. -/\ntheorem orthogonalProjection_tendsto_self {Œπ : Type*} [Preorder Œπ]\n    (U : Œπ ‚Üí Submodule ùïú E) [‚àÄ t, HasOrthogonalProjection (U t)] (hU : Monotone U) (x : E)\n    (hU' : ‚ä§ ‚â§ (‚®Ü t, U t).topologicalClosure) :\n    Filter.Tendsto (fun t => (orthogonalProjection (U t) x : E)) atTop (ùìù x) := by\n  have : HasOrthogonalProjection (‚®Ü i, U i).topologicalClosure := by\n    rw [top_unique hU']\n    infer_instance\n  convert orthogonalProjection_tendsto_closure_iSup U hU x\n  rw [eq_comm, orthogonalProjection_eq_self_iff, top_unique hU']\n  trivial\n\n"}
{"name":"Submodule.triorthogonal_eq_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : CompleteSpace E\n‚ä¢ Eq K.orthogonal.orthogonal.orthogonal K.orthogonal","decl":"/-- The orthogonal complement satisfies `K·óÆ·óÆ·óÆ = K·óÆ`. -/\ntheorem Submodule.triorthogonal_eq_orthogonal [CompleteSpace E] : K·óÆ·óÆ·óÆ = K·óÆ := by\n  rw [K·óÆ.orthogonal_orthogonal_eq_closure]\n  exact K.isClosed_orthogonal.submodule_topologicalClosure_eq\n\n"}
{"name":"Submodule.topologicalClosure_eq_top_iff","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : CompleteSpace E\n‚ä¢ Iff (Eq K.topologicalClosure Top.top) (Eq K.orthogonal Bot.bot)","decl":"/-- The closure of `K` is the full space iff `K·óÆ` is trivial. -/\ntheorem Submodule.topologicalClosure_eq_top_iff [CompleteSpace E] :\n    K.topologicalClosure = ‚ä§ ‚Üî K·óÆ = ‚ä• := by\n  rw [‚Üê Submodule.orthogonal_orthogonal_eq_closure]\n  constructor <;> intro h\n  ¬∑ rw [‚Üê Submodule.triorthogonal_eq_orthogonal, h, Submodule.top_orthogonal_eq_bot]\n  ¬∑ rw [h, Submodule.bot_orthogonal_eq_top]\n\n"}
{"name":"Dense.eq_zero_of_inner_left","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nK : Submodule ùïú E\nx : E\nhK : Dense ‚ÜëK\nh : ‚àÄ (v : Subtype fun x => Membership.mem K x), Eq (Inner.inner x ‚Üëv) 0\n‚ä¢ Eq x 0","decl":"theorem eq_zero_of_inner_left (hK : Dense (K : Set E)) (h : ‚àÄ v : K, ‚ü™x, v‚ü´ = 0) : x = 0 := by\n  have : (‚ü™x, ¬∑‚ü´) = 0 := (continuous_const.inner continuous_id).ext_on\n    hK continuous_const (Subtype.forall.1 h)\n  simpa using congr_fun this x\n\n"}
{"name":"Dense.eq_zero_of_mem_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nK : Submodule ùïú E\nx : E\nhK : Dense ‚ÜëK\nh : Membership.mem K.orthogonal x\n‚ä¢ Eq x 0","decl":"theorem eq_zero_of_mem_orthogonal (hK : Dense (K : Set E)) (h : x ‚àà K·óÆ) : x = 0 :=\n  eq_zero_of_inner_left hK fun v ‚Ü¶ (mem_orthogonal' _ _).1 h _ v.2\n\n"}
{"name":"Dense.eq_of_sub_mem_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nK : Submodule ùïú E\nx y : E\nhK : Dense ‚ÜëK\nh : Membership.mem K.orthogonal (HSub.hSub x y)\n‚ä¢ Eq x y","decl":"/-- If `S` is dense and `x - y ‚àà K·óÆ`, then `x = y`. -/\ntheorem eq_of_sub_mem_orthogonal (hK : Dense (K : Set E)) (h : x - y ‚àà K·óÆ) : x = y :=\n  sub_eq_zero.1 <| eq_zero_of_mem_orthogonal hK h\n\n"}
{"name":"Dense.eq_of_inner_left","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nK : Submodule ùïú E\nx y : E\nhK : Dense ‚ÜëK\nh : ‚àÄ (v : Subtype fun x => Membership.mem K x), Eq (Inner.inner x ‚Üëv) (Inner.inner y ‚Üëv)\n‚ä¢ Eq x y","decl":"theorem eq_of_inner_left (hK : Dense (K : Set E)) (h : ‚àÄ v : K, ‚ü™x, v‚ü´ = ‚ü™y, v‚ü´) : x = y :=\n  hK.eq_of_sub_mem_orthogonal (Submodule.sub_mem_orthogonal_of_inner_left h)\n\n"}
{"name":"Dense.eq_of_inner_right","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nK : Submodule ùïú E\nx y : E\nhK : Dense ‚ÜëK\nh : ‚àÄ (v : Subtype fun x => Membership.mem K x), Eq (Inner.inner (‚Üëv) x) (Inner.inner (‚Üëv) y)\n‚ä¢ Eq x y","decl":"theorem eq_of_inner_right (hK : Dense (K : Set E)) (h : ‚àÄ v : K, ‚ü™(v : E), x‚ü´ = ‚ü™(v : E), y‚ü´) :\n    x = y :=\n  hK.eq_of_sub_mem_orthogonal (Submodule.sub_mem_orthogonal_of_inner_right h)\n\n"}
{"name":"Dense.eq_zero_of_inner_right","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nK : Submodule ùïú E\nx : E\nhK : Dense ‚ÜëK\nh : ‚àÄ (v : Subtype fun x => Membership.mem K x), Eq (Inner.inner (‚Üëv) x) 0\n‚ä¢ Eq x 0","decl":"theorem eq_zero_of_inner_right (hK : Dense (K : Set E)) (h : ‚àÄ v : K, ‚ü™(v : E), x‚ü´ = 0) : x = 0 :=\n  hK.eq_of_inner_right fun v => by rw [inner_zero_right, h v]\n\n"}
{"name":"reflection_mem_subspace_orthogonal_precomplement_eq_neg","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nv : E\nhv : Membership.mem K v\n‚ä¢ Eq ((reflection K.orthogonal) v) (Neg.neg v)","decl":"/-- The reflection in `K·óÆ` of an element of `K` is its negation. -/\ntheorem reflection_mem_subspace_orthogonal_precomplement_eq_neg [HasOrthogonalProjection K] {v : E}\n    (hv : v ‚àà K) : reflection K·óÆ v = -v :=\n  reflection_mem_subspace_orthogonalComplement_eq_neg (K.le_orthogonal_orthogonal hv)\n\n"}
{"name":"orthogonalProjection_orthogonalComplement_singleton_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nv : E\n‚ä¢ Eq ((orthogonalProjection (Submodule.span ùïú (Singleton.singleton v)).orthogonal) v) 0","decl":"/-- The orthogonal projection onto `(ùïú ‚àô v)·óÆ` of `v` is zero. -/\ntheorem orthogonalProjection_orthogonalComplement_singleton_eq_zero (v : E) :\n    orthogonalProjection (ùïú ‚àô v)·óÆ v = 0 :=\n  orthogonalProjection_mem_subspace_orthogonal_precomplement_eq_zero\n    (Submodule.mem_span_singleton_self v)\n\n"}
{"name":"reflection_orthogonalComplement_singleton_eq_neg","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nv : E\n‚ä¢ Eq ((reflection (Submodule.span ùïú (Singleton.singleton v)).orthogonal) v) (Neg.neg v)","decl":"/-- The reflection in `(ùïú ‚àô v)·óÆ` of `v` is `-v`. -/\ntheorem reflection_orthogonalComplement_singleton_eq_neg (v : E) : reflection (ùïú ‚àô v)·óÆ v = -v :=\n  reflection_mem_subspace_orthogonal_precomplement_eq_neg (Submodule.mem_span_singleton_self v)\n\n"}
{"name":"reflection_sub","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"F : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : InnerProductSpace Real F\nv w : F\nh : Eq (Norm.norm v) (Norm.norm w)\n‚ä¢ Eq ((reflection (Submodule.span Real (Singleton.singleton (HSub.hSub v w))).orthogonal) v) w","decl":"theorem reflection_sub {v w : F} (h : ‚Äñv‚Äñ = ‚Äñw‚Äñ) : reflection (‚Ñù ‚àô (v - w))·óÆ v = w := by\n  set R : F ‚âÉ‚Çó·µ¢[‚Ñù] F := reflection (‚Ñù ‚àô v - w)·óÆ\n  suffices R v + R v = w + w by\n    apply smul_right_injective F (by norm_num : (2 : ‚Ñù) ‚â† 0)\n    simpa [two_smul] using this\n  have h‚ÇÅ : R (v - w) = -(v - w) := reflection_orthogonalComplement_singleton_eq_neg (v - w)\n  have h‚ÇÇ : R (v + w) = v + w := by\n    apply reflection_mem_subspace_eq_self\n    rw [Submodule.mem_orthogonal_singleton_iff_inner_left]\n    rw [real_inner_add_sub_eq_zero_iff]\n    exact h\n  convert congr_arg‚ÇÇ (¬∑ + ¬∑) h‚ÇÇ h‚ÇÅ using 1\n  ¬∑ simp\n  ¬∑ abel\n\n"}
{"name":"det_reflection","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : FiniteDimensional ùïú (Subtype fun x => Membership.mem K x)\n‚ä¢ Eq (LinearMap.det ‚Üë(reflection K).toLinearEquiv) (HPow.hPow (-1) (Module.finrank ùïú (Subtype fun x => Membership.mem K.orthogonal x)))","decl":"@[simp]\ntheorem det_reflection : LinearMap.det (reflection K).toLinearMap = (-1) ^ finrank ùïú K·óÆ := by\n  by_cases hK : FiniteDimensional ùïú K·óÆ\n  swap\n  ¬∑ rw [finrank_of_infinite_dimensional hK, pow_zero, LinearMap.det_eq_one_of_finrank_eq_zero]\n    exact finrank_of_infinite_dimensional fun h ‚Ü¶ hK (h.finiteDimensional_submodule _)\n  let e := K.prodEquivOfIsCompl _ K.isCompl_orthogonal_of_completeSpace\n  let b := (finBasis ùïú K).prod (finBasis ùïú K·óÆ)\n  have : LinearMap.toMatrix b b (e.symm ‚àò‚Çó (reflection K).toLinearMap ‚àò‚Çó e.symm.symm) =\n      Matrix.fromBlocks 1 0 0 (-1) := by\n    ext (_ | _) (_ | _) <;>\n    simp [LinearMap.toMatrix_apply, b, Matrix.one_apply, Finsupp.single_apply, e, eq_comm,\n      reflection_mem_subspace_eq_self, reflection_mem_subspace_orthogonalComplement_eq_neg]\n  rw [‚Üê LinearMap.det_conj _ e.symm, ‚Üê LinearMap.det_toMatrix b, this, Matrix.det_fromBlocks_zero‚ÇÇ‚ÇÅ,\n    Matrix.det_one, one_mul, Matrix.det_neg, Fintype.card_fin, Matrix.det_one, mul_one]\n\n"}
{"name":"linearEquiv_det_reflection","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : FiniteDimensional ùïú (Subtype fun x => Membership.mem K x)\n‚ä¢ Eq (LinearEquiv.det (reflection K).toLinearEquiv) (HPow.hPow (-1) (Module.finrank ùïú (Subtype fun x => Membership.mem K.orthogonal x)))","decl":"@[simp]\ntheorem linearEquiv_det_reflection : (reflection K).det = (-1) ^ finrank ùïú K·óÆ := by\n  ext\n  rw [LinearEquiv.coe_det, Units.val_pow_eq_pow_val]\n  exact det_reflection K\n\n"}
{"name":"orthogonalProjection_add_orthogonalProjection_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nw : E\n‚ä¢ Eq (HAdd.hAdd ‚Üë((orthogonalProjection K) w) ‚Üë((orthogonalProjection K.orthogonal) w)) w","decl":"/-- If the orthogonal projection to `K` is well-defined, then a vector splits as the sum of its\northogonal projections onto a complete submodule `K` and onto the orthogonal complement of `K`. -/\ntheorem orthogonalProjection_add_orthogonalProjection_orthogonal [HasOrthogonalProjection K]\n    (w : E) : (orthogonalProjection K w : E) + (orthogonalProjection K·óÆ w : E) = w := by\n  simp\n\n"}
{"name":"norm_sq_eq_add_norm_sq_projection","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nx : E\nS : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection S\n‚ä¢ Eq (HPow.hPow (Norm.norm x) 2) (HAdd.hAdd (HPow.hPow (Norm.norm ((orthogonalProjection S) x)) 2) (HPow.hPow (Norm.norm ((orthogonalProjection S.orthogonal) x)) 2))","decl":"/-- The Pythagorean theorem, for an orthogonal projection. -/\ntheorem norm_sq_eq_add_norm_sq_projection (x : E) (S : Submodule ùïú E) [HasOrthogonalProjection S] :\n    ‚Äñx‚Äñ ^ 2 = ‚ÄñorthogonalProjection S x‚Äñ ^ 2 + ‚ÄñorthogonalProjection S·óÆ x‚Äñ ^ 2 :=\n  calc\n    ‚Äñx‚Äñ ^ 2 = ‚Äñ(orthogonalProjection S x : E) + orthogonalProjection S·óÆ x‚Äñ ^ 2 := by\n      rw [orthogonalProjection_add_orthogonalProjection_orthogonal]\n    _ = ‚ÄñorthogonalProjection S x‚Äñ ^ 2 + ‚ÄñorthogonalProjection S·óÆ x‚Äñ ^ 2 := by\n      simp only [sq]\n      exact norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero _ _ <|\n        (S.mem_orthogonal _).1 (orthogonalProjection S·óÆ x).2 _ (orthogonalProjection S x).2\n\n"}
{"name":"id_eq_sum_orthogonalProjection_self_orthogonalComplement","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\n‚ä¢ Eq (ContinuousLinearMap.id ùïú E) (HAdd.hAdd (K.subtypeL.comp (orthogonalProjection K)) (K.orthogonal.subtypeL.comp (orthogonalProjection K.orthogonal)))","decl":"/-- In a complete space `E`, the projection maps onto a complete subspace `K` and its orthogonal\ncomplement sum to the identity. -/\ntheorem id_eq_sum_orthogonalProjection_self_orthogonalComplement [HasOrthogonalProjection K] :\n    ContinuousLinearMap.id ùïú E =\n      K.subtypeL.comp (orthogonalProjection K) + K·óÆ.subtypeL.comp (orthogonalProjection K·óÆ) := by\n  ext w\n  exact (orthogonalProjection_add_orthogonalProjection_orthogonal K w).symm\n\n-- Porting note: The priority should be higher than `Submodule.coe_inner`.\n"}
{"name":"inner_orthogonalProjection_eq_of_mem_right","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nu : Subtype fun x => Membership.mem K x\nv : E\n‚ä¢ Eq (Inner.inner ((orthogonalProjection K) v) u) (Inner.inner v ‚Üëu)","decl":"@[simp high]\ntheorem inner_orthogonalProjection_eq_of_mem_right [HasOrthogonalProjection K] (u : K) (v : E) :\n    ‚ü™orthogonalProjection K v, u‚ü´ = ‚ü™v, u‚ü´ :=\n  calc\n    ‚ü™orthogonalProjection K v, u‚ü´ = ‚ü™(orthogonalProjection K v : E), u‚ü´ := K.coe_inner _ _\n    _ = ‚ü™(orthogonalProjection K v : E), u‚ü´ + ‚ü™v - orthogonalProjection K v, u‚ü´ := by\n      rw [orthogonalProjection_inner_eq_zero _ _ (Submodule.coe_mem _), add_zero]\n    _ = ‚ü™v, u‚ü´ := by rw [‚Üê inner_add_left, add_sub_cancel]\n\n-- Porting note: The priority should be higher than `Submodule.coe_inner`.\n"}
{"name":"inner_orthogonalProjection_eq_of_mem_left","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nu : Subtype fun x => Membership.mem K x\nv : E\n‚ä¢ Eq (Inner.inner u ((orthogonalProjection K) v)) (Inner.inner (‚Üëu) v)","decl":"@[simp high]\ntheorem inner_orthogonalProjection_eq_of_mem_left [HasOrthogonalProjection K] (u : K) (v : E) :\n    ‚ü™u, orthogonalProjection K v‚ü´ = ‚ü™(u : E), v‚ü´ := by\n  rw [‚Üê inner_conj_symm, ‚Üê inner_conj_symm (u : E), inner_orthogonalProjection_eq_of_mem_right]\n\n"}
{"name":"inner_orthogonalProjection_left_eq_right","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\nu v : E\n‚ä¢ Eq (Inner.inner (‚Üë((orthogonalProjection K) u)) v) (Inner.inner u ‚Üë((orthogonalProjection K) v))","decl":"/-- The orthogonal projection is self-adjoint. -/\ntheorem inner_orthogonalProjection_left_eq_right [HasOrthogonalProjection K] (u v : E) :\n    ‚ü™‚Üë(orthogonalProjection K u), v‚ü´ = ‚ü™u, orthogonalProjection K v‚ü´ := by\n  rw [‚Üê inner_orthogonalProjection_eq_of_mem_left, inner_orthogonalProjection_eq_of_mem_right]\n\n"}
{"name":"orthogonalProjection_isSymmetric","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK : Submodule ùïú E\ninst‚úù : HasOrthogonalProjection K\n‚ä¢ (‚Üë(K.subtypeL.comp (orthogonalProjection K))).IsSymmetric","decl":"/-- The orthogonal projection is symmetric. -/\ntheorem orthogonalProjection_isSymmetric [HasOrthogonalProjection K] :\n    (K.subtypeL ‚àòL orthogonalProjection K : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=\n  inner_orthogonalProjection_left_eq_right K\n\n"}
{"name":"Submodule.finrank_add_inf_finrank_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK‚ÇÅ K‚ÇÇ : Submodule ùïú E\ninst‚úù : FiniteDimensional ùïú (Subtype fun x => Membership.mem K‚ÇÇ x)\nh : LE.le K‚ÇÅ K‚ÇÇ\n‚ä¢ Eq (HAdd.hAdd (Module.finrank ùïú (Subtype fun x => Membership.mem K‚ÇÅ x)) (Module.finrank ùïú (Subtype fun x => Membership.mem (Min.min K‚ÇÅ.orthogonal K‚ÇÇ) x))) (Module.finrank ùïú (Subtype fun x => Membership.mem K‚ÇÇ x))","decl":"/-- Given a finite-dimensional subspace `K‚ÇÇ`, and a subspace `K‚ÇÅ`\ncontained in it, the dimensions of `K‚ÇÅ` and the intersection of its\northogonal subspace with `K‚ÇÇ` add to that of `K‚ÇÇ`. -/\ntheorem Submodule.finrank_add_inf_finrank_orthogonal {K‚ÇÅ K‚ÇÇ : Submodule ùïú E}\n    [FiniteDimensional ùïú K‚ÇÇ] (h : K‚ÇÅ ‚â§ K‚ÇÇ) :\n    finrank ùïú K‚ÇÅ + finrank ùïú (K‚ÇÅ·óÆ ‚äì K‚ÇÇ : Submodule ùïú E) = finrank ùïú K‚ÇÇ := by\n  haveI : FiniteDimensional ùïú K‚ÇÅ := Submodule.finiteDimensional_of_le h\n  haveI := FiniteDimensional.proper_rclike ùïú K‚ÇÅ\n  have hd := Submodule.finrank_sup_add_finrank_inf_eq K‚ÇÅ (K‚ÇÅ·óÆ ‚äì K‚ÇÇ)\n  rw [‚Üê inf_assoc, (Submodule.orthogonal_disjoint K‚ÇÅ).eq_bot, bot_inf_eq, finrank_bot,\n    Submodule.sup_orthogonal_inf_of_completeSpace h] at hd\n  rw [add_zero] at hd\n  exact hd.symm\n\n"}
{"name":"Submodule.finrank_add_inf_finrank_orthogonal'","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nK‚ÇÅ K‚ÇÇ : Submodule ùïú E\ninst‚úù : FiniteDimensional ùïú (Subtype fun x => Membership.mem K‚ÇÇ x)\nh : LE.le K‚ÇÅ K‚ÇÇ\nn : Nat\nh_dim : Eq (HAdd.hAdd (Module.finrank ùïú (Subtype fun x => Membership.mem K‚ÇÅ x)) n) (Module.finrank ùïú (Subtype fun x => Membership.mem K‚ÇÇ x))\n‚ä¢ Eq (Module.finrank ùïú (Subtype fun x => Membership.mem (Min.min K‚ÇÅ.orthogonal K‚ÇÇ) x)) n","decl":"/-- Given a finite-dimensional subspace `K‚ÇÇ`, and a subspace `K‚ÇÅ`\ncontained in it, the dimensions of `K‚ÇÅ` and the intersection of its\northogonal subspace with `K‚ÇÇ` add to that of `K‚ÇÇ`. -/\ntheorem Submodule.finrank_add_inf_finrank_orthogonal' {K‚ÇÅ K‚ÇÇ : Submodule ùïú E}\n    [FiniteDimensional ùïú K‚ÇÇ] (h : K‚ÇÅ ‚â§ K‚ÇÇ) {n : ‚Ñï} (h_dim : finrank ùïú K‚ÇÅ + n = finrank ùïú K‚ÇÇ) :\n    finrank ùïú (K‚ÇÅ·óÆ ‚äì K‚ÇÇ : Submodule ùïú E) = n := by\n  rw [‚Üê add_right_inj (finrank ùïú K‚ÇÅ)]\n  simp [Submodule.finrank_add_inf_finrank_orthogonal h, h_dim]\n\n"}
{"name":"Submodule.finrank_add_finrank_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\ninst‚úù : FiniteDimensional ùïú E\nK : Submodule ùïú E\n‚ä¢ Eq (HAdd.hAdd (Module.finrank ùïú (Subtype fun x => Membership.mem K x)) (Module.finrank ùïú (Subtype fun x => Membership.mem K.orthogonal x))) (Module.finrank ùïú E)","decl":"/-- Given a finite-dimensional space `E` and subspace `K`, the dimensions of `K` and `K·óÆ` add to\nthat of `E`. -/\ntheorem Submodule.finrank_add_finrank_orthogonal [FiniteDimensional ùïú E] (K : Submodule ùïú E) :\n    finrank ùïú K + finrank ùïú K·óÆ = finrank ùïú E := by\n  convert Submodule.finrank_add_inf_finrank_orthogonal (le_top : K ‚â§ ‚ä§) using 1\n  ¬∑ rw [inf_top_eq]\n  ¬∑ simp\n\n"}
{"name":"Submodule.finrank_add_finrank_orthogonal'","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\ninst‚úù : FiniteDimensional ùïú E\nK : Submodule ùïú E\nn : Nat\nh_dim : Eq (HAdd.hAdd (Module.finrank ùïú (Subtype fun x => Membership.mem K x)) n) (Module.finrank ùïú E)\n‚ä¢ Eq (Module.finrank ùïú (Subtype fun x => Membership.mem K.orthogonal x)) n","decl":"/-- Given a finite-dimensional space `E` and subspace `K`, the dimensions of `K` and `K·óÆ` add to\nthat of `E`. -/\ntheorem Submodule.finrank_add_finrank_orthogonal' [FiniteDimensional ùïú E] {K : Submodule ùïú E}\n    {n : ‚Ñï} (h_dim : finrank ùïú K + n = finrank ùïú E) : finrank ùïú K·óÆ = n := by\n  rw [‚Üê add_right_inj (finrank ùïú K)]\n  simp [Submodule.finrank_add_finrank_orthogonal, h_dim]\n\n"}
{"name":"finrank_orthogonal_span_singleton","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nn : Nat\n_i : Fact (Eq (Module.finrank ùïú E) (HAdd.hAdd n 1))\nv : E\nhv : Ne v 0\n‚ä¢ Eq (Module.finrank ùïú (Subtype fun x => Membership.mem (Submodule.span ùïú (Singleton.singleton v)).orthogonal x)) n","decl":"/-- In a finite-dimensional inner product space, the dimension of the orthogonal complement of the\nspan of a nonzero vector is one less than the dimension of the space. -/\ntheorem finrank_orthogonal_span_singleton {n : ‚Ñï} [_i : Fact (finrank ùïú E = n + 1)] {v : E}\n    (hv : v ‚â† 0) : finrank ùïú (ùïú ‚àô v)·óÆ = n := by\n  haveI : FiniteDimensional ùïú E := .of_fact_finrank_eq_succ n\n  exact Submodule.finrank_add_finrank_orthogonal' <| by\n    simp [finrank_span_singleton hv, _i.elim, add_comm]\n\n"}
{"name":"LinearIsometryEquiv.reflections_generate_dim_aux","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"F : Type u_3\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : InnerProductSpace Real F\ninst‚úù : FiniteDimensional Real F\nn : Nat\nœÜ : LinearIsometryEquiv (RingHom.id Real) F F\nhn : LE.le (Module.finrank Real (Subtype fun x => Membership.mem (LinearMap.ker (HSub.hSub (ContinuousLinearMap.id Real F) ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ })).orthogonal x)) n\n‚ä¢ Exists fun l => And (LE.le l.length n) (Eq œÜ (List.map (fun v => reflection (Submodule.span Real (Singleton.singleton v)).orthogonal) l).prod)","decl":"/-- An element `œÜ` of the orthogonal group of `F` can be factored as a product of reflections, and\nspecifically at most as many reflections as the dimension of the complement of the fixed subspace\nof `œÜ`. -/\ntheorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}\n    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :\n    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod := by\n  -- We prove this by strong induction on `n`, the dimension of the orthogonal complement of the\n  -- fixed subspace of the endomorphism `œÜ`\n  induction' n with n IH generalizing œÜ\n  ¬∑ -- Base case: `n = 0`, the fixed subspace is the whole space, so `œÜ = id`\n    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©\n    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by\n      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn\n    symm\n    ext x\n    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x\n    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,\n      LinearMap.zero_apply] using this\n  ¬∑ -- Inductive step.  Let `W` be the fixed subspace of `œÜ`.  We suppose its complement to have\n    -- dimension at most n + 1.\n    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)\n    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm\n    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n\n    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'\n      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©\n    -- Take a nonzero element `v` of the orthogonal complement of `W`.\n    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)\n    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)\n    have hœÜv : œÜ v ‚àà W·óÆ := by\n      intro w hw\n      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]\n      exact v.prop w hw\n    have hv' : (v : F) ‚àâ W := by\n      intro h\n      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)\n    -- Let `œÅ` be the reflection in `v - œÜ v`; this is designed to swap `v` and `œÜ v`\n    let x : F := v - œÜ v\n    let œÅ := reflection (‚Ñù ‚àô x)·óÆ\n    -- Notation: Let `V` be the fixed subspace of `œÜ.trans œÅ`\n    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)\n    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by\n      intro w hw\n      change w - œÅ (œÜ w) = 0\n      rw [sub_eq_zero, hw]\n    -- Everything fixed by `œÜ` is fixed by `œÜ.trans œÅ`\n    have H‚ÇÇV : W ‚â§ V := by\n      intro w hw\n      apply hV\n      rw [hW w hw]\n      refine reflection_mem_subspace_eq_self ?_\n      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]\n      exact Submodule.sub_mem _ v.prop hœÜv _ hw\n    -- `v` is also fixed by `œÜ.trans œÅ`\n    have H‚ÇÅV : (v : F) ‚àà V := by\n      apply hV\n      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm\n      rw [‚Üê this]\n      exact reflection_reflection _ _\n    -- By dimension-counting, the complement of the fixed subspace of `œÜ.trans œÅ` has dimension at\n    -- most `n`\n    have : finrank ‚Ñù V·óÆ ‚â§ n := by\n      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn\n      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=\n        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)\n      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal\n      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal\n      omega\n    -- So apply the inductive hypothesis to `œÜ.trans œÅ`\n    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this\n    -- Prepend `œÅ` to the factorization into reflections obtained for `œÜ.trans œÅ`; this gives a\n    -- factorization into reflections for `œÜ`.\n    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©\n    rw [List.map_cons, List.prod_cons]\n    have := congr_arg (œÅ * ¬∑) hœÜl\n    dsimp only at this\n    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this\n\n"}
{"name":"LinearIsometryEquiv.reflections_generate_dim","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"F : Type u_3\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : InnerProductSpace Real F\ninst‚úù : FiniteDimensional Real F\nœÜ : LinearIsometryEquiv (RingHom.id Real) F F\n‚ä¢ Exists fun l => And (LE.le l.length (Module.finrank Real F)) (Eq œÜ (List.map (fun v => reflection (Submodule.span Real (Singleton.singleton v)).orthogonal) l).prod)","decl":"/-- The orthogonal group of `F` is generated by reflections; specifically each element `œÜ` of the\northogonal group is a product of at most as many reflections as the dimension of `F`.\n\nSpecial case of the **Cartan‚ÄìDieudonn√© theorem**. -/\ntheorem LinearIsometryEquiv.reflections_generate_dim [FiniteDimensional ‚Ñù F] (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) :\n    ‚àÉ l : List F, l.length ‚â§ finrank ‚Ñù F ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod :=\n  let ‚ü®l, hl‚ÇÅ, hl‚ÇÇ‚ü© := œÜ.reflections_generate_dim_aux le_rfl\n  ‚ü®l, hl‚ÇÅ.trans (Submodule.finrank_le _), hl‚ÇÇ‚ü©\n\n"}
{"name":"LinearIsometryEquiv.reflections_generate","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"F : Type u_3\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : InnerProductSpace Real F\ninst‚úù : FiniteDimensional Real F\n‚ä¢ Eq (Subgroup.closure (Set.range fun v => reflection (Submodule.span Real (Singleton.singleton v)).orthogonal)) Top.top","decl":"/-- The orthogonal group of `F` is generated by reflections. -/\ntheorem LinearIsometryEquiv.reflections_generate [FiniteDimensional ‚Ñù F] :\n    Subgroup.closure (Set.range fun v : F => reflection (‚Ñù ‚àô v)·óÆ) = ‚ä§ := by\n  rw [Subgroup.eq_top_iff']\n  intro œÜ\n  rcases œÜ.reflections_generate_dim with ‚ü®l, _, rfl‚ü©\n  apply (Subgroup.closure _).list_prod_mem\n  intro x hx\n  rcases List.mem_map.mp hx with ‚ü®a, _, hax‚ü©\n  exact Subgroup.subset_closure ‚ü®a, hax‚ü©\n\n"}
{"name":"OrthogonalFamily.isInternal_iff_of_isComplete","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nŒπ : Type u_4\ninst‚úù : DecidableEq Œπ\nV : Œπ ‚Üí Submodule ùïú E\nhV : OrthogonalFamily ùïú (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtype‚Çó·µ¢\nhc : IsComplete ‚Üë(iSup V)\n‚ä¢ Iff (DirectSum.IsInternal V) (Eq (iSup V).orthogonal Bot.bot)","decl":"/-- An orthogonal family of subspaces of `E` satisfies `DirectSum.IsInternal` (that is,\nthey provide an internal direct sum decomposition of `E`) if and only if their span has trivial\northogonal complement. -/\ntheorem OrthogonalFamily.isInternal_iff_of_isComplete [DecidableEq Œπ] {V : Œπ ‚Üí Submodule ùïú E}\n    (hV : OrthogonalFamily ùïú (fun i => V i) fun i => (V i).subtype‚Çó·µ¢)\n    (hc : IsComplete (‚Üë(iSup V) : Set E)) : DirectSum.IsInternal V ‚Üî (iSup V)·óÆ = ‚ä• := by\n  haveI : CompleteSpace (‚Ü•(iSup V)) := hc.completeSpace_coe\n  simp only [DirectSum.isInternal_submodule_iff_iSupIndep_and_iSup_eq_top, hV.independent,\n    true_and, Submodule.orthogonal_eq_bot_iff]\n\n"}
{"name":"OrthogonalFamily.isInternal_iff","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : RCLike ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : InnerProductSpace ùïú E\nŒπ : Type u_4\ninst‚úù¬π : DecidableEq Œπ\ninst‚úù : FiniteDimensional ùïú E\nV : Œπ ‚Üí Submodule ùïú E\nhV : OrthogonalFamily ùïú (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtype‚Çó·µ¢\n‚ä¢ Iff (DirectSum.IsInternal V) (Eq (iSup V).orthogonal Bot.bot)","decl":"/-- An orthogonal family of subspaces of `E` satisfies `DirectSum.IsInternal` (that is,\nthey provide an internal direct sum decomposition of `E`) if and only if their span has trivial\northogonal complement. -/\ntheorem OrthogonalFamily.isInternal_iff [DecidableEq Œπ] [FiniteDimensional ùïú E]\n    {V : Œπ ‚Üí Submodule ùïú E} (hV : OrthogonalFamily ùïú (fun i => V i) fun i => (V i).subtype‚Çó·µ¢) :\n    DirectSum.IsInternal V ‚Üî (iSup V)·óÆ = ‚ä• :=\n  haveI h := FiniteDimensional.proper_rclike ùïú (‚Ü•(iSup V))\n  hV.isInternal_iff_of_isComplete (completeSpace_coe_iff_isComplete.mp inferInstance)\n\n"}
{"name":"OrthogonalFamily.sum_projection_of_mem_iSup","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : RCLike ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : InnerProductSpace ùïú E\nŒπ : Type u_4\ninst‚úù¬π : Fintype Œπ\nV : Œπ ‚Üí Submodule ùïú E\ninst‚úù : ‚àÄ (i : Œπ), CompleteSpace (Subtype fun x => Membership.mem (V i) x)\nhV : OrthogonalFamily ùïú (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtype‚Çó·µ¢\nx : E\nhx : Membership.mem (iSup V) x\n‚ä¢ Eq (Finset.univ.sum fun i => ‚Üë((orthogonalProjection (V i)) x)) x","decl":"/-- If `x` lies within an orthogonal family `v`, it can be expressed as a sum of projections. -/\ntheorem OrthogonalFamily.sum_projection_of_mem_iSup [Fintype Œπ] {V : Œπ ‚Üí Submodule ùïú E}\n    [‚àÄ i, CompleteSpace (V i)] (hV : OrthogonalFamily ùïú (fun i => V i) fun i => (V i).subtype‚Çó·µ¢)\n    (x : E) (hx : x ‚àà iSup V) : (‚àë i, (orthogonalProjection (V i) x : E)) = x := by\n  -- Porting note: switch to the better `induction _ using`. Need the primed induction principle,\n  -- the unprimed one doesn't work with `induction` (as it isn't as syntactically general)\n  induction hx using Submodule.iSup_induction' with\n  | mem i x hx =>\n    refine\n      (Finset.sum_eq_single_of_mem i (Finset.mem_univ _) fun j _ hij => ?_).trans\n        (orthogonalProjection_eq_self_iff.mpr hx)\n    rw [orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero, Submodule.coe_zero]\n    exact hV.isOrtho hij.symm hx\n  | zero =>\n    simp_rw [map_zero, Submodule.coe_zero, Finset.sum_const_zero]\n  | add x y _ _ hx hy =>\n    simp_rw [map_add, Submodule.coe_add, Finset.sum_add_distrib]\n    exact congr_arg‚ÇÇ (¬∑ + ¬∑) hx hy\n\n"}
{"name":"OrthogonalFamily.projection_directSum_coeAddHom","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : RCLike ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : InnerProductSpace ùïú E\nŒπ : Type u_4\ninst‚úù¬π : DecidableEq Œπ\nV : Œπ ‚Üí Submodule ùïú E\nhV : OrthogonalFamily ùïú (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtype‚Çó·µ¢\nx : DirectSum Œπ fun i => Subtype fun x => Membership.mem (V i) x\ni : Œπ\ninst‚úù : CompleteSpace (Subtype fun x => Membership.mem (V i) x)\n‚ä¢ Eq ((orthogonalProjection (V i)) ((DirectSum.coeAddMonoidHom V) x)) (x i)","decl":"/-- If a family of submodules is orthogonal, then the `orthogonalProjection` on a direct sum\nis just the coefficient of that direct sum. -/\ntheorem OrthogonalFamily.projection_directSum_coeAddHom [DecidableEq Œπ] {V : Œπ ‚Üí Submodule ùïú E}\n    (hV : OrthogonalFamily ùïú (fun i => V i) fun i => (V i).subtype‚Çó·µ¢) (x : ‚®Å i, V i) (i : Œπ)\n    [CompleteSpace (V i)] :\n    orthogonalProjection (V i) (DirectSum.coeAddMonoidHom V x) = x i := by\n  induction' x using DirectSum.induction_on with j x x y hx hy\n  ¬∑ simp\n  ¬∑ simp_rw [DirectSum.coeAddMonoidHom_of, DirectSum.of]\n    -- Porting note: was in the previous `simp_rw`, no longer works\n    -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n    erw [DFinsupp.singleAddHom_apply]\n    obtain rfl | hij := Decidable.eq_or_ne i j\n    ¬∑ rw [orthogonalProjection_mem_subspace_eq_self, DFinsupp.single_eq_same]\n    ¬∑ rw [orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero,\n        DFinsupp.single_eq_of_ne hij.symm]\n      exact hV.isOrtho hij.symm x.prop\n  ¬∑ simp_rw [map_add]\n    exact congr_arg‚ÇÇ (¬∑ + ¬∑) hx hy\n\n"}
{"name":"maximal_orthonormal_iff_orthogonalComplement_eq_bot","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nv : Set E\nhv : Orthonormal ùïú Subtype.val\n‚ä¢ Iff (‚àÄ (u : Set E), Superset u v ‚Üí Orthonormal ùïú Subtype.val ‚Üí Eq u v) (Eq (Submodule.span ùïú v).orthogonal Bot.bot)","decl":"/-- An orthonormal set in an `InnerProductSpace` is maximal, if and only if the orthogonal\ncomplement of its span is empty. -/\ntheorem maximal_orthonormal_iff_orthogonalComplement_eq_bot (hv : Orthonormal ùïú ((‚Üë) : v ‚Üí E)) :\n    (‚àÄ u ‚äá v, Orthonormal ùïú ((‚Üë) : u ‚Üí E) ‚Üí u = v) ‚Üî (span ùïú v)·óÆ = ‚ä• := by\n  rw [Submodule.eq_bot_iff]\n  constructor\n  ¬∑ contrapose!\n    -- ** direction 1: nonempty orthogonal complement implies nonmaximal\n    rintro ‚ü®x, hx', hx‚ü©\n    -- take a nonzero vector and normalize it\n    let e := (‚Äñx‚Äñ‚Åª¬π : ùïú) ‚Ä¢ x\n    have he : ‚Äñe‚Äñ = 1 := by simp [e, norm_smul_inv_norm hx]\n    have he' : e ‚àà (span ùïú v)·óÆ := smul_mem' _ _ hx'\n    have he'' : e ‚àâ v := by\n      intro hev\n      have : e = 0 := by\n        have : e ‚àà span ùïú v ‚äì (span ùïú v)·óÆ := ‚ü®subset_span hev, he'‚ü©\n        simpa [(span ùïú v).inf_orthogonal_eq_bot] using this\n      have : e ‚â† 0 := hv.ne_zero ‚ü®e, hev‚ü©\n      contradiction\n    -- put this together with `v` to provide a candidate orthonormal basis for the whole space\n    refine ‚ü®insert e v, v.subset_insert e, ‚ü®?_, ?_‚ü©, (ne_insert_of_not_mem v he'').symm‚ü©\n    ¬∑ -- show that the elements of `insert e v` have unit length\n      rintro ‚ü®a, ha'‚ü©\n      cases' eq_or_mem_of_mem_insert ha' with ha ha\n      ¬∑ simp [ha, he]\n      ¬∑ exact hv.1 ‚ü®a, ha‚ü©\n    ¬∑ -- show that the elements of `insert e v` are orthogonal\n      have h_end : ‚àÄ a ‚àà v, ‚ü™a, e‚ü´ = 0 := by\n        intro a ha\n        exact he' a (Submodule.subset_span ha)\n      rintro ‚ü®a, ha'‚ü©\n      cases' eq_or_mem_of_mem_insert ha' with ha ha\n      ¬∑ rintro ‚ü®b, hb'‚ü© hab'\n        have hb : b ‚àà v := by\n          refine mem_of_mem_insert_of_ne hb' ?_\n          intro hbe'\n          apply hab'\n          simp [ha, hbe']\n        rw [inner_eq_zero_symm]\n        simpa [ha] using h_end b hb\n      rintro ‚ü®b, hb'‚ü© hab'\n      cases' eq_or_mem_of_mem_insert hb' with hb hb\n      ¬∑ simpa [hb] using h_end a ha\n      have : (‚ü®a, ha‚ü© : v) ‚â† ‚ü®b, hb‚ü© := by\n        intro hab''\n        apply hab'\n        simpa using hab''\n      exact hv.2 this\n  ¬∑ -- ** direction 2: empty orthogonal complement implies maximal\n    simp only [Subset.antisymm_iff]\n    rintro h u (huv : v ‚äÜ u) hu\n    refine ‚ü®?_, huv‚ü©\n    intro x hxu\n    refine ((mt (h x)) (hu.ne_zero ‚ü®x, hxu‚ü©)).imp_symm ?_\n    intro hxv y hy\n    have hxv' : (‚ü®x, hxu‚ü© : u) ‚àâ ((‚Üë) ‚Åª¬π' v : Set u) := by simp [huv, hxv]\n    obtain ‚ü®l, hl, rfl‚ü© :\n      ‚àÉ l ‚àà supported ùïú ùïú ((‚Üë) ‚Åª¬π' v : Set u), (linearCombination ùïú ((‚Üë) : u ‚Üí E)) l = y := by\n      rw [‚Üê Finsupp.mem_span_image_iff_linearCombination]\n      simp [huv, inter_eq_self_of_subset_right, hy]\n    exact hu.inner_finsupp_eq_zero hxv' hl\n\n"}
{"name":"maximal_orthonormal_iff_basis_of_finiteDimensional","module":"Mathlib.Analysis.InnerProductSpace.Projection","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : InnerProductSpace ùïú E\nv : Set E\ninst‚úù : FiniteDimensional ùïú E\nhv : Orthonormal ùïú Subtype.val\n‚ä¢ Iff (‚àÄ (u : Set E), Superset u v ‚Üí Orthonormal ùïú Subtype.val ‚Üí Eq u v) (Exists fun b => Eq (‚áëb) Subtype.val)","decl":"/-- An orthonormal set in a finite-dimensional `InnerProductSpace` is maximal, if and only if it\nis a basis. -/\ntheorem maximal_orthonormal_iff_basis_of_finiteDimensional (hv : Orthonormal ùïú ((‚Üë) : v ‚Üí E)) :\n    (‚àÄ u ‚äá v, Orthonormal ùïú ((‚Üë) : u ‚Üí E) ‚Üí u = v) ‚Üî ‚àÉ b : Basis v ùïú E, ‚áëb = ((‚Üë) : v ‚Üí E) := by\n  haveI := FiniteDimensional.proper_rclike ùïú (span ùïú v)\n  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hv]\n  rw [Submodule.orthogonal_eq_bot_iff]\n  have hv_coe : range ((‚Üë) : v ‚Üí E) = v := by simp\n  constructor\n  ¬∑ refine fun h => ‚ü®Basis.mk hv.linearIndependent _, Basis.coe_mk _ ?_‚ü©\n    convert h.ge\n  ¬∑ rintro ‚ü®h, coe_h‚ü©\n    rw [‚Üê h.span_eq, coe_h, hv_coe]\n\n"}
