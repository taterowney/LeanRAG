{"name":"SimpleGraph.Subgraph.IsMatching.toEdge_eq_of_adj","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG : SimpleGraph V\nM : G.Subgraph\nv w : V\nh : M.IsMatching\nhv : Membership.mem M.verts v\nhvw : M.Adj v w\n⊢ Eq (h.toEdge ⟨v, hv⟩) ⟨Sym2.mk { fst := v, snd := w }, hvw⟩","decl":"theorem IsMatching.toEdge_eq_of_adj (h : M.IsMatching) (hv : v ∈ M.verts) (hvw : M.Adj v w) :\n    h.toEdge ⟨v, hv⟩ = ⟨s(v, w), hvw⟩ := by\n  simp only [IsMatching.toEdge, Subtype.mk_eq_mk]\n  congr\n  exact ((h (M.edge_vert hvw)).choose_spec.2 w hvw).symm\n\n"}
{"name":"SimpleGraph.Subgraph.IsMatching.toEdge.surjective","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG : SimpleGraph V\nM : G.Subgraph\nh : M.IsMatching\n⊢ Function.Surjective h.toEdge","decl":"theorem IsMatching.toEdge.surjective (h : M.IsMatching) : Surjective h.toEdge := by\n  rintro ⟨e, he⟩\n  induction' e with x y\n  exact ⟨⟨x, M.edge_vert he⟩, h.toEdge_eq_of_adj _ he⟩\n\n"}
{"name":"SimpleGraph.Subgraph.IsMatching.toEdge_eq_toEdge_of_adj","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG : SimpleGraph V\nM : G.Subgraph\nv w : V\nh : M.IsMatching\nhv : Membership.mem M.verts v\nhw : Membership.mem M.verts w\nha : M.Adj v w\n⊢ Eq (h.toEdge ⟨v, hv⟩) (h.toEdge ⟨w, hw⟩)","decl":"theorem IsMatching.toEdge_eq_toEdge_of_adj (h : M.IsMatching)\n    (hv : v ∈ M.verts) (hw : w ∈ M.verts) (ha : M.Adj v w) :\n    h.toEdge ⟨v, hv⟩ = h.toEdge ⟨w, hw⟩ := by\n  rw [h.toEdge_eq_of_adj hv ha, h.toEdge_eq_of_adj hw (M.symm ha), Subtype.mk_eq_mk, Sym2.eq_swap]\n\n"}
{"name":"SimpleGraph.Subgraph.IsMatching.map_ofLE","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG G' : SimpleGraph V\nM : G.Subgraph\nh : M.IsMatching\nhGG' : LE.le G G'\n⊢ (SimpleGraph.Subgraph.map (SimpleGraph.Hom.ofLE hGG') M).IsMatching","decl":"lemma IsMatching.map_ofLE (h : M.IsMatching) (hGG' : G ≤ G') :\n    (M.map (Hom.ofLE hGG')).IsMatching := by\n  intro _ hv\n  obtain ⟨_, hv, hv'⟩ := Set.mem_image _ _ _ |>.mp hv\n  obtain ⟨w, hw⟩ := h hv\n  use w\n  simpa using hv' ▸ hw\n\n"}
{"name":"SimpleGraph.Subgraph.IsMatching.sup","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG : SimpleGraph V\nM M' : G.Subgraph\nhM : M.IsMatching\nhM' : M'.IsMatching\nhd : Disjoint M.support M'.support\n⊢ (Max.max M M').IsMatching","decl":"lemma IsMatching.sup (hM : M.IsMatching) (hM' : M'.IsMatching)\n    (hd : Disjoint M.support M'.support) : (M ⊔ M').IsMatching := by\n  intro v hv\n  have aux {N N' : Subgraph G} (hN : N.IsMatching) (hd : Disjoint N.support N'.support)\n    (hmN: v ∈ N.verts) : ∃! w, (N ⊔ N').Adj v w := by\n    obtain ⟨w, hw⟩ := hN hmN\n    use w\n    refine ⟨sup_adj.mpr (.inl hw.1), ?_⟩\n    intro y hy\n    cases hy with\n    | inl h => exact hw.2 y h\n    | inr h =>\n      rw [Set.disjoint_left] at hd\n      simpa [(mem_support _).mpr ⟨w, hw.1⟩, (mem_support _).mpr ⟨y, h⟩] using @hd v\n  cases Set.mem_or_mem_of_mem_union hv with\n  | inl hmM => exact aux hM hd hmM\n  | inr hmM' =>\n    rw [sup_comm]\n    exact aux hM' (Disjoint.symm hd) hmM'\n\n"}
{"name":"SimpleGraph.Subgraph.IsMatching.iSup","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG : SimpleGraph V\nι : Type u_3\nf : ι → G.Subgraph\nhM : ∀ (i : ι), (f i).IsMatching\nhd : Pairwise fun i j => Disjoint (f i).support (f j).support\n⊢ (iSup fun i => f i).IsMatching","decl":"lemma IsMatching.iSup {ι : Sort _} {f : ι → Subgraph G} (hM : (i : ι) → (f i).IsMatching)\n    (hd : Pairwise fun i j ↦ Disjoint (f i).support (f j).support) :\n    (⨆ i, f i).IsMatching := by\n  intro v hv\n  obtain ⟨i , hi⟩ := Set.mem_iUnion.mp (verts_iSup ▸ hv)\n  obtain ⟨w , hw⟩ := hM i hi\n  use w\n  refine ⟨iSup_adj.mpr ⟨i, hw.1⟩, ?_⟩\n  intro y hy\n  obtain ⟨i' , hi'⟩ := iSup_adj.mp hy\n  by_cases heq : i = i'\n  · exact hw.2 y (heq.symm ▸ hi')\n  · have := hd heq\n    simp only [Set.disjoint_left] at this\n    simpa [(mem_support _).mpr ⟨w, hw.1⟩, (mem_support _).mpr ⟨y, hi'⟩] using @this v\n\n"}
{"name":"SimpleGraph.Subgraph.IsMatching.subgraphOfAdj","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv w : V\nh : G.Adj v w\n⊢ (G.subgraphOfAdj h).IsMatching","decl":"lemma IsMatching.subgraphOfAdj (h : G.Adj v w) : (G.subgraphOfAdj h).IsMatching := by\n  intro _ hv\n  rw [subgraphOfAdj_verts, Set.mem_insert_iff, Set.mem_singleton_iff] at hv\n  cases hv with\n  | inl => use w; aesop\n  | inr => use v; aesop\n\n"}
{"name":"SimpleGraph.Subgraph.IsMatching.coeSubgraph","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG : SimpleGraph V\nG' : G.Subgraph\nM : G'.coe.Subgraph\nhM : M.IsMatching\n⊢ (SimpleGraph.Subgraph.coeSubgraph M).IsMatching","decl":"lemma IsMatching.coeSubgraph {G' : Subgraph G} {M : Subgraph G'.coe} (hM : M.IsMatching) :\n    M.coeSubgraph.IsMatching := by\n  intro _ hv\n  obtain ⟨w, hw⟩ := hM <| Set.mem_of_mem_image_val <| M.verts_coeSubgraph.symm ▸ hv\n  use w\n  refine ⟨?_, fun y hy => ?_⟩\n  · obtain ⟨v, hv⟩ := (Set.mem_image _ _ _).mp <| M.verts_coeSubgraph.symm ▸ hv\n    simp only [coeSubgraph_adj, Subtype.coe_eta, Subtype.coe_prop, exists_const]\n    exact ⟨hv.2 ▸ v.2, hw.1⟩\n  · obtain ⟨_, hw', hvw⟩ := (coeSubgraph_adj _ _ _).mp hy\n    rw [← hw.2 ⟨y, hw'⟩ hvw]\n\n"}
{"name":"SimpleGraph.Subgraph.IsMatching.exists_of_disjoint_sets_of_equiv","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns t : Set V\nh : Disjoint s t\nf : Equiv ↑s ↑t\nhadj : ∀ (v : ↑s), G.Adj ↑v ↑(f v)\n⊢ Exists fun M => And (Eq M.verts (Union.union s t)) M.IsMatching","decl":"lemma IsMatching.exists_of_disjoint_sets_of_equiv {s t : Set V} (h : Disjoint s t)\n    (f : s ≃ t) (hadj : ∀ v : s, G.Adj v (f v)) :\n    ∃ M : Subgraph G, M.verts = s ∪ t ∧ M.IsMatching := by\n  use {\n    verts := s ∪ t\n    Adj := fun v w ↦ (∃ h : v ∈ s, f ⟨v, h⟩ = w) ∨ (∃ h : w ∈ s, f ⟨w, h⟩ = v)\n    adj_sub := by\n      intro v w h\n      obtain (⟨hv, rfl⟩ | ⟨hw, rfl⟩) := h\n      · exact hadj ⟨v, _⟩\n      · exact (hadj ⟨w, _⟩).symm\n    edge_vert := by aesop }\n\n  simp only [Subgraph.IsMatching, Set.mem_union, true_and]\n  intro v hv\n  cases' hv with hl hr\n  · use f ⟨v, hl⟩\n    simp only [hl, exists_const, true_or, exists_true_left, true_and]\n    rintro y (rfl | ⟨hys, rfl⟩)\n    · rfl\n    · exact (h.ne_of_mem hl (f ⟨y, hys⟩).coe_prop rfl).elim\n  · use f.symm ⟨v, hr⟩\n    simp only [Subtype.coe_eta, Equiv.apply_symm_apply, Subtype.coe_prop, exists_const, or_true,\n      true_and]\n    rintro y (⟨hy, rfl⟩ | ⟨hy, rfl⟩)\n    · exact (h.ne_of_mem hy hr rfl).elim\n    · simp\n\n"}
{"name":"SimpleGraph.Subgraph.IsMatching.map","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nM : G.Subgraph\nf : G.Hom G'\nhf : Function.Injective ⇑f\nhM : M.IsMatching\n⊢ (SimpleGraph.Subgraph.map f M).IsMatching","decl":"protected lemma IsMatching.map {G' : SimpleGraph W} {M : Subgraph G} (f : G →g G')\n    (hf : Injective f) (hM : M.IsMatching) : (M.map f).IsMatching := by\n  rintro _ ⟨v, hv, rfl⟩\n  obtain ⟨v', hv'⟩ := hM hv\n  use f v'\n  refine ⟨⟨v, v', hv'.1, rfl, rfl⟩, ?_⟩\n  rintro _ ⟨w, w', hw, hw', rfl⟩\n  cases hf hw'.symm\n  rw [hv'.2 w' hw]\n\n"}
{"name":"SimpleGraph.Subgraph.Iso.isMatching_map","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nM : G.Subgraph\nf : G.Iso G'\n⊢ Iff (SimpleGraph.Subgraph.map f.toHom M).IsMatching M.IsMatching","decl":"@[simp]\nlemma Iso.isMatching_map {G' : SimpleGraph W} {M : Subgraph G} (f : G ≃g G') :\n    (M.map f.toHom).IsMatching ↔ M.IsMatching where\n   mp h := by simpa [← map_comp] using h.map f.symm.toHom f.symm.injective\n   mpr := .map f.toHom f.injective\n\n"}
{"name":"SimpleGraph.Subgraph.IsMatching.support_eq_verts","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG : SimpleGraph V\nM : G.Subgraph\nh : M.IsMatching\n⊢ Eq M.support M.verts","decl":"theorem IsMatching.support_eq_verts (h : M.IsMatching) : M.support = M.verts := by\n  refine M.support_subset_verts.antisymm fun v hv => ?_\n  obtain ⟨w, hvw, -⟩ := h hv\n  exact ⟨_, hvw⟩\n\n"}
{"name":"SimpleGraph.Subgraph.isMatching_iff_forall_degree","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG : SimpleGraph V\nM : G.Subgraph\ninst✝ : (v : V) → Fintype ↑(M.neighborSet v)\n⊢ Iff M.IsMatching (∀ (v : V), Membership.mem M.verts v → Eq (M.degree v) 1)","decl":"theorem isMatching_iff_forall_degree [∀ v, Fintype (M.neighborSet v)] :\n    M.IsMatching ↔ ∀ v : V, v ∈ M.verts → M.degree v = 1 := by\n  simp only [degree_eq_one_iff_unique_adj, IsMatching]\n\n"}
{"name":"SimpleGraph.Subgraph.IsMatching.even_card","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG : SimpleGraph V\nM : G.Subgraph\ninst✝ : Fintype ↑M.verts\nh : M.IsMatching\n⊢ Even M.verts.toFinset.card","decl":"theorem IsMatching.even_card [Fintype M.verts] (h : M.IsMatching) : Even M.verts.toFinset.card := by\n  classical\n  rw [isMatching_iff_forall_degree] at h\n  use M.coe.edgeFinset.card\n  rw [← two_mul, ← M.coe.sum_degrees_eq_twice_card_edges]\n  -- Porting note: `SimpleGraph.Subgraph.coe_degree` does not trigger because it uses\n  -- instance arguments instead of implicit arguments for the first `Fintype` argument.\n  -- Using a `convert_to` to swap out the `Fintype` instance to the \"right\" one.\n  convert_to _ = Finset.sum Finset.univ fun v => SimpleGraph.degree (Subgraph.coe M) v using 3\n  simp [h, Finset.card_univ]\n\n"}
{"name":"SimpleGraph.Subgraph.isPerfectMatching_iff","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG : SimpleGraph V\nM : G.Subgraph\n⊢ Iff M.IsPerfectMatching (∀ (v : V), ExistsUnique fun w => M.Adj v w)","decl":"theorem isPerfectMatching_iff : M.IsPerfectMatching ↔ ∀ v, ∃! w, M.Adj v w := by\n  refine ⟨?_, fun hm => ⟨fun v _ => hm v, fun v => ?_⟩⟩\n  · rintro ⟨hm, hs⟩ v\n    exact hm (hs v)\n  · obtain ⟨w, hw, -⟩ := hm v\n    exact M.edge_vert hw\n\n"}
{"name":"SimpleGraph.Subgraph.isPerfectMatching_iff_forall_degree","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG : SimpleGraph V\nM : G.Subgraph\ninst✝ : (v : V) → Fintype ↑(M.neighborSet v)\n⊢ Iff M.IsPerfectMatching (∀ (v : V), Eq (M.degree v) 1)","decl":"theorem isPerfectMatching_iff_forall_degree [∀ v, Fintype (M.neighborSet v)] :\n    M.IsPerfectMatching ↔ ∀ v, M.degree v = 1 := by\n  simp [degree_eq_one_iff_unique_adj, isPerfectMatching_iff]\n\n"}
{"name":"SimpleGraph.Subgraph.IsPerfectMatching.even_card","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG : SimpleGraph V\nM : G.Subgraph\ninst✝ : Fintype V\nh : M.IsPerfectMatching\n⊢ Even (Fintype.card V)","decl":"theorem IsPerfectMatching.even_card [Fintype V] (h : M.IsPerfectMatching) :\n    Even (Fintype.card V) := by\n  classical\n  simpa only [h.2.card_verts] using IsMatching.even_card h.1\n\n"}
{"name":"SimpleGraph.Subgraph.IsMatching.induce_connectedComponent","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG : SimpleGraph V\nM : G.Subgraph\nh : M.IsMatching\nc : G.ConnectedComponent\n⊢ (M.induce (Inter.inter M.verts c.supp)).IsMatching","decl":"lemma IsMatching.induce_connectedComponent (h : M.IsMatching) (c : ConnectedComponent G) :\n    (M.induce (M.verts ∩ c.supp)).IsMatching := by\n  intro _ hv\n  obtain ⟨hv, rfl⟩ := hv\n  obtain ⟨w, hvw, hw⟩ := h hv\n  use w\n  simpa [hv, hvw, M.edge_vert hvw.symm, (M.adj_sub hvw).symm.reachable] using fun _ _ _ ↦ hw _\n\n"}
{"name":"SimpleGraph.Subgraph.IsPerfectMatching.induce_connectedComponent_isMatching","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG : SimpleGraph V\nM : G.Subgraph\nh : M.IsPerfectMatching\nc : G.ConnectedComponent\n⊢ (M.induce c.supp).IsMatching","decl":"lemma IsPerfectMatching.induce_connectedComponent_isMatching (h : M.IsPerfectMatching)\n    (c : ConnectedComponent G) : (M.induce c.supp).IsMatching := by\n  simpa [h.2.verts_eq_univ] using h.1.induce_connectedComponent c\n\n"}
{"name":"SimpleGraph.Subgraph.IsPerfectMatching.toSubgraph_iff","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG G' : SimpleGraph V\nM : G.Subgraph\nh : LE.le M.spanningCoe G'\n⊢ Iff (SimpleGraph.toSubgraph M.spanningCoe h).IsPerfectMatching M.IsPerfectMatching","decl":"@[simp]\nlemma IsPerfectMatching.toSubgraph_iff (h : M.spanningCoe ≤ G') :\n    (G'.toSubgraph M.spanningCoe h).IsPerfectMatching ↔ M.IsPerfectMatching := by\n  simp only [isPerfectMatching_iff, toSubgraph_adj, spanningCoe_adj]\n\n"}
{"name":"SimpleGraph.ConnectedComponent.even_card_of_isPerfectMatching","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG : SimpleGraph V\nM : G.Subgraph\ninst✝² : Fintype V\ninst✝¹ : DecidableEq V\ninst✝ : DecidableRel G.Adj\nc : G.ConnectedComponent\nhM : M.IsPerfectMatching\n⊢ Even (Fintype.card ↑c.supp)","decl":"lemma even_card_of_isPerfectMatching [Fintype V] [DecidableEq V] [DecidableRel G.Adj]\n    (c : ConnectedComponent G) (hM : M.IsPerfectMatching) :\n    Even (Fintype.card c.supp) := by\n  #adaptation_note /-- https://github.com/leanprover/lean4/pull/5020\n  some instances that use the chain of coercions\n  `[SetLike X], X → Set α → Sort _` are\n  blocked by the discrimination tree. This can be fixed by redeclaring the instance for `X`\n  using the double coercion but the proper fix seems to avoid the double coercion. -/\n  letI : DecidablePred fun x ↦ x ∈ (M.induce c.supp).verts := fun a ↦ G.instDecidableMemSupp c a\n  simpa using (hM.induce_connectedComponent_isMatching c).even_card\n\n"}
{"name":"SimpleGraph.ConnectedComponent.odd_matches_node_outside","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG : SimpleGraph V\nM : G.Subgraph\ninst✝ : Finite V\nu : Set V\nc : (Top.top.deleteVerts u).coe.ConnectedComponent\nhM : M.IsPerfectMatching\ncodd : Odd (Nat.card ↑c.supp)\n⊢ Exists fun w => And (Membership.mem u w) (Exists fun v => And (M.Adj (↑v) w) (Membership.mem c.supp v))","decl":"lemma odd_matches_node_outside [Finite V] {u : Set V}\n    {c : ConnectedComponent (Subgraph.deleteVerts ⊤ u).coe}\n    (hM : M.IsPerfectMatching) (codd : Odd (Nat.card c.supp)) :\n    ∃ᵉ (w ∈ u) (v : ((⊤ : G.Subgraph).deleteVerts u).verts), M.Adj v w ∧ v ∈ c.supp := by\n  by_contra! h\n  have hMmatch : (M.induce c.supp).IsMatching := by\n    intro v hv\n    obtain ⟨w, hw⟩ := hM.1 (hM.2 v)\n    obtain ⟨⟨v', hv'⟩, ⟨hv , rfl⟩⟩ := hv\n    use w\n    have hwnu : w ∉ u := fun hw' ↦ h w hw' ⟨v', hv'⟩ (hw.1) hv\n    refine ⟨⟨⟨⟨v', hv'⟩, hv, rfl⟩, ?_, hw.1⟩, fun _ hy ↦ hw.2 _ hy.2.2⟩\n    apply ConnectedComponent.mem_coe_supp_of_adj ⟨⟨v', hv'⟩, ⟨hv, rfl⟩⟩ ⟨by trivial, hwnu⟩\n    simp only [Subgraph.induce_verts, Subgraph.verts_top, Set.mem_diff, Set.mem_univ, true_and,\n      Subgraph.induce_adj, hwnu, not_false_eq_true, and_self, Subgraph.top_adj, M.adj_sub hw.1,\n      and_true] at hv' ⊢\n    trivial\n  apply Nat.not_even_iff_odd.2 codd\n  haveI : Fintype ↑(Subgraph.induce M (Subtype.val '' supp c)).verts := Fintype.ofFinite _\n  classical\n  have hMeven := Subgraph.IsMatching.even_card hMmatch\n  haveI : Fintype (c.supp) := Fintype.ofFinite _\n  simp only [Subgraph.induce_verts, Subgraph.verts_top, Set.toFinset_image,\n    Nat.card_eq_fintype_card, Set.toFinset_image,\n    Finset.card_image_of_injective _ (Subtype.val_injective), Set.toFinset_card] at hMeven ⊢\n  exact hMeven\n\n"}
{"name":"SimpleGraph.IsMatchingFree.mono","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG G' : SimpleGraph V\nh : LE.le G G'\nhmf : G'.IsMatchingFree\n⊢ G.IsMatchingFree","decl":"lemma IsMatchingFree.mono {G G' : SimpleGraph V} (h : G ≤ G') (hmf : G'.IsMatchingFree) :\n    G.IsMatchingFree := by\n  intro x\n  by_contra! hc\n  apply hmf (x.map (SimpleGraph.Hom.ofLE h))\n  refine ⟨hc.1.map_ofLE h, ?_⟩\n  intro v\n  simp only [Subgraph.map_verts, Hom.coe_ofLE, id_eq, Set.image_id']\n  exact hc.2 v\n\n"}
{"name":"SimpleGraph.exists_maximal_isMatchingFree","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝ : Finite V\nh : G.IsMatchingFree\n⊢ Exists fun Gmax => And (LE.le G Gmax) (And Gmax.IsMatchingFree (∀ (G' : SimpleGraph V), GT.gt G' Gmax → Exists fun M => M.IsPerfectMatching))","decl":"lemma exists_maximal_isMatchingFree [Finite V] (h : G.IsMatchingFree) :\n    ∃ Gmax : SimpleGraph V, G ≤ Gmax ∧ Gmax.IsMatchingFree ∧\n      ∀ G', G' > Gmax → ∃ M : Subgraph G', M.IsPerfectMatching := by\n  simp_rw [← @not_forall_not _ Subgraph.IsPerfectMatching]\n  obtain ⟨Gmax, hGmax⟩ := Finite.exists_le_maximal h\n  exact ⟨Gmax, ⟨hGmax.1, ⟨hGmax.2.prop, fun _ h' ↦ hGmax.2.not_prop_of_gt h'⟩⟩⟩\n\n"}
{"name":"SimpleGraph.IsCycles.other_adj_of_adj","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv w : V\nh : G.IsCycles\nhadj : G.Adj v w\n⊢ Exists fun w' => And (Ne w w') (G.Adj v w')","decl":"/--\nGiven a vertex with one edge in a graph of cycles this gives the other edge incident\nto the same vertex.\n-/\nlemma IsCycles.other_adj_of_adj (h : G.IsCycles) (hadj : G.Adj v w) :\n    ∃ w', w ≠ w' ∧ G.Adj v w' := by\n  simp_rw [← SimpleGraph.mem_neighborSet] at hadj ⊢\n  have := h ⟨w, hadj⟩\n  obtain ⟨w', hww'⟩ := (G.neighborSet v).exists_ne_of_one_lt_ncard (by omega) w\n  exact ⟨w', ⟨hww'.2.symm, hww'.1⟩⟩\n\n"}
{"name":"SimpleGraph.IsCycles.induce_supp","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG : SimpleGraph V\nc : G.ConnectedComponent\nh : G.IsCycles\n⊢ (SimpleGraph.induce c.supp G).spanningCoe.IsCycles","decl":"lemma IsCycles.induce_supp (c : G.ConnectedComponent) (h : G.IsCycles) :\n    (G.induce c.supp).spanningCoe.IsCycles := by\n  intro v ⟨w, hw⟩\n  rw [mem_neighborSet, c.adj_spanningCoe_induce_supp] at hw\n  rw [← h ⟨w, hw.2⟩]\n  congr\n  ext w'\n  simp only [mem_neighborSet, c.adj_spanningCoe_induce_supp, hw, true_and]\n\n"}
{"name":"SimpleGraph.Subgraph.IsPerfectMatching.symmDiff_isCycles","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG G' : SimpleGraph V\nM : G.Subgraph\nM' : G'.Subgraph\nhM : M.IsPerfectMatching\nhM' : M'.IsPerfectMatching\n⊢ (symmDiff M.spanningCoe M'.spanningCoe).IsCycles","decl":"lemma Subgraph.IsPerfectMatching.symmDiff_isCycles\n    {M : Subgraph G} {M' : Subgraph G'} (hM : M.IsPerfectMatching)\n    (hM' : M'.IsPerfectMatching) : (M.spanningCoe ∆ M'.spanningCoe).IsCycles := by\n  intro v\n  obtain ⟨w, hw⟩ := hM.1 (hM.2 v)\n  obtain ⟨w', hw'⟩ := hM'.1 (hM'.2 v)\n  simp only [symmDiff_def, Set.ncard_eq_two, ne_eq, imp_iff_not_or, Set.not_nonempty_iff_eq_empty,\n    Set.eq_empty_iff_forall_not_mem, SimpleGraph.mem_neighborSet, SimpleGraph.sup_adj, sdiff_adj,\n    spanningCoe_adj, not_or, not_and, not_not]\n  by_cases hww' : w = w'\n  · simp_all [← imp_iff_not_or, hww']\n  · right\n    use w, w'\n    aesop\n\n"}
{"name":"SimpleGraph.IsAlternating.mono","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG G' G'' : SimpleGraph V\nhalt : G.IsAlternating G'\nh : LE.le G'' G\n⊢ G''.IsAlternating G'","decl":"lemma IsAlternating.mono {G'' : SimpleGraph V} (halt : G.IsAlternating G') (h : G'' ≤ G) :\n    G''.IsAlternating G' := fun _ _ _ hww' hvw hvw' ↦ halt hww' (h hvw) (h hvw')\n\n"}
{"name":"SimpleGraph.IsPerfectMatching.symmDiff_of_isAlternating","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG G' : SimpleGraph V\nM : G.Subgraph\nhM : M.IsPerfectMatching\nhG' : G'.IsAlternating M.spanningCoe\nhG'cyc : G'.IsCycles\n⊢ Top.top.IsPerfectMatching","decl":"lemma IsPerfectMatching.symmDiff_of_isAlternating (hM : M.IsPerfectMatching)\n    (hG' : G'.IsAlternating M.spanningCoe) (hG'cyc : G'.IsCycles) :\n    (⊤ : Subgraph (M.spanningCoe ∆ G')).IsPerfectMatching := by\n  rw [Subgraph.isPerfectMatching_iff]\n  intro v\n  simp only [toSubgraph_adj, symmDiff_def, sup_adj, sdiff_adj, Subgraph.spanningCoe_adj]\n  obtain ⟨w, hw⟩ := hM.1 (hM.2 v)\n  by_cases h : G'.Adj v w\n  · obtain ⟨w', hw'⟩ := hG'cyc.other_adj_of_adj h\n    have hmadj :  M.Adj v w ↔ ¬M.Adj v w' := by simpa using hG' hw'.1 h hw'.2\n    use w'\n    simp only [Subgraph.top_adj, sup_adj, sdiff_adj, Subgraph.spanningCoe_adj, hmadj.mp hw.1, hw'.2,\n      not_true_eq_false, and_self, not_false_eq_true, or_true, true_and]\n    rintro y (hl | hr)\n    · aesop\n    · obtain ⟨w'', hw''⟩ := hG'cyc.other_adj_of_adj hr.1\n      by_contra! hc\n      simp_all [show M.Adj v y ↔ ¬M.Adj v w' from by simpa using hG' hc hr.1 hw'.2]\n  · use w\n    simp only [Subgraph.top_adj, sup_adj, sdiff_adj, Subgraph.spanningCoe_adj, hw.1, h,\n      not_false_eq_true, and_self, not_true_eq_false, or_false, true_and]\n    rintro y (hl | hr)\n    · exact hw.2 _ hl.1\n    · have ⟨w', hw'⟩ := hG'cyc.other_adj_of_adj hr.1\n      simp_all [show M.Adj v y ↔ ¬M.Adj v w' from by simpa using hG' hw'.1 hr.1 hw'.2]\n\n"}
{"name":"SimpleGraph.IsPerfectMatching.isAlternating_symmDiff_left","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG G' : SimpleGraph V\nM : G.Subgraph\nM' : G'.Subgraph\nhM : M.IsPerfectMatching\nhM' : M'.IsPerfectMatching\n⊢ (symmDiff M.spanningCoe M'.spanningCoe).IsAlternating M.spanningCoe","decl":"lemma IsPerfectMatching.isAlternating_symmDiff_left {M' : Subgraph G'}\n    (hM : M.IsPerfectMatching) (hM' : M'.IsPerfectMatching) :\n    (M.spanningCoe ∆ M'.spanningCoe).IsAlternating M.spanningCoe := by\n  intro v w w' hww' hvw hvw'\n  obtain ⟨v1, hm1, hv1⟩ := hM.1 (hM.2 v)\n  obtain ⟨v2, hm2, hv2⟩ := hM'.1 (hM'.2 v)\n  simp only [symmDiff_def] at *\n  aesop\n\n"}
{"name":"SimpleGraph.IsPerfectMatching.isAlternating_symmDiff_right","module":"Mathlib.Combinatorics.SimpleGraph.Matching","initialProofState":"V : Type u_1\nG G' : SimpleGraph V\nM : G.Subgraph\nM' : G'.Subgraph\nhM : M.IsPerfectMatching\nhM' : M'.IsPerfectMatching\n⊢ (symmDiff M.spanningCoe M'.spanningCoe).IsAlternating M'.spanningCoe","decl":"lemma IsPerfectMatching.isAlternating_symmDiff_right\n    {M' : Subgraph G'} (hM : M.IsPerfectMatching) (hM' : M'.IsPerfectMatching) :\n    (M.spanningCoe ∆ M'.spanningCoe).IsAlternating M'.spanningCoe := by\n  simpa [symmDiff_comm] using isAlternating_symmDiff_left hM' hM\n\n"}
