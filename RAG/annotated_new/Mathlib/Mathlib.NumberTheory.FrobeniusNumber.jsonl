{"name":"frobeniusNumber_pair","module":"Mathlib.NumberTheory.FrobeniusNumber","initialProofState":"m n : Nat\ncop : m.Coprime n\nhm : LT.lt 1 m\nhn : LT.lt 1 n\n⊢ FrobeniusNumber (HSub.hSub (HSub.hSub (HMul.hMul m n) m) n) (Insert.insert m (Singleton.singleton n))","decl":"/-- The **Chicken McNugget theorem** stating that the Frobenius number\n  of positive numbers `m` and `n` is `m * n - m - n`. -/\ntheorem frobeniusNumber_pair (cop : Coprime m n) (hm : 1 < m) (hn : 1 < n) :\n    FrobeniusNumber (m * n - m - n) {m, n} := by\n  simp_rw [FrobeniusNumber, AddSubmonoid.mem_closure_pair]\n  have hmn : m + n ≤ m * n := add_le_mul hm hn\n  constructor\n  · push_neg\n    intro a b h\n    apply cop.mul_add_mul_ne_mul (add_one_ne_zero a) (add_one_ne_zero b)\n    simp only [Nat.sub_sub, smul_eq_mul] at h\n    zify [hmn] at h ⊢\n    rw [← sub_eq_zero] at h ⊢\n    rw [← h]\n    ring\n  · intro k hk\n    dsimp at hk\n    contrapose! hk\n    let x := chineseRemainder cop 0 k\n    have hx : x.val < m * n := chineseRemainder_lt_mul cop 0 k (ne_bot_of_gt hm) (ne_bot_of_gt hn)\n    suffices key : x.1 ≤ k by\n      obtain ⟨a, ha⟩ := modEq_zero_iff_dvd.mp x.2.1\n      obtain ⟨b, hb⟩ := (modEq_iff_dvd' key).mp x.2.2\n      exact ⟨a, b, by rw [mul_comm, ← ha, mul_comm, ← hb, Nat.add_sub_of_le key]⟩\n    refine ModEq.le_of_lt_add x.2.2 (lt_of_le_of_lt ?_ (add_lt_add_right hk n))\n    rw [Nat.sub_add_cancel (le_tsub_of_add_le_left hmn)]\n    exact\n      ModEq.le_of_lt_add\n        (x.2.1.trans (modEq_zero_iff_dvd.mpr (Nat.dvd_sub' (dvd_mul_right m n) dvd_rfl)).symm)\n        (lt_of_lt_of_le hx le_tsub_add)\n"}
