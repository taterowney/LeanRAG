{"name":"WithTop.coe_zero","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Zero α\n⊢ Eq (↑0) 0","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_one : ((1 : α) : WithTop α) = 1 :=\n  rfl\n\n"}
{"name":"WithTop.coe_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : One α\n⊢ Eq (↑1) 1","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_one : ((1 : α) : WithTop α) = 1 :=\n  rfl\n\n"}
{"name":"WithTop.coe_eq_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : One α\na : α\n⊢ Iff (Eq (↑a) 1) (Eq a 1)","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma coe_eq_one : (a : WithTop α) = 1 ↔ a = 1 := coe_eq_coe\n\n"}
{"name":"WithTop.coe_eq_zero","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Zero α\na : α\n⊢ Iff (Eq (↑a) 0) (Eq a 0)","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma coe_eq_one : (a : WithTop α) = 1 ↔ a = 1 := coe_eq_coe\n\n"}
{"name":"WithTop.one_eq_coe","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : One α\na : α\n⊢ Iff (Eq 1 ↑a) (Eq a 1)","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma one_eq_coe : 1 = (a : WithTop α) ↔ a = 1 := eq_comm.trans coe_eq_one\n\n"}
{"name":"WithTop.zero_eq_coe","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Zero α\na : α\n⊢ Iff (Eq 0 ↑a) (Eq a 0)","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma one_eq_coe : 1 = (a : WithTop α) ↔ a = 1 := eq_comm.trans coe_eq_one\n\n"}
{"name":"WithTop.top_ne_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : One α\n⊢ Ne Top.top 1","decl":"@[to_additive (attr := simp)] lemma top_ne_one : (⊤ : WithTop α) ≠ 1 := top_ne_coe\n\n"}
{"name":"WithTop.top_ne_zero","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Zero α\n⊢ Ne Top.top 0","decl":"@[to_additive (attr := simp)] lemma top_ne_one : (⊤ : WithTop α) ≠ 1 := top_ne_coe\n\n"}
{"name":"WithTop.one_ne_top","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : One α\n⊢ Ne 1 Top.top","decl":"@[to_additive (attr := simp)] lemma one_ne_top : (1 : WithTop α) ≠ ⊤ := coe_ne_top\n\n"}
{"name":"WithTop.zero_ne_top","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Zero α\n⊢ Ne 0 Top.top","decl":"@[to_additive (attr := simp)] lemma one_ne_top : (1 : WithTop α) ≠ ⊤ := coe_ne_top\n\n"}
{"name":"WithTop.untop_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : One α\n⊢ Eq (WithTop.untop 1 ⋯) 1","decl":"@[to_additive (attr := simp)]\ntheorem untop_one : (1 : WithTop α).untop coe_ne_top = 1 :=\n  rfl\n\n"}
{"name":"WithTop.untop_zero","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Zero α\n⊢ Eq (WithTop.untop 0 ⋯) 0","decl":"@[to_additive (attr := simp)]\ntheorem untop_one : (1 : WithTop α).untop coe_ne_top = 1 :=\n  rfl\n\n"}
{"name":"WithTop.untop_zero'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Zero α\nd : α\n⊢ Eq (WithTop.untop' d 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem untop_one' (d : α) : (1 : WithTop α).untop' d = 1 :=\n  rfl\n\n"}
{"name":"WithTop.untop_one'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : One α\nd : α\n⊢ Eq (WithTop.untop' d 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem untop_one' (d : α) : (1 : WithTop α).untop' d = 1 :=\n  rfl\n\n"}
{"name":"WithTop.coe_nonneg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : Zero α\ninst✝ : LE α\na : α\n⊢ Iff (LE.le 0 ↑a) (LE.le 0 a)","decl":"@[to_additive (attr := simp, norm_cast) coe_nonneg]\ntheorem one_le_coe [LE α] {a : α} : 1 ≤ (a : WithTop α) ↔ 1 ≤ a :=\n  coe_le_coe\n\n"}
{"name":"WithTop.one_le_coe","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : One α\ninst✝ : LE α\na : α\n⊢ Iff (LE.le 1 ↑a) (LE.le 1 a)","decl":"@[to_additive (attr := simp, norm_cast) coe_nonneg]\ntheorem one_le_coe [LE α] {a : α} : 1 ≤ (a : WithTop α) ↔ 1 ≤ a :=\n  coe_le_coe\n\n"}
{"name":"WithTop.coe_le_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : One α\ninst✝ : LE α\na : α\n⊢ Iff (LE.le (↑a) 1) (LE.le a 1)","decl":"@[to_additive (attr := simp, norm_cast) coe_le_zero]\ntheorem coe_le_one [LE α] {a : α} : (a : WithTop α) ≤ 1 ↔ a ≤ 1 :=\n  coe_le_coe\n\n"}
{"name":"WithTop.coe_le_zero","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : Zero α\ninst✝ : LE α\na : α\n⊢ Iff (LE.le (↑a) 0) (LE.le a 0)","decl":"@[to_additive (attr := simp, norm_cast) coe_le_zero]\ntheorem coe_le_one [LE α] {a : α} : (a : WithTop α) ≤ 1 ↔ a ≤ 1 :=\n  coe_le_coe\n\n"}
{"name":"WithTop.one_lt_coe","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : One α\ninst✝ : LT α\na : α\n⊢ Iff (LT.lt 1 ↑a) (LT.lt 1 a)","decl":"@[to_additive (attr := simp, norm_cast) coe_pos]\ntheorem one_lt_coe [LT α] {a : α} : 1 < (a : WithTop α) ↔ 1 < a :=\n  coe_lt_coe\n\n"}
{"name":"WithTop.coe_pos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : Zero α\ninst✝ : LT α\na : α\n⊢ Iff (LT.lt 0 ↑a) (LT.lt 0 a)","decl":"@[to_additive (attr := simp, norm_cast) coe_pos]\ntheorem one_lt_coe [LT α] {a : α} : 1 < (a : WithTop α) ↔ 1 < a :=\n  coe_lt_coe\n\n"}
{"name":"WithTop.coe_lt_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : One α\ninst✝ : LT α\na : α\n⊢ Iff (LT.lt (↑a) 1) (LT.lt a 1)","decl":"@[to_additive (attr := simp, norm_cast) coe_lt_zero]\ntheorem coe_lt_one [LT α] {a : α} : (a : WithTop α) < 1 ↔ a < 1 :=\n  coe_lt_coe\n\n"}
{"name":"WithTop.coe_lt_zero","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : Zero α\ninst✝ : LT α\na : α\n⊢ Iff (LT.lt (↑a) 0) (LT.lt a 0)","decl":"@[to_additive (attr := simp, norm_cast) coe_lt_zero]\ntheorem coe_lt_one [LT α] {a : α} : (a : WithTop α) < 1 ↔ a < 1 :=\n  coe_lt_coe\n\n"}
{"name":"WithTop.map_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : One α\nβ : Type u_1\nf : α → β\n⊢ Eq (WithTop.map f 1) ↑(f 1)","decl":"@[to_additive (attr := simp)]\nprotected theorem map_one {β} (f : α → β) : (1 : WithTop α).map f = (f 1 : WithTop β) :=\n  rfl\n\n"}
{"name":"WithTop.map_zero","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Zero α\nβ : Type u_1\nf : α → β\n⊢ Eq (WithTop.map f 0) ↑(f 0)","decl":"@[to_additive (attr := simp)]\nprotected theorem map_one {β} (f : α → β) : (1 : WithTop α).map f = (f 1 : WithTop β) :=\n  rfl\n\n"}
{"name":"WithTop.map_eq_zero_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"β : Type v\nα : Type u_1\nf : α → β\nv : WithTop α\ninst✝ : Zero β\n⊢ Iff (Eq (WithTop.map f v) 0) (Exists fun x => And (Eq v ↑x) (Eq (f x) 0))","decl":"@[to_additive]\ntheorem map_eq_one_iff {α} {f : α → β} {v : WithTop α} [One β] :\n    WithTop.map f v = 1 ↔ ∃ x, v = .some x ∧ f x = 1 := map_eq_some_iff\n\n"}
{"name":"WithTop.map_eq_one_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"β : Type v\nα : Type u_1\nf : α → β\nv : WithTop α\ninst✝ : One β\n⊢ Iff (Eq (WithTop.map f v) 1) (Exists fun x => And (Eq v ↑x) (Eq (f x) 1))","decl":"@[to_additive]\ntheorem map_eq_one_iff {α} {f : α → β} {v : WithTop α} [One β] :\n    WithTop.map f v = 1 ↔ ∃ x, v = .some x ∧ f x = 1 := map_eq_some_iff\n\n"}
{"name":"WithTop.one_eq_map_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"β : Type v\nα : Type u_1\nf : α → β\nv : WithTop α\ninst✝ : One β\n⊢ Iff (Eq 1 (WithTop.map f v)) (Exists fun x => And (Eq v ↑x) (Eq (f x) 1))","decl":"@[to_additive]\ntheorem one_eq_map_iff {α} {f : α → β} {v : WithTop α} [One β] :\n    1 = WithTop.map f v ↔ ∃ x, v = .some x ∧ f x = 1 := some_eq_map_iff\n\n"}
{"name":"WithTop.zero_eq_map_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"β : Type v\nα : Type u_1\nf : α → β\nv : WithTop α\ninst✝ : Zero β\n⊢ Iff (Eq 0 (WithTop.map f v)) (Exists fun x => And (Eq v ↑x) (Eq (f x) 0))","decl":"@[to_additive]\ntheorem one_eq_map_iff {α} {f : α → β} {v : WithTop α} [One β] :\n    1 = WithTop.map f v ↔ ∃ x, v = .some x ∧ f x = 1 := some_eq_map_iff\n\n"}
{"name":"WithTop.zeroLEOneClass","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝³ : One α\ninst✝² : Zero α\ninst✝¹ : LE α\ninst✝ : ZeroLEOneClass α\n⊢ ZeroLEOneClass (WithTop α)","decl":"instance zeroLEOneClass [Zero α] [LE α] [ZeroLEOneClass α] : ZeroLEOneClass (WithTop α) :=\n  ⟨coe_le_coe.2 zero_le_one⟩\n\n"}
{"name":"WithTop.coe_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Add α\na b : α\n⊢ Eq (↑(HAdd.hAdd a b)) (HAdd.hAdd ↑a ↑b)","decl":"@[simp, norm_cast] lemma coe_add (a b : α) : ↑(a + b) = (a + b : WithTop α) := rfl\n\n"}
{"name":"WithTop.top_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Add α\na : WithTop α\n⊢ Eq (HAdd.hAdd Top.top a) Top.top","decl":"@[simp]\ntheorem top_add (a : WithTop α) : ⊤ + a = ⊤ :=\n  rfl\n\n"}
{"name":"WithTop.add_top","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Add α\na : WithTop α\n⊢ Eq (HAdd.hAdd a Top.top) Top.top","decl":"@[simp]\ntheorem add_top (a : WithTop α) : a + ⊤ = ⊤ := by cases a <;> rfl\n\n"}
{"name":"WithTop.add_eq_top","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Add α\na b : WithTop α\n⊢ Iff (Eq (HAdd.hAdd a b) Top.top) (Or (Eq a Top.top) (Eq b Top.top))","decl":"@[simp]\ntheorem add_eq_top : a + b = ⊤ ↔ a = ⊤ ∨ b = ⊤ := by\n  match a, b with\n  | ⊤, _ => simp\n  | _, ⊤ => simp\n  | (a : α), (b : α) => simp only [← coe_add, coe_ne_top, or_false]\n\n"}
{"name":"WithTop.add_ne_top","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Add α\na b : WithTop α\n⊢ Iff (Ne (HAdd.hAdd a b) Top.top) (And (Ne a Top.top) (Ne b Top.top))","decl":"theorem add_ne_top : a + b ≠ ⊤ ↔ a ≠ ⊤ ∧ b ≠ ⊤ :=\n  add_eq_top.not.trans not_or\n\n"}
{"name":"WithTop.add_lt_top","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : Add α\ninst✝ : LT α\na b : WithTop α\n⊢ Iff (LT.lt (HAdd.hAdd a b) Top.top) (And (LT.lt a Top.top) (LT.lt b Top.top))","decl":"theorem add_lt_top [LT α] {a b : WithTop α} : a + b < ⊤ ↔ a < ⊤ ∧ b < ⊤ := by\n  simp_rw [WithTop.lt_top_iff_ne_top, add_ne_top]\n\n"}
{"name":"WithTop.add_eq_coe","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Add α\na b : WithTop α\nc : α\n⊢ Iff (Eq (HAdd.hAdd a b) ↑c) (Exists fun a' => Exists fun b' => And (Eq (↑a') a) (And (Eq (↑b') b) (Eq (HAdd.hAdd a' b') c)))","decl":"theorem add_eq_coe :\n    ∀ {a b : WithTop α} {c : α}, a + b = c ↔ ∃ a' b' : α, ↑a' = a ∧ ↑b' = b ∧ a' + b' = c\n  | ⊤, b, c => by simp\n  | some a, ⊤, c => by simp\n  | some a, some b, c => by norm_cast; simp\n\n"}
{"name":"WithTop.add_coe_eq_top_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Add α\nx : WithTop α\ny : α\n⊢ Iff (Eq (HAdd.hAdd x ↑y) Top.top) (Eq x Top.top)","decl":"theorem add_coe_eq_top_iff {x : WithTop α} {y : α} : x + y = ⊤ ↔ x = ⊤ := by simp\n\n"}
{"name":"WithTop.coe_add_eq_top_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Add α\nx : α\ny : WithTop α\n⊢ Iff (Eq (HAdd.hAdd (↑x) y) Top.top) (Eq y Top.top)","decl":"theorem coe_add_eq_top_iff {y : WithTop α} : ↑x + y = ⊤ ↔ y = ⊤ := by simp\n\n"}
{"name":"WithTop.add_right_cancel_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : Add α\na b c : WithTop α\ninst✝ : IsRightCancelAdd α\nha : Ne a Top.top\n⊢ Iff (Eq (HAdd.hAdd b a) (HAdd.hAdd c a)) (Eq b c)","decl":"theorem add_right_cancel_iff [IsRightCancelAdd α] (ha : a ≠ ⊤) : b + a = c + a ↔ b = c := by\n  lift a to α using ha\n  obtain rfl | hb := eq_or_ne b ⊤\n  · rw [top_add, eq_comm, WithTop.add_coe_eq_top_iff, eq_comm]\n  lift b to α using hb\n  simp_rw [← WithTop.coe_add, eq_comm, WithTop.add_eq_coe, coe_eq_coe, exists_and_left,\n    exists_eq_left, add_left_inj, exists_eq_right, eq_comm]\n\n"}
{"name":"WithTop.add_right_cancel","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : Add α\na b c : WithTop α\ninst✝ : IsRightCancelAdd α\nha : Ne a Top.top\nh : Eq (HAdd.hAdd b a) (HAdd.hAdd c a)\n⊢ Eq b c","decl":"theorem add_right_cancel [IsRightCancelAdd α] (ha : a ≠ ⊤) (h : b + a = c + a) : b = c :=\n  (WithTop.add_right_cancel_iff ha).1 h\n\n"}
{"name":"WithTop.add_left_cancel_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : Add α\na b c : WithTop α\ninst✝ : IsLeftCancelAdd α\nha : Ne a Top.top\n⊢ Iff (Eq (HAdd.hAdd a b) (HAdd.hAdd a c)) (Eq b c)","decl":"theorem add_left_cancel_iff [IsLeftCancelAdd α] (ha : a ≠ ⊤) : a + b = a + c ↔ b = c := by\n  lift a to α using ha\n  obtain rfl | hb := eq_or_ne b ⊤\n  · rw [add_top, eq_comm, WithTop.coe_add_eq_top_iff, eq_comm]\n  lift b to α using hb\n  simp_rw [← WithTop.coe_add, eq_comm, WithTop.add_eq_coe, eq_comm, coe_eq_coe,\n    exists_and_left, exists_eq_left', add_right_inj, exists_eq_right']\n\n"}
{"name":"WithTop.add_left_cancel","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : Add α\na b c : WithTop α\ninst✝ : IsLeftCancelAdd α\nha : Ne a Top.top\nh : Eq (HAdd.hAdd a b) (HAdd.hAdd a c)\n⊢ Eq b c","decl":"theorem add_left_cancel [IsLeftCancelAdd α] (ha : a ≠ ⊤) (h : a + b = a + c) : b = c :=\n  (WithTop.add_left_cancel_iff ha).1 h\n\n"}
{"name":"WithTop.addLeftMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝² : Add α\ninst✝¹ : LE α\ninst✝ : AddLeftMono α\n⊢ AddLeftMono (WithTop α)","decl":"instance addLeftMono [LE α] [AddLeftMono α] : AddLeftMono (WithTop α) :=\n  ⟨fun a b c h => by\n    cases a <;> cases c <;> try exact le_top\n    rcases le_coe_iff.1 h with ⟨b, rfl, _⟩\n    exact coe_le_coe.2 (add_le_add_left (coe_le_coe.1 h) _)⟩\n\n"}
{"name":"WithTop.addRightMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝² : Add α\ninst✝¹ : LE α\ninst✝ : AddRightMono α\n⊢ AddRightMono (WithTop α)","decl":"instance addRightMono [LE α] [AddRightMono α] : AddRightMono (WithTop α) :=\n  ⟨fun a b c h => by\n    cases a <;> cases c <;> try exact le_top\n    rcases le_coe_iff.1 h with ⟨b, rfl, _⟩\n    exact coe_le_coe.2 (add_le_add_right (coe_le_coe.1 h) _)⟩\n\n"}
{"name":"WithTop.addLeftReflectLT","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝² : Add α\ninst✝¹ : LT α\ninst✝ : AddLeftReflectLT α\n⊢ AddLeftReflectLT (WithTop α)","decl":"instance addLeftReflectLT [LT α] [AddLeftReflectLT α] : AddLeftReflectLT (WithTop α) :=\n  ⟨fun a b c h => by\n    induction a; · exact (WithTop.not_top_lt _ h).elim\n    induction b; · exact (WithTop.not_top_lt _ h).elim\n    induction c\n    · exact coe_lt_top _\n    · exact coe_lt_coe.2 (lt_of_add_lt_add_left <| coe_lt_coe.1 h)⟩\n\n"}
{"name":"WithTop.addRightReflectLT","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝² : Add α\ninst✝¹ : LT α\ninst✝ : AddRightReflectLT α\n⊢ AddRightReflectLT (WithTop α)","decl":"instance addRightReflectLT [LT α] [AddRightReflectLT α] : AddRightReflectLT (WithTop α) :=\n  ⟨fun a b c h => by\n    cases a <;> cases b <;> try exact (WithTop.not_top_lt _ h).elim\n    cases c\n    · exact coe_lt_top _\n    · exact coe_lt_coe.2 (lt_of_add_lt_add_right <| coe_lt_coe.1 h)⟩\n\n"}
{"name":"WithTop.le_of_add_le_add_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝² : Add α\na b c : WithTop α\ninst✝¹ : LE α\ninst✝ : AddLeftReflectLE α\nha : Ne a Top.top\nh : LE.le (HAdd.hAdd a b) (HAdd.hAdd a c)\n⊢ LE.le b c","decl":"protected theorem le_of_add_le_add_left [LE α] [AddLeftReflectLE α] (ha : a ≠ ⊤)\n    (h : a + b ≤ a + c) : b ≤ c := by\n  lift a to α using ha\n  induction c\n  · exact le_top\n  · induction b\n    · exact (not_top_le_coe _ h).elim\n    · simp only [← coe_add, coe_le_coe] at h ⊢\n      exact le_of_add_le_add_left h\n\n"}
{"name":"WithTop.le_of_add_le_add_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝² : Add α\na b c : WithTop α\ninst✝¹ : LE α\ninst✝ : AddRightReflectLE α\nha : Ne a Top.top\nh : LE.le (HAdd.hAdd b a) (HAdd.hAdd c a)\n⊢ LE.le b c","decl":"protected theorem le_of_add_le_add_right [LE α] [AddRightReflectLE α]\n    (ha : a ≠ ⊤) (h : b + a ≤ c + a) : b ≤ c := by\n  lift a to α using ha\n  cases c\n  · exact le_top\n  · cases b\n    · exact (not_top_le_coe _ h).elim\n    · exact coe_le_coe.2 (le_of_add_le_add_right <| coe_le_coe.1 h)\n\n"}
{"name":"WithTop.add_lt_add_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝² : Add α\na b c : WithTop α\ninst✝¹ : LT α\ninst✝ : AddLeftStrictMono α\nha : Ne a Top.top\nh : LT.lt b c\n⊢ LT.lt (HAdd.hAdd a b) (HAdd.hAdd a c)","decl":"protected theorem add_lt_add_left [LT α] [AddLeftStrictMono α] (ha : a ≠ ⊤)\n    (h : b < c) : a + b < a + c := by\n  lift a to α using ha\n  rcases lt_iff_exists_coe.1 h with ⟨b, rfl, h'⟩\n  cases c\n  · exact coe_lt_top _\n  · exact coe_lt_coe.2 (add_lt_add_left (coe_lt_coe.1 h) _)\n\n"}
{"name":"WithTop.add_lt_add_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝² : Add α\na b c : WithTop α\ninst✝¹ : LT α\ninst✝ : AddRightStrictMono α\nha : Ne a Top.top\nh : LT.lt b c\n⊢ LT.lt (HAdd.hAdd b a) (HAdd.hAdd c a)","decl":"protected theorem add_lt_add_right [LT α] [AddRightStrictMono α] (ha : a ≠ ⊤)\n    (h : b < c) : b + a < c + a := by\n  lift a to α using ha\n  rcases lt_iff_exists_coe.1 h with ⟨b, rfl, h'⟩\n  cases c\n  · exact coe_lt_top _\n  · exact coe_lt_coe.2 (add_lt_add_right (coe_lt_coe.1 h) _)\n\n"}
{"name":"WithTop.add_le_add_iff_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝³ : Add α\na b c : WithTop α\ninst✝² : LE α\ninst✝¹ : AddLeftMono α\ninst✝ : AddLeftReflectLE α\nha : Ne a Top.top\n⊢ Iff (LE.le (HAdd.hAdd a b) (HAdd.hAdd a c)) (LE.le b c)","decl":"protected theorem add_le_add_iff_left [LE α] [AddLeftMono α]\n    [AddLeftReflectLE α] (ha : a ≠ ⊤) : a + b ≤ a + c ↔ b ≤ c :=\n  ⟨WithTop.le_of_add_le_add_left ha, fun h => add_le_add_left h a⟩\n\n"}
{"name":"WithTop.add_le_add_iff_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝³ : Add α\na b c : WithTop α\ninst✝² : LE α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nha : Ne a Top.top\n⊢ Iff (LE.le (HAdd.hAdd b a) (HAdd.hAdd c a)) (LE.le b c)","decl":"protected theorem add_le_add_iff_right [LE α] [AddRightMono α]\n    [AddRightReflectLE α] (ha : a ≠ ⊤) : b + a ≤ c + a ↔ b ≤ c :=\n  ⟨WithTop.le_of_add_le_add_right ha, fun h => add_le_add_right h a⟩\n\n"}
{"name":"WithTop.add_lt_add_iff_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝³ : Add α\na b c : WithTop α\ninst✝² : LT α\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddLeftReflectLT α\nha : Ne a Top.top\n⊢ Iff (LT.lt (HAdd.hAdd a b) (HAdd.hAdd a c)) (LT.lt b c)","decl":"protected theorem add_lt_add_iff_left [LT α] [AddLeftStrictMono α]\n    [AddLeftReflectLT α] (ha : a ≠ ⊤) : a + b < a + c ↔ b < c :=\n  ⟨lt_of_add_lt_add_left, WithTop.add_lt_add_left ha⟩\n\n"}
{"name":"WithTop.add_lt_add_iff_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝³ : Add α\na b c : WithTop α\ninst✝² : LT α\ninst✝¹ : AddRightStrictMono α\ninst✝ : AddRightReflectLT α\nha : Ne a Top.top\n⊢ Iff (LT.lt (HAdd.hAdd b a) (HAdd.hAdd c a)) (LT.lt b c)","decl":"protected theorem add_lt_add_iff_right [LT α] [AddRightStrictMono α]\n    [AddRightReflectLT α] (ha : a ≠ ⊤) : b + a < c + a ↔ b < c :=\n  ⟨lt_of_add_lt_add_right, WithTop.add_lt_add_right ha⟩\n\n"}
{"name":"WithTop.add_lt_add_of_le_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝³ : Add α\na b c d : WithTop α\ninst✝² : Preorder α\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddRightMono α\nha : Ne a Top.top\nhab : LE.le a b\nhcd : LT.lt c d\n⊢ LT.lt (HAdd.hAdd a c) (HAdd.hAdd b d)","decl":"protected theorem add_lt_add_of_le_of_lt [Preorder α] [AddLeftStrictMono α]\n    [AddRightMono α] (ha : a ≠ ⊤) (hab : a ≤ b) (hcd : c < d) :\n    a + c < b + d :=\n  (WithTop.add_lt_add_left ha hcd).trans_le <| add_le_add_right hab _\n\n"}
{"name":"WithTop.add_lt_add_of_lt_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝³ : Add α\na b c d : WithTop α\ninst✝² : Preorder α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightStrictMono α\nhc : Ne c Top.top\nhab : LT.lt a b\nhcd : LE.le c d\n⊢ LT.lt (HAdd.hAdd a c) (HAdd.hAdd b d)","decl":"protected theorem add_lt_add_of_lt_of_le [Preorder α] [AddLeftMono α]\n    [AddRightStrictMono α] (hc : c ≠ ⊤) (hab : a < b) (hcd : c ≤ d) :\n    a + c < b + d :=\n  (WithTop.add_lt_add_right hc hab).trans_le <| add_le_add_left hcd _\n\n"}
{"name":"WithTop.addLECancellable_of_ne_top","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝² : Add α\na : WithTop α\ninst✝¹ : Preorder α\ninst✝ : ContravariantClass α α (fun x1 x2 => HAdd.hAdd x1 x2) fun x1 x2 => LE.le x1 x2\nha : Ne a Top.top\n⊢ AddLECancellable a","decl":"lemma addLECancellable_of_ne_top [Preorder α] [ContravariantClass α α (· + ·) (· ≤ ·)]\n    (ha : a ≠ ⊤) : AddLECancellable a := fun _b _c ↦ WithTop.le_of_add_le_add_left ha\n\n"}
{"name":"WithTop.addLECancellable_of_lt_top","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝² : Add α\na : WithTop α\ninst✝¹ : Preorder α\ninst✝ : ContravariantClass α α (fun x1 x2 => HAdd.hAdd x1 x2) fun x1 x2 => LE.le x1 x2\nha : LT.lt a Top.top\n⊢ AddLECancellable a","decl":"lemma addLECancellable_of_lt_top [Preorder α] [ContravariantClass α α (· + ·) (· ≤ ·)]\n    (ha : a < ⊤) : AddLECancellable a := addLECancellable_of_ne_top ha.ne\n\n"}
{"name":"WithTop.addLECancellable_coe","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝² : Add α\ninst✝¹ : Preorder α\ninst✝ : ContravariantClass α α (fun x1 x2 => HAdd.hAdd x1 x2) fun x1 x2 => LE.le x1 x2\na : α\n⊢ AddLECancellable ↑a","decl":"lemma addLECancellable_coe [Preorder α] [ContravariantClass α α (· + ·) (· ≤ ·)] (a : α) :\n    AddLECancellable (a : WithTop α) := addLECancellable_of_ne_top coe_ne_top\n\n"}
{"name":"WithTop.addLECancellable_iff_ne_top","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝³ : Add α\na : WithTop α\ninst✝² : Nonempty α\ninst✝¹ : Preorder α\ninst✝ : ContravariantClass α α (fun x1 x2 => HAdd.hAdd x1 x2) fun x1 x2 => LE.le x1 x2\n⊢ Iff (AddLECancellable a) (Ne a Top.top)","decl":"lemma addLECancellable_iff_ne_top [Nonempty α] [Preorder α]\n    [ContravariantClass α α (· + ·) (· ≤ ·)] : AddLECancellable a ↔ a ≠ ⊤ where\n  mp := by rintro h rfl; exact (coe_lt_top <| Classical.arbitrary _).not_le <| h <| by simp\n  mpr := addLECancellable_of_ne_top\n\n--  There is no `WithTop.map_mul_of_mulHom`, since `WithTop` does not have a multiplication.\n"}
{"name":"WithTop.map_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : Add α\nF : Type u_1\ninst✝² : Add β\ninst✝¹ : FunLike F α β\ninst✝ : AddHomClass F α β\nf : F\na b : WithTop α\n⊢ Eq (WithTop.map (⇑f) (HAdd.hAdd a b)) (HAdd.hAdd (WithTop.map (⇑f) a) (WithTop.map (⇑f) b))","decl":"@[simp]\nprotected theorem map_add {F} [Add β] [FunLike F α β] [AddHomClass F α β]\n    (f : F) (a b : WithTop α) :\n    (a + b).map f = a.map f + b.map f := by\n  induction a\n  · exact (top_add _).symm\n  · induction b\n    · exact (add_top _).symm\n    · rw [map_coe, map_coe, ← coe_add, ← coe_add, ← map_add]\n      rfl\n\n"}
{"name":"WithTop.coe_nsmul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : AddMonoid α\na : α\nn : Nat\n⊢ Eq (↑(HSMul.hSMul n a)) (HSMul.hSMul n ↑a)","decl":"@[simp, norm_cast] lemma coe_nsmul (a : α) (n : ℕ) : ↑(n • a) = n • (a : WithTop α) := rfl\n\n"}
{"name":"WithTop.coe_addHom","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : AddMonoid α\n⊢ Eq (⇑WithTop.addHom) WithTop.some","decl":"@[simp, norm_cast] lemma coe_addHom : ⇑(addHom : α →+ WithTop α) = WithTop.some := rfl\n\n"}
{"name":"WithTop.coe_natCast","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : AddMonoidWithOne α\nn : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast] lemma coe_natCast (n : ℕ) : ((n : α) : WithTop α) = n := rfl\n\n"}
{"name":"WithTop.top_ne_natCast","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : AddMonoidWithOne α\nn : Nat\n⊢ Ne Top.top ↑n","decl":"@[simp] lemma top_ne_natCast (n : ℕ) : (⊤ : WithTop α) ≠ n := top_ne_coe\n"}
{"name":"WithTop.natCast_ne_top","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : AddMonoidWithOne α\nn : Nat\n⊢ Ne (↑n) Top.top","decl":"@[simp] lemma natCast_ne_top (n : ℕ) : (n : WithTop α) ≠ ⊤ := coe_ne_top\n"}
{"name":"WithTop.natCast_lt_top","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : AddMonoidWithOne α\ninst✝ : LT α\nn : Nat\n⊢ LT.lt (↑n) Top.top","decl":"@[simp] lemma natCast_lt_top [LT α] (n : ℕ) : (n : WithTop α) < ⊤ := coe_lt_top _\n\n"}
{"name":"WithTop.coe_ofNat","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : AddMonoidWithOne α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (↑(OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp] lemma coe_ofNat (n : ℕ) [n.AtLeastTwo] :\n    ((ofNat(n) : α) : WithTop α) = ofNat(n) := rfl\n"}
{"name":"WithTop.coe_eq_ofNat","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : AddMonoidWithOne α\nn : Nat\ninst✝ : n.AtLeastTwo\nm : α\n⊢ Iff (Eq (↑m) (OfNat.ofNat n)) (Eq m (OfNat.ofNat n))","decl":"@[simp] lemma coe_eq_ofNat (n : ℕ) [n.AtLeastTwo] (m : α) :\n    (m : WithTop α) = ofNat(n) ↔ m = ofNat(n) :=\n  coe_eq_coe\n"}
{"name":"WithTop.ofNat_eq_coe","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : AddMonoidWithOne α\nn : Nat\ninst✝ : n.AtLeastTwo\nm : α\n⊢ Iff (Eq (OfNat.ofNat n) ↑m) (Eq (OfNat.ofNat n) m)","decl":"@[simp] lemma ofNat_eq_coe (n : ℕ) [n.AtLeastTwo] (m : α) :\n    ofNat(n) = (m : WithTop α) ↔ ofNat(n) = m :=\n  coe_eq_coe\n"}
{"name":"WithTop.ofNat_ne_top","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : AddMonoidWithOne α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Ne (OfNat.ofNat n) Top.top","decl":"@[simp] lemma ofNat_ne_top (n : ℕ) [n.AtLeastTwo] : (ofNat(n) : WithTop α) ≠ ⊤ :=\n  natCast_ne_top n\n"}
{"name":"WithTop.top_ne_ofNat","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : AddMonoidWithOne α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Ne Top.top (OfNat.ofNat n)","decl":"@[simp] lemma top_ne_ofNat (n : ℕ) [n.AtLeastTwo] : (⊤ : WithTop α) ≠ ofNat(n) :=\n  top_ne_natCast n\n\n"}
{"name":"WithTop.map_ofNat","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : AddMonoidWithOne α\nf : α → β\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (WithTop.map f (OfNat.ofNat n)) ↑(f (OfNat.ofNat n))","decl":"@[simp] lemma map_ofNat {f : α → β} (n : ℕ) [n.AtLeastTwo] :\n    WithTop.map f (ofNat(n) : WithTop α) = f (ofNat(n)) := map_coe f n\n\n"}
{"name":"WithTop.map_natCast","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddMonoidWithOne α\nf : α → β\nn : Nat\n⊢ Eq (WithTop.map f ↑n) ↑(f ↑n)","decl":"@[simp] lemma map_natCast {f : α → β} (n : ℕ) :\n    WithTop.map f (n : WithTop α) = f n := map_coe f n\n\n"}
{"name":"WithTop.map_eq_ofNat_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : AddMonoidWithOne α\nf : β → α\nn : Nat\ninst✝ : n.AtLeastTwo\na : WithTop β\n⊢ Iff (Eq (WithTop.map f a) (OfNat.ofNat n)) (Exists fun x => And (Eq a ↑x) (Eq (f x) ↑n))","decl":"lemma map_eq_ofNat_iff {f : β → α} {n : ℕ} [n.AtLeastTwo] {a : WithTop β} :\n    a.map f = ofNat(n) ↔ ∃ x, a = .some x ∧ f x = n := map_eq_some_iff\n\n"}
{"name":"WithTop.ofNat_eq_map_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : AddMonoidWithOne α\nf : β → α\nn : Nat\ninst✝ : n.AtLeastTwo\na : WithTop β\n⊢ Iff (Eq (OfNat.ofNat n) (WithTop.map f a)) (Exists fun x => And (Eq a ↑x) (Eq (f x) ↑n))","decl":"lemma ofNat_eq_map_iff {f : β → α} {n : ℕ} [n.AtLeastTwo] {a : WithTop β} :\n    ofNat(n) = a.map f ↔ ∃ x, a = .some x ∧ f x = n := some_eq_map_iff\n\n"}
{"name":"WithTop.map_eq_natCast_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddMonoidWithOne α\nf : β → α\nn : Nat\na : WithTop β\n⊢ Iff (Eq (WithTop.map f a) ↑n) (Exists fun x => And (Eq a ↑x) (Eq (f x) ↑n))","decl":"lemma map_eq_natCast_iff {f : β → α} {n : ℕ} {a : WithTop β} :\n    a.map f = n ↔ ∃ x, a = .some x ∧ f x = n := map_eq_some_iff\n\n"}
{"name":"WithTop.natCast_eq_map_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddMonoidWithOne α\nf : β → α\nn : Nat\na : WithTop β\n⊢ Iff (Eq (↑n) (WithTop.map f a)) (Exists fun x => And (Eq a ↑x) (Eq (f x) ↑n))","decl":"lemma natCast_eq_map_iff {f : β → α} {n : ℕ} {a : WithTop β} :\n    n = a.map f ↔ ∃ x, a = .some x ∧ f x = n := some_eq_map_iff\n\n"}
{"name":"WithTop.charZero","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : AddMonoidWithOne α\ninst✝ : CharZero α\n⊢ CharZero (WithTop α)","decl":"instance charZero [AddMonoidWithOne α] [CharZero α] : CharZero (WithTop α) :=\n  { cast_injective := Function.Injective.comp (f := Nat.cast (R := α))\n      (fun _ _ => WithTop.coe_eq_coe.1) Nat.cast_injective}\n\n"}
{"name":"WithTop.existsAddOfLE","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝² : LE α\ninst✝¹ : Add α\ninst✝ : ExistsAddOfLE α\n⊢ ExistsAddOfLE (WithTop α)","decl":"instance existsAddOfLE [LE α] [Add α] [ExistsAddOfLE α] : ExistsAddOfLE (WithTop α) :=\n  ⟨fun {a} {b} =>\n    match a, b with\n    | ⊤, ⊤ => by simp\n    | (a : α), ⊤ => fun _ => ⟨⊤, rfl⟩\n    | (a : α), (b : α) => fun h => by\n      obtain ⟨c, rfl⟩ := exists_add_of_le (WithTop.coe_le_coe.1 h)\n      exact ⟨c, rfl⟩\n    | ⊤, (b : α) => fun h => (not_top_le_coe _ h).elim⟩\n\n-- instance canonicallyOrderedAddCommMonoid [CanonicallyOrderedAddCommMonoid α] :\n--     CanonicallyOrderedAddCommMonoid (WithTop α) :=\n--   { WithTop.orderBot, WithTop.orderedAddCommMonoid, WithTop.existsAddOfLE with\n--     le_self_add := fun a b =>\n--       match a, b with\n--       | ⊤, ⊤ => le_rfl\n--       | (a : α), ⊤ => le_top\n--       | (a : α), (b : α) => WithTop.coe_le_coe.2 le_self_add\n--       | ⊤, (b : α) => le_rfl }\n--\n-- instance [CanonicallyLinearOrderedAddCommMonoid α] :\n--     CanonicallyLinearOrderedAddCommMonoid (WithTop α) :=\n--   { WithTop.canonicallyOrderedAddCommMonoid, WithTop.linearOrder with }\n\n"}
{"name":"WithTop.one_lt_top","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : One α\ninst✝ : LT α\n⊢ LT.lt 1 Top.top","decl":"@[to_additive (attr := simp) top_pos]\ntheorem one_lt_top [One α] [LT α] : (1 : WithTop α) < ⊤ := coe_lt_top _\n\n"}
{"name":"WithTop.top_pos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : Zero α\ninst✝ : LT α\n⊢ LT.lt 0 Top.top","decl":"@[to_additive (attr := simp) top_pos]\ntheorem one_lt_top [One α] [LT α] : (1 : WithTop α) < ⊤ := coe_lt_top _\n\n"}
{"name":"WithTop.zero_lt_top","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : Zero α\ninst✝ : LT α\n⊢ LT.lt 0 Top.top","decl":"@[deprecated top_pos (since := \"2024-10-22\")]\nalias zero_lt_top := top_pos\n\n"}
{"name":"WithTop.zero_lt_coe","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : Zero α\ninst✝ : LT α\na : α\n⊢ Iff (LT.lt 0 ↑a) (LT.lt 0 a)","decl":"@[norm_cast, deprecated coe_pos (since := \"2024-10-22\")]\ntheorem zero_lt_coe [Zero α] [LT α] (a : α) : (0 : WithTop α) < a ↔ 0 < a :=\n  coe_lt_coe\n\n"}
{"name":"ZeroHom.withTopMap_apply","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Zero M\ninst✝ : Zero N\nf : ZeroHom M N\n⊢ Eq (⇑f.withTopMap) (WithTop.map ⇑f)","decl":"/-- A version of `WithTop.map` for `OneHom`s. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"A version of `WithTop.map` for `ZeroHom`s\"]\nprotected def _root_.OneHom.withTopMap {M N : Type*} [One M] [One N] (f : OneHom M N) :\n    OneHom (WithTop M) (WithTop N) where\n  toFun := WithTop.map f\n  map_one' := by rw [WithTop.map_one, map_one, coe_one]\n\n"}
{"name":"OneHom.withTopMap_apply","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : One M\ninst✝ : One N\nf : OneHom M N\n⊢ Eq (⇑f.withTopMap) (WithTop.map ⇑f)","decl":"/-- A version of `WithTop.map` for `OneHom`s. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"A version of `WithTop.map` for `ZeroHom`s\"]\nprotected def _root_.OneHom.withTopMap {M N : Type*} [One M] [One N] (f : OneHom M N) :\n    OneHom (WithTop M) (WithTop N) where\n  toFun := WithTop.map f\n  map_one' := by rw [WithTop.map_one, map_one, coe_one]\n\n"}
{"name":"AddHom.withTopMap_apply","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\n⊢ Eq (⇑f.withTopMap) (WithTop.map ⇑f)","decl":"/-- A version of `WithTop.map` for `AddHom`s. -/\n@[simps (config := .asFn)]\nprotected def _root_.AddHom.withTopMap {M N : Type*} [Add M] [Add N] (f : AddHom M N) :\n    AddHom (WithTop M) (WithTop N) where\n  toFun := WithTop.map f\n  map_add' := WithTop.map_add f\n\n"}
{"name":"AddMonoidHom.withTopMap_apply","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\n⊢ Eq (⇑f.withTopMap) (WithTop.map ⇑f)","decl":"/-- A version of `WithTop.map` for `AddMonoidHom`s. -/\n@[simps (config := .asFn)]\nprotected def _root_.AddMonoidHom.withTopMap {M N : Type*} [AddZeroClass M] [AddZeroClass N]\n    (f : M →+ N) : WithTop M →+ WithTop N :=\n  { ZeroHom.withTopMap f.toZeroHom, AddHom.withTopMap f.toAddHom with toFun := WithTop.map f }\n\n"}
{"name":"WithBot.coe_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : One α\n⊢ Eq (↑1) 1","decl":"@[to_additive (attr := simp, norm_cast)] lemma coe_one : ((1 : α) : WithBot α) = 1 := rfl\n\n"}
{"name":"WithBot.coe_zero","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Zero α\n⊢ Eq (↑0) 0","decl":"@[to_additive (attr := simp, norm_cast)] lemma coe_one : ((1 : α) : WithBot α) = 1 := rfl\n\n"}
{"name":"WithBot.coe_eq_zero","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Zero α\na : α\n⊢ Iff (Eq (↑a) 0) (Eq a 0)","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma coe_eq_one : (a : WithBot α) = 1 ↔ a = 1 := coe_eq_coe\n\n"}
{"name":"WithBot.coe_eq_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : One α\na : α\n⊢ Iff (Eq (↑a) 1) (Eq a 1)","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma coe_eq_one : (a : WithBot α) = 1 ↔ a = 1 := coe_eq_coe\n\n"}
{"name":"WithBot.zero_eq_coe","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Zero α\na : α\n⊢ Iff (Eq 0 ↑a) (Eq a 0)","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma one_eq_coe : 1 = (a : WithBot α) ↔ a = 1 := eq_comm.trans coe_eq_one\n\n"}
{"name":"WithBot.one_eq_coe","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : One α\na : α\n⊢ Iff (Eq 1 ↑a) (Eq a 1)","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma one_eq_coe : 1 = (a : WithBot α) ↔ a = 1 := eq_comm.trans coe_eq_one\n\n"}
{"name":"WithBot.bot_ne_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : One α\n⊢ Ne Bot.bot 1","decl":"@[to_additive (attr := simp)] lemma bot_ne_one : (⊥ : WithBot α) ≠ 1 := bot_ne_coe\n"}
{"name":"WithBot.bot_ne_zero","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Zero α\n⊢ Ne Bot.bot 0","decl":"@[to_additive (attr := simp)] lemma bot_ne_one : (⊥ : WithBot α) ≠ 1 := bot_ne_coe\n"}
{"name":"WithBot.zero_ne_bot","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Zero α\n⊢ Ne 0 Bot.bot","decl":"@[to_additive (attr := simp)] lemma one_ne_bot : (1 : WithBot α) ≠ ⊥ := coe_ne_bot\n\n"}
{"name":"WithBot.one_ne_bot","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : One α\n⊢ Ne 1 Bot.bot","decl":"@[to_additive (attr := simp)] lemma one_ne_bot : (1 : WithBot α) ≠ ⊥ := coe_ne_bot\n\n"}
{"name":"WithBot.unbot_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : One α\n⊢ Eq (WithBot.unbot 1 ⋯) 1","decl":"@[to_additive (attr := simp)]\ntheorem unbot_one : (1 : WithBot α).unbot coe_ne_bot = 1 :=\n  rfl\n\n"}
{"name":"WithBot.unbot_zero","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Zero α\n⊢ Eq (WithBot.unbot 0 ⋯) 0","decl":"@[to_additive (attr := simp)]\ntheorem unbot_one : (1 : WithBot α).unbot coe_ne_bot = 1 :=\n  rfl\n\n"}
{"name":"WithBot.unbot_one'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : One α\nd : α\n⊢ Eq (WithBot.unbot' d 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem unbot_one' (d : α) : (1 : WithBot α).unbot' d = 1 :=\n  rfl\n\n"}
{"name":"WithBot.unbot_zero'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Zero α\nd : α\n⊢ Eq (WithBot.unbot' d 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem unbot_one' (d : α) : (1 : WithBot α).unbot' d = 1 :=\n  rfl\n\n"}
{"name":"WithBot.one_le_coe","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : One α\na : α\ninst✝ : LE α\n⊢ Iff (LE.le 1 ↑a) (LE.le 1 a)","decl":"@[to_additive (attr := simp, norm_cast) coe_nonneg]\ntheorem one_le_coe [LE α] : 1 ≤ (a : WithBot α) ↔ 1 ≤ a := coe_le_coe\n\n"}
{"name":"WithBot.coe_nonneg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : Zero α\na : α\ninst✝ : LE α\n⊢ Iff (LE.le 0 ↑a) (LE.le 0 a)","decl":"@[to_additive (attr := simp, norm_cast) coe_nonneg]\ntheorem one_le_coe [LE α] : 1 ≤ (a : WithBot α) ↔ 1 ≤ a := coe_le_coe\n\n"}
{"name":"WithBot.coe_le_zero","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : Zero α\na : α\ninst✝ : LE α\n⊢ Iff (LE.le (↑a) 0) (LE.le a 0)","decl":"@[to_additive (attr := simp, norm_cast) coe_le_zero]\ntheorem coe_le_one [LE α] : (a : WithBot α) ≤ 1 ↔ a ≤ 1 := coe_le_coe\n\n"}
{"name":"WithBot.coe_le_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : One α\na : α\ninst✝ : LE α\n⊢ Iff (LE.le (↑a) 1) (LE.le a 1)","decl":"@[to_additive (attr := simp, norm_cast) coe_le_zero]\ntheorem coe_le_one [LE α] : (a : WithBot α) ≤ 1 ↔ a ≤ 1 := coe_le_coe\n\n"}
{"name":"WithBot.one_lt_coe","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : One α\na : α\ninst✝ : LT α\n⊢ Iff (LT.lt 1 ↑a) (LT.lt 1 a)","decl":"@[to_additive (attr := simp, norm_cast) coe_pos]\ntheorem one_lt_coe [LT α] : 1 < (a : WithBot α) ↔ 1 < a := coe_lt_coe\n\n"}
{"name":"WithBot.coe_pos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : Zero α\na : α\ninst✝ : LT α\n⊢ Iff (LT.lt 0 ↑a) (LT.lt 0 a)","decl":"@[to_additive (attr := simp, norm_cast) coe_pos]\ntheorem one_lt_coe [LT α] : 1 < (a : WithBot α) ↔ 1 < a := coe_lt_coe\n\n"}
{"name":"WithBot.coe_lt_zero","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : Zero α\na : α\ninst✝ : LT α\n⊢ Iff (LT.lt (↑a) 0) (LT.lt a 0)","decl":"@[to_additive (attr := simp, norm_cast) coe_lt_zero]\ntheorem coe_lt_one [LT α] : (a : WithBot α) < 1 ↔ a < 1 := coe_lt_coe\n\n"}
{"name":"WithBot.coe_lt_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : One α\na : α\ninst✝ : LT α\n⊢ Iff (LT.lt (↑a) 1) (LT.lt a 1)","decl":"@[to_additive (attr := simp, norm_cast) coe_lt_zero]\ntheorem coe_lt_one [LT α] : (a : WithBot α) < 1 ↔ a < 1 := coe_lt_coe\n\n"}
{"name":"WithBot.map_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : One α\nβ : Type u_1\nf : α → β\n⊢ Eq (WithBot.map f 1) ↑(f 1)","decl":"@[to_additive (attr := simp)]\nprotected theorem map_one {β} (f : α → β) : (1 : WithBot α).map f = (f 1 : WithBot β) :=\n  rfl\n\n"}
{"name":"WithBot.map_zero","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Zero α\nβ : Type u_1\nf : α → β\n⊢ Eq (WithBot.map f 0) ↑(f 0)","decl":"@[to_additive (attr := simp)]\nprotected theorem map_one {β} (f : α → β) : (1 : WithBot α).map f = (f 1 : WithBot β) :=\n  rfl\n\n"}
{"name":"WithBot.map_eq_zero_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"β : Type v\nα : Type u_1\nf : α → β\nv : WithBot α\ninst✝ : Zero β\n⊢ Iff (Eq (WithBot.map f v) 0) (Exists fun x => And (Eq v ↑x) (Eq (f x) 0))","decl":"@[to_additive]\ntheorem map_eq_one_iff {α} {f : α → β} {v : WithBot α} [One β] :\n    WithBot.map f v = 1 ↔ ∃ x, v = .some x ∧ f x = 1 := map_eq_some_iff\n\n"}
{"name":"WithBot.map_eq_one_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"β : Type v\nα : Type u_1\nf : α → β\nv : WithBot α\ninst✝ : One β\n⊢ Iff (Eq (WithBot.map f v) 1) (Exists fun x => And (Eq v ↑x) (Eq (f x) 1))","decl":"@[to_additive]\ntheorem map_eq_one_iff {α} {f : α → β} {v : WithBot α} [One β] :\n    WithBot.map f v = 1 ↔ ∃ x, v = .some x ∧ f x = 1 := map_eq_some_iff\n\n"}
{"name":"WithBot.zero_eq_map_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"β : Type v\nα : Type u_1\nf : α → β\nv : WithBot α\ninst✝ : Zero β\n⊢ Iff (Eq 0 (WithBot.map f v)) (Exists fun x => And (Eq v ↑x) (Eq (f x) 0))","decl":"@[to_additive]\ntheorem one_eq_map_iff {α} {f : α → β} {v : WithBot α} [One β] :\n    1 = WithBot.map f v ↔ ∃ x, v = .some x ∧ f x = 1 := some_eq_map_iff\n\n"}
{"name":"WithBot.one_eq_map_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"β : Type v\nα : Type u_1\nf : α → β\nv : WithBot α\ninst✝ : One β\n⊢ Iff (Eq 1 (WithBot.map f v)) (Exists fun x => And (Eq v ↑x) (Eq (f x) 1))","decl":"@[to_additive]\ntheorem one_eq_map_iff {α} {f : α → β} {v : WithBot α} [One β] :\n    1 = WithBot.map f v ↔ ∃ x, v = .some x ∧ f x = 1 := some_eq_map_iff\n\n"}
{"name":"WithBot.zeroLEOneClass","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝³ : One α\ninst✝² : Zero α\ninst✝¹ : LE α\ninst✝ : ZeroLEOneClass α\n⊢ ZeroLEOneClass (WithBot α)","decl":"instance zeroLEOneClass [Zero α] [LE α] [ZeroLEOneClass α] : ZeroLEOneClass (WithBot α) :=\n  ⟨coe_le_coe.2 zero_le_one⟩\n\n"}
{"name":"WithBot.coe_addHom","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : AddMonoid α\n⊢ Eq (⇑WithBot.addHom) WithBot.some","decl":"@[simp, norm_cast] lemma coe_addHom : ⇑(addHom : α →+ WithBot α) = WithBot.some := rfl\n\n"}
{"name":"WithBot.coe_nsmul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : AddMonoid α\na : α\nn : Nat\n⊢ Eq (↑(HSMul.hSMul n a)) (HSMul.hSMul n ↑a)","decl":"@[simp, norm_cast]\nlemma coe_nsmul (a : α) (n : ℕ) : ↑(n • a) = n • (a : WithBot α) :=\n  (addHom : α →+ WithBot α).map_nsmul _ _\n\n"}
{"name":"WithBot.coe_natCast","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : AddMonoidWithOne α\nn : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[norm_cast] lemma coe_natCast (n : ℕ) : ((n : α) : WithBot α) = n := rfl\n\n"}
{"name":"WithBot.natCast_ne_bot","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : AddMonoidWithOne α\nn : Nat\n⊢ Ne (↑n) Bot.bot","decl":"@[simp] lemma natCast_ne_bot (n : ℕ) : (n : WithBot α) ≠ ⊥ := coe_ne_bot\n\n"}
{"name":"WithBot.bot_ne_natCast","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : AddMonoidWithOne α\nn : Nat\n⊢ Ne Bot.bot ↑n","decl":"@[simp] lemma bot_ne_natCast (n : ℕ) : (⊥ : WithBot α) ≠ n := bot_ne_coe\n\n"}
{"name":"WithBot.coe_ofNat","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : AddMonoidWithOne α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (↑(OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp] lemma coe_ofNat (n : ℕ) [n.AtLeastTwo] :\n    ((ofNat(n) : α) : WithBot α) = ofNat(n) := rfl\n"}
{"name":"WithBot.coe_eq_ofNat","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : AddMonoidWithOne α\nn : Nat\ninst✝ : n.AtLeastTwo\nm : α\n⊢ Iff (Eq (↑m) (OfNat.ofNat n)) (Eq m (OfNat.ofNat n))","decl":"@[simp] lemma coe_eq_ofNat (n : ℕ) [n.AtLeastTwo] (m : α) :\n    (m : WithBot α) = ofNat(n) ↔ m = ofNat(n) :=\n  coe_eq_coe\n"}
{"name":"WithBot.ofNat_eq_coe","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : AddMonoidWithOne α\nn : Nat\ninst✝ : n.AtLeastTwo\nm : α\n⊢ Iff (Eq (OfNat.ofNat n) ↑m) (Eq (OfNat.ofNat n) m)","decl":"@[simp] lemma ofNat_eq_coe (n : ℕ) [n.AtLeastTwo] (m : α) :\n    ofNat(n) = (m : WithBot α) ↔ ofNat(n) = m :=\n  coe_eq_coe\n"}
{"name":"WithBot.ofNat_ne_bot","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : AddMonoidWithOne α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Ne (OfNat.ofNat n) Bot.bot","decl":"@[simp] lemma ofNat_ne_bot (n : ℕ) [n.AtLeastTwo] : (ofNat(n) : WithBot α) ≠ ⊥ :=\n  natCast_ne_bot n\n"}
{"name":"WithBot.bot_ne_ofNat","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : AddMonoidWithOne α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Ne Bot.bot (OfNat.ofNat n)","decl":"@[simp] lemma bot_ne_ofNat (n : ℕ) [n.AtLeastTwo] : (⊥ : WithBot α) ≠ ofNat(n) :=\n  bot_ne_natCast n\n\n"}
{"name":"WithBot.map_ofNat","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : AddMonoidWithOne α\nf : α → β\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (WithBot.map f (OfNat.ofNat n)) ↑(f (OfNat.ofNat n))","decl":"@[simp] lemma map_ofNat {f : α → β} (n : ℕ) [n.AtLeastTwo] :\n    WithBot.map f (ofNat(n) : WithBot α) = f ofNat(n) := map_coe f n\n\n"}
{"name":"WithBot.map_natCast","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddMonoidWithOne α\nf : α → β\nn : Nat\n⊢ Eq (WithBot.map f ↑n) ↑(f ↑n)","decl":"@[simp] lemma map_natCast {f : α → β} (n : ℕ) :\n    WithBot.map f (n : WithBot α) = f n := map_coe f n\n\n"}
{"name":"WithBot.map_eq_ofNat_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : AddMonoidWithOne α\nf : β → α\nn : Nat\ninst✝ : n.AtLeastTwo\na : WithBot β\n⊢ Iff (Eq (WithBot.map f a) (OfNat.ofNat n)) (Exists fun x => And (Eq a ↑x) (Eq (f x) ↑n))","decl":"lemma map_eq_ofNat_iff {f : β → α} {n : ℕ} [n.AtLeastTwo] {a : WithBot β} :\n    a.map f = ofNat(n) ↔ ∃ x, a = .some x ∧ f x = n := map_eq_some_iff\n\n"}
{"name":"WithBot.ofNat_eq_map_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : AddMonoidWithOne α\nf : β → α\nn : Nat\ninst✝ : n.AtLeastTwo\na : WithBot β\n⊢ Iff (Eq (OfNat.ofNat n) (WithBot.map f a)) (Exists fun x => And (Eq a ↑x) (Eq (f x) ↑n))","decl":"lemma ofNat_eq_map_iff {f : β → α} {n : ℕ} [n.AtLeastTwo] {a : WithBot β} :\n    ofNat(n) = a.map f ↔ ∃ x, a = .some x ∧ f x = n := some_eq_map_iff\n\n"}
{"name":"WithBot.map_eq_natCast_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddMonoidWithOne α\nf : β → α\nn : Nat\na : WithBot β\n⊢ Iff (Eq (WithBot.map f a) ↑n) (Exists fun x => And (Eq a ↑x) (Eq (f x) ↑n))","decl":"lemma map_eq_natCast_iff {f : β → α} {n : ℕ} {a : WithBot β} :\n    a.map f = n ↔ ∃ x, a = .some x ∧ f x = n := map_eq_some_iff\n\n"}
{"name":"WithBot.natCast_eq_map_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddMonoidWithOne α\nf : β → α\nn : Nat\na : WithBot β\n⊢ Iff (Eq (↑n) (WithBot.map f a)) (Exists fun x => And (Eq a ↑x) (Eq (f x) ↑n))","decl":"lemma natCast_eq_map_iff {f : β → α} {n : ℕ} {a : WithBot β} :\n    n = a.map f ↔ ∃ x, a = .some x ∧ f x = n := some_eq_map_iff\n\n"}
{"name":"WithBot.charZero","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : AddMonoidWithOne α\ninst✝ : CharZero α\n⊢ CharZero (WithBot α)","decl":"instance charZero [AddMonoidWithOne α] [CharZero α] : CharZero (WithBot α) :=\n  WithTop.charZero\n\n"}
{"name":"WithBot.coe_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Add α\na b : α\n⊢ Eq (↑(HAdd.hAdd a b)) (HAdd.hAdd ↑a ↑b)","decl":"@[simp, norm_cast]\ntheorem coe_add (a b : α) : ((a + b : α) : WithBot α) = a + b :=\n  rfl\n\n"}
{"name":"WithBot.bot_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Add α\na : WithBot α\n⊢ Eq (HAdd.hAdd Bot.bot a) Bot.bot","decl":"@[simp]\ntheorem bot_add (a : WithBot α) : ⊥ + a = ⊥ :=\n  rfl\n\n"}
{"name":"WithBot.add_bot","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Add α\na : WithBot α\n⊢ Eq (HAdd.hAdd a Bot.bot) Bot.bot","decl":"@[simp]\ntheorem add_bot (a : WithBot α) : a + ⊥ = ⊥ := by cases a <;> rfl\n\n"}
{"name":"WithBot.add_eq_bot","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Add α\na b : WithBot α\n⊢ Iff (Eq (HAdd.hAdd a b) Bot.bot) (Or (Eq a Bot.bot) (Eq b Bot.bot))","decl":"@[simp]\ntheorem add_eq_bot : a + b = ⊥ ↔ a = ⊥ ∨ b = ⊥ :=\n  WithTop.add_eq_top\n\n"}
{"name":"WithBot.add_ne_bot","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Add α\na b : WithBot α\n⊢ Iff (Ne (HAdd.hAdd a b) Bot.bot) (And (Ne a Bot.bot) (Ne b Bot.bot))","decl":"theorem add_ne_bot : a + b ≠ ⊥ ↔ a ≠ ⊥ ∧ b ≠ ⊥ :=\n  WithTop.add_ne_top\n\n"}
{"name":"WithBot.bot_lt_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : Add α\ninst✝ : LT α\na b : WithBot α\n⊢ Iff (LT.lt Bot.bot (HAdd.hAdd a b)) (And (LT.lt Bot.bot a) (LT.lt Bot.bot b))","decl":"theorem bot_lt_add [LT α] {a b : WithBot α} : ⊥ < a + b ↔ ⊥ < a ∧ ⊥ < b :=\n  WithTop.add_lt_top (α := αᵒᵈ)\n\n"}
{"name":"WithBot.add_eq_coe","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Add α\na b : WithBot α\nx : α\n⊢ Iff (Eq (HAdd.hAdd a b) ↑x) (Exists fun a' => Exists fun b' => And (Eq (↑a') a) (And (Eq (↑b') b) (Eq (HAdd.hAdd a' b') x)))","decl":"theorem add_eq_coe : a + b = x ↔ ∃ a' b' : α, ↑a' = a ∧ ↑b' = b ∧ a' + b' = x :=\n  WithTop.add_eq_coe\n\n"}
{"name":"WithBot.add_coe_eq_bot_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Add α\na : WithBot α\ny : α\n⊢ Iff (Eq (HAdd.hAdd a ↑y) Bot.bot) (Eq a Bot.bot)","decl":"theorem add_coe_eq_bot_iff : a + y = ⊥ ↔ a = ⊥ :=\n  WithTop.add_coe_eq_top_iff\n\n"}
{"name":"WithBot.coe_add_eq_bot_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝ : Add α\nb : WithBot α\nx : α\n⊢ Iff (Eq (HAdd.hAdd (↑x) b) Bot.bot) (Eq b Bot.bot)","decl":"theorem coe_add_eq_bot_iff : ↑x + b = ⊥ ↔ b = ⊥ :=\n  WithTop.coe_add_eq_top_iff\n\n"}
{"name":"WithBot.add_right_cancel_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : Add α\na b c : WithBot α\ninst✝ : IsRightCancelAdd α\nha : Ne a Bot.bot\n⊢ Iff (Eq (HAdd.hAdd b a) (HAdd.hAdd c a)) (Eq b c)","decl":"theorem add_right_cancel_iff [IsRightCancelAdd α] (ha : a ≠ ⊥) : b + a = c + a ↔ b = c :=\n  WithTop.add_right_cancel_iff ha\n\n"}
{"name":"WithBot.add_right_cancel","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : Add α\na b c : WithBot α\ninst✝ : IsRightCancelAdd α\nha : Ne a Bot.bot\nh : Eq (HAdd.hAdd b a) (HAdd.hAdd c a)\n⊢ Eq b c","decl":"theorem add_right_cancel [IsRightCancelAdd α] (ha : a ≠ ⊥) (h : b + a = c + a) : b = c :=\n  WithTop.add_right_cancel ha h\n\n"}
{"name":"WithBot.add_left_cancel_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : Add α\na b c : WithBot α\ninst✝ : IsLeftCancelAdd α\nha : Ne a Bot.bot\n⊢ Iff (Eq (HAdd.hAdd a b) (HAdd.hAdd a c)) (Eq b c)","decl":"theorem add_left_cancel_iff [IsLeftCancelAdd α] (ha : a ≠ ⊥) : a + b = a + c ↔ b = c :=\n  WithTop.add_left_cancel_iff ha\n\n"}
{"name":"WithBot.add_left_cancel","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝¹ : Add α\na b c : WithBot α\ninst✝ : IsLeftCancelAdd α\nha : Ne a Bot.bot\nh : Eq (HAdd.hAdd a b) (HAdd.hAdd a c)\n⊢ Eq b c","decl":"theorem add_left_cancel [IsLeftCancelAdd α] (ha : a ≠ ⊥) (h : a + b = a + c) : b = c :=\n  WithTop.add_left_cancel ha h\n\n-- There is no `WithBot.map_mul_of_mulHom`, since `WithBot` does not have a multiplication.\n"}
{"name":"WithBot.map_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : Add α\nF : Type u_1\ninst✝² : Add β\ninst✝¹ : FunLike F α β\ninst✝ : AddHomClass F α β\nf : F\na b : WithBot α\n⊢ Eq (WithBot.map (⇑f) (HAdd.hAdd a b)) (HAdd.hAdd (WithBot.map (⇑f) a) (WithBot.map (⇑f) b))","decl":"@[simp]\nprotected theorem map_add {F} [Add β] [FunLike F α β] [AddHomClass F α β]\n    (f : F) (a b : WithBot α) :\n    (a + b).map f = a.map f + b.map f :=\n  WithTop.map_add f a b\n\n"}
{"name":"ZeroHom.withBotMap_apply","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Zero M\ninst✝ : Zero N\nf : ZeroHom M N\n⊢ Eq (⇑f.withBotMap) (WithBot.map ⇑f)","decl":"/-- A version of `WithBot.map` for `OneHom`s. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"A version of `WithBot.map` for `ZeroHom`s\"]\nprotected def _root_.OneHom.withBotMap {M N : Type*} [One M] [One N] (f : OneHom M N) :\n    OneHom (WithBot M) (WithBot N) where\n  toFun := WithBot.map f\n  map_one' := by rw [WithBot.map_one, map_one, coe_one]\n\n"}
{"name":"OneHom.withBotMap_apply","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : One M\ninst✝ : One N\nf : OneHom M N\n⊢ Eq (⇑f.withBotMap) (WithBot.map ⇑f)","decl":"/-- A version of `WithBot.map` for `OneHom`s. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"A version of `WithBot.map` for `ZeroHom`s\"]\nprotected def _root_.OneHom.withBotMap {M N : Type*} [One M] [One N] (f : OneHom M N) :\n    OneHom (WithBot M) (WithBot N) where\n  toFun := WithBot.map f\n  map_one' := by rw [WithBot.map_one, map_one, coe_one]\n\n"}
{"name":"AddHom.withBotMap_apply","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\n⊢ Eq (⇑f.withBotMap) (WithBot.map ⇑f)","decl":"/-- A version of `WithBot.map` for `AddHom`s. -/\n@[simps (config := .asFn)]\nprotected def _root_.AddHom.withBotMap {M N : Type*} [Add M] [Add N] (f : AddHom M N) :\n    AddHom (WithBot M) (WithBot N) where\n  toFun := WithBot.map f\n  map_add' := WithBot.map_add f\n\n"}
{"name":"AddMonoidHom.withBotMap_apply","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\n⊢ Eq (⇑f.withBotMap) (WithBot.map ⇑f)","decl":"/-- A version of `WithBot.map` for `AddMonoidHom`s. -/\n@[simps (config := .asFn)]\nprotected def _root_.AddMonoidHom.withBotMap {M N : Type*} [AddZeroClass M] [AddZeroClass N]\n    (f : M →+ N) : WithBot M →+ WithBot N :=\n  { ZeroHom.withBotMap f.toZeroHom, AddHom.withBotMap f.toAddHom with toFun := WithBot.map f }\n\n"}
{"name":"WithBot.addLeftMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝² : Add α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\n⊢ AddLeftMono (WithBot α)","decl":"instance addLeftMono [AddLeftMono α] : AddLeftMono (WithBot α) :=\n  OrderDual.addLeftMono (α := WithTop αᵒᵈ)\n\n"}
{"name":"WithBot.addRightMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝² : Add α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\n⊢ AddRightMono (WithBot α)","decl":"instance addRightMono [AddRightMono α] : AddRightMono (WithBot α) :=\n  OrderDual.addRightMono (α := WithTop αᵒᵈ)\n\n"}
{"name":"WithBot.addLeftReflectLT","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝² : Add α\ninst✝¹ : Preorder α\ninst✝ : AddLeftReflectLT α\n⊢ AddLeftReflectLT (WithBot α)","decl":"instance addLeftReflectLT [AddLeftReflectLT α] : AddLeftReflectLT (WithBot α) :=\n  OrderDual.addLeftReflectLT (α := WithTop αᵒᵈ)\n\n"}
{"name":"WithBot.addRightReflectLT","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝² : Add α\ninst✝¹ : Preorder α\ninst✝ : AddRightReflectLT α\n⊢ AddRightReflectLT (WithBot α)","decl":"instance addRightReflectLT [AddRightReflectLT α] : AddRightReflectLT (WithBot α) :=\n  OrderDual.addRightReflectLT (α := WithTop αᵒᵈ)\n\n"}
{"name":"WithBot.le_of_add_le_add_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝² : Add α\na b c : WithBot α\ninst✝¹ : Preorder α\ninst✝ : AddLeftReflectLE α\nha : Ne a Bot.bot\nh : LE.le (HAdd.hAdd a b) (HAdd.hAdd a c)\n⊢ LE.le b c","decl":"protected theorem le_of_add_le_add_left [AddLeftReflectLE α] (ha : a ≠ ⊥)\n    (h : a + b ≤ a + c) : b ≤ c :=\n  WithTop.le_of_add_le_add_left (α := αᵒᵈ) ha h\n\n"}
{"name":"WithBot.le_of_add_le_add_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝² : Add α\na b c : WithBot α\ninst✝¹ : Preorder α\ninst✝ : AddRightReflectLE α\nha : Ne a Bot.bot\nh : LE.le (HAdd.hAdd b a) (HAdd.hAdd c a)\n⊢ LE.le b c","decl":"protected theorem le_of_add_le_add_right [AddRightReflectLE α]\n    (ha : a ≠ ⊥) (h : b + a ≤ c + a) : b ≤ c :=\n  WithTop.le_of_add_le_add_right (α := αᵒᵈ) ha h\n\n"}
{"name":"WithBot.add_lt_add_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝² : Add α\na b c : WithBot α\ninst✝¹ : Preorder α\ninst✝ : AddLeftStrictMono α\nha : Ne a Bot.bot\nh : LT.lt b c\n⊢ LT.lt (HAdd.hAdd a b) (HAdd.hAdd a c)","decl":"protected theorem add_lt_add_left [AddLeftStrictMono α] (ha : a ≠ ⊥) (h : b < c) :\n    a + b < a + c :=\n  WithTop.add_lt_add_left (α := αᵒᵈ) ha h\n\n"}
{"name":"WithBot.add_lt_add_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝² : Add α\na b c : WithBot α\ninst✝¹ : Preorder α\ninst✝ : AddRightStrictMono α\nha : Ne a Bot.bot\nh : LT.lt b c\n⊢ LT.lt (HAdd.hAdd b a) (HAdd.hAdd c a)","decl":"protected theorem add_lt_add_right [AddRightStrictMono α] (ha : a ≠ ⊥)\n    (h : b < c) : b + a < c + a :=\n  WithTop.add_lt_add_right (α := αᵒᵈ) ha h\n\n"}
{"name":"WithBot.add_le_add_iff_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝³ : Add α\na b c : WithBot α\ninst✝² : Preorder α\ninst✝¹ : AddLeftMono α\ninst✝ : AddLeftReflectLE α\nha : Ne a Bot.bot\n⊢ Iff (LE.le (HAdd.hAdd a b) (HAdd.hAdd a c)) (LE.le b c)","decl":"protected theorem add_le_add_iff_left [AddLeftMono α]\n    [AddLeftReflectLE α] (ha : a ≠ ⊥) : a + b ≤ a + c ↔ b ≤ c :=\n  ⟨WithBot.le_of_add_le_add_left ha, fun h => add_le_add_left h a⟩\n\n"}
{"name":"WithBot.add_le_add_iff_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝³ : Add α\na b c : WithBot α\ninst✝² : Preorder α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nha : Ne a Bot.bot\n⊢ Iff (LE.le (HAdd.hAdd b a) (HAdd.hAdd c a)) (LE.le b c)","decl":"protected theorem add_le_add_iff_right [AddRightMono α]\n    [AddRightReflectLE α] (ha : a ≠ ⊥) : b + a ≤ c + a ↔ b ≤ c :=\n  ⟨WithBot.le_of_add_le_add_right ha, fun h => add_le_add_right h a⟩\n\n"}
{"name":"WithBot.add_lt_add_iff_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝³ : Add α\na b c : WithBot α\ninst✝² : Preorder α\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddLeftReflectLT α\nha : Ne a Bot.bot\n⊢ Iff (LT.lt (HAdd.hAdd a b) (HAdd.hAdd a c)) (LT.lt b c)","decl":"protected theorem add_lt_add_iff_left [AddLeftStrictMono α]\n    [AddLeftReflectLT α] (ha : a ≠ ⊥) : a + b < a + c ↔ b < c :=\n  ⟨lt_of_add_lt_add_left, WithBot.add_lt_add_left ha⟩\n\n"}
{"name":"WithBot.add_lt_add_iff_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝³ : Add α\na b c : WithBot α\ninst✝² : Preorder α\ninst✝¹ : AddRightStrictMono α\ninst✝ : AddRightReflectLT α\nha : Ne a Bot.bot\n⊢ Iff (LT.lt (HAdd.hAdd b a) (HAdd.hAdd c a)) (LT.lt b c)","decl":"protected theorem add_lt_add_iff_right [AddRightStrictMono α]\n    [AddRightReflectLT α] (ha : a ≠ ⊥) : b + a < c + a ↔ b < c :=\n  ⟨lt_of_add_lt_add_right, WithBot.add_lt_add_right ha⟩\n\n"}
{"name":"WithBot.add_lt_add_of_le_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝³ : Add α\na b c d : WithBot α\ninst✝² : Preorder α\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddRightMono α\nhb : Ne b Bot.bot\nhab : LE.le a b\nhcd : LT.lt c d\n⊢ LT.lt (HAdd.hAdd a c) (HAdd.hAdd b d)","decl":"protected theorem add_lt_add_of_le_of_lt [AddLeftStrictMono α]\n    [AddRightMono α] (hb : b ≠ ⊥) (hab : a ≤ b) (hcd : c < d) :\n    a + c < b + d :=\n  WithTop.add_lt_add_of_le_of_lt (α := αᵒᵈ) hb hab hcd\n\n"}
{"name":"WithBot.add_lt_add_of_lt_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.WithTop","initialProofState":"α : Type u\ninst✝³ : Add α\na b c d : WithBot α\ninst✝² : Preorder α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightStrictMono α\nhd : Ne d Bot.bot\nhab : LT.lt a b\nhcd : LE.le c d\n⊢ LT.lt (HAdd.hAdd a c) (HAdd.hAdd b d)","decl":"protected theorem add_lt_add_of_lt_of_le [AddLeftMono α]\n    [AddRightStrictMono α] (hd : d ≠ ⊥) (hab : a < b) (hcd : c ≤ d) :\n    a + c < b + d :=\n  WithTop.add_lt_add_of_lt_of_le (α := αᵒᵈ) hd hab hcd\n\n"}
