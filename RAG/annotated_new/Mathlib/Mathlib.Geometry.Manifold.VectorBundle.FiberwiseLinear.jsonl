{"name":"FiberwiseLinear.trans_partialHomeomorph_apply","module":"Mathlib.Geometry.Manifold.VectorBundle.FiberwiseLinear","initialProofState":"ùïú : Type u_1\nB : Type u_2\nF : Type u_3\ninst‚úù¬≥ : TopologicalSpace B\ninst‚úù¬≤ : NontriviallyNormedField ùïú\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nœÜ œÜ' : B ‚Üí ContinuousLinearEquiv (RingHom.id ùïú) F F\nU U' : Set B\nhU : IsOpen U\nhœÜ : ContinuousOn (fun x => ‚Üë(œÜ x)) U\nh2œÜ : ContinuousOn (fun x => ‚Üë(œÜ x).symm) U\nhU' : IsOpen U'\nhœÜ' : ContinuousOn (fun x => ‚Üë(œÜ' x)) U'\nh2œÜ' : ContinuousOn (fun x => ‚Üë(œÜ' x).symm) U'\nb : B\nv : F\n‚ä¢ Eq (‚Üë((FiberwiseLinear.partialHomeomorph œÜ hU hœÜ h2œÜ).trans (FiberwiseLinear.partialHomeomorph œÜ' hU' hœÜ' h2œÜ')) { fst := b, snd := v }) { fst := b, snd := (œÜ' b) ((œÜ b) v) }","decl":"/-- Compute the composition of two partial homeomorphisms induced by fiberwise linear\nequivalences. -/\ntheorem trans_partialHomeomorph_apply (hU : IsOpen U)\n    (hœÜ : ContinuousOn (fun x => œÜ x : B ‚Üí F ‚ÜíL[ùïú] F) U)\n    (h2œÜ : ContinuousOn (fun x => (œÜ x).symm : B ‚Üí F ‚ÜíL[ùïú] F) U) (hU' : IsOpen U')\n    (hœÜ' : ContinuousOn (fun x => œÜ' x : B ‚Üí F ‚ÜíL[ùïú] F) U')\n    (h2œÜ' : ContinuousOn (fun x => (œÜ' x).symm : B ‚Üí F ‚ÜíL[ùïú] F) U') (b : B) (v : F) :\n    (FiberwiseLinear.partialHomeomorph œÜ hU hœÜ h2œÜ ‚â´‚Çï\n      FiberwiseLinear.partialHomeomorph œÜ' hU' hœÜ' h2œÜ')\n        ‚ü®b, v‚ü© =\n      ‚ü®b, œÜ' b (œÜ b v)‚ü© :=\n  rfl\n\n"}
{"name":"FiberwiseLinear.source_trans_partialHomeomorph","module":"Mathlib.Geometry.Manifold.VectorBundle.FiberwiseLinear","initialProofState":"ùïú : Type u_1\nB : Type u_2\nF : Type u_3\ninst‚úù¬≥ : TopologicalSpace B\ninst‚úù¬≤ : NontriviallyNormedField ùïú\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nœÜ œÜ' : B ‚Üí ContinuousLinearEquiv (RingHom.id ùïú) F F\nU U' : Set B\nhU : IsOpen U\nhœÜ : ContinuousOn (fun x => ‚Üë(œÜ x)) U\nh2œÜ : ContinuousOn (fun x => ‚Üë(œÜ x).symm) U\nhU' : IsOpen U'\nhœÜ' : ContinuousOn (fun x => ‚Üë(œÜ' x)) U'\nh2œÜ' : ContinuousOn (fun x => ‚Üë(œÜ' x).symm) U'\n‚ä¢ Eq ((FiberwiseLinear.partialHomeomorph œÜ hU hœÜ h2œÜ).trans (FiberwiseLinear.partialHomeomorph œÜ' hU' hœÜ' h2œÜ')).source (SProd.sprod (Inter.inter U U') Set.univ)","decl":"/-- Compute the source of the composition of two partial homeomorphisms induced by fiberwise linear\nequivalences. -/\ntheorem source_trans_partialHomeomorph (hU : IsOpen U)\n    (hœÜ : ContinuousOn (fun x => œÜ x : B ‚Üí F ‚ÜíL[ùïú] F) U)\n    (h2œÜ : ContinuousOn (fun x => (œÜ x).symm : B ‚Üí F ‚ÜíL[ùïú] F) U) (hU' : IsOpen U')\n    (hœÜ' : ContinuousOn (fun x => œÜ' x : B ‚Üí F ‚ÜíL[ùïú] F) U')\n    (h2œÜ' : ContinuousOn (fun x => (œÜ' x).symm : B ‚Üí F ‚ÜíL[ùïú] F) U') :\n    (FiberwiseLinear.partialHomeomorph œÜ hU hœÜ h2œÜ ‚â´‚Çï\n          FiberwiseLinear.partialHomeomorph œÜ' hU' hœÜ' h2œÜ').source =\n      (U ‚à© U') √óÀ¢ univ := by\n  dsimp only [FiberwiseLinear.partialHomeomorph]; mfld_set_tac\n\n"}
{"name":"FiberwiseLinear.target_trans_partialHomeomorph","module":"Mathlib.Geometry.Manifold.VectorBundle.FiberwiseLinear","initialProofState":"ùïú : Type u_1\nB : Type u_2\nF : Type u_3\ninst‚úù¬≥ : TopologicalSpace B\ninst‚úù¬≤ : NontriviallyNormedField ùïú\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nœÜ œÜ' : B ‚Üí ContinuousLinearEquiv (RingHom.id ùïú) F F\nU U' : Set B\nhU : IsOpen U\nhœÜ : ContinuousOn (fun x => ‚Üë(œÜ x)) U\nh2œÜ : ContinuousOn (fun x => ‚Üë(œÜ x).symm) U\nhU' : IsOpen U'\nhœÜ' : ContinuousOn (fun x => ‚Üë(œÜ' x)) U'\nh2œÜ' : ContinuousOn (fun x => ‚Üë(œÜ' x).symm) U'\n‚ä¢ Eq ((FiberwiseLinear.partialHomeomorph œÜ hU hœÜ h2œÜ).trans (FiberwiseLinear.partialHomeomorph œÜ' hU' hœÜ' h2œÜ')).target (SProd.sprod (Inter.inter U U') Set.univ)","decl":"/-- Compute the target of the composition of two partial homeomorphisms induced by fiberwise linear\nequivalences. -/\ntheorem target_trans_partialHomeomorph (hU : IsOpen U)\n    (hœÜ : ContinuousOn (fun x => œÜ x : B ‚Üí F ‚ÜíL[ùïú] F) U)\n    (h2œÜ : ContinuousOn (fun x => (œÜ x).symm : B ‚Üí F ‚ÜíL[ùïú] F) U) (hU' : IsOpen U')\n    (hœÜ' : ContinuousOn (fun x => œÜ' x : B ‚Üí F ‚ÜíL[ùïú] F) U')\n    (h2œÜ' : ContinuousOn (fun x => (œÜ' x).symm : B ‚Üí F ‚ÜíL[ùïú] F) U') :\n    (FiberwiseLinear.partialHomeomorph œÜ hU hœÜ h2œÜ ‚â´‚Çï\n          FiberwiseLinear.partialHomeomorph œÜ' hU' hœÜ' h2œÜ').target =\n      (U ‚à© U') √óÀ¢ univ := by\n  dsimp only [FiberwiseLinear.partialHomeomorph]; mfld_set_tac\n\n"}
{"name":"ContMDiffFiberwiseLinear.locality_aux‚ÇÅ","module":"Mathlib.Geometry.Manifold.VectorBundle.FiberwiseLinear","initialProofState":"ùïú : Type u_1\nB : Type u_2\nF : Type u_3\ninst‚úù‚Å∑ : TopologicalSpace B\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\ninst‚úù‚Åµ : NormedAddCommGroup F\ninst‚úù‚Å¥ : NormedSpace ùïú F\nEB : Type u_4\ninst‚úù¬≥ : NormedAddCommGroup EB\ninst‚úù¬≤ : NormedSpace ùïú EB\nHB : Type u_5\ninst‚úù¬π : TopologicalSpace HB\ninst‚úù : ChartedSpace HB B\nIB : ModelWithCorners ùïú EB HB\nn : WithTop ENat\ne : PartialHomeomorph (Prod B F) (Prod B F)\nh : ‚àÄ (p : Prod B F), Membership.mem e.source p ‚Üí Exists fun s => And (IsOpen s) (And (Membership.mem s p) (Exists fun œÜ => Exists fun u => Exists fun hu => Exists fun hœÜ => Exists fun h2œÜ => (e.restr s).EqOnSource (FiberwiseLinear.partialHomeomorph œÜ hu ‚ãØ ‚ãØ)))\n‚ä¢ Exists fun U => And (Eq e.source (SProd.sprod U Set.univ)) (‚àÄ (x : B), Membership.mem U x ‚Üí Exists fun œÜ => Exists fun u => Exists fun hu => Exists fun _huU => Exists fun _hux => Exists fun hœÜ => Exists fun h2œÜ => (e.restr (SProd.sprod u Set.univ)).EqOnSource (FiberwiseLinear.partialHomeomorph œÜ hu ‚ãØ ‚ãØ))","decl":"/-- Let `e` be a partial homeomorphism of `B √ó F`.  Suppose that at every point `p` in the source of\n`e`, there is some neighbourhood `s` of `p` on which `e` is equal to a bi-`C^n` fiberwise linear\npartial homeomorphism.\nThen the source of `e` is of the form `U √óÀ¢ univ`, for some set `U` in `B`, and, at any point `x` in\n`U`, admits a neighbourhood `u` of `x` such that `e` is equal on `u √óÀ¢ univ` to some bi-`C^n`\nfiberwise linear partial homeomorphism. -/\ntheorem ContMDiffFiberwiseLinear.locality_aux‚ÇÅ\n    (n : WithTop ‚Ñï‚àû) (e : PartialHomeomorph (B √ó F) (B √ó F))\n    (h : ‚àÄ p ‚àà e.source, ‚àÉ s : Set (B √ó F), IsOpen s ‚àß p ‚àà s ‚àß\n      ‚àÉ (œÜ : B ‚Üí F ‚âÉL[ùïú] F) (u : Set B) (hu : IsOpen u)\n        (hœÜ : ContMDiffOn IB ùìò(ùïú, F ‚ÜíL[ùïú] F) n (fun x => (œÜ x : F ‚ÜíL[ùïú] F)) u)\n        (h2œÜ : ContMDiffOn IB ùìò(ùïú, F ‚ÜíL[ùïú] F) n (fun x => ((œÜ x).symm : F ‚ÜíL[ùïú] F)) u),\n          (e.restr s).EqOnSource\n            (FiberwiseLinear.partialHomeomorph œÜ hu hœÜ.continuousOn h2œÜ.continuousOn)) :\n    ‚àÉ U : Set B, e.source = U √óÀ¢ univ ‚àß ‚àÄ x ‚àà U,\n        ‚àÉ (œÜ : B ‚Üí F ‚âÉL[ùïú] F) (u : Set B) (hu : IsOpen u) (_huU : u ‚äÜ U) (_hux : x ‚àà u),\n          ‚àÉ (hœÜ : ContMDiffOn IB ùìò(ùïú, F ‚ÜíL[ùïú] F) n (fun x => (œÜ x : F ‚ÜíL[ùïú] F)) u)\n            (h2œÜ : ContMDiffOn IB ùìò(ùïú, F ‚ÜíL[ùïú] F) n (fun x => ((œÜ x).symm : F ‚ÜíL[ùïú] F)) u),\n            (e.restr (u √óÀ¢ univ)).EqOnSource\n              (FiberwiseLinear.partialHomeomorph œÜ hu hœÜ.continuousOn h2œÜ.continuousOn) := by\n  rw [SetCoe.forall'] at h\n  choose s hs hsp œÜ u hu hœÜ h2œÜ heœÜ using h\n  have hesu : ‚àÄ p : e.source, e.source ‚à© s p = u p √óÀ¢ univ := by\n    intro p\n    rw [‚Üê e.restr_source' (s _) (hs _)]\n    exact (heœÜ p).1\n  have hu' : ‚àÄ p : e.source, (p : B √ó F).fst ‚àà u p := by\n    intro p\n    have : (p : B √ó F) ‚àà e.source ‚à© s p := ‚ü®p.prop, hsp p‚ü©\n    simpa only [hesu, mem_prod, mem_univ, and_true] using this\n  have heu : ‚àÄ p : e.source, ‚àÄ q : B √ó F, q.fst ‚àà u p ‚Üí q ‚àà e.source := by\n    intro p q hq\n    have : q ‚àà u p √óÀ¢ (univ : Set F) := ‚ü®hq, trivial‚ü©\n    rw [‚Üê hesu p] at this\n    exact this.1\n  have he : e.source = (Prod.fst '' e.source) √óÀ¢ (univ : Set F) := by\n    apply HasSubset.Subset.antisymm\n    ¬∑ intro p hp\n      exact ‚ü®‚ü®p, hp, rfl‚ü©, trivial‚ü©\n    ¬∑ rintro ‚ü®x, v‚ü© ‚ü®‚ü®p, hp, rfl : p.fst = x‚ü©, -‚ü©\n      exact heu ‚ü®p, hp‚ü© (p.fst, v) (hu' ‚ü®p, hp‚ü©)\n  refine ‚ü®Prod.fst '' e.source, he, ?_‚ü©\n  rintro x ‚ü®p, hp, rfl‚ü©\n  refine ‚ü®œÜ ‚ü®p, hp‚ü©, u ‚ü®p, hp‚ü©, hu ‚ü®p, hp‚ü©, ?_, hu' _, hœÜ ‚ü®p, hp‚ü©, h2œÜ ‚ü®p, hp‚ü©, ?_‚ü©\n  ¬∑ intro y hy; exact ‚ü®(y, 0), heu ‚ü®p, hp‚ü© ‚ü®_, _‚ü© hy, rfl‚ü©\n  ¬∑ rw [‚Üê hesu, e.restr_source_inter]; exact heœÜ ‚ü®p, hp‚ü©\n\n"}
{"name":"SmoothFiberwiseLinear.locality_aux‚ÇÅ","module":"Mathlib.Geometry.Manifold.VectorBundle.FiberwiseLinear","initialProofState":"ùïú : Type u_1\nB : Type u_2\nF : Type u_3\ninst‚úù‚Å∑ : TopologicalSpace B\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\ninst‚úù‚Åµ : NormedAddCommGroup F\ninst‚úù‚Å¥ : NormedSpace ùïú F\nEB : Type u_4\ninst‚úù¬≥ : NormedAddCommGroup EB\ninst‚úù¬≤ : NormedSpace ùïú EB\nHB : Type u_5\ninst‚úù¬π : TopologicalSpace HB\ninst‚úù : ChartedSpace HB B\nIB : ModelWithCorners ùïú EB HB\nn : WithTop ENat\ne : PartialHomeomorph (Prod B F) (Prod B F)\nh : ‚àÄ (p : Prod B F), Membership.mem e.source p ‚Üí Exists fun s => And (IsOpen s) (And (Membership.mem s p) (Exists fun œÜ => Exists fun u => Exists fun hu => Exists fun hœÜ => Exists fun h2œÜ => (e.restr s).EqOnSource (FiberwiseLinear.partialHomeomorph œÜ hu ‚ãØ ‚ãØ)))\n‚ä¢ Exists fun U => And (Eq e.source (SProd.sprod U Set.univ)) (‚àÄ (x : B), Membership.mem U x ‚Üí Exists fun œÜ => Exists fun u => Exists fun hu => Exists fun _huU => Exists fun _hux => Exists fun hœÜ => Exists fun h2œÜ => (e.restr (SProd.sprod u Set.univ)).EqOnSource (FiberwiseLinear.partialHomeomorph œÜ hu ‚ãØ ‚ãØ))","decl":"@[deprecated (since := \"2025-01-09\")]\nalias SmoothFiberwiseLinear.locality_aux‚ÇÅ := ContMDiffFiberwiseLinear.locality_aux‚ÇÅ\n\n"}
{"name":"ContMDiffFiberwiseLinear.locality_aux‚ÇÇ","module":"Mathlib.Geometry.Manifold.VectorBundle.FiberwiseLinear","initialProofState":"ùïú : Type u_1\nB : Type u_2\nF : Type u_3\ninst‚úù‚Å∑ : TopologicalSpace B\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\ninst‚úù‚Åµ : NormedAddCommGroup F\ninst‚úù‚Å¥ : NormedSpace ùïú F\nEB : Type u_4\ninst‚úù¬≥ : NormedAddCommGroup EB\ninst‚úù¬≤ : NormedSpace ùïú EB\nHB : Type u_5\ninst‚úù¬π : TopologicalSpace HB\ninst‚úù : ChartedSpace HB B\nIB : ModelWithCorners ùïú EB HB\nn : WithTop ENat\ne : PartialHomeomorph (Prod B F) (Prod B F)\nU : Set B\nhU : Eq e.source (SProd.sprod U Set.univ)\nh : ‚àÄ (x : B), Membership.mem U x ‚Üí Exists fun œÜ => Exists fun u => Exists fun hu => Exists fun _hUu => Exists fun _hux => Exists fun hœÜ => Exists fun h2œÜ => (e.restr (SProd.sprod u Set.univ)).EqOnSource (FiberwiseLinear.partialHomeomorph œÜ hu ‚ãØ ‚ãØ)\n‚ä¢ Exists fun Œ¶ => Exists fun U => Exists fun hU‚ÇÄ => Exists fun hŒ¶ => Exists fun h2Œ¶ => e.EqOnSource (FiberwiseLinear.partialHomeomorph Œ¶ hU‚ÇÄ ‚ãØ ‚ãØ)","decl":"/-- Let `e` be a partial homeomorphism of `B √ó F` whose source is `U √óÀ¢ univ`, for some set `U` in\n`B`, and which, at any point `x` in `U`, admits a neighbourhood `u` of `x` such that `e` is equal\non `u √óÀ¢ univ` to some bi-`C^n` fiberwise linear partial homeomorphism.  Then `e` itself\nis equal to some bi-`C^n` fiberwise linear partial homeomorphism.\n\nThis is the key mathematical point of the `locality` condition in the construction of the\n`StructureGroupoid` of bi-`C^n` fiberwise linear partial homeomorphisms.  The proof is by gluing\ntogether the various bi-`C^n` fiberwise linear partial homeomorphism which exist locally.\n\nThe `U` in the conclusion is the same `U` as in the hypothesis. We state it like this, because this\nis exactly what we need for `contMDiffFiberwiseLinear`. -/\ntheorem ContMDiffFiberwiseLinear.locality_aux‚ÇÇ\n    (n : WithTop ‚Ñï‚àû) (e : PartialHomeomorph (B √ó F) (B √ó F)) (U : Set B) (hU : e.source = U √óÀ¢ univ)\n    (h : ‚àÄ x ‚àà U,\n      ‚àÉ (œÜ : B ‚Üí F ‚âÉL[ùïú] F) (u : Set B) (hu : IsOpen u) (_hUu : u ‚äÜ U) (_hux : x ‚àà u)\n        (hœÜ : ContMDiffOn IB ùìò(ùïú, F ‚ÜíL[ùïú] F) n (fun x => (œÜ x : F ‚ÜíL[ùïú] F)) u)\n        (h2œÜ : ContMDiffOn IB ùìò(ùïú, F ‚ÜíL[ùïú] F) n (fun x => ((œÜ x).symm : F ‚ÜíL[ùïú] F)) u),\n          (e.restr (u √óÀ¢ univ)).EqOnSource\n            (FiberwiseLinear.partialHomeomorph œÜ hu hœÜ.continuousOn h2œÜ.continuousOn)) :\n    ‚àÉ (Œ¶ : B ‚Üí F ‚âÉL[ùïú] F) (U : Set B) (hU‚ÇÄ : IsOpen U) (hŒ¶ :\n      ContMDiffOn IB ùìò(ùïú, F ‚ÜíL[ùïú] F) n (fun x => (Œ¶ x : F ‚ÜíL[ùïú] F)) U) (h2Œ¶ :\n      ContMDiffOn IB ùìò(ùïú, F ‚ÜíL[ùïú] F) n (fun x => ((Œ¶ x).symm : F ‚ÜíL[ùïú] F)) U),\n      e.EqOnSource (FiberwiseLinear.partialHomeomorph Œ¶ hU‚ÇÄ hŒ¶.continuousOn h2Œ¶.continuousOn) := by\n  classical\n  rw [SetCoe.forall'] at h\n  choose! œÜ u hu hUu hux hœÜ h2œÜ heœÜ using h\n  have heuœÜ : ‚àÄ x : U, EqOn e (fun q => (q.1, œÜ x q.1 q.2)) (u x √óÀ¢ univ) := fun x p hp ‚Ü¶ by\n    refine (heœÜ x).2 ?_\n    rw [(heœÜ x).1]\n    exact hp\n  have huœÜ : ‚àÄ (x x' : U) (y : B), y ‚àà u x ‚Üí y ‚àà u x' ‚Üí œÜ x y = œÜ x' y := fun p p' y hyp hyp' ‚Ü¶ by\n    ext v\n    have h1 : e (y, v) = (y, œÜ p y v) := heuœÜ _ ‚ü®(id hyp : (y, v).fst ‚àà u p), trivial‚ü©\n    have h2 : e (y, v) = (y, œÜ p' y v) := heuœÜ _ ‚ü®(id hyp' : (y, v).fst ‚àà u p'), trivial‚ü©\n    exact congr_arg Prod.snd (h1.symm.trans h2)\n  have hUu' : U = ‚ãÉ i, u i := by\n    ext x\n    rw [mem_iUnion]\n    refine ‚ü®fun h => ‚ü®‚ü®x, h‚ü©, hux _‚ü©, ?_‚ü©\n    rintro ‚ü®x, hx‚ü©\n    exact hUu x hx\n  have hU' : IsOpen U := by\n    rw [hUu']\n    apply isOpen_iUnion hu\n  let Œ¶‚ÇÄ : U ‚Üí F ‚âÉL[ùïú] F := iUnionLift u (fun x => œÜ x ‚àò (‚Üë)) huœÜ U hUu'.le\n  let Œ¶ : B ‚Üí F ‚âÉL[ùïú] F := fun y =>\n    if hy : y ‚àà U then Œ¶‚ÇÄ ‚ü®y, hy‚ü© else ContinuousLinearEquiv.refl ùïú F\n  have hŒ¶ : ‚àÄ (y) (hy : y ‚àà U), Œ¶ y = Œ¶‚ÇÄ ‚ü®y, hy‚ü© := fun y hy => dif_pos hy\n  have hŒ¶œÜ : ‚àÄ x : U, ‚àÄ y ‚àà u x, Œ¶ y = œÜ x y := by\n    intro x y hyu\n    refine (hŒ¶ y (hUu x hyu)).trans ?_\n    exact iUnionLift_mk ‚ü®y, hyu‚ü© _\n  have hŒ¶ : ContMDiffOn IB ùìò(ùïú, F ‚ÜíL[ùïú] F) n (fun y => (Œ¶ y : F ‚ÜíL[ùïú] F)) U := by\n    apply contMDiffOn_of_locally_contMDiffOn\n    intro x hx\n    refine ‚ü®u ‚ü®x, hx‚ü©, hu ‚ü®x, hx‚ü©, hux _, ?_‚ü©\n    refine (ContMDiffOn.congr (hœÜ ‚ü®x, hx‚ü©) ?_).mono inter_subset_right\n    intro y hy\n    rw [hŒ¶œÜ ‚ü®x, hx‚ü© y hy]\n  have h2Œ¶ : ContMDiffOn IB ùìò(ùïú, F ‚ÜíL[ùïú] F) n (fun y => ((Œ¶ y).symm : F ‚ÜíL[ùïú] F)) U := by\n    apply contMDiffOn_of_locally_contMDiffOn\n    intro x hx\n    refine ‚ü®u ‚ü®x, hx‚ü©, hu ‚ü®x, hx‚ü©, hux _, ?_‚ü©\n    refine (ContMDiffOn.congr (h2œÜ ‚ü®x, hx‚ü©) ?_).mono inter_subset_right\n    intro y hy\n    rw [hŒ¶œÜ ‚ü®x, hx‚ü© y hy]\n  refine ‚ü®Œ¶, U, hU', hŒ¶, h2Œ¶, hU, fun p hp => ?_‚ü©\n  rw [hU] at hp\n  rw [heuœÜ ‚ü®p.fst, hp.1‚ü© ‚ü®hux _, hp.2‚ü©]\n  congrm (_, ?_)\n  rw [hŒ¶œÜ]\n  apply hux\n\n"}
{"name":"SmoothFiberwiseLinear.locality_aux‚ÇÇ","module":"Mathlib.Geometry.Manifold.VectorBundle.FiberwiseLinear","initialProofState":"ùïú : Type u_1\nB : Type u_2\nF : Type u_3\ninst‚úù‚Å∑ : TopologicalSpace B\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\ninst‚úù‚Åµ : NormedAddCommGroup F\ninst‚úù‚Å¥ : NormedSpace ùïú F\nEB : Type u_4\ninst‚úù¬≥ : NormedAddCommGroup EB\ninst‚úù¬≤ : NormedSpace ùïú EB\nHB : Type u_5\ninst‚úù¬π : TopologicalSpace HB\ninst‚úù : ChartedSpace HB B\nIB : ModelWithCorners ùïú EB HB\nn : WithTop ENat\ne : PartialHomeomorph (Prod B F) (Prod B F)\nU : Set B\nhU : Eq e.source (SProd.sprod U Set.univ)\nh : ‚àÄ (x : B), Membership.mem U x ‚Üí Exists fun œÜ => Exists fun u => Exists fun hu => Exists fun _hUu => Exists fun _hux => Exists fun hœÜ => Exists fun h2œÜ => (e.restr (SProd.sprod u Set.univ)).EqOnSource (FiberwiseLinear.partialHomeomorph œÜ hu ‚ãØ ‚ãØ)\n‚ä¢ Exists fun Œ¶ => Exists fun U => Exists fun hU‚ÇÄ => Exists fun hŒ¶ => Exists fun h2Œ¶ => e.EqOnSource (FiberwiseLinear.partialHomeomorph Œ¶ hU‚ÇÄ ‚ãØ ‚ãØ)","decl":"@[deprecated (since := \"2025-01-09\")]\nalias SmoothFiberwiseLinear.locality_aux‚ÇÇ := ContMDiffFiberwiseLinear.locality_aux‚ÇÇ\n\n-- Having this private lemma speeds up `simp` calls below a lot.\n-- TODO: understand why and fix the underlying issue (relatedly, the `simp` calls\n-- in `contMDiffFiberwiseLinear` are quite slow, even with this change)\n"}
{"name":"mem_contMDiffFiberwiseLinear_iff","module":"Mathlib.Geometry.Manifold.VectorBundle.FiberwiseLinear","initialProofState":"ùïú : Type u_1\nB : Type u_2\nF : Type u_3\ninst‚úù‚Å∑ : TopologicalSpace B\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\ninst‚úù‚Åµ : NormedAddCommGroup F\ninst‚úù‚Å¥ : NormedSpace ùïú F\nEB : Type u_4\ninst‚úù¬≥ : NormedAddCommGroup EB\ninst‚úù¬≤ : NormedSpace ùïú EB\nHB : Type u_5\ninst‚úù¬π : TopologicalSpace HB\ninst‚úù : ChartedSpace HB B\nIB : ModelWithCorners ùïú EB HB\nn : WithTop ENat\ne : PartialHomeomorph (Prod B F) (Prod B F)\n‚ä¢ Iff (Membership.mem (contMDiffFiberwiseLinear B F IB n) e) (Exists fun œÜ => Exists fun U => Exists fun hU => Exists fun hœÜ => Exists fun h2œÜ => e.EqOnSource (FiberwiseLinear.partialHomeomorph œÜ hU ‚ãØ ‚ãØ))","decl":"@[simp]\ntheorem mem_contMDiffFiberwiseLinear_iff {n : WithTop ‚Ñï‚àû} (e : PartialHomeomorph (B √ó F) (B √ó F)) :\n    e ‚àà contMDiffFiberwiseLinear B F IB n ‚Üî\n      ‚àÉ (œÜ : B ‚Üí F ‚âÉL[ùïú] F) (U : Set B) (hU : IsOpen U) (hœÜ :\n        ContMDiffOn IB ùìò(ùïú, F ‚ÜíL[ùïú] F) n (fun x => œÜ x : B ‚Üí F ‚ÜíL[ùïú] F) U) (h2œÜ :\n        ContMDiffOn IB ùìò(ùïú, F ‚ÜíL[ùïú] F) n (fun x => (œÜ x).symm : B ‚Üí F ‚ÜíL[ùïú] F) U),\n        e.EqOnSource (FiberwiseLinear.partialHomeomorph œÜ hU hœÜ.continuousOn h2œÜ.continuousOn) :=\n  mem_aux\n\n"}
{"name":"mem_smoothFiberwiseLinear_iff","module":"Mathlib.Geometry.Manifold.VectorBundle.FiberwiseLinear","initialProofState":"ùïú : Type u_1\nB : Type u_2\nF : Type u_3\ninst‚úù‚Å∑ : TopologicalSpace B\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\ninst‚úù‚Åµ : NormedAddCommGroup F\ninst‚úù‚Å¥ : NormedSpace ùïú F\nEB : Type u_4\ninst‚úù¬≥ : NormedAddCommGroup EB\ninst‚úù¬≤ : NormedSpace ùïú EB\nHB : Type u_5\ninst‚úù¬π : TopologicalSpace HB\ninst‚úù : ChartedSpace HB B\nIB : ModelWithCorners ùïú EB HB\nn : WithTop ENat\ne : PartialHomeomorph (Prod B F) (Prod B F)\n‚ä¢ Iff (Membership.mem (contMDiffFiberwiseLinear B F IB n) e) (Exists fun œÜ => Exists fun U => Exists fun hU => Exists fun hœÜ => Exists fun h2œÜ => e.EqOnSource (FiberwiseLinear.partialHomeomorph œÜ hU ‚ãØ ‚ãØ))","decl":"@[deprecated (since := \"2025-01-09\")]\nalias mem_smoothFiberwiseLinear_iff := mem_contMDiffFiberwiseLinear_iff\n"}
