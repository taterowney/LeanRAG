{"name":"FiberwiseLinear.trans_partialHomeomorph_apply","module":"Mathlib.Geometry.Manifold.VectorBundle.FiberwiseLinear","initialProofState":"ð•œ : Type u_1\nB : Type u_2\nF : Type u_3\ninstâœÂ³ : TopologicalSpace B\ninstâœÂ² : NontriviallyNormedField ð•œ\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nÏ† Ï†' : B â†’ ContinuousLinearEquiv (RingHom.id ð•œ) F F\nU U' : Set B\nhU : IsOpen U\nhÏ† : ContinuousOn (fun x => â†‘(Ï† x)) U\nh2Ï† : ContinuousOn (fun x => â†‘(Ï† x).symm) U\nhU' : IsOpen U'\nhÏ†' : ContinuousOn (fun x => â†‘(Ï†' x)) U'\nh2Ï†' : ContinuousOn (fun x => â†‘(Ï†' x).symm) U'\nb : B\nv : F\nâŠ¢ Eq (â†‘((FiberwiseLinear.partialHomeomorph Ï† hU hÏ† h2Ï†).trans (FiberwiseLinear.partialHomeomorph Ï†' hU' hÏ†' h2Ï†')) { fst := b, snd := v }) { fst := b, snd := (Ï†' b) ((Ï† b) v) }","decl":"/-- Compute the composition of two partial homeomorphisms induced by fiberwise linear\nequivalences. -/\ntheorem trans_partialHomeomorph_apply (hU : IsOpen U)\n    (hÏ† : ContinuousOn (fun x => Ï† x : B â†’ F â†’L[ð•œ] F) U)\n    (h2Ï† : ContinuousOn (fun x => (Ï† x).symm : B â†’ F â†’L[ð•œ] F) U) (hU' : IsOpen U')\n    (hÏ†' : ContinuousOn (fun x => Ï†' x : B â†’ F â†’L[ð•œ] F) U')\n    (h2Ï†' : ContinuousOn (fun x => (Ï†' x).symm : B â†’ F â†’L[ð•œ] F) U') (b : B) (v : F) :\n    (FiberwiseLinear.partialHomeomorph Ï† hU hÏ† h2Ï† â‰«â‚•\n      FiberwiseLinear.partialHomeomorph Ï†' hU' hÏ†' h2Ï†')\n        âŸ¨b, vâŸ© =\n      âŸ¨b, Ï†' b (Ï† b v)âŸ© :=\n  rfl\n\n"}
{"name":"FiberwiseLinear.source_trans_partialHomeomorph","module":"Mathlib.Geometry.Manifold.VectorBundle.FiberwiseLinear","initialProofState":"ð•œ : Type u_1\nB : Type u_2\nF : Type u_3\ninstâœÂ³ : TopologicalSpace B\ninstâœÂ² : NontriviallyNormedField ð•œ\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nÏ† Ï†' : B â†’ ContinuousLinearEquiv (RingHom.id ð•œ) F F\nU U' : Set B\nhU : IsOpen U\nhÏ† : ContinuousOn (fun x => â†‘(Ï† x)) U\nh2Ï† : ContinuousOn (fun x => â†‘(Ï† x).symm) U\nhU' : IsOpen U'\nhÏ†' : ContinuousOn (fun x => â†‘(Ï†' x)) U'\nh2Ï†' : ContinuousOn (fun x => â†‘(Ï†' x).symm) U'\nâŠ¢ Eq ((FiberwiseLinear.partialHomeomorph Ï† hU hÏ† h2Ï†).trans (FiberwiseLinear.partialHomeomorph Ï†' hU' hÏ†' h2Ï†')).source (SProd.sprod (Inter.inter U U') Set.univ)","decl":"/-- Compute the source of the composition of two partial homeomorphisms induced by fiberwise linear\nequivalences. -/\ntheorem source_trans_partialHomeomorph (hU : IsOpen U)\n    (hÏ† : ContinuousOn (fun x => Ï† x : B â†’ F â†’L[ð•œ] F) U)\n    (h2Ï† : ContinuousOn (fun x => (Ï† x).symm : B â†’ F â†’L[ð•œ] F) U) (hU' : IsOpen U')\n    (hÏ†' : ContinuousOn (fun x => Ï†' x : B â†’ F â†’L[ð•œ] F) U')\n    (h2Ï†' : ContinuousOn (fun x => (Ï†' x).symm : B â†’ F â†’L[ð•œ] F) U') :\n    (FiberwiseLinear.partialHomeomorph Ï† hU hÏ† h2Ï† â‰«â‚•\n          FiberwiseLinear.partialHomeomorph Ï†' hU' hÏ†' h2Ï†').source =\n      (U âˆ© U') Ã—Ë¢ univ := by\n  dsimp only [FiberwiseLinear.partialHomeomorph]; mfld_set_tac\n\n"}
{"name":"FiberwiseLinear.target_trans_partialHomeomorph","module":"Mathlib.Geometry.Manifold.VectorBundle.FiberwiseLinear","initialProofState":"ð•œ : Type u_1\nB : Type u_2\nF : Type u_3\ninstâœÂ³ : TopologicalSpace B\ninstâœÂ² : NontriviallyNormedField ð•œ\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nÏ† Ï†' : B â†’ ContinuousLinearEquiv (RingHom.id ð•œ) F F\nU U' : Set B\nhU : IsOpen U\nhÏ† : ContinuousOn (fun x => â†‘(Ï† x)) U\nh2Ï† : ContinuousOn (fun x => â†‘(Ï† x).symm) U\nhU' : IsOpen U'\nhÏ†' : ContinuousOn (fun x => â†‘(Ï†' x)) U'\nh2Ï†' : ContinuousOn (fun x => â†‘(Ï†' x).symm) U'\nâŠ¢ Eq ((FiberwiseLinear.partialHomeomorph Ï† hU hÏ† h2Ï†).trans (FiberwiseLinear.partialHomeomorph Ï†' hU' hÏ†' h2Ï†')).target (SProd.sprod (Inter.inter U U') Set.univ)","decl":"/-- Compute the target of the composition of two partial homeomorphisms induced by fiberwise linear\nequivalences. -/\ntheorem target_trans_partialHomeomorph (hU : IsOpen U)\n    (hÏ† : ContinuousOn (fun x => Ï† x : B â†’ F â†’L[ð•œ] F) U)\n    (h2Ï† : ContinuousOn (fun x => (Ï† x).symm : B â†’ F â†’L[ð•œ] F) U) (hU' : IsOpen U')\n    (hÏ†' : ContinuousOn (fun x => Ï†' x : B â†’ F â†’L[ð•œ] F) U')\n    (h2Ï†' : ContinuousOn (fun x => (Ï†' x).symm : B â†’ F â†’L[ð•œ] F) U') :\n    (FiberwiseLinear.partialHomeomorph Ï† hU hÏ† h2Ï† â‰«â‚•\n          FiberwiseLinear.partialHomeomorph Ï†' hU' hÏ†' h2Ï†').target =\n      (U âˆ© U') Ã—Ë¢ univ := by\n  dsimp only [FiberwiseLinear.partialHomeomorph]; mfld_set_tac\n\n"}
{"name":"ContMDiffFiberwiseLinear.locality_auxâ‚","module":"Mathlib.Geometry.Manifold.VectorBundle.FiberwiseLinear","initialProofState":"ð•œ : Type u_1\nB : Type u_2\nF : Type u_3\ninstâœâ· : TopologicalSpace B\ninstâœâ¶ : NontriviallyNormedField ð•œ\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ð•œ F\nEB : Type u_4\ninstâœÂ³ : NormedAddCommGroup EB\ninstâœÂ² : NormedSpace ð•œ EB\nHB : Type u_5\ninstâœÂ¹ : TopologicalSpace HB\ninstâœ : ChartedSpace HB B\nIB : ModelWithCorners ð•œ EB HB\nn : WithTop ENat\ne : PartialHomeomorph (Prod B F) (Prod B F)\nh : âˆ€ (p : Prod B F), Membership.mem e.source p â†’ Exists fun s => And (IsOpen s) (And (Membership.mem s p) (Exists fun Ï† => Exists fun u => Exists fun hu => Exists fun hÏ† => Exists fun h2Ï† => (e.restr s).EqOnSource (FiberwiseLinear.partialHomeomorph Ï† hu â‹¯ â‹¯)))\nâŠ¢ Exists fun U => And (Eq e.source (SProd.sprod U Set.univ)) (âˆ€ (x : B), Membership.mem U x â†’ Exists fun Ï† => Exists fun u => Exists fun hu => Exists fun _huU => Exists fun _hux => Exists fun hÏ† => Exists fun h2Ï† => (e.restr (SProd.sprod u Set.univ)).EqOnSource (FiberwiseLinear.partialHomeomorph Ï† hu â‹¯ â‹¯))","decl":"/-- Let `e` be a partial homeomorphism of `B Ã— F`.  Suppose that at every point `p` in the source of\n`e`, there is some neighbourhood `s` of `p` on which `e` is equal to a bi-`C^n` fiberwise linear\npartial homeomorphism.\nThen the source of `e` is of the form `U Ã—Ë¢ univ`, for some set `U` in `B`, and, at any point `x` in\n`U`, admits a neighbourhood `u` of `x` such that `e` is equal on `u Ã—Ë¢ univ` to some bi-`C^n`\nfiberwise linear partial homeomorphism. -/\ntheorem ContMDiffFiberwiseLinear.locality_auxâ‚\n    (n : WithTop â„•âˆž) (e : PartialHomeomorph (B Ã— F) (B Ã— F))\n    (h : âˆ€ p âˆˆ e.source, âˆƒ s : Set (B Ã— F), IsOpen s âˆ§ p âˆˆ s âˆ§\n      âˆƒ (Ï† : B â†’ F â‰ƒL[ð•œ] F) (u : Set B) (hu : IsOpen u)\n        (hÏ† : ContMDiffOn IB ð“˜(ð•œ, F â†’L[ð•œ] F) n (fun x => (Ï† x : F â†’L[ð•œ] F)) u)\n        (h2Ï† : ContMDiffOn IB ð“˜(ð•œ, F â†’L[ð•œ] F) n (fun x => ((Ï† x).symm : F â†’L[ð•œ] F)) u),\n          (e.restr s).EqOnSource\n            (FiberwiseLinear.partialHomeomorph Ï† hu hÏ†.continuousOn h2Ï†.continuousOn)) :\n    âˆƒ U : Set B, e.source = U Ã—Ë¢ univ âˆ§ âˆ€ x âˆˆ U,\n        âˆƒ (Ï† : B â†’ F â‰ƒL[ð•œ] F) (u : Set B) (hu : IsOpen u) (_huU : u âŠ† U) (_hux : x âˆˆ u),\n          âˆƒ (hÏ† : ContMDiffOn IB ð“˜(ð•œ, F â†’L[ð•œ] F) n (fun x => (Ï† x : F â†’L[ð•œ] F)) u)\n            (h2Ï† : ContMDiffOn IB ð“˜(ð•œ, F â†’L[ð•œ] F) n (fun x => ((Ï† x).symm : F â†’L[ð•œ] F)) u),\n            (e.restr (u Ã—Ë¢ univ)).EqOnSource\n              (FiberwiseLinear.partialHomeomorph Ï† hu hÏ†.continuousOn h2Ï†.continuousOn) := by\n  rw [SetCoe.forall'] at h\n  choose s hs hsp Ï† u hu hÏ† h2Ï† heÏ† using h\n  have hesu : âˆ€ p : e.source, e.source âˆ© s p = u p Ã—Ë¢ univ := by\n    intro p\n    rw [â† e.restr_source' (s _) (hs _)]\n    exact (heÏ† p).1\n  have hu' : âˆ€ p : e.source, (p : B Ã— F).fst âˆˆ u p := by\n    intro p\n    have : (p : B Ã— F) âˆˆ e.source âˆ© s p := âŸ¨p.prop, hsp pâŸ©\n    simpa only [hesu, mem_prod, mem_univ, and_true] using this\n  have heu : âˆ€ p : e.source, âˆ€ q : B Ã— F, q.fst âˆˆ u p â†’ q âˆˆ e.source := by\n    intro p q hq\n    have : q âˆˆ u p Ã—Ë¢ (univ : Set F) := âŸ¨hq, trivialâŸ©\n    rw [â† hesu p] at this\n    exact this.1\n  have he : e.source = (Prod.fst '' e.source) Ã—Ë¢ (univ : Set F) := by\n    apply HasSubset.Subset.antisymm\n    Â· intro p hp\n      exact âŸ¨âŸ¨p, hp, rflâŸ©, trivialâŸ©\n    Â· rintro âŸ¨x, vâŸ© âŸ¨âŸ¨p, hp, rfl : p.fst = xâŸ©, -âŸ©\n      exact heu âŸ¨p, hpâŸ© (p.fst, v) (hu' âŸ¨p, hpâŸ©)\n  refine âŸ¨Prod.fst '' e.source, he, ?_âŸ©\n  rintro x âŸ¨p, hp, rflâŸ©\n  refine âŸ¨Ï† âŸ¨p, hpâŸ©, u âŸ¨p, hpâŸ©, hu âŸ¨p, hpâŸ©, ?_, hu' _, hÏ† âŸ¨p, hpâŸ©, h2Ï† âŸ¨p, hpâŸ©, ?_âŸ©\n  Â· intro y hy; exact âŸ¨(y, 0), heu âŸ¨p, hpâŸ© âŸ¨_, _âŸ© hy, rflâŸ©\n  Â· rw [â† hesu, e.restr_source_inter]; exact heÏ† âŸ¨p, hpâŸ©\n\n"}
{"name":"SmoothFiberwiseLinear.locality_auxâ‚","module":"Mathlib.Geometry.Manifold.VectorBundle.FiberwiseLinear","initialProofState":"ð•œ : Type u_1\nB : Type u_2\nF : Type u_3\ninstâœâ· : TopologicalSpace B\ninstâœâ¶ : NontriviallyNormedField ð•œ\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ð•œ F\nEB : Type u_4\ninstâœÂ³ : NormedAddCommGroup EB\ninstâœÂ² : NormedSpace ð•œ EB\nHB : Type u_5\ninstâœÂ¹ : TopologicalSpace HB\ninstâœ : ChartedSpace HB B\nIB : ModelWithCorners ð•œ EB HB\nn : WithTop ENat\ne : PartialHomeomorph (Prod B F) (Prod B F)\nh : âˆ€ (p : Prod B F), Membership.mem e.source p â†’ Exists fun s => And (IsOpen s) (And (Membership.mem s p) (Exists fun Ï† => Exists fun u => Exists fun hu => Exists fun hÏ† => Exists fun h2Ï† => (e.restr s).EqOnSource (FiberwiseLinear.partialHomeomorph Ï† hu â‹¯ â‹¯)))\nâŠ¢ Exists fun U => And (Eq e.source (SProd.sprod U Set.univ)) (âˆ€ (x : B), Membership.mem U x â†’ Exists fun Ï† => Exists fun u => Exists fun hu => Exists fun _huU => Exists fun _hux => Exists fun hÏ† => Exists fun h2Ï† => (e.restr (SProd.sprod u Set.univ)).EqOnSource (FiberwiseLinear.partialHomeomorph Ï† hu â‹¯ â‹¯))","decl":"@[deprecated (since := \"2025-01-09\")]\nalias SmoothFiberwiseLinear.locality_auxâ‚ := ContMDiffFiberwiseLinear.locality_auxâ‚\n\n"}
{"name":"ContMDiffFiberwiseLinear.locality_auxâ‚‚","module":"Mathlib.Geometry.Manifold.VectorBundle.FiberwiseLinear","initialProofState":"ð•œ : Type u_1\nB : Type u_2\nF : Type u_3\ninstâœâ· : TopologicalSpace B\ninstâœâ¶ : NontriviallyNormedField ð•œ\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ð•œ F\nEB : Type u_4\ninstâœÂ³ : NormedAddCommGroup EB\ninstâœÂ² : NormedSpace ð•œ EB\nHB : Type u_5\ninstâœÂ¹ : TopologicalSpace HB\ninstâœ : ChartedSpace HB B\nIB : ModelWithCorners ð•œ EB HB\nn : WithTop ENat\ne : PartialHomeomorph (Prod B F) (Prod B F)\nU : Set B\nhU : Eq e.source (SProd.sprod U Set.univ)\nh : âˆ€ (x : B), Membership.mem U x â†’ Exists fun Ï† => Exists fun u => Exists fun hu => Exists fun _hUu => Exists fun _hux => Exists fun hÏ† => Exists fun h2Ï† => (e.restr (SProd.sprod u Set.univ)).EqOnSource (FiberwiseLinear.partialHomeomorph Ï† hu â‹¯ â‹¯)\nâŠ¢ Exists fun Î¦ => Exists fun U => Exists fun hUâ‚€ => Exists fun hÎ¦ => Exists fun h2Î¦ => e.EqOnSource (FiberwiseLinear.partialHomeomorph Î¦ hUâ‚€ â‹¯ â‹¯)","decl":"/-- Let `e` be a partial homeomorphism of `B Ã— F` whose source is `U Ã—Ë¢ univ`, for some set `U` in\n`B`, and which, at any point `x` in `U`, admits a neighbourhood `u` of `x` such that `e` is equal\non `u Ã—Ë¢ univ` to some bi-`C^n` fiberwise linear partial homeomorphism.  Then `e` itself\nis equal to some bi-`C^n` fiberwise linear partial homeomorphism.\n\nThis is the key mathematical point of the `locality` condition in the construction of the\n`StructureGroupoid` of bi-`C^n` fiberwise linear partial homeomorphisms.  The proof is by gluing\ntogether the various bi-`C^n` fiberwise linear partial homeomorphism which exist locally.\n\nThe `U` in the conclusion is the same `U` as in the hypothesis. We state it like this, because this\nis exactly what we need for `contMDiffFiberwiseLinear`. -/\ntheorem ContMDiffFiberwiseLinear.locality_auxâ‚‚\n    (n : WithTop â„•âˆž) (e : PartialHomeomorph (B Ã— F) (B Ã— F)) (U : Set B) (hU : e.source = U Ã—Ë¢ univ)\n    (h : âˆ€ x âˆˆ U,\n      âˆƒ (Ï† : B â†’ F â‰ƒL[ð•œ] F) (u : Set B) (hu : IsOpen u) (_hUu : u âŠ† U) (_hux : x âˆˆ u)\n        (hÏ† : ContMDiffOn IB ð“˜(ð•œ, F â†’L[ð•œ] F) n (fun x => (Ï† x : F â†’L[ð•œ] F)) u)\n        (h2Ï† : ContMDiffOn IB ð“˜(ð•œ, F â†’L[ð•œ] F) n (fun x => ((Ï† x).symm : F â†’L[ð•œ] F)) u),\n          (e.restr (u Ã—Ë¢ univ)).EqOnSource\n            (FiberwiseLinear.partialHomeomorph Ï† hu hÏ†.continuousOn h2Ï†.continuousOn)) :\n    âˆƒ (Î¦ : B â†’ F â‰ƒL[ð•œ] F) (U : Set B) (hUâ‚€ : IsOpen U) (hÎ¦ :\n      ContMDiffOn IB ð“˜(ð•œ, F â†’L[ð•œ] F) n (fun x => (Î¦ x : F â†’L[ð•œ] F)) U) (h2Î¦ :\n      ContMDiffOn IB ð“˜(ð•œ, F â†’L[ð•œ] F) n (fun x => ((Î¦ x).symm : F â†’L[ð•œ] F)) U),\n      e.EqOnSource (FiberwiseLinear.partialHomeomorph Î¦ hUâ‚€ hÎ¦.continuousOn h2Î¦.continuousOn) := by\n  classical\n  rw [SetCoe.forall'] at h\n  choose! Ï† u hu hUu hux hÏ† h2Ï† heÏ† using h\n  have heuÏ† : âˆ€ x : U, EqOn e (fun q => (q.1, Ï† x q.1 q.2)) (u x Ã—Ë¢ univ) := fun x p hp â†¦ by\n    refine (heÏ† x).2 ?_\n    rw [(heÏ† x).1]\n    exact hp\n  have huÏ† : âˆ€ (x x' : U) (y : B), y âˆˆ u x â†’ y âˆˆ u x' â†’ Ï† x y = Ï† x' y := fun p p' y hyp hyp' â†¦ by\n    ext v\n    have h1 : e (y, v) = (y, Ï† p y v) := heuÏ† _ âŸ¨(id hyp : (y, v).fst âˆˆ u p), trivialâŸ©\n    have h2 : e (y, v) = (y, Ï† p' y v) := heuÏ† _ âŸ¨(id hyp' : (y, v).fst âˆˆ u p'), trivialâŸ©\n    exact congr_arg Prod.snd (h1.symm.trans h2)\n  have hUu' : U = â‹ƒ i, u i := by\n    ext x\n    rw [mem_iUnion]\n    refine âŸ¨fun h => âŸ¨âŸ¨x, hâŸ©, hux _âŸ©, ?_âŸ©\n    rintro âŸ¨x, hxâŸ©\n    exact hUu x hx\n  have hU' : IsOpen U := by\n    rw [hUu']\n    apply isOpen_iUnion hu\n  let Î¦â‚€ : U â†’ F â‰ƒL[ð•œ] F := iUnionLift u (fun x => Ï† x âˆ˜ (â†‘)) huÏ† U hUu'.le\n  let Î¦ : B â†’ F â‰ƒL[ð•œ] F := fun y =>\n    if hy : y âˆˆ U then Î¦â‚€ âŸ¨y, hyâŸ© else ContinuousLinearEquiv.refl ð•œ F\n  have hÎ¦ : âˆ€ (y) (hy : y âˆˆ U), Î¦ y = Î¦â‚€ âŸ¨y, hyâŸ© := fun y hy => dif_pos hy\n  have hÎ¦Ï† : âˆ€ x : U, âˆ€ y âˆˆ u x, Î¦ y = Ï† x y := by\n    intro x y hyu\n    refine (hÎ¦ y (hUu x hyu)).trans ?_\n    exact iUnionLift_mk âŸ¨y, hyuâŸ© _\n  have hÎ¦ : ContMDiffOn IB ð“˜(ð•œ, F â†’L[ð•œ] F) n (fun y => (Î¦ y : F â†’L[ð•œ] F)) U := by\n    apply contMDiffOn_of_locally_contMDiffOn\n    intro x hx\n    refine âŸ¨u âŸ¨x, hxâŸ©, hu âŸ¨x, hxâŸ©, hux _, ?_âŸ©\n    refine (ContMDiffOn.congr (hÏ† âŸ¨x, hxâŸ©) ?_).mono inter_subset_right\n    intro y hy\n    rw [hÎ¦Ï† âŸ¨x, hxâŸ© y hy]\n  have h2Î¦ : ContMDiffOn IB ð“˜(ð•œ, F â†’L[ð•œ] F) n (fun y => ((Î¦ y).symm : F â†’L[ð•œ] F)) U := by\n    apply contMDiffOn_of_locally_contMDiffOn\n    intro x hx\n    refine âŸ¨u âŸ¨x, hxâŸ©, hu âŸ¨x, hxâŸ©, hux _, ?_âŸ©\n    refine (ContMDiffOn.congr (h2Ï† âŸ¨x, hxâŸ©) ?_).mono inter_subset_right\n    intro y hy\n    rw [hÎ¦Ï† âŸ¨x, hxâŸ© y hy]\n  refine âŸ¨Î¦, U, hU', hÎ¦, h2Î¦, hU, fun p hp => ?_âŸ©\n  rw [hU] at hp\n  rw [heuÏ† âŸ¨p.fst, hp.1âŸ© âŸ¨hux _, hp.2âŸ©]\n  congrm (_, ?_)\n  rw [hÎ¦Ï†]\n  apply hux\n\n"}
{"name":"SmoothFiberwiseLinear.locality_auxâ‚‚","module":"Mathlib.Geometry.Manifold.VectorBundle.FiberwiseLinear","initialProofState":"ð•œ : Type u_1\nB : Type u_2\nF : Type u_3\ninstâœâ· : TopologicalSpace B\ninstâœâ¶ : NontriviallyNormedField ð•œ\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ð•œ F\nEB : Type u_4\ninstâœÂ³ : NormedAddCommGroup EB\ninstâœÂ² : NormedSpace ð•œ EB\nHB : Type u_5\ninstâœÂ¹ : TopologicalSpace HB\ninstâœ : ChartedSpace HB B\nIB : ModelWithCorners ð•œ EB HB\nn : WithTop ENat\ne : PartialHomeomorph (Prod B F) (Prod B F)\nU : Set B\nhU : Eq e.source (SProd.sprod U Set.univ)\nh : âˆ€ (x : B), Membership.mem U x â†’ Exists fun Ï† => Exists fun u => Exists fun hu => Exists fun _hUu => Exists fun _hux => Exists fun hÏ† => Exists fun h2Ï† => (e.restr (SProd.sprod u Set.univ)).EqOnSource (FiberwiseLinear.partialHomeomorph Ï† hu â‹¯ â‹¯)\nâŠ¢ Exists fun Î¦ => Exists fun U => Exists fun hUâ‚€ => Exists fun hÎ¦ => Exists fun h2Î¦ => e.EqOnSource (FiberwiseLinear.partialHomeomorph Î¦ hUâ‚€ â‹¯ â‹¯)","decl":"@[deprecated (since := \"2025-01-09\")]\nalias SmoothFiberwiseLinear.locality_auxâ‚‚ := ContMDiffFiberwiseLinear.locality_auxâ‚‚\n\n-- Having this private lemma speeds up `simp` calls below a lot.\n-- TODO: understand why and fix the underlying issue (relatedly, the `simp` calls\n-- in `contMDiffFiberwiseLinear` are quite slow, even with this change)\n"}
{"name":"mem_contMDiffFiberwiseLinear_iff","module":"Mathlib.Geometry.Manifold.VectorBundle.FiberwiseLinear","initialProofState":"ð•œ : Type u_1\nB : Type u_2\nF : Type u_3\ninstâœâ· : TopologicalSpace B\ninstâœâ¶ : NontriviallyNormedField ð•œ\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ð•œ F\nEB : Type u_4\ninstâœÂ³ : NormedAddCommGroup EB\ninstâœÂ² : NormedSpace ð•œ EB\nHB : Type u_5\ninstâœÂ¹ : TopologicalSpace HB\ninstâœ : ChartedSpace HB B\nIB : ModelWithCorners ð•œ EB HB\nn : WithTop ENat\ne : PartialHomeomorph (Prod B F) (Prod B F)\nâŠ¢ Iff (Membership.mem (contMDiffFiberwiseLinear B F IB n) e) (Exists fun Ï† => Exists fun U => Exists fun hU => Exists fun hÏ† => Exists fun h2Ï† => e.EqOnSource (FiberwiseLinear.partialHomeomorph Ï† hU â‹¯ â‹¯))","decl":"@[simp]\ntheorem mem_contMDiffFiberwiseLinear_iff {n : WithTop â„•âˆž} (e : PartialHomeomorph (B Ã— F) (B Ã— F)) :\n    e âˆˆ contMDiffFiberwiseLinear B F IB n â†”\n      âˆƒ (Ï† : B â†’ F â‰ƒL[ð•œ] F) (U : Set B) (hU : IsOpen U) (hÏ† :\n        ContMDiffOn IB ð“˜(ð•œ, F â†’L[ð•œ] F) n (fun x => Ï† x : B â†’ F â†’L[ð•œ] F) U) (h2Ï† :\n        ContMDiffOn IB ð“˜(ð•œ, F â†’L[ð•œ] F) n (fun x => (Ï† x).symm : B â†’ F â†’L[ð•œ] F) U),\n        e.EqOnSource (FiberwiseLinear.partialHomeomorph Ï† hU hÏ†.continuousOn h2Ï†.continuousOn) :=\n  mem_aux\n\n"}
{"name":"mem_smoothFiberwiseLinear_iff","module":"Mathlib.Geometry.Manifold.VectorBundle.FiberwiseLinear","initialProofState":"ð•œ : Type u_1\nB : Type u_2\nF : Type u_3\ninstâœâ· : TopologicalSpace B\ninstâœâ¶ : NontriviallyNormedField ð•œ\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ð•œ F\nEB : Type u_4\ninstâœÂ³ : NormedAddCommGroup EB\ninstâœÂ² : NormedSpace ð•œ EB\nHB : Type u_5\ninstâœÂ¹ : TopologicalSpace HB\ninstâœ : ChartedSpace HB B\nIB : ModelWithCorners ð•œ EB HB\nn : WithTop ENat\ne : PartialHomeomorph (Prod B F) (Prod B F)\nâŠ¢ Iff (Membership.mem (contMDiffFiberwiseLinear B F IB n) e) (Exists fun Ï† => Exists fun U => Exists fun hU => Exists fun hÏ† => Exists fun h2Ï† => e.EqOnSource (FiberwiseLinear.partialHomeomorph Ï† hU â‹¯ â‹¯))","decl":"@[deprecated (since := \"2025-01-09\")]\nalias mem_smoothFiberwiseLinear_iff := mem_contMDiffFiberwiseLinear_iff\n"}
