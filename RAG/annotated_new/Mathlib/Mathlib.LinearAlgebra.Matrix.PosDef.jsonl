{"name":"Matrix.PosSemidef.diagonal","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœâµ : Fintype n\ninstâœâ´ : CommRing R\ninstâœÂ³ : PartialOrder R\ninstâœÂ² : StarRing R\ninstâœÂ¹ : StarOrderedRing R\ninstâœ : DecidableEq n\nd : n â†’ R\nh : LE.le 0 d\nâŠ¢ (Matrix.diagonal d).PosSemidef","decl":"protected theorem PosSemidef.diagonal [StarOrderedRing R] [DecidableEq n] {d : n â†’ R} (h : 0 â‰¤ d) :\n    PosSemidef (diagonal d) :=\n  âŸ¨isHermitian_diagonal_of_self_adjoint _ <| funext fun i => IsSelfAdjoint.of_nonneg (h i),\n    fun x => by\n      refine Fintype.sum_nonneg fun i => ?_\n      simpa only [mulVec_diagonal, â† mul_assoc] using conjugate_nonneg (h i) _âŸ©\n\n"}
{"name":"Matrix.posSemidef_diagonal_iff","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœâµ : Fintype n\ninstâœâ´ : CommRing R\ninstâœÂ³ : PartialOrder R\ninstâœÂ² : StarRing R\ninstâœÂ¹ : StarOrderedRing R\ninstâœ : DecidableEq n\nd : n â†’ R\nâŠ¢ Iff (Matrix.diagonal d).PosSemidef (âˆ€ (i : n), LE.le 0 (d i))","decl":"/-- A diagonal matrix is positive semidefinite iff its diagonal entries are nonnegative. -/\nlemma posSemidef_diagonal_iff [StarOrderedRing R] [DecidableEq n] {d : n â†’ R} :\n    PosSemidef (diagonal d) â†” (âˆ€ i : n, 0 â‰¤ d i) :=\n  âŸ¨fun âŸ¨_, hPâŸ© i â†¦ by simpa using hP (Pi.single i 1), .diagonalâŸ©\n\n"}
{"name":"Matrix.PosSemidef.isHermitian","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœÂ³ : Fintype n\ninstâœÂ² : CommRing R\ninstâœÂ¹ : PartialOrder R\ninstâœ : StarRing R\nM : Matrix n n R\nhM : M.PosSemidef\nâŠ¢ M.IsHermitian","decl":"theorem isHermitian {M : Matrix n n R} (hM : M.PosSemidef) : M.IsHermitian :=\n  hM.1\n\n"}
{"name":"Matrix.PosSemidef.re_dotProduct_nonneg","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nğ•œ : Type u_4\ninstâœÂ¹ : Fintype n\ninstâœ : RCLike ğ•œ\nM : Matrix n n ğ•œ\nhM : M.PosSemidef\nx : n â†’ ğ•œ\nâŠ¢ LE.le 0 (RCLike.re (dotProduct (Star.star x) (M.mulVec x)))","decl":"theorem re_dotProduct_nonneg {M : Matrix n n ğ•œ} (hM : M.PosSemidef) (x : n â†’ ğ•œ) :\n    0 â‰¤ RCLike.re (dotProduct (star x) (M *áµ¥ x)) :=\n  RCLike.nonneg_iff.mp (hM.2 _) |>.1\n\n"}
{"name":"Matrix.PosSemidef.conjTranspose_mul_mul_same","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœâ´ : Fintype n\ninstâœÂ³ : CommRing R\ninstâœÂ² : PartialOrder R\ninstâœÂ¹ : StarRing R\nA : Matrix n n R\nhA : A.PosSemidef\nm : Type u_5\ninstâœ : Fintype m\nB : Matrix n m R\nâŠ¢ (HMul.hMul (HMul.hMul B.conjTranspose A) B).PosSemidef","decl":"lemma conjTranspose_mul_mul_same {A : Matrix n n R} (hA : PosSemidef A)\n    {m : Type*} [Fintype m] (B : Matrix n m R) :\n    PosSemidef (Bá´´ * A * B) := by\n  constructor\n  Â· exact isHermitian_conjTranspose_mul_mul B hA.1\n  Â· intro x\n    simpa only [star_mulVec, dotProduct_mulVec, vecMul_vecMul] using hA.2 (B *áµ¥ x)\n\n"}
{"name":"Matrix.PosSemidef.mul_mul_conjTranspose_same","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœâ´ : Fintype n\ninstâœÂ³ : CommRing R\ninstâœÂ² : PartialOrder R\ninstâœÂ¹ : StarRing R\nA : Matrix n n R\nhA : A.PosSemidef\nm : Type u_5\ninstâœ : Fintype m\nB : Matrix m n R\nâŠ¢ (HMul.hMul (HMul.hMul B A) B.conjTranspose).PosSemidef","decl":"lemma mul_mul_conjTranspose_same {A : Matrix n n R} (hA : PosSemidef A)\n    {m : Type*} [Fintype m] (B : Matrix m n R) :\n    PosSemidef (B * A * Bá´´) := by\n  simpa only [conjTranspose_conjTranspose] using hA.conjTranspose_mul_mul_same Bá´´\n\n"}
{"name":"Matrix.PosSemidef.submatrix","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"m : Type u_1\nn : Type u_2\nR : Type u_3\ninstâœâ´ : Fintype m\ninstâœÂ³ : Fintype n\ninstâœÂ² : CommRing R\ninstâœÂ¹ : PartialOrder R\ninstâœ : StarRing R\nM : Matrix n n R\nhM : M.PosSemidef\ne : m â†’ n\nâŠ¢ (M.submatrix e e).PosSemidef","decl":"theorem submatrix {M : Matrix n n R} (hM : M.PosSemidef) (e : m â†’ n) :\n    (M.submatrix e e).PosSemidef := by\n  classical\n  rw [(by simp : M = 1 * M * 1), submatrix_mul (heâ‚‚ := Function.bijective_id),\n    submatrix_mul (heâ‚‚ := Function.bijective_id), submatrix_id_id]\n  simpa only [conjTranspose_submatrix, conjTranspose_one] using\n    conjTranspose_mul_mul_same hM (Matrix.submatrix 1 id e)\n\n"}
{"name":"Matrix.PosSemidef.transpose","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœÂ³ : Fintype n\ninstâœÂ² : CommRing R\ninstâœÂ¹ : PartialOrder R\ninstâœ : StarRing R\nM : Matrix n n R\nhM : M.PosSemidef\nâŠ¢ M.transpose.PosSemidef","decl":"theorem transpose {M : Matrix n n R} (hM : M.PosSemidef) : Máµ€.PosSemidef := by\n  refine âŸ¨IsHermitian.transpose hM.1, fun x => ?_âŸ©\n  convert hM.2 (star x) using 1\n  rw [mulVec_transpose, dotProduct_mulVec, star_star, dotProduct_comm]\n\n"}
{"name":"Matrix.PosSemidef.conjTranspose","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœÂ³ : Fintype n\ninstâœÂ² : CommRing R\ninstâœÂ¹ : PartialOrder R\ninstâœ : StarRing R\nM : Matrix n n R\nhM : M.PosSemidef\nâŠ¢ M.conjTranspose.PosSemidef","decl":"theorem conjTranspose {M : Matrix n n R} (hM : M.PosSemidef) : Má´´.PosSemidef := hM.1.symm â–¸ hM\n\n"}
{"name":"Matrix.PosSemidef.zero","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœÂ³ : Fintype n\ninstâœÂ² : CommRing R\ninstâœÂ¹ : PartialOrder R\ninstâœ : StarRing R\nâŠ¢ Matrix.PosSemidef 0","decl":"protected lemma zero : PosSemidef (0 : Matrix n n R) :=\n  âŸ¨isHermitian_zero, by simpâŸ©\n\n"}
{"name":"Matrix.PosSemidef.one","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœâµ : Fintype n\ninstâœâ´ : CommRing R\ninstâœÂ³ : PartialOrder R\ninstâœÂ² : StarRing R\ninstâœÂ¹ : StarOrderedRing R\ninstâœ : DecidableEq n\nâŠ¢ Matrix.PosSemidef 1","decl":"protected lemma one [StarOrderedRing R] [DecidableEq n] : PosSemidef (1 : Matrix n n R) :=\n  âŸ¨isHermitian_one, fun x => by\n    rw [one_mulVec]; exact Fintype.sum_nonneg fun i => star_mul_self_nonneg _âŸ©\n\n"}
{"name":"Matrix.PosSemidef.natCast","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœâµ : Fintype n\ninstâœâ´ : CommRing R\ninstâœÂ³ : PartialOrder R\ninstâœÂ² : StarRing R\ninstâœÂ¹ : StarOrderedRing R\ninstâœ : DecidableEq n\nd : Nat\nâŠ¢ (â†‘d).PosSemidef","decl":"protected theorem natCast [StarOrderedRing R] [DecidableEq n] (d : â„•) :\n    PosSemidef (d : Matrix n n R) :=\n  âŸ¨isHermitian_natCast _, fun x => by\n    simp only [natCast_mulVec, dotProduct_smul]\n    rw [Nat.cast_smul_eq_nsmul]\n    exact nsmul_nonneg (dotProduct_star_self_nonneg _) _âŸ©\n\n"}
{"name":"Matrix.PosSemidef.ofNat","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœâ¶ : Fintype n\ninstâœâµ : CommRing R\ninstâœâ´ : PartialOrder R\ninstâœÂ³ : StarRing R\ninstâœÂ² : StarOrderedRing R\ninstâœÂ¹ : DecidableEq n\nd : Nat\ninstâœ : d.AtLeastTwo\nâŠ¢ (OfNat.ofNat d).PosSemidef","decl":"protected theorem ofNat [StarOrderedRing R] [DecidableEq n] (d : â„•) [d.AtLeastTwo] :\n    PosSemidef (ofNat(d) : Matrix n n R) :=\n  .natCast d\n\n"}
{"name":"Matrix.PosSemidef.intCast","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœâµ : Fintype n\ninstâœâ´ : CommRing R\ninstâœÂ³ : PartialOrder R\ninstâœÂ² : StarRing R\ninstâœÂ¹ : StarOrderedRing R\ninstâœ : DecidableEq n\nd : Int\nhd : LE.le 0 d\nâŠ¢ (â†‘d).PosSemidef","decl":"protected theorem intCast [StarOrderedRing R] [DecidableEq n] (d : â„¤) (hd : 0 â‰¤ d) :\n    PosSemidef (d : Matrix n n R) :=\n  âŸ¨isHermitian_intCast _, fun x => by\n    simp only [intCast_mulVec, dotProduct_smul]\n    rw [Int.cast_smul_eq_zsmul]\n    exact zsmul_nonneg (dotProduct_star_self_nonneg _) hdâŸ©\n\n"}
{"name":"Matrix.posSemidef_intCast_iff","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœâ· : Fintype n\ninstâœâ¶ : CommRing R\ninstâœâµ : PartialOrder R\ninstâœâ´ : StarRing R\ninstâœÂ³ : StarOrderedRing R\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : Nonempty n\ninstâœ : Nontrivial R\nd : Int\nâŠ¢ Iff (â†‘d).PosSemidef (LE.le 0 d)","decl":"@[simp]\nprotected theorem _root_.Matrix.posSemidef_intCast_iff\n    [StarOrderedRing R] [DecidableEq n] [Nonempty n] [Nontrivial R] (d : â„¤) :\n    PosSemidef (d : Matrix n n R) â†” 0 â‰¤ d :=\n  posSemidef_diagonal_iff.trans <| by simp [Pi.le_def]\n\n"}
{"name":"Matrix.PosSemidef.pow","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœâµ : Fintype n\ninstâœâ´ : CommRing R\ninstâœÂ³ : PartialOrder R\ninstâœÂ² : StarRing R\ninstâœÂ¹ : StarOrderedRing R\ninstâœ : DecidableEq n\nM : Matrix n n R\nhM : M.PosSemidef\nk : Nat\nâŠ¢ (HPow.hPow M k).PosSemidef","decl":"protected lemma pow [StarOrderedRing R] [DecidableEq n]\n    {M : Matrix n n R} (hM : M.PosSemidef) (k : â„•) :\n    PosSemidef (M ^ k) :=\n  match k with\n  | 0 => .one\n  | 1 => by simpa using hM\n  | (k + 2) => by\n    rw [pow_succ, pow_succ']\n    simpa only [hM.isHermitian.eq] using (hM.pow k).mul_mul_conjTranspose_same M\n\n"}
{"name":"Matrix.PosSemidef.inv","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœâ´ : Fintype n\ninstâœÂ³ : CommRing R\ninstâœÂ² : PartialOrder R\ninstâœÂ¹ : StarRing R\ninstâœ : DecidableEq n\nM : Matrix n n R\nhM : M.PosSemidef\nâŠ¢ (Inv.inv M).PosSemidef","decl":"protected lemma inv [DecidableEq n] {M : Matrix n n R} (hM : M.PosSemidef) : Mâ»Â¹.PosSemidef := by\n  by_cases h : IsUnit M.det\n  Â· have := (conjTranspose_mul_mul_same hM Mâ»Â¹).conjTranspose\n    rwa [mul_nonsing_inv_cancel_right _ _ h, conjTranspose_conjTranspose] at this\n  Â· rw [nonsing_inv_apply_not_isUnit _ h]\n    exact .zero\n\n"}
{"name":"Matrix.PosSemidef.zpow","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœâµ : Fintype n\ninstâœâ´ : CommRing R\ninstâœÂ³ : PartialOrder R\ninstâœÂ² : StarRing R\ninstâœÂ¹ : StarOrderedRing R\ninstâœ : DecidableEq n\nM : Matrix n n R\nhM : M.PosSemidef\nz : Int\nâŠ¢ (HPow.hPow M z).PosSemidef","decl":"protected lemma zpow [StarOrderedRing R] [DecidableEq n]\n    {M : Matrix n n R} (hM : M.PosSemidef) (z : â„¤) :\n    (M ^ z).PosSemidef := by\n  obtain âŸ¨n, rfl | rflâŸ© := z.eq_nat_or_neg\n  Â· simpa using hM.pow n\n  Â· simpa using (hM.pow n).inv\n\n"}
{"name":"Matrix.PosSemidef.add","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"m : Type u_1\nR : Type u_3\ninstâœâ´ : Fintype m\ninstâœÂ³ : CommRing R\ninstâœÂ² : PartialOrder R\ninstâœÂ¹ : StarRing R\ninstâœ : AddLeftMono R\nA B : Matrix m m R\nhA : A.PosSemidef\nhB : B.PosSemidef\nâŠ¢ (HAdd.hAdd A B).PosSemidef","decl":"protected lemma add [AddLeftMono R] {A : Matrix m m R} {B : Matrix m m R}\n    (hA : A.PosSemidef) (hB : B.PosSemidef) : (A + B).PosSemidef :=\n  âŸ¨hA.isHermitian.add hB.isHermitian, fun x => by\n    rw [add_mulVec, dotProduct_add]\n    exact add_nonneg (hA.2 x) (hB.2 x)âŸ©\n\n"}
{"name":"Matrix.PosSemidef.eigenvalues_nonneg","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nğ•œ : Type u_4\ninstâœÂ² : Fintype n\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nhA : A.PosSemidef\ni : n\nâŠ¢ LE.le 0 (â‹¯.eigenvalues i)","decl":"/-- The eigenvalues of a positive semi-definite matrix are non-negative -/\nlemma eigenvalues_nonneg [DecidableEq n] {A : Matrix n n ğ•œ}\n    (hA : Matrix.PosSemidef A) (i : n) : 0 â‰¤ hA.1.eigenvalues i :=\n  (hA.re_dotProduct_nonneg _).trans_eq (hA.1.eigenvalues_eq _).symm\n\n"}
{"name":"Matrix.PosSemidef.posSemidef_sqrt","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nğ•œ : Type u_4\ninstâœÂ² : Fintype n\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nhA : A.PosSemidef\nâŠ¢ hA.sqrt.PosSemidef","decl":"lemma posSemidef_sqrt : PosSemidef hA.sqrt := by\n  apply PosSemidef.mul_mul_conjTranspose_same\n  refine posSemidef_diagonal_iff.mpr fun i â†¦ ?_\n  rw [Function.comp_apply, RCLike.nonneg_iff]\n  constructor\n  Â· simp only [RCLike.ofReal_re]\n    exact Real.sqrt_nonneg _\n  Â· simp only [RCLike.ofReal_im]\n\n"}
{"name":"Matrix.PosSemidef.sq_sqrt","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nğ•œ : Type u_4\ninstâœÂ² : Fintype n\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nhA : A.PosSemidef\nâŠ¢ Eq (HPow.hPow hA.sqrt 2) A","decl":"@[simp]\nlemma sq_sqrt : hA.sqrt ^ 2 = A := by\n  let C : Matrix n n ğ•œ := hA.1.eigenvectorUnitary\n  let E := diagonal ((â†‘) âˆ˜ Real.sqrt âˆ˜ hA.1.eigenvalues : n â†’ ğ•œ)\n  suffices C * (E * (star C * C) * E) * star C = A by\n    rw [Matrix.PosSemidef.sqrt, pow_two]\n    simpa only [â† mul_assoc] using this\n  have : E * E = diagonal ((â†‘) âˆ˜ hA.1.eigenvalues) := by\n    rw [diagonal_mul_diagonal]\n    congr! with v\n    simp [â† pow_two, â† RCLike.ofReal_pow, Real.sq_sqrt (hA.eigenvalues_nonneg v)]\n  simpa [C, this] using hA.1.spectral_theorem.symm\n\n"}
{"name":"Matrix.PosSemidef.sqrt_mul_self","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nğ•œ : Type u_4\ninstâœÂ² : Fintype n\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nhA : A.PosSemidef\nâŠ¢ Eq (HMul.hMul hA.sqrt hA.sqrt) A","decl":"@[simp]\nlemma sqrt_mul_self : hA.sqrt * hA.sqrt = A := by rw [â† pow_two, sq_sqrt]\n\n"}
{"name":"Matrix.PosSemidef.eq_of_sq_eq_sq","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nğ•œ : Type u_4\ninstâœÂ² : Fintype n\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nhA : A.PosSemidef\nB : Matrix n n ğ•œ\nhB : B.PosSemidef\nhAB : Eq (HPow.hPow A 2) (HPow.hPow B 2)\nâŠ¢ Eq A B","decl":"include hA in\nlemma eq_of_sq_eq_sq {B : Matrix n n ğ•œ} (hB : PosSemidef B) (hAB : A ^ 2 = B ^ 2) : A = B := by\n  /- This is deceptively hard, much more difficult than the positive *definite* case. We follow a\n  clever proof due to Koeber and SchÃ¤fer. The idea is that if `A â‰  B`, then `A - B` has a nonzero\n  real eigenvalue, with eigenvector `v`. Then a manipulation using the identity\n  `A ^ 2 - B ^ 2 = A * (A - B) + (A - B) * B` leads to the conclusion that\n  `âŸ¨v, A vâŸ© + âŸ¨v, B vâŸ© = 0`. Since `A, B` are positive semidefinite, both terms must be zero. Thus\n  `âŸ¨v, (A - B) vâŸ© = 0`, but this is a nonzero scalar multiple of `âŸ¨v, vâŸ©`, contradiction. -/\n  by_contra h_ne\n  let âŸ¨v, t, ht, hv, hv'âŸ© := (hA.1.sub hB.1).exists_eigenvector_of_ne_zero (sub_ne_zero.mpr h_ne)\n  have h_sum : 0 = t * (star v â¬áµ¥ A *áµ¥ v + star v â¬áµ¥ B *áµ¥ v) := calc\n    0 = star v â¬áµ¥ (A ^ 2 - B ^ 2) *áµ¥ v := by rw [hAB, sub_self, zero_mulVec, dotProduct_zero]\n    _ = star v â¬áµ¥ A *áµ¥ (A - B) *áµ¥ v + star v â¬áµ¥ (A - B) *áµ¥ B *áµ¥ v := by\n      rw [mulVec_mulVec, mulVec_mulVec, â† dotProduct_add, â† add_mulVec, mul_sub, sub_mul,\n        add_sub, sub_add_cancel, pow_two, pow_two]\n    _ = t * (star v â¬áµ¥ A *áµ¥ v) + (star v) áµ¥* (A - B)á´´ â¬áµ¥ B *áµ¥ v := by\n      rw [hv', mulVec_smul, dotProduct_smul, RCLike.real_smul_eq_coe_mul,\n        dotProduct_mulVec _ (A - B), hA.1.sub hB.1]\n    _ = t * (star v â¬áµ¥ A *áµ¥ v + star v â¬áµ¥ B *áµ¥ v) := by\n      simp_rw [â† star_mulVec, hv', mul_add, â† RCLike.real_smul_eq_coe_mul, â† smul_dotProduct]\n      congr 2 with i\n      simp only [Pi.star_apply, Pi.smul_apply, RCLike.real_smul_eq_coe_mul, star_mul',\n        RCLike.star_def, RCLike.conj_ofReal]\n  replace h_sum : star v â¬áµ¥ A *áµ¥ v + star v â¬áµ¥ B *áµ¥ v = 0 := by\n    rw [eq_comm, â† mul_zero (t : ğ•œ)] at h_sum\n    exact mul_left_cancelâ‚€ (RCLike.ofReal_ne_zero.mpr ht) h_sum\n  have h_van : star v â¬áµ¥ A *áµ¥ v = 0 âˆ§ star v â¬áµ¥ B *áµ¥ v = 0 := by\n    refine âŸ¨le_antisymm ?_ (hA.2 v), le_antisymm ?_ (hB.2 v)âŸ©\n    Â· rw [add_comm, add_eq_zero_iff_eq_neg] at h_sum\n      simpa only [h_sum, neg_nonneg] using hB.2 v\n    Â· simpa only [add_eq_zero_iff_eq_neg.mp h_sum, neg_nonneg] using hA.2 v\n  have aux : star v â¬áµ¥ (A - B) *áµ¥ v = 0 := by\n    rw [sub_mulVec, dotProduct_sub, h_van.1, h_van.2, sub_zero]\n  rw [hv', dotProduct_smul, RCLike.real_smul_eq_coe_mul, â† mul_zero â†‘t] at aux\n  exact hv <| dotProduct_star_self_eq_zero.mp <| mul_left_cancelâ‚€\n    (RCLike.ofReal_ne_zero.mpr ht) aux\n\n"}
{"name":"Matrix.PosSemidef.sqrt_sq","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nğ•œ : Type u_4\ninstâœÂ² : Fintype n\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nhA : A.PosSemidef\nâŠ¢ Eq â‹¯.sqrt A","decl":"lemma sqrt_sq : (hA.pow 2 : PosSemidef (A ^ 2)).sqrt = A :=\n  (hA.pow 2).posSemidef_sqrt.eq_of_sq_eq_sq hA (hA.pow 2).sq_sqrt\n\n"}
{"name":"Matrix.PosSemidef.eq_sqrt_of_sq_eq","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nğ•œ : Type u_4\ninstâœÂ² : Fintype n\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nhA : A.PosSemidef\nB : Matrix n n ğ•œ\nhB : B.PosSemidef\nhAB : Eq (HPow.hPow A 2) B\nâŠ¢ Eq A hB.sqrt","decl":"include hA in\nlemma eq_sqrt_of_sq_eq {B : Matrix n n ğ•œ} (hB : PosSemidef B) (hAB : A ^ 2 = B) : A = hB.sqrt := by\n  subst B\n  rw [hA.sqrt_sq]\n\n"}
{"name":"Matrix.posSemidef_submatrix_equiv","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"m : Type u_1\nn : Type u_2\nR : Type u_3\ninstâœâ´ : Fintype m\ninstâœÂ³ : Fintype n\ninstâœÂ² : CommRing R\ninstâœÂ¹ : PartialOrder R\ninstâœ : StarRing R\nM : Matrix n n R\ne : Equiv m n\nâŠ¢ Iff (M.submatrix â‡‘e â‡‘e).PosSemidef M.PosSemidef","decl":"@[simp]\ntheorem posSemidef_submatrix_equiv {M : Matrix n n R} (e : m â‰ƒ n) :\n    (M.submatrix e e).PosSemidef â†” M.PosSemidef :=\n  âŸ¨fun h => by simpa using h.submatrix e.symm, fun h => h.submatrix _âŸ©\n\n"}
{"name":"Matrix.posSemidef_conjTranspose_mul_self","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"m : Type u_1\nn : Type u_2\nR : Type u_3\ninstâœâµ : Fintype m\ninstâœâ´ : Fintype n\ninstâœÂ³ : CommRing R\ninstâœÂ² : PartialOrder R\ninstâœÂ¹ : StarRing R\ninstâœ : StarOrderedRing R\nA : Matrix m n R\nâŠ¢ (HMul.hMul A.conjTranspose A).PosSemidef","decl":"/-- The conjugate transpose of a matrix multiplied by the matrix is positive semidefinite -/\ntheorem posSemidef_conjTranspose_mul_self [StarOrderedRing R] (A : Matrix m n R) :\n    PosSemidef (Aá´´ * A) := by\n  refine âŸ¨isHermitian_transpose_mul_self _, fun x => ?_âŸ©\n  rw [â† mulVec_mulVec, dotProduct_mulVec, vecMul_conjTranspose, star_star]\n  exact Finset.sum_nonneg fun i _ => star_mul_self_nonneg _\n\n"}
{"name":"Matrix.posSemidef_self_mul_conjTranspose","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"m : Type u_1\nn : Type u_2\nR : Type u_3\ninstâœâµ : Fintype m\ninstâœâ´ : Fintype n\ninstâœÂ³ : CommRing R\ninstâœÂ² : PartialOrder R\ninstâœÂ¹ : StarRing R\ninstâœ : StarOrderedRing R\nA : Matrix m n R\nâŠ¢ (HMul.hMul A A.conjTranspose).PosSemidef","decl":"/-- A matrix multiplied by its conjugate transpose is positive semidefinite -/\ntheorem posSemidef_self_mul_conjTranspose [StarOrderedRing R] (A : Matrix m n R) :\n    PosSemidef (A * Aá´´) := by\n  simpa only [conjTranspose_conjTranspose] using posSemidef_conjTranspose_mul_self Aá´´\n\n"}
{"name":"Matrix.eigenvalues_conjTranspose_mul_self_nonneg","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"m : Type u_1\nn : Type u_2\nğ•œ : Type u_4\ninstâœÂ³ : Fintype m\ninstâœÂ² : Fintype n\ninstâœÂ¹ : RCLike ğ•œ\nA : Matrix m n ğ•œ\ninstâœ : DecidableEq n\ni : n\nâŠ¢ LE.le 0 (â‹¯.eigenvalues i)","decl":"lemma eigenvalues_conjTranspose_mul_self_nonneg (A : Matrix m n ğ•œ) [DecidableEq n] (i : n) :\n    0 â‰¤ (isHermitian_transpose_mul_self A).eigenvalues i :=\n  (posSemidef_conjTranspose_mul_self _).eigenvalues_nonneg _\n\n"}
{"name":"Matrix.eigenvalues_self_mul_conjTranspose_nonneg","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"m : Type u_1\nn : Type u_2\nğ•œ : Type u_4\ninstâœÂ³ : Fintype m\ninstâœÂ² : Fintype n\ninstâœÂ¹ : RCLike ğ•œ\nA : Matrix m n ğ•œ\ninstâœ : DecidableEq m\ni : m\nâŠ¢ LE.le 0 (â‹¯.eigenvalues i)","decl":"lemma eigenvalues_self_mul_conjTranspose_nonneg (A : Matrix m n ğ•œ) [DecidableEq m] (i : m) :\n    0 â‰¤ (isHermitian_mul_conjTranspose_self A).eigenvalues i :=\n  (posSemidef_self_mul_conjTranspose _).eigenvalues_nonneg _\n\n"}
{"name":"Matrix.posSemidef_iff_eq_transpose_mul_self","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nğ•œ : Type u_4\ninstâœÂ¹ : Fintype n\ninstâœ : RCLike ğ•œ\nA : Matrix n n ğ•œ\nâŠ¢ Iff A.PosSemidef (Exists fun B => Eq A (HMul.hMul B.conjTranspose B))","decl":"/-- A matrix is positive semidefinite if and only if it has the form `Bá´´ * B` for some `B`. -/\nlemma posSemidef_iff_eq_transpose_mul_self {A : Matrix n n ğ•œ} :\n    PosSemidef A â†” âˆƒ (B : Matrix n n ğ•œ), A = Bá´´ * B := by\n  classical\n  refine âŸ¨fun hA â†¦ âŸ¨hA.sqrt, ?_âŸ©, fun âŸ¨B, hBâŸ© â†¦ (hB â–¸ posSemidef_conjTranspose_mul_self B)âŸ©\n  simp_rw [â† PosSemidef.sq_sqrt hA, pow_two]\n  rw [hA.posSemidef_sqrt.1]\n\n"}
{"name":"Matrix.IsHermitian.posSemidef_of_eigenvalues_nonneg","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nğ•œ : Type u_4\ninstâœÂ² : Fintype n\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nhA : A.IsHermitian\nh : âˆ€ (i : n), LE.le 0 (hA.eigenvalues i)\nâŠ¢ A.PosSemidef","decl":"lemma IsHermitian.posSemidef_of_eigenvalues_nonneg [DecidableEq n] {A : Matrix n n ğ•œ}\n    (hA : IsHermitian A) (h : âˆ€ i : n, 0 â‰¤ hA.eigenvalues i) : PosSemidef A := by\n  rw [hA.spectral_theorem]\n  refine (posSemidef_diagonal_iff.mpr ?_).mul_mul_conjTranspose_same _\n  simpa using h\n\n"}
{"name":"Matrix.PosSemidef.dotProduct_mulVec_zero_iff","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nğ•œ : Type u_4\ninstâœÂ¹ : Fintype n\ninstâœ : RCLike ğ•œ\nA : Matrix n n ğ•œ\nhA : A.PosSemidef\nx : n â†’ ğ•œ\nâŠ¢ Iff (Eq (dotProduct (Star.star x) (A.mulVec x)) 0) (Eq (A.mulVec x) 0)","decl":"/-- For `A` positive semidefinite, we have `xâ‹† A x = 0` iff `A x = 0`. -/\ntheorem PosSemidef.dotProduct_mulVec_zero_iff\n    {A : Matrix n n ğ•œ} (hA : PosSemidef A) (x : n â†’ ğ•œ) :\n    star x â¬áµ¥ A *áµ¥ x = 0 â†” A *áµ¥ x = 0 := by\n  constructor\n  Â· obtain âŸ¨B, rflâŸ© := posSemidef_iff_eq_transpose_mul_self.mp hA\n    rw [â† Matrix.mulVec_mulVec, dotProduct_mulVec,\n      vecMul_conjTranspose, star_star, dotProduct_star_self_eq_zero]\n    intro h0\n    rw [h0, mulVec_zero]\n  Â· intro h0\n    rw [h0, dotProduct_zero]\n\n"}
{"name":"Matrix.PosSemidef.toLinearMapâ‚‚'_zero_iff","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nğ•œ : Type u_4\ninstâœÂ² : Fintype n\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nhA : A.PosSemidef\nx : n â†’ ğ•œ\nâŠ¢ Iff (Eq ((((Matrix.toLinearMapâ‚‚' ğ•œ) A) (Star.star x)) x) 0) (Eq ((Matrix.toLin' A) x) 0)","decl":"/-- For `A` positive semidefinite, we have `xâ‹† A x = 0` iff `A x = 0` (linear maps version). -/\ntheorem PosSemidef.toLinearMapâ‚‚'_zero_iff [DecidableEq n]\n    {A : Matrix n n ğ•œ} (hA : PosSemidef A) (x : n â†’ ğ•œ) :\n    Matrix.toLinearMapâ‚‚' ğ•œ A (star x) x = 0 â†” Matrix.toLin' A x = 0 := by\n  simpa only [toLinearMapâ‚‚'_apply', toLin'_apply] using hA.dotProduct_mulVec_zero_iff x\n\n"}
{"name":"Matrix.PosDef.isHermitian","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœÂ³ : Fintype n\ninstâœÂ² : CommRing R\ninstâœÂ¹ : PartialOrder R\ninstâœ : StarRing R\nM : Matrix n n R\nhM : M.PosDef\nâŠ¢ M.IsHermitian","decl":"theorem isHermitian {M : Matrix n n R} (hM : M.PosDef) : M.IsHermitian :=\n  hM.1\n\n"}
{"name":"Matrix.PosDef.re_dotProduct_pos","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nğ•œ : Type u_4\ninstâœÂ¹ : Fintype n\ninstâœ : RCLike ğ•œ\nM : Matrix n n ğ•œ\nhM : M.PosDef\nx : n â†’ ğ•œ\nhx : Ne x 0\nâŠ¢ LT.lt 0 (RCLike.re (dotProduct (Star.star x) (M.mulVec x)))","decl":"theorem re_dotProduct_pos {M : Matrix n n ğ•œ} (hM : M.PosDef) {x : n â†’ ğ•œ} (hx : x â‰  0) :\n    0 < RCLike.re (dotProduct (star x) (M *áµ¥ x)) :=\n  RCLike.pos_iff.mp (hM.2 _ hx) |>.1\n\n"}
{"name":"Matrix.PosDef.posSemidef","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœÂ³ : Fintype n\ninstâœÂ² : CommRing R\ninstâœÂ¹ : PartialOrder R\ninstâœ : StarRing R\nM : Matrix n n R\nhM : M.PosDef\nâŠ¢ M.PosSemidef","decl":"theorem posSemidef {M : Matrix n n R} (hM : M.PosDef) : M.PosSemidef := by\n  refine âŸ¨hM.1, ?_âŸ©\n  intro x\n  by_cases hx : x = 0\n  Â· simp only [hx, zero_dotProduct, star_zero, RCLike.zero_re']\n    exact le_rfl\n  Â· exact le_of_lt (hM.2 x hx)\n\n"}
{"name":"Matrix.PosDef.transpose","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœÂ³ : Fintype n\ninstâœÂ² : CommRing R\ninstâœÂ¹ : PartialOrder R\ninstâœ : StarRing R\nM : Matrix n n R\nhM : M.PosDef\nâŠ¢ M.transpose.PosDef","decl":"theorem transpose {M : Matrix n n R} (hM : M.PosDef) : Máµ€.PosDef := by\n  refine âŸ¨IsHermitian.transpose hM.1, fun x hx => ?_âŸ©\n  convert hM.2 (star x) (star_ne_zero.2 hx) using 1\n  rw [mulVec_transpose, dotProduct_mulVec, star_star, dotProduct_comm]\n\n"}
{"name":"Matrix.PosDef.diagonal","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœâ¶ : Fintype n\ninstâœâµ : CommRing R\ninstâœâ´ : PartialOrder R\ninstâœÂ³ : StarRing R\ninstâœÂ² : StarOrderedRing R\ninstâœÂ¹ : DecidableEq n\ninstâœ : NoZeroDivisors R\nd : n â†’ R\nh : âˆ€ (i : n), LT.lt 0 (d i)\nâŠ¢ (Matrix.diagonal d).PosDef","decl":"protected theorem diagonal [StarOrderedRing R] [DecidableEq n] [NoZeroDivisors R]\n    {d : n â†’ R} (h : âˆ€ i, 0 < d i) :\n    PosDef (diagonal d) :=\n  âŸ¨isHermitian_diagonal_of_self_adjoint _ <| funext fun i => IsSelfAdjoint.of_nonneg (h i).le,\n    fun x hx => by\n      refine Fintype.sum_pos ?_\n      simp_rw [mulVec_diagonal, â† mul_assoc, Pi.lt_def]\n      obtain âŸ¨i, hiâŸ© := Function.ne_iff.mp hx\n      exact âŸ¨fun i => conjugate_nonneg (h i).le _,\n        i, conjugate_pos (h _) (isRegular_of_ne_zero hi)âŸ©âŸ©\n\n"}
{"name":"Matrix.posDef_diagonal_iff","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœâ· : Fintype n\ninstâœâ¶ : CommRing R\ninstâœâµ : PartialOrder R\ninstâœâ´ : StarRing R\ninstâœÂ³ : StarOrderedRing R\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : NoZeroDivisors R\ninstâœ : Nontrivial R\nd : n â†’ R\nâŠ¢ Iff (Matrix.diagonal d).PosDef (âˆ€ (i : n), LT.lt 0 (d i))","decl":"@[simp]\ntheorem _root_.Matrix.posDef_diagonal_iff\n    [StarOrderedRing R] [DecidableEq n] [NoZeroDivisors R] [Nontrivial R] {d : n â†’ R} :\n    PosDef (diagonal d) â†” âˆ€ i, 0 < d i := by\n  refine âŸ¨fun h i => ?_, .diagonalâŸ©\n  have := h.2 (Pi.single i 1)\n  simp_rw [mulVec_single_one, â† Pi.single_star, star_one, single_dotProduct, one_mul,\n    transpose_apply, diagonal_apply_eq, Function.ne_iff] at this\n  exact this âŸ¨i, by simpâŸ©\n\n"}
{"name":"Matrix.PosDef.one","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœâ¶ : Fintype n\ninstâœâµ : CommRing R\ninstâœâ´ : PartialOrder R\ninstâœÂ³ : StarRing R\ninstâœÂ² : StarOrderedRing R\ninstâœÂ¹ : DecidableEq n\ninstâœ : NoZeroDivisors R\nâŠ¢ Matrix.PosDef 1","decl":"protected theorem one [StarOrderedRing R] [DecidableEq n] [NoZeroDivisors R] :\n    PosDef (1 : Matrix n n R) :=\n  âŸ¨isHermitian_one, fun x hx => by simpa only [one_mulVec, dotProduct_star_self_pos_iff]âŸ©\n\n"}
{"name":"Matrix.PosDef.natCast","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœâ¶ : Fintype n\ninstâœâµ : CommRing R\ninstâœâ´ : PartialOrder R\ninstâœÂ³ : StarRing R\ninstâœÂ² : StarOrderedRing R\ninstâœÂ¹ : DecidableEq n\ninstâœ : NoZeroDivisors R\nd : Nat\nhd : Ne d 0\nâŠ¢ (â†‘d).PosDef","decl":"protected theorem natCast [StarOrderedRing R] [DecidableEq n] [NoZeroDivisors R]\n    (d : â„•) (hd : d â‰  0) :\n    PosDef (d : Matrix n n R) :=\n  âŸ¨isHermitian_natCast _, fun x hx => by\n    simp only [natCast_mulVec, dotProduct_smul]\n    rw [Nat.cast_smul_eq_nsmul]\n    exact nsmul_pos (dotProduct_star_self_pos_iff.mpr hx) hdâŸ©\n\n"}
{"name":"Matrix.posDef_natCast_iff","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœâ¸ : Fintype n\ninstâœâ· : CommRing R\ninstâœâ¶ : PartialOrder R\ninstâœâµ : StarRing R\ninstâœâ´ : StarOrderedRing R\ninstâœÂ³ : DecidableEq n\ninstâœÂ² : NoZeroDivisors R\ninstâœÂ¹ : Nonempty n\ninstâœ : Nontrivial R\nd : Nat\nâŠ¢ Iff (â†‘d).PosDef (LT.lt 0 d)","decl":"@[simp]\ntheorem _root_.Matrix.posDef_natCast_iff [StarOrderedRing R] [DecidableEq n] [NoZeroDivisors R]\n    [Nonempty n] [Nontrivial R] {d : â„•} :\n    PosDef (d : Matrix n n R) â†” 0 < d :=\n  posDef_diagonal_iff.trans <| by simp\n\n"}
{"name":"Matrix.PosDef.ofNat","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœâ· : Fintype n\ninstâœâ¶ : CommRing R\ninstâœâµ : PartialOrder R\ninstâœâ´ : StarRing R\ninstâœÂ³ : StarOrderedRing R\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : NoZeroDivisors R\nd : Nat\ninstâœ : d.AtLeastTwo\nâŠ¢ (OfNat.ofNat d).PosDef","decl":"protected theorem ofNat [StarOrderedRing R] [DecidableEq n] [NoZeroDivisors R]\n    (d : â„•) [d.AtLeastTwo] :\n    PosDef (ofNat(d) : Matrix n n R) :=\n  .natCast d (NeZero.ne _)\n\n"}
{"name":"Matrix.PosDef.intCast","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœâ¶ : Fintype n\ninstâœâµ : CommRing R\ninstâœâ´ : PartialOrder R\ninstâœÂ³ : StarRing R\ninstâœÂ² : StarOrderedRing R\ninstâœÂ¹ : DecidableEq n\ninstâœ : NoZeroDivisors R\nd : Int\nhd : LT.lt 0 d\nâŠ¢ (â†‘d).PosDef","decl":"protected theorem intCast [StarOrderedRing R] [DecidableEq n] [NoZeroDivisors R]\n    (d : â„¤) (hd : 0 < d) :\n    PosDef (d : Matrix n n R) :=\n  âŸ¨isHermitian_intCast _, fun x hx => by\n    simp only [intCast_mulVec, dotProduct_smul]\n    rw [Int.cast_smul_eq_zsmul]\n    exact zsmul_pos (dotProduct_star_self_pos_iff.mpr hx) hdâŸ©\n\n"}
{"name":"Matrix.posDef_intCast_iff","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nR : Type u_3\ninstâœâ¸ : Fintype n\ninstâœâ· : CommRing R\ninstâœâ¶ : PartialOrder R\ninstâœâµ : StarRing R\ninstâœâ´ : StarOrderedRing R\ninstâœÂ³ : DecidableEq n\ninstâœÂ² : NoZeroDivisors R\ninstâœÂ¹ : Nonempty n\ninstâœ : Nontrivial R\nd : Int\nâŠ¢ Iff (â†‘d).PosDef (LT.lt 0 d)","decl":"@[simp]\ntheorem _root_.Matrix.posDef_intCast_iff [StarOrderedRing R] [DecidableEq n] [NoZeroDivisors R]\n    [Nonempty n] [Nontrivial R] {d : â„¤} :\n    PosDef (d : Matrix n n R) â†” 0 < d :=\n  posDef_diagonal_iff.trans <| by simp\n\n"}
{"name":"Matrix.PosDef.add_posSemidef","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"m : Type u_1\nR : Type u_3\ninstâœâ´ : Fintype m\ninstâœÂ³ : CommRing R\ninstâœÂ² : PartialOrder R\ninstâœÂ¹ : StarRing R\ninstâœ : AddLeftMono R\nA B : Matrix m m R\nhA : A.PosDef\nhB : B.PosSemidef\nâŠ¢ (HAdd.hAdd A B).PosDef","decl":"protected lemma add_posSemidef [AddLeftMono R]\n    {A : Matrix m m R} {B : Matrix m m R}\n    (hA : A.PosDef) (hB : B.PosSemidef) : (A + B).PosDef :=\n  âŸ¨hA.isHermitian.add hB.isHermitian, fun x hx => by\n    rw [add_mulVec, dotProduct_add]\n    exact add_pos_of_pos_of_nonneg (hA.2 x hx) (hB.2 x)âŸ©\n\n"}
{"name":"Matrix.PosDef.posSemidef_add","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"m : Type u_1\nR : Type u_3\ninstâœâ´ : Fintype m\ninstâœÂ³ : CommRing R\ninstâœÂ² : PartialOrder R\ninstâœÂ¹ : StarRing R\ninstâœ : AddLeftMono R\nA B : Matrix m m R\nhA : A.PosSemidef\nhB : B.PosDef\nâŠ¢ (HAdd.hAdd A B).PosDef","decl":"protected lemma posSemidef_add [AddLeftMono R]\n    {A : Matrix m m R} {B : Matrix m m R}\n    (hA : A.PosSemidef) (hB : B.PosDef) : (A + B).PosDef :=\n  âŸ¨hA.isHermitian.add hB.isHermitian, fun x hx => by\n    rw [add_mulVec, dotProduct_add]\n    exact add_pos_of_nonneg_of_pos (hA.2 x) (hB.2 x hx)âŸ©\n\n"}
{"name":"Matrix.PosDef.add","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"m : Type u_1\nR : Type u_3\ninstâœâ´ : Fintype m\ninstâœÂ³ : CommRing R\ninstâœÂ² : PartialOrder R\ninstâœÂ¹ : StarRing R\ninstâœ : AddLeftMono R\nA B : Matrix m m R\nhA : A.PosDef\nhB : B.PosDef\nâŠ¢ (HAdd.hAdd A B).PosDef","decl":"protected lemma add [AddLeftMono R] {A : Matrix m m R} {B : Matrix m m R}\n    (hA : A.PosDef) (hB : B.PosDef) : (A + B).PosDef :=\n  hA.add_posSemidef hB.posSemidef\n\n"}
{"name":"Matrix.PosDef.of_toQuadraticForm'","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nM : Matrix n n Real\nhM : M.IsSymm\nhMq : M.toQuadraticMap'.PosDef\nâŠ¢ M.PosDef","decl":"theorem of_toQuadraticForm' [DecidableEq n] {M : Matrix n n â„} (hM : M.IsSymm)\n    (hMq : M.toQuadraticMap'.PosDef) : M.PosDef := by\n  refine âŸ¨hM, fun x hx => ?_âŸ©\n  simp only [toQuadraticMap', QuadraticMap.PosDef, LinearMap.BilinMap.toQuadraticMap_apply,\n    toLinearMapâ‚‚'_apply'] at hMq\n  apply hMq x hx\n\n"}
{"name":"Matrix.PosDef.toQuadraticForm'","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nM : Matrix n n Real\nhM : M.PosDef\nâŠ¢ M.toQuadraticMap'.PosDef","decl":"theorem toQuadraticForm' [DecidableEq n] {M : Matrix n n â„} (hM : M.PosDef) :\n    M.toQuadraticMap'.PosDef := by\n  intro x hx\n  simp only [Matrix.toQuadraticMap', LinearMap.BilinMap.toQuadraticMap_apply,\n    toLinearMapâ‚‚'_apply']\n  apply hM.2 x hx\n\n"}
{"name":"Matrix.PosDef.eigenvalues_pos","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nğ•œ : Type u_4\ninstâœÂ² : Fintype n\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nhA : A.PosDef\ni : n\nâŠ¢ LT.lt 0 (â‹¯.eigenvalues i)","decl":"/-- The eigenvalues of a positive definite matrix are positive -/\nlemma eigenvalues_pos [DecidableEq n] {A : Matrix n n ğ•œ}\n    (hA : Matrix.PosDef A) (i : n) : 0 < hA.1.eigenvalues i := by\n  simp only [hA.1.eigenvalues_eq]\n  exact hA.re_dotProduct_pos <| hA.1.eigenvectorBasis.orthonormal.ne_zero i\n\n"}
{"name":"Matrix.PosDef.det_pos","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nğ•œ : Type u_4\ninstâœÂ² : Fintype n\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : DecidableEq n\nM : Matrix n n ğ•œ\nhM : M.PosDef\nâŠ¢ LT.lt 0 M.det","decl":"theorem det_pos [DecidableEq n] {M : Matrix n n ğ•œ} (hM : M.PosDef) : 0 < det M := by\n  rw [hM.isHermitian.det_eq_prod_eigenvalues]\n  apply Finset.prod_pos\n  intro i _\n  simpa using hM.eigenvalues_pos i\n\n"}
{"name":"Matrix.PosDef.isUnit","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nğ•œ : Type u_4\ninstâœÂ² : Fintype n\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : DecidableEq n\nM : Matrix n n ğ•œ\nhM : M.PosDef\nâŠ¢ IsUnit M","decl":"theorem isUnit [DecidableEq n] {M : Matrix n n ğ•œ} (hM : M.PosDef) : IsUnit M :=\n  isUnit_iff_isUnit_det _ |>.2 <| hM.det_pos.ne'.isUnit\n\n"}
{"name":"Matrix.PosDef.inv","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nğ•œ : Type u_4\ninstâœÂ² : Fintype n\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : DecidableEq n\nM : Matrix n n ğ•œ\nhM : M.PosDef\nâŠ¢ (Inv.inv M).PosDef","decl":"protected theorem inv [DecidableEq n] {M : Matrix n n ğ•œ} (hM : M.PosDef) : Mâ»Â¹.PosDef := by\n  refine âŸ¨hM.isHermitian.inv, fun x hx => ?_âŸ©\n  have := hM.2 (Mâ»Â¹ *áµ¥ x) ((Matrix.mulVec_injective_iff_isUnit.mpr ?_ |>.ne_iff' ?_).2 hx)\n  Â· let _inst := hM.isUnit.invertible\n    rwa [star_mulVec, mulVec_mulVec, Matrix.mul_inv_of_invertible, one_mulVec,\n      â† star_pos_iff, â† star_mulVec, â† star_dotProduct] at this\n  Â· simpa using hM.isUnit\n  Â· simp\n\n"}
{"name":"Matrix.posDef_inv_iff","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_2\nğ•œ : Type u_4\ninstâœÂ² : Fintype n\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : DecidableEq n\nM : Matrix n n ğ•œ\nâŠ¢ Iff (Inv.inv M).PosDef M.PosDef","decl":"@[simp]\ntheorem _root_.Matrix.posDef_inv_iff [DecidableEq n] {M : Matrix n n ğ•œ} :\n    Mâ»Â¹.PosDef â†” M.PosDef :=\n  âŸ¨fun h =>\n    letI := (Matrix.isUnit_nonsing_inv_iff.1 <| h.isUnit).invertible\n    Matrix.inv_inv_of_invertible M â–¸ h.inv, (Â·.inv)âŸ©\n\n"}
{"name":"QuadraticForm.posDef_of_toMatrix'","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_1\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nQ : QuadraticForm Real (n â†’ Real)\nhQ : (QuadraticMap.toMatrix' Q).PosDef\nâŠ¢ QuadraticMap.PosDef Q","decl":"theorem posDef_of_toMatrix' [DecidableEq n] {Q : QuadraticForm â„ (n â†’ â„)}\n    (hQ : Q.toMatrix'.PosDef) : Q.PosDef := by\n  rw [â† toQuadraticMap_associated â„ Q,\n    â† (LinearMap.toMatrixâ‚‚' â„).left_inv ((associatedHom (R := â„) â„) Q)]\n  exact hQ.toQuadraticForm'\n\n"}
{"name":"QuadraticForm.posDef_toMatrix'","module":"Mathlib.LinearAlgebra.Matrix.PosDef","initialProofState":"n : Type u_1\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nQ : QuadraticForm Real (n â†’ Real)\nhQ : QuadraticMap.PosDef Q\nâŠ¢ (QuadraticMap.toMatrix' Q).PosDef","decl":"theorem posDef_toMatrix' [DecidableEq n] {Q : QuadraticForm â„ (n â†’ â„)} (hQ : Q.PosDef) :\n    Q.toMatrix'.PosDef := by\n  rw [â† toQuadraticMap_associated â„ Q, â†\n    (LinearMap.toMatrixâ‚‚' â„).left_inv ((associatedHom (R := â„) â„) Q)] at hQ\n  exact .of_toQuadraticForm' (isSymm_toMatrix' Q) hQ\n\n"}
