{"name":"RootPairing.instFiniteSubtypeMemSubmoduleRootSpan","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Module.Finite R (Subtype fun x => Membership.mem P.rootSpan x)","decl":"instance : Module.Finite R P.rootSpan := Finite.span_of_finite R <| finite_range P.root\n\n"}
{"name":"RootPairing.instFiniteSubtypeMemSubmoduleCorootSpan","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Module.Finite R (Subtype fun x => Membership.mem P.corootSpan x)","decl":"instance : Module.Finite R P.corootSpan := Finite.span_of_finite R <| finite_range P.coroot\n\n"}
{"name":"RootPairing.Polarization_apply","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nx : M\n⊢ Eq (P.Polarization x) (Finset.univ.sum fun i => HSMul.hSMul ((P.coroot' i) x) (P.coroot i))","decl":"@[simp]\nlemma Polarization_apply (x : M) :\n    P.Polarization x = ∑ i, P.coroot' i x • P.coroot i := by\n  simp [Polarization]\n\n"}
{"name":"RootPairing.CoPolarization_apply","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nx : N\n⊢ Eq (P.CoPolarization x) (Finset.univ.sum fun i => HSMul.hSMul ((P.root' i) x) (P.root i))","decl":"@[simp]\nlemma CoPolarization_apply (x : N) :\n    P.CoPolarization x = ∑ i, P.root' i x • P.root i := by\n  simp [CoPolarization]\n\n"}
{"name":"RootPairing.CoPolarization_eq","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Eq P.CoPolarization P.flip.Polarization","decl":"lemma CoPolarization_eq : P.CoPolarization = P.flip.Polarization :=\n  rfl\n\n"}
{"name":"RootPairing.rootForm_apply_apply","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nx y : M\n⊢ Eq ((P.RootForm x) y) (Finset.univ.sum fun i => HMul.hMul ((P.coroot' i) x) ((P.coroot' i) y))","decl":"lemma rootForm_apply_apply (x y : M) : P.RootForm x y =\n    ∑ i, P.coroot' i x * P.coroot' i y := by\n  simp [RootForm]\n\n"}
{"name":"RootPairing.corootForm_apply_apply","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nx y : N\n⊢ Eq ((P.CorootForm x) y) (Finset.univ.sum fun i => HMul.hMul ((P.root' i) x) ((P.root' i) y))","decl":"lemma corootForm_apply_apply (x y : N) : P.CorootForm x y =\n    ∑ i, P.root' i x * P.root' i y := by\n  simp [CorootForm]\n\n"}
{"name":"RootPairing.toPerfectPairing_apply_apply_Polarization","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nx y : M\n⊢ Eq ((P.toPerfectPairing y) (P.Polarization x)) ((P.RootForm x) y)","decl":"lemma toPerfectPairing_apply_apply_Polarization (x y : M) :\n    P.toPerfectPairing y (P.Polarization x) = P.RootForm x y := by\n  simp [RootForm]\n\n"}
{"name":"RootPairing.toPerfectPairing_apply_CoPolarization","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nx : N\n⊢ Eq (P.toPerfectPairing (P.CoPolarization x)) (P.CorootForm x)","decl":"lemma toPerfectPairing_apply_CoPolarization (x : N) :\n    P.toPerfectPairing (P.CoPolarization x) = P.CorootForm x := by\n  ext y\n  exact P.flip.toPerfectPairing_apply_apply_Polarization x y\n\n"}
{"name":"RootPairing.flip_comp_polarization_eq_rootForm","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Eq (P.flip.toLin.comp P.Polarization) P.RootForm","decl":"lemma flip_comp_polarization_eq_rootForm :\n    P.flip.toLin ∘ₗ P.Polarization = P.RootForm := by\n  ext; simp [rootForm_apply_apply, RootPairing.flip]\n\n"}
{"name":"RootPairing.self_comp_coPolarization_eq_corootForm","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Eq (P.toLin.comp P.CoPolarization) P.CorootForm","decl":"lemma self_comp_coPolarization_eq_corootForm :\n    P.toLin ∘ₗ P.CoPolarization = P.CorootForm := by\n  ext; simp [corootForm_apply_apply]\n\n"}
{"name":"RootPairing.polarization_apply_eq_zero_iff","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nm : M\n⊢ Iff (Eq (P.Polarization m) 0) (Eq (P.RootForm m) 0)","decl":"lemma polarization_apply_eq_zero_iff (m : M) :\n    P.Polarization m = 0 ↔ P.RootForm m = 0 := by\n  rw [← flip_comp_polarization_eq_rootForm]\n  refine ⟨fun h ↦ by simp [h], fun h ↦ ?_⟩\n  change P.toDualRight (P.Polarization m) = 0 at h\n  simp only [EmbeddingLike.map_eq_zero_iff] at h\n  exact h\n\n"}
{"name":"RootPairing.coPolarization_apply_eq_zero_iff","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nn : N\n⊢ Iff (Eq (P.CoPolarization n) 0) (Eq (P.CorootForm n) 0)","decl":"lemma coPolarization_apply_eq_zero_iff (n : N) :\n    P.CoPolarization n = 0 ↔ P.CorootForm n = 0 :=\n  P.flip.polarization_apply_eq_zero_iff n\n\n"}
{"name":"RootPairing.ker_polarization_eq_ker_rootForm","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Eq (LinearMap.ker P.Polarization) (LinearMap.ker P.RootForm)","decl":"lemma ker_polarization_eq_ker_rootForm :\n    LinearMap.ker P.Polarization = LinearMap.ker P.RootForm := by\n  ext; simp only [LinearMap.mem_ker, P.polarization_apply_eq_zero_iff]\n\n"}
{"name":"RootPairing.ker_copolarization_eq_ker_corootForm","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Eq (LinearMap.ker P.CoPolarization) (LinearMap.ker P.CorootForm)","decl":"lemma ker_copolarization_eq_ker_corootForm :\n    LinearMap.ker P.CoPolarization = LinearMap.ker P.CorootForm :=\n  P.flip.ker_polarization_eq_ker_rootForm\n\n"}
{"name":"RootPairing.rootForm_symmetric","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ LinearMap.IsSymm P.RootForm","decl":"lemma rootForm_symmetric :\n    LinearMap.IsSymm P.RootForm := by\n  simp [LinearMap.IsSymm, mul_comm, rootForm_apply_apply]\n\n"}
{"name":"RootPairing.rootForm_reflection_reflection_apply","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\nx y : M\n⊢ Eq ((P.RootForm ((P.reflection i) x)) ((P.reflection i) y)) ((P.RootForm x) y)","decl":"@[simp]\nlemma rootForm_reflection_reflection_apply (i : ι) (x y : M) :\n    P.RootForm (P.reflection i x) (P.reflection i y) = P.RootForm x y := by\n  simp only [rootForm_apply_apply, coroot'_reflection]\n  exact Fintype.sum_equiv (P.reflection_perm i)\n    (fun j ↦ (P.coroot' (P.reflection_perm i j) x) * (P.coroot' (P.reflection_perm i j) y))\n    (fun j ↦ P.coroot' j x * P.coroot' j y) (congrFun rfl)\n\n"}
{"name":"RootPairing.rootForm_self_smul_coroot","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Eq (HSMul.hSMul ((P.RootForm (P.root i)) (P.root i)) (P.coroot i)) (HSMul.hSMul 2 (P.Polarization (P.root i)))","decl":"/-- This is SGA3 XXI Lemma 1.2.1 (10), key for proving nondegeneracy and positivity. -/\nlemma rootForm_self_smul_coroot (i : ι) :\n    (P.RootForm (P.root i) (P.root i)) • P.coroot i = 2 • P.Polarization (P.root i) := by\n  have hP : P.Polarization (P.root i) =\n      ∑ j : ι, P.pairing i (P.reflection_perm i j) • P.coroot (P.reflection_perm i j) := by\n    simp_rw [Polarization_apply, root_coroot'_eq_pairing]\n    exact (Fintype.sum_equiv (P.reflection_perm i)\n          (fun j ↦ P.pairing i (P.reflection_perm i j) • P.coroot (P.reflection_perm i j))\n          (fun j ↦ P.pairing i j • P.coroot j) (congrFun rfl)).symm\n  rw [two_nsmul]\n  nth_rw 2 [hP]\n  rw [Polarization_apply]\n  simp only [root_coroot'_eq_pairing, pairing_reflection_perm, pairing_reflection_perm_self_left,\n    ← reflection_perm_coroot, smul_sub, neg_smul, sub_neg_eq_add]\n  rw [Finset.sum_add_distrib, ← add_assoc, ← sub_eq_iff_eq_add]\n  simp only [rootForm_apply_apply, LinearMap.coe_comp, comp_apply, Polarization_apply,\n    root_coroot_eq_pairing, map_sum, LinearMapClass.map_smul, Finset.sum_neg_distrib, ← smul_assoc]\n  rw [Finset.sum_smul, add_neg_eq_zero.mpr rfl]\n  exact sub_eq_zero_of_eq rfl\n\n"}
{"name":"RootPairing.four_smul_rootForm_sq_eq_coxeterWeight_smul","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\n⊢ Eq (HSMul.hSMul 4 (HPow.hPow ((P.RootForm (P.root i)) (P.root j)) 2)) (HSMul.hSMul (P.coxeterWeight i j) (HMul.hMul ((P.RootForm (P.root i)) (P.root i)) ((P.RootForm (P.root j)) (P.root j))))","decl":"lemma four_smul_rootForm_sq_eq_coxeterWeight_smul (i j : ι) :\n    4 • (P.RootForm (P.root i) (P.root j)) ^ 2 = P.coxeterWeight i j •\n      (P.RootForm (P.root i) (P.root i) * P.RootForm (P.root j) (P.root j)) := by\n  have hij : 4 • (P.RootForm (P.root i)) (P.root j) =\n      2 • P.toPerfectPairing (P.root j) (2 • P.Polarization (P.root i)) := by\n    rw [← toPerfectPairing_apply_apply_Polarization, LinearMap.map_smul_of_tower, ← smul_assoc,\n      Nat.nsmul_eq_mul]\n  have hji : 2 • (P.RootForm (P.root i)) (P.root j) =\n      P.toPerfectPairing (P.root i) (2 • P.Polarization (P.root j)) := by\n    rw [show (P.RootForm (P.root i)) (P.root j) = (P.RootForm (P.root j)) (P.root i) by\n      apply rootForm_symmetric, ← toPerfectPairing_apply_apply_Polarization,\n      LinearMap.map_smul_of_tower]\n  rw [sq, nsmul_eq_mul, ← mul_assoc, ← nsmul_eq_mul, hij, ← rootForm_self_smul_coroot,\n    smul_mul_assoc 2, ← mul_smul_comm, hji, ← rootForm_self_smul_coroot, map_smul, ← pairing,\n    map_smul, ← pairing, smul_eq_mul, smul_eq_mul, smul_eq_mul, coxeterWeight]\n  ring\n\n"}
{"name":"RootPairing.corootForm_self_smul_root","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Eq (HSMul.hSMul ((P.CorootForm (P.coroot i)) (P.coroot i)) (P.root i)) (HSMul.hSMul 2 (P.CoPolarization (P.coroot i)))","decl":"lemma corootForm_self_smul_root (i : ι) :\n    (P.CorootForm (P.coroot i) (P.coroot i)) • P.root i = 2 • P.CoPolarization (P.coroot i) :=\n  rootForm_self_smul_coroot (P.flip) i\n\n"}
{"name":"RootPairing.rootForm_self_sum_of_squares","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nx : M\n⊢ IsSumSq ((P.RootForm x) x)","decl":"lemma rootForm_self_sum_of_squares (x : M) :\n    IsSumSq (P.RootForm x x) :=\n  P.rootForm_apply_apply x x ▸ IsSumSq.sum_mul_self Finset.univ _\n\n"}
{"name":"RootPairing.rootForm_root_self","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nj : ι\n⊢ Eq ((P.RootForm (P.root j)) (P.root j)) (Finset.univ.sum fun i => HMul.hMul (P.pairing j i) (P.pairing j i))","decl":"lemma rootForm_root_self (j : ι) :\n    P.RootForm (P.root j) (P.root j) = ∑ (i : ι), (P.pairing j i) * (P.pairing j i) := by\n  simp [rootForm_apply_apply]\n\n"}
{"name":"RootPairing.range_polarization_domRestrict_le_span_coroot","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ LE.le (LinearMap.range (P.Polarization.domRestrict P.rootSpan)) P.corootSpan","decl":"theorem range_polarization_domRestrict_le_span_coroot :\n    LinearMap.range (P.Polarization.domRestrict P.rootSpan) ≤ P.corootSpan := by\n  intro y hy\n  obtain ⟨x, hx⟩ := hy\n  rw [← hx, LinearMap.domRestrict_apply, Polarization_apply]\n  refine (mem_span_range_iff_exists_fun R).mpr ?_\n  use fun i => (P.toPerfectPairing x) (P.coroot i)\n  simp\n\n"}
{"name":"RootPairing.corootSpan_dualAnnihilator_le_ker_rootForm","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ LE.le (Submodule.map P.toDualLeft.symm P.corootSpan.dualAnnihilator) (LinearMap.ker P.RootForm)","decl":"theorem corootSpan_dualAnnihilator_le_ker_rootForm :\n    P.corootSpan.dualAnnihilator.map P.toDualLeft.symm ≤ LinearMap.ker P.RootForm := by\n  rw [← SetLike.coe_subset_coe, coe_corootSpan_dualAnnihilator_map]\n  intro x hx\n  simp only [coroot', PerfectPairing.flip_apply_apply, mem_setOf_eq] at hx\n  ext y\n  simp [rootForm_apply_apply, hx]\n\n"}
{"name":"RootPairing.rootSpan_dualAnnihilator_le_ker_rootForm","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ LE.le (Submodule.map P.toDualRight.symm P.rootSpan.dualAnnihilator) (LinearMap.ker P.CorootForm)","decl":"theorem rootSpan_dualAnnihilator_le_ker_rootForm :\n    P.rootSpan.dualAnnihilator.map P.toDualRight.symm ≤ LinearMap.ker P.CorootForm :=\n  P.flip.corootSpan_dualAnnihilator_le_ker_rootForm\n\n"}
{"name":"RootPairing.prod_rootForm_smul_coroot_mem_range_domRestrict","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Membership.mem (LinearMap.range (P.Polarization.domRestrict P.rootSpan)) (HSMul.hSMul (Finset.univ.prod fun a => (P.RootForm (P.root a)) (P.root a)) (P.coroot i))","decl":"lemma prod_rootForm_smul_coroot_mem_range_domRestrict (i : ι) :\n    (∏ a : ι, P.RootForm (P.root a) (P.root a)) • P.coroot i ∈\n      LinearMap.range (P.Polarization.domRestrict (P.rootSpan)) := by\n  obtain ⟨c, hc⟩ := Finset.dvd_prod_of_mem (fun a ↦ P.RootForm (P.root a) (P.root a))\n    (Finset.mem_univ i)\n  rw [hc, mul_comm, mul_smul, rootForm_self_smul_coroot]\n  refine LinearMap.mem_range.mpr ?_\n  use ⟨(c • 2 • P.root i), by aesop⟩\n  simp\n\n"}
{"name":"RootPairing.rootForm_self_non_neg","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : LinearOrderedCommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nx : M\n⊢ LE.le 0 ((P.RootForm x) x)","decl":"theorem rootForm_self_non_neg (x : M) : 0 ≤ P.RootForm x x :=\n  IsSumSq.nonneg (P.rootForm_self_sum_of_squares x)\n\n"}
{"name":"RootPairing.rootForm_self_eq_zero_iff","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : LinearOrderedCommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nx : M\n⊢ Iff (Eq ((P.RootForm x) x) 0) (Membership.mem (LinearMap.ker P.RootForm) x)","decl":"lemma rootForm_self_eq_zero_iff {x : M} :\n    P.RootForm x x = 0 ↔ x ∈ LinearMap.ker P.RootForm :=\n  P.RootForm.apply_apply_same_eq_zero_iff P.rootForm_self_non_neg P.rootForm_symmetric\n\n"}
{"name":"RootPairing.rootForm_root_self_pos","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : LinearOrderedCommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ LT.lt 0 ((P.RootForm (P.root i)) (P.root i))","decl":"lemma rootForm_root_self_pos (i : ι) :\n    0 < P.RootForm (P.root i) (P.root i) := by\n  simp only [rootForm_apply_apply]\n  exact Finset.sum_pos' (fun j _ ↦ mul_self_nonneg _) ⟨i, by simp⟩\n\n"}
{"name":"RootPairing.coxeterWeight_le_four","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : LinearOrderedCommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\n⊢ LE.le (P.coxeterWeight i j) 4","decl":"/-- SGA3 XXI Prop. 2.3.1 -/\nlemma coxeterWeight_le_four (i j : ι) : P.coxeterWeight i j ≤ 4 := by\n  set li := P.RootForm (P.root i) (P.root i)\n  set lj := P.RootForm (P.root j) (P.root j)\n  set lij := P.RootForm (P.root i) (P.root j)\n  have hi := P.rootForm_root_self_pos i\n  have hj := P.rootForm_root_self_pos j\n  have cs : 4 * lij ^ 2 ≤ 4 * (li * lj) := by\n    rw [mul_le_mul_left four_pos]\n    exact LinearMap.BilinForm.apply_sq_le_of_symm P.RootForm P.rootForm_self_non_neg\n      P.rootForm_symmetric (P.root i) (P.root j)\n  have key : 4 • lij ^ 2 = _ • (li * lj) := P.four_smul_rootForm_sq_eq_coxeterWeight_smul i j\n  simp only [nsmul_eq_mul, smul_eq_mul, Nat.cast_ofNat] at key\n  rwa [key, mul_le_mul_right (by positivity)] at cs\n\n"}
{"name":"RootPairing.instIsRootPositiveRootForm","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : LinearOrderedCommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ P.IsRootPositive P.RootForm","decl":"instance instIsRootPositiveRootForm : IsRootPositive P P.RootForm where\n  zero_lt_apply_root i := P.rootForm_root_self_pos i\n  symm := P.rootForm_symmetric\n  apply_reflection_eq := P.rootForm_reflection_reflection_apply\n\n"}
{"name":"RootPairing.coxeterWeight_mem_set_of_isCrystallographic","module":"Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁶ : Fintype ι\ninst✝⁵ : LinearOrderedCommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nP : RootPairing ι R M N\ni j : ι\ninst✝ : P.IsCrystallographic\n⊢ Membership.mem (Insert.insert 0 (Insert.insert 1 (Insert.insert 2 (Insert.insert 3 (Singleton.singleton 4))))) (P.coxeterWeight i j)","decl":"lemma coxeterWeight_mem_set_of_isCrystallographic (i j : ι) [P.IsCrystallographic] :\n    P.coxeterWeight i j ∈ ({0, 1, 2, 3, 4} : Set R) := by\n  obtain ⟨n, hcn⟩ : ∃ n : ℕ, P.coxeterWeight i j = n := by\n    have : 0 ≤ P.coxeterWeightIn ℤ i j := by\n      simpa [← P.algebraMap_coxeterWeightIn ℤ] using P.coxeterWeight_non_neg P.RootForm i j\n    obtain ⟨n, hn⟩ := Int.eq_ofNat_of_zero_le this\n    exact ⟨n, by simp [← P.algebraMap_coxeterWeightIn ℤ, hn]⟩\n  have : P.coxeterWeight i j ≤ 4 := P.coxeterWeight_le_four i j\n  simp only [hcn, mem_insert_iff, mem_singleton_iff] at this ⊢\n  norm_cast at this ⊢\n  omega\n\n"}
