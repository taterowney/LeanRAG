{"name":"WithTop.sSup_eq","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SupSet α\ns : Set (WithTop α)\nhs : Not (Membership.mem s Top.top)\nhs' : BddAbove (Set.preimage WithTop.some s)\n⊢ Eq (SupSet.sSup s) ↑(SupSet.sSup (Set.preimage WithTop.some s))","decl":"theorem WithTop.sSup_eq [SupSet α] {s : Set (WithTop α)} (hs : ⊤ ∉ s)\n    (hs' : BddAbove ((↑) ⁻¹' s : Set α)) : sSup s = ↑(sSup ((↑) ⁻¹' s) : α) :=\n  (if_neg hs).trans <| if_pos hs'\n\n"}
{"name":"WithTop.sInf_eq","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : InfSet α\ns : Set (WithTop α)\nhs : Not (HasSubset.Subset s (Singleton.singleton Top.top))\nh's : BddBelow s\n⊢ Eq (InfSet.sInf s) ↑(InfSet.sInf (Set.preimage WithTop.some s))","decl":"theorem WithTop.sInf_eq [InfSet α] {s : Set (WithTop α)} (hs : ¬s ⊆ {⊤}) (h's : BddBelow s) :\n    sInf s = ↑(sInf ((↑) ⁻¹' s) : α) :=\n  if_neg <| by simp [hs, h's]\n\n"}
{"name":"WithBot.sInf_eq","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : InfSet α\ns : Set (WithBot α)\nhs : Not (Membership.mem s Bot.bot)\nhs' : BddBelow (Set.preimage WithBot.some s)\n⊢ Eq (InfSet.sInf s) ↑(InfSet.sInf (Set.preimage WithBot.some s))","decl":"theorem WithBot.sInf_eq [InfSet α] {s : Set (WithBot α)} (hs : ⊥ ∉ s)\n    (hs' : BddBelow ((↑) ⁻¹' s : Set α)) : sInf s = ↑(sInf ((↑) ⁻¹' s) : α) :=\n  (if_neg hs).trans <| if_pos hs'\n\n"}
{"name":"WithBot.sSup_eq","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SupSet α\ns : Set (WithBot α)\nhs : Not (HasSubset.Subset s (Singleton.singleton Bot.bot))\nh's : BddAbove s\n⊢ Eq (SupSet.sSup s) ↑(SupSet.sSup (Set.preimage WithBot.some s))","decl":"theorem WithBot.sSup_eq [SupSet α] {s : Set (WithBot α)} (hs : ¬s ⊆ {⊥}) (h's : BddAbove s) :\n    sSup s = ↑(sSup ((↑) ⁻¹' s) : α) :=\n  WithTop.sInf_eq (α := αᵒᵈ) hs h's\n\n"}
{"name":"WithTop.sInf_empty","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : InfSet α\n⊢ Eq (InfSet.sInf EmptyCollection.emptyCollection) Top.top","decl":"@[simp]\ntheorem WithTop.sInf_empty [InfSet α] : sInf (∅ : Set (WithTop α)) = ⊤ :=\n  if_pos <| by simp\n\n"}
{"name":"WithTop.coe_sInf'","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : InfSet α\ns : Set α\nhs : s.Nonempty\nh's : BddBelow s\n⊢ Eq (↑(InfSet.sInf s)) (InfSet.sInf (Set.image (fun a => ↑a) s))","decl":"theorem WithTop.coe_sInf' [InfSet α] {s : Set α} (hs : s.Nonempty) (h's : BddBelow s) :\n    ↑(sInf s) = (sInf ((fun (a : α) ↦ ↑a) '' s) : WithTop α) := by\n  classical\n  obtain ⟨x, hx⟩ := hs\n  change _ = ite _ _ _\n  split_ifs with h\n  · rcases h with h1 | h2\n    · cases h1 (mem_image_of_mem _ hx)\n    · exact (h2 (Monotone.map_bddBelow coe_mono h's)).elim\n  · rw [preimage_image_eq]\n    exact Option.some_injective _\n\n"}
{"name":"WithTop.coe_sSup'","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SupSet α\ns : Set α\nhs : BddAbove s\n⊢ Eq (↑(SupSet.sSup s)) (SupSet.sSup (Set.image (fun a => ↑a) s))","decl":"theorem WithTop.coe_sSup' [SupSet α] {s : Set α} (hs : BddAbove s) :\n    ↑(sSup s) = (sSup ((fun (a : α) ↦ ↑a) '' s) : WithTop α) := by\n  classical\n  change _ = ite _ _ _\n  rw [if_neg, preimage_image_eq, if_pos hs]\n  · exact Option.some_injective _\n  · rintro ⟨x, _, ⟨⟩⟩\n\n"}
{"name":"WithBot.sSup_empty","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SupSet α\n⊢ Eq (SupSet.sSup EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem WithBot.sSup_empty [SupSet α] : sSup (∅ : Set (WithBot α)) = ⊥ :=\n  WithTop.sInf_empty (α := αᵒᵈ)\n\n"}
{"name":"WithBot.coe_sSup'","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SupSet α\ns : Set α\nhs : s.Nonempty\nh's : BddAbove s\n⊢ Eq (↑(SupSet.sSup s)) (SupSet.sSup (Set.image (fun a => ↑a) s))","decl":"@[norm_cast]\ntheorem WithBot.coe_sSup' [SupSet α] {s : Set α} (hs : s.Nonempty) (h's : BddAbove s) :\n    ↑(sSup s) = (sSup ((fun (a : α) ↦ ↑a) '' s) : WithBot α) :=\n  WithTop.coe_sInf' (α := αᵒᵈ) hs h's\n\n"}
{"name":"WithBot.coe_sInf'","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : InfSet α\ns : Set α\nhs : BddBelow s\n⊢ Eq (↑(InfSet.sInf s)) (InfSet.sInf (Set.image (fun a => ↑a) s))","decl":"@[norm_cast]\ntheorem WithBot.coe_sInf' [InfSet α] {s : Set α} (hs : BddBelow s) :\n    ↑(sInf s) = (sInf ((fun (a : α) ↦ ↑a) '' s) : WithBot α) :=\n  WithTop.coe_sSup' (α := αᵒᵈ) hs\n\n"}
{"name":"le_csSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\na : α\nh₁ : BddAbove s\nh₂ : Membership.mem s a\n⊢ LE.le a (SupSet.sSup s)","decl":"theorem le_csSup (h₁ : BddAbove s) (h₂ : a ∈ s) : a ≤ sSup s :=\n  ConditionallyCompleteLattice.le_csSup s a h₁ h₂\n\n"}
{"name":"csSup_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\na : α\nh₁ : s.Nonempty\nh₂ : ∀ (b : α), Membership.mem s b → LE.le b a\n⊢ LE.le (SupSet.sSup s) a","decl":"theorem csSup_le (h₁ : s.Nonempty) (h₂ : ∀ b ∈ s, b ≤ a) : sSup s ≤ a :=\n  ConditionallyCompleteLattice.csSup_le s a h₁ h₂\n\n"}
{"name":"csInf_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\na : α\nh₁ : BddBelow s\nh₂ : Membership.mem s a\n⊢ LE.le (InfSet.sInf s) a","decl":"theorem csInf_le (h₁ : BddBelow s) (h₂ : a ∈ s) : sInf s ≤ a :=\n  ConditionallyCompleteLattice.csInf_le s a h₁ h₂\n\n"}
{"name":"le_csInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\na : α\nh₁ : s.Nonempty\nh₂ : ∀ (b : α), Membership.mem s b → LE.le a b\n⊢ LE.le a (InfSet.sInf s)","decl":"theorem le_csInf (h₁ : s.Nonempty) (h₂ : ∀ b ∈ s, a ≤ b) : a ≤ sInf s :=\n  ConditionallyCompleteLattice.le_csInf s a h₁ h₂\n\n"}
{"name":"le_csSup_of_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\na b : α\nhs : BddAbove s\nhb : Membership.mem s b\nh : LE.le a b\n⊢ LE.le a (SupSet.sSup s)","decl":"theorem le_csSup_of_le (hs : BddAbove s) (hb : b ∈ s) (h : a ≤ b) : a ≤ sSup s :=\n  le_trans h (le_csSup hs hb)\n\n"}
{"name":"csInf_le_of_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\na b : α\nhs : BddBelow s\nhb : Membership.mem s b\nh : LE.le b a\n⊢ LE.le (InfSet.sInf s) a","decl":"theorem csInf_le_of_le (hs : BddBelow s) (hb : b ∈ s) (h : b ≤ a) : sInf s ≤ a :=\n  le_trans (csInf_le hs hb) h\n\n"}
{"name":"csSup_le_csSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns t : Set α\nht : BddAbove t\nhs : s.Nonempty\nh : HasSubset.Subset s t\n⊢ LE.le (SupSet.sSup s) (SupSet.sSup t)","decl":"theorem csSup_le_csSup (ht : BddAbove t) (hs : s.Nonempty) (h : s ⊆ t) : sSup s ≤ sSup t :=\n  csSup_le hs fun _ ha => le_csSup ht (h ha)\n\n"}
{"name":"csInf_le_csInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns t : Set α\nht : BddBelow t\nhs : s.Nonempty\nh : HasSubset.Subset s t\n⊢ LE.le (InfSet.sInf t) (InfSet.sInf s)","decl":"theorem csInf_le_csInf (ht : BddBelow t) (hs : s.Nonempty) (h : s ⊆ t) : sInf t ≤ sInf s :=\n  le_csInf hs fun _ ha => csInf_le ht (h ha)\n\n"}
{"name":"le_csSup_iff","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\na : α\nh : BddAbove s\nhs : s.Nonempty\n⊢ Iff (LE.le a (SupSet.sSup s)) (∀ (b : α), Membership.mem (upperBounds s) b → LE.le a b)","decl":"theorem le_csSup_iff (h : BddAbove s) (hs : s.Nonempty) :\n    a ≤ sSup s ↔ ∀ b, b ∈ upperBounds s → a ≤ b :=\n  ⟨fun h _ hb => le_trans h (csSup_le hs hb), fun hb => hb _ fun _ => le_csSup h⟩\n\n"}
{"name":"csInf_le_iff","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\na : α\nh : BddBelow s\nhs : s.Nonempty\n⊢ Iff (LE.le (InfSet.sInf s) a) (∀ (b : α), Membership.mem (lowerBounds s) b → LE.le b a)","decl":"theorem csInf_le_iff (h : BddBelow s) (hs : s.Nonempty) : sInf s ≤ a ↔ ∀ b ∈ lowerBounds s, b ≤ a :=\n  ⟨fun h _ hb => le_trans (le_csInf hs hb) h, fun hb => hb _ fun _ => csInf_le h⟩\n\n"}
{"name":"isLUB_csSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\nne : s.Nonempty\nH : BddAbove s\n⊢ IsLUB s (SupSet.sSup s)","decl":"theorem isLUB_csSup (ne : s.Nonempty) (H : BddAbove s) : IsLUB s (sSup s) :=\n  ⟨fun _ => le_csSup H, fun _ => csSup_le ne⟩\n\n"}
{"name":"isGLB_csInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\nne : s.Nonempty\nH : BddBelow s\n⊢ IsGLB s (InfSet.sInf s)","decl":"theorem isGLB_csInf (ne : s.Nonempty) (H : BddBelow s) : IsGLB s (sInf s) :=\n  ⟨fun _ => csInf_le H, fun _ => le_csInf ne⟩\n\n"}
{"name":"IsLUB.csSup_eq","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\na : α\nH : IsLUB s a\nne : s.Nonempty\n⊢ Eq (SupSet.sSup s) a","decl":"theorem IsLUB.csSup_eq (H : IsLUB s a) (ne : s.Nonempty) : sSup s = a :=\n  (isLUB_csSup ne ⟨a, H.1⟩).unique H\n\n"}
{"name":"IsGreatest.csSup_eq","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\na : α\nH : IsGreatest s a\n⊢ Eq (SupSet.sSup s) a","decl":"/-- A greatest element of a set is the supremum of this set. -/\ntheorem IsGreatest.csSup_eq (H : IsGreatest s a) : sSup s = a :=\n  H.isLUB.csSup_eq H.nonempty\n\n"}
{"name":"IsGreatest.csSup_mem","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\na : α\nH : IsGreatest s a\n⊢ Membership.mem s (SupSet.sSup s)","decl":"theorem IsGreatest.csSup_mem (H : IsGreatest s a) : sSup s ∈ s :=\n  H.csSup_eq.symm ▸ H.1\n\n"}
{"name":"IsGLB.csInf_eq","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\na : α\nH : IsGLB s a\nne : s.Nonempty\n⊢ Eq (InfSet.sInf s) a","decl":"theorem IsGLB.csInf_eq (H : IsGLB s a) (ne : s.Nonempty) : sInf s = a :=\n  (isGLB_csInf ne ⟨a, H.1⟩).unique H\n\n"}
{"name":"IsLeast.csInf_eq","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\na : α\nH : IsLeast s a\n⊢ Eq (InfSet.sInf s) a","decl":"/-- A least element of a set is the infimum of this set. -/\ntheorem IsLeast.csInf_eq (H : IsLeast s a) : sInf s = a :=\n  H.isGLB.csInf_eq H.nonempty\n\n"}
{"name":"IsLeast.csInf_mem","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\na : α\nH : IsLeast s a\n⊢ Membership.mem s (InfSet.sInf s)","decl":"theorem IsLeast.csInf_mem (H : IsLeast s a) : sInf s ∈ s :=\n  H.csInf_eq.symm ▸ H.1\n\n"}
{"name":"subset_Icc_csInf_csSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\nhb : BddBelow s\nha : BddAbove s\n⊢ HasSubset.Subset s (Set.Icc (InfSet.sInf s) (SupSet.sSup s))","decl":"theorem subset_Icc_csInf_csSup (hb : BddBelow s) (ha : BddAbove s) : s ⊆ Icc (sInf s) (sSup s) :=\n  fun _ hx => ⟨csInf_le hb hx, le_csSup ha hx⟩\n\n"}
{"name":"csSup_le_iff","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\na : α\nhb : BddAbove s\nhs : s.Nonempty\n⊢ Iff (LE.le (SupSet.sSup s) a) (∀ (b : α), Membership.mem s b → LE.le b a)","decl":"theorem csSup_le_iff (hb : BddAbove s) (hs : s.Nonempty) : sSup s ≤ a ↔ ∀ b ∈ s, b ≤ a :=\n  isLUB_le_iff (isLUB_csSup hs hb)\n\n"}
{"name":"le_csInf_iff","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\na : α\nhb : BddBelow s\nhs : s.Nonempty\n⊢ Iff (LE.le a (InfSet.sInf s)) (∀ (b : α), Membership.mem s b → LE.le a b)","decl":"theorem le_csInf_iff (hb : BddBelow s) (hs : s.Nonempty) : a ≤ sInf s ↔ ∀ b ∈ s, a ≤ b :=\n  le_isGLB_iff (isGLB_csInf hs hb)\n\n"}
{"name":"csSup_lowerBounds_eq_csInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\nh : BddBelow s\nhs : s.Nonempty\n⊢ Eq (SupSet.sSup (lowerBounds s)) (InfSet.sInf s)","decl":"theorem csSup_lowerBounds_eq_csInf {s : Set α} (h : BddBelow s) (hs : s.Nonempty) :\n    sSup (lowerBounds s) = sInf s :=\n  (isLUB_csSup h <| hs.mono fun _ hx _ hy => hy hx).unique (isGLB_csInf hs h).isLUB\n\n"}
{"name":"csInf_upperBounds_eq_csSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\nh : BddAbove s\nhs : s.Nonempty\n⊢ Eq (InfSet.sInf (upperBounds s)) (SupSet.sSup s)","decl":"theorem csInf_upperBounds_eq_csSup {s : Set α} (h : BddAbove s) (hs : s.Nonempty) :\n    sInf (upperBounds s) = sSup s :=\n  (isGLB_csInf h <| hs.mono fun _ hx _ hy => hy hx).unique (isLUB_csSup hs h).isGLB\n\n"}
{"name":"csSup_lower_bounds_eq_csInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\nh : BddBelow s\nhs : s.Nonempty\n⊢ Eq (SupSet.sSup (lowerBounds s)) (InfSet.sInf s)","decl":"@[deprecated (since := \"2024-08-25\")]\nalias csSup_lower_bounds_eq_csInf := csSup_lowerBounds_eq_csInf\n\n"}
{"name":"csInf_upper_bounds_eq_csSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\nh : BddAbove s\nhs : s.Nonempty\n⊢ Eq (InfSet.sInf (upperBounds s)) (SupSet.sSup s)","decl":"@[deprecated (since := \"2024-08-25\")]\nalias csInf_upper_bounds_eq_csSup := csInf_upperBounds_eq_csSup\n\n"}
{"name":"csSup_lowerBounds_range","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : Nonempty β\nf : β → α\nhf : BddBelow (Set.range f)\n⊢ Eq (SupSet.sSup (lowerBounds (Set.range f))) (iInf fun i => f i)","decl":"theorem csSup_lowerBounds_range [Nonempty β] {f : β → α} (hf : BddBelow (range f)) :\n    sSup (lowerBounds (range f)) = ⨅ i, f i :=\n  csSup_lowerBounds_eq_csInf hf <| range_nonempty _\n\n"}
{"name":"csInf_upperBounds_range","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : Nonempty β\nf : β → α\nhf : BddAbove (Set.range f)\n⊢ Eq (InfSet.sInf (upperBounds (Set.range f))) (iSup fun i => f i)","decl":"theorem csInf_upperBounds_range [Nonempty β] {f : β → α} (hf : BddAbove (range f)) :\n    sInf (upperBounds (range f)) = ⨆ i, f i :=\n  csInf_upperBounds_eq_csSup hf <| range_nonempty _\n\n"}
{"name":"not_mem_of_lt_csInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\nx : α\ns : Set α\nh : LT.lt x (InfSet.sInf s)\nhs : BddBelow s\n⊢ Not (Membership.mem s x)","decl":"theorem not_mem_of_lt_csInf {x : α} {s : Set α} (h : x < sInf s) (hs : BddBelow s) : x ∉ s :=\n  fun hx => lt_irrefl _ (h.trans_le (csInf_le hs hx))\n\n"}
{"name":"not_mem_of_csSup_lt","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\nx : α\ns : Set α\nh : LT.lt (SupSet.sSup s) x\nhs : BddAbove s\n⊢ Not (Membership.mem s x)","decl":"theorem not_mem_of_csSup_lt {x : α} {s : Set α} (h : sSup s < x) (hs : BddAbove s) : x ∉ s :=\n  not_mem_of_lt_csInf (α := αᵒᵈ) h hs\n\n"}
{"name":"csSup_eq_of_forall_le_of_forall_lt_exists_gt","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\nb : α\nhs : s.Nonempty\nH : ∀ (a : α), Membership.mem s a → LE.le a b\nH' : ∀ (w : α), LT.lt w b → Exists fun a => And (Membership.mem s a) (LT.lt w a)\n⊢ Eq (SupSet.sSup s) b","decl":"/-- Introduction rule to prove that `b` is the supremum of `s`: it suffices to check that `b`\nis larger than all elements of `s`, and that this is not the case of any `w<b`.\nSee `sSup_eq_of_forall_le_of_forall_lt_exists_gt` for a version in complete lattices. -/\ntheorem csSup_eq_of_forall_le_of_forall_lt_exists_gt (hs : s.Nonempty) (H : ∀ a ∈ s, a ≤ b)\n    (H' : ∀ w, w < b → ∃ a ∈ s, w < a) : sSup s = b :=\n  (eq_of_le_of_not_lt (csSup_le hs H)) fun hb =>\n    let ⟨_, ha, ha'⟩ := H' _ hb\n    lt_irrefl _ <| ha'.trans_le <| le_csSup ⟨b, H⟩ ha\n\n"}
{"name":"csInf_eq_of_forall_ge_of_forall_gt_exists_lt","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\nb : α\na✝² : s.Nonempty\na✝¹ : ∀ (a : α), Membership.mem s a → LE.le b a\na✝ : ∀ (w : α), LT.lt b w → Exists fun a => And (Membership.mem s a) (LT.lt a w)\n⊢ Eq (InfSet.sInf s) b","decl":"/-- Introduction rule to prove that `b` is the infimum of `s`: it suffices to check that `b`\nis smaller than all elements of `s`, and that this is not the case of any `w>b`.\nSee `sInf_eq_of_forall_ge_of_forall_gt_exists_lt` for a version in complete lattices. -/\ntheorem csInf_eq_of_forall_ge_of_forall_gt_exists_lt :\n    s.Nonempty → (∀ a ∈ s, b ≤ a) → (∀ w, b < w → ∃ a ∈ s, a < w) → sInf s = b :=\n  csSup_eq_of_forall_le_of_forall_lt_exists_gt (α := αᵒᵈ)\n\n"}
{"name":"lt_csSup_of_lt","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\na b : α\nhs : BddAbove s\nha : Membership.mem s a\nh : LT.lt b a\n⊢ LT.lt b (SupSet.sSup s)","decl":"/-- `b < sSup s` when there is an element `a` in `s` with `b < a`, when `s` is bounded above.\nThis is essentially an iff, except that the assumptions for the two implications are\nslightly different (one needs boundedness above for one direction, nonemptiness and linear\norder for the other one), so we formulate separately the two implications, contrary to\nthe `CompleteLattice` case. -/\ntheorem lt_csSup_of_lt (hs : BddAbove s) (ha : a ∈ s) (h : b < a) : b < sSup s :=\n  lt_of_lt_of_le h (le_csSup hs ha)\n\n"}
{"name":"csInf_lt_of_lt","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\na b : α\na✝² : BddBelow s\na✝¹ : Membership.mem s a\na✝ : LT.lt a b\n⊢ LT.lt (InfSet.sInf s) b","decl":"/-- `sInf s < b` when there is an element `a` in `s` with `a < b`, when `s` is bounded below.\nThis is essentially an iff, except that the assumptions for the two implications are\nslightly different (one needs boundedness below for one direction, nonemptiness and linear\norder for the other one), so we formulate separately the two implications, contrary to\nthe `CompleteLattice` case. -/\ntheorem csInf_lt_of_lt : BddBelow s → a ∈ s → a < b → sInf s < b :=\n  lt_csSup_of_lt (α := αᵒᵈ)\n\n"}
{"name":"exists_between_of_forall_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns t : Set α\nsne : s.Nonempty\ntne : t.Nonempty\nhst : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem t y → LE.le x y\n⊢ (Inter.inter (upperBounds s) (lowerBounds t)).Nonempty","decl":"/-- If all elements of a nonempty set `s` are less than or equal to all elements\nof a nonempty set `t`, then there exists an element between these sets. -/\ntheorem exists_between_of_forall_le (sne : s.Nonempty) (tne : t.Nonempty)\n    (hst : ∀ x ∈ s, ∀ y ∈ t, x ≤ y) : (upperBounds s ∩ lowerBounds t).Nonempty :=\n  ⟨sInf t, fun x hx => le_csInf tne <| hst x hx, fun _ hy => csInf_le (sne.mono hst) hy⟩\n\n"}
{"name":"csSup_singleton","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\na : α\n⊢ Eq (SupSet.sSup (Singleton.singleton a)) a","decl":"/-- The supremum of a singleton is the element of the singleton -/\n@[simp]\ntheorem csSup_singleton (a : α) : sSup {a} = a :=\n  isGreatest_singleton.csSup_eq\n\n"}
{"name":"csInf_singleton","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\na : α\n⊢ Eq (InfSet.sInf (Singleton.singleton a)) a","decl":"/-- The infimum of a singleton is the element of the singleton -/\n@[simp]\ntheorem csInf_singleton (a : α) : sInf {a} = a :=\n  isLeast_singleton.csInf_eq\n\n"}
{"name":"csSup_pair","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\na b : α\n⊢ Eq (SupSet.sSup (Insert.insert a (Singleton.singleton b))) (Max.max a b)","decl":"theorem csSup_pair (a b : α) : sSup {a, b} = a ⊔ b :=\n  (@isLUB_pair _ _ a b).csSup_eq (insert_nonempty _ _)\n\n"}
{"name":"csInf_pair","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\na b : α\n⊢ Eq (InfSet.sInf (Insert.insert a (Singleton.singleton b))) (Min.min a b)","decl":"theorem csInf_pair (a b : α) : sInf {a, b} = a ⊓ b :=\n  (@isGLB_pair _ _ a b).csInf_eq (insert_nonempty _ _)\n\n"}
{"name":"csInf_le_csSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\nhb : BddBelow s\nha : BddAbove s\nne : s.Nonempty\n⊢ LE.le (InfSet.sInf s) (SupSet.sSup s)","decl":"/-- If a set is bounded below and above, and nonempty, its infimum is less than or equal to\nits supremum. -/\ntheorem csInf_le_csSup (hb : BddBelow s) (ha : BddAbove s) (ne : s.Nonempty) : sInf s ≤ sSup s :=\n  isGLB_le_isLUB (isGLB_csInf ne hb) (isLUB_csSup ne ha) ne\n\n"}
{"name":"csSup_union","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns t : Set α\nhs : BddAbove s\nsne : s.Nonempty\nht : BddAbove t\ntne : t.Nonempty\n⊢ Eq (SupSet.sSup (Union.union s t)) (Max.max (SupSet.sSup s) (SupSet.sSup t))","decl":"/-- The `sSup` of a union of two sets is the max of the suprema of each subset, under the\nassumptions that all sets are bounded above and nonempty. -/\ntheorem csSup_union (hs : BddAbove s) (sne : s.Nonempty) (ht : BddAbove t) (tne : t.Nonempty) :\n    sSup (s ∪ t) = sSup s ⊔ sSup t :=\n  ((isLUB_csSup sne hs).union (isLUB_csSup tne ht)).csSup_eq sne.inl\n\n"}
{"name":"csInf_union","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns t : Set α\nhs : BddBelow s\nsne : s.Nonempty\nht : BddBelow t\ntne : t.Nonempty\n⊢ Eq (InfSet.sInf (Union.union s t)) (Min.min (InfSet.sInf s) (InfSet.sInf t))","decl":"/-- The `sInf` of a union of two sets is the min of the infima of each subset, under the assumptions\nthat all sets are bounded below and nonempty. -/\ntheorem csInf_union (hs : BddBelow s) (sne : s.Nonempty) (ht : BddBelow t) (tne : t.Nonempty) :\n    sInf (s ∪ t) = sInf s ⊓ sInf t :=\n  csSup_union (α := αᵒᵈ) hs sne ht tne\n\n"}
{"name":"csSup_inter_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns t : Set α\nhs : BddAbove s\nht : BddAbove t\nhst : (Inter.inter s t).Nonempty\n⊢ LE.le (SupSet.sSup (Inter.inter s t)) (Min.min (SupSet.sSup s) (SupSet.sSup t))","decl":"/-- The supremum of an intersection of two sets is bounded by the minimum of the suprema of each\nset, if all sets are bounded above and nonempty. -/\ntheorem csSup_inter_le (hs : BddAbove s) (ht : BddAbove t) (hst : (s ∩ t).Nonempty) :\n    sSup (s ∩ t) ≤ sSup s ⊓ sSup t :=\n  (csSup_le hst) fun _ hx => le_inf (le_csSup hs hx.1) (le_csSup ht hx.2)\n\n"}
{"name":"le_csInf_inter","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns t : Set α\na✝² : BddBelow s\na✝¹ : BddBelow t\na✝ : (Inter.inter s t).Nonempty\n⊢ LE.le (Max.max (InfSet.sInf s) (InfSet.sInf t)) (InfSet.sInf (Inter.inter s t))","decl":"/-- The infimum of an intersection of two sets is bounded below by the maximum of the\ninfima of each set, if all sets are bounded below and nonempty. -/\ntheorem le_csInf_inter :\n    BddBelow s → BddBelow t → (s ∩ t).Nonempty → sInf s ⊔ sInf t ≤ sInf (s ∩ t) :=\n  csSup_inter_le (α := αᵒᵈ)\n\n"}
{"name":"csSup_insert","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\na : α\nhs : BddAbove s\nsne : s.Nonempty\n⊢ Eq (SupSet.sSup (Insert.insert a s)) (Max.max a (SupSet.sSup s))","decl":"/-- The supremum of `insert a s` is the maximum of `a` and the supremum of `s`, if `s` is\nnonempty and bounded above. -/\n@[simp]\ntheorem csSup_insert (hs : BddAbove s) (sne : s.Nonempty) : sSup (insert a s) = a ⊔ sSup s :=\n  ((isLUB_csSup sne hs).insert a).csSup_eq (insert_nonempty a s)\n\n"}
{"name":"csInf_insert","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\na : α\nhs : BddBelow s\nsne : s.Nonempty\n⊢ Eq (InfSet.sInf (Insert.insert a s)) (Min.min a (InfSet.sInf s))","decl":"/-- The infimum of `insert a s` is the minimum of `a` and the infimum of `s`, if `s` is\nnonempty and bounded below. -/\n@[simp]\ntheorem csInf_insert (hs : BddBelow s) (sne : s.Nonempty) : sInf (insert a s) = a ⊓ sInf s :=\n  csSup_insert (α := αᵒᵈ) hs sne\n\n"}
{"name":"csInf_Icc","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\na b : α\nh : LE.le a b\n⊢ Eq (InfSet.sInf (Set.Icc a b)) a","decl":"@[simp]\ntheorem csInf_Icc (h : a ≤ b) : sInf (Icc a b) = a :=\n  (isGLB_Icc h).csInf_eq (nonempty_Icc.2 h)\n\n"}
{"name":"csInf_Ici","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\na : α\n⊢ Eq (InfSet.sInf (Set.Ici a)) a","decl":"@[simp]\ntheorem csInf_Ici : sInf (Ici a) = a :=\n  isLeast_Ici.csInf_eq\n\n"}
{"name":"csInf_Ico","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\na b : α\nh : LT.lt a b\n⊢ Eq (InfSet.sInf (Set.Ico a b)) a","decl":"@[simp]\ntheorem csInf_Ico (h : a < b) : sInf (Ico a b) = a :=\n  (isGLB_Ico h).csInf_eq (nonempty_Ico.2 h)\n\n"}
{"name":"csInf_Ioc","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : ConditionallyCompleteLattice α\na b : α\ninst✝ : DenselyOrdered α\nh : LT.lt a b\n⊢ Eq (InfSet.sInf (Set.Ioc a b)) a","decl":"@[simp]\ntheorem csInf_Ioc [DenselyOrdered α] (h : a < b) : sInf (Ioc a b) = a :=\n  (isGLB_Ioc h).csInf_eq (nonempty_Ioc.2 h)\n\n"}
{"name":"csInf_Ioi","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝² : ConditionallyCompleteLattice α\na : α\ninst✝¹ : NoMaxOrder α\ninst✝ : DenselyOrdered α\n⊢ Eq (InfSet.sInf (Set.Ioi a)) a","decl":"@[simp]\ntheorem csInf_Ioi [NoMaxOrder α] [DenselyOrdered α] : sInf (Ioi a) = a :=\n  csInf_eq_of_forall_ge_of_forall_gt_exists_lt nonempty_Ioi (fun _ => le_of_lt) fun w hw => by\n    simpa using exists_between hw\n\n"}
{"name":"csInf_Ioo","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : ConditionallyCompleteLattice α\na b : α\ninst✝ : DenselyOrdered α\nh : LT.lt a b\n⊢ Eq (InfSet.sInf (Set.Ioo a b)) a","decl":"@[simp]\ntheorem csInf_Ioo [DenselyOrdered α] (h : a < b) : sInf (Ioo a b) = a :=\n  (isGLB_Ioo h).csInf_eq (nonempty_Ioo.2 h)\n\n"}
{"name":"csSup_Icc","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\na b : α\nh : LE.le a b\n⊢ Eq (SupSet.sSup (Set.Icc a b)) b","decl":"@[simp]\ntheorem csSup_Icc (h : a ≤ b) : sSup (Icc a b) = b :=\n  (isLUB_Icc h).csSup_eq (nonempty_Icc.2 h)\n\n"}
{"name":"csSup_Ico","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : ConditionallyCompleteLattice α\na b : α\ninst✝ : DenselyOrdered α\nh : LT.lt a b\n⊢ Eq (SupSet.sSup (Set.Ico a b)) b","decl":"@[simp]\ntheorem csSup_Ico [DenselyOrdered α] (h : a < b) : sSup (Ico a b) = b :=\n  (isLUB_Ico h).csSup_eq (nonempty_Ico.2 h)\n\n"}
{"name":"csSup_Iic","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\na : α\n⊢ Eq (SupSet.sSup (Set.Iic a)) a","decl":"@[simp]\ntheorem csSup_Iic : sSup (Iic a) = a :=\n  isGreatest_Iic.csSup_eq\n\n"}
{"name":"csSup_Iio","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝² : ConditionallyCompleteLattice α\na : α\ninst✝¹ : NoMinOrder α\ninst✝ : DenselyOrdered α\n⊢ Eq (SupSet.sSup (Set.Iio a)) a","decl":"@[simp]\ntheorem csSup_Iio [NoMinOrder α] [DenselyOrdered α] : sSup (Iio a) = a :=\n  csSup_eq_of_forall_le_of_forall_lt_exists_gt nonempty_Iio (fun _ => le_of_lt) fun w hw => by\n    simpa [and_comm] using exists_between hw\n\n"}
{"name":"csSup_Ioc","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\na b : α\nh : LT.lt a b\n⊢ Eq (SupSet.sSup (Set.Ioc a b)) b","decl":"@[simp]\ntheorem csSup_Ioc (h : a < b) : sSup (Ioc a b) = b :=\n  (isLUB_Ioc h).csSup_eq (nonempty_Ioc.2 h)\n\n"}
{"name":"csSup_Ioo","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : ConditionallyCompleteLattice α\na b : α\ninst✝ : DenselyOrdered α\nh : LT.lt a b\n⊢ Eq (SupSet.sSup (Set.Ioo a b)) b","decl":"@[simp]\ntheorem csSup_Ioo [DenselyOrdered α] (h : a < b) : sSup (Ioo a b) = b :=\n  (isLUB_Ioo h).csSup_eq (nonempty_Ioo.2 h)\n\n"}
{"name":"csSup_eq_of_is_forall_le_of_forall_le_imp_ge","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\nb : α\nhs : s.Nonempty\nh_is_ub : ∀ (a : α), Membership.mem s a → LE.le a b\nh_b_le_ub : ∀ (ub : α), (∀ (a : α), Membership.mem s a → LE.le a ub) → LE.le b ub\n⊢ Eq (SupSet.sSup s) b","decl":"/-- Introduction rule to prove that `b` is the supremum of `s`: it suffices to check that\n1) `b` is an upper bound\n2) every other upper bound `b'` satisfies `b ≤ b'`. -/\ntheorem csSup_eq_of_is_forall_le_of_forall_le_imp_ge (hs : s.Nonempty) (h_is_ub : ∀ a ∈ s, a ≤ b)\n    (h_b_le_ub : ∀ ub, (∀ a ∈ s, a ≤ ub) → b ≤ ub) : sSup s = b :=\n  (csSup_le hs h_is_ub).antisymm ((h_b_le_ub _) fun _ => le_csSup ⟨b, h_is_ub⟩)\n\n"}
{"name":"sup_eq_top_of_top_mem","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : ConditionallyCompleteLattice α\ns : Set α\ninst✝ : OrderTop α\nh : Membership.mem s Top.top\n⊢ Eq (SupSet.sSup s) Top.top","decl":"lemma sup_eq_top_of_top_mem [OrderTop α] (h : ⊤ ∈ s) : sSup s = ⊤ :=\n  top_unique <| le_csSup (OrderTop.bddAbove s) h\n\n"}
{"name":"inf_eq_bot_of_bot_mem","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : ConditionallyCompleteLattice α\ns : Set α\ninst✝ : OrderBot α\nh : Membership.mem s Bot.bot\n⊢ Eq (InfSet.sInf s) Bot.bot","decl":"lemma inf_eq_bot_of_bot_mem [OrderBot α] (h : ⊥ ∈ s) : sInf s = ⊥ :=\n  bot_unique <| csInf_le (OrderBot.bddBelow s) h\n\n"}
{"name":"exists_lt_of_lt_csSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrder α\ns : Set α\nb : α\nhs : s.Nonempty\nhb : LT.lt b (SupSet.sSup s)\n⊢ Exists fun a => And (Membership.mem s a) (LT.lt b a)","decl":"/-- When `b < sSup s`, there is an element `a` in `s` with `b < a`, if `s` is nonempty and the order\nis a linear order. -/\ntheorem exists_lt_of_lt_csSup (hs : s.Nonempty) (hb : b < sSup s) : ∃ a ∈ s, b < a := by\n  contrapose! hb\n  exact csSup_le hs hb\n\n"}
{"name":"exists_lt_of_csInf_lt","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrder α\ns : Set α\nb : α\nhs : s.Nonempty\nhb : LT.lt (InfSet.sInf s) b\n⊢ Exists fun a => And (Membership.mem s a) (LT.lt a b)","decl":"/-- When `sInf s < b`, there is an element `a` in `s` with `a < b`, if `s` is nonempty and the order\nis a linear order. -/\ntheorem exists_lt_of_csInf_lt (hs : s.Nonempty) (hb : sInf s < b) : ∃ a ∈ s, a < b :=\n  exists_lt_of_lt_csSup (α := αᵒᵈ) hs hb\n\n"}
{"name":"lt_csSup_iff","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrder α\ns : Set α\na : α\nhb : BddAbove s\nhs : s.Nonempty\n⊢ Iff (LT.lt a (SupSet.sSup s)) (Exists fun b => And (Membership.mem s b) (LT.lt a b))","decl":"theorem lt_csSup_iff (hb : BddAbove s) (hs : s.Nonempty) : a < sSup s ↔ ∃ b ∈ s, a < b := by\n  simpa only [not_le, not_forall₂, exists_prop] using (csSup_le_iff hb hs (a := a)).not\n\n"}
{"name":"csInf_lt_iff","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrder α\ns : Set α\na : α\nhb : BddBelow s\nhs : s.Nonempty\n⊢ Iff (LT.lt (InfSet.sInf s) a) (Exists fun b => And (Membership.mem s b) (LT.lt b a))","decl":"theorem csInf_lt_iff (hb : BddBelow s) (hs : s.Nonempty) : sInf s < a ↔ ∃ b ∈ s, b < a := by\n  simpa only [not_le, not_forall₂, exists_prop] using (le_csInf_iff hb hs).not\n\n"}
{"name":"csSup_of_not_bddAbove","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrder α\ns : Set α\nhs : Not (BddAbove s)\n⊢ Eq (SupSet.sSup s) (SupSet.sSup EmptyCollection.emptyCollection)","decl":"theorem csSup_of_not_bddAbove {s : Set α} (hs : ¬BddAbove s) : sSup s = sSup ∅ :=\n  ConditionallyCompleteLinearOrder.csSup_of_not_bddAbove s hs\n\n"}
{"name":"csSup_eq_univ_of_not_bddAbove","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrder α\ns : Set α\nhs : Not (BddAbove s)\n⊢ Eq (SupSet.sSup s) (SupSet.sSup Set.univ)","decl":"theorem csSup_eq_univ_of_not_bddAbove {s : Set α} (hs : ¬BddAbove s) : sSup s = sSup univ := by\n  rw [csSup_of_not_bddAbove hs, csSup_of_not_bddAbove (s := univ)]\n  contrapose! hs\n  exact hs.mono (subset_univ _)\n\n"}
{"name":"csInf_of_not_bddBelow","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrder α\ns : Set α\nhs : Not (BddBelow s)\n⊢ Eq (InfSet.sInf s) (InfSet.sInf EmptyCollection.emptyCollection)","decl":"theorem csInf_of_not_bddBelow {s : Set α} (hs : ¬BddBelow s) : sInf s = sInf ∅ :=\n  ConditionallyCompleteLinearOrder.csInf_of_not_bddBelow s hs\n\n"}
{"name":"csInf_eq_univ_of_not_bddBelow","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrder α\ns : Set α\nhs : Not (BddBelow s)\n⊢ Eq (InfSet.sInf s) (InfSet.sInf Set.univ)","decl":"theorem csInf_eq_univ_of_not_bddBelow {s : Set α} (hs : ¬BddBelow s) : sInf s = sInf univ :=\n  csSup_eq_univ_of_not_bddAbove (α := αᵒᵈ) hs\n\n"}
{"name":"csSup_eq_csSup_of_forall_exists_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrder α\ns t : Set α\nhs : ∀ (x : α), Membership.mem s x → Exists fun y => And (Membership.mem t y) (LE.le x y)\nht : ∀ (y : α), Membership.mem t y → Exists fun x => And (Membership.mem s x) (LE.le y x)\n⊢ Eq (SupSet.sSup s) (SupSet.sSup t)","decl":"/-- When every element of a set `s` is bounded by an element of a set `t`, and conversely, then\n`s` and `t` have the same supremum. This holds even when the sets may be empty or unbounded. -/\ntheorem csSup_eq_csSup_of_forall_exists_le {s t : Set α}\n    (hs : ∀ x ∈ s, ∃ y ∈ t, x ≤ y) (ht : ∀ y ∈ t, ∃ x ∈ s, y ≤ x) :\n    sSup s = sSup t := by\n  rcases eq_empty_or_nonempty s with rfl|s_ne\n  · have : t = ∅ := eq_empty_of_forall_not_mem (fun y yt ↦ by simpa using ht y yt)\n    rw [this]\n  rcases eq_empty_or_nonempty t with rfl|t_ne\n  · have : s = ∅ := eq_empty_of_forall_not_mem (fun x xs ↦ by simpa using hs x xs)\n    rw [this]\n  by_cases B : BddAbove s ∨ BddAbove t\n  · have Bs : BddAbove s := by\n      rcases B with hB|⟨b, hb⟩\n      · exact hB\n      · refine ⟨b, fun x hx ↦ ?_⟩\n        rcases hs x hx with ⟨y, hy, hxy⟩\n        exact hxy.trans (hb hy)\n    have Bt : BddAbove t := by\n      rcases B with ⟨b, hb⟩|hB\n      · refine ⟨b, fun y hy ↦ ?_⟩\n        rcases ht y hy with ⟨x, hx, hyx⟩\n        exact hyx.trans (hb hx)\n      · exact hB\n    apply le_antisymm\n    · apply csSup_le s_ne (fun x hx ↦ ?_)\n      rcases hs x hx with ⟨y, yt, hxy⟩\n      exact hxy.trans (le_csSup Bt yt)\n    · apply csSup_le t_ne (fun y hy ↦ ?_)\n      rcases ht y hy with ⟨x, xs, hyx⟩\n      exact hyx.trans (le_csSup Bs xs)\n  · simp [csSup_of_not_bddAbove, (not_or.1 B).1, (not_or.1 B).2]\n\n"}
{"name":"csInf_eq_csInf_of_forall_exists_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrder α\ns t : Set α\nhs : ∀ (x : α), Membership.mem s x → Exists fun y => And (Membership.mem t y) (LE.le y x)\nht : ∀ (y : α), Membership.mem t y → Exists fun x => And (Membership.mem s x) (LE.le x y)\n⊢ Eq (InfSet.sInf s) (InfSet.sInf t)","decl":"/-- When every element of a set `s` is bounded by an element of a set `t`, and conversely, then\n`s` and `t` have the same infimum. This holds even when the sets may be empty or unbounded. -/\ntheorem csInf_eq_csInf_of_forall_exists_le {s t : Set α}\n    (hs : ∀ x ∈ s, ∃ y ∈ t, y ≤ x) (ht : ∀ y ∈ t, ∃ x ∈ s, x ≤ y) :\n    sInf s = sInf t :=\n  csSup_eq_csSup_of_forall_exists_le (α := αᵒᵈ) hs ht\n\n"}
{"name":"sSup_iUnion_Iic","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLinearOrder α\nf : ι → α\n⊢ Eq (SupSet.sSup (Set.iUnion fun i => Set.Iic (f i))) (iSup fun i => f i)","decl":"lemma sSup_iUnion_Iic (f : ι → α) : sSup (⋃ (i : ι), Iic (f i)) = ⨆ i, f i := by\n  apply csSup_eq_csSup_of_forall_exists_le\n  · rintro x ⟨-, ⟨i, rfl⟩, hi⟩\n    exact ⟨f i, mem_range_self _, hi⟩\n  · rintro x ⟨i, rfl⟩\n    exact ⟨f i, mem_iUnion_of_mem i le_rfl, le_rfl⟩\n\n"}
{"name":"sInf_iUnion_Ici","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLinearOrder α\nf : ι → α\n⊢ Eq (InfSet.sInf (Set.iUnion fun i => Set.Ici (f i))) (iInf fun i => f i)","decl":"lemma sInf_iUnion_Ici (f : ι → α) : sInf (⋃ (i : ι), Ici (f i)) = ⨅ i, f i :=\n  sSup_iUnion_Iic (α := αᵒᵈ) f\n\n"}
{"name":"csInf_eq_bot_of_bot_mem","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : ConditionallyCompleteLinearOrder α\ninst✝ : OrderBot α\ns : Set α\nhs : Membership.mem s Bot.bot\n⊢ Eq (InfSet.sInf s) Bot.bot","decl":"theorem csInf_eq_bot_of_bot_mem [OrderBot α] {s : Set α} (hs : ⊥ ∈ s) : sInf s = ⊥ :=\n  eq_bot_iff.2 <| csInf_le (OrderBot.bddBelow s) hs\n\n"}
{"name":"csSup_eq_top_of_top_mem","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : ConditionallyCompleteLinearOrder α\ninst✝ : OrderTop α\ns : Set α\nhs : Membership.mem s Top.top\n⊢ Eq (SupSet.sSup s) Top.top","decl":"theorem csSup_eq_top_of_top_mem [OrderTop α] {s : Set α} (hs : ⊤ ∈ s) : sSup s = ⊤ :=\n  csInf_eq_bot_of_bot_mem (α := αᵒᵈ) hs\n\n"}
{"name":"sInf_eq_argmin_on","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : ConditionallyCompleteLinearOrder α\ns : Set α\ninst✝ : WellFoundedLT α\nhs : s.Nonempty\n⊢ Eq (InfSet.sInf s) (Function.argminOn id s hs)","decl":"theorem sInf_eq_argmin_on (hs : s.Nonempty) : sInf s = argminOn id s hs :=\n  IsLeast.csInf_eq ⟨argminOn_mem _ _ _, fun _ ha => argminOn_le id _ ha⟩\n\n"}
{"name":"isLeast_csInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : ConditionallyCompleteLinearOrder α\ns : Set α\ninst✝ : WellFoundedLT α\nhs : s.Nonempty\n⊢ IsLeast s (InfSet.sInf s)","decl":"theorem isLeast_csInf (hs : s.Nonempty) : IsLeast s (sInf s) := by\n  rw [sInf_eq_argmin_on hs]\n  exact ⟨argminOn_mem _ _ _, fun a ha => argminOn_le id _ ha⟩\n\n"}
{"name":"le_csInf_iff'","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : ConditionallyCompleteLinearOrder α\ns : Set α\nb : α\ninst✝ : WellFoundedLT α\nhs : s.Nonempty\n⊢ Iff (LE.le b (InfSet.sInf s)) (Membership.mem (lowerBounds s) b)","decl":"theorem le_csInf_iff' (hs : s.Nonempty) : b ≤ sInf s ↔ b ∈ lowerBounds s :=\n  le_isGLB_iff (isLeast_csInf hs).isGLB\n\n"}
{"name":"csInf_mem","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : ConditionallyCompleteLinearOrder α\ns : Set α\ninst✝ : WellFoundedLT α\nhs : s.Nonempty\n⊢ Membership.mem s (InfSet.sInf s)","decl":"theorem csInf_mem (hs : s.Nonempty) : sInf s ∈ s :=\n  (isLeast_csInf hs).1\n\n"}
{"name":"MonotoneOn.map_csInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝² : ConditionallyCompleteLinearOrder α\ns : Set α\ninst✝¹ : WellFoundedLT α\nβ : Type u_5\ninst✝ : ConditionallyCompleteLattice β\nf : α → β\nhf : MonotoneOn f s\nhs : s.Nonempty\n⊢ Eq (f (InfSet.sInf s)) (InfSet.sInf (Set.image f s))","decl":"theorem MonotoneOn.map_csInf {β : Type*} [ConditionallyCompleteLattice β] {f : α → β}\n    (hf : MonotoneOn f s) (hs : s.Nonempty) : f (sInf s) = sInf (f '' s) :=\n  (hf.map_isLeast (isLeast_csInf hs)).csInf_eq.symm\n\n"}
{"name":"Monotone.map_csInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝² : ConditionallyCompleteLinearOrder α\ns : Set α\ninst✝¹ : WellFoundedLT α\nβ : Type u_5\ninst✝ : ConditionallyCompleteLattice β\nf : α → β\nhf : Monotone f\nhs : s.Nonempty\n⊢ Eq (f (InfSet.sInf s)) (InfSet.sInf (Set.image f s))","decl":"theorem Monotone.map_csInf {β : Type*} [ConditionallyCompleteLattice β] {f : α → β}\n    (hf : Monotone f) (hs : s.Nonempty) : f (sInf s) = sInf (f '' s) :=\n  (hf.map_isLeast (isLeast_csInf hs)).csInf_eq.symm\n\n"}
{"name":"csInf_univ","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝¹ : ConditionallyCompleteLinearOrder α\ninst✝ : OrderBot α\n⊢ Eq (InfSet.sInf Set.univ) Bot.bot","decl":"@[simp]\ntheorem csInf_univ [ConditionallyCompleteLinearOrder α] [OrderBot α] : sInf (univ : Set α) = ⊥ :=\n  isLeast_univ.csInf_eq\n\n"}
{"name":"csSup_empty","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrderBot α\n⊢ Eq (SupSet.sSup EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem csSup_empty : (sSup ∅ : α) = ⊥ :=\n  ConditionallyCompleteLinearOrderBot.csSup_empty\n\n"}
{"name":"isLUB_csSup'","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrderBot α\ns : Set α\nhs : BddAbove s\n⊢ IsLUB s (SupSet.sSup s)","decl":"theorem isLUB_csSup' {s : Set α} (hs : BddAbove s) : IsLUB s (sSup s) := by\n  rcases eq_empty_or_nonempty s with (rfl | hne)\n  · simp only [csSup_empty, isLUB_empty]\n  · exact isLUB_csSup hne hs\n\n"}
{"name":"csSup_le_iff'","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrderBot α\ns : Set α\nhs : BddAbove s\na : α\n⊢ Iff (LE.le (SupSet.sSup s) a) (∀ (x : α), Membership.mem s x → LE.le x a)","decl":"/-- In conditionally complete orders with a bottom element, the nonempty condition can be omitted\nfrom `csSup_le_iff`. -/\ntheorem csSup_le_iff' {s : Set α} (hs : BddAbove s) {a : α} : sSup s ≤ a ↔ ∀ x ∈ s, x ≤ a :=\n  isLUB_le_iff (isLUB_csSup' hs)\n\n"}
{"name":"csSup_le'","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrderBot α\ns : Set α\na : α\nh : Membership.mem (upperBounds s) a\n⊢ LE.le (SupSet.sSup s) a","decl":"theorem csSup_le' {s : Set α} {a : α} (h : a ∈ upperBounds s) : sSup s ≤ a :=\n  (csSup_le_iff' ⟨a, h⟩).2 h\n\n"}
{"name":"lt_csSup_iff'","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrderBot α\ns : Set α\na : α\nhb : BddAbove s\n⊢ Iff (LT.lt a (SupSet.sSup s)) (Exists fun b => And (Membership.mem s b) (LT.lt a b))","decl":"/-- In conditionally complete orders with a bottom element, the nonempty condition can be omitted\nfrom `lt_csSup_iff`. -/\ntheorem lt_csSup_iff' (hb : BddAbove s) : a < sSup s ↔ ∃ b ∈ s, a < b := by\n  simpa only [not_le, not_forall₂, exists_prop] using (csSup_le_iff' hb).not\n\n"}
{"name":"le_csSup_iff'","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrderBot α\ns : Set α\na : α\nh : BddAbove s\n⊢ Iff (LE.le a (SupSet.sSup s)) (∀ (b : α), Membership.mem (upperBounds s) b → LE.le a b)","decl":"theorem le_csSup_iff' {s : Set α} {a : α} (h : BddAbove s) :\n    a ≤ sSup s ↔ ∀ b, b ∈ upperBounds s → a ≤ b :=\n  ⟨fun h _ hb => le_trans h (csSup_le' hb), fun hb => hb _ fun _ => le_csSup h⟩\n\n"}
{"name":"le_csInf_iff''","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrderBot α\ns : Set α\na : α\nne : s.Nonempty\n⊢ Iff (LE.le a (InfSet.sInf s)) (∀ (b : α), Membership.mem s b → LE.le a b)","decl":"theorem le_csInf_iff'' {s : Set α} {a : α} (ne : s.Nonempty) :\n    a ≤ sInf s ↔ ∀ b : α, b ∈ s → a ≤ b :=\n  le_csInf_iff (OrderBot.bddBelow _) ne\n\n"}
{"name":"csInf_le'","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrderBot α\ns : Set α\na : α\nh : Membership.mem s a\n⊢ LE.le (InfSet.sInf s) a","decl":"theorem csInf_le' (h : a ∈ s) : sInf s ≤ a := csInf_le (OrderBot.bddBelow _) h\n\n"}
{"name":"exists_lt_of_lt_csSup'","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrderBot α\ns : Set α\na : α\nh : LT.lt a (SupSet.sSup s)\n⊢ Exists fun b => And (Membership.mem s b) (LT.lt a b)","decl":"theorem exists_lt_of_lt_csSup' {s : Set α} {a : α} (h : a < sSup s) : ∃ b ∈ s, a < b := by\n  contrapose! h\n  exact csSup_le' h\n\n"}
{"name":"not_mem_of_lt_csInf'","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrderBot α\nx : α\ns : Set α\nh : LT.lt x (InfSet.sInf s)\n⊢ Not (Membership.mem s x)","decl":"theorem not_mem_of_lt_csInf' {x : α} {s : Set α} (h : x < sInf s) : x ∉ s :=\n  not_mem_of_lt_csInf h (OrderBot.bddBelow s)\n\n"}
{"name":"csInf_le_csInf'","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrderBot α\ns t : Set α\nh₁ : t.Nonempty\nh₂ : HasSubset.Subset t s\n⊢ LE.le (InfSet.sInf s) (InfSet.sInf t)","decl":"theorem csInf_le_csInf' {s t : Set α} (h₁ : t.Nonempty) (h₂ : t ⊆ s) : sInf s ≤ sInf t :=\n  csInf_le_csInf (OrderBot.bddBelow s) h₁ h₂\n\n"}
{"name":"csSup_le_csSup'","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrderBot α\ns t : Set α\nh₁ : BddAbove t\nh₂ : HasSubset.Subset s t\n⊢ LE.le (SupSet.sSup s) (SupSet.sSup t)","decl":"theorem csSup_le_csSup' {s t : Set α} (h₁ : BddAbove t) (h₂ : s ⊆ t) : sSup s ≤ sSup t := by\n  rcases eq_empty_or_nonempty s with rfl | h\n  · rw [csSup_empty]\n    exact bot_le\n  · exact csSup_le_csSup h₁ h h₂\n\n"}
{"name":"WithTop.isLUB_sSup'","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"β : Type u_5\ninst✝ : ConditionallyCompleteLattice β\ns : Set (WithTop β)\nhs : s.Nonempty\n⊢ IsLUB s (SupSet.sSup s)","decl":"/-- The `sSup` of a non-empty set is its least upper bound for a conditionally\ncomplete lattice with a top. -/\ntheorem isLUB_sSup' {β : Type*} [ConditionallyCompleteLattice β] {s : Set (WithTop β)}\n    (hs : s.Nonempty) : IsLUB s (sSup s) := by\n  classical\n  constructor\n  · show ite _ _ _ ∈ _\n    split_ifs with h₁ h₂\n    · intro _ _\n      exact le_top\n    · rintro (⟨⟩ | a) ha\n      · contradiction\n      apply coe_le_coe.2\n      exact le_csSup h₂ ha\n    · intro _ _\n      exact le_top\n  · show ite _ _ _ ∈ _\n    split_ifs with h₁ h₂\n    · rintro (⟨⟩ | a) ha\n      · exact le_rfl\n      · exact False.elim (not_top_le_coe a (ha h₁))\n    · rintro (⟨⟩ | b) hb\n      · exact le_top\n      refine coe_le_coe.2 (csSup_le ?_ ?_)\n      · rcases hs with ⟨⟨⟩ | b, hb⟩\n        · exact absurd hb h₁\n        · exact ⟨b, hb⟩\n      · intro a ha\n        exact coe_le_coe.1 (hb ha)\n    · rintro (⟨⟩ | b) hb\n      · exact le_rfl\n      · exfalso\n        apply h₂\n        use b\n        intro a ha\n        exact coe_le_coe.1 (hb ha)\n\n-- Porting note: in mathlib3 `dsimp only [sSup]` was not needed, we used `show IsLUB ∅ (ite _ _ _)`\n"}
{"name":"WithTop.isLUB_sSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrderBot α\ns : Set (WithTop α)\n⊢ IsLUB s (SupSet.sSup s)","decl":"theorem isLUB_sSup (s : Set (WithTop α)) : IsLUB s (sSup s) := by\n  rcases s.eq_empty_or_nonempty with hs | hs\n  · rw [hs]\n    dsimp only [sSup]\n    show IsLUB ∅ _\n    split_ifs with h₁ h₂\n    · cases h₁\n    · rw [preimage_empty, csSup_empty]\n      exact isLUB_empty\n    · exfalso\n      apply h₂\n      use ⊥\n      rintro a ⟨⟩\n  exact isLUB_sSup' hs\n\n"}
{"name":"WithTop.isGLB_sInf'","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"β : Type u_5\ninst✝ : ConditionallyCompleteLattice β\ns : Set (WithTop β)\nhs : BddBelow s\n⊢ IsGLB s (InfSet.sInf s)","decl":"/-- The `sInf` of a bounded-below set is its greatest lower bound for a conditionally\ncomplete lattice with a top. -/\ntheorem isGLB_sInf' {β : Type*} [ConditionallyCompleteLattice β] {s : Set (WithTop β)}\n    (hs : BddBelow s) : IsGLB s (sInf s) := by\n  classical\n  constructor\n  · show ite _ _ _ ∈ _\n    simp only [hs, not_true_eq_false, or_false]\n    split_ifs with h\n    · intro a ha\n      exact top_le_iff.2 (Set.mem_singleton_iff.1 (h ha))\n    · rintro (⟨⟩ | a) ha\n      · exact le_top\n      refine coe_le_coe.2 (csInf_le ?_ ha)\n      rcases hs with ⟨⟨⟩ | b, hb⟩\n      · exfalso\n        apply h\n        intro c hc\n        rw [mem_singleton_iff, ← top_le_iff]\n        exact hb hc\n      use b\n      intro c hc\n      exact coe_le_coe.1 (hb hc)\n  · show ite _ _ _ ∈ _\n    simp only [hs, not_true_eq_false, or_false]\n    split_ifs with h\n    · intro _ _\n      exact le_top\n    · rintro (⟨⟩ | a) ha\n      · exfalso\n        apply h\n        intro b hb\n        exact Set.mem_singleton_iff.2 (top_le_iff.1 (ha hb))\n      · refine coe_le_coe.2 (le_csInf ?_ ?_)\n        · classical\n            contrapose! h\n            rintro (⟨⟩ | a) ha\n            · exact mem_singleton ⊤\n            · exact (not_nonempty_iff_eq_empty.2 h ⟨a, ha⟩).elim\n        · intro b hb\n          rw [← coe_le_coe]\n          exact ha hb\n\n"}
{"name":"WithTop.isGLB_sInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrderBot α\ns : Set (WithTop α)\n⊢ IsGLB s (InfSet.sInf s)","decl":"theorem isGLB_sInf (s : Set (WithTop α)) : IsGLB s (sInf s) := by\n  by_cases hs : BddBelow s\n  · exact isGLB_sInf' hs\n  · exfalso\n    apply hs\n    use ⊥\n    intro _ _\n    exact bot_le\n\n"}
{"name":"WithTop.coe_sSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrderBot α\ns : Set α\nhb : BddAbove s\n⊢ Eq (↑(SupSet.sSup s)) (iSup fun a => iSup fun h => ↑a)","decl":"/-- A version of `WithTop.coe_sSup'` with a more convenient but less general statement. -/\n@[norm_cast]\ntheorem coe_sSup {s : Set α} (hb : BddAbove s) : ↑(sSup s) = (⨆ a ∈ s, ↑a : WithTop α) := by\n  rw [coe_sSup' hb, sSup_image]\n\n"}
{"name":"WithTop.coe_sInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrderBot α\ns : Set α\nhs : s.Nonempty\nh's : BddBelow s\n⊢ Eq (↑(InfSet.sInf s)) (iInf fun a => iInf fun h => ↑a)","decl":"/-- A version of `WithTop.coe_sInf'` with a more convenient but less general statement. -/\n@[norm_cast]\ntheorem coe_sInf {s : Set α} (hs : s.Nonempty) (h's : BddBelow s) :\n    ↑(sInf s) = (⨅ a ∈ s, ↑a : WithTop α) := by\n  rw [coe_sInf' hs h's, sInf_image]\n\n"}
{"name":"Monotone.le_csSup_image","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : ConditionallyCompleteLattice β\nf : α → β\nh_mono : Monotone f\ns : Set α\nc : α\nhcs : Membership.mem s c\nh_bdd : BddAbove s\n⊢ LE.le (f c) (SupSet.sSup (Set.image f s))","decl":"theorem le_csSup_image {s : Set α} {c : α} (hcs : c ∈ s) (h_bdd : BddAbove s) :\n    f c ≤ sSup (f '' s) :=\n  le_csSup (map_bddAbove h_mono h_bdd) (mem_image_of_mem f hcs)\n\n"}
{"name":"Monotone.csSup_image_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : ConditionallyCompleteLattice β\nf : α → β\nh_mono : Monotone f\ns : Set α\nhs : s.Nonempty\nB : α\nhB : Membership.mem (upperBounds s) B\n⊢ LE.le (SupSet.sSup (Set.image f s)) (f B)","decl":"theorem csSup_image_le {s : Set α} (hs : s.Nonempty) {B : α} (hB : B ∈ upperBounds s) :\n    sSup (f '' s) ≤ f B :=\n  csSup_le (Nonempty.image f hs) (h_mono.mem_upperBounds_image hB)\n\n-- Porting note: in mathlib3 `f'` is not needed\n"}
{"name":"Monotone.csInf_image_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : ConditionallyCompleteLattice β\nf : α → β\nh_mono : Monotone f\ns : Set α\nc : α\nhcs : Membership.mem s c\nh_bdd : BddBelow s\n⊢ LE.le (InfSet.sInf (Set.image f s)) (f c)","decl":"theorem csInf_image_le {s : Set α} {c : α} (hcs : c ∈ s) (h_bdd : BddBelow s) :\n    sInf (f '' s) ≤ f c := by\n  let f' : αᵒᵈ → βᵒᵈ := f\n  exact le_csSup_image (α := αᵒᵈ) (β := βᵒᵈ)\n    (show Monotone f' from fun x y hxy => h_mono hxy) hcs h_bdd\n\n-- Porting note: in mathlib3 `f'` is not needed\n"}
{"name":"Monotone.le_csInf_image","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : ConditionallyCompleteLattice β\nf : α → β\nh_mono : Monotone f\ns : Set α\nhs : s.Nonempty\nB : α\nhB : Membership.mem (lowerBounds s) B\n⊢ LE.le (f B) (InfSet.sInf (Set.image f s))","decl":"theorem le_csInf_image {s : Set α} (hs : s.Nonempty) {B : α} (hB : B ∈ lowerBounds s) :\n    f B ≤ sInf (f '' s) := by\n  let f' : αᵒᵈ → βᵒᵈ := f\n  exact csSup_image_le (α := αᵒᵈ) (β := βᵒᵈ)\n    (show Monotone f' from fun x y hxy => h_mono hxy) hs hB\n\n"}
{"name":"csSup_image2_eq_csSup_csSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : ConditionallyCompleteLattice β\ninst✝ : ConditionallyCompleteLattice γ\ns : Set α\nt : Set β\nl : α → β → γ\nu₁ : β → γ → α\nu₂ : α → γ → β\nh₁ : ∀ (b : β), GaloisConnection (Function.swap l b) (u₁ b)\nh₂ : ∀ (a : α), GaloisConnection (l a) (u₂ a)\nhs₀ : s.Nonempty\nhs₁ : BddAbove s\nht₀ : t.Nonempty\nht₁ : BddAbove t\n⊢ Eq (SupSet.sSup (Set.image2 l s t)) (l (SupSet.sSup s) (SupSet.sSup t))","decl":"theorem csSup_image2_eq_csSup_csSup (h₁ : ∀ b, GaloisConnection (swap l b) (u₁ b))\n    (h₂ : ∀ a, GaloisConnection (l a) (u₂ a)) (hs₀ : s.Nonempty) (hs₁ : BddAbove s)\n    (ht₀ : t.Nonempty) (ht₁ : BddAbove t) : sSup (image2 l s t) = l (sSup s) (sSup t) := by\n  refine eq_of_forall_ge_iff fun c => ?_\n  rw [csSup_le_iff (hs₁.image2 (fun _ => (h₁ _).monotone_l) (fun _ => (h₂ _).monotone_l) ht₁)\n      (hs₀.image2 ht₀),\n    forall_mem_image2, forall₂_swap, (h₂ _).le_iff_le, csSup_le_iff ht₁ ht₀]\n  simp_rw [← (h₂ _).le_iff_le, (h₁ _).le_iff_le, csSup_le_iff hs₁ hs₀]\n\n"}
{"name":"csSup_image2_eq_csSup_csInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : ConditionallyCompleteLattice β\ninst✝ : ConditionallyCompleteLattice γ\ns : Set α\nt : Set β\nl : α → β → γ\nu₁ : β → γ → α\nu₂ : α → γ → β\nh₁ : ∀ (b : β), GaloisConnection (Function.swap l b) (u₁ b)\nh₂ : ∀ (a : α), GaloisConnection (Function.comp (l a) ⇑OrderDual.ofDual) (Function.comp (⇑OrderDual.toDual) (u₂ a))\na✝³ : s.Nonempty\na✝² : BddAbove s\na✝¹ : t.Nonempty\na✝ : BddBelow t\n⊢ Eq (SupSet.sSup (Set.image2 l s t)) (l (SupSet.sSup s) (InfSet.sInf t))","decl":"theorem csSup_image2_eq_csSup_csInf (h₁ : ∀ b, GaloisConnection (swap l b) (u₁ b))\n    (h₂ : ∀ a, GaloisConnection (l a ∘ ofDual) (toDual ∘ u₂ a)) :\n    s.Nonempty → BddAbove s → t.Nonempty → BddBelow t → sSup (image2 l s t) = l (sSup s) (sInf t) :=\n  csSup_image2_eq_csSup_csSup (β := βᵒᵈ) h₁ h₂\n\n"}
{"name":"csSup_image2_eq_csInf_csSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : ConditionallyCompleteLattice β\ninst✝ : ConditionallyCompleteLattice γ\ns : Set α\nt : Set β\nl : α → β → γ\nu₁ : β → γ → α\nu₂ : α → γ → β\nh₁ : ∀ (b : β), GaloisConnection (Function.comp (Function.swap l b) ⇑OrderDual.ofDual) (Function.comp (⇑OrderDual.toDual) (u₁ b))\nh₂ : ∀ (a : α), GaloisConnection (l a) (u₂ a)\na✝³ : s.Nonempty\na✝² : BddBelow s\na✝¹ : t.Nonempty\na✝ : BddAbove t\n⊢ Eq (SupSet.sSup (Set.image2 l s t)) (l (InfSet.sInf s) (SupSet.sSup t))","decl":"theorem csSup_image2_eq_csInf_csSup (h₁ : ∀ b, GaloisConnection (swap l b ∘ ofDual) (toDual ∘ u₁ b))\n    (h₂ : ∀ a, GaloisConnection (l a) (u₂ a)) :\n    s.Nonempty → BddBelow s → t.Nonempty → BddAbove t → sSup (image2 l s t) = l (sInf s) (sSup t) :=\n  csSup_image2_eq_csSup_csSup (α := αᵒᵈ) h₁ h₂\n\n"}
{"name":"csSup_image2_eq_csInf_csInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : ConditionallyCompleteLattice β\ninst✝ : ConditionallyCompleteLattice γ\ns : Set α\nt : Set β\nl : α → β → γ\nu₁ : β → γ → α\nu₂ : α → γ → β\nh₁ : ∀ (b : β), GaloisConnection (Function.comp (Function.swap l b) ⇑OrderDual.ofDual) (Function.comp (⇑OrderDual.toDual) (u₁ b))\nh₂ : ∀ (a : α), GaloisConnection (Function.comp (l a) ⇑OrderDual.ofDual) (Function.comp (⇑OrderDual.toDual) (u₂ a))\na✝³ : s.Nonempty\na✝² : BddBelow s\na✝¹ : t.Nonempty\na✝ : BddBelow t\n⊢ Eq (SupSet.sSup (Set.image2 l s t)) (l (InfSet.sInf s) (InfSet.sInf t))","decl":"theorem csSup_image2_eq_csInf_csInf (h₁ : ∀ b, GaloisConnection (swap l b ∘ ofDual) (toDual ∘ u₁ b))\n    (h₂ : ∀ a, GaloisConnection (l a ∘ ofDual) (toDual ∘ u₂ a)) :\n    s.Nonempty → BddBelow s → t.Nonempty → BddBelow t → sSup (image2 l s t) = l (sInf s) (sInf t) :=\n  csSup_image2_eq_csSup_csSup (α := αᵒᵈ) (β := βᵒᵈ) h₁ h₂\n\n"}
{"name":"csInf_image2_eq_csInf_csInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : ConditionallyCompleteLattice β\ninst✝ : ConditionallyCompleteLattice γ\ns : Set α\nt : Set β\nu : α → β → γ\nl₁ : β → γ → α\nl₂ : α → γ → β\nh₁ : ∀ (b : β), GaloisConnection (l₁ b) (Function.swap u b)\nh₂ : ∀ (a : α), GaloisConnection (l₂ a) (u a)\na✝³ : s.Nonempty\na✝² : BddBelow s\na✝¹ : t.Nonempty\na✝ : BddBelow t\n⊢ Eq (InfSet.sInf (Set.image2 u s t)) (u (InfSet.sInf s) (InfSet.sInf t))","decl":"theorem csInf_image2_eq_csInf_csInf (h₁ : ∀ b, GaloisConnection (l₁ b) (swap u b))\n    (h₂ : ∀ a, GaloisConnection (l₂ a) (u a)) :\n    s.Nonempty → BddBelow s → t.Nonempty → BddBelow t → sInf (image2 u s t) = u (sInf s) (sInf t) :=\n  csSup_image2_eq_csSup_csSup (α := αᵒᵈ) (β := βᵒᵈ) (γ := γᵒᵈ) (u₁ := l₁) (u₂ := l₂)\n    (fun _ => (h₁ _).dual) fun _ => (h₂ _).dual\n\n"}
{"name":"csInf_image2_eq_csInf_csSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : ConditionallyCompleteLattice β\ninst✝ : ConditionallyCompleteLattice γ\ns : Set α\nt : Set β\nu : α → β → γ\nl₁ : β → γ → α\nl₂ : α → γ → β\nh₁ : ∀ (b : β), GaloisConnection (l₁ b) (Function.swap u b)\nh₂ : ∀ (a : α), GaloisConnection (Function.comp (⇑OrderDual.toDual) (l₂ a)) (Function.comp (u a) ⇑OrderDual.ofDual)\na✝³ : s.Nonempty\na✝² : BddBelow s\na✝¹ : t.Nonempty\na✝ : BddAbove t\n⊢ Eq (InfSet.sInf (Set.image2 u s t)) (u (InfSet.sInf s) (SupSet.sSup t))","decl":"theorem csInf_image2_eq_csInf_csSup (h₁ : ∀ b, GaloisConnection (l₁ b) (swap u b))\n    (h₂ : ∀ a, GaloisConnection (toDual ∘ l₂ a) (u a ∘ ofDual)) :\n    s.Nonempty → BddBelow s → t.Nonempty → BddAbove t → sInf (image2 u s t) = u (sInf s) (sSup t) :=\n  csInf_image2_eq_csInf_csInf (β := βᵒᵈ) h₁ h₂\n\n"}
{"name":"csInf_image2_eq_csSup_csInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : ConditionallyCompleteLattice β\ninst✝ : ConditionallyCompleteLattice γ\ns : Set α\nt : Set β\nu : α → β → γ\nl₁ : β → γ → α\nl₂ : α → γ → β\nh₁ : ∀ (b : β), GaloisConnection (Function.comp (⇑OrderDual.toDual) (l₁ b)) (Function.comp (Function.swap u b) ⇑OrderDual.ofDual)\nh₂ : ∀ (a : α), GaloisConnection (l₂ a) (u a)\na✝³ : s.Nonempty\na✝² : BddAbove s\na✝¹ : t.Nonempty\na✝ : BddBelow t\n⊢ Eq (InfSet.sInf (Set.image2 u s t)) (u (SupSet.sSup s) (InfSet.sInf t))","decl":"theorem csInf_image2_eq_csSup_csInf (h₁ : ∀ b, GaloisConnection (toDual ∘ l₁ b) (swap u b ∘ ofDual))\n    (h₂ : ∀ a, GaloisConnection (l₂ a) (u a)) :\n    s.Nonempty → BddAbove s → t.Nonempty → BddBelow t → sInf (image2 u s t) = u (sSup s) (sInf t) :=\n  csInf_image2_eq_csInf_csInf (α := αᵒᵈ) h₁ h₂\n\n"}
{"name":"csInf_image2_eq_csSup_csSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : ConditionallyCompleteLattice β\ninst✝ : ConditionallyCompleteLattice γ\ns : Set α\nt : Set β\nu : α → β → γ\nl₁ : β → γ → α\nl₂ : α → γ → β\nh₁ : ∀ (b : β), GaloisConnection (Function.comp (⇑OrderDual.toDual) (l₁ b)) (Function.comp (Function.swap u b) ⇑OrderDual.ofDual)\nh₂ : ∀ (a : α), GaloisConnection (Function.comp (⇑OrderDual.toDual) (l₂ a)) (Function.comp (u a) ⇑OrderDual.ofDual)\na✝³ : s.Nonempty\na✝² : BddAbove s\na✝¹ : t.Nonempty\na✝ : BddAbove t\n⊢ Eq (InfSet.sInf (Set.image2 u s t)) (u (SupSet.sSup s) (SupSet.sSup t))","decl":"theorem csInf_image2_eq_csSup_csSup (h₁ : ∀ b, GaloisConnection (toDual ∘ l₁ b) (swap u b ∘ ofDual))\n    (h₂ : ∀ a, GaloisConnection (toDual ∘ l₂ a) (u a ∘ ofDual)) :\n    s.Nonempty → BddAbove s → t.Nonempty → BddAbove t → sInf (image2 u s t) = u (sSup s) (sSup t) :=\n  csInf_image2_eq_csInf_csInf (α := αᵒᵈ) (β := βᵒᵈ) h₁ h₂\n\n"}
