{"name":"DMatrix.ext_iff","module":"Mathlib.Data.Matrix.DMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nα : m → n → Type v\nM N : DMatrix m n α\n⊢ Iff (∀ (i : m) (j : n), Eq (M i j) (N i j)) (Eq M N)","decl":"theorem ext_iff : (∀ i j, M i j = N i j) ↔ M = N :=\n  ⟨fun h => funext fun i => funext <| h i, fun h => by simp [h]⟩\n\n"}
{"name":"DMatrix.ext","module":"Mathlib.Data.Matrix.DMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nα : m → n → Type v\nM N : DMatrix m n α\na✝ : ∀ (i : m) (j : n), Eq (M i j) (N i j)\n⊢ Eq M N","decl":"@[ext]\ntheorem ext : (∀ i j, M i j = N i j) → M = N :=\n  ext_iff.mp\n\n"}
{"name":"DMatrix.map_apply","module":"Mathlib.Data.Matrix.DMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nα : m → n → Type v\nM : DMatrix m n α\nβ : m → n → Type w\nf : ⦃i : m⦄ → ⦃j : n⦄ → α i j → β i j\ni : m\nj : n\n⊢ Eq (M.map f i j) (f (M i j))","decl":"@[simp]\ntheorem map_apply {M : DMatrix m n α} {β : m → n → Type w} {f : ∀ ⦃i j⦄, α i j → β i j} {i : m}\n    {j : n} : M.map f i j = f (M i j) := rfl\n\n"}
{"name":"DMatrix.map_map","module":"Mathlib.Data.Matrix.DMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nα : m → n → Type v\nM : DMatrix m n α\nβ : m → n → Type w\nγ : m → n → Type z\nf : ⦃i : m⦄ → ⦃j : n⦄ → α i j → β i j\ng : ⦃i : m⦄ → ⦃j : n⦄ → β i j → γ i j\n⊢ Eq ((M.map f).map g) (M.map fun x x_1 x_2 => g (f x_2))","decl":"@[simp]\ntheorem map_map {M : DMatrix m n α} {β : m → n → Type w} {γ : m → n → Type z}\n    {f : ∀ ⦃i j⦄, α i j → β i j} {g : ∀ ⦃i j⦄, β i j → γ i j} :\n    (M.map f).map g = M.map fun _ _ x => g (f x) := by ext; simp\n\n"}
{"name":"DMatrix.instSubsingleton","module":"Mathlib.Data.Matrix.DMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nα : m → n → Type v\ninst✝ : ∀ (i : m) (j : n), Subsingleton (α i j)\n⊢ Subsingleton (DMatrix m n α)","decl":"instance [∀ i j, Subsingleton (α i j)] : Subsingleton (DMatrix m n α) :=\n  inferInstanceAs <| Subsingleton <| ∀ i j, α i j\n\n"}
{"name":"DMatrix.zero_apply","module":"Mathlib.Data.Matrix.DMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nα : m → n → Type v\ninst✝ : (i : m) → (j : n) → Zero (α i j)\ni : m\nj : n\n⊢ Eq (0 i j) 0","decl":"@[simp]\ntheorem zero_apply [∀ i j, Zero (α i j)] (i j) : (0 : DMatrix m n α) i j = 0 := rfl\n\n"}
{"name":"DMatrix.neg_apply","module":"Mathlib.Data.Matrix.DMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nα : m → n → Type v\ninst✝ : (i : m) → (j : n) → Neg (α i j)\nM : DMatrix m n α\ni : m\nj : n\n⊢ Eq (Neg.neg M i j) (Neg.neg (M i j))","decl":"@[simp]\ntheorem neg_apply [∀ i j, Neg (α i j)] (M : DMatrix m n α) (i j) : (-M) i j = -M i j := rfl\n\n"}
{"name":"DMatrix.add_apply","module":"Mathlib.Data.Matrix.DMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nα : m → n → Type v\ninst✝ : (i : m) → (j : n) → Add (α i j)\nM N : DMatrix m n α\ni : m\nj : n\n⊢ Eq (HAdd.hAdd M N i j) (HAdd.hAdd (M i j) (N i j))","decl":"@[simp]\ntheorem add_apply [∀ i j, Add (α i j)] (M N : DMatrix m n α) (i j) : (M + N) i j = M i j + N i j :=\n  rfl\n\n"}
{"name":"DMatrix.sub_apply","module":"Mathlib.Data.Matrix.DMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nα : m → n → Type v\ninst✝ : (i : m) → (j : n) → Sub (α i j)\nM N : DMatrix m n α\ni : m\nj : n\n⊢ Eq (HSub.hSub M N i j) (HSub.hSub (M i j) (N i j))","decl":"@[simp]\ntheorem sub_apply [∀ i j, Sub (α i j)] (M N : DMatrix m n α) (i j) : (M - N) i j = M i j - N i j :=\n  rfl\n\n"}
{"name":"DMatrix.map_zero","module":"Mathlib.Data.Matrix.DMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nα : m → n → Type v\ninst✝¹ : (i : m) → (j : n) → Zero (α i j)\nβ : m → n → Type w\ninst✝ : (i : m) → (j : n) → Zero (β i j)\nf : ⦃i : m⦄ → ⦃j : n⦄ → α i j → β i j\nh : ∀ (i : m) (j : n), Eq (f 0) 0\n⊢ Eq (DMatrix.map 0 f) 0","decl":"@[simp]\ntheorem map_zero [∀ i j, Zero (α i j)] {β : m → n → Type w} [∀ i j, Zero (β i j)]\n    {f : ∀ ⦃i j⦄, α i j → β i j} (h : ∀ i j, f (0 : α i j) = 0) :\n    (0 : DMatrix m n α).map f = 0 := by ext; simp [h]\n\n"}
{"name":"DMatrix.map_add","module":"Mathlib.Data.Matrix.DMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nα : m → n → Type v\ninst✝¹ : (i : m) → (j : n) → AddMonoid (α i j)\nβ : m → n → Type w\ninst✝ : (i : m) → (j : n) → AddMonoid (β i j)\nf : ⦃i : m⦄ → ⦃j : n⦄ → AddMonoidHom (α i j) (β i j)\nM N : DMatrix m n α\n⊢ Eq ((HAdd.hAdd M N).map fun i j => ⇑f) (HAdd.hAdd (M.map fun i j => ⇑f) (N.map fun i j => ⇑f))","decl":"theorem map_add [∀ i j, AddMonoid (α i j)] {β : m → n → Type w} [∀ i j, AddMonoid (β i j)]\n    (f : ∀ ⦃i j⦄, α i j →+ β i j) (M N : DMatrix m n α) :\n    ((M + N).map fun i j => @f i j) = (M.map fun i j => @f i j) + N.map fun i j => @f i j := by\n  ext; simp\n\n"}
{"name":"DMatrix.map_sub","module":"Mathlib.Data.Matrix.DMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nα : m → n → Type v\ninst✝¹ : (i : m) → (j : n) → AddGroup (α i j)\nβ : m → n → Type w\ninst✝ : (i : m) → (j : n) → AddGroup (β i j)\nf : ⦃i : m⦄ → ⦃j : n⦄ → AddMonoidHom (α i j) (β i j)\nM N : DMatrix m n α\n⊢ Eq ((HSub.hSub M N).map fun i j => ⇑f) (HSub.hSub (M.map fun i j => ⇑f) (N.map fun i j => ⇑f))","decl":"theorem map_sub [∀ i j, AddGroup (α i j)] {β : m → n → Type w} [∀ i j, AddGroup (β i j)]\n    (f : ∀ ⦃i j⦄, α i j →+ β i j) (M N : DMatrix m n α) :\n    ((M - N).map fun i j => @f i j) = (M.map fun i j => @f i j) - N.map fun i j => @f i j := by\n  ext; simp\n\n"}
{"name":"DMatrix.subsingleton_of_empty_left","module":"Mathlib.Data.Matrix.DMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nα : m → n → Type v\ninst✝ : IsEmpty m\n⊢ Subsingleton (DMatrix m n α)","decl":"instance subsingleton_of_empty_left [IsEmpty m] : Subsingleton (DMatrix m n α) :=\n  ⟨fun M N => by\n    ext i\n    exact isEmptyElim i⟩\n\n"}
{"name":"DMatrix.subsingleton_of_empty_right","module":"Mathlib.Data.Matrix.DMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nα : m → n → Type v\ninst✝ : IsEmpty n\n⊢ Subsingleton (DMatrix m n α)","decl":"instance subsingleton_of_empty_right [IsEmpty n] : Subsingleton (DMatrix m n α) :=\n  ⟨fun M N => by ext i j; exact isEmptyElim j⟩\n\n"}
{"name":"AddMonoidHom.mapDMatrix_apply","module":"Mathlib.Data.Matrix.DMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nα : m → n → Type v\ninst✝¹ : (i : m) → (j : n) → AddMonoid (α i j)\nβ : m → n → Type w\ninst✝ : (i : m) → (j : n) → AddMonoid (β i j)\nf : ⦃i : m⦄ → ⦃j : n⦄ → AddMonoidHom (α i j) (β i j)\nM : DMatrix m n α\n⊢ Eq ((AddMonoidHom.mapDMatrix f) M) (M.map fun i j => ⇑f)","decl":"@[simp]\ntheorem AddMonoidHom.mapDMatrix_apply [∀ i j, AddMonoid (α i j)] {β : m → n → Type w}\n    [∀ i j, AddMonoid (β i j)] (f : ∀ ⦃i j⦄, α i j →+ β i j) (M : DMatrix m n α) :\n    AddMonoidHom.mapDMatrix f M = M.map fun i j => @f i j := rfl\n"}
