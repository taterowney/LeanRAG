{"name":"LocalizedModule.map_exact","module":"Mathlib.Algebra.Module.LocalizedModule.Exact","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nS : Submonoid R\nM₀ : Type u_2\ninst✝⁵ : AddCommMonoid M₀\ninst✝⁴ : Module R M₀\nM₁ : Type u_3\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\nM₂ : Type u_4\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\ng : LinearMap (RingHom.id R) M₀ M₁\nh : LinearMap (RingHom.id R) M₁ M₂\nex : Function.Exact ⇑g ⇑h\n⊢ Function.Exact ⇑((IsLocalizedModule.map S (LocalizedModule.mkLinearMap S M₀) (LocalizedModule.mkLinearMap S M₁)) g) ⇑((IsLocalizedModule.map S (LocalizedModule.mkLinearMap S M₁) (LocalizedModule.mkLinearMap S M₂)) h)","decl":"/-- Localization of modules is an exact functor, proven here for `LocalizedModule`.\nSee `IsLocalizedModule.map_exact` for the more general version. -/\nlemma LocalizedModule.map_exact (g : M₀ →ₗ[R] M₁) (h : M₁ →ₗ[R] M₂) (ex : Exact g h) :\n    Exact (map S (mkLinearMap S M₀) (mkLinearMap S M₁) g)\n    (map S (mkLinearMap S M₁) (mkLinearMap S M₂) h) :=\n  fun y ↦ Iff.intro\n    (induction_on\n      (fun m s hy ↦ by\n        rw [map_LocalizedModules, ← zero_mk 1, mk_eq, one_smul, smul_zero] at hy\n        obtain ⟨a, aS, ha⟩ := Subtype.exists.1 hy\n        rw [smul_zero, mk_smul, ← LinearMap.map_smul, ex (a • m)] at ha\n        rcases ha with ⟨x, hx⟩\n        use mk x (⟨a, aS⟩ * s)\n        rw [map_LocalizedModules, hx, ← mk_cancel_common_left ⟨a, aS⟩ s m, mk_smul])\n      y)\n    fun ⟨x, hx⟩ ↦ by\n      revert hx\n      refine induction_on (fun m s hx ↦ ?_) x\n      rw [← hx, map_LocalizedModules, map_LocalizedModules, (ex (g m)).2 ⟨m, rfl⟩, zero_mk]\n\n"}
{"name":"IsLocalizedModule.map_exact","module":"Mathlib.Algebra.Module.LocalizedModule.Exact","initialProofState":"R : Type u_1\ninst✝¹⁵ : CommSemiring R\nS : Submonoid R\nM₀ : Type u_2\nM₀' : Type u_5\ninst✝¹⁴ : AddCommMonoid M₀\ninst✝¹³ : AddCommMonoid M₀'\ninst✝¹² : Module R M₀\ninst✝¹¹ : Module R M₀'\nf₀ : LinearMap (RingHom.id R) M₀ M₀'\ninst✝¹⁰ : IsLocalizedModule S f₀\nM₁ : Type u_3\nM₁' : Type u_6\ninst✝⁹ : AddCommMonoid M₁\ninst✝⁸ : AddCommMonoid M₁'\ninst✝⁷ : Module R M₁\ninst✝⁶ : Module R M₁'\nf₁ : LinearMap (RingHom.id R) M₁ M₁'\ninst✝⁵ : IsLocalizedModule S f₁\nM₂ : Type u_4\nM₂' : Type u_7\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₂'\ninst✝² : Module R M₂\ninst✝¹ : Module R M₂'\nf₂ : LinearMap (RingHom.id R) M₂ M₂'\ninst✝ : IsLocalizedModule S f₂\ng : LinearMap (RingHom.id R) M₀ M₁\nh : LinearMap (RingHom.id R) M₁ M₂\nex : Function.Exact ⇑g ⇑h\n⊢ Function.Exact ⇑((IsLocalizedModule.map S f₀ f₁) g) ⇑((IsLocalizedModule.map S f₁ f₂) h)","decl":"/-- Localization of modules is an exact functor. -/\ntheorem IsLocalizedModule.map_exact (g : M₀ →ₗ[R] M₁) (h : M₁ →ₗ[R] M₂) (ex : Function.Exact g h) :\n    Function.Exact (map S f₀ f₁ g) (map S f₁ f₂ h) :=\n  Function.Exact.of_ladder_linearEquiv_of_exact\n    (map_iso_commute S f₀ f₁ g) (map_iso_commute S f₁ f₂ h) (LocalizedModule.map_exact S g h ex)\n\n"}
