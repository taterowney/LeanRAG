{"name":"continuous_one","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : One M\nâŠ¢ Continuous 1","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem continuous_one [TopologicalSpace M] [One M] : Continuous (1 : X â†’ M) :=\n  @continuous_const _ _ _ _ 1\n\n"}
{"name":"continuous_zero","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : Zero M\nâŠ¢ Continuous 0","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem continuous_one [TopologicalSpace M] [One M] : Continuous (1 : X â†’ M) :=\n  @continuous_const _ _ _ _ 1\n\n"}
{"name":"ContinuousAdd.continuous_add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : Add M\nself : ContinuousAdd M\nâŠ¢ Continuous fun p => HAdd.hAdd p.1 p.2","decl":"/-- Basic hypothesis to talk about a topological additive monoid or a topological additive\nsemigroup. A topological additive monoid over `M`, for example, is obtained by requiring both the\ninstances `AddMonoid M` and `ContinuousAdd M`.\n\nContinuity in only the left/right argument can be stated using\n`ContinuousConstVAdd Î± Î±`/`ContinuousConstVAdd Î±áµáµ’áµ– Î±`. -/\nclass ContinuousAdd (M : Type u) [TopologicalSpace M] [Add M] : Prop where\n  continuous_add : Continuous fun p : M Ã— M => p.1 + p.2\n\n"}
{"name":"ContinuousMul.continuous_mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : Mul M\nself : ContinuousMul M\nâŠ¢ Continuous fun p => HMul.hMul p.1 p.2","decl":"/-- Basic hypothesis to talk about a topological monoid or a topological semigroup.\nA topological monoid over `M`, for example, is obtained by requiring both the instances `Monoid M`\nand `ContinuousMul M`.\n\nContinuity in only the left/right argument can be stated using\n`ContinuousConstSMul Î± Î±`/`ContinuousConstSMul Î±áµáµ’áµ– Î±`. -/\n@[to_additive]\nclass ContinuousMul (M : Type u) [TopologicalSpace M] [Mul M] : Prop where\n  continuous_mul : Continuous fun p : M Ã— M => p.1 * p.2\n\n"}
{"name":"instContinuousAddOrderDual","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : Add M\nâŠ¢ ContinuousAdd (OrderDual M)","decl":"@[to_additive]\ninstance : ContinuousMul Máµ’áµˆ :=\n  â€¹ContinuousMul Mâ€º\n\n"}
{"name":"instContinuousMulOrderDual","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : Mul M\nâŠ¢ ContinuousMul (OrderDual M)","decl":"@[to_additive]\ninstance : ContinuousMul Máµ’áµˆ :=\n  â€¹ContinuousMul Mâ€º\n\n"}
{"name":"continuous_add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Add M\ninstâœ : ContinuousAdd M\nâŠ¢ Continuous fun p => HAdd.hAdd p.1 p.2","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem continuous_mul : Continuous fun p : M Ã— M => p.1 * p.2 :=\n  ContinuousMul.continuous_mul\n\n"}
{"name":"continuous_mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Mul M\ninstâœ : ContinuousMul M\nâŠ¢ Continuous fun p => HMul.hMul p.1 p.2","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem continuous_mul : Continuous fun p : M Ã— M => p.1 * p.2 :=\n  ContinuousMul.continuous_mul\n\n"}
{"name":"instContinuousAddULift","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : Add M\nâŠ¢ ContinuousAdd (ULift.{u, u_3} M)","decl":"@[to_additive]\ninstance : ContinuousMul (ULift.{u} M) := by\n  constructor\n  apply continuous_uLift_up.comp\n  exact continuous_mul.compâ‚‚ (continuous_uLift_down.comp continuous_fst)\n    (continuous_uLift_down.comp continuous_snd)\n\n"}
{"name":"instContinuousMulULift","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : Mul M\nâŠ¢ ContinuousMul (ULift.{u, u_3} M)","decl":"@[to_additive]\ninstance : ContinuousMul (ULift.{u} M) := by\n  constructor\n  apply continuous_uLift_up.comp\n  exact continuous_mul.compâ‚‚ (continuous_uLift_down.comp continuous_fst)\n    (continuous_uLift_down.comp continuous_snd)\n\n"}
{"name":"ContinuousMul.to_continuousSMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Mul M\ninstâœ : ContinuousMul M\nâŠ¢ ContinuousSMul M M","decl":"@[to_additive]\ninstance ContinuousMul.to_continuousSMul : ContinuousSMul M M :=\n  âŸ¨continuous_mulâŸ©\n\n"}
{"name":"ContinuousAdd.to_continuousVAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Add M\ninstâœ : ContinuousAdd M\nâŠ¢ ContinuousVAdd M M","decl":"@[to_additive]\ninstance ContinuousMul.to_continuousSMul : ContinuousSMul M M :=\n  âŸ¨continuous_mulâŸ©\n\n"}
{"name":"ContinuousAdd.to_continuousVAdd_op","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Add M\ninstâœ : ContinuousAdd M\nâŠ¢ ContinuousVAdd (AddOpposite M) M","decl":"@[to_additive]\ninstance ContinuousMul.to_continuousSMul_op : ContinuousSMul Máµáµ’áµ– M :=\n  âŸ¨show Continuous ((fun p : M Ã— M => p.1 * p.2) âˆ˜ Prod.swap âˆ˜ Prod.map MulOpposite.unop id) from\n      continuous_mul.comp <|\n        continuous_swap.comp <| Continuous.prodMap MulOpposite.continuous_unop continuous_idâŸ©\n\n"}
{"name":"ContinuousMul.to_continuousSMul_op","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Mul M\ninstâœ : ContinuousMul M\nâŠ¢ ContinuousSMul (MulOpposite M) M","decl":"@[to_additive]\ninstance ContinuousMul.to_continuousSMul_op : ContinuousSMul Máµáµ’áµ– M :=\n  âŸ¨show Continuous ((fun p : M Ã— M => p.1 * p.2) âˆ˜ Prod.swap âˆ˜ Prod.map MulOpposite.unop id) from\n      continuous_mul.comp <|\n        continuous_swap.comp <| Continuous.prodMap MulOpposite.continuous_unop continuous_idâŸ©\n\n"}
{"name":"ContinuousMul.induced","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_6\nÎ² : Type u_7\nF : Type u_8\ninstâœâ´ : FunLike F Î± Î²\ninstâœÂ³ : MulOneClass Î±\ninstâœÂ² : MulOneClass Î²\ninstâœÂ¹ : MonoidHomClass F Î± Î²\ntÎ² : TopologicalSpace Î²\ninstâœ : ContinuousMul Î²\nf : F\nâŠ¢ ContinuousMul Î±","decl":"@[to_additive]\ntheorem ContinuousMul.induced {Î± : Type*} {Î² : Type*} {F : Type*} [FunLike F Î± Î²] [MulOneClass Î±]\n    [MulOneClass Î²] [MonoidHomClass F Î± Î²] [tÎ² : TopologicalSpace Î²] [ContinuousMul Î²] (f : F) :\n    @ContinuousMul Î± (tÎ².induced f) _ := by\n  let tÎ± := tÎ².induced f\n  refine âŸ¨continuous_induced_rng.2 ?_âŸ©\n  simp only [Function.comp_def, map_mul]\n  fun_prop\n\n"}
{"name":"ContinuousAdd.induced","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_6\nÎ² : Type u_7\nF : Type u_8\ninstâœâ´ : FunLike F Î± Î²\ninstâœÂ³ : AddZeroClass Î±\ninstâœÂ² : AddZeroClass Î²\ninstâœÂ¹ : AddMonoidHomClass F Î± Î²\ntÎ² : TopologicalSpace Î²\ninstâœ : ContinuousAdd Î²\nf : F\nâŠ¢ ContinuousAdd Î±","decl":"@[to_additive]\ntheorem ContinuousMul.induced {Î± : Type*} {Î² : Type*} {F : Type*} [FunLike F Î± Î²] [MulOneClass Î±]\n    [MulOneClass Î²] [MonoidHomClass F Î± Î²] [tÎ² : TopologicalSpace Î²] [ContinuousMul Î²] (f : F) :\n    @ContinuousMul Î± (tÎ².induced f) _ := by\n  let tÎ± := tÎ².induced f\n  refine âŸ¨continuous_induced_rng.2 ?_âŸ©\n  simp only [Function.comp_def, map_mul]\n  fun_prop\n\n"}
{"name":"Continuous.mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Mul M\ninstâœ : ContinuousMul M\nf g : X â†’ M\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous fun x => HMul.hMul (f x) (g x)","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem Continuous.mul {f g : X â†’ M} (hf : Continuous f) (hg : Continuous g) :\n    Continuous fun x => f x * g x :=\n  continuous_mul.comp (hf.prod_mk hg :)\n\n"}
{"name":"Continuous.add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Add M\ninstâœ : ContinuousAdd M\nf g : X â†’ M\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous fun x => HAdd.hAdd (f x) (g x)","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem Continuous.mul {f g : X â†’ M} (hf : Continuous f) (hg : Continuous g) :\n    Continuous fun x => f x * g x :=\n  continuous_mul.comp (hf.prod_mk hg :)\n\n"}
{"name":"continuous_mul_left","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Mul M\ninstâœ : ContinuousMul M\na : M\nâŠ¢ Continuous fun b => HMul.hMul a b","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_mul_left (a : M) : Continuous fun b : M => a * b :=\n  continuous_const.mul continuous_id\n\n"}
{"name":"continuous_add_left","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Add M\ninstâœ : ContinuousAdd M\na : M\nâŠ¢ Continuous fun b => HAdd.hAdd a b","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_mul_left (a : M) : Continuous fun b : M => a * b :=\n  continuous_const.mul continuous_id\n\n"}
{"name":"continuous_add_right","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Add M\ninstâœ : ContinuousAdd M\na : M\nâŠ¢ Continuous fun b => HAdd.hAdd b a","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_mul_right (a : M) : Continuous fun b : M => b * a :=\n  continuous_id.mul continuous_const\n\n"}
{"name":"continuous_mul_right","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Mul M\ninstâœ : ContinuousMul M\na : M\nâŠ¢ Continuous fun b => HMul.hMul b a","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_mul_right (a : M) : Continuous fun b : M => b * a :=\n  continuous_id.mul continuous_const\n\n"}
{"name":"ContinuousOn.add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Add M\ninstâœ : ContinuousAdd M\nf g : X â†’ M\ns : Set X\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nâŠ¢ ContinuousOn (fun x => HAdd.hAdd (f x) (g x)) s","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousOn.mul {f g : X â†’ M} {s : Set X} (hf : ContinuousOn f s) (hg : ContinuousOn g s) :\n    ContinuousOn (fun x => f x * g x) s :=\n  (continuous_mul.comp_continuousOn (hf.prod hg) :)\n\n"}
{"name":"ContinuousOn.mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Mul M\ninstâœ : ContinuousMul M\nf g : X â†’ M\ns : Set X\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nâŠ¢ ContinuousOn (fun x => HMul.hMul (f x) (g x)) s","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousOn.mul {f g : X â†’ M} {s : Set X} (hf : ContinuousOn f s) (hg : ContinuousOn g s) :\n    ContinuousOn (fun x => f x * g x) s :=\n  (continuous_mul.comp_continuousOn (hf.prod hg) :)\n\n"}
{"name":"tendsto_mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Mul M\ninstâœ : ContinuousMul M\na b : M\nâŠ¢ Filter.Tendsto (fun p => HMul.hMul p.1 p.2) (nhds { fst := a, snd := b }) (nhds (HMul.hMul a b))","decl":"@[to_additive]\ntheorem tendsto_mul {a b : M} : Tendsto (fun p : M Ã— M => p.fst * p.snd) (ğ“ (a, b)) (ğ“ (a * b)) :=\n  continuous_iff_continuousAt.mp ContinuousMul.continuous_mul (a, b)\n\n"}
{"name":"tendsto_add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Add M\ninstâœ : ContinuousAdd M\na b : M\nâŠ¢ Filter.Tendsto (fun p => HAdd.hAdd p.1 p.2) (nhds { fst := a, snd := b }) (nhds (HAdd.hAdd a b))","decl":"@[to_additive]\ntheorem tendsto_mul {a b : M} : Tendsto (fun p : M Ã— M => p.fst * p.snd) (ğ“ (a, b)) (ğ“ (a * b)) :=\n  continuous_iff_continuousAt.mp ContinuousMul.continuous_mul (a, b)\n\n"}
{"name":"Filter.Tendsto.add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_2\nM : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Add M\ninstâœ : ContinuousAdd M\nf g : Î± â†’ M\nx : Filter Î±\na b : M\nhf : Filter.Tendsto f x (nhds a)\nhg : Filter.Tendsto g x (nhds b)\nâŠ¢ Filter.Tendsto (fun x => HAdd.hAdd (f x) (g x)) x (nhds (HAdd.hAdd a b))","decl":"@[to_additive]\ntheorem Filter.Tendsto.mul {f g : Î± â†’ M} {x : Filter Î±} {a b : M} (hf : Tendsto f x (ğ“ a))\n    (hg : Tendsto g x (ğ“ b)) : Tendsto (fun x => f x * g x) x (ğ“ (a * b)) :=\n  tendsto_mul.comp (hf.prod_mk_nhds hg)\n\n"}
{"name":"Filter.Tendsto.mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_2\nM : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Mul M\ninstâœ : ContinuousMul M\nf g : Î± â†’ M\nx : Filter Î±\na b : M\nhf : Filter.Tendsto f x (nhds a)\nhg : Filter.Tendsto g x (nhds b)\nâŠ¢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) x (nhds (HMul.hMul a b))","decl":"@[to_additive]\ntheorem Filter.Tendsto.mul {f g : Î± â†’ M} {x : Filter Î±} {a b : M} (hf : Tendsto f x (ğ“ a))\n    (hg : Tendsto g x (ğ“ b)) : Tendsto (fun x => f x * g x) x (ğ“ (a * b)) :=\n  tendsto_mul.comp (hf.prod_mk_nhds hg)\n\n"}
{"name":"Filter.Tendsto.const_mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_2\nM : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Mul M\ninstâœ : ContinuousMul M\nb c : M\nf : Î± â†’ M\nl : Filter Î±\nh : Filter.Tendsto (fun k => f k) l (nhds c)\nâŠ¢ Filter.Tendsto (fun k => HMul.hMul b (f k)) l (nhds (HMul.hMul b c))","decl":"@[to_additive]\ntheorem Filter.Tendsto.const_mul (b : M) {c : M} {f : Î± â†’ M} {l : Filter Î±}\n    (h : Tendsto (fun k : Î± => f k) l (ğ“ c)) : Tendsto (fun k : Î± => b * f k) l (ğ“ (b * c)) :=\n  tendsto_const_nhds.mul h\n\n"}
{"name":"Filter.Tendsto.const_add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_2\nM : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Add M\ninstâœ : ContinuousAdd M\nb c : M\nf : Î± â†’ M\nl : Filter Î±\nh : Filter.Tendsto (fun k => f k) l (nhds c)\nâŠ¢ Filter.Tendsto (fun k => HAdd.hAdd b (f k)) l (nhds (HAdd.hAdd b c))","decl":"@[to_additive]\ntheorem Filter.Tendsto.const_mul (b : M) {c : M} {f : Î± â†’ M} {l : Filter Î±}\n    (h : Tendsto (fun k : Î± => f k) l (ğ“ c)) : Tendsto (fun k : Î± => b * f k) l (ğ“ (b * c)) :=\n  tendsto_const_nhds.mul h\n\n"}
{"name":"Filter.Tendsto.mul_const","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_2\nM : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Mul M\ninstâœ : ContinuousMul M\nb c : M\nf : Î± â†’ M\nl : Filter Î±\nh : Filter.Tendsto (fun k => f k) l (nhds c)\nâŠ¢ Filter.Tendsto (fun k => HMul.hMul (f k) b) l (nhds (HMul.hMul c b))","decl":"@[to_additive]\ntheorem Filter.Tendsto.mul_const (b : M) {c : M} {f : Î± â†’ M} {l : Filter Î±}\n    (h : Tendsto (fun k : Î± => f k) l (ğ“ c)) : Tendsto (fun k : Î± => f k * b) l (ğ“ (c * b)) :=\n  h.mul tendsto_const_nhds\n\n"}
{"name":"Filter.Tendsto.add_const","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_2\nM : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Add M\ninstâœ : ContinuousAdd M\nb c : M\nf : Î± â†’ M\nl : Filter Î±\nh : Filter.Tendsto (fun k => f k) l (nhds c)\nâŠ¢ Filter.Tendsto (fun k => HAdd.hAdd (f k) b) l (nhds (HAdd.hAdd c b))","decl":"@[to_additive]\ntheorem Filter.Tendsto.mul_const (b : M) {c : M} {f : Î± â†’ M} {l : Filter Î±}\n    (h : Tendsto (fun k : Î± => f k) l (ğ“ c)) : Tendsto (fun k : Î± => f k * b) l (ğ“ (c * b)) :=\n  h.mul tendsto_const_nhds\n\n"}
{"name":"le_nhds_add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Add M\ninstâœ : ContinuousAdd M\na b : M\nâŠ¢ LE.le (HAdd.hAdd (nhds a) (nhds b)) (nhds (HAdd.hAdd a b))","decl":"@[to_additive]\ntheorem le_nhds_mul (a b : M) : ğ“ a * ğ“ b â‰¤ ğ“ (a * b) := by\n  rw [â† mapâ‚‚_mul, â† map_uncurry_prod, â† nhds_prod_eq]\n  exact continuous_mul.tendsto _\n\n"}
{"name":"le_nhds_mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Mul M\ninstâœ : ContinuousMul M\na b : M\nâŠ¢ LE.le (HMul.hMul (nhds a) (nhds b)) (nhds (HMul.hMul a b))","decl":"@[to_additive]\ntheorem le_nhds_mul (a b : M) : ğ“ a * ğ“ b â‰¤ ğ“ (a * b) := by\n  rw [â† mapâ‚‚_mul, â† map_uncurry_prod, â† nhds_prod_eq]\n  exact continuous_mul.tendsto _\n\n"}
{"name":"nhds_zero_add_nhds","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\ninstâœÂ² : AddZeroClass M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousAdd M\na : M\nâŠ¢ Eq (HAdd.hAdd (nhds 0) (nhds a)) (nhds a)","decl":"@[to_additive (attr := simp)]\ntheorem nhds_one_mul_nhds {M} [MulOneClass M] [TopologicalSpace M] [ContinuousMul M] (a : M) :\n    ğ“ (1 : M) * ğ“ a = ğ“ a :=\n  ((le_nhds_mul _ _).trans_eq <| congr_arg _ (one_mul a)).antisymm <|\n    le_mul_of_one_le_left' <| pure_le_nhds 1\n\n"}
{"name":"nhds_one_mul_nhds","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\ninstâœÂ² : MulOneClass M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousMul M\na : M\nâŠ¢ Eq (HMul.hMul (nhds 1) (nhds a)) (nhds a)","decl":"@[to_additive (attr := simp)]\ntheorem nhds_one_mul_nhds {M} [MulOneClass M] [TopologicalSpace M] [ContinuousMul M] (a : M) :\n    ğ“ (1 : M) * ğ“ a = ğ“ a :=\n  ((le_nhds_mul _ _).trans_eq <| congr_arg _ (one_mul a)).antisymm <|\n    le_mul_of_one_le_left' <| pure_le_nhds 1\n\n"}
{"name":"nhds_add_nhds_zero","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\ninstâœÂ² : AddZeroClass M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousAdd M\na : M\nâŠ¢ Eq (HAdd.hAdd (nhds a) (nhds 0)) (nhds a)","decl":"@[to_additive (attr := simp)]\ntheorem nhds_mul_nhds_one {M} [MulOneClass M] [TopologicalSpace M] [ContinuousMul M] (a : M) :\n    ğ“ a * ğ“ 1 = ğ“ a :=\n  ((le_nhds_mul _ _).trans_eq <| congr_arg _ (mul_one a)).antisymm <|\n    le_mul_of_one_le_right' <| pure_le_nhds 1\n\n"}
{"name":"nhds_mul_nhds_one","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\ninstâœÂ² : MulOneClass M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousMul M\na : M\nâŠ¢ Eq (HMul.hMul (nhds a) (nhds 1)) (nhds a)","decl":"@[to_additive (attr := simp)]\ntheorem nhds_mul_nhds_one {M} [MulOneClass M] [TopologicalSpace M] [ContinuousMul M] (a : M) :\n    ğ“ a * ğ“ 1 = ğ“ a :=\n  ((le_nhds_mul _ _).trans_eq <| congr_arg _ (mul_one a)).antisymm <|\n    le_mul_of_one_le_right' <| pure_le_nhds 1\n\n"}
{"name":"Filter.TendstoNhdsWithinIoi.const_mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_2\nğ•œ : Type u_6\ninstâœâ¶ : Preorder ğ•œ\ninstâœâµ : Zero ğ•œ\ninstâœâ´ : Mul ğ•œ\ninstâœÂ³ : TopologicalSpace ğ•œ\ninstâœÂ² : ContinuousMul ğ•œ\nl : Filter Î±\nf : Î± â†’ ğ•œ\nb c : ğ•œ\nhb : LT.lt 0 b\ninstâœÂ¹ : PosMulStrictMono ğ•œ\ninstâœ : PosMulReflectLT ğ•œ\nh : Filter.Tendsto f l (nhdsWithin c (Set.Ioi c))\nâŠ¢ Filter.Tendsto (fun a => HMul.hMul b (f a)) l (nhdsWithin (HMul.hMul b c) (Set.Ioi (HMul.hMul b c)))","decl":"theorem Filter.TendstoNhdsWithinIoi.const_mul [PosMulStrictMono ğ•œ] [PosMulReflectLT ğ•œ]\n    (h : Tendsto f l (ğ“[>] c)) : Tendsto (fun a => b * f a) l (ğ“[>] (b * c)) :=\n  tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _\n      ((tendsto_nhds_of_tendsto_nhdsWithin h).const_mul b) <|\n    (tendsto_nhdsWithin_iff.mp h).2.mono fun _ => (mul_lt_mul_left hb).mpr\n\n"}
{"name":"Filter.TendstoNhdsWithinIio.const_mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_2\nğ•œ : Type u_6\ninstâœâ¶ : Preorder ğ•œ\ninstâœâµ : Zero ğ•œ\ninstâœâ´ : Mul ğ•œ\ninstâœÂ³ : TopologicalSpace ğ•œ\ninstâœÂ² : ContinuousMul ğ•œ\nl : Filter Î±\nf : Î± â†’ ğ•œ\nb c : ğ•œ\nhb : LT.lt 0 b\ninstâœÂ¹ : PosMulStrictMono ğ•œ\ninstâœ : PosMulReflectLT ğ•œ\nh : Filter.Tendsto f l (nhdsWithin c (Set.Iio c))\nâŠ¢ Filter.Tendsto (fun a => HMul.hMul b (f a)) l (nhdsWithin (HMul.hMul b c) (Set.Iio (HMul.hMul b c)))","decl":"theorem Filter.TendstoNhdsWithinIio.const_mul [PosMulStrictMono ğ•œ] [PosMulReflectLT ğ•œ]\n    (h : Tendsto f l (ğ“[<] c)) : Tendsto (fun a => b * f a) l (ğ“[<] (b * c)) :=\n  tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _\n      ((tendsto_nhds_of_tendsto_nhdsWithin h).const_mul b) <|\n    (tendsto_nhdsWithin_iff.mp h).2.mono fun _ => (mul_lt_mul_left hb).mpr\n\n"}
{"name":"Filter.TendstoNhdsWithinIoi.mul_const","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_2\nğ•œ : Type u_6\ninstâœâ¶ : Preorder ğ•œ\ninstâœâµ : Zero ğ•œ\ninstâœâ´ : Mul ğ•œ\ninstâœÂ³ : TopologicalSpace ğ•œ\ninstâœÂ² : ContinuousMul ğ•œ\nl : Filter Î±\nf : Î± â†’ ğ•œ\nb c : ğ•œ\nhb : LT.lt 0 b\ninstâœÂ¹ : MulPosStrictMono ğ•œ\ninstâœ : MulPosReflectLT ğ•œ\nh : Filter.Tendsto f l (nhdsWithin c (Set.Ioi c))\nâŠ¢ Filter.Tendsto (fun a => HMul.hMul (f a) b) l (nhdsWithin (HMul.hMul c b) (Set.Ioi (HMul.hMul c b)))","decl":"theorem Filter.TendstoNhdsWithinIoi.mul_const [MulPosStrictMono ğ•œ] [MulPosReflectLT ğ•œ]\n    (h : Tendsto f l (ğ“[>] c)) : Tendsto (fun a => f a * b) l (ğ“[>] (c * b)) :=\n  tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _\n      ((tendsto_nhds_of_tendsto_nhdsWithin h).mul_const b) <|\n    (tendsto_nhdsWithin_iff.mp h).2.mono fun _ => (mul_lt_mul_right hb).mpr\n\n"}
{"name":"Filter.TendstoNhdsWithinIio.mul_const","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_2\nğ•œ : Type u_6\ninstâœâ¶ : Preorder ğ•œ\ninstâœâµ : Zero ğ•œ\ninstâœâ´ : Mul ğ•œ\ninstâœÂ³ : TopologicalSpace ğ•œ\ninstâœÂ² : ContinuousMul ğ•œ\nl : Filter Î±\nf : Î± â†’ ğ•œ\nb c : ğ•œ\nhb : LT.lt 0 b\ninstâœÂ¹ : MulPosStrictMono ğ•œ\ninstâœ : MulPosReflectLT ğ•œ\nh : Filter.Tendsto f l (nhdsWithin c (Set.Iio c))\nâŠ¢ Filter.Tendsto (fun a => HMul.hMul (f a) b) l (nhdsWithin (HMul.hMul c b) (Set.Iio (HMul.hMul c b)))","decl":"theorem Filter.TendstoNhdsWithinIio.mul_const [MulPosStrictMono ğ•œ] [MulPosReflectLT ğ•œ]\n    (h : Tendsto f l (ğ“[<] c)) : Tendsto (fun a => f a * b) l (ğ“[<] (c * b)) :=\n  tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _\n      ((tendsto_nhds_of_tendsto_nhdsWithin h).mul_const b) <|\n    (tendsto_nhdsWithin_iff.mp h).2.mono fun _ => (mul_lt_mul_right hb).mpr\n\n"}
{"name":"Specializes.add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Add M\ninstâœ : ContinuousAdd M\na b c d : M\nhab : Specializes a b\nhcd : Specializes c d\nâŠ¢ Specializes (HAdd.hAdd a c) (HAdd.hAdd b d)","decl":"@[to_additive]\nprotected theorem Specializes.mul {a b c d : M} (hab : a â¤³ b) (hcd : c â¤³ d) : (a * c) â¤³ (b * d) :=\n  hab.smul hcd\n\n"}
{"name":"Specializes.mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Mul M\ninstâœ : ContinuousMul M\na b c d : M\nhab : Specializes a b\nhcd : Specializes c d\nâŠ¢ Specializes (HMul.hMul a c) (HMul.hMul b d)","decl":"@[to_additive]\nprotected theorem Specializes.mul {a b c d : M} (hab : a â¤³ b) (hcd : c â¤³ d) : (a * c) â¤³ (b * d) :=\n  hab.smul hcd\n\n"}
{"name":"Inseparable.mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Mul M\ninstâœ : ContinuousMul M\na b c d : M\nhab : Inseparable a b\nhcd : Inseparable c d\nâŠ¢ Inseparable (HMul.hMul a c) (HMul.hMul b d)","decl":"@[to_additive]\nprotected theorem Inseparable.mul {a b c d : M} (hab : Inseparable a b) (hcd : Inseparable c d) :\n    Inseparable (a * c) (b * d) :=\n  hab.smul hcd\n\n"}
{"name":"Inseparable.add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Add M\ninstâœ : ContinuousAdd M\na b c d : M\nhab : Inseparable a b\nhcd : Inseparable c d\nâŠ¢ Inseparable (HAdd.hAdd a c) (HAdd.hAdd b d)","decl":"@[to_additive]\nprotected theorem Inseparable.mul {a b c d : M} (hab : Inseparable a b) (hcd : Inseparable c d) :\n    Inseparable (a * c) (b * d) :=\n  hab.smul hcd\n\n"}
{"name":"Specializes.nsmul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\ninstâœÂ² : AddMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousAdd M\na b : M\nh : Specializes a b\nn : Nat\nâŠ¢ Specializes (HSMul.hSMul n a) (HSMul.hSMul n b)","decl":"@[to_additive]\nprotected theorem Specializes.pow {M : Type*} [Monoid M] [TopologicalSpace M] [ContinuousMul M]\n    {a b : M} (h : a â¤³ b) (n : â„•) : (a ^ n) â¤³ (b ^ n) :=\n  Nat.recOn n (by simp only [pow_zero, specializes_rfl]) fun _ ihn â†¦ by\n    simpa only [pow_succ] using ihn.mul h\n\n"}
{"name":"Specializes.pow","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\ninstâœÂ² : Monoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousMul M\na b : M\nh : Specializes a b\nn : Nat\nâŠ¢ Specializes (HPow.hPow a n) (HPow.hPow b n)","decl":"@[to_additive]\nprotected theorem Specializes.pow {M : Type*} [Monoid M] [TopologicalSpace M] [ContinuousMul M]\n    {a b : M} (h : a â¤³ b) (n : â„•) : (a ^ n) â¤³ (b ^ n) :=\n  Nat.recOn n (by simp only [pow_zero, specializes_rfl]) fun _ ihn â†¦ by\n    simpa only [pow_succ] using ihn.mul h\n\n"}
{"name":"Inseparable.pow","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\ninstâœÂ² : Monoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousMul M\na b : M\nh : Inseparable a b\nn : Nat\nâŠ¢ Inseparable (HPow.hPow a n) (HPow.hPow b n)","decl":"@[to_additive]\nprotected theorem Inseparable.pow {M : Type*} [Monoid M] [TopologicalSpace M] [ContinuousMul M]\n    {a b : M} (h : Inseparable a b) (n : â„•) : Inseparable (a ^ n) (b ^ n) :=\n  (h.specializes.pow n).antisymm (h.specializes'.pow n)\n\n"}
{"name":"Inseparable.nsmul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\ninstâœÂ² : AddMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousAdd M\na b : M\nh : Inseparable a b\nn : Nat\nâŠ¢ Inseparable (HSMul.hSMul n a) (HSMul.hSMul n b)","decl":"@[to_additive]\nprotected theorem Inseparable.pow {M : Type*} [Monoid M] [TopologicalSpace M] [ContinuousMul M]\n    {a b : M} (h : Inseparable a b) (n : â„•) : Inseparable (a ^ n) (b ^ n) :=\n  (h.specializes.pow n).antisymm (h.specializes'.pow n)\n\n"}
{"name":"Filter.Tendsto.val_units","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nN : Type u_4\ninstâœâ´ : TopologicalSpace N\ninstâœÂ³ : Monoid N\ninstâœÂ² : ContinuousMul N\ninstâœÂ¹ : T2Space N\nf : Î¹ â†’ Units N\nrâ‚ râ‚‚ : N\nl : Filter Î¹\ninstâœ : l.NeBot\nhâ‚ : Filter.Tendsto (fun x => â†‘(f x)) l (nhds râ‚)\nhâ‚‚ : Filter.Tendsto (fun x => â†‘(Inv.inv (f x))) l (nhds râ‚‚)\nâŠ¢ Eq (â†‘(hâ‚.units hâ‚‚)) râ‚","decl":"/-- Construct a unit from limits of units and their inverses. -/\n@[to_additive (attr := simps)\n  \"Construct an additive unit from limits of additive units and their negatives.\"]\ndef Filter.Tendsto.units [TopologicalSpace N] [Monoid N] [ContinuousMul N] [T2Space N]\n    {f : Î¹ â†’ NË£} {râ‚ râ‚‚ : N} {l : Filter Î¹} [l.NeBot] (hâ‚ : Tendsto (fun x => â†‘(f x)) l (ğ“ râ‚))\n    (hâ‚‚ : Tendsto (fun x => â†‘(f x)â»Â¹) l (ğ“ râ‚‚)) : NË£ where\n  val := râ‚\n  inv := râ‚‚\n  val_inv := by\n    symm\n    simpa using hâ‚.mul hâ‚‚\n  inv_val := by\n    symm\n    simpa using hâ‚‚.mul hâ‚\n\n"}
{"name":"Filter.Tendsto.val_inv_units","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nN : Type u_4\ninstâœâ´ : TopologicalSpace N\ninstâœÂ³ : Monoid N\ninstâœÂ² : ContinuousMul N\ninstâœÂ¹ : T2Space N\nf : Î¹ â†’ Units N\nrâ‚ râ‚‚ : N\nl : Filter Î¹\ninstâœ : l.NeBot\nhâ‚ : Filter.Tendsto (fun x => â†‘(f x)) l (nhds râ‚)\nhâ‚‚ : Filter.Tendsto (fun x => â†‘(Inv.inv (f x))) l (nhds râ‚‚)\nâŠ¢ Eq (â†‘(Inv.inv (hâ‚.units hâ‚‚))) râ‚‚","decl":"/-- Construct a unit from limits of units and their inverses. -/\n@[to_additive (attr := simps)\n  \"Construct an additive unit from limits of additive units and their negatives.\"]\ndef Filter.Tendsto.units [TopologicalSpace N] [Monoid N] [ContinuousMul N] [T2Space N]\n    {f : Î¹ â†’ NË£} {râ‚ râ‚‚ : N} {l : Filter Î¹} [l.NeBot] (hâ‚ : Tendsto (fun x => â†‘(f x)) l (ğ“ râ‚))\n    (hâ‚‚ : Tendsto (fun x => â†‘(f x)â»Â¹) l (ğ“ râ‚‚)) : NË£ where\n  val := râ‚\n  inv := râ‚‚\n  val_inv := by\n    symm\n    simpa using hâ‚.mul hâ‚‚\n  inv_val := by\n    symm\n    simpa using hâ‚‚.mul hâ‚\n\n"}
{"name":"Filter.Tendsto.val_neg_addUnits","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nN : Type u_4\ninstâœâ´ : TopologicalSpace N\ninstâœÂ³ : AddMonoid N\ninstâœÂ² : ContinuousAdd N\ninstâœÂ¹ : T2Space N\nf : Î¹ â†’ AddUnits N\nrâ‚ râ‚‚ : N\nl : Filter Î¹\ninstâœ : l.NeBot\nhâ‚ : Filter.Tendsto (fun x => â†‘(f x)) l (nhds râ‚)\nhâ‚‚ : Filter.Tendsto (fun x => â†‘(Neg.neg (f x))) l (nhds râ‚‚)\nâŠ¢ Eq (â†‘(Neg.neg (hâ‚.addUnits hâ‚‚))) râ‚‚","decl":"/-- Construct a unit from limits of units and their inverses. -/\n@[to_additive (attr := simps)\n  \"Construct an additive unit from limits of additive units and their negatives.\"]\ndef Filter.Tendsto.units [TopologicalSpace N] [Monoid N] [ContinuousMul N] [T2Space N]\n    {f : Î¹ â†’ NË£} {râ‚ râ‚‚ : N} {l : Filter Î¹} [l.NeBot] (hâ‚ : Tendsto (fun x => â†‘(f x)) l (ğ“ râ‚))\n    (hâ‚‚ : Tendsto (fun x => â†‘(f x)â»Â¹) l (ğ“ râ‚‚)) : NË£ where\n  val := râ‚\n  inv := râ‚‚\n  val_inv := by\n    symm\n    simpa using hâ‚.mul hâ‚‚\n  inv_val := by\n    symm\n    simpa using hâ‚‚.mul hâ‚\n\n"}
{"name":"Filter.Tendsto.val_addUnits","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nN : Type u_4\ninstâœâ´ : TopologicalSpace N\ninstâœÂ³ : AddMonoid N\ninstâœÂ² : ContinuousAdd N\ninstâœÂ¹ : T2Space N\nf : Î¹ â†’ AddUnits N\nrâ‚ râ‚‚ : N\nl : Filter Î¹\ninstâœ : l.NeBot\nhâ‚ : Filter.Tendsto (fun x => â†‘(f x)) l (nhds râ‚)\nhâ‚‚ : Filter.Tendsto (fun x => â†‘(Neg.neg (f x))) l (nhds râ‚‚)\nâŠ¢ Eq (â†‘(hâ‚.addUnits hâ‚‚)) râ‚","decl":"/-- Construct a unit from limits of units and their inverses. -/\n@[to_additive (attr := simps)\n  \"Construct an additive unit from limits of additive units and their negatives.\"]\ndef Filter.Tendsto.units [TopologicalSpace N] [Monoid N] [ContinuousMul N] [T2Space N]\n    {f : Î¹ â†’ NË£} {râ‚ râ‚‚ : N} {l : Filter Î¹} [l.NeBot] (hâ‚ : Tendsto (fun x => â†‘(f x)) l (ğ“ râ‚))\n    (hâ‚‚ : Tendsto (fun x => â†‘(f x)â»Â¹) l (ğ“ râ‚‚)) : NË£ where\n  val := râ‚\n  inv := râ‚‚\n  val_inv := by\n    symm\n    simpa using hâ‚.mul hâ‚‚\n  inv_val := by\n    symm\n    simpa using hâ‚‚.mul hâ‚\n\n"}
{"name":"ContinuousAt.mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Mul M\ninstâœ : ContinuousMul M\nf g : X â†’ M\nx : X\nhf : ContinuousAt f x\nhg : ContinuousAt g x\nâŠ¢ ContinuousAt (fun x => HMul.hMul (f x) (g x)) x","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousAt.mul {f g : X â†’ M} {x : X} (hf : ContinuousAt f x) (hg : ContinuousAt g x) :\n    ContinuousAt (fun x => f x * g x) x :=\n  Filter.Tendsto.mul hf hg\n\n"}
{"name":"ContinuousAt.add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Add M\ninstâœ : ContinuousAdd M\nf g : X â†’ M\nx : X\nhf : ContinuousAt f x\nhg : ContinuousAt g x\nâŠ¢ ContinuousAt (fun x => HAdd.hAdd (f x) (g x)) x","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousAt.mul {f g : X â†’ M} {x : X} (hf : ContinuousAt f x) (hg : ContinuousAt g x) :\n    ContinuousAt (fun x => f x * g x) x :=\n  Filter.Tendsto.mul hf hg\n\n"}
{"name":"ContinuousWithinAt.mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Mul M\ninstâœ : ContinuousMul M\nf g : X â†’ M\ns : Set X\nx : X\nhf : ContinuousWithinAt f s x\nhg : ContinuousWithinAt g s x\nâŠ¢ ContinuousWithinAt (fun x => HMul.hMul (f x) (g x)) s x","decl":"@[to_additive]\ntheorem ContinuousWithinAt.mul {f g : X â†’ M} {s : Set X} {x : X} (hf : ContinuousWithinAt f s x)\n    (hg : ContinuousWithinAt g s x) : ContinuousWithinAt (fun x => f x * g x) s x :=\n  Filter.Tendsto.mul hf hg\n\n"}
{"name":"ContinuousWithinAt.add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Add M\ninstâœ : ContinuousAdd M\nf g : X â†’ M\ns : Set X\nx : X\nhf : ContinuousWithinAt f s x\nhg : ContinuousWithinAt g s x\nâŠ¢ ContinuousWithinAt (fun x => HAdd.hAdd (f x) (g x)) s x","decl":"@[to_additive]\ntheorem ContinuousWithinAt.mul {f g : X â†’ M} {s : Set X} {x : X} (hf : ContinuousWithinAt f s x)\n    (hg : ContinuousWithinAt g s x) : ContinuousWithinAt (fun x => f x * g x) s x :=\n  Filter.Tendsto.mul hf hg\n\n"}
{"name":"Prod.continuousAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nN : Type u_4\ninstâœâµ : TopologicalSpace M\ninstâœâ´ : Add M\ninstâœÂ³ : ContinuousAdd M\ninstâœÂ² : TopologicalSpace N\ninstâœÂ¹ : Add N\ninstâœ : ContinuousAdd N\nâŠ¢ ContinuousAdd (Prod M N)","decl":"@[to_additive]\ninstance Prod.continuousMul [TopologicalSpace N] [Mul N] [ContinuousMul N] :\n    ContinuousMul (M Ã— N) :=\n  âŸ¨(continuous_fst.fst'.mul continuous_fst.snd').prod_mk\n      (continuous_snd.fst'.mul continuous_snd.snd')âŸ©\n\n"}
{"name":"Prod.continuousMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nN : Type u_4\ninstâœâµ : TopologicalSpace M\ninstâœâ´ : Mul M\ninstâœÂ³ : ContinuousMul M\ninstâœÂ² : TopologicalSpace N\ninstâœÂ¹ : Mul N\ninstâœ : ContinuousMul N\nâŠ¢ ContinuousMul (Prod M N)","decl":"@[to_additive]\ninstance Prod.continuousMul [TopologicalSpace N] [Mul N] [ContinuousMul N] :\n    ContinuousMul (M Ã— N) :=\n  âŸ¨(continuous_fst.fst'.mul continuous_fst.snd').prod_mk\n      (continuous_snd.fst'.mul continuous_snd.snd')âŸ©\n\n"}
{"name":"Pi.continuousMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nC : Î¹ â†’ Type u_6\ninstâœÂ² : (i : Î¹) â†’ TopologicalSpace (C i)\ninstâœÂ¹ : (i : Î¹) â†’ Mul (C i)\ninstâœ : âˆ€ (i : Î¹), ContinuousMul (C i)\nâŠ¢ ContinuousMul ((i : Î¹) â†’ C i)","decl":"@[to_additive]\ninstance Pi.continuousMul {C : Î¹ â†’ Type*} [âˆ€ i, TopologicalSpace (C i)] [âˆ€ i, Mul (C i)]\n    [âˆ€ i, ContinuousMul (C i)] : ContinuousMul (âˆ€ i, C i) where\n  continuous_mul :=\n    continuous_pi fun i => (continuous_apply i).fst'.mul (continuous_apply i).snd'\n\n"}
{"name":"Pi.continuousAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nC : Î¹ â†’ Type u_6\ninstâœÂ² : (i : Î¹) â†’ TopologicalSpace (C i)\ninstâœÂ¹ : (i : Î¹) â†’ Add (C i)\ninstâœ : âˆ€ (i : Î¹), ContinuousAdd (C i)\nâŠ¢ ContinuousAdd ((i : Î¹) â†’ C i)","decl":"@[to_additive]\ninstance Pi.continuousMul {C : Î¹ â†’ Type*} [âˆ€ i, TopologicalSpace (C i)] [âˆ€ i, Mul (C i)]\n    [âˆ€ i, ContinuousMul (C i)] : ContinuousMul (âˆ€ i, C i) where\n  continuous_mul :=\n    continuous_pi fun i => (continuous_apply i).fst'.mul (continuous_apply i).snd'\n\n"}
{"name":"Pi.continuousAdd'","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Add M\ninstâœ : ContinuousAdd M\nâŠ¢ ContinuousAdd (Î¹ â†’ M)","decl":"/-- A version of `Pi.continuousMul` for non-dependent functions. It is needed because sometimes\nLean 3 fails to use `Pi.continuousMul` for non-dependent functions. -/\n@[to_additive \"A version of `Pi.continuousAdd` for non-dependent functions. It is needed\nbecause sometimes Lean fails to use `Pi.continuousAdd` for non-dependent functions.\"]\ninstance Pi.continuousMul' : ContinuousMul (Î¹ â†’ M) :=\n  Pi.continuousMul\n\n"}
{"name":"Pi.continuousMul'","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Mul M\ninstâœ : ContinuousMul M\nâŠ¢ ContinuousMul (Î¹ â†’ M)","decl":"/-- A version of `Pi.continuousMul` for non-dependent functions. It is needed because sometimes\nLean 3 fails to use `Pi.continuousMul` for non-dependent functions. -/\n@[to_additive \"A version of `Pi.continuousAdd` for non-dependent functions. It is needed\nbecause sometimes Lean fails to use `Pi.continuousAdd` for non-dependent functions.\"]\ninstance Pi.continuousMul' : ContinuousMul (Î¹ â†’ M) :=\n  Pi.continuousMul\n\n"}
{"name":"continuousMul_of_discreteTopology","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"N : Type u_4\ninstâœÂ² : TopologicalSpace N\ninstâœÂ¹ : Mul N\ninstâœ : DiscreteTopology N\nâŠ¢ ContinuousMul N","decl":"@[to_additive]\ninstance (priority := 100) continuousMul_of_discreteTopology [TopologicalSpace N] [Mul N]\n    [DiscreteTopology N] : ContinuousMul N :=\n  âŸ¨continuous_of_discreteTopologyâŸ©\n\n"}
{"name":"continuousAdd_of_discreteTopology","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"N : Type u_4\ninstâœÂ² : TopologicalSpace N\ninstâœÂ¹ : Add N\ninstâœ : DiscreteTopology N\nâŠ¢ ContinuousAdd N","decl":"@[to_additive]\ninstance (priority := 100) continuousMul_of_discreteTopology [TopologicalSpace N] [Mul N]\n    [DiscreteTopology N] : ContinuousMul N :=\n  âŸ¨continuous_of_discreteTopologyâŸ©\n\n"}
{"name":"ContinuousMul.of_nhds_one","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u\ninstâœÂ¹ : Monoid M\ninstâœ : TopologicalSpace M\nhmul : Filter.Tendsto (Function.uncurry fun x1 x2 => HMul.hMul x1 x2) (SProd.sprod (nhds 1) (nhds 1)) (nhds 1)\nhleft : âˆ€ (xâ‚€ : M), Eq (nhds xâ‚€) (Filter.map (fun x => HMul.hMul xâ‚€ x) (nhds 1))\nhright : âˆ€ (xâ‚€ : M), Eq (nhds xâ‚€) (Filter.map (fun x => HMul.hMul x xâ‚€) (nhds 1))\nâŠ¢ ContinuousMul M","decl":"@[to_additive]\ntheorem ContinuousMul.of_nhds_one {M : Type u} [Monoid M] [TopologicalSpace M]\n    (hmul : Tendsto (uncurry ((Â· * Â·) : M â†’ M â†’ M)) (ğ“ 1 Ã—Ë¢ ğ“ 1) <| ğ“ 1)\n    (hleft : âˆ€ xâ‚€ : M, ğ“ xâ‚€ = map (fun x => xâ‚€ * x) (ğ“ 1))\n    (hright : âˆ€ xâ‚€ : M, ğ“ xâ‚€ = map (fun x => x * xâ‚€) (ğ“ 1)) : ContinuousMul M :=\n  âŸ¨by\n    rw [continuous_iff_continuousAt]\n    rintro âŸ¨xâ‚€, yâ‚€âŸ©\n    have key : (fun p : M Ã— M => xâ‚€ * p.1 * (p.2 * yâ‚€)) =\n        ((fun x => xâ‚€ * x) âˆ˜ fun x => x * yâ‚€) âˆ˜ uncurry (Â· * Â·) := by\n      ext p\n      simp [uncurry, mul_assoc]\n    have keyâ‚‚ : ((fun x => xâ‚€ * x) âˆ˜ fun x => yâ‚€ * x) = fun x => xâ‚€ * yâ‚€ * x := by\n      ext x\n      simp [mul_assoc]\n    calc\n      map (uncurry (Â· * Â·)) (ğ“ (xâ‚€, yâ‚€)) = map (uncurry (Â· * Â·)) (ğ“ xâ‚€ Ã—Ë¢ ğ“ yâ‚€) := by\n        rw [nhds_prod_eq]\n      _ = map (fun p : M Ã— M => xâ‚€ * p.1 * (p.2 * yâ‚€)) (ğ“ 1 Ã—Ë¢ ğ“ 1) := by\n        -- Porting note: `rw` was able to prove this\n        -- Now it fails with `failed to rewrite using equation theorems for 'Function.uncurry'`\n        -- and `failed to rewrite using equation theorems for 'Function.comp'`.\n        -- Removing those two lemmas, the `rw` would succeed, but then needs a `rfl`.\n        simp (config := { unfoldPartialApp := true }) only [uncurry]\n        simp_rw [hleft xâ‚€, hright yâ‚€, prod_map_map_eq, Filter.map_map, Function.comp_def]\n      _ = map ((fun x => xâ‚€ * x) âˆ˜ fun x => x * yâ‚€) (map (uncurry (Â· * Â·)) (ğ“ 1 Ã—Ë¢ ğ“ 1)) := by\n        rw [key, â† Filter.map_map]\n      _ â‰¤ map ((fun x : M => xâ‚€ * x) âˆ˜ fun x => x * yâ‚€) (ğ“ 1) := map_mono hmul\n      _ = ğ“ (xâ‚€ * yâ‚€) := by\n        rw [â† Filter.map_map, â† hright, hleft yâ‚€, Filter.map_map, keyâ‚‚, â† hleft]âŸ©\n\n"}
{"name":"ContinuousAdd.of_nhds_zero","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u\ninstâœÂ¹ : AddMonoid M\ninstâœ : TopologicalSpace M\nhmul : Filter.Tendsto (Function.uncurry fun x1 x2 => HAdd.hAdd x1 x2) (SProd.sprod (nhds 0) (nhds 0)) (nhds 0)\nhleft : âˆ€ (xâ‚€ : M), Eq (nhds xâ‚€) (Filter.map (fun x => HAdd.hAdd xâ‚€ x) (nhds 0))\nhright : âˆ€ (xâ‚€ : M), Eq (nhds xâ‚€) (Filter.map (fun x => HAdd.hAdd x xâ‚€) (nhds 0))\nâŠ¢ ContinuousAdd M","decl":"@[to_additive]\ntheorem ContinuousMul.of_nhds_one {M : Type u} [Monoid M] [TopologicalSpace M]\n    (hmul : Tendsto (uncurry ((Â· * Â·) : M â†’ M â†’ M)) (ğ“ 1 Ã—Ë¢ ğ“ 1) <| ğ“ 1)\n    (hleft : âˆ€ xâ‚€ : M, ğ“ xâ‚€ = map (fun x => xâ‚€ * x) (ğ“ 1))\n    (hright : âˆ€ xâ‚€ : M, ğ“ xâ‚€ = map (fun x => x * xâ‚€) (ğ“ 1)) : ContinuousMul M :=\n  âŸ¨by\n    rw [continuous_iff_continuousAt]\n    rintro âŸ¨xâ‚€, yâ‚€âŸ©\n    have key : (fun p : M Ã— M => xâ‚€ * p.1 * (p.2 * yâ‚€)) =\n        ((fun x => xâ‚€ * x) âˆ˜ fun x => x * yâ‚€) âˆ˜ uncurry (Â· * Â·) := by\n      ext p\n      simp [uncurry, mul_assoc]\n    have keyâ‚‚ : ((fun x => xâ‚€ * x) âˆ˜ fun x => yâ‚€ * x) = fun x => xâ‚€ * yâ‚€ * x := by\n      ext x\n      simp [mul_assoc]\n    calc\n      map (uncurry (Â· * Â·)) (ğ“ (xâ‚€, yâ‚€)) = map (uncurry (Â· * Â·)) (ğ“ xâ‚€ Ã—Ë¢ ğ“ yâ‚€) := by\n        rw [nhds_prod_eq]\n      _ = map (fun p : M Ã— M => xâ‚€ * p.1 * (p.2 * yâ‚€)) (ğ“ 1 Ã—Ë¢ ğ“ 1) := by\n        -- Porting note: `rw` was able to prove this\n        -- Now it fails with `failed to rewrite using equation theorems for 'Function.uncurry'`\n        -- and `failed to rewrite using equation theorems for 'Function.comp'`.\n        -- Removing those two lemmas, the `rw` would succeed, but then needs a `rfl`.\n        simp (config := { unfoldPartialApp := true }) only [uncurry]\n        simp_rw [hleft xâ‚€, hright yâ‚€, prod_map_map_eq, Filter.map_map, Function.comp_def]\n      _ = map ((fun x => xâ‚€ * x) âˆ˜ fun x => x * yâ‚€) (map (uncurry (Â· * Â·)) (ğ“ 1 Ã—Ë¢ ğ“ 1)) := by\n        rw [key, â† Filter.map_map]\n      _ â‰¤ map ((fun x : M => xâ‚€ * x) âˆ˜ fun x => x * yâ‚€) (ğ“ 1) := map_mono hmul\n      _ = ğ“ (xâ‚€ * yâ‚€) := by\n        rw [â† Filter.map_map, â† hright, hleft yâ‚€, Filter.map_map, keyâ‚‚, â† hleft]âŸ©\n\n"}
{"name":"continuousAdd_of_comm_of_nhds_zero","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : TopologicalSpace M\nhmul : Filter.Tendsto (Function.uncurry fun x1 x2 => HAdd.hAdd x1 x2) (SProd.sprod (nhds 0) (nhds 0)) (nhds 0)\nhleft : âˆ€ (xâ‚€ : M), Eq (nhds xâ‚€) (Filter.map (fun x => HAdd.hAdd xâ‚€ x) (nhds 0))\nâŠ¢ ContinuousAdd M","decl":"@[to_additive]\ntheorem continuousMul_of_comm_of_nhds_one (M : Type u) [CommMonoid M] [TopologicalSpace M]\n    (hmul : Tendsto (uncurry ((Â· * Â·) : M â†’ M â†’ M)) (ğ“ 1 Ã—Ë¢ ğ“ 1) (ğ“ 1))\n    (hleft : âˆ€ xâ‚€ : M, ğ“ xâ‚€ = map (fun x => xâ‚€ * x) (ğ“ 1)) : ContinuousMul M := by\n  apply ContinuousMul.of_nhds_one hmul hleft\n  intro xâ‚€\n  simp_rw [mul_comm, hleft xâ‚€]\n\n"}
{"name":"continuousMul_of_comm_of_nhds_one","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u\ninstâœÂ¹ : CommMonoid M\ninstâœ : TopologicalSpace M\nhmul : Filter.Tendsto (Function.uncurry fun x1 x2 => HMul.hMul x1 x2) (SProd.sprod (nhds 1) (nhds 1)) (nhds 1)\nhleft : âˆ€ (xâ‚€ : M), Eq (nhds xâ‚€) (Filter.map (fun x => HMul.hMul xâ‚€ x) (nhds 1))\nâŠ¢ ContinuousMul M","decl":"@[to_additive]\ntheorem continuousMul_of_comm_of_nhds_one (M : Type u) [CommMonoid M] [TopologicalSpace M]\n    (hmul : Tendsto (uncurry ((Â· * Â·) : M â†’ M â†’ M)) (ğ“ 1 Ã—Ë¢ ğ“ 1) (ğ“ 1))\n    (hleft : âˆ€ xâ‚€ : M, ğ“ xâ‚€ = map (fun x => xâ‚€ * x) (ğ“ 1)) : ContinuousMul M := by\n  apply ContinuousMul.of_nhds_one hmul hleft\n  intro xâ‚€\n  simp_rw [mul_comm, hleft xâ‚€]\n\n"}
{"name":"isClosed_setOf_map_one","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Mâ‚ : Type u_6\nMâ‚‚ : Type u_7\ninstâœÂ³ : TopologicalSpace Mâ‚‚\ninstâœÂ² : T2Space Mâ‚‚\ninstâœÂ¹ : One Mâ‚\ninstâœ : One Mâ‚‚\nâŠ¢ IsClosed (setOf fun f => Eq (f 1) 1)","decl":"@[to_additive]\ntheorem isClosed_setOf_map_one [One Mâ‚] [One Mâ‚‚] : IsClosed { f : Mâ‚ â†’ Mâ‚‚ | f 1 = 1 } :=\n  isClosed_eq (continuous_apply 1) continuous_const\n\n"}
{"name":"isClosed_setOf_map_zero","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Mâ‚ : Type u_6\nMâ‚‚ : Type u_7\ninstâœÂ³ : TopologicalSpace Mâ‚‚\ninstâœÂ² : T2Space Mâ‚‚\ninstâœÂ¹ : Zero Mâ‚\ninstâœ : Zero Mâ‚‚\nâŠ¢ IsClosed (setOf fun f => Eq (f 0) 0)","decl":"@[to_additive]\ntheorem isClosed_setOf_map_one [One Mâ‚] [One Mâ‚‚] : IsClosed { f : Mâ‚ â†’ Mâ‚‚ | f 1 = 1 } :=\n  isClosed_eq (continuous_apply 1) continuous_const\n\n"}
{"name":"isClosed_setOf_map_mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Mâ‚ : Type u_6\nMâ‚‚ : Type u_7\ninstâœâ´ : TopologicalSpace Mâ‚‚\ninstâœÂ³ : T2Space Mâ‚‚\ninstâœÂ² : Mul Mâ‚\ninstâœÂ¹ : Mul Mâ‚‚\ninstâœ : ContinuousMul Mâ‚‚\nâŠ¢ IsClosed (setOf fun f => âˆ€ (x y : Mâ‚), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y)))","decl":"@[to_additive]\ntheorem isClosed_setOf_map_mul [Mul Mâ‚] [Mul Mâ‚‚] [ContinuousMul Mâ‚‚] :\n    IsClosed { f : Mâ‚ â†’ Mâ‚‚ | âˆ€ x y, f (x * y) = f x * f y } := by\n  simp only [setOf_forall]\n  exact\n    isClosed_iInter fun x =>\n      isClosed_iInter fun y =>\n        isClosed_eq (continuous_apply _)\n          (by continuity)\n\n"}
{"name":"isClosed_setOf_map_add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Mâ‚ : Type u_6\nMâ‚‚ : Type u_7\ninstâœâ´ : TopologicalSpace Mâ‚‚\ninstâœÂ³ : T2Space Mâ‚‚\ninstâœÂ² : Add Mâ‚\ninstâœÂ¹ : Add Mâ‚‚\ninstâœ : ContinuousAdd Mâ‚‚\nâŠ¢ IsClosed (setOf fun f => âˆ€ (x y : Mâ‚), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y)))","decl":"@[to_additive]\ntheorem isClosed_setOf_map_mul [Mul Mâ‚] [Mul Mâ‚‚] [ContinuousMul Mâ‚‚] :\n    IsClosed { f : Mâ‚ â†’ Mâ‚‚ | âˆ€ x y, f (x * y) = f x * f y } := by\n  simp only [setOf_forall]\n  exact\n    isClosed_iInter fun x =>\n      isClosed_iInter fun y =>\n        isClosed_eq (continuous_apply _)\n          (by continuity)\n\n"}
{"name":"mulHomOfMemClosureRangeCoe_apply","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Mâ‚ : Type u_6\nMâ‚‚ : Type u_7\ninstâœâ¶ : TopologicalSpace Mâ‚‚\ninstâœâµ : T2Space Mâ‚‚\ninstâœâ´ : Mul Mâ‚\ninstâœÂ³ : Mul Mâ‚‚\ninstâœÂ² : ContinuousMul Mâ‚‚\nF : Type u_8\ninstâœÂ¹ : FunLike F Mâ‚ Mâ‚‚\ninstâœ : MulHomClass F Mâ‚ Mâ‚‚\nf : Mâ‚ â†’ Mâ‚‚\nhf : Membership.mem (closure (Set.range fun f x => f x)) f\nâŠ¢ Eq (â‡‘(mulHomOfMemClosureRangeCoe f hf)) f","decl":"/-- Construct a bundled semigroup homomorphism `Mâ‚ â†’â‚™* Mâ‚‚` from a function `f` and a proof that it\nbelongs to the closure of the range of the coercion from `Mâ‚ â†’â‚™* Mâ‚‚` (or another type of bundled\nhomomorphisms that has a `MulHomClass` instance) to `Mâ‚ â†’ Mâ‚‚`. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"Construct a bundled additive semigroup homomorphism `Mâ‚ â†’â‚™+ Mâ‚‚` from a function `f`\nand a proof that it belongs to the closure of the range of the coercion from `Mâ‚ â†’â‚™+ Mâ‚‚` (or another\ntype of bundled homomorphisms that has an `AddHomClass` instance) to `Mâ‚ â†’ Mâ‚‚`.\"]\ndef mulHomOfMemClosureRangeCoe (f : Mâ‚ â†’ Mâ‚‚)\n    (hf : f âˆˆ closure (range fun (f : F) (x : Mâ‚) => f x)) : Mâ‚ â†’â‚™* Mâ‚‚ where\n  toFun := f\n  map_mul' := (isClosed_setOf_map_mul Mâ‚ Mâ‚‚).closure_subset_iff.2 (range_subset_iff.2 map_mul) hf\n\n"}
{"name":"addHomOfMemClosureRangeCoe_apply","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Mâ‚ : Type u_6\nMâ‚‚ : Type u_7\ninstâœâ¶ : TopologicalSpace Mâ‚‚\ninstâœâµ : T2Space Mâ‚‚\ninstâœâ´ : Add Mâ‚\ninstâœÂ³ : Add Mâ‚‚\ninstâœÂ² : ContinuousAdd Mâ‚‚\nF : Type u_8\ninstâœÂ¹ : FunLike F Mâ‚ Mâ‚‚\ninstâœ : AddHomClass F Mâ‚ Mâ‚‚\nf : Mâ‚ â†’ Mâ‚‚\nhf : Membership.mem (closure (Set.range fun f x => f x)) f\nâŠ¢ Eq (â‡‘(addHomOfMemClosureRangeCoe f hf)) f","decl":"/-- Construct a bundled semigroup homomorphism `Mâ‚ â†’â‚™* Mâ‚‚` from a function `f` and a proof that it\nbelongs to the closure of the range of the coercion from `Mâ‚ â†’â‚™* Mâ‚‚` (or another type of bundled\nhomomorphisms that has a `MulHomClass` instance) to `Mâ‚ â†’ Mâ‚‚`. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"Construct a bundled additive semigroup homomorphism `Mâ‚ â†’â‚™+ Mâ‚‚` from a function `f`\nand a proof that it belongs to the closure of the range of the coercion from `Mâ‚ â†’â‚™+ Mâ‚‚` (or another\ntype of bundled homomorphisms that has an `AddHomClass` instance) to `Mâ‚ â†’ Mâ‚‚`.\"]\ndef mulHomOfMemClosureRangeCoe (f : Mâ‚ â†’ Mâ‚‚)\n    (hf : f âˆˆ closure (range fun (f : F) (x : Mâ‚) => f x)) : Mâ‚ â†’â‚™* Mâ‚‚ where\n  toFun := f\n  map_mul' := (isClosed_setOf_map_mul Mâ‚ Mâ‚‚).closure_subset_iff.2 (range_subset_iff.2 map_mul) hf\n\n"}
{"name":"addHomOfTendsto_apply","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_2\nMâ‚ : Type u_6\nMâ‚‚ : Type u_7\ninstâœâ· : TopologicalSpace Mâ‚‚\ninstâœâ¶ : T2Space Mâ‚‚\ninstâœâµ : Add Mâ‚\ninstâœâ´ : Add Mâ‚‚\ninstâœÂ³ : ContinuousAdd Mâ‚‚\nF : Type u_8\ninstâœÂ² : FunLike F Mâ‚ Mâ‚‚\ninstâœÂ¹ : AddHomClass F Mâ‚ Mâ‚‚\nl : Filter Î±\nf : Mâ‚ â†’ Mâ‚‚\ng : Î± â†’ F\ninstâœ : l.NeBot\nh : Filter.Tendsto (fun a x => (g a) x) l (nhds f)\nâŠ¢ Eq (â‡‘(addHomOfTendsto f g h)) f","decl":"/-- Construct a bundled semigroup homomorphism from a pointwise limit of semigroup homomorphisms. -/\n@[to_additive (attr := simps! (config := .asFn))\n  \"Construct a bundled additive semigroup homomorphism from a pointwise limit of additive\nsemigroup homomorphisms\"]\ndef mulHomOfTendsto (f : Mâ‚ â†’ Mâ‚‚) (g : Î± â†’ F) [l.NeBot]\n    (h : Tendsto (fun a x => g a x) l (ğ“ f)) : Mâ‚ â†’â‚™* Mâ‚‚ :=\n  mulHomOfMemClosureRangeCoe f <|\n    mem_closure_of_tendsto h <| Eventually.of_forall fun _ => mem_range_self _\n\n"}
{"name":"mulHomOfTendsto_apply","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_2\nMâ‚ : Type u_6\nMâ‚‚ : Type u_7\ninstâœâ· : TopologicalSpace Mâ‚‚\ninstâœâ¶ : T2Space Mâ‚‚\ninstâœâµ : Mul Mâ‚\ninstâœâ´ : Mul Mâ‚‚\ninstâœÂ³ : ContinuousMul Mâ‚‚\nF : Type u_8\ninstâœÂ² : FunLike F Mâ‚ Mâ‚‚\ninstâœÂ¹ : MulHomClass F Mâ‚ Mâ‚‚\nl : Filter Î±\nf : Mâ‚ â†’ Mâ‚‚\ng : Î± â†’ F\ninstâœ : l.NeBot\nh : Filter.Tendsto (fun a x => (g a) x) l (nhds f)\nâŠ¢ Eq (â‡‘(mulHomOfTendsto f g h)) f","decl":"/-- Construct a bundled semigroup homomorphism from a pointwise limit of semigroup homomorphisms. -/\n@[to_additive (attr := simps! (config := .asFn))\n  \"Construct a bundled additive semigroup homomorphism from a pointwise limit of additive\nsemigroup homomorphisms\"]\ndef mulHomOfTendsto (f : Mâ‚ â†’ Mâ‚‚) (g : Î± â†’ F) [l.NeBot]\n    (h : Tendsto (fun a x => g a x) l (ğ“ f)) : Mâ‚ â†’â‚™* Mâ‚‚ :=\n  mulHomOfMemClosureRangeCoe f <|\n    mem_closure_of_tendsto h <| Eventually.of_forall fun _ => mem_range_self _\n\n"}
{"name":"MulHom.isClosed_range_coe","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Mâ‚ : Type u_6\nMâ‚‚ : Type u_7\ninstâœâ´ : TopologicalSpace Mâ‚‚\ninstâœÂ³ : T2Space Mâ‚‚\ninstâœÂ² : Mul Mâ‚\ninstâœÂ¹ : Mul Mâ‚‚\ninstâœ : ContinuousMul Mâ‚‚\nâŠ¢ IsClosed (Set.range DFunLike.coe)","decl":"@[to_additive]\ntheorem MulHom.isClosed_range_coe : IsClosed (Set.range ((â†‘) : (Mâ‚ â†’â‚™* Mâ‚‚) â†’ Mâ‚ â†’ Mâ‚‚)) :=\n  isClosed_of_closure_subset fun f hf => âŸ¨mulHomOfMemClosureRangeCoe f hf, rflâŸ©\n\n"}
{"name":"AddHom.isClosed_range_coe","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Mâ‚ : Type u_6\nMâ‚‚ : Type u_7\ninstâœâ´ : TopologicalSpace Mâ‚‚\ninstâœÂ³ : T2Space Mâ‚‚\ninstâœÂ² : Add Mâ‚\ninstâœÂ¹ : Add Mâ‚‚\ninstâœ : ContinuousAdd Mâ‚‚\nâŠ¢ IsClosed (Set.range DFunLike.coe)","decl":"@[to_additive]\ntheorem MulHom.isClosed_range_coe : IsClosed (Set.range ((â†‘) : (Mâ‚ â†’â‚™* Mâ‚‚) â†’ Mâ‚ â†’ Mâ‚‚)) :=\n  isClosed_of_closure_subset fun f hf => âŸ¨mulHomOfMemClosureRangeCoe f hf, rflâŸ©\n\n"}
{"name":"addMonoidHomOfMemClosureRangeCoe_apply","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Mâ‚ : Type u_6\nMâ‚‚ : Type u_7\ninstâœâ¶ : TopologicalSpace Mâ‚‚\ninstâœâµ : T2Space Mâ‚‚\ninstâœâ´ : AddZeroClass Mâ‚\ninstâœÂ³ : AddZeroClass Mâ‚‚\ninstâœÂ² : ContinuousAdd Mâ‚‚\nF : Type u_8\ninstâœÂ¹ : FunLike F Mâ‚ Mâ‚‚\ninstâœ : AddMonoidHomClass F Mâ‚ Mâ‚‚\nf : Mâ‚ â†’ Mâ‚‚\nhf : Membership.mem (closure (Set.range fun f x => f x)) f\nâŠ¢ Eq (â‡‘(addMonoidHomOfMemClosureRangeCoe f hf)) f","decl":"/-- Construct a bundled monoid homomorphism `Mâ‚ â†’* Mâ‚‚` from a function `f` and a proof that it\nbelongs to the closure of the range of the coercion from `Mâ‚ â†’* Mâ‚‚` (or another type of bundled\nhomomorphisms that has a `MonoidHomClass` instance) to `Mâ‚ â†’ Mâ‚‚`. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"Construct a bundled additive monoid homomorphism `Mâ‚ â†’+ Mâ‚‚` from a function `f`\nand a proof that it belongs to the closure of the range of the coercion from `Mâ‚ â†’+ Mâ‚‚` (or another\ntype of bundled homomorphisms that has an `AddMonoidHomClass` instance) to `Mâ‚ â†’ Mâ‚‚`.\"]\ndef monoidHomOfMemClosureRangeCoe (f : Mâ‚ â†’ Mâ‚‚)\n    (hf : f âˆˆ closure (range fun (f : F) (x : Mâ‚) => f x)) : Mâ‚ â†’* Mâ‚‚ where\n  toFun := f\n  map_one' := (isClosed_setOf_map_one Mâ‚ Mâ‚‚).closure_subset_iff.2 (range_subset_iff.2 map_one) hf\n  map_mul' := (isClosed_setOf_map_mul Mâ‚ Mâ‚‚).closure_subset_iff.2 (range_subset_iff.2 map_mul) hf\n\n"}
{"name":"monoidHomOfMemClosureRangeCoe_apply","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Mâ‚ : Type u_6\nMâ‚‚ : Type u_7\ninstâœâ¶ : TopologicalSpace Mâ‚‚\ninstâœâµ : T2Space Mâ‚‚\ninstâœâ´ : MulOneClass Mâ‚\ninstâœÂ³ : MulOneClass Mâ‚‚\ninstâœÂ² : ContinuousMul Mâ‚‚\nF : Type u_8\ninstâœÂ¹ : FunLike F Mâ‚ Mâ‚‚\ninstâœ : MonoidHomClass F Mâ‚ Mâ‚‚\nf : Mâ‚ â†’ Mâ‚‚\nhf : Membership.mem (closure (Set.range fun f x => f x)) f\nâŠ¢ Eq (â‡‘(monoidHomOfMemClosureRangeCoe f hf)) f","decl":"/-- Construct a bundled monoid homomorphism `Mâ‚ â†’* Mâ‚‚` from a function `f` and a proof that it\nbelongs to the closure of the range of the coercion from `Mâ‚ â†’* Mâ‚‚` (or another type of bundled\nhomomorphisms that has a `MonoidHomClass` instance) to `Mâ‚ â†’ Mâ‚‚`. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"Construct a bundled additive monoid homomorphism `Mâ‚ â†’+ Mâ‚‚` from a function `f`\nand a proof that it belongs to the closure of the range of the coercion from `Mâ‚ â†’+ Mâ‚‚` (or another\ntype of bundled homomorphisms that has an `AddMonoidHomClass` instance) to `Mâ‚ â†’ Mâ‚‚`.\"]\ndef monoidHomOfMemClosureRangeCoe (f : Mâ‚ â†’ Mâ‚‚)\n    (hf : f âˆˆ closure (range fun (f : F) (x : Mâ‚) => f x)) : Mâ‚ â†’* Mâ‚‚ where\n  toFun := f\n  map_one' := (isClosed_setOf_map_one Mâ‚ Mâ‚‚).closure_subset_iff.2 (range_subset_iff.2 map_one) hf\n  map_mul' := (isClosed_setOf_map_mul Mâ‚ Mâ‚‚).closure_subset_iff.2 (range_subset_iff.2 map_mul) hf\n\n"}
{"name":"addMonoidHomOfTendsto_apply","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_2\nMâ‚ : Type u_6\nMâ‚‚ : Type u_7\ninstâœâ· : TopologicalSpace Mâ‚‚\ninstâœâ¶ : T2Space Mâ‚‚\ninstâœâµ : AddZeroClass Mâ‚\ninstâœâ´ : AddZeroClass Mâ‚‚\ninstâœÂ³ : ContinuousAdd Mâ‚‚\nF : Type u_8\ninstâœÂ² : FunLike F Mâ‚ Mâ‚‚\ninstâœÂ¹ : AddMonoidHomClass F Mâ‚ Mâ‚‚\nl : Filter Î±\nf : Mâ‚ â†’ Mâ‚‚\ng : Î± â†’ F\ninstâœ : l.NeBot\nh : Filter.Tendsto (fun a x => (g a) x) l (nhds f)\nâŠ¢ Eq (â‡‘(addMonoidHomOfTendsto f g h)) f","decl":"/-- Construct a bundled monoid homomorphism from a pointwise limit of monoid homomorphisms. -/\n@[to_additive (attr := simps! (config := .asFn))\n  \"Construct a bundled additive monoid homomorphism from a pointwise limit of additive\nmonoid homomorphisms\"]\ndef monoidHomOfTendsto (f : Mâ‚ â†’ Mâ‚‚) (g : Î± â†’ F) [l.NeBot]\n    (h : Tendsto (fun a x => g a x) l (ğ“ f)) : Mâ‚ â†’* Mâ‚‚ :=\n  monoidHomOfMemClosureRangeCoe f <|\n    mem_closure_of_tendsto h <| Eventually.of_forall fun _ => mem_range_self _\n\n"}
{"name":"monoidHomOfTendsto_apply","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_2\nMâ‚ : Type u_6\nMâ‚‚ : Type u_7\ninstâœâ· : TopologicalSpace Mâ‚‚\ninstâœâ¶ : T2Space Mâ‚‚\ninstâœâµ : MulOneClass Mâ‚\ninstâœâ´ : MulOneClass Mâ‚‚\ninstâœÂ³ : ContinuousMul Mâ‚‚\nF : Type u_8\ninstâœÂ² : FunLike F Mâ‚ Mâ‚‚\ninstâœÂ¹ : MonoidHomClass F Mâ‚ Mâ‚‚\nl : Filter Î±\nf : Mâ‚ â†’ Mâ‚‚\ng : Î± â†’ F\ninstâœ : l.NeBot\nh : Filter.Tendsto (fun a x => (g a) x) l (nhds f)\nâŠ¢ Eq (â‡‘(monoidHomOfTendsto f g h)) f","decl":"/-- Construct a bundled monoid homomorphism from a pointwise limit of monoid homomorphisms. -/\n@[to_additive (attr := simps! (config := .asFn))\n  \"Construct a bundled additive monoid homomorphism from a pointwise limit of additive\nmonoid homomorphisms\"]\ndef monoidHomOfTendsto (f : Mâ‚ â†’ Mâ‚‚) (g : Î± â†’ F) [l.NeBot]\n    (h : Tendsto (fun a x => g a x) l (ğ“ f)) : Mâ‚ â†’* Mâ‚‚ :=\n  monoidHomOfMemClosureRangeCoe f <|\n    mem_closure_of_tendsto h <| Eventually.of_forall fun _ => mem_range_self _\n\n"}
{"name":"MonoidHom.isClosed_range_coe","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Mâ‚ : Type u_6\nMâ‚‚ : Type u_7\ninstâœâ´ : TopologicalSpace Mâ‚‚\ninstâœÂ³ : T2Space Mâ‚‚\ninstâœÂ² : MulOneClass Mâ‚\ninstâœÂ¹ : MulOneClass Mâ‚‚\ninstâœ : ContinuousMul Mâ‚‚\nâŠ¢ IsClosed (Set.range DFunLike.coe)","decl":"@[to_additive]\ntheorem MonoidHom.isClosed_range_coe : IsClosed (Set.range ((â†‘) : (Mâ‚ â†’* Mâ‚‚) â†’ Mâ‚ â†’ Mâ‚‚)) :=\n  isClosed_of_closure_subset fun f hf => âŸ¨monoidHomOfMemClosureRangeCoe f hf, rflâŸ©\n\n"}
{"name":"AddMonoidHom.isClosed_range_coe","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Mâ‚ : Type u_6\nMâ‚‚ : Type u_7\ninstâœâ´ : TopologicalSpace Mâ‚‚\ninstâœÂ³ : T2Space Mâ‚‚\ninstâœÂ² : AddZeroClass Mâ‚\ninstâœÂ¹ : AddZeroClass Mâ‚‚\ninstâœ : ContinuousAdd Mâ‚‚\nâŠ¢ IsClosed (Set.range DFunLike.coe)","decl":"@[to_additive]\ntheorem MonoidHom.isClosed_range_coe : IsClosed (Set.range ((â†‘) : (Mâ‚ â†’* Mâ‚‚) â†’ Mâ‚ â†’ Mâ‚‚)) :=\n  isClosed_of_closure_subset fun f hf => âŸ¨monoidHomOfMemClosureRangeCoe f hf, rflâŸ©\n\n"}
{"name":"Topology.IsInducing.continuousMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\nN : Type u_7\nF : Type u_8\ninstâœâ¶ : Mul M\ninstâœâµ : Mul N\ninstâœâ´ : FunLike F M N\ninstâœÂ³ : MulHomClass F M N\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : TopologicalSpace N\ninstâœ : ContinuousMul N\nf : F\nhf : Topology.IsInducing â‡‘f\nâŠ¢ ContinuousMul M","decl":"@[to_additive]\ntheorem Topology.IsInducing.continuousMul {M N F : Type*} [Mul M] [Mul N] [FunLike F M N]\n    [MulHomClass F M N] [TopologicalSpace M] [TopologicalSpace N] [ContinuousMul N] (f : F)\n    (hf : IsInducing f) : ContinuousMul M :=\n  âŸ¨(hf.continuousSMul hf.continuous (map_mul f _ _)).1âŸ©\n\n"}
{"name":"Topology.IsInducing.continuousAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\nN : Type u_7\nF : Type u_8\ninstâœâ¶ : Add M\ninstâœâµ : Add N\ninstâœâ´ : FunLike F M N\ninstâœÂ³ : AddHomClass F M N\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : TopologicalSpace N\ninstâœ : ContinuousAdd N\nf : F\nhf : Topology.IsInducing â‡‘f\nâŠ¢ ContinuousAdd M","decl":"@[to_additive]\ntheorem Topology.IsInducing.continuousMul {M N F : Type*} [Mul M] [Mul N] [FunLike F M N]\n    [MulHomClass F M N] [TopologicalSpace M] [TopologicalSpace N] [ContinuousMul N] (f : F)\n    (hf : IsInducing f) : ContinuousMul M :=\n  âŸ¨(hf.continuousSMul hf.continuous (map_mul f _ _)).1âŸ©\n\n"}
{"name":"Inducing.continuousMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\nN : Type u_7\nF : Type u_8\ninstâœâ¶ : Mul M\ninstâœâµ : Mul N\ninstâœâ´ : FunLike F M N\ninstâœÂ³ : MulHomClass F M N\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : TopologicalSpace N\ninstâœ : ContinuousMul N\nf : F\nhf : Topology.IsInducing â‡‘f\nâŠ¢ ContinuousMul M","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.continuousMul := IsInducing.continuousMul\n\n"}
{"name":"continuousMul_induced","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\nN : Type u_7\nF : Type u_8\ninstâœâµ : Mul M\ninstâœâ´ : Mul N\ninstâœÂ³ : FunLike F M N\ninstâœÂ² : MulHomClass F M N\ninstâœÂ¹ : TopologicalSpace N\ninstâœ : ContinuousMul N\nf : F\nâŠ¢ ContinuousMul M","decl":"@[to_additive]\ntheorem continuousMul_induced {M N F : Type*} [Mul M] [Mul N] [FunLike F M N] [MulHomClass F M N]\n    [TopologicalSpace N] [ContinuousMul N] (f : F) : @ContinuousMul M (induced f â€¹_â€º) _ :=\n  letI := induced f â€¹_â€º\n  IsInducing.continuousMul f âŸ¨rflâŸ©\n\n"}
{"name":"continuousAdd_induced","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\nN : Type u_7\nF : Type u_8\ninstâœâµ : Add M\ninstâœâ´ : Add N\ninstâœÂ³ : FunLike F M N\ninstâœÂ² : AddHomClass F M N\ninstâœÂ¹ : TopologicalSpace N\ninstâœ : ContinuousAdd N\nf : F\nâŠ¢ ContinuousAdd M","decl":"@[to_additive]\ntheorem continuousMul_induced {M N F : Type*} [Mul M] [Mul N] [FunLike F M N] [MulHomClass F M N]\n    [TopologicalSpace N] [ContinuousMul N] (f : F) : @ContinuousMul M (induced f â€¹_â€º) _ :=\n  letI := induced f â€¹_â€º\n  IsInducing.continuousMul f âŸ¨rflâŸ©\n\n"}
{"name":"AddSubsemigroup.continuousAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddSemigroup M\ninstâœ : ContinuousAdd M\nS : AddSubsemigroup M\nâŠ¢ ContinuousAdd (Subtype fun x => Membership.mem S x)","decl":"@[to_additive]\ninstance Subsemigroup.continuousMul [TopologicalSpace M] [Semigroup M] [ContinuousMul M]\n    (S : Subsemigroup M) : ContinuousMul S :=\n  IsInducing.continuousMul ({ toFun := (â†‘), map_mul' := fun _ _ => rfl} : MulHom S M) âŸ¨rflâŸ©\n\n"}
{"name":"Subsemigroup.continuousMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Semigroup M\ninstâœ : ContinuousMul M\nS : Subsemigroup M\nâŠ¢ ContinuousMul (Subtype fun x => Membership.mem S x)","decl":"@[to_additive]\ninstance Subsemigroup.continuousMul [TopologicalSpace M] [Semigroup M] [ContinuousMul M]\n    (S : Subsemigroup M) : ContinuousMul S :=\n  IsInducing.continuousMul ({ toFun := (â†‘), map_mul' := fun _ _ => rfl} : MulHom S M) âŸ¨rflâŸ©\n\n"}
{"name":"AddSubmonoid.continuousAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : ContinuousAdd M\nS : AddSubmonoid M\nâŠ¢ ContinuousAdd (Subtype fun x => Membership.mem S x)","decl":"@[to_additive]\ninstance Submonoid.continuousMul [TopologicalSpace M] [Monoid M] [ContinuousMul M]\n    (S : Submonoid M) : ContinuousMul S :=\n  S.toSubsemigroup.continuousMul\n\n"}
{"name":"Submonoid.continuousMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : ContinuousMul M\nS : Submonoid M\nâŠ¢ ContinuousMul (Subtype fun x => Membership.mem S x)","decl":"@[to_additive]\ninstance Submonoid.continuousMul [TopologicalSpace M] [Monoid M] [ContinuousMul M]\n    (S : Submonoid M) : ContinuousMul S :=\n  S.toSubsemigroup.continuousMul\n\n"}
{"name":"exists_mem_nhds_zero_mul_subset","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : MulZeroClass M\ninstâœ : ContinuousMul M\nK U : Set M\nhK : IsCompact K\nhU : Membership.mem (nhds 0) U\nâŠ¢ Exists fun V => And (Membership.mem (nhds 0) V) (HasSubset.Subset (HMul.hMul K V) U)","decl":"theorem exists_mem_nhds_zero_mul_subset\n    {K U : Set M} (hK : IsCompact K) (hU : U âˆˆ ğ“ 0) : âˆƒ V âˆˆ ğ“ 0, K * V âŠ† U := by\n  refine hK.induction_on ?_ ?_ ?_ ?_\n  Â· exact âŸ¨univ, by simpâŸ©\n  Â· rintro s t hst âŸ¨V, hV, hV'âŸ©\n    exact âŸ¨V, hV, (mul_subset_mul_right hst).trans hV'âŸ©\n  Â· rintro s t âŸ¨V, V_in, hV'âŸ© âŸ¨W, W_in, hW'âŸ©\n    use V âˆ© W, inter_mem V_in W_in\n    rw [union_mul]\n    exact\n      union_subset ((mul_subset_mul_left V.inter_subset_left).trans hV')\n        ((mul_subset_mul_left V.inter_subset_right).trans hW')\n  Â· intro x hx\n    have := tendsto_mul (show U âˆˆ ğ“ (x * 0) by simpa using hU)\n    rw [nhds_prod_eq, mem_map, mem_prod_iff] at this\n    rcases this with âŸ¨t, ht, s, hs, hâŸ©\n    rw [â† image_subset_iff, image_mul_prod] at h\n    exact âŸ¨t, mem_nhdsWithin_of_mem_nhds ht, s, hs, hâŸ©\n\n"}
{"name":"tendsto_mul_nhds_zero_prod_of_disjoint_cocompact","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : MulZeroClass M\ninstâœ : ContinuousMul M\nl : Filter M\nhl : Disjoint l (Filter.cocompact M)\nâŠ¢ Filter.Tendsto (fun x => HMul.hMul x.1 x.2) (SProd.sprod (nhds 0) l) (nhds 0)","decl":"/-- Let `M` be a topological space with a continuous multiplication operation and a `0`.\nLet `l` be a filter on `M` which is disjoint from the cocompact filter. Then, the multiplication map\n`M Ã— M â†’ M` tends to zero on the filter product `ğ“ 0 Ã—Ë¢ l`. -/\ntheorem tendsto_mul_nhds_zero_prod_of_disjoint_cocompact {l : Filter M}\n    (hl : Disjoint l (cocompact M)) :\n    Tendsto (fun x : M Ã— M â†¦ x.1 * x.2) (ğ“ 0 Ã—Ë¢ l) (ğ“ 0) := calc\n  map (fun x : M Ã— M â†¦ x.1 * x.2) (ğ“ 0 Ã—Ë¢ l)\n  _ â‰¤ map (fun x : M Ã— M â†¦ x.1 * x.2) (ğ“Ë¢ ({0} Ã—Ë¢ Set.univ)) :=\n    map_mono <| nhds_prod_le_of_disjoint_cocompact 0 hl\n  _ â‰¤ ğ“ 0 := continuous_mul.tendsto_nhdsSet_nhds fun _ âŸ¨hx, _âŸ© â†¦ mul_eq_zero_of_left hx _\n\n"}
{"name":"tendsto_mul_prod_nhds_zero_of_disjoint_cocompact","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : MulZeroClass M\ninstâœ : ContinuousMul M\nl : Filter M\nhl : Disjoint l (Filter.cocompact M)\nâŠ¢ Filter.Tendsto (fun x => HMul.hMul x.1 x.2) (SProd.sprod l (nhds 0)) (nhds 0)","decl":"/-- Let `M` be a topological space with a continuous multiplication operation and a `0`.\nLet `l` be a filter on `M` which is disjoint from the cocompact filter. Then, the multiplication map\n`M Ã— M â†’ M` tends to zero on the filter product `l Ã—Ë¢ ğ“ 0`. -/\ntheorem tendsto_mul_prod_nhds_zero_of_disjoint_cocompact {l : Filter M}\n    (hl : Disjoint l (cocompact M)) :\n    Tendsto (fun x : M Ã— M â†¦ x.1 * x.2) (l Ã—Ë¢ ğ“ 0) (ğ“ 0) := calc\n  map (fun x : M Ã— M â†¦ x.1 * x.2) (l Ã—Ë¢ ğ“ 0)\n  _ â‰¤ map (fun x : M Ã— M â†¦ x.1 * x.2) (ğ“Ë¢ (Set.univ Ã—Ë¢ {0})) :=\n    map_mono <| prod_nhds_le_of_disjoint_cocompact 0 hl\n  _ â‰¤ ğ“ 0 := continuous_mul.tendsto_nhdsSet_nhds fun _ âŸ¨_, hxâŸ© â†¦ mul_eq_zero_of_right _ hx\n\n"}
{"name":"tendsto_mul_coprod_nhds_zero_inf_of_disjoint_cocompact","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : MulZeroClass M\ninstâœ : ContinuousMul M\nl : Filter (Prod M M)\nhl : Disjoint l (Filter.cocompact (Prod M M))\nâŠ¢ Filter.Tendsto (fun x => HMul.hMul x.1 x.2) (Min.min ((nhds 0).coprod (nhds 0)) l) (nhds 0)","decl":"/-- Let `M` be a topological space with a continuous multiplication operation and a `0`.\nLet `l` be a filter on `M Ã— M` which is disjoint from the cocompact filter. Then, the multiplication\nmap `M Ã— M â†’ M` tends to zero on `(ğ“ 0).coprod (ğ“ 0) âŠ“ l`. -/\ntheorem tendsto_mul_coprod_nhds_zero_inf_of_disjoint_cocompact {l : Filter (M Ã— M)}\n    (hl : Disjoint l (cocompact (M Ã— M))) :\n    Tendsto (fun x : M Ã— M â†¦ x.1 * x.2) ((ğ“ 0).coprod (ğ“ 0) âŠ“ l) (ğ“ 0) := by\n  have := calc\n    (ğ“ 0).coprod (ğ“ 0) âŠ“ l\n    _ â‰¤ (ğ“ 0).coprod (ğ“ 0) âŠ“ map Prod.fst l Ã—Ë¢ map Prod.snd l :=\n      inf_le_inf_left _ le_prod_map_fst_snd\n    _ â‰¤ ğ“ 0 Ã—Ë¢ map Prod.snd l âŠ” map Prod.fst l Ã—Ë¢ ğ“ 0 :=\n      coprod_inf_prod_le _ _ _ _\n  apply (Tendsto.sup _ _).mono_left this\n  Â· apply tendsto_mul_nhds_zero_prod_of_disjoint_cocompact\n    exact disjoint_map_cocompact continuous_snd hl\n  Â· apply tendsto_mul_prod_nhds_zero_of_disjoint_cocompact\n    exact disjoint_map_cocompact continuous_fst hl\n\n"}
{"name":"tendsto_mul_nhds_zero_of_disjoint_cocompact","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : MulZeroClass M\ninstâœ : ContinuousMul M\nl : Filter (Prod M M)\nhl : Disjoint l (Filter.cocompact (Prod M M))\nh'l : LE.le l ((nhds 0).coprod (nhds 0))\nâŠ¢ Filter.Tendsto (fun x => HMul.hMul x.1 x.2) l (nhds 0)","decl":"/-- Let `M` be a topological space with a continuous multiplication operation and a `0`.\nLet `l` be a filter on `M Ã— M` which is both disjoint from the cocompact filter and less than or\nequal to `(ğ“ 0).coprod (ğ“ 0)`. Then the multiplication map `M Ã— M â†’ M` tends to zero on `l`. -/\ntheorem tendsto_mul_nhds_zero_of_disjoint_cocompact {l : Filter (M Ã— M)}\n    (hl : Disjoint l (cocompact (M Ã— M))) (h'l : l â‰¤ (ğ“ 0).coprod (ğ“ 0)) :\n    Tendsto (fun x : M Ã— M â†¦ x.1 * x.2) l (ğ“ 0) := by\n  simpa [inf_eq_right.mpr h'l] using tendsto_mul_coprod_nhds_zero_inf_of_disjoint_cocompact hl\n\n"}
{"name":"Tendsto.tendsto_mul_zero_of_disjoint_cocompact_right","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nÎ± : Type u_6\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : MulZeroClass M\ninstâœ : ContinuousMul M\nf g : Î± â†’ M\nl : Filter Î±\nhf : Filter.Tendsto f l (nhds 0)\nhg : Disjoint (Filter.map g l) (Filter.cocompact M)\nâŠ¢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l (nhds 0)","decl":"/-- Let `M` be a topological space with a continuous multiplication operation and a `0`.\nLet `f : Î± â†’ M` and `g : Î± â†’ M` be functions. If `f` tends to zero on a filter `l`\nand the image of `l` under `g` is disjoint from the cocompact filter on `M`, then\n`fun x : Î± â†¦ f x * g x` also tends to zero on `l`. -/\ntheorem Tendsto.tendsto_mul_zero_of_disjoint_cocompact_right {f g : Î± â†’ M} {l : Filter Î±}\n    (hf : Tendsto f l (ğ“ 0)) (hg : Disjoint (map g l) (cocompact M)) :\n    Tendsto (fun x â†¦ f x * g x) l (ğ“ 0) :=\n  tendsto_mul_nhds_zero_prod_of_disjoint_cocompact hg |>.comp (hf.prod_mk tendsto_map)\n\n"}
{"name":"Tendsto.tendsto_mul_zero_of_disjoint_cocompact_left","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nÎ± : Type u_6\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : MulZeroClass M\ninstâœ : ContinuousMul M\nf g : Î± â†’ M\nl : Filter Î±\nhf : Disjoint (Filter.map f l) (Filter.cocompact M)\nhg : Filter.Tendsto g l (nhds 0)\nâŠ¢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l (nhds 0)","decl":"/-- Let `M` be a topological space with a continuous multiplication operation and a `0`.\nLet `f : Î± â†’ M` and `g : Î± â†’ M` be functions. If `g` tends to zero on a filter `l`\nand the image of `l` under `f` is disjoint from the cocompact filter on `M`, then\n`fun x : Î± â†¦ f x * g x` also tends to zero on `l`. -/\ntheorem Tendsto.tendsto_mul_zero_of_disjoint_cocompact_left {f g : Î± â†’ M} {l : Filter Î±}\n    (hf : Disjoint (map f l) (cocompact M)) (hg : Tendsto g l (ğ“ 0)):\n    Tendsto (fun x â†¦ f x * g x) l (ğ“ 0) :=\n  tendsto_mul_prod_nhds_zero_of_disjoint_cocompact hf |>.comp (tendsto_map.prod_mk hg)\n\n"}
{"name":"tendsto_mul_cocompact_nhds_zero","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nÎ± : Type u_6\nÎ² : Type u_7\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : MulZeroClass M\ninstâœÂ² : ContinuousMul M\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\nf : Î± â†’ M\ng : Î² â†’ M\nf_cont : Continuous f\ng_cont : Continuous g\nhf : Filter.Tendsto f (Filter.cocompact Î±) (nhds 0)\nhg : Filter.Tendsto g (Filter.cocompact Î²) (nhds 0)\nâŠ¢ Filter.Tendsto (fun i => HMul.hMul (f i.1) (g i.2)) (Filter.cocompact (Prod Î± Î²)) (nhds 0)","decl":"/-- If `f : Î± â†’ M` and `g : Î² â†’ M` are continuous and both tend to zero on the cocompact filter,\nthen `fun i : Î± Ã— Î² â†¦ f i.1 * g i.2` also tends to zero on the cocompact filter. -/\ntheorem tendsto_mul_cocompact_nhds_zero [TopologicalSpace Î±] [TopologicalSpace Î²]\n    {f : Î± â†’ M} {g : Î² â†’ M} (f_cont : Continuous f) (g_cont : Continuous g)\n    (hf : Tendsto f (cocompact Î±) (ğ“ 0)) (hg : Tendsto g (cocompact Î²) (ğ“ 0)) :\n    Tendsto (fun i : Î± Ã— Î² â†¦ f i.1 * g i.2) (cocompact (Î± Ã— Î²)) (ğ“ 0) := by\n  set l : Filter (M Ã— M) := map (Prod.map f g) (cocompact (Î± Ã— Î²)) with l_def\n  set K : Set (M Ã— M) := (insert 0 (range f)) Ã—Ë¢ (insert 0 (range g))\n  have K_compact : IsCompact K := .prod (hf.isCompact_insert_range_of_cocompact f_cont)\n    (hg.isCompact_insert_range_of_cocompact g_cont)\n  have K_mem_l : K âˆˆ l := eventually_map.mpr <| .of_forall fun âŸ¨x, yâŸ© â†¦\n    âŸ¨mem_insert_of_mem _ (mem_range_self _), mem_insert_of_mem _ (mem_range_self _)âŸ©\n  have l_compact : Disjoint l (cocompact (M Ã— M)) := by\n    rw [disjoint_cocompact_right]\n    exact âŸ¨K, K_mem_l, K_compactâŸ©\n  have l_le_coprod : l â‰¤ (ğ“ 0).coprod (ğ“ 0) := by\n    rw [l_def, â† coprod_cocompact]\n    exact hf.prod_map_coprod hg\n  exact tendsto_mul_nhds_zero_of_disjoint_cocompact l_compact l_le_coprod |>.comp tendsto_map\n\n"}
{"name":"tendsto_mul_cofinite_nhds_zero","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nÎ± : Type u_6\nÎ² : Type u_7\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : MulZeroClass M\ninstâœ : ContinuousMul M\nf : Î± â†’ M\ng : Î² â†’ M\nhf : Filter.Tendsto f Filter.cofinite (nhds 0)\nhg : Filter.Tendsto g Filter.cofinite (nhds 0)\nâŠ¢ Filter.Tendsto (fun i => HMul.hMul (f i.1) (g i.2)) Filter.cofinite (nhds 0)","decl":"/-- If `f : Î± â†’ M` and `g : Î² â†’ M` both tend to zero on the cofinite filter, then so does\n`fun i : Î± Ã— Î² â†¦ f i.1 * g i.2`. -/\ntheorem tendsto_mul_cofinite_nhds_zero {f : Î± â†’ M} {g : Î² â†’ M}\n    (hf : Tendsto f cofinite (ğ“ 0)) (hg : Tendsto g cofinite (ğ“ 0)) :\n    Tendsto (fun i : Î± Ã— Î² â†¦ f i.1 * g i.2) cofinite (ğ“ 0) := by\n  letI : TopologicalSpace Î± := âŠ¥\n  haveI : DiscreteTopology Î± := discreteTopology_bot Î±\n  letI : TopologicalSpace Î² := âŠ¥\n  haveI : DiscreteTopology Î² := discreteTopology_bot Î²\n  rw [â† cocompact_eq_cofinite] at *\n  exact tendsto_mul_cocompact_nhds_zero\n    continuous_of_discreteTopology continuous_of_discreteTopology hf hg\n\n"}
{"name":"GroupWithZero.isOpen_singleton_zero","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœâ´ : GroupWithZero M\ninstâœÂ³ : TopologicalSpace M\ninstâœÂ² : ContinuousMul M\ninstâœÂ¹ : CompactSpace M\ninstâœ : T1Space M\nâŠ¢ IsOpen (Singleton.singleton 0)","decl":"lemma GroupWithZero.isOpen_singleton_zero [GroupWithZero M] [TopologicalSpace M]\n    [ContinuousMul M] [CompactSpace M] [T1Space M] :\n    IsOpen {(0 : M)} := by\n  obtain âŸ¨U, hU, h0U, h1UâŸ© := t1Space_iff_exists_open.mp â€¹_â€º zero_ne_one\n  obtain âŸ¨W, hW, hW'âŸ© := exists_mem_nhds_zero_mul_subset isCompact_univ (hU.mem_nhds h0U)\n  by_cases H : âˆƒ x â‰  0, x âˆˆ W\n  Â· obtain âŸ¨x, hx, hxWâŸ© := H\n    cases h1U (hW' (by simpa [hx] using Set.mul_mem_mul (Set.mem_univ xâ»Â¹) hxW))\n  Â· obtain rfl : W = {0} := subset_antisymm\n      (by simpa [not_imp_not] using H) (by simpa using mem_of_mem_nhds hW)\n    simpa [isOpen_iff_mem_nhds]\n\n"}
{"name":"exists_open_nhds_zero_half","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddZeroClass M\ninstâœ : ContinuousAdd M\ns : Set M\nhs : Membership.mem (nhds 0) s\nâŠ¢ Exists fun V => And (IsOpen V) (And (Membership.mem V 0) (âˆ€ (v : M), Membership.mem V v â†’ âˆ€ (w : M), Membership.mem V w â†’ Membership.mem s (HAdd.hAdd v w)))","decl":"@[to_additive exists_open_nhds_zero_half]\ntheorem exists_open_nhds_one_split {s : Set M} (hs : s âˆˆ ğ“ (1 : M)) :\n    âˆƒ V : Set M, IsOpen V âˆ§ (1 : M) âˆˆ V âˆ§ âˆ€ v âˆˆ V, âˆ€ w âˆˆ V, v * w âˆˆ s := by\n  have : (fun a : M Ã— M => a.1 * a.2) â»Â¹' s âˆˆ ğ“ ((1, 1) : M Ã— M) :=\n    tendsto_mul (by simpa only [one_mul] using hs)\n  simpa only [prod_subset_iff] using exists_nhds_square this\n\n"}
{"name":"exists_open_nhds_one_split","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : MulOneClass M\ninstâœ : ContinuousMul M\ns : Set M\nhs : Membership.mem (nhds 1) s\nâŠ¢ Exists fun V => And (IsOpen V) (And (Membership.mem V 1) (âˆ€ (v : M), Membership.mem V v â†’ âˆ€ (w : M), Membership.mem V w â†’ Membership.mem s (HMul.hMul v w)))","decl":"@[to_additive exists_open_nhds_zero_half]\ntheorem exists_open_nhds_one_split {s : Set M} (hs : s âˆˆ ğ“ (1 : M)) :\n    âˆƒ V : Set M, IsOpen V âˆ§ (1 : M) âˆˆ V âˆ§ âˆ€ v âˆˆ V, âˆ€ w âˆˆ V, v * w âˆˆ s := by\n  have : (fun a : M Ã— M => a.1 * a.2) â»Â¹' s âˆˆ ğ“ ((1, 1) : M Ã— M) :=\n    tendsto_mul (by simpa only [one_mul] using hs)\n  simpa only [prod_subset_iff] using exists_nhds_square this\n\n"}
{"name":"exists_nhds_zero_half","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddZeroClass M\ninstâœ : ContinuousAdd M\ns : Set M\nhs : Membership.mem (nhds 0) s\nâŠ¢ Exists fun V => And (Membership.mem (nhds 0) V) (âˆ€ (v : M), Membership.mem V v â†’ âˆ€ (w : M), Membership.mem V w â†’ Membership.mem s (HAdd.hAdd v w))","decl":"@[to_additive exists_nhds_zero_half]\ntheorem exists_nhds_one_split {s : Set M} (hs : s âˆˆ ğ“ (1 : M)) :\n    âˆƒ V âˆˆ ğ“ (1 : M), âˆ€ v âˆˆ V, âˆ€ w âˆˆ V, v * w âˆˆ s :=\n  let âŸ¨V, Vo, V1, hVâŸ© := exists_open_nhds_one_split hs\n  âŸ¨V, IsOpen.mem_nhds Vo V1, hVâŸ©\n\n"}
{"name":"exists_nhds_one_split","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : MulOneClass M\ninstâœ : ContinuousMul M\ns : Set M\nhs : Membership.mem (nhds 1) s\nâŠ¢ Exists fun V => And (Membership.mem (nhds 1) V) (âˆ€ (v : M), Membership.mem V v â†’ âˆ€ (w : M), Membership.mem V w â†’ Membership.mem s (HMul.hMul v w))","decl":"@[to_additive exists_nhds_zero_half]\ntheorem exists_nhds_one_split {s : Set M} (hs : s âˆˆ ğ“ (1 : M)) :\n    âˆƒ V âˆˆ ğ“ (1 : M), âˆ€ v âˆˆ V, âˆ€ w âˆˆ V, v * w âˆˆ s :=\n  let âŸ¨V, Vo, V1, hVâŸ© := exists_open_nhds_one_split hs\n  âŸ¨V, IsOpen.mem_nhds Vo V1, hVâŸ©\n\n"}
{"name":"exists_open_nhds_zero_add_subset","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddZeroClass M\ninstâœ : ContinuousAdd M\nU : Set M\nhU : Membership.mem (nhds 0) U\nâŠ¢ Exists fun V => And (IsOpen V) (And (Membership.mem V 0) (HasSubset.Subset (HAdd.hAdd V V) U))","decl":"/-- Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\nsuch that `V * V âŠ† U`. -/\n@[to_additive \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\n  such that `V + V âŠ† U`.\"]\ntheorem exists_open_nhds_one_mul_subset {U : Set M} (hU : U âˆˆ ğ“ (1 : M)) :\n    âˆƒ V : Set M, IsOpen V âˆ§ (1 : M) âˆˆ V âˆ§ V * V âŠ† U := by\n  simpa only [mul_subset_iff] using exists_open_nhds_one_split hU\n\n"}
{"name":"exists_open_nhds_one_mul_subset","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : MulOneClass M\ninstâœ : ContinuousMul M\nU : Set M\nhU : Membership.mem (nhds 1) U\nâŠ¢ Exists fun V => And (IsOpen V) (And (Membership.mem V 1) (HasSubset.Subset (HMul.hMul V V) U))","decl":"/-- Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\nsuch that `V * V âŠ† U`. -/\n@[to_additive \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\n  such that `V + V âŠ† U`.\"]\ntheorem exists_open_nhds_one_mul_subset {U : Set M} (hU : U âˆˆ ğ“ (1 : M)) :\n    âˆƒ V : Set M, IsOpen V âˆ§ (1 : M) âˆˆ V âˆ§ V * V âŠ† U := by\n  simpa only [mul_subset_iff] using exists_open_nhds_one_split hU\n\n"}
{"name":"Filter.HasBasis.mul_self","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : MulOneClass M\ninstâœ : ContinuousMul M\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set M\nh : (nhds 1).HasBasis p s\nâŠ¢ (nhds 1).HasBasis p fun i => HMul.hMul (s i) (s i)","decl":"@[to_additive]\ntheorem Filter.HasBasis.mul_self {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set M} (h : (ğ“ 1).HasBasis p s) :\n    (ğ“ 1).HasBasis p fun i => s i * s i := by\n  rw [â† nhds_mul_nhds_one, â† mapâ‚‚_mul, â† map_uncurry_prod]\n  simpa only [â† image_mul_prod] using h.prod_self.map _\n\n"}
{"name":"Filter.HasBasis.add_self","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddZeroClass M\ninstâœ : ContinuousAdd M\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set M\nh : (nhds 0).HasBasis p s\nâŠ¢ (nhds 0).HasBasis p fun i => HAdd.hAdd (s i) (s i)","decl":"@[to_additive]\ntheorem Filter.HasBasis.mul_self {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set M} (h : (ğ“ 1).HasBasis p s) :\n    (ğ“ 1).HasBasis p fun i => s i * s i := by\n  rw [â† nhds_mul_nhds_one, â† mapâ‚‚_mul, â† map_uncurry_prod]\n  simpa only [â† image_mul_prod] using h.prod_self.map _\n\n"}
{"name":"Subsemigroup.top_closure_mul_self_subset","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Semigroup M\ninstâœ : ContinuousMul M\ns : Subsemigroup M\nâŠ¢ HasSubset.Subset (HMul.hMul (closure â†‘s) (closure â†‘s)) (closure â†‘s)","decl":"@[to_additive]\ntheorem Subsemigroup.top_closure_mul_self_subset (s : Subsemigroup M) :\n    _root_.closure (s : Set M) * _root_.closure s âŠ† _root_.closure s :=\n  image2_subset_iff.2 fun _ hx _ hy =>\n    map_mem_closureâ‚‚ continuous_mul hx hy fun _ ha _ hb => s.mul_mem ha hb\n\n"}
{"name":"AddSubsemigroup.top_closure_add_self_subset","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddSemigroup M\ninstâœ : ContinuousAdd M\ns : AddSubsemigroup M\nâŠ¢ HasSubset.Subset (HAdd.hAdd (closure â†‘s) (closure â†‘s)) (closure â†‘s)","decl":"@[to_additive]\ntheorem Subsemigroup.top_closure_mul_self_subset (s : Subsemigroup M) :\n    _root_.closure (s : Set M) * _root_.closure s âŠ† _root_.closure s :=\n  image2_subset_iff.2 fun _ hx _ hy =>\n    map_mem_closureâ‚‚ continuous_mul hx hy fun _ ha _ hb => s.mul_mem ha hb\n\n"}
{"name":"Subsemigroup.coe_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Semigroup M\ninstâœ : ContinuousMul M\ns : Subsemigroup M\nâŠ¢ Eq (â†‘s.topologicalClosure) (closure â†‘s)","decl":"@[to_additive]\ntheorem Subsemigroup.coe_topologicalClosure (s : Subsemigroup M) :\n    (s.topologicalClosure : Set M) = _root_.closure (s : Set M) := rfl\n\n"}
{"name":"AddSubsemigroup.coe_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddSemigroup M\ninstâœ : ContinuousAdd M\ns : AddSubsemigroup M\nâŠ¢ Eq (â†‘s.topologicalClosure) (closure â†‘s)","decl":"@[to_additive]\ntheorem Subsemigroup.coe_topologicalClosure (s : Subsemigroup M) :\n    (s.topologicalClosure : Set M) = _root_.closure (s : Set M) := rfl\n\n"}
{"name":"Subsemigroup.le_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Semigroup M\ninstâœ : ContinuousMul M\ns : Subsemigroup M\nâŠ¢ LE.le s s.topologicalClosure","decl":"@[to_additive]\ntheorem Subsemigroup.le_topologicalClosure (s : Subsemigroup M) : s â‰¤ s.topologicalClosure :=\n  _root_.subset_closure\n\n"}
{"name":"AddSubsemigroup.le_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddSemigroup M\ninstâœ : ContinuousAdd M\ns : AddSubsemigroup M\nâŠ¢ LE.le s s.topologicalClosure","decl":"@[to_additive]\ntheorem Subsemigroup.le_topologicalClosure (s : Subsemigroup M) : s â‰¤ s.topologicalClosure :=\n  _root_.subset_closure\n\n"}
{"name":"Subsemigroup.isClosed_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Semigroup M\ninstâœ : ContinuousMul M\ns : Subsemigroup M\nâŠ¢ IsClosed â†‘s.topologicalClosure","decl":"@[to_additive]\ntheorem Subsemigroup.isClosed_topologicalClosure (s : Subsemigroup M) :\n    IsClosed (s.topologicalClosure : Set M) := isClosed_closure\n\n"}
{"name":"AddSubsemigroup.isClosed_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddSemigroup M\ninstâœ : ContinuousAdd M\ns : AddSubsemigroup M\nâŠ¢ IsClosed â†‘s.topologicalClosure","decl":"@[to_additive]\ntheorem Subsemigroup.isClosed_topologicalClosure (s : Subsemigroup M) :\n    IsClosed (s.topologicalClosure : Set M) := isClosed_closure\n\n"}
{"name":"AddSubsemigroup.topologicalClosure_minimal","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddSemigroup M\ninstâœ : ContinuousAdd M\ns t : AddSubsemigroup M\nh : LE.le s t\nht : IsClosed â†‘t\nâŠ¢ LE.le s.topologicalClosure t","decl":"@[to_additive]\ntheorem Subsemigroup.topologicalClosure_minimal (s : Subsemigroup M) {t : Subsemigroup M}\n    (h : s â‰¤ t) (ht : IsClosed (t : Set M)) : s.topologicalClosure â‰¤ t := closure_minimal h ht\n\n"}
{"name":"Subsemigroup.topologicalClosure_minimal","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Semigroup M\ninstâœ : ContinuousMul M\ns t : Subsemigroup M\nh : LE.le s t\nht : IsClosed â†‘t\nâŠ¢ LE.le s.topologicalClosure t","decl":"@[to_additive]\ntheorem Subsemigroup.topologicalClosure_minimal (s : Subsemigroup M) {t : Subsemigroup M}\n    (h : s â‰¤ t) (ht : IsClosed (t : Set M)) : s.topologicalClosure â‰¤ t := closure_minimal h ht\n\n"}
{"name":"IsCompact.add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddSemigroup M\ninstâœ : ContinuousAdd M\ns t : Set M\nhs : IsCompact s\nht : IsCompact t\nâŠ¢ IsCompact (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem IsCompact.mul {s t : Set M} (hs : IsCompact s) (ht : IsCompact t) : IsCompact (s * t) := by\n  rw [â† image_mul_prod]\n  exact (hs.prod ht).image continuous_mul\n\n"}
{"name":"IsCompact.mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Semigroup M\ninstâœ : ContinuousMul M\ns t : Set M\nhs : IsCompact s\nht : IsCompact t\nâŠ¢ IsCompact (HMul.hMul s t)","decl":"@[to_additive]\ntheorem IsCompact.mul {s t : Set M} (hs : IsCompact s) (ht : IsCompact t) : IsCompact (s * t) := by\n  rw [â† image_mul_prod]\n  exact (hs.prod ht).image continuous_mul\n\n"}
{"name":"AddSubmonoid.top_closure_add_self_subset","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : ContinuousAdd M\ns : AddSubmonoid M\nâŠ¢ HasSubset.Subset (HAdd.hAdd (closure â†‘s) (closure â†‘s)) (closure â†‘s)","decl":"@[to_additive]\ntheorem Submonoid.top_closure_mul_self_subset (s : Submonoid M) :\n    _root_.closure (s : Set M) * _root_.closure s âŠ† _root_.closure s :=\n  image2_subset_iff.2 fun _ hx _ hy =>\n    map_mem_closureâ‚‚ continuous_mul hx hy fun _ ha _ hb => s.mul_mem ha hb\n\n"}
{"name":"Submonoid.top_closure_mul_self_subset","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : ContinuousMul M\ns : Submonoid M\nâŠ¢ HasSubset.Subset (HMul.hMul (closure â†‘s) (closure â†‘s)) (closure â†‘s)","decl":"@[to_additive]\ntheorem Submonoid.top_closure_mul_self_subset (s : Submonoid M) :\n    _root_.closure (s : Set M) * _root_.closure s âŠ† _root_.closure s :=\n  image2_subset_iff.2 fun _ hx _ hy =>\n    map_mem_closureâ‚‚ continuous_mul hx hy fun _ ha _ hb => s.mul_mem ha hb\n\n"}
{"name":"Submonoid.top_closure_mul_self_eq","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : ContinuousMul M\ns : Submonoid M\nâŠ¢ Eq (HMul.hMul (closure â†‘s) (closure â†‘s)) (closure â†‘s)","decl":"@[to_additive]\ntheorem Submonoid.top_closure_mul_self_eq (s : Submonoid M) :\n    _root_.closure (s : Set M) * _root_.closure s = _root_.closure s :=\n  Subset.antisymm s.top_closure_mul_self_subset fun x hx =>\n    âŸ¨x, hx, 1, _root_.subset_closure s.one_mem, mul_one _âŸ©\n\n"}
{"name":"AddSubmonoid.top_closure_add_self_eq","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : ContinuousAdd M\ns : AddSubmonoid M\nâŠ¢ Eq (HAdd.hAdd (closure â†‘s) (closure â†‘s)) (closure â†‘s)","decl":"@[to_additive]\ntheorem Submonoid.top_closure_mul_self_eq (s : Submonoid M) :\n    _root_.closure (s : Set M) * _root_.closure s = _root_.closure s :=\n  Subset.antisymm s.top_closure_mul_self_subset fun x hx =>\n    âŸ¨x, hx, 1, _root_.subset_closure s.one_mem, mul_one _âŸ©\n\n"}
{"name":"AddSubmonoid.coe_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : ContinuousAdd M\ns : AddSubmonoid M\nâŠ¢ Eq (â†‘s.topologicalClosure) (closure â†‘s)","decl":"@[to_additive]\ntheorem Submonoid.coe_topologicalClosure (s : Submonoid M) :\n    (s.topologicalClosure : Set M) = _root_.closure (s : Set M) := rfl\n\n"}
{"name":"Submonoid.coe_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : ContinuousMul M\ns : Submonoid M\nâŠ¢ Eq (â†‘s.topologicalClosure) (closure â†‘s)","decl":"@[to_additive]\ntheorem Submonoid.coe_topologicalClosure (s : Submonoid M) :\n    (s.topologicalClosure : Set M) = _root_.closure (s : Set M) := rfl\n\n"}
{"name":"Submonoid.le_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : ContinuousMul M\ns : Submonoid M\nâŠ¢ LE.le s s.topologicalClosure","decl":"@[to_additive]\ntheorem Submonoid.le_topologicalClosure (s : Submonoid M) : s â‰¤ s.topologicalClosure :=\n  _root_.subset_closure\n\n"}
{"name":"AddSubmonoid.le_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : ContinuousAdd M\ns : AddSubmonoid M\nâŠ¢ LE.le s s.topologicalClosure","decl":"@[to_additive]\ntheorem Submonoid.le_topologicalClosure (s : Submonoid M) : s â‰¤ s.topologicalClosure :=\n  _root_.subset_closure\n\n"}
{"name":"Submonoid.isClosed_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : ContinuousMul M\ns : Submonoid M\nâŠ¢ IsClosed â†‘s.topologicalClosure","decl":"@[to_additive]\ntheorem Submonoid.isClosed_topologicalClosure (s : Submonoid M) :\n    IsClosed (s.topologicalClosure : Set M) := isClosed_closure\n\n"}
{"name":"AddSubmonoid.isClosed_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : ContinuousAdd M\ns : AddSubmonoid M\nâŠ¢ IsClosed â†‘s.topologicalClosure","decl":"@[to_additive]\ntheorem Submonoid.isClosed_topologicalClosure (s : Submonoid M) :\n    IsClosed (s.topologicalClosure : Set M) := isClosed_closure\n\n"}
{"name":"Submonoid.topologicalClosure_minimal","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : ContinuousMul M\ns t : Submonoid M\nh : LE.le s t\nht : IsClosed â†‘t\nâŠ¢ LE.le s.topologicalClosure t","decl":"@[to_additive]\ntheorem Submonoid.topologicalClosure_minimal (s : Submonoid M) {t : Submonoid M} (h : s â‰¤ t)\n    (ht : IsClosed (t : Set M)) : s.topologicalClosure â‰¤ t := closure_minimal h ht\n\n"}
{"name":"AddSubmonoid.topologicalClosure_minimal","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : ContinuousAdd M\ns t : AddSubmonoid M\nh : LE.le s t\nht : IsClosed â†‘t\nâŠ¢ LE.le s.topologicalClosure t","decl":"@[to_additive]\ntheorem Submonoid.topologicalClosure_minimal (s : Submonoid M) {t : Submonoid M} (h : s â‰¤ t)\n    (ht : IsClosed (t : Set M)) : s.topologicalClosure â‰¤ t := closure_minimal h ht\n\n"}
{"name":"exists_nhds_one_split4","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : ContinuousMul M\nu : Set M\nhu : Membership.mem (nhds 1) u\nâŠ¢ Exists fun V => And (Membership.mem (nhds 1) V) (âˆ€ {v w s t : M}, Membership.mem V v â†’ Membership.mem V w â†’ Membership.mem V s â†’ Membership.mem V t â†’ Membership.mem u (HMul.hMul (HMul.hMul (HMul.hMul v w) s) t))","decl":"@[to_additive exists_nhds_zero_quarter]\ntheorem exists_nhds_one_split4 {u : Set M} (hu : u âˆˆ ğ“ (1 : M)) :\n    âˆƒ V âˆˆ ğ“ (1 : M), âˆ€ {v w s t}, v âˆˆ V â†’ w âˆˆ V â†’ s âˆˆ V â†’ t âˆˆ V â†’ v * w * s * t âˆˆ u := by\n  rcases exists_nhds_one_split hu with âŸ¨W, W1, hâŸ©\n  rcases exists_nhds_one_split W1 with âŸ¨V, V1, h'âŸ©\n  use V, V1\n  intro v w s t v_in w_in s_in t_in\n  simpa only [mul_assoc] using h _ (h' v v_in w w_in) _ (h' s s_in t t_in)\n\n"}
{"name":"exists_nhds_zero_quarter","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : ContinuousAdd M\nu : Set M\nhu : Membership.mem (nhds 0) u\nâŠ¢ Exists fun V => And (Membership.mem (nhds 0) V) (âˆ€ {v w s t : M}, Membership.mem V v â†’ Membership.mem V w â†’ Membership.mem V s â†’ Membership.mem V t â†’ Membership.mem u (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd v w) s) t))","decl":"@[to_additive exists_nhds_zero_quarter]\ntheorem exists_nhds_one_split4 {u : Set M} (hu : u âˆˆ ğ“ (1 : M)) :\n    âˆƒ V âˆˆ ğ“ (1 : M), âˆ€ {v w s t}, v âˆˆ V â†’ w âˆˆ V â†’ s âˆˆ V â†’ t âˆˆ V â†’ v * w * s * t âˆˆ u := by\n  rcases exists_nhds_one_split hu with âŸ¨W, W1, hâŸ©\n  rcases exists_nhds_one_split W1 with âŸ¨V, V1, h'âŸ©\n  use V, V1\n  intro v w s t v_in w_in s_in t_in\n  simpa only [mul_assoc] using h _ (h' v v_in w w_in) _ (h' s s_in t t_in)\n\n"}
{"name":"tendsto_list_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\nM : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : ContinuousMul M\nf : Î¹ â†’ Î± â†’ M\nx : Filter Î±\na : Î¹ â†’ M\nl : List Î¹\naâœ : âˆ€ (i : Î¹), Membership.mem l i â†’ Filter.Tendsto (f i) x (nhds (a i))\nâŠ¢ Filter.Tendsto (fun b => (List.map (fun c => f c b) l).prod) x (nhds (List.map a l).prod)","decl":"@[to_additive]\ntheorem tendsto_list_prod {f : Î¹ â†’ Î± â†’ M} {x : Filter Î±} {a : Î¹ â†’ M} :\n    âˆ€ l : List Î¹,\n      (âˆ€ i âˆˆ l, Tendsto (f i) x (ğ“ (a i))) â†’\n        Tendsto (fun b => (l.map fun c => f c b).prod) x (ğ“ (l.map a).prod)\n  | [], _ => by simp [tendsto_const_nhds]\n  | f::l, h => by\n    simp only [List.map_cons, List.prod_cons]\n    exact\n      (h f (List.mem_cons_self _ _)).mul\n        (tendsto_list_prod l fun c hc => h c (List.mem_cons_of_mem _ hc))\n\n"}
{"name":"tendsto_list_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\nM : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : ContinuousAdd M\nf : Î¹ â†’ Î± â†’ M\nx : Filter Î±\na : Î¹ â†’ M\nl : List Î¹\naâœ : âˆ€ (i : Î¹), Membership.mem l i â†’ Filter.Tendsto (f i) x (nhds (a i))\nâŠ¢ Filter.Tendsto (fun b => (List.map (fun c => f c b) l).sum) x (nhds (List.map a l).sum)","decl":"@[to_additive]\ntheorem tendsto_list_prod {f : Î¹ â†’ Î± â†’ M} {x : Filter Î±} {a : Î¹ â†’ M} :\n    âˆ€ l : List Î¹,\n      (âˆ€ i âˆˆ l, Tendsto (f i) x (ğ“ (a i))) â†’\n        Tendsto (fun b => (l.map fun c => f c b).prod) x (ğ“ (l.map a).prod)\n  | [], _ => by simp [tendsto_const_nhds]\n  | f::l, h => by\n    simp only [List.map_cons, List.prod_cons]\n    exact\n      (h f (List.mem_cons_self _ _)).mul\n        (tendsto_list_prod l fun c hc => h c (List.mem_cons_of_mem _ hc))\n\n"}
{"name":"continuous_list_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nM : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : ContinuousMul M\nf : Î¹ â†’ X â†’ M\nl : List Î¹\nh : âˆ€ (i : Î¹), Membership.mem l i â†’ Continuous (f i)\nâŠ¢ Continuous fun a => (List.map (fun i => f i a) l).prod","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_list_prod {f : Î¹ â†’ X â†’ M} (l : List Î¹) (h : âˆ€ i âˆˆ l, Continuous (f i)) :\n    Continuous fun a => (l.map fun i => f i a).prod :=\n  continuous_iff_continuousAt.2 fun x =>\n    tendsto_list_prod l fun c hc => continuous_iff_continuousAt.1 (h c hc) x\n\n"}
{"name":"continuous_list_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nM : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : ContinuousAdd M\nf : Î¹ â†’ X â†’ M\nl : List Î¹\nh : âˆ€ (i : Î¹), Membership.mem l i â†’ Continuous (f i)\nâŠ¢ Continuous fun a => (List.map (fun i => f i a) l).sum","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_list_prod {f : Î¹ â†’ X â†’ M} (l : List Î¹) (h : âˆ€ i âˆˆ l, Continuous (f i)) :\n    Continuous fun a => (l.map fun i => f i a).prod :=\n  continuous_iff_continuousAt.2 fun x =>\n    tendsto_list_prod l fun c hc => continuous_iff_continuousAt.1 (h c hc) x\n\n"}
{"name":"continuousOn_list_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nM : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : ContinuousMul M\nf : Î¹ â†’ X â†’ M\nl : List Î¹\nt : Set X\nh : âˆ€ (i : Î¹), Membership.mem l i â†’ ContinuousOn (f i) t\nâŠ¢ ContinuousOn (fun a => (List.map (fun i => f i a) l).prod) t","decl":"@[to_additive]\ntheorem continuousOn_list_prod {f : Î¹ â†’ X â†’ M} (l : List Î¹) {t : Set X}\n    (h : âˆ€ i âˆˆ l, ContinuousOn (f i) t) :\n    ContinuousOn (fun a => (l.map fun i => f i a).prod) t := by\n  intro x hx\n  rw [continuousWithinAt_iff_continuousAt_restrict _ hx]\n  refine tendsto_list_prod _ fun i hi => ?_\n  specialize h i hi x hx\n  rw [continuousWithinAt_iff_continuousAt_restrict _ hx] at h\n  exact h\n\n"}
{"name":"continuousOn_list_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nM : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : ContinuousAdd M\nf : Î¹ â†’ X â†’ M\nl : List Î¹\nt : Set X\nh : âˆ€ (i : Î¹), Membership.mem l i â†’ ContinuousOn (f i) t\nâŠ¢ ContinuousOn (fun a => (List.map (fun i => f i a) l).sum) t","decl":"@[to_additive]\ntheorem continuousOn_list_prod {f : Î¹ â†’ X â†’ M} (l : List Î¹) {t : Set X}\n    (h : âˆ€ i âˆˆ l, ContinuousOn (f i) t) :\n    ContinuousOn (fun a => (l.map fun i => f i a).prod) t := by\n  intro x hx\n  rw [continuousWithinAt_iff_continuousAt_restrict _ hx]\n  refine tendsto_list_prod _ fun i hi => ?_\n  specialize h i hi x hx\n  rw [continuousWithinAt_iff_continuousAt_restrict _ hx] at h\n  exact h\n\n"}
{"name":"continuous_nsmul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : ContinuousAdd M\nn : Nat\nâŠ¢ Continuous fun a => HSMul.hSMul n a","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_pow : âˆ€ n : â„•, Continuous fun a : M => a ^ n\n  | 0 => by simpa using continuous_const\n  | k + 1 => by\n    simp only [pow_succ']\n    exact continuous_id.mul (continuous_pow _)\n\n"}
{"name":"continuous_pow","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : ContinuousMul M\nn : Nat\nâŠ¢ Continuous fun a => HPow.hPow a n","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_pow : âˆ€ n : â„•, Continuous fun a : M => a ^ n\n  | 0 => by simpa using continuous_const\n  | k + 1 => by\n    simp only [pow_succ']\n    exact continuous_id.mul (continuous_pow _)\n\n"}
{"name":"AddMonoid.continuousConstSMul_nat","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"A : Type u_6\ninstâœÂ² : AddMonoid A\ninstâœÂ¹ : TopologicalSpace A\ninstâœ : ContinuousAdd A\nâŠ¢ ContinuousConstSMul Nat A","decl":"instance AddMonoid.continuousConstSMul_nat {A} [AddMonoid A] [TopologicalSpace A]\n    [ContinuousAdd A] : ContinuousConstSMul â„• A :=\n  âŸ¨continuous_nsmulâŸ©\n\n"}
{"name":"AddMonoid.continuousSMul_nat","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"A : Type u_6\ninstâœÂ² : AddMonoid A\ninstâœÂ¹ : TopologicalSpace A\ninstâœ : ContinuousAdd A\nâŠ¢ ContinuousSMul Nat A","decl":"instance AddMonoid.continuousSMul_nat {A} [AddMonoid A] [TopologicalSpace A]\n    [ContinuousAdd A] : ContinuousSMul â„• A :=\n  âŸ¨continuous_prod_of_discrete_left.mpr continuous_nsmulâŸ©\n\n-- We register `Continuous.pow` as a `continuity` lemma with low penalty (so\n-- `continuity` will try it before other `continuity` lemmas). This is a\n-- workaround for goals of the form `Continuous fun x => x ^ 2`, where\n-- `continuity` applies `Continuous.mul` since the goal is defeq to\n-- `Continuous fun x => x * x`.\n--\n-- To properly fix this, we should make sure that `continuity` applies its\n-- lemmas with reducible transparency, preventing the unfolding of `^`. But this\n-- is quite an invasive change.\n"}
{"name":"Continuous.pow","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : ContinuousMul M\nf : X â†’ M\nh : Continuous f\nn : Nat\nâŠ¢ Continuous fun b => HPow.hPow (f b) n","decl":"@[to_additive (attr := aesop safe -100 (rule_sets := [Continuous]), fun_prop)]\ntheorem Continuous.pow {f : X â†’ M} (h : Continuous f) (n : â„•) : Continuous fun b => f b ^ n :=\n  (continuous_pow n).comp h\n\n"}
{"name":"Continuous.nsmul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : ContinuousAdd M\nf : X â†’ M\nh : Continuous f\nn : Nat\nâŠ¢ Continuous fun b => HSMul.hSMul n (f b)","decl":"@[to_additive (attr := aesop safe -100 (rule_sets := [Continuous]), fun_prop)]\ntheorem Continuous.pow {f : X â†’ M} (h : Continuous f) (n : â„•) : Continuous fun b => f b ^ n :=\n  (continuous_pow n).comp h\n\n"}
{"name":"continuousOn_pow","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : ContinuousMul M\ns : Set M\nn : Nat\nâŠ¢ ContinuousOn (fun x => HPow.hPow x n) s","decl":"@[to_additive]\ntheorem continuousOn_pow {s : Set M} (n : â„•) : ContinuousOn (fun (x : M) => x ^ n) s :=\n  (continuous_pow n).continuousOn\n\n"}
{"name":"continuousOn_nsmul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : ContinuousAdd M\ns : Set M\nn : Nat\nâŠ¢ ContinuousOn (fun x => HSMul.hSMul n x) s","decl":"@[to_additive]\ntheorem continuousOn_pow {s : Set M} (n : â„•) : ContinuousOn (fun (x : M) => x ^ n) s :=\n  (continuous_pow n).continuousOn\n\n"}
{"name":"continuousAt_nsmul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : ContinuousAdd M\nx : M\nn : Nat\nâŠ¢ ContinuousAt (fun x => HSMul.hSMul n x) x","decl":"@[to_additive]\ntheorem continuousAt_pow (x : M) (n : â„•) : ContinuousAt (fun (x : M) => x ^ n) x :=\n  (continuous_pow n).continuousAt\n\n"}
{"name":"continuousAt_pow","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : ContinuousMul M\nx : M\nn : Nat\nâŠ¢ ContinuousAt (fun x => HPow.hPow x n) x","decl":"@[to_additive]\ntheorem continuousAt_pow (x : M) (n : â„•) : ContinuousAt (fun (x : M) => x ^ n) x :=\n  (continuous_pow n).continuousAt\n\n"}
{"name":"Filter.Tendsto.nsmul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_2\nM : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : ContinuousAdd M\nl : Filter Î±\nf : Î± â†’ M\nx : M\nhf : Filter.Tendsto f l (nhds x)\nn : Nat\nâŠ¢ Filter.Tendsto (fun x => HSMul.hSMul n (f x)) l (nhds (HSMul.hSMul n x))","decl":"@[to_additive]\ntheorem Filter.Tendsto.pow {l : Filter Î±} {f : Î± â†’ M} {x : M} (hf : Tendsto f l (ğ“ x)) (n : â„•) :\n    Tendsto (fun x => f x ^ n) l (ğ“ (x ^ n)) :=\n  (continuousAt_pow _ _).tendsto.comp hf\n\n"}
{"name":"Filter.Tendsto.pow","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_2\nM : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : ContinuousMul M\nl : Filter Î±\nf : Î± â†’ M\nx : M\nhf : Filter.Tendsto f l (nhds x)\nn : Nat\nâŠ¢ Filter.Tendsto (fun x => HPow.hPow (f x) n) l (nhds (HPow.hPow x n))","decl":"@[to_additive]\ntheorem Filter.Tendsto.pow {l : Filter Î±} {f : Î± â†’ M} {x : M} (hf : Tendsto f l (ğ“ x)) (n : â„•) :\n    Tendsto (fun x => f x ^ n) l (ğ“ (x ^ n)) :=\n  (continuousAt_pow _ _).tendsto.comp hf\n\n"}
{"name":"ContinuousWithinAt.pow","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : ContinuousMul M\nf : X â†’ M\nx : X\ns : Set X\nhf : ContinuousWithinAt f s x\nn : Nat\nâŠ¢ ContinuousWithinAt (fun x => HPow.hPow (f x) n) s x","decl":"@[to_additive]\ntheorem ContinuousWithinAt.pow {f : X â†’ M} {x : X} {s : Set X} (hf : ContinuousWithinAt f s x)\n    (n : â„•) : ContinuousWithinAt (fun x => f x ^ n) s x :=\n  Filter.Tendsto.pow hf n\n\n"}
{"name":"ContinuousWithinAt.nsmul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : ContinuousAdd M\nf : X â†’ M\nx : X\ns : Set X\nhf : ContinuousWithinAt f s x\nn : Nat\nâŠ¢ ContinuousWithinAt (fun x => HSMul.hSMul n (f x)) s x","decl":"@[to_additive]\ntheorem ContinuousWithinAt.pow {f : X â†’ M} {x : X} {s : Set X} (hf : ContinuousWithinAt f s x)\n    (n : â„•) : ContinuousWithinAt (fun x => f x ^ n) s x :=\n  Filter.Tendsto.pow hf n\n\n"}
{"name":"ContinuousAt.pow","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : ContinuousMul M\nf : X â†’ M\nx : X\nhf : ContinuousAt f x\nn : Nat\nâŠ¢ ContinuousAt (fun x => HPow.hPow (f x) n) x","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousAt.pow {f : X â†’ M} {x : X} (hf : ContinuousAt f x) (n : â„•) :\n    ContinuousAt (fun x => f x ^ n) x :=\n  Filter.Tendsto.pow hf n\n\n"}
{"name":"ContinuousAt.nsmul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : ContinuousAdd M\nf : X â†’ M\nx : X\nhf : ContinuousAt f x\nn : Nat\nâŠ¢ ContinuousAt (fun x => HSMul.hSMul n (f x)) x","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousAt.pow {f : X â†’ M} {x : X} (hf : ContinuousAt f x) (n : â„•) :\n    ContinuousAt (fun x => f x ^ n) x :=\n  Filter.Tendsto.pow hf n\n\n"}
{"name":"ContinuousOn.nsmul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : ContinuousAdd M\nf : X â†’ M\ns : Set X\nhf : ContinuousOn f s\nn : Nat\nâŠ¢ ContinuousOn (fun x => HSMul.hSMul n (f x)) s","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousOn.pow {f : X â†’ M} {s : Set X} (hf : ContinuousOn f s) (n : â„•) :\n    ContinuousOn (fun x => f x ^ n) s := fun x hx => (hf x hx).pow n\n\n"}
{"name":"ContinuousOn.pow","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : ContinuousMul M\nf : X â†’ M\ns : Set X\nhf : ContinuousOn f s\nn : Nat\nâŠ¢ ContinuousOn (fun x => HPow.hPow (f x) n) s","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousOn.pow {f : X â†’ M} {s : Set X} (hf : ContinuousOn f s) (n : â„•) :\n    ContinuousOn (fun x => f x ^ n) s := fun x hx => (hf x hx).pow n\n\n"}
{"name":"Filter.tendsto_cocompact_mul_left","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : ContinuousMul M\na b : M\nha : Eq (HMul.hMul b a) 1\nâŠ¢ Filter.Tendsto (fun x => HMul.hMul a x) (Filter.cocompact M) (Filter.cocompact M)","decl":"/-- Left-multiplication by a left-invertible element of a topological monoid is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem Filter.tendsto_cocompact_mul_left {a b : M} (ha : b * a = 1) :\n    Filter.Tendsto (fun x : M => a * x) (Filter.cocompact M) (Filter.cocompact M) := by\n  refine Filter.Tendsto.of_tendsto_comp ?_ (Filter.comap_cocompact_le (continuous_mul_left b))\n  convert Filter.tendsto_id\n  ext x\n  simp [â† mul_assoc, ha]\n\n"}
{"name":"Filter.tendsto_cocompact_mul_right","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : ContinuousMul M\na b : M\nha : Eq (HMul.hMul a b) 1\nâŠ¢ Filter.Tendsto (fun x => HMul.hMul x a) (Filter.cocompact M) (Filter.cocompact M)","decl":"/-- Right-multiplication by a right-invertible element of a topological monoid is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem Filter.tendsto_cocompact_mul_right {a b : M} (ha : a * b = 1) :\n    Filter.Tendsto (fun x : M => x * a) (Filter.cocompact M) (Filter.cocompact M) := by\n  refine Filter.Tendsto.of_tendsto_comp ?_ (Filter.comap_cocompact_le (continuous_mul_right b))\n  simp only [comp_mul_right, ha, mul_one]\n  exact Filter.tendsto_id\n  -- Porting note: changed proof\n\n"}
{"name":"VAddAssocClass.continuousConstVAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"R : Type u_6\nA : Type u_7\ninstâœâ´ : AddMonoid A\ninstâœÂ³ : VAdd R A\ninstâœÂ² : VAddAssocClass R A A\ninstâœÂ¹ : TopologicalSpace A\ninstâœ : ContinuousAdd A\nâŠ¢ ContinuousConstVAdd R A","decl":"/-- If `R` acts on `A` via `A`, then continuous multiplication implies continuous scalar\nmultiplication by constants.\n\nNotably, this instances applies when `R = A`, or when `[Algebra R A]` is available. -/\n@[to_additive \"If `R` acts on `A` via `A`, then continuous addition implies\ncontinuous affine addition by constants.\"]\ninstance (priority := 100) IsScalarTower.continuousConstSMul {R A : Type*} [Monoid A] [SMul R A]\n    [IsScalarTower R A A] [TopologicalSpace A] [ContinuousMul A] : ContinuousConstSMul R A where\n  continuous_const_smul q := by\n    simp (config := { singlePass := true }) only [â† smul_one_mul q (_ : A)]\n    exact continuous_const.mul continuous_id\n\n"}
{"name":"IsScalarTower.continuousConstSMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"R : Type u_6\nA : Type u_7\ninstâœâ´ : Monoid A\ninstâœÂ³ : SMul R A\ninstâœÂ² : IsScalarTower R A A\ninstâœÂ¹ : TopologicalSpace A\ninstâœ : ContinuousMul A\nâŠ¢ ContinuousConstSMul R A","decl":"/-- If `R` acts on `A` via `A`, then continuous multiplication implies continuous scalar\nmultiplication by constants.\n\nNotably, this instances applies when `R = A`, or when `[Algebra R A]` is available. -/\n@[to_additive \"If `R` acts on `A` via `A`, then continuous addition implies\ncontinuous affine addition by constants.\"]\ninstance (priority := 100) IsScalarTower.continuousConstSMul {R A : Type*} [Monoid A] [SMul R A]\n    [IsScalarTower R A A] [TopologicalSpace A] [ContinuousMul A] : ContinuousConstSMul R A where\n  continuous_const_smul q := by\n    simp (config := { singlePass := true }) only [â† smul_one_mul q (_ : A)]\n    exact continuous_const.mul continuous_id\n\n"}
{"name":"VAddCommClass.continuousConstVAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"R : Type u_6\nA : Type u_7\ninstâœâ´ : AddMonoid A\ninstâœÂ³ : VAdd R A\ninstâœÂ² : VAddCommClass R A A\ninstâœÂ¹ : TopologicalSpace A\ninstâœ : ContinuousAdd A\nâŠ¢ ContinuousConstVAdd R A","decl":"/-- If the action of `R` on `A` commutes with left-multiplication, then continuous multiplication\nimplies continuous scalar multiplication by constants.\n\nNotably, this instances applies when `R = Aáµáµ’áµ–`. -/\n@[to_additive \"If the action of `R` on `A` commutes with left-addition, then\ncontinuous addition implies continuous affine addition by constants.\n\nNotably, this instances applies when `R = Aáµƒáµ’áµ–`.\"]\ninstance (priority := 100) SMulCommClass.continuousConstSMul {R A : Type*} [Monoid A] [SMul R A]\n    [SMulCommClass R A A] [TopologicalSpace A] [ContinuousMul A] : ContinuousConstSMul R A where\n  continuous_const_smul q := by\n    simp (config := { singlePass := true }) only [â† mul_smul_one q (_ : A)]\n    exact continuous_id.mul continuous_const\n\n"}
{"name":"SMulCommClass.continuousConstSMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"R : Type u_6\nA : Type u_7\ninstâœâ´ : Monoid A\ninstâœÂ³ : SMul R A\ninstâœÂ² : SMulCommClass R A A\ninstâœÂ¹ : TopologicalSpace A\ninstâœ : ContinuousMul A\nâŠ¢ ContinuousConstSMul R A","decl":"/-- If the action of `R` on `A` commutes with left-multiplication, then continuous multiplication\nimplies continuous scalar multiplication by constants.\n\nNotably, this instances applies when `R = Aáµáµ’áµ–`. -/\n@[to_additive \"If the action of `R` on `A` commutes with left-addition, then\ncontinuous addition implies continuous affine addition by constants.\n\nNotably, this instances applies when `R = Aáµƒáµ’áµ–`.\"]\ninstance (priority := 100) SMulCommClass.continuousConstSMul {R A : Type*} [Monoid A] [SMul R A]\n    [SMulCommClass R A A] [TopologicalSpace A] [ContinuousMul A] : ContinuousConstSMul R A where\n  continuous_const_smul q := by\n    simp (config := { singlePass := true }) only [â† mul_smul_one q (_ : A)]\n    exact continuous_id.mul continuous_const\n\n"}
{"name":"MulOpposite.instContinuousMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Mul Î±\ninstâœ : ContinuousMul Î±\nâŠ¢ ContinuousMul (MulOpposite Î±)","decl":"/-- If multiplication is continuous in `Î±`, then it also is in `Î±áµáµ’áµ–`. -/\n@[to_additive \"If addition is continuous in `Î±`, then it also is in `Î±áµƒáµ’áµ–`.\"]\ninstance [TopologicalSpace Î±] [Mul Î±] [ContinuousMul Î±] : ContinuousMul Î±áµáµ’áµ– :=\n  âŸ¨continuous_op.comp (continuous_unop.snd'.mul continuous_unop.fst')âŸ©\n\n"}
{"name":"AddOpposite.instContinuousAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Add Î±\ninstâœ : ContinuousAdd Î±\nâŠ¢ ContinuousAdd (AddOpposite Î±)","decl":"/-- If multiplication is continuous in `Î±`, then it also is in `Î±áµáµ’áµ–`. -/\n@[to_additive \"If addition is continuous in `Î±`, then it also is in `Î±áµƒáµ’áµ–`.\"]\ninstance [TopologicalSpace Î±] [Mul Î±] [ContinuousMul Î±] : ContinuousMul Î±áµáµ’áµ– :=\n  âŸ¨continuous_op.comp (continuous_unop.snd'.mul continuous_unop.fst')âŸ©\n\n"}
{"name":"AddUnits.instContinuousAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : AddMonoid Î±\ninstâœ : ContinuousAdd Î±\nâŠ¢ ContinuousAdd (AddUnits Î±)","decl":"/-- If multiplication on a monoid is continuous, then multiplication on the units of the monoid,\nwith respect to the induced topology, is continuous.\n\nInversion is also continuous, but we register this in a later file, `Topology.Algebra.Group`,\nbecause the predicate `ContinuousInv` has not yet been defined. -/\n@[to_additive \"If addition on an additive monoid is continuous, then addition on the additive units\nof the monoid, with respect to the induced topology, is continuous.\n\nNegation is also continuous, but we register this in a later file, `Topology.Algebra.Group`, because\nthe predicate `ContinuousNeg` has not yet been defined.\"]\ninstance : ContinuousMul Î±Ë£ := isInducing_embedProduct.continuousMul (embedProduct Î±)\n\n"}
{"name":"Units.instContinuousMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î± : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Monoid Î±\ninstâœ : ContinuousMul Î±\nâŠ¢ ContinuousMul (Units Î±)","decl":"/-- If multiplication on a monoid is continuous, then multiplication on the units of the monoid,\nwith respect to the induced topology, is continuous.\n\nInversion is also continuous, but we register this in a later file, `Topology.Algebra.Group`,\nbecause the predicate `ContinuousInv` has not yet been defined. -/\n@[to_additive \"If addition on an additive monoid is continuous, then addition on the additive units\nof the monoid, with respect to the induced topology, is continuous.\n\nNegation is also continuous, but we register this in a later file, `Topology.Algebra.Group`, because\nthe predicate `ContinuousNeg` has not yet been defined.\"]\ninstance : ContinuousMul Î±Ë£ := isInducing_embedProduct.continuousMul (embedProduct Î±)\n\n"}
{"name":"Continuous.units_map","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nN : Type u_4\ninstâœÂ³ : Monoid M\ninstâœÂ² : Monoid N\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : TopologicalSpace N\nf : MonoidHom M N\nhf : Continuous â‡‘f\nâŠ¢ Continuous â‡‘(Units.map f)","decl":"@[to_additive]\ntheorem Continuous.units_map [Monoid M] [Monoid N] [TopologicalSpace M] [TopologicalSpace N]\n    (f : M â†’* N) (hf : Continuous f) : Continuous (Units.map f) :=\n  Units.continuous_iff.2 âŸ¨hf.comp Units.continuous_val, hf.comp Units.continuous_coe_invâŸ©\n\n"}
{"name":"Continuous.addUnits_map","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nN : Type u_4\ninstâœÂ³ : AddMonoid M\ninstâœÂ² : AddMonoid N\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : TopologicalSpace N\nf : AddMonoidHom M N\nhf : Continuous â‡‘f\nâŠ¢ Continuous â‡‘(AddUnits.map f)","decl":"@[to_additive]\ntheorem Continuous.units_map [Monoid M] [Monoid N] [TopologicalSpace M] [TopologicalSpace N]\n    (f : M â†’* N) (hf : Continuous f) : Continuous (Units.map f) :=\n  Units.continuous_iff.2 âŸ¨hf.comp Units.continuous_val, hf.comp Units.continuous_coe_invâŸ©\n\n"}
{"name":"Submonoid.mem_nhds_one","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : CommMonoid M\nS : Submonoid M\noS : IsOpen â†‘S\nâŠ¢ Membership.mem (nhds 1) â†‘S","decl":"@[to_additive]\ntheorem Submonoid.mem_nhds_one (S : Submonoid M) (oS : IsOpen (S : Set M)) :\n    (S : Set M) âˆˆ ğ“ (1 : M) :=\n  IsOpen.mem_nhds oS S.one_mem\n\n"}
{"name":"AddSubmonoid.mem_nhds_zero","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : AddCommMonoid M\nS : AddSubmonoid M\noS : IsOpen â†‘S\nâŠ¢ Membership.mem (nhds 0) â†‘S","decl":"@[to_additive]\ntheorem Submonoid.mem_nhds_one (S : Submonoid M) (oS : IsOpen (S : Set M)) :\n    (S : Set M) âˆˆ ğ“ (1 : M) :=\n  IsOpen.mem_nhds oS S.one_mem\n\n"}
{"name":"tendsto_multiset_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\nM : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : CommMonoid M\ninstâœ : ContinuousMul M\nf : Î¹ â†’ Î± â†’ M\nx : Filter Î±\na : Î¹ â†’ M\ns : Multiset Î¹\naâœ : âˆ€ (i : Î¹), Membership.mem s i â†’ Filter.Tendsto (f i) x (nhds (a i))\nâŠ¢ Filter.Tendsto (fun b => (Multiset.map (fun c => f c b) s).prod) x (nhds (Multiset.map a s).prod)","decl":"@[to_additive]\ntheorem tendsto_multiset_prod {f : Î¹ â†’ Î± â†’ M} {x : Filter Î±} {a : Î¹ â†’ M} (s : Multiset Î¹) :\n    (âˆ€ i âˆˆ s, Tendsto (f i) x (ğ“ (a i))) â†’\n      Tendsto (fun b => (s.map fun c => f c b).prod) x (ğ“ (s.map a).prod) := by\n  rcases s with âŸ¨lâŸ©\n  simpa using tendsto_list_prod l\n\n"}
{"name":"tendsto_multiset_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\nM : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : ContinuousAdd M\nf : Î¹ â†’ Î± â†’ M\nx : Filter Î±\na : Î¹ â†’ M\ns : Multiset Î¹\naâœ : âˆ€ (i : Î¹), Membership.mem s i â†’ Filter.Tendsto (f i) x (nhds (a i))\nâŠ¢ Filter.Tendsto (fun b => (Multiset.map (fun c => f c b) s).sum) x (nhds (Multiset.map a s).sum)","decl":"@[to_additive]\ntheorem tendsto_multiset_prod {f : Î¹ â†’ Î± â†’ M} {x : Filter Î±} {a : Î¹ â†’ M} (s : Multiset Î¹) :\n    (âˆ€ i âˆˆ s, Tendsto (f i) x (ğ“ (a i))) â†’\n      Tendsto (fun b => (s.map fun c => f c b).prod) x (ğ“ (s.map a).prod) := by\n  rcases s with âŸ¨lâŸ©\n  simpa using tendsto_list_prod l\n\n"}
{"name":"tendsto_finset_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\nM : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : ContinuousAdd M\nf : Î¹ â†’ Î± â†’ M\nx : Filter Î±\na : Î¹ â†’ M\ns : Finset Î¹\naâœ : âˆ€ (i : Î¹), Membership.mem s i â†’ Filter.Tendsto (f i) x (nhds (a i))\nâŠ¢ Filter.Tendsto (fun b => s.sum fun c => f c b) x (nhds (s.sum fun c => a c))","decl":"@[to_additive]\ntheorem tendsto_finset_prod {f : Î¹ â†’ Î± â†’ M} {x : Filter Î±} {a : Î¹ â†’ M} (s : Finset Î¹) :\n    (âˆ€ i âˆˆ s, Tendsto (f i) x (ğ“ (a i))) â†’\n      Tendsto (fun b => âˆ c âˆˆ s, f c b) x (ğ“ (âˆ c âˆˆ s, a c)) :=\n  tendsto_multiset_prod _\n\n"}
{"name":"tendsto_finset_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\nM : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : CommMonoid M\ninstâœ : ContinuousMul M\nf : Î¹ â†’ Î± â†’ M\nx : Filter Î±\na : Î¹ â†’ M\ns : Finset Î¹\naâœ : âˆ€ (i : Î¹), Membership.mem s i â†’ Filter.Tendsto (f i) x (nhds (a i))\nâŠ¢ Filter.Tendsto (fun b => s.prod fun c => f c b) x (nhds (s.prod fun c => a c))","decl":"@[to_additive]\ntheorem tendsto_finset_prod {f : Î¹ â†’ Î± â†’ M} {x : Filter Î±} {a : Î¹ â†’ M} (s : Finset Î¹) :\n    (âˆ€ i âˆˆ s, Tendsto (f i) x (ğ“ (a i))) â†’\n      Tendsto (fun b => âˆ c âˆˆ s, f c b) x (ğ“ (âˆ c âˆˆ s, a c)) :=\n  tendsto_multiset_prod _\n\n"}
{"name":"continuous_multiset_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nM : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : ContinuousAdd M\nf : Î¹ â†’ X â†’ M\ns : Multiset Î¹\naâœ : âˆ€ (i : Î¹), Membership.mem s i â†’ Continuous (f i)\nâŠ¢ Continuous fun a => (Multiset.map (fun i => f i a) s).sum","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_multiset_prod {f : Î¹ â†’ X â†’ M} (s : Multiset Î¹) :\n    (âˆ€ i âˆˆ s, Continuous (f i)) â†’ Continuous fun a => (s.map fun i => f i a).prod := by\n  rcases s with âŸ¨lâŸ©\n  simpa using continuous_list_prod l\n\n"}
{"name":"continuous_multiset_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nM : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : CommMonoid M\ninstâœ : ContinuousMul M\nf : Î¹ â†’ X â†’ M\ns : Multiset Î¹\naâœ : âˆ€ (i : Î¹), Membership.mem s i â†’ Continuous (f i)\nâŠ¢ Continuous fun a => (Multiset.map (fun i => f i a) s).prod","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_multiset_prod {f : Î¹ â†’ X â†’ M} (s : Multiset Î¹) :\n    (âˆ€ i âˆˆ s, Continuous (f i)) â†’ Continuous fun a => (s.map fun i => f i a).prod := by\n  rcases s with âŸ¨lâŸ©\n  simpa using continuous_list_prod l\n\n"}
{"name":"continuousOn_multiset_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nM : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : ContinuousAdd M\nf : Î¹ â†’ X â†’ M\ns : Multiset Î¹\nt : Set X\naâœ : âˆ€ (i : Î¹), Membership.mem s i â†’ ContinuousOn (f i) t\nâŠ¢ ContinuousOn (fun a => (Multiset.map (fun i => f i a) s).sum) t","decl":"@[to_additive]\ntheorem continuousOn_multiset_prod {f : Î¹ â†’ X â†’ M} (s : Multiset Î¹) {t : Set X} :\n    (âˆ€ i âˆˆ s, ContinuousOn (f i) t) â†’ ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by\n  rcases s with âŸ¨lâŸ©\n  simpa using continuousOn_list_prod l\n\n"}
{"name":"continuousOn_multiset_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nM : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : CommMonoid M\ninstâœ : ContinuousMul M\nf : Î¹ â†’ X â†’ M\ns : Multiset Î¹\nt : Set X\naâœ : âˆ€ (i : Î¹), Membership.mem s i â†’ ContinuousOn (f i) t\nâŠ¢ ContinuousOn (fun a => (Multiset.map (fun i => f i a) s).prod) t","decl":"@[to_additive]\ntheorem continuousOn_multiset_prod {f : Î¹ â†’ X â†’ M} (s : Multiset Î¹) {t : Set X} :\n    (âˆ€ i âˆˆ s, ContinuousOn (f i) t) â†’ ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by\n  rcases s with âŸ¨lâŸ©\n  simpa using continuousOn_list_prod l\n\n"}
{"name":"continuous_finset_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nM : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : CommMonoid M\ninstâœ : ContinuousMul M\nf : Î¹ â†’ X â†’ M\ns : Finset Î¹\naâœ : âˆ€ (i : Î¹), Membership.mem s i â†’ Continuous (f i)\nâŠ¢ Continuous fun a => s.prod fun i => f i a","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem continuous_finset_prod {f : Î¹ â†’ X â†’ M} (s : Finset Î¹) :\n    (âˆ€ i âˆˆ s, Continuous (f i)) â†’ Continuous fun a => âˆ i âˆˆ s, f i a :=\n  continuous_multiset_prod _\n\n"}
{"name":"continuous_finset_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nM : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : ContinuousAdd M\nf : Î¹ â†’ X â†’ M\ns : Finset Î¹\naâœ : âˆ€ (i : Î¹), Membership.mem s i â†’ Continuous (f i)\nâŠ¢ Continuous fun a => s.sum fun i => f i a","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem continuous_finset_prod {f : Î¹ â†’ X â†’ M} (s : Finset Î¹) :\n    (âˆ€ i âˆˆ s, Continuous (f i)) â†’ Continuous fun a => âˆ i âˆˆ s, f i a :=\n  continuous_multiset_prod _\n\n"}
{"name":"continuousOn_finset_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nM : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : ContinuousAdd M\nf : Î¹ â†’ X â†’ M\ns : Finset Î¹\nt : Set X\naâœ : âˆ€ (i : Î¹), Membership.mem s i â†’ ContinuousOn (f i) t\nâŠ¢ ContinuousOn (fun a => s.sum fun i => f i a) t","decl":"@[to_additive]\ntheorem continuousOn_finset_prod {f : Î¹ â†’ X â†’ M} (s : Finset Î¹) {t : Set X} :\n    (âˆ€ i âˆˆ s, ContinuousOn (f i) t) â†’ ContinuousOn (fun a => âˆ i âˆˆ s, f i a) t :=\n  continuousOn_multiset_prod _\n\n"}
{"name":"continuousOn_finset_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nM : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : CommMonoid M\ninstâœ : ContinuousMul M\nf : Î¹ â†’ X â†’ M\ns : Finset Î¹\nt : Set X\naâœ : âˆ€ (i : Î¹), Membership.mem s i â†’ ContinuousOn (f i) t\nâŠ¢ ContinuousOn (fun a => s.prod fun i => f i a) t","decl":"@[to_additive]\ntheorem continuousOn_finset_prod {f : Î¹ â†’ X â†’ M} (s : Finset Î¹) {t : Set X} :\n    (âˆ€ i âˆˆ s, ContinuousOn (f i) t) â†’ ContinuousOn (fun a => âˆ i âˆˆ s, f i a) t :=\n  continuousOn_multiset_prod _\n\n"}
{"name":"eventuallyEq_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nX : Type u_6\nM : Type u_7\ninstâœ : AddCommMonoid M\ns : Finset Î¹\nl : Filter X\nf g : Î¹ â†’ X â†’ M\nhs : âˆ€ (i : Î¹), Membership.mem s i â†’ l.EventuallyEq (f i) (g i)\nâŠ¢ l.EventuallyEq (s.sum fun i => f i) (s.sum fun i => g i)","decl":"@[to_additive]\ntheorem eventuallyEq_prod {X M : Type*} [CommMonoid M] {s : Finset Î¹} {l : Filter X}\n    {f g : Î¹ â†’ X â†’ M} (hs : âˆ€ i âˆˆ s, f i =á¶ [l] g i) : âˆ i âˆˆ s, f i =á¶ [l] âˆ i âˆˆ s, g i := by\n  replace hs : âˆ€á¶  x in l, âˆ€ i âˆˆ s, f i x = g i x := by rwa [eventually_all_finset]\n  filter_upwards [hs] with x hx\n  simp only [Finset.prod_apply, Finset.prod_congr rfl hx]\n\n"}
{"name":"eventuallyEq_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nX : Type u_6\nM : Type u_7\ninstâœ : CommMonoid M\ns : Finset Î¹\nl : Filter X\nf g : Î¹ â†’ X â†’ M\nhs : âˆ€ (i : Î¹), Membership.mem s i â†’ l.EventuallyEq (f i) (g i)\nâŠ¢ l.EventuallyEq (s.prod fun i => f i) (s.prod fun i => g i)","decl":"@[to_additive]\ntheorem eventuallyEq_prod {X M : Type*} [CommMonoid M] {s : Finset Î¹} {l : Filter X}\n    {f g : Î¹ â†’ X â†’ M} (hs : âˆ€ i âˆˆ s, f i =á¶ [l] g i) : âˆ i âˆˆ s, f i =á¶ [l] âˆ i âˆˆ s, g i := by\n  replace hs : âˆ€á¶  x in l, âˆ€ i âˆˆ s, f i x = g i x := by rwa [eventually_all_finset]\n  filter_upwards [hs] with x hx\n  simp only [Finset.prod_apply, Finset.prod_congr rfl hx]\n\n"}
{"name":"LocallyFinite.exists_finset_support","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nX : Type u_5\ninstâœÂ¹ : TopologicalSpace X\nM : Type u_6\ninstâœ : AddCommMonoid M\nf : Î¹ â†’ X â†’ M\nhf : LocallyFinite fun i => Function.support (f i)\nxâ‚€ : X\nâŠ¢ Exists fun I => Filter.Eventually (fun x => HasSubset.Subset (Function.support fun i => f i x) â†‘I) (nhds xâ‚€)","decl":"@[to_additive]\ntheorem LocallyFinite.exists_finset_mulSupport {M : Type*} [CommMonoid M] {f : Î¹ â†’ X â†’ M}\n    (hf : LocallyFinite fun i => mulSupport <| f i) (xâ‚€ : X) :\n    âˆƒ I : Finset Î¹, âˆ€á¶  x in ğ“ xâ‚€, (mulSupport fun i => f i x) âŠ† I := by\n  rcases hf xâ‚€ with âŸ¨U, hxU, hUfâŸ©\n  refine âŸ¨hUf.toFinset, mem_of_superset hxU fun y hy i hi => ?_âŸ©\n  rw [hUf.coe_toFinset]\n  exact âŸ¨y, hi, hyâŸ©\n\n"}
{"name":"LocallyFinite.exists_finset_mulSupport","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nX : Type u_5\ninstâœÂ¹ : TopologicalSpace X\nM : Type u_6\ninstâœ : CommMonoid M\nf : Î¹ â†’ X â†’ M\nhf : LocallyFinite fun i => Function.mulSupport (f i)\nxâ‚€ : X\nâŠ¢ Exists fun I => Filter.Eventually (fun x => HasSubset.Subset (Function.mulSupport fun i => f i x) â†‘I) (nhds xâ‚€)","decl":"@[to_additive]\ntheorem LocallyFinite.exists_finset_mulSupport {M : Type*} [CommMonoid M] {f : Î¹ â†’ X â†’ M}\n    (hf : LocallyFinite fun i => mulSupport <| f i) (xâ‚€ : X) :\n    âˆƒ I : Finset Î¹, âˆ€á¶  x in ğ“ xâ‚€, (mulSupport fun i => f i x) âŠ† I := by\n  rcases hf xâ‚€ with âŸ¨U, hxU, hUfâŸ©\n  refine âŸ¨hUf.toFinset, mem_of_superset hxU fun y hy i hi => ?_âŸ©\n  rw [hUf.coe_toFinset]\n  exact âŸ¨y, hi, hyâŸ©\n\n"}
{"name":"finprod_eventually_eq_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nX : Type u_5\ninstâœÂ¹ : TopologicalSpace X\nM : Type u_6\ninstâœ : CommMonoid M\nf : Î¹ â†’ X â†’ M\nhf : LocallyFinite fun i => Function.mulSupport (f i)\nx : X\nâŠ¢ Exists fun s => Filter.Eventually (fun y => Eq (finprod fun i => f i y) (s.prod fun i => f i y)) (nhds x)","decl":"@[to_additive]\ntheorem finprod_eventually_eq_prod {M : Type*} [CommMonoid M] {f : Î¹ â†’ X â†’ M}\n    (hf : LocallyFinite fun i => mulSupport (f i)) (x : X) :\n    âˆƒ s : Finset Î¹, âˆ€á¶  y in ğ“ x, âˆá¶  i, f i y = âˆ i âˆˆ s, f i y :=\n  let âŸ¨I, hIâŸ© := hf.exists_finset_mulSupport x\n  âŸ¨I, hI.mono fun _ hy => finprod_eq_prod_of_mulSupport_subset _ fun _ hi => hy hiâŸ©\n\n"}
{"name":"finsum_eventually_eq_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nX : Type u_5\ninstâœÂ¹ : TopologicalSpace X\nM : Type u_6\ninstâœ : AddCommMonoid M\nf : Î¹ â†’ X â†’ M\nhf : LocallyFinite fun i => Function.support (f i)\nx : X\nâŠ¢ Exists fun s => Filter.Eventually (fun y => Eq (finsum fun i => f i y) (s.sum fun i => f i y)) (nhds x)","decl":"@[to_additive]\ntheorem finprod_eventually_eq_prod {M : Type*} [CommMonoid M] {f : Î¹ â†’ X â†’ M}\n    (hf : LocallyFinite fun i => mulSupport (f i)) (x : X) :\n    âˆƒ s : Finset Î¹, âˆ€á¶  y in ğ“ x, âˆá¶  i, f i y = âˆ i âˆˆ s, f i y :=\n  let âŸ¨I, hIâŸ© := hf.exists_finset_mulSupport x\n  âŸ¨I, hI.mono fun _ hy => finprod_eq_prod_of_mulSupport_subset _ fun _ hi => hy hiâŸ©\n\n"}
{"name":"continuous_finprod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nM : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : CommMonoid M\ninstâœ : ContinuousMul M\nf : Î¹ â†’ X â†’ M\nhc : âˆ€ (i : Î¹), Continuous (f i)\nhf : LocallyFinite fun i => Function.mulSupport (f i)\nâŠ¢ Continuous fun x => finprod fun i => f i x","decl":"@[to_additive]\ntheorem continuous_finprod {f : Î¹ â†’ X â†’ M} (hc : âˆ€ i, Continuous (f i))\n    (hf : LocallyFinite fun i => mulSupport (f i)) : Continuous fun x => âˆá¶  i, f i x := by\n  refine continuous_iff_continuousAt.2 fun x => ?_\n  rcases finprod_eventually_eq_prod hf x with âŸ¨s, hsâŸ©\n  refine ContinuousAt.congr ?_ (EventuallyEq.symm hs)\n  exact tendsto_finset_prod _ fun i _ => (hc i).continuousAt\n\n"}
{"name":"continuous_finsum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nM : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : ContinuousAdd M\nf : Î¹ â†’ X â†’ M\nhc : âˆ€ (i : Î¹), Continuous (f i)\nhf : LocallyFinite fun i => Function.support (f i)\nâŠ¢ Continuous fun x => finsum fun i => f i x","decl":"@[to_additive]\ntheorem continuous_finprod {f : Î¹ â†’ X â†’ M} (hc : âˆ€ i, Continuous (f i))\n    (hf : LocallyFinite fun i => mulSupport (f i)) : Continuous fun x => âˆá¶  i, f i x := by\n  refine continuous_iff_continuousAt.2 fun x => ?_\n  rcases finprod_eventually_eq_prod hf x with âŸ¨s, hsâŸ©\n  refine ContinuousAt.congr ?_ (EventuallyEq.symm hs)\n  exact tendsto_finset_prod _ fun i _ => (hc i).continuousAt\n\n"}
{"name":"continuous_finsum_cond","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nM : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : ContinuousAdd M\nf : Î¹ â†’ X â†’ M\np : Î¹ â†’ Prop\nhc : âˆ€ (i : Î¹), p i â†’ Continuous (f i)\nhf : LocallyFinite fun i => Function.support (f i)\nâŠ¢ Continuous fun x => finsum fun i => finsum fun x_1 => f i x","decl":"@[to_additive]\ntheorem continuous_finprod_cond {f : Î¹ â†’ X â†’ M} {p : Î¹ â†’ Prop} (hc : âˆ€ i, p i â†’ Continuous (f i))\n    (hf : LocallyFinite fun i => mulSupport (f i)) :\n    Continuous fun x => âˆá¶  (i) (_ : p i), f i x := by\n  simp only [â† finprod_subtype_eq_finprod_cond]\n  exact continuous_finprod (fun i => hc i i.2) (hf.comp_injective Subtype.coe_injective)\n\n"}
{"name":"continuous_finprod_cond","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"Î¹ : Type u_1\nM : Type u_3\nX : Type u_5\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : CommMonoid M\ninstâœ : ContinuousMul M\nf : Î¹ â†’ X â†’ M\np : Î¹ â†’ Prop\nhc : âˆ€ (i : Î¹), p i â†’ Continuous (f i)\nhf : LocallyFinite fun i => Function.mulSupport (f i)\nâŠ¢ Continuous fun x => finprod fun i => finprod fun x_1 => f i x","decl":"@[to_additive]\ntheorem continuous_finprod_cond {f : Î¹ â†’ X â†’ M} {p : Î¹ â†’ Prop} (hc : âˆ€ i, p i â†’ Continuous (f i))\n    (hf : LocallyFinite fun i => mulSupport (f i)) :\n    Continuous fun x => âˆá¶  (i) (_ : p i), f i x := by\n  simp only [â† finprod_subtype_eq_finprod_cond]\n  exact continuous_finprod (fun i => hc i i.2) (hf.comp_injective Subtype.coe_injective)\n\n"}
{"name":"instContinuousAddAdditiveOfContinuousMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Mul M\ninstâœ : ContinuousMul M\nâŠ¢ ContinuousAdd (Additive M)","decl":"instance [TopologicalSpace M] [Mul M] [ContinuousMul M] : ContinuousAdd (Additive M) where\n  continuous_add := @continuous_mul M _ _ _\n\n"}
{"name":"instContinuousMulMultiplicativeOfContinuousAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Add M\ninstâœ : ContinuousAdd M\nâŠ¢ ContinuousMul (Multiplicative M)","decl":"instance [TopologicalSpace M] [Add M] [ContinuousAdd M] : ContinuousMul (Multiplicative M) where\n  continuous_mul := @continuous_add M _ _ _\n\n"}
{"name":"continuousAdd_sInf","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœ : Add M\nts : Set (TopologicalSpace M)\nh : âˆ€ (t : TopologicalSpace M), Membership.mem ts t â†’ ContinuousAdd M\nâŠ¢ ContinuousAdd M","decl":"@[to_additive]\ntheorem continuousMul_sInf {ts : Set (TopologicalSpace M)}\n    (h : âˆ€ t âˆˆ ts, @ContinuousMul M t _) : @ContinuousMul M (sInf ts) _ :=\n  letI := sInf ts\n  { continuous_mul :=\n      continuous_sInf_rng.2 fun t ht =>\n        continuous_sInf_domâ‚‚ ht ht (@ContinuousMul.continuous_mul M t _ (h t ht)) }\n\n"}
{"name":"continuousMul_sInf","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœ : Mul M\nts : Set (TopologicalSpace M)\nh : âˆ€ (t : TopologicalSpace M), Membership.mem ts t â†’ ContinuousMul M\nâŠ¢ ContinuousMul M","decl":"@[to_additive]\ntheorem continuousMul_sInf {ts : Set (TopologicalSpace M)}\n    (h : âˆ€ t âˆˆ ts, @ContinuousMul M t _) : @ContinuousMul M (sInf ts) _ :=\n  letI := sInf ts\n  { continuous_mul :=\n      continuous_sInf_rng.2 fun t ht =>\n        continuous_sInf_domâ‚‚ ht ht (@ContinuousMul.continuous_mul M t _ (h t ht)) }\n\n"}
{"name":"continuousMul_iInf","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nÎ¹' : Sort u_6\ninstâœ : Mul M\nts : Î¹' â†’ TopologicalSpace M\nh' : âˆ€ (i : Î¹'), ContinuousMul M\nâŠ¢ ContinuousMul M","decl":"@[to_additive]\ntheorem continuousMul_iInf {ts : Î¹' â†’ TopologicalSpace M}\n    (h' : âˆ€ i, @ContinuousMul M (ts i) _) : @ContinuousMul M (â¨… i, ts i) _ := by\n  rw [â† sInf_range]\n  exact continuousMul_sInf (Set.forall_mem_range.mpr h')\n\n"}
{"name":"continuousAdd_iInf","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nÎ¹' : Sort u_6\ninstâœ : Add M\nts : Î¹' â†’ TopologicalSpace M\nh' : âˆ€ (i : Î¹'), ContinuousAdd M\nâŠ¢ ContinuousAdd M","decl":"@[to_additive]\ntheorem continuousMul_iInf {ts : Î¹' â†’ TopologicalSpace M}\n    (h' : âˆ€ i, @ContinuousMul M (ts i) _) : @ContinuousMul M (â¨… i, ts i) _ := by\n  rw [â† sInf_range]\n  exact continuousMul_sInf (Set.forall_mem_range.mpr h')\n\n"}
{"name":"continuousAdd_inf","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœ : Add M\ntâ‚ tâ‚‚ : TopologicalSpace M\nhâ‚ : ContinuousAdd M\nhâ‚‚ : ContinuousAdd M\nâŠ¢ ContinuousAdd M","decl":"@[to_additive]\ntheorem continuousMul_inf {tâ‚ tâ‚‚ : TopologicalSpace M} (hâ‚ : @ContinuousMul M tâ‚ _)\n    (hâ‚‚ : @ContinuousMul M tâ‚‚ _) : @ContinuousMul M (tâ‚ âŠ“ tâ‚‚) _ := by\n  rw [inf_eq_iInf]\n  refine continuousMul_iInf fun b => ?_\n  cases b <;> assumption\n\n"}
{"name":"continuousMul_inf","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninstâœ : Mul M\ntâ‚ tâ‚‚ : TopologicalSpace M\nhâ‚ : ContinuousMul M\nhâ‚‚ : ContinuousMul M\nâŠ¢ ContinuousMul M","decl":"@[to_additive]\ntheorem continuousMul_inf {tâ‚ tâ‚‚ : TopologicalSpace M} (hâ‚ : @ContinuousMul M tâ‚ _)\n    (hâ‚‚ : @ContinuousMul M tâ‚‚ _) : @ContinuousMul M (tâ‚ âŠ“ tâ‚‚) _ := by\n  rw [inf_eq_iInf]\n  refine continuousMul_iInf fun b => ?_\n  cases b <;> assumption\n\n"}
{"name":"ContinuousMap.coe_addRight","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"X : Type u_5\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : Add X\ninstâœ : ContinuousAdd X\nx : X\nâŠ¢ Eq â‡‘(ContinuousMap.addRight x) fun y => HAdd.hAdd y x","decl":"@[to_additive (attr := simp)]\ntheorem coe_mulRight (x : X) : â‡‘(ContinuousMap.mulRight x) = fun y => y * x :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_mulRight","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"X : Type u_5\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : Mul X\ninstâœ : ContinuousMul X\nx : X\nâŠ¢ Eq â‡‘(ContinuousMap.mulRight x) fun y => HMul.hMul y x","decl":"@[to_additive (attr := simp)]\ntheorem coe_mulRight (x : X) : â‡‘(ContinuousMap.mulRight x) = fun y => y * x :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_mulLeft","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"X : Type u_5\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : Mul X\ninstâœ : ContinuousMul X\nx : X\nâŠ¢ Eq â‡‘(ContinuousMap.mulLeft x) fun y => HMul.hMul x y","decl":"@[to_additive (attr := simp)]\ntheorem coe_mulLeft (x : X) : â‡‘(ContinuousMap.mulLeft x) = fun y => x * y :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_addLeft","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"X : Type u_5\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : Add X\ninstâœ : ContinuousAdd X\nx : X\nâŠ¢ Eq â‡‘(ContinuousMap.addLeft x) fun y => HAdd.hAdd x y","decl":"@[to_additive (attr := simp)]\ntheorem coe_mulLeft (x : X) : â‡‘(ContinuousMap.mulLeft x) = fun y => x * y :=\n  rfl\n\n"}
