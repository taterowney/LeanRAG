{"name":"continuous_one","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace M\ninst✝ : One M\n⊢ Continuous 1","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem continuous_one [TopologicalSpace M] [One M] : Continuous (1 : X → M) :=\n  @continuous_const _ _ _ _ 1\n\n"}
{"name":"continuous_zero","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace M\ninst✝ : Zero M\n⊢ Continuous 0","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem continuous_one [TopologicalSpace M] [One M] : Continuous (1 : X → M) :=\n  @continuous_const _ _ _ _ 1\n\n"}
{"name":"ContinuousAdd.continuous_add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u\ninst✝¹ : TopologicalSpace M\ninst✝ : Add M\nself : ContinuousAdd M\n⊢ Continuous fun p => HAdd.hAdd p.1 p.2","decl":"/-- Basic hypothesis to talk about a topological additive monoid or a topological additive\nsemigroup. A topological additive monoid over `M`, for example, is obtained by requiring both the\ninstances `AddMonoid M` and `ContinuousAdd M`.\n\nContinuity in only the left/right argument can be stated using\n`ContinuousConstVAdd α α`/`ContinuousConstVAdd αᵐᵒᵖ α`. -/\nclass ContinuousAdd (M : Type u) [TopologicalSpace M] [Add M] : Prop where\n  continuous_add : Continuous fun p : M × M => p.1 + p.2\n\n"}
{"name":"ContinuousMul.continuous_mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u\ninst✝¹ : TopologicalSpace M\ninst✝ : Mul M\nself : ContinuousMul M\n⊢ Continuous fun p => HMul.hMul p.1 p.2","decl":"/-- Basic hypothesis to talk about a topological monoid or a topological semigroup.\nA topological monoid over `M`, for example, is obtained by requiring both the instances `Monoid M`\nand `ContinuousMul M`.\n\nContinuity in only the left/right argument can be stated using\n`ContinuousConstSMul α α`/`ContinuousConstSMul αᵐᵒᵖ α`. -/\n@[to_additive]\nclass ContinuousMul (M : Type u) [TopologicalSpace M] [Mul M] : Prop where\n  continuous_mul : Continuous fun p : M × M => p.1 * p.2\n\n"}
{"name":"instContinuousAddOrderDual","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : Add M\n⊢ ContinuousAdd (OrderDual M)","decl":"@[to_additive]\ninstance : ContinuousMul Mᵒᵈ :=\n  ‹ContinuousMul M›\n\n"}
{"name":"instContinuousMulOrderDual","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : Mul M\n⊢ ContinuousMul (OrderDual M)","decl":"@[to_additive]\ninstance : ContinuousMul Mᵒᵈ :=\n  ‹ContinuousMul M›\n\n"}
{"name":"continuous_add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Add M\ninst✝ : ContinuousAdd M\n⊢ Continuous fun p => HAdd.hAdd p.1 p.2","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem continuous_mul : Continuous fun p : M × M => p.1 * p.2 :=\n  ContinuousMul.continuous_mul\n\n"}
{"name":"continuous_mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Mul M\ninst✝ : ContinuousMul M\n⊢ Continuous fun p => HMul.hMul p.1 p.2","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem continuous_mul : Continuous fun p : M × M => p.1 * p.2 :=\n  ContinuousMul.continuous_mul\n\n"}
{"name":"instContinuousAddULift","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : Add M\n⊢ ContinuousAdd (ULift.{u, u_3} M)","decl":"@[to_additive]\ninstance : ContinuousMul (ULift.{u} M) := by\n  constructor\n  apply continuous_uLift_up.comp\n  exact continuous_mul.comp₂ (continuous_uLift_down.comp continuous_fst)\n    (continuous_uLift_down.comp continuous_snd)\n\n"}
{"name":"instContinuousMulULift","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : Mul M\n⊢ ContinuousMul (ULift.{u, u_3} M)","decl":"@[to_additive]\ninstance : ContinuousMul (ULift.{u} M) := by\n  constructor\n  apply continuous_uLift_up.comp\n  exact continuous_mul.comp₂ (continuous_uLift_down.comp continuous_fst)\n    (continuous_uLift_down.comp continuous_snd)\n\n"}
{"name":"ContinuousMul.to_continuousSMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Mul M\ninst✝ : ContinuousMul M\n⊢ ContinuousSMul M M","decl":"@[to_additive]\ninstance ContinuousMul.to_continuousSMul : ContinuousSMul M M :=\n  ⟨continuous_mul⟩\n\n"}
{"name":"ContinuousAdd.to_continuousVAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Add M\ninst✝ : ContinuousAdd M\n⊢ ContinuousVAdd M M","decl":"@[to_additive]\ninstance ContinuousMul.to_continuousSMul : ContinuousSMul M M :=\n  ⟨continuous_mul⟩\n\n"}
{"name":"ContinuousAdd.to_continuousVAdd_op","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Add M\ninst✝ : ContinuousAdd M\n⊢ ContinuousVAdd (AddOpposite M) M","decl":"@[to_additive]\ninstance ContinuousMul.to_continuousSMul_op : ContinuousSMul Mᵐᵒᵖ M :=\n  ⟨show Continuous ((fun p : M × M => p.1 * p.2) ∘ Prod.swap ∘ Prod.map MulOpposite.unop id) from\n      continuous_mul.comp <|\n        continuous_swap.comp <| Continuous.prodMap MulOpposite.continuous_unop continuous_id⟩\n\n"}
{"name":"ContinuousMul.to_continuousSMul_op","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Mul M\ninst✝ : ContinuousMul M\n⊢ ContinuousSMul (MulOpposite M) M","decl":"@[to_additive]\ninstance ContinuousMul.to_continuousSMul_op : ContinuousSMul Mᵐᵒᵖ M :=\n  ⟨show Continuous ((fun p : M × M => p.1 * p.2) ∘ Prod.swap ∘ Prod.map MulOpposite.unop id) from\n      continuous_mul.comp <|\n        continuous_swap.comp <| Continuous.prodMap MulOpposite.continuous_unop continuous_id⟩\n\n"}
{"name":"ContinuousMul.induced","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\nF : Type u_8\ninst✝⁴ : FunLike F α β\ninst✝³ : MulOneClass α\ninst✝² : MulOneClass β\ninst✝¹ : MonoidHomClass F α β\ntβ : TopologicalSpace β\ninst✝ : ContinuousMul β\nf : F\n⊢ ContinuousMul α","decl":"@[to_additive]\ntheorem ContinuousMul.induced {α : Type*} {β : Type*} {F : Type*} [FunLike F α β] [MulOneClass α]\n    [MulOneClass β] [MonoidHomClass F α β] [tβ : TopologicalSpace β] [ContinuousMul β] (f : F) :\n    @ContinuousMul α (tβ.induced f) _ := by\n  let tα := tβ.induced f\n  refine ⟨continuous_induced_rng.2 ?_⟩\n  simp only [Function.comp_def, map_mul]\n  fun_prop\n\n"}
{"name":"ContinuousAdd.induced","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\nF : Type u_8\ninst✝⁴ : FunLike F α β\ninst✝³ : AddZeroClass α\ninst✝² : AddZeroClass β\ninst✝¹ : AddMonoidHomClass F α β\ntβ : TopologicalSpace β\ninst✝ : ContinuousAdd β\nf : F\n⊢ ContinuousAdd α","decl":"@[to_additive]\ntheorem ContinuousMul.induced {α : Type*} {β : Type*} {F : Type*} [FunLike F α β] [MulOneClass α]\n    [MulOneClass β] [MonoidHomClass F α β] [tβ : TopologicalSpace β] [ContinuousMul β] (f : F) :\n    @ContinuousMul α (tβ.induced f) _ := by\n  let tα := tβ.induced f\n  refine ⟨continuous_induced_rng.2 ?_⟩\n  simp only [Function.comp_def, map_mul]\n  fun_prop\n\n"}
{"name":"Continuous.mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : Mul M\ninst✝ : ContinuousMul M\nf g : X → M\nhf : Continuous f\nhg : Continuous g\n⊢ Continuous fun x => HMul.hMul (f x) (g x)","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem Continuous.mul {f g : X → M} (hf : Continuous f) (hg : Continuous g) :\n    Continuous fun x => f x * g x :=\n  continuous_mul.comp (hf.prod_mk hg :)\n\n"}
{"name":"Continuous.add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : Add M\ninst✝ : ContinuousAdd M\nf g : X → M\nhf : Continuous f\nhg : Continuous g\n⊢ Continuous fun x => HAdd.hAdd (f x) (g x)","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem Continuous.mul {f g : X → M} (hf : Continuous f) (hg : Continuous g) :\n    Continuous fun x => f x * g x :=\n  continuous_mul.comp (hf.prod_mk hg :)\n\n"}
{"name":"continuous_mul_left","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Mul M\ninst✝ : ContinuousMul M\na : M\n⊢ Continuous fun b => HMul.hMul a b","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_mul_left (a : M) : Continuous fun b : M => a * b :=\n  continuous_const.mul continuous_id\n\n"}
{"name":"continuous_add_left","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Add M\ninst✝ : ContinuousAdd M\na : M\n⊢ Continuous fun b => HAdd.hAdd a b","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_mul_left (a : M) : Continuous fun b : M => a * b :=\n  continuous_const.mul continuous_id\n\n"}
{"name":"continuous_add_right","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Add M\ninst✝ : ContinuousAdd M\na : M\n⊢ Continuous fun b => HAdd.hAdd b a","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_mul_right (a : M) : Continuous fun b : M => b * a :=\n  continuous_id.mul continuous_const\n\n"}
{"name":"continuous_mul_right","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Mul M\ninst✝ : ContinuousMul M\na : M\n⊢ Continuous fun b => HMul.hMul b a","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_mul_right (a : M) : Continuous fun b : M => b * a :=\n  continuous_id.mul continuous_const\n\n"}
{"name":"ContinuousOn.add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : Add M\ninst✝ : ContinuousAdd M\nf g : X → M\ns : Set X\nhf : ContinuousOn f s\nhg : ContinuousOn g s\n⊢ ContinuousOn (fun x => HAdd.hAdd (f x) (g x)) s","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousOn.mul {f g : X → M} {s : Set X} (hf : ContinuousOn f s) (hg : ContinuousOn g s) :\n    ContinuousOn (fun x => f x * g x) s :=\n  (continuous_mul.comp_continuousOn (hf.prod hg) :)\n\n"}
{"name":"ContinuousOn.mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : Mul M\ninst✝ : ContinuousMul M\nf g : X → M\ns : Set X\nhf : ContinuousOn f s\nhg : ContinuousOn g s\n⊢ ContinuousOn (fun x => HMul.hMul (f x) (g x)) s","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousOn.mul {f g : X → M} {s : Set X} (hf : ContinuousOn f s) (hg : ContinuousOn g s) :\n    ContinuousOn (fun x => f x * g x) s :=\n  (continuous_mul.comp_continuousOn (hf.prod hg) :)\n\n"}
{"name":"tendsto_mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Mul M\ninst✝ : ContinuousMul M\na b : M\n⊢ Filter.Tendsto (fun p => HMul.hMul p.1 p.2) (nhds { fst := a, snd := b }) (nhds (HMul.hMul a b))","decl":"@[to_additive]\ntheorem tendsto_mul {a b : M} : Tendsto (fun p : M × M => p.fst * p.snd) (𝓝 (a, b)) (𝓝 (a * b)) :=\n  continuous_iff_continuousAt.mp ContinuousMul.continuous_mul (a, b)\n\n"}
{"name":"tendsto_add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Add M\ninst✝ : ContinuousAdd M\na b : M\n⊢ Filter.Tendsto (fun p => HAdd.hAdd p.1 p.2) (nhds { fst := a, snd := b }) (nhds (HAdd.hAdd a b))","decl":"@[to_additive]\ntheorem tendsto_mul {a b : M} : Tendsto (fun p : M × M => p.fst * p.snd) (𝓝 (a, b)) (𝓝 (a * b)) :=\n  continuous_iff_continuousAt.mp ContinuousMul.continuous_mul (a, b)\n\n"}
{"name":"Filter.Tendsto.add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Add M\ninst✝ : ContinuousAdd M\nf g : α → M\nx : Filter α\na b : M\nhf : Filter.Tendsto f x (nhds a)\nhg : Filter.Tendsto g x (nhds b)\n⊢ Filter.Tendsto (fun x => HAdd.hAdd (f x) (g x)) x (nhds (HAdd.hAdd a b))","decl":"@[to_additive]\ntheorem Filter.Tendsto.mul {f g : α → M} {x : Filter α} {a b : M} (hf : Tendsto f x (𝓝 a))\n    (hg : Tendsto g x (𝓝 b)) : Tendsto (fun x => f x * g x) x (𝓝 (a * b)) :=\n  tendsto_mul.comp (hf.prod_mk_nhds hg)\n\n"}
{"name":"Filter.Tendsto.mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Mul M\ninst✝ : ContinuousMul M\nf g : α → M\nx : Filter α\na b : M\nhf : Filter.Tendsto f x (nhds a)\nhg : Filter.Tendsto g x (nhds b)\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) x (nhds (HMul.hMul a b))","decl":"@[to_additive]\ntheorem Filter.Tendsto.mul {f g : α → M} {x : Filter α} {a b : M} (hf : Tendsto f x (𝓝 a))\n    (hg : Tendsto g x (𝓝 b)) : Tendsto (fun x => f x * g x) x (𝓝 (a * b)) :=\n  tendsto_mul.comp (hf.prod_mk_nhds hg)\n\n"}
{"name":"Filter.Tendsto.const_mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Mul M\ninst✝ : ContinuousMul M\nb c : M\nf : α → M\nl : Filter α\nh : Filter.Tendsto (fun k => f k) l (nhds c)\n⊢ Filter.Tendsto (fun k => HMul.hMul b (f k)) l (nhds (HMul.hMul b c))","decl":"@[to_additive]\ntheorem Filter.Tendsto.const_mul (b : M) {c : M} {f : α → M} {l : Filter α}\n    (h : Tendsto (fun k : α => f k) l (𝓝 c)) : Tendsto (fun k : α => b * f k) l (𝓝 (b * c)) :=\n  tendsto_const_nhds.mul h\n\n"}
{"name":"Filter.Tendsto.const_add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Add M\ninst✝ : ContinuousAdd M\nb c : M\nf : α → M\nl : Filter α\nh : Filter.Tendsto (fun k => f k) l (nhds c)\n⊢ Filter.Tendsto (fun k => HAdd.hAdd b (f k)) l (nhds (HAdd.hAdd b c))","decl":"@[to_additive]\ntheorem Filter.Tendsto.const_mul (b : M) {c : M} {f : α → M} {l : Filter α}\n    (h : Tendsto (fun k : α => f k) l (𝓝 c)) : Tendsto (fun k : α => b * f k) l (𝓝 (b * c)) :=\n  tendsto_const_nhds.mul h\n\n"}
{"name":"Filter.Tendsto.mul_const","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Mul M\ninst✝ : ContinuousMul M\nb c : M\nf : α → M\nl : Filter α\nh : Filter.Tendsto (fun k => f k) l (nhds c)\n⊢ Filter.Tendsto (fun k => HMul.hMul (f k) b) l (nhds (HMul.hMul c b))","decl":"@[to_additive]\ntheorem Filter.Tendsto.mul_const (b : M) {c : M} {f : α → M} {l : Filter α}\n    (h : Tendsto (fun k : α => f k) l (𝓝 c)) : Tendsto (fun k : α => f k * b) l (𝓝 (c * b)) :=\n  h.mul tendsto_const_nhds\n\n"}
{"name":"Filter.Tendsto.add_const","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Add M\ninst✝ : ContinuousAdd M\nb c : M\nf : α → M\nl : Filter α\nh : Filter.Tendsto (fun k => f k) l (nhds c)\n⊢ Filter.Tendsto (fun k => HAdd.hAdd (f k) b) l (nhds (HAdd.hAdd c b))","decl":"@[to_additive]\ntheorem Filter.Tendsto.mul_const (b : M) {c : M} {f : α → M} {l : Filter α}\n    (h : Tendsto (fun k : α => f k) l (𝓝 c)) : Tendsto (fun k : α => f k * b) l (𝓝 (c * b)) :=\n  h.mul tendsto_const_nhds\n\n"}
{"name":"le_nhds_add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Add M\ninst✝ : ContinuousAdd M\na b : M\n⊢ LE.le (HAdd.hAdd (nhds a) (nhds b)) (nhds (HAdd.hAdd a b))","decl":"@[to_additive]\ntheorem le_nhds_mul (a b : M) : 𝓝 a * 𝓝 b ≤ 𝓝 (a * b) := by\n  rw [← map₂_mul, ← map_uncurry_prod, ← nhds_prod_eq]\n  exact continuous_mul.tendsto _\n\n"}
{"name":"le_nhds_mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Mul M\ninst✝ : ContinuousMul M\na b : M\n⊢ LE.le (HMul.hMul (nhds a) (nhds b)) (nhds (HMul.hMul a b))","decl":"@[to_additive]\ntheorem le_nhds_mul (a b : M) : 𝓝 a * 𝓝 b ≤ 𝓝 (a * b) := by\n  rw [← map₂_mul, ← map_uncurry_prod, ← nhds_prod_eq]\n  exact continuous_mul.tendsto _\n\n"}
{"name":"nhds_zero_add_nhds","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\ninst✝² : AddZeroClass M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\na : M\n⊢ Eq (HAdd.hAdd (nhds 0) (nhds a)) (nhds a)","decl":"@[to_additive (attr := simp)]\ntheorem nhds_one_mul_nhds {M} [MulOneClass M] [TopologicalSpace M] [ContinuousMul M] (a : M) :\n    𝓝 (1 : M) * 𝓝 a = 𝓝 a :=\n  ((le_nhds_mul _ _).trans_eq <| congr_arg _ (one_mul a)).antisymm <|\n    le_mul_of_one_le_left' <| pure_le_nhds 1\n\n"}
{"name":"nhds_one_mul_nhds","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\ninst✝² : MulOneClass M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousMul M\na : M\n⊢ Eq (HMul.hMul (nhds 1) (nhds a)) (nhds a)","decl":"@[to_additive (attr := simp)]\ntheorem nhds_one_mul_nhds {M} [MulOneClass M] [TopologicalSpace M] [ContinuousMul M] (a : M) :\n    𝓝 (1 : M) * 𝓝 a = 𝓝 a :=\n  ((le_nhds_mul _ _).trans_eq <| congr_arg _ (one_mul a)).antisymm <|\n    le_mul_of_one_le_left' <| pure_le_nhds 1\n\n"}
{"name":"nhds_add_nhds_zero","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\ninst✝² : AddZeroClass M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\na : M\n⊢ Eq (HAdd.hAdd (nhds a) (nhds 0)) (nhds a)","decl":"@[to_additive (attr := simp)]\ntheorem nhds_mul_nhds_one {M} [MulOneClass M] [TopologicalSpace M] [ContinuousMul M] (a : M) :\n    𝓝 a * 𝓝 1 = 𝓝 a :=\n  ((le_nhds_mul _ _).trans_eq <| congr_arg _ (mul_one a)).antisymm <|\n    le_mul_of_one_le_right' <| pure_le_nhds 1\n\n"}
{"name":"nhds_mul_nhds_one","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\ninst✝² : MulOneClass M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousMul M\na : M\n⊢ Eq (HMul.hMul (nhds a) (nhds 1)) (nhds a)","decl":"@[to_additive (attr := simp)]\ntheorem nhds_mul_nhds_one {M} [MulOneClass M] [TopologicalSpace M] [ContinuousMul M] (a : M) :\n    𝓝 a * 𝓝 1 = 𝓝 a :=\n  ((le_nhds_mul _ _).trans_eq <| congr_arg _ (mul_one a)).antisymm <|\n    le_mul_of_one_le_right' <| pure_le_nhds 1\n\n"}
{"name":"Filter.TendstoNhdsWithinIoi.const_mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_2\n𝕜 : Type u_6\ninst✝⁶ : Preorder 𝕜\ninst✝⁵ : Zero 𝕜\ninst✝⁴ : Mul 𝕜\ninst✝³ : TopologicalSpace 𝕜\ninst✝² : ContinuousMul 𝕜\nl : Filter α\nf : α → 𝕜\nb c : 𝕜\nhb : LT.lt 0 b\ninst✝¹ : PosMulStrictMono 𝕜\ninst✝ : PosMulReflectLT 𝕜\nh : Filter.Tendsto f l (nhdsWithin c (Set.Ioi c))\n⊢ Filter.Tendsto (fun a => HMul.hMul b (f a)) l (nhdsWithin (HMul.hMul b c) (Set.Ioi (HMul.hMul b c)))","decl":"theorem Filter.TendstoNhdsWithinIoi.const_mul [PosMulStrictMono 𝕜] [PosMulReflectLT 𝕜]\n    (h : Tendsto f l (𝓝[>] c)) : Tendsto (fun a => b * f a) l (𝓝[>] (b * c)) :=\n  tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _\n      ((tendsto_nhds_of_tendsto_nhdsWithin h).const_mul b) <|\n    (tendsto_nhdsWithin_iff.mp h).2.mono fun _ => (mul_lt_mul_left hb).mpr\n\n"}
{"name":"Filter.TendstoNhdsWithinIio.const_mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_2\n𝕜 : Type u_6\ninst✝⁶ : Preorder 𝕜\ninst✝⁵ : Zero 𝕜\ninst✝⁴ : Mul 𝕜\ninst✝³ : TopologicalSpace 𝕜\ninst✝² : ContinuousMul 𝕜\nl : Filter α\nf : α → 𝕜\nb c : 𝕜\nhb : LT.lt 0 b\ninst✝¹ : PosMulStrictMono 𝕜\ninst✝ : PosMulReflectLT 𝕜\nh : Filter.Tendsto f l (nhdsWithin c (Set.Iio c))\n⊢ Filter.Tendsto (fun a => HMul.hMul b (f a)) l (nhdsWithin (HMul.hMul b c) (Set.Iio (HMul.hMul b c)))","decl":"theorem Filter.TendstoNhdsWithinIio.const_mul [PosMulStrictMono 𝕜] [PosMulReflectLT 𝕜]\n    (h : Tendsto f l (𝓝[<] c)) : Tendsto (fun a => b * f a) l (𝓝[<] (b * c)) :=\n  tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _\n      ((tendsto_nhds_of_tendsto_nhdsWithin h).const_mul b) <|\n    (tendsto_nhdsWithin_iff.mp h).2.mono fun _ => (mul_lt_mul_left hb).mpr\n\n"}
{"name":"Filter.TendstoNhdsWithinIoi.mul_const","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_2\n𝕜 : Type u_6\ninst✝⁶ : Preorder 𝕜\ninst✝⁵ : Zero 𝕜\ninst✝⁴ : Mul 𝕜\ninst✝³ : TopologicalSpace 𝕜\ninst✝² : ContinuousMul 𝕜\nl : Filter α\nf : α → 𝕜\nb c : 𝕜\nhb : LT.lt 0 b\ninst✝¹ : MulPosStrictMono 𝕜\ninst✝ : MulPosReflectLT 𝕜\nh : Filter.Tendsto f l (nhdsWithin c (Set.Ioi c))\n⊢ Filter.Tendsto (fun a => HMul.hMul (f a) b) l (nhdsWithin (HMul.hMul c b) (Set.Ioi (HMul.hMul c b)))","decl":"theorem Filter.TendstoNhdsWithinIoi.mul_const [MulPosStrictMono 𝕜] [MulPosReflectLT 𝕜]\n    (h : Tendsto f l (𝓝[>] c)) : Tendsto (fun a => f a * b) l (𝓝[>] (c * b)) :=\n  tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _\n      ((tendsto_nhds_of_tendsto_nhdsWithin h).mul_const b) <|\n    (tendsto_nhdsWithin_iff.mp h).2.mono fun _ => (mul_lt_mul_right hb).mpr\n\n"}
{"name":"Filter.TendstoNhdsWithinIio.mul_const","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_2\n𝕜 : Type u_6\ninst✝⁶ : Preorder 𝕜\ninst✝⁵ : Zero 𝕜\ninst✝⁴ : Mul 𝕜\ninst✝³ : TopologicalSpace 𝕜\ninst✝² : ContinuousMul 𝕜\nl : Filter α\nf : α → 𝕜\nb c : 𝕜\nhb : LT.lt 0 b\ninst✝¹ : MulPosStrictMono 𝕜\ninst✝ : MulPosReflectLT 𝕜\nh : Filter.Tendsto f l (nhdsWithin c (Set.Iio c))\n⊢ Filter.Tendsto (fun a => HMul.hMul (f a) b) l (nhdsWithin (HMul.hMul c b) (Set.Iio (HMul.hMul c b)))","decl":"theorem Filter.TendstoNhdsWithinIio.mul_const [MulPosStrictMono 𝕜] [MulPosReflectLT 𝕜]\n    (h : Tendsto f l (𝓝[<] c)) : Tendsto (fun a => f a * b) l (𝓝[<] (c * b)) :=\n  tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _\n      ((tendsto_nhds_of_tendsto_nhdsWithin h).mul_const b) <|\n    (tendsto_nhdsWithin_iff.mp h).2.mono fun _ => (mul_lt_mul_right hb).mpr\n\n"}
{"name":"Specializes.add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Add M\ninst✝ : ContinuousAdd M\na b c d : M\nhab : Specializes a b\nhcd : Specializes c d\n⊢ Specializes (HAdd.hAdd a c) (HAdd.hAdd b d)","decl":"@[to_additive]\nprotected theorem Specializes.mul {a b c d : M} (hab : a ⤳ b) (hcd : c ⤳ d) : (a * c) ⤳ (b * d) :=\n  hab.smul hcd\n\n"}
{"name":"Specializes.mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Mul M\ninst✝ : ContinuousMul M\na b c d : M\nhab : Specializes a b\nhcd : Specializes c d\n⊢ Specializes (HMul.hMul a c) (HMul.hMul b d)","decl":"@[to_additive]\nprotected theorem Specializes.mul {a b c d : M} (hab : a ⤳ b) (hcd : c ⤳ d) : (a * c) ⤳ (b * d) :=\n  hab.smul hcd\n\n"}
{"name":"Inseparable.mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Mul M\ninst✝ : ContinuousMul M\na b c d : M\nhab : Inseparable a b\nhcd : Inseparable c d\n⊢ Inseparable (HMul.hMul a c) (HMul.hMul b d)","decl":"@[to_additive]\nprotected theorem Inseparable.mul {a b c d : M} (hab : Inseparable a b) (hcd : Inseparable c d) :\n    Inseparable (a * c) (b * d) :=\n  hab.smul hcd\n\n"}
{"name":"Inseparable.add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Add M\ninst✝ : ContinuousAdd M\na b c d : M\nhab : Inseparable a b\nhcd : Inseparable c d\n⊢ Inseparable (HAdd.hAdd a c) (HAdd.hAdd b d)","decl":"@[to_additive]\nprotected theorem Inseparable.mul {a b c d : M} (hab : Inseparable a b) (hcd : Inseparable c d) :\n    Inseparable (a * c) (b * d) :=\n  hab.smul hcd\n\n"}
{"name":"Specializes.nsmul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\ninst✝² : AddMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\na b : M\nh : Specializes a b\nn : Nat\n⊢ Specializes (HSMul.hSMul n a) (HSMul.hSMul n b)","decl":"@[to_additive]\nprotected theorem Specializes.pow {M : Type*} [Monoid M] [TopologicalSpace M] [ContinuousMul M]\n    {a b : M} (h : a ⤳ b) (n : ℕ) : (a ^ n) ⤳ (b ^ n) :=\n  Nat.recOn n (by simp only [pow_zero, specializes_rfl]) fun _ ihn ↦ by\n    simpa only [pow_succ] using ihn.mul h\n\n"}
{"name":"Specializes.pow","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\ninst✝² : Monoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousMul M\na b : M\nh : Specializes a b\nn : Nat\n⊢ Specializes (HPow.hPow a n) (HPow.hPow b n)","decl":"@[to_additive]\nprotected theorem Specializes.pow {M : Type*} [Monoid M] [TopologicalSpace M] [ContinuousMul M]\n    {a b : M} (h : a ⤳ b) (n : ℕ) : (a ^ n) ⤳ (b ^ n) :=\n  Nat.recOn n (by simp only [pow_zero, specializes_rfl]) fun _ ihn ↦ by\n    simpa only [pow_succ] using ihn.mul h\n\n"}
{"name":"Inseparable.pow","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\ninst✝² : Monoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousMul M\na b : M\nh : Inseparable a b\nn : Nat\n⊢ Inseparable (HPow.hPow a n) (HPow.hPow b n)","decl":"@[to_additive]\nprotected theorem Inseparable.pow {M : Type*} [Monoid M] [TopologicalSpace M] [ContinuousMul M]\n    {a b : M} (h : Inseparable a b) (n : ℕ) : Inseparable (a ^ n) (b ^ n) :=\n  (h.specializes.pow n).antisymm (h.specializes'.pow n)\n\n"}
{"name":"Inseparable.nsmul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\ninst✝² : AddMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\na b : M\nh : Inseparable a b\nn : Nat\n⊢ Inseparable (HSMul.hSMul n a) (HSMul.hSMul n b)","decl":"@[to_additive]\nprotected theorem Inseparable.pow {M : Type*} [Monoid M] [TopologicalSpace M] [ContinuousMul M]\n    {a b : M} (h : Inseparable a b) (n : ℕ) : Inseparable (a ^ n) (b ^ n) :=\n  (h.specializes.pow n).antisymm (h.specializes'.pow n)\n\n"}
{"name":"Filter.Tendsto.val_units","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nN : Type u_4\ninst✝⁴ : TopologicalSpace N\ninst✝³ : Monoid N\ninst✝² : ContinuousMul N\ninst✝¹ : T2Space N\nf : ι → Units N\nr₁ r₂ : N\nl : Filter ι\ninst✝ : l.NeBot\nh₁ : Filter.Tendsto (fun x => ↑(f x)) l (nhds r₁)\nh₂ : Filter.Tendsto (fun x => ↑(Inv.inv (f x))) l (nhds r₂)\n⊢ Eq (↑(h₁.units h₂)) r₁","decl":"/-- Construct a unit from limits of units and their inverses. -/\n@[to_additive (attr := simps)\n  \"Construct an additive unit from limits of additive units and their negatives.\"]\ndef Filter.Tendsto.units [TopologicalSpace N] [Monoid N] [ContinuousMul N] [T2Space N]\n    {f : ι → Nˣ} {r₁ r₂ : N} {l : Filter ι} [l.NeBot] (h₁ : Tendsto (fun x => ↑(f x)) l (𝓝 r₁))\n    (h₂ : Tendsto (fun x => ↑(f x)⁻¹) l (𝓝 r₂)) : Nˣ where\n  val := r₁\n  inv := r₂\n  val_inv := by\n    symm\n    simpa using h₁.mul h₂\n  inv_val := by\n    symm\n    simpa using h₂.mul h₁\n\n"}
{"name":"Filter.Tendsto.val_inv_units","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nN : Type u_4\ninst✝⁴ : TopologicalSpace N\ninst✝³ : Monoid N\ninst✝² : ContinuousMul N\ninst✝¹ : T2Space N\nf : ι → Units N\nr₁ r₂ : N\nl : Filter ι\ninst✝ : l.NeBot\nh₁ : Filter.Tendsto (fun x => ↑(f x)) l (nhds r₁)\nh₂ : Filter.Tendsto (fun x => ↑(Inv.inv (f x))) l (nhds r₂)\n⊢ Eq (↑(Inv.inv (h₁.units h₂))) r₂","decl":"/-- Construct a unit from limits of units and their inverses. -/\n@[to_additive (attr := simps)\n  \"Construct an additive unit from limits of additive units and their negatives.\"]\ndef Filter.Tendsto.units [TopologicalSpace N] [Monoid N] [ContinuousMul N] [T2Space N]\n    {f : ι → Nˣ} {r₁ r₂ : N} {l : Filter ι} [l.NeBot] (h₁ : Tendsto (fun x => ↑(f x)) l (𝓝 r₁))\n    (h₂ : Tendsto (fun x => ↑(f x)⁻¹) l (𝓝 r₂)) : Nˣ where\n  val := r₁\n  inv := r₂\n  val_inv := by\n    symm\n    simpa using h₁.mul h₂\n  inv_val := by\n    symm\n    simpa using h₂.mul h₁\n\n"}
{"name":"Filter.Tendsto.val_neg_addUnits","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nN : Type u_4\ninst✝⁴ : TopologicalSpace N\ninst✝³ : AddMonoid N\ninst✝² : ContinuousAdd N\ninst✝¹ : T2Space N\nf : ι → AddUnits N\nr₁ r₂ : N\nl : Filter ι\ninst✝ : l.NeBot\nh₁ : Filter.Tendsto (fun x => ↑(f x)) l (nhds r₁)\nh₂ : Filter.Tendsto (fun x => ↑(Neg.neg (f x))) l (nhds r₂)\n⊢ Eq (↑(Neg.neg (h₁.addUnits h₂))) r₂","decl":"/-- Construct a unit from limits of units and their inverses. -/\n@[to_additive (attr := simps)\n  \"Construct an additive unit from limits of additive units and their negatives.\"]\ndef Filter.Tendsto.units [TopologicalSpace N] [Monoid N] [ContinuousMul N] [T2Space N]\n    {f : ι → Nˣ} {r₁ r₂ : N} {l : Filter ι} [l.NeBot] (h₁ : Tendsto (fun x => ↑(f x)) l (𝓝 r₁))\n    (h₂ : Tendsto (fun x => ↑(f x)⁻¹) l (𝓝 r₂)) : Nˣ where\n  val := r₁\n  inv := r₂\n  val_inv := by\n    symm\n    simpa using h₁.mul h₂\n  inv_val := by\n    symm\n    simpa using h₂.mul h₁\n\n"}
{"name":"Filter.Tendsto.val_addUnits","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nN : Type u_4\ninst✝⁴ : TopologicalSpace N\ninst✝³ : AddMonoid N\ninst✝² : ContinuousAdd N\ninst✝¹ : T2Space N\nf : ι → AddUnits N\nr₁ r₂ : N\nl : Filter ι\ninst✝ : l.NeBot\nh₁ : Filter.Tendsto (fun x => ↑(f x)) l (nhds r₁)\nh₂ : Filter.Tendsto (fun x => ↑(Neg.neg (f x))) l (nhds r₂)\n⊢ Eq (↑(h₁.addUnits h₂)) r₁","decl":"/-- Construct a unit from limits of units and their inverses. -/\n@[to_additive (attr := simps)\n  \"Construct an additive unit from limits of additive units and their negatives.\"]\ndef Filter.Tendsto.units [TopologicalSpace N] [Monoid N] [ContinuousMul N] [T2Space N]\n    {f : ι → Nˣ} {r₁ r₂ : N} {l : Filter ι} [l.NeBot] (h₁ : Tendsto (fun x => ↑(f x)) l (𝓝 r₁))\n    (h₂ : Tendsto (fun x => ↑(f x)⁻¹) l (𝓝 r₂)) : Nˣ where\n  val := r₁\n  inv := r₂\n  val_inv := by\n    symm\n    simpa using h₁.mul h₂\n  inv_val := by\n    symm\n    simpa using h₂.mul h₁\n\n"}
{"name":"ContinuousAt.mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : Mul M\ninst✝ : ContinuousMul M\nf g : X → M\nx : X\nhf : ContinuousAt f x\nhg : ContinuousAt g x\n⊢ ContinuousAt (fun x => HMul.hMul (f x) (g x)) x","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousAt.mul {f g : X → M} {x : X} (hf : ContinuousAt f x) (hg : ContinuousAt g x) :\n    ContinuousAt (fun x => f x * g x) x :=\n  Filter.Tendsto.mul hf hg\n\n"}
{"name":"ContinuousAt.add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : Add M\ninst✝ : ContinuousAdd M\nf g : X → M\nx : X\nhf : ContinuousAt f x\nhg : ContinuousAt g x\n⊢ ContinuousAt (fun x => HAdd.hAdd (f x) (g x)) x","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousAt.mul {f g : X → M} {x : X} (hf : ContinuousAt f x) (hg : ContinuousAt g x) :\n    ContinuousAt (fun x => f x * g x) x :=\n  Filter.Tendsto.mul hf hg\n\n"}
{"name":"ContinuousWithinAt.mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : Mul M\ninst✝ : ContinuousMul M\nf g : X → M\ns : Set X\nx : X\nhf : ContinuousWithinAt f s x\nhg : ContinuousWithinAt g s x\n⊢ ContinuousWithinAt (fun x => HMul.hMul (f x) (g x)) s x","decl":"@[to_additive]\ntheorem ContinuousWithinAt.mul {f g : X → M} {s : Set X} {x : X} (hf : ContinuousWithinAt f s x)\n    (hg : ContinuousWithinAt g s x) : ContinuousWithinAt (fun x => f x * g x) s x :=\n  Filter.Tendsto.mul hf hg\n\n"}
{"name":"ContinuousWithinAt.add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : Add M\ninst✝ : ContinuousAdd M\nf g : X → M\ns : Set X\nx : X\nhf : ContinuousWithinAt f s x\nhg : ContinuousWithinAt g s x\n⊢ ContinuousWithinAt (fun x => HAdd.hAdd (f x) (g x)) s x","decl":"@[to_additive]\ntheorem ContinuousWithinAt.mul {f g : X → M} {s : Set X} {x : X} (hf : ContinuousWithinAt f s x)\n    (hg : ContinuousWithinAt g s x) : ContinuousWithinAt (fun x => f x * g x) s x :=\n  Filter.Tendsto.mul hf hg\n\n"}
{"name":"Prod.continuousAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : Add M\ninst✝³ : ContinuousAdd M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add N\ninst✝ : ContinuousAdd N\n⊢ ContinuousAdd (Prod M N)","decl":"@[to_additive]\ninstance Prod.continuousMul [TopologicalSpace N] [Mul N] [ContinuousMul N] :\n    ContinuousMul (M × N) :=\n  ⟨(continuous_fst.fst'.mul continuous_fst.snd').prod_mk\n      (continuous_snd.fst'.mul continuous_snd.snd')⟩\n\n"}
{"name":"Prod.continuousMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : Mul M\ninst✝³ : ContinuousMul M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul N\ninst✝ : ContinuousMul N\n⊢ ContinuousMul (Prod M N)","decl":"@[to_additive]\ninstance Prod.continuousMul [TopologicalSpace N] [Mul N] [ContinuousMul N] :\n    ContinuousMul (M × N) :=\n  ⟨(continuous_fst.fst'.mul continuous_fst.snd').prod_mk\n      (continuous_snd.fst'.mul continuous_snd.snd')⟩\n\n"}
{"name":"Pi.continuousMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nC : ι → Type u_6\ninst✝² : (i : ι) → TopologicalSpace (C i)\ninst✝¹ : (i : ι) → Mul (C i)\ninst✝ : ∀ (i : ι), ContinuousMul (C i)\n⊢ ContinuousMul ((i : ι) → C i)","decl":"@[to_additive]\ninstance Pi.continuousMul {C : ι → Type*} [∀ i, TopologicalSpace (C i)] [∀ i, Mul (C i)]\n    [∀ i, ContinuousMul (C i)] : ContinuousMul (∀ i, C i) where\n  continuous_mul :=\n    continuous_pi fun i => (continuous_apply i).fst'.mul (continuous_apply i).snd'\n\n"}
{"name":"Pi.continuousAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nC : ι → Type u_6\ninst✝² : (i : ι) → TopologicalSpace (C i)\ninst✝¹ : (i : ι) → Add (C i)\ninst✝ : ∀ (i : ι), ContinuousAdd (C i)\n⊢ ContinuousAdd ((i : ι) → C i)","decl":"@[to_additive]\ninstance Pi.continuousMul {C : ι → Type*} [∀ i, TopologicalSpace (C i)] [∀ i, Mul (C i)]\n    [∀ i, ContinuousMul (C i)] : ContinuousMul (∀ i, C i) where\n  continuous_mul :=\n    continuous_pi fun i => (continuous_apply i).fst'.mul (continuous_apply i).snd'\n\n"}
{"name":"Pi.continuousAdd'","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Add M\ninst✝ : ContinuousAdd M\n⊢ ContinuousAdd (ι → M)","decl":"/-- A version of `Pi.continuousMul` for non-dependent functions. It is needed because sometimes\nLean 3 fails to use `Pi.continuousMul` for non-dependent functions. -/\n@[to_additive \"A version of `Pi.continuousAdd` for non-dependent functions. It is needed\nbecause sometimes Lean fails to use `Pi.continuousAdd` for non-dependent functions.\"]\ninstance Pi.continuousMul' : ContinuousMul (ι → M) :=\n  Pi.continuousMul\n\n"}
{"name":"Pi.continuousMul'","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Mul M\ninst✝ : ContinuousMul M\n⊢ ContinuousMul (ι → M)","decl":"/-- A version of `Pi.continuousMul` for non-dependent functions. It is needed because sometimes\nLean 3 fails to use `Pi.continuousMul` for non-dependent functions. -/\n@[to_additive \"A version of `Pi.continuousAdd` for non-dependent functions. It is needed\nbecause sometimes Lean fails to use `Pi.continuousAdd` for non-dependent functions.\"]\ninstance Pi.continuousMul' : ContinuousMul (ι → M) :=\n  Pi.continuousMul\n\n"}
{"name":"continuousMul_of_discreteTopology","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"N : Type u_4\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul N\ninst✝ : DiscreteTopology N\n⊢ ContinuousMul N","decl":"@[to_additive]\ninstance (priority := 100) continuousMul_of_discreteTopology [TopologicalSpace N] [Mul N]\n    [DiscreteTopology N] : ContinuousMul N :=\n  ⟨continuous_of_discreteTopology⟩\n\n"}
{"name":"continuousAdd_of_discreteTopology","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"N : Type u_4\ninst✝² : TopologicalSpace N\ninst✝¹ : Add N\ninst✝ : DiscreteTopology N\n⊢ ContinuousAdd N","decl":"@[to_additive]\ninstance (priority := 100) continuousMul_of_discreteTopology [TopologicalSpace N] [Mul N]\n    [DiscreteTopology N] : ContinuousMul N :=\n  ⟨continuous_of_discreteTopology⟩\n\n"}
{"name":"ContinuousMul.of_nhds_one","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u\ninst✝¹ : Monoid M\ninst✝ : TopologicalSpace M\nhmul : Filter.Tendsto (Function.uncurry fun x1 x2 => HMul.hMul x1 x2) (SProd.sprod (nhds 1) (nhds 1)) (nhds 1)\nhleft : ∀ (x₀ : M), Eq (nhds x₀) (Filter.map (fun x => HMul.hMul x₀ x) (nhds 1))\nhright : ∀ (x₀ : M), Eq (nhds x₀) (Filter.map (fun x => HMul.hMul x x₀) (nhds 1))\n⊢ ContinuousMul M","decl":"@[to_additive]\ntheorem ContinuousMul.of_nhds_one {M : Type u} [Monoid M] [TopologicalSpace M]\n    (hmul : Tendsto (uncurry ((· * ·) : M → M → M)) (𝓝 1 ×ˢ 𝓝 1) <| 𝓝 1)\n    (hleft : ∀ x₀ : M, 𝓝 x₀ = map (fun x => x₀ * x) (𝓝 1))\n    (hright : ∀ x₀ : M, 𝓝 x₀ = map (fun x => x * x₀) (𝓝 1)) : ContinuousMul M :=\n  ⟨by\n    rw [continuous_iff_continuousAt]\n    rintro ⟨x₀, y₀⟩\n    have key : (fun p : M × M => x₀ * p.1 * (p.2 * y₀)) =\n        ((fun x => x₀ * x) ∘ fun x => x * y₀) ∘ uncurry (· * ·) := by\n      ext p\n      simp [uncurry, mul_assoc]\n    have key₂ : ((fun x => x₀ * x) ∘ fun x => y₀ * x) = fun x => x₀ * y₀ * x := by\n      ext x\n      simp [mul_assoc]\n    calc\n      map (uncurry (· * ·)) (𝓝 (x₀, y₀)) = map (uncurry (· * ·)) (𝓝 x₀ ×ˢ 𝓝 y₀) := by\n        rw [nhds_prod_eq]\n      _ = map (fun p : M × M => x₀ * p.1 * (p.2 * y₀)) (𝓝 1 ×ˢ 𝓝 1) := by\n        -- Porting note: `rw` was able to prove this\n        -- Now it fails with `failed to rewrite using equation theorems for 'Function.uncurry'`\n        -- and `failed to rewrite using equation theorems for 'Function.comp'`.\n        -- Removing those two lemmas, the `rw` would succeed, but then needs a `rfl`.\n        simp (config := { unfoldPartialApp := true }) only [uncurry]\n        simp_rw [hleft x₀, hright y₀, prod_map_map_eq, Filter.map_map, Function.comp_def]\n      _ = map ((fun x => x₀ * x) ∘ fun x => x * y₀) (map (uncurry (· * ·)) (𝓝 1 ×ˢ 𝓝 1)) := by\n        rw [key, ← Filter.map_map]\n      _ ≤ map ((fun x : M => x₀ * x) ∘ fun x => x * y₀) (𝓝 1) := map_mono hmul\n      _ = 𝓝 (x₀ * y₀) := by\n        rw [← Filter.map_map, ← hright, hleft y₀, Filter.map_map, key₂, ← hleft]⟩\n\n"}
{"name":"ContinuousAdd.of_nhds_zero","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u\ninst✝¹ : AddMonoid M\ninst✝ : TopologicalSpace M\nhmul : Filter.Tendsto (Function.uncurry fun x1 x2 => HAdd.hAdd x1 x2) (SProd.sprod (nhds 0) (nhds 0)) (nhds 0)\nhleft : ∀ (x₀ : M), Eq (nhds x₀) (Filter.map (fun x => HAdd.hAdd x₀ x) (nhds 0))\nhright : ∀ (x₀ : M), Eq (nhds x₀) (Filter.map (fun x => HAdd.hAdd x x₀) (nhds 0))\n⊢ ContinuousAdd M","decl":"@[to_additive]\ntheorem ContinuousMul.of_nhds_one {M : Type u} [Monoid M] [TopologicalSpace M]\n    (hmul : Tendsto (uncurry ((· * ·) : M → M → M)) (𝓝 1 ×ˢ 𝓝 1) <| 𝓝 1)\n    (hleft : ∀ x₀ : M, 𝓝 x₀ = map (fun x => x₀ * x) (𝓝 1))\n    (hright : ∀ x₀ : M, 𝓝 x₀ = map (fun x => x * x₀) (𝓝 1)) : ContinuousMul M :=\n  ⟨by\n    rw [continuous_iff_continuousAt]\n    rintro ⟨x₀, y₀⟩\n    have key : (fun p : M × M => x₀ * p.1 * (p.2 * y₀)) =\n        ((fun x => x₀ * x) ∘ fun x => x * y₀) ∘ uncurry (· * ·) := by\n      ext p\n      simp [uncurry, mul_assoc]\n    have key₂ : ((fun x => x₀ * x) ∘ fun x => y₀ * x) = fun x => x₀ * y₀ * x := by\n      ext x\n      simp [mul_assoc]\n    calc\n      map (uncurry (· * ·)) (𝓝 (x₀, y₀)) = map (uncurry (· * ·)) (𝓝 x₀ ×ˢ 𝓝 y₀) := by\n        rw [nhds_prod_eq]\n      _ = map (fun p : M × M => x₀ * p.1 * (p.2 * y₀)) (𝓝 1 ×ˢ 𝓝 1) := by\n        -- Porting note: `rw` was able to prove this\n        -- Now it fails with `failed to rewrite using equation theorems for 'Function.uncurry'`\n        -- and `failed to rewrite using equation theorems for 'Function.comp'`.\n        -- Removing those two lemmas, the `rw` would succeed, but then needs a `rfl`.\n        simp (config := { unfoldPartialApp := true }) only [uncurry]\n        simp_rw [hleft x₀, hright y₀, prod_map_map_eq, Filter.map_map, Function.comp_def]\n      _ = map ((fun x => x₀ * x) ∘ fun x => x * y₀) (map (uncurry (· * ·)) (𝓝 1 ×ˢ 𝓝 1)) := by\n        rw [key, ← Filter.map_map]\n      _ ≤ map ((fun x : M => x₀ * x) ∘ fun x => x * y₀) (𝓝 1) := map_mono hmul\n      _ = 𝓝 (x₀ * y₀) := by\n        rw [← Filter.map_map, ← hright, hleft y₀, Filter.map_map, key₂, ← hleft]⟩\n\n"}
{"name":"continuousAdd_of_comm_of_nhds_zero","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nhmul : Filter.Tendsto (Function.uncurry fun x1 x2 => HAdd.hAdd x1 x2) (SProd.sprod (nhds 0) (nhds 0)) (nhds 0)\nhleft : ∀ (x₀ : M), Eq (nhds x₀) (Filter.map (fun x => HAdd.hAdd x₀ x) (nhds 0))\n⊢ ContinuousAdd M","decl":"@[to_additive]\ntheorem continuousMul_of_comm_of_nhds_one (M : Type u) [CommMonoid M] [TopologicalSpace M]\n    (hmul : Tendsto (uncurry ((· * ·) : M → M → M)) (𝓝 1 ×ˢ 𝓝 1) (𝓝 1))\n    (hleft : ∀ x₀ : M, 𝓝 x₀ = map (fun x => x₀ * x) (𝓝 1)) : ContinuousMul M := by\n  apply ContinuousMul.of_nhds_one hmul hleft\n  intro x₀\n  simp_rw [mul_comm, hleft x₀]\n\n"}
{"name":"continuousMul_of_comm_of_nhds_one","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u\ninst✝¹ : CommMonoid M\ninst✝ : TopologicalSpace M\nhmul : Filter.Tendsto (Function.uncurry fun x1 x2 => HMul.hMul x1 x2) (SProd.sprod (nhds 1) (nhds 1)) (nhds 1)\nhleft : ∀ (x₀ : M), Eq (nhds x₀) (Filter.map (fun x => HMul.hMul x₀ x) (nhds 1))\n⊢ ContinuousMul M","decl":"@[to_additive]\ntheorem continuousMul_of_comm_of_nhds_one (M : Type u) [CommMonoid M] [TopologicalSpace M]\n    (hmul : Tendsto (uncurry ((· * ·) : M → M → M)) (𝓝 1 ×ˢ 𝓝 1) (𝓝 1))\n    (hleft : ∀ x₀ : M, 𝓝 x₀ = map (fun x => x₀ * x) (𝓝 1)) : ContinuousMul M := by\n  apply ContinuousMul.of_nhds_one hmul hleft\n  intro x₀\n  simp_rw [mul_comm, hleft x₀]\n\n"}
{"name":"isClosed_setOf_map_one","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M₁ : Type u_6\nM₂ : Type u_7\ninst✝³ : TopologicalSpace M₂\ninst✝² : T2Space M₂\ninst✝¹ : One M₁\ninst✝ : One M₂\n⊢ IsClosed (setOf fun f => Eq (f 1) 1)","decl":"@[to_additive]\ntheorem isClosed_setOf_map_one [One M₁] [One M₂] : IsClosed { f : M₁ → M₂ | f 1 = 1 } :=\n  isClosed_eq (continuous_apply 1) continuous_const\n\n"}
{"name":"isClosed_setOf_map_zero","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M₁ : Type u_6\nM₂ : Type u_7\ninst✝³ : TopologicalSpace M₂\ninst✝² : T2Space M₂\ninst✝¹ : Zero M₁\ninst✝ : Zero M₂\n⊢ IsClosed (setOf fun f => Eq (f 0) 0)","decl":"@[to_additive]\ntheorem isClosed_setOf_map_one [One M₁] [One M₂] : IsClosed { f : M₁ → M₂ | f 1 = 1 } :=\n  isClosed_eq (continuous_apply 1) continuous_const\n\n"}
{"name":"isClosed_setOf_map_mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M₁ : Type u_6\nM₂ : Type u_7\ninst✝⁴ : TopologicalSpace M₂\ninst✝³ : T2Space M₂\ninst✝² : Mul M₁\ninst✝¹ : Mul M₂\ninst✝ : ContinuousMul M₂\n⊢ IsClosed (setOf fun f => ∀ (x y : M₁), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y)))","decl":"@[to_additive]\ntheorem isClosed_setOf_map_mul [Mul M₁] [Mul M₂] [ContinuousMul M₂] :\n    IsClosed { f : M₁ → M₂ | ∀ x y, f (x * y) = f x * f y } := by\n  simp only [setOf_forall]\n  exact\n    isClosed_iInter fun x =>\n      isClosed_iInter fun y =>\n        isClosed_eq (continuous_apply _)\n          (by continuity)\n\n"}
{"name":"isClosed_setOf_map_add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M₁ : Type u_6\nM₂ : Type u_7\ninst✝⁴ : TopologicalSpace M₂\ninst✝³ : T2Space M₂\ninst✝² : Add M₁\ninst✝¹ : Add M₂\ninst✝ : ContinuousAdd M₂\n⊢ IsClosed (setOf fun f => ∀ (x y : M₁), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y)))","decl":"@[to_additive]\ntheorem isClosed_setOf_map_mul [Mul M₁] [Mul M₂] [ContinuousMul M₂] :\n    IsClosed { f : M₁ → M₂ | ∀ x y, f (x * y) = f x * f y } := by\n  simp only [setOf_forall]\n  exact\n    isClosed_iInter fun x =>\n      isClosed_iInter fun y =>\n        isClosed_eq (continuous_apply _)\n          (by continuity)\n\n"}
{"name":"mulHomOfMemClosureRangeCoe_apply","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M₁ : Type u_6\nM₂ : Type u_7\ninst✝⁶ : TopologicalSpace M₂\ninst✝⁵ : T2Space M₂\ninst✝⁴ : Mul M₁\ninst✝³ : Mul M₂\ninst✝² : ContinuousMul M₂\nF : Type u_8\ninst✝¹ : FunLike F M₁ M₂\ninst✝ : MulHomClass F M₁ M₂\nf : M₁ → M₂\nhf : Membership.mem (closure (Set.range fun f x => f x)) f\n⊢ Eq (⇑(mulHomOfMemClosureRangeCoe f hf)) f","decl":"/-- Construct a bundled semigroup homomorphism `M₁ →ₙ* M₂` from a function `f` and a proof that it\nbelongs to the closure of the range of the coercion from `M₁ →ₙ* M₂` (or another type of bundled\nhomomorphisms that has a `MulHomClass` instance) to `M₁ → M₂`. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"Construct a bundled additive semigroup homomorphism `M₁ →ₙ+ M₂` from a function `f`\nand a proof that it belongs to the closure of the range of the coercion from `M₁ →ₙ+ M₂` (or another\ntype of bundled homomorphisms that has an `AddHomClass` instance) to `M₁ → M₂`.\"]\ndef mulHomOfMemClosureRangeCoe (f : M₁ → M₂)\n    (hf : f ∈ closure (range fun (f : F) (x : M₁) => f x)) : M₁ →ₙ* M₂ where\n  toFun := f\n  map_mul' := (isClosed_setOf_map_mul M₁ M₂).closure_subset_iff.2 (range_subset_iff.2 map_mul) hf\n\n"}
{"name":"addHomOfMemClosureRangeCoe_apply","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M₁ : Type u_6\nM₂ : Type u_7\ninst✝⁶ : TopologicalSpace M₂\ninst✝⁵ : T2Space M₂\ninst✝⁴ : Add M₁\ninst✝³ : Add M₂\ninst✝² : ContinuousAdd M₂\nF : Type u_8\ninst✝¹ : FunLike F M₁ M₂\ninst✝ : AddHomClass F M₁ M₂\nf : M₁ → M₂\nhf : Membership.mem (closure (Set.range fun f x => f x)) f\n⊢ Eq (⇑(addHomOfMemClosureRangeCoe f hf)) f","decl":"/-- Construct a bundled semigroup homomorphism `M₁ →ₙ* M₂` from a function `f` and a proof that it\nbelongs to the closure of the range of the coercion from `M₁ →ₙ* M₂` (or another type of bundled\nhomomorphisms that has a `MulHomClass` instance) to `M₁ → M₂`. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"Construct a bundled additive semigroup homomorphism `M₁ →ₙ+ M₂` from a function `f`\nand a proof that it belongs to the closure of the range of the coercion from `M₁ →ₙ+ M₂` (or another\ntype of bundled homomorphisms that has an `AddHomClass` instance) to `M₁ → M₂`.\"]\ndef mulHomOfMemClosureRangeCoe (f : M₁ → M₂)\n    (hf : f ∈ closure (range fun (f : F) (x : M₁) => f x)) : M₁ →ₙ* M₂ where\n  toFun := f\n  map_mul' := (isClosed_setOf_map_mul M₁ M₂).closure_subset_iff.2 (range_subset_iff.2 map_mul) hf\n\n"}
{"name":"addHomOfTendsto_apply","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_2\nM₁ : Type u_6\nM₂ : Type u_7\ninst✝⁷ : TopologicalSpace M₂\ninst✝⁶ : T2Space M₂\ninst✝⁵ : Add M₁\ninst✝⁴ : Add M₂\ninst✝³ : ContinuousAdd M₂\nF : Type u_8\ninst✝² : FunLike F M₁ M₂\ninst✝¹ : AddHomClass F M₁ M₂\nl : Filter α\nf : M₁ → M₂\ng : α → F\ninst✝ : l.NeBot\nh : Filter.Tendsto (fun a x => (g a) x) l (nhds f)\n⊢ Eq (⇑(addHomOfTendsto f g h)) f","decl":"/-- Construct a bundled semigroup homomorphism from a pointwise limit of semigroup homomorphisms. -/\n@[to_additive (attr := simps! (config := .asFn))\n  \"Construct a bundled additive semigroup homomorphism from a pointwise limit of additive\nsemigroup homomorphisms\"]\ndef mulHomOfTendsto (f : M₁ → M₂) (g : α → F) [l.NeBot]\n    (h : Tendsto (fun a x => g a x) l (𝓝 f)) : M₁ →ₙ* M₂ :=\n  mulHomOfMemClosureRangeCoe f <|\n    mem_closure_of_tendsto h <| Eventually.of_forall fun _ => mem_range_self _\n\n"}
{"name":"mulHomOfTendsto_apply","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_2\nM₁ : Type u_6\nM₂ : Type u_7\ninst✝⁷ : TopologicalSpace M₂\ninst✝⁶ : T2Space M₂\ninst✝⁵ : Mul M₁\ninst✝⁴ : Mul M₂\ninst✝³ : ContinuousMul M₂\nF : Type u_8\ninst✝² : FunLike F M₁ M₂\ninst✝¹ : MulHomClass F M₁ M₂\nl : Filter α\nf : M₁ → M₂\ng : α → F\ninst✝ : l.NeBot\nh : Filter.Tendsto (fun a x => (g a) x) l (nhds f)\n⊢ Eq (⇑(mulHomOfTendsto f g h)) f","decl":"/-- Construct a bundled semigroup homomorphism from a pointwise limit of semigroup homomorphisms. -/\n@[to_additive (attr := simps! (config := .asFn))\n  \"Construct a bundled additive semigroup homomorphism from a pointwise limit of additive\nsemigroup homomorphisms\"]\ndef mulHomOfTendsto (f : M₁ → M₂) (g : α → F) [l.NeBot]\n    (h : Tendsto (fun a x => g a x) l (𝓝 f)) : M₁ →ₙ* M₂ :=\n  mulHomOfMemClosureRangeCoe f <|\n    mem_closure_of_tendsto h <| Eventually.of_forall fun _ => mem_range_self _\n\n"}
{"name":"MulHom.isClosed_range_coe","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M₁ : Type u_6\nM₂ : Type u_7\ninst✝⁴ : TopologicalSpace M₂\ninst✝³ : T2Space M₂\ninst✝² : Mul M₁\ninst✝¹ : Mul M₂\ninst✝ : ContinuousMul M₂\n⊢ IsClosed (Set.range DFunLike.coe)","decl":"@[to_additive]\ntheorem MulHom.isClosed_range_coe : IsClosed (Set.range ((↑) : (M₁ →ₙ* M₂) → M₁ → M₂)) :=\n  isClosed_of_closure_subset fun f hf => ⟨mulHomOfMemClosureRangeCoe f hf, rfl⟩\n\n"}
{"name":"AddHom.isClosed_range_coe","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M₁ : Type u_6\nM₂ : Type u_7\ninst✝⁴ : TopologicalSpace M₂\ninst✝³ : T2Space M₂\ninst✝² : Add M₁\ninst✝¹ : Add M₂\ninst✝ : ContinuousAdd M₂\n⊢ IsClosed (Set.range DFunLike.coe)","decl":"@[to_additive]\ntheorem MulHom.isClosed_range_coe : IsClosed (Set.range ((↑) : (M₁ →ₙ* M₂) → M₁ → M₂)) :=\n  isClosed_of_closure_subset fun f hf => ⟨mulHomOfMemClosureRangeCoe f hf, rfl⟩\n\n"}
{"name":"addMonoidHomOfMemClosureRangeCoe_apply","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M₁ : Type u_6\nM₂ : Type u_7\ninst✝⁶ : TopologicalSpace M₂\ninst✝⁵ : T2Space M₂\ninst✝⁴ : AddZeroClass M₁\ninst✝³ : AddZeroClass M₂\ninst✝² : ContinuousAdd M₂\nF : Type u_8\ninst✝¹ : FunLike F M₁ M₂\ninst✝ : AddMonoidHomClass F M₁ M₂\nf : M₁ → M₂\nhf : Membership.mem (closure (Set.range fun f x => f x)) f\n⊢ Eq (⇑(addMonoidHomOfMemClosureRangeCoe f hf)) f","decl":"/-- Construct a bundled monoid homomorphism `M₁ →* M₂` from a function `f` and a proof that it\nbelongs to the closure of the range of the coercion from `M₁ →* M₂` (or another type of bundled\nhomomorphisms that has a `MonoidHomClass` instance) to `M₁ → M₂`. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"Construct a bundled additive monoid homomorphism `M₁ →+ M₂` from a function `f`\nand a proof that it belongs to the closure of the range of the coercion from `M₁ →+ M₂` (or another\ntype of bundled homomorphisms that has an `AddMonoidHomClass` instance) to `M₁ → M₂`.\"]\ndef monoidHomOfMemClosureRangeCoe (f : M₁ → M₂)\n    (hf : f ∈ closure (range fun (f : F) (x : M₁) => f x)) : M₁ →* M₂ where\n  toFun := f\n  map_one' := (isClosed_setOf_map_one M₁ M₂).closure_subset_iff.2 (range_subset_iff.2 map_one) hf\n  map_mul' := (isClosed_setOf_map_mul M₁ M₂).closure_subset_iff.2 (range_subset_iff.2 map_mul) hf\n\n"}
{"name":"monoidHomOfMemClosureRangeCoe_apply","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M₁ : Type u_6\nM₂ : Type u_7\ninst✝⁶ : TopologicalSpace M₂\ninst✝⁵ : T2Space M₂\ninst✝⁴ : MulOneClass M₁\ninst✝³ : MulOneClass M₂\ninst✝² : ContinuousMul M₂\nF : Type u_8\ninst✝¹ : FunLike F M₁ M₂\ninst✝ : MonoidHomClass F M₁ M₂\nf : M₁ → M₂\nhf : Membership.mem (closure (Set.range fun f x => f x)) f\n⊢ Eq (⇑(monoidHomOfMemClosureRangeCoe f hf)) f","decl":"/-- Construct a bundled monoid homomorphism `M₁ →* M₂` from a function `f` and a proof that it\nbelongs to the closure of the range of the coercion from `M₁ →* M₂` (or another type of bundled\nhomomorphisms that has a `MonoidHomClass` instance) to `M₁ → M₂`. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"Construct a bundled additive monoid homomorphism `M₁ →+ M₂` from a function `f`\nand a proof that it belongs to the closure of the range of the coercion from `M₁ →+ M₂` (or another\ntype of bundled homomorphisms that has an `AddMonoidHomClass` instance) to `M₁ → M₂`.\"]\ndef monoidHomOfMemClosureRangeCoe (f : M₁ → M₂)\n    (hf : f ∈ closure (range fun (f : F) (x : M₁) => f x)) : M₁ →* M₂ where\n  toFun := f\n  map_one' := (isClosed_setOf_map_one M₁ M₂).closure_subset_iff.2 (range_subset_iff.2 map_one) hf\n  map_mul' := (isClosed_setOf_map_mul M₁ M₂).closure_subset_iff.2 (range_subset_iff.2 map_mul) hf\n\n"}
{"name":"addMonoidHomOfTendsto_apply","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_2\nM₁ : Type u_6\nM₂ : Type u_7\ninst✝⁷ : TopologicalSpace M₂\ninst✝⁶ : T2Space M₂\ninst✝⁵ : AddZeroClass M₁\ninst✝⁴ : AddZeroClass M₂\ninst✝³ : ContinuousAdd M₂\nF : Type u_8\ninst✝² : FunLike F M₁ M₂\ninst✝¹ : AddMonoidHomClass F M₁ M₂\nl : Filter α\nf : M₁ → M₂\ng : α → F\ninst✝ : l.NeBot\nh : Filter.Tendsto (fun a x => (g a) x) l (nhds f)\n⊢ Eq (⇑(addMonoidHomOfTendsto f g h)) f","decl":"/-- Construct a bundled monoid homomorphism from a pointwise limit of monoid homomorphisms. -/\n@[to_additive (attr := simps! (config := .asFn))\n  \"Construct a bundled additive monoid homomorphism from a pointwise limit of additive\nmonoid homomorphisms\"]\ndef monoidHomOfTendsto (f : M₁ → M₂) (g : α → F) [l.NeBot]\n    (h : Tendsto (fun a x => g a x) l (𝓝 f)) : M₁ →* M₂ :=\n  monoidHomOfMemClosureRangeCoe f <|\n    mem_closure_of_tendsto h <| Eventually.of_forall fun _ => mem_range_self _\n\n"}
{"name":"monoidHomOfTendsto_apply","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_2\nM₁ : Type u_6\nM₂ : Type u_7\ninst✝⁷ : TopologicalSpace M₂\ninst✝⁶ : T2Space M₂\ninst✝⁵ : MulOneClass M₁\ninst✝⁴ : MulOneClass M₂\ninst✝³ : ContinuousMul M₂\nF : Type u_8\ninst✝² : FunLike F M₁ M₂\ninst✝¹ : MonoidHomClass F M₁ M₂\nl : Filter α\nf : M₁ → M₂\ng : α → F\ninst✝ : l.NeBot\nh : Filter.Tendsto (fun a x => (g a) x) l (nhds f)\n⊢ Eq (⇑(monoidHomOfTendsto f g h)) f","decl":"/-- Construct a bundled monoid homomorphism from a pointwise limit of monoid homomorphisms. -/\n@[to_additive (attr := simps! (config := .asFn))\n  \"Construct a bundled additive monoid homomorphism from a pointwise limit of additive\nmonoid homomorphisms\"]\ndef monoidHomOfTendsto (f : M₁ → M₂) (g : α → F) [l.NeBot]\n    (h : Tendsto (fun a x => g a x) l (𝓝 f)) : M₁ →* M₂ :=\n  monoidHomOfMemClosureRangeCoe f <|\n    mem_closure_of_tendsto h <| Eventually.of_forall fun _ => mem_range_self _\n\n"}
{"name":"MonoidHom.isClosed_range_coe","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M₁ : Type u_6\nM₂ : Type u_7\ninst✝⁴ : TopologicalSpace M₂\ninst✝³ : T2Space M₂\ninst✝² : MulOneClass M₁\ninst✝¹ : MulOneClass M₂\ninst✝ : ContinuousMul M₂\n⊢ IsClosed (Set.range DFunLike.coe)","decl":"@[to_additive]\ntheorem MonoidHom.isClosed_range_coe : IsClosed (Set.range ((↑) : (M₁ →* M₂) → M₁ → M₂)) :=\n  isClosed_of_closure_subset fun f hf => ⟨monoidHomOfMemClosureRangeCoe f hf, rfl⟩\n\n"}
{"name":"AddMonoidHom.isClosed_range_coe","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M₁ : Type u_6\nM₂ : Type u_7\ninst✝⁴ : TopologicalSpace M₂\ninst✝³ : T2Space M₂\ninst✝² : AddZeroClass M₁\ninst✝¹ : AddZeroClass M₂\ninst✝ : ContinuousAdd M₂\n⊢ IsClosed (Set.range DFunLike.coe)","decl":"@[to_additive]\ntheorem MonoidHom.isClosed_range_coe : IsClosed (Set.range ((↑) : (M₁ →* M₂) → M₁ → M₂)) :=\n  isClosed_of_closure_subset fun f hf => ⟨monoidHomOfMemClosureRangeCoe f hf, rfl⟩\n\n"}
{"name":"Topology.IsInducing.continuousMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\nN : Type u_7\nF : Type u_8\ninst✝⁶ : Mul M\ninst✝⁵ : Mul N\ninst✝⁴ : FunLike F M N\ninst✝³ : MulHomClass F M N\ninst✝² : TopologicalSpace M\ninst✝¹ : TopologicalSpace N\ninst✝ : ContinuousMul N\nf : F\nhf : Topology.IsInducing ⇑f\n⊢ ContinuousMul M","decl":"@[to_additive]\ntheorem Topology.IsInducing.continuousMul {M N F : Type*} [Mul M] [Mul N] [FunLike F M N]\n    [MulHomClass F M N] [TopologicalSpace M] [TopologicalSpace N] [ContinuousMul N] (f : F)\n    (hf : IsInducing f) : ContinuousMul M :=\n  ⟨(hf.continuousSMul hf.continuous (map_mul f _ _)).1⟩\n\n"}
{"name":"Topology.IsInducing.continuousAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\nN : Type u_7\nF : Type u_8\ninst✝⁶ : Add M\ninst✝⁵ : Add N\ninst✝⁴ : FunLike F M N\ninst✝³ : AddHomClass F M N\ninst✝² : TopologicalSpace M\ninst✝¹ : TopologicalSpace N\ninst✝ : ContinuousAdd N\nf : F\nhf : Topology.IsInducing ⇑f\n⊢ ContinuousAdd M","decl":"@[to_additive]\ntheorem Topology.IsInducing.continuousMul {M N F : Type*} [Mul M] [Mul N] [FunLike F M N]\n    [MulHomClass F M N] [TopologicalSpace M] [TopologicalSpace N] [ContinuousMul N] (f : F)\n    (hf : IsInducing f) : ContinuousMul M :=\n  ⟨(hf.continuousSMul hf.continuous (map_mul f _ _)).1⟩\n\n"}
{"name":"Inducing.continuousMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\nN : Type u_7\nF : Type u_8\ninst✝⁶ : Mul M\ninst✝⁵ : Mul N\ninst✝⁴ : FunLike F M N\ninst✝³ : MulHomClass F M N\ninst✝² : TopologicalSpace M\ninst✝¹ : TopologicalSpace N\ninst✝ : ContinuousMul N\nf : F\nhf : Topology.IsInducing ⇑f\n⊢ ContinuousMul M","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.continuousMul := IsInducing.continuousMul\n\n"}
{"name":"continuousMul_induced","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\nN : Type u_7\nF : Type u_8\ninst✝⁵ : Mul M\ninst✝⁴ : Mul N\ninst✝³ : FunLike F M N\ninst✝² : MulHomClass F M N\ninst✝¹ : TopologicalSpace N\ninst✝ : ContinuousMul N\nf : F\n⊢ ContinuousMul M","decl":"@[to_additive]\ntheorem continuousMul_induced {M N F : Type*} [Mul M] [Mul N] [FunLike F M N] [MulHomClass F M N]\n    [TopologicalSpace N] [ContinuousMul N] (f : F) : @ContinuousMul M (induced f ‹_›) _ :=\n  letI := induced f ‹_›\n  IsInducing.continuousMul f ⟨rfl⟩\n\n"}
{"name":"continuousAdd_induced","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_6\nN : Type u_7\nF : Type u_8\ninst✝⁵ : Add M\ninst✝⁴ : Add N\ninst✝³ : FunLike F M N\ninst✝² : AddHomClass F M N\ninst✝¹ : TopologicalSpace N\ninst✝ : ContinuousAdd N\nf : F\n⊢ ContinuousAdd M","decl":"@[to_additive]\ntheorem continuousMul_induced {M N F : Type*} [Mul M] [Mul N] [FunLike F M N] [MulHomClass F M N]\n    [TopologicalSpace N] [ContinuousMul N] (f : F) : @ContinuousMul M (induced f ‹_›) _ :=\n  letI := induced f ‹_›\n  IsInducing.continuousMul f ⟨rfl⟩\n\n"}
{"name":"AddSubsemigroup.continuousAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddSemigroup M\ninst✝ : ContinuousAdd M\nS : AddSubsemigroup M\n⊢ ContinuousAdd (Subtype fun x => Membership.mem S x)","decl":"@[to_additive]\ninstance Subsemigroup.continuousMul [TopologicalSpace M] [Semigroup M] [ContinuousMul M]\n    (S : Subsemigroup M) : ContinuousMul S :=\n  IsInducing.continuousMul ({ toFun := (↑), map_mul' := fun _ _ => rfl} : MulHom S M) ⟨rfl⟩\n\n"}
{"name":"Subsemigroup.continuousMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Semigroup M\ninst✝ : ContinuousMul M\nS : Subsemigroup M\n⊢ ContinuousMul (Subtype fun x => Membership.mem S x)","decl":"@[to_additive]\ninstance Subsemigroup.continuousMul [TopologicalSpace M] [Semigroup M] [ContinuousMul M]\n    (S : Subsemigroup M) : ContinuousMul S :=\n  IsInducing.continuousMul ({ toFun := (↑), map_mul' := fun _ _ => rfl} : MulHom S M) ⟨rfl⟩\n\n"}
{"name":"AddSubmonoid.continuousAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddMonoid M\ninst✝ : ContinuousAdd M\nS : AddSubmonoid M\n⊢ ContinuousAdd (Subtype fun x => Membership.mem S x)","decl":"@[to_additive]\ninstance Submonoid.continuousMul [TopologicalSpace M] [Monoid M] [ContinuousMul M]\n    (S : Submonoid M) : ContinuousMul S :=\n  S.toSubsemigroup.continuousMul\n\n"}
{"name":"Submonoid.continuousMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\nS : Submonoid M\n⊢ ContinuousMul (Subtype fun x => Membership.mem S x)","decl":"@[to_additive]\ninstance Submonoid.continuousMul [TopologicalSpace M] [Monoid M] [ContinuousMul M]\n    (S : Submonoid M) : ContinuousMul S :=\n  S.toSubsemigroup.continuousMul\n\n"}
{"name":"exists_mem_nhds_zero_mul_subset","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : MulZeroClass M\ninst✝ : ContinuousMul M\nK U : Set M\nhK : IsCompact K\nhU : Membership.mem (nhds 0) U\n⊢ Exists fun V => And (Membership.mem (nhds 0) V) (HasSubset.Subset (HMul.hMul K V) U)","decl":"theorem exists_mem_nhds_zero_mul_subset\n    {K U : Set M} (hK : IsCompact K) (hU : U ∈ 𝓝 0) : ∃ V ∈ 𝓝 0, K * V ⊆ U := by\n  refine hK.induction_on ?_ ?_ ?_ ?_\n  · exact ⟨univ, by simp⟩\n  · rintro s t hst ⟨V, hV, hV'⟩\n    exact ⟨V, hV, (mul_subset_mul_right hst).trans hV'⟩\n  · rintro s t ⟨V, V_in, hV'⟩ ⟨W, W_in, hW'⟩\n    use V ∩ W, inter_mem V_in W_in\n    rw [union_mul]\n    exact\n      union_subset ((mul_subset_mul_left V.inter_subset_left).trans hV')\n        ((mul_subset_mul_left V.inter_subset_right).trans hW')\n  · intro x hx\n    have := tendsto_mul (show U ∈ 𝓝 (x * 0) by simpa using hU)\n    rw [nhds_prod_eq, mem_map, mem_prod_iff] at this\n    rcases this with ⟨t, ht, s, hs, h⟩\n    rw [← image_subset_iff, image_mul_prod] at h\n    exact ⟨t, mem_nhdsWithin_of_mem_nhds ht, s, hs, h⟩\n\n"}
{"name":"tendsto_mul_nhds_zero_prod_of_disjoint_cocompact","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : MulZeroClass M\ninst✝ : ContinuousMul M\nl : Filter M\nhl : Disjoint l (Filter.cocompact M)\n⊢ Filter.Tendsto (fun x => HMul.hMul x.1 x.2) (SProd.sprod (nhds 0) l) (nhds 0)","decl":"/-- Let `M` be a topological space with a continuous multiplication operation and a `0`.\nLet `l` be a filter on `M` which is disjoint from the cocompact filter. Then, the multiplication map\n`M × M → M` tends to zero on the filter product `𝓝 0 ×ˢ l`. -/\ntheorem tendsto_mul_nhds_zero_prod_of_disjoint_cocompact {l : Filter M}\n    (hl : Disjoint l (cocompact M)) :\n    Tendsto (fun x : M × M ↦ x.1 * x.2) (𝓝 0 ×ˢ l) (𝓝 0) := calc\n  map (fun x : M × M ↦ x.1 * x.2) (𝓝 0 ×ˢ l)\n  _ ≤ map (fun x : M × M ↦ x.1 * x.2) (𝓝ˢ ({0} ×ˢ Set.univ)) :=\n    map_mono <| nhds_prod_le_of_disjoint_cocompact 0 hl\n  _ ≤ 𝓝 0 := continuous_mul.tendsto_nhdsSet_nhds fun _ ⟨hx, _⟩ ↦ mul_eq_zero_of_left hx _\n\n"}
{"name":"tendsto_mul_prod_nhds_zero_of_disjoint_cocompact","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : MulZeroClass M\ninst✝ : ContinuousMul M\nl : Filter M\nhl : Disjoint l (Filter.cocompact M)\n⊢ Filter.Tendsto (fun x => HMul.hMul x.1 x.2) (SProd.sprod l (nhds 0)) (nhds 0)","decl":"/-- Let `M` be a topological space with a continuous multiplication operation and a `0`.\nLet `l` be a filter on `M` which is disjoint from the cocompact filter. Then, the multiplication map\n`M × M → M` tends to zero on the filter product `l ×ˢ 𝓝 0`. -/\ntheorem tendsto_mul_prod_nhds_zero_of_disjoint_cocompact {l : Filter M}\n    (hl : Disjoint l (cocompact M)) :\n    Tendsto (fun x : M × M ↦ x.1 * x.2) (l ×ˢ 𝓝 0) (𝓝 0) := calc\n  map (fun x : M × M ↦ x.1 * x.2) (l ×ˢ 𝓝 0)\n  _ ≤ map (fun x : M × M ↦ x.1 * x.2) (𝓝ˢ (Set.univ ×ˢ {0})) :=\n    map_mono <| prod_nhds_le_of_disjoint_cocompact 0 hl\n  _ ≤ 𝓝 0 := continuous_mul.tendsto_nhdsSet_nhds fun _ ⟨_, hx⟩ ↦ mul_eq_zero_of_right _ hx\n\n"}
{"name":"tendsto_mul_coprod_nhds_zero_inf_of_disjoint_cocompact","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : MulZeroClass M\ninst✝ : ContinuousMul M\nl : Filter (Prod M M)\nhl : Disjoint l (Filter.cocompact (Prod M M))\n⊢ Filter.Tendsto (fun x => HMul.hMul x.1 x.2) (Min.min ((nhds 0).coprod (nhds 0)) l) (nhds 0)","decl":"/-- Let `M` be a topological space with a continuous multiplication operation and a `0`.\nLet `l` be a filter on `M × M` which is disjoint from the cocompact filter. Then, the multiplication\nmap `M × M → M` tends to zero on `(𝓝 0).coprod (𝓝 0) ⊓ l`. -/\ntheorem tendsto_mul_coprod_nhds_zero_inf_of_disjoint_cocompact {l : Filter (M × M)}\n    (hl : Disjoint l (cocompact (M × M))) :\n    Tendsto (fun x : M × M ↦ x.1 * x.2) ((𝓝 0).coprod (𝓝 0) ⊓ l) (𝓝 0) := by\n  have := calc\n    (𝓝 0).coprod (𝓝 0) ⊓ l\n    _ ≤ (𝓝 0).coprod (𝓝 0) ⊓ map Prod.fst l ×ˢ map Prod.snd l :=\n      inf_le_inf_left _ le_prod_map_fst_snd\n    _ ≤ 𝓝 0 ×ˢ map Prod.snd l ⊔ map Prod.fst l ×ˢ 𝓝 0 :=\n      coprod_inf_prod_le _ _ _ _\n  apply (Tendsto.sup _ _).mono_left this\n  · apply tendsto_mul_nhds_zero_prod_of_disjoint_cocompact\n    exact disjoint_map_cocompact continuous_snd hl\n  · apply tendsto_mul_prod_nhds_zero_of_disjoint_cocompact\n    exact disjoint_map_cocompact continuous_fst hl\n\n"}
{"name":"tendsto_mul_nhds_zero_of_disjoint_cocompact","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : MulZeroClass M\ninst✝ : ContinuousMul M\nl : Filter (Prod M M)\nhl : Disjoint l (Filter.cocompact (Prod M M))\nh'l : LE.le l ((nhds 0).coprod (nhds 0))\n⊢ Filter.Tendsto (fun x => HMul.hMul x.1 x.2) l (nhds 0)","decl":"/-- Let `M` be a topological space with a continuous multiplication operation and a `0`.\nLet `l` be a filter on `M × M` which is both disjoint from the cocompact filter and less than or\nequal to `(𝓝 0).coprod (𝓝 0)`. Then the multiplication map `M × M → M` tends to zero on `l`. -/\ntheorem tendsto_mul_nhds_zero_of_disjoint_cocompact {l : Filter (M × M)}\n    (hl : Disjoint l (cocompact (M × M))) (h'l : l ≤ (𝓝 0).coprod (𝓝 0)) :\n    Tendsto (fun x : M × M ↦ x.1 * x.2) l (𝓝 0) := by\n  simpa [inf_eq_right.mpr h'l] using tendsto_mul_coprod_nhds_zero_inf_of_disjoint_cocompact hl\n\n"}
{"name":"Tendsto.tendsto_mul_zero_of_disjoint_cocompact_right","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nα : Type u_6\ninst✝² : TopologicalSpace M\ninst✝¹ : MulZeroClass M\ninst✝ : ContinuousMul M\nf g : α → M\nl : Filter α\nhf : Filter.Tendsto f l (nhds 0)\nhg : Disjoint (Filter.map g l) (Filter.cocompact M)\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l (nhds 0)","decl":"/-- Let `M` be a topological space with a continuous multiplication operation and a `0`.\nLet `f : α → M` and `g : α → M` be functions. If `f` tends to zero on a filter `l`\nand the image of `l` under `g` is disjoint from the cocompact filter on `M`, then\n`fun x : α ↦ f x * g x` also tends to zero on `l`. -/\ntheorem Tendsto.tendsto_mul_zero_of_disjoint_cocompact_right {f g : α → M} {l : Filter α}\n    (hf : Tendsto f l (𝓝 0)) (hg : Disjoint (map g l) (cocompact M)) :\n    Tendsto (fun x ↦ f x * g x) l (𝓝 0) :=\n  tendsto_mul_nhds_zero_prod_of_disjoint_cocompact hg |>.comp (hf.prod_mk tendsto_map)\n\n"}
{"name":"Tendsto.tendsto_mul_zero_of_disjoint_cocompact_left","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nα : Type u_6\ninst✝² : TopologicalSpace M\ninst✝¹ : MulZeroClass M\ninst✝ : ContinuousMul M\nf g : α → M\nl : Filter α\nhf : Disjoint (Filter.map f l) (Filter.cocompact M)\nhg : Filter.Tendsto g l (nhds 0)\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l (nhds 0)","decl":"/-- Let `M` be a topological space with a continuous multiplication operation and a `0`.\nLet `f : α → M` and `g : α → M` be functions. If `g` tends to zero on a filter `l`\nand the image of `l` under `f` is disjoint from the cocompact filter on `M`, then\n`fun x : α ↦ f x * g x` also tends to zero on `l`. -/\ntheorem Tendsto.tendsto_mul_zero_of_disjoint_cocompact_left {f g : α → M} {l : Filter α}\n    (hf : Disjoint (map f l) (cocompact M)) (hg : Tendsto g l (𝓝 0)):\n    Tendsto (fun x ↦ f x * g x) l (𝓝 0) :=\n  tendsto_mul_prod_nhds_zero_of_disjoint_cocompact hf |>.comp (tendsto_map.prod_mk hg)\n\n"}
{"name":"tendsto_mul_cocompact_nhds_zero","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nα : Type u_6\nβ : Type u_7\ninst✝⁴ : TopologicalSpace M\ninst✝³ : MulZeroClass M\ninst✝² : ContinuousMul M\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : α → M\ng : β → M\nf_cont : Continuous f\ng_cont : Continuous g\nhf : Filter.Tendsto f (Filter.cocompact α) (nhds 0)\nhg : Filter.Tendsto g (Filter.cocompact β) (nhds 0)\n⊢ Filter.Tendsto (fun i => HMul.hMul (f i.1) (g i.2)) (Filter.cocompact (Prod α β)) (nhds 0)","decl":"/-- If `f : α → M` and `g : β → M` are continuous and both tend to zero on the cocompact filter,\nthen `fun i : α × β ↦ f i.1 * g i.2` also tends to zero on the cocompact filter. -/\ntheorem tendsto_mul_cocompact_nhds_zero [TopologicalSpace α] [TopologicalSpace β]\n    {f : α → M} {g : β → M} (f_cont : Continuous f) (g_cont : Continuous g)\n    (hf : Tendsto f (cocompact α) (𝓝 0)) (hg : Tendsto g (cocompact β) (𝓝 0)) :\n    Tendsto (fun i : α × β ↦ f i.1 * g i.2) (cocompact (α × β)) (𝓝 0) := by\n  set l : Filter (M × M) := map (Prod.map f g) (cocompact (α × β)) with l_def\n  set K : Set (M × M) := (insert 0 (range f)) ×ˢ (insert 0 (range g))\n  have K_compact : IsCompact K := .prod (hf.isCompact_insert_range_of_cocompact f_cont)\n    (hg.isCompact_insert_range_of_cocompact g_cont)\n  have K_mem_l : K ∈ l := eventually_map.mpr <| .of_forall fun ⟨x, y⟩ ↦\n    ⟨mem_insert_of_mem _ (mem_range_self _), mem_insert_of_mem _ (mem_range_self _)⟩\n  have l_compact : Disjoint l (cocompact (M × M)) := by\n    rw [disjoint_cocompact_right]\n    exact ⟨K, K_mem_l, K_compact⟩\n  have l_le_coprod : l ≤ (𝓝 0).coprod (𝓝 0) := by\n    rw [l_def, ← coprod_cocompact]\n    exact hf.prod_map_coprod hg\n  exact tendsto_mul_nhds_zero_of_disjoint_cocompact l_compact l_le_coprod |>.comp tendsto_map\n\n"}
{"name":"tendsto_mul_cofinite_nhds_zero","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nα : Type u_6\nβ : Type u_7\ninst✝² : TopologicalSpace M\ninst✝¹ : MulZeroClass M\ninst✝ : ContinuousMul M\nf : α → M\ng : β → M\nhf : Filter.Tendsto f Filter.cofinite (nhds 0)\nhg : Filter.Tendsto g Filter.cofinite (nhds 0)\n⊢ Filter.Tendsto (fun i => HMul.hMul (f i.1) (g i.2)) Filter.cofinite (nhds 0)","decl":"/-- If `f : α → M` and `g : β → M` both tend to zero on the cofinite filter, then so does\n`fun i : α × β ↦ f i.1 * g i.2`. -/\ntheorem tendsto_mul_cofinite_nhds_zero {f : α → M} {g : β → M}\n    (hf : Tendsto f cofinite (𝓝 0)) (hg : Tendsto g cofinite (𝓝 0)) :\n    Tendsto (fun i : α × β ↦ f i.1 * g i.2) cofinite (𝓝 0) := by\n  letI : TopologicalSpace α := ⊥\n  haveI : DiscreteTopology α := discreteTopology_bot α\n  letI : TopologicalSpace β := ⊥\n  haveI : DiscreteTopology β := discreteTopology_bot β\n  rw [← cocompact_eq_cofinite] at *\n  exact tendsto_mul_cocompact_nhds_zero\n    continuous_of_discreteTopology continuous_of_discreteTopology hf hg\n\n"}
{"name":"GroupWithZero.isOpen_singleton_zero","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝⁴ : GroupWithZero M\ninst✝³ : TopologicalSpace M\ninst✝² : ContinuousMul M\ninst✝¹ : CompactSpace M\ninst✝ : T1Space M\n⊢ IsOpen (Singleton.singleton 0)","decl":"lemma GroupWithZero.isOpen_singleton_zero [GroupWithZero M] [TopologicalSpace M]\n    [ContinuousMul M] [CompactSpace M] [T1Space M] :\n    IsOpen {(0 : M)} := by\n  obtain ⟨U, hU, h0U, h1U⟩ := t1Space_iff_exists_open.mp ‹_› zero_ne_one\n  obtain ⟨W, hW, hW'⟩ := exists_mem_nhds_zero_mul_subset isCompact_univ (hU.mem_nhds h0U)\n  by_cases H : ∃ x ≠ 0, x ∈ W\n  · obtain ⟨x, hx, hxW⟩ := H\n    cases h1U (hW' (by simpa [hx] using Set.mul_mem_mul (Set.mem_univ x⁻¹) hxW))\n  · obtain rfl : W = {0} := subset_antisymm\n      (by simpa [not_imp_not] using H) (by simpa using mem_of_mem_nhds hW)\n    simpa [isOpen_iff_mem_nhds]\n\n"}
{"name":"exists_open_nhds_zero_half","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddZeroClass M\ninst✝ : ContinuousAdd M\ns : Set M\nhs : Membership.mem (nhds 0) s\n⊢ Exists fun V => And (IsOpen V) (And (Membership.mem V 0) (∀ (v : M), Membership.mem V v → ∀ (w : M), Membership.mem V w → Membership.mem s (HAdd.hAdd v w)))","decl":"@[to_additive exists_open_nhds_zero_half]\ntheorem exists_open_nhds_one_split {s : Set M} (hs : s ∈ 𝓝 (1 : M)) :\n    ∃ V : Set M, IsOpen V ∧ (1 : M) ∈ V ∧ ∀ v ∈ V, ∀ w ∈ V, v * w ∈ s := by\n  have : (fun a : M × M => a.1 * a.2) ⁻¹' s ∈ 𝓝 ((1, 1) : M × M) :=\n    tendsto_mul (by simpa only [one_mul] using hs)\n  simpa only [prod_subset_iff] using exists_nhds_square this\n\n"}
{"name":"exists_open_nhds_one_split","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : MulOneClass M\ninst✝ : ContinuousMul M\ns : Set M\nhs : Membership.mem (nhds 1) s\n⊢ Exists fun V => And (IsOpen V) (And (Membership.mem V 1) (∀ (v : M), Membership.mem V v → ∀ (w : M), Membership.mem V w → Membership.mem s (HMul.hMul v w)))","decl":"@[to_additive exists_open_nhds_zero_half]\ntheorem exists_open_nhds_one_split {s : Set M} (hs : s ∈ 𝓝 (1 : M)) :\n    ∃ V : Set M, IsOpen V ∧ (1 : M) ∈ V ∧ ∀ v ∈ V, ∀ w ∈ V, v * w ∈ s := by\n  have : (fun a : M × M => a.1 * a.2) ⁻¹' s ∈ 𝓝 ((1, 1) : M × M) :=\n    tendsto_mul (by simpa only [one_mul] using hs)\n  simpa only [prod_subset_iff] using exists_nhds_square this\n\n"}
{"name":"exists_nhds_zero_half","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddZeroClass M\ninst✝ : ContinuousAdd M\ns : Set M\nhs : Membership.mem (nhds 0) s\n⊢ Exists fun V => And (Membership.mem (nhds 0) V) (∀ (v : M), Membership.mem V v → ∀ (w : M), Membership.mem V w → Membership.mem s (HAdd.hAdd v w))","decl":"@[to_additive exists_nhds_zero_half]\ntheorem exists_nhds_one_split {s : Set M} (hs : s ∈ 𝓝 (1 : M)) :\n    ∃ V ∈ 𝓝 (1 : M), ∀ v ∈ V, ∀ w ∈ V, v * w ∈ s :=\n  let ⟨V, Vo, V1, hV⟩ := exists_open_nhds_one_split hs\n  ⟨V, IsOpen.mem_nhds Vo V1, hV⟩\n\n"}
{"name":"exists_nhds_one_split","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : MulOneClass M\ninst✝ : ContinuousMul M\ns : Set M\nhs : Membership.mem (nhds 1) s\n⊢ Exists fun V => And (Membership.mem (nhds 1) V) (∀ (v : M), Membership.mem V v → ∀ (w : M), Membership.mem V w → Membership.mem s (HMul.hMul v w))","decl":"@[to_additive exists_nhds_zero_half]\ntheorem exists_nhds_one_split {s : Set M} (hs : s ∈ 𝓝 (1 : M)) :\n    ∃ V ∈ 𝓝 (1 : M), ∀ v ∈ V, ∀ w ∈ V, v * w ∈ s :=\n  let ⟨V, Vo, V1, hV⟩ := exists_open_nhds_one_split hs\n  ⟨V, IsOpen.mem_nhds Vo V1, hV⟩\n\n"}
{"name":"exists_open_nhds_zero_add_subset","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddZeroClass M\ninst✝ : ContinuousAdd M\nU : Set M\nhU : Membership.mem (nhds 0) U\n⊢ Exists fun V => And (IsOpen V) (And (Membership.mem V 0) (HasSubset.Subset (HAdd.hAdd V V) U))","decl":"/-- Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\nsuch that `V * V ⊆ U`. -/\n@[to_additive \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\n  such that `V + V ⊆ U`.\"]\ntheorem exists_open_nhds_one_mul_subset {U : Set M} (hU : U ∈ 𝓝 (1 : M)) :\n    ∃ V : Set M, IsOpen V ∧ (1 : M) ∈ V ∧ V * V ⊆ U := by\n  simpa only [mul_subset_iff] using exists_open_nhds_one_split hU\n\n"}
{"name":"exists_open_nhds_one_mul_subset","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : MulOneClass M\ninst✝ : ContinuousMul M\nU : Set M\nhU : Membership.mem (nhds 1) U\n⊢ Exists fun V => And (IsOpen V) (And (Membership.mem V 1) (HasSubset.Subset (HMul.hMul V V) U))","decl":"/-- Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\nsuch that `V * V ⊆ U`. -/\n@[to_additive \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\n  such that `V + V ⊆ U`.\"]\ntheorem exists_open_nhds_one_mul_subset {U : Set M} (hU : U ∈ 𝓝 (1 : M)) :\n    ∃ V : Set M, IsOpen V ∧ (1 : M) ∈ V ∧ V * V ⊆ U := by\n  simpa only [mul_subset_iff] using exists_open_nhds_one_split hU\n\n"}
{"name":"Filter.HasBasis.mul_self","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : MulOneClass M\ninst✝ : ContinuousMul M\np : ι → Prop\ns : ι → Set M\nh : (nhds 1).HasBasis p s\n⊢ (nhds 1).HasBasis p fun i => HMul.hMul (s i) (s i)","decl":"@[to_additive]\ntheorem Filter.HasBasis.mul_self {p : ι → Prop} {s : ι → Set M} (h : (𝓝 1).HasBasis p s) :\n    (𝓝 1).HasBasis p fun i => s i * s i := by\n  rw [← nhds_mul_nhds_one, ← map₂_mul, ← map_uncurry_prod]\n  simpa only [← image_mul_prod] using h.prod_self.map _\n\n"}
{"name":"Filter.HasBasis.add_self","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddZeroClass M\ninst✝ : ContinuousAdd M\np : ι → Prop\ns : ι → Set M\nh : (nhds 0).HasBasis p s\n⊢ (nhds 0).HasBasis p fun i => HAdd.hAdd (s i) (s i)","decl":"@[to_additive]\ntheorem Filter.HasBasis.mul_self {p : ι → Prop} {s : ι → Set M} (h : (𝓝 1).HasBasis p s) :\n    (𝓝 1).HasBasis p fun i => s i * s i := by\n  rw [← nhds_mul_nhds_one, ← map₂_mul, ← map_uncurry_prod]\n  simpa only [← image_mul_prod] using h.prod_self.map _\n\n"}
{"name":"Subsemigroup.top_closure_mul_self_subset","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Semigroup M\ninst✝ : ContinuousMul M\ns : Subsemigroup M\n⊢ HasSubset.Subset (HMul.hMul (closure ↑s) (closure ↑s)) (closure ↑s)","decl":"@[to_additive]\ntheorem Subsemigroup.top_closure_mul_self_subset (s : Subsemigroup M) :\n    _root_.closure (s : Set M) * _root_.closure s ⊆ _root_.closure s :=\n  image2_subset_iff.2 fun _ hx _ hy =>\n    map_mem_closure₂ continuous_mul hx hy fun _ ha _ hb => s.mul_mem ha hb\n\n"}
{"name":"AddSubsemigroup.top_closure_add_self_subset","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddSemigroup M\ninst✝ : ContinuousAdd M\ns : AddSubsemigroup M\n⊢ HasSubset.Subset (HAdd.hAdd (closure ↑s) (closure ↑s)) (closure ↑s)","decl":"@[to_additive]\ntheorem Subsemigroup.top_closure_mul_self_subset (s : Subsemigroup M) :\n    _root_.closure (s : Set M) * _root_.closure s ⊆ _root_.closure s :=\n  image2_subset_iff.2 fun _ hx _ hy =>\n    map_mem_closure₂ continuous_mul hx hy fun _ ha _ hb => s.mul_mem ha hb\n\n"}
{"name":"Subsemigroup.coe_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Semigroup M\ninst✝ : ContinuousMul M\ns : Subsemigroup M\n⊢ Eq (↑s.topologicalClosure) (closure ↑s)","decl":"@[to_additive]\ntheorem Subsemigroup.coe_topologicalClosure (s : Subsemigroup M) :\n    (s.topologicalClosure : Set M) = _root_.closure (s : Set M) := rfl\n\n"}
{"name":"AddSubsemigroup.coe_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddSemigroup M\ninst✝ : ContinuousAdd M\ns : AddSubsemigroup M\n⊢ Eq (↑s.topologicalClosure) (closure ↑s)","decl":"@[to_additive]\ntheorem Subsemigroup.coe_topologicalClosure (s : Subsemigroup M) :\n    (s.topologicalClosure : Set M) = _root_.closure (s : Set M) := rfl\n\n"}
{"name":"Subsemigroup.le_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Semigroup M\ninst✝ : ContinuousMul M\ns : Subsemigroup M\n⊢ LE.le s s.topologicalClosure","decl":"@[to_additive]\ntheorem Subsemigroup.le_topologicalClosure (s : Subsemigroup M) : s ≤ s.topologicalClosure :=\n  _root_.subset_closure\n\n"}
{"name":"AddSubsemigroup.le_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddSemigroup M\ninst✝ : ContinuousAdd M\ns : AddSubsemigroup M\n⊢ LE.le s s.topologicalClosure","decl":"@[to_additive]\ntheorem Subsemigroup.le_topologicalClosure (s : Subsemigroup M) : s ≤ s.topologicalClosure :=\n  _root_.subset_closure\n\n"}
{"name":"Subsemigroup.isClosed_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Semigroup M\ninst✝ : ContinuousMul M\ns : Subsemigroup M\n⊢ IsClosed ↑s.topologicalClosure","decl":"@[to_additive]\ntheorem Subsemigroup.isClosed_topologicalClosure (s : Subsemigroup M) :\n    IsClosed (s.topologicalClosure : Set M) := isClosed_closure\n\n"}
{"name":"AddSubsemigroup.isClosed_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddSemigroup M\ninst✝ : ContinuousAdd M\ns : AddSubsemigroup M\n⊢ IsClosed ↑s.topologicalClosure","decl":"@[to_additive]\ntheorem Subsemigroup.isClosed_topologicalClosure (s : Subsemigroup M) :\n    IsClosed (s.topologicalClosure : Set M) := isClosed_closure\n\n"}
{"name":"AddSubsemigroup.topologicalClosure_minimal","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddSemigroup M\ninst✝ : ContinuousAdd M\ns t : AddSubsemigroup M\nh : LE.le s t\nht : IsClosed ↑t\n⊢ LE.le s.topologicalClosure t","decl":"@[to_additive]\ntheorem Subsemigroup.topologicalClosure_minimal (s : Subsemigroup M) {t : Subsemigroup M}\n    (h : s ≤ t) (ht : IsClosed (t : Set M)) : s.topologicalClosure ≤ t := closure_minimal h ht\n\n"}
{"name":"Subsemigroup.topologicalClosure_minimal","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Semigroup M\ninst✝ : ContinuousMul M\ns t : Subsemigroup M\nh : LE.le s t\nht : IsClosed ↑t\n⊢ LE.le s.topologicalClosure t","decl":"@[to_additive]\ntheorem Subsemigroup.topologicalClosure_minimal (s : Subsemigroup M) {t : Subsemigroup M}\n    (h : s ≤ t) (ht : IsClosed (t : Set M)) : s.topologicalClosure ≤ t := closure_minimal h ht\n\n"}
{"name":"IsCompact.add","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddSemigroup M\ninst✝ : ContinuousAdd M\ns t : Set M\nhs : IsCompact s\nht : IsCompact t\n⊢ IsCompact (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem IsCompact.mul {s t : Set M} (hs : IsCompact s) (ht : IsCompact t) : IsCompact (s * t) := by\n  rw [← image_mul_prod]\n  exact (hs.prod ht).image continuous_mul\n\n"}
{"name":"IsCompact.mul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Semigroup M\ninst✝ : ContinuousMul M\ns t : Set M\nhs : IsCompact s\nht : IsCompact t\n⊢ IsCompact (HMul.hMul s t)","decl":"@[to_additive]\ntheorem IsCompact.mul {s t : Set M} (hs : IsCompact s) (ht : IsCompact t) : IsCompact (s * t) := by\n  rw [← image_mul_prod]\n  exact (hs.prod ht).image continuous_mul\n\n"}
{"name":"AddSubmonoid.top_closure_add_self_subset","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddMonoid M\ninst✝ : ContinuousAdd M\ns : AddSubmonoid M\n⊢ HasSubset.Subset (HAdd.hAdd (closure ↑s) (closure ↑s)) (closure ↑s)","decl":"@[to_additive]\ntheorem Submonoid.top_closure_mul_self_subset (s : Submonoid M) :\n    _root_.closure (s : Set M) * _root_.closure s ⊆ _root_.closure s :=\n  image2_subset_iff.2 fun _ hx _ hy =>\n    map_mem_closure₂ continuous_mul hx hy fun _ ha _ hb => s.mul_mem ha hb\n\n"}
{"name":"Submonoid.top_closure_mul_self_subset","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\ns : Submonoid M\n⊢ HasSubset.Subset (HMul.hMul (closure ↑s) (closure ↑s)) (closure ↑s)","decl":"@[to_additive]\ntheorem Submonoid.top_closure_mul_self_subset (s : Submonoid M) :\n    _root_.closure (s : Set M) * _root_.closure s ⊆ _root_.closure s :=\n  image2_subset_iff.2 fun _ hx _ hy =>\n    map_mem_closure₂ continuous_mul hx hy fun _ ha _ hb => s.mul_mem ha hb\n\n"}
{"name":"Submonoid.top_closure_mul_self_eq","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\ns : Submonoid M\n⊢ Eq (HMul.hMul (closure ↑s) (closure ↑s)) (closure ↑s)","decl":"@[to_additive]\ntheorem Submonoid.top_closure_mul_self_eq (s : Submonoid M) :\n    _root_.closure (s : Set M) * _root_.closure s = _root_.closure s :=\n  Subset.antisymm s.top_closure_mul_self_subset fun x hx =>\n    ⟨x, hx, 1, _root_.subset_closure s.one_mem, mul_one _⟩\n\n"}
{"name":"AddSubmonoid.top_closure_add_self_eq","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddMonoid M\ninst✝ : ContinuousAdd M\ns : AddSubmonoid M\n⊢ Eq (HAdd.hAdd (closure ↑s) (closure ↑s)) (closure ↑s)","decl":"@[to_additive]\ntheorem Submonoid.top_closure_mul_self_eq (s : Submonoid M) :\n    _root_.closure (s : Set M) * _root_.closure s = _root_.closure s :=\n  Subset.antisymm s.top_closure_mul_self_subset fun x hx =>\n    ⟨x, hx, 1, _root_.subset_closure s.one_mem, mul_one _⟩\n\n"}
{"name":"AddSubmonoid.coe_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddMonoid M\ninst✝ : ContinuousAdd M\ns : AddSubmonoid M\n⊢ Eq (↑s.topologicalClosure) (closure ↑s)","decl":"@[to_additive]\ntheorem Submonoid.coe_topologicalClosure (s : Submonoid M) :\n    (s.topologicalClosure : Set M) = _root_.closure (s : Set M) := rfl\n\n"}
{"name":"Submonoid.coe_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\ns : Submonoid M\n⊢ Eq (↑s.topologicalClosure) (closure ↑s)","decl":"@[to_additive]\ntheorem Submonoid.coe_topologicalClosure (s : Submonoid M) :\n    (s.topologicalClosure : Set M) = _root_.closure (s : Set M) := rfl\n\n"}
{"name":"Submonoid.le_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\ns : Submonoid M\n⊢ LE.le s s.topologicalClosure","decl":"@[to_additive]\ntheorem Submonoid.le_topologicalClosure (s : Submonoid M) : s ≤ s.topologicalClosure :=\n  _root_.subset_closure\n\n"}
{"name":"AddSubmonoid.le_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddMonoid M\ninst✝ : ContinuousAdd M\ns : AddSubmonoid M\n⊢ LE.le s s.topologicalClosure","decl":"@[to_additive]\ntheorem Submonoid.le_topologicalClosure (s : Submonoid M) : s ≤ s.topologicalClosure :=\n  _root_.subset_closure\n\n"}
{"name":"Submonoid.isClosed_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\ns : Submonoid M\n⊢ IsClosed ↑s.topologicalClosure","decl":"@[to_additive]\ntheorem Submonoid.isClosed_topologicalClosure (s : Submonoid M) :\n    IsClosed (s.topologicalClosure : Set M) := isClosed_closure\n\n"}
{"name":"AddSubmonoid.isClosed_topologicalClosure","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddMonoid M\ninst✝ : ContinuousAdd M\ns : AddSubmonoid M\n⊢ IsClosed ↑s.topologicalClosure","decl":"@[to_additive]\ntheorem Submonoid.isClosed_topologicalClosure (s : Submonoid M) :\n    IsClosed (s.topologicalClosure : Set M) := isClosed_closure\n\n"}
{"name":"Submonoid.topologicalClosure_minimal","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\ns t : Submonoid M\nh : LE.le s t\nht : IsClosed ↑t\n⊢ LE.le s.topologicalClosure t","decl":"@[to_additive]\ntheorem Submonoid.topologicalClosure_minimal (s : Submonoid M) {t : Submonoid M} (h : s ≤ t)\n    (ht : IsClosed (t : Set M)) : s.topologicalClosure ≤ t := closure_minimal h ht\n\n"}
{"name":"AddSubmonoid.topologicalClosure_minimal","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddMonoid M\ninst✝ : ContinuousAdd M\ns t : AddSubmonoid M\nh : LE.le s t\nht : IsClosed ↑t\n⊢ LE.le s.topologicalClosure t","decl":"@[to_additive]\ntheorem Submonoid.topologicalClosure_minimal (s : Submonoid M) {t : Submonoid M} (h : s ≤ t)\n    (ht : IsClosed (t : Set M)) : s.topologicalClosure ≤ t := closure_minimal h ht\n\n"}
{"name":"exists_nhds_one_split4","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\nu : Set M\nhu : Membership.mem (nhds 1) u\n⊢ Exists fun V => And (Membership.mem (nhds 1) V) (∀ {v w s t : M}, Membership.mem V v → Membership.mem V w → Membership.mem V s → Membership.mem V t → Membership.mem u (HMul.hMul (HMul.hMul (HMul.hMul v w) s) t))","decl":"@[to_additive exists_nhds_zero_quarter]\ntheorem exists_nhds_one_split4 {u : Set M} (hu : u ∈ 𝓝 (1 : M)) :\n    ∃ V ∈ 𝓝 (1 : M), ∀ {v w s t}, v ∈ V → w ∈ V → s ∈ V → t ∈ V → v * w * s * t ∈ u := by\n  rcases exists_nhds_one_split hu with ⟨W, W1, h⟩\n  rcases exists_nhds_one_split W1 with ⟨V, V1, h'⟩\n  use V, V1\n  intro v w s t v_in w_in s_in t_in\n  simpa only [mul_assoc] using h _ (h' v v_in w w_in) _ (h' s s_in t t_in)\n\n"}
{"name":"exists_nhds_zero_quarter","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddMonoid M\ninst✝ : ContinuousAdd M\nu : Set M\nhu : Membership.mem (nhds 0) u\n⊢ Exists fun V => And (Membership.mem (nhds 0) V) (∀ {v w s t : M}, Membership.mem V v → Membership.mem V w → Membership.mem V s → Membership.mem V t → Membership.mem u (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd v w) s) t))","decl":"@[to_additive exists_nhds_zero_quarter]\ntheorem exists_nhds_one_split4 {u : Set M} (hu : u ∈ 𝓝 (1 : M)) :\n    ∃ V ∈ 𝓝 (1 : M), ∀ {v w s t}, v ∈ V → w ∈ V → s ∈ V → t ∈ V → v * w * s * t ∈ u := by\n  rcases exists_nhds_one_split hu with ⟨W, W1, h⟩\n  rcases exists_nhds_one_split W1 with ⟨V, V1, h'⟩\n  use V, V1\n  intro v w s t v_in w_in s_in t_in\n  simpa only [mul_assoc] using h _ (h' v v_in w w_in) _ (h' s s_in t t_in)\n\n"}
{"name":"tendsto_list_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nα : Type u_2\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\nf : ι → α → M\nx : Filter α\na : ι → M\nl : List ι\na✝ : ∀ (i : ι), Membership.mem l i → Filter.Tendsto (f i) x (nhds (a i))\n⊢ Filter.Tendsto (fun b => (List.map (fun c => f c b) l).prod) x (nhds (List.map a l).prod)","decl":"@[to_additive]\ntheorem tendsto_list_prod {f : ι → α → M} {x : Filter α} {a : ι → M} :\n    ∀ l : List ι,\n      (∀ i ∈ l, Tendsto (f i) x (𝓝 (a i))) →\n        Tendsto (fun b => (l.map fun c => f c b).prod) x (𝓝 (l.map a).prod)\n  | [], _ => by simp [tendsto_const_nhds]\n  | f::l, h => by\n    simp only [List.map_cons, List.prod_cons]\n    exact\n      (h f (List.mem_cons_self _ _)).mul\n        (tendsto_list_prod l fun c hc => h c (List.mem_cons_of_mem _ hc))\n\n"}
{"name":"tendsto_list_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nα : Type u_2\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddMonoid M\ninst✝ : ContinuousAdd M\nf : ι → α → M\nx : Filter α\na : ι → M\nl : List ι\na✝ : ∀ (i : ι), Membership.mem l i → Filter.Tendsto (f i) x (nhds (a i))\n⊢ Filter.Tendsto (fun b => (List.map (fun c => f c b) l).sum) x (nhds (List.map a l).sum)","decl":"@[to_additive]\ntheorem tendsto_list_prod {f : ι → α → M} {x : Filter α} {a : ι → M} :\n    ∀ l : List ι,\n      (∀ i ∈ l, Tendsto (f i) x (𝓝 (a i))) →\n        Tendsto (fun b => (l.map fun c => f c b).prod) x (𝓝 (l.map a).prod)\n  | [], _ => by simp [tendsto_const_nhds]\n  | f::l, h => by\n    simp only [List.map_cons, List.prod_cons]\n    exact\n      (h f (List.mem_cons_self _ _)).mul\n        (tendsto_list_prod l fun c hc => h c (List.mem_cons_of_mem _ hc))\n\n"}
{"name":"continuous_list_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nM : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\nf : ι → X → M\nl : List ι\nh : ∀ (i : ι), Membership.mem l i → Continuous (f i)\n⊢ Continuous fun a => (List.map (fun i => f i a) l).prod","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_list_prod {f : ι → X → M} (l : List ι) (h : ∀ i ∈ l, Continuous (f i)) :\n    Continuous fun a => (l.map fun i => f i a).prod :=\n  continuous_iff_continuousAt.2 fun x =>\n    tendsto_list_prod l fun c hc => continuous_iff_continuousAt.1 (h c hc) x\n\n"}
{"name":"continuous_list_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nM : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : AddMonoid M\ninst✝ : ContinuousAdd M\nf : ι → X → M\nl : List ι\nh : ∀ (i : ι), Membership.mem l i → Continuous (f i)\n⊢ Continuous fun a => (List.map (fun i => f i a) l).sum","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_list_prod {f : ι → X → M} (l : List ι) (h : ∀ i ∈ l, Continuous (f i)) :\n    Continuous fun a => (l.map fun i => f i a).prod :=\n  continuous_iff_continuousAt.2 fun x =>\n    tendsto_list_prod l fun c hc => continuous_iff_continuousAt.1 (h c hc) x\n\n"}
{"name":"continuousOn_list_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nM : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\nf : ι → X → M\nl : List ι\nt : Set X\nh : ∀ (i : ι), Membership.mem l i → ContinuousOn (f i) t\n⊢ ContinuousOn (fun a => (List.map (fun i => f i a) l).prod) t","decl":"@[to_additive]\ntheorem continuousOn_list_prod {f : ι → X → M} (l : List ι) {t : Set X}\n    (h : ∀ i ∈ l, ContinuousOn (f i) t) :\n    ContinuousOn (fun a => (l.map fun i => f i a).prod) t := by\n  intro x hx\n  rw [continuousWithinAt_iff_continuousAt_restrict _ hx]\n  refine tendsto_list_prod _ fun i hi => ?_\n  specialize h i hi x hx\n  rw [continuousWithinAt_iff_continuousAt_restrict _ hx] at h\n  exact h\n\n"}
{"name":"continuousOn_list_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nM : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : AddMonoid M\ninst✝ : ContinuousAdd M\nf : ι → X → M\nl : List ι\nt : Set X\nh : ∀ (i : ι), Membership.mem l i → ContinuousOn (f i) t\n⊢ ContinuousOn (fun a => (List.map (fun i => f i a) l).sum) t","decl":"@[to_additive]\ntheorem continuousOn_list_prod {f : ι → X → M} (l : List ι) {t : Set X}\n    (h : ∀ i ∈ l, ContinuousOn (f i) t) :\n    ContinuousOn (fun a => (l.map fun i => f i a).prod) t := by\n  intro x hx\n  rw [continuousWithinAt_iff_continuousAt_restrict _ hx]\n  refine tendsto_list_prod _ fun i hi => ?_\n  specialize h i hi x hx\n  rw [continuousWithinAt_iff_continuousAt_restrict _ hx] at h\n  exact h\n\n"}
{"name":"continuous_nsmul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddMonoid M\ninst✝ : ContinuousAdd M\nn : Nat\n⊢ Continuous fun a => HSMul.hSMul n a","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_pow : ∀ n : ℕ, Continuous fun a : M => a ^ n\n  | 0 => by simpa using continuous_const\n  | k + 1 => by\n    simp only [pow_succ']\n    exact continuous_id.mul (continuous_pow _)\n\n"}
{"name":"continuous_pow","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\nn : Nat\n⊢ Continuous fun a => HPow.hPow a n","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_pow : ∀ n : ℕ, Continuous fun a : M => a ^ n\n  | 0 => by simpa using continuous_const\n  | k + 1 => by\n    simp only [pow_succ']\n    exact continuous_id.mul (continuous_pow _)\n\n"}
{"name":"AddMonoid.continuousConstSMul_nat","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"A : Type u_6\ninst✝² : AddMonoid A\ninst✝¹ : TopologicalSpace A\ninst✝ : ContinuousAdd A\n⊢ ContinuousConstSMul Nat A","decl":"instance AddMonoid.continuousConstSMul_nat {A} [AddMonoid A] [TopologicalSpace A]\n    [ContinuousAdd A] : ContinuousConstSMul ℕ A :=\n  ⟨continuous_nsmul⟩\n\n"}
{"name":"AddMonoid.continuousSMul_nat","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"A : Type u_6\ninst✝² : AddMonoid A\ninst✝¹ : TopologicalSpace A\ninst✝ : ContinuousAdd A\n⊢ ContinuousSMul Nat A","decl":"instance AddMonoid.continuousSMul_nat {A} [AddMonoid A] [TopologicalSpace A]\n    [ContinuousAdd A] : ContinuousSMul ℕ A :=\n  ⟨continuous_prod_of_discrete_left.mpr continuous_nsmul⟩\n\n-- We register `Continuous.pow` as a `continuity` lemma with low penalty (so\n-- `continuity` will try it before other `continuity` lemmas). This is a\n-- workaround for goals of the form `Continuous fun x => x ^ 2`, where\n-- `continuity` applies `Continuous.mul` since the goal is defeq to\n-- `Continuous fun x => x * x`.\n--\n-- To properly fix this, we should make sure that `continuity` applies its\n-- lemmas with reducible transparency, preventing the unfolding of `^`. But this\n-- is quite an invasive change.\n"}
{"name":"Continuous.pow","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\nf : X → M\nh : Continuous f\nn : Nat\n⊢ Continuous fun b => HPow.hPow (f b) n","decl":"@[to_additive (attr := aesop safe -100 (rule_sets := [Continuous]), fun_prop)]\ntheorem Continuous.pow {f : X → M} (h : Continuous f) (n : ℕ) : Continuous fun b => f b ^ n :=\n  (continuous_pow n).comp h\n\n"}
{"name":"Continuous.nsmul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : AddMonoid M\ninst✝ : ContinuousAdd M\nf : X → M\nh : Continuous f\nn : Nat\n⊢ Continuous fun b => HSMul.hSMul n (f b)","decl":"@[to_additive (attr := aesop safe -100 (rule_sets := [Continuous]), fun_prop)]\ntheorem Continuous.pow {f : X → M} (h : Continuous f) (n : ℕ) : Continuous fun b => f b ^ n :=\n  (continuous_pow n).comp h\n\n"}
{"name":"continuousOn_pow","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\ns : Set M\nn : Nat\n⊢ ContinuousOn (fun x => HPow.hPow x n) s","decl":"@[to_additive]\ntheorem continuousOn_pow {s : Set M} (n : ℕ) : ContinuousOn (fun (x : M) => x ^ n) s :=\n  (continuous_pow n).continuousOn\n\n"}
{"name":"continuousOn_nsmul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddMonoid M\ninst✝ : ContinuousAdd M\ns : Set M\nn : Nat\n⊢ ContinuousOn (fun x => HSMul.hSMul n x) s","decl":"@[to_additive]\ntheorem continuousOn_pow {s : Set M} (n : ℕ) : ContinuousOn (fun (x : M) => x ^ n) s :=\n  (continuous_pow n).continuousOn\n\n"}
{"name":"continuousAt_nsmul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddMonoid M\ninst✝ : ContinuousAdd M\nx : M\nn : Nat\n⊢ ContinuousAt (fun x => HSMul.hSMul n x) x","decl":"@[to_additive]\ntheorem continuousAt_pow (x : M) (n : ℕ) : ContinuousAt (fun (x : M) => x ^ n) x :=\n  (continuous_pow n).continuousAt\n\n"}
{"name":"continuousAt_pow","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\nx : M\nn : Nat\n⊢ ContinuousAt (fun x => HPow.hPow x n) x","decl":"@[to_additive]\ntheorem continuousAt_pow (x : M) (n : ℕ) : ContinuousAt (fun (x : M) => x ^ n) x :=\n  (continuous_pow n).continuousAt\n\n"}
{"name":"Filter.Tendsto.nsmul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddMonoid M\ninst✝ : ContinuousAdd M\nl : Filter α\nf : α → M\nx : M\nhf : Filter.Tendsto f l (nhds x)\nn : Nat\n⊢ Filter.Tendsto (fun x => HSMul.hSMul n (f x)) l (nhds (HSMul.hSMul n x))","decl":"@[to_additive]\ntheorem Filter.Tendsto.pow {l : Filter α} {f : α → M} {x : M} (hf : Tendsto f l (𝓝 x)) (n : ℕ) :\n    Tendsto (fun x => f x ^ n) l (𝓝 (x ^ n)) :=\n  (continuousAt_pow _ _).tendsto.comp hf\n\n"}
{"name":"Filter.Tendsto.pow","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\nl : Filter α\nf : α → M\nx : M\nhf : Filter.Tendsto f l (nhds x)\nn : Nat\n⊢ Filter.Tendsto (fun x => HPow.hPow (f x) n) l (nhds (HPow.hPow x n))","decl":"@[to_additive]\ntheorem Filter.Tendsto.pow {l : Filter α} {f : α → M} {x : M} (hf : Tendsto f l (𝓝 x)) (n : ℕ) :\n    Tendsto (fun x => f x ^ n) l (𝓝 (x ^ n)) :=\n  (continuousAt_pow _ _).tendsto.comp hf\n\n"}
{"name":"ContinuousWithinAt.pow","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\nf : X → M\nx : X\ns : Set X\nhf : ContinuousWithinAt f s x\nn : Nat\n⊢ ContinuousWithinAt (fun x => HPow.hPow (f x) n) s x","decl":"@[to_additive]\ntheorem ContinuousWithinAt.pow {f : X → M} {x : X} {s : Set X} (hf : ContinuousWithinAt f s x)\n    (n : ℕ) : ContinuousWithinAt (fun x => f x ^ n) s x :=\n  Filter.Tendsto.pow hf n\n\n"}
{"name":"ContinuousWithinAt.nsmul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : AddMonoid M\ninst✝ : ContinuousAdd M\nf : X → M\nx : X\ns : Set X\nhf : ContinuousWithinAt f s x\nn : Nat\n⊢ ContinuousWithinAt (fun x => HSMul.hSMul n (f x)) s x","decl":"@[to_additive]\ntheorem ContinuousWithinAt.pow {f : X → M} {x : X} {s : Set X} (hf : ContinuousWithinAt f s x)\n    (n : ℕ) : ContinuousWithinAt (fun x => f x ^ n) s x :=\n  Filter.Tendsto.pow hf n\n\n"}
{"name":"ContinuousAt.pow","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\nf : X → M\nx : X\nhf : ContinuousAt f x\nn : Nat\n⊢ ContinuousAt (fun x => HPow.hPow (f x) n) x","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousAt.pow {f : X → M} {x : X} (hf : ContinuousAt f x) (n : ℕ) :\n    ContinuousAt (fun x => f x ^ n) x :=\n  Filter.Tendsto.pow hf n\n\n"}
{"name":"ContinuousAt.nsmul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : AddMonoid M\ninst✝ : ContinuousAdd M\nf : X → M\nx : X\nhf : ContinuousAt f x\nn : Nat\n⊢ ContinuousAt (fun x => HSMul.hSMul n (f x)) x","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousAt.pow {f : X → M} {x : X} (hf : ContinuousAt f x) (n : ℕ) :\n    ContinuousAt (fun x => f x ^ n) x :=\n  Filter.Tendsto.pow hf n\n\n"}
{"name":"ContinuousOn.nsmul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : AddMonoid M\ninst✝ : ContinuousAdd M\nf : X → M\ns : Set X\nhf : ContinuousOn f s\nn : Nat\n⊢ ContinuousOn (fun x => HSMul.hSMul n (f x)) s","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousOn.pow {f : X → M} {s : Set X} (hf : ContinuousOn f s) (n : ℕ) :\n    ContinuousOn (fun x => f x ^ n) s := fun x hx => (hf x hx).pow n\n\n"}
{"name":"ContinuousOn.pow","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\nf : X → M\ns : Set X\nhf : ContinuousOn f s\nn : Nat\n⊢ ContinuousOn (fun x => HPow.hPow (f x) n) s","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousOn.pow {f : X → M} {s : Set X} (hf : ContinuousOn f s) (n : ℕ) :\n    ContinuousOn (fun x => f x ^ n) s := fun x hx => (hf x hx).pow n\n\n"}
{"name":"Filter.tendsto_cocompact_mul_left","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\na b : M\nha : Eq (HMul.hMul b a) 1\n⊢ Filter.Tendsto (fun x => HMul.hMul a x) (Filter.cocompact M) (Filter.cocompact M)","decl":"/-- Left-multiplication by a left-invertible element of a topological monoid is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem Filter.tendsto_cocompact_mul_left {a b : M} (ha : b * a = 1) :\n    Filter.Tendsto (fun x : M => a * x) (Filter.cocompact M) (Filter.cocompact M) := by\n  refine Filter.Tendsto.of_tendsto_comp ?_ (Filter.comap_cocompact_le (continuous_mul_left b))\n  convert Filter.tendsto_id\n  ext x\n  simp [← mul_assoc, ha]\n\n"}
{"name":"Filter.tendsto_cocompact_mul_right","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\na b : M\nha : Eq (HMul.hMul a b) 1\n⊢ Filter.Tendsto (fun x => HMul.hMul x a) (Filter.cocompact M) (Filter.cocompact M)","decl":"/-- Right-multiplication by a right-invertible element of a topological monoid is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem Filter.tendsto_cocompact_mul_right {a b : M} (ha : a * b = 1) :\n    Filter.Tendsto (fun x : M => x * a) (Filter.cocompact M) (Filter.cocompact M) := by\n  refine Filter.Tendsto.of_tendsto_comp ?_ (Filter.comap_cocompact_le (continuous_mul_right b))\n  simp only [comp_mul_right, ha, mul_one]\n  exact Filter.tendsto_id\n  -- Porting note: changed proof\n\n"}
{"name":"VAddAssocClass.continuousConstVAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"R : Type u_6\nA : Type u_7\ninst✝⁴ : AddMonoid A\ninst✝³ : VAdd R A\ninst✝² : VAddAssocClass R A A\ninst✝¹ : TopologicalSpace A\ninst✝ : ContinuousAdd A\n⊢ ContinuousConstVAdd R A","decl":"/-- If `R` acts on `A` via `A`, then continuous multiplication implies continuous scalar\nmultiplication by constants.\n\nNotably, this instances applies when `R = A`, or when `[Algebra R A]` is available. -/\n@[to_additive \"If `R` acts on `A` via `A`, then continuous addition implies\ncontinuous affine addition by constants.\"]\ninstance (priority := 100) IsScalarTower.continuousConstSMul {R A : Type*} [Monoid A] [SMul R A]\n    [IsScalarTower R A A] [TopologicalSpace A] [ContinuousMul A] : ContinuousConstSMul R A where\n  continuous_const_smul q := by\n    simp (config := { singlePass := true }) only [← smul_one_mul q (_ : A)]\n    exact continuous_const.mul continuous_id\n\n"}
{"name":"IsScalarTower.continuousConstSMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"R : Type u_6\nA : Type u_7\ninst✝⁴ : Monoid A\ninst✝³ : SMul R A\ninst✝² : IsScalarTower R A A\ninst✝¹ : TopologicalSpace A\ninst✝ : ContinuousMul A\n⊢ ContinuousConstSMul R A","decl":"/-- If `R` acts on `A` via `A`, then continuous multiplication implies continuous scalar\nmultiplication by constants.\n\nNotably, this instances applies when `R = A`, or when `[Algebra R A]` is available. -/\n@[to_additive \"If `R` acts on `A` via `A`, then continuous addition implies\ncontinuous affine addition by constants.\"]\ninstance (priority := 100) IsScalarTower.continuousConstSMul {R A : Type*} [Monoid A] [SMul R A]\n    [IsScalarTower R A A] [TopologicalSpace A] [ContinuousMul A] : ContinuousConstSMul R A where\n  continuous_const_smul q := by\n    simp (config := { singlePass := true }) only [← smul_one_mul q (_ : A)]\n    exact continuous_const.mul continuous_id\n\n"}
{"name":"VAddCommClass.continuousConstVAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"R : Type u_6\nA : Type u_7\ninst✝⁴ : AddMonoid A\ninst✝³ : VAdd R A\ninst✝² : VAddCommClass R A A\ninst✝¹ : TopologicalSpace A\ninst✝ : ContinuousAdd A\n⊢ ContinuousConstVAdd R A","decl":"/-- If the action of `R` on `A` commutes with left-multiplication, then continuous multiplication\nimplies continuous scalar multiplication by constants.\n\nNotably, this instances applies when `R = Aᵐᵒᵖ`. -/\n@[to_additive \"If the action of `R` on `A` commutes with left-addition, then\ncontinuous addition implies continuous affine addition by constants.\n\nNotably, this instances applies when `R = Aᵃᵒᵖ`.\"]\ninstance (priority := 100) SMulCommClass.continuousConstSMul {R A : Type*} [Monoid A] [SMul R A]\n    [SMulCommClass R A A] [TopologicalSpace A] [ContinuousMul A] : ContinuousConstSMul R A where\n  continuous_const_smul q := by\n    simp (config := { singlePass := true }) only [← mul_smul_one q (_ : A)]\n    exact continuous_id.mul continuous_const\n\n"}
{"name":"SMulCommClass.continuousConstSMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"R : Type u_6\nA : Type u_7\ninst✝⁴ : Monoid A\ninst✝³ : SMul R A\ninst✝² : SMulCommClass R A A\ninst✝¹ : TopologicalSpace A\ninst✝ : ContinuousMul A\n⊢ ContinuousConstSMul R A","decl":"/-- If the action of `R` on `A` commutes with left-multiplication, then continuous multiplication\nimplies continuous scalar multiplication by constants.\n\nNotably, this instances applies when `R = Aᵐᵒᵖ`. -/\n@[to_additive \"If the action of `R` on `A` commutes with left-addition, then\ncontinuous addition implies continuous affine addition by constants.\n\nNotably, this instances applies when `R = Aᵃᵒᵖ`.\"]\ninstance (priority := 100) SMulCommClass.continuousConstSMul {R A : Type*} [Monoid A] [SMul R A]\n    [SMulCommClass R A A] [TopologicalSpace A] [ContinuousMul A] : ContinuousConstSMul R A where\n  continuous_const_smul q := by\n    simp (config := { singlePass := true }) only [← mul_smul_one q (_ : A)]\n    exact continuous_id.mul continuous_const\n\n"}
{"name":"MulOpposite.instContinuousMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : Mul α\ninst✝ : ContinuousMul α\n⊢ ContinuousMul (MulOpposite α)","decl":"/-- If multiplication is continuous in `α`, then it also is in `αᵐᵒᵖ`. -/\n@[to_additive \"If addition is continuous in `α`, then it also is in `αᵃᵒᵖ`.\"]\ninstance [TopologicalSpace α] [Mul α] [ContinuousMul α] : ContinuousMul αᵐᵒᵖ :=\n  ⟨continuous_op.comp (continuous_unop.snd'.mul continuous_unop.fst')⟩\n\n"}
{"name":"AddOpposite.instContinuousAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : Add α\ninst✝ : ContinuousAdd α\n⊢ ContinuousAdd (AddOpposite α)","decl":"/-- If multiplication is continuous in `α`, then it also is in `αᵐᵒᵖ`. -/\n@[to_additive \"If addition is continuous in `α`, then it also is in `αᵃᵒᵖ`.\"]\ninstance [TopologicalSpace α] [Mul α] [ContinuousMul α] : ContinuousMul αᵐᵒᵖ :=\n  ⟨continuous_op.comp (continuous_unop.snd'.mul continuous_unop.fst')⟩\n\n"}
{"name":"AddUnits.instContinuousAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : AddMonoid α\ninst✝ : ContinuousAdd α\n⊢ ContinuousAdd (AddUnits α)","decl":"/-- If multiplication on a monoid is continuous, then multiplication on the units of the monoid,\nwith respect to the induced topology, is continuous.\n\nInversion is also continuous, but we register this in a later file, `Topology.Algebra.Group`,\nbecause the predicate `ContinuousInv` has not yet been defined. -/\n@[to_additive \"If addition on an additive monoid is continuous, then addition on the additive units\nof the monoid, with respect to the induced topology, is continuous.\n\nNegation is also continuous, but we register this in a later file, `Topology.Algebra.Group`, because\nthe predicate `ContinuousNeg` has not yet been defined.\"]\ninstance : ContinuousMul αˣ := isInducing_embedProduct.continuousMul (embedProduct α)\n\n"}
{"name":"Units.instContinuousMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"α : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : Monoid α\ninst✝ : ContinuousMul α\n⊢ ContinuousMul (Units α)","decl":"/-- If multiplication on a monoid is continuous, then multiplication on the units of the monoid,\nwith respect to the induced topology, is continuous.\n\nInversion is also continuous, but we register this in a later file, `Topology.Algebra.Group`,\nbecause the predicate `ContinuousInv` has not yet been defined. -/\n@[to_additive \"If addition on an additive monoid is continuous, then addition on the additive units\nof the monoid, with respect to the induced topology, is continuous.\n\nNegation is also continuous, but we register this in a later file, `Topology.Algebra.Group`, because\nthe predicate `ContinuousNeg` has not yet been defined.\"]\ninstance : ContinuousMul αˣ := isInducing_embedProduct.continuousMul (embedProduct α)\n\n"}
{"name":"Continuous.units_map","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝³ : Monoid M\ninst✝² : Monoid N\ninst✝¹ : TopologicalSpace M\ninst✝ : TopologicalSpace N\nf : MonoidHom M N\nhf : Continuous ⇑f\n⊢ Continuous ⇑(Units.map f)","decl":"@[to_additive]\ntheorem Continuous.units_map [Monoid M] [Monoid N] [TopologicalSpace M] [TopologicalSpace N]\n    (f : M →* N) (hf : Continuous f) : Continuous (Units.map f) :=\n  Units.continuous_iff.2 ⟨hf.comp Units.continuous_val, hf.comp Units.continuous_coe_inv⟩\n\n"}
{"name":"Continuous.addUnits_map","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝³ : AddMonoid M\ninst✝² : AddMonoid N\ninst✝¹ : TopologicalSpace M\ninst✝ : TopologicalSpace N\nf : AddMonoidHom M N\nhf : Continuous ⇑f\n⊢ Continuous ⇑(AddUnits.map f)","decl":"@[to_additive]\ntheorem Continuous.units_map [Monoid M] [Monoid N] [TopologicalSpace M] [TopologicalSpace N]\n    (f : M →* N) (hf : Continuous f) : Continuous (Units.map f) :=\n  Units.continuous_iff.2 ⟨hf.comp Units.continuous_val, hf.comp Units.continuous_coe_inv⟩\n\n"}
{"name":"Submonoid.mem_nhds_one","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : CommMonoid M\nS : Submonoid M\noS : IsOpen ↑S\n⊢ Membership.mem (nhds 1) ↑S","decl":"@[to_additive]\ntheorem Submonoid.mem_nhds_one (S : Submonoid M) (oS : IsOpen (S : Set M)) :\n    (S : Set M) ∈ 𝓝 (1 : M) :=\n  IsOpen.mem_nhds oS S.one_mem\n\n"}
{"name":"AddSubmonoid.mem_nhds_zero","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\noS : IsOpen ↑S\n⊢ Membership.mem (nhds 0) ↑S","decl":"@[to_additive]\ntheorem Submonoid.mem_nhds_one (S : Submonoid M) (oS : IsOpen (S : Set M)) :\n    (S : Set M) ∈ 𝓝 (1 : M) :=\n  IsOpen.mem_nhds oS S.one_mem\n\n"}
{"name":"tendsto_multiset_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nα : Type u_2\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : CommMonoid M\ninst✝ : ContinuousMul M\nf : ι → α → M\nx : Filter α\na : ι → M\ns : Multiset ι\na✝ : ∀ (i : ι), Membership.mem s i → Filter.Tendsto (f i) x (nhds (a i))\n⊢ Filter.Tendsto (fun b => (Multiset.map (fun c => f c b) s).prod) x (nhds (Multiset.map a s).prod)","decl":"@[to_additive]\ntheorem tendsto_multiset_prod {f : ι → α → M} {x : Filter α} {a : ι → M} (s : Multiset ι) :\n    (∀ i ∈ s, Tendsto (f i) x (𝓝 (a i))) →\n      Tendsto (fun b => (s.map fun c => f c b).prod) x (𝓝 (s.map a).prod) := by\n  rcases s with ⟨l⟩\n  simpa using tendsto_list_prod l\n\n"}
{"name":"tendsto_multiset_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nα : Type u_2\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid M\ninst✝ : ContinuousAdd M\nf : ι → α → M\nx : Filter α\na : ι → M\ns : Multiset ι\na✝ : ∀ (i : ι), Membership.mem s i → Filter.Tendsto (f i) x (nhds (a i))\n⊢ Filter.Tendsto (fun b => (Multiset.map (fun c => f c b) s).sum) x (nhds (Multiset.map a s).sum)","decl":"@[to_additive]\ntheorem tendsto_multiset_prod {f : ι → α → M} {x : Filter α} {a : ι → M} (s : Multiset ι) :\n    (∀ i ∈ s, Tendsto (f i) x (𝓝 (a i))) →\n      Tendsto (fun b => (s.map fun c => f c b).prod) x (𝓝 (s.map a).prod) := by\n  rcases s with ⟨l⟩\n  simpa using tendsto_list_prod l\n\n"}
{"name":"tendsto_finset_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nα : Type u_2\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid M\ninst✝ : ContinuousAdd M\nf : ι → α → M\nx : Filter α\na : ι → M\ns : Finset ι\na✝ : ∀ (i : ι), Membership.mem s i → Filter.Tendsto (f i) x (nhds (a i))\n⊢ Filter.Tendsto (fun b => s.sum fun c => f c b) x (nhds (s.sum fun c => a c))","decl":"@[to_additive]\ntheorem tendsto_finset_prod {f : ι → α → M} {x : Filter α} {a : ι → M} (s : Finset ι) :\n    (∀ i ∈ s, Tendsto (f i) x (𝓝 (a i))) →\n      Tendsto (fun b => ∏ c ∈ s, f c b) x (𝓝 (∏ c ∈ s, a c)) :=\n  tendsto_multiset_prod _\n\n"}
{"name":"tendsto_finset_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nα : Type u_2\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : CommMonoid M\ninst✝ : ContinuousMul M\nf : ι → α → M\nx : Filter α\na : ι → M\ns : Finset ι\na✝ : ∀ (i : ι), Membership.mem s i → Filter.Tendsto (f i) x (nhds (a i))\n⊢ Filter.Tendsto (fun b => s.prod fun c => f c b) x (nhds (s.prod fun c => a c))","decl":"@[to_additive]\ntheorem tendsto_finset_prod {f : ι → α → M} {x : Filter α} {a : ι → M} (s : Finset ι) :\n    (∀ i ∈ s, Tendsto (f i) x (𝓝 (a i))) →\n      Tendsto (fun b => ∏ c ∈ s, f c b) x (𝓝 (∏ c ∈ s, a c)) :=\n  tendsto_multiset_prod _\n\n"}
{"name":"continuous_multiset_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nM : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid M\ninst✝ : ContinuousAdd M\nf : ι → X → M\ns : Multiset ι\na✝ : ∀ (i : ι), Membership.mem s i → Continuous (f i)\n⊢ Continuous fun a => (Multiset.map (fun i => f i a) s).sum","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_multiset_prod {f : ι → X → M} (s : Multiset ι) :\n    (∀ i ∈ s, Continuous (f i)) → Continuous fun a => (s.map fun i => f i a).prod := by\n  rcases s with ⟨l⟩\n  simpa using continuous_list_prod l\n\n"}
{"name":"continuous_multiset_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nM : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : CommMonoid M\ninst✝ : ContinuousMul M\nf : ι → X → M\ns : Multiset ι\na✝ : ∀ (i : ι), Membership.mem s i → Continuous (f i)\n⊢ Continuous fun a => (Multiset.map (fun i => f i a) s).prod","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_multiset_prod {f : ι → X → M} (s : Multiset ι) :\n    (∀ i ∈ s, Continuous (f i)) → Continuous fun a => (s.map fun i => f i a).prod := by\n  rcases s with ⟨l⟩\n  simpa using continuous_list_prod l\n\n"}
{"name":"continuousOn_multiset_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nM : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid M\ninst✝ : ContinuousAdd M\nf : ι → X → M\ns : Multiset ι\nt : Set X\na✝ : ∀ (i : ι), Membership.mem s i → ContinuousOn (f i) t\n⊢ ContinuousOn (fun a => (Multiset.map (fun i => f i a) s).sum) t","decl":"@[to_additive]\ntheorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :\n    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by\n  rcases s with ⟨l⟩\n  simpa using continuousOn_list_prod l\n\n"}
{"name":"continuousOn_multiset_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nM : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : CommMonoid M\ninst✝ : ContinuousMul M\nf : ι → X → M\ns : Multiset ι\nt : Set X\na✝ : ∀ (i : ι), Membership.mem s i → ContinuousOn (f i) t\n⊢ ContinuousOn (fun a => (Multiset.map (fun i => f i a) s).prod) t","decl":"@[to_additive]\ntheorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :\n    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by\n  rcases s with ⟨l⟩\n  simpa using continuousOn_list_prod l\n\n"}
{"name":"continuous_finset_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nM : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : CommMonoid M\ninst✝ : ContinuousMul M\nf : ι → X → M\ns : Finset ι\na✝ : ∀ (i : ι), Membership.mem s i → Continuous (f i)\n⊢ Continuous fun a => s.prod fun i => f i a","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem continuous_finset_prod {f : ι → X → M} (s : Finset ι) :\n    (∀ i ∈ s, Continuous (f i)) → Continuous fun a => ∏ i ∈ s, f i a :=\n  continuous_multiset_prod _\n\n"}
{"name":"continuous_finset_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nM : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid M\ninst✝ : ContinuousAdd M\nf : ι → X → M\ns : Finset ι\na✝ : ∀ (i : ι), Membership.mem s i → Continuous (f i)\n⊢ Continuous fun a => s.sum fun i => f i a","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem continuous_finset_prod {f : ι → X → M} (s : Finset ι) :\n    (∀ i ∈ s, Continuous (f i)) → Continuous fun a => ∏ i ∈ s, f i a :=\n  continuous_multiset_prod _\n\n"}
{"name":"continuousOn_finset_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nM : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid M\ninst✝ : ContinuousAdd M\nf : ι → X → M\ns : Finset ι\nt : Set X\na✝ : ∀ (i : ι), Membership.mem s i → ContinuousOn (f i) t\n⊢ ContinuousOn (fun a => s.sum fun i => f i a) t","decl":"@[to_additive]\ntheorem continuousOn_finset_prod {f : ι → X → M} (s : Finset ι) {t : Set X} :\n    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => ∏ i ∈ s, f i a) t :=\n  continuousOn_multiset_prod _\n\n"}
{"name":"continuousOn_finset_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nM : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : CommMonoid M\ninst✝ : ContinuousMul M\nf : ι → X → M\ns : Finset ι\nt : Set X\na✝ : ∀ (i : ι), Membership.mem s i → ContinuousOn (f i) t\n⊢ ContinuousOn (fun a => s.prod fun i => f i a) t","decl":"@[to_additive]\ntheorem continuousOn_finset_prod {f : ι → X → M} (s : Finset ι) {t : Set X} :\n    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => ∏ i ∈ s, f i a) t :=\n  continuousOn_multiset_prod _\n\n"}
{"name":"eventuallyEq_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nX : Type u_6\nM : Type u_7\ninst✝ : AddCommMonoid M\ns : Finset ι\nl : Filter X\nf g : ι → X → M\nhs : ∀ (i : ι), Membership.mem s i → l.EventuallyEq (f i) (g i)\n⊢ l.EventuallyEq (s.sum fun i => f i) (s.sum fun i => g i)","decl":"@[to_additive]\ntheorem eventuallyEq_prod {X M : Type*} [CommMonoid M] {s : Finset ι} {l : Filter X}\n    {f g : ι → X → M} (hs : ∀ i ∈ s, f i =ᶠ[l] g i) : ∏ i ∈ s, f i =ᶠ[l] ∏ i ∈ s, g i := by\n  replace hs : ∀ᶠ x in l, ∀ i ∈ s, f i x = g i x := by rwa [eventually_all_finset]\n  filter_upwards [hs] with x hx\n  simp only [Finset.prod_apply, Finset.prod_congr rfl hx]\n\n"}
{"name":"eventuallyEq_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nX : Type u_6\nM : Type u_7\ninst✝ : CommMonoid M\ns : Finset ι\nl : Filter X\nf g : ι → X → M\nhs : ∀ (i : ι), Membership.mem s i → l.EventuallyEq (f i) (g i)\n⊢ l.EventuallyEq (s.prod fun i => f i) (s.prod fun i => g i)","decl":"@[to_additive]\ntheorem eventuallyEq_prod {X M : Type*} [CommMonoid M] {s : Finset ι} {l : Filter X}\n    {f g : ι → X → M} (hs : ∀ i ∈ s, f i =ᶠ[l] g i) : ∏ i ∈ s, f i =ᶠ[l] ∏ i ∈ s, g i := by\n  replace hs : ∀ᶠ x in l, ∀ i ∈ s, f i x = g i x := by rwa [eventually_all_finset]\n  filter_upwards [hs] with x hx\n  simp only [Finset.prod_apply, Finset.prod_congr rfl hx]\n\n"}
{"name":"LocallyFinite.exists_finset_support","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nX : Type u_5\ninst✝¹ : TopologicalSpace X\nM : Type u_6\ninst✝ : AddCommMonoid M\nf : ι → X → M\nhf : LocallyFinite fun i => Function.support (f i)\nx₀ : X\n⊢ Exists fun I => Filter.Eventually (fun x => HasSubset.Subset (Function.support fun i => f i x) ↑I) (nhds x₀)","decl":"@[to_additive]\ntheorem LocallyFinite.exists_finset_mulSupport {M : Type*} [CommMonoid M] {f : ι → X → M}\n    (hf : LocallyFinite fun i => mulSupport <| f i) (x₀ : X) :\n    ∃ I : Finset ι, ∀ᶠ x in 𝓝 x₀, (mulSupport fun i => f i x) ⊆ I := by\n  rcases hf x₀ with ⟨U, hxU, hUf⟩\n  refine ⟨hUf.toFinset, mem_of_superset hxU fun y hy i hi => ?_⟩\n  rw [hUf.coe_toFinset]\n  exact ⟨y, hi, hy⟩\n\n"}
{"name":"LocallyFinite.exists_finset_mulSupport","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nX : Type u_5\ninst✝¹ : TopologicalSpace X\nM : Type u_6\ninst✝ : CommMonoid M\nf : ι → X → M\nhf : LocallyFinite fun i => Function.mulSupport (f i)\nx₀ : X\n⊢ Exists fun I => Filter.Eventually (fun x => HasSubset.Subset (Function.mulSupport fun i => f i x) ↑I) (nhds x₀)","decl":"@[to_additive]\ntheorem LocallyFinite.exists_finset_mulSupport {M : Type*} [CommMonoid M] {f : ι → X → M}\n    (hf : LocallyFinite fun i => mulSupport <| f i) (x₀ : X) :\n    ∃ I : Finset ι, ∀ᶠ x in 𝓝 x₀, (mulSupport fun i => f i x) ⊆ I := by\n  rcases hf x₀ with ⟨U, hxU, hUf⟩\n  refine ⟨hUf.toFinset, mem_of_superset hxU fun y hy i hi => ?_⟩\n  rw [hUf.coe_toFinset]\n  exact ⟨y, hi, hy⟩\n\n"}
{"name":"finprod_eventually_eq_prod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nX : Type u_5\ninst✝¹ : TopologicalSpace X\nM : Type u_6\ninst✝ : CommMonoid M\nf : ι → X → M\nhf : LocallyFinite fun i => Function.mulSupport (f i)\nx : X\n⊢ Exists fun s => Filter.Eventually (fun y => Eq (finprod fun i => f i y) (s.prod fun i => f i y)) (nhds x)","decl":"@[to_additive]\ntheorem finprod_eventually_eq_prod {M : Type*} [CommMonoid M] {f : ι → X → M}\n    (hf : LocallyFinite fun i => mulSupport (f i)) (x : X) :\n    ∃ s : Finset ι, ∀ᶠ y in 𝓝 x, ∏ᶠ i, f i y = ∏ i ∈ s, f i y :=\n  let ⟨I, hI⟩ := hf.exists_finset_mulSupport x\n  ⟨I, hI.mono fun _ hy => finprod_eq_prod_of_mulSupport_subset _ fun _ hi => hy hi⟩\n\n"}
{"name":"finsum_eventually_eq_sum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nX : Type u_5\ninst✝¹ : TopologicalSpace X\nM : Type u_6\ninst✝ : AddCommMonoid M\nf : ι → X → M\nhf : LocallyFinite fun i => Function.support (f i)\nx : X\n⊢ Exists fun s => Filter.Eventually (fun y => Eq (finsum fun i => f i y) (s.sum fun i => f i y)) (nhds x)","decl":"@[to_additive]\ntheorem finprod_eventually_eq_prod {M : Type*} [CommMonoid M] {f : ι → X → M}\n    (hf : LocallyFinite fun i => mulSupport (f i)) (x : X) :\n    ∃ s : Finset ι, ∀ᶠ y in 𝓝 x, ∏ᶠ i, f i y = ∏ i ∈ s, f i y :=\n  let ⟨I, hI⟩ := hf.exists_finset_mulSupport x\n  ⟨I, hI.mono fun _ hy => finprod_eq_prod_of_mulSupport_subset _ fun _ hi => hy hi⟩\n\n"}
{"name":"continuous_finprod","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nM : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : CommMonoid M\ninst✝ : ContinuousMul M\nf : ι → X → M\nhc : ∀ (i : ι), Continuous (f i)\nhf : LocallyFinite fun i => Function.mulSupport (f i)\n⊢ Continuous fun x => finprod fun i => f i x","decl":"@[to_additive]\ntheorem continuous_finprod {f : ι → X → M} (hc : ∀ i, Continuous (f i))\n    (hf : LocallyFinite fun i => mulSupport (f i)) : Continuous fun x => ∏ᶠ i, f i x := by\n  refine continuous_iff_continuousAt.2 fun x => ?_\n  rcases finprod_eventually_eq_prod hf x with ⟨s, hs⟩\n  refine ContinuousAt.congr ?_ (EventuallyEq.symm hs)\n  exact tendsto_finset_prod _ fun i _ => (hc i).continuousAt\n\n"}
{"name":"continuous_finsum","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nM : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid M\ninst✝ : ContinuousAdd M\nf : ι → X → M\nhc : ∀ (i : ι), Continuous (f i)\nhf : LocallyFinite fun i => Function.support (f i)\n⊢ Continuous fun x => finsum fun i => f i x","decl":"@[to_additive]\ntheorem continuous_finprod {f : ι → X → M} (hc : ∀ i, Continuous (f i))\n    (hf : LocallyFinite fun i => mulSupport (f i)) : Continuous fun x => ∏ᶠ i, f i x := by\n  refine continuous_iff_continuousAt.2 fun x => ?_\n  rcases finprod_eventually_eq_prod hf x with ⟨s, hs⟩\n  refine ContinuousAt.congr ?_ (EventuallyEq.symm hs)\n  exact tendsto_finset_prod _ fun i _ => (hc i).continuousAt\n\n"}
{"name":"continuous_finsum_cond","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nM : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid M\ninst✝ : ContinuousAdd M\nf : ι → X → M\np : ι → Prop\nhc : ∀ (i : ι), p i → Continuous (f i)\nhf : LocallyFinite fun i => Function.support (f i)\n⊢ Continuous fun x => finsum fun i => finsum fun x_1 => f i x","decl":"@[to_additive]\ntheorem continuous_finprod_cond {f : ι → X → M} {p : ι → Prop} (hc : ∀ i, p i → Continuous (f i))\n    (hf : LocallyFinite fun i => mulSupport (f i)) :\n    Continuous fun x => ∏ᶠ (i) (_ : p i), f i x := by\n  simp only [← finprod_subtype_eq_finprod_cond]\n  exact continuous_finprod (fun i => hc i i.2) (hf.comp_injective Subtype.coe_injective)\n\n"}
{"name":"continuous_finprod_cond","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"ι : Type u_1\nM : Type u_3\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace M\ninst✝¹ : CommMonoid M\ninst✝ : ContinuousMul M\nf : ι → X → M\np : ι → Prop\nhc : ∀ (i : ι), p i → Continuous (f i)\nhf : LocallyFinite fun i => Function.mulSupport (f i)\n⊢ Continuous fun x => finprod fun i => finprod fun x_1 => f i x","decl":"@[to_additive]\ntheorem continuous_finprod_cond {f : ι → X → M} {p : ι → Prop} (hc : ∀ i, p i → Continuous (f i))\n    (hf : LocallyFinite fun i => mulSupport (f i)) :\n    Continuous fun x => ∏ᶠ (i) (_ : p i), f i x := by\n  simp only [← finprod_subtype_eq_finprod_cond]\n  exact continuous_finprod (fun i => hc i i.2) (hf.comp_injective Subtype.coe_injective)\n\n"}
{"name":"instContinuousAddAdditiveOfContinuousMul","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Mul M\ninst✝ : ContinuousMul M\n⊢ ContinuousAdd (Additive M)","decl":"instance [TopologicalSpace M] [Mul M] [ContinuousMul M] : ContinuousAdd (Additive M) where\n  continuous_add := @continuous_mul M _ _ _\n\n"}
{"name":"instContinuousMulMultiplicativeOfContinuousAdd","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : Add M\ninst✝ : ContinuousAdd M\n⊢ ContinuousMul (Multiplicative M)","decl":"instance [TopologicalSpace M] [Add M] [ContinuousAdd M] : ContinuousMul (Multiplicative M) where\n  continuous_mul := @continuous_add M _ _ _\n\n"}
{"name":"continuousAdd_sInf","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝ : Add M\nts : Set (TopologicalSpace M)\nh : ∀ (t : TopologicalSpace M), Membership.mem ts t → ContinuousAdd M\n⊢ ContinuousAdd M","decl":"@[to_additive]\ntheorem continuousMul_sInf {ts : Set (TopologicalSpace M)}\n    (h : ∀ t ∈ ts, @ContinuousMul M t _) : @ContinuousMul M (sInf ts) _ :=\n  letI := sInf ts\n  { continuous_mul :=\n      continuous_sInf_rng.2 fun t ht =>\n        continuous_sInf_dom₂ ht ht (@ContinuousMul.continuous_mul M t _ (h t ht)) }\n\n"}
{"name":"continuousMul_sInf","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝ : Mul M\nts : Set (TopologicalSpace M)\nh : ∀ (t : TopologicalSpace M), Membership.mem ts t → ContinuousMul M\n⊢ ContinuousMul M","decl":"@[to_additive]\ntheorem continuousMul_sInf {ts : Set (TopologicalSpace M)}\n    (h : ∀ t ∈ ts, @ContinuousMul M t _) : @ContinuousMul M (sInf ts) _ :=\n  letI := sInf ts\n  { continuous_mul :=\n      continuous_sInf_rng.2 fun t ht =>\n        continuous_sInf_dom₂ ht ht (@ContinuousMul.continuous_mul M t _ (h t ht)) }\n\n"}
{"name":"continuousMul_iInf","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nι' : Sort u_6\ninst✝ : Mul M\nts : ι' → TopologicalSpace M\nh' : ∀ (i : ι'), ContinuousMul M\n⊢ ContinuousMul M","decl":"@[to_additive]\ntheorem continuousMul_iInf {ts : ι' → TopologicalSpace M}\n    (h' : ∀ i, @ContinuousMul M (ts i) _) : @ContinuousMul M (⨅ i, ts i) _ := by\n  rw [← sInf_range]\n  exact continuousMul_sInf (Set.forall_mem_range.mpr h')\n\n"}
{"name":"continuousAdd_iInf","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\nι' : Sort u_6\ninst✝ : Add M\nts : ι' → TopologicalSpace M\nh' : ∀ (i : ι'), ContinuousAdd M\n⊢ ContinuousAdd M","decl":"@[to_additive]\ntheorem continuousMul_iInf {ts : ι' → TopologicalSpace M}\n    (h' : ∀ i, @ContinuousMul M (ts i) _) : @ContinuousMul M (⨅ i, ts i) _ := by\n  rw [← sInf_range]\n  exact continuousMul_sInf (Set.forall_mem_range.mpr h')\n\n"}
{"name":"continuousAdd_inf","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝ : Add M\nt₁ t₂ : TopologicalSpace M\nh₁ : ContinuousAdd M\nh₂ : ContinuousAdd M\n⊢ ContinuousAdd M","decl":"@[to_additive]\ntheorem continuousMul_inf {t₁ t₂ : TopologicalSpace M} (h₁ : @ContinuousMul M t₁ _)\n    (h₂ : @ContinuousMul M t₂ _) : @ContinuousMul M (t₁ ⊓ t₂) _ := by\n  rw [inf_eq_iInf]\n  refine continuousMul_iInf fun b => ?_\n  cases b <;> assumption\n\n"}
{"name":"continuousMul_inf","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"M : Type u_3\ninst✝ : Mul M\nt₁ t₂ : TopologicalSpace M\nh₁ : ContinuousMul M\nh₂ : ContinuousMul M\n⊢ ContinuousMul M","decl":"@[to_additive]\ntheorem continuousMul_inf {t₁ t₂ : TopologicalSpace M} (h₁ : @ContinuousMul M t₁ _)\n    (h₂ : @ContinuousMul M t₂ _) : @ContinuousMul M (t₁ ⊓ t₂) _ := by\n  rw [inf_eq_iInf]\n  refine continuousMul_iInf fun b => ?_\n  cases b <;> assumption\n\n"}
{"name":"ContinuousMap.coe_addRight","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"X : Type u_5\ninst✝² : TopologicalSpace X\ninst✝¹ : Add X\ninst✝ : ContinuousAdd X\nx : X\n⊢ Eq ⇑(ContinuousMap.addRight x) fun y => HAdd.hAdd y x","decl":"@[to_additive (attr := simp)]\ntheorem coe_mulRight (x : X) : ⇑(ContinuousMap.mulRight x) = fun y => y * x :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_mulRight","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"X : Type u_5\ninst✝² : TopologicalSpace X\ninst✝¹ : Mul X\ninst✝ : ContinuousMul X\nx : X\n⊢ Eq ⇑(ContinuousMap.mulRight x) fun y => HMul.hMul y x","decl":"@[to_additive (attr := simp)]\ntheorem coe_mulRight (x : X) : ⇑(ContinuousMap.mulRight x) = fun y => y * x :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_mulLeft","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"X : Type u_5\ninst✝² : TopologicalSpace X\ninst✝¹ : Mul X\ninst✝ : ContinuousMul X\nx : X\n⊢ Eq ⇑(ContinuousMap.mulLeft x) fun y => HMul.hMul x y","decl":"@[to_additive (attr := simp)]\ntheorem coe_mulLeft (x : X) : ⇑(ContinuousMap.mulLeft x) = fun y => x * y :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_addLeft","module":"Mathlib.Topology.Algebra.Monoid","initialProofState":"X : Type u_5\ninst✝² : TopologicalSpace X\ninst✝¹ : Add X\ninst✝ : ContinuousAdd X\nx : X\n⊢ Eq ⇑(ContinuousMap.addLeft x) fun y => HAdd.hAdd x y","decl":"@[to_additive (attr := simp)]\ntheorem coe_mulLeft (x : X) : ⇑(ContinuousMap.mulLeft x) = fun y => x * y :=\n  rfl\n\n"}
