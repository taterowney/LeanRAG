{"name":"minpoly.degree_le_of_ne_zero","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝² : Field A\ninst✝¹ : Ring B\ninst✝ : Algebra A B\nx : B\np : Polynomial A\npnz : Ne p 0\nhp : Eq ((Polynomial.aeval x) p) 0\n⊢ LE.le (minpoly A x).degree p.degree","decl":"/-- If an element `x` is a root of a nonzero polynomial `p`, then the degree of `p` is at least the\ndegree of the minimal polynomial of `x`. See also `minpoly.IsIntegrallyClosed.degree_le_of_ne_zero`\nwhich relaxes the assumptions on `A` in exchange for stronger assumptions on `B`. -/\ntheorem degree_le_of_ne_zero {p : A[X]} (pnz : p ≠ 0) (hp : Polynomial.aeval x p = 0) :\n    degree (minpoly A x) ≤ degree p :=\n  calc\n    degree (minpoly A x) ≤ degree (p * C (leadingCoeff p)⁻¹) :=\n      min A x (monic_mul_leadingCoeff_inv pnz) (by simp [hp])\n    _ = degree p := degree_mul_leadingCoeff_inv p pnz\n\n"}
{"name":"minpoly.ne_zero_of_finite","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : Field A\ninst✝² : Ring B\ninst✝¹ : Algebra A B\ne : B\ninst✝ : FiniteDimensional A B\n⊢ Ne (minpoly A e) 0","decl":"theorem ne_zero_of_finite (e : B) [FiniteDimensional A B] : minpoly A e ≠ 0 :=\n  minpoly.ne_zero <| .of_finite A _\n\n"}
{"name":"minpoly.unique","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝² : Field A\ninst✝¹ : Ring B\ninst✝ : Algebra A B\nx : B\np : Polynomial A\npmonic : p.Monic\nhp : Eq ((Polynomial.aeval x) p) 0\npmin : ∀ (q : Polynomial A), q.Monic → Eq ((Polynomial.aeval x) q) 0 → LE.le p.degree q.degree\n⊢ Eq p (minpoly A x)","decl":"/-- The minimal polynomial of an element `x` is uniquely characterized by its defining property:\nif there is another monic polynomial of minimal degree that has `x` as a root, then this polynomial\nis equal to the minimal polynomial of `x`. See also `minpoly.IsIntegrallyClosed.Minpoly.unique`\nwhich relaxes the assumptions on `A` in exchange for stronger assumptions on `B`. -/\ntheorem unique {p : A[X]} (pmonic : p.Monic) (hp : Polynomial.aeval x p = 0)\n    (pmin : ∀ q : A[X], q.Monic → Polynomial.aeval x q = 0 → degree p ≤ degree q) :\n    p = minpoly A x := by\n  have hx : IsIntegral A x := ⟨p, pmonic, hp⟩\n  symm; apply eq_of_sub_eq_zero\n  by_contra hnz\n  apply degree_le_of_ne_zero A x hnz (by simp [hp]) |>.not_lt\n  apply degree_sub_lt _ (minpoly.ne_zero hx)\n  · rw [(monic hx).leadingCoeff, pmonic.leadingCoeff]\n  · exact le_antisymm (min A x pmonic hp) (pmin (minpoly A x) (monic hx) (aeval A x))\n\n"}
{"name":"minpoly.dvd","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝² : Field A\ninst✝¹ : Ring B\ninst✝ : Algebra A B\nx : B\np : Polynomial A\nhp : Eq ((Polynomial.aeval x) p) 0\n⊢ Dvd.dvd (minpoly A x) p","decl":"/-- If an element `x` is a root of a polynomial `p`, then the minimal polynomial of `x` divides `p`.\nSee also `minpoly.isIntegrallyClosed_dvd` which relaxes the assumptions on `A` in exchange for\nstronger assumptions on `B`. -/\ntheorem dvd {p : A[X]} (hp : Polynomial.aeval x p = 0) : minpoly A x ∣ p := by\n  by_cases hp0 : p = 0\n  · simp only [hp0, dvd_zero]\n  have hx : IsIntegral A x := IsAlgebraic.isIntegral ⟨p, hp0, hp⟩\n  rw [← modByMonic_eq_zero_iff_dvd (monic hx)]\n  by_contra hnz\n  apply degree_le_of_ne_zero A x hnz\n    ((aeval_modByMonic_eq_self_of_root (monic hx) (aeval _ _)).trans hp) |>.not_lt\n  exact degree_modByMonic_lt _ (monic hx)\n\n"}
{"name":"minpoly.dvd_iff","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝² : Field A\ninst✝¹ : Ring B\ninst✝ : Algebra A B\nx : B\np : Polynomial A\n⊢ Iff (Dvd.dvd (minpoly A x) p) (Eq ((Polynomial.aeval x) p) 0)","decl":"variable {A x} in\nlemma dvd_iff {p : A[X]} : minpoly A x ∣ p ↔ Polynomial.aeval x p = 0 :=\n  ⟨fun ⟨q, hq⟩ ↦ by rw [hq, map_mul, aeval, zero_mul], minpoly.dvd A x⟩\n\n"}
{"name":"minpoly.isRadical","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : Field A\ninst✝² : Ring B\ninst✝¹ : Algebra A B\nx : B\ninst✝ : IsReduced B\n⊢ IsRadical (minpoly A x)","decl":"theorem isRadical [IsReduced B] : IsRadical (minpoly A x) := fun n p dvd ↦ by\n  rw [dvd_iff] at dvd ⊢; rw [map_pow] at dvd; exact IsReduced.eq_zero _ ⟨n, dvd⟩\n\n"}
{"name":"minpoly.dvd_map_of_isScalarTower","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_3\nK : Type u_4\nR : Type u_5\ninst✝⁶ : CommRing A\ninst✝⁵ : Field K\ninst✝⁴ : Ring R\ninst✝³ : Algebra A K\ninst✝² : Algebra A R\ninst✝¹ : Algebra K R\ninst✝ : IsScalarTower A K R\nx : R\n⊢ Dvd.dvd (minpoly K x) (Polynomial.map (algebraMap A K) (minpoly A x))","decl":"theorem dvd_map_of_isScalarTower (A K : Type*) {R : Type*} [CommRing A] [Field K] [Ring R]\n    [Algebra A K] [Algebra A R] [Algebra K R] [IsScalarTower A K R] (x : R) :\n    minpoly K x ∣ (minpoly A x).map (algebraMap A K) := by\n  refine minpoly.dvd K x ?_\n  rw [aeval_map_algebraMap, minpoly.aeval]\n\n"}
{"name":"minpoly.dvd_map_of_isScalarTower'","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"R : Type u_3\nS : Type u_4\nK : Type u_5\nL : Type u_6\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Field K\ninst✝⁷ : CommRing L\ninst✝⁶ : Algebra R S\ninst✝⁵ : Algebra R K\ninst✝⁴ : Algebra S L\ninst✝³ : Algebra K L\ninst✝² : Algebra R L\ninst✝¹ : IsScalarTower R K L\ninst✝ : IsScalarTower R S L\ns : S\n⊢ Dvd.dvd (minpoly K ((algebraMap S L) s)) (Polynomial.map (algebraMap R K) (minpoly R s))","decl":"theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]\n    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]\n    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :\n    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by\n  apply minpoly.dvd K (algebraMap S L s)\n  rw [← map_aeval_eq_aeval_map, minpoly.aeval, map_zero]\n  rw [← IsScalarTower.algebraMap_eq, ← IsScalarTower.algebraMap_eq]\n\n"}
{"name":"minpoly.aeval_of_isScalarTower","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"R : Type u_3\nK : Type u_4\nT : Type u_5\nU : Type u_6\ninst✝¹⁰ : CommRing R\ninst✝⁹ : Field K\ninst✝⁸ : CommRing T\ninst✝⁷ : Algebra R K\ninst✝⁶ : Algebra K T\ninst✝⁵ : Algebra R T\ninst✝⁴ : IsScalarTower R K T\ninst✝³ : CommSemiring U\ninst✝² : Algebra K U\ninst✝¹ : Algebra R U\ninst✝ : IsScalarTower R K U\nx : T\ny : U\nhy : Eq ((Polynomial.aeval y) (minpoly K x)) 0\n⊢ Eq ((Polynomial.aeval y) (minpoly R x)) 0","decl":"/-- If `y` is a conjugate of `x` over a field `K`, then it is a conjugate over a subring `R`. -/\ntheorem aeval_of_isScalarTower (R : Type*) {K T U : Type*} [CommRing R] [Field K] [CommRing T]\n    [Algebra R K] [Algebra K T] [Algebra R T] [IsScalarTower R K T] [CommSemiring U] [Algebra K U]\n    [Algebra R U] [IsScalarTower R K U] (x : T) (y : U)\n    (hy : Polynomial.aeval y (minpoly K x) = 0) : Polynomial.aeval y (minpoly R x) = 0 :=\n  aeval_map_algebraMap K y (minpoly R x) ▸\n    eval₂_eq_zero_of_dvd_of_eval₂_eq_zero (algebraMap K U) y\n      (minpoly.dvd_map_of_isScalarTower R K x) hy\n\n"}
{"name":"minpoly.ker_aeval_eq_span_minpoly","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝² : Field A\ninst✝¹ : Ring B\ninst✝ : Algebra A B\nx : B\n⊢ Eq (RingHom.ker (Polynomial.aeval x)) (Submodule.span (Polynomial A) (Singleton.singleton (minpoly A x)))","decl":"/-- See also `minpoly.ker_eval` which relaxes the assumptions on `A` in exchange for\nstronger assumptions on `B`. -/\n@[simp]\nlemma ker_aeval_eq_span_minpoly :\n    RingHom.ker (Polynomial.aeval x) = A[X] ∙ minpoly A x := by\n  ext p\n  simp_rw [RingHom.mem_ker, ← minpoly.dvd_iff, Submodule.mem_span_singleton,\n    dvd_iff_exists_eq_mul_left, smul_eq_mul, eq_comm (a := p)]\n\n"}
{"name":"minpoly.eq_of_irreducible_of_monic","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : Field A\ninst✝² : Ring B\ninst✝¹ : Algebra A B\nx : B\ninst✝ : Nontrivial B\np : Polynomial A\nhp1 : Irreducible p\nhp2 : Eq ((Polynomial.aeval x) p) 0\nhp3 : p.Monic\n⊢ Eq p (minpoly A x)","decl":"theorem eq_of_irreducible_of_monic [Nontrivial B] {p : A[X]} (hp1 : Irreducible p)\n    (hp2 : Polynomial.aeval x p = 0) (hp3 : p.Monic) : p = minpoly A x :=\n  let ⟨_, hq⟩ := dvd A x hp2\n  eq_of_monic_of_associated hp3 (monic ⟨p, ⟨hp3, hp2⟩⟩) <|\n    mul_one (minpoly A x) ▸ hq.symm ▸ Associated.mul_left _\n      (associated_one_iff_isUnit.2 <| (hp1.isUnit_or_isUnit hq).resolve_left <| not_isUnit A x)\n\n"}
{"name":"minpoly.eq_iff_aeval_eq_zero","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : Field A\ninst✝² : Ring B\ninst✝¹ : Algebra A B\nx : B\ninst✝ : Nontrivial B\np : Polynomial A\nirr : Irreducible p\nmonic : p.Monic\n⊢ Iff (Eq p (minpoly A x)) (Eq ((Polynomial.aeval x) p) 0)","decl":"theorem eq_iff_aeval_eq_zero [Nontrivial B] {p : A[X]} (irr: Irreducible p) (monic: p.Monic) :\n    p = minpoly A x ↔ Polynomial.aeval x p = 0 :=\n  ⟨(· ▸ aeval A x), (eq_of_irreducible_of_monic irr · monic)⟩\n\n"}
{"name":"minpoly.eq_iff_aeval_minpoly_eq_zero","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁶ : Field A\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra A B\ninst✝³ : IsDomain B\nC : Type u_3\ninst✝² : Ring C\ninst✝¹ : Algebra A C\ninst✝ : Nontrivial C\nb : B\nh : IsIntegral A b\nc : C\n⊢ Iff (Eq (minpoly A b) (minpoly A c)) (Eq ((Polynomial.aeval c) (minpoly A b)) 0)","decl":"theorem eq_iff_aeval_minpoly_eq_zero [IsDomain B] {C} [Ring C] [Algebra A C] [Nontrivial C]\n    {b : B} (h : IsIntegral A b) {c : C} :\n    minpoly A b = minpoly A c ↔ Polynomial.aeval c (minpoly A b) = 0 :=\n  eq_iff_aeval_eq_zero (irreducible h) (monic h)\n\n"}
{"name":"minpoly.eq_of_irreducible","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : Field A\ninst✝² : Ring B\ninst✝¹ : Algebra A B\nx : B\ninst✝ : Nontrivial B\np : Polynomial A\nhp1 : Irreducible p\nhp2 : Eq ((Polynomial.aeval x) p) 0\n⊢ Eq (HMul.hMul p (Polynomial.C (Inv.inv p.leadingCoeff))) (minpoly A x)","decl":"theorem eq_of_irreducible [Nontrivial B] {p : A[X]} (hp1 : Irreducible p)\n    (hp2 : Polynomial.aeval x p = 0) : p * C p.leadingCoeff⁻¹ = minpoly A x := by\n  have : p.leadingCoeff ≠ 0 := leadingCoeff_ne_zero.mpr hp1.ne_zero\n  apply eq_of_irreducible_of_monic\n  · exact Associated.irreducible ⟨⟨C p.leadingCoeff⁻¹, C p.leadingCoeff,\n      by rwa [← C_mul, inv_mul_cancel₀, C_1], by rwa [← C_mul, mul_inv_cancel₀, C_1]⟩, rfl⟩ hp1\n  · rw [aeval_mul, hp2, zero_mul]\n  · rwa [Polynomial.Monic, leadingCoeff_mul, leadingCoeff_C, mul_inv_cancel₀]\n\n"}
{"name":"minpoly.add_algebraMap","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\ninst✝² : Field A\nB : Type u_3\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\nx : B\na : A\n⊢ Eq (minpoly A (HAdd.hAdd x ((algebraMap A B) a))) ((minpoly A x).comp (HSub.hSub Polynomial.X (Polynomial.C a)))","decl":"theorem add_algebraMap {B : Type*} [CommRing B] [Algebra A B] (x : B)\n    (a : A) : minpoly A (x + algebraMap A B a) = (minpoly A x).comp (X - C a) := by\n  by_cases hx : IsIntegral A x\n  · refine (minpoly.unique _ _ ((minpoly.monic hx).comp_X_sub_C _) ?_ fun q qmo hq => ?_).symm\n    · simp [aeval_comp]\n    · have : (Polynomial.aeval x) (q.comp (X + C a)) = 0 := by simpa [aeval_comp] using hq\n      have H := minpoly.min A x (qmo.comp_X_add_C _) this\n      rw [degree_eq_natDegree qmo.ne_zero,\n        degree_eq_natDegree ((minpoly.monic hx).comp_X_sub_C _).ne_zero, natDegree_comp,\n        natDegree_X_sub_C, mul_one]\n      rwa [degree_eq_natDegree (minpoly.ne_zero hx),\n        degree_eq_natDegree (qmo.comp_X_add_C _).ne_zero, natDegree_comp,\n        natDegree_X_add_C, mul_one] at H\n  · rw [minpoly.eq_zero hx, minpoly.eq_zero, zero_comp]\n    refine fun h ↦ hx ?_\n    simpa only [add_sub_cancel_right] using IsIntegral.sub h (isIntegral_algebraMap (x := a))\n\n"}
{"name":"minpoly.sub_algebraMap","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\ninst✝² : Field A\nB : Type u_3\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\nx : B\na : A\n⊢ Eq (minpoly A (HSub.hSub x ((algebraMap A B) a))) ((minpoly A x).comp (HAdd.hAdd Polynomial.X (Polynomial.C a)))","decl":"theorem sub_algebraMap {B : Type*} [CommRing B] [Algebra A B] (x : B)\n    (a : A) : minpoly A (x - algebraMap A B a) = (minpoly A x).comp (X + C a) := by\n  simpa [sub_eq_add_neg] using add_algebraMap x (-a)\n\n"}
{"name":"minpoly.neg","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\ninst✝² : Field A\nB : Type u_3\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\nx : B\n⊢ Eq (minpoly A (Neg.neg x)) (HMul.hMul (HPow.hPow (-1) (minpoly A x).natDegree) ((minpoly A x).comp (Neg.neg Polynomial.X)))","decl":"theorem neg {B : Type*} [CommRing B] [Algebra A B] (x : B) :\n    minpoly A (- x) = (-1) ^ (natDegree (minpoly A x)) * (minpoly A x).comp (- X) := by\n  by_cases hx : IsIntegral A x\n  · refine (minpoly.unique _ _ ((minpoly.monic hx).neg_one_pow_natDegree_mul_comp_neg_X)\n        ?_ fun q qmo hq => ?_).symm\n    · simp [aeval_comp]\n    · have : (Polynomial.aeval x) ((-1) ^ q.natDegree * q.comp (- X)) = 0 := by\n        simpa [aeval_comp] using hq\n      have H := minpoly.min A x qmo.neg_one_pow_natDegree_mul_comp_neg_X this\n      have n1 := ((minpoly.monic hx).neg_one_pow_natDegree_mul_comp_neg_X).ne_zero\n      have n2 := qmo.neg_one_pow_natDegree_mul_comp_neg_X.ne_zero\n      rw [degree_eq_natDegree qmo.ne_zero,\n        degree_eq_natDegree n1, natDegree_mul (by simp) (right_ne_zero_of_mul n1), natDegree_comp]\n      rw [degree_eq_natDegree (minpoly.ne_zero hx),\n        degree_eq_natDegree qmo.neg_one_pow_natDegree_mul_comp_neg_X.ne_zero,\n        natDegree_mul (by simp) (right_ne_zero_of_mul n2), natDegree_comp] at H\n      simpa using H\n  · rw [minpoly.eq_zero hx, minpoly.eq_zero, zero_comp]\n    · simp only [natDegree_zero, pow_zero, mul_zero]\n    · exact IsIntegral.neg_iff.not.mpr hx\n\n"}
{"name":"minpoly.aux_inj_roots_of_min_poly","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"F : Type u_3\nE : Type u_4\nK : Type u_5\ninst✝⁶ : Field F\ninst✝⁵ : Ring E\ninst✝⁴ : CommRing K\ninst✝³ : IsDomain K\ninst✝² : Algebra F E\ninst✝¹ : Algebra F K\ninst✝ : FiniteDimensional F E\n⊢ Function.Injective (minpoly.rootsOfMinPolyPiType F E K)","decl":"theorem aux_inj_roots_of_min_poly : Injective (rootsOfMinPolyPiType F E K) := by\n  intro f g h\n  -- needs explicit coercion on the RHS\n  suffices (f : E →ₗ[F] K) = (g : E →ₗ[F] K) by rwa [DFunLike.ext'_iff] at this ⊢\n  rw [funext_iff] at h\n  exact LinearMap.ext_on (Module.finBasis F E).span_eq fun e he =>\n    Subtype.ext_iff.mp (h ⟨e, he⟩)\n\n"}
{"name":"minpoly.eq_X_sub_C","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : Field A\ninst✝² : Ring B\ninst✝¹ : Algebra A B\ninst✝ : Nontrivial B\na : A\n⊢ Eq (minpoly A ((algebraMap A B) a)) (HSub.hSub Polynomial.X (Polynomial.C a))","decl":"/-- If `B/K` is a nontrivial algebra over a field, and `x` is an element of `K`,\nthen the minimal polynomial of `algebraMap K B x` is `X - C x`. -/\ntheorem eq_X_sub_C (a : A) : minpoly A (algebraMap A B a) = X - C a :=\n  eq_X_sub_C_of_algebraMap_inj a (algebraMap A B).injective\n\n"}
{"name":"minpoly.eq_X_sub_C'","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\ninst✝ : Field A\na : A\n⊢ Eq (minpoly A a) (HSub.hSub Polynomial.X (Polynomial.C a))","decl":"theorem eq_X_sub_C' (a : A) : minpoly A a = X - C a :=\n  eq_X_sub_C A a\n\n"}
{"name":"minpoly.zero","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : Field A\ninst✝² : Ring B\ninst✝¹ : Algebra A B\ninst✝ : Nontrivial B\n⊢ Eq (minpoly A 0) Polynomial.X","decl":"/-- The minimal polynomial of `0` is `X`. -/\n@[simp]\ntheorem zero : minpoly A (0 : B) = X := by\n  simpa only [add_zero, C_0, sub_eq_add_neg, neg_zero, RingHom.map_zero] using eq_X_sub_C B (0 : A)\n\n"}
{"name":"minpoly.one","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : Field A\ninst✝² : Ring B\ninst✝¹ : Algebra A B\ninst✝ : Nontrivial B\n⊢ Eq (minpoly A 1) (HSub.hSub Polynomial.X 1)","decl":"/-- The minimal polynomial of `1` is `X - 1`. -/\n@[simp]\ntheorem one : minpoly A (1 : B) = X - 1 := by\n  simpa only [RingHom.map_one, C_1, sub_eq_add_neg] using eq_X_sub_C B (1 : A)\n\n"}
{"name":"minpoly.prime","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : Field A\ninst✝² : Ring B\ninst✝¹ : IsDomain B\ninst✝ : Algebra A B\nx : B\nhx : IsIntegral A x\n⊢ Prime (minpoly A x)","decl":"/-- A minimal polynomial is prime. -/\ntheorem prime (hx : IsIntegral A x) : Prime (minpoly A x) := by\n  refine ⟨minpoly.ne_zero hx, not_isUnit A x, ?_⟩\n  rintro p q ⟨d, h⟩\n  have : Polynomial.aeval x (p * q) = 0 := by simp [h, aeval A x]\n  replace : Polynomial.aeval x p = 0 ∨ Polynomial.aeval x q = 0 := by simpa\n  exact Or.imp (dvd A x) (dvd A x) this\n\n"}
{"name":"minpoly.root","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : Field A\ninst✝² : Ring B\ninst✝¹ : IsDomain B\ninst✝ : Algebra A B\nx : B\nhx : IsIntegral A x\ny : A\nh : (minpoly A x).IsRoot y\n⊢ Eq ((algebraMap A B) y) x","decl":"/-- If `L/K` is a field extension and an element `y` of `K` is a root of the minimal polynomial\nof an element `x ∈ L`, then `y` maps to `x` under the field embedding. -/\ntheorem root {x : B} (hx : IsIntegral A x) {y : A} (h : IsRoot (minpoly A x) y) :\n    algebraMap A B y = x := by\n  have key : minpoly A x = X - C y := eq_of_monic_of_associated (monic hx) (monic_X_sub_C y)\n    (associated_of_dvd_dvd ((irreducible_X_sub_C y).dvd_symm (irreducible hx) (dvd_iff_isRoot.2 h))\n      (dvd_iff_isRoot.2 h))\n  have := aeval A x\n  rwa [key, map_sub, aeval_X, aeval_C, sub_eq_zero, eq_comm] at this\n\n"}
{"name":"minpoly.coeff_zero_eq_zero","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : Field A\ninst✝² : Ring B\ninst✝¹ : IsDomain B\ninst✝ : Algebra A B\nx : B\nhx : IsIntegral A x\n⊢ Iff (Eq ((minpoly A x).coeff 0) 0) (Eq x 0)","decl":"/-- The constant coefficient of the minimal polynomial of `x` is `0` if and only if `x = 0`. -/\n@[simp]\ntheorem coeff_zero_eq_zero (hx : IsIntegral A x) : coeff (minpoly A x) 0 = 0 ↔ x = 0 := by\n  constructor\n  · intro h\n    have zero_root := zero_isRoot_of_coeff_zero_eq_zero h\n    rw [← root hx zero_root]\n    exact RingHom.map_zero _\n  · rintro rfl\n    simp\n\n"}
{"name":"minpoly.coeff_zero_ne_zero","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : Field A\ninst✝² : Ring B\ninst✝¹ : IsDomain B\ninst✝ : Algebra A B\nx : B\nhx : IsIntegral A x\nh : Ne x 0\n⊢ Ne ((minpoly A x).coeff 0) 0","decl":"/-- The minimal polynomial of a nonzero element has nonzero constant coefficient. -/\ntheorem coeff_zero_ne_zero (hx : IsIntegral A x) (h : x ≠ 0) : coeff (minpoly A x) 0 ≠ 0 := by\n  contrapose! h\n  simpa only [hx, coeff_zero_eq_zero] using h\n\n"}
{"name":"minpoly_algEquiv_toLinearMap","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝³ : Field K\ninst✝² : CommRing L\ninst✝¹ : IsDomain L\ninst✝ : Algebra K L\nσ : AlgEquiv K L L\nhσ : IsOfFinOrder σ\n⊢ Eq (minpoly K σ.toLinearMap) (HSub.hSub (HPow.hPow Polynomial.X (orderOf σ)) (Polynomial.C 1))","decl":"/-- The minimal polynomial (over `K`) of `σ : Gal(L/K)` is `X ^ (orderOf σ) - 1`. -/\nlemma minpoly_algEquiv_toLinearMap (σ : L ≃ₐ[K] L) (hσ : IsOfFinOrder σ) :\n    minpoly K σ.toLinearMap = X ^ (orderOf σ) - C 1 := by\n  refine (minpoly.unique _ _ (monic_X_pow_sub_C _ hσ.orderOf_pos.ne.symm) ?_ ?_).symm\n  · rw [map_sub]\n    simp [← AlgEquiv.pow_toLinearMap, pow_orderOf_eq_one]\n  · intros q hq hs\n    rw [degree_eq_natDegree hq.ne_zero, degree_X_pow_sub_C hσ.orderOf_pos, Nat.cast_le, ← not_lt]\n    intro H\n    rw [aeval_eq_sum_range' H, ← Fin.sum_univ_eq_sum_range] at hs\n    simp_rw [← AlgEquiv.pow_toLinearMap] at hs\n    apply hq.ne_zero\n    simpa using Fintype.linearIndependent_iff.mp\n      (((linearIndependent_algHom_toLinearMap' K L L).comp _ AlgEquiv.coe_algHom_injective).comp _\n        (Subtype.val_injective.comp ((finEquivPowers σ hσ).injective)))\n      (q.coeff ∘ (↑)) hs ⟨_, H⟩\n\n"}
{"name":"minpoly_algHom_toLinearMap","module":"Mathlib.FieldTheory.Minpoly.Field","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝³ : Field K\ninst✝² : CommRing L\ninst✝¹ : IsDomain L\ninst✝ : Algebra K L\nσ : AlgHom K L L\nhσ : IsOfFinOrder σ\n⊢ Eq (minpoly K σ.toLinearMap) (HSub.hSub (HPow.hPow Polynomial.X (orderOf σ)) (Polynomial.C 1))","decl":"/-- The minimal polynomial (over `K`) of `σ : Gal(L/K)` is `X ^ (orderOf σ) - 1`. -/\nlemma minpoly_algHom_toLinearMap (σ : L →ₐ[K] L) (hσ : IsOfFinOrder σ) :\n    minpoly K σ.toLinearMap = X ^ (orderOf σ) - C 1 := by\n  have : orderOf σ = orderOf (AlgEquiv.algHomUnitsEquiv _ _ hσ.unit) := by\n    rw [← MonoidHom.coe_coe, orderOf_injective, ← orderOf_units, IsOfFinOrder.val_unit]\n    exact (AlgEquiv.algHomUnitsEquiv K L).injective\n  rw [this, ← minpoly_algEquiv_toLinearMap]\n  · apply congr_arg\n    ext\n    simp\n  · rwa [← orderOf_pos_iff, ← this, orderOf_pos_iff]\n\n"}
