{"name":"Subgroup.exists_finsupp_of_mem_closure_range","module":"Mathlib.Algebra.Group.Subgroup.Finsupp","initialProofState":"M : Type u_1\ninst✝ : CommGroup M\nι : Type u_2\nf : ι → M\nx : M\nhx : Membership.mem (Subgroup.closure (Set.range f)) x\n⊢ Exists fun a => Eq x (a.prod fun x1 x2 => HPow.hPow (f x1) x2)","decl":"@[to_additive]\ntheorem exists_finsupp_of_mem_closure_range (hx : x ∈ closure (Set.range f)) :\n    ∃ a : ι →₀ ℤ, x = a.prod (f · ^ ·) := by\n  classical\n  induction hx using closure_induction with\n  | mem x h => obtain ⟨i, rfl⟩ := h; exact ⟨Finsupp.single i 1, by simp⟩\n  | one => use 0; simp\n  | mul x y hx hy hx' hy' =>\n    obtain ⟨⟨v, rfl⟩, w, rfl⟩ := And.intro hx' hy'\n    use v + w\n    rw [Finsupp.prod_add_index]\n    · simp\n    · simp [zpow_add]\n  | inv x hx hx' =>\n    obtain ⟨a, rfl⟩ := hx'\n    use -a\n    rw [Finsupp.prod_neg_index]\n    · simp\n    · simp [zpow_neg]\n\n"}
{"name":"AddSubgroup.exists_finsupp_of_mem_closure_range","module":"Mathlib.Algebra.Group.Subgroup.Finsupp","initialProofState":"M : Type u_1\ninst✝ : AddCommGroup M\nι : Type u_2\nf : ι → M\nx : M\nhx : Membership.mem (AddSubgroup.closure (Set.range f)) x\n⊢ Exists fun a => Eq x (a.sum fun x1 x2 => HSMul.hSMul x2 (f x1))","decl":"@[to_additive]\ntheorem exists_finsupp_of_mem_closure_range (hx : x ∈ closure (Set.range f)) :\n    ∃ a : ι →₀ ℤ, x = a.prod (f · ^ ·) := by\n  classical\n  induction hx using closure_induction with\n  | mem x h => obtain ⟨i, rfl⟩ := h; exact ⟨Finsupp.single i 1, by simp⟩\n  | one => use 0; simp\n  | mul x y hx hy hx' hy' =>\n    obtain ⟨⟨v, rfl⟩, w, rfl⟩ := And.intro hx' hy'\n    use v + w\n    rw [Finsupp.prod_add_index]\n    · simp\n    · simp [zpow_add]\n  | inv x hx hx' =>\n    obtain ⟨a, rfl⟩ := hx'\n    use -a\n    rw [Finsupp.prod_neg_index]\n    · simp\n    · simp [zpow_neg]\n\n"}
{"name":"AddSubgroup.mem_closure_range_iff","module":"Mathlib.Algebra.Group.Subgroup.Finsupp","initialProofState":"M : Type u_1\ninst✝ : AddCommGroup M\nι : Type u_2\nf : ι → M\nx : M\n⊢ Iff (Membership.mem (AddSubgroup.closure (Set.range f)) x) (Exists fun a => Eq x (a.sum fun x1 x2 => HSMul.hSMul x2 (f x1)))","decl":"variable {f x} in\n@[to_additive]\ntheorem mem_closure_range_iff :\n    x ∈ closure (Set.range f) ↔ ∃ a : ι →₀ ℤ, x = a.prod (f · ^ ·) := by\n  refine ⟨exists_finsupp_of_mem_closure_range f x, ?_⟩\n  rintro ⟨a, rfl⟩\n  exact Submonoid.prod_mem _ fun i hi ↦ zpow_mem (subset_closure (Set.mem_range_self i)) _\n\n"}
{"name":"Subgroup.mem_closure_range_iff","module":"Mathlib.Algebra.Group.Subgroup.Finsupp","initialProofState":"M : Type u_1\ninst✝ : CommGroup M\nι : Type u_2\nf : ι → M\nx : M\n⊢ Iff (Membership.mem (Subgroup.closure (Set.range f)) x) (Exists fun a => Eq x (a.prod fun x1 x2 => HPow.hPow (f x1) x2))","decl":"variable {f x} in\n@[to_additive]\ntheorem mem_closure_range_iff :\n    x ∈ closure (Set.range f) ↔ ∃ a : ι →₀ ℤ, x = a.prod (f · ^ ·) := by\n  refine ⟨exists_finsupp_of_mem_closure_range f x, ?_⟩\n  rintro ⟨a, rfl⟩\n  exact Submonoid.prod_mem _ fun i hi ↦ zpow_mem (subset_closure (Set.mem_range_self i)) _\n\n"}
{"name":"AddSubgroup.exists_of_mem_closure_range","module":"Mathlib.Algebra.Group.Subgroup.Finsupp","initialProofState":"M : Type u_1\ninst✝¹ : AddCommGroup M\nι : Type u_2\nf : ι → M\nx : M\ninst✝ : Fintype ι\nhx : Membership.mem (AddSubgroup.closure (Set.range f)) x\n⊢ Exists fun a => Eq x (Finset.univ.sum fun i => HSMul.hSMul (a i) (f i))","decl":"@[to_additive]\ntheorem exists_of_mem_closure_range [Fintype ι] (hx : x ∈ closure (Set.range f)) :\n    ∃ a : ι → ℤ, x = ∏ i, f i ^ a i := by\n  obtain ⟨a, rfl⟩ := exists_finsupp_of_mem_closure_range f x hx\n  exact ⟨a, by simp⟩\n\n"}
{"name":"Subgroup.exists_of_mem_closure_range","module":"Mathlib.Algebra.Group.Subgroup.Finsupp","initialProofState":"M : Type u_1\ninst✝¹ : CommGroup M\nι : Type u_2\nf : ι → M\nx : M\ninst✝ : Fintype ι\nhx : Membership.mem (Subgroup.closure (Set.range f)) x\n⊢ Exists fun a => Eq x (Finset.univ.prod fun i => HPow.hPow (f i) (a i))","decl":"@[to_additive]\ntheorem exists_of_mem_closure_range [Fintype ι] (hx : x ∈ closure (Set.range f)) :\n    ∃ a : ι → ℤ, x = ∏ i, f i ^ a i := by\n  obtain ⟨a, rfl⟩ := exists_finsupp_of_mem_closure_range f x hx\n  exact ⟨a, by simp⟩\n\n"}
{"name":"AddSubgroup.mem_closure_range_iff_of_fintype","module":"Mathlib.Algebra.Group.Subgroup.Finsupp","initialProofState":"M : Type u_1\ninst✝¹ : AddCommGroup M\nι : Type u_2\nf : ι → M\nx : M\ninst✝ : Fintype ι\n⊢ Iff (Membership.mem (AddSubgroup.closure (Set.range f)) x) (Exists fun a => Eq x (Finset.univ.sum fun i => HSMul.hSMul (a i) (f i)))","decl":"variable {f x} in\n@[to_additive]\ntheorem mem_closure_range_iff_of_fintype [Fintype ι] :\n    x ∈ closure (Set.range f) ↔ ∃ a : ι → ℤ, x = ∏ i, f i ^ a i := by\n  rw [Finsupp.equivFunOnFinite.symm.exists_congr_left, mem_closure_range_iff]\n  simp\n\n"}
{"name":"Subgroup.mem_closure_range_iff_of_fintype","module":"Mathlib.Algebra.Group.Subgroup.Finsupp","initialProofState":"M : Type u_1\ninst✝¹ : CommGroup M\nι : Type u_2\nf : ι → M\nx : M\ninst✝ : Fintype ι\n⊢ Iff (Membership.mem (Subgroup.closure (Set.range f)) x) (Exists fun a => Eq x (Finset.univ.prod fun i => HPow.hPow (f i) (a i)))","decl":"variable {f x} in\n@[to_additive]\ntheorem mem_closure_range_iff_of_fintype [Fintype ι] :\n    x ∈ closure (Set.range f) ↔ ∃ a : ι → ℤ, x = ∏ i, f i ^ a i := by\n  rw [Finsupp.equivFunOnFinite.symm.exists_congr_left, mem_closure_range_iff]\n  simp\n\n"}
