{"name":"cauchy_davenport_minOrder_mul","module":"Mathlib.Combinatorics.Additive.CauchyDavenport","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : DecidableEq α\ns t : Finset α\nhs : s.Nonempty\nht : t.Nonempty\n⊢ LE.le (Min.min (Monoid.minOrder α) ↑(HSub.hSub (HAdd.hAdd s.card t.card) 1)) ↑(HMul.hMul s t).card","decl":"/-- A generalisation of the **Cauchy-Davenport theorem** to arbitrary groups. The size of `s * t` is\nlower-bounded by `|s| + |t| - 1` unless this quantity is greater than the size of the smallest\nsubgroup. -/\n@[to_additive \"A generalisation of the **Cauchy-Davenport theorem** to arbitrary groups. The size of\n`s + t` is lower-bounded by `|s| + |t| - 1` unless this quantity is greater than the size of the\nsmallest subgroup.\"]\nlemma cauchy_davenport_minOrder_mul (hs : s.Nonempty) (ht : t.Nonempty) :\n    min (minOrder α) ↑(#s + #t - 1) ≤ #(s * t) := by\n  -- Set up the induction on `x := (s, t)` along the `DevosMulRel` relation.\n  set x := (s, t) with hx\n  clear_value x\n  simp only [Prod.ext_iff] at hx\n  obtain ⟨rfl, rfl⟩ := hx\n  refine wellFoundedOn_devosMulRel.induction (P := fun x : Finset α × Finset α ↦\n    min (minOrder α) ↑(#x.1 + #x.2 - 1) ≤ #(x.1 * x.2)) ⟨hs, ht⟩ ?_\n  clear! x\n  rintro ⟨s, t⟩ ⟨hs, ht⟩ ih\n  simp only [min_le_iff, tsub_le_iff_right, Prod.forall, Set.mem_setOf_eq, and_imp,\n    Nat.cast_le] at *\n  -- If `#t < #s`, we're done by the induction hypothesis on `(t⁻¹, s⁻¹)`.\n  obtain hts | hst := lt_or_le #t #s\n  · simpa only [← mul_inv_rev, add_comm, card_inv] using\n      ih _ _ ht.inv hs.inv\n        (devosMulRel_iff.2 <| Or.inr <| Or.inr <| by\n          simpa only [← mul_inv_rev, add_comm, card_inv, true_and])\n  -- If `s` is a singleton, then the result is trivial.\n  obtain ⟨a, rfl⟩ | ⟨a, ha, b, hb, hab⟩ := hs.exists_eq_singleton_or_nontrivial\n  · simp [add_comm]\n  -- Else, we have `a, b ∈ s` distinct. So `g := b⁻¹ * a` is a non-identity element such that `s`\n  -- intersects its right translate by `g`.\n  obtain ⟨g, hg, hgs⟩ : ∃ g : α, g ≠ 1 ∧ (s ∩ op g • s).Nonempty :=\n    ⟨b⁻¹ * a, inv_mul_eq_one.not.2 hab.symm, _,\n      mem_inter.2 ⟨ha, mem_smul_finset.2 ⟨_, hb, by simp⟩⟩⟩\n  -- If `s` is equal to its right translate by `g`, then it contains a nontrivial subgroup, namely\n  -- the subgroup generated by `g`. So `s * t` has size at least the size of a nontrivial subgroup,\n  -- as wanted.\n  obtain hsg | hsg := eq_or_ne (op g • s) s\n  · have hS : (zpowers g : Set α) ⊆ a⁻¹ • (s : Set α) := by\n      refine forall_mem_zpowers.2 <| @zpow_induction_right _ _ _ (· ∈ a⁻¹ • (s : Set α))\n        ⟨_, ha, inv_mul_cancel _⟩ (fun c hc ↦ ?_) fun c hc ↦ ?_\n      · rw [← hsg, coe_smul_finset, smul_comm]\n        exact Set.smul_mem_smul_set hc\n      · simp only\n        rwa [← op_smul_eq_mul, op_inv, ← Set.mem_smul_set_iff_inv_smul_mem, smul_comm,\n          ← coe_smul_finset, hsg]\n    refine Or.inl ((minOrder_le_natCard (zpowers_ne_bot.2 hg) <|\n      s.finite_toSet.smul_set.subset hS).trans <| WithTop.coe_le_coe.2 <|\n        ((Nat.card_mono s.finite_toSet.smul_set hS).trans_eq <| ?_).trans <|\n          card_le_card_mul_right ht)\n    rw [← coe_smul_finset]\n    simp [-coe_smul_finset]\n  -- Else, we can transform `s`, `t` to `s'`, `t'` and `s''`, `t''`, such that one of `(s', t')` and\n  -- `(s'', t'')` is strictly smaller than `(s, t)` according to `DevosMulRel`.\n  replace hsg : #(s ∩ op g • s) < #s := card_lt_card ⟨inter_subset_left, fun h ↦\n    hsg <| eq_of_superset_of_card_ge (h.trans inter_subset_right) (card_smul_finset _ _).le⟩\n  replace aux1 := card_mono <| mulETransformLeft.fst_mul_snd_subset g (s, t)\n  replace aux2 := card_mono <| mulETransformRight.fst_mul_snd_subset g (s, t)\n  -- If the left translate of `t` by `g⁻¹` is disjoint from `t`, then we're easily done.\n  obtain hgt | hgt := disjoint_or_nonempty_inter t (g⁻¹ • t)\n  · rw [← card_smul_finset g⁻¹ t]\n    refine Or.inr ((add_le_add_right hst _).trans ?_)\n    rw [← card_union_of_disjoint hgt]\n    exact (card_le_card_mul_left hgs).trans (le_add_of_le_left aux1)\n  -- Else, we're done by induction on either `(s', t')` or `(s'', t'')` depending on whether\n  -- `|s| + |t| ≤ |s'| + |t'|` or `|s| + |t| < |s''| + |t''|`. One of those two inequalities must\n  -- hold since `2 * (|s| + |t|) = |s'| + |t'| + |s''| + |t''|`.\n  obtain hstg | hstg := le_or_lt_of_add_le_add (MulETransform.card g (s, t)).ge\n  · exact (ih _ _ hgs (hgt.mono inter_subset_union) <| devosMulRel_of_le_of_le aux1 hstg hsg).imp\n      (WithTop.coe_le_coe.2 aux1).trans' fun h ↦ hstg.trans <| h.trans <| add_le_add_right aux1 _\n  · exact (ih _ _ (hgs.mono inter_subset_union) hgt <| devosMulRel_of_le aux2 hstg).imp\n      (WithTop.coe_le_coe.2 aux2).trans' fun h ↦\n        hstg.le.trans <| h.trans <| add_le_add_right aux2 _\n\n"}
{"name":"cauchy_davenport_minOrder_add","module":"Mathlib.Combinatorics.Additive.CauchyDavenport","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : DecidableEq α\ns t : Finset α\nhs : s.Nonempty\nht : t.Nonempty\n⊢ LE.le (Min.min (AddMonoid.minOrder α) ↑(HSub.hSub (HAdd.hAdd s.card t.card) 1)) ↑(HAdd.hAdd s t).card","decl":"/-- A generalisation of the **Cauchy-Davenport theorem** to arbitrary groups. The size of `s * t` is\nlower-bounded by `|s| + |t| - 1` unless this quantity is greater than the size of the smallest\nsubgroup. -/\n@[to_additive \"A generalisation of the **Cauchy-Davenport theorem** to arbitrary groups. The size of\n`s + t` is lower-bounded by `|s| + |t| - 1` unless this quantity is greater than the size of the\nsmallest subgroup.\"]\nlemma cauchy_davenport_minOrder_mul (hs : s.Nonempty) (ht : t.Nonempty) :\n    min (minOrder α) ↑(#s + #t - 1) ≤ #(s * t) := by\n  -- Set up the induction on `x := (s, t)` along the `DevosMulRel` relation.\n  set x := (s, t) with hx\n  clear_value x\n  simp only [Prod.ext_iff] at hx\n  obtain ⟨rfl, rfl⟩ := hx\n  refine wellFoundedOn_devosMulRel.induction (P := fun x : Finset α × Finset α ↦\n    min (minOrder α) ↑(#x.1 + #x.2 - 1) ≤ #(x.1 * x.2)) ⟨hs, ht⟩ ?_\n  clear! x\n  rintro ⟨s, t⟩ ⟨hs, ht⟩ ih\n  simp only [min_le_iff, tsub_le_iff_right, Prod.forall, Set.mem_setOf_eq, and_imp,\n    Nat.cast_le] at *\n  -- If `#t < #s`, we're done by the induction hypothesis on `(t⁻¹, s⁻¹)`.\n  obtain hts | hst := lt_or_le #t #s\n  · simpa only [← mul_inv_rev, add_comm, card_inv] using\n      ih _ _ ht.inv hs.inv\n        (devosMulRel_iff.2 <| Or.inr <| Or.inr <| by\n          simpa only [← mul_inv_rev, add_comm, card_inv, true_and])\n  -- If `s` is a singleton, then the result is trivial.\n  obtain ⟨a, rfl⟩ | ⟨a, ha, b, hb, hab⟩ := hs.exists_eq_singleton_or_nontrivial\n  · simp [add_comm]\n  -- Else, we have `a, b ∈ s` distinct. So `g := b⁻¹ * a` is a non-identity element such that `s`\n  -- intersects its right translate by `g`.\n  obtain ⟨g, hg, hgs⟩ : ∃ g : α, g ≠ 1 ∧ (s ∩ op g • s).Nonempty :=\n    ⟨b⁻¹ * a, inv_mul_eq_one.not.2 hab.symm, _,\n      mem_inter.2 ⟨ha, mem_smul_finset.2 ⟨_, hb, by simp⟩⟩⟩\n  -- If `s` is equal to its right translate by `g`, then it contains a nontrivial subgroup, namely\n  -- the subgroup generated by `g`. So `s * t` has size at least the size of a nontrivial subgroup,\n  -- as wanted.\n  obtain hsg | hsg := eq_or_ne (op g • s) s\n  · have hS : (zpowers g : Set α) ⊆ a⁻¹ • (s : Set α) := by\n      refine forall_mem_zpowers.2 <| @zpow_induction_right _ _ _ (· ∈ a⁻¹ • (s : Set α))\n        ⟨_, ha, inv_mul_cancel _⟩ (fun c hc ↦ ?_) fun c hc ↦ ?_\n      · rw [← hsg, coe_smul_finset, smul_comm]\n        exact Set.smul_mem_smul_set hc\n      · simp only\n        rwa [← op_smul_eq_mul, op_inv, ← Set.mem_smul_set_iff_inv_smul_mem, smul_comm,\n          ← coe_smul_finset, hsg]\n    refine Or.inl ((minOrder_le_natCard (zpowers_ne_bot.2 hg) <|\n      s.finite_toSet.smul_set.subset hS).trans <| WithTop.coe_le_coe.2 <|\n        ((Nat.card_mono s.finite_toSet.smul_set hS).trans_eq <| ?_).trans <|\n          card_le_card_mul_right ht)\n    rw [← coe_smul_finset]\n    simp [-coe_smul_finset]\n  -- Else, we can transform `s`, `t` to `s'`, `t'` and `s''`, `t''`, such that one of `(s', t')` and\n  -- `(s'', t'')` is strictly smaller than `(s, t)` according to `DevosMulRel`.\n  replace hsg : #(s ∩ op g • s) < #s := card_lt_card ⟨inter_subset_left, fun h ↦\n    hsg <| eq_of_superset_of_card_ge (h.trans inter_subset_right) (card_smul_finset _ _).le⟩\n  replace aux1 := card_mono <| mulETransformLeft.fst_mul_snd_subset g (s, t)\n  replace aux2 := card_mono <| mulETransformRight.fst_mul_snd_subset g (s, t)\n  -- If the left translate of `t` by `g⁻¹` is disjoint from `t`, then we're easily done.\n  obtain hgt | hgt := disjoint_or_nonempty_inter t (g⁻¹ • t)\n  · rw [← card_smul_finset g⁻¹ t]\n    refine Or.inr ((add_le_add_right hst _).trans ?_)\n    rw [← card_union_of_disjoint hgt]\n    exact (card_le_card_mul_left hgs).trans (le_add_of_le_left aux1)\n  -- Else, we're done by induction on either `(s', t')` or `(s'', t'')` depending on whether\n  -- `|s| + |t| ≤ |s'| + |t'|` or `|s| + |t| < |s''| + |t''|`. One of those two inequalities must\n  -- hold since `2 * (|s| + |t|) = |s'| + |t'| + |s''| + |t''|`.\n  obtain hstg | hstg := le_or_lt_of_add_le_add (MulETransform.card g (s, t)).ge\n  · exact (ih _ _ hgs (hgt.mono inter_subset_union) <| devosMulRel_of_le_of_le aux1 hstg hsg).imp\n      (WithTop.coe_le_coe.2 aux1).trans' fun h ↦ hstg.trans <| h.trans <| add_le_add_right aux1 _\n  · exact (ih _ _ (hgs.mono inter_subset_union) hgt <| devosMulRel_of_le aux2 hstg).imp\n      (WithTop.coe_le_coe.2 aux2).trans' fun h ↦\n        hstg.le.trans <| h.trans <| add_le_add_right aux2 _\n\n"}
{"name":"cauchy_davenport_mul_of_isTorsionFree","module":"Mathlib.Combinatorics.Additive.CauchyDavenport","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : DecidableEq α\ns t : Finset α\nh : Monoid.IsTorsionFree α\nhs : s.Nonempty\nht : t.Nonempty\n⊢ LE.le (HSub.hSub (HAdd.hAdd s.card t.card) 1) (HMul.hMul s t).card","decl":"/-- The **Cauchy-Davenport Theorem** for torsion-free groups. The size of `s * t` is lower-bounded\nby `|s| + |t| - 1`. -/\n@[to_additive\n\"The **Cauchy-Davenport theorem** for torsion-free groups. The size of `s + t` is lower-bounded\nby `|s| + |t| - 1`.\"]\nlemma cauchy_davenport_mul_of_isTorsionFree (h : IsTorsionFree α)\n    (hs : s.Nonempty) (ht : t.Nonempty) : #s + #t - 1 ≤ #(s * t) := by\n  simpa only [h.minOrder, min_eq_right, le_top, Nat.cast_le]\n    using cauchy_davenport_minOrder_mul hs ht\n\n"}
{"name":"cauchy_davenport_add_of_isTorsionFree","module":"Mathlib.Combinatorics.Additive.CauchyDavenport","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : DecidableEq α\ns t : Finset α\nh : AddMonoid.IsTorsionFree α\nhs : s.Nonempty\nht : t.Nonempty\n⊢ LE.le (HSub.hSub (HAdd.hAdd s.card t.card) 1) (HAdd.hAdd s t).card","decl":"/-- The **Cauchy-Davenport Theorem** for torsion-free groups. The size of `s * t` is lower-bounded\nby `|s| + |t| - 1`. -/\n@[to_additive\n\"The **Cauchy-Davenport theorem** for torsion-free groups. The size of `s + t` is lower-bounded\nby `|s| + |t| - 1`.\"]\nlemma cauchy_davenport_mul_of_isTorsionFree (h : IsTorsionFree α)\n    (hs : s.Nonempty) (ht : t.Nonempty) : #s + #t - 1 ≤ #(s * t) := by\n  simpa only [h.minOrder, min_eq_right, le_top, Nat.cast_le]\n    using cauchy_davenport_minOrder_mul hs ht\n\n"}
{"name":"ZMod.cauchy_davenport","module":"Mathlib.Combinatorics.Additive.CauchyDavenport","initialProofState":"p : Nat\nhp : Nat.Prime p\ns t : Finset (ZMod p)\nhs : s.Nonempty\nht : t.Nonempty\n⊢ LE.le (Min.min p (HSub.hSub (HAdd.hAdd s.card t.card) 1)) (HAdd.hAdd s t).card","decl":"/-- The **Cauchy-Davenport Theorem**. If `s`, `t` are nonempty sets in $$ℤ/pℤ$$, then the size of\n`s + t` is lower-bounded by `|s| + |t| - 1`, unless this quantity is greater than `p`. -/\nlemma ZMod.cauchy_davenport {p : ℕ} (hp : p.Prime) {s t : Finset (ZMod p)} (hs : s.Nonempty)\n    (ht : t.Nonempty) : min p (#s + #t - 1) ≤ #(s + t) := by\n  simpa only [ZMod.minOrder_of_prime hp, min_le_iff, Nat.cast_le]\n    using cauchy_davenport_minOrder_add hs ht\n\n"}
{"name":"cauchy_davenport_add_of_linearOrder_isAddCancel","module":"Mathlib.Combinatorics.Additive.CauchyDavenport","initialProofState":"α : Type u_1\ninst✝⁴ : LinearOrder α\ninst✝³ : AddSemigroup α\ninst✝² : IsCancelAdd α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\ns t : Finset α\nhs : s.Nonempty\nht : t.Nonempty\n⊢ LE.le (HSub.hSub (HAdd.hAdd s.card t.card) 1) (HAdd.hAdd s t).card","decl":"/-- The **Cauchy-Davenport Theorem** for linearly ordered cancellative semigroups. The size of\n`s * t` is lower-bounded by `|s| + |t| - 1`. -/\n@[to_additive\n\"The **Cauchy-Davenport theorem** for linearly ordered additive cancellative semigroups. The size of\n`s + t` is lower-bounded by `|s| + |t| - 1`.\"]\nlemma cauchy_davenport_mul_of_linearOrder_isCancelMul [LinearOrder α] [Semigroup α] [IsCancelMul α]\n    [MulLeftMono α] [MulRightMono α]\n    {s t : Finset α} (hs : s.Nonempty) (ht : t.Nonempty) : #s + #t - 1 ≤ #(s * t) := by\n  suffices s * {t.min' ht} ∩ ({s.max' hs} * t) = {s.max' hs * t.min' ht} by\n    rw [← card_singleton_mul (s.max' hs) t, ← card_mul_singleton s (t.min' ht),\n      ← card_union_add_card_inter, ← card_singleton _, ← this, Nat.add_sub_cancel]\n    exact card_mono (union_subset (mul_subset_mul_left <| singleton_subset_iff.2 <| min'_mem _ _) <|\n      mul_subset_mul_right <| singleton_subset_iff.2 <| max'_mem _ _)\n  refine eq_singleton_iff_unique_mem.2 ⟨mem_inter.2 ⟨mul_mem_mul (max'_mem _ _) <|\n    mem_singleton_self _, mul_mem_mul (mem_singleton_self _) <| min'_mem _ _⟩, ?_⟩\n  simp only [mem_inter, and_imp, mem_mul, mem_singleton, exists_and_left, exists_eq_left,\n    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, mul_left_inj]\n  exact fun a' ha' b' hb' h ↦ (le_max' _ _ ha').eq_of_not_lt fun ha ↦\n    ((mul_lt_mul_right' ha _).trans_eq' h).not_le <| mul_le_mul_left' (min'_le _ _ hb') _\n"}
{"name":"cauchy_davenport_mul_of_linearOrder_isCancelMul","module":"Mathlib.Combinatorics.Additive.CauchyDavenport","initialProofState":"α : Type u_1\ninst✝⁴ : LinearOrder α\ninst✝³ : Semigroup α\ninst✝² : IsCancelMul α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\ns t : Finset α\nhs : s.Nonempty\nht : t.Nonempty\n⊢ LE.le (HSub.hSub (HAdd.hAdd s.card t.card) 1) (HMul.hMul s t).card","decl":"/-- The **Cauchy-Davenport Theorem** for linearly ordered cancellative semigroups. The size of\n`s * t` is lower-bounded by `|s| + |t| - 1`. -/\n@[to_additive\n\"The **Cauchy-Davenport theorem** for linearly ordered additive cancellative semigroups. The size of\n`s + t` is lower-bounded by `|s| + |t| - 1`.\"]\nlemma cauchy_davenport_mul_of_linearOrder_isCancelMul [LinearOrder α] [Semigroup α] [IsCancelMul α]\n    [MulLeftMono α] [MulRightMono α]\n    {s t : Finset α} (hs : s.Nonempty) (ht : t.Nonempty) : #s + #t - 1 ≤ #(s * t) := by\n  suffices s * {t.min' ht} ∩ ({s.max' hs} * t) = {s.max' hs * t.min' ht} by\n    rw [← card_singleton_mul (s.max' hs) t, ← card_mul_singleton s (t.min' ht),\n      ← card_union_add_card_inter, ← card_singleton _, ← this, Nat.add_sub_cancel]\n    exact card_mono (union_subset (mul_subset_mul_left <| singleton_subset_iff.2 <| min'_mem _ _) <|\n      mul_subset_mul_right <| singleton_subset_iff.2 <| max'_mem _ _)\n  refine eq_singleton_iff_unique_mem.2 ⟨mem_inter.2 ⟨mul_mem_mul (max'_mem _ _) <|\n    mem_singleton_self _, mul_mem_mul (mem_singleton_self _) <| min'_mem _ _⟩, ?_⟩\n  simp only [mem_inter, and_imp, mem_mul, mem_singleton, exists_and_left, exists_eq_left,\n    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, mul_left_inj]\n  exact fun a' ha' b' hb' h ↦ (le_max' _ _ ha').eq_of_not_lt fun ha ↦\n    ((mul_lt_mul_right' ha _).trans_eq' h).not_le <| mul_le_mul_left' (min'_le _ _ hb') _\n"}
