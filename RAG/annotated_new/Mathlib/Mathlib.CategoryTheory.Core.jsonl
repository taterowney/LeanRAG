{"name":"CategoryTheory.Core.id_hom","module":"Mathlib.CategoryTheory.Core","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.id X).hom (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\n/- Porting note: abomination -/\ntheorem id_hom (X : C) : Iso.hom (coreCategory.id X) = @CategoryStruct.id C _ X := by\n  rfl\n\n"}
{"name":"CategoryTheory.Core.comp_hom","module":"Mathlib.CategoryTheory.Core","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : CategoryTheory.Core C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"@[simp]\ntheorem comp_hom {X Y Z : Core C} (f : X ⟶ Y) (g : Y ⟶ Z) : (f ≫ g).hom = f.hom ≫ g.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Core.instFaithfulInclusion","module":"Mathlib.CategoryTheory.Core","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ (CategoryTheory.Core.inclusion C).Faithful","decl":"instance : (inclusion C).Faithful where\n  map_injective := by\n    intro _ _\n    apply Iso.ext\n\n"}
