{"name":"EisensteinSeries.norm_eq_max_natAbs","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.UniformConvergence","initialProofState":"x : Fin 2 → Int\n⊢ Eq (Norm.norm x) ↑(Max.max (x 0).natAbs (x 1).natAbs)","decl":"lemma norm_eq_max_natAbs (x : Fin 2 → ℤ) : ‖x‖ = max (x 0).natAbs (x 1).natAbs := by\n  rw [← coe_nnnorm, ← NNReal.coe_natCast, NNReal.coe_inj, Nat.cast_max]\n  refine eq_of_forall_ge_iff fun c ↦ ?_\n  simp only [pi_nnnorm_le_iff, Fin.forall_fin_two, max_le_iff, NNReal.natCast_natAbs]\n\n"}
{"name":"EisensteinSeries.r1_eq","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.UniformConvergence","initialProofState":"z : UpperHalfPlane\n⊢ Eq (EisensteinSeries.r1 z) (HDiv.hDiv 1 (HAdd.hAdd (HPow.hPow (HDiv.hDiv z.re z.im) 2) 1))","decl":"lemma r1_eq : r1 z = 1 / ((z.re / z.im) ^ 2 + 1) := by\n  rw [div_pow, div_add_one (by positivity), one_div_div, r1]\n\n"}
{"name":"EisensteinSeries.r1_pos","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.UniformConvergence","initialProofState":"z : UpperHalfPlane\n⊢ LT.lt 0 (EisensteinSeries.r1 z)","decl":"lemma r1_pos : 0 < r1 z := by\n  dsimp only [r1]\n  positivity\n\n"}
{"name":"EisensteinSeries.r1_aux_bound","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.UniformConvergence","initialProofState":"z : UpperHalfPlane\nc d : Real\nhd : LE.le 1 (HPow.hPow d 2)\n⊢ LE.le (EisensteinSeries.r1 z) (HAdd.hAdd (HPow.hPow (HAdd.hAdd (HMul.hMul c z.re) d) 2) (HPow.hPow (HMul.hMul c z.im) 2))","decl":"/-- For `c, d ∈ ℝ` with `1 ≤ d ^ 2`, we have `r1 z ≤ |c * z + d| ^ 2`. -/\nlemma r1_aux_bound (c : ℝ) {d : ℝ} (hd : 1 ≤ d ^ 2) :\n    r1 z ≤ (c * z.re + d) ^ 2 + (c * z.im) ^ 2 := by\n  have H1 : (c * z.re + d) ^ 2 + (c * z.im) ^ 2 =\n    c ^ 2 * (z.re ^ 2 + z.im ^ 2) + d * 2 * c * z.re + d ^ 2 := by ring\n  have H2 : (c ^ 2 * (z.re ^ 2 + z.im ^ 2) + d * 2 * c * z.re + d ^ 2) * (z.re ^ 2 + z.im ^ 2)\n    - z.im ^ 2 = (c * (z.re ^ 2 + z.im ^ 2) + d * z.re) ^ 2 + (d ^ 2 - 1) * z.im ^ 2 := by ring\n  rw [r1, H1, div_le_iff₀ (by positivity), ← sub_nonneg, H2]\n  exact add_nonneg (sq_nonneg _) (mul_nonneg (sub_nonneg.mpr hd) (sq_nonneg _))\n\n"}
{"name":"EisensteinSeries.r_pos","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.UniformConvergence","initialProofState":"z : UpperHalfPlane\n⊢ LT.lt 0 (EisensteinSeries.r z)","decl":"lemma r_pos : 0 < r z := by\n  simp only [r, lt_min_iff, im_pos, Real.sqrt_pos, r1_pos, and_self]\n\n"}
{"name":"EisensteinSeries.r_lower_bound_on_verticalStrip","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.UniformConvergence","initialProofState":"z : UpperHalfPlane\nA B : Real\nh : LT.lt 0 B\nhz : Membership.mem (UpperHalfPlane.verticalStrip A B) z\n⊢ LE.le (EisensteinSeries.r ⟨{ re := A, im := B }, h⟩) (EisensteinSeries.r z)","decl":"lemma r_lower_bound_on_verticalStrip {A B : ℝ} (h : 0 < B) (hz : z ∈ verticalStrip A B) :\n    r ⟨⟨A, B⟩, h⟩ ≤ r z := by\n  apply min_le_min hz.2\n  rw [Real.sqrt_le_sqrt_iff (by apply (r1_pos z).le)]\n  simp only [r1_eq, div_pow, one_div]\n  rw [inv_le_inv₀ (by positivity) (by positivity), add_le_add_iff_right, ← even_two.pow_abs]\n  gcongr\n  exacts [hz.1, hz.2]\n\n"}
{"name":"EisensteinSeries.auxbound1","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.UniformConvergence","initialProofState":"z : UpperHalfPlane\nc d : Real\nhc : LE.le 1 (HPow.hPow c 2)\n⊢ LE.le (EisensteinSeries.r z) (Complex.abs (HAdd.hAdd (HMul.hMul ↑c ↑z) ↑d))","decl":"lemma auxbound1 {c : ℝ} (d : ℝ) (hc : 1 ≤ c ^ 2) : r z ≤ Complex.abs (c * z + d) := by\n  rcases z with ⟨z, hz⟩\n  have H1 : z.im ≤ √((c * z.re + d) ^ 2 + (c * z).im ^ 2) := by\n    rw [Real.le_sqrt' hz, im_ofReal_mul, mul_pow]\n    exact (le_mul_of_one_le_left (sq_nonneg _) hc).trans <| le_add_of_nonneg_left (sq_nonneg _)\n  simpa only [r, abs_apply, normSq_apply, add_re, re_ofReal_mul, coe_re, ← pow_two, add_im, mul_im,\n    coe_im, ofReal_im, zero_mul, add_zero, min_le_iff] using Or.inl H1\n\n"}
{"name":"EisensteinSeries.auxbound2","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.UniformConvergence","initialProofState":"z : UpperHalfPlane\nc d : Real\nhd : LE.le 1 (HPow.hPow d 2)\n⊢ LE.le (EisensteinSeries.r z) (Complex.abs (HAdd.hAdd (HMul.hMul ↑c ↑z) ↑d))","decl":"lemma auxbound2 (c : ℝ) {d : ℝ} (hd : 1 ≤ d ^ 2) : r z ≤ Complex.abs (c * z + d) := by\n  have H1 : √(r1 z) ≤ √((c * z.re + d) ^ 2 + (c * z.im) ^ 2) :=\n    (Real.sqrt_le_sqrt_iff (by positivity)).mpr (r1_aux_bound _ _ hd)\n  simpa only [r, abs_apply, normSq_apply, add_re, re_ofReal_mul, coe_re, ofReal_re, ← pow_two,\n    add_im, im_ofReal_mul, coe_im, ofReal_im, add_zero, min_le_iff] using Or.inr H1\n\n"}
{"name":"EisensteinSeries.div_max_sq_ge_one","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.UniformConvergence","initialProofState":"x : Fin 2 → Int\nhx : Ne x 0\n⊢ Or (LE.le 1 (HPow.hPow (HDiv.hDiv (↑(x 0)) (Norm.norm x)) 2)) (LE.le 1 (HPow.hPow (HDiv.hDiv (↑(x 1)) (Norm.norm x)) 2))","decl":"lemma div_max_sq_ge_one (x : Fin 2 → ℤ) (hx : x ≠ 0) :\n    1 ≤ (x 0 / ‖x‖) ^ 2 ∨ 1 ≤ (x 1 / ‖x‖) ^ 2 := by\n  refine (max_choice (x 0).natAbs (x 1).natAbs).imp (fun H0 ↦ ?_) (fun H1 ↦ ?_)\n  · have : x 0 ≠ 0 := by\n      rwa [← norm_ne_zero_iff, norm_eq_max_natAbs, H0, Nat.cast_ne_zero, Int.natAbs_ne_zero] at hx\n    simp only [norm_eq_max_natAbs, H0, Int.cast_natAbs, Int.cast_abs, div_pow, _root_.sq_abs, ne_eq,\n      OfNat.ofNat_ne_zero, not_false_eq_true, pow_eq_zero_iff, Int.cast_eq_zero, this, div_self,\n      le_refl]\n  · have : x 1 ≠ 0 := by\n      rwa [← norm_ne_zero_iff, norm_eq_max_natAbs, H1, Nat.cast_ne_zero, Int.natAbs_ne_zero] at hx\n    simp only [norm_eq_max_natAbs, H1, Int.cast_natAbs, Int.cast_abs, div_pow, _root_.sq_abs, ne_eq,\n      OfNat.ofNat_ne_zero, not_false_eq_true, pow_eq_zero_iff, Int.cast_eq_zero, this, div_self,\n      le_refl]\n\n"}
{"name":"EisensteinSeries.r_mul_max_le","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.UniformConvergence","initialProofState":"z : UpperHalfPlane\nx : Fin 2 → Int\nhx : Ne x 0\n⊢ LE.le (HMul.hMul (EisensteinSeries.r z) (Norm.norm x)) (Complex.abs (HAdd.hAdd (HMul.hMul ↑(x 0) ↑z) ↑(x 1)))","decl":"lemma r_mul_max_le {x : Fin 2 → ℤ} (hx : x ≠ 0) : r z * ‖x‖ ≤ Complex.abs (x 0 * z + x 1) := by\n  have hn0 : ‖x‖ ≠ 0 := by rwa [norm_ne_zero_iff]\n  have h11 : x 0 * (z : ℂ) + x 1 = (x 0 / ‖x‖ * z + x 1 / ‖x‖) * ‖x‖ := by\n    rw [div_mul_eq_mul_div, ← add_div, div_mul_cancel₀ _ (mod_cast hn0)]\n  rw [norm_eq_max_natAbs, h11, map_mul, Complex.abs_ofReal, abs_norm, norm_eq_max_natAbs]\n  gcongr\n  · rcases div_max_sq_ge_one x hx with H1 | H2\n    · simpa only [norm_eq_max_natAbs, ofReal_div, ofReal_intCast] using auxbound1 z (x 1 / ‖x‖) H1\n    · simpa only [norm_eq_max_natAbs, ofReal_div, ofReal_intCast] using auxbound2 z (x 0 / ‖x‖) H2\n\n"}
{"name":"EisensteinSeries.summand_bound","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.UniformConvergence","initialProofState":"z : UpperHalfPlane\nk : Real\nhk : LE.le 0 k\nx : Fin 2 → Int\n⊢ LE.le (HPow.hPow (Complex.abs (HAdd.hAdd (HMul.hMul ↑(x 0) ↑z) ↑(x 1))) (Neg.neg k)) (HMul.hMul (HPow.hPow (EisensteinSeries.r z) (Neg.neg k)) (HPow.hPow (Norm.norm x) (Neg.neg k)))","decl":"/-- Upper bound for the summand `|c * z + d| ^ (-k)`, as a product of a function of `z` and a\nfunction of `c, d`. -/\nlemma summand_bound {k : ℝ} (hk : 0 ≤ k) (x : Fin 2 → ℤ) :\n    Complex.abs (x 0 * z + x 1) ^ (-k) ≤ (r z) ^ (-k) * ‖x‖ ^ (-k) := by\n  by_cases hx : x = 0\n  · simp only [hx, Pi.zero_apply, Int.cast_zero, zero_mul, add_zero, ← norm_eq_abs, norm_zero]\n    by_cases h : -k = 0\n    · rw [h, Real.rpow_zero, Real.rpow_zero, one_mul]\n    · rw [Real.zero_rpow h, mul_zero]\n  · rw [← Real.mul_rpow (r_pos _).le (norm_nonneg _)]\n    exact Real.rpow_le_rpow_of_nonpos (mul_pos (r_pos _) (norm_pos_iff.mpr hx)) (r_mul_max_le z hx)\n      (neg_nonpos.mpr hk)\n\n"}
{"name":"EisensteinSeries.summand_bound_of_mem_verticalStrip","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.UniformConvergence","initialProofState":"z : UpperHalfPlane\nk : Real\nhk : LE.le 0 k\nx : Fin 2 → Int\nA B : Real\nhB : LT.lt 0 B\nhz : Membership.mem (UpperHalfPlane.verticalStrip A B) z\n⊢ LE.le (HPow.hPow (Complex.abs (HAdd.hAdd (HMul.hMul ↑(x 0) ↑z) ↑(x 1))) (Neg.neg k)) (HMul.hMul (HPow.hPow (EisensteinSeries.r ⟨{ re := A, im := B }, hB⟩) (Neg.neg k)) (HPow.hPow (Norm.norm x) (Neg.neg k)))","decl":"variable {z} in\nlemma summand_bound_of_mem_verticalStrip {k : ℝ} (hk : 0 ≤ k) (x : Fin 2 → ℤ)\n    {A B : ℝ} (hB : 0 < B) (hz : z ∈ verticalStrip A B) :\n    Complex.abs (x 0 * z + x 1) ^ (-k) ≤ r ⟨⟨A, B⟩, hB⟩ ^ (-k) * ‖x‖ ^ (-k) := by\n  refine (summand_bound z hk x).trans (mul_le_mul_of_nonneg_right ?_ (by positivity))\n  exact Real.rpow_le_rpow_of_nonpos (r_pos _) (r_lower_bound_on_verticalStrip z hB hz)\n    (neg_nonpos.mpr hk)\n\n"}
{"name":"EisensteinSeries.summable_one_div_norm_rpow","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.UniformConvergence","initialProofState":"k : Real\nhk : LT.lt 2 k\n⊢ Summable fun x => HPow.hPow (Norm.norm x) (Neg.neg k)","decl":"/-- The function `ℤ ^ 2 → ℝ` given by `x ↦ ‖x‖ ^ (-k)` is summable if `2 < k`. We prove this by\nsplitting into boxes using `Finset.box`. -/\nlemma summable_one_div_norm_rpow {k : ℝ} (hk : 2 < k) :\n    Summable fun (x : Fin 2 → ℤ) ↦ ‖x‖ ^ (-k) := by\n  rw [← (finTwoArrowEquiv _).symm.summable_iff, summable_partition _ Int.existsUnique_mem_box]\n  · simp only [finTwoArrowEquiv_symm_apply, Function.comp_def]\n    refine ⟨fun n ↦ (hasSum_fintype (β := box (α := ℤ × ℤ) n) _).summable, ?_⟩\n    suffices Summable fun n : ℕ ↦ ∑' (_ : box (α := ℤ × ℤ) n), (n : ℝ) ^ (-k) by\n      refine this.congr fun n ↦ tsum_congr fun p ↦ ?_\n      simp only [← Int.mem_box.mp p.2, Nat.cast_max, norm_eq_max_natAbs, Matrix.cons_val_zero,\n        Matrix.cons_val_one, Matrix.head_cons]\n    simp only [tsum_fintype, univ_eq_attach, sum_const, card_attach, nsmul_eq_mul]\n    apply ((Real.summable_nat_rpow.mpr (by linarith : 1 - k < -1)).mul_left\n      8).of_norm_bounded_eventually_nat\n    filter_upwards [Filter.eventually_gt_atTop 0] with n hn\n    rw [Int.card_box hn.ne', Real.norm_of_nonneg (by positivity), sub_eq_add_neg,\n      Real.rpow_add (Nat.cast_pos.mpr hn), Real.rpow_one, Nat.cast_mul, Nat.cast_ofNat, mul_assoc]\n  · exact fun n ↦ Real.rpow_nonneg (norm_nonneg _) _\n\n"}
{"name":"EisensteinSeries.eisensteinSeries_tendstoLocallyUniformly","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.UniformConvergence","initialProofState":"k : Int\nhk : LE.le 3 k\nN : Nat\na : Fin 2 → ZMod N\n⊢ TendstoLocallyUniformly (fun s x => s.sum fun x_1 => EisensteinSeries.eisSummand k (↑x_1) x) (fun x => eisensteinSeries a k x) Filter.atTop","decl":"/-- The sum defining the Eisenstein series (of weight `k` and level `Γ(N)` with congruence\ncondition `a : Fin 2 → ZMod N`) converges locally uniformly on `ℍ`. -/\ntheorem eisensteinSeries_tendstoLocallyUniformly {k : ℤ} (hk : 3 ≤ k) {N : ℕ} (a : Fin 2 → ZMod N) :\n    TendstoLocallyUniformly (fun (s : Finset (gammaSet N a)) ↦ (∑ x ∈ s, eisSummand k x ·))\n      (eisensteinSeries a k ·) Filter.atTop := by\n  have hk' : (2 : ℝ) < k := by norm_cast\n  have p_sum : Summable fun x : gammaSet N a ↦ ‖x.val‖ ^ (-k) :=\n    mod_cast (summable_one_div_norm_rpow hk').subtype (gammaSet N a)\n  simp only [tendstoLocallyUniformly_iff_forall_isCompact, eisensteinSeries]\n  intro K hK\n  obtain ⟨A, B, hB, HABK⟩ := subset_verticalStrip_of_isCompact hK\n  refine (tendstoUniformlyOn_tsum (hu := p_sum.mul_left <| r ⟨⟨A, B⟩, hB⟩ ^ (-k : ℝ))\n    (fun p z hz ↦ ?_)).mono HABK\n  simpa only [eisSummand, one_div, ← zpow_neg, norm_eq_abs, abs_zpow, ← Real.rpow_intCast,\n    Int.cast_neg] using summand_bound_of_mem_verticalStrip (by positivity) p hB hz\n\n"}
{"name":"EisensteinSeries.eisensteinSeries_tendstoLocallyUniformlyOn","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.UniformConvergence","initialProofState":"k : Int\nN : Nat\nhk : LE.le 3 k\na : Fin 2 → ZMod N\n⊢ TendstoLocallyUniformlyOn (fun s => Function.comp (fun z => s.sum fun x => EisensteinSeries.eisSummand k (↑x) z) ↑UpperHalfPlane.ofComplex) (Function.comp (EisensteinSeries.eisensteinSeries_SIF a k).toFun ↑UpperHalfPlane.ofComplex) Filter.atTop (setOf fun z => LT.lt 0 z.im)","decl":"/-- Variant of `eisensteinSeries_tendstoLocallyUniformly` formulated with maps `ℂ → ℂ`, which is\nnice to have for holomorphicity later. -/\nlemma eisensteinSeries_tendstoLocallyUniformlyOn {k : ℤ} {N : ℕ} (hk : 3 ≤ k)\n    (a : Fin 2 → ZMod N) : TendstoLocallyUniformlyOn (fun (s : Finset (gammaSet N a )) ↦\n      ↑ₕ(fun (z : ℍ) ↦ ∑ x ∈ s, eisSummand k x z)) (↑ₕ(eisensteinSeries_SIF a k).toFun)\n          Filter.atTop {z : ℂ | 0 < z.im} := by\n  rw [← Subtype.coe_image_univ {z : ℂ | 0 < z.im}]\n  apply TendstoLocallyUniformlyOn.comp (s := ⊤) _ _ _ (PartialHomeomorph.continuousOn_symm _)\n  · simp only [SlashInvariantForm.toFun_eq_coe, Set.top_eq_univ, tendstoLocallyUniformlyOn_univ]\n    apply eisensteinSeries_tendstoLocallyUniformly hk\n  · simp only [IsOpenEmbedding.toPartialHomeomorph_target, Set.top_eq_univ, mapsTo_range_iff,\n    Set.mem_univ, forall_const]\n\n"}
