{"name":"MvPFunctor.WPath.root.inj","module":"Mathlib.Data.PFunctor.Multivariate.W","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\na : P.A\nf : P.last.B a → P.last.W\ni : Fin2 n\nc✝ c : P.drop.B a i\nx✝ : Eq (MvPFunctor.WPath.root a f i c✝) (MvPFunctor.WPath.root a f i c)\n⊢ Eq c✝ c","decl":"/-- A path from the root of a tree to one of its node -/\ninductive WPath : P.last.W → Fin2 n → Type u\n  | root (a : P.A) (f : P.last.B a → P.last.W) (i : Fin2 n) (c : P.drop.B a i) : WPath ⟨a, f⟩ i\n  | child (a : P.A) (f : P.last.B a → P.last.W) (i : Fin2 n) (j : P.last.B a)\n    (c : WPath (f j) i) : WPath ⟨a, f⟩ i\n\n"}
{"name":"MvPFunctor.WPath.child.injEq","module":"Mathlib.Data.PFunctor.Multivariate.W","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\na : P.A\nf : P.last.B a → P.last.W\ni : Fin2 n\nj✝ : P.last.B a\nc✝ : P.WPath (f j✝) i\nj : P.last.B a\nc : P.WPath (f j) i\n⊢ Eq (Eq (MvPFunctor.WPath.child a f i j✝ c✝) (MvPFunctor.WPath.child a f i j c)) (And (Eq j✝ j) (HEq c✝ c))","decl":"/-- A path from the root of a tree to one of its node -/\ninductive WPath : P.last.W → Fin2 n → Type u\n  | root (a : P.A) (f : P.last.B a → P.last.W) (i : Fin2 n) (c : P.drop.B a i) : WPath ⟨a, f⟩ i\n  | child (a : P.A) (f : P.last.B a → P.last.W) (i : Fin2 n) (j : P.last.B a)\n    (c : WPath (f j) i) : WPath ⟨a, f⟩ i\n\n"}
{"name":"MvPFunctor.WPath.child.inj","module":"Mathlib.Data.PFunctor.Multivariate.W","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\na : P.A\nf : P.last.B a → P.last.W\ni : Fin2 n\nj✝ : P.last.B a\nc✝ : P.WPath (f j✝) i\nj : P.last.B a\nc : P.WPath (f j) i\nx✝ : Eq (MvPFunctor.WPath.child a f i j✝ c✝) (MvPFunctor.WPath.child a f i j c)\n⊢ And (Eq j✝ j) (HEq c✝ c)","decl":"/-- A path from the root of a tree to one of its node -/\ninductive WPath : P.last.W → Fin2 n → Type u\n  | root (a : P.A) (f : P.last.B a → P.last.W) (i : Fin2 n) (c : P.drop.B a i) : WPath ⟨a, f⟩ i\n  | child (a : P.A) (f : P.last.B a → P.last.W) (i : Fin2 n) (j : P.last.B a)\n    (c : WPath (f j) i) : WPath ⟨a, f⟩ i\n\n"}
{"name":"MvPFunctor.WPath.child.sizeOf_spec","module":"Mathlib.Data.PFunctor.Multivariate.W","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\na : P.A\nf : P.last.B a → P.last.W\ni : Fin2 n\nj : P.last.B a\nc : P.WPath (f j) i\n⊢ Eq (SizeOf.sizeOf (MvPFunctor.WPath.child a f i j c)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf i)) (SizeOf.sizeOf j)) (SizeOf.sizeOf c))","decl":"/-- A path from the root of a tree to one of its node -/\ninductive WPath : P.last.W → Fin2 n → Type u\n  | root (a : P.A) (f : P.last.B a → P.last.W) (i : Fin2 n) (c : P.drop.B a i) : WPath ⟨a, f⟩ i\n  | child (a : P.A) (f : P.last.B a → P.last.W) (i : Fin2 n) (j : P.last.B a)\n    (c : WPath (f j) i) : WPath ⟨a, f⟩ i\n\n"}
{"name":"MvPFunctor.WPath.root.injEq","module":"Mathlib.Data.PFunctor.Multivariate.W","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\na : P.A\nf : P.last.B a → P.last.W\ni : Fin2 n\nc✝ c : P.drop.B a i\n⊢ Eq (Eq (MvPFunctor.WPath.root a f i c✝) (MvPFunctor.WPath.root a f i c)) (Eq c✝ c)","decl":"/-- A path from the root of a tree to one of its node -/\ninductive WPath : P.last.W → Fin2 n → Type u\n  | root (a : P.A) (f : P.last.B a → P.last.W) (i : Fin2 n) (c : P.drop.B a i) : WPath ⟨a, f⟩ i\n  | child (a : P.A) (f : P.last.B a → P.last.W) (i : Fin2 n) (j : P.last.B a)\n    (c : WPath (f j) i) : WPath ⟨a, f⟩ i\n\n"}
{"name":"MvPFunctor.WPath.root.sizeOf_spec","module":"Mathlib.Data.PFunctor.Multivariate.W","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\na : P.A\nf : P.last.B a → P.last.W\ni : Fin2 n\nc : P.drop.B a i\n⊢ Eq (SizeOf.sizeOf (MvPFunctor.WPath.root a f i c)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf i)) (SizeOf.sizeOf c))","decl":"/-- A path from the root of a tree to one of its node -/\ninductive WPath : P.last.W → Fin2 n → Type u\n  | root (a : P.A) (f : P.last.B a → P.last.W) (i : Fin2 n) (c : P.drop.B a i) : WPath ⟨a, f⟩ i\n  | child (a : P.A) (f : P.last.B a → P.last.W) (i : Fin2 n) (j : P.last.B a)\n    (c : WPath (f j) i) : WPath ⟨a, f⟩ i\n\n"}
{"name":"MvPFunctor.wPathDestLeft_wPathCasesOn","module":"Mathlib.Data.PFunctor.Multivariate.W","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα : TypeVec.{u_1} n\na : P.A\nf : P.last.B a → P.last.W\ng' : (P.drop.B a).Arrow α\ng : (j : P.last.B a) → TypeVec.Arrow (P.WPath (f j)) α\n⊢ Eq (P.wPathDestLeft (P.wPathCasesOn g' g)) g'","decl":"theorem wPathDestLeft_wPathCasesOn {α : TypeVec n} {a : P.A} {f : P.last.B a → P.last.W}\n    (g' : P.drop.B a ⟹ α) (g : ∀ j : P.last.B a, P.WPath (f j) ⟹ α) :\n    P.wPathDestLeft (P.wPathCasesOn g' g) = g' := rfl\n\n"}
{"name":"MvPFunctor.wPathDestRight_wPathCasesOn","module":"Mathlib.Data.PFunctor.Multivariate.W","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα : TypeVec.{u_1} n\na : P.A\nf : P.last.B a → P.last.W\ng' : (P.drop.B a).Arrow α\ng : (j : P.last.B a) → TypeVec.Arrow (P.WPath (f j)) α\n⊢ Eq (P.wPathDestRight (P.wPathCasesOn g' g)) g","decl":"theorem wPathDestRight_wPathCasesOn {α : TypeVec n} {a : P.A} {f : P.last.B a → P.last.W}\n    (g' : P.drop.B a ⟹ α) (g : ∀ j : P.last.B a, P.WPath (f j) ⟹ α) :\n    P.wPathDestRight (P.wPathCasesOn g' g) = g := rfl\n\n"}
{"name":"MvPFunctor.wPathCasesOn_eta","module":"Mathlib.Data.PFunctor.Multivariate.W","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα : TypeVec.{u_1} n\na : P.A\nf : P.last.B a → P.last.W\nh : TypeVec.Arrow (P.WPath (WType.mk a f)) α\n⊢ Eq (P.wPathCasesOn (P.wPathDestLeft h) (P.wPathDestRight h)) h","decl":"theorem wPathCasesOn_eta {α : TypeVec n} {a : P.A} {f : P.last.B a → P.last.W}\n    (h : P.WPath ⟨a, f⟩ ⟹ α) : P.wPathCasesOn (P.wPathDestLeft h) (P.wPathDestRight h) = h := by\n  ext i x; cases x <;> rfl\n\n"}
{"name":"MvPFunctor.comp_wPathCasesOn","module":"Mathlib.Data.PFunctor.Multivariate.W","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα : TypeVec.{u_1} n\nβ : TypeVec.{u_2} n\nh : α.Arrow β\na : P.A\nf : P.last.B a → P.last.W\ng' : (P.drop.B a).Arrow α\ng : (j : P.last.B a) → TypeVec.Arrow (P.WPath (f j)) α\n⊢ Eq (TypeVec.comp h (P.wPathCasesOn g' g)) (P.wPathCasesOn (TypeVec.comp h g') fun i => TypeVec.comp h (g i))","decl":"theorem comp_wPathCasesOn {α β : TypeVec n} (h : α ⟹ β) {a : P.A} {f : P.last.B a → P.last.W}\n    (g' : P.drop.B a ⟹ α) (g : ∀ j : P.last.B a, P.WPath (f j) ⟹ α) :\n    h ⊚ P.wPathCasesOn g' g = P.wPathCasesOn (h ⊚ g') fun i => h ⊚ g i := by\n  ext i x; cases x <;> rfl\n\n"}
{"name":"MvPFunctor.wpRec_eq","module":"Mathlib.Data.PFunctor.Multivariate.W","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα : TypeVec.{u_2} n\nC : Type u_1\ng : (a : P.A) → (f : P.last.B a → P.last.W) → TypeVec.Arrow (P.WPath (WType.mk a f)) α → (P.last.B a → C) → C\na : P.A\nf : P.last.B a → P.last.W\nf' : TypeVec.Arrow (P.WPath (WType.mk a f)) α\n⊢ Eq (P.wpRec g (WType.mk a f) f') (g a f f' fun i => P.wpRec g (f i) (P.wPathDestRight f' i))","decl":"theorem wpRec_eq {α : TypeVec n} {C : Type*}\n    (g : ∀ (a : P.A) (f : P.last.B a → P.last.W), P.WPath ⟨a, f⟩ ⟹ α → (P.last.B a → C) → C)\n    (a : P.A) (f : P.last.B a → P.last.W) (f' : P.WPath ⟨a, f⟩ ⟹ α) :\n    P.wpRec g ⟨a, f⟩ f' = g a f f' fun i => P.wpRec g (f i) (P.wPathDestRight f' i) := rfl\n\n-- Note: we could replace Prop by Type* and obtain a dependent recursor\n"}
{"name":"MvPFunctor.wp_ind","module":"Mathlib.Data.PFunctor.Multivariate.W","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα : TypeVec.{u_1} n\nC : (x : P.last.W) → TypeVec.Arrow (P.WPath x) α → Prop\nih : ∀ (a : P.A) (f : P.last.B a → P.last.W) (f' : TypeVec.Arrow (P.WPath (WType.mk a f)) α), (∀ (i : P.last.B a), C (f i) (P.wPathDestRight f' i)) → C (WType.mk a f) f'\nx : P.last.W\nf' : TypeVec.Arrow (P.WPath x) α\n⊢ C x f'","decl":"theorem wp_ind {α : TypeVec n} {C : ∀ x : P.last.W, P.WPath x ⟹ α → Prop}\n    (ih : ∀ (a : P.A) (f : P.last.B a → P.last.W) (f' : P.WPath ⟨a, f⟩ ⟹ α),\n        (∀ i : P.last.B a, C (f i) (P.wPathDestRight f' i)) → C ⟨a, f⟩ f') :\n    ∀ (x : P.last.W) (f' : P.WPath x ⟹ α), C x f'\n  | ⟨a, f⟩, f' => ih a f f' fun _i => wp_ind ih _ _\n\n"}
{"name":"MvPFunctor.wRec_eq","module":"Mathlib.Data.PFunctor.Multivariate.W","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα : TypeVec.{u} n\nC : Type u_1\ng : (a : P.A) → (P.drop.B a).Arrow α → (P.last.B a → P.W α) → (P.last.B a → C) → C\na : P.A\nf' : (P.drop.B a).Arrow α\nf : P.last.B a → P.W α\n⊢ Eq (P.wRec g (P.wMk a f' f)) (g a f' f fun i => P.wRec g (f i))","decl":"/-- Defining equation for the recursor of `W` -/\ntheorem wRec_eq {α : TypeVec n} {C : Type*}\n    (g : ∀ a : P.A, P.drop.B a ⟹ α → (P.last.B a → P.W α) → (P.last.B a → C) → C) (a : P.A)\n    (f' : P.drop.B a ⟹ α) (f : P.last.B a → P.W α) :\n    P.wRec g (P.wMk a f' f) = g a f' f fun i => P.wRec g (f i) := by\n  rw [wMk, wRec]; rw [wpRec_eq]\n  dsimp only [wPathDestLeft_wPathCasesOn, wPathDestRight_wPathCasesOn]\n  congr\n\n"}
{"name":"MvPFunctor.w_ind","module":"Mathlib.Data.PFunctor.Multivariate.W","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα : TypeVec.{u} n\nC : P.W α → Prop\nih : ∀ (a : P.A) (f' : (P.drop.B a).Arrow α) (f : P.last.B a → P.W α), (∀ (i : P.last.B a), C (f i)) → C (P.wMk a f' f)\nx : P.W α\n⊢ C x","decl":"/-- Induction principle for `W` -/\ntheorem w_ind {α : TypeVec n} {C : P.W α → Prop}\n    (ih : ∀ (a : P.A) (f' : P.drop.B a ⟹ α) (f : P.last.B a → P.W α),\n        (∀ i, C (f i)) → C (P.wMk a f' f)) :\n    ∀ x, C x := by\n  intro x; cases' x with a f\n  apply @wp_ind n P α fun a f => C ⟨a, f⟩\n  intro a f f' ih'\n  dsimp [wMk] at ih\n  let ih'' := ih a (P.wPathDestLeft f') fun i => ⟨f i, P.wPathDestRight f' i⟩\n  dsimp at ih''; rw [wPathCasesOn_eta] at ih''\n  apply ih''\n  apply ih'\n\n"}
{"name":"MvPFunctor.w_cases","module":"Mathlib.Data.PFunctor.Multivariate.W","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα : TypeVec.{u} n\nC : P.W α → Prop\nih : ∀ (a : P.A) (f' : (P.drop.B a).Arrow α) (f : P.last.B a → P.W α), C (P.wMk a f' f)\nx : P.W α\n⊢ C x","decl":"theorem w_cases {α : TypeVec n} {C : P.W α → Prop}\n    (ih : ∀ (a : P.A) (f' : P.drop.B a ⟹ α) (f : P.last.B a → P.W α), C (P.wMk a f' f)) :\n    ∀ x, C x := P.w_ind fun a f' f _ih' => ih a f' f\n\n"}
{"name":"MvPFunctor.wMk_eq","module":"Mathlib.Data.PFunctor.Multivariate.W","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα : TypeVec.{u} n\na : P.A\nf : P.last.B a → P.last.W\ng' : (P.drop.B a).Arrow α\ng : (j : P.last.B a) → TypeVec.Arrow (P.WPath (f j)) α\n⊢ Eq (P.wMk a g' fun i => ⟨f i, g i⟩) ⟨WType.mk a f, P.wPathCasesOn g' g⟩","decl":"theorem wMk_eq {α : TypeVec n} (a : P.A) (f : P.last.B a → P.last.W) (g' : P.drop.B a ⟹ α)\n    (g : ∀ j : P.last.B a, P.WPath (f j) ⟹ α) :\n    (P.wMk a g' fun i => ⟨f i, g i⟩) = ⟨⟨a, f⟩, P.wPathCasesOn g' g⟩ := rfl\n\n"}
{"name":"MvPFunctor.w_map_wMk","module":"Mathlib.Data.PFunctor.Multivariate.W","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα β : TypeVec.{u} n\ng : α.Arrow β\na : P.A\nf' : (P.drop.B a).Arrow α\nf : P.last.B a → P.W α\n⊢ Eq (MvFunctor.map g (P.wMk a f' f)) (P.wMk a (TypeVec.comp g f') fun i => MvFunctor.map g (f i))","decl":"theorem w_map_wMk {α β : TypeVec n} (g : α ⟹ β) (a : P.A) (f' : P.drop.B a ⟹ α)\n    (f : P.last.B a → P.W α) : g <$$> P.wMk a f' f = P.wMk a (g ⊚ f') fun i => g <$$> f i := by\n  show _ = P.wMk a (g ⊚ f') (MvFunctor.map g ∘ f)\n  have : MvFunctor.map g ∘ f = fun i => ⟨(f i).fst, g ⊚ (f i).snd⟩ := by\n    ext i : 1\n    dsimp [Function.comp_def]\n    cases f i\n    rfl\n  rw [this]\n  have : f = fun i => ⟨(f i).fst, (f i).snd⟩ := by\n    ext1 x\n    cases f x\n    rfl\n  rw [this]\n  dsimp\n  rw [wMk_eq, wMk_eq]\n  have h := MvPFunctor.map_eq P.wp g\n  rw [h, comp_wPathCasesOn]\n\n-- TODO: this technical theorem is used in one place in constructing the initial algebra.\n-- Can it be avoided?\n"}
{"name":"MvPFunctor.map_objAppend1","module":"Mathlib.Data.PFunctor.Multivariate.W","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα γ : TypeVec.{u} n\ng : α.Arrow γ\na : P.A\nf' : (P.drop.B a).Arrow α\nf : P.last.B a → P.W α\n⊢ Eq (MvFunctor.map (TypeVec.appendFun g (P.wMap g)) (P.objAppend1 a f' f)) (P.objAppend1 a (TypeVec.comp g f') fun x => P.wMap g (f x))","decl":"theorem map_objAppend1 {α γ : TypeVec n} (g : α ⟹ γ) (a : P.A) (f' : P.drop.B a ⟹ α)\n    (f : P.last.B a → P.W α) :\n    appendFun g (P.wMap g) <$$> P.objAppend1 a f' f =\n      P.objAppend1 a (g ⊚ f') fun x => P.wMap g (f x) := by\n  rw [objAppend1, objAppend1, map_eq, appendFun, ← splitFun_comp]; rfl\n\n"}
{"name":"MvPFunctor.wDest'_wMk","module":"Mathlib.Data.PFunctor.Multivariate.W","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα : TypeVec.{u} n\na : P.A\nf' : (P.drop.B a).Arrow α\nf : P.last.B a → P.W α\n⊢ Eq (P.wDest' (P.wMk a f' f)) ⟨a, TypeVec.splitFun f' f⟩","decl":"theorem wDest'_wMk {α : TypeVec n} (a : P.A) (f' : P.drop.B a ⟹ α) (f : P.last.B a → P.W α) :\n    P.wDest' (P.wMk a f' f) = ⟨a, splitFun f' f⟩ := by rw [wDest', wRec_eq]\n\n"}
{"name":"MvPFunctor.wDest'_wMk'","module":"Mathlib.Data.PFunctor.Multivariate.W","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα : TypeVec.{u} n\nx : ↑P (α.append1 (P.W α))\n⊢ Eq (P.wDest' (P.wMk' x)) x","decl":"theorem wDest'_wMk' {α : TypeVec n} (x : P (α.append1 (P.W α))) : P.wDest' (P.wMk' x) = x := by\n  cases' x with a f; rw [wMk', wDest'_wMk, split_dropFun_lastFun]\n\n"}
