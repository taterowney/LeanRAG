{"name":"Rat.AbsoluteValue.eq_on_nat_iff_eq","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f g : AbsoluteValue Rat Real\n⊢ Iff (∀ (n : Nat), Eq (f ↑n) (g ↑n)) (Eq f g)","decl":"/-- Values of an absolute value on the rationals are determined by the values on the natural\nnumbers. -/\nlemma eq_on_nat_iff_eq : (∀ n : ℕ , f n = g n) ↔ f = g := by\n  refine ⟨fun h ↦ ?_, fun h n ↦ congrFun (congrArg DFunLike.coe h) ↑n⟩\n  ext1 z\n  rw [← Rat.num_div_den z, map_div₀, map_div₀, h, eq_on_nat_iff_eq_on_int.mp h]\n\n"}
{"name":"Rat.AbsoluteValue.equiv_on_nat_iff_equiv","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f g : AbsoluteValue Rat Real\n⊢ Iff (Exists fun c => And (LT.lt 0 c) (∀ (n : Nat), Eq (HPow.hPow (f ↑n) c) (g ↑n))) (HasEquiv.Equiv f g)","decl":"/-- The equivalence class of an absolute value on the rationals is determined by its values on\nthe natural numbers. -/\nlemma equiv_on_nat_iff_equiv : (∃ c : ℝ, 0 < c ∧ ∀ n : ℕ , f n ^ c = g n) ↔ f ≈ g := by\n  refine ⟨fun ⟨c, hc, h⟩ ↦ ⟨c, hc, ?_⟩, fun ⟨c, hc, h⟩ ↦ ⟨c, hc, (congrFun h ·)⟩⟩\n  ext1 x\n  rw [← Rat.num_div_den x, map_div₀, map_div₀, div_rpow (by positivity) (by positivity), h x.den,\n    ← apply_natAbs_eq,← apply_natAbs_eq, h (natAbs x.num)]\n\n"}
{"name":"Rat.AbsoluteValue.padic_eq_padicNorm","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nr : Rat\n⊢ Eq ((Rat.AbsoluteValue.padic p) r) ↑(padicNorm p r)","decl":"@[simp] lemma padic_eq_padicNorm (p : ℕ) [Fact p.Prime] (r : ℚ) :\n    padic p r = padicNorm p r := rfl\n\n"}
{"name":"Rat.AbsoluteValue.padic_le_one","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nn : Int\n⊢ LE.le ((Rat.AbsoluteValue.padic p) ↑n) 1","decl":"lemma padic_le_one (p : ℕ) [Fact p.Prime] (n : ℤ) : padic p n ≤ 1 := by\n  simp only [padic_eq_padicNorm]\n  exact_mod_cast padicNorm.of_int n\n\n-- ## Step 1: define `p = minimal n s. t. 0 < f n < 1`\n\n"}
{"name":"Rat.AbsoluteValue.exists_minimal_nat_zero_lt_and_lt_one","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f : AbsoluteValue Rat Real\nhf_nontriv : f.IsNontrivial\nbdd : ∀ (n : Nat), LE.le (f ↑n) 1\n⊢ Exists fun p => And (And (LT.lt 0 (f ↑p)) (LT.lt (f ↑p) 1)) (∀ (m : Nat), And (LT.lt 0 (f ↑m)) (LT.lt (f ↑m) 1) → LE.le p m)","decl":"include hf_nontriv bdd in\n/-- There exists a minimal positive integer with absolute value smaller than 1. -/\nlemma exists_minimal_nat_zero_lt_and_lt_one :\n    ∃ p : ℕ, (0 < f p ∧ f p < 1) ∧ ∀ m : ℕ, 0 < f m ∧ f m < 1 → p ≤ m := by\n  -- There is a positive integer with absolute value different from one.\n  obtain ⟨n, hn1, hn2⟩ : ∃ n : ℕ, n ≠ 0 ∧ f n ≠ 1 := by\n    contrapose! hf_nontriv\n    refine (isNontrivial_iff_ne_trivial f).not_left.mpr <| eq_on_nat_iff_eq.mp fun n ↦ ?_\n    rcases eq_or_ne n 0 with rfl | hn\n    · simp\n    · simp [hf_nontriv, hn]\n  set P := {m : ℕ | 0 < f ↑m ∧ f ↑m < 1} -- p is going to be the minimum of this set.\n  have hP : P.Nonempty :=\n    ⟨n, map_pos_of_ne_zero f (Nat.cast_ne_zero.mpr hn1), lt_of_le_of_ne (bdd n) hn2⟩\n  exact ⟨sInf P, Nat.sInf_mem hP, fun m hm ↦ Nat.sInf_le hm⟩\n\n-- ## Step 2: p is prime\n\n"}
{"name":"Rat.AbsoluteValue.is_prime_of_minimal_nat_zero_lt_and_lt_one","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f : AbsoluteValue Rat Real\np : Nat\nhp0 : LT.lt 0 (f ↑p)\nhp1 : LT.lt (f ↑p) 1\nhmin : ∀ (m : Nat), And (LT.lt 0 (f ↑m)) (LT.lt (f ↑m) 1) → LE.le p m\n⊢ Nat.Prime p","decl":"include hp0 hp1 hmin in\n/-- The minimal positive integer with absolute value smaller than 1 is a prime number.-/\nlemma is_prime_of_minimal_nat_zero_lt_and_lt_one : p.Prime := by\n  rw [← Nat.irreducible_iff_nat_prime]\n  constructor -- Two goals: p is not a unit and any product giving p must contain a unit.\n  · rw [Nat.isUnit_iff]\n    rintro rfl\n    simp only [Nat.cast_one, map_one, lt_self_iff_false] at hp1\n  · rintro a b rfl\n    rw [Nat.isUnit_iff, Nat.isUnit_iff]\n    by_contra! con\n    obtain ⟨ha₁, hb₁⟩ := con\n    obtain ⟨ha₀, hb₀⟩ : a ≠ 0 ∧ b ≠ 0 := by\n      refine mul_ne_zero_iff.mp fun h ↦ ?_\n      rwa [h, Nat.cast_zero, map_zero, lt_self_iff_false] at hp0\n    have hap : a < a * b := lt_mul_of_one_lt_right (by omega) (by omega)\n    have hbp : b < a * b := lt_mul_of_one_lt_left (by omega) (by omega)\n    have ha :=\n      le_of_not_lt <| not_and.mp ((hmin a).mt hap.not_le) (map_pos_of_ne_zero f (mod_cast ha₀))\n    have hb :=\n      le_of_not_lt <| not_and.mp ((hmin b).mt hbp.not_le) (map_pos_of_ne_zero f (mod_cast hb₀))\n    rw [Nat.cast_mul, map_mul] at hp1\n    exact ((one_le_mul_of_one_le_of_one_le ha hb).trans_lt hp1).false\n\n-- ## Step 3: if p does not divide m, then f m = 1\n\n"}
{"name":"Rat.AbsoluteValue.eq_one_of_not_dvd","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f : AbsoluteValue Rat Real\nbdd : ∀ (n : Nat), LE.le (f ↑n) 1\np : Nat\nhp0 : LT.lt 0 (f ↑p)\nhp1 : LT.lt (f ↑p) 1\nhmin : ∀ (m : Nat), And (LT.lt 0 (f ↑m)) (LT.lt (f ↑m) 1) → LE.le p m\nm : Nat\nhpm : Not (Dvd.dvd p m)\n⊢ Eq (f ↑m) 1","decl":"include hp0 hp1 hmin bdd in\n/-- A natural number not divible by `p` has absolute value 1. -/\nlemma eq_one_of_not_dvd {m : ℕ} (hpm : ¬ p ∣ m) : f m = 1 := by\n  apply le_antisymm (bdd m)\n  by_contra! hm\n  set M := f p ⊔ f m with hM\n  set k := Nat.ceil (M.logb (1 / 2)) + 1 with hk\n  obtain ⟨a, b, bezout⟩ : IsCoprime (p ^ k : ℤ) (m ^ k) :=\n    is_prime_of_minimal_nat_zero_lt_and_lt_one hp0 hp1 hmin\n      |>.coprime_iff_not_dvd |>.mpr hpm |>.isCoprime |>.pow\n  have le_half {x} (hx0 : 0 < x) (hx1 : x < 1) (hxM : x ≤ M) : x ^ k < 1 / 2 := by\n    calc\n    x ^ k = x ^ (k : ℝ) := (rpow_natCast x k).symm\n    _ < x ^ M.logb (1 / 2) := by\n      apply rpow_lt_rpow_of_exponent_gt hx0 hx1\n      rw [hk]\n      push_cast\n      exact lt_add_of_le_of_pos (Nat.le_ceil _) zero_lt_one\n    _ ≤ x ^ x.logb (1 / 2) := by\n      apply rpow_le_rpow_of_exponent_ge hx0 hx1.le\n      simp only [one_div, ← log_div_log, log_inv, neg_div, ← div_neg, hM]\n      gcongr\n      simp only [Left.neg_pos_iff]\n      exact log_neg (lt_sup_iff.mpr <| .inl hp0) (sup_lt_iff.mpr ⟨hp1, hm⟩)\n    _ = 1 / 2 := rpow_logb hx0 hx1.ne one_half_pos\n  apply lt_irrefl (1 : ℝ)\n  calc\n  1 = f 1 := (map_one f).symm\n  _ = f (a * p ^ k + b * m ^ k) := by rw_mod_cast [bezout]; norm_cast\n  _ ≤ f (a * p ^ k) + f (b * m ^ k) := f.add_le' ..\n  _ ≤ 1 * (f p) ^ k + 1 * (f m) ^ k := by\n    simp only [map_mul, map_pow]\n    gcongr\n    all_goals rw [← apply_natAbs_eq]; apply bdd\n  _ = (f p) ^ k + (f m) ^ k := by simp only [one_mul]\n  _ < 1 := by\n    have hm₀ : 0 < f m := f.pos <| Nat.cast_ne_zero.mpr fun H ↦ hpm <| H ▸ dvd_zero p\n    linarith only [le_half hp0 hp1 le_sup_left, le_half hm₀ hm le_sup_right]\n\n-- ## Step 4: f p = p ^ (-t) for some positive real t\n\n"}
{"name":"Rat.AbsoluteValue.exists_pos_eq_pow_neg","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f : AbsoluteValue Rat Real\np : Nat\nhp0 : LT.lt 0 (f ↑p)\nhp1 : LT.lt (f ↑p) 1\nhmin : ∀ (m : Nat), And (LT.lt 0 (f ↑m)) (LT.lt (f ↑m) 1) → LE.le p m\n⊢ Exists fun t => And (LT.lt 0 t) (Eq (f ↑p) (HPow.hPow (↑p) (Neg.neg t)))","decl":"include hp0 hp1 hmin in\n/-- The absolute value of `p` is `p ^ (-t)` for some positive real number `t`. -/\nlemma exists_pos_eq_pow_neg : ∃ t : ℝ, 0 < t ∧ f p = p ^ (-t) := by\n  have pprime := is_prime_of_minimal_nat_zero_lt_and_lt_one hp0 hp1 hmin\n  refine ⟨- logb p (f p), Left.neg_pos_iff.mpr <| logb_neg (mod_cast pprime.one_lt) hp0 hp1, ?_⟩\n  rw [neg_neg]\n  exact (rpow_logb (mod_cast pprime.pos) (mod_cast pprime.ne_one) hp0).symm\n\n-- ## Non-archimedean case: end goal\n\n"}
{"name":"Rat.AbsoluteValue.equiv_padic_of_bounded","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f : AbsoluteValue Rat Real\nhf_nontriv : f.IsNontrivial\nbdd : ∀ (n : Nat), LE.le (f ↑n) 1\n⊢ ExistsUnique fun p => Exists fun x => HasEquiv.Equiv f (Rat.AbsoluteValue.padic p)","decl":"include hf_nontriv bdd in\n/-- If `f` is bounded and not trivial, then it is equivalent to a p-adic absolute value. -/\ntheorem equiv_padic_of_bounded :\n    ∃! p, ∃ (_ : Fact p.Prime), f ≈ (padic p) := by\n  obtain ⟨p, hfp, hmin⟩ := exists_minimal_nat_zero_lt_and_lt_one hf_nontriv bdd\n  have hprime := is_prime_of_minimal_nat_zero_lt_and_lt_one hfp.1 hfp.2 hmin\n  have hprime_fact : Fact p.Prime := ⟨hprime⟩\n  obtain ⟨t, h⟩ := exists_pos_eq_pow_neg hfp.1 hfp.2 hmin\n  simp_rw [← equiv_on_nat_iff_equiv]\n  refine ⟨p, ⟨hprime_fact, t⁻¹, inv_pos_of_pos h.1, fun n ↦ ?_⟩, fun q ⟨hq_prime, h_equiv⟩ ↦ ?_⟩\n  · have ht : t⁻¹ ≠ 0 := inv_ne_zero h.1.ne'\n    rcases eq_or_ne n 0 with rfl | hn -- Separate cases n = 0 and n ≠ 0\n    · simp [ht]\n    · /- Any natural number can be written as a power of p times a natural number not divisible\n      by p  -/\n      rcases Nat.exists_eq_pow_mul_and_not_dvd hn p hprime.ne_one with ⟨e, m, hpm, rfl⟩\n      simp only [Nat.cast_mul, Nat.cast_pow, map_mul, map_pow, h.2,\n        eq_one_of_not_dvd bdd hfp.1 hfp.2 hmin hpm, padic_eq_padicNorm,\n        padicNorm.padicNorm_p_of_prime, cast_inv, cast_natCast, inv_pow]\n      rw [← padicNorm.nat_eq_one_iff] at hpm\n      simp only [← rpow_natCast, p.cast_nonneg, ← rpow_mul, neg_mul, mul_one, ← rpow_neg, hpm,\n        cast_one]\n      congr\n      field_simp [h.1.ne']\n  · by_contra! hne\n    apply hq_prime.elim.prime.ne_one\n    rw [ne_comm, ← Nat.coprime_primes hprime hq_prime.elim, hprime.coprime_iff_not_dvd] at hne\n    rcases h_equiv with ⟨c, _, h_eq⟩\n    have h_eq' := h_eq q\n    simp only [eq_one_of_not_dvd bdd hfp.1 hfp.2 hmin hne, one_rpow, padic_eq_padicNorm,\n      padicNorm.padicNorm_p_of_prime, cast_inv, cast_natCast, eq_comm, inv_eq_one] at h_eq'\n    exact_mod_cast h_eq'\n\n"}
{"name":"Rat.AbsoluteValue.real_eq_abs","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"r : Rat\n⊢ Eq (Rat.AbsoluteValue.real r) ↑(abs r)","decl":"@[simp] lemma real_eq_abs (r : ℚ) : real r = |r| :=\n  (cast_abs r).symm\n\n-- ## Preliminary result\n\n"}
{"name":"Rat.AbsoluteValue.apply_le_sum_digits","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f : AbsoluteValue Rat Real\nn m : Nat\nhm : LT.lt 1 m\n⊢ LE.le (f ↑n) (List.mapIdx (fun i x => HMul.hMul (↑m) (HPow.hPow (f ↑m) i)) (m.digits n)).sum","decl":"/-- Given any two integers `n`, `m` with `m > 1`, the absolute value of `n` is bounded by\n`m + m * f m + m * (f m) ^ 2 + ... + m * (f m) ^ d` where `d` is the number of digits of the\nexpansion of `n` in base `m`. -/\nlemma apply_le_sum_digits (n : ℕ) {m : ℕ} (hm : 1 < m) :\n    f n ≤ ((Nat.digits m n).mapIdx fun i _ ↦ m * (f m) ^ i).sum := by\n  set L := Nat.digits m n\n  set L' : List ℚ := List.map Nat.cast (L.mapIdx fun i a ↦ (a * m ^ i)) with hL'\n  -- If `c` is a digit in the expansion of `n` in base `m`, then `f c` is less than `m`.\n  have hcoef {c : ℕ} (hc : c ∈ Nat.digits m n) : f c < m :=\n    lt_of_le_of_lt (f.apply_nat_le_self c) (mod_cast Nat.digits_lt_base hm hc)\n  calc\n  f n = f ((Nat.ofDigits m L : ℕ) : ℚ) := by rw [Nat.ofDigits_digits m n]\n    _ = f L'.sum := by rw [Nat.ofDigits_eq_sum_mapIdx]; norm_cast\n    _ ≤ (L'.map f).sum := listSum_le f L'\n    _ ≤ (L.mapIdx fun i _ ↦ m * (f m) ^ i).sum := ?_\n  simp only [hL', List.mapIdx_eq_enum_map, List.map_map]\n  refine List.sum_le_sum fun ⟨i, a⟩ hia ↦ ?_\n  dsimp only [Function.comp_apply, Function.uncurry_apply_pair]\n  replace hia := List.mem_enumFrom hia\n  push_cast\n  rw [map_mul, map_pow]\n  refine mul_le_mul_of_nonneg_right ?_ <| pow_nonneg (f.nonneg _) i\n  simp only [zero_le, zero_add, tsub_zero, true_and] at hia\n  exact (hcoef (List.mem_iff_get.mpr ⟨⟨i, hia.1⟩, hia.2.symm⟩)).le\n\n-- ## Step 1: if f is an AbsoluteValue and f n > 1 for some natural n, then f n > 1 for all n ≥ 2\n\n"}
{"name":"Rat.AbsoluteValue.one_lt_of_not_bounded","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f : AbsoluteValue Rat Real\nnotbdd : Not (∀ (n : Nat), LE.le (f ↑n) 1)\nn₀ : Nat\nhn₀ : LT.lt 1 n₀\n⊢ LT.lt 1 (f ↑n₀)","decl":"/-- If `f n > 1` for some `n` then `f n > 1` for all `n ≥ 2` -/\nlemma one_lt_of_not_bounded (notbdd : ¬ ∀ n : ℕ, f n ≤ 1) {n₀ : ℕ} (hn₀ : 1 < n₀) : 1 < f n₀ := by\n  contrapose! notbdd with h\n  intro n\n  have h_ineq1 {m : ℕ} (hm : 1 ≤ m) : f m ≤ n₀ * (logb n₀ m + 1) := by\n    /- L is the string of digits of `n` in the base `n₀`-/\n    set L := Nat.digits n₀ m\n    calc\n    f m ≤ (L.mapIdx fun i _ ↦ n₀ * f n₀ ^ i).sum := apply_le_sum_digits m hn₀\n    _ ≤ (L.mapIdx fun _ _ ↦ (n₀ : ℝ)).sum := by\n      simp only [List.mapIdx_eq_enum_map, List.map_map]\n      refine List.sum_le_sum fun ⟨i, a⟩ _ ↦ ?_\n      simp only [Function.comp_apply, Function.uncurry_apply_pair]\n      exact mul_le_of_le_of_le_one' (mod_cast le_refl n₀) (pow_le_one₀ (by positivity) h)\n        (by positivity) (by positivity)\n    _ = n₀ * (Nat.log n₀ m + 1) := by\n      rw [List.mapIdx_eq_enum_map, List.eq_replicate_of_mem (a := (n₀ : ℝ))\n        (l := List.map (Function.uncurry fun _ _ ↦ n₀) (List.enum L)),\n        List.sum_replicate, List.length_map, List.enum_length, nsmul_eq_mul, mul_comm,\n        Nat.digits_len n₀ m hn₀ (not_eq_zero_of_lt hm), Nat.cast_add_one]\n      simp +contextual\n    _ ≤ n₀ * (logb n₀ m + 1) := by gcongr; exact natLog_le_logb ..\n  -- For h_ineq2 we need to exclude the case n = 0.\n  rcases eq_or_ne n 0 with rfl | h₀\n  · simp\n  have h_ineq2 (k : ℕ) (hk : 0 < k) :\n      f n ≤ (n₀ * (logb n₀ n + 1)) ^ (k : ℝ)⁻¹ * k ^ (k : ℝ)⁻¹ := by\n    have : 0 ≤ logb n₀ n := logb_nonneg (one_lt_cast.mpr hn₀) (mod_cast Nat.one_le_of_lt h₀.bot_lt)\n    calc\n    f n = (f ↑(n ^ k)) ^ (k : ℝ)⁻¹ := by\n      rw [Nat.cast_pow, map_pow, ← rpow_natCast, rpow_rpow_inv (by positivity) (by positivity)]\n    _  ≤ (n₀ * (logb n₀ ↑(n ^ k) + 1)) ^ (k : ℝ)⁻¹ := by\n      gcongr\n      exact h_ineq1 <| one_le_pow₀ (one_le_iff_ne_zero.mpr h₀)\n    _  = (n₀ * (k * logb n₀ n + 1)) ^ (k : ℝ)⁻¹ := by\n      rw [Nat.cast_pow, logb_pow]\n    _  ≤ (n₀ * (k * logb n₀ n + k)) ^ (k : ℝ)⁻¹ := by\n      gcongr\n      exact one_le_cast.mpr hk\n    _ = (n₀ * (logb n₀ n + 1)) ^ (k : ℝ)⁻¹ * k ^ (k : ℝ)⁻¹ := by\n      rw [← mul_rpow (by positivity) (by positivity), mul_assoc, add_mul, one_mul,\n        mul_comm _ (k : ℝ)]\n-- For 0 < logb n₀ n below we also need to exclude n = 1.\n  rcases eq_or_ne n 1 with rfl | h₁\n  · simp\n  refine le_of_tendsto_of_tendsto tendsto_const_nhds ?_ (eventually_atTop.mpr ⟨1, h_ineq2⟩)\n  nth_rw 2 [← mul_one 1]\n  have : 0 < logb n₀ n := logb_pos (mod_cast hn₀) (by norm_cast; omega)\n  exact (tendsto_const_rpow_inv (by positivity)).mul tendsto_nat_rpow_inv\n\n-- ## Step 2: given m, n ≥ 2 and |m| = m^s, |n| = n^t for s, t > 0, we have t ≤ s\n\n"}
{"name":"Rat.AbsoluteValue.le_pow_log","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f : AbsoluteValue Rat Real\nm n : Nat\nhm : LT.lt 1 m\nhn : LT.lt 1 n\nnotbdd : Not (∀ (n : Nat), LE.le (f ↑n) 1)\n⊢ LE.le (f ↑n) (HPow.hPow (f ↑m) (Real.logb ↑m ↑n))","decl":"include hm hn notbdd in\n/-- Given two natural numbers `n, m` greater than 1 we have `f n ≤ f m ^ logb m n`. -/\nlemma le_pow_log : f n ≤ f m ^ logb m n := by\n  have : Tendsto (fun k : ℕ ↦ (m * f m / (f m - 1)) ^ (k : ℝ)⁻¹ * f m ^ logb m n)\n      atTop (𝓝 (f m ^ logb m n)) := by\n    nth_rw 2 [← one_mul (f ↑m ^ logb ↑m ↑n)]\n    exact (tendsto_const_rpow_inv (expr_pos hm notbdd)).mul_const _\n  exact le_of_tendsto_of_tendsto (tendsto_const_nhds (x:= f ↑n)) this <|\n    eventually_atTop.mpr ⟨2, fun b hb ↦ param_upperbound hm hn notbdd (not_eq_zero_of_lt hb)⟩\n\n"}
{"name":"Rat.AbsoluteValue.equiv_real_of_unbounded","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f : AbsoluteValue Rat Real\nnotbdd : Not (∀ (n : Nat), LE.le (f ↑n) 1)\n⊢ HasEquiv.Equiv f Rat.AbsoluteValue.real","decl":"include notbdd in\n/-- If `f` is not bounded and not trivial, then it is equivalent to the standard absolute value on\n`ℚ`. -/\ntheorem equiv_real_of_unbounded : f ≈ real := by\n  obtain ⟨m, hm⟩ := Classical.exists_not_of_not_forall notbdd\n  have oneltm : 1 < m := by\n    contrapose! hm\n    rcases le_one_iff_eq_zero_or_eq_one.mp hm with rfl | rfl <;> simp\n  rw [← equiv_on_nat_iff_equiv]\n  set s := logb m (f m) with hs\n  refine ⟨s⁻¹,\n    inv_pos.mpr (logb_pos (Nat.one_lt_cast.mpr oneltm) (one_lt_of_not_bounded notbdd oneltm)),\n    fun n ↦ ?_⟩\n  rcases lt_trichotomy n 1 with h | rfl | h\n  · obtain rfl : n = 0 := by omega\n    have : (logb (↑m) (f ↑m))⁻¹ ≠ 0 := by\n      simp only [ne_eq, inv_eq_zero, logb_eq_zero, Nat.cast_eq_zero, Nat.cast_eq_one, map_eq_zero,\n        not_or]\n      exact ⟨not_eq_zero_of_lt oneltm, oneltm.ne', by norm_cast,\n        not_eq_zero_of_lt oneltm, ne_of_not_le hm, by linarith only [apply_nonneg f ↑m]⟩\n    simp [hs, this]\n  · simp\n  · simp only [real_eq_abs, abs_cast, Rat.cast_natCast]\n    rw [rpow_inv_eq (apply_nonneg f ↑n) (Nat.cast_nonneg n)\n      (logb_ne_zero_of_pos_of_ne_one (one_lt_cast.mpr oneltm) (by linarith only [hm])\n      (by linarith only [hm]))]\n    have hfm : f m = m ^ s := by\n      rw [rpow_logb (mod_cast zero_lt_of_lt oneltm) (mod_cast oneltm.ne') (by linarith only [hm])]\n    have hfn : f n = n ^ logb n (f n) := by\n      rw [rpow_logb (mod_cast zero_lt_of_lt h) (mod_cast h.ne')\n        (by apply map_pos_of_ne_zero; exact_mod_cast not_eq_zero_of_lt h)]\n    rwa [← hs, eq_of_eq_pow oneltm h notbdd hfm hfn]\n\n"}
{"name":"Rat.AbsoluteValue.equiv_real_or_padic","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f : AbsoluteValue Rat Real\nhf_nontriv : f.IsNontrivial\n⊢ Or (HasEquiv.Equiv f Rat.AbsoluteValue.real) (ExistsUnique fun p => Exists fun x => HasEquiv.Equiv f (Rat.AbsoluteValue.padic p))","decl":"/-- **Ostrowski's Theorem**: every absolute value (with values in `ℝ`) on `ℚ` is equivalent\nto either the standard absolute value or a `p`-adic absolute value for a prime `p`. -/\ntheorem equiv_real_or_padic (f : AbsoluteValue ℚ ℝ) (hf_nontriv : f.IsNontrivial) :\n    f ≈ real ∨ ∃! p, ∃ (_ : Fact p.Prime), f ≈ (padic p) := by\n  by_cases bdd : ∀ n : ℕ, f n ≤ 1\n  · exact .inr <| equiv_padic_of_bounded hf_nontriv bdd\n  · exact .inl <| equiv_real_of_unbounded bdd\n\n"}
{"name":"Rat.AbsoluteValue.not_real_equiv_padic","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ Not (HasEquiv.Equiv Rat.AbsoluteValue.real (Rat.AbsoluteValue.padic p))","decl":"/-- The standard absolute value on `ℚ` is not equivalent to any `p`-adic absolute value. -/\nlemma not_real_equiv_padic (p : ℕ) [Fact p.Prime] : ¬ real ≈ (padic p) := by\n  rintro ⟨c, hc₀, hc⟩\n  apply_fun (· 2) at hc\n  simp only [real_eq_abs, abs_ofNat, cast_ofNat] at hc\n  exact ((padic_le_one p 2).trans_lt <| one_lt_rpow one_lt_two hc₀).ne' hc\n\n"}
