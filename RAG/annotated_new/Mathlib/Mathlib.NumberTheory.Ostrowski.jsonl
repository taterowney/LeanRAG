{"name":"Rat.AbsoluteValue.eq_on_nat_iff_eq","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f g : AbsoluteValue Rat Real\nâŠ¢ Iff (âˆ€ (n : Nat), Eq (f â†‘n) (g â†‘n)) (Eq f g)","decl":"/-- Values of an absolute value on the rationals are determined by the values on the natural\nnumbers. -/\nlemma eq_on_nat_iff_eq : (âˆ€ n : â„• , f n = g n) â†” f = g := by\n  refine âŸ¨fun h â†¦ ?_, fun h n â†¦ congrFun (congrArg DFunLike.coe h) â†‘nâŸ©\n  ext1 z\n  rw [â† Rat.num_div_den z, map_divâ‚€, map_divâ‚€, h, eq_on_nat_iff_eq_on_int.mp h]\n\n"}
{"name":"Rat.AbsoluteValue.equiv_on_nat_iff_equiv","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f g : AbsoluteValue Rat Real\nâŠ¢ Iff (Exists fun c => And (LT.lt 0 c) (âˆ€ (n : Nat), Eq (HPow.hPow (f â†‘n) c) (g â†‘n))) (HasEquiv.Equiv f g)","decl":"/-- The equivalence class of an absolute value on the rationals is determined by its values on\nthe natural numbers. -/\nlemma equiv_on_nat_iff_equiv : (âˆƒ c : â„, 0 < c âˆ§ âˆ€ n : â„• , f n ^ c = g n) â†” f â‰ˆ g := by\n  refine âŸ¨fun âŸ¨c, hc, hâŸ© â†¦ âŸ¨c, hc, ?_âŸ©, fun âŸ¨c, hc, hâŸ© â†¦ âŸ¨c, hc, (congrFun h Â·)âŸ©âŸ©\n  ext1 x\n  rw [â† Rat.num_div_den x, map_divâ‚€, map_divâ‚€, div_rpow (by positivity) (by positivity), h x.den,\n    â† apply_natAbs_eq,â† apply_natAbs_eq, h (natAbs x.num)]\n\n"}
{"name":"Rat.AbsoluteValue.padic_eq_padicNorm","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"p : Nat\ninstâœ : Fact (Nat.Prime p)\nr : Rat\nâŠ¢ Eq ((Rat.AbsoluteValue.padic p) r) â†‘(padicNorm p r)","decl":"@[simp] lemma padic_eq_padicNorm (p : â„•) [Fact p.Prime] (r : â„š) :\n    padic p r = padicNorm p r := rfl\n\n"}
{"name":"Rat.AbsoluteValue.padic_le_one","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"p : Nat\ninstâœ : Fact (Nat.Prime p)\nn : Int\nâŠ¢ LE.le ((Rat.AbsoluteValue.padic p) â†‘n) 1","decl":"lemma padic_le_one (p : â„•) [Fact p.Prime] (n : â„¤) : padic p n â‰¤ 1 := by\n  simp only [padic_eq_padicNorm]\n  exact_mod_cast padicNorm.of_int n\n\n-- ## Step 1: define `p = minimal n s. t. 0 < f n < 1`\n\n"}
{"name":"Rat.AbsoluteValue.exists_minimal_nat_zero_lt_and_lt_one","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f : AbsoluteValue Rat Real\nhf_nontriv : f.IsNontrivial\nbdd : âˆ€ (n : Nat), LE.le (f â†‘n) 1\nâŠ¢ Exists fun p => And (And (LT.lt 0 (f â†‘p)) (LT.lt (f â†‘p) 1)) (âˆ€ (m : Nat), And (LT.lt 0 (f â†‘m)) (LT.lt (f â†‘m) 1) â†’ LE.le p m)","decl":"include hf_nontriv bdd in\n/-- There exists a minimal positive integer with absolute value smaller than 1. -/\nlemma exists_minimal_nat_zero_lt_and_lt_one :\n    âˆƒ p : â„•, (0 < f p âˆ§ f p < 1) âˆ§ âˆ€ m : â„•, 0 < f m âˆ§ f m < 1 â†’ p â‰¤ m := by\n  -- There is a positive integer with absolute value different from one.\n  obtain âŸ¨n, hn1, hn2âŸ© : âˆƒ n : â„•, n â‰  0 âˆ§ f n â‰  1 := by\n    contrapose! hf_nontriv\n    refine (isNontrivial_iff_ne_trivial f).not_left.mpr <| eq_on_nat_iff_eq.mp fun n â†¦ ?_\n    rcases eq_or_ne n 0 with rfl | hn\n    Â· simp\n    Â· simp [hf_nontriv, hn]\n  set P := {m : â„• | 0 < f â†‘m âˆ§ f â†‘m < 1} -- p is going to be the minimum of this set.\n  have hP : P.Nonempty :=\n    âŸ¨n, map_pos_of_ne_zero f (Nat.cast_ne_zero.mpr hn1), lt_of_le_of_ne (bdd n) hn2âŸ©\n  exact âŸ¨sInf P, Nat.sInf_mem hP, fun m hm â†¦ Nat.sInf_le hmâŸ©\n\n-- ## Step 2: p is prime\n\n"}
{"name":"Rat.AbsoluteValue.is_prime_of_minimal_nat_zero_lt_and_lt_one","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f : AbsoluteValue Rat Real\np : Nat\nhp0 : LT.lt 0 (f â†‘p)\nhp1 : LT.lt (f â†‘p) 1\nhmin : âˆ€ (m : Nat), And (LT.lt 0 (f â†‘m)) (LT.lt (f â†‘m) 1) â†’ LE.le p m\nâŠ¢ Nat.Prime p","decl":"include hp0 hp1 hmin in\n/-- The minimal positive integer with absolute value smaller than 1 is a prime number.-/\nlemma is_prime_of_minimal_nat_zero_lt_and_lt_one : p.Prime := by\n  rw [â† Nat.irreducible_iff_nat_prime]\n  constructor -- Two goals: p is not a unit and any product giving p must contain a unit.\n  Â· rw [Nat.isUnit_iff]\n    rintro rfl\n    simp only [Nat.cast_one, map_one, lt_self_iff_false] at hp1\n  Â· rintro a b rfl\n    rw [Nat.isUnit_iff, Nat.isUnit_iff]\n    by_contra! con\n    obtain âŸ¨haâ‚, hbâ‚âŸ© := con\n    obtain âŸ¨haâ‚€, hbâ‚€âŸ© : a â‰  0 âˆ§ b â‰  0 := by\n      refine mul_ne_zero_iff.mp fun h â†¦ ?_\n      rwa [h, Nat.cast_zero, map_zero, lt_self_iff_false] at hp0\n    have hap : a < a * b := lt_mul_of_one_lt_right (by omega) (by omega)\n    have hbp : b < a * b := lt_mul_of_one_lt_left (by omega) (by omega)\n    have ha :=\n      le_of_not_lt <| not_and.mp ((hmin a).mt hap.not_le) (map_pos_of_ne_zero f (mod_cast haâ‚€))\n    have hb :=\n      le_of_not_lt <| not_and.mp ((hmin b).mt hbp.not_le) (map_pos_of_ne_zero f (mod_cast hbâ‚€))\n    rw [Nat.cast_mul, map_mul] at hp1\n    exact ((one_le_mul_of_one_le_of_one_le ha hb).trans_lt hp1).false\n\n-- ## Step 3: if p does not divide m, then f m = 1\n\n"}
{"name":"Rat.AbsoluteValue.eq_one_of_not_dvd","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f : AbsoluteValue Rat Real\nbdd : âˆ€ (n : Nat), LE.le (f â†‘n) 1\np : Nat\nhp0 : LT.lt 0 (f â†‘p)\nhp1 : LT.lt (f â†‘p) 1\nhmin : âˆ€ (m : Nat), And (LT.lt 0 (f â†‘m)) (LT.lt (f â†‘m) 1) â†’ LE.le p m\nm : Nat\nhpm : Not (Dvd.dvd p m)\nâŠ¢ Eq (f â†‘m) 1","decl":"include hp0 hp1 hmin bdd in\n/-- A natural number not divible by `p` has absolute value 1. -/\nlemma eq_one_of_not_dvd {m : â„•} (hpm : Â¬ p âˆ£ m) : f m = 1 := by\n  apply le_antisymm (bdd m)\n  by_contra! hm\n  set M := f p âŠ” f m with hM\n  set k := Nat.ceil (M.logb (1 / 2)) + 1 with hk\n  obtain âŸ¨a, b, bezoutâŸ© : IsCoprime (p ^ k : â„¤) (m ^ k) :=\n    is_prime_of_minimal_nat_zero_lt_and_lt_one hp0 hp1 hmin\n      |>.coprime_iff_not_dvd |>.mpr hpm |>.isCoprime |>.pow\n  have le_half {x} (hx0 : 0 < x) (hx1 : x < 1) (hxM : x â‰¤ M) : x ^ k < 1 / 2 := by\n    calc\n    x ^ k = x ^ (k : â„) := (rpow_natCast x k).symm\n    _ < x ^ M.logb (1 / 2) := by\n      apply rpow_lt_rpow_of_exponent_gt hx0 hx1\n      rw [hk]\n      push_cast\n      exact lt_add_of_le_of_pos (Nat.le_ceil _) zero_lt_one\n    _ â‰¤ x ^ x.logb (1 / 2) := by\n      apply rpow_le_rpow_of_exponent_ge hx0 hx1.le\n      simp only [one_div, â† log_div_log, log_inv, neg_div, â† div_neg, hM]\n      gcongr\n      simp only [Left.neg_pos_iff]\n      exact log_neg (lt_sup_iff.mpr <| .inl hp0) (sup_lt_iff.mpr âŸ¨hp1, hmâŸ©)\n    _ = 1 / 2 := rpow_logb hx0 hx1.ne one_half_pos\n  apply lt_irrefl (1 : â„)\n  calc\n  1 = f 1 := (map_one f).symm\n  _ = f (a * p ^ k + b * m ^ k) := by rw_mod_cast [bezout]; norm_cast\n  _ â‰¤ f (a * p ^ k) + f (b * m ^ k) := f.add_le' ..\n  _ â‰¤ 1 * (f p) ^ k + 1 * (f m) ^ k := by\n    simp only [map_mul, map_pow]\n    gcongr\n    all_goals rw [â† apply_natAbs_eq]; apply bdd\n  _ = (f p) ^ k + (f m) ^ k := by simp only [one_mul]\n  _ < 1 := by\n    have hmâ‚€ : 0 < f m := f.pos <| Nat.cast_ne_zero.mpr fun H â†¦ hpm <| H â–¸ dvd_zero p\n    linarith only [le_half hp0 hp1 le_sup_left, le_half hmâ‚€ hm le_sup_right]\n\n-- ## Step 4: f p = p ^ (-t) for some positive real t\n\n"}
{"name":"Rat.AbsoluteValue.exists_pos_eq_pow_neg","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f : AbsoluteValue Rat Real\np : Nat\nhp0 : LT.lt 0 (f â†‘p)\nhp1 : LT.lt (f â†‘p) 1\nhmin : âˆ€ (m : Nat), And (LT.lt 0 (f â†‘m)) (LT.lt (f â†‘m) 1) â†’ LE.le p m\nâŠ¢ Exists fun t => And (LT.lt 0 t) (Eq (f â†‘p) (HPow.hPow (â†‘p) (Neg.neg t)))","decl":"include hp0 hp1 hmin in\n/-- The absolute value of `p` is `p ^ (-t)` for some positive real number `t`. -/\nlemma exists_pos_eq_pow_neg : âˆƒ t : â„, 0 < t âˆ§ f p = p ^ (-t) := by\n  have pprime := is_prime_of_minimal_nat_zero_lt_and_lt_one hp0 hp1 hmin\n  refine âŸ¨- logb p (f p), Left.neg_pos_iff.mpr <| logb_neg (mod_cast pprime.one_lt) hp0 hp1, ?_âŸ©\n  rw [neg_neg]\n  exact (rpow_logb (mod_cast pprime.pos) (mod_cast pprime.ne_one) hp0).symm\n\n-- ## Non-archimedean case: end goal\n\n"}
{"name":"Rat.AbsoluteValue.equiv_padic_of_bounded","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f : AbsoluteValue Rat Real\nhf_nontriv : f.IsNontrivial\nbdd : âˆ€ (n : Nat), LE.le (f â†‘n) 1\nâŠ¢ ExistsUnique fun p => Exists fun x => HasEquiv.Equiv f (Rat.AbsoluteValue.padic p)","decl":"include hf_nontriv bdd in\n/-- If `f` is bounded and not trivial, then it is equivalent to a p-adic absolute value. -/\ntheorem equiv_padic_of_bounded :\n    âˆƒ! p, âˆƒ (_ : Fact p.Prime), f â‰ˆ (padic p) := by\n  obtain âŸ¨p, hfp, hminâŸ© := exists_minimal_nat_zero_lt_and_lt_one hf_nontriv bdd\n  have hprime := is_prime_of_minimal_nat_zero_lt_and_lt_one hfp.1 hfp.2 hmin\n  have hprime_fact : Fact p.Prime := âŸ¨hprimeâŸ©\n  obtain âŸ¨t, hâŸ© := exists_pos_eq_pow_neg hfp.1 hfp.2 hmin\n  simp_rw [â† equiv_on_nat_iff_equiv]\n  refine âŸ¨p, âŸ¨hprime_fact, tâ»Â¹, inv_pos_of_pos h.1, fun n â†¦ ?_âŸ©, fun q âŸ¨hq_prime, h_equivâŸ© â†¦ ?_âŸ©\n  Â· have ht : tâ»Â¹ â‰  0 := inv_ne_zero h.1.ne'\n    rcases eq_or_ne n 0 with rfl | hn -- Separate cases n = 0 and n â‰  0\n    Â· simp [ht]\n    Â· /- Any natural number can be written as a power of p times a natural number not divisible\n      by p  -/\n      rcases Nat.exists_eq_pow_mul_and_not_dvd hn p hprime.ne_one with âŸ¨e, m, hpm, rflâŸ©\n      simp only [Nat.cast_mul, Nat.cast_pow, map_mul, map_pow, h.2,\n        eq_one_of_not_dvd bdd hfp.1 hfp.2 hmin hpm, padic_eq_padicNorm,\n        padicNorm.padicNorm_p_of_prime, cast_inv, cast_natCast, inv_pow]\n      rw [â† padicNorm.nat_eq_one_iff] at hpm\n      simp only [â† rpow_natCast, p.cast_nonneg, â† rpow_mul, neg_mul, mul_one, â† rpow_neg, hpm,\n        cast_one]\n      congr\n      field_simp [h.1.ne']\n  Â· by_contra! hne\n    apply hq_prime.elim.prime.ne_one\n    rw [ne_comm, â† Nat.coprime_primes hprime hq_prime.elim, hprime.coprime_iff_not_dvd] at hne\n    rcases h_equiv with âŸ¨c, _, h_eqâŸ©\n    have h_eq' := h_eq q\n    simp only [eq_one_of_not_dvd bdd hfp.1 hfp.2 hmin hne, one_rpow, padic_eq_padicNorm,\n      padicNorm.padicNorm_p_of_prime, cast_inv, cast_natCast, eq_comm, inv_eq_one] at h_eq'\n    exact_mod_cast h_eq'\n\n"}
{"name":"Rat.AbsoluteValue.real_eq_abs","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"r : Rat\nâŠ¢ Eq (Rat.AbsoluteValue.real r) â†‘(abs r)","decl":"@[simp] lemma real_eq_abs (r : â„š) : real r = |r| :=\n  (cast_abs r).symm\n\n-- ## Preliminary result\n\n"}
{"name":"Rat.AbsoluteValue.apply_le_sum_digits","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f : AbsoluteValue Rat Real\nn m : Nat\nhm : LT.lt 1 m\nâŠ¢ LE.le (f â†‘n) (List.mapIdx (fun i x => HMul.hMul (â†‘m) (HPow.hPow (f â†‘m) i)) (m.digits n)).sum","decl":"/-- Given any two integers `n`, `m` with `m > 1`, the absolute value of `n` is bounded by\n`m + m * f m + m * (f m) ^ 2 + ... + m * (f m) ^ d` where `d` is the number of digits of the\nexpansion of `n` in base `m`. -/\nlemma apply_le_sum_digits (n : â„•) {m : â„•} (hm : 1 < m) :\n    f n â‰¤ ((Nat.digits m n).mapIdx fun i _ â†¦ m * (f m) ^ i).sum := by\n  set L := Nat.digits m n\n  set L' : List â„š := List.map Nat.cast (L.mapIdx fun i a â†¦ (a * m ^ i)) with hL'\n  -- If `c` is a digit in the expansion of `n` in base `m`, then `f c` is less than `m`.\n  have hcoef {c : â„•} (hc : c âˆˆ Nat.digits m n) : f c < m :=\n    lt_of_le_of_lt (f.apply_nat_le_self c) (mod_cast Nat.digits_lt_base hm hc)\n  calc\n  f n = f ((Nat.ofDigits m L : â„•) : â„š) := by rw [Nat.ofDigits_digits m n]\n    _ = f L'.sum := by rw [Nat.ofDigits_eq_sum_mapIdx]; norm_cast\n    _ â‰¤ (L'.map f).sum := listSum_le f L'\n    _ â‰¤ (L.mapIdx fun i _ â†¦ m * (f m) ^ i).sum := ?_\n  simp only [hL', List.mapIdx_eq_enum_map, List.map_map]\n  refine List.sum_le_sum fun âŸ¨i, aâŸ© hia â†¦ ?_\n  dsimp only [Function.comp_apply, Function.uncurry_apply_pair]\n  replace hia := List.mem_enumFrom hia\n  push_cast\n  rw [map_mul, map_pow]\n  refine mul_le_mul_of_nonneg_right ?_ <| pow_nonneg (f.nonneg _) i\n  simp only [zero_le, zero_add, tsub_zero, true_and] at hia\n  exact (hcoef (List.mem_iff_get.mpr âŸ¨âŸ¨i, hia.1âŸ©, hia.2.symmâŸ©)).le\n\n-- ## Step 1: if f is an AbsoluteValue and f n > 1 for some natural n, then f n > 1 for all n â‰¥ 2\n\n"}
{"name":"Rat.AbsoluteValue.one_lt_of_not_bounded","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f : AbsoluteValue Rat Real\nnotbdd : Not (âˆ€ (n : Nat), LE.le (f â†‘n) 1)\nnâ‚€ : Nat\nhnâ‚€ : LT.lt 1 nâ‚€\nâŠ¢ LT.lt 1 (f â†‘nâ‚€)","decl":"/-- If `f n > 1` for some `n` then `f n > 1` for all `n â‰¥ 2` -/\nlemma one_lt_of_not_bounded (notbdd : Â¬ âˆ€ n : â„•, f n â‰¤ 1) {nâ‚€ : â„•} (hnâ‚€ : 1 < nâ‚€) : 1 < f nâ‚€ := by\n  contrapose! notbdd with h\n  intro n\n  have h_ineq1 {m : â„•} (hm : 1 â‰¤ m) : f m â‰¤ nâ‚€ * (logb nâ‚€ m + 1) := by\n    /- L is the string of digits of `n` in the base `nâ‚€`-/\n    set L := Nat.digits nâ‚€ m\n    calc\n    f m â‰¤ (L.mapIdx fun i _ â†¦ nâ‚€ * f nâ‚€ ^ i).sum := apply_le_sum_digits m hnâ‚€\n    _ â‰¤ (L.mapIdx fun _ _ â†¦ (nâ‚€ : â„)).sum := by\n      simp only [List.mapIdx_eq_enum_map, List.map_map]\n      refine List.sum_le_sum fun âŸ¨i, aâŸ© _ â†¦ ?_\n      simp only [Function.comp_apply, Function.uncurry_apply_pair]\n      exact mul_le_of_le_of_le_one' (mod_cast le_refl nâ‚€) (pow_le_oneâ‚€ (by positivity) h)\n        (by positivity) (by positivity)\n    _ = nâ‚€ * (Nat.log nâ‚€ m + 1) := by\n      rw [List.mapIdx_eq_enum_map, List.eq_replicate_of_mem (a := (nâ‚€ : â„))\n        (l := List.map (Function.uncurry fun _ _ â†¦ nâ‚€) (List.enum L)),\n        List.sum_replicate, List.length_map, List.enum_length, nsmul_eq_mul, mul_comm,\n        Nat.digits_len nâ‚€ m hnâ‚€ (not_eq_zero_of_lt hm), Nat.cast_add_one]\n      simp +contextual\n    _ â‰¤ nâ‚€ * (logb nâ‚€ m + 1) := by gcongr; exact natLog_le_logb ..\n  -- For h_ineq2 we need to exclude the case n = 0.\n  rcases eq_or_ne n 0 with rfl | hâ‚€\n  Â· simp\n  have h_ineq2 (k : â„•) (hk : 0 < k) :\n      f n â‰¤ (nâ‚€ * (logb nâ‚€ n + 1)) ^ (k : â„)â»Â¹ * k ^ (k : â„)â»Â¹ := by\n    have : 0 â‰¤ logb nâ‚€ n := logb_nonneg (one_lt_cast.mpr hnâ‚€) (mod_cast Nat.one_le_of_lt hâ‚€.bot_lt)\n    calc\n    f n = (f â†‘(n ^ k)) ^ (k : â„)â»Â¹ := by\n      rw [Nat.cast_pow, map_pow, â† rpow_natCast, rpow_rpow_inv (by positivity) (by positivity)]\n    _  â‰¤ (nâ‚€ * (logb nâ‚€ â†‘(n ^ k) + 1)) ^ (k : â„)â»Â¹ := by\n      gcongr\n      exact h_ineq1 <| one_le_powâ‚€ (one_le_iff_ne_zero.mpr hâ‚€)\n    _  = (nâ‚€ * (k * logb nâ‚€ n + 1)) ^ (k : â„)â»Â¹ := by\n      rw [Nat.cast_pow, logb_pow]\n    _  â‰¤ (nâ‚€ * (k * logb nâ‚€ n + k)) ^ (k : â„)â»Â¹ := by\n      gcongr\n      exact one_le_cast.mpr hk\n    _ = (nâ‚€ * (logb nâ‚€ n + 1)) ^ (k : â„)â»Â¹ * k ^ (k : â„)â»Â¹ := by\n      rw [â† mul_rpow (by positivity) (by positivity), mul_assoc, add_mul, one_mul,\n        mul_comm _ (k : â„)]\n-- For 0 < logb nâ‚€ n below we also need to exclude n = 1.\n  rcases eq_or_ne n 1 with rfl | hâ‚\n  Â· simp\n  refine le_of_tendsto_of_tendsto tendsto_const_nhds ?_ (eventually_atTop.mpr âŸ¨1, h_ineq2âŸ©)\n  nth_rw 2 [â† mul_one 1]\n  have : 0 < logb nâ‚€ n := logb_pos (mod_cast hnâ‚€) (by norm_cast; omega)\n  exact (tendsto_const_rpow_inv (by positivity)).mul tendsto_nat_rpow_inv\n\n-- ## Step 2: given m, n â‰¥ 2 and |m| = m^s, |n| = n^t for s, t > 0, we have t â‰¤ s\n\n"}
{"name":"Rat.AbsoluteValue.le_pow_log","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f : AbsoluteValue Rat Real\nm n : Nat\nhm : LT.lt 1 m\nhn : LT.lt 1 n\nnotbdd : Not (âˆ€ (n : Nat), LE.le (f â†‘n) 1)\nâŠ¢ LE.le (f â†‘n) (HPow.hPow (f â†‘m) (Real.logb â†‘m â†‘n))","decl":"include hm hn notbdd in\n/-- Given two natural numbers `n, m` greater than 1 we have `f n â‰¤ f m ^ logb m n`. -/\nlemma le_pow_log : f n â‰¤ f m ^ logb m n := by\n  have : Tendsto (fun k : â„• â†¦ (m * f m / (f m - 1)) ^ (k : â„)â»Â¹ * f m ^ logb m n)\n      atTop (ğ“ (f m ^ logb m n)) := by\n    nth_rw 2 [â† one_mul (f â†‘m ^ logb â†‘m â†‘n)]\n    exact (tendsto_const_rpow_inv (expr_pos hm notbdd)).mul_const _\n  exact le_of_tendsto_of_tendsto (tendsto_const_nhds (x:= f â†‘n)) this <|\n    eventually_atTop.mpr âŸ¨2, fun b hb â†¦ param_upperbound hm hn notbdd (not_eq_zero_of_lt hb)âŸ©\n\n"}
{"name":"Rat.AbsoluteValue.equiv_real_of_unbounded","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f : AbsoluteValue Rat Real\nnotbdd : Not (âˆ€ (n : Nat), LE.le (f â†‘n) 1)\nâŠ¢ HasEquiv.Equiv f Rat.AbsoluteValue.real","decl":"include notbdd in\n/-- If `f` is not bounded and not trivial, then it is equivalent to the standard absolute value on\n`â„š`. -/\ntheorem equiv_real_of_unbounded : f â‰ˆ real := by\n  obtain âŸ¨m, hmâŸ© := Classical.exists_not_of_not_forall notbdd\n  have oneltm : 1 < m := by\n    contrapose! hm\n    rcases le_one_iff_eq_zero_or_eq_one.mp hm with rfl | rfl <;> simp\n  rw [â† equiv_on_nat_iff_equiv]\n  set s := logb m (f m) with hs\n  refine âŸ¨sâ»Â¹,\n    inv_pos.mpr (logb_pos (Nat.one_lt_cast.mpr oneltm) (one_lt_of_not_bounded notbdd oneltm)),\n    fun n â†¦ ?_âŸ©\n  rcases lt_trichotomy n 1 with h | rfl | h\n  Â· obtain rfl : n = 0 := by omega\n    have : (logb (â†‘m) (f â†‘m))â»Â¹ â‰  0 := by\n      simp only [ne_eq, inv_eq_zero, logb_eq_zero, Nat.cast_eq_zero, Nat.cast_eq_one, map_eq_zero,\n        not_or]\n      exact âŸ¨not_eq_zero_of_lt oneltm, oneltm.ne', by norm_cast,\n        not_eq_zero_of_lt oneltm, ne_of_not_le hm, by linarith only [apply_nonneg f â†‘m]âŸ©\n    simp [hs, this]\n  Â· simp\n  Â· simp only [real_eq_abs, abs_cast, Rat.cast_natCast]\n    rw [rpow_inv_eq (apply_nonneg f â†‘n) (Nat.cast_nonneg n)\n      (logb_ne_zero_of_pos_of_ne_one (one_lt_cast.mpr oneltm) (by linarith only [hm])\n      (by linarith only [hm]))]\n    have hfm : f m = m ^ s := by\n      rw [rpow_logb (mod_cast zero_lt_of_lt oneltm) (mod_cast oneltm.ne') (by linarith only [hm])]\n    have hfn : f n = n ^ logb n (f n) := by\n      rw [rpow_logb (mod_cast zero_lt_of_lt h) (mod_cast h.ne')\n        (by apply map_pos_of_ne_zero; exact_mod_cast not_eq_zero_of_lt h)]\n    rwa [â† hs, eq_of_eq_pow oneltm h notbdd hfm hfn]\n\n"}
{"name":"Rat.AbsoluteValue.equiv_real_or_padic","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"f : AbsoluteValue Rat Real\nhf_nontriv : f.IsNontrivial\nâŠ¢ Or (HasEquiv.Equiv f Rat.AbsoluteValue.real) (ExistsUnique fun p => Exists fun x => HasEquiv.Equiv f (Rat.AbsoluteValue.padic p))","decl":"/-- **Ostrowski's Theorem**: every absolute value (with values in `â„`) on `â„š` is equivalent\nto either the standard absolute value or a `p`-adic absolute value for a prime `p`. -/\ntheorem equiv_real_or_padic (f : AbsoluteValue â„š â„) (hf_nontriv : f.IsNontrivial) :\n    f â‰ˆ real âˆ¨ âˆƒ! p, âˆƒ (_ : Fact p.Prime), f â‰ˆ (padic p) := by\n  by_cases bdd : âˆ€ n : â„•, f n â‰¤ 1\n  Â· exact .inr <| equiv_padic_of_bounded hf_nontriv bdd\n  Â· exact .inl <| equiv_real_of_unbounded bdd\n\n"}
{"name":"Rat.AbsoluteValue.not_real_equiv_padic","module":"Mathlib.NumberTheory.Ostrowski","initialProofState":"p : Nat\ninstâœ : Fact (Nat.Prime p)\nâŠ¢ Not (HasEquiv.Equiv Rat.AbsoluteValue.real (Rat.AbsoluteValue.padic p))","decl":"/-- The standard absolute value on `â„š` is not equivalent to any `p`-adic absolute value. -/\nlemma not_real_equiv_padic (p : â„•) [Fact p.Prime] : Â¬ real â‰ˆ (padic p) := by\n  rintro âŸ¨c, hcâ‚€, hcâŸ©\n  apply_fun (Â· 2) at hc\n  simp only [real_eq_abs, abs_ofNat, cast_ofNat] at hc\n  exact ((padic_le_one p 2).trans_lt <| one_lt_rpow one_lt_two hcâ‚€).ne' hc\n\n"}
