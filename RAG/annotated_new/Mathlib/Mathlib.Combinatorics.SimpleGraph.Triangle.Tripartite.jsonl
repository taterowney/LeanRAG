{"name":"SimpleGraph.TripartiteFromTriangles.rel_iff","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\naâœÂ¹ aâœ : Sum Î± (Sum Î² Î³)\nâŠ¢ Iff (SimpleGraph.TripartiteFromTriangles.Rel t aâœÂ¹ aâœ) (Or (Exists fun a => Exists fun b => Exists fun c => And (Membership.mem t { fst := a, snd := { fst := b, snd := c } }) (And (Eq aâœÂ¹ (Sum3.inâ‚€ a)) (Eq aâœ (Sum3.inâ‚ b)))) (Or (Exists fun a => Exists fun b => Exists fun c => And (Membership.mem t { fst := a, snd := { fst := b, snd := c } }) (And (Eq aâœÂ¹ (Sum3.inâ‚ b)) (Eq aâœ (Sum3.inâ‚€ a)))) (Or (Exists fun a => Exists fun b => Exists fun c => And (Membership.mem t { fst := a, snd := { fst := b, snd := c } }) (And (Eq aâœÂ¹ (Sum3.inâ‚€ a)) (Eq aâœ (Sum3.inâ‚‚ c)))) (Or (Exists fun a => Exists fun b => Exists fun c => And (Membership.mem t { fst := a, snd := { fst := b, snd := c } }) (And (Eq aâœÂ¹ (Sum3.inâ‚‚ c)) (Eq aâœ (Sum3.inâ‚€ a)))) (Or (Exists fun a => Exists fun b => Exists fun c => And (Membership.mem t { fst := a, snd := { fst := b, snd := c } }) (And (Eq aâœÂ¹ (Sum3.inâ‚ b)) (Eq aâœ (Sum3.inâ‚‚ c)))) (Exists fun a => Exists fun b => Exists fun c => And (Membership.mem t { fst := a, snd := { fst := b, snd := c } }) (And (Eq aâœÂ¹ (Sum3.inâ‚‚ c)) (Eq aâœ (Sum3.inâ‚ b)))))))))","decl":"/-- The underlying relation of the tripartite-from-triangles graph.\n\nTwo vertices are related iff there exists a triangle index containing them both. -/\n@[mk_iff] inductive Rel (t : Finset (Î± Ã— Î² Ã— Î³)) : Î± âŠ• Î² âŠ• Î³ â†’ Î± âŠ• Î² âŠ• Î³ â†’ Prop\n| inâ‚€â‚ â¦ƒa b câ¦„ : (a, b, c) âˆˆ t â†’ Rel t (inâ‚€ a) (inâ‚ b)\n| inâ‚â‚€ â¦ƒa b câ¦„ : (a, b, c) âˆˆ t â†’ Rel t (inâ‚ b) (inâ‚€ a)\n| inâ‚€â‚‚ â¦ƒa b câ¦„ : (a, b, c) âˆˆ t â†’ Rel t (inâ‚€ a) (inâ‚‚ c)\n| inâ‚‚â‚€ â¦ƒa b câ¦„ : (a, b, c) âˆˆ t â†’ Rel t (inâ‚‚ c) (inâ‚€ a)\n| inâ‚â‚‚ â¦ƒa b câ¦„ : (a, b, c) âˆˆ t â†’ Rel t (inâ‚ b) (inâ‚‚ c)\n| inâ‚‚â‚ â¦ƒa b câ¦„ : (a, b, c) âˆˆ t â†’ Rel t (inâ‚‚ c) (inâ‚ b)\n\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.rel_irrefl","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\nx : Sum Î± (Sum Î² Î³)\nâŠ¢ Not (SimpleGraph.TripartiteFromTriangles.Rel t x x)","decl":"lemma rel_irrefl : âˆ€ x, Â¬ Rel t x x := fun _x hx â†¦ nomatch hx\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.rel_symm","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\nâŠ¢ Symmetric (SimpleGraph.TripartiteFromTriangles.Rel t)","decl":"lemma rel_symm : Symmetric (Rel t) := fun x y h â†¦  by cases h <;> constructor <;> assumption\n\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.Graph.not_inâ‚€â‚€","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\na a' : Î±\nâŠ¢ Not ((SimpleGraph.TripartiteFromTriangles.graph t).Adj (Sum3.inâ‚€ a) (Sum3.inâ‚€ a'))","decl":"@[simp] lemma not_inâ‚€â‚€ : Â¬ (graph t).Adj (inâ‚€ a) (inâ‚€ a') := fun h â†¦ nomatch h\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.Graph.not_inâ‚â‚","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\nb b' : Î²\nâŠ¢ Not ((SimpleGraph.TripartiteFromTriangles.graph t).Adj (Sum3.inâ‚ b) (Sum3.inâ‚ b'))","decl":"@[simp] lemma not_inâ‚â‚ : Â¬ (graph t).Adj (inâ‚ b) (inâ‚ b') := fun h â†¦ nomatch h\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.Graph.not_inâ‚‚â‚‚","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\nc c' : Î³\nâŠ¢ Not ((SimpleGraph.TripartiteFromTriangles.graph t).Adj (Sum3.inâ‚‚ c) (Sum3.inâ‚‚ c'))","decl":"@[simp] lemma not_inâ‚‚â‚‚ : Â¬ (graph t).Adj (inâ‚‚ c) (inâ‚‚ c') := fun h â†¦ nomatch h\n\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.Graph.inâ‚€â‚_iff","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\na : Î±\nb : Î²\nâŠ¢ Iff ((SimpleGraph.TripartiteFromTriangles.graph t).Adj (Sum3.inâ‚€ a) (Sum3.inâ‚ b)) (Exists fun c => Membership.mem t { fst := a, snd := { fst := b, snd := c } })","decl":"@[simp] lemma inâ‚€â‚_iff : (graph t).Adj (inâ‚€ a) (inâ‚ b) â†” âˆƒ c, (a, b, c) âˆˆ t :=\n  âŸ¨by rintro âŸ¨âŸ©; exact âŸ¨_, â€¹_â€ºâŸ©, fun âŸ¨_, hâŸ© â†¦ inâ‚€â‚ hâŸ©\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.Graph.inâ‚â‚€_iff","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\na : Î±\nb : Î²\nâŠ¢ Iff ((SimpleGraph.TripartiteFromTriangles.graph t).Adj (Sum3.inâ‚ b) (Sum3.inâ‚€ a)) (Exists fun c => Membership.mem t { fst := a, snd := { fst := b, snd := c } })","decl":"@[simp] lemma inâ‚â‚€_iff : (graph t).Adj (inâ‚ b) (inâ‚€ a) â†” âˆƒ c, (a, b, c) âˆˆ t :=\n  âŸ¨by rintro âŸ¨âŸ©; exact âŸ¨_, â€¹_â€ºâŸ©, fun âŸ¨_, hâŸ© â†¦ inâ‚â‚€ hâŸ©\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.Graph.inâ‚€â‚‚_iff","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\na : Î±\nc : Î³\nâŠ¢ Iff ((SimpleGraph.TripartiteFromTriangles.graph t).Adj (Sum3.inâ‚€ a) (Sum3.inâ‚‚ c)) (Exists fun b => Membership.mem t { fst := a, snd := { fst := b, snd := c } })","decl":"@[simp] lemma inâ‚€â‚‚_iff : (graph t).Adj (inâ‚€ a) (inâ‚‚ c) â†” âˆƒ b, (a, b, c) âˆˆ t :=\n  âŸ¨by rintro âŸ¨âŸ©; exact âŸ¨_, â€¹_â€ºâŸ©, fun âŸ¨_, hâŸ© â†¦ inâ‚€â‚‚ hâŸ©\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.Graph.inâ‚‚â‚€_iff","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\na : Î±\nc : Î³\nâŠ¢ Iff ((SimpleGraph.TripartiteFromTriangles.graph t).Adj (Sum3.inâ‚‚ c) (Sum3.inâ‚€ a)) (Exists fun b => Membership.mem t { fst := a, snd := { fst := b, snd := c } })","decl":"@[simp] lemma inâ‚‚â‚€_iff : (graph t).Adj (inâ‚‚ c) (inâ‚€ a) â†” âˆƒ b, (a, b, c) âˆˆ t :=\n  âŸ¨by rintro âŸ¨âŸ©; exact âŸ¨_, â€¹_â€ºâŸ©, fun âŸ¨_, hâŸ© â†¦ inâ‚‚â‚€ hâŸ©\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.Graph.inâ‚â‚‚_iff","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\nb : Î²\nc : Î³\nâŠ¢ Iff ((SimpleGraph.TripartiteFromTriangles.graph t).Adj (Sum3.inâ‚ b) (Sum3.inâ‚‚ c)) (Exists fun a => Membership.mem t { fst := a, snd := { fst := b, snd := c } })","decl":"@[simp] lemma inâ‚â‚‚_iff : (graph t).Adj (inâ‚ b) (inâ‚‚ c) â†” âˆƒ a, (a, b, c) âˆˆ t :=\n  âŸ¨by rintro âŸ¨âŸ©; exact âŸ¨_, â€¹_â€ºâŸ©, fun âŸ¨_, hâŸ© â†¦ inâ‚â‚‚ hâŸ©\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.Graph.inâ‚‚â‚_iff","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\nb : Î²\nc : Î³\nâŠ¢ Iff ((SimpleGraph.TripartiteFromTriangles.graph t).Adj (Sum3.inâ‚‚ c) (Sum3.inâ‚ b)) (Exists fun a => Membership.mem t { fst := a, snd := { fst := b, snd := c } })","decl":"@[simp] lemma inâ‚‚â‚_iff : (graph t).Adj (inâ‚‚ c) (inâ‚ b) â†” âˆƒ a, (a, b, c) âˆˆ t :=\n  âŸ¨by rintro âŸ¨âŸ©; exact âŸ¨_, â€¹_â€ºâŸ©, fun âŸ¨_, hâŸ© â†¦ inâ‚‚â‚ hâŸ©\n\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.Graph.inâ‚€â‚_iff'","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\na : Î±\nb : Î²\nâŠ¢ Iff ((SimpleGraph.TripartiteFromTriangles.graph t).Adj (Sum3.inâ‚€ a) (Sum3.inâ‚ b)) (Exists fun x => And (Membership.mem t x) (And (Eq x.1 a) (Eq x.2.1 b)))","decl":"lemma inâ‚€â‚_iff' :\n    (graph t).Adj (inâ‚€ a) (inâ‚ b) â†” âˆƒ x : Î± Ã— Î² Ã— Î³, x âˆˆ t âˆ§ x.1 = a âˆ§ x.2.1 = b where\n  mp := by rintro âŸ¨âŸ©; exact âŸ¨_, â€¹_â€º, by simpâŸ©\n  mpr := by rintro âŸ¨âŸ¨a, b, câŸ©, h, rfl, rflâŸ©; constructor; assumption\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.Graph.inâ‚â‚€_iff'","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\na : Î±\nb : Î²\nâŠ¢ Iff ((SimpleGraph.TripartiteFromTriangles.graph t).Adj (Sum3.inâ‚ b) (Sum3.inâ‚€ a)) (Exists fun x => And (Membership.mem t x) (And (Eq x.2.1 b) (Eq x.1 a)))","decl":"lemma inâ‚â‚€_iff' :\n    (graph t).Adj (inâ‚ b) (inâ‚€ a) â†” âˆƒ x : Î± Ã— Î² Ã— Î³, x âˆˆ t âˆ§ x.2.1 = b âˆ§ x.1 = a where\n  mp := by rintro âŸ¨âŸ©; exact âŸ¨_, â€¹_â€º, by simpâŸ©\n  mpr := by rintro âŸ¨âŸ¨a, b, câŸ©, h, rfl, rflâŸ©; constructor; assumption\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.Graph.inâ‚€â‚‚_iff'","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\na : Î±\nc : Î³\nâŠ¢ Iff ((SimpleGraph.TripartiteFromTriangles.graph t).Adj (Sum3.inâ‚€ a) (Sum3.inâ‚‚ c)) (Exists fun x => And (Membership.mem t x) (And (Eq x.1 a) (Eq x.2.2 c)))","decl":"lemma inâ‚€â‚‚_iff' :\n    (graph t).Adj (inâ‚€ a) (inâ‚‚ c) â†” âˆƒ x : Î± Ã— Î² Ã— Î³, x âˆˆ t âˆ§ x.1 = a âˆ§ x.2.2 = c where\n  mp := by rintro âŸ¨âŸ©; exact âŸ¨_, â€¹_â€º, by simpâŸ©\n  mpr := by rintro âŸ¨âŸ¨a, b, câŸ©, h, rfl, rflâŸ©; constructor; assumption\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.Graph.inâ‚‚â‚€_iff'","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\na : Î±\nc : Î³\nâŠ¢ Iff ((SimpleGraph.TripartiteFromTriangles.graph t).Adj (Sum3.inâ‚‚ c) (Sum3.inâ‚€ a)) (Exists fun x => And (Membership.mem t x) (And (Eq x.2.2 c) (Eq x.1 a)))","decl":"lemma inâ‚‚â‚€_iff' :\n    (graph t).Adj (inâ‚‚ c) (inâ‚€ a) â†” âˆƒ x : Î± Ã— Î² Ã— Î³, x âˆˆ t âˆ§ x.2.2 = c âˆ§ x.1 = a where\n  mp := by rintro âŸ¨âŸ©; exact âŸ¨_, â€¹_â€º, by simpâŸ©\n  mpr := by rintro âŸ¨âŸ¨a, b, câŸ©, h, rfl, rflâŸ©; constructor; assumption\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.Graph.inâ‚â‚‚_iff'","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\nb : Î²\nc : Î³\nâŠ¢ Iff ((SimpleGraph.TripartiteFromTriangles.graph t).Adj (Sum3.inâ‚ b) (Sum3.inâ‚‚ c)) (Exists fun x => And (Membership.mem t x) (And (Eq x.2.1 b) (Eq x.2.2 c)))","decl":"lemma inâ‚â‚‚_iff' :\n    (graph t).Adj (inâ‚ b) (inâ‚‚ c) â†” âˆƒ x : Î± Ã— Î² Ã— Î³, x âˆˆ t âˆ§ x.2.1 = b âˆ§ x.2.2 = c where\n  mp := by rintro âŸ¨âŸ©; exact âŸ¨_, â€¹_â€º, by simpâŸ©\n  mpr := by rintro âŸ¨âŸ¨a, b, câŸ©, h, rfl, rflâŸ©; constructor; assumption\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.Graph.inâ‚‚â‚_iff'","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\nb : Î²\nc : Î³\nâŠ¢ Iff ((SimpleGraph.TripartiteFromTriangles.graph t).Adj (Sum3.inâ‚‚ c) (Sum3.inâ‚ b)) (Exists fun x => And (Membership.mem t x) (And (Eq x.2.2 c) (Eq x.2.1 b)))","decl":"lemma inâ‚‚â‚_iff' :\n    (graph t).Adj (inâ‚‚ c) (inâ‚ b) â†” âˆƒ x : Î± Ã— Î² Ã— Î³, x âˆˆ t âˆ§ x.2.2 = c âˆ§ x.2.1 = b where\n  mp := by rintro âŸ¨âŸ©; exact âŸ¨_, â€¹_â€º, by simpâŸ©\n  mpr := by rintro âŸ¨âŸ¨a, b, câŸ©, h, rfl, rflâŸ©; constructor; assumption\n\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.ExplicitDisjoint.injâ‚€","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\nself : SimpleGraph.TripartiteFromTriangles.ExplicitDisjoint t\na : Î±\nb : Î²\nc : Î³\na' : Î±\naâœÂ¹ : Membership.mem t { fst := a, snd := { fst := b, snd := c } }\naâœ : Membership.mem t { fst := a', snd := { fst := b, snd := c } }\nâŠ¢ Eq a a'","decl":"/-- Predicate on the triangle indices for the explicit triangles to be edge-disjoint. -/\nclass ExplicitDisjoint (t : Finset (Î± Ã— Î² Ã— Î³)) : Prop where\n  injâ‚€ : âˆ€ â¦ƒa b c a'â¦„, (a, b, c) âˆˆ t â†’ (a', b, c) âˆˆ t â†’ a = a'\n  injâ‚ : âˆ€ â¦ƒa b c b'â¦„, (a, b, c) âˆˆ t â†’ (a, b', c) âˆˆ t â†’ b = b'\n  injâ‚‚ : âˆ€ â¦ƒa b c c'â¦„, (a, b, c) âˆˆ t â†’ (a, b, c') âˆˆ t â†’ c = c'\n\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.ExplicitDisjoint.injâ‚‚","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\nself : SimpleGraph.TripartiteFromTriangles.ExplicitDisjoint t\na : Î±\nb : Î²\nc c' : Î³\naâœÂ¹ : Membership.mem t { fst := a, snd := { fst := b, snd := c } }\naâœ : Membership.mem t { fst := a, snd := { fst := b, snd := c' } }\nâŠ¢ Eq c c'","decl":"/-- Predicate on the triangle indices for the explicit triangles to be edge-disjoint. -/\nclass ExplicitDisjoint (t : Finset (Î± Ã— Î² Ã— Î³)) : Prop where\n  injâ‚€ : âˆ€ â¦ƒa b c a'â¦„, (a, b, c) âˆˆ t â†’ (a', b, c) âˆˆ t â†’ a = a'\n  injâ‚ : âˆ€ â¦ƒa b c b'â¦„, (a, b, c) âˆˆ t â†’ (a, b', c) âˆˆ t â†’ b = b'\n  injâ‚‚ : âˆ€ â¦ƒa b c c'â¦„, (a, b, c) âˆˆ t â†’ (a, b, c') âˆˆ t â†’ c = c'\n\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.ExplicitDisjoint.injâ‚","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\nself : SimpleGraph.TripartiteFromTriangles.ExplicitDisjoint t\na : Î±\nb : Î²\nc : Î³\nb' : Î²\naâœÂ¹ : Membership.mem t { fst := a, snd := { fst := b, snd := c } }\naâœ : Membership.mem t { fst := a, snd := { fst := b', snd := c } }\nâŠ¢ Eq b b'","decl":"/-- Predicate on the triangle indices for the explicit triangles to be edge-disjoint. -/\nclass ExplicitDisjoint (t : Finset (Î± Ã— Î² Ã— Î³)) : Prop where\n  injâ‚€ : âˆ€ â¦ƒa b c a'â¦„, (a, b, c) âˆˆ t â†’ (a', b, c) âˆˆ t â†’ a = a'\n  injâ‚ : âˆ€ â¦ƒa b c b'â¦„, (a, b, c) âˆˆ t â†’ (a, b', c) âˆˆ t â†’ b = b'\n  injâ‚‚ : âˆ€ â¦ƒa b c c'â¦„, (a, b, c) âˆˆ t â†’ (a, b, c') âˆˆ t â†’ c = c'\n\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.NoAccidental.eq_or_eq_or_eq","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\nself : SimpleGraph.TripartiteFromTriangles.NoAccidental t\na a' : Î±\nb b' : Î²\nc c' : Î³\naâœÂ² : Membership.mem t { fst := a', snd := { fst := b, snd := c } }\naâœÂ¹ : Membership.mem t { fst := a, snd := { fst := b', snd := c } }\naâœ : Membership.mem t { fst := a, snd := { fst := b, snd := c' } }\nâŠ¢ Or (Eq a a') (Or (Eq b b') (Eq c c'))","decl":"/-- Predicate on the triangle indices for there to be no accidental triangle.\n\nNote that we cheat a bit, since the exact translation of this informal description would have\n`(a', b', c') âˆˆ t` as a conclusion rather than `a = a' âˆ¨ b = b' âˆ¨ c = c'`. Those conditions are\nequivalent when the explicit triangles are edge-disjoint (which is the case we care about). -/\nclass NoAccidental (t : Finset (Î± Ã— Î² Ã— Î³)) : Prop where\n  eq_or_eq_or_eq : âˆ€ â¦ƒa a' b b' c c'â¦„, (a', b, c) âˆˆ t â†’ (a, b', c) âˆˆ t â†’ (a, b, c') âˆˆ t â†’\n    a = a' âˆ¨ b = b' âˆ¨ c = c'\n\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.graph_triple","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\ninstâœÂ² : DecidableEq Î±\ninstâœÂ¹ : DecidableEq Î²\ninstâœ : DecidableEq Î³\nx y z : Sum Î± (Sum Î² Î³)\naâœÂ² : (SimpleGraph.TripartiteFromTriangles.graph t).Adj x y\naâœÂ¹ : (SimpleGraph.TripartiteFromTriangles.graph t).Adj x z\naâœ : (SimpleGraph.TripartiteFromTriangles.graph t).Adj y z\nâŠ¢ Exists fun a => Exists fun b => Exists fun c => And (Eq (Insert.insert (Sum3.inâ‚€ a) (Insert.insert (Sum3.inâ‚ b) (Singleton.singleton (Sum3.inâ‚‚ c)))) (Insert.insert x (Insert.insert y (Singleton.singleton z)))) (And ((SimpleGraph.TripartiteFromTriangles.graph t).Adj (Sum3.inâ‚€ a) (Sum3.inâ‚ b)) (And ((SimpleGraph.TripartiteFromTriangles.graph t).Adj (Sum3.inâ‚€ a) (Sum3.inâ‚‚ c)) ((SimpleGraph.TripartiteFromTriangles.graph t).Adj (Sum3.inâ‚ b) (Sum3.inâ‚‚ c))))","decl":"/-- This lemma reorders the elements of a triangle in the tripartite graph. It turns a triangle\n`{x, y, z}` into a triangle `{a, b, c}` where `a : Î± `, `b : Î²`, `c : Î³`. -/\n lemma graph_triple â¦ƒx y zâ¦„ :\n  (graph t).Adj x y â†’ (graph t).Adj x z â†’ (graph t).Adj y z â†’ âˆƒ a b c,\n    ({inâ‚€ a, inâ‚ b, inâ‚‚ c} : Finset (Î± âŠ• Î² âŠ• Î³)) = {x, y, z} âˆ§ (graph t).Adj (inâ‚€ a) (inâ‚ b) âˆ§\n      (graph t).Adj (inâ‚€ a) (inâ‚‚ c) âˆ§ (graph t).Adj (inâ‚ b) (inâ‚‚ c) := by\n  rintro (_ | _ | _) (_ | _ | _) (_ | _ | _) <;>\n    refine âŸ¨_, _, _, by ext; simp only [Finset.mem_insert, Finset.mem_singleton]; try tauto,\n      ?_, ?_, ?_âŸ© <;> constructor <;> assumption\n\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.toTriangle_apply","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ² : DecidableEq Î±\ninstâœÂ¹ : DecidableEq Î²\ninstâœ : DecidableEq Î³\nx : Prod Î± (Prod Î² Î³)\nâŠ¢ Eq (SimpleGraph.TripartiteFromTriangles.toTriangle x) (Insert.insert (Sum3.inâ‚€ x.1) (Insert.insert (Sum3.inâ‚ x.2.1) (Singleton.singleton (Sum3.inâ‚‚ x.2.2))))","decl":"/-- The map that turns a triangle index into an explicit triangle. -/\n@[simps] def toTriangle : Î± Ã— Î² Ã— Î³ â†ª Finset (Î± âŠ• Î² âŠ• Î³) where\n  toFun x := {inâ‚€ x.1, inâ‚ x.2.1, inâ‚‚ x.2.2}\n  inj' := fun âŸ¨a, b, câŸ© âŸ¨a', b', c'âŸ© â†¦ by simpa only [Finset.Subset.antisymm_iff, Finset.subset_iff,\n    mem_insert, mem_singleton, forall_eq_or_imp, forall_eq, Prod.mk.inj_iff, or_false, false_or,\n    inâ‚€, inâ‚, inâ‚‚, Sum.inl.inj_iff, Sum.inr.inj_iff, reduceCtorEq] using And.left\n\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.toTriangle_is3Clique","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\nx : Prod Î± (Prod Î² Î³)\ninstâœÂ² : DecidableEq Î±\ninstâœÂ¹ : DecidableEq Î²\ninstâœ : DecidableEq Î³\nhx : Membership.mem t x\nâŠ¢ (SimpleGraph.TripartiteFromTriangles.graph t).IsNClique 3 (SimpleGraph.TripartiteFromTriangles.toTriangle x)","decl":"lemma toTriangle_is3Clique (hx : x âˆˆ t) : (graph t).IsNClique 3 (toTriangle x) := by\n  simp only [toTriangle_apply, is3Clique_triple_iff, inâ‚€â‚_iff, inâ‚€â‚‚_iff, inâ‚â‚‚_iff]\n  exact âŸ¨âŸ¨_, hxâŸ©, âŸ¨_, hxâŸ©, _, hxâŸ©\n\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.exists_mem_toTriangle","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\ninstâœÂ² : DecidableEq Î±\ninstâœÂ¹ : DecidableEq Î²\ninstâœ : DecidableEq Î³\nx y : Sum Î± (Sum Î² Î³)\nhxy : (SimpleGraph.TripartiteFromTriangles.graph t).Adj x y\nâŠ¢ Exists fun z => And (Membership.mem t z) (And (Membership.mem (SimpleGraph.TripartiteFromTriangles.toTriangle z) x) (Membership.mem (SimpleGraph.TripartiteFromTriangles.toTriangle z) y))","decl":"lemma exists_mem_toTriangle {x y : Î± âŠ• Î² âŠ• Î³} (hxy : (graph t).Adj x y) :\n    âˆƒ z âˆˆ t, x âˆˆ toTriangle z âˆ§ y âˆˆ toTriangle z := by cases hxy <;> exact âŸ¨_, â€¹_â€º, by simpâŸ©\n\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.is3Clique_iff","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\ninstâœÂ³ : DecidableEq Î±\ninstâœÂ² : DecidableEq Î²\ninstâœÂ¹ : DecidableEq Î³\ninstâœ : SimpleGraph.TripartiteFromTriangles.NoAccidental t\ns : Finset (Sum Î± (Sum Î² Î³))\nâŠ¢ Iff ((SimpleGraph.TripartiteFromTriangles.graph t).IsNClique 3 s) (Exists fun x => And (Membership.mem t x) (Eq (SimpleGraph.TripartiteFromTriangles.toTriangle x) s))","decl":"nonrec lemma is3Clique_iff [NoAccidental t] {s : Finset (Î± âŠ• Î² âŠ• Î³)} :\n    (graph t).IsNClique 3 s â†” âˆƒ x, x âˆˆ t âˆ§ toTriangle x = s := by\n  refine âŸ¨fun h â†¦ ?_, ?_âŸ©\n  Â· rw [is3Clique_iff] at h\n    obtain âŸ¨x, y, z, hxy, hxz, hyz, rflâŸ© := h\n    obtain âŸ¨a, b, c, habc, hab, hac, hbcâŸ© := graph_triple hxy hxz hyz\n    refine âŸ¨(a, b, c), ?_, habcâŸ©\n    obtain âŸ¨c', hc'âŸ© := inâ‚€â‚_iff.1 hab\n    obtain âŸ¨b', hb'âŸ© := inâ‚€â‚‚_iff.1 hac\n    obtain âŸ¨a', ha'âŸ© := inâ‚â‚‚_iff.1 hbc\n    obtain rfl | rfl | rfl := NoAccidental.eq_or_eq_or_eq ha' hb' hc' <;> assumption\n  Â· rintro âŸ¨x, hx, rflâŸ©\n    exact toTriangle_is3Clique hx\n\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.toTriangle_surjOn","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\ninstâœÂ³ : DecidableEq Î±\ninstâœÂ² : DecidableEq Î²\ninstâœÂ¹ : DecidableEq Î³\ninstâœ : SimpleGraph.TripartiteFromTriangles.NoAccidental t\nâŠ¢ Set.SurjOn (â‡‘SimpleGraph.TripartiteFromTriangles.toTriangle) (â†‘t) ((SimpleGraph.TripartiteFromTriangles.graph t).cliqueSet 3)","decl":"lemma toTriangle_surjOn [NoAccidental t] :\n    (t : Set (Î± Ã— Î² Ã— Î³)).SurjOn toTriangle ((graph t).cliqueSet 3) := fun _ â†¦ is3Clique_iff.1\n\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.map_toTriangle_disjoint","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\ninstâœÂ³ : DecidableEq Î±\ninstâœÂ² : DecidableEq Î²\ninstâœÂ¹ : DecidableEq Î³\ninstâœ : SimpleGraph.TripartiteFromTriangles.ExplicitDisjoint t\nâŠ¢ (â†‘(Finset.map SimpleGraph.TripartiteFromTriangles.toTriangle t)).Pairwise fun x y => (Inter.inter â†‘x â†‘y).Subsingleton","decl":"lemma map_toTriangle_disjoint [ExplicitDisjoint t] :\n    (t.map toTriangle : Set (Finset (Î± âŠ• Î² âŠ• Î³))).Pairwise\n      fun x y â†¦ (x âˆ© y : Set (Î± âŠ• Î² âŠ• Î³)).Subsingleton := by\n  intro\n  simp only [Finset.coe_map, Set.mem_image, Finset.mem_coe, Prod.exists, Ne,\n    forall_exists_index, and_imp]\n  rintro a b c habc rfl e x y z hxyz rfl h'\n  have := ne_of_apply_ne _ h'\n  simp only [Ne, Prod.mk.inj_iff, not_and] at this\n  simp only [toTriangle_apply, inâ‚€, inâ‚, inâ‚‚, Set.mem_inter_iff, mem_insert, mem_singleton,\n    mem_coe, and_imp, Sum.forall, or_false, forall_eq, false_or, eq_self_iff_true, imp_true_iff,\n    true_and, and_true, Set.Subsingleton]\n  suffices Â¬ (a = x âˆ§ b = y) âˆ§ Â¬ (a = x âˆ§ c = z) âˆ§ Â¬ (b = y âˆ§ c = z) by aesop\n  refine âŸ¨?_, ?_, ?_âŸ©\n  Â· rintro âŸ¨rfl, rflâŸ©\n    exact this rfl rfl (ExplicitDisjoint.injâ‚‚ habc hxyz)\n  Â· rintro âŸ¨rfl, rflâŸ©\n    exact this rfl (ExplicitDisjoint.injâ‚ habc hxyz) rfl\n  Â· rintro âŸ¨rfl, rflâŸ©\n    exact this (ExplicitDisjoint.injâ‚€ habc hxyz) rfl rfl\n\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.cliqueSet_eq_image","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\ninstâœÂ³ : DecidableEq Î±\ninstâœÂ² : DecidableEq Î²\ninstâœÂ¹ : DecidableEq Î³\ninstâœ : SimpleGraph.TripartiteFromTriangles.NoAccidental t\nâŠ¢ Eq ((SimpleGraph.TripartiteFromTriangles.graph t).cliqueSet 3) (Set.image â‡‘SimpleGraph.TripartiteFromTriangles.toTriangle â†‘t)","decl":"lemma cliqueSet_eq_image [NoAccidental t] : (graph t).cliqueSet 3 = toTriangle '' t := by\n  ext; exact is3Clique_iff\n\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.cliqueFinset_eq_image","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\ninstâœâ¶ : DecidableEq Î±\ninstâœâµ : DecidableEq Î²\ninstâœâ´ : DecidableEq Î³\ninstâœÂ³ : Fintype Î±\ninstâœÂ² : Fintype Î²\ninstâœÂ¹ : Fintype Î³\ninstâœ : SimpleGraph.TripartiteFromTriangles.NoAccidental t\nâŠ¢ Eq ((SimpleGraph.TripartiteFromTriangles.graph t).cliqueFinset 3) (Finset.image (â‡‘SimpleGraph.TripartiteFromTriangles.toTriangle) t)","decl":"lemma cliqueFinset_eq_image [NoAccidental t] : (graph t).cliqueFinset 3 = t.image toTriangle :=\n  coe_injective <| by push_cast; exact cliqueSet_eq_image _\n\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.cliqueFinset_eq_map","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\ninstâœâ¶ : DecidableEq Î±\ninstâœâµ : DecidableEq Î²\ninstâœâ´ : DecidableEq Î³\ninstâœÂ³ : Fintype Î±\ninstâœÂ² : Fintype Î²\ninstâœÂ¹ : Fintype Î³\ninstâœ : SimpleGraph.TripartiteFromTriangles.NoAccidental t\nâŠ¢ Eq ((SimpleGraph.TripartiteFromTriangles.graph t).cliqueFinset 3) (Finset.map SimpleGraph.TripartiteFromTriangles.toTriangle t)","decl":"lemma cliqueFinset_eq_map [NoAccidental t] : (graph t).cliqueFinset 3 = t.map toTriangle := by\n  simp [cliqueFinset_eq_image, map_eq_image]\n\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.card_triangles","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\ninstâœâ¶ : DecidableEq Î±\ninstâœâµ : DecidableEq Î²\ninstâœâ´ : DecidableEq Î³\ninstâœÂ³ : Fintype Î±\ninstâœÂ² : Fintype Î²\ninstâœÂ¹ : Fintype Î³\ninstâœ : SimpleGraph.TripartiteFromTriangles.NoAccidental t\nâŠ¢ Eq ((SimpleGraph.TripartiteFromTriangles.graph t).cliqueFinset 3).card t.card","decl":"@[simp] lemma card_triangles [NoAccidental t] : #((graph t).cliqueFinset 3) = #t := by\n  rw [cliqueFinset_eq_map, card_map]\n\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.farFromTriangleFree","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nğ•œ : Type u_4\ninstâœâ· : LinearOrderedField ğ•œ\nt : Finset (Prod Î± (Prod Î² Î³))\ninstâœâ¶ : DecidableEq Î±\ninstâœâµ : DecidableEq Î²\ninstâœâ´ : DecidableEq Î³\ninstâœÂ³ : Fintype Î±\ninstâœÂ² : Fintype Î²\ninstâœÂ¹ : Fintype Î³\ninstâœ : SimpleGraph.TripartiteFromTriangles.ExplicitDisjoint t\nÎµ : ğ•œ\nht : LE.le (HMul.hMul Îµ â†‘(HPow.hPow (HAdd.hAdd (HAdd.hAdd (Fintype.card Î±) (Fintype.card Î²)) (Fintype.card Î³)) 2)) â†‘t.card\nâŠ¢ (SimpleGraph.TripartiteFromTriangles.graph t).FarFromTriangleFree Îµ","decl":"lemma farFromTriangleFree [ExplicitDisjoint t] {Îµ : ğ•œ}\n    (ht : Îµ * ((Fintype.card Î± + Fintype.card Î² + Fintype.card Î³) ^ 2 : â„•) â‰¤ #t) :\n    (graph t).FarFromTriangleFree Îµ :=\n  farFromTriangleFree_of_disjoint_triangles (t.map toTriangle)\n    (map_subset_iff_subset_preimage.2 fun x hx â†¦ by simpa using toTriangle_is3Clique hx)\n    (map_toTriangle_disjoint t) <| by simpa [add_assoc] using ht\n\n"}
{"name":"SimpleGraph.TripartiteFromTriangles.locallyLinear","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nt : Finset (Prod Î± (Prod Î² Î³))\ninstâœÂ¹ : SimpleGraph.TripartiteFromTriangles.ExplicitDisjoint t\ninstâœ : SimpleGraph.TripartiteFromTriangles.NoAccidental t\nâŠ¢ (SimpleGraph.TripartiteFromTriangles.graph t).LocallyLinear","decl":"lemma locallyLinear [ExplicitDisjoint t] [NoAccidental t] : (graph t).LocallyLinear := by\n  classical\n  refine âŸ¨?_, fun x y hxy â†¦ ?_âŸ©\n  Â· unfold EdgeDisjointTriangles\n    convert map_toTriangle_disjoint t\n    rw [cliqueSet_eq_image, coe_map]\n  Â· obtain âŸ¨z, hz, hxyâŸ© := exists_mem_toTriangle hxy\n    exact âŸ¨_, toTriangle_is3Clique hz, hxyâŸ©\n\n"}
