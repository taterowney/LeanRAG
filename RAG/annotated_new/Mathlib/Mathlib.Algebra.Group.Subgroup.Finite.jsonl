{"name":"AddSubgroup.instFiniteSubtypeMem","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nK : AddSubgroup G\ninst✝ : Finite G\n⊢ Finite (Subtype fun x => Membership.mem K x)","decl":"@[to_additive]\ninstance (K : Subgroup G) [Finite G] : Finite K :=\n  Subtype.finite\n\n"}
{"name":"Subgroup.instFiniteSubtypeMem","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nK : Subgroup G\ninst✝ : Finite G\n⊢ Finite (Subtype fun x => Membership.mem K x)","decl":"@[to_additive]\ninstance (K : Subgroup G) [Finite G] : Finite K :=\n  Subtype.finite\n\n"}
{"name":"Subgroup.list_prod_mem","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Subgroup G\nl : List G\na✝ : ∀ (x : G), Membership.mem l x → Membership.mem K x\n⊢ Membership.mem K l.prod","decl":"/-- Product of a list of elements in a subgroup is in the subgroup. -/\n@[to_additive \"Sum of a list of elements in an `AddSubgroup` is in the `AddSubgroup`.\"]\nprotected theorem list_prod_mem {l : List G} : (∀ x ∈ l, x ∈ K) → l.prod ∈ K :=\n  list_prod_mem\n\n"}
{"name":"AddSubgroup.list_sum_mem","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nK : AddSubgroup G\nl : List G\na✝ : ∀ (x : G), Membership.mem l x → Membership.mem K x\n⊢ Membership.mem K l.sum","decl":"/-- Product of a list of elements in a subgroup is in the subgroup. -/\n@[to_additive \"Sum of a list of elements in an `AddSubgroup` is in the `AddSubgroup`.\"]\nprotected theorem list_prod_mem {l : List G} : (∀ x ∈ l, x ∈ K) → l.prod ∈ K :=\n  list_prod_mem\n\n"}
{"name":"AddSubgroup.multiset_sum_mem","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\nK : AddSubgroup G\ng : Multiset G\na✝ : ∀ (a : G), Membership.mem g a → Membership.mem K a\n⊢ Membership.mem K g.sum","decl":"/-- Product of a multiset of elements in a subgroup of a `CommGroup` is in the subgroup. -/\n@[to_additive \"Sum of a multiset of elements in an `AddSubgroup` of an `AddCommGroup` is in\n the `AddSubgroup`.\"]\nprotected theorem multiset_prod_mem {G} [CommGroup G] (K : Subgroup G) (g : Multiset G) :\n    (∀ a ∈ g, a ∈ K) → g.prod ∈ K :=\n  multiset_prod_mem g\n\n"}
{"name":"Subgroup.multiset_prod_mem","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\nK : Subgroup G\ng : Multiset G\na✝ : ∀ (a : G), Membership.mem g a → Membership.mem K a\n⊢ Membership.mem K g.prod","decl":"/-- Product of a multiset of elements in a subgroup of a `CommGroup` is in the subgroup. -/\n@[to_additive \"Sum of a multiset of elements in an `AddSubgroup` of an `AddCommGroup` is in\n the `AddSubgroup`.\"]\nprotected theorem multiset_prod_mem {G} [CommGroup G] (K : Subgroup G) (g : Multiset G) :\n    (∀ a ∈ g, a ∈ K) → g.prod ∈ K :=\n  multiset_prod_mem g\n\n"}
{"name":"Subgroup.multiset_noncommProd_mem","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Subgroup G\ng : Multiset G\ncomm : (setOf fun x => Membership.mem g x).Pairwise Commute\na✝ : ∀ (a : G), Membership.mem g a → Membership.mem K a\n⊢ Membership.mem K (g.noncommProd comm)","decl":"@[to_additive]\ntheorem multiset_noncommProd_mem (K : Subgroup G) (g : Multiset G) (comm) :\n    (∀ a ∈ g, a ∈ K) → g.noncommProd comm ∈ K :=\n  K.toSubmonoid.multiset_noncommProd_mem g comm\n\n"}
{"name":"AddSubgroup.multiset_noncommSum_mem","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nK : AddSubgroup G\ng : Multiset G\ncomm : (setOf fun x => Membership.mem g x).Pairwise AddCommute\na✝ : ∀ (a : G), Membership.mem g a → Membership.mem K a\n⊢ Membership.mem K (g.noncommSum comm)","decl":"@[to_additive]\ntheorem multiset_noncommProd_mem (K : Subgroup G) (g : Multiset G) (comm) :\n    (∀ a ∈ g, a ∈ K) → g.noncommProd comm ∈ K :=\n  K.toSubmonoid.multiset_noncommProd_mem g comm\n\n"}
{"name":"AddSubgroup.sum_mem","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\nK : AddSubgroup G\nι : Type u_4\nt : Finset ι\nf : ι → G\nh : ∀ (c : ι), Membership.mem t c → Membership.mem K (f c)\n⊢ Membership.mem K (t.sum fun c => f c)","decl":"/-- Product of elements of a subgroup of a `CommGroup` indexed by a `Finset` is in the\n    subgroup. -/\n@[to_additive \"Sum of elements in an `AddSubgroup` of an `AddCommGroup` indexed by a `Finset`\n is in the `AddSubgroup`.\"]\nprotected theorem prod_mem {G : Type*} [CommGroup G] (K : Subgroup G) {ι : Type*} {t : Finset ι}\n    {f : ι → G} (h : ∀ c ∈ t, f c ∈ K) : (∏ c ∈ t, f c) ∈ K :=\n  prod_mem h\n\n"}
{"name":"Subgroup.prod_mem","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\nK : Subgroup G\nι : Type u_4\nt : Finset ι\nf : ι → G\nh : ∀ (c : ι), Membership.mem t c → Membership.mem K (f c)\n⊢ Membership.mem K (t.prod fun c => f c)","decl":"/-- Product of elements of a subgroup of a `CommGroup` indexed by a `Finset` is in the\n    subgroup. -/\n@[to_additive \"Sum of elements in an `AddSubgroup` of an `AddCommGroup` indexed by a `Finset`\n is in the `AddSubgroup`.\"]\nprotected theorem prod_mem {G : Type*} [CommGroup G] (K : Subgroup G) {ι : Type*} {t : Finset ι}\n    {f : ι → G} (h : ∀ c ∈ t, f c ∈ K) : (∏ c ∈ t, f c) ∈ K :=\n  prod_mem h\n\n"}
{"name":"AddSubgroup.noncommSum_mem","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nK : AddSubgroup G\nι : Type u_3\nt : Finset ι\nf : ι → G\ncomm : (↑t).Pairwise (Function.onFun AddCommute f)\na✝ : ∀ (c : ι), Membership.mem t c → Membership.mem K (f c)\n⊢ Membership.mem K (t.noncommSum f comm)","decl":"@[to_additive]\ntheorem noncommProd_mem (K : Subgroup G) {ι : Type*} {t : Finset ι} {f : ι → G} (comm) :\n    (∀ c ∈ t, f c ∈ K) → t.noncommProd f comm ∈ K :=\n  K.toSubmonoid.noncommProd_mem t f comm\n\n-- Porting note: increased priority to appease `simpNF`, otherwise left-hand side reduces\n"}
{"name":"Subgroup.noncommProd_mem","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Subgroup G\nι : Type u_3\nt : Finset ι\nf : ι → G\ncomm : (↑t).Pairwise (Function.onFun Commute f)\na✝ : ∀ (c : ι), Membership.mem t c → Membership.mem K (f c)\n⊢ Membership.mem K (t.noncommProd f comm)","decl":"@[to_additive]\ntheorem noncommProd_mem (K : Subgroup G) {ι : Type*} {t : Finset ι} {f : ι → G} (comm) :\n    (∀ c ∈ t, f c ∈ K) → t.noncommProd f comm ∈ K :=\n  K.toSubmonoid.noncommProd_mem t f comm\n\n-- Porting note: increased priority to appease `simpNF`, otherwise left-hand side reduces\n"}
{"name":"AddSubgroup.val_list_sum","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nl : List (Subtype fun x => Membership.mem H x)\n⊢ Eq (↑l.sum) (List.map Subtype.val l).sum","decl":"@[to_additive (attr := simp 1100, norm_cast)]\ntheorem val_list_prod (l : List H) : (l.prod : G) = (l.map Subtype.val).prod :=\n  SubmonoidClass.coe_list_prod l\n\n-- Porting note: increased priority to appease `simpNF`, otherwise left-hand side reduces\n"}
{"name":"Subgroup.val_list_prod","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nl : List (Subtype fun x => Membership.mem H x)\n⊢ Eq (↑l.prod) (List.map Subtype.val l).prod","decl":"@[to_additive (attr := simp 1100, norm_cast)]\ntheorem val_list_prod (l : List H) : (l.prod : G) = (l.map Subtype.val).prod :=\n  SubmonoidClass.coe_list_prod l\n\n-- Porting note: increased priority to appease `simpNF`, otherwise left-hand side reduces\n"}
{"name":"Subgroup.val_multiset_prod","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\nH : Subgroup G\nm : Multiset (Subtype fun x => Membership.mem H x)\n⊢ Eq (↑m.prod) (Multiset.map Subtype.val m).prod","decl":"@[to_additive (attr := simp 1100, norm_cast)]\ntheorem val_multiset_prod {G} [CommGroup G] (H : Subgroup G) (m : Multiset H) :\n    (m.prod : G) = (m.map Subtype.val).prod :=\n  SubmonoidClass.coe_multiset_prod m\n\n-- Porting note: increased priority to appease `simpNF`, otherwise `simp` can prove it.\n"}
{"name":"AddSubgroup.val_multiset_sum","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\nH : AddSubgroup G\nm : Multiset (Subtype fun x => Membership.mem H x)\n⊢ Eq (↑m.sum) (Multiset.map Subtype.val m).sum","decl":"@[to_additive (attr := simp 1100, norm_cast)]\ntheorem val_multiset_prod {G} [CommGroup G] (H : Subgroup G) (m : Multiset H) :\n    (m.prod : G) = (m.map Subtype.val).prod :=\n  SubmonoidClass.coe_multiset_prod m\n\n-- Porting note: increased priority to appease `simpNF`, otherwise `simp` can prove it.\n"}
{"name":"Subgroup.val_finset_prod","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"ι : Type u_3\nG : Type u_4\ninst✝ : CommGroup G\nH : Subgroup G\nf : ι → Subtype fun x => Membership.mem H x\ns : Finset ι\n⊢ Eq (↑(s.prod fun i => f i)) (s.prod fun i => ↑(f i))","decl":"@[to_additive (attr := simp 1100, norm_cast)]\ntheorem val_finset_prod {ι G} [CommGroup G] (H : Subgroup G) (f : ι → H) (s : Finset ι) :\n    ↑(∏ i ∈ s, f i) = (∏ i ∈ s, f i : G) :=\n  SubmonoidClass.coe_finset_prod f s\n\n"}
{"name":"AddSubgroup.val_finset_sum","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"ι : Type u_3\nG : Type u_4\ninst✝ : AddCommGroup G\nH : AddSubgroup G\nf : ι → Subtype fun x => Membership.mem H x\ns : Finset ι\n⊢ Eq (↑(s.sum fun i => f i)) (s.sum fun i => ↑(f i))","decl":"@[to_additive (attr := simp 1100, norm_cast)]\ntheorem val_finset_prod {ι G} [CommGroup G] (H : Subgroup G) (f : ι → H) (s : Finset ι) :\n    ↑(∏ i ∈ s, f i) = (∏ i ∈ s, f i : G) :=\n  SubmonoidClass.coe_finset_prod f s\n\n"}
{"name":"AddSubgroup.card_bot","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Eq (Nat.card (Subtype fun x => Membership.mem Bot.bot x)) 1","decl":"@[to_additive]\ntheorem card_bot : Nat.card (⊥ : Subgroup G) = 1 := by simp\n\n"}
{"name":"Subgroup.card_bot","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Eq (Nat.card (Subtype fun x => Membership.mem Bot.bot x)) 1","decl":"@[to_additive]\ntheorem card_bot : Nat.card (⊥ : Subgroup G) = 1 := by simp\n\n"}
{"name":"Subgroup.card_top","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Eq (Nat.card (Subtype fun x => Membership.mem Top.top x)) (Nat.card G)","decl":"@[to_additive]\ntheorem card_top : Nat.card (⊤ : Subgroup G) = Nat.card G :=\n  Nat.card_congr Subgroup.topEquiv.toEquiv\n\n"}
{"name":"AddSubgroup.card_top","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Eq (Nat.card (Subtype fun x => Membership.mem Top.top x)) (Nat.card G)","decl":"@[to_additive]\ntheorem card_top : Nat.card (⊤ : Subgroup G) = Nat.card G :=\n  Nat.card_congr Subgroup.topEquiv.toEquiv\n\n"}
{"name":"AddSubgroup.eq_of_le_of_card_ge","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH K : AddSubgroup G\ninst✝ : Finite (Subtype fun x => Membership.mem K x)\nhle : LE.le H K\nhcard : LE.le (Nat.card (Subtype fun x => Membership.mem K x)) (Nat.card (Subtype fun x => Membership.mem H x))\n⊢ Eq H K","decl":"@[to_additive]\ntheorem eq_of_le_of_card_ge {H K : Subgroup G} [Finite K] (hle : H ≤ K)\n    (hcard : Nat.card K ≤ Nat.card H) :\n    H = K :=\n  SetLike.coe_injective <| Set.Finite.eq_of_subset_of_card_le (Set.toFinite _) hle hcard\n\n"}
{"name":"Subgroup.eq_of_le_of_card_ge","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH K : Subgroup G\ninst✝ : Finite (Subtype fun x => Membership.mem K x)\nhle : LE.le H K\nhcard : LE.le (Nat.card (Subtype fun x => Membership.mem K x)) (Nat.card (Subtype fun x => Membership.mem H x))\n⊢ Eq H K","decl":"@[to_additive]\ntheorem eq_of_le_of_card_ge {H K : Subgroup G} [Finite K] (hle : H ≤ K)\n    (hcard : Nat.card K ≤ Nat.card H) :\n    H = K :=\n  SetLike.coe_injective <| Set.Finite.eq_of_subset_of_card_le (Set.toFinite _) hle hcard\n\n"}
{"name":"Subgroup.eq_top_of_le_card","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : Finite G\nh : LE.le (Nat.card G) (Nat.card (Subtype fun x => Membership.mem H x))\n⊢ Eq H Top.top","decl":"@[to_additive]\ntheorem eq_top_of_le_card [Finite G] (h : Nat.card G ≤ Nat.card H) : H = ⊤ :=\n  eq_of_le_of_card_ge le_top (Nat.card_congr (Equiv.Set.univ G) ▸ h)\n\n"}
{"name":"AddSubgroup.eq_top_of_le_card","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH : AddSubgroup G\ninst✝ : Finite G\nh : LE.le (Nat.card G) (Nat.card (Subtype fun x => Membership.mem H x))\n⊢ Eq H Top.top","decl":"@[to_additive]\ntheorem eq_top_of_le_card [Finite G] (h : Nat.card G ≤ Nat.card H) : H = ⊤ :=\n  eq_of_le_of_card_ge le_top (Nat.card_congr (Equiv.Set.univ G) ▸ h)\n\n"}
{"name":"AddSubgroup.eq_top_of_card_eq","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH : AddSubgroup G\ninst✝ : Finite (Subtype fun x => Membership.mem H x)\nh : Eq (Nat.card (Subtype fun x => Membership.mem H x)) (Nat.card G)\n⊢ Eq H Top.top","decl":"@[to_additive]\ntheorem eq_top_of_card_eq [Finite H] (h : Nat.card H = Nat.card G) : H = ⊤ := by\n  have : Finite G := Nat.finite_of_card_ne_zero (h ▸ Nat.card_pos.ne')\n  exact eq_top_of_le_card _ (Nat.le_of_eq h.symm)\n\n"}
{"name":"Subgroup.eq_top_of_card_eq","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : Finite (Subtype fun x => Membership.mem H x)\nh : Eq (Nat.card (Subtype fun x => Membership.mem H x)) (Nat.card G)\n⊢ Eq H Top.top","decl":"@[to_additive]\ntheorem eq_top_of_card_eq [Finite H] (h : Nat.card H = Nat.card G) : H = ⊤ := by\n  have : Finite G := Nat.finite_of_card_ne_zero (h ▸ Nat.card_pos.ne')\n  exact eq_top_of_le_card _ (Nat.le_of_eq h.symm)\n\n"}
{"name":"Subgroup.card_eq_iff_eq_top","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : Finite (Subtype fun x => Membership.mem H x)\n⊢ Iff (Eq (Nat.card (Subtype fun x => Membership.mem H x)) (Nat.card G)) (Eq H Top.top)","decl":"@[to_additive (attr := simp)]\ntheorem card_eq_iff_eq_top [Finite H] : Nat.card H = Nat.card G ↔ H = ⊤ :=\n  Iff.intro (eq_top_of_card_eq H) (fun h ↦ by simpa only [h] using card_top)\n\n"}
{"name":"AddSubgroup.card_eq_iff_eq_top","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH : AddSubgroup G\ninst✝ : Finite (Subtype fun x => Membership.mem H x)\n⊢ Iff (Eq (Nat.card (Subtype fun x => Membership.mem H x)) (Nat.card G)) (Eq H Top.top)","decl":"@[to_additive (attr := simp)]\ntheorem card_eq_iff_eq_top [Finite H] : Nat.card H = Nat.card G ↔ H = ⊤ :=\n  Iff.intro (eq_top_of_card_eq H) (fun h ↦ by simpa only [h] using card_top)\n\n"}
{"name":"AddSubgroup.eq_bot_of_card_le","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH : AddSubgroup G\ninst✝ : Finite (Subtype fun x => Membership.mem H x)\nh : LE.le (Nat.card (Subtype fun x => Membership.mem H x)) 1\n⊢ Eq H Bot.bot","decl":"@[to_additive]\ntheorem eq_bot_of_card_le [Finite H] (h : Nat.card H ≤ 1) : H = ⊥ :=\n  let _ := Finite.card_le_one_iff_subsingleton.mp h\n  eq_bot_of_subsingleton H\n\n"}
{"name":"Subgroup.eq_bot_of_card_le","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : Finite (Subtype fun x => Membership.mem H x)\nh : LE.le (Nat.card (Subtype fun x => Membership.mem H x)) 1\n⊢ Eq H Bot.bot","decl":"@[to_additive]\ntheorem eq_bot_of_card_le [Finite H] (h : Nat.card H ≤ 1) : H = ⊥ :=\n  let _ := Finite.card_le_one_iff_subsingleton.mp h\n  eq_bot_of_subsingleton H\n\n"}
{"name":"AddSubgroup.eq_bot_of_card_eq","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nh : Eq (Nat.card (Subtype fun x => Membership.mem H x)) 1\n⊢ Eq H Bot.bot","decl":"@[to_additive]\ntheorem eq_bot_of_card_eq (h : Nat.card H = 1) : H = ⊥ :=\n  let _ := (Nat.card_eq_one_iff_unique.mp h).1\n  eq_bot_of_subsingleton H\n\n"}
{"name":"Subgroup.eq_bot_of_card_eq","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nh : Eq (Nat.card (Subtype fun x => Membership.mem H x)) 1\n⊢ Eq H Bot.bot","decl":"@[to_additive]\ntheorem eq_bot_of_card_eq (h : Nat.card H = 1) : H = ⊥ :=\n  let _ := (Nat.card_eq_one_iff_unique.mp h).1\n  eq_bot_of_subsingleton H\n\n"}
{"name":"Subgroup.card_le_one_iff_eq_bot","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : Finite (Subtype fun x => Membership.mem H x)\n⊢ Iff (LE.le (Nat.card (Subtype fun x => Membership.mem H x)) 1) (Eq H Bot.bot)","decl":"@[to_additive card_le_one_iff_eq_bot]\ntheorem card_le_one_iff_eq_bot [Finite H] : Nat.card H ≤ 1 ↔ H = ⊥ :=\n  ⟨H.eq_bot_of_card_le, fun h => by simp [h]⟩\n\n"}
{"name":"AddSubgroup.card_le_one_iff_eq_bot","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH : AddSubgroup G\ninst✝ : Finite (Subtype fun x => Membership.mem H x)\n⊢ Iff (LE.le (Nat.card (Subtype fun x => Membership.mem H x)) 1) (Eq H Bot.bot)","decl":"@[to_additive card_le_one_iff_eq_bot]\ntheorem card_le_one_iff_eq_bot [Finite H] : Nat.card H ≤ 1 ↔ H = ⊥ :=\n  ⟨H.eq_bot_of_card_le, fun h => by simp [h]⟩\n\n"}
{"name":"AddSubgroup.eq_bot_iff_card","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff (Eq H Bot.bot) (Eq (Nat.card (Subtype fun x => Membership.mem H x)) 1)","decl":"@[to_additive] lemma eq_bot_iff_card : H = ⊥ ↔ Nat.card H = 1 :=\n  ⟨by rintro rfl; exact card_bot, eq_bot_of_card_eq _⟩\n\n"}
{"name":"Subgroup.eq_bot_iff_card","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff (Eq H Bot.bot) (Eq (Nat.card (Subtype fun x => Membership.mem H x)) 1)","decl":"@[to_additive] lemma eq_bot_iff_card : H = ⊥ ↔ Nat.card H = 1 :=\n  ⟨by rintro rfl; exact card_bot, eq_bot_of_card_eq _⟩\n\n"}
{"name":"AddSubgroup.one_lt_card_iff_ne_bot","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH : AddSubgroup G\ninst✝ : Finite (Subtype fun x => Membership.mem H x)\n⊢ Iff (LT.lt 1 (Nat.card (Subtype fun x => Membership.mem H x))) (Ne H Bot.bot)","decl":"@[to_additive one_lt_card_iff_ne_bot]\ntheorem one_lt_card_iff_ne_bot [Finite H] : 1 < Nat.card H ↔ H ≠ ⊥ :=\n  lt_iff_not_le.trans H.card_le_one_iff_eq_bot.not\n\n"}
{"name":"Subgroup.one_lt_card_iff_ne_bot","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : Finite (Subtype fun x => Membership.mem H x)\n⊢ Iff (LT.lt 1 (Nat.card (Subtype fun x => Membership.mem H x))) (Ne H Bot.bot)","decl":"@[to_additive one_lt_card_iff_ne_bot]\ntheorem one_lt_card_iff_ne_bot [Finite H] : 1 < Nat.card H ↔ H ≠ ⊥ :=\n  lt_iff_not_le.trans H.card_le_one_iff_eq_bot.not\n\n"}
{"name":"AddSubgroup.card_le_card_addGroup","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH : AddSubgroup G\ninst✝ : Finite G\n⊢ LE.le (Nat.card (Subtype fun x => Membership.mem H x)) (Nat.card G)","decl":"@[to_additive]\ntheorem card_le_card_group [Finite G] : Nat.card H ≤ Nat.card G :=\n  Nat.card_le_card_of_injective _ Subtype.coe_injective\n\n"}
{"name":"Subgroup.card_le_card_group","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : Finite G\n⊢ LE.le (Nat.card (Subtype fun x => Membership.mem H x)) (Nat.card G)","decl":"@[to_additive]\ntheorem card_le_card_group [Finite G] : Nat.card H ≤ Nat.card G :=\n  Nat.card_le_card_of_injective _ Subtype.coe_injective\n\n"}
{"name":"Subgroup.card_le_of_le","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH K : Subgroup G\ninst✝ : Finite (Subtype fun x => Membership.mem K x)\nh : LE.le H K\n⊢ LE.le (Nat.card (Subtype fun x => Membership.mem H x)) (Nat.card (Subtype fun x => Membership.mem K x))","decl":"@[to_additive]\ntheorem card_le_of_le {H K : Subgroup G} [Finite K] (h : H ≤ K) : Nat.card H ≤ Nat.card K :=\n  Nat.card_le_card_of_injective _ (Subgroup.inclusion_injective h)\n\n"}
{"name":"AddSubgroup.card_le_of_le","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH K : AddSubgroup G\ninst✝ : Finite (Subtype fun x => Membership.mem K x)\nh : LE.le H K\n⊢ LE.le (Nat.card (Subtype fun x => Membership.mem H x)) (Nat.card (Subtype fun x => Membership.mem K x))","decl":"@[to_additive]\ntheorem card_le_of_le {H K : Subgroup G} [Finite K] (h : H ≤ K) : Nat.card H ≤ Nat.card K :=\n  Nat.card_le_card_of_injective _ (Subgroup.inclusion_injective h)\n\n"}
{"name":"Subgroup.card_map_of_injective","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Type u_3\ninst✝ : Group H\nK : Subgroup G\nf : MonoidHom G H\nhf : Function.Injective ⇑f\n⊢ Eq (Nat.card (Subtype fun x => Membership.mem (Subgroup.map f K) x)) (Nat.card (Subtype fun x => Membership.mem K x))","decl":"@[to_additive]\ntheorem card_map_of_injective {H : Type*} [Group H] {K : Subgroup G} {f : G →* H}\n    (hf : Function.Injective f) :\n    Nat.card (map f K) = Nat.card K := by\n  -- simp only [← SetLike.coe_sort_coe]\n  apply Nat.card_image_of_injective hf\n\n"}
{"name":"AddSubgroup.card_map_of_injective","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH : Type u_3\ninst✝ : AddGroup H\nK : AddSubgroup G\nf : AddMonoidHom G H\nhf : Function.Injective ⇑f\n⊢ Eq (Nat.card (Subtype fun x => Membership.mem (AddSubgroup.map f K) x)) (Nat.card (Subtype fun x => Membership.mem K x))","decl":"@[to_additive]\ntheorem card_map_of_injective {H : Type*} [Group H] {K : Subgroup G} {f : G →* H}\n    (hf : Function.Injective f) :\n    Nat.card (map f K) = Nat.card K := by\n  -- simp only [← SetLike.coe_sort_coe]\n  apply Nat.card_image_of_injective hf\n\n"}
{"name":"AddSubgroup.card_subtype","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nK : AddSubgroup G\nL : AddSubgroup (Subtype fun x => Membership.mem K x)\n⊢ Eq (Nat.card (Subtype fun x => Membership.mem (AddSubgroup.map K.subtype L) x)) (Nat.card (Subtype fun x => Membership.mem L x))","decl":"@[to_additive]\ntheorem card_subtype (K : Subgroup G) (L : Subgroup K) :\n    Nat.card (map K.subtype L) = Nat.card L :=\n  card_map_of_injective K.subtype_injective\n\n"}
{"name":"Subgroup.card_subtype","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Subgroup G\nL : Subgroup (Subtype fun x => Membership.mem K x)\n⊢ Eq (Nat.card (Subtype fun x => Membership.mem (Subgroup.map K.subtype L) x)) (Nat.card (Subtype fun x => Membership.mem L x))","decl":"@[to_additive]\ntheorem card_subtype (K : Subgroup G) (L : Subgroup K) :\n    Nat.card (map K.subtype L) = Nat.card L :=\n  card_map_of_injective K.subtype_injective\n\n"}
{"name":"AddSubgroup.pi_mem_of_single_mem_aux","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"η : Type u_3\nf : η → Type u_4\ninst✝¹ : (i : η) → AddGroup (f i)\ninst✝ : DecidableEq η\nI : Finset η\nH : AddSubgroup ((i : η) → f i)\nx : (i : η) → f i\nh1 : ∀ (i : η), Not (Membership.mem I i) → Eq (x i) 0\nh2 : ∀ (i : η), Membership.mem I i → Membership.mem H (Pi.single i (x i))\n⊢ Membership.mem H x","decl":"@[to_additive]\ntheorem pi_mem_of_mulSingle_mem_aux [DecidableEq η] (I : Finset η) {H : Subgroup (∀ i, f i)}\n    (x : ∀ i, f i) (h1 : ∀ i, i ∉ I → x i = 1) (h2 : ∀ i, i ∈ I → Pi.mulSingle i (x i) ∈ H) :\n    x ∈ H := by\n  induction I using Finset.induction_on generalizing x with\n  | empty =>\n    have : x = 1 := by\n      ext i\n      exact h1 i (Finset.not_mem_empty i)\n    rw [this]\n    exact one_mem H\n  | insert hnmem ih =>\n    rename_i i I\n    have : x = Function.update x i 1 * Pi.mulSingle i (x i) := by\n      ext j\n      by_cases heq : j = i\n      · subst heq\n        simp\n      · simp [heq]\n    rw [this]\n    clear this\n    apply mul_mem\n    · apply ih <;> clear ih\n      · intro j hj\n        by_cases heq : j = i\n        · subst heq\n          simp\n        · simpa [heq] using h1 j (by simpa [heq] using hj)\n      · intro j hj\n        have : j ≠ i := by\n          rintro rfl\n          contradiction\n        simp only [ne_eq, this, not_false_eq_true, Function.update_of_ne]\n        exact h2 _ (Finset.mem_insert_of_mem hj)\n    · apply h2\n      simp\n\n"}
{"name":"Subgroup.pi_mem_of_mulSingle_mem_aux","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"η : Type u_3\nf : η → Type u_4\ninst✝¹ : (i : η) → Group (f i)\ninst✝ : DecidableEq η\nI : Finset η\nH : Subgroup ((i : η) → f i)\nx : (i : η) → f i\nh1 : ∀ (i : η), Not (Membership.mem I i) → Eq (x i) 1\nh2 : ∀ (i : η), Membership.mem I i → Membership.mem H (Pi.mulSingle i (x i))\n⊢ Membership.mem H x","decl":"@[to_additive]\ntheorem pi_mem_of_mulSingle_mem_aux [DecidableEq η] (I : Finset η) {H : Subgroup (∀ i, f i)}\n    (x : ∀ i, f i) (h1 : ∀ i, i ∉ I → x i = 1) (h2 : ∀ i, i ∈ I → Pi.mulSingle i (x i) ∈ H) :\n    x ∈ H := by\n  induction I using Finset.induction_on generalizing x with\n  | empty =>\n    have : x = 1 := by\n      ext i\n      exact h1 i (Finset.not_mem_empty i)\n    rw [this]\n    exact one_mem H\n  | insert hnmem ih =>\n    rename_i i I\n    have : x = Function.update x i 1 * Pi.mulSingle i (x i) := by\n      ext j\n      by_cases heq : j = i\n      · subst heq\n        simp\n      · simp [heq]\n    rw [this]\n    clear this\n    apply mul_mem\n    · apply ih <;> clear ih\n      · intro j hj\n        by_cases heq : j = i\n        · subst heq\n          simp\n        · simpa [heq] using h1 j (by simpa [heq] using hj)\n      · intro j hj\n        have : j ≠ i := by\n          rintro rfl\n          contradiction\n        simp only [ne_eq, this, not_false_eq_true, Function.update_of_ne]\n        exact h2 _ (Finset.mem_insert_of_mem hj)\n    · apply h2\n      simp\n\n"}
{"name":"Subgroup.pi_mem_of_mulSingle_mem","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"η : Type u_3\nf : η → Type u_4\ninst✝² : (i : η) → Group (f i)\ninst✝¹ : Finite η\ninst✝ : DecidableEq η\nH : Subgroup ((i : η) → f i)\nx : (i : η) → f i\nh : ∀ (i : η), Membership.mem H (Pi.mulSingle i (x i))\n⊢ Membership.mem H x","decl":"@[to_additive]\ntheorem pi_mem_of_mulSingle_mem [Finite η] [DecidableEq η] {H : Subgroup (∀ i, f i)} (x : ∀ i, f i)\n    (h : ∀ i, Pi.mulSingle i (x i) ∈ H) : x ∈ H := by\n  cases nonempty_fintype η\n  exact pi_mem_of_mulSingle_mem_aux Finset.univ x (by simp) fun i _ => h i\n\n"}
{"name":"AddSubgroup.pi_mem_of_single_mem","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"η : Type u_3\nf : η → Type u_4\ninst✝² : (i : η) → AddGroup (f i)\ninst✝¹ : Finite η\ninst✝ : DecidableEq η\nH : AddSubgroup ((i : η) → f i)\nx : (i : η) → f i\nh : ∀ (i : η), Membership.mem H (Pi.single i (x i))\n⊢ Membership.mem H x","decl":"@[to_additive]\ntheorem pi_mem_of_mulSingle_mem [Finite η] [DecidableEq η] {H : Subgroup (∀ i, f i)} (x : ∀ i, f i)\n    (h : ∀ i, Pi.mulSingle i (x i) ∈ H) : x ∈ H := by\n  cases nonempty_fintype η\n  exact pi_mem_of_mulSingle_mem_aux Finset.univ x (by simp) fun i _ => h i\n\n"}
{"name":"AddSubgroup.pi_le_iff","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"η : Type u_3\nf : η → Type u_4\ninst✝² : (i : η) → AddGroup (f i)\ninst✝¹ : DecidableEq η\ninst✝ : Finite η\nH : (i : η) → AddSubgroup (f i)\nJ : AddSubgroup ((i : η) → f i)\n⊢ Iff (LE.le (AddSubgroup.pi Set.univ H) J) (∀ (i : η), LE.le (AddSubgroup.map (AddMonoidHom.single f i) (H i)) J)","decl":"/-- For finite index types, the `Subgroup.pi` is generated by the embeddings of the groups. -/\n@[to_additive \"For finite index types, the `Subgroup.pi` is generated by the embeddings of the\n additive groups.\"]\ntheorem pi_le_iff [DecidableEq η] [Finite η] {H : ∀ i, Subgroup (f i)} {J : Subgroup (∀ i, f i)} :\n    pi univ H ≤ J ↔ ∀ i : η, map (MonoidHom.mulSingle f i) (H i) ≤ J := by\n  constructor\n  · rintro h i _ ⟨x, hx, rfl⟩\n    apply h\n    simpa using hx\n  · exact fun h x hx => pi_mem_of_mulSingle_mem x fun i => h i (mem_map_of_mem _ (hx i trivial))\n\n"}
{"name":"Subgroup.pi_le_iff","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"η : Type u_3\nf : η → Type u_4\ninst✝² : (i : η) → Group (f i)\ninst✝¹ : DecidableEq η\ninst✝ : Finite η\nH : (i : η) → Subgroup (f i)\nJ : Subgroup ((i : η) → f i)\n⊢ Iff (LE.le (Subgroup.pi Set.univ H) J) (∀ (i : η), LE.le (Subgroup.map (MonoidHom.mulSingle f i) (H i)) J)","decl":"/-- For finite index types, the `Subgroup.pi` is generated by the embeddings of the groups. -/\n@[to_additive \"For finite index types, the `Subgroup.pi` is generated by the embeddings of the\n additive groups.\"]\ntheorem pi_le_iff [DecidableEq η] [Finite η] {H : ∀ i, Subgroup (f i)} {J : Subgroup (∀ i, f i)} :\n    pi univ H ≤ J ↔ ∀ i : η, map (MonoidHom.mulSingle f i) (H i) ≤ J := by\n  constructor\n  · rintro h i _ ⟨x, hx, rfl⟩\n    apply h\n    simpa using hx\n  · exact fun h x hx => pi_mem_of_mulSingle_mem x fun i => h i (mem_map_of_mem _ (hx i trivial))\n\n"}
{"name":"Subgroup.mem_normalizer_fintype","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nS : Set G\ninst✝ : Finite ↑S\nx : G\nh : ∀ (n : G), Membership.mem S n → Membership.mem S (HMul.hMul (HMul.hMul x n) (Inv.inv x))\n⊢ Membership.mem (Subgroup.setNormalizer S) x","decl":"theorem mem_normalizer_fintype {S : Set G} [Finite S] {x : G} (h : ∀ n, n ∈ S → x * n * x⁻¹ ∈ S) :\n    x ∈ Subgroup.setNormalizer S := by\n  haveI := Classical.propDecidable; cases nonempty_fintype S\n  haveI := Set.fintypeImage S fun n => x * n * x⁻¹\n  exact fun n =>\n    ⟨h n, fun h₁ =>\n      have heq : (fun n => x * n * x⁻¹) '' S = S :=\n        Set.eq_of_subset_of_card_le (fun n ⟨y, hy⟩ => hy.2 ▸ h y hy.1)\n          (by rw [Set.card_image_of_injective S conj_injective])\n      have : x * n * x⁻¹ ∈ (fun n => x * n * x⁻¹) '' S := heq.symm ▸ h₁\n      let ⟨y, hy⟩ := this\n      conj_injective hy.2 ▸ hy.1⟩\n\n"}
{"name":"Fintype.card_coeSort_mrange","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝³ : Monoid M\ninst✝² : Monoid N\ninst✝¹ : Fintype M\ninst✝ : DecidableEq N\nf : MonoidHom M N\nhf : Function.Injective ⇑f\n⊢ Eq (Fintype.card (Subtype fun x => Membership.mem (MonoidHom.mrange f) x)) (Fintype.card M)","decl":"lemma _root_.Fintype.card_coeSort_mrange {M N : Type*} [Monoid M] [Monoid N] [Fintype M]\n    [DecidableEq N] {f : M →* N} (hf : Function.Injective f) :\n    Fintype.card (mrange f) = Fintype.card M :=\n  Set.card_range_of_injective hf\n\n"}
{"name":"Fintype.card_coeSort_range","module":"Mathlib.Algebra.Group.Subgroup.Finite","initialProofState":"G : Type u_1\ninst✝³ : Group G\nN : Type u_3\ninst✝² : Group N\ninst✝¹ : Fintype G\ninst✝ : DecidableEq N\nf : MonoidHom G N\nhf : Function.Injective ⇑f\n⊢ Eq (Fintype.card (Subtype fun x => Membership.mem f.range x)) (Fintype.card G)","decl":"lemma _root_.Fintype.card_coeSort_range [Fintype G] [DecidableEq N] {f : G →* N}\n    (hf : Function.Injective f) :\n    Fintype.card (range f) = Fintype.card G :=\n  Set.card_range_of_injective hf\n\n"}
