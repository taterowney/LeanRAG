{"name":"ProbabilityTheory.Kernel.IsProper.restrict_eq_indicator_smul'","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\n𝓑 𝓧 : MeasurableSpace X\nπ : ProbabilityTheory.Kernel X X\nself : π.IsProper\nB : Set X\nhB : MeasurableSet B\nx : X\n⊢ Eq ((π.restrict ⋯) x) (HSMul.hSMul (B.indicator (fun x => 1) x) (π x))","decl":"/-- For two σ-algebras `𝓑 ≤ 𝓧` on a space `X`, a `𝓑, 𝓧`-kernel `π : X → Measure X` is proper if\n`∫ x, g x * f x ∂(π x₀) = g x₀ * ∫ x, f x ∂(π x₀)` for all `x₀ : X`, `𝓧`-measurable function `f`\nand `𝓑`-measurable function `g`.\n\nBy the standard machine, this is equivalent to having that, for all `B ∈ 𝓑`, `π` restricted to `B`\nis the same as `π` times the indicator of `B`.\n\nTo avoid assuming `𝓑 ≤ 𝓧` in the definition, we replace `𝓑` by `𝓑 ⊓ 𝓧` in the restriction. -/\nstructure IsProper (π : Kernel[𝓑, 𝓧] X X) : Prop where\n  restrict_eq_indicator_smul' :\n    ∀ ⦃B : Set X⦄ (hB : MeasurableSet[𝓑 ⊓ 𝓧] B) (x : X),\n      π.restrict (inf_le_right (b := 𝓧) _ hB) x = B.indicator (fun _ ↦ (1 : ℝ≥0∞)) x • π x\n\n"}
{"name":"ProbabilityTheory.Kernel.isProper_iff_restrict_eq_indicator_smul","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\n𝓑 𝓧 : MeasurableSpace X\nπ : ProbabilityTheory.Kernel X X\nh𝓑𝓧 : LE.le 𝓑 𝓧\n⊢ Iff π.IsProper (∀ ⦃B : Set X⦄ (hB : MeasurableSet B) (x : X), Eq ((π.restrict ⋯) x) (HSMul.hSMul (B.indicator (fun x => 1) x) (π x)))","decl":"lemma isProper_iff_restrict_eq_indicator_smul (h𝓑𝓧 : 𝓑 ≤ 𝓧) :\n    IsProper π ↔ ∀ ⦃B : Set X⦄ (hB : MeasurableSet[𝓑] B) (x : X),\n      π.restrict (h𝓑𝓧 _ hB) x = B.indicator (fun _ ↦ (1 : ℝ≥0∞)) x • π x := by\n  refine ⟨fun ⟨h⟩ ↦ ?_, fun h ↦ ⟨?_⟩⟩ <;> simpa only [inf_eq_left.2 h𝓑𝓧] using h\n\n"}
{"name":"ProbabilityTheory.Kernel.isProper_iff_inter_eq_indicator_mul","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\n𝓑 𝓧 : MeasurableSpace X\nπ : ProbabilityTheory.Kernel X X\nh𝓑𝓧 : LE.le 𝓑 𝓧\n⊢ Iff π.IsProper (∀ ⦃A : Set X⦄, MeasurableSet A → ∀ ⦃B : Set X⦄, MeasurableSet B → ∀ (x : X), Eq ((π x) (Inter.inter A B)) (HMul.hMul (B.indicator 1 x) ((π x) A)))","decl":"lemma isProper_iff_inter_eq_indicator_mul (h𝓑𝓧 : 𝓑 ≤ 𝓧) :\n    IsProper π ↔\n      ∀ ⦃A : Set X⦄ (_hA : MeasurableSet[𝓧] A) ⦃B : Set X⦄ (_hB : MeasurableSet[𝓑] B) (x : X),\n        π x (A ∩ B) = B.indicator 1 x * π x A := by\n  calc\n    _ ↔ ∀ ⦃A : Set X⦄ (_hA : MeasurableSet[𝓧] A) ⦃B : Set X⦄ (hB : MeasurableSet[𝓑] B) (x : X),\n          π.restrict (h𝓑𝓧 _ hB) x A = B.indicator 1 x * π x A := by\n      simp [isProper_iff_restrict_eq_indicator_smul h𝓑𝓧, Measure.ext_iff]; aesop\n    _ ↔ _ := by congr! 5 with A hA B hB x; rw [restrict_apply, Measure.restrict_apply hA]\n\n"}
{"name":"ProbabilityTheory.Kernel.IsProper.of_restrict_eq_indicator_smul","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\n𝓑 𝓧 : MeasurableSpace X\nπ : ProbabilityTheory.Kernel X X\nh𝓑𝓧 : LE.le 𝓑 𝓧\na✝ : ∀ ⦃B : Set X⦄ (hB : MeasurableSet B) (x : X), Eq ((π.restrict ⋯) x) (HSMul.hSMul (B.indicator (fun x => 1) x) (π x))\n⊢ π.IsProper","decl":"alias ⟨IsProper.restrict_eq_indicator_smul, IsProper.of_restrict_eq_indicator_smul⟩ :=\n  isProper_iff_restrict_eq_indicator_smul\n\n"}
{"name":"ProbabilityTheory.Kernel.IsProper.restrict_eq_indicator_smul","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\n𝓑 𝓧 : MeasurableSpace X\nπ : ProbabilityTheory.Kernel X X\nh𝓑𝓧 : LE.le 𝓑 𝓧\na✝ : π.IsProper\nB : Set X\nhB : MeasurableSet B\nx : X\n⊢ Eq ((π.restrict ⋯) x) (HSMul.hSMul (B.indicator (fun x => 1) x) (π x))","decl":"alias ⟨IsProper.restrict_eq_indicator_smul, IsProper.of_restrict_eq_indicator_smul⟩ :=\n  isProper_iff_restrict_eq_indicator_smul\n\n"}
{"name":"ProbabilityTheory.Kernel.IsProper.inter_eq_indicator_mul","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\n𝓑 𝓧 : MeasurableSpace X\nπ : ProbabilityTheory.Kernel X X\nh𝓑𝓧 : LE.le 𝓑 𝓧\na✝ : π.IsProper\nA : Set X\n_hA : MeasurableSet A\nB : Set X\n_hB : MeasurableSet B\nx : X\n⊢ Eq ((π x) (Inter.inter A B)) (HMul.hMul (B.indicator 1 x) ((π x) A))","decl":"alias ⟨IsProper.inter_eq_indicator_mul, IsProper.of_inter_eq_indicator_mul⟩ :=\n  isProper_iff_inter_eq_indicator_mul\n\n"}
{"name":"ProbabilityTheory.Kernel.IsProper.of_inter_eq_indicator_mul","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\n𝓑 𝓧 : MeasurableSpace X\nπ : ProbabilityTheory.Kernel X X\nh𝓑𝓧 : LE.le 𝓑 𝓧\na✝ : ∀ ⦃A : Set X⦄, MeasurableSet A → ∀ ⦃B : Set X⦄, MeasurableSet B → ∀ (x : X), Eq ((π x) (Inter.inter A B)) (HMul.hMul (B.indicator 1 x) ((π x) A))\n⊢ π.IsProper","decl":"alias ⟨IsProper.inter_eq_indicator_mul, IsProper.of_inter_eq_indicator_mul⟩ :=\n  isProper_iff_inter_eq_indicator_mul\n\n"}
{"name":"ProbabilityTheory.Kernel.IsProper.setLIntegral_eq_comp","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\n𝓑 𝓧 : MeasurableSpace X\nπ : ProbabilityTheory.Kernel X X\nA B : Set X\nhπ : π.IsProper\nh𝓑𝓧 : LE.le 𝓑 𝓧\nμ : MeasureTheory.Measure X\nhA : MeasurableSet A\nhB : MeasurableSet B\n⊢ Eq (MeasureTheory.lintegral (μ.restrict B) fun a => (π a) A) ((μ.bind ⇑π) (Inter.inter A B))","decl":"lemma IsProper.setLIntegral_eq_comp (hπ : IsProper π) (h𝓑𝓧 : 𝓑 ≤ 𝓧) {μ : Measure[𝓧] X}\n    (hA : MeasurableSet[𝓧] A) (hB : MeasurableSet[𝓑] B) :\n    ∫⁻ a in B, π a A ∂μ = (π ∘ₘ μ) (A ∩ B) := by\n  rw [Measure.bind_apply (by measurability) (π.measurable.mono h𝓑𝓧 le_rfl)]\n  simp only [hπ.inter_eq_indicator_mul h𝓑𝓧 hA hB, ← indicator_mul_const, Pi.one_apply, one_mul]\n  rw [← lintegral_indicator (h𝓑𝓧 _ hB)]\n  rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.IsProper.setLIntegral_eq_bind","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\n𝓑 𝓧 : MeasurableSpace X\nπ : ProbabilityTheory.Kernel X X\nA B : Set X\nhπ : π.IsProper\nh𝓑𝓧 : LE.le 𝓑 𝓧\nμ : MeasureTheory.Measure X\nhA : MeasurableSet A\nhB : MeasurableSet B\n⊢ Eq (MeasureTheory.lintegral (μ.restrict B) fun a => (π a) A) ((μ.bind ⇑π) (Inter.inter A B))","decl":"@[deprecated (since := \"2025-01-24\")]\nalias IsProper.setLIntegral_eq_bind := IsProper.setLIntegral_eq_comp\n\n"}
{"name":"ProbabilityTheory.Kernel.IsProper.setLIntegral_eq_indicator_mul_lintegral","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\n𝓑 𝓧 : MeasurableSpace X\nπ : ProbabilityTheory.Kernel X X\nB : Set X\nf : X → ENNReal\nhπ : π.IsProper\nh𝓑𝓧 : LE.le 𝓑 𝓧\nhf : Measurable f\nhB : MeasurableSet B\nx₀ : X\n⊢ Eq (MeasureTheory.lintegral ((π x₀).restrict B) fun x => f x) (HMul.hMul (B.indicator 1 x₀) (MeasureTheory.lintegral (π x₀) fun x => f x))","decl":"lemma IsProper.setLIntegral_eq_indicator_mul_lintegral (hπ : IsProper π) (h𝓑𝓧 : 𝓑 ≤ 𝓧)\n    (hf : Measurable[𝓧] f) (hB : MeasurableSet[𝓑] B) (x₀ : X) :\n    ∫⁻ x in B, f x ∂(π x₀) = B.indicator 1 x₀ * ∫⁻ x, f x ∂(π x₀) := by\n  simp [← hπ.lintegral_indicator_mul h𝓑𝓧 hf hB, ← indicator_mul_left,\n    lintegral_indicator (h𝓑𝓧 _ hB)]\n\n"}
{"name":"ProbabilityTheory.Kernel.IsProper.setLIntegral_inter_eq_indicator_mul_setLIntegral","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\n𝓑 𝓧 : MeasurableSpace X\nπ : ProbabilityTheory.Kernel X X\nA B : Set X\nf : X → ENNReal\nhπ : π.IsProper\nh𝓑𝓧 : LE.le 𝓑 𝓧\nhf : Measurable f\nhA : MeasurableSet A\nhB : MeasurableSet B\nx₀ : X\n⊢ Eq (MeasureTheory.lintegral ((π x₀).restrict (Inter.inter A B)) fun x => f x) (HMul.hMul (B.indicator 1 x₀) (MeasureTheory.lintegral ((π x₀).restrict A) fun x => f x))","decl":"lemma IsProper.setLIntegral_inter_eq_indicator_mul_setLIntegral (hπ : IsProper π) (h𝓑𝓧 : 𝓑 ≤ 𝓧)\n    (hf : Measurable[𝓧] f) (hA : MeasurableSet[𝓧] A) (hB : MeasurableSet[𝓑] B) (x₀ : X) :\n    ∫⁻ x in A ∩ B, f x ∂(π x₀) = B.indicator 1 x₀ * ∫⁻ x in A, f x ∂(π x₀) := by\n  rw [← lintegral_indicator hA, ← hπ.setLIntegral_eq_indicator_mul_lintegral h𝓑𝓧 _ hB,\n    setLIntegral_indicator] <;> measurability\n\n"}
{"name":"ProbabilityTheory.Kernel.IsProper.lintegral_mul","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\n𝓑 𝓧 : MeasurableSpace X\nπ : ProbabilityTheory.Kernel X X\nf g : X → ENNReal\nhπ : π.IsProper\nh𝓑𝓧 : LE.le 𝓑 𝓧\nhf : Measurable f\nhg : Measurable g\nx₀ : X\n⊢ Eq (MeasureTheory.lintegral (π x₀) fun x => HMul.hMul (g x) (f x)) (HMul.hMul (g x₀) (MeasureTheory.lintegral (π x₀) fun x => f x))","decl":"lemma IsProper.lintegral_mul (hπ : IsProper π) (h𝓑𝓧 : 𝓑 ≤ 𝓧) (hf : Measurable[𝓧] f)\n    (hg : Measurable[𝓑] g) (x₀ : X) :\n    ∫⁻ x, g x * f x ∂(π x₀) = g x₀ * ∫⁻ x, f x ∂(π x₀) := by\n  refine hg.ennreal_induction ?_ ?_ ?_\n  · rintro c A hA\n    simp_rw [← smul_indicator_one_apply, smul_mul_assoc, smul_eq_mul]\n    rw [lintegral_const_mul, hπ.lintegral_indicator_mul h𝓑𝓧 hf hA]\n    · measurability\n  · rintro g₁ g₂ - _ hg₂_meas hg₁ hg₂\n    simp only [Pi.add_apply, mul_add, add_mul]\n    rw [lintegral_add_right, hg₁, hg₂]\n    · exact (hg₂_meas.mono h𝓑𝓧 le_rfl).mul hf\n  · rintro g' hg'_meas hg'_mono hg'\n    simp_rw [ENNReal.iSup_mul]\n    rw [lintegral_iSup (fun n ↦ ((hg'_meas _).mono h𝓑𝓧 le_rfl).mul hf)\n      (hg'_mono.mul_const (zero_le _))]\n    simp_rw [hg']\n\n"}
