{"name":"ProbabilityTheory.Kernel.IsProper.restrict_eq_indicator_smul'","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\nğ“‘ ğ“§ : MeasurableSpace X\nÏ€ : ProbabilityTheory.Kernel X X\nself : Ï€.IsProper\nB : Set X\nhB : MeasurableSet B\nx : X\nâŠ¢ Eq ((Ï€.restrict â‹¯) x) (HSMul.hSMul (B.indicator (fun x => 1) x) (Ï€ x))","decl":"/-- For two Ïƒ-algebras `ğ“‘ â‰¤ ğ“§` on a space `X`, a `ğ“‘, ğ“§`-kernel `Ï€ : X â†’ Measure X` is proper if\n`âˆ« x, g x * f x âˆ‚(Ï€ xâ‚€) = g xâ‚€ * âˆ« x, f x âˆ‚(Ï€ xâ‚€)` for all `xâ‚€ : X`, `ğ“§`-measurable function `f`\nand `ğ“‘`-measurable function `g`.\n\nBy the standard machine, this is equivalent to having that, for all `B âˆˆ ğ“‘`, `Ï€` restricted to `B`\nis the same as `Ï€` times the indicator of `B`.\n\nTo avoid assuming `ğ“‘ â‰¤ ğ“§` in the definition, we replace `ğ“‘` by `ğ“‘ âŠ“ ğ“§` in the restriction. -/\nstructure IsProper (Ï€ : Kernel[ğ“‘, ğ“§] X X) : Prop where\n  restrict_eq_indicator_smul' :\n    âˆ€ â¦ƒB : Set Xâ¦„ (hB : MeasurableSet[ğ“‘ âŠ“ ğ“§] B) (x : X),\n      Ï€.restrict (inf_le_right (b := ğ“§) _ hB) x = B.indicator (fun _ â†¦ (1 : â„â‰¥0âˆ)) x â€¢ Ï€ x\n\n"}
{"name":"ProbabilityTheory.Kernel.isProper_iff_restrict_eq_indicator_smul","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\nğ“‘ ğ“§ : MeasurableSpace X\nÏ€ : ProbabilityTheory.Kernel X X\nhğ“‘ğ“§ : LE.le ğ“‘ ğ“§\nâŠ¢ Iff Ï€.IsProper (âˆ€ â¦ƒB : Set Xâ¦„ (hB : MeasurableSet B) (x : X), Eq ((Ï€.restrict â‹¯) x) (HSMul.hSMul (B.indicator (fun x => 1) x) (Ï€ x)))","decl":"lemma isProper_iff_restrict_eq_indicator_smul (hğ“‘ğ“§ : ğ“‘ â‰¤ ğ“§) :\n    IsProper Ï€ â†” âˆ€ â¦ƒB : Set Xâ¦„ (hB : MeasurableSet[ğ“‘] B) (x : X),\n      Ï€.restrict (hğ“‘ğ“§ _ hB) x = B.indicator (fun _ â†¦ (1 : â„â‰¥0âˆ)) x â€¢ Ï€ x := by\n  refine âŸ¨fun âŸ¨hâŸ© â†¦ ?_, fun h â†¦ âŸ¨?_âŸ©âŸ© <;> simpa only [inf_eq_left.2 hğ“‘ğ“§] using h\n\n"}
{"name":"ProbabilityTheory.Kernel.isProper_iff_inter_eq_indicator_mul","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\nğ“‘ ğ“§ : MeasurableSpace X\nÏ€ : ProbabilityTheory.Kernel X X\nhğ“‘ğ“§ : LE.le ğ“‘ ğ“§\nâŠ¢ Iff Ï€.IsProper (âˆ€ â¦ƒA : Set Xâ¦„, MeasurableSet A â†’ âˆ€ â¦ƒB : Set Xâ¦„, MeasurableSet B â†’ âˆ€ (x : X), Eq ((Ï€ x) (Inter.inter A B)) (HMul.hMul (B.indicator 1 x) ((Ï€ x) A)))","decl":"lemma isProper_iff_inter_eq_indicator_mul (hğ“‘ğ“§ : ğ“‘ â‰¤ ğ“§) :\n    IsProper Ï€ â†”\n      âˆ€ â¦ƒA : Set Xâ¦„ (_hA : MeasurableSet[ğ“§] A) â¦ƒB : Set Xâ¦„ (_hB : MeasurableSet[ğ“‘] B) (x : X),\n        Ï€ x (A âˆ© B) = B.indicator 1 x * Ï€ x A := by\n  calc\n    _ â†” âˆ€ â¦ƒA : Set Xâ¦„ (_hA : MeasurableSet[ğ“§] A) â¦ƒB : Set Xâ¦„ (hB : MeasurableSet[ğ“‘] B) (x : X),\n          Ï€.restrict (hğ“‘ğ“§ _ hB) x A = B.indicator 1 x * Ï€ x A := by\n      simp [isProper_iff_restrict_eq_indicator_smul hğ“‘ğ“§, Measure.ext_iff]; aesop\n    _ â†” _ := by congr! 5 with A hA B hB x; rw [restrict_apply, Measure.restrict_apply hA]\n\n"}
{"name":"ProbabilityTheory.Kernel.IsProper.of_restrict_eq_indicator_smul","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\nğ“‘ ğ“§ : MeasurableSpace X\nÏ€ : ProbabilityTheory.Kernel X X\nhğ“‘ğ“§ : LE.le ğ“‘ ğ“§\naâœ : âˆ€ â¦ƒB : Set Xâ¦„ (hB : MeasurableSet B) (x : X), Eq ((Ï€.restrict â‹¯) x) (HSMul.hSMul (B.indicator (fun x => 1) x) (Ï€ x))\nâŠ¢ Ï€.IsProper","decl":"alias âŸ¨IsProper.restrict_eq_indicator_smul, IsProper.of_restrict_eq_indicator_smulâŸ© :=\n  isProper_iff_restrict_eq_indicator_smul\n\n"}
{"name":"ProbabilityTheory.Kernel.IsProper.restrict_eq_indicator_smul","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\nğ“‘ ğ“§ : MeasurableSpace X\nÏ€ : ProbabilityTheory.Kernel X X\nhğ“‘ğ“§ : LE.le ğ“‘ ğ“§\naâœ : Ï€.IsProper\nB : Set X\nhB : MeasurableSet B\nx : X\nâŠ¢ Eq ((Ï€.restrict â‹¯) x) (HSMul.hSMul (B.indicator (fun x => 1) x) (Ï€ x))","decl":"alias âŸ¨IsProper.restrict_eq_indicator_smul, IsProper.of_restrict_eq_indicator_smulâŸ© :=\n  isProper_iff_restrict_eq_indicator_smul\n\n"}
{"name":"ProbabilityTheory.Kernel.IsProper.inter_eq_indicator_mul","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\nğ“‘ ğ“§ : MeasurableSpace X\nÏ€ : ProbabilityTheory.Kernel X X\nhğ“‘ğ“§ : LE.le ğ“‘ ğ“§\naâœ : Ï€.IsProper\nA : Set X\n_hA : MeasurableSet A\nB : Set X\n_hB : MeasurableSet B\nx : X\nâŠ¢ Eq ((Ï€ x) (Inter.inter A B)) (HMul.hMul (B.indicator 1 x) ((Ï€ x) A))","decl":"alias âŸ¨IsProper.inter_eq_indicator_mul, IsProper.of_inter_eq_indicator_mulâŸ© :=\n  isProper_iff_inter_eq_indicator_mul\n\n"}
{"name":"ProbabilityTheory.Kernel.IsProper.of_inter_eq_indicator_mul","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\nğ“‘ ğ“§ : MeasurableSpace X\nÏ€ : ProbabilityTheory.Kernel X X\nhğ“‘ğ“§ : LE.le ğ“‘ ğ“§\naâœ : âˆ€ â¦ƒA : Set Xâ¦„, MeasurableSet A â†’ âˆ€ â¦ƒB : Set Xâ¦„, MeasurableSet B â†’ âˆ€ (x : X), Eq ((Ï€ x) (Inter.inter A B)) (HMul.hMul (B.indicator 1 x) ((Ï€ x) A))\nâŠ¢ Ï€.IsProper","decl":"alias âŸ¨IsProper.inter_eq_indicator_mul, IsProper.of_inter_eq_indicator_mulâŸ© :=\n  isProper_iff_inter_eq_indicator_mul\n\n"}
{"name":"ProbabilityTheory.Kernel.IsProper.setLIntegral_eq_comp","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\nğ“‘ ğ“§ : MeasurableSpace X\nÏ€ : ProbabilityTheory.Kernel X X\nA B : Set X\nhÏ€ : Ï€.IsProper\nhğ“‘ğ“§ : LE.le ğ“‘ ğ“§\nÎ¼ : MeasureTheory.Measure X\nhA : MeasurableSet A\nhB : MeasurableSet B\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict B) fun a => (Ï€ a) A) ((Î¼.bind â‡‘Ï€) (Inter.inter A B))","decl":"lemma IsProper.setLIntegral_eq_comp (hÏ€ : IsProper Ï€) (hğ“‘ğ“§ : ğ“‘ â‰¤ ğ“§) {Î¼ : Measure[ğ“§] X}\n    (hA : MeasurableSet[ğ“§] A) (hB : MeasurableSet[ğ“‘] B) :\n    âˆ«â» a in B, Ï€ a A âˆ‚Î¼ = (Ï€ âˆ˜â‚˜ Î¼) (A âˆ© B) := by\n  rw [Measure.bind_apply (by measurability) (Ï€.measurable.mono hğ“‘ğ“§ le_rfl)]\n  simp only [hÏ€.inter_eq_indicator_mul hğ“‘ğ“§ hA hB, â† indicator_mul_const, Pi.one_apply, one_mul]\n  rw [â† lintegral_indicator (hğ“‘ğ“§ _ hB)]\n  rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.IsProper.setLIntegral_eq_bind","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\nğ“‘ ğ“§ : MeasurableSpace X\nÏ€ : ProbabilityTheory.Kernel X X\nA B : Set X\nhÏ€ : Ï€.IsProper\nhğ“‘ğ“§ : LE.le ğ“‘ ğ“§\nÎ¼ : MeasureTheory.Measure X\nhA : MeasurableSet A\nhB : MeasurableSet B\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict B) fun a => (Ï€ a) A) ((Î¼.bind â‡‘Ï€) (Inter.inter A B))","decl":"@[deprecated (since := \"2025-01-24\")]\nalias IsProper.setLIntegral_eq_bind := IsProper.setLIntegral_eq_comp\n\n"}
{"name":"ProbabilityTheory.Kernel.IsProper.setLIntegral_eq_indicator_mul_lintegral","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\nğ“‘ ğ“§ : MeasurableSpace X\nÏ€ : ProbabilityTheory.Kernel X X\nB : Set X\nf : X â†’ ENNReal\nhÏ€ : Ï€.IsProper\nhğ“‘ğ“§ : LE.le ğ“‘ ğ“§\nhf : Measurable f\nhB : MeasurableSet B\nxâ‚€ : X\nâŠ¢ Eq (MeasureTheory.lintegral ((Ï€ xâ‚€).restrict B) fun x => f x) (HMul.hMul (B.indicator 1 xâ‚€) (MeasureTheory.lintegral (Ï€ xâ‚€) fun x => f x))","decl":"lemma IsProper.setLIntegral_eq_indicator_mul_lintegral (hÏ€ : IsProper Ï€) (hğ“‘ğ“§ : ğ“‘ â‰¤ ğ“§)\n    (hf : Measurable[ğ“§] f) (hB : MeasurableSet[ğ“‘] B) (xâ‚€ : X) :\n    âˆ«â» x in B, f x âˆ‚(Ï€ xâ‚€) = B.indicator 1 xâ‚€ * âˆ«â» x, f x âˆ‚(Ï€ xâ‚€) := by\n  simp [â† hÏ€.lintegral_indicator_mul hğ“‘ğ“§ hf hB, â† indicator_mul_left,\n    lintegral_indicator (hğ“‘ğ“§ _ hB)]\n\n"}
{"name":"ProbabilityTheory.Kernel.IsProper.setLIntegral_inter_eq_indicator_mul_setLIntegral","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\nğ“‘ ğ“§ : MeasurableSpace X\nÏ€ : ProbabilityTheory.Kernel X X\nA B : Set X\nf : X â†’ ENNReal\nhÏ€ : Ï€.IsProper\nhğ“‘ğ“§ : LE.le ğ“‘ ğ“§\nhf : Measurable f\nhA : MeasurableSet A\nhB : MeasurableSet B\nxâ‚€ : X\nâŠ¢ Eq (MeasureTheory.lintegral ((Ï€ xâ‚€).restrict (Inter.inter A B)) fun x => f x) (HMul.hMul (B.indicator 1 xâ‚€) (MeasureTheory.lintegral ((Ï€ xâ‚€).restrict A) fun x => f x))","decl":"lemma IsProper.setLIntegral_inter_eq_indicator_mul_setLIntegral (hÏ€ : IsProper Ï€) (hğ“‘ğ“§ : ğ“‘ â‰¤ ğ“§)\n    (hf : Measurable[ğ“§] f) (hA : MeasurableSet[ğ“§] A) (hB : MeasurableSet[ğ“‘] B) (xâ‚€ : X) :\n    âˆ«â» x in A âˆ© B, f x âˆ‚(Ï€ xâ‚€) = B.indicator 1 xâ‚€ * âˆ«â» x in A, f x âˆ‚(Ï€ xâ‚€) := by\n  rw [â† lintegral_indicator hA, â† hÏ€.setLIntegral_eq_indicator_mul_lintegral hğ“‘ğ“§ _ hB,\n    setLIntegral_indicator] <;> measurability\n\n"}
{"name":"ProbabilityTheory.Kernel.IsProper.lintegral_mul","module":"Mathlib.Probability.Kernel.Proper","initialProofState":"X : Type u_1\nğ“‘ ğ“§ : MeasurableSpace X\nÏ€ : ProbabilityTheory.Kernel X X\nf g : X â†’ ENNReal\nhÏ€ : Ï€.IsProper\nhğ“‘ğ“§ : LE.le ğ“‘ ğ“§\nhf : Measurable f\nhg : Measurable g\nxâ‚€ : X\nâŠ¢ Eq (MeasureTheory.lintegral (Ï€ xâ‚€) fun x => HMul.hMul (g x) (f x)) (HMul.hMul (g xâ‚€) (MeasureTheory.lintegral (Ï€ xâ‚€) fun x => f x))","decl":"lemma IsProper.lintegral_mul (hÏ€ : IsProper Ï€) (hğ“‘ğ“§ : ğ“‘ â‰¤ ğ“§) (hf : Measurable[ğ“§] f)\n    (hg : Measurable[ğ“‘] g) (xâ‚€ : X) :\n    âˆ«â» x, g x * f x âˆ‚(Ï€ xâ‚€) = g xâ‚€ * âˆ«â» x, f x âˆ‚(Ï€ xâ‚€) := by\n  refine hg.ennreal_induction ?_ ?_ ?_\n  Â· rintro c A hA\n    simp_rw [â† smul_indicator_one_apply, smul_mul_assoc, smul_eq_mul]\n    rw [lintegral_const_mul, hÏ€.lintegral_indicator_mul hğ“‘ğ“§ hf hA]\n    Â· measurability\n  Â· rintro gâ‚ gâ‚‚ - _ hgâ‚‚_meas hgâ‚ hgâ‚‚\n    simp only [Pi.add_apply, mul_add, add_mul]\n    rw [lintegral_add_right, hgâ‚, hgâ‚‚]\n    Â· exact (hgâ‚‚_meas.mono hğ“‘ğ“§ le_rfl).mul hf\n  Â· rintro g' hg'_meas hg'_mono hg'\n    simp_rw [ENNReal.iSup_mul]\n    rw [lintegral_iSup (fun n â†¦ ((hg'_meas _).mono hğ“‘ğ“§ le_rfl).mul hf)\n      (hg'_mono.mul_const (zero_le _))]\n    simp_rw [hg']\n\n"}
