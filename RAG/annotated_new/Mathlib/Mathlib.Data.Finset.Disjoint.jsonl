{"name":"Finset.disjoint_left","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (Disjoint s t) (∀ ⦃a : α⦄, Membership.mem s a → Not (Membership.mem t a))","decl":"theorem disjoint_left : Disjoint s t ↔ ∀ ⦃a⦄, a ∈ s → a ∉ t :=\n  ⟨fun h a hs ht => not_mem_empty a <|\n    singleton_subset_iff.mp (h (singleton_subset_iff.mpr hs) (singleton_subset_iff.mpr ht)),\n    fun h _ hs ht _ ha => (h (hs ha) (ht ha)).elim⟩\n\n"}
{"name":"Finset.disjoint_right","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (Disjoint s t) (∀ ⦃a : α⦄, Membership.mem t a → Not (Membership.mem s a))","decl":"theorem disjoint_right : Disjoint s t ↔ ∀ ⦃a⦄, a ∈ t → a ∉ s := by\n  rw [_root_.disjoint_comm, disjoint_left]\n\n"}
{"name":"Finset.disjoint_iff_ne","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (Disjoint s t) (∀ (a : α), Membership.mem s a → ∀ (b : α), Membership.mem t b → Ne a b)","decl":"theorem disjoint_iff_ne : Disjoint s t ↔ ∀ a ∈ s, ∀ b ∈ t, a ≠ b := by\n  simp only [disjoint_left, imp_not_comm, forall_eq']\n\n"}
{"name":"Finset.disjoint_val","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (Disjoint s.val t.val) (Disjoint s t)","decl":"@[simp]\ntheorem disjoint_val : Disjoint s.1 t.1 ↔ Disjoint s t :=\n  Multiset.disjoint_left.trans disjoint_left.symm\n\n"}
{"name":"Disjoint.forall_ne_finset","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ns t : Finset α\na b : α\nh : Disjoint s t\nha : Membership.mem s a\nhb : Membership.mem t b\n⊢ Ne a b","decl":"theorem _root_.Disjoint.forall_ne_finset (h : Disjoint s t) (ha : a ∈ s) (hb : b ∈ t) : a ≠ b :=\n  disjoint_iff_ne.1 h _ ha _ hb\n\n"}
{"name":"Finset.not_disjoint_iff","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (Not (Disjoint s t)) (Exists fun a => And (Membership.mem s a) (Membership.mem t a))","decl":"theorem not_disjoint_iff : ¬Disjoint s t ↔ ∃ a, a ∈ s ∧ a ∈ t :=\n  disjoint_left.not.trans <| not_forall.trans <| exists_congr fun _ => by\n    rw [Classical.not_imp, not_not]\n\n"}
{"name":"Finset.disjoint_of_subset_left","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ns t u : Finset α\nh : HasSubset.Subset s u\nd : Disjoint u t\n⊢ Disjoint s t","decl":"theorem disjoint_of_subset_left (h : s ⊆ u) (d : Disjoint u t) : Disjoint s t :=\n  disjoint_left.2 fun _x m₁ => (disjoint_left.1 d) (h m₁)\n\n"}
{"name":"Finset.disjoint_of_subset_right","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ns t u : Finset α\nh : HasSubset.Subset t u\nd : Disjoint s u\n⊢ Disjoint s t","decl":"theorem disjoint_of_subset_right (h : t ⊆ u) (d : Disjoint s u) : Disjoint s t :=\n  disjoint_right.2 fun _x m₁ => (disjoint_right.1 d) (h m₁)\n\n"}
{"name":"Finset.disjoint_empty_left","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Disjoint EmptyCollection.emptyCollection s","decl":"@[simp]\ntheorem disjoint_empty_left (s : Finset α) : Disjoint ∅ s :=\n  disjoint_bot_left\n\n"}
{"name":"Finset.disjoint_empty_right","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Disjoint s EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem disjoint_empty_right (s : Finset α) : Disjoint s ∅ :=\n  disjoint_bot_right\n\n"}
{"name":"Finset.disjoint_singleton_left","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ns : Finset α\na : α\n⊢ Iff (Disjoint (Singleton.singleton a) s) (Not (Membership.mem s a))","decl":"@[simp]\ntheorem disjoint_singleton_left : Disjoint (singleton a) s ↔ a ∉ s := by\n  simp only [disjoint_left, mem_singleton, forall_eq]\n\n"}
{"name":"Finset.disjoint_singleton_right","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ns : Finset α\na : α\n⊢ Iff (Disjoint s (Singleton.singleton a)) (Not (Membership.mem s a))","decl":"@[simp]\ntheorem disjoint_singleton_right : Disjoint s (singleton a) ↔ a ∉ s :=\n  disjoint_comm.trans disjoint_singleton_left\n\n-- Porting note: Left-hand side simplifies @[simp]\n"}
{"name":"Finset.disjoint_singleton","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\na b : α\n⊢ Iff (Disjoint (Singleton.singleton a) (Singleton.singleton b)) (Ne a b)","decl":"theorem disjoint_singleton : Disjoint ({a} : Finset α) {b} ↔ a ≠ b := by\n  rw [disjoint_singleton_left, mem_singleton]\n\n"}
{"name":"Finset.disjoint_self_iff_empty","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (Disjoint s s) (Eq s EmptyCollection.emptyCollection)","decl":"theorem disjoint_self_iff_empty (s : Finset α) : Disjoint s s ↔ s = ∅ :=\n  disjoint_self\n\n"}
{"name":"Finset.disjoint_coe","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (Disjoint ↑s ↑t) (Disjoint s t)","decl":"@[simp, norm_cast]\ntheorem disjoint_coe : Disjoint (s : Set α) t ↔ Disjoint s t := by\n  simp only [Finset.disjoint_left, Set.disjoint_left, mem_coe]\n\n"}
{"name":"Finset.pairwiseDisjoint_coe","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\nι : Type u_4\ns : Set ι\nf : ι → Finset α\n⊢ Iff (s.PairwiseDisjoint fun i => ↑(f i)) (s.PairwiseDisjoint f)","decl":"@[simp, norm_cast]\ntheorem pairwiseDisjoint_coe {ι : Type*} {s : Set ι} {f : ι → Finset α} :\n    s.PairwiseDisjoint (fun i => f i : ι → Set α) ↔ s.PairwiseDisjoint f :=\n  forall₅_congr fun _ _ _ _ _ => disjoint_coe\n\n"}
{"name":"Finset.mem_disjUnion","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_4\ns t : Finset α\nh : Disjoint s t\na : α\n⊢ Iff (Membership.mem (s.disjUnion t h) a) (Or (Membership.mem s a) (Membership.mem t a))","decl":"@[simp]\ntheorem mem_disjUnion {α s t h a} : a ∈ @disjUnion α s t h ↔ a ∈ s ∨ a ∈ t := by\n  rcases s with ⟨⟨s⟩⟩; rcases t with ⟨⟨t⟩⟩; apply List.mem_append\n\n"}
{"name":"Finset.coe_disjUnion","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ns t : Finset α\nh : Disjoint s t\n⊢ Eq (↑(s.disjUnion t h)) (Union.union ↑s ↑t)","decl":"@[simp, norm_cast]\ntheorem coe_disjUnion {s t : Finset α} (h : Disjoint s t) :\n    (disjUnion s t h : Set α) = (s : Set α) ∪ t :=\n  Set.ext <| by simp\n\n"}
{"name":"Finset.disjUnion_comm","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ns t : Finset α\nh : Disjoint s t\n⊢ Eq (s.disjUnion t h) (t.disjUnion s ⋯)","decl":"theorem disjUnion_comm (s t : Finset α) (h : Disjoint s t) :\n    disjUnion s t h = disjUnion t s h.symm :=\n  eq_of_veq <| Multiset.add_comm _ _\n\n"}
{"name":"Finset.empty_disjUnion","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\nt : Finset α\nh : optParam (Disjoint EmptyCollection.emptyCollection t) ⋯\n⊢ Eq (EmptyCollection.emptyCollection.disjUnion t h) t","decl":"@[simp]\ntheorem empty_disjUnion (t : Finset α) (h : Disjoint ∅ t := disjoint_bot_left) :\n    disjUnion ∅ t h = t :=\n  eq_of_veq <| Multiset.zero_add _\n\n"}
{"name":"Finset.disjUnion_empty","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ns : Finset α\nh : optParam (Disjoint s EmptyCollection.emptyCollection) ⋯\n⊢ Eq (s.disjUnion EmptyCollection.emptyCollection h) s","decl":"@[simp]\ntheorem disjUnion_empty (s : Finset α) (h : Disjoint s ∅ := disjoint_bot_right) :\n    disjUnion s ∅ h = s :=\n  eq_of_veq <| Multiset.add_zero _\n\n"}
{"name":"Finset.singleton_disjUnion","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\na : α\nt : Finset α\nh : Disjoint (Singleton.singleton a) t\n⊢ Eq ((Singleton.singleton a).disjUnion t h) (Finset.cons a t ⋯)","decl":"theorem singleton_disjUnion (a : α) (t : Finset α) (h : Disjoint {a} t) :\n    disjUnion {a} t h = cons a t (disjoint_singleton_left.mp h) :=\n  eq_of_veq <| Multiset.singleton_add _ _\n\n"}
{"name":"Finset.disjUnion_singleton","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ns : Finset α\na : α\nh : Disjoint s (Singleton.singleton a)\n⊢ Eq (s.disjUnion (Singleton.singleton a) h) (Finset.cons a s ⋯)","decl":"theorem disjUnion_singleton (s : Finset α) (a : α) (h : Disjoint s {a}) :\n    disjUnion s {a} h = cons a s (disjoint_singleton_right.mp h) := by\n  rw [disjUnion_comm, singleton_disjUnion]\n\n"}
{"name":"Finset.disjoint_insert_left","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\n⊢ Iff (Disjoint (Insert.insert a s) t) (And (Not (Membership.mem t a)) (Disjoint s t))","decl":"@[simp]\ntheorem disjoint_insert_left : Disjoint (insert a s) t ↔ a ∉ t ∧ Disjoint s t := by\n  simp only [disjoint_left, mem_insert, or_imp, forall_and, forall_eq]\n\n"}
{"name":"Finset.disjoint_insert_right","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\n⊢ Iff (Disjoint s (Insert.insert a t)) (And (Not (Membership.mem s a)) (Disjoint s t))","decl":"@[simp]\ntheorem disjoint_insert_right : Disjoint s (insert a t) ↔ a ∉ s ∧ Disjoint s t :=\n  disjoint_comm.trans <| by rw [disjoint_insert_left, _root_.disjoint_comm]\n\n"}
{"name":"Multiset.disjoint_toFinset","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm1 m2 : Multiset α\n⊢ Iff (Disjoint m1.toFinset m2.toFinset) (Disjoint m1 m2)","decl":"@[simp]\ntheorem disjoint_toFinset {m1 m2 : Multiset α} :\n    _root_.Disjoint m1.toFinset m2.toFinset ↔ Disjoint m1 m2 := by\n  simp [disjoint_left, Finset.disjoint_left]\n\n"}
{"name":"List.disjoint_toFinset_iff_disjoint","module":"Mathlib.Data.Finset.Disjoint","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl l' : List α\n⊢ Iff (Disjoint l.toFinset l'.toFinset) (l.Disjoint l')","decl":"@[simp]\ntheorem disjoint_toFinset_iff_disjoint : _root_.Disjoint l.toFinset l'.toFinset ↔ l.Disjoint l' :=\n  Multiset.disjoint_toFinset.trans (Multiset.coe_disjoint _ _)\n\n"}
