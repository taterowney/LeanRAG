{"name":"EckmannHilton.IsUnital.toLawfulIdentity","module":"Mathlib.GroupTheory.EckmannHilton","initialProofState":"X : Type u\nm : X → X → X\ne : X\nself : EckmannHilton.IsUnital m e\n⊢ Std.LawfulIdentity m e","decl":"/-- `IsUnital m e` expresses that `e : X` is a left and right unit\nfor the binary operation `m : X → X → X`. -/\nstructure IsUnital (m : X → X → X) (e : X) extends Std.LawfulIdentity m e : Prop\n\n"}
{"name":"EckmannHilton.MulOneClass.isUnital","module":"Mathlib.GroupTheory.EckmannHilton","initialProofState":"X : Type u\n_G : MulOneClass X\n⊢ EckmannHilton.IsUnital (fun x1 x2 => HMul.hMul x1 x2) 1","decl":"@[to_additive EckmannHilton.AddZeroClass.IsUnital]\ntheorem MulOneClass.isUnital [_G : MulOneClass X] : IsUnital (· * ·) (1 : X) :=\n  IsUnital.mk { left_id := MulOneClass.one_mul,\n                right_id := MulOneClass.mul_one }\n\n"}
{"name":"EckmannHilton.AddZeroClass.IsUnital","module":"Mathlib.GroupTheory.EckmannHilton","initialProofState":"X : Type u\n_G : AddZeroClass X\n⊢ EckmannHilton.IsUnital (fun x1 x2 => HAdd.hAdd x1 x2) 0","decl":"@[to_additive EckmannHilton.AddZeroClass.IsUnital]\ntheorem MulOneClass.isUnital [_G : MulOneClass X] : IsUnital (· * ·) (1 : X) :=\n  IsUnital.mk { left_id := MulOneClass.one_mul,\n                right_id := MulOneClass.mul_one }\n\n"}
{"name":"EckmannHilton.one","module":"Mathlib.GroupTheory.EckmannHilton","initialProofState":"X : Type u\nm₁ m₂ : X → X → X\ne₁ e₂ : X\nh₁ : EckmannHilton.IsUnital m₁ e₁\nh₂ : EckmannHilton.IsUnital m₂ e₂\ndistrib : ∀ (a b c d : X), Eq (m₁ (m₂ a b) (m₂ c d)) (m₂ (m₁ a c) (m₁ b d))\n⊢ Eq e₁ e₂","decl":"/-- If a type carries two unital binary operations that distribute over each other,\nthen they have the same unit elements.\n\nIn fact, the two operations are the same, and give a commutative monoid structure,\nsee `eckmann_hilton.CommMonoid`. -/\ntheorem one : e₁ = e₂ := by\n  simpa only [h₁.left_id, h₁.right_id, h₂.left_id, h₂.right_id] using distrib e₂ e₁ e₁ e₂\n\n"}
{"name":"EckmannHilton.mul","module":"Mathlib.GroupTheory.EckmannHilton","initialProofState":"X : Type u\nm₁ m₂ : X → X → X\ne₁ e₂ : X\nh₁ : EckmannHilton.IsUnital m₁ e₁\nh₂ : EckmannHilton.IsUnital m₂ e₂\ndistrib : ∀ (a b c d : X), Eq (m₁ (m₂ a b) (m₂ c d)) (m₂ (m₁ a c) (m₁ b d))\n⊢ Eq m₁ m₂","decl":"/-- If a type carries two unital binary operations that distribute over each other,\nthen these operations are equal.\n\nIn fact, they give a commutative monoid structure, see `eckmann_hilton.CommMonoid`. -/\ntheorem mul : m₁ = m₂ := by\n  funext a b\n  calc\n    m₁ a b = m₁ (m₂ a e₁) (m₂ e₁ b) := by\n      { simp only [one h₁ h₂ distrib, h₁.left_id, h₁.right_id, h₂.left_id, h₂.right_id] }\n    _ = m₂ a b := by simp only [distrib, h₁.left_id, h₁.right_id, h₂.left_id, h₂.right_id]\n\n"}
{"name":"EckmannHilton.mul_comm","module":"Mathlib.GroupTheory.EckmannHilton","initialProofState":"X : Type u\nm₁ m₂ : X → X → X\ne₁ e₂ : X\nh₁ : EckmannHilton.IsUnital m₁ e₁\nh₂ : EckmannHilton.IsUnital m₂ e₂\ndistrib : ∀ (a b c d : X), Eq (m₁ (m₂ a b) (m₂ c d)) (m₂ (m₁ a c) (m₁ b d))\n⊢ Std.Commutative m₂","decl":"/-- If a type carries two unital binary operations that distribute over each other,\nthen these operations are commutative.\n\nIn fact, they give a commutative monoid structure, see `eckmann_hilton.CommMonoid`. -/\ntheorem mul_comm : Std.Commutative m₂ :=\n  ⟨fun a b => by simpa [mul h₁ h₂ distrib, h₂.left_id, h₂.right_id] using distrib e₂ a b e₂⟩\n\n"}
{"name":"EckmannHilton.mul_assoc","module":"Mathlib.GroupTheory.EckmannHilton","initialProofState":"X : Type u\nm₁ m₂ : X → X → X\ne₁ e₂ : X\nh₁ : EckmannHilton.IsUnital m₁ e₁\nh₂ : EckmannHilton.IsUnital m₂ e₂\ndistrib : ∀ (a b c d : X), Eq (m₁ (m₂ a b) (m₂ c d)) (m₂ (m₁ a c) (m₁ b d))\n⊢ Std.Associative m₂","decl":"/-- If a type carries two unital binary operations that distribute over each other,\nthen these operations are associative.\n\nIn fact, they give a commutative monoid structure, see `eckmann_hilton.CommMonoid`. -/\ntheorem mul_assoc : Std.Associative m₂ :=\n  ⟨fun a b c => by simpa [mul h₁ h₂ distrib, h₂.left_id, h₂.right_id] using distrib a b e₂ c⟩\n\n"}
