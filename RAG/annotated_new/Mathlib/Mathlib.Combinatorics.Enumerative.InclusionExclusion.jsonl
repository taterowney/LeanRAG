{"name":"Finset.prod_indicator_biUnion_sub_indicator","module":"Mathlib.Combinatorics.Enumerative.InclusionExclusion","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : DecidableEq α\ns : Finset ι\nhs : s.Nonempty\nS : ι → Finset α\na : α\n⊢ Eq (s.prod fun i => HSub.hSub ((↑(s.biUnion S)).indicator 1 a) ((↑(S i)).indicator 1 a)) 0","decl":"lemma prod_indicator_biUnion_sub_indicator (hs : s.Nonempty) (S : ι → Finset α) (a : α) :\n    ∏ i ∈ s, (Set.indicator (s.biUnion S) 1 a - Set.indicator (S i) 1 a) = (0 : ℤ) := by\n  by_cases ha : a ∈ s.biUnion S\n  · obtain ⟨i, hi, ha⟩ := mem_biUnion.1 ha\n    exact prod_eq_zero hi <| by simp [*, -coe_biUnion]\n  · obtain ⟨i, hi⟩ := hs\n    have ha : a ∉ S i := fun h ↦ ha <| subset_biUnion_of_mem _ hi h\n    exact prod_eq_zero hi <| by simp [*, -coe_biUnion]\n\n"}
{"name":"Finset.inclusion_exclusion_sum_biUnion","module":"Mathlib.Combinatorics.Enumerative.InclusionExclusion","initialProofState":"ι : Type u_1\nα : Type u_2\nG : Type u_3\ninst✝¹ : DecidableEq α\ninst✝ : AddCommGroup G\ns : Finset ι\nS : ι → Finset α\nf : α → G\n⊢ Eq ((s.biUnion S).sum fun a => f a) (Finset.univ.sum fun t => HSMul.hSMul (HPow.hPow (-1) (HAdd.hAdd (↑t).card 1)) (((↑t).inf' ⋯ S).sum fun a => f a))","decl":"/-- **Inclusion-exclusion principle** for the sum of a function over a union.\n\nThe sum of a function `f` over the union of the `S i` over `i ∈ s` is the alternating sum of the\nsums of `f` over the intersections of the `S i`. -/\ntheorem inclusion_exclusion_sum_biUnion (s : Finset ι) (S : ι → Finset α) (f : α → G) :\n    ∑ a ∈ s.biUnion S, f a = ∑ t : s.powerset.filter (·.Nonempty),\n      (-1) ^ (#t.1 + 1) • ∑ a ∈ t.1.inf' (mem_filter.1 t.2).2 S, f a := by\n  classical\n  rw [← sub_eq_zero]\n  calc\n    ∑ a ∈ s.biUnion S, f a - ∑ t : s.powerset.filter (·.Nonempty),\n      (-1) ^ (#t.1 + 1) • ∑ a ∈ t.1.inf' (mem_filter.1 t.2).2 S, f a\n      = ∑ t : s.powerset.filter (·.Nonempty),\n          (-1) ^ #t.1 • ∑ a ∈ t.1.inf' (mem_filter.1 t.2).2 S, f a +\n          ∑ t ∈ s.powerset.filter (¬ ·.Nonempty), (-1) ^ #t • ∑ a ∈ s.biUnion S, f a := by\n      simp [sub_eq_neg_add, ← sum_neg_distrib, filter_eq', pow_succ]\n    _ = ∑ t ∈ s.powerset, (-1) ^ #t •\n          if ht : t.Nonempty then ∑ a ∈ t.inf' ht S, f a else ∑ a ∈ s.biUnion S, f a := by\n      rw [← sum_attach (filter ..)]; simp [sum_dite, filter_eq', sum_attach]\n    _ = ∑ a ∈ s.biUnion S, (∏ i ∈ s, (1 - Set.indicator (S i) 1 a : ℤ)) • f a := by\n      simp only [Int.reduceNeg, mem_coe, prod_sub, sum_comm (s := s.biUnion S), sum_smul, mul_assoc]\n      congr! with t\n      split_ifs with ht\n      · obtain ⟨i, hi⟩ := ht\n        simp only [prod_const_one, mul_one, prod_indicator_apply]\n        simp only [smul_sum, Set.indicator, Set.mem_iInter, mem_coe, Pi.one_apply, mul_ite, mul_one,\n          mul_zero, ite_smul, zero_smul, sum_ite, not_forall, sum_const_zero, add_zero]\n        congr\n        aesop\n      · obtain rfl := not_nonempty_iff_eq_empty.1 ht\n        simp\n    _ = ∑ a ∈ s.biUnion S, (∏ i ∈ s,\n          (Set.indicator (s.biUnion S) 1 a - Set.indicator (S i) 1 a) : ℤ) • f a := by\n      congr! with t; rw [Set.indicator_of_mem ‹_›, Pi.one_apply]\n    _ = 0 := by\n      obtain rfl | hs := s.eq_empty_or_nonempty <;>\n        simp [-coe_biUnion, prod_indicator_biUnion_sub_indicator, *]\n\n"}
{"name":"Finset.inclusion_exclusion_card_biUnion","module":"Mathlib.Combinatorics.Enumerative.InclusionExclusion","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : DecidableEq α\ns : Finset ι\nS : ι → Finset α\n⊢ Eq (↑(s.biUnion S).card) (Finset.univ.sum fun t => HMul.hMul (HPow.hPow (-1) (HAdd.hAdd (↑t).card 1)) ↑((↑t).inf' ⋯ S).card)","decl":"/-- **Inclusion-exclusion principle** for the cardinality of a union.\n\nThe cardinality of the union of the `S i` over `i ∈ s` is the alternating sum of the cardinalities\nof the intersections of the `S i`. -/\ntheorem inclusion_exclusion_card_biUnion (s : Finset ι) (S : ι → Finset α) :\n    #(s.biUnion S) = ∑ t : s.powerset.filter (·.Nonempty),\n      (-1 : ℤ) ^ (#t.1 + 1) * #(t.1.inf' (mem_filter.1 t.2).2 S) := by\n  simpa using inclusion_exclusion_sum_biUnion (G := ℤ) s S (f := 1)\n\n"}
{"name":"Finset.inclusion_exclusion_sum_inf_compl","module":"Mathlib.Combinatorics.Enumerative.InclusionExclusion","initialProofState":"ι : Type u_1\nα : Type u_2\nG : Type u_3\ninst✝² : DecidableEq α\ninst✝¹ : AddCommGroup G\ninst✝ : Fintype α\ns : Finset ι\nS : ι → Finset α\nf : α → G\n⊢ Eq ((s.inf fun i => HasCompl.compl (S i)).sum fun a => f a) (s.powerset.sum fun t => HSMul.hSMul (HPow.hPow (-1) t.card) ((t.inf S).sum fun a => f a))","decl":"/-- **Inclusion-exclusion principle** for the sum of a function over an intersection of complements.\n\nThe sum of a function `f` over the intersection of the complements of the `S i` over `i ∈ s` is the\nalternating sum of the sums of `f` over the intersections of the `S i`. -/\ntheorem inclusion_exclusion_sum_inf_compl (s : Finset ι) (S : ι → Finset α) (f : α → G) :\n    ∑ a ∈ s.inf fun i ↦ (S i)ᶜ, f a = ∑ t ∈ s.powerset, (-1) ^ #t • ∑ a ∈ t.inf S, f a := by\n  classical\n  calc\n    ∑ a ∈ s.inf fun i ↦ (S i)ᶜ, f a\n      = ∑ a, f a - ∑ a ∈ s.biUnion S, f a := by\n      rw [← Finset.compl_sup, sup_eq_biUnion, eq_sub_iff_add_eq, sum_compl_add_sum]\n    _ = ∑ t ∈ s.powerset.filter (¬ ·.Nonempty), (-1) ^ #t • ∑ a ∈ t.inf S, f a\n          + ∑ t ∈ s.powerset.filter (·.Nonempty), (-1) ^ #t • ∑ a ∈ t.inf S, f a := by\n      simp [← sum_attach (filter ..), inclusion_exclusion_sum_biUnion, inf'_eq_inf, filter_eq',\n        sub_eq_add_neg, pow_succ]\n    _ = ∑ t ∈ s.powerset, (-1) ^ #t • ∑ a ∈ t.inf S, f a := sum_filter_not_add_sum_filter ..\n\n"}
{"name":"Finset.inclusion_exclusion_card_inf_compl","module":"Mathlib.Combinatorics.Enumerative.InclusionExclusion","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ns : Finset ι\nS : ι → Finset α\n⊢ Eq (↑(s.inf fun i => HasCompl.compl (S i)).card) (s.powerset.sum fun t => HMul.hMul (HPow.hPow (-1) t.card) ↑(t.inf S).card)","decl":"/-- **Inclusion-exclusion principle** for the cardinality of an intersection of complements.\n\nThe cardinality of the intersection of the complements of the `S i` over `i ∈ s` is the\nalternating sum of the cardinalities of the intersections of the `S i`. -/\ntheorem inclusion_exclusion_card_inf_compl (s : Finset ι) (S : ι → Finset α) :\n    #(s.inf fun i ↦ (S i)ᶜ) = ∑ t ∈ s.powerset, (-1 : ℤ) ^ #t * #(t.inf S) := by\n  simpa using inclusion_exclusion_sum_inf_compl (G := ℤ) s S (f := 1)\n\n"}
