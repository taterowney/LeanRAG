{"name":"Polynomial.cyclotomic'_zero","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_2\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Eq (Polynomial.cyclotomic' 0 R) 1","decl":"/-- The zeroth modified cyclotomic polyomial is `1`. -/\n@[simp]\ntheorem cyclotomic'_zero (R : Type*) [CommRing R] [IsDomain R] : cyclotomic' 0 R = 1 := by\n  simp only [cyclotomic', Finset.prod_empty, primitiveRoots_zero]\n\n"}
{"name":"Polynomial.cyclotomic'_one","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_2\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Eq (Polynomial.cyclotomic' 1 R) (HSub.hSub Polynomial.X 1)","decl":"/-- The first modified cyclotomic polyomial is `X - 1`. -/\n@[simp]\ntheorem cyclotomic'_one (R : Type*) [CommRing R] [IsDomain R] : cyclotomic' 1 R = X - 1 := by\n  simp only [cyclotomic', Finset.prod_singleton, RingHom.map_one,\n    IsPrimitiveRoot.primitiveRoots_one]\n\n"}
{"name":"Polynomial.cyclotomic'_two","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_2\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\np : Nat\ninst✝ : CharP R p\nhp : Ne p 2\n⊢ Eq (Polynomial.cyclotomic' 2 R) (HAdd.hAdd Polynomial.X 1)","decl":"/-- The second modified cyclotomic polyomial is `X + 1` if the characteristic of `R` is not `2`. -/\n@[simp]\ntheorem cyclotomic'_two (R : Type*) [CommRing R] [IsDomain R] (p : ℕ) [CharP R p] (hp : p ≠ 2) :\n    cyclotomic' 2 R = X + 1 := by\n  rw [cyclotomic']\n  have prim_root_two : primitiveRoots 2 R = {(-1 : R)} := by\n    simp only [Finset.eq_singleton_iff_unique_mem, mem_primitiveRoots two_pos]\n    exact ⟨IsPrimitiveRoot.neg_one p hp, fun x => IsPrimitiveRoot.eq_neg_one_of_two_right⟩\n  simp only [prim_root_two, Finset.prod_singleton, RingHom.map_neg, RingHom.map_one, sub_neg_eq_add]\n\n"}
{"name":"Polynomial.cyclotomic'.monic","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"n : Nat\nR : Type u_2\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ (Polynomial.cyclotomic' n R).Monic","decl":"/-- `cyclotomic' n R` is monic. -/\ntheorem cyclotomic'.monic (n : ℕ) (R : Type*) [CommRing R] [IsDomain R] :\n    (cyclotomic' n R).Monic :=\n  monic_prod_of_monic _ _ fun _ _ => monic_X_sub_C _\n\n"}
{"name":"Polynomial.cyclotomic'_ne_zero","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"n : Nat\nR : Type u_2\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Ne (Polynomial.cyclotomic' n R) 0","decl":"/-- `cyclotomic' n R` is different from `0`. -/\ntheorem cyclotomic'_ne_zero (n : ℕ) (R : Type*) [CommRing R] [IsDomain R] : cyclotomic' n R ≠ 0 :=\n  (cyclotomic'.monic n R).ne_zero\n\n"}
{"name":"Polynomial.natDegree_cyclotomic'","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nζ : R\nn : Nat\nh : IsPrimitiveRoot ζ n\n⊢ Eq (Polynomial.cyclotomic' n R).natDegree n.totient","decl":"/-- The natural degree of `cyclotomic' n R` is `totient n` if there is a primitive root of\nunity in `R`. -/\ntheorem natDegree_cyclotomic' {ζ : R} {n : ℕ} (h : IsPrimitiveRoot ζ n) :\n    (cyclotomic' n R).natDegree = Nat.totient n := by\n  rw [cyclotomic']\n  rw [natDegree_prod (primitiveRoots n R) fun z : R => X - C z]\n  · simp only [IsPrimitiveRoot.card_primitiveRoots h, mul_one, natDegree_X_sub_C, Nat.cast_id,\n      Finset.sum_const, nsmul_eq_mul]\n  intro z _\n  exact X_sub_C_ne_zero z\n\n"}
{"name":"Polynomial.degree_cyclotomic'","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nζ : R\nn : Nat\nh : IsPrimitiveRoot ζ n\n⊢ Eq (Polynomial.cyclotomic' n R).degree ↑n.totient","decl":"/-- The degree of `cyclotomic' n R` is `totient n` if there is a primitive root of unity in `R`. -/\ntheorem degree_cyclotomic' {ζ : R} {n : ℕ} (h : IsPrimitiveRoot ζ n) :\n    (cyclotomic' n R).degree = Nat.totient n := by\n  simp only [degree_eq_natDegree (cyclotomic'_ne_zero n R), natDegree_cyclotomic' h]\n\n"}
{"name":"Polynomial.roots_of_cyclotomic","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"n : Nat\nR : Type u_2\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Eq (Polynomial.cyclotomic' n R).roots (primitiveRoots n R).val","decl":"/-- The roots of `cyclotomic' n R` are the primitive `n`-th roots of unity. -/\ntheorem roots_of_cyclotomic (n : ℕ) (R : Type*) [CommRing R] [IsDomain R] :\n    (cyclotomic' n R).roots = (primitiveRoots n R).val := by\n  rw [cyclotomic']; exact roots_prod_X_sub_C (primitiveRoots n R)\n\n"}
{"name":"Polynomial.X_pow_sub_one_eq_prod","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nζ : R\nn : Nat\nhpos : LT.lt 0 n\nh : IsPrimitiveRoot ζ n\n⊢ Eq (HSub.hSub (HPow.hPow Polynomial.X n) 1) ((Polynomial.nthRootsFinset n R).prod fun ζ => HSub.hSub Polynomial.X (Polynomial.C ζ))","decl":"/-- If there is a primitive `n`th root of unity in `K`, then `X ^ n - 1 = ∏ (X - μ)`, where `μ`\nvaries over the `n`-th roots of unity. -/\ntheorem X_pow_sub_one_eq_prod {ζ : R} {n : ℕ} (hpos : 0 < n) (h : IsPrimitiveRoot ζ n) :\n    X ^ n - 1 = ∏ ζ ∈ nthRootsFinset n R, (X - C ζ) := by\n  classical\n  rw [nthRootsFinset, ← Multiset.toFinset_eq (IsPrimitiveRoot.nthRoots_one_nodup h)]\n  simp only [Finset.prod_mk, RingHom.map_one]\n  rw [nthRoots]\n  have hmonic : (X ^ n - C (1 : R)).Monic := monic_X_pow_sub_C (1 : R) (ne_of_lt hpos).symm\n  symm\n  apply prod_multiset_X_sub_C_of_monic_of_roots_card_eq hmonic\n  rw [@natDegree_X_pow_sub_C R _ _ n 1, ← nthRoots]\n  exact IsPrimitiveRoot.card_nthRoots_one h\n\n"}
{"name":"Polynomial.cyclotomic'_splits","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\nn : Nat\n⊢ Polynomial.Splits (RingHom.id K) (Polynomial.cyclotomic' n K)","decl":"/-- `cyclotomic' n K` splits. -/\ntheorem cyclotomic'_splits (n : ℕ) : Splits (RingHom.id K) (cyclotomic' n K) := by\n  apply splits_prod (RingHom.id K)\n  intro z _\n  simp only [splits_X_sub_C (RingHom.id K)]\n\n"}
{"name":"Polynomial.X_pow_sub_one_splits","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nn : Nat\nh : IsPrimitiveRoot ζ n\n⊢ Polynomial.Splits (RingHom.id K) (HSub.hSub (HPow.hPow Polynomial.X n) (Polynomial.C 1))","decl":"/-- If there is a primitive `n`-th root of unity in `K`, then `X ^ n - 1` splits. -/\ntheorem X_pow_sub_one_splits {ζ : K} {n : ℕ} (h : IsPrimitiveRoot ζ n) :\n    Splits (RingHom.id K) (X ^ n - C (1 : K)) := by\n  rw [splits_iff_card_roots, ← nthRoots, IsPrimitiveRoot.card_nthRoots_one h, natDegree_X_pow_sub_C]\n\n"}
{"name":"Polynomial.prod_cyclotomic'_eq_X_pow_sub_one","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"K : Type u_2\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\nζ : K\nn : Nat\nhpos : LT.lt 0 n\nh : IsPrimitiveRoot ζ n\n⊢ Eq (n.divisors.prod fun i => Polynomial.cyclotomic' i K) (HSub.hSub (HPow.hPow Polynomial.X n) 1)","decl":"/-- If there is a primitive `n`-th root of unity in `K`, then\n`∏ i ∈ Nat.divisors n, cyclotomic' i K = X ^ n - 1`. -/\ntheorem prod_cyclotomic'_eq_X_pow_sub_one {K : Type*} [CommRing K] [IsDomain K] {ζ : K} {n : ℕ}\n    (hpos : 0 < n) (h : IsPrimitiveRoot ζ n) :\n    ∏ i ∈ Nat.divisors n, cyclotomic' i K = X ^ n - 1 := by\n  classical\n  have hd : (n.divisors : Set ℕ).PairwiseDisjoint fun k => primitiveRoots k K :=\n    fun x _ y _ hne => IsPrimitiveRoot.disjoint hne\n  simp only [X_pow_sub_one_eq_prod hpos h, cyclotomic', ← Finset.prod_biUnion hd,\n    h.nthRoots_one_eq_biUnion_primitiveRoots]\n\n"}
{"name":"Polynomial.cyclotomic'_eq_X_pow_sub_one_div","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"K : Type u_2\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\nζ : K\nn : Nat\nhpos : LT.lt 0 n\nh : IsPrimitiveRoot ζ n\n⊢ Eq (Polynomial.cyclotomic' n K) ((HSub.hSub (HPow.hPow Polynomial.X n) 1).divByMonic (n.properDivisors.prod fun i => Polynomial.cyclotomic' i K))","decl":"/-- If there is a primitive `n`-th root of unity in `K`, then\n`cyclotomic' n K = (X ^ k - 1) /ₘ (∏ i ∈ Nat.properDivisors k, cyclotomic' i K)`. -/\ntheorem cyclotomic'_eq_X_pow_sub_one_div {K : Type*} [CommRing K] [IsDomain K] {ζ : K} {n : ℕ}\n    (hpos : 0 < n) (h : IsPrimitiveRoot ζ n) :\n    cyclotomic' n K = (X ^ n - 1) /ₘ ∏ i ∈ Nat.properDivisors n, cyclotomic' i K := by\n  rw [← prod_cyclotomic'_eq_X_pow_sub_one hpos h, ← Nat.cons_self_properDivisors hpos.ne',\n    Finset.prod_cons]\n  have prod_monic : (∏ i ∈ Nat.properDivisors n, cyclotomic' i K).Monic := by\n    apply monic_prod_of_monic\n    intro i _\n    exact cyclotomic'.monic i K\n  rw [(div_modByMonic_unique (cyclotomic' n K) 0 prod_monic _).1]\n  simp only [degree_zero, zero_add]\n  refine ⟨by rw [mul_comm], ?_⟩\n  rw [bot_lt_iff_ne_bot]\n  intro h\n  exact Monic.ne_zero prod_monic (degree_eq_bot.1 h)\n\n"}
{"name":"Polynomial.int_coeff_of_cyclotomic'","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"K : Type u_2\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\nζ : K\nn : Nat\nh : IsPrimitiveRoot ζ n\n⊢ Exists fun P => And (Eq (Polynomial.map (Int.castRingHom K) P) (Polynomial.cyclotomic' n K)) (And (Eq P.degree (Polynomial.cyclotomic' n K).degree) P.Monic)","decl":"/-- If there is a primitive `n`-th root of unity in `K`, then `cyclotomic' n K` comes from a\nmonic polynomial with integer coefficients. -/\ntheorem int_coeff_of_cyclotomic' {K : Type*} [CommRing K] [IsDomain K] {ζ : K} {n : ℕ}\n    (h : IsPrimitiveRoot ζ n) : ∃ P : ℤ[X], map (Int.castRingHom K) P =\n      cyclotomic' n K ∧ P.degree = (cyclotomic' n K).degree ∧ P.Monic := by\n  refine lifts_and_degree_eq_and_monic ?_ (cyclotomic'.monic n K)\n  induction' n using Nat.strong_induction_on with k ihk generalizing ζ\n  rcases k.eq_zero_or_pos with (rfl | hpos)\n  · use 1\n    simp only [cyclotomic'_zero, coe_mapRingHom, Polynomial.map_one]\n  let B : K[X] := ∏ i ∈ Nat.properDivisors k, cyclotomic' i K\n  have Bmo : B.Monic := by\n    apply monic_prod_of_monic\n    intro i _\n    exact cyclotomic'.monic i K\n  have Bint : B ∈ lifts (Int.castRingHom K) := by\n    refine Subsemiring.prod_mem (lifts (Int.castRingHom K)) ?_\n    intro x hx\n    have xsmall := (Nat.mem_properDivisors.1 hx).2\n    obtain ⟨d, hd⟩ := (Nat.mem_properDivisors.1 hx).1\n    rw [mul_comm] at hd\n    exact ihk x xsmall (h.pow hpos hd)\n  replace Bint := lifts_and_degree_eq_and_monic Bint Bmo\n  obtain ⟨B₁, hB₁, _, hB₁mo⟩ := Bint\n  let Q₁ : ℤ[X] := (X ^ k - 1) /ₘ B₁\n  have huniq : 0 + B * cyclotomic' k K = X ^ k - 1 ∧ (0 : K[X]).degree < B.degree := by\n    constructor\n    · rw [zero_add, mul_comm, ← prod_cyclotomic'_eq_X_pow_sub_one hpos h, ←\n        Nat.cons_self_properDivisors hpos.ne', Finset.prod_cons]\n    · simpa only [degree_zero, bot_lt_iff_ne_bot, Ne, degree_eq_bot] using Bmo.ne_zero\n  replace huniq := div_modByMonic_unique (cyclotomic' k K) (0 : K[X]) Bmo huniq\n  simp only [lifts, RingHom.mem_rangeS]\n  use Q₁\n  rw [coe_mapRingHom, map_divByMonic (Int.castRingHom K) hB₁mo, hB₁, ← huniq.1]\n  simp\n\n"}
{"name":"Polynomial.unique_int_coeff_of_cycl","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"K : Type u_2\ninst✝² : CommRing K\ninst✝¹ : IsDomain K\ninst✝ : CharZero K\nζ : K\nn : PNat\nh : IsPrimitiveRoot ζ ↑n\n⊢ ExistsUnique fun P => Eq (Polynomial.map (Int.castRingHom K) P) (Polynomial.cyclotomic' (↑n) K)","decl":"/-- If `K` is of characteristic `0` and there is a primitive `n`-th root of unity in `K`,\nthen `cyclotomic n K` comes from a unique polynomial with integer coefficients. -/\ntheorem unique_int_coeff_of_cycl {K : Type*} [CommRing K] [IsDomain K] [CharZero K] {ζ : K}\n    {n : ℕ+} (h : IsPrimitiveRoot ζ n) :\n    ∃! P : ℤ[X], map (Int.castRingHom K) P = cyclotomic' n K := by\n  obtain ⟨P, hP⟩ := int_coeff_of_cyclotomic' h\n  refine ⟨P, hP.1, fun Q hQ => ?_⟩\n  apply map_injective (Int.castRingHom K) Int.cast_injective\n  rw [hP.1, hQ]\n\n"}
{"name":"Polynomial.int_cyclotomic_rw","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"n : Nat\nh : Ne n 0\n⊢ Eq (Polynomial.cyclotomic n Int) ⋯.choose","decl":"theorem int_cyclotomic_rw {n : ℕ} (h : n ≠ 0) :\n    cyclotomic n ℤ = (int_coeff_of_cyclotomic' (Complex.isPrimitiveRoot_exp n h)).choose := by\n  simp only [cyclotomic, h, dif_neg, not_false_iff]\n  ext i\n  simp only [coeff_map, Int.cast_id, eq_intCast]\n\n"}
{"name":"Polynomial.map_cyclotomic_int","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝ : Ring R\n⊢ Eq (Polynomial.map (Int.castRingHom R) (Polynomial.cyclotomic n Int)) (Polynomial.cyclotomic n R)","decl":"/-- `cyclotomic n R` comes from `cyclotomic n ℤ`. -/\ntheorem map_cyclotomic_int (n : ℕ) (R : Type*) [Ring R] :\n    map (Int.castRingHom R) (cyclotomic n ℤ) = cyclotomic n R := by\n  by_cases hzero : n = 0\n  · simp only [hzero, cyclotomic, dif_pos, Polynomial.map_one]\n  simp [cyclotomic, hzero]\n\n"}
{"name":"Polynomial.int_cyclotomic_spec","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"n : Nat\n⊢ And (Eq (Polynomial.map (Int.castRingHom Complex) (Polynomial.cyclotomic n Int)) (Polynomial.cyclotomic' n Complex)) (And (Eq (Polynomial.cyclotomic n Int).degree (Polynomial.cyclotomic' n Complex).degree) (Polynomial.cyclotomic n Int).Monic)","decl":"theorem int_cyclotomic_spec (n : ℕ) :\n    map (Int.castRingHom ℂ) (cyclotomic n ℤ) = cyclotomic' n ℂ ∧\n      (cyclotomic n ℤ).degree = (cyclotomic' n ℂ).degree ∧ (cyclotomic n ℤ).Monic := by\n  by_cases hzero : n = 0\n  · simp only [hzero, cyclotomic, degree_one, monic_one, cyclotomic'_zero, dif_pos,\n      eq_self_iff_true, Polynomial.map_one, and_self_iff]\n  rw [int_cyclotomic_rw hzero]\n  exact (int_coeff_of_cyclotomic' (Complex.isPrimitiveRoot_exp n hzero)).choose_spec\n\n"}
{"name":"Polynomial.int_cyclotomic_unique","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"n : Nat\nP : Polynomial Int\nh : Eq (Polynomial.map (Int.castRingHom Complex) P) (Polynomial.cyclotomic' n Complex)\n⊢ Eq P (Polynomial.cyclotomic n Int)","decl":"theorem int_cyclotomic_unique {n : ℕ} {P : ℤ[X]} (h : map (Int.castRingHom ℂ) P = cyclotomic' n ℂ) :\n    P = cyclotomic n ℤ := by\n  apply map_injective (Int.castRingHom ℂ) Int.cast_injective\n  rw [h, (int_cyclotomic_spec n).1]\n\n"}
{"name":"Polynomial.map_cyclotomic","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"n : Nat\nR : Type u_1\nS : Type u_2\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\n⊢ Eq (Polynomial.map f (Polynomial.cyclotomic n R)) (Polynomial.cyclotomic n S)","decl":"/-- The definition of `cyclotomic n R` commutes with any ring homomorphism. -/\n@[simp]\ntheorem map_cyclotomic (n : ℕ) {R S : Type*} [Ring R] [Ring S] (f : R →+* S) :\n    map f (cyclotomic n R) = cyclotomic n S := by\n  rw [← map_cyclotomic_int n R, ← map_cyclotomic_int n S, map_map]\n  have : Subsingleton (ℤ →+* S) := inferInstance\n  congr!\n\n"}
{"name":"Polynomial.cyclotomic.eval_apply","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nq : R\nn : Nat\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\n⊢ Eq (Polynomial.eval (f q) (Polynomial.cyclotomic n S)) (f (Polynomial.eval q (Polynomial.cyclotomic n R)))","decl":"theorem cyclotomic.eval_apply {R S : Type*} (q : R) (n : ℕ) [Ring R] [Ring S] (f : R →+* S) :\n    eval (f q) (cyclotomic n S) = f (eval q (cyclotomic n R)) := by\n  rw [← map_cyclotomic n f, eval_map, eval₂_at_apply]\n\n"}
{"name":"Polynomial.cyclotomic.eval_apply_ofReal","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"q : Real\nn : Nat\n⊢ Eq (Polynomial.eval (↑q) (Polynomial.cyclotomic n Complex)) ↑(Polynomial.eval q (Polynomial.cyclotomic n Real))","decl":"@[simp] theorem cyclotomic.eval_apply_ofReal (q : ℝ) (n : ℕ) :\n    eval (q : ℂ) (cyclotomic n ℂ) = (eval q (cyclotomic n ℝ)) :=\n  cyclotomic.eval_apply q n (algebraMap ℝ ℂ)\n\n"}
{"name":"Polynomial.cyclotomic_zero","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\n⊢ Eq (Polynomial.cyclotomic 0 R) 1","decl":"/-- The zeroth cyclotomic polyomial is `1`. -/\n@[simp]\ntheorem cyclotomic_zero (R : Type*) [Ring R] : cyclotomic 0 R = 1 := by\n  simp only [cyclotomic, dif_pos]\n\n"}
{"name":"Polynomial.cyclotomic_one","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\n⊢ Eq (Polynomial.cyclotomic 1 R) (HSub.hSub Polynomial.X 1)","decl":"/-- The first cyclotomic polyomial is `X - 1`. -/\n@[simp]\ntheorem cyclotomic_one (R : Type*) [Ring R] : cyclotomic 1 R = X - 1 := by\n  have hspec : map (Int.castRingHom ℂ) (X - 1) = cyclotomic' 1 ℂ := by\n    simp only [cyclotomic'_one, PNat.one_coe, map_X, Polynomial.map_one, Polynomial.map_sub]\n  symm\n  rw [← map_cyclotomic_int, ← int_cyclotomic_unique hspec]\n  simp only [map_X, Polynomial.map_one, Polynomial.map_sub]\n\n"}
{"name":"Polynomial.cyclotomic.monic","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝ : Ring R\n⊢ (Polynomial.cyclotomic n R).Monic","decl":"/-- `cyclotomic n` is monic. -/\ntheorem cyclotomic.monic (n : ℕ) (R : Type*) [Ring R] : (cyclotomic n R).Monic := by\n  rw [← map_cyclotomic_int]\n  exact (int_cyclotomic_spec n).2.2.map _\n\n"}
{"name":"Polynomial.cyclotomic.isPrimitive","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝ : CommRing R\n⊢ (Polynomial.cyclotomic n R).IsPrimitive","decl":"/-- `cyclotomic n` is primitive. -/\ntheorem cyclotomic.isPrimitive (n : ℕ) (R : Type*) [CommRing R] : (cyclotomic n R).IsPrimitive :=\n  (cyclotomic.monic n R).isPrimitive\n\n"}
{"name":"Polynomial.cyclotomic_ne_zero","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : Nontrivial R\n⊢ Ne (Polynomial.cyclotomic n R) 0","decl":"/-- `cyclotomic n R` is different from `0`. -/\ntheorem cyclotomic_ne_zero (n : ℕ) (R : Type*) [Ring R] [Nontrivial R] : cyclotomic n R ≠ 0 :=\n  (cyclotomic.monic n R).ne_zero\n\n"}
{"name":"Polynomial.degree_cyclotomic","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : Nontrivial R\n⊢ Eq (Polynomial.cyclotomic n R).degree ↑n.totient","decl":"/-- The degree of `cyclotomic n` is `totient n`. -/\ntheorem degree_cyclotomic (n : ℕ) (R : Type*) [Ring R] [Nontrivial R] :\n    (cyclotomic n R).degree = Nat.totient n := by\n  rw [← map_cyclotomic_int]\n  rw [degree_map_eq_of_leadingCoeff_ne_zero (Int.castRingHom R) _]\n  · cases' n with k\n    · simp only [cyclotomic, degree_one, dif_pos, Nat.totient_zero, CharP.cast_eq_zero]\n    rw [← degree_cyclotomic' (Complex.isPrimitiveRoot_exp k.succ (Nat.succ_ne_zero k))]\n    exact (int_cyclotomic_spec k.succ).2.1\n  simp only [(int_cyclotomic_spec n).right.right, eq_intCast, Monic.leadingCoeff, Int.cast_one,\n    Ne, not_false_iff, one_ne_zero]\n\n"}
{"name":"Polynomial.natDegree_cyclotomic","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : Nontrivial R\n⊢ Eq (Polynomial.cyclotomic n R).natDegree n.totient","decl":"/-- The natural degree of `cyclotomic n` is `totient n`. -/\ntheorem natDegree_cyclotomic (n : ℕ) (R : Type*) [Ring R] [Nontrivial R] :\n    (cyclotomic n R).natDegree = Nat.totient n := by\n  rw [natDegree, degree_cyclotomic]; norm_cast\n\n"}
{"name":"Polynomial.degree_cyclotomic_pos","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"n : Nat\nR : Type u_1\nhpos : LT.lt 0 n\ninst✝¹ : Ring R\ninst✝ : Nontrivial R\n⊢ LT.lt 0 (Polynomial.cyclotomic n R).degree","decl":"/-- The degree of `cyclotomic n R` is positive. -/\ntheorem degree_cyclotomic_pos (n : ℕ) (R : Type*) (hpos : 0 < n) [Ring R] [Nontrivial R] :\n    0 < (cyclotomic n R).degree := by\n  rwa [degree_cyclotomic n R, Nat.cast_pos, Nat.totient_pos]\n\n"}
{"name":"Polynomial.prod_cyclotomic_eq_X_pow_sub_one","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"n : Nat\nhpos : LT.lt 0 n\nR : Type u_1\ninst✝ : CommRing R\n⊢ Eq (n.divisors.prod fun i => Polynomial.cyclotomic i R) (HSub.hSub (HPow.hPow Polynomial.X n) 1)","decl":"/-- `∏ i ∈ Nat.divisors n, cyclotomic i R = X ^ n - 1`. -/\ntheorem prod_cyclotomic_eq_X_pow_sub_one {n : ℕ} (hpos : 0 < n) (R : Type*) [CommRing R] :\n    ∏ i ∈ Nat.divisors n, cyclotomic i R = X ^ n - 1 := by\n  have integer : ∏ i ∈ Nat.divisors n, cyclotomic i ℤ = X ^ n - 1 := by\n    apply map_injective (Int.castRingHom ℂ) Int.cast_injective\n    simp only [Polynomial.map_prod, int_cyclotomic_spec, Polynomial.map_pow, map_X,\n      Polynomial.map_one, Polynomial.map_sub]\n    exact prod_cyclotomic'_eq_X_pow_sub_one hpos (Complex.isPrimitiveRoot_exp n hpos.ne')\n  simpa only [Polynomial.map_prod, map_cyclotomic_int, Polynomial.map_sub, Polynomial.map_one,\n    Polynomial.map_pow, Polynomial.map_X] using congr_arg (map (Int.castRingHom R)) integer\n\n"}
{"name":"Polynomial.cyclotomic.dvd_X_pow_sub_one","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝ : Ring R\n⊢ Dvd.dvd (Polynomial.cyclotomic n R) (HSub.hSub (HPow.hPow Polynomial.X n) 1)","decl":"theorem cyclotomic.dvd_X_pow_sub_one (n : ℕ) (R : Type*) [Ring R] :\n    cyclotomic n R ∣ X ^ n - 1 := by\n  suffices cyclotomic n ℤ ∣ X ^ n - 1 by\n    simpa only [map_cyclotomic_int, Polynomial.map_sub, Polynomial.map_one, Polynomial.map_pow,\n      Polynomial.map_X] using map_dvd (Int.castRingHom R) this\n  rcases n.eq_zero_or_pos with (rfl | hn)\n  · simp\n  rw [← prod_cyclotomic_eq_X_pow_sub_one hn]\n  exact Finset.dvd_prod_of_mem _ (n.mem_divisors_self hn.ne')\n\n"}
{"name":"Polynomial.prod_cyclotomic_eq_geom_sum","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"n : Nat\nh : LT.lt 0 n\nR : Type u_1\ninst✝ : CommRing R\n⊢ Eq ((n.divisors.erase 1).prod fun i => Polynomial.cyclotomic i R) ((Finset.range n).sum fun i => HPow.hPow Polynomial.X i)","decl":"theorem prod_cyclotomic_eq_geom_sum {n : ℕ} (h : 0 < n) (R) [CommRing R] :\n    ∏ i ∈ n.divisors.erase 1, cyclotomic i R = ∑ i ∈ Finset.range n, X ^ i := by\n  suffices (∏ i ∈ n.divisors.erase 1, cyclotomic i ℤ) = ∑ i ∈ Finset.range n, X ^ i by\n    simpa only [Polynomial.map_prod, map_cyclotomic_int, Polynomial.map_sum, Polynomial.map_pow,\n      Polynomial.map_X] using congr_arg (map (Int.castRingHom R)) this\n  rw [← mul_left_inj' (cyclotomic_ne_zero 1 ℤ), prod_erase_mul _ _ (Nat.one_mem_divisors.2 h.ne'),\n    cyclotomic_one, geom_sum_mul, prod_cyclotomic_eq_X_pow_sub_one h]\n\n"}
{"name":"Polynomial.cyclotomic_prime","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\np : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (Polynomial.cyclotomic p R) ((Finset.range p).sum fun i => HPow.hPow Polynomial.X i)","decl":"/-- If `p` is prime, then `cyclotomic p R = ∑ i ∈ range p, X ^ i`. -/\ntheorem cyclotomic_prime (R : Type*) [Ring R] (p : ℕ) [hp : Fact p.Prime] :\n    cyclotomic p R = ∑ i ∈ Finset.range p, X ^ i := by\n  suffices cyclotomic p ℤ = ∑ i ∈ range p, X ^ i by\n    simpa only [map_cyclotomic_int, Polynomial.map_sum, Polynomial.map_pow, Polynomial.map_X] using\n      congr_arg (map (Int.castRingHom R)) this\n  rw [← prod_cyclotomic_eq_geom_sum hp.out.pos, hp.out.divisors,\n    erase_insert (mem_singleton.not.2 hp.out.ne_one.symm), prod_singleton]\n\n"}
{"name":"Polynomial.cyclotomic_prime_mul_X_sub_one","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\np : Nat\nhn : Fact (Nat.Prime p)\n⊢ Eq (HMul.hMul (Polynomial.cyclotomic p R) (HSub.hSub Polynomial.X 1)) (HSub.hSub (HPow.hPow Polynomial.X p) 1)","decl":"theorem cyclotomic_prime_mul_X_sub_one (R : Type*) [Ring R] (p : ℕ) [hn : Fact (Nat.Prime p)] :\n    cyclotomic p R * (X - 1) = X ^ p - 1 := by rw [cyclotomic_prime, geom_sum_mul]\n\n"}
{"name":"Polynomial.cyclotomic_two","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\n⊢ Eq (Polynomial.cyclotomic 2 R) (HAdd.hAdd Polynomial.X 1)","decl":"@[simp]\ntheorem cyclotomic_two (R : Type*) [Ring R] : cyclotomic 2 R = X + 1 := by simp [cyclotomic_prime]\n\n"}
{"name":"Polynomial.cyclotomic_three","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\n⊢ Eq (Polynomial.cyclotomic 3 R) (HAdd.hAdd (HAdd.hAdd (HPow.hPow Polynomial.X 2) Polynomial.X) 1)","decl":"@[simp]\ntheorem cyclotomic_three (R : Type*) [Ring R] : cyclotomic 3 R = X ^ 2 + X + 1 := by\n  simp [cyclotomic_prime, sum_range_succ']\n\n"}
{"name":"Polynomial.cyclotomic_dvd_geom_sum_of_dvd","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\nd n : Nat\nhdn : Dvd.dvd d n\nhd : Ne d 1\n⊢ Dvd.dvd (Polynomial.cyclotomic d R) ((Finset.range n).sum fun i => HPow.hPow Polynomial.X i)","decl":"theorem cyclotomic_dvd_geom_sum_of_dvd (R) [Ring R] {d n : ℕ} (hdn : d ∣ n) (hd : d ≠ 1) :\n    cyclotomic d R ∣ ∑ i ∈ Finset.range n, X ^ i := by\n  suffices cyclotomic d ℤ ∣ ∑ i ∈ Finset.range n, X ^ i by\n    simpa only [map_cyclotomic_int, Polynomial.map_sum, Polynomial.map_pow, Polynomial.map_X] using\n      map_dvd (Int.castRingHom R) this\n  rcases n.eq_zero_or_pos with (rfl | hn)\n  · simp\n  rw [← prod_cyclotomic_eq_geom_sum hn]\n  apply Finset.dvd_prod_of_mem\n  simp [hd, hdn, hn.ne']\n\n"}
{"name":"Polynomial.X_pow_sub_one_mul_prod_cyclotomic_eq_X_pow_sub_one_of_dvd","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nd n : Nat\nh : Membership.mem n.properDivisors d\n⊢ Eq (HMul.hMul (HSub.hSub (HPow.hPow Polynomial.X d) 1) ((SDiff.sdiff n.divisors d.divisors).prod fun x => Polynomial.cyclotomic x R)) (HSub.hSub (HPow.hPow Polynomial.X n) 1)","decl":"theorem X_pow_sub_one_mul_prod_cyclotomic_eq_X_pow_sub_one_of_dvd (R) [CommRing R] {d n : ℕ}\n    (h : d ∈ n.properDivisors) :\n    ((X ^ d - 1) * ∏ x ∈ n.divisors \\ d.divisors, cyclotomic x R) = X ^ n - 1 := by\n  obtain ⟨hd, hdn⟩ := Nat.mem_properDivisors.mp h\n  have h0n : 0 < n := pos_of_gt hdn\n  have h0d : 0 < d := Nat.pos_of_dvd_of_pos hd h0n\n  rw [← prod_cyclotomic_eq_X_pow_sub_one h0d, ← prod_cyclotomic_eq_X_pow_sub_one h0n, mul_comm,\n    Finset.prod_sdiff (Nat.divisors_subset_of_dvd h0n.ne' hd)]\n\n"}
{"name":"Polynomial.X_pow_sub_one_mul_cyclotomic_dvd_X_pow_sub_one_of_dvd","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nd n : Nat\nh : Membership.mem n.properDivisors d\n⊢ Dvd.dvd (HMul.hMul (HSub.hSub (HPow.hPow Polynomial.X d) 1) (Polynomial.cyclotomic n R)) (HSub.hSub (HPow.hPow Polynomial.X n) 1)","decl":"theorem X_pow_sub_one_mul_cyclotomic_dvd_X_pow_sub_one_of_dvd (R) [CommRing R] {d n : ℕ}\n    (h : d ∈ n.properDivisors) : (X ^ d - 1) * cyclotomic n R ∣ X ^ n - 1 := by\n  have hdn := (Nat.mem_properDivisors.mp h).2\n  use ∏ x ∈ n.properDivisors \\ d.divisors, cyclotomic x R\n  symm\n  convert X_pow_sub_one_mul_prod_cyclotomic_eq_X_pow_sub_one_of_dvd R h using 1\n  rw [mul_assoc]\n  congr 1\n  rw [← Nat.insert_self_properDivisors hdn.ne_bot, insert_sdiff_of_not_mem, prod_insert]\n  · exact Finset.not_mem_sdiff_of_not_mem_left Nat.properDivisors.not_self_mem\n  · exact fun hk => hdn.not_le <| Nat.divisor_le hk\n\n"}
{"name":"Polynomial.cyclotomic_eq_prod_X_pow_sub_one_pow_moebius","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Eq ((algebraMap (Polynomial R) (RatFunc R)) (Polynomial.cyclotomic n R)) (n.divisorsAntidiagonal.prod fun i => HPow.hPow ((algebraMap (Polynomial R) (RatFunc R)) (HSub.hSub (HPow.hPow Polynomial.X i.2) 1)) (ArithmeticFunction.moebius i.1))","decl":"/-- `cyclotomic n R` can be expressed as a product in a fraction field of `R[X]`\n  using Möbius inversion. -/\ntheorem cyclotomic_eq_prod_X_pow_sub_one_pow_moebius {n : ℕ} (R : Type*) [CommRing R]\n    [IsDomain R] : algebraMap _ (RatFunc R) (cyclotomic n R) =\n      ∏ i ∈ n.divisorsAntidiagonal, algebraMap R[X] _ (X ^ i.snd - 1) ^ μ i.fst := by\n  rcases n.eq_zero_or_pos with (rfl | hpos)\n  · simp\n  have h : ∀ n : ℕ, 0 < n → (∏ i ∈ Nat.divisors n, algebraMap _ (RatFunc R) (cyclotomic i R)) =\n      algebraMap _ _ (X ^ n - 1 : R[X]) := by\n    intro n hn\n    rw [← prod_cyclotomic_eq_X_pow_sub_one hn R, map_prod]\n  rw [(prod_eq_iff_prod_pow_moebius_eq_of_nonzero (fun n hn => _) fun n hn => _).1 h n hpos] <;>\n    simp_rw [Ne, IsFractionRing.to_map_eq_zero_iff]\n  · simp [cyclotomic_ne_zero]\n  · intro n hn\n    apply Monic.ne_zero\n    apply monic_X_pow_sub_C _ (ne_of_gt hn)\n\n"}
{"name":"Polynomial.cyclotomic_eq_X_pow_sub_one_div","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\nhpos : LT.lt 0 n\n⊢ Eq (Polynomial.cyclotomic n R) ((HSub.hSub (HPow.hPow Polynomial.X n) 1).divByMonic (n.properDivisors.prod fun i => Polynomial.cyclotomic i R))","decl":"/-- We have\n`cyclotomic n R = (X ^ k - 1) /ₘ (∏ i ∈ Nat.properDivisors k, cyclotomic i K)`. -/\ntheorem cyclotomic_eq_X_pow_sub_one_div {R : Type*} [CommRing R] {n : ℕ} (hpos : 0 < n) :\n    cyclotomic n R = (X ^ n - 1) /ₘ ∏ i ∈ Nat.properDivisors n, cyclotomic i R := by\n  nontriviality R\n  rw [← prod_cyclotomic_eq_X_pow_sub_one hpos, ← Nat.cons_self_properDivisors hpos.ne',\n    Finset.prod_cons]\n  have prod_monic : (∏ i ∈ Nat.properDivisors n, cyclotomic i R).Monic := by\n    apply monic_prod_of_monic\n    intro i _\n    exact cyclotomic.monic i R\n  rw [(div_modByMonic_unique (cyclotomic n R) 0 prod_monic _).1]\n  simp only [degree_zero, zero_add]\n  constructor\n  · rw [mul_comm]\n  rw [bot_lt_iff_ne_bot]\n  intro h\n  exact Monic.ne_zero prod_monic (degree_eq_bot.1 h)\n\n"}
{"name":"Polynomial.X_pow_sub_one_dvd_prod_cyclotomic","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn m : Nat\nhpos : LT.lt 0 n\nhm : Dvd.dvd m n\nhdiff : Ne m n\n⊢ Dvd.dvd (HSub.hSub (HPow.hPow Polynomial.X m) 1) (n.properDivisors.prod fun i => Polynomial.cyclotomic i R)","decl":"/-- If `m` is a proper divisor of `n`, then `X ^ m - 1` divides\n`∏ i ∈ Nat.properDivisors n, cyclotomic i R`. -/\ntheorem X_pow_sub_one_dvd_prod_cyclotomic (R : Type*) [CommRing R] {n m : ℕ} (hpos : 0 < n)\n    (hm : m ∣ n) (hdiff : m ≠ n) : X ^ m - 1 ∣ ∏ i ∈ Nat.properDivisors n, cyclotomic i R := by\n  replace hm := Nat.mem_properDivisors.2\n    ⟨hm, lt_of_le_of_ne (Nat.divisor_le (Nat.mem_divisors.2 ⟨hm, hpos.ne'⟩)) hdiff⟩\n  rw [← Finset.sdiff_union_of_subset (Nat.divisors_subset_properDivisors (ne_of_lt hpos).symm\n    (Nat.mem_properDivisors.1 hm).1 (ne_of_lt (Nat.mem_properDivisors.1 hm).2)),\n    Finset.prod_union Finset.sdiff_disjoint,\n    prod_cyclotomic_eq_X_pow_sub_one (Nat.pos_of_mem_properDivisors hm)]\n  exact ⟨∏ x ∈ n.properDivisors \\ m.divisors, cyclotomic x R, by rw [mul_comm]⟩\n\n"}
{"name":"Polynomial.cyclotomic_eq_prod_X_sub_primitiveRoots","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"K : Type u_1\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\nζ : K\nn : Nat\nhz : IsPrimitiveRoot ζ n\n⊢ Eq (Polynomial.cyclotomic n K) ((primitiveRoots n K).prod fun μ => HSub.hSub Polynomial.X (Polynomial.C μ))","decl":"/-- If there is a primitive `n`-th root of unity in `K`, then\n`cyclotomic n K = ∏ μ ∈ primitiveRoots n K, (X - C μ)`. ∈ particular,\n`cyclotomic n K = cyclotomic' n K` -/\ntheorem cyclotomic_eq_prod_X_sub_primitiveRoots {K : Type*} [CommRing K] [IsDomain K] {ζ : K}\n    {n : ℕ} (hz : IsPrimitiveRoot ζ n) : cyclotomic n K = ∏ μ ∈ primitiveRoots n K, (X - C μ) := by\n  rw [← cyclotomic']\n  induction' n using Nat.strong_induction_on with k hk generalizing ζ\n  obtain hzero | hpos := k.eq_zero_or_pos\n  · simp only [hzero, cyclotomic'_zero, cyclotomic_zero]\n  have h : ∀ i ∈ k.properDivisors, cyclotomic i K = cyclotomic' i K := by\n    intro i hi\n    obtain ⟨d, hd⟩ := (Nat.mem_properDivisors.1 hi).1\n    rw [mul_comm] at hd\n    exact hk i (Nat.mem_properDivisors.1 hi).2 (IsPrimitiveRoot.pow hpos hz hd)\n  rw [@cyclotomic_eq_X_pow_sub_one_div _ _ _ hpos, cyclotomic'_eq_X_pow_sub_one_div hpos hz,\n    Finset.prod_congr (refl k.properDivisors) h]\n\n"}
{"name":"Polynomial.eq_cyclotomic_iff","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\nhpos : LT.lt 0 n\nP : Polynomial R\n⊢ Iff (Eq P (Polynomial.cyclotomic n R)) (Eq (HMul.hMul P (n.properDivisors.prod fun i => Polynomial.cyclotomic i R)) (HSub.hSub (HPow.hPow Polynomial.X n) 1))","decl":"theorem eq_cyclotomic_iff {R : Type*} [CommRing R] {n : ℕ} (hpos : 0 < n) (P : R[X]) :\n    P = cyclotomic n R ↔\n    (P * ∏ i ∈ Nat.properDivisors n, Polynomial.cyclotomic i R) = X ^ n - 1 := by\n  nontriviality R\n  refine ⟨fun hcycl => ?_, fun hP => ?_⟩\n  · rw [hcycl, ← prod_cyclotomic_eq_X_pow_sub_one hpos R, ← Nat.cons_self_properDivisors hpos.ne',\n      Finset.prod_cons]\n  · have prod_monic : (∏ i ∈ Nat.properDivisors n, cyclotomic i R).Monic := by\n      apply monic_prod_of_monic\n      intro i _\n      exact cyclotomic.monic i R\n    rw [@cyclotomic_eq_X_pow_sub_one_div R _ _ hpos, (div_modByMonic_unique P 0 prod_monic _).1]\n    refine ⟨by rwa [zero_add, mul_comm], ?_⟩\n    rw [degree_zero, bot_lt_iff_ne_bot]\n    intro h\n    exact Monic.ne_zero prod_monic (degree_eq_bot.1 h)\n\n"}
{"name":"Polynomial.cyclotomic_prime_pow_eq_geom_sum","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\np n : Nat\nhp : Nat.Prime p\n⊢ Eq (Polynomial.cyclotomic (HPow.hPow p (HAdd.hAdd n 1)) R) ((Finset.range p).sum fun i => HPow.hPow (HPow.hPow Polynomial.X (HPow.hPow p n)) i)","decl":"/-- If `p ^ k` is a prime power, then\n`cyclotomic (p ^ (n + 1)) R = ∑ i ∈ range p, (X ^ (p ^ n)) ^ i`. -/\ntheorem cyclotomic_prime_pow_eq_geom_sum {R : Type*} [CommRing R] {p n : ℕ} (hp : p.Prime) :\n    cyclotomic (p ^ (n + 1)) R = ∑ i ∈ Finset.range p, (X ^ p ^ n) ^ i := by\n  have : ∀ m, (cyclotomic (p ^ (m + 1)) R = ∑ i ∈ Finset.range p, (X ^ p ^ m) ^ i) ↔\n      ((∑ i ∈ Finset.range p, (X ^ p ^ m) ^ i) *\n        ∏ x ∈ Finset.range (m + 1), cyclotomic (p ^ x) R) = X ^ p ^ (m + 1) - 1 := by\n    intro m\n    have := eq_cyclotomic_iff (R := R) (P := ∑ i ∈ range p, (X ^ p ^ m) ^ i)\n      (pow_pos hp.pos (m + 1))\n    rw [eq_comm] at this\n    rw [this, Nat.prod_properDivisors_prime_pow hp]\n  induction' n with n_n n_ih\n  · haveI := Fact.mk hp; simp [cyclotomic_prime]\n  rw [((eq_cyclotomic_iff (pow_pos hp.pos (n_n + 1 + 1)) _).mpr _).symm]\n  rw [Nat.prod_properDivisors_prime_pow hp, Finset.prod_range_succ, n_ih]\n  rw [this] at n_ih\n  rw [mul_comm _ (∑ i ∈ _, _), n_ih, geom_sum_mul, sub_left_inj, ← pow_mul]\n  simp only [pow_add, pow_one]\n\n"}
{"name":"Polynomial.cyclotomic_prime_pow_mul_X_pow_sub_one","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\np k : Nat\nhn : Fact (Nat.Prime p)\n⊢ Eq (HMul.hMul (Polynomial.cyclotomic (HPow.hPow p (HAdd.hAdd k 1)) R) (HSub.hSub (HPow.hPow Polynomial.X (HPow.hPow p k)) 1)) (HSub.hSub (HPow.hPow Polynomial.X (HPow.hPow p (HAdd.hAdd k 1))) 1)","decl":"theorem cyclotomic_prime_pow_mul_X_pow_sub_one (R : Type*) [CommRing R] (p k : ℕ)\n    [hn : Fact (Nat.Prime p)] :\n    cyclotomic (p ^ (k + 1)) R * (X ^ p ^ k - 1) = X ^ p ^ (k + 1) - 1 := by\n  rw [cyclotomic_prime_pow_eq_geom_sum hn.out, geom_sum_mul, ← pow_mul, pow_succ, mul_comm]\n\n"}
{"name":"Polynomial.cyclotomic_coeff_zero","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\nhn : LT.lt 1 n\n⊢ Eq ((Polynomial.cyclotomic n R).coeff 0) 1","decl":"/-- The constant term of `cyclotomic n R` is `1` if `2 ≤ n`. -/\ntheorem cyclotomic_coeff_zero (R : Type*) [CommRing R] {n : ℕ} (hn : 1 < n) :\n    (cyclotomic n R).coeff 0 = 1 := by\n  induction' n using Nat.strong_induction_on with n hi\n  have hprod : (∏ i ∈ Nat.properDivisors n, (Polynomial.cyclotomic i R).coeff 0) = -1 := by\n    rw [← Finset.insert_erase (Nat.one_mem_properDivisors_iff_one_lt.2\n      (lt_of_lt_of_le one_lt_two hn)), Finset.prod_insert (Finset.not_mem_erase 1 _),\n      cyclotomic_one R]\n    have hleq : ∀ j ∈ n.properDivisors.erase 1, 2 ≤ j := by\n      intro j hj\n      apply Nat.succ_le_of_lt\n      exact (Ne.le_iff_lt (Finset.mem_erase.1 hj).1.symm).mp\n        (Nat.succ_le_of_lt (Nat.pos_of_mem_properDivisors (Finset.mem_erase.1 hj).2))\n    have hcongr : ∀ j ∈ n.properDivisors.erase 1, (cyclotomic j R).coeff 0 = 1 := by\n      intro j hj\n      exact hi j (Nat.mem_properDivisors.1 (Finset.mem_erase.1 hj).2).2 (hleq j hj)\n    have hrw : (∏ x ∈ n.properDivisors.erase 1, (cyclotomic x R).coeff 0) = 1 := by\n      rw [Finset.prod_congr (refl (n.properDivisors.erase 1)) hcongr]\n      simp only [Finset.prod_const_one]\n    simp only [hrw, mul_one, zero_sub, coeff_one_zero, coeff_X_zero, coeff_sub]\n  have heq : (X ^ n - 1 : R[X]).coeff 0 = -(cyclotomic n R).coeff 0 := by\n    rw [← prod_cyclotomic_eq_X_pow_sub_one (zero_le_one.trans_lt hn), ←\n      Nat.cons_self_properDivisors hn.ne_bot, Finset.prod_cons, mul_coeff_zero, coeff_zero_prod,\n      hprod, mul_neg, mul_one]\n  have hzero : (X ^ n - 1 : R[X]).coeff 0 = (-1 : R) := by\n    rw [coeff_zero_eq_eval_zero _]\n    simp only [zero_pow (by positivity : n ≠ 0), eval_X, eval_one, zero_sub, eval_pow, eval_sub]\n  rw [hzero] at heq\n  exact neg_inj.mp (Eq.symm heq)\n\n"}
{"name":"Polynomial.coprime_of_root_cyclotomic","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"n : Nat\nhpos : LT.lt 0 n\np : Nat\nhprime : Fact (Nat.Prime p)\na : Nat\nhroot : (Polynomial.cyclotomic n (ZMod p)).IsRoot ((Nat.castRingHom (ZMod p)) a)\n⊢ a.Coprime p","decl":"/-- If `(a : ℕ)` is a root of `cyclotomic n (ZMod p)`, where `p` is a prime, then `a` and `p` are\ncoprime. -/\ntheorem coprime_of_root_cyclotomic {n : ℕ} (hpos : 0 < n) {p : ℕ} [hprime : Fact p.Prime] {a : ℕ}\n    (hroot : IsRoot (cyclotomic n (ZMod p)) (Nat.castRingHom (ZMod p) a)) : a.Coprime p := by\n  apply Nat.Coprime.symm\n  rw [hprime.1.coprime_iff_not_dvd]\n  intro h\n  replace h := (ZMod.natCast_zmod_eq_zero_iff_dvd a p).2 h\n  rw [IsRoot.def, eq_natCast, h, ← coeff_zero_eq_eval_zero] at hroot\n  by_cases hone : n = 1\n  · simp only [hone, cyclotomic_one, zero_sub, coeff_one_zero, coeff_X_zero, neg_eq_zero,\n      one_ne_zero, coeff_sub] at hroot\n  rw [cyclotomic_coeff_zero (ZMod p) (Nat.succ_le_of_lt\n    (lt_of_le_of_ne (Nat.succ_le_of_lt hpos) (Ne.symm hone)))] at hroot\n  exact one_ne_zero hroot\n\n"}
{"name":"Polynomial.orderOf_root_cyclotomic_dvd","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"n : Nat\nhpos : LT.lt 0 n\np : Nat\ninst✝ : Fact (Nat.Prime p)\na : Nat\nhroot : (Polynomial.cyclotomic n (ZMod p)).IsRoot ((Nat.castRingHom (ZMod p)) a)\n⊢ Dvd.dvd (orderOf (ZMod.unitOfCoprime a ⋯)) n","decl":"/-- If `(a : ℕ)` is a root of `cyclotomic n (ZMod p)`, then the multiplicative order of `a` modulo\n`p` divides `n`. -/\ntheorem orderOf_root_cyclotomic_dvd {n : ℕ} (hpos : 0 < n) {p : ℕ} [Fact p.Prime] {a : ℕ}\n    (hroot : IsRoot (cyclotomic n (ZMod p)) (Nat.castRingHom (ZMod p) a)) :\n    orderOf (ZMod.unitOfCoprime a (coprime_of_root_cyclotomic hpos hroot)) ∣ n := by\n  apply orderOf_dvd_of_pow_eq_one\n  suffices hpow : eval (Nat.castRingHom (ZMod p) a) (X ^ n - 1 : (ZMod p)[X]) = 0 by\n    simp only [eval_X, eval_one, eval_pow, eval_sub, eq_natCast] at hpow\n    apply Units.val_eq_one.1\n    simp only [sub_eq_zero.mp hpow, ZMod.coe_unitOfCoprime, Units.val_pow_eq_pow_val]\n  rw [IsRoot.def] at hroot\n  rw [← prod_cyclotomic_eq_X_pow_sub_one hpos (ZMod p), ← Nat.cons_self_properDivisors hpos.ne',\n    Finset.prod_cons, eval_mul, hroot, zero_mul]\n\n"}
{"name":"Polynomial.dvd_C_mul_X_sub_one_pow_add_one","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\np : Nat\nhpri : Nat.Prime p\nhp : Ne p 2\na r : R\nh₁ : Dvd.dvd r (HPow.hPow a p)\nh₂ : Dvd.dvd r (HMul.hMul (↑p) a)\n⊢ Dvd.dvd (Polynomial.C r) (HAdd.hAdd (HPow.hPow (HSub.hSub (HMul.hMul (Polynomial.C a) Polynomial.X) 1) p) 1)","decl":"lemma dvd_C_mul_X_sub_one_pow_add_one {p : ℕ} (hpri : p.Prime)\n    (hp : p ≠ 2) (a r : R) (h₁ : r ∣ a ^ p) (h₂ : r ∣ p * a) : C r ∣ (C a * X - 1) ^ p + 1 := by\n  have := hpri.dvd_add_pow_sub_pow_of_dvd (C a * X) (-1) (r := C r) ?_ ?_\n  · rwa [← sub_eq_add_neg, (hpri.odd_of_ne_two hp).neg_pow, one_pow, sub_neg_eq_add] at this\n  · simp only [mul_pow, ← map_pow, dvd_mul_right, (_root_.map_dvd C h₁).trans]\n  simp only [map_mul, map_natCast, ← mul_assoc, dvd_mul_right, (_root_.map_dvd C h₂).trans]\n\n"}
{"name":"IsPrimitiveRoot.pow_sub_pow_eq_prod_sub_mul","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nζ : R\nn : Nat\nx y : R\ninst✝ : IsDomain R\nhpos : LT.lt 0 n\nh : IsPrimitiveRoot ζ n\n⊢ Eq (HSub.hSub (HPow.hPow x n) (HPow.hPow y n)) ((Polynomial.nthRootsFinset n R).prod fun ζ => HSub.hSub x (HMul.hMul ζ y))","decl":"/-- If there is a primitive `n`th root of unity in `R`, then `X ^ n - Y ^ n = ∏ (X - μ Y)`,\nwhere `μ` varies over the `n`-th roots of unity. -/\ntheorem _root_.IsPrimitiveRoot.pow_sub_pow_eq_prod_sub_mul (hpos : 0 < n)\n    (h : IsPrimitiveRoot ζ n) : x ^ n - y ^ n = ∏ ζ ∈ nthRootsFinset n R, (x - ζ * y) := by\n  let K := FractionRing R\n  apply NoZeroSMulDivisors.algebraMap_injective R K\n  rw [map_sub, map_pow, map_pow, map_prod]\n  simp_rw [map_sub, map_mul]\n  have h' : IsPrimitiveRoot (algebraMap R K ζ) n :=\n    h.map_of_injective <| NoZeroSMulDivisors.algebraMap_injective R K\n  rw [h'.pow_sub_pow_eq_prod_sub_mul_field _ _ hpos]\n  refine (prod_nbij (algebraMap R K) (fun a ha ↦ map_mem_nthRootsFinset ha _) (fun a _ b _ H ↦\n    NoZeroSMulDivisors.algebraMap_injective R K H) (fun a ha ↦ ?_) (fun _ _ ↦ rfl)).symm\n  have := Set.surj_on_of_inj_on_of_ncard_le (s := nthRootsFinset n R)\n    (t := nthRootsFinset n K) _ (fun _ hr ↦ map_mem_nthRootsFinset hr _)\n    (fun a _ b _ H ↦ NoZeroSMulDivisors.algebraMap_injective R K H)\n    (by simp [h.card_nthRootsFinset, h'.card_nthRootsFinset])\n  obtain ⟨x, hx, hx1⟩ := this _ ha\n  exact ⟨x, hx, hx1.symm⟩\n\n"}
{"name":"IsPrimitiveRoot.pow_add_pow_eq_prod_add_mul","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nζ : R\nn : Nat\nx y : R\ninst✝ : IsDomain R\nhodd : Odd n\nh : IsPrimitiveRoot ζ n\n⊢ Eq (HAdd.hAdd (HPow.hPow x n) (HPow.hPow y n)) ((Polynomial.nthRootsFinset n R).prod fun ζ => HAdd.hAdd x (HMul.hMul ζ y))","decl":"/-- If there is a primitive `n`th root of unity in `R` and `n` is odd, then\n`X ^ n + Y ^ n = ∏ (X + μ Y)`, where `μ` varies over the `n`-th roots of unity. -/\ntheorem _root_.IsPrimitiveRoot.pow_add_pow_eq_prod_add_mul (hodd : Odd n)\n    (h : IsPrimitiveRoot ζ n) : x ^ n + y ^ n = ∏ ζ ∈ nthRootsFinset n R, (x + ζ * y) := by\n  simpa [hodd.neg_pow] using h.pow_sub_pow_eq_prod_sub_mul x (-y) hodd.pos\n\n"}
