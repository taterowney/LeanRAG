{"name":"Submodule.isInternal_prime_power_torsion_of_is_torsion_by_ideal","module":"Mathlib.Algebra.Module.DedekindDomain","initialProofState":"R : Type u\ninst✝⁵ : CommRing R\ninst✝⁴ : IsDomain R\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : IsDedekindDomain R\ninst✝ : DecidableEq (Ideal R)\nI : Ideal R\nhI : Ne I Bot.bot\nhM : Module.IsTorsionBySet R M ↑I\n⊢ DirectSum.IsInternal fun p => Submodule.torsionBySet R M ↑(HPow.hPow (↑p) (Multiset.count (↑p) (UniqueFactorizationMonoid.factors I)))","decl":"/-- Over a Dedekind domain, an `I`-torsion module is the internal direct sum of its `p i ^ e i`-\ntorsion submodules, where `I = ∏ i, p i ^ e i` is its unique decomposition in prime ideals. -/\ntheorem isInternal_prime_power_torsion_of_is_torsion_by_ideal [DecidableEq (Ideal R)]\n    {I : Ideal R} (hI : I ≠ ⊥) (hM : Module.IsTorsionBySet R M I) :\n    DirectSum.IsInternal fun p : (factors I).toFinset =>\n      torsionBySet R M (p ^ (factors I).count ↑p : Ideal R) := by\n  let P := factors I\n  have prime_of_mem := fun p (hp : p ∈ P.toFinset) =>\n    prime_of_factor p (Multiset.mem_toFinset.mp hp)\n  apply torsionBySet_isInternal (p := fun p => p ^ P.count p) _\n  · convert hM\n    rw [← Finset.inf_eq_iInf, IsDedekindDomain.inf_prime_pow_eq_prod, ← Finset.prod_multiset_count,\n      ← associated_iff_eq]\n    · exact factors_prod hI\n    · exact prime_of_mem\n    · exact fun _ _ _ _ ij => ij\n  · intro p hp q hq pq; dsimp\n    rw [irreducible_pow_sup]\n    · suffices (normalizedFactors _).count p = 0 by rw [this, zero_min, pow_zero, Ideal.one_eq_top]\n      rw [Multiset.count_eq_zero,\n        normalizedFactors_of_irreducible_pow (prime_of_mem q hq).irreducible,\n        Multiset.mem_replicate]\n      exact fun H => pq <| H.2.trans <| normalize_eq q\n    · rw [← Ideal.zero_eq_bot]; apply pow_ne_zero; exact (prime_of_mem q hq).ne_zero\n    · exact (prime_of_mem p hp).irreducible\n\n"}
{"name":"Submodule.isInternal_prime_power_torsion","module":"Mathlib.Algebra.Module.DedekindDomain","initialProofState":"R : Type u\ninst✝⁶ : CommRing R\ninst✝⁵ : IsDomain R\nM : Type v\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : IsDedekindDomain R\ninst✝¹ : DecidableEq (Ideal R)\ninst✝ : Module.Finite R M\nhM : Module.IsTorsion R M\n⊢ DirectSum.IsInternal fun p => Submodule.torsionBySet R M ↑(HPow.hPow (↑p) (Multiset.count (↑p) (UniqueFactorizationMonoid.factors Top.top.annihilator)))","decl":"/-- A finitely generated torsion module over a Dedekind domain is an internal direct sum of its\n`p i ^ e i`-torsion submodules where `p i` are factors of `(⊤ : Submodule R M).annihilator` and\n`e i` are their multiplicities. -/\ntheorem isInternal_prime_power_torsion [DecidableEq (Ideal R)] [Module.Finite R M]\n    (hM : Module.IsTorsion R M) :\n    DirectSum.IsInternal fun p : (factors (⊤ : Submodule R M).annihilator).toFinset =>\n      torsionBySet R M (p ^ (factors (⊤ : Submodule R M).annihilator).count ↑p : Ideal R) := by\n  have hM' := Module.isTorsionBySet_annihilator_top R M\n  have hI := Submodule.annihilator_top_inter_nonZeroDivisors hM\n  refine isInternal_prime_power_torsion_of_is_torsion_by_ideal ?_ hM'\n  rw [← Set.nonempty_iff_ne_empty] at hI; rw [Submodule.ne_bot_iff]\n  obtain ⟨x, H, hx⟩ := hI; exact ⟨x, H, nonZeroDivisors.ne_zero hx⟩\n\n"}
{"name":"Submodule.exists_isInternal_prime_power_torsion","module":"Mathlib.Algebra.Module.DedekindDomain","initialProofState":"R : Type u\ninst✝⁵ : CommRing R\ninst✝⁴ : IsDomain R\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : IsDedekindDomain R\ninst✝ : Module.Finite R M\nhM : Module.IsTorsion R M\n⊢ Exists fun P => Exists fun x => Exists fun x_1 => Exists fun e => DirectSum.IsInternal fun p => Submodule.torsionBySet R M ↑(HPow.hPow (↑p) (e p))","decl":"/-- A finitely generated torsion module over a Dedekind domain is an internal direct sum of its\n`p i ^ e i`-torsion submodules for some prime ideals `p i` and numbers `e i`. -/\ntheorem exists_isInternal_prime_power_torsion [Module.Finite R M] (hM : Module.IsTorsion R M) :\n    ∃ (P : Finset <| Ideal R) (_ : DecidableEq P) (_ : ∀ p ∈ P, Prime p) (e : P → ℕ),\n      DirectSum.IsInternal fun p : P => torsionBySet R M (p ^ e p : Ideal R) := by\n  classical\n  exact ⟨_, _, fun p hp => prime_of_factor p (Multiset.mem_toFinset.mp hp), _,\n    isInternal_prime_power_torsion hM⟩\n\n"}
