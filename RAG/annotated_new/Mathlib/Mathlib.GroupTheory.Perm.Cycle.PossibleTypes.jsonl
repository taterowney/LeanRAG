{"name":"Equiv.Perm.exists_with_cycleType_iff","module":"Mathlib.GroupTheory.Perm.Cycle.PossibleTypes","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nm : Multiset Nat\n⊢ Iff (Exists fun g => Eq g.cycleType m) (And (LE.le m.sum (Fintype.card α)) (∀ (a : Nat), Membership.mem m a → LE.le 2 a))","decl":"/-- There are permutations with cycleType `m` if and only if\n  its sum is at most `Fintype.card α` and its members are at least 2. -/\ntheorem Equiv.Perm.exists_with_cycleType_iff {m : Multiset ℕ} :\n    (∃ g : Equiv.Perm α, g.cycleType = m) ↔\n      (m.sum ≤ Fintype.card α ∧ ∀ a ∈ m, 2 ≤ a) := by\n  constructor\n  · -- empty case\n    intro h\n    obtain ⟨g, hg⟩ := h\n    constructor\n    · rw [← hg, Equiv.Perm.sum_cycleType]\n      exact (Equiv.Perm.support g).card_le_univ\n    · intro a\n      rw [← hg]\n      exact Equiv.Perm.two_le_of_mem_cycleType\n  · rintro ⟨hc, h2c⟩\n    have hc' : m.toList.sum ≤ Fintype.card α := by\n      simp only [Multiset.sum_toList]\n      exact hc\n    obtain ⟨p, hp_length, hp_nodup, hp_disj⟩ := List.exists_pw_disjoint_with_card hc'\n    use List.prod (List.map (fun l => List.formPerm l) p)\n    have hp2 : ∀ x ∈ p, 2 ≤ x.length := by\n      intro x hx\n      apply h2c x.length\n      rw [← Multiset.mem_toList, ← hp_length, List.mem_map]\n      exact ⟨x, hx, rfl⟩\n    rw [Equiv.Perm.cycleType_eq _ rfl]\n    · -- lengths\n      rw [← Multiset.coe_toList m]\n      apply congr_arg\n      rw [List.map_map]; rw [← hp_length]\n      apply List.map_congr_left\n      intro x hx; simp only [Function.comp_apply]\n      rw [List.support_formPerm_of_nodup x (hp_nodup x hx)]\n      ·-- length\n        rw [List.toFinset_card_of_nodup (hp_nodup x hx)]\n      · -- length >= 1\n        intro a h\n        apply Nat.not_succ_le_self 1\n        conv_rhs => rw [← List.length_singleton a]; rw [← h]\n        exact hp2 x hx\n    · -- cycles\n      intro g\n      rw [List.mem_map]\n      rintro ⟨x, hx, rfl⟩\n      have hx_nodup : x.Nodup := hp_nodup x hx\n      rw [← Cycle.formPerm_coe x hx_nodup]\n      apply Cycle.isCycle_formPerm\n      rw [Cycle.nontrivial_coe_nodup_iff hx_nodup]\n      exact hp2 x hx\n    · -- disjoint\n      rw [List.pairwise_map]\n      apply List.Pairwise.imp_of_mem _ hp_disj\n      intro a b ha hb hab\n      rw [List.formPerm_disjoint_iff (hp_nodup a ha) (hp_nodup b hb) (hp2 a ha) (hp2 b hb)]\n      exact hab\n"}
