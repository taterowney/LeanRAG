{"name":"CategoryTheory.IsPreconnected.iso_constant","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nself : CategoryTheory.IsPreconnected J\nα : Type u₁\nF : CategoryTheory.Functor J (CategoryTheory.Discrete α)\nj : J\n⊢ Nonempty (CategoryTheory.Iso F ((CategoryTheory.Functor.const J).obj (F.obj j)))","decl":"/-- A possibly empty category for which every functor to a discrete category is constant.\n-/\nclass IsPreconnected (J : Type u₁) [Category.{v₁} J] : Prop where\n  iso_constant :\n    ∀ {α : Type u₁} (F : J ⥤ Discrete α) (j : J), Nonempty (F ≅ (Functor.const J).obj (F.obj j))\n\n"}
{"name":"CategoryTheory.IsConnected.is_nonempty","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nself : CategoryTheory.IsConnected J\n⊢ Nonempty J","decl":"/-- We define a connected category as a _nonempty_ category for which every\nfunctor to a discrete category is constant.\n\nNB. Some authors include the empty category as connected, we do not.\nWe instead are interested in categories with exactly one 'connected\ncomponent'.\n\nThis allows us to show that the functor X ⨯ - preserves connected limits. -/\n@[stacks 002S]\nclass IsConnected (J : Type u₁) [Category.{v₁} J] extends IsPreconnected J : Prop where\n  [is_nonempty : Nonempty J]\n\n"}
{"name":"CategoryTheory.IsConnected.toIsPreconnected","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nself : CategoryTheory.IsConnected J\n⊢ CategoryTheory.IsPreconnected J","decl":"/-- We define a connected category as a _nonempty_ category for which every\nfunctor to a discrete category is constant.\n\nNB. Some authors include the empty category as connected, we do not.\nWe instead are interested in categories with exactly one 'connected\ncomponent'.\n\nThis allows us to show that the functor X ⨯ - preserves connected limits. -/\n@[stacks 002S]\nclass IsConnected (J : Type u₁) [Category.{v₁} J] extends IsPreconnected J : Prop where\n  [is_nonempty : Nonempty J]\n\n"}
{"name":"CategoryTheory.any_functor_const_on_obj","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : CategoryTheory.IsPreconnected J\nα : Type u₂\nF : CategoryTheory.Functor J (CategoryTheory.Discrete α)\nj j' : J\n⊢ Eq (F.obj j) (F.obj j')","decl":"/-- If `J` is connected, any functor to a discrete category is constant on objects.\nThe converse is given in `IsConnected.of_any_functor_const_on_obj`.\n-/\ntheorem any_functor_const_on_obj [IsPreconnected J] {α : Type u₂} (F : J ⥤ Discrete α) (j j' : J) :\n    F.obj j = F.obj j' := by\n  ext; exact ((isoConstant F j').hom.app j).down.1\n\n"}
{"name":"CategoryTheory.IsPreconnected.of_any_functor_const_on_obj","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nh : ∀ {α : Type u₁} (F : CategoryTheory.Functor J (CategoryTheory.Discrete α)) (j j' : J), Eq (F.obj j) (F.obj j')\n⊢ CategoryTheory.IsPreconnected J","decl":"/-- If any functor to a discrete category is constant on objects, J is connected.\nThe converse of `any_functor_const_on_obj`.\n-/\ntheorem IsPreconnected.of_any_functor_const_on_obj\n    (h : ∀ {α : Type u₁} (F : J ⥤ Discrete α), ∀ j j' : J, F.obj j = F.obj j') :\n    IsPreconnected J where\n  iso_constant := fun F j' => ⟨NatIso.ofComponents fun j => eqToIso (h F j j')⟩\n\n"}
{"name":"CategoryTheory.IsPreconnected.prod","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} K\ninst✝¹ : CategoryTheory.IsPreconnected J\ninst✝ : CategoryTheory.IsPreconnected K\n⊢ CategoryTheory.IsPreconnected (Prod J K)","decl":"instance IsPreconnected.prod [IsPreconnected J] [IsPreconnected K] : IsPreconnected (J × K) := by\n  refine .of_any_functor_const_on_obj (fun {a} F ⟨j, k⟩ ⟨j', k'⟩ => ?_)\n  exact (any_functor_const_on_obj (Prod.sectL J k ⋙ F) j j').trans\n    (any_functor_const_on_obj (Prod.sectR j' K ⋙ F) k k')\n\n"}
{"name":"CategoryTheory.IsConnected.prod","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} K\ninst✝¹ : CategoryTheory.IsConnected J\ninst✝ : CategoryTheory.IsConnected K\n⊢ CategoryTheory.IsConnected (Prod J K)","decl":"instance IsConnected.prod [IsConnected J] [IsConnected K] : IsConnected (J × K) where\n\n"}
{"name":"CategoryTheory.IsConnected.of_any_functor_const_on_obj","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : Nonempty J\nh : ∀ {α : Type u₁} (F : CategoryTheory.Functor J (CategoryTheory.Discrete α)) (j j' : J), Eq (F.obj j) (F.obj j')\n⊢ CategoryTheory.IsConnected J","decl":"/-- If any functor to a discrete category is constant on objects, J is connected.\nThe converse of `any_functor_const_on_obj`.\n-/\ntheorem IsConnected.of_any_functor_const_on_obj [Nonempty J]\n    (h : ∀ {α : Type u₁} (F : J ⥤ Discrete α), ∀ j j' : J, F.obj j = F.obj j') : IsConnected J :=\n  { IsPreconnected.of_any_functor_const_on_obj h with }\n\n"}
{"name":"CategoryTheory.constant_of_preserves_morphisms","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : CategoryTheory.IsPreconnected J\nα : Type u₂\nF : J → α\nh : ∀ (j₁ j₂ : J), Quiver.Hom j₁ j₂ → Eq (F j₁) (F j₂)\nj j' : J\n⊢ Eq (F j) (F j')","decl":"/-- If `J` is connected, then given any function `F` such that the presence of a\nmorphism `j₁ ⟶ j₂` implies `F j₁ = F j₂`, we have that `F` is constant.\nThis can be thought of as a local-to-global property.\n\nThe converse is shown in `IsConnected.of_constant_of_preserves_morphisms`\n-/\ntheorem constant_of_preserves_morphisms [IsPreconnected J] {α : Type u₂} (F : J → α)\n    (h : ∀ (j₁ j₂ : J) (_ : j₁ ⟶ j₂), F j₁ = F j₂) (j j' : J) : F j = F j' := by\n  simpa using\n    any_functor_const_on_obj\n      { obj := Discrete.mk ∘ F\n        map := fun f => eqToHom (by ext; exact h _ _ f) }\n      j j'\n\n"}
{"name":"CategoryTheory.IsPreconnected.of_constant_of_preserves_morphisms","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nh : ∀ {α : Type u₁} (F : J → α), (∀ {j₁ j₂ : J}, Quiver.Hom j₁ j₂ → Eq (F j₁) (F j₂)) → ∀ (j j' : J), Eq (F j) (F j')\n⊢ CategoryTheory.IsPreconnected J","decl":"/-- `J` is connected if: given any function `F : J → α` which is constant for any\n`j₁, j₂` for which there is a morphism `j₁ ⟶ j₂`, then `F` is constant.\nThis can be thought of as a local-to-global property.\n\nThe converse of `constant_of_preserves_morphisms`.\n-/\ntheorem IsPreconnected.of_constant_of_preserves_morphisms\n    (h : ∀ {α : Type u₁} (F : J → α),\n      (∀ {j₁ j₂ : J} (_ : j₁ ⟶ j₂), F j₁ = F j₂) → ∀ j j' : J, F j = F j') :\n    IsPreconnected J :=\n  IsPreconnected.of_any_functor_const_on_obj fun F =>\n    h F.obj fun f => by ext; exact Discrete.eq_of_hom (F.map f)\n\n"}
{"name":"CategoryTheory.IsConnected.of_constant_of_preserves_morphisms","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : Nonempty J\nh : ∀ {α : Type u₁} (F : J → α), (∀ {j₁ j₂ : J}, Quiver.Hom j₁ j₂ → Eq (F j₁) (F j₂)) → ∀ (j j' : J), Eq (F j) (F j')\n⊢ CategoryTheory.IsConnected J","decl":"/-- `J` is connected if: given any function `F : J → α` which is constant for any\n`j₁, j₂` for which there is a morphism `j₁ ⟶ j₂`, then `F` is constant.\nThis can be thought of as a local-to-global property.\n\nThe converse of `constant_of_preserves_morphisms`.\n-/\ntheorem IsConnected.of_constant_of_preserves_morphisms [Nonempty J]\n    (h : ∀ {α : Type u₁} (F : J → α),\n      (∀ {j₁ j₂ : J} (_ : j₁ ⟶ j₂), F j₁ = F j₂) → ∀ j j' : J, F j = F j') :\n    IsConnected J :=\n  { IsPreconnected.of_constant_of_preserves_morphisms h with }\n\n"}
{"name":"CategoryTheory.induct_on_objects","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : CategoryTheory.IsPreconnected J\np : Set J\nj₀ : J\nh0 : Membership.mem p j₀\nh1 : ∀ {j₁ j₂ : J}, Quiver.Hom j₁ j₂ → Iff (Membership.mem p j₁) (Membership.mem p j₂)\nj : J\n⊢ Membership.mem p j","decl":"/-- An inductive-like property for the objects of a connected category.\nIf the set `p` is nonempty, and `p` is closed under morphisms of `J`,\nthen `p` contains all of `J`.\n\nThe converse is given in `IsConnected.of_induct`.\n-/\ntheorem induct_on_objects [IsPreconnected J] (p : Set J) {j₀ : J} (h0 : j₀ ∈ p)\n    (h1 : ∀ {j₁ j₂ : J} (_ : j₁ ⟶ j₂), j₁ ∈ p ↔ j₂ ∈ p) (j : J) : j ∈ p := by\n  let aux (j₁ j₂ : J) (f : j₁ ⟶ j₂) := congrArg ULift.up <| (h1 f).eq\n  injection constant_of_preserves_morphisms (fun k => ULift.up.{u₁} (k ∈ p)) aux j j₀ with i\n  rwa [i]\n\n"}
{"name":"CategoryTheory.IsConnected.of_induct","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj₀ : J\nh : ∀ (p : Set J), Membership.mem p j₀ → (∀ {j₁ j₂ : J}, Quiver.Hom j₁ j₂ → Iff (Membership.mem p j₁) (Membership.mem p j₂)) → ∀ (j : J), Membership.mem p j\n⊢ CategoryTheory.IsConnected J","decl":"/--\nIf any maximal connected component containing some element j₀ of J is all of J, then J is connected.\n\nThe converse of `induct_on_objects`.\n-/\ntheorem IsConnected.of_induct {j₀ : J}\n    (h : ∀ p : Set J, j₀ ∈ p → (∀ {j₁ j₂ : J} (_ : j₁ ⟶ j₂), j₁ ∈ p ↔ j₂ ∈ p) → ∀ j : J, j ∈ p) :\n    IsConnected J :=\n  have := Nonempty.intro j₀\n  IsConnected.of_constant_of_preserves_morphisms fun {α} F a => by\n    have w := h { j | F j = F j₀ } rfl (fun {j₁} {j₂} f => by\n      change F j₁ = F j₀ ↔ F j₂ = F j₀\n      simp [a f])\n    intro j j'\n    rw [w j, w j']\n\n"}
{"name":"CategoryTheory.instIsConnectedULiftHomULift","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nhc : CategoryTheory.IsConnected J\n⊢ CategoryTheory.IsConnected (CategoryTheory.ULiftHom (ULift.{u₂, u₁} J))","decl":"/-- Lifting the universe level of morphisms and objects preserves connectedness. -/\ninstance [hc : IsConnected J] : IsConnected (ULiftHom.{v₂} (ULift.{u₂} J)) := by\n  apply IsConnected.of_induct\n  · rintro p hj₀ h ⟨j⟩\n    let p' : Set J := {j : J | p ⟨j⟩}\n    have hj₀' : Classical.choice hc.is_nonempty ∈ p' := by\n      simp only [p', (eq_self p')]\n      exact hj₀\n    apply induct_on_objects p' hj₀' fun f => h ((ULiftHomULiftCategory.equiv J).functor.map f)\n\n"}
{"name":"CategoryTheory.isPreconnected_induction","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : CategoryTheory.IsPreconnected J\nZ : J → Sort u_1\nh₁ : {j₁ j₂ : J} → Quiver.Hom j₁ j₂ → Z j₁ → Z j₂\nh₂ : {j₁ j₂ : J} → Quiver.Hom j₁ j₂ → Z j₂ → Z j₁\nj₀ : J\nx : Z j₀\nj : J\n⊢ Nonempty (Z j)","decl":"/-- Another induction principle for `IsPreconnected J`:\ngiven a type family `Z : J → Sort*` and\na rule for transporting in *both* directions along a morphism in `J`,\nwe can transport an `x : Z j₀` to a point in `Z j` for any `j`.\n-/\ntheorem isPreconnected_induction [IsPreconnected J] (Z : J → Sort*)\n    (h₁ : ∀ {j₁ j₂ : J} (_ : j₁ ⟶ j₂), Z j₁ → Z j₂) (h₂ : ∀ {j₁ j₂ : J} (_ : j₁ ⟶ j₂), Z j₂ → Z j₁)\n    {j₀ : J} (x : Z j₀) (j : J) : Nonempty (Z j) :=\n  (induct_on_objects { j | Nonempty (Z j) } ⟨x⟩\n      (fun f => ⟨by rintro ⟨y⟩; exact ⟨h₁ f y⟩, by rintro ⟨y⟩; exact ⟨h₂ f y⟩⟩)\n      j :)\n\n"}
{"name":"CategoryTheory.isPreconnected_of_equivalent","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.IsPreconnected J\ne : CategoryTheory.Equivalence J K\n⊢ CategoryTheory.IsPreconnected K","decl":"/-- If `J` and `K` are equivalent, then if `J` is preconnected then `K` is as well. -/\ntheorem isPreconnected_of_equivalent {K : Type u₂} [Category.{v₂} K] [IsPreconnected J]\n    (e : J ≌ K) : IsPreconnected K where\n  iso_constant F k :=\n    ⟨calc\n        F ≅ e.inverse ⋙ e.functor ⋙ F := (e.invFunIdAssoc F).symm\n        _ ≅ e.inverse ⋙ (Functor.const J).obj ((e.functor ⋙ F).obj (e.inverse.obj k)) :=\n          isoWhiskerLeft e.inverse (isoConstant (e.functor ⋙ F) (e.inverse.obj k))\n        _ ≅ e.inverse ⋙ (Functor.const J).obj (F.obj k) :=\n          isoWhiskerLeft _ ((F ⋙ Functor.const J).mapIso (e.counitIso.app k))\n        _ ≅ (Functor.const K).obj (F.obj k) := NatIso.ofComponents fun _ => Iso.refl _⟩\n\n"}
{"name":"CategoryTheory.isPreconnected_iff_of_equivalence","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} K\ne : CategoryTheory.Equivalence J K\n⊢ Iff (CategoryTheory.IsPreconnected J) (CategoryTheory.IsPreconnected K)","decl":"lemma isPreconnected_iff_of_equivalence {K : Type u₂} [Category.{v₂} K] (e : J ≌ K) :\n    IsPreconnected J ↔ IsPreconnected K :=\n  ⟨fun _ => isPreconnected_of_equivalent e, fun _ => isPreconnected_of_equivalent e.symm⟩\n\n"}
{"name":"CategoryTheory.isConnected_of_equivalent","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ne : CategoryTheory.Equivalence J K\ninst✝ : CategoryTheory.IsConnected J\n⊢ CategoryTheory.IsConnected K","decl":"/-- If `J` and `K` are equivalent, then if `J` is connected then `K` is as well. -/\ntheorem isConnected_of_equivalent {K : Type u₂} [Category.{v₂} K] (e : J ≌ K) [IsConnected J] :\n    IsConnected K :=\n  { is_nonempty := Nonempty.map e.functor.obj (by infer_instance)\n    toIsPreconnected := isPreconnected_of_equivalent e }\n\n"}
{"name":"CategoryTheory.isConnected_iff_of_equivalence","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} K\ne : CategoryTheory.Equivalence J K\n⊢ Iff (CategoryTheory.IsConnected J) (CategoryTheory.IsConnected K)","decl":"lemma isConnected_iff_of_equivalence {K : Type u₂} [Category.{v₂} K] (e : J ≌ K) :\n    IsConnected J ↔ IsConnected K :=\n  ⟨fun _ => isConnected_of_equivalent e, fun _ => isConnected_of_equivalent e.symm⟩\n\n"}
{"name":"CategoryTheory.isPreconnected_op","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : CategoryTheory.IsPreconnected J\n⊢ CategoryTheory.IsPreconnected (Opposite J)","decl":"/-- If `J` is preconnected, then `Jᵒᵖ` is preconnected as well. -/\ninstance isPreconnected_op [IsPreconnected J] : IsPreconnected Jᵒᵖ where\n  iso_constant := fun {α} F X =>\n    ⟨NatIso.ofComponents fun Y =>\n      eqToIso (Discrete.ext (Discrete.eq_of_hom ((Nonempty.some\n        (IsPreconnected.iso_constant (F.rightOp ⋙ (Discrete.opposite α).functor) (unop X))).app\n          (unop Y)).hom))⟩\n\n"}
{"name":"CategoryTheory.isConnected_op","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : CategoryTheory.IsConnected J\n⊢ CategoryTheory.IsConnected (Opposite J)","decl":"/-- If `J` is connected, then `Jᵒᵖ` is connected as well. -/\ninstance isConnected_op [IsConnected J] : IsConnected Jᵒᵖ where\n  is_nonempty := Nonempty.intro (op (Classical.arbitrary J))\n\n"}
{"name":"CategoryTheory.isPreconnected_of_isPreconnected_op","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : CategoryTheory.IsPreconnected (Opposite J)\n⊢ CategoryTheory.IsPreconnected J","decl":"theorem isPreconnected_of_isPreconnected_op [IsPreconnected Jᵒᵖ] : IsPreconnected J :=\n  isPreconnected_of_equivalent (opOpEquivalence J)\n\n"}
{"name":"CategoryTheory.isConnected_of_isConnected_op","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : CategoryTheory.IsConnected (Opposite J)\n⊢ CategoryTheory.IsConnected J","decl":"theorem isConnected_of_isConnected_op [IsConnected Jᵒᵖ] : IsConnected J :=\n  isConnected_of_equivalent (opOpEquivalence J)\n\n"}
{"name":"CategoryTheory.isConnected_op_iff_isConnected","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\n⊢ Iff (CategoryTheory.IsConnected (Opposite J)) (CategoryTheory.IsConnected J)","decl":"variable (J) in\n@[simp]\ntheorem isConnected_op_iff_isConnected : IsConnected Jᵒᵖ ↔ IsConnected J :=\n  ⟨fun _ => isConnected_of_isConnected_op, fun _ => isConnected_op⟩\n\n"}
{"name":"CategoryTheory.Zag.refl","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nX : J\n⊢ CategoryTheory.Zag X X","decl":"@[refl] theorem Zag.refl (X : J) : Zag X X := Or.inl ⟨𝟙 _⟩\n\n"}
{"name":"CategoryTheory.zag_symmetric","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\n⊢ Symmetric CategoryTheory.Zag","decl":"theorem zag_symmetric : Symmetric (@Zag J _) := fun _ _ h => h.symm\n\n"}
{"name":"CategoryTheory.Zag.symm","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj₁ j₂ : J\nh : CategoryTheory.Zag j₁ j₂\n⊢ CategoryTheory.Zag j₂ j₁","decl":"@[symm] theorem Zag.symm {j₁ j₂ : J} (h : Zag j₁ j₂) : Zag j₂ j₁ := zag_symmetric h\n\n"}
{"name":"CategoryTheory.Zag.of_hom","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj₁ j₂ : J\nf : Quiver.Hom j₁ j₂\n⊢ CategoryTheory.Zag j₁ j₂","decl":"theorem Zag.of_hom {j₁ j₂ : J} (f : j₁ ⟶ j₂) : Zag j₁ j₂ := Or.inl ⟨f⟩\n\n"}
{"name":"CategoryTheory.Zag.of_inv","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj₁ j₂ : J\nf : Quiver.Hom j₂ j₁\n⊢ CategoryTheory.Zag j₁ j₂","decl":"theorem Zag.of_inv {j₁ j₂ : J} (f : j₂ ⟶ j₁) : Zag j₁ j₂ := Or.inr ⟨f⟩\n\n"}
{"name":"CategoryTheory.zigzag_symmetric","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\n⊢ Symmetric CategoryTheory.Zigzag","decl":"theorem zigzag_symmetric : Symmetric (@Zigzag J _) :=\n  Relation.ReflTransGen.symmetric zag_symmetric\n\n"}
{"name":"CategoryTheory.zigzag_equivalence","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\n⊢ Equivalence CategoryTheory.Zigzag","decl":"theorem zigzag_equivalence : _root_.Equivalence (@Zigzag J _) :=\n  _root_.Equivalence.mk Relation.reflexive_reflTransGen (fun h => zigzag_symmetric h)\n  (fun h g => Relation.transitive_reflTransGen h g)\n\n"}
{"name":"CategoryTheory.Zigzag.refl","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nX : J\n⊢ CategoryTheory.Zigzag X X","decl":"@[refl] theorem Zigzag.refl (X : J) : Zigzag X X := zigzag_equivalence.refl _\n\n"}
{"name":"CategoryTheory.Zigzag.symm","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj₁ j₂ : J\nh : CategoryTheory.Zigzag j₁ j₂\n⊢ CategoryTheory.Zigzag j₂ j₁","decl":"@[symm] theorem Zigzag.symm {j₁ j₂ : J} (h : Zigzag j₁ j₂) : Zigzag j₂ j₁ := zigzag_symmetric h\n\n"}
{"name":"CategoryTheory.Zigzag.trans","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj₁ j₂ j₃ : J\nh₁ : CategoryTheory.Zigzag j₁ j₂\nh₂ : CategoryTheory.Zigzag j₂ j₃\n⊢ CategoryTheory.Zigzag j₁ j₃","decl":"@[trans] theorem Zigzag.trans {j₁ j₂ j₃ : J} (h₁ : Zigzag j₁ j₂) (h₂ : Zigzag j₂ j₃) :\n    Zigzag j₁ j₃ :=\n  zigzag_equivalence.trans h₁ h₂\n\n"}
{"name":"CategoryTheory.Zigzag.of_zag","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj₁ j₂ : J\nh : CategoryTheory.Zag j₁ j₂\n⊢ CategoryTheory.Zigzag j₁ j₂","decl":"theorem Zigzag.of_zag {j₁ j₂ : J} (h : Zag j₁ j₂) : Zigzag j₁ j₂ :=\n  Relation.ReflTransGen.single h\n\n"}
{"name":"CategoryTheory.Zigzag.of_hom","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj₁ j₂ : J\nf : Quiver.Hom j₁ j₂\n⊢ CategoryTheory.Zigzag j₁ j₂","decl":"theorem Zigzag.of_hom {j₁ j₂ : J} (f : j₁ ⟶ j₂) : Zigzag j₁ j₂ :=\n  of_zag (Zag.of_hom f)\n\n"}
{"name":"CategoryTheory.Zigzag.of_inv","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj₁ j₂ : J\nf : Quiver.Hom j₂ j₁\n⊢ CategoryTheory.Zigzag j₁ j₂","decl":"theorem Zigzag.of_inv {j₁ j₂ : J} (f : j₂ ⟶ j₁) : Zigzag j₁ j₂ :=\n  of_zag (Zag.of_inv f)\n\n"}
{"name":"CategoryTheory.Zigzag.of_zag_trans","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj₁ j₂ j₃ : J\nh₁ : CategoryTheory.Zag j₁ j₂\nh₂ : CategoryTheory.Zag j₂ j₃\n⊢ CategoryTheory.Zigzag j₁ j₃","decl":"theorem Zigzag.of_zag_trans {j₁ j₂ j₃ : J} (h₁ : Zag j₁ j₂) (h₂ : Zag j₂ j₃) : Zigzag j₁ j₃ :=\n  trans (of_zag h₁) (of_zag h₂)\n\n"}
{"name":"CategoryTheory.Zigzag.of_hom_hom","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj₁ j₂ j₃ : J\nf₁₂ : Quiver.Hom j₁ j₂\nf₂₃ : Quiver.Hom j₂ j₃\n⊢ CategoryTheory.Zigzag j₁ j₃","decl":"theorem Zigzag.of_hom_hom {j₁ j₂ j₃ : J} (f₁₂ : j₁ ⟶ j₂) (f₂₃ : j₂ ⟶ j₃) : Zigzag j₁ j₃ :=\n  (of_hom f₁₂).trans (of_hom f₂₃)\n\n"}
{"name":"CategoryTheory.Zigzag.of_hom_inv","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj₁ j₂ j₃ : J\nf₁₂ : Quiver.Hom j₁ j₂\nf₃₂ : Quiver.Hom j₃ j₂\n⊢ CategoryTheory.Zigzag j₁ j₃","decl":"theorem Zigzag.of_hom_inv {j₁ j₂ j₃ : J} (f₁₂ : j₁ ⟶ j₂) (f₃₂ : j₃ ⟶ j₂) : Zigzag j₁ j₃ :=\n  (of_hom f₁₂).trans (of_inv f₃₂)\n\n"}
{"name":"CategoryTheory.Zigzag.of_inv_hom","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj₁ j₂ j₃ : J\nf₂₁ : Quiver.Hom j₂ j₁\nf₂₃ : Quiver.Hom j₂ j₃\n⊢ CategoryTheory.Zigzag j₁ j₃","decl":"theorem Zigzag.of_inv_hom {j₁ j₂ j₃ : J} (f₂₁ : j₂ ⟶ j₁) (f₂₃ : j₂ ⟶ j₃) : Zigzag j₁ j₃ :=\n  (of_inv f₂₁).trans (of_hom f₂₃)\n\n"}
{"name":"CategoryTheory.Zigzag.of_inv_inv","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj₁ j₂ j₃ : J\nf₂₁ : Quiver.Hom j₂ j₁\nf₃₂ : Quiver.Hom j₃ j₂\n⊢ CategoryTheory.Zigzag j₁ j₃","decl":"theorem Zigzag.of_inv_inv {j₁ j₂ j₃ : J} (f₂₁ : j₂ ⟶ j₁) (f₃₂ : j₃ ⟶ j₂) : Zigzag j₁ j₃ :=\n  (of_inv f₂₁).trans (of_inv f₃₂)\n\n"}
{"name":"CategoryTheory.zigzag_prefunctor_obj_of_zigzag","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} K\nF : Prefunctor J K\nj₁ j₂ : J\nh : CategoryTheory.Zigzag j₁ j₂\n⊢ CategoryTheory.Zigzag (F.obj j₁) (F.obj j₂)","decl":"/-- If there is a zigzag from `j₁` to `j₂`, then there is a zigzag from `F j₁` to\n`F j₂` as long as `F` is a prefunctor.\n-/\ntheorem zigzag_prefunctor_obj_of_zigzag (F : J ⥤q K) {j₁ j₂ : J} (h : Zigzag j₁ j₂) :\n    Zigzag (F.obj j₁) (F.obj j₂) :=\n  h.lift _ fun _ _ => Or.imp (Nonempty.map fun f => F.map f) (Nonempty.map fun f => F.map f)\n\n"}
{"name":"CategoryTheory.zigzag_obj_of_zigzag","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J K\nj₁ j₂ : J\nh : CategoryTheory.Zigzag j₁ j₂\n⊢ CategoryTheory.Zigzag (F.obj j₁) (F.obj j₂)","decl":"/-- If there is a zigzag from `j₁` to `j₂`, then there is a zigzag from `F j₁` to\n`F j₂` as long as `F` is a functor.\n-/\ntheorem zigzag_obj_of_zigzag (F : J ⥤ K) {j₁ j₂ : J} (h : Zigzag j₁ j₂) :\n    Zigzag (F.obj j₁) (F.obj j₂) :=\n  zigzag_prefunctor_obj_of_zigzag F.toPrefunctor h\n\n"}
{"name":"CategoryTheory.eq_of_zag","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"X : Type u_1\na b : CategoryTheory.Discrete X\nh : CategoryTheory.Zag a b\n⊢ Eq a.as b.as","decl":"/-- A Zag in a discrete category entails an equality of its extremities -/\nlemma eq_of_zag (X) {a b : Discrete X} (h : Zag a b) : a.as = b.as :=\n  h.elim (fun ⟨f⟩ ↦ Discrete.eq_of_hom f) (fun ⟨f⟩ ↦ (Discrete.eq_of_hom f).symm)\n\n"}
{"name":"CategoryTheory.eq_of_zigzag","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"X : Type u_1\na b : CategoryTheory.Discrete X\nh : CategoryTheory.Zigzag a b\n⊢ Eq a.as b.as","decl":"/-- A zigzag in a discrete category entails an equality of its extremities -/\nlemma eq_of_zigzag (X) {a b : Discrete X} (h : Zigzag a b) : a.as = b.as := by\n  induction h with\n  | refl => rfl\n  | tail _ h eq  => exact eq.trans (eq_of_zag _ h)\n\n-- TODO: figure out the right way to generalise this to `Zigzag`.\n"}
{"name":"CategoryTheory.zag_of_zag_obj","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J K\ninst✝ : F.Full\nj₁ j₂ : J\nh : CategoryTheory.Zag (F.obj j₁) (F.obj j₂)\n⊢ CategoryTheory.Zag j₁ j₂","decl":"theorem zag_of_zag_obj (F : J ⥤ K) [F.Full] {j₁ j₂ : J} (h : Zag (F.obj j₁) (F.obj j₂)) :\n    Zag j₁ j₂ :=\n  Or.imp (Nonempty.map F.preimage) (Nonempty.map F.preimage) h\n\n"}
{"name":"CategoryTheory.equiv_relation","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : CategoryTheory.IsPreconnected J\nr : J → J → Prop\nhr : Equivalence r\nh : ∀ {j₁ j₂ : J}, Quiver.Hom j₁ j₂ → r j₁ j₂\nj₁ j₂ : J\n⊢ r j₁ j₂","decl":"/-- Any equivalence relation containing (⟶) holds for all pairs of a connected category. -/\ntheorem equiv_relation [IsPreconnected J] (r : J → J → Prop) (hr : _root_.Equivalence r)\n    (h : ∀ {j₁ j₂ : J} (_ : j₁ ⟶ j₂), r j₁ j₂) : ∀ j₁ j₂ : J, r j₁ j₂ := by\n  intros j₁ j₂\n  have z : ∀ j : J, r j₁ j :=\n    induct_on_objects {k | r j₁ k} (hr.1 j₁)\n      fun f => ⟨fun t => hr.3 t (h f), fun t => hr.3 t (hr.2 (h f))⟩\n  exact z j₂\n\n"}
{"name":"CategoryTheory.isPreconnected_zigzag","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : CategoryTheory.IsPreconnected J\nj₁ j₂ : J\n⊢ CategoryTheory.Zigzag j₁ j₂","decl":"/-- In a connected category, any two objects are related by `Zigzag`. -/\ntheorem isPreconnected_zigzag [IsPreconnected J] (j₁ j₂ : J) : Zigzag j₁ j₂ :=\n  equiv_relation _ zigzag_equivalence\n    (fun f => Relation.ReflTransGen.single (Or.inl (Nonempty.intro f))) _ _\n\n\n"}
{"name":"CategoryTheory.zigzag_isPreconnected","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nh : ∀ (j₁ j₂ : J), CategoryTheory.Zigzag j₁ j₂\n⊢ CategoryTheory.IsPreconnected J","decl":"theorem zigzag_isPreconnected (h : ∀ j₁ j₂ : J, Zigzag j₁ j₂) : IsPreconnected J := by\n  apply IsPreconnected.of_constant_of_preserves_morphisms\n  intro α F hF j j'\n  specialize h j j'\n  induction' h with j₁ j₂ _ hj ih\n  · rfl\n  · rw [ih]\n    rcases hj with (⟨⟨hj⟩⟩|⟨⟨hj⟩⟩)\n    exacts [hF hj, (hF hj).symm]\n\n"}
{"name":"CategoryTheory.zigzag_isConnected","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : Nonempty J\nh : ∀ (j₁ j₂ : J), CategoryTheory.Zigzag j₁ j₂\n⊢ CategoryTheory.IsConnected J","decl":"/-- If any two objects in a nonempty category are related by `Zigzag`, the category is connected.\n-/\ntheorem zigzag_isConnected [Nonempty J] (h : ∀ j₁ j₂ : J, Zigzag j₁ j₂) : IsConnected J :=\n  { zigzag_isPreconnected h with }\n\n"}
{"name":"CategoryTheory.exists_zigzag'","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : CategoryTheory.IsConnected J\nj₁ j₂ : J\n⊢ Exists fun l => And (List.Chain CategoryTheory.Zag j₁ l) (Eq ((List.cons j₁ l).getLast ⋯) j₂)","decl":"theorem exists_zigzag' [IsConnected J] (j₁ j₂ : J) :\n    ∃ l, List.Chain Zag j₁ l ∧ List.getLast (j₁ :: l) (List.cons_ne_nil _ _) = j₂ :=\n  List.exists_chain_of_relationReflTransGen (isPreconnected_zigzag _ _)\n\n"}
{"name":"CategoryTheory.isPreconnected_of_zigzag","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nh : ∀ (j₁ j₂ : J), Exists fun l => And (List.Chain CategoryTheory.Zag j₁ l) (Eq ((List.cons j₁ l).getLast ⋯) j₂)\n⊢ CategoryTheory.IsPreconnected J","decl":"/-- If any two objects in a nonempty category are linked by a sequence of (potentially reversed)\nmorphisms, then J is connected.\n\nThe converse of `exists_zigzag'`.\n-/\ntheorem isPreconnected_of_zigzag (h : ∀ j₁ j₂ : J, ∃ l,\n    List.Chain Zag j₁ l ∧ List.getLast (j₁ :: l) (List.cons_ne_nil _ _) = j₂) :\n    IsPreconnected J := by\n  apply zigzag_isPreconnected\n  intro j₁ j₂\n  rcases h j₁ j₂ with ⟨l, hl₁, hl₂⟩\n  apply List.relationReflTransGen_of_exists_chain l hl₁ hl₂\n\n"}
{"name":"CategoryTheory.isConnected_of_zigzag","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : Nonempty J\nh : ∀ (j₁ j₂ : J), Exists fun l => And (List.Chain CategoryTheory.Zag j₁ l) (Eq ((List.cons j₁ l).getLast ⋯) j₂)\n⊢ CategoryTheory.IsConnected J","decl":"/-- If any two objects in a nonempty category are linked by a sequence of (potentially reversed)\nmorphisms, then J is connected.\n\nThe converse of `exists_zigzag'`.\n-/\ntheorem isConnected_of_zigzag [Nonempty J] (h : ∀ j₁ j₂ : J, ∃ l,\n    List.Chain Zag j₁ l ∧ List.getLast (j₁ :: l) (List.cons_ne_nil _ _) = j₂) :\n    IsConnected J :=\n  { isPreconnected_of_zigzag h with }\n\n"}
{"name":"CategoryTheory.nat_trans_from_is_connected","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type w₂\ninst✝¹ : CategoryTheory.Category.{w₁, w₂} C\ninst✝ : CategoryTheory.IsPreconnected J\nX Y : C\nα : Quiver.Hom ((CategoryTheory.Functor.const J).obj X) ((CategoryTheory.Functor.const J).obj Y)\nj j' : J\n⊢ Eq (α.app j) (α.app j')","decl":"/-- For objects `X Y : C`, any natural transformation `α : const X ⟶ const Y` from a connected\ncategory must be constant.\nThis is the key property of connected categories which we use to establish properties about limits.\n-/\ntheorem nat_trans_from_is_connected [IsPreconnected J] {X Y : C}\n    (α : (Functor.const J).obj X ⟶ (Functor.const J).obj Y) :\n    ∀ j j' : J, α.app j = (α.app j' : X ⟶ Y) :=\n  @constant_of_preserves_morphisms _ _ _ (X ⟶ Y) (fun j => α.app j) fun _ _ f => by\n    have := α.naturality f\n    erw [id_comp, comp_id] at this\n    exact this.symm\n\n"}
{"name":"CategoryTheory.instFullFunctorConstOfIsConnected","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type w₂\ninst✝¹ : CategoryTheory.Category.{w₁, w₂} C\ninst✝ : CategoryTheory.IsConnected J\n⊢ (CategoryTheory.Functor.const J).Full","decl":"instance [IsConnected J] : (Functor.const J : C ⥤ J ⥤ C).Full where\n  map_surjective f := ⟨f.app (Classical.arbitrary J), by\n    ext j\n    apply nat_trans_from_is_connected f (Classical.arbitrary J) j⟩\n\n"}
{"name":"CategoryTheory.nonempty_hom_of_preconnected_groupoid","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"G : Type u_1\ninst✝¹ : CategoryTheory.Groupoid G\ninst✝ : CategoryTheory.IsPreconnected G\nx y : G\n⊢ Nonempty (Quiver.Hom x y)","decl":"theorem nonempty_hom_of_preconnected_groupoid {G} [Groupoid G] [IsPreconnected G] :\n    ∀ x y : G, Nonempty (x ⟶ y) := by\n  refine equiv_relation _ ?_ fun {j₁ j₂} => Nonempty.intro\n  exact\n    ⟨fun j => ⟨𝟙 _⟩,\n     fun {j₁ j₂} => Nonempty.map fun f => inv f,\n     fun {_ _ _} => Nonempty.map2 (· ≫ ·)⟩\n\n"}
