{"name":"CategoryTheory.IsPreconnected.iso_constant","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nself : CategoryTheory.IsPreconnected J\nŒ± : Type u‚ÇÅ\nF : CategoryTheory.Functor J (CategoryTheory.Discrete Œ±)\nj : J\n‚ä¢ Nonempty (CategoryTheory.Iso F ((CategoryTheory.Functor.const J).obj (F.obj j)))","decl":"/-- A possibly empty category for which every functor to a discrete category is constant.\n-/\nclass IsPreconnected (J : Type u‚ÇÅ) [Category.{v‚ÇÅ} J] : Prop where\n  iso_constant :\n    ‚àÄ {Œ± : Type u‚ÇÅ} (F : J ‚•§ Discrete Œ±) (j : J), Nonempty (F ‚âÖ (Functor.const J).obj (F.obj j))\n\n"}
{"name":"CategoryTheory.IsConnected.is_nonempty","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nself : CategoryTheory.IsConnected J\n‚ä¢ Nonempty J","decl":"/-- We define a connected category as a _nonempty_ category for which every\nfunctor to a discrete category is constant.\n\nNB. Some authors include the empty category as connected, we do not.\nWe instead are interested in categories with exactly one 'connected\ncomponent'.\n\nThis allows us to show that the functor X ‚®Ø - preserves connected limits. -/\n@[stacks 002S]\nclass IsConnected (J : Type u‚ÇÅ) [Category.{v‚ÇÅ} J] extends IsPreconnected J : Prop where\n  [is_nonempty : Nonempty J]\n\n"}
{"name":"CategoryTheory.IsConnected.toIsPreconnected","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nself : CategoryTheory.IsConnected J\n‚ä¢ CategoryTheory.IsPreconnected J","decl":"/-- We define a connected category as a _nonempty_ category for which every\nfunctor to a discrete category is constant.\n\nNB. Some authors include the empty category as connected, we do not.\nWe instead are interested in categories with exactly one 'connected\ncomponent'.\n\nThis allows us to show that the functor X ‚®Ø - preserves connected limits. -/\n@[stacks 002S]\nclass IsConnected (J : Type u‚ÇÅ) [Category.{v‚ÇÅ} J] extends IsPreconnected J : Prop where\n  [is_nonempty : Nonempty J]\n\n"}
{"name":"CategoryTheory.any_functor_const_on_obj","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\ninst‚úù : CategoryTheory.IsPreconnected J\nŒ± : Type u‚ÇÇ\nF : CategoryTheory.Functor J (CategoryTheory.Discrete Œ±)\nj j' : J\n‚ä¢ Eq (F.obj j) (F.obj j')","decl":"/-- If `J` is connected, any functor to a discrete category is constant on objects.\nThe converse is given in `IsConnected.of_any_functor_const_on_obj`.\n-/\ntheorem any_functor_const_on_obj [IsPreconnected J] {Œ± : Type u‚ÇÇ} (F : J ‚•§ Discrete Œ±) (j j' : J) :\n    F.obj j = F.obj j' := by\n  ext; exact ((isoConstant F j').hom.app j).down.1\n\n"}
{"name":"CategoryTheory.IsPreconnected.of_any_functor_const_on_obj","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nh : ‚àÄ {Œ± : Type u‚ÇÅ} (F : CategoryTheory.Functor J (CategoryTheory.Discrete Œ±)) (j j' : J), Eq (F.obj j) (F.obj j')\n‚ä¢ CategoryTheory.IsPreconnected J","decl":"/-- If any functor to a discrete category is constant on objects, J is connected.\nThe converse of `any_functor_const_on_obj`.\n-/\ntheorem IsPreconnected.of_any_functor_const_on_obj\n    (h : ‚àÄ {Œ± : Type u‚ÇÅ} (F : J ‚•§ Discrete Œ±), ‚àÄ j j' : J, F.obj j = F.obj j') :\n    IsPreconnected J where\n  iso_constant := fun F j' => ‚ü®NatIso.ofComponents fun j => eqToIso (h F j j')‚ü©\n\n"}
{"name":"CategoryTheory.IsPreconnected.prod","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\ninst‚úù¬π : CategoryTheory.IsPreconnected J\ninst‚úù : CategoryTheory.IsPreconnected K\n‚ä¢ CategoryTheory.IsPreconnected (Prod J K)","decl":"instance IsPreconnected.prod [IsPreconnected J] [IsPreconnected K] : IsPreconnected (J √ó K) := by\n  refine .of_any_functor_const_on_obj (fun {a} F ‚ü®j, k‚ü© ‚ü®j', k'‚ü© => ?_)\n  exact (any_functor_const_on_obj (Prod.sectL J k ‚ãô F) j j').trans\n    (any_functor_const_on_obj (Prod.sectR j' K ‚ãô F) k k')\n\n"}
{"name":"CategoryTheory.IsConnected.prod","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\ninst‚úù¬π : CategoryTheory.IsConnected J\ninst‚úù : CategoryTheory.IsConnected K\n‚ä¢ CategoryTheory.IsConnected (Prod J K)","decl":"instance IsConnected.prod [IsConnected J] [IsConnected K] : IsConnected (J √ó K) where\n\n"}
{"name":"CategoryTheory.IsConnected.of_any_functor_const_on_obj","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\ninst‚úù : Nonempty J\nh : ‚àÄ {Œ± : Type u‚ÇÅ} (F : CategoryTheory.Functor J (CategoryTheory.Discrete Œ±)) (j j' : J), Eq (F.obj j) (F.obj j')\n‚ä¢ CategoryTheory.IsConnected J","decl":"/-- If any functor to a discrete category is constant on objects, J is connected.\nThe converse of `any_functor_const_on_obj`.\n-/\ntheorem IsConnected.of_any_functor_const_on_obj [Nonempty J]\n    (h : ‚àÄ {Œ± : Type u‚ÇÅ} (F : J ‚•§ Discrete Œ±), ‚àÄ j j' : J, F.obj j = F.obj j') : IsConnected J :=\n  { IsPreconnected.of_any_functor_const_on_obj h with }\n\n"}
{"name":"CategoryTheory.constant_of_preserves_morphisms","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\ninst‚úù : CategoryTheory.IsPreconnected J\nŒ± : Type u‚ÇÇ\nF : J ‚Üí Œ±\nh : ‚àÄ (j‚ÇÅ j‚ÇÇ : J), Quiver.Hom j‚ÇÅ j‚ÇÇ ‚Üí Eq (F j‚ÇÅ) (F j‚ÇÇ)\nj j' : J\n‚ä¢ Eq (F j) (F j')","decl":"/-- If `J` is connected, then given any function `F` such that the presence of a\nmorphism `j‚ÇÅ ‚ü∂ j‚ÇÇ` implies `F j‚ÇÅ = F j‚ÇÇ`, we have that `F` is constant.\nThis can be thought of as a local-to-global property.\n\nThe converse is shown in `IsConnected.of_constant_of_preserves_morphisms`\n-/\ntheorem constant_of_preserves_morphisms [IsPreconnected J] {Œ± : Type u‚ÇÇ} (F : J ‚Üí Œ±)\n    (h : ‚àÄ (j‚ÇÅ j‚ÇÇ : J) (_ : j‚ÇÅ ‚ü∂ j‚ÇÇ), F j‚ÇÅ = F j‚ÇÇ) (j j' : J) : F j = F j' := by\n  simpa using\n    any_functor_const_on_obj\n      { obj := Discrete.mk ‚àò F\n        map := fun f => eqToHom (by ext; exact h _ _ f) }\n      j j'\n\n"}
{"name":"CategoryTheory.IsPreconnected.of_constant_of_preserves_morphisms","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nh : ‚àÄ {Œ± : Type u‚ÇÅ} (F : J ‚Üí Œ±), (‚àÄ {j‚ÇÅ j‚ÇÇ : J}, Quiver.Hom j‚ÇÅ j‚ÇÇ ‚Üí Eq (F j‚ÇÅ) (F j‚ÇÇ)) ‚Üí ‚àÄ (j j' : J), Eq (F j) (F j')\n‚ä¢ CategoryTheory.IsPreconnected J","decl":"/-- `J` is connected if: given any function `F : J ‚Üí Œ±` which is constant for any\n`j‚ÇÅ, j‚ÇÇ` for which there is a morphism `j‚ÇÅ ‚ü∂ j‚ÇÇ`, then `F` is constant.\nThis can be thought of as a local-to-global property.\n\nThe converse of `constant_of_preserves_morphisms`.\n-/\ntheorem IsPreconnected.of_constant_of_preserves_morphisms\n    (h : ‚àÄ {Œ± : Type u‚ÇÅ} (F : J ‚Üí Œ±),\n      (‚àÄ {j‚ÇÅ j‚ÇÇ : J} (_ : j‚ÇÅ ‚ü∂ j‚ÇÇ), F j‚ÇÅ = F j‚ÇÇ) ‚Üí ‚àÄ j j' : J, F j = F j') :\n    IsPreconnected J :=\n  IsPreconnected.of_any_functor_const_on_obj fun F =>\n    h F.obj fun f => by ext; exact Discrete.eq_of_hom (F.map f)\n\n"}
{"name":"CategoryTheory.IsConnected.of_constant_of_preserves_morphisms","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\ninst‚úù : Nonempty J\nh : ‚àÄ {Œ± : Type u‚ÇÅ} (F : J ‚Üí Œ±), (‚àÄ {j‚ÇÅ j‚ÇÇ : J}, Quiver.Hom j‚ÇÅ j‚ÇÇ ‚Üí Eq (F j‚ÇÅ) (F j‚ÇÇ)) ‚Üí ‚àÄ (j j' : J), Eq (F j) (F j')\n‚ä¢ CategoryTheory.IsConnected J","decl":"/-- `J` is connected if: given any function `F : J ‚Üí Œ±` which is constant for any\n`j‚ÇÅ, j‚ÇÇ` for which there is a morphism `j‚ÇÅ ‚ü∂ j‚ÇÇ`, then `F` is constant.\nThis can be thought of as a local-to-global property.\n\nThe converse of `constant_of_preserves_morphisms`.\n-/\ntheorem IsConnected.of_constant_of_preserves_morphisms [Nonempty J]\n    (h : ‚àÄ {Œ± : Type u‚ÇÅ} (F : J ‚Üí Œ±),\n      (‚àÄ {j‚ÇÅ j‚ÇÇ : J} (_ : j‚ÇÅ ‚ü∂ j‚ÇÇ), F j‚ÇÅ = F j‚ÇÇ) ‚Üí ‚àÄ j j' : J, F j = F j') :\n    IsConnected J :=\n  { IsPreconnected.of_constant_of_preserves_morphisms h with }\n\n"}
{"name":"CategoryTheory.induct_on_objects","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\ninst‚úù : CategoryTheory.IsPreconnected J\np : Set J\nj‚ÇÄ : J\nh0 : Membership.mem p j‚ÇÄ\nh1 : ‚àÄ {j‚ÇÅ j‚ÇÇ : J}, Quiver.Hom j‚ÇÅ j‚ÇÇ ‚Üí Iff (Membership.mem p j‚ÇÅ) (Membership.mem p j‚ÇÇ)\nj : J\n‚ä¢ Membership.mem p j","decl":"/-- An inductive-like property for the objects of a connected category.\nIf the set `p` is nonempty, and `p` is closed under morphisms of `J`,\nthen `p` contains all of `J`.\n\nThe converse is given in `IsConnected.of_induct`.\n-/\ntheorem induct_on_objects [IsPreconnected J] (p : Set J) {j‚ÇÄ : J} (h0 : j‚ÇÄ ‚àà p)\n    (h1 : ‚àÄ {j‚ÇÅ j‚ÇÇ : J} (_ : j‚ÇÅ ‚ü∂ j‚ÇÇ), j‚ÇÅ ‚àà p ‚Üî j‚ÇÇ ‚àà p) (j : J) : j ‚àà p := by\n  let aux (j‚ÇÅ j‚ÇÇ : J) (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) := congrArg ULift.up <| (h1 f).eq\n  injection constant_of_preserves_morphisms (fun k => ULift.up.{u‚ÇÅ} (k ‚àà p)) aux j j‚ÇÄ with i\n  rwa [i]\n\n"}
{"name":"CategoryTheory.IsConnected.of_induct","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nj‚ÇÄ : J\nh : ‚àÄ (p : Set J), Membership.mem p j‚ÇÄ ‚Üí (‚àÄ {j‚ÇÅ j‚ÇÇ : J}, Quiver.Hom j‚ÇÅ j‚ÇÇ ‚Üí Iff (Membership.mem p j‚ÇÅ) (Membership.mem p j‚ÇÇ)) ‚Üí ‚àÄ (j : J), Membership.mem p j\n‚ä¢ CategoryTheory.IsConnected J","decl":"/--\nIf any maximal connected component containing some element j‚ÇÄ of J is all of J, then J is connected.\n\nThe converse of `induct_on_objects`.\n-/\ntheorem IsConnected.of_induct {j‚ÇÄ : J}\n    (h : ‚àÄ p : Set J, j‚ÇÄ ‚àà p ‚Üí (‚àÄ {j‚ÇÅ j‚ÇÇ : J} (_ : j‚ÇÅ ‚ü∂ j‚ÇÇ), j‚ÇÅ ‚àà p ‚Üî j‚ÇÇ ‚àà p) ‚Üí ‚àÄ j : J, j ‚àà p) :\n    IsConnected J :=\n  have := Nonempty.intro j‚ÇÄ\n  IsConnected.of_constant_of_preserves_morphisms fun {Œ±} F a => by\n    have w := h { j | F j = F j‚ÇÄ } rfl (fun {j‚ÇÅ} {j‚ÇÇ} f => by\n      change F j‚ÇÅ = F j‚ÇÄ ‚Üî F j‚ÇÇ = F j‚ÇÄ\n      simp [a f])\n    intro j j'\n    rw [w j, w j']\n\n"}
{"name":"CategoryTheory.instIsConnectedULiftHomULift","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nhc : CategoryTheory.IsConnected J\n‚ä¢ CategoryTheory.IsConnected (CategoryTheory.ULiftHom (ULift.{u‚ÇÇ, u‚ÇÅ} J))","decl":"/-- Lifting the universe level of morphisms and objects preserves connectedness. -/\ninstance [hc : IsConnected J] : IsConnected (ULiftHom.{v‚ÇÇ} (ULift.{u‚ÇÇ} J)) := by\n  apply IsConnected.of_induct\n  ¬∑ rintro p hj‚ÇÄ h ‚ü®j‚ü©\n    let p' : Set J := {j : J | p ‚ü®j‚ü©}\n    have hj‚ÇÄ' : Classical.choice hc.is_nonempty ‚àà p' := by\n      simp only [p', (eq_self p')]\n      exact hj‚ÇÄ\n    apply induct_on_objects p' hj‚ÇÄ' fun f => h ((ULiftHomULiftCategory.equiv J).functor.map f)\n\n"}
{"name":"CategoryTheory.isPreconnected_induction","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\ninst‚úù : CategoryTheory.IsPreconnected J\nZ : J ‚Üí Sort u_1\nh‚ÇÅ : {j‚ÇÅ j‚ÇÇ : J} ‚Üí Quiver.Hom j‚ÇÅ j‚ÇÇ ‚Üí Z j‚ÇÅ ‚Üí Z j‚ÇÇ\nh‚ÇÇ : {j‚ÇÅ j‚ÇÇ : J} ‚Üí Quiver.Hom j‚ÇÅ j‚ÇÇ ‚Üí Z j‚ÇÇ ‚Üí Z j‚ÇÅ\nj‚ÇÄ : J\nx : Z j‚ÇÄ\nj : J\n‚ä¢ Nonempty (Z j)","decl":"/-- Another induction principle for `IsPreconnected J`:\ngiven a type family `Z : J ‚Üí Sort*` and\na rule for transporting in *both* directions along a morphism in `J`,\nwe can transport an `x : Z j‚ÇÄ` to a point in `Z j` for any `j`.\n-/\ntheorem isPreconnected_induction [IsPreconnected J] (Z : J ‚Üí Sort*)\n    (h‚ÇÅ : ‚àÄ {j‚ÇÅ j‚ÇÇ : J} (_ : j‚ÇÅ ‚ü∂ j‚ÇÇ), Z j‚ÇÅ ‚Üí Z j‚ÇÇ) (h‚ÇÇ : ‚àÄ {j‚ÇÅ j‚ÇÇ : J} (_ : j‚ÇÅ ‚ü∂ j‚ÇÇ), Z j‚ÇÇ ‚Üí Z j‚ÇÅ)\n    {j‚ÇÄ : J} (x : Z j‚ÇÄ) (j : J) : Nonempty (Z j) :=\n  (induct_on_objects { j | Nonempty (Z j) } ‚ü®x‚ü©\n      (fun f => ‚ü®by rintro ‚ü®y‚ü©; exact ‚ü®h‚ÇÅ f y‚ü©, by rintro ‚ü®y‚ü©; exact ‚ü®h‚ÇÇ f y‚ü©‚ü©)\n      j :)\n\n"}
{"name":"CategoryTheory.isPreconnected_of_equivalent","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\ninst‚úù : CategoryTheory.IsPreconnected J\ne : CategoryTheory.Equivalence J K\n‚ä¢ CategoryTheory.IsPreconnected K","decl":"/-- If `J` and `K` are equivalent, then if `J` is preconnected then `K` is as well. -/\ntheorem isPreconnected_of_equivalent {K : Type u‚ÇÇ} [Category.{v‚ÇÇ} K] [IsPreconnected J]\n    (e : J ‚âå K) : IsPreconnected K where\n  iso_constant F k :=\n    ‚ü®calc\n        F ‚âÖ e.inverse ‚ãô e.functor ‚ãô F := (e.invFunIdAssoc F).symm\n        _ ‚âÖ e.inverse ‚ãô (Functor.const J).obj ((e.functor ‚ãô F).obj (e.inverse.obj k)) :=\n          isoWhiskerLeft e.inverse (isoConstant (e.functor ‚ãô F) (e.inverse.obj k))\n        _ ‚âÖ e.inverse ‚ãô (Functor.const J).obj (F.obj k) :=\n          isoWhiskerLeft _ ((F ‚ãô Functor.const J).mapIso (e.counitIso.app k))\n        _ ‚âÖ (Functor.const K).obj (F.obj k) := NatIso.ofComponents fun _ => Iso.refl _‚ü©\n\n"}
{"name":"CategoryTheory.isPreconnected_iff_of_equivalence","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\ne : CategoryTheory.Equivalence J K\n‚ä¢ Iff (CategoryTheory.IsPreconnected J) (CategoryTheory.IsPreconnected K)","decl":"lemma isPreconnected_iff_of_equivalence {K : Type u‚ÇÇ} [Category.{v‚ÇÇ} K] (e : J ‚âå K) :\n    IsPreconnected J ‚Üî IsPreconnected K :=\n  ‚ü®fun _ => isPreconnected_of_equivalent e, fun _ => isPreconnected_of_equivalent e.symm‚ü©\n\n"}
{"name":"CategoryTheory.isConnected_of_equivalent","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\ne : CategoryTheory.Equivalence J K\ninst‚úù : CategoryTheory.IsConnected J\n‚ä¢ CategoryTheory.IsConnected K","decl":"/-- If `J` and `K` are equivalent, then if `J` is connected then `K` is as well. -/\ntheorem isConnected_of_equivalent {K : Type u‚ÇÇ} [Category.{v‚ÇÇ} K] (e : J ‚âå K) [IsConnected J] :\n    IsConnected K :=\n  { is_nonempty := Nonempty.map e.functor.obj (by infer_instance)\n    toIsPreconnected := isPreconnected_of_equivalent e }\n\n"}
{"name":"CategoryTheory.isConnected_iff_of_equivalence","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\ne : CategoryTheory.Equivalence J K\n‚ä¢ Iff (CategoryTheory.IsConnected J) (CategoryTheory.IsConnected K)","decl":"lemma isConnected_iff_of_equivalence {K : Type u‚ÇÇ} [Category.{v‚ÇÇ} K] (e : J ‚âå K) :\n    IsConnected J ‚Üî IsConnected K :=\n  ‚ü®fun _ => isConnected_of_equivalent e, fun _ => isConnected_of_equivalent e.symm‚ü©\n\n"}
{"name":"CategoryTheory.isPreconnected_op","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\ninst‚úù : CategoryTheory.IsPreconnected J\n‚ä¢ CategoryTheory.IsPreconnected (Opposite J)","decl":"/-- If `J` is preconnected, then `J·µí·µñ` is preconnected as well. -/\ninstance isPreconnected_op [IsPreconnected J] : IsPreconnected J·µí·µñ where\n  iso_constant := fun {Œ±} F X =>\n    ‚ü®NatIso.ofComponents fun Y =>\n      eqToIso (Discrete.ext (Discrete.eq_of_hom ((Nonempty.some\n        (IsPreconnected.iso_constant (F.rightOp ‚ãô (Discrete.opposite Œ±).functor) (unop X))).app\n          (unop Y)).hom))‚ü©\n\n"}
{"name":"CategoryTheory.isConnected_op","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\ninst‚úù : CategoryTheory.IsConnected J\n‚ä¢ CategoryTheory.IsConnected (Opposite J)","decl":"/-- If `J` is connected, then `J·µí·µñ` is connected as well. -/\ninstance isConnected_op [IsConnected J] : IsConnected J·µí·µñ where\n  is_nonempty := Nonempty.intro (op (Classical.arbitrary J))\n\n"}
{"name":"CategoryTheory.isPreconnected_of_isPreconnected_op","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\ninst‚úù : CategoryTheory.IsPreconnected (Opposite J)\n‚ä¢ CategoryTheory.IsPreconnected J","decl":"theorem isPreconnected_of_isPreconnected_op [IsPreconnected J·µí·µñ] : IsPreconnected J :=\n  isPreconnected_of_equivalent (opOpEquivalence J)\n\n"}
{"name":"CategoryTheory.isConnected_of_isConnected_op","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\ninst‚úù : CategoryTheory.IsConnected (Opposite J)\n‚ä¢ CategoryTheory.IsConnected J","decl":"theorem isConnected_of_isConnected_op [IsConnected J·µí·µñ] : IsConnected J :=\n  isConnected_of_equivalent (opOpEquivalence J)\n\n"}
{"name":"CategoryTheory.isConnected_op_iff_isConnected","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\n‚ä¢ Iff (CategoryTheory.IsConnected (Opposite J)) (CategoryTheory.IsConnected J)","decl":"variable (J) in\n@[simp]\ntheorem isConnected_op_iff_isConnected : IsConnected J·µí·µñ ‚Üî IsConnected J :=\n  ‚ü®fun _ => isConnected_of_isConnected_op, fun _ => isConnected_op‚ü©\n\n"}
{"name":"CategoryTheory.Zag.refl","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nX : J\n‚ä¢ CategoryTheory.Zag X X","decl":"@[refl] theorem Zag.refl (X : J) : Zag X X := Or.inl ‚ü®ùüô _‚ü©\n\n"}
{"name":"CategoryTheory.zag_symmetric","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\n‚ä¢ Symmetric CategoryTheory.Zag","decl":"theorem zag_symmetric : Symmetric (@Zag J _) := fun _ _ h => h.symm\n\n"}
{"name":"CategoryTheory.Zag.symm","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nj‚ÇÅ j‚ÇÇ : J\nh : CategoryTheory.Zag j‚ÇÅ j‚ÇÇ\n‚ä¢ CategoryTheory.Zag j‚ÇÇ j‚ÇÅ","decl":"@[symm] theorem Zag.symm {j‚ÇÅ j‚ÇÇ : J} (h : Zag j‚ÇÅ j‚ÇÇ) : Zag j‚ÇÇ j‚ÇÅ := zag_symmetric h\n\n"}
{"name":"CategoryTheory.Zag.of_hom","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nj‚ÇÅ j‚ÇÇ : J\nf : Quiver.Hom j‚ÇÅ j‚ÇÇ\n‚ä¢ CategoryTheory.Zag j‚ÇÅ j‚ÇÇ","decl":"theorem Zag.of_hom {j‚ÇÅ j‚ÇÇ : J} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) : Zag j‚ÇÅ j‚ÇÇ := Or.inl ‚ü®f‚ü©\n\n"}
{"name":"CategoryTheory.Zag.of_inv","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nj‚ÇÅ j‚ÇÇ : J\nf : Quiver.Hom j‚ÇÇ j‚ÇÅ\n‚ä¢ CategoryTheory.Zag j‚ÇÅ j‚ÇÇ","decl":"theorem Zag.of_inv {j‚ÇÅ j‚ÇÇ : J} (f : j‚ÇÇ ‚ü∂ j‚ÇÅ) : Zag j‚ÇÅ j‚ÇÇ := Or.inr ‚ü®f‚ü©\n\n"}
{"name":"CategoryTheory.zigzag_symmetric","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\n‚ä¢ Symmetric CategoryTheory.Zigzag","decl":"theorem zigzag_symmetric : Symmetric (@Zigzag J _) :=\n  Relation.ReflTransGen.symmetric zag_symmetric\n\n"}
{"name":"CategoryTheory.zigzag_equivalence","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\n‚ä¢ Equivalence CategoryTheory.Zigzag","decl":"theorem zigzag_equivalence : _root_.Equivalence (@Zigzag J _) :=\n  _root_.Equivalence.mk Relation.reflexive_reflTransGen (fun h => zigzag_symmetric h)\n  (fun h g => Relation.transitive_reflTransGen h g)\n\n"}
{"name":"CategoryTheory.Zigzag.refl","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nX : J\n‚ä¢ CategoryTheory.Zigzag X X","decl":"@[refl] theorem Zigzag.refl (X : J) : Zigzag X X := zigzag_equivalence.refl _\n\n"}
{"name":"CategoryTheory.Zigzag.symm","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nj‚ÇÅ j‚ÇÇ : J\nh : CategoryTheory.Zigzag j‚ÇÅ j‚ÇÇ\n‚ä¢ CategoryTheory.Zigzag j‚ÇÇ j‚ÇÅ","decl":"@[symm] theorem Zigzag.symm {j‚ÇÅ j‚ÇÇ : J} (h : Zigzag j‚ÇÅ j‚ÇÇ) : Zigzag j‚ÇÇ j‚ÇÅ := zigzag_symmetric h\n\n"}
{"name":"CategoryTheory.Zigzag.trans","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nj‚ÇÅ j‚ÇÇ j‚ÇÉ : J\nh‚ÇÅ : CategoryTheory.Zigzag j‚ÇÅ j‚ÇÇ\nh‚ÇÇ : CategoryTheory.Zigzag j‚ÇÇ j‚ÇÉ\n‚ä¢ CategoryTheory.Zigzag j‚ÇÅ j‚ÇÉ","decl":"@[trans] theorem Zigzag.trans {j‚ÇÅ j‚ÇÇ j‚ÇÉ : J} (h‚ÇÅ : Zigzag j‚ÇÅ j‚ÇÇ) (h‚ÇÇ : Zigzag j‚ÇÇ j‚ÇÉ) :\n    Zigzag j‚ÇÅ j‚ÇÉ :=\n  zigzag_equivalence.trans h‚ÇÅ h‚ÇÇ\n\n"}
{"name":"CategoryTheory.Zigzag.of_zag","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nj‚ÇÅ j‚ÇÇ : J\nh : CategoryTheory.Zag j‚ÇÅ j‚ÇÇ\n‚ä¢ CategoryTheory.Zigzag j‚ÇÅ j‚ÇÇ","decl":"theorem Zigzag.of_zag {j‚ÇÅ j‚ÇÇ : J} (h : Zag j‚ÇÅ j‚ÇÇ) : Zigzag j‚ÇÅ j‚ÇÇ :=\n  Relation.ReflTransGen.single h\n\n"}
{"name":"CategoryTheory.Zigzag.of_hom","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nj‚ÇÅ j‚ÇÇ : J\nf : Quiver.Hom j‚ÇÅ j‚ÇÇ\n‚ä¢ CategoryTheory.Zigzag j‚ÇÅ j‚ÇÇ","decl":"theorem Zigzag.of_hom {j‚ÇÅ j‚ÇÇ : J} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) : Zigzag j‚ÇÅ j‚ÇÇ :=\n  of_zag (Zag.of_hom f)\n\n"}
{"name":"CategoryTheory.Zigzag.of_inv","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nj‚ÇÅ j‚ÇÇ : J\nf : Quiver.Hom j‚ÇÇ j‚ÇÅ\n‚ä¢ CategoryTheory.Zigzag j‚ÇÅ j‚ÇÇ","decl":"theorem Zigzag.of_inv {j‚ÇÅ j‚ÇÇ : J} (f : j‚ÇÇ ‚ü∂ j‚ÇÅ) : Zigzag j‚ÇÅ j‚ÇÇ :=\n  of_zag (Zag.of_inv f)\n\n"}
{"name":"CategoryTheory.Zigzag.of_zag_trans","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nj‚ÇÅ j‚ÇÇ j‚ÇÉ : J\nh‚ÇÅ : CategoryTheory.Zag j‚ÇÅ j‚ÇÇ\nh‚ÇÇ : CategoryTheory.Zag j‚ÇÇ j‚ÇÉ\n‚ä¢ CategoryTheory.Zigzag j‚ÇÅ j‚ÇÉ","decl":"theorem Zigzag.of_zag_trans {j‚ÇÅ j‚ÇÇ j‚ÇÉ : J} (h‚ÇÅ : Zag j‚ÇÅ j‚ÇÇ) (h‚ÇÇ : Zag j‚ÇÇ j‚ÇÉ) : Zigzag j‚ÇÅ j‚ÇÉ :=\n  trans (of_zag h‚ÇÅ) (of_zag h‚ÇÇ)\n\n"}
{"name":"CategoryTheory.Zigzag.of_hom_hom","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nj‚ÇÅ j‚ÇÇ j‚ÇÉ : J\nf‚ÇÅ‚ÇÇ : Quiver.Hom j‚ÇÅ j‚ÇÇ\nf‚ÇÇ‚ÇÉ : Quiver.Hom j‚ÇÇ j‚ÇÉ\n‚ä¢ CategoryTheory.Zigzag j‚ÇÅ j‚ÇÉ","decl":"theorem Zigzag.of_hom_hom {j‚ÇÅ j‚ÇÇ j‚ÇÉ : J} (f‚ÇÅ‚ÇÇ : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f‚ÇÇ‚ÇÉ : j‚ÇÇ ‚ü∂ j‚ÇÉ) : Zigzag j‚ÇÅ j‚ÇÉ :=\n  (of_hom f‚ÇÅ‚ÇÇ).trans (of_hom f‚ÇÇ‚ÇÉ)\n\n"}
{"name":"CategoryTheory.Zigzag.of_hom_inv","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nj‚ÇÅ j‚ÇÇ j‚ÇÉ : J\nf‚ÇÅ‚ÇÇ : Quiver.Hom j‚ÇÅ j‚ÇÇ\nf‚ÇÉ‚ÇÇ : Quiver.Hom j‚ÇÉ j‚ÇÇ\n‚ä¢ CategoryTheory.Zigzag j‚ÇÅ j‚ÇÉ","decl":"theorem Zigzag.of_hom_inv {j‚ÇÅ j‚ÇÇ j‚ÇÉ : J} (f‚ÇÅ‚ÇÇ : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f‚ÇÉ‚ÇÇ : j‚ÇÉ ‚ü∂ j‚ÇÇ) : Zigzag j‚ÇÅ j‚ÇÉ :=\n  (of_hom f‚ÇÅ‚ÇÇ).trans (of_inv f‚ÇÉ‚ÇÇ)\n\n"}
{"name":"CategoryTheory.Zigzag.of_inv_hom","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nj‚ÇÅ j‚ÇÇ j‚ÇÉ : J\nf‚ÇÇ‚ÇÅ : Quiver.Hom j‚ÇÇ j‚ÇÅ\nf‚ÇÇ‚ÇÉ : Quiver.Hom j‚ÇÇ j‚ÇÉ\n‚ä¢ CategoryTheory.Zigzag j‚ÇÅ j‚ÇÉ","decl":"theorem Zigzag.of_inv_hom {j‚ÇÅ j‚ÇÇ j‚ÇÉ : J} (f‚ÇÇ‚ÇÅ : j‚ÇÇ ‚ü∂ j‚ÇÅ) (f‚ÇÇ‚ÇÉ : j‚ÇÇ ‚ü∂ j‚ÇÉ) : Zigzag j‚ÇÅ j‚ÇÉ :=\n  (of_inv f‚ÇÇ‚ÇÅ).trans (of_hom f‚ÇÇ‚ÇÉ)\n\n"}
{"name":"CategoryTheory.Zigzag.of_inv_inv","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nj‚ÇÅ j‚ÇÇ j‚ÇÉ : J\nf‚ÇÇ‚ÇÅ : Quiver.Hom j‚ÇÇ j‚ÇÅ\nf‚ÇÉ‚ÇÇ : Quiver.Hom j‚ÇÉ j‚ÇÇ\n‚ä¢ CategoryTheory.Zigzag j‚ÇÅ j‚ÇÉ","decl":"theorem Zigzag.of_inv_inv {j‚ÇÅ j‚ÇÇ j‚ÇÉ : J} (f‚ÇÇ‚ÇÅ : j‚ÇÇ ‚ü∂ j‚ÇÅ) (f‚ÇÉ‚ÇÇ : j‚ÇÉ ‚ü∂ j‚ÇÇ) : Zigzag j‚ÇÅ j‚ÇÉ :=\n  (of_inv f‚ÇÇ‚ÇÅ).trans (of_inv f‚ÇÉ‚ÇÇ)\n\n"}
{"name":"CategoryTheory.zigzag_prefunctor_obj_of_zigzag","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nF : Prefunctor J K\nj‚ÇÅ j‚ÇÇ : J\nh : CategoryTheory.Zigzag j‚ÇÅ j‚ÇÇ\n‚ä¢ CategoryTheory.Zigzag (F.obj j‚ÇÅ) (F.obj j‚ÇÇ)","decl":"/-- If there is a zigzag from `j‚ÇÅ` to `j‚ÇÇ`, then there is a zigzag from `F j‚ÇÅ` to\n`F j‚ÇÇ` as long as `F` is a prefunctor.\n-/\ntheorem zigzag_prefunctor_obj_of_zigzag (F : J ‚•§q K) {j‚ÇÅ j‚ÇÇ : J} (h : Zigzag j‚ÇÅ j‚ÇÇ) :\n    Zigzag (F.obj j‚ÇÅ) (F.obj j‚ÇÇ) :=\n  h.lift _ fun _ _ => Or.imp (Nonempty.map fun f => F.map f) (Nonempty.map fun f => F.map f)\n\n"}
{"name":"CategoryTheory.zigzag_obj_of_zigzag","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nF : CategoryTheory.Functor J K\nj‚ÇÅ j‚ÇÇ : J\nh : CategoryTheory.Zigzag j‚ÇÅ j‚ÇÇ\n‚ä¢ CategoryTheory.Zigzag (F.obj j‚ÇÅ) (F.obj j‚ÇÇ)","decl":"/-- If there is a zigzag from `j‚ÇÅ` to `j‚ÇÇ`, then there is a zigzag from `F j‚ÇÅ` to\n`F j‚ÇÇ` as long as `F` is a functor.\n-/\ntheorem zigzag_obj_of_zigzag (F : J ‚•§ K) {j‚ÇÅ j‚ÇÇ : J} (h : Zigzag j‚ÇÅ j‚ÇÇ) :\n    Zigzag (F.obj j‚ÇÅ) (F.obj j‚ÇÇ) :=\n  zigzag_prefunctor_obj_of_zigzag F.toPrefunctor h\n\n"}
{"name":"CategoryTheory.eq_of_zag","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"X : Type u_1\na b : CategoryTheory.Discrete X\nh : CategoryTheory.Zag a b\n‚ä¢ Eq a.as b.as","decl":"/-- A Zag in a discrete category entails an equality of its extremities -/\nlemma eq_of_zag (X) {a b : Discrete X} (h : Zag a b) : a.as = b.as :=\n  h.elim (fun ‚ü®f‚ü© ‚Ü¶ Discrete.eq_of_hom f) (fun ‚ü®f‚ü© ‚Ü¶ (Discrete.eq_of_hom f).symm)\n\n"}
{"name":"CategoryTheory.eq_of_zigzag","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"X : Type u_1\na b : CategoryTheory.Discrete X\nh : CategoryTheory.Zigzag a b\n‚ä¢ Eq a.as b.as","decl":"/-- A zigzag in a discrete category entails an equality of its extremities -/\nlemma eq_of_zigzag (X) {a b : Discrete X} (h : Zigzag a b) : a.as = b.as := by\n  induction h with\n  | refl => rfl\n  | tail _ h eq  => exact eq.trans (eq_of_zag _ h)\n\n-- TODO: figure out the right way to generalise this to `Zigzag`.\n"}
{"name":"CategoryTheory.zag_of_zag_obj","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nF : CategoryTheory.Functor J K\ninst‚úù : F.Full\nj‚ÇÅ j‚ÇÇ : J\nh : CategoryTheory.Zag (F.obj j‚ÇÅ) (F.obj j‚ÇÇ)\n‚ä¢ CategoryTheory.Zag j‚ÇÅ j‚ÇÇ","decl":"theorem zag_of_zag_obj (F : J ‚•§ K) [F.Full] {j‚ÇÅ j‚ÇÇ : J} (h : Zag (F.obj j‚ÇÅ) (F.obj j‚ÇÇ)) :\n    Zag j‚ÇÅ j‚ÇÇ :=\n  Or.imp (Nonempty.map F.preimage) (Nonempty.map F.preimage) h\n\n"}
{"name":"CategoryTheory.equiv_relation","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\ninst‚úù : CategoryTheory.IsPreconnected J\nr : J ‚Üí J ‚Üí Prop\nhr : Equivalence r\nh : ‚àÄ {j‚ÇÅ j‚ÇÇ : J}, Quiver.Hom j‚ÇÅ j‚ÇÇ ‚Üí r j‚ÇÅ j‚ÇÇ\nj‚ÇÅ j‚ÇÇ : J\n‚ä¢ r j‚ÇÅ j‚ÇÇ","decl":"/-- Any equivalence relation containing (‚ü∂) holds for all pairs of a connected category. -/\ntheorem equiv_relation [IsPreconnected J] (r : J ‚Üí J ‚Üí Prop) (hr : _root_.Equivalence r)\n    (h : ‚àÄ {j‚ÇÅ j‚ÇÇ : J} (_ : j‚ÇÅ ‚ü∂ j‚ÇÇ), r j‚ÇÅ j‚ÇÇ) : ‚àÄ j‚ÇÅ j‚ÇÇ : J, r j‚ÇÅ j‚ÇÇ := by\n  intros j‚ÇÅ j‚ÇÇ\n  have z : ‚àÄ j : J, r j‚ÇÅ j :=\n    induct_on_objects {k | r j‚ÇÅ k} (hr.1 j‚ÇÅ)\n      fun f => ‚ü®fun t => hr.3 t (h f), fun t => hr.3 t (hr.2 (h f))‚ü©\n  exact z j‚ÇÇ\n\n"}
{"name":"CategoryTheory.isPreconnected_zigzag","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\ninst‚úù : CategoryTheory.IsPreconnected J\nj‚ÇÅ j‚ÇÇ : J\n‚ä¢ CategoryTheory.Zigzag j‚ÇÅ j‚ÇÇ","decl":"/-- In a connected category, any two objects are related by `Zigzag`. -/\ntheorem isPreconnected_zigzag [IsPreconnected J] (j‚ÇÅ j‚ÇÇ : J) : Zigzag j‚ÇÅ j‚ÇÇ :=\n  equiv_relation _ zigzag_equivalence\n    (fun f => Relation.ReflTransGen.single (Or.inl (Nonempty.intro f))) _ _\n\n\n"}
{"name":"CategoryTheory.zigzag_isPreconnected","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nh : ‚àÄ (j‚ÇÅ j‚ÇÇ : J), CategoryTheory.Zigzag j‚ÇÅ j‚ÇÇ\n‚ä¢ CategoryTheory.IsPreconnected J","decl":"theorem zigzag_isPreconnected (h : ‚àÄ j‚ÇÅ j‚ÇÇ : J, Zigzag j‚ÇÅ j‚ÇÇ) : IsPreconnected J := by\n  apply IsPreconnected.of_constant_of_preserves_morphisms\n  intro Œ± F hF j j'\n  specialize h j j'\n  induction' h with j‚ÇÅ j‚ÇÇ _ hj ih\n  ¬∑ rfl\n  ¬∑ rw [ih]\n    rcases hj with (‚ü®‚ü®hj‚ü©‚ü©|‚ü®‚ü®hj‚ü©‚ü©)\n    exacts [hF hj, (hF hj).symm]\n\n"}
{"name":"CategoryTheory.zigzag_isConnected","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\ninst‚úù : Nonempty J\nh : ‚àÄ (j‚ÇÅ j‚ÇÇ : J), CategoryTheory.Zigzag j‚ÇÅ j‚ÇÇ\n‚ä¢ CategoryTheory.IsConnected J","decl":"/-- If any two objects in a nonempty category are related by `Zigzag`, the category is connected.\n-/\ntheorem zigzag_isConnected [Nonempty J] (h : ‚àÄ j‚ÇÅ j‚ÇÇ : J, Zigzag j‚ÇÅ j‚ÇÇ) : IsConnected J :=\n  { zigzag_isPreconnected h with }\n\n"}
{"name":"CategoryTheory.exists_zigzag'","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\ninst‚úù : CategoryTheory.IsConnected J\nj‚ÇÅ j‚ÇÇ : J\n‚ä¢ Exists fun l => And (List.Chain CategoryTheory.Zag j‚ÇÅ l) (Eq ((List.cons j‚ÇÅ l).getLast ‚ãØ) j‚ÇÇ)","decl":"theorem exists_zigzag' [IsConnected J] (j‚ÇÅ j‚ÇÇ : J) :\n    ‚àÉ l, List.Chain Zag j‚ÇÅ l ‚àß List.getLast (j‚ÇÅ :: l) (List.cons_ne_nil _ _) = j‚ÇÇ :=\n  List.exists_chain_of_relationReflTransGen (isPreconnected_zigzag _ _)\n\n"}
{"name":"CategoryTheory.isPreconnected_of_zigzag","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nh : ‚àÄ (j‚ÇÅ j‚ÇÇ : J), Exists fun l => And (List.Chain CategoryTheory.Zag j‚ÇÅ l) (Eq ((List.cons j‚ÇÅ l).getLast ‚ãØ) j‚ÇÇ)\n‚ä¢ CategoryTheory.IsPreconnected J","decl":"/-- If any two objects in a nonempty category are linked by a sequence of (potentially reversed)\nmorphisms, then J is connected.\n\nThe converse of `exists_zigzag'`.\n-/\ntheorem isPreconnected_of_zigzag (h : ‚àÄ j‚ÇÅ j‚ÇÇ : J, ‚àÉ l,\n    List.Chain Zag j‚ÇÅ l ‚àß List.getLast (j‚ÇÅ :: l) (List.cons_ne_nil _ _) = j‚ÇÇ) :\n    IsPreconnected J := by\n  apply zigzag_isPreconnected\n  intro j‚ÇÅ j‚ÇÇ\n  rcases h j‚ÇÅ j‚ÇÇ with ‚ü®l, hl‚ÇÅ, hl‚ÇÇ‚ü©\n  apply List.relationReflTransGen_of_exists_chain l hl‚ÇÅ hl‚ÇÇ\n\n"}
{"name":"CategoryTheory.isConnected_of_zigzag","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\ninst‚úù : Nonempty J\nh : ‚àÄ (j‚ÇÅ j‚ÇÇ : J), Exists fun l => And (List.Chain CategoryTheory.Zag j‚ÇÅ l) (Eq ((List.cons j‚ÇÅ l).getLast ‚ãØ) j‚ÇÇ)\n‚ä¢ CategoryTheory.IsConnected J","decl":"/-- If any two objects in a nonempty category are linked by a sequence of (potentially reversed)\nmorphisms, then J is connected.\n\nThe converse of `exists_zigzag'`.\n-/\ntheorem isConnected_of_zigzag [Nonempty J] (h : ‚àÄ j‚ÇÅ j‚ÇÇ : J, ‚àÉ l,\n    List.Chain Zag j‚ÇÅ l ‚àß List.getLast (j‚ÇÅ :: l) (List.cons_ne_nil _ _) = j‚ÇÇ) :\n    IsConnected J :=\n  { isPreconnected_of_zigzag h with }\n\n"}
{"name":"CategoryTheory.nat_trans_from_is_connected","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type w‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{w‚ÇÅ, w‚ÇÇ} C\ninst‚úù : CategoryTheory.IsPreconnected J\nX Y : C\nŒ± : Quiver.Hom ((CategoryTheory.Functor.const J).obj X) ((CategoryTheory.Functor.const J).obj Y)\nj j' : J\n‚ä¢ Eq (Œ±.app j) (Œ±.app j')","decl":"/-- For objects `X Y : C`, any natural transformation `Œ± : const X ‚ü∂ const Y` from a connected\ncategory must be constant.\nThis is the key property of connected categories which we use to establish properties about limits.\n-/\ntheorem nat_trans_from_is_connected [IsPreconnected J] {X Y : C}\n    (Œ± : (Functor.const J).obj X ‚ü∂ (Functor.const J).obj Y) :\n    ‚àÄ j j' : J, Œ±.app j = (Œ±.app j' : X ‚ü∂ Y) :=\n  @constant_of_preserves_morphisms _ _ _ (X ‚ü∂ Y) (fun j => Œ±.app j) fun _ _ f => by\n    have := Œ±.naturality f\n    erw [id_comp, comp_id] at this\n    exact this.symm\n\n"}
{"name":"CategoryTheory.instFullFunctorConstOfIsConnected","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type w‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{w‚ÇÅ, w‚ÇÇ} C\ninst‚úù : CategoryTheory.IsConnected J\n‚ä¢ (CategoryTheory.Functor.const J).Full","decl":"instance [IsConnected J] : (Functor.const J : C ‚•§ J ‚•§ C).Full where\n  map_surjective f := ‚ü®f.app (Classical.arbitrary J), by\n    ext j\n    apply nat_trans_from_is_connected f (Classical.arbitrary J) j‚ü©\n\n"}
{"name":"CategoryTheory.nonempty_hom_of_preconnected_groupoid","module":"Mathlib.CategoryTheory.IsConnected","initialProofState":"G : Type u_1\ninst‚úù¬π : CategoryTheory.Groupoid G\ninst‚úù : CategoryTheory.IsPreconnected G\nx y : G\n‚ä¢ Nonempty (Quiver.Hom x y)","decl":"theorem nonempty_hom_of_preconnected_groupoid {G} [Groupoid G] [IsPreconnected G] :\n    ‚àÄ x y : G, Nonempty (x ‚ü∂ y) := by\n  refine equiv_relation _ ?_ fun {j‚ÇÅ j‚ÇÇ} => Nonempty.intro\n  exact\n    ‚ü®fun j => ‚ü®ùüô _‚ü©,\n     fun {j‚ÇÅ j‚ÇÇ} => Nonempty.map fun f => inv f,\n     fun {_ _ _} => Nonempty.map2 (¬∑ ‚â´ ¬∑)‚ü©\n\n"}
