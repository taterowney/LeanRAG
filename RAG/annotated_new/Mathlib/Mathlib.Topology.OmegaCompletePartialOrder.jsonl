{"name":"Topology.IsScott.ωscottContinuous_iff_continuous","module":"Mathlib.Topology.OmegaCompletePartialOrder","initialProofState":"α : Type u_1\ninst✝² : OmegaCompletePartialOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsScott α (Set.range fun c => Set.range ⇑c)\nf : α → Prop\n⊢ Iff (OmegaCompletePartialOrder.ωScottContinuous f) (Continuous f)","decl":"open Topology.IsScott in\n@[simp] lemma Topology.IsScott.ωscottContinuous_iff_continuous {α : Type*}\n    [OmegaCompletePartialOrder α] [TopologicalSpace α]\n    [Topology.IsScott α (Set.range fun c : Chain α => Set.range c)] {f : α → Prop} :\n    ωScottContinuous f ↔ Continuous f := by\n  rw [ωScottContinuous, scottContinuous_iff_continuous (fun a b hab => by\n    use Chain.pair a b hab; exact OmegaCompletePartialOrder.Chain.range_pair a b hab)]\n\n-- \"Scott\", \"ωSup\"\n"}
{"name":"Scott.isωSup_iff_isLUB","module":"Mathlib.Topology.OmegaCompletePartialOrder","initialProofState":"α : Type u\ninst✝ : Preorder α\nc : OmegaCompletePartialOrder.Chain α\nx : α\n⊢ Iff (Scott.IsωSup c x) (IsLUB (Set.range ⇑c) x)","decl":"theorem isωSup_iff_isLUB {α : Type u} [Preorder α] {c : Chain α} {x : α} :\n    IsωSup c x ↔ IsLUB (range c) x := by\n  simp [IsωSup, IsLUB, IsLeast, upperBounds, lowerBounds]\n\n"}
{"name":"Scott.isOpen_univ","module":"Mathlib.Topology.OmegaCompletePartialOrder","initialProofState":"α : Type u\ninst✝ : OmegaCompletePartialOrder α\n⊢ Scott.IsOpen α Set.univ","decl":"theorem isOpen_univ : IsOpen α univ := @CompleteLattice.ωScottContinuous.top α Prop _ _\n\n"}
{"name":"Scott.IsOpen.inter","module":"Mathlib.Topology.OmegaCompletePartialOrder","initialProofState":"α : Type u\ninst✝ : OmegaCompletePartialOrder α\ns t : Set α\na✝¹ : Scott.IsOpen α s\na✝ : Scott.IsOpen α t\n⊢ Scott.IsOpen α (Inter.inter s t)","decl":"theorem IsOpen.inter (s t : Set α) : IsOpen α s → IsOpen α t → IsOpen α (s ∩ t) :=\n  CompleteLattice.ωScottContinuous.inf\n\n"}
{"name":"Scott.isOpen_sUnion","module":"Mathlib.Topology.OmegaCompletePartialOrder","initialProofState":"α : Type u\ninst✝ : OmegaCompletePartialOrder α\ns : Set (Set α)\nhs : ∀ (t : Set α), Membership.mem s t → Scott.IsOpen α t\n⊢ Scott.IsOpen α s.sUnion","decl":"theorem isOpen_sUnion (s : Set (Set α)) (hs : ∀ t ∈ s, IsOpen α t) : IsOpen α (⋃₀ s) := by\n  simp only [IsOpen] at hs ⊢\n  convert CompleteLattice.ωScottContinuous.sSup hs\n  aesop\n\n"}
{"name":"Scott.IsOpen.isUpperSet","module":"Mathlib.Topology.OmegaCompletePartialOrder","initialProofState":"α : Type u\ninst✝ : OmegaCompletePartialOrder α\ns : Set α\nhs : Scott.IsOpen α s\n⊢ IsUpperSet s","decl":"theorem IsOpen.isUpperSet {s : Set α} (hs : IsOpen α s) : IsUpperSet s := hs.monotone\n\n"}
{"name":"isOpen_iff_ωScottContinuous_mem","module":"Mathlib.Topology.OmegaCompletePartialOrder","initialProofState":"α : Type u_1\ninst✝ : OmegaCompletePartialOrder α\ns : Set (Scott α)\n⊢ Iff (IsOpen s) (OmegaCompletePartialOrder.ωScottContinuous fun x => Membership.mem s x)","decl":"lemma isOpen_iff_ωScottContinuous_mem {α} [OmegaCompletePartialOrder α] {s : Set (Scott α)} :\n    IsOpen s ↔ ωScottContinuous fun x ↦ x ∈ s := by rfl\n\n"}
{"name":"scott_eq_Scott","module":"Mathlib.Topology.OmegaCompletePartialOrder","initialProofState":"α : Type u_1\ninst✝ : OmegaCompletePartialOrder α\n⊢ Eq (Topology.scott α (Set.range fun c => Set.range ⇑c)) (Scott.topologicalSpace α)","decl":"lemma scott_eq_Scott {α} [OmegaCompletePartialOrder α] :\n    Topology.scott α (Set.range fun c : Chain α => Set.range c) = Scott.topologicalSpace α := by\n  ext U\n  letI := Topology.scott α (Set.range fun c : Chain α => Set.range c)\n  rw [isOpen_iff_ωScottContinuous_mem, @isOpen_iff_continuous_mem,\n    @Topology.IsScott.ωscottContinuous_iff_continuous _ _\n      (Topology.scott α (Set.range fun c : Chain α => Set.range c)) ({ topology_eq_scott := rfl })]\n\n"}
{"name":"notBelow_isOpen","module":"Mathlib.Topology.OmegaCompletePartialOrder","initialProofState":"α : Type u_1\ninst✝ : OmegaCompletePartialOrder α\ny : Scott α\n⊢ IsOpen (notBelow y)","decl":"theorem notBelow_isOpen : IsOpen (notBelow y) := by\n  have h : Monotone (notBelow y) := fun x z hle ↦ mt hle.trans\n  dsimp only [IsOpen, TopologicalSpace.IsOpen, Scott.IsOpen]\n  rw [ωScottContinuous_iff_monotone_map_ωSup]\n  refine ⟨h, fun c ↦ eq_of_forall_ge_iff fun z ↦ ?_⟩\n  simp only [ωSup_le_iff, notBelow, mem_setOf_eq, le_Prop_eq, OrderHom.coe_mk, Chain.map_coe,\n    Function.comp_apply, exists_imp, not_forall]\n\n"}
{"name":"isωSup_ωSup","module":"Mathlib.Topology.OmegaCompletePartialOrder","initialProofState":"α : Type u_1\ninst✝ : OmegaCompletePartialOrder α\nc : OmegaCompletePartialOrder.Chain α\n⊢ Scott.IsωSup c (OmegaCompletePartialOrder.ωSup c)","decl":"theorem isωSup_ωSup {α} [OmegaCompletePartialOrder α] (c : Chain α) : IsωSup c (ωSup c) := by\n  constructor\n  · apply le_ωSup\n  · apply ωSup_le\n\n"}
{"name":"scottContinuous_of_continuous","module":"Mathlib.Topology.OmegaCompletePartialOrder","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf : Scott α → Scott β\nhf : Continuous f\n⊢ OmegaCompletePartialOrder.ωScottContinuous f","decl":"theorem scottContinuous_of_continuous {α β} [OmegaCompletePartialOrder α]\n    [OmegaCompletePartialOrder β] (f : Scott α → Scott β) (hf : _root_.Continuous f) :\n    OmegaCompletePartialOrder.ωScottContinuous f := by\n  rw [ωScottContinuous_iff_monotone_map_ωSup]\n  have h : Monotone f := fun x y h ↦ by\n    have hf : IsUpperSet {x | ¬f x ≤ f y} := ((notBelow_isOpen (f y)).preimage hf).isUpperSet\n    simpa only [mem_setOf_eq, le_refl, not_true, imp_false, not_not] using hf h\n  refine ⟨h, fun c ↦ eq_of_forall_ge_iff fun z ↦ ?_⟩\n  rcases (notBelow_isOpen z).preimage hf with hf''\n  let hf' := hf''.monotone_map_ωSup.2\n  specialize hf' c\n  simp only [OrderHom.coe_mk, mem_preimage, notBelow, mem_setOf_eq] at hf'\n  rw [← not_iff_not]\n  simp only [ωSup_le_iff, hf', ωSup, iSup, sSup, mem_range, Chain.map_coe, Function.comp_apply,\n    eq_iff_iff, not_forall, OrderHom.coe_mk]\n  tauto\n\n"}
{"name":"continuous_of_scottContinuous","module":"Mathlib.Topology.OmegaCompletePartialOrder","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf : Scott α → Scott β\nhf : OmegaCompletePartialOrder.ωScottContinuous f\n⊢ Continuous f","decl":"theorem continuous_of_scottContinuous {α β} [OmegaCompletePartialOrder α]\n    [OmegaCompletePartialOrder β] (f : Scott α → Scott β)\n    (hf : ωScottContinuous f) : Continuous f := by\n  rw [continuous_def]\n  intro s hs\n  dsimp only [IsOpen, TopologicalSpace.IsOpen, Scott.IsOpen]\n  simp_rw [mem_preimage, mem_def, ← Function.comp_def]\n  apply ωScottContinuous.comp hs hf\n"}
