{"name":"CategoryTheory.Square.isPullback_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Iff sq.IsPullback (Nonempty (CategoryTheory.Limits.IsLimit sq.pullbackCone))","decl":"lemma isPullback_iff :\n    sq.IsPullback ↔ Nonempty (IsLimit sq.pullbackCone) :=\n  ⟨fun h ↦ ⟨h.isLimit⟩, fun h ↦ { w := sq.fac, isLimit' := h }⟩\n\n"}
{"name":"CategoryTheory.Square.isPushout_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Iff sq.IsPushout (Nonempty (CategoryTheory.Limits.IsColimit sq.pushoutCocone))","decl":"lemma isPushout_iff :\n    sq.IsPushout ↔ Nonempty (IsColimit sq.pushoutCocone) :=\n  ⟨fun h ↦ ⟨h.isColimit⟩, fun h ↦ { w := sq.fac, isColimit' := h }⟩\n\n"}
{"name":"CategoryTheory.Square.IsPullback.mk","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\nh : CategoryTheory.Limits.IsLimit sq.pullbackCone\n⊢ sq.IsPullback","decl":"lemma IsPullback.mk (h : IsLimit sq.pullbackCone) : sq.IsPullback :=\n  sq.isPullback_iff.2 ⟨h⟩\n\n"}
{"name":"CategoryTheory.Square.IsPushout.mk","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\nh : CategoryTheory.Limits.IsColimit sq.pushoutCocone\n⊢ sq.IsPushout","decl":"lemma IsPushout.mk (h : IsColimit sq.pushoutCocone) : sq.IsPushout :=\n  sq.isPushout_iff.2 ⟨h⟩\n\n"}
{"name":"CategoryTheory.Square.IsPullback.of_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ : CategoryTheory.Square C\nh : sq₁.IsPullback\ne : CategoryTheory.Iso sq₁ sq₂\n⊢ sq₂.IsPullback","decl":"lemma IsPullback.of_iso {sq₁ sq₂ : Square C} (h : sq₁.IsPullback)\n    (e : sq₁ ≅ sq₂) : sq₂.IsPullback := by\n  refine CategoryTheory.IsPullback.of_iso h\n    (evaluation₁.mapIso e) (evaluation₂.mapIso e)\n    (evaluation₃.mapIso e) (evaluation₄.mapIso e) ?_ ?_ ?_ ?_\n  all_goals simp\n\n"}
{"name":"CategoryTheory.Square.IsPullback.iff_of_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ : CategoryTheory.Square C\ne : CategoryTheory.Iso sq₁ sq₂\n⊢ Iff sq₁.IsPullback sq₂.IsPullback","decl":"lemma IsPullback.iff_of_iso {sq₁ sq₂ : Square C} (e : sq₁ ≅ sq₂) :\n    sq₁.IsPullback ↔ sq₂.IsPullback :=\n  ⟨fun h ↦ h.of_iso e, fun h ↦ h.of_iso e.symm⟩\n\n"}
{"name":"CategoryTheory.Square.IsPushout.of_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ : CategoryTheory.Square C\nh : sq₁.IsPushout\ne : CategoryTheory.Iso sq₁ sq₂\n⊢ sq₂.IsPushout","decl":"lemma IsPushout.of_iso {sq₁ sq₂ : Square C} (h : sq₁.IsPushout)\n    (e : sq₁ ≅ sq₂) : sq₂.IsPushout := by\n  refine CategoryTheory.IsPushout.of_iso h\n    (evaluation₁.mapIso e) (evaluation₂.mapIso e)\n    (evaluation₃.mapIso e) (evaluation₄.mapIso e) ?_ ?_ ?_ ?_\n  all_goals simp\n\n"}
{"name":"CategoryTheory.Square.IsPushout.iff_of_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq₁ sq₂ : CategoryTheory.Square C\ne : CategoryTheory.Iso sq₁ sq₂\n⊢ Iff sq₁.IsPushout sq₂.IsPushout","decl":"lemma IsPushout.iff_of_iso {sq₁ sq₂ : Square C} (e : sq₁ ≅ sq₂) :\n    sq₁.IsPushout ↔ sq₂.IsPushout :=\n  ⟨fun h ↦ h.of_iso e, fun h ↦ h.of_iso e.symm⟩\n\n"}
{"name":"CategoryTheory.Square.IsPushout.op","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\nh : sq.IsPushout\n⊢ sq.op.IsPullback","decl":"lemma IsPushout.op {sq : Square C} (h : sq.IsPushout) : sq.op.IsPullback :=\n  CategoryTheory.IsPushout.op h.flip\n\n"}
{"name":"CategoryTheory.Square.IsPushout.unop","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square (Opposite C)\nh : sq.IsPushout\n⊢ sq.unop.IsPullback","decl":"lemma IsPushout.unop {sq : Square Cᵒᵖ} (h : sq.IsPushout) : sq.unop.IsPullback :=\n  CategoryTheory.IsPushout.unop h.flip\n\n"}
{"name":"CategoryTheory.Square.IsPullback.op","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\nh : sq.IsPullback\n⊢ sq.op.IsPushout","decl":"lemma IsPullback.op {sq : Square C} (h : sq.IsPullback) : sq.op.IsPushout :=\n  CategoryTheory.IsPullback.op h.flip\n\n"}
{"name":"CategoryTheory.Square.IsPullback.unop","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square (Opposite C)\nh : sq.IsPullback\n⊢ sq.unop.IsPushout","decl":"lemma IsPullback.unop {sq : Square Cᵒᵖ} (h : sq.IsPullback) : sq.unop.IsPushout :=\n  CategoryTheory.IsPullback.unop h.flip\n\n"}
{"name":"CategoryTheory.Square.IsPullback.flip","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\nh : sq.IsPullback\n⊢ sq.flip.IsPullback","decl":"lemma flip : sq.flip.IsPullback := CategoryTheory.IsPullback.flip h\n\n"}
{"name":"CategoryTheory.Square.IsPullback.mono_f₁₃","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\nh : sq.IsPullback\ninst✝ : CategoryTheory.Mono sq.f₂₄\n⊢ CategoryTheory.Mono sq.f₁₃","decl":"lemma mono_f₁₃ [Mono sq.f₂₄] : Mono sq.f₁₃ :=\n  (MorphismProperty.monomorphisms C).of_isPullback h (by assumption)\n\n"}
{"name":"CategoryTheory.Square.IsPullback.mono_f₁₂","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\nh : sq.IsPullback\ninst✝ : CategoryTheory.Mono sq.f₃₄\n⊢ CategoryTheory.Mono sq.f₁₂","decl":"lemma mono_f₁₂ [Mono sq.f₃₄] : Mono sq.f₁₂ := by\n  have : Mono sq.flip.f₂₄ := by dsimp; infer_instance\n  exact h.flip.mono_f₁₃\n\n"}
{"name":"CategoryTheory.Square.IsPushout.flip","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\nh : sq.IsPushout\n⊢ sq.flip.IsPushout","decl":"lemma flip : sq.flip.IsPushout := CategoryTheory.IsPushout.flip h\n\n"}
{"name":"CategoryTheory.Square.IsPushout.epi_f₂₄","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\nh : sq.IsPushout\ninst✝ : CategoryTheory.Epi sq.f₁₃\n⊢ CategoryTheory.Epi sq.f₂₄","decl":"lemma epi_f₂₄ [Epi sq.f₁₃] : Epi sq.f₂₄ :=\n  (MorphismProperty.epimorphisms C).of_isPushout h (by assumption)\n\n"}
{"name":"CategoryTheory.Square.IsPushout.epi_f₃₄","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Square","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\nh : sq.IsPushout\ninst✝ : CategoryTheory.Epi sq.f₁₂\n⊢ CategoryTheory.Epi sq.f₃₄","decl":"lemma epi_f₃₄ [Epi sq.f₁₂] : Epi sq.f₃₄ := by\n  have : Epi sq.flip.f₁₃ := by dsimp; infer_instance\n  exact h.flip.epi_f₂₄\n\n"}
