{"name":"MeasureTheory.integral_divergence_of_hasFDerivWithinAt_off_countable_aux₁","module":"Mathlib.MeasureTheory.Integral.DivergenceTheorem","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nn : Nat\nI : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\nf : (Fin (HAdd.hAdd n 1) → Real) → Fin (HAdd.hAdd n 1) → E\nf' : (Fin (HAdd.hAdd n 1) → Real) → ContinuousLinearMap (RingHom.id Real) (Fin (HAdd.hAdd n 1) → Real) (Fin (HAdd.hAdd n 1) → E)\ns : Set (Fin (HAdd.hAdd n 1) → Real)\nhs : s.Countable\nHc : ContinuousOn f (BoxIntegral.Box.Icc I)\nHd : ∀ (x : Fin (HAdd.hAdd n 1) → Real), Membership.mem (SDiff.sdiff (BoxIntegral.Box.Icc I) s) x → HasFDerivWithinAt f (f' x) (BoxIntegral.Box.Icc I) x\nHi : MeasureTheory.IntegrableOn (fun x => Finset.univ.sum fun i => (f' x) (Pi.single i 1) i) (BoxIntegral.Box.Icc I) MeasureTheory.MeasureSpace.volume\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (BoxIntegral.Box.Icc I)) fun x => Finset.univ.sum fun i => (f' x) (Pi.single i 1) i) (Finset.univ.sum fun i => HSub.hSub (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (BoxIntegral.Box.Icc (I.face i))) fun x => f (i.insertNth (I.upper i) x) i) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (BoxIntegral.Box.Icc (I.face i))) fun x => f (i.insertNth (I.lower i) x) i))","decl":"/-- An auxiliary lemma for\n`MeasureTheory.integral_divergence_of_hasFDerivWithinAt_off_countable`. This is exactly\n`BoxIntegral.hasIntegral_GP_divergence_of_forall_hasDerivWithinAt` reformulated for the\nBochner integral. -/\ntheorem integral_divergence_of_hasFDerivWithinAt_off_countable_aux₁ (I : Box (Fin (n + 1)))\n    (f : ℝⁿ⁺¹ → Eⁿ⁺¹)\n    (f' : ℝⁿ⁺¹ → ℝⁿ⁺¹ →L[ℝ] Eⁿ⁺¹) (s : Set ℝⁿ⁺¹)\n    (hs : s.Countable) (Hc : ContinuousOn f (Box.Icc I))\n    (Hd : ∀ x ∈ (Box.Icc I) \\ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x)\n    (Hi : IntegrableOn (fun x => ∑ i, f' x (e i) i) (Box.Icc I)) :\n    (∫ x in Box.Icc I, ∑ i, f' x (e i) i) =\n      ∑ i : Fin (n + 1),\n        ((∫ x in Box.Icc (I.face i), f (i.insertNth (I.upper i) x) i) -\n          ∫ x in Box.Icc (I.face i), f (i.insertNth (I.lower i) x) i) := by\n  simp only [← setIntegral_congr_set (Box.coe_ae_eq_Icc _)]\n  have A := (Hi.mono_set Box.coe_subset_Icc).hasBoxIntegral ⊥ rfl\n  have B :=\n    hasIntegral_GP_divergence_of_forall_hasDerivWithinAt I f f' (s ∩ Box.Icc I)\n      (hs.mono inter_subset_left) (fun x hx => Hc _ hx.2) fun x hx =>\n      Hd _ ⟨hx.1, fun h => hx.2 ⟨h, hx.1⟩⟩\n  rw [continuousOn_pi] at Hc\n  refine (A.unique B).trans (sum_congr rfl fun i _ => ?_)\n  refine congr_arg₂ Sub.sub ?_ ?_\n  · have := Box.continuousOn_face_Icc (Hc i) (Set.right_mem_Icc.2 (I.lower_le_upper i))\n    have := (this.integrableOn_compact (μ := volume) (Box.isCompact_Icc _)).mono_set\n      Box.coe_subset_Icc\n    exact (this.hasBoxIntegral ⊥ rfl).integral_eq\n  · have := Box.continuousOn_face_Icc (Hc i) (Set.left_mem_Icc.2 (I.lower_le_upper i))\n    have := (this.integrableOn_compact (μ := volume) (Box.isCompact_Icc _)).mono_set\n      Box.coe_subset_Icc\n    exact (this.hasBoxIntegral ⊥ rfl).integral_eq\n\n"}
{"name":"MeasureTheory.integral_divergence_of_hasFDerivWithinAt_off_countable_aux₂","module":"Mathlib.MeasureTheory.Integral.DivergenceTheorem","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nn : Nat\nI : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\nf : (Fin (HAdd.hAdd n 1) → Real) → Fin (HAdd.hAdd n 1) → E\nf' : (Fin (HAdd.hAdd n 1) → Real) → ContinuousLinearMap (RingHom.id Real) (Fin (HAdd.hAdd n 1) → Real) (Fin (HAdd.hAdd n 1) → E)\ns : Set (Fin (HAdd.hAdd n 1) → Real)\nhs : s.Countable\nHc : ContinuousOn f (BoxIntegral.Box.Icc I)\nHd : ∀ (x : Fin (HAdd.hAdd n 1) → Real), Membership.mem (SDiff.sdiff (BoxIntegral.Box.Ioo I) s) x → HasFDerivAt f (f' x) x\nHi : MeasureTheory.IntegrableOn (fun x => Finset.univ.sum fun i => (f' x) (Pi.single i 1) i) (BoxIntegral.Box.Icc I) MeasureTheory.MeasureSpace.volume\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (BoxIntegral.Box.Icc I)) fun x => Finset.univ.sum fun i => (f' x) (Pi.single i 1) i) (Finset.univ.sum fun i => HSub.hSub (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (BoxIntegral.Box.Icc (I.face i))) fun x => f (i.insertNth (I.upper i) x) i) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (BoxIntegral.Box.Icc (I.face i))) fun x => f (i.insertNth (I.lower i) x) i))","decl":"/-- An auxiliary lemma for\n`MeasureTheory.integral_divergence_of_hasFDerivWithinAt_off_countable`. Compared to the previous\nlemma, here we drop the assumption of differentiability on the boundary of the box. -/\ntheorem integral_divergence_of_hasFDerivWithinAt_off_countable_aux₂ (I : Box (Fin (n + 1)))\n    (f : ℝⁿ⁺¹ → Eⁿ⁺¹)\n    (f' : ℝⁿ⁺¹ → ℝⁿ⁺¹ →L[ℝ] Eⁿ⁺¹)\n    (s : Set ℝⁿ⁺¹) (hs : s.Countable) (Hc : ContinuousOn f (Box.Icc I))\n    (Hd : ∀ x ∈ Box.Ioo I \\ s, HasFDerivAt f (f' x) x)\n    (Hi : IntegrableOn (∑ i, f' · (e i) i) (Box.Icc I)) :\n    (∫ x in Box.Icc I, ∑ i, f' x (e i) i) =\n      ∑ i : Fin (n + 1),\n        ((∫ x in Box.Icc (I.face i), f (i.insertNth (I.upper i) x) i) -\n          ∫ x in Box.Icc (I.face i), f (i.insertNth (I.lower i) x) i) := by\n  /- Choose a monotone sequence `J k` of subboxes that cover the interior of `I` and prove that\n    these boxes satisfy the assumptions of the previous lemma. -/\n  rcases I.exists_seq_mono_tendsto with ⟨J, hJ_sub, hJl, hJu⟩\n  have hJ_sub' : ∀ k, Box.Icc (J k) ⊆ Box.Icc I := fun k => (hJ_sub k).trans I.Ioo_subset_Icc\n  have hJ_le : ∀ k, J k ≤ I := fun k => Box.le_iff_Icc.2 (hJ_sub' k)\n  have HcJ : ∀ k, ContinuousOn f (Box.Icc (J k)) := fun k => Hc.mono (hJ_sub' k)\n  have HdJ : ∀ (k), ∀ x ∈ (Box.Icc (J k)) \\ s, HasFDerivWithinAt f (f' x) (Box.Icc (J k)) x :=\n    fun k x hx => (Hd x ⟨hJ_sub k hx.1, hx.2⟩).hasFDerivWithinAt\n  have HiJ : ∀ k, IntegrableOn (∑ i, f' · (e i) i) (Box.Icc (J k)) volume := fun k =>\n    Hi.mono_set (hJ_sub' k)\n  -- Apply the previous lemma to `J k`.\n  have HJ_eq := fun k =>\n    integral_divergence_of_hasFDerivWithinAt_off_countable_aux₁ (J k) f f' s hs (HcJ k) (HdJ k)\n      (HiJ k)\n  -- Note that the LHS of `HJ_eq k` tends to the LHS of the goal as `k → ∞`.\n  have hI_tendsto :\n    Tendsto (fun k => ∫ x in Box.Icc (J k), ∑ i, f' x (e i) i) atTop\n      (𝓝 (∫ x in Box.Icc I, ∑ i, f' x (e i) i)) := by\n    simp only [IntegrableOn, ← Measure.restrict_congr_set (Box.Ioo_ae_eq_Icc _)] at Hi ⊢\n    rw [← Box.iUnion_Ioo_of_tendsto J.monotone hJl hJu] at Hi ⊢\n    exact tendsto_setIntegral_of_monotone (fun k => (J k).measurableSet_Ioo)\n      (Box.Ioo.comp J).monotone Hi\n  -- Thus it suffices to prove the same about the RHS.\n  refine tendsto_nhds_unique_of_eventuallyEq hI_tendsto ?_ (Eventually.of_forall HJ_eq)\n  clear hI_tendsto\n  rw [tendsto_pi_nhds] at hJl hJu\n  /- We'll need to prove a similar statement about the integrals over the front sides and the\n    integrals over the back sides. In order to avoid repeating ourselves, we formulate a lemma. -/\n  suffices ∀ (i : Fin (n + 1)) (c : ℕ → ℝ) (d), (∀ k, c k ∈ Icc (I.lower i) (I.upper i)) →\n    Tendsto c atTop (𝓝 d) →\n      Tendsto (fun k => ∫ x in Box.Icc ((J k).face i), f (i.insertNth (c k) x) i) atTop\n        (𝓝 <| ∫ x in Box.Icc (I.face i), f (i.insertNth d x) i) by\n    rw [Box.Icc_eq_pi] at hJ_sub'\n    refine tendsto_finset_sum _ fun i _ => (this _ _ _ ?_ (hJu _)).sub (this _ _ _ ?_ (hJl _))\n    exacts [fun k => hJ_sub' k (J k).upper_mem_Icc _ trivial, fun k =>\n      hJ_sub' k (J k).lower_mem_Icc _ trivial]\n  intro i c d hc hcd\n  /- First we prove that the integrals of the restriction of `f` to `{x | x i = d}` over increasing\n    boxes `((J k).face i).Icc` tend to the desired limit. The proof mostly repeats the one above. -/\n  have hd : d ∈ Icc (I.lower i) (I.upper i) :=\n    isClosed_Icc.mem_of_tendsto hcd (Eventually.of_forall hc)\n  have Hic : ∀ k, IntegrableOn (fun x => f (i.insertNth (c k) x) i) (Box.Icc (I.face i)) := fun k =>\n    (Box.continuousOn_face_Icc ((continuous_apply i).comp_continuousOn Hc) (hc k)).integrableOn_Icc\n  have Hid : IntegrableOn (fun x => f (i.insertNth d x) i) (Box.Icc (I.face i)) :=\n    (Box.continuousOn_face_Icc ((continuous_apply i).comp_continuousOn Hc) hd).integrableOn_Icc\n  have H :\n    Tendsto (fun k => ∫ x in Box.Icc ((J k).face i), f (i.insertNth d x) i) atTop\n      (𝓝 <| ∫ x in Box.Icc (I.face i), f (i.insertNth d x) i) := by\n    have hIoo : (⋃ k, Box.Ioo ((J k).face i)) = Box.Ioo (I.face i) :=\n      Box.iUnion_Ioo_of_tendsto ((Box.monotone_face i).comp J.monotone)\n        (tendsto_pi_nhds.2 fun _ => hJl _) (tendsto_pi_nhds.2 fun _ => hJu _)\n    simp only [IntegrableOn, ← Measure.restrict_congr_set (Box.Ioo_ae_eq_Icc _), ← hIoo] at Hid ⊢\n    exact tendsto_setIntegral_of_monotone (fun k => ((J k).face i).measurableSet_Ioo)\n      (Box.Ioo.monotone.comp ((Box.monotone_face i).comp J.monotone)) Hid\n  /- Thus it suffices to show that the distance between the integrals of the restrictions of `f` to\n    `{x | x i = c k}` and `{x | x i = d}` over `((J k).face i).Icc` tends to zero as `k → ∞`. Choose\n    `ε > 0`. -/\n  refine H.congr_dist (Metric.nhds_basis_closedBall.tendsto_right_iff.2 fun ε εpos => ?_)\n  have hvol_pos : ∀ J : Box (Fin n), 0 < ∏ j, (J.upper j - J.lower j) := fun J =>\n    prod_pos fun j hj => sub_pos.2 <| J.lower_lt_upper _\n  /- Choose `δ > 0` such that for any `x y ∈ I.Icc` at distance at most `δ`, the distance between\n    `f x` and `f y` is at most `ε / volume (I.face i).Icc`, then the distance between the integrals\n    is at most `(ε / volume (I.face i).Icc) * volume ((J k).face i).Icc ≤ ε`. -/\n  rcases Metric.uniformContinuousOn_iff_le.1 (I.isCompact_Icc.uniformContinuousOn_of_continuous Hc)\n      (ε / ∏ j, ((I.face i).upper j - (I.face i).lower j)) (div_pos εpos (hvol_pos (I.face i)))\n    with ⟨δ, δpos, hδ⟩\n  refine (hcd.eventually (Metric.ball_mem_nhds _ δpos)).mono fun k hk => ?_\n  have Hsub : Box.Icc ((J k).face i) ⊆ Box.Icc (I.face i) :=\n    Box.le_iff_Icc.1 (Box.face_mono (hJ_le _) i)\n  rw [mem_closedBall_zero_iff, Real.norm_eq_abs, abs_of_nonneg dist_nonneg, dist_eq_norm,\n    ← integral_sub (Hid.mono_set Hsub) ((Hic _).mono_set Hsub)]\n  calc\n    ‖∫ x in Box.Icc ((J k).face i), f (i.insertNth d x) i - f (i.insertNth (c k) x) i‖ ≤\n        (ε / ∏ j, ((I.face i).upper j - (I.face i).lower j)) *\n          (volume (Box.Icc ((J k).face i))).toReal := by\n      refine norm_setIntegral_le_of_norm_le_const' (((J k).face i).measure_Icc_lt_top _)\n        ((J k).face i).measurableSet_Icc fun x hx => ?_\n      rw [← dist_eq_norm]\n      calc\n        dist (f (i.insertNth d x) i) (f (i.insertNth (c k) x) i) ≤\n            dist (f (i.insertNth d x)) (f (i.insertNth (c k) x)) :=\n          dist_le_pi_dist (f (i.insertNth d x)) (f (i.insertNth (c k) x)) i\n        _ ≤ ε / ∏ j, ((I.face i).upper j - (I.face i).lower j) :=\n          hδ _ (I.mapsTo_insertNth_face_Icc hd <| Hsub hx) _\n            (I.mapsTo_insertNth_face_Icc (hc _) <| Hsub hx) ?_\n      rw [Fin.dist_insertNth_insertNth, dist_self, dist_comm]\n      exact max_le hk.le δpos.lt.le\n    _ ≤ ε := by\n      rw [Box.Icc_def, Real.volume_Icc_pi_toReal ((J k).face i).lower_le_upper,\n        ← le_div_iff₀ (hvol_pos _)]\n      gcongr\n      exacts [hvol_pos _, fun _ _ ↦ sub_nonneg.2 (Box.lower_le_upper _ _),\n        (hJ_sub' _ (J _).upper_mem_Icc).2 _, (hJ_sub' _ (J _).lower_mem_Icc).1 _]\n\n"}
{"name":"MeasureTheory.integral_divergence_of_hasFDerivWithinAt_off_countable","module":"Mathlib.MeasureTheory.Integral.DivergenceTheorem","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nn : Nat\na b : Fin (HAdd.hAdd n 1) → Real\nhle : LE.le a b\nf : (Fin (HAdd.hAdd n 1) → Real) → Fin (HAdd.hAdd n 1) → E\nf' : (Fin (HAdd.hAdd n 1) → Real) → ContinuousLinearMap (RingHom.id Real) (Fin (HAdd.hAdd n 1) → Real) (Fin (HAdd.hAdd n 1) → E)\ns : Set (Fin (HAdd.hAdd n 1) → Real)\nhs : s.Countable\nHc : ContinuousOn f (Set.Icc a b)\nHd : ∀ (x : Fin (HAdd.hAdd n 1) → Real), Membership.mem (SDiff.sdiff (Set.univ.pi fun i => Set.Ioo (a i) (b i)) s) x → HasFDerivAt f (f' x) x\nHi : MeasureTheory.IntegrableOn (fun x => Finset.univ.sum fun i => (f' x) (Pi.single i 1) i) (Set.Icc a b) MeasureTheory.MeasureSpace.volume\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Icc a b)) fun x => Finset.univ.sum fun i => (f' x) (Pi.single i 1) i) (Finset.univ.sum fun i => HSub.hSub (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Icc (Function.comp a i.succAbove) (Function.comp b i.succAbove))) fun x => f (i.insertNth (b i) x) i) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Icc (Function.comp a i.succAbove) (Function.comp b i.succAbove))) fun x => f (i.insertNth (a i) x) i))","decl":"/-- **Divergence theorem** for Bochner integral. If `f : ℝⁿ⁺¹ → Eⁿ⁺¹` is continuous on a rectangular\nbox `[a, b] : Set ℝⁿ⁺¹`, `a ≤ b`, is differentiable on its interior with derivative\n`f' : ℝⁿ⁺¹ → ℝⁿ⁺¹ →L[ℝ] Eⁿ⁺¹` and the divergence `fun x ↦ ∑ i, f' x eᵢ i` is integrable on `[a, b]`,\nwhere `eᵢ = Pi.single i 1` is the `i`-th basis vector, then its integral is equal to the sum of\nintegrals of `f` over the faces of `[a, b]`, taken with appropriate signs.\n\nMoreover, the same is true if the function is not differentiable at countably many\npoints of the interior of `[a, b]`.\n\nWe represent both faces `x i = a i` and `x i = b i` as the box\n`face i = [a ∘ Fin.succAbove i, b ∘ Fin.succAbove i]` in `ℝⁿ`, where\n`Fin.succAbove : Fin n ↪o Fin (n + 1)` is the order embedding with range `{i}ᶜ`. The restrictions\nof `f : ℝⁿ⁺¹ → Eⁿ⁺¹` to these faces are given by `f ∘ backFace i` and `f ∘ frontFace i`, where\n`backFace i = Fin.insertNth i (a i)` and `frontFace i = Fin.insertNth i (b i)` are embeddings\n`ℝⁿ → ℝⁿ⁺¹` that take `y : ℝⁿ` and insert `a i` (resp., `b i`) as `i`-th coordinate. -/\ntheorem integral_divergence_of_hasFDerivWithinAt_off_countable (hle : a ≤ b)\n    (f : ℝⁿ⁺¹ → Eⁿ⁺¹)\n    (f' : ℝⁿ⁺¹ → ℝⁿ⁺¹ →L[ℝ] Eⁿ⁺¹)\n    (s : Set ℝⁿ⁺¹) (hs : s.Countable) (Hc : ContinuousOn f (Icc a b))\n    (Hd : ∀ x ∈ (Set.pi univ fun i => Ioo (a i) (b i)) \\ s, HasFDerivAt f (f' x) x)\n    (Hi : IntegrableOn (fun x => ∑ i, f' x (e i) i) (Icc a b)) :\n    (∫ x in Icc a b, ∑ i, f' x (e i) i) =\n      ∑ i : Fin (n + 1),\n        ((∫ x in face i, f (frontFace i x) i) - ∫ x in face i, f (backFace i x) i) := by\n  rcases em (∃ i, a i = b i) with (⟨i, hi⟩ | hne)\n  · -- First we sort out the trivial case `∃ i, a i = b i`.\n    rw [volume_pi, ← setIntegral_congr_set Measure.univ_pi_Ioc_ae_eq_Icc]\n    have hi' : Ioc (a i) (b i) = ∅ := Ioc_eq_empty hi.not_lt\n    have : (pi Set.univ fun j => Ioc (a j) (b j)) = ∅ := univ_pi_eq_empty hi'\n    rw [this, setIntegral_empty, sum_eq_zero]\n    rintro j -\n    rcases eq_or_ne i j with (rfl | hne)\n    · simp [hi]\n    · rcases Fin.exists_succAbove_eq hne with ⟨i, rfl⟩\n      have : Icc (a ∘ j.succAbove) (b ∘ j.succAbove) =ᵐ[volume] (∅ : Set ℝⁿ) := by\n        rw [ae_eq_empty, Real.volume_Icc_pi, prod_eq_zero (Finset.mem_univ i)]\n        simp [hi]\n      rw [setIntegral_congr_set this, setIntegral_congr_set this, setIntegral_empty,\n        setIntegral_empty, sub_self]\n  · -- In the non-trivial case `∀ i, a i < b i`, we apply a lemma we proved above.\n    have hlt : ∀ i, a i < b i := fun i => (hle i).lt_of_ne fun hi => hne ⟨i, hi⟩\n    exact integral_divergence_of_hasFDerivWithinAt_off_countable_aux₂ ⟨a, b, hlt⟩ f f' s hs Hc\n      Hd Hi\n\n"}
{"name":"MeasureTheory.integral_divergence_of_hasFDerivWithinAt_off_countable'","module":"Mathlib.MeasureTheory.Integral.DivergenceTheorem","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nn : Nat\na b : Fin (HAdd.hAdd n 1) → Real\nhle : LE.le a b\nf : Fin (HAdd.hAdd n 1) → (Fin (HAdd.hAdd n 1) → Real) → E\nf' : Fin (HAdd.hAdd n 1) → (Fin (HAdd.hAdd n 1) → Real) → ContinuousLinearMap (RingHom.id Real) (Fin (HAdd.hAdd n 1) → Real) E\ns : Set (Fin (HAdd.hAdd n 1) → Real)\nhs : s.Countable\nHc : ∀ (i : Fin (HAdd.hAdd n 1)), ContinuousOn (f i) (Set.Icc a b)\nHd : ∀ (x : Fin (HAdd.hAdd n 1) → Real), Membership.mem (SDiff.sdiff (Set.univ.pi fun i => Set.Ioo (a i) (b i)) s) x → ∀ (i : Fin (HAdd.hAdd n 1)), HasFDerivAt (f i) (f' i x) x\nHi : MeasureTheory.IntegrableOn (fun x => Finset.univ.sum fun i => (f' i x) (Pi.single i 1)) (Set.Icc a b) MeasureTheory.MeasureSpace.volume\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Icc a b)) fun x => Finset.univ.sum fun i => (f' i x) (Pi.single i 1)) (Finset.univ.sum fun i => HSub.hSub (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Icc (Function.comp a i.succAbove) (Function.comp b i.succAbove))) fun x => f i (i.insertNth (b i) x)) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Icc (Function.comp a i.succAbove) (Function.comp b i.succAbove))) fun x => f i (i.insertNth (a i) x)))","decl":"/-- **Divergence theorem** for a family of functions `f : Fin (n + 1) → ℝⁿ⁺¹ → E`. See also\n`MeasureTheory.integral_divergence_of_hasFDerivWithinAt_off_countable'` for a version formulated\nin terms of a vector-valued function `f : ℝⁿ⁺¹ → Eⁿ⁺¹`. -/\ntheorem integral_divergence_of_hasFDerivWithinAt_off_countable' (hle : a ≤ b)\n    (f : Fin (n + 1) → ℝⁿ⁺¹ → E)\n    (f' : Fin (n + 1) → ℝⁿ⁺¹ → ℝⁿ⁺¹ →L[ℝ] E) (s : Set ℝⁿ⁺¹)\n    (hs : s.Countable) (Hc : ∀ i, ContinuousOn (f i) (Icc a b))\n    (Hd : ∀ x ∈ (pi Set.univ fun i => Ioo (a i) (b i)) \\ s, ∀ (i), HasFDerivAt (f i) (f' i x) x)\n    (Hi : IntegrableOn (fun x => ∑ i, f' i x (e i)) (Icc a b)) :\n    (∫ x in Icc a b, ∑ i, f' i x (e i)) =\n      ∑ i : Fin (n + 1), ((∫ x in face i, f i (frontFace i x)) -\n        ∫ x in face i, f i (backFace i x)) :=\n  integral_divergence_of_hasFDerivWithinAt_off_countable a b hle (fun x i => f i x)\n    (fun x => ContinuousLinearMap.pi fun i => f' i x) s hs (continuousOn_pi.2 Hc)\n    (fun x hx => hasFDerivAt_pi.2 (Hd x hx)) Hi\n\n"}
{"name":"MeasureTheory.integral_divergence_of_hasFDerivWithinAt_off_countable_of_equiv","module":"Mathlib.MeasureTheory.Integral.DivergenceTheorem","initialProofState":"E : Type u\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\ninst✝⁵ : CompleteSpace E\nn : Nat\nF : Type u_1\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace Real F\ninst✝² : PartialOrder F\ninst✝¹ : MeasureTheory.MeasureSpace F\ninst✝ : BorelSpace F\neL : ContinuousLinearEquiv (RingHom.id Real) F (Fin (HAdd.hAdd n 1) → Real)\nhe_ord : ∀ (x y : F), Iff (LE.le (eL x) (eL y)) (LE.le x y)\nhe_vol : MeasureTheory.MeasurePreserving (⇑eL) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\nf : Fin (HAdd.hAdd n 1) → F → E\nf' : Fin (HAdd.hAdd n 1) → F → ContinuousLinearMap (RingHom.id Real) F E\ns : Set F\nhs : s.Countable\na b : F\nhle : LE.le a b\nHc : ∀ (i : Fin (HAdd.hAdd n 1)), ContinuousOn (f i) (Set.Icc a b)\nHd : ∀ (x : F), Membership.mem (SDiff.sdiff (interior (Set.Icc a b)) s) x → ∀ (i : Fin (HAdd.hAdd n 1)), HasFDerivAt (f i) (f' i x) x\nDF : F → E\nhDF : ∀ (x : F), Eq (DF x) (Finset.univ.sum fun i => (f' i x) (eL.symm (Pi.single i 1)))\nHi : MeasureTheory.IntegrableOn DF (Set.Icc a b) MeasureTheory.MeasureSpace.volume\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Icc a b)) fun x => DF x) (Finset.univ.sum fun i => HSub.hSub (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Icc (Function.comp (eL a) i.succAbove) (Function.comp (eL b) i.succAbove))) fun x => f i (eL.symm (i.insertNth (eL b i) x))) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Icc (Function.comp (eL a) i.succAbove) (Function.comp (eL b) i.succAbove))) fun x => f i (eL.symm (i.insertNth (eL a i) x))))","decl":"/-- An auxiliary lemma that is used to specialize the general divergence theorem to spaces that do\nnot have the form `Fin n → ℝ`. -/\ntheorem integral_divergence_of_hasFDerivWithinAt_off_countable_of_equiv {F : Type*}\n    [NormedAddCommGroup F] [NormedSpace ℝ F] [PartialOrder F] [MeasureSpace F] [BorelSpace F]\n    (eL : F ≃L[ℝ] ℝⁿ⁺¹) (he_ord : ∀ x y, eL x ≤ eL y ↔ x ≤ y)\n    (he_vol : MeasurePreserving eL volume volume) (f : Fin (n + 1) → F → E)\n    (f' : Fin (n + 1) → F → F →L[ℝ] E) (s : Set F) (hs : s.Countable) (a b : F) (hle : a ≤ b)\n    (Hc : ∀ i, ContinuousOn (f i) (Icc a b))\n    (Hd : ∀ x ∈ interior (Icc a b) \\ s, ∀ (i), HasFDerivAt (f i) (f' i x) x) (DF : F → E)\n    (hDF : ∀ x, DF x = ∑ i, f' i x (eL.symm <| e i)) (Hi : IntegrableOn DF (Icc a b)) :\n    ∫ x in Icc a b, DF x =\n      ∑ i : Fin (n + 1),\n        ((∫ x in Icc (eL a ∘ i.succAbove) (eL b ∘ i.succAbove),\n            f i (eL.symm <| i.insertNth (eL b i) x)) -\n          ∫ x in Icc (eL a ∘ i.succAbove) (eL b ∘ i.succAbove),\n            f i (eL.symm <| i.insertNth (eL a i) x)) :=\n  have he_emb : MeasurableEmbedding eL := eL.toHomeomorph.measurableEmbedding\n  have hIcc : eL ⁻¹' Icc (eL a) (eL b) = Icc a b := by\n    ext1 x; simp only [Set.mem_preimage, Set.mem_Icc, he_ord]\n  have hIcc' : Icc (eL a) (eL b) = eL.symm ⁻¹' Icc a b := by rw [← hIcc, eL.symm_preimage_preimage]\n  calc\n    ∫ x in Icc a b, DF x = ∫ x in Icc a b, ∑ i, f' i x (eL.symm <| e i) := by simp only [hDF]\n    _ = ∫ x in Icc (eL a) (eL b), ∑ i, f' i (eL.symm x) (eL.symm <| e i) := by\n      rw [← he_vol.setIntegral_preimage_emb he_emb]\n      simp only [hIcc, eL.symm_apply_apply]\n    _ = ∑ i : Fin (n + 1),\n          ((∫ x in Icc (eL a ∘ i.succAbove) (eL b ∘ i.succAbove),\n              f i (eL.symm <| i.insertNth (eL b i) x)) -\n            ∫ x in Icc (eL a ∘ i.succAbove) (eL b ∘ i.succAbove),\n              f i (eL.symm <| i.insertNth (eL a i) x)) := by\n      refine integral_divergence_of_hasFDerivWithinAt_off_countable' (eL a) (eL b)\n        ((he_ord _ _).2 hle) (fun i x => f i (eL.symm x))\n        (fun i x => f' i (eL.symm x) ∘L (eL.symm : ℝⁿ⁺¹ →L[ℝ] F)) (eL.symm ⁻¹' s)\n        (hs.preimage eL.symm.injective) ?_ ?_ ?_\n      · exact fun i => (Hc i).comp eL.symm.continuousOn hIcc'.subset\n      · refine fun x hx i => (Hd (eL.symm x) ⟨?_, hx.2⟩ i).comp x eL.symm.hasFDerivAt\n        rw [← hIcc]\n        refine preimage_interior_subset_interior_preimage eL.continuous ?_\n        simpa only [Set.mem_preimage, eL.apply_symm_apply, ← pi_univ_Icc,\n          interior_pi_set (@finite_univ (Fin _) _), interior_Icc] using hx.1\n      · rw [← he_vol.integrableOn_comp_preimage he_emb, hIcc]\n        simp [← hDF, Function.comp_def, Hi]\n\n"}
{"name":"MeasureTheory.integral_eq_of_hasDerivWithinAt_off_countable_of_le","module":"Mathlib.MeasureTheory.Integral.DivergenceTheorem","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nf f' : Real → E\na b : Real\nhle : LE.le a b\ns : Set Real\nhs : s.Countable\nHc : ContinuousOn f (Set.Icc a b)\nHd : ∀ (x : Real), Membership.mem (SDiff.sdiff (Set.Ioo a b) s) x → HasDerivAt f (f' x) x\nHi : IntervalIntegrable f' MeasureTheory.MeasureSpace.volume a b\n⊢ Eq (intervalIntegral (fun x => f' x) a b MeasureTheory.MeasureSpace.volume) (HSub.hSub (f b) (f a))","decl":"/-- **Fundamental theorem of calculus, part 2**. This version assumes that `f` is continuous on the\ninterval and is differentiable off a countable set `s`.\n\nSee also\n\n* `intervalIntegral.integral_eq_sub_of_hasDeriv_right_of_le` for a version that only assumes right\ndifferentiability of `f`;\n\n* `MeasureTheory.integral_eq_of_hasDerivWithinAt_off_countable` for a version that works both\n  for `a ≤ b` and `b ≤ a` at the expense of using unordered intervals instead of `Set.Icc`. -/\ntheorem integral_eq_of_hasDerivWithinAt_off_countable_of_le (f f' : ℝ → E) {a b : ℝ}\n    (hle : a ≤ b) {s : Set ℝ} (hs : s.Countable) (Hc : ContinuousOn f (Icc a b))\n    (Hd : ∀ x ∈ Ioo a b \\ s, HasDerivAt f (f' x) x) (Hi : IntervalIntegrable f' volume a b) :\n    ∫ x in a..b, f' x = f b - f a := by\n  set e : ℝ ≃L[ℝ] ℝ¹ := (ContinuousLinearEquiv.funUnique (Fin 1) ℝ ℝ).symm\n  have e_symm : ∀ x, e.symm x = x 0 := fun x => rfl\n  set F' : ℝ → ℝ →L[ℝ] E := fun x => smulRight (1 : ℝ →L[ℝ] ℝ) (f' x)\n  have hF' : ∀ x y, F' x y = y • f' x := fun x y => rfl\n  calc\n    ∫ x in a..b, f' x = ∫ x in Icc a b, f' x := by\n      rw [intervalIntegral.integral_of_le hle, setIntegral_congr_set Ioc_ae_eq_Icc]\n    _ = ∑ i : Fin 1,\n          ((∫ x in Icc (e a ∘ i.succAbove) (e b ∘ i.succAbove),\n              f (e.symm <| i.insertNth (e b i) x)) -\n            ∫ x in Icc (e a ∘ i.succAbove) (e b ∘ i.succAbove),\n              f (e.symm <| i.insertNth (e a i) x)) := by\n      simp only [← interior_Icc] at Hd\n      refine\n        integral_divergence_of_hasFDerivWithinAt_off_countable_of_equiv e ?_ ?_ (fun _ => f)\n          (fun _ => F') s hs a b hle (fun _ => Hc) (fun x hx _ => Hd x hx) _ ?_ ?_\n      · exact fun x y => (OrderIso.funUnique (Fin 1) ℝ).symm.le_iff_le\n      · exact (volume_preserving_funUnique (Fin 1) ℝ).symm _\n      · intro x; rw [Fin.sum_univ_one, hF', e_symm, Pi.single_eq_same, one_smul]\n      · rw [intervalIntegrable_iff_integrableOn_Ioc_of_le hle] at Hi\n        exact Hi.congr_set_ae Ioc_ae_eq_Icc.symm\n    _ = f b - f a := by\n      simp only [e, Fin.sum_univ_one, e_symm]\n      have : ∀ c : ℝ, const (Fin 0) c = isEmptyElim := fun c => Subsingleton.elim _ _\n      simp [this, volume_pi, Measure.pi_of_empty fun _ : Fin 0 => volume]\n\n"}
{"name":"MeasureTheory.integral_eq_of_hasDerivWithinAt_off_countable","module":"Mathlib.MeasureTheory.Integral.DivergenceTheorem","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nf f' : Real → E\na b : Real\ns : Set Real\nhs : s.Countable\nHc : ContinuousOn f (Set.uIcc a b)\nHd : ∀ (x : Real), Membership.mem (SDiff.sdiff (Set.Ioo (Min.min a b) (Max.max a b)) s) x → HasDerivAt f (f' x) x\nHi : IntervalIntegrable f' MeasureTheory.MeasureSpace.volume a b\n⊢ Eq (intervalIntegral (fun x => f' x) a b MeasureTheory.MeasureSpace.volume) (HSub.hSub (f b) (f a))","decl":"/-- **Fundamental theorem of calculus, part 2**. This version assumes that `f` is continuous on the\ninterval and is differentiable off a countable set `s`.\n\nSee also `intervalIntegral.integral_eq_sub_of_hasDeriv_right` for a version that\nonly assumes right differentiability of `f`.\n-/\ntheorem integral_eq_of_hasDerivWithinAt_off_countable (f f' : ℝ → E) {a b : ℝ} {s : Set ℝ}\n    (hs : s.Countable) (Hc : ContinuousOn f [[a, b]])\n    (Hd : ∀ x ∈ Ioo (min a b) (max a b) \\ s, HasDerivAt f (f' x) x)\n    (Hi : IntervalIntegrable f' volume a b) : ∫ x in a..b, f' x = f b - f a := by\n  rcases le_total a b with hab | hab\n  · simp only [uIcc_of_le hab, min_eq_left hab, max_eq_right hab] at *\n    exact integral_eq_of_hasDerivWithinAt_off_countable_of_le f f' hab hs Hc Hd Hi\n  · simp only [uIcc_of_ge hab, min_eq_right hab, max_eq_left hab] at *\n    rw [intervalIntegral.integral_symm, neg_eq_iff_eq_neg, neg_sub]\n    exact integral_eq_of_hasDerivWithinAt_off_countable_of_le f f' hab hs Hc Hd Hi.symm\n\n"}
{"name":"MeasureTheory.integral_divergence_prod_Icc_of_hasFDerivWithinAt_off_countable_of_le","module":"Mathlib.MeasureTheory.Integral.DivergenceTheorem","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nf g : Prod Real Real → E\nf' g' : Prod Real Real → ContinuousLinearMap (RingHom.id Real) (Prod Real Real) E\na b : Prod Real Real\nhle : LE.le a b\ns : Set (Prod Real Real)\nhs : s.Countable\nHcf : ContinuousOn f (Set.Icc a b)\nHcg : ContinuousOn g (Set.Icc a b)\nHdf : ∀ (x : Prod Real Real), Membership.mem (SDiff.sdiff (SProd.sprod (Set.Ioo a.1 b.1) (Set.Ioo a.2 b.2)) s) x → HasFDerivAt f (f' x) x\nHdg : ∀ (x : Prod Real Real), Membership.mem (SDiff.sdiff (SProd.sprod (Set.Ioo a.1 b.1) (Set.Ioo a.2 b.2)) s) x → HasFDerivAt g (g' x) x\nHi : MeasureTheory.IntegrableOn (fun x => HAdd.hAdd ((f' x) { fst := 1, snd := 0 }) ((g' x) { fst := 0, snd := 1 })) (Set.Icc a b) MeasureTheory.MeasureSpace.volume\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Icc a b)) fun x => HAdd.hAdd ((f' x) { fst := 1, snd := 0 }) ((g' x) { fst := 0, snd := 1 })) (HSub.hSub (HAdd.hAdd (HSub.hSub (intervalIntegral (fun x => g { fst := x, snd := b.2 }) a.1 b.1 MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => g { fst := x, snd := a.2 }) a.1 b.1 MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun y => f { fst := b.1, snd := y }) a.2 b.2 MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun y => f { fst := a.1, snd := y }) a.2 b.2 MeasureTheory.MeasureSpace.volume))","decl":"/-- **Divergence theorem** for functions on the plane along rectangles. It is formulated in terms of\ntwo functions `f g : ℝ × ℝ → E` and an integral over `Icc a b = [a.1, b.1] × [a.2, b.2]`, where\n`a b : ℝ × ℝ`, `a ≤ b`. When thinking of `f` and `g` as the two coordinates of a single function\n`F : ℝ × ℝ → E × E` and when `E = ℝ`, this is the usual statement that the integral of the\ndivergence of `F` inside the rectangle equals the integral of the normal derivative of `F` along the\nboundary.\n\nSee also `MeasureTheory.integral2_divergence_prod_of_hasFDerivWithinAt_off_countable` for a\nversion that does not assume `a ≤ b` and uses iterated interval integral instead of the integral\nover `Icc a b`. -/\ntheorem integral_divergence_prod_Icc_of_hasFDerivWithinAt_off_countable_of_le (f g : ℝ × ℝ → E)\n    (f' g' : ℝ × ℝ → ℝ × ℝ →L[ℝ] E) (a b : ℝ × ℝ) (hle : a ≤ b) (s : Set (ℝ × ℝ)) (hs : s.Countable)\n    (Hcf : ContinuousOn f (Icc a b)) (Hcg : ContinuousOn g (Icc a b))\n    (Hdf : ∀ x ∈ Ioo a.1 b.1 ×ˢ Ioo a.2 b.2 \\ s, HasFDerivAt f (f' x) x)\n    (Hdg : ∀ x ∈ Ioo a.1 b.1 ×ˢ Ioo a.2 b.2 \\ s, HasFDerivAt g (g' x) x)\n    (Hi : IntegrableOn (fun x => f' x (1, 0) + g' x (0, 1)) (Icc a b)) :\n    (∫ x in Icc a b, f' x (1, 0) + g' x (0, 1)) =\n      (((∫ x in a.1..b.1, g (x, b.2)) - ∫ x in a.1..b.1, g (x, a.2)) +\n          ∫ y in a.2..b.2, f (b.1, y)) -\n        ∫ y in a.2..b.2, f (a.1, y) :=\n  let e : (ℝ × ℝ) ≃L[ℝ] ℝ² := (ContinuousLinearEquiv.finTwoArrow ℝ ℝ).symm\n  calc\n    (∫ x in Icc a b, f' x (1, 0) + g' x (0, 1)) =\n        ∑ i : Fin 2,\n          ((∫ x in Icc (e a ∘ i.succAbove) (e b ∘ i.succAbove),\n              ![f, g] i (e.symm <| i.insertNth (e b i) x)) -\n            ∫ x in Icc (e a ∘ i.succAbove) (e b ∘ i.succAbove),\n              ![f, g] i (e.symm <| i.insertNth (e a i) x)) := by\n      refine integral_divergence_of_hasFDerivWithinAt_off_countable_of_equiv e ?_ ?_ ![f, g]\n        ![f', g'] s hs a b hle ?_ (fun x hx => ?_) _ ?_ Hi\n      · exact fun x y => (OrderIso.finTwoArrowIso ℝ).symm.le_iff_le\n      · exact (volume_preserving_finTwoArrow ℝ).symm _\n      · exact Fin.forall_fin_two.2 ⟨Hcf, Hcg⟩\n      · rw [Icc_prod_eq, interior_prod_eq, interior_Icc, interior_Icc] at hx\n        exact Fin.forall_fin_two.2 ⟨Hdf x hx, Hdg x hx⟩\n      · intro x; rw [Fin.sum_univ_two]; rfl\n    _ = ((∫ y in Icc a.2 b.2, f (b.1, y)) - ∫ y in Icc a.2 b.2, f (a.1, y)) +\n          ((∫ x in Icc a.1 b.1, g (x, b.2)) - ∫ x in Icc a.1 b.1, g (x, a.2)) := by\n      have : ∀ (a b : ℝ¹) (f : ℝ¹ → E),\n          ∫ x in Icc a b, f x = ∫ x in Icc (a 0) (b 0), f fun _ => x := fun a b f ↦ by\n        convert (((volume_preserving_funUnique (Fin 1) ℝ).symm _).setIntegral_preimage_emb\n          (MeasurableEquiv.measurableEmbedding _) f _).symm\n        exact ((OrderIso.funUnique (Fin 1) ℝ).symm.preimage_Icc a b).symm\n      simp only [Fin.sum_univ_two, this]\n      rfl\n    _ = (((∫ x in a.1..b.1, g (x, b.2)) - ∫ x in a.1..b.1, g (x, a.2)) +\n            ∫ y in a.2..b.2, f (b.1, y)) - ∫ y in a.2..b.2, f (a.1, y) := by\n      simp only [intervalIntegral.integral_of_le hle.1, intervalIntegral.integral_of_le hle.2,\n        setIntegral_congr_set (Ioc_ae_eq_Icc (α := ℝ) (μ := volume))]\n      abel\n\n"}
{"name":"MeasureTheory.integral2_divergence_prod_of_hasFDerivWithinAt_off_countable","module":"Mathlib.MeasureTheory.Integral.DivergenceTheorem","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nf g : Prod Real Real → E\nf' g' : Prod Real Real → ContinuousLinearMap (RingHom.id Real) (Prod Real Real) E\na₁ a₂ b₁ b₂ : Real\ns : Set (Prod Real Real)\nhs : s.Countable\nHcf : ContinuousOn f (SProd.sprod (Set.uIcc a₁ b₁) (Set.uIcc a₂ b₂))\nHcg : ContinuousOn g (SProd.sprod (Set.uIcc a₁ b₁) (Set.uIcc a₂ b₂))\nHdf : ∀ (x : Prod Real Real), Membership.mem (SDiff.sdiff (SProd.sprod (Set.Ioo (Min.min a₁ b₁) (Max.max a₁ b₁)) (Set.Ioo (Min.min a₂ b₂) (Max.max a₂ b₂))) s) x → HasFDerivAt f (f' x) x\nHdg : ∀ (x : Prod Real Real), Membership.mem (SDiff.sdiff (SProd.sprod (Set.Ioo (Min.min a₁ b₁) (Max.max a₁ b₁)) (Set.Ioo (Min.min a₂ b₂) (Max.max a₂ b₂))) s) x → HasFDerivAt g (g' x) x\nHi : MeasureTheory.IntegrableOn (fun x => HAdd.hAdd ((f' x) { fst := 1, snd := 0 }) ((g' x) { fst := 0, snd := 1 })) (SProd.sprod (Set.uIcc a₁ b₁) (Set.uIcc a₂ b₂)) MeasureTheory.MeasureSpace.volume\n⊢ Eq (intervalIntegral (fun x => intervalIntegral (fun y => HAdd.hAdd ((f' { fst := x, snd := y }) { fst := 1, snd := 0 }) ((g' { fst := x, snd := y }) { fst := 0, snd := 1 })) a₂ b₂ MeasureTheory.MeasureSpace.volume) a₁ b₁ MeasureTheory.MeasureSpace.volume) (HSub.hSub (HAdd.hAdd (HSub.hSub (intervalIntegral (fun x => g { fst := x, snd := b₂ }) a₁ b₁ MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => g { fst := x, snd := a₂ }) a₁ b₁ MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun y => f { fst := b₁, snd := y }) a₂ b₂ MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun y => f { fst := a₁, snd := y }) a₂ b₂ MeasureTheory.MeasureSpace.volume))","decl":"/-- **Divergence theorem** for functions on the plane. It is formulated in terms of two functions\n`f g : ℝ × ℝ → E` and iterated integral `∫ x in a₁..b₁, ∫ y in a₂..b₂, _`, where\n`a₁ a₂ b₁ b₂ : ℝ`. When thinking of `f` and `g` as the two coordinates of a single function\n`F : ℝ × ℝ → E × E` and when `E = ℝ`, this is the usual statement that the integral of the\ndivergence of `F` inside the rectangle with vertices `(aᵢ, bⱼ)`, `i, j =1,2`, equals the integral of\nthe normal derivative of `F` along the boundary.\n\nSee also `MeasureTheory.integral_divergence_prod_Icc_of_hasFDerivWithinAt_off_countable_of_le`\nfor a version that uses an integral over `Icc a b`, where `a b : ℝ × ℝ`, `a ≤ b`. -/\ntheorem integral2_divergence_prod_of_hasFDerivWithinAt_off_countable (f g : ℝ × ℝ → E)\n    (f' g' : ℝ × ℝ → ℝ × ℝ →L[ℝ] E) (a₁ a₂ b₁ b₂ : ℝ) (s : Set (ℝ × ℝ)) (hs : s.Countable)\n    (Hcf : ContinuousOn f ([[a₁, b₁]] ×ˢ [[a₂, b₂]]))\n    (Hcg : ContinuousOn g ([[a₁, b₁]] ×ˢ [[a₂, b₂]]))\n    (Hdf : ∀ x ∈ Ioo (min a₁ b₁) (max a₁ b₁) ×ˢ Ioo (min a₂ b₂) (max a₂ b₂) \\ s,\n      HasFDerivAt f (f' x) x)\n    (Hdg : ∀ x ∈ Ioo (min a₁ b₁) (max a₁ b₁) ×ˢ Ioo (min a₂ b₂) (max a₂ b₂) \\ s,\n      HasFDerivAt g (g' x) x)\n    (Hi : IntegrableOn (fun x => f' x (1, 0) + g' x (0, 1)) ([[a₁, b₁]] ×ˢ [[a₂, b₂]])) :\n    (∫ x in a₁..b₁, ∫ y in a₂..b₂, f' (x, y) (1, 0) + g' (x, y) (0, 1)) =\n      (((∫ x in a₁..b₁, g (x, b₂)) - ∫ x in a₁..b₁, g (x, a₂)) + ∫ y in a₂..b₂, f (b₁, y)) -\n        ∫ y in a₂..b₂, f (a₁, y) := by\n  wlog h₁ : a₁ ≤ b₁ generalizing a₁ b₁\n  · specialize this b₁ a₁\n    rw [uIcc_comm b₁ a₁, min_comm b₁ a₁, max_comm b₁ a₁] at this\n    simp only [intervalIntegral.integral_symm b₁ a₁]\n    refine (congr_arg Neg.neg (this Hcf Hcg Hdf Hdg Hi (le_of_not_le h₁))).trans ?_; abel\n  wlog h₂ : a₂ ≤ b₂ generalizing a₂ b₂\n  · specialize this b₂ a₂\n    rw [uIcc_comm b₂ a₂, min_comm b₂ a₂, max_comm b₂ a₂] at this\n    simp only [intervalIntegral.integral_symm b₂ a₂, intervalIntegral.integral_neg]\n    refine (congr_arg Neg.neg (this Hcf Hcg Hdf Hdg Hi (le_of_not_le h₂))).trans ?_; abel\n  simp only [uIcc_of_le h₁, uIcc_of_le h₂, min_eq_left, max_eq_right, h₁, h₂] at Hcf Hcg Hdf Hdg Hi\n  calc\n    (∫ x in a₁..b₁, ∫ y in a₂..b₂, f' (x, y) (1, 0) + g' (x, y) (0, 1)) =\n        ∫ x in Icc a₁ b₁, ∫ y in Icc a₂ b₂, f' (x, y) (1, 0) + g' (x, y) (0, 1) := by\n      simp only [intervalIntegral.integral_of_le, h₁, h₂,\n        setIntegral_congr_set (Ioc_ae_eq_Icc (α := ℝ) (μ := volume))]\n    _ = ∫ x in Icc a₁ b₁ ×ˢ Icc a₂ b₂, f' x (1, 0) + g' x (0, 1) := (setIntegral_prod _ Hi).symm\n    _ = (((∫ x in a₁..b₁, g (x, b₂)) - ∫ x in a₁..b₁, g (x, a₂)) + ∫ y in a₂..b₂, f (b₁, y)) -\n          ∫ y in a₂..b₂, f (a₁, y) := by\n      rw [Icc_prod_Icc] at *\n      apply integral_divergence_prod_Icc_of_hasFDerivWithinAt_off_countable_of_le f g f' g'\n        (a₁, a₂) (b₁, b₂) ⟨h₁, h₂⟩ s <;> assumption\n\n"}
