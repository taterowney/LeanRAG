{"name":"DFinsupp.infinite_of_left","module":"Mathlib.Data.DFinsupp.FiniteInfinite","initialProofState":"ι : Type u_1\nπ : ι → Type u_2\ninst✝² : ∀ (i : ι), Nontrivial (π i)\ninst✝¹ : (i : ι) → Zero (π i)\ninst✝ : Infinite ι\n⊢ Infinite (DFinsupp fun i => π i)","decl":"instance DFinsupp.infinite_of_left {ι : Sort _} {π : ι → Sort _} [∀ i, Nontrivial (π i)]\n    [∀ i, Zero (π i)] [Infinite ι] : Infinite (Π₀ i, π i) := by\n  letI := Classical.decEq ι; choose m hm using fun i => exists_ne (0 : π i)\n  exact Infinite.of_injective _ (DFinsupp.single_left_injective hm)\n\n"}
{"name":"DFinsupp.infinite_of_exists_right","module":"Mathlib.Data.DFinsupp.FiniteInfinite","initialProofState":"ι : Type u_1\nπ : ι → Type u_2\ni : ι\ninst✝¹ : Infinite (π i)\ninst✝ : (i : ι) → Zero (π i)\n⊢ Infinite (DFinsupp fun i => π i)","decl":"/-- See `DFinsupp.infinite_of_right` for this in instance form, with the drawback that\nit needs all `π i` to be infinite. -/\ntheorem DFinsupp.infinite_of_exists_right {ι : Sort _} {π : ι → Sort _} (i : ι) [Infinite (π i)]\n    [∀ i, Zero (π i)] : Infinite (Π₀ i, π i) :=\n  letI := Classical.decEq ι\n  Infinite.of_injective (fun j => DFinsupp.single i j) DFinsupp.single_injective\n\n"}
{"name":"DFinsupp.infinite_of_right","module":"Mathlib.Data.DFinsupp.FiniteInfinite","initialProofState":"ι : Type u_1\nπ : ι → Type u_2\ninst✝² : ∀ (i : ι), Infinite (π i)\ninst✝¹ : (i : ι) → Zero (π i)\ninst✝ : Nonempty ι\n⊢ Infinite (DFinsupp fun i => π i)","decl":"/-- See `DFinsupp.infinite_of_exists_right` for the case that only one `π ι` is infinite. -/\ninstance DFinsupp.infinite_of_right {ι : Sort _} {π : ι → Sort _} [∀ i, Infinite (π i)]\n    [∀ i, Zero (π i)] [Nonempty ι] : Infinite (Π₀ i, π i) :=\n  DFinsupp.infinite_of_exists_right (Classical.arbitrary ι)\n\n"}
