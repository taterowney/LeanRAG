{"name":"NFA.mk.inj","module":"Mathlib.Computability.NFA","initialProofState":"α : Type u\nσ : Type v\nstep✝ : σ → α → Set σ\nstart✝ accept✝ : Set σ\nstep : σ → α → Set σ\nstart accept : Set σ\nx✝ : Eq { step := step✝, start := start✝, accept := accept✝ } { step := step, start := start, accept := accept }\n⊢ And (Eq step✝ step) (And (Eq start✝ start) (Eq accept✝ accept))","decl":"/-- An NFA is a set of states (`σ`), a transition function from state to state labelled by the\n  alphabet (`step`), a set of starting states (`start`) and a set of acceptance states (`accept`).\n  Note the transition function sends a state to a `Set` of states. These are the states that it\n  may be sent to. -/\nstructure NFA (α : Type u) (σ : Type v) where\n  step : σ → α → Set σ\n  start : Set σ\n  accept : Set σ\n\n"}
{"name":"NFA.mk.sizeOf_spec","module":"Mathlib.Computability.NFA","initialProofState":"α : Type u\nσ : Type v\ninst✝¹ : SizeOf α\ninst✝ : SizeOf σ\nstep : σ → α → Set σ\nstart accept : Set σ\n⊢ Eq (SizeOf.sizeOf { step := step, start := start, accept := accept }) 1","decl":"/-- An NFA is a set of states (`σ`), a transition function from state to state labelled by the\n  alphabet (`step`), a set of starting states (`start`) and a set of acceptance states (`accept`).\n  Note the transition function sends a state to a `Set` of states. These are the states that it\n  may be sent to. -/\nstructure NFA (α : Type u) (σ : Type v) where\n  step : σ → α → Set σ\n  start : Set σ\n  accept : Set σ\n\n"}
{"name":"NFA.mk.injEq","module":"Mathlib.Computability.NFA","initialProofState":"α : Type u\nσ : Type v\nstep✝ : σ → α → Set σ\nstart✝ accept✝ : Set σ\nstep : σ → α → Set σ\nstart accept : Set σ\n⊢ Eq (Eq { step := step✝, start := start✝, accept := accept✝ } { step := step, start := start, accept := accept }) (And (Eq step✝ step) (And (Eq start✝ start) (Eq accept✝ accept)))","decl":"/-- An NFA is a set of states (`σ`), a transition function from state to state labelled by the\n  alphabet (`step`), a set of starting states (`start`) and a set of acceptance states (`accept`).\n  Note the transition function sends a state to a `Set` of states. These are the states that it\n  may be sent to. -/\nstructure NFA (α : Type u) (σ : Type v) where\n  step : σ → α → Set σ\n  start : Set σ\n  accept : Set σ\n\n"}
{"name":"NFA.mem_stepSet","module":"Mathlib.Computability.NFA","initialProofState":"α : Type u\nσ : Type v\nM : NFA α σ\ns : σ\nS : Set σ\na : α\n⊢ Iff (Membership.mem (M.stepSet S a) s) (Exists fun t => And (Membership.mem S t) (Membership.mem (M.step t a) s))","decl":"theorem mem_stepSet (s : σ) (S : Set σ) (a : α) : s ∈ M.stepSet S a ↔ ∃ t ∈ S, s ∈ M.step t a := by\n  simp [stepSet]\n\n"}
{"name":"NFA.stepSet_empty","module":"Mathlib.Computability.NFA","initialProofState":"α : Type u\nσ : Type v\nM : NFA α σ\na : α\n⊢ Eq (M.stepSet EmptyCollection.emptyCollection a) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem stepSet_empty (a : α) : M.stepSet ∅ a = ∅ := by simp [stepSet]\n\n"}
{"name":"NFA.evalFrom_nil","module":"Mathlib.Computability.NFA","initialProofState":"α : Type u\nσ : Type v\nM : NFA α σ\nS : Set σ\n⊢ Eq (M.evalFrom S List.nil) S","decl":"@[simp]\ntheorem evalFrom_nil (S : Set σ) : M.evalFrom S [] = S :=\n  rfl\n\n"}
{"name":"NFA.evalFrom_singleton","module":"Mathlib.Computability.NFA","initialProofState":"α : Type u\nσ : Type v\nM : NFA α σ\nS : Set σ\na : α\n⊢ Eq (M.evalFrom S (List.cons a List.nil)) (M.stepSet S a)","decl":"@[simp]\ntheorem evalFrom_singleton (S : Set σ) (a : α) : M.evalFrom S [a] = M.stepSet S a :=\n  rfl\n\n"}
{"name":"NFA.evalFrom_append_singleton","module":"Mathlib.Computability.NFA","initialProofState":"α : Type u\nσ : Type v\nM : NFA α σ\nS : Set σ\nx : List α\na : α\n⊢ Eq (M.evalFrom S (HAppend.hAppend x (List.cons a List.nil))) (M.stepSet (M.evalFrom S x) a)","decl":"@[simp]\ntheorem evalFrom_append_singleton (S : Set σ) (x : List α) (a : α) :\n    M.evalFrom S (x ++ [a]) = M.stepSet (M.evalFrom S x) a := by\n  simp only [evalFrom, List.foldl_append, List.foldl_cons, List.foldl_nil]\n\n"}
{"name":"NFA.eval_nil","module":"Mathlib.Computability.NFA","initialProofState":"α : Type u\nσ : Type v\nM : NFA α σ\n⊢ Eq (M.eval List.nil) M.start","decl":"@[simp]\ntheorem eval_nil : M.eval [] = M.start :=\n  rfl\n\n"}
{"name":"NFA.eval_singleton","module":"Mathlib.Computability.NFA","initialProofState":"α : Type u\nσ : Type v\nM : NFA α σ\na : α\n⊢ Eq (M.eval (List.cons a List.nil)) (M.stepSet M.start a)","decl":"@[simp]\ntheorem eval_singleton (a : α) : M.eval [a] = M.stepSet M.start a :=\n  rfl\n\n"}
{"name":"NFA.eval_append_singleton","module":"Mathlib.Computability.NFA","initialProofState":"α : Type u\nσ : Type v\nM : NFA α σ\nx : List α\na : α\n⊢ Eq (M.eval (HAppend.hAppend x (List.cons a List.nil))) (M.stepSet (M.eval x) a)","decl":"@[simp]\ntheorem eval_append_singleton (x : List α) (a : α) : M.eval (x ++ [a]) = M.stepSet (M.eval x) a :=\n  evalFrom_append_singleton _ _ _ _\n\n"}
{"name":"NFA.mem_accepts","module":"Mathlib.Computability.NFA","initialProofState":"α : Type u\nσ : Type v\nM : NFA α σ\nx : List α\n⊢ Iff (Membership.mem M.accepts x) (Exists fun S => And (Membership.mem M.accept S) (Membership.mem (M.evalFrom M.start x) S))","decl":"theorem mem_accepts {x : List α} : x ∈ M.accepts ↔ ∃ S ∈ M.accept, S ∈ M.evalFrom M.start x := by\n  rfl\n\n"}
{"name":"NFA.toDFA_correct","module":"Mathlib.Computability.NFA","initialProofState":"α : Type u\nσ : Type v\nM : NFA α σ\n⊢ Eq M.toDFA.accepts M.accepts","decl":"@[simp]\ntheorem toDFA_correct : M.toDFA.accepts = M.accepts := by\n  ext x\n  rw [mem_accepts, DFA.mem_accepts]\n  constructor <;> · exact fun ⟨w, h2, h3⟩ => ⟨w, h3, h2⟩\n\n"}
{"name":"NFA.pumping_lemma","module":"Mathlib.Computability.NFA","initialProofState":"α : Type u\nσ : Type v\nM : NFA α σ\ninst✝ : Fintype σ\nx : List α\nhx : Membership.mem M.accepts x\nhlen : LE.le (Fintype.card (Set σ)) x.length\n⊢ Exists fun a => Exists fun b => Exists fun c => And (Eq x (HAppend.hAppend (HAppend.hAppend a b) c)) (And (LE.le (HAdd.hAdd a.length b.length) (Fintype.card (Set σ))) (And (Ne b List.nil) (LE.le (HMul.hMul (HMul.hMul (Singleton.singleton a) (KStar.kstar (Singleton.singleton b))) (Singleton.singleton c)) M.accepts)))","decl":"theorem pumping_lemma [Fintype σ] {x : List α} (hx : x ∈ M.accepts)\n    (hlen : Fintype.card (Set σ) ≤ List.length x) :\n    ∃ a b c,\n      x = a ++ b ++ c ∧\n        a.length + b.length ≤ Fintype.card (Set σ) ∧ b ≠ [] ∧ {a} * {b}∗ * {c} ≤ M.accepts := by\n  rw [← toDFA_correct] at hx ⊢\n  exact M.toDFA.pumping_lemma hx hlen\n\n"}
{"name":"DFA.toNFA_start","module":"Mathlib.Computability.NFA","initialProofState":"α : Type u\nσ' : Type v\nM : DFA α σ'\n⊢ Eq M.toNFA.start (Singleton.singleton M.start)","decl":"/-- `M.toNFA` is an `NFA` constructed from a `DFA` `M` by using the same start and accept\n  states and a transition function which sends `s` with input `a` to the singleton `M.step s a`. -/\n@[simps] def toNFA (M : DFA α σ') : NFA α σ' where\n  step s a := {M.step s a}\n  start := {M.start}\n  accept := M.accept\n\n"}
{"name":"DFA.toNFA_step","module":"Mathlib.Computability.NFA","initialProofState":"α : Type u\nσ' : Type v\nM : DFA α σ'\ns : σ'\na : α\n⊢ Eq (M.toNFA.step s a) (Singleton.singleton (M.step s a))","decl":"/-- `M.toNFA` is an `NFA` constructed from a `DFA` `M` by using the same start and accept\n  states and a transition function which sends `s` with input `a` to the singleton `M.step s a`. -/\n@[simps] def toNFA (M : DFA α σ') : NFA α σ' where\n  step s a := {M.step s a}\n  start := {M.start}\n  accept := M.accept\n\n"}
{"name":"DFA.toNFA_accept","module":"Mathlib.Computability.NFA","initialProofState":"α : Type u\nσ' : Type v\nM : DFA α σ'\n⊢ Eq M.toNFA.accept M.accept","decl":"/-- `M.toNFA` is an `NFA` constructed from a `DFA` `M` by using the same start and accept\n  states and a transition function which sends `s` with input `a` to the singleton `M.step s a`. -/\n@[simps] def toNFA (M : DFA α σ') : NFA α σ' where\n  step s a := {M.step s a}\n  start := {M.start}\n  accept := M.accept\n\n"}
{"name":"DFA.toNFA_evalFrom_match","module":"Mathlib.Computability.NFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\nstart : σ\ns : List α\n⊢ Eq (M.toNFA.evalFrom (Singleton.singleton start) s) (Singleton.singleton (M.evalFrom start s))","decl":"@[simp]\ntheorem toNFA_evalFrom_match (M : DFA α σ) (start : σ) (s : List α) :\n    M.toNFA.evalFrom {start} s = {M.evalFrom start s} := by\n  change List.foldl M.toNFA.stepSet {start} s = {List.foldl M.step start s}\n  induction' s with a s ih generalizing start\n  · tauto\n  · rw [List.foldl, List.foldl,\n      show M.toNFA.stepSet {start} a = {M.step start a} by simp [NFA.stepSet] ]\n    tauto\n\n"}
{"name":"DFA.toNFA_correct","module":"Mathlib.Computability.NFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\n⊢ Eq M.toNFA.accepts M.accepts","decl":"@[simp]\ntheorem toNFA_correct (M : DFA α σ) : M.toNFA.accepts = M.accepts := by\n  ext x\n  rw [NFA.mem_accepts, toNFA_start, toNFA_evalFrom_match]\n  constructor\n  · rintro ⟨S, hS₁, hS₂⟩\n    rwa [Set.mem_singleton_iff.mp hS₂] at hS₁\n  · exact fun h => ⟨M.eval x, h, rfl⟩\n\n"}
