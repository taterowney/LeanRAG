{"name":"IsLocalization.lift_cardinalMk_le","module":"Mathlib.RingTheory.Localization.Cardinality","initialProofState":"R : Type u\ninst✝³ : CommSemiring R\nL : Type v\ninst✝² : CommSemiring L\ninst✝¹ : Algebra R L\nS : Submonoid R\ninst✝ : IsLocalization S L\n⊢ LE.le (Cardinal.lift.{u, v} (Cardinal.mk L)) (Cardinal.lift.{v, u} (Cardinal.mk R))","decl":"theorem lift_cardinalMk_le (S : Submonoid R) [IsLocalization S L] :\n    Cardinal.lift.{u} #L ≤ Cardinal.lift.{v} #R := by\n  have := Localization.cardinalMk_le S\n  rwa [← lift_le.{v}, lift_mk_eq'.2 ⟨(Localization.algEquiv S L).toEquiv⟩] at this\n\n"}
{"name":"IsLocalization.cardinalMk_le","module":"Mathlib.RingTheory.Localization.Cardinality","initialProofState":"R : Type u\ninst✝³ : CommSemiring R\nL : Type u\ninst✝² : CommSemiring L\ninst✝¹ : Algebra R L\nS : Submonoid R\ninst✝ : IsLocalization S L\n⊢ LE.le (Cardinal.mk L) (Cardinal.mk R)","decl":"/-- A localization always has cardinality less than or equal to the base ring. -/\ntheorem cardinalMk_le {L : Type u} [CommSemiring L] [Algebra R L]\n    (S : Submonoid R) [IsLocalization S L] : #L ≤ #R := by\n  simpa using lift_cardinalMk_le (L := L) S\n\n"}
{"name":"IsLocalization.card_le","module":"Mathlib.RingTheory.Localization.Cardinality","initialProofState":"R : Type u\ninst✝³ : CommSemiring R\nL : Type u\ninst✝² : CommSemiring L\ninst✝¹ : Algebra R L\nS : Submonoid R\ninst✝ : IsLocalization S L\n⊢ LE.le (Cardinal.mk L) (Cardinal.mk R)","decl":"@[deprecated (since := \"2024-10-30\")] alias card_le := cardinalMk_le\n\n"}
{"name":"Localization.cardinalMk","module":"Mathlib.RingTheory.Localization.Cardinality","initialProofState":"R : Type u\ninst✝ : CommRing R\nS : Submonoid R\nhS : LE.le S (nonZeroDivisors R)\n⊢ Eq (Cardinal.mk (Localization S)) (Cardinal.mk R)","decl":"theorem cardinalMk {S : Submonoid R} (hS : S ≤ R⁰) : #(Localization S) = #R := by\n  apply OreLocalization.cardinalMk\n  convert hS using 1\n  ext x\n  rw [mem_nonZeroDivisorsRight_iff, mem_nonZeroDivisors_iff]\n  congr! 3\n  rw [mul_comm]\n\n"}
{"name":"IsLocalization.lift_cardinalMk","module":"Mathlib.RingTheory.Localization.Cardinality","initialProofState":"R : Type u\ninst✝³ : CommRing R\nL : Type v\ninst✝² : CommRing L\ninst✝¹ : Algebra R L\nS : Submonoid R\ninst✝ : IsLocalization S L\nhS : LE.le S (nonZeroDivisors R)\n⊢ Eq (Cardinal.lift.{u, v} (Cardinal.mk L)) (Cardinal.lift.{v, u} (Cardinal.mk R))","decl":"theorem lift_cardinalMk (S : Submonoid R) [IsLocalization S L] (hS : S ≤ R⁰) :\n    Cardinal.lift.{u} #L = Cardinal.lift.{v} #R := by\n  have := Localization.cardinalMk hS\n  rwa [← lift_inj.{u, v}, lift_mk_eq'.2 ⟨(Localization.algEquiv S L).toEquiv⟩] at this\n\n"}
{"name":"IsLocalization.cardinalMk","module":"Mathlib.RingTheory.Localization.Cardinality","initialProofState":"R : Type u\ninst✝³ : CommRing R\nL : Type u\ninst✝² : CommRing L\ninst✝¹ : Algebra R L\nS : Submonoid R\ninst✝ : IsLocalization S L\nhS : LE.le S (nonZeroDivisors R)\n⊢ Eq (Cardinal.mk L) (Cardinal.mk R)","decl":"/-- If you do not localize at any zero-divisors, localization preserves cardinality. -/\ntheorem cardinalMk (L : Type u) [CommRing L] [Algebra R L]\n    (S : Submonoid R) [IsLocalization S L] (hS : S ≤ R⁰) : #L = #R := by\n  simpa using lift_cardinalMk L S hS\n\n"}
{"name":"IsLocalization.card","module":"Mathlib.RingTheory.Localization.Cardinality","initialProofState":"R : Type u\ninst✝³ : CommRing R\nL : Type u\ninst✝² : CommRing L\ninst✝¹ : Algebra R L\nS : Submonoid R\ninst✝ : IsLocalization S L\nhS : LE.le S (nonZeroDivisors R)\n⊢ Eq (Cardinal.mk L) (Cardinal.mk R)","decl":"@[deprecated (since := \"2024-10-30\")] alias card := cardinalMk\n\n"}
{"name":"Cardinal.mk_fractionRing","module":"Mathlib.RingTheory.Localization.Cardinality","initialProofState":"R : Type u\ninst✝ : CommRing R\n⊢ Eq (Cardinal.mk (FractionRing R)) (Cardinal.mk R)","decl":"@[simp]\ntheorem Cardinal.mk_fractionRing (R : Type u) [CommRing R] : #(FractionRing R) = #R :=\n  IsLocalization.cardinalMk (FractionRing R) R⁰ le_rfl\n\n"}
{"name":"FractionRing.cardinalMk","module":"Mathlib.RingTheory.Localization.Cardinality","initialProofState":"R : Type u\ninst✝ : CommRing R\n⊢ Eq (Cardinal.mk (FractionRing R)) (Cardinal.mk R)","decl":"alias FractionRing.cardinalMk := Cardinal.mk_fractionRing\n\n"}
{"name":"IsFractionRing.lift_cardinalMk","module":"Mathlib.RingTheory.Localization.Cardinality","initialProofState":"R : Type u\ninst✝³ : CommRing R\nL : Type v\ninst✝² : CommRing L\ninst✝¹ : Algebra R L\ninst✝ : IsFractionRing R L\n⊢ Eq (Cardinal.lift.{u, v} (Cardinal.mk L)) (Cardinal.lift.{v, u} (Cardinal.mk R))","decl":"theorem lift_cardinalMk [IsFractionRing R L] : Cardinal.lift.{u} #L = Cardinal.lift.{v} #R :=\n  IsLocalization.lift_cardinalMk L _ le_rfl\n\n"}
{"name":"IsFractionRing.cardinalMk","module":"Mathlib.RingTheory.Localization.Cardinality","initialProofState":"R : Type u\ninst✝³ : CommRing R\nL : Type u\ninst✝² : CommRing L\ninst✝¹ : Algebra R L\ninst✝ : IsFractionRing R L\n⊢ Eq (Cardinal.mk L) (Cardinal.mk R)","decl":"theorem cardinalMk (L : Type u) [CommRing L] [Algebra R L] [IsFractionRing R L] : #L = #R :=\n  IsLocalization.cardinalMk L _ le_rfl\n\n"}
