{"name":"OrderIso.neg_symm_apply","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝³ : AddGroup α\ninst✝² : LE α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\na✝ : OrderDual α\n⊢ Eq ((RelIso.symm (OrderIso.neg α)) a✝) (Neg.neg (OrderDual.ofDual a✝))","decl":"/-- `x ↦ x⁻¹` as an order-reversing equivalence. -/\n@[to_additive (attr := simps!) \"`x ↦ -x` as an order-reversing equivalence.\"]\ndef OrderIso.inv : α ≃o αᵒᵈ where\n  toEquiv := (Equiv.inv α).trans OrderDual.toDual\n  map_rel_iff' {_ _} := inv_le_inv_iff (α := α)\n\n"}
{"name":"OrderIso.neg_apply","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝³ : AddGroup α\ninst✝² : LE α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\na✝ : α\n⊢ Eq ((OrderIso.neg α) a✝) (OrderDual.toDual (Neg.neg a✝))","decl":"/-- `x ↦ x⁻¹` as an order-reversing equivalence. -/\n@[to_additive (attr := simps!) \"`x ↦ -x` as an order-reversing equivalence.\"]\ndef OrderIso.inv : α ≃o αᵒᵈ where\n  toEquiv := (Equiv.inv α).trans OrderDual.toDual\n  map_rel_iff' {_ _} := inv_le_inv_iff (α := α)\n\n"}
{"name":"OrderIso.inv_symm_apply","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝³ : Group α\ninst✝² : LE α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\na✝ : OrderDual α\n⊢ Eq ((RelIso.symm (OrderIso.inv α)) a✝) (Inv.inv (OrderDual.ofDual a✝))","decl":"/-- `x ↦ x⁻¹` as an order-reversing equivalence. -/\n@[to_additive (attr := simps!) \"`x ↦ -x` as an order-reversing equivalence.\"]\ndef OrderIso.inv : α ≃o αᵒᵈ where\n  toEquiv := (Equiv.inv α).trans OrderDual.toDual\n  map_rel_iff' {_ _} := inv_le_inv_iff (α := α)\n\n"}
{"name":"OrderIso.inv_apply","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝³ : Group α\ninst✝² : LE α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\na✝ : α\n⊢ Eq ((OrderIso.inv α) a✝) (OrderDual.toDual (Inv.inv a✝))","decl":"/-- `x ↦ x⁻¹` as an order-reversing equivalence. -/\n@[to_additive (attr := simps!) \"`x ↦ -x` as an order-reversing equivalence.\"]\ndef OrderIso.inv : α ≃o αᵒᵈ where\n  toEquiv := (Equiv.inv α).trans OrderDual.toDual\n  map_rel_iff' {_ _} := inv_le_inv_iff (α := α)\n\n"}
{"name":"inv_le'","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝³ : Group α\ninst✝² : LE α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\na b : α\n⊢ Iff (LE.le (Inv.inv a) b) (LE.le (Inv.inv b) a)","decl":"@[to_additive neg_le]\ntheorem inv_le' : a⁻¹ ≤ b ↔ b⁻¹ ≤ a :=\n  (OrderIso.inv α).symm_apply_le\n\n"}
{"name":"neg_le","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝³ : AddGroup α\ninst✝² : LE α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\na b : α\n⊢ Iff (LE.le (Neg.neg a) b) (LE.le (Neg.neg b) a)","decl":"@[to_additive neg_le]\ntheorem inv_le' : a⁻¹ ≤ b ↔ b⁻¹ ≤ a :=\n  (OrderIso.inv α).symm_apply_le\n\n"}
{"name":"inv_le_of_inv_le'","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝³ : Group α\ninst✝² : LE α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\na b : α\na✝ : LE.le (Inv.inv a) b\n⊢ LE.le (Inv.inv b) a","decl":"alias ⟨inv_le_of_inv_le', _⟩ := inv_le'\n\n"}
{"name":"neg_le_of_neg_le","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝³ : AddGroup α\ninst✝² : LE α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\na b : α\na✝ : LE.le (Neg.neg a) b\n⊢ LE.le (Neg.neg b) a","decl":"attribute [to_additive neg_le_of_neg_le] inv_le_of_inv_le'\n\n"}
{"name":"le_inv'","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝³ : Group α\ninst✝² : LE α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\na b : α\n⊢ Iff (LE.le a (Inv.inv b)) (LE.le b (Inv.inv a))","decl":"@[to_additive le_neg]\ntheorem le_inv' : a ≤ b⁻¹ ↔ b ≤ a⁻¹ :=\n  (OrderIso.inv α).le_symm_apply\n\n"}
{"name":"le_neg","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝³ : AddGroup α\ninst✝² : LE α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\na b : α\n⊢ Iff (LE.le a (Neg.neg b)) (LE.le b (Neg.neg a))","decl":"@[to_additive le_neg]\ntheorem le_inv' : a ≤ b⁻¹ ↔ b ≤ a⁻¹ :=\n  (OrderIso.inv α).le_symm_apply\n\n"}
{"name":"OrderIso.divLeft_symm_apply","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝³ : Group α\ninst✝² : LE α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\na : α\na✝ : OrderDual α\n⊢ Eq ((RelIso.symm (OrderIso.divLeft a)) a✝) (HMul.hMul (Inv.inv (OrderDual.ofDual a✝)) a)","decl":"/-- `x ↦ a / x` as an order-reversing equivalence. -/\n@[to_additive (attr := simps!) \"`x ↦ a - x` as an order-reversing equivalence.\"]\ndef OrderIso.divLeft (a : α) : α ≃o αᵒᵈ where\n  toEquiv := (Equiv.divLeft a).trans OrderDual.toDual\n  map_rel_iff' {_ _} := div_le_div_iff_left (α := α) _\n\n"}
{"name":"OrderIso.divLeft_apply","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝³ : Group α\ninst✝² : LE α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\na a✝ : α\n⊢ Eq ((OrderIso.divLeft a) a✝) (OrderDual.toDual (HDiv.hDiv a a✝))","decl":"/-- `x ↦ a / x` as an order-reversing equivalence. -/\n@[to_additive (attr := simps!) \"`x ↦ a - x` as an order-reversing equivalence.\"]\ndef OrderIso.divLeft (a : α) : α ≃o αᵒᵈ where\n  toEquiv := (Equiv.divLeft a).trans OrderDual.toDual\n  map_rel_iff' {_ _} := div_le_div_iff_left (α := α) _\n\n"}
{"name":"OrderIso.subLeft_apply","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝³ : AddGroup α\ninst✝² : LE α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\na a✝ : α\n⊢ Eq ((OrderIso.subLeft a) a✝) (OrderDual.toDual (HSub.hSub a a✝))","decl":"/-- `x ↦ a / x` as an order-reversing equivalence. -/\n@[to_additive (attr := simps!) \"`x ↦ a - x` as an order-reversing equivalence.\"]\ndef OrderIso.divLeft (a : α) : α ≃o αᵒᵈ where\n  toEquiv := (Equiv.divLeft a).trans OrderDual.toDual\n  map_rel_iff' {_ _} := div_le_div_iff_left (α := α) _\n\n"}
{"name":"OrderIso.subLeft_symm_apply","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝³ : AddGroup α\ninst✝² : LE α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\na : α\na✝ : OrderDual α\n⊢ Eq ((RelIso.symm (OrderIso.subLeft a)) a✝) (HAdd.hAdd (Neg.neg (OrderDual.ofDual a✝)) a)","decl":"/-- `x ↦ a / x` as an order-reversing equivalence. -/\n@[to_additive (attr := simps!) \"`x ↦ a - x` as an order-reversing equivalence.\"]\ndef OrderIso.divLeft (a : α) : α ≃o αᵒᵈ where\n  toEquiv := (Equiv.divLeft a).trans OrderDual.toDual\n  map_rel_iff' {_ _} := div_le_div_iff_left (α := α) _\n\n"}
{"name":"le_inv_of_le_inv","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝³ : Group α\ninst✝² : LE α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\na b : α\na✝ : LE.le a (Inv.inv b)\n⊢ LE.le b (Inv.inv a)","decl":"alias ⟨le_inv_of_le_inv, _⟩ := le_inv'\n\n"}
{"name":"le_neg_of_le_neg","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝³ : AddGroup α\ninst✝² : LE α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\na b : α\na✝ : LE.le a (Neg.neg b)\n⊢ LE.le b (Neg.neg a)","decl":"attribute [to_additive] le_inv_of_le_inv\n\n"}
{"name":"OrderIso.mulRight_toEquiv","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝² : Group α\ninst✝¹ : LE α\ninst✝ : MulRightMono α\na : α\n⊢ Eq (OrderIso.mulRight a).toEquiv (Equiv.mulRight a)","decl":"/-- `Equiv.mulRight` as an `OrderIso`. See also `OrderEmbedding.mulRight`. -/\n@[to_additive (attr := simps! (config := { simpRhs := true }) toEquiv apply)\n  \"`Equiv.addRight` as an `OrderIso`. See also `OrderEmbedding.addRight`.\"]\ndef OrderIso.mulRight (a : α) : α ≃o α where\n  map_rel_iff' {_ _} := mul_le_mul_iff_right a\n  toEquiv := Equiv.mulRight a\n\n"}
{"name":"OrderIso.addRight_toEquiv","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝² : AddGroup α\ninst✝¹ : LE α\ninst✝ : AddRightMono α\na : α\n⊢ Eq (OrderIso.addRight a).toEquiv (Equiv.addRight a)","decl":"/-- `Equiv.mulRight` as an `OrderIso`. See also `OrderEmbedding.mulRight`. -/\n@[to_additive (attr := simps! (config := { simpRhs := true }) toEquiv apply)\n  \"`Equiv.addRight` as an `OrderIso`. See also `OrderEmbedding.addRight`.\"]\ndef OrderIso.mulRight (a : α) : α ≃o α where\n  map_rel_iff' {_ _} := mul_le_mul_iff_right a\n  toEquiv := Equiv.mulRight a\n\n"}
{"name":"OrderIso.mulRight_apply","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝² : Group α\ninst✝¹ : LE α\ninst✝ : MulRightMono α\na x : α\n⊢ Eq ((OrderIso.mulRight a) x) (HMul.hMul x a)","decl":"/-- `Equiv.mulRight` as an `OrderIso`. See also `OrderEmbedding.mulRight`. -/\n@[to_additive (attr := simps! (config := { simpRhs := true }) toEquiv apply)\n  \"`Equiv.addRight` as an `OrderIso`. See also `OrderEmbedding.addRight`.\"]\ndef OrderIso.mulRight (a : α) : α ≃o α where\n  map_rel_iff' {_ _} := mul_le_mul_iff_right a\n  toEquiv := Equiv.mulRight a\n\n"}
{"name":"OrderIso.addRight_apply","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝² : AddGroup α\ninst✝¹ : LE α\ninst✝ : AddRightMono α\na x : α\n⊢ Eq ((OrderIso.addRight a) x) (HAdd.hAdd x a)","decl":"/-- `Equiv.mulRight` as an `OrderIso`. See also `OrderEmbedding.mulRight`. -/\n@[to_additive (attr := simps! (config := { simpRhs := true }) toEquiv apply)\n  \"`Equiv.addRight` as an `OrderIso`. See also `OrderEmbedding.addRight`.\"]\ndef OrderIso.mulRight (a : α) : α ≃o α where\n  map_rel_iff' {_ _} := mul_le_mul_iff_right a\n  toEquiv := Equiv.mulRight a\n\n"}
{"name":"OrderIso.mulRight_symm","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝² : Group α\ninst✝¹ : LE α\ninst✝ : MulRightMono α\na : α\n⊢ Eq (OrderIso.mulRight a).symm (OrderIso.mulRight (Inv.inv a))","decl":"@[to_additive (attr := simp)]\ntheorem OrderIso.mulRight_symm (a : α) : (OrderIso.mulRight a).symm = OrderIso.mulRight a⁻¹ := by\n  ext x\n  rfl\n\n"}
{"name":"OrderIso.addRight_symm","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝² : AddGroup α\ninst✝¹ : LE α\ninst✝ : AddRightMono α\na : α\n⊢ Eq (OrderIso.addRight a).symm (OrderIso.addRight (Neg.neg a))","decl":"@[to_additive (attr := simp)]\ntheorem OrderIso.mulRight_symm (a : α) : (OrderIso.mulRight a).symm = OrderIso.mulRight a⁻¹ := by\n  ext x\n  rfl\n\n"}
{"name":"OrderIso.subRight_symm_apply","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝² : AddGroup α\ninst✝¹ : LE α\ninst✝ : AddRightMono α\na b : α\n⊢ Eq ((RelIso.symm (OrderIso.subRight a)) b) (HAdd.hAdd b a)","decl":"/-- `x ↦ x / a` as an order isomorphism. -/\n@[to_additive (attr := simps!) \"`x ↦ x - a` as an order isomorphism.\"]\ndef OrderIso.divRight (a : α) : α ≃o α where\n  toEquiv := Equiv.divRight a\n  map_rel_iff' {_ _} := div_le_div_iff_right a\n\n"}
{"name":"OrderIso.divRight_apply","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝² : Group α\ninst✝¹ : LE α\ninst✝ : MulRightMono α\na b : α\n⊢ Eq ((OrderIso.divRight a) b) (HDiv.hDiv b a)","decl":"/-- `x ↦ x / a` as an order isomorphism. -/\n@[to_additive (attr := simps!) \"`x ↦ x - a` as an order isomorphism.\"]\ndef OrderIso.divRight (a : α) : α ≃o α where\n  toEquiv := Equiv.divRight a\n  map_rel_iff' {_ _} := div_le_div_iff_right a\n\n"}
{"name":"OrderIso.subRight_apply","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝² : AddGroup α\ninst✝¹ : LE α\ninst✝ : AddRightMono α\na b : α\n⊢ Eq ((OrderIso.subRight a) b) (HSub.hSub b a)","decl":"/-- `x ↦ x / a` as an order isomorphism. -/\n@[to_additive (attr := simps!) \"`x ↦ x - a` as an order isomorphism.\"]\ndef OrderIso.divRight (a : α) : α ≃o α where\n  toEquiv := Equiv.divRight a\n  map_rel_iff' {_ _} := div_le_div_iff_right a\n\n"}
{"name":"OrderIso.divRight_symm_apply","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝² : Group α\ninst✝¹ : LE α\ninst✝ : MulRightMono α\na b : α\n⊢ Eq ((RelIso.symm (OrderIso.divRight a)) b) (HMul.hMul b a)","decl":"/-- `x ↦ x / a` as an order isomorphism. -/\n@[to_additive (attr := simps!) \"`x ↦ x - a` as an order isomorphism.\"]\ndef OrderIso.divRight (a : α) : α ≃o α where\n  toEquiv := Equiv.divRight a\n  map_rel_iff' {_ _} := div_le_div_iff_right a\n\n"}
{"name":"OrderIso.mulLeft_apply","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝² : Group α\ninst✝¹ : LE α\ninst✝ : MulLeftMono α\na x : α\n⊢ Eq ((OrderIso.mulLeft a) x) (HMul.hMul a x)","decl":"/-- `Equiv.mulLeft` as an `OrderIso`. See also `OrderEmbedding.mulLeft`. -/\n@[to_additive (attr := simps! (config := { simpRhs := true }) toEquiv apply)\n  \"`Equiv.addLeft` as an `OrderIso`. See also `OrderEmbedding.addLeft`.\"]\ndef OrderIso.mulLeft (a : α) : α ≃o α where\n  map_rel_iff' {_ _} := mul_le_mul_iff_left a\n  toEquiv := Equiv.mulLeft a\n\n"}
{"name":"OrderIso.addLeft_apply","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝² : AddGroup α\ninst✝¹ : LE α\ninst✝ : AddLeftMono α\na x : α\n⊢ Eq ((OrderIso.addLeft a) x) (HAdd.hAdd a x)","decl":"/-- `Equiv.mulLeft` as an `OrderIso`. See also `OrderEmbedding.mulLeft`. -/\n@[to_additive (attr := simps! (config := { simpRhs := true }) toEquiv apply)\n  \"`Equiv.addLeft` as an `OrderIso`. See also `OrderEmbedding.addLeft`.\"]\ndef OrderIso.mulLeft (a : α) : α ≃o α where\n  map_rel_iff' {_ _} := mul_le_mul_iff_left a\n  toEquiv := Equiv.mulLeft a\n\n"}
{"name":"OrderIso.mulLeft_toEquiv","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝² : Group α\ninst✝¹ : LE α\ninst✝ : MulLeftMono α\na : α\n⊢ Eq (OrderIso.mulLeft a).toEquiv (Equiv.mulLeft a)","decl":"/-- `Equiv.mulLeft` as an `OrderIso`. See also `OrderEmbedding.mulLeft`. -/\n@[to_additive (attr := simps! (config := { simpRhs := true }) toEquiv apply)\n  \"`Equiv.addLeft` as an `OrderIso`. See also `OrderEmbedding.addLeft`.\"]\ndef OrderIso.mulLeft (a : α) : α ≃o α where\n  map_rel_iff' {_ _} := mul_le_mul_iff_left a\n  toEquiv := Equiv.mulLeft a\n\n"}
{"name":"OrderIso.addLeft_toEquiv","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝² : AddGroup α\ninst✝¹ : LE α\ninst✝ : AddLeftMono α\na : α\n⊢ Eq (OrderIso.addLeft a).toEquiv (Equiv.addLeft a)","decl":"/-- `Equiv.mulLeft` as an `OrderIso`. See also `OrderEmbedding.mulLeft`. -/\n@[to_additive (attr := simps! (config := { simpRhs := true }) toEquiv apply)\n  \"`Equiv.addLeft` as an `OrderIso`. See also `OrderEmbedding.addLeft`.\"]\ndef OrderIso.mulLeft (a : α) : α ≃o α where\n  map_rel_iff' {_ _} := mul_le_mul_iff_left a\n  toEquiv := Equiv.mulLeft a\n\n"}
{"name":"OrderIso.mulLeft_symm","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝² : Group α\ninst✝¹ : LE α\ninst✝ : MulLeftMono α\na : α\n⊢ Eq (OrderIso.mulLeft a).symm (OrderIso.mulLeft (Inv.inv a))","decl":"@[to_additive (attr := simp)]\ntheorem OrderIso.mulLeft_symm (a : α) : (OrderIso.mulLeft a).symm = OrderIso.mulLeft a⁻¹ := by\n  ext x\n  rfl\n\n"}
{"name":"OrderIso.addLeft_symm","module":"Mathlib.Algebra.Order.Group.OrderIso","initialProofState":"α : Type u\ninst✝² : AddGroup α\ninst✝¹ : LE α\ninst✝ : AddLeftMono α\na : α\n⊢ Eq (OrderIso.addLeft a).symm (OrderIso.addLeft (Neg.neg a))","decl":"@[to_additive (attr := simp)]\ntheorem OrderIso.mulLeft_symm (a : α) : (OrderIso.mulLeft a).symm = OrderIso.mulLeft a⁻¹ := by\n  ext x\n  rfl\n\n"}
