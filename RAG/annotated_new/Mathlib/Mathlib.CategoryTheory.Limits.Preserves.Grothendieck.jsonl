{"name":"CategoryTheory.Limits.fiberwiseColimitLimitIso_hom_app","module":"Mathlib.CategoryTheory.Limits.Preserves.Grothendieck","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nH : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} H\nJ : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} J\nF : CategoryTheory.Functor C CategoryTheory.Cat\nK : CategoryTheory.Functor J (CategoryTheory.Functor (CategoryTheory.Grothendieck F) H)\ninst✝² : ∀ (c : C), CategoryTheory.Limits.HasColimitsOfShape (↑(F.obj c)) H\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J H\ninst✝ : ∀ (c : C), CategoryTheory.Limits.PreservesLimitsOfShape J CategoryTheory.Limits.colim\nX : C\n⊢ Eq ((CategoryTheory.Limits.fiberwiseColimitLimitIso K).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasColimit.isoOfNatIso (CategoryTheory.Limits.limitCompWhiskeringLeftIsoCompLimit K (CategoryTheory.Grothendieck.ι F X)).symm).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.preservesLimitIso CategoryTheory.Limits.colim (K.comp ((CategoryTheory.whiskeringLeft (↑(F.obj X)) (CategoryTheory.Grothendieck F) H).obj (CategoryTheory.Grothendieck.ι F X)))).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasLimit.isoOfNatIso ((K.associator ((CategoryTheory.whiskeringLeft (↑(F.obj X)) (CategoryTheory.Grothendieck F) H).obj (CategoryTheory.Grothendieck.ι F X)) CategoryTheory.Limits.colim).trans ((CategoryTheory.isoWhiskerLeft K (CategoryTheory.Limits.fiberwiseColimCompEvaluationIso X).symm).trans (K.associator (CategoryTheory.Limits.fiberwiseColim F H) ((CategoryTheory.evaluation C H).obj X)).symm))).hom (CategoryTheory.Limits.limitObjIsoLimitCompEvaluation (K.comp (CategoryTheory.Limits.fiberwiseColim F H)) X).inv)))","decl":"/-- If `colim` on each fiber `F.obj c` of a functor `F : C ⥤ Cat` preserves limits of shape `J`,\nthen the fiberwise colimit of the limit of a functor `K : J ⥤ Grothendieck F ⥤ H` is naturally\nisomorphic to taking the limit of the composition `K ⋙ fiberwiseColim F H`. -/\n@[simps!]\ndef fiberwiseColimitLimitIso (K : J ⥤ Grothendieck F ⥤ H)\n    [∀ (c : C), HasColimitsOfShape (↑(F.obj c)) H] [HasLimitsOfShape J H]\n    [∀ c, PreservesLimitsOfShape J (colim (J := F.obj c) (C := H))] :\n    fiberwiseColimit (limit K) ≅ limit (K ⋙ fiberwiseColim F H) :=\n  NatIso.ofComponents\n    (fun c => HasColimit.isoOfNatIso\n       (limitCompWhiskeringLeftIsoCompLimit K (Grothendieck.ι F c)).symm ≪≫\n      preservesLimitIso colim _ ≪≫\n      HasLimit.isoOfNatIso\n        (Functor.associator _ _ _ ≪≫\n        isoWhiskerLeft _ (fiberwiseColimCompEvaluationIso _).symm ≪≫\n        (Functor.associator _ _ _).symm) ≪≫\n      (limitObjIsoLimitCompEvaluation _ c).symm)\n    fun {c₁ c₂} f => by\n      simp only [fiberwiseColimit_obj, fiberwiseColimit_map, Iso.trans_hom, Iso.symm_hom,\n        Category.assoc, limitObjIsoLimitCompEvaluation_inv_limit_map]\n      apply colimit.hom_ext\n      intro d\n      simp only [← Category.assoc]\n      congr 1\n      apply limit.hom_ext\n      intro e\n      simp [← NatTrans.comp_app_assoc]\n\n"}
{"name":"CategoryTheory.Limits.fiberwiseColimitLimitIso_inv_app","module":"Mathlib.CategoryTheory.Limits.Preserves.Grothendieck","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nH : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} H\nJ : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} J\nF : CategoryTheory.Functor C CategoryTheory.Cat\nK : CategoryTheory.Functor J (CategoryTheory.Functor (CategoryTheory.Grothendieck F) H)\ninst✝² : ∀ (c : C), CategoryTheory.Limits.HasColimitsOfShape (↑(F.obj c)) H\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J H\ninst✝ : ∀ (c : C), CategoryTheory.Limits.PreservesLimitsOfShape J CategoryTheory.Limits.colim\nX : C\n⊢ Eq ((CategoryTheory.Limits.fiberwiseColimitLimitIso K).inv.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitObjIsoLimitCompEvaluation (K.comp (CategoryTheory.Limits.fiberwiseColim F H)) X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasLimit.isoOfNatIso ((K.associator ((CategoryTheory.whiskeringLeft (↑(F.obj X)) (CategoryTheory.Grothendieck F) H).obj (CategoryTheory.Grothendieck.ι F X)) CategoryTheory.Limits.colim).trans ((CategoryTheory.isoWhiskerLeft K (CategoryTheory.Limits.fiberwiseColimCompEvaluationIso X).symm).trans (K.associator (CategoryTheory.Limits.fiberwiseColim F H) ((CategoryTheory.evaluation C H).obj X)).symm))).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.preservesLimitIso CategoryTheory.Limits.colim (K.comp ((CategoryTheory.whiskeringLeft (↑(F.obj X)) (CategoryTheory.Grothendieck F) H).obj (CategoryTheory.Grothendieck.ι F X)))).inv (CategoryTheory.Limits.HasColimit.isoOfNatIso (CategoryTheory.Limits.limitCompWhiskeringLeftIsoCompLimit K (CategoryTheory.Grothendieck.ι F X)).symm).inv)))","decl":"/-- If `colim` on each fiber `F.obj c` of a functor `F : C ⥤ Cat` preserves limits of shape `J`,\nthen the fiberwise colimit of the limit of a functor `K : J ⥤ Grothendieck F ⥤ H` is naturally\nisomorphic to taking the limit of the composition `K ⋙ fiberwiseColim F H`. -/\n@[simps!]\ndef fiberwiseColimitLimitIso (K : J ⥤ Grothendieck F ⥤ H)\n    [∀ (c : C), HasColimitsOfShape (↑(F.obj c)) H] [HasLimitsOfShape J H]\n    [∀ c, PreservesLimitsOfShape J (colim (J := F.obj c) (C := H))] :\n    fiberwiseColimit (limit K) ≅ limit (K ⋙ fiberwiseColim F H) :=\n  NatIso.ofComponents\n    (fun c => HasColimit.isoOfNatIso\n       (limitCompWhiskeringLeftIsoCompLimit K (Grothendieck.ι F c)).symm ≪≫\n      preservesLimitIso colim _ ≪≫\n      HasLimit.isoOfNatIso\n        (Functor.associator _ _ _ ≪≫\n        isoWhiskerLeft _ (fiberwiseColimCompEvaluationIso _).symm ≪≫\n        (Functor.associator _ _ _).symm) ≪≫\n      (limitObjIsoLimitCompEvaluation _ c).symm)\n    fun {c₁ c₂} f => by\n      simp only [fiberwiseColimit_obj, fiberwiseColimit_map, Iso.trans_hom, Iso.symm_hom,\n        Category.assoc, limitObjIsoLimitCompEvaluation_inv_limit_map]\n      apply colimit.hom_ext\n      intro d\n      simp only [← Category.assoc]\n      congr 1\n      apply limit.hom_ext\n      intro e\n      simp [← NatTrans.comp_app_assoc]\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfShape_colim_grothendieck","module":"Mathlib.CategoryTheory.Limits.Preserves.Grothendieck","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\nH : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} H\nJ : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₃, u₃} J\nF : CategoryTheory.Functor C CategoryTheory.Cat\ninst✝⁴ : CategoryTheory.Limits.HasColimitsOfShape C H\ninst✝³ : CategoryTheory.Limits.HasLimitsOfShape J H\ninst✝² : ∀ (c : C), CategoryTheory.Limits.HasColimitsOfShape (↑(F.obj c)) H\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape J CategoryTheory.Limits.colim\ninst✝ : ∀ (c : C), CategoryTheory.Limits.PreservesLimitsOfShape J CategoryTheory.Limits.colim\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J CategoryTheory.Limits.colim","decl":"variable (C) (F) in\n/-- If `colim` on a category `C` preserves limits of shape `J` and if it does so for `colim` on\nevery `F.obj c` for a functor `F : C ⥤ Cat`, then `colim` on `Grothendieck F` also preserves limits\nof shape `J`. -/\ninstance preservesLimitsOfShape_colim_grothendieck [HasColimitsOfShape C H] [HasLimitsOfShape J H]\n    [∀ c, HasColimitsOfShape (↑(F.obj c)) H] [PreservesLimitsOfShape J (colim (J := C) (C := H))]\n    [∀ c, PreservesLimitsOfShape J (colim (J := F.obj c) (C := H))] :\n    PreservesLimitsOfShape J (colim (J := Grothendieck F) (C := H)) := by\n  constructor\n  intro K\n  let i₂ := calc colimit (limit K)\n    _ ≅ colimit (fiberwiseColimit (limit K)) := (colimitFiberwiseColimitIso _).symm\n    _ ≅ colimit (limit (K ⋙ fiberwiseColim _ _)) :=\n          HasColimit.isoOfNatIso (fiberwiseColimitLimitIso _)\n    _ ≅ limit ((K ⋙ fiberwiseColim _ _) ⋙ colim) :=\n          preservesLimitIso colim (K ⋙ fiberwiseColim _ _)\n    _ ≅ limit (K ⋙ colim) :=\n      HasLimit.isoOfNatIso\n       (Functor.associator _ _ _ ≪≫ isoWhiskerLeft _ fiberwiseColimCompColimIso)\n  haveI : IsIso (limit.post K colim) := by\n    convert Iso.isIso_hom i₂\n    ext\n    simp only [colim_obj, Functor.comp_obj, limit.post_π, colim_map, Iso.instTransIso_trans,\n      Iso.trans_assoc, Iso.trans_hom, Category.assoc, HasLimit.isoOfNatIso_hom_π,\n      fiberwiseColim_obj, isoWhiskerLeft_hom, NatTrans.comp_app, Functor.associator_hom_app,\n      whiskerLeft_app, fiberwiseColimCompColimIso_hom_app, Category.id_comp,\n      preservesLimitIso_hom_π_assoc, i₂]\n    ext\n    simp only [ι_colimMap, Trans.trans, Iso.symm_hom, ι_colimitFiberwiseColimitIso_inv_assoc,\n      HasColimit.isoOfNatIso_ι_hom_assoc, fiberwiseColimit_obj, fiberwiseColimitLimitIso_hom_app,\n      ι_colimMap_assoc, Category.assoc, limitObjIsoLimitCompEvaluation_inv_π_app_assoc,\n      Functor.comp_obj, fiberwiseColim_obj, HasLimit.isoOfNatIso_hom_π_assoc,\n      whiskeringLeft_obj_obj, colim_obj, evaluation_obj_obj, Iso.trans_hom, isoWhiskerLeft_hom,\n      NatTrans.comp_app, Functor.associator_hom_app, whiskerLeft_app,\n      fiberwiseColimCompEvaluationIso_inv_app, Functor.associator_inv_app, Category.comp_id,\n      Category.id_comp, preservesLimitIso_hom_π_assoc, colim_map, Grothendieck.ι_obj,\n      ι_colimitFiberwiseColimitIso_hom]\n    simp [← Category.assoc, ← NatTrans.comp_app]\n  apply preservesLimit_of_isIso_post\n\n"}
