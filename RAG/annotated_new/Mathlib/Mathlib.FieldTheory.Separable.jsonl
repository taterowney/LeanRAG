{"name":"Polynomial.separable_def","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf : Polynomial R\n⊢ Iff f.Separable (IsCoprime f (Polynomial.derivative f))","decl":"theorem separable_def (f : R[X]) : f.Separable ↔ IsCoprime f (derivative f) :=\n  Iff.rfl\n\n"}
{"name":"Polynomial.separable_def'","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf : Polynomial R\n⊢ Iff f.Separable (Exists fun a => Exists fun b => Eq (HAdd.hAdd (HMul.hMul a f) (HMul.hMul b (Polynomial.derivative f))) 1)","decl":"theorem separable_def' (f : R[X]) : f.Separable ↔ ∃ a b : R[X], a * f + b * (derivative f) = 1 :=\n  Iff.rfl\n\n"}
{"name":"Polynomial.not_separable_zero","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\n⊢ Not (Polynomial.Separable 0)","decl":"theorem not_separable_zero [Nontrivial R] : ¬Separable (0 : R[X]) := by\n  rintro ⟨x, y, h⟩\n  simp only [derivative_zero, mul_zero, add_zero, zero_ne_one] at h\n\n"}
{"name":"Polynomial.Separable.ne_zero","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\nf : Polynomial R\nh : f.Separable\n⊢ Ne f 0","decl":"theorem Separable.ne_zero [Nontrivial R] {f : R[X]} (h : f.Separable) : f ≠ 0 :=\n  (not_separable_zero <| · ▸ h)\n\n"}
{"name":"Polynomial.separable_one","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Polynomial.Separable 1","decl":"@[simp]\ntheorem separable_one : (1 : R[X]).Separable :=\n  isCoprime_one_left\n\n"}
{"name":"Polynomial.separable_of_subsingleton","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : Subsingleton R\nf : Polynomial R\n⊢ f.Separable","decl":"@[nontriviality]\ntheorem separable_of_subsingleton [Subsingleton R] (f : R[X]) : f.Separable := by\n  simp [Separable, IsCoprime, eq_iff_true_of_subsingleton]\n\n"}
{"name":"Polynomial.separable_X_add_C","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommSemiring R\na : R\n⊢ (HAdd.hAdd Polynomial.X (Polynomial.C a)).Separable","decl":"theorem separable_X_add_C (a : R) : (X + C a).Separable := by\n  rw [separable_def, derivative_add, derivative_X, derivative_C, add_zero]\n  exact isCoprime_one_right\n\n"}
{"name":"Polynomial.separable_X","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Polynomial.X.Separable","decl":"theorem separable_X : (X : R[X]).Separable := by\n  rw [separable_def, derivative_X]\n  exact isCoprime_one_right\n\n"}
{"name":"Polynomial.separable_C","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nr : R\n⊢ Iff (Polynomial.C r).Separable (IsUnit r)","decl":"theorem separable_C (r : R) : (C r).Separable ↔ IsUnit r := by\n  rw [separable_def, derivative_C, isCoprime_zero_right, isUnit_C]\n\n"}
{"name":"Polynomial.Separable.of_mul_left","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf g : Polynomial R\nh : (HMul.hMul f g).Separable\n⊢ f.Separable","decl":"theorem Separable.of_mul_left {f g : R[X]} (h : (f * g).Separable) : f.Separable := by\n  have := h.of_mul_left_left; rw [derivative_mul] at this\n  exact IsCoprime.of_mul_right_left (IsCoprime.of_add_mul_left_right this)\n\n"}
{"name":"Polynomial.Separable.of_mul_right","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf g : Polynomial R\nh : (HMul.hMul f g).Separable\n⊢ g.Separable","decl":"theorem Separable.of_mul_right {f g : R[X]} (h : (f * g).Separable) : g.Separable := by\n  rw [mul_comm] at h\n  exact h.of_mul_left\n\n"}
{"name":"Polynomial.Separable.of_dvd","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf g : Polynomial R\nhf : f.Separable\nhfg : Dvd.dvd g f\n⊢ g.Separable","decl":"theorem Separable.of_dvd {f g : R[X]} (hf : f.Separable) (hfg : g ∣ f) : g.Separable := by\n  rcases hfg with ⟨f', rfl⟩\n  exact Separable.of_mul_left hf\n\n"}
{"name":"Polynomial.separable_gcd_left","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : DecidableEq (Polynomial F)\nf : Polynomial F\nhf : f.Separable\ng : Polynomial F\n⊢ (EuclideanDomain.gcd f g).Separable","decl":"theorem separable_gcd_left {F : Type*} [Field F] [DecidableEq F[X]]\n    {f : F[X]} (hf : f.Separable) (g : F[X]) :\n    (EuclideanDomain.gcd f g).Separable :=\n  Separable.of_dvd hf (EuclideanDomain.gcd_dvd_left f g)\n\n"}
{"name":"Polynomial.separable_gcd_right","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : DecidableEq (Polynomial F)\ng f : Polynomial F\nhg : g.Separable\n⊢ (EuclideanDomain.gcd f g).Separable","decl":"theorem separable_gcd_right {F : Type*} [Field F] [DecidableEq F[X]]\n    {g : F[X]} (f : F[X]) (hg : g.Separable) :\n    (EuclideanDomain.gcd f g).Separable :=\n  Separable.of_dvd hg (EuclideanDomain.gcd_dvd_right f g)\n\n"}
{"name":"Polynomial.Separable.isCoprime","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf g : Polynomial R\nh : (HMul.hMul f g).Separable\n⊢ IsCoprime f g","decl":"theorem Separable.isCoprime {f g : R[X]} (h : (f * g).Separable) : IsCoprime f g := by\n  have := h.of_mul_left_left; rw [derivative_mul] at this\n  exact IsCoprime.of_mul_right_right (IsCoprime.of_add_mul_left_right this)\n\n"}
{"name":"Polynomial.Separable.of_pow'","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf : Polynomial R\nn : Nat\n_h : (HPow.hPow f n).Separable\n⊢ Or (IsUnit f) (Or (And f.Separable (Eq n 1)) (Eq n 0))","decl":"theorem Separable.of_pow' {f : R[X]} :\n    ∀ {n : ℕ} (_h : (f ^ n).Separable), IsUnit f ∨ f.Separable ∧ n = 1 ∨ n = 0\n  | 0 => fun _h => Or.inr <| Or.inr rfl\n  | 1 => fun h => Or.inr <| Or.inl ⟨pow_one f ▸ h, rfl⟩\n  | n + 2 => fun h => by\n    rw [pow_succ, pow_succ] at h\n    exact Or.inl (isCoprime_self.1 h.isCoprime.of_mul_left_right)\n\n"}
{"name":"Polynomial.Separable.of_pow","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf : Polynomial R\nhf : Not (IsUnit f)\nn : Nat\nhn : Ne n 0\nhfs : (HPow.hPow f n).Separable\n⊢ And f.Separable (Eq n 1)","decl":"theorem Separable.of_pow {f : R[X]} (hf : ¬IsUnit f) {n : ℕ} (hn : n ≠ 0)\n    (hfs : (f ^ n).Separable) : f.Separable ∧ n = 1 :=\n  (hfs.of_pow'.resolve_left hf).resolve_right hn\n\n"}
{"name":"Polynomial.Separable.map","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\nS : Type v\ninst✝ : CommSemiring S\np : Polynomial R\nh : p.Separable\nf : RingHom R S\n⊢ (Polynomial.map f p).Separable","decl":"theorem Separable.map {p : R[X]} (h : p.Separable) {f : R →+* S} : (p.map f).Separable :=\n  let ⟨a, b, H⟩ := h\n  ⟨a.map f, b.map f, by\n    rw [derivative_map, ← Polynomial.map_mul, ← Polynomial.map_mul, ← Polynomial.map_add, H,\n      Polynomial.map_one]⟩\n\n"}
{"name":"Associated.separable","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf g : Polynomial R\nha : Associated f g\nh : f.Separable\n⊢ g.Separable","decl":"theorem _root_.Associated.separable {f g : R[X]}\n    (ha : Associated f g) (h : f.Separable) : g.Separable := by\n  obtain ⟨⟨u, v, h1, h2⟩, ha⟩ := ha\n  obtain ⟨a, b, h⟩ := h\n  refine ⟨a * v + b * derivative v, b * v, ?_⟩\n  replace h := congr($h * $(h1))\n  have h3 := congr(derivative $(h1))\n  simp only [← ha, derivative_mul, derivative_one] at h3 ⊢\n  calc\n    _ = (a * f + b * derivative f) * (u * v)\n      + (b * f) * (derivative u * v + u * derivative v) := by ring1\n    _ = 1 := by rw [h, h3]; ring1\n\n"}
{"name":"Associated.separable_iff","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf g : Polynomial R\nha : Associated f g\n⊢ Iff f.Separable g.Separable","decl":"theorem _root_.Associated.separable_iff {f g : R[X]}\n    (ha : Associated f g) : f.Separable ↔ g.Separable := ⟨ha.separable, ha.symm.separable⟩\n\n"}
{"name":"Polynomial.Separable.mul_unit","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf g : Polynomial R\nhf : f.Separable\nhg : IsUnit g\n⊢ (HMul.hMul f g).Separable","decl":"theorem Separable.mul_unit {f g : R[X]} (hf : f.Separable) (hg : IsUnit g) : (f * g).Separable :=\n  (associated_mul_unit_right f g hg).separable hf\n\n"}
{"name":"Polynomial.Separable.unit_mul","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf g : Polynomial R\nhf : IsUnit f\nhg : g.Separable\n⊢ (HMul.hMul f g).Separable","decl":"theorem Separable.unit_mul {f g : R[X]} (hf : IsUnit f) (hg : g.Separable) : (f * g).Separable :=\n  (associated_unit_mul_right g f hf).separable hg\n\n"}
{"name":"Polynomial.Separable.eval₂_derivative_ne_zero","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Type v\ninst✝¹ : CommSemiring S\ninst✝ : Nontrivial S\nf : RingHom R S\np : Polynomial R\nh : p.Separable\nx : S\nhx : Eq (Polynomial.eval₂ f x p) 0\n⊢ Ne (Polynomial.eval₂ f x (Polynomial.derivative p)) 0","decl":"theorem Separable.eval₂_derivative_ne_zero [Nontrivial S] (f : R →+* S) {p : R[X]}\n    (h : p.Separable) {x : S} (hx : p.eval₂ f x = 0) :\n    (derivative p).eval₂ f x ≠ 0 := by\n  intro hx'\n  obtain ⟨a, b, e⟩ := h\n  apply_fun Polynomial.eval₂ f x at e\n  simp only [eval₂_add, eval₂_mul, hx, mul_zero, hx', add_zero, eval₂_one, zero_ne_one] at e\n\n"}
{"name":"Polynomial.Separable.aeval_derivative_ne_zero","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝³ : CommSemiring R\nS : Type v\ninst✝² : CommSemiring S\ninst✝¹ : Nontrivial S\ninst✝ : Algebra R S\np : Polynomial R\nh : p.Separable\nx : S\nhx : Eq ((Polynomial.aeval x) p) 0\n⊢ Ne ((Polynomial.aeval x) (Polynomial.derivative p)) 0","decl":"theorem Separable.aeval_derivative_ne_zero [Nontrivial S] [Algebra R S] {p : R[X]}\n    (h : p.Separable) {x : S} (hx : aeval x p = 0) :\n    aeval x (derivative p) ≠ 0 :=\n  h.eval₂_derivative_ne_zero (algebraMap R S) hx\n\n"}
{"name":"Polynomial.isUnit_of_self_mul_dvd_separable","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np q : Polynomial R\nhp : p.Separable\nhq : Dvd.dvd (HMul.hMul q q) p\n⊢ IsUnit q","decl":"theorem isUnit_of_self_mul_dvd_separable {p q : R[X]} (hp : p.Separable) (hq : q * q ∣ p) :\n    IsUnit q := by\n  obtain ⟨p, rfl⟩ := hq\n  apply isCoprime_self.mp\n  have : IsCoprime (q * (q * p))\n      (q * (derivative q * p + derivative q * p + q * derivative p)) := by\n    simp only [← mul_assoc, mul_add]\n    dsimp only [Separable] at hp\n    convert hp using 1\n    rw [derivative_mul, derivative_mul]\n    ring\n  exact IsCoprime.of_mul_right_left (IsCoprime.of_mul_left_left this)\n\n"}
{"name":"Polynomial.emultiplicity_le_one_of_separable","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np q : Polynomial R\nhq : Not (IsUnit q)\nhsep : p.Separable\n⊢ LE.le (emultiplicity q p) 1","decl":"theorem emultiplicity_le_one_of_separable {p q : R[X]} (hq : ¬IsUnit q) (hsep : Separable p) :\n    emultiplicity q p ≤ 1 := by\n  contrapose! hq\n  apply isUnit_of_self_mul_dvd_separable hsep\n  rw [← sq]\n  apply pow_dvd_of_le_emultiplicity\n  exact Order.add_one_le_of_lt hq\n\n"}
{"name":"Polynomial.Separable.squarefree","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Polynomial R\nhsep : p.Separable\n⊢ Squarefree p","decl":"/-- A separable polynomial is square-free.\n\nSee `PerfectField.separable_iff_squarefree` for the converse when the coefficients are a perfect\nfield. -/\ntheorem Separable.squarefree {p : R[X]} (hsep : Separable p) : Squarefree p := by\n  classical\n  rw [squarefree_iff_emultiplicity_le_one p]\n  exact fun f => or_iff_not_imp_right.mpr fun hunit => emultiplicity_le_one_of_separable hunit hsep\n\n"}
{"name":"Polynomial.separable_X_sub_C","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommRing R\nx : R\n⊢ (HSub.hSub Polynomial.X (Polynomial.C x)).Separable","decl":"theorem separable_X_sub_C {x : R} : Separable (X - C x) := by\n  simpa only [sub_eq_add_neg, C_neg] using separable_X_add_C (-x)\n\n"}
{"name":"Polynomial.Separable.mul","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommRing R\nf g : Polynomial R\nhf : f.Separable\nhg : g.Separable\nh : IsCoprime f g\n⊢ (HMul.hMul f g).Separable","decl":"theorem Separable.mul {f g : R[X]} (hf : f.Separable) (hg : g.Separable) (h : IsCoprime f g) :\n    (f * g).Separable := by\n  rw [separable_def, derivative_mul]\n  exact\n    ((hf.mul_right h).add_mul_left_right _).mul_left ((h.symm.mul_right hg).mul_add_right_right _)\n\n"}
{"name":"Polynomial.separable_prod'","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommRing R\nι : Type u_1\nf : ι → Polynomial R\ns : Finset ι\na✝¹ : ∀ (x : ι), Membership.mem s x → ∀ (y : ι), Membership.mem s y → Ne x y → IsCoprime (f x) (f y)\na✝ : ∀ (x : ι), Membership.mem s x → (f x).Separable\n⊢ (s.prod fun x => f x).Separable","decl":"theorem separable_prod' {ι : Sort _} {f : ι → R[X]} {s : Finset ι} :\n    (∀ x ∈ s, ∀ y ∈ s, x ≠ y → IsCoprime (f x) (f y)) →\n      (∀ x ∈ s, (f x).Separable) → (∏ x ∈ s, f x).Separable := by\n  classical\n  exact Finset.induction_on s (fun _ _ => separable_one) fun a s has ih h1 h2 => by\n    simp_rw [Finset.forall_mem_insert, forall_and] at h1 h2; rw [prod_insert has]\n    exact\n      h2.1.mul (ih h1.2.2 h2.2)\n        (IsCoprime.prod_right fun i his => h1.1.2 i his <| Ne.symm <| ne_of_mem_of_not_mem his has)\n\n"}
{"name":"Polynomial.separable_prod","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nι : Type u_1\ninst✝ : Fintype ι\nf : ι → Polynomial R\nh1 : Pairwise (Function.onFun IsCoprime f)\nh2 : ∀ (x : ι), (f x).Separable\n⊢ (Finset.univ.prod fun x => f x).Separable","decl":"open scoped Function in -- required for scoped `on` notation\ntheorem separable_prod {ι : Sort _} [Fintype ι] {f : ι → R[X]} (h1 : Pairwise (IsCoprime on f))\n    (h2 : ∀ x, (f x).Separable) : (∏ x, f x).Separable :=\n  separable_prod' (fun _x _hx _y _hy hxy => h1 hxy) fun x _hx => h2 x\n\n"}
{"name":"Polynomial.Separable.inj_of_prod_X_sub_C","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : Nontrivial R\nι : Type u_1\nf : ι → R\ns : Finset ι\nhfs : (s.prod fun i => HSub.hSub Polynomial.X (Polynomial.C (f i))).Separable\nx y : ι\nhx : Membership.mem s x\nhy : Membership.mem s y\nhfxy : Eq (f x) (f y)\n⊢ Eq x y","decl":"theorem Separable.inj_of_prod_X_sub_C [Nontrivial R] {ι : Sort _} {f : ι → R} {s : Finset ι}\n    (hfs : (∏ i ∈ s, (X - C (f i))).Separable) {x y : ι} (hx : x ∈ s) (hy : y ∈ s)\n    (hfxy : f x = f y) : x = y := by\n  classical\n  by_contra hxy\n  rw [← insert_erase hx, prod_insert (not_mem_erase _ _), ←\n    insert_erase (mem_erase_of_ne_of_mem (Ne.symm hxy) hy), prod_insert (not_mem_erase _ _), ←\n    mul_assoc, hfxy, ← sq] at hfs\n  cases (hfs.of_mul_left.of_pow (not_isUnit_X_sub_C _) two_ne_zero).2\n\n"}
{"name":"Polynomial.Separable.injective_of_prod_X_sub_C","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : Nontrivial R\nι : Type u_1\ninst✝ : Fintype ι\nf : ι → R\nhfs : (Finset.univ.prod fun i => HSub.hSub Polynomial.X (Polynomial.C (f i))).Separable\n⊢ Function.Injective f","decl":"theorem Separable.injective_of_prod_X_sub_C [Nontrivial R] {ι : Sort _} [Fintype ι] {f : ι → R}\n    (hfs : (∏ i, (X - C (f i))).Separable) : Function.Injective f := fun _x _y hfxy =>\n  hfs.inj_of_prod_X_sub_C (mem_univ _) (mem_univ _) hfxy\n\n"}
{"name":"Polynomial.nodup_of_separable_prod","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : Nontrivial R\ns : Multiset R\nhs : (Multiset.map (fun a => HSub.hSub Polynomial.X (Polynomial.C a)) s).prod.Separable\n⊢ s.Nodup","decl":"theorem nodup_of_separable_prod [Nontrivial R] {s : Multiset R}\n    (hs : Separable (Multiset.map (fun a => X - C a) s).prod) : s.Nodup := by\n  rw [Multiset.nodup_iff_ne_cons_cons]\n  rintro a t rfl\n  refine not_isUnit_X_sub_C a (isUnit_of_self_mul_dvd_separable hs ?_)\n  simpa only [Multiset.map_cons, Multiset.prod_cons] using mul_dvd_mul_left _ (dvd_mul_right _ _)\n\n"}
{"name":"Polynomial.separable_X_pow_sub_C_unit","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommRing R\nn : Nat\nu : Units R\nhn : IsUnit ↑n\n⊢ (HSub.hSub (HPow.hPow Polynomial.X n) (Polynomial.C ↑u)).Separable","decl":"/-- If `IsUnit n` in a `CommRing R`, then `X ^ n - u` is separable for any unit `u`. -/\ntheorem separable_X_pow_sub_C_unit {n : ℕ} (u : Rˣ) (hn : IsUnit (n : R)) :\n    Separable (X ^ n - C (u : R)) := by\n  nontriviality R\n  rcases n.eq_zero_or_pos with (rfl | hpos)\n  · simp at hn\n  apply (separable_def' (X ^ n - C (u : R))).2\n  obtain ⟨n', hn'⟩ := hn.exists_left_inv\n  refine ⟨-C ↑u⁻¹, C (↑u⁻¹ : R) * C n' * X, ?_⟩\n  rw [derivative_sub, derivative_C, sub_zero, derivative_pow X n, derivative_X, mul_one]\n  calc\n    -C ↑u⁻¹ * (X ^ n - C ↑u) + C ↑u⁻¹ * C n' * X * (↑n * X ^ (n - 1)) =\n        C (↑u⁻¹ * ↑u) - C ↑u⁻¹ * X ^ n + C ↑u⁻¹ * C (n' * ↑n) * (X * X ^ (n - 1)) := by\n      simp only [C.map_mul, C_eq_natCast]\n      ring\n    _ = 1 := by\n      simp only [Units.inv_mul, hn', C.map_one, mul_one, ← pow_succ',\n        Nat.sub_add_cancel (show 1 ≤ n from hpos), sub_add_cancel]\n\n"}
{"name":"Polynomial.separable_C_mul_X_pow_add_C_mul_X_add_C","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝ : CommRing R\nn : Nat\na b c : R\nhn : Eq (↑n) 0\nhb : IsUnit b\n⊢ (HAdd.hAdd (HAdd.hAdd (HMul.hMul (Polynomial.C a) (HPow.hPow Polynomial.X n)) (HMul.hMul (Polynomial.C b) Polynomial.X)) (Polynomial.C c)).Separable","decl":"/-- If `n = 0` in `R` and `b` is a unit, then `a * X ^ n + b * X + c` is separable. -/\ntheorem separable_C_mul_X_pow_add_C_mul_X_add_C\n    {n : ℕ} (a b c : R) (hn : (n : R) = 0) (hb : IsUnit b) :\n    (C a * X ^ n + C b * X + C c).Separable := by\n  set f := C a * X ^ n + C b * X + C c\n  have hderiv : derivative f = C b := by\n    simp_rw [f, map_add derivative, derivative_C]\n    simp [hn]\n  obtain ⟨e, hb⟩ := hb.exists_left_inv\n  refine ⟨-derivative f, f + C e, ?_⟩\n  rw [hderiv, right_distrib, ← add_assoc, neg_mul, mul_comm, neg_add_cancel, zero_add,\n    ← map_mul, hb, map_one]\n\n"}
{"name":"Polynomial.separable_C_mul_X_pow_add_C_mul_X_add_C'","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝¹ : CommRing R\np n : Nat\na b c : R\ninst✝ : CharP R p\nhn : Dvd.dvd p n\nhb : IsUnit b\n⊢ (HAdd.hAdd (HAdd.hAdd (HMul.hMul (Polynomial.C a) (HPow.hPow Polynomial.X n)) (HMul.hMul (Polynomial.C b) Polynomial.X)) (Polynomial.C c)).Separable","decl":"/-- If `R` is of characteristic `p`, `p ∣ n` and `b` is a unit,\nthen `a * X ^ n + b * X + c` is separable. -/\ntheorem separable_C_mul_X_pow_add_C_mul_X_add_C'\n    (p n : ℕ) (a b c : R) [CharP R p] (hn : p ∣ n) (hb : IsUnit b) :\n    (C a * X ^ n + C b * X + C c).Separable :=\n  separable_C_mul_X_pow_add_C_mul_X_add_C a b c ((CharP.cast_eq_zero_iff R p n).2 hn) hb\n\n"}
{"name":"Polynomial.rootMultiplicity_le_one_of_separable","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : Nontrivial R\np : Polynomial R\nhsep : p.Separable\nx : R\n⊢ LE.le (Polynomial.rootMultiplicity x p) 1","decl":"theorem rootMultiplicity_le_one_of_separable [Nontrivial R] {p : R[X]} (hsep : Separable p)\n    (x : R) : rootMultiplicity x p ≤ 1 := by\n  classical\n  by_cases hp : p = 0\n  · simp [hp]\n  rw [rootMultiplicity_eq_multiplicity, if_neg hp, ← Nat.cast_le (α := ℕ∞),\n    Nat.cast_one, ← (finiteMultiplicity_X_sub_C x hp).emultiplicity_eq_multiplicity]\n  apply emultiplicity_le_one_of_separable (not_isUnit_X_sub_C _) hsep\n\n"}
{"name":"Polynomial.count_roots_le_one","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : DecidableEq R\np : Polynomial R\nhsep : p.Separable\nx : R\n⊢ LE.le (Multiset.count x p.roots) 1","decl":"theorem count_roots_le_one [DecidableEq R] {p : R[X]} (hsep : Separable p) (x : R) :\n    p.roots.count x ≤ 1 := by\n  rw [count_roots p]\n  exact rootMultiplicity_le_one_of_separable hsep x\n\n"}
{"name":"Polynomial.nodup_roots","module":"Mathlib.FieldTheory.Separable","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\nhsep : p.Separable\n⊢ p.roots.Nodup","decl":"theorem nodup_roots {p : R[X]} (hsep : Separable p) : p.roots.Nodup := by\n  classical\n  exact Multiset.nodup_iff_count_le_one.mpr (count_roots_le_one hsep)\n\n"}
{"name":"Polynomial.separable_iff_derivative_ne_zero","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u\ninst✝ : Field F\nf : Polynomial F\nhf : Irreducible f\n⊢ Iff f.Separable (Ne (Polynomial.derivative f) 0)","decl":"theorem separable_iff_derivative_ne_zero {f : F[X]} (hf : Irreducible f) :\n    f.Separable ↔ derivative f ≠ 0 :=\n  ⟨fun h1 h2 => hf.not_unit <| isCoprime_zero_right.1 <| h2 ▸ h1, fun h =>\n    EuclideanDomain.isCoprime_of_dvd (mt And.right h) fun g hg1 _hg2 ⟨p, hg3⟩ hg4 =>\n      let ⟨u, hu⟩ := (hf.isUnit_or_isUnit hg3).resolve_left hg1\n      have : f ∣ derivative f := by\n        conv_lhs => rw [hg3, ← hu]\n        rwa [Units.mul_right_dvd]\n      not_lt_of_le (natDegree_le_of_dvd this h) <|\n        natDegree_derivative_lt <| mt derivative_of_natDegree_zero h⟩\n\n"}
{"name":"Polynomial.separable_map","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u\ninst✝² : Field F\nS : Type u_1\ninst✝¹ : CommRing S\ninst✝ : Nontrivial S\nf : RingHom F S\np : Polynomial F\n⊢ Iff (Polynomial.map f p).Separable p.Separable","decl":"attribute [local instance] Ideal.Quotient.field in\ntheorem separable_map {S} [CommRing S] [Nontrivial S] (f : F →+* S) {p : F[X]} :\n    (p.map f).Separable ↔ p.Separable := by\n  refine ⟨fun H ↦ ?_, fun H ↦ H.map⟩\n  obtain ⟨m, hm⟩ := Ideal.exists_maximal S\n  have := Separable.map H (f := Ideal.Quotient.mk m)\n  rwa [map_map, separable_def, derivative_map, isCoprime_map] at this\n\n"}
{"name":"Polynomial.separable_prod_X_sub_C_iff'","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u\ninst✝ : Field F\nι : Type u_1\nf : ι → F\ns : Finset ι\n⊢ Iff (s.prod fun i => HSub.hSub Polynomial.X (Polynomial.C (f i))).Separable (∀ (x : ι), Membership.mem s x → ∀ (y : ι), Membership.mem s y → Eq (f x) (f y) → Eq x y)","decl":"theorem separable_prod_X_sub_C_iff' {ι : Sort _} {f : ι → F} {s : Finset ι} :\n    (∏ i ∈ s, (X - C (f i))).Separable ↔ ∀ x ∈ s, ∀ y ∈ s, f x = f y → x = y :=\n  ⟨fun hfs _ hx _ hy hfxy => hfs.inj_of_prod_X_sub_C hx hy hfxy, fun H => by\n    rw [← prod_attach]\n    exact\n      separable_prod'\n        (fun x _hx y _hy hxy =>\n          @pairwise_coprime_X_sub_C _ _ { x // x ∈ s } (fun x => f x)\n            (fun x y hxy => Subtype.eq <| H x.1 x.2 y.1 y.2 hxy) _ _ hxy)\n        fun _ _ => separable_X_sub_C⟩\n\n"}
{"name":"Polynomial.separable_prod_X_sub_C_iff","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u\ninst✝¹ : Field F\nι : Type u_1\ninst✝ : Fintype ι\nf : ι → F\n⊢ Iff (Finset.univ.prod fun i => HSub.hSub Polynomial.X (Polynomial.C (f i))).Separable (Function.Injective f)","decl":"theorem separable_prod_X_sub_C_iff {ι : Sort _} [Fintype ι] {f : ι → F} :\n    (∏ i, (X - C (f i))).Separable ↔ Function.Injective f :=\n  separable_prod_X_sub_C_iff'.trans <| by simp_rw [mem_univ, true_imp_iff, Function.Injective]\n\n"}
{"name":"Polynomial.separable_or","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u\ninst✝ : Field F\np : Nat\nHF : CharP F p\nf : Polynomial F\nhf : Irreducible f\n⊢ Or f.Separable (And (Not f.Separable) (Exists fun g => And (Irreducible g) (Eq ((Polynomial.expand F p) g) f)))","decl":"theorem separable_or {f : F[X]} (hf : Irreducible f) :\n    f.Separable ∨ ¬f.Separable ∧ ∃ g : F[X], Irreducible g ∧ expand F p g = f := by\n  classical\n  exact if H : derivative f = 0 then by\n    rcases p.eq_zero_or_pos with (rfl | hp)\n    · haveI := CharP.charP_to_charZero F\n      have := natDegree_eq_zero_of_derivative_eq_zero H\n      have := (natDegree_pos_iff_degree_pos.mpr <| degree_pos_of_irreducible hf).ne'\n      contradiction\n    haveI := isLocalHom_expand F hp\n    exact\n      Or.inr\n        ⟨by rw [separable_iff_derivative_ne_zero hf, Classical.not_not, H], contract p f,\n          Irreducible.of_map (by rwa [← expand_contract p H hp.ne'] at hf),\n          expand_contract p H hp.ne'⟩\n  else Or.inl <| (separable_iff_derivative_ne_zero hf).2 H\n\n"}
{"name":"Polynomial.exists_separable_of_irreducible","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u\ninst✝ : Field F\np : Nat\nHF : CharP F p\nf : Polynomial F\nhf : Irreducible f\nhp : Ne p 0\n⊢ Exists fun n => Exists fun g => And g.Separable (Eq ((Polynomial.expand F (HPow.hPow p n)) g) f)","decl":"theorem exists_separable_of_irreducible {f : F[X]} (hf : Irreducible f) (hp : p ≠ 0) :\n    ∃ (n : ℕ) (g : F[X]), g.Separable ∧ expand F (p ^ n) g = f := by\n  replace hp : p.Prime := (CharP.char_is_prime_or_zero F p).resolve_right hp\n  induction' hn : f.natDegree using Nat.strong_induction_on with N ih generalizing f\n  rcases separable_or p hf with (h | ⟨h1, g, hg, hgf⟩)\n  · refine ⟨0, f, h, ?_⟩\n    rw [pow_zero, expand_one]\n  · cases' N with N\n    · rw [natDegree_eq_zero_iff_degree_le_zero, degree_le_zero_iff] at hn\n      rw [hn, separable_C, isUnit_iff_ne_zero, Classical.not_not] at h1\n      have hf0 : f ≠ 0 := hf.ne_zero\n      rw [h1, C_0] at hn\n      exact absurd hn hf0\n    have hg1 : g.natDegree * p = N.succ := by rwa [← natDegree_expand, hgf]\n    have hg2 : g.natDegree ≠ 0 := by\n      intro this\n      rw [this, zero_mul] at hg1\n      cases hg1\n    have hg3 : g.natDegree < N.succ := by\n      rw [← mul_one g.natDegree, ← hg1]\n      exact Nat.mul_lt_mul_of_pos_left hp.one_lt hg2.bot_lt\n    rcases ih _ hg3 hg rfl with ⟨n, g, hg4, rfl⟩\n    refine ⟨n + 1, g, hg4, ?_⟩\n    rw [← hgf, expand_expand, pow_succ']\n\n"}
{"name":"Polynomial.isUnit_or_eq_zero_of_separable_expand","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u\ninst✝ : Field F\np : Nat\nHF : CharP F p\nf : Polynomial F\nn : Nat\nhp : LT.lt 0 p\nhf : ((Polynomial.expand F (HPow.hPow p n)) f).Separable\n⊢ Or (IsUnit f) (Eq n 0)","decl":"theorem isUnit_or_eq_zero_of_separable_expand {f : F[X]} (n : ℕ) (hp : 0 < p)\n    (hf : (expand F (p ^ n) f).Separable) : IsUnit f ∨ n = 0 := by\n  rw [or_iff_not_imp_right]\n  rintro hn : n ≠ 0\n  have hf2 : derivative (expand F (p ^ n) f) = 0 := by\n    rw [derivative_expand, Nat.cast_pow, CharP.cast_eq_zero, zero_pow hn, zero_mul, mul_zero]\n  rw [separable_def, hf2, isCoprime_zero_right, isUnit_iff] at hf\n  rcases hf with ⟨r, hr, hrf⟩\n  rw [eq_comm, expand_eq_C (pow_pos hp _)] at hrf\n  rwa [hrf, isUnit_C]\n\n"}
{"name":"Polynomial.unique_separable_of_irreducible","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u\ninst✝ : Field F\np : Nat\nHF : CharP F p\nf : Polynomial F\nhf : Irreducible f\nhp : LT.lt 0 p\nn₁ : Nat\ng₁ : Polynomial F\nhg₁ : g₁.Separable\nhgf₁ : Eq ((Polynomial.expand F (HPow.hPow p n₁)) g₁) f\nn₂ : Nat\ng₂ : Polynomial F\nhg₂ : g₂.Separable\nhgf₂ : Eq ((Polynomial.expand F (HPow.hPow p n₂)) g₂) f\n⊢ And (Eq n₁ n₂) (Eq g₁ g₂)","decl":"theorem unique_separable_of_irreducible {f : F[X]} (hf : Irreducible f) (hp : 0 < p) (n₁ : ℕ)\n    (g₁ : F[X]) (hg₁ : g₁.Separable) (hgf₁ : expand F (p ^ n₁) g₁ = f) (n₂ : ℕ) (g₂ : F[X])\n    (hg₂ : g₂.Separable) (hgf₂ : expand F (p ^ n₂) g₂ = f) : n₁ = n₂ ∧ g₁ = g₂ := by\n  revert g₁ g₂\n  wlog hn : n₁ ≤ n₂\n  · intro g₁ hg₁ Hg₁ g₂ hg₂ Hg₂\n    simpa only [eq_comm] using this p hf hp n₂ n₁ (le_of_not_le hn) g₂ hg₂ Hg₂ g₁ hg₁ Hg₁\n  have hf0 : f ≠ 0 := hf.ne_zero\n  intros g₁ hg₁ hgf₁ g₂ hg₂ hgf₂\n  rw [le_iff_exists_add] at hn\n  rcases hn with ⟨k, rfl⟩\n  rw [← hgf₁, pow_add, expand_mul, expand_inj (pow_pos hp n₁)] at hgf₂\n  subst hgf₂\n  subst hgf₁\n  rcases isUnit_or_eq_zero_of_separable_expand p k hp hg₁ with (h | rfl)\n  · rw [isUnit_iff] at h\n    rcases h with ⟨r, hr, rfl⟩\n    simp_rw [expand_C] at hf\n    exact absurd (isUnit_C.2 hr) hf.1\n  · rw [add_zero, pow_zero, expand_one]\n    constructor <;> rfl\n\n"}
{"name":"Polynomial.separable_X_pow_sub_C","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u\ninst✝ : Field F\nn : Nat\na : F\nhn : Ne (↑n) 0\nha : Ne a 0\n⊢ (HSub.hSub (HPow.hPow Polynomial.X n) (Polynomial.C a)).Separable","decl":"/-- If `n ≠ 0` in `F`, then `X ^ n - a` is separable for any `a ≠ 0`. -/\ntheorem separable_X_pow_sub_C {n : ℕ} (a : F) (hn : (n : F) ≠ 0) (ha : a ≠ 0) :\n    Separable (X ^ n - C a) :=\n  separable_X_pow_sub_C_unit (Units.mk0 a ha) (IsUnit.mk0 (n : F) hn)\n\n"}
{"name":"Polynomial.separable_X_pow_sub_C'","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u\ninst✝¹ : Field F\np n : Nat\na : F\ninst✝ : CharP F p\nhn : Not (Dvd.dvd p n)\nha : Ne a 0\n⊢ (HSub.hSub (HPow.hPow Polynomial.X n) (Polynomial.C a)).Separable","decl":"/-- If `F` is of characteristic `p` and `p ∤ n`, then `X ^ n - a` is separable for any `a ≠ 0`. -/\ntheorem separable_X_pow_sub_C' (p n : ℕ) (a : F) [CharP F p] (hn : ¬p ∣ n) (ha : a ≠ 0) :\n    Separable (X ^ n - C a) :=\n  separable_X_pow_sub_C a (by rwa [← CharP.cast_eq_zero_iff F p n] at hn) ha\n\n-- this can possibly be strengthened to making `separable_X_pow_sub_C_unit` a\n-- bi-implication, but it is nontrivial!\n"}
{"name":"Polynomial.X_pow_sub_one_separable_iff","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u\ninst✝ : Field F\nn : Nat\n⊢ Iff (HSub.hSub (HPow.hPow Polynomial.X n) 1).Separable (Ne (↑n) 0)","decl":"/-- In a field `F`, `X ^ n - 1` is separable iff `↑n ≠ 0`. -/\ntheorem X_pow_sub_one_separable_iff {n : ℕ} : (X ^ n - 1 : F[X]).Separable ↔ (n : F) ≠ 0 := by\n  refine ⟨?_, fun h => separable_X_pow_sub_C_unit 1 (IsUnit.mk0 _ h)⟩\n  rw [separable_def', derivative_sub, derivative_X_pow, derivative_one, sub_zero]\n  -- Suppose `(n : F) = 0`, then the derivative is `0`, so `X ^ n - 1` is a unit, contradiction.\n  rintro (h : IsCoprime _ _) hn'\n  rw [hn', C_0, zero_mul, isCoprime_zero_right] at h\n  exact not_isUnit_X_pow_sub_one F n h\n\n"}
{"name":"Polynomial.card_rootSet_eq_natDegree","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u\ninst✝² : Field F\nK : Type v\ninst✝¹ : Field K\ninst✝ : Algebra F K\np : Polynomial F\nhsep : p.Separable\nhsplit : Polynomial.Splits (algebraMap F K) p\n⊢ Eq (Fintype.card ↑(p.rootSet K)) p.natDegree","decl":"theorem card_rootSet_eq_natDegree [Algebra F K] {p : F[X]} (hsep : p.Separable)\n    (hsplit : Splits (algebraMap F K) p) : Fintype.card (p.rootSet K) = p.natDegree := by\n  classical\n  simp_rw [rootSet_def, Finset.coe_sort_coe, Fintype.card_coe]\n  rw [Multiset.toFinset_card_of_nodup (nodup_roots hsep.map), ← natDegree_eq_card_roots hsplit]\n\n"}
{"name":"Polynomial.nodup_roots_iff_of_splits","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u\ninst✝ : Field F\nf : Polynomial F\nhf : Ne f 0\nh : Polynomial.Splits (RingHom.id F) f\n⊢ Iff f.roots.Nodup f.Separable","decl":"/-- If a non-zero polynomial splits, then it has no repeated roots on that field\nif and only if it is separable. -/\ntheorem nodup_roots_iff_of_splits {f : F[X]} (hf : f ≠ 0) (h : f.Splits (RingHom.id F)) :\n    f.roots.Nodup ↔ f.Separable := by\n  classical\n  refine ⟨(fun hnsep ↦ ?_).mtr, nodup_roots⟩\n  rw [Separable, ← gcd_isUnit_iff, isUnit_iff_degree_eq_zero] at hnsep\n  obtain ⟨x, hx⟩ := exists_root_of_splits _\n    (splits_of_splits_of_dvd _ hf h (gcd_dvd_left f _)) hnsep\n  simp_rw [Multiset.nodup_iff_count_le_one, not_forall, not_le]\n  exact ⟨x, ((one_lt_rootMultiplicity_iff_isRoot_gcd hf).2 hx).trans_eq f.count_roots.symm⟩\n\n"}
{"name":"Polynomial.nodup_aroots_iff_of_splits","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u\ninst✝² : Field F\nK : Type v\ninst✝¹ : Field K\ninst✝ : Algebra F K\nf : Polynomial F\nhf : Ne f 0\nh : Polynomial.Splits (algebraMap F K) f\n⊢ Iff (f.aroots K).Nodup f.Separable","decl":"/-- If a non-zero polynomial over `F` splits in `K`, then it has no repeated roots on `K`\nif and only if it is separable. -/\n@[stacks 09H3 \"Here we only require `f` splits instead of `K` is algebraically closed.\"]\ntheorem nodup_aroots_iff_of_splits [Algebra F K] {f : F[X]} (hf : f ≠ 0)\n    (h : f.Splits (algebraMap F K)) : (f.aroots K).Nodup ↔ f.Separable := by\n  rw [← (algebraMap F K).id_comp, ← splits_map_iff] at h\n  rw [nodup_roots_iff_of_splits (map_ne_zero hf) h, separable_map]\n\n"}
{"name":"Polynomial.card_rootSet_eq_natDegree_iff_of_splits","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u\ninst✝² : Field F\nK : Type v\ninst✝¹ : Field K\ninst✝ : Algebra F K\nf : Polynomial F\nhf : Ne f 0\nh : Polynomial.Splits (algebraMap F K) f\n⊢ Iff (Eq (Fintype.card ↑(f.rootSet K)) f.natDegree) f.Separable","decl":"theorem card_rootSet_eq_natDegree_iff_of_splits [Algebra F K] {f : F[X]} (hf : f ≠ 0)\n    (h : f.Splits (algebraMap F K)) : Fintype.card (f.rootSet K) = f.natDegree ↔ f.Separable := by\n  classical\n  simp_rw [rootSet_def, Finset.coe_sort_coe, Fintype.card_coe, natDegree_eq_card_roots h,\n    Multiset.toFinset_card_eq_card_iff_nodup, nodup_aroots_iff_of_splits hf h]\n\n"}
{"name":"Polynomial.eq_X_sub_C_of_separable_of_root_eq","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u\ninst✝¹ : Field F\nK : Type v\ninst✝ : Field K\ni : RingHom F K\nx : F\nh : Polynomial F\nh_sep : h.Separable\nh_root : Eq (Polynomial.eval x h) 0\nh_splits : Polynomial.Splits i h\nh_roots : ∀ (y : K), Membership.mem (Polynomial.map i h).roots y → Eq y (i x)\n⊢ Eq h (HMul.hMul (Polynomial.C h.leadingCoeff) (HSub.hSub Polynomial.X (Polynomial.C x)))","decl":"theorem eq_X_sub_C_of_separable_of_root_eq {x : F} {h : F[X]} (h_sep : h.Separable)\n    (h_root : h.eval x = 0) (h_splits : Splits i h) (h_roots : ∀ y ∈ (h.map i).roots, y = i x) :\n    h = C (leadingCoeff h) * (X - C x) := by\n  have h_ne_zero : h ≠ 0 := by\n    rintro rfl\n    exact not_separable_zero h_sep\n  apply Polynomial.eq_X_sub_C_of_splits_of_single_root i h_splits\n  apply Finset.mk.inj\n  · change _ = {i x}\n    rw [Finset.eq_singleton_iff_unique_mem]\n    constructor\n    · apply Finset.mem_mk.mpr\n      · rw [mem_roots (show h.map i ≠ 0 from map_ne_zero h_ne_zero)]\n        rw [IsRoot.def, ← eval₂_eq_eval_map, eval₂_hom, h_root]\n        exact RingHom.map_zero i\n      · exact nodup_roots (Separable.map h_sep)\n    · exact h_roots\n\n"}
{"name":"Polynomial.exists_finset_of_splits","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u\ninst✝¹ : Field F\nK : Type v\ninst✝ : Field K\ni : RingHom F K\nf : Polynomial F\nsep : f.Separable\nsp : Polynomial.Splits i f\n⊢ Exists fun s => Eq (Polynomial.map i f) (HMul.hMul (Polynomial.C (i f.leadingCoeff)) (s.prod fun a => HSub.hSub Polynomial.X (Polynomial.C a)))","decl":"theorem exists_finset_of_splits (i : F →+* K) {f : F[X]} (sep : Separable f) (sp : Splits i f) :\n    ∃ s : Finset K, f.map i = C (i f.leadingCoeff) * s.prod fun a : K => X - C a := by\n  classical\n  obtain ⟨s, h⟩ := (splits_iff_exists_multiset _).1 sp\n  use s.toFinset\n  rw [h, Finset.prod_eq_multiset_prod, ← Multiset.toFinset_eq]\n  apply nodup_of_separable_prod\n  apply Separable.of_mul_right\n  rw [← h]\n  exact sep.map\n\n"}
{"name":"Irreducible.separable","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u\ninst✝¹ : Field F\ninst✝ : CharZero F\nf : Polynomial F\nhf : Irreducible f\n⊢ f.Separable","decl":"theorem _root_.Irreducible.separable [CharZero F] {f : F[X]} (hf : Irreducible f) :\n    f.Separable := by\n  rw [separable_iff_derivative_ne_zero hf, Ne, ← degree_eq_bot, degree_derivative_eq]\n  · rintro ⟨⟩\n  rw [pos_iff_ne_zero, Ne, natDegree_eq_zero_iff_degree_le_zero, degree_le_zero_iff]\n  refine fun hf1 => hf.not_unit ?_\n  rw [hf1, isUnit_C, isUnit_iff_ne_zero]\n  intro hf2\n  rw [hf2, C_0] at hf1\n  exact absurd hf1 hf.ne_zero\n\n"}
{"name":"Algebra.IsSeparable.isSeparable'","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\nK : Type u_3\ninst✝² : CommRing F\ninst✝¹ : Ring K\ninst✝ : Algebra F K\nself : Algebra.IsSeparable F K\nx : K\n⊢ IsSeparable F x","decl":"/-- Typeclass for separable field extension: `K` is a separable field extension of `F` iff\nthe minimal polynomial of every `x : K` is separable. This implies that `K/F` is an algebraic\nextension, because the minimal polynomial of a non-integral element is `0`, which is not\nseparable.\n\nWe define this for general (commutative) rings and only assume `F` and `K` are fields if this\nis needed for a proof. -/\n@[mk_iff isSeparable_def, stacks 09H1 \"third part\"]\nprotected class Algebra.IsSeparable : Prop where\n  isSeparable' : ∀ x : K, IsSeparable F x\n\n"}
{"name":"Algebra.isSeparable_def","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\nK : Type u_3\ninst✝² : CommRing F\ninst✝¹ : Ring K\ninst✝ : Algebra F K\n⊢ Iff (Algebra.IsSeparable F K) (∀ (x : K), IsSeparable F x)","decl":"/-- Typeclass for separable field extension: `K` is a separable field extension of `F` iff\nthe minimal polynomial of every `x : K` is separable. This implies that `K/F` is an algebraic\nextension, because the minimal polynomial of a non-integral element is `0`, which is not\nseparable.\n\nWe define this for general (commutative) rings and only assume `F` and `K` are fields if this\nis needed for a proof. -/\n@[mk_iff isSeparable_def, stacks 09H1 \"third part\"]\nprotected class Algebra.IsSeparable : Prop where\n  isSeparable' : ∀ x : K, IsSeparable F x\n\n"}
{"name":"Algebra.IsSeparable.isSeparable","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\nK : Type u_3\ninst✝³ : CommRing F\ninst✝² : Ring K\ninst✝¹ : Algebra F K\ninst✝ : Algebra.IsSeparable F K\nx : K\n⊢ IsSeparable F x","decl":"theorem Algebra.IsSeparable.isSeparable [Algebra.IsSeparable F K] : ∀ x : K, IsSeparable F x :=\n  Algebra.IsSeparable.isSeparable'\n\n"}
{"name":"IsSeparable.isIntegral","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\nK : Type u_3\ninst✝² : CommRing F\ninst✝¹ : Ring K\ninst✝ : Algebra F K\nx : K\nh : IsSeparable F x\n⊢ IsIntegral F x","decl":"variable {F} in\n/-- If the minimal polynomial of `x : K` over `F` is separable, then `x` is integral over `F`,\nbecause the minimal polynomial of a non-integral element is `0`, which is not separable. -/\ntheorem IsSeparable.isIntegral {x : K} (h : IsSeparable F x) : IsIntegral F x := by\n  cases subsingleton_or_nontrivial F\n  · haveI := Module.subsingleton F K\n    exact ⟨1, monic_one, Subsingleton.elim _ _⟩\n  · exact of_not_not (h.ne_zero <| minpoly.eq_zero ·)\n\n"}
{"name":"Algebra.IsSeparable.isIntegral","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\nK : Type u_3\ninst✝³ : CommRing F\ninst✝² : Ring K\ninst✝¹ : Algebra F K\ninst✝ : Algebra.IsSeparable F K\nx : K\n⊢ IsIntegral F x","decl":"theorem Algebra.IsSeparable.isIntegral [Algebra.IsSeparable F K] : ∀ x : K, IsIntegral F x :=\n  fun x ↦ _root_.IsSeparable.isIntegral (Algebra.IsSeparable.isSeparable F x)\n\n"}
{"name":"Algebra.IsSeparable.isAlgebraic","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\nK : Type u_3\ninst✝⁴ : CommRing F\ninst✝³ : Ring K\ninst✝² : Algebra F K\ninst✝¹ : Nontrivial F\ninst✝ : Algebra.IsSeparable F K\n⊢ Algebra.IsAlgebraic F K","decl":"variable (K) in\ninstance Algebra.IsSeparable.isAlgebraic [Nontrivial F] [Algebra.IsSeparable F K] :\n    Algebra.IsAlgebraic F K :=\n  ⟨fun x ↦ (Algebra.IsSeparable.isIntegral F x).isAlgebraic⟩\n\n"}
{"name":"Algebra.isSeparable_iff","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\nK : Type u_3\ninst✝² : CommRing F\ninst✝¹ : Ring K\ninst✝ : Algebra F K\n⊢ Iff (Algebra.IsSeparable F K) (∀ (x : K), And (IsIntegral F x) (IsSeparable F x))","decl":"theorem Algebra.isSeparable_iff :\n    Algebra.IsSeparable F K ↔ ∀ x : K, IsIntegral F x ∧ IsSeparable F x :=\n  ⟨fun _ x => ⟨Algebra.IsSeparable.isIntegral F x, Algebra.IsSeparable.isSeparable F x⟩,\n    fun h => ⟨fun x => (h x).2⟩⟩\n\n"}
{"name":"AlgEquiv.isSeparable_iff","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\nK : Type u_3\ninst✝⁴ : CommRing F\ninst✝³ : Ring K\ninst✝² : Algebra F K\nE : Type u_4\ninst✝¹ : Ring E\ninst✝ : Algebra F E\ne : AlgEquiv F K E\nx : K\n⊢ Iff (IsSeparable F (e x)) (IsSeparable F x)","decl":"/-- Transfer `IsSeparable` across an `AlgEquiv`. -/\ntheorem AlgEquiv.isSeparable_iff {x : K} : IsSeparable F (e x) ↔ IsSeparable F x := by\n  simp only [IsSeparable, minpoly.algEquiv_eq e x]\n\n"}
{"name":"AlgEquiv.Algebra.isSeparable","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\nK : Type u_3\ninst✝⁵ : CommRing F\ninst✝⁴ : Ring K\ninst✝³ : Algebra F K\nE : Type u_4\ninst✝² : Ring E\ninst✝¹ : Algebra F E\ne : AlgEquiv F K E\ninst✝ : Algebra.IsSeparable F K\n⊢ Algebra.IsSeparable F E","decl":"/-- Transfer `Algebra.IsSeparable` across an `AlgEquiv`. -/\ntheorem AlgEquiv.Algebra.isSeparable [Algebra.IsSeparable F K] : Algebra.IsSeparable F E :=\n  ⟨fun _ ↦ e.symm.isSeparable_iff.mp (Algebra.IsSeparable.isSeparable _ _)⟩\n\n"}
{"name":"AlgEquiv.isSeparable","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\nK : Type u_3\ninst✝⁵ : CommRing F\ninst✝⁴ : Ring K\ninst✝³ : Algebra F K\nE : Type u_4\ninst✝² : Ring E\ninst✝¹ : Algebra F E\ne : AlgEquiv F K E\ninst✝ : Algebra.IsSeparable F K\n⊢ Algebra.IsSeparable F E","decl":"@[deprecated (since := \"2024-08-06\")]\nalias AlgEquiv.isSeparable := AlgEquiv.Algebra.isSeparable\n\n"}
{"name":"AlgEquiv.Algebra.isSeparable_iff","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\nK : Type u_3\ninst✝⁴ : CommRing F\ninst✝³ : Ring K\ninst✝² : Algebra F K\nE : Type u_4\ninst✝¹ : Ring E\ninst✝ : Algebra F E\ne : AlgEquiv F K E\n⊢ Iff (Algebra.IsSeparable F K) (Algebra.IsSeparable F E)","decl":"theorem AlgEquiv.Algebra.isSeparable_iff : Algebra.IsSeparable F K ↔ Algebra.IsSeparable F E :=\n  ⟨fun _ ↦ AlgEquiv.Algebra.isSeparable e, fun _ ↦ AlgEquiv.Algebra.isSeparable e.symm⟩\n\n"}
{"name":"IsSeparable.tower_top","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\nL : Type u_2\ninst✝⁶ : CommRing F\nE : Type u_4\ninst✝⁵ : Field L\ninst✝⁴ : Ring E\ninst✝³ : Algebra F L\ninst✝² : Algebra F E\ninst✝¹ : Algebra L E\ninst✝ : IsScalarTower F L E\nx : E\nh : IsSeparable F x\n⊢ IsSeparable L x","decl":"/-- If `E / L / F` is a scalar tower and `x : E` is separable over `F`, then it's also separable\nover `L`. -/\n@[stacks 09H2 \"first part\"]\ntheorem IsSeparable.tower_top\n    {x : E} (h : IsSeparable F x) : IsSeparable L x :=\n  h.map.of_dvd (minpoly.dvd_map_of_isScalarTower _ _ _)\n\n"}
{"name":"Algebra.isSeparable_tower_top_of_isSeparable","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\nL : Type u_2\ninst✝⁷ : CommRing F\nE : Type u_4\ninst✝⁶ : Field L\ninst✝⁵ : Ring E\ninst✝⁴ : Algebra F L\ninst✝³ : Algebra F E\ninst✝² : Algebra L E\ninst✝¹ : IsScalarTower F L E\ninst✝ : Algebra.IsSeparable F E\n⊢ Algebra.IsSeparable L E","decl":"variable (F E) in\n/-- If `E / K / F` is an extension tower, `E` is separable over `F`, then it's also separable\nover `K`. -/\n@[stacks 09H2 \"second part\"]\ntheorem Algebra.isSeparable_tower_top_of_isSeparable [Algebra.IsSeparable F E] :\n    Algebra.IsSeparable L E :=\n  ⟨fun x ↦ IsSeparable.tower_top _ (Algebra.IsSeparable.isSeparable F x)⟩\n\n"}
{"name":"IsSeparable.of_isScalarTower","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\nL : Type u_2\ninst✝⁷ : CommRing F\nE : Type u_4\ninst✝⁶ : Field L\ninst✝⁵ : Ring E\ninst✝⁴ : Algebra F L\ninst✝³ : Algebra F E\ninst✝² : Algebra L E\ninst✝¹ : IsScalarTower F L E\ninst✝ : Algebra.IsSeparable F E\n⊢ Algebra.IsSeparable L E","decl":"@[deprecated (since := \"2024-08-06\")]\nalias IsSeparable.of_isScalarTower := Algebra.isSeparable_tower_top_of_isSeparable\n\n"}
{"name":"isSeparable_algebraMap","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\ninst✝² : Field F\nK : Type u_2\ninst✝¹ : Ring K\ninst✝ : Algebra F K\nx : F\n⊢ IsSeparable F ((algebraMap F K) x)","decl":"variable {F} in\ntheorem isSeparable_algebraMap (x : F) : IsSeparable F (algebraMap F K x) :=\n  Polynomial.Separable.of_dvd (Polynomial.separable_X_sub_C (x := x))\n    (minpoly.dvd F (algebraMap F K x) (by simp only [map_sub, aeval_X, aeval_C, sub_self]))\n\n"}
{"name":"Algebra.isSeparable_self","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\ninst✝ : Field F\n⊢ Algebra.IsSeparable F F","decl":"instance Algebra.isSeparable_self : Algebra.IsSeparable F F :=\n  ⟨isSeparable_algebraMap⟩\n\n"}
{"name":"IsSeparable.of_integral","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\ninst✝⁵ : Field F\nK : Type u_2\ninst✝⁴ : Ring K\ninst✝³ : Algebra F K\ninst✝² : IsDomain K\ninst✝¹ : Algebra.IsIntegral F K\ninst✝ : CharZero F\nx : K\n⊢ IsSeparable F x","decl":"theorem IsSeparable.of_integral (x : K) : IsSeparable F x :=\n  (minpoly.irreducible <| Algebra.IsIntegral.isIntegral x).separable\n\n-- See note [lower instance priority]\n"}
{"name":"Algebra.IsSeparable.of_integral","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\ninst✝⁵ : Field F\nK : Type u_2\ninst✝⁴ : Ring K\ninst✝³ : Algebra F K\ninst✝² : IsDomain K\ninst✝¹ : Algebra.IsIntegral F K\ninst✝ : CharZero F\n⊢ Algebra.IsSeparable F K","decl":"variable (K) in\n/-- A integral field extension in characteristic 0 is separable. -/\nprotected instance (priority := 100) Algebra.IsSeparable.of_integral : Algebra.IsSeparable F K :=\n  ⟨_root_.IsSeparable.of_integral _⟩\n\n"}
{"name":"IsSeparable.tower_bot","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\ninst✝⁷ : Field F\nK : Type u_2\nE : Type u_3\ninst✝⁶ : Field K\ninst✝⁵ : Ring E\ninst✝⁴ : Algebra F K\ninst✝³ : Algebra F E\ninst✝² : Algebra K E\ninst✝¹ : Nontrivial E\ninst✝ : IsScalarTower F K E\nx : K\nh : IsSeparable F ((algebraMap K E) x)\n⊢ IsSeparable F x","decl":"variable {F} in\n/-- If `E / K / F` is a scalar tower and `algebraMap K E x` is separable over `F`, then `x` is\nalso separable over `F`. -/\ntheorem IsSeparable.tower_bot {x : K} (h : IsSeparable F (algebraMap K E x)) : IsSeparable F x :=\n    have ⟨_q, hq⟩ :=\n      minpoly.dvd F x\n        ((aeval_algebraMap_eq_zero_iff _ _ _).mp (minpoly.aeval F ((algebraMap K E) x)))\n    (Eq.mp (congrArg Separable hq) h).of_mul_left\n\n"}
{"name":"Algebra.isSeparable_tower_bot_of_isSeparable","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\ninst✝⁷ : Field F\nK : Type u_2\nE : Type u_3\ninst✝⁶ : Field K\ninst✝⁵ : Ring E\ninst✝⁴ : Algebra F K\ninst✝³ : Algebra F E\ninst✝² : Algebra K E\ninst✝¹ : Nontrivial E\ninst✝ : IsScalarTower F K E\nh : Algebra.IsSeparable F E\n⊢ Algebra.IsSeparable F K","decl":"variable (K E) in\ntheorem Algebra.isSeparable_tower_bot_of_isSeparable [h : Algebra.IsSeparable F E] :\n    Algebra.IsSeparable F K :=\n  ⟨fun _ ↦ IsSeparable.tower_bot (h.isSeparable _ _)⟩\n\n"}
{"name":"IsSeparable.of_algHom","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\ninst✝⁴ : Field F\nE : Type u_3\nE' : Type u_4\ninst✝³ : Field E\ninst✝² : Field E'\ninst✝¹ : Algebra F E\ninst✝ : Algebra F E'\nf : AlgHom F E E'\nx : E\nh : IsSeparable F (f x)\n⊢ IsSeparable F x","decl":"variable {F} in\ntheorem IsSeparable.of_algHom {x : E} (h : IsSeparable F (f x)) : IsSeparable F x := by\n  let _ : Algebra E E' := RingHom.toAlgebra f.toRingHom\n  haveI : IsScalarTower F E E' := IsScalarTower.of_algebraMap_eq fun x => (f.commutes x).symm\n  exact h.tower_bot\n\n\n"}
{"name":"Algebra.IsSeparable.of_algHom","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\ninst✝⁵ : Field F\nE : Type u_3\nE' : Type u_4\ninst✝⁴ : Field E\ninst✝³ : Field E'\ninst✝² : Algebra F E\ninst✝¹ : Algebra F E'\nf : AlgHom F E E'\ninst✝ : Algebra.IsSeparable F E'\n⊢ Algebra.IsSeparable F E","decl":"variable (E') in\ntheorem Algebra.IsSeparable.of_algHom [Algebra.IsSeparable F E'] : Algebra.IsSeparable F E :=\n  ⟨fun x => (Algebra.IsSeparable.isSeparable F (f x)).of_algHom⟩\n\n"}
{"name":"IntermediateField.isSeparable_tower_bot","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\ninst✝³ : Field F\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra F K\nM : IntermediateField F K\ninst✝ : Algebra.IsSeparable F K\n⊢ Algebra.IsSeparable F (Subtype fun x => Membership.mem M x)","decl":"instance isSeparable_tower_bot [Algebra.IsSeparable F K] : Algebra.IsSeparable F M :=\n  Algebra.isSeparable_tower_bot_of_isSeparable F M K\n\n"}
{"name":"IntermediateField.isSeparable_tower_top","module":"Mathlib.FieldTheory.Separable","initialProofState":"F : Type u_1\ninst✝³ : Field F\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra F K\nM : IntermediateField F K\ninst✝ : Algebra.IsSeparable F K\n⊢ Algebra.IsSeparable (Subtype fun x => Membership.mem M x) K","decl":"instance isSeparable_tower_top [Algebra.IsSeparable F K] : Algebra.IsSeparable M K :=\n  Algebra.isSeparable_tower_top_of_isSeparable F M K\n\n"}
{"name":"IsSeparable.of_equiv_equiv","module":"Mathlib.FieldTheory.Separable","initialProofState":"A₁ : Type u_1\nB₁ : Type u_2\nA₂ : Type u_3\nB₂ : Type u_4\ninst✝⁵ : Field A₁\ninst✝⁴ : Ring B₁\ninst✝³ : Field A₂\ninst✝² : Ring B₂\ninst✝¹ : Algebra A₁ B₁\ninst✝ : Algebra A₂ B₂\ne₁ : RingEquiv A₁ A₂\ne₂ : RingEquiv B₁ B₂\nhe : Eq ((algebraMap A₂ B₂).comp ↑e₁) ((↑e₂).comp (algebraMap A₁ B₁))\nx : B₁\nh : IsSeparable A₁ x\n⊢ IsSeparable A₂ (e₂ x)","decl":"lemma IsSeparable.of_equiv_equiv {x : B₁} (h : IsSeparable A₁ x) : IsSeparable A₂ (e₂ x) :=\n  letI := e₁.toRingHom.toAlgebra\n  letI : Algebra A₂ B₁ :=\n    { (algebraMap A₁ B₁).comp e₁.symm.toRingHom with\n        smul := fun a b ↦ ((algebraMap A₁ B₁).comp e₁.symm.toRingHom a) * b\n        commutes' := fun r x ↦ (Algebra.commutes) (e₁.symm.toRingHom r) x\n        smul_def' := fun _ _ ↦ rfl }\n  haveI : IsScalarTower A₁ A₂ B₁ := IsScalarTower.of_algebraMap_eq <| fun x ↦\n      (algebraMap A₁ B₁).congr_arg <| id ((e₁.symm_apply_apply x).symm)\n  let e : B₁ ≃ₐ[A₂] B₂ :=\n    { e₂ with\n      commutes' := fun x ↦ by\n        simpa [RingHom.algebraMap_toAlgebra] using DFunLike.congr_fun he.symm (e₁.symm x) }\n  (AlgEquiv.isSeparable_iff e).mpr <| IsSeparable.tower_top A₂ h\n\n"}
{"name":"Algebra.IsSeparable.of_equiv_equiv","module":"Mathlib.FieldTheory.Separable","initialProofState":"A₁ : Type u_1\nB₁ : Type u_2\nA₂ : Type u_3\nB₂ : Type u_4\ninst✝⁶ : Field A₁\ninst✝⁵ : Ring B₁\ninst✝⁴ : Field A₂\ninst✝³ : Ring B₂\ninst✝² : Algebra A₁ B₁\ninst✝¹ : Algebra A₂ B₂\ne₁ : RingEquiv A₁ A₂\ne₂ : RingEquiv B₁ B₂\nhe : Eq ((algebraMap A₂ B₂).comp ↑e₁) ((↑e₂).comp (algebraMap A₁ B₁))\ninst✝ : Algebra.IsSeparable A₁ B₁\n⊢ Algebra.IsSeparable A₂ B₂","decl":"lemma Algebra.IsSeparable.of_equiv_equiv [Algebra.IsSeparable A₁ B₁] : Algebra.IsSeparable A₂ B₂ :=\n  ⟨fun x ↦ (e₂.apply_symm_apply x) ▸ _root_.IsSeparable.of_equiv_equiv e₁ e₂ he\n    (Algebra.IsSeparable.isSeparable _ _)⟩\n\n"}
{"name":"AlgHom.card_of_powerBasis","module":"Mathlib.FieldTheory.Separable","initialProofState":"S : Type u_2\ninst✝⁴ : CommRing S\nK : Type u_4\nL : Type u_5\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K S\ninst✝ : Algebra K L\npb : PowerBasis K S\nh_sep : IsSeparable K pb.gen\nh_splits : Polynomial.Splits (algebraMap K L) (minpoly K pb.gen)\n⊢ Eq (Fintype.card (AlgHom K S L)) pb.dim","decl":"theorem AlgHom.card_of_powerBasis (pb : PowerBasis K S) (h_sep : IsSeparable K pb.gen)\n    (h_splits : (minpoly K pb.gen).Splits (algebraMap K L)) :\n    @Fintype.card (S →ₐ[K] L) (PowerBasis.AlgHom.fintype pb) = pb.dim := by\n  classical\n  let _ := (PowerBasis.AlgHom.fintype pb : Fintype (S →ₐ[K] L))\n  rw [Fintype.card_congr pb.liftEquiv', Fintype.card_of_subtype _ (fun x => Multiset.mem_toFinset),\n    ← pb.natDegree_minpoly, natDegree_eq_card_roots h_splits, Multiset.toFinset_card_of_nodup]\n  exact nodup_roots ((separable_map (algebraMap K L)).mpr h_sep)\n\n"}
