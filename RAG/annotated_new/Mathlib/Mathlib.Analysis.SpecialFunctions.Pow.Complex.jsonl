{"name":"Complex.cpow_eq_pow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x y : Complex\n⊢ Eq (x.cpow y) (HPow.hPow x y)","decl":"@[simp]\ntheorem cpow_eq_pow (x y : ℂ) : cpow x y = x ^ y :=\n  rfl\n\n"}
{"name":"Complex.cpow_def","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x y : Complex\n⊢ Eq (HPow.hPow x y) (ite (Eq x 0) (ite (Eq y 0) 1 0) (Complex.exp (HMul.hMul (Complex.log x) y)))","decl":"theorem cpow_def (x y : ℂ) : x ^ y = if x = 0 then if y = 0 then 1 else 0 else exp (log x * y) :=\n  rfl\n\n"}
{"name":"Complex.cpow_def_of_ne_zero","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x : Complex\nhx : Ne x 0\ny : Complex\n⊢ Eq (HPow.hPow x y) (Complex.exp (HMul.hMul (Complex.log x) y))","decl":"theorem cpow_def_of_ne_zero {x : ℂ} (hx : x ≠ 0) (y : ℂ) : x ^ y = exp (log x * y) :=\n  if_neg hx\n\n"}
{"name":"Complex.cpow_zero","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x : Complex\n⊢ Eq (HPow.hPow x 0) 1","decl":"@[simp]\ntheorem cpow_zero (x : ℂ) : x ^ (0 : ℂ) = 1 := by simp [cpow_def]\n\n"}
{"name":"Complex.cpow_eq_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x y : Complex\n⊢ Iff (Eq (HPow.hPow x y) 0) (And (Eq x 0) (Ne y 0))","decl":"@[simp]\ntheorem cpow_eq_zero_iff (x y : ℂ) : x ^ y = 0 ↔ x = 0 ∧ y ≠ 0 := by\n  simp only [cpow_def]\n  split_ifs <;> simp [*, exp_ne_zero]\n\n"}
{"name":"Complex.cpow_ne_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x y : Complex\n⊢ Iff (Ne (HPow.hPow x y) 0) (Or (Ne x 0) (Eq y 0))","decl":"theorem cpow_ne_zero_iff {x y : ℂ} :\n    x ^ y ≠ 0 ↔ x ≠ 0 ∨ y = 0 := by\n  rw [ne_eq, cpow_eq_zero_iff, not_and_or, ne_eq, not_not]\n\n"}
{"name":"Complex.cpow_ne_zero_iff_of_exponent_ne_zero","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x y : Complex\nhy : Ne y 0\n⊢ Iff (Ne (HPow.hPow x y) 0) (Ne x 0)","decl":"theorem cpow_ne_zero_iff_of_exponent_ne_zero {x y : ℂ} (hy : y ≠ 0) :\n    x ^ y ≠ 0 ↔ x ≠ 0 := by simp [hy]\n\n"}
{"name":"Complex.zero_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x : Complex\nh : Ne x 0\n⊢ Eq (HPow.hPow 0 x) 0","decl":"@[simp]\ntheorem zero_cpow {x : ℂ} (h : x ≠ 0) : (0 : ℂ) ^ x = 0 := by simp [cpow_def, *]\n\n"}
{"name":"Complex.zero_cpow_eq_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x a : Complex\n⊢ Iff (Eq (HPow.hPow 0 x) a) (Or (And (Ne x 0) (Eq a 0)) (And (Eq x 0) (Eq a 1)))","decl":"theorem zero_cpow_eq_iff {x : ℂ} {a : ℂ} : (0 : ℂ) ^ x = a ↔ x ≠ 0 ∧ a = 0 ∨ x = 0 ∧ a = 1 := by\n  constructor\n  · intro hyp\n    simp only [cpow_def, eq_self_iff_true, if_true] at hyp\n    by_cases h : x = 0\n    · subst h\n      simp only [if_true, eq_self_iff_true] at hyp\n      right\n      exact ⟨rfl, hyp.symm⟩\n    · rw [if_neg h] at hyp\n      left\n      exact ⟨h, hyp.symm⟩\n  · rintro (⟨h, rfl⟩ | ⟨rfl, rfl⟩)\n    · exact zero_cpow h\n    · exact cpow_zero _\n\n"}
{"name":"Complex.eq_zero_cpow_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x a : Complex\n⊢ Iff (Eq a (HPow.hPow 0 x)) (Or (And (Ne x 0) (Eq a 0)) (And (Eq x 0) (Eq a 1)))","decl":"theorem eq_zero_cpow_iff {x : ℂ} {a : ℂ} : a = (0 : ℂ) ^ x ↔ x ≠ 0 ∧ a = 0 ∨ x = 0 ∧ a = 1 := by\n  rw [← zero_cpow_eq_iff, eq_comm]\n\n"}
{"name":"Complex.cpow_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x : Complex\n⊢ Eq (HPow.hPow x 1) x","decl":"@[simp]\ntheorem cpow_one (x : ℂ) : x ^ (1 : ℂ) = x :=\n  if hx : x = 0 then by simp [hx, cpow_def]\n  else by rw [cpow_def, if_neg (one_ne_zero : (1 : ℂ) ≠ 0), if_neg hx, mul_one, exp_log hx]\n\n"}
{"name":"Complex.one_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x : Complex\n⊢ Eq (HPow.hPow 1 x) 1","decl":"@[simp]\ntheorem one_cpow (x : ℂ) : (1 : ℂ) ^ x = 1 := by\n  rw [cpow_def]\n  split_ifs <;> simp_all [one_ne_zero]\n\n"}
{"name":"Complex.cpow_add","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x y z : Complex\nhx : Ne x 0\n⊢ Eq (HPow.hPow x (HAdd.hAdd y z)) (HMul.hMul (HPow.hPow x y) (HPow.hPow x z))","decl":"theorem cpow_add {x : ℂ} (y z : ℂ) (hx : x ≠ 0) : x ^ (y + z) = x ^ y * x ^ z := by\n  simp only [cpow_def, ite_mul, boole_mul, mul_ite, mul_boole]\n  simp_all [exp_add, mul_add]\n\n"}
{"name":"Complex.cpow_mul","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x y z : Complex\nh₁ : LT.lt (Neg.neg Real.pi) (HMul.hMul (Complex.log x) y).im\nh₂ : LE.le (HMul.hMul (Complex.log x) y).im Real.pi\n⊢ Eq (HPow.hPow x (HMul.hMul y z)) (HPow.hPow (HPow.hPow x y) z)","decl":"theorem cpow_mul {x y : ℂ} (z : ℂ) (h₁ : -π < (log x * y).im) (h₂ : (log x * y).im ≤ π) :\n    x ^ (y * z) = (x ^ y) ^ z := by\n  simp only [cpow_def]\n  split_ifs <;> simp_all [exp_ne_zero, log_exp h₁ h₂, mul_assoc]\n\n"}
{"name":"Complex.cpow_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x y : Complex\n⊢ Eq (HPow.hPow x (Neg.neg y)) (Inv.inv (HPow.hPow x y))","decl":"theorem cpow_neg (x y : ℂ) : x ^ (-y) = (x ^ y)⁻¹ := by\n  simp only [cpow_def, neg_eq_zero, mul_neg]\n  split_ifs <;> simp [exp_neg]\n\n"}
{"name":"Complex.cpow_sub","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x y z : Complex\nhx : Ne x 0\n⊢ Eq (HPow.hPow x (HSub.hSub y z)) (HDiv.hDiv (HPow.hPow x y) (HPow.hPow x z))","decl":"theorem cpow_sub {x : ℂ} (y z : ℂ) (hx : x ≠ 0) : x ^ (y - z) = x ^ y / x ^ z := by\n  rw [sub_eq_add_neg, cpow_add _ _ hx, cpow_neg, div_eq_mul_inv]\n\n"}
{"name":"Complex.cpow_neg_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x : Complex\n⊢ Eq (HPow.hPow x (-1)) (Inv.inv x)","decl":"theorem cpow_neg_one (x : ℂ) : x ^ (-1 : ℂ) = x⁻¹ := by simpa using cpow_neg x 1\n\n"}
{"name":"Complex.cpow_int_mul","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x : Complex\nn : Int\ny : Complex\n⊢ Eq (HPow.hPow x (HMul.hMul (↑n) y)) (HPow.hPow (HPow.hPow x y) n)","decl":"/-- See also `Complex.cpow_int_mul'`. -/\nlemma cpow_int_mul (x : ℂ) (n : ℤ) (y : ℂ) : x ^ (n * y) = (x ^ y) ^ n := by\n  rcases eq_or_ne x 0 with rfl | hx\n  · rcases eq_or_ne n 0 with rfl | hn\n    · simp\n    · rcases eq_or_ne y 0 with rfl | hy <;> simp [*, zero_zpow]\n  · rw [cpow_def_of_ne_zero hx, cpow_def_of_ne_zero hx, mul_left_comm, exp_int_mul]\n\n"}
{"name":"Complex.cpow_mul_int","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x y : Complex\nn : Int\n⊢ Eq (HPow.hPow x (HMul.hMul y ↑n)) (HPow.hPow (HPow.hPow x y) n)","decl":"lemma cpow_mul_int (x y : ℂ) (n : ℤ) : x ^ (y * n) = (x ^ y) ^ n := by rw [mul_comm, cpow_int_mul]\n\n"}
{"name":"Complex.cpow_nat_mul","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x : Complex\nn : Nat\ny : Complex\n⊢ Eq (HPow.hPow x (HMul.hMul (↑n) y)) (HPow.hPow (HPow.hPow x y) n)","decl":"lemma cpow_nat_mul (x : ℂ) (n : ℕ) (y : ℂ) : x ^ (n * y) = (x ^ y) ^ n :=\n  mod_cast cpow_int_mul x n y\n\n"}
{"name":"Complex.cpow_ofNat_mul","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x : Complex\nn : Nat\ninst✝ : n.AtLeastTwo\ny : Complex\n⊢ Eq (HPow.hPow x (HMul.hMul (OfNat.ofNat n) y)) (HPow.hPow (HPow.hPow x y) (OfNat.ofNat n))","decl":"lemma cpow_ofNat_mul (x : ℂ) (n : ℕ) [n.AtLeastTwo] (y : ℂ) :\n    x ^ (ofNat(n) * y) = (x ^ y) ^ ofNat(n) :=\n  cpow_nat_mul x n y\n\n"}
{"name":"Complex.cpow_mul_nat","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x y : Complex\nn : Nat\n⊢ Eq (HPow.hPow x (HMul.hMul y ↑n)) (HPow.hPow (HPow.hPow x y) n)","decl":"lemma cpow_mul_nat (x y : ℂ) (n : ℕ) : x ^ (y * n) = (x ^ y) ^ n := by\n  rw [mul_comm, cpow_nat_mul]\n\n"}
{"name":"Complex.cpow_mul_ofNat","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x y : Complex\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (HPow.hPow x (HMul.hMul y (OfNat.ofNat n))) (HPow.hPow (HPow.hPow x y) (OfNat.ofNat n))","decl":"lemma cpow_mul_ofNat (x y : ℂ) (n : ℕ) [n.AtLeastTwo] :\n    x ^ (y * ofNat(n)) = (x ^ y) ^ ofNat(n) :=\n  cpow_mul_nat x y n\n\n"}
{"name":"Complex.cpow_natCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x : Complex\nn : Nat\n⊢ Eq (HPow.hPow x ↑n) (HPow.hPow x n)","decl":"@[simp, norm_cast]\ntheorem cpow_natCast (x : ℂ) (n : ℕ) : x ^ (n : ℂ) = x ^ n := by simpa using cpow_nat_mul x n 1\n\n"}
{"name":"Complex.cpow_ofNat","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x : Complex\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (HPow.hPow x (OfNat.ofNat n)) (HPow.hPow x (OfNat.ofNat n))","decl":"@[simp]\nlemma cpow_ofNat (x : ℂ) (n : ℕ) [n.AtLeastTwo] :\n    x ^ (ofNat(n) : ℂ) = x ^ ofNat(n) :=\n  cpow_natCast x n\n\n"}
{"name":"Complex.cpow_two","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x : Complex\n⊢ Eq (HPow.hPow x 2) (HPow.hPow x 2)","decl":"theorem cpow_two (x : ℂ) : x ^ (2 : ℂ) = x ^ (2 : ℕ) := cpow_ofNat x 2\n\n"}
{"name":"Complex.cpow_intCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x : Complex\nn : Int\n⊢ Eq (HPow.hPow x ↑n) (HPow.hPow x n)","decl":"@[simp, norm_cast]\ntheorem cpow_intCast (x : ℂ) (n : ℤ) : x ^ (n : ℂ) = x ^ n := by simpa using cpow_int_mul x n 1\n\n"}
{"name":"Complex.cpow_nat_inv_pow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x : Complex\nn : Nat\nhn : Ne n 0\n⊢ Eq (HPow.hPow (HPow.hPow x (Inv.inv ↑n)) n) x","decl":"@[simp]\ntheorem cpow_nat_inv_pow (x : ℂ) {n : ℕ} (hn : n ≠ 0) : (x ^ (n⁻¹ : ℂ)) ^ n = x := by\n  rw [← cpow_nat_mul, mul_inv_cancel₀, cpow_one]\n  assumption_mod_cast\n\n"}
{"name":"Complex.cpow_ofNat_inv_pow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x : Complex\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (HPow.hPow (HPow.hPow x (Inv.inv (OfNat.ofNat n))) (OfNat.ofNat n)) x","decl":"@[simp]\nlemma cpow_ofNat_inv_pow (x : ℂ) (n : ℕ) [n.AtLeastTwo] :\n    (x ^ ((ofNat(n) : ℂ)⁻¹)) ^ (ofNat(n) : ℕ) = x :=\n  cpow_nat_inv_pow _ (NeZero.ne n)\n\n"}
{"name":"Complex.cpow_int_mul'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x : Complex\nn : Int\nhlt : LT.lt (Neg.neg Real.pi) (HMul.hMul (↑n) x.arg)\nhle : LE.le (HMul.hMul (↑n) x.arg) Real.pi\ny : Complex\n⊢ Eq (HPow.hPow x (HMul.hMul (↑n) y)) (HPow.hPow (HPow.hPow x n) y)","decl":"/-- A version of `Complex.cpow_int_mul` with RHS that matches `Complex.cpow_mul`.\n\nThe assumptions on the arguments are needed\nbecause the equality fails, e.g., for `x = -I`, `n = 2`, `y = 1/2`. -/\nlemma cpow_int_mul' {x : ℂ} {n : ℤ} (hlt : -π < n * x.arg) (hle : n * x.arg ≤ π) (y : ℂ) :\n    x ^ (n * y) = (x ^ n) ^ y := by\n  rw [mul_comm] at hlt hle\n  rw [cpow_mul, cpow_intCast] <;> simpa [log_im]\n\n"}
{"name":"Complex.cpow_nat_mul'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x : Complex\nn : Nat\nhlt : LT.lt (Neg.neg Real.pi) (HMul.hMul (↑n) x.arg)\nhle : LE.le (HMul.hMul (↑n) x.arg) Real.pi\ny : Complex\n⊢ Eq (HPow.hPow x (HMul.hMul (↑n) y)) (HPow.hPow (HPow.hPow x n) y)","decl":"/-- A version of `Complex.cpow_nat_mul` with RHS that matches `Complex.cpow_mul`.\n\nThe assumptions on the arguments are needed\nbecause the equality fails, e.g., for `x = -I`, `n = 2`, `y = 1/2`. -/\nlemma cpow_nat_mul' {x : ℂ} {n : ℕ} (hlt : -π < n * x.arg) (hle : n * x.arg ≤ π) (y : ℂ) :\n    x ^ (n * y) = (x ^ n) ^ y :=\n  cpow_int_mul' hlt hle y\n\n"}
{"name":"Complex.cpow_ofNat_mul'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x : Complex\nn : Nat\ninst✝ : n.AtLeastTwo\nhlt : LT.lt (Neg.neg Real.pi) (HMul.hMul (OfNat.ofNat n) x.arg)\nhle : LE.le (HMul.hMul (OfNat.ofNat n) x.arg) Real.pi\ny : Complex\n⊢ Eq (HPow.hPow x (HMul.hMul (OfNat.ofNat n) y)) (HPow.hPow (HPow.hPow x (OfNat.ofNat n)) y)","decl":"lemma cpow_ofNat_mul' {x : ℂ} {n : ℕ} [n.AtLeastTwo] (hlt : -π < OfNat.ofNat n * x.arg)\n    (hle : OfNat.ofNat n * x.arg ≤ π) (y : ℂ) :\n    x ^ (OfNat.ofNat n * y) = (x ^ ofNat(n)) ^ y :=\n  cpow_nat_mul' hlt hle y\n\n"}
{"name":"Complex.pow_cpow_nat_inv","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x : Complex\nn : Nat\nh₀ : Ne n 0\nhlt : LT.lt (Neg.neg (HDiv.hDiv Real.pi ↑n)) x.arg\nhle : LE.le x.arg (HDiv.hDiv Real.pi ↑n)\n⊢ Eq (HPow.hPow (HPow.hPow x n) (Inv.inv ↑n)) x","decl":"lemma pow_cpow_nat_inv {x : ℂ} {n : ℕ} (h₀ : n ≠ 0) (hlt : -(π / n) < x.arg) (hle : x.arg ≤ π / n) :\n    (x ^ n) ^ (n⁻¹ : ℂ) = x := by\n  rw [← cpow_nat_mul', mul_inv_cancel₀ (Nat.cast_ne_zero.2 h₀), cpow_one]\n  · rwa [← div_lt_iff₀' (Nat.cast_pos.2 h₀.bot_lt), neg_div]\n  · rwa [← le_div_iff₀' (Nat.cast_pos.2 h₀.bot_lt)]\n\n"}
{"name":"Complex.pow_cpow_ofNat_inv","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x : Complex\nn : Nat\ninst✝ : n.AtLeastTwo\nhlt : LT.lt (Neg.neg (HDiv.hDiv Real.pi (OfNat.ofNat n))) x.arg\nhle : LE.le x.arg (HDiv.hDiv Real.pi (OfNat.ofNat n))\n⊢ Eq (HPow.hPow (HPow.hPow x (OfNat.ofNat n)) (Inv.inv (OfNat.ofNat n))) x","decl":"lemma pow_cpow_ofNat_inv {x : ℂ} {n : ℕ} [n.AtLeastTwo] (hlt : -(π / OfNat.ofNat n) < x.arg)\n    (hle : x.arg ≤ π / OfNat.ofNat n) :\n    (x ^ ofNat(n)) ^ ((OfNat.ofNat n : ℂ)⁻¹) = x :=\n  pow_cpow_nat_inv (NeZero.ne n) hlt hle\n\n"}
{"name":"Complex.sq_cpow_two_inv","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x : Complex\nhx : LT.lt 0 x.re\n⊢ Eq (HPow.hPow (HPow.hPow x 2) (Inv.inv 2)) x","decl":"/-- See also `Complex.pow_cpow_ofNat_inv` for a version that also works for `x * I`, `0 ≤ x`. -/\nlemma sq_cpow_two_inv {x : ℂ} (hx : 0 < x.re) : (x ^ (2 : ℕ)) ^ (2⁻¹ : ℂ) = x :=\n  pow_cpow_ofNat_inv (neg_pi_div_two_lt_arg_iff.2 <| .inl hx)\n    (arg_le_pi_div_two_iff.2 <| .inl hx.le)\n\n"}
{"name":"Complex.mul_cpow_ofReal_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"a b : Real\nha : LE.le 0 a\nhb : LE.le 0 b\nr : Complex\n⊢ Eq (HPow.hPow (HMul.hMul ↑a ↑b) r) (HMul.hMul (HPow.hPow (↑a) r) (HPow.hPow (↑b) r))","decl":"theorem mul_cpow_ofReal_nonneg {a b : ℝ} (ha : 0 ≤ a) (hb : 0 ≤ b) (r : ℂ) :\n    ((a : ℂ) * (b : ℂ)) ^ r = (a : ℂ) ^ r * (b : ℂ) ^ r := by\n  rcases eq_or_ne r 0 with (rfl | hr)\n  · simp only [cpow_zero, mul_one]\n  rcases eq_or_lt_of_le ha with (rfl | ha')\n  · rw [ofReal_zero, zero_mul, zero_cpow hr, zero_mul]\n  rcases eq_or_lt_of_le hb with (rfl | hb')\n  · rw [ofReal_zero, mul_zero, zero_cpow hr, mul_zero]\n  have ha'' : (a : ℂ) ≠ 0 := ofReal_ne_zero.mpr ha'.ne'\n  have hb'' : (b : ℂ) ≠ 0 := ofReal_ne_zero.mpr hb'.ne'\n  rw [cpow_def_of_ne_zero (mul_ne_zero ha'' hb''), log_ofReal_mul ha' hb'', ofReal_log ha,\n    add_mul, exp_add, ← cpow_def_of_ne_zero ha'', ← cpow_def_of_ne_zero hb'']\n\n"}
{"name":"Complex.natCast_mul_natCast_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"m n : Nat\ns : Complex\n⊢ Eq (HPow.hPow (HMul.hMul ↑m ↑n) s) (HMul.hMul (HPow.hPow (↑m) s) (HPow.hPow (↑n) s))","decl":"lemma natCast_mul_natCast_cpow (m n : ℕ) (s : ℂ) : (m * n : ℂ) ^ s = m ^ s * n ^ s :=\n  ofReal_natCast m ▸ ofReal_natCast n ▸ mul_cpow_ofReal_nonneg m.cast_nonneg n.cast_nonneg s\n\n"}
{"name":"Complex.natCast_cpow_natCast_mul","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"n m : Nat\nz : Complex\n⊢ Eq (HPow.hPow (↑n) (HMul.hMul (↑m) z)) (HPow.hPow (HPow.hPow (↑n) m) z)","decl":"lemma natCast_cpow_natCast_mul (n m : ℕ) (z : ℂ) : (n : ℂ) ^ (m * z) = ((n : ℂ) ^ m) ^ z := by\n  refine cpow_nat_mul' (x := n) (n := m) ?_ ?_ z\n  · simp only [natCast_arg, mul_zero, Left.neg_neg_iff, pi_pos]\n  · simp only [natCast_arg, mul_zero, pi_pos.le]\n\n"}
{"name":"Complex.inv_cpow_eq_ite","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x n : Complex\n⊢ Eq (HPow.hPow (Inv.inv x) n) (ite (Eq x.arg Real.pi) ((starRingEnd Complex) (Inv.inv (HPow.hPow x ((starRingEnd Complex) n)))) (Inv.inv (HPow.hPow x n)))","decl":"theorem inv_cpow_eq_ite (x : ℂ) (n : ℂ) :\n    x⁻¹ ^ n = if x.arg = π then conj (x ^ conj n)⁻¹ else (x ^ n)⁻¹ := by\n  simp_rw [Complex.cpow_def, log_inv_eq_ite, inv_eq_zero, map_eq_zero, ite_mul, neg_mul,\n    RCLike.conj_inv, apply_ite conj, apply_ite exp, apply_ite Inv.inv, map_zero, map_one, exp_neg,\n    inv_one, inv_zero, ← exp_conj, map_mul, conj_conj]\n  split_ifs with hx hn ha ha <;> rfl\n\n"}
{"name":"Complex.inv_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x n : Complex\nhx : Ne x.arg Real.pi\n⊢ Eq (HPow.hPow (Inv.inv x) n) (Inv.inv (HPow.hPow x n))","decl":"theorem inv_cpow (x : ℂ) (n : ℂ) (hx : x.arg ≠ π) : x⁻¹ ^ n = (x ^ n)⁻¹ := by\n  rw [inv_cpow_eq_ite, if_neg hx]\n\n"}
{"name":"Complex.inv_cpow_eq_ite'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x n : Complex\n⊢ Eq (Inv.inv (HPow.hPow x n)) (ite (Eq x.arg Real.pi) ((starRingEnd Complex) (HPow.hPow (Inv.inv x) ((starRingEnd Complex) n))) (HPow.hPow (Inv.inv x) n))","decl":"/-- `Complex.inv_cpow_eq_ite` with the `ite` on the other side. -/\ntheorem inv_cpow_eq_ite' (x : ℂ) (n : ℂ) :\n    (x ^ n)⁻¹ = if x.arg = π then conj (x⁻¹ ^ conj n) else x⁻¹ ^ n := by\n  rw [inv_cpow_eq_ite, apply_ite conj, conj_conj, conj_conj]\n  split_ifs with h\n  · rfl\n  · rw [inv_cpow _ _ h]\n\n"}
{"name":"Complex.conj_cpow_eq_ite","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x n : Complex\n⊢ Eq (HPow.hPow ((starRingEnd Complex) x) n) (ite (Eq x.arg Real.pi) (HPow.hPow x n) ((starRingEnd Complex) (HPow.hPow x ((starRingEnd Complex) n))))","decl":"theorem conj_cpow_eq_ite (x : ℂ) (n : ℂ) :\n    conj x ^ n = if x.arg = π then x ^ n else conj (x ^ conj n) := by\n  simp_rw [cpow_def, map_eq_zero, apply_ite conj, map_one, map_zero, ← exp_conj, map_mul, conj_conj,\n    log_conj_eq_ite]\n  split_ifs with hcx hn hx <;> rfl\n\n"}
{"name":"Complex.conj_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x n : Complex\nhx : Ne x.arg Real.pi\n⊢ Eq (HPow.hPow ((starRingEnd Complex) x) n) ((starRingEnd Complex) (HPow.hPow x ((starRingEnd Complex) n)))","decl":"theorem conj_cpow (x : ℂ) (n : ℂ) (hx : x.arg ≠ π) : conj x ^ n = conj (x ^ conj n) := by\n  rw [conj_cpow_eq_ite, if_neg hx]\n\n"}
{"name":"Complex.cpow_conj","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"x n : Complex\nhx : Ne x.arg Real.pi\n⊢ Eq (HPow.hPow x ((starRingEnd Complex) n)) ((starRingEnd Complex) (HPow.hPow ((starRingEnd Complex) x) n))","decl":"theorem cpow_conj (x : ℂ) (n : ℂ) (hx : x.arg ≠ π) : x ^ conj n = conj (conj x ^ n) := by\n  rw [conj_cpow _ _ hx, conj_conj]\n\n"}
{"name":"Complex.natCast_add_one_cpow_ne_zero","module":"Mathlib.Analysis.SpecialFunctions.Pow.Complex","initialProofState":"n : Nat\nz : Complex\n⊢ Ne (HPow.hPow (HAdd.hAdd (↑n) 1) z) 0","decl":"lemma natCast_add_one_cpow_ne_zero (n : ℕ) (z : ℂ) : (n + 1 : ℂ) ^ z ≠ 0 :=\n  mt (cpow_eq_zero_iff ..).mp fun H ↦ by norm_cast at H; exact H.1\n\n"}
