{"name":"IsBoundedBilinearMap.hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nb : Prod E F → G\nh : IsBoundedBilinearMap 𝕜 b\np : Prod E F\n⊢ HasStrictFDerivAt b (h.deriv p) p","decl":"@[fun_prop]\ntheorem IsBoundedBilinearMap.hasStrictFDerivAt (h : IsBoundedBilinearMap 𝕜 b) (p : E × F) :\n    HasStrictFDerivAt b (h.deriv p) p := by\n  simp only [hasStrictFDerivAt_iff_isLittleO]\n  simp only [← map_add_left_nhds_zero (p, p), isLittleO_map]\n  set T := (E × F) × E × F\n  calc\n    _ = fun x ↦ h.deriv (x.1 - x.2) (x.2.1, x.1.2) := by\n      ext ⟨⟨x₁, y₁⟩, ⟨x₂, y₂⟩⟩\n      rcases p with ⟨x, y⟩\n      simp only [map_sub, deriv_apply, Function.comp_apply, Prod.mk_add_mk, h.add_right, h.add_left,\n        Prod.mk_sub_mk, h.map_sub_left, h.map_sub_right, sub_add_sub_cancel]\n      abel\n    -- _ =O[𝓝 (0 : T)] fun x ↦ ‖x.1 - x.2‖ * ‖(x.2.1, x.1.2)‖ :=\n    --     h.toContinuousLinearMap.deriv₂.isBoundedBilinearMap.isBigO_comp\n    -- _ = o[𝓝 0] fun x ↦ ‖x.1 - x.2‖ * 1 := _\n    _ =o[𝓝 (0 : T)] fun x ↦ x.1 - x.2 := by\n      -- TODO : add 2 `calc` steps instead of the next 3 lines\n      refine h.toContinuousLinearMap.deriv₂.isBoundedBilinearMap.isBigO_comp.trans_isLittleO ?_\n      suffices (fun x : T ↦ ‖x.1 - x.2‖ * ‖(x.2.1, x.1.2)‖) =o[𝓝 0] fun x ↦ ‖x.1 - x.2‖ * 1 by\n        simpa only [mul_one, isLittleO_norm_right] using this\n      refine (isBigO_refl _ _).mul_isLittleO ((isLittleO_one_iff _).2 ?_)\n      -- TODO: `continuity` fails\n      exact (continuous_snd.fst.prod_mk continuous_fst.snd).norm.tendsto' _ _ (by simp)\n    _ = _ := by simp [T, Function.comp_def]\n\n"}
{"name":"IsBoundedBilinearMap.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nb : Prod E F → G\nh : IsBoundedBilinearMap 𝕜 b\np : Prod E F\n⊢ HasFDerivAt b (h.deriv p) p","decl":"@[fun_prop]\ntheorem IsBoundedBilinearMap.hasFDerivAt (h : IsBoundedBilinearMap 𝕜 b) (p : E × F) :\n    HasFDerivAt b (h.deriv p) p :=\n  (h.hasStrictFDerivAt p).hasFDerivAt\n\n"}
{"name":"IsBoundedBilinearMap.hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nb : Prod E F → G\nu : Set (Prod E F)\nh : IsBoundedBilinearMap 𝕜 b\np : Prod E F\n⊢ HasFDerivWithinAt b (h.deriv p) u p","decl":"@[fun_prop]\ntheorem IsBoundedBilinearMap.hasFDerivWithinAt (h : IsBoundedBilinearMap 𝕜 b) (p : E × F) :\n    HasFDerivWithinAt b (h.deriv p) u p :=\n  (h.hasFDerivAt p).hasFDerivWithinAt\n\n"}
{"name":"IsBoundedBilinearMap.differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nb : Prod E F → G\nh : IsBoundedBilinearMap 𝕜 b\np : Prod E F\n⊢ DifferentiableAt 𝕜 b p","decl":"@[fun_prop]\ntheorem IsBoundedBilinearMap.differentiableAt (h : IsBoundedBilinearMap 𝕜 b) (p : E × F) :\n    DifferentiableAt 𝕜 b p :=\n  (h.hasFDerivAt p).differentiableAt\n\n"}
{"name":"IsBoundedBilinearMap.differentiableWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nb : Prod E F → G\nu : Set (Prod E F)\nh : IsBoundedBilinearMap 𝕜 b\np : Prod E F\n⊢ DifferentiableWithinAt 𝕜 b u p","decl":"@[fun_prop]\ntheorem IsBoundedBilinearMap.differentiableWithinAt (h : IsBoundedBilinearMap 𝕜 b) (p : E × F) :\n    DifferentiableWithinAt 𝕜 b u p :=\n  (h.differentiableAt p).differentiableWithinAt\n\n"}
{"name":"IsBoundedBilinearMap.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nb : Prod E F → G\nh : IsBoundedBilinearMap 𝕜 b\np : Prod E F\n⊢ Eq (fderiv 𝕜 b p) (h.deriv p)","decl":"protected theorem IsBoundedBilinearMap.fderiv (h : IsBoundedBilinearMap 𝕜 b) (p : E × F) :\n    fderiv 𝕜 b p = h.deriv p :=\n  HasFDerivAt.fderiv (h.hasFDerivAt p)\n\n"}
{"name":"IsBoundedBilinearMap.fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nb : Prod E F → G\nu : Set (Prod E F)\nh : IsBoundedBilinearMap 𝕜 b\np : Prod E F\nhxs : UniqueDiffWithinAt 𝕜 u p\n⊢ Eq (fderivWithin 𝕜 b u p) (h.deriv p)","decl":"protected theorem IsBoundedBilinearMap.fderivWithin (h : IsBoundedBilinearMap 𝕜 b) (p : E × F)\n    (hxs : UniqueDiffWithinAt 𝕜 u p) : fderivWithin 𝕜 b u p = h.deriv p := by\n  rw [DifferentiableAt.fderivWithin (h.differentiableAt p) hxs]\n  exact h.fderiv p\n\n"}
{"name":"IsBoundedBilinearMap.differentiable","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nb : Prod E F → G\nh : IsBoundedBilinearMap 𝕜 b\n⊢ Differentiable 𝕜 b","decl":"@[fun_prop]\ntheorem IsBoundedBilinearMap.differentiable (h : IsBoundedBilinearMap 𝕜 b) : Differentiable 𝕜 b :=\n  fun x => h.differentiableAt x\n\n"}
{"name":"IsBoundedBilinearMap.differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nb : Prod E F → G\nu : Set (Prod E F)\nh : IsBoundedBilinearMap 𝕜 b\n⊢ DifferentiableOn 𝕜 b u","decl":"@[fun_prop]\ntheorem IsBoundedBilinearMap.differentiableOn (h : IsBoundedBilinearMap 𝕜 b) :\n    DifferentiableOn 𝕜 b u :=\n  h.differentiable.differentiableOn\n\n"}
{"name":"ContinuousLinearMap.hasFDerivWithinAt_of_bilinear","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nG' : Type u_5\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nB : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F G)\nf : G' → E\ng : G' → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) G' E\ng' : ContinuousLinearMap (RingHom.id 𝕜) G' F\nx : G'\ns : Set G'\nhf : HasFDerivWithinAt f f' s x\nhg : HasFDerivWithinAt g g' s x\n⊢ HasFDerivWithinAt (fun y => (B (f y)) (g y)) (HAdd.hAdd (((ContinuousLinearMap.precompR G' B) (f x)) g') (((ContinuousLinearMap.precompL G' B) f') (g x))) s x","decl":"@[fun_prop]\ntheorem ContinuousLinearMap.hasFDerivWithinAt_of_bilinear {f : G' → E} {g : G' → F}\n    {f' : G' →L[𝕜] E} {g' : G' →L[𝕜] F} {x : G'} {s : Set G'} (hf : HasFDerivWithinAt f f' s x)\n    (hg : HasFDerivWithinAt g g' s x) :\n    HasFDerivWithinAt (fun y => B (f y) (g y))\n      (B.precompR G' (f x) g' + B.precompL G' f' (g x)) s x := by\n  exact (B.isBoundedBilinearMap.hasFDerivAt (f x, g x)).comp_hasFDerivWithinAt x (hf.prod hg)\n\n"}
{"name":"ContinuousLinearMap.hasFDerivAt_of_bilinear","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nG' : Type u_5\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nB : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F G)\nf : G' → E\ng : G' → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) G' E\ng' : ContinuousLinearMap (RingHom.id 𝕜) G' F\nx : G'\nhf : HasFDerivAt f f' x\nhg : HasFDerivAt g g' x\n⊢ HasFDerivAt (fun y => (B (f y)) (g y)) (HAdd.hAdd (((ContinuousLinearMap.precompR G' B) (f x)) g') (((ContinuousLinearMap.precompL G' B) f') (g x))) x","decl":"@[fun_prop]\ntheorem ContinuousLinearMap.hasFDerivAt_of_bilinear {f : G' → E} {g : G' → F} {f' : G' →L[𝕜] E}\n    {g' : G' →L[𝕜] F} {x : G'} (hf : HasFDerivAt f f' x) (hg : HasFDerivAt g g' x) :\n    HasFDerivAt (fun y => B (f y) (g y)) (B.precompR G' (f x) g' + B.precompL G' f' (g x)) x := by\n  exact (B.isBoundedBilinearMap.hasFDerivAt (f x, g x)).comp x (hf.prod hg)\n\n"}
{"name":"ContinuousLinearMap.hasStrictFDerivAt_of_bilinear","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nG' : Type u_5\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nB : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F G)\nf : G' → E\ng : G' → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) G' E\ng' : ContinuousLinearMap (RingHom.id 𝕜) G' F\nx : G'\nhf : HasStrictFDerivAt f f' x\nhg : HasStrictFDerivAt g g' x\n⊢ HasStrictFDerivAt (fun y => (B (f y)) (g y)) (HAdd.hAdd (((ContinuousLinearMap.precompR G' B) (f x)) g') (((ContinuousLinearMap.precompL G' B) f') (g x))) x","decl":"@[fun_prop]\ntheorem ContinuousLinearMap.hasStrictFDerivAt_of_bilinear\n    {f : G' → E} {g : G' → F} {f' : G' →L[𝕜] E}\n    {g' : G' →L[𝕜] F} {x : G'} (hf : HasStrictFDerivAt f f' x) (hg : HasStrictFDerivAt g g' x) :\n    HasStrictFDerivAt (fun y => B (f y) (g y))\n      (B.precompR G' (f x) g' + B.precompL G' f' (g x)) x :=\n  (B.isBoundedBilinearMap.hasStrictFDerivAt (f x, g x)).comp x (hf.prod hg)\n\n"}
{"name":"ContinuousLinearMap.fderivWithin_of_bilinear","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nG' : Type u_5\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nB : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F G)\nf : G' → E\ng : G' → F\nx : G'\ns : Set G'\nhf : DifferentiableWithinAt 𝕜 f s x\nhg : DifferentiableWithinAt 𝕜 g s x\nhs : UniqueDiffWithinAt 𝕜 s x\n⊢ Eq (fderivWithin 𝕜 (fun y => (B (f y)) (g y)) s x) (HAdd.hAdd (((ContinuousLinearMap.precompR G' B) (f x)) (fderivWithin 𝕜 g s x)) (((ContinuousLinearMap.precompL G' B) (fderivWithin 𝕜 f s x)) (g x)))","decl":"theorem ContinuousLinearMap.fderivWithin_of_bilinear {f : G' → E} {g : G' → F} {x : G'} {s : Set G'}\n    (hf : DifferentiableWithinAt 𝕜 f s x) (hg : DifferentiableWithinAt 𝕜 g s x)\n    (hs : UniqueDiffWithinAt 𝕜 s x) :\n    fderivWithin 𝕜 (fun y => B (f y) (g y)) s x =\n      B.precompR G' (f x) (fderivWithin 𝕜 g s x) + B.precompL G' (fderivWithin 𝕜 f s x) (g x) :=\n  (B.hasFDerivWithinAt_of_bilinear hf.hasFDerivWithinAt hg.hasFDerivWithinAt).fderivWithin hs\n\n"}
{"name":"ContinuousLinearMap.fderiv_of_bilinear","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nG' : Type u_5\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nB : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F G)\nf : G' → E\ng : G' → F\nx : G'\nhf : DifferentiableAt 𝕜 f x\nhg : DifferentiableAt 𝕜 g x\n⊢ Eq (fderiv 𝕜 (fun y => (B (f y)) (g y)) x) (HAdd.hAdd (((ContinuousLinearMap.precompR G' B) (f x)) (fderiv 𝕜 g x)) (((ContinuousLinearMap.precompL G' B) (fderiv 𝕜 f x)) (g x)))","decl":"theorem ContinuousLinearMap.fderiv_of_bilinear {f : G' → E} {g : G' → F} {x : G'}\n    (hf : DifferentiableAt 𝕜 f x) (hg : DifferentiableAt 𝕜 g x) :\n    fderiv 𝕜 (fun y => B (f y) (g y)) x =\n      B.precompR G' (f x) (fderiv 𝕜 g x) + B.precompL G' (fderiv 𝕜 f x) (g x) :=\n  (B.hasFDerivAt_of_bilinear hf.hasFDerivAt hg.hasFDerivAt).fderiv\n\n"}
