{"name":"IsBoundedBilinearMap.hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nb : Prod E F â†’ G\nh : IsBoundedBilinearMap ğ•œ b\np : Prod E F\nâŠ¢ HasStrictFDerivAt b (h.deriv p) p","decl":"@[fun_prop]\ntheorem IsBoundedBilinearMap.hasStrictFDerivAt (h : IsBoundedBilinearMap ğ•œ b) (p : E Ã— F) :\n    HasStrictFDerivAt b (h.deriv p) p := by\n  simp only [hasStrictFDerivAt_iff_isLittleO]\n  simp only [â† map_add_left_nhds_zero (p, p), isLittleO_map]\n  set T := (E Ã— F) Ã— E Ã— F\n  calc\n    _ = fun x â†¦ h.deriv (x.1 - x.2) (x.2.1, x.1.2) := by\n      ext âŸ¨âŸ¨xâ‚, yâ‚âŸ©, âŸ¨xâ‚‚, yâ‚‚âŸ©âŸ©\n      rcases p with âŸ¨x, yâŸ©\n      simp only [map_sub, deriv_apply, Function.comp_apply, Prod.mk_add_mk, h.add_right, h.add_left,\n        Prod.mk_sub_mk, h.map_sub_left, h.map_sub_right, sub_add_sub_cancel]\n      abel\n    -- _ =O[ğ“ (0 : T)] fun x â†¦ â€–x.1 - x.2â€– * â€–(x.2.1, x.1.2)â€– :=\n    --     h.toContinuousLinearMap.derivâ‚‚.isBoundedBilinearMap.isBigO_comp\n    -- _ = o[ğ“ 0] fun x â†¦ â€–x.1 - x.2â€– * 1 := _\n    _ =o[ğ“ (0 : T)] fun x â†¦ x.1 - x.2 := by\n      -- TODO : add 2 `calc` steps instead of the next 3 lines\n      refine h.toContinuousLinearMap.derivâ‚‚.isBoundedBilinearMap.isBigO_comp.trans_isLittleO ?_\n      suffices (fun x : T â†¦ â€–x.1 - x.2â€– * â€–(x.2.1, x.1.2)â€–) =o[ğ“ 0] fun x â†¦ â€–x.1 - x.2â€– * 1 by\n        simpa only [mul_one, isLittleO_norm_right] using this\n      refine (isBigO_refl _ _).mul_isLittleO ((isLittleO_one_iff _).2 ?_)\n      -- TODO: `continuity` fails\n      exact (continuous_snd.fst.prod_mk continuous_fst.snd).norm.tendsto' _ _ (by simp)\n    _ = _ := by simp [T, Function.comp_def]\n\n"}
{"name":"IsBoundedBilinearMap.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nb : Prod E F â†’ G\nh : IsBoundedBilinearMap ğ•œ b\np : Prod E F\nâŠ¢ HasFDerivAt b (h.deriv p) p","decl":"@[fun_prop]\ntheorem IsBoundedBilinearMap.hasFDerivAt (h : IsBoundedBilinearMap ğ•œ b) (p : E Ã— F) :\n    HasFDerivAt b (h.deriv p) p :=\n  (h.hasStrictFDerivAt p).hasFDerivAt\n\n"}
{"name":"IsBoundedBilinearMap.hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nb : Prod E F â†’ G\nu : Set (Prod E F)\nh : IsBoundedBilinearMap ğ•œ b\np : Prod E F\nâŠ¢ HasFDerivWithinAt b (h.deriv p) u p","decl":"@[fun_prop]\ntheorem IsBoundedBilinearMap.hasFDerivWithinAt (h : IsBoundedBilinearMap ğ•œ b) (p : E Ã— F) :\n    HasFDerivWithinAt b (h.deriv p) u p :=\n  (h.hasFDerivAt p).hasFDerivWithinAt\n\n"}
{"name":"IsBoundedBilinearMap.differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nb : Prod E F â†’ G\nh : IsBoundedBilinearMap ğ•œ b\np : Prod E F\nâŠ¢ DifferentiableAt ğ•œ b p","decl":"@[fun_prop]\ntheorem IsBoundedBilinearMap.differentiableAt (h : IsBoundedBilinearMap ğ•œ b) (p : E Ã— F) :\n    DifferentiableAt ğ•œ b p :=\n  (h.hasFDerivAt p).differentiableAt\n\n"}
{"name":"IsBoundedBilinearMap.differentiableWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nb : Prod E F â†’ G\nu : Set (Prod E F)\nh : IsBoundedBilinearMap ğ•œ b\np : Prod E F\nâŠ¢ DifferentiableWithinAt ğ•œ b u p","decl":"@[fun_prop]\ntheorem IsBoundedBilinearMap.differentiableWithinAt (h : IsBoundedBilinearMap ğ•œ b) (p : E Ã— F) :\n    DifferentiableWithinAt ğ•œ b u p :=\n  (h.differentiableAt p).differentiableWithinAt\n\n"}
{"name":"IsBoundedBilinearMap.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nb : Prod E F â†’ G\nh : IsBoundedBilinearMap ğ•œ b\np : Prod E F\nâŠ¢ Eq (fderiv ğ•œ b p) (h.deriv p)","decl":"protected theorem IsBoundedBilinearMap.fderiv (h : IsBoundedBilinearMap ğ•œ b) (p : E Ã— F) :\n    fderiv ğ•œ b p = h.deriv p :=\n  HasFDerivAt.fderiv (h.hasFDerivAt p)\n\n"}
{"name":"IsBoundedBilinearMap.fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nb : Prod E F â†’ G\nu : Set (Prod E F)\nh : IsBoundedBilinearMap ğ•œ b\np : Prod E F\nhxs : UniqueDiffWithinAt ğ•œ u p\nâŠ¢ Eq (fderivWithin ğ•œ b u p) (h.deriv p)","decl":"protected theorem IsBoundedBilinearMap.fderivWithin (h : IsBoundedBilinearMap ğ•œ b) (p : E Ã— F)\n    (hxs : UniqueDiffWithinAt ğ•œ u p) : fderivWithin ğ•œ b u p = h.deriv p := by\n  rw [DifferentiableAt.fderivWithin (h.differentiableAt p) hxs]\n  exact h.fderiv p\n\n"}
{"name":"IsBoundedBilinearMap.differentiable","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nb : Prod E F â†’ G\nh : IsBoundedBilinearMap ğ•œ b\nâŠ¢ Differentiable ğ•œ b","decl":"@[fun_prop]\ntheorem IsBoundedBilinearMap.differentiable (h : IsBoundedBilinearMap ğ•œ b) : Differentiable ğ•œ b :=\n  fun x => h.differentiableAt x\n\n"}
{"name":"IsBoundedBilinearMap.differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nb : Prod E F â†’ G\nu : Set (Prod E F)\nh : IsBoundedBilinearMap ğ•œ b\nâŠ¢ DifferentiableOn ğ•œ b u","decl":"@[fun_prop]\ntheorem IsBoundedBilinearMap.differentiableOn (h : IsBoundedBilinearMap ğ•œ b) :\n    DifferentiableOn ğ•œ b u :=\n  h.differentiable.differentiableOn\n\n"}
{"name":"ContinuousLinearMap.hasFDerivWithinAt_of_bilinear","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nG' : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nB : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) F G)\nf : G' â†’ E\ng : G' â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) G' E\ng' : ContinuousLinearMap (RingHom.id ğ•œ) G' F\nx : G'\ns : Set G'\nhf : HasFDerivWithinAt f f' s x\nhg : HasFDerivWithinAt g g' s x\nâŠ¢ HasFDerivWithinAt (fun y => (B (f y)) (g y)) (HAdd.hAdd (((ContinuousLinearMap.precompR G' B) (f x)) g') (((ContinuousLinearMap.precompL G' B) f') (g x))) s x","decl":"@[fun_prop]\ntheorem ContinuousLinearMap.hasFDerivWithinAt_of_bilinear {f : G' â†’ E} {g : G' â†’ F}\n    {f' : G' â†’L[ğ•œ] E} {g' : G' â†’L[ğ•œ] F} {x : G'} {s : Set G'} (hf : HasFDerivWithinAt f f' s x)\n    (hg : HasFDerivWithinAt g g' s x) :\n    HasFDerivWithinAt (fun y => B (f y) (g y))\n      (B.precompR G' (f x) g' + B.precompL G' f' (g x)) s x := by\n  exact (B.isBoundedBilinearMap.hasFDerivAt (f x, g x)).comp_hasFDerivWithinAt x (hf.prod hg)\n\n"}
{"name":"ContinuousLinearMap.hasFDerivAt_of_bilinear","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nG' : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nB : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) F G)\nf : G' â†’ E\ng : G' â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) G' E\ng' : ContinuousLinearMap (RingHom.id ğ•œ) G' F\nx : G'\nhf : HasFDerivAt f f' x\nhg : HasFDerivAt g g' x\nâŠ¢ HasFDerivAt (fun y => (B (f y)) (g y)) (HAdd.hAdd (((ContinuousLinearMap.precompR G' B) (f x)) g') (((ContinuousLinearMap.precompL G' B) f') (g x))) x","decl":"@[fun_prop]\ntheorem ContinuousLinearMap.hasFDerivAt_of_bilinear {f : G' â†’ E} {g : G' â†’ F} {f' : G' â†’L[ğ•œ] E}\n    {g' : G' â†’L[ğ•œ] F} {x : G'} (hf : HasFDerivAt f f' x) (hg : HasFDerivAt g g' x) :\n    HasFDerivAt (fun y => B (f y) (g y)) (B.precompR G' (f x) g' + B.precompL G' f' (g x)) x := by\n  exact (B.isBoundedBilinearMap.hasFDerivAt (f x, g x)).comp x (hf.prod hg)\n\n"}
{"name":"ContinuousLinearMap.hasStrictFDerivAt_of_bilinear","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nG' : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nB : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) F G)\nf : G' â†’ E\ng : G' â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) G' E\ng' : ContinuousLinearMap (RingHom.id ğ•œ) G' F\nx : G'\nhf : HasStrictFDerivAt f f' x\nhg : HasStrictFDerivAt g g' x\nâŠ¢ HasStrictFDerivAt (fun y => (B (f y)) (g y)) (HAdd.hAdd (((ContinuousLinearMap.precompR G' B) (f x)) g') (((ContinuousLinearMap.precompL G' B) f') (g x))) x","decl":"@[fun_prop]\ntheorem ContinuousLinearMap.hasStrictFDerivAt_of_bilinear\n    {f : G' â†’ E} {g : G' â†’ F} {f' : G' â†’L[ğ•œ] E}\n    {g' : G' â†’L[ğ•œ] F} {x : G'} (hf : HasStrictFDerivAt f f' x) (hg : HasStrictFDerivAt g g' x) :\n    HasStrictFDerivAt (fun y => B (f y) (g y))\n      (B.precompR G' (f x) g' + B.precompL G' f' (g x)) x :=\n  (B.isBoundedBilinearMap.hasStrictFDerivAt (f x, g x)).comp x (hf.prod hg)\n\n"}
{"name":"ContinuousLinearMap.fderivWithin_of_bilinear","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nG' : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nB : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) F G)\nf : G' â†’ E\ng : G' â†’ F\nx : G'\ns : Set G'\nhf : DifferentiableWithinAt ğ•œ f s x\nhg : DifferentiableWithinAt ğ•œ g s x\nhs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (fderivWithin ğ•œ (fun y => (B (f y)) (g y)) s x) (HAdd.hAdd (((ContinuousLinearMap.precompR G' B) (f x)) (fderivWithin ğ•œ g s x)) (((ContinuousLinearMap.precompL G' B) (fderivWithin ğ•œ f s x)) (g x)))","decl":"theorem ContinuousLinearMap.fderivWithin_of_bilinear {f : G' â†’ E} {g : G' â†’ F} {x : G'} {s : Set G'}\n    (hf : DifferentiableWithinAt ğ•œ f s x) (hg : DifferentiableWithinAt ğ•œ g s x)\n    (hs : UniqueDiffWithinAt ğ•œ s x) :\n    fderivWithin ğ•œ (fun y => B (f y) (g y)) s x =\n      B.precompR G' (f x) (fderivWithin ğ•œ g s x) + B.precompL G' (fderivWithin ğ•œ f s x) (g x) :=\n  (B.hasFDerivWithinAt_of_bilinear hf.hasFDerivWithinAt hg.hasFDerivWithinAt).fderivWithin hs\n\n"}
{"name":"ContinuousLinearMap.fderiv_of_bilinear","module":"Mathlib.Analysis.Calculus.FDeriv.Bilinear","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nG' : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nB : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) F G)\nf : G' â†’ E\ng : G' â†’ F\nx : G'\nhf : DifferentiableAt ğ•œ f x\nhg : DifferentiableAt ğ•œ g x\nâŠ¢ Eq (fderiv ğ•œ (fun y => (B (f y)) (g y)) x) (HAdd.hAdd (((ContinuousLinearMap.precompR G' B) (f x)) (fderiv ğ•œ g x)) (((ContinuousLinearMap.precompL G' B) (fderiv ğ•œ f x)) (g x)))","decl":"theorem ContinuousLinearMap.fderiv_of_bilinear {f : G' â†’ E} {g : G' â†’ F} {x : G'}\n    (hf : DifferentiableAt ğ•œ f x) (hg : DifferentiableAt ğ•œ g x) :\n    fderiv ğ•œ (fun y => B (f y) (g y)) x =\n      B.precompR G' (f x) (fderiv ğ•œ g x) + B.precompL G' (fderiv ğ•œ f x) (g x) :=\n  (B.hasFDerivAt_of_bilinear hf.hasFDerivAt hg.hasFDerivAt).fderiv\n\n"}
