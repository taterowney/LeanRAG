{"name":"NatOrdinal.instNoMaxOrder","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"⊢ NoMaxOrder NatOrdinal","decl":"instance NatOrdinal.instNoMaxOrder : NoMaxOrder NatOrdinal := Ordinal.instNoMaxOrder\n"}
{"name":"NatOrdinal.instZeroLEOneClass","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"⊢ ZeroLEOneClass NatOrdinal","decl":"instance NatOrdinal.instZeroLEOneClass : ZeroLEOneClass NatOrdinal := Ordinal.instZeroLEOneClass\n"}
{"name":"NatOrdinal.instNeZeroOne","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"⊢ NeZero 1","decl":"instance NatOrdinal.instNeZeroOne : NeZero (1 : NatOrdinal) := Ordinal.instNeZeroOne\n\n"}
{"name":"NatOrdinal.toOrdinal_symm_eq","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"⊢ Eq NatOrdinal.toOrdinal.symm Ordinal.toNatOrdinal","decl":"@[simp]\ntheorem toOrdinal_symm_eq : NatOrdinal.toOrdinal.symm = Ordinal.toNatOrdinal :=\n  rfl\n\n"}
{"name":"NatOrdinal.toOrdinal_toNatOrdinal","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a : NatOrdinal\n⊢ Eq (Ordinal.toNatOrdinal (NatOrdinal.toOrdinal a)) a","decl":"@[simp]\ntheorem toOrdinal_toNatOrdinal (a : NatOrdinal) : a.toOrdinal.toNatOrdinal = a :=\n  rfl\n\n"}
{"name":"NatOrdinal.lt_wf","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"⊢ WellFounded fun x1 x2 => LT.lt x1 x2","decl":"theorem lt_wf : @WellFounded NatOrdinal (· < ·) :=\n  Ordinal.lt_wf\n\n"}
{"name":"NatOrdinal.instWellFoundedLT","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"⊢ WellFoundedLT NatOrdinal","decl":"instance : WellFoundedLT NatOrdinal :=\n  Ordinal.wellFoundedLT\n\n"}
{"name":"NatOrdinal.bot_eq_zero","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"⊢ Eq Bot.bot 0","decl":"@[simp]\ntheorem bot_eq_zero : ⊥ = 0 :=\n  rfl\n\n"}
{"name":"NatOrdinal.toOrdinal_zero","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"⊢ Eq (NatOrdinal.toOrdinal 0) 0","decl":"@[simp]\ntheorem toOrdinal_zero : toOrdinal 0 = 0 :=\n  rfl\n\n"}
{"name":"NatOrdinal.toOrdinal_one","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"⊢ Eq (NatOrdinal.toOrdinal 1) 1","decl":"@[simp]\ntheorem toOrdinal_one : toOrdinal 1 = 1 :=\n  rfl\n\n"}
{"name":"NatOrdinal.toOrdinal_eq_zero","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a : NatOrdinal\n⊢ Iff (Eq (NatOrdinal.toOrdinal a) 0) (Eq a 0)","decl":"@[simp]\ntheorem toOrdinal_eq_zero {a} : toOrdinal a = 0 ↔ a = 0 :=\n  Iff.rfl\n\n"}
{"name":"NatOrdinal.toOrdinal_eq_one","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a : NatOrdinal\n⊢ Iff (Eq (NatOrdinal.toOrdinal a) 1) (Eq a 1)","decl":"@[simp]\ntheorem toOrdinal_eq_one {a} : toOrdinal a = 1 ↔ a = 1 :=\n  Iff.rfl\n\n"}
{"name":"NatOrdinal.toOrdinal_max","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : NatOrdinal\n⊢ Eq (NatOrdinal.toOrdinal (Max.max a b)) (Max.max (NatOrdinal.toOrdinal a) (NatOrdinal.toOrdinal b))","decl":"@[simp]\ntheorem toOrdinal_max (a b : NatOrdinal) : toOrdinal (max a b) = max (toOrdinal a) (toOrdinal b) :=\n  rfl\n\n"}
{"name":"NatOrdinal.toOrdinal_min","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : NatOrdinal\n⊢ Eq (NatOrdinal.toOrdinal (Min.min a b)) (Min.min (NatOrdinal.toOrdinal a) (NatOrdinal.toOrdinal b))","decl":"@[simp]\ntheorem toOrdinal_min (a b : NatOrdinal) : toOrdinal (min a b) = min (toOrdinal a) (toOrdinal b) :=\n  rfl\n\n"}
{"name":"NatOrdinal.succ_def","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a : NatOrdinal\n⊢ Eq (Order.succ a) (Ordinal.toNatOrdinal (HAdd.hAdd (NatOrdinal.toOrdinal a) 1))","decl":"theorem succ_def (a : NatOrdinal) : succ a = toNatOrdinal (toOrdinal a + 1) :=\n  rfl\n\n"}
{"name":"NatOrdinal.induction","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"p : NatOrdinal → Prop\ni : NatOrdinal\nx✝ : ∀ (j : NatOrdinal), (∀ (k : NatOrdinal), LT.lt k j → p k) → p j\n⊢ p i","decl":"/-- `Ordinal.induction` but for `NatOrdinal`. -/\ntheorem induction {p : NatOrdinal → Prop} : ∀ (i) (_ : ∀ j, (∀ k, k < j → p k) → p j), p i :=\n  Ordinal.induction\n\n"}
{"name":"Ordinal.toNatOrdinal_symm_eq","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"⊢ Eq Ordinal.toNatOrdinal.symm NatOrdinal.toOrdinal","decl":"@[simp]\ntheorem toNatOrdinal_symm_eq : toNatOrdinal.symm = NatOrdinal.toOrdinal :=\n  rfl\n\n"}
{"name":"Ordinal.toNatOrdinal_toOrdinal","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (NatOrdinal.toOrdinal (Ordinal.toNatOrdinal a)) a","decl":"@[simp]\ntheorem toNatOrdinal_toOrdinal (a : Ordinal) : a.toNatOrdinal.toOrdinal = a :=\n  rfl\n\n"}
{"name":"Ordinal.toNatOrdinal_zero","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"⊢ Eq (Ordinal.toNatOrdinal 0) 0","decl":"@[simp]\ntheorem toNatOrdinal_zero : toNatOrdinal 0 = 0 :=\n  rfl\n\n"}
{"name":"Ordinal.toNatOrdinal_one","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"⊢ Eq (Ordinal.toNatOrdinal 1) 1","decl":"@[simp]\ntheorem toNatOrdinal_one : toNatOrdinal 1 = 1 :=\n  rfl\n\n"}
{"name":"Ordinal.toNatOrdinal_eq_zero","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a : Ordinal.{u_1}\n⊢ Iff (Eq (Ordinal.toNatOrdinal a) 0) (Eq a 0)","decl":"@[simp]\ntheorem toNatOrdinal_eq_zero (a) : toNatOrdinal a = 0 ↔ a = 0 :=\n  Iff.rfl\n\n"}
{"name":"Ordinal.toNatOrdinal_eq_one","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a : Ordinal.{u_1}\n⊢ Iff (Eq (Ordinal.toNatOrdinal a) 1) (Eq a 1)","decl":"@[simp]\ntheorem toNatOrdinal_eq_one (a) : toNatOrdinal a = 1 ↔ a = 1 :=\n  Iff.rfl\n\n"}
{"name":"Ordinal.toNatOrdinal_max","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u_1}\n⊢ Eq (Ordinal.toNatOrdinal (Max.max a b)) (Max.max (Ordinal.toNatOrdinal a) (Ordinal.toNatOrdinal b))","decl":"@[simp]\ntheorem toNatOrdinal_max (a b : Ordinal) :\n    toNatOrdinal (max a b) = max (toNatOrdinal a) (toNatOrdinal b) :=\n  rfl\n\n"}
{"name":"Ordinal.toNatOrdinal_min","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u_1}\n⊢ Eq (Ordinal.toNatOrdinal (Min.min a b)) (Min.min (Ordinal.toNatOrdinal a) (Ordinal.toNatOrdinal b))","decl":"@[simp]\ntheorem toNatOrdinal_min (a b : Ordinal) :\n    toNatOrdinal (min a b) = min (toNatOrdinal a) (toNatOrdinal b) :=\n  rfl\n\n"}
{"name":"Ordinal.lt_nadd_iff","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u}\n⊢ Iff (LT.lt a (b.nadd c)) (Or (Exists fun b' => And (LT.lt b' b) (LE.le a (b'.nadd c))) (Exists fun c' => And (LT.lt c' c) (LE.le a (b.nadd c'))))","decl":"theorem lt_nadd_iff : a < b ♯ c ↔ (∃ b' < b, a ≤ b' ♯ c) ∨ ∃ c' < c, a ≤ b ♯ c' := by\n  rw [nadd]\n  simp [Ordinal.lt_iSup_iff]\n\n"}
{"name":"Ordinal.nadd_le_iff","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u}\n⊢ Iff (LE.le (b.nadd c) a) (And (∀ (b' : Ordinal.{u}), LT.lt b' b → LT.lt (b'.nadd c) a) (∀ (c' : Ordinal.{u}), LT.lt c' c → LT.lt (b.nadd c') a))","decl":"theorem nadd_le_iff : b ♯ c ≤ a ↔ (∀ b' < b, b' ♯ c < a) ∧ ∀ c' < c, b ♯ c' < a := by\n  rw [← not_lt, lt_nadd_iff]\n  simp\n\n"}
{"name":"Ordinal.nadd_lt_nadd_left","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"b c : Ordinal.{u}\nh : LT.lt b c\na : Ordinal.{u}\n⊢ LT.lt (a.nadd b) (a.nadd c)","decl":"theorem nadd_lt_nadd_left (h : b < c) (a) : a ♯ b < a ♯ c :=\n  lt_nadd_iff.2 (Or.inr ⟨b, h, le_rfl⟩)\n\n"}
{"name":"Ordinal.nadd_lt_nadd_right","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"b c : Ordinal.{u}\nh : LT.lt b c\na : Ordinal.{u}\n⊢ LT.lt (b.nadd a) (c.nadd a)","decl":"theorem nadd_lt_nadd_right (h : b < c) (a) : b ♯ a < c ♯ a :=\n  lt_nadd_iff.2 (Or.inl ⟨b, h, le_rfl⟩)\n\n"}
{"name":"Ordinal.nadd_le_nadd_left","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"b c : Ordinal.{u}\nh : LE.le b c\na : Ordinal.{u}\n⊢ LE.le (a.nadd b) (a.nadd c)","decl":"theorem nadd_le_nadd_left (h : b ≤ c) (a) : a ♯ b ≤ a ♯ c := by\n  rcases lt_or_eq_of_le h with (h | rfl)\n  · exact (nadd_lt_nadd_left h a).le\n  · exact le_rfl\n\n"}
{"name":"Ordinal.nadd_le_nadd_right","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"b c : Ordinal.{u}\nh : LE.le b c\na : Ordinal.{u}\n⊢ LE.le (b.nadd a) (c.nadd a)","decl":"theorem nadd_le_nadd_right (h : b ≤ c) (a) : b ♯ a ≤ c ♯ a := by\n  rcases lt_or_eq_of_le h with (h | rfl)\n  · exact (nadd_lt_nadd_right h a).le\n  · exact le_rfl\n\n"}
{"name":"Ordinal.nadd_comm","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u_1}\n⊢ Eq (a.nadd b) (b.nadd a)","decl":"theorem nadd_comm (a b) : a ♯ b = b ♯ a := by\n  rw [nadd, nadd, max_comm]\n  congr <;> ext x <;> cases x <;> apply congr_arg _ (nadd_comm _ _)\ntermination_by (a, b)\n\n"}
{"name":"Ordinal.blsub_nadd_of_mono","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u}\nf : (c : Ordinal.{u}) → LT.lt c (a.nadd b) → Ordinal.{max u v}\nhf : ∀ {i j : Ordinal.{u}} (hi : LT.lt i (a.nadd b)) (hj : LT.lt j (a.nadd b)), LE.le i j → LE.le (f i hi) (f j hj)\n⊢ Eq ((a.nadd b).blsub f) (Max.max (a.blsub fun a' ha' => f (a'.nadd b) ⋯) (b.blsub fun b' hb' => f (a.nadd b') ⋯))","decl":"@[deprecated \"blsub will soon be deprecated\" (since := \"2024-11-18\")]\ntheorem blsub_nadd_of_mono {f : ∀ c < a ♯ b, Ordinal.{max u v}}\n    (hf : ∀ {i j} (hi hj), i ≤ j → f i hi ≤ f j hj) :\n    blsub.{u,v} _ f =\n      max (blsub.{u, v} a fun a' ha' => f (a' ♯ b) <| nadd_lt_nadd_right ha' b)\n        (blsub.{u, v} b fun b' hb' => f (a ♯ b') <| nadd_lt_nadd_left hb' a) := by\n  apply (blsub_le_iff.2 fun i h => _).antisymm (max_le _ _)\n  · intro i h\n    rcases lt_nadd_iff.1 h with (⟨a', ha', hi⟩ | ⟨b', hb', hi⟩)\n    · exact lt_max_of_lt_left ((hf h (nadd_lt_nadd_right ha' b) hi).trans_lt (lt_blsub _ _ ha'))\n    · exact lt_max_of_lt_right ((hf h (nadd_lt_nadd_left hb' a) hi).trans_lt (lt_blsub _ _ hb'))\n  all_goals\n    apply blsub_le_of_brange_subset.{u, u, v}\n    rintro c ⟨d, hd, rfl⟩\n    apply mem_brange_self\n\n"}
{"name":"Ordinal.nadd_assoc","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u_1}\n⊢ Eq ((a.nadd b).nadd c) (a.nadd (b.nadd c))","decl":"theorem nadd_assoc (a b c) : a ♯ b ♯ c = a ♯ (b ♯ c) := by\n  unfold nadd\n  rw [iSup_nadd_of_monotone fun a' ↦ succ (a' ♯ c), iSup_nadd_of_monotone fun b' ↦ succ (a ♯ b'),\n    max_assoc]\n  · congr <;> ext x <;> cases x <;> apply congr_arg _ (nadd_assoc _ _ _)\n  · exact succ_mono.comp fun x y h ↦ nadd_le_nadd_left h _\n  · exact succ_mono.comp fun x y h ↦ nadd_le_nadd_right h _\ntermination_by (a, b, c)\n\n"}
{"name":"Ordinal.nadd_zero","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (a.nadd 0) a","decl":"@[simp]\ntheorem nadd_zero (a : Ordinal) : a ♯ 0 = a := by\n  rw [nadd, ciSup_of_empty fun _ : Iio 0 ↦ _, sup_bot_eq]\n  convert iSup_succ a\n  rename_i x\n  cases x\n  exact nadd_zero _\ntermination_by a\n\n"}
{"name":"Ordinal.zero_nadd","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a : Ordinal.{u}\n⊢ Eq (Ordinal.nadd 0 a) a","decl":"@[simp]\ntheorem zero_nadd : 0 ♯ a = a := by rw [nadd_comm, nadd_zero]\n\n"}
{"name":"Ordinal.nadd_one","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (a.nadd 1) (Order.succ a)","decl":"@[simp]\ntheorem nadd_one (a : Ordinal) : a ♯ 1 = succ a := by\n  rw [nadd, ciSup_unique (s := fun _ : Iio 1 ↦ _), Iio_one_default_eq, nadd_zero,\n    max_eq_right_iff, Ordinal.iSup_le_iff]\n  rintro ⟨i, hi⟩\n  rwa [nadd_one, succ_le_succ_iff, succ_le_iff]\ntermination_by a\n\n"}
{"name":"Ordinal.one_nadd","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a : Ordinal.{u}\n⊢ Eq (Ordinal.nadd 1 a) (Order.succ a)","decl":"@[simp]\ntheorem one_nadd : 1 ♯ a = succ a := by rw [nadd_comm, nadd_one]\n\n"}
{"name":"Ordinal.nadd_succ","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u}\n⊢ Eq (a.nadd (Order.succ b)) (Order.succ (a.nadd b))","decl":"theorem nadd_succ : a ♯ succ b = succ (a ♯ b) := by rw [← nadd_one (a ♯ b), nadd_assoc, nadd_one]\n\n"}
{"name":"Ordinal.succ_nadd","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u}\n⊢ Eq ((Order.succ a).nadd b) (Order.succ (a.nadd b))","decl":"theorem succ_nadd : succ a ♯ b = succ (a ♯ b) := by rw [← one_nadd (a ♯ b), ← nadd_assoc, one_nadd]\n\n"}
{"name":"Ordinal.nadd_nat","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a : Ordinal.{u}\nn : Nat\n⊢ Eq (a.nadd ↑n) (HAdd.hAdd a ↑n)","decl":"@[simp]\ntheorem nadd_nat (n : ℕ) : a ♯ n = a + n := by\n  induction' n with n hn\n  · simp\n  · rw [Nat.cast_succ, add_one_eq_succ, nadd_succ, add_succ, hn]\n\n"}
{"name":"Ordinal.nat_nadd","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a : Ordinal.{u}\nn : Nat\n⊢ Eq ((↑n).nadd a) (HAdd.hAdd a ↑n)","decl":"@[simp]\ntheorem nat_nadd (n : ℕ) : ↑n ♯ a = a + n := by rw [nadd_comm, nadd_nat]\n\n"}
{"name":"Ordinal.add_le_nadd","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u}\n⊢ LE.le (HAdd.hAdd a b) (a.nadd b)","decl":"theorem add_le_nadd : a + b ≤ a ♯ b := by\n  induction b using limitRecOn with\n  | H₁ => simp\n  | H₂ c h =>\n    rwa [add_succ, nadd_succ, succ_le_succ_iff]\n  | H₃ c hc H =>\n    rw [(isNormal_add_right a).apply_of_isLimit hc, Ordinal.iSup_le_iff]\n    rintro ⟨i, hi⟩\n    exact (H i hi).trans (nadd_le_nadd_left hi.le a)\n\n"}
{"name":"NatOrdinal.instAddLeftStrictMono","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"⊢ AddLeftStrictMono NatOrdinal","decl":"instance : AddLeftStrictMono NatOrdinal.{u} :=\n  ⟨fun a _ _ h => nadd_lt_nadd_left h a⟩\n\n"}
{"name":"NatOrdinal.instAddLeftMono","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"⊢ AddLeftMono NatOrdinal","decl":"instance : AddLeftMono NatOrdinal.{u} :=\n  ⟨fun a _ _ h => nadd_le_nadd_left h a⟩\n\n"}
{"name":"NatOrdinal.instAddLeftReflectLE","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"⊢ AddLeftReflectLE NatOrdinal","decl":"instance : AddLeftReflectLE NatOrdinal.{u} :=\n  ⟨fun a b c h => by\n    by_contra! h'\n    exact h.not_lt (add_lt_add_left h' a)⟩\n\n"}
{"name":"NatOrdinal.add_one_eq_succ","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a : NatOrdinal\n⊢ Eq (HAdd.hAdd a 1) (Order.succ a)","decl":"@[deprecated Order.succ_eq_add_one (since := \"2024-09-04\")]\ntheorem add_one_eq_succ (a : NatOrdinal) : a + 1 = succ a :=\n  (Order.succ_eq_add_one a).symm\n\n"}
{"name":"NatOrdinal.toOrdinal_cast_nat","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"n : Nat\n⊢ Eq (NatOrdinal.toOrdinal ↑n) ↑n","decl":"@[simp]\ntheorem toOrdinal_cast_nat (n : ℕ) : toOrdinal n = n := by\n  induction' n with n hn\n  · rfl\n  · change (toOrdinal n) ♯ 1 = n + 1\n    rw [hn]; exact nadd_one n\n\n"}
{"name":"Ordinal.nadd_eq_add","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u_1}\n⊢ Eq (a.nadd b) (NatOrdinal.toOrdinal (HAdd.hAdd (Ordinal.toNatOrdinal a) (Ordinal.toNatOrdinal b)))","decl":"theorem nadd_eq_add (a b : Ordinal) : a ♯ b = toOrdinal (toNatOrdinal a + toNatOrdinal b) :=\n  rfl\n\n"}
{"name":"Ordinal.toNatOrdinal_cast_nat","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"n : Nat\n⊢ Eq (Ordinal.toNatOrdinal ↑n) ↑n","decl":"@[simp]\ntheorem toNatOrdinal_cast_nat (n : ℕ) : toNatOrdinal n = n := by\n  rw [← toOrdinal_cast_nat n]\n  rfl\n\n"}
{"name":"Ordinal.lt_of_nadd_lt_nadd_left","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u_1}\na✝ : LT.lt (a.nadd b) (a.nadd c)\n⊢ LT.lt b c","decl":"theorem lt_of_nadd_lt_nadd_left : ∀ {a b c}, a ♯ b < a ♯ c → b < c :=\n  @lt_of_add_lt_add_left NatOrdinal _ _ _\n\n"}
{"name":"Ordinal.lt_of_nadd_lt_nadd_right","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u_1}\na✝ : LT.lt (b.nadd a) (c.nadd a)\n⊢ LT.lt b c","decl":"theorem lt_of_nadd_lt_nadd_right : ∀ {a b c}, b ♯ a < c ♯ a → b < c :=\n  @lt_of_add_lt_add_right NatOrdinal _ _ _\n\n"}
{"name":"Ordinal.le_of_nadd_le_nadd_left","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u_1}\na✝ : LE.le (a.nadd b) (a.nadd c)\n⊢ LE.le b c","decl":"theorem le_of_nadd_le_nadd_left : ∀ {a b c}, a ♯ b ≤ a ♯ c → b ≤ c :=\n  @le_of_add_le_add_left NatOrdinal _ _ _\n\n"}
{"name":"Ordinal.le_of_nadd_le_nadd_right","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u_1}\na✝ : LE.le (b.nadd a) (c.nadd a)\n⊢ LE.le b c","decl":"theorem le_of_nadd_le_nadd_right : ∀ {a b c}, b ♯ a ≤ c ♯ a → b ≤ c :=\n  @le_of_add_le_add_right NatOrdinal _ _ _\n\n"}
{"name":"Ordinal.nadd_lt_nadd_iff_left","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u_1}\n⊢ Iff (LT.lt (a.nadd b) (a.nadd c)) (LT.lt b c)","decl":"theorem nadd_lt_nadd_iff_left : ∀ (a) {b c}, a ♯ b < a ♯ c ↔ b < c :=\n  @add_lt_add_iff_left NatOrdinal _ _ _ _\n\n"}
{"name":"Ordinal.nadd_lt_nadd_iff_right","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u_1}\n⊢ Iff (LT.lt (b.nadd a) (c.nadd a)) (LT.lt b c)","decl":"theorem nadd_lt_nadd_iff_right : ∀ (a) {b c}, b ♯ a < c ♯ a ↔ b < c :=\n  @add_lt_add_iff_right NatOrdinal _ _ _ _\n\n"}
{"name":"Ordinal.nadd_le_nadd_iff_left","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u_1}\n⊢ Iff (LE.le (a.nadd b) (a.nadd c)) (LE.le b c)","decl":"theorem nadd_le_nadd_iff_left : ∀ (a) {b c}, a ♯ b ≤ a ♯ c ↔ b ≤ c :=\n  @add_le_add_iff_left NatOrdinal _ _ _ _\n\n"}
{"name":"Ordinal.nadd_le_nadd_iff_right","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u_1}\n⊢ Iff (LE.le (b.nadd a) (c.nadd a)) (LE.le b c)","decl":"theorem nadd_le_nadd_iff_right : ∀ (a) {b c}, b ♯ a ≤ c ♯ a ↔ b ≤ c :=\n  @_root_.add_le_add_iff_right NatOrdinal _ _ _ _\n\n"}
{"name":"Ordinal.nadd_le_nadd","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c d : Ordinal.{u_1}\na✝¹ : LE.le a b\na✝ : LE.le c d\n⊢ LE.le (a.nadd c) (b.nadd d)","decl":"theorem nadd_le_nadd : ∀ {a b c d}, a ≤ b → c ≤ d → a ♯ c ≤ b ♯ d :=\n  @add_le_add NatOrdinal _ _ _ _\n\n"}
{"name":"Ordinal.nadd_lt_nadd","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c d : Ordinal.{u_1}\na✝¹ : LT.lt a b\na✝ : LT.lt c d\n⊢ LT.lt (a.nadd c) (b.nadd d)","decl":"theorem nadd_lt_nadd : ∀ {a b c d}, a < b → c < d → a ♯ c < b ♯ d :=\n  @add_lt_add NatOrdinal _ _ _ _\n\n"}
{"name":"Ordinal.nadd_lt_nadd_of_lt_of_le","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c d : Ordinal.{u_1}\na✝¹ : LT.lt a b\na✝ : LE.le c d\n⊢ LT.lt (a.nadd c) (b.nadd d)","decl":"theorem nadd_lt_nadd_of_lt_of_le : ∀ {a b c d}, a < b → c ≤ d → a ♯ c < b ♯ d :=\n  @add_lt_add_of_lt_of_le NatOrdinal _ _ _ _\n\n"}
{"name":"Ordinal.nadd_lt_nadd_of_le_of_lt","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c d : Ordinal.{u_1}\na✝¹ : LE.le a b\na✝ : LT.lt c d\n⊢ LT.lt (a.nadd c) (b.nadd d)","decl":"theorem nadd_lt_nadd_of_le_of_lt : ∀ {a b c d}, a ≤ b → c < d → a ♯ c < b ♯ d :=\n  @add_lt_add_of_le_of_lt NatOrdinal _ _ _ _\n\n"}
{"name":"Ordinal.nadd_left_cancel","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u_1}\na✝ : Eq (a.nadd b) (a.nadd c)\n⊢ Eq b c","decl":"theorem nadd_left_cancel : ∀ {a b c}, a ♯ b = a ♯ c → b = c :=\n  @_root_.add_left_cancel NatOrdinal _ _\n\n"}
{"name":"Ordinal.nadd_right_cancel","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u_1}\na✝ : Eq (a.nadd b) (c.nadd b)\n⊢ Eq a c","decl":"theorem nadd_right_cancel : ∀ {a b c}, a ♯ b = c ♯ b → a = c :=\n  @_root_.add_right_cancel NatOrdinal _ _\n\n"}
{"name":"Ordinal.nadd_left_cancel_iff","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u_1}\n⊢ Iff (Eq (a.nadd b) (a.nadd c)) (Eq b c)","decl":"theorem nadd_left_cancel_iff : ∀ {a b c}, a ♯ b = a ♯ c ↔ b = c :=\n  @add_left_cancel_iff NatOrdinal _ _\n\n"}
{"name":"Ordinal.nadd_right_cancel_iff","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u_1}\n⊢ Iff (Eq (b.nadd a) (c.nadd a)) (Eq b c)","decl":"theorem nadd_right_cancel_iff : ∀ {a b c}, b ♯ a = c ♯ a ↔ b = c :=\n  @add_right_cancel_iff NatOrdinal _ _\n\n"}
{"name":"Ordinal.le_nadd_self","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u_1}\n⊢ LE.le a (b.nadd a)","decl":"theorem le_nadd_self {a b} : a ≤ b ♯ a := by simpa using nadd_le_nadd_right (Ordinal.zero_le b) a\n\n"}
{"name":"Ordinal.le_nadd_left","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u_1}\nh : LE.le a c\n⊢ LE.le a (b.nadd c)","decl":"theorem le_nadd_left {a b c} (h : a ≤ c) : a ≤ b ♯ c :=\n  le_nadd_self.trans (nadd_le_nadd_left h b)\n\n"}
{"name":"Ordinal.le_self_nadd","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u_1}\n⊢ LE.le a (a.nadd b)","decl":"theorem le_self_nadd {a b} : a ≤ a ♯ b := by simpa using nadd_le_nadd_left (Ordinal.zero_le b) a\n\n"}
{"name":"Ordinal.le_nadd_right","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u_1}\nh : LE.le a b\n⊢ LE.le a (b.nadd c)","decl":"theorem le_nadd_right {a b c} (h : a ≤ b) : a ≤ b ♯ c :=\n  le_self_nadd.trans (nadd_le_nadd_right h c)\n\n"}
{"name":"Ordinal.nadd_left_comm","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u_1}\n⊢ Eq (a.nadd (b.nadd c)) (b.nadd (a.nadd c))","decl":"theorem nadd_left_comm : ∀ a b c, a ♯ (b ♯ c) = b ♯ (a ♯ c) :=\n  @add_left_comm NatOrdinal _\n\n"}
{"name":"Ordinal.nadd_right_comm","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u_1}\n⊢ Eq ((a.nadd b).nadd c) ((a.nadd c).nadd b)","decl":"theorem nadd_right_comm : ∀ a b c, a ♯ b ♯ c = a ♯ c ♯ b :=\n  @add_right_comm NatOrdinal _\n\n"}
{"name":"Ordinal.nmul_def","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u_1}\n⊢ Eq (a.nmul b) (InfSet.sInf (setOf fun c => ∀ (a' : Ordinal.{u_1}), LT.lt a' a → ∀ (b' : Ordinal.{u_1}), LT.lt b' b → LT.lt ((a'.nmul b).nadd (a.nmul b')) (c.nadd (a'.nmul b'))))","decl":"@[deprecated \"avoid using the definition of `nmul` directly\" (since := \"2024-11-19\")]\ntheorem nmul_def (a b : Ordinal) :\n    a ⨳ b = sInf {c | ∀ a' < a, ∀ b' < b, a' ⨳ b ♯ a ⨳ b' < c ♯ a' ⨳ b'} := by\n  rw [nmul]\n\n"}
{"name":"Ordinal.nmul_nadd_lt","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b a' b' : Ordinal.{u}\nha : LT.lt a' a\nhb : LT.lt b' b\n⊢ LT.lt ((a'.nmul b).nadd (a.nmul b')) ((a.nmul b).nadd (a'.nmul b'))","decl":"theorem nmul_nadd_lt {a' b' : Ordinal} (ha : a' < a) (hb : b' < b) :\n    a' ⨳ b ♯ a ⨳ b' < a ⨳ b ♯ a' ⨳ b' := by\n  conv_rhs => rw [nmul]\n  exact csInf_mem (nmul_nonempty a b) a' ha b' hb\n\n"}
{"name":"Ordinal.nmul_nadd_le","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b a' b' : Ordinal.{u}\nha : LE.le a' a\nhb : LE.le b' b\n⊢ LE.le ((a'.nmul b).nadd (a.nmul b')) ((a.nmul b).nadd (a'.nmul b'))","decl":"theorem nmul_nadd_le {a' b' : Ordinal} (ha : a' ≤ a) (hb : b' ≤ b) :\n    a' ⨳ b ♯ a ⨳ b' ≤ a ⨳ b ♯ a' ⨳ b' := by\n  rcases lt_or_eq_of_le ha with (ha | rfl)\n  · rcases lt_or_eq_of_le hb with (hb | rfl)\n    · exact (nmul_nadd_lt ha hb).le\n    · rw [nadd_comm]\n  · exact le_rfl\n\n"}
{"name":"Ordinal.lt_nmul_iff","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u}\n⊢ Iff (LT.lt c (a.nmul b)) (Exists fun a' => And (LT.lt a' a) (Exists fun b' => And (LT.lt b' b) (LE.le (c.nadd (a'.nmul b')) ((a'.nmul b).nadd (a.nmul b')))))","decl":"theorem lt_nmul_iff : c < a ⨳ b ↔ ∃ a' < a, ∃ b' < b, c ♯ a' ⨳ b' ≤ a' ⨳ b ♯ a ⨳ b' := by\n  refine ⟨fun h => ?_, ?_⟩\n  · rw [nmul] at h\n    simpa using not_mem_of_lt_csInf h ⟨0, fun _ _ => bot_le⟩\n  · rintro ⟨a', ha, b', hb, h⟩\n    have := h.trans_lt (nmul_nadd_lt ha hb)\n    rwa [nadd_lt_nadd_iff_right] at this\n\n"}
{"name":"Ordinal.nmul_le_iff","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u}\n⊢ Iff (LE.le (a.nmul b) c) (∀ (a' : Ordinal.{u}), LT.lt a' a → ∀ (b' : Ordinal.{u}), LT.lt b' b → LT.lt ((a'.nmul b).nadd (a.nmul b')) (c.nadd (a'.nmul b')))","decl":"theorem nmul_le_iff : a ⨳ b ≤ c ↔ ∀ a' < a, ∀ b' < b, a' ⨳ b ♯ a ⨳ b' < c ♯ a' ⨳ b' := by\n  rw [← not_iff_not]; simp [lt_nmul_iff]\n\n"}
{"name":"Ordinal.nmul_comm","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u_1}\n⊢ Eq (a.nmul b) (b.nmul a)","decl":"theorem nmul_comm (a b) : a ⨳ b = b ⨳ a := by\n  rw [nmul, nmul]\n  congr; ext x; constructor <;> intro H c hc d hd\n  · rw [nadd_comm, ← nmul_comm, ← nmul_comm a, ← nmul_comm d]\n    exact H _ hd _ hc\n  · rw [nadd_comm, nmul_comm, nmul_comm c, nmul_comm c]\n    exact H _ hd _ hc\ntermination_by (a, b)\n\n"}
{"name":"Ordinal.nmul_zero","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (a.nmul 0) 0","decl":"@[simp]\ntheorem nmul_zero (a) : a ⨳ 0 = 0 := by\n  rw [← Ordinal.le_zero, nmul_le_iff]\n  exact fun _ _ a ha => (Ordinal.not_lt_zero a ha).elim\n\n"}
{"name":"Ordinal.zero_nmul","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (Ordinal.nmul 0 a) 0","decl":"@[simp]\ntheorem zero_nmul (a) : 0 ⨳ a = 0 := by rw [nmul_comm, nmul_zero]\n\n"}
{"name":"Ordinal.nmul_one","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (a.nmul 1) a","decl":"@[simp]\ntheorem nmul_one (a : Ordinal) : a ⨳ 1 = a := by\n  rw [nmul]\n  convert csInf_Ici\n  ext b\n  refine ⟨fun H ↦ le_of_forall_lt (a := a) fun c hc ↦ ?_, fun ha c hc ↦ ?_⟩\n  -- Porting note: had to add arguments to `nmul_one` in the next two lines\n  -- for the termination checker.\n  · simpa [nmul_one c] using H c hc\n  · simpa [nmul_one c] using hc.trans_le ha\ntermination_by a\n\n"}
{"name":"Ordinal.one_nmul","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (Ordinal.nmul 1 a) a","decl":"@[simp]\ntheorem one_nmul (a) : 1 ⨳ a = a := by rw [nmul_comm, nmul_one]\n\n"}
{"name":"Ordinal.nmul_lt_nmul_of_pos_left","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u}\nh₁ : LT.lt a b\nh₂ : LT.lt 0 c\n⊢ LT.lt (c.nmul a) (c.nmul b)","decl":"theorem nmul_lt_nmul_of_pos_left (h₁ : a < b) (h₂ : 0 < c) : c ⨳ a < c ⨳ b :=\n  lt_nmul_iff.2 ⟨0, h₂, a, h₁, by simp⟩\n\n"}
{"name":"Ordinal.nmul_lt_nmul_of_pos_right","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u}\nh₁ : LT.lt a b\nh₂ : LT.lt 0 c\n⊢ LT.lt (a.nmul c) (b.nmul c)","decl":"theorem nmul_lt_nmul_of_pos_right (h₁ : a < b) (h₂ : 0 < c) : a ⨳ c < b ⨳ c :=\n  lt_nmul_iff.2 ⟨a, h₁, 0, h₂, by simp⟩\n\n"}
{"name":"Ordinal.nmul_le_nmul_left","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u}\nh : LE.le a b\nc : Ordinal.{u}\n⊢ LE.le (c.nmul a) (c.nmul b)","decl":"theorem nmul_le_nmul_left (h : a ≤ b) (c) : c ⨳ a ≤ c ⨳ b := by\n  rcases lt_or_eq_of_le h with (h₁ | rfl) <;> rcases (eq_zero_or_pos c).symm with (h₂ | rfl)\n  · exact (nmul_lt_nmul_of_pos_left h₁ h₂).le\n  all_goals simp\n\n"}
{"name":"Ordinal.nmul_le_nmul_of_nonneg_left","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u}\nh : LE.le a b\nc : Ordinal.{u}\n⊢ LE.le (c.nmul a) (c.nmul b)","decl":"@[deprecated nmul_le_nmul_left (since := \"2024-08-20\")]\nalias nmul_le_nmul_of_nonneg_left := nmul_le_nmul_left\n\n"}
{"name":"Ordinal.nmul_le_nmul_right","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u}\nh : LE.le a b\nc : Ordinal.{u}\n⊢ LE.le (a.nmul c) (b.nmul c)","decl":"theorem nmul_le_nmul_right (h : a ≤ b) (c) : a ⨳ c ≤ b ⨳ c := by\n  rw [nmul_comm, nmul_comm b]\n  exact nmul_le_nmul_left h c\n\n"}
{"name":"Ordinal.nmul_le_nmul_of_nonneg_right","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u}\nh : LE.le a b\nc : Ordinal.{u}\n⊢ LE.le (a.nmul c) (b.nmul c)","decl":"@[deprecated nmul_le_nmul_left (since := \"2024-08-20\")]\nalias nmul_le_nmul_of_nonneg_right := nmul_le_nmul_right\n\n"}
{"name":"Ordinal.nmul_nadd","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u_1}\n⊢ Eq (a.nmul (b.nadd c)) ((a.nmul b).nadd (a.nmul c))","decl":"theorem nmul_nadd (a b c : Ordinal) : a ⨳ (b ♯ c) = a ⨳ b ♯ a ⨳ c := by\n  refine le_antisymm (nmul_le_iff.2 fun a' ha d hd => ?_)\n    (nadd_le_iff.2 ⟨fun d hd => ?_, fun d hd => ?_⟩)\n  · rw [nmul_nadd]\n    rcases lt_nadd_iff.1 hd with (⟨b', hb, hd⟩ | ⟨c', hc, hd⟩)\n    · have := nadd_lt_nadd_of_lt_of_le (nmul_nadd_lt ha hb) (nmul_nadd_le ha.le hd)\n      rw [nmul_nadd, nmul_nadd] at this\n      simp only [nadd_assoc] at this\n      rwa [nadd_left_comm, nadd_left_comm _ (a ⨳ b'), nadd_left_comm (a ⨳ b),\n        nadd_lt_nadd_iff_left, nadd_left_comm (a' ⨳ b), nadd_left_comm (a ⨳ b),\n        nadd_lt_nadd_iff_left, ← nadd_assoc, ← nadd_assoc] at this\n    · have := nadd_lt_nadd_of_le_of_lt (nmul_nadd_le ha.le hd) (nmul_nadd_lt ha hc)\n      rw [nmul_nadd, nmul_nadd] at this\n      simp only [nadd_assoc] at this\n      rwa [nadd_left_comm, nadd_comm (a ⨳ c), nadd_left_comm (a' ⨳ d), nadd_left_comm (a ⨳ c'),\n        nadd_left_comm (a ⨳ b), nadd_lt_nadd_iff_left, nadd_comm (a' ⨳ c), nadd_left_comm (a ⨳ d),\n        nadd_left_comm (a' ⨳ b), nadd_left_comm (a ⨳ b), nadd_lt_nadd_iff_left, nadd_comm (a ⨳ d),\n        nadd_comm (a' ⨳ d), ← nadd_assoc, ← nadd_assoc] at this\n  · rcases lt_nmul_iff.1 hd with ⟨a', ha, b', hb, hd⟩\n    have := nadd_lt_nadd_of_le_of_lt hd (nmul_nadd_lt ha (nadd_lt_nadd_right hb c))\n    rw [nmul_nadd, nmul_nadd, nmul_nadd a'] at this\n    simp only [nadd_assoc] at this\n    rwa [nadd_left_comm (a' ⨳ b'), nadd_left_comm, nadd_lt_nadd_iff_left, nadd_left_comm,\n      nadd_left_comm _ (a' ⨳ b'), nadd_left_comm (a ⨳ b'), nadd_lt_nadd_iff_left,\n      nadd_left_comm (a' ⨳ c), nadd_left_comm, nadd_lt_nadd_iff_left, nadd_left_comm,\n      nadd_comm _ (a' ⨳ c), nadd_lt_nadd_iff_left] at this\n  · rcases lt_nmul_iff.1 hd with ⟨a', ha, c', hc, hd⟩\n    have := nadd_lt_nadd_of_lt_of_le (nmul_nadd_lt ha (nadd_lt_nadd_left hc b)) hd\n    rw [nmul_nadd, nmul_nadd, nmul_nadd a'] at this\n    simp only [nadd_assoc] at this\n    rwa [nadd_left_comm _ (a' ⨳ b), nadd_lt_nadd_iff_left, nadd_left_comm (a' ⨳ c'),\n      nadd_left_comm _ (a' ⨳ c), nadd_lt_nadd_iff_left, nadd_left_comm, nadd_comm (a' ⨳ c'),\n      nadd_left_comm _ (a ⨳ c'), nadd_lt_nadd_iff_left, nadd_comm _ (a' ⨳ c'),\n      nadd_comm _ (a' ⨳ c'), nadd_left_comm, nadd_lt_nadd_iff_left] at this\ntermination_by (a, b, c)\n\n"}
{"name":"Ordinal.nadd_nmul","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u_1}\n⊢ Eq ((a.nadd b).nmul c) ((a.nmul c).nadd (b.nmul c))","decl":"theorem nadd_nmul (a b c) : (a ♯ b) ⨳ c = a ⨳ c ♯ b ⨳ c := by\n  rw [nmul_comm, nmul_nadd, nmul_comm, nmul_comm c]\n\n"}
{"name":"Ordinal.nmul_nadd_lt₃","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c a' b' c' : Ordinal.{u}\nha : LT.lt a' a\nhb : LT.lt b' b\nhc : LT.lt c' c\n⊢ LT.lt (((((a'.nmul b).nmul c).nadd ((a.nmul b').nmul c)).nadd ((a.nmul b).nmul c')).nadd ((a'.nmul b').nmul c')) (((((a.nmul b).nmul c).nadd ((a'.nmul b').nmul c)).nadd ((a'.nmul b).nmul c')).nadd ((a.nmul b').nmul c'))","decl":"theorem nmul_nadd_lt₃ {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :\n    a' ⨳ b ⨳ c ♯ a ⨳ b' ⨳ c ♯ a ⨳ b ⨳ c' ♯ a' ⨳ b' ⨳ c' <\n      a ⨳ b ⨳ c ♯ a' ⨳ b' ⨳ c ♯ a' ⨳ b ⨳ c' ♯ a ⨳ b' ⨳ c' := by\n  simpa only [nadd_nmul, ← nadd_assoc] using nmul_nadd_lt (nmul_nadd_lt ha hb) hc\n\n"}
{"name":"Ordinal.nmul_nadd_le₃","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c a' b' c' : Ordinal.{u}\nha : LE.le a' a\nhb : LE.le b' b\nhc : LE.le c' c\n⊢ LE.le (((((a'.nmul b).nmul c).nadd ((a.nmul b').nmul c)).nadd ((a.nmul b).nmul c')).nadd ((a'.nmul b').nmul c')) (((((a.nmul b).nmul c).nadd ((a'.nmul b').nmul c)).nadd ((a'.nmul b).nmul c')).nadd ((a.nmul b').nmul c'))","decl":"theorem nmul_nadd_le₃ {a' b' c' : Ordinal} (ha : a' ≤ a) (hb : b' ≤ b) (hc : c' ≤ c) :\n    a' ⨳ b ⨳ c ♯ a ⨳ b' ⨳ c ♯ a ⨳ b ⨳ c' ♯ a' ⨳ b' ⨳ c' ≤\n      a ⨳ b ⨳ c ♯ a' ⨳ b' ⨳ c ♯ a' ⨳ b ⨳ c' ♯ a ⨳ b' ⨳ c' := by\n  simpa only [nadd_nmul, ← nadd_assoc] using nmul_nadd_le (nmul_nadd_le ha hb) hc\n\n"}
{"name":"Ordinal.nmul_nadd_le₃'","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c a' b' c' : Ordinal.{u}\nha : LE.le a' a\nhb : LE.le b' b\nhc : LE.le c' c\n⊢ LE.le ((((a'.nmul (b.nmul c)).nadd (a.nmul (b'.nmul c))).nadd (a.nmul (b.nmul c'))).nadd (a'.nmul (b'.nmul c'))) ((((a.nmul (b.nmul c)).nadd (a'.nmul (b'.nmul c))).nadd (a'.nmul (b.nmul c'))).nadd (a.nmul (b'.nmul c')))","decl":"@[deprecated nmul_nadd_le₃ (since := \"2024-11-19\")]\ntheorem nmul_nadd_le₃' {a' b' c' : Ordinal} (ha : a' ≤ a) (hb : b' ≤ b) (hc : c' ≤ c) :\n    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') ≤\n      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by\n  simp only [nmul_comm _ (_ ⨳ _)]\n  convert nmul_nadd_le₃ hb hc ha using 1 <;>\n    (simp only [nadd_eq_add, NatOrdinal.toOrdinal_toNatOrdinal]; abel_nf)\n\n"}
{"name":"Ordinal.lt_nmul_iff₃","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c d : Ordinal.{u}\n⊢ Iff (LT.lt d ((a.nmul b).nmul c)) (Exists fun a' => And (LT.lt a' a) (Exists fun b' => And (LT.lt b' b) (Exists fun c' => And (LT.lt c' c) (LE.le (((d.nadd ((a'.nmul b').nmul c)).nadd ((a'.nmul b).nmul c')).nadd ((a.nmul b').nmul c')) (((((a'.nmul b).nmul c).nadd ((a.nmul b').nmul c)).nadd ((a.nmul b).nmul c')).nadd ((a'.nmul b').nmul c'))))))","decl":"theorem lt_nmul_iff₃ : d < a ⨳ b ⨳ c ↔ ∃ a' < a, ∃ b' < b, ∃ c' < c,\n    d ♯ a' ⨳ b' ⨳ c ♯ a' ⨳ b ⨳ c' ♯ a ⨳ b' ⨳ c' ≤\n      a' ⨳ b ⨳ c ♯ a ⨳ b' ⨳ c ♯ a ⨳ b ⨳ c' ♯ a' ⨳ b' ⨳ c' := by\n  refine ⟨fun h ↦ ?_, fun ⟨a', ha, b', hb, c', hc, h⟩ ↦ ?_⟩\n  · rcases lt_nmul_iff.1 h with ⟨e, he, c', hc, H₁⟩\n    rcases lt_nmul_iff.1 he with ⟨a', ha, b', hb, H₂⟩\n    refine ⟨a', ha, b', hb, c', hc, ?_⟩\n    have := nadd_le_nadd H₁ (nmul_nadd_le H₂ hc.le)\n    simp only [nadd_nmul, nadd_assoc] at this\n    rw [nadd_left_comm, nadd_left_comm d, nadd_left_comm, nadd_le_nadd_iff_left,\n      nadd_left_comm (a ⨳ b' ⨳ c), nadd_left_comm (a' ⨳ b ⨳ c), nadd_left_comm (a ⨳ b ⨳ c'),\n      nadd_le_nadd_iff_left, nadd_left_comm (a ⨳ b ⨳ c'), nadd_left_comm (a ⨳ b ⨳ c')] at this\n    simpa only [nadd_assoc]\n  · have := h.trans_lt (nmul_nadd_lt₃ ha hb hc)\n    repeat rw [nadd_lt_nadd_iff_right] at this\n    assumption\n\n"}
{"name":"Ordinal.nmul_le_iff₃","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c d : Ordinal.{u}\n⊢ Iff (LE.le ((a.nmul b).nmul c) d) (∀ (a' : Ordinal.{u}), LT.lt a' a → ∀ (b' : Ordinal.{u}), LT.lt b' b → ∀ (c' : Ordinal.{u}), LT.lt c' c → LT.lt (((((a'.nmul b).nmul c).nadd ((a.nmul b').nmul c)).nadd ((a.nmul b).nmul c')).nadd ((a'.nmul b').nmul c')) (((d.nadd ((a'.nmul b').nmul c)).nadd ((a'.nmul b).nmul c')).nadd ((a.nmul b').nmul c')))","decl":"theorem nmul_le_iff₃ : a ⨳ b ⨳ c ≤ d ↔ ∀ a' < a, ∀ b' < b, ∀ c' < c,\n    a' ⨳ b ⨳ c ♯ a ⨳ b' ⨳ c ♯ a ⨳ b ⨳ c' ♯ a' ⨳ b' ⨳ c' <\n      d ♯ a' ⨳ b' ⨳ c ♯ a' ⨳ b ⨳ c' ♯ a ⨳ b' ⨳ c' := by\n  simpa using lt_nmul_iff₃.not\n\n"}
{"name":"Ordinal.lt_nmul_iff₃'","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c d : Ordinal.{u}\n⊢ Iff (LT.lt d (a.nmul (b.nmul c))) (Exists fun a' => And (LT.lt a' a) (Exists fun b' => And (LT.lt b' b) (Exists fun c' => And (LT.lt c' c) (LE.le (((d.nadd (a'.nmul (b'.nmul c))).nadd (a'.nmul (b.nmul c'))).nadd (a.nmul (b'.nmul c'))) ((((a'.nmul (b.nmul c)).nadd (a.nmul (b'.nmul c))).nadd (a.nmul (b.nmul c'))).nadd (a'.nmul (b'.nmul c')))))))","decl":"@[deprecated lt_nmul_iff₃ (since := \"2024-11-19\")]\ntheorem lt_nmul_iff₃' : d < a ⨳ (b ⨳ c) ↔ ∃ a' < a, ∃ b' < b, ∃ c' < c,\n    d ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') ≤\n      a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') := by\n  simpa using nmul_le_iff₃'.not\n\n"}
{"name":"Ordinal.nmul_assoc","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b c : Ordinal.{u_1}\n⊢ Eq ((a.nmul b).nmul c) (a.nmul (b.nmul c))","decl":"theorem nmul_assoc (a b c : Ordinal) : a ⨳ b ⨳ c = a ⨳ (b ⨳ c) := by\n  apply le_antisymm\n  · rw [nmul_le_iff₃]\n    intro a' ha b' hb c' hc\n    repeat rw [nmul_assoc]\n    exact nmul_nadd_lt₃' ha hb hc\n  · rw [nmul_le_iff₃']\n    intro a' ha b' hb c' hc\n    repeat rw [← nmul_assoc]\n    exact nmul_nadd_lt₃ ha hb hc\ntermination_by (a, b, c)\n\n"}
{"name":"Ordinal.nmul_eq_mul","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u_1}\n⊢ Eq (a.nmul b) (NatOrdinal.toOrdinal (HMul.hMul (Ordinal.toNatOrdinal a) (Ordinal.toNatOrdinal b)))","decl":"theorem nmul_eq_mul (a b) : a ⨳ b = toOrdinal (toNatOrdinal a * toNatOrdinal b) :=\n  rfl\n\n"}
{"name":"Ordinal.nmul_nadd_one","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u_1}\n⊢ Eq (a.nmul (b.nadd 1)) ((a.nmul b).nadd a)","decl":"theorem nmul_nadd_one : ∀ a b, a ⨳ (b ♯ 1) = a ⨳ b ♯ a :=\n  @mul_add_one NatOrdinal _ _ _\n\n"}
{"name":"Ordinal.nadd_one_nmul","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u_1}\n⊢ Eq ((a.nadd 1).nmul b) ((a.nmul b).nadd b)","decl":"theorem nadd_one_nmul : ∀ a b, (a ♯ 1) ⨳ b = a ⨳ b ♯ b :=\n  @add_one_mul NatOrdinal _ _ _\n\n"}
{"name":"Ordinal.nmul_succ","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u_1}\n⊢ Eq (a.nmul (Order.succ b)) ((a.nmul b).nadd a)","decl":"theorem nmul_succ (a b) : a ⨳ succ b = a ⨳ b ♯ a := by rw [← nadd_one, nmul_nadd_one]\n\n"}
{"name":"Ordinal.succ_nmul","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u_1}\n⊢ Eq ((Order.succ a).nmul b) ((a.nmul b).nadd b)","decl":"theorem succ_nmul (a b) : succ a ⨳ b = a ⨳ b ♯ b := by rw [← nadd_one, nadd_one_nmul]\n\n"}
{"name":"Ordinal.nmul_add_one","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u_1}\n⊢ Eq (a.nmul (HAdd.hAdd b 1)) ((a.nmul b).nadd a)","decl":"theorem nmul_add_one : ∀ a b, a ⨳ (b + 1) = a ⨳ b ♯ a :=\n  nmul_succ\n\n"}
{"name":"Ordinal.add_one_nmul","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u_1}\n⊢ Eq ((HAdd.hAdd a 1).nmul b) ((a.nmul b).nadd b)","decl":"theorem add_one_nmul : ∀ a b, (a + 1) ⨳ b = a ⨳ b ♯ b :=\n  succ_nmul\n\n"}
{"name":"Ordinal.mul_le_nmul","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u}\n⊢ LE.le (HMul.hMul a b) (a.nmul b)","decl":"theorem mul_le_nmul (a b : Ordinal.{u}) : a * b ≤ a ⨳ b := by\n  refine b.limitRecOn ?_ ?_ ?_\n  · simp\n  · intro c h\n    rw [mul_succ, nmul_succ]\n    exact (add_le_nadd _ a).trans (nadd_le_nadd_right h a)\n  · intro c hc H\n    rcases eq_zero_or_pos a with (rfl | ha)\n    · simp\n    · rw [(isNormal_mul_right ha).apply_of_isLimit hc, Ordinal.iSup_le_iff]\n      rintro ⟨i, hi⟩\n      exact (H i hi).trans (nmul_le_nmul_left hi.le a)\n\n"}
{"name":"NatOrdinal.mul_le_nmul","module":"Mathlib.SetTheory.Ordinal.NaturalOps","initialProofState":"a b : Ordinal.{u}\n⊢ LE.le (HMul.hMul a b) (a.nmul b)","decl":"@[deprecated mul_le_nmul (since := \"2024-08-20\")]\nalias _root_.NatOrdinal.mul_le_nmul := mul_le_nmul\n\n"}
