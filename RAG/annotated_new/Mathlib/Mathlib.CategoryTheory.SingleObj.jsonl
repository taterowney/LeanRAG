{"name":"CategoryTheory.SingleObj.id_as_one","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"M : Type u\ninst‚úù : Monoid M\nx : CategoryTheory.SingleObj M\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id x) 1","decl":"theorem id_as_one (x : SingleObj M) : ùüô x = 1 :=\n  rfl\n\n"}
{"name":"CategoryTheory.SingleObj.comp_as_mul","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"M : Type u\ninst‚úù : Monoid M\nx y z : CategoryTheory.SingleObj M\nf : Quiver.Hom x y\ng : Quiver.Hom y z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g) (HMul.hMul g f)","decl":"theorem comp_as_mul {x y z : SingleObj M} (f : x ‚ü∂ y) (g : y ‚ü∂ z) : f ‚â´ g = g * f :=\n  rfl\n\n"}
{"name":"CategoryTheory.SingleObj.inv_as_inv","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"G : Type u\ninst‚úù : Group G\nx y : CategoryTheory.SingleObj G\nf : Quiver.Hom x y\n‚ä¢ Eq (CategoryTheory.inv f) (Inv.inv f)","decl":"theorem inv_as_inv {x y : SingleObj G} (f : x ‚ü∂ y) : inv f = f‚Åª¬π := by\n  apply IsIso.inv_eq_of_hom_inv_id\n  rw [comp_as_mul, inv_mul_cancel, id_as_one]\n\n"}
{"name":"CategoryTheory.SingleObj.toEnd_def","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"M : Type u\ninst‚úù : Monoid M\nx : M\n‚ä¢ Eq ((CategoryTheory.SingleObj.toEnd M) x) x","decl":"theorem toEnd_def (x : M) : toEnd M x = x :=\n  rfl\n\n"}
{"name":"CategoryTheory.SingleObj.mapHom_id","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"M : Type u\ninst‚úù : Monoid M\n‚ä¢ Eq ((CategoryTheory.SingleObj.mapHom M M) (MonoidHom.id M)) (CategoryTheory.Functor.id (CategoryTheory.SingleObj M))","decl":"theorem mapHom_id : mapHom M M (MonoidHom.id M) = ùü≠ _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.SingleObj.mapHom_comp","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"M : Type u\ninst‚úù¬≤ : Monoid M\nN : Type v\ninst‚úù¬π : Monoid N\nf : MonoidHom M N\nP : Type w\ninst‚úù : Monoid P\ng : MonoidHom N P\n‚ä¢ Eq ((CategoryTheory.SingleObj.mapHom M P) (g.comp f)) (((CategoryTheory.SingleObj.mapHom M N) f).comp ((CategoryTheory.SingleObj.mapHom N P) g))","decl":"theorem mapHom_comp (f : M ‚Üí* N) {P : Type w} [Monoid P] (g : N ‚Üí* P) :\n    mapHom M P (g.comp f) = mapHom M N f ‚ãô mapHom N P g :=\n  rfl\n\n"}
{"name":"CategoryTheory.SingleObj.differenceFunctor_map","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"G : Type u\ninst‚úù¬π : Group G\nC : Type v\ninst‚úù : CategoryTheory.Category.{w, v} C\nf : C ‚Üí G\nx y : C\nx‚úù : Quiver.Hom x y\n‚ä¢ Eq ((CategoryTheory.SingleObj.differenceFunctor f).map x‚úù) (HMul.hMul (f y) (Inv.inv (f x)))","decl":"/-- Given a function `f : C ‚Üí G` from a category to a group, we get a functor\n    `C ‚•§ G` sending any morphism `x ‚ü∂ y` to `f y * (f x)‚Åª¬π`. -/\n@[simps]\ndef differenceFunctor (f : C ‚Üí G) : C ‚•§ SingleObj G where\n  obj _ := ()\n  map {x y} _ := f y * (f x)‚Åª¬π\n  map_id := by\n    intro\n    simp only [SingleObj.id_as_one, mul_inv_cancel]\n  map_comp := by\n    intros\n    dsimp\n    rw [SingleObj.comp_as_mul, ‚Üê mul_assoc, mul_left_inj, mul_assoc, inv_mul_cancel, mul_one]\n\n"}
{"name":"CategoryTheory.SingleObj.differenceFunctor_obj","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"G : Type u\ninst‚úù¬π : Group G\nC : Type v\ninst‚úù : CategoryTheory.Category.{w, v} C\nf : C ‚Üí G\nx‚úù : C\n‚ä¢ Eq ((CategoryTheory.SingleObj.differenceFunctor f).obj x‚úù) Unit.unit","decl":"/-- Given a function `f : C ‚Üí G` from a category to a group, we get a functor\n    `C ‚•§ G` sending any morphism `x ‚ü∂ y` to `f y * (f x)‚Åª¬π`. -/\n@[simps]\ndef differenceFunctor (f : C ‚Üí G) : C ‚•§ SingleObj G where\n  obj _ := ()\n  map {x y} _ := f y * (f x)‚Åª¬π\n  map_id := by\n    intro\n    simp only [SingleObj.id_as_one, mul_inv_cancel]\n  map_comp := by\n    intros\n    dsimp\n    rw [SingleObj.comp_as_mul, ‚Üê mul_assoc, mul_left_inj, mul_assoc, inv_mul_cancel, mul_one]\n\n"}
{"name":"CategoryTheory.SingleObj.functor_map","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"M : Type u\ninst‚úù¬π : Monoid M\nC : Type v\ninst‚úù : CategoryTheory.Category.{w, v} C\nX : C\nf : MonoidHom M (CategoryTheory.End X)\nX‚úù Y‚úù : CategoryTheory.SingleObj M\na : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.SingleObj.functor f).map a) (f a)","decl":"/-- A monoid homomorphism `f: M ‚Üí End X` into the endomorphisms of an object `X` of a category `C`\ninduces a functor `SingleObj M ‚•§ C`. -/\n@[simps]\ndef functor {X : C} (f : M ‚Üí* End X) : SingleObj M ‚•§ C where\n  obj _ := X\n  map a := f a\n  map_id _ := MonoidHom.map_one f\n  map_comp a b := MonoidHom.map_mul f b a\n\n"}
{"name":"CategoryTheory.SingleObj.functor_obj","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"M : Type u\ninst‚úù¬π : Monoid M\nC : Type v\ninst‚úù : CategoryTheory.Category.{w, v} C\nX : C\nf : MonoidHom M (CategoryTheory.End X)\nx‚úù : CategoryTheory.SingleObj M\n‚ä¢ Eq ((CategoryTheory.SingleObj.functor f).obj x‚úù) X","decl":"/-- A monoid homomorphism `f: M ‚Üí End X` into the endomorphisms of an object `X` of a category `C`\ninduces a functor `SingleObj M ‚•§ C`. -/\n@[simps]\ndef functor {X : C} (f : M ‚Üí* End X) : SingleObj M ‚•§ C where\n  obj _ := X\n  map a := f a\n  map_id _ := MonoidHom.map_one f\n  map_comp a b := MonoidHom.map_mul f b a\n\n"}
{"name":"CategoryTheory.SingleObj.natTrans_app","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"M : Type u\ninst‚úù¬π : Monoid M\nC : Type v\ninst‚úù : CategoryTheory.Category.{w, v} C\nF G : CategoryTheory.Functor (CategoryTheory.SingleObj M) C\nu : Quiver.Hom (F.obj (CategoryTheory.SingleObj.star M)) (G.obj (CategoryTheory.SingleObj.star M))\nh : ‚àÄ (a : M), Eq (CategoryTheory.CategoryStruct.comp (F.map a) u) (CategoryTheory.CategoryStruct.comp u (G.map a))\nx‚úù : CategoryTheory.SingleObj M\n‚ä¢ Eq ((CategoryTheory.SingleObj.natTrans u h).app x‚úù) u","decl":"/-- Construct a natural transformation between functors `SingleObj M ‚•§ C` by\ngiving a compatible morphism `SingleObj.star M`. -/\n@[simps]\ndef natTrans {F G : SingleObj M ‚•§ C} (u : F.obj (SingleObj.star M) ‚ü∂ G.obj (SingleObj.star M))\n    (h : ‚àÄ a : M, F.map a ‚â´ u = u ‚â´ G.map a) : F ‚ü∂ G where\n  app _ := u\n  naturality _ _ a := h a\n\n"}
{"name":"MonoidHom.comp_toFunctor","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"M : Type u\nN : Type v\ninst‚úù¬≤ : Monoid M\ninst‚úù¬π : Monoid N\nf : MonoidHom M N\nP : Type w\ninst‚úù : Monoid P\ng : MonoidHom N P\n‚ä¢ Eq (g.comp f).toFunctor (f.toFunctor.comp g.toFunctor)","decl":"@[simp]\ntheorem comp_toFunctor (f : M ‚Üí* N) {P : Type w} [Monoid P] (g : N ‚Üí* P) :\n    (g.comp f).toFunctor = f.toFunctor ‚ãô g.toFunctor :=\n  rfl\n\n"}
{"name":"MonoidHom.id_toFunctor","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"M : Type u\ninst‚úù : Monoid M\n‚ä¢ Eq (MonoidHom.id M).toFunctor (CategoryTheory.Functor.id (CategoryTheory.SingleObj M))","decl":"@[simp]\ntheorem id_toFunctor : (id M).toFunctor = ùü≠ _ :=\n  rfl\n\n"}
{"name":"MulEquiv.toSingleObjEquiv_unitIso_inv","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"M : Type u\nN : Type v\ninst‚úù¬π : Monoid M\ninst‚úù : Monoid N\ne : MulEquiv M N\n‚ä¢ Eq e.toSingleObjEquiv.unitIso.inv (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- Reinterpret a monoid isomorphism `f : M ‚âÉ* N` as an equivalence `SingleObj M ‚âå SingleObj N`. -/\n@[simps!]\ndef toSingleObjEquiv (e : M ‚âÉ* N) : SingleObj M ‚âå SingleObj N where\n  functor := e.toMonoidHom.toFunctor\n  inverse := e.symm.toMonoidHom.toFunctor\n  unitIso := eqToIso (by\n    rw [‚Üê MonoidHom.comp_toFunctor, ‚Üê MonoidHom.id_toFunctor]\n    congr 1\n    simp)\n  counitIso := eqToIso (by\n    rw [‚Üê MonoidHom.comp_toFunctor, ‚Üê MonoidHom.id_toFunctor]\n    congr 1\n    simp)\n\n"}
{"name":"MulEquiv.toSingleObjEquiv_inverse_obj","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"M : Type u\nN : Type v\ninst‚úù¬π : Monoid M\ninst‚úù : Monoid N\ne : MulEquiv M N\na : CategoryTheory.SingleObj N\n‚ä¢ Eq (e.toSingleObjEquiv.inverse.obj a) a","decl":"/-- Reinterpret a monoid isomorphism `f : M ‚âÉ* N` as an equivalence `SingleObj M ‚âå SingleObj N`. -/\n@[simps!]\ndef toSingleObjEquiv (e : M ‚âÉ* N) : SingleObj M ‚âå SingleObj N where\n  functor := e.toMonoidHom.toFunctor\n  inverse := e.symm.toMonoidHom.toFunctor\n  unitIso := eqToIso (by\n    rw [‚Üê MonoidHom.comp_toFunctor, ‚Üê MonoidHom.id_toFunctor]\n    congr 1\n    simp)\n  counitIso := eqToIso (by\n    rw [‚Üê MonoidHom.comp_toFunctor, ‚Üê MonoidHom.id_toFunctor]\n    congr 1\n    simp)\n\n"}
{"name":"MulEquiv.toSingleObjEquiv_inverse_map","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"M : Type u\nN : Type v\ninst‚úù¬π : Monoid M\ninst‚úù : Monoid N\ne : MulEquiv M N\nX‚úù Y‚úù : CategoryTheory.SingleObj N\na : N\n‚ä¢ Eq (e.toSingleObjEquiv.inverse.map a) (e.symm a)","decl":"/-- Reinterpret a monoid isomorphism `f : M ‚âÉ* N` as an equivalence `SingleObj M ‚âå SingleObj N`. -/\n@[simps!]\ndef toSingleObjEquiv (e : M ‚âÉ* N) : SingleObj M ‚âå SingleObj N where\n  functor := e.toMonoidHom.toFunctor\n  inverse := e.symm.toMonoidHom.toFunctor\n  unitIso := eqToIso (by\n    rw [‚Üê MonoidHom.comp_toFunctor, ‚Üê MonoidHom.id_toFunctor]\n    congr 1\n    simp)\n  counitIso := eqToIso (by\n    rw [‚Üê MonoidHom.comp_toFunctor, ‚Üê MonoidHom.id_toFunctor]\n    congr 1\n    simp)\n\n"}
{"name":"MulEquiv.toSingleObjEquiv_unitIso_hom","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"M : Type u\nN : Type v\ninst‚úù¬π : Monoid M\ninst‚úù : Monoid N\ne : MulEquiv M N\n‚ä¢ Eq e.toSingleObjEquiv.unitIso.hom (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- Reinterpret a monoid isomorphism `f : M ‚âÉ* N` as an equivalence `SingleObj M ‚âå SingleObj N`. -/\n@[simps!]\ndef toSingleObjEquiv (e : M ‚âÉ* N) : SingleObj M ‚âå SingleObj N where\n  functor := e.toMonoidHom.toFunctor\n  inverse := e.symm.toMonoidHom.toFunctor\n  unitIso := eqToIso (by\n    rw [‚Üê MonoidHom.comp_toFunctor, ‚Üê MonoidHom.id_toFunctor]\n    congr 1\n    simp)\n  counitIso := eqToIso (by\n    rw [‚Üê MonoidHom.comp_toFunctor, ‚Üê MonoidHom.id_toFunctor]\n    congr 1\n    simp)\n\n"}
{"name":"MulEquiv.toSingleObjEquiv_counitIso_hom","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"M : Type u\nN : Type v\ninst‚úù¬π : Monoid M\ninst‚úù : Monoid N\ne : MulEquiv M N\n‚ä¢ Eq e.toSingleObjEquiv.counitIso.hom (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- Reinterpret a monoid isomorphism `f : M ‚âÉ* N` as an equivalence `SingleObj M ‚âå SingleObj N`. -/\n@[simps!]\ndef toSingleObjEquiv (e : M ‚âÉ* N) : SingleObj M ‚âå SingleObj N where\n  functor := e.toMonoidHom.toFunctor\n  inverse := e.symm.toMonoidHom.toFunctor\n  unitIso := eqToIso (by\n    rw [‚Üê MonoidHom.comp_toFunctor, ‚Üê MonoidHom.id_toFunctor]\n    congr 1\n    simp)\n  counitIso := eqToIso (by\n    rw [‚Üê MonoidHom.comp_toFunctor, ‚Üê MonoidHom.id_toFunctor]\n    congr 1\n    simp)\n\n"}
{"name":"MulEquiv.toSingleObjEquiv_functor_map","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"M : Type u\nN : Type v\ninst‚úù¬π : Monoid M\ninst‚úù : Monoid N\ne : MulEquiv M N\nX‚úù Y‚úù : CategoryTheory.SingleObj M\na : M\n‚ä¢ Eq (e.toSingleObjEquiv.functor.map a) (e a)","decl":"/-- Reinterpret a monoid isomorphism `f : M ‚âÉ* N` as an equivalence `SingleObj M ‚âå SingleObj N`. -/\n@[simps!]\ndef toSingleObjEquiv (e : M ‚âÉ* N) : SingleObj M ‚âå SingleObj N where\n  functor := e.toMonoidHom.toFunctor\n  inverse := e.symm.toMonoidHom.toFunctor\n  unitIso := eqToIso (by\n    rw [‚Üê MonoidHom.comp_toFunctor, ‚Üê MonoidHom.id_toFunctor]\n    congr 1\n    simp)\n  counitIso := eqToIso (by\n    rw [‚Üê MonoidHom.comp_toFunctor, ‚Üê MonoidHom.id_toFunctor]\n    congr 1\n    simp)\n\n"}
{"name":"MulEquiv.toSingleObjEquiv_functor_obj","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"M : Type u\nN : Type v\ninst‚úù¬π : Monoid M\ninst‚úù : Monoid N\ne : MulEquiv M N\na : CategoryTheory.SingleObj M\n‚ä¢ Eq (e.toSingleObjEquiv.functor.obj a) a","decl":"/-- Reinterpret a monoid isomorphism `f : M ‚âÉ* N` as an equivalence `SingleObj M ‚âå SingleObj N`. -/\n@[simps!]\ndef toSingleObjEquiv (e : M ‚âÉ* N) : SingleObj M ‚âå SingleObj N where\n  functor := e.toMonoidHom.toFunctor\n  inverse := e.symm.toMonoidHom.toFunctor\n  unitIso := eqToIso (by\n    rw [‚Üê MonoidHom.comp_toFunctor, ‚Üê MonoidHom.id_toFunctor]\n    congr 1\n    simp)\n  counitIso := eqToIso (by\n    rw [‚Üê MonoidHom.comp_toFunctor, ‚Üê MonoidHom.id_toFunctor]\n    congr 1\n    simp)\n\n"}
{"name":"MulEquiv.toSingleObjEquiv_counitIso_inv","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"M : Type u\nN : Type v\ninst‚úù¬π : Monoid M\ninst‚úù : Monoid N\ne : MulEquiv M N\n‚ä¢ Eq e.toSingleObjEquiv.counitIso.inv (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- Reinterpret a monoid isomorphism `f : M ‚âÉ* N` as an equivalence `SingleObj M ‚âå SingleObj N`. -/\n@[simps!]\ndef toSingleObjEquiv (e : M ‚âÉ* N) : SingleObj M ‚âå SingleObj N where\n  functor := e.toMonoidHom.toFunctor\n  inverse := e.symm.toMonoidHom.toFunctor\n  unitIso := eqToIso (by\n    rw [‚Üê MonoidHom.comp_toFunctor, ‚Üê MonoidHom.id_toFunctor]\n    congr 1\n    simp)\n  counitIso := eqToIso (by\n    rw [‚Üê MonoidHom.comp_toFunctor, ‚Üê MonoidHom.id_toFunctor]\n    congr 1\n    simp)\n\n"}
{"name":"Units.toAut_hom","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"M : Type u\ninst‚úù : Monoid M\nx : Units M\n‚ä¢ Eq ((Units.toAut M) x).hom ((CategoryTheory.SingleObj.toEnd M) ‚Üëx)","decl":"@[simp]\ntheorem toAut_hom (x : MÀ£) : (toAut M x).hom = SingleObj.toEnd M x :=\n  rfl\n\n"}
{"name":"Units.toAut_inv","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"M : Type u\ninst‚úù : Monoid M\nx : Units M\n‚ä¢ Eq ((Units.toAut M) x).inv ((CategoryTheory.SingleObj.toEnd M) ‚Üë(Inv.inv x))","decl":"@[simp]\ntheorem toAut_inv (x : MÀ£) : (toAut M x).inv = SingleObj.toEnd M (x‚Åª¬π : MÀ£) :=\n  rfl\n\n"}
{"name":"MonCat.toCat_full","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"‚ä¢ MonCat.toCat.Full","decl":"instance toCat_full : toCat.Full where\n  map_surjective y :=\n    let ‚ü®x, h‚ü© := (SingleObj.mapHom _ _).surjective y\n    ‚ü®ofHom x, h‚ü©\n\n"}
{"name":"MonCat.toCat_faithful","module":"Mathlib.CategoryTheory.SingleObj","initialProofState":"‚ä¢ MonCat.toCat.Faithful","decl":"instance toCat_faithful : toCat.Faithful where\n  map_injective h := MonCat.hom_ext <| by rwa [toCat, (SingleObj.mapHom _ _).apply_eq_iff_eq] at h\n\n"}
