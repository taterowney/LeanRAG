{"name":"Preorder.lt_iff_le_not_le","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_2\nself : Preorder α\na b : α\n⊢ Iff (LT.lt a b) (And (LE.le a b) (Not (LE.le b a)))","decl":"/-- A preorder is a reflexive, transitive relation `≤` with `a < b` defined in the obvious way. -/\nclass Preorder (α : Type*) extends LE α, LT α where\n  le_refl : ∀ a : α, a ≤ a\n  le_trans : ∀ a b c : α, a ≤ b → b ≤ c → a ≤ c\n  lt := fun a b => a ≤ b ∧ ¬b ≤ a\n  lt_iff_le_not_le : ∀ a b : α, a < b ↔ a ≤ b ∧ ¬b ≤ a := by intros; rfl\n\n"}
{"name":"Preorder.le_trans","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_2\nself : Preorder α\na b c : α\na✝¹ : LE.le a b\na✝ : LE.le b c\n⊢ LE.le a c","decl":"/-- A preorder is a reflexive, transitive relation `≤` with `a < b` defined in the obvious way. -/\nclass Preorder (α : Type*) extends LE α, LT α where\n  le_refl : ∀ a : α, a ≤ a\n  le_trans : ∀ a b c : α, a ≤ b → b ≤ c → a ≤ c\n  lt := fun a b => a ≤ b ∧ ¬b ≤ a\n  lt_iff_le_not_le : ∀ a b : α, a < b ↔ a ≤ b ∧ ¬b ≤ a := by intros; rfl\n\n"}
{"name":"Preorder.le_refl","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_2\nself : Preorder α\na : α\n⊢ LE.le a a","decl":"/-- A preorder is a reflexive, transitive relation `≤` with `a < b` defined in the obvious way. -/\nclass Preorder (α : Type*) extends LE α, LT α where\n  le_refl : ∀ a : α, a ≤ a\n  le_trans : ∀ a b c : α, a ≤ b → b ≤ c → a ≤ c\n  lt := fun a b => a ≤ b ∧ ¬b ≤ a\n  lt_iff_le_not_le : ∀ a b : α, a < b ↔ a ≤ b ∧ ¬b ≤ a := by intros; rfl\n\n"}
{"name":"le_refl","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ LE.le a a","decl":"/-- The relation `≤` on a preorder is reflexive. -/\n@[refl, simp] lemma le_refl : ∀ a : α, a ≤ a := Preorder.le_refl\n\n"}
{"name":"le_rfl","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ LE.le a a","decl":"/-- A version of `le_refl` where the argument is implicit -/\nlemma le_rfl : a ≤ a := le_refl a\n\n"}
{"name":"le_trans","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\na✝¹ : LE.le a b\na✝ : LE.le b c\n⊢ LE.le a c","decl":"/-- The relation `≤` on a preorder is transitive. -/\n@[trans] lemma le_trans : a ≤ b → b ≤ c → a ≤ c := Preorder.le_trans _ _ _\n\n"}
{"name":"lt_iff_le_not_le","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (LT.lt a b) (And (LE.le a b) (Not (LE.le b a)))","decl":"lemma lt_iff_le_not_le : a < b ↔ a ≤ b ∧ ¬b ≤ a := Preorder.lt_iff_le_not_le _ _\n\n"}
{"name":"lt_of_le_not_le","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nhab : LE.le a b\nhba : Not (LE.le b a)\n⊢ LT.lt a b","decl":"lemma lt_of_le_not_le (hab : a ≤ b) (hba : ¬ b ≤ a) : a < b := lt_iff_le_not_le.2 ⟨hab, hba⟩\n\n"}
{"name":"le_of_eq","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nhab : Eq a b\n⊢ LE.le a b","decl":"lemma le_of_eq (hab : a = b) : a ≤ b := by rw [hab]\n"}
{"name":"le_of_lt","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nhab : LT.lt a b\n⊢ LE.le a b","decl":"lemma le_of_lt (hab : a < b) : a ≤ b := (lt_iff_le_not_le.1 hab).1\n"}
{"name":"not_le_of_lt","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nhab : LT.lt a b\n⊢ Not (LE.le b a)","decl":"lemma not_le_of_lt (hab : a < b) : ¬ b ≤ a := (lt_iff_le_not_le.1 hab).2\n"}
{"name":"not_le_of_gt","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nhab : GT.gt a b\n⊢ Not (LE.le a b)","decl":"lemma not_le_of_gt (hab : a > b) : ¬a ≤ b := not_le_of_lt hab\n"}
{"name":"not_lt_of_le","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nhab : LE.le a b\n⊢ Not (LT.lt b a)","decl":"lemma not_lt_of_le (hab : a ≤ b) : ¬ b < a := imp_not_comm.1 not_le_of_lt hab\n"}
{"name":"not_lt_of_ge","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nhab : GE.ge a b\n⊢ Not (LT.lt a b)","decl":"lemma not_lt_of_ge (hab : a ≥ b) : ¬a < b := not_lt_of_le hab\n\n"}
{"name":"LT.lt.not_le","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nhab : LT.lt a b\n⊢ Not (LE.le b a)","decl":"alias LT.lt.not_le := not_le_of_lt\n"}
{"name":"LE.le.not_lt","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nhab : LE.le a b\n⊢ Not (LT.lt b a)","decl":"alias LE.le.not_lt := not_lt_of_le\n\n"}
{"name":"ge_trans","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\na✝¹ : GE.ge a b\na✝ : GE.ge b c\n⊢ GE.ge a c","decl":"@[trans] lemma ge_trans : a ≥ b → b ≥ c → a ≥ c := fun h₁ h₂ => le_trans h₂ h₁\n\n"}
{"name":"lt_irrefl","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Not (LT.lt a a)","decl":"lemma lt_irrefl (a : α) : ¬a < a := fun h ↦ not_le_of_lt h le_rfl\n"}
{"name":"gt_irrefl","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Not (GT.gt a a)","decl":"lemma gt_irrefl (a : α) : ¬a > a := lt_irrefl _\n\n"}
{"name":"lt_of_lt_of_le","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhab : LT.lt a b\nhbc : LE.le b c\n⊢ LT.lt a c","decl":"@[trans] lemma lt_of_lt_of_le (hab : a < b) (hbc : b ≤ c) : a < c :=\n  lt_of_le_not_le (le_trans (le_of_lt hab) hbc) fun hca ↦ not_le_of_lt hab (le_trans hbc hca)\n\n"}
{"name":"lt_of_le_of_lt","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhab : LE.le a b\nhbc : LT.lt b c\n⊢ LT.lt a c","decl":"@[trans] lemma lt_of_le_of_lt (hab : a ≤ b) (hbc : b < c) : a < c :=\n  lt_of_le_not_le (le_trans hab (le_of_lt hbc)) fun hca ↦ not_le_of_lt hbc (le_trans hca hab)\n\n"}
{"name":"gt_of_gt_of_ge","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nh₁ : GT.gt a b\nh₂ : GE.ge b c\n⊢ GT.gt a c","decl":"@[trans] lemma gt_of_gt_of_ge (h₁ : a > b) (h₂ : b ≥ c) : a > c := lt_of_le_of_lt h₂ h₁\n"}
{"name":"gt_of_ge_of_gt","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nh₁ : GE.ge a b\nh₂ : GT.gt b c\n⊢ GT.gt a c","decl":"@[trans] lemma gt_of_ge_of_gt (h₁ : a ≥ b) (h₂ : b > c) : a > c := lt_of_lt_of_le h₂ h₁\n\n"}
{"name":"lt_trans","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhab : LT.lt a b\nhbc : LT.lt b c\n⊢ LT.lt a c","decl":"@[trans] lemma lt_trans (hab : a < b) (hbc : b < c) : a < c := lt_of_lt_of_le hab (le_of_lt hbc)\n"}
{"name":"gt_trans","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\na✝¹ : GT.gt a b\na✝ : GT.gt b c\n⊢ GT.gt a c","decl":"@[trans] lemma gt_trans : a > b → b > c → a > c := fun h₁ h₂ => lt_trans h₂ h₁\n\n"}
{"name":"ne_of_lt","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LT.lt a b\n⊢ Ne a b","decl":"lemma ne_of_lt (h : a < b) : a ≠ b := fun he => absurd h (he ▸ lt_irrefl a)\n"}
{"name":"ne_of_gt","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LT.lt b a\n⊢ Ne a b","decl":"lemma ne_of_gt (h : b < a) : a ≠ b := fun he => absurd h (he ▸ lt_irrefl a)\n"}
{"name":"lt_asymm","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LT.lt a b\n⊢ Not (LT.lt b a)","decl":"lemma lt_asymm (h : a < b) : ¬b < a := fun h1 : b < a => lt_irrefl a (lt_trans h h1)\n\n"}
{"name":"not_lt_of_gt","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LT.lt a b\n⊢ Not (LT.lt b a)","decl":"alias not_lt_of_gt := lt_asymm\n"}
{"name":"not_lt_of_lt","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LT.lt a b\n⊢ Not (LT.lt b a)","decl":"alias not_lt_of_lt := lt_asymm\n\n"}
{"name":"le_of_lt_or_eq","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : Or (LT.lt a b) (Eq a b)\n⊢ LE.le a b","decl":"lemma le_of_lt_or_eq (h : a < b ∨ a = b) : a ≤ b := h.elim le_of_lt le_of_eq\n"}
{"name":"le_of_eq_or_lt","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : Or (Eq a b) (LT.lt a b)\n⊢ LE.le a b","decl":"lemma le_of_eq_or_lt (h : a = b ∨ a < b) : a ≤ b := h.elim le_of_eq le_of_lt\n\n"}
{"name":"PartialOrder.le_antisymm","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_2\nself : PartialOrder α\na b : α\na✝¹ : LE.le a b\na✝ : LE.le b a\n⊢ Eq a b","decl":"/-- A partial order is a reflexive, transitive, antisymmetric relation `≤`. -/\nclass PartialOrder (α : Type*) extends Preorder α where\n  le_antisymm : ∀ a b : α, a ≤ b → b ≤ a → a = b\n\n"}
{"name":"le_antisymm","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\na✝¹ : LE.le a b\na✝ : LE.le b a\n⊢ Eq a b","decl":"lemma le_antisymm : a ≤ b → b ≤ a → a = b := PartialOrder.le_antisymm _ _\n\n"}
{"name":"eq_of_le_of_le","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\na✝¹ : LE.le a b\na✝ : LE.le b a\n⊢ Eq a b","decl":"alias eq_of_le_of_le := le_antisymm\n\n"}
{"name":"le_antisymm_iff","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Iff (Eq a b) (And (LE.le a b) (LE.le b a))","decl":"lemma le_antisymm_iff : a = b ↔ a ≤ b ∧ b ≤ a :=\n  ⟨fun e => ⟨le_of_eq e, le_of_eq e.symm⟩, fun ⟨h1, h2⟩ => le_antisymm h1 h2⟩\n\n"}
{"name":"lt_of_le_of_ne","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\na✝¹ : LE.le a b\na✝ : Ne a b\n⊢ LT.lt a b","decl":"lemma lt_of_le_of_ne : a ≤ b → a ≠ b → a < b := fun h₁ h₂ =>\n  lt_of_le_not_le h₁ <| mt (le_antisymm h₁) h₂\n\n"}
{"name":"Decidable.lt_or_eq_of_le","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\na b : α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nhab : LE.le a b\n⊢ Or (LT.lt a b) (Eq a b)","decl":"lemma lt_or_eq_of_le (hab : a ≤ b) : a < b ∨ a = b :=\n  if hba : b ≤ a then Or.inr (le_antisymm hab hba) else Or.inl (lt_of_le_not_le hab hba)\n\n"}
{"name":"Decidable.eq_or_lt_of_le","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\na b : α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nhab : LE.le a b\n⊢ Or (Eq a b) (LT.lt a b)","decl":"lemma eq_or_lt_of_le (hab : a ≤ b) : a = b ∨ a < b :=\n  (lt_or_eq_of_le hab).symm\n\n"}
{"name":"Decidable.le_iff_lt_or_eq","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\na b : α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\n⊢ Iff (LE.le a b) (Or (LT.lt a b) (Eq a b))","decl":"lemma le_iff_lt_or_eq : a ≤ b ↔ a < b ∨ a = b :=\n  ⟨lt_or_eq_of_le, le_of_lt_or_eq⟩\n\n"}
{"name":"lt_or_eq_of_le","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\na✝ : LE.le a b\n⊢ Or (LT.lt a b) (Eq a b)","decl":"lemma lt_or_eq_of_le : a ≤ b → a < b ∨ a = b := Decidable.lt_or_eq_of_le\n"}
{"name":"le_iff_lt_or_eq","module":"Mathlib.Order.Defs.PartialOrder","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Iff (LE.le a b) (Or (LT.lt a b) (Eq a b))","decl":"lemma le_iff_lt_or_eq : a ≤ b ↔ a < b ∨ a = b := Decidable.le_iff_lt_or_eq\n\n"}
