{"name":"LinearMap.charpoly_toMatrix","module":"Mathlib.LinearAlgebra.Charpoly.ToMatrix","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁷ : CommRing R\ninst✝⁶ : Nontrivial R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : Module.Free R M\ninst✝² : Module.Finite R M\nf : LinearMap (RingHom.id R) M M\nι : Type w\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nb : Basis ι R M\n⊢ Eq ((LinearMap.toMatrix b b) f).charpoly f.charpoly","decl":"/-- `charpoly f` is the characteristic polynomial of the matrix of `f` in any basis. -/\n@[simp]\ntheorem charpoly_toMatrix {ι : Type w} [DecidableEq ι] [Fintype ι] (b : Basis ι R M) :\n    (toMatrix b b f).charpoly = f.charpoly := by\n  let A := toMatrix b b f\n  let b' := chooseBasis R M\n  let ι' := ChooseBasisIndex R M\n  let A' := toMatrix b' b' f\n  let e := Basis.indexEquiv b b'\n  let φ := reindexLinearEquiv R R e e\n  let φ₁ := reindexLinearEquiv R R e (Equiv.refl ι')\n  let φ₂ := reindexLinearEquiv R R (Equiv.refl ι') (Equiv.refl ι')\n  let φ₃ := reindexLinearEquiv R R (Equiv.refl ι') e\n  let P := b.toMatrix b'\n  let Q := b'.toMatrix b\n  have hPQ : C.mapMatrix (φ₁ P) * C.mapMatrix (φ₃ Q) = 1 := by\n    rw [RingHom.mapMatrix_apply, RingHom.mapMatrix_apply, ← Matrix.map_mul,\n      reindexLinearEquiv_mul R R, Basis.toMatrix_mul_toMatrix_flip,\n      reindexLinearEquiv_one, ← RingHom.mapMatrix_apply, RingHom.map_one]\n  calc\n    A.charpoly = (reindex e e A).charpoly := (charpoly_reindex _ _).symm\n    _ = det (scalar ι' X - C.mapMatrix (φ A)) := rfl\n    _ = det (scalar ι' X - C.mapMatrix (φ (P * A' * Q))) := by\n      rw [basis_toMatrix_mul_linearMap_toMatrix_mul_basis_toMatrix]\n    _ = det (scalar ι' X - C.mapMatrix (φ₁ P * φ₂ A' * φ₃ Q)) := by\n      rw [reindexLinearEquiv_mul, reindexLinearEquiv_mul]\n    _ = det (scalar ι' X - C.mapMatrix (φ₁ P) * C.mapMatrix A' * C.mapMatrix (φ₃ Q)) := by\n      simp [φ₁, φ₂, φ₃, ι']\n    _ = det (scalar ι' X * C.mapMatrix (φ₁ P) * C.mapMatrix (φ₃ Q) -\n          C.mapMatrix (φ₁ P) * C.mapMatrix A' * C.mapMatrix (φ₃ Q)) := by\n      rw [Matrix.mul_assoc ((scalar ι') X), hPQ, Matrix.mul_one]\n    _ = det (C.mapMatrix (φ₁ P) * scalar ι' X * C.mapMatrix (φ₃ Q) -\n          C.mapMatrix (φ₁ P) * C.mapMatrix A' * C.mapMatrix (φ₃ Q)) := by\n      rw [scalar_commute _ commute_X]\n    _ = det (C.mapMatrix (φ₁ P) * (scalar ι' X - C.mapMatrix A') * C.mapMatrix (φ₃ Q)) := by\n      rw [← Matrix.sub_mul, ← Matrix.mul_sub]\n    _ = det (C.mapMatrix (φ₁ P)) * det (scalar ι' X - C.mapMatrix A') * det (C.mapMatrix (φ₃ Q)) :=\n      by rw [det_mul, det_mul]\n    _ = det (C.mapMatrix (φ₁ P)) * det (C.mapMatrix (φ₃ Q)) * det (scalar ι' X - C.mapMatrix A') :=\n      by ring\n    _ = det (scalar ι' X - C.mapMatrix A') := by\n      rw [← det_mul, hPQ, det_one, one_mul]\n    _ = f.charpoly := rfl\n\n"}
{"name":"LinearMap.charpoly_prodMap","module":"Mathlib.LinearAlgebra.Charpoly.ToMatrix","initialProofState":"R : Type u_1\nM₁ : Type u_3\nM₂ : Type u_4\ninst✝⁹ : CommRing R\ninst✝⁸ : Nontrivial R\ninst✝⁷ : AddCommGroup M₁\ninst✝⁶ : Module R M₁\ninst✝⁵ : Module.Finite R M₁\ninst✝⁴ : Module.Free R M₁\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : Module.Finite R M₂\ninst✝ : Module.Free R M₂\nf₁ : LinearMap (RingHom.id R) M₁ M₁\nf₂ : LinearMap (RingHom.id R) M₂ M₂\n⊢ Eq (f₁.prodMap f₂).charpoly (HMul.hMul f₁.charpoly f₂.charpoly)","decl":"lemma charpoly_prodMap (f₁ : M₁ →ₗ[R] M₁) (f₂ : M₂ →ₗ[R] M₂) :\n    (f₁.prodMap f₂).charpoly = f₁.charpoly * f₂.charpoly := by\n  let b₁ := chooseBasis R M₁\n  let b₂ := chooseBasis R M₂\n  let b := b₁.prod b₂\n  rw [← charpoly_toMatrix f₁ b₁, ← charpoly_toMatrix f₂ b₂, ← charpoly_toMatrix (f₁.prodMap f₂) b,\n    toMatrix_prodMap b₁ b₂ f₁ f₂, Matrix.charpoly_fromBlocks_zero₁₂]\n\n"}
{"name":"LinearEquiv.charpoly_conj","module":"Mathlib.LinearAlgebra.Charpoly.ToMatrix","initialProofState":"R : Type u_1\nM₁ : Type u_3\nM₂ : Type u_4\ninst✝⁹ : CommRing R\ninst✝⁸ : Nontrivial R\ninst✝⁷ : AddCommGroup M₁\ninst✝⁶ : Module R M₁\ninst✝⁵ : Module.Finite R M₁\ninst✝⁴ : Module.Free R M₁\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : Module.Finite R M₂\ninst✝ : Module.Free R M₂\ne : LinearEquiv (RingHom.id R) M₁ M₂\nφ : Module.End R M₁\n⊢ Eq (LinearMap.charpoly (e.conj φ)) (LinearMap.charpoly φ)","decl":"@[simp]\nlemma LinearEquiv.charpoly_conj (e : M₁ ≃ₗ[R] M₂) (φ : Module.End R M₁) :\n    (e.conj φ).charpoly = φ.charpoly := by\n  let b := chooseBasis R M₁\n  rw [← LinearMap.charpoly_toMatrix φ b, ← LinearMap.charpoly_toMatrix (e.conj φ) (b.map e)]\n  congr 1\n  ext i j : 1\n  simp [Matrix.charmatrix, LinearMap.toMatrix, Matrix.diagonal, LinearEquiv.conj_apply]\n"}
