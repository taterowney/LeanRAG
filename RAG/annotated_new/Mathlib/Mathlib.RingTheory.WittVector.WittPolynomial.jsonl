{"name":"wittPolynomial_eq_sum_C_mul_X_pow","module":"Mathlib.RingTheory.WittVector.WittPolynomial","initialProofState":"p : Nat\nR : Type u_1\ninst✝ : CommRing R\nn : Nat\n⊢ Eq (wittPolynomial p R n) ((Finset.range (HAdd.hAdd n 1)).sum fun i => HMul.hMul (MvPolynomial.C (HPow.hPow (↑p) i)) (HPow.hPow (MvPolynomial.X i) (HPow.hPow p (HSub.hSub n i))))","decl":"theorem wittPolynomial_eq_sum_C_mul_X_pow (n : ℕ) :\n    wittPolynomial p R n = ∑ i ∈ range (n + 1), C ((p : R) ^ i) * X i ^ p ^ (n - i) := by\n  apply sum_congr rfl\n  rintro i -\n  rw [monomial_eq, Finsupp.prod_single_index]\n  rw [pow_zero]\n\n"}
{"name":"map_wittPolynomial","module":"Mathlib.RingTheory.WittVector.WittPolynomial","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\nS : Type u_2\ninst✝ : CommRing S\nf : RingHom R S\nn : Nat\n⊢ Eq ((MvPolynomial.map f) (wittPolynomial p R n)) (wittPolynomial p S n)","decl":"@[simp]\ntheorem map_wittPolynomial (f : R →+* S) (n : ℕ) : map f (W n) = W n := by\n  rw [wittPolynomial, map_sum, wittPolynomial]\n  refine sum_congr rfl fun i _ => ?_\n  rw [map_monomial, RingHom.map_pow, map_natCast]\n\n"}
{"name":"constantCoeff_wittPolynomial","module":"Mathlib.RingTheory.WittVector.WittPolynomial","initialProofState":"p : Nat\nR : Type u_1\ninst✝ : CommRing R\nhp : Fact (Nat.Prime p)\nn : Nat\n⊢ Eq (MvPolynomial.constantCoeff (wittPolynomial p R n)) 0","decl":"@[simp]\ntheorem constantCoeff_wittPolynomial [hp : Fact p.Prime] (n : ℕ) :\n    constantCoeff (wittPolynomial p R n) = 0 := by\n  simp only [wittPolynomial, map_sum, constantCoeff_monomial]\n  rw [sum_eq_zero]\n  rintro i _\n  rw [if_neg]\n  rw [Finsupp.single_eq_zero]\n  exact ne_of_gt (pow_pos hp.1.pos _)\n\n"}
{"name":"wittPolynomial_zero","module":"Mathlib.RingTheory.WittVector.WittPolynomial","initialProofState":"p : Nat\nR : Type u_1\ninst✝ : CommRing R\n⊢ Eq (wittPolynomial p R 0) (MvPolynomial.X 0)","decl":"@[simp]\ntheorem wittPolynomial_zero : wittPolynomial p R 0 = X 0 := by\n  simp only [wittPolynomial, X, sum_singleton, range_one, pow_zero, zero_add, tsub_self]\n\n"}
{"name":"wittPolynomial_one","module":"Mathlib.RingTheory.WittVector.WittPolynomial","initialProofState":"p : Nat\nR : Type u_1\ninst✝ : CommRing R\n⊢ Eq (wittPolynomial p R 1) (HAdd.hAdd (HMul.hMul (MvPolynomial.C ↑p) (MvPolynomial.X 1)) (HPow.hPow (MvPolynomial.X 0) p))","decl":"@[simp]\ntheorem wittPolynomial_one : wittPolynomial p R 1 = C (p : R) * X 1 + X 0 ^ p := by\n  simp only [wittPolynomial_eq_sum_C_mul_X_pow, sum_range_succ_comm, range_one, sum_singleton,\n    one_mul, pow_one, C_1, pow_zero, tsub_self, tsub_zero]\n\n"}
{"name":"aeval_wittPolynomial","module":"Mathlib.RingTheory.WittVector.WittPolynomial","initialProofState":"p : Nat\nR : Type u_1\ninst✝² : CommRing R\nA : Type u_3\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nf : Nat → A\nn : Nat\n⊢ Eq ((MvPolynomial.aeval f) (wittPolynomial p R n)) ((Finset.range (HAdd.hAdd n 1)).sum fun i => HMul.hMul (HPow.hPow (↑p) i) (HPow.hPow (f i) (HPow.hPow p (HSub.hSub n i))))","decl":"theorem aeval_wittPolynomial {A : Type*} [CommRing A] [Algebra R A] (f : ℕ → A) (n : ℕ) :\n    aeval f (W_ R n) = ∑ i ∈ range (n + 1), (p : A) ^ i * f i ^ p ^ (n - i) := by\n  simp [wittPolynomial, map_sum, aeval_monomial, Finsupp.prod_single_index]\n\n"}
{"name":"wittPolynomial_zmod_self","module":"Mathlib.RingTheory.WittVector.WittPolynomial","initialProofState":"p n : Nat\n⊢ Eq (wittPolynomial p (ZMod (HPow.hPow p (HAdd.hAdd n 1))) (HAdd.hAdd n 1)) ((MvPolynomial.expand p) (wittPolynomial p (ZMod (HPow.hPow p (HAdd.hAdd n 1))) n))","decl":"/-- Over the ring `ZMod (p^(n+1))`, we produce the `n+1`st Witt polynomial\nby expanding the `n`th Witt polynomial by `p`. -/\n@[simp]\ntheorem wittPolynomial_zmod_self (n : ℕ) :\n    W_ (ZMod (p ^ (n + 1))) (n + 1) = expand p (W_ (ZMod (p ^ (n + 1))) n) := by\n  simp only [wittPolynomial_eq_sum_C_mul_X_pow]\n  rw [sum_range_succ, ← Nat.cast_pow, CharP.cast_eq_zero (ZMod (p ^ (n + 1))) (p ^ (n + 1)), C_0,\n    zero_mul, add_zero, map_sum, sum_congr rfl]\n  intro k hk\n  rw [map_mul (expand p), map_pow (expand p), expand_X, algHom_C, ← pow_mul, ← pow_succ']\n  congr\n  rw [mem_range] at hk\n  rw [add_comm, add_tsub_assoc_of_le (Nat.lt_succ_iff.mp hk), ← add_comm]\n\n"}
{"name":"wittPolynomial_vars","module":"Mathlib.RingTheory.WittVector.WittPolynomial","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\nhp : NeZero p\ninst✝ : CharZero R\nn : Nat\n⊢ Eq (wittPolynomial p R n).vars (Finset.range (HAdd.hAdd n 1))","decl":"theorem wittPolynomial_vars [CharZero R] (n : ℕ) : (wittPolynomial p R n).vars = range (n + 1) := by\n  have : ∀ i, (monomial (Finsupp.single i (p ^ (n - i))) ((p : R) ^ i)).vars = {i} := by\n    intro i\n    refine vars_monomial_single i (pow_ne_zero _ hp.1) ?_\n    rw [← Nat.cast_pow, Nat.cast_ne_zero]\n    exact pow_ne_zero i hp.1\n  rw [wittPolynomial, vars_sum_of_disjoint]\n  · simp only [this, biUnion_singleton_eq_self]\n  · simp only [this]\n    intro a b h\n    apply disjoint_singleton_left.mpr\n    rwa [mem_singleton]\n\n"}
{"name":"wittPolynomial_vars_subset","module":"Mathlib.RingTheory.WittVector.WittPolynomial","initialProofState":"p : Nat\nR : Type u_1\ninst✝ : CommRing R\nhp : NeZero p\nn : Nat\n⊢ HasSubset.Subset (wittPolynomial p R n).vars (Finset.range (HAdd.hAdd n 1))","decl":"theorem wittPolynomial_vars_subset (n : ℕ) : (wittPolynomial p R n).vars ⊆ range (n + 1) := by\n  rw [← map_wittPolynomial p (Int.castRingHom R), ← wittPolynomial_vars p ℤ]\n  apply vars_map\n\n"}
{"name":"xInTermsOfW_eq","module":"Mathlib.RingTheory.WittVector.WittPolynomial","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Invertible ↑p\nn : Nat\n⊢ Eq (xInTermsOfW p R n) (HMul.hMul (HSub.hSub (MvPolynomial.X n) ((Finset.range n).sum fun i => HMul.hMul (MvPolynomial.C (HPow.hPow (↑p) i)) (HPow.hPow (xInTermsOfW p R i) (HPow.hPow p (HSub.hSub n i))))) (MvPolynomial.C (HPow.hPow (Invertible.invOf ↑p) n)))","decl":"theorem xInTermsOfW_eq [Invertible (p : R)] {n : ℕ} : xInTermsOfW p R n =\n    (X n - ∑ i ∈ range n, C ((p : R) ^ i) *\n      xInTermsOfW p R i ^ p ^ (n - i)) * C ((⅟p : R) ^ n) := by\n  rw [xInTermsOfW, ← Fin.sum_univ_eq_sum_range]\n\n"}
{"name":"constantCoeff_xInTermsOfW","module":"Mathlib.RingTheory.WittVector.WittPolynomial","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\nhp : Fact (Nat.Prime p)\ninst✝ : Invertible ↑p\nn : Nat\n⊢ Eq (MvPolynomial.constantCoeff (xInTermsOfW p R n)) 0","decl":"@[simp]\ntheorem constantCoeff_xInTermsOfW [hp : Fact p.Prime] [Invertible (p : R)] (n : ℕ) :\n    constantCoeff (xInTermsOfW p R n) = 0 := by\n  induction n using Nat.strongRecOn with | ind n IH => ?_\n  rw [xInTermsOfW_eq, mul_comm, RingHom.map_mul, RingHom.map_sub, map_sum, constantCoeff_C,\n    constantCoeff_X, zero_sub, mul_neg, neg_eq_zero]\n  -- Porting note: here, we should be able to do `rw [sum_eq_zero]`, but the goal that\n  -- is created is not what we expect, and the sum is not replaced by zero...\n  -- is it a bug in `rw` tactic?\n  refine Eq.trans (?_ : _ = ((⅟↑p : R) ^ n)* 0) (mul_zero _)\n  congr 1\n  rw [sum_eq_zero]\n  intro m H\n  rw [mem_range] at H\n  simp only [RingHom.map_mul, RingHom.map_pow, map_natCast, IH m H]\n  rw [zero_pow, mul_zero]\n  exact pow_ne_zero _ hp.1.ne_zero\n\n"}
{"name":"xInTermsOfW_zero","module":"Mathlib.RingTheory.WittVector.WittPolynomial","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Invertible ↑p\n⊢ Eq (xInTermsOfW p R 0) (MvPolynomial.X 0)","decl":"@[simp]\ntheorem xInTermsOfW_zero [Invertible (p : R)] : xInTermsOfW p R 0 = X 0 := by\n  rw [xInTermsOfW_eq, range_zero, sum_empty, pow_zero, C_1, mul_one, sub_zero]\n\n"}
{"name":"xInTermsOfW_vars_aux","module":"Mathlib.RingTheory.WittVector.WittPolynomial","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n⊢ And (Membership.mem (xInTermsOfW p Rat n).vars n) (HasSubset.Subset (xInTermsOfW p Rat n).vars (Finset.range (HAdd.hAdd n 1)))","decl":"theorem xInTermsOfW_vars_aux (n : ℕ) :\n    n ∈ (xInTermsOfW p ℚ n).vars ∧ (xInTermsOfW p ℚ n).vars ⊆ range (n + 1) := by\n  induction n using Nat.strongRecOn with | ind n ih => ?_\n  rw [xInTermsOfW_eq, mul_comm, vars_C_mul _ (Invertible.ne_zero _),\n    vars_sub_of_disjoint, vars_X, range_succ, insert_eq]\n  on_goal 1 =>\n    simp only [true_and, true_or, eq_self_iff_true, mem_union, mem_singleton]\n    intro i\n    rw [mem_union, mem_union]\n    apply Or.imp id\n  on_goal 2 => rw [vars_X, disjoint_singleton_left]\n  all_goals\n    intro H\n    replace H := vars_sum_subset _ _ H\n    rw [mem_biUnion] at H\n    rcases H with ⟨j, hj, H⟩\n    rw [vars_C_mul] at H\n    swap\n    · apply pow_ne_zero\n      exact mod_cast hp.1.ne_zero\n    rw [mem_range] at hj\n    replace H := (ih j hj).2 (vars_pow _ _ H)\n    rw [mem_range] at H\n  · rw [mem_range]\n    omega\n  · omega\n\n"}
{"name":"xInTermsOfW_vars_subset","module":"Mathlib.RingTheory.WittVector.WittPolynomial","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n⊢ HasSubset.Subset (xInTermsOfW p Rat n).vars (Finset.range (HAdd.hAdd n 1))","decl":"theorem xInTermsOfW_vars_subset (n : ℕ) : (xInTermsOfW p ℚ n).vars ⊆ range (n + 1) :=\n  (xInTermsOfW_vars_aux p n).2\n\n"}
{"name":"xInTermsOfW_aux","module":"Mathlib.RingTheory.WittVector.WittPolynomial","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Invertible ↑p\nn : Nat\n⊢ Eq (HMul.hMul (xInTermsOfW p R n) (MvPolynomial.C (HPow.hPow (↑p) n))) (HSub.hSub (MvPolynomial.X n) ((Finset.range n).sum fun i => HMul.hMul (MvPolynomial.C (HPow.hPow (↑p) i)) (HPow.hPow (xInTermsOfW p R i) (HPow.hPow p (HSub.hSub n i)))))","decl":"theorem xInTermsOfW_aux [Invertible (p : R)] (n : ℕ) :\n    xInTermsOfW p R n * C ((p : R) ^ n) =\n      X n - ∑ i ∈ range n, C ((p : R) ^ i) * xInTermsOfW p R i ^ p ^ (n - i) := by\n  rw [xInTermsOfW_eq, mul_assoc, ← C_mul, ← mul_pow, invOf_mul_self,\n    one_pow, C_1, mul_one]\n\n"}
{"name":"bind₁_xInTermsOfW_wittPolynomial","module":"Mathlib.RingTheory.WittVector.WittPolynomial","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Invertible ↑p\nk : Nat\n⊢ Eq ((MvPolynomial.bind₁ (xInTermsOfW p R)) (wittPolynomial p R k)) (MvPolynomial.X k)","decl":"@[simp]\ntheorem bind₁_xInTermsOfW_wittPolynomial [Invertible (p : R)] (k : ℕ) :\n    bind₁ (xInTermsOfW p R) (W_ R k) = X k := by\n  rw [wittPolynomial_eq_sum_C_mul_X_pow, map_sum]\n  simp only [Nat.cast_pow, map_pow, C_pow, map_mul, algHom_C, algebraMap_eq]\n  rw [sum_range_succ_comm, tsub_self, pow_zero, pow_one, bind₁_X_right, mul_comm, ← C_pow,\n    xInTermsOfW_aux]\n  simp only [Nat.cast_pow, C_pow, bind₁_X_right, sub_add_cancel]\n\n"}
{"name":"bind₁_wittPolynomial_xInTermsOfW","module":"Mathlib.RingTheory.WittVector.WittPolynomial","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Invertible ↑p\nn : Nat\n⊢ Eq ((MvPolynomial.bind₁ (wittPolynomial p R)) (xInTermsOfW p R n)) (MvPolynomial.X n)","decl":"@[simp]\ntheorem bind₁_wittPolynomial_xInTermsOfW [Invertible (p : R)] (n : ℕ) :\n    bind₁ (W_ R) (xInTermsOfW p R n) = X n := by\n  induction n using Nat.strongRecOn with | ind n H => ?_\n  rw [xInTermsOfW_eq, map_mul, map_sub, bind₁_X_right, algHom_C, map_sum,\n    show X n = (X n * C ((p : R) ^ n)) * C ((⅟p : R) ^ n) by\n      rw [mul_assoc, ← C_mul, ← mul_pow, mul_invOf_self, one_pow, map_one, mul_one]]\n  congr 1\n  rw [wittPolynomial_eq_sum_C_mul_X_pow, sum_range_succ_comm,\n    tsub_self, pow_zero, pow_one, mul_comm (X n), add_sub_assoc, add_right_eq_self, sub_eq_zero]\n  apply sum_congr rfl\n  intro i h\n  rw [mem_range] at h\n  rw [map_mul, map_pow (bind₁ _), algHom_C, H i h, algebraMap_eq]\n"}
