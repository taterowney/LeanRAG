{"name":"Basis.toMatrix_apply","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_5\nM : Type u_6\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ne : Basis ι R M\nv : ι' → M\ni : ι\nj : ι'\n⊢ Eq (e.toMatrix v i j) ((e.repr (v j)) i)","decl":"theorem toMatrix_apply : e.toMatrix v i j = e.repr (v j) i :=\n  rfl\n\n"}
{"name":"Basis.toMatrix_transpose_apply","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_5\nM : Type u_6\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ne : Basis ι R M\nv : ι' → M\nj : ι'\n⊢ Eq ((e.toMatrix v).transpose j) ⇑(e.repr (v j))","decl":"theorem toMatrix_transpose_apply : (e.toMatrix v)ᵀ j = e.repr (v j) :=\n  funext fun _ => rfl\n\n"}
{"name":"Basis.toMatrix_eq_toMatrix_constr","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nR : Type u_5\nM : Type u_6\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ne : Basis ι R M\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nv : ι → M\n⊢ Eq (e.toMatrix v) ((LinearMap.toMatrix e e) ((e.constr Nat) v))","decl":"theorem toMatrix_eq_toMatrix_constr [Fintype ι] [DecidableEq ι] (v : ι → M) :\n    e.toMatrix v = LinearMap.toMatrix e e (e.constr ℕ v) := by\n  ext\n  rw [Basis.toMatrix_apply, LinearMap.toMatrix_apply, Basis.constr_basis]\n\n-- TODO (maybe) Adjust the definition of `Basis.toMatrix` to eliminate the transpose.\n"}
{"name":"Basis.coePiBasisFun.toMatrix_eq_transpose","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nR : Type u_5\ninst✝¹ : CommSemiring R\ninst✝ : Finite ι\n⊢ Eq (Pi.basisFun R ι).toMatrix Matrix.transpose","decl":"theorem coePiBasisFun.toMatrix_eq_transpose [Finite ι] :\n    ((Pi.basisFun R ι).toMatrix : Matrix ι ι R → Matrix ι ι R) = Matrix.transpose := by\n  ext M i j\n  rfl\n\n"}
{"name":"Basis.toMatrix_self","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nR : Type u_5\nM : Type u_6\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ne : Basis ι R M\ninst✝ : DecidableEq ι\n⊢ Eq (e.toMatrix ⇑e) 1","decl":"@[simp]\ntheorem toMatrix_self [DecidableEq ι] : e.toMatrix e = 1 := by\n  unfold Basis.toMatrix\n  ext i j\n  simp [Basis.equivFun, Matrix.one_apply, Finsupp.single_apply, eq_comm]\n\n"}
{"name":"Basis.toMatrix_update","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_5\nM : Type u_6\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ne : Basis ι R M\nv : ι' → M\nj : ι'\ninst✝ : DecidableEq ι'\nx : M\n⊢ Eq (e.toMatrix (Function.update v j x)) ((e.toMatrix v).updateCol j ⇑(e.repr x))","decl":"theorem toMatrix_update [DecidableEq ι'] (x : M) :\n    e.toMatrix (Function.update v j x) = Matrix.updateCol (e.toMatrix v) j (e.repr x) := by\n  ext i' k\n  rw [Basis.toMatrix, Matrix.updateCol_apply, e.toMatrix_apply]\n  split_ifs with h\n  · rw [h, update_self j x v]\n  · rw [update_of_ne h]\n\n"}
{"name":"Basis.toMatrix_unitsSMul","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nR₂ : Type u_7\nM₂ : Type u_8\ninst✝³ : CommRing R₂\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R₂ M₂\ninst✝ : DecidableEq ι\ne : Basis ι R₂ M₂\nw : ι → Units R₂\n⊢ Eq (e.toMatrix ⇑(e.unitsSMul w)) (Matrix.diagonal (Function.comp Units.val w))","decl":"/-- The basis constructed by `unitsSMul` has vectors given by a diagonal matrix. -/\n@[simp]\ntheorem toMatrix_unitsSMul [DecidableEq ι] (e : Basis ι R₂ M₂) (w : ι → R₂ˣ) :\n    e.toMatrix (e.unitsSMul w) = diagonal ((↑) ∘ w) := by\n  ext i j\n  by_cases h : i = j\n  · simp [h, toMatrix_apply, unitsSMul_apply, Units.smul_def]\n  · simp [h, toMatrix_apply, unitsSMul_apply, Units.smul_def, Ne.symm h]\n\n"}
{"name":"Basis.toMatrix_isUnitSMul","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nR₂ : Type u_7\nM₂ : Type u_8\ninst✝³ : CommRing R₂\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R₂ M₂\ninst✝ : DecidableEq ι\ne : Basis ι R₂ M₂\nw : ι → R₂\nhw : ∀ (i : ι), IsUnit (w i)\n⊢ Eq (e.toMatrix ⇑(e.isUnitSMul hw)) (Matrix.diagonal w)","decl":"/-- The basis constructed by `isUnitSMul` has vectors given by a diagonal matrix. -/\n@[simp]\ntheorem toMatrix_isUnitSMul [DecidableEq ι] (e : Basis ι R₂ M₂) {w : ι → R₂}\n    (hw : ∀ i, IsUnit (w i)) : e.toMatrix (e.isUnitSMul hw) = diagonal w :=\n  e.toMatrix_unitsSMul _\n\n"}
{"name":"Basis.toMatrix_smul_left","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_5\nM : Type u_6\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ne : Basis ι R M\nv : ι' → M\nG : Type u_9\ninst✝² : Group G\ninst✝¹ : DistribMulAction G M\ninst✝ : SMulCommClass G R M\ng : G\n⊢ Eq ((HSMul.hSMul g e).toMatrix v) (e.toMatrix (HSMul.hSMul (Inv.inv g) v))","decl":"theorem toMatrix_smul_left {G} [Group G] [DistribMulAction G M] [SMulCommClass G R M] (g : G) :\n    (g • e).toMatrix v = e.toMatrix (g⁻¹ • v) := rfl\n\n"}
{"name":"Basis.sum_toMatrix_smul_self","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_5\nM : Type u_6\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ne : Basis ι R M\nv : ι' → M\nj : ι'\ninst✝ : Fintype ι\n⊢ Eq (Finset.univ.sum fun i => HSMul.hSMul (e.toMatrix v i j) (e i)) (v j)","decl":"@[simp]\ntheorem sum_toMatrix_smul_self [Fintype ι] : ∑ i : ι, e.toMatrix v i j • e i = v j := by\n  simp_rw [e.toMatrix_apply, e.sum_repr]\n\n"}
{"name":"Basis.toMatrix_smul","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nR₁ : Type u_9\nS : Type u_10\ninst✝⁴ : CommRing R₁\ninst✝³ : Ring S\ninst✝² : Algebra R₁ S\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nx : S\nb : Basis ι R₁ S\nw : ι → S\n⊢ Eq (b.toMatrix (HSMul.hSMul x w)) (HMul.hMul ((Algebra.leftMulMatrix b) x) (b.toMatrix w))","decl":"theorem toMatrix_smul {R₁ S : Type*} [CommRing R₁] [Ring S] [Algebra R₁ S] [Fintype ι]\n    [DecidableEq ι] (x : S) (b : Basis ι R₁ S) (w : ι → S) :\n    (b.toMatrix (x • w)) = (Algebra.leftMulMatrix b x) * (b.toMatrix w) := by\n  ext\n  rw [Basis.toMatrix_apply, Pi.smul_apply, smul_eq_mul, ← Algebra.leftMulMatrix_mulVec_repr]\n  rfl\n\n"}
{"name":"Basis.toMatrix_map_vecMul","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_5\ninst✝³ : CommSemiring R\nS : Type u_9\ninst✝² : Ring S\ninst✝¹ : Algebra R S\ninst✝ : Fintype ι\nb : Basis ι R S\nv : ι' → S\n⊢ Eq (Matrix.vecMul (⇑b) ((b.toMatrix v).map ⇑(algebraMap R S))) v","decl":"theorem toMatrix_map_vecMul {S : Type*} [Ring S] [Algebra R S] [Fintype ι] (b : Basis ι R S)\n    (v : ι' → S) : b ᵥ* ((b.toMatrix v).map <| algebraMap R S) = v := by\n  ext i\n  simp_rw [vecMul, dotProduct, Matrix.map_apply, ← Algebra.commutes, ← Algebra.smul_def,\n    sum_toMatrix_smul_self]\n\n"}
{"name":"Basis.toLin_toMatrix","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_5\nM : Type u_6\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ne : Basis ι R M\ninst✝² : Finite ι\ninst✝¹ : Fintype ι'\ninst✝ : DecidableEq ι'\nv : Basis ι' R M\n⊢ Eq ((Matrix.toLin v e) (e.toMatrix ⇑v)) LinearMap.id","decl":"@[simp]\ntheorem toLin_toMatrix [Finite ι] [Fintype ι'] [DecidableEq ι'] (v : Basis ι' R M) :\n    Matrix.toLin v e (e.toMatrix v) = LinearMap.id :=\n  v.ext fun i => by cases nonempty_fintype ι; rw [toLin_self, id_apply, e.sum_toMatrix_smul_self]\n\n"}
{"name":"Basis.restrictScalars_toMatrix","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nR₂ : Type u_7\nM₂ : Type u_8\ninst✝¹⁰ : CommRing R₂\ninst✝⁹ : AddCommGroup M₂\ninst✝⁸ : Module R₂ M₂\ninst✝⁷ : Fintype ι\ninst✝⁶ : DecidableEq ι\nS : Type u_9\ninst✝⁵ : CommRing S\ninst✝⁴ : Nontrivial S\ninst✝³ : Algebra R₂ S\ninst✝² : Module S M₂\ninst✝¹ : IsScalarTower R₂ S M₂\ninst✝ : NoZeroSMulDivisors R₂ S\nb : Basis ι S M₂\nv : ι → Subtype fun x => Membership.mem (Submodule.span R₂ (Set.range ⇑b)) x\n⊢ Eq ((algebraMap R₂ S).mapMatrix ((Basis.restrictScalars R₂ b).toMatrix v)) (b.toMatrix fun i => ↑(v i))","decl":"variable (R₂) in\ntheorem restrictScalars_toMatrix [Fintype ι] [DecidableEq ι] {S : Type*} [CommRing S] [Nontrivial S]\n    [Algebra R₂ S] [Module S M₂] [IsScalarTower R₂ S M₂] [NoZeroSMulDivisors R₂ S]\n    (b : Basis ι S M₂) (v : ι → span R₂ (Set.range b)) :\n    (algebraMap R₂ S).mapMatrix ((b.restrictScalars R₂).toMatrix v) =\n      b.toMatrix (fun i ↦ (v i : M₂)) := by\n  ext\n  rw [RingHom.mapMatrix_apply, Matrix.map_apply, Basis.toMatrix_apply,\n    Basis.restrictScalars_repr_apply, Basis.toMatrix_apply]\n\n"}
{"name":"LinearMap.toMatrix_id_eq_basis_toMatrix","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_5\nM : Type u_6\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nb : Basis ι R M\nb' : Basis ι' R M\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\ninst✝ : Finite ι'\n⊢ Eq ((LinearMap.toMatrix b b') LinearMap.id) (b'.toMatrix ⇑b)","decl":"/-- A generalization of `LinearMap.toMatrix_id`. -/\n@[simp]\ntheorem LinearMap.toMatrix_id_eq_basis_toMatrix [Fintype ι] [DecidableEq ι] [Finite ι'] :\n    LinearMap.toMatrix b b' id = b'.toMatrix b := by\n  ext i\n  apply LinearMap.toMatrix_apply\n\n"}
{"name":"basis_toMatrix_mul_linearMap_toMatrix","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι' : Type u_2\nκ : Type u_3\nκ' : Type u_4\nR : Type u_5\nM : Type u_6\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\nN : Type u_9\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\nb' : Basis ι' R M\nc : Basis κ R N\nc' : Basis κ' R N\nf : LinearMap (RingHom.id R) M N\ninst✝³ : Fintype ι'\ninst✝² : Finite κ\ninst✝¹ : Fintype κ'\ninst✝ : DecidableEq ι'\n⊢ Eq (HMul.hMul (c.toMatrix ⇑c') ((LinearMap.toMatrix b' c') f)) ((LinearMap.toMatrix b' c) f)","decl":"@[simp]\ntheorem basis_toMatrix_mul_linearMap_toMatrix [Finite κ] [Fintype κ'] [DecidableEq ι'] :\n    c.toMatrix c' * LinearMap.toMatrix b' c' f = LinearMap.toMatrix b' c f :=\n  (Matrix.toLin b' c).injective <| by\n    haveI := Classical.decEq κ'\n    rw [toLin_toMatrix, toLin_mul b' c' c, toLin_toMatrix, c.toLin_toMatrix, LinearMap.id_comp]\n\n"}
{"name":"basis_toMatrix_mul","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nκ : Type u_3\nR : Type u_5\nM : Type u_6\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\nN : Type u_9\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : Fintype ι'\ninst✝² : Fintype κ\ninst✝¹ : Finite ι\ninst✝ : DecidableEq κ\nb₁ : Basis ι R M\nb₂ : Basis ι' R M\nb₃ : Basis κ R N\nA : Matrix ι' κ R\n⊢ Eq (HMul.hMul (b₁.toMatrix ⇑b₂) A) ((LinearMap.toMatrix b₃ b₁) ((Matrix.toLin b₃ b₂) A))","decl":"theorem basis_toMatrix_mul [Fintype κ] [Finite ι] [DecidableEq κ]\n    (b₁ : Basis ι R M) (b₂ : Basis ι' R M) (b₃ : Basis κ R N) (A : Matrix ι' κ R) :\n    b₁.toMatrix b₂ * A = LinearMap.toMatrix b₃ b₁ (toLin b₃ b₂ A) := by\n  have := basis_toMatrix_mul_linearMap_toMatrix b₃ b₁ b₂ (Matrix.toLin b₃ b₂ A)\n  rwa [LinearMap.toMatrix_toLin] at this\n\n"}
{"name":"linearMap_toMatrix_mul_basis_toMatrix","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nκ' : Type u_4\nR : Type u_5\nM : Type u_6\ninst✝⁹ : CommSemiring R\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Module R M\nN : Type u_9\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : Module R N\nb : Basis ι R M\nb' : Basis ι' R M\nc' : Basis κ' R N\nf : LinearMap (RingHom.id R) M N\ninst✝⁴ : Fintype ι'\ninst✝³ : Fintype ι\ninst✝² : Finite κ'\ninst✝¹ : DecidableEq ι\ninst✝ : DecidableEq ι'\n⊢ Eq (HMul.hMul ((LinearMap.toMatrix b' c') f) (b'.toMatrix ⇑b)) ((LinearMap.toMatrix b c') f)","decl":"@[simp]\ntheorem linearMap_toMatrix_mul_basis_toMatrix [Finite κ'] [DecidableEq ι] [DecidableEq ι'] :\n    LinearMap.toMatrix b' c' f * b'.toMatrix b = LinearMap.toMatrix b c' f :=\n  (Matrix.toLin b c').injective <| by\n    rw [toLin_toMatrix, toLin_mul b b' c', toLin_toMatrix, b'.toLin_toMatrix, LinearMap.comp_id]\n\n"}
{"name":"basis_toMatrix_mul_linearMap_toMatrix_mul_basis_toMatrix","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nκ : Type u_3\nκ' : Type u_4\nR : Type u_5\nM : Type u_6\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\nN : Type u_9\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R N\nb : Basis ι R M\nb' : Basis ι' R M\nc : Basis κ R N\nc' : Basis κ' R N\nf : LinearMap (RingHom.id R) M N\ninst✝⁵ : Fintype ι'\ninst✝⁴ : Finite κ\ninst✝³ : Fintype ι\ninst✝² : Fintype κ'\ninst✝¹ : DecidableEq ι\ninst✝ : DecidableEq ι'\n⊢ Eq (HMul.hMul (HMul.hMul (c.toMatrix ⇑c') ((LinearMap.toMatrix b' c') f)) (b'.toMatrix ⇑b)) ((LinearMap.toMatrix b c) f)","decl":"theorem basis_toMatrix_mul_linearMap_toMatrix_mul_basis_toMatrix\n    [Fintype κ'] [DecidableEq ι] [DecidableEq ι'] :\n    c.toMatrix c' * LinearMap.toMatrix b' c' f * b'.toMatrix b = LinearMap.toMatrix b c f := by\n  cases nonempty_fintype κ\n  rw [basis_toMatrix_mul_linearMap_toMatrix, linearMap_toMatrix_mul_basis_toMatrix]\n\n"}
{"name":"mul_basis_toMatrix","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nκ : Type u_3\nR : Type u_5\nM : Type u_6\ninst✝⁹ : CommSemiring R\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Module R M\nN : Type u_9\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : Module R N\ninst✝⁴ : Fintype ι'\ninst✝³ : Finite κ\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\ninst✝ : DecidableEq ι'\nb₁ : Basis ι R M\nb₂ : Basis ι' R M\nb₃ : Basis κ R N\nA : Matrix κ ι R\n⊢ Eq (HMul.hMul A (b₁.toMatrix ⇑b₂)) ((LinearMap.toMatrix b₂ b₃) ((Matrix.toLin b₁ b₃) A))","decl":"theorem mul_basis_toMatrix [DecidableEq ι] [DecidableEq ι'] (b₁ : Basis ι R M) (b₂ : Basis ι' R M)\n    (b₃ : Basis κ R N) (A : Matrix κ ι R) :\n    A * b₁.toMatrix b₂ = LinearMap.toMatrix b₂ b₃ (toLin b₁ b₃ A) := by\n  cases nonempty_fintype κ\n  have := linearMap_toMatrix_mul_basis_toMatrix b₂ b₁ b₃ (Matrix.toLin b₁ b₃ A)\n  rwa [LinearMap.toMatrix_toLin] at this\n\n"}
{"name":"basis_toMatrix_basisFun_mul","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nR : Type u_5\ninst✝¹ : CommSemiring R\ninst✝ : Fintype ι\nb : Basis ι R (ι → R)\nA : Matrix ι ι R\n⊢ Eq (HMul.hMul (b.toMatrix ⇑(Pi.basisFun R ι)) A) (Matrix.of fun i j => (b.repr (A.transpose j)) i)","decl":"theorem basis_toMatrix_basisFun_mul (b : Basis ι R (ι → R)) (A : Matrix ι ι R) :\n    b.toMatrix (Pi.basisFun R ι) * A = of fun i j => b.repr (Aᵀ j) i := by\n  classical\n  simp only [basis_toMatrix_mul _ _ (Pi.basisFun R ι), Matrix.toLin_eq_toLin']\n  ext i j\n  rw [LinearMap.toMatrix_apply, Matrix.toLin'_apply, Pi.basisFun_apply,\n    Matrix.mulVec_single_one, Matrix.of_apply]\n\n"}
{"name":"Basis.toMatrix_reindex'","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_5\nM : Type u_6\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Fintype ι'\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\ninst✝ : DecidableEq ι'\nb : Basis ι R M\nv : ι' → M\ne : Equiv ι ι'\n⊢ Eq ((b.reindex e).toMatrix v) ((Matrix.reindexAlgEquiv R R e) (b.toMatrix (Function.comp v ⇑e)))","decl":"/-- See also `Basis.toMatrix_reindex` which gives the `simp` normal form of this result. -/\ntheorem Basis.toMatrix_reindex' [DecidableEq ι] [DecidableEq ι'] (b : Basis ι R M) (v : ι' → M)\n    (e : ι ≃ ι') : (b.reindex e).toMatrix v =\n    Matrix.reindexAlgEquiv R R e (b.toMatrix (v ∘ e)) := by\n  ext\n  simp only [Basis.toMatrix_apply, Basis.repr_reindex, Matrix.reindexAlgEquiv_apply,\n    Matrix.reindex_apply, Matrix.submatrix_apply, Function.comp_apply, e.apply_symm_apply,\n    Finsupp.mapDomain_equiv_apply]\n\n"}
{"name":"Basis.toMatrix_mulVec_repr","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_5\nM : Type u_6\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nb : Basis ι R M\nb' : Basis ι' R M\ninst✝¹ : Fintype ι'\ninst✝ : Fintype ι\nm : M\n⊢ Eq ((b'.toMatrix ⇑b).mulVec ⇑(b.repr m)) ⇑(b'.repr m)","decl":"@[simp]\nlemma Basis.toMatrix_mulVec_repr (m : M) :\n    b'.toMatrix b *ᵥ b.repr m = b'.repr m := by\n  classical\n  simp [← LinearMap.toMatrix_id_eq_basis_toMatrix, LinearMap.toMatrix_mulVec_repr]\n\n"}
{"name":"Basis.toMatrix_mul_toMatrix","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_5\nM : Type u_6\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nb : Basis ι R M\nb' : Basis ι' R M\nι'' : Type u_10\ninst✝ : Fintype ι'\nb'' : ι'' → M\n⊢ Eq (HMul.hMul (b.toMatrix ⇑b') (b'.toMatrix b'')) (b.toMatrix b'')","decl":"/-- A generalization of `Basis.toMatrix_self`, in the opposite direction. -/\n@[simp]\ntheorem Basis.toMatrix_mul_toMatrix {ι'' : Type*} [Fintype ι'] (b'' : ι'' → M) :\n    b.toMatrix b' * b'.toMatrix b'' = b.toMatrix b'' := by\n  haveI := Classical.decEq ι\n  haveI := Classical.decEq ι'\n  haveI := Classical.decEq ι''\n  ext i j\n  simp only [Matrix.mul_apply, Basis.toMatrix_apply, Basis.sum_repr_mul_repr]\n\n"}
{"name":"Basis.toMatrix_mul_toMatrix_flip","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_5\nM : Type u_6\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nb : Basis ι R M\nb' : Basis ι' R M\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι'\n⊢ Eq (HMul.hMul (b.toMatrix ⇑b') (b'.toMatrix ⇑b)) 1","decl":"/-- `b.toMatrix b'` and `b'.toMatrix b` are inverses. -/\ntheorem Basis.toMatrix_mul_toMatrix_flip [DecidableEq ι] [Fintype ι'] :\n    b.toMatrix b' * b'.toMatrix b = 1 := by rw [Basis.toMatrix_mul_toMatrix, Basis.toMatrix_self]\n\n"}
{"name":"Basis.toMatrix_reindex","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_5\nM : Type u_6\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nv : ι' → M\ne : Equiv ι ι'\n⊢ Eq ((b.reindex e).toMatrix v) ((b.toMatrix v).submatrix (⇑e.symm) id)","decl":"@[simp]\ntheorem Basis.toMatrix_reindex (b : Basis ι R M) (v : ι' → M) (e : ι ≃ ι') :\n    (b.reindex e).toMatrix v = (b.toMatrix v).submatrix e.symm _root_.id := by\n  ext\n  simp only [Basis.toMatrix_apply, Basis.repr_reindex, Matrix.submatrix_apply, _root_.id,\n    Finsupp.mapDomain_equiv_apply]\n\n"}
{"name":"Basis.toMatrix_map","module":"Mathlib.LinearAlgebra.Matrix.Basis","initialProofState":"ι : Type u_1\nR : Type u_5\nM : Type u_6\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_9\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nb : Basis ι R M\nf : LinearEquiv (RingHom.id R) M N\nv : ι → N\n⊢ Eq ((b.map f).toMatrix v) (b.toMatrix (Function.comp (⇑f.symm) v))","decl":"@[simp]\ntheorem Basis.toMatrix_map (b : Basis ι R M) (f : M ≃ₗ[R] N) (v : ι → N) :\n    (b.map f).toMatrix v = b.toMatrix (f.symm ∘ v) := by\n  ext\n  simp only [Basis.toMatrix_apply, Basis.map, LinearEquiv.trans_apply, (· ∘ ·)]\n\n"}
