{"name":"Ordinal.IsInitial.ord_card","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\nh : o.IsInitial\n⊢ Eq o.card.ord o","decl":"theorem IsInitial.ord_card {o : Ordinal} (h : IsInitial o) : o.card.ord = o := h\n\n"}
{"name":"Ordinal.IsInitial.card_le_card","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"a b : Ordinal.{u_1}\nha : a.IsInitial\n⊢ Iff (LE.le a.card b.card) (LE.le a b)","decl":"theorem IsInitial.card_le_card {a b : Ordinal} (ha : IsInitial a) : a.card ≤ b.card ↔ a ≤ b := by\n  refine ⟨fun h ↦ ?_, Ordinal.card_le_card⟩\n  rw [← ord_le_ord, ha.ord_card] at h\n  exact h.trans (ord_card_le b)\n\n"}
{"name":"Ordinal.IsInitial.card_lt_card","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"a b : Ordinal.{u_1}\nhb : b.IsInitial\n⊢ Iff (LT.lt a.card b.card) (LT.lt a b)","decl":"theorem IsInitial.card_lt_card {a b : Ordinal} (hb : IsInitial b) : a.card < b.card ↔ a < b :=\n  lt_iff_lt_of_le_iff_le hb.card_le_card\n\n"}
{"name":"Ordinal.isInitial_ord","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"c : Cardinal.{u_1}\n⊢ c.ord.IsInitial","decl":"theorem isInitial_ord (c : Cardinal) : IsInitial c.ord := by\n  rw [IsInitial, card_ord]\n\n"}
{"name":"Ordinal.isInitial_natCast","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"n : Nat\n⊢ (↑n).IsInitial","decl":"theorem isInitial_natCast (n : ℕ) : IsInitial n := by\n  rw [IsInitial, card_nat, ord_nat]\n\n"}
{"name":"Ordinal.isInitial_zero","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Ordinal.IsInitial 0","decl":"theorem isInitial_zero : IsInitial 0 := by\n  exact_mod_cast isInitial_natCast 0\n\n"}
{"name":"Ordinal.isInitial_one","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Ordinal.IsInitial 1","decl":"theorem isInitial_one : IsInitial 1 := by\n  exact_mod_cast isInitial_natCast 1\n\n"}
{"name":"Ordinal.isInitial_omega0","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Ordinal.omega0.IsInitial","decl":"theorem isInitial_omega0 : IsInitial ω := by\n  rw [IsInitial, card_omega0, ord_aleph0]\n\n"}
{"name":"Ordinal.not_bddAbove_isInitial","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Not (BddAbove (setOf fun x => x.IsInitial))","decl":"theorem not_bddAbove_isInitial : ¬ BddAbove {x | IsInitial x} := by\n  rintro ⟨a, ha⟩\n  have := ha (isInitial_ord (succ a.card))\n  rw [ord_le] at this\n  exact (lt_succ _).not_le this\n\n"}
{"name":"Ordinal.isInitialIso_apply","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"x : Subtype fun x => x.IsInitial\n⊢ Eq (Ordinal.isInitialIso x) (↑x).card","decl":"/-- Initial ordinals are order-isomorphic to the cardinals. -/\n@[simps!]\ndef isInitialIso : {x // IsInitial x} ≃o Cardinal where\n  toFun x := x.1.card\n  invFun x := ⟨x.ord, isInitial_ord _⟩\n  left_inv x := Subtype.ext x.2.ord_card\n  right_inv x := card_ord x\n  map_rel_iff' {a _} := a.2.card_le_card\n\n"}
{"name":"Ordinal.isInitialIso_symm_apply_coe","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"x : Cardinal.{u_1}\n⊢ Eq (↑((RelIso.symm Ordinal.isInitialIso) x)) x.ord","decl":"/-- Initial ordinals are order-isomorphic to the cardinals. -/\n@[simps!]\ndef isInitialIso : {x // IsInitial x} ≃o Cardinal where\n  toFun x := x.1.card\n  invFun x := ⟨x.ord, isInitial_ord _⟩\n  left_inv x := Subtype.ext x.2.ord_card\n  right_inv x := card_ord x\n  map_rel_iff' {a _} := a.2.card_le_card\n\n"}
{"name":"Ordinal.coe_preOmega","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Eq (⇑Ordinal.preOmega) (Ordinal.enumOrd (setOf fun x => x.IsInitial))","decl":"theorem coe_preOmega : preOmega = enumOrd {x | IsInitial x} :=\n  rfl\n\n"}
{"name":"Ordinal.preOmega_strictMono","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ StrictMono ⇑Ordinal.preOmega","decl":"theorem preOmega_strictMono : StrictMono preOmega :=\n  preOmega.strictMono\n\n"}
{"name":"Ordinal.preOmega_lt_preOmega","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Iff (LT.lt (Ordinal.preOmega o₁) (Ordinal.preOmega o₂)) (LT.lt o₁ o₂)","decl":"theorem preOmega_lt_preOmega {o₁ o₂ : Ordinal} : preOmega o₁ < preOmega o₂ ↔ o₁ < o₂ :=\n  preOmega.lt_iff_lt\n\n"}
{"name":"Ordinal.preOmega_le_preOmega","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Iff (LE.le (Ordinal.preOmega o₁) (Ordinal.preOmega o₂)) (LE.le o₁ o₂)","decl":"theorem preOmega_le_preOmega {o₁ o₂ : Ordinal} : preOmega o₁ ≤ preOmega o₂ ↔ o₁ ≤ o₂ :=\n  preOmega.le_iff_le\n\n"}
{"name":"Ordinal.preOmega_max","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Eq (Ordinal.preOmega (Max.max o₁ o₂)) (Max.max (Ordinal.preOmega o₁) (Ordinal.preOmega o₂))","decl":"theorem preOmega_max (o₁ o₂ : Ordinal) : preOmega (max o₁ o₂) = max (preOmega o₁) (preOmega o₂) :=\n  preOmega.monotone.map_max\n\n"}
{"name":"Ordinal.isInitial_preOmega","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ (Ordinal.preOmega o).IsInitial","decl":"theorem isInitial_preOmega (o : Ordinal) : IsInitial (preOmega o) :=\n  enumOrd_mem not_bddAbove_isInitial o\n\n"}
{"name":"Ordinal.le_preOmega_self","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ LE.le o (Ordinal.preOmega o)","decl":"theorem le_preOmega_self (o : Ordinal) : o ≤ preOmega o :=\n  preOmega_strictMono.le_apply\n\n"}
{"name":"Ordinal.preOmega_zero","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Eq (Ordinal.preOmega 0) 0","decl":"@[simp]\ntheorem preOmega_zero : preOmega 0 = 0 := by\n  rw [coe_preOmega, enumOrd_zero]\n  exact csInf_eq_bot_of_bot_mem isInitial_zero\n\n"}
{"name":"Ordinal.preOmega_natCast","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"n : Nat\n⊢ Eq (Ordinal.preOmega ↑n) ↑n","decl":"@[simp]\ntheorem preOmega_natCast (n : ℕ) : preOmega n = n := by\n  induction n with\n  | zero => exact preOmega_zero\n  | succ n IH =>\n    apply (le_preOmega_self _).antisymm'\n    apply enumOrd_succ_le not_bddAbove_isInitial (isInitial_natCast _) (IH.trans_lt _)\n    rw [Nat.cast_lt]\n    exact lt_succ n\n\n"}
{"name":"Ordinal.preOmega_ofNat","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Ordinal.preOmega (OfNat.ofNat n)) ↑n","decl":"@[simp]\ntheorem preOmega_ofNat (n : ℕ) [n.AtLeastTwo] : preOmega ofNat(n) = n :=\n  preOmega_natCast n\n\n"}
{"name":"Ordinal.preOmega_le_of_forall_lt","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o a : Ordinal.{u_1}\nha : a.IsInitial\nH : ∀ (b : Ordinal.{u_1}), LT.lt b o → LT.lt (Ordinal.preOmega b) a\n⊢ LE.le (Ordinal.preOmega o) a","decl":"theorem preOmega_le_of_forall_lt {o a : Ordinal} (ha : IsInitial a) (H : ∀ b < o, preOmega b < a) :\n    preOmega o ≤ a :=\n  enumOrd_le_of_forall_lt ha H\n\n"}
{"name":"Ordinal.isNormal_preOmega","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Ordinal.IsNormal ⇑Ordinal.preOmega","decl":"theorem isNormal_preOmega : IsNormal preOmega := by\n  rw [isNormal_iff_strictMono_limit]\n  refine ⟨preOmega_strictMono, fun o ho a ha ↦\n    (preOmega_le_of_forall_lt (isInitial_ord _) fun b hb ↦ ?_).trans (ord_card_le a)⟩\n  rw [← (isInitial_ord _).card_lt_card, card_ord]\n  apply lt_of_lt_of_le _ (card_le_card <| ha _ (ho.succ_lt hb))\n  rw [(isInitial_preOmega _).card_lt_card, preOmega_lt_preOmega]\n  exact lt_succ b\n\n"}
{"name":"Ordinal.range_preOmega","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Eq (Set.range ⇑Ordinal.preOmega) (setOf fun x => x.IsInitial)","decl":"@[simp]\ntheorem range_preOmega : range preOmega = {x | IsInitial x} :=\n  range_enumOrd not_bddAbove_isInitial\n\n"}
{"name":"Ordinal.mem_range_preOmega_iff","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"x : Ordinal.{u_1}\n⊢ Iff (Membership.mem (Set.range ⇑Ordinal.preOmega) x) x.IsInitial","decl":"theorem mem_range_preOmega_iff {x : Ordinal} : x ∈ range preOmega ↔ IsInitial x := by\n  rw [range_preOmega, mem_setOf]\n\n"}
{"name":"Ordinal.IsInitial.mem_range_preOmega","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"x : Ordinal.{u_1}\na✝ : x.IsInitial\n⊢ Membership.mem (Set.range ⇑Ordinal.preOmega) x","decl":"alias ⟨_, IsInitial.mem_range_preOmega⟩ := mem_range_preOmega_iff\n\n"}
{"name":"Ordinal.preOmega_omega0","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Eq (Ordinal.preOmega Ordinal.omega0) Ordinal.omega0","decl":"@[simp]\ntheorem preOmega_omega0 : preOmega ω = ω := by\n  simp_rw [← isNormal_preOmega.apply_omega0, preOmega_natCast, iSup_natCast]\n\n"}
{"name":"Ordinal.omega0_le_preOmega_iff","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"x : Ordinal.{u_1}\n⊢ Iff (LE.le Ordinal.omega0 (Ordinal.preOmega x)) (LE.le Ordinal.omega0 x)","decl":"@[simp]\ntheorem omega0_le_preOmega_iff {x : Ordinal} : ω ≤ preOmega x ↔ ω ≤ x := by\n  conv_lhs => rw [← preOmega_omega0, preOmega_le_preOmega]\n\n"}
{"name":"Ordinal.omega0_lt_preOmega_iff","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"x : Ordinal.{u_1}\n⊢ Iff (LT.lt Ordinal.omega0 (Ordinal.preOmega x)) (LT.lt Ordinal.omega0 x)","decl":"@[simp]\ntheorem omega0_lt_preOmega_iff {x : Ordinal} : ω < preOmega x ↔ ω < x := by\n  conv_lhs => rw [← preOmega_omega0, preOmega_lt_preOmega]\n\n"}
{"name":"Ordinal.omega_eq_preOmega","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Ordinal.omega o) (Ordinal.preOmega (HAdd.hAdd Ordinal.omega0 o))","decl":"theorem omega_eq_preOmega (o : Ordinal) : ω_ o = preOmega (ω + o) :=\n  rfl\n\n"}
{"name":"Ordinal.omega_strictMono","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ StrictMono ⇑Ordinal.omega","decl":"theorem omega_strictMono : StrictMono omega :=\n  omega.strictMono\n\n"}
{"name":"Ordinal.omega_lt_omega","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Iff (LT.lt (Ordinal.omega o₁) (Ordinal.omega o₂)) (LT.lt o₁ o₂)","decl":"theorem omega_lt_omega {o₁ o₂ : Ordinal} : ω_ o₁ < ω_ o₂ ↔ o₁ < o₂ :=\n  omega.lt_iff_lt\n\n"}
{"name":"Ordinal.omega_le_omega","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Iff (LE.le (Ordinal.omega o₁) (Ordinal.omega o₂)) (LE.le o₁ o₂)","decl":"theorem omega_le_omega {o₁ o₂ : Ordinal} : ω_ o₁ ≤ ω_ o₂ ↔ o₁ ≤ o₂ :=\n  omega.le_iff_le\n\n"}
{"name":"Ordinal.omega_max","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Eq (Ordinal.omega (Max.max o₁ o₂)) (Max.max (Ordinal.omega o₁) (Ordinal.omega o₂))","decl":"theorem omega_max (o₁ o₂ : Ordinal) : ω_ (max o₁ o₂) = max (ω_ o₁) (ω_ o₂) :=\n  omega.monotone.map_max\n\n"}
{"name":"Ordinal.preOmega_le_omega","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ LE.le (Ordinal.preOmega o) (Ordinal.omega o)","decl":"theorem preOmega_le_omega (o : Ordinal) : preOmega o ≤ ω_ o :=\n  preOmega_le_preOmega.2 (Ordinal.le_add_left _ _)\n\n"}
{"name":"Ordinal.isInitial_omega","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ (Ordinal.omega o).IsInitial","decl":"theorem isInitial_omega (o : Ordinal) : IsInitial (omega o) :=\n  isInitial_preOmega _\n\n"}
{"name":"Ordinal.le_omega_self","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ LE.le o (Ordinal.omega o)","decl":"theorem le_omega_self (o : Ordinal) : o ≤ omega o :=\n  omega_strictMono.le_apply\n\n"}
{"name":"Ordinal.omega_zero","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Eq (Ordinal.omega 0) Ordinal.omega0","decl":"@[simp]\ntheorem omega_zero : ω_ 0 = ω := by\n  rw [omega_eq_preOmega, add_zero, preOmega_omega0]\n\n"}
{"name":"Ordinal.omega0_le_omega","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ LE.le Ordinal.omega0 (Ordinal.omega o)","decl":"theorem omega0_le_omega (o : Ordinal) : ω ≤ ω_ o := by\n  rw [← omega_zero, omega_le_omega]\n  exact Ordinal.zero_le o\n\n"}
{"name":"Ordinal.omega_pos","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ LT.lt 0 (Ordinal.omega o)","decl":"/-- For the theorem `0 < ω`, see `omega0_pos`. -/\ntheorem omega_pos (o : Ordinal) : 0 < ω_ o :=\n  omega0_pos.trans_le (omega0_le_omega o)\n\n"}
{"name":"Ordinal.omega0_lt_omega1","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ LT.lt Ordinal.omega0 (Ordinal.omega 1)","decl":"theorem omega0_lt_omega1 : ω < ω₁ := by\n  rw [← omega_zero, omega_lt_omega]\n  exact zero_lt_one\n\n"}
{"name":"Ordinal.omega_lt_omega1","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ LT.lt Ordinal.omega0 (Ordinal.omega 1)","decl":"@[deprecated omega0_lt_omega1 (since := \"2024-10-11\")]\nalias omega_lt_omega1 := omega0_lt_omega1\n\n"}
{"name":"Ordinal.isNormal_omega","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Ordinal.IsNormal ⇑Ordinal.omega","decl":"theorem isNormal_omega : IsNormal omega :=\n  isNormal_preOmega.trans (isNormal_add_right _)\n\n"}
{"name":"Ordinal.range_omega","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Eq (Set.range ⇑Ordinal.omega) (setOf fun x => And (LE.le Ordinal.omega0 x) x.IsInitial)","decl":"@[simp]\ntheorem range_omega : range omega = {x | ω ≤ x ∧ IsInitial x} := by\n  ext x\n  constructor\n  · rintro ⟨a, rfl⟩\n    exact ⟨omega0_le_omega a, isInitial_omega a⟩\n  · rintro ⟨ha', ha⟩\n    obtain ⟨a, rfl⟩ := ha.mem_range_preOmega\n    use a - ω\n    rw [omega0_le_preOmega_iff] at ha'\n    rw [omega_eq_preOmega, Ordinal.add_sub_cancel_of_le ha']\n\n"}
{"name":"Ordinal.mem_range_omega_iff","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"x : Ordinal.{u_1}\n⊢ Iff (Membership.mem (Set.range ⇑Ordinal.omega) x) (And (LE.le Ordinal.omega0 x) x.IsInitial)","decl":"theorem mem_range_omega_iff {x : Ordinal} : x ∈ range omega ↔ ω ≤ x ∧ IsInitial x := by\n  rw [range_omega, mem_setOf]\n\n"}
{"name":"Ordinal.card_preOmega","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Ordinal.preOmega o).card (Cardinal.preAleph o)","decl":"@[simp]\ntheorem _root_.Ordinal.card_preOmega (o : Ordinal) : (preOmega o).card = preAleph o :=\n  rfl\n\n"}
{"name":"Cardinal.ord_preAleph","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Cardinal.preAleph o).ord (Ordinal.preOmega o)","decl":"@[simp]\ntheorem ord_preAleph (o : Ordinal) : (preAleph o).ord = preOmega o := by\n  rw [← o.card_preOmega, (isInitial_preOmega o).ord_card]\n\n"}
{"name":"Cardinal.type_cardinal","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Eq (Ordinal.type fun x1 x2 => LT.lt x1 x2) Ordinal.univ.{u, u + 1}","decl":"@[simp]\ntheorem type_cardinal : typeLT Cardinal = Ordinal.univ.{u, u + 1} := by\n  rw [Ordinal.univ_id]\n  exact Quotient.sound ⟨preAleph.symm.toRelIsoLT⟩\n\n"}
{"name":"Cardinal.mk_cardinal","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Eq (Cardinal.mk Cardinal.{u}) Cardinal.univ.{u, u + 1}","decl":"@[simp]\ntheorem mk_cardinal : #Cardinal = univ.{u, u + 1} := by\n  simpa only [card_type, card_univ] using congr_arg card type_cardinal\n\n"}
{"name":"Cardinal.preAleph_lt_preAleph","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Iff (LT.lt (Cardinal.preAleph o₁) (Cardinal.preAleph o₂)) (LT.lt o₁ o₂)","decl":"theorem preAleph_lt_preAleph {o₁ o₂ : Ordinal} : preAleph o₁ < preAleph o₂ ↔ o₁ < o₂ :=\n  preAleph.lt_iff_lt\n\n"}
{"name":"Cardinal.preAleph_le_preAleph","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Iff (LE.le (Cardinal.preAleph o₁) (Cardinal.preAleph o₂)) (LE.le o₁ o₂)","decl":"theorem preAleph_le_preAleph {o₁ o₂ : Ordinal} : preAleph o₁ ≤ preAleph o₂ ↔ o₁ ≤ o₂ :=\n  preAleph.le_iff_le\n\n"}
{"name":"Cardinal.preAleph_max","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Eq (Cardinal.preAleph (Max.max o₁ o₂)) (Max.max (Cardinal.preAleph o₁) (Cardinal.preAleph o₂))","decl":"theorem preAleph_max (o₁ o₂ : Ordinal) : preAleph (max o₁ o₂) = max (preAleph o₁) (preAleph o₂) :=\n  preAleph.monotone.map_max\n\n"}
{"name":"Cardinal.preAleph_zero","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Eq (Cardinal.preAleph 0) 0","decl":"@[simp]\ntheorem preAleph_zero : preAleph 0 = 0 :=\n  preAleph.map_bot\n\n"}
{"name":"Cardinal.preAleph_succ","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Cardinal.preAleph (Order.succ o)) (Order.succ (Cardinal.preAleph o))","decl":"@[simp]\ntheorem preAleph_succ (o : Ordinal) : preAleph (succ o) = succ (preAleph o) :=\n  preAleph.map_succ o\n\n"}
{"name":"Cardinal.preAleph_nat","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"n : Nat\n⊢ Eq (Cardinal.preAleph ↑n) ↑n","decl":"@[simp]\ntheorem preAleph_nat (n : ℕ) : preAleph n = n := by\n  rw [← card_preOmega, preOmega_natCast, card_nat]\n\n"}
{"name":"Cardinal.preAleph_omega0","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Eq (Cardinal.preAleph Ordinal.omega0) Cardinal.aleph0","decl":"@[simp]\ntheorem preAleph_omega0 : preAleph ω = ℵ₀ := by\n  rw [← card_preOmega, preOmega_omega0, card_omega0]\n\n"}
{"name":"Cardinal.preAleph_pos","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (LT.lt 0 (Cardinal.preAleph o)) (LT.lt 0 o)","decl":"@[simp]\ntheorem preAleph_pos {o : Ordinal} : 0 < preAleph o ↔ 0 < o := by\n  rw [← preAleph_zero, preAleph_lt_preAleph]\n\n"}
{"name":"Cardinal.aleph0_le_preAleph","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (LE.le Cardinal.aleph0 (Cardinal.preAleph o)) (LE.le Ordinal.omega0 o)","decl":"@[simp]\ntheorem aleph0_le_preAleph {o : Ordinal} : ℵ₀ ≤ preAleph o ↔ ω ≤ o := by\n  rw [← preAleph_omega0, preAleph_le_preAleph]\n\n"}
{"name":"Cardinal.lift_preAleph","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u}\n⊢ Eq (Cardinal.lift.{v, u} (Cardinal.preAleph o)) (Cardinal.preAleph (Ordinal.lift.{v, u} o))","decl":"@[simp]\ntheorem lift_preAleph (o : Ordinal.{u}) : lift.{v} (preAleph o) = preAleph (Ordinal.lift.{v} o) :=\n  (preAleph.toInitialSeg.trans liftInitialSeg).eq\n    (Ordinal.liftInitialSeg.trans preAleph.toInitialSeg) o\n\n"}
{"name":"Ordinal.lift_preOmega","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u}\n⊢ Eq (Ordinal.lift.{v, u} (Ordinal.preOmega o)) (Ordinal.preOmega (Ordinal.lift.{v, u} o))","decl":"@[simp]\ntheorem _root_.Ordinal.lift_preOmega (o : Ordinal.{u}) :\n    Ordinal.lift.{v} (preOmega o) = preOmega (Ordinal.lift.{v} o) := by\n  rw [← ord_preAleph, lift_ord, lift_preAleph, ord_preAleph]\n\n"}
{"name":"Cardinal.preAleph_le_of_isLimit","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\nl : o.IsLimit\nc : Cardinal.{u_1}\n⊢ Iff (LE.le (Cardinal.preAleph o) c) (∀ (o' : Ordinal.{u_1}), LT.lt o' o → LE.le (Cardinal.preAleph o') c)","decl":"theorem preAleph_le_of_isLimit {o : Ordinal} (l : o.IsLimit) {c} :\n    preAleph o ≤ c ↔ ∀ o' < o, preAleph o' ≤ c :=\n  ⟨fun h o' h' => (preAleph_le_preAleph.2 <| h'.le).trans h, fun h => by\n    rw [← preAleph.apply_symm_apply c, preAleph_le_preAleph, limit_le l]\n    intro x h'\n    rw [← preAleph_le_preAleph, preAleph.apply_symm_apply]\n    exact h _ h'⟩\n\n"}
{"name":"Cardinal.preAleph_limit","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\nho : o.IsLimit\n⊢ Eq (Cardinal.preAleph o) (iSup fun a => Cardinal.preAleph ↑a)","decl":"theorem preAleph_limit {o : Ordinal} (ho : o.IsLimit) : preAleph o = ⨆ a : Iio o, preAleph a := by\n  refine le_antisymm ?_ (ciSup_le' fun i => preAleph_le_preAleph.2 i.2.le)\n  rw [preAleph_le_of_isLimit ho]\n  exact fun a ha => le_ciSup (bddAbove_of_small _) (⟨a, ha⟩ : Iio o)\n\n"}
{"name":"Cardinal.aleph_eq_preAleph","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Cardinal.aleph o) (Cardinal.preAleph (HAdd.hAdd Ordinal.omega0 o))","decl":"theorem aleph_eq_preAleph (o : Ordinal) : ℵ_ o = preAleph (ω + o) :=\n  rfl\n\n"}
{"name":"Ordinal.card_omega","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Ordinal.omega o).card (Cardinal.aleph o)","decl":"@[simp]\ntheorem _root_.Ordinal.card_omega (o : Ordinal) : (ω_ o).card = ℵ_ o :=\n  rfl\n\n"}
{"name":"Cardinal.ord_aleph","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Cardinal.aleph o).ord (Ordinal.omega o)","decl":"@[simp]\ntheorem ord_aleph (o : Ordinal) : (ℵ_ o).ord = ω_ o :=\n  ord_preAleph _\n\n"}
{"name":"Cardinal.aleph_lt_aleph","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Iff (LT.lt (Cardinal.aleph o₁) (Cardinal.aleph o₂)) (LT.lt o₁ o₂)","decl":"theorem aleph_lt_aleph {o₁ o₂ : Ordinal} : ℵ_ o₁ < ℵ_ o₂ ↔ o₁ < o₂ :=\n  aleph.lt_iff_lt\n\n"}
{"name":"Cardinal.aleph_lt","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Iff (LT.lt (Cardinal.aleph o₁) (Cardinal.aleph o₂)) (LT.lt o₁ o₂)","decl":"@[deprecated aleph_lt_aleph (since := \"2024-10-22\")]\nalias aleph_lt := aleph_lt_aleph\n\n"}
{"name":"Cardinal.aleph_le_aleph","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Iff (LE.le (Cardinal.aleph o₁) (Cardinal.aleph o₂)) (LE.le o₁ o₂)","decl":"theorem aleph_le_aleph {o₁ o₂ : Ordinal} : ℵ_ o₁ ≤ ℵ_ o₂ ↔ o₁ ≤ o₂ :=\n  aleph.le_iff_le\n\n"}
{"name":"Cardinal.aleph_le","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Iff (LE.le (Cardinal.aleph o₁) (Cardinal.aleph o₂)) (LE.le o₁ o₂)","decl":"@[deprecated aleph_le_aleph (since := \"2024-10-22\")]\nalias aleph_le := aleph_le_aleph\n\n"}
{"name":"Cardinal.aleph_max","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Eq (Cardinal.aleph (Max.max o₁ o₂)) (Max.max (Cardinal.aleph o₁) (Cardinal.aleph o₂))","decl":"theorem aleph_max (o₁ o₂ : Ordinal) : ℵ_ (max o₁ o₂) = max (ℵ_ o₁) (ℵ_ o₂) :=\n  aleph.monotone.map_max\n\n"}
{"name":"Cardinal.max_aleph_eq","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Eq (Max.max (Cardinal.aleph o₁) (Cardinal.aleph o₂)) (Cardinal.aleph (Max.max o₁ o₂))","decl":"@[deprecated aleph_max (since := \"2024-08-28\")]\ntheorem max_aleph_eq (o₁ o₂ : Ordinal) : max (ℵ_ o₁) (ℵ_ o₂) = ℵ_ (max o₁ o₂) :=\n  (aleph_max o₁ o₂).symm\n\n"}
{"name":"Cardinal.preAleph_le_aleph","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ LE.le (Cardinal.preAleph o) (Cardinal.aleph o)","decl":"theorem preAleph_le_aleph (o : Ordinal) : preAleph o ≤ ℵ_ o :=\n  preAleph_le_preAleph.2 (Ordinal.le_add_left _ _)\n\n"}
{"name":"Cardinal.aleph_succ","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Cardinal.aleph (Order.succ o)) (Order.succ (Cardinal.aleph o))","decl":"@[simp]\ntheorem aleph_succ (o : Ordinal) : ℵ_ (succ o) = succ (ℵ_ o) := by\n  rw [aleph_eq_preAleph, add_succ, preAleph_succ, aleph_eq_preAleph]\n\n"}
{"name":"Cardinal.aleph_zero","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Eq (Cardinal.aleph 0) Cardinal.aleph0","decl":"@[simp]\ntheorem aleph_zero : ℵ_ 0 = ℵ₀ := by rw [aleph_eq_preAleph, add_zero, preAleph_omega0]\n\n"}
{"name":"Cardinal.lift_aleph","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u}\n⊢ Eq (Cardinal.lift.{v, u} (Cardinal.aleph o)) (Cardinal.aleph (Ordinal.lift.{v, u} o))","decl":"@[simp]\ntheorem lift_aleph (o : Ordinal.{u}) : lift.{v} (aleph o) = aleph (Ordinal.lift.{v} o) := by\n  simp [aleph_eq_preAleph]\n\n"}
{"name":"Ordinal.lift_omega","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u}\n⊢ Eq (Ordinal.lift.{v, u} (Ordinal.omega o)) (Ordinal.omega (Ordinal.lift.{v, u} o))","decl":"/-- For the theorem `lift ω = ω`, see `lift_omega0`. -/\n@[simp]\ntheorem _root_.Ordinal.lift_omega (o : Ordinal.{u}) :\n    Ordinal.lift.{v} (ω_ o) = ω_ (Ordinal.lift.{v} o) := by\n  simp [omega_eq_preOmega]\n\n"}
{"name":"Cardinal.aleph_limit","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\nho : o.IsLimit\n⊢ Eq (Cardinal.aleph o) (iSup fun a => Cardinal.aleph ↑a)","decl":"theorem aleph_limit {o : Ordinal} (ho : o.IsLimit) : ℵ_ o = ⨆ a : Iio o, ℵ_ a := by\n  rw [aleph_eq_preAleph, preAleph_limit (isLimit_add ω ho)]\n  apply le_antisymm <;>\n    apply ciSup_mono' (bddAbove_of_small _) <;>\n    intro i\n  · refine ⟨⟨_, sub_lt_of_lt_add i.2 ho.pos⟩, ?_⟩\n    simpa [aleph_eq_preAleph] using le_add_sub _ _\n  · exact ⟨⟨_, add_lt_add_left i.2 ω⟩, le_rfl⟩\n\n"}
{"name":"Cardinal.aleph0_le_aleph","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ LE.le Cardinal.aleph0 (Cardinal.aleph o)","decl":"theorem aleph0_le_aleph (o : Ordinal) : ℵ₀ ≤ ℵ_ o := by\n  rw [aleph_eq_preAleph, aleph0_le_preAleph]\n  apply Ordinal.le_add_right\n\n"}
{"name":"Cardinal.aleph_pos","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ LT.lt 0 (Cardinal.aleph o)","decl":"theorem aleph_pos (o : Ordinal) : 0 < ℵ_ o :=\n  aleph0_pos.trans_le (aleph0_le_aleph o)\n\n"}
{"name":"Cardinal.aleph_toNat","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Cardinal.toNat (Cardinal.aleph o)) 0","decl":"@[simp]\ntheorem aleph_toNat (o : Ordinal) : toNat (ℵ_ o) = 0 :=\n  toNat_apply_of_aleph0_le <| aleph0_le_aleph o\n\n"}
{"name":"Cardinal.aleph_toENat","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Cardinal.toENat (Cardinal.aleph o)) Top.top","decl":"@[simp]\ntheorem aleph_toENat (o : Ordinal) : toENat (ℵ_ o) = ⊤ :=\n  (toENat_eq_top.2 (aleph0_le_aleph o))\n\n"}
{"name":"Cardinal.isLimit_omega","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ (Ordinal.omega o).IsLimit","decl":"theorem isLimit_omega (o : Ordinal) : Ordinal.IsLimit (ω_ o) := by\n  rw [← ord_aleph]\n  exact isLimit_ord (aleph0_le_aleph _)\n\n"}
{"name":"Cardinal.ord_aleph_isLimit","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ (Cardinal.aleph o).ord.IsLimit","decl":"@[deprecated isLimit_omega (since := \"2024-10-24\")]\ntheorem ord_aleph_isLimit (o : Ordinal) : (ℵ_ o).ord.IsLimit :=\n  isLimit_ord <| aleph0_le_aleph _\n\n"}
{"name":"Cardinal.range_aleph","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Eq (Set.range ⇑Cardinal.aleph) (Set.Ici Cardinal.aleph0)","decl":"@[simp]\ntheorem range_aleph : range aleph = Set.Ici ℵ₀ := by\n  ext c\n  refine ⟨fun ⟨o, e⟩ => e ▸ aleph0_le_aleph _, fun hc ↦ ⟨preAleph.symm c - ω, ?_⟩⟩\n  rw [aleph_eq_preAleph, Ordinal.add_sub_cancel_of_le, preAleph.apply_symm_apply]\n  rwa [← aleph0_le_preAleph, preAleph.apply_symm_apply]\n\n"}
{"name":"Cardinal.mem_range_aleph_iff","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"c : Cardinal.{u_1}\n⊢ Iff (Membership.mem (Set.range ⇑Cardinal.aleph) c) (LE.le Cardinal.aleph0 c)","decl":"theorem mem_range_aleph_iff {c : Cardinal} : c ∈ range aleph ↔ ℵ₀ ≤ c := by\n  rw [range_aleph, mem_Ici]\n\n"}
{"name":"Cardinal.exists_aleph","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"c : Cardinal.{u_1}\n⊢ Iff (LE.le Cardinal.aleph0 c) (Exists fun o => Eq c (Cardinal.aleph o))","decl":"@[deprecated mem_range_aleph_iff (since := \"2024-10-24\")]\ntheorem exists_aleph {c : Cardinal} : ℵ₀ ≤ c ↔ ∃ o, c = ℵ_ o :=\n  ⟨fun h =>\n    ⟨preAleph.symm c - ω, by\n      rw [aleph_eq_preAleph, Ordinal.add_sub_cancel_of_le, preAleph.apply_symm_apply]\n      rwa [← aleph0_le_preAleph, preAleph.apply_symm_apply]⟩,\n    fun ⟨o, e⟩ => e.symm ▸ aleph0_le_aleph _⟩\n\n"}
{"name":"Cardinal.preAleph_isNormal","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Ordinal.IsNormal (Function.comp Cardinal.ord ⇑Cardinal.preAleph)","decl":"@[deprecated isNormal_preOmega (since := \"2024-10-11\")]\ntheorem preAleph_isNormal : IsNormal (ord ∘ preAleph) := by\n  convert isNormal_preOmega\n  exact funext ord_preAleph\n\n"}
{"name":"Cardinal.aleph_isNormal","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Ordinal.IsNormal (Function.comp Cardinal.ord ⇑Cardinal.aleph)","decl":"@[deprecated isNormal_omega (since := \"2024-10-11\")]\ntheorem aleph_isNormal : IsNormal (ord ∘ aleph) := by\n  convert isNormal_omega\n  exact funext ord_aleph\n\n"}
{"name":"Cardinal.succ_aleph0","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Eq (Order.succ Cardinal.aleph0) (Cardinal.aleph 1)","decl":"@[simp]\ntheorem succ_aleph0 : succ ℵ₀ = ℵ₁ := by\n  rw [← aleph_zero, ← aleph_succ, Ordinal.succ_zero]\n\n"}
{"name":"Cardinal.aleph0_lt_aleph_one","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ LT.lt Cardinal.aleph0 (Cardinal.aleph 1)","decl":"theorem aleph0_lt_aleph_one : ℵ₀ < ℵ₁ := by\n  rw [← succ_aleph0]\n  apply lt_succ\n\n"}
{"name":"Cardinal.countable_iff_lt_aleph_one","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff s.Countable (LT.lt (Cardinal.mk ↑s) (Cardinal.aleph 1))","decl":"theorem countable_iff_lt_aleph_one {α : Type*} (s : Set α) : s.Countable ↔ #s < ℵ₁ := by\n  rw [← succ_aleph0, lt_succ_iff, le_aleph0_iff_set_countable]\n\n"}
{"name":"Cardinal.aleph1_le_lift","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"c : Cardinal.{u}\n⊢ Iff (LE.le (Cardinal.aleph 1) (Cardinal.lift.{v, u} c)) (LE.le (Cardinal.aleph 1) c)","decl":"@[simp]\ntheorem aleph1_le_lift {c : Cardinal.{u}} : ℵ₁ ≤ lift.{v} c ↔ ℵ₁ ≤ c := by\n  simpa using lift_le (a := ℵ₁)\n\n"}
{"name":"Cardinal.lift_le_aleph1","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"c : Cardinal.{u}\n⊢ Iff (LE.le (Cardinal.lift.{v, u} c) (Cardinal.aleph 1)) (LE.le c (Cardinal.aleph 1))","decl":"@[simp]\ntheorem lift_le_aleph1 {c : Cardinal.{u}} : lift.{v} c ≤ ℵ₁ ↔ c ≤ ℵ₁ := by\n  simpa using lift_le (b := ℵ₁)\n\n"}
{"name":"Cardinal.aleph1_lt_lift","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"c : Cardinal.{u}\n⊢ Iff (LT.lt (Cardinal.aleph 1) (Cardinal.lift.{v, u} c)) (LT.lt (Cardinal.aleph 1) c)","decl":"@[simp]\ntheorem aleph1_lt_lift {c : Cardinal.{u}} : ℵ₁ < lift.{v} c ↔ ℵ₁ < c := by\n  simpa using lift_lt (a := ℵ₁)\n\n"}
{"name":"Cardinal.lift_lt_aleph1","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"c : Cardinal.{u}\n⊢ Iff (LT.lt (Cardinal.lift.{v, u} c) (Cardinal.aleph 1)) (LT.lt c (Cardinal.aleph 1))","decl":"@[simp]\ntheorem lift_lt_aleph1 {c : Cardinal.{u}} : lift.{v} c < ℵ₁ ↔ c < ℵ₁ := by\n  simpa using lift_lt (b := ℵ₁)\n\n"}
{"name":"Cardinal.aleph1_eq_lift","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"c : Cardinal.{u}\n⊢ Iff (Eq (Cardinal.aleph 1) (Cardinal.lift.{v, u} c)) (Eq (Cardinal.aleph 1) c)","decl":"@[simp]\ntheorem aleph1_eq_lift {c : Cardinal.{u}} : ℵ₁ = lift.{v} c ↔ ℵ₁ = c := by\n  simpa using lift_inj (a := ℵ₁)\n\n"}
{"name":"Cardinal.lift_eq_aleph1","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"c : Cardinal.{u}\n⊢ Iff (Eq (Cardinal.lift.{v, u} c) (Cardinal.aleph 1)) (Eq c (Cardinal.aleph 1))","decl":"@[simp]\ntheorem lift_eq_aleph1 {c : Cardinal.{u}} : lift.{v} c = ℵ₁ ↔ c = ℵ₁ := by\n  simpa using lift_inj (b := ℵ₁)\n\n"}
{"name":"Cardinal.lt_omega_iff_card_lt","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"x o : Ordinal.{u_1}\n⊢ Iff (LT.lt x (Ordinal.omega o)) (LT.lt x.card (Cardinal.aleph o))","decl":"theorem lt_omega_iff_card_lt {x o : Ordinal} : x < ω_ o ↔ x.card < ℵ_ o := by\n  rw [← (isInitial_omega o).card_lt_card, card_omega]\n\n"}
{"name":"Cardinal.alephIdx.relIso_coe","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Eq (⇑Cardinal.alephIdx.relIso) Cardinal.alephIdx","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-08-28\")]\ntheorem alephIdx.relIso_coe : (alephIdx.relIso : Cardinal → Ordinal) = alephIdx :=\n  rfl\n\n"}
{"name":"Cardinal.aleph'.relIso_coe","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Eq ⇑Cardinal.Aleph'.relIso ⇑Cardinal.aleph'","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-08-28\")]\ntheorem aleph'.relIso_coe : (Aleph'.relIso : Ordinal → Cardinal) = aleph' :=\n  rfl\n\n"}
{"name":"Cardinal.aleph'_lt","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Iff (LT.lt (Cardinal.aleph' o₁) (Cardinal.aleph' o₂)) (LT.lt o₁ o₂)","decl":"set_option linter.deprecated false in\n@[deprecated preAleph_lt_preAleph (since := \"2024-10-22\")]\ntheorem aleph'_lt {o₁ o₂ : Ordinal} : aleph' o₁ < aleph' o₂ ↔ o₁ < o₂ :=\n  aleph'.lt_iff_lt\n\n"}
{"name":"Cardinal.aleph'_le","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Iff (LE.le (Cardinal.aleph' o₁) (Cardinal.aleph' o₂)) (LE.le o₁ o₂)","decl":"set_option linter.deprecated false in\n@[deprecated preAleph_le_preAleph (since := \"2024-10-22\")]\ntheorem aleph'_le {o₁ o₂ : Ordinal} : aleph' o₁ ≤ aleph' o₂ ↔ o₁ ≤ o₂ :=\n  aleph'.le_iff_le\n\n"}
{"name":"Cardinal.aleph'_max","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Eq (Cardinal.aleph' (Max.max o₁ o₂)) (Max.max (Cardinal.aleph' o₁) (Cardinal.aleph' o₂))","decl":"set_option linter.deprecated false in\n@[deprecated preAleph_max (since := \"2024-10-22\")]\ntheorem aleph'_max (o₁ o₂ : Ordinal) : aleph' (max o₁ o₂) = max (aleph' o₁) (aleph' o₂) :=\n  aleph'.monotone.map_max\n\n"}
{"name":"Cardinal.aleph'_alephIdx","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"c : Cardinal.{u_1}\n⊢ Eq (Cardinal.aleph' c.alephIdx) c","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-08-28\")]\ntheorem aleph'_alephIdx (c : Cardinal) : aleph' c.alephIdx = c :=\n  Cardinal.alephIdx.relIso.toEquiv.symm_apply_apply c\n\n"}
{"name":"Cardinal.alephIdx_aleph'","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Cardinal.aleph' o).alephIdx o","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-08-28\")]\ntheorem alephIdx_aleph' (o : Ordinal) : (aleph' o).alephIdx = o :=\n  Cardinal.alephIdx.relIso.toEquiv.apply_symm_apply o\n\n"}
{"name":"Cardinal.aleph'_zero","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Eq (Cardinal.aleph' 0) 0","decl":"set_option linter.deprecated false in\n@[deprecated preAleph_zero (since := \"2024-10-22\")]\ntheorem aleph'_zero : aleph' 0 = 0 :=\n  aleph'.map_bot\n\n"}
{"name":"Cardinal.aleph'_succ","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Cardinal.aleph' (Order.succ o)) (Order.succ (Cardinal.aleph' o))","decl":"set_option linter.deprecated false in\n@[deprecated preAleph_succ (since := \"2024-10-22\")]\ntheorem aleph'_succ (o : Ordinal) : aleph' (succ o) = succ (aleph' o) :=\n  aleph'.map_succ o\n\n"}
{"name":"Cardinal.aleph'_nat","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"n : Nat\n⊢ Eq (Cardinal.aleph' ↑n) ↑n","decl":"set_option linter.deprecated false in\n@[deprecated preAleph_nat (since := \"2024-10-22\")]\ntheorem aleph'_nat : ∀ n : ℕ, aleph' n = n :=\n  preAleph_nat\n\n"}
{"name":"Cardinal.lift_aleph'","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u}\n⊢ Eq (Cardinal.lift.{v, u} (Cardinal.aleph' o)) (Cardinal.aleph' (Ordinal.lift.{v, u} o))","decl":"set_option linter.deprecated false in\n@[deprecated lift_preAleph (since := \"2024-10-22\")]\ntheorem lift_aleph' (o : Ordinal.{u}) : lift.{v} (aleph' o) = aleph' (Ordinal.lift.{v} o) :=\n  lift_preAleph o\n\n"}
{"name":"Cardinal.aleph'_le_of_limit","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\nl : o.IsLimit\nc : Cardinal.{u_1}\n⊢ Iff (LE.le (Cardinal.aleph' o) c) (∀ (o' : Ordinal.{u_1}), LT.lt o' o → LE.le (Cardinal.aleph' o') c)","decl":"set_option linter.deprecated false in\n@[deprecated preAleph_le_of_isLimit (since := \"2024-10-22\")]\ntheorem aleph'_le_of_limit {o : Ordinal} (l : o.IsLimit) {c} :\n    aleph' o ≤ c ↔ ∀ o' < o, aleph' o' ≤ c :=\n  preAleph_le_of_isLimit l\n\n"}
{"name":"Cardinal.aleph'_limit","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\nho : o.IsLimit\n⊢ Eq (Cardinal.aleph' o) (iSup fun a => Cardinal.aleph' ↑a)","decl":"set_option linter.deprecated false in\n@[deprecated preAleph_limit (since := \"2024-10-22\")]\ntheorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a :=\n  preAleph_limit ho\n\n"}
{"name":"Cardinal.aleph'_omega0","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Eq (Cardinal.aleph' Ordinal.omega0) Cardinal.aleph0","decl":"set_option linter.deprecated false in\n@[deprecated preAleph_omega0 (since := \"2024-10-22\")]\ntheorem aleph'_omega0 : aleph' ω = ℵ₀ :=\n  preAleph_omega0\n\n"}
{"name":"Cardinal.aleph'_omega","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Eq (Cardinal.aleph' Ordinal.omega0) Cardinal.aleph0","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias aleph'_omega := aleph'_omega0\n\n"}
{"name":"Cardinal.aleph_eq_aleph'","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Cardinal.aleph o) (Cardinal.preAleph (HAdd.hAdd Ordinal.omega0 o))","decl":"@[deprecated aleph_eq_preAleph (since := \"2024-10-22\")]\ntheorem aleph_eq_aleph' (o : Ordinal) : ℵ_ o = preAleph (ω + o) :=\n  rfl\n\n"}
{"name":"Cardinal.aleph0_le_aleph'","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (LE.le Cardinal.aleph0 (Cardinal.aleph' o)) (LE.le Ordinal.omega0 o)","decl":"set_option linter.deprecated false in\n@[deprecated aleph0_le_preAleph (since := \"2024-10-22\")]\ntheorem aleph0_le_aleph' {o : Ordinal} : ℵ₀ ≤ aleph' o ↔ ω ≤ o := by\n  rw [← aleph'_omega0, aleph'_le]\n\n"}
{"name":"Cardinal.aleph'_pos","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\nho : LT.lt 0 o\n⊢ LT.lt 0 (Cardinal.aleph' o)","decl":"set_option linter.deprecated false in\n@[deprecated preAleph_pos (since := \"2024-10-22\")]\ntheorem aleph'_pos {o : Ordinal} (ho : 0 < o) : 0 < aleph' o := by\n  rwa [← aleph'_zero, aleph'_lt]\n\n"}
{"name":"Cardinal.aleph'_isNormal","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Ordinal.IsNormal (Function.comp Cardinal.ord ⇑Cardinal.aleph')","decl":"set_option linter.deprecated false in\n@[deprecated preAleph_isNormal (since := \"2024-10-22\")]\ntheorem aleph'_isNormal : IsNormal (ord ∘ aleph') :=\n  preAleph_isNormal\n\n-- TODO: these lemmas should be stated in terms of the `ω` function and of an `IsInitial` predicate,\n-- neither of which currently exist.\n--\n-- They should also use `¬ BddAbove` instead of `Unbounded (· < ·)`.\n\n"}
{"name":"Cardinal.ord_card_unbounded","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Set.Unbounded (fun x1 x2 => LT.lt x1 x2) (setOf fun b => Eq b.card.ord b)","decl":"/-- Ordinals that are cardinals are unbounded. -/\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-24\")]\ntheorem ord_card_unbounded : Unbounded (· < ·) { b : Ordinal | b.card.ord = b } :=\n  unbounded_lt_iff.2 fun a =>\n    ⟨_,\n      ⟨by\n        dsimp\n        rw [card_ord], (lt_ord_succ_card a).le⟩⟩\n\n"}
{"name":"Cardinal.eq_aleph'_of_eq_card_ord","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\nho : Eq o.card.ord o\n⊢ Exists fun a => Eq (Cardinal.aleph' a).ord o","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-24\")]\ntheorem eq_aleph'_of_eq_card_ord {o : Ordinal} (ho : o.card.ord = o) : ∃ a, (aleph' a).ord = o :=\n  ⟨aleph'.symm o.card, by simpa using ho⟩\n\n"}
{"name":"Cardinal.ord_card_unbounded'","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Set.Unbounded (fun x1 x2 => LT.lt x1 x2) (setOf fun b => And (Eq b.card.ord b) (LE.le Ordinal.omega0 b))","decl":"set_option linter.deprecated false in\n/-- Infinite ordinals that are cardinals are unbounded. -/\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-24\")]\ntheorem ord_card_unbounded' : Unbounded (· < ·) { b : Ordinal | b.card.ord = b ∧ ω ≤ b } :=\n  (unbounded_lt_inter_le ω).2 ord_card_unbounded\n\n"}
{"name":"Cardinal.eq_aleph_of_eq_card_ord","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\nho : Eq o.card.ord o\nho' : LE.le Ordinal.omega0 o\n⊢ Exists fun a => Eq (Cardinal.aleph a).ord o","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-24\")]\ntheorem eq_aleph_of_eq_card_ord {o : Ordinal} (ho : o.card.ord = o) (ho' : ω ≤ o) :\n    ∃ a, (ℵ_ a).ord = o := by\n  cases' eq_aleph'_of_eq_card_ord ho with a ha\n  use a - ω\n  rwa [aleph_eq_aleph', Ordinal.add_sub_cancel_of_le]\n  rwa [← aleph0_le_aleph', ← ord_le_ord, ha, ord_aleph0]\n\n"}
{"name":"Cardinal.beth_zero","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Eq (Cardinal.beth 0) Cardinal.aleph0","decl":"@[simp]\ntheorem beth_zero : ℶ_ 0 = ℵ₀ :=\n  limitRecOn_zero _ _ _\n\n"}
{"name":"Cardinal.beth_succ","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Cardinal.beth (Order.succ o)) (HPow.hPow 2 (Cardinal.beth o))","decl":"@[simp]\ntheorem beth_succ (o : Ordinal) : ℶ_ (succ o) = 2 ^ beth o :=\n  limitRecOn_succ _ _ _ _\n\n"}
{"name":"Cardinal.beth_limit","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\na✝ : o.IsLimit\n⊢ Eq (Cardinal.beth o) (iSup fun a => Cardinal.beth ↑a)","decl":"theorem beth_limit {o : Ordinal} : o.IsLimit → ℶ_ o = ⨆ a : Iio o, ℶ_ a :=\n  limitRecOn_limit _ _ _ _\n\n"}
{"name":"Cardinal.beth_strictMono","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ StrictMono Cardinal.beth","decl":"theorem beth_strictMono : StrictMono beth := by\n  intro a b\n  induction' b using Ordinal.induction with b IH generalizing a\n  intro h\n  rcases zero_or_succ_or_limit b with (rfl | ⟨c, rfl⟩ | hb)\n  · exact (Ordinal.not_lt_zero a h).elim\n  · rw [lt_succ_iff] at h\n    rw [beth_succ]\n    apply lt_of_le_of_lt _ (cantor _)\n    rcases eq_or_lt_of_le h with (rfl | h)\n    · rfl\n    exact (IH c (lt_succ c) h).le\n  · apply (cantor _).trans_le\n    rw [beth_limit hb, ← beth_succ]\n    exact le_ciSup (bddAbove_of_small _) (⟨_, hb.succ_lt h⟩ : Iio b)\n\n"}
{"name":"Cardinal.beth_mono","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Monotone Cardinal.beth","decl":"theorem beth_mono : Monotone beth :=\n  beth_strictMono.monotone\n\n"}
{"name":"Cardinal.beth_lt","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Iff (LT.lt (Cardinal.beth o₁) (Cardinal.beth o₂)) (LT.lt o₁ o₂)","decl":"@[simp]\ntheorem beth_lt {o₁ o₂ : Ordinal} : ℶ_ o₁ < ℶ_ o₂ ↔ o₁ < o₂ :=\n  beth_strictMono.lt_iff_lt\n\n"}
{"name":"Cardinal.beth_le","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Iff (LE.le (Cardinal.beth o₁) (Cardinal.beth o₂)) (LE.le o₁ o₂)","decl":"@[simp]\ntheorem beth_le {o₁ o₂ : Ordinal} : ℶ_ o₁ ≤ ℶ_ o₂ ↔ o₁ ≤ o₂ :=\n  beth_strictMono.le_iff_le\n\n"}
{"name":"Cardinal.aleph_le_beth","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ LE.le (Cardinal.aleph o) (Cardinal.beth o)","decl":"theorem aleph_le_beth (o : Ordinal) : ℵ_ o ≤ ℶ_ o := by\n  induction o using limitRecOn with\n  | H₁ => simp\n  | H₂ o h =>\n    rw [aleph_succ, beth_succ, succ_le_iff]\n    exact (cantor _).trans_le (power_le_power_left two_ne_zero h)\n  | H₃ o ho IH =>\n    rw [aleph_limit ho, beth_limit ho]\n    exact ciSup_mono (bddAbove_of_small _) fun x => IH x.1 x.2\n\n"}
{"name":"Cardinal.aleph0_le_beth","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ LE.le Cardinal.aleph0 (Cardinal.beth o)","decl":"theorem aleph0_le_beth (o : Ordinal) : ℵ₀ ≤ ℶ_ o :=\n  (aleph0_le_aleph o).trans <| aleph_le_beth o\n\n"}
{"name":"Cardinal.beth_pos","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ LT.lt 0 (Cardinal.beth o)","decl":"theorem beth_pos (o : Ordinal) : 0 < ℶ_ o :=\n  aleph0_pos.trans_le <| aleph0_le_beth o\n\n"}
{"name":"Cardinal.beth_ne_zero","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"o : Ordinal.{u_1}\n⊢ Ne (Cardinal.beth o) 0","decl":"theorem beth_ne_zero (o : Ordinal) : ℶ_ o ≠ 0 :=\n  (beth_pos o).ne'\n\n"}
{"name":"Cardinal.isNormal_beth","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Ordinal.IsNormal (Function.comp Cardinal.ord Cardinal.beth)","decl":"theorem isNormal_beth : IsNormal (ord ∘ beth) := by\n  refine (isNormal_iff_strictMono_limit _).2\n    ⟨ord_strictMono.comp beth_strictMono, fun o ho a ha ↦ ?_⟩\n  rw [comp_apply, beth_limit ho, ord_le]\n  exact ciSup_le' fun b => ord_le.1 (ha _ b.2)\n\n"}
{"name":"Cardinal.beth_normal","module":"Mathlib.SetTheory.Cardinal.Aleph","initialProofState":"⊢ Ordinal.IsNormal fun o => (Cardinal.beth o).ord","decl":"@[deprecated isNormal_beth (since := \"2024-10-11\")]\ntheorem beth_normal : IsNormal.{u} fun o => (beth o).ord :=\n  isNormal_beth\n\n"}
