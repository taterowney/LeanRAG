{"name":"suffixLevenshtein_minimum_le_levenshtein_cons","module":"Mathlib.Data.List.EditDistance.Bounds","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\nC : Levenshtein.Cost α β δ\ninst✝¹ : LinearOrderedAddCommMonoid δ\ninst✝ : CanonicallyOrderedAdd δ\nxs : List α\ny : β\nys : List β\n⊢ LE.le (↑(suffixLevenshtein C xs ys)).minimum ↑(levenshtein C xs (List.cons y ys))","decl":"theorem suffixLevenshtein_minimum_le_levenshtein_cons (xs : List α) (y ys) :\n    (suffixLevenshtein C xs ys).1.minimum ≤ levenshtein C xs (y :: ys) := by\n  induction xs with\n  | nil =>\n      simp only [suffixLevenshtein_nil', levenshtein_nil_cons,\n        List.minimum_singleton, WithTop.coe_le_coe]\n      exact le_add_of_nonneg_left (by simp)\n  | cons x xs ih =>\n    suffices\n      (suffixLevenshtein C (x :: xs) ys).1.minimum ≤ (C.delete x + levenshtein C xs (y :: ys)) ∧\n        (suffixLevenshtein C (x :: xs) ys).1.minimum ≤ (C.insert y + levenshtein C (x :: xs) ys) ∧\n        (suffixLevenshtein C (x :: xs) ys).1.minimum ≤ (C.substitute x y + levenshtein C xs ys) by\n      simpa [suffixLevenshtein_eq_tails_map]\n    refine ⟨?_, ?_, ?_⟩\n    · calc\n        _ ≤ (suffixLevenshtein C xs ys).1.minimum := by\n            simp [suffixLevenshtein_cons₁_fst, List.minimum_cons]\n        _ ≤ ↑(levenshtein C xs (y :: ys)) := ih\n        _ ≤ _ := by simp\n    · calc\n        (suffixLevenshtein C (x :: xs) ys).1.minimum ≤ (levenshtein C (x :: xs) ys) := by\n            simp [suffixLevenshtein_cons₁_fst, List.minimum_cons]\n        _ ≤ _ := by simp\n    · calc\n        (suffixLevenshtein C (x :: xs) ys).1.minimum ≤ (levenshtein C xs ys) := by\n            simp only [suffixLevenshtein_cons₁_fst, List.minimum_cons]\n            apply min_le_of_right_le\n            cases xs\n            · simp [suffixLevenshtein_nil']\n            · simp [suffixLevenshtein_cons₁, List.minimum_cons]\n        _ ≤ _ := by simp\n\n"}
{"name":"le_suffixLevenshtein_cons_minimum","module":"Mathlib.Data.List.EditDistance.Bounds","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\nC : Levenshtein.Cost α β δ\ninst✝¹ : LinearOrderedAddCommMonoid δ\ninst✝ : CanonicallyOrderedAdd δ\nxs : List α\ny : β\nys : List β\n⊢ LE.le (↑(suffixLevenshtein C xs ys)).minimum (↑(suffixLevenshtein C xs (List.cons y ys))).minimum","decl":"theorem le_suffixLevenshtein_cons_minimum (xs : List α) (y ys) :\n    (suffixLevenshtein C xs ys).1.minimum ≤ (suffixLevenshtein C xs (y :: ys)).1.minimum := by\n  apply List.le_minimum_of_forall_le\n  simp only [suffixLevenshtein_eq_tails_map]\n  simp only [List.mem_map, List.mem_tails, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂]\n  intro a suff\n  refine (?_ : _ ≤ _).trans (suffixLevenshtein_minimum_le_levenshtein_cons _ _ _)\n  simp only [suffixLevenshtein_eq_tails_map]\n  apply List.le_minimum_of_forall_le\n  intro b m\n  replace m : ∃ a_1, a_1 <:+ a ∧ levenshtein C a_1 ys = b := by simpa using m\n  obtain ⟨a', suff', rfl⟩ := m\n  apply List.minimum_le_of_mem'\n  simp only [List.mem_map, List.mem_tails]\n  suffices ∃ a, a <:+ xs ∧ levenshtein C a ys = levenshtein C a' ys by simpa\n  exact ⟨a', suff'.trans suff, rfl⟩\n\n"}
{"name":"le_suffixLevenshtein_append_minimum","module":"Mathlib.Data.List.EditDistance.Bounds","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\nC : Levenshtein.Cost α β δ\ninst✝¹ : LinearOrderedAddCommMonoid δ\ninst✝ : CanonicallyOrderedAdd δ\nxs : List α\nys₁ ys₂ : List β\n⊢ LE.le (↑(suffixLevenshtein C xs ys₂)).minimum (↑(suffixLevenshtein C xs (HAppend.hAppend ys₁ ys₂))).minimum","decl":"theorem le_suffixLevenshtein_append_minimum (xs : List α) (ys₁ ys₂) :\n    (suffixLevenshtein C xs ys₂).1.minimum ≤ (suffixLevenshtein C xs (ys₁ ++ ys₂)).1.minimum := by\n  induction ys₁ with\n  | nil => exact le_refl _\n  | cons y ys₁ ih => exact ih.trans (le_suffixLevenshtein_cons_minimum _ _ _)\n\n"}
{"name":"suffixLevenshtein_minimum_le_levenshtein_append","module":"Mathlib.Data.List.EditDistance.Bounds","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\nC : Levenshtein.Cost α β δ\ninst✝¹ : LinearOrderedAddCommMonoid δ\ninst✝ : CanonicallyOrderedAdd δ\nxs : List α\nys₁ ys₂ : List β\n⊢ LE.le (↑(suffixLevenshtein C xs ys₂)).minimum ↑(levenshtein C xs (HAppend.hAppend ys₁ ys₂))","decl":"theorem suffixLevenshtein_minimum_le_levenshtein_append (xs ys₁ ys₂) :\n    (suffixLevenshtein C xs ys₂).1.minimum ≤ levenshtein C xs (ys₁ ++ ys₂) := by\n  cases ys₁ with\n  | nil => exact List.minimum_le_of_mem' (List.getElem_mem _)\n  | cons y ys₁ =>\n      exact (le_suffixLevenshtein_append_minimum _ _ _).trans\n        (suffixLevenshtein_minimum_le_levenshtein_cons _ _ _)\n\n"}
{"name":"le_levenshtein_cons","module":"Mathlib.Data.List.EditDistance.Bounds","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\nC : Levenshtein.Cost α β δ\ninst✝¹ : LinearOrderedAddCommMonoid δ\ninst✝ : CanonicallyOrderedAdd δ\nxs : List α\ny : β\nys : List β\n⊢ Exists fun xs' => And (xs'.IsSuffix xs) (LE.le (levenshtein C xs' ys) (levenshtein C xs (List.cons y ys)))","decl":"theorem le_levenshtein_cons (xs : List α) (y ys) :\n    ∃ xs', xs' <:+ xs ∧ levenshtein C xs' ys ≤ levenshtein C xs (y :: ys) := by\n  simpa [suffixLevenshtein_eq_tails_map, List.minimum_le_coe_iff] using\n    suffixLevenshtein_minimum_le_levenshtein_cons (δ := δ) xs y ys\n\n"}
{"name":"le_levenshtein_append","module":"Mathlib.Data.List.EditDistance.Bounds","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\nC : Levenshtein.Cost α β δ\ninst✝¹ : LinearOrderedAddCommMonoid δ\ninst✝ : CanonicallyOrderedAdd δ\nxs : List α\nys₁ ys₂ : List β\n⊢ Exists fun xs' => And (xs'.IsSuffix xs) (LE.le (levenshtein C xs' ys₂) (levenshtein C xs (HAppend.hAppend ys₁ ys₂)))","decl":"theorem le_levenshtein_append (xs : List α) (ys₁ ys₂) :\n    ∃ xs', xs' <:+ xs ∧ levenshtein C xs' ys₂ ≤ levenshtein C xs (ys₁ ++ ys₂) := by\n  simpa [suffixLevenshtein_eq_tails_map, List.minimum_le_coe_iff] using\n    suffixLevenshtein_minimum_le_levenshtein_append (δ := δ) xs ys₁ ys₂\n"}
