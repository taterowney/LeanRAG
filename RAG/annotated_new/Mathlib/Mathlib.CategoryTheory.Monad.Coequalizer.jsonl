{"name":"CategoryTheory.Monad.FreeCoequalizer.topMap_f","module":"Mathlib.CategoryTheory.Monad.Coequalizer","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nX : T.Algebra\n⊢ Eq (CategoryTheory.Monad.FreeCoequalizer.topMap X).f (T.map X.a)","decl":"/-- The top map in the coequalizer diagram we will construct. -/\n@[simps!]\ndef FreeCoequalizer.topMap : (Monad.free T).obj (T.obj X.A) ⟶ (Monad.free T).obj X.A :=\n  (Monad.free T).map X.a\n\n"}
{"name":"CategoryTheory.Monad.FreeCoequalizer.bottomMap_f","module":"Mathlib.CategoryTheory.Monad.Coequalizer","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nX : T.Algebra\n⊢ Eq (CategoryTheory.Monad.FreeCoequalizer.bottomMap X).f (T.μ.app X.A)","decl":"/-- The bottom map in the coequalizer diagram we will construct. -/\n@[simps]\ndef FreeCoequalizer.bottomMap : (Monad.free T).obj (T.obj X.A) ⟶ (Monad.free T).obj X.A where\n  f := T.μ.app X.A\n  h := T.assoc X.A\n\n"}
{"name":"CategoryTheory.Monad.FreeCoequalizer.π_f","module":"Mathlib.CategoryTheory.Monad.Coequalizer","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nX : T.Algebra\n⊢ Eq (CategoryTheory.Monad.FreeCoequalizer.π X).f X.a","decl":"/-- The cofork map in the coequalizer diagram we will construct. -/\n@[simps]\ndef FreeCoequalizer.π : (Monad.free T).obj X.A ⟶ X where\n  f := X.a\n  h := X.assoc.symm\n\n"}
{"name":"CategoryTheory.Monad.FreeCoequalizer.condition","module":"Mathlib.CategoryTheory.Monad.Coequalizer","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nX : T.Algebra\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Monad.FreeCoequalizer.topMap X) (CategoryTheory.Monad.FreeCoequalizer.π X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Monad.FreeCoequalizer.bottomMap X) (CategoryTheory.Monad.FreeCoequalizer.π X))","decl":"theorem FreeCoequalizer.condition :\n    FreeCoequalizer.topMap X ≫ FreeCoequalizer.π X =\n      FreeCoequalizer.bottomMap X ≫ FreeCoequalizer.π X :=\n  Algebra.Hom.ext X.assoc.symm\n\n"}
{"name":"CategoryTheory.Monad.instIsReflexivePairAlgebraTopMapBottomMap","module":"Mathlib.CategoryTheory.Monad.Coequalizer","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nX : T.Algebra\n⊢ CategoryTheory.IsReflexivePair (CategoryTheory.Monad.FreeCoequalizer.topMap X) (CategoryTheory.Monad.FreeCoequalizer.bottomMap X)","decl":"instance : IsReflexivePair (FreeCoequalizer.topMap X) (FreeCoequalizer.bottomMap X) := by\n  apply IsReflexivePair.mk' _ _ _\n  · apply (free T).map (T.η.app X.A)\n  · ext\n    dsimp\n    rw [← Functor.map_comp, X.unit, Functor.map_id]\n  · ext\n    apply Monad.right_unit\n\n"}
{"name":"CategoryTheory.Monad.beckAlgebraCofork_pt","module":"Mathlib.CategoryTheory.Monad.Coequalizer","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nX : T.Algebra\n⊢ Eq (CategoryTheory.Monad.beckAlgebraCofork X).pt X","decl":"/-- Construct the Beck cofork in the category of algebras. This cofork is reflexive as well as a\ncoequalizer.\n-/\n@[simps!]\ndef beckAlgebraCofork : Cofork (FreeCoequalizer.topMap X) (FreeCoequalizer.bottomMap X) :=\n  Cofork.ofπ _ (FreeCoequalizer.condition X)\n\n"}
{"name":"CategoryTheory.Monad.beckAlgebraCofork_ι_app","module":"Mathlib.CategoryTheory.Monad.Coequalizer","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nX✝ : T.Algebra\nX : CategoryTheory.Limits.WalkingParallelPair\n⊢ Eq ((CategoryTheory.Monad.beckAlgebraCofork X✝).ι.app X) (CategoryTheory.Limits.WalkingParallelPair.rec (CategoryTheory.CategoryStruct.comp (CategoryTheory.Monad.FreeCoequalizer.topMap X✝) (CategoryTheory.Monad.FreeCoequalizer.π X✝)) (CategoryTheory.Monad.FreeCoequalizer.π X✝) X)","decl":"/-- Construct the Beck cofork in the category of algebras. This cofork is reflexive as well as a\ncoequalizer.\n-/\n@[simps!]\ndef beckAlgebraCofork : Cofork (FreeCoequalizer.topMap X) (FreeCoequalizer.bottomMap X) :=\n  Cofork.ofπ _ (FreeCoequalizer.condition X)\n\n"}
{"name":"CategoryTheory.Monad.beckCofork_pt","module":"Mathlib.CategoryTheory.Monad.Coequalizer","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nX : T.Algebra\n⊢ Eq (CategoryTheory.Monad.beckCofork X).pt X.A","decl":"/-- This is the Beck cofork. It is a split coequalizer, in particular a coequalizer. -/\n@[simps! pt]\ndef beckCofork : Cofork (T.map X.a) (T.μ.app _) :=\n  (beckSplitCoequalizer X).asCofork\n\n"}
{"name":"CategoryTheory.Monad.beckCofork_π","module":"Mathlib.CategoryTheory.Monad.Coequalizer","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nX : T.Algebra\n⊢ Eq (CategoryTheory.Monad.beckCofork X).π X.a","decl":"@[simp]\ntheorem beckCofork_π : (beckCofork X).π = X.a :=\n  rfl\n\n"}
{"name":"CategoryTheory.Monad.beckCoequalizer_desc","module":"Mathlib.CategoryTheory.Monad.Coequalizer","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nX : T.Algebra\ns : CategoryTheory.Limits.Cofork (T.map X.a) (T.μ.app X.A)\n⊢ Eq ((CategoryTheory.Monad.beckCoequalizer X).desc s) (CategoryTheory.CategoryStruct.comp (T.η.app X.A) s.π)","decl":"@[simp]\ntheorem beckCoequalizer_desc (s : Cofork (T.toFunctor.map X.a) (T.μ.app X.A)) :\n    (beckCoequalizer X).desc s = T.η.app _ ≫ s.π :=\n  rfl\n\n"}
