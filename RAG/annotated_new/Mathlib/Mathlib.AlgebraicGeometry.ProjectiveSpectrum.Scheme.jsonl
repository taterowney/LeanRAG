{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.ToSpec.mk_mem_carrier","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nx : ↑((AlgebraicGeometry.Proj.toLocallyRingedSpace 𝒜).restrict ⋯).toTopCat\nz : HomogeneousLocalization.NumDenSameDeg 𝒜 (Submonoid.powers f)\n⊢ Iff (Membership.mem (AlgebraicGeometry.ProjIsoSpecTopComponent.ToSpec.carrier x) (HomogeneousLocalization.mk z)) (Membership.mem (↑x).asHomogeneousIdeal ↑z.num)","decl":"@[simp]\ntheorem mk_mem_carrier (z : HomogeneousLocalization.NumDenSameDeg 𝒜 (.powers f)) :\n    HomogeneousLocalization.mk z ∈ carrier x ↔ z.num.1 ∈ x.1.asHomogeneousIdeal := by\n  rw [carrier, Ideal.mem_comap, HomogeneousLocalization.algebraMap_apply,\n    HomogeneousLocalization.val_mk, Localization.mk_eq_mk', IsLocalization.mk'_eq_mul_mk'_one,\n    mul_comm, Ideal.unit_mul_mem_iff_mem, ← Ideal.mem_comap,\n    IsLocalization.comap_map_of_isPrime_disjoint (.powers f)]\n  · rfl\n  · infer_instance\n  · exact (disjoint_powers_iff_not_mem _ (Ideal.IsPrime.isRadical inferInstance)).mpr x.2\n  · exact isUnit_of_invertible _\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.ToSpec.isPrime_carrier","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nx : ↑((AlgebraicGeometry.Proj.toLocallyRingedSpace 𝒜).restrict ⋯).toTopCat\n⊢ (AlgebraicGeometry.ProjIsoSpecTopComponent.ToSpec.carrier x).IsPrime","decl":"theorem isPrime_carrier : Ideal.IsPrime (carrier x) := by\n  refine Ideal.IsPrime.comap _ (hK := ?_)\n  exact IsLocalization.isPrime_of_isPrime_disjoint\n    (Submonoid.powers f) _ _ inferInstance\n    ((disjoint_powers_iff_not_mem _ (Ideal.IsPrime.isRadical inferInstance)).mpr x.2)\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.ToSpec.toFun_asIdeal","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nx : ↑↑((AlgebraicGeometry.Proj.toLocallyRingedSpace 𝒜).restrict ⋯).toPresheafedSpace\n⊢ Eq (AlgebraicGeometry.ProjIsoSpecTopComponent.ToSpec.toFun f x).asIdeal (AlgebraicGeometry.ProjIsoSpecTopComponent.ToSpec.carrier x)","decl":"/-- The function between the basic open set `D(f)` in `Proj` to the corresponding basic open set in\n`Spec A⁰_f`. This is bundled into a continuous map in `TopComponent.forward`.\n-/\n@[simps (config := .lemmasOnly)]\ndef toFun (x : Proj.T| pbo f) : Spec.T A⁰_ f :=\n  ⟨carrier x, isPrime_carrier x⟩\n\n/-\nThe preimage of basic open set `D(a/f^n)` in `Spec A⁰_f` under the forward map from `Proj A` to\n`Spec A⁰_f` is the basic open set `D(a) ∩ D(f)` in `Proj A`. This lemma is used to prove that the\nforward map is continuous.\n-/\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.ToSpec.preimage_basicOpen","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nz : HomogeneousLocalization.NumDenSameDeg 𝒜 (Submonoid.powers f)\n⊢ Eq (Set.preimage (AlgebraicGeometry.ProjIsoSpecTopComponent.ToSpec.toFun f) ↑(PrimeSpectrum.basicOpen (HomogeneousLocalization.mk z))) (Set.preimage Subtype.val ↑(ProjectiveSpectrum.basicOpen 𝒜 ↑z.num))","decl":"theorem preimage_basicOpen (z : HomogeneousLocalization.NumDenSameDeg 𝒜 (.powers f)) :\n    toFun f ⁻¹' (sbo (HomogeneousLocalization.mk z) : Set (PrimeSpectrum (A⁰_ f))) =\n      Subtype.val ⁻¹' (pbo z.num.1 : Set (ProjectiveSpectrum 𝒜)) :=\n  Set.ext fun y ↦ (mk_mem_carrier y z).not\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.toSpec_apply_asIdeal","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nx : ↑↑((AlgebraicGeometry.Proj.toLocallyRingedSpace 𝒜).restrict ⋯).toPresheafedSpace\n⊢ Eq ((AlgebraicGeometry.ProjIsoSpecTopComponent.toSpec 𝒜 f) x).asIdeal (AlgebraicGeometry.ProjIsoSpecTopComponent.ToSpec.carrier x)","decl":"/-- The continuous function from the basic open set `D(f)` in `Proj`\nto the corresponding basic open set in `Spec A⁰_f`. -/\n@[simps! (config := .lemmasOnly) apply_asIdeal]\ndef toSpec (f : A) : (Proj.T| pbo f) ⟶ Spec.T A⁰_ f where\n  toFun := ToSpec.toFun f\n  continuous_toFun := by\n    rw [PrimeSpectrum.isTopologicalBasis_basic_opens.continuous_iff]\n    rintro _ ⟨x, rfl⟩\n    obtain ⟨x, rfl⟩ := Quotient.mk''_surjective x\n    rw [ToSpec.preimage_basicOpen]\n    exact (pbo x.num).2.preimage continuous_subtype_val\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.toSpec_preimage_basicOpen","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nz : HomogeneousLocalization.NumDenSameDeg 𝒜 (Submonoid.powers f)\n⊢ Eq (Set.preimage ⇑(AlgebraicGeometry.ProjIsoSpecTopComponent.toSpec 𝒜 f) ↑(PrimeSpectrum.basicOpen (HomogeneousLocalization.mk z))) (Set.preimage Subtype.val ↑(ProjectiveSpectrum.basicOpen 𝒜 ↑z.num))","decl":"variable {𝒜} in\nlemma toSpec_preimage_basicOpen {f} (z : HomogeneousLocalization.NumDenSameDeg 𝒜 (.powers f)) :\n    toSpec 𝒜 f ⁻¹' (sbo (HomogeneousLocalization.mk z) : Set (PrimeSpectrum (A⁰_ f))) =\n      Subtype.val ⁻¹' (pbo z.num.1 : Set (ProjectiveSpectrum 𝒜)) :=\n  ToSpec.preimage_basicOpen f z\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.mem_carrier_iff","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nq : ↑↑(AlgebraicGeometry.Spec.locallyRingedSpaceObj (CommRingCat.of (HomogeneousLocalization.Away 𝒜 f))).toPresheafedSpace\na : A\n⊢ Iff (Membership.mem (AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier f_deg q) a) (∀ (i : Nat), Membership.mem q.asIdeal (HomogeneousLocalization.mk { deg := HMul.hMul m i, num := ⟨HPow.hPow ((GradedAlgebra.proj 𝒜 i) a) m, ⋯⟩, den := ⟨HPow.hPow f i, ⋯⟩, den_mem := ⋯ }))","decl":"theorem mem_carrier_iff (q : Spec.T A⁰_ f) (a : A) :\n    a ∈ carrier f_deg q ↔ ∀ i, (HomogeneousLocalization.mk ⟨m * i, ⟨proj 𝒜 i a ^ m, by\n      rw [← smul_eq_mul]; mem_tac⟩,\n      ⟨f ^ i, by rw [mul_comm]; mem_tac⟩, ⟨_, rfl⟩⟩ : A⁰_ f) ∈ q.1 :=\n  Iff.rfl\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.mem_carrier_iff'","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nq : ↑↑(AlgebraicGeometry.Spec.locallyRingedSpaceObj (CommRingCat.of (HomogeneousLocalization.Away 𝒜 f))).toPresheafedSpace\na : A\n⊢ Iff (Membership.mem (AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier f_deg q) a) (∀ (i : Nat), Membership.mem (Set.image (⇑(algebraMap (HomogeneousLocalization.Away 𝒜 f) (Localization.Away f))) (setOf fun s => Membership.mem q.asIdeal s)) (Localization.mk (HPow.hPow ((GradedAlgebra.proj 𝒜 i) a) m) ⟨HPow.hPow f i, ⋯⟩))","decl":"theorem mem_carrier_iff' (q : Spec.T A⁰_ f) (a : A) :\n    a ∈ carrier f_deg q ↔\n      ∀ i, (Localization.mk (proj 𝒜 i a ^ m) ⟨f ^ i, ⟨i, rfl⟩⟩ : Localization.Away f) ∈\n          algebraMap (HomogeneousLocalization.Away 𝒜 f) (Localization.Away f) '' { s | s ∈ q.1 } :=\n  (mem_carrier_iff f_deg q a).trans\n    (by\n      constructor <;> intro h i <;> specialize h i\n      · rw [Set.mem_image]; refine ⟨_, h, rfl⟩\n      · rw [Set.mem_image] at h; rcases h with ⟨x, h, hx⟩\n        change x ∈ q.asIdeal at h\n        convert h\n        rw [HomogeneousLocalization.ext_iff_val, HomogeneousLocalization.val_mk]\n        dsimp only [Subtype.coe_mk]; rw [← hx]; rfl)\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.mem_carrier_iff_of_mem","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nhm : LT.lt 0 m\nq : ↑↑(AlgebraicGeometry.Spec.locallyRingedSpaceObj (CommRingCat.of (HomogeneousLocalization.Away 𝒜 f))).toPresheafedSpace\na : A\nn : Nat\nhn : Membership.mem (𝒜 n) a\n⊢ Iff (Membership.mem (AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier f_deg q) a) (Membership.mem q.asIdeal (HomogeneousLocalization.mk { deg := HMul.hMul m n, num := ⟨HPow.hPow a m, ⋯⟩, den := ⟨HPow.hPow f n, ⋯⟩, den_mem := ⋯ }))","decl":"theorem mem_carrier_iff_of_mem (hm : 0 < m) (q : Spec.T A⁰_ f) (a : A) {n} (hn : a ∈ 𝒜 n) :\n    a ∈ carrier f_deg q ↔\n      (HomogeneousLocalization.mk ⟨m * n, ⟨a ^ m, pow_mem_graded m hn⟩,\n        ⟨f ^ n, by rw [mul_comm]; mem_tac⟩, ⟨_, rfl⟩⟩ : A⁰_ f) ∈ q.asIdeal := by\n  trans (HomogeneousLocalization.mk ⟨m * n, ⟨proj 𝒜 n a ^ m, by rw [← smul_eq_mul]; mem_tac⟩,\n    ⟨f ^ n, by rw [mul_comm]; mem_tac⟩, ⟨_, rfl⟩⟩ : A⁰_ f) ∈ q.asIdeal\n  · refine ⟨fun h ↦ h n, fun h i ↦ if hi : i = n then hi ▸ h else ?_⟩\n    convert zero_mem q.asIdeal\n    apply HomogeneousLocalization.val_injective\n    simp only [proj_apply, decompose_of_mem_ne _ hn (Ne.symm hi), zero_pow hm.ne',\n      HomogeneousLocalization.val_mk, Localization.mk_zero, HomogeneousLocalization.val_zero]\n  · simp only [proj_apply, decompose_of_mem_same _ hn]\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.mem_carrier_iff_of_mem_mul","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nhm : LT.lt 0 m\nq : ↑↑(AlgebraicGeometry.Spec.locallyRingedSpaceObj (CommRingCat.of (HomogeneousLocalization.Away 𝒜 f))).toPresheafedSpace\na : A\nn : Nat\nhn : Membership.mem (𝒜 (HMul.hMul n m)) a\n⊢ Iff (Membership.mem (AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier f_deg q) a) (Membership.mem q.asIdeal (HomogeneousLocalization.mk { deg := HMul.hMul m n, num := ⟨a, ⋯⟩, den := ⟨HPow.hPow f n, ⋯⟩, den_mem := ⋯ }))","decl":"theorem mem_carrier_iff_of_mem_mul (hm : 0 < m)\n    (q : Spec.T A⁰_ f) (a : A) {n} (hn : a ∈ 𝒜 (n * m)) :\n    a ∈ carrier f_deg q ↔ (HomogeneousLocalization.mk ⟨m * n, ⟨a, mul_comm n m ▸ hn⟩,\n        ⟨f ^ n, by rw [mul_comm]; mem_tac⟩, ⟨_, rfl⟩⟩ : A⁰_ f) ∈ q.asIdeal := by\n  rw [mem_carrier_iff_of_mem f_deg hm q a hn, iff_iff_eq, eq_comm,\n    ← Ideal.IsPrime.pow_mem_iff_mem (α := A⁰_ f) inferInstance m hm]\n  congr 1\n  apply HomogeneousLocalization.val_injective\n  simp only [HomogeneousLocalization.val_mk, HomogeneousLocalization.val_pow,\n    Localization.mk_pow, pow_mul]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.num_mem_carrier_iff","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nhm : LT.lt 0 m\nq : ↑↑(AlgebraicGeometry.Spec.locallyRingedSpaceObj (CommRingCat.of (HomogeneousLocalization.Away 𝒜 f))).toPresheafedSpace\nz : HomogeneousLocalization.NumDenSameDeg 𝒜 (Submonoid.powers f)\n⊢ Iff (Membership.mem (AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier f_deg q) ↑z.num) (Membership.mem q.asIdeal (HomogeneousLocalization.mk z))","decl":"theorem num_mem_carrier_iff (hm : 0 < m) (q : Spec.T A⁰_ f)\n    (z : HomogeneousLocalization.NumDenSameDeg 𝒜 (.powers f)) :\n    z.num.1 ∈ carrier f_deg q ↔ HomogeneousLocalization.mk z ∈ q.asIdeal := by\n  obtain ⟨n, hn : f ^ n = _⟩ := z.den_mem\n  have : f ^ n ≠ 0 := fun e ↦ by\n    have := HomogeneousLocalization.subsingleton 𝒜 (x := .powers f) ⟨n, e⟩\n    exact IsEmpty.elim (inferInstanceAs (IsEmpty (PrimeSpectrum (A⁰_ f)))) q\n  convert mem_carrier_iff_of_mem_mul f_deg hm q z.num.1 (n := n) ?_ using 2\n  · apply HomogeneousLocalization.val_injective; simp only [hn, HomogeneousLocalization.val_mk]\n  · have := degree_eq_of_mem_mem 𝒜 (SetLike.pow_mem_graded n f_deg) (hn.symm ▸ z.den.2) this\n    rw [← smul_eq_mul, this]; exact z.num.2\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.add_mem","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nq : ↑↑(AlgebraicGeometry.Spec.locallyRingedSpaceObj (CommRingCat.of (HomogeneousLocalization.Away 𝒜 f))).toPresheafedSpace\na b : A\nha : Membership.mem (AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier f_deg q) a\nhb : Membership.mem (AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier f_deg q) b\n⊢ Membership.mem (AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier f_deg q) (HAdd.hAdd a b)","decl":"theorem carrier.add_mem (q : Spec.T A⁰_ f) {a b : A} (ha : a ∈ carrier f_deg q)\n    (hb : b ∈ carrier f_deg q) : a + b ∈ carrier f_deg q := by\n  refine fun i => (q.2.mem_or_mem ?_).elim id id\n  change (HomogeneousLocalization.mk ⟨_, _, _, _⟩ : A⁰_ f) ∈ q.1; dsimp only [Subtype.coe_mk]\n  simp_rw [← pow_add, map_add, add_pow, mul_comm, ← nsmul_eq_mul]\n  let g : ℕ → A⁰_ f := fun j => (m + m).choose j •\n      if h2 : m + m < j then (0 : A⁰_ f)\n      else\n        -- Porting note: inlining `l`, `r` causes a \"can't synth HMul A⁰_ f A⁰_ f ?\" error\n        if h1 : j ≤ m then\n          letI l : A⁰_ f := HomogeneousLocalization.mk\n            ⟨m * i, ⟨proj 𝒜 i a ^ j * proj 𝒜 i b ^ (m - j), ?_⟩,\n              ⟨_, by rw [mul_comm]; mem_tac⟩, ⟨i, rfl⟩⟩\n          letI r : A⁰_ f := HomogeneousLocalization.mk\n            ⟨m * i, ⟨proj 𝒜 i b ^ m, by rw [← smul_eq_mul]; mem_tac⟩,\n              ⟨_, by rw [mul_comm]; mem_tac⟩, ⟨i, rfl⟩⟩\n          l * r\n        else\n          letI l : A⁰_ f := HomogeneousLocalization.mk\n            ⟨m * i, ⟨proj 𝒜 i a ^ m, by rw [← smul_eq_mul]; mem_tac⟩,\n              ⟨_, by rw [mul_comm]; mem_tac⟩, ⟨i, rfl⟩⟩\n          letI r : A⁰_ f := HomogeneousLocalization.mk\n            ⟨m * i, ⟨proj 𝒜 i a ^ (j - m) * proj 𝒜 i b ^ (m + m - j), ?_⟩,\n              ⟨_, by rw [mul_comm]; mem_tac⟩, ⟨i, rfl⟩⟩\n          l * r\n  rotate_left\n  · rw [(_ : m * i = _)]\n    -- Porting note: it seems unification with mul_mem is more fiddly reducing value of mem_tac\n    apply GradedMonoid.toGradedMul.mul_mem (i := j • i) (j := (m - j) • i) <;> mem_tac_aux\n    rw [← add_smul, Nat.add_sub_of_le h1]; rfl\n  · rw [(_ : m * i = _)]\n    apply GradedMonoid.toGradedMul.mul_mem (i := (j-m) • i) (j := (m + m - j) • i) <;> mem_tac_aux\n    rw [← add_smul]; congr; zify [le_of_not_lt h2, le_of_not_le h1]; abel\n  convert_to ∑ i ∈ range (m + m + 1), g i ∈ q.1; swap\n  · refine q.1.sum_mem fun j _ => nsmul_mem ?_ _; split_ifs\n    exacts [q.1.zero_mem, q.1.mul_mem_left _ (hb i), q.1.mul_mem_right _ (ha i)]\n  rw [HomogeneousLocalization.ext_iff_val, HomogeneousLocalization.val_mk]\n  change _ = (algebraMap (HomogeneousLocalization.Away 𝒜 f) (Localization.Away f)) _\n  dsimp only [Subtype.coe_mk]; rw [map_sum, mk_sum]\n  apply Finset.sum_congr rfl fun j hj => _\n  intro j hj\n  change _ = HomogeneousLocalization.val _\n  rw [HomogeneousLocalization.val_smul]\n  split_ifs with h2 h1\n  · exact ((Finset.mem_range.1 hj).not_le h2).elim\n  all_goals simp only [HomogeneousLocalization.val_mul, HomogeneousLocalization.val_zero,\n    HomogeneousLocalization.val_mk, Subtype.coe_mk, Localization.mk_mul, ← smul_mk]; congr 2\n  · dsimp; rw [mul_assoc, ← pow_add, add_comm (m - j), Nat.add_sub_assoc h1]\n  · simp_rw [pow_add]; rfl\n  · dsimp; rw [← mul_assoc, ← pow_add, Nat.add_sub_of_le (le_of_not_le h1)]\n  · simp_rw [pow_add]; rfl\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.zero_mem","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nhm : LT.lt 0 m\nq : ↑↑(AlgebraicGeometry.Spec.locallyRingedSpaceObj (CommRingCat.of (HomogeneousLocalization.Away 𝒜 f))).toPresheafedSpace\n⊢ Membership.mem (AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier f_deg q) 0","decl":"theorem carrier.zero_mem : (0 : A) ∈ carrier f_deg q := fun i => by\n  convert Submodule.zero_mem q.1 using 1\n  rw [HomogeneousLocalization.ext_iff_val, HomogeneousLocalization.val_mk,\n    HomogeneousLocalization.val_zero]; simp_rw [map_zero, zero_pow hm.ne']\n  convert Localization.mk_zero (S := Submonoid.powers f) _ using 1\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.smul_mem","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nhm : LT.lt 0 m\nq : ↑↑(AlgebraicGeometry.Spec.locallyRingedSpaceObj (CommRingCat.of (HomogeneousLocalization.Away 𝒜 f))).toPresheafedSpace\nc x : A\nhx : Membership.mem (AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier f_deg q) x\n⊢ Membership.mem (AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier f_deg q) (HSMul.hSMul c x)","decl":"theorem carrier.smul_mem (c x : A) (hx : x ∈ carrier f_deg q) : c • x ∈ carrier f_deg q := by\n  revert c\n  refine DirectSum.Decomposition.inductionOn 𝒜 ?_ ?_ ?_\n  · rw [zero_smul]; exact carrier.zero_mem f_deg hm _\n  · rintro n ⟨a, ha⟩ i\n    simp_rw [proj_apply, smul_eq_mul, coe_decompose_mul_of_left_mem 𝒜 i ha]\n    -- Porting note: having trouble with Mul instance\n    let product : A⁰_ f :=\n      Mul.mul (HomogeneousLocalization.mk ⟨_, ⟨a ^ m, pow_mem_graded m ha⟩, ⟨_, ?_⟩, ⟨n, rfl⟩⟩)\n        (HomogeneousLocalization.mk ⟨_, ⟨proj 𝒜 (i - n) x ^ m, by mem_tac⟩, ⟨_, ?_⟩, ⟨i - n, rfl⟩⟩)\n    · split_ifs with h\n      · convert_to product ∈ q.1\n        · dsimp [product]\n          erw [HomogeneousLocalization.ext_iff_val, HomogeneousLocalization.val_mk,\n            HomogeneousLocalization.val_mul, HomogeneousLocalization.val_mk,\n            HomogeneousLocalization.val_mk]\n          · simp_rw [mul_pow]; rw [Localization.mk_mul]\n            · congr; rw [← pow_add, Nat.add_sub_of_le h]\n        · apply Ideal.mul_mem_left (α := A⁰_ f) _ _ (hx _)\n          rw [(_ : m • n = _)]\n          · mem_tac\n          · simp only [smul_eq_mul, mul_comm]\n      · simpa only [map_zero, zero_pow hm.ne'] using zero_mem f_deg hm q i\n    rw [(_ : m • (i - n) = _)]\n    · mem_tac\n    · simp only [smul_eq_mul, mul_comm]\n  · simp_rw [add_smul]; exact fun _ _ => carrier.add_mem f_deg q\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.asIdeal.homogeneous","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nhm : LT.lt 0 m\nq : ↑↑(AlgebraicGeometry.Spec.locallyRingedSpaceObj (CommRingCat.of (HomogeneousLocalization.Away 𝒜 f))).toPresheafedSpace\n⊢ Ideal.IsHomogeneous 𝒜 (AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.asIdeal f_deg hm q)","decl":"theorem carrier.asIdeal.homogeneous : (carrier.asIdeal f_deg hm q).IsHomogeneous 𝒜 :=\n  fun i a ha j =>\n  (em (i = j)).elim (fun h => h ▸ by simpa only [proj_apply, decompose_coe, of_eq_same] using ha _)\n    fun h => by\n    simpa only [proj_apply, decompose_of_mem_ne 𝒜 (Submodule.coe_mem (decompose 𝒜 a i)) h,\n      zero_pow hm.ne', map_zero] using carrier.zero_mem f_deg hm q j\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.denom_not_mem","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nhm : LT.lt 0 m\nq : ↑↑(AlgebraicGeometry.Spec.locallyRingedSpaceObj (CommRingCat.of (HomogeneousLocalization.Away 𝒜 f))).toPresheafedSpace\n⊢ Not (Membership.mem (AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.asIdeal f_deg hm q) f)","decl":"theorem carrier.denom_not_mem : f ∉ carrier.asIdeal f_deg hm q := fun rid =>\n  q.isPrime.ne_top <|\n    (Ideal.eq_top_iff_one _).mpr\n      (by\n        convert rid m\n        rw [HomogeneousLocalization.ext_iff_val, HomogeneousLocalization.val_one,\n          HomogeneousLocalization.val_mk]\n        dsimp\n        simp_rw [decompose_of_mem_same _ f_deg]\n        simp only [mk_eq_monoidOf_mk', Submonoid.LocalizationMap.mk'_self])\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.relevant","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nhm : LT.lt 0 m\nq : ↑↑(AlgebraicGeometry.Spec.locallyRingedSpaceObj (CommRingCat.of (HomogeneousLocalization.Away 𝒜 f))).toPresheafedSpace\n⊢ Not (LE.le (HomogeneousIdeal.irrelevant 𝒜) (AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.asHomogeneousIdeal f_deg hm q))","decl":"theorem carrier.relevant : ¬HomogeneousIdeal.irrelevant 𝒜 ≤ carrier.asHomogeneousIdeal f_deg hm q :=\n  fun rid => carrier.denom_not_mem f_deg hm q <| rid <| DirectSum.decompose_of_mem_ne 𝒜 f_deg hm.ne'\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.asIdeal.ne_top","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nhm : LT.lt 0 m\nq : ↑↑(AlgebraicGeometry.Spec.locallyRingedSpaceObj (CommRingCat.of (HomogeneousLocalization.Away 𝒜 f))).toPresheafedSpace\n⊢ Ne (AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.asIdeal f_deg hm q) Top.top","decl":"theorem carrier.asIdeal.ne_top : carrier.asIdeal f_deg hm q ≠ ⊤ := fun rid =>\n  carrier.denom_not_mem f_deg hm q (rid.symm ▸ Submodule.mem_top)\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.asIdeal.prime","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nhm : LT.lt 0 m\nq : ↑↑(AlgebraicGeometry.Spec.locallyRingedSpaceObj (CommRingCat.of (HomogeneousLocalization.Away 𝒜 f))).toPresheafedSpace\n⊢ (AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.asIdeal f_deg hm q).IsPrime","decl":"theorem carrier.asIdeal.prime : (carrier.asIdeal f_deg hm q).IsPrime :=\n  (carrier.asIdeal.homogeneous f_deg hm q).isPrime_of_homogeneous_mem_or_mem\n    (carrier.asIdeal.ne_top f_deg hm q) fun {x y} ⟨nx, hnx⟩ ⟨ny, hny⟩ hxy =>\n    show (∀ _, _ ∈ _) ∨ ∀ _, _ ∈ _ by\n      rw [← and_forall_ne nx, and_iff_left, ← and_forall_ne ny, and_iff_left]\n      · apply q.2.mem_or_mem; convert hxy (nx + ny) using 1\n        dsimp\n        simp_rw [decompose_of_mem_same 𝒜 hnx, decompose_of_mem_same 𝒜 hny,\n          decompose_of_mem_same 𝒜 (SetLike.GradedMonoid.toGradedMul.mul_mem hnx hny),\n          mul_pow, pow_add]\n        simp only [HomogeneousLocalization.ext_iff_val, HomogeneousLocalization.val_mk,\n          HomogeneousLocalization.val_mul, Localization.mk_mul]\n        simp only [Submonoid.mk_mul_mk, mk_eq_monoidOf_mk']\n      all_goals\n        intro n hn; convert q.1.zero_mem using 1\n        rw [HomogeneousLocalization.ext_iff_val, HomogeneousLocalization.val_mk,\n          HomogeneousLocalization.val_zero]; simp_rw [proj_apply]\n        convert mk_zero (S := Submonoid.powers f) _\n        rw [decompose_of_mem_ne 𝒜 _ hn.symm, zero_pow hm.ne']\n        · first | exact hnx | exact hny\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.toSpec_fromSpec","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nhm : LT.lt 0 m\nx : ↑↑(AlgebraicGeometry.Spec.locallyRingedSpaceObj (CommRingCat.of (HomogeneousLocalization.Away 𝒜 f))).toPresheafedSpace\n⊢ Eq ((AlgebraicGeometry.ProjIsoSpecTopComponent.toSpec 𝒜 f) (AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.toFun f_deg hm x)) x","decl":"lemma toSpec_fromSpec {f : A} {m : ℕ} (f_deg : f ∈ 𝒜 m) (hm : 0 < m) (x : Spec.T (A⁰_ f)) :\n    toSpec 𝒜 f (FromSpec.toFun f_deg hm x) = x := by\n  apply PrimeSpectrum.ext\n  ext z\n  obtain ⟨z, rfl⟩ := HomogeneousLocalization.mk_surjective z\n  rw [← FromSpec.num_mem_carrier_iff f_deg hm x]\n  exact ToSpec.mk_mem_carrier _ z\n\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.fromSpec_toSpec","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nhm : LT.lt 0 m\nx : ↑↑((AlgebraicGeometry.Proj.toLocallyRingedSpace 𝒜).restrict ⋯).toPresheafedSpace\n⊢ Eq (AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.toFun f_deg hm ((AlgebraicGeometry.ProjIsoSpecTopComponent.toSpec 𝒜 f) x)) x","decl":"lemma fromSpec_toSpec {f : A} {m : ℕ} (f_deg : f ∈ 𝒜 m) (hm : 0 < m) (x : Proj.T| pbo f) :\n    FromSpec.toFun f_deg hm (toSpec 𝒜 f x) = x := by\n  refine Subtype.ext <| ProjectiveSpectrum.ext <| HomogeneousIdeal.ext' ?_\n  intros i z hzi\n  refine (FromSpec.mem_carrier_iff_of_mem f_deg hm _ _ hzi).trans ?_\n  exact (ToSpec.mk_mem_carrier _ _).trans (x.1.2.pow_mem_iff_mem m hm)\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.toSpec_injective","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nhm : LT.lt 0 m\n⊢ Function.Injective ⇑(AlgebraicGeometry.ProjIsoSpecTopComponent.toSpec 𝒜 f)","decl":"lemma toSpec_injective {f : A} {m : ℕ} (f_deg : f ∈ 𝒜 m) (hm : 0 < m) :\n    Function.Injective (toSpec 𝒜 f) := by\n  intro x₁ x₂ h\n  have := congr_arg (FromSpec.toFun f_deg hm) h\n  rwa [fromSpec_toSpec, fromSpec_toSpec] at this\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.toSpec_surjective","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nhm : LT.lt 0 m\n⊢ Function.Surjective ⇑(AlgebraicGeometry.ProjIsoSpecTopComponent.toSpec 𝒜 f)","decl":"lemma toSpec_surjective {f : A} {m : ℕ} (f_deg : f ∈ 𝒜 m) (hm : 0 < m) :\n    Function.Surjective (toSpec 𝒜 f) :=\n  Function.surjective_iff_hasRightInverse |>.mpr\n    ⟨FromSpec.toFun f_deg hm, toSpec_fromSpec 𝒜 f_deg hm⟩\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.toSpec_bijective","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nhm : LT.lt 0 m\n⊢ Function.Bijective ⇑(AlgebraicGeometry.ProjIsoSpecTopComponent.toSpec 𝒜 f)","decl":"lemma toSpec_bijective {f : A} {m : ℕ} (f_deg : f ∈ 𝒜 m) (hm : 0 < m) :\n    Function.Bijective (toSpec (𝒜 := 𝒜) (f := f)) :=\n  ⟨toSpec_injective 𝒜 f_deg hm, toSpec_surjective 𝒜 f_deg hm⟩\n\n"}
{"name":"AlgebraicGeometry.ProjIsoSpecTopComponent.toSpec.image_basicOpen_eq_basicOpen","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nhm : LT.lt 0 m\na : A\ni : Nat\n⊢ Eq (Set.image (⇑(AlgebraicGeometry.ProjIsoSpecTopComponent.toSpec 𝒜 f)) (Set.preimage Subtype.val ↑(ProjectiveSpectrum.basicOpen 𝒜 ↑(((DirectSum.decompose 𝒜) a) i)))) (PrimeSpectrum.basicOpen (HomogeneousLocalization.mk { deg := HMul.hMul m i, num := ⟨HPow.hPow (↑(((DirectSum.decompose 𝒜) a) i)) m, ⋯⟩, den := ⟨HPow.hPow f i, ⋯⟩, den_mem := ⋯ })).carrier","decl":"variable {𝒜} in\nlemma image_basicOpen_eq_basicOpen (a : A) (i : ℕ) :\n    toSpec 𝒜 f '' (Subtype.val ⁻¹' (pbo (decompose 𝒜 a i) : Set (ProjectiveSpectrum 𝒜))) =\n    (PrimeSpectrum.basicOpen (R := A⁰_ f) <|\n      HomogeneousLocalization.mk\n        ⟨m * i, ⟨decompose 𝒜 a i ^ m,\n          (smul_eq_mul ℕ) ▸ SetLike.pow_mem_graded _ (Submodule.coe_mem _)⟩,\n          ⟨f^i, by rw [mul_comm]; exact SetLike.pow_mem_graded _ f_deg⟩, ⟨i, rfl⟩⟩).1 :=\n  Set.preimage_injective.mpr (toSpec_surjective 𝒜 f_deg hm) <|\n    Set.preimage_image_eq _ (toSpec_injective 𝒜 f_deg hm) ▸ by\n  rw [Opens.carrier_eq_coe, toSpec_preimage_basicOpen, ProjectiveSpectrum.basicOpen_pow 𝒜 _ m hm]\n\n"}
{"name":"AlgebraicGeometry.ProjectiveSpectrum.Proj.awayToSection_germ","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nx : ↑(ProjectiveSpectrum.top 𝒜)\nhx : Membership.mem (ProjectiveSpectrum.basicOpen 𝒜 f) x\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.ProjectiveSpectrum.Proj.awayToSection 𝒜 f) ((AlgebraicGeometry.ProjectiveSpectrum.Proj.structureSheaf 𝒜).presheaf.germ (ProjectiveSpectrum.basicOpen 𝒜 f) x hx)) (CategoryTheory.CategoryStruct.comp (CommRingCat.ofHom (HomogeneousLocalization.mapId 𝒜 ⋯)) (AlgebraicGeometry.Proj.stalkIso' 𝒜 x).toCommRingCatIso.inv)","decl":"lemma awayToSection_germ (f x hx) :\n    awayToSection 𝒜 f ≫ (structureSheaf 𝒜).presheaf.germ _ x hx =\n      CommRingCat.ofHom (HomogeneousLocalization.mapId 𝒜 (Submonoid.powers_le.mpr hx)) ≫\n        (Proj.stalkIso' 𝒜 x).toCommRingCatIso.inv := by\n  ext z\n  apply (Proj.stalkIso' 𝒜 x).eq_symm_apply.mpr\n  apply Proj.stalkIso'_germ\n\n"}
{"name":"AlgebraicGeometry.ProjectiveSpectrum.Proj.awayToSection_apply","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nx : ↑(CommRingCat.of (HomogeneousLocalization.Away 𝒜 f))\np : Subtype fun x => Membership.mem (Opposite.unop { unop := ProjectiveSpectrum.basicOpen 𝒜 f }) x\n⊢ Eq (HomogeneousLocalization.val (↑((AlgebraicGeometry.ProjectiveSpectrum.Proj.awayToSection 𝒜 f).hom' x) p)) ((IsLocalization.map (Localization (↑p).asHomogeneousIdeal.toIdeal.primeCompl) (RingHom.id A) ⋯) (HomogeneousLocalization.val x))","decl":"lemma awayToSection_apply (f : A) (x p) :\n    (((ProjectiveSpectrum.Proj.awayToSection 𝒜 f).1 x).val p).val =\n      IsLocalization.map (M := Submonoid.powers f) (T := p.1.1.toIdeal.primeCompl) _\n        (RingHom.id _) (Submonoid.powers_le.mpr p.2) x.val := by\n  obtain ⟨x, rfl⟩ := HomogeneousLocalization.mk_surjective x\n  show (HomogeneousLocalization.mapId 𝒜 _ _).val = _\n  dsimp [HomogeneousLocalization.mapId, HomogeneousLocalization.map]\n  rw [Localization.mk_eq_mk', Localization.mk_eq_mk', IsLocalization.map_mk']\n  rfl\n\n"}
{"name":"AlgebraicGeometry.ProjectiveSpectrum.Proj.awayToΓ_ΓToStalk","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nx : ↑↑((AlgebraicGeometry.Proj.toLocallyRingedSpace 𝒜).restrict ⋯).toPresheafedSpace\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.ProjectiveSpectrum.Proj.awayToΓ 𝒜 f) (((AlgebraicGeometry.Proj.toLocallyRingedSpace 𝒜).restrict ⋯).presheaf.Γgerm x)) (CategoryTheory.CategoryStruct.comp (CommRingCat.ofHom (HomogeneousLocalization.mapId 𝒜 ⋯)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Proj.stalkIso' 𝒜 ↑x).toCommRingCatIso.inv ((AlgebraicGeometry.Proj.toLocallyRingedSpace 𝒜).restrictStalkIso ⋯ x).inv))","decl":"lemma awayToΓ_ΓToStalk (f) (x) :\n    awayToΓ 𝒜 f ≫ (Proj| pbo f).presheaf.Γgerm x =\n      CommRingCat.ofHom (HomogeneousLocalization.mapId 𝒜 (Submonoid.powers_le.mpr x.2)) ≫\n      (Proj.stalkIso' 𝒜 x.1).toCommRingCatIso.inv ≫\n      ((Proj.toLocallyRingedSpace 𝒜).restrictStalkIso (Opens.isOpenEmbedding _) x).inv := by\n  rw [awayToΓ, Category.assoc, ← Category.assoc _ (Iso.inv _),\n    Iso.eq_comp_inv, Category.assoc, Category.assoc, Presheaf.Γgerm]\n  rw [LocallyRingedSpace.restrictStalkIso_hom_eq_germ]\n  simp only [Proj.toLocallyRingedSpace, Proj.toSheafedSpace]\n  rw [Presheaf.germ_res, awayToSection_germ]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.ProjectiveSpectrum.Proj.toSpec_base_apply_eq_comap","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nx : ↑((AlgebraicGeometry.Proj.toLocallyRingedSpace 𝒜).restrict ⋯).toTopCat\n⊢ Eq ((AlgebraicGeometry.ProjectiveSpectrum.Proj.toSpec 𝒜 f).base x) ((PrimeSpectrum.comap (HomogeneousLocalization.mapId 𝒜 ⋯)) (IsLocalRing.closedPoint (HomogeneousLocalization.AtPrime 𝒜 (↑x).asHomogeneousIdeal.toIdeal)))","decl":"lemma toSpec_base_apply_eq_comap {f} (x : Proj| pbo f) :\n    (toSpec 𝒜 f).base x = PrimeSpectrum.comap (mapId 𝒜 (Submonoid.powers_le.mpr x.2))\n      (closedPoint (AtPrime 𝒜 x.1.asHomogeneousIdeal.toIdeal)) := by\n  show PrimeSpectrum.comap (awayToΓ 𝒜 f ≫ (Proj| pbo f).presheaf.Γgerm x).hom\n        (IsLocalRing.closedPoint ((Proj| pbo f).presheaf.stalk x)) = _\n  rw [awayToΓ_ΓToStalk, CommRingCat.hom_comp, PrimeSpectrum.comap_comp]\n  exact congr(PrimeSpectrum.comap _ $(@IsLocalRing.comap_closedPoint\n    (HomogeneousLocalization.AtPrime 𝒜 x.1.asHomogeneousIdeal.toIdeal) _ _\n    ((Proj| pbo f).presheaf.stalk x) _ _ _ (isLocalHom_of_isIso _)))\n\n"}
{"name":"AlgebraicGeometry.ProjectiveSpectrum.Proj.toSpec_base_apply_eq","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nx : ↑((AlgebraicGeometry.Proj.toLocallyRingedSpace 𝒜).restrict ⋯).toTopCat\n⊢ Eq ((AlgebraicGeometry.ProjectiveSpectrum.Proj.toSpec 𝒜 f).base x) ((AlgebraicGeometry.ProjIsoSpecTopComponent.toSpec 𝒜 f) x)","decl":"lemma toSpec_base_apply_eq {f} (x : Proj| pbo f) :\n    (toSpec 𝒜 f).base x = ProjIsoSpecTopComponent.toSpec 𝒜 f x :=\n  toSpec_base_apply_eq_comap 𝒜 x |>.trans <| PrimeSpectrum.ext <| Ideal.ext fun z =>\n  show ¬ IsUnit _ ↔ z ∈ ProjIsoSpecTopComponent.ToSpec.carrier _ by\n  obtain ⟨z, rfl⟩ := z.mk_surjective\n  rw [← HomogeneousLocalization.isUnit_iff_isUnit_val,\n    ProjIsoSpecTopComponent.ToSpec.mk_mem_carrier, HomogeneousLocalization.map_mk,\n    HomogeneousLocalization.val_mk, Localization.mk_eq_mk',\n    IsLocalization.AtPrime.isUnit_mk'_iff]\n  exact not_not\n\n"}
{"name":"AlgebraicGeometry.ProjectiveSpectrum.Proj.toSpec_base_isIso","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nhm : LT.lt 0 m\n⊢ CategoryTheory.IsIso (AlgebraicGeometry.ProjectiveSpectrum.Proj.toSpec 𝒜 f).base","decl":"lemma toSpec_base_isIso {f} {m} (f_deg : f ∈ 𝒜 m) (hm : 0 < m) :\n    IsIso (toSpec 𝒜 f).base := by\n  convert (projIsoSpecTopComponent f_deg hm).isIso_hom\n  exact DFunLike.ext _ _ <| toSpec_base_apply_eq 𝒜\n\n"}
{"name":"AlgebraicGeometry.ProjectiveSpectrum.Proj.mk_mem_toSpec_base_apply","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nx : ↑((AlgebraicGeometry.Proj.toLocallyRingedSpace 𝒜).restrict ⋯).toTopCat\nz : HomogeneousLocalization.NumDenSameDeg 𝒜 (Submonoid.powers f)\n⊢ Iff (Membership.mem ((AlgebraicGeometry.ProjectiveSpectrum.Proj.toSpec 𝒜 f).base x).asIdeal (HomogeneousLocalization.mk z)) (Membership.mem (↑x).asHomogeneousIdeal ↑z.num)","decl":"lemma mk_mem_toSpec_base_apply {f} (x : Proj| pbo f)\n    (z : NumDenSameDeg 𝒜 (.powers f)) :\n    HomogeneousLocalization.mk z ∈ ((toSpec 𝒜 f).base x).asIdeal ↔\n      z.num.1 ∈ x.1.asHomogeneousIdeal :=\n  (toSpec_base_apply_eq 𝒜 x).symm ▸ ProjIsoSpecTopComponent.ToSpec.mk_mem_carrier _ _\n\n"}
{"name":"AlgebraicGeometry.ProjectiveSpectrum.Proj.toSpec_preimage_basicOpen","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nt : HomogeneousLocalization.NumDenSameDeg 𝒜 (Submonoid.powers f)\n⊢ Eq ((TopologicalSpace.Opens.map (AlgebraicGeometry.ProjectiveSpectrum.Proj.toSpec 𝒜 f).base).obj (PrimeSpectrum.basicOpen (HomogeneousLocalization.mk t))) ((TopologicalSpace.Opens.comap { toFun := Subtype.val, continuous_toFun := ⋯ }) (ProjectiveSpectrum.basicOpen 𝒜 ↑t.num))","decl":"lemma toSpec_preimage_basicOpen {f}\n    (t : NumDenSameDeg 𝒜 (.powers f)) :\n    (Opens.map (toSpec 𝒜 f).base).obj (sbo (HomogeneousLocalization.mk t)) =\n      Opens.comap ⟨_, continuous_subtype_val⟩ (pbo t.num.1) :=\n  Opens.ext <| Opens.map_coe _ _ ▸ by\n  convert (ProjIsoSpecTopComponent.ToSpec.preimage_basicOpen f t)\n  exact funext fun _ => toSpec_base_apply_eq _ _\n\n"}
{"name":"AlgebraicGeometry.ProjectiveSpectrum.Proj.toOpen_toSpec_val_c_app_assoc","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nU : Opposite (TopologicalSpace.Opens ↑↑(AlgebraicGeometry.Spec.locallyRingedSpaceObj (CommRingCat.of (HomogeneousLocalization.Away 𝒜 f))).toPresheafedSpace)\nZ : CommRingCat\nh : Quiver.Hom (((TopCat.Presheaf.pushforward CommRingCat (AlgebraicGeometry.ProjectiveSpectrum.Proj.toSpec 𝒜 f).base).obj ((AlgebraicGeometry.Proj.toLocallyRingedSpace 𝒜).restrict ⋯).presheaf).obj U) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toOpen (HomogeneousLocalization.Away 𝒜 f) (Opposite.unop U)) (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.ProjectiveSpectrum.Proj.toSpec 𝒜 f).c.app U) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.ProjectiveSpectrum.Proj.awayToΓ 𝒜 f) (CategoryTheory.CategoryStruct.comp (((AlgebraicGeometry.Proj.toLocallyRingedSpace 𝒜).restrict ⋯).presheaf.map (CategoryTheory.homOfLE ⋯).op) h))","decl":"@[reassoc]\nlemma toOpen_toSpec_val_c_app (f) (U) :\n    StructureSheaf.toOpen (A⁰_ f) U.unop ≫ (toSpec 𝒜 f).c.app U =\n      awayToΓ 𝒜 f ≫ (Proj| pbo f).presheaf.map (homOfLE le_top).op :=\n  Eq.trans (by congr) <| ΓSpec.toOpen_comp_locallyRingedSpaceAdjunction_homEquiv_app _ U\n\n"}
{"name":"AlgebraicGeometry.ProjectiveSpectrum.Proj.toOpen_toSpec_val_c_app","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nU : Opposite (TopologicalSpace.Opens ↑↑(AlgebraicGeometry.Spec.locallyRingedSpaceObj (CommRingCat.of (HomogeneousLocalization.Away 𝒜 f))).toPresheafedSpace)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toOpen (HomogeneousLocalization.Away 𝒜 f) (Opposite.unop U)) ((AlgebraicGeometry.ProjectiveSpectrum.Proj.toSpec 𝒜 f).c.app U)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.ProjectiveSpectrum.Proj.awayToΓ 𝒜 f) (((AlgebraicGeometry.Proj.toLocallyRingedSpace 𝒜).restrict ⋯).presheaf.map (CategoryTheory.homOfLE ⋯).op))","decl":"@[reassoc]\nlemma toOpen_toSpec_val_c_app (f) (U) :\n    StructureSheaf.toOpen (A⁰_ f) U.unop ≫ (toSpec 𝒜 f).c.app U =\n      awayToΓ 𝒜 f ≫ (Proj| pbo f).presheaf.map (homOfLE le_top).op :=\n  Eq.trans (by congr) <| ΓSpec.toOpen_comp_locallyRingedSpaceAdjunction_homEquiv_app _ U\n\n"}
{"name":"AlgebraicGeometry.ProjectiveSpectrum.Proj.toStalk_stalkMap_toSpec","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nx : ↑((AlgebraicGeometry.Proj.toLocallyRingedSpace 𝒜).restrict ⋯).toTopCat\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toStalk (↑(CommRingCat.of (HomogeneousLocalization.Away 𝒜 f))) ((AlgebraicGeometry.ProjectiveSpectrum.Proj.toSpec 𝒜 f).base x)) (AlgebraicGeometry.LocallyRingedSpace.Hom.stalkMap (AlgebraicGeometry.ProjectiveSpectrum.Proj.toSpec 𝒜 f) x)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.ProjectiveSpectrum.Proj.awayToΓ 𝒜 f) (((AlgebraicGeometry.Proj.toLocallyRingedSpace 𝒜).restrict ⋯).presheaf.Γgerm x))","decl":"@[reassoc]\nlemma toStalk_stalkMap_toSpec (f) (x) :\n    StructureSheaf.toStalk _ _ ≫ (toSpec 𝒜 f).stalkMap x =\n      awayToΓ 𝒜 f ≫ (Proj| pbo f).presheaf.Γgerm x := by\n  rw [StructureSheaf.toStalk, Category.assoc]\n  simp_rw [← Spec.locallyRingedSpaceObj_presheaf']\n  rw [LocallyRingedSpace.stalkMap_germ (toSpec 𝒜 f),\n    toOpen_toSpec_val_c_app_assoc, Presheaf.germ_res]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.ProjectiveSpectrum.Proj.toStalk_stalkMap_toSpec_assoc","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nx : ↑((AlgebraicGeometry.Proj.toLocallyRingedSpace 𝒜).restrict ⋯).toTopCat\nZ : CommRingCat\nh : Quiver.Hom (((AlgebraicGeometry.Proj.toLocallyRingedSpace 𝒜).restrict ⋯).presheaf.stalk x) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toStalk (HomogeneousLocalization.Away 𝒜 f) ((AlgebraicGeometry.ProjectiveSpectrum.Proj.toSpec 𝒜 f).base x)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.LocallyRingedSpace.Hom.stalkMap (AlgebraicGeometry.ProjectiveSpectrum.Proj.toSpec 𝒜 f) x) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.ProjectiveSpectrum.Proj.awayToΓ 𝒜 f) (CategoryTheory.CategoryStruct.comp (((AlgebraicGeometry.Proj.toLocallyRingedSpace 𝒜).restrict ⋯).presheaf.Γgerm x) h))","decl":"@[reassoc]\nlemma toStalk_stalkMap_toSpec (f) (x) :\n    StructureSheaf.toStalk _ _ ≫ (toSpec 𝒜 f).stalkMap x =\n      awayToΓ 𝒜 f ≫ (Proj| pbo f).presheaf.Γgerm x := by\n  rw [StructureSheaf.toStalk, Category.assoc]\n  simp_rw [← Spec.locallyRingedSpaceObj_presheaf']\n  rw [LocallyRingedSpace.stalkMap_germ (toSpec 𝒜 f),\n    toOpen_toSpec_val_c_app_assoc, Presheaf.germ_res]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.ProjectiveSpectrum.Proj.isLocalization_atPrime","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nx : Subtype fun x => Membership.mem (ProjectiveSpectrum.basicOpen 𝒜 f) x\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nhm : LT.lt 0 m\n⊢ IsLocalization ((AlgebraicGeometry.ProjectiveSpectrum.Proj.toSpec 𝒜 f).base x).asIdeal.primeCompl (HomogeneousLocalization.AtPrime 𝒜 (↑x).asHomogeneousIdeal.toIdeal)","decl":"/--\nIf `x` is a point in the basic open set `D(f)` where `f` is a homogeneous element of positive\ndegree, then the homogeneously localized ring `A⁰ₓ` has the universal property of the localization\nof `A⁰_f` at `φ(x)` where `φ : Proj|D(f) ⟶ Spec A⁰_f` is the morphism of locally ringed space\nconstructed as above.\n-/\nlemma isLocalization_atPrime (f) (x : pbo f) {m} (f_deg : f ∈ 𝒜 m) (hm : 0 < m) :\n    @IsLocalization (Away 𝒜 f) _ ((toSpec 𝒜 f).base x).asIdeal.primeCompl\n      (AtPrime 𝒜 x.1.asHomogeneousIdeal.toIdeal) _\n      (mapId 𝒜 (Submonoid.powers_le.mpr x.2)).toAlgebra := by\n  letI : Algebra (Away 𝒜 f) (AtPrime 𝒜 x.1.asHomogeneousIdeal.toIdeal) :=\n    (mapId 𝒜 (Submonoid.powers_le.mpr x.2)).toAlgebra\n  constructor\n  · rintro ⟨y, hy⟩\n    obtain ⟨y, rfl⟩ := HomogeneousLocalization.mk_surjective y\n    refine isUnit_of_mul_eq_one _\n      (.mk ⟨y.deg, y.den, y.num, (mk_mem_toSpec_base_apply _ _ _).not.mp hy⟩) <| val_injective _ ?_\n    simp only [RingHom.algebraMap_toAlgebra, map_mk, RingHom.id_apply, val_mul, val_mk, mk_eq_mk',\n      val_one, IsLocalization.mk'_mul_mk'_eq_one']\n  · intro z\n    obtain ⟨⟨i, a, ⟨b, hb⟩, (hb' : b ∉ x.1.1)⟩, rfl⟩ := z.mk_surjective\n    refine ⟨⟨HomogeneousLocalization.mk ⟨i * m, ⟨a * b ^ (m - 1), ?_⟩,\n        ⟨f ^ i, SetLike.pow_mem_graded _ f_deg⟩, ⟨_, rfl⟩⟩,\n      ⟨HomogeneousLocalization.mk ⟨i * m, ⟨b ^ m, mul_comm m i ▸ SetLike.pow_mem_graded _ hb⟩,\n        ⟨f ^ i, SetLike.pow_mem_graded _ f_deg⟩, ⟨_, rfl⟩⟩,\n        (mk_mem_toSpec_base_apply _ _ _).not.mpr <| x.1.1.toIdeal.primeCompl.pow_mem hb' m⟩⟩,\n        val_injective _ ?_⟩\n    · convert SetLike.mul_mem_graded a.2 (SetLike.pow_mem_graded (m - 1) hb) using 2\n      rw [← succ_nsmul', tsub_add_cancel_of_le (by omega), mul_comm, smul_eq_mul]\n    · simp only [RingHom.algebraMap_toAlgebra, map_mk, RingHom.id_apply, val_mul, val_mk,\n        mk_eq_mk', ← IsLocalization.mk'_mul, Submonoid.mk_mul_mk, IsLocalization.mk'_eq_iff_eq]\n      rw [mul_comm b, mul_mul_mul_comm, ← pow_succ', mul_assoc, tsub_add_cancel_of_le (by omega)]\n  · intros y z e\n    obtain ⟨y, rfl⟩ := HomogeneousLocalization.mk_surjective y\n    obtain ⟨z, rfl⟩ := HomogeneousLocalization.mk_surjective z\n    obtain ⟨i, c, hc, hc', e⟩ : ∃ i, ∃ c ∈ 𝒜 i, c ∉ x.1.asHomogeneousIdeal ∧\n        c * (z.den.1 * y.num.1) = c * (y.den.1 * z.num.1) := by\n      apply_fun HomogeneousLocalization.val at e\n      simp only [RingHom.algebraMap_toAlgebra, map_mk, RingHom.id_apply, val_mk, mk_eq_mk',\n        IsLocalization.mk'_eq_iff_eq] at e\n      obtain ⟨⟨c, hcx⟩, hc⟩ := IsLocalization.exists_of_eq (M := x.1.1.toIdeal.primeCompl) e\n      obtain ⟨i, hi⟩ := not_forall.mp ((x.1.1.isHomogeneous.mem_iff _).not.mp hcx)\n      refine ⟨i, _, (decompose 𝒜 c i).2, hi, ?_⟩\n      apply_fun fun x ↦ (decompose 𝒜 x (i + z.deg + y.deg)).1 at hc\n      conv_rhs at hc => rw [add_right_comm]\n      rwa [← mul_assoc, coe_decompose_mul_add_of_right_mem, coe_decompose_mul_add_of_right_mem,\n        ← mul_assoc, coe_decompose_mul_add_of_right_mem, coe_decompose_mul_add_of_right_mem,\n        mul_assoc, mul_assoc] at hc\n      exacts [y.den.2, z.num.2, z.den.2, y.num.2]\n\n    refine ⟨⟨HomogeneousLocalization.mk ⟨m * i, ⟨c ^ m, SetLike.pow_mem_graded _ hc⟩,\n      ⟨f ^ i, mul_comm m i ▸ SetLike.pow_mem_graded _ f_deg⟩, ⟨_, rfl⟩⟩,\n      (mk_mem_toSpec_base_apply _ _ _).not.mpr <| x.1.1.toIdeal.primeCompl.pow_mem hc' _⟩,\n      val_injective _ ?_⟩\n    simp only [val_mul, val_mk, mk_eq_mk', ← IsLocalization.mk'_mul, Submonoid.mk_mul_mk,\n      IsLocalization.mk'_eq_iff_eq, mul_assoc]\n    congr 2\n    rw [mul_left_comm, mul_left_comm y.den.1, ← tsub_add_cancel_of_le (show 1 ≤ m from hm),\n      pow_succ, mul_assoc, mul_assoc, e]\n\n"}
{"name":"AlgebraicGeometry.ProjectiveSpectrum.Proj.toStalk_specStalkEquiv","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nx : Subtype fun x => Membership.mem (ProjectiveSpectrum.basicOpen 𝒜 f) x\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nhm : LT.lt 0 m\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toStalk (HomogeneousLocalization.Away 𝒜 f) ((AlgebraicGeometry.ProjectiveSpectrum.Proj.toSpec 𝒜 f).base x)) (AlgebraicGeometry.ProjectiveSpectrum.Proj.specStalkEquiv 𝒜 f x f_deg hm).hom) (CommRingCat.ofHom (HomogeneousLocalization.mapId 𝒜 ⋯))","decl":"lemma toStalk_specStalkEquiv (f) (x : pbo f) {m} (f_deg : f ∈ 𝒜 m) (hm : 0 < m) :\n    StructureSheaf.toStalk (A⁰_ f) ((toSpec 𝒜 f).base x) ≫ (specStalkEquiv 𝒜 f x f_deg hm).hom =\n      CommRingCat.ofHom (mapId _ <| Submonoid.powers_le.mpr x.2) :=\n  letI : Algebra (Away 𝒜 f) (AtPrime 𝒜 x.1.asHomogeneousIdeal.toIdeal) :=\n    (mapId 𝒜 (Submonoid.powers_le.mpr x.2)).toAlgebra\n  letI := isLocalization_atPrime 𝒜 f x f_deg hm\n  CommRingCat.hom_ext (IsLocalization.algEquiv\n    (R := A⁰_ f)\n    (M := ((toSpec 𝒜 f).base x).asIdeal.primeCompl)\n    (S := (Spec.structureSheaf (A⁰_ f)).presheaf.stalk ((toSpec 𝒜 f).base x))\n    (Q := AtPrime 𝒜 x.1.asHomogeneousIdeal.toIdeal)).toAlgHom.comp_algebraMap\n\n"}
{"name":"AlgebraicGeometry.ProjectiveSpectrum.Proj.stalkMap_toSpec","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nx : Subtype fun x => Membership.mem (ProjectiveSpectrum.basicOpen 𝒜 f) x\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nhm : LT.lt 0 m\n⊢ Eq (AlgebraicGeometry.LocallyRingedSpace.Hom.stalkMap (AlgebraicGeometry.ProjectiveSpectrum.Proj.toSpec 𝒜 f) x) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.ProjectiveSpectrum.Proj.specStalkEquiv 𝒜 f x f_deg hm).hom (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Proj.stalkIso' 𝒜 ↑x).toCommRingCatIso.inv ((AlgebraicGeometry.Proj.toLocallyRingedSpace 𝒜).restrictStalkIso ⋯ x).inv))","decl":"lemma stalkMap_toSpec (f) (x : pbo f) {m} (f_deg : f ∈ 𝒜 m) (hm : 0 < m) :\n    (toSpec 𝒜 f).stalkMap x =\n      (specStalkEquiv 𝒜 f x f_deg hm).hom ≫ (Proj.stalkIso' 𝒜 x.1).toCommRingCatIso.inv ≫\n      ((Proj.toLocallyRingedSpace 𝒜).restrictStalkIso (Opens.isOpenEmbedding _) x).inv :=\n  CommRingCat.hom_ext <|\n    IsLocalization.ringHom_ext (R := A⁰_ f) ((toSpec 𝒜 f).base x).asIdeal.primeCompl\n      (S := (Spec.structureSheaf (A⁰_ f)).presheaf.stalk ((toSpec 𝒜 f).base x)) <|\n      CommRingCat.hom_ext_iff.mp <|\n        (toStalk_stalkMap_toSpec _ _ _).trans <| by\n        rw [awayToΓ_ΓToStalk, ← toStalk_specStalkEquiv, Category.assoc]; rfl\n\n"}
{"name":"AlgebraicGeometry.ProjectiveSpectrum.Proj.isIso_toSpec","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nf : A\nm : Nat\nf_deg : Membership.mem (𝒜 m) f\nhm : LT.lt 0 m\n⊢ CategoryTheory.IsIso (AlgebraicGeometry.ProjectiveSpectrum.Proj.toSpec 𝒜 f)","decl":"lemma isIso_toSpec (f) {m} (f_deg : f ∈ 𝒜 m) (hm : 0 < m) :\n    IsIso (toSpec 𝒜 f) := by\n  haveI : IsIso (toSpec 𝒜 f).base := toSpec_base_isIso 𝒜 f_deg hm\n  haveI (x) : IsIso ((toSpec 𝒜 f).stalkMap x) := by\n    rw [stalkMap_toSpec 𝒜 f x f_deg hm]; infer_instance\n  haveI : LocallyRingedSpace.IsOpenImmersion (toSpec 𝒜 f) :=\n    LocallyRingedSpace.IsOpenImmersion.of_stalk_iso (toSpec 𝒜 f)\n      (TopCat.homeoOfIso (asIso <| (toSpec 𝒜 f).base)).isOpenEmbedding\n  exact LocallyRingedSpace.IsOpenImmersion.to_iso _\n\n"}
