{"name":"star_natCast_smul","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : StarAddMonoid M\nn : Nat\nx : M\n⊢ Eq (Star.star (HSMul.hSMul (↑n) x)) (HSMul.hSMul (↑n) (Star.star x))","decl":"@[simp]\ntheorem star_natCast_smul [Semiring R] [AddCommMonoid M] [Module R M] [StarAddMonoid M] (n : ℕ)\n    (x : M) : star ((n : R) • x) = (n : R) • star x :=\n  map_natCast_smul (starAddEquiv : M ≃+ M) R R n x\n\n"}
{"name":"star_intCast_smul","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : StarAddMonoid M\nn : Int\nx : M\n⊢ Eq (Star.star (HSMul.hSMul (↑n) x)) (HSMul.hSMul (↑n) (Star.star x))","decl":"@[simp]\ntheorem star_intCast_smul [Ring R] [AddCommGroup M] [Module R M] [StarAddMonoid M] (n : ℤ)\n    (x : M) : star ((n : R) • x) = (n : R) • star x :=\n  map_intCast_smul (starAddEquiv : M ≃+ M) R R n x\n\n"}
{"name":"star_inv_natCast_smul","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : DivisionSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : StarAddMonoid M\nn : Nat\nx : M\n⊢ Eq (Star.star (HSMul.hSMul (Inv.inv ↑n) x)) (HSMul.hSMul (Inv.inv ↑n) (Star.star x))","decl":"@[simp]\ntheorem star_inv_natCast_smul [DivisionSemiring R] [AddCommMonoid M] [Module R M] [StarAddMonoid M]\n    (n : ℕ) (x : M) : star ((n⁻¹ : R) • x) = (n⁻¹ : R) • star x :=\n  map_inv_natCast_smul (starAddEquiv : M ≃+ M) R R n x\n\n"}
{"name":"star_inv_intCast_smul","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : DivisionRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : StarAddMonoid M\nn : Int\nx : M\n⊢ Eq (Star.star (HSMul.hSMul (Inv.inv ↑n) x)) (HSMul.hSMul (Inv.inv ↑n) (Star.star x))","decl":"@[simp]\ntheorem star_inv_intCast_smul [DivisionRing R] [AddCommGroup M] [Module R M] [StarAddMonoid M]\n    (n : ℤ) (x : M) : star ((n⁻¹ : R) • x) = (n⁻¹ : R) • star x :=\n  map_inv_intCast_smul (starAddEquiv : M ≃+ M) R R n x\n\n"}
{"name":"star_ratCast_smul","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : DivisionRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : StarAddMonoid M\nn : Rat\nx : M\n⊢ Eq (Star.star (HSMul.hSMul (↑n) x)) (HSMul.hSMul (↑n) (Star.star x))","decl":"@[simp]\ntheorem star_ratCast_smul [DivisionRing R] [AddCommGroup M] [Module R M] [StarAddMonoid M] (n : ℚ)\n    (x : M) : star ((n : R) • x) = (n : R) • star x :=\n  map_ratCast_smul (starAddEquiv : M ≃+ M) _ _ _ x\n\n"}
{"name":"star_nnrat_smul","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\ninst✝² : AddCommMonoid R\ninst✝¹ : StarAddMonoid R\ninst✝ : Module NNRat R\nq : NNRat\nx : R\n⊢ Eq (Star.star (HSMul.hSMul q x)) (HSMul.hSMul q (Star.star x))","decl":"/-- Note that this lemma holds for an arbitrary `ℚ≥0`-action, rather than merely one coming from a\n`DivisionSemiring`. We keep both the `nnqsmul` and `nnrat_smul` naming conventions for\ndiscoverability. See `star_nnqsmul`. -/\n@[simp high]\nlemma star_nnrat_smul [AddCommMonoid R] [StarAddMonoid R] [Module ℚ≥0 R] (q : ℚ≥0) (x : R) :\n    star (q • x) = q • star x := map_nnrat_smul (starAddEquiv : R ≃+ R) _ _\n\n"}
{"name":"star_rat_smul","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\ninst✝² : AddCommGroup R\ninst✝¹ : StarAddMonoid R\ninst✝ : Module Rat R\nq : Rat\nx : R\n⊢ Eq (Star.star (HSMul.hSMul q x)) (HSMul.hSMul q (Star.star x))","decl":"/-- Note that this lemma holds for an arbitrary `ℚ`-action, rather than merely one coming from a\n`DivisionRing`. We keep both the `qsmul` and `rat_smul` naming conventions for discoverability.\nSee `star_qsmul`. -/\n@[simp high] lemma star_rat_smul [AddCommGroup R] [StarAddMonoid R] [Module ℚ R] (q : ℚ) (x : R) :\n    star (q • x) = q • star x :=\n  map_rat_smul (starAddEquiv : R ≃+ R) _ _\n\n"}
{"name":"star_nnqsmul","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\ninst✝² : AddCommMonoid R\ninst✝¹ : StarAddMonoid R\ninst✝ : Module NNRat R\nq : NNRat\nx : R\n⊢ Eq (Star.star (HSMul.hSMul q x)) (HSMul.hSMul q (Star.star x))","decl":"/-- Note that this lemma holds for an arbitrary `ℚ≥0`-action, rather than merely one coming from a\n`DivisionSemiring`. We keep both the `nnqsmul` and `nnrat_smul` naming conventions for\ndiscoverability. See `star_nnrat_smul`. -/\nalias star_nnqsmul := star_nnrat_smul\n\n"}
{"name":"star_qsmul","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\ninst✝² : AddCommGroup R\ninst✝¹ : StarAddMonoid R\ninst✝ : Module Rat R\nq : Rat\nx : R\n⊢ Eq (Star.star (HSMul.hSMul q x)) (HSMul.hSMul q (Star.star x))","decl":"/-- Note that this lemma holds for an arbitrary `ℚ`-action, rather than merely one coming from a\n`DivisionRing`. We keep both the `qsmul` and `rat_smul` naming conventions for\ndiscoverability. See `star_rat_smul`. -/\nalias star_qsmul := star_rat_smul\n\n"}
{"name":"StarAddMonoid.toStarModuleNNRat","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\ninst✝² : AddCommMonoid R\ninst✝¹ : Module NNRat R\ninst✝ : StarAddMonoid R\n⊢ StarModule NNRat R","decl":"instance StarAddMonoid.toStarModuleNNRat [AddCommMonoid R] [Module ℚ≥0 R] [StarAddMonoid R] :\n    StarModule ℚ≥0 R where star_smul := star_nnrat_smul\n\n"}
{"name":"StarAddMonoid.toStarModuleRat","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\ninst✝² : AddCommGroup R\ninst✝¹ : Module Rat R\ninst✝ : StarAddMonoid R\n⊢ StarModule Rat R","decl":"instance StarAddMonoid.toStarModuleRat [AddCommGroup R] [Module ℚ R] [StarAddMonoid R] :\n    StarModule ℚ R where star_smul := star_rat_smul\n\n"}
{"name":"starLinearEquiv_symm_apply","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : StarRing R\ninst✝³ : AddCommMonoid A\ninst✝² : StarAddMonoid A\ninst✝¹ : Module R A\ninst✝ : StarModule R A\na✝ : A\n⊢ Eq ((starLinearEquiv R).symm a✝) (starAddEquiv.invFun a✝)","decl":"/-- If `A` is a module over a commutative `R` with compatible actions,\nthen `star` is a semilinear equivalence. -/\n@[simps]\ndef starLinearEquiv (R : Type*) {A : Type*} [CommSemiring R] [StarRing R] [AddCommMonoid A]\n    [StarAddMonoid A] [Module R A] [StarModule R A] : A ≃ₗ⋆[R] A :=\n  { starAddEquiv with\n    toFun := star\n    map_smul' := star_smul }\n\n"}
{"name":"starLinearEquiv_apply","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : StarRing R\ninst✝³ : AddCommMonoid A\ninst✝² : StarAddMonoid A\ninst✝¹ : Module R A\ninst✝ : StarModule R A\na✝ : A\n⊢ Eq ((starLinearEquiv R) a✝) (Star.star a✝)","decl":"/-- If `A` is a module over a commutative `R` with compatible actions,\nthen `star` is a semilinear equivalence. -/\n@[simps]\ndef starLinearEquiv (R : Type*) {A : Type*} [CommSemiring R] [StarRing R] [AddCommMonoid A]\n    [StarAddMonoid A] [Module R A] [StarModule R A] : A ≃ₗ⋆[R] A :=\n  { starAddEquiv with\n    toFun := star\n    map_smul' := star_smul }\n\n"}
{"name":"selfAdjointPart_apply_coe","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁷ : Semiring R\ninst✝⁶ : StarMul R\ninst✝⁵ : TrivialStar R\ninst✝⁴ : AddCommGroup A\ninst✝³ : Module R A\ninst✝² : StarAddMonoid A\ninst✝¹ : StarModule R A\ninst✝ : Invertible 2\nx : A\n⊢ Eq (↑((selfAdjointPart R) x)) (HSMul.hSMul (Invertible.invOf 2) (HAdd.hAdd x (Star.star x)))","decl":"/-- The self-adjoint part of an element of a star module, as a linear map. -/\n@[simps]\ndef selfAdjointPart : A →ₗ[R] selfAdjoint A where\n  toFun x :=\n    ⟨(⅟ 2 : R) • (x + star x), by\n      rw [selfAdjoint.mem_iff, star_smul, star_trivial, star_add, star_star, add_comm]⟩\n  map_add' x y := by\n    ext\n    simp [add_add_add_comm]\n  map_smul' r x := by\n    ext\n    simp [← mul_smul, show ⅟ 2 * r = r * ⅟ 2 from Commute.invOf_left <| (2 : ℕ).cast_commute r]\n\n"}
{"name":"skewAdjointPart_apply_coe","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁷ : Semiring R\ninst✝⁶ : StarMul R\ninst✝⁵ : TrivialStar R\ninst✝⁴ : AddCommGroup A\ninst✝³ : Module R A\ninst✝² : StarAddMonoid A\ninst✝¹ : StarModule R A\ninst✝ : Invertible 2\nx : A\n⊢ Eq (↑((skewAdjointPart R) x)) (HSMul.hSMul (Invertible.invOf 2) (HSub.hSub x (Star.star x)))","decl":"/-- The skew-adjoint part of an element of a star module, as a linear map. -/\n@[simps]\ndef skewAdjointPart : A →ₗ[R] skewAdjoint A where\n  toFun x :=\n    ⟨(⅟ 2 : R) • (x - star x), by\n      simp only [skewAdjoint.mem_iff, star_smul, star_sub, star_star, star_trivial, ← smul_neg,\n        neg_sub]⟩\n  map_add' x y := by\n    ext\n    simp only [sub_add, ← smul_add, sub_sub_eq_add_sub, star_add, AddSubgroup.coe_mk,\n      AddSubgroup.coe_add]\n  map_smul' r x := by\n    ext\n    simp [← mul_smul, ← smul_sub,\n      show r * ⅟ 2 = ⅟ 2 * r from Commute.invOf_right <| (2 : ℕ).commute_cast r]\n\n"}
{"name":"StarModule.selfAdjointPart_add_skewAdjointPart","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁷ : Semiring R\ninst✝⁶ : StarMul R\ninst✝⁵ : TrivialStar R\ninst✝⁴ : AddCommGroup A\ninst✝³ : Module R A\ninst✝² : StarAddMonoid A\ninst✝¹ : StarModule R A\ninst✝ : Invertible 2\nx : A\n⊢ Eq (HAdd.hAdd ↑((selfAdjointPart R) x) ↑((skewAdjointPart R) x)) x","decl":"theorem StarModule.selfAdjointPart_add_skewAdjointPart (x : A) :\n    (selfAdjointPart R x : A) + skewAdjointPart R x = x := by\n  simp only [smul_sub, selfAdjointPart_apply_coe, smul_add, skewAdjointPart_apply_coe,\n    add_add_sub_cancel, invOf_two_smul_add_invOf_two_smul]\n\n"}
{"name":"IsSelfAdjoint.coe_selfAdjointPart_apply","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁷ : Semiring R\ninst✝⁶ : StarMul R\ninst✝⁵ : TrivialStar R\ninst✝⁴ : AddCommGroup A\ninst✝³ : Module R A\ninst✝² : StarAddMonoid A\ninst✝¹ : StarModule R A\ninst✝ : Invertible 2\nx : A\nhx : IsSelfAdjoint x\n⊢ Eq (↑((selfAdjointPart R) x)) x","decl":"theorem IsSelfAdjoint.coe_selfAdjointPart_apply {x : A} (hx : IsSelfAdjoint x) :\n    (selfAdjointPart R x : A) = x := by\n  rw [selfAdjointPart_apply_coe, hx.star_eq, smul_add, invOf_two_smul_add_invOf_two_smul]\n\n"}
{"name":"IsSelfAdjoint.selfAdjointPart_apply","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁷ : Semiring R\ninst✝⁶ : StarMul R\ninst✝⁵ : TrivialStar R\ninst✝⁴ : AddCommGroup A\ninst✝³ : Module R A\ninst✝² : StarAddMonoid A\ninst✝¹ : StarModule R A\ninst✝ : Invertible 2\nx : A\nhx : IsSelfAdjoint x\n⊢ Eq ((selfAdjointPart R) x) ⟨x, hx⟩","decl":"theorem IsSelfAdjoint.selfAdjointPart_apply {x : A} (hx : IsSelfAdjoint x) :\n    selfAdjointPart R x = ⟨x, hx⟩ :=\n  Subtype.eq (hx.coe_selfAdjointPart_apply R)\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: make it a `simp`\n"}
{"name":"selfAdjointPart_comp_subtype_selfAdjoint","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁷ : Semiring R\ninst✝⁶ : StarMul R\ninst✝⁵ : TrivialStar R\ninst✝⁴ : AddCommGroup A\ninst✝³ : Module R A\ninst✝² : StarAddMonoid A\ninst✝¹ : StarModule R A\ninst✝ : Invertible 2\n⊢ Eq ((selfAdjointPart R).comp (selfAdjoint.submodule R A).subtype) LinearMap.id","decl":"theorem selfAdjointPart_comp_subtype_selfAdjoint :\n    (selfAdjointPart R).comp (selfAdjoint.submodule R A).subtype = .id :=\n  LinearMap.ext fun x ↦ x.2.selfAdjointPart_apply R\n\n"}
{"name":"IsSelfAdjoint.skewAdjointPart_apply","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁷ : Semiring R\ninst✝⁶ : StarMul R\ninst✝⁵ : TrivialStar R\ninst✝⁴ : AddCommGroup A\ninst✝³ : Module R A\ninst✝² : StarAddMonoid A\ninst✝¹ : StarModule R A\ninst✝ : Invertible 2\nx : A\nhx : IsSelfAdjoint x\n⊢ Eq ((skewAdjointPart R) x) 0","decl":"theorem IsSelfAdjoint.skewAdjointPart_apply {x : A} (hx : IsSelfAdjoint x) :\n    skewAdjointPart R x = 0 := Subtype.eq <| by\n  rw [skewAdjointPart_apply_coe, hx.star_eq, sub_self, smul_zero, ZeroMemClass.coe_zero]\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: make it a `simp`\n"}
{"name":"skewAdjointPart_comp_subtype_selfAdjoint","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁷ : Semiring R\ninst✝⁶ : StarMul R\ninst✝⁵ : TrivialStar R\ninst✝⁴ : AddCommGroup A\ninst✝³ : Module R A\ninst✝² : StarAddMonoid A\ninst✝¹ : StarModule R A\ninst✝ : Invertible 2\n⊢ Eq ((skewAdjointPart R).comp (selfAdjoint.submodule R A).subtype) 0","decl":"theorem skewAdjointPart_comp_subtype_selfAdjoint :\n    (skewAdjointPart R).comp (selfAdjoint.submodule R A).subtype = 0 :=\n  LinearMap.ext fun x ↦ x.2.skewAdjointPart_apply R\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: make it a `simp`\n"}
{"name":"selfAdjointPart_comp_subtype_skewAdjoint","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁷ : Semiring R\ninst✝⁶ : StarMul R\ninst✝⁵ : TrivialStar R\ninst✝⁴ : AddCommGroup A\ninst✝³ : Module R A\ninst✝² : StarAddMonoid A\ninst✝¹ : StarModule R A\ninst✝ : Invertible 2\n⊢ Eq ((selfAdjointPart R).comp (skewAdjoint.submodule R A).subtype) 0","decl":"theorem selfAdjointPart_comp_subtype_skewAdjoint :\n    (selfAdjointPart R).comp (skewAdjoint.submodule R A).subtype = 0 :=\n  LinearMap.ext fun ⟨x, (hx : _ = _)⟩ ↦ Subtype.eq <| by simp [hx]\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: make it a `simp`\n"}
{"name":"skewAdjointPart_comp_subtype_skewAdjoint","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁷ : Semiring R\ninst✝⁶ : StarMul R\ninst✝⁵ : TrivialStar R\ninst✝⁴ : AddCommGroup A\ninst✝³ : Module R A\ninst✝² : StarAddMonoid A\ninst✝¹ : StarModule R A\ninst✝ : Invertible 2\n⊢ Eq ((skewAdjointPart R).comp (skewAdjoint.submodule R A).subtype) LinearMap.id","decl":"theorem skewAdjointPart_comp_subtype_skewAdjoint :\n    (skewAdjointPart R).comp (skewAdjoint.submodule R A).subtype = .id :=\n  LinearMap.ext fun ⟨x, (hx : _ = _)⟩ ↦ Subtype.eq <| by\n    simp only [LinearMap.comp_apply, Submodule.subtype_apply, skewAdjointPart_apply_coe, hx,\n      sub_neg_eq_add, smul_add, invOf_two_smul_add_invOf_two_smul]; rfl\n\n"}
{"name":"StarModule.decomposeProdAdjoint_apply","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁷ : Semiring R\ninst✝⁶ : StarMul R\ninst✝⁵ : TrivialStar R\ninst✝⁴ : AddCommGroup A\ninst✝³ : Module R A\ninst✝² : StarAddMonoid A\ninst✝¹ : StarModule R A\ninst✝ : Invertible 2\ni : A\n⊢ Eq ((StarModule.decomposeProdAdjoint R A) i) { fst := (selfAdjointPart R) i, snd := (skewAdjointPart R) i }","decl":"/-- The decomposition of elements of a star module into their self- and skew-adjoint parts,\nas a linear equivalence. -/\n-- Porting note: This attribute causes a `timeout at 'whnf'`.\n@[simps!]\ndef StarModule.decomposeProdAdjoint : A ≃ₗ[R] selfAdjoint A × skewAdjoint A := by\n  refine LinearEquiv.ofLinear ((selfAdjointPart R).prod (skewAdjointPart R))\n    (LinearMap.coprod ((selfAdjoint.submodule R A).subtype) (skewAdjoint.submodule R A).subtype)\n    ?_ (LinearMap.ext <| StarModule.selfAdjointPart_add_skewAdjointPart R)\n  -- Note: with https://github.com/leanprover-community/mathlib4/pull/6965 `Submodule.coe_subtype` doesn't fire in `dsimp` or `simp`\n  ext x <;> dsimp <;> erw [Submodule.coe_subtype, Submodule.coe_subtype] <;> simp\n\n"}
{"name":"StarModule.decomposeProdAdjoint_symm_apply","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁷ : Semiring R\ninst✝⁶ : StarMul R\ninst✝⁵ : TrivialStar R\ninst✝⁴ : AddCommGroup A\ninst✝³ : Module R A\ninst✝² : StarAddMonoid A\ninst✝¹ : StarModule R A\ninst✝ : Invertible 2\na : Prod (Subtype fun x => Membership.mem (selfAdjoint A) x) (Subtype fun x => Membership.mem (skewAdjoint A) x)\n⊢ Eq ((StarModule.decomposeProdAdjoint R A).symm a) (HAdd.hAdd ((selfAdjoint.submodule R A).subtype a.1) ((skewAdjoint.submodule R A).subtype a.2))","decl":"/-- The decomposition of elements of a star module into their self- and skew-adjoint parts,\nas a linear equivalence. -/\n-- Porting note: This attribute causes a `timeout at 'whnf'`.\n@[simps!]\ndef StarModule.decomposeProdAdjoint : A ≃ₗ[R] selfAdjoint A × skewAdjoint A := by\n  refine LinearEquiv.ofLinear ((selfAdjointPart R).prod (skewAdjointPart R))\n    (LinearMap.coprod ((selfAdjoint.submodule R A).subtype) (skewAdjoint.submodule R A).subtype)\n    ?_ (LinearMap.ext <| StarModule.selfAdjointPart_add_skewAdjointPart R)\n  -- Note: with https://github.com/leanprover-community/mathlib4/pull/6965 `Submodule.coe_subtype` doesn't fire in `dsimp` or `simp`\n  ext x <;> dsimp <;> erw [Submodule.coe_subtype, Submodule.coe_subtype] <;> simp\n\n"}
{"name":"algebraMap_star_comm","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : StarRing R\ninst✝³ : Semiring A\ninst✝² : StarMul A\ninst✝¹ : Algebra R A\ninst✝ : StarModule R A\nr : R\n⊢ Eq ((algebraMap R A) (Star.star r)) (Star.star ((algebraMap R A) r))","decl":"@[simp]\ntheorem algebraMap_star_comm (r : R) : algebraMap R A (star r) = star (algebraMap R A r) := by\n  simp only [Algebra.algebraMap_eq_smul_one, star_smul, star_one]\n\n"}
{"name":"IsSelfAdjoint.algebraMap","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : StarRing R\ninst✝³ : Semiring A\ninst✝² : StarMul A\ninst✝¹ : Algebra R A\ninst✝ : StarModule R A\nr : R\nhr : IsSelfAdjoint r\n⊢ IsSelfAdjoint ((algebraMap R A) r)","decl":"variable (A) in\nprotected lemma IsSelfAdjoint.algebraMap {r : R} (hr : IsSelfAdjoint r) :\n    IsSelfAdjoint (algebraMap R A r) := by\n  simpa using congr(algebraMap R A $(hr.star_eq))\n\n"}
{"name":"isSelfAdjoint_algebraMap_iff","module":"Mathlib.Algebra.Star.Module","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : StarRing R\ninst✝³ : Semiring A\ninst✝² : StarMul A\ninst✝¹ : Algebra R A\ninst✝ : StarModule R A\nr : R\nh : Function.Injective ⇑(algebraMap R A)\n⊢ Iff (IsSelfAdjoint ((algebraMap R A) r)) (IsSelfAdjoint r)","decl":"lemma isSelfAdjoint_algebraMap_iff {r : R} (h : Function.Injective (algebraMap R A)) :\n    IsSelfAdjoint (algebraMap R A r) ↔ IsSelfAdjoint r :=\n  ⟨fun hr ↦ h <| algebraMap_star_comm r (A := A) ▸ hr.star_eq, IsSelfAdjoint.algebraMap A⟩\n\n"}
