{"name":"LieRing.lie_add","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nself : LieRing L\nx y z : L\n⊢ Eq (Bracket.bracket x (HAdd.hAdd y z)) (HAdd.hAdd (Bracket.bracket x y) (Bracket.bracket x z))","decl":"/-- A Lie ring is an additive group with compatible product, known as the bracket, satisfying the\nJacobi identity. -/\nclass LieRing (L : Type v) extends AddCommGroup L, Bracket L L where\n  /-- A Lie ring bracket is additive in its first component. -/\n  protected add_lie : ∀ x y z : L, ⁅x + y, z⁆ = ⁅x, z⁆ + ⁅y, z⁆\n  /-- A Lie ring bracket is additive in its second component. -/\n  protected lie_add : ∀ x y z : L, ⁅x, y + z⁆ = ⁅x, y⁆ + ⁅x, z⁆\n  /-- A Lie ring bracket vanishes on the diagonal in L × L. -/\n  protected lie_self : ∀ x : L, ⁅x, x⁆ = 0\n  /-- A Lie ring bracket satisfies a Leibniz / Jacobi identity. -/\n  protected leibniz_lie : ∀ x y z : L, ⁅x, ⁅y, z⁆⁆ = ⁅⁅x, y⁆, z⁆ + ⁅y, ⁅x, z⁆⁆\n\n"}
{"name":"LieRing.leibniz_lie","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nself : LieRing L\nx y z : L\n⊢ Eq (Bracket.bracket x (Bracket.bracket y z)) (HAdd.hAdd (Bracket.bracket (Bracket.bracket x y) z) (Bracket.bracket y (Bracket.bracket x z)))","decl":"/-- A Lie ring is an additive group with compatible product, known as the bracket, satisfying the\nJacobi identity. -/\nclass LieRing (L : Type v) extends AddCommGroup L, Bracket L L where\n  /-- A Lie ring bracket is additive in its first component. -/\n  protected add_lie : ∀ x y z : L, ⁅x + y, z⁆ = ⁅x, z⁆ + ⁅y, z⁆\n  /-- A Lie ring bracket is additive in its second component. -/\n  protected lie_add : ∀ x y z : L, ⁅x, y + z⁆ = ⁅x, y⁆ + ⁅x, z⁆\n  /-- A Lie ring bracket vanishes on the diagonal in L × L. -/\n  protected lie_self : ∀ x : L, ⁅x, x⁆ = 0\n  /-- A Lie ring bracket satisfies a Leibniz / Jacobi identity. -/\n  protected leibniz_lie : ∀ x y z : L, ⁅x, ⁅y, z⁆⁆ = ⁅⁅x, y⁆, z⁆ + ⁅y, ⁅x, z⁆⁆\n\n"}
{"name":"LieRing.lie_self","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nself : LieRing L\nx : L\n⊢ Eq (Bracket.bracket x x) 0","decl":"/-- A Lie ring is an additive group with compatible product, known as the bracket, satisfying the\nJacobi identity. -/\nclass LieRing (L : Type v) extends AddCommGroup L, Bracket L L where\n  /-- A Lie ring bracket is additive in its first component. -/\n  protected add_lie : ∀ x y z : L, ⁅x + y, z⁆ = ⁅x, z⁆ + ⁅y, z⁆\n  /-- A Lie ring bracket is additive in its second component. -/\n  protected lie_add : ∀ x y z : L, ⁅x, y + z⁆ = ⁅x, y⁆ + ⁅x, z⁆\n  /-- A Lie ring bracket vanishes on the diagonal in L × L. -/\n  protected lie_self : ∀ x : L, ⁅x, x⁆ = 0\n  /-- A Lie ring bracket satisfies a Leibniz / Jacobi identity. -/\n  protected leibniz_lie : ∀ x y z : L, ⁅x, ⁅y, z⁆⁆ = ⁅⁅x, y⁆, z⁆ + ⁅y, ⁅x, z⁆⁆\n\n"}
{"name":"LieRing.add_lie","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nself : LieRing L\nx y z : L\n⊢ Eq (Bracket.bracket (HAdd.hAdd x y) z) (HAdd.hAdd (Bracket.bracket x z) (Bracket.bracket y z))","decl":"/-- A Lie ring is an additive group with compatible product, known as the bracket, satisfying the\nJacobi identity. -/\nclass LieRing (L : Type v) extends AddCommGroup L, Bracket L L where\n  /-- A Lie ring bracket is additive in its first component. -/\n  protected add_lie : ∀ x y z : L, ⁅x + y, z⁆ = ⁅x, z⁆ + ⁅y, z⁆\n  /-- A Lie ring bracket is additive in its second component. -/\n  protected lie_add : ∀ x y z : L, ⁅x, y + z⁆ = ⁅x, y⁆ + ⁅x, z⁆\n  /-- A Lie ring bracket vanishes on the diagonal in L × L. -/\n  protected lie_self : ∀ x : L, ⁅x, x⁆ = 0\n  /-- A Lie ring bracket satisfies a Leibniz / Jacobi identity. -/\n  protected leibniz_lie : ∀ x y z : L, ⁅x, ⁅y, z⁆⁆ = ⁅⁅x, y⁆, z⁆ + ⁅y, ⁅x, z⁆⁆\n\n"}
{"name":"LieAlgebra.lie_smul","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\ninst✝¹ : CommRing R\ninst✝ : LieRing L\nself : LieAlgebra R L\nt : R\nx y : L\n⊢ Eq (Bracket.bracket x (HSMul.hSMul t y)) (HSMul.hSMul t (Bracket.bracket x y))","decl":"/-- A Lie algebra is a module with compatible product, known as the bracket, satisfying the Jacobi\nidentity. Forgetting the scalar multiplication, every Lie algebra is a Lie ring. -/\nclass LieAlgebra (R : Type u) (L : Type v) [CommRing R] [LieRing L] extends Module R L where\n  /-- A Lie algebra bracket is compatible with scalar multiplication in its second argument.\n\n  The compatibility in the first argument is not a class property, but follows since every\n  Lie algebra has a natural Lie module action on itself, see `LieModule`. -/\n  protected lie_smul : ∀ (t : R) (x y : L), ⁅x, t • y⁆ = t • ⁅x, y⁆\n\n"}
{"name":"LieRingModule.add_lie","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nM : Type w\ninst✝¹ : LieRing L\ninst✝ : AddCommGroup M\nself : LieRingModule L M\nx y : L\nm : M\n⊢ Eq (Bracket.bracket (HAdd.hAdd x y) m) (HAdd.hAdd (Bracket.bracket x m) (Bracket.bracket y m))","decl":"/-- A Lie ring module is an additive group, together with an additive action of a\nLie ring on this group, such that the Lie bracket acts as the commutator of endomorphisms.\n(For representations of Lie *algebras* see `LieModule`.) -/\nclass LieRingModule (L : Type v) (M : Type w) [LieRing L] [AddCommGroup M] extends Bracket L M where\n  /-- A Lie ring module bracket is additive in its first component. -/\n  protected add_lie : ∀ (x y : L) (m : M), ⁅x + y, m⁆ = ⁅x, m⁆ + ⁅y, m⁆\n  /-- A Lie ring module bracket is additive in its second component. -/\n  protected lie_add : ∀ (x : L) (m n : M), ⁅x, m + n⁆ = ⁅x, m⁆ + ⁅x, n⁆\n  /-- A Lie ring module bracket satisfies a Leibniz / Jacobi identity. -/\n  protected leibniz_lie : ∀ (x y : L) (m : M), ⁅x, ⁅y, m⁆⁆ = ⁅⁅x, y⁆, m⁆ + ⁅y, ⁅x, m⁆⁆\n\n"}
{"name":"LieRingModule.lie_add","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nM : Type w\ninst✝¹ : LieRing L\ninst✝ : AddCommGroup M\nself : LieRingModule L M\nx : L\nm n : M\n⊢ Eq (Bracket.bracket x (HAdd.hAdd m n)) (HAdd.hAdd (Bracket.bracket x m) (Bracket.bracket x n))","decl":"/-- A Lie ring module is an additive group, together with an additive action of a\nLie ring on this group, such that the Lie bracket acts as the commutator of endomorphisms.\n(For representations of Lie *algebras* see `LieModule`.) -/\nclass LieRingModule (L : Type v) (M : Type w) [LieRing L] [AddCommGroup M] extends Bracket L M where\n  /-- A Lie ring module bracket is additive in its first component. -/\n  protected add_lie : ∀ (x y : L) (m : M), ⁅x + y, m⁆ = ⁅x, m⁆ + ⁅y, m⁆\n  /-- A Lie ring module bracket is additive in its second component. -/\n  protected lie_add : ∀ (x : L) (m n : M), ⁅x, m + n⁆ = ⁅x, m⁆ + ⁅x, n⁆\n  /-- A Lie ring module bracket satisfies a Leibniz / Jacobi identity. -/\n  protected leibniz_lie : ∀ (x y : L) (m : M), ⁅x, ⁅y, m⁆⁆ = ⁅⁅x, y⁆, m⁆ + ⁅y, ⁅x, m⁆⁆\n\n"}
{"name":"LieRingModule.leibniz_lie","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nM : Type w\ninst✝¹ : LieRing L\ninst✝ : AddCommGroup M\nself : LieRingModule L M\nx y : L\nm : M\n⊢ Eq (Bracket.bracket x (Bracket.bracket y m)) (HAdd.hAdd (Bracket.bracket (Bracket.bracket x y) m) (Bracket.bracket y (Bracket.bracket x m)))","decl":"/-- A Lie ring module is an additive group, together with an additive action of a\nLie ring on this group, such that the Lie bracket acts as the commutator of endomorphisms.\n(For representations of Lie *algebras* see `LieModule`.) -/\nclass LieRingModule (L : Type v) (M : Type w) [LieRing L] [AddCommGroup M] extends Bracket L M where\n  /-- A Lie ring module bracket is additive in its first component. -/\n  protected add_lie : ∀ (x y : L) (m : M), ⁅x + y, m⁆ = ⁅x, m⁆ + ⁅y, m⁆\n  /-- A Lie ring module bracket is additive in its second component. -/\n  protected lie_add : ∀ (x : L) (m n : M), ⁅x, m + n⁆ = ⁅x, m⁆ + ⁅x, n⁆\n  /-- A Lie ring module bracket satisfies a Leibniz / Jacobi identity. -/\n  protected leibniz_lie : ∀ (x y : L) (m : M), ⁅x, ⁅y, m⁆⁆ = ⁅⁅x, y⁆, m⁆ + ⁅y, ⁅x, m⁆⁆\n\n"}
{"name":"LieModule.lie_smul","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nself : LieModule R L M\nt : R\nx : L\nm : M\n⊢ Eq (Bracket.bracket x (HSMul.hSMul t m)) (HSMul.hSMul t (Bracket.bracket x m))","decl":"/-- A Lie module is a module over a commutative ring, together with a linear action of a Lie\nalgebra on this module, such that the Lie bracket acts as the commutator of endomorphisms. -/\nclass LieModule (R : Type u) (L : Type v) (M : Type w) [CommRing R] [LieRing L] [LieAlgebra R L]\n  [AddCommGroup M] [Module R M] [LieRingModule L M] : Prop where\n  /-- A Lie module bracket is compatible with scalar multiplication in its first argument. -/\n  protected smul_lie : ∀ (t : R) (x : L) (m : M), ⁅t • x, m⁆ = t • ⁅x, m⁆\n  /-- A Lie module bracket is compatible with scalar multiplication in its second argument. -/\n  protected lie_smul : ∀ (t : R) (x : L) (m : M), ⁅x, t • m⁆ = t • ⁅x, m⁆\n\n"}
{"name":"LieModule.smul_lie","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nself : LieModule R L M\nt : R\nx : L\nm : M\n⊢ Eq (Bracket.bracket (HSMul.hSMul t x) m) (HSMul.hSMul t (Bracket.bracket x m))","decl":"/-- A Lie module is a module over a commutative ring, together with a linear action of a Lie\nalgebra on this module, such that the Lie bracket acts as the commutator of endomorphisms. -/\nclass LieModule (R : Type u) (L : Type v) (M : Type w) [CommRing R] [LieRing L] [LieAlgebra R L]\n  [AddCommGroup M] [Module R M] [LieRingModule L M] : Prop where\n  /-- A Lie module bracket is compatible with scalar multiplication in its first argument. -/\n  protected smul_lie : ∀ (t : R) (x : L) (m : M), ⁅t • x, m⁆ = t • ⁅x, m⁆\n  /-- A Lie module bracket is compatible with scalar multiplication in its second argument. -/\n  protected lie_smul : ∀ (t : R) (x : L) (m : M), ⁅x, t • m⁆ = t • ⁅x, m⁆\n\n"}
{"name":"IsLieTower.leibniz_lie","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L₁ : Type u_1\nL₂ : Type u_2\nM : Type u_3\ninst✝³ : Bracket L₁ L₂\ninst✝² : Bracket L₁ M\ninst✝¹ : Bracket L₂ M\ninst✝ : Add M\nself : IsLieTower L₁ L₂ M\nx : L₁\ny : L₂\nm : M\n⊢ Eq (Bracket.bracket x (Bracket.bracket y m)) (HAdd.hAdd (Bracket.bracket (Bracket.bracket x y) m) (Bracket.bracket y (Bracket.bracket x m)))","decl":"/-- A tower of Lie bracket actions encapsulates the Leibniz rule for Lie bracket actions.\n\nMore precisely, it does so in a relative setting:\nLet `L₁` and `L₂` be two types with Lie bracket actions on a type `M` endowed with an addition,\nand additionally assume a Lie bracket action of `L₁` on `L₂`.\nThen the Leibniz rule asserts for all `x : L₁`, `y : L₂`, and `m : M` that\n`⁅x, ⁅y, m⁆⁆ = ⁅⁅x, y⁆, m⁆ + ⁅y, ⁅x, m⁆⁆` holds.\n\nCommon examples include the case where `L₁` is a Lie subalgebra of `L₂`\nand the case where `L₂` is a Lie ideal of `L₁`. -/\nclass IsLieTower (L₁ L₂ M : Type*) [Bracket L₁ L₂] [Bracket L₁ M] [Bracket L₂ M] [Add M] where\n  protected leibniz_lie (x : L₁) (y : L₂) (m : M) : ⁅x, ⁅y, m⁆⁆ = ⁅⁅x, y⁆, m⁆ + ⁅y, ⁅x, m⁆⁆\n\n"}
{"name":"leibniz_lie","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L₁ : Type u_1\nL₂ : Type u_2\nM : Type u_3\ninst✝⁴ : Bracket L₁ L₂\ninst✝³ : Bracket L₁ M\ninst✝² : Bracket L₂ M\ninst✝¹ : Add M\ninst✝ : IsLieTower L₁ L₂ M\nx : L₁\ny : L₂\nm : M\n⊢ Eq (Bracket.bracket x (Bracket.bracket y m)) (HAdd.hAdd (Bracket.bracket (Bracket.bracket x y) m) (Bracket.bracket y (Bracket.bracket x m)))","decl":"lemma leibniz_lie [Add M] [IsLieTower L₁ L₂ M] (x : L₁) (y : L₂) (m : M) :\n    ⁅x, ⁅y, m⁆⁆ = ⁅⁅x, y⁆, m⁆ + ⁅y, ⁅x, m⁆⁆ := IsLieTower.leibniz_lie x y m\n\n"}
{"name":"lie_swap_lie","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L₁ : Type u_1\nL₂ : Type u_2\nM : Type u_3\ninst✝⁶ : Bracket L₁ L₂\ninst✝⁵ : Bracket L₁ M\ninst✝⁴ : Bracket L₂ M\ninst✝³ : Bracket L₂ L₁\ninst✝² : AddCommGroup M\ninst✝¹ : IsLieTower L₁ L₂ M\ninst✝ : IsLieTower L₂ L₁ M\nx : L₁\ny : L₂\nm : M\n⊢ Eq (Bracket.bracket (Bracket.bracket x y) m) (Neg.neg (Bracket.bracket (Bracket.bracket y x) m))","decl":"lemma lie_swap_lie [Bracket L₂ L₁] [AddCommGroup M] [IsLieTower L₁ L₂ M] [IsLieTower L₂ L₁ M]\n    (x : L₁) (y : L₂) (m : M) : ⁅⁅x, y⁆, m⁆ = -⁅⁅y, x⁆, m⁆ := by\n  have h1 := leibniz_lie x y m\n  have h2 := leibniz_lie y x m\n  convert congr($h1.symm - $h2) using 1 <;> simp only [add_sub_cancel_right, sub_add_cancel_right]\n\n"}
{"name":"add_lie","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nM : Type w\ninst✝² : LieRing L\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L M\nx y : L\nm : M\n⊢ Eq (Bracket.bracket (HAdd.hAdd x y) m) (HAdd.hAdd (Bracket.bracket x m) (Bracket.bracket y m))","decl":"@[simp]\ntheorem add_lie : ⁅x + y, m⁆ = ⁅x, m⁆ + ⁅y, m⁆ :=\n  LieRingModule.add_lie x y m\n\n"}
{"name":"lie_add","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nM : Type w\ninst✝² : LieRing L\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L M\nx : L\nm n : M\n⊢ Eq (Bracket.bracket x (HAdd.hAdd m n)) (HAdd.hAdd (Bracket.bracket x m) (Bracket.bracket x n))","decl":"@[simp]\ntheorem lie_add : ⁅x, m + n⁆ = ⁅x, m⁆ + ⁅x, n⁆ :=\n  LieRingModule.lie_add x m n\n\n"}
{"name":"smul_lie","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nt : R\nx : L\nm : M\n⊢ Eq (Bracket.bracket (HSMul.hSMul t x) m) (HSMul.hSMul t (Bracket.bracket x m))","decl":"@[simp]\ntheorem smul_lie : ⁅t • x, m⁆ = t • ⁅x, m⁆ :=\n  LieModule.smul_lie t x m\n\n"}
{"name":"lie_smul","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nt : R\nx : L\nm : M\n⊢ Eq (Bracket.bracket x (HSMul.hSMul t m)) (HSMul.hSMul t (Bracket.bracket x m))","decl":"@[simp]\ntheorem lie_smul : ⁅x, t • m⁆ = t • ⁅x, m⁆ :=\n  LieModule.lie_smul t x m\n\n"}
{"name":"instIsLieTower","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nM : Type w\ninst✝² : LieRing L\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L M\n⊢ IsLieTower L L M","decl":"instance : IsLieTower L L M where\n  leibniz_lie x y m := LieRingModule.leibniz_lie x y m\n\n"}
{"name":"lie_zero","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nM : Type w\ninst✝² : LieRing L\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L M\nx : L\n⊢ Eq (Bracket.bracket x 0) 0","decl":"@[simp]\ntheorem lie_zero : ⁅x, 0⁆ = (0 : M) :=\n  (AddMonoidHom.mk' _ (lie_add x)).map_zero\n\n"}
{"name":"zero_lie","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nM : Type w\ninst✝² : LieRing L\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L M\nm : M\n⊢ Eq (Bracket.bracket 0 m) 0","decl":"@[simp]\ntheorem zero_lie : ⁅(0 : L), m⁆ = 0 :=\n  (AddMonoidHom.mk' (fun x : L => ⁅x, m⁆) fun x y => add_lie x y m).map_zero\n\n"}
{"name":"lie_self","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\ninst✝ : LieRing L\nx : L\n⊢ Eq (Bracket.bracket x x) 0","decl":"@[simp]\ntheorem lie_self : ⁅x, x⁆ = 0 :=\n  LieRing.lie_self x\n\n"}
{"name":"lie_skew","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\ninst✝ : LieRing L\nx y : L\n⊢ Eq (Neg.neg (Bracket.bracket y x)) (Bracket.bracket x y)","decl":"@[simp]\ntheorem lie_skew : -⁅y, x⁆ = ⁅x, y⁆ := by\n  have h : ⁅x + y, x⁆ + ⁅x + y, y⁆ = 0 := by rw [← lie_add]; apply lie_self\n  simpa [neg_eq_iff_add_eq_zero] using h\n\n"}
{"name":"lieAlgebraSelfModule","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ LieModule R L L","decl":"/-- Every Lie algebra is a module over itself. -/\ninstance lieAlgebraSelfModule : LieModule R L L where\n  smul_lie t x m := by rw [← lie_skew, ← lie_skew x m, LieAlgebra.lie_smul, smul_neg]\n  lie_smul := by apply LieAlgebra.lie_smul\n\n"}
{"name":"neg_lie","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nM : Type w\ninst✝² : LieRing L\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L M\nx : L\nm : M\n⊢ Eq (Bracket.bracket (Neg.neg x) m) (Neg.neg (Bracket.bracket x m))","decl":"@[simp]\ntheorem neg_lie : ⁅-x, m⁆ = -⁅x, m⁆ := by\n  rw [← sub_eq_zero, sub_neg_eq_add, ← add_lie]\n  simp\n\n"}
{"name":"lie_neg","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nM : Type w\ninst✝² : LieRing L\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L M\nx : L\nm : M\n⊢ Eq (Bracket.bracket x (Neg.neg m)) (Neg.neg (Bracket.bracket x m))","decl":"@[simp]\ntheorem lie_neg : ⁅x, -m⁆ = -⁅x, m⁆ := by\n  rw [← sub_eq_zero, sub_neg_eq_add, ← lie_add]\n  simp\n\n"}
{"name":"sub_lie","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nM : Type w\ninst✝² : LieRing L\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L M\nx y : L\nm : M\n⊢ Eq (Bracket.bracket (HSub.hSub x y) m) (HSub.hSub (Bracket.bracket x m) (Bracket.bracket y m))","decl":"@[simp]\ntheorem sub_lie : ⁅x - y, m⁆ = ⁅x, m⁆ - ⁅y, m⁆ := by simp [sub_eq_add_neg]\n\n"}
{"name":"lie_sub","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nM : Type w\ninst✝² : LieRing L\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L M\nx : L\nm n : M\n⊢ Eq (Bracket.bracket x (HSub.hSub m n)) (HSub.hSub (Bracket.bracket x m) (Bracket.bracket x n))","decl":"@[simp]\ntheorem lie_sub : ⁅x, m - n⁆ = ⁅x, m⁆ - ⁅x, n⁆ := by simp [sub_eq_add_neg]\n\n"}
{"name":"nsmul_lie","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nM : Type w\ninst✝² : LieRing L\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L M\nx : L\nm : M\nn : Nat\n⊢ Eq (Bracket.bracket (HSMul.hSMul n x) m) (HSMul.hSMul n (Bracket.bracket x m))","decl":"@[simp]\ntheorem nsmul_lie (n : ℕ) : ⁅n • x, m⁆ = n • ⁅x, m⁆ :=\n  AddMonoidHom.map_nsmul\n    { toFun := fun x : L => ⁅x, m⁆, map_zero' := zero_lie m, map_add' := fun _ _ => add_lie _ _ _ }\n    _ _\n\n"}
{"name":"lie_nsmul","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nM : Type w\ninst✝² : LieRing L\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L M\nx : L\nm : M\nn : Nat\n⊢ Eq (Bracket.bracket x (HSMul.hSMul n m)) (HSMul.hSMul n (Bracket.bracket x m))","decl":"@[simp]\ntheorem lie_nsmul (n : ℕ) : ⁅x, n • m⁆ = n • ⁅x, m⁆ :=\n  AddMonoidHom.map_nsmul\n    { toFun := fun m : M => ⁅x, m⁆, map_zero' := lie_zero x, map_add' := fun _ _ => lie_add _ _ _}\n    _ _\n\n"}
{"name":"zsmul_lie","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nM : Type w\ninst✝² : LieRing L\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L M\nx : L\nm : M\na : Int\n⊢ Eq (Bracket.bracket (HSMul.hSMul a x) m) (HSMul.hSMul a (Bracket.bracket x m))","decl":"theorem zsmul_lie (a : ℤ) : ⁅a • x, m⁆ = a • ⁅x, m⁆ :=\n  AddMonoidHom.map_zsmul\n    { toFun := fun x : L => ⁅x, m⁆, map_zero' := zero_lie m, map_add' := fun _ _ => add_lie _ _ _ }\n    _ _\n\n"}
{"name":"lie_zsmul","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nM : Type w\ninst✝² : LieRing L\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L M\nx : L\nm : M\na : Int\n⊢ Eq (Bracket.bracket x (HSMul.hSMul a m)) (HSMul.hSMul a (Bracket.bracket x m))","decl":"theorem lie_zsmul (a : ℤ) : ⁅x, a • m⁆ = a • ⁅x, m⁆ :=\n  AddMonoidHom.map_zsmul\n    { toFun := fun m : M => ⁅x, m⁆, map_zero' := lie_zero x, map_add' := fun _ _ => lie_add _ _ _ }\n    _ _\n\n"}
{"name":"lie_lie","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nM : Type w\ninst✝² : LieRing L\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L M\nx y : L\nm : M\n⊢ Eq (Bracket.bracket (Bracket.bracket x y) m) (HSub.hSub (Bracket.bracket x (Bracket.bracket y m)) (Bracket.bracket y (Bracket.bracket x m)))","decl":"@[simp]\nlemma lie_lie : ⁅⁅x, y⁆, m⁆ = ⁅x, ⁅y, m⁆⁆ - ⁅y, ⁅x, m⁆⁆ := by rw [leibniz_lie, add_sub_cancel_right]\n\n"}
{"name":"lie_jacobi","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\ninst✝ : LieRing L\nx y z : L\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (Bracket.bracket x (Bracket.bracket y z)) (Bracket.bracket y (Bracket.bracket z x))) (Bracket.bracket z (Bracket.bracket x y))) 0","decl":"theorem lie_jacobi : ⁅x, ⁅y, z⁆⁆ + ⁅y, ⁅z, x⁆⁆ + ⁅z, ⁅x, y⁆⁆ = 0 := by\n  rw [← neg_neg ⁅x, y⁆, lie_neg z, lie_skew y x, ← lie_skew, lie_lie]\n  abel\n\n"}
{"name":"instLieModuleInt","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"L : Type v\nM : Type w\ninst✝² : LieRing L\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L M\n⊢ LieModule Int L M","decl":"instance : LieModule ℤ L M where\n  smul_lie n x m := zsmul_lie x m n\n  lie_smul n x m := lie_zsmul x m n\n\n"}
{"name":"LieHom.lie_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : LieRingModule L N\ninst✝ : LieModule R L N\nf : LinearMap (RingHom.id R) M N\nx : L\nm : M\n⊢ Eq ((Bracket.bracket x f) m) (HSub.hSub (Bracket.bracket x (f m)) (f (Bracket.bracket x m)))","decl":"@[simp]\ntheorem LieHom.lie_apply (f : M →ₗ[R] N) (x : L) (m : M) : ⁅x, f⁆ m = ⁅x, f m⁆ - f ⁅x, m⁆ :=\n  rfl\n\n"}
{"name":"LinearMap.instLieModule","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : LieRingModule L N\n⊢ LieModule R L (LinearMap (RingHom.id R) M N)","decl":"instance LinearMap.instLieModule : LieModule R L (M →ₗ[R] N) where\n  smul_lie t x f := by\n    ext n\n    simp only [smul_sub, smul_lie, LinearMap.smul_apply, LieHom.lie_apply, LinearMap.map_smul]\n  lie_smul t x f := by\n    ext n\n    simp only [smul_sub, LinearMap.smul_apply, LieHom.lie_apply, lie_smul]\n\n"}
{"name":"Module.Dual.lie_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nx : L\nm : M\nf : LinearMap (RingHom.id R) M R\n⊢ Eq ((Bracket.bracket x f) m) (Neg.neg (f (Bracket.bracket x m)))","decl":"@[simp] lemma Module.Dual.lie_apply (f : M →ₗ[R] R) : ⁅x, f⁆ m = - f ⁅x, m⁆ := rfl\n\n"}
{"name":"Module.Dual.instLieModule","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ LieModule R L (LinearMap (RingHom.id R) M R)","decl":"instance Module.Dual.instLieModule : LieModule R L (M →ₗ[R] R) where\n  smul_lie := fun t x m ↦ by ext n; simp\n  lie_smul := fun t x m ↦ by ext n; simp\n\n"}
{"name":"LieHom.map_lie'","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\nself : LieHom R L L'\nx y : L\n⊢ Eq (self.toFun (Bracket.bracket x y)) (Bracket.bracket (self.toFun x) (self.toFun y))","decl":"/-- A morphism of Lie algebras (denoted as `L₁ →ₗ⁅R⁆ L₂`)\nis a linear map respecting the bracket operations. -/\nstructure LieHom (R L L' : Type*) [CommRing R] [LieRing L] [LieAlgebra R L]\n  [LieRing L'] [LieAlgebra R L'] extends L →ₗ[R] L' where\n  /-- A morphism of Lie algebras is compatible with brackets. -/\n  map_lie' : ∀ {x y : L}, toFun ⁅x, y⁆ = ⁅toFun x, toFun y⁆\n\n"}
{"name":"LieHom.mk.sizeOf_spec","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : LieRing L'\ninst✝³ : LieAlgebra R L'\ninst✝² : SizeOf R\ninst✝¹ : SizeOf L\ninst✝ : SizeOf L'\ntoLinearMap : LinearMap (RingHom.id R) L L'\nmap_lie' : ∀ {x y : L}, Eq (toLinearMap.toFun (Bracket.bracket x y)) (Bracket.bracket (toLinearMap.toFun x) (toLinearMap.toFun y))\n⊢ Eq (SizeOf.sizeOf { toLinearMap := toLinearMap, map_lie' := map_lie' }) (HAdd.hAdd 1 (SizeOf.sizeOf toLinearMap))","decl":"/-- A morphism of Lie algebras (denoted as `L₁ →ₗ⁅R⁆ L₂`)\nis a linear map respecting the bracket operations. -/\nstructure LieHom (R L L' : Type*) [CommRing R] [LieRing L] [LieAlgebra R L]\n  [LieRing L'] [LieAlgebra R L'] extends L →ₗ[R] L' where\n  /-- A morphism of Lie algebras is compatible with brackets. -/\n  map_lie' : ∀ {x y : L}, toFun ⁅x, y⁆ = ⁅toFun x, toFun y⁆\n\n"}
{"name":"LieHom.mk.injEq","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\ntoLinearMap✝ : LinearMap (RingHom.id R) L L'\nmap_lie'✝ : ∀ {x y : L}, Eq (toLinearMap✝.toFun (Bracket.bracket x y)) (Bracket.bracket (toLinearMap✝.toFun x) (toLinearMap✝.toFun y))\ntoLinearMap : LinearMap (RingHom.id R) L L'\nmap_lie' : ∀ {x y : L}, Eq (toLinearMap.toFun (Bracket.bracket x y)) (Bracket.bracket (toLinearMap.toFun x) (toLinearMap.toFun y))\n⊢ Eq (Eq { toLinearMap := toLinearMap✝, map_lie' := map_lie'✝ } { toLinearMap := toLinearMap, map_lie' := map_lie' }) (Eq toLinearMap✝ toLinearMap)","decl":"/-- A morphism of Lie algebras (denoted as `L₁ →ₗ⁅R⁆ L₂`)\nis a linear map respecting the bracket operations. -/\nstructure LieHom (R L L' : Type*) [CommRing R] [LieRing L] [LieAlgebra R L]\n  [LieRing L'] [LieAlgebra R L'] extends L →ₗ[R] L' where\n  /-- A morphism of Lie algebras is compatible with brackets. -/\n  map_lie' : ∀ {x y : L}, toFun ⁅x, y⁆ = ⁅toFun x, toFun y⁆\n\n"}
{"name":"LieHom.mk.inj","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\ntoLinearMap✝ : LinearMap (RingHom.id R) L L'\nmap_lie'✝ : ∀ {x y : L}, Eq (toLinearMap✝.toFun (Bracket.bracket x y)) (Bracket.bracket (toLinearMap✝.toFun x) (toLinearMap✝.toFun y))\ntoLinearMap : LinearMap (RingHom.id R) L L'\nmap_lie' : ∀ {x y : L}, Eq (toLinearMap.toFun (Bracket.bracket x y)) (Bracket.bracket (toLinearMap.toFun x) (toLinearMap.toFun y))\nx✝ : Eq { toLinearMap := toLinearMap✝, map_lie' := map_lie'✝ } { toLinearMap := toLinearMap, map_lie' := map_lie' }\n⊢ Eq toLinearMap✝ toLinearMap","decl":"/-- A morphism of Lie algebras (denoted as `L₁ →ₗ⁅R⁆ L₂`)\nis a linear map respecting the bracket operations. -/\nstructure LieHom (R L L' : Type*) [CommRing R] [LieRing L] [LieAlgebra R L]\n  [LieRing L'] [LieAlgebra R L'] extends L →ₗ[R] L' where\n  /-- A morphism of Lie algebras is compatible with brackets. -/\n  map_lie' : ∀ {x y : L}, toFun ⁅x, y⁆ = ⁅toFun x, toFun y⁆\n\n"}
{"name":"LieHom.coe_toLinearMap","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieAlgebra R L₁\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L₁ L₂\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp, norm_cast]\ntheorem coe_toLinearMap (f : L₁ →ₗ⁅R⁆ L₂) : ⇑(f : L₁ →ₗ[R] L₂) = f :=\n  rfl\n\n"}
{"name":"LieHom.toFun_eq_coe","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieAlgebra R L₁\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L₁ L₂\n⊢ Eq (↑f).toFun ⇑f","decl":"@[simp]\ntheorem toFun_eq_coe (f : L₁ →ₗ⁅R⁆ L₂) : f.toFun = ⇑f :=\n  rfl\n\n"}
{"name":"LieHom.map_smul","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieAlgebra R L₁\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L₁ L₂\nc : R\nx : L₁\n⊢ Eq (f (HSMul.hSMul c x)) (HSMul.hSMul c (f x))","decl":"@[simp]\ntheorem map_smul (f : L₁ →ₗ⁅R⁆ L₂) (c : R) (x : L₁) : f (c • x) = c • f x :=\n  LinearMap.map_smul (f : L₁ →ₗ[R] L₂) c x\n\n"}
{"name":"LieHom.map_add","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieAlgebra R L₁\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L₁ L₂\nx y : L₁\n⊢ Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))","decl":"@[simp]\ntheorem map_add (f : L₁ →ₗ⁅R⁆ L₂) (x y : L₁) : f (x + y) = f x + f y :=\n  LinearMap.map_add (f : L₁ →ₗ[R] L₂) x y\n\n"}
{"name":"LieHom.map_sub","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieAlgebra R L₁\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L₁ L₂\nx y : L₁\n⊢ Eq (f (HSub.hSub x y)) (HSub.hSub (f x) (f y))","decl":"@[simp]\ntheorem map_sub (f : L₁ →ₗ⁅R⁆ L₂) (x y : L₁) : f (x - y) = f x - f y :=\n  LinearMap.map_sub (f : L₁ →ₗ[R] L₂) x y\n\n"}
{"name":"LieHom.map_neg","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieAlgebra R L₁\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L₁ L₂\nx : L₁\n⊢ Eq (f (Neg.neg x)) (Neg.neg (f x))","decl":"@[simp]\ntheorem map_neg (f : L₁ →ₗ⁅R⁆ L₂) (x : L₁) : f (-x) = -f x :=\n  LinearMap.map_neg (f : L₁ →ₗ[R] L₂) x\n\n"}
{"name":"LieHom.map_lie","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieAlgebra R L₁\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L₁ L₂\nx y : L₁\n⊢ Eq (f (Bracket.bracket x y)) (Bracket.bracket (f x) (f y))","decl":"@[simp]\ntheorem map_lie (f : L₁ →ₗ⁅R⁆ L₂) (x y : L₁) : f ⁅x, y⁆ = ⁅f x, f y⁆ :=\n  LieHom.map_lie' f\n\n"}
{"name":"LieHom.map_zero","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieAlgebra R L₁\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L₁ L₂\n⊢ Eq (f 0) 0","decl":"@[simp]\ntheorem map_zero (f : L₁ →ₗ⁅R⁆ L₂) : f 0 = 0 :=\n  (f : L₁ →ₗ[R] L₂).map_zero\n\n"}
{"name":"LieHom.coe_id","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L₁\ninst✝ : LieAlgebra R L₁\n⊢ Eq (⇑LieHom.id) id","decl":"@[simp, norm_cast]\ntheorem coe_id : ⇑(id : L₁ →ₗ⁅R⁆ L₁) = _root_.id :=\n  rfl\n\n"}
{"name":"LieHom.id_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L₁\ninst✝ : LieAlgebra R L₁\nx : L₁\n⊢ Eq (LieHom.id x) x","decl":"theorem id_apply (x : L₁) : (id : L₁ →ₗ⁅R⁆ L₁) x = x :=\n  rfl\n\n"}
{"name":"LieHom.coe_zero","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieAlgebra R L₁\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\n⊢ Eq (⇑0) 0","decl":"@[norm_cast, simp]\ntheorem coe_zero : ((0 : L₁ →ₗ⁅R⁆ L₂) : L₁ → L₂) = 0 :=\n  rfl\n\n"}
{"name":"LieHom.zero_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieAlgebra R L₁\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nx : L₁\n⊢ Eq (0 x) 0","decl":"theorem zero_apply (x : L₁) : (0 : L₁ →ₗ⁅R⁆ L₂) x = 0 :=\n  rfl\n\n"}
{"name":"LieHom.coe_one","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L₁\ninst✝ : LieAlgebra R L₁\n⊢ Eq (⇑1) id","decl":"@[simp]\ntheorem coe_one : ((1 : L₁ →ₗ⁅R⁆ L₁) : L₁ → L₁) = _root_.id :=\n  rfl\n\n"}
{"name":"LieHom.one_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L₁\ninst✝ : LieAlgebra R L₁\nx : L₁\n⊢ Eq (1 x) x","decl":"theorem one_apply (x : L₁) : (1 : L₁ →ₗ⁅R⁆ L₁) x = x :=\n  rfl\n\n"}
{"name":"LieHom.coe_injective","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieAlgebra R L₁\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\n⊢ Function.Injective DFunLike.coe","decl":"theorem coe_injective : @Function.Injective (L₁ →ₗ⁅R⁆ L₂) (L₁ → L₂) (↑) := by\n  rintro ⟨⟨⟨f, _⟩, _⟩, _⟩ ⟨⟨⟨g, _⟩, _⟩, _⟩ h\n  congr\n\n"}
{"name":"LieHom.ext","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieAlgebra R L₁\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf g : LieHom R L₁ L₂\nh : ∀ (x : L₁), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : L₁ →ₗ⁅R⁆ L₂} (h : ∀ x, f x = g x) : f = g :=\n  coe_injective <| funext h\n\n"}
{"name":"LieHom.ext_iff","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieAlgebra R L₁\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf g : LieHom R L₁ L₂\n⊢ Iff (Eq f g) (∀ (x : L₁), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext {f g : L₁ →ₗ⁅R⁆ L₂} (h : ∀ x, f x = g x) : f = g :=\n  coe_injective <| funext h\n\n"}
{"name":"LieHom.congr_fun","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieAlgebra R L₁\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf g : LieHom R L₁ L₂\nh : Eq f g\nx : L₁\n⊢ Eq (f x) (g x)","decl":"theorem congr_fun {f g : L₁ →ₗ⁅R⁆ L₂} (h : f = g) (x : L₁) : f x = g x :=\n  h ▸ rfl\n\n"}
{"name":"LieHom.mk_coe","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieAlgebra R L₁\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L₁ L₂\nh₁ : ∀ (x y : L₁), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\nh₂ : ∀ (m : R) (x : L₁), Eq ({ toFun := ⇑f, map_add' := h₁ }.toFun (HSMul.hSMul m x)) (HSMul.hSMul ((RingHom.id R) m) ({ toFun := ⇑f, map_add' := h₁ }.toFun x))\nh₃ : ∀ {x y : L₁}, Eq ({ toFun := ⇑f, map_add' := h₁, map_smul' := h₂ }.toFun (Bracket.bracket x y)) (Bracket.bracket ({ toFun := ⇑f, map_add' := h₁, map_smul' := h₂ }.toFun x) ({ toFun := ⇑f, map_add' := h₁, map_smul' := h₂ }.toFun y))\n⊢ Eq { toFun := ⇑f, map_add' := h₁, map_smul' := h₂, map_lie' := h₃ } f","decl":"@[simp]\ntheorem mk_coe (f : L₁ →ₗ⁅R⁆ L₂) (h₁ h₂ h₃) : (⟨⟨⟨f, h₁⟩, h₂⟩, h₃⟩ : L₁ →ₗ⁅R⁆ L₂) = f := by\n  ext\n  rfl\n\n"}
{"name":"LieHom.coe_mk","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieAlgebra R L₁\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : L₁ → L₂\nh₁ : ∀ (x y : L₁), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\nh₂ : ∀ (m : R) (x : L₁), Eq ({ toFun := f, map_add' := h₁ }.toFun (HSMul.hSMul m x)) (HSMul.hSMul ((RingHom.id R) m) ({ toFun := f, map_add' := h₁ }.toFun x))\nh₃ : ∀ {x y : L₁}, Eq ({ toFun := f, map_add' := h₁, map_smul' := h₂ }.toFun (Bracket.bracket x y)) (Bracket.bracket ({ toFun := f, map_add' := h₁, map_smul' := h₂ }.toFun x) ({ toFun := f, map_add' := h₁, map_smul' := h₂ }.toFun y))\n⊢ Eq (⇑{ toFun := f, map_add' := h₁, map_smul' := h₂, map_lie' := h₃ }) f","decl":"@[simp]\ntheorem coe_mk (f : L₁ → L₂) (h₁ h₂ h₃) : ((⟨⟨⟨f, h₁⟩, h₂⟩, h₃⟩ : L₁ →ₗ⁅R⁆ L₂) : L₁ → L₂) = f :=\n  rfl\n\n"}
{"name":"LieHom.comp_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\nL₃ : Type w₁\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L₁\ninst✝⁴ : LieAlgebra R L₁\ninst✝³ : LieRing L₂\ninst✝² : LieAlgebra R L₂\ninst✝¹ : LieRing L₃\ninst✝ : LieAlgebra R L₃\nf : LieHom R L₂ L₃\ng : LieHom R L₁ L₂\nx : L₁\n⊢ Eq ((f.comp g) x) (f (g x))","decl":"theorem comp_apply (f : L₂ →ₗ⁅R⁆ L₃) (g : L₁ →ₗ⁅R⁆ L₂) (x : L₁) : f.comp g x = f (g x) :=\n  rfl\n\n"}
{"name":"LieHom.coe_comp","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\nL₃ : Type w₁\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L₁\ninst✝⁴ : LieAlgebra R L₁\ninst✝³ : LieRing L₂\ninst✝² : LieAlgebra R L₂\ninst✝¹ : LieRing L₃\ninst✝ : LieAlgebra R L₃\nf : LieHom R L₂ L₃\ng : LieHom R L₁ L₂\n⊢ Eq (⇑(f.comp g)) (Function.comp ⇑f ⇑g)","decl":"@[norm_cast, simp]\ntheorem coe_comp (f : L₂ →ₗ⁅R⁆ L₃) (g : L₁ →ₗ⁅R⁆ L₂) : (f.comp g : L₁ → L₃) = f ∘ g :=\n  rfl\n\n"}
{"name":"LieHom.toLinearMap_comp","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\nL₃ : Type w₁\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L₁\ninst✝⁴ : LieAlgebra R L₁\ninst✝³ : LieRing L₂\ninst✝² : LieAlgebra R L₂\ninst✝¹ : LieRing L₃\ninst✝ : LieAlgebra R L₃\nf : LieHom R L₂ L₃\ng : LieHom R L₁ L₂\n⊢ Eq (↑(f.comp g)) ((↑f).comp ↑g)","decl":"@[norm_cast, simp]\ntheorem toLinearMap_comp (f : L₂ →ₗ⁅R⁆ L₃) (g : L₁ →ₗ⁅R⁆ L₂) :\n    (f.comp g : L₁ →ₗ[R] L₃) = (f : L₂ →ₗ[R] L₃).comp (g : L₁ →ₗ[R] L₂) :=\n  rfl\n\n"}
{"name":"LieHom.coe_linearMap_comp","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\nL₃ : Type w₁\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L₁\ninst✝⁴ : LieAlgebra R L₁\ninst✝³ : LieRing L₂\ninst✝² : LieAlgebra R L₂\ninst✝¹ : LieRing L₃\ninst✝ : LieAlgebra R L₃\nf : LieHom R L₂ L₃\ng : LieHom R L₁ L₂\n⊢ Eq (↑(f.comp g)) ((↑f).comp ↑g)","decl":"@[deprecated (since := \"2024-12-30\")] alias coe_linearMap_comp := toLinearMap_comp\n\n"}
{"name":"LieHom.comp_id","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieAlgebra R L₁\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L₁ L₂\n⊢ Eq (f.comp LieHom.id) f","decl":"@[simp]\ntheorem comp_id (f : L₁ →ₗ⁅R⁆ L₂) : f.comp (id : L₁ →ₗ⁅R⁆ L₁) = f :=\n  rfl\n\n"}
{"name":"LieHom.id_comp","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieAlgebra R L₁\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L₁ L₂\n⊢ Eq (LieHom.id.comp f) f","decl":"@[simp]\ntheorem id_comp (f : L₁ →ₗ⁅R⁆ L₂) : (id : L₂ →ₗ⁅R⁆ L₂).comp f = f :=\n  rfl\n\n"}
{"name":"LieRingModule.compLieHom_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\nM : Type w₁\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L₁\ninst✝⁴ : LieAlgebra R L₁\ninst✝³ : LieRing L₂\ninst✝² : LieAlgebra R L₂\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L₂ M\nf : LieHom R L₁ L₂\nx : L₁\nm : M\n⊢ Eq (Bracket.bracket x m) (Bracket.bracket (f x) m)","decl":"theorem LieRingModule.compLieHom_apply (x : L₁) (m : M) :\n    haveI := LieRingModule.compLieHom M f\n    ⁅x, m⁆ = ⁅f x, m⁆ :=\n  rfl\n\n"}
{"name":"LieModule.compLieHom","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\nM : Type w₁\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L₁\ninst✝⁶ : LieAlgebra R L₁\ninst✝⁵ : LieRing L₂\ninst✝⁴ : LieAlgebra R L₂\ninst✝³ : AddCommGroup M\ninst✝² : LieRingModule L₂ M\nf : LieHom R L₁ L₂\ninst✝¹ : Module R M\ninst✝ : LieModule R L₂ M\n⊢ LieModule R L₁ M","decl":"/-- A Lie module may be pulled back along a morphism of Lie algebras. -/\ntheorem LieModule.compLieHom [Module R M] [LieModule R L₂ M] :\n    @LieModule R L₁ M _ _ _ _ _ (LieRingModule.compLieHom M f) :=\n  { __ := LieRingModule.compLieHom M f\n    smul_lie := fun t x m => by\n      simp only [LieRingModule.compLieHom_apply, smul_lie, LieHom.map_smul]\n    lie_smul := fun t x m => by\n      simp only [LieRingModule.compLieHom_apply, lie_smul] }\n\n"}
{"name":"LieEquiv.mk.inj","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nL' : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\ntoLieHom✝ : LieHom R L L'\ninvFun✝ : L' → L\nleft_inv✝ : Function.LeftInverse invFun✝ (↑toLieHom✝).toFun\nright_inv✝ : Function.RightInverse invFun✝ (↑toLieHom✝).toFun\ntoLieHom : LieHom R L L'\ninvFun : L' → L\nleft_inv : Function.LeftInverse invFun (↑toLieHom).toFun\nright_inv : Function.RightInverse invFun (↑toLieHom).toFun\nx✝ : Eq { toLieHom := toLieHom✝, invFun := invFun✝, left_inv := left_inv✝, right_inv := right_inv✝ } { toLieHom := toLieHom, invFun := invFun, left_inv := left_inv, right_inv := right_inv }\n⊢ And (Eq toLieHom✝ toLieHom) (Eq invFun✝ invFun)","decl":"/-- An equivalence of Lie algebras (denoted as `L₁ ≃ₗ⁅R⁆ L₂`) is a morphism\nwhich is also a linear equivalence.\nWe could instead define an equivalence to be a morphism which is also a (plain) equivalence.\nHowever, it is more convenient to define via linear equivalence to get `.toLinearEquiv` for free. -/\nstructure LieEquiv (R : Type u) (L : Type v) (L' : Type w) [CommRing R] [LieRing L] [LieAlgebra R L]\n  [LieRing L'] [LieAlgebra R L'] extends L →ₗ⁅R⁆ L' where\n  /-- The inverse function of an equivalence of Lie algebras -/\n  invFun : L' → L\n  /-- The inverse function of an equivalence of Lie algebras is a left inverse of the underlying\n  function. -/\n  left_inv : Function.LeftInverse invFun toLieHom.toFun\n  /-- The inverse function of an equivalence of Lie algebras is a right inverse of the underlying\n  function. -/\n  right_inv : Function.RightInverse invFun toLieHom.toFun\n\n"}
{"name":"LieEquiv.mk.injEq","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nL' : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\ntoLieHom✝ : LieHom R L L'\ninvFun✝ : L' → L\nleft_inv✝ : Function.LeftInverse invFun✝ (↑toLieHom✝).toFun\nright_inv✝ : Function.RightInverse invFun✝ (↑toLieHom✝).toFun\ntoLieHom : LieHom R L L'\ninvFun : L' → L\nleft_inv : Function.LeftInverse invFun (↑toLieHom).toFun\nright_inv : Function.RightInverse invFun (↑toLieHom).toFun\n⊢ Eq (Eq { toLieHom := toLieHom✝, invFun := invFun✝, left_inv := left_inv✝, right_inv := right_inv✝ } { toLieHom := toLieHom, invFun := invFun, left_inv := left_inv, right_inv := right_inv }) (And (Eq toLieHom✝ toLieHom) (Eq invFun✝ invFun))","decl":"/-- An equivalence of Lie algebras (denoted as `L₁ ≃ₗ⁅R⁆ L₂`) is a morphism\nwhich is also a linear equivalence.\nWe could instead define an equivalence to be a morphism which is also a (plain) equivalence.\nHowever, it is more convenient to define via linear equivalence to get `.toLinearEquiv` for free. -/\nstructure LieEquiv (R : Type u) (L : Type v) (L' : Type w) [CommRing R] [LieRing L] [LieAlgebra R L]\n  [LieRing L'] [LieAlgebra R L'] extends L →ₗ⁅R⁆ L' where\n  /-- The inverse function of an equivalence of Lie algebras -/\n  invFun : L' → L\n  /-- The inverse function of an equivalence of Lie algebras is a left inverse of the underlying\n  function. -/\n  left_inv : Function.LeftInverse invFun toLieHom.toFun\n  /-- The inverse function of an equivalence of Lie algebras is a right inverse of the underlying\n  function. -/\n  right_inv : Function.RightInverse invFun toLieHom.toFun\n\n"}
{"name":"LieEquiv.left_inv","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nL' : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\nself : LieEquiv R L L'\n⊢ Function.LeftInverse self.invFun (↑self.toLieHom).toFun","decl":"/-- An equivalence of Lie algebras (denoted as `L₁ ≃ₗ⁅R⁆ L₂`) is a morphism\nwhich is also a linear equivalence.\nWe could instead define an equivalence to be a morphism which is also a (plain) equivalence.\nHowever, it is more convenient to define via linear equivalence to get `.toLinearEquiv` for free. -/\nstructure LieEquiv (R : Type u) (L : Type v) (L' : Type w) [CommRing R] [LieRing L] [LieAlgebra R L]\n  [LieRing L'] [LieAlgebra R L'] extends L →ₗ⁅R⁆ L' where\n  /-- The inverse function of an equivalence of Lie algebras -/\n  invFun : L' → L\n  /-- The inverse function of an equivalence of Lie algebras is a left inverse of the underlying\n  function. -/\n  left_inv : Function.LeftInverse invFun toLieHom.toFun\n  /-- The inverse function of an equivalence of Lie algebras is a right inverse of the underlying\n  function. -/\n  right_inv : Function.RightInverse invFun toLieHom.toFun\n\n"}
{"name":"LieEquiv.mk.sizeOf_spec","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nL' : Type w\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : LieRing L'\ninst✝³ : LieAlgebra R L'\ninst✝² : SizeOf R\ninst✝¹ : SizeOf L\ninst✝ : SizeOf L'\ntoLieHom : LieHom R L L'\ninvFun : L' → L\nleft_inv : Function.LeftInverse invFun (↑toLieHom).toFun\nright_inv : Function.RightInverse invFun (↑toLieHom).toFun\n⊢ Eq (SizeOf.sizeOf { toLieHom := toLieHom, invFun := invFun, left_inv := left_inv, right_inv := right_inv }) (HAdd.hAdd 1 (SizeOf.sizeOf toLieHom))","decl":"/-- An equivalence of Lie algebras (denoted as `L₁ ≃ₗ⁅R⁆ L₂`) is a morphism\nwhich is also a linear equivalence.\nWe could instead define an equivalence to be a morphism which is also a (plain) equivalence.\nHowever, it is more convenient to define via linear equivalence to get `.toLinearEquiv` for free. -/\nstructure LieEquiv (R : Type u) (L : Type v) (L' : Type w) [CommRing R] [LieRing L] [LieAlgebra R L]\n  [LieRing L'] [LieAlgebra R L'] extends L →ₗ⁅R⁆ L' where\n  /-- The inverse function of an equivalence of Lie algebras -/\n  invFun : L' → L\n  /-- The inverse function of an equivalence of Lie algebras is a left inverse of the underlying\n  function. -/\n  left_inv : Function.LeftInverse invFun toLieHom.toFun\n  /-- The inverse function of an equivalence of Lie algebras is a right inverse of the underlying\n  function. -/\n  right_inv : Function.RightInverse invFun toLieHom.toFun\n\n"}
{"name":"LieEquiv.right_inv","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nL' : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\nself : LieEquiv R L L'\n⊢ Function.RightInverse self.invFun (↑self.toLieHom).toFun","decl":"/-- An equivalence of Lie algebras (denoted as `L₁ ≃ₗ⁅R⁆ L₂`) is a morphism\nwhich is also a linear equivalence.\nWe could instead define an equivalence to be a morphism which is also a (plain) equivalence.\nHowever, it is more convenient to define via linear equivalence to get `.toLinearEquiv` for free. -/\nstructure LieEquiv (R : Type u) (L : Type v) (L' : Type w) [CommRing R] [LieRing L] [LieAlgebra R L]\n  [LieRing L'] [LieAlgebra R L'] extends L →ₗ⁅R⁆ L' where\n  /-- The inverse function of an equivalence of Lie algebras -/\n  invFun : L' → L\n  /-- The inverse function of an equivalence of Lie algebras is a left inverse of the underlying\n  function. -/\n  left_inv : Function.LeftInverse invFun toLieHom.toFun\n  /-- The inverse function of an equivalence of Lie algebras is a right inverse of the underlying\n  function. -/\n  right_inv : Function.RightInverse invFun toLieHom.toFun\n\n"}
{"name":"LieEquiv.coe_toLieHom","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\ne : LieEquiv R L₁ L₂\n⊢ Eq ⇑e.toLieHom ⇑e","decl":"theorem coe_toLieHom (e : L₁ ≃ₗ⁅R⁆ L₂) : ⇑(e : L₁ →ₗ⁅R⁆ L₂) = e :=\n  rfl\n\n"}
{"name":"LieEquiv.coe_to_lieHom","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\ne : LieEquiv R L₁ L₂\n⊢ Eq ⇑e.toLieHom ⇑e","decl":"@[deprecated (since := \"2024-12-30\")] alias coe_to_lieHom := coe_toLieHom\n\n"}
{"name":"LieEquiv.coe_toLinearEquiv","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\ne : LieEquiv R L₁ L₂\n⊢ Eq ⇑e.toLinearEquiv ⇑e","decl":"@[simp]\ntheorem coe_toLinearEquiv (e : L₁ ≃ₗ⁅R⁆ L₂) : ⇑(e : L₁ ≃ₗ[R] L₂) = e :=\n  rfl\n\n"}
{"name":"LieEquiv.coe_to_linearEquiv","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\ne : LieEquiv R L₁ L₂\n⊢ Eq ⇑e.toLinearEquiv ⇑e","decl":"@[deprecated (since := \"2024-12-30\")] alias coe_to_linearEquiv := coe_toLinearEquiv\n\n"}
{"name":"LieEquiv.toLinearEquiv_mk","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\nf : LieHom R L₁ L₂\ng : L₂ → L₁\nh₁ : Function.LeftInverse g (↑f).toFun\nh₂ : Function.RightInverse g (↑f).toFun\n⊢ Eq { toLieHom := f, invFun := g, left_inv := h₁, right_inv := h₂ }.toLinearEquiv { toLinearMap := ↑f, invFun := g, left_inv := h₁, right_inv := h₂ }","decl":"@[simp]\ntheorem toLinearEquiv_mk (f : L₁ →ₗ⁅R⁆ L₂) (g h₁ h₂) :\n    (mk f g h₁ h₂ : L₁ ≃ₗ[R] L₂) =\n      { f with\n        invFun := g\n        left_inv := h₁\n        right_inv := h₂ } :=\n  rfl\n\n"}
{"name":"LieEquiv.to_linearEquiv_mk","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\nf : LieHom R L₁ L₂\ng : L₂ → L₁\nh₁ : Function.LeftInverse g (↑f).toFun\nh₂ : Function.RightInverse g (↑f).toFun\n⊢ Eq { toLieHom := f, invFun := g, left_inv := h₁, right_inv := h₂ }.toLinearEquiv { toLinearMap := ↑f, invFun := g, left_inv := h₁, right_inv := h₂ }","decl":"@[deprecated (since := \"2024-12-30\")] alias to_linearEquiv_mk := toLinearEquiv_mk\n\n"}
{"name":"LieEquiv.toLinearEquiv_injective","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\n⊢ Function.Injective LieEquiv.toLinearEquiv","decl":"theorem toLinearEquiv_injective : Injective ((↑) : (L₁ ≃ₗ⁅R⁆ L₂) → L₁ ≃ₗ[R] L₂) := by\n  rintro ⟨⟨⟨⟨f, -⟩, -⟩, -⟩, f_inv⟩ ⟨⟨⟨⟨g, -⟩, -⟩, -⟩, g_inv⟩\n  intro h\n  simp only [toLinearEquiv_mk, LinearEquiv.mk.injEq, LinearMap.mk.injEq, AddHom.mk.injEq] at h\n  congr\n  exacts [h.1, h.2]\n\n"}
{"name":"LieEquiv.coe_linearEquiv_injective","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\n⊢ Function.Injective LieEquiv.toLinearEquiv","decl":"@[deprecated (since := \"2024-12-30\")] alias coe_linearEquiv_injective := toLinearEquiv_injective\n\n"}
{"name":"LieEquiv.coe_injective","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\n⊢ Function.Injective DFunLike.coe","decl":"theorem coe_injective : @Injective (L₁ ≃ₗ⁅R⁆ L₂) (L₁ → L₂) (↑) :=\n  LinearEquiv.coe_injective.comp toLinearEquiv_injective\n\n"}
{"name":"LieEquiv.ext_iff","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\nf g : LieEquiv R L₁ L₂\n⊢ Iff (Eq f g) (∀ (x : L₁), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext {f g : L₁ ≃ₗ⁅R⁆ L₂} (h : ∀ x, f x = g x) : f = g :=\n  coe_injective <| funext h\n\n"}
{"name":"LieEquiv.ext","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\nf g : LieEquiv R L₁ L₂\nh : ∀ (x : L₁), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : L₁ ≃ₗ⁅R⁆ L₂} (h : ∀ x, f x = g x) : f = g :=\n  coe_injective <| funext h\n\n"}
{"name":"LieEquiv.one_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L₁\ninst✝ : LieAlgebra R L₁\nx : L₁\n⊢ Eq (1 x) x","decl":"@[simp]\ntheorem one_apply (x : L₁) : (1 : L₁ ≃ₗ⁅R⁆ L₁) x = x :=\n  rfl\n\n"}
{"name":"LieEquiv.map_lie","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\ne : LieEquiv R L₁ L₂\nx y : L₁\n⊢ Eq (e (Bracket.bracket x y)) (Bracket.bracket (e x) (e y))","decl":"lemma map_lie (e : L₁ ≃ₗ⁅R⁆ L₂) (x y : L₁) : e ⁅x, y⁆ = ⁅e x, e y⁆ :=\n  LieHom.map_lie e.toLieHom x y\n\n"}
{"name":"LieEquiv.refl_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L₁\ninst✝ : LieAlgebra R L₁\nx : L₁\n⊢ Eq (LieEquiv.refl x) x","decl":"@[simp]\ntheorem refl_apply (x : L₁) : (refl : L₁ ≃ₗ⁅R⁆ L₁) x = x :=\n  rfl\n\n"}
{"name":"LieEquiv.symm_symm","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\ne : LieEquiv R L₁ L₂\n⊢ Eq e.symm.symm e","decl":"@[simp]\ntheorem symm_symm (e : L₁ ≃ₗ⁅R⁆ L₂) : e.symm.symm = e := rfl\n\n"}
{"name":"LieEquiv.symm_bijective","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\n⊢ Function.Bijective LieEquiv.symm","decl":"theorem symm_bijective : Function.Bijective (LieEquiv.symm : (L₁ ≃ₗ⁅R⁆ L₂) → L₂ ≃ₗ⁅R⁆ L₁) :=\n  Function.bijective_iff_has_inverse.mpr ⟨_, symm_symm, symm_symm⟩\n\n"}
{"name":"LieEquiv.apply_symm_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\ne : LieEquiv R L₁ L₂\nx : L₂\n⊢ Eq (e (e.symm x)) x","decl":"@[simp]\ntheorem apply_symm_apply (e : L₁ ≃ₗ⁅R⁆ L₂) : ∀ x, e (e.symm x) = x :=\n  e.toLinearEquiv.apply_symm_apply\n\n"}
{"name":"LieEquiv.symm_apply_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\ne : LieEquiv R L₁ L₂\nx : L₁\n⊢ Eq (e.symm (e x)) x","decl":"@[simp]\ntheorem symm_apply_apply (e : L₁ ≃ₗ⁅R⁆ L₂) : ∀ x, e.symm (e x) = x :=\n  e.toLinearEquiv.symm_apply_apply\n\n"}
{"name":"LieEquiv.refl_symm","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L₁\ninst✝ : LieAlgebra R L₁\n⊢ Eq LieEquiv.refl.symm LieEquiv.refl","decl":"@[simp]\ntheorem refl_symm : (refl : L₁ ≃ₗ⁅R⁆ L₁).symm = refl :=\n  rfl\n\n"}
{"name":"LieEquiv.self_trans_symm","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\ne : LieEquiv R L₁ L₂\n⊢ Eq (e.trans e.symm) LieEquiv.refl","decl":"@[simp]\ntheorem self_trans_symm (e : L₁ ≃ₗ⁅R⁆ L₂) : e.trans e.symm = refl :=\n  ext e.symm_apply_apply\n\n"}
{"name":"LieEquiv.symm_trans_self","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\ne : LieEquiv R L₁ L₂\n⊢ Eq (e.symm.trans e) LieEquiv.refl","decl":"@[simp]\ntheorem symm_trans_self (e : L₁ ≃ₗ⁅R⁆ L₂) : e.symm.trans e = refl :=\n  e.symm.self_trans_symm\n\n"}
{"name":"LieEquiv.trans_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\nL₃ : Type w₁\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L₁\ninst✝⁴ : LieRing L₂\ninst✝³ : LieRing L₃\ninst✝² : LieAlgebra R L₁\ninst✝¹ : LieAlgebra R L₂\ninst✝ : LieAlgebra R L₃\ne₁ : LieEquiv R L₁ L₂\ne₂ : LieEquiv R L₂ L₃\nx : L₁\n⊢ Eq ((e₁.trans e₂) x) (e₂ (e₁ x))","decl":"@[simp]\ntheorem trans_apply (e₁ : L₁ ≃ₗ⁅R⁆ L₂) (e₂ : L₂ ≃ₗ⁅R⁆ L₃) (x : L₁) : (e₁.trans e₂) x = e₂ (e₁ x) :=\n  rfl\n\n"}
{"name":"LieEquiv.symm_trans","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\nL₃ : Type w₁\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L₁\ninst✝⁴ : LieRing L₂\ninst✝³ : LieRing L₃\ninst✝² : LieAlgebra R L₁\ninst✝¹ : LieAlgebra R L₂\ninst✝ : LieAlgebra R L₃\ne₁ : LieEquiv R L₁ L₂\ne₂ : LieEquiv R L₂ L₃\n⊢ Eq (e₁.trans e₂).symm (e₂.symm.trans e₁.symm)","decl":"@[simp]\ntheorem symm_trans (e₁ : L₁ ≃ₗ⁅R⁆ L₂) (e₂ : L₂ ≃ₗ⁅R⁆ L₃) :\n    (e₁.trans e₂).symm = e₂.symm.trans e₁.symm :=\n  rfl\n\n"}
{"name":"LieEquiv.bijective","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\ne : LieEquiv R L₁ L₂\n⊢ Function.Bijective ⇑e.toLieHom","decl":"protected theorem bijective (e : L₁ ≃ₗ⁅R⁆ L₂) : Function.Bijective ((e : L₁ →ₗ⁅R⁆ L₂) : L₁ → L₂) :=\n  e.toLinearEquiv.bijective\n\n"}
{"name":"LieEquiv.injective","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\ne : LieEquiv R L₁ L₂\n⊢ Function.Injective ⇑e.toLieHom","decl":"protected theorem injective (e : L₁ ≃ₗ⁅R⁆ L₂) : Function.Injective ((e : L₁ →ₗ⁅R⁆ L₂) : L₁ → L₂) :=\n  e.toLinearEquiv.injective\n\n"}
{"name":"LieEquiv.surjective","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\ne : LieEquiv R L₁ L₂\n⊢ Function.Surjective ⇑e.toLieHom","decl":"protected theorem surjective (e : L₁ ≃ₗ⁅R⁆ L₂) :\n    Function.Surjective ((e : L₁ →ₗ⁅R⁆ L₂) : L₁ → L₂) :=\n  e.toLinearEquiv.surjective\n\n"}
{"name":"LieEquiv.ofBijective_invFun","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\nf : LieHom R L₁ L₂\nh : Function.Bijective ⇑f\na✝ : L₂\n⊢ Eq ((LieEquiv.ofBijective f h).invFun a✝) ((LinearEquiv.ofBijective (↑f) h).symm a✝)","decl":"/-- A bijective morphism of Lie algebras yields an equivalence of Lie algebras. -/\n@[simps!]\nnoncomputable def ofBijective (f : L₁ →ₗ⁅R⁆ L₂) (h : Function.Bijective f) : L₁ ≃ₗ⁅R⁆ L₂ :=\n  { LinearEquiv.ofBijective (f : L₁ →ₗ[R] L₂)\n      h with\n    toFun := f\n    map_lie' := by intros x y; exact f.map_lie x y }\n\n"}
{"name":"LieEquiv.ofBijective_toFun","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\nf : LieHom R L₁ L₂\nh : Function.Bijective ⇑f\na : L₁\n⊢ Eq ((LieEquiv.ofBijective f h) a) (f a)","decl":"/-- A bijective morphism of Lie algebras yields an equivalence of Lie algebras. -/\n@[simps!]\nnoncomputable def ofBijective (f : L₁ →ₗ⁅R⁆ L₂) (h : Function.Bijective f) : L₁ ≃ₗ⁅R⁆ L₂ :=\n  { LinearEquiv.ofBijective (f : L₁ →ₗ[R] L₂)\n      h with\n    toFun := f\n    map_lie' := by intros x y; exact f.map_lie x y }\n\n"}
{"name":"LieModuleHom.map_lie'","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nself : LieModuleHom R L M N\nx : L\nm : M\n⊢ Eq (self.toFun (Bracket.bracket x m)) (Bracket.bracket x (self.toFun m))","decl":"/-- A morphism of Lie algebra modules (denoted as `M →ₗ⁅R,L⁆ N`) is a linear map\nwhich commutes with the action of the Lie algebra. -/\nstructure LieModuleHom extends M →ₗ[R] N where\n  /-- A module of Lie algebra modules is compatible with the action of the Lie algebra on the\n  modules. -/\n  map_lie' : ∀ {x : L} {m : M}, toFun ⁅x, m⁆ = ⁅x, toFun m⁆\n\n"}
{"name":"LieModuleHom.mk.injEq","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\ntoLinearMap✝ : LinearMap (RingHom.id R) M N\nmap_lie'✝ : ∀ {x : L} {m : M}, Eq (toLinearMap✝.toFun (Bracket.bracket x m)) (Bracket.bracket x (toLinearMap✝.toFun m))\ntoLinearMap : LinearMap (RingHom.id R) M N\nmap_lie' : ∀ {x : L} {m : M}, Eq (toLinearMap.toFun (Bracket.bracket x m)) (Bracket.bracket x (toLinearMap.toFun m))\n⊢ Eq (Eq { toLinearMap := toLinearMap✝, map_lie' := map_lie'✝ } { toLinearMap := toLinearMap, map_lie' := map_lie' }) (Eq toLinearMap✝ toLinearMap)","decl":"/-- A morphism of Lie algebra modules (denoted as `M →ₗ⁅R,L⁆ N`) is a linear map\nwhich commutes with the action of the Lie algebra. -/\nstructure LieModuleHom extends M →ₗ[R] N where\n  /-- A module of Lie algebra modules is compatible with the action of the Lie algebra on the\n  modules. -/\n  map_lie' : ∀ {x : L} {m : M}, toFun ⁅x, m⁆ = ⁅x, toFun m⁆\n\n"}
{"name":"LieModuleHom.mk.sizeOf_spec","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : LieRing L\ninst✝⁹ : AddCommGroup M\ninst✝⁸ : AddCommGroup N\ninst✝⁷ : Module R M\ninst✝⁶ : Module R N\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieRingModule L N\ninst✝³ : SizeOf R\ninst✝² : SizeOf L\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ntoLinearMap : LinearMap (RingHom.id R) M N\nmap_lie' : ∀ {x : L} {m : M}, Eq (toLinearMap.toFun (Bracket.bracket x m)) (Bracket.bracket x (toLinearMap.toFun m))\n⊢ Eq (SizeOf.sizeOf { toLinearMap := toLinearMap, map_lie' := map_lie' }) (HAdd.hAdd 1 (SizeOf.sizeOf toLinearMap))","decl":"/-- A morphism of Lie algebra modules (denoted as `M →ₗ⁅R,L⁆ N`) is a linear map\nwhich commutes with the action of the Lie algebra. -/\nstructure LieModuleHom extends M →ₗ[R] N where\n  /-- A module of Lie algebra modules is compatible with the action of the Lie algebra on the\n  modules. -/\n  map_lie' : ∀ {x : L} {m : M}, toFun ⁅x, m⁆ = ⁅x, toFun m⁆\n\n"}
{"name":"LieModuleHom.mk.inj","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\ntoLinearMap✝ : LinearMap (RingHom.id R) M N\nmap_lie'✝ : ∀ {x : L} {m : M}, Eq (toLinearMap✝.toFun (Bracket.bracket x m)) (Bracket.bracket x (toLinearMap✝.toFun m))\ntoLinearMap : LinearMap (RingHom.id R) M N\nmap_lie' : ∀ {x : L} {m : M}, Eq (toLinearMap.toFun (Bracket.bracket x m)) (Bracket.bracket x (toLinearMap.toFun m))\nx✝ : Eq { toLinearMap := toLinearMap✝, map_lie' := map_lie'✝ } { toLinearMap := toLinearMap, map_lie' := map_lie' }\n⊢ Eq toLinearMap✝ toLinearMap","decl":"/-- A morphism of Lie algebra modules (denoted as `M →ₗ⁅R,L⁆ N`) is a linear map\nwhich commutes with the action of the Lie algebra. -/\nstructure LieModuleHom extends M →ₗ[R] N where\n  /-- A module of Lie algebra modules is compatible with the action of the Lie algebra on the\n  modules. -/\n  map_lie' : ∀ {x : L} {m : M}, toFun ⁅x, m⁆ = ⁅x, toFun m⁆\n\n"}
{"name":"LieModuleHom.coe_toLinearMap","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp, norm_cast]\ntheorem coe_toLinearMap (f : M →ₗ⁅R,L⁆ N) : ((f : M →ₗ[R] N) : M → N) = f :=\n  rfl\n\n"}
{"name":"LieModuleHom.map_smul","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\nc : R\nx : M\n⊢ Eq (f (HSMul.hSMul c x)) (HSMul.hSMul c (f x))","decl":"@[simp]\ntheorem map_smul (f : M →ₗ⁅R,L⁆ N) (c : R) (x : M) : f (c • x) = c • f x :=\n  LinearMap.map_smul (f : M →ₗ[R] N) c x\n\n"}
{"name":"LieModuleHom.map_add","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\nx y : M\n⊢ Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))","decl":"@[simp]\ntheorem map_add (f : M →ₗ⁅R,L⁆ N) (x y : M) : f (x + y) = f x + f y :=\n  LinearMap.map_add (f : M →ₗ[R] N) x y\n\n"}
{"name":"LieModuleHom.map_sub","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\nx y : M\n⊢ Eq (f (HSub.hSub x y)) (HSub.hSub (f x) (f y))","decl":"@[simp]\ntheorem map_sub (f : M →ₗ⁅R,L⁆ N) (x y : M) : f (x - y) = f x - f y :=\n  LinearMap.map_sub (f : M →ₗ[R] N) x y\n\n"}
{"name":"LieModuleHom.map_neg","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\nx : M\n⊢ Eq (f (Neg.neg x)) (Neg.neg (f x))","decl":"@[simp]\ntheorem map_neg (f : M →ₗ⁅R,L⁆ N) (x : M) : f (-x) = -f x :=\n  LinearMap.map_neg (f : M →ₗ[R] N) x\n\n"}
{"name":"LieModuleHom.map_lie","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\nx : L\nm : M\n⊢ Eq (f (Bracket.bracket x m)) (Bracket.bracket x (f m))","decl":"@[simp]\ntheorem map_lie (f : M →ₗ⁅R,L⁆ N) (x : L) (m : M) : f ⁅x, m⁆ = ⁅x, f m⁆ :=\n  LieModuleHom.map_lie' f\n\n"}
{"name":"LieModuleHom.map_lie₂","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\nP : Type w₂\ninst✝¹³ : CommRing R\ninst✝¹² : LieRing L\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : AddCommGroup N\ninst✝⁹ : AddCommGroup P\ninst✝⁸ : Module R M\ninst✝⁷ : Module R N\ninst✝⁶ : Module R P\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieRingModule L N\ninst✝³ : LieRingModule L P\ninst✝² : LieAlgebra R L\ninst✝¹ : LieModule R L N\ninst✝ : LieModule R L P\nf : LieModuleHom R L M (LinearMap (RingHom.id R) N P)\nx : L\nm : M\nn : N\n⊢ Eq (Bracket.bracket x ((f m) n)) (HAdd.hAdd ((f (Bracket.bracket x m)) n) ((f m) (Bracket.bracket x n)))","decl":"variable [LieAlgebra R L] [LieModule R L N] [LieModule R L P] in\ntheorem map_lie₂ (f : M →ₗ⁅R,L⁆ N →ₗ[R] P) (x : L) (m : M) (n : N) :\n    ⁅x, f m n⁆ = f ⁅x, m⁆ n + f m ⁅x, n⁆ := by simp only [sub_add_cancel, map_lie, LieHom.lie_apply]\n\n"}
{"name":"LieModuleHom.map_zero","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\n⊢ Eq (f 0) 0","decl":"@[simp]\ntheorem map_zero (f : M →ₗ⁅R,L⁆ N) : f 0 = 0 :=\n  LinearMap.map_zero (f : M →ₗ[R] N)\n\n"}
{"name":"LieModuleHom.coe_id","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ Eq (⇑LieModuleHom.id) id","decl":"@[simp, norm_cast]\ntheorem coe_id : ((id : M →ₗ⁅R,L⁆ M) : M → M) = _root_.id :=\n  rfl\n\n"}
{"name":"LieModuleHom.id_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nx : M\n⊢ Eq (LieModuleHom.id x) x","decl":"theorem id_apply (x : M) : (id : M →ₗ⁅R,L⁆ M) x = x :=\n  rfl\n\n"}
{"name":"LieModuleHom.coe_zero","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\n⊢ Eq (⇑0) 0","decl":"@[norm_cast, simp]\ntheorem coe_zero : ⇑(0 : M →ₗ⁅R,L⁆ N) = 0 :=\n  rfl\n\n"}
{"name":"LieModuleHom.zero_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nm : M\n⊢ Eq (0 m) 0","decl":"theorem zero_apply (m : M) : (0 : M →ₗ⁅R,L⁆ N) m = 0 :=\n  rfl\n\n"}
{"name":"LieModuleHom.coe_injective","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\n⊢ Function.Injective DFunLike.coe","decl":"theorem coe_injective : @Function.Injective (M →ₗ⁅R,L⁆ N) (M → N) (↑) := by\n  rintro ⟨⟨⟨f, _⟩⟩⟩ ⟨⟨⟨g, _⟩⟩⟩ h\n  congr\n\n"}
{"name":"LieModuleHom.ext_iff","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nf g : LieModuleHom R L M N\n⊢ Iff (Eq f g) (∀ (m : M), Eq (f m) (g m))","decl":"@[ext]\ntheorem ext {f g : M →ₗ⁅R,L⁆ N} (h : ∀ m, f m = g m) : f = g :=\n  coe_injective <| funext h\n\n"}
{"name":"LieModuleHom.ext","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nf g : LieModuleHom R L M N\nh : ∀ (m : M), Eq (f m) (g m)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : M →ₗ⁅R,L⁆ N} (h : ∀ m, f m = g m) : f = g :=\n  coe_injective <| funext h\n\n"}
{"name":"LieModuleHom.congr_fun","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nf g : LieModuleHom R L M N\nh : Eq f g\nx : M\n⊢ Eq (f x) (g x)","decl":"theorem congr_fun {f g : M →ₗ⁅R,L⁆ N} (h : f = g) (x : M) : f x = g x :=\n  h ▸ rfl\n\n"}
{"name":"LieModuleHom.mk_coe","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\nh : ∀ {x : L} {m : M}, Eq ((↑f).toFun (Bracket.bracket x m)) (Bracket.bracket x ((↑f).toFun m))\n⊢ Eq { toLinearMap := ↑f, map_lie' := h } f","decl":"@[simp]\ntheorem mk_coe (f : M →ₗ⁅R,L⁆ N) (h) : (⟨f, h⟩ : M →ₗ⁅R,L⁆ N) = f := by\n  rfl\n\n"}
{"name":"LieModuleHom.coe_mk","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nf : LinearMap (RingHom.id R) M N\nh : ∀ {x : L} {m : M}, Eq (f.toFun (Bracket.bracket x m)) (Bracket.bracket x (f.toFun m))\n⊢ Eq ⇑{ toLinearMap := f, map_lie' := h } ⇑f","decl":"@[simp]\ntheorem coe_mk (f : M →ₗ[R] N) (h) : ((⟨f, h⟩ : M →ₗ⁅R,L⁆ N) : M → N) = f := by\n  rfl\n\n"}
{"name":"LieModuleHom.coe_linear_mk","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nf : LinearMap (RingHom.id R) M N\nh : ∀ {x : L} {m : M}, Eq (f.toFun (Bracket.bracket x m)) (Bracket.bracket x (f.toFun m))\n⊢ Eq (↑{ toLinearMap := f, map_lie' := h }) f","decl":"@[norm_cast]\ntheorem coe_linear_mk (f : M →ₗ[R] N) (h) : ((⟨f, h⟩ : M →ₗ⁅R,L⁆ N) : M →ₗ[R] N) = f := by\n  rfl\n\n"}
{"name":"LieModuleHom.comp_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\nP : Type w₂\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : AddCommGroup N\ninst✝⁶ : AddCommGroup P\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : Module R P\ninst✝² : LieRingModule L M\ninst✝¹ : LieRingModule L N\ninst✝ : LieRingModule L P\nf : LieModuleHom R L N P\ng : LieModuleHom R L M N\nm : M\n⊢ Eq ((f.comp g) m) (f (g m))","decl":"theorem comp_apply (f : N →ₗ⁅R,L⁆ P) (g : M →ₗ⁅R,L⁆ N) (m : M) : f.comp g m = f (g m) :=\n  rfl\n\n"}
{"name":"LieModuleHom.coe_comp","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\nP : Type w₂\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : AddCommGroup N\ninst✝⁶ : AddCommGroup P\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : Module R P\ninst✝² : LieRingModule L M\ninst✝¹ : LieRingModule L N\ninst✝ : LieRingModule L P\nf : LieModuleHom R L N P\ng : LieModuleHom R L M N\n⊢ Eq (⇑(f.comp g)) (Function.comp ⇑f ⇑g)","decl":"@[norm_cast, simp]\ntheorem coe_comp (f : N →ₗ⁅R,L⁆ P) (g : M →ₗ⁅R,L⁆ N) : ⇑(f.comp g) = f ∘ g :=\n  rfl\n\n"}
{"name":"LieModuleHom.toLinearMap_comp","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\nP : Type w₂\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : AddCommGroup N\ninst✝⁶ : AddCommGroup P\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : Module R P\ninst✝² : LieRingModule L M\ninst✝¹ : LieRingModule L N\ninst✝ : LieRingModule L P\nf : LieModuleHom R L N P\ng : LieModuleHom R L M N\n⊢ Eq (↑(f.comp g)) ((↑f).comp ↑g)","decl":"@[norm_cast, simp]\ntheorem toLinearMap_comp (f : N →ₗ⁅R,L⁆ P) (g : M →ₗ⁅R,L⁆ N) :\n    (f.comp g : M →ₗ[R] P) = (f : N →ₗ[R] P).comp (g : M →ₗ[R] N) :=\n  rfl\n\n"}
{"name":"LieModuleHom.coe_linearMap_comp","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\nP : Type w₂\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : AddCommGroup N\ninst✝⁶ : AddCommGroup P\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : Module R P\ninst✝² : LieRingModule L M\ninst✝¹ : LieRingModule L N\ninst✝ : LieRingModule L P\nf : LieModuleHom R L N P\ng : LieModuleHom R L M N\n⊢ Eq (↑(f.comp g)) ((↑f).comp ↑g)","decl":"@[deprecated (since := \"2024-12-30\")] alias coe_linearMap_comp := toLinearMap_comp\n\n"}
{"name":"LieModuleHom.coe_add","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nf g : LieModuleHom R L M N\n⊢ Eq (⇑(HAdd.hAdd f g)) (HAdd.hAdd ⇑f ⇑g)","decl":"@[norm_cast, simp]\ntheorem coe_add (f g : M →ₗ⁅R,L⁆ N) : ⇑(f + g) = f + g :=\n  rfl\n\n"}
{"name":"LieModuleHom.add_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nf g : LieModuleHom R L M N\nm : M\n⊢ Eq ((HAdd.hAdd f g) m) (HAdd.hAdd (f m) (g m))","decl":"theorem add_apply (f g : M →ₗ⁅R,L⁆ N) (m : M) : (f + g) m = f m + g m :=\n  rfl\n\n"}
{"name":"LieModuleHom.coe_sub","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nf g : LieModuleHom R L M N\n⊢ Eq (⇑(HSub.hSub f g)) (HSub.hSub ⇑f ⇑g)","decl":"@[norm_cast, simp]\ntheorem coe_sub (f g : M →ₗ⁅R,L⁆ N) : ⇑(f - g) = f - g :=\n  rfl\n\n"}
{"name":"LieModuleHom.sub_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nf g : LieModuleHom R L M N\nm : M\n⊢ Eq ((HSub.hSub f g) m) (HSub.hSub (f m) (g m))","decl":"theorem sub_apply (f g : M →ₗ⁅R,L⁆ N) (m : M) : (f - g) m = f m - g m :=\n  rfl\n\n"}
{"name":"LieModuleHom.coe_neg","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\n⊢ Eq (⇑(Neg.neg f)) (Neg.neg ⇑f)","decl":"@[norm_cast, simp]\ntheorem coe_neg (f : M →ₗ⁅R,L⁆ N) : ⇑(-f) = -f :=\n  rfl\n\n"}
{"name":"LieModuleHom.neg_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\nm : M\n⊢ Eq ((Neg.neg f) m) (Neg.neg (f m))","decl":"theorem neg_apply (f : M →ₗ⁅R,L⁆ N) (m : M) : (-f) m = -f m :=\n  rfl\n\n"}
{"name":"LieModuleHom.coe_nsmul","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nn : Nat\nf : LieModuleHom R L M N\n⊢ Eq (⇑(HSMul.hSMul n f)) (HSMul.hSMul n ⇑f)","decl":"@[norm_cast, simp]\ntheorem coe_nsmul (n : ℕ) (f : M →ₗ⁅R,L⁆ N) : ⇑(n • f) = n • (⇑f) :=\n  rfl\n\n"}
{"name":"LieModuleHom.nsmul_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nn : Nat\nf : LieModuleHom R L M N\nm : M\n⊢ Eq ((HSMul.hSMul n f) m) (HSMul.hSMul n (f m))","decl":"theorem nsmul_apply (n : ℕ) (f : M →ₗ⁅R,L⁆ N) (m : M) : (n • f) m = n • f m :=\n  rfl\n\n"}
{"name":"LieModuleHom.coe_zsmul","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nz : Int\nf : LieModuleHom R L M N\n⊢ Eq (⇑(HSMul.hSMul z f)) (HSMul.hSMul z ⇑f)","decl":"@[norm_cast, simp]\ntheorem coe_zsmul (z : ℤ) (f : M →ₗ⁅R,L⁆ N) : ⇑(z • f) = z • (⇑f) :=\n  rfl\n\n"}
{"name":"LieModuleHom.zsmul_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nz : Int\nf : LieModuleHom R L M N\nm : M\n⊢ Eq ((HSMul.hSMul z f) m) (HSMul.hSMul z (f m))","decl":"theorem zsmul_apply (z : ℤ) (f : M →ₗ⁅R,L⁆ N) (m : M) : (z • f) m = z • f m :=\n  rfl\n\n"}
{"name":"LieModuleHom.coe_smul","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁹ : CommRing R\ninst✝⁸ : LieRing L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : LieRingModule L M\ninst✝² : LieRingModule L N\ninst✝¹ : LieAlgebra R L\ninst✝ : LieModule R L N\nt : R\nf : LieModuleHom R L M N\n⊢ Eq (⇑(HSMul.hSMul t f)) (HSMul.hSMul t ⇑f)","decl":"@[norm_cast, simp]\ntheorem coe_smul (t : R) (f : M →ₗ⁅R,L⁆ N) : ⇑(t • f) = t • (⇑f) :=\n  rfl\n\n"}
{"name":"LieModuleHom.smul_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁹ : CommRing R\ninst✝⁸ : LieRing L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : LieRingModule L M\ninst✝² : LieRingModule L N\ninst✝¹ : LieAlgebra R L\ninst✝ : LieModule R L N\nt : R\nf : LieModuleHom R L M N\nm : M\n⊢ Eq ((HSMul.hSMul t f) m) (HSMul.hSMul t (f m))","decl":"theorem smul_apply (t : R) (f : M →ₗ⁅R,L⁆ N) (m : M) : (t • f) m = t • f m :=\n  rfl\n\n"}
{"name":"LieModuleEquiv.right_inv","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nself : LieModuleEquiv R L M N\n⊢ Function.RightInverse self.invFun (↑self.toLieModuleHom).toFun","decl":"/-- An equivalence of Lie algebra modules (denoted as `M ≃ₗ⁅R,L⁆ N`) is a linear equivalence\nwhich is also a morphism of Lie algebra modules. -/\nstructure LieModuleEquiv extends M →ₗ⁅R,L⁆ N where\n  /-- The inverse function of an equivalence of Lie modules -/\n  invFun : N → M\n  /-- The inverse function of an equivalence of Lie modules is a left inverse of the underlying\n  function. -/\n  left_inv : Function.LeftInverse invFun toFun\n  /-- The inverse function of an equivalence of Lie modules is a right inverse of the underlying\n  function. -/\n  right_inv : Function.RightInverse invFun toFun\n\n"}
{"name":"LieModuleEquiv.left_inv","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nself : LieModuleEquiv R L M N\n⊢ Function.LeftInverse self.invFun (↑self.toLieModuleHom).toFun","decl":"/-- An equivalence of Lie algebra modules (denoted as `M ≃ₗ⁅R,L⁆ N`) is a linear equivalence\nwhich is also a morphism of Lie algebra modules. -/\nstructure LieModuleEquiv extends M →ₗ⁅R,L⁆ N where\n  /-- The inverse function of an equivalence of Lie modules -/\n  invFun : N → M\n  /-- The inverse function of an equivalence of Lie modules is a left inverse of the underlying\n  function. -/\n  left_inv : Function.LeftInverse invFun toFun\n  /-- The inverse function of an equivalence of Lie modules is a right inverse of the underlying\n  function. -/\n  right_inv : Function.RightInverse invFun toFun\n\n"}
{"name":"LieModuleEquiv.mk.sizeOf_spec","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : LieRing L\ninst✝⁹ : AddCommGroup M\ninst✝⁸ : AddCommGroup N\ninst✝⁷ : Module R M\ninst✝⁶ : Module R N\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieRingModule L N\ninst✝³ : SizeOf R\ninst✝² : SizeOf L\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ntoLieModuleHom : LieModuleHom R L M N\ninvFun : N → M\nleft_inv : Function.LeftInverse invFun (↑toLieModuleHom).toFun\nright_inv : Function.RightInverse invFun (↑toLieModuleHom).toFun\n⊢ Eq (SizeOf.sizeOf { toLieModuleHom := toLieModuleHom, invFun := invFun, left_inv := left_inv, right_inv := right_inv }) (HAdd.hAdd 1 (SizeOf.sizeOf toLieModuleHom))","decl":"/-- An equivalence of Lie algebra modules (denoted as `M ≃ₗ⁅R,L⁆ N`) is a linear equivalence\nwhich is also a morphism of Lie algebra modules. -/\nstructure LieModuleEquiv extends M →ₗ⁅R,L⁆ N where\n  /-- The inverse function of an equivalence of Lie modules -/\n  invFun : N → M\n  /-- The inverse function of an equivalence of Lie modules is a left inverse of the underlying\n  function. -/\n  left_inv : Function.LeftInverse invFun toFun\n  /-- The inverse function of an equivalence of Lie modules is a right inverse of the underlying\n  function. -/\n  right_inv : Function.RightInverse invFun toFun\n\n"}
{"name":"LieModuleEquiv.mk.inj","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\ntoLieModuleHom✝ : LieModuleHom R L M N\ninvFun✝ : N → M\nleft_inv✝ : Function.LeftInverse invFun✝ (↑toLieModuleHom✝).toFun\nright_inv✝ : Function.RightInverse invFun✝ (↑toLieModuleHom✝).toFun\ntoLieModuleHom : LieModuleHom R L M N\ninvFun : N → M\nleft_inv : Function.LeftInverse invFun (↑toLieModuleHom).toFun\nright_inv : Function.RightInverse invFun (↑toLieModuleHom).toFun\nx✝ : Eq { toLieModuleHom := toLieModuleHom✝, invFun := invFun✝, left_inv := left_inv✝, right_inv := right_inv✝ } { toLieModuleHom := toLieModuleHom, invFun := invFun, left_inv := left_inv, right_inv := right_inv }\n⊢ And (Eq toLieModuleHom✝ toLieModuleHom) (Eq invFun✝ invFun)","decl":"/-- An equivalence of Lie algebra modules (denoted as `M ≃ₗ⁅R,L⁆ N`) is a linear equivalence\nwhich is also a morphism of Lie algebra modules. -/\nstructure LieModuleEquiv extends M →ₗ⁅R,L⁆ N where\n  /-- The inverse function of an equivalence of Lie modules -/\n  invFun : N → M\n  /-- The inverse function of an equivalence of Lie modules is a left inverse of the underlying\n  function. -/\n  left_inv : Function.LeftInverse invFun toFun\n  /-- The inverse function of an equivalence of Lie modules is a right inverse of the underlying\n  function. -/\n  right_inv : Function.RightInverse invFun toFun\n\n"}
{"name":"LieModuleEquiv.mk.injEq","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\ntoLieModuleHom✝ : LieModuleHom R L M N\ninvFun✝ : N → M\nleft_inv✝ : Function.LeftInverse invFun✝ (↑toLieModuleHom✝).toFun\nright_inv✝ : Function.RightInverse invFun✝ (↑toLieModuleHom✝).toFun\ntoLieModuleHom : LieModuleHom R L M N\ninvFun : N → M\nleft_inv : Function.LeftInverse invFun (↑toLieModuleHom).toFun\nright_inv : Function.RightInverse invFun (↑toLieModuleHom).toFun\n⊢ Eq (Eq { toLieModuleHom := toLieModuleHom✝, invFun := invFun✝, left_inv := left_inv✝, right_inv := right_inv✝ } { toLieModuleHom := toLieModuleHom, invFun := invFun, left_inv := left_inv, right_inv := right_inv }) (And (Eq toLieModuleHom✝ toLieModuleHom) (Eq invFun✝ invFun))","decl":"/-- An equivalence of Lie algebra modules (denoted as `M ≃ₗ⁅R,L⁆ N`) is a linear equivalence\nwhich is also a morphism of Lie algebra modules. -/\nstructure LieModuleEquiv extends M →ₗ⁅R,L⁆ N where\n  /-- The inverse function of an equivalence of Lie modules -/\n  invFun : N → M\n  /-- The inverse function of an equivalence of Lie modules is a left inverse of the underlying\n  function. -/\n  left_inv : Function.LeftInverse invFun toFun\n  /-- The inverse function of an equivalence of Lie modules is a right inverse of the underlying\n  function. -/\n  right_inv : Function.RightInverse invFun toFun\n\n"}
{"name":"LieModuleEquiv.coe_coe","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\ne : LieModuleEquiv R L M N\n⊢ Eq ⇑e.toLieModuleHom ⇑e","decl":"@[simp] lemma coe_coe (e : M ≃ₗ⁅R,L⁆ N) : ⇑(e : M →ₗ⁅R,L⁆ N) = e := rfl\n\n"}
{"name":"LieModuleEquiv.injective","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\ne : LieModuleEquiv R L M N\n⊢ Function.Injective ⇑e","decl":"theorem injective (e : M ≃ₗ⁅R,L⁆ N) : Function.Injective e :=\n  e.toEquiv.injective\n\n"}
{"name":"LieModuleEquiv.surjective","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\ne : LieModuleEquiv R L M N\n⊢ Function.Surjective ⇑e","decl":"theorem surjective (e : M ≃ₗ⁅R,L⁆ N) : Function.Surjective e :=\n  e.toEquiv.surjective\n\n"}
{"name":"LieModuleEquiv.toEquiv_mk","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\ng : N → M\nh₁ : Function.LeftInverse g (↑f).toFun\nh₂ : Function.RightInverse g (↑f).toFun\n⊢ Eq { toLieModuleHom := f, invFun := g, left_inv := h₁, right_inv := h₂ }.toEquiv { toFun := ⇑f, invFun := g, left_inv := h₁, right_inv := h₂ }","decl":"@[simp]\ntheorem toEquiv_mk (f : M →ₗ⁅R,L⁆ N) (g : N → M) (h₁ h₂) :\n    toEquiv (mk f g h₁ h₂ : M ≃ₗ⁅R,L⁆ N) = Equiv.mk f g h₁ h₂ :=\n  rfl\n\n"}
{"name":"LieModuleEquiv.coe_mk","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\ninvFun : N → M\nh₁ : Function.LeftInverse invFun (↑f).toFun\nh₂ : Function.RightInverse invFun (↑f).toFun\n⊢ Eq ⇑{ toLieModuleHom := f, invFun := invFun, left_inv := h₁, right_inv := h₂ } ⇑f","decl":"@[simp]\ntheorem coe_mk (f : M →ₗ⁅R,L⁆ N) (invFun h₁ h₂) :\n    ((⟨f, invFun, h₁, h₂⟩ : M ≃ₗ⁅R,L⁆ N) : M → N) = f :=\n  rfl\n\n"}
{"name":"LieModuleEquiv.coe_toLieModuleHom","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\ne : LieModuleEquiv R L M N\n⊢ Eq ⇑e.toLieModuleHom ⇑e","decl":"theorem coe_toLieModuleHom (e : M ≃ₗ⁅R,L⁆ N) : ⇑(e : M →ₗ⁅R,L⁆ N) = e :=\n  rfl\n\n"}
{"name":"LieModuleEquiv.coe_to_lieModuleHom","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\ne : LieModuleEquiv R L M N\n⊢ Eq ⇑e.toLieModuleHom ⇑e","decl":"@[deprecated (since := \"2024-12-30\")] alias coe_to_lieModuleHom := coe_toLieModuleHom\n\n"}
{"name":"LieModuleEquiv.coe_toLinearEquiv","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\ne : LieModuleEquiv R L M N\n⊢ Eq ⇑e.toLinearEquiv ⇑e","decl":"@[simp]\ntheorem coe_toLinearEquiv (e : M ≃ₗ⁅R,L⁆ N) : ((e : M ≃ₗ[R] N) : M → N) = e :=\n  rfl\n\n"}
{"name":"LieModuleEquiv.coe_to_linearEquiv","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\ne : LieModuleEquiv R L M N\n⊢ Eq ⇑e.toLinearEquiv ⇑e","decl":"@[deprecated (since := \"2024-12-30\")] alias coe_to_linearEquiv := coe_toLinearEquiv\n\n"}
{"name":"LieModuleEquiv.toEquiv_injective","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\n⊢ Function.Injective LieModuleEquiv.toEquiv","decl":"theorem toEquiv_injective : Function.Injective (toEquiv : (M ≃ₗ⁅R,L⁆ N) → M ≃ N) := by\n  rintro ⟨⟨⟨⟨f, -⟩, -⟩, -⟩, f_inv⟩ ⟨⟨⟨⟨g, -⟩, -⟩, -⟩, g_inv⟩\n  intro h\n  simp only [toEquiv_mk, LieModuleHom.coe_mk, LinearMap.coe_mk, AddHom.coe_mk, Equiv.mk.injEq] at h\n  congr\n  exacts [h.1, h.2]\n\n"}
{"name":"LieModuleEquiv.ext","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\ne₁ e₂ : LieModuleEquiv R L M N\nh : ∀ (m : M), Eq (e₁ m) (e₂ m)\n⊢ Eq e₁ e₂","decl":"@[ext]\ntheorem ext (e₁ e₂ : M ≃ₗ⁅R,L⁆ N) (h : ∀ m, e₁ m = e₂ m) : e₁ = e₂ :=\n  toEquiv_injective (Equiv.ext h)\n\n"}
{"name":"LieModuleEquiv.ext_iff","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\ne₁ e₂ : LieModuleEquiv R L M N\n⊢ Iff (Eq e₁ e₂) (∀ (m : M), Eq (e₁ m) (e₂ m))","decl":"@[ext]\ntheorem ext (e₁ e₂ : M ≃ₗ⁅R,L⁆ N) (h : ∀ m, e₁ m = e₂ m) : e₁ = e₂ :=\n  toEquiv_injective (Equiv.ext h)\n\n"}
{"name":"LieModuleEquiv.one_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nm : M\n⊢ Eq (1 m) m","decl":"@[simp]\ntheorem one_apply (m : M) : (1 : M ≃ₗ⁅R,L⁆ M) m = m :=\n  rfl\n\n"}
{"name":"LieModuleEquiv.refl_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nm : M\n⊢ Eq (LieModuleEquiv.refl m) m","decl":"@[simp]\ntheorem refl_apply (m : M) : (refl : M ≃ₗ⁅R,L⁆ M) m = m :=\n  rfl\n\n"}
{"name":"LieModuleEquiv.apply_symm_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\ne : LieModuleEquiv R L M N\nx : N\n⊢ Eq (e (e.symm x)) x","decl":"@[simp]\ntheorem apply_symm_apply (e : M ≃ₗ⁅R,L⁆ N) : ∀ x, e (e.symm x) = x :=\n  e.toLinearEquiv.apply_symm_apply\n\n"}
{"name":"LieModuleEquiv.symm_apply_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\ne : LieModuleEquiv R L M N\nx : M\n⊢ Eq (e.symm (e x)) x","decl":"@[simp]\ntheorem symm_apply_apply (e : M ≃ₗ⁅R,L⁆ N) : ∀ x, e.symm (e x) = x :=\n  e.toLinearEquiv.symm_apply_apply\n\n"}
{"name":"LieModuleEquiv.apply_eq_iff_eq_symm_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\nm : M\nn : N\ne : LieModuleEquiv R L M N\n⊢ Iff (Eq (e m) n) (Eq m (e.symm n))","decl":"theorem apply_eq_iff_eq_symm_apply {m : M} {n : N} (e : M ≃ₗ⁅R,L⁆ N) :\n    e m = n ↔ m = e.symm n :=\n  (e : M ≃ N).apply_eq_iff_eq_symm_apply\n\n"}
{"name":"LieModuleEquiv.symm_symm","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\ne : LieModuleEquiv R L M N\n⊢ Eq e.symm.symm e","decl":"@[simp]\ntheorem symm_symm (e : M ≃ₗ⁅R,L⁆ N) : e.symm.symm = e := rfl\n\n"}
{"name":"LieModuleEquiv.symm_bijective","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\n⊢ Function.Bijective LieModuleEquiv.symm","decl":"theorem symm_bijective :\n    Function.Bijective (LieModuleEquiv.symm : (M ≃ₗ⁅R,L⁆ N) → N ≃ₗ⁅R,L⁆ M) :=\n  Function.bijective_iff_has_inverse.mpr ⟨_, symm_symm, symm_symm⟩\n\n"}
{"name":"LieModuleEquiv.trans_apply","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\nP : Type w₂\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : AddCommGroup N\ninst✝⁶ : AddCommGroup P\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : Module R P\ninst✝² : LieRingModule L M\ninst✝¹ : LieRingModule L N\ninst✝ : LieRingModule L P\ne₁ : LieModuleEquiv R L M N\ne₂ : LieModuleEquiv R L N P\nm : M\n⊢ Eq ((e₁.trans e₂) m) (e₂ (e₁ m))","decl":"@[simp]\ntheorem trans_apply (e₁ : M ≃ₗ⁅R,L⁆ N) (e₂ : N ≃ₗ⁅R,L⁆ P) (m : M) : (e₁.trans e₂) m = e₂ (e₁ m) :=\n  rfl\n\n"}
{"name":"LieModuleEquiv.symm_trans","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\nP : Type w₂\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : AddCommGroup N\ninst✝⁶ : AddCommGroup P\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : Module R P\ninst✝² : LieRingModule L M\ninst✝¹ : LieRingModule L N\ninst✝ : LieRingModule L P\ne₁ : LieModuleEquiv R L M N\ne₂ : LieModuleEquiv R L N P\n⊢ Eq (e₁.trans e₂).symm (e₂.symm.trans e₁.symm)","decl":"@[simp]\ntheorem symm_trans (e₁ : M ≃ₗ⁅R,L⁆ N) (e₂ : N ≃ₗ⁅R,L⁆ P) :\n    (e₁.trans e₂).symm = e₂.symm.trans e₁.symm :=\n  rfl\n\n"}
{"name":"LieModuleEquiv.self_trans_symm","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\ne : LieModuleEquiv R L M N\n⊢ Eq (e.trans e.symm) LieModuleEquiv.refl","decl":"@[simp]\ntheorem self_trans_symm (e : M ≃ₗ⁅R,L⁆ N) : e.trans e.symm = refl :=\n  ext _ _ e.symm_apply_apply\n\n"}
{"name":"LieModuleEquiv.symm_trans_self","module":"Mathlib.Algebra.Lie.Basic","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : LieRingModule L M\ninst✝ : LieRingModule L N\ne : LieModuleEquiv R L M N\n⊢ Eq (e.symm.trans e) LieModuleEquiv.refl","decl":"@[simp]\ntheorem symm_trans_self (e : M ≃ₗ⁅R,L⁆ N) : e.symm.trans e = refl :=\n  ext _ _ e.apply_symm_apply\n\n"}
