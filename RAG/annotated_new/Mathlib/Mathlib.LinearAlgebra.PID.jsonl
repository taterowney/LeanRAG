{"name":"LinearMap.trace_restrict_eq_of_forall_mem","module":"Mathlib.LinearAlgebra.PID","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : Module.Finite R M\ninst✝² : Module.Free R M\ninst✝¹ : IsDomain R\ninst✝ : IsPrincipalIdealRing R\np : Submodule R M\nf : LinearMap (RingHom.id R) M M\nhf : ∀ (x : M), Membership.mem p (f x)\nhf' : optParam (∀ (x : M), Membership.mem p x → Membership.mem p (f x)) ⋯\n⊢ Eq ((LinearMap.trace R (Subtype fun x => Membership.mem p x)) (f.restrict hf')) ((LinearMap.trace R M) f)","decl":"/-- If a linear endomorphism of a (finite, free) module `M` takes values in a submodule `p ⊆ M`,\nthen the trace of its restriction to `p` is equal to its trace on `M`. -/\nlemma trace_restrict_eq_of_forall_mem [IsDomain R] [IsPrincipalIdealRing R]\n    (p : Submodule R M) (f : M →ₗ[R] M)\n    (hf : ∀ x, f x ∈ p) (hf' : ∀ x ∈ p, f x ∈ p := fun x _ ↦ hf x) :\n    trace R p (f.restrict hf') = trace R M f := by\n  let ι := Module.Free.ChooseBasisIndex R M\n  obtain ⟨n, snf : Basis.SmithNormalForm p ι n⟩ := p.smithNormalForm (Module.Free.chooseBasis R M)\n  rw [trace_eq_matrix_trace R snf.bM, trace_eq_matrix_trace R snf.bN]\n  set A : Matrix (Fin n) (Fin n) R := toMatrix snf.bN snf.bN (f.restrict hf')\n  set B : Matrix ι ι R := toMatrix snf.bM snf.bM f\n  have aux : ∀ i, B i i ≠ 0 → i ∈ Set.range snf.f := fun i hi ↦ by\n    contrapose! hi; exact snf.repr_eq_zero_of_nmem_range ⟨_, (hf _)⟩ hi\n  change ∑ i, A i i = ∑ i, B i i\n  rw [← Finset.sum_filter_of_ne (p := fun j ↦ j ∈ Set.range snf.f) (by simpa using aux)]\n  simp [A, B]\n\n"}
