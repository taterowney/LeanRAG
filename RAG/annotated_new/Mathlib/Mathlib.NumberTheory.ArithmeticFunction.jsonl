{"name":"ArithmeticFunction.toFun_eq","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : Zero R\nf : ArithmeticFunction R\n⊢ Eq f.toFun ⇑f","decl":"@[simp]\ntheorem toFun_eq (f : ArithmeticFunction R) : f.toFun = f := rfl\n\n"}
{"name":"ArithmeticFunction.coe_mk","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : Zero R\nf : Nat → R\nhf : Eq (f 0) 0\n⊢ Eq (⇑{ toFun := f, map_zero' := hf }) f","decl":"@[simp]\ntheorem coe_mk (f : ℕ → R) (hf) : @DFunLike.coe (ArithmeticFunction R) _ _ _\n    (ZeroHom.mk f hf) = f := rfl\n\n"}
{"name":"ArithmeticFunction.map_zero","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : Zero R\nf : ArithmeticFunction R\n⊢ Eq (f 0) 0","decl":"@[simp]\ntheorem map_zero {f : ArithmeticFunction R} : f 0 = 0 :=\n  ZeroHom.map_zero' f\n\n"}
{"name":"ArithmeticFunction.coe_inj","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : Zero R\nf g : ArithmeticFunction R\n⊢ Iff (Eq ⇑f ⇑g) (Eq f g)","decl":"theorem coe_inj {f g : ArithmeticFunction R} : (f : ℕ → R) = g ↔ f = g :=\n  DFunLike.coe_fn_eq\n\n"}
{"name":"ArithmeticFunction.zero_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : Zero R\nx : Nat\n⊢ Eq (0 x) 0","decl":"@[simp]\ntheorem zero_apply {x : ℕ} : (0 : ArithmeticFunction R) x = 0 :=\n  ZeroHom.zero_apply x\n\n"}
{"name":"ArithmeticFunction.ext","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : Zero R\nf g : ArithmeticFunction R\nh : ∀ (x : Nat), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext ⦃f g : ArithmeticFunction R⦄ (h : ∀ x, f x = g x) : f = g :=\n  ZeroHom.ext h\n\n"}
{"name":"ArithmeticFunction.ext_iff","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : Zero R\nf g : ArithmeticFunction R\n⊢ Iff (Eq f g) (∀ (x : Nat), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext ⦃f g : ArithmeticFunction R⦄ (h : ∀ x, f x = g x) : f = g :=\n  ZeroHom.ext h\n\n"}
{"name":"ArithmeticFunction.one_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝¹ : Zero R\ninst✝ : One R\nx : Nat\n⊢ Eq (1 x) (ite (Eq x 1) 1 0)","decl":"theorem one_apply {x : ℕ} : (1 : ArithmeticFunction R) x = ite (x = 1) 1 0 :=\n  rfl\n\n"}
{"name":"ArithmeticFunction.one_one","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝¹ : Zero R\ninst✝ : One R\n⊢ Eq (1 1) 1","decl":"@[simp]\ntheorem one_one : (1 : ArithmeticFunction R) 1 = 1 :=\n  rfl\n\n"}
{"name":"ArithmeticFunction.one_apply_ne","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝¹ : Zero R\ninst✝ : One R\nx : Nat\nh : Ne x 1\n⊢ Eq (1 x) 0","decl":"@[simp]\ntheorem one_apply_ne {x : ℕ} (h : x ≠ 1) : (1 : ArithmeticFunction R) x = 0 :=\n  if_neg h\n\n"}
{"name":"ArithmeticFunction.natCoe_nat","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"f : ArithmeticFunction Nat\n⊢ Eq (↑f) f","decl":"@[simp]\ntheorem natCoe_nat (f : ArithmeticFunction ℕ) : natToArithmeticFunction f = f :=\n  ext fun _ => cast_id _\n\n"}
{"name":"ArithmeticFunction.natCoe_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\nf : ArithmeticFunction Nat\nx : Nat\n⊢ Eq (↑f x) ↑(f x)","decl":"@[simp]\ntheorem natCoe_apply [AddMonoidWithOne R] {f : ArithmeticFunction ℕ} {x : ℕ} :\n    (f : ArithmeticFunction R) x = f x :=\n  rfl\n\n"}
{"name":"ArithmeticFunction.intCoe_int","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"f : ArithmeticFunction Int\n⊢ Eq (↑f) f","decl":"@[simp]\ntheorem intCoe_int (f : ArithmeticFunction ℤ) : ofInt f = f :=\n  ext fun _ => Int.cast_id\n\n"}
{"name":"ArithmeticFunction.intCoe_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : AddGroupWithOne R\nf : ArithmeticFunction Int\nx : Nat\n⊢ Eq (↑f x) ↑(f x)","decl":"@[simp]\ntheorem intCoe_apply [AddGroupWithOne R] {f : ArithmeticFunction ℤ} {x : ℕ} :\n    (f : ArithmeticFunction R) x = f x := rfl\n\n"}
{"name":"ArithmeticFunction.coe_coe","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : AddGroupWithOne R\nf : ArithmeticFunction Nat\n⊢ Eq ↑↑f ↑f","decl":"@[simp]\ntheorem coe_coe [AddGroupWithOne R] {f : ArithmeticFunction ℕ} :\n    ((f : ArithmeticFunction ℤ) : ArithmeticFunction R) = (f : ArithmeticFunction R) := by\n  ext\n  simp\n\n"}
{"name":"ArithmeticFunction.natCoe_one","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\n⊢ Eq (↑1) 1","decl":"@[simp]\ntheorem natCoe_one [AddMonoidWithOne R] :\n    ((1 : ArithmeticFunction ℕ) : ArithmeticFunction R) = 1 := by\n  ext n\n  simp [one_apply]\n\n"}
{"name":"ArithmeticFunction.intCoe_one","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : AddGroupWithOne R\n⊢ Eq (↑1) 1","decl":"@[simp]\ntheorem intCoe_one [AddGroupWithOne R] : ((1 : ArithmeticFunction ℤ) :\n    ArithmeticFunction R) = 1 := by\n  ext n\n  simp [one_apply]\n\n"}
{"name":"ArithmeticFunction.add_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : AddMonoid R\nf g : ArithmeticFunction R\nn : Nat\n⊢ Eq ((HAdd.hAdd f g) n) (HAdd.hAdd (f n) (g n))","decl":"@[simp]\ntheorem add_apply {f g : ArithmeticFunction R} {n : ℕ} : (f + g) n = f n + g n :=\n  rfl\n\n"}
{"name":"ArithmeticFunction.smul_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Zero R\ninst✝¹ : AddCommMonoid M\ninst✝ : SMul R M\nf : ArithmeticFunction R\ng : ArithmeticFunction M\nn : Nat\n⊢ Eq ((HSMul.hSMul f g) n) (n.divisorsAntidiagonal.sum fun x => HSMul.hSMul (f x.1) (g x.2))","decl":"@[simp]\ntheorem smul_apply {f : ArithmeticFunction R} {g : ArithmeticFunction M} {n : ℕ} :\n    (f • g) n = ∑ x ∈ divisorsAntidiagonal n, f x.fst • g x.snd :=\n  rfl\n\n"}
{"name":"ArithmeticFunction.mul_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf g : ArithmeticFunction R\nn : Nat\n⊢ Eq ((HMul.hMul f g) n) (n.divisorsAntidiagonal.sum fun x => HMul.hMul (f x.1) (g x.2))","decl":"@[simp]\ntheorem mul_apply [Semiring R] {f g : ArithmeticFunction R} {n : ℕ} :\n    (f * g) n = ∑ x ∈ divisorsAntidiagonal n, f x.fst * g x.snd :=\n  rfl\n\n"}
{"name":"ArithmeticFunction.mul_apply_one","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf g : ArithmeticFunction R\n⊢ Eq ((HMul.hMul f g) 1) (HMul.hMul (f 1) (g 1))","decl":"theorem mul_apply_one [Semiring R] {f g : ArithmeticFunction R} : (f * g) 1 = f 1 * g 1 := by simp\n\n"}
{"name":"ArithmeticFunction.natCoe_mul","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf g : ArithmeticFunction Nat\n⊢ Eq (↑(HMul.hMul f g)) (HMul.hMul ↑f ↑g)","decl":"@[simp, norm_cast]\ntheorem natCoe_mul [Semiring R] {f g : ArithmeticFunction ℕ} :\n    (↑(f * g) : ArithmeticFunction R) = f * g := by\n  ext n\n  simp\n\n"}
{"name":"ArithmeticFunction.intCoe_mul","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : Ring R\nf g : ArithmeticFunction Int\n⊢ Eq (↑(HMul.hMul f g)) (HMul.hMul ↑f ↑g)","decl":"@[simp, norm_cast]\ntheorem intCoe_mul [Ring R] {f g : ArithmeticFunction ℤ} :\n    (↑(f * g) : ArithmeticFunction R) = ↑f * g := by\n  ext n\n  simp\n\n"}
{"name":"ArithmeticFunction.mul_smul'","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf g : ArithmeticFunction R\nh : ArithmeticFunction M\n⊢ Eq (HSMul.hSMul (HMul.hMul f g) h) (HSMul.hSMul f (HSMul.hSMul g h))","decl":"theorem mul_smul' (f g : ArithmeticFunction R) (h : ArithmeticFunction M) :\n    (f * g) • h = f • g • h := by\n  ext n\n  simp only [mul_apply, smul_apply, sum_smul, mul_smul, smul_sum, Finset.sum_sigma']\n  apply Finset.sum_nbij' (fun ⟨⟨_i, j⟩, ⟨k, l⟩⟩ ↦ ⟨(k, l * j), (l, j)⟩)\n    (fun ⟨⟨i, _j⟩, ⟨k, l⟩⟩ ↦ ⟨(i * k, l), (i, k)⟩) <;> aesop (add simp mul_assoc)\n\n"}
{"name":"ArithmeticFunction.one_smul'","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : ArithmeticFunction M\n⊢ Eq (HSMul.hSMul 1 b) b","decl":"theorem one_smul' (b : ArithmeticFunction M) : (1 : ArithmeticFunction R) • b = b := by\n  ext x\n  rw [smul_apply]\n  by_cases x0 : x = 0\n  · simp [x0]\n  have h : {(1, x)} ⊆ divisorsAntidiagonal x := by simp [x0]\n  rw [← sum_subset h]\n  · simp\n  intro y ymem ynmem\n  have y1ne : y.fst ≠ 1 := by\n    intro con\n    simp only [mem_divisorsAntidiagonal, one_mul, Ne] at ymem\n    simp only [mem_singleton, Prod.ext_iff] at ynmem\n    -- Porting note: `tauto` worked from here.\n    cases y\n    subst con\n    simp only [true_and, one_mul, x0, not_false_eq_true, and_true] at ynmem ymem\n    tauto\n\n  simp [y1ne]\n\n"}
{"name":"ArithmeticFunction.zeta_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"x : Nat\n⊢ Eq (ArithmeticFunction.zeta x) (ite (Eq x 0) 0 1)","decl":"@[simp]\ntheorem zeta_apply {x : ℕ} : ζ x = if x = 0 then 0 else 1 :=\n  rfl\n\n"}
{"name":"ArithmeticFunction.zeta_apply_ne","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"x : Nat\nh : Ne x 0\n⊢ Eq (ArithmeticFunction.zeta x) 1","decl":"theorem zeta_apply_ne {x : ℕ} (h : x ≠ 0) : ζ x = 1 :=\n  if_neg h\n\n-- Porting note: removed `@[simp]`, LHS not in normal form\n"}
{"name":"ArithmeticFunction.coe_zeta_smul_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : ArithmeticFunction M\nx : Nat\n⊢ Eq ((HSMul.hSMul (↑ArithmeticFunction.zeta) f) x) (x.divisors.sum fun i => f i)","decl":"theorem coe_zeta_smul_apply {M} [Semiring R] [AddCommMonoid M] [Module R M]\n    {f : ArithmeticFunction M} {x : ℕ} :\n    ((↑ζ : ArithmeticFunction R) • f) x = ∑ i ∈ divisors x, f i := by\n  rw [smul_apply]\n  trans ∑ i ∈ divisorsAntidiagonal x, f i.snd\n  · refine sum_congr rfl fun i hi => ?_\n    rcases mem_divisorsAntidiagonal.1 hi with ⟨rfl, h⟩\n    rw [natCoe_apply, zeta_apply_ne (left_ne_zero_of_mul h), cast_one, one_smul]\n  · rw [← map_div_left_divisors, sum_map, Function.Embedding.coeFn_mk]\n\n-- Porting note: removed `@[simp]` to make the linter happy.\n"}
{"name":"ArithmeticFunction.coe_zeta_mul_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : ArithmeticFunction R\nx : Nat\n⊢ Eq ((HMul.hMul (↑ArithmeticFunction.zeta) f) x) (x.divisors.sum fun i => f i)","decl":"theorem coe_zeta_mul_apply [Semiring R] {f : ArithmeticFunction R} {x : ℕ} :\n    (↑ζ * f) x = ∑ i ∈ divisors x, f i :=\n  coe_zeta_smul_apply\n\n-- Porting note: removed `@[simp]` to make the linter happy.\n"}
{"name":"ArithmeticFunction.coe_mul_zeta_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : ArithmeticFunction R\nx : Nat\n⊢ Eq ((HMul.hMul f ↑ArithmeticFunction.zeta) x) (x.divisors.sum fun i => f i)","decl":"theorem coe_mul_zeta_apply [Semiring R] {f : ArithmeticFunction R} {x : ℕ} :\n    (f * ζ) x = ∑ i ∈ divisors x, f i := by\n  rw [mul_apply]\n  trans ∑ i ∈ divisorsAntidiagonal x, f i.1\n  · refine sum_congr rfl fun i hi => ?_\n    rcases mem_divisorsAntidiagonal.1 hi with ⟨rfl, h⟩\n    rw [natCoe_apply, zeta_apply_ne (right_ne_zero_of_mul h), cast_one, mul_one]\n  · rw [← map_div_right_divisors, sum_map, Function.Embedding.coeFn_mk]\n\n"}
{"name":"ArithmeticFunction.zeta_mul_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"f : ArithmeticFunction Nat\nx : Nat\n⊢ Eq ((HMul.hMul ArithmeticFunction.zeta f) x) (x.divisors.sum fun i => f i)","decl":"theorem zeta_mul_apply {f : ArithmeticFunction ℕ} {x : ℕ} : (ζ * f) x = ∑ i ∈ divisors x, f i :=\n  coe_zeta_mul_apply\n  -- Porting note: was `by rw [← nat_coe_nat ζ, coe_zeta_mul_apply]`.  Is this `theorem` obsolete?\n\n"}
{"name":"ArithmeticFunction.mul_zeta_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"f : ArithmeticFunction Nat\nx : Nat\n⊢ Eq ((HMul.hMul f ArithmeticFunction.zeta) x) (x.divisors.sum fun i => f i)","decl":"theorem mul_zeta_apply {f : ArithmeticFunction ℕ} {x : ℕ} : (f * ζ) x = ∑ i ∈ divisors x, f i :=\n  coe_mul_zeta_apply\n  -- Porting note: was `by rw [← natCoe_nat ζ, coe_mul_zeta_apply]`.  Is this `theorem` obsolete=\n\n"}
{"name":"ArithmeticFunction.pmul_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : MulZeroClass R\nf g : ArithmeticFunction R\nx : Nat\n⊢ Eq ((f.pmul g) x) (HMul.hMul (f x) (g x))","decl":"@[simp]\ntheorem pmul_apply [MulZeroClass R] {f g : ArithmeticFunction R} {x : ℕ} : f.pmul g x = f x * g x :=\n  rfl\n\n"}
{"name":"ArithmeticFunction.pmul_comm","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nf g : ArithmeticFunction R\n⊢ Eq (f.pmul g) (g.pmul f)","decl":"theorem pmul_comm [CommMonoidWithZero R] (f g : ArithmeticFunction R) : f.pmul g = g.pmul f := by\n  ext\n  simp [mul_comm]\n\n"}
{"name":"ArithmeticFunction.pmul_assoc","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nf₁ f₂ f₃ : ArithmeticFunction R\n⊢ Eq ((f₁.pmul f₂).pmul f₃) (f₁.pmul (f₂.pmul f₃))","decl":"lemma pmul_assoc [CommMonoidWithZero R] (f₁ f₂ f₃ : ArithmeticFunction R) :\n    pmul (pmul f₁ f₂) f₃ = pmul f₁ (pmul f₂ f₃) := by\n  ext\n  simp only [pmul_apply, mul_assoc]\n\n"}
{"name":"ArithmeticFunction.pmul_zeta","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\nf : ArithmeticFunction R\n⊢ Eq (f.pmul ↑ArithmeticFunction.zeta) f","decl":"@[simp]\ntheorem pmul_zeta (f : ArithmeticFunction R) : f.pmul ↑ζ = f := by\n  ext x\n  cases x <;> simp [Nat.succ_ne_zero]\n\n"}
{"name":"ArithmeticFunction.zeta_pmul","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\nf : ArithmeticFunction R\n⊢ Eq ((↑ArithmeticFunction.zeta).pmul f) f","decl":"@[simp]\ntheorem zeta_pmul (f : ArithmeticFunction R) : (ζ : ArithmeticFunction R).pmul f = f := by\n  ext x\n  cases x <;> simp [Nat.succ_ne_zero]\n\n"}
{"name":"ArithmeticFunction.ppow_zero","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : ArithmeticFunction R\n⊢ Eq (f.ppow 0) ↑ArithmeticFunction.zeta","decl":"@[simp]\ntheorem ppow_zero {f : ArithmeticFunction R} : f.ppow 0 = ζ := by rw [ppow, dif_pos rfl]\n\n"}
{"name":"ArithmeticFunction.ppow_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : ArithmeticFunction R\nk x : Nat\nkpos : LT.lt 0 k\n⊢ Eq ((f.ppow k) x) (HPow.hPow (f x) k)","decl":"@[simp]\ntheorem ppow_apply {f : ArithmeticFunction R} {k x : ℕ} (kpos : 0 < k) : f.ppow k x = f x ^ k := by\n  rw [ppow, dif_neg (Nat.ne_of_gt kpos)]\n  rfl\n\n"}
{"name":"ArithmeticFunction.ppow_succ'","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : ArithmeticFunction R\nk : Nat\n⊢ Eq (f.ppow (HAdd.hAdd k 1)) (f.pmul (f.ppow k))","decl":"theorem ppow_succ' {f : ArithmeticFunction R} {k : ℕ} : f.ppow (k + 1) = f.pmul (f.ppow k) := by\n  ext x\n  rw [ppow_apply (Nat.succ_pos k), _root_.pow_succ']\n  induction k <;> simp\n\n"}
{"name":"ArithmeticFunction.ppow_succ","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : ArithmeticFunction R\nk : Nat\nkpos : LT.lt 0 k\n⊢ Eq (f.ppow (HAdd.hAdd k 1)) ((f.ppow k).pmul f)","decl":"theorem ppow_succ {f : ArithmeticFunction R} {k : ℕ} {kpos : 0 < k} :\n    f.ppow (k + 1) = (f.ppow k).pmul f := by\n  ext x\n  rw [ppow_apply (Nat.succ_pos k), _root_.pow_succ]\n  induction k <;> simp\n\n"}
{"name":"ArithmeticFunction.pdiv_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : GroupWithZero R\nf g : ArithmeticFunction R\nn : Nat\n⊢ Eq ((f.pdiv g) n) (HDiv.hDiv (f n) (g n))","decl":"@[simp]\ntheorem pdiv_apply [GroupWithZero R] (f g : ArithmeticFunction R) (n : ℕ) :\n    pdiv f g n = f n / g n := rfl\n\n"}
{"name":"ArithmeticFunction.pdiv_zeta","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : DivisionSemiring R\nf : ArithmeticFunction R\n⊢ Eq (f.pdiv ↑ArithmeticFunction.zeta) f","decl":"/-- This result only holds for `DivisionSemiring`s instead of `GroupWithZero`s because zeta takes\nvalues in ℕ, and hence the coercion requires an `AddMonoidWithOne`. TODO: Generalise zeta -/\n@[simp]\ntheorem pdiv_zeta [DivisionSemiring R] (f : ArithmeticFunction R) :\n    pdiv f zeta = f := by\n  ext n\n  cases n <;> simp [succ_ne_zero]\n\n"}
{"name":"ArithmeticFunction.prodPrimeFactors_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nf : Nat → R\nn : Nat\nhn : Ne n 0\n⊢ Eq ((ArithmeticFunction.prodPrimeFactors fun p => f p) n) (n.primeFactors.prod fun p => f p)","decl":"@[simp]\ntheorem prodPrimeFactors_apply [CommMonoidWithZero R] {f : ℕ → R} {n : ℕ} (hn : n ≠ 0) :\n    ∏ᵖ p ∣ n, f p = ∏ p ∈ n.primeFactors, f p :=\n  if_neg hn\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.map_one","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : MonoidWithZero R\nf : ArithmeticFunction R\nh : f.IsMultiplicative\n⊢ Eq (f 1) 1","decl":"@[simp, arith_mult]\ntheorem map_one {f : ArithmeticFunction R} (h : f.IsMultiplicative) : f 1 = 1 :=\n  h.1\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.map_mul_of_coprime","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : MonoidWithZero R\nf : ArithmeticFunction R\nhf : f.IsMultiplicative\nm n : Nat\nh : m.Coprime n\n⊢ Eq (f (HMul.hMul m n)) (HMul.hMul (f m) (f n))","decl":"@[simp]\ntheorem map_mul_of_coprime {f : ArithmeticFunction R} (hf : f.IsMultiplicative) {m n : ℕ}\n    (h : m.Coprime n) : f (m * n) = f m * f n :=\n  hf.2 h\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.map_prod","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝ : CommMonoidWithZero R\ng : ι → Nat\nf : ArithmeticFunction R\nhf : f.IsMultiplicative\ns : Finset ι\nhs : (↑s).Pairwise (Function.onFun Nat.Coprime g)\n⊢ Eq (f (s.prod fun i => g i)) (s.prod fun i => f (g i))","decl":"open scoped Function in -- required for scoped `on` notation\ntheorem map_prod {ι : Type*} [CommMonoidWithZero R] (g : ι → ℕ) {f : ArithmeticFunction R}\n    (hf : f.IsMultiplicative) (s : Finset ι) (hs : (s : Set ι).Pairwise (Coprime on g)) :\n    f (∏ i ∈ s, g i) = ∏ i ∈ s, f (g i) := by\n  classical\n    induction' s using Finset.induction_on with a s has ih hs\n    · simp [hf]\n    rw [coe_insert, Set.pairwise_insert_of_symmetric (Coprime.symmetric.comap g)] at hs\n    rw [prod_insert has, prod_insert has, hf.map_mul_of_coprime, ih hs.1]\n    exact .prod_right fun i hi => hs.2 _ hi (hi.ne_of_not_mem has).symm\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.map_prod_of_prime","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nf : ArithmeticFunction R\nh_mult : f.IsMultiplicative\nt : Finset Nat\nht : ∀ (p : Nat), Membership.mem t p → Nat.Prime p\n⊢ Eq (f (t.prod fun a => a)) (t.prod fun a => f a)","decl":"theorem map_prod_of_prime [CommSemiring R] {f : ArithmeticFunction R}\n    (h_mult : ArithmeticFunction.IsMultiplicative f)\n    (t : Finset ℕ) (ht : ∀ p ∈ t, p.Prime) :\n    f (∏ a ∈ t, a) = ∏ a ∈ t, f a :=\n  map_prod _ h_mult t fun x hx y hy hxy => (coprime_primes (ht x hx) (ht y hy)).mpr hxy\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.map_prod_of_subset_primeFactors","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nf : ArithmeticFunction R\nh_mult : f.IsMultiplicative\nl : Nat\nt : Finset Nat\nht : HasSubset.Subset t l.primeFactors\n⊢ Eq (f (t.prod fun a => a)) (t.prod fun a => f a)","decl":"theorem map_prod_of_subset_primeFactors [CommSemiring R] {f : ArithmeticFunction R}\n    (h_mult : ArithmeticFunction.IsMultiplicative f) (l : ℕ)\n    (t : Finset ℕ) (ht : t ⊆ l.primeFactors) :\n    f (∏ a ∈ t, a) = ∏ a ∈ t, f a :=\n  map_prod_of_prime h_mult t fun _ a => prime_of_mem_primeFactors (ht a)\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.map_div_of_coprime","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommGroupWithZero R\nf : ArithmeticFunction R\nhf : f.IsMultiplicative\nl d : Nat\nhdl : Dvd.dvd d l\nhl : (HDiv.hDiv l d).Coprime d\nhd : Ne (f d) 0\n⊢ Eq (f (HDiv.hDiv l d)) (HDiv.hDiv (f l) (f d))","decl":"theorem map_div_of_coprime [CommGroupWithZero R] {f : ArithmeticFunction R}\n    (hf : IsMultiplicative f) {l d : ℕ} (hdl : d ∣ l) (hl : (l/d).Coprime d) (hd : f d ≠ 0) :\n    f (l / d) = f l / f d := by\n  apply (div_eq_of_eq_mul hd ..).symm\n  rw [← hf.right hl, Nat.div_mul_cancel hdl]\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.natCast","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\nf : ArithmeticFunction Nat\ninst✝ : Semiring R\nh : f.IsMultiplicative\n⊢ (↑f).IsMultiplicative","decl":"@[arith_mult]\ntheorem natCast {f : ArithmeticFunction ℕ} [Semiring R] (h : f.IsMultiplicative) :\n    IsMultiplicative (f : ArithmeticFunction R) :=\n                                 -- Porting note: was `by simp [cop, h]`\n  ⟨by simp [h], fun {m n} cop => by simp [h.2 cop]⟩\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.intCast","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\nf : ArithmeticFunction Int\ninst✝ : Ring R\nh : f.IsMultiplicative\n⊢ (↑f).IsMultiplicative","decl":"@[arith_mult]\ntheorem intCast {f : ArithmeticFunction ℤ} [Ring R] (h : f.IsMultiplicative) :\n    IsMultiplicative (f : ArithmeticFunction R) :=\n                                 -- Porting note: was `by simp [cop, h]`\n  ⟨by simp [h], fun {m n} cop => by simp [h.2 cop]⟩\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.mul","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nf g : ArithmeticFunction R\nhf : f.IsMultiplicative\nhg : g.IsMultiplicative\n⊢ (HMul.hMul f g).IsMultiplicative","decl":"@[arith_mult]\ntheorem mul [CommSemiring R] {f g : ArithmeticFunction R} (hf : f.IsMultiplicative)\n    (hg : g.IsMultiplicative) : IsMultiplicative (f * g) := by\n  refine ⟨by simp [hf.1, hg.1], ?_⟩\n  simp only [mul_apply]\n  intro m n cop\n  rw [sum_mul_sum, ← sum_product']\n  symm\n  apply sum_nbij fun ((i, j), k, l) ↦ (i * k, j * l)\n  · rintro ⟨⟨a1, a2⟩, ⟨b1, b2⟩⟩ h\n    simp only [mem_divisorsAntidiagonal, Ne, mem_product] at h\n    rcases h with ⟨⟨rfl, ha⟩, ⟨rfl, hb⟩⟩\n    simp only [mem_divisorsAntidiagonal, Nat.mul_eq_zero, Ne]\n    constructor\n    · ring\n    rw [Nat.mul_eq_zero] at *\n    apply not_or_intro ha hb\n  · simp only [Set.InjOn, mem_coe, mem_divisorsAntidiagonal, Ne, mem_product, Prod.mk.inj_iff]\n    rintro ⟨⟨a1, a2⟩, ⟨b1, b2⟩⟩ ⟨⟨rfl, ha⟩, ⟨rfl, hb⟩⟩ ⟨⟨c1, c2⟩, ⟨d1, d2⟩⟩ hcd h\n    simp only [Prod.mk.inj_iff] at h\n    ext <;> dsimp only\n    · trans Nat.gcd (a1 * a2) (a1 * b1)\n      · rw [Nat.gcd_mul_left, cop.coprime_mul_left.coprime_mul_right_right.gcd_eq_one, mul_one]\n      · rw [← hcd.1.1, ← hcd.2.1] at cop\n        rw [← hcd.1.1, h.1, Nat.gcd_mul_left,\n          cop.coprime_mul_left.coprime_mul_right_right.gcd_eq_one, mul_one]\n    · trans Nat.gcd (a1 * a2) (a2 * b2)\n      · rw [mul_comm, Nat.gcd_mul_left, cop.coprime_mul_right.coprime_mul_left_right.gcd_eq_one,\n          mul_one]\n      · rw [← hcd.1.1, ← hcd.2.1] at cop\n        rw [← hcd.1.1, h.2, mul_comm, Nat.gcd_mul_left,\n          cop.coprime_mul_right.coprime_mul_left_right.gcd_eq_one, mul_one]\n    · trans Nat.gcd (b1 * b2) (a1 * b1)\n      · rw [mul_comm, Nat.gcd_mul_right,\n          cop.coprime_mul_right.coprime_mul_left_right.symm.gcd_eq_one, one_mul]\n      · rw [← hcd.1.1, ← hcd.2.1] at cop\n        rw [← hcd.2.1, h.1, mul_comm c1 d1, Nat.gcd_mul_left,\n          cop.coprime_mul_right.coprime_mul_left_right.symm.gcd_eq_one, mul_one]\n    · trans Nat.gcd (b1 * b2) (a2 * b2)\n      · rw [Nat.gcd_mul_right, cop.coprime_mul_left.coprime_mul_right_right.symm.gcd_eq_one,\n          one_mul]\n      · rw [← hcd.1.1, ← hcd.2.1] at cop\n        rw [← hcd.2.1, h.2, Nat.gcd_mul_right,\n          cop.coprime_mul_left.coprime_mul_right_right.symm.gcd_eq_one, one_mul]\n  · simp only [Set.SurjOn, Set.subset_def, mem_coe, mem_divisorsAntidiagonal, Ne, mem_product,\n      Set.mem_image, exists_prop, Prod.mk.inj_iff]\n    rintro ⟨b1, b2⟩ h\n    dsimp at h\n    use ((b1.gcd m, b2.gcd m), (b1.gcd n, b2.gcd n))\n    rw [← cop.gcd_mul _, ← cop.gcd_mul _, ← h.1, Nat.gcd_mul_gcd_of_coprime_of_mul_eq_mul cop h.1,\n      Nat.gcd_mul_gcd_of_coprime_of_mul_eq_mul cop.symm _]\n    · rw [Nat.mul_eq_zero, not_or] at h\n      simp [h.2.1, h.2.2]\n    rw [mul_comm n m, h.1]\n  · simp only [mem_divisorsAntidiagonal, Ne, mem_product]\n    rintro ⟨⟨a1, a2⟩, ⟨b1, b2⟩⟩ ⟨⟨rfl, ha⟩, ⟨rfl, hb⟩⟩\n    dsimp only\n    rw [hf.map_mul_of_coprime cop.coprime_mul_right.coprime_mul_right_right,\n      hg.map_mul_of_coprime cop.coprime_mul_left.coprime_mul_left_right]\n    ring\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.pmul","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nf g : ArithmeticFunction R\nhf : f.IsMultiplicative\nhg : g.IsMultiplicative\n⊢ (f.pmul g).IsMultiplicative","decl":"@[arith_mult]\ntheorem pmul [CommSemiring R] {f g : ArithmeticFunction R} (hf : f.IsMultiplicative)\n    (hg : g.IsMultiplicative) : IsMultiplicative (f.pmul g) :=\n  ⟨by simp [hf, hg], fun {m n} cop => by\n    simp only [pmul_apply, hf.map_mul_of_coprime cop, hg.map_mul_of_coprime cop]\n    ring⟩\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.pdiv","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommGroupWithZero R\nf g : ArithmeticFunction R\nhf : f.IsMultiplicative\nhg : g.IsMultiplicative\n⊢ (f.pdiv g).IsMultiplicative","decl":"@[arith_mult]\ntheorem pdiv [CommGroupWithZero R] {f g : ArithmeticFunction R} (hf : IsMultiplicative f)\n    (hg : IsMultiplicative g) : IsMultiplicative (pdiv f g) :=\n  ⟨ by simp [hf, hg], fun {m n} cop => by\n    simp only [pdiv_apply, map_mul_of_coprime hf cop, map_mul_of_coprime hg cop,\n      div_eq_mul_inv, mul_inv]\n    apply mul_mul_mul_comm ⟩\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.multiplicative_factorization","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nf : ArithmeticFunction R\nhf : f.IsMultiplicative\nn : Nat\nhn : Ne n 0\n⊢ Eq (f n) (n.factorization.prod fun p k => f (HPow.hPow p k))","decl":"/-- For any multiplicative function `f` and any `n > 0`,\nwe can evaluate `f n` by evaluating `f` at `p ^ k` over the factorization of `n` -/\nnonrec  -- Porting note: added\ntheorem multiplicative_factorization [CommMonoidWithZero R] (f : ArithmeticFunction R)\n    (hf : f.IsMultiplicative) {n : ℕ} (hn : n ≠ 0) :\n    f n = n.factorization.prod fun p k => f (p ^ k) :=\n  multiplicative_factorization f (fun _ _ => hf.2) hf.1 hn\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.iff_ne_zero","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : MonoidWithZero R\nf : ArithmeticFunction R\n⊢ Iff f.IsMultiplicative (And (Eq (f 1) 1) (∀ {m n : Nat}, Ne m 0 → Ne n 0 → m.Coprime n → Eq (f (HMul.hMul m n)) (HMul.hMul (f m) (f n))))","decl":"/-- A recapitulation of the definition of multiplicative that is simpler for proofs -/\ntheorem iff_ne_zero [MonoidWithZero R] {f : ArithmeticFunction R} :\n    IsMultiplicative f ↔\n      f 1 = 1 ∧ ∀ {m n : ℕ}, m ≠ 0 → n ≠ 0 → m.Coprime n → f (m * n) = f m * f n := by\n  refine and_congr_right' (forall₂_congr fun m n => ⟨fun h _ _ => h, fun h hmn => ?_⟩)\n  rcases eq_or_ne m 0 with (rfl | hm)\n  · simp\n  rcases eq_or_ne n 0 with (rfl | hn)\n  · simp\n  exact h hm hn hmn\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.eq_iff_eq_on_prime_powers","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nf : ArithmeticFunction R\nhf : f.IsMultiplicative\ng : ArithmeticFunction R\nhg : g.IsMultiplicative\n⊢ Iff (Eq f g) (∀ (p i : Nat), Nat.Prime p → Eq (f (HPow.hPow p i)) (g (HPow.hPow p i)))","decl":"/-- Two multiplicative functions `f` and `g` are equal if and only if\nthey agree on prime powers -/\ntheorem eq_iff_eq_on_prime_powers [CommMonoidWithZero R] (f : ArithmeticFunction R)\n    (hf : f.IsMultiplicative) (g : ArithmeticFunction R) (hg : g.IsMultiplicative) :\n    f = g ↔ ∀ p i : ℕ, Nat.Prime p → f (p ^ i) = g (p ^ i) := by\n  constructor\n  · intro h p i _\n    rw [h]\n  intro h\n  ext n\n  by_cases hn : n = 0\n  · rw [hn, ArithmeticFunction.map_zero, ArithmeticFunction.map_zero]\n  rw [multiplicative_factorization f hf hn, multiplicative_factorization g hg hn]\n  exact Finset.prod_congr rfl fun p hp ↦ h p _ (Nat.prime_of_mem_primeFactors hp)\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.prodPrimeFactors","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nf : Nat → R\n⊢ (ArithmeticFunction.prodPrimeFactors f).IsMultiplicative","decl":"@[arith_mult]\ntheorem prodPrimeFactors [CommMonoidWithZero R] (f : ℕ → R) :\n    IsMultiplicative (prodPrimeFactors f) := by\n  rw [iff_ne_zero]\n  simp only [ne_eq, one_ne_zero, not_false_eq_true, prodPrimeFactors_apply, primeFactors_one,\n    prod_empty, true_and]\n  intro x y hx hy hxy\n  have hxy₀ : x * y ≠ 0 := mul_ne_zero hx hy\n  rw [prodPrimeFactors_apply hxy₀, prodPrimeFactors_apply hx, prodPrimeFactors_apply hy,\n    Nat.primeFactors_mul hx hy, ← Finset.prod_union hxy.disjoint_primeFactors]\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.prodPrimeFactors_add_of_squarefree","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nf g : ArithmeticFunction R\nhf : f.IsMultiplicative\nhg : g.IsMultiplicative\nn : Nat\nhn : Squarefree n\n⊢ Eq ((ArithmeticFunction.prodPrimeFactors fun p => (HAdd.hAdd f g) p) n) ((HMul.hMul f g) n)","decl":"theorem prodPrimeFactors_add_of_squarefree [CommSemiring R] {f g : ArithmeticFunction R}\n    (hf : IsMultiplicative f) (hg : IsMultiplicative g) {n : ℕ} (hn : Squarefree n) :\n    ∏ᵖ p ∣ n, (f + g) p = (f * g) n := by\n  rw [prodPrimeFactors_apply hn.ne_zero]\n  simp_rw [add_apply (f := f) (g := g)]\n  rw [Finset.prod_add, mul_apply, sum_divisorsAntidiagonal (f · * g ·),\n    ← divisors_filter_squarefree_of_squarefree hn, sum_divisors_filter_squarefree hn.ne_zero,\n    factors_eq]\n  apply Finset.sum_congr rfl\n  intro t ht\n  rw [t.prod_val, Function.id_def,\n    ← prod_primeFactors_sdiff_of_squarefree hn (Finset.mem_powerset.mp ht),\n    hf.map_prod_of_subset_primeFactors n t (Finset.mem_powerset.mp ht),\n    ← hg.map_prod_of_subset_primeFactors n (_ \\ t) Finset.sdiff_subset]\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.lcm_apply_mul_gcd_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nf : ArithmeticFunction R\nhf : f.IsMultiplicative\nx y : Nat\n⊢ Eq (HMul.hMul (f (x.lcm y)) (f (x.gcd y))) (HMul.hMul (f x) (f y))","decl":"theorem lcm_apply_mul_gcd_apply [CommMonoidWithZero R] {f : ArithmeticFunction R}\n    (hf : f.IsMultiplicative) {x y : ℕ} :\n    f (x.lcm y) * f (x.gcd y) = f x * f y := by\n  by_cases hx : x = 0\n  · simp only [hx, f.map_zero, zero_mul, Nat.lcm_zero_left, Nat.gcd_zero_left]\n  by_cases hy : y = 0\n  · simp only [hy, f.map_zero, mul_zero, Nat.lcm_zero_right, Nat.gcd_zero_right, zero_mul]\n  have hgcd_ne_zero : x.gcd y ≠ 0 := gcd_ne_zero_left hx\n  have hlcm_ne_zero : x.lcm y ≠ 0 := lcm_ne_zero hx hy\n  have hfi_zero : ∀ {i}, f (i ^ 0) = 1 := by\n    intro i; rw [Nat.pow_zero, hf.1]\n  iterate 4 rw [hf.multiplicative_factorization f (by assumption),\n    Finsupp.prod_of_support_subset _ _ _ (fun _ _ => hfi_zero)\n      (s := (x.primeFactors ⊔ y.primeFactors))]\n  · rw [← Finset.prod_mul_distrib, ← Finset.prod_mul_distrib]\n    apply Finset.prod_congr rfl\n    intro p _\n    rcases Nat.le_or_le (x.factorization p) (y.factorization p) with h | h <;>\n      simp only [factorization_lcm hx hy, Finsupp.sup_apply, h, sup_of_le_right,\n        sup_of_le_left, inf_of_le_right, Nat.factorization_gcd hx hy, Finsupp.inf_apply,\n        inf_of_le_left, mul_comm]\n  · apply Finset.subset_union_right\n  · apply Finset.subset_union_left\n  · rw [factorization_gcd hx hy, Finsupp.support_inf, Finset.sup_eq_union]\n    apply Finset.inter_subset_union\n  · simp [factorization_lcm hx hy]\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.map_gcd","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommGroupWithZero R\nf : ArithmeticFunction R\nhf : f.IsMultiplicative\nx y : Nat\nhf_lcm : Ne (f (x.lcm y)) 0\n⊢ Eq (f (x.gcd y)) (HDiv.hDiv (HMul.hMul (f x) (f y)) (f (x.lcm y)))","decl":"theorem map_gcd [CommGroupWithZero R] {f : ArithmeticFunction R}\n    (hf : f.IsMultiplicative) {x y : ℕ} (hf_lcm : f (x.lcm y) ≠ 0) :\n    f (x.gcd y) = f x * f y / f (x.lcm y) := by\n  rw [←hf.lcm_apply_mul_gcd_apply, mul_div_cancel_left₀ _ hf_lcm]\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.map_lcm","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommGroupWithZero R\nf : ArithmeticFunction R\nhf : f.IsMultiplicative\nx y : Nat\nhf_gcd : Ne (f (x.gcd y)) 0\n⊢ Eq (f (x.lcm y)) (HDiv.hDiv (HMul.hMul (f x) (f y)) (f (x.gcd y)))","decl":"theorem map_lcm [CommGroupWithZero R] {f : ArithmeticFunction R}\n    (hf : f.IsMultiplicative) {x y : ℕ} (hf_gcd : f (x.gcd y) ≠ 0) :\n    f (x.lcm y) = f x * f y / f (x.gcd y) := by\n  rw [←hf.lcm_apply_mul_gcd_apply, mul_div_cancel_right₀ _ hf_gcd]\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.eq_zero_of_squarefree_of_dvd_eq_zero","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nf : ArithmeticFunction R\nhf : f.IsMultiplicative\nm n : Nat\nhn : Squarefree n\nhmn : Dvd.dvd m n\nh_zero : Eq (f m) 0\n⊢ Eq (f n) 0","decl":"theorem eq_zero_of_squarefree_of_dvd_eq_zero [CommMonoidWithZero R] {f : ArithmeticFunction R}\n    (hf : IsMultiplicative f) {m n : ℕ} (hn : Squarefree n) (hmn : m ∣ n)\n    (h_zero : f m = 0) :\n    f n = 0 := by\n  rcases hmn with ⟨k, rfl⟩\n  simp only [MulZeroClass.zero_mul, eq_self_iff_true, hf.map_mul_of_coprime\n    (coprime_of_squarefree_mul hn), h_zero]\n\n"}
{"name":"ArithmeticFunction.id_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"x : Nat\n⊢ Eq (ArithmeticFunction.id x) x","decl":"@[simp]\ntheorem id_apply {x : ℕ} : id x = x :=\n  rfl\n\n"}
{"name":"ArithmeticFunction.pow_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"k n : Nat\n⊢ Eq ((ArithmeticFunction.pow k) n) (ite (And (Eq k 0) (Eq n 0)) 0 (HPow.hPow n k))","decl":"@[simp]\ntheorem pow_apply {k n : ℕ} : pow k n = if k = 0 ∧ n = 0 then 0 else n ^ k := by\n  cases k\n  · simp [pow]\n  rename_i k  -- Porting note: added\n  simp [pow, k.succ_pos.ne']\n\n"}
{"name":"ArithmeticFunction.pow_zero_eq_zeta","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"⊢ Eq (ArithmeticFunction.pow 0) ArithmeticFunction.zeta","decl":"theorem pow_zero_eq_zeta : pow 0 = ζ := by\n  ext n\n  simp\n\n"}
{"name":"ArithmeticFunction.sigma_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"k n : Nat\n⊢ Eq ((ArithmeticFunction.sigma k) n) (n.divisors.sum fun d => HPow.hPow d k)","decl":"theorem sigma_apply {k n : ℕ} : σ k n = ∑ d ∈ divisors n, d ^ k :=\n  rfl\n\n"}
{"name":"ArithmeticFunction.sigma_apply_prime_pow","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"k p i : Nat\nhp : Nat.Prime p\n⊢ Eq ((ArithmeticFunction.sigma k) (HPow.hPow p i)) ((Finset.range (HAdd.hAdd i 1)).sum fun j => HPow.hPow p (HMul.hMul j k))","decl":"theorem sigma_apply_prime_pow {k p i : ℕ} (hp : p.Prime) :\n    σ k (p ^ i) = ∑ j ∈ .range (i + 1), p ^ (j * k) := by\n  simp [sigma_apply, divisors_prime_pow hp, Nat.pow_mul]\n\n"}
{"name":"ArithmeticFunction.sigma_one_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"n : Nat\n⊢ Eq ((ArithmeticFunction.sigma 1) n) (n.divisors.sum fun d => d)","decl":"theorem sigma_one_apply (n : ℕ) : σ 1 n = ∑ d ∈ divisors n, d := by simp [sigma_apply]\n\n"}
{"name":"ArithmeticFunction.sigma_one_apply_prime_pow","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"p i : Nat\nhp : Nat.Prime p\n⊢ Eq ((ArithmeticFunction.sigma 1) (HPow.hPow p i)) ((Finset.range (HAdd.hAdd i 1)).sum fun k => HPow.hPow p k)","decl":"theorem sigma_one_apply_prime_pow {p i : ℕ} (hp : p.Prime) :\n    σ 1 (p ^ i) = ∑ k ∈ .range (i + 1), p ^ k := by\n  simp [sigma_apply_prime_pow hp]\n\n"}
{"name":"ArithmeticFunction.sigma_zero_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"n : Nat\n⊢ Eq ((ArithmeticFunction.sigma 0) n) n.divisors.card","decl":"theorem sigma_zero_apply (n : ℕ) : σ 0 n = #n.divisors := by simp [sigma_apply]\n\n"}
{"name":"ArithmeticFunction.sigma_zero_apply_prime_pow","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"p i : Nat\nhp : Nat.Prime p\n⊢ Eq ((ArithmeticFunction.sigma 0) (HPow.hPow p i)) (HAdd.hAdd i 1)","decl":"theorem sigma_zero_apply_prime_pow {p i : ℕ} (hp : p.Prime) : σ 0 (p ^ i) = i + 1 := by\n  simp [sigma_apply_prime_pow hp]\n\n"}
{"name":"ArithmeticFunction.zeta_mul_pow_eq_sigma","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"k : Nat\n⊢ Eq (HMul.hMul ArithmeticFunction.zeta (ArithmeticFunction.pow k)) (ArithmeticFunction.sigma k)","decl":"theorem zeta_mul_pow_eq_sigma {k : ℕ} : ζ * pow k = σ k := by\n  ext\n  rw [sigma, zeta_mul_apply]\n  apply sum_congr rfl\n  intro x hx\n  rw [pow_apply, if_neg (not_and_of_not_right _ _)]\n  contrapose! hx\n  simp [hx]\n\n"}
{"name":"ArithmeticFunction.isMultiplicative_one","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : MonoidWithZero R\n⊢ ArithmeticFunction.IsMultiplicative 1","decl":"@[arith_mult]\ntheorem isMultiplicative_one [MonoidWithZero R] : IsMultiplicative (1 : ArithmeticFunction R) :=\n  IsMultiplicative.iff_ne_zero.2\n    ⟨by simp, by\n      intro m n hm _hn hmn\n      rcases eq_or_ne m 1 with (rfl | hm')\n      · simp\n      rw [one_apply_ne, one_apply_ne hm', zero_mul]\n      rw [Ne, mul_eq_one, not_and_or]\n      exact Or.inl hm'⟩\n\n"}
{"name":"ArithmeticFunction.isMultiplicative_zeta","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"⊢ ArithmeticFunction.zeta.IsMultiplicative","decl":"@[arith_mult]\ntheorem isMultiplicative_zeta : IsMultiplicative ζ :=\n  IsMultiplicative.iff_ne_zero.2 ⟨by simp, by simp +contextual⟩\n\n"}
{"name":"ArithmeticFunction.isMultiplicative_id","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"⊢ ArithmeticFunction.id.IsMultiplicative","decl":"@[arith_mult]\ntheorem isMultiplicative_id : IsMultiplicative ArithmeticFunction.id :=\n  ⟨rfl, fun {_ _} _ => rfl⟩\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.ppow","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nf : ArithmeticFunction R\nhf : f.IsMultiplicative\nk : Nat\n⊢ (f.ppow k).IsMultiplicative","decl":"@[arith_mult]\ntheorem IsMultiplicative.ppow [CommSemiring R] {f : ArithmeticFunction R} (hf : f.IsMultiplicative)\n    {k : ℕ} : IsMultiplicative (f.ppow k) := by\n  induction' k with k hi\n  · exact isMultiplicative_zeta.natCast\n  · rw [ppow_succ']\n    apply hf.pmul hi\n\n"}
{"name":"ArithmeticFunction.isMultiplicative_pow","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"k : Nat\n⊢ (ArithmeticFunction.pow k).IsMultiplicative","decl":"@[arith_mult]\ntheorem isMultiplicative_pow {k : ℕ} : IsMultiplicative (pow k) :=\n  isMultiplicative_id.ppow\n\n"}
{"name":"ArithmeticFunction.isMultiplicative_sigma","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"k : Nat\n⊢ (ArithmeticFunction.sigma k).IsMultiplicative","decl":"@[arith_mult]\ntheorem isMultiplicative_sigma {k : ℕ} : IsMultiplicative (σ k) := by\n  rw [← zeta_mul_pow_eq_sigma]\n  apply isMultiplicative_zeta.mul isMultiplicative_pow\n\n"}
{"name":"ArithmeticFunction.cardFactors_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"n : Nat\n⊢ Eq (ArithmeticFunction.cardFactors n) n.primeFactorsList.length","decl":"theorem cardFactors_apply {n : ℕ} : Ω n = n.primeFactorsList.length :=\n  rfl\n\n"}
{"name":"ArithmeticFunction.cardFactors_zero","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"⊢ Eq (ArithmeticFunction.cardFactors 0) 0","decl":"lemma cardFactors_zero : Ω 0 = 0 := by simp\n\n"}
{"name":"ArithmeticFunction.cardFactors_one","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"⊢ Eq (ArithmeticFunction.cardFactors 1) 0","decl":"@[simp] theorem cardFactors_one : Ω 1 = 0 := by simp [cardFactors_apply]\n\n"}
{"name":"ArithmeticFunction.cardFactors_eq_one_iff_prime","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"n : Nat\n⊢ Iff (Eq (ArithmeticFunction.cardFactors n) 1) (Nat.Prime n)","decl":"@[simp]\ntheorem cardFactors_eq_one_iff_prime {n : ℕ} : Ω n = 1 ↔ n.Prime := by\n  refine ⟨fun h => ?_, fun h => List.length_eq_one.2 ⟨n, primeFactorsList_prime h⟩⟩\n  cases' n with n\n  · simp at h\n  rcases List.length_eq_one.1 h with ⟨x, hx⟩\n  rw [← prod_primeFactorsList n.add_one_ne_zero, hx, List.prod_singleton]\n  apply prime_of_mem_primeFactorsList\n  rw [hx, List.mem_singleton]\n\n"}
{"name":"ArithmeticFunction.cardFactors_mul","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"m n : Nat\nm0 : Ne m 0\nn0 : Ne n 0\n⊢ Eq (ArithmeticFunction.cardFactors (HMul.hMul m n)) (HAdd.hAdd (ArithmeticFunction.cardFactors m) (ArithmeticFunction.cardFactors n))","decl":"theorem cardFactors_mul {m n : ℕ} (m0 : m ≠ 0) (n0 : n ≠ 0) : Ω (m * n) = Ω m + Ω n := by\n  rw [cardFactors_apply, cardFactors_apply, cardFactors_apply, ← Multiset.coe_card, ← factors_eq,\n    UniqueFactorizationMonoid.normalizedFactors_mul m0 n0, factors_eq, factors_eq,\n    Multiset.card_add, Multiset.coe_card, Multiset.coe_card]\n\n"}
{"name":"ArithmeticFunction.cardFactors_multiset_prod","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"s : Multiset Nat\nh0 : Ne s.prod 0\n⊢ Eq (ArithmeticFunction.cardFactors s.prod) (Multiset.map (⇑ArithmeticFunction.cardFactors) s).sum","decl":"theorem cardFactors_multiset_prod {s : Multiset ℕ} (h0 : s.prod ≠ 0) :\n    Ω s.prod = (Multiset.map Ω s).sum := by\n  induction s using Multiset.induction_on with\n  | empty => simp\n  | cons ih => simp_all [cardFactors_mul, not_or]\n\n"}
{"name":"ArithmeticFunction.cardFactors_apply_prime","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"p : Nat\nhp : Nat.Prime p\n⊢ Eq (ArithmeticFunction.cardFactors p) 1","decl":"@[simp]\ntheorem cardFactors_apply_prime {p : ℕ} (hp : p.Prime) : Ω p = 1 :=\n  cardFactors_eq_one_iff_prime.2 hp\n\n"}
{"name":"ArithmeticFunction.cardFactors_apply_prime_pow","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"p k : Nat\nhp : Nat.Prime p\n⊢ Eq (ArithmeticFunction.cardFactors (HPow.hPow p k)) k","decl":"@[simp]\ntheorem cardFactors_apply_prime_pow {p k : ℕ} (hp : p.Prime) : Ω (p ^ k) = k := by\n  rw [cardFactors_apply, hp.primeFactorsList_pow, List.length_replicate]\n\n"}
{"name":"ArithmeticFunction.cardDistinctFactors_zero","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"⊢ Eq (ArithmeticFunction.cardDistinctFactors 0) 0","decl":"theorem cardDistinctFactors_zero : ω 0 = 0 := by simp\n\n"}
{"name":"ArithmeticFunction.cardDistinctFactors_one","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"⊢ Eq (ArithmeticFunction.cardDistinctFactors 1) 0","decl":"@[simp]\ntheorem cardDistinctFactors_one : ω 1 = 0 := by simp [cardDistinctFactors]\n\n"}
{"name":"ArithmeticFunction.cardDistinctFactors_apply","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"n : Nat\n⊢ Eq (ArithmeticFunction.cardDistinctFactors n) n.primeFactorsList.dedup.length","decl":"theorem cardDistinctFactors_apply {n : ℕ} : ω n = n.primeFactorsList.dedup.length :=\n  rfl\n\n"}
{"name":"ArithmeticFunction.cardDistinctFactors_eq_cardFactors_iff_squarefree","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"n : Nat\nh0 : Ne n 0\n⊢ Iff (Eq (ArithmeticFunction.cardDistinctFactors n) (ArithmeticFunction.cardFactors n)) (Squarefree n)","decl":"theorem cardDistinctFactors_eq_cardFactors_iff_squarefree {n : ℕ} (h0 : n ≠ 0) :\n    ω n = Ω n ↔ Squarefree n := by\n  rw [squarefree_iff_nodup_primeFactorsList h0, cardDistinctFactors_apply]\n  constructor <;> intro h\n  · rw [← n.primeFactorsList.dedup_sublist.eq_of_length h]\n    apply List.nodup_dedup\n  · rw [h.dedup]\n    rfl\n\n"}
{"name":"ArithmeticFunction.cardDistinctFactors_apply_prime_pow","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"p k : Nat\nhp : Nat.Prime p\nhk : Ne k 0\n⊢ Eq (ArithmeticFunction.cardDistinctFactors (HPow.hPow p k)) 1","decl":"@[simp]\ntheorem cardDistinctFactors_apply_prime_pow {p k : ℕ} (hp : p.Prime) (hk : k ≠ 0) :\n    ω (p ^ k) = 1 := by\n  rw [cardDistinctFactors_apply, hp.primeFactorsList_pow, List.replicate_dedup hk,\n    List.length_singleton]\n\n"}
{"name":"ArithmeticFunction.cardDistinctFactors_apply_prime","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"p : Nat\nhp : Nat.Prime p\n⊢ Eq (ArithmeticFunction.cardDistinctFactors p) 1","decl":"@[simp]\ntheorem cardDistinctFactors_apply_prime {p : ℕ} (hp : p.Prime) : ω p = 1 := by\n  rw [← pow_one p, cardDistinctFactors_apply_prime_pow hp one_ne_zero]\n\n"}
{"name":"ArithmeticFunction.moebius_apply_of_squarefree","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"n : Nat\nh : Squarefree n\n⊢ Eq (ArithmeticFunction.moebius n) (HPow.hPow (-1) (ArithmeticFunction.cardFactors n))","decl":"@[simp]\ntheorem moebius_apply_of_squarefree {n : ℕ} (h : Squarefree n) : μ n = (-1) ^ cardFactors n :=\n  if_pos h\n\n"}
{"name":"ArithmeticFunction.moebius_eq_zero_of_not_squarefree","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"n : Nat\nh : Not (Squarefree n)\n⊢ Eq (ArithmeticFunction.moebius n) 0","decl":"@[simp]\ntheorem moebius_eq_zero_of_not_squarefree {n : ℕ} (h : ¬Squarefree n) : μ n = 0 :=\n  if_neg h\n\n"}
{"name":"ArithmeticFunction.moebius_apply_one","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"⊢ Eq (ArithmeticFunction.moebius 1) 1","decl":"theorem moebius_apply_one : μ 1 = 1 := by simp\n\n"}
{"name":"ArithmeticFunction.moebius_ne_zero_iff_squarefree","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"n : Nat\n⊢ Iff (Ne (ArithmeticFunction.moebius n) 0) (Squarefree n)","decl":"theorem moebius_ne_zero_iff_squarefree {n : ℕ} : μ n ≠ 0 ↔ Squarefree n := by\n  constructor <;> intro h\n  · contrapose! h\n    simp [h]\n  · simp [h, pow_ne_zero]\n\n"}
{"name":"ArithmeticFunction.moebius_eq_or","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"n : Nat\n⊢ Or (Eq (ArithmeticFunction.moebius n) 0) (Or (Eq (ArithmeticFunction.moebius n) 1) (Eq (ArithmeticFunction.moebius n) (-1)))","decl":"theorem moebius_eq_or (n : ℕ) : μ n = 0 ∨ μ n = 1 ∨ μ n = -1 := by\n  simp only [moebius, coe_mk]\n  split_ifs\n  · right\n    exact neg_one_pow_eq_or ..\n  · left\n    rfl\n\n"}
{"name":"ArithmeticFunction.moebius_ne_zero_iff_eq_or","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"n : Nat\n⊢ Iff (Ne (ArithmeticFunction.moebius n) 0) (Or (Eq (ArithmeticFunction.moebius n) 1) (Eq (ArithmeticFunction.moebius n) (-1)))","decl":"theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by\n  have := moebius_eq_or n\n  aesop\n\n"}
{"name":"ArithmeticFunction.moebius_sq_eq_one_of_squarefree","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"l : Nat\nhl : Squarefree l\n⊢ Eq (HPow.hPow (ArithmeticFunction.moebius l) 2) 1","decl":"theorem moebius_sq_eq_one_of_squarefree {l : ℕ} (hl : Squarefree l) : μ l ^ 2 = 1 := by\n  rw [moebius_apply_of_squarefree hl, ← pow_mul, mul_comm, pow_mul, neg_one_sq, one_pow]\n\n"}
{"name":"ArithmeticFunction.abs_moebius_eq_one_of_squarefree","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"l : Nat\nhl : Squarefree l\n⊢ Eq (abs (ArithmeticFunction.moebius l)) 1","decl":"theorem abs_moebius_eq_one_of_squarefree {l : ℕ} (hl : Squarefree l) : |μ l| = 1 := by\n  simp only [moebius_apply_of_squarefree hl, abs_pow, abs_neg, abs_one, one_pow]\n\n"}
{"name":"ArithmeticFunction.moebius_sq","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"n : Nat\n⊢ Eq (HPow.hPow (ArithmeticFunction.moebius n) 2) (ite (Squarefree n) 1 0)","decl":"theorem moebius_sq {n : ℕ} :\n    μ n ^ 2 = if Squarefree n then 1 else 0 := by\n  split_ifs with h\n  · exact moebius_sq_eq_one_of_squarefree h\n  · simp only [pow_eq_zero_iff, moebius_eq_zero_of_not_squarefree h,\n    zero_pow (show 2 ≠ 0 by norm_num)]\n\n"}
{"name":"ArithmeticFunction.abs_moebius","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"n : Nat\n⊢ Eq (abs (ArithmeticFunction.moebius n)) (ite (Squarefree n) 1 0)","decl":"theorem abs_moebius {n : ℕ} :\n    |μ n| = if Squarefree n then 1 else 0 := by\n  split_ifs with h\n  · exact abs_moebius_eq_one_of_squarefree h\n  · simp only [moebius_eq_zero_of_not_squarefree h, abs_zero]\n\n"}
{"name":"ArithmeticFunction.abs_moebius_le_one","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"n : Nat\n⊢ LE.le (abs (ArithmeticFunction.moebius n)) 1","decl":"theorem abs_moebius_le_one {n : ℕ} : |μ n| ≤ 1 := by\n  rw [abs_moebius, apply_ite (· ≤ 1)]\n  simp\n\n"}
{"name":"ArithmeticFunction.moebius_apply_prime","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"p : Nat\nhp : Nat.Prime p\n⊢ Eq (ArithmeticFunction.moebius p) (-1)","decl":"theorem moebius_apply_prime {p : ℕ} (hp : p.Prime) : μ p = -1 := by\n  rw [moebius_apply_of_squarefree hp.squarefree, cardFactors_apply_prime hp, pow_one]\n\n"}
{"name":"ArithmeticFunction.moebius_apply_prime_pow","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"p k : Nat\nhp : Nat.Prime p\nhk : Ne k 0\n⊢ Eq (ArithmeticFunction.moebius (HPow.hPow p k)) (ite (Eq k 1) (-1) 0)","decl":"theorem moebius_apply_prime_pow {p k : ℕ} (hp : p.Prime) (hk : k ≠ 0) :\n    μ (p ^ k) = if k = 1 then -1 else 0 := by\n  split_ifs with h\n  · rw [h, pow_one, moebius_apply_prime hp]\n  rw [moebius_eq_zero_of_not_squarefree]\n  rw [squarefree_pow_iff hp.ne_one hk, not_and_or]\n  exact Or.inr h\n\n"}
{"name":"ArithmeticFunction.moebius_apply_isPrimePow_not_prime","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"n : Nat\nhn : IsPrimePow n\nhn' : Not (Nat.Prime n)\n⊢ Eq (ArithmeticFunction.moebius n) 0","decl":"theorem moebius_apply_isPrimePow_not_prime {n : ℕ} (hn : IsPrimePow n) (hn' : ¬n.Prime) :\n    μ n = 0 := by\n  obtain ⟨p, k, hp, hk, rfl⟩ := (isPrimePow_nat_iff _).1 hn\n  rw [moebius_apply_prime_pow hp hk.ne', if_neg]\n  rintro rfl\n  exact hn' (by simpa)\n\n"}
{"name":"ArithmeticFunction.isMultiplicative_moebius","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"⊢ ArithmeticFunction.moebius.IsMultiplicative","decl":"@[arith_mult]\ntheorem isMultiplicative_moebius : IsMultiplicative μ := by\n  rw [IsMultiplicative.iff_ne_zero]\n  refine ⟨by simp, fun {n m} hn hm hnm => ?_⟩\n  simp only [moebius, ZeroHom.coe_mk, coe_mk, ZeroHom.toFun_eq_coe, Eq.ndrec, ZeroHom.coe_mk,\n    IsUnit.mul_iff, Nat.isUnit_iff, squarefree_mul hnm, ite_zero_mul_ite_zero,\n    cardFactors_mul hn hm, pow_add]\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.prodPrimeFactors_one_add_of_squarefree","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nf : ArithmeticFunction R\nh_mult : f.IsMultiplicative\nn : Nat\nhn : Squarefree n\n⊢ Eq (n.primeFactors.prod fun p => HAdd.hAdd 1 (f p)) (n.divisors.sum fun d => f d)","decl":"theorem IsMultiplicative.prodPrimeFactors_one_add_of_squarefree [CommSemiring R]\n    {f : ArithmeticFunction R} (h_mult : f.IsMultiplicative) {n : ℕ} (hn : Squarefree n) :\n    ∏ p ∈ n.primeFactors, (1 + f p) = ∑ d ∈ n.divisors, f d := by\n  trans (∏ᵖ p ∣ n, ((ζ : ArithmeticFunction R) + f) p)\n  · simp_rw [prodPrimeFactors_apply hn.ne_zero, add_apply, natCoe_apply]\n    apply Finset.prod_congr rfl; intro p hp\n    rw [zeta_apply_ne (prime_of_mem_primeFactorsList <| List.mem_toFinset.mp hp).ne_zero, cast_one]\n  rw [isMultiplicative_zeta.natCast.prodPrimeFactors_add_of_squarefree h_mult hn,\n    coe_zeta_mul_apply]\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.prodPrimeFactors_one_sub_of_squarefree","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : ArithmeticFunction R\nhf : f.IsMultiplicative\nn : Nat\nhn : Squarefree n\n⊢ Eq (n.primeFactors.prod fun p => HSub.hSub 1 (f p)) (n.divisors.sum fun d => HMul.hMul (↑(ArithmeticFunction.moebius d)) (f d))","decl":"theorem IsMultiplicative.prodPrimeFactors_one_sub_of_squarefree [CommRing R]\n    (f : ArithmeticFunction R) (hf : f.IsMultiplicative) {n : ℕ} (hn : Squarefree n) :\n    ∏ p ∈ n.primeFactors, (1 - f p) = ∑ d ∈ n.divisors, μ d * f d := by\n  trans (∏ p ∈ n.primeFactors, (1 + (ArithmeticFunction.pmul (μ : ArithmeticFunction R) f) p))\n  · apply Finset.prod_congr rfl; intro p hp\n    rw [pmul_apply, intCoe_apply, ArithmeticFunction.moebius_apply_prime\n        (prime_of_mem_primeFactorsList (List.mem_toFinset.mp hp))]\n    ring\n  · rw [(isMultiplicative_moebius.intCast.pmul hf).prodPrimeFactors_one_add_of_squarefree hn]\n    simp_rw [pmul_apply, intCoe_apply]\n\n"}
{"name":"ArithmeticFunction.moebius_mul_coe_zeta","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"⊢ Eq (HMul.hMul ArithmeticFunction.moebius ↑ArithmeticFunction.zeta) 1","decl":"@[simp]\ntheorem moebius_mul_coe_zeta : (μ * ζ : ArithmeticFunction ℤ) = 1 := by\n  ext n\n  refine recOnPosPrimePosCoprime ?_ ?_ ?_ ?_ n\n  · intro p n hp hn\n    rw [coe_mul_zeta_apply, sum_divisors_prime_pow hp, sum_range_succ']\n    simp_rw [Nat.pow_zero, moebius_apply_one,\n      moebius_apply_prime_pow hp (Nat.succ_ne_zero _), Nat.succ_inj', sum_ite_eq', mem_range,\n      if_pos hn, neg_add_cancel]\n    rw [one_apply_ne]\n    rw [Ne, pow_eq_one_iff]\n    · exact hp.ne_one\n    · exact hn.ne'\n  · rw [ZeroHom.map_zero, ZeroHom.map_zero]\n  · simp\n  · intro a b _ha _hb hab ha' hb'\n    rw [IsMultiplicative.map_mul_of_coprime _ hab, ha', hb',\n      IsMultiplicative.map_mul_of_coprime isMultiplicative_one hab]\n    exact isMultiplicative_moebius.mul isMultiplicative_zeta.natCast\n\n"}
{"name":"ArithmeticFunction.coe_zeta_mul_moebius","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"⊢ Eq (HMul.hMul (↑ArithmeticFunction.zeta) ArithmeticFunction.moebius) 1","decl":"@[simp]\ntheorem coe_zeta_mul_moebius : (ζ * μ : ArithmeticFunction ℤ) = 1 := by\n  rw [mul_comm, moebius_mul_coe_zeta]\n\n"}
{"name":"ArithmeticFunction.coe_moebius_mul_coe_zeta","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : Ring R\n⊢ Eq (HMul.hMul ↑ArithmeticFunction.moebius ↑ArithmeticFunction.zeta) 1","decl":"@[simp]\ntheorem coe_moebius_mul_coe_zeta [Ring R] : (μ * ζ : ArithmeticFunction R) = 1 := by\n  rw [← coe_coe, ← intCoe_mul, moebius_mul_coe_zeta, intCoe_one]\n\n"}
{"name":"ArithmeticFunction.coe_zeta_mul_coe_moebius","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : Ring R\n⊢ Eq (HMul.hMul ↑ArithmeticFunction.zeta ↑ArithmeticFunction.moebius) 1","decl":"@[simp]\ntheorem coe_zeta_mul_coe_moebius [Ring R] : (ζ * μ : ArithmeticFunction R) = 1 := by\n  rw [← coe_coe, ← intCoe_mul, coe_zeta_mul_moebius, intCoe_one]\n\n"}
{"name":"ArithmeticFunction.coe_zetaUnit","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq ↑ArithmeticFunction.zetaUnit ↑ArithmeticFunction.zeta","decl":"@[simp]\ntheorem coe_zetaUnit : ((zetaUnit : (ArithmeticFunction R)ˣ) : ArithmeticFunction R) = ζ :=\n  rfl\n\n"}
{"name":"ArithmeticFunction.inv_zetaUnit","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq ↑(Inv.inv ArithmeticFunction.zetaUnit) ↑ArithmeticFunction.moebius","decl":"@[simp]\ntheorem inv_zetaUnit : ((zetaUnit⁻¹ : (ArithmeticFunction R)ˣ) : ArithmeticFunction R) = μ :=\n  rfl\n\n"}
{"name":"ArithmeticFunction.sum_eq_iff_sum_smul_moebius_eq","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : AddCommGroup R\nf g : Nat → R\n⊢ Iff (∀ (n : Nat), GT.gt n 0 → Eq (n.divisors.sum fun i => f i) (g n)) (∀ (n : Nat), GT.gt n 0 → Eq (n.divisorsAntidiagonal.sum fun x => HSMul.hSMul (ArithmeticFunction.moebius x.1) (g x.2)) (f n))","decl":"/-- Möbius inversion for functions to an `AddCommGroup`. -/\ntheorem sum_eq_iff_sum_smul_moebius_eq [AddCommGroup R] {f g : ℕ → R} :\n    (∀ n > 0, ∑ i ∈ n.divisors, f i = g n) ↔\n      ∀ n > 0, ∑ x ∈ n.divisorsAntidiagonal, μ x.fst • g x.snd = f n := by\n  let f' : ArithmeticFunction R := ⟨fun x => if x = 0 then 0 else f x, if_pos rfl⟩\n  let g' : ArithmeticFunction R := ⟨fun x => if x = 0 then 0 else g x, if_pos rfl⟩\n  trans (ζ : ArithmeticFunction ℤ) • f' = g'\n  · rw [ArithmeticFunction.ext_iff]\n    apply forall_congr'\n    intro n\n    cases n with\n    | zero => simp\n    | succ n =>\n      rw [coe_zeta_smul_apply]\n      simp only [n.succ_ne_zero, forall_prop_of_true, succ_pos', if_false, ZeroHom.coe_mk]\n      simp only [f', g', coe_mk, succ_ne_zero, ite_false]\n      rw [sum_congr rfl fun x hx => ?_]\n      rw [if_neg (Nat.pos_of_mem_divisors hx).ne']\n  trans μ • g' = f'\n  · constructor <;> intro h\n    · rw [← h, ← mul_smul, moebius_mul_coe_zeta, one_smul]\n    · rw [← h, ← mul_smul, coe_zeta_mul_moebius, one_smul]\n  · rw [ArithmeticFunction.ext_iff]\n    apply forall_congr'\n    intro n\n    cases n with\n    | zero => simp\n    | succ n =>\n      simp only [n.succ_ne_zero, forall_prop_of_true, succ_pos', smul_apply, if_false,\n        ZeroHom.coe_mk]\n      -- Porting note: added following `simp only`\n      simp only [f', g', Nat.isUnit_iff, coe_mk, ZeroHom.toFun_eq_coe, succ_ne_zero, ite_false]\n      rw [sum_congr rfl fun x hx => ?_]\n      rw [if_neg (Nat.pos_of_mem_divisors (snd_mem_divisors_of_mem_antidiagonal hx)).ne']\n\n"}
{"name":"ArithmeticFunction.sum_eq_iff_sum_mul_moebius_eq","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : Ring R\nf g : Nat → R\n⊢ Iff (∀ (n : Nat), GT.gt n 0 → Eq (n.divisors.sum fun i => f i) (g n)) (∀ (n : Nat), GT.gt n 0 → Eq (n.divisorsAntidiagonal.sum fun x => HMul.hMul (↑(ArithmeticFunction.moebius x.1)) (g x.2)) (f n))","decl":"/-- Möbius inversion for functions to a `Ring`. -/\ntheorem sum_eq_iff_sum_mul_moebius_eq [Ring R] {f g : ℕ → R} :\n    (∀ n > 0, ∑ i ∈ n.divisors, f i = g n) ↔\n      ∀ n > 0, ∑ x ∈ n.divisorsAntidiagonal, (μ x.fst : R) * g x.snd = f n := by\n  rw [sum_eq_iff_sum_smul_moebius_eq]\n  apply forall_congr'\n  refine fun a => imp_congr_right fun _ => (sum_congr rfl fun x _hx => ?_).congr_left\n  rw [zsmul_eq_mul]\n\n"}
{"name":"ArithmeticFunction.prod_eq_iff_prod_pow_moebius_eq","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommGroup R\nf g : Nat → R\n⊢ Iff (∀ (n : Nat), GT.gt n 0 → Eq (n.divisors.prod fun i => f i) (g n)) (∀ (n : Nat), GT.gt n 0 → Eq (n.divisorsAntidiagonal.prod fun x => HPow.hPow (g x.2) (ArithmeticFunction.moebius x.1)) (f n))","decl":"/-- Möbius inversion for functions to a `CommGroup`. -/\ntheorem prod_eq_iff_prod_pow_moebius_eq [CommGroup R] {f g : ℕ → R} :\n    (∀ n > 0, ∏ i ∈ n.divisors, f i = g n) ↔\n      ∀ n > 0, ∏ x ∈ n.divisorsAntidiagonal, g x.snd ^ μ x.fst = f n :=\n  @sum_eq_iff_sum_smul_moebius_eq (Additive R) _ _ _\n\n"}
{"name":"ArithmeticFunction.prod_eq_iff_prod_pow_moebius_eq_of_nonzero","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommGroupWithZero R\nf g : Nat → R\nhf : ∀ (n : Nat), LT.lt 0 n → Ne (f n) 0\nhg : ∀ (n : Nat), LT.lt 0 n → Ne (g n) 0\n⊢ Iff (∀ (n : Nat), GT.gt n 0 → Eq (n.divisors.prod fun i => f i) (g n)) (∀ (n : Nat), GT.gt n 0 → Eq (n.divisorsAntidiagonal.prod fun x => HPow.hPow (g x.2) (ArithmeticFunction.moebius x.1)) (f n))","decl":"/-- Möbius inversion for functions to a `CommGroupWithZero`. -/\ntheorem prod_eq_iff_prod_pow_moebius_eq_of_nonzero [CommGroupWithZero R] {f g : ℕ → R}\n    (hf : ∀ n : ℕ, 0 < n → f n ≠ 0) (hg : ∀ n : ℕ, 0 < n → g n ≠ 0) :\n    (∀ n > 0, ∏ i ∈ n.divisors, f i = g n) ↔\n      ∀ n > 0, ∏ x ∈ n.divisorsAntidiagonal, g x.snd ^ μ x.fst = f n := by\n  refine\n      Iff.trans\n        (Iff.trans (forall_congr' fun n => ?_)\n          (@prod_eq_iff_prod_pow_moebius_eq Rˣ _\n            (fun n => if h : 0 < n then Units.mk0 (f n) (hf n h) else 1) fun n =>\n            if h : 0 < n then Units.mk0 (g n) (hg n h) else 1))\n        (forall_congr' fun n => ?_) <;>\n    refine imp_congr_right fun hn => ?_\n  · dsimp\n    rw [dif_pos hn, ← Units.eq_iff, ← Units.coeHom_apply, map_prod, Units.val_mk0,\n      prod_congr rfl _]\n    intro x hx\n    rw [dif_pos (Nat.pos_of_mem_divisors hx), Units.coeHom_apply, Units.val_mk0]\n  · dsimp\n    rw [dif_pos hn, ← Units.eq_iff, ← Units.coeHom_apply, map_prod, Units.val_mk0,\n      prod_congr rfl _]\n    intro x hx\n    rw [dif_pos (Nat.pos_of_mem_divisors (Nat.snd_mem_divisors_of_mem_antidiagonal hx)),\n      Units.coeHom_apply, Units.val_zpow_eq_zpow_val, Units.val_mk0]\n\n"}
{"name":"ArithmeticFunction.sum_eq_iff_sum_smul_moebius_eq_on","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : AddCommGroup R\nf g : Nat → R\ns : Set Nat\nhs : ∀ (m n : Nat), Dvd.dvd m n → Membership.mem s n → Membership.mem s m\n⊢ Iff (∀ (n : Nat), GT.gt n 0 → Membership.mem s n → Eq (n.divisors.sum fun i => f i) (g n)) (∀ (n : Nat), GT.gt n 0 → Membership.mem s n → Eq (n.divisorsAntidiagonal.sum fun x => HSMul.hSMul (ArithmeticFunction.moebius x.1) (g x.2)) (f n))","decl":"/-- Möbius inversion for functions to an `AddCommGroup`, where the equalities only hold on a\nwell-behaved set. -/\ntheorem sum_eq_iff_sum_smul_moebius_eq_on [AddCommGroup R] {f g : ℕ → R}\n    (s : Set ℕ) (hs : ∀ m n, m ∣ n → n ∈ s → m ∈ s) :\n    (∀ n > 0, n ∈ s → (∑ i ∈ n.divisors, f i) = g n) ↔\n      ∀ n > 0, n ∈ s → (∑ x ∈ n.divisorsAntidiagonal, μ x.fst • g x.snd) = f n := by\n  constructor\n  · intro h\n    let G := fun (n : ℕ) => (∑ i ∈ n.divisors, f i)\n    intro n hn hnP\n    suffices ∑ d ∈ n.divisors, μ (n/d) • G d = f n from by\n      rw [Nat.sum_divisorsAntidiagonal' (f := fun x y => μ x • g y), ← this, sum_congr rfl]\n      intro d hd\n      rw [← h d (Nat.pos_of_mem_divisors hd) <| hs d n (Nat.dvd_of_mem_divisors hd) hnP]\n    rw [← Nat.sum_divisorsAntidiagonal' (f := fun x y => μ x • G y)]\n    apply sum_eq_iff_sum_smul_moebius_eq.mp _ n hn\n    intro _ _; rfl\n  · intro h\n    let F := fun (n : ℕ) => ∑ x ∈ n.divisorsAntidiagonal, μ x.fst • g x.snd\n    intro n hn hnP\n    suffices ∑ d ∈ n.divisors, F d = g n from by\n      rw [← this, sum_congr rfl]\n      intro d hd\n      rw [← h d (Nat.pos_of_mem_divisors hd) <| hs d n (Nat.dvd_of_mem_divisors hd) hnP]\n    apply sum_eq_iff_sum_smul_moebius_eq.mpr _ n hn\n    intro _ _; rfl\n\n"}
{"name":"ArithmeticFunction.sum_eq_iff_sum_smul_moebius_eq_on'","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : AddCommGroup R\nf g : Nat → R\ns : Set Nat\nhs : ∀ (m n : Nat), Dvd.dvd m n → Membership.mem s n → Membership.mem s m\nhs₀ : Not (Membership.mem s 0)\n⊢ Iff (∀ (n : Nat), Membership.mem s n → Eq (n.divisors.sum fun i => f i) (g n)) (∀ (n : Nat), Membership.mem s n → Eq (n.divisorsAntidiagonal.sum fun x => HSMul.hSMul (ArithmeticFunction.moebius x.1) (g x.2)) (f n))","decl":"theorem sum_eq_iff_sum_smul_moebius_eq_on' [AddCommGroup R] {f g : ℕ → R}\n    (s : Set ℕ) (hs : ∀ m n, m ∣ n → n ∈ s → m ∈ s) (hs₀ : 0 ∉ s) :\n    (∀ n ∈ s, (∑ i ∈ n.divisors, f i) = g n) ↔\n     ∀ n ∈ s, (∑ x ∈ n.divisorsAntidiagonal, μ x.fst • g x.snd) = f n := by\n  have : ∀ P : ℕ → Prop, ((∀ n ∈ s, P n) ↔ (∀ n > 0, n ∈ s → P n)) := fun P ↦ by\n    refine forall_congr' (fun n ↦ ⟨fun h _ ↦ h, fun h hn ↦ h ?_ hn⟩)\n    contrapose! hs₀\n    simpa [nonpos_iff_eq_zero.mp hs₀] using hn\n  simpa only [this] using sum_eq_iff_sum_smul_moebius_eq_on s hs\n\n"}
{"name":"ArithmeticFunction.sum_eq_iff_sum_mul_moebius_eq_on","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : Ring R\nf g : Nat → R\ns : Set Nat\nhs : ∀ (m n : Nat), Dvd.dvd m n → Membership.mem s n → Membership.mem s m\n⊢ Iff (∀ (n : Nat), GT.gt n 0 → Membership.mem s n → Eq (n.divisors.sum fun i => f i) (g n)) (∀ (n : Nat), GT.gt n 0 → Membership.mem s n → Eq (n.divisorsAntidiagonal.sum fun x => HMul.hMul (↑(ArithmeticFunction.moebius x.1)) (g x.2)) (f n))","decl":"/-- Möbius inversion for functions to a `Ring`, where the equalities only hold on a well-behaved\nset. -/\ntheorem sum_eq_iff_sum_mul_moebius_eq_on [Ring R] {f g : ℕ → R}\n    (s : Set ℕ) (hs : ∀ m n, m ∣ n → n ∈ s → m ∈ s) :\n    (∀ n > 0, n ∈ s → (∑ i ∈ n.divisors, f i) = g n) ↔\n      ∀ n > 0, n ∈ s →\n        (∑ x ∈ n.divisorsAntidiagonal, (μ x.fst : R) * g x.snd) = f n := by\n  rw [sum_eq_iff_sum_smul_moebius_eq_on s hs]\n  apply forall_congr'\n  intro a; refine imp_congr_right ?_\n  refine fun _ => imp_congr_right fun _ => (sum_congr rfl fun x _hx => ?_).congr_left\n  rw [zsmul_eq_mul]\n\n"}
{"name":"ArithmeticFunction.prod_eq_iff_prod_pow_moebius_eq_on","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommGroup R\nf g : Nat → R\ns : Set Nat\nhs : ∀ (m n : Nat), Dvd.dvd m n → Membership.mem s n → Membership.mem s m\n⊢ Iff (∀ (n : Nat), GT.gt n 0 → Membership.mem s n → Eq (n.divisors.prod fun i => f i) (g n)) (∀ (n : Nat), GT.gt n 0 → Membership.mem s n → Eq (n.divisorsAntidiagonal.prod fun x => HPow.hPow (g x.2) (ArithmeticFunction.moebius x.1)) (f n))","decl":"/-- Möbius inversion for functions to a `CommGroup`, where the equalities only hold on a\nwell-behaved set. -/\ntheorem prod_eq_iff_prod_pow_moebius_eq_on [CommGroup R] {f g : ℕ → R}\n    (s : Set ℕ) (hs : ∀ m n, m ∣ n → n ∈ s → m ∈ s) :\n    (∀ n > 0, n ∈ s → (∏ i ∈ n.divisors, f i) = g n) ↔\n      ∀ n > 0, n ∈ s → (∏ x ∈ n.divisorsAntidiagonal, g x.snd ^ μ x.fst) = f n :=\n  @sum_eq_iff_sum_smul_moebius_eq_on (Additive R) _ _ _ s hs\n\n"}
{"name":"ArithmeticFunction.prod_eq_iff_prod_pow_moebius_eq_on_of_nonzero","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"R : Type u_1\ninst✝ : CommGroupWithZero R\ns : Set Nat\nhs : ∀ (m n : Nat), Dvd.dvd m n → Membership.mem s n → Membership.mem s m\nf g : Nat → R\nhf : ∀ (n : Nat), GT.gt n 0 → Ne (f n) 0\nhg : ∀ (n : Nat), GT.gt n 0 → Ne (g n) 0\n⊢ Iff (∀ (n : Nat), GT.gt n 0 → Membership.mem s n → Eq (n.divisors.prod fun i => f i) (g n)) (∀ (n : Nat), GT.gt n 0 → Membership.mem s n → Eq (n.divisorsAntidiagonal.prod fun x => HPow.hPow (g x.2) (ArithmeticFunction.moebius x.1)) (f n))","decl":"/-- Möbius inversion for functions to a `CommGroupWithZero`, where the equalities only hold on\na well-behaved set. -/\ntheorem prod_eq_iff_prod_pow_moebius_eq_on_of_nonzero [CommGroupWithZero R]\n    (s : Set ℕ) (hs : ∀ m n, m ∣ n → n ∈ s → m ∈ s) {f g : ℕ → R}\n    (hf : ∀ n > 0, f n ≠ 0) (hg : ∀ n > 0, g n ≠ 0) :\n    (∀ n > 0, n ∈ s → (∏ i ∈ n.divisors, f i) = g n) ↔\n      ∀ n > 0, n ∈ s → (∏ x ∈ n.divisorsAntidiagonal, g x.snd ^ μ x.fst) = f n := by\n  refine\n      Iff.trans\n        (Iff.trans (forall_congr' fun n => ?_)\n          (@prod_eq_iff_prod_pow_moebius_eq_on Rˣ _\n            (fun n => if h : 0 < n then Units.mk0 (f n) (hf n h) else 1)\n            (fun n => if h : 0 < n then Units.mk0 (g n) (hg n h) else 1)\n            s hs) )\n        (forall_congr' fun n => ?_) <;>\n    refine imp_congr_right fun hn => ?_\n  · dsimp\n    rw [dif_pos hn, ← Units.eq_iff, ← Units.coeHom_apply, map_prod, Units.val_mk0,\n      prod_congr rfl _]\n    intro x hx\n    rw [dif_pos (Nat.pos_of_mem_divisors hx), Units.coeHom_apply, Units.val_mk0]\n  · dsimp\n    rw [dif_pos hn, ← Units.eq_iff, ← Units.coeHom_apply, map_prod, Units.val_mk0,\n      prod_congr rfl _]\n    intro x hx\n    rw [dif_pos (Nat.pos_of_mem_divisors (Nat.snd_mem_divisors_of_mem_antidiagonal hx)),\n      Units.coeHom_apply, Units.val_zpow_eq_zpow_val, Units.val_mk0]\n\n"}
{"name":"Nat.card_divisors","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"n : Nat\nhn : Ne n 0\n⊢ Eq n.divisors.card (n.primeFactors.prod fun x => HAdd.hAdd (n.factorization x) 1)","decl":"theorem _root_.Nat.card_divisors {n : ℕ} (hn : n ≠ 0) :\n    #n.divisors = n.primeFactors.prod (n.factorization · + 1) := by\n  rw [← sigma_zero_apply, isMultiplicative_sigma.multiplicative_factorization _ hn]\n  exact Finset.prod_congr n.support_factorization fun _ h =>\n    sigma_zero_apply_prime_pow <| Nat.prime_of_mem_primeFactors h\n\n"}
{"name":"Nat.sum_divisors","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"n : Nat\nhn : Ne n 0\n⊢ Eq (n.divisors.sum fun d => d) (n.primeFactors.prod fun p => (Finset.range (HAdd.hAdd (n.factorization p) 1)).sum fun k => HPow.hPow p k)","decl":"theorem _root_.Nat.sum_divisors {n : ℕ} (hn : n ≠ 0) :\n    ∑ d ∈ n.divisors, d = ∏ p ∈ n.primeFactors, ∑ k ∈ .range (n.factorization p + 1), p ^ k := by\n  rw [← sigma_one_apply, isMultiplicative_sigma.multiplicative_factorization _ hn]\n  exact Finset.prod_congr n.support_factorization fun _ h =>\n    sigma_one_apply_prime_pow <| Nat.prime_of_mem_primeFactors h\n\n"}
{"name":"Nat.Coprime.card_divisors_mul","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"m n : Nat\nhmn : m.Coprime n\n⊢ Eq (HMul.hMul m n).divisors.card (HMul.hMul m.divisors.card n.divisors.card)","decl":"theorem card_divisors_mul {m n : ℕ} (hmn : m.Coprime n) :\n    #(m * n).divisors = #m.divisors * #n.divisors := by\n  simp only [← sigma_zero_apply, isMultiplicative_sigma.map_mul_of_coprime hmn]\n\n"}
{"name":"Nat.Coprime.sum_divisors_mul","module":"Mathlib.NumberTheory.ArithmeticFunction","initialProofState":"m n : Nat\nhmn : m.Coprime n\n⊢ Eq ((HMul.hMul m n).divisors.sum fun d => d) (HMul.hMul (m.divisors.sum fun d => d) (n.divisors.sum fun d => d))","decl":"theorem sum_divisors_mul {m n : ℕ} (hmn : m.Coprime n) :\n    ∑ d ∈ (m * n).divisors, d = (∑ d ∈ m.divisors, d) * ∑ d ∈ n.divisors, d := by\n  simp only [← sigma_one_apply, isMultiplicative_sigma.map_mul_of_coprime hmn]\n\n"}
