{"name":"MvPowerSeries.instNontrivial","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Nontrivial R\n⊢ Nontrivial (MvPowerSeries σ R)","decl":"instance [Nontrivial R] : Nontrivial (MvPowerSeries σ R) :=\n  Function.nontrivial\n\n"}
{"name":"MvPowerSeries.instIsScalarTower","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\nA : Type u_3\nS : Type u_4\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid A\ninst✝³ : Module R A\ninst✝² : Module S A\ninst✝¹ : SMul R S\ninst✝ : IsScalarTower R S A\n⊢ IsScalarTower R S (MvPowerSeries σ A)","decl":"instance {A S} [Semiring R] [Semiring S] [AddCommMonoid A] [Module R A] [Module S A] [SMul R S]\n    [IsScalarTower R S A] : IsScalarTower R S (MvPowerSeries σ A) :=\n  Pi.isScalarTower\n\n"}
{"name":"MvPowerSeries.coeff_apply","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nf : MvPowerSeries σ R\nd : Finsupp σ Nat\n⊢ Eq ((MvPowerSeries.coeff R d) f) (f d)","decl":"theorem coeff_apply (f : MvPowerSeries σ R) (d : σ →₀ ℕ) : coeff R d f = f d :=\n  rfl\n\n"}
{"name":"MvPowerSeries.ext_iff","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nφ ψ : MvPowerSeries σ R\n⊢ Iff (Eq φ ψ) (∀ (n : Finsupp σ Nat), Eq ((MvPowerSeries.coeff R n) φ) ((MvPowerSeries.coeff R n) ψ))","decl":"/-- Two multivariate formal power series are equal if all their coefficients are equal. -/\n@[ext]\ntheorem ext {φ ψ} (h : ∀ n : σ →₀ ℕ, coeff R n φ = coeff R n ψ) : φ = ψ :=\n  funext h\n\n"}
{"name":"MvPowerSeries.ext","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nφ ψ : MvPowerSeries σ R\nh : ∀ (n : Finsupp σ Nat), Eq ((MvPowerSeries.coeff R n) φ) ((MvPowerSeries.coeff R n) ψ)\n⊢ Eq φ ψ","decl":"/-- Two multivariate formal power series are equal if all their coefficients are equal. -/\n@[ext]\ntheorem ext {φ ψ} (h : ∀ n : σ →₀ ℕ, coeff R n φ = coeff R n ψ) : φ = ψ :=\n  funext h\n\n"}
{"name":"MvPowerSeries.monomial_def","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝¹ : Semiring R\ninst✝ : DecidableEq σ\nn : Finsupp σ Nat\n⊢ Eq (MvPowerSeries.monomial R n) (LinearMap.single R (fun x => R) n)","decl":"theorem monomial_def [DecidableEq σ] (n : σ →₀ ℕ) :\n    (monomial R n) = LinearMap.single R (fun _ ↦ R) n := by\n  rw [monomial]\n  -- unify the `Decidable` arguments\n  convert rfl\n\n"}
{"name":"MvPowerSeries.coeff_monomial","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝¹ : Semiring R\ninst✝ : DecidableEq σ\nm n : Finsupp σ Nat\na : R\n⊢ Eq ((MvPowerSeries.coeff R m) ((MvPowerSeries.monomial R n) a)) (ite (Eq m n) a 0)","decl":"theorem coeff_monomial [DecidableEq σ] (m n : σ →₀ ℕ) (a : R) :\n    coeff R m (monomial R n a) = if m = n then a else 0 := by\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [coeff, monomial_def, LinearMap.proj_apply (i := m)]\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [LinearMap.single_apply, Pi.single_apply]\n\n"}
{"name":"MvPowerSeries.coeff_monomial_same","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nn : Finsupp σ Nat\na : R\n⊢ Eq ((MvPowerSeries.coeff R n) ((MvPowerSeries.monomial R n) a)) a","decl":"@[simp]\ntheorem coeff_monomial_same (n : σ →₀ ℕ) (a : R) : coeff R n (monomial R n a) = a := by\n  classical\n  rw [monomial_def]\n  exact Pi.single_eq_same _ _\n\n"}
{"name":"MvPowerSeries.coeff_monomial_ne","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nm n : Finsupp σ Nat\nh : Ne m n\na : R\n⊢ Eq ((MvPowerSeries.coeff R m) ((MvPowerSeries.monomial R n) a)) 0","decl":"theorem coeff_monomial_ne {m n : σ →₀ ℕ} (h : m ≠ n) (a : R) : coeff R m (monomial R n a) = 0 := by\n  classical\n  rw [monomial_def]\n  exact Pi.single_eq_of_ne h _\n\n"}
{"name":"MvPowerSeries.eq_of_coeff_monomial_ne_zero","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nm n : Finsupp σ Nat\na : R\nh : Ne ((MvPowerSeries.coeff R m) ((MvPowerSeries.monomial R n) a)) 0\n⊢ Eq m n","decl":"theorem eq_of_coeff_monomial_ne_zero {m n : σ →₀ ℕ} {a : R} (h : coeff R m (monomial R n a) ≠ 0) :\n    m = n :=\n  by_contra fun h' => h <| coeff_monomial_ne h' a\n\n"}
{"name":"MvPowerSeries.coeff_comp_monomial","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nn : Finsupp σ Nat\n⊢ Eq ((MvPowerSeries.coeff R n).comp (MvPowerSeries.monomial R n)) LinearMap.id","decl":"@[simp]\ntheorem coeff_comp_monomial (n : σ →₀ ℕ) : (coeff R n).comp (monomial R n) = LinearMap.id :=\n  LinearMap.ext <| coeff_monomial_same n\n\n"}
{"name":"MvPowerSeries.coeff_zero","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nn : Finsupp σ Nat\n⊢ Eq ((MvPowerSeries.coeff R n) 0) 0","decl":"@[simp]\ntheorem coeff_zero (n : σ →₀ ℕ) : coeff R n (0 : MvPowerSeries σ R) = 0 :=\n  rfl\n\n"}
{"name":"MvPowerSeries.eq_zero_iff_forall_coeff_zero","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nf : MvPowerSeries σ R\n⊢ Iff (Eq f 0) (∀ (d : Finsupp σ Nat), Eq ((MvPowerSeries.coeff R d) f) 0)","decl":"theorem eq_zero_iff_forall_coeff_zero {f : MvPowerSeries σ R} :\n    f = 0 ↔ (∀ d : σ →₀ ℕ, coeff R d f = 0) :=\n  MvPowerSeries.ext_iff\n\n"}
{"name":"MvPowerSeries.ne_zero_iff_exists_coeff_ne_zero","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nf : MvPowerSeries σ R\n⊢ Iff (Ne f 0) (Exists fun d => Ne ((MvPowerSeries.coeff R d) f) 0)","decl":"theorem ne_zero_iff_exists_coeff_ne_zero (f : MvPowerSeries σ R) :\n    f ≠ 0 ↔ (∃ d : σ →₀ ℕ, coeff R d f ≠ 0) := by\n  simp only [MvPowerSeries.ext_iff, ne_eq, coeff_zero, not_forall]\n\n"}
{"name":"MvPowerSeries.coeff_one","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝¹ : Semiring R\nn : Finsupp σ Nat\ninst✝ : DecidableEq σ\n⊢ Eq ((MvPowerSeries.coeff R n) 1) (ite (Eq n 0) 1 0)","decl":"theorem coeff_one [DecidableEq σ] : coeff R n (1 : MvPowerSeries σ R) = if n = 0 then 1 else 0 :=\n  coeff_monomial _ _ _\n\n"}
{"name":"MvPowerSeries.coeff_zero_one","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\n⊢ Eq ((MvPowerSeries.coeff R 0) 1) 1","decl":"theorem coeff_zero_one : coeff R (0 : σ →₀ ℕ) 1 = 1 :=\n  coeff_monomial_same 0 1\n\n"}
{"name":"MvPowerSeries.monomial_zero_one","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\n⊢ Eq ((MvPowerSeries.monomial R 0) 1) 1","decl":"theorem monomial_zero_one : monomial R (0 : σ →₀ ℕ) 1 = 1 :=\n  rfl\n\n"}
{"name":"MvPowerSeries.coeff_mul","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝¹ : Semiring R\nn : Finsupp σ Nat\nφ ψ : MvPowerSeries σ R\ninst✝ : DecidableEq σ\n⊢ Eq ((MvPowerSeries.coeff R n) (HMul.hMul φ ψ)) ((Finset.HasAntidiagonal.antidiagonal n).sum fun p => HMul.hMul ((MvPowerSeries.coeff R p.1) φ) ((MvPowerSeries.coeff R p.2) ψ))","decl":"theorem coeff_mul [DecidableEq σ] :\n    coeff R n (φ * ψ) = ∑ p ∈ antidiagonal n, coeff R p.1 φ * coeff R p.2 ψ := by\n  refine Finset.sum_congr ?_ fun _ _ => rfl\n  rw [Subsingleton.elim (Classical.decEq σ) ‹DecidableEq σ›]\n\n"}
{"name":"MvPowerSeries.zero_mul","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nφ : MvPowerSeries σ R\n⊢ Eq (HMul.hMul 0 φ) 0","decl":"protected theorem zero_mul : (0 : MvPowerSeries σ R) * φ = 0 :=\n  ext fun n => by classical simp [coeff_mul]\n\n"}
{"name":"MvPowerSeries.mul_zero","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nφ : MvPowerSeries σ R\n⊢ Eq (HMul.hMul φ 0) 0","decl":"protected theorem mul_zero : φ * 0 = 0 :=\n  ext fun n => by classical simp [coeff_mul]\n\n"}
{"name":"MvPowerSeries.coeff_monomial_mul","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nm n : Finsupp σ Nat\nφ : MvPowerSeries σ R\na : R\n⊢ Eq ((MvPowerSeries.coeff R m) (HMul.hMul ((MvPowerSeries.monomial R n) a) φ)) (ite (LE.le n m) (HMul.hMul a ((MvPowerSeries.coeff R (HSub.hSub m n)) φ)) 0)","decl":"theorem coeff_monomial_mul (a : R) :\n    coeff R m (monomial R n a * φ) = if n ≤ m then a * coeff R (m - n) φ else 0 := by\n  classical\n  have :\n    ∀ p ∈ antidiagonal m,\n      coeff R (p : (σ →₀ ℕ) × (σ →₀ ℕ)).1 (monomial R n a) * coeff R p.2 φ ≠ 0 → p.1 = n :=\n    fun p _ hp => eq_of_coeff_monomial_ne_zero (left_ne_zero_of_mul hp)\n  rw [coeff_mul, ← Finset.sum_filter_of_ne this, Finset.filter_fst_eq_antidiagonal _ n,\n    Finset.sum_ite_index]\n  simp only [Finset.sum_singleton, coeff_monomial_same, Finset.sum_empty]\n\n"}
{"name":"MvPowerSeries.coeff_mul_monomial","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nm n : Finsupp σ Nat\nφ : MvPowerSeries σ R\na : R\n⊢ Eq ((MvPowerSeries.coeff R m) (HMul.hMul φ ((MvPowerSeries.monomial R n) a))) (ite (LE.le n m) (HMul.hMul ((MvPowerSeries.coeff R (HSub.hSub m n)) φ) a) 0)","decl":"theorem coeff_mul_monomial (a : R) :\n    coeff R m (φ * monomial R n a) = if n ≤ m then coeff R (m - n) φ * a else 0 := by\n  classical\n  have :\n    ∀ p ∈ antidiagonal m,\n      coeff R (p : (σ →₀ ℕ) × (σ →₀ ℕ)).1 φ * coeff R p.2 (monomial R n a) ≠ 0 → p.2 = n :=\n    fun p _ hp => eq_of_coeff_monomial_ne_zero (right_ne_zero_of_mul hp)\n  rw [coeff_mul, ← Finset.sum_filter_of_ne this, Finset.filter_snd_eq_antidiagonal _ n,\n    Finset.sum_ite_index]\n  simp only [Finset.sum_singleton, coeff_monomial_same, Finset.sum_empty]\n\n"}
{"name":"MvPowerSeries.coeff_add_monomial_mul","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nm n : Finsupp σ Nat\nφ : MvPowerSeries σ R\na : R\n⊢ Eq ((MvPowerSeries.coeff R (HAdd.hAdd m n)) (HMul.hMul ((MvPowerSeries.monomial R m) a) φ)) (HMul.hMul a ((MvPowerSeries.coeff R n) φ))","decl":"theorem coeff_add_monomial_mul (a : R) :\n    coeff R (m + n) (monomial R m a * φ) = a * coeff R n φ := by\n  rw [coeff_monomial_mul, if_pos, add_tsub_cancel_left]\n  exact le_add_right le_rfl\n\n"}
{"name":"MvPowerSeries.coeff_add_mul_monomial","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nm n : Finsupp σ Nat\nφ : MvPowerSeries σ R\na : R\n⊢ Eq ((MvPowerSeries.coeff R (HAdd.hAdd m n)) (HMul.hMul φ ((MvPowerSeries.monomial R n) a))) (HMul.hMul ((MvPowerSeries.coeff R m) φ) a)","decl":"theorem coeff_add_mul_monomial (a : R) :\n    coeff R (m + n) (φ * monomial R n a) = coeff R m φ * a := by\n  rw [coeff_mul_monomial, if_pos, add_tsub_cancel_right]\n  exact le_add_left le_rfl\n\n"}
{"name":"MvPowerSeries.commute_monomial","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nφ : MvPowerSeries σ R\na : R\nn : Finsupp σ Nat\n⊢ Iff (Commute φ ((MvPowerSeries.monomial R n) a)) (∀ (m : Finsupp σ Nat), Commute ((MvPowerSeries.coeff R m) φ) a)","decl":"@[simp]\ntheorem commute_monomial {a : R} {n} :\n    Commute φ (monomial R n a) ↔ ∀ m, Commute (coeff R m φ) a := by\n  rw [commute_iff_eq, MvPowerSeries.ext_iff]\n  refine ⟨fun h m => ?_, fun h m => ?_⟩\n  · have := h (m + n)\n    rwa [coeff_add_mul_monomial, add_comm, coeff_add_monomial_mul] at this\n  · rw [coeff_mul_monomial, coeff_monomial_mul]\n    split_ifs <;> [apply h; rfl]\n\n"}
{"name":"MvPowerSeries.one_mul","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nφ : MvPowerSeries σ R\n⊢ Eq (HMul.hMul 1 φ) φ","decl":"protected theorem one_mul : (1 : MvPowerSeries σ R) * φ = φ :=\n  ext fun n => by simpa using coeff_add_monomial_mul 0 n φ 1\n\n"}
{"name":"MvPowerSeries.mul_one","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nφ : MvPowerSeries σ R\n⊢ Eq (HMul.hMul φ 1) φ","decl":"protected theorem mul_one : φ * 1 = φ :=\n  ext fun n => by simpa using coeff_add_mul_monomial n 0 φ 1\n\n"}
{"name":"MvPowerSeries.mul_add","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nφ₁ φ₂ φ₃ : MvPowerSeries σ R\n⊢ Eq (HMul.hMul φ₁ (HAdd.hAdd φ₂ φ₃)) (HAdd.hAdd (HMul.hMul φ₁ φ₂) (HMul.hMul φ₁ φ₃))","decl":"protected theorem mul_add (φ₁ φ₂ φ₃ : MvPowerSeries σ R) : φ₁ * (φ₂ + φ₃) = φ₁ * φ₂ + φ₁ * φ₃ :=\n  ext fun n => by\n    classical simp only [coeff_mul, mul_add, Finset.sum_add_distrib, LinearMap.map_add]\n\n"}
{"name":"MvPowerSeries.add_mul","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nφ₁ φ₂ φ₃ : MvPowerSeries σ R\n⊢ Eq (HMul.hMul (HAdd.hAdd φ₁ φ₂) φ₃) (HAdd.hAdd (HMul.hMul φ₁ φ₃) (HMul.hMul φ₂ φ₃))","decl":"protected theorem add_mul (φ₁ φ₂ φ₃ : MvPowerSeries σ R) : (φ₁ + φ₂) * φ₃ = φ₁ * φ₃ + φ₂ * φ₃ :=\n  ext fun n => by\n    classical simp only [coeff_mul, add_mul, Finset.sum_add_distrib, LinearMap.map_add]\n\n"}
{"name":"MvPowerSeries.mul_assoc","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nφ₁ φ₂ φ₃ : MvPowerSeries σ R\n⊢ Eq (HMul.hMul (HMul.hMul φ₁ φ₂) φ₃) (HMul.hMul φ₁ (HMul.hMul φ₂ φ₃))","decl":"protected theorem mul_assoc (φ₁ φ₂ φ₃ : MvPowerSeries σ R) : φ₁ * φ₂ * φ₃ = φ₁ * (φ₂ * φ₃) := by\n  ext1 n\n  classical\n  simp only [coeff_mul, Finset.sum_mul, Finset.mul_sum, Finset.sum_sigma']\n  apply Finset.sum_nbij' (fun ⟨⟨_i, j⟩, ⟨k, l⟩⟩ ↦ ⟨(k, l + j), (l, j)⟩)\n    (fun ⟨⟨i, _j⟩, ⟨k, l⟩⟩ ↦ ⟨(i + k, l), (i, k)⟩) <;> aesop (add simp [add_assoc, mul_assoc])\n\n"}
{"name":"MvPowerSeries.monomial_mul_monomial","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nm n : Finsupp σ Nat\na b : R\n⊢ Eq (HMul.hMul ((MvPowerSeries.monomial R m) a) ((MvPowerSeries.monomial R n) b)) ((MvPowerSeries.monomial R (HAdd.hAdd m n)) (HMul.hMul a b))","decl":"theorem monomial_mul_monomial (m n : σ →₀ ℕ) (a b : R) :\n    monomial R m a * monomial R n b = monomial R (m + n) (a * b) := by\n  classical\n  ext k\n  simp only [coeff_mul_monomial, coeff_monomial]\n  split_ifs with h₁ h₂ h₃ h₃ h₂ <;> try rfl\n  · rw [← h₂, tsub_add_cancel_of_le h₁] at h₃\n    exact (h₃ rfl).elim\n  · rw [h₃, add_tsub_cancel_right] at h₂\n    exact (h₂ rfl).elim\n  · exact zero_mul b\n  · rw [h₂] at h₁\n    exact (h₁ <| le_add_left le_rfl).elim\n\n"}
{"name":"MvPowerSeries.monomial_zero_eq_C","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\n⊢ Eq ⇑(MvPowerSeries.monomial R 0) ⇑(MvPowerSeries.C σ R)","decl":"@[simp]\ntheorem monomial_zero_eq_C : ⇑(monomial R (0 : σ →₀ ℕ)) = C σ R :=\n  rfl\n\n"}
{"name":"MvPowerSeries.monomial_zero_eq_C_apply","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\na : R\n⊢ Eq ((MvPowerSeries.monomial R 0) a) ((MvPowerSeries.C σ R) a)","decl":"theorem monomial_zero_eq_C_apply (a : R) : monomial R (0 : σ →₀ ℕ) a = C σ R a :=\n  rfl\n\n"}
{"name":"MvPowerSeries.coeff_C","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝¹ : Semiring R\ninst✝ : DecidableEq σ\nn : Finsupp σ Nat\na : R\n⊢ Eq ((MvPowerSeries.coeff R n) ((MvPowerSeries.C σ R) a)) (ite (Eq n 0) a 0)","decl":"theorem coeff_C [DecidableEq σ] (n : σ →₀ ℕ) (a : R) :\n    coeff R n (C σ R a) = if n = 0 then a else 0 :=\n  coeff_monomial _ _ _\n\n"}
{"name":"MvPowerSeries.coeff_zero_C","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\na : R\n⊢ Eq ((MvPowerSeries.coeff R 0) ((MvPowerSeries.C σ R) a)) a","decl":"theorem coeff_zero_C (a : R) : coeff R (0 : σ →₀ ℕ) (C σ R a) = a :=\n  coeff_monomial_same 0 a\n\n"}
{"name":"MvPowerSeries.coeff_X","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝¹ : Semiring R\ninst✝ : DecidableEq σ\nn : Finsupp σ Nat\ns : σ\n⊢ Eq ((MvPowerSeries.coeff R n) (MvPowerSeries.X s)) (ite (Eq n (Finsupp.single s 1)) 1 0)","decl":"theorem coeff_X [DecidableEq σ] (n : σ →₀ ℕ) (s : σ) :\n    coeff R n (X s : MvPowerSeries σ R) = if n = single s 1 then 1 else 0 :=\n  coeff_monomial _ _ _\n\n"}
{"name":"MvPowerSeries.coeff_index_single_X","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝¹ : Semiring R\ninst✝ : DecidableEq σ\ns t : σ\n⊢ Eq ((MvPowerSeries.coeff R (Finsupp.single t 1)) (MvPowerSeries.X s)) (ite (Eq t s) 1 0)","decl":"theorem coeff_index_single_X [DecidableEq σ] (s t : σ) :\n    coeff R (single t 1) (X s : MvPowerSeries σ R) = if t = s then 1 else 0 := by\n  simp only [coeff_X, single_left_inj (one_ne_zero : (1 : ℕ) ≠ 0)]\n\n"}
{"name":"MvPowerSeries.coeff_index_single_self_X","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\ns : σ\n⊢ Eq ((MvPowerSeries.coeff R (Finsupp.single s 1)) (MvPowerSeries.X s)) 1","decl":"@[simp]\ntheorem coeff_index_single_self_X (s : σ) : coeff R (single s 1) (X s : MvPowerSeries σ R) = 1 :=\n  coeff_monomial_same _ _\n\n"}
{"name":"MvPowerSeries.coeff_zero_X","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\ns : σ\n⊢ Eq ((MvPowerSeries.coeff R 0) (MvPowerSeries.X s)) 0","decl":"theorem coeff_zero_X (s : σ) : coeff R (0 : σ →₀ ℕ) (X s : MvPowerSeries σ R) = 0 := by\n  classical\n  rw [coeff_X, if_neg]\n  intro h\n  exact one_ne_zero (single_eq_zero.mp h.symm)\n\n"}
{"name":"MvPowerSeries.commute_X","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nφ : MvPowerSeries σ R\ns : σ\n⊢ Commute φ (MvPowerSeries.X s)","decl":"theorem commute_X (φ : MvPowerSeries σ R) (s : σ) : Commute φ (X s) :=\n  φ.commute_monomial.mpr fun _m => Commute.one_right _\n\n"}
{"name":"MvPowerSeries.X_def","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\ns : σ\n⊢ Eq (MvPowerSeries.X s) ((MvPowerSeries.monomial R (Finsupp.single s 1)) 1)","decl":"theorem X_def (s : σ) : X s = monomial R (single s 1) 1 :=\n  rfl\n\n"}
{"name":"MvPowerSeries.X_pow_eq","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\ns : σ\nn : Nat\n⊢ Eq (HPow.hPow (MvPowerSeries.X s) n) ((MvPowerSeries.monomial R (Finsupp.single s n)) 1)","decl":"theorem X_pow_eq (s : σ) (n : ℕ) : (X s : MvPowerSeries σ R) ^ n = monomial R (single s n) 1 := by\n  induction n with\n  | zero => simp\n  | succ n ih => rw [pow_succ, ih, Finsupp.single_add, X, monomial_mul_monomial, one_mul]\n\n"}
{"name":"MvPowerSeries.coeff_X_pow","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝¹ : Semiring R\ninst✝ : DecidableEq σ\nm : Finsupp σ Nat\ns : σ\nn : Nat\n⊢ Eq ((MvPowerSeries.coeff R m) (HPow.hPow (MvPowerSeries.X s) n)) (ite (Eq m (Finsupp.single s n)) 1 0)","decl":"theorem coeff_X_pow [DecidableEq σ] (m : σ →₀ ℕ) (s : σ) (n : ℕ) :\n    coeff R m ((X s : MvPowerSeries σ R) ^ n) = if m = single s n then 1 else 0 := by\n  rw [X_pow_eq s n, coeff_monomial]\n\n"}
{"name":"MvPowerSeries.coeff_mul_C","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nn : Finsupp σ Nat\nφ : MvPowerSeries σ R\na : R\n⊢ Eq ((MvPowerSeries.coeff R n) (HMul.hMul φ ((MvPowerSeries.C σ R) a))) (HMul.hMul ((MvPowerSeries.coeff R n) φ) a)","decl":"@[simp]\ntheorem coeff_mul_C (n : σ →₀ ℕ) (φ : MvPowerSeries σ R) (a : R) :\n    coeff R n (φ * C σ R a) = coeff R n φ * a := by simpa using coeff_add_mul_monomial n 0 φ a\n\n"}
{"name":"MvPowerSeries.coeff_C_mul","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nn : Finsupp σ Nat\nφ : MvPowerSeries σ R\na : R\n⊢ Eq ((MvPowerSeries.coeff R n) (HMul.hMul ((MvPowerSeries.C σ R) a) φ)) (HMul.hMul a ((MvPowerSeries.coeff R n) φ))","decl":"@[simp]\ntheorem coeff_C_mul (n : σ →₀ ℕ) (φ : MvPowerSeries σ R) (a : R) :\n    coeff R n (C σ R a * φ) = a * coeff R n φ := by simpa using coeff_add_monomial_mul 0 n φ a\n\n"}
{"name":"MvPowerSeries.coeff_zero_mul_X","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nφ : MvPowerSeries σ R\ns : σ\n⊢ Eq ((MvPowerSeries.coeff R 0) (HMul.hMul φ (MvPowerSeries.X s))) 0","decl":"theorem coeff_zero_mul_X (φ : MvPowerSeries σ R) (s : σ) : coeff R (0 : σ →₀ ℕ) (φ * X s) = 0 := by\n  have : ¬single s 1 ≤ 0 := fun h => by simpa using h s\n  simp only [X, coeff_mul_monomial, if_neg this]\n\n"}
{"name":"MvPowerSeries.coeff_zero_X_mul","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nφ : MvPowerSeries σ R\ns : σ\n⊢ Eq ((MvPowerSeries.coeff R 0) (HMul.hMul (MvPowerSeries.X s) φ)) 0","decl":"theorem coeff_zero_X_mul (φ : MvPowerSeries σ R) (s : σ) : coeff R (0 : σ →₀ ℕ) (X s * φ) = 0 := by\n  rw [← (φ.commute_X s).eq, coeff_zero_mul_X]\n\n"}
{"name":"MvPowerSeries.coeff_zero_eq_constantCoeff","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\n⊢ Eq ⇑(MvPowerSeries.coeff R 0) ⇑(MvPowerSeries.constantCoeff σ R)","decl":"@[simp]\ntheorem coeff_zero_eq_constantCoeff : ⇑(coeff R (0 : σ →₀ ℕ)) = constantCoeff σ R :=\n  rfl\n\n"}
{"name":"MvPowerSeries.coeff_zero_eq_constantCoeff_apply","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nφ : MvPowerSeries σ R\n⊢ Eq ((MvPowerSeries.coeff R 0) φ) ((MvPowerSeries.constantCoeff σ R) φ)","decl":"theorem coeff_zero_eq_constantCoeff_apply (φ : MvPowerSeries σ R) :\n    coeff R (0 : σ →₀ ℕ) φ = constantCoeff σ R φ :=\n  rfl\n\n"}
{"name":"MvPowerSeries.constantCoeff_C","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\na : R\n⊢ Eq ((MvPowerSeries.constantCoeff σ R) ((MvPowerSeries.C σ R) a)) a","decl":"@[simp]\ntheorem constantCoeff_C (a : R) : constantCoeff σ R (C σ R a) = a :=\n  rfl\n\n"}
{"name":"MvPowerSeries.constantCoeff_comp_C","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\n⊢ Eq ((MvPowerSeries.constantCoeff σ R).comp (MvPowerSeries.C σ R)) (RingHom.id R)","decl":"@[simp]\ntheorem constantCoeff_comp_C : (constantCoeff σ R).comp (C σ R) = RingHom.id R :=\n  rfl\n\n"}
{"name":"MvPowerSeries.constantCoeff_zero","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\n⊢ Eq ((MvPowerSeries.constantCoeff σ R) 0) 0","decl":"@[simp]\ntheorem constantCoeff_zero : constantCoeff σ R 0 = 0 :=\n  rfl\n\n"}
{"name":"MvPowerSeries.constantCoeff_one","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\n⊢ Eq ((MvPowerSeries.constantCoeff σ R) 1) 1","decl":"@[simp]\ntheorem constantCoeff_one : constantCoeff σ R 1 = 1 :=\n  rfl\n\n"}
{"name":"MvPowerSeries.constantCoeff_X","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\ns : σ\n⊢ Eq ((MvPowerSeries.constantCoeff σ R) (MvPowerSeries.X s)) 0","decl":"@[simp]\ntheorem constantCoeff_X (s : σ) : constantCoeff σ R (X s) = 0 :=\n  coeff_zero_X s\n\n"}
{"name":"MvPowerSeries.isUnit_constantCoeff","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nφ : MvPowerSeries σ R\nh : IsUnit φ\n⊢ IsUnit ((MvPowerSeries.constantCoeff σ R) φ)","decl":"/-- If a multivariate formal power series is invertible,\n then so is its constant coefficient. -/\ntheorem isUnit_constantCoeff (φ : MvPowerSeries σ R) (h : IsUnit φ) :\n    IsUnit (constantCoeff σ R φ) :=\n  h.map _\n\n"}
{"name":"MvPowerSeries.coeff_smul","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nf : MvPowerSeries σ R\nn : Finsupp σ Nat\na : R\n⊢ Eq ((MvPowerSeries.coeff R n) (HSMul.hSMul a f)) (HMul.hMul a ((MvPowerSeries.coeff R n) f))","decl":"@[simp]\ntheorem coeff_smul (f : MvPowerSeries σ R) (n) (a : R) : coeff _ n (a • f) = a * coeff _ n f :=\n  rfl\n\n"}
{"name":"MvPowerSeries.smul_eq_C_mul","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nf : MvPowerSeries σ R\na : R\n⊢ Eq (HSMul.hSMul a f) (HMul.hMul ((MvPowerSeries.C σ R) a) f)","decl":"theorem smul_eq_C_mul (f : MvPowerSeries σ R) (a : R) : a • f = C σ R a * f := by\n  ext\n  simp\n\n"}
{"name":"MvPowerSeries.X_inj","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝¹ : Semiring R\ninst✝ : Nontrivial R\ns t : σ\n⊢ Iff (Eq (MvPowerSeries.X s) (MvPowerSeries.X t)) (Eq s t)","decl":"theorem X_inj [Nontrivial R] {s t : σ} : (X s : MvPowerSeries σ R) = X t ↔ s = t :=\n  ⟨by\n    classical\n    intro h\n    replace h := congr_arg (coeff R (single s 1)) h\n    rw [coeff_X, if_pos rfl, coeff_X] at h\n    split_ifs at h with H\n    · rw [Finsupp.single_eq_single_iff] at H\n      cases' H with H H\n      · exact H.1\n      · exfalso\n        exact one_ne_zero H.1\n    · exfalso\n      exact one_ne_zero h, congr_arg X⟩\n\n"}
{"name":"MvPowerSeries.map_id","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\n⊢ Eq (MvPowerSeries.map σ (RingHom.id R)) (RingHom.id (MvPowerSeries σ R))","decl":"@[simp]\ntheorem map_id : map σ (RingHom.id R) = RingHom.id _ :=\n  rfl\n\n"}
{"name":"MvPowerSeries.map_comp","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\nS : Type u_3\nT : Type u_4\ninst✝² : Semiring R\ninst✝¹ : Semiring S\ninst✝ : Semiring T\nf : RingHom R S\ng : RingHom S T\n⊢ Eq (MvPowerSeries.map σ (g.comp f)) ((MvPowerSeries.map σ g).comp (MvPowerSeries.map σ f))","decl":"theorem map_comp : map σ (g.comp f) = (map σ g).comp (map σ f) :=\n  rfl\n\n"}
{"name":"MvPowerSeries.coeff_map","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nn : Finsupp σ Nat\nφ : MvPowerSeries σ R\n⊢ Eq ((MvPowerSeries.coeff S n) ((MvPowerSeries.map σ f) φ)) (f ((MvPowerSeries.coeff R n) φ))","decl":"@[simp]\ntheorem coeff_map (n : σ →₀ ℕ) (φ : MvPowerSeries σ R) : coeff S n (map σ f φ) = f (coeff R n φ) :=\n  rfl\n\n"}
{"name":"MvPowerSeries.constantCoeff_map","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nφ : MvPowerSeries σ R\n⊢ Eq ((MvPowerSeries.constantCoeff σ S) ((MvPowerSeries.map σ f) φ)) (f ((MvPowerSeries.constantCoeff σ R) φ))","decl":"@[simp]\ntheorem constantCoeff_map (φ : MvPowerSeries σ R) :\n    constantCoeff σ S (map σ f φ) = f (constantCoeff σ R φ) :=\n  rfl\n\n"}
{"name":"MvPowerSeries.map_monomial","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nn : Finsupp σ Nat\na : R\n⊢ Eq ((MvPowerSeries.map σ f) ((MvPowerSeries.monomial R n) a)) ((MvPowerSeries.monomial S n) (f a))","decl":"@[simp]\ntheorem map_monomial (n : σ →₀ ℕ) (a : R) : map σ f (monomial R n a) = monomial S n (f a) := by\n  classical\n  ext m\n  simp [coeff_monomial, apply_ite f]\n\n"}
{"name":"MvPowerSeries.map_C","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\na : R\n⊢ Eq ((MvPowerSeries.map σ f) ((MvPowerSeries.C σ R) a)) ((MvPowerSeries.C σ S) (f a))","decl":"@[simp]\ntheorem map_C (a : R) : map σ f (C σ R a) = C σ S (f a) :=\n  map_monomial _ _ _\n\n"}
{"name":"MvPowerSeries.map_X","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\ns : σ\n⊢ Eq ((MvPowerSeries.map σ f) (MvPowerSeries.X s)) (MvPowerSeries.X s)","decl":"@[simp]\ntheorem map_X (s : σ) : map σ f (X s) = X s := by simp [MvPowerSeries.X]\n\n"}
{"name":"MvPowerSeries.X_pow_dvd_iff","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\ns : σ\nn : Nat\nφ : MvPowerSeries σ R\n⊢ Iff (Dvd.dvd (HPow.hPow (MvPowerSeries.X s) n) φ) (∀ (m : Finsupp σ Nat), LT.lt (m s) n → Eq ((MvPowerSeries.coeff R m) φ) 0)","decl":"theorem X_pow_dvd_iff {s : σ} {n : ℕ} {φ : MvPowerSeries σ R} :\n    (X s : MvPowerSeries σ R) ^ n ∣ φ ↔ ∀ m : σ →₀ ℕ, m s < n → coeff R m φ = 0 := by\n  classical\n  constructor\n  · rintro ⟨φ, rfl⟩ m h\n    rw [coeff_mul, Finset.sum_eq_zero]\n    rintro ⟨i, j⟩ hij\n    rw [coeff_X_pow, if_neg, zero_mul]\n    contrapose! h\n    dsimp at h\n    subst i\n    rw [mem_antidiagonal] at hij\n    rw [← hij, Finsupp.add_apply, Finsupp.single_eq_same]\n    exact Nat.le_add_right n _\n  · intro h\n    refine ⟨fun m => coeff R (m + single s n) φ, ?_⟩\n    ext m\n    by_cases H : m - single s n + single s n = m\n    · rw [coeff_mul, Finset.sum_eq_single (single s n, m - single s n)]\n      · rw [coeff_X_pow, if_pos rfl, one_mul]\n        simpa using congr_arg (fun m : σ →₀ ℕ => coeff R m φ) H.symm\n      · rintro ⟨i, j⟩ hij hne\n        rw [mem_antidiagonal] at hij\n        rw [coeff_X_pow]\n        split_ifs with hi\n        · exfalso\n          apply hne\n          rw [← hij, ← hi, Prod.mk.inj_iff]\n          refine ⟨rfl, ?_⟩\n          ext t\n          simp only [add_tsub_cancel_left, Finsupp.add_apply, Finsupp.tsub_apply]\n        · exact zero_mul _\n      · intro hni\n        exfalso\n        apply hni\n        rwa [mem_antidiagonal, add_comm]\n    · rw [h, coeff_mul, Finset.sum_eq_zero]\n      · rintro ⟨i, j⟩ hij\n        rw [mem_antidiagonal] at hij\n        rw [coeff_X_pow]\n        split_ifs with hi\n        · exfalso\n          apply H\n          rw [← hij, hi]\n          ext\n          rw [coe_add, coe_add, Pi.add_apply, Pi.add_apply, add_tsub_cancel_left, add_comm]\n        · exact zero_mul _\n      · contrapose! H\n        ext t\n        by_cases hst : s = t\n        · subst t\n          simpa using tsub_add_cancel_of_le H\n        · simp [Finsupp.single_apply, hst]\n\n"}
{"name":"MvPowerSeries.X_dvd_iff","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\ns : σ\nφ : MvPowerSeries σ R\n⊢ Iff (Dvd.dvd (MvPowerSeries.X s) φ) (∀ (m : Finsupp σ Nat), Eq (m s) 0 → Eq ((MvPowerSeries.coeff R m) φ) 0)","decl":"theorem X_dvd_iff {s : σ} {φ : MvPowerSeries σ R} :\n    (X s : MvPowerSeries σ R) ∣ φ ↔ ∀ m : σ →₀ ℕ, m s = 0 → coeff R m φ = 0 := by\n  rw [← pow_one (X s : MvPowerSeries σ R), X_pow_dvd_iff]\n  constructor <;> intro h m hm\n  · exact h m (hm.symm ▸ zero_lt_one)\n  · exact h m (Nat.eq_zero_of_le_zero <| Nat.le_of_succ_le_succ hm)\n\n"}
{"name":"MvPowerSeries.coeff_prod","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝² : CommSemiring R\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : DecidableEq σ\nf : ι → MvPowerSeries σ R\nd : Finsupp σ Nat\ns : Finset ι\n⊢ Eq ((MvPowerSeries.coeff R d) (s.prod fun j => f j)) ((s.finsuppAntidiag d).sum fun l => s.prod fun i => (MvPowerSeries.coeff R (l i)) (f i))","decl":"/-- Coefficients of a product of power series -/\ntheorem coeff_prod [DecidableEq σ]\n    (f : ι → MvPowerSeries σ R) (d : σ →₀ ℕ) (s : Finset ι) :\n    coeff R d (∏ j ∈ s, f j) =\n      ∑ l ∈ finsuppAntidiag s d,\n        ∏ i ∈ s, coeff R (l i) (f i) := by\n  induction s using Finset.induction_on generalizing d with\n  | empty =>\n    simp only [prod_empty, sum_const, nsmul_eq_mul, mul_one, coeff_one, finsuppAntidiag_empty]\n    split_ifs\n    · simp only [card_singleton, Nat.cast_one]\n    · simp only [card_empty, Nat.cast_zero]\n  | @insert a s ha ih =>\n    rw [finsuppAntidiag_insert ha, prod_insert ha, coeff_mul, sum_biUnion]\n    · apply Finset.sum_congr rfl\n      simp only [mem_antidiagonal, sum_map, Function.Embedding.coeFn_mk, coe_update, Prod.forall]\n      rintro u v rfl\n      rw [ih, Finset.mul_sum, ← Finset.sum_attach]\n      apply Finset.sum_congr rfl\n      simp only [mem_attach, Finset.prod_insert ha, Function.update_self, forall_true_left,\n        Subtype.forall]\n      rintro x -\n      rw [Finset.prod_congr rfl]\n      intro i hi\n      rw [Function.update_of_ne]\n      exact ne_of_mem_of_not_mem hi ha\n    · simp only [Set.PairwiseDisjoint, Set.Pairwise, mem_coe, mem_antidiagonal, ne_eq,\n        disjoint_left, mem_map, mem_attach, Function.Embedding.coeFn_mk, true_and, Subtype.exists,\n        exists_prop, not_exists, not_and, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂,\n        Prod.forall, Prod.mk.injEq]\n      rintro u v rfl u' v' huv h k - l - hkl\n      obtain rfl : u' = u := by\n        simpa only [Finsupp.coe_update, Function.update_self] using DFunLike.congr_fun hkl a\n      simp only [add_right_inj] at huv\n      exact h rfl huv.symm\n\n"}
{"name":"MvPowerSeries.coeff_pow","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\nf : MvPowerSeries σ R\nn : Nat\nd : Finsupp σ Nat\n⊢ Eq ((MvPowerSeries.coeff R d) (HPow.hPow f n)) (((Finset.range n).finsuppAntidiag d).sum fun l => (Finset.range n).prod fun i => (MvPowerSeries.coeff R (l i)) f)","decl":"/-- The `d`th coefficient of a power of a multivariate power series\nis the sum, indexed by `finsuppAntidiag (Finset.range n) d`, of products of coefficients  -/\ntheorem coeff_pow [DecidableEq σ] (f : MvPowerSeries σ R) {n : ℕ} (d : σ →₀ ℕ) :\n    coeff R d (f ^ n) =\n      ∑ l ∈ finsuppAntidiag (Finset.range n) d,\n        ∏ i ∈ Finset.range n, coeff R (l i) f := by\n  suffices f ^ n = (Finset.range n).prod fun _ ↦ f by\n    rw [this, coeff_prod]\n  rw [Finset.prod_const, card_range]\n\n"}
{"name":"MvPowerSeries.coeff_eq_zero_of_constantCoeff_nilpotent","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nf : MvPowerSeries σ R\nm : Nat\nhf : Eq (HPow.hPow ((MvPowerSeries.constantCoeff σ R) f) m) 0\nd : Finsupp σ Nat\nn : Nat\nhn : LE.le (HAdd.hAdd m d.degree) n\n⊢ Eq ((MvPowerSeries.coeff R d) (HPow.hPow f n)) 0","decl":"/-- Vanishing of coefficients of powers of multivariate power series\nwhen the constant coefficient is nilpotent\n[N. Bourbaki, *Algebra {II}*, Chapter 4, §4, n°2, proposition 3][bourbaki1981] -/\ntheorem coeff_eq_zero_of_constantCoeff_nilpotent\n    {f : MvPowerSeries σ R} {m : ℕ} (hf : constantCoeff σ R f ^ m = 0)\n    {d : σ →₀ ℕ} {n : ℕ} (hn : m + degree d ≤ n) : coeff R d (f ^ n) = 0 := by\n  classical\n  rw [coeff_pow]\n  apply sum_eq_zero\n  intro k hk\n  rw [mem_finsuppAntidiag] at hk\n  set s := {i ∈ range n | k i = 0} with hs_def\n  have hs : s ⊆ range n := filter_subset _ _\n  have hs' (i : ℕ) (hi : i ∈ s) : coeff R (k i) f = constantCoeff σ R f := by\n    simp only [hs_def, mem_filter] at hi\n    rw [hi.2, coeff_zero_eq_constantCoeff]\n  have hs'' (i : ℕ) (hi : i ∈ s) : k i = 0 := by\n    simp only [hs_def, mem_filter] at hi\n    rw [hi.2]\n  rw [← prod_sdiff (s₁ := s) (filter_subset _ _)]\n  apply mul_eq_zero_of_right\n  rw [prod_congr rfl hs', prod_const]\n  suffices m ≤ #s by\n    obtain ⟨m', hm'⟩ := Nat.exists_eq_add_of_le this\n    rw [hm', pow_add, hf, MulZeroClass.zero_mul]\n  rw [← Nat.add_le_add_iff_right, add_comm #s,\n    Finset.card_sdiff_add_card_eq_card (filter_subset _ _), card_range]\n  apply le_trans _ hn\n  simp only [add_comm m, Nat.add_le_add_iff_right, ← hk.1,\n    ← sum_sdiff (hs), sum_eq_zero (s := s) hs'', add_zero]\n  rw [← hs_def]\n  convert Finset.card_nsmul_le_sum (range n \\ s) (fun x ↦ degree (k x)) 1 _\n  · simp only [Algebra.id.smul_eq_mul, mul_one]\n  · simp only [degree_eq_weight_one, map_sum]\n  · simp only [hs_def, mem_filter, mem_sdiff, mem_range, not_and, and_imp]\n    intro i hi hi'\n    rw [← not_lt, Nat.lt_one_iff, degree_eq_zero_iff]\n    exact hi' hi\n\n"}
{"name":"MvPowerSeries.c_eq_algebraMap","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\n⊢ Eq (MvPowerSeries.C σ R) (algebraMap R (MvPowerSeries σ R))","decl":"theorem c_eq_algebraMap : C σ R = algebraMap R (MvPowerSeries σ R) :=\n  rfl\n\n"}
{"name":"MvPowerSeries.algebraMap_apply","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\nA : Type u_3\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nr : R\n⊢ Eq ((algebraMap R (MvPowerSeries σ A)) r) ((MvPowerSeries.C σ A) ((algebraMap R A) r))","decl":"theorem algebraMap_apply {r : R} :\n    algebraMap R (MvPowerSeries σ A) r = C σ A (algebraMap R A r) := by\n  change (MvPowerSeries.map σ (algebraMap R A)).comp (C σ R) r = _\n  simp\n\n"}
{"name":"MvPowerSeries.instNontrivialSubalgebraOfNonempty","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Nonempty σ\ninst✝ : Nontrivial R\n⊢ Nontrivial (Subalgebra R (MvPowerSeries σ R))","decl":"instance [Nonempty σ] [Nontrivial R] : Nontrivial (Subalgebra R (MvPowerSeries σ R)) :=\n  ⟨⟨⊥, ⊤, by\n      classical\n      rw [Ne, SetLike.ext_iff, not_forall]\n      inhabit σ\n      refine ⟨X default, ?_⟩\n      simp only [Algebra.mem_bot, not_exists, Set.mem_range, iff_true, Algebra.mem_top]\n      intro x\n      rw [MvPowerSeries.ext_iff, not_forall]\n      refine ⟨Finsupp.single default 1, ?_⟩\n      simp [algebraMap_apply, coeff_C]⟩⟩\n\n"}
{"name":"MvPolynomial.coe_def","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\n⊢ Eq ↑φ fun n => MvPolynomial.coeff n φ","decl":"theorem coe_def : (φ : MvPowerSeries σ R) = fun n => coeff n φ :=\n  rfl\n\n"}
{"name":"MvPolynomial.coeff_coe","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\nn : Finsupp σ Nat\n⊢ Eq ((MvPowerSeries.coeff R n) ↑φ) (MvPolynomial.coeff n φ)","decl":"@[simp, norm_cast]\ntheorem coeff_coe (n : σ →₀ ℕ) : MvPowerSeries.coeff R n ↑φ = coeff n φ :=\n  rfl\n\n"}
{"name":"MvPolynomial.coe_monomial","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\nn : Finsupp σ Nat\na : R\n⊢ Eq (↑((MvPolynomial.monomial n) a)) ((MvPowerSeries.monomial R n) a)","decl":"@[simp, norm_cast]\ntheorem coe_monomial (n : σ →₀ ℕ) (a : R) :\n    (monomial n a : MvPowerSeries σ R) = MvPowerSeries.monomial R n a :=\n  MvPowerSeries.ext fun m => by\n    classical\n    rw [coeff_coe, coeff_monomial, MvPowerSeries.coeff_monomial]\n    split_ifs with h₁ h₂ <;> first |rfl|subst m; contradiction\n\n"}
{"name":"MvPolynomial.coe_zero","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem coe_zero : ((0 : MvPolynomial σ R) : MvPowerSeries σ R) = 0 :=\n  rfl\n\n"}
{"name":"MvPolynomial.coe_one","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem coe_one : ((1 : MvPolynomial σ R) : MvPowerSeries σ R) = 1 :=\n    coe_monomial _ _\n\n"}
{"name":"MvPolynomial.coe_add","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\nφ ψ : MvPolynomial σ R\n⊢ Eq (↑(HAdd.hAdd φ ψ)) (HAdd.hAdd ↑φ ↑ψ)","decl":"@[simp, norm_cast]\ntheorem coe_add : ((φ + ψ : MvPolynomial σ R) : MvPowerSeries σ R) = φ + ψ :=\n  rfl\n\n"}
{"name":"MvPolynomial.coe_mul","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\nφ ψ : MvPolynomial σ R\n⊢ Eq (↑(HMul.hMul φ ψ)) (HMul.hMul ↑φ ↑ψ)","decl":"@[simp, norm_cast]\ntheorem coe_mul : ((φ * ψ : MvPolynomial σ R) : MvPowerSeries σ R) = φ * ψ :=\n  MvPowerSeries.ext fun n => by\n    classical\n    simp only [coeff_coe, MvPowerSeries.coeff_mul, coeff_mul]\n\n"}
{"name":"MvPolynomial.coe_C","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\na : R\n⊢ Eq (↑(MvPolynomial.C a)) ((MvPowerSeries.C σ R) a)","decl":"@[simp, norm_cast]\ntheorem coe_C (a : R) : ((C a : MvPolynomial σ R) : MvPowerSeries σ R) = MvPowerSeries.C σ R a :=\n  coe_monomial _ _\n\n"}
{"name":"MvPolynomial.coe_X","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\ns : σ\n⊢ Eq (↑(MvPolynomial.X s)) (MvPowerSeries.X s)","decl":"@[simp, norm_cast]\ntheorem coe_X (s : σ) : ((X s : MvPolynomial σ R) : MvPowerSeries σ R) = MvPowerSeries.X s :=\n  coe_monomial _ _\n\n"}
{"name":"MvPolynomial.coe_injective","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\n⊢ Function.Injective Coe.coe","decl":"theorem coe_injective : Function.Injective (Coe.coe : MvPolynomial σ R → MvPowerSeries σ R) :=\n    fun x y h => by\n  ext\n  simp_rw [← coeff_coe]\n  congr\n\n"}
{"name":"MvPolynomial.coe_inj","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\nφ ψ : MvPolynomial σ R\n⊢ Iff (Eq ↑φ ↑ψ) (Eq φ ψ)","decl":"@[simp, norm_cast]\ntheorem coe_inj : (φ : MvPowerSeries σ R) = ψ ↔ φ = ψ :=\n  (coe_injective σ R).eq_iff\n\n"}
{"name":"MvPolynomial.coe_eq_zero_iff","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\n⊢ Iff (Eq (↑φ) 0) (Eq φ 0)","decl":"@[simp]\ntheorem coe_eq_zero_iff : (φ : MvPowerSeries σ R) = 0 ↔ φ = 0 := by rw [← coe_zero, coe_inj]\n\n"}
{"name":"MvPolynomial.coe_eq_one_iff","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\n⊢ Iff (Eq (↑φ) 1) (Eq φ 1)","decl":"@[simp]\ntheorem coe_eq_one_iff : (φ : MvPowerSeries σ R) = 1 ↔ φ = 1 := by rw [← coe_one, coe_inj]\n\n"}
{"name":"MvPolynomial.coe_pow","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\nn : Nat\n⊢ Eq (↑(HPow.hPow φ n)) (HPow.hPow (↑φ) n)","decl":"@[simp, norm_cast]\ntheorem coe_pow (n : ℕ) :\n    ((φ ^ n : MvPolynomial σ R) : MvPowerSeries σ R) = (φ : MvPowerSeries σ R) ^ n :=\n  coeToMvPowerSeries.ringHom.map_pow _ _\n\n"}
{"name":"MvPolynomial.coeToMvPowerSeries.ringHom_apply","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\n⊢ Eq (MvPolynomial.coeToMvPowerSeries.ringHom φ) ↑φ","decl":"@[simp]\ntheorem coeToMvPowerSeries.ringHom_apply : coeToMvPowerSeries.ringHom φ = φ :=\n  rfl\n\n"}
{"name":"MvPolynomial.coeToMvPowerSeries.algHom_apply","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝² : CommSemiring R\nφ : MvPolynomial σ R\nA : Type u_3\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\n⊢ Eq ((MvPolynomial.coeToMvPowerSeries.algHom A) φ) ((MvPowerSeries.map σ (algebraMap R A)) ↑φ)","decl":"@[simp]\ntheorem coeToMvPowerSeries.algHom_apply :\n    coeToMvPowerSeries.algHom A φ = MvPowerSeries.map σ (algebraMap R A) ↑φ :=\n  rfl\n\n"}
{"name":"MvPowerSeries.algebraMap_apply'","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\nA : Type u_3\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\np : MvPolynomial σ R\n⊢ Eq ((algebraMap (MvPolynomial σ R) (MvPowerSeries σ A)) p) ((MvPowerSeries.map σ (algebraMap R A)) ↑p)","decl":"theorem algebraMap_apply' (p : MvPolynomial σ R) :\n    algebraMap (MvPolynomial σ R) (MvPowerSeries σ A) p = map σ (algebraMap R A) p :=\n  rfl\n\n"}
{"name":"MvPowerSeries.algebraMap_apply''","module":"Mathlib.RingTheory.MvPowerSeries.Basic","initialProofState":"σ : Type u_1\nR : Type u_2\nA : Type u_3\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\nf : MvPowerSeries σ R\n⊢ Eq ((algebraMap (MvPowerSeries σ R) (MvPowerSeries σ A)) f) ((MvPowerSeries.map σ (algebraMap R A)) f)","decl":"theorem algebraMap_apply'' :\n    algebraMap (MvPowerSeries σ R) (MvPowerSeries σ A) f = map σ (algebraMap R A) f :=\n  rfl\n\n"}
