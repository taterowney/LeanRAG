{"name":"Levenshtein.Cost.mk.injEq","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_4\nβ : Type u_5\nδ : Type u_6\ndelete✝ : α → δ\ninsert✝ : β → δ\nsubstitute✝ : α → β → δ\ndelete : α → δ\ninsert : β → δ\nsubstitute : α → β → δ\n⊢ Eq (Eq { delete := delete✝, insert := insert✝, substitute := substitute✝ } { delete := delete, insert := insert, substitute := substitute }) (And (Eq delete✝ delete) (And (Eq insert✝ insert) (Eq substitute✝ substitute)))","decl":"/-- A cost structure for Levenshtein edit distance. -/\nstructure Cost (α β δ : Type*) where\n  /-- Cost to delete an element from a list. -/\n  delete : α → δ\n  /-- Cost in insert an element into a list. -/\n  insert : β → δ\n  /-- Cost to substitute one element for another in a list. -/\n  substitute : α → β → δ\n\n"}
{"name":"Levenshtein.Cost.mk.inj","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_4\nβ : Type u_5\nδ : Type u_6\ndelete✝ : α → δ\ninsert✝ : β → δ\nsubstitute✝ : α → β → δ\ndelete : α → δ\ninsert : β → δ\nsubstitute : α → β → δ\nx✝ : Eq { delete := delete✝, insert := insert✝, substitute := substitute✝ } { delete := delete, insert := insert, substitute := substitute }\n⊢ And (Eq delete✝ delete) (And (Eq insert✝ insert) (Eq substitute✝ substitute))","decl":"/-- A cost structure for Levenshtein edit distance. -/\nstructure Cost (α β δ : Type*) where\n  /-- Cost to delete an element from a list. -/\n  delete : α → δ\n  /-- Cost in insert an element into a list. -/\n  insert : β → δ\n  /-- Cost to substitute one element for another in a list. -/\n  substitute : α → β → δ\n\n"}
{"name":"Levenshtein.Cost.mk.sizeOf_spec","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_4\nβ : Type u_5\nδ : Type u_6\ninst✝² : SizeOf α\ninst✝¹ : SizeOf β\ninst✝ : SizeOf δ\ndelete : α → δ\ninsert : β → δ\nsubstitute : α → β → δ\n⊢ Eq (SizeOf.sizeOf { delete := delete, insert := insert, substitute := substitute }) 1","decl":"/-- A cost structure for Levenshtein edit distance. -/\nstructure Cost (α β δ : Type*) where\n  /-- Cost to delete an element from a list. -/\n  delete : α → δ\n  /-- Cost in insert an element into a list. -/\n  insert : β → δ\n  /-- Cost to substitute one element for another in a list. -/\n  substitute : α → β → δ\n\n"}
{"name":"Levenshtein.defaultCost_substitute","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\n⊢ Eq (Levenshtein.defaultCost.substitute a b) (ite (Eq a b) 0 1)","decl":"/-- The default cost structure, for which all operations cost `1`. -/\n@[simps]\ndef defaultCost [DecidableEq α] : Cost α α ℕ where\n  delete _ := 1\n  insert _ := 1\n  substitute a b := if a = b then 0 else 1\n\n"}
{"name":"Levenshtein.defaultCost_insert","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx✝ : α\n⊢ Eq (Levenshtein.defaultCost.insert x✝) 1","decl":"/-- The default cost structure, for which all operations cost `1`. -/\n@[simps]\ndef defaultCost [DecidableEq α] : Cost α α ℕ where\n  delete _ := 1\n  insert _ := 1\n  substitute a b := if a = b then 0 else 1\n\n"}
{"name":"Levenshtein.defaultCost_delete","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx✝ : α\n⊢ Eq (Levenshtein.defaultCost.delete x✝) 1","decl":"/-- The default cost structure, for which all operations cost `1`. -/\n@[simps]\ndef defaultCost [DecidableEq α] : Cost α α ℕ where\n  delete _ := 1\n  insert _ := 1\n  substitute a b := if a = b then 0 else 1\n\n"}
{"name":"Levenshtein.weightCost_substitute","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\nf : α → Nat\na b : α\n⊢ Eq ((Levenshtein.weightCost f).substitute a b) (Max.max (f a) (f b))","decl":"/--\nCost structure given by a function.\nDelete and insert cost the same, and substitution costs the greater value.\n-/\n@[simps]\ndef weightCost (f : α → ℕ) : Cost α α ℕ where\n  delete a := f a\n  insert b := f b\n  substitute a b := max (f a) (f b)\n\n"}
{"name":"Levenshtein.weightCost_delete","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\nf : α → Nat\na : α\n⊢ Eq ((Levenshtein.weightCost f).delete a) (f a)","decl":"/--\nCost structure given by a function.\nDelete and insert cost the same, and substitution costs the greater value.\n-/\n@[simps]\ndef weightCost (f : α → ℕ) : Cost α α ℕ where\n  delete a := f a\n  insert b := f b\n  substitute a b := max (f a) (f b)\n\n"}
{"name":"Levenshtein.weightCost_insert","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\nf : α → Nat\nb : α\n⊢ Eq ((Levenshtein.weightCost f).insert b) (f b)","decl":"/--\nCost structure given by a function.\nDelete and insert cost the same, and substitution costs the greater value.\n-/\n@[simps]\ndef weightCost (f : α → ℕ) : Cost α α ℕ where\n  delete a := f a\n  insert b := f b\n  substitute a b := max (f a) (f b)\n\n"}
{"name":"Levenshtein.stringLengthCost_insert","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"b : String\n⊢ Eq (Levenshtein.stringLengthCost.insert b) b.length","decl":"/--\nCost structure for strings, where cost is the length of the token.\n-/\n@[simps!]\ndef stringLengthCost : Cost String String ℕ := weightCost String.length\n\n"}
{"name":"Levenshtein.stringLengthCost_delete","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"a : String\n⊢ Eq (Levenshtein.stringLengthCost.delete a) a.length","decl":"/--\nCost structure for strings, where cost is the length of the token.\n-/\n@[simps!]\ndef stringLengthCost : Cost String String ℕ := weightCost String.length\n\n"}
{"name":"Levenshtein.stringLengthCost_substitute","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"a b : String\n⊢ Eq (Levenshtein.stringLengthCost.substitute a b) (Max.max a.length b.length)","decl":"/--\nCost structure for strings, where cost is the length of the token.\n-/\n@[simps!]\ndef stringLengthCost : Cost String String ℕ := weightCost String.length\n\n"}
{"name":"Levenshtein.stringLogLengthCost_substitute","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"a b : String\n⊢ Eq (Levenshtein.stringLogLengthCost.substitute a b) (Max.max (HAdd.hAdd a.length 1).log2 (HAdd.hAdd b.length 1).log2)","decl":"/--\nCost structure for strings, where cost is the log base 2 length of the token.\n-/\n@[simps!]\ndef stringLogLengthCost : Cost String String ℕ := weightCost fun s => Nat.log2 (s.length + 1)\n\n"}
{"name":"Levenshtein.stringLogLengthCost_delete","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"a : String\n⊢ Eq (Levenshtein.stringLogLengthCost.delete a) (HAdd.hAdd a.length 1).log2","decl":"/--\nCost structure for strings, where cost is the log base 2 length of the token.\n-/\n@[simps!]\ndef stringLogLengthCost : Cost String String ℕ := weightCost fun s => Nat.log2 (s.length + 1)\n\n"}
{"name":"Levenshtein.stringLogLengthCost_insert","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"b : String\n⊢ Eq (Levenshtein.stringLogLengthCost.insert b) (HAdd.hAdd b.length 1).log2","decl":"/--\nCost structure for strings, where cost is the log base 2 length of the token.\n-/\n@[simps!]\ndef stringLogLengthCost : Cost String String ℕ := weightCost fun s => Nat.log2 (s.length + 1)\n\n"}
{"name":"Levenshtein.impl_cons","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\ninst✝¹ : AddZeroClass δ\ninst✝ : Min δ\nC : Levenshtein.Cost α β δ\nx : α\nxs : List α\ny : β\nd : δ\nds : List δ\nw : LT.lt 0 (List.cons d ds).length\nw' : LT.lt 0 ds.length\n⊢ Eq (Levenshtein.impl C (List.cons x xs) y ⟨List.cons d ds, w⟩) (Levenshtein.impl.match_1 (fun x => Subtype fun r => LT.lt 0 r.length) (Levenshtein.impl C xs y ⟨ds, w'⟩) fun r w => ⟨List.cons (Min.min (HAdd.hAdd (C.delete x) (GetElem.getElem r 0 ⋯)) (Min.min (HAdd.hAdd (C.insert y) d) (HAdd.hAdd (C.substitute x y) (GetElem.getElem ds 0 ⋯)))) r, ⋯⟩)","decl":"theorem impl_cons (w' : 0 < List.length ds) :\n    impl C (x :: xs) y ⟨d :: ds, w⟩ =\n      let ⟨r, w⟩ := impl C xs y ⟨ds, w'⟩\n      ⟨min (C.delete x + r[0]) (min (C.insert y + d) (C.substitute x y + ds[0])) :: r, by simp⟩ :=\n  match ds, w' with | _ :: _, _ => rfl\n\n-- Note this lemma has two unspecified proofs: `h` appears on the left-hand-side\n-- and should be found by matching, but `w'` will become an extra goal when rewriting.\n"}
{"name":"Levenshtein.impl_cons_fst_zero","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\ninst✝¹ : AddZeroClass δ\ninst✝ : Min δ\nC : Levenshtein.Cost α β δ\nx : α\nxs : List α\ny : β\nd : δ\nds : List δ\nw : LT.lt 0 (List.cons d ds).length\nh : LT.lt 0 (Levenshtein.impl C (List.cons x xs) y ⟨List.cons d ds, w⟩).val.length\nw' : LT.lt 0 ds.length\n⊢ Eq (GetElem.getElem (Levenshtein.impl C (List.cons x xs) y ⟨List.cons d ds, w⟩).val 0 ⋯) (Levenshtein.impl.match_1 (fun x => δ) (Levenshtein.impl C xs y ⟨ds, w'⟩) fun r w => Min.min (HAdd.hAdd (C.delete x) (GetElem.getElem r 0 ⋯)) (Min.min (HAdd.hAdd (C.insert y) d) (HAdd.hAdd (C.substitute x y) (GetElem.getElem ds 0 ⋯))))","decl":"theorem impl_cons_fst_zero (h : 0 < (impl C (x :: xs) y ⟨d :: ds, w⟩).val.length)\n    (w' : 0 < List.length ds) : (impl C (x :: xs) y ⟨d :: ds, w⟩).1[0] =\n      let ⟨r, w⟩ := impl C xs y ⟨ds, w'⟩\n      min (C.delete x + r[0]) (min (C.insert y + d) (C.substitute x y + ds[0])) :=\n  match ds, w' with | _ :: _, _ => rfl\n\n"}
{"name":"Levenshtein.impl_length","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\ninst✝¹ : AddZeroClass δ\ninst✝ : Min δ\nC : Levenshtein.Cost α β δ\nxs : List α\ny : β\nd : Subtype fun r => LT.lt 0 r.length\nw : Eq d.val.length (HAdd.hAdd xs.length 1)\n⊢ Eq (Levenshtein.impl C xs y d).val.length (HAdd.hAdd xs.length 1)","decl":"theorem impl_length (d : {r : List δ // 0 < r.length}) (w : d.1.length = xs.length + 1) :\n    (impl C xs y d).1.length = xs.length + 1 := by\n  induction xs generalizing d with\n  | nil => rfl\n  | cons x xs ih =>\n    dsimp [impl]\n    match d, w with\n    | ⟨d₁ :: d₂ :: ds, _⟩, w =>\n      dsimp\n      congr 1\n      exact ih ⟨d₂ :: ds, (by simp)⟩ (by simpa using w)\n\n"}
{"name":"suffixLevenshtein_length","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\ninst✝¹ : AddZeroClass δ\ninst✝ : Min δ\nC : Levenshtein.Cost α β δ\nxs : List α\nys : List β\n⊢ Eq (suffixLevenshtein C xs ys).val.length (HAdd.hAdd xs.length 1)","decl":"theorem suffixLevenshtein_length (xs : List α) (ys : List β) :\n    (suffixLevenshtein C xs ys).1.length = xs.length + 1 := by\n  induction ys with\n  | nil =>\n    dsimp [suffixLevenshtein]\n    induction xs with\n    | nil => rfl\n    | cons _ xs ih =>\n      simp_all\n  | cons y ys ih =>\n    dsimp [suffixLevenshtein]\n    rw [impl_length]\n    exact ih\n\n-- This is only used in keeping track of estimates.\n"}
{"name":"suffixLevenshtein_eq","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\ninst✝¹ : AddZeroClass δ\ninst✝ : Min δ\nC : Levenshtein.Cost α β δ\nxs : List α\ny : β\nys : List β\n⊢ Eq (Levenshtein.impl C xs y (suffixLevenshtein C xs ys)) (suffixLevenshtein C xs (List.cons y ys))","decl":"theorem suffixLevenshtein_eq (xs : List α) (y ys) :\n    impl C xs y (suffixLevenshtein C xs ys) = suffixLevenshtein C xs (y :: ys) := by\n  rfl\n\n"}
{"name":"suffixLevenshtein_nil_nil","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\ninst✝¹ : AddZeroClass δ\ninst✝ : Min δ\nC : Levenshtein.Cost α β δ\n⊢ Eq (suffixLevenshtein C List.nil List.nil).val (List.cons 0 List.nil)","decl":"theorem suffixLevenshtein_nil_nil : (suffixLevenshtein C [] []).1 = [0] := by\n  rfl\n\n-- Not sure if this belongs in the main `List` API, or can stay local.\n"}
{"name":"List.eq_of_length_one","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\nx : List α\nw : Eq x.length 1\n⊢ letFun ⋯ fun this => Eq x (List.cons (GetElem.getElem x 0 ⋯) List.nil)","decl":"theorem List.eq_of_length_one (x : List α) (w : x.length = 1) :\n    have : 0 < x.length := lt_of_lt_of_eq Nat.zero_lt_one w.symm\n    x = [x[0]] := by\n  match x, w with\n  | [r], _ => rfl\n\n"}
{"name":"suffixLevenshtein_nil'","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\ninst✝¹ : AddZeroClass δ\ninst✝ : Min δ\nC : Levenshtein.Cost α β δ\nys : List β\n⊢ Eq (suffixLevenshtein C List.nil ys).val (List.cons (levenshtein C List.nil ys) List.nil)","decl":"theorem suffixLevenshtein_nil' (ys : List β) :\n    (suffixLevenshtein C [] ys).1 = [levenshtein C [] ys] :=\n  List.eq_of_length_one _ (suffixLevenshtein_length [] _)\n\n"}
{"name":"suffixLevenshtein_cons₂","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\ninst✝¹ : AddZeroClass δ\ninst✝ : Min δ\nC : Levenshtein.Cost α β δ\nxs : List α\ny : β\nys : List β\n⊢ Eq (suffixLevenshtein C xs (List.cons y ys)) (Levenshtein.impl C xs y (suffixLevenshtein C xs ys))","decl":"theorem suffixLevenshtein_cons₂ (xs : List α) (y ys) :\n    suffixLevenshtein C xs (y :: ys) = (impl C xs) y (suffixLevenshtein C xs ys) :=\n  rfl\n\n"}
{"name":"suffixLevenshtein_cons₁_aux","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_4\nx y : Subtype fun l => LT.lt 0 l.length\nw₀ : Eq (GetElem.getElem x.val 0 ⋯) (GetElem.getElem y.val 0 ⋯)\nw : Eq x.val.tail y.val.tail\n⊢ Eq x y","decl":"theorem suffixLevenshtein_cons₁_aux {α} {x y : { l : List α // 0 < l.length }}\n    (w₀ : x.1[0]'x.2 = y.1[0]'y.2) (w : x.1.tail = y.1.tail) : x = y := by\n  match x, y with\n  | ⟨hx :: tx, _⟩, ⟨hy :: ty, _⟩ => simp_all\n\n"}
{"name":"suffixLevenshtein_cons₁","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\ninst✝¹ : AddZeroClass δ\ninst✝ : Min δ\nC : Levenshtein.Cost α β δ\nx : α\nxs : List α\nys : List β\n⊢ Eq (suffixLevenshtein C (List.cons x xs) ys) ⟨List.cons (levenshtein C (List.cons x xs) ys) (suffixLevenshtein C xs ys).val, ⋯⟩","decl":"theorem suffixLevenshtein_cons₁\n    (x : α) (xs ys) :\n    suffixLevenshtein C (x :: xs) ys =\n      ⟨levenshtein C (x :: xs) ys ::\n        (suffixLevenshtein C xs ys).1, by simp⟩ := by\n  induction ys with\n  | nil =>\n    dsimp [levenshtein, suffixLevenshtein]\n  | cons y ys ih =>\n    apply suffixLevenshtein_cons₁_aux\n    · rfl\n    · rw [suffixLevenshtein_cons₂ (x :: xs), ih, impl_cons]\n      · rfl\n      · simp [suffixLevenshtein_length]\n\n"}
{"name":"suffixLevenshtein_cons₁_fst","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\ninst✝¹ : AddZeroClass δ\ninst✝ : Min δ\nC : Levenshtein.Cost α β δ\nx : α\nxs : List α\nys : List β\n⊢ Eq (suffixLevenshtein C (List.cons x xs) ys).val (List.cons (levenshtein C (List.cons x xs) ys) (suffixLevenshtein C xs ys).val)","decl":"theorem suffixLevenshtein_cons₁_fst (x : α) (xs ys) :\n    (suffixLevenshtein C (x :: xs) ys).1 =\n      levenshtein C (x :: xs) ys ::\n        (suffixLevenshtein C xs ys).1 := by\n  simp [suffixLevenshtein_cons₁]\n\n"}
{"name":"suffixLevenshtein_cons_cons_fst_get_zero","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\ninst✝¹ : AddZeroClass δ\ninst✝ : Min δ\nC : Levenshtein.Cost α β δ\nx : α\nxs : List α\ny : β\nys : List β\nw : LT.lt 0 (suffixLevenshtein C (List.cons x xs) (List.cons y ys)).val.length\n⊢ Eq (GetElem.getElem (suffixLevenshtein C (List.cons x xs) (List.cons y ys)).val 0 w) (Levenshtein.impl.match_1 (fun x => δ) (suffixLevenshtein C xs (List.cons y ys)) fun dx property => Levenshtein.impl.match_1 (fun x => δ) (suffixLevenshtein C (List.cons x xs) ys) fun dy property => Levenshtein.impl.match_1 (fun x => δ) (suffixLevenshtein C xs ys) fun dxy property => Min.min (HAdd.hAdd (C.delete x) (GetElem.getElem dx 0 ⋯)) (Min.min (HAdd.hAdd (C.insert y) (GetElem.getElem dy 0 ⋯)) (HAdd.hAdd (C.substitute x y) (GetElem.getElem dxy 0 ⋯))))","decl":"theorem suffixLevenshtein_cons_cons_fst_get_zero\n    (x : α) (xs y ys) (w : 0 < (suffixLevenshtein C (x :: xs) (y :: ys)).val.length) :\n    (suffixLevenshtein C (x :: xs) (y :: ys)).1[0]'w =\n      let ⟨dx, _⟩ := suffixLevenshtein C xs (y :: ys)\n      let ⟨dy, _⟩ := suffixLevenshtein C (x :: xs) ys\n      let ⟨dxy, _⟩ := suffixLevenshtein C xs ys\n      min\n        (C.delete x + dx[0])\n        (min\n          (C.insert y + dy[0])\n          (C.substitute x y + dxy[0])) := by\n  conv =>\n    lhs\n    dsimp only [suffixLevenshtein_cons₂]\n  simp only [suffixLevenshtein_cons₁]\n  rw [impl_cons_fst_zero]\n  rfl\n\n"}
{"name":"suffixLevenshtein_eq_tails_map","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\ninst✝¹ : AddZeroClass δ\ninst✝ : Min δ\nC : Levenshtein.Cost α β δ\nxs : List α\nys : List β\n⊢ Eq (suffixLevenshtein C xs ys).val (List.map (fun xs' => levenshtein C xs' ys) xs.tails)","decl":"theorem suffixLevenshtein_eq_tails_map (xs ys) :\n    (suffixLevenshtein C xs ys).1 = xs.tails.map fun xs' => levenshtein C xs' ys := by\n  induction xs with\n  | nil =>\n    simp only [suffixLevenshtein_nil', List.tails, List.map_cons, List.map]\n  | cons x xs ih =>\n    simp only [suffixLevenshtein_cons₁, ih, List.tails, List.map_cons]\n\n"}
{"name":"levenshtein_nil_nil","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\ninst✝¹ : AddZeroClass δ\ninst✝ : Min δ\nC : Levenshtein.Cost α β δ\n⊢ Eq (levenshtein C List.nil List.nil) 0","decl":"@[simp]\ntheorem levenshtein_nil_nil : levenshtein C [] [] = 0 := by\n  simp [levenshtein, suffixLevenshtein]\n\n"}
{"name":"levenshtein_nil_cons","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\ninst✝¹ : AddZeroClass δ\ninst✝ : Min δ\nC : Levenshtein.Cost α β δ\ny : β\nys : List β\n⊢ Eq (levenshtein C List.nil (List.cons y ys)) (HAdd.hAdd (C.insert y) (levenshtein C List.nil ys))","decl":"@[simp]\ntheorem levenshtein_nil_cons (y) (ys) :\n    levenshtein C [] (y :: ys) = C.insert y + levenshtein C [] ys := by\n  dsimp (config := { unfoldPartialApp := true }) [levenshtein, suffixLevenshtein, impl]\n  congr\n  rw [List.getLast_eq_getElem]\n  congr\n  rw [show (List.length _) = 1 from _]\n  induction ys <;> simp\n\n"}
{"name":"levenshtein_cons_nil","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\ninst✝¹ : AddZeroClass δ\ninst✝ : Min δ\nC : Levenshtein.Cost α β δ\nx : α\nxs : List α\n⊢ Eq (levenshtein C (List.cons x xs) List.nil) (HAdd.hAdd (C.delete x) (levenshtein C xs List.nil))","decl":"@[simp]\ntheorem levenshtein_cons_nil (x : α) (xs : List α) :\n    levenshtein C (x :: xs) [] = C.delete x + levenshtein C xs [] :=\n  rfl\n\n"}
{"name":"levenshtein_cons_cons","module":"Mathlib.Data.List.EditDistance.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_3\ninst✝¹ : AddZeroClass δ\ninst✝ : Min δ\nC : Levenshtein.Cost α β δ\nx : α\nxs : List α\ny : β\nys : List β\n⊢ Eq (levenshtein C (List.cons x xs) (List.cons y ys)) (Min.min (HAdd.hAdd (C.delete x) (levenshtein C xs (List.cons y ys))) (Min.min (HAdd.hAdd (C.insert y) (levenshtein C (List.cons x xs) ys)) (HAdd.hAdd (C.substitute x y) (levenshtein C xs ys))))","decl":"@[simp]\ntheorem levenshtein_cons_cons\n    (x : α) (xs : List α) (y : β) (ys : List β) :\n    levenshtein C (x :: xs) (y :: ys) =\n      min (C.delete x + levenshtein C xs (y :: ys))\n        (min (C.insert y + levenshtein C (x :: xs) ys)\n          (C.substitute x y + levenshtein C xs ys)) :=\n  suffixLevenshtein_cons_cons_fst_get_zero ..\n"}
