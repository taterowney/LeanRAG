{"name":"AlgebraicGeometry.surjectiveOnStalks_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n‚ä¢ Iff (AlgebraicGeometry.SurjectiveOnStalks f) (‚àÄ (x : ‚Üë‚ÜëX.toPresheafedSpace), Function.Surjective ‚áë(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.stalkMap f x)))","decl":"/-- The class of morphisms `f : X ‚ü∂ Y` between schemes such that\n`ùí™_{Y, f x} ‚ü∂ ùí™_{X, x}` is surjective for all `x : X`. -/\n@[mk_iff]\nclass SurjectiveOnStalks : Prop where\n  surj_on_stalks : ‚àÄ x, Function.Surjective (f.stalkMap x)\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.surj_on_stalks","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nself : AlgebraicGeometry.SurjectiveOnStalks f\nx : ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ Function.Surjective ‚áë(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.stalkMap f x))","decl":"/-- The class of morphisms `f : X ‚ü∂ Y` between schemes such that\n`ùí™_{Y, f x} ‚ü∂ ùí™_{X, x}` is surjective for all `x : X`. -/\n@[mk_iff]\nclass SurjectiveOnStalks : Prop where\n  surj_on_stalks : ‚àÄ x, Function.Surjective (f.stalkMap x)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.stalkMap_surjective","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\ninst‚úù : AlgebraicGeometry.SurjectiveOnStalks f\nx : ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ Function.Surjective ‚áë(CategoryTheory.ConcreteCategory.hom (f.stalkMap x))","decl":"theorem Scheme.Hom.stalkMap_surjective (f : X.Hom Y) [SurjectiveOnStalks f] (x) :\n    Function.Surjective (f.stalkMap x) :=\n  SurjectiveOnStalks.surj_on_stalks x\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.instOfIsOpenImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : AlgebraicGeometry.IsOpenImmersion f\n‚ä¢ AlgebraicGeometry.SurjectiveOnStalks f","decl":"instance (priority := 900) [IsOpenImmersion f] : SurjectiveOnStalks f :=\n  ‚ü®fun _ ‚Ü¶ (ConcreteCategory.bijective_of_isIso _).2‚ü©\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.instIsMultiplicativeScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"‚ä¢ CategoryTheory.MorphismProperty.IsMultiplicative @AlgebraicGeometry.SurjectiveOnStalks","decl":"instance : MorphismProperty.IsMultiplicative @SurjectiveOnStalks where\n  id_mem _ := inferInstance\n  comp_mem {X Y Z} f g hf hg := by\n    refine ‚ü®fun x ‚Ü¶ ?_‚ü©\n    rw [Scheme.stalkMap_comp]\n    exact (hf.surj_on_stalks x).comp (hg.surj_on_stalks (f.base x))\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.comp","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : AlgebraicGeometry.SurjectiveOnStalks f\ninst‚úù : AlgebraicGeometry.SurjectiveOnStalks g\n‚ä¢ AlgebraicGeometry.SurjectiveOnStalks (CategoryTheory.CategoryStruct.comp f g)","decl":"instance comp {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [SurjectiveOnStalks f]\n    [SurjectiveOnStalks g] : SurjectiveOnStalks (f ‚â´ g) :=\n  MorphismProperty.IsStableUnderComposition.comp_mem f g inferInstance inferInstance\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.eq_stalkwise","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"‚ä¢ Eq (@AlgebraicGeometry.SurjectiveOnStalks) (AlgebraicGeometry.stalkwise fun {R S} [CommRing R] [CommRing S] x => Function.Surjective ‚áëx)","decl":"lemma eq_stalkwise :\n    @SurjectiveOnStalks = stalkwise (Function.Surjective ¬∑) := by\n  ext; exact surjectiveOnStalks_iff _\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.instIsLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"‚ä¢ AlgebraicGeometry.IsLocalAtTarget @AlgebraicGeometry.SurjectiveOnStalks","decl":"instance : IsLocalAtTarget @SurjectiveOnStalks :=\n  eq_stalkwise ‚ñ∏ stalkwiseIsLocalAtTarget_of_respectsIso RingHom.surjective_respectsIso\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.instIsLocalAtSource","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"‚ä¢ AlgebraicGeometry.IsLocalAtSource @AlgebraicGeometry.SurjectiveOnStalks","decl":"instance : IsLocalAtSource @SurjectiveOnStalks :=\n  eq_stalkwise ‚ñ∏ stalkwise_isLocalAtSource_of_respectsIso RingHom.surjective_respectsIso\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.Spec_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"R S : CommRingCat\nœÜ : Quiver.Hom R S\n‚ä¢ Iff (AlgebraicGeometry.SurjectiveOnStalks (AlgebraicGeometry.Spec.map œÜ)) (CommRingCat.Hom.hom œÜ).SurjectiveOnStalks","decl":"lemma Spec_iff {R S : CommRingCat.{u}} {œÜ : R ‚ü∂ S} :\n    SurjectiveOnStalks (Spec.map œÜ) ‚Üî RingHom.SurjectiveOnStalks œÜ.hom := by\n  rw [eq_stalkwise, stalkwise_Spec_map_iff RingHom.surjective_respectsIso,\n    RingHom.SurjectiveOnStalks]\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.instHasRingHomPropertySurjectiveOnStalks","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"‚ä¢ AlgebraicGeometry.HasRingHomProperty @AlgebraicGeometry.SurjectiveOnStalks fun {R S} [CommRing R] [CommRing S] => RingHom.SurjectiveOnStalks","decl":"instance : HasRingHomProperty @SurjectiveOnStalks RingHom.SurjectiveOnStalks :=\n  eq_stalkwise ‚ñ∏ .stalkwise RingHom.surjective_respectsIso\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.iff_of_isAffine","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù¬π : AlgebraicGeometry.IsAffine X\ninst‚úù : AlgebraicGeometry.IsAffine Y\n‚ä¢ Iff (AlgebraicGeometry.SurjectiveOnStalks f) (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.app f Top.top)).SurjectiveOnStalks","decl":"variable {f} in\nlemma iff_of_isAffine [IsAffine X] [IsAffine Y] :\n    SurjectiveOnStalks f ‚Üî RingHom.SurjectiveOnStalks (f.app ‚ä§).hom := by\n  rw [‚Üê Spec_iff, MorphismProperty.arrow_mk_iso_iff @SurjectiveOnStalks (arrowIsoSpecŒìOfIsAffine f)]\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.of_comp","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù : AlgebraicGeometry.SurjectiveOnStalks (CategoryTheory.CategoryStruct.comp f g)\n‚ä¢ AlgebraicGeometry.SurjectiveOnStalks f","decl":"theorem of_comp [SurjectiveOnStalks (f ‚â´ g)] : SurjectiveOnStalks f := by\n  refine ‚ü®fun x ‚Ü¶ ?_‚ü©\n  have := (f ‚â´ g).stalkMap_surjective x\n  rw [Scheme.stalkMap_comp] at this\n  exact Function.Surjective.of_comp this\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.stableUnderBaseChange","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"‚ä¢ CategoryTheory.MorphismProperty.IsStableUnderBaseChange @AlgebraicGeometry.SurjectiveOnStalks","decl":"instance stableUnderBaseChange :\n    MorphismProperty.IsStableUnderBaseChange @SurjectiveOnStalks := by\n  apply HasRingHomProperty.isStableUnderBaseChange\n  apply RingHom.IsStableUnderBaseChange.mk\n  ¬∑ exact (HasRingHomProperty.isLocal_ringHomProperty @SurjectiveOnStalks).respectsIso\n  intros R S T _ _ _ _ _ H\n  exact H.baseChange\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.isEmbedding_pullback","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\ninst‚úù : AlgebraicGeometry.SurjectiveOnStalks g\n‚ä¢ Topology.IsEmbedding fun x => { fst := (CategoryTheory.Limits.pullback.fst f g).base x, snd := (CategoryTheory.Limits.pullback.snd f g).base x }","decl":"/-- If `Y ‚ü∂ S` is surjective on stalks, then for every `X ‚ü∂ S`, `X √ó‚Çõ Y` is a subset of\n`X √ó Y` (cartesian product as topological spaces) with the induced topology. -/\nlemma isEmbedding_pullback {X Y S : Scheme.{u}} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) [SurjectiveOnStalks g] :\n    IsEmbedding (fun x ‚Ü¶ ((pullback.fst f g).base x, (pullback.snd f g).base x)) := by\n  let L := (fun x ‚Ü¶ ((pullback.fst f g).base x, (pullback.snd f g).base x))\n  have H : ‚àÄ R A B (f' : Spec A ‚ü∂ Spec R) (g' : Spec B ‚ü∂ Spec R) (iX : Spec A ‚ü∂ X)\n      (iY : Spec B ‚ü∂ Y) (iS : Spec R ‚ü∂ S) (e‚ÇÅ e‚ÇÇ), IsOpenImmersion iX ‚Üí IsOpenImmersion iY ‚Üí\n      IsOpenImmersion iS ‚Üí IsEmbedding (L ‚àò (pullback.map f' g' f g iX iY iS e‚ÇÅ e‚ÇÇ).base) := by\n    intro R A B f' g' iX iY iS e‚ÇÅ e‚ÇÇ _ _ _\n    have H : SurjectiveOnStalks g' :=\n      have : SurjectiveOnStalks (g' ‚â´ iS) := e‚ÇÇ ‚ñ∏ inferInstance\n      .of_comp _ iS\n    obtain ‚ü®œÜ, rfl‚ü© : ‚àÉ œÜ, Spec.map œÜ = f' := ‚ü®_, Spec.map_preimage _‚ü©\n    obtain ‚ü®œà, rfl‚ü© : ‚àÉ œà, Spec.map œà = g' := ‚ü®_, Spec.map_preimage _‚ü©\n    algebraize [œÜ.hom, œà.hom]\n    rw [HasRingHomProperty.Spec_iff (P := @SurjectiveOnStalks)] at H\n    convert ((iX.isOpenEmbedding.prodMap iY.isOpenEmbedding).isEmbedding.comp\n      (PrimeSpectrum.isEmbedding_tensorProductTo_of_surjectiveOnStalks R A B H)).comp\n      (Scheme.homeoOfIso (pullbackSpecIso R A B)).isEmbedding\n    ext1 x\n    obtain ‚ü®x, rfl‚ü© := (Scheme.homeoOfIso (pullbackSpecIso R A B).symm).surjective x\n    simp only [Scheme.homeoOfIso_apply, Function.comp_apply]\n    ext\n    ¬∑ simp only [L, ‚Üê Scheme.comp_base_apply, pullback.lift_fst, Iso.symm_hom,\n        Iso.inv_hom_id]\n      erw [‚Üê Scheme.comp_base_apply, pullbackSpecIso_inv_fst_assoc]\n      rfl\n    ¬∑ simp only [L, ‚Üê Scheme.comp_base_apply, pullback.lift_snd, Iso.symm_hom,\n        Iso.inv_hom_id]\n      erw [‚Üê Scheme.comp_base_apply, pullbackSpecIso_inv_snd_assoc]\n      rfl\n  let ùí∞ := S.affineOpenCover.openCover\n  let ùí± (i) := ((ùí∞.pullbackCover f).obj i).affineOpenCover.openCover\n  let ùí≤ (i) := ((ùí∞.pullbackCover g).obj i).affineOpenCover.openCover\n  let U (ijk : Œ£ i, (ùí± i).J √ó (ùí≤ i).J) : TopologicalSpace.Opens (X.carrier √ó Y) :=\n    ‚ü®{ P | P.1 ‚àà ((ùí± ijk.1).map ijk.2.1 ‚â´ (ùí∞.pullbackCover f).map ijk.1).opensRange ‚àß\n          P.2 ‚àà ((ùí≤ ijk.1).map ijk.2.2 ‚â´ (ùí∞.pullbackCover g).map ijk.1).opensRange },\n      (continuous_fst.1 _ ((ùí± ijk.1).map ijk.2.1 ‚â´\n      (ùí∞.pullbackCover f).map ijk.1).opensRange.2).inter (continuous_snd.1 _\n      ((ùí≤ ijk.1).map ijk.2.2 ‚â´ (ùí∞.pullbackCover g).map ijk.1).opensRange.2)‚ü©\n  have : Set.range L ‚äÜ (iSup U :) := by\n    simp only [Scheme.Cover.pullbackCover_J, Scheme.Cover.pullbackCover_obj, Set.range_subset_iff]\n    intro z\n    simp only [SetLike.mem_coe, TopologicalSpace.Opens.mem_iSup, Sigma.exists, Prod.exists]\n    obtain ‚ü®is, s, hsx‚ü© := ùí∞.exists_eq (f.base ((pullback.fst f g).base z))\n    have hsy : (ùí∞.map is).base s = g.base ((pullback.snd f g).base z) := by\n      rwa [‚Üê Scheme.comp_base_apply, ‚Üê pullback.condition, Scheme.comp_base_apply]\n    obtain ‚ü®x : (ùí∞.pullbackCover f).obj is, hx‚ü© :=\n      Scheme.IsJointlySurjectivePreserving.exists_preimage_fst_triplet_of_prop\n        (P := @IsOpenImmersion) inferInstance _ _ hsx.symm\n    obtain ‚ü®y : (ùí∞.pullbackCover g).obj is, hy‚ü© :=\n      Scheme.IsJointlySurjectivePreserving.exists_preimage_fst_triplet_of_prop\n        (P := @IsOpenImmersion) inferInstance _ _ hsy.symm\n    obtain ‚ü®ix, x, rfl‚ü© := (ùí± is).exists_eq x\n    obtain ‚ü®iy, y, rfl‚ü© := (ùí≤ is).exists_eq y\n    refine ‚ü®is, ix, iy, ‚ü®x, hx‚ü©, ‚ü®y, hy‚ü©‚ü©\n  let ùì§ := (Scheme.Pullback.openCoverOfBase ùí∞ f g).bind\n    (fun i ‚Ü¶ Scheme.Pullback.openCoverOfLeftRight (ùí± i) (ùí≤ i) _ _)\n  refine isEmbedding_of_iSup_eq_top_of_preimage_subset_range _ ?_ U this _ (fun i ‚Ü¶ (ùì§.map i).base)\n    (fun i ‚Ü¶ (ùì§.map i).continuous) ?_ ?_\n  ¬∑ fun_prop\n  ¬∑ rintro i x ‚ü®‚ü®x‚ÇÅ, hx‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, hx‚ÇÇ‚ü©‚ü©\n    obtain ‚ü®x‚ÇÅ', hx‚ÇÅ'‚ü© :=\n      Scheme.IsJointlySurjectivePreserving.exists_preimage_fst_triplet_of_prop\n        (P := @IsOpenImmersion) inferInstance _ _ hx‚ÇÅ.symm\n    obtain ‚ü®x‚ÇÇ', hx‚ÇÇ'‚ü© :=\n      Scheme.IsJointlySurjectivePreserving.exists_preimage_fst_triplet_of_prop\n        (P := @IsOpenImmersion) inferInstance _ _ hx‚ÇÇ.symm\n    obtain ‚ü®z, hz‚ü© :=\n      Scheme.IsJointlySurjectivePreserving.exists_preimage_fst_triplet_of_prop\n        (P := @IsOpenImmersion) inferInstance _ _ (hx‚ÇÅ'.trans hx‚ÇÇ'.symm)\n    refine ‚ü®(pullbackFstFstIso _ _ _ _ _ _ (ùí∞.map i.1) ?_ ?_).hom.base z, ?_‚ü©\n    ¬∑ simp [pullback.condition]\n    ¬∑ simp [pullback.condition]\n    ¬∑ dsimp only\n      rw [‚Üê hx‚ÇÅ', ‚Üê hz, ‚Üê Scheme.comp_base_apply]\n      erw [‚Üê Scheme.comp_base_apply]\n      congr 4\n      apply pullback.hom_ext <;> simp [ùì§, ‚Üê pullback.condition, ‚Üê pullback.condition_assoc]\n  ¬∑ intro i\n    have := H (S.affineOpenCover.obj i.1) (((ùí∞.pullbackCover f).obj i.1).affineOpenCover.obj i.2.1)\n        (((ùí∞.pullbackCover g).obj i.1).affineOpenCover.obj i.2.2)\n        ((ùí± i.1).map i.2.1 ‚â´ ùí∞.pullbackHom f i.1)\n        ((ùí≤ i.1).map i.2.2 ‚â´ ùí∞.pullbackHom g i.1)\n        ((ùí± i.1).map i.2.1 ‚â´ (ùí∞.pullbackCover f).map i.1)\n        ((ùí≤ i.1).map i.2.2 ‚â´ (ùí∞.pullbackCover g).map i.1)\n        (ùí∞.map i.1) (by simp [pullback.condition]) (by simp [pullback.condition])\n        inferInstance inferInstance inferInstance\n    convert this using 6\n    apply pullback.hom_ext <;>\n      simp [ùì§, ‚Üê pullback.condition, ‚Üê pullback.condition_assoc,\n        Scheme.Cover.pullbackHom]\n\n"}
