{"name":"AlgebraicGeometry.surjectiveOnStalks_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nâŠ¢ Iff (AlgebraicGeometry.SurjectiveOnStalks f) (âˆ€ (x : â†‘â†‘X.toPresheafedSpace), Function.Surjective â‡‘(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.stalkMap f x)))","decl":"/-- The class of morphisms `f : X âŸ¶ Y` between schemes such that\n`ğ’ª_{Y, f x} âŸ¶ ğ’ª_{X, x}` is surjective for all `x : X`. -/\n@[mk_iff]\nclass SurjectiveOnStalks : Prop where\n  surj_on_stalks : âˆ€ x, Function.Surjective (f.stalkMap x)\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.surj_on_stalks","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nself : AlgebraicGeometry.SurjectiveOnStalks f\nx : â†‘â†‘X.toPresheafedSpace\nâŠ¢ Function.Surjective â‡‘(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.stalkMap f x))","decl":"/-- The class of morphisms `f : X âŸ¶ Y` between schemes such that\n`ğ’ª_{Y, f x} âŸ¶ ğ’ª_{X, x}` is surjective for all `x : X`. -/\n@[mk_iff]\nclass SurjectiveOnStalks : Prop where\n  surj_on_stalks : âˆ€ x, Function.Surjective (f.stalkMap x)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.stalkMap_surjective","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\ninstâœ : AlgebraicGeometry.SurjectiveOnStalks f\nx : â†‘â†‘X.toPresheafedSpace\nâŠ¢ Function.Surjective â‡‘(CategoryTheory.ConcreteCategory.hom (f.stalkMap x))","decl":"theorem Scheme.Hom.stalkMap_surjective (f : X.Hom Y) [SurjectiveOnStalks f] (x) :\n    Function.Surjective (f.stalkMap x) :=\n  SurjectiveOnStalks.surj_on_stalks x\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.instOfIsOpenImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninstâœ : AlgebraicGeometry.IsOpenImmersion f\nâŠ¢ AlgebraicGeometry.SurjectiveOnStalks f","decl":"instance (priority := 900) [IsOpenImmersion f] : SurjectiveOnStalks f :=\n  âŸ¨fun _ â†¦ (ConcreteCategory.bijective_of_isIso _).2âŸ©\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.instIsMultiplicativeScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"âŠ¢ CategoryTheory.MorphismProperty.IsMultiplicative @AlgebraicGeometry.SurjectiveOnStalks","decl":"instance : MorphismProperty.IsMultiplicative @SurjectiveOnStalks where\n  id_mem _ := inferInstance\n  comp_mem {X Y Z} f g hf hg := by\n    refine âŸ¨fun x â†¦ ?_âŸ©\n    rw [Scheme.stalkMap_comp]\n    exact (hf.surj_on_stalks x).comp (hg.surj_on_stalks (f.base x))\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.comp","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœÂ¹ : AlgebraicGeometry.SurjectiveOnStalks f\ninstâœ : AlgebraicGeometry.SurjectiveOnStalks g\nâŠ¢ AlgebraicGeometry.SurjectiveOnStalks (CategoryTheory.CategoryStruct.comp f g)","decl":"instance comp {X Y Z : Scheme} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [SurjectiveOnStalks f]\n    [SurjectiveOnStalks g] : SurjectiveOnStalks (f â‰« g) :=\n  MorphismProperty.IsStableUnderComposition.comp_mem f g inferInstance inferInstance\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.eq_stalkwise","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"âŠ¢ Eq (@AlgebraicGeometry.SurjectiveOnStalks) (AlgebraicGeometry.stalkwise fun {R S} [CommRing R] [CommRing S] x => Function.Surjective â‡‘x)","decl":"lemma eq_stalkwise :\n    @SurjectiveOnStalks = stalkwise (Function.Surjective Â·) := by\n  ext; exact surjectiveOnStalks_iff _\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.instIsLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"âŠ¢ AlgebraicGeometry.IsLocalAtTarget @AlgebraicGeometry.SurjectiveOnStalks","decl":"instance : IsLocalAtTarget @SurjectiveOnStalks :=\n  eq_stalkwise â–¸ stalkwiseIsLocalAtTarget_of_respectsIso RingHom.surjective_respectsIso\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.instIsLocalAtSource","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"âŠ¢ AlgebraicGeometry.IsLocalAtSource @AlgebraicGeometry.SurjectiveOnStalks","decl":"instance : IsLocalAtSource @SurjectiveOnStalks :=\n  eq_stalkwise â–¸ stalkwise_isLocalAtSource_of_respectsIso RingHom.surjective_respectsIso\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.Spec_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"R S : CommRingCat\nÏ† : Quiver.Hom R S\nâŠ¢ Iff (AlgebraicGeometry.SurjectiveOnStalks (AlgebraicGeometry.Spec.map Ï†)) (CommRingCat.Hom.hom Ï†).SurjectiveOnStalks","decl":"lemma Spec_iff {R S : CommRingCat.{u}} {Ï† : R âŸ¶ S} :\n    SurjectiveOnStalks (Spec.map Ï†) â†” RingHom.SurjectiveOnStalks Ï†.hom := by\n  rw [eq_stalkwise, stalkwise_Spec_map_iff RingHom.surjective_respectsIso,\n    RingHom.SurjectiveOnStalks]\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.instHasRingHomPropertySurjectiveOnStalks","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"âŠ¢ AlgebraicGeometry.HasRingHomProperty @AlgebraicGeometry.SurjectiveOnStalks fun {R S} [CommRing R] [CommRing S] => RingHom.SurjectiveOnStalks","decl":"instance : HasRingHomProperty @SurjectiveOnStalks RingHom.SurjectiveOnStalks :=\n  eq_stalkwise â–¸ .stalkwise RingHom.surjective_respectsIso\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.iff_of_isAffine","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninstâœÂ¹ : AlgebraicGeometry.IsAffine X\ninstâœ : AlgebraicGeometry.IsAffine Y\nâŠ¢ Iff (AlgebraicGeometry.SurjectiveOnStalks f) (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.app f Top.top)).SurjectiveOnStalks","decl":"variable {f} in\nlemma iff_of_isAffine [IsAffine X] [IsAffine Y] :\n    SurjectiveOnStalks f â†” RingHom.SurjectiveOnStalks (f.app âŠ¤).hom := by\n  rw [â† Spec_iff, MorphismProperty.arrow_mk_iso_iff @SurjectiveOnStalks (arrowIsoSpecÎ“OfIsAffine f)]\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.of_comp","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœ : AlgebraicGeometry.SurjectiveOnStalks (CategoryTheory.CategoryStruct.comp f g)\nâŠ¢ AlgebraicGeometry.SurjectiveOnStalks f","decl":"theorem of_comp [SurjectiveOnStalks (f â‰« g)] : SurjectiveOnStalks f := by\n  refine âŸ¨fun x â†¦ ?_âŸ©\n  have := (f â‰« g).stalkMap_surjective x\n  rw [Scheme.stalkMap_comp] at this\n  exact Function.Surjective.of_comp this\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.stableUnderBaseChange","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"âŠ¢ CategoryTheory.MorphismProperty.IsStableUnderBaseChange @AlgebraicGeometry.SurjectiveOnStalks","decl":"instance stableUnderBaseChange :\n    MorphismProperty.IsStableUnderBaseChange @SurjectiveOnStalks := by\n  apply HasRingHomProperty.isStableUnderBaseChange\n  apply RingHom.IsStableUnderBaseChange.mk\n  Â· exact (HasRingHomProperty.isLocal_ringHomProperty @SurjectiveOnStalks).respectsIso\n  intros R S T _ _ _ _ _ H\n  exact H.baseChange\n\n"}
{"name":"AlgebraicGeometry.SurjectiveOnStalks.isEmbedding_pullback","module":"Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\ninstâœ : AlgebraicGeometry.SurjectiveOnStalks g\nâŠ¢ Topology.IsEmbedding fun x => { fst := (CategoryTheory.Limits.pullback.fst f g).base x, snd := (CategoryTheory.Limits.pullback.snd f g).base x }","decl":"/-- If `Y âŸ¶ S` is surjective on stalks, then for every `X âŸ¶ S`, `X Ã—â‚› Y` is a subset of\n`X Ã— Y` (cartesian product as topological spaces) with the induced topology. -/\nlemma isEmbedding_pullback {X Y S : Scheme.{u}} (f : X âŸ¶ S) (g : Y âŸ¶ S) [SurjectiveOnStalks g] :\n    IsEmbedding (fun x â†¦ ((pullback.fst f g).base x, (pullback.snd f g).base x)) := by\n  let L := (fun x â†¦ ((pullback.fst f g).base x, (pullback.snd f g).base x))\n  have H : âˆ€ R A B (f' : Spec A âŸ¶ Spec R) (g' : Spec B âŸ¶ Spec R) (iX : Spec A âŸ¶ X)\n      (iY : Spec B âŸ¶ Y) (iS : Spec R âŸ¶ S) (eâ‚ eâ‚‚), IsOpenImmersion iX â†’ IsOpenImmersion iY â†’\n      IsOpenImmersion iS â†’ IsEmbedding (L âˆ˜ (pullback.map f' g' f g iX iY iS eâ‚ eâ‚‚).base) := by\n    intro R A B f' g' iX iY iS eâ‚ eâ‚‚ _ _ _\n    have H : SurjectiveOnStalks g' :=\n      have : SurjectiveOnStalks (g' â‰« iS) := eâ‚‚ â–¸ inferInstance\n      .of_comp _ iS\n    obtain âŸ¨Ï†, rflâŸ© : âˆƒ Ï†, Spec.map Ï† = f' := âŸ¨_, Spec.map_preimage _âŸ©\n    obtain âŸ¨Ïˆ, rflâŸ© : âˆƒ Ïˆ, Spec.map Ïˆ = g' := âŸ¨_, Spec.map_preimage _âŸ©\n    algebraize [Ï†.hom, Ïˆ.hom]\n    rw [HasRingHomProperty.Spec_iff (P := @SurjectiveOnStalks)] at H\n    convert ((iX.isOpenEmbedding.prodMap iY.isOpenEmbedding).isEmbedding.comp\n      (PrimeSpectrum.isEmbedding_tensorProductTo_of_surjectiveOnStalks R A B H)).comp\n      (Scheme.homeoOfIso (pullbackSpecIso R A B)).isEmbedding\n    ext1 x\n    obtain âŸ¨x, rflâŸ© := (Scheme.homeoOfIso (pullbackSpecIso R A B).symm).surjective x\n    simp only [Scheme.homeoOfIso_apply, Function.comp_apply]\n    ext\n    Â· simp only [L, â† Scheme.comp_base_apply, pullback.lift_fst, Iso.symm_hom,\n        Iso.inv_hom_id]\n      erw [â† Scheme.comp_base_apply, pullbackSpecIso_inv_fst_assoc]\n      rfl\n    Â· simp only [L, â† Scheme.comp_base_apply, pullback.lift_snd, Iso.symm_hom,\n        Iso.inv_hom_id]\n      erw [â† Scheme.comp_base_apply, pullbackSpecIso_inv_snd_assoc]\n      rfl\n  let ğ’° := S.affineOpenCover.openCover\n  let ğ’± (i) := ((ğ’°.pullbackCover f).obj i).affineOpenCover.openCover\n  let ğ’² (i) := ((ğ’°.pullbackCover g).obj i).affineOpenCover.openCover\n  let U (ijk : Î£ i, (ğ’± i).J Ã— (ğ’² i).J) : TopologicalSpace.Opens (X.carrier Ã— Y) :=\n    âŸ¨{ P | P.1 âˆˆ ((ğ’± ijk.1).map ijk.2.1 â‰« (ğ’°.pullbackCover f).map ijk.1).opensRange âˆ§\n          P.2 âˆˆ ((ğ’² ijk.1).map ijk.2.2 â‰« (ğ’°.pullbackCover g).map ijk.1).opensRange },\n      (continuous_fst.1 _ ((ğ’± ijk.1).map ijk.2.1 â‰«\n      (ğ’°.pullbackCover f).map ijk.1).opensRange.2).inter (continuous_snd.1 _\n      ((ğ’² ijk.1).map ijk.2.2 â‰« (ğ’°.pullbackCover g).map ijk.1).opensRange.2)âŸ©\n  have : Set.range L âŠ† (iSup U :) := by\n    simp only [Scheme.Cover.pullbackCover_J, Scheme.Cover.pullbackCover_obj, Set.range_subset_iff]\n    intro z\n    simp only [SetLike.mem_coe, TopologicalSpace.Opens.mem_iSup, Sigma.exists, Prod.exists]\n    obtain âŸ¨is, s, hsxâŸ© := ğ’°.exists_eq (f.base ((pullback.fst f g).base z))\n    have hsy : (ğ’°.map is).base s = g.base ((pullback.snd f g).base z) := by\n      rwa [â† Scheme.comp_base_apply, â† pullback.condition, Scheme.comp_base_apply]\n    obtain âŸ¨x : (ğ’°.pullbackCover f).obj is, hxâŸ© :=\n      Scheme.IsJointlySurjectivePreserving.exists_preimage_fst_triplet_of_prop\n        (P := @IsOpenImmersion) inferInstance _ _ hsx.symm\n    obtain âŸ¨y : (ğ’°.pullbackCover g).obj is, hyâŸ© :=\n      Scheme.IsJointlySurjectivePreserving.exists_preimage_fst_triplet_of_prop\n        (P := @IsOpenImmersion) inferInstance _ _ hsy.symm\n    obtain âŸ¨ix, x, rflâŸ© := (ğ’± is).exists_eq x\n    obtain âŸ¨iy, y, rflâŸ© := (ğ’² is).exists_eq y\n    refine âŸ¨is, ix, iy, âŸ¨x, hxâŸ©, âŸ¨y, hyâŸ©âŸ©\n  let ğ“¤ := (Scheme.Pullback.openCoverOfBase ğ’° f g).bind\n    (fun i â†¦ Scheme.Pullback.openCoverOfLeftRight (ğ’± i) (ğ’² i) _ _)\n  refine isEmbedding_of_iSup_eq_top_of_preimage_subset_range _ ?_ U this _ (fun i â†¦ (ğ“¤.map i).base)\n    (fun i â†¦ (ğ“¤.map i).continuous) ?_ ?_\n  Â· fun_prop\n  Â· rintro i x âŸ¨âŸ¨xâ‚, hxâ‚âŸ©, âŸ¨xâ‚‚, hxâ‚‚âŸ©âŸ©\n    obtain âŸ¨xâ‚', hxâ‚'âŸ© :=\n      Scheme.IsJointlySurjectivePreserving.exists_preimage_fst_triplet_of_prop\n        (P := @IsOpenImmersion) inferInstance _ _ hxâ‚.symm\n    obtain âŸ¨xâ‚‚', hxâ‚‚'âŸ© :=\n      Scheme.IsJointlySurjectivePreserving.exists_preimage_fst_triplet_of_prop\n        (P := @IsOpenImmersion) inferInstance _ _ hxâ‚‚.symm\n    obtain âŸ¨z, hzâŸ© :=\n      Scheme.IsJointlySurjectivePreserving.exists_preimage_fst_triplet_of_prop\n        (P := @IsOpenImmersion) inferInstance _ _ (hxâ‚'.trans hxâ‚‚'.symm)\n    refine âŸ¨(pullbackFstFstIso _ _ _ _ _ _ (ğ’°.map i.1) ?_ ?_).hom.base z, ?_âŸ©\n    Â· simp [pullback.condition]\n    Â· simp [pullback.condition]\n    Â· dsimp only\n      rw [â† hxâ‚', â† hz, â† Scheme.comp_base_apply]\n      erw [â† Scheme.comp_base_apply]\n      congr 4\n      apply pullback.hom_ext <;> simp [ğ“¤, â† pullback.condition, â† pullback.condition_assoc]\n  Â· intro i\n    have := H (S.affineOpenCover.obj i.1) (((ğ’°.pullbackCover f).obj i.1).affineOpenCover.obj i.2.1)\n        (((ğ’°.pullbackCover g).obj i.1).affineOpenCover.obj i.2.2)\n        ((ğ’± i.1).map i.2.1 â‰« ğ’°.pullbackHom f i.1)\n        ((ğ’² i.1).map i.2.2 â‰« ğ’°.pullbackHom g i.1)\n        ((ğ’± i.1).map i.2.1 â‰« (ğ’°.pullbackCover f).map i.1)\n        ((ğ’² i.1).map i.2.2 â‰« (ğ’°.pullbackCover g).map i.1)\n        (ğ’°.map i.1) (by simp [pullback.condition]) (by simp [pullback.condition])\n        inferInstance inferInstance inferInstance\n    convert this using 6\n    apply pullback.hom_ext <;>\n      simp [ğ“¤, â† pullback.condition, â† pullback.condition_assoc,\n        Scheme.Cover.pullbackHom]\n\n"}
