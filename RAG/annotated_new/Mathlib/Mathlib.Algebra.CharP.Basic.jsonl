{"name":"CharP.natCast_injOn_Iio","module":"Mathlib.Algebra.CharP.Basic","initialProofState":"R : Type u_1\ninst✝² : AddMonoidWithOne R\np : Nat\ninst✝¹ : CharP R p\ninst✝ : IsRightCancelAdd R\n⊢ Set.InjOn Nat.cast (Set.Iio p)","decl":"lemma natCast_injOn_Iio : (Set.Iio p).InjOn ((↑) : ℕ → R) :=\n  fun _a ha _b hb hab ↦ ((natCast_eq_natCast _ _).1 hab).eq_of_lt_of_lt ha hb\n\n"}
{"name":"CharP.intCast_injOn_Ico","module":"Mathlib.Algebra.CharP.Basic","initialProofState":"R : Type u_1\ninst✝² : AddGroupWithOne R\np : Nat\ninst✝¹ : CharP R p\ninst✝ : IsRightCancelAdd R\n⊢ Set.InjOn Int.cast (Set.Ico 0 ↑p)","decl":"lemma intCast_injOn_Ico [IsRightCancelAdd R] : InjOn (Int.cast : ℤ → R) (Ico 0 p) := by\n  rintro a ⟨ha₀, ha⟩ b ⟨hb₀, hb⟩ hab\n  lift a to ℕ using ha₀\n  lift b to ℕ using hb₀\n  norm_cast at *\n  exact natCast_injOn_Iio _ _ ha hb hab\n\n"}
{"name":"CharP.cast_ne_zero_of_ne_of_prime","module":"Mathlib.Algebra.CharP.Basic","initialProofState":"R : Type u_1\ninst✝² : NonAssocSemiring R\ninst✝¹ : Nontrivial R\np q : Nat\ninst✝ : CharP R p\nhq : Nat.Prime q\nhneq : Ne p q\n⊢ Ne (↑q) 0","decl":"variable (R) in\n/-- If a ring `R` is of characteristic `p`, then for any prime number `q` different from `p`,\nit is not zero in `R`. -/\nlemma cast_ne_zero_of_ne_of_prime [Nontrivial R]\n    {p q : ℕ} [CharP R p] (hq : q.Prime) (hneq : p ≠ q) : (q : R) ≠ 0 := fun h ↦ by\n  rw [cast_eq_zero_iff R p q] at h\n  rcases hq.eq_one_or_self_of_dvd _ h with h | h\n  · subst h\n    exact false_of_nontrivial_of_char_one (R := R)\n  · exact hneq h\n\n"}
{"name":"CharP.ringChar_of_prime_eq_zero","module":"Mathlib.Algebra.CharP.Basic","initialProofState":"R : Type u_1\ninst✝¹ : NonAssocSemiring R\ninst✝ : Nontrivial R\np : Nat\nhprime : Nat.Prime p\nhp0 : Eq (↑p) 0\n⊢ Eq (ringChar R) p","decl":"lemma ringChar_of_prime_eq_zero [Nontrivial R] {p : ℕ} (hprime : Nat.Prime p)\n    (hp0 : (p : R) = 0) : ringChar R = p :=\n  Or.resolve_left ((Nat.dvd_prime hprime).1 (ringChar.dvd hp0)) ringChar_ne_one\n\n"}
{"name":"CharP.charP_iff_prime_eq_zero","module":"Mathlib.Algebra.CharP.Basic","initialProofState":"R : Type u_1\ninst✝¹ : NonAssocSemiring R\ninst✝ : Nontrivial R\np : Nat\nhp : Nat.Prime p\n⊢ Iff (CharP R p) (Eq (↑p) 0)","decl":"lemma charP_iff_prime_eq_zero [Nontrivial R] {p : ℕ} (hp : p.Prime) :\n    CharP R p ↔ (p : R) = 0 :=\n  ⟨fun _ => cast_eq_zero R p,\n   fun hp0 => (ringChar_of_prime_eq_zero hp hp0) ▸ inferInstance⟩\n\n"}
{"name":"Ring.two_ne_zero","module":"Mathlib.Algebra.CharP.Basic","initialProofState":"R : Type u_2\ninst✝¹ : NonAssocSemiring R\ninst✝ : Nontrivial R\nhR : Ne (ringChar R) 2\n⊢ Ne 2 0","decl":"/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/\nprotected lemma Ring.two_ne_zero {R : Type*} [NonAssocSemiring R] [Nontrivial R]\n    (hR : ringChar R ≠ 2) : (2 : R) ≠ 0 := by\n  rw [Ne, (by norm_cast : (2 : R) = (2 : ℕ)), ringChar.spec, Nat.dvd_prime Nat.prime_two]\n  exact mt (or_iff_left hR).mp CharP.ringChar_ne_one\n\n-- We have `CharP.neg_one_ne_one`, which assumes `[Ring R] (p : ℕ) [CharP R p] [Fact (2 < p)]`.\n-- This is a version using `ringChar` instead.\n"}
{"name":"Ring.neg_one_ne_one_of_char_ne_two","module":"Mathlib.Algebra.CharP.Basic","initialProofState":"R : Type u_2\ninst✝¹ : NonAssocRing R\ninst✝ : Nontrivial R\nhR : Ne (ringChar R) 2\n⊢ Ne (-1) 1","decl":"/-- Characteristic `≠ 2` and nontrivial implies that `-1 ≠ 1`. -/\nlemma Ring.neg_one_ne_one_of_char_ne_two {R : Type*} [NonAssocRing R] [Nontrivial R]\n    (hR : ringChar R ≠ 2) : (-1 : R) ≠ 1 := fun h =>\n  Ring.two_ne_zero hR (one_add_one_eq_two (R := R) ▸ neg_eq_iff_add_eq_zero.mp h)\n\n"}
{"name":"Ring.eq_self_iff_eq_zero_of_char_ne_two","module":"Mathlib.Algebra.CharP.Basic","initialProofState":"R : Type u_2\ninst✝² : NonAssocRing R\ninst✝¹ : Nontrivial R\ninst✝ : NoZeroDivisors R\nhR : Ne (ringChar R) 2\na : R\n⊢ Iff (Eq (Neg.neg a) a) (Eq a 0)","decl":"/-- Characteristic `≠ 2` in a domain implies that `-a = a` iff `a = 0`. -/\nlemma Ring.eq_self_iff_eq_zero_of_char_ne_two {R : Type*} [NonAssocRing R] [Nontrivial R]\n    [NoZeroDivisors R] (hR : ringChar R ≠ 2) {a : R} : -a = a ↔ a = 0 :=\n  ⟨fun h =>\n    (mul_eq_zero.mp <| (two_mul a).trans <| neg_eq_iff_add_eq_zero.mp h).resolve_left\n      (Ring.two_ne_zero hR),\n    fun h => ((congr_arg (fun x => -x) h).trans neg_zero).trans h.symm⟩\n\n"}
{"name":"Nat.lcm.charP","module":"Mathlib.Algebra.CharP.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : AddMonoidWithOne R\ninst✝¹ : AddMonoidWithOne S\np q : Nat\ninst✝ : CharP S q\n⊢ CharP (Prod R S) (p.lcm q)","decl":"/-- The characteristic of the product of rings is the least common multiple of the\ncharacteristics of the two rings. -/\ninstance Nat.lcm.charP [CharP S q] : CharP (R × S) (Nat.lcm p q) where\n  cast_eq_zero_iff' := by\n    simp [Prod.ext_iff, CharP.cast_eq_zero_iff R p, CharP.cast_eq_zero_iff S q, Nat.lcm_dvd_iff]\n\n"}
{"name":"Prod.charP","module":"Mathlib.Algebra.CharP.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : AddMonoidWithOne R\ninst✝¹ : AddMonoidWithOne S\np : Nat\ninst✝ : CharP S p\n⊢ CharP (Prod R S) p","decl":"/-- The characteristic of the product of two rings of the same characteristic\n  is the same as the characteristic of the rings -/\ninstance Prod.charP [CharP S p] : CharP (R × S) p := by\n  convert Nat.lcm.charP R S p p; simp\n\n"}
{"name":"Prod.charZero_of_left","module":"Mathlib.Algebra.CharP.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : AddMonoidWithOne R\ninst✝¹ : AddMonoidWithOne S\ninst✝ : CharZero R\n⊢ CharZero (Prod R S)","decl":"instance Prod.charZero_of_left [CharZero R] : CharZero (R × S) where\n  cast_injective _ _ h := CharZero.cast_injective congr(Prod.fst $h)\n\n"}
{"name":"Prod.charZero_of_right","module":"Mathlib.Algebra.CharP.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : AddMonoidWithOne R\ninst✝¹ : AddMonoidWithOne S\ninst✝ : CharZero S\n⊢ CharZero (Prod R S)","decl":"instance Prod.charZero_of_right [CharZero S] : CharZero (R × S) where\n  cast_injective _ _ h := CharZero.cast_injective congr(Prod.snd $h)\n\n"}
{"name":"ULift.charP","module":"Mathlib.Algebra.CharP.Basic","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoidWithOne R\np : Nat\ninst✝ : CharP R p\n⊢ CharP (ULift.{u_2, u_1} R) p","decl":"instance ULift.charP [AddMonoidWithOne R] (p : ℕ) [CharP R p] : CharP (ULift R) p where\n  cast_eq_zero_iff' n := Iff.trans ULift.ext_iff <| CharP.cast_eq_zero_iff R p n\n\n"}
{"name":"MulOpposite.charP","module":"Mathlib.Algebra.CharP.Basic","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoidWithOne R\np : Nat\ninst✝ : CharP R p\n⊢ CharP (MulOpposite R) p","decl":"instance MulOpposite.charP [AddMonoidWithOne R] (p : ℕ) [CharP R p] : CharP Rᵐᵒᵖ p where\n  cast_eq_zero_iff' n := MulOpposite.unop_inj.symm.trans <| CharP.cast_eq_zero_iff R p n\n\n"}
{"name":"Int.cast_injOn_of_ringChar_ne_two","module":"Mathlib.Algebra.CharP.Basic","initialProofState":"R : Type u_2\ninst✝¹ : NonAssocRing R\ninst✝ : Nontrivial R\nhR : Ne (ringChar R) 2\n⊢ Set.InjOn Int.cast (Insert.insert 0 (Insert.insert 1 (Singleton.singleton (-1))))","decl":"/-- If two integers from `{0, 1, -1}` result in equal elements in a ring `R`\nthat is nontrivial and of characteristic not `2`, then they are equal. -/\nlemma Int.cast_injOn_of_ringChar_ne_two {R : Type*} [NonAssocRing R] [Nontrivial R]\n    (hR : ringChar R ≠ 2) : ({0, 1, -1} : Set ℤ).InjOn ((↑) : ℤ → R) := by\n  rintro _ (rfl | rfl | rfl) _ (rfl | rfl | rfl) h <;>\n  simp only\n    [cast_neg, cast_one, cast_zero, neg_eq_zero, one_ne_zero, zero_ne_one, zero_eq_neg] at h ⊢\n  · exact ((Ring.neg_one_ne_one_of_char_ne_two hR).symm h).elim\n  · exact ((Ring.neg_one_ne_one_of_char_ne_two hR) h).elim\n\n"}
{"name":"CharZero.charZero_iff_forall_prime_ne_zero","module":"Mathlib.Algebra.CharP.Basic","initialProofState":"R : Type u_1\ninst✝² : NonAssocRing R\ninst✝¹ : NoZeroDivisors R\ninst✝ : Nontrivial R\n⊢ Iff (CharZero R) (∀ (p : Nat), Nat.Prime p → Ne (↑p) 0)","decl":"lemma charZero_iff_forall_prime_ne_zero [NonAssocRing R] [NoZeroDivisors R] [Nontrivial R] :\n    CharZero R ↔ ∀ p : ℕ, p.Prime → (p : R) ≠ 0 := by\n  refine ⟨fun h p hp => by simp [hp.ne_zero], fun h => ?_⟩\n  let p := ringChar R\n  cases CharP.char_is_prime_or_zero R p with\n  | inl hp => simpa using h p hp\n  | inr h => have : CharP R 0 := h ▸ inferInstance; exact CharP.charP_to_charZero R\n\n"}
{"name":"Fin.charP","module":"Mathlib.Algebra.CharP.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ CharP (Fin n) n","decl":"/-- The characteristic of `F_p` is `p`. -/\n@[stacks 09FS \"First part. We don't require `p` to be a prime in mathlib.\"]\ninstance charP (n : ℕ) [NeZero n] : CharP (Fin n) n where cast_eq_zero_iff' _ := natCast_eq_zero\n\n"}
{"name":"instExpCharProd","module":"Mathlib.Algebra.CharP.Basic","initialProofState":"R : Type u_1\ninst✝³ : AddMonoidWithOne R\nS : Type u_2\ninst✝² : Semiring S\np : Nat\ninst✝¹ : ExpChar R p\ninst✝ : ExpChar S p\n⊢ ExpChar (Prod R S) p","decl":"instance (S : Type*) [Semiring S] (p) [ExpChar R p] [ExpChar S p] : ExpChar (R × S) p := by\n  obtain hp | ⟨hp⟩ := ‹ExpChar R p›\n  · have := Prod.charZero_of_left R S; exact .zero\n  obtain _ | _ := ‹ExpChar S p›\n  · exact (Nat.not_prime_one hp).elim\n  · have := Prod.charP R S p; exact .prime hp\n\n"}
