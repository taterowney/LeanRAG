{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.diagonal_respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœ : P.toProperty.RespectsIso\nâŠ¢ P.diagonal.toProperty.RespectsIso","decl":"instance AffineTargetMorphismProperty.diagonal_respectsIso (P : AffineTargetMorphismProperty)\n    [P.toProperty.RespectsIso] : P.diagonal.toProperty.RespectsIso := by\n  delta AffineTargetMorphismProperty.diagonal\n  apply AffineTargetMorphismProperty.respectsIso_mk\n  Â· introv H _ _\n    rw [pullback.mapDesc_comp, P.cancel_left_of_respectsIso, P.cancel_right_of_respectsIso]\n    apply H\n  Â· introv H _ _\n    rw [pullback.mapDesc_comp, P.cancel_right_of_respectsIso]\n    apply H\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.diagonal_of_openCover","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœÂ² : AlgebraicGeometry.HasAffineProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nğ’° : Y.OpenCover\ninstâœÂ¹ : âˆ€ (i : ğ’°.J), AlgebraicGeometry.IsAffine (ğ’°.obj i)\nğ’°' : (i : ğ’°.J) â†’ (CategoryTheory.Limits.pullback f (ğ’°.map i)).OpenCover\ninstâœ : âˆ€ (i : ğ’°.J) (j : (ğ’°' i).J), AlgebraicGeometry.IsAffine ((ğ’°' i).obj j)\nhğ’°' : âˆ€ (i : ğ’°.J) (j k : (ğ’°' i).J), Q (CategoryTheory.Limits.pullback.mapDesc ((ğ’°' i).map j) ((ğ’°' i).map k) (AlgebraicGeometry.Scheme.Cover.pullbackHom ğ’° f i))\nâŠ¢ P.diagonal f","decl":"theorem HasAffineProperty.diagonal_of_openCover (P) {Q} [HasAffineProperty P Q]\n    {X Y : Scheme.{u}} (f : X âŸ¶ Y) (ğ’° : Scheme.OpenCover.{u} Y) [âˆ€ i, IsAffine (ğ’°.obj i)]\n    (ğ’°' : âˆ€ i, Scheme.OpenCover.{u} (pullback f (ğ’°.map i))) [âˆ€ i j, IsAffine ((ğ’°' i).obj j)]\n    (hğ’°' : âˆ€ i j k,\n      Q (pullback.mapDesc ((ğ’°' i).map j) ((ğ’°' i).map k) (ğ’°.pullbackHom f i))) :\n    P.diagonal f := by\n  letI := isLocal_affineProperty P\n  let ğ’± := (Scheme.Pullback.openCoverOfBase ğ’° f f).bind fun i =>\n    Scheme.Pullback.openCoverOfLeftRight.{u} (ğ’°' i) (ğ’°' i) (pullback.snd _ _) (pullback.snd _ _)\n  have i1 : âˆ€ i, IsAffine (ğ’±.obj i) := fun i => by dsimp [ğ’±]; infer_instance\n  apply of_openCover ğ’±\n  rintro âŸ¨i, j, kâŸ©\n  dsimp [ğ’±]\n  convert (Q.cancel_left_of_respectsIso\n    ((pullbackDiagonalMapIso _ _ ((ğ’°' i).map j) ((ğ’°' i).map k)).inv â‰«\n      pullback.map _ _ _ _ (ğŸ™ _) (ğŸ™ _) (ğŸ™ _) _ _) (pullback.snd _ _)).mp _ using 1\n  Â· simp\n  Â· ext1 <;> simp\n  Â· simp only [Category.assoc, limit.lift_Ï€, PullbackCone.mk_pt, PullbackCone.mk_Ï€_app,\n      Functor.const_obj_obj, cospan_one, cospan_left, cospan_right, Category.comp_id]\n    convert hğ’°' i j k\n    ext1 <;> simp [Scheme.Cover.pullbackHom]\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.diagonal_of_openCover_diagonal","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœÂ¹ : AlgebraicGeometry.HasAffineProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nğ’° : Y.OpenCover\ninstâœ : âˆ€ (i : ğ’°.J), AlgebraicGeometry.IsAffine (ğ’°.obj i)\nhğ’° : âˆ€ (i : ğ’°.1), Q.diagonal (AlgebraicGeometry.Scheme.Cover.pullbackHom ğ’° f i)\nâŠ¢ P.diagonal f","decl":"theorem HasAffineProperty.diagonal_of_openCover_diagonal\n    (P) {Q} [HasAffineProperty P Q]\n    {X Y : Scheme.{u}} (f : X âŸ¶ Y) (ğ’° : Scheme.OpenCover.{u} Y) [âˆ€ i, IsAffine (ğ’°.obj i)]\n    (hğ’° : âˆ€ i, Q.diagonal (ğ’°.pullbackHom f i)) :\n    P.diagonal f :=\n  diagonal_of_openCover P f ğ’° (fun _ â†¦ Scheme.affineCover _)\n    (fun _ _ _ â†¦ hğ’° _ _ _)\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.diagonal_of_diagonal_of_isPullback","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœÂ² : AlgebraicGeometry.HasAffineProperty P Q\nX Y U V : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom U Y\ninstâœÂ¹ : AlgebraicGeometry.IsAffine U\ninstâœ : AlgebraicGeometry.IsOpenImmersion g\niV : Quiver.Hom V X\nf' : Quiver.Hom V U\nh : CategoryTheory.IsPullback iV f' f g\nH : P.diagonal f\nâŠ¢ Q.diagonal f'","decl":"theorem HasAffineProperty.diagonal_of_diagonal_of_isPullback\n    (P) {Q} [HasAffineProperty P Q]\n    {X Y U V : Scheme.{u}} {f : X âŸ¶ Y} {g : U âŸ¶ Y}\n    [IsAffine U] [IsOpenImmersion g]\n    {iV : V âŸ¶ X} {f' : V âŸ¶ U} (h : IsPullback iV f' f g) (H : P.diagonal f) :\n    Q.diagonal f' := by\n  letI := isLocal_affineProperty P\n  rw [â† Q.diagonal.cancel_left_of_respectsIso h.isoPullback.inv,\n    h.isoPullback_inv_snd]\n  rintro U V fâ‚ fâ‚‚ hU hV hfâ‚ hfâ‚‚\n  rw [â† Q.cancel_left_of_respectsIso (pullbackDiagonalMapIso f _ fâ‚ fâ‚‚).hom]\n  convert HasAffineProperty.of_isPullback (P := P) (.of_hasPullback _ _) H\n  Â· apply pullback.hom_ext <;> simp\n  Â· infer_instance\n  Â· infer_instance\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.diagonal_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœÂ¹ : AlgebraicGeometry.HasAffineProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninstâœ : AlgebraicGeometry.IsAffine Y\nâŠ¢ Iff (Q.diagonal f) (P.diagonal f)","decl":"theorem HasAffineProperty.diagonal_iff\n    (P) {Q} [HasAffineProperty P Q] {X Y} {f : X âŸ¶ Y} [IsAffine Y] :\n    Q.diagonal f â†” P.diagonal f := by\n  letI := isLocal_affineProperty P\n  refine âŸ¨fun hf â†¦ ?_, diagonal_of_diagonal_of_isPullback P .of_id_fstâŸ©\n  rw [â† Q.diagonal.cancel_left_of_respectsIso\n    (pullback.fst (f := f) (g := ğŸ™ Y)), pullback.condition, Category.comp_id] at hf\n  let ğ’° := X.affineCover.pushforwardIso (inv (pullback.fst (f := f) (g := ğŸ™ Y)))\n  have (i) : IsAffine (ğ’°.obj i) := by dsimp [ğ’°]; infer_instance\n  exact HasAffineProperty.diagonal_of_openCover P f (Scheme.coverOfIsIso (ğŸ™ _))\n    (fun _ â†¦ ğ’°) (fun _ _ _ â†¦ hf _ _)\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.diagonal_affineProperty_isLocal","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"Q : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœ : Q.IsLocal\nâŠ¢ Q.diagonal.IsLocal","decl":"instance HasAffineProperty.diagonal_affineProperty_isLocal\n    {Q : AffineTargetMorphismProperty} [Q.IsLocal] :\n    Q.diagonal.IsLocal where\n  respectsIso := inferInstance\n  to_basicOpen {_ Y} _ f r hf :=\n    diagonal_of_diagonal_of_isPullback (targetAffineLocally Q)\n      (isPullback_morphismRestrict f (Y.basicOpen r)).flip\n      ((diagonal_iff (targetAffineLocally Q)).mp hf)\n  of_basicOpenCover {X Y} _ f s hs hs' := by\n    refine (diagonal_iff (targetAffineLocally Q)).mpr ?_\n    let ğ’° := Y.openCoverOfISupEqTop _ (((isAffineOpen_top Y).basicOpen_union_eq_self_iff _).mpr hs)\n    have (i) : IsAffine (ğ’°.obj i) := (isAffineOpen_top Y).basicOpen i.1\n    refine diagonal_of_openCover_diagonal (targetAffineLocally Q) f ğ’° ?_\n    intro i\n    exact (Q.diagonal.arrow_mk_iso_iff\n      (morphismRestrictEq _ (by simp [ğ’°]) â‰ªâ‰« morphismRestrictOpensRange _ _)).mp (hs' i)\n\n"}
{"name":"AlgebraicGeometry.instHasAffinePropertyDiagonalSchemeDiagonal","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœ : AlgebraicGeometry.HasAffineProperty P Q\nâŠ¢ AlgebraicGeometry.HasAffineProperty P.diagonal Q.diagonal","decl":"instance (P) {Q} [HasAffineProperty P Q] : HasAffineProperty P.diagonal Q.diagonal where\n  isLocal_affineProperty := letI := HasAffineProperty.isLocal_affineProperty P; inferInstance\n  eq_targetAffineLocally' := by\n    ext X Y f\n    letI := HasAffineProperty.isLocal_affineProperty P\n    constructor\n    Â· exact fun H U â†¦ HasAffineProperty.diagonal_of_diagonal_of_isPullback P\n        (isPullback_morphismRestrict f U).flip H\n    Â· exact fun H â†¦ HasAffineProperty.diagonal_of_openCover_diagonal P f Y.affineCover\n        (fun i â†¦ of_targetAffineLocally_of_isPullback (.of_hasPullback _ _) H)\n\n"}
{"name":"AlgebraicGeometry.instIsLocalAtTargetDiagonalScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœ : AlgebraicGeometry.IsLocalAtTarget P\nâŠ¢ AlgebraicGeometry.IsLocalAtTarget P.diagonal","decl":"instance (P) [IsLocalAtTarget P] : IsLocalAtTarget P.diagonal :=\n  letI := HasAffineProperty.of_isLocalAtTarget P\n  inferInstance\n\n"}
{"name":"AlgebraicGeometry.universally_isLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nhPâ‚‚ : âˆ€ {X Y : AlgebraicGeometry.Scheme} (f : Quiver.Hom X Y) {Î¹ : Type u} (U : Î¹ â†’ Y.Opens), Eq (iSup U) Top.top â†’ (âˆ€ (i : Î¹), P (AlgebraicGeometry.morphismRestrict f (U i))) â†’ P f\nâŠ¢ AlgebraicGeometry.IsLocalAtTarget P.universally","decl":"theorem universally_isLocalAtTarget (P : MorphismProperty Scheme)\n    (hPâ‚‚ : âˆ€ {X Y : Scheme.{u}} (f : X âŸ¶ Y) {Î¹ : Type u} (U : Î¹ â†’ Y.Opens)\n      (_ : iSup U = âŠ¤), (âˆ€ i, P (f âˆ£_ U i)) â†’ P f) : IsLocalAtTarget P.universally := by\n  apply IsLocalAtTarget.mk'\n  Â· exact fun {X Y} f U => P.universally.of_isPullback\n      (isPullback_morphismRestrict f U).flip\n  Â· intros X Y f Î¹ U hU H X' Y' iâ‚ iâ‚‚ f' h\n    apply hPâ‚‚ _ (fun i â†¦ iâ‚‚ â»Â¹áµ U i)\n    Â· rw [â† top_le_iff] at hU âŠ¢\n      rintro x -\n      simpa using @hU (iâ‚‚.base x) trivial\n    Â· rintro i\n      refine H _ ((X'.isoOfEq ?_).hom â‰« iâ‚ âˆ£_ _) (iâ‚‚ âˆ£_ _) _ ?_\n      Â· exact congr($(h.1.1) â»Â¹áµ U i)\n      Â· rw [â† (isPullback_morphismRestrict f _).paste_vert_iff]\n        Â· simp only [Category.assoc, morphismRestrict_Î¹, Scheme.isoOfEq_hom_Î¹_assoc]\n          exact (isPullback_morphismRestrict f' (iâ‚‚ â»Â¹áµ U i)).paste_vert h\n        Â· rw [â† cancel_mono (Scheme.Opens.Î¹ _)]\n          simp [morphismRestrict_Î¹_assoc, h.1.1]\n\n"}
{"name":"AlgebraicGeometry.topologically_isStableUnderComposition","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : {Î± Î² : Type u} â†’ [inst : TopologicalSpace Î±] â†’ [inst : TopologicalSpace Î²] â†’ (Î± â†’ Î²) â†’ Prop\nhP : âˆ€ {Î± Î² Î³ : Type u} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : TopologicalSpace Î³] (f : Î± â†’ Î²) (g : Î² â†’ Î³), P f â†’ P g â†’ P (Function.comp g f)\nâŠ¢ (AlgebraicGeometry.topologically fun {Î± Î²} [TopologicalSpace Î±] [TopologicalSpace Î²] => P).IsStableUnderComposition","decl":"/-- If a property of maps of topological spaces is stable under composition, the induced\nmorphism property of schemes is stable under composition. -/\nlemma topologically_isStableUnderComposition\n    (hP : âˆ€ {Î± Î² Î³ : Type u} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³]\n      (f : Î± â†’ Î²) (g : Î² â†’ Î³) (_ : P f) (_ : P g), P (g âˆ˜ f)) :\n    (topologically P).IsStableUnderComposition where\n  comp_mem {X Y Z} f g hf hg := by\n    simp only [topologically, Scheme.comp_coeBase, TopCat.coe_comp]\n    exact hP _ _ hf hg\n\n"}
{"name":"AlgebraicGeometry.topologically_iso_le","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : {Î± Î² : Type u} â†’ [inst : TopologicalSpace Î±] â†’ [inst : TopologicalSpace Î²] â†’ (Î± â†’ Î²) â†’ Prop\nhP : âˆ€ {Î± Î² : Type u} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] (f : Homeomorph Î± Î²), P â‡‘f\nâŠ¢ LE.le (CategoryTheory.MorphismProperty.isomorphisms AlgebraicGeometry.Scheme) (AlgebraicGeometry.topologically fun {Î± Î²} [TopologicalSpace Î±] [TopologicalSpace Î²] => P)","decl":"/-- If a property of maps of topological spaces is satisfied by all homeomorphisms,\nevery isomorphism of schemes satisfies the induced property. -/\nlemma topologically_iso_le\n    (hP : âˆ€ {Î± Î² : Type u} [TopologicalSpace Î±] [TopologicalSpace Î²] (f : Î± â‰ƒâ‚œ Î²), P f) :\n    MorphismProperty.isomorphisms Scheme â‰¤ (topologically P) := by\n  intro X Y e (he : IsIso e)\n  have : IsIso e := he\n  exact hP (TopCat.homeoOfIso (asIso e.base))\n\n"}
{"name":"AlgebraicGeometry.topologically_respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : {Î± Î² : Type u} â†’ [inst : TopologicalSpace Î±] â†’ [inst : TopologicalSpace Î²] â†’ (Î± â†’ Î²) â†’ Prop\nhPâ‚ : âˆ€ {Î± Î² : Type u} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] (f : Homeomorph Î± Î²), P â‡‘f\nhPâ‚‚ : âˆ€ {Î± Î² Î³ : Type u} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : TopologicalSpace Î³] (f : Î± â†’ Î²) (g : Î² â†’ Î³), P f â†’ P g â†’ P (Function.comp g f)\nâŠ¢ (AlgebraicGeometry.topologically fun {Î± Î²} [TopologicalSpace Î±] [TopologicalSpace Î²] => P).RespectsIso","decl":"/-- If a property of maps of topological spaces is satisfied by homeomorphisms and is stable\nunder composition, the induced property on schemes respects isomorphisms. -/\nlemma topologically_respectsIso\n    (hPâ‚ : âˆ€ {Î± Î² : Type u} [TopologicalSpace Î±] [TopologicalSpace Î²] (f : Î± â‰ƒâ‚œ Î²), P f)\n    (hPâ‚‚ : âˆ€ {Î± Î² Î³ : Type u} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³]\n      (f : Î± â†’ Î²) (g : Î² â†’ Î³) (_ : P f) (_ : P g), P (g âˆ˜ f)) :\n      (topologically P).RespectsIso :=\n  have : (topologically P).IsStableUnderComposition :=\n    topologically_isStableUnderComposition P hPâ‚‚\n  MorphismProperty.respectsIso_of_isStableUnderComposition (topologically_iso_le P hPâ‚)\n\n"}
{"name":"AlgebraicGeometry.topologically_isLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : {Î± Î² : Type u} â†’ [inst : TopologicalSpace Î±] â†’ [inst : TopologicalSpace Î²] â†’ (Î± â†’ Î²) â†’ Prop\ninstâœ : (AlgebraicGeometry.topologically fun {Î± Î²} [TopologicalSpace Î±] [TopologicalSpace Î²] => P).RespectsIso\nhPâ‚‚ : âˆ€ {Î± Î² : Type u} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] (f : Î± â†’ Î²) (s : Set Î²), Continuous f â†’ IsOpen s â†’ P f â†’ P (s.restrictPreimage f)\nhPâ‚ƒ : âˆ€ {Î± Î² : Type u} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] (f : Î± â†’ Î²) {Î¹ : Type u} (U : Î¹ â†’ TopologicalSpace.Opens Î²), Eq (iSup U) Top.top â†’ Continuous f â†’ (âˆ€ (i : Î¹), P ((U i).carrier.restrictPreimage f)) â†’ P f\nâŠ¢ AlgebraicGeometry.IsLocalAtTarget (AlgebraicGeometry.topologically fun {Î± Î²} [TopologicalSpace Î±] [TopologicalSpace Î²] => P)","decl":"/-- To check that a topologically defined morphism property is local at the target,\nwe may check the corresponding properties on topological spaces. -/\nlemma topologically_isLocalAtTarget\n    [(topologically P).RespectsIso]\n    (hPâ‚‚ : âˆ€ {Î± Î² : Type u} [TopologicalSpace Î±] [TopologicalSpace Î²] (f : Î± â†’ Î²) (s : Set Î²)\n      (_ : Continuous f) (_ : IsOpen s), P f â†’ P (s.restrictPreimage f))\n    (hPâ‚ƒ : âˆ€ {Î± Î² : Type u} [TopologicalSpace Î±] [TopologicalSpace Î²] (f : Î± â†’ Î²) {Î¹ : Type u}\n      (U : Î¹ â†’ TopologicalSpace.Opens Î²) (_ : iSup U = âŠ¤) (_ : Continuous f),\n      (âˆ€ i, P ((U i).carrier.restrictPreimage f)) â†’ P f) :\n    IsLocalAtTarget (topologically P) := by\n  apply IsLocalAtTarget.mk'\n  Â· intro X Y f U hf\n    simp_rw [topologically, morphismRestrict_base]\n    exact hPâ‚‚ f.base U.carrier f.base.2 U.2 hf\n  Â· intro X Y f Î¹ U hU hf\n    apply hPâ‚ƒ f.base U hU f.base.continuous fun i â†¦ ?_\n    rw [â† morphismRestrict_base]\n    exact hf i\n\n"}
{"name":"AlgebraicGeometry.topologically_isLocalAtTarget'","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : {Î± Î² : Type u} â†’ [inst : TopologicalSpace Î±] â†’ [inst : TopologicalSpace Î²] â†’ (Î± â†’ Î²) â†’ Prop\ninstâœ : (AlgebraicGeometry.topologically fun {Î± Î²} [TopologicalSpace Î±] [TopologicalSpace Î²] => P).RespectsIso\nhP : âˆ€ {Î± Î² : Type u} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] (f : Î± â†’ Î²) {Î¹ : Type u} (U : Î¹ â†’ TopologicalSpace.Opens Î²), Eq (iSup U) Top.top â†’ Continuous f â†’ Iff (P f) (âˆ€ (i : Î¹), P ((U i).carrier.restrictPreimage f))\nâŠ¢ AlgebraicGeometry.IsLocalAtTarget (AlgebraicGeometry.topologically fun {Î± Î²} [TopologicalSpace Î±] [TopologicalSpace Î²] => P)","decl":"/-- A variant of `topologically_isLocalAtTarget`\nthat takes one iff statement instead of two implications. -/\nlemma topologically_isLocalAtTarget'\n    [(topologically P).RespectsIso]\n    (hP : âˆ€ {Î± Î² : Type u} [TopologicalSpace Î±] [TopologicalSpace Î²] (f : Î± â†’ Î²) {Î¹ : Type u}\n      (U : Î¹ â†’ TopologicalSpace.Opens Î²) (_ : iSup U = âŠ¤) (_ : Continuous f),\n      P f â†” (âˆ€ i, P ((U i).carrier.restrictPreimage f))) :\n    IsLocalAtTarget (topologically P) := by\n  refine topologically_isLocalAtTarget P ?_ (fun f _ U hU hU' â†¦ (hP f U hU hU').mpr)\n  introv hf hs H\n  have := (hP f (![âŠ¤, Opens.mk s hs] âˆ˜ Equiv.ulift) ?_ hf).mp H âŸ¨1âŸ©\n  Â· simpa using this\n  Â· rw [â† top_le_iff]\n    exact le_iSup (![âŠ¤, Opens.mk s hs] âˆ˜ Equiv.ulift) âŸ¨0âŸ©\n\n"}
{"name":"AlgebraicGeometry.stalkwise_respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : {R S : Type u} â†’ [inst : CommRing R] â†’ [inst_1 : CommRing S] â†’ RingHom R S â†’ Prop\nhP : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nâŠ¢ (AlgebraicGeometry.stalkwise fun {R S} [CommRing R] [CommRing S] => P).RespectsIso","decl":"/-- If `P` respects isos, then `stalkwise P` respects isos. -/\nlemma stalkwise_respectsIso (hP : RingHom.RespectsIso P) :\n    (stalkwise P).RespectsIso where\n  precomp {X Y Z} e (he : IsIso e) f hf := by\n    simp only [stalkwise, Scheme.comp_coeBase, TopCat.coe_comp, Function.comp_apply]\n    intro x\n    rw [Scheme.stalkMap_comp]\n    exact (RingHom.RespectsIso.cancel_right_isIso hP _ _).mpr <| hf (e.base x)\n  postcomp {X Y Z} e (he : IsIso _) f hf := by\n    simp only [stalkwise, Scheme.comp_coeBase, TopCat.coe_comp, Function.comp_apply]\n    intro x\n    rw [Scheme.stalkMap_comp]\n    exact (RingHom.RespectsIso.cancel_left_isIso hP _ _).mpr <| hf x\n\n"}
{"name":"AlgebraicGeometry.stalkwiseIsLocalAtTarget_of_respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : {R S : Type u} â†’ [inst : CommRing R] â†’ [inst_1 : CommRing S] â†’ RingHom R S â†’ Prop\nhP : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nâŠ¢ AlgebraicGeometry.IsLocalAtTarget (AlgebraicGeometry.stalkwise fun {R S} [CommRing R] [CommRing S] => P)","decl":"/-- If `P` respects isos, then `stalkwise P` is local at the target. -/\nlemma stalkwiseIsLocalAtTarget_of_respectsIso (hP : RingHom.RespectsIso P) :\n    IsLocalAtTarget (stalkwise P) := by\n  have hP' : (RingHom.toMorphismProperty P).RespectsIso :=\n    RingHom.toMorphismProperty_respectsIso_iff.mp hP\n  letI := stalkwise_respectsIso hP\n  apply IsLocalAtTarget.mk'\n  Â· intro X Y f U hf x\n    apply ((RingHom.toMorphismProperty P).arrow_mk_iso_iff <|\n      morphismRestrictStalkMap f U x).mpr <| hf _\n  Â· intro X Y f Î¹ U hU hf x\n    have hy : f.base x âˆˆ iSup U := by rw [hU]; trivial\n    obtain âŸ¨i, hiâŸ© := Opens.mem_iSup.mp hy\n    exact ((RingHom.toMorphismProperty P).arrow_mk_iso_iff <|\n      morphismRestrictStalkMap f (U i) âŸ¨x, hiâŸ©).mp <| hf i âŸ¨x, hiâŸ©\n\n"}
{"name":"AlgebraicGeometry.stalkwise_isLocalAtSource_of_respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : {R S : Type u} â†’ [inst : CommRing R] â†’ [inst_1 : CommRing S] â†’ RingHom R S â†’ Prop\nhP : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nâŠ¢ AlgebraicGeometry.IsLocalAtSource (AlgebraicGeometry.stalkwise fun {R S} [CommRing R] [CommRing S] => P)","decl":"/-- If `P` respects isos, then `stalkwise P` is local at the source. -/\nlemma stalkwise_isLocalAtSource_of_respectsIso (hP : RingHom.RespectsIso P) :\n    IsLocalAtSource (stalkwise P) := by\n  letI := stalkwise_respectsIso hP\n  apply IsLocalAtSource.mk'\n  Â· intro X Y f U hf x\n    rw [Scheme.stalkMap_comp, CommRingCat.hom_comp, hP.cancel_right_isIso]\n    exact hf _\n  Â· intro X Y f Î¹ U hU hf x\n    have hy : x âˆˆ iSup U := by rw [hU]; trivial\n    obtain âŸ¨i, hiâŸ© := Opens.mem_iSup.mp hy\n    rw [â† hP.cancel_right_isIso _ ((U i).Î¹.stalkMap âŸ¨x, hiâŸ©)]\n    simpa [Scheme.stalkMap_comp] using hf i âŸ¨x, hiâŸ©\n\n"}
{"name":"AlgebraicGeometry.stalkwise_Spec_map_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : {R S : Type u} â†’ [inst : CommRing R] â†’ [inst_1 : CommRing S] â†’ RingHom R S â†’ Prop\nhP : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nR S : CommRingCat\nÏ† : Quiver.Hom R S\nâŠ¢ Iff (AlgebraicGeometry.stalkwise (fun {R S} [CommRing R] [CommRing S] => P) (AlgebraicGeometry.Spec.map Ï†)) (âˆ€ (p : Ideal â†‘S) (x : p.IsPrime), P (Localization.localRingHom (Ideal.comap (CommRingCat.Hom.hom Ï†) p) p (CommRingCat.Hom.hom Ï†) â‹¯))","decl":"lemma stalkwise_Spec_map_iff (hP : RingHom.RespectsIso P) {R S : CommRingCat} (Ï† : R âŸ¶ S) :\n    stalkwise P (Spec.map Ï†) â†” âˆ€ (p : Ideal S) (_ : p.IsPrime),\n      P (Localization.localRingHom _ p Ï†.hom rfl) := by\n  have hP' : (RingHom.toMorphismProperty P).RespectsIso :=\n    RingHom.toMorphismProperty_respectsIso_iff.mp hP\n  trans âˆ€ (p : PrimeSpectrum S), P (Localization.localRingHom _ p.asIdeal Ï†.hom rfl)\n  Â· exact forall_congr' fun p â†¦\n      (RingHom.toMorphismProperty P).arrow_mk_iso_iff (Scheme.arrowStalkMapSpecIso _ _)\n  Â· exact âŸ¨fun H p hp â†¦ H âŸ¨p, hpâŸ©, fun H p â†¦ H p.1 p.2âŸ©\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.isStableUnderBaseChange_of_isStableUnderBaseChangeOnAffine_of_isLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœ : AlgebraicGeometry.IsLocalAtTarget P\nhPâ‚‚ : (AlgebraicGeometry.AffineTargetMorphismProperty.of P).IsStableUnderBaseChange\nâŠ¢ P.IsStableUnderBaseChange","decl":"/-- If `P` is local at the target, to show that `P` is stable under base change, it suffices to\ncheck this for base change along a morphism of affine schemes. -/\nlemma isStableUnderBaseChange_of_isStableUnderBaseChangeOnAffine_of_isLocalAtTarget\n    (P : MorphismProperty Scheme) [IsLocalAtTarget P]\n    (hPâ‚‚ : (of P).IsStableUnderBaseChange) :\n    P.IsStableUnderBaseChange :=\n  letI := HasAffineProperty.of_isLocalAtTarget P\n  HasAffineProperty.isStableUnderBaseChange hPâ‚‚\n\n"}
