{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.diagonal_respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\ninst✝ : P.toProperty.RespectsIso\n⊢ P.diagonal.toProperty.RespectsIso","decl":"instance AffineTargetMorphismProperty.diagonal_respectsIso (P : AffineTargetMorphismProperty)\n    [P.toProperty.RespectsIso] : P.diagonal.toProperty.RespectsIso := by\n  delta AffineTargetMorphismProperty.diagonal\n  apply AffineTargetMorphismProperty.respectsIso_mk\n  · introv H _ _\n    rw [pullback.mapDesc_comp, P.cancel_left_of_respectsIso, P.cancel_right_of_respectsIso]\n    apply H\n  · introv H _ _\n    rw [pullback.mapDesc_comp, P.cancel_right_of_respectsIso]\n    apply H\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.diagonal_of_openCover","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninst✝² : AlgebraicGeometry.HasAffineProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n𝒰 : Y.OpenCover\ninst✝¹ : ∀ (i : 𝒰.J), AlgebraicGeometry.IsAffine (𝒰.obj i)\n𝒰' : (i : 𝒰.J) → (CategoryTheory.Limits.pullback f (𝒰.map i)).OpenCover\ninst✝ : ∀ (i : 𝒰.J) (j : (𝒰' i).J), AlgebraicGeometry.IsAffine ((𝒰' i).obj j)\nh𝒰' : ∀ (i : 𝒰.J) (j k : (𝒰' i).J), Q (CategoryTheory.Limits.pullback.mapDesc ((𝒰' i).map j) ((𝒰' i).map k) (AlgebraicGeometry.Scheme.Cover.pullbackHom 𝒰 f i))\n⊢ P.diagonal f","decl":"theorem HasAffineProperty.diagonal_of_openCover (P) {Q} [HasAffineProperty P Q]\n    {X Y : Scheme.{u}} (f : X ⟶ Y) (𝒰 : Scheme.OpenCover.{u} Y) [∀ i, IsAffine (𝒰.obj i)]\n    (𝒰' : ∀ i, Scheme.OpenCover.{u} (pullback f (𝒰.map i))) [∀ i j, IsAffine ((𝒰' i).obj j)]\n    (h𝒰' : ∀ i j k,\n      Q (pullback.mapDesc ((𝒰' i).map j) ((𝒰' i).map k) (𝒰.pullbackHom f i))) :\n    P.diagonal f := by\n  letI := isLocal_affineProperty P\n  let 𝒱 := (Scheme.Pullback.openCoverOfBase 𝒰 f f).bind fun i =>\n    Scheme.Pullback.openCoverOfLeftRight.{u} (𝒰' i) (𝒰' i) (pullback.snd _ _) (pullback.snd _ _)\n  have i1 : ∀ i, IsAffine (𝒱.obj i) := fun i => by dsimp [𝒱]; infer_instance\n  apply of_openCover 𝒱\n  rintro ⟨i, j, k⟩\n  dsimp [𝒱]\n  convert (Q.cancel_left_of_respectsIso\n    ((pullbackDiagonalMapIso _ _ ((𝒰' i).map j) ((𝒰' i).map k)).inv ≫\n      pullback.map _ _ _ _ (𝟙 _) (𝟙 _) (𝟙 _) _ _) (pullback.snd _ _)).mp _ using 1\n  · simp\n  · ext1 <;> simp\n  · simp only [Category.assoc, limit.lift_π, PullbackCone.mk_pt, PullbackCone.mk_π_app,\n      Functor.const_obj_obj, cospan_one, cospan_left, cospan_right, Category.comp_id]\n    convert h𝒰' i j k\n    ext1 <;> simp [Scheme.Cover.pullbackHom]\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.diagonal_of_openCover_diagonal","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninst✝¹ : AlgebraicGeometry.HasAffineProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n𝒰 : Y.OpenCover\ninst✝ : ∀ (i : 𝒰.J), AlgebraicGeometry.IsAffine (𝒰.obj i)\nh𝒰 : ∀ (i : 𝒰.1), Q.diagonal (AlgebraicGeometry.Scheme.Cover.pullbackHom 𝒰 f i)\n⊢ P.diagonal f","decl":"theorem HasAffineProperty.diagonal_of_openCover_diagonal\n    (P) {Q} [HasAffineProperty P Q]\n    {X Y : Scheme.{u}} (f : X ⟶ Y) (𝒰 : Scheme.OpenCover.{u} Y) [∀ i, IsAffine (𝒰.obj i)]\n    (h𝒰 : ∀ i, Q.diagonal (𝒰.pullbackHom f i)) :\n    P.diagonal f :=\n  diagonal_of_openCover P f 𝒰 (fun _ ↦ Scheme.affineCover _)\n    (fun _ _ _ ↦ h𝒰 _ _ _)\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.diagonal_of_diagonal_of_isPullback","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninst✝² : AlgebraicGeometry.HasAffineProperty P Q\nX Y U V : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom U Y\ninst✝¹ : AlgebraicGeometry.IsAffine U\ninst✝ : AlgebraicGeometry.IsOpenImmersion g\niV : Quiver.Hom V X\nf' : Quiver.Hom V U\nh : CategoryTheory.IsPullback iV f' f g\nH : P.diagonal f\n⊢ Q.diagonal f'","decl":"theorem HasAffineProperty.diagonal_of_diagonal_of_isPullback\n    (P) {Q} [HasAffineProperty P Q]\n    {X Y U V : Scheme.{u}} {f : X ⟶ Y} {g : U ⟶ Y}\n    [IsAffine U] [IsOpenImmersion g]\n    {iV : V ⟶ X} {f' : V ⟶ U} (h : IsPullback iV f' f g) (H : P.diagonal f) :\n    Q.diagonal f' := by\n  letI := isLocal_affineProperty P\n  rw [← Q.diagonal.cancel_left_of_respectsIso h.isoPullback.inv,\n    h.isoPullback_inv_snd]\n  rintro U V f₁ f₂ hU hV hf₁ hf₂\n  rw [← Q.cancel_left_of_respectsIso (pullbackDiagonalMapIso f _ f₁ f₂).hom]\n  convert HasAffineProperty.of_isPullback (P := P) (.of_hasPullback _ _) H\n  · apply pullback.hom_ext <;> simp\n  · infer_instance\n  · infer_instance\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.diagonal_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninst✝¹ : AlgebraicGeometry.HasAffineProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsAffine Y\n⊢ Iff (Q.diagonal f) (P.diagonal f)","decl":"theorem HasAffineProperty.diagonal_iff\n    (P) {Q} [HasAffineProperty P Q] {X Y} {f : X ⟶ Y} [IsAffine Y] :\n    Q.diagonal f ↔ P.diagonal f := by\n  letI := isLocal_affineProperty P\n  refine ⟨fun hf ↦ ?_, diagonal_of_diagonal_of_isPullback P .of_id_fst⟩\n  rw [← Q.diagonal.cancel_left_of_respectsIso\n    (pullback.fst (f := f) (g := 𝟙 Y)), pullback.condition, Category.comp_id] at hf\n  let 𝒰 := X.affineCover.pushforwardIso (inv (pullback.fst (f := f) (g := 𝟙 Y)))\n  have (i) : IsAffine (𝒰.obj i) := by dsimp [𝒰]; infer_instance\n  exact HasAffineProperty.diagonal_of_openCover P f (Scheme.coverOfIsIso (𝟙 _))\n    (fun _ ↦ 𝒰) (fun _ _ _ ↦ hf _ _)\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.diagonal_affineProperty_isLocal","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"Q : AlgebraicGeometry.AffineTargetMorphismProperty\ninst✝ : Q.IsLocal\n⊢ Q.diagonal.IsLocal","decl":"instance HasAffineProperty.diagonal_affineProperty_isLocal\n    {Q : AffineTargetMorphismProperty} [Q.IsLocal] :\n    Q.diagonal.IsLocal where\n  respectsIso := inferInstance\n  to_basicOpen {_ Y} _ f r hf :=\n    diagonal_of_diagonal_of_isPullback (targetAffineLocally Q)\n      (isPullback_morphismRestrict f (Y.basicOpen r)).flip\n      ((diagonal_iff (targetAffineLocally Q)).mp hf)\n  of_basicOpenCover {X Y} _ f s hs hs' := by\n    refine (diagonal_iff (targetAffineLocally Q)).mpr ?_\n    let 𝒰 := Y.openCoverOfISupEqTop _ (((isAffineOpen_top Y).basicOpen_union_eq_self_iff _).mpr hs)\n    have (i) : IsAffine (𝒰.obj i) := (isAffineOpen_top Y).basicOpen i.1\n    refine diagonal_of_openCover_diagonal (targetAffineLocally Q) f 𝒰 ?_\n    intro i\n    exact (Q.diagonal.arrow_mk_iso_iff\n      (morphismRestrictEq _ (by simp [𝒰]) ≪≫ morphismRestrictOpensRange _ _)).mp (hs' i)\n\n"}
{"name":"AlgebraicGeometry.instHasAffinePropertyDiagonalSchemeDiagonal","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninst✝ : AlgebraicGeometry.HasAffineProperty P Q\n⊢ AlgebraicGeometry.HasAffineProperty P.diagonal Q.diagonal","decl":"instance (P) {Q} [HasAffineProperty P Q] : HasAffineProperty P.diagonal Q.diagonal where\n  isLocal_affineProperty := letI := HasAffineProperty.isLocal_affineProperty P; inferInstance\n  eq_targetAffineLocally' := by\n    ext X Y f\n    letI := HasAffineProperty.isLocal_affineProperty P\n    constructor\n    · exact fun H U ↦ HasAffineProperty.diagonal_of_diagonal_of_isPullback P\n        (isPullback_morphismRestrict f U).flip H\n    · exact fun H ↦ HasAffineProperty.diagonal_of_openCover_diagonal P f Y.affineCover\n        (fun i ↦ of_targetAffineLocally_of_isPullback (.of_hasPullback _ _) H)\n\n"}
{"name":"AlgebraicGeometry.instIsLocalAtTargetDiagonalScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝ : AlgebraicGeometry.IsLocalAtTarget P\n⊢ AlgebraicGeometry.IsLocalAtTarget P.diagonal","decl":"instance (P) [IsLocalAtTarget P] : IsLocalAtTarget P.diagonal :=\n  letI := HasAffineProperty.of_isLocalAtTarget P\n  inferInstance\n\n"}
{"name":"AlgebraicGeometry.universally_isLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nhP₂ : ∀ {X Y : AlgebraicGeometry.Scheme} (f : Quiver.Hom X Y) {ι : Type u} (U : ι → Y.Opens), Eq (iSup U) Top.top → (∀ (i : ι), P (AlgebraicGeometry.morphismRestrict f (U i))) → P f\n⊢ AlgebraicGeometry.IsLocalAtTarget P.universally","decl":"theorem universally_isLocalAtTarget (P : MorphismProperty Scheme)\n    (hP₂ : ∀ {X Y : Scheme.{u}} (f : X ⟶ Y) {ι : Type u} (U : ι → Y.Opens)\n      (_ : iSup U = ⊤), (∀ i, P (f ∣_ U i)) → P f) : IsLocalAtTarget P.universally := by\n  apply IsLocalAtTarget.mk'\n  · exact fun {X Y} f U => P.universally.of_isPullback\n      (isPullback_morphismRestrict f U).flip\n  · intros X Y f ι U hU H X' Y' i₁ i₂ f' h\n    apply hP₂ _ (fun i ↦ i₂ ⁻¹ᵁ U i)\n    · rw [← top_le_iff] at hU ⊢\n      rintro x -\n      simpa using @hU (i₂.base x) trivial\n    · rintro i\n      refine H _ ((X'.isoOfEq ?_).hom ≫ i₁ ∣_ _) (i₂ ∣_ _) _ ?_\n      · exact congr($(h.1.1) ⁻¹ᵁ U i)\n      · rw [← (isPullback_morphismRestrict f _).paste_vert_iff]\n        · simp only [Category.assoc, morphismRestrict_ι, Scheme.isoOfEq_hom_ι_assoc]\n          exact (isPullback_morphismRestrict f' (i₂ ⁻¹ᵁ U i)).paste_vert h\n        · rw [← cancel_mono (Scheme.Opens.ι _)]\n          simp [morphismRestrict_ι_assoc, h.1.1]\n\n"}
{"name":"AlgebraicGeometry.topologically_isStableUnderComposition","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : {α β : Type u} → [inst : TopologicalSpace α] → [inst : TopologicalSpace β] → (α → β) → Prop\nhP : ∀ {α β γ : Type u} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ] (f : α → β) (g : β → γ), P f → P g → P (Function.comp g f)\n⊢ (AlgebraicGeometry.topologically fun {α β} [TopologicalSpace α] [TopologicalSpace β] => P).IsStableUnderComposition","decl":"/-- If a property of maps of topological spaces is stable under composition, the induced\nmorphism property of schemes is stable under composition. -/\nlemma topologically_isStableUnderComposition\n    (hP : ∀ {α β γ : Type u} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ]\n      (f : α → β) (g : β → γ) (_ : P f) (_ : P g), P (g ∘ f)) :\n    (topologically P).IsStableUnderComposition where\n  comp_mem {X Y Z} f g hf hg := by\n    simp only [topologically, Scheme.comp_coeBase, TopCat.coe_comp]\n    exact hP _ _ hf hg\n\n"}
{"name":"AlgebraicGeometry.topologically_iso_le","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : {α β : Type u} → [inst : TopologicalSpace α] → [inst : TopologicalSpace β] → (α → β) → Prop\nhP : ∀ {α β : Type u} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (f : Homeomorph α β), P ⇑f\n⊢ LE.le (CategoryTheory.MorphismProperty.isomorphisms AlgebraicGeometry.Scheme) (AlgebraicGeometry.topologically fun {α β} [TopologicalSpace α] [TopologicalSpace β] => P)","decl":"/-- If a property of maps of topological spaces is satisfied by all homeomorphisms,\nevery isomorphism of schemes satisfies the induced property. -/\nlemma topologically_iso_le\n    (hP : ∀ {α β : Type u} [TopologicalSpace α] [TopologicalSpace β] (f : α ≃ₜ β), P f) :\n    MorphismProperty.isomorphisms Scheme ≤ (topologically P) := by\n  intro X Y e (he : IsIso e)\n  have : IsIso e := he\n  exact hP (TopCat.homeoOfIso (asIso e.base))\n\n"}
{"name":"AlgebraicGeometry.topologically_respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : {α β : Type u} → [inst : TopologicalSpace α] → [inst : TopologicalSpace β] → (α → β) → Prop\nhP₁ : ∀ {α β : Type u} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (f : Homeomorph α β), P ⇑f\nhP₂ : ∀ {α β γ : Type u} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ] (f : α → β) (g : β → γ), P f → P g → P (Function.comp g f)\n⊢ (AlgebraicGeometry.topologically fun {α β} [TopologicalSpace α] [TopologicalSpace β] => P).RespectsIso","decl":"/-- If a property of maps of topological spaces is satisfied by homeomorphisms and is stable\nunder composition, the induced property on schemes respects isomorphisms. -/\nlemma topologically_respectsIso\n    (hP₁ : ∀ {α β : Type u} [TopologicalSpace α] [TopologicalSpace β] (f : α ≃ₜ β), P f)\n    (hP₂ : ∀ {α β γ : Type u} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ]\n      (f : α → β) (g : β → γ) (_ : P f) (_ : P g), P (g ∘ f)) :\n      (topologically P).RespectsIso :=\n  have : (topologically P).IsStableUnderComposition :=\n    topologically_isStableUnderComposition P hP₂\n  MorphismProperty.respectsIso_of_isStableUnderComposition (topologically_iso_le P hP₁)\n\n"}
{"name":"AlgebraicGeometry.topologically_isLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : {α β : Type u} → [inst : TopologicalSpace α] → [inst : TopologicalSpace β] → (α → β) → Prop\ninst✝ : (AlgebraicGeometry.topologically fun {α β} [TopologicalSpace α] [TopologicalSpace β] => P).RespectsIso\nhP₂ : ∀ {α β : Type u} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (f : α → β) (s : Set β), Continuous f → IsOpen s → P f → P (s.restrictPreimage f)\nhP₃ : ∀ {α β : Type u} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (f : α → β) {ι : Type u} (U : ι → TopologicalSpace.Opens β), Eq (iSup U) Top.top → Continuous f → (∀ (i : ι), P ((U i).carrier.restrictPreimage f)) → P f\n⊢ AlgebraicGeometry.IsLocalAtTarget (AlgebraicGeometry.topologically fun {α β} [TopologicalSpace α] [TopologicalSpace β] => P)","decl":"/-- To check that a topologically defined morphism property is local at the target,\nwe may check the corresponding properties on topological spaces. -/\nlemma topologically_isLocalAtTarget\n    [(topologically P).RespectsIso]\n    (hP₂ : ∀ {α β : Type u} [TopologicalSpace α] [TopologicalSpace β] (f : α → β) (s : Set β)\n      (_ : Continuous f) (_ : IsOpen s), P f → P (s.restrictPreimage f))\n    (hP₃ : ∀ {α β : Type u} [TopologicalSpace α] [TopologicalSpace β] (f : α → β) {ι : Type u}\n      (U : ι → TopologicalSpace.Opens β) (_ : iSup U = ⊤) (_ : Continuous f),\n      (∀ i, P ((U i).carrier.restrictPreimage f)) → P f) :\n    IsLocalAtTarget (topologically P) := by\n  apply IsLocalAtTarget.mk'\n  · intro X Y f U hf\n    simp_rw [topologically, morphismRestrict_base]\n    exact hP₂ f.base U.carrier f.base.2 U.2 hf\n  · intro X Y f ι U hU hf\n    apply hP₃ f.base U hU f.base.continuous fun i ↦ ?_\n    rw [← morphismRestrict_base]\n    exact hf i\n\n"}
{"name":"AlgebraicGeometry.topologically_isLocalAtTarget'","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : {α β : Type u} → [inst : TopologicalSpace α] → [inst : TopologicalSpace β] → (α → β) → Prop\ninst✝ : (AlgebraicGeometry.topologically fun {α β} [TopologicalSpace α] [TopologicalSpace β] => P).RespectsIso\nhP : ∀ {α β : Type u} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (f : α → β) {ι : Type u} (U : ι → TopologicalSpace.Opens β), Eq (iSup U) Top.top → Continuous f → Iff (P f) (∀ (i : ι), P ((U i).carrier.restrictPreimage f))\n⊢ AlgebraicGeometry.IsLocalAtTarget (AlgebraicGeometry.topologically fun {α β} [TopologicalSpace α] [TopologicalSpace β] => P)","decl":"/-- A variant of `topologically_isLocalAtTarget`\nthat takes one iff statement instead of two implications. -/\nlemma topologically_isLocalAtTarget'\n    [(topologically P).RespectsIso]\n    (hP : ∀ {α β : Type u} [TopologicalSpace α] [TopologicalSpace β] (f : α → β) {ι : Type u}\n      (U : ι → TopologicalSpace.Opens β) (_ : iSup U = ⊤) (_ : Continuous f),\n      P f ↔ (∀ i, P ((U i).carrier.restrictPreimage f))) :\n    IsLocalAtTarget (topologically P) := by\n  refine topologically_isLocalAtTarget P ?_ (fun f _ U hU hU' ↦ (hP f U hU hU').mpr)\n  introv hf hs H\n  have := (hP f (![⊤, Opens.mk s hs] ∘ Equiv.ulift) ?_ hf).mp H ⟨1⟩\n  · simpa using this\n  · rw [← top_le_iff]\n    exact le_iSup (![⊤, Opens.mk s hs] ∘ Equiv.ulift) ⟨0⟩\n\n"}
{"name":"AlgebraicGeometry.stalkwise_respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\n⊢ (AlgebraicGeometry.stalkwise fun {R S} [CommRing R] [CommRing S] => P).RespectsIso","decl":"/-- If `P` respects isos, then `stalkwise P` respects isos. -/\nlemma stalkwise_respectsIso (hP : RingHom.RespectsIso P) :\n    (stalkwise P).RespectsIso where\n  precomp {X Y Z} e (he : IsIso e) f hf := by\n    simp only [stalkwise, Scheme.comp_coeBase, TopCat.coe_comp, Function.comp_apply]\n    intro x\n    rw [Scheme.stalkMap_comp]\n    exact (RingHom.RespectsIso.cancel_right_isIso hP _ _).mpr <| hf (e.base x)\n  postcomp {X Y Z} e (he : IsIso _) f hf := by\n    simp only [stalkwise, Scheme.comp_coeBase, TopCat.coe_comp, Function.comp_apply]\n    intro x\n    rw [Scheme.stalkMap_comp]\n    exact (RingHom.RespectsIso.cancel_left_isIso hP _ _).mpr <| hf x\n\n"}
{"name":"AlgebraicGeometry.stalkwiseIsLocalAtTarget_of_respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\n⊢ AlgebraicGeometry.IsLocalAtTarget (AlgebraicGeometry.stalkwise fun {R S} [CommRing R] [CommRing S] => P)","decl":"/-- If `P` respects isos, then `stalkwise P` is local at the target. -/\nlemma stalkwiseIsLocalAtTarget_of_respectsIso (hP : RingHom.RespectsIso P) :\n    IsLocalAtTarget (stalkwise P) := by\n  have hP' : (RingHom.toMorphismProperty P).RespectsIso :=\n    RingHom.toMorphismProperty_respectsIso_iff.mp hP\n  letI := stalkwise_respectsIso hP\n  apply IsLocalAtTarget.mk'\n  · intro X Y f U hf x\n    apply ((RingHom.toMorphismProperty P).arrow_mk_iso_iff <|\n      morphismRestrictStalkMap f U x).mpr <| hf _\n  · intro X Y f ι U hU hf x\n    have hy : f.base x ∈ iSup U := by rw [hU]; trivial\n    obtain ⟨i, hi⟩ := Opens.mem_iSup.mp hy\n    exact ((RingHom.toMorphismProperty P).arrow_mk_iso_iff <|\n      morphismRestrictStalkMap f (U i) ⟨x, hi⟩).mp <| hf i ⟨x, hi⟩\n\n"}
{"name":"AlgebraicGeometry.stalkwise_isLocalAtSource_of_respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\n⊢ AlgebraicGeometry.IsLocalAtSource (AlgebraicGeometry.stalkwise fun {R S} [CommRing R] [CommRing S] => P)","decl":"/-- If `P` respects isos, then `stalkwise P` is local at the source. -/\nlemma stalkwise_isLocalAtSource_of_respectsIso (hP : RingHom.RespectsIso P) :\n    IsLocalAtSource (stalkwise P) := by\n  letI := stalkwise_respectsIso hP\n  apply IsLocalAtSource.mk'\n  · intro X Y f U hf x\n    rw [Scheme.stalkMap_comp, CommRingCat.hom_comp, hP.cancel_right_isIso]\n    exact hf _\n  · intro X Y f ι U hU hf x\n    have hy : x ∈ iSup U := by rw [hU]; trivial\n    obtain ⟨i, hi⟩ := Opens.mem_iSup.mp hy\n    rw [← hP.cancel_right_isIso _ ((U i).ι.stalkMap ⟨x, hi⟩)]\n    simpa [Scheme.stalkMap_comp] using hf i ⟨x, hi⟩\n\n"}
{"name":"AlgebraicGeometry.stalkwise_Spec_map_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nR S : CommRingCat\nφ : Quiver.Hom R S\n⊢ Iff (AlgebraicGeometry.stalkwise (fun {R S} [CommRing R] [CommRing S] => P) (AlgebraicGeometry.Spec.map φ)) (∀ (p : Ideal ↑S) (x : p.IsPrime), P (Localization.localRingHom (Ideal.comap (CommRingCat.Hom.hom φ) p) p (CommRingCat.Hom.hom φ) ⋯))","decl":"lemma stalkwise_Spec_map_iff (hP : RingHom.RespectsIso P) {R S : CommRingCat} (φ : R ⟶ S) :\n    stalkwise P (Spec.map φ) ↔ ∀ (p : Ideal S) (_ : p.IsPrime),\n      P (Localization.localRingHom _ p φ.hom rfl) := by\n  have hP' : (RingHom.toMorphismProperty P).RespectsIso :=\n    RingHom.toMorphismProperty_respectsIso_iff.mp hP\n  trans ∀ (p : PrimeSpectrum S), P (Localization.localRingHom _ p.asIdeal φ.hom rfl)\n  · exact forall_congr' fun p ↦\n      (RingHom.toMorphismProperty P).arrow_mk_iso_iff (Scheme.arrowStalkMapSpecIso _ _)\n  · exact ⟨fun H p hp ↦ H ⟨p, hp⟩, fun H p ↦ H p.1 p.2⟩\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.isStableUnderBaseChange_of_isStableUnderBaseChangeOnAffine_of_isLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.Constructors","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝ : AlgebraicGeometry.IsLocalAtTarget P\nhP₂ : (AlgebraicGeometry.AffineTargetMorphismProperty.of P).IsStableUnderBaseChange\n⊢ P.IsStableUnderBaseChange","decl":"/-- If `P` is local at the target, to show that `P` is stable under base change, it suffices to\ncheck this for base change along a morphism of affine schemes. -/\nlemma isStableUnderBaseChange_of_isStableUnderBaseChangeOnAffine_of_isLocalAtTarget\n    (P : MorphismProperty Scheme) [IsLocalAtTarget P]\n    (hP₂ : (of P).IsStableUnderBaseChange) :\n    P.IsStableUnderBaseChange :=\n  letI := HasAffineProperty.of_isLocalAtTarget P\n  HasAffineProperty.isStableUnderBaseChange hP₂\n\n"}
