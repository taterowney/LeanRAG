{"name":"SSet.StrictSegal.spineToSimplex_spine","module":"Mathlib.AlgebraicTopology.SimplicialSet.StrictSegal","initialProofState":"X : SSet\nself : X.StrictSegal\nn : Nat\nΔ : X.obj { unop := SimplexCategory.mk n }\n⊢ Eq (SSet.StrictSegal.spineToSimplex (X.spine n Δ)) Δ","decl":"/-- A simplicial set `X` satisfies the strict Segal condition if its simplices are uniquely\ndetermined by their spine. -/\nclass StrictSegal where\n  /-- The inverse to `X.spine n`.-/\n  spineToSimplex {n : ℕ} : Path X n → X _[n]\n  /-- `spineToSimplex` is a right inverse to `X.spine n`.-/\n  spine_spineToSimplex {n : ℕ} (f : Path X n) : X.spine n (spineToSimplex f) = f\n  /-- `spineToSimplex` is a left inverse to `X.spine n`.-/\n  spineToSimplex_spine {n : ℕ} (Δ : X _[n]) : spineToSimplex (X.spine n Δ) = Δ\n\n"}
{"name":"SSet.StrictSegal.spine_spineToSimplex","module":"Mathlib.AlgebraicTopology.SimplicialSet.StrictSegal","initialProofState":"X : SSet\nself : X.StrictSegal\nn : Nat\nf : X.Path n\n⊢ Eq (X.spine n (SSet.StrictSegal.spineToSimplex f)) f","decl":"/-- A simplicial set `X` satisfies the strict Segal condition if its simplices are uniquely\ndetermined by their spine. -/\nclass StrictSegal where\n  /-- The inverse to `X.spine n`.-/\n  spineToSimplex {n : ℕ} : Path X n → X _[n]\n  /-- `spineToSimplex` is a right inverse to `X.spine n`.-/\n  spine_spineToSimplex {n : ℕ} (f : Path X n) : X.spine n (spineToSimplex f) = f\n  /-- `spineToSimplex` is a left inverse to `X.spine n`.-/\n  spineToSimplex_spine {n : ℕ} (Δ : X _[n]) : spineToSimplex (X.spine n Δ) = Δ\n\n"}
{"name":"SSet.StrictSegal.spineInjective","module":"Mathlib.AlgebraicTopology.SimplicialSet.StrictSegal","initialProofState":"X : SSet\ninst✝ : X.StrictSegal\nn : Nat\n⊢ Function.Injective ⇑(SSet.StrictSegal.spineEquiv n)","decl":"theorem spineInjective {n : ℕ} : Function.Injective (spineEquiv (X := X) n) := Equiv.injective _\n\n"}
{"name":"SSet.StrictSegal.spineToSimplex_vertex","module":"Mathlib.AlgebraicTopology.SimplicialSet.StrictSegal","initialProofState":"X : SSet\ninst✝ : X.StrictSegal\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nf : X.Path n\n⊢ Eq (X.map ((SimplexCategory.mk 0).const (SimplexCategory.mk n) i).op (SSet.StrictSegal.spineToSimplex f)) (f.vertex i)","decl":"@[simp]\ntheorem spineToSimplex_vertex (i : Fin (n + 1)) (f : Path X n) :\n    X.map (const [0] [n] i).op (spineToSimplex f) = f.vertex i := by\n  rw [← spine_vertex, spine_spineToSimplex]\n\n"}
{"name":"SSet.StrictSegal.spineToSimplex_arrow","module":"Mathlib.AlgebraicTopology.SimplicialSet.StrictSegal","initialProofState":"X : SSet\ninst✝ : X.StrictSegal\nn : Nat\ni : Fin n\nf : X.Path n\n⊢ Eq (X.map (SimplexCategory.mkOfSucc i).op (SSet.StrictSegal.spineToSimplex f)) (f.arrow i)","decl":"@[simp]\ntheorem spineToSimplex_arrow (i : Fin n) (f : Path X n) :\n    X.map (mkOfSucc i).op (spineToSimplex f) = f.arrow i := by\n  rw [← spine_arrow, spine_spineToSimplex]\n\n"}
{"name":"SSet.StrictSegal.spineToSimplex_interval","module":"Mathlib.AlgebraicTopology.SimplicialSet.StrictSegal","initialProofState":"X : SSet\ninst✝ : X.StrictSegal\nn : Nat\nf : X.Path n\nj l : Nat\nhjl : LE.le (HAdd.hAdd j l) n\n⊢ Eq (X.map (SimplexCategory.subinterval j l hjl).op (SSet.StrictSegal.spineToSimplex f)) (SSet.StrictSegal.spineToSimplex (f.interval j l hjl))","decl":"@[simp]\ntheorem spineToSimplex_interval (f : Path X n) (j l : ℕ) (hjl : j + l ≤  n)  :\n    X.map (subinterval j l hjl).op (spineToSimplex f) =\n      spineToSimplex (Path.interval f j l hjl) := by\n  apply spineInjective\n  unfold spineEquiv\n  dsimp\n  rw [spine_spineToSimplex]\n  convert spine_map_subinterval X j l hjl (spineToSimplex f)\n  exact Eq.symm (spine_spineToSimplex f)\n\n"}
{"name":"SSet.StrictSegal.spineToSimplex_edge","module":"Mathlib.AlgebraicTopology.SimplicialSet.StrictSegal","initialProofState":"X : SSet\ninst✝ : X.StrictSegal\nn : Nat\nf : X.Path n\nj l : Nat\nhjl : LE.le (HAdd.hAdd j l) n\n⊢ Eq (X.map (SimplexCategory.intervalEdge j l hjl).op (SSet.StrictSegal.spineToSimplex f)) (SSet.StrictSegal.spineToDiagonal (f.interval j l hjl))","decl":"theorem spineToSimplex_edge (f : Path X n) (j l : ℕ) (hjl : j + l ≤ n) :\n    X.map (intervalEdge j l hjl).op (spineToSimplex f) =\n      spineToDiagonal (Path.interval f j l hjl) := by\n  unfold spineToDiagonal\n  rw [← congrArg (diagonal X) (spineToSimplex_interval f j l hjl)]\n  unfold diagonal\n  simp only [← FunctorToTypes.map_comp_apply, ← op_comp, diag_subinterval_eq]\n\n"}
{"name":"SSet.StrictSegal.spineToSimplex_map","module":"Mathlib.AlgebraicTopology.SimplicialSet.StrictSegal","initialProofState":"X Y : SSet\ninst✝¹ : X.StrictSegal\ninst✝ : Y.StrictSegal\nn : Nat\nf : X.Path (HAdd.hAdd n 1)\nσ : Quiver.Hom X Y\n⊢ Eq (SSet.StrictSegal.spineToSimplex (f.map σ)) (σ.app { unop := SimplexCategory.mk (HAdd.hAdd n 1) } (SSet.StrictSegal.spineToSimplex f))","decl":"/-- For any `σ : X ⟶ Y` between `StrictSegal` simplicial sets, `spineToSimplex`\ncommutes with `Path.map`. -/\nlemma spineToSimplex_map {X Y : SSet.{u}} [StrictSegal X] [StrictSegal Y]\n    {n : ℕ} (f : Path X (n + 1)) (σ : X ⟶ Y) :\n    spineToSimplex (f.map σ) = σ.app _ (spineToSimplex f) := by\n  apply spineInjective\n  ext k\n  dsimp only [spineEquiv, Equiv.coe_fn_mk, Path.map, spine_arrow]\n  rw [← types_comp_apply (σ.app _) (Y.map _), ← σ.naturality]\n  simp only [types_comp_apply, spineToSimplex_arrow]\n\n"}
{"name":"SSet.StrictSegal.spine_δ_vertex_lt","module":"Mathlib.AlgebraicTopology.SimplicialSet.StrictSegal","initialProofState":"X : SSet\ninst✝ : X.StrictSegal\nn : Nat\nf : X.Path (HAdd.hAdd n 1)\ni : Fin (HAdd.hAdd n 1)\nj : Fin (HAdd.hAdd n 2)\nh : LT.lt i.castSucc j\n⊢ Eq ((X.spine n (CategoryTheory.SimplicialObject.δ X j (SSet.StrictSegal.spineToSimplex f))).vertex i) (f.vertex i.castSucc)","decl":"/-- If we take the path along the spine of the `j`th face of a `spineToSimplex`,\nthe common vertices will agree with those of the original path `f`. In particular,\na vertex `i` with `i < j` can be identified with the same vertex in `f`. -/\nlemma spine_δ_vertex_lt (f : Path X (n + 1)) {i : Fin (n + 1)} {j : Fin (n + 2)}\n    (h : i.castSucc < j) :\n    (X.spine n (X.δ j (spineToSimplex f))).vertex i = f.vertex i.castSucc := by\n  simp only [SimplicialObject.δ, spine_vertex]\n  rw [← FunctorToTypes.map_comp_apply, ← op_comp, const_comp, spineToSimplex_vertex]\n  simp only [SimplexCategory.δ, Hom.toOrderHom, len_mk, mkHom, Hom.mk,\n    OrderEmbedding.toOrderHom_coe, Fin.succAboveOrderEmb_apply]\n  rw [Fin.succAbove_of_castSucc_lt j i h]\n\n"}
{"name":"SSet.StrictSegal.spine_δ_vertex_ge","module":"Mathlib.AlgebraicTopology.SimplicialSet.StrictSegal","initialProofState":"X : SSet\ninst✝ : X.StrictSegal\nn : Nat\nf : X.Path (HAdd.hAdd n 1)\ni : Fin (HAdd.hAdd n 1)\nj : Fin (HAdd.hAdd n 2)\nh : LE.le j i.castSucc\n⊢ Eq ((X.spine n (CategoryTheory.SimplicialObject.δ X j (SSet.StrictSegal.spineToSimplex f))).vertex i) (f.vertex i.succ)","decl":"/-- If we take the path along the spine of the `j`th face of a `spineToSimplex`,\na vertex `i` with `i ≥ j` can be identified with vertex `i + 1` in the original\npath. -/\nlemma spine_δ_vertex_ge (f : Path X (n + 1)) {i : Fin (n + 1)} {j : Fin (n + 2)}\n    (h : j ≤ i.castSucc) :\n    (X.spine n (X.δ j (spineToSimplex f))).vertex i = f.vertex i.succ := by\n  simp only [SimplicialObject.δ, spine_vertex]\n  rw [← FunctorToTypes.map_comp_apply, ← op_comp, const_comp, spineToSimplex_vertex]\n  simp only [SimplexCategory.δ, Hom.toOrderHom, len_mk, mkHom, Hom.mk,\n    OrderEmbedding.toOrderHom_coe, Fin.succAboveOrderEmb_apply]\n  rw [Fin.succAbove_of_le_castSucc j i h]\n\n"}
{"name":"SSet.StrictSegal.spine_δ_arrow_lt","module":"Mathlib.AlgebraicTopology.SimplicialSet.StrictSegal","initialProofState":"X : SSet\ninst✝ : X.StrictSegal\nn : Nat\nf : X.Path (HAdd.hAdd n 1)\ni : Fin n\nj : Fin (HAdd.hAdd n 2)\nh : LT.lt i.succ.castSucc j\n⊢ Eq ((X.spine n (CategoryTheory.SimplicialObject.δ X j (SSet.StrictSegal.spineToSimplex f))).arrow i) (f.arrow i.castSucc)","decl":"/-- If we take the path along the spine of the `j`th face of a `spineToSimplex`,\nthe common arrows will agree with those of the original path `f`. In particular,\nan arrow `i` with `i + 1 < j` can be identified with the same arrow in `f`. -/\nlemma spine_δ_arrow_lt (f : Path X (n + 1)) {i : Fin n} {j : Fin (n + 2)}\n    (h : i.succ.castSucc < j) :\n    (X.spine n (X.δ j (spineToSimplex f))).arrow i = f.arrow i.castSucc := by\n  simp only [SimplicialObject.δ, spine_arrow]\n  rw [← FunctorToTypes.map_comp_apply, ← op_comp]\n  rw [mkOfSucc_δ_lt h, spineToSimplex_arrow]\n\n"}
{"name":"SSet.StrictSegal.spine_δ_arrow_gt","module":"Mathlib.AlgebraicTopology.SimplicialSet.StrictSegal","initialProofState":"X : SSet\ninst✝ : X.StrictSegal\nn : Nat\nf : X.Path (HAdd.hAdd n 1)\ni : Fin n\nj : Fin (HAdd.hAdd n 2)\nh : LT.lt j i.succ.castSucc\n⊢ Eq ((X.spine n (CategoryTheory.SimplicialObject.δ X j (SSet.StrictSegal.spineToSimplex f))).arrow i) (f.arrow i.succ)","decl":"/-- If we take the path along the spine of the `j`th face of a `spineToSimplex`,\nan arrow `i` with `i + 1 > j` can be identified with arrow `i + 1` in the\noriginal path. -/\nlemma spine_δ_arrow_gt (f : Path X (n + 1)) {i : Fin n} {j : Fin (n + 2)}\n    (h : j < i.succ.castSucc) :\n    (X.spine n (X.δ j (spineToSimplex f))).arrow i = f.arrow i.succ := by\n  simp only [SimplicialObject.δ, spine_arrow]\n  rw [← FunctorToTypes.map_comp_apply, ← op_comp]\n  rw [mkOfSucc_δ_gt h, spineToSimplex_arrow]\n\n"}
{"name":"SSet.StrictSegal.spine_δ_arrow_eq","module":"Mathlib.AlgebraicTopology.SimplicialSet.StrictSegal","initialProofState":"X : SSet\ninst✝ : X.StrictSegal\nn : Nat\nf : X.Path (HAdd.hAdd n 1)\ni : Fin n\nj : Fin (HAdd.hAdd n 2)\nh : Eq j i.succ.castSucc\n⊢ Eq ((X.spine n (CategoryTheory.SimplicialObject.δ X j (SSet.StrictSegal.spineToSimplex f))).arrow i) (SSet.StrictSegal.spineToDiagonal (f.interval (↑i) 2 ⋯))","decl":"/-- If we take the path along the spine of a face of a `spineToSimplex`, the\narrows not contained in the original path can be recovered as the diagonal edge\nof the `spineToSimplex` that \"composes\" arrows `i` and `i + 1`. -/\nlemma spine_δ_arrow_eq (f : Path X (n + 1)) {i : Fin n} {j : Fin (n + 2)}\n    (h : j = i.succ.castSucc) :\n    (X.spine n (X.δ j (spineToSimplex f))).arrow i =\n      spineToDiagonal (Path.interval f i 2 (by omega)) := by\n  simp only [SimplicialObject.δ, spine_arrow]\n  rw [← FunctorToTypes.map_comp_apply, ← op_comp]\n  rw [mkOfSucc_δ_eq h, spineToSimplex_edge]\n\n"}
