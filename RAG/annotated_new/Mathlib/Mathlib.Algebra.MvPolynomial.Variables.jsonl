{"name":"MvPolynomial.vars_def","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\np : MvPolynomial σ R\n⊢ Eq p.vars p.degrees.toFinset","decl":"theorem vars_def [DecidableEq σ] (p : MvPolynomial σ R) : p.vars = p.degrees.toFinset := by\n  rw [vars]\n  convert rfl\n\n"}
{"name":"MvPolynomial.vars_0","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.vars 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem vars_0 : (0 : MvPolynomial σ R).vars = ∅ := by\n  classical rw [vars_def, degrees_zero, Multiset.toFinset_zero]\n\n"}
{"name":"MvPolynomial.vars_monomial","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\nr : R\ns : Finsupp σ Nat\ninst✝ : CommSemiring R\nh : Ne r 0\n⊢ Eq ((MvPolynomial.monomial s) r).vars s.support","decl":"@[simp]\ntheorem vars_monomial (h : r ≠ 0) : (monomial s r).vars = s.support := by\n  classical rw [vars_def, degrees_monomial_eq _ _ h, Finsupp.toFinset_toMultiset]\n\n"}
{"name":"MvPolynomial.vars_C","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\nr : R\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.C r).vars EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem vars_C : (C r : MvPolynomial σ R).vars = ∅ := by\n  classical rw [vars_def, degrees_C, Multiset.toFinset_zero]\n\n"}
{"name":"MvPolynomial.vars_X","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\nn : σ\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\n⊢ Eq (MvPolynomial.X n).vars (Singleton.singleton n)","decl":"@[simp]\ntheorem vars_X [Nontrivial R] : (X n : MvPolynomial σ R).vars = {n} := by\n  rw [X, vars_monomial (one_ne_zero' R), Finsupp.support_single_ne_zero _ (one_ne_zero' ℕ)]\n\n"}
{"name":"MvPolynomial.mem_vars","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\ni : σ\n⊢ Iff (Membership.mem p.vars i) (Exists fun d => And (Membership.mem p.support d) (Membership.mem d.support i))","decl":"theorem mem_vars (i : σ) : i ∈ p.vars ↔ ∃ d ∈ p.support, i ∈ d.support := by\n  classical simp only [vars_def, Multiset.mem_toFinset, mem_degrees, mem_support_iff, exists_prop]\n\n"}
{"name":"MvPolynomial.mem_support_not_mem_vars_zero","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nf : MvPolynomial σ R\nx : Finsupp σ Nat\nH : Membership.mem f.support x\nv : σ\nh : Not (Membership.mem f.vars v)\n⊢ Eq (x v) 0","decl":"theorem mem_support_not_mem_vars_zero {f : MvPolynomial σ R} {x : σ →₀ ℕ} (H : x ∈ f.support)\n    {v : σ} (h : v ∉ vars f) : x v = 0 := by\n  contrapose! h\n  exact (mem_vars v).mpr ⟨x, H, Finsupp.mem_support_iff.mpr h⟩\n\n"}
{"name":"MvPolynomial.vars_add_subset","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\np q : MvPolynomial σ R\n⊢ HasSubset.Subset (HAdd.hAdd p q).vars (Union.union p.vars q.vars)","decl":"theorem vars_add_subset [DecidableEq σ] (p q : MvPolynomial σ R) :\n    (p + q).vars ⊆ p.vars ∪ q.vars := by\n  intro x hx\n  simp only [vars_def, Finset.mem_union, Multiset.mem_toFinset] at hx ⊢\n  simpa using Multiset.mem_of_le degrees_add_le hx\n\n"}
{"name":"MvPolynomial.vars_add_of_disjoint","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\np q : MvPolynomial σ R\ninst✝ : DecidableEq σ\nh : Disjoint p.vars q.vars\n⊢ Eq (HAdd.hAdd p q).vars (Union.union p.vars q.vars)","decl":"theorem vars_add_of_disjoint [DecidableEq σ] (h : Disjoint p.vars q.vars) :\n    (p + q).vars = p.vars ∪ q.vars := by\n  refine (vars_add_subset p q).antisymm fun x hx => ?_\n  simp only [vars_def, Multiset.disjoint_toFinset] at h hx ⊢\n  rwa [degrees_add_of_disjoint h, Multiset.toFinset_union]\n\n"}
{"name":"MvPolynomial.vars_mul","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\nφ ψ : MvPolynomial σ R\n⊢ HasSubset.Subset (HMul.hMul φ ψ).vars (Union.union φ.vars ψ.vars)","decl":"theorem vars_mul [DecidableEq σ] (φ ψ : MvPolynomial σ R) : (φ * ψ).vars ⊆ φ.vars ∪ ψ.vars := by\n  simp_rw [vars_def, ← Multiset.toFinset_add, Multiset.toFinset_subset]\n  exact Multiset.subset_of_le degrees_mul_le\n\n"}
{"name":"MvPolynomial.vars_one","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.vars 1) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem vars_one : (1 : MvPolynomial σ R).vars = ∅ :=\n  vars_C\n\n"}
{"name":"MvPolynomial.vars_pow","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\nn : Nat\n⊢ HasSubset.Subset (HPow.hPow φ n).vars φ.vars","decl":"theorem vars_pow (φ : MvPolynomial σ R) (n : ℕ) : (φ ^ n).vars ⊆ φ.vars := by\n  classical\n  induction n with\n  | zero => simp\n  | succ n ih =>\n    rw [pow_succ']\n    apply Finset.Subset.trans (vars_mul _ _)\n    exact Finset.union_subset (Finset.Subset.refl _) ih\n\n"}
{"name":"MvPolynomial.vars_prod","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\nι : Type u_3\ninst✝ : DecidableEq σ\ns : Finset ι\nf : ι → MvPolynomial σ R\n⊢ HasSubset.Subset (s.prod fun i => f i).vars (s.biUnion fun i => (f i).vars)","decl":"/-- The variables of the product of a family of polynomials\nare a subset of the union of the sets of variables of each polynomial.\n-/\ntheorem vars_prod {ι : Type*} [DecidableEq σ] {s : Finset ι} (f : ι → MvPolynomial σ R) :\n    (∏ i ∈ s, f i).vars ⊆ s.biUnion fun i => (f i).vars := by\n  classical\n  induction s using Finset.induction_on with\n  | empty => simp\n  | insert hs hsub =>\n    simp only [hs, Finset.biUnion_insert, Finset.prod_insert, not_false_iff]\n    apply Finset.Subset.trans (vars_mul _ _)\n    exact Finset.union_subset_union (Finset.Subset.refl _) hsub\n\n"}
{"name":"MvPolynomial.vars_C_mul","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"σ : Type u_1\nA : Type u_3\ninst✝¹ : CommRing A\ninst✝ : NoZeroDivisors A\na : A\nha : Ne a 0\nφ : MvPolynomial σ A\n⊢ Eq (HMul.hMul (MvPolynomial.C a) φ).vars φ.vars","decl":"theorem vars_C_mul (a : A) (ha : a ≠ 0) (φ : MvPolynomial σ A) :\n    (C a * φ : MvPolynomial σ A).vars = φ.vars := by\n  ext1 i\n  simp only [mem_vars, exists_prop, mem_support_iff]\n  apply exists_congr\n  intro d\n  apply and_congr _ Iff.rfl\n  rw [coeff_C_mul, mul_ne_zero_iff, eq_true ha, true_and]\n\n"}
{"name":"MvPolynomial.vars_sum_subset","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\nι : Type u_3\nt : Finset ι\nφ : ι → MvPolynomial σ R\ninst✝ : DecidableEq σ\n⊢ HasSubset.Subset (t.sum fun i => φ i).vars (t.biUnion fun i => (φ i).vars)","decl":"theorem vars_sum_subset [DecidableEq σ] :\n    (∑ i ∈ t, φ i).vars ⊆ Finset.biUnion t fun i => (φ i).vars := by\n  classical\n  induction t using Finset.induction_on with\n  | empty => simp\n  | insert has hsum =>\n    rw [Finset.biUnion_insert, Finset.sum_insert has]\n    refine Finset.Subset.trans\n      (vars_add_subset _ _) (Finset.union_subset_union (Finset.Subset.refl _) ?_)\n    assumption\n\n"}
{"name":"MvPolynomial.vars_sum_of_disjoint","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\nι : Type u_3\nt : Finset ι\nφ : ι → MvPolynomial σ R\ninst✝ : DecidableEq σ\nh : Pairwise (Function.onFun Disjoint fun i => (φ i).vars)\n⊢ Eq (t.sum fun i => φ i).vars (t.biUnion fun i => (φ i).vars)","decl":"theorem vars_sum_of_disjoint [DecidableEq σ] (h : Pairwise <| (Disjoint on fun i => (φ i).vars)) :\n    (∑ i ∈ t, φ i).vars = Finset.biUnion t fun i => (φ i).vars := by\n  classical\n  induction t using Finset.induction_on with\n  | empty => simp\n  | insert has hsum =>\n    rw [Finset.biUnion_insert, Finset.sum_insert has, vars_add_of_disjoint, hsum]\n    unfold Pairwise onFun at h\n    rw [hsum]\n    simp only [Finset.disjoint_iff_ne] at h ⊢\n    intro v hv v2 hv2\n    rw [Finset.mem_biUnion] at hv2\n    rcases hv2 with ⟨i, his, hi⟩\n    refine h ?_ _ hv _ hi\n    rintro rfl\n    contradiction\n\n"}
{"name":"MvPolynomial.vars_map","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nS : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\np : MvPolynomial σ R\ninst✝ : CommSemiring S\nf : RingHom R S\n⊢ HasSubset.Subset ((MvPolynomial.map f) p).vars p.vars","decl":"theorem vars_map : (map f p).vars ⊆ p.vars := by\n  classical simp [vars_def, Multiset.subset_of_le degrees_map_le]\n\n"}
{"name":"MvPolynomial.vars_map_of_injective","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nS : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\np : MvPolynomial σ R\ninst✝ : CommSemiring S\nf : RingHom R S\nhf : Function.Injective ⇑f\n⊢ Eq ((MvPolynomial.map f) p).vars p.vars","decl":"theorem vars_map_of_injective (hf : Injective f) : (map f p).vars = p.vars := by\n  simp [vars, degrees_map_of_injective _ hf]\n\n"}
{"name":"MvPolynomial.vars_monomial_single","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ni : σ\ne : Nat\nr : R\nhe : Ne e 0\nhr : Ne r 0\n⊢ Eq ((MvPolynomial.monomial (Finsupp.single i e)) r).vars (Singleton.singleton i)","decl":"theorem vars_monomial_single (i : σ) {e : ℕ} {r : R} (he : e ≠ 0) (hr : r ≠ 0) :\n    (monomial (Finsupp.single i e) r).vars = {i} := by\n  rw [vars_monomial hr, Finsupp.support_single_ne_zero _ he]\n\n"}
{"name":"MvPolynomial.vars_eq_support_biUnion_support","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\np : MvPolynomial σ R\ninst✝ : DecidableEq σ\n⊢ Eq p.vars (p.support.biUnion Finsupp.support)","decl":"theorem vars_eq_support_biUnion_support [DecidableEq σ] :\n    p.vars = p.support.biUnion Finsupp.support := by\n  ext i\n  rw [mem_vars, Finset.mem_biUnion]\n\n"}
{"name":"MvPolynomial.eval₂Hom_eq_constantCoeff_of_vars","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nS : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\ng : σ → S\np : MvPolynomial σ R\nhp : ∀ (i : σ), Membership.mem p.vars i → Eq (g i) 0\n⊢ Eq ((MvPolynomial.eval₂Hom f g) p) (f (MvPolynomial.constantCoeff p))","decl":"theorem eval₂Hom_eq_constantCoeff_of_vars (f : R →+* S) {g : σ → S} {p : MvPolynomial σ R}\n    (hp : ∀ i ∈ p.vars, g i = 0) : eval₂Hom f g p = f (constantCoeff p) := by\n  conv_lhs => rw [p.as_sum]\n  simp only [map_sum, eval₂Hom_monomial]\n  by_cases h0 : constantCoeff p = 0\n  on_goal 1 =>\n    rw [h0, f.map_zero, Finset.sum_eq_zero]\n    intro d hd\n  on_goal 2 =>\n    rw [Finset.sum_eq_single (0 : σ →₀ ℕ)]\n    · rw [Finsupp.prod_zero_index, mul_one]\n      rfl\n    on_goal 1 => intro d hd hd0\n  on_goal 3 =>\n    rw [constantCoeff_eq, coeff, ← Ne, ← Finsupp.mem_support_iff] at h0\n    intro\n    contradiction\n  repeat'\n    obtain ⟨i, hi⟩ : Finset.Nonempty (Finsupp.support d) := by\n      rw [constantCoeff_eq, coeff, ← Finsupp.not_mem_support_iff] at h0\n      rw [Finset.nonempty_iff_ne_empty, Ne, Finsupp.support_eq_empty]\n      rintro rfl\n      contradiction\n    rw [Finsupp.prod, Finset.prod_eq_zero hi, mul_zero]\n    rw [hp, zero_pow (Finsupp.mem_support_iff.1 hi)]\n    rw [mem_vars]\n    exact ⟨d, hd, hi⟩\n\n"}
{"name":"MvPolynomial.aeval_eq_constantCoeff_of_vars","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nS : Type v\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\ng : σ → S\np : MvPolynomial σ R\nhp : ∀ (i : σ), Membership.mem p.vars i → Eq (g i) 0\n⊢ Eq ((MvPolynomial.aeval g) p) ((algebraMap R S) (MvPolynomial.constantCoeff p))","decl":"theorem aeval_eq_constantCoeff_of_vars [Algebra R S] {g : σ → S} {p : MvPolynomial σ R}\n    (hp : ∀ i ∈ p.vars, g i = 0) : aeval g p = algebraMap _ _ (constantCoeff p) :=\n  eval₂Hom_eq_constantCoeff_of_vars _ hp\n\n"}
{"name":"MvPolynomial.eval₂Hom_congr'","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nS : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf₁ f₂ : RingHom R S\ng₁ g₂ : σ → S\np₁ p₂ : MvPolynomial σ R\na✝² : Eq f₁ f₂\na✝¹ : ∀ (i : σ), Membership.mem p₁.vars i → Membership.mem p₂.vars i → Eq (g₁ i) (g₂ i)\na✝ : Eq p₁ p₂\n⊢ Eq ((MvPolynomial.eval₂Hom f₁ g₁) p₁) ((MvPolynomial.eval₂Hom f₂ g₂) p₂)","decl":"theorem eval₂Hom_congr' {f₁ f₂ : R →+* S} {g₁ g₂ : σ → S} {p₁ p₂ : MvPolynomial σ R} :\n    f₁ = f₂ →\n      (∀ i, i ∈ p₁.vars → i ∈ p₂.vars → g₁ i = g₂ i) →\n        p₁ = p₂ → eval₂Hom f₁ g₁ p₁ = eval₂Hom f₂ g₂ p₂ := by\n  rintro rfl h rfl\n  rw [p₁.as_sum]\n  simp only [map_sum, eval₂Hom_monomial]\n  apply Finset.sum_congr rfl\n  intro d hd\n  congr 1\n  simp only [Finsupp.prod]\n  apply Finset.prod_congr rfl\n  intro i hi\n  have : i ∈ p₁.vars := by\n    rw [mem_vars]\n    exact ⟨d, hd, hi⟩\n  rw [h i this this]\n\n"}
{"name":"MvPolynomial.hom_congr_vars","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nS : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf₁ f₂ : RingHom (MvPolynomial σ R) S\np₁ p₂ : MvPolynomial σ R\nhC : Eq (f₁.comp MvPolynomial.C) (f₂.comp MvPolynomial.C)\nhv : ∀ (i : σ), Membership.mem p₁.vars i → Membership.mem p₂.vars i → Eq (f₁ (MvPolynomial.X i)) (f₂ (MvPolynomial.X i))\nhp : Eq p₁ p₂\n⊢ Eq (f₁ p₁) (f₂ p₂)","decl":"/-- If `f₁` and `f₂` are ring homs out of the polynomial ring and `p₁` and `p₂` are polynomials,\n  then `f₁ p₁ = f₂ p₂` if `p₁ = p₂` and `f₁` and `f₂` are equal on `R` and on the variables\n  of `p₁`. -/\ntheorem hom_congr_vars {f₁ f₂ : MvPolynomial σ R →+* S} {p₁ p₂ : MvPolynomial σ R}\n    (hC : f₁.comp C = f₂.comp C) (hv : ∀ i, i ∈ p₁.vars → i ∈ p₂.vars → f₁ (X i) = f₂ (X i))\n    (hp : p₁ = p₂) : f₁ p₁ = f₂ p₂ :=\n  calc\n    f₁ p₁ = eval₂Hom (f₁.comp C) (f₁ ∘ X) p₁ := RingHom.congr_fun (by ext <;> simp) _\n    _ = eval₂Hom (f₂.comp C) (f₂ ∘ X) p₂ := eval₂Hom_congr' hC hv hp\n    _ = f₂ p₂ := RingHom.congr_fun (by ext <;> simp) _\n\n"}
{"name":"MvPolynomial.exists_rename_eq_of_vars_subset_range","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\nτ : Type u_2\ninst✝ : CommSemiring R\np : MvPolynomial σ R\nf : τ → σ\nhfi : Function.Injective f\nhf : HasSubset.Subset (↑p.vars) (Set.range f)\n⊢ Exists fun q => Eq ((MvPolynomial.rename f) q) p","decl":"theorem exists_rename_eq_of_vars_subset_range (p : MvPolynomial σ R) (f : τ → σ) (hfi : Injective f)\n    (hf : ↑p.vars ⊆ Set.range f) : ∃ q : MvPolynomial τ R, rename f q = p :=\n  ⟨aeval (fun i : σ => Option.elim' 0 X <| partialInv f i) p,\n    by\n      show (rename f).toRingHom.comp _ p = RingHom.id _ p\n      refine hom_congr_vars ?_ ?_ ?_\n      · ext1\n        simp [algebraMap_eq]\n      · intro i hip _\n        rcases hf hip with ⟨i, rfl⟩\n        simp [partialInv_left hfi]\n      · rfl⟩\n\n"}
{"name":"MvPolynomial.vars_rename","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\nτ : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq τ\nf : σ → τ\nφ : MvPolynomial σ R\n⊢ HasSubset.Subset ((MvPolynomial.rename f) φ).vars (Finset.image f φ.vars)","decl":"theorem vars_rename [DecidableEq τ] (f : σ → τ) (φ : MvPolynomial σ R) :\n    (rename f φ).vars ⊆ φ.vars.image f := by\n  classical\n  intro i hi\n  simp only [vars_def, exists_prop, Multiset.mem_toFinset, Finset.mem_image] at hi ⊢\n  simpa only [Multiset.mem_map] using degrees_rename _ _ hi\n\n"}
{"name":"MvPolynomial.mem_vars_rename","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\nτ : Type u_2\ninst✝ : CommSemiring R\nf : σ → τ\nφ : MvPolynomial σ R\nj : τ\nh : Membership.mem ((MvPolynomial.rename f) φ).vars j\n⊢ Exists fun i => And (Membership.mem φ.vars i) (Eq (f i) j)","decl":"theorem mem_vars_rename (f : σ → τ) (φ : MvPolynomial σ R) {j : τ} (h : j ∈ (rename f φ).vars) :\n    ∃ i : σ, i ∈ φ.vars ∧ f i = j := by\n  classical\n  simpa only [exists_prop, Finset.mem_image] using vars_rename f φ h\n\n"}
{"name":"MvPolynomial.aeval_ite_mem_eq_self","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\nq : MvPolynomial σ R\ns : Set σ\nhs : HasSubset.Subset (↑q.vars) s\ninst✝ : (i : σ) → Decidable (Membership.mem s i)\n⊢ Eq ((MvPolynomial.aeval fun i => ite (Membership.mem s i) (MvPolynomial.X i) 0) q) q","decl":"lemma aeval_ite_mem_eq_self (q : MvPolynomial σ R) {s : Set σ} (hs : q.vars.toSet ⊆ s)\n    [∀ i, Decidable (i ∈ s)] :\n    MvPolynomial.aeval (fun i ↦ if i ∈ s then .X i else 0) q = q := by\n  rw [MvPolynomial.as_sum q, MvPolynomial.aeval_sum]\n  refine Finset.sum_congr rfl fun u hu ↦ ?_\n  rw [MvPolynomial.aeval_monomial, MvPolynomial.monomial_eq]\n  congr 1\n  exact Finsupp.prod_congr (fun i hi ↦ by simp [hs ((MvPolynomial.mem_vars _).mpr ⟨u, hu, hi⟩)])\n\n"}
{"name":"MvPolynomial.leadingCoeff_toLex","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\np : MvPolynomial σ R\ninst✝ : LinearOrder σ\n⊢ Eq (AddMonoidAlgebra.leadingCoeff (⇑toLex) p) (MvPolynomial.coeff (ofLex (AddMonoidAlgebra.supDegree (⇑toLex) p)) p)","decl":"lemma leadingCoeff_toLex : p.leadingCoeff toLex = p.coeff (ofLex <| p.supDegree toLex) := by\n  rw [leadingCoeff]\n  apply congr_arg p.coeff\n  apply toLex.injective\n  rw [Function.rightInverse_invFun toLex.surjective, toLex_ofLex]\n\n"}
{"name":"MvPolynomial.supDegree_toLex_C","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : LinearOrder σ\nr : R\n⊢ Eq (AddMonoidAlgebra.supDegree (⇑toLex) (MvPolynomial.C r)) 0","decl":"lemma supDegree_toLex_C (r : R) : supDegree toLex (C (σ := σ) r) = 0 := by\n  classical\n    exact (supDegree_single _ r).trans (ite_eq_iff'.mpr ⟨fun _ => rfl, fun _ => rfl⟩)\n\n"}
{"name":"MvPolynomial.leadingCoeff_toLex_C","module":"Mathlib.Algebra.MvPolynomial.Variables","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : LinearOrder σ\nr : R\n⊢ Eq (AddMonoidAlgebra.leadingCoeff (⇑toLex) (MvPolynomial.C r)) r","decl":"lemma leadingCoeff_toLex_C (r : R) : leadingCoeff toLex (C (σ := σ) r) = r :=\n  leadingCoeff_single toLex.injective _ r\n\n"}
