{"name":"Complex.Gamma‚Ñù_def","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Deligne","initialProofState":"s : Complex\n‚ä¢ Eq s.Gamma‚Ñù (HMul.hMul (HPow.hPow (‚ÜëReal.pi) (HDiv.hDiv (Neg.neg s) 2)) (Complex.Gamma (HDiv.hDiv s 2)))","decl":"lemma Gamma‚Ñù_def (s : ‚ÑÇ) : Gamma‚Ñù s = œÄ ^ (-s / 2) * Gamma (s / 2) := rfl\n\n"}
{"name":"Complex.Gamma‚ÑÇ_def","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Deligne","initialProofState":"s : Complex\n‚ä¢ Eq s.Gamma‚ÑÇ (HMul.hMul (HMul.hMul 2 (HPow.hPow (HMul.hMul 2 ‚ÜëReal.pi) (Neg.neg s))) (Complex.Gamma s))","decl":"lemma Gamma‚ÑÇ_def (s : ‚ÑÇ) : Gamma‚ÑÇ s = 2 * (2 * œÄ) ^ (-s) * Gamma s := rfl\n\n"}
{"name":"Complex.Gamma‚Ñù_add_two","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Deligne","initialProofState":"s : Complex\nhs : Ne s 0\n‚ä¢ Eq (HAdd.hAdd s 2).Gamma‚Ñù (HDiv.hDiv (HDiv.hDiv (HMul.hMul s.Gamma‚Ñù s) 2) ‚ÜëReal.pi)","decl":"lemma Gamma‚Ñù_add_two {s : ‚ÑÇ} (hs : s ‚â† 0) : Gamma‚Ñù (s + 2) = Gamma‚Ñù s * s / 2 / œÄ := by\n  rw [Gamma‚Ñù_def, Gamma‚Ñù_def, neg_div, add_div, neg_add, div_self two_ne_zero,\n    Gamma_add_one _ (div_ne_zero hs two_ne_zero),\n    cpow_add _ _ (ofReal_ne_zero.mpr pi_ne_zero), cpow_neg_one]\n  field_simp [pi_ne_zero]\n  ring\n\n"}
{"name":"Complex.Gamma‚ÑÇ_add_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Deligne","initialProofState":"s : Complex\nhs : Ne s 0\n‚ä¢ Eq (HAdd.hAdd s 1).Gamma‚ÑÇ (HDiv.hDiv (HDiv.hDiv (HMul.hMul s.Gamma‚ÑÇ s) 2) ‚ÜëReal.pi)","decl":"lemma Gamma‚ÑÇ_add_one {s : ‚ÑÇ} (hs : s ‚â† 0) : Gamma‚ÑÇ (s + 1) = Gamma‚ÑÇ s * s / 2 / œÄ := by\n  rw [Gamma‚ÑÇ_def, Gamma‚ÑÇ_def, Gamma_add_one _ hs, neg_add,\n    cpow_add _ _ (mul_ne_zero two_ne_zero (ofReal_ne_zero.mpr pi_ne_zero)), cpow_neg_one]\n  field_simp [pi_ne_zero]\n  ring\n\n"}
{"name":"Complex.Gamma‚Ñù_ne_zero_of_re_pos","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Deligne","initialProofState":"s : Complex\nhs : LT.lt 0 s.re\n‚ä¢ Ne s.Gamma‚Ñù 0","decl":"lemma Gamma‚Ñù_ne_zero_of_re_pos {s : ‚ÑÇ} (hs : 0 < re s) : Gamma‚Ñù s ‚â† 0 := by\n  apply mul_ne_zero\n  ¬∑ simp [pi_ne_zero]\n  ¬∑ apply Gamma_ne_zero_of_re_pos\n    rw [div_ofNat_re]\n    exact div_pos hs two_pos\n\n"}
{"name":"Complex.Gamma‚Ñù_eq_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Deligne","initialProofState":"s : Complex\n‚ä¢ Iff (Eq s.Gamma‚Ñù 0) (Exists fun n => Eq s (Neg.neg (HMul.hMul 2 ‚Üën)))","decl":"lemma Gamma‚Ñù_eq_zero_iff {s : ‚ÑÇ} : Gamma‚Ñù s = 0 ‚Üî ‚àÉ n : ‚Ñï, s = -(2 * n) := by\n  simp [Gamma‚Ñù_def, Complex.Gamma_eq_zero_iff, pi_ne_zero, div_eq_iff (two_ne_zero' ‚ÑÇ), mul_comm]\n\n"}
{"name":"Complex.Gamma‚Ñù_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Deligne","initialProofState":"‚ä¢ Eq (Complex.Gamma‚Ñù 1) 1","decl":"@[simp]\nlemma Gamma‚Ñù_one : Gamma‚Ñù 1 = 1 := by\n  rw [Gamma‚Ñù_def, Complex.Gamma_one_half_eq]\n  simp [neg_div, cpow_neg, inv_mul_cancel, pi_ne_zero]\n\n"}
{"name":"Complex.Gamma‚ÑÇ_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Deligne","initialProofState":"‚ä¢ Eq (Complex.Gamma‚ÑÇ 1) (HDiv.hDiv 1 ‚ÜëReal.pi)","decl":"@[simp]\nlemma Gamma‚ÑÇ_one : Gamma‚ÑÇ 1 = 1 / œÄ := by\n  rw [Gamma‚ÑÇ_def, cpow_neg_one, Complex.Gamma_one]\n  field_simp [pi_ne_zero]\n\n"}
{"name":"Complex.differentiable_Gamma‚Ñù_inv","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Deligne","initialProofState":"‚ä¢ Differentiable Complex fun s => Inv.inv s.Gamma‚Ñù","decl":"lemma differentiable_Gamma‚Ñù_inv : Differentiable ‚ÑÇ (fun s ‚Ü¶ (Gamma‚Ñù s)‚Åª¬π) := by\n  conv => enter [2, s]; rw [Gamma‚Ñù, mul_inv]\n  refine Differentiable.mul (fun s ‚Ü¶ .inv ?_ (by simp [pi_ne_zero])) ?_\n  ¬∑ refine ((differentiableAt_id.neg.div_const (2 : ‚ÑÇ)).const_cpow ?_)\n    exact Or.inl (ofReal_ne_zero.mpr pi_ne_zero)\n  ¬∑ exact differentiable_one_div_Gamma.comp (differentiable_id.div_const _)\n\n"}
{"name":"Complex.Gamma‚Ñù_residue_zero","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Deligne","initialProofState":"‚ä¢ Filter.Tendsto (fun s => HMul.hMul s s.Gamma‚Ñù) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) (nhds 2)","decl":"lemma Gamma‚Ñù_residue_zero : Tendsto (fun s ‚Ü¶ s * Gamma‚Ñù s) (ùìù[‚â†] 0) (ùìù 2) := by\n  have h : Tendsto (fun z : ‚ÑÇ ‚Ü¶ z / 2 * Gamma (z / 2)) (ùìù[‚â†] 0) (ùìù 1) := by\n    refine tendsto_self_mul_Gamma_nhds_zero.comp ?_\n    rw [tendsto_nhdsWithin_iff, (by simp : ùìù (0 : ‚ÑÇ) = ùìù (0 / 2))]\n    exact ‚ü®(tendsto_id.div_const _).mono_left nhdsWithin_le_nhds,\n      eventually_of_mem self_mem_nhdsWithin fun x hx ‚Ü¶ div_ne_zero hx two_ne_zero‚ü©\n  have h' : Tendsto (fun s : ‚ÑÇ ‚Ü¶ 2 * (œÄ : ‚ÑÇ) ^ (-s / 2)) (ùìù[‚â†] 0) (ùìù 2) := by\n    rw [(by simp : ùìù 2 = ùìù (2 * (œÄ : ‚ÑÇ) ^ (-(0 : ‚ÑÇ) / 2)))]\n    refine Tendsto.mono_left (ContinuousAt.tendsto ?_) nhdsWithin_le_nhds\n    exact continuousAt_const.mul ((continuousAt_const_cpow (ofReal_ne_zero.mpr pi_ne_zero)).comp\n      (continuousAt_id.neg.div_const _))\n  convert mul_one (2 : ‚ÑÇ) ‚ñ∏ (h'.mul h) using 2 with z\n  rw [Gamma‚Ñù]\n  ring_nf\n\n"}
{"name":"Complex.Gamma‚Ñù_mul_Gamma‚Ñù_add_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Deligne","initialProofState":"s : Complex\n‚ä¢ Eq (HMul.hMul s.Gamma‚Ñù (HAdd.hAdd s 1).Gamma‚Ñù) s.Gamma‚ÑÇ","decl":"/-- Reformulation of the doubling formula in terms of `Gamma‚Ñù`. -/\nlemma Gamma‚Ñù_mul_Gamma‚Ñù_add_one (s : ‚ÑÇ) : Gamma‚Ñù s * Gamma‚Ñù (s + 1) = Gamma‚ÑÇ s := by\n  simp only [Gamma‚Ñù_def, Gamma‚ÑÇ_def]\n  calc\n  _ = (œÄ ^ (-s / 2) * œÄ ^ (-(s + 1) / 2)) * (Gamma (s / 2) * Gamma (s / 2 + 1 / 2)) := by ring_nf\n  _ = 2 ^ (1 - s) * (œÄ ^ (-1 / 2 - s) * œÄ ^ (1 / 2 : ‚ÑÇ)) * Gamma s := by\n    rw [‚Üê cpow_add _ _ (ofReal_ne_zero.mpr pi_ne_zero), Complex.Gamma_mul_Gamma_add_half,\n      sqrt_eq_rpow, ofReal_cpow pi_pos.le, ofReal_div, ofReal_one, ofReal_ofNat]\n    ring_nf\n  _ = 2 * ((2 : ‚Ñù) ^ (-s) * œÄ ^ (-s)) * Gamma s := by\n    rw [sub_eq_add_neg, cpow_add _ _ two_ne_zero, cpow_one,\n      ‚Üê cpow_add _ _ (ofReal_ne_zero.mpr pi_ne_zero), ofReal_ofNat]\n    ring_nf\n  _ = 2 * (2 * œÄ) ^ (-s) * Gamma s := by\n    rw [‚Üê mul_cpow_ofReal_nonneg two_pos.le pi_pos.le, ofReal_ofNat]\n\n"}
{"name":"Complex.Gamma‚Ñù_one_sub_mul_Gamma‚Ñù_one_add","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Deligne","initialProofState":"s : Complex\n‚ä¢ Eq (HMul.hMul (HSub.hSub 1 s).Gamma‚Ñù (HAdd.hAdd 1 s).Gamma‚Ñù) (Inv.inv (Complex.cos (HDiv.hDiv (HMul.hMul (‚ÜëReal.pi) s) 2)))","decl":"/-- Reformulation of the reflection formula in terms of `Gamma‚Ñù`. -/\nlemma Gamma‚Ñù_one_sub_mul_Gamma‚Ñù_one_add (s : ‚ÑÇ) :\n    Gamma‚Ñù (1 - s) * Gamma‚Ñù (1 + s) = (cos (œÄ * s / 2))‚Åª¬π :=\n  calc Gamma‚Ñù (1 - s) * Gamma‚Ñù (1 + s)\n  _ = (œÄ ^ ((s - 1) / 2) * œÄ ^ ((-1 - s) / 2)) *\n        (Gamma ((1 - s) / 2) * Gamma (1 - (1 - s) / 2)) := by\n    simp only [Gamma‚Ñù_def]\n    ring_nf\n  _ = (œÄ ^ ((s - 1) / 2) * œÄ ^ ((-1 - s) / 2) * œÄ ^ (1 : ‚ÑÇ)) / sin (œÄ / 2 - œÄ * s / 2) := by\n    rw [Complex.Gamma_mul_Gamma_one_sub, cpow_one]\n    ring_nf\n  _ = _ := by\n    simp_rw [‚Üê cpow_add _ _ (ofReal_ne_zero.mpr pi_ne_zero),\n      Complex.sin_pi_div_two_sub]\n    ring_nf\n    rw [cpow_zero, one_mul]\n\n"}
{"name":"Complex.Gamma‚Ñù_div_Gamma‚Ñù_one_sub","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Deligne","initialProofState":"s : Complex\nhs : ‚àÄ (n : Nat), Ne s (Neg.neg (HAdd.hAdd (HMul.hMul 2 ‚Üën) 1))\n‚ä¢ Eq (HDiv.hDiv s.Gamma‚Ñù (HSub.hSub 1 s).Gamma‚Ñù) (HMul.hMul s.Gamma‚ÑÇ (Complex.cos (HDiv.hDiv (HMul.hMul (‚ÜëReal.pi) s) 2)))","decl":"/-- Another formulation of the reflection formula in terms of `Gamma‚Ñù`. -/\nlemma Gamma‚Ñù_div_Gamma‚Ñù_one_sub {s : ‚ÑÇ} (hs : ‚àÄ (n : ‚Ñï), s ‚â† -(2 * n + 1)) :\n    Gamma‚Ñù s / Gamma‚Ñù (1 - s) = Gamma‚ÑÇ s * cos (œÄ * s / 2) := by\n  have : Gamma‚Ñù (s + 1) ‚â† 0 := by\n    simpa only [Ne, Gamma‚Ñù_eq_zero_iff, not_exists, ‚Üê eq_sub_iff_add_eq,\n      sub_eq_add_neg, ‚Üê neg_add]\n  calc Gamma‚Ñù s / Gamma‚Ñù (1 - s)\n  _ = (Gamma‚Ñù s * Gamma‚Ñù (s + 1)) / (Gamma‚Ñù (1 - s) * Gamma‚Ñù (1 + s)) := by\n    rw [add_comm 1 s, mul_comm (Gamma‚Ñù (1 - s)) (Gamma‚Ñù (s + 1)), ‚Üê div_div,\n      mul_div_cancel_right‚ÇÄ _ this]\n  _ = (2 * (2 * œÄ) ^ (-s) * Gamma s) / ((cos (œÄ * s / 2))‚Åª¬π) := by\n    rw [Gamma‚Ñù_one_sub_mul_Gamma‚Ñù_one_add, Gamma‚Ñù_mul_Gamma‚Ñù_add_one, Gamma‚ÑÇ_def]\n  _ = _ := by rw [Gamma‚ÑÇ_def, div_eq_mul_inv, inv_inv]\n\n"}
{"name":"Complex.inv_Gamma‚Ñù_one_sub","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Deligne","initialProofState":"s : Complex\nhs : ‚àÄ (n : Nat), Ne s (Neg.neg ‚Üën)\n‚ä¢ Eq (Inv.inv (HSub.hSub 1 s).Gamma‚Ñù) (HMul.hMul (HMul.hMul s.Gamma‚ÑÇ (Complex.cos (HDiv.hDiv (HMul.hMul (‚ÜëReal.pi) s) 2))) (Inv.inv s.Gamma‚Ñù))","decl":"/-- Formulation of reflection formula tailored to functional equations of L-functions of even\nDirichlet characters (including Riemann zeta). -/\nlemma inv_Gamma‚Ñù_one_sub {s : ‚ÑÇ} (hs : ‚àÄ (n : ‚Ñï), s ‚â† -n) :\n    (Gamma‚Ñù (1 - s))‚Åª¬π = Gamma‚ÑÇ s * cos (œÄ * s / 2) * (Gamma‚Ñù s)‚Åª¬π := by\n  have h1 : Gamma‚Ñù s ‚â† 0 := by\n    rw [Ne, Gamma‚Ñù_eq_zero_iff, not_exists]\n    intro n h\n    specialize hs (2 * n)\n    simp_all\n  have h2 : ‚àÄ (n : ‚Ñï), s ‚â† -(2 * ‚Üën + 1) := by\n    intro n h\n    specialize hs (2 * n + 1)\n    simp_all\n  rw [‚Üê Gamma‚Ñù_div_Gamma‚Ñù_one_sub h2, ‚Üê div_eq_mul_inv, div_right_comm, div_self h1, one_div]\n\n"}
{"name":"Complex.inv_Gamma‚Ñù_two_sub","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Deligne","initialProofState":"s : Complex\nhs : ‚àÄ (n : Nat), Ne s (Neg.neg ‚Üën)\n‚ä¢ Eq (Inv.inv (HSub.hSub 2 s).Gamma‚Ñù) (HMul.hMul (HMul.hMul s.Gamma‚ÑÇ (Complex.sin (HDiv.hDiv (HMul.hMul (‚ÜëReal.pi) s) 2))) (Inv.inv (HAdd.hAdd s 1).Gamma‚Ñù))","decl":"/-- Formulation of reflection formula tailored to functional equations of L-functions of odd\nDirichlet characters. -/\nlemma inv_Gamma‚Ñù_two_sub {s : ‚ÑÇ} (hs : ‚àÄ (n : ‚Ñï), s ‚â† -n) :\n    (Gamma‚Ñù (2 - s))‚Åª¬π = Gamma‚ÑÇ s * sin (œÄ * s / 2) * (Gamma‚Ñù (s + 1))‚Åª¬π := by\n  by_cases h : s = 1\n  ¬∑ rw [h, (by ring : 2 - 1 = (1 : ‚ÑÇ)), Gamma‚Ñù_one, Gamma‚Ñù,\n    neg_div, (by norm_num : (1 + 1) / 2 = (1 : ‚ÑÇ)), Complex.Gamma_one, Gamma‚ÑÇ_one,\n    mul_one, Complex.sin_pi_div_two, mul_one, cpow_neg_one, mul_one, inv_inv,\n    div_mul_cancel‚ÇÄ _ (ofReal_ne_zero.mpr pi_ne_zero), inv_one]\n  rw [‚Üê Ne, ‚Üê sub_ne_zero] at h\n  have h' (n : ‚Ñï) : s - 1 ‚â† -n := by\n    cases' n with m\n    ¬∑ rwa [Nat.cast_zero, neg_zero]\n    ¬∑ rw [Ne, sub_eq_iff_eq_add]\n      convert hs m using 2\n      push_cast\n      ring\n  rw [(by ring : 2 - s = 1 - (s - 1)), inv_Gamma‚Ñù_one_sub h',\n    (by rw [sub_add_cancel] : Gamma‚ÑÇ s = Gamma‚ÑÇ (s - 1 + 1)), Gamma‚ÑÇ_add_one h,\n    (by ring : s + 1 = (s - 1) + 2), Gamma‚Ñù_add_two h, mul_sub, sub_div, mul_one,\n      Complex.cos_sub_pi_div_two]\n  simp_rw [mul_div_assoc, mul_inv]\n  generalize (Gamma‚Ñù (s - 1))‚Åª¬π = A\n  field_simp [pi_ne_zero]\n  ring\n\n"}
