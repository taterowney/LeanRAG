{"name":"Set.Subsingleton.prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nhs : s.Subsingleton\nht : t.Subsingleton\n⊢ (SProd.sprod s t).Subsingleton","decl":"theorem Subsingleton.prod (hs : s.Subsingleton) (ht : t.Subsingleton) :\n    (s ×ˢ t).Subsingleton := fun _x hx _y hy ↦\n  Prod.ext (hs hx.1 hy.1) (ht hx.2 hy.2)\n\n"}
{"name":"Set.prod_mono","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nt₁ t₂ : Set β\nhs : HasSubset.Subset s₁ s₂\nht : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (SProd.sprod s₁ t₁) (SProd.sprod s₂ t₂)","decl":"@[gcongr]\ntheorem prod_mono (hs : s₁ ⊆ s₂) (ht : t₁ ⊆ t₂) : s₁ ×ˢ t₁ ⊆ s₂ ×ˢ t₂ :=\n  fun _ ⟨h₁, h₂⟩ => ⟨hs h₁, ht h₂⟩\n\n"}
{"name":"Set.prod_mono_left","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nt : Set β\nhs : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (SProd.sprod s₁ t) (SProd.sprod s₂ t)","decl":"@[gcongr]\ntheorem prod_mono_left (hs : s₁ ⊆ s₂) : s₁ ×ˢ t ⊆ s₂ ×ˢ t :=\n  prod_mono hs Subset.rfl\n\n"}
{"name":"Set.prod_mono_right","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt₁ t₂ : Set β\nht : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (SProd.sprod s t₁) (SProd.sprod s t₂)","decl":"@[gcongr]\ntheorem prod_mono_right (ht : t₁ ⊆ t₂) : s ×ˢ t₁ ⊆ s ×ˢ t₂ :=\n  prod_mono Subset.rfl ht\n\n"}
{"name":"Set.prod_self_subset_prod_self","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\ns₁ s₂ : Set α\n⊢ Iff (HasSubset.Subset (SProd.sprod s₁ s₁) (SProd.sprod s₂ s₂)) (HasSubset.Subset s₁ s₂)","decl":"@[simp]\ntheorem prod_self_subset_prod_self : s₁ ×ˢ s₁ ⊆ s₂ ×ˢ s₂ ↔ s₁ ⊆ s₂ :=\n  ⟨fun h _ hx => (h (mk_mem_prod hx hx)).1, fun h _ hx => ⟨h hx.1, h hx.2⟩⟩\n\n"}
{"name":"Set.prod_self_ssubset_prod_self","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\ns₁ s₂ : Set α\n⊢ Iff (HasSSubset.SSubset (SProd.sprod s₁ s₁) (SProd.sprod s₂ s₂)) (HasSSubset.SSubset s₁ s₂)","decl":"@[simp]\ntheorem prod_self_ssubset_prod_self : s₁ ×ˢ s₁ ⊂ s₂ ×ˢ s₂ ↔ s₁ ⊂ s₂ :=\n  and_congr prod_self_subset_prod_self <| not_congr prod_self_subset_prod_self\n\n"}
{"name":"Set.prod_subset_iff","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nP : Set (Prod α β)\n⊢ Iff (HasSubset.Subset (SProd.sprod s t) P) (∀ (x : α), Membership.mem s x → ∀ (y : β), Membership.mem t y → Membership.mem P { fst := x, snd := y })","decl":"theorem prod_subset_iff {P : Set (α × β)} : s ×ˢ t ⊆ P ↔ ∀ x ∈ s, ∀ y ∈ t, (x, y) ∈ P :=\n  ⟨fun h _ hx _ hy => h (mk_mem_prod hx hy), fun h ⟨_, _⟩ hp => h _ hp.1 _ hp.2⟩\n\n"}
{"name":"Set.forall_prod_set","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\np : Prod α β → Prop\n⊢ Iff (∀ (x : Prod α β), Membership.mem (SProd.sprod s t) x → p x) (∀ (x : α), Membership.mem s x → ∀ (y : β), Membership.mem t y → p { fst := x, snd := y })","decl":"theorem forall_prod_set {p : α × β → Prop} : (∀ x ∈ s ×ˢ t, p x) ↔ ∀ x ∈ s, ∀ y ∈ t, p (x, y) :=\n  prod_subset_iff\n\n"}
{"name":"Set.exists_prod_set","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\np : Prod α β → Prop\n⊢ Iff (Exists fun x => And (Membership.mem (SProd.sprod s t) x) (p x)) (Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem t y) (p { fst := x, snd := y })))","decl":"theorem exists_prod_set {p : α × β → Prop} : (∃ x ∈ s ×ˢ t, p x) ↔ ∃ x ∈ s, ∃ y ∈ t, p (x, y) := by\n  simp [and_assoc]\n\n"}
{"name":"Set.prod_empty","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\n⊢ Eq (SProd.sprod s EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem prod_empty : s ×ˢ (∅ : Set β) = ∅ := by\n  ext\n  exact iff_of_eq (and_false _)\n\n"}
{"name":"Set.empty_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\n⊢ Eq (SProd.sprod EmptyCollection.emptyCollection t) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem empty_prod : (∅ : Set α) ×ˢ t = ∅ := by\n  ext\n  exact iff_of_eq (false_and _)\n\n"}
{"name":"Set.univ_prod_univ","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq (SProd.sprod Set.univ Set.univ) Set.univ","decl":"@[simp, mfld_simps]\ntheorem univ_prod_univ : @univ α ×ˢ @univ β = univ := by\n  ext\n  exact iff_of_eq (true_and _)\n\n"}
{"name":"Set.univ_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\n⊢ Eq (SProd.sprod Set.univ t) (Set.preimage Prod.snd t)","decl":"theorem univ_prod {t : Set β} : (univ : Set α) ×ˢ t = Prod.snd ⁻¹' t := by simp [prod_eq]\n\n"}
{"name":"Set.prod_univ","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\n⊢ Eq (SProd.sprod s Set.univ) (Set.preimage Prod.fst s)","decl":"theorem prod_univ {s : Set α} : s ×ˢ (univ : Set β) = Prod.fst ⁻¹' s := by simp [prod_eq]\n\n"}
{"name":"Set.prod_eq_univ","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\ninst✝¹ : Nonempty α\ninst✝ : Nonempty β\n⊢ Iff (Eq (SProd.sprod s t) Set.univ) (And (Eq s Set.univ) (Eq t Set.univ))","decl":"@[simp] lemma prod_eq_univ [Nonempty α] [Nonempty β] : s ×ˢ t = univ ↔ s = univ ∧ t = univ := by\n  simp [eq_univ_iff_forall, forall_and]\n\n"}
{"name":"Set.singleton_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\na : α\n⊢ Eq (SProd.sprod (Singleton.singleton a) t) (Set.image (Prod.mk a) t)","decl":"@[simp]\ntheorem singleton_prod : ({a} : Set α) ×ˢ t = Prod.mk a '' t := by\n  ext ⟨x, y⟩\n  simp [and_left_comm, eq_comm]\n\n"}
{"name":"Set.prod_singleton","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nb : β\n⊢ Eq (SProd.sprod s (Singleton.singleton b)) (Set.image (fun a => { fst := a, snd := b }) s)","decl":"@[simp]\ntheorem prod_singleton : s ×ˢ ({b} : Set β) = (fun a => (a, b)) '' s := by\n  ext ⟨x, y⟩\n  simp [and_left_comm, eq_comm]\n\n"}
{"name":"Set.singleton_prod_singleton","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\nb : β\n⊢ Eq (SProd.sprod (Singleton.singleton a) (Singleton.singleton b)) (Singleton.singleton { fst := a, snd := b })","decl":"theorem singleton_prod_singleton : ({a} : Set α) ×ˢ ({b} : Set β) = {(a, b)} := by simp\n\n"}
{"name":"Set.union_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nt : Set β\n⊢ Eq (SProd.sprod (Union.union s₁ s₂) t) (Union.union (SProd.sprod s₁ t) (SProd.sprod s₂ t))","decl":"@[simp]\ntheorem union_prod : (s₁ ∪ s₂) ×ˢ t = s₁ ×ˢ t ∪ s₂ ×ˢ t := by\n  ext ⟨x, y⟩\n  simp [or_and_right]\n\n"}
{"name":"Set.prod_union","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt₁ t₂ : Set β\n⊢ Eq (SProd.sprod s (Union.union t₁ t₂)) (Union.union (SProd.sprod s t₁) (SProd.sprod s t₂))","decl":"@[simp]\ntheorem prod_union : s ×ˢ (t₁ ∪ t₂) = s ×ˢ t₁ ∪ s ×ˢ t₂ := by\n  ext ⟨x, y⟩\n  simp [and_or_left]\n\n"}
{"name":"Set.inter_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nt : Set β\n⊢ Eq (SProd.sprod (Inter.inter s₁ s₂) t) (Inter.inter (SProd.sprod s₁ t) (SProd.sprod s₂ t))","decl":"theorem inter_prod : (s₁ ∩ s₂) ×ˢ t = s₁ ×ˢ t ∩ s₂ ×ˢ t := by\n  ext ⟨x, y⟩\n  simp only [← and_and_right, mem_inter_iff, mem_prod]\n\n"}
{"name":"Set.prod_inter","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt₁ t₂ : Set β\n⊢ Eq (SProd.sprod s (Inter.inter t₁ t₂)) (Inter.inter (SProd.sprod s t₁) (SProd.sprod s t₂))","decl":"theorem prod_inter : s ×ˢ (t₁ ∩ t₂) = s ×ˢ t₁ ∩ s ×ˢ t₂ := by\n  ext ⟨x, y⟩\n  simp only [← and_and_left, mem_inter_iff, mem_prod]\n\n"}
{"name":"Set.prod_inter_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nt₁ t₂ : Set β\n⊢ Eq (Inter.inter (SProd.sprod s₁ t₁) (SProd.sprod s₂ t₂)) (SProd.sprod (Inter.inter s₁ s₂) (Inter.inter t₁ t₂))","decl":"@[mfld_simps]\ntheorem prod_inter_prod : s₁ ×ˢ t₁ ∩ s₂ ×ˢ t₂ = (s₁ ∩ s₂) ×ˢ (t₁ ∩ t₂) := by\n  ext ⟨x, y⟩\n  simp [and_assoc, and_left_comm]\n\n"}
{"name":"Set.compl_prod_eq_union","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_5\nβ : Type u_6\ns : Set α\nt : Set β\n⊢ Eq (HasCompl.compl (SProd.sprod s t)) (Union.union (SProd.sprod (HasCompl.compl s) Set.univ) (SProd.sprod Set.univ (HasCompl.compl t)))","decl":"lemma compl_prod_eq_union {α β : Type*} (s : Set α) (t : Set β) :\n    (s ×ˢ t)ᶜ = (sᶜ ×ˢ univ) ∪ (univ ×ˢ tᶜ) := by\n  ext p\n  simp only [mem_compl_iff, mem_prod, not_and, mem_union, mem_univ, and_true, true_and]\n  constructor <;> intro h\n  · by_cases fst_in_s : p.fst ∈ s\n    · exact Or.inr (h fst_in_s)\n    · exact Or.inl fst_in_s\n  · intro fst_in_s\n    simpa only [fst_in_s, not_true, false_or] using h\n\n"}
{"name":"Set.disjoint_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nt₁ t₂ : Set β\n⊢ Iff (Disjoint (SProd.sprod s₁ t₁) (SProd.sprod s₂ t₂)) (Or (Disjoint s₁ s₂) (Disjoint t₁ t₂))","decl":"@[simp]\ntheorem disjoint_prod : Disjoint (s₁ ×ˢ t₁) (s₂ ×ˢ t₂) ↔ Disjoint s₁ s₂ ∨ Disjoint t₁ t₂ := by\n  simp_rw [disjoint_left, mem_prod, not_and_or, Prod.forall, and_imp, ← @forall_or_right α, ←\n    @forall_or_left β, ← @forall_or_right (_ ∈ s₁), ← @forall_or_left (_ ∈ t₁)]\n\n"}
{"name":"Set.Disjoint.set_prod_left","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nhs : Disjoint s₁ s₂\nt₁ t₂ : Set β\n⊢ Disjoint (SProd.sprod s₁ t₁) (SProd.sprod s₂ t₂)","decl":"theorem Disjoint.set_prod_left (hs : Disjoint s₁ s₂) (t₁ t₂ : Set β) :\n    Disjoint (s₁ ×ˢ t₁) (s₂ ×ˢ t₂) :=\n  disjoint_left.2 fun ⟨_a, _b⟩ ⟨ha₁, _⟩ ⟨ha₂, _⟩ => disjoint_left.1 hs ha₁ ha₂\n\n"}
{"name":"Set.Disjoint.set_prod_right","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nt₁ t₂ : Set β\nht : Disjoint t₁ t₂\ns₁ s₂ : Set α\n⊢ Disjoint (SProd.sprod s₁ t₁) (SProd.sprod s₂ t₂)","decl":"theorem Disjoint.set_prod_right (ht : Disjoint t₁ t₂) (s₁ s₂ : Set α) :\n    Disjoint (s₁ ×ˢ t₁) (s₂ ×ˢ t₂) :=\n  disjoint_left.2 fun ⟨_a, _b⟩ ⟨_, hb₁⟩ ⟨_, hb₂⟩ => disjoint_left.1 ht hb₁ hb₂\n\n"}
{"name":"Set.insert_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\na : α\n⊢ Eq (SProd.sprod (Insert.insert a s) t) (Union.union (Set.image (Prod.mk a) t) (SProd.sprod s t))","decl":"theorem insert_prod : insert a s ×ˢ t = Prod.mk a '' t ∪ s ×ˢ t := by\n  ext ⟨x, y⟩\n  simp +contextual [image, iff_def, or_imp]\n\n"}
{"name":"Set.prod_insert","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nb : β\n⊢ Eq (SProd.sprod s (Insert.insert b t)) (Union.union (Set.image (fun a => { fst := a, snd := b }) s) (SProd.sprod s t))","decl":"theorem prod_insert : s ×ˢ insert b t = (fun a => (a, b)) '' s ∪ s ×ˢ t := by\n  ext ⟨x, y⟩\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10745):\n  -- was `simp +contextual [image, iff_def, or_imp, Imp.swap]`\n  simp only [mem_prod, mem_insert_iff, image, mem_union, mem_setOf_eq, Prod.mk.injEq]\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · obtain ⟨hx, rfl|hy⟩ := h\n    · exact Or.inl ⟨x, hx, rfl, rfl⟩\n    · exact Or.inr ⟨hx, hy⟩\n  · obtain ⟨x, hx, rfl, rfl⟩|⟨hx, hy⟩ := h\n    · exact ⟨hx, Or.inl rfl⟩\n    · exact ⟨hx, Or.inr hy⟩\n\n"}
{"name":"Set.prod_preimage_eq","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ns : Set α\nt : Set β\nf : γ → α\ng : δ → β\n⊢ Eq (SProd.sprod (Set.preimage f s) (Set.preimage g t)) (Set.preimage (fun p => { fst := f p.1, snd := g p.2 }) (SProd.sprod s t))","decl":"theorem prod_preimage_eq {f : γ → α} {g : δ → β} :\n    (f ⁻¹' s) ×ˢ (g ⁻¹' t) = (fun p : γ × δ => (f p.1, g p.2)) ⁻¹' s ×ˢ t :=\n  rfl\n\n"}
{"name":"Set.prod_preimage_left","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\nf : γ → α\n⊢ Eq (SProd.sprod (Set.preimage f s) t) (Set.preimage (fun p => { fst := f p.1, snd := p.2 }) (SProd.sprod s t))","decl":"theorem prod_preimage_left {f : γ → α} :\n    (f ⁻¹' s) ×ˢ t = (fun p : γ × β => (f p.1, p.2)) ⁻¹' s ×ˢ t :=\n  rfl\n\n"}
{"name":"Set.prod_preimage_right","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_4\ns : Set α\nt : Set β\ng : δ → β\n⊢ Eq (SProd.sprod s (Set.preimage g t)) (Set.preimage (fun p => { fst := p.1, snd := g p.2 }) (SProd.sprod s t))","decl":"theorem prod_preimage_right {g : δ → β} :\n    s ×ˢ (g ⁻¹' t) = (fun p : α × δ => (p.1, g p.2)) ⁻¹' s ×ˢ t :=\n  rfl\n\n"}
{"name":"Set.preimage_prod_map_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : α → β\ng : γ → δ\ns : Set β\nt : Set δ\n⊢ Eq (Set.preimage (Prod.map f g) (SProd.sprod s t)) (SProd.sprod (Set.preimage f s) (Set.preimage g t))","decl":"theorem preimage_prod_map_prod (f : α → β) (g : γ → δ) (s : Set β) (t : Set δ) :\n    Prod.map f g ⁻¹' s ×ˢ t = (f ⁻¹' s) ×ˢ (g ⁻¹' t) :=\n  rfl\n\n"}
{"name":"Set.mk_preimage_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\nf : γ → α\ng : γ → β\n⊢ Eq (Set.preimage (fun x => { fst := f x, snd := g x }) (SProd.sprod s t)) (Inter.inter (Set.preimage f s) (Set.preimage g t))","decl":"theorem mk_preimage_prod (f : γ → α) (g : γ → β) :\n    (fun x => (f x, g x)) ⁻¹' s ×ˢ t = f ⁻¹' s ∩ g ⁻¹' t :=\n  rfl\n\n"}
{"name":"Set.mk_preimage_prod_left","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nb : β\nhb : Membership.mem t b\n⊢ Eq (Set.preimage (fun a => { fst := a, snd := b }) (SProd.sprod s t)) s","decl":"@[simp]\ntheorem mk_preimage_prod_left (hb : b ∈ t) : (fun a => (a, b)) ⁻¹' s ×ˢ t = s := by\n  ext a\n  simp [hb]\n\n"}
{"name":"Set.mk_preimage_prod_right","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\na : α\nha : Membership.mem s a\n⊢ Eq (Set.preimage (Prod.mk a) (SProd.sprod s t)) t","decl":"@[simp]\ntheorem mk_preimage_prod_right (ha : a ∈ s) : Prod.mk a ⁻¹' s ×ˢ t = t := by\n  ext b\n  simp [ha]\n\n"}
{"name":"Set.mk_preimage_prod_left_eq_empty","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nb : β\nhb : Not (Membership.mem t b)\n⊢ Eq (Set.preimage (fun a => { fst := a, snd := b }) (SProd.sprod s t)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem mk_preimage_prod_left_eq_empty (hb : b ∉ t) : (fun a => (a, b)) ⁻¹' s ×ˢ t = ∅ := by\n  ext a\n  simp [hb]\n\n"}
{"name":"Set.mk_preimage_prod_right_eq_empty","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\na : α\nha : Not (Membership.mem s a)\n⊢ Eq (Set.preimage (Prod.mk a) (SProd.sprod s t)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem mk_preimage_prod_right_eq_empty (ha : a ∉ s) : Prod.mk a ⁻¹' s ×ˢ t = ∅ := by\n  ext b\n  simp [ha]\n\n"}
{"name":"Set.mk_preimage_prod_left_eq_if","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nb : β\ninst✝ : DecidablePred fun x => Membership.mem t x\n⊢ Eq (Set.preimage (fun a => { fst := a, snd := b }) (SProd.sprod s t)) (ite (Membership.mem t b) s EmptyCollection.emptyCollection)","decl":"theorem mk_preimage_prod_left_eq_if [DecidablePred (· ∈ t)] :\n    (fun a => (a, b)) ⁻¹' s ×ˢ t = if b ∈ t then s else ∅ := by split_ifs with h <;> simp [h]\n\n"}
{"name":"Set.mk_preimage_prod_right_eq_if","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\na : α\ninst✝ : DecidablePred fun x => Membership.mem s x\n⊢ Eq (Set.preimage (Prod.mk a) (SProd.sprod s t)) (ite (Membership.mem s a) t EmptyCollection.emptyCollection)","decl":"theorem mk_preimage_prod_right_eq_if [DecidablePred (· ∈ s)] :\n    Prod.mk a ⁻¹' s ×ˢ t = if a ∈ s then t else ∅ := by split_ifs with h <;> simp [h]\n\n"}
{"name":"Set.mk_preimage_prod_left_fn_eq_if","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\nb : β\ninst✝ : DecidablePred fun x => Membership.mem t x\nf : γ → α\n⊢ Eq (Set.preimage (fun a => { fst := f a, snd := b }) (SProd.sprod s t)) (ite (Membership.mem t b) (Set.preimage f s) EmptyCollection.emptyCollection)","decl":"theorem mk_preimage_prod_left_fn_eq_if [DecidablePred (· ∈ t)] (f : γ → α) :\n    (fun a => (f a, b)) ⁻¹' s ×ˢ t = if b ∈ t then f ⁻¹' s else ∅ := by\n  rw [← mk_preimage_prod_left_eq_if, prod_preimage_left, preimage_preimage]\n\n"}
{"name":"Set.mk_preimage_prod_right_fn_eq_if","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_4\ns : Set α\nt : Set β\na : α\ninst✝ : DecidablePred fun x => Membership.mem s x\ng : δ → β\n⊢ Eq (Set.preimage (fun b => { fst := a, snd := g b }) (SProd.sprod s t)) (ite (Membership.mem s a) (Set.preimage g t) EmptyCollection.emptyCollection)","decl":"theorem mk_preimage_prod_right_fn_eq_if [DecidablePred (· ∈ s)] (g : δ → β) :\n    (fun b => (a, g b)) ⁻¹' s ×ˢ t = if a ∈ s then g ⁻¹' t else ∅ := by\n  rw [← mk_preimage_prod_right_eq_if, prod_preimage_right, preimage_preimage]\n\n"}
{"name":"Set.preimage_swap_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\n⊢ Eq (Set.preimage Prod.swap (SProd.sprod s t)) (SProd.sprod t s)","decl":"@[simp]\ntheorem preimage_swap_prod (s : Set α) (t : Set β) : Prod.swap ⁻¹' s ×ˢ t = t ×ˢ s := by\n  ext ⟨x, y⟩\n  simp [and_comm]\n\n"}
{"name":"Set.image_swap_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\n⊢ Eq (Set.image Prod.swap (SProd.sprod s t)) (SProd.sprod t s)","decl":"@[simp]\ntheorem image_swap_prod (s : Set α) (t : Set β) : Prod.swap '' s ×ˢ t = t ×ˢ s := by\n  rw [image_swap_eq_preimage_swap, preimage_swap_prod]\n\n"}
{"name":"Set.prod_image_image_eq","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ns : Set α\nt : Set β\nm₁ : α → γ\nm₂ : β → δ\n⊢ Eq (SProd.sprod (Set.image m₁ s) (Set.image m₂ t)) (Set.image (fun p => { fst := m₁ p.1, snd := m₂ p.2 }) (SProd.sprod s t))","decl":"theorem prod_image_image_eq {m₁ : α → γ} {m₂ : β → δ} :\n    (m₁ '' s) ×ˢ (m₂ '' t) = (fun p : α × β => (m₁ p.1, m₂ p.2)) '' s ×ˢ t :=\n  ext <| by\n    simp [-exists_and_right, exists_and_right.symm, and_left_comm, and_assoc, and_comm]\n\n"}
{"name":"Set.prod_range_range_eq","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nm₁ : α → γ\nm₂ : β → δ\n⊢ Eq (SProd.sprod (Set.range m₁) (Set.range m₂)) (Set.range fun p => { fst := m₁ p.1, snd := m₂ p.2 })","decl":"theorem prod_range_range_eq {m₁ : α → γ} {m₂ : β → δ} :\n    range m₁ ×ˢ range m₂ = range fun p : α × β => (m₁ p.1, m₂ p.2) :=\n  ext <| by simp [range]\n\n"}
{"name":"Set.range_prod_map","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nm₁ : α → γ\nm₂ : β → δ\n⊢ Eq (Set.range (Prod.map m₁ m₂)) (SProd.sprod (Set.range m₁) (Set.range m₂))","decl":"@[simp, mfld_simps]\ntheorem range_prod_map {m₁ : α → γ} {m₂ : β → δ} : range (Prod.map m₁ m₂) = range m₁ ×ˢ range m₂ :=\n  prod_range_range_eq.symm\n\n"}
{"name":"Set.prod_range_univ_eq","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm₁ : α → γ\n⊢ Eq (SProd.sprod (Set.range m₁) Set.univ) (Set.range fun p => { fst := m₁ p.1, snd := p.2 })","decl":"theorem prod_range_univ_eq {m₁ : α → γ} :\n    range m₁ ×ˢ (univ : Set β) = range fun p : α × β => (m₁ p.1, p.2) :=\n  ext <| by simp [range]\n\n"}
{"name":"Set.prod_univ_range_eq","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_4\nm₂ : β → δ\n⊢ Eq (SProd.sprod Set.univ (Set.range m₂)) (Set.range fun p => { fst := p.1, snd := m₂ p.2 })","decl":"theorem prod_univ_range_eq {m₂ : β → δ} :\n    (univ : Set α) ×ˢ range m₂ = range fun p : α × β => (p.1, m₂ p.2) :=\n  ext <| by simp [range]\n\n"}
{"name":"Set.range_pair_subset","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\ng : α → γ\n⊢ HasSubset.Subset (Set.range fun x => { fst := f x, snd := g x }) (SProd.sprod (Set.range f) (Set.range g))","decl":"theorem range_pair_subset (f : α → β) (g : α → γ) :\n    (range fun x => (f x, g x)) ⊆ range f ×ˢ range g := by\n  have : (fun x => (f x, g x)) = Prod.map f g ∘ fun x => (x, x) := funext fun x => rfl\n  rw [this, ← range_prod_map]\n  apply range_comp_subset_range\n\n"}
{"name":"Set.Nonempty.prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\na✝¹ : s.Nonempty\na✝ : t.Nonempty\n⊢ (SProd.sprod s t).Nonempty","decl":"theorem Nonempty.prod : s.Nonempty → t.Nonempty → (s ×ˢ t).Nonempty := fun ⟨x, hx⟩ ⟨y, hy⟩ =>\n  ⟨(x, y), ⟨hx, hy⟩⟩\n\n"}
{"name":"Set.Nonempty.fst","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\na✝ : (SProd.sprod s t).Nonempty\n⊢ s.Nonempty","decl":"theorem Nonempty.fst : (s ×ˢ t).Nonempty → s.Nonempty := fun ⟨x, hx⟩ => ⟨x.1, hx.1⟩\n\n"}
{"name":"Set.Nonempty.snd","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\na✝ : (SProd.sprod s t).Nonempty\n⊢ t.Nonempty","decl":"theorem Nonempty.snd : (s ×ˢ t).Nonempty → t.Nonempty := fun ⟨x, hx⟩ => ⟨x.2, hx.2⟩\n\n"}
{"name":"Set.prod_nonempty_iff","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\n⊢ Iff (SProd.sprod s t).Nonempty (And s.Nonempty t.Nonempty)","decl":"@[simp]\ntheorem prod_nonempty_iff : (s ×ˢ t).Nonempty ↔ s.Nonempty ∧ t.Nonempty :=\n  ⟨fun h => ⟨h.fst, h.snd⟩, fun h => h.1.prod h.2⟩\n\n"}
{"name":"Set.prod_eq_empty_iff","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\n⊢ Iff (Eq (SProd.sprod s t) EmptyCollection.emptyCollection) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[simp]\ntheorem prod_eq_empty_iff : s ×ˢ t = ∅ ↔ s = ∅ ∨ t = ∅ := by\n  simp only [not_nonempty_iff_eq_empty.symm, prod_nonempty_iff, not_and_or]\n\n"}
{"name":"Set.prod_sub_preimage_iff","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\nW : Set γ\nf : Prod α β → γ\n⊢ Iff (HasSubset.Subset (SProd.sprod s t) (Set.preimage f W)) (∀ (a : α) (b : β), Membership.mem s a → Membership.mem t b → Membership.mem W (f { fst := a, snd := b }))","decl":"theorem prod_sub_preimage_iff {W : Set γ} {f : α × β → γ} :\n    s ×ˢ t ⊆ f ⁻¹' W ↔ ∀ a b, a ∈ s → b ∈ t → f (a, b) ∈ W := by simp [subset_def]\n\n"}
{"name":"Set.image_prod_mk_subset_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\ng : α → γ\ns : Set α\n⊢ HasSubset.Subset (Set.image (fun x => { fst := f x, snd := g x }) s) (SProd.sprod (Set.image f s) (Set.image g s))","decl":"theorem image_prod_mk_subset_prod {f : α → β} {g : α → γ} {s : Set α} :\n    (fun x => (f x, g x)) '' s ⊆ (f '' s) ×ˢ (g '' s) := by\n  rintro _ ⟨x, hx, rfl⟩\n  exact mk_mem_prod (mem_image_of_mem f hx) (mem_image_of_mem g hx)\n\n"}
{"name":"Set.image_prod_mk_subset_prod_left","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nb : β\nhb : Membership.mem t b\n⊢ HasSubset.Subset (Set.image (fun a => { fst := a, snd := b }) s) (SProd.sprod s t)","decl":"theorem image_prod_mk_subset_prod_left (hb : b ∈ t) : (fun a => (a, b)) '' s ⊆ s ×ˢ t := by\n  rintro _ ⟨a, ha, rfl⟩\n  exact ⟨ha, hb⟩\n\n"}
{"name":"Set.image_prod_mk_subset_prod_right","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\na : α\nha : Membership.mem s a\n⊢ HasSubset.Subset (Set.image (Prod.mk a) t) (SProd.sprod s t)","decl":"theorem image_prod_mk_subset_prod_right (ha : a ∈ s) : Prod.mk a '' t ⊆ s ×ˢ t := by\n  rintro _ ⟨b, hb, rfl⟩\n  exact ⟨ha, hb⟩\n\n"}
{"name":"Set.prod_subset_preimage_fst","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\n⊢ HasSubset.Subset (SProd.sprod s t) (Set.preimage Prod.fst s)","decl":"theorem prod_subset_preimage_fst (s : Set α) (t : Set β) : s ×ˢ t ⊆ Prod.fst ⁻¹' s :=\n  inter_subset_left\n\n"}
{"name":"Set.fst_image_prod_subset","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\n⊢ HasSubset.Subset (Set.image Prod.fst (SProd.sprod s t)) s","decl":"theorem fst_image_prod_subset (s : Set α) (t : Set β) : Prod.fst '' s ×ˢ t ⊆ s :=\n  image_subset_iff.2 <| prod_subset_preimage_fst s t\n\n"}
{"name":"Set.fst_image_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set β\nt : Set α\nht : t.Nonempty\n⊢ Eq (Set.image Prod.fst (SProd.sprod s t)) s","decl":"theorem fst_image_prod (s : Set β) {t : Set α} (ht : t.Nonempty) : Prod.fst '' s ×ˢ t = s :=\n  (fst_image_prod_subset _ _).antisymm fun y hy =>\n    let ⟨x, hx⟩ := ht\n    ⟨(y, x), ⟨hy, hx⟩, rfl⟩\n\n"}
{"name":"Set.mapsTo_fst_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\n⊢ Set.MapsTo Prod.fst (SProd.sprod s t) s","decl":"lemma mapsTo_fst_prod {s : Set α} {t : Set β} : MapsTo Prod.fst (s ×ˢ t) s :=\n  fun _ hx ↦ (mem_prod.1 hx).1\n\n"}
{"name":"Set.prod_subset_preimage_snd","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\n⊢ HasSubset.Subset (SProd.sprod s t) (Set.preimage Prod.snd t)","decl":"theorem prod_subset_preimage_snd (s : Set α) (t : Set β) : s ×ˢ t ⊆ Prod.snd ⁻¹' t :=\n  inter_subset_right\n\n"}
{"name":"Set.snd_image_prod_subset","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\n⊢ HasSubset.Subset (Set.image Prod.snd (SProd.sprod s t)) t","decl":"theorem snd_image_prod_subset (s : Set α) (t : Set β) : Prod.snd '' s ×ˢ t ⊆ t :=\n  image_subset_iff.2 <| prod_subset_preimage_snd s t\n\n"}
{"name":"Set.snd_image_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nhs : s.Nonempty\nt : Set β\n⊢ Eq (Set.image Prod.snd (SProd.sprod s t)) t","decl":"theorem snd_image_prod {s : Set α} (hs : s.Nonempty) (t : Set β) : Prod.snd '' s ×ˢ t = t :=\n  (snd_image_prod_subset _ _).antisymm fun y y_in =>\n    let ⟨x, x_in⟩ := hs\n    ⟨(x, y), ⟨x_in, y_in⟩, rfl⟩\n\n"}
{"name":"Set.mapsTo_snd_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\n⊢ Set.MapsTo Prod.snd (SProd.sprod s t) t","decl":"lemma mapsTo_snd_prod {s : Set α} {t : Set β} : MapsTo Prod.snd (s ×ˢ t) t :=\n  fun _ hx ↦ (mem_prod.1 hx).2\n\n"}
{"name":"Set.prod_diff_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₁ : Set α\nt t₁ : Set β\n⊢ Eq (SDiff.sdiff (SProd.sprod s t) (SProd.sprod s₁ t₁)) (Union.union (SProd.sprod s (SDiff.sdiff t t₁)) (SProd.sprod (SDiff.sdiff s s₁) t))","decl":"theorem prod_diff_prod : s ×ˢ t \\ s₁ ×ˢ t₁ = s ×ˢ (t \\ t₁) ∪ (s \\ s₁) ×ˢ t := by\n  ext x\n  by_cases h₁ : x.1 ∈ s₁ <;> by_cases h₂ : x.2 ∈ t₁ <;> simp [*]\n\n"}
{"name":"Set.prod_subset_prod_iff","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₁ : Set α\nt t₁ : Set β\n⊢ Iff (HasSubset.Subset (SProd.sprod s t) (SProd.sprod s₁ t₁)) (Or (And (HasSubset.Subset s s₁) (HasSubset.Subset t t₁)) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection)))","decl":"/-- A product set is included in a product set if and only factors are included, or a factor of the\nfirst set is empty. -/\ntheorem prod_subset_prod_iff : s ×ˢ t ⊆ s₁ ×ˢ t₁ ↔ s ⊆ s₁ ∧ t ⊆ t₁ ∨ s = ∅ ∨ t = ∅ := by\n  rcases (s ×ˢ t).eq_empty_or_nonempty with h | h\n  · simp [h, prod_eq_empty_iff.1 h]\n  have st : s.Nonempty ∧ t.Nonempty := by rwa [prod_nonempty_iff] at h\n  refine ⟨fun H => Or.inl ⟨?_, ?_⟩, ?_⟩\n  · have := image_subset (Prod.fst : α × β → α) H\n    rwa [fst_image_prod _ st.2, fst_image_prod _ (h.mono H).snd] at this\n  · have := image_subset (Prod.snd : α × β → β) H\n    rwa [snd_image_prod st.1, snd_image_prod (h.mono H).fst] at this\n  · intro H\n    simp only [st.1.ne_empty, st.2.ne_empty, or_false] at H\n    exact prod_mono H.1 H.2\n\n"}
{"name":"Set.prod_eq_prod_iff_of_nonempty","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₁ : Set α\nt t₁ : Set β\nh : (SProd.sprod s t).Nonempty\n⊢ Iff (Eq (SProd.sprod s t) (SProd.sprod s₁ t₁)) (And (Eq s s₁) (Eq t t₁))","decl":"theorem prod_eq_prod_iff_of_nonempty (h : (s ×ˢ t).Nonempty) :\n    s ×ˢ t = s₁ ×ˢ t₁ ↔ s = s₁ ∧ t = t₁ := by\n  constructor\n  · intro heq\n    have h₁ : (s₁ ×ˢ t₁ : Set _).Nonempty := by rwa [← heq]\n    rw [prod_nonempty_iff] at h h₁\n    rw [← fst_image_prod s h.2, ← fst_image_prod s₁ h₁.2, heq, eq_self_iff_true, true_and, ←\n      snd_image_prod h.1 t, ← snd_image_prod h₁.1 t₁, heq]\n  · rintro ⟨rfl, rfl⟩\n    rfl\n\n"}
{"name":"Set.prod_eq_prod_iff","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₁ : Set α\nt t₁ : Set β\n⊢ Iff (Eq (SProd.sprod s t) (SProd.sprod s₁ t₁)) (Or (And (Eq s s₁) (Eq t t₁)) (And (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection)) (Or (Eq s₁ EmptyCollection.emptyCollection) (Eq t₁ EmptyCollection.emptyCollection))))","decl":"theorem prod_eq_prod_iff :\n    s ×ˢ t = s₁ ×ˢ t₁ ↔ s = s₁ ∧ t = t₁ ∨ (s = ∅ ∨ t = ∅) ∧ (s₁ = ∅ ∨ t₁ = ∅) := by\n  symm\n  rcases eq_empty_or_nonempty (s ×ˢ t) with h | h\n  · simp_rw [h, @eq_comm _ ∅, prod_eq_empty_iff, prod_eq_empty_iff.mp h, true_and,\n      or_iff_right_iff_imp]\n    rintro ⟨rfl, rfl⟩\n    exact prod_eq_empty_iff.mp h\n  rw [prod_eq_prod_iff_of_nonempty h]\n  rw [nonempty_iff_ne_empty, Ne, prod_eq_empty_iff] at h\n  simp_rw [h, false_and, or_false]\n\n"}
{"name":"Set.prod_eq_iff_eq","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₁ : Set α\nt : Set β\nht : t.Nonempty\n⊢ Iff (Eq (SProd.sprod s t) (SProd.sprod s₁ t)) (Eq s s₁)","decl":"@[simp]\ntheorem prod_eq_iff_eq (ht : t.Nonempty) : s ×ˢ t = s₁ ×ˢ t ↔ s = s₁ := by\n  simp_rw [prod_eq_prod_iff, ht.ne_empty, and_true, or_iff_left_iff_imp, or_false]\n  rintro ⟨rfl, rfl⟩\n  rfl\n\n"}
{"name":"Set.subset_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set (Prod α β)\n⊢ HasSubset.Subset s (SProd.sprod (Set.image Prod.fst s) (Set.image Prod.snd s))","decl":"theorem subset_prod {s : Set (α × β)} : s ⊆ (Prod.fst '' s) ×ˢ (Prod.snd '' s) :=\n  fun _ hp ↦ mem_prod.2 ⟨mem_image_of_mem _ hp, mem_image_of_mem _ hp⟩\n\n"}
{"name":"Monotone.set_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Preorder α\nf : α → Set β\ng : α → Set γ\nhf : Monotone f\nhg : Monotone g\n⊢ Monotone fun x => SProd.sprod (f x) (g x)","decl":"theorem _root_.Monotone.set_prod (hf : Monotone f) (hg : Monotone g) :\n    Monotone fun x => f x ×ˢ g x :=\n  fun _ _ h => prod_mono (hf h) (hg h)\n\n"}
{"name":"Antitone.set_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Preorder α\nf : α → Set β\ng : α → Set γ\nhf : Antitone f\nhg : Antitone g\n⊢ Antitone fun x => SProd.sprod (f x) (g x)","decl":"theorem _root_.Antitone.set_prod (hf : Antitone f) (hg : Antitone g) :\n    Antitone fun x => f x ×ˢ g x :=\n  fun _ _ h => prod_mono (hf h) (hg h)\n\n"}
{"name":"MonotoneOn.set_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\ninst✝ : Preorder α\nf : α → Set β\ng : α → Set γ\nhf : MonotoneOn f s\nhg : MonotoneOn g s\n⊢ MonotoneOn (fun x => SProd.sprod (f x) (g x)) s","decl":"theorem _root_.MonotoneOn.set_prod (hf : MonotoneOn f s) (hg : MonotoneOn g s) :\n    MonotoneOn (fun x => f x ×ˢ g x) s := fun _ ha _ hb h => prod_mono (hf ha hb h) (hg ha hb h)\n\n"}
{"name":"AntitoneOn.set_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\ninst✝ : Preorder α\nf : α → Set β\ng : α → Set γ\nhf : AntitoneOn f s\nhg : AntitoneOn g s\n⊢ AntitoneOn (fun x => SProd.sprod (f x) (g x)) s","decl":"theorem _root_.AntitoneOn.set_prod (hf : AntitoneOn f s) (hg : AntitoneOn g s) :\n    AntitoneOn (fun x => f x ×ˢ g x) s := fun _ ha _ hb h => prod_mono (hf ha hb h) (hg ha hb h)\n\n"}
{"name":"Set.diagonal_nonempty","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\ninst✝ : Nonempty α\n⊢ (Set.diagonal α).Nonempty","decl":"lemma diagonal_nonempty [Nonempty α] : (diagonal α).Nonempty :=\n  Nonempty.elim ‹_› fun x => ⟨_, mem_diagonal x⟩\n\n"}
{"name":"Set.preimage_coe_coe_diagonal","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Set.preimage (Prod.map (fun x => ↑x) fun x => ↑x) (Set.diagonal α)) (Set.diagonal ↑s)","decl":"theorem preimage_coe_coe_diagonal (s : Set α) :\n    Prod.map (fun x : s => (x : α)) (fun x : s => (x : α)) ⁻¹' diagonal α = diagonal s := by\n  ext ⟨⟨x, hx⟩, ⟨y, hy⟩⟩\n  simp [Set.diagonal]\n\n"}
{"name":"Set.range_diag","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\n⊢ Eq (Set.range fun x => { fst := x, snd := x }) (Set.diagonal α)","decl":"@[simp]\ntheorem range_diag : (range fun x => (x, x)) = diagonal α := by\n  ext ⟨x, y⟩\n  simp [diagonal, eq_comm]\n\n"}
{"name":"Set.diagonal_subset_iff","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\ns : Set (Prod α α)\n⊢ Iff (HasSubset.Subset (Set.diagonal α) s) (∀ (x : α), Membership.mem s { fst := x, snd := x })","decl":"theorem diagonal_subset_iff {s} : diagonal α ⊆ s ↔ ∀ x, (x, x) ∈ s := by\n  rw [← range_diag, range_subset_iff]\n\n"}
{"name":"Set.prod_subset_compl_diagonal_iff_disjoint","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Iff (HasSubset.Subset (SProd.sprod s t) (HasCompl.compl (Set.diagonal α))) (Disjoint s t)","decl":"@[simp]\ntheorem prod_subset_compl_diagonal_iff_disjoint : s ×ˢ t ⊆ (diagonal α)ᶜ ↔ Disjoint s t :=\n  prod_subset_iff.trans disjoint_iff_forall_ne.symm\n\n"}
{"name":"Set.diag_preimage_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Eq (Set.preimage (fun x => { fst := x, snd := x }) (SProd.sprod s t)) (Inter.inter s t)","decl":"@[simp]\ntheorem diag_preimage_prod (s t : Set α) : (fun x => (x, x)) ⁻¹' s ×ˢ t = s ∩ t :=\n  rfl\n\n"}
{"name":"Set.diag_preimage_prod_self","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Set.preimage (fun x => { fst := x, snd := x }) (SProd.sprod s s)) s","decl":"theorem diag_preimage_prod_self (s : Set α) : (fun x => (x, x)) ⁻¹' s ×ˢ s = s :=\n  inter_self s\n\n"}
{"name":"Set.diag_image","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Set.image (fun x => { fst := x, snd := x }) s) (Inter.inter (Set.diagonal α) (SProd.sprod s s))","decl":"theorem diag_image (s : Set α) : (fun x => (x, x)) '' s = diagonal α ∩ s ×ˢ s := by\n  rw [← range_diag, ← image_preimage_eq_range_inter, diag_preimage_prod_self]\n\n"}
{"name":"Set.diagonal_eq_univ_iff","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\n⊢ Iff (Eq (Set.diagonal α) Set.univ) (Subsingleton α)","decl":"theorem diagonal_eq_univ_iff : diagonal α = univ ↔ Subsingleton α := by\n  simp only [subsingleton_iff, eq_univ_iff_forall, Prod.forall, mem_diagonal_iff]\n\n"}
{"name":"Set.diagonal_eq_univ","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\ninst✝ : Subsingleton α\n⊢ Eq (Set.diagonal α) Set.univ","decl":"theorem diagonal_eq_univ [Subsingleton α] : diagonal α = univ := diagonal_eq_univ_iff.2 ‹_›\n\n"}
{"name":"Set.range_const_eq_diagonal","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nhβ : Nonempty β\n⊢ Eq (Set.range (Function.const α)) (setOf fun f => ∀ (x y : α), Eq (f x) (f y))","decl":"/-- A function is `Function.const α a` for some `a` if and only if `∀ x y, f x = f y`. -/\ntheorem range_const_eq_diagonal {α β : Type*} [hβ : Nonempty β] :\n    range (const α) = {f : α → β | ∀ x y, f x = f y} := by\n  refine (range_eq_iff _ _).mpr ⟨fun _ _ _ ↦ rfl, fun f hf ↦ ?_⟩\n  rcases isEmpty_or_nonempty α with h|⟨⟨a⟩⟩\n  · exact hβ.elim fun b ↦ ⟨b, Subsingleton.elim _ _⟩\n  · exact ⟨f a, funext fun x ↦ hf _ _⟩\n\n"}
{"name":"Function.pullback_comm_sq","module":"Mathlib.Data.Set.Prod","initialProofState":"X : Type u_2\nY : Sort u_3\nZ : Type u_1\nf : X → Y\ng : Z → Y\n⊢ Eq (Function.comp f Function.Pullback.fst) (Function.comp g Function.Pullback.snd)","decl":"open Function.Pullback in\nlemma Function.pullback_comm_sq (f : X → Y) (g : Z → Y) :\n    f ∘ @fst X Y Z f g = g ∘ @snd X Y Z f g := funext fun p ↦ p.2\n\n"}
{"name":"preimage_map_fst_pullbackDiagonal","module":"Mathlib.Data.Set.Prod","initialProofState":"X : Type u_2\nY : Sort u_3\nZ : Type u_1\nf : X → Y\ng : Z → Y\n⊢ Eq (Set.preimage Function.PullbackSelf.map_fst (Function.pullbackDiagonal f)) (Function.pullbackDiagonal Function.Pullback.snd)","decl":"theorem preimage_map_fst_pullbackDiagonal {f : X → Y} {g : Z → Y} :\n    @map_fst X Y Z f g ⁻¹' pullbackDiagonal f = pullbackDiagonal (@snd X Y Z f g) := by\n  ext ⟨⟨p₁, p₂⟩, he⟩\n  simp_rw [pullbackDiagonal, mem_setOf, Subtype.ext_iff, Prod.ext_iff]\n  exact (and_iff_left he).symm\n\n"}
{"name":"Function.Injective.preimage_pullbackDiagonal","module":"Mathlib.Data.Set.Prod","initialProofState":"X : Type u_2\nY : Sort u_3\nZ : Type u_1\nf : X → Y\ng : Z → X\ninj : Function.Injective g\n⊢ Eq (Set.preimage (Function.mapPullback g id g ⋯ ⋯) (Function.pullbackDiagonal f)) (Function.pullbackDiagonal (Function.comp f g))","decl":"theorem Function.Injective.preimage_pullbackDiagonal {f : X → Y} {g : Z → X} (inj : g.Injective) :\n    mapPullback g id g (by rfl) (by rfl) ⁻¹' pullbackDiagonal f = pullbackDiagonal (f ∘ g) :=\n  ext fun _ ↦ inj.eq_iff\n\n"}
{"name":"image_toPullbackDiag","module":"Mathlib.Data.Set.Prod","initialProofState":"X : Type u_1\nY : Sort u_2\nf : X → Y\ns : Set X\n⊢ Eq (Set.image (toPullbackDiag f) s) (Inter.inter (Function.pullbackDiagonal f) (Set.preimage Subtype.val (SProd.sprod s s)))","decl":"theorem image_toPullbackDiag (f : X → Y) (s : Set X) :\n    toPullbackDiag f '' s = pullbackDiagonal f ∩ Subtype.val ⁻¹' s ×ˢ s := by\n  ext x\n  constructor\n  · rintro ⟨x, hx, rfl⟩\n    exact ⟨rfl, hx, hx⟩\n  · obtain ⟨⟨x, y⟩, h⟩ := x\n    rintro ⟨rfl : x = y, h2x⟩\n    exact mem_image_of_mem _ h2x.1\n\n"}
{"name":"range_toPullbackDiag","module":"Mathlib.Data.Set.Prod","initialProofState":"X : Type u_1\nY : Sort u_2\nf : X → Y\n⊢ Eq (Set.range (toPullbackDiag f)) (Function.pullbackDiagonal f)","decl":"theorem range_toPullbackDiag (f : X → Y) : range (toPullbackDiag f) = pullbackDiagonal f := by\n  rw [← image_univ, image_toPullbackDiag, univ_prod_univ, preimage_univ, inter_univ]\n\n"}
{"name":"injective_toPullbackDiag","module":"Mathlib.Data.Set.Prod","initialProofState":"X : Type u_1\nY : Sort u_2\nf : X → Y\n⊢ Function.Injective (toPullbackDiag f)","decl":"theorem injective_toPullbackDiag (f : X → Y) : (toPullbackDiag f).Injective :=\n  fun _ _ h ↦ congr_arg Prod.fst (congr_arg Subtype.val h)\n\n"}
{"name":"Set.offDiag_mono","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\n⊢ Monotone Set.offDiag","decl":"theorem offDiag_mono : Monotone (offDiag : Set α → Set (α × α)) := fun _ _ h _ =>\n  And.imp (@h _) <| And.imp_left <| @h _\n\n"}
{"name":"Set.offDiag_nonempty","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff s.offDiag.Nonempty s.Nontrivial","decl":"@[simp]\ntheorem offDiag_nonempty : s.offDiag.Nonempty ↔ s.Nontrivial := by\n  simp [offDiag, Set.Nonempty, Set.Nontrivial]\n\n"}
{"name":"Set.offDiag_eq_empty","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (Eq s.offDiag EmptyCollection.emptyCollection) s.Subsingleton","decl":"@[simp]\ntheorem offDiag_eq_empty : s.offDiag = ∅ ↔ s.Subsingleton := by\n  rw [← not_nonempty_iff_eq_empty, ← not_nontrivial_iff, offDiag_nonempty.not]\n\n"}
{"name":"Set.Nontrivial.offDiag_nonempty","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\ns : Set α\na✝ : s.Nontrivial\n⊢ s.offDiag.Nonempty","decl":"alias ⟨_, Nontrivial.offDiag_nonempty⟩ := offDiag_nonempty\n\n"}
{"name":"Set.Subsingleton.offDiag_eq_empty","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\ns : Set α\na✝ : s.Nontrivial\n⊢ s.offDiag.Nonempty","decl":"alias ⟨_, Subsingleton.offDiag_eq_empty⟩ := offDiag_nonempty\n\n"}
{"name":"Set.offDiag_subset_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\ns : Set α\n⊢ HasSubset.Subset s.offDiag (SProd.sprod s s)","decl":"theorem offDiag_subset_prod : s.offDiag ⊆ s ×ˢ s := fun _ hx => ⟨hx.1, hx.2.1⟩\n\n"}
{"name":"Set.offDiag_eq_sep_prod","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq s.offDiag (setOf fun x => And (Membership.mem (SProd.sprod s s) x) (Ne x.1 x.2))","decl":"theorem offDiag_eq_sep_prod : s.offDiag = { x ∈ s ×ˢ s | x.1 ≠ x.2 } :=\n  ext fun _ => and_assoc.symm\n\n"}
{"name":"Set.offDiag_empty","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\n⊢ Eq EmptyCollection.emptyCollection.offDiag EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem offDiag_empty : (∅ : Set α).offDiag = ∅ := by simp\n\n"}
{"name":"Set.offDiag_singleton","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\na : α\n⊢ Eq (Singleton.singleton a).offDiag EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem offDiag_singleton (a : α) : ({a} : Set α).offDiag = ∅ := by simp\n\n"}
{"name":"Set.offDiag_univ","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\n⊢ Eq Set.univ.offDiag (HasCompl.compl (Set.diagonal α))","decl":"@[simp]\ntheorem offDiag_univ : (univ : Set α).offDiag = (diagonal α)ᶜ :=\n  ext <| by simp\n\n"}
{"name":"Set.prod_sdiff_diagonal","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (SDiff.sdiff (SProd.sprod s s) (Set.diagonal α)) s.offDiag","decl":"@[simp]\ntheorem prod_sdiff_diagonal : s ×ˢ s \\ diagonal α = s.offDiag :=\n  ext fun _ => and_assoc\n\n"}
{"name":"Set.disjoint_diagonal_offDiag","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\ns : Set α\n⊢ Disjoint (Set.diagonal α) s.offDiag","decl":"@[simp]\ntheorem disjoint_diagonal_offDiag : Disjoint (diagonal α) s.offDiag :=\n  disjoint_left.mpr fun _ hd ho => ho.2.2 hd\n\n"}
{"name":"Set.offDiag_inter","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Eq (Inter.inter s t).offDiag (Inter.inter s.offDiag t.offDiag)","decl":"theorem offDiag_inter : (s ∩ t).offDiag = s.offDiag ∩ t.offDiag :=\n  ext fun x => by\n    simp only [mem_offDiag, mem_inter_iff]\n    tauto\n\n"}
{"name":"Set.offDiag_union","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\ns t : Set α\nh : Disjoint s t\n⊢ Eq (Union.union s t).offDiag (Union.union (Union.union (Union.union s.offDiag t.offDiag) (SProd.sprod s t)) (SProd.sprod t s))","decl":"theorem offDiag_union (h : Disjoint s t) :\n    (s ∪ t).offDiag = s.offDiag ∪ t.offDiag ∪ s ×ˢ t ∪ t ×ˢ s := by\n  ext x\n  simp only [mem_offDiag, mem_union, ne_eq, mem_prod]\n  constructor\n  · rintro ⟨h0|h0, h1|h1, h2⟩ <;> simp [h0, h1, h2]\n  · rintro (((⟨h0, h1, h2⟩|⟨h0, h1, h2⟩)|⟨h0, h1⟩)|⟨h0, h1⟩) <;> simp [*]\n    · rintro h3\n      rw [h3] at h0\n      exact Set.disjoint_left.mp h h0 h1\n    · rintro h3\n      rw [h3] at h0\n      exact (Set.disjoint_right.mp h h0 h1).elim\n\n"}
{"name":"Set.offDiag_insert","module":"Mathlib.Data.Set.Prod","initialProofState":"α : Type u_1\ns : Set α\na : α\nha : Not (Membership.mem s a)\n⊢ Eq (Insert.insert a s).offDiag (Union.union (Union.union s.offDiag (SProd.sprod (Singleton.singleton a) s)) (SProd.sprod s (Singleton.singleton a)))","decl":"theorem offDiag_insert (ha : a ∉ s) : (insert a s).offDiag = s.offDiag ∪ {a} ×ˢ s ∪ s ×ˢ {a} := by\n  rw [insert_eq, union_comm, offDiag_union, offDiag_singleton, union_empty, union_right_comm]\n  rw [disjoint_left]\n  rintro b hb (rfl : b = a)\n  exact ha hb\n\n"}
{"name":"Set.empty_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : (i : ι) → Set (α i)\n⊢ Eq (EmptyCollection.emptyCollection.pi s) Set.univ","decl":"@[simp]\ntheorem empty_pi (s : ∀ i, Set (α i)) : pi ∅ s = univ := by\n  ext\n  simp [pi]\n\n"}
{"name":"Set.subsingleton_univ_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nt : (i : ι) → Set (α i)\nht : ∀ (i : ι), (t i).Subsingleton\n⊢ (Set.univ.pi t).Subsingleton","decl":"theorem subsingleton_univ_pi (ht : ∀ i, (t i).Subsingleton) :\n    (univ.pi t).Subsingleton := fun _f hf _g hg ↦ funext fun i ↦\n  (ht i) (hf _ <| mem_univ _) (hg _ <| mem_univ _)\n\n"}
{"name":"Set.pi_univ","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Set ι\n⊢ Eq (s.pi fun i => Set.univ) Set.univ","decl":"@[simp]\ntheorem pi_univ (s : Set ι) : (pi s fun i => (univ : Set (α i))) = univ :=\n  eq_univ_of_forall fun _ _ _ => mem_univ _\n\n"}
{"name":"Set.pi_univ_ite","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Set ι\ninst✝ : DecidablePred fun x => Membership.mem s x\nt : (i : ι) → Set (α i)\n⊢ Eq (Set.univ.pi fun i => ite (Membership.mem s i) (t i) Set.univ) (s.pi t)","decl":"@[simp]\ntheorem pi_univ_ite (s : Set ι) [DecidablePred (· ∈ s)] (t : ∀ i, Set (α i)) :\n    (pi univ fun i => if i ∈ s then t i else univ) = s.pi t := by\n  ext; simp_rw [Set.mem_pi]; apply forall_congr'; intro i; split_ifs with h <;> simp [h]\n\n"}
{"name":"Set.pi_mono","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Set ι\nt₁ t₂ : (i : ι) → Set (α i)\nh : ∀ (i : ι), Membership.mem s i → HasSubset.Subset (t₁ i) (t₂ i)\n⊢ HasSubset.Subset (s.pi t₁) (s.pi t₂)","decl":"theorem pi_mono (h : ∀ i ∈ s, t₁ i ⊆ t₂ i) : pi s t₁ ⊆ pi s t₂ := fun _ hx i hi => h i hi <| hx i hi\n\n"}
{"name":"Set.pi_inter_distrib","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Set ι\nt t₁ : (i : ι) → Set (α i)\n⊢ Eq (s.pi fun i => Inter.inter (t i) (t₁ i)) (Inter.inter (s.pi t) (s.pi t₁))","decl":"theorem pi_inter_distrib : (s.pi fun i => t i ∩ t₁ i) = s.pi t ∩ s.pi t₁ :=\n  ext fun x => by simp only [forall_and, mem_pi, mem_inter_iff]\n\n"}
{"name":"Set.pi_congr","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns₁ s₂ : Set ι\nt₁ t₂ : (i : ι) → Set (α i)\nh : Eq s₁ s₂\nh' : ∀ (i : ι), Membership.mem s₁ i → Eq (t₁ i) (t₂ i)\n⊢ Eq (s₁.pi t₁) (s₂.pi t₂)","decl":"theorem pi_congr (h : s₁ = s₂) (h' : ∀ i ∈ s₁, t₁ i = t₂ i) : s₁.pi t₁ = s₂.pi t₂ :=\n  h ▸ ext fun _ => forall₂_congr fun i hi => h' i hi ▸ Iff.rfl\n\n"}
{"name":"Set.pi_eq_empty","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Set ι\nt : (i : ι) → Set (α i)\ni : ι\nhs : Membership.mem s i\nht : Eq (t i) EmptyCollection.emptyCollection\n⊢ Eq (s.pi t) EmptyCollection.emptyCollection","decl":"theorem pi_eq_empty (hs : i ∈ s) (ht : t i = ∅) : s.pi t = ∅ := by\n  ext f\n  simp only [mem_empty_iff_false, not_forall, iff_false, mem_pi, Classical.not_imp]\n  exact ⟨i, hs, by simp [ht]⟩\n\n"}
{"name":"Set.univ_pi_eq_empty","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nt : (i : ι) → Set (α i)\ni : ι\nht : Eq (t i) EmptyCollection.emptyCollection\n⊢ Eq (Set.univ.pi t) EmptyCollection.emptyCollection","decl":"theorem univ_pi_eq_empty (ht : t i = ∅) : pi univ t = ∅ :=\n  pi_eq_empty (mem_univ i) ht\n\n"}
{"name":"Set.pi_nonempty_iff","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Set ι\nt : (i : ι) → Set (α i)\n⊢ Iff (s.pi t).Nonempty (∀ (i : ι), Exists fun x => Membership.mem s i → Membership.mem (t i) x)","decl":"theorem pi_nonempty_iff : (s.pi t).Nonempty ↔ ∀ i, ∃ x, i ∈ s → x ∈ t i := by\n  simp [Classical.skolem, Set.Nonempty]\n\n"}
{"name":"Set.univ_pi_nonempty_iff","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nt : (i : ι) → Set (α i)\n⊢ Iff (Set.univ.pi t).Nonempty (∀ (i : ι), (t i).Nonempty)","decl":"theorem univ_pi_nonempty_iff : (pi univ t).Nonempty ↔ ∀ i, (t i).Nonempty := by\n  simp [Classical.skolem, Set.Nonempty]\n\n"}
{"name":"Set.pi_eq_empty_iff","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Set ι\nt : (i : ι) → Set (α i)\n⊢ Iff (Eq (s.pi t) EmptyCollection.emptyCollection) (Exists fun i => Or (IsEmpty (α i)) (And (Membership.mem s i) (Eq (t i) EmptyCollection.emptyCollection)))","decl":"theorem pi_eq_empty_iff : s.pi t = ∅ ↔ ∃ i, IsEmpty (α i) ∨ i ∈ s ∧ t i = ∅ := by\n  rw [← not_nonempty_iff_eq_empty, pi_nonempty_iff]\n  push_neg\n  refine exists_congr fun i => ?_\n  cases isEmpty_or_nonempty (α i) <;> simp [*, forall_and, eq_empty_iff_forall_not_mem]\n\n"}
{"name":"Set.univ_pi_eq_empty_iff","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nt : (i : ι) → Set (α i)\n⊢ Iff (Eq (Set.univ.pi t) EmptyCollection.emptyCollection) (Exists fun i => Eq (t i) EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem univ_pi_eq_empty_iff : pi univ t = ∅ ↔ ∃ i, t i = ∅ := by\n  simp [← not_nonempty_iff_eq_empty, univ_pi_nonempty_iff]\n\n"}
{"name":"Set.univ_pi_empty","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nh : Nonempty ι\n⊢ Eq (Set.univ.pi fun x => EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem univ_pi_empty [h : Nonempty ι] : pi univ (fun _ => ∅ : ∀ i, Set (α i)) = ∅ :=\n  univ_pi_eq_empty_iff.2 <| h.elim fun x => ⟨x, rfl⟩\n\n"}
{"name":"Set.disjoint_univ_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nt₁ t₂ : (i : ι) → Set (α i)\n⊢ Iff (Disjoint (Set.univ.pi t₁) (Set.univ.pi t₂)) (Exists fun i => Disjoint (t₁ i) (t₂ i))","decl":"@[simp]\ntheorem disjoint_univ_pi : Disjoint (pi univ t₁) (pi univ t₂) ↔ ∃ i, Disjoint (t₁ i) (t₂ i) := by\n  simp only [disjoint_iff_inter_eq_empty, ← pi_inter_distrib, univ_pi_eq_empty_iff]\n\n"}
{"name":"Set.Disjoint.set_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Set ι\nt₁ t₂ : (i : ι) → Set (α i)\ni : ι\nhi : Membership.mem s i\nht : Disjoint (t₁ i) (t₂ i)\n⊢ Disjoint (s.pi t₁) (s.pi t₂)","decl":"theorem Disjoint.set_pi (hi : i ∈ s) (ht : Disjoint (t₁ i) (t₂ i)) : Disjoint (s.pi t₁) (s.pi t₂) :=\n  disjoint_left.2 fun _ h₁ h₂ => disjoint_left.1 ht (h₁ _ hi) (h₂ _ hi)\n\n"}
{"name":"Set.uniqueElim_preimage","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : Unique ι\nt : (i : ι) → Set (α i)\n⊢ Eq (Set.preimage uniqueElim (Set.univ.pi t)) (t Inhabited.default)","decl":"theorem uniqueElim_preimage [Unique ι] (t : ∀ i, Set (α i)) :\n    uniqueElim ⁻¹' pi univ t = t (default : ι) := by ext; simp [Unique.forall_iff]\n\n"}
{"name":"Set.pi_eq_empty_iff'","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Set ι\nt : (i : ι) → Set (α i)\ninst✝ : ∀ (i : ι), Nonempty (α i)\n⊢ Iff (Eq (s.pi t) EmptyCollection.emptyCollection) (Exists fun i => And (Membership.mem s i) (Eq (t i) EmptyCollection.emptyCollection))","decl":"theorem pi_eq_empty_iff' : s.pi t = ∅ ↔ ∃ i ∈ s, t i = ∅ := by simp [pi_eq_empty_iff]\n\n"}
{"name":"Set.disjoint_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Set ι\nt₁ t₂ : (i : ι) → Set (α i)\ninst✝ : ∀ (i : ι), Nonempty (α i)\n⊢ Iff (Disjoint (s.pi t₁) (s.pi t₂)) (Exists fun i => And (Membership.mem s i) (Disjoint (t₁ i) (t₂ i)))","decl":"@[simp]\ntheorem disjoint_pi : Disjoint (s.pi t₁) (s.pi t₂) ↔ ∃ i ∈ s, Disjoint (t₁ i) (t₂ i) := by\n  simp only [disjoint_iff_inter_eq_empty, ← pi_inter_distrib, pi_eq_empty_iff']\n\n"}
{"name":"Set.insert_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ni : ι\ns : Set ι\nt : (i : ι) → Set (α i)\n⊢ Eq ((Insert.insert i s).pi t) (Inter.inter (Set.preimage (Function.eval i) (t i)) (s.pi t))","decl":"@[simp]\ntheorem insert_pi (i : ι) (s : Set ι) (t : ∀ i, Set (α i)) :\n    pi (insert i s) t = eval i ⁻¹' t i ∩ pi s t := by\n  ext\n  simp [pi, or_imp, forall_and]\n\n"}
{"name":"Set.singleton_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ni : ι\nt : (i : ι) → Set (α i)\n⊢ Eq ((Singleton.singleton i).pi t) (Set.preimage (Function.eval i) (t i))","decl":"@[simp]\ntheorem singleton_pi (i : ι) (t : ∀ i, Set (α i)) : pi {i} t = eval i ⁻¹' t i := by\n  ext\n  simp [pi]\n\n"}
{"name":"Set.singleton_pi'","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ni : ι\nt : (i : ι) → Set (α i)\n⊢ Eq ((Singleton.singleton i).pi t) (setOf fun x => Membership.mem (t i) (x i))","decl":"theorem singleton_pi' (i : ι) (t : ∀ i, Set (α i)) : pi {i} t = { x | x i ∈ t i } :=\n  singleton_pi i t\n\n"}
{"name":"Set.univ_pi_singleton","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nf : (i : ι) → α i\n⊢ Eq (Set.univ.pi fun i => Singleton.singleton (f i)) (Singleton.singleton f)","decl":"theorem univ_pi_singleton (f : ∀ i, α i) : (pi univ fun i => {f i}) = ({f} : Set (∀ i, α i)) :=\n  ext fun g => by simp [funext_iff]\n\n"}
{"name":"Set.preimage_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (β i)\nf : (i : ι) → α i → β i\n⊢ Eq (Set.preimage (fun g i => f i (g i)) (s.pi t)) (s.pi fun i => Set.preimage (f i) (t i))","decl":"theorem preimage_pi (s : Set ι) (t : ∀ i, Set (β i)) (f : ∀ i, α i → β i) :\n    (fun (g : ∀ i, α i) i => f _ (g i)) ⁻¹' s.pi t = s.pi fun i => f i ⁻¹' t i :=\n  rfl\n\n"}
{"name":"Set.pi_if","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\np : ι → Prop\nh : DecidablePred p\ns : Set ι\nt₁ t₂ : (i : ι) → Set (α i)\n⊢ Eq (s.pi fun i => ite (p i) (t₁ i) (t₂ i)) (Inter.inter ((setOf fun i => And (Membership.mem s i) (p i)).pi t₁) ((setOf fun i => And (Membership.mem s i) (Not (p i))).pi t₂))","decl":"theorem pi_if {p : ι → Prop} [h : DecidablePred p] (s : Set ι) (t₁ t₂ : ∀ i, Set (α i)) :\n    (pi s fun i => if p i then t₁ i else t₂ i) =\n      pi ({ i ∈ s | p i }) t₁ ∩ pi ({ i ∈ s | ¬p i }) t₂ := by\n  ext f\n  refine ⟨fun h => ?_, ?_⟩\n  · constructor <;>\n      · rintro i ⟨his, hpi⟩\n        simpa [*] using h i\n  · rintro ⟨ht₁, ht₂⟩ i his\n    by_cases p i <;> simp_all\n\n"}
{"name":"Set.union_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns₁ s₂ : Set ι\nt : (i : ι) → Set (α i)\n⊢ Eq ((Union.union s₁ s₂).pi t) (Inter.inter (s₁.pi t) (s₂.pi t))","decl":"theorem union_pi : (s₁ ∪ s₂).pi t = s₁.pi t ∩ s₂.pi t := by\n  simp [pi, or_imp, forall_and, setOf_and]\n\n"}
{"name":"Set.union_pi_inter","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns₁ s₂ : Set ι\nt₁ t₂ : (i : ι) → Set (α i)\nht₁ : ∀ (i : ι), Not (Membership.mem s₁ i) → Eq (t₁ i) Set.univ\nht₂ : ∀ (i : ι), Not (Membership.mem s₂ i) → Eq (t₂ i) Set.univ\n⊢ Eq ((Union.union s₁ s₂).pi fun i => Inter.inter (t₁ i) (t₂ i)) (Inter.inter (s₁.pi t₁) (s₂.pi t₂))","decl":"theorem union_pi_inter\n    (ht₁ : ∀ i ∉ s₁, t₁ i = univ) (ht₂ : ∀ i ∉ s₂, t₂ i = univ) :\n    (s₁ ∪ s₂).pi (fun i ↦ t₁ i ∩ t₂ i) = s₁.pi t₁ ∩ s₂.pi t₂ := by\n  ext x\n  simp only [mem_pi, mem_union, mem_inter_iff]\n  refine ⟨fun h ↦ ⟨fun i his₁ ↦ (h i (Or.inl his₁)).1, fun i his₂ ↦ (h i (Or.inr his₂)).2⟩,\n    fun h i hi ↦ ?_⟩\n  rcases hi with hi | hi\n  · by_cases hi2 : i ∈ s₂\n    · exact ⟨h.1 i hi, h.2 i hi2⟩\n    · refine ⟨h.1 i hi, ?_⟩\n      rw [ht₂ i hi2]\n      exact mem_univ _\n  · by_cases hi1 : i ∈ s₁\n    · exact ⟨h.1 i hi1, h.2 i hi⟩\n    · refine ⟨?_, h.2 i hi⟩\n      rw [ht₁ i hi1]\n      exact mem_univ _\n\n"}
{"name":"Set.pi_inter_compl","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nt : (i : ι) → Set (α i)\ns : Set ι\n⊢ Eq (Inter.inter (s.pi t) ((HasCompl.compl s).pi t)) (Set.univ.pi t)","decl":"@[simp]\ntheorem pi_inter_compl (s : Set ι) : pi s t ∩ pi sᶜ t = pi univ t := by\n  rw [← union_pi, union_compl_self]\n\n"}
{"name":"Set.pi_update_of_not_mem","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : ι → Type u_3\ns : Set ι\ni : ι\ninst✝ : DecidableEq ι\nhi : Not (Membership.mem s i)\nf : (j : ι) → α j\na : α i\nt : (j : ι) → α j → Set (β j)\n⊢ Eq (s.pi fun j => t j (Function.update f i a j)) (s.pi fun j => t j (f j))","decl":"theorem pi_update_of_not_mem [DecidableEq ι] (hi : i ∉ s) (f : ∀ j, α j) (a : α i)\n    (t : ∀ j, α j → Set (β j)) : (s.pi fun j => t j (update f i a j)) = s.pi fun j => t j (f j) :=\n  (pi_congr rfl) fun j hj => by\n    rw [update_of_ne]\n    exact fun h => hi (h ▸ hj)\n\n"}
{"name":"Set.pi_update_of_mem","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : ι → Type u_3\ns : Set ι\ni : ι\ninst✝ : DecidableEq ι\nhi : Membership.mem s i\nf : (j : ι) → α j\na : α i\nt : (j : ι) → α j → Set (β j)\n⊢ Eq (s.pi fun j => t j (Function.update f i a j)) (Inter.inter (setOf fun x => Membership.mem (t i a) (x i)) ((SDiff.sdiff s (Singleton.singleton i)).pi fun j => t j (f j)))","decl":"theorem pi_update_of_mem [DecidableEq ι] (hi : i ∈ s) (f : ∀ j, α j) (a : α i)\n    (t : ∀ j, α j → Set (β j)) :\n    (s.pi fun j => t j (update f i a j)) = { x | x i ∈ t i a } ∩ (s \\ {i}).pi fun j => t j (f j) :=\n  calc\n    (s.pi fun j => t j (update f i a j)) = ({i} ∪ s \\ {i}).pi fun j => t j (update f i a j) := by\n        rw [union_diff_self, union_eq_self_of_subset_left (singleton_subset_iff.2 hi)]\n    _ = { x | x i ∈ t i a } ∩ (s \\ {i}).pi fun j => t j (f j) := by\n        rw [union_pi, singleton_pi', update_self, pi_update_of_not_mem]; simp\n\n"}
{"name":"Set.univ_pi_update","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : DecidableEq ι\nβ : ι → Type u_4\ni : ι\nf : (j : ι) → α j\na : α i\nt : (j : ι) → α j → Set (β j)\n⊢ Eq (Set.univ.pi fun j => t j (Function.update f i a j)) (Inter.inter (setOf fun x => Membership.mem (t i a) (x i)) ((HasCompl.compl (Singleton.singleton i)).pi fun j => t j (f j)))","decl":"theorem univ_pi_update [DecidableEq ι] {β : ι → Type*} (i : ι) (f : ∀ j, α j) (a : α i)\n    (t : ∀ j, α j → Set (β j)) :\n    (pi univ fun j => t j (update f i a j)) = { x | x i ∈ t i a } ∩ pi {i}ᶜ fun j => t j (f j) := by\n  rw [compl_eq_univ_diff, ← pi_update_of_mem (mem_univ _)]\n\n"}
{"name":"Set.univ_pi_update_univ","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : DecidableEq ι\ni : ι\ns : Set (α i)\n⊢ Eq (Set.univ.pi (Function.update (fun j => Set.univ) i s)) (Set.preimage (Function.eval i) s)","decl":"theorem univ_pi_update_univ [DecidableEq ι] (i : ι) (s : Set (α i)) :\n    pi univ (update (fun j : ι => (univ : Set (α j))) i s) = eval i ⁻¹' s := by\n  rw [univ_pi_update i (fun j => (univ : Set (α j))) s fun j t => t, pi_univ, inter_univ, preimage]\n\n"}
{"name":"Set.eval_image_pi_subset","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Set ι\nt : (i : ι) → Set (α i)\ni : ι\nhs : Membership.mem s i\n⊢ HasSubset.Subset (Set.image (Function.eval i) (s.pi t)) (t i)","decl":"theorem eval_image_pi_subset (hs : i ∈ s) : eval i '' s.pi t ⊆ t i :=\n  image_subset_iff.2 fun _ hf => hf i hs\n\n"}
{"name":"Set.eval_image_univ_pi_subset","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nt : (i : ι) → Set (α i)\ni : ι\n⊢ HasSubset.Subset (Set.image (Function.eval i) (Set.univ.pi t)) (t i)","decl":"theorem eval_image_univ_pi_subset : eval i '' pi univ t ⊆ t i :=\n  eval_image_pi_subset (mem_univ i)\n\n"}
{"name":"Set.subset_eval_image_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Set ι\nt : (i : ι) → Set (α i)\nht : (s.pi t).Nonempty\ni : ι\n⊢ HasSubset.Subset (t i) (Set.image (Function.eval i) (s.pi t))","decl":"theorem subset_eval_image_pi (ht : (s.pi t).Nonempty) (i : ι) : t i ⊆ eval i '' s.pi t := by\n  classical\n  obtain ⟨f, hf⟩ := ht\n  refine fun y hy => ⟨update f i y, fun j hj => ?_, update_self ..⟩\n  obtain rfl | hji := eq_or_ne j i <;> simp [*, hf _ hj]\n\n"}
{"name":"Set.eval_image_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Set ι\nt : (i : ι) → Set (α i)\ni : ι\nhs : Membership.mem s i\nht : (s.pi t).Nonempty\n⊢ Eq (Set.image (Function.eval i) (s.pi t)) (t i)","decl":"theorem eval_image_pi (hs : i ∈ s) (ht : (s.pi t).Nonempty) : eval i '' s.pi t = t i :=\n  (eval_image_pi_subset hs).antisymm (subset_eval_image_pi ht i)\n\n"}
{"name":"Set.eval_image_pi_of_not_mem","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Set ι\nt : (i : ι) → Set (α i)\ni : ι\ninst✝ : Decidable (s.pi t).Nonempty\nhi : Not (Membership.mem s i)\n⊢ Eq (Set.image (Function.eval i) (s.pi t)) (ite (s.pi t).Nonempty Set.univ EmptyCollection.emptyCollection)","decl":"lemma eval_image_pi_of_not_mem [Decidable (s.pi t).Nonempty] (hi : i ∉ s) :\n    eval i '' s.pi t = if (s.pi t).Nonempty then univ else ∅ := by\n  classical\n  ext xᵢ\n  simp only [eval, mem_image, mem_pi, Set.Nonempty, mem_ite_empty_right, mem_univ, and_true]\n  constructor\n  · rintro ⟨x, hx, rfl⟩\n    exact ⟨x, hx⟩\n  · rintro ⟨x, hx⟩\n    refine ⟨Function.update x i xᵢ, ?_⟩\n    simpa (config := { contextual := true }) [(ne_of_mem_of_not_mem · hi)]\n\n"}
{"name":"Set.eval_image_univ_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nt : (i : ι) → Set (α i)\ni : ι\nht : (Set.univ.pi t).Nonempty\n⊢ Eq (Set.image (fun f => f i) (Set.univ.pi t)) (t i)","decl":"@[simp]\ntheorem eval_image_univ_pi (ht : (pi univ t).Nonempty) :\n    (fun f : ∀ i, α i => f i) '' pi univ t = t i :=\n  eval_image_pi (mem_univ i) ht\n\n"}
{"name":"Set.piMap_image_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : ι → Type u_3\ns : Set ι\nf : (i : ι) → α i → β i\nhf : ∀ (i : ι), Not (Membership.mem s i) → Function.Surjective (f i)\nt : (i : ι) → Set (α i)\n⊢ Eq (Set.image (Pi.map f) (s.pi t)) (s.pi fun i => Set.image (f i) (t i))","decl":"theorem piMap_image_pi {f : ∀ i, α i → β i} (hf : ∀ i ∉ s, Surjective (f i)) (t : ∀ i, Set (α i)) :\n    Pi.map f '' s.pi t = s.pi fun i ↦ f i '' t i := by\n  refine Subset.antisymm (image_subset_iff.2 fun a ha i hi ↦ mem_image_of_mem _ (ha _ hi)) ?_\n  intro b hb\n  have : ∀ i, ∃ a, f i a = b i ∧ (i ∈ s → a ∈ t i) := by\n    intro i\n    if hi : i ∈ s then\n      exact (hb i hi).imp fun a ⟨hat, hab⟩ ↦ ⟨hab, fun _ ↦ hat⟩\n    else\n      exact (hf i hi (b i)).imp fun a ha ↦ ⟨ha, (absurd · hi)⟩\n  choose a hab hat using this\n  exact ⟨a, hat, funext hab⟩\n\n"}
{"name":"Set.dcomp_image_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : ι → Type u_3\ns : Set ι\nf : (i : ι) → α i → β i\nhf : ∀ (i : ι), Not (Membership.mem s i) → Function.Surjective (f i)\nt : (i : ι) → Set (α i)\n⊢ Eq (Set.image (Pi.map f) (s.pi t)) (s.pi fun i => Set.image (f i) (t i))","decl":"@[deprecated (since := \"2024-10-06\")] alias dcomp_image_pi := piMap_image_pi\n\n"}
{"name":"Set.piMap_image_univ_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : ι → Type u_3\nf : (i : ι) → α i → β i\nt : (i : ι) → Set (α i)\n⊢ Eq (Set.image (Pi.map f) (Set.univ.pi t)) (Set.univ.pi fun i => Set.image (f i) (t i))","decl":"theorem piMap_image_univ_pi (f : ∀ i, α i → β i) (t : ∀ i, Set (α i)) :\n    Pi.map f '' univ.pi t = univ.pi fun i ↦ f i '' t i :=\n  piMap_image_pi (by simp) t\n\n"}
{"name":"Set.dcomp_image_univ_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : ι → Type u_3\nf : (i : ι) → α i → β i\nt : (i : ι) → Set (α i)\n⊢ Eq (Set.image (Pi.map f) (Set.univ.pi t)) (Set.univ.pi fun i => Set.image (f i) (t i))","decl":"@[deprecated (since := \"2024-10-06\")] alias dcomp_image_univ_pi := piMap_image_univ_pi\n\n"}
{"name":"Set.range_piMap","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : ι → Type u_3\nf : (i : ι) → α i → β i\n⊢ Eq (Set.range (Pi.map f)) (Set.univ.pi fun i => Set.range (f i))","decl":"@[simp]\ntheorem range_piMap (f : ∀ i, α i → β i) : range (Pi.map f) = pi univ fun i ↦ range (f i) := by\n  simp only [← image_univ, ← piMap_image_univ_pi, pi_univ]\n\n"}
{"name":"Set.range_dcomp","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nβ : ι → Type u_3\nf : (i : ι) → α i → β i\n⊢ Eq (Set.range (Pi.map f)) (Set.univ.pi fun i => Set.range (f i))","decl":"@[deprecated (since := \"2024-10-06\")] alias range_dcomp := range_piMap\n\n"}
{"name":"Set.pi_subset_pi_iff","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Set ι\nt₁ t₂ : (i : ι) → Set (α i)\n⊢ Iff (HasSubset.Subset (s.pi t₁) (s.pi t₂)) (Or (∀ (i : ι), Membership.mem s i → HasSubset.Subset (t₁ i) (t₂ i)) (Eq (s.pi t₁) EmptyCollection.emptyCollection))","decl":"theorem pi_subset_pi_iff : pi s t₁ ⊆ pi s t₂ ↔ (∀ i ∈ s, t₁ i ⊆ t₂ i) ∨ pi s t₁ = ∅ := by\n  refine\n    ⟨fun h => or_iff_not_imp_right.2 ?_, fun h => h.elim pi_mono fun h' => h'.symm ▸ empty_subset _⟩\n  rw [← Ne, ← nonempty_iff_ne_empty]\n  intro hne i hi\n  simpa only [eval_image_pi hi hne, eval_image_pi hi (hne.mono h)] using\n    image_subset (fun f : ∀ i, α i => f i) h\n\n"}
{"name":"Set.univ_pi_subset_univ_pi_iff","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nt₁ t₂ : (i : ι) → Set (α i)\n⊢ Iff (HasSubset.Subset (Set.univ.pi t₁) (Set.univ.pi t₂)) (Or (∀ (i : ι), HasSubset.Subset (t₁ i) (t₂ i)) (Exists fun i => Eq (t₁ i) EmptyCollection.emptyCollection))","decl":"theorem univ_pi_subset_univ_pi_iff :\n    pi univ t₁ ⊆ pi univ t₂ ↔ (∀ i, t₁ i ⊆ t₂ i) ∨ ∃ i, t₁ i = ∅ := by simp [pi_subset_pi_iff]\n\n"}
{"name":"Set.eval_preimage","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ni : ι\ninst✝ : DecidableEq ι\ns : Set (α i)\n⊢ Eq (Set.preimage (Function.eval i) s) (Set.univ.pi (Function.update (fun x => Set.univ) i s))","decl":"theorem eval_preimage [DecidableEq ι] {s : Set (α i)} :\n    eval i ⁻¹' s = pi univ (update (fun _ => univ) i s) := by\n  ext x\n  simp [@forall_update_iff _ (fun i => Set (α i)) _ _ _ _ fun i' y => x i' ∈ y]\n\n"}
{"name":"Set.eval_preimage'","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ni : ι\ninst✝ : DecidableEq ι\ns : Set (α i)\n⊢ Eq (Set.preimage (Function.eval i) s) ((Singleton.singleton i).pi (Function.update (fun x => Set.univ) i s))","decl":"theorem eval_preimage' [DecidableEq ι] {s : Set (α i)} :\n    eval i ⁻¹' s = pi {i} (update (fun _ => univ) i s) := by\n  ext\n  simp\n\n"}
{"name":"Set.update_preimage_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Set ι\nt : (i : ι) → Set (α i)\ni : ι\ninst✝ : DecidableEq ι\nf : (i : ι) → α i\nhi : Membership.mem s i\nhf : ∀ (j : ι), Membership.mem s j → Ne j i → Membership.mem (t j) (f j)\n⊢ Eq (Set.preimage (Function.update f i) (s.pi t)) (t i)","decl":"theorem update_preimage_pi [DecidableEq ι] {f : ∀ i, α i} (hi : i ∈ s)\n    (hf : ∀ j ∈ s, j ≠ i → f j ∈ t j) : update f i ⁻¹' s.pi t = t i := by\n  ext x\n  refine ⟨fun h => ?_, fun hx j hj => ?_⟩\n  · convert h i hi\n    simp\n  · obtain rfl | h := eq_or_ne j i\n    · simpa\n    · rw [update_of_ne h]\n      exact hf j hj h\n\n"}
{"name":"Set.update_image","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nβ : ι → Type u_3\ninst✝ : DecidableEq ι\nx : (i : ι) → β i\ni : ι\ns : Set (β i)\n⊢ Eq (Set.image (Function.update x i) s) (Set.univ.pi (Function.update (fun j => Singleton.singleton (x j)) i s))","decl":"theorem update_image [DecidableEq ι] (x : (i : ι) → β i) (i : ι) (s : Set (β i)) :\n    update x i '' s = Set.univ.pi (update (fun j ↦ {x j}) i s) := by\n  ext y\n  simp only [mem_image, update_eq_iff, ne_eq, and_left_comm (a := _ ∈ s), exists_eq_left, mem_pi,\n    mem_univ, true_implies]\n  rw [forall_update_iff (p := fun x s => y x ∈ s)]\n  simp [eq_comm]\n\n"}
{"name":"Set.update_preimage_univ_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nt : (i : ι) → Set (α i)\ni : ι\ninst✝ : DecidableEq ι\nf : (i : ι) → α i\nhf : ∀ (j : ι), Ne j i → Membership.mem (t j) (f j)\n⊢ Eq (Set.preimage (Function.update f i) (Set.univ.pi t)) (t i)","decl":"theorem update_preimage_univ_pi [DecidableEq ι] {f : ∀ i, α i} (hf : ∀ j ≠ i, f j ∈ t j) :\n    update f i ⁻¹' pi univ t = t i :=\n  update_preimage_pi (mem_univ i) fun j _ => hf j\n\n"}
{"name":"Set.subset_pi_eval_image","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Set ι\nu : Set ((i : ι) → α i)\n⊢ HasSubset.Subset u (s.pi fun i => Set.image (Function.eval i) u)","decl":"theorem subset_pi_eval_image (s : Set ι) (u : Set (∀ i, α i)) : u ⊆ pi s fun i => eval i '' u :=\n  fun f hf _ _ => ⟨f, hf, rfl⟩\n\n"}
{"name":"Set.univ_pi_ite","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Set ι\ninst✝ : DecidablePred fun x => Membership.mem s x\nt : (i : ι) → Set (α i)\n⊢ Eq (Set.univ.pi fun i => ite (Membership.mem s i) (t i) Set.univ) (s.pi t)","decl":"theorem univ_pi_ite (s : Set ι) [DecidablePred (· ∈ s)] (t : ∀ i, Set (α i)) :\n    (pi univ fun i => if i ∈ s then t i else univ) = s.pi t := by\n  ext\n  simp_rw [mem_univ_pi]\n  refine forall_congr' fun i => ?_\n  split_ifs with h <;> simp [h]\n\n"}
{"name":"Equiv.piCongrLeft_symm_preimage_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : ι → Type u_3\nf : Equiv ι' ι\ns : Set ι'\nt : (i : ι) → Set (α i)\n⊢ Eq (Set.preimage (⇑(Equiv.piCongrLeft α f).symm) (s.pi fun i' => t (f i'))) ((Set.image (⇑f) s).pi t)","decl":"theorem piCongrLeft_symm_preimage_pi (f : ι' ≃ ι) (s : Set ι') (t : ∀ i, Set (α i)) :\n    (f.piCongrLeft α).symm ⁻¹' s.pi (fun i' => t <| f i') = (f '' s).pi t := by\n  ext; simp\n\n"}
{"name":"Equiv.piCongrLeft_symm_preimage_univ_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : ι → Type u_3\nf : Equiv ι' ι\nt : (i : ι) → Set (α i)\n⊢ Eq (Set.preimage (⇑(Equiv.piCongrLeft α f).symm) (Set.univ.pi fun i' => t (f i'))) (Set.univ.pi t)","decl":"theorem piCongrLeft_symm_preimage_univ_pi (f : ι' ≃ ι) (t : ∀ i, Set (α i)) :\n    (f.piCongrLeft α).symm ⁻¹' univ.pi (fun i' => t <| f i') = univ.pi t := by\n  simpa [f.surjective.range_eq] using piCongrLeft_symm_preimage_pi f univ t\n\n"}
{"name":"Equiv.piCongrLeft_preimage_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : ι → Type u_3\nf : Equiv ι' ι\ns : Set ι'\nt : (i : ι) → Set (α i)\n⊢ Eq (Set.preimage (⇑(Equiv.piCongrLeft α f)) ((Set.image (⇑f) s).pi t)) (s.pi fun i => t (f i))","decl":"theorem piCongrLeft_preimage_pi (f : ι' ≃ ι) (s : Set ι') (t : ∀ i, Set (α i)) :\n    f.piCongrLeft α ⁻¹' (f '' s).pi t = s.pi fun i => t (f i) := by\n  apply Set.ext\n  rw [← (f.piCongrLeft α).symm.forall_congr_right]\n  simp\n\n"}
{"name":"Equiv.piCongrLeft_preimage_univ_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : ι → Type u_3\nf : Equiv ι' ι\nt : (i : ι) → Set (α i)\n⊢ Eq (Set.preimage (⇑(Equiv.piCongrLeft α f)) (Set.univ.pi t)) (Set.univ.pi fun i => t (f i))","decl":"theorem piCongrLeft_preimage_univ_pi (f : ι' ≃ ι) (t : ∀ i, Set (α i)) :\n    f.piCongrLeft α ⁻¹' univ.pi t = univ.pi fun i => t (f i) := by\n  simpa [f.surjective.range_eq] using piCongrLeft_preimage_pi f univ t\n\n"}
{"name":"Equiv.sumPiEquivProdPi_symm_preimage_univ_pi","module":"Mathlib.Data.Set.Prod","initialProofState":"ι : Type u_1\nι' : Type u_2\nπ : Sum ι ι' → Type u_4\nt : (i : Sum ι ι') → Set (π i)\n⊢ Eq (Set.preimage (⇑(Equiv.sumPiEquivProdPi π).symm) (Set.univ.pi t)) (SProd.sprod (Set.univ.pi fun i => t (Sum.inl i)) (Set.univ.pi fun i => t (Sum.inr i)))","decl":"theorem sumPiEquivProdPi_symm_preimage_univ_pi (π : ι ⊕ ι' → Type*) (t : ∀ i, Set (π i)) :\n    (sumPiEquivProdPi π).symm ⁻¹' univ.pi t =\n    univ.pi (fun i => t (.inl i)) ×ˢ univ.pi fun i => t (.inr i) := by\n  ext\n  simp_rw [mem_preimage, mem_prod, mem_univ_pi, sumPiEquivProdPi_symm_apply]\n  constructor\n  · intro h; constructor <;> intro i <;> apply h\n  · rintro ⟨h₁, h₂⟩ (i|i) <;> simp <;> apply_assumption\n\n"}
