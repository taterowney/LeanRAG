{"name":"Submodule.span_coe_eq_restrictScalars","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\nS : Type u_7\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\np : Submodule R M\ninst✝³ : Semiring S\ninst✝² : SMul S R\ninst✝¹ : Module S M\ninst✝ : IsScalarTower S R M\n⊢ Eq (Submodule.span S ↑p) (Submodule.restrictScalars S p)","decl":"/-- A version of `Submodule.span_eq` for when the span is by a smaller ring. -/\n@[simp]\ntheorem span_coe_eq_restrictScalars [Semiring S] [SMul S R] [Module S M] [IsScalarTower S R M] :\n    span S (p : Set M) = p.restrictScalars S :=\n  span_eq (p.restrictScalars S)\n\n"}
{"name":"Submodule.image_span_subset","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : Semiring R₂\nσ₁₂ : RingHom R R₂\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R₂ M₂\nF : Type u_8\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\ns : Set M\nN : Submodule R₂ M₂\n⊢ Iff (HasSubset.Subset (Set.image ⇑f ↑(Submodule.span R s)) ↑N) (∀ (m : M), Membership.mem s m → Membership.mem N (f m))","decl":"include σ₁₂ in\n/-- A version of `Submodule.map_span_le` that does not require the `RingHomSurjective`\nassumption. -/\ntheorem image_span_subset (f : F) (s : Set M) (N : Submodule R₂ M₂) :\n    f '' span R s ⊆ N ↔ ∀ m ∈ s, f m ∈ N := image_subset_iff.trans <| span_le (p := N.comap f)\n\n"}
{"name":"Submodule.image_span_subset_span","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : Semiring R₂\nσ₁₂ : RingHom R R₂\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R₂ M₂\nF : Type u_8\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\ns : Set M\n⊢ HasSubset.Subset (Set.image ⇑f ↑(Submodule.span R s)) ↑(Submodule.span R₂ (Set.image (⇑f) s))","decl":"include σ₁₂ in\ntheorem image_span_subset_span (f : F) (s : Set M) : f '' span R s ⊆ span R₂ (f '' s) :=\n  (image_span_subset f s _).2 fun x hx ↦ subset_span ⟨x, hx, rfl⟩\n\n"}
{"name":"Submodule.map_span","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Semiring R₂\nσ₁₂ : RingHom R R₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R₂ M₂\nF : Type u_8\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\ns : Set M\n⊢ Eq (Submodule.map f (Submodule.span R s)) (Submodule.span R₂ (Set.image (⇑f) s))","decl":"theorem map_span [RingHomSurjective σ₁₂] (f : F) (s : Set M) :\n    (span R s).map f = span R₂ (f '' s) :=\n  Eq.symm <| span_eq_of_le _ (Set.image_subset f subset_span) (image_span_subset_span f s)\n\n"}
{"name":"LinearMap.map_span","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Semiring R₂\nσ₁₂ : RingHom R R₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R₂ M₂\nF : Type u_8\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\ns : Set M\n⊢ Eq (Submodule.map f (Submodule.span R s)) (Submodule.span R₂ (Set.image (⇑f) s))","decl":"alias _root_.LinearMap.map_span := Submodule.map_span\n\n"}
{"name":"Submodule.map_span_le","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Semiring R₂\nσ₁₂ : RingHom R R₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R₂ M₂\nF : Type u_8\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\ns : Set M\nN : Submodule R₂ M₂\n⊢ Iff (LE.le (Submodule.map f (Submodule.span R s)) N) (∀ (m : M), Membership.mem s m → Membership.mem N (f m))","decl":"theorem map_span_le [RingHomSurjective σ₁₂] (f : F) (s : Set M) (N : Submodule R₂ M₂) :\n    map f (span R s) ≤ N ↔ ∀ m ∈ s, f m ∈ N := image_span_subset f s N\n\n"}
{"name":"LinearMap.map_span_le","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Semiring R₂\nσ₁₂ : RingHom R R₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R₂ M₂\nF : Type u_8\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\ns : Set M\nN : Submodule R₂ M₂\n⊢ Iff (LE.le (Submodule.map f (Submodule.span R s)) N) (∀ (m : M), Membership.mem s m → Membership.mem N (f m))","decl":"alias _root_.LinearMap.map_span_le := Submodule.map_span_le\n\n-- See also `span_preimage_eq` below.\n"}
{"name":"Submodule.span_preimage_le","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : Semiring R₂\nσ₁₂ : RingHom R R₂\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R₂ M₂\nF : Type u_8\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\ns : Set M₂\n⊢ LE.le (Submodule.span R (Set.preimage (⇑f) s)) (Submodule.comap f (Submodule.span R₂ s))","decl":"theorem span_preimage_le (f : F) (s : Set M₂) :\n    span R (f ⁻¹' s) ≤ (span R₂ s).comap f := by\n  rw [span_le, comap_coe]\n  exact preimage_mono subset_span\n\n"}
{"name":"LinearMap.span_preimage_le","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : Semiring R₂\nσ₁₂ : RingHom R R₂\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R₂ M₂\nF : Type u_8\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\ns : Set M₂\n⊢ LE.le (Submodule.span R (Set.preimage (⇑f) s)) (Submodule.comap f (Submodule.span R₂ s))","decl":"alias _root_.LinearMap.span_preimage_le := Submodule.span_preimage_le\n\n"}
{"name":"Submodule.linearMap_eq_iff_of_eq_span","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_9\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nV : Submodule R M\nf g : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem V x) N\nS : Set M\nhV : Eq V (Submodule.span R S)\n⊢ Iff (Eq f g) (∀ (s : ↑S), Eq (f ⟨↑s, ⋯⟩) (g ⟨↑s, ⋯⟩))","decl":"lemma linearMap_eq_iff_of_eq_span {V : Submodule R M} (f g : V →ₗ[R] N)\n    {S : Set M} (hV : V = span R S) :\n    f = g ↔ ∀ (s : S), f ⟨s, by simpa only [hV] using subset_span (by simp)⟩ =\n      g ⟨s, by simpa only [hV] using subset_span (by simp)⟩ := by\n  constructor\n  · rintro rfl _\n    rfl\n  · intro h\n    subst hV\n    suffices ∀ (x : M) (hx : x ∈ span R S), f ⟨x, hx⟩ = g ⟨x, hx⟩ by\n      ext ⟨x, hx⟩\n      exact this x hx\n    intro x hx\n    induction hx using span_induction with\n    | mem x hx => exact h ⟨x, hx⟩\n    | zero => erw [map_zero, map_zero]\n    | add x y hx hy hx' hy' =>\n        erw [f.map_add ⟨x, hx⟩ ⟨y, hy⟩, g.map_add ⟨x, hx⟩ ⟨y, hy⟩]\n        rw [hx', hy']\n    | smul a x hx hx' =>\n        erw [f.map_smul a ⟨x, hx⟩, g.map_smul a ⟨x, hx⟩]\n        rw [hx']\n\n"}
{"name":"Submodule.linearMap_eq_iff_of_span_eq_top","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_9\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nf g : LinearMap (RingHom.id R) M N\nS : Set M\nhM : Eq (Submodule.span R S) Top.top\n⊢ Iff (Eq f g) (∀ (s : ↑S), Eq (f ↑s) (g ↑s))","decl":"lemma linearMap_eq_iff_of_span_eq_top (f g : M →ₗ[R] N)\n    {S : Set M} (hM : span R S = ⊤) :\n    f = g ↔ ∀ (s : S), f s = g s := by\n  convert linearMap_eq_iff_of_eq_span (f.comp (Submodule.subtype _))\n    (g.comp (Submodule.subtype _)) hM.symm\n  constructor\n  · rintro rfl\n    rfl\n  · intro h\n    ext x\n    exact DFunLike.congr_fun h ⟨x, by simp⟩\n\n"}
{"name":"Submodule.linearMap_eq_zero_iff_of_span_eq_top","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_9\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\nS : Set M\nhM : Eq (Submodule.span R S) Top.top\n⊢ Iff (Eq f 0) (∀ (s : ↑S), Eq (f ↑s) 0)","decl":"lemma linearMap_eq_zero_iff_of_span_eq_top (f : M →ₗ[R] N)\n    {S : Set M} (hM : span R S = ⊤) :\n    f = 0 ↔ ∀ (s : S), f s = 0 :=\n  linearMap_eq_iff_of_span_eq_top f 0 hM\n\n"}
{"name":"Submodule.linearMap_eq_zero_iff_of_eq_span","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_9\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nV : Submodule R M\nf : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem V x) N\nS : Set M\nhV : Eq V (Submodule.span R S)\n⊢ Iff (Eq f 0) (∀ (s : ↑S), Eq (f ⟨↑s, ⋯⟩) 0)","decl":"lemma linearMap_eq_zero_iff_of_eq_span {V : Submodule R M} (f : V →ₗ[R] N)\n    {S : Set M} (hV : V = span R S) :\n    f = 0 ↔ ∀ (s : S), f ⟨s, by simpa only [hV] using subset_span (by simp)⟩ = 0 :=\n  linearMap_eq_iff_of_eq_span f 0 hV\n\n"}
{"name":"Submodule.span_smul_eq_of_isUnit","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\nr : R\nhr : IsUnit r\n⊢ Eq (Submodule.span R (HSMul.hSMul r s)) (Submodule.span R s)","decl":"/-- See `Submodule.span_smul_eq` (in `RingTheory.Ideal.Operations`) for\n`span R (r • s) = r • span R s` that holds for arbitrary `r` in a `CommSemiring`. -/\ntheorem span_smul_eq_of_isUnit (s : Set M) (r : R) (hr : IsUnit r) : span R (r • s) = span R s := by\n  apply le_antisymm\n  · apply span_smul_le\n  · convert span_smul_le (r • s) ((hr.unit⁻¹ :) : R)\n    simp [smul_smul]\n\n"}
{"name":"Submodule.coe_scott_continuous","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ OmegaCompletePartialOrder.ωScottContinuous SetLike.coe","decl":"/-- We can regard `coe_iSup_of_chain` as the statement that `(↑) : (Submodule R M) → Set M` is\nScott continuous for the ω-complete partial order induced by the complete lattice structures. -/\ntheorem coe_scott_continuous :\n    OmegaCompletePartialOrder.ωScottContinuous ((↑) : Submodule R M → Set M) :=\n  OmegaCompletePartialOrder.ωScottContinuous.of_monotone_map_ωSup\n    ⟨SetLike.coe_mono, coe_iSup_of_chain⟩\n\n"}
{"name":"Submodule.inclusionSpan_apply_coe","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\nS : Type u_7\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Semiring S\ninst✝² : SMul R S\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\np : Submodule R M\nx : Subtype fun x => Membership.mem p x\n⊢ Eq ↑((Submodule.inclusionSpan S p) x) ↑x","decl":"/-- The inclusion of an `R`-submodule into its `S`-span, as an `R`-linear map. -/\n@[simps] def inclusionSpan :\n    p →ₗ[R] span S (p : Set M) where\n  toFun x := ⟨x, subset_span x.property⟩\n  map_add' x y := by simp\n  map_smul' t x := by simp\n\n"}
{"name":"Submodule.injective_inclusionSpan","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\nS : Type u_7\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Semiring S\ninst✝² : SMul R S\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\np : Submodule R M\n⊢ Function.Injective ⇑(Submodule.inclusionSpan S p)","decl":"lemma injective_inclusionSpan :\n    Injective (p.inclusionSpan S) := by\n  intro x y hxy\n  rw [Subtype.ext_iff] at hxy\n  simpa using hxy\n\n"}
{"name":"Submodule.span_range_inclusionSpan","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\nS : Type u_7\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Semiring S\ninst✝² : SMul R S\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\np : Submodule R M\n⊢ Eq (Submodule.span S (Set.range ⇑(Submodule.inclusionSpan S p))) Top.top","decl":"lemma span_range_inclusionSpan :\n    span S (range <| p.inclusionSpan S) = ⊤ := by\n  have : (span S (p : Set M)).subtype '' range (inclusionSpan S p) = p := by\n    ext; simpa [Subtype.ext_iff] using fun h ↦ subset_span h\n  apply map_injective_of_injective (span S (p : Set M)).injective_subtype\n  rw [map_subtype_top, map_span, this]\n\n"}
{"name":"Submodule.span_le_restrictScalars","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\nS : Type u_7\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ns : Set M\ninst✝³ : Semiring S\ninst✝² : SMul R S\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\n⊢ LE.le (Submodule.span R s) (Submodule.restrictScalars R (Submodule.span S s))","decl":"/-- If `R` is \"smaller\" ring than `S` then the span by `R` is smaller than the span by `S`. -/\ntheorem span_le_restrictScalars :\n    span R s ≤ (span S s).restrictScalars R :=\n  Submodule.span_le.2 Submodule.subset_span\n\n"}
{"name":"Submodule.span_subset_span","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\nS : Type u_7\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ns : Set M\ninst✝³ : Semiring S\ninst✝² : SMul R S\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\n⊢ HasSubset.Subset ↑(Submodule.span R s) ↑(Submodule.span S s)","decl":"/-- A version of `Submodule.span_le_restrictScalars` with coercions. -/\n@[simp]\ntheorem span_subset_span :\n    ↑(span R s) ⊆ (span S s : Set M) :=\n  span_le_restrictScalars R S s\n\n"}
{"name":"Submodule.span_span_of_tower","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\nS : Type u_7\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ns : Set M\ninst✝³ : Semiring S\ninst✝² : SMul R S\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\n⊢ Eq (Submodule.span S ↑(Submodule.span R s)) (Submodule.span S s)","decl":"/-- Taking the span by a large ring of the span by the small ring is the same as taking the span\nby just the large ring. -/\n@[simp]\ntheorem span_span_of_tower :\n    span S (span R s : Set M) = span S s :=\n  le_antisymm (span_le.2 <| span_subset_span R S s) (span_mono subset_span)\n\n"}
{"name":"Submodule.span_eq_top_of_span_eq_top","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\nS : Type u_7\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Semiring S\ninst✝² : SMul R S\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\ns : Set M\nhs : Eq (Submodule.span R s) Top.top\n⊢ Eq (Submodule.span S s) Top.top","decl":"theorem span_eq_top_of_span_eq_top (s : Set M) (hs : span R s = ⊤) : span S s = ⊤ :=\n  le_top.antisymm (hs.ge.trans (span_le_restrictScalars R S s))\n\n"}
{"name":"Submodule.span_range_inclusion_eq_top","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\nS : Type u_7\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Semiring S\ninst✝² : SMul R S\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\np : Submodule R M\nq : Submodule S M\nh₁ : LE.le p (Submodule.restrictScalars R q)\nh₂ : LE.le q (Submodule.span S ↑p)\n⊢ Eq (Submodule.span S (Set.range ⇑(Submodule.inclusion h₁))) Top.top","decl":"variable {R S} in\nlemma span_range_inclusion_eq_top (p : Submodule R M) (q : Submodule S M)\n    (h₁ : p ≤ q.restrictScalars R) (h₂ : q ≤ span S p) :\n    span S (range (inclusion h₁)) = ⊤ := by\n  suffices (span S (range (inclusion h₁))).map q.subtype = q by\n    apply map_injective_of_injective q.injective_subtype\n    rw [this, q.map_subtype_top]\n  rw [map_span]\n  suffices q.subtype '' ((LinearMap.range (inclusion h₁)) : Set <| q.restrictScalars R) = p by\n    refine this ▸ le_antisymm ?_ h₂\n    simpa using span_mono (R := S) h₁\n  ext x\n  simpa [range_inclusion] using fun hx ↦ h₁ hx\n\n"}
{"name":"Submodule.span_range_inclusion_restrictScalars_eq_top","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\nS : Type u_7\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ns : Set M\ninst✝³ : Semiring S\ninst✝² : SMul R S\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\n⊢ Eq (Submodule.span S (Set.range ⇑(Submodule.inclusion ⋯))) Top.top","decl":"@[simp]\ntheorem span_range_inclusion_restrictScalars_eq_top :\n    span S (range (inclusion <| span_le_restrictScalars R S s)) = ⊤ :=\n  span_range_inclusion_eq_top _ _ _ <| by simp\n\n"}
{"name":"Submodule.span_singleton_eq_span_singleton","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_9\nM : Type u_10\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nx y : M\n⊢ Iff (Eq (Submodule.span R (Singleton.singleton x)) (Submodule.span R (Singleton.singleton y))) (Exists fun z => Eq (HSMul.hSMul z x) y)","decl":"theorem span_singleton_eq_span_singleton {R M : Type*} [Ring R] [AddCommGroup M] [Module R M]\n    [NoZeroSMulDivisors R M] {x y : M} : ((R ∙ x) = R ∙ y) ↔ ∃ z : Rˣ, z • x = y := by\n  constructor\n  · simp only [le_antisymm_iff, span_singleton_le_iff_mem, mem_span_singleton]\n    rintro ⟨⟨a, rfl⟩, b, hb⟩\n    rcases eq_or_ne y 0 with rfl | hy; · simp\n    refine ⟨⟨b, a, ?_, ?_⟩, hb⟩\n    · apply smul_left_injective R hy\n      simpa only [mul_smul, one_smul]\n    · rw [← hb] at hy\n      apply smul_left_injective R (smul_ne_zero_iff.1 hy).2\n      simp only [mul_smul, one_smul, hb]\n  · rintro ⟨u, rfl⟩\n    exact (span_singleton_group_smul_eq _ _ _).symm\n\n-- Should be `@[simp]` but doesn't fire due to https://github.com/leanprover/lean4/pull/3701.\n"}
{"name":"Submodule.span_image","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Semiring R₂\nσ₁₂ : RingHom R R₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R₂ M₂\nF : Type u_8\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ns : Set M\ninst✝ : RingHomSurjective σ₁₂\nf : F\n⊢ Eq (Submodule.span R₂ (Set.image (⇑f) s)) (Submodule.map f (Submodule.span R s))","decl":"theorem span_image [RingHomSurjective σ₁₂] (f : F) :\n    span R₂ (f '' s) = map f (span R s) :=\n  (map_span f s).symm\n\n"}
{"name":"Submodule.span_image'","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Semiring R₂\nσ₁₂ : RingHom R R₂\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R₂ M₂\ns : Set M\ninst✝ : RingHomSurjective σ₁₂\nf : LinearMap σ₁₂ M M₂\n⊢ Eq (Submodule.span R₂ (Set.image (⇑f) s)) (Submodule.map f (Submodule.span R s))","decl":"@[simp] -- Should be replaced with `Submodule.span_image` when https://github.com/leanprover/lean4/pull/3701 is fixed.\ntheorem span_image' [RingHomSurjective σ₁₂] (f : M →ₛₗ[σ₁₂] M₂) :\n    span R₂ (f '' s) = map f (span R s) :=\n  span_image _\n\n"}
{"name":"Submodule.apply_mem_span_image_of_mem_span","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Semiring R₂\nσ₁₂ : RingHom R R₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R₂ M₂\nF : Type u_8\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nx : M\ns : Set M\nh : Membership.mem (Submodule.span R s) x\n⊢ Membership.mem (Submodule.span R₂ (Set.image (⇑f) s)) (f x)","decl":"theorem apply_mem_span_image_of_mem_span [RingHomSurjective σ₁₂] (f : F) {x : M}\n    {s : Set M} (h : x ∈ Submodule.span R s) : f x ∈ Submodule.span R₂ (f '' s) := by\n  rw [Submodule.span_image]\n  exact Submodule.mem_map_of_mem h\n\n"}
{"name":"Submodule.apply_mem_span_image_iff_mem_span","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Semiring R₂\nσ₁₂ : RingHom R R₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R₂ M₂\nF : Type u_8\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nx : M\ns : Set M\nhf : Function.Injective ⇑f\n⊢ Iff (Membership.mem (Submodule.span R₂ (Set.image (⇑f) s)) (f x)) (Membership.mem (Submodule.span R s) x)","decl":"theorem apply_mem_span_image_iff_mem_span [RingHomSurjective σ₁₂] {f : F} {x : M}\n    {s : Set M} (hf : Function.Injective f) :\n    f x ∈ Submodule.span R₂ (f '' s) ↔ x ∈ Submodule.span R s := by\n  rw [← Submodule.mem_comap, ← Submodule.map_span, Submodule.comap_map_eq_of_injective hf]\n\n"}
{"name":"Submodule.map_subtype_span_singleton","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\nx : Subtype fun x => Membership.mem p x\n⊢ Eq (Submodule.map p.subtype (Submodule.span R (Singleton.singleton x))) (Submodule.span R (Singleton.singleton ↑x))","decl":"@[simp]\ntheorem map_subtype_span_singleton {p : Submodule R M} (x : p) :\n    map p.subtype (R ∙ x) = R ∙ (x : M) := by simp [← span_image]\n\n"}
{"name":"Submodule.not_mem_span_of_apply_not_mem_span_image","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Semiring R₂\nσ₁₂ : RingHom R R₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R₂ M₂\nF : Type u_8\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nx : M\ns : Set M\nh : Not (Membership.mem (Submodule.span R₂ (Set.image (⇑f) s)) (f x))\n⊢ Not (Membership.mem (Submodule.span R s) x)","decl":"/-- `f` is an explicit argument so we can `apply` this theorem and obtain `h` as a new goal. -/\ntheorem not_mem_span_of_apply_not_mem_span_image [RingHomSurjective σ₁₂] (f : F) {x : M}\n    {s : Set M} (h : f x ∉ Submodule.span R₂ (f '' s)) : x ∉ Submodule.span R s :=\n  h.imp (apply_mem_span_image_of_mem_span f)\n\n"}
{"name":"Submodule.iSup_toAddSubmonoid","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Sort u_9\np : ι → Submodule R M\n⊢ Eq (iSup fun i => p i).toAddSubmonoid (iSup fun i => (p i).toAddSubmonoid)","decl":"theorem iSup_toAddSubmonoid {ι : Sort*} (p : ι → Submodule R M) :\n    (⨆ i, p i).toAddSubmonoid = ⨆ i, (p i).toAddSubmonoid := by\n  refine le_antisymm (fun x => ?_) (iSup_le fun i => toAddSubmonoid_mono <| le_iSup _ i)\n  simp_rw [iSup_eq_span, AddSubmonoid.iSup_eq_closure, mem_toAddSubmonoid, coe_toAddSubmonoid]\n  intro hx\n  refine Submodule.span_induction (fun x hx => ?_) ?_ (fun x y _ _ hx hy => ?_)\n    (fun r x _ hx => ?_) hx\n  · exact AddSubmonoid.subset_closure hx\n  · exact AddSubmonoid.zero_mem _\n  · exact AddSubmonoid.add_mem _ hx hy\n  · refine AddSubmonoid.closure_induction ?_ ?_ ?_ hx\n    · rintro x ⟨_, ⟨i, rfl⟩, hix : x ∈ p i⟩\n      apply AddSubmonoid.subset_closure (Set.mem_iUnion.mpr ⟨i, _⟩)\n      exact smul_mem _ r hix\n    · rw [smul_zero]\n      exact AddSubmonoid.zero_mem _\n    · intro x y _ _ hx hy\n      rw [smul_add]\n      exact AddSubmonoid.add_mem _ hx hy\n\n"}
{"name":"Submodule.iSup_induction","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Sort u_9\np : ι → Submodule R M\nC : M → Prop\nx : M\nhx : Membership.mem (iSup fun i => p i) x\nhp : ∀ (i : ι) (x : M), Membership.mem (p i) x → C x\nh0 : C 0\nhadd : ∀ (x y : M), C x → C y → C (HAdd.hAdd x y)\n⊢ C x","decl":"/-- An induction principle for elements of `⨆ i, p i`.\nIf `C` holds for `0` and all elements of `p i` for all `i`, and is preserved under addition,\nthen it holds for all elements of the supremum of `p`. -/\n@[elab_as_elim]\ntheorem iSup_induction {ι : Sort*} (p : ι → Submodule R M) {C : M → Prop} {x : M}\n    (hx : x ∈ ⨆ i, p i) (hp : ∀ (i), ∀ x ∈ p i, C x) (h0 : C 0)\n    (hadd : ∀ x y, C x → C y → C (x + y)) : C x := by\n  rw [← mem_toAddSubmonoid, iSup_toAddSubmonoid] at hx\n  exact AddSubmonoid.iSup_induction (x := x) _ hx hp h0 hadd\n\n"}
{"name":"Submodule.iSup_induction'","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Sort u_9\np : ι → Submodule R M\nC : (x : M) → Membership.mem (iSup fun i => p i) x → Prop\nmem : ∀ (i : ι) (x : M) (hx : Membership.mem (p i) x), C x ⋯\nzero : C 0 ⋯\nadd : ∀ (x y : M) (hx : Membership.mem (iSup fun i => p i) x) (hy : Membership.mem (iSup fun i => p i) y), C x hx → C y hy → C (HAdd.hAdd x y) ⋯\nx : M\nhx : Membership.mem (iSup fun i => p i) x\n⊢ C x hx","decl":"/-- A dependent version of `submodule.iSup_induction`. -/\n@[elab_as_elim]\ntheorem iSup_induction' {ι : Sort*} (p : ι → Submodule R M) {C : ∀ x, (x ∈ ⨆ i, p i) → Prop}\n    (mem : ∀ (i) (x) (hx : x ∈ p i), C x (mem_iSup_of_mem i hx)) (zero : C 0 (zero_mem _))\n    (add : ∀ x y hx hy, C x hx → C y hy → C (x + y) (add_mem ‹_› ‹_›)) {x : M}\n    (hx : x ∈ ⨆ i, p i) : C x hx := by\n  refine Exists.elim ?_ fun (hx : x ∈ ⨆ i, p i) (hc : C x hx) => hc\n  refine iSup_induction p (C := fun x : M ↦ ∃ (hx : x ∈ ⨆ i, p i), C x hx) hx\n    (fun i x hx => ?_) ?_ fun x y => ?_\n  · exact ⟨_, mem _ _ hx⟩\n  · exact ⟨_, zero⟩\n  · rintro ⟨_, Cx⟩ ⟨_, Cy⟩\n    exact ⟨_, add _ _ _ _ Cx Cy⟩\n\n"}
{"name":"Submodule.singleton_span_isCompactElement","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ CompleteLattice.IsCompactElement (Submodule.span R (Singleton.singleton x))","decl":"theorem singleton_span_isCompactElement (x : M) :\n    CompleteLattice.IsCompactElement (span R {x} : Submodule R M) := by\n  rw [CompleteLattice.isCompactElement_iff_le_of_directed_sSup_le]\n  intro d hemp hdir hsup\n  have : x ∈ (sSup d) := (SetLike.le_def.mp hsup) (mem_span_singleton_self x)\n  obtain ⟨y, ⟨hyd, hxy⟩⟩ := (mem_sSup_of_directed hemp hdir).mp this\n  exact ⟨y, ⟨hyd, by simpa only [span_le, singleton_subset_iff] ⟩⟩\n\n"}
{"name":"Submodule.finset_span_isCompactElement","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nS : Finset M\n⊢ CompleteLattice.IsCompactElement (Submodule.span R ↑S)","decl":"/-- The span of a finite subset is compact in the lattice of submodules. -/\ntheorem finset_span_isCompactElement (S : Finset M) :\n    CompleteLattice.IsCompactElement (span R S : Submodule R M) := by\n  rw [span_eq_iSup_of_singleton_spans]\n  simp only [Finset.mem_coe]\n  rw [← Finset.sup_eq_iSup]\n  exact\n    CompleteLattice.isCompactElement_finsetSup S fun x _ => singleton_span_isCompactElement x\n\n"}
{"name":"Submodule.finite_span_isCompactElement","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nS : Set M\nh : S.Finite\n⊢ CompleteLattice.IsCompactElement (Submodule.span R S)","decl":"/-- The span of a finite subset is compact in the lattice of submodules. -/\ntheorem finite_span_isCompactElement (S : Set M) (h : S.Finite) :\n    CompleteLattice.IsCompactElement (span R S : Submodule R M) :=\n  Finite.coe_toFinset h ▸ finset_span_isCompactElement h.toFinset\n\n"}
{"name":"Submodule.instIsCompactlyGenerated","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ IsCompactlyGenerated (Submodule R M)","decl":"instance : IsCompactlyGenerated (Submodule R M) :=\n  ⟨fun s =>\n    ⟨(fun x => span R {x}) '' s,\n      ⟨fun t ht => by\n        rcases (Set.mem_image _ _ _).1 ht with ⟨x, _, rfl⟩\n        apply singleton_span_isCompactElement, by\n        rw [sSup_eq_iSup, iSup_image, ← span_eq_iSup_of_singleton_spans, span_eq]⟩⟩⟩\n\n"}
{"name":"Submodule.prod_coe","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\np : Submodule R M\nM' : Type u_9\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nq₁ : Submodule R M'\n⊢ Eq (↑(p.prod q₁)) (SProd.sprod ↑p ↑q₁)","decl":"@[simp]\ntheorem prod_coe : (prod p q₁ : Set (M × M')) = (p : Set M) ×ˢ (q₁ : Set M') :=\n  rfl\n\n"}
{"name":"Submodule.mem_prod","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nM' : Type u_9\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\np : Submodule R M\nq : Submodule R M'\nx : Prod M M'\n⊢ Iff (Membership.mem (p.prod q) x) (And (Membership.mem p x.1) (Membership.mem q x.2))","decl":"@[simp]\ntheorem mem_prod {p : Submodule R M} {q : Submodule R M'} {x : M × M'} :\n    x ∈ prod p q ↔ x.1 ∈ p ∧ x.2 ∈ q :=\n  Set.mem_prod\n\n"}
{"name":"Submodule.span_prod_le","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nM' : Type u_9\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\ns : Set M\nt : Set M'\n⊢ LE.le (Submodule.span R (SProd.sprod s t)) ((Submodule.span R s).prod (Submodule.span R t))","decl":"theorem span_prod_le (s : Set M) (t : Set M') : span R (s ×ˢ t) ≤ prod (span R s) (span R t) :=\n  span_le.2 <| Set.prod_mono subset_span subset_span\n\n"}
{"name":"Submodule.prod_top","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nM' : Type u_9\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\n⊢ Eq (Top.top.prod Top.top) Top.top","decl":"@[simp]\ntheorem prod_top : (prod ⊤ ⊤ : Submodule R (M × M')) = ⊤ := by ext; simp\n\n"}
{"name":"Submodule.prod_bot","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nM' : Type u_9\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\n⊢ Eq (Bot.bot.prod Bot.bot) Bot.bot","decl":"@[simp]\ntheorem prod_bot : (prod ⊥ ⊥ : Submodule R (M × M')) = ⊥ := by ext ⟨x, y⟩; simp\n\n"}
{"name":"Submodule.prod_mono","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nM' : Type u_9\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\np p' : Submodule R M\nq q' : Submodule R M'\na✝¹ : LE.le p p'\na✝ : LE.le q q'\n⊢ LE.le (p.prod q) (p'.prod q')","decl":"theorem prod_mono {p p' : Submodule R M} {q q' : Submodule R M'} :\n    p ≤ p' → q ≤ q' → prod p q ≤ prod p' q' :=\n  Set.prod_mono\n\n"}
{"name":"Submodule.prod_inf_prod","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\np p' : Submodule R M\nM' : Type u_9\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nq₁ q₁' : Submodule R M'\n⊢ Eq (Min.min (p.prod q₁) (p'.prod q₁')) ((Min.min p p').prod (Min.min q₁ q₁'))","decl":"@[simp]\ntheorem prod_inf_prod : prod p q₁ ⊓ prod p' q₁' = prod (p ⊓ p') (q₁ ⊓ q₁') :=\n  SetLike.coe_injective Set.prod_inter_prod\n\n"}
{"name":"Submodule.prod_sup_prod","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\np p' : Submodule R M\nM' : Type u_9\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nq₁ q₁' : Submodule R M'\n⊢ Eq (Max.max (p.prod q₁) (p'.prod q₁')) ((Max.max p p').prod (Max.max q₁ q₁'))","decl":"@[simp]\ntheorem prod_sup_prod : prod p q₁ ⊔ prod p' q₁' = prod (p ⊔ p') (q₁ ⊔ q₁') := by\n  refine le_antisymm\n    (sup_le (prod_mono le_sup_left le_sup_left) (prod_mono le_sup_right le_sup_right)) ?_\n  simp only [SetLike.le_def, mem_prod, and_imp, Prod.forall]; intro xx yy hxx hyy\n  rcases mem_sup.1 hxx with ⟨x, hx, x', hx', rfl⟩\n  rcases mem_sup.1 hyy with ⟨y, hy, y', hy', rfl⟩\n  exact mem_sup.2 ⟨(x, y), ⟨hx, hy⟩, (x', y'), ⟨hx', hy'⟩, rfl⟩\n\n"}
{"name":"LinearMap.BilinMap.apply_apply_mem_of_mem_span","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_10\nM : Type u_11\nN : Type u_12\nP : Type u_13\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nP' : Submodule R P\ns : Set M\nt : Set N\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\nhB : ∀ (x : M), Membership.mem s x → ∀ (y : N), Membership.mem t y → Membership.mem P' ((B x) y)\nx : M\ny : N\nhx : Membership.mem (Submodule.span R s) x\nhy : Membership.mem (Submodule.span R t) y\n⊢ Membership.mem P' ((B x) y)","decl":"/-- If a bilinear map takes values in a submodule along two sets, then the same is true along\nthe span of these sets. -/\nlemma _root_.LinearMap.BilinMap.apply_apply_mem_of_mem_span {R M N P : Type*} [CommSemiring R]\n    [AddCommGroup M] [AddCommMonoid N] [AddCommMonoid P] [Module R M] [Module R N] [Module R P]\n    (P' : Submodule R P) (s : Set M) (t : Set N)\n    (B : M →ₗ[R] N →ₗ[R] P) (hB : ∀ x ∈ s, ∀ y ∈ t, B x y ∈ P')\n    (x : M) (y : N) (hx : x ∈ span R s) (hy : y ∈ span R t) :\n    B x y ∈ P' := by\n  induction hx, hy using span_induction₂ with\n  | mem_mem u v hu hv => exact hB u hu v hv\n  | zero_left v hv => simp\n  | zero_right u hu => simp\n  | add_left u₁ u₂ v hu₁ hu₂ hv huv₁ huv₂ => simpa using add_mem huv₁ huv₂\n  | add_right u v₁ v₂ hu hv₁ hv₂ huv₁ huv₂ => simpa using add_mem huv₁ huv₂\n  | smul_left t u v hu hv huv => simpa using Submodule.smul_mem _ _ huv\n  | smul_right t u v hu hv huv => simpa using Submodule.smul_mem _ _ huv\n\n"}
{"name":"Submodule.span_neg","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ns : Set M\n⊢ Eq (Submodule.span R (Neg.neg s)) (Submodule.span R s)","decl":"@[simp]\ntheorem span_neg (s : Set M) : span R (-s) = span R s :=\n  calc\n    span R (-s) = span R ((-LinearMap.id : M →ₗ[R] M) '' s) := by simp\n    _ = map (-LinearMap.id) (span R s) := (map_span (-LinearMap.id) _).symm\n    _ = span R s := by simp\n\n"}
{"name":"Submodule.instIsModularLattice","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ IsModularLattice (Submodule R M)","decl":"instance : IsModularLattice (Submodule R M) :=\n  ⟨fun y z xz a ha => by\n    rw [mem_inf, mem_sup] at ha\n    rcases ha with ⟨⟨b, hb, c, hc, rfl⟩, haz⟩\n    rw [mem_sup]\n    refine ⟨b, hb, c, mem_inf.2 ⟨hc, ?_⟩, rfl⟩\n    rw [← add_sub_cancel_right c b, add_comm]\n    apply z.sub_mem haz (xz hb)⟩\n\n"}
{"name":"Submodule.isCompl_comap_subtype_of_isCompl_of_le","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np q r : Submodule R M\nh₁ : IsCompl q r\nh₂ : LE.le q p\n⊢ IsCompl (Submodule.comap p.subtype q) (Submodule.comap p.subtype r)","decl":"lemma isCompl_comap_subtype_of_isCompl_of_le {p q r : Submodule R M}\n    (h₁ : IsCompl q r) (h₂ : q ≤ p) :\n    IsCompl (q.comap p.subtype) (r.comap p.subtype) := by\n  simpa [p.mapIic.isCompl_iff, Iic.isCompl_iff] using Iic.isCompl_inf_inf_of_isCompl_of_le h₁ h₂\n\n"}
{"name":"Submodule.comap_map_eq","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝² : RingHomSurjective τ₁₂\nF : Type u_8\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F τ₁₂ M M₂\nf : F\np : Submodule R M\n⊢ Eq (Submodule.comap f (Submodule.map f p)) (Max.max p (LinearMap.ker f))","decl":"theorem comap_map_eq (f : F) (p : Submodule R M) : comap f (map f p) = p ⊔ LinearMap.ker f := by\n  refine le_antisymm ?_ (sup_le (le_comap_map _ _) (comap_mono bot_le))\n  rintro x ⟨y, hy, e⟩\n  exact mem_sup.2 ⟨y, hy, x - y, by simpa using sub_eq_zero.2 e.symm, by simp⟩\n\n"}
{"name":"Submodule.comap_map_eq_self","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝² : RingHomSurjective τ₁₂\nF : Type u_8\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F τ₁₂ M M₂\nf : F\np : Submodule R M\nh : LE.le (LinearMap.ker f) p\n⊢ Eq (Submodule.comap f (Submodule.map f p)) p","decl":"theorem comap_map_eq_self {f : F} {p : Submodule R M} (h : LinearMap.ker f ≤ p) :\n    comap f (map f p) = p := by rw [Submodule.comap_map_eq, sup_of_le_left h]\n\n"}
{"name":"LinearMap.range_domRestrict_eq_range_iff","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective τ₁₂\nf : LinearMap τ₁₂ M M₂\nS : Submodule R M\n⊢ Iff (Eq (LinearMap.range (f.domRestrict S)) (LinearMap.range f)) (Eq (Max.max S (LinearMap.ker f)) Top.top)","decl":"lemma _root_.LinearMap.range_domRestrict_eq_range_iff {f : M →ₛₗ[τ₁₂] M₂} {S : Submodule R M} :\n    LinearMap.range (f.domRestrict S) = LinearMap.range f ↔ S ⊔ (LinearMap.ker f) = ⊤ := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · rw [eq_top_iff]\n    intro x _\n    have : f x ∈ LinearMap.range f := LinearMap.mem_range_self f x\n    rw [← h] at this\n    obtain ⟨y, hy⟩ : ∃ y : S, f.domRestrict S y = f x := this\n    have : (y : M) + (x - y) ∈ S ⊔ (LinearMap.ker f) := Submodule.add_mem_sup y.2 (by simp [← hy])\n    simpa using this\n  · refine le_antisymm (LinearMap.range_domRestrict_le_range f S) ?_\n    rintro x ⟨y, rfl⟩\n    obtain ⟨s, hs, t, ht, rfl⟩ : ∃ s, s ∈ S ∧ ∃ t, t ∈ LinearMap.ker f ∧ s + t = y :=\n      Submodule.mem_sup.1 (by simp [h])\n    exact ⟨⟨s, hs⟩, by simp [LinearMap.mem_ker.1 ht]⟩\n\n"}
{"name":"LinearMap.surjective_domRestrict_iff","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective τ₁₂\nf : LinearMap τ₁₂ M M₂\nS : Submodule R M\nhf : Function.Surjective ⇑f\n⊢ Iff (Function.Surjective ⇑(f.domRestrict S)) (Eq (Max.max S (LinearMap.ker f)) Top.top)","decl":"@[simp] lemma _root_.LinearMap.surjective_domRestrict_iff\n    {f : M →ₛₗ[τ₁₂] M₂} {S : Submodule R M} (hf : Surjective f) :\n    Surjective (f.domRestrict S) ↔ S ⊔ LinearMap.ker f = ⊤ := by\n  rw [← LinearMap.range_eq_top] at hf ⊢\n  rw [← hf]\n  exact LinearMap.range_domRestrict_eq_range_iff\n\n"}
{"name":"Submodule.biSup_comap_subtype_eq_top","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nι : Type u_9\ns : Set ι\np : ι → Submodule R M\n⊢ Eq (iSup fun i => iSup fun h => Submodule.comap (iSup fun i => iSup fun h => p i).subtype (p i)) Top.top","decl":"@[simp]\nlemma biSup_comap_subtype_eq_top {ι : Type*} (s : Set ι) (p : ι → Submodule R M) :\n    ⨆ i ∈ s, (p i).comap (⨆ i ∈ s, p i).subtype = ⊤ := by\n  refine eq_top_iff.mpr fun ⟨x, hx⟩ _ ↦ ?_\n  suffices x ∈ (⨆ i ∈ s, (p i).comap (⨆ i ∈ s, p i).subtype).map (⨆ i ∈ s, (p i)).subtype by\n    obtain ⟨y, hy, rfl⟩ := Submodule.mem_map.mp this\n    exact hy\n  suffices ∀ i ∈ s, (comap (⨆ i ∈ s, p i).subtype (p i)).map (⨆ i ∈ s, p i).subtype = p i by\n    simpa only [map_iSup, biSup_congr this]\n  intro i hi\n  rw [map_comap_eq, range_subtype, inf_eq_right]\n  exact le_biSup p hi\n\n"}
{"name":"Submodule.biSup_comap_eq_top_of_surjective","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective τ₁₂\nι : Type u_9\ns : Set ι\nhs : s.Nonempty\np : ι → Submodule R₂ M₂\nhp : Eq (iSup fun i => iSup fun h => p i) Top.top\nf : LinearMap τ₁₂ M M₂\nhf : Function.Surjective ⇑f\n⊢ Eq (iSup fun i => iSup fun h => Submodule.comap f (p i)) Top.top","decl":"lemma biSup_comap_eq_top_of_surjective {ι : Type*} (s : Set ι) (hs : s.Nonempty)\n    (p : ι → Submodule R₂ M₂) (hp : ⨆ i ∈ s, p i = ⊤)\n    (f : M →ₛₗ[τ₁₂] M₂) (hf : Surjective f) :\n    ⨆ i ∈ s, (p i).comap f = ⊤ := by\n  obtain ⟨k, hk⟩ := hs\n  suffices (⨆ i ∈ s, (p i).comap f) ⊔ LinearMap.ker f = ⊤ by\n    rw [← this, left_eq_sup]; exact le_trans f.ker_le_comap (le_biSup (fun i ↦ (p i).comap f) hk)\n  rw [iSup_subtype'] at hp ⊢\n  rw [← comap_map_eq, map_iSup_comap_of_sujective hf, hp, comap_top]\n\n"}
{"name":"Submodule.biSup_comap_eq_top_of_range_eq_biSup","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"M : Type u_4\nM₂ : Type u_5\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : AddCommGroup M₂\nR : Type u_9\nR₂ : Type u_10\ninst✝⁴ : Ring R\ninst✝³ : Ring R₂\nτ₁₂ : RingHom R R₂\ninst✝² : RingHomSurjective τ₁₂\ninst✝¹ : Module R M\ninst✝ : Module R₂ M₂\nι : Type u_11\ns : Set ι\nhs : s.Nonempty\np : ι → Submodule R₂ M₂\nf : LinearMap τ₁₂ M M₂\nhf : Eq (LinearMap.range f) (iSup fun i => iSup fun h => p i)\n⊢ Eq (iSup fun i => iSup fun h => Submodule.comap f (p i)) Top.top","decl":"lemma biSup_comap_eq_top_of_range_eq_biSup\n    {R R₂ : Type*} [Ring R] [Ring R₂] {τ₁₂ : R →+* R₂} [RingHomSurjective τ₁₂]\n    [Module R M] [Module R₂ M₂] {ι : Type*} (s : Set ι) (hs : s.Nonempty)\n    (p : ι → Submodule R₂ M₂) (f : M →ₛₗ[τ₁₂] M₂) (hf : LinearMap.range f = ⨆ i ∈ s, p i) :\n    ⨆ i ∈ s, (p i).comap f = ⊤ := by\n  suffices ⨆ i ∈ s, (p i).comap (LinearMap.range f).subtype = ⊤ by\n    rw [← biSup_comap_eq_top_of_surjective s hs _ this _ f.surjective_rangeRestrict]; rfl\n  exact hf ▸ biSup_comap_subtype_eq_top s p\n\n"}
{"name":"Submodule.wcovBy_span_singleton_sup","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"K : Type u_3\nV : Type u_6\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nx : V\ns : Submodule K V\n⊢ WCovBy s (Max.max (Submodule.span K (Singleton.singleton x)) s)","decl":"/-- There is no vector subspace between `s` and `(K ∙ x) ⊔ s`, `WCovBy` version. -/\ntheorem wcovBy_span_singleton_sup (x : V) (s : Submodule K V) : WCovBy s ((K ∙ x) ⊔ s) := by\n  refine ⟨le_sup_right, fun q hpq hqp ↦ hqp.not_le ?_⟩\n  rcases SetLike.exists_of_lt hpq with ⟨y, hyq, hyp⟩\n  obtain ⟨c, z, hz, rfl⟩ : ∃ c : K, ∃ z ∈ s, c • x + z = y := by\n    simpa [mem_sup, mem_span_singleton] using hqp.le hyq\n  rcases eq_or_ne c 0 with rfl | hc\n  · simp [hz] at hyp\n  · have : x ∈ q := by\n      rwa [q.add_mem_iff_left (hpq.le hz), q.smul_mem_iff hc] at hyq\n    simp [hpq.le, this]\n\n"}
{"name":"Submodule.covBy_span_singleton_sup","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"K : Type u_3\nV : Type u_6\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nx : V\ns : Submodule K V\nh : Not (Membership.mem s x)\n⊢ CovBy s (Max.max (Submodule.span K (Singleton.singleton x)) s)","decl":"/-- There is no vector subspace between `s` and `(K ∙ x) ⊔ s`, `CovBy` version. -/\ntheorem covBy_span_singleton_sup {x : V} {s : Submodule K V} (h : x ∉ s) : CovBy s ((K ∙ x) ⊔ s) :=\n  ⟨by simpa, (wcovBy_span_singleton_sup _ _).2⟩\n\n"}
{"name":"Submodule.disjoint_span_singleton","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"K : Type u_3\nV : Type u_6\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\ns : Submodule K V\nx : V\n⊢ Iff (Disjoint s (Submodule.span K (Singleton.singleton x))) (Membership.mem s x → Eq x 0)","decl":"theorem disjoint_span_singleton : Disjoint s (K ∙ x) ↔ x ∈ s → x = 0 := by\n  refine disjoint_def.trans ⟨fun H hx => H x hx <| subset_span <| mem_singleton x, ?_⟩\n  intro H y hy hyx\n  obtain ⟨c, rfl⟩ := mem_span_singleton.1 hyx\n  by_cases hc : c = 0\n  · rw [hc, zero_smul]\n  · rw [s.smul_mem_iff hc] at hy\n    rw [H hy, smul_zero]\n\n"}
{"name":"Submodule.disjoint_span_singleton'","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"K : Type u_3\nV : Type u_6\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\ns : Submodule K V\nx : V\nx0 : Ne x 0\n⊢ Iff (Disjoint s (Submodule.span K (Singleton.singleton x))) (Not (Membership.mem s x))","decl":"theorem disjoint_span_singleton' (x0 : x ≠ 0) : Disjoint s (K ∙ x) ↔ x ∉ s :=\n  disjoint_span_singleton.trans ⟨fun h₁ h₂ => x0 (h₁ h₂), fun h₁ h₂ => (h₁ h₂).elim⟩\n\n"}
{"name":"Submodule.disjoint_span_singleton_of_not_mem","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"K : Type u_3\nV : Type u_6\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\ns : Submodule K V\nx : V\nhx : Not (Membership.mem s x)\n⊢ Disjoint s (Submodule.span K (Singleton.singleton x))","decl":"lemma disjoint_span_singleton_of_not_mem (hx : x ∉ s) : Disjoint s (K ∙ x) := by\n  rw [disjoint_span_singleton]\n  intro h\n  contradiction\n\n"}
{"name":"Submodule.isCompl_span_singleton_of_isCoatom_of_not_mem","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"K : Type u_3\nV : Type u_6\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\ns : Submodule K V\nx : V\nhs : IsCoatom s\nhx : Not (Membership.mem s x)\n⊢ IsCompl s (Submodule.span K (Singleton.singleton x))","decl":"lemma isCompl_span_singleton_of_isCoatom_of_not_mem (hs : IsCoatom s) (hx : x ∉ s) :\n    IsCompl s (K ∙ x) := by\n  refine ⟨disjoint_span_singleton_of_not_mem hx, ?_⟩\n  rw [← covBy_top_iff] at hs\n  simpa only [codisjoint_iff, sup_comm, not_lt_top_iff] using hs.2 (covBy_span_singleton_sup hx).1\n\n"}
{"name":"LinearMap.map_le_map_iff","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : AddCommGroup M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝² : RingHomSurjective τ₁₂\nF : Type u_8\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F τ₁₂ M M₂\nf : F\np p' : Submodule R M\n⊢ Iff (LE.le (Submodule.map f p) (Submodule.map f p')) (LE.le p (Max.max p' (LinearMap.ker f)))","decl":"protected theorem map_le_map_iff (f : F) {p p'} : map f p ≤ map f p' ↔ p ≤ p' ⊔ ker f := by\n  rw [map_le_iff_le_comap, Submodule.comap_map_eq]\n\n"}
{"name":"LinearMap.map_le_map_iff'","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : AddCommGroup M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝² : RingHomSurjective τ₁₂\nF : Type u_8\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F τ₁₂ M M₂\nf : F\nhf : Eq (LinearMap.ker f) Bot.bot\np p' : Submodule R M\n⊢ Iff (LE.le (Submodule.map f p) (Submodule.map f p')) (LE.le p p')","decl":"theorem map_le_map_iff' {f : F} (hf : ker f = ⊥) {p p'} : map f p ≤ map f p' ↔ p ≤ p' := by\n  rw [LinearMap.map_le_map_iff, hf, sup_bot_eq]\n\n"}
{"name":"LinearMap.map_injective","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : AddCommGroup M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝² : RingHomSurjective τ₁₂\nF : Type u_8\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F τ₁₂ M M₂\nf : F\nhf : Eq (LinearMap.ker f) Bot.bot\n⊢ Function.Injective (Submodule.map f)","decl":"theorem map_injective {f : F} (hf : ker f = ⊥) : Injective (map f) := fun _ _ h =>\n  le_antisymm ((map_le_map_iff' hf).1 (le_of_eq h)) ((map_le_map_iff' hf).1 (ge_of_eq h))\n\n"}
{"name":"LinearMap.map_eq_top_iff","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : AddCommGroup M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝² : RingHomSurjective τ₁₂\nF : Type u_8\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F τ₁₂ M M₂\nf : F\nhf : Eq (LinearMap.range f) Top.top\np : Submodule R M\n⊢ Iff (Eq (Submodule.map f p) Top.top) (Eq (Max.max p (LinearMap.ker f)) Top.top)","decl":"theorem map_eq_top_iff {f : F} (hf : range f = ⊤) {p : Submodule R M} :\n    p.map f = ⊤ ↔ p ⊔ LinearMap.ker f = ⊤ := by\n  simp_rw [← top_le_iff, ← hf, range_eq_map, LinearMap.map_le_map_iff]\n\n"}
{"name":"LinearMap.toSpanSingleton_apply","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\nb : R\n⊢ Eq ((LinearMap.toSpanSingleton R M x) b) (HSMul.hSMul b x)","decl":"/-- Given an element `x` of a module `M` over `R`, the natural map from\n    `R` to scalar multiples of `x`. See also `LinearMap.ringLmapEquivSelf`. -/\n@[simps!]\ndef toSpanSingleton (x : M) : R →ₗ[R] M :=\n  LinearMap.id.smulRight x\n\n"}
{"name":"LinearMap.span_singleton_eq_range","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ Eq (Submodule.span R (Singleton.singleton x)) (LinearMap.range (LinearMap.toSpanSingleton R M x))","decl":"/-- The range of `toSpanSingleton x` is the span of `x`. -/\ntheorem span_singleton_eq_range (x : M) : (R ∙ x) = range (toSpanSingleton R M x) :=\n  Submodule.ext fun y => by\n    refine Iff.trans ?_ LinearMap.mem_range.symm\n    exact mem_span_singleton\n\n"}
{"name":"LinearMap.toSpanSingleton_one","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ Eq ((LinearMap.toSpanSingleton R M x) 1) x","decl":"theorem toSpanSingleton_one (x : M) : toSpanSingleton R M x 1 = x :=\n  one_smul _ _\n\n"}
{"name":"LinearMap.toSpanSingleton_injective","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Function.Injective (LinearMap.toSpanSingleton R M)","decl":"theorem toSpanSingleton_injective : Function.Injective (toSpanSingleton R M) :=\n  fun _ _ eq ↦ by simpa using congr($eq 1)\n\n"}
{"name":"LinearMap.toSpanSingleton_zero","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (LinearMap.toSpanSingleton R M 0) 0","decl":"@[simp]\ntheorem toSpanSingleton_zero : toSpanSingleton R M 0 = 0 := by\n  ext\n  simp\n\n"}
{"name":"LinearMap.toSpanSingleton_eq_zero_iff","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ Iff (Eq (LinearMap.toSpanSingleton R M x) 0) (Eq x 0)","decl":"theorem toSpanSingleton_eq_zero_iff {x : M} : toSpanSingleton R M x = 0 ↔ x = 0 := by\n  rw [← toSpanSingleton_zero, (toSpanSingleton_injective R M).eq_iff]\n\n"}
{"name":"LinearMap.toSpanSingleton_isIdempotentElem_iff","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\ne : R\n⊢ Iff (IsIdempotentElem (LinearMap.toSpanSingleton R R e)) (IsIdempotentElem e)","decl":"theorem toSpanSingleton_isIdempotentElem_iff {e : R} :\n    IsIdempotentElem (toSpanSingleton R R e) ↔ IsIdempotentElem e := by\n  simp_rw [IsIdempotentElem, LinearMap.ext_iff, mul_apply, toSpanSingleton_apply, smul_eq_mul,\n    mul_assoc]\n  exact ⟨fun h ↦ by conv_rhs => rw [← one_mul e, ← h, one_mul], fun h _ ↦ by rw [h]⟩\n\n"}
{"name":"LinearMap.isIdempotentElem_apply_one_iff","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Module.End R R\n⊢ Iff (IsIdempotentElem (f 1)) (IsIdempotentElem f)","decl":"theorem isIdempotentElem_apply_one_iff {f : Module.End R R} :\n    IsIdempotentElem (f 1) ↔ IsIdempotentElem f := by\n  rw [IsIdempotentElem, ← smul_eq_mul, ← map_smul, smul_eq_mul, mul_one, IsIdempotentElem,\n    LinearMap.ext_iff]\n  simp_rw [mul_apply]\n  exact ⟨fun h r ↦ by rw [← mul_one r, ← smul_eq_mul, map_smul, map_smul, h], (· 1)⟩\n\n"}
{"name":"LinearMap.eqOn_span_iff","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R₂ M₂\nF : Type u_8\nσ₁₂ : RingHom R R₂\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\ns : Set M\nf g : F\n⊢ Iff (Set.EqOn ⇑f ⇑g ↑(Submodule.span R s)) (Set.EqOn (⇑f) (⇑g) s)","decl":"/-- Two linear maps are equal on `Submodule.span s` iff they are equal on `s`. -/\ntheorem eqOn_span_iff {s : Set M} {f g : F} : Set.EqOn f g (span R s) ↔ Set.EqOn f g s := by\n  rw [← le_eqLocus, span_le]; rfl\n\n"}
{"name":"LinearMap.eqOn_span'","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R₂ M₂\nF : Type u_8\nσ₁₂ : RingHom R R₂\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\ns : Set M\nf g : F\nH : Set.EqOn (⇑f) (⇑g) s\n⊢ Set.EqOn ⇑f ⇑g ↑(Submodule.span R s)","decl":"/-- If two linear maps are equal on a set `s`, then they are equal on `Submodule.span s`.\n\nThis version uses `Set.EqOn`, and the hidden argument will expand to `h : x ∈ (span R s : Set M)`.\nSee `LinearMap.eqOn_span` for a version that takes `h : x ∈ span R s` as an argument. -/\ntheorem eqOn_span' {s : Set M} {f g : F} (H : Set.EqOn f g s) :\n    Set.EqOn f g (span R s : Set M) :=\n  eqOn_span_iff.2 H\n\n"}
{"name":"LinearMap.eqOn_span","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R₂ M₂\nF : Type u_8\nσ₁₂ : RingHom R R₂\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\ns : Set M\nf g : F\nH : Set.EqOn (⇑f) (⇑g) s\nx : M\nh : Membership.mem (Submodule.span R s) x\n⊢ Eq (f x) (g x)","decl":"/-- If two linear maps are equal on a set `s`, then they are equal on `Submodule.span s`.\n\nSee also `LinearMap.eqOn_span'` for a version using `Set.EqOn`. -/\ntheorem eqOn_span {s : Set M} {f g : F} (H : Set.EqOn f g s) ⦃x⦄ (h : x ∈ span R s) :\n    f x = g x :=\n  eqOn_span' H h\n\n"}
{"name":"LinearMap.ext_on","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R₂ M₂\nF : Type u_8\nσ₁₂ : RingHom R R₂\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\ns : Set M\nf g : F\nhv : Eq (Submodule.span R s) Top.top\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Eq f g","decl":"/-- If `s` generates the whole module and linear maps `f`, `g` are equal on `s`, then they are\nequal. -/\ntheorem ext_on {s : Set M} {f g : F} (hv : span R s = ⊤) (h : Set.EqOn f g s) : f = g :=\n  DFunLike.ext _ _ fun _ => eqOn_span h (eq_top_iff'.1 hv _)\n\n"}
{"name":"LinearMap.ext_on_range","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_5\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R₂ M₂\nF : Type u_8\nσ₁₂ : RingHom R R₂\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nι : Sort u_9\nv : ι → M\nf g : F\nhv : Eq (Submodule.span R (Set.range v)) Top.top\nh : ∀ (i : ι), Eq (f (v i)) (g (v i))\n⊢ Eq f g","decl":"/-- If the range of `v : ι → M` generates the whole module and linear maps `f`, `g` are equal at\neach `v i`, then they are equal. -/\ntheorem ext_on_range {ι : Sort*} {v : ι → M} {f g : F} (hv : span R (Set.range v) = ⊤)\n    (h : ∀ i, f (v i) = g (v i)) : f = g :=\n  ext_on hv (Set.forall_mem_range.2 h)\n\n"}
{"name":"LinearMap.ker_toSpanSingleton","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nx : M\nh : Ne x 0\n⊢ Eq (LinearMap.ker (LinearMap.toSpanSingleton R M x)) Bot.bot","decl":"theorem ker_toSpanSingleton {x : M} (h : x ≠ 0) : LinearMap.ker (toSpanSingleton R M x) = ⊥ :=\n  SetLike.ext fun _ => smul_eq_zero.trans <| or_iff_left_of_imp fun h' => (h h').elim\n\n"}
{"name":"LinearMap.span_singleton_sup_ker_eq_top","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"K : Type u_3\nV : Type u_6\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nf : LinearMap (RingHom.id K) V K\nx : V\nhx : Ne (f x) 0\n⊢ Eq (Max.max (Submodule.span K (Singleton.singleton x)) (LinearMap.ker f)) Top.top","decl":"theorem span_singleton_sup_ker_eq_top (f : V →ₗ[K] K) {x : V} (hx : f x ≠ 0) :\n    (K ∙ x) ⊔ ker f = ⊤ :=\n  top_unique fun y _ =>\n    Submodule.mem_sup.2\n      ⟨(f y * (f x)⁻¹) • x, Submodule.mem_span_singleton.2 ⟨f y * (f x)⁻¹, rfl⟩,\n        ⟨y - (f y * (f x)⁻¹) • x, by simp [hx]⟩⟩\n\n"}
{"name":"LinearEquiv.toSpanNonzeroSingleton_apply","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nx : M\nh : Ne x 0\nt : R\n⊢ Eq ((LinearEquiv.toSpanNonzeroSingleton R M x h) t) ⟨HSMul.hSMul t x, ⋯⟩","decl":"@[simp] theorem toSpanNonzeroSingleton_apply (t : R) :\n    toSpanNonzeroSingleton R M x h t =\n      (⟨t • x, Submodule.smul_mem _ _ (Submodule.mem_span_singleton_self x)⟩ : R ∙ x) := by\n  rfl\n\n"}
{"name":"LinearEquiv.toSpanNonzeroSingleton_symm_apply_smul","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nx : M\nh : Ne x 0\nm : Subtype fun x_1 => Membership.mem (Submodule.span R (Singleton.singleton x)) x_1\n⊢ Eq (HSMul.hSMul ((LinearEquiv.toSpanNonzeroSingleton R M x h).symm m) x) ↑m","decl":"@[simp]\nlemma toSpanNonzeroSingleton_symm_apply_smul (m : R ∙ x) :\n    (toSpanNonzeroSingleton R M x h).symm m • x = m :=\n  congrArg Subtype.val <| apply_symm_apply (toSpanNonzeroSingleton R M x h) m\n\n"}
{"name":"LinearEquiv.toSpanNonzeroSingleton_one","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nx : M\nh : Ne x 0\n⊢ Eq ((LinearEquiv.toSpanNonzeroSingleton R M x h) 1) ⟨x, ⋯⟩","decl":"theorem toSpanNonzeroSingleton_one :\n    LinearEquiv.toSpanNonzeroSingleton R M x h 1 =\n      (⟨x, Submodule.mem_span_singleton_self x⟩ : R ∙ x) := by simp\n\n"}
{"name":"LinearEquiv.coord_self","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nx : M\nh : Ne x 0\n⊢ Eq ((LinearEquiv.coord R M x h) ⟨x, ⋯⟩) 1","decl":"theorem coord_self : (coord R M x h) (⟨x, Submodule.mem_span_singleton_self x⟩ : R ∙ x) = 1 := by\n  rw [← toSpanNonzeroSingleton_one R M x h, LinearEquiv.symm_apply_apply]\n\n"}
{"name":"LinearEquiv.coord_apply_smul","module":"Mathlib.LinearAlgebra.Span.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nx : M\nh : Ne x 0\ny : Subtype fun x_1 => Membership.mem (Submodule.span R (Singleton.singleton x)) x_1\n⊢ Eq (HSMul.hSMul ((LinearEquiv.coord R M x h) y) x) ↑y","decl":"theorem coord_apply_smul (y : Submodule.span R ({x} : Set M)) : coord R M x h y • x = y :=\n  Subtype.ext_iff.1 <| (toSpanNonzeroSingleton R M x h).apply_symm_apply _\n\n"}
