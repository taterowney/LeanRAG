{"name":"RingInvo.mk.injEq","module":"Mathlib.RingTheory.RingInvo","initialProofState":"R : Type u_2\ninst✝ : Semiring R\ntoRingEquiv✝ : RingEquiv R (MulOpposite R)\ninvolution'✝ : ∀ (x : R), Eq (MulOpposite.unop (toRingEquiv✝.toFun (MulOpposite.unop (toRingEquiv✝.toFun x)))) x\ntoRingEquiv : RingEquiv R (MulOpposite R)\ninvolution' : ∀ (x : R), Eq (MulOpposite.unop (toRingEquiv.toFun (MulOpposite.unop (toRingEquiv.toFun x)))) x\n⊢ Eq (Eq { toRingEquiv := toRingEquiv✝, involution' := involution'✝ } { toRingEquiv := toRingEquiv, involution' := involution' }) (Eq toRingEquiv✝ toRingEquiv)","decl":"/-- A ring involution -/\nstructure RingInvo [Semiring R] extends R ≃+* Rᵐᵒᵖ where\n  /-- The requirement that the ring homomorphism is its own inverse -/\n  involution' : ∀ x, (toFun (toFun x).unop).unop = x\n\n"}
{"name":"RingInvo.involution'","module":"Mathlib.RingTheory.RingInvo","initialProofState":"R : Type u_2\ninst✝ : Semiring R\nself : RingInvo R\nx : R\n⊢ Eq (MulOpposite.unop (self.toFun (MulOpposite.unop (self.toFun x)))) x","decl":"/-- A ring involution -/\nstructure RingInvo [Semiring R] extends R ≃+* Rᵐᵒᵖ where\n  /-- The requirement that the ring homomorphism is its own inverse -/\n  involution' : ∀ x, (toFun (toFun x).unop).unop = x\n\n"}
{"name":"RingInvo.mk.sizeOf_spec","module":"Mathlib.RingTheory.RingInvo","initialProofState":"R : Type u_2\ninst✝¹ : Semiring R\ninst✝ : SizeOf R\ntoRingEquiv : RingEquiv R (MulOpposite R)\ninvolution' : ∀ (x : R), Eq (MulOpposite.unop (toRingEquiv.toFun (MulOpposite.unop (toRingEquiv.toFun x)))) x\n⊢ Eq (SizeOf.sizeOf { toRingEquiv := toRingEquiv, involution' := involution' }) (HAdd.hAdd 1 (SizeOf.sizeOf toRingEquiv))","decl":"/-- A ring involution -/\nstructure RingInvo [Semiring R] extends R ≃+* Rᵐᵒᵖ where\n  /-- The requirement that the ring homomorphism is its own inverse -/\n  involution' : ∀ x, (toFun (toFun x).unop).unop = x\n\n"}
{"name":"RingInvo.mk.inj","module":"Mathlib.RingTheory.RingInvo","initialProofState":"R : Type u_2\ninst✝ : Semiring R\ntoRingEquiv✝ : RingEquiv R (MulOpposite R)\ninvolution'✝ : ∀ (x : R), Eq (MulOpposite.unop (toRingEquiv✝.toFun (MulOpposite.unop (toRingEquiv✝.toFun x)))) x\ntoRingEquiv : RingEquiv R (MulOpposite R)\ninvolution' : ∀ (x : R), Eq (MulOpposite.unop (toRingEquiv.toFun (MulOpposite.unop (toRingEquiv.toFun x)))) x\nx✝ : Eq { toRingEquiv := toRingEquiv✝, involution' := involution'✝ } { toRingEquiv := toRingEquiv, involution' := involution' }\n⊢ Eq toRingEquiv✝ toRingEquiv","decl":"/-- A ring involution -/\nstructure RingInvo [Semiring R] extends R ≃+* Rᵐᵒᵖ where\n  /-- The requirement that the ring homomorphism is its own inverse -/\n  involution' : ∀ x, (toFun (toFun x).unop).unop = x\n\n"}
{"name":"RingInvoClass.toRingEquivClass","module":"Mathlib.RingTheory.RingInvo","initialProofState":"F : Type u_3\nR : Type u_4\ninst✝¹ : Semiring R\ninst✝ : EquivLike F R (MulOpposite R)\nself : RingInvoClass F R\n⊢ RingEquivClass F R (MulOpposite R)","decl":"/-- `RingInvoClass F R` states that `F` is a type of ring involutions.\nYou should extend this class when you extend `RingInvo`. -/\nclass RingInvoClass (F R : Type*) [Semiring R] [EquivLike F R Rᵐᵒᵖ]\n  extends RingEquivClass F R Rᵐᵒᵖ : Prop where\n  /-- Every ring involution must be its own inverse -/\n  involution : ∀ (f : F) (x), (f (f x).unop).unop = x\n\n\n"}
{"name":"RingInvoClass.involution","module":"Mathlib.RingTheory.RingInvo","initialProofState":"F : Type u_3\nR : Type u_4\ninst✝¹ : Semiring R\ninst✝ : EquivLike F R (MulOpposite R)\nself : RingInvoClass F R\nf : F\nx : R\n⊢ Eq (MulOpposite.unop (f (MulOpposite.unop (f x)))) x","decl":"/-- `RingInvoClass F R` states that `F` is a type of ring involutions.\nYou should extend this class when you extend `RingInvo`. -/\nclass RingInvoClass (F R : Type*) [Semiring R] [EquivLike F R Rᵐᵒᵖ]\n  extends RingEquivClass F R Rᵐᵒᵖ : Prop where\n  /-- Every ring involution must be its own inverse -/\n  involution : ∀ (f : F) (x), (f (f x).unop).unop = x\n\n\n"}
{"name":"RingInvo.instRingInvoClass","module":"Mathlib.RingTheory.RingInvo","initialProofState":"R : Type u_2\ninst✝ : Semiring R\n⊢ RingInvoClass (RingInvo R) R","decl":"instance : RingInvoClass (RingInvo R) R where\n  map_add f := f.map_add'\n  map_mul f := f.map_mul'\n  involution f := f.involution'\n\n"}
{"name":"RingInvo.involution","module":"Mathlib.RingTheory.RingInvo","initialProofState":"R : Type u_2\ninst✝ : Semiring R\nf : RingInvo R\nx : R\n⊢ Eq (MulOpposite.unop (f (MulOpposite.unop (f x)))) x","decl":"@[simp]\ntheorem involution (f : RingInvo R) (x : R) : (f (f x).unop).unop = x :=\n  f.involution' x\n\n-- Porting note: remove Coe instance, not needed\n-- instance hasCoeToRingEquiv : Coe (RingInvo R) (R ≃+* Rᵐᵒᵖ) :=\n--   ⟨RingInvo.toRingEquiv⟩\n\n"}
{"name":"RingInvo.coe_ringEquiv","module":"Mathlib.RingTheory.RingInvo","initialProofState":"R : Type u_2\ninst✝ : Semiring R\nf : RingInvo R\na : R\n⊢ Eq (↑f a) (f a)","decl":"@[norm_cast]\ntheorem coe_ringEquiv (f : RingInvo R) (a : R) : (f : R ≃+* Rᵐᵒᵖ) a = f a :=\n  rfl\n\n"}
{"name":"RingInvo.map_eq_zero_iff","module":"Mathlib.RingTheory.RingInvo","initialProofState":"R : Type u_2\ninst✝ : Semiring R\nf : RingInvo R\nx : R\n⊢ Iff (Eq (f x) 0) (Eq x 0)","decl":"theorem map_eq_zero_iff (f : RingInvo R) {x : R} : f x = 0 ↔ x = 0 :=\n  f.toRingEquiv.map_eq_zero_iff\n\n"}
