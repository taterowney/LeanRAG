{"name":"instIsAtomicFilter","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nâŠ¢ IsAtomic (Filter Î±)","decl":"/-- `Filter Î±` is an atomic type: for every filter there exists an ultrafilter that is less than or\nequal to this filter. -/\ninstance : IsAtomic (Filter Î±) :=\n  IsAtomic.of_isChain_bounded fun c hc hne hb =>\n    âŸ¨sInf c, (sInf_neBot_of_directed' hne (show IsChain (Â· â‰¥ Â·) c from hc.symm).directedOn hb).ne,\n      fun _ hx => sInf_le hxâŸ©\n\n"}
{"name":"Ultrafilter.mk.injEq","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u_2\ntoFilterâœ : Filter Î±\nneBot'âœ : toFilterâœ.NeBot\nle_of_leâœ : âˆ€ (g : Filter Î±), g.NeBot â†’ LE.le g toFilterâœ â†’ LE.le toFilterâœ g\ntoFilter : Filter Î±\nneBot' : toFilter.NeBot\nle_of_le : âˆ€ (g : Filter Î±), g.NeBot â†’ LE.le g toFilter â†’ LE.le toFilter g\nâŠ¢ Eq (Eq { toFilter := toFilterâœ, neBot' := neBot'âœ, le_of_le := le_of_leâœ } { toFilter := toFilter, neBot' := neBot', le_of_le := le_of_le }) (Eq toFilterâœ toFilter)","decl":"/-- An ultrafilter is a minimal (maximal in the set order) proper filter. -/\nstructure Ultrafilter (Î± : Type*) extends Filter Î± where\n  /-- An ultrafilter is nontrivial. -/\n  protected neBot' : NeBot toFilter\n  /-- If `g` is a nontrivial filter that is less than or equal to an ultrafilter, then it is greater\n  than or equal to the ultrafilter. -/\n  protected le_of_le : âˆ€ g, Filter.NeBot g â†’ g â‰¤ toFilter â†’ toFilter â‰¤ g\n\n"}
{"name":"Ultrafilter.mk.inj","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u_2\ntoFilterâœ : Filter Î±\nneBot'âœ : toFilterâœ.NeBot\nle_of_leâœ : âˆ€ (g : Filter Î±), g.NeBot â†’ LE.le g toFilterâœ â†’ LE.le toFilterâœ g\ntoFilter : Filter Î±\nneBot' : toFilter.NeBot\nle_of_le : âˆ€ (g : Filter Î±), g.NeBot â†’ LE.le g toFilter â†’ LE.le toFilter g\nxâœ : Eq { toFilter := toFilterâœ, neBot' := neBot'âœ, le_of_le := le_of_leâœ } { toFilter := toFilter, neBot' := neBot', le_of_le := le_of_le }\nâŠ¢ Eq toFilterâœ toFilter","decl":"/-- An ultrafilter is a minimal (maximal in the set order) proper filter. -/\nstructure Ultrafilter (Î± : Type*) extends Filter Î± where\n  /-- An ultrafilter is nontrivial. -/\n  protected neBot' : NeBot toFilter\n  /-- If `g` is a nontrivial filter that is less than or equal to an ultrafilter, then it is greater\n  than or equal to the ultrafilter. -/\n  protected le_of_le : âˆ€ g, Filter.NeBot g â†’ g â‰¤ toFilter â†’ toFilter â‰¤ g\n\n"}
{"name":"Ultrafilter.neBot'","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u_2\nself : Ultrafilter Î±\nâŠ¢ self.NeBot","decl":"/-- An ultrafilter is a minimal (maximal in the set order) proper filter. -/\nstructure Ultrafilter (Î± : Type*) extends Filter Î± where\n  /-- An ultrafilter is nontrivial. -/\n  protected neBot' : NeBot toFilter\n  /-- If `g` is a nontrivial filter that is less than or equal to an ultrafilter, then it is greater\n  than or equal to the ultrafilter. -/\n  protected le_of_le : âˆ€ g, Filter.NeBot g â†’ g â‰¤ toFilter â†’ toFilter â‰¤ g\n\n"}
{"name":"Ultrafilter.mk.sizeOf_spec","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u_2\ninstâœ : SizeOf Î±\ntoFilter : Filter Î±\nneBot' : toFilter.NeBot\nle_of_le : âˆ€ (g : Filter Î±), g.NeBot â†’ LE.le g toFilter â†’ LE.le toFilter g\nâŠ¢ Eq (SizeOf.sizeOf { toFilter := toFilter, neBot' := neBot', le_of_le := le_of_le }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toFilter)) (SizeOf.sizeOf neBot'))","decl":"/-- An ultrafilter is a minimal (maximal in the set order) proper filter. -/\nstructure Ultrafilter (Î± : Type*) extends Filter Î± where\n  /-- An ultrafilter is nontrivial. -/\n  protected neBot' : NeBot toFilter\n  /-- If `g` is a nontrivial filter that is less than or equal to an ultrafilter, then it is greater\n  than or equal to the ultrafilter. -/\n  protected le_of_le : âˆ€ g, Filter.NeBot g â†’ g â‰¤ toFilter â†’ toFilter â‰¤ g\n\n"}
{"name":"Ultrafilter.le_of_le","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u_2\nself : Ultrafilter Î±\ng : Filter Î±\naâœÂ¹ : g.NeBot\naâœ : LE.le g self.toFilter\nâŠ¢ LE.le self.toFilter g","decl":"/-- An ultrafilter is a minimal (maximal in the set order) proper filter. -/\nstructure Ultrafilter (Î± : Type*) extends Filter Î± where\n  /-- An ultrafilter is nontrivial. -/\n  protected neBot' : NeBot toFilter\n  /-- If `g` is a nontrivial filter that is less than or equal to an ultrafilter, then it is greater\n  than or equal to the ultrafilter. -/\n  protected le_of_le : âˆ€ g, Filter.NeBot g â†’ g â‰¤ toFilter â†’ toFilter â‰¤ g\n\n"}
{"name":"Ultrafilter.unique","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\ng : Filter Î±\nh : LE.le g â†‘f\nhne : autoParam g.NeBot _autoâœ\nâŠ¢ Eq g â†‘f","decl":"theorem unique (f : Ultrafilter Î±) {g : Filter Î±} (h : g â‰¤ f) (hne : NeBot g := by infer_instance) :\n    g = f :=\n  le_antisymm h <| f.le_of_le g hne h\n\n"}
{"name":"Ultrafilter.neBot","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\nâŠ¢ (â†‘f).NeBot","decl":"instance neBot (f : Ultrafilter Î±) : NeBot (f : Filter Î±) :=\n  f.neBot'\n\n"}
{"name":"Ultrafilter.isAtom","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\nâŠ¢ IsAtom â†‘f","decl":"protected theorem isAtom (f : Ultrafilter Î±) : IsAtom (f : Filter Î±) :=\n  âŸ¨f.neBot.ne, fun _ hgf => by_contra fun hg => hgf.ne <| f.unique hgf.le âŸ¨hgâŸ©âŸ©\n\n"}
{"name":"Ultrafilter.mem_coe","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\ns : Set Î±\nâŠ¢ Iff (Membership.mem (â†‘f) s) (Membership.mem f s)","decl":"@[simp, norm_cast]\ntheorem mem_coe : s âˆˆ (f : Filter Î±) â†” s âˆˆ f :=\n  Iff.rfl\n\n"}
{"name":"Ultrafilter.coe_injective","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nâŠ¢ Function.Injective Ultrafilter.toFilter","decl":"theorem coe_injective : Injective ((â†‘) : Ultrafilter Î± â†’ Filter Î±)\n  | âŸ¨f, hâ‚, hâ‚‚âŸ©, âŸ¨g, _, _âŸ©, _ => by congr\n\n"}
{"name":"Ultrafilter.eq_of_le","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf g : Ultrafilter Î±\nh : LE.le â†‘f â†‘g\nâŠ¢ Eq f g","decl":"theorem eq_of_le {f g : Ultrafilter Î±} (h : (f : Filter Î±) â‰¤ g) : f = g :=\n  coe_injective (g.unique h)\n\n"}
{"name":"Ultrafilter.coe_le_coe","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf g : Ultrafilter Î±\nâŠ¢ Iff (LE.le â†‘f â†‘g) (Eq f g)","decl":"@[simp, norm_cast]\ntheorem coe_le_coe {f g : Ultrafilter Î±} : (f : Filter Î±) â‰¤ g â†” f = g :=\n  âŸ¨fun h => eq_of_le h, fun h => h â–¸ le_rflâŸ©\n\n"}
{"name":"Ultrafilter.coe_inj","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf g : Ultrafilter Î±\nâŠ¢ Iff (Eq â†‘f â†‘g) (Eq f g)","decl":"@[simp, norm_cast]\ntheorem coe_inj : (f : Filter Î±) = g â†” f = g :=\n  coe_injective.eq_iff\n\n"}
{"name":"Ultrafilter.ext_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf g : Ultrafilter Î±\nâŠ¢ Iff (Eq f g) (âˆ€ (s : Set Î±), Iff (Membership.mem f s) (Membership.mem g s))","decl":"@[ext]\ntheorem ext â¦ƒf g : Ultrafilter Î±â¦„ (h : âˆ€ s, s âˆˆ f â†” s âˆˆ g) : f = g :=\n  coe_injective <| Filter.ext h\n\n"}
{"name":"Ultrafilter.ext","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf g : Ultrafilter Î±\nh : âˆ€ (s : Set Î±), Iff (Membership.mem f s) (Membership.mem g s)\nâŠ¢ Eq f g","decl":"@[ext]\ntheorem ext â¦ƒf g : Ultrafilter Î±â¦„ (h : âˆ€ s, s âˆˆ f â†” s âˆˆ g) : f = g :=\n  coe_injective <| Filter.ext h\n\n"}
{"name":"Ultrafilter.le_of_inf_neBot","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\ng : Filter Î±\nhg : (Min.min (â†‘f) g).NeBot\nâŠ¢ LE.le (â†‘f) g","decl":"theorem le_of_inf_neBot (f : Ultrafilter Î±) {g : Filter Î±} (hg : NeBot (â†‘f âŠ“ g)) : â†‘f â‰¤ g :=\n  le_of_inf_eq (f.unique inf_le_left hg)\n\n"}
{"name":"Ultrafilter.le_of_inf_neBot'","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\ng : Filter Î±\nhg : (Min.min g â†‘f).NeBot\nâŠ¢ LE.le (â†‘f) g","decl":"theorem le_of_inf_neBot' (f : Ultrafilter Î±) {g : Filter Î±} (hg : NeBot (g âŠ“ f)) : â†‘f â‰¤ g :=\n  f.le_of_inf_neBot <| by rwa [inf_comm]\n\n"}
{"name":"Ultrafilter.inf_neBot_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\ng : Filter Î±\nâŠ¢ Iff (Min.min (â†‘f) g).NeBot (LE.le (â†‘f) g)","decl":"theorem inf_neBot_iff {f : Ultrafilter Î±} {g : Filter Î±} : NeBot (â†‘f âŠ“ g) â†” â†‘f â‰¤ g :=\n  âŸ¨le_of_inf_neBot f, fun h => (inf_of_le_left h).symm â–¸ f.neBotâŸ©\n\n"}
{"name":"Ultrafilter.disjoint_iff_not_le","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\ng : Filter Î±\nâŠ¢ Iff (Disjoint (â†‘f) g) (Not (LE.le (â†‘f) g))","decl":"theorem disjoint_iff_not_le {f : Ultrafilter Î±} {g : Filter Î±} : Disjoint (â†‘f) g â†” Â¬â†‘f â‰¤ g := by\n  rw [â† inf_neBot_iff, neBot_iff, Ne, not_not, disjoint_iff]\n\n"}
{"name":"Ultrafilter.compl_not_mem_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\ns : Set Î±\nâŠ¢ Iff (Not (Membership.mem f (HasCompl.compl s))) (Membership.mem f s)","decl":"@[simp]\ntheorem compl_not_mem_iff : sá¶œ âˆ‰ f â†” s âˆˆ f :=\n  âŸ¨fun hsc =>\n    le_principal_iff.1 <|\n      f.le_of_inf_neBot âŸ¨fun h => hsc <| mem_of_eq_bot <| by rwa [compl_compl]âŸ©,\n    compl_not_memâŸ©\n\n"}
{"name":"Ultrafilter.frequently_iff_eventually","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\np : Î± â†’ Prop\nâŠ¢ Iff (Filter.Frequently (fun x => p x) â†‘f) (Filter.Eventually (fun x => p x) â†‘f)","decl":"@[simp]\ntheorem frequently_iff_eventually : (âˆƒá¶  x in f, p x) â†” âˆ€á¶  x in f, p x :=\n  compl_not_mem_iff\n\n"}
{"name":"Filter.Frequently.eventually","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\np : Î± â†’ Prop\naâœ : Filter.Frequently (fun x => p x) â†‘f\nâŠ¢ Filter.Eventually (fun x => p x) â†‘f","decl":"alias âŸ¨_root_.Filter.Frequently.eventually, _âŸ© := frequently_iff_eventually\n\n"}
{"name":"Ultrafilter.compl_mem_iff_not_mem","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\ns : Set Î±\nâŠ¢ Iff (Membership.mem f (HasCompl.compl s)) (Not (Membership.mem f s))","decl":"theorem compl_mem_iff_not_mem : sá¶œ âˆˆ f â†” s âˆ‰ f := by rw [â† compl_not_mem_iff, compl_compl]\n\n"}
{"name":"Ultrafilter.diff_mem_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\ns t : Set Î±\nf : Ultrafilter Î±\nâŠ¢ Iff (Membership.mem f (SDiff.sdiff s t)) (And (Membership.mem f s) (Not (Membership.mem f t)))","decl":"theorem diff_mem_iff (f : Ultrafilter Î±) : s \\ t âˆˆ f â†” s âˆˆ f âˆ§ t âˆ‰ f :=\n  inter_mem_iff.trans <| and_congr Iff.rfl compl_mem_iff_not_mem\n\n"}
{"name":"Ultrafilter.nonempty_of_mem","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\ns : Set Î±\nhs : Membership.mem f s\nâŠ¢ s.Nonempty","decl":"theorem nonempty_of_mem (hs : s âˆˆ f) : s.Nonempty :=\n  Filter.nonempty_of_mem hs\n\n"}
{"name":"Ultrafilter.ne_empty_of_mem","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\ns : Set Î±\nhs : Membership.mem f s\nâŠ¢ Ne s EmptyCollection.emptyCollection","decl":"theorem ne_empty_of_mem (hs : s âˆˆ f) : s â‰  âˆ… :=\n  (nonempty_of_mem hs).ne_empty\n\n"}
{"name":"Ultrafilter.empty_not_mem","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\nâŠ¢ Not (Membership.mem f EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem empty_not_mem : âˆ… âˆ‰ f :=\n  Filter.empty_not_mem (f : Filter Î±)\n\n"}
{"name":"Ultrafilter.le_sup_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nu : Ultrafilter Î±\nf g : Filter Î±\nâŠ¢ Iff (LE.le (â†‘u) (Max.max f g)) (Or (LE.le (â†‘u) f) (LE.le (â†‘u) g))","decl":"@[simp]\ntheorem le_sup_iff {u : Ultrafilter Î±} {f g : Filter Î±} : â†‘u â‰¤ f âŠ” g â†” â†‘u â‰¤ f âˆ¨ â†‘u â‰¤ g :=\n  not_iff_not.1 <| by simp only [â† disjoint_iff_not_le, not_or, disjoint_sup_right]\n\n"}
{"name":"Ultrafilter.union_mem_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\ns t : Set Î±\nâŠ¢ Iff (Membership.mem f (Union.union s t)) (Or (Membership.mem f s) (Membership.mem f t))","decl":"@[simp]\ntheorem union_mem_iff : s âˆª t âˆˆ f â†” s âˆˆ f âˆ¨ t âˆˆ f := by\n  simp only [â† mem_coe, â† le_principal_iff, â† sup_principal, le_sup_iff]\n\n"}
{"name":"Ultrafilter.mem_or_compl_mem","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\ns : Set Î±\nâŠ¢ Or (Membership.mem f s) (Membership.mem f (HasCompl.compl s))","decl":"theorem mem_or_compl_mem (f : Ultrafilter Î±) (s : Set Î±) : s âˆˆ f âˆ¨ sá¶œ âˆˆ f :=\n  or_iff_not_imp_left.2 compl_mem_iff_not_mem.2\n\n"}
{"name":"Ultrafilter.em","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\np : Î± â†’ Prop\nâŠ¢ Or (Filter.Eventually (fun x => p x) â†‘f) (Filter.Eventually (fun x => Not (p x)) â†‘f)","decl":"protected theorem em (f : Ultrafilter Î±) (p : Î± â†’ Prop) : (âˆ€á¶  x in f, p x) âˆ¨ âˆ€á¶  x in f, Â¬p x :=\n  f.mem_or_compl_mem { x | p x }\n\n"}
{"name":"Ultrafilter.eventually_or","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\np q : Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => Or (p x) (q x)) â†‘f) (Or (Filter.Eventually (fun x => p x) â†‘f) (Filter.Eventually (fun x => q x) â†‘f))","decl":"theorem eventually_or : (âˆ€á¶  x in f, p x âˆ¨ q x) â†” (âˆ€á¶  x in f, p x) âˆ¨ âˆ€á¶  x in f, q x :=\n  union_mem_iff\n\n"}
{"name":"Ultrafilter.eventually_not","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\np : Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => Not (p x)) â†‘f) (Not (Filter.Eventually (fun x => p x) â†‘f))","decl":"theorem eventually_not : (âˆ€á¶  x in f, Â¬p x) â†” Â¬âˆ€á¶  x in f, p x :=\n  compl_mem_iff_not_mem\n\n"}
{"name":"Ultrafilter.eventually_imp","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\np q : Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => p x â†’ q x) â†‘f) (Filter.Eventually (fun x => p x) â†‘f â†’ Filter.Eventually (fun x => q x) â†‘f)","decl":"theorem eventually_imp : (âˆ€á¶  x in f, p x â†’ q x) â†” (âˆ€á¶  x in f, p x) â†’ âˆ€á¶  x in f, q x := by\n  simp only [imp_iff_not_or, eventually_or, eventually_not]\n\n"}
{"name":"Ultrafilter.coe_map","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\nf : Ultrafilter Î±\nâŠ¢ Eq (â†‘(Ultrafilter.map m f)) (Filter.map m â†‘f)","decl":"@[simp, norm_cast]\ntheorem coe_map (m : Î± â†’ Î²) (f : Ultrafilter Î±) : (map m f : Filter Î²) = Filter.map m â†‘f :=\n  rfl\n\n"}
{"name":"Ultrafilter.mem_map","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\nf : Ultrafilter Î±\ns : Set Î²\nâŠ¢ Iff (Membership.mem (Ultrafilter.map m f) s) (Membership.mem f (Set.preimage m s))","decl":"@[simp]\ntheorem mem_map {m : Î± â†’ Î²} {f : Ultrafilter Î±} {s : Set Î²} : s âˆˆ map m f â†” m â»Â¹' s âˆˆ f :=\n  Iff.rfl\n\n"}
{"name":"Ultrafilter.map_id","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\nâŠ¢ Eq (Ultrafilter.map id f) f","decl":"@[simp]\nnonrec theorem map_id (f : Ultrafilter Î±) : f.map id = f :=\n  coe_injective map_id\n\n"}
{"name":"Ultrafilter.map_id'","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\nâŠ¢ Eq (Ultrafilter.map (fun x => x) f) f","decl":"@[simp]\ntheorem map_id' (f : Ultrafilter Î±) : (f.map fun x => x) = f :=\n  map_id _\n\n"}
{"name":"Ultrafilter.map_map","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type u_1\nf : Ultrafilter Î±\nm : Î± â†’ Î²\nn : Î² â†’ Î³\nâŠ¢ Eq (Ultrafilter.map n (Ultrafilter.map m f)) (Ultrafilter.map (Function.comp n m) f)","decl":"@[simp]\nnonrec theorem map_map (f : Ultrafilter Î±) (m : Î± â†’ Î²) (n : Î² â†’ Î³) :\n  (f.map m).map n = f.map (n âˆ˜ m) :=\n  coe_injective map_map\n\n"}
{"name":"Ultrafilter.mem_comap","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\nu : Ultrafilter Î²\ninj : Function.Injective m\nlarge : Membership.mem u (Set.range m)\ns : Set Î±\nâŠ¢ Iff (Membership.mem (u.comap inj large) s) (Membership.mem u (Set.image m s))","decl":"@[simp]\ntheorem mem_comap {m : Î± â†’ Î²} (u : Ultrafilter Î²) (inj : Injective m) (large : Set.range m âˆˆ u)\n    {s : Set Î±} : s âˆˆ u.comap inj large â†” m '' s âˆˆ u :=\n  mem_comap_iff inj large\n\n"}
{"name":"Ultrafilter.coe_comap","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\nu : Ultrafilter Î²\ninj : Function.Injective m\nlarge : Membership.mem u (Set.range m)\nâŠ¢ Eq (â†‘(u.comap inj large)) (Filter.comap m â†‘u)","decl":"@[simp, norm_cast]\ntheorem coe_comap {m : Î± â†’ Î²} (u : Ultrafilter Î²) (inj : Injective m) (large : Set.range m âˆˆ u) :\n    (u.comap inj large : Filter Î±) = Filter.comap m u :=\n  rfl\n\n"}
{"name":"Ultrafilter.comap_id","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\nhâ‚€ : optParam (Function.Injective id) â‹¯\nhâ‚ : optParam (Membership.mem f (Set.range id)) â‹¯\nâŠ¢ Eq (f.comap hâ‚€ hâ‚) f","decl":"@[simp]\nnonrec theorem comap_id (f : Ultrafilter Î±) (hâ‚€ : Injective (id : Î± â†’ Î±) := injective_id)\n    (hâ‚ : range id âˆˆ f := (by rw [range_id]; exact univ_mem)) :\n    f.comap hâ‚€ hâ‚ = f :=\n  coe_injective comap_id\n\n"}
{"name":"Ultrafilter.comap_comap","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type u_1\nf : Ultrafilter Î³\nm : Î± â†’ Î²\nn : Î² â†’ Î³\ninjâ‚€ : Function.Injective n\nlargeâ‚€ : Membership.mem f (Set.range n)\ninjâ‚ : Function.Injective m\nlargeâ‚ : Membership.mem (f.comap injâ‚€ largeâ‚€) (Set.range m)\ninjâ‚‚ : optParam (Function.Injective (Function.comp n m)) â‹¯\nlargeâ‚‚ : optParam (Membership.mem f (Set.range (Function.comp n m))) â‹¯\nâŠ¢ Eq ((f.comap injâ‚€ largeâ‚€).comap injâ‚ largeâ‚) (f.comap injâ‚‚ largeâ‚‚)","decl":"@[simp]\nnonrec theorem comap_comap (f : Ultrafilter Î³) {m : Î± â†’ Î²} {n : Î² â†’ Î³} (injâ‚€ : Injective n)\n    (largeâ‚€ : range n âˆˆ f) (injâ‚ : Injective m) (largeâ‚ : range m âˆˆ f.comap injâ‚€ largeâ‚€)\n    (injâ‚‚ : Injective (n âˆ˜ m) := injâ‚€.comp injâ‚)\n    (largeâ‚‚ : range (n âˆ˜ m) âˆˆ f :=\n      (by rw [range_comp]; exact image_mem_of_mem_comap largeâ‚€ largeâ‚)) :\n    (f.comap injâ‚€ largeâ‚€).comap injâ‚ largeâ‚ = f.comap injâ‚‚ largeâ‚‚ :=\n  coe_injective comap_comap\n\n"}
{"name":"Ultrafilter.mem_pure","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\na : Î±\ns : Set Î±\nâŠ¢ Iff (Membership.mem (Pure.pure a) s) (Membership.mem s a)","decl":"@[simp]\ntheorem mem_pure {a : Î±} {s : Set Î±} : s âˆˆ (pure a : Ultrafilter Î±) â†” a âˆˆ s :=\n  Iff.rfl\n\n"}
{"name":"Ultrafilter.coe_pure","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\na : Î±\nâŠ¢ Eq (â†‘(Pure.pure a)) (Pure.pure a)","decl":"@[simp]\ntheorem coe_pure (a : Î±) : â†‘(pure a : Ultrafilter Î±) = (pure a : Filter Î±) :=\n  rfl\n\n"}
{"name":"Ultrafilter.map_pure","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\na : Î±\nâŠ¢ Eq (Ultrafilter.map m (Pure.pure a)) (Pure.pure (m a))","decl":"@[simp]\ntheorem map_pure (m : Î± â†’ Î²) (a : Î±) : map m (pure a) = pure (m a) :=\n  rfl\n\n"}
{"name":"Ultrafilter.comap_pure","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\na : Î±\ninj : Function.Injective m\nlarge : Membership.mem (Pure.pure (m a)) (Set.range m)\nâŠ¢ Eq ((Pure.pure (m a)).comap inj large) (Pure.pure a)","decl":"@[simp]\ntheorem comap_pure {m : Î± â†’ Î²} (a : Î±) (inj : Injective m) (large) :\n    comap (pure <| m a) inj large = pure a :=\n  coe_injective <|\n    Filter.comap_pure.trans <| by\n      rw [coe_pure, â† principal_singleton, â† image_singleton, preimage_image_eq _ inj]\n\n"}
{"name":"Ultrafilter.pure_injective","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nâŠ¢ Function.Injective Pure.pure","decl":"theorem pure_injective : Injective (pure : Î± â†’ Ultrafilter Î±) := fun _ _ h =>\n  Filter.pure_injective (congr_arg Ultrafilter.toFilter h :)\n\n"}
{"name":"Ultrafilter.instNonempty","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\ninstâœ : Nonempty Î±\nâŠ¢ Nonempty (Ultrafilter Î±)","decl":"instance [Nonempty Î±] : Nonempty (Ultrafilter Î±) :=\n  Nonempty.map pure inferInstance\n\n"}
{"name":"Ultrafilter.lawfulMonad","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"âŠ¢ LawfulMonad Ultrafilter","decl":"instance lawfulMonad : LawfulMonad Ultrafilter where\n  id_map f := coe_injective (id_map f.toFilter)\n  pure_bind a f := coe_injective (Filter.pure_bind a ((Ultrafilter.toFilter) âˆ˜ f))\n  bind_assoc _ _ _ := coe_injective (filter_eq rfl)\n  bind_pure_comp f x := coe_injective (bind_pure_comp f x.1)\n  map_const := rfl\n  seqLeft_eq _ _ := rfl\n  seqRight_eq _ _ := rfl\n  pure_seq _ _ := rfl\n  bind_map _ _ := rfl\n\n"}
{"name":"Ultrafilter.exists_le","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Filter Î±\nh : f.NeBot\nâŠ¢ Exists fun u => LE.le (â†‘u) f","decl":"/-- The ultrafilter lemma: Any proper filter is contained in an ultrafilter. -/\ntheorem exists_le (f : Filter Î±) [h : NeBot f] : âˆƒ u : Ultrafilter Î±, â†‘u â‰¤ f :=\n  let âŸ¨u, hu, hufâŸ© := (eq_bot_or_exists_atom_le f).resolve_left h.ne\n  âŸ¨ofAtom u hu, hufâŸ©\n\n"}
{"name":"Filter.exists_ultrafilter_le","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Filter Î±\nh : f.NeBot\nâŠ¢ Exists fun u => LE.le (â†‘u) f","decl":"alias _root_.Filter.exists_ultrafilter_le := exists_le\n\n"}
{"name":"Ultrafilter.of_le","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Filter Î±\ninstâœ : f.NeBot\nâŠ¢ LE.le (â†‘(Ultrafilter.of f)) f","decl":"theorem of_le (f : Filter Î±) [NeBot f] : â†‘(of f) â‰¤ f :=\n  Classical.choose_spec (exists_le f)\n\n"}
{"name":"Ultrafilter.of_coe","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Ultrafilter Î±\nâŠ¢ Eq (Ultrafilter.of â†‘f) f","decl":"theorem of_coe (f : Ultrafilter Î±) : of â†‘f = f :=\n  coe_inj.1 <| f.unique (of_le f.toFilter)\n\n"}
{"name":"Filter.isAtom_pure","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\na : Î±\nâŠ¢ IsAtom (Pure.pure a)","decl":"theorem isAtom_pure : IsAtom (pure a : Filter Î±) :=\n  (pure a : Ultrafilter Î±).isAtom\n\n"}
{"name":"Filter.NeBot.le_pure_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Filter Î±\na : Î±\nhf : f.NeBot\nâŠ¢ Iff (LE.le f (Pure.pure a)) (Eq f (Pure.pure a))","decl":"protected theorem NeBot.le_pure_iff (hf : f.NeBot) : f â‰¤ pure a â†” f = pure a :=\n  âŸ¨Ultrafilter.unique (pure a), le_of_eqâŸ©\n\n"}
{"name":"Filter.NeBot.eq_pure_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Filter Î±\nhf : f.NeBot\nx : Î±\nâŠ¢ Iff (Eq f (Pure.pure x)) (Membership.mem f (Singleton.singleton x))","decl":"protected theorem NeBot.eq_pure_iff (hf : f.NeBot) {x : Î±} :\n    f = pure x â†” {x} âˆˆ f := by\n  rw [â† hf.le_pure_iff, le_pure_iff]\n\n"}
{"name":"Filter.lt_pure_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Filter Î±\na : Î±\nâŠ¢ Iff (LT.lt f (Pure.pure a)) (Eq f Bot.bot)","decl":"@[simp]\ntheorem lt_pure_iff : f < pure a â†” f = âŠ¥ :=\n  isAtom_pure.lt_iff\n\n"}
{"name":"Filter.le_pure_iff'","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Filter Î±\na : Î±\nâŠ¢ Iff (LE.le f (Pure.pure a)) (Or (Eq f Bot.bot) (Eq f (Pure.pure a)))","decl":"theorem le_pure_iff' : f â‰¤ pure a â†” f = âŠ¥ âˆ¨ f = pure a :=\n  isAtom_pure.le_iff\n\n"}
{"name":"Filter.Iic_pure","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\na : Î±\nâŠ¢ Eq (Set.Iic (Pure.pure a)) (Insert.insert Bot.bot (Singleton.singleton (Pure.pure a)))","decl":"@[simp]\ntheorem Iic_pure (a : Î±) : Iic (pure a : Filter Î±) = {âŠ¥, pure a} :=\n  isAtom_pure.Iic_eq\n\n"}
{"name":"Filter.mem_iff_ultrafilter","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Filter Î±\ns : Set Î±\nâŠ¢ Iff (Membership.mem f s) (âˆ€ (g : Ultrafilter Î±), LE.le (â†‘g) f â†’ Membership.mem g s)","decl":"theorem mem_iff_ultrafilter : s âˆˆ f â†” âˆ€ g : Ultrafilter Î±, â†‘g â‰¤ f â†’ s âˆˆ g := by\n  refine âŸ¨fun hf g hg => hg hf, fun H => by_contra fun hf => ?_âŸ©\n  set g : Filter (sá¶œ : Set Î±) := comap (â†‘) f\n  haveI : NeBot g := comap_neBot_iff_compl_range.2 (by simpa [compl_setOf] )\n  simpa using H ((of g).map (â†‘)) (map_le_iff_le_comap.mpr (of_le g))\n\n"}
{"name":"Filter.le_iff_ultrafilter","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nfâ‚ fâ‚‚ : Filter Î±\nâŠ¢ Iff (LE.le fâ‚ fâ‚‚) (âˆ€ (g : Ultrafilter Î±), LE.le (â†‘g) fâ‚ â†’ LE.le (â†‘g) fâ‚‚)","decl":"theorem le_iff_ultrafilter {fâ‚ fâ‚‚ : Filter Î±} : fâ‚ â‰¤ fâ‚‚ â†” âˆ€ g : Ultrafilter Î±, â†‘g â‰¤ fâ‚ â†’ â†‘g â‰¤ fâ‚‚ :=\n  âŸ¨fun h _ hâ‚ => hâ‚.trans h, fun h _ hs => mem_iff_ultrafilter.2 fun g hg => h g hg hsâŸ©\n\n"}
{"name":"Filter.iSup_ultrafilter_le_eq","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Filter Î±\nâŠ¢ Eq (iSup fun g => iSup fun x => â†‘g) f","decl":"/-- A filter equals the intersection of all the ultrafilters which contain it. -/\ntheorem iSup_ultrafilter_le_eq (f : Filter Î±) :\n    â¨† (g : Ultrafilter Î±) (_ : g â‰¤ f), (g : Filter Î±) = f :=\n  eq_of_forall_ge_iff fun f' => by simp only [iSup_le_iff, â† le_iff_ultrafilter]\n\n"}
{"name":"Filter.exists_ultrafilter_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nf : Filter Î±\nâŠ¢ Iff (Exists fun u => LE.le (â†‘u) f) f.NeBot","decl":"theorem exists_ultrafilter_iff {f : Filter Î±} : (âˆƒ u : Ultrafilter Î±, â†‘u â‰¤ f) â†” NeBot f :=\n  âŸ¨fun âŸ¨_, ufâŸ© => neBot_of_le uf, fun h => @exists_ultrafilter_le _ _ hâŸ©\n\n"}
{"name":"Filter.forall_neBot_le_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\ng : Filter Î±\np : Filter Î± â†’ Prop\nhp : Monotone p\nâŠ¢ Iff (âˆ€ (f : Filter Î±), f.NeBot â†’ LE.le f g â†’ p f) (âˆ€ (f : Ultrafilter Î±), LE.le (â†‘f) g â†’ p â†‘f)","decl":"theorem forall_neBot_le_iff {g : Filter Î±} {p : Filter Î± â†’ Prop} (hp : Monotone p) :\n    (âˆ€ f : Filter Î±, NeBot f â†’ f â‰¤ g â†’ p f) â†” âˆ€ f : Ultrafilter Î±, â†‘f â‰¤ g â†’ p f := by\n  refine âŸ¨fun H f hf => H f f.neBot hf, ?_âŸ©\n  intro H f hf hfg\n  exact hp (of_le f) (H _ ((of_le f).trans hfg))\n\n"}
{"name":"Ultrafilter.comap_inf_principal_neBot_of_image_mem","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\ns : Set Î±\ng : Ultrafilter Î²\nh : Membership.mem g (Set.image m s)\nâŠ¢ (Min.min (Filter.comap m â†‘g) (Filter.principal s)).NeBot","decl":"theorem comap_inf_principal_neBot_of_image_mem (h : m '' s âˆˆ g) : (Filter.comap m g âŠ“ ğ“Ÿ s).NeBot :=\n  Filter.comap_inf_principal_neBot_of_image_mem g.neBot h\n\n"}
{"name":"Ultrafilter.ofComapInfPrincipal_mem","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\ns : Set Î±\ng : Ultrafilter Î²\nh : Membership.mem g (Set.image m s)\nâŠ¢ Membership.mem (Ultrafilter.ofComapInfPrincipal h) s","decl":"theorem ofComapInfPrincipal_mem (h : m '' s âˆˆ g) : s âˆˆ ofComapInfPrincipal h := by\n  let f := Filter.comap m g âŠ“ ğ“Ÿ s\n  haveI : f.NeBot := comap_inf_principal_neBot_of_image_mem h\n  have : s âˆˆ f := mem_inf_of_right (mem_principal_self s)\n  exact le_def.mp (of_le _) s this\n\n"}
{"name":"Ultrafilter.ofComapInfPrincipal_eq_of_map","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\ns : Set Î±\ng : Ultrafilter Î²\nh : Membership.mem g (Set.image m s)\nâŠ¢ Eq (Ultrafilter.map m (Ultrafilter.ofComapInfPrincipal h)) g","decl":"theorem ofComapInfPrincipal_eq_of_map (h : m '' s âˆˆ g) : (ofComapInfPrincipal h).map m = g := by\n  let f := Filter.comap m g âŠ“ ğ“Ÿ s\n  haveI : f.NeBot := comap_inf_principal_neBot_of_image_mem h\n  apply eq_of_le\n  calc\n    Filter.map m (of f) â‰¤ Filter.map m f := map_mono (of_le _)\n    _ â‰¤ (Filter.map m <| Filter.comap m g) âŠ“ Filter.map m (ğ“Ÿ s) := map_inf_le\n    _ = (Filter.map m <| Filter.comap m g) âŠ“ (ğ“Ÿ <| m '' s) := by rw [map_principal]\n    _ â‰¤ â†‘g âŠ“ (ğ“Ÿ <| m '' s) := inf_le_inf_right _ map_comap_le\n    _ = â†‘g := inf_of_le_left (le_principal_iff.mpr h)\n\n"}
{"name":"Ultrafilter.eq_of_le_pure","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"X : Type u_2\nÎ± : Filter X\nhÎ± : Î±.NeBot\nx y : X\nhx : LE.le Î± (Pure.pure x)\nhy : LE.le Î± (Pure.pure y)\nâŠ¢ Eq x y","decl":"theorem eq_of_le_pure {X : Type _} {Î± : Filter X} (hÎ± : Î±.NeBot) {x y : X}\n    (hx : Î± â‰¤ pure x) (hy : Î± â‰¤ pure y) : x = y :=\n  Filter.pure_injective (hÎ±.le_pure_iff.mp hx â–¸ hÎ±.le_pure_iff.mp hy)\n\n"}
