{"name":"instIsAtomicFilter","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\n⊢ IsAtomic (Filter α)","decl":"/-- `Filter α` is an atomic type: for every filter there exists an ultrafilter that is less than or\nequal to this filter. -/\ninstance : IsAtomic (Filter α) :=\n  IsAtomic.of_isChain_bounded fun c hc hne hb =>\n    ⟨sInf c, (sInf_neBot_of_directed' hne (show IsChain (· ≥ ·) c from hc.symm).directedOn hb).ne,\n      fun _ hx => sInf_le hx⟩\n\n"}
{"name":"Ultrafilter.mk.injEq","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u_2\ntoFilter✝ : Filter α\nneBot'✝ : toFilter✝.NeBot\nle_of_le✝ : ∀ (g : Filter α), g.NeBot → LE.le g toFilter✝ → LE.le toFilter✝ g\ntoFilter : Filter α\nneBot' : toFilter.NeBot\nle_of_le : ∀ (g : Filter α), g.NeBot → LE.le g toFilter → LE.le toFilter g\n⊢ Eq (Eq { toFilter := toFilter✝, neBot' := neBot'✝, le_of_le := le_of_le✝ } { toFilter := toFilter, neBot' := neBot', le_of_le := le_of_le }) (Eq toFilter✝ toFilter)","decl":"/-- An ultrafilter is a minimal (maximal in the set order) proper filter. -/\nstructure Ultrafilter (α : Type*) extends Filter α where\n  /-- An ultrafilter is nontrivial. -/\n  protected neBot' : NeBot toFilter\n  /-- If `g` is a nontrivial filter that is less than or equal to an ultrafilter, then it is greater\n  than or equal to the ultrafilter. -/\n  protected le_of_le : ∀ g, Filter.NeBot g → g ≤ toFilter → toFilter ≤ g\n\n"}
{"name":"Ultrafilter.mk.inj","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u_2\ntoFilter✝ : Filter α\nneBot'✝ : toFilter✝.NeBot\nle_of_le✝ : ∀ (g : Filter α), g.NeBot → LE.le g toFilter✝ → LE.le toFilter✝ g\ntoFilter : Filter α\nneBot' : toFilter.NeBot\nle_of_le : ∀ (g : Filter α), g.NeBot → LE.le g toFilter → LE.le toFilter g\nx✝ : Eq { toFilter := toFilter✝, neBot' := neBot'✝, le_of_le := le_of_le✝ } { toFilter := toFilter, neBot' := neBot', le_of_le := le_of_le }\n⊢ Eq toFilter✝ toFilter","decl":"/-- An ultrafilter is a minimal (maximal in the set order) proper filter. -/\nstructure Ultrafilter (α : Type*) extends Filter α where\n  /-- An ultrafilter is nontrivial. -/\n  protected neBot' : NeBot toFilter\n  /-- If `g` is a nontrivial filter that is less than or equal to an ultrafilter, then it is greater\n  than or equal to the ultrafilter. -/\n  protected le_of_le : ∀ g, Filter.NeBot g → g ≤ toFilter → toFilter ≤ g\n\n"}
{"name":"Ultrafilter.neBot'","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u_2\nself : Ultrafilter α\n⊢ self.NeBot","decl":"/-- An ultrafilter is a minimal (maximal in the set order) proper filter. -/\nstructure Ultrafilter (α : Type*) extends Filter α where\n  /-- An ultrafilter is nontrivial. -/\n  protected neBot' : NeBot toFilter\n  /-- If `g` is a nontrivial filter that is less than or equal to an ultrafilter, then it is greater\n  than or equal to the ultrafilter. -/\n  protected le_of_le : ∀ g, Filter.NeBot g → g ≤ toFilter → toFilter ≤ g\n\n"}
{"name":"Ultrafilter.mk.sizeOf_spec","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u_2\ninst✝ : SizeOf α\ntoFilter : Filter α\nneBot' : toFilter.NeBot\nle_of_le : ∀ (g : Filter α), g.NeBot → LE.le g toFilter → LE.le toFilter g\n⊢ Eq (SizeOf.sizeOf { toFilter := toFilter, neBot' := neBot', le_of_le := le_of_le }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toFilter)) (SizeOf.sizeOf neBot'))","decl":"/-- An ultrafilter is a minimal (maximal in the set order) proper filter. -/\nstructure Ultrafilter (α : Type*) extends Filter α where\n  /-- An ultrafilter is nontrivial. -/\n  protected neBot' : NeBot toFilter\n  /-- If `g` is a nontrivial filter that is less than or equal to an ultrafilter, then it is greater\n  than or equal to the ultrafilter. -/\n  protected le_of_le : ∀ g, Filter.NeBot g → g ≤ toFilter → toFilter ≤ g\n\n"}
{"name":"Ultrafilter.le_of_le","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u_2\nself : Ultrafilter α\ng : Filter α\na✝¹ : g.NeBot\na✝ : LE.le g self.toFilter\n⊢ LE.le self.toFilter g","decl":"/-- An ultrafilter is a minimal (maximal in the set order) proper filter. -/\nstructure Ultrafilter (α : Type*) extends Filter α where\n  /-- An ultrafilter is nontrivial. -/\n  protected neBot' : NeBot toFilter\n  /-- If `g` is a nontrivial filter that is less than or equal to an ultrafilter, then it is greater\n  than or equal to the ultrafilter. -/\n  protected le_of_le : ∀ g, Filter.NeBot g → g ≤ toFilter → toFilter ≤ g\n\n"}
{"name":"Ultrafilter.unique","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\ng : Filter α\nh : LE.le g ↑f\nhne : autoParam g.NeBot _auto✝\n⊢ Eq g ↑f","decl":"theorem unique (f : Ultrafilter α) {g : Filter α} (h : g ≤ f) (hne : NeBot g := by infer_instance) :\n    g = f :=\n  le_antisymm h <| f.le_of_le g hne h\n\n"}
{"name":"Ultrafilter.neBot","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\n⊢ (↑f).NeBot","decl":"instance neBot (f : Ultrafilter α) : NeBot (f : Filter α) :=\n  f.neBot'\n\n"}
{"name":"Ultrafilter.isAtom","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\n⊢ IsAtom ↑f","decl":"protected theorem isAtom (f : Ultrafilter α) : IsAtom (f : Filter α) :=\n  ⟨f.neBot.ne, fun _ hgf => by_contra fun hg => hgf.ne <| f.unique hgf.le ⟨hg⟩⟩\n\n"}
{"name":"Ultrafilter.mem_coe","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\ns : Set α\n⊢ Iff (Membership.mem (↑f) s) (Membership.mem f s)","decl":"@[simp, norm_cast]\ntheorem mem_coe : s ∈ (f : Filter α) ↔ s ∈ f :=\n  Iff.rfl\n\n"}
{"name":"Ultrafilter.coe_injective","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\n⊢ Function.Injective Ultrafilter.toFilter","decl":"theorem coe_injective : Injective ((↑) : Ultrafilter α → Filter α)\n  | ⟨f, h₁, h₂⟩, ⟨g, _, _⟩, _ => by congr\n\n"}
{"name":"Ultrafilter.eq_of_le","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf g : Ultrafilter α\nh : LE.le ↑f ↑g\n⊢ Eq f g","decl":"theorem eq_of_le {f g : Ultrafilter α} (h : (f : Filter α) ≤ g) : f = g :=\n  coe_injective (g.unique h)\n\n"}
{"name":"Ultrafilter.coe_le_coe","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf g : Ultrafilter α\n⊢ Iff (LE.le ↑f ↑g) (Eq f g)","decl":"@[simp, norm_cast]\ntheorem coe_le_coe {f g : Ultrafilter α} : (f : Filter α) ≤ g ↔ f = g :=\n  ⟨fun h => eq_of_le h, fun h => h ▸ le_rfl⟩\n\n"}
{"name":"Ultrafilter.coe_inj","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf g : Ultrafilter α\n⊢ Iff (Eq ↑f ↑g) (Eq f g)","decl":"@[simp, norm_cast]\ntheorem coe_inj : (f : Filter α) = g ↔ f = g :=\n  coe_injective.eq_iff\n\n"}
{"name":"Ultrafilter.ext_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf g : Ultrafilter α\n⊢ Iff (Eq f g) (∀ (s : Set α), Iff (Membership.mem f s) (Membership.mem g s))","decl":"@[ext]\ntheorem ext ⦃f g : Ultrafilter α⦄ (h : ∀ s, s ∈ f ↔ s ∈ g) : f = g :=\n  coe_injective <| Filter.ext h\n\n"}
{"name":"Ultrafilter.ext","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf g : Ultrafilter α\nh : ∀ (s : Set α), Iff (Membership.mem f s) (Membership.mem g s)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext ⦃f g : Ultrafilter α⦄ (h : ∀ s, s ∈ f ↔ s ∈ g) : f = g :=\n  coe_injective <| Filter.ext h\n\n"}
{"name":"Ultrafilter.le_of_inf_neBot","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\ng : Filter α\nhg : (Min.min (↑f) g).NeBot\n⊢ LE.le (↑f) g","decl":"theorem le_of_inf_neBot (f : Ultrafilter α) {g : Filter α} (hg : NeBot (↑f ⊓ g)) : ↑f ≤ g :=\n  le_of_inf_eq (f.unique inf_le_left hg)\n\n"}
{"name":"Ultrafilter.le_of_inf_neBot'","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\ng : Filter α\nhg : (Min.min g ↑f).NeBot\n⊢ LE.le (↑f) g","decl":"theorem le_of_inf_neBot' (f : Ultrafilter α) {g : Filter α} (hg : NeBot (g ⊓ f)) : ↑f ≤ g :=\n  f.le_of_inf_neBot <| by rwa [inf_comm]\n\n"}
{"name":"Ultrafilter.inf_neBot_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\ng : Filter α\n⊢ Iff (Min.min (↑f) g).NeBot (LE.le (↑f) g)","decl":"theorem inf_neBot_iff {f : Ultrafilter α} {g : Filter α} : NeBot (↑f ⊓ g) ↔ ↑f ≤ g :=\n  ⟨le_of_inf_neBot f, fun h => (inf_of_le_left h).symm ▸ f.neBot⟩\n\n"}
{"name":"Ultrafilter.disjoint_iff_not_le","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\ng : Filter α\n⊢ Iff (Disjoint (↑f) g) (Not (LE.le (↑f) g))","decl":"theorem disjoint_iff_not_le {f : Ultrafilter α} {g : Filter α} : Disjoint (↑f) g ↔ ¬↑f ≤ g := by\n  rw [← inf_neBot_iff, neBot_iff, Ne, not_not, disjoint_iff]\n\n"}
{"name":"Ultrafilter.compl_not_mem_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\ns : Set α\n⊢ Iff (Not (Membership.mem f (HasCompl.compl s))) (Membership.mem f s)","decl":"@[simp]\ntheorem compl_not_mem_iff : sᶜ ∉ f ↔ s ∈ f :=\n  ⟨fun hsc =>\n    le_principal_iff.1 <|\n      f.le_of_inf_neBot ⟨fun h => hsc <| mem_of_eq_bot <| by rwa [compl_compl]⟩,\n    compl_not_mem⟩\n\n"}
{"name":"Ultrafilter.frequently_iff_eventually","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\np : α → Prop\n⊢ Iff (Filter.Frequently (fun x => p x) ↑f) (Filter.Eventually (fun x => p x) ↑f)","decl":"@[simp]\ntheorem frequently_iff_eventually : (∃ᶠ x in f, p x) ↔ ∀ᶠ x in f, p x :=\n  compl_not_mem_iff\n\n"}
{"name":"Filter.Frequently.eventually","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\np : α → Prop\na✝ : Filter.Frequently (fun x => p x) ↑f\n⊢ Filter.Eventually (fun x => p x) ↑f","decl":"alias ⟨_root_.Filter.Frequently.eventually, _⟩ := frequently_iff_eventually\n\n"}
{"name":"Ultrafilter.compl_mem_iff_not_mem","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\ns : Set α\n⊢ Iff (Membership.mem f (HasCompl.compl s)) (Not (Membership.mem f s))","decl":"theorem compl_mem_iff_not_mem : sᶜ ∈ f ↔ s ∉ f := by rw [← compl_not_mem_iff, compl_compl]\n\n"}
{"name":"Ultrafilter.diff_mem_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\ns t : Set α\nf : Ultrafilter α\n⊢ Iff (Membership.mem f (SDiff.sdiff s t)) (And (Membership.mem f s) (Not (Membership.mem f t)))","decl":"theorem diff_mem_iff (f : Ultrafilter α) : s \\ t ∈ f ↔ s ∈ f ∧ t ∉ f :=\n  inter_mem_iff.trans <| and_congr Iff.rfl compl_mem_iff_not_mem\n\n"}
{"name":"Ultrafilter.nonempty_of_mem","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\ns : Set α\nhs : Membership.mem f s\n⊢ s.Nonempty","decl":"theorem nonempty_of_mem (hs : s ∈ f) : s.Nonempty :=\n  Filter.nonempty_of_mem hs\n\n"}
{"name":"Ultrafilter.ne_empty_of_mem","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\ns : Set α\nhs : Membership.mem f s\n⊢ Ne s EmptyCollection.emptyCollection","decl":"theorem ne_empty_of_mem (hs : s ∈ f) : s ≠ ∅ :=\n  (nonempty_of_mem hs).ne_empty\n\n"}
{"name":"Ultrafilter.empty_not_mem","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\n⊢ Not (Membership.mem f EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem empty_not_mem : ∅ ∉ f :=\n  Filter.empty_not_mem (f : Filter α)\n\n"}
{"name":"Ultrafilter.le_sup_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nu : Ultrafilter α\nf g : Filter α\n⊢ Iff (LE.le (↑u) (Max.max f g)) (Or (LE.le (↑u) f) (LE.le (↑u) g))","decl":"@[simp]\ntheorem le_sup_iff {u : Ultrafilter α} {f g : Filter α} : ↑u ≤ f ⊔ g ↔ ↑u ≤ f ∨ ↑u ≤ g :=\n  not_iff_not.1 <| by simp only [← disjoint_iff_not_le, not_or, disjoint_sup_right]\n\n"}
{"name":"Ultrafilter.union_mem_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\ns t : Set α\n⊢ Iff (Membership.mem f (Union.union s t)) (Or (Membership.mem f s) (Membership.mem f t))","decl":"@[simp]\ntheorem union_mem_iff : s ∪ t ∈ f ↔ s ∈ f ∨ t ∈ f := by\n  simp only [← mem_coe, ← le_principal_iff, ← sup_principal, le_sup_iff]\n\n"}
{"name":"Ultrafilter.mem_or_compl_mem","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\ns : Set α\n⊢ Or (Membership.mem f s) (Membership.mem f (HasCompl.compl s))","decl":"theorem mem_or_compl_mem (f : Ultrafilter α) (s : Set α) : s ∈ f ∨ sᶜ ∈ f :=\n  or_iff_not_imp_left.2 compl_mem_iff_not_mem.2\n\n"}
{"name":"Ultrafilter.em","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\np : α → Prop\n⊢ Or (Filter.Eventually (fun x => p x) ↑f) (Filter.Eventually (fun x => Not (p x)) ↑f)","decl":"protected theorem em (f : Ultrafilter α) (p : α → Prop) : (∀ᶠ x in f, p x) ∨ ∀ᶠ x in f, ¬p x :=\n  f.mem_or_compl_mem { x | p x }\n\n"}
{"name":"Ultrafilter.eventually_or","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\np q : α → Prop\n⊢ Iff (Filter.Eventually (fun x => Or (p x) (q x)) ↑f) (Or (Filter.Eventually (fun x => p x) ↑f) (Filter.Eventually (fun x => q x) ↑f))","decl":"theorem eventually_or : (∀ᶠ x in f, p x ∨ q x) ↔ (∀ᶠ x in f, p x) ∨ ∀ᶠ x in f, q x :=\n  union_mem_iff\n\n"}
{"name":"Ultrafilter.eventually_not","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\np : α → Prop\n⊢ Iff (Filter.Eventually (fun x => Not (p x)) ↑f) (Not (Filter.Eventually (fun x => p x) ↑f))","decl":"theorem eventually_not : (∀ᶠ x in f, ¬p x) ↔ ¬∀ᶠ x in f, p x :=\n  compl_mem_iff_not_mem\n\n"}
{"name":"Ultrafilter.eventually_imp","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\np q : α → Prop\n⊢ Iff (Filter.Eventually (fun x => p x → q x) ↑f) (Filter.Eventually (fun x => p x) ↑f → Filter.Eventually (fun x => q x) ↑f)","decl":"theorem eventually_imp : (∀ᶠ x in f, p x → q x) ↔ (∀ᶠ x in f, p x) → ∀ᶠ x in f, q x := by\n  simp only [imp_iff_not_or, eventually_or, eventually_not]\n\n"}
{"name":"Ultrafilter.coe_map","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nβ : Type v\nm : α → β\nf : Ultrafilter α\n⊢ Eq (↑(Ultrafilter.map m f)) (Filter.map m ↑f)","decl":"@[simp, norm_cast]\ntheorem coe_map (m : α → β) (f : Ultrafilter α) : (map m f : Filter β) = Filter.map m ↑f :=\n  rfl\n\n"}
{"name":"Ultrafilter.mem_map","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nβ : Type v\nm : α → β\nf : Ultrafilter α\ns : Set β\n⊢ Iff (Membership.mem (Ultrafilter.map m f) s) (Membership.mem f (Set.preimage m s))","decl":"@[simp]\ntheorem mem_map {m : α → β} {f : Ultrafilter α} {s : Set β} : s ∈ map m f ↔ m ⁻¹' s ∈ f :=\n  Iff.rfl\n\n"}
{"name":"Ultrafilter.map_id","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\n⊢ Eq (Ultrafilter.map id f) f","decl":"@[simp]\nnonrec theorem map_id (f : Ultrafilter α) : f.map id = f :=\n  coe_injective map_id\n\n"}
{"name":"Ultrafilter.map_id'","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\n⊢ Eq (Ultrafilter.map (fun x => x) f) f","decl":"@[simp]\ntheorem map_id' (f : Ultrafilter α) : (f.map fun x => x) = f :=\n  map_id _\n\n"}
{"name":"Ultrafilter.map_map","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\nf : Ultrafilter α\nm : α → β\nn : β → γ\n⊢ Eq (Ultrafilter.map n (Ultrafilter.map m f)) (Ultrafilter.map (Function.comp n m) f)","decl":"@[simp]\nnonrec theorem map_map (f : Ultrafilter α) (m : α → β) (n : β → γ) :\n  (f.map m).map n = f.map (n ∘ m) :=\n  coe_injective map_map\n\n"}
{"name":"Ultrafilter.mem_comap","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nβ : Type v\nm : α → β\nu : Ultrafilter β\ninj : Function.Injective m\nlarge : Membership.mem u (Set.range m)\ns : Set α\n⊢ Iff (Membership.mem (u.comap inj large) s) (Membership.mem u (Set.image m s))","decl":"@[simp]\ntheorem mem_comap {m : α → β} (u : Ultrafilter β) (inj : Injective m) (large : Set.range m ∈ u)\n    {s : Set α} : s ∈ u.comap inj large ↔ m '' s ∈ u :=\n  mem_comap_iff inj large\n\n"}
{"name":"Ultrafilter.coe_comap","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nβ : Type v\nm : α → β\nu : Ultrafilter β\ninj : Function.Injective m\nlarge : Membership.mem u (Set.range m)\n⊢ Eq (↑(u.comap inj large)) (Filter.comap m ↑u)","decl":"@[simp, norm_cast]\ntheorem coe_comap {m : α → β} (u : Ultrafilter β) (inj : Injective m) (large : Set.range m ∈ u) :\n    (u.comap inj large : Filter α) = Filter.comap m u :=\n  rfl\n\n"}
{"name":"Ultrafilter.comap_id","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\nh₀ : optParam (Function.Injective id) ⋯\nh₁ : optParam (Membership.mem f (Set.range id)) ⋯\n⊢ Eq (f.comap h₀ h₁) f","decl":"@[simp]\nnonrec theorem comap_id (f : Ultrafilter α) (h₀ : Injective (id : α → α) := injective_id)\n    (h₁ : range id ∈ f := (by rw [range_id]; exact univ_mem)) :\n    f.comap h₀ h₁ = f :=\n  coe_injective comap_id\n\n"}
{"name":"Ultrafilter.comap_comap","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\nf : Ultrafilter γ\nm : α → β\nn : β → γ\ninj₀ : Function.Injective n\nlarge₀ : Membership.mem f (Set.range n)\ninj₁ : Function.Injective m\nlarge₁ : Membership.mem (f.comap inj₀ large₀) (Set.range m)\ninj₂ : optParam (Function.Injective (Function.comp n m)) ⋯\nlarge₂ : optParam (Membership.mem f (Set.range (Function.comp n m))) ⋯\n⊢ Eq ((f.comap inj₀ large₀).comap inj₁ large₁) (f.comap inj₂ large₂)","decl":"@[simp]\nnonrec theorem comap_comap (f : Ultrafilter γ) {m : α → β} {n : β → γ} (inj₀ : Injective n)\n    (large₀ : range n ∈ f) (inj₁ : Injective m) (large₁ : range m ∈ f.comap inj₀ large₀)\n    (inj₂ : Injective (n ∘ m) := inj₀.comp inj₁)\n    (large₂ : range (n ∘ m) ∈ f :=\n      (by rw [range_comp]; exact image_mem_of_mem_comap large₀ large₁)) :\n    (f.comap inj₀ large₀).comap inj₁ large₁ = f.comap inj₂ large₂ :=\n  coe_injective comap_comap\n\n"}
{"name":"Ultrafilter.mem_pure","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ Iff (Membership.mem (Pure.pure a) s) (Membership.mem s a)","decl":"@[simp]\ntheorem mem_pure {a : α} {s : Set α} : s ∈ (pure a : Ultrafilter α) ↔ a ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Ultrafilter.coe_pure","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\na : α\n⊢ Eq (↑(Pure.pure a)) (Pure.pure a)","decl":"@[simp]\ntheorem coe_pure (a : α) : ↑(pure a : Ultrafilter α) = (pure a : Filter α) :=\n  rfl\n\n"}
{"name":"Ultrafilter.map_pure","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nβ : Type v\nm : α → β\na : α\n⊢ Eq (Ultrafilter.map m (Pure.pure a)) (Pure.pure (m a))","decl":"@[simp]\ntheorem map_pure (m : α → β) (a : α) : map m (pure a) = pure (m a) :=\n  rfl\n\n"}
{"name":"Ultrafilter.comap_pure","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nβ : Type v\nm : α → β\na : α\ninj : Function.Injective m\nlarge : Membership.mem (Pure.pure (m a)) (Set.range m)\n⊢ Eq ((Pure.pure (m a)).comap inj large) (Pure.pure a)","decl":"@[simp]\ntheorem comap_pure {m : α → β} (a : α) (inj : Injective m) (large) :\n    comap (pure <| m a) inj large = pure a :=\n  coe_injective <|\n    Filter.comap_pure.trans <| by\n      rw [coe_pure, ← principal_singleton, ← image_singleton, preimage_image_eq _ inj]\n\n"}
{"name":"Ultrafilter.pure_injective","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\n⊢ Function.Injective Pure.pure","decl":"theorem pure_injective : Injective (pure : α → Ultrafilter α) := fun _ _ h =>\n  Filter.pure_injective (congr_arg Ultrafilter.toFilter h :)\n\n"}
{"name":"Ultrafilter.instNonempty","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Nonempty (Ultrafilter α)","decl":"instance [Nonempty α] : Nonempty (Ultrafilter α) :=\n  Nonempty.map pure inferInstance\n\n"}
{"name":"Ultrafilter.lawfulMonad","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"⊢ LawfulMonad Ultrafilter","decl":"instance lawfulMonad : LawfulMonad Ultrafilter where\n  id_map f := coe_injective (id_map f.toFilter)\n  pure_bind a f := coe_injective (Filter.pure_bind a ((Ultrafilter.toFilter) ∘ f))\n  bind_assoc _ _ _ := coe_injective (filter_eq rfl)\n  bind_pure_comp f x := coe_injective (bind_pure_comp f x.1)\n  map_const := rfl\n  seqLeft_eq _ _ := rfl\n  seqRight_eq _ _ := rfl\n  pure_seq _ _ := rfl\n  bind_map _ _ := rfl\n\n"}
{"name":"Ultrafilter.exists_le","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Filter α\nh : f.NeBot\n⊢ Exists fun u => LE.le (↑u) f","decl":"/-- The ultrafilter lemma: Any proper filter is contained in an ultrafilter. -/\ntheorem exists_le (f : Filter α) [h : NeBot f] : ∃ u : Ultrafilter α, ↑u ≤ f :=\n  let ⟨u, hu, huf⟩ := (eq_bot_or_exists_atom_le f).resolve_left h.ne\n  ⟨ofAtom u hu, huf⟩\n\n"}
{"name":"Filter.exists_ultrafilter_le","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Filter α\nh : f.NeBot\n⊢ Exists fun u => LE.le (↑u) f","decl":"alias _root_.Filter.exists_ultrafilter_le := exists_le\n\n"}
{"name":"Ultrafilter.of_le","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Filter α\ninst✝ : f.NeBot\n⊢ LE.le (↑(Ultrafilter.of f)) f","decl":"theorem of_le (f : Filter α) [NeBot f] : ↑(of f) ≤ f :=\n  Classical.choose_spec (exists_le f)\n\n"}
{"name":"Ultrafilter.of_coe","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Ultrafilter α\n⊢ Eq (Ultrafilter.of ↑f) f","decl":"theorem of_coe (f : Ultrafilter α) : of ↑f = f :=\n  coe_inj.1 <| f.unique (of_le f.toFilter)\n\n"}
{"name":"Filter.isAtom_pure","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\na : α\n⊢ IsAtom (Pure.pure a)","decl":"theorem isAtom_pure : IsAtom (pure a : Filter α) :=\n  (pure a : Ultrafilter α).isAtom\n\n"}
{"name":"Filter.NeBot.le_pure_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Filter α\na : α\nhf : f.NeBot\n⊢ Iff (LE.le f (Pure.pure a)) (Eq f (Pure.pure a))","decl":"protected theorem NeBot.le_pure_iff (hf : f.NeBot) : f ≤ pure a ↔ f = pure a :=\n  ⟨Ultrafilter.unique (pure a), le_of_eq⟩\n\n"}
{"name":"Filter.NeBot.eq_pure_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Filter α\nhf : f.NeBot\nx : α\n⊢ Iff (Eq f (Pure.pure x)) (Membership.mem f (Singleton.singleton x))","decl":"protected theorem NeBot.eq_pure_iff (hf : f.NeBot) {x : α} :\n    f = pure x ↔ {x} ∈ f := by\n  rw [← hf.le_pure_iff, le_pure_iff]\n\n"}
{"name":"Filter.lt_pure_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Filter α\na : α\n⊢ Iff (LT.lt f (Pure.pure a)) (Eq f Bot.bot)","decl":"@[simp]\ntheorem lt_pure_iff : f < pure a ↔ f = ⊥ :=\n  isAtom_pure.lt_iff\n\n"}
{"name":"Filter.le_pure_iff'","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Filter α\na : α\n⊢ Iff (LE.le f (Pure.pure a)) (Or (Eq f Bot.bot) (Eq f (Pure.pure a)))","decl":"theorem le_pure_iff' : f ≤ pure a ↔ f = ⊥ ∨ f = pure a :=\n  isAtom_pure.le_iff\n\n"}
{"name":"Filter.Iic_pure","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\na : α\n⊢ Eq (Set.Iic (Pure.pure a)) (Insert.insert Bot.bot (Singleton.singleton (Pure.pure a)))","decl":"@[simp]\ntheorem Iic_pure (a : α) : Iic (pure a : Filter α) = {⊥, pure a} :=\n  isAtom_pure.Iic_eq\n\n"}
{"name":"Filter.mem_iff_ultrafilter","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Filter α\ns : Set α\n⊢ Iff (Membership.mem f s) (∀ (g : Ultrafilter α), LE.le (↑g) f → Membership.mem g s)","decl":"theorem mem_iff_ultrafilter : s ∈ f ↔ ∀ g : Ultrafilter α, ↑g ≤ f → s ∈ g := by\n  refine ⟨fun hf g hg => hg hf, fun H => by_contra fun hf => ?_⟩\n  set g : Filter (sᶜ : Set α) := comap (↑) f\n  haveI : NeBot g := comap_neBot_iff_compl_range.2 (by simpa [compl_setOf] )\n  simpa using H ((of g).map (↑)) (map_le_iff_le_comap.mpr (of_le g))\n\n"}
{"name":"Filter.le_iff_ultrafilter","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf₁ f₂ : Filter α\n⊢ Iff (LE.le f₁ f₂) (∀ (g : Ultrafilter α), LE.le (↑g) f₁ → LE.le (↑g) f₂)","decl":"theorem le_iff_ultrafilter {f₁ f₂ : Filter α} : f₁ ≤ f₂ ↔ ∀ g : Ultrafilter α, ↑g ≤ f₁ → ↑g ≤ f₂ :=\n  ⟨fun h _ h₁ => h₁.trans h, fun h _ hs => mem_iff_ultrafilter.2 fun g hg => h g hg hs⟩\n\n"}
{"name":"Filter.iSup_ultrafilter_le_eq","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Filter α\n⊢ Eq (iSup fun g => iSup fun x => ↑g) f","decl":"/-- A filter equals the intersection of all the ultrafilters which contain it. -/\ntheorem iSup_ultrafilter_le_eq (f : Filter α) :\n    ⨆ (g : Ultrafilter α) (_ : g ≤ f), (g : Filter α) = f :=\n  eq_of_forall_ge_iff fun f' => by simp only [iSup_le_iff, ← le_iff_ultrafilter]\n\n"}
{"name":"Filter.exists_ultrafilter_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nf : Filter α\n⊢ Iff (Exists fun u => LE.le (↑u) f) f.NeBot","decl":"theorem exists_ultrafilter_iff {f : Filter α} : (∃ u : Ultrafilter α, ↑u ≤ f) ↔ NeBot f :=\n  ⟨fun ⟨_, uf⟩ => neBot_of_le uf, fun h => @exists_ultrafilter_le _ _ h⟩\n\n"}
{"name":"Filter.forall_neBot_le_iff","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\ng : Filter α\np : Filter α → Prop\nhp : Monotone p\n⊢ Iff (∀ (f : Filter α), f.NeBot → LE.le f g → p f) (∀ (f : Ultrafilter α), LE.le (↑f) g → p ↑f)","decl":"theorem forall_neBot_le_iff {g : Filter α} {p : Filter α → Prop} (hp : Monotone p) :\n    (∀ f : Filter α, NeBot f → f ≤ g → p f) ↔ ∀ f : Ultrafilter α, ↑f ≤ g → p f := by\n  refine ⟨fun H f hf => H f f.neBot hf, ?_⟩\n  intro H f hf hfg\n  exact hp (of_le f) (H _ ((of_le f).trans hfg))\n\n"}
{"name":"Ultrafilter.comap_inf_principal_neBot_of_image_mem","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nβ : Type v\nm : α → β\ns : Set α\ng : Ultrafilter β\nh : Membership.mem g (Set.image m s)\n⊢ (Min.min (Filter.comap m ↑g) (Filter.principal s)).NeBot","decl":"theorem comap_inf_principal_neBot_of_image_mem (h : m '' s ∈ g) : (Filter.comap m g ⊓ 𝓟 s).NeBot :=\n  Filter.comap_inf_principal_neBot_of_image_mem g.neBot h\n\n"}
{"name":"Ultrafilter.ofComapInfPrincipal_mem","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nβ : Type v\nm : α → β\ns : Set α\ng : Ultrafilter β\nh : Membership.mem g (Set.image m s)\n⊢ Membership.mem (Ultrafilter.ofComapInfPrincipal h) s","decl":"theorem ofComapInfPrincipal_mem (h : m '' s ∈ g) : s ∈ ofComapInfPrincipal h := by\n  let f := Filter.comap m g ⊓ 𝓟 s\n  haveI : f.NeBot := comap_inf_principal_neBot_of_image_mem h\n  have : s ∈ f := mem_inf_of_right (mem_principal_self s)\n  exact le_def.mp (of_le _) s this\n\n"}
{"name":"Ultrafilter.ofComapInfPrincipal_eq_of_map","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"α : Type u\nβ : Type v\nm : α → β\ns : Set α\ng : Ultrafilter β\nh : Membership.mem g (Set.image m s)\n⊢ Eq (Ultrafilter.map m (Ultrafilter.ofComapInfPrincipal h)) g","decl":"theorem ofComapInfPrincipal_eq_of_map (h : m '' s ∈ g) : (ofComapInfPrincipal h).map m = g := by\n  let f := Filter.comap m g ⊓ 𝓟 s\n  haveI : f.NeBot := comap_inf_principal_neBot_of_image_mem h\n  apply eq_of_le\n  calc\n    Filter.map m (of f) ≤ Filter.map m f := map_mono (of_le _)\n    _ ≤ (Filter.map m <| Filter.comap m g) ⊓ Filter.map m (𝓟 s) := map_inf_le\n    _ = (Filter.map m <| Filter.comap m g) ⊓ (𝓟 <| m '' s) := by rw [map_principal]\n    _ ≤ ↑g ⊓ (𝓟 <| m '' s) := inf_le_inf_right _ map_comap_le\n    _ = ↑g := inf_of_le_left (le_principal_iff.mpr h)\n\n"}
{"name":"Ultrafilter.eq_of_le_pure","module":"Mathlib.Order.Filter.Ultrafilter.Defs","initialProofState":"X : Type u_2\nα : Filter X\nhα : α.NeBot\nx y : X\nhx : LE.le α (Pure.pure x)\nhy : LE.le α (Pure.pure y)\n⊢ Eq x y","decl":"theorem eq_of_le_pure {X : Type _} {α : Filter X} (hα : α.NeBot) {x y : X}\n    (hx : α ≤ pure x) (hy : α ≤ pure y) : x = y :=\n  Filter.pure_injective (hα.le_pure_iff.mp hx ▸ hα.le_pure_iff.mp hy)\n\n"}
