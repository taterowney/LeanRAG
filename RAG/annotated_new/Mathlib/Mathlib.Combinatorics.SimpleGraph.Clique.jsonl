{"name":"SimpleGraph.isClique_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ns : Set α\n⊢ Iff (G.IsClique s) (s.Pairwise G.Adj)","decl":"theorem isClique_iff : G.IsClique s ↔ s.Pairwise G.Adj :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.isClique_iff_induce_eq","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ns : Set α\n⊢ Iff (G.IsClique s) (Eq (SimpleGraph.induce s G) Top.top)","decl":"/-- A clique is a set of vertices whose induced graph is complete. -/\ntheorem isClique_iff_induce_eq : G.IsClique s ↔ G.induce s = ⊤ := by\n  rw [isClique_iff]\n  constructor\n  · intro h\n    ext ⟨v, hv⟩ ⟨w, hw⟩\n    simp only [comap_adj, Subtype.coe_mk, top_adj, Ne, Subtype.mk_eq_mk]\n    exact ⟨Adj.ne, h hv hw⟩\n  · intro h v hv w hw hne\n    have h2 : (G.induce s).Adj ⟨v, hv⟩ ⟨w, hw⟩ = _ := rfl\n    conv_lhs at h2 => rw [h]\n    simp only [top_adj, ne_eq, Subtype.mk.injEq, eq_iff_iff] at h2\n    exact h2.1 hne\n\n"}
{"name":"SimpleGraph.isClique_empty","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\n⊢ G.IsClique EmptyCollection.emptyCollection","decl":"lemma isClique_empty : G.IsClique ∅ := by simp\n\n"}
{"name":"SimpleGraph.isClique_singleton","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\na : α\n⊢ G.IsClique (Singleton.singleton a)","decl":"lemma isClique_singleton (a : α) : G.IsClique {a} := by simp\n\n"}
{"name":"SimpleGraph.IsClique.of_subsingleton","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\ns : Set α\nG : SimpleGraph α\nhs : s.Subsingleton\n⊢ G.IsClique s","decl":"theorem IsClique.of_subsingleton {G : SimpleGraph α} (hs : s.Subsingleton) : G.IsClique s :=\n  hs.pairwise G.Adj\n\n"}
{"name":"SimpleGraph.isClique_pair","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\na b : α\n⊢ Iff (G.IsClique (Insert.insert a (Singleton.singleton b))) (Ne a b → G.Adj a b)","decl":"lemma isClique_pair : G.IsClique {a, b} ↔ a ≠ b → G.Adj a b := Set.pairwise_pair_of_symmetric G.symm\n\n"}
{"name":"SimpleGraph.isClique_insert","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ns : Set α\na : α\n⊢ Iff (G.IsClique (Insert.insert a s)) (And (G.IsClique s) (∀ (b : α), Membership.mem s b → Ne a b → G.Adj a b))","decl":"@[simp]\nlemma isClique_insert : G.IsClique (insert a s) ↔ G.IsClique s ∧ ∀ b ∈ s, a ≠ b → G.Adj a b :=\n  Set.pairwise_insert_of_symmetric G.symm\n\n"}
{"name":"SimpleGraph.isClique_insert_of_not_mem","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ns : Set α\na : α\nha : Not (Membership.mem s a)\n⊢ Iff (G.IsClique (Insert.insert a s)) (And (G.IsClique s) (∀ (b : α), Membership.mem s b → G.Adj a b))","decl":"lemma isClique_insert_of_not_mem (ha : a ∉ s) :\n    G.IsClique (insert a s) ↔ G.IsClique s ∧ ∀ b ∈ s, G.Adj a b :=\n  Set.pairwise_insert_of_symmetric_of_not_mem G.symm ha\n\n"}
{"name":"SimpleGraph.IsClique.insert","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ns : Set α\na : α\nhs : G.IsClique s\nh : ∀ (b : α), Membership.mem s b → Ne a b → G.Adj a b\n⊢ G.IsClique (Insert.insert a s)","decl":"lemma IsClique.insert (hs : G.IsClique s) (h : ∀ b ∈ s, a ≠ b → G.Adj a b) :\n    G.IsClique (insert a s) := hs.insert_of_symmetric G.symm h\n\n"}
{"name":"SimpleGraph.IsClique.mono","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG H : SimpleGraph α\ns : Set α\nh : LE.le G H\na✝ : G.IsClique s\n⊢ H.IsClique s","decl":"theorem IsClique.mono (h : G ≤ H) : G.IsClique s → H.IsClique s := Set.Pairwise.mono' h\n\n"}
{"name":"SimpleGraph.IsClique.subset","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ns t : Set α\nh : HasSubset.Subset t s\na✝ : G.IsClique s\n⊢ G.IsClique t","decl":"theorem IsClique.subset (h : t ⊆ s) : G.IsClique s → G.IsClique t := Set.Pairwise.mono h\n\n"}
{"name":"SimpleGraph.isClique_bot_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (Bot.bot.IsClique s) s.Subsingleton","decl":"@[simp]\ntheorem isClique_bot_iff : (⊥ : SimpleGraph α).IsClique s ↔ (s : Set α).Subsingleton :=\n  Set.pairwise_bot_iff\n\n"}
{"name":"SimpleGraph.IsClique.subsingleton","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\ns : Set α\na✝ : Bot.bot.IsClique s\n⊢ s.Subsingleton","decl":"alias ⟨IsClique.subsingleton, _⟩ := isClique_bot_iff\n\n"}
{"name":"SimpleGraph.IsClique.map","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\ns : Set α\nh : G.IsClique s\nf : Function.Embedding α β\n⊢ (SimpleGraph.map f G).IsClique (Set.image (⇑f) s)","decl":"protected theorem IsClique.map (h : G.IsClique s) {f : α ↪ β} : (G.map f).IsClique (f '' s) := by\n  rintro _ ⟨a, ha, rfl⟩ _ ⟨b, hb, rfl⟩ hab\n  exact ⟨a, b, h ha hb <| ne_of_apply_ne _ hab, rfl, rfl⟩\n\n"}
{"name":"SimpleGraph.isClique_map_iff_of_nontrivial","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nf : Function.Embedding α β\nt : Set β\nht : t.Nontrivial\n⊢ Iff ((SimpleGraph.map f G).IsClique t) (Exists fun s => And (G.IsClique s) (Eq (Set.image (⇑f) s) t))","decl":"theorem isClique_map_iff_of_nontrivial {f : α ↪ β} {t : Set β} (ht : t.Nontrivial) :\n    (G.map f).IsClique t ↔ ∃ (s : Set α), G.IsClique s ∧ f '' s = t := by\n  refine ⟨fun h ↦ ⟨f ⁻¹' t, ?_, ?_⟩, by rintro ⟨x, hs, rfl⟩; exact hs.map⟩\n  · rintro x (hx : f x ∈ t) y (hy : f y ∈ t) hne\n    obtain ⟨u,v, huv, hux, hvy⟩ := h hx hy (by simpa)\n    rw [EmbeddingLike.apply_eq_iff_eq] at hux hvy\n    rwa [← hux, ← hvy]\n  rw [Set.image_preimage_eq_iff]\n  intro x hxt\n  obtain ⟨y,hyt, hyne⟩ := ht.exists_ne x\n  obtain ⟨u,v, -, rfl, rfl⟩ := h hyt hxt hyne\n  exact Set.mem_range_self _\n\n"}
{"name":"SimpleGraph.isClique_map_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nf : Function.Embedding α β\nt : Set β\n⊢ Iff ((SimpleGraph.map f G).IsClique t) (Or t.Subsingleton (Exists fun s => And (G.IsClique s) (Eq (Set.image (⇑f) s) t)))","decl":"theorem isClique_map_iff {f : α ↪ β} {t : Set β} :\n    (G.map f).IsClique t ↔ t.Subsingleton ∨ ∃ (s : Set α), G.IsClique s ∧ f '' s = t := by\n  obtain (ht | ht) := t.subsingleton_or_nontrivial\n  · simp [IsClique.of_subsingleton, ht]\n  simp [isClique_map_iff_of_nontrivial ht, ht.not_subsingleton]\n\n"}
{"name":"SimpleGraph.isClique_map_image_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\ns : Set α\nf : Function.Embedding α β\n⊢ Iff ((SimpleGraph.map f G).IsClique (Set.image (⇑f) s)) (G.IsClique s)","decl":"@[simp] theorem isClique_map_image_iff {f : α ↪ β} :\n    (G.map f).IsClique (f '' s) ↔ G.IsClique s := by\n  rw [isClique_map_iff, f.injective.subsingleton_image_iff]\n  obtain (hs | hs) := s.subsingleton_or_nontrivial\n  · simp [hs, IsClique.of_subsingleton]\n  simp [or_iff_right hs.not_subsingleton, Set.image_eq_image f.injective]\n\n"}
{"name":"SimpleGraph.isClique_map_finset_iff_of_nontrivial","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nf : Function.Embedding α β\nt : Finset β\nht : t.Nontrivial\n⊢ Iff ((SimpleGraph.map f G).IsClique ↑t) (Exists fun s => And (G.IsClique ↑s) (Eq (Finset.map f s) t))","decl":"theorem isClique_map_finset_iff_of_nontrivial (ht : t.Nontrivial) :\n    (G.map f).IsClique t ↔ ∃ (s : Finset α), G.IsClique s ∧ s.map f = t := by\n  constructor\n  · rw [isClique_map_iff_of_nontrivial (by simpa)]\n    rintro ⟨s, hs, hst⟩\n    obtain ⟨s, rfl⟩ := Set.Finite.exists_finset_coe <|\n      (show s.Finite from Set.Finite.of_finite_image (by simp [hst]) f.injective.injOn)\n    exact ⟨s,hs, Finset.coe_inj.1 (by simpa)⟩\n  rintro ⟨s, hs, rfl⟩\n  simpa using hs.map (f := f)\n\n"}
{"name":"SimpleGraph.isClique_map_finset_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nf : Function.Embedding α β\nt : Finset β\n⊢ Iff ((SimpleGraph.map f G).IsClique ↑t) (Or (LE.le t.card 1) (Exists fun s => And (G.IsClique ↑s) (Eq (Finset.map f s) t)))","decl":"theorem isClique_map_finset_iff :\n    (G.map f).IsClique t ↔ #t ≤ 1 ∨ ∃ (s : Finset α), G.IsClique s ∧ s.map f = t := by\n  obtain (ht | ht) := le_or_lt #t 1\n  · simp only [ht, true_or, iff_true]\n    exact IsClique.of_subsingleton <| card_le_one.1 ht\n  rw [isClique_map_finset_iff_of_nontrivial, ← not_lt]\n  · simp [ht, Finset.map_eq_image]\n  exact Finset.one_lt_card_iff_nontrivial.mp ht\n\n"}
{"name":"SimpleGraph.IsClique.finsetMap","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nf : Function.Embedding α β\ns : Finset α\nh : G.IsClique ↑s\n⊢ (SimpleGraph.map f G).IsClique ↑(Finset.map f s)","decl":"protected theorem IsClique.finsetMap {f : α ↪ β} {s : Finset α} (h : G.IsClique s) :\n    (G.map f).IsClique (s.map f) := by\n  simpa\n\n"}
{"name":"SimpleGraph.IsNClique.card_eq","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\ns : Finset α\nself : G.IsNClique n s\n⊢ Eq s.card n","decl":"/-- An `n`-clique in a graph is a set of `n` vertices which are pairwise connected. -/\nstructure IsNClique (n : ℕ) (s : Finset α) : Prop where\n  isClique : G.IsClique s\n  card_eq : #s = n\n\n"}
{"name":"SimpleGraph.IsNClique.isClique","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\ns : Finset α\nself : G.IsNClique n s\n⊢ G.IsClique ↑s","decl":"/-- An `n`-clique in a graph is a set of `n` vertices which are pairwise connected. -/\nstructure IsNClique (n : ℕ) (s : Finset α) : Prop where\n  isClique : G.IsClique s\n  card_eq : #s = n\n\n"}
{"name":"SimpleGraph.isNClique_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\ns : Finset α\n⊢ Iff (G.IsNClique n s) (And (G.IsClique ↑s) (Eq s.card n))","decl":"theorem isNClique_iff : G.IsNClique n s ↔ G.IsClique s ∧ #s = n :=\n  ⟨fun h ↦ ⟨h.1, h.2⟩, fun h ↦ ⟨h.1, h.2⟩⟩\n\n"}
{"name":"SimpleGraph.isNClique_empty","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\n⊢ Iff (G.IsNClique n EmptyCollection.emptyCollection) (Eq n 0)","decl":"@[simp] lemma isNClique_empty : G.IsNClique n ∅ ↔ n = 0 := by simp [isNClique_iff, eq_comm]\n\n"}
{"name":"SimpleGraph.isNClique_singleton","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\na : α\n⊢ Iff (G.IsNClique n (Singleton.singleton a)) (Eq n 1)","decl":"@[simp]\nlemma isNClique_singleton : G.IsNClique n {a} ↔ n = 1 := by simp [isNClique_iff, eq_comm]\n\n"}
{"name":"SimpleGraph.IsNClique.mono","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG H : SimpleGraph α\nn : Nat\ns : Finset α\nh : LE.le G H\na✝ : G.IsNClique n s\n⊢ H.IsNClique n s","decl":"theorem IsNClique.mono (h : G ≤ H) : G.IsNClique n s → H.IsNClique n s := by\n  simp_rw [isNClique_iff]\n  exact And.imp_left (IsClique.mono h)\n\n"}
{"name":"SimpleGraph.IsNClique.map","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nn : Nat\ns : Finset α\nh : G.IsNClique n s\nf : Function.Embedding α β\n⊢ (SimpleGraph.map f G).IsNClique n (Finset.map f s)","decl":"protected theorem IsNClique.map (h : G.IsNClique n s) {f : α ↪ β} :\n    (G.map f).IsNClique n (s.map f) :=\n  ⟨by rw [coe_map]; exact h.1.map, (card_map _).trans h.2⟩\n\n"}
{"name":"SimpleGraph.isNClique_map_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nn : Nat\nhn : LT.lt 1 n\nt : Finset β\nf : Function.Embedding α β\n⊢ Iff ((SimpleGraph.map f G).IsNClique n t) (Exists fun s => And (G.IsNClique n s) (Eq (Finset.map f s) t))","decl":"theorem isNClique_map_iff (hn : 1 < n) {t : Finset β} {f : α ↪ β} :\n    (G.map f).IsNClique n t ↔ ∃ s : Finset α, G.IsNClique n s ∧ s.map f = t := by\n  rw [isNClique_iff, isClique_map_finset_iff, or_and_right,\n    or_iff_right (by rintro ⟨h', rfl⟩; exact h'.not_lt hn)]\n  constructor\n  · rintro ⟨⟨s, hs, rfl⟩, rfl⟩\n    simp [isNClique_iff, hs]\n  rintro ⟨s, hs, rfl⟩\n  simp [hs.card_eq, hs.isClique]\n\n"}
{"name":"SimpleGraph.isNClique_bot_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nn : Nat\ns : Finset α\n⊢ Iff (Bot.bot.IsNClique n s) (And (LE.le n 1) (Eq s.card n))","decl":"@[simp]\ntheorem isNClique_bot_iff : (⊥ : SimpleGraph α).IsNClique n s ↔ n ≤ 1 ∧ #s = n := by\n  rw [isNClique_iff, isClique_bot_iff]\n  refine and_congr_left ?_\n  rintro rfl\n  exact card_le_one.symm\n\n"}
{"name":"SimpleGraph.isNClique_zero","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ns : Finset α\n⊢ Iff (G.IsNClique 0 s) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem isNClique_zero : G.IsNClique 0 s ↔ s = ∅ := by\n  simp only [isNClique_iff, Finset.card_eq_zero, and_iff_right_iff_imp]; rintro rfl; simp\n\n"}
{"name":"SimpleGraph.isNClique_one","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ns : Finset α\n⊢ Iff (G.IsNClique 1 s) (Exists fun a => Eq s (Singleton.singleton a))","decl":"@[simp]\ntheorem isNClique_one : G.IsNClique 1 s ↔ ∃ a, s = {a} := by\n  simp only [isNClique_iff, card_eq_one, and_iff_right_iff_imp]; rintro ⟨a, rfl⟩; simp\n\n"}
{"name":"SimpleGraph.IsNClique.insert","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\ns : Finset α\na : α\ninst✝ : DecidableEq α\nhs : G.IsNClique n s\nh : ∀ (b : α), Membership.mem s b → G.Adj a b\n⊢ G.IsNClique (HAdd.hAdd n 1) (Insert.insert a s)","decl":"theorem IsNClique.insert (hs : G.IsNClique n s) (h : ∀ b ∈ s, G.Adj a b) :\n    G.IsNClique (n + 1) (insert a s) := by\n  constructor\n  · push_cast\n    exact hs.1.insert fun b hb _ => h _ hb\n  · rw [card_insert_of_not_mem fun ha => (h _ ha).ne rfl, hs.2]\n\n"}
{"name":"SimpleGraph.is3Clique_triple_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\na b c : α\ninst✝ : DecidableEq α\n⊢ Iff (G.IsNClique 3 (Insert.insert a (Insert.insert b (Singleton.singleton c)))) (And (G.Adj a b) (And (G.Adj a c) (G.Adj b c)))","decl":"theorem is3Clique_triple_iff : G.IsNClique 3 {a, b, c} ↔ G.Adj a b ∧ G.Adj a c ∧ G.Adj b c := by\n  simp only [isNClique_iff, isClique_iff, Set.pairwise_insert_of_symmetric G.symm, coe_insert]\n  by_cases hab : a = b <;> by_cases hbc : b = c <;> by_cases hac : a = c <;> subst_vars <;>\n    simp [G.ne_of_adj, and_rotate, *]\n\n"}
{"name":"SimpleGraph.is3Clique_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ns : Finset α\ninst✝ : DecidableEq α\n⊢ Iff (G.IsNClique 3 s) (Exists fun a => Exists fun b => Exists fun c => And (G.Adj a b) (And (G.Adj a c) (And (G.Adj b c) (Eq s (Insert.insert a (Insert.insert b (Singleton.singleton c)))))))","decl":"theorem is3Clique_iff :\n    G.IsNClique 3 s ↔ ∃ a b c, G.Adj a b ∧ G.Adj a c ∧ G.Adj b c ∧ s = {a, b, c} := by\n  refine ⟨fun h ↦ ?_, ?_⟩\n  · obtain ⟨a, b, c, -, -, -, hs⟩ := card_eq_three.1 h.card_eq\n    refine ⟨a, b, c, ?_⟩\n    rwa [hs, eq_self_iff_true, and_true, is3Clique_triple_iff.symm, ← hs]\n  · rintro ⟨a, b, c, hab, hbc, hca, rfl⟩\n    exact is3Clique_triple_iff.2 ⟨hab, hbc, hca⟩\n\n"}
{"name":"SimpleGraph.is3Clique_iff_exists_cycle_length_three","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\n⊢ Iff (Exists fun s => G.IsNClique 3 s) (Exists fun u => Exists fun w => And w.IsCycle (Eq w.length 3))","decl":"theorem is3Clique_iff_exists_cycle_length_three :\n    (∃ s : Finset α, G.IsNClique 3 s) ↔ ∃ (u : α) (w : G.Walk u u), w.IsCycle ∧ w.length = 3 := by\n  classical\n  simp_rw [is3Clique_iff, isCycle_def]\n  exact\n    ⟨(fun ⟨_, a, _, _, hab, hac, hbc, _⟩ => ⟨a, cons hab (cons hbc (cons hac.symm nil)), by aesop⟩),\n    (fun ⟨_, .cons hab (.cons hbc (.cons hca nil)), _, _⟩ => ⟨_, _, _, _, hab, hca.symm, hbc, rfl⟩)⟩\n\n"}
{"name":"SimpleGraph.IsNClique.not_cliqueFree","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\ns : Finset α\nhG : G.IsNClique n s\n⊢ Not (G.CliqueFree n)","decl":"theorem IsNClique.not_cliqueFree (hG : G.IsNClique n s) : ¬G.CliqueFree n :=\n  fun h ↦ h _ hG\n\n"}
{"name":"SimpleGraph.not_cliqueFree_of_top_embedding","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\nf : Top.top.Embedding G\n⊢ Not (G.CliqueFree n)","decl":"theorem not_cliqueFree_of_top_embedding {n : ℕ} (f : (⊤ : SimpleGraph (Fin n)) ↪g G) :\n    ¬G.CliqueFree n := by\n  simp only [CliqueFree, isNClique_iff, isClique_iff_induce_eq, not_forall, Classical.not_not]\n  use Finset.univ.map f.toEmbedding\n  simp only [card_map, Finset.card_fin, eq_self_iff_true, and_true]\n  ext ⟨v, hv⟩ ⟨w, hw⟩\n  simp only [coe_map, Set.mem_image, coe_univ, Set.mem_univ, true_and] at hv hw\n  obtain ⟨v', rfl⟩ := hv\n  obtain ⟨w', rfl⟩ := hw\n  simp only [coe_sort_coe, RelEmbedding.coe_toEmbedding, comap_adj, Function.Embedding.coe_subtype,\n    f.map_adj_iff, top_adj, ne_eq, Subtype.mk.injEq, RelEmbedding.inj]\n  -- This used to be the end of the proof before https://github.com/leanprover/lean4/pull/2644\n  erw [Function.Embedding.coe_subtype, f.map_adj_iff]\n  simp\n\n"}
{"name":"SimpleGraph.not_cliqueFree_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\n⊢ Iff (Not (G.CliqueFree n)) (Nonempty (Top.top.Embedding G))","decl":"theorem not_cliqueFree_iff (n : ℕ) : ¬G.CliqueFree n ↔ Nonempty ((⊤ : SimpleGraph (Fin n)) ↪g G) :=\n  ⟨fun h ↦ ⟨topEmbeddingOfNotCliqueFree h⟩, fun ⟨f⟩ ↦ not_cliqueFree_of_top_embedding f⟩\n\n"}
{"name":"SimpleGraph.cliqueFree_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\n⊢ Iff (G.CliqueFree n) (IsEmpty (Top.top.Embedding G))","decl":"theorem cliqueFree_iff {n : ℕ} : G.CliqueFree n ↔ IsEmpty ((⊤ : SimpleGraph (Fin n)) ↪g G) := by\n  rw [← not_iff_not, not_cliqueFree_iff, not_isEmpty_iff]\n\n"}
{"name":"SimpleGraph.not_cliqueFree_card_of_top_embedding","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ninst✝ : Fintype α\nf : Top.top.Embedding G\n⊢ Not (G.CliqueFree (Fintype.card α))","decl":"theorem not_cliqueFree_card_of_top_embedding [Fintype α] (f : (⊤ : SimpleGraph α) ↪g G) :\n    ¬G.CliqueFree (card α) := by\n  rw [not_cliqueFree_iff]\n  exact ⟨(Iso.completeGraph (Fintype.equivFin α)).symm.toEmbedding.trans f⟩\n\n"}
{"name":"SimpleGraph.cliqueFree_bot","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nn : Nat\nh : LE.le 2 n\n⊢ Bot.bot.CliqueFree n","decl":"@[simp]\ntheorem cliqueFree_bot (h : 2 ≤ n) : (⊥ : SimpleGraph α).CliqueFree n := by\n  intro t ht\n  have := le_trans h (isNClique_bot_iff.1 ht).1\n  contradiction\n\n"}
{"name":"SimpleGraph.CliqueFree.mono","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nm n : Nat\nh : LE.le m n\na✝ : G.CliqueFree m\n⊢ G.CliqueFree n","decl":"theorem CliqueFree.mono (h : m ≤ n) : G.CliqueFree m → G.CliqueFree n := by\n  intro hG s hs\n  obtain ⟨t, hts, ht⟩ := exists_subset_card_eq (h.trans hs.card_eq.ge)\n  exact hG _ ⟨hs.isClique.subset hts, ht⟩\n\n"}
{"name":"SimpleGraph.CliqueFree.anti","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG H : SimpleGraph α\nn : Nat\nh : LE.le G H\na✝ : H.CliqueFree n\n⊢ G.CliqueFree n","decl":"theorem CliqueFree.anti (h : G ≤ H) : H.CliqueFree n → G.CliqueFree n :=\n  forall_imp fun _ ↦ mt <| IsNClique.mono h\n\n"}
{"name":"SimpleGraph.CliqueFree.comap","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nn : Nat\nH : SimpleGraph β\nf : H.Embedding G\na✝ : G.CliqueFree n\n⊢ H.CliqueFree n","decl":"/-- If a graph is cliquefree, any graph that embeds into it is also cliquefree. -/\ntheorem CliqueFree.comap {H : SimpleGraph β} (f : H ↪g G) : G.CliqueFree n → H.CliqueFree n := by\n  intro h; contrapose h\n  exact not_cliqueFree_of_top_embedding <| f.comp (topEmbeddingOfNotCliqueFree h)\n\n"}
{"name":"SimpleGraph.cliqueFree_map_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nn : Nat\nf : Function.Embedding α β\ninst✝ : Nonempty α\n⊢ Iff ((SimpleGraph.map f G).CliqueFree n) (G.CliqueFree n)","decl":"@[simp] theorem cliqueFree_map_iff {f : α ↪ β} [Nonempty α] :\n    (G.map f).CliqueFree n ↔ G.CliqueFree n := by\n  obtain (hle | hlt) := le_or_lt n 1\n  · obtain (rfl | rfl) := Nat.le_one_iff_eq_zero_or_eq_one.1 hle\n    · simp [CliqueFree]\n    simp [CliqueFree, show ∃ (_ : β), True from ⟨f (Classical.arbitrary _), trivial⟩]\n  simp [CliqueFree, isNClique_map_iff hlt]\n\n"}
{"name":"SimpleGraph.cliqueFree_of_card_lt","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\ninst✝ : Fintype α\nhc : LT.lt (Fintype.card α) n\n⊢ G.CliqueFree n","decl":"/-- See `SimpleGraph.cliqueFree_of_chromaticNumber_lt` for a tighter bound. -/\ntheorem cliqueFree_of_card_lt [Fintype α] (hc : card α < n) : G.CliqueFree n := by\n  by_contra h\n  refine Nat.lt_le_asymm hc ?_\n  rw [cliqueFree_iff, not_isEmpty_iff] at h\n  simpa only [Fintype.card_fin] using Fintype.card_le_of_embedding h.some.toEmbedding\n\n"}
{"name":"SimpleGraph.cliqueFree_completeMultipartiteGraph","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"n : Nat\nι : Type u_3\ninst✝ : Fintype ι\nV : ι → Type u_4\nhc : LT.lt (Fintype.card ι) n\n⊢ (SimpleGraph.completeMultipartiteGraph V).CliqueFree n","decl":"/-- A complete `r`-partite graph has no `n`-cliques for `r < n`. -/\ntheorem cliqueFree_completeMultipartiteGraph {ι : Type*} [Fintype ι] (V : ι → Type*)\n    (hc : card ι < n) : (completeMultipartiteGraph V).CliqueFree n := by\n  rw [cliqueFree_iff, isEmpty_iff]\n  intro f\n  obtain ⟨v, w, hn, he⟩ := exists_ne_map_eq_of_card_lt (Sigma.fst ∘ f) (by simp [hc])\n  rw [← top_adj, ← f.map_adj_iff, comap_adj, top_adj] at hn\n  exact absurd he hn\n\n"}
{"name":"SimpleGraph.CliqueFree.replaceVertex","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\ninst✝ : DecidableEq α\nh : G.CliqueFree n\ns t : α\n⊢ (G.replaceVertex s t).CliqueFree n","decl":"/-- Clique-freeness is preserved by `replaceVertex`. -/\nprotected theorem CliqueFree.replaceVertex [DecidableEq α] (h : G.CliqueFree n) (s t : α) :\n    (G.replaceVertex s t).CliqueFree n := by\n  contrapose h\n  obtain ⟨φ, hφ⟩ := topEmbeddingOfNotCliqueFree h\n  rw [not_cliqueFree_iff]\n  by_cases mt : t ∈ Set.range φ\n  · obtain ⟨x, hx⟩ := mt\n    by_cases ms : s ∈ Set.range φ\n    · obtain ⟨y, hy⟩ := ms\n      have e := @hφ x y\n      simp_rw [hx, hy, adj_comm, not_adj_replaceVertex_same, top_adj, false_iff, not_ne_iff] at e\n      rwa [← hx, e, hy, replaceVertex_self, not_cliqueFree_iff] at h\n    · unfold replaceVertex at hφ\n      use φ.setValue x s\n      intro a b\n      simp only [Embedding.coeFn_mk, Embedding.setValue, not_exists.mp ms, ite_false]\n      rw [apply_ite (G.Adj · _), apply_ite (G.Adj _ ·), apply_ite (G.Adj _ ·)]\n      convert @hφ a b <;> simp only [← φ.apply_eq_iff_eq, SimpleGraph.irrefl, hx]\n  · use φ\n    simp_rw [Set.mem_range, not_exists, ← ne_eq] at mt\n    conv at hφ => enter [a, b]; rw [G.adj_replaceVertex_iff_of_ne _ (mt a) (mt b)]\n    exact hφ\n\n"}
{"name":"SimpleGraph.cliqueFree_one","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\n⊢ Iff (G.CliqueFree 1) (IsEmpty α)","decl":"@[simp]\nlemma cliqueFree_one : G.CliqueFree 1 ↔ IsEmpty α := by\n  simp [CliqueFree, isEmpty_iff]\n\n"}
{"name":"SimpleGraph.cliqueFree_two","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\n⊢ Iff (G.CliqueFree 2) (Eq G Bot.bot)","decl":"@[simp]\ntheorem cliqueFree_two : G.CliqueFree 2 ↔ G = ⊥ := by\n  classical\n  constructor\n  · simp_rw [← edgeSet_eq_empty, Set.eq_empty_iff_forall_not_mem, Sym2.forall, mem_edgeSet]\n    exact fun h a b hab => h _ ⟨by simpa [hab.ne], card_pair hab.ne⟩\n  · rintro rfl\n    exact cliqueFree_bot le_rfl\n\n"}
{"name":"SimpleGraph.CliqueFree.sup_edge","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\nh : G.CliqueFree n\nv w : α\n⊢ (Max.max G (SimpleGraph.edge v w)).CliqueFree (HAdd.hAdd n 1)","decl":"/-- Adding an edge increases the clique number by at most one. -/\nprotected theorem CliqueFree.sup_edge (h : G.CliqueFree n) (v w : α) :\n    (G ⊔ edge v w).CliqueFree (n + 1) := by\n  contrapose h\n  obtain ⟨f, ha⟩ := topEmbeddingOfNotCliqueFree h\n  simp only [ne_eq, top_adj] at ha\n  rw [not_cliqueFree_iff]\n  by_cases mw : w ∈ Set.range f\n  · obtain ⟨x, hx⟩ := mw\n    use ⟨f ∘ x.succAboveEmb, f.2.comp Fin.succAbove_right_injective⟩\n    intro a b\n    simp_rw [Embedding.coeFn_mk, comp_apply, Fin.succAboveEmb_apply, top_adj]\n    have hs := @ha (x.succAbove a) (x.succAbove b)\n    have ia : w ≠ f (x.succAbove a) :=\n      (hx ▸ f.apply_eq_iff_eq x (x.succAbove a)).ne.mpr (x.succAbove_ne a).symm\n    have ib : w ≠ f (x.succAbove b) :=\n      (hx ▸ f.apply_eq_iff_eq x (x.succAbove b)).ne.mpr (x.succAbove_ne b).symm\n    rw [sup_adj, edge_adj] at hs\n    simp only [ia.symm, ib.symm, and_false, false_and, or_false] at hs\n    rw [hs, Fin.succAbove_right_inj]\n  · use ⟨f ∘ Fin.succEmb n, (f.2.of_comp_iff _).mpr (Fin.succ_injective _)⟩\n    intro a b\n    simp only [Fin.val_succEmb, Embedding.coeFn_mk, comp_apply, top_adj]\n    have hs := @ha a.succ b.succ\n    have ia : f a.succ ≠ w := by simp_all\n    have ib : f b.succ ≠ w := by simp_all\n    rw [sup_adj, edge_adj] at hs\n    simp only [ia, ib, and_false, false_and, or_false] at hs\n    rw [hs, Fin.succ_inj]\n\n"}
{"name":"SimpleGraph.CliqueFreeOn.subset","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ns₁ s₂ : Set α\nn : Nat\nhs : HasSubset.Subset s₁ s₂\nh₂ : G.CliqueFreeOn s₂ n\n⊢ G.CliqueFreeOn s₁ n","decl":"theorem CliqueFreeOn.subset (hs : s₁ ⊆ s₂) (h₂ : G.CliqueFreeOn s₂ n) : G.CliqueFreeOn s₁ n :=\n  fun _t hts => h₂ <| hts.trans hs\n\n"}
{"name":"SimpleGraph.CliqueFreeOn.mono","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ns : Set α\nm n : Nat\nhmn : LE.le m n\nhG : G.CliqueFreeOn s m\n⊢ G.CliqueFreeOn s n","decl":"theorem CliqueFreeOn.mono (hmn : m ≤ n) (hG : G.CliqueFreeOn s m) : G.CliqueFreeOn s n := by\n  rintro t hts ht\n  obtain ⟨u, hut, hu⟩ := exists_subset_card_eq (hmn.trans ht.card_eq.ge)\n  exact hG ((coe_subset.2 hut).trans hts) ⟨ht.isClique.subset hut, hu⟩\n\n"}
{"name":"SimpleGraph.CliqueFreeOn.anti","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG H : SimpleGraph α\ns : Set α\nn : Nat\nhGH : LE.le G H\nhH : H.CliqueFreeOn s n\n⊢ G.CliqueFreeOn s n","decl":"theorem CliqueFreeOn.anti (hGH : G ≤ H) (hH : H.CliqueFreeOn s n) : G.CliqueFreeOn s n :=\n  fun _t hts ht => hH hts <| ht.mono hGH\n\n"}
{"name":"SimpleGraph.cliqueFreeOn_empty","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\n⊢ Iff (G.CliqueFreeOn EmptyCollection.emptyCollection n) (Ne n 0)","decl":"@[simp]\ntheorem cliqueFreeOn_empty : G.CliqueFreeOn ∅ n ↔ n ≠ 0 := by\n  simp [CliqueFreeOn, Set.subset_empty_iff]\n\n"}
{"name":"SimpleGraph.cliqueFreeOn_singleton","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\na : α\nn : Nat\n⊢ Iff (G.CliqueFreeOn (Singleton.singleton a) n) (LT.lt 1 n)","decl":"@[simp]\ntheorem cliqueFreeOn_singleton : G.CliqueFreeOn {a} n ↔ 1 < n := by\n  obtain _ | _ | n := n <;>\n    simp [CliqueFreeOn, isNClique_iff, ← subset_singleton_iff', (Nat.succ_ne_zero _).symm]\n\n"}
{"name":"SimpleGraph.cliqueFreeOn_univ","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\n⊢ Iff (G.CliqueFreeOn Set.univ n) (G.CliqueFree n)","decl":"@[simp]\ntheorem cliqueFreeOn_univ : G.CliqueFreeOn Set.univ n ↔ G.CliqueFree n := by\n  simp [CliqueFree, CliqueFreeOn]\n\n"}
{"name":"SimpleGraph.CliqueFree.cliqueFreeOn","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ns : Set α\nn : Nat\nhG : G.CliqueFree n\n⊢ G.CliqueFreeOn s n","decl":"protected theorem CliqueFree.cliqueFreeOn (hG : G.CliqueFree n) : G.CliqueFreeOn s n :=\n  fun _t _ ↦ hG _\n\n"}
{"name":"SimpleGraph.cliqueFreeOn_of_card_lt","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\ns : Finset α\nh : LT.lt s.card n\n⊢ G.CliqueFreeOn (↑s) n","decl":"theorem cliqueFreeOn_of_card_lt {s : Finset α} (h : #s < n) : G.CliqueFreeOn s n :=\n  fun _t hts ht => h.not_le <| ht.2.symm.trans_le <| card_mono hts\n\n-- TODO: Restate using `SimpleGraph.IndepSet` once we have it\n"}
{"name":"SimpleGraph.cliqueFreeOn_two","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ns : Set α\n⊢ Iff (G.CliqueFreeOn s 2) (s.Pairwise (HasCompl.compl G.Adj))","decl":"@[simp]\ntheorem cliqueFreeOn_two : G.CliqueFreeOn s 2 ↔ s.Pairwise (G.Adjᶜ) := by\n  classical\n  refine ⟨fun h a ha b hb _ hab => h ?_ ⟨by simpa [hab.ne], card_pair hab.ne⟩, ?_⟩\n  · push_cast\n    exact Set.insert_subset_iff.2 ⟨ha, Set.singleton_subset_iff.2 hb⟩\n  simp only [CliqueFreeOn, isNClique_iff, card_eq_two, coe_subset, not_and, not_exists]\n  rintro h t hst ht a b hab rfl\n  simp only [coe_insert, coe_singleton, Set.insert_subset_iff, Set.singleton_subset_iff] at hst\n  refine h hst.1 hst.2 hab (ht ?_ ?_ hab) <;> simp\n\n"}
{"name":"SimpleGraph.CliqueFreeOn.of_succ","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ns : Set α\na : α\nn : Nat\nhs : G.CliqueFreeOn s (HAdd.hAdd n 1)\nha : Membership.mem s a\n⊢ G.CliqueFreeOn (Inter.inter s (G.neighborSet a)) n","decl":"theorem CliqueFreeOn.of_succ (hs : G.CliqueFreeOn s (n + 1)) (ha : a ∈ s) :\n    G.CliqueFreeOn (s ∩ G.neighborSet a) n := by\n  classical\n  refine fun t hts ht => hs ?_ (ht.insert fun b hb => (hts hb).2)\n  push_cast\n  exact Set.insert_subset_iff.2 ⟨ha, hts.trans Set.inter_subset_left⟩\n\n"}
{"name":"SimpleGraph.mem_cliqueSet_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\ns : Finset α\n⊢ Iff (Membership.mem (G.cliqueSet n) s) (G.IsNClique n s)","decl":"@[simp]\ntheorem mem_cliqueSet_iff : s ∈ G.cliqueSet n ↔ G.IsNClique n s :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.cliqueSet_eq_empty_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\n⊢ Iff (Eq (G.cliqueSet n) EmptyCollection.emptyCollection) (G.CliqueFree n)","decl":"@[simp]\ntheorem cliqueSet_eq_empty_iff : G.cliqueSet n = ∅ ↔ G.CliqueFree n := by\n  simp_rw [CliqueFree, Set.eq_empty_iff_forall_not_mem, mem_cliqueSet_iff]\n\n"}
{"name":"SimpleGraph.CliqueFree.cliqueSet","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\na✝ : G.CliqueFree n\n⊢ Eq (G.cliqueSet n) EmptyCollection.emptyCollection","decl":"protected alias ⟨_, CliqueFree.cliqueSet⟩ := cliqueSet_eq_empty_iff\n\n"}
{"name":"SimpleGraph.cliqueSet_mono","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG H : SimpleGraph α\nn : Nat\nh : LE.le G H\n⊢ HasSubset.Subset (G.cliqueSet n) (H.cliqueSet n)","decl":"@[gcongr, mono]\ntheorem cliqueSet_mono (h : G ≤ H) : G.cliqueSet n ⊆ H.cliqueSet n :=\n  fun _ ↦ IsNClique.mono h\n\n"}
{"name":"SimpleGraph.cliqueSet_mono'","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG H : SimpleGraph α\nh : LE.le G H\n⊢ LE.le G.cliqueSet H.cliqueSet","decl":"theorem cliqueSet_mono' (h : G ≤ H) : G.cliqueSet ≤ H.cliqueSet :=\n  fun _ ↦ cliqueSet_mono h\n\n"}
{"name":"SimpleGraph.cliqueSet_zero","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\n⊢ Eq (G.cliqueSet 0) (Singleton.singleton EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem cliqueSet_zero (G : SimpleGraph α) : G.cliqueSet 0 = {∅} := Set.ext fun s => by simp\n\n"}
{"name":"SimpleGraph.cliqueSet_one","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\n⊢ Eq (G.cliqueSet 1) (Set.range Singleton.singleton)","decl":"@[simp]\ntheorem cliqueSet_one (G : SimpleGraph α) : G.cliqueSet 1 = Set.range singleton :=\n  Set.ext fun s => by simp [eq_comm]\n\n"}
{"name":"SimpleGraph.cliqueSet_bot","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nn : Nat\nhn : LT.lt 1 n\n⊢ Eq (Bot.bot.cliqueSet n) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem cliqueSet_bot (hn : 1 < n) : (⊥ : SimpleGraph α).cliqueSet n = ∅ :=\n  (cliqueFree_bot hn).cliqueSet\n\n"}
{"name":"SimpleGraph.cliqueSet_map","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nat\nhn : Ne n 1\nG : SimpleGraph α\nf : Function.Embedding α β\n⊢ Eq ((SimpleGraph.map f G).cliqueSet n) (Set.image (Finset.map f) (G.cliqueSet n))","decl":"@[simp]\ntheorem cliqueSet_map (hn : n ≠ 1) (G : SimpleGraph α) (f : α ↪ β) :\n    (G.map f).cliqueSet n = map f '' G.cliqueSet n := by\n  ext s\n  constructor\n  · rintro ⟨hs, rfl⟩\n    have hs' : (s.preimage f f.injective.injOn).map f = s := by\n      classical\n      rw [map_eq_image, image_preimage, filter_true_of_mem]\n      rintro a ha\n      obtain ⟨b, hb, hba⟩ := exists_mem_ne (hn.lt_of_le' <| Finset.card_pos.2 ⟨a, ha⟩) a\n      obtain ⟨c, _, _, hc, _⟩ := hs ha hb hba.symm\n      exact ⟨c, hc⟩\n    refine ⟨s.preimage f f.injective.injOn, ⟨?_, by rw [← card_map f, hs']⟩, hs'⟩\n    rw [coe_preimage]\n    exact fun a ha b hb hab => map_adj_apply.1 (hs ha hb <| f.injective.ne hab)\n  · rintro ⟨s, hs, rfl⟩\n    exact hs.map\n\n"}
{"name":"SimpleGraph.cliqueSet_map_of_equiv","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\ne : Equiv α β\nn : Nat\n⊢ Eq ((SimpleGraph.map e.toEmbedding G).cliqueSet n) (Set.image (Finset.map e.toEmbedding) (G.cliqueSet n))","decl":"@[simp]\ntheorem cliqueSet_map_of_equiv (G : SimpleGraph α) (e : α ≃ β) (n : ℕ) :\n    (G.map e.toEmbedding).cliqueSet n = map e.toEmbedding '' G.cliqueSet n := by\n  obtain rfl | hn := eq_or_ne n 1\n  · ext\n    simp [e.exists_congr_left]\n  · exact cliqueSet_map hn _ _\n\n"}
{"name":"SimpleGraph.IsClique.card_le_cliqueNum","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\nG : SimpleGraph α\ninst✝ : Fintype α\nt : Finset α\ntc : G.IsClique ↑t\n⊢ LE.le t.card G.cliqueNum","decl":"lemma IsClique.card_le_cliqueNum [Fintype α] {t : Finset α} {tc : G.IsClique t} :\n    #t ≤ G.cliqueNum :=\n  le_csSup G.fintype_cliqueNum_bddAbove (Exists.intro t ⟨tc, rfl⟩)\n\n"}
{"name":"SimpleGraph.exists_isNClique_cliqueNum","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\nG : SimpleGraph α\ninst✝ : Fintype α\n⊢ Exists fun s => G.IsNClique G.cliqueNum s","decl":"lemma exists_isNClique_cliqueNum [Fintype α] : ∃ s, G.IsNClique G.cliqueNum s :=\n  Nat.sSup_mem ⟨0, by simp [isNClique_empty.mpr rfl]⟩ G.fintype_cliqueNum_bddAbove\n\n"}
{"name":"SimpleGraph.IsMaximumClique.maximum","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\ninst✝ : Fintype α\nG : SimpleGraph α\ns : Finset α\nself : G.IsMaximumClique s\nt : Finset α\na✝ : G.IsClique ↑t\n⊢ LE.le t.card s.card","decl":"/-- A maximum clique in a graph `G` is a clique with the largest possible size. -/\nstructure IsMaximumClique [Fintype α] (G : SimpleGraph α) (s : Finset α) : Prop where\n  (isClique : G.IsClique s)\n  (maximum : ∀ t : Finset α, G.IsClique t → #t ≤ #s)\n\n"}
{"name":"SimpleGraph.IsMaximumClique.isClique","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\ninst✝ : Fintype α\nG : SimpleGraph α\ns : Finset α\nself : G.IsMaximumClique s\n⊢ G.IsClique ↑s","decl":"/-- A maximum clique in a graph `G` is a clique with the largest possible size. -/\nstructure IsMaximumClique [Fintype α] (G : SimpleGraph α) (s : Finset α) : Prop where\n  (isClique : G.IsClique s)\n  (maximum : ∀ t : Finset α, G.IsClique t → #t ≤ #s)\n\n"}
{"name":"SimpleGraph.isMaximumClique_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\nG : SimpleGraph α\ninst✝ : Fintype α\ns : Finset α\n⊢ Iff (G.IsMaximumClique s) (And (G.IsClique ↑s) (∀ (t : Finset α), G.IsClique ↑t → LE.le t.card s.card))","decl":"theorem isMaximumClique_iff [Fintype α] {s : Finset α} :\n    G.IsMaximumClique s ↔ G.IsClique s ∧ ∀ t : Finset α, G.IsClique t → #t ≤ #s :=\n  ⟨fun h ↦ ⟨h.1, h.2⟩, fun h ↦ ⟨h.1, h.2⟩⟩\n\n"}
{"name":"SimpleGraph.isMaximalClique_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\nG : SimpleGraph α\ns : Set α\n⊢ Iff (Maximal G.IsClique s) (And (G.IsClique s) (∀ (t : Set α), G.IsClique t → HasSubset.Subset s t → HasSubset.Subset t s))","decl":"/-- A maximal clique in a graph `G` is a clique that cannot be extended by adding more vertices. -/\ntheorem isMaximalClique_iff {s : Set α} :\n    Maximal G.IsClique s ↔ G.IsClique s ∧ ∀ t : Set α, G.IsClique t → s ⊆ t → t ⊆ s :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.IsMaximumClique.isMaximalClique","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\nG : SimpleGraph α\ninst✝ : Fintype α\ns : Finset α\nM : G.IsMaximumClique s\n⊢ Maximal G.IsClique ↑s","decl":"lemma IsMaximumClique.isMaximalClique [Fintype α] (s : Finset α) (M : G.IsMaximumClique s) :\n    Maximal G.IsClique s :=\n  ⟨ M.isClique,\n    fun t ht hsub => by\n      by_contra hc\n      have fint : Fintype t := ofFinite ↑t\n      have ne : s ≠ t.toFinset := fun a ↦ by subst a; simp_all[Set.coe_toFinset, not_true_eq_false]\n      have hle : #t.toFinset ≤ #s := M.maximum t.toFinset (by simp [Set.coe_toFinset, ht])\n      have hlt : #s < #t.toFinset :=\n        card_lt_card (ssubset_of_ne_of_subset ne (Set.subset_toFinset.mpr hsub))\n      exact lt_irrefl _ (lt_of_lt_of_le hlt hle) ⟩\n\n"}
{"name":"SimpleGraph.maximumClique_card_eq_cliqueNum","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\nG : SimpleGraph α\ninst✝ : Fintype α\ns : Finset α\nsm : G.IsMaximumClique s\n⊢ Eq s.card G.cliqueNum","decl":"lemma maximumClique_card_eq_cliqueNum [Fintype α] (s : Finset α) (sm : G.IsMaximumClique s) :\n    #s = G.cliqueNum := by\n  obtain ⟨sc, sm⟩ := sm\n  obtain ⟨t, tc, tcard⟩ := G.exists_isNClique_cliqueNum\n  exact eq_of_le_of_not_lt sc.card_le_cliqueNum (by simp [← tcard, sm t tc])\n\n"}
{"name":"SimpleGraph.maximumClique_exists","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\nG : SimpleGraph α\ninst✝ : Fintype α\n⊢ Exists fun s => G.IsMaximumClique s","decl":"lemma maximumClique_exists [Fintype α] : ∃ (s : Finset α), G.IsMaximumClique s := by\n  obtain ⟨s, snc⟩ := G.exists_isNClique_cliqueNum\n  exact ⟨s, ⟨snc.isClique, fun t ht => snc.card_eq.symm ▸ ht.card_le_cliqueNum⟩⟩\n\n"}
{"name":"SimpleGraph.mem_cliqueFinset_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ninst✝² : Fintype α\ninst✝¹ : DecidableEq α\ninst✝ : DecidableRel G.Adj\nn : Nat\ns : Finset α\n⊢ Iff (Membership.mem (G.cliqueFinset n) s) (G.IsNClique n s)","decl":"variable {G} in\n@[simp]\ntheorem mem_cliqueFinset_iff : s ∈ G.cliqueFinset n ↔ G.IsNClique n s :=\n  mem_filter.trans <| and_iff_right <| mem_univ _\n\n"}
{"name":"SimpleGraph.coe_cliqueFinset","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ninst✝² : Fintype α\ninst✝¹ : DecidableEq α\ninst✝ : DecidableRel G.Adj\nn : Nat\n⊢ Eq (↑(G.cliqueFinset n)) (G.cliqueSet n)","decl":"@[simp, norm_cast]\ntheorem coe_cliqueFinset (n : ℕ) : (G.cliqueFinset n : Set (Finset α)) = G.cliqueSet n :=\n  Set.ext fun _ ↦ mem_cliqueFinset_iff\n\n"}
{"name":"SimpleGraph.cliqueFinset_eq_empty_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ninst✝² : Fintype α\ninst✝¹ : DecidableEq α\ninst✝ : DecidableRel G.Adj\nn : Nat\n⊢ Iff (Eq (G.cliqueFinset n) EmptyCollection.emptyCollection) (G.CliqueFree n)","decl":"@[simp]\ntheorem cliqueFinset_eq_empty_iff : G.cliqueFinset n = ∅ ↔ G.CliqueFree n := by\n  simp_rw [CliqueFree, eq_empty_iff_forall_not_mem, mem_cliqueFinset_iff]\n\n"}
{"name":"SimpleGraph.CliqueFree.cliqueFinset","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ninst✝² : Fintype α\ninst✝¹ : DecidableEq α\ninst✝ : DecidableRel G.Adj\nn : Nat\na✝ : G.CliqueFree n\n⊢ Eq (G.cliqueFinset n) EmptyCollection.emptyCollection","decl":"protected alias ⟨_, CliqueFree.cliqueFinset⟩ := cliqueFinset_eq_empty_iff\n\n"}
{"name":"SimpleGraph.card_cliqueFinset_le","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ninst✝² : Fintype α\ninst✝¹ : DecidableEq α\ninst✝ : DecidableRel G.Adj\nn : Nat\n⊢ LE.le (G.cliqueFinset n).card ((Fintype.card α).choose n)","decl":"theorem card_cliqueFinset_le : #(G.cliqueFinset n) ≤ (card α).choose n := by\n  rw [← card_univ, ← card_powersetCard]\n  refine card_mono fun s => ?_\n  simpa [mem_powersetCard_univ] using IsNClique.card_eq\n\n"}
{"name":"SimpleGraph.cliqueFinset_mono","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG H : SimpleGraph α\ninst✝³ : Fintype α\ninst✝² : DecidableEq α\ninst✝¹ : DecidableRel G.Adj\nn : Nat\ninst✝ : DecidableRel H.Adj\nh : LE.le G H\n⊢ HasSubset.Subset (G.cliqueFinset n) (H.cliqueFinset n)","decl":"@[gcongr, mono]\ntheorem cliqueFinset_mono (h : G ≤ H) : G.cliqueFinset n ⊆ H.cliqueFinset n :=\n  monotone_filter_right _ fun _ ↦ IsNClique.mono h\n\n"}
{"name":"SimpleGraph.cliqueFinset_map","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\ninst✝⁴ : Fintype α\ninst✝³ : DecidableEq α\ninst✝² : DecidableRel G.Adj\nn : Nat\ninst✝¹ : Fintype β\ninst✝ : DecidableEq β\nf : Function.Embedding α β\nhn : Ne n 1\n⊢ Eq ((SimpleGraph.map f G).cliqueFinset n) (Finset.map { toFun := Finset.map f, inj' := ⋯ } (G.cliqueFinset n))","decl":"@[simp]\ntheorem cliqueFinset_map (f : α ↪ β) (hn : n ≠ 1) :\n    (G.map f).cliqueFinset n = (G.cliqueFinset n).map ⟨map f, Finset.map_injective _⟩ :=\n  coe_injective <| by\n    simp_rw [coe_cliqueFinset, cliqueSet_map hn, coe_map, coe_cliqueFinset, Embedding.coeFn_mk]\n\n"}
{"name":"SimpleGraph.cliqueFinset_map_of_equiv","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\ninst✝⁴ : Fintype α\ninst✝³ : DecidableEq α\ninst✝² : DecidableRel G.Adj\ninst✝¹ : Fintype β\ninst✝ : DecidableEq β\ne : Equiv α β\nn : Nat\n⊢ Eq ((SimpleGraph.map e.toEmbedding G).cliqueFinset n) (Finset.map { toFun := Finset.map e.toEmbedding, inj' := ⋯ } (G.cliqueFinset n))","decl":"@[simp]\ntheorem cliqueFinset_map_of_equiv (e : α ≃ β) (n : ℕ) :\n    (G.map e.toEmbedding).cliqueFinset n =\n      (G.cliqueFinset n).map ⟨map e.toEmbedding, Finset.map_injective _⟩ :=\n  coe_injective <| by push_cast; exact cliqueSet_map_of_equiv _ _ _\n\n"}
{"name":"SimpleGraph.isIndepSet_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ns : Set α\n⊢ Iff (G.IsIndepSet s) (s.Pairwise fun v w => Not (G.Adj v w))","decl":"theorem isIndepSet_iff : G.IsIndepSet s ↔ s.Pairwise (fun v w ↦ ¬G.Adj v w) :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.isClique_compl","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ns : Set α\n⊢ Iff ((HasCompl.compl G).IsClique s) (G.IsIndepSet s)","decl":"/-- An independent set is a clique in the complement graph and vice versa. -/\n@[simp] theorem isClique_compl : Gᶜ.IsClique s ↔ G.IsIndepSet s := by\n  rw [isIndepSet_iff, isClique_iff]; repeat rw [Set.Pairwise]\n  simp_all [compl_adj]\n\n"}
{"name":"SimpleGraph.isIndepSet_compl","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ns : Set α\n⊢ Iff ((HasCompl.compl G).IsIndepSet s) (G.IsClique s)","decl":"/-- An independent set in the complement graph is a clique and vice versa. -/\n@[simp] theorem isIndepSet_compl : Gᶜ.IsIndepSet s ↔ G.IsClique s := by\n  rw [isIndepSet_iff, isClique_iff]; repeat rw [Set.Pairwise]\n  simp_all [compl_adj]\n\n"}
{"name":"SimpleGraph.IsIndepSet.nonempty_mem_compl_mem_edge","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ns : Finset α\nindA : G.IsIndepSet ↑s\ne : Sym2 α\nhe : Membership.mem G.edgeSet e\n⊢ (Finset.filter (fun b => Membership.mem e b) (HasCompl.compl s)).Nonempty","decl":"/-- If `s` is an independent set, its complement meets every edge of `G`. -/\nlemma IsIndepSet.nonempty_mem_compl_mem_edge\n    [Fintype α] [DecidableEq α] {s : Finset α} (indA : G.IsIndepSet s) {e} (he : e ∈ G.edgeSet) :\n  { b ∈ sᶜ | b ∈ e }.Nonempty := by\n  obtain ⟨v , w⟩ := e\n  by_contra c\n  rw [IsIndepSet] at indA\n  rw [mem_edgeSet] at he\n  rw [not_nonempty_iff_eq_empty, filter_eq_empty_iff] at c\n  simp_rw [mem_compl, Sym2.mem_iff, not_or] at c\n  by_cases vins : v ∈ s\n  · have wins : w ∈ s := by by_contra wnins; exact (c wnins).right rfl\n    exact (indA vins wins (Adj.ne he)) he\n  · exact (c vins).left rfl\n\n"}
{"name":"SimpleGraph.isIndepSet_neighborSet_of_triangleFree","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ninst✝ : DecidableEq α\nh : G.CliqueFree 3\nv : α\n⊢ G.IsIndepSet (G.neighborSet v)","decl":"/-- The neighbors of a vertex `v` form an independent set in a triangle free graph `G`. -/\ntheorem isIndepSet_neighborSet_of_triangleFree [DecidableEq α] (h: G.CliqueFree 3) (v : α) :\n    G.IsIndepSet (G.neighborSet v) := by\n  by_contra nind\n  rw [IsIndepSet, Set.Pairwise] at nind\n  push_neg at nind\n  simp_rw [mem_neighborSet] at nind\n  obtain ⟨j, avj, k, avk, _, ajk⟩ := nind\n  exact h {v, j, k} (is3Clique_triple_iff.mpr (by simp [avj, avk, ajk]))\n\n"}
{"name":"SimpleGraph.isNIndepSet_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\ns : Finset α\n⊢ Iff (G.IsNIndepSet n s) (And (G.IsIndepSet ↑s) (Eq s.card n))","decl":"/-- An `n`-independent set in a graph is a set of `n` vertices which are pairwise nonadjacent. -/\n@[mk_iff]\nstructure IsNIndepSet (n : ℕ) (s : Finset α) : Prop where\n  isIndepSet : G.IsIndepSet s\n  card_eq : s.card = n\n\n"}
{"name":"SimpleGraph.IsNIndepSet.isIndepSet","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\ns : Finset α\nself : G.IsNIndepSet n s\n⊢ G.IsIndepSet ↑s","decl":"/-- An `n`-independent set in a graph is a set of `n` vertices which are pairwise nonadjacent. -/\n@[mk_iff]\nstructure IsNIndepSet (n : ℕ) (s : Finset α) : Prop where\n  isIndepSet : G.IsIndepSet s\n  card_eq : s.card = n\n\n"}
{"name":"SimpleGraph.IsNIndepSet.card_eq","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\ns : Finset α\nself : G.IsNIndepSet n s\n⊢ Eq s.card n","decl":"/-- An `n`-independent set in a graph is a set of `n` vertices which are pairwise nonadjacent. -/\n@[mk_iff]\nstructure IsNIndepSet (n : ℕ) (s : Finset α) : Prop where\n  isIndepSet : G.IsIndepSet s\n  card_eq : s.card = n\n\n"}
{"name":"SimpleGraph.isNClique_compl","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\ns : Finset α\n⊢ Iff ((HasCompl.compl G).IsNClique n s) (G.IsNIndepSet n s)","decl":"/-- An `n`-independent set is an `n`-clique in the complement graph and vice versa. -/\n@[simp] theorem isNClique_compl : Gᶜ.IsNClique n s ↔ G.IsNIndepSet n s := by\n  rw [isNIndepSet_iff]\n  simp [isNClique_iff]\n\n"}
{"name":"SimpleGraph.isNIndepSet_compl","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\ns : Finset α\n⊢ Iff ((HasCompl.compl G).IsNIndepSet n s) (G.IsNClique n s)","decl":"/-- An `n`-independent set in the complement graph is an `n`-clique and vice versa. -/\n@[simp] theorem isNIndepSet_compl : Gᶜ.IsNIndepSet n s ↔ G.IsNClique n s := by\n  rw [isNClique_iff]\n  simp [isNIndepSet_iff]\n\n"}
{"name":"SimpleGraph.cliqueFree_compl","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\n⊢ Iff ((HasCompl.compl G).CliqueFree n) (G.IndepSetFree n)","decl":"/-- An graph is `n`-independent set free iff its complement is `n`-clique free. -/\n@[simp] theorem cliqueFree_compl : Gᶜ.CliqueFree n ↔ G.IndepSetFree n := by\n  simp [IndepSetFree, CliqueFree]\n\n"}
{"name":"SimpleGraph.indepSetFree_compl","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\n⊢ Iff ((HasCompl.compl G).IndepSetFree n) (G.CliqueFree n)","decl":"/-- An graph's complement is `n`-independent set free iff it is `n`-clique free. -/\n@[simp] theorem indepSetFree_compl : Gᶜ.IndepSetFree n ↔ G.CliqueFree n := by\n  simp [IndepSetFree, CliqueFree]\n\n"}
{"name":"SimpleGraph.mem_indepSetSet_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : Nat\ns : Finset α\n⊢ Iff (Membership.mem (G.indepSetSet n) s) (G.IsNIndepSet n s)","decl":"@[simp]\ntheorem mem_indepSetSet_iff : s ∈ G.indepSetSet n ↔ G.IsNIndepSet n s :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.cliqueNum_compl","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\nG : SimpleGraph α\n⊢ Eq (HasCompl.compl G).cliqueNum G.indepNum","decl":"@[simp] lemma cliqueNum_compl : Gᶜ.cliqueNum = G.indepNum := by\n  simp [indepNum, cliqueNum]\n\n"}
{"name":"SimpleGraph.indepNum_compl","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\nG : SimpleGraph α\n⊢ Eq (HasCompl.compl G).indepNum G.cliqueNum","decl":"@[simp] lemma indepNum_compl : Gᶜ.indepNum = G.cliqueNum := by\n  simp [indepNum, cliqueNum]\n\n"}
{"name":"SimpleGraph.IsIndepSet.card_le_indepNum","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\nG : SimpleGraph α\ninst✝ : Fintype α\nt : Finset α\ntc : G.IsIndepSet ↑t\n⊢ LE.le t.card G.indepNum","decl":"theorem IsIndepSet.card_le_indepNum\n    [Fintype α] {t : Finset α} (tc : G.IsIndepSet t) : #t ≤ G.indepNum := by\n  rw[← isClique_compl] at tc\n  simp_rw [indepNum, ← isNClique_compl]\n  exact tc.card_le_cliqueNum\n\n"}
{"name":"SimpleGraph.exists_isNIndepSet_indepNum","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\nG : SimpleGraph α\ninst✝ : Fintype α\n⊢ Exists fun s => G.IsNIndepSet G.indepNum s","decl":"lemma exists_isNIndepSet_indepNum [Fintype α] : ∃ s, G.IsNIndepSet G.indepNum s := by\n  simp_rw [indepNum, ← isNClique_compl]\n  exact exists_isNClique_cliqueNum\n\n"}
{"name":"SimpleGraph.isMaximumIndepSet_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\ninst✝ : Fintype α\nG : SimpleGraph α\ns : Finset α\n⊢ Iff (G.IsMaximumIndepSet s) (And (G.IsIndepSet ↑s) (∀ (t : Finset α), G.IsIndepSet ↑t → LE.le t.card s.card))","decl":"/-- An independent set in a graph `G` such that there is no independent set with more vertices. -/\n@[mk_iff]\nstructure IsMaximumIndepSet [Fintype α] (G : SimpleGraph α) (s : Finset α) : Prop where\n  isIndepSet : G.IsIndepSet s\n  maximum : ∀ t : Finset α, G.IsIndepSet t → #t ≤ #s\n\n"}
{"name":"SimpleGraph.IsMaximumIndepSet.maximum","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\ninst✝ : Fintype α\nG : SimpleGraph α\ns : Finset α\nself : G.IsMaximumIndepSet s\nt : Finset α\na✝ : G.IsIndepSet ↑t\n⊢ LE.le t.card s.card","decl":"/-- An independent set in a graph `G` such that there is no independent set with more vertices. -/\n@[mk_iff]\nstructure IsMaximumIndepSet [Fintype α] (G : SimpleGraph α) (s : Finset α) : Prop where\n  isIndepSet : G.IsIndepSet s\n  maximum : ∀ t : Finset α, G.IsIndepSet t → #t ≤ #s\n\n"}
{"name":"SimpleGraph.IsMaximumIndepSet.isIndepSet","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\ninst✝ : Fintype α\nG : SimpleGraph α\ns : Finset α\nself : G.IsMaximumIndepSet s\n⊢ G.IsIndepSet ↑s","decl":"/-- An independent set in a graph `G` such that there is no independent set with more vertices. -/\n@[mk_iff]\nstructure IsMaximumIndepSet [Fintype α] (G : SimpleGraph α) (s : Finset α) : Prop where\n  isIndepSet : G.IsIndepSet s\n  maximum : ∀ t : Finset α, G.IsIndepSet t → #t ≤ #s\n\n"}
{"name":"SimpleGraph.isMaximumClique_compl","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\nG : SimpleGraph α\ninst✝ : Fintype α\ns : Finset α\n⊢ Iff ((HasCompl.compl G).IsMaximumClique s) (G.IsMaximumIndepSet s)","decl":"@[simp] lemma isMaximumClique_compl [Fintype α] (s : Finset α) :\n    Gᶜ.IsMaximumClique s ↔ G.IsMaximumIndepSet s := by\n  simp [isMaximumIndepSet_iff, isMaximumClique_iff]\n\n"}
{"name":"SimpleGraph.isMaximumIndepSet_compl","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\nG : SimpleGraph α\ninst✝ : Fintype α\ns : Finset α\n⊢ Iff ((HasCompl.compl G).IsMaximumIndepSet s) (G.IsMaximumClique s)","decl":"@[simp] lemma isMaximumIndepSet_compl [Fintype α] (s : Finset α) :\n    Gᶜ.IsMaximumIndepSet s ↔ G.IsMaximumClique s := by\n  simp [isMaximumIndepSet_iff, isMaximumClique_iff]\n\n"}
{"name":"SimpleGraph.isMaximalIndepSet_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\nG : SimpleGraph α\ns : Set α\n⊢ Iff (Maximal G.IsIndepSet s) (And (G.IsIndepSet s) (∀ (t : Set α), G.IsIndepSet t → HasSubset.Subset s t → HasSubset.Subset t s))","decl":"/-- An independent set in a graph `G` that cannot be extended by adding more vertices. -/\ntheorem isMaximalIndepSet_iff {s : Set α} :\n    Maximal G.IsIndepSet s ↔ G.IsIndepSet s ∧ ∀ t : Set α, G.IsIndepSet t → s ⊆ t → t ⊆ s :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.isMaximalClique_compl","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\nG : SimpleGraph α\ns : Finset α\n⊢ Iff (Maximal (HasCompl.compl G).IsClique ↑s) (Maximal G.IsIndepSet ↑s)","decl":"@[simp] lemma isMaximalClique_compl (s : Finset α) :\n    Maximal Gᶜ.IsClique s ↔ Maximal G.IsIndepSet s := by\n  simp [isMaximalIndepSet_iff, isMaximalClique_iff]\n\n"}
{"name":"SimpleGraph.isMaximalIndepSet_compl","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\nG : SimpleGraph α\ns : Finset α\n⊢ Iff (Maximal (HasCompl.compl G).IsIndepSet ↑s) (Maximal G.IsClique ↑s)","decl":"@[simp] lemma isMaximalIndepSet_compl (s : Finset α) :\n    Maximal Gᶜ.IsIndepSet s ↔ Maximal G.IsClique s := by\n  simp [isMaximalIndepSet_iff, isMaximalClique_iff]\n\n"}
{"name":"SimpleGraph.IsMaximumIndepSet.isMaximalIndepSet","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\nG : SimpleGraph α\ninst✝ : Fintype α\ns : Finset α\nM : G.IsMaximumIndepSet s\n⊢ Maximal G.IsIndepSet ↑s","decl":"lemma IsMaximumIndepSet.isMaximalIndepSet\n    [Fintype α] (s : Finset α) (M : G.IsMaximumIndepSet s) : Maximal G.IsIndepSet s := by\n  rw [← isMaximalClique_compl]\n  rw [← isMaximumClique_compl] at M\n  exact IsMaximumClique.isMaximalClique s M\n\n"}
{"name":"SimpleGraph.maximumIndepSet_card_eq_indepNum","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\nG : SimpleGraph α\ninst✝ : Fintype α\nt : Finset α\ntmc : G.IsMaximumIndepSet t\n⊢ Eq t.card G.indepNum","decl":"theorem maximumIndepSet_card_eq_indepNum\n    [Fintype α] (t : Finset α) (tmc : G.IsMaximumIndepSet t) : #t = G.indepNum := by\n  rw [← isMaximumClique_compl] at tmc\n  simp_rw [indepNum, ← isNClique_compl]\n  exact Gᶜ.maximumClique_card_eq_cliqueNum t tmc\n\n"}
{"name":"SimpleGraph.maximumIndepSet_exists","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_3\nG : SimpleGraph α\ninst✝ : Fintype α\n⊢ Exists fun s => G.IsMaximumIndepSet s","decl":"lemma maximumIndepSet_exists [Fintype α] : ∃ (s : Finset α), G.IsMaximumIndepSet s := by\n  simp [← isMaximumClique_compl, maximumClique_exists]\n\n"}
{"name":"SimpleGraph.mem_indepSetFinset_iff","module":"Mathlib.Combinatorics.SimpleGraph.Clique","initialProofState":"α : Type u_1\nG : SimpleGraph α\ninst✝² : Fintype α\ninst✝¹ : DecidableEq α\ninst✝ : DecidableRel G.Adj\nn : Nat\ns : Finset α\n⊢ Iff (Membership.mem (G.indepSetFinset n) s) (G.IsNIndepSet n s)","decl":"variable {G} in\n@[simp]\ntheorem mem_indepSetFinset_iff : s ∈ G.indepSetFinset n ↔ G.IsNIndepSet n s :=\n  mem_filter.trans <| and_iff_right <| mem_univ _\n\n"}
