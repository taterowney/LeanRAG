{"name":"StructureGroupoid.locality'","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nself : StructureGroupoid H\ne : PartialHomeomorph H H\na✝ : ∀ (x : H), Membership.mem e.source x → Exists fun s => And (IsOpen s) (And (Membership.mem s x) (Membership.mem self.members (e.restr s)))\n⊢ Membership.mem self.members e","decl":"/-- A structure groupoid is a set of partial homeomorphisms of a topological space stable under\ncomposition and inverse. They appear in the definition of the smoothness class of a manifold. -/\nstructure StructureGroupoid (H : Type u) [TopologicalSpace H] where\n  /-- Members of the structure groupoid are partial homeomorphisms. -/\n  members : Set (PartialHomeomorph H H)\n  /-- Structure groupoids are stable under composition. -/\n  trans' : ∀ e e' : PartialHomeomorph H H, e ∈ members → e' ∈ members → e ≫ₕ e' ∈ members\n  /-- Structure groupoids are stable under inverse. -/\n  symm' : ∀ e : PartialHomeomorph H H, e ∈ members → e.symm ∈ members\n  /-- The identity morphism lies in the structure groupoid. -/\n  id_mem' : PartialHomeomorph.refl H ∈ members\n  /-- Let `e` be a partial homeomorphism. If for every `x ∈ e.source`, the restriction of e to some\n  open set around `x` lies in the groupoid, then `e` lies in the groupoid. -/\n  locality' : ∀ e : PartialHomeomorph H H,\n    (∀ x ∈ e.source, ∃ s, IsOpen s ∧ x ∈ s ∧ e.restr s ∈ members) → e ∈ members\n  /-- Membership in a structure groupoid respects the equivalence of partial homeomorphisms. -/\n  mem_of_eqOnSource' : ∀ e e' : PartialHomeomorph H H, e ∈ members → e' ≈ e → e' ∈ members\n\n"}
{"name":"StructureGroupoid.mk.injEq","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nmembers✝ : Set (PartialHomeomorph H H)\ntrans'✝ : ∀ (e e' : PartialHomeomorph H H), Membership.mem members✝ e → Membership.mem members✝ e' → Membership.mem members✝ (e.trans e')\nsymm'✝ : ∀ (e : PartialHomeomorph H H), Membership.mem members✝ e → Membership.mem members✝ e.symm\nid_mem'✝ : Membership.mem members✝ (PartialHomeomorph.refl H)\nlocality'✝ : ∀ (e : PartialHomeomorph H H), (∀ (x : H), Membership.mem e.source x → Exists fun s => And (IsOpen s) (And (Membership.mem s x) (Membership.mem members✝ (e.restr s)))) → Membership.mem members✝ e\nmem_of_eqOnSource'✝ : ∀ (e e' : PartialHomeomorph H H), Membership.mem members✝ e → HasEquiv.Equiv e' e → Membership.mem members✝ e'\nmembers : Set (PartialHomeomorph H H)\ntrans' : ∀ (e e' : PartialHomeomorph H H), Membership.mem members e → Membership.mem members e' → Membership.mem members (e.trans e')\nsymm' : ∀ (e : PartialHomeomorph H H), Membership.mem members e → Membership.mem members e.symm\nid_mem' : Membership.mem members (PartialHomeomorph.refl H)\nlocality' : ∀ (e : PartialHomeomorph H H), (∀ (x : H), Membership.mem e.source x → Exists fun s => And (IsOpen s) (And (Membership.mem s x) (Membership.mem members (e.restr s)))) → Membership.mem members e\nmem_of_eqOnSource' : ∀ (e e' : PartialHomeomorph H H), Membership.mem members e → HasEquiv.Equiv e' e → Membership.mem members e'\n⊢ Eq (Eq { members := members✝, trans' := trans'✝, symm' := symm'✝, id_mem' := id_mem'✝, locality' := locality'✝, mem_of_eqOnSource' := mem_of_eqOnSource'✝ } { members := members, trans' := trans', symm' := symm', id_mem' := id_mem', locality' := locality', mem_of_eqOnSource' := mem_of_eqOnSource' }) (Eq members✝ members)","decl":"/-- A structure groupoid is a set of partial homeomorphisms of a topological space stable under\ncomposition and inverse. They appear in the definition of the smoothness class of a manifold. -/\nstructure StructureGroupoid (H : Type u) [TopologicalSpace H] where\n  /-- Members of the structure groupoid are partial homeomorphisms. -/\n  members : Set (PartialHomeomorph H H)\n  /-- Structure groupoids are stable under composition. -/\n  trans' : ∀ e e' : PartialHomeomorph H H, e ∈ members → e' ∈ members → e ≫ₕ e' ∈ members\n  /-- Structure groupoids are stable under inverse. -/\n  symm' : ∀ e : PartialHomeomorph H H, e ∈ members → e.symm ∈ members\n  /-- The identity morphism lies in the structure groupoid. -/\n  id_mem' : PartialHomeomorph.refl H ∈ members\n  /-- Let `e` be a partial homeomorphism. If for every `x ∈ e.source`, the restriction of e to some\n  open set around `x` lies in the groupoid, then `e` lies in the groupoid. -/\n  locality' : ∀ e : PartialHomeomorph H H,\n    (∀ x ∈ e.source, ∃ s, IsOpen s ∧ x ∈ s ∧ e.restr s ∈ members) → e ∈ members\n  /-- Membership in a structure groupoid respects the equivalence of partial homeomorphisms. -/\n  mem_of_eqOnSource' : ∀ e e' : PartialHomeomorph H H, e ∈ members → e' ≈ e → e' ∈ members\n\n"}
{"name":"StructureGroupoid.mk.sizeOf_spec","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝¹ : TopologicalSpace H\ninst✝ : SizeOf H\nmembers : Set (PartialHomeomorph H H)\ntrans' : ∀ (e e' : PartialHomeomorph H H), Membership.mem members e → Membership.mem members e' → Membership.mem members (e.trans e')\nsymm' : ∀ (e : PartialHomeomorph H H), Membership.mem members e → Membership.mem members e.symm\nid_mem' : Membership.mem members (PartialHomeomorph.refl H)\nlocality' : ∀ (e : PartialHomeomorph H H), (∀ (x : H), Membership.mem e.source x → Exists fun s => And (IsOpen s) (And (Membership.mem s x) (Membership.mem members (e.restr s)))) → Membership.mem members e\nmem_of_eqOnSource' : ∀ (e e' : PartialHomeomorph H H), Membership.mem members e → HasEquiv.Equiv e' e → Membership.mem members e'\n⊢ Eq (SizeOf.sizeOf { members := members, trans' := trans', symm' := symm', id_mem' := id_mem', locality' := locality', mem_of_eqOnSource' := mem_of_eqOnSource' }) (HAdd.hAdd 1 (SizeOf.sizeOf id_mem'))","decl":"/-- A structure groupoid is a set of partial homeomorphisms of a topological space stable under\ncomposition and inverse. They appear in the definition of the smoothness class of a manifold. -/\nstructure StructureGroupoid (H : Type u) [TopologicalSpace H] where\n  /-- Members of the structure groupoid are partial homeomorphisms. -/\n  members : Set (PartialHomeomorph H H)\n  /-- Structure groupoids are stable under composition. -/\n  trans' : ∀ e e' : PartialHomeomorph H H, e ∈ members → e' ∈ members → e ≫ₕ e' ∈ members\n  /-- Structure groupoids are stable under inverse. -/\n  symm' : ∀ e : PartialHomeomorph H H, e ∈ members → e.symm ∈ members\n  /-- The identity morphism lies in the structure groupoid. -/\n  id_mem' : PartialHomeomorph.refl H ∈ members\n  /-- Let `e` be a partial homeomorphism. If for every `x ∈ e.source`, the restriction of e to some\n  open set around `x` lies in the groupoid, then `e` lies in the groupoid. -/\n  locality' : ∀ e : PartialHomeomorph H H,\n    (∀ x ∈ e.source, ∃ s, IsOpen s ∧ x ∈ s ∧ e.restr s ∈ members) → e ∈ members\n  /-- Membership in a structure groupoid respects the equivalence of partial homeomorphisms. -/\n  mem_of_eqOnSource' : ∀ e e' : PartialHomeomorph H H, e ∈ members → e' ≈ e → e' ∈ members\n\n"}
{"name":"StructureGroupoid.mem_of_eqOnSource'","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nself : StructureGroupoid H\ne e' : PartialHomeomorph H H\na✝¹ : Membership.mem self.members e\na✝ : HasEquiv.Equiv e' e\n⊢ Membership.mem self.members e'","decl":"/-- A structure groupoid is a set of partial homeomorphisms of a topological space stable under\ncomposition and inverse. They appear in the definition of the smoothness class of a manifold. -/\nstructure StructureGroupoid (H : Type u) [TopologicalSpace H] where\n  /-- Members of the structure groupoid are partial homeomorphisms. -/\n  members : Set (PartialHomeomorph H H)\n  /-- Structure groupoids are stable under composition. -/\n  trans' : ∀ e e' : PartialHomeomorph H H, e ∈ members → e' ∈ members → e ≫ₕ e' ∈ members\n  /-- Structure groupoids are stable under inverse. -/\n  symm' : ∀ e : PartialHomeomorph H H, e ∈ members → e.symm ∈ members\n  /-- The identity morphism lies in the structure groupoid. -/\n  id_mem' : PartialHomeomorph.refl H ∈ members\n  /-- Let `e` be a partial homeomorphism. If for every `x ∈ e.source`, the restriction of e to some\n  open set around `x` lies in the groupoid, then `e` lies in the groupoid. -/\n  locality' : ∀ e : PartialHomeomorph H H,\n    (∀ x ∈ e.source, ∃ s, IsOpen s ∧ x ∈ s ∧ e.restr s ∈ members) → e ∈ members\n  /-- Membership in a structure groupoid respects the equivalence of partial homeomorphisms. -/\n  mem_of_eqOnSource' : ∀ e e' : PartialHomeomorph H H, e ∈ members → e' ≈ e → e' ∈ members\n\n"}
{"name":"StructureGroupoid.mk.inj","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nmembers✝ : Set (PartialHomeomorph H H)\ntrans'✝ : ∀ (e e' : PartialHomeomorph H H), Membership.mem members✝ e → Membership.mem members✝ e' → Membership.mem members✝ (e.trans e')\nsymm'✝ : ∀ (e : PartialHomeomorph H H), Membership.mem members✝ e → Membership.mem members✝ e.symm\nid_mem'✝ : Membership.mem members✝ (PartialHomeomorph.refl H)\nlocality'✝ : ∀ (e : PartialHomeomorph H H), (∀ (x : H), Membership.mem e.source x → Exists fun s => And (IsOpen s) (And (Membership.mem s x) (Membership.mem members✝ (e.restr s)))) → Membership.mem members✝ e\nmem_of_eqOnSource'✝ : ∀ (e e' : PartialHomeomorph H H), Membership.mem members✝ e → HasEquiv.Equiv e' e → Membership.mem members✝ e'\nmembers : Set (PartialHomeomorph H H)\ntrans' : ∀ (e e' : PartialHomeomorph H H), Membership.mem members e → Membership.mem members e' → Membership.mem members (e.trans e')\nsymm' : ∀ (e : PartialHomeomorph H H), Membership.mem members e → Membership.mem members e.symm\nid_mem' : Membership.mem members (PartialHomeomorph.refl H)\nlocality' : ∀ (e : PartialHomeomorph H H), (∀ (x : H), Membership.mem e.source x → Exists fun s => And (IsOpen s) (And (Membership.mem s x) (Membership.mem members (e.restr s)))) → Membership.mem members e\nmem_of_eqOnSource' : ∀ (e e' : PartialHomeomorph H H), Membership.mem members e → HasEquiv.Equiv e' e → Membership.mem members e'\nx✝ : Eq { members := members✝, trans' := trans'✝, symm' := symm'✝, id_mem' := id_mem'✝, locality' := locality'✝, mem_of_eqOnSource' := mem_of_eqOnSource'✝ } { members := members, trans' := trans', symm' := symm', id_mem' := id_mem', locality' := locality', mem_of_eqOnSource' := mem_of_eqOnSource' }\n⊢ Eq members✝ members","decl":"/-- A structure groupoid is a set of partial homeomorphisms of a topological space stable under\ncomposition and inverse. They appear in the definition of the smoothness class of a manifold. -/\nstructure StructureGroupoid (H : Type u) [TopologicalSpace H] where\n  /-- Members of the structure groupoid are partial homeomorphisms. -/\n  members : Set (PartialHomeomorph H H)\n  /-- Structure groupoids are stable under composition. -/\n  trans' : ∀ e e' : PartialHomeomorph H H, e ∈ members → e' ∈ members → e ≫ₕ e' ∈ members\n  /-- Structure groupoids are stable under inverse. -/\n  symm' : ∀ e : PartialHomeomorph H H, e ∈ members → e.symm ∈ members\n  /-- The identity morphism lies in the structure groupoid. -/\n  id_mem' : PartialHomeomorph.refl H ∈ members\n  /-- Let `e` be a partial homeomorphism. If for every `x ∈ e.source`, the restriction of e to some\n  open set around `x` lies in the groupoid, then `e` lies in the groupoid. -/\n  locality' : ∀ e : PartialHomeomorph H H,\n    (∀ x ∈ e.source, ∃ s, IsOpen s ∧ x ∈ s ∧ e.restr s ∈ members) → e ∈ members\n  /-- Membership in a structure groupoid respects the equivalence of partial homeomorphisms. -/\n  mem_of_eqOnSource' : ∀ e e' : PartialHomeomorph H H, e ∈ members → e' ≈ e → e' ∈ members\n\n"}
{"name":"StructureGroupoid.id_mem'","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nself : StructureGroupoid H\n⊢ Membership.mem self.members (PartialHomeomorph.refl H)","decl":"/-- A structure groupoid is a set of partial homeomorphisms of a topological space stable under\ncomposition and inverse. They appear in the definition of the smoothness class of a manifold. -/\nstructure StructureGroupoid (H : Type u) [TopologicalSpace H] where\n  /-- Members of the structure groupoid are partial homeomorphisms. -/\n  members : Set (PartialHomeomorph H H)\n  /-- Structure groupoids are stable under composition. -/\n  trans' : ∀ e e' : PartialHomeomorph H H, e ∈ members → e' ∈ members → e ≫ₕ e' ∈ members\n  /-- Structure groupoids are stable under inverse. -/\n  symm' : ∀ e : PartialHomeomorph H H, e ∈ members → e.symm ∈ members\n  /-- The identity morphism lies in the structure groupoid. -/\n  id_mem' : PartialHomeomorph.refl H ∈ members\n  /-- Let `e` be a partial homeomorphism. If for every `x ∈ e.source`, the restriction of e to some\n  open set around `x` lies in the groupoid, then `e` lies in the groupoid. -/\n  locality' : ∀ e : PartialHomeomorph H H,\n    (∀ x ∈ e.source, ∃ s, IsOpen s ∧ x ∈ s ∧ e.restr s ∈ members) → e ∈ members\n  /-- Membership in a structure groupoid respects the equivalence of partial homeomorphisms. -/\n  mem_of_eqOnSource' : ∀ e e' : PartialHomeomorph H H, e ∈ members → e' ≈ e → e' ∈ members\n\n"}
{"name":"StructureGroupoid.trans'","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nself : StructureGroupoid H\ne e' : PartialHomeomorph H H\na✝¹ : Membership.mem self.members e\na✝ : Membership.mem self.members e'\n⊢ Membership.mem self.members (e.trans e')","decl":"/-- A structure groupoid is a set of partial homeomorphisms of a topological space stable under\ncomposition and inverse. They appear in the definition of the smoothness class of a manifold. -/\nstructure StructureGroupoid (H : Type u) [TopologicalSpace H] where\n  /-- Members of the structure groupoid are partial homeomorphisms. -/\n  members : Set (PartialHomeomorph H H)\n  /-- Structure groupoids are stable under composition. -/\n  trans' : ∀ e e' : PartialHomeomorph H H, e ∈ members → e' ∈ members → e ≫ₕ e' ∈ members\n  /-- Structure groupoids are stable under inverse. -/\n  symm' : ∀ e : PartialHomeomorph H H, e ∈ members → e.symm ∈ members\n  /-- The identity morphism lies in the structure groupoid. -/\n  id_mem' : PartialHomeomorph.refl H ∈ members\n  /-- Let `e` be a partial homeomorphism. If for every `x ∈ e.source`, the restriction of e to some\n  open set around `x` lies in the groupoid, then `e` lies in the groupoid. -/\n  locality' : ∀ e : PartialHomeomorph H H,\n    (∀ x ∈ e.source, ∃ s, IsOpen s ∧ x ∈ s ∧ e.restr s ∈ members) → e ∈ members\n  /-- Membership in a structure groupoid respects the equivalence of partial homeomorphisms. -/\n  mem_of_eqOnSource' : ∀ e e' : PartialHomeomorph H H, e ∈ members → e' ≈ e → e' ∈ members\n\n"}
{"name":"StructureGroupoid.symm'","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nself : StructureGroupoid H\ne : PartialHomeomorph H H\na✝ : Membership.mem self.members e\n⊢ Membership.mem self.members e.symm","decl":"/-- A structure groupoid is a set of partial homeomorphisms of a topological space stable under\ncomposition and inverse. They appear in the definition of the smoothness class of a manifold. -/\nstructure StructureGroupoid (H : Type u) [TopologicalSpace H] where\n  /-- Members of the structure groupoid are partial homeomorphisms. -/\n  members : Set (PartialHomeomorph H H)\n  /-- Structure groupoids are stable under composition. -/\n  trans' : ∀ e e' : PartialHomeomorph H H, e ∈ members → e' ∈ members → e ≫ₕ e' ∈ members\n  /-- Structure groupoids are stable under inverse. -/\n  symm' : ∀ e : PartialHomeomorph H H, e ∈ members → e.symm ∈ members\n  /-- The identity morphism lies in the structure groupoid. -/\n  id_mem' : PartialHomeomorph.refl H ∈ members\n  /-- Let `e` be a partial homeomorphism. If for every `x ∈ e.source`, the restriction of e to some\n  open set around `x` lies in the groupoid, then `e` lies in the groupoid. -/\n  locality' : ∀ e : PartialHomeomorph H H,\n    (∀ x ∈ e.source, ∃ s, IsOpen s ∧ x ∈ s ∧ e.restr s ∈ members) → e ∈ members\n  /-- Membership in a structure groupoid respects the equivalence of partial homeomorphisms. -/\n  mem_of_eqOnSource' : ∀ e e' : PartialHomeomorph H H, e ∈ members → e' ≈ e → e' ∈ members\n\n"}
{"name":"StructureGroupoid.trans","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nG : StructureGroupoid H\ne e' : PartialHomeomorph H H\nhe : Membership.mem G e\nhe' : Membership.mem G e'\n⊢ Membership.mem G (e.trans e')","decl":"theorem StructureGroupoid.trans (G : StructureGroupoid H) {e e' : PartialHomeomorph H H}\n    (he : e ∈ G) (he' : e' ∈ G) : e ≫ₕ e' ∈ G :=\n  G.trans' e e' he he'\n\n"}
{"name":"StructureGroupoid.symm","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nG : StructureGroupoid H\ne : PartialHomeomorph H H\nhe : Membership.mem G e\n⊢ Membership.mem G e.symm","decl":"theorem StructureGroupoid.symm (G : StructureGroupoid H) {e : PartialHomeomorph H H} (he : e ∈ G) :\n    e.symm ∈ G :=\n  G.symm' e he\n\n"}
{"name":"StructureGroupoid.id_mem","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nG : StructureGroupoid H\n⊢ Membership.mem G (PartialHomeomorph.refl H)","decl":"theorem StructureGroupoid.id_mem (G : StructureGroupoid H) : PartialHomeomorph.refl H ∈ G :=\n  G.id_mem'\n\n"}
{"name":"StructureGroupoid.locality","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nG : StructureGroupoid H\ne : PartialHomeomorph H H\nh : ∀ (x : H), Membership.mem e.source x → Exists fun s => And (IsOpen s) (And (Membership.mem s x) (Membership.mem G (e.restr s)))\n⊢ Membership.mem G e","decl":"theorem StructureGroupoid.locality (G : StructureGroupoid H) {e : PartialHomeomorph H H}\n    (h : ∀ x ∈ e.source, ∃ s, IsOpen s ∧ x ∈ s ∧ e.restr s ∈ G) : e ∈ G :=\n  G.locality' e h\n\n"}
{"name":"StructureGroupoid.mem_of_eqOnSource","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nG : StructureGroupoid H\ne e' : PartialHomeomorph H H\nhe : Membership.mem G e\nh : HasEquiv.Equiv e' e\n⊢ Membership.mem G e'","decl":"theorem StructureGroupoid.mem_of_eqOnSource (G : StructureGroupoid H) {e e' : PartialHomeomorph H H}\n    (he : e ∈ G) (h : e' ≈ e) : e' ∈ G :=\n  G.mem_of_eqOnSource' e e' he h\n\n"}
{"name":"StructureGroupoid.mem_iff_of_eqOnSource","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nG : StructureGroupoid H\ne e' : PartialHomeomorph H H\nh : HasEquiv.Equiv e e'\n⊢ Iff (Membership.mem G e) (Membership.mem G e')","decl":"theorem StructureGroupoid.mem_iff_of_eqOnSource {G : StructureGroupoid H}\n    {e e' : PartialHomeomorph H H} (h : e ≈ e') : e ∈ G ↔ e' ∈ G :=\n  ⟨fun he ↦ G.mem_of_eqOnSource he (Setoid.symm h), fun he' ↦ G.mem_of_eqOnSource he' h⟩\n\n"}
{"name":"StructureGroupoid.le_iff","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nG₁ G₂ : StructureGroupoid H\n⊢ Iff (LE.le G₁ G₂) (∀ (e : PartialHomeomorph H H), Membership.mem G₁ e → Membership.mem G₂ e)","decl":"theorem StructureGroupoid.le_iff {G₁ G₂ : StructureGroupoid H} : G₁ ≤ G₂ ↔ ∀ e, e ∈ G₁ → e ∈ G₂ :=\n  Iff.rfl\n\n"}
{"name":"Pregroupoid.mk.inj","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝ : TopologicalSpace H\nproperty✝ : (H → H) → Set H → Prop\ncomp✝ : ∀ {f g : H → H} {u v : Set H}, property✝ f u → property✝ g v → IsOpen u → IsOpen v → IsOpen (Inter.inter u (Set.preimage f v)) → property✝ (Function.comp g f) (Inter.inter u (Set.preimage f v))\nid_mem✝ : property✝ id Set.univ\nlocality✝ : ∀ {f : H → H} {u : Set H}, IsOpen u → (∀ (x : H), Membership.mem u x → Exists fun v => And (IsOpen v) (And (Membership.mem v x) (property✝ f (Inter.inter u v)))) → property✝ f u\ncongr✝ : ∀ {f g : H → H} {u : Set H}, IsOpen u → (∀ (x : H), Membership.mem u x → Eq (g x) (f x)) → property✝ f u → property✝ g u\nproperty : (H → H) → Set H → Prop\ncomp : ∀ {f g : H → H} {u v : Set H}, property f u → property g v → IsOpen u → IsOpen v → IsOpen (Inter.inter u (Set.preimage f v)) → property (Function.comp g f) (Inter.inter u (Set.preimage f v))\nid_mem : property id Set.univ\nlocality : ∀ {f : H → H} {u : Set H}, IsOpen u → (∀ (x : H), Membership.mem u x → Exists fun v => And (IsOpen v) (And (Membership.mem v x) (property f (Inter.inter u v)))) → property f u\ncongr : ∀ {f g : H → H} {u : Set H}, IsOpen u → (∀ (x : H), Membership.mem u x → Eq (g x) (f x)) → property f u → property g u\nx✝ : Eq { property := property✝, comp := comp✝, id_mem := id_mem✝, locality := locality✝, congr := congr✝ } { property := property, comp := comp, id_mem := id_mem, locality := locality, congr := congr }\n⊢ Eq property✝ property","decl":"/-- To construct a groupoid, one may consider classes of partial homeomorphisms such that\nboth the function and its inverse have some property. If this property is stable under composition,\none gets a groupoid. `Pregroupoid` bundles the properties needed for this construction, with the\ngroupoid of smooth functions with smooth inverses as an application. -/\nstructure Pregroupoid (H : Type*) [TopologicalSpace H] where\n  /-- Property describing membership in this groupoid: the pregroupoid \"contains\"\n    all functions `H → H` having the pregroupoid property on some `s : Set H` -/\n  property : (H → H) → Set H → Prop\n  /-- The pregroupoid property is stable under composition -/\n  comp : ∀ {f g u v}, property f u → property g v →\n    IsOpen u → IsOpen v → IsOpen (u ∩ f ⁻¹' v) → property (g ∘ f) (u ∩ f ⁻¹' v)\n  /-- Pregroupoids contain the identity map (on `univ`) -/\n  id_mem : property id univ\n  /-- The pregroupoid property is \"local\", in the sense that `f` has the pregroupoid property on `u`\n  iff its restriction to each open subset of `u` has it -/\n  locality :\n    ∀ {f u}, IsOpen u → (∀ x ∈ u, ∃ v, IsOpen v ∧ x ∈ v ∧ property f (u ∩ v)) → property f u\n  /-- If `f = g` on `u` and `property f u`, then `property g u` -/\n  congr : ∀ {f g : H → H} {u}, IsOpen u → (∀ x ∈ u, g x = f x) → property f u → property g u\n\n"}
{"name":"Pregroupoid.comp","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝ : TopologicalSpace H\nself : Pregroupoid H\nf g : H → H\nu v : Set H\na✝⁴ : self.property f u\na✝³ : self.property g v\na✝² : IsOpen u\na✝¹ : IsOpen v\na✝ : IsOpen (Inter.inter u (Set.preimage f v))\n⊢ self.property (Function.comp g f) (Inter.inter u (Set.preimage f v))","decl":"/-- To construct a groupoid, one may consider classes of partial homeomorphisms such that\nboth the function and its inverse have some property. If this property is stable under composition,\none gets a groupoid. `Pregroupoid` bundles the properties needed for this construction, with the\ngroupoid of smooth functions with smooth inverses as an application. -/\nstructure Pregroupoid (H : Type*) [TopologicalSpace H] where\n  /-- Property describing membership in this groupoid: the pregroupoid \"contains\"\n    all functions `H → H` having the pregroupoid property on some `s : Set H` -/\n  property : (H → H) → Set H → Prop\n  /-- The pregroupoid property is stable under composition -/\n  comp : ∀ {f g u v}, property f u → property g v →\n    IsOpen u → IsOpen v → IsOpen (u ∩ f ⁻¹' v) → property (g ∘ f) (u ∩ f ⁻¹' v)\n  /-- Pregroupoids contain the identity map (on `univ`) -/\n  id_mem : property id univ\n  /-- The pregroupoid property is \"local\", in the sense that `f` has the pregroupoid property on `u`\n  iff its restriction to each open subset of `u` has it -/\n  locality :\n    ∀ {f u}, IsOpen u → (∀ x ∈ u, ∃ v, IsOpen v ∧ x ∈ v ∧ property f (u ∩ v)) → property f u\n  /-- If `f = g` on `u` and `property f u`, then `property g u` -/\n  congr : ∀ {f g : H → H} {u}, IsOpen u → (∀ x ∈ u, g x = f x) → property f u → property g u\n\n"}
{"name":"Pregroupoid.congr","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝ : TopologicalSpace H\nself : Pregroupoid H\nf g : H → H\nu : Set H\na✝² : IsOpen u\na✝¹ : ∀ (x : H), Membership.mem u x → Eq (g x) (f x)\na✝ : self.property f u\n⊢ self.property g u","decl":"/-- To construct a groupoid, one may consider classes of partial homeomorphisms such that\nboth the function and its inverse have some property. If this property is stable under composition,\none gets a groupoid. `Pregroupoid` bundles the properties needed for this construction, with the\ngroupoid of smooth functions with smooth inverses as an application. -/\nstructure Pregroupoid (H : Type*) [TopologicalSpace H] where\n  /-- Property describing membership in this groupoid: the pregroupoid \"contains\"\n    all functions `H → H` having the pregroupoid property on some `s : Set H` -/\n  property : (H → H) → Set H → Prop\n  /-- The pregroupoid property is stable under composition -/\n  comp : ∀ {f g u v}, property f u → property g v →\n    IsOpen u → IsOpen v → IsOpen (u ∩ f ⁻¹' v) → property (g ∘ f) (u ∩ f ⁻¹' v)\n  /-- Pregroupoids contain the identity map (on `univ`) -/\n  id_mem : property id univ\n  /-- The pregroupoid property is \"local\", in the sense that `f` has the pregroupoid property on `u`\n  iff its restriction to each open subset of `u` has it -/\n  locality :\n    ∀ {f u}, IsOpen u → (∀ x ∈ u, ∃ v, IsOpen v ∧ x ∈ v ∧ property f (u ∩ v)) → property f u\n  /-- If `f = g` on `u` and `property f u`, then `property g u` -/\n  congr : ∀ {f g : H → H} {u}, IsOpen u → (∀ x ∈ u, g x = f x) → property f u → property g u\n\n"}
{"name":"Pregroupoid.id_mem","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝ : TopologicalSpace H\nself : Pregroupoid H\n⊢ self.property id Set.univ","decl":"/-- To construct a groupoid, one may consider classes of partial homeomorphisms such that\nboth the function and its inverse have some property. If this property is stable under composition,\none gets a groupoid. `Pregroupoid` bundles the properties needed for this construction, with the\ngroupoid of smooth functions with smooth inverses as an application. -/\nstructure Pregroupoid (H : Type*) [TopologicalSpace H] where\n  /-- Property describing membership in this groupoid: the pregroupoid \"contains\"\n    all functions `H → H` having the pregroupoid property on some `s : Set H` -/\n  property : (H → H) → Set H → Prop\n  /-- The pregroupoid property is stable under composition -/\n  comp : ∀ {f g u v}, property f u → property g v →\n    IsOpen u → IsOpen v → IsOpen (u ∩ f ⁻¹' v) → property (g ∘ f) (u ∩ f ⁻¹' v)\n  /-- Pregroupoids contain the identity map (on `univ`) -/\n  id_mem : property id univ\n  /-- The pregroupoid property is \"local\", in the sense that `f` has the pregroupoid property on `u`\n  iff its restriction to each open subset of `u` has it -/\n  locality :\n    ∀ {f u}, IsOpen u → (∀ x ∈ u, ∃ v, IsOpen v ∧ x ∈ v ∧ property f (u ∩ v)) → property f u\n  /-- If `f = g` on `u` and `property f u`, then `property g u` -/\n  congr : ∀ {f g : H → H} {u}, IsOpen u → (∀ x ∈ u, g x = f x) → property f u → property g u\n\n"}
{"name":"Pregroupoid.mk.injEq","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝ : TopologicalSpace H\nproperty✝ : (H → H) → Set H → Prop\ncomp✝ : ∀ {f g : H → H} {u v : Set H}, property✝ f u → property✝ g v → IsOpen u → IsOpen v → IsOpen (Inter.inter u (Set.preimage f v)) → property✝ (Function.comp g f) (Inter.inter u (Set.preimage f v))\nid_mem✝ : property✝ id Set.univ\nlocality✝ : ∀ {f : H → H} {u : Set H}, IsOpen u → (∀ (x : H), Membership.mem u x → Exists fun v => And (IsOpen v) (And (Membership.mem v x) (property✝ f (Inter.inter u v)))) → property✝ f u\ncongr✝ : ∀ {f g : H → H} {u : Set H}, IsOpen u → (∀ (x : H), Membership.mem u x → Eq (g x) (f x)) → property✝ f u → property✝ g u\nproperty : (H → H) → Set H → Prop\ncomp : ∀ {f g : H → H} {u v : Set H}, property f u → property g v → IsOpen u → IsOpen v → IsOpen (Inter.inter u (Set.preimage f v)) → property (Function.comp g f) (Inter.inter u (Set.preimage f v))\nid_mem : property id Set.univ\nlocality : ∀ {f : H → H} {u : Set H}, IsOpen u → (∀ (x : H), Membership.mem u x → Exists fun v => And (IsOpen v) (And (Membership.mem v x) (property f (Inter.inter u v)))) → property f u\ncongr : ∀ {f g : H → H} {u : Set H}, IsOpen u → (∀ (x : H), Membership.mem u x → Eq (g x) (f x)) → property f u → property g u\n⊢ Eq (Eq { property := property✝, comp := comp✝, id_mem := id_mem✝, locality := locality✝, congr := congr✝ } { property := property, comp := comp, id_mem := id_mem, locality := locality, congr := congr }) (Eq property✝ property)","decl":"/-- To construct a groupoid, one may consider classes of partial homeomorphisms such that\nboth the function and its inverse have some property. If this property is stable under composition,\none gets a groupoid. `Pregroupoid` bundles the properties needed for this construction, with the\ngroupoid of smooth functions with smooth inverses as an application. -/\nstructure Pregroupoid (H : Type*) [TopologicalSpace H] where\n  /-- Property describing membership in this groupoid: the pregroupoid \"contains\"\n    all functions `H → H` having the pregroupoid property on some `s : Set H` -/\n  property : (H → H) → Set H → Prop\n  /-- The pregroupoid property is stable under composition -/\n  comp : ∀ {f g u v}, property f u → property g v →\n    IsOpen u → IsOpen v → IsOpen (u ∩ f ⁻¹' v) → property (g ∘ f) (u ∩ f ⁻¹' v)\n  /-- Pregroupoids contain the identity map (on `univ`) -/\n  id_mem : property id univ\n  /-- The pregroupoid property is \"local\", in the sense that `f` has the pregroupoid property on `u`\n  iff its restriction to each open subset of `u` has it -/\n  locality :\n    ∀ {f u}, IsOpen u → (∀ x ∈ u, ∃ v, IsOpen v ∧ x ∈ v ∧ property f (u ∩ v)) → property f u\n  /-- If `f = g` on `u` and `property f u`, then `property g u` -/\n  congr : ∀ {f g : H → H} {u}, IsOpen u → (∀ x ∈ u, g x = f x) → property f u → property g u\n\n"}
{"name":"Pregroupoid.locality","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝ : TopologicalSpace H\nself : Pregroupoid H\nf : H → H\nu : Set H\na✝¹ : IsOpen u\na✝ : ∀ (x : H), Membership.mem u x → Exists fun v => And (IsOpen v) (And (Membership.mem v x) (self.property f (Inter.inter u v)))\n⊢ self.property f u","decl":"/-- To construct a groupoid, one may consider classes of partial homeomorphisms such that\nboth the function and its inverse have some property. If this property is stable under composition,\none gets a groupoid. `Pregroupoid` bundles the properties needed for this construction, with the\ngroupoid of smooth functions with smooth inverses as an application. -/\nstructure Pregroupoid (H : Type*) [TopologicalSpace H] where\n  /-- Property describing membership in this groupoid: the pregroupoid \"contains\"\n    all functions `H → H` having the pregroupoid property on some `s : Set H` -/\n  property : (H → H) → Set H → Prop\n  /-- The pregroupoid property is stable under composition -/\n  comp : ∀ {f g u v}, property f u → property g v →\n    IsOpen u → IsOpen v → IsOpen (u ∩ f ⁻¹' v) → property (g ∘ f) (u ∩ f ⁻¹' v)\n  /-- Pregroupoids contain the identity map (on `univ`) -/\n  id_mem : property id univ\n  /-- The pregroupoid property is \"local\", in the sense that `f` has the pregroupoid property on `u`\n  iff its restriction to each open subset of `u` has it -/\n  locality :\n    ∀ {f u}, IsOpen u → (∀ x ∈ u, ∃ v, IsOpen v ∧ x ∈ v ∧ property f (u ∩ v)) → property f u\n  /-- If `f = g` on `u` and `property f u`, then `property g u` -/\n  congr : ∀ {f g : H → H} {u}, IsOpen u → (∀ x ∈ u, g x = f x) → property f u → property g u\n\n"}
{"name":"Pregroupoid.mk.sizeOf_spec","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝¹ : TopologicalSpace H\ninst✝ : SizeOf H\nproperty : (H → H) → Set H → Prop\ncomp : ∀ {f g : H → H} {u v : Set H}, property f u → property g v → IsOpen u → IsOpen v → IsOpen (Inter.inter u (Set.preimage f v)) → property (Function.comp g f) (Inter.inter u (Set.preimage f v))\nid_mem : property id Set.univ\nlocality : ∀ {f : H → H} {u : Set H}, IsOpen u → (∀ (x : H), Membership.mem u x → Exists fun v => And (IsOpen v) (And (Membership.mem v x) (property f (Inter.inter u v)))) → property f u\ncongr : ∀ {f g : H → H} {u : Set H}, IsOpen u → (∀ (x : H), Membership.mem u x → Eq (g x) (f x)) → property f u → property g u\n⊢ Eq (SizeOf.sizeOf { property := property, comp := comp, id_mem := id_mem, locality := locality, congr := congr }) (HAdd.hAdd 1 (SizeOf.sizeOf id_mem))","decl":"/-- To construct a groupoid, one may consider classes of partial homeomorphisms such that\nboth the function and its inverse have some property. If this property is stable under composition,\none gets a groupoid. `Pregroupoid` bundles the properties needed for this construction, with the\ngroupoid of smooth functions with smooth inverses as an application. -/\nstructure Pregroupoid (H : Type*) [TopologicalSpace H] where\n  /-- Property describing membership in this groupoid: the pregroupoid \"contains\"\n    all functions `H → H` having the pregroupoid property on some `s : Set H` -/\n  property : (H → H) → Set H → Prop\n  /-- The pregroupoid property is stable under composition -/\n  comp : ∀ {f g u v}, property f u → property g v →\n    IsOpen u → IsOpen v → IsOpen (u ∩ f ⁻¹' v) → property (g ∘ f) (u ∩ f ⁻¹' v)\n  /-- Pregroupoids contain the identity map (on `univ`) -/\n  id_mem : property id univ\n  /-- The pregroupoid property is \"local\", in the sense that `f` has the pregroupoid property on `u`\n  iff its restriction to each open subset of `u` has it -/\n  locality :\n    ∀ {f u}, IsOpen u → (∀ x ∈ u, ∃ v, IsOpen v ∧ x ∈ v ∧ property f (u ∩ v)) → property f u\n  /-- If `f = g` on `u` and `property f u`, then `property g u` -/\n  congr : ∀ {f g : H → H} {u}, IsOpen u → (∀ x ∈ u, g x = f x) → property f u → property g u\n\n"}
{"name":"mem_groupoid_of_pregroupoid","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nPG : Pregroupoid H\ne : PartialHomeomorph H H\n⊢ Iff (Membership.mem PG.groupoid e) (And (PG.property (↑e) e.source) (PG.property (↑e.symm) e.target))","decl":"theorem mem_groupoid_of_pregroupoid {PG : Pregroupoid H} {e : PartialHomeomorph H H} :\n    e ∈ PG.groupoid ↔ PG.property e e.source ∧ PG.property e.symm e.target :=\n  Iff.rfl\n\n"}
{"name":"groupoid_of_pregroupoid_le","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nPG₁ PG₂ : Pregroupoid H\nh : ∀ (f : H → H) (s : Set H), PG₁.property f s → PG₂.property f s\n⊢ LE.le PG₁.groupoid PG₂.groupoid","decl":"theorem groupoid_of_pregroupoid_le (PG₁ PG₂ : Pregroupoid H)\n    (h : ∀ f s, PG₁.property f s → PG₂.property f s) : PG₁.groupoid ≤ PG₂.groupoid := by\n  refine StructureGroupoid.le_iff.2 fun e he ↦ ?_\n  rw [mem_groupoid_of_pregroupoid] at he ⊢\n  exact ⟨h _ _ he.1, h _ _ he.2⟩\n\n"}
{"name":"mem_pregroupoid_of_eqOnSource","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nPG : Pregroupoid H\ne e' : PartialHomeomorph H H\nhe' : HasEquiv.Equiv e e'\nhe : PG.property (↑e) e.source\n⊢ PG.property (↑e') e'.source","decl":"theorem mem_pregroupoid_of_eqOnSource (PG : Pregroupoid H) {e e' : PartialHomeomorph H H}\n    (he' : e ≈ e') (he : PG.property e e.source) : PG.property e' e'.source := by\n  rw [← he'.1]\n  exact PG.congr e.open_source he'.eqOn.symm he\n\n"}
{"name":"ClosedUnderRestriction.closedUnderRestriction","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nG : StructureGroupoid H\nself : ClosedUnderRestriction G\ne : PartialHomeomorph H H\na✝¹ : Membership.mem G e\ns : Set H\na✝ : IsOpen s\n⊢ Membership.mem G (e.restr s)","decl":"/-- A groupoid is closed under restriction if it contains all restrictions of its element local\nhomeomorphisms to open subsets of the source. -/\nclass ClosedUnderRestriction (G : StructureGroupoid H) : Prop where\n  closedUnderRestriction :\n    ∀ {e : PartialHomeomorph H H}, e ∈ G → ∀ s : Set H, IsOpen s → e.restr s ∈ G\n\n"}
{"name":"closedUnderRestriction'","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝¹ : TopologicalSpace H\nG : StructureGroupoid H\ninst✝ : ClosedUnderRestriction G\ne : PartialHomeomorph H H\nhe : Membership.mem G e\ns : Set H\nhs : IsOpen s\n⊢ Membership.mem G (e.restr s)","decl":"theorem closedUnderRestriction' {G : StructureGroupoid H} [ClosedUnderRestriction G]\n    {e : PartialHomeomorph H H} (he : e ∈ G) {s : Set H} (hs : IsOpen s) : e.restr s ∈ G :=\n  ClosedUnderRestriction.closedUnderRestriction he s hs\n\n"}
{"name":"idRestrGroupoid_mem","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\ns : Set H\nhs : IsOpen s\n⊢ Membership.mem idRestrGroupoid (PartialHomeomorph.ofSet s hs)","decl":"theorem idRestrGroupoid_mem {s : Set H} (hs : IsOpen s) : ofSet s hs ∈ @idRestrGroupoid H _ :=\n  ⟨s, hs, refl _⟩\n\n"}
{"name":"closedUnderRestriction_idRestrGroupoid","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\n⊢ ClosedUnderRestriction idRestrGroupoid","decl":"/-- The trivial restriction-closed groupoid is indeed `ClosedUnderRestriction`. -/\ninstance closedUnderRestriction_idRestrGroupoid : ClosedUnderRestriction (@idRestrGroupoid H _) :=\n  ⟨by\n    rintro e ⟨s', hs', he⟩ s hs\n    use s' ∩ s, hs'.inter hs\n    refine Setoid.trans (PartialHomeomorph.EqOnSource.restr he s) ?_\n    exact ⟨by simp only [hs.interior_eq, mfld_simps], by simp only [mfld_simps, eqOn_refl]⟩⟩\n\n"}
{"name":"closedUnderRestriction_iff_id_le","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nG : StructureGroupoid H\n⊢ Iff (ClosedUnderRestriction G) (LE.le idRestrGroupoid G)","decl":"/-- A groupoid is closed under restriction if and only if it contains the trivial restriction-closed\ngroupoid. -/\ntheorem closedUnderRestriction_iff_id_le (G : StructureGroupoid H) :\n    ClosedUnderRestriction G ↔ idRestrGroupoid ≤ G := by\n  constructor\n  · intro _i\n    rw [StructureGroupoid.le_iff]\n    rintro e ⟨s, hs, hes⟩\n    refine G.mem_of_eqOnSource ?_ hes\n    convert closedUnderRestriction' G.id_mem hs\n    -- Porting note: was\n    -- change s = _ ∩ _\n    -- rw [hs.interior_eq]\n    -- simp only [mfld_simps]\n    ext\n    · rw [PartialHomeomorph.restr_apply, PartialHomeomorph.refl_apply, id, ofSet_apply, id_eq]\n    · simp [hs]\n    · simp [hs.interior_eq]\n  · intro h\n    constructor\n    intro e he s hs\n    rw [← ofSet_trans (e : PartialHomeomorph H H) hs]\n    refine G.trans ?_ he\n    apply StructureGroupoid.le_iff.mp h\n    exact idRestrGroupoid_mem hs\n\n"}
{"name":"instClosedUnderRestrictionContinuousGroupoid","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\n⊢ ClosedUnderRestriction (continuousGroupoid H)","decl":"/-- The groupoid of all partial homeomorphisms on a topological space `H`\nis closed under restriction. -/\ninstance : ClosedUnderRestriction (continuousGroupoid H) :=\n  (closedUnderRestriction_iff_id_le _).mpr le_top\n\n"}
{"name":"ChartedSpace.ext","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝¹ : TopologicalSpace H\nM : Type u_6\ninst✝ : TopologicalSpace M\nx y : ChartedSpace H M\natlas : Eq ChartedSpace.atlas ChartedSpace.atlas\nchartAt : Eq ChartedSpace.chartAt ChartedSpace.chartAt\n⊢ Eq x y","decl":"/-- A charted space is a topological space endowed with an atlas, i.e., a set of local\nhomeomorphisms taking value in a model space `H`, called charts, such that the domains of the charts\ncover the whole space. We express the covering property by choosing for each `x` a member\n`chartAt x` of the atlas containing `x` in its source: in the smooth case, this is convenient to\nconstruct the tangent bundle in an efficient way.\nThe model space is written as an explicit parameter as there can be several model spaces for a\ngiven topological space. For instance, a complex manifold (modelled over `ℂ^n`) will also be seen\nsometimes as a real manifold over `ℝ^(2n)`.\n-/\n@[ext]\nclass ChartedSpace (H : Type*) [TopologicalSpace H] (M : Type*) [TopologicalSpace M] where\n  /-- The atlas of charts in the `ChartedSpace`. -/\n  protected atlas : Set (PartialHomeomorph M H)\n  /-- The preferred chart at each point in the charted space. -/\n  protected chartAt : M → PartialHomeomorph M H\n  protected mem_chart_source : ∀ x, x ∈ (chartAt x).source\n  protected chart_mem_atlas : ∀ x, chartAt x ∈ atlas\n\n"}
{"name":"ChartedSpace.mem_chart_source","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝¹ : TopologicalSpace H\nM : Type u_6\ninst✝ : TopologicalSpace M\nself : ChartedSpace H M\nx : M\n⊢ Membership.mem (ChartedSpace.chartAt x).source x","decl":"/-- A charted space is a topological space endowed with an atlas, i.e., a set of local\nhomeomorphisms taking value in a model space `H`, called charts, such that the domains of the charts\ncover the whole space. We express the covering property by choosing for each `x` a member\n`chartAt x` of the atlas containing `x` in its source: in the smooth case, this is convenient to\nconstruct the tangent bundle in an efficient way.\nThe model space is written as an explicit parameter as there can be several model spaces for a\ngiven topological space. For instance, a complex manifold (modelled over `ℂ^n`) will also be seen\nsometimes as a real manifold over `ℝ^(2n)`.\n-/\n@[ext]\nclass ChartedSpace (H : Type*) [TopologicalSpace H] (M : Type*) [TopologicalSpace M] where\n  /-- The atlas of charts in the `ChartedSpace`. -/\n  protected atlas : Set (PartialHomeomorph M H)\n  /-- The preferred chart at each point in the charted space. -/\n  protected chartAt : M → PartialHomeomorph M H\n  protected mem_chart_source : ∀ x, x ∈ (chartAt x).source\n  protected chart_mem_atlas : ∀ x, chartAt x ∈ atlas\n\n"}
{"name":"ChartedSpace.ext_iff","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝¹ : TopologicalSpace H\nM : Type u_6\ninst✝ : TopologicalSpace M\nx y : ChartedSpace H M\n⊢ Iff (Eq x y) (And (Eq ChartedSpace.atlas ChartedSpace.atlas) (Eq ChartedSpace.chartAt ChartedSpace.chartAt))","decl":"/-- A charted space is a topological space endowed with an atlas, i.e., a set of local\nhomeomorphisms taking value in a model space `H`, called charts, such that the domains of the charts\ncover the whole space. We express the covering property by choosing for each `x` a member\n`chartAt x` of the atlas containing `x` in its source: in the smooth case, this is convenient to\nconstruct the tangent bundle in an efficient way.\nThe model space is written as an explicit parameter as there can be several model spaces for a\ngiven topological space. For instance, a complex manifold (modelled over `ℂ^n`) will also be seen\nsometimes as a real manifold over `ℝ^(2n)`.\n-/\n@[ext]\nclass ChartedSpace (H : Type*) [TopologicalSpace H] (M : Type*) [TopologicalSpace M] where\n  /-- The atlas of charts in the `ChartedSpace`. -/\n  protected atlas : Set (PartialHomeomorph M H)\n  /-- The preferred chart at each point in the charted space. -/\n  protected chartAt : M → PartialHomeomorph M H\n  protected mem_chart_source : ∀ x, x ∈ (chartAt x).source\n  protected chart_mem_atlas : ∀ x, chartAt x ∈ atlas\n\n"}
{"name":"ChartedSpace.chart_mem_atlas","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝¹ : TopologicalSpace H\nM : Type u_6\ninst✝ : TopologicalSpace M\nself : ChartedSpace H M\nx : M\n⊢ Membership.mem ChartedSpace.atlas (ChartedSpace.chartAt x)","decl":"/-- A charted space is a topological space endowed with an atlas, i.e., a set of local\nhomeomorphisms taking value in a model space `H`, called charts, such that the domains of the charts\ncover the whole space. We express the covering property by choosing for each `x` a member\n`chartAt x` of the atlas containing `x` in its source: in the smooth case, this is convenient to\nconstruct the tangent bundle in an efficient way.\nThe model space is written as an explicit parameter as there can be several model spaces for a\ngiven topological space. For instance, a complex manifold (modelled over `ℂ^n`) will also be seen\nsometimes as a real manifold over `ℝ^(2n)`.\n-/\n@[ext]\nclass ChartedSpace (H : Type*) [TopologicalSpace H] (M : Type*) [TopologicalSpace M] where\n  /-- The atlas of charts in the `ChartedSpace`. -/\n  protected atlas : Set (PartialHomeomorph M H)\n  /-- The preferred chart at each point in the charted space. -/\n  protected chartAt : M → PartialHomeomorph M H\n  protected mem_chart_source : ∀ x, x ∈ (chartAt x).source\n  protected chart_mem_atlas : ∀ x, chartAt x ∈ atlas\n\n"}
{"name":"mem_chart_source","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\nM : Type u_6\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nx : M\n⊢ Membership.mem (chartAt H x).source x","decl":"@[simp, mfld_simps]\nlemma mem_chart_source (H : Type*) {M : Type*} [TopologicalSpace H] [TopologicalSpace M]\n    [ChartedSpace H M] (x : M) : x ∈ (chartAt H x).source :=\n  ChartedSpace.mem_chart_source x\n\n"}
{"name":"chart_mem_atlas","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\nM : Type u_6\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nx : M\n⊢ Membership.mem (atlas H M) (chartAt H x)","decl":"@[simp, mfld_simps]\nlemma chart_mem_atlas (H : Type*) {M : Type*} [TopologicalSpace H] [TopologicalSpace M]\n    [ChartedSpace H M] (x : M) : chartAt H x ∈ atlas H M :=\n  ChartedSpace.chart_mem_atlas x\n\n"}
{"name":"chartedSpaceSelf_atlas","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝ : TopologicalSpace H\ne : PartialHomeomorph H H\n⊢ Iff (Membership.mem (atlas H H) e) (Eq e (PartialHomeomorph.refl H))","decl":"/-- In the trivial `ChartedSpace` structure of a space modelled over itself through the identity,\nthe atlas members are just the identity. -/\n@[simp, mfld_simps]\ntheorem chartedSpaceSelf_atlas {H : Type*} [TopologicalSpace H] {e : PartialHomeomorph H H} :\n    e ∈ atlas H H ↔ e = PartialHomeomorph.refl H :=\n  Iff.rfl\n\n"}
{"name":"chartAt_self_eq","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝ : TopologicalSpace H\nx : H\n⊢ Eq (chartAt H x) (PartialHomeomorph.refl H)","decl":"/-- In the model space, `chartAt` is always the identity. -/\ntheorem chartAt_self_eq {H : Type*} [TopologicalSpace H] {x : H} :\n    chartAt H x = PartialHomeomorph.refl H := rfl\n\n"}
{"name":"mem_chart_target","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nx : M\n⊢ Membership.mem (chartAt H x).target (↑(chartAt H x) x)","decl":"theorem mem_chart_target (x : M) : chartAt H x x ∈ (chartAt H x).target :=\n  (chartAt H x).map_source (mem_chart_source _ _)\n\n"}
{"name":"chart_source_mem_nhds","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nx : M\n⊢ Membership.mem (nhds x) (chartAt H x).source","decl":"theorem chart_source_mem_nhds (x : M) : (chartAt H x).source ∈ 𝓝 x :=\n  (chartAt H x).open_source.mem_nhds <| mem_chart_source H x\n\n"}
{"name":"chart_target_mem_nhds","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nx : M\n⊢ Membership.mem (nhds (↑(chartAt H x) x)) (chartAt H x).target","decl":"theorem chart_target_mem_nhds (x : M) : (chartAt H x).target ∈ 𝓝 (chartAt H x x) :=\n  (chartAt H x).open_target.mem_nhds <| mem_chart_target H x\n\n"}
{"name":"iUnion_source_chartAt","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\n⊢ Eq (Set.iUnion fun x => (chartAt H x).source) Set.univ","decl":"variable (M) in\n@[simp]\ntheorem iUnion_source_chartAt : (⋃ x : M, (chartAt H x).source) = (univ : Set M) :=\n  eq_univ_iff_forall.mpr fun x ↦ mem_iUnion.mpr ⟨x, mem_chart_source H x⟩\n\n"}
{"name":"ChartedSpace.isOpen_iff","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\ns : Set M\n⊢ Iff (IsOpen s) (∀ (x : M), IsOpen (Set.image (↑(chartAt H x)) (Inter.inter (chartAt H x).source s)))","decl":"theorem ChartedSpace.isOpen_iff (s : Set M) :\n    IsOpen s ↔ ∀ x : M, IsOpen <| chartAt H x '' ((chartAt H x).source ∩ s) := by\n  rw [isOpen_iff_of_cover (fun i ↦ (chartAt H i).open_source) (iUnion_source_chartAt H M)]\n  simp only [(chartAt H _).isOpen_image_iff_of_subset_source inter_subset_left]\n\n"}
{"name":"achart_def","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nx : M\n⊢ Eq (achart H x) ⟨chartAt H x, ⋯⟩","decl":"theorem achart_def (x : M) : achart H x = ⟨chartAt H x, chart_mem_atlas H x⟩ :=\n  rfl\n\n"}
{"name":"coe_achart","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nx : M\n⊢ Eq (↑(achart H x)) (chartAt H x)","decl":"@[simp, mfld_simps]\ntheorem coe_achart (x : M) : (achart H x : PartialHomeomorph M H) = chartAt H x :=\n  rfl\n\n"}
{"name":"achart_val","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nx : M\n⊢ Eq (↑(achart H x)) (chartAt H x)","decl":"@[simp, mfld_simps]\ntheorem achart_val (x : M) : (achart H x).1 = chartAt H x :=\n  rfl\n\n"}
{"name":"mem_achart_source","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nx : M\n⊢ Membership.mem (↑(achart H x)).source x","decl":"theorem mem_achart_source (x : M) : x ∈ (achart H x).1.source :=\n  mem_chart_source H x\n\n"}
{"name":"ChartedSpace.secondCountable_of_countable_cover","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝³ : TopologicalSpace H\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\ninst✝ : SecondCountableTopology H\ns : Set M\nhs : Eq (Set.iUnion fun x => Set.iUnion fun x_1 => (chartAt H x).source) Set.univ\nhsc : s.Countable\n⊢ SecondCountableTopology M","decl":"theorem ChartedSpace.secondCountable_of_countable_cover [SecondCountableTopology H] {s : Set M}\n    (hs : ⋃ (x) (_ : x ∈ s), (chartAt H x).source = univ) (hsc : s.Countable) :\n    SecondCountableTopology M := by\n  haveI : ∀ x : M, SecondCountableTopology (chartAt H x).source :=\n    fun x ↦ (chartAt (H := H) x).secondCountableTopology_source\n  haveI := hsc.toEncodable\n  rw [biUnion_eq_iUnion] at hs\n  exact secondCountableTopology_of_countable_cover (fun x : s ↦ (chartAt H (x : M)).open_source) hs\n\n"}
{"name":"ChartedSpace.secondCountable_of_sigmaCompact","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝⁴ : TopologicalSpace H\ninst✝³ : TopologicalSpace M\ninst✝² : ChartedSpace H M\ninst✝¹ : SecondCountableTopology H\ninst✝ : SigmaCompactSpace M\n⊢ SecondCountableTopology M","decl":"theorem ChartedSpace.secondCountable_of_sigmaCompact [SecondCountableTopology H]\n    [SigmaCompactSpace M] : SecondCountableTopology M := by\n  obtain ⟨s, hsc, hsU⟩ : ∃ s, Set.Countable s ∧ ⋃ (x) (_ : x ∈ s), (chartAt H x).source = univ :=\n    countable_cover_nhds_of_sigmaCompact fun x : M ↦ chart_source_mem_nhds H x\n  exact ChartedSpace.secondCountable_of_countable_cover H hsU hsc\n\n"}
{"name":"ChartedSpace.secondCountable_of_sigma_compact","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝⁴ : TopologicalSpace H\ninst✝³ : TopologicalSpace M\ninst✝² : ChartedSpace H M\ninst✝¹ : SecondCountableTopology H\ninst✝ : SigmaCompactSpace M\n⊢ SecondCountableTopology M","decl":"@[deprecated (since := \"2024-11-13\")] alias\nChartedSpace.secondCountable_of_sigma_compact := ChartedSpace.secondCountable_of_sigmaCompact\n\n"}
{"name":"ChartedSpace.locallyCompactSpace","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝³ : TopologicalSpace H\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\ninst✝ : LocallyCompactSpace H\n⊢ LocallyCompactSpace M","decl":"/-- If a topological space admits an atlas with locally compact charts, then the space itself\nis locally compact. -/\ntheorem ChartedSpace.locallyCompactSpace [LocallyCompactSpace H] : LocallyCompactSpace M := by\n  have : ∀ x : M, (𝓝 x).HasBasis\n      (fun s ↦ s ∈ 𝓝 (chartAt H x x) ∧ IsCompact s ∧ s ⊆ (chartAt H x).target)\n      fun s ↦ (chartAt H x).symm '' s := fun x ↦ by\n    rw [← (chartAt H x).symm_map_nhds_eq (mem_chart_source H x)]\n    exact ((compact_basis_nhds (chartAt H x x)).hasBasis_self_subset\n      (chart_target_mem_nhds H x)).map _\n  refine .of_hasBasis this ?_\n  rintro x s ⟨_, h₂, h₃⟩\n  exact h₂.image_of_continuousOn ((chartAt H x).continuousOn_symm.mono h₃)\n\n"}
{"name":"ChartedSpace.locallyConnectedSpace","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝³ : TopologicalSpace H\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\ninst✝ : LocallyConnectedSpace H\n⊢ LocallyConnectedSpace M","decl":"/-- If a topological space admits an atlas with locally connected charts, then the space itself is\nlocally connected. -/\ntheorem ChartedSpace.locallyConnectedSpace [LocallyConnectedSpace H] : LocallyConnectedSpace M := by\n  let e : M → PartialHomeomorph M H := chartAt H\n  refine locallyConnectedSpace_of_connected_bases (fun x s ↦ (e x).symm '' s)\n      (fun x s ↦ (IsOpen s ∧ e x x ∈ s ∧ IsConnected s) ∧ s ⊆ (e x).target) ?_ ?_\n  · intro x\n    simpa only [e, PartialHomeomorph.symm_map_nhds_eq, mem_chart_source] using\n      ((LocallyConnectedSpace.open_connected_basis (e x x)).restrict_subset\n        ((e x).open_target.mem_nhds (mem_chart_target H x))).map (e x).symm\n  · rintro x s ⟨⟨-, -, hsconn⟩, hssubset⟩\n    exact hsconn.isPreconnected.image _ ((e x).continuousOn_symm.mono hssubset)\n\n"}
{"name":"ChartedSpace.locPathConnectedSpace","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝³ : TopologicalSpace H\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\ninst✝ : LocPathConnectedSpace H\n⊢ LocPathConnectedSpace M","decl":"/-- If a topological space `M` admits an atlas with locally path-connected charts,\n  then `M` itself is locally path-connected. -/\ntheorem ChartedSpace.locPathConnectedSpace [LocPathConnectedSpace H] : LocPathConnectedSpace M := by\n  refine ⟨fun x ↦ ⟨fun s ↦ ⟨fun hs ↦ ?_, fun ⟨u, hu⟩ ↦ Filter.mem_of_superset hu.1.1 hu.2⟩⟩⟩\n  let e := chartAt H x\n  let t := s ∩ e.source\n  have ht : t ∈ 𝓝 x := Filter.inter_mem hs (chart_source_mem_nhds _ _)\n  refine ⟨e.symm '' pathComponentIn (e x) (e '' t), ⟨?_, ?_⟩, (?_ : _ ⊆ t).trans inter_subset_left⟩\n  · nth_rewrite 1 [← e.left_inv (mem_chart_source _ _)]\n    apply e.symm.image_mem_nhds (by simp [e])\n    exact pathComponentIn_mem_nhds <| e.image_mem_nhds (mem_chart_source _ _) ht\n  · refine (isPathConnected_pathComponentIn <| mem_image_of_mem e (mem_of_mem_nhds ht)).image' ?_\n    refine e.continuousOn_symm.mono <| subset_trans ?_ e.map_source''\n    exact (pathComponentIn_mono <| image_mono inter_subset_right).trans pathComponentIn_subset\n  · exact (image_mono pathComponentIn_subset).trans\n      (PartialEquiv.symm_image_image_of_subset_source _ inter_subset_right).subset\n\n"}
{"name":"chartAt_comp","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝⁴ : TopologicalSpace H\nH' : Type u_6\ninst✝³ : TopologicalSpace H'\nM : Type u_7\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H H'\ninst✝ : ChartedSpace H' M\nx : M\n⊢ Eq (chartAt H x) ((chartAt H' x).trans (chartAt H (↑(chartAt H' x) x)))","decl":"theorem chartAt_comp (H : Type*) [TopologicalSpace H] (H' : Type*) [TopologicalSpace H']\n    {M : Type*} [TopologicalSpace M] [ChartedSpace H H'] [ChartedSpace H' M] (x : M) :\n    (letI := ChartedSpace.comp H H' M; chartAt H x) = chartAt H' x ≫ₕ chartAt H (chartAt H' x x) :=\n  rfl\n\n"}
{"name":"ChartedSpace.t1Space","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝³ : TopologicalSpace H\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\ninst✝ : T1Space H\n⊢ T1Space M","decl":"/-- A charted space over a T1 space is T1. Note that this is *not* true for T2 (for instance for\nthe real line with a double origin). -/\ntheorem ChartedSpace.t1Space [T1Space H] : T1Space M := by\n  apply t1Space_iff_exists_open.2 (fun x y hxy ↦ ?_)\n  by_cases hy : y ∈ (chartAt H x).source\n  · refine ⟨(chartAt H x).source ∩ (chartAt H x)⁻¹' ({chartAt H x y}ᶜ), ?_, ?_, by simp⟩\n    · exact PartialHomeomorph.isOpen_inter_preimage _ isOpen_compl_singleton\n    · simp only [preimage_compl, mem_inter_iff, mem_chart_source, mem_compl_iff, mem_preimage,\n        mem_singleton_iff, true_and]\n      exact (chartAt H x).injOn.ne (ChartedSpace.mem_chart_source x) hy hxy\n  · exact ⟨(chartAt H x).source, (chartAt H x).open_source, ChartedSpace.mem_chart_source x, hy⟩\n\n"}
{"name":"modelProd_range_prod_id","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\nH' : Type u_6\nα : Type u_7\nf : H → α\n⊢ Eq (Set.range fun p => { fst := f p.1, snd := p.2 }) (SProd.sprod (Set.range f) Set.univ)","decl":"@[simp, mfld_simps]\ntheorem modelProd_range_prod_id {H : Type*} {H' : Type*} {α : Type*} (f : H → α) :\n    (range fun p : ModelProd H H' ↦ (f p.1, p.2)) = range f ×ˢ (univ : Set H') := by\n  rw [prod_range_univ_eq]\n  rfl\n\n"}
{"name":"ModelProd.ext","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nH' : Type u_1\nx y : ModelProd H H'\nh₁ : Eq x.1 y.1\nh₂ : Eq x.2 y.2\n⊢ Eq x y","decl":"@[ext]\ntheorem ModelProd.ext {x y : ModelProd H H'} (h₁ : x.1 = y.1) (h₂ : x.2 = y.2) : x = y :=\n  Prod.ext h₁ h₂\n\n"}
{"name":"ModelProd.ext_iff","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nH' : Type u_1\nx y : ModelProd H H'\n⊢ Iff (Eq x y) (And (Eq x.1 y.1) (Eq x.2 y.2))","decl":"@[ext]\ntheorem ModelProd.ext {x y : ModelProd H H'} (h₁ : x.1 = y.1) (h₂ : x.2 = y.2) : x = y :=\n  Prod.ext h₁ h₂\n\n"}
{"name":"prodChartedSpace_chartAt","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nH' : Type u_1\nM : Type u_2\nM' : Type u_3\ninst✝⁵ : TopologicalSpace H\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\ninst✝² : TopologicalSpace H'\ninst✝¹ : TopologicalSpace M'\ninst✝ : ChartedSpace H' M'\nx : Prod M M'\n⊢ Eq (chartAt (ModelProd H H') x) ((chartAt H x.1).prod (chartAt H' x.2))","decl":"@[simp, mfld_simps]\ntheorem prodChartedSpace_chartAt :\n    chartAt (ModelProd H H') x = (chartAt H x.fst).prod (chartAt H' x.snd) :=\n  rfl\n\n"}
{"name":"chartedSpaceSelf_prod","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nH' : Type u_1\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace H'\n⊢ Eq (prodChartedSpace H H H' H') (chartedSpaceSelf (Prod H H'))","decl":"theorem chartedSpaceSelf_prod : prodChartedSpace H H H' H' = chartedSpaceSelf (H × H') := by\n  ext1\n  · simp [prodChartedSpace, atlas, ChartedSpace.atlas]\n  · ext1\n    simp only [prodChartedSpace_chartAt, chartAt_self_eq, refl_prod_refl]\n    rfl\n\n"}
{"name":"piChartedSpace_chartAt","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"ι : Type u_5\ninst✝³ : Finite ι\nH : ι → Type u_6\ninst✝² : (i : ι) → TopologicalSpace (H i)\nM : ι → Type u_7\ninst✝¹ : (i : ι) → TopologicalSpace (M i)\ninst✝ : (i : ι) → ChartedSpace (H i) (M i)\nf : (i : ι) → M i\n⊢ Eq (chartAt (ModelPi H) f) (PartialHomeomorph.pi fun i => chartAt (H i) (f i))","decl":"@[simp, mfld_simps]\ntheorem piChartedSpace_chartAt {ι : Type*} [Finite ι] (H : ι → Type*)\n    [∀ i, TopologicalSpace (H i)] (M : ι → Type*) [∀ i, TopologicalSpace (M i)]\n    [∀ i, ChartedSpace (H i) (M i)] (f : ∀ i, M i) :\n    chartAt (H := ModelPi H) f = PartialHomeomorph.pi fun i ↦ chartAt (H i) (f i) :=\n  rfl\n\n"}
{"name":"ChartedSpace.sum_chartAt_inl","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\nM' : Type u_3\ninst✝³ : TopologicalSpace H\ninst✝² : TopologicalSpace M\ninst✝¹ : TopologicalSpace M'\ncm : ChartedSpace H M\ncm' : ChartedSpace H M'\ninst✝ : Nonempty H\nx : M\n⊢ Eq (chartAt H (Sum.inl x)) ((chartAt H x).lift_openEmbedding ⋯)","decl":"lemma ChartedSpace.sum_chartAt_inl (x : M) :\n    chartAt H (Sum.inl x) = (chartAt H x).lift_openEmbedding (X' := M ⊕ M') IsOpenEmbedding.inl :=\n  rfl\n\n"}
{"name":"ChartedSpace.sum_chartAt_inr","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\nM' : Type u_3\ninst✝³ : TopologicalSpace H\ninst✝² : TopologicalSpace M\ninst✝¹ : TopologicalSpace M'\ncm : ChartedSpace H M\ncm' : ChartedSpace H M'\ninst✝ : Nonempty H\nx' : M'\n⊢ Eq (chartAt H (Sum.inr x')) ((chartAt H x').lift_openEmbedding ⋯)","decl":"lemma ChartedSpace.sum_chartAt_inr (x' : M') :\n    chartAt H (Sum.inr x') = (chartAt H x').lift_openEmbedding (X' := M ⊕ M') IsOpenEmbedding.inr :=\n  rfl\n\n"}
{"name":"ChartedSpace.mem_atlas_sum","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\nM' : Type u_3\ninst✝³ : TopologicalSpace H\ninst✝² : TopologicalSpace M\ninst✝¹ : TopologicalSpace M'\ncm : ChartedSpace H M\ncm' : ChartedSpace H M'\ninst✝ : Nonempty H\ne : PartialHomeomorph (Sum M M') H\nhe : Membership.mem (atlas H (Sum M M')) e\n⊢ Or (Exists fun f => And (Membership.mem (atlas H M) f) (Eq e (f.lift_openEmbedding ⋯))) (Exists fun f' => And (Membership.mem (atlas H M') f') (Eq e (f'.lift_openEmbedding ⋯)))","decl":"lemma ChartedSpace.mem_atlas_sum {e : PartialHomeomorph (M ⊕ M') H} (he : e ∈ atlas H (M ⊕ M')) :\n    (∃ f : PartialHomeomorph M H, f ∈ (atlas H M) ∧ e = (f.lift_openEmbedding IsOpenEmbedding.inl))\n    ∨ (∃ f' : PartialHomeomorph M' H, f' ∈ (atlas H M') ∧\n      e = (f'.lift_openEmbedding IsOpenEmbedding.inr)) := by\n    obtain (⟨x, hx, hxe⟩ | ⟨x, hx, hxe⟩) := he\n    · rw [← hxe]; left; use x\n    · rw [← hxe]; right; use x\n\n"}
{"name":"ChartedSpaceCore.mem_chart_source","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝ : TopologicalSpace H\nM : Type u_6\nself : ChartedSpaceCore H M\nx : M\n⊢ Membership.mem (self.chartAt x).source x","decl":"/-- Sometimes, one may want to construct a charted space structure on a space which does not yet\nhave a topological structure, where the topology would come from the charts. For this, one needs\ncharts that are only partial equivalences, and continuity properties for their composition.\nThis is formalised in `ChartedSpaceCore`. -/\nstructure ChartedSpaceCore (H : Type*) [TopologicalSpace H] (M : Type*) where\n  /-- An atlas of charts, which are only `PartialEquiv`s -/\n  atlas : Set (PartialEquiv M H)\n  /-- The preferred chart at each point -/\n  chartAt : M → PartialEquiv M H\n  mem_chart_source : ∀ x, x ∈ (chartAt x).source\n  chart_mem_atlas : ∀ x, chartAt x ∈ atlas\n  open_source : ∀ e e' : PartialEquiv M H, e ∈ atlas → e' ∈ atlas → IsOpen (e.symm.trans e').source\n  continuousOn_toFun : ∀ e e' : PartialEquiv M H, e ∈ atlas → e' ∈ atlas →\n    ContinuousOn (e.symm.trans e') (e.symm.trans e').source\n\n"}
{"name":"ChartedSpaceCore.open_source","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝ : TopologicalSpace H\nM : Type u_6\nself : ChartedSpaceCore H M\ne e' : PartialEquiv M H\na✝¹ : Membership.mem self.atlas e\na✝ : Membership.mem self.atlas e'\n⊢ IsOpen (e.symm.trans e').source","decl":"/-- Sometimes, one may want to construct a charted space structure on a space which does not yet\nhave a topological structure, where the topology would come from the charts. For this, one needs\ncharts that are only partial equivalences, and continuity properties for their composition.\nThis is formalised in `ChartedSpaceCore`. -/\nstructure ChartedSpaceCore (H : Type*) [TopologicalSpace H] (M : Type*) where\n  /-- An atlas of charts, which are only `PartialEquiv`s -/\n  atlas : Set (PartialEquiv M H)\n  /-- The preferred chart at each point -/\n  chartAt : M → PartialEquiv M H\n  mem_chart_source : ∀ x, x ∈ (chartAt x).source\n  chart_mem_atlas : ∀ x, chartAt x ∈ atlas\n  open_source : ∀ e e' : PartialEquiv M H, e ∈ atlas → e' ∈ atlas → IsOpen (e.symm.trans e').source\n  continuousOn_toFun : ∀ e e' : PartialEquiv M H, e ∈ atlas → e' ∈ atlas →\n    ContinuousOn (e.symm.trans e') (e.symm.trans e').source\n\n"}
{"name":"ChartedSpaceCore.mk.sizeOf_spec","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝² : TopologicalSpace H\nM : Type u_6\ninst✝¹ : SizeOf H\ninst✝ : SizeOf M\natlas : Set (PartialEquiv M H)\nchartAt : M → PartialEquiv M H\nmem_chart_source : ∀ (x : M), Membership.mem (chartAt x).source x\nchart_mem_atlas : ∀ (x : M), Membership.mem atlas (chartAt x)\nopen_source : ∀ (e e' : PartialEquiv M H), Membership.mem atlas e → Membership.mem atlas e' → IsOpen (e.symm.trans e').source\ncontinuousOn_toFun : ∀ (e e' : PartialEquiv M H), Membership.mem atlas e → Membership.mem atlas e' → ContinuousOn (↑(e.symm.trans e')) (e.symm.trans e').source\n⊢ Eq (SizeOf.sizeOf { atlas := atlas, chartAt := chartAt, mem_chart_source := mem_chart_source, chart_mem_atlas := chart_mem_atlas, open_source := open_source, continuousOn_toFun := continuousOn_toFun }) 1","decl":"/-- Sometimes, one may want to construct a charted space structure on a space which does not yet\nhave a topological structure, where the topology would come from the charts. For this, one needs\ncharts that are only partial equivalences, and continuity properties for their composition.\nThis is formalised in `ChartedSpaceCore`. -/\nstructure ChartedSpaceCore (H : Type*) [TopologicalSpace H] (M : Type*) where\n  /-- An atlas of charts, which are only `PartialEquiv`s -/\n  atlas : Set (PartialEquiv M H)\n  /-- The preferred chart at each point -/\n  chartAt : M → PartialEquiv M H\n  mem_chart_source : ∀ x, x ∈ (chartAt x).source\n  chart_mem_atlas : ∀ x, chartAt x ∈ atlas\n  open_source : ∀ e e' : PartialEquiv M H, e ∈ atlas → e' ∈ atlas → IsOpen (e.symm.trans e').source\n  continuousOn_toFun : ∀ e e' : PartialEquiv M H, e ∈ atlas → e' ∈ atlas →\n    ContinuousOn (e.symm.trans e') (e.symm.trans e').source\n\n"}
{"name":"ChartedSpaceCore.continuousOn_toFun","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝ : TopologicalSpace H\nM : Type u_6\nself : ChartedSpaceCore H M\ne e' : PartialEquiv M H\na✝¹ : Membership.mem self.atlas e\na✝ : Membership.mem self.atlas e'\n⊢ ContinuousOn (↑(e.symm.trans e')) (e.symm.trans e').source","decl":"/-- Sometimes, one may want to construct a charted space structure on a space which does not yet\nhave a topological structure, where the topology would come from the charts. For this, one needs\ncharts that are only partial equivalences, and continuity properties for their composition.\nThis is formalised in `ChartedSpaceCore`. -/\nstructure ChartedSpaceCore (H : Type*) [TopologicalSpace H] (M : Type*) where\n  /-- An atlas of charts, which are only `PartialEquiv`s -/\n  atlas : Set (PartialEquiv M H)\n  /-- The preferred chart at each point -/\n  chartAt : M → PartialEquiv M H\n  mem_chart_source : ∀ x, x ∈ (chartAt x).source\n  chart_mem_atlas : ∀ x, chartAt x ∈ atlas\n  open_source : ∀ e e' : PartialEquiv M H, e ∈ atlas → e' ∈ atlas → IsOpen (e.symm.trans e').source\n  continuousOn_toFun : ∀ e e' : PartialEquiv M H, e ∈ atlas → e' ∈ atlas →\n    ContinuousOn (e.symm.trans e') (e.symm.trans e').source\n\n"}
{"name":"ChartedSpaceCore.mk.injEq","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝ : TopologicalSpace H\nM : Type u_6\natlas✝ : Set (PartialEquiv M H)\nchartAt✝ : M → PartialEquiv M H\nmem_chart_source✝ : ∀ (x : M), Membership.mem (chartAt✝ x).source x\nchart_mem_atlas✝ : ∀ (x : M), Membership.mem atlas✝ (chartAt✝ x)\nopen_source✝ : ∀ (e e' : PartialEquiv M H), Membership.mem atlas✝ e → Membership.mem atlas✝ e' → IsOpen (e.symm.trans e').source\ncontinuousOn_toFun✝ : ∀ (e e' : PartialEquiv M H), Membership.mem atlas✝ e → Membership.mem atlas✝ e' → ContinuousOn (↑(e.symm.trans e')) (e.symm.trans e').source\natlas : Set (PartialEquiv M H)\nchartAt : M → PartialEquiv M H\nmem_chart_source : ∀ (x : M), Membership.mem (chartAt x).source x\nchart_mem_atlas : ∀ (x : M), Membership.mem atlas (chartAt x)\nopen_source : ∀ (e e' : PartialEquiv M H), Membership.mem atlas e → Membership.mem atlas e' → IsOpen (e.symm.trans e').source\ncontinuousOn_toFun : ∀ (e e' : PartialEquiv M H), Membership.mem atlas e → Membership.mem atlas e' → ContinuousOn (↑(e.symm.trans e')) (e.symm.trans e').source\n⊢ Eq (Eq { atlas := atlas✝, chartAt := chartAt✝, mem_chart_source := mem_chart_source✝, chart_mem_atlas := chart_mem_atlas✝, open_source := open_source✝, continuousOn_toFun := continuousOn_toFun✝ } { atlas := atlas, chartAt := chartAt, mem_chart_source := mem_chart_source, chart_mem_atlas := chart_mem_atlas, open_source := open_source, continuousOn_toFun := continuousOn_toFun }) (And (Eq atlas✝ atlas) (Eq chartAt✝ chartAt))","decl":"/-- Sometimes, one may want to construct a charted space structure on a space which does not yet\nhave a topological structure, where the topology would come from the charts. For this, one needs\ncharts that are only partial equivalences, and continuity properties for their composition.\nThis is formalised in `ChartedSpaceCore`. -/\nstructure ChartedSpaceCore (H : Type*) [TopologicalSpace H] (M : Type*) where\n  /-- An atlas of charts, which are only `PartialEquiv`s -/\n  atlas : Set (PartialEquiv M H)\n  /-- The preferred chart at each point -/\n  chartAt : M → PartialEquiv M H\n  mem_chart_source : ∀ x, x ∈ (chartAt x).source\n  chart_mem_atlas : ∀ x, chartAt x ∈ atlas\n  open_source : ∀ e e' : PartialEquiv M H, e ∈ atlas → e' ∈ atlas → IsOpen (e.symm.trans e').source\n  continuousOn_toFun : ∀ e e' : PartialEquiv M H, e ∈ atlas → e' ∈ atlas →\n    ContinuousOn (e.symm.trans e') (e.symm.trans e').source\n\n"}
{"name":"ChartedSpaceCore.chart_mem_atlas","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝ : TopologicalSpace H\nM : Type u_6\nself : ChartedSpaceCore H M\nx : M\n⊢ Membership.mem self.atlas (self.chartAt x)","decl":"/-- Sometimes, one may want to construct a charted space structure on a space which does not yet\nhave a topological structure, where the topology would come from the charts. For this, one needs\ncharts that are only partial equivalences, and continuity properties for their composition.\nThis is formalised in `ChartedSpaceCore`. -/\nstructure ChartedSpaceCore (H : Type*) [TopologicalSpace H] (M : Type*) where\n  /-- An atlas of charts, which are only `PartialEquiv`s -/\n  atlas : Set (PartialEquiv M H)\n  /-- The preferred chart at each point -/\n  chartAt : M → PartialEquiv M H\n  mem_chart_source : ∀ x, x ∈ (chartAt x).source\n  chart_mem_atlas : ∀ x, chartAt x ∈ atlas\n  open_source : ∀ e e' : PartialEquiv M H, e ∈ atlas → e' ∈ atlas → IsOpen (e.symm.trans e').source\n  continuousOn_toFun : ∀ e e' : PartialEquiv M H, e ∈ atlas → e' ∈ atlas →\n    ContinuousOn (e.symm.trans e') (e.symm.trans e').source\n\n"}
{"name":"ChartedSpaceCore.mk.inj","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝ : TopologicalSpace H\nM : Type u_6\natlas✝ : Set (PartialEquiv M H)\nchartAt✝ : M → PartialEquiv M H\nmem_chart_source✝ : ∀ (x : M), Membership.mem (chartAt✝ x).source x\nchart_mem_atlas✝ : ∀ (x : M), Membership.mem atlas✝ (chartAt✝ x)\nopen_source✝ : ∀ (e e' : PartialEquiv M H), Membership.mem atlas✝ e → Membership.mem atlas✝ e' → IsOpen (e.symm.trans e').source\ncontinuousOn_toFun✝ : ∀ (e e' : PartialEquiv M H), Membership.mem atlas✝ e → Membership.mem atlas✝ e' → ContinuousOn (↑(e.symm.trans e')) (e.symm.trans e').source\natlas : Set (PartialEquiv M H)\nchartAt : M → PartialEquiv M H\nmem_chart_source : ∀ (x : M), Membership.mem (chartAt x).source x\nchart_mem_atlas : ∀ (x : M), Membership.mem atlas (chartAt x)\nopen_source : ∀ (e e' : PartialEquiv M H), Membership.mem atlas e → Membership.mem atlas e' → IsOpen (e.symm.trans e').source\ncontinuousOn_toFun : ∀ (e e' : PartialEquiv M H), Membership.mem atlas e → Membership.mem atlas e' → ContinuousOn (↑(e.symm.trans e')) (e.symm.trans e').source\nx✝ : Eq { atlas := atlas✝, chartAt := chartAt✝, mem_chart_source := mem_chart_source✝, chart_mem_atlas := chart_mem_atlas✝, open_source := open_source✝, continuousOn_toFun := continuousOn_toFun✝ } { atlas := atlas, chartAt := chartAt, mem_chart_source := mem_chart_source, chart_mem_atlas := chart_mem_atlas, open_source := open_source, continuousOn_toFun := continuousOn_toFun }\n⊢ And (Eq atlas✝ atlas) (Eq chartAt✝ chartAt)","decl":"/-- Sometimes, one may want to construct a charted space structure on a space which does not yet\nhave a topological structure, where the topology would come from the charts. For this, one needs\ncharts that are only partial equivalences, and continuity properties for their composition.\nThis is formalised in `ChartedSpaceCore`. -/\nstructure ChartedSpaceCore (H : Type*) [TopologicalSpace H] (M : Type*) where\n  /-- An atlas of charts, which are only `PartialEquiv`s -/\n  atlas : Set (PartialEquiv M H)\n  /-- The preferred chart at each point -/\n  chartAt : M → PartialEquiv M H\n  mem_chart_source : ∀ x, x ∈ (chartAt x).source\n  chart_mem_atlas : ∀ x, chartAt x ∈ atlas\n  open_source : ∀ e e' : PartialEquiv M H, e ∈ atlas → e' ∈ atlas → IsOpen (e.symm.trans e').source\n  continuousOn_toFun : ∀ e e' : PartialEquiv M H, e ∈ atlas → e' ∈ atlas →\n    ContinuousOn (e.symm.trans e') (e.symm.trans e').source\n\n"}
{"name":"ChartedSpaceCore.open_source'","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝ : TopologicalSpace H\nc : ChartedSpaceCore H M\ne : PartialEquiv M H\nhe : Membership.mem c.atlas e\n⊢ IsOpen e.source","decl":"theorem open_source' (he : e ∈ c.atlas) : IsOpen[c.toTopologicalSpace] e.source := by\n  apply TopologicalSpace.GenerateOpen.basic\n  simp only [exists_prop, mem_iUnion, mem_singleton_iff]\n  refine ⟨e, he, univ, isOpen_univ, ?_⟩\n  simp only [Set.univ_inter, Set.preimage_univ]\n\n"}
{"name":"ChartedSpaceCore.open_target","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝ : TopologicalSpace H\nc : ChartedSpaceCore H M\ne : PartialEquiv M H\nhe : Membership.mem c.atlas e\n⊢ IsOpen e.target","decl":"theorem open_target (he : e ∈ c.atlas) : IsOpen e.target := by\n  have E : e.target ∩ e.symm ⁻¹' e.source = e.target :=\n    Subset.antisymm inter_subset_left fun x hx ↦\n      ⟨hx, PartialEquiv.target_subset_preimage_source _ hx⟩\n  simpa [PartialEquiv.trans_source, E] using c.open_source e e he he\n\n"}
{"name":"HasGroupoid.compatible","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝² : TopologicalSpace H\nM : Type u_6\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nG : StructureGroupoid H\nself : HasGroupoid M G\ne e' : PartialHomeomorph M H\na✝¹ : Membership.mem (atlas H M) e\na✝ : Membership.mem (atlas H M) e'\n⊢ Membership.mem G (e.symm.trans e')","decl":"/-- A charted space has an atlas in a groupoid `G` if the change of coordinates belong to the\ngroupoid. -/\nclass HasGroupoid {H : Type*} [TopologicalSpace H] (M : Type*) [TopologicalSpace M]\n    [ChartedSpace H M] (G : StructureGroupoid H) : Prop where\n  compatible : ∀ {e e' : PartialHomeomorph M H}, e ∈ atlas H M → e' ∈ atlas H M → e.symm ≫ₕ e' ∈ G\n\n"}
{"name":"StructureGroupoid.compatible","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝³ : TopologicalSpace H\nG : StructureGroupoid H\nM : Type u_6\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\ninst✝ : HasGroupoid M G\ne e' : PartialHomeomorph M H\nhe : Membership.mem (atlas H M) e\nhe' : Membership.mem (atlas H M) e'\n⊢ Membership.mem G (e.symm.trans e')","decl":"/-- Reformulate in the `StructureGroupoid` namespace the compatibility condition of charts in a\ncharted space admitting a structure groupoid, to make it more easily accessible with dot\nnotation. -/\ntheorem StructureGroupoid.compatible {H : Type*} [TopologicalSpace H] (G : StructureGroupoid H)\n    {M : Type*} [TopologicalSpace M] [ChartedSpace H M] [HasGroupoid M G]\n    {e e' : PartialHomeomorph M H} (he : e ∈ atlas H M) (he' : e' ∈ atlas H M) : e.symm ≫ₕ e' ∈ G :=\n  HasGroupoid.compatible he he'\n\n"}
{"name":"hasGroupoid_of_le","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nG₁ G₂ : StructureGroupoid H\nh : HasGroupoid M G₁\nhle : LE.le G₁ G₂\n⊢ HasGroupoid M G₂","decl":"theorem hasGroupoid_of_le {G₁ G₂ : StructureGroupoid H} (h : HasGroupoid M G₁) (hle : G₁ ≤ G₂) :\n    HasGroupoid M G₂ :=\n  ⟨fun he he' ↦ hle (h.compatible he he')⟩\n\n"}
{"name":"hasGroupoid_inf_iff","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nG₁ G₂ : StructureGroupoid H\n⊢ Iff (HasGroupoid M (Min.min G₁ G₂)) (And (HasGroupoid M G₁) (HasGroupoid M G₂))","decl":"theorem hasGroupoid_inf_iff {G₁ G₂ : StructureGroupoid H} : HasGroupoid M (G₁ ⊓ G₂) ↔\n    HasGroupoid M G₁ ∧ HasGroupoid M G₂ :=\n  ⟨(fun h ↦ ⟨hasGroupoid_of_le h inf_le_left, hasGroupoid_of_le h inf_le_right⟩),\n  fun ⟨h1, h2⟩ ↦ { compatible := fun he he' ↦ ⟨h1.compatible he he', h2.compatible he he'⟩ }⟩\n\n"}
{"name":"hasGroupoid_of_pregroupoid","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nPG : Pregroupoid H\nh : ∀ {e e' : PartialHomeomorph M H}, Membership.mem (atlas H M) e → Membership.mem (atlas H M) e' → PG.property (↑(e.symm.trans e')) (e.symm.trans e').source\n⊢ HasGroupoid M PG.groupoid","decl":"theorem hasGroupoid_of_pregroupoid (PG : Pregroupoid H) (h : ∀ {e e' : PartialHomeomorph M H},\n    e ∈ atlas H M → e' ∈ atlas H M → PG.property (e.symm ≫ₕ e') (e.symm ≫ₕ e').source) :\n    HasGroupoid M PG.groupoid :=\n  ⟨fun he he' ↦ mem_groupoid_of_pregroupoid.mpr ⟨h he he', h he' he⟩⟩\n\n"}
{"name":"hasGroupoid_model_space","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u_5\ninst✝ : TopologicalSpace H\nG : StructureGroupoid H\n⊢ HasGroupoid H G","decl":"/-- The trivial charted space structure on the model space is compatible with any groupoid. -/\ninstance hasGroupoid_model_space (H : Type*) [TopologicalSpace H] (G : StructureGroupoid H) :\n    HasGroupoid H G where\n  compatible {e e'} he he' := by\n    rw [chartedSpaceSelf_atlas] at he he'\n    simp [he, he', StructureGroupoid.id_mem]\n\n"}
{"name":"hasGroupoid_continuousGroupoid","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\n⊢ HasGroupoid M (continuousGroupoid H)","decl":"/-- Any charted space structure is compatible with the groupoid of all partial homeomorphisms. -/\ninstance hasGroupoid_continuousGroupoid : HasGroupoid M (continuousGroupoid H) := by\n  refine ⟨fun _ _ ↦ ?_⟩\n  rw [continuousGroupoid, mem_groupoid_of_pregroupoid]\n  simp only [and_self_iff]\n\n"}
{"name":"StructureGroupoid.trans_restricted","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝⁴ : TopologicalSpace H\ninst✝³ : TopologicalSpace M\ninst✝² : ChartedSpace H M\ne e' : PartialHomeomorph M H\nG : StructureGroupoid H\nhe : Membership.mem (atlas H M) e\nhe' : Membership.mem (atlas H M) e'\ninst✝¹ : HasGroupoid M G\ninst✝ : ClosedUnderRestriction G\ns : TopologicalSpace.Opens M\nhs : Nonempty (Subtype fun x => Membership.mem s x)\n⊢ Membership.mem G ((e.subtypeRestr hs).symm.trans (e'.subtypeRestr hs))","decl":"/-- If `G` is closed under restriction, the transition function between\n  the restriction of two charts `e` and `e'` lies in `G`. -/\ntheorem StructureGroupoid.trans_restricted {e e' : PartialHomeomorph M H} {G : StructureGroupoid H}\n    (he : e ∈ atlas H M) (he' : e' ∈ atlas H M)\n    [HasGroupoid M G] [ClosedUnderRestriction G] {s : Opens M} (hs : Nonempty s) :\n    (e.subtypeRestr hs).symm ≫ₕ e'.subtypeRestr hs ∈ G :=\n  G.mem_of_eqOnSource (closedUnderRestriction' (G.compatible he he')\n    (e.isOpen_inter_preimage_symm s.2)) (e.subtypeRestr_symm_trans_subtypeRestr hs e')\n\n"}
{"name":"StructureGroupoid.subset_maximalAtlas","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝³ : TopologicalSpace H\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\nG : StructureGroupoid H\ninst✝ : HasGroupoid M G\n⊢ HasSubset.Subset (atlas H M) (StructureGroupoid.maximalAtlas M G)","decl":"/-- The elements of the atlas belong to the maximal atlas for any structure groupoid. -/\ntheorem StructureGroupoid.subset_maximalAtlas [HasGroupoid M G] : atlas H M ⊆ G.maximalAtlas M :=\n  fun _ he _ he' ↦ ⟨G.compatible he he', G.compatible he' he⟩\n\n"}
{"name":"StructureGroupoid.chart_mem_maximalAtlas","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝³ : TopologicalSpace H\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\nG : StructureGroupoid H\ninst✝ : HasGroupoid M G\nx : M\n⊢ Membership.mem (StructureGroupoid.maximalAtlas M G) (chartAt H x)","decl":"theorem StructureGroupoid.chart_mem_maximalAtlas [HasGroupoid M G] (x : M) :\n    chartAt H x ∈ G.maximalAtlas M :=\n  G.subset_maximalAtlas (chart_mem_atlas H x)\n\n"}
{"name":"mem_maximalAtlas_iff","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nG : StructureGroupoid H\ne : PartialHomeomorph M H\n⊢ Iff (Membership.mem (StructureGroupoid.maximalAtlas M G) e) (∀ (e' : PartialHomeomorph M H), Membership.mem (atlas H M) e' → And (Membership.mem G (e.symm.trans e')) (Membership.mem G (e'.symm.trans e)))","decl":"theorem mem_maximalAtlas_iff {e : PartialHomeomorph M H} :\n    e ∈ G.maximalAtlas M ↔ ∀ e' ∈ atlas H M, e.symm ≫ₕ e' ∈ G ∧ e'.symm ≫ₕ e ∈ G :=\n  Iff.rfl\n\n"}
{"name":"StructureGroupoid.compatible_of_mem_maximalAtlas","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nG : StructureGroupoid H\ne e' : PartialHomeomorph M H\nhe : Membership.mem (StructureGroupoid.maximalAtlas M G) e\nhe' : Membership.mem (StructureGroupoid.maximalAtlas M G) e'\n⊢ Membership.mem G (e.symm.trans e')","decl":"/-- Changing coordinates between two elements of the maximal atlas gives rise to an element\nof the structure groupoid. -/\ntheorem StructureGroupoid.compatible_of_mem_maximalAtlas {e e' : PartialHomeomorph M H}\n    (he : e ∈ G.maximalAtlas M) (he' : e' ∈ G.maximalAtlas M) : e.symm ≫ₕ e' ∈ G := by\n  refine G.locality fun x hx ↦ ?_\n  set f := chartAt (H := H) (e.symm x)\n  let s := e.target ∩ e.symm ⁻¹' f.source\n  have hs : IsOpen s := by\n    apply e.symm.continuousOn_toFun.isOpen_inter_preimage <;> apply open_source\n  have xs : x ∈ s := by\n    simp only [s, f, mem_inter_iff, mem_preimage, mem_chart_source, and_true]\n    exact ((mem_inter_iff _ _ _).1 hx).1\n  refine ⟨s, hs, xs, ?_⟩\n  have A : e.symm ≫ₕ f ∈ G := (mem_maximalAtlas_iff.1 he f (chart_mem_atlas _ _)).1\n  have B : f.symm ≫ₕ e' ∈ G := (mem_maximalAtlas_iff.1 he' f (chart_mem_atlas _ _)).2\n  have C : (e.symm ≫ₕ f) ≫ₕ f.symm ≫ₕ e' ∈ G := G.trans A B\n  have D : (e.symm ≫ₕ f) ≫ₕ f.symm ≫ₕ e' ≈ (e.symm ≫ₕ e').restr s := calc\n    (e.symm ≫ₕ f) ≫ₕ f.symm ≫ₕ e' = e.symm ≫ₕ (f ≫ₕ f.symm) ≫ₕ e' := by simp only [trans_assoc]\n    _ ≈ e.symm ≫ₕ ofSet f.source f.open_source ≫ₕ e' :=\n      EqOnSource.trans' (refl _) (EqOnSource.trans' (self_trans_symm _) (refl _))\n    _ ≈ (e.symm ≫ₕ ofSet f.source f.open_source) ≫ₕ e' := by rw [trans_assoc]\n    _ ≈ e.symm.restr s ≫ₕ e' := by rw [trans_of_set']; apply refl\n    _ ≈ (e.symm ≫ₕ e').restr s := by rw [restr_trans]\n  exact G.mem_of_eqOnSource C (Setoid.symm D)\n\n"}
{"name":"StructureGroupoid.mem_maximalAtlas_of_eqOnSource","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nG : StructureGroupoid H\ne e' : PartialHomeomorph M H\nh : HasEquiv.Equiv e' e\nhe : Membership.mem (StructureGroupoid.maximalAtlas M G) e\n⊢ Membership.mem (StructureGroupoid.maximalAtlas M G) e'","decl":"open PartialHomeomorph in\n/-- The maximal atlas of a structure groupoid is stable under equivalence. -/\nlemma StructureGroupoid.mem_maximalAtlas_of_eqOnSource {e e' : PartialHomeomorph M H} (h : e' ≈ e)\n    (he : e ∈ G.maximalAtlas M) : e' ∈ G.maximalAtlas M := by\n  intro e'' he''\n  obtain ⟨l, r⟩ := mem_maximalAtlas_iff.mp he e'' he''\n  exact ⟨G.mem_of_eqOnSource l (EqOnSource.trans' (EqOnSource.symm' h) (e''.eqOnSource_refl)),\n         G.mem_of_eqOnSource r (EqOnSource.trans' (e''.symm).eqOnSource_refl h)⟩\n\n"}
{"name":"StructureGroupoid.id_mem_maximalAtlas","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nG : StructureGroupoid H\n⊢ Membership.mem (StructureGroupoid.maximalAtlas H G) (PartialHomeomorph.refl H)","decl":"/-- In the model space, the identity is in any maximal atlas. -/\ntheorem StructureGroupoid.id_mem_maximalAtlas : PartialHomeomorph.refl H ∈ G.maximalAtlas H :=\n  G.subset_maximalAtlas <| by simp\n\n"}
{"name":"StructureGroupoid.mem_maximalAtlas_of_mem_groupoid","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nG : StructureGroupoid H\nf : PartialHomeomorph H H\nhf : Membership.mem G f\n⊢ Membership.mem (StructureGroupoid.maximalAtlas H G) f","decl":"/-- In the model space, any element of the groupoid is in the maximal atlas. -/\ntheorem StructureGroupoid.mem_maximalAtlas_of_mem_groupoid {f : PartialHomeomorph H H}\n    (hf : f ∈ G) : f ∈ G.maximalAtlas H := by\n  rintro e (rfl : e = PartialHomeomorph.refl H)\n  exact ⟨G.trans (G.symm hf) G.id_mem, G.trans (G.symm G.id_mem) hf⟩\n\n"}
{"name":"StructureGroupoid.maximalAtlas_mono","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nG G' : StructureGroupoid H\nh : LE.le G G'\n⊢ HasSubset.Subset (StructureGroupoid.maximalAtlas M G) (StructureGroupoid.maximalAtlas M G')","decl":"theorem StructureGroupoid.maximalAtlas_mono {G G' : StructureGroupoid H} (h : G ≤ G') :\n    G.maximalAtlas M ⊆ G'.maximalAtlas M :=\n  fun _ he e' he' ↦ ⟨h (he e' he').1, h (he e' he').2⟩\n\n"}
{"name":"PartialHomeomorph.singletonChartedSpace_chartAt_eq","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝¹ : TopologicalSpace H\nα : Type u_5\ninst✝ : TopologicalSpace α\ne : PartialHomeomorph α H\nh : Eq e.source Set.univ\nx : α\n⊢ Eq (chartAt H x) e","decl":"@[simp, mfld_simps]\ntheorem singletonChartedSpace_chartAt_eq (h : e.source = Set.univ) {x : α} :\n    @chartAt H _ α _ (e.singletonChartedSpace h) x = e :=\n  rfl\n\n"}
{"name":"PartialHomeomorph.singletonChartedSpace_chartAt_source","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝¹ : TopologicalSpace H\nα : Type u_5\ninst✝ : TopologicalSpace α\ne : PartialHomeomorph α H\nh : Eq e.source Set.univ\nx : α\n⊢ Eq (chartAt H x).source Set.univ","decl":"theorem singletonChartedSpace_chartAt_source (h : e.source = Set.univ) {x : α} :\n    (@chartAt H _ α _ (e.singletonChartedSpace h) x).source = Set.univ :=\n  h\n\n"}
{"name":"PartialHomeomorph.singletonChartedSpace_mem_atlas_eq","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝¹ : TopologicalSpace H\nα : Type u_5\ninst✝ : TopologicalSpace α\ne : PartialHomeomorph α H\nh : Eq e.source Set.univ\ne' : PartialHomeomorph α H\nh' : Membership.mem ChartedSpace.atlas e'\n⊢ Eq e' e","decl":"theorem singletonChartedSpace_mem_atlas_eq (h : e.source = Set.univ) (e' : PartialHomeomorph α H)\n    (h' : e' ∈ (e.singletonChartedSpace h).atlas) : e' = e :=\n  h'\n\n"}
{"name":"PartialHomeomorph.singleton_hasGroupoid","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝² : TopologicalSpace H\nα : Type u_5\ninst✝¹ : TopologicalSpace α\ne : PartialHomeomorph α H\nh : Eq e.source Set.univ\nG : StructureGroupoid H\ninst✝ : ClosedUnderRestriction G\n⊢ HasGroupoid α G","decl":"/-- Given a partial homeomorphism `e` from a space `α` into `H`, if its source covers the whole\nspace `α`, then the induced charted space structure on `α` is `HasGroupoid G` for any structure\ngroupoid `G` which is closed under restrictions. -/\ntheorem singleton_hasGroupoid (h : e.source = Set.univ) (G : StructureGroupoid H)\n    [ClosedUnderRestriction G] : @HasGroupoid _ _ _ _ (e.singletonChartedSpace h) G :=\n  { __ := e.singletonChartedSpace h\n    compatible := by\n      intro e' e'' he' he''\n      rw [e.singletonChartedSpace_mem_atlas_eq h e' he',\n        e.singletonChartedSpace_mem_atlas_eq h e'' he'']\n      refine G.mem_of_eqOnSource ?_ e.symm_trans_self\n      have hle : idRestrGroupoid ≤ G := (closedUnderRestriction_iff_id_le G).mp (by assumption)\n      exact StructureGroupoid.le_iff.mp hle _ (idRestrGroupoid_mem _) }\n\n"}
{"name":"Topology.IsOpenEmbedding.singletonChartedSpace_chartAt_eq","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝² : TopologicalSpace H\nα : Type u_5\ninst✝¹ : TopologicalSpace α\ninst✝ : Nonempty α\nf : α → H\nh : Topology.IsOpenEmbedding f\nx : α\n⊢ Eq (↑(chartAt H x)) f","decl":"theorem singletonChartedSpace_chartAt_eq {f : α → H} (h : IsOpenEmbedding f) {x : α} :\n    ⇑(@chartAt H _ α _ h.singletonChartedSpace x) = f :=\n  rfl\n\n"}
{"name":"Topology.IsOpenEmbedding.singleton_hasGroupoid","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝³ : TopologicalSpace H\nα : Type u_5\ninst✝² : TopologicalSpace α\ninst✝¹ : Nonempty α\nf : α → H\nh : Topology.IsOpenEmbedding f\nG : StructureGroupoid H\ninst✝ : ClosedUnderRestriction G\n⊢ HasGroupoid α G","decl":"theorem singleton_hasGroupoid {f : α → H} (h : IsOpenEmbedding f) (G : StructureGroupoid H)\n    [ClosedUnderRestriction G] : @HasGroupoid _ _ _ _ h.singletonChartedSpace G :=\n  (h.toPartialHomeomorph f).singleton_hasGroupoid (toPartialHomeomorph_source _ _) G\n\n"}
{"name":"TopologicalSpace.Opens.chart_eq","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\ns : TopologicalSpace.Opens M\nhs : Nonempty (Subtype fun x => Membership.mem s x)\ne : PartialHomeomorph (Subtype fun x => Membership.mem s x) H\nhe : Membership.mem (atlas H (Subtype fun x => Membership.mem s x)) e\n⊢ Exists fun x => Eq e ((chartAt H ↑x).subtypeRestr hs)","decl":"/-- If `s` is a non-empty open subset of `M`, every chart of `s` is the restriction\n of some chart on `M`. -/\nlemma chart_eq {s : Opens M} (hs : Nonempty s) {e : PartialHomeomorph s H} (he : e ∈ atlas H s) :\n    ∃ x : s, e = (chartAt H (x : M)).subtypeRestr hs := by\n  rcases he with ⟨xset, ⟨x, hx⟩, he⟩\n  exact ⟨x, mem_singleton_iff.mp (by convert he)⟩\n\n"}
{"name":"TopologicalSpace.Opens.chart_eq'","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝ : TopologicalSpace H\nt : TopologicalSpace.Opens H\nht : Nonempty (Subtype fun x => Membership.mem t x)\ne' : PartialHomeomorph (Subtype fun x => Membership.mem t x) H\nhe' : Membership.mem (atlas H (Subtype fun x => Membership.mem t x)) e'\n⊢ Exists fun x => Eq e' ((chartAt H ↑x).subtypeRestr ht)","decl":"/-- If `t` is a non-empty open subset of `H`,\n  every chart of `t` is the restriction of some chart on `H`. -/\n-- XXX: can I unify this with `chart_eq`?\nlemma chart_eq' {t : Opens H} (ht : Nonempty t) {e' : PartialHomeomorph t H}\n    (he' : e' ∈ atlas H t) : ∃ x : t, e' = (chartAt H ↑x).subtypeRestr ht := by\n  rcases he' with ⟨xset, ⟨x, hx⟩, he'⟩\n  exact ⟨x, mem_singleton_iff.mp (by convert he')⟩\n\n"}
{"name":"TopologicalSpace.Opens.instHasGroupoid","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝³ : TopologicalSpace H\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\nG : StructureGroupoid H\ns : TopologicalSpace.Opens M\ninst✝ : ClosedUnderRestriction G\n⊢ HasGroupoid (Subtype fun x => Membership.mem s x) G","decl":"/-- If a groupoid `G` is `ClosedUnderRestriction`, then an open subset of a space which is\n`HasGroupoid G` is naturally `HasGroupoid G`. -/\nprotected instance instHasGroupoid [ClosedUnderRestriction G] : HasGroupoid s G where\n  compatible := by\n    rintro e e' ⟨_, ⟨x, hc⟩, he⟩ ⟨_, ⟨x', hc'⟩, he'⟩\n    rw [hc.symm, mem_singleton_iff] at he\n    rw [hc'.symm, mem_singleton_iff] at he'\n    rw [he, he']\n    refine G.mem_of_eqOnSource ?_\n      (subtypeRestr_symm_trans_subtypeRestr (s := s) _ (chartAt H x) (chartAt H x'))\n    apply closedUnderRestriction'\n    · exact G.compatible (chart_mem_atlas _ _) (chart_mem_atlas _ _)\n    · exact isOpen_inter_preimage_symm (chartAt _ _) s.2\n\n"}
{"name":"TopologicalSpace.Opens.chartAt_subtype_val_symm_eventuallyEq","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nU : TopologicalSpace.Opens M\nx : Subtype fun x => Membership.mem U x\n⊢ (nhds (↑(chartAt H ↑x) ↑x)).EventuallyEq (↑(chartAt H ↑x).symm) (Function.comp Subtype.val ↑(chartAt H x).symm)","decl":"theorem chartAt_subtype_val_symm_eventuallyEq (U : Opens M) {x : U} :\n    (chartAt H x.val).symm =ᶠ[𝓝 (chartAt H x.val x.val)] Subtype.val ∘ (chartAt H x).symm := by\n  set e := chartAt H x.val\n  have heUx_nhds : (e.subtypeRestr ⟨x⟩).target ∈ 𝓝 (e x) := by\n    apply (e.subtypeRestr ⟨x⟩).open_target.mem_nhds\n    exact e.map_subtype_source ⟨x⟩ (mem_chart_source _ _)\n  exact Filter.eventuallyEq_of_mem heUx_nhds (e.subtypeRestr_symm_eqOn ⟨x⟩)\n\n"}
{"name":"TopologicalSpace.Opens.chartAt_inclusion_symm_eventuallyEq","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nU V : TopologicalSpace.Opens M\nhUV : LE.le U V\nx : Subtype fun x => Membership.mem U x\n⊢ (nhds (↑(chartAt H (TopologicalSpace.Opens.inclusion hUV x)) (Set.inclusion hUV x))).EventuallyEq (↑(chartAt H (TopologicalSpace.Opens.inclusion hUV x)).symm) (Function.comp (TopologicalSpace.Opens.inclusion hUV) ↑(chartAt H x).symm)","decl":"theorem chartAt_inclusion_symm_eventuallyEq {U V : Opens M} (hUV : U ≤ V) {x : U} :\n    (chartAt H (Opens.inclusion hUV x)).symm\n    =ᶠ[𝓝 (chartAt H (Opens.inclusion hUV x) (Set.inclusion hUV x))]\n    Opens.inclusion hUV ∘ (chartAt H x).symm := by\n  set e := chartAt H (x : M)\n  have heUx_nhds : (e.subtypeRestr ⟨x⟩).target ∈ 𝓝 (e x) := by\n    apply (e.subtypeRestr ⟨x⟩).open_target.mem_nhds\n    exact e.map_subtype_source ⟨x⟩ (mem_chart_source _ _)\n  exact Filter.eventuallyEq_of_mem heUx_nhds <| e.subtypeRestr_symm_eqOn_of_le ⟨x⟩\n    ⟨Opens.inclusion hUV x⟩ hUV\n"}
{"name":"StructureGroupoid.restriction_in_maximalAtlas","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝⁴ : TopologicalSpace H\ninst✝³ : TopologicalSpace M\ninst✝² : ChartedSpace H M\ne : PartialHomeomorph M H\nhe : Membership.mem (atlas H M) e\ns : TopologicalSpace.Opens M\nhs : Nonempty (Subtype fun x => Membership.mem s x)\nG : StructureGroupoid H\ninst✝¹ : HasGroupoid M G\ninst✝ : ClosedUnderRestriction G\n⊢ Membership.mem (StructureGroupoid.maximalAtlas (Subtype fun x => Membership.mem s x) G) (e.subtypeRestr hs)","decl":"/-- Restricting a chart of `M` to an open subset `s` yields a chart in the maximal atlas of `s`.\n\nNB. We cannot deduce membership in `atlas H s` in general: by definition, this atlas contains\nprecisely the restriction of each preferred chart at `x ∈ s` --- whereas `atlas H M`\ncan contain more charts than these. -/\nlemma StructureGroupoid.restriction_in_maximalAtlas {e : PartialHomeomorph M H}\n    (he : e ∈ atlas H M) {s : Opens M} (hs : Nonempty s) {G : StructureGroupoid H} [HasGroupoid M G]\n    [ClosedUnderRestriction G] : e.subtypeRestr hs ∈ G.maximalAtlas s := by\n  intro e' he'\n  -- `e'` is the restriction of some chart of `M` at `x`,\n  obtain ⟨x, this⟩ := Opens.chart_eq hs he'\n  rw [this]\n  -- The transition functions between the unrestricted charts lie in the groupoid,\n  -- the transition functions of the restriction are the restriction of the transition function.\n  exact ⟨G.trans_restricted he (chart_mem_atlas H (x : M)) hs,\n         G.trans_restricted (chart_mem_atlas H (x : M)) he hs⟩\n\n"}
{"name":"Structomorph.mem_groupoid","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝⁴ : TopologicalSpace H\nG : StructureGroupoid H\nM : Type u_5\nM' : Type u_6\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace M'\ninst✝¹ : ChartedSpace H M\ninst✝ : ChartedSpace H M'\nself : Structomorph G M M'\nc : PartialHomeomorph M H\nc' : PartialHomeomorph M' H\na✝¹ : Membership.mem (atlas H M) c\na✝ : Membership.mem (atlas H M') c'\n⊢ Membership.mem G (c.symm.trans (self.toPartialHomeomorph.trans c'))","decl":"/-- A `G`-diffeomorphism between two charted spaces is a homeomorphism which, when read in the\ncharts, belongs to `G`. We avoid the word diffeomorph as it is too related to the smooth category,\nand use structomorph instead. -/\nstructure Structomorph (G : StructureGroupoid H) (M : Type*) (M' : Type*) [TopologicalSpace M]\n  [TopologicalSpace M'] [ChartedSpace H M] [ChartedSpace H M'] extends Homeomorph M M' where\n  mem_groupoid : ∀ c : PartialHomeomorph M H, ∀ c' : PartialHomeomorph M' H, c ∈ atlas H M →\n    c' ∈ atlas H M' → c.symm ≫ₕ toHomeomorph.toPartialHomeomorph ≫ₕ c' ∈ G\n\n"}
{"name":"Structomorph.mk.sizeOf_spec","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝⁷ : TopologicalSpace H\nG : StructureGroupoid H\nM : Type u_5\nM' : Type u_6\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : TopologicalSpace M'\ninst✝⁴ : ChartedSpace H M\ninst✝³ : ChartedSpace H M'\ninst✝² : SizeOf H\ninst✝¹ : SizeOf M\ninst✝ : SizeOf M'\ntoHomeomorph : Homeomorph M M'\nmem_groupoid : ∀ (c : PartialHomeomorph M H) (c' : PartialHomeomorph M' H), Membership.mem (atlas H M) c → Membership.mem (atlas H M') c' → Membership.mem G (c.symm.trans (toHomeomorph.toPartialHomeomorph.trans c'))\n⊢ Eq (SizeOf.sizeOf { toHomeomorph := toHomeomorph, mem_groupoid := mem_groupoid }) (HAdd.hAdd 1 (SizeOf.sizeOf toHomeomorph))","decl":"/-- A `G`-diffeomorphism between two charted spaces is a homeomorphism which, when read in the\ncharts, belongs to `G`. We avoid the word diffeomorph as it is too related to the smooth category,\nand use structomorph instead. -/\nstructure Structomorph (G : StructureGroupoid H) (M : Type*) (M' : Type*) [TopologicalSpace M]\n  [TopologicalSpace M'] [ChartedSpace H M] [ChartedSpace H M'] extends Homeomorph M M' where\n  mem_groupoid : ∀ c : PartialHomeomorph M H, ∀ c' : PartialHomeomorph M' H, c ∈ atlas H M →\n    c' ∈ atlas H M' → c.symm ≫ₕ toHomeomorph.toPartialHomeomorph ≫ₕ c' ∈ G\n\n"}
{"name":"Structomorph.mk.inj","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝⁴ : TopologicalSpace H\nG : StructureGroupoid H\nM : Type u_5\nM' : Type u_6\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace M'\ninst✝¹ : ChartedSpace H M\ninst✝ : ChartedSpace H M'\ntoHomeomorph✝ : Homeomorph M M'\nmem_groupoid✝ : ∀ (c : PartialHomeomorph M H) (c' : PartialHomeomorph M' H), Membership.mem (atlas H M) c → Membership.mem (atlas H M') c' → Membership.mem G (c.symm.trans (toHomeomorph✝.toPartialHomeomorph.trans c'))\ntoHomeomorph : Homeomorph M M'\nmem_groupoid : ∀ (c : PartialHomeomorph M H) (c' : PartialHomeomorph M' H), Membership.mem (atlas H M) c → Membership.mem (atlas H M') c' → Membership.mem G (c.symm.trans (toHomeomorph.toPartialHomeomorph.trans c'))\nx✝ : Eq { toHomeomorph := toHomeomorph✝, mem_groupoid := mem_groupoid✝ } { toHomeomorph := toHomeomorph, mem_groupoid := mem_groupoid }\n⊢ Eq toHomeomorph✝ toHomeomorph","decl":"/-- A `G`-diffeomorphism between two charted spaces is a homeomorphism which, when read in the\ncharts, belongs to `G`. We avoid the word diffeomorph as it is too related to the smooth category,\nand use structomorph instead. -/\nstructure Structomorph (G : StructureGroupoid H) (M : Type*) (M' : Type*) [TopologicalSpace M]\n  [TopologicalSpace M'] [ChartedSpace H M] [ChartedSpace H M'] extends Homeomorph M M' where\n  mem_groupoid : ∀ c : PartialHomeomorph M H, ∀ c' : PartialHomeomorph M' H, c ∈ atlas H M →\n    c' ∈ atlas H M' → c.symm ≫ₕ toHomeomorph.toPartialHomeomorph ≫ₕ c' ∈ G\n\n"}
{"name":"Structomorph.mk.injEq","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\ninst✝⁴ : TopologicalSpace H\nG : StructureGroupoid H\nM : Type u_5\nM' : Type u_6\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace M'\ninst✝¹ : ChartedSpace H M\ninst✝ : ChartedSpace H M'\ntoHomeomorph✝ : Homeomorph M M'\nmem_groupoid✝ : ∀ (c : PartialHomeomorph M H) (c' : PartialHomeomorph M' H), Membership.mem (atlas H M) c → Membership.mem (atlas H M') c' → Membership.mem G (c.symm.trans (toHomeomorph✝.toPartialHomeomorph.trans c'))\ntoHomeomorph : Homeomorph M M'\nmem_groupoid : ∀ (c : PartialHomeomorph M H) (c' : PartialHomeomorph M' H), Membership.mem (atlas H M) c → Membership.mem (atlas H M') c' → Membership.mem G (c.symm.trans (toHomeomorph.toPartialHomeomorph.trans c'))\n⊢ Eq (Eq { toHomeomorph := toHomeomorph✝, mem_groupoid := mem_groupoid✝ } { toHomeomorph := toHomeomorph, mem_groupoid := mem_groupoid }) (Eq toHomeomorph✝ toHomeomorph)","decl":"/-- A `G`-diffeomorphism between two charted spaces is a homeomorphism which, when read in the\ncharts, belongs to `G`. We avoid the word diffeomorph as it is too related to the smooth category,\nand use structomorph instead. -/\nstructure Structomorph (G : StructureGroupoid H) (M : Type*) (M' : Type*) [TopologicalSpace M]\n  [TopologicalSpace M'] [ChartedSpace H M] [ChartedSpace H M'] extends Homeomorph M M' where\n  mem_groupoid : ∀ c : PartialHomeomorph M H, ∀ c' : PartialHomeomorph M' H, c ∈ atlas H M →\n    c' ∈ atlas H M' → c.symm ≫ₕ toHomeomorph.toPartialHomeomorph ≫ₕ c' ∈ G\n\n"}
{"name":"StructureGroupoid.restriction_mem_maximalAtlas_subtype","module":"Mathlib.Geometry.Manifold.ChartedSpace","initialProofState":"H : Type u\nM : Type u_2\ninst✝⁴ : TopologicalSpace H\ninst✝³ : TopologicalSpace M\ninst✝² : ChartedSpace H M\nG : StructureGroupoid H\ne : PartialHomeomorph M H\nhe : Membership.mem (atlas H M) e\nhs : Nonempty ↑e.source\ninst✝¹ : HasGroupoid M G\ninst✝ : ClosedUnderRestriction G\n⊢ let s := { carrier := e.source, is_open' := ⋯ };\n  let t := { carrier := e.target, is_open' := ⋯ };\n  ∀ (c' : PartialHomeomorph (Subtype fun x => Membership.mem t x) H), Membership.mem (atlas H (Subtype fun x => Membership.mem t x)) c' → Membership.mem (StructureGroupoid.maximalAtlas (Subtype fun x => Membership.mem s x) G) (e.toHomeomorphSourceTarget.toPartialHomeomorph.trans c')","decl":"/-- Restricting a chart to its source `s ⊆ M` yields a chart in the maximal atlas of `s`. -/\ntheorem StructureGroupoid.restriction_mem_maximalAtlas_subtype\n    {e : PartialHomeomorph M H} (he : e ∈ atlas H M)\n    (hs : Nonempty e.source) [HasGroupoid M G] [ClosedUnderRestriction G] :\n    let s := { carrier := e.source, is_open' := e.open_source : Opens M }\n    let t := { carrier := e.target, is_open' := e.open_target : Opens H }\n    ∀ c' ∈ atlas H t, e.toHomeomorphSourceTarget.toPartialHomeomorph ≫ₕ c' ∈ G.maximalAtlas s := by\n  intro s t c' hc'\n  have : Nonempty t := nonempty_coe_sort.mpr (e.mapsTo.nonempty (nonempty_coe_sort.mp hs))\n  obtain ⟨x, hc'⟩ := Opens.chart_eq this hc'\n  -- As H has only one chart, `chartAt H x` is the identity: i.e., `c'` is the inclusion.\n  rw [hc', (chartAt_self_eq)]\n  -- Our expression equals this chart, at least on its source.\n  rw [PartialHomeomorph.subtypeRestr_def, PartialHomeomorph.trans_refl]\n  let goal := e.toHomeomorphSourceTarget.toPartialHomeomorph ≫ₕ (t.partialHomeomorphSubtypeCoe this)\n  have : goal ≈ e.subtypeRestr (s := s) hs :=\n    (goal.eqOnSource_iff (e.subtypeRestr (s := s) hs)).mpr\n      ⟨by\n        simp only [trans_toPartialEquiv, PartialEquiv.trans_source,\n          Homeomorph.toPartialHomeomorph_source, toFun_eq_coe, Homeomorph.toPartialHomeomorph_apply,\n          Opens.partialHomeomorphSubtypeCoe_source, preimage_univ, inter_self, subtypeRestr_source,\n          goal, s]\n        exact Subtype.coe_preimage_self _ |>.symm, by intro _ _; rfl⟩\n  exact G.mem_maximalAtlas_of_eqOnSource (M := s) this (G.restriction_in_maximalAtlas he hs)\n\n"}
