{"name":"TopCat.Presheaf.comp_app","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : TopCat\nU : Opposite (TopologicalSpace.Opens ‚ÜëX)\nP Q R : TopCat.Presheaf C X\nf : Quiver.Hom P Q\ng : Quiver.Hom Q R\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.comp f g).app U) (CategoryTheory.CategoryStruct.comp (f.app U) (g.app U))","decl":"@[simp] theorem comp_app {X : TopCat} {U : (Opens X)·µí·µñ} {P Q R : Presheaf C X}\n    (f : P ‚ü∂ Q) (g : Q ‚ü∂ R) :\n    (f ‚â´ g).app U = f.app U ‚â´ g.app U := rfl\n\n"}
{"name":"TopCat.Presheaf.ext","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : TopCat\nP Q : TopCat.Presheaf C X\nf g : Quiver.Hom P Q\nw : ‚àÄ (U : TopologicalSpace.Opens ‚ÜëX), Eq (f.app { unop := U }) (g.app { unop := U })\n‚ä¢ Eq f g","decl":"@[ext]\nlemma ext {X : TopCat} {P Q : Presheaf C X} {f g : P ‚ü∂ Q}\n    (w : ‚àÄ U : Opens X, f.app (op U) = g.app (op U)) :\n    f = g := by\n  apply NatTrans.ext\n  ext U\n  induction U with | _ U => ?_\n  apply w\n\n"}
{"name":"TopCat.Presheaf.ext_iff","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : TopCat\nP Q : TopCat.Presheaf C X\nf g : Quiver.Hom P Q\n‚ä¢ Iff (Eq f g) (‚àÄ (U : TopologicalSpace.Opens ‚ÜëX), Eq (f.app { unop := U }) (g.app { unop := U }))","decl":"@[ext]\nlemma ext {X : TopCat} {P Q : Presheaf C X} {f g : P ‚ü∂ Q}\n    (w : ‚àÄ U : Opens X, f.app (op U) = g.app (op U)) :\n    f = g := by\n  apply NatTrans.ext\n  ext U\n  induction U with | _ U => ?_\n  apply w\n\n"}
{"name":"TopCat.Presheaf.restrict_restrict","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"X : TopCat\nC : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.HasForget C\nF : TopCat.Presheaf C X\nU V W : TopologicalSpace.Opens ‚ÜëX\ne‚ÇÅ : LE.le U V\ne‚ÇÇ : LE.le V W\nx : (CategoryTheory.forget C).obj (F.obj { unop := W })\n‚ä¢ Eq (TopCat.Presheaf.restrictOpen (TopCat.Presheaf.restrictOpen x V ‚ãØ) U ‚ãØ) (TopCat.Presheaf.restrictOpen x U ‚ãØ)","decl":"theorem restrict_restrict {X : TopCat} {C : Type*} [Category C] [HasForget C]\n    {F : X.Presheaf C} {U V W : Opens X} (e‚ÇÅ : U ‚â§ V) (e‚ÇÇ : V ‚â§ W) (x : F.obj (op W)) :\n    x |_ V |_ U = x |_ U := by\n  delta restrictOpen restrict\n  rw [‚Üê CategoryTheory.comp_apply, ‚Üê Functor.map_comp]\n  rfl\n\n"}
{"name":"TopCat.Presheaf.map_restrict","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"X : TopCat\nC : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.HasForget C\nF G : TopCat.Presheaf C X\ne : Quiver.Hom F G\nU V : TopologicalSpace.Opens ‚ÜëX\nh : LE.le U V\nx : (CategoryTheory.forget C).obj (F.obj { unop := V })\n‚ä¢ Eq ((e.app { unop := U }) (TopCat.Presheaf.restrictOpen x U ‚ãØ)) (TopCat.Presheaf.restrictOpen ((e.app { unop := V }) x) U ‚ãØ)","decl":"theorem map_restrict {X : TopCat} {C : Type*} [Category C] [HasForget C]\n    {F G : X.Presheaf C} (e : F ‚ü∂ G) {U V : Opens X} (h : U ‚â§ V) (x : F.obj (op V)) :\n    e.app _ (x |_ U) = e.app _ x |_ U := by\n  delta restrictOpen restrict\n  rw [‚Üê CategoryTheory.comp_apply, NatTrans.naturality, CategoryTheory.comp_apply]\n\n"}
{"name":"TopCat.Presheaf.pushforward_obj_map","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : TopCat\nf‚úù : Quiver.Hom X Y\nG : CategoryTheory.Functor (Opposite (TopologicalSpace.Opens ‚ÜëX)) C\nX‚úù Y‚úù : Opposite (TopologicalSpace.Opens ‚ÜëY)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((TopCat.Presheaf.pushforward C f‚úù).obj G).map f) (G.map ((TopologicalSpace.Opens.map f‚úù).map f.unop).op)","decl":"/-- The pushforward functor. -/\n@[simps!]\ndef pushforward {X Y : TopCat.{w}} (f : X ‚ü∂ Y) : X.Presheaf C ‚•§ Y.Presheaf C :=\n  (whiskeringLeft _ _ _).obj (Opens.map f).op\n\n"}
{"name":"TopCat.Presheaf.pushforward_map_app","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù¬π Y : TopCat\nf : Quiver.Hom X‚úù¬π Y\nX‚úù Y‚úù : CategoryTheory.Functor (Opposite (TopologicalSpace.Opens ‚ÜëX‚úù¬π)) C\nŒ± : Quiver.Hom X‚úù Y‚úù\nX : Opposite (TopologicalSpace.Opens ‚ÜëY)\n‚ä¢ Eq (((TopCat.Presheaf.pushforward C f).map Œ±).app X) (Œ±.app { unop := (TopologicalSpace.Opens.map f).obj (Opposite.unop X) })","decl":"/-- The pushforward functor. -/\n@[simps!]\ndef pushforward {X Y : TopCat.{w}} (f : X ‚ü∂ Y) : X.Presheaf C ‚•§ Y.Presheaf C :=\n  (whiskeringLeft _ _ _).obj (Opens.map f).op\n\n"}
{"name":"TopCat.Presheaf.pushforward_obj_obj","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y : TopCat\nf : Quiver.Hom X‚úù Y\nG : CategoryTheory.Functor (Opposite (TopologicalSpace.Opens ‚ÜëX‚úù)) C\nX : Opposite (TopologicalSpace.Opens ‚ÜëY)\n‚ä¢ Eq (((TopCat.Presheaf.pushforward C f).obj G).obj X) (G.obj { unop := (TopologicalSpace.Opens.map f).obj (Opposite.unop X) })","decl":"/-- The pushforward functor. -/\n@[simps!]\ndef pushforward {X Y : TopCat.{w}} (f : X ‚ü∂ Y) : X.Presheaf C ‚•§ Y.Presheaf C :=\n  (whiskeringLeft _ _ _).obj (Opens.map f).op\n\n"}
{"name":"TopCat.Presheaf.pushforward_map_app'","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : TopCat\nf : Quiver.Hom X Y\n‚Ñ± ùí¢ : TopCat.Presheaf C X\nŒ± : Quiver.Hom ‚Ñ± ùí¢\nU : Opposite (TopologicalSpace.Opens ‚ÜëY)\n‚ä¢ Eq (((TopCat.Presheaf.pushforward C f).map Œ±).app U) (Œ±.app { unop := (TopologicalSpace.Opens.map f).obj (Opposite.unop U) })","decl":"@[simp]\ntheorem pushforward_map_app' {X Y : TopCat.{w}} (f : X ‚ü∂ Y) {‚Ñ± ùí¢ : X.Presheaf C} (Œ± : ‚Ñ± ‚ü∂ ùí¢)\n    {U : (Opens Y)·µí·µñ} : ((pushforward C f).map Œ±).app U = Œ±.app (op <| (Opens.map f).obj U.unop) :=\n  rfl\n\n"}
{"name":"TopCat.Presheaf.id_pushforward","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : TopCat\n‚ä¢ Eq (TopCat.Presheaf.pushforward C (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.Functor.id (TopCat.Presheaf C X))","decl":"lemma id_pushforward (X : TopCat.{w}) : pushforward C (ùüô X) = ùü≠ (X.Presheaf C) := rfl\n\n"}
{"name":"TopCat.Presheaf.Pushforward.id_hom_app","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : TopCat\n‚Ñ± : TopCat.Presheaf C X\nU : Opposite (TopologicalSpace.Opens ‚ÜëX)\n‚ä¢ Eq ((TopCat.Presheaf.Pushforward.id ‚Ñ±).hom.app U) (CategoryTheory.CategoryStruct.id (((TopCat.Presheaf.pushforward C (CategoryTheory.CategoryStruct.id X)).obj ‚Ñ±).obj U))","decl":"@[simp]\ntheorem id_hom_app {X : TopCat.{w}} (‚Ñ± : X.Presheaf C) (U) : (id ‚Ñ±).hom.app U = ùüô _ := rfl\n\n"}
{"name":"TopCat.Presheaf.Pushforward.id_inv_app","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : TopCat\n‚Ñ± : TopCat.Presheaf C X\nU : Opposite (TopologicalSpace.Opens ‚ÜëX)\n‚ä¢ Eq ((TopCat.Presheaf.Pushforward.id ‚Ñ±).inv.app U) (CategoryTheory.CategoryStruct.id (‚Ñ±.obj U))","decl":"@[simp]\ntheorem id_inv_app {X : TopCat.{w}} (‚Ñ± : X.Presheaf C) (U) :\n    (id ‚Ñ±).inv.app U = ùüô _ := rfl\n\n"}
{"name":"TopCat.Presheaf.Pushforward.id_eq","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : TopCat\n‚Ñ± : TopCat.Presheaf C X\n‚ä¢ Eq ((TopCat.Presheaf.pushforward C (CategoryTheory.CategoryStruct.id X)).obj ‚Ñ±) ‚Ñ±","decl":"theorem id_eq {X : TopCat.{w}} (‚Ñ± : X.Presheaf C) : ùüô X _* ‚Ñ± = ‚Ñ± := rfl\n\n"}
{"name":"TopCat.Presheaf.Pushforward.comp_eq","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : TopCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚Ñ± : TopCat.Presheaf C X\n‚ä¢ Eq ((TopCat.Presheaf.pushforward C (CategoryTheory.CategoryStruct.comp f g)).obj ‚Ñ±) ((TopCat.Presheaf.pushforward C g).obj ((TopCat.Presheaf.pushforward C f).obj ‚Ñ±))","decl":"theorem comp_eq {X Y Z : TopCat.{w}} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (‚Ñ± : X.Presheaf C) :\n    (f ‚â´ g) _* ‚Ñ± = g _* (f _* ‚Ñ±) :=\n  rfl\n\n"}
{"name":"TopCat.Presheaf.Pushforward.comp_hom_app","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : TopCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚Ñ± : TopCat.Presheaf C X\nU : Opposite (TopologicalSpace.Opens ‚ÜëZ)\n‚ä¢ Eq ((TopCat.Presheaf.Pushforward.comp f g ‚Ñ±).hom.app U) (CategoryTheory.CategoryStruct.id (((TopCat.Presheaf.pushforward C (CategoryTheory.CategoryStruct.comp f g)).obj ‚Ñ±).obj U))","decl":"@[simp]\ntheorem comp_hom_app {X Y Z : TopCat.{w}} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (‚Ñ± : X.Presheaf C) (U) :\n    (comp f g ‚Ñ±).hom.app U = ùüô _ := rfl\n\n"}
{"name":"TopCat.Presheaf.Pushforward.comp_inv_app","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : TopCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚Ñ± : TopCat.Presheaf C X\nU : Opposite (TopologicalSpace.Opens ‚ÜëZ)\n‚ä¢ Eq ((TopCat.Presheaf.Pushforward.comp f g ‚Ñ±).inv.app U) (CategoryTheory.CategoryStruct.id (((TopCat.Presheaf.pushforward C g).obj ((TopCat.Presheaf.pushforward C f).obj ‚Ñ±)).obj U))","decl":"@[simp]\ntheorem comp_inv_app {X Y Z : TopCat.{w}} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (‚Ñ± : X.Presheaf C) (U) :\n    (comp f g ‚Ñ±).inv.app U = ùüô _ := rfl\n\n"}
{"name":"TopCat.Presheaf.pushforward_eq'","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : TopCat\nf g : Quiver.Hom X Y\nh : Eq f g\n‚Ñ± : TopCat.Presheaf C X\n‚ä¢ Eq ((TopCat.Presheaf.pushforward C f).obj ‚Ñ±) ((TopCat.Presheaf.pushforward C g).obj ‚Ñ±)","decl":"theorem pushforward_eq' {X Y : TopCat.{w}} {f g : X ‚ü∂ Y} (h : f = g) (‚Ñ± : X.Presheaf C) :\n    f _* ‚Ñ± = g _* ‚Ñ± := by rw [h]\n\n"}
{"name":"TopCat.Presheaf.pushforwardEq_hom_app","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : TopCat\nf g : Quiver.Hom X Y\nh : Eq f g\n‚Ñ± : TopCat.Presheaf C X\nU : Opposite (TopologicalSpace.Opens ‚ÜëY)\n‚ä¢ Eq ((TopCat.Presheaf.pushforwardEq h ‚Ñ±).hom.app U) (‚Ñ±.map (CategoryTheory.eqToHom ‚ãØ))","decl":"@[simp]\ntheorem pushforwardEq_hom_app {X Y : TopCat.{w}} {f g : X ‚ü∂ Y}\n    (h : f = g) (‚Ñ± : X.Presheaf C) (U) :\n    (pushforwardEq h ‚Ñ±).hom.app U = ‚Ñ±.map (eqToHom (by aesop_cat)) := by\n  simp [pushforwardEq]\n\n"}
{"name":"TopCat.Presheaf.presheafEquivOfIso_inverse_map_app","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù¬π Y : TopCat\nH : CategoryTheory.Iso X‚úù¬π Y\nX‚úù Y‚úù : CategoryTheory.Functor (Opposite (TopologicalSpace.Opens ‚ÜëY)) C\nŒ± : Quiver.Hom X‚úù Y‚úù\nX : Opposite (TopologicalSpace.Opens ‚ÜëX‚úù¬π)\n‚ä¢ Eq (((TopCat.Presheaf.presheafEquivOfIso C H).inverse.map Œ±).app X) (Œ±.app { unop := (TopologicalSpace.Opens.map H.inv).obj (Opposite.unop X) })","decl":"/-- A homeomorphism of spaces gives an equivalence of categories of presheaves. -/\n@[simps!]\ndef presheafEquivOfIso {X Y : TopCat} (H : X ‚âÖ Y) : X.Presheaf C ‚âå Y.Presheaf C :=\n  Equivalence.congrLeft (Opens.mapMapIso H).symm.op\n\n"}
{"name":"TopCat.Presheaf.presheafEquivOfIso_functor_obj_obj","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y : TopCat\nH : CategoryTheory.Iso X‚úù Y\nG : CategoryTheory.Functor (Opposite (TopologicalSpace.Opens ‚ÜëX‚úù)) C\nX : Opposite (TopologicalSpace.Opens ‚ÜëY)\n‚ä¢ Eq (((TopCat.Presheaf.presheafEquivOfIso C H).functor.obj G).obj X) (G.obj { unop := (TopologicalSpace.Opens.map H.hom).obj (Opposite.unop X) })","decl":"/-- A homeomorphism of spaces gives an equivalence of categories of presheaves. -/\n@[simps!]\ndef presheafEquivOfIso {X Y : TopCat} (H : X ‚âÖ Y) : X.Presheaf C ‚âå Y.Presheaf C :=\n  Equivalence.congrLeft (Opens.mapMapIso H).symm.op\n\n"}
{"name":"TopCat.Presheaf.presheafEquivOfIso_functor_obj_map","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : TopCat\nH : CategoryTheory.Iso X Y\nG : CategoryTheory.Functor (Opposite (TopologicalSpace.Opens ‚ÜëX)) C\nX‚úù Y‚úù : Opposite (TopologicalSpace.Opens ‚ÜëY)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((TopCat.Presheaf.presheafEquivOfIso C H).functor.obj G).map f) (G.map ((TopologicalSpace.Opens.map H.hom).map f.unop).op)","decl":"/-- A homeomorphism of spaces gives an equivalence of categories of presheaves. -/\n@[simps!]\ndef presheafEquivOfIso {X Y : TopCat} (H : X ‚âÖ Y) : X.Presheaf C ‚âå Y.Presheaf C :=\n  Equivalence.congrLeft (Opens.mapMapIso H).symm.op\n\n"}
{"name":"TopCat.Presheaf.presheafEquivOfIso_unitIso_hom_app_app","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù¬π Y : TopCat\nH : CategoryTheory.Iso X‚úù¬π Y\nX‚úù : CategoryTheory.Functor (Opposite (TopologicalSpace.Opens ‚ÜëX‚úù¬π)) C\nX : Opposite (TopologicalSpace.Opens ‚ÜëX‚úù¬π)\n‚ä¢ Eq (((TopCat.Presheaf.presheafEquivOfIso C H).unitIso.hom.app X‚úù).app X) (X‚úù.map (CategoryTheory.eqToHom ‚ãØ))","decl":"/-- A homeomorphism of spaces gives an equivalence of categories of presheaves. -/\n@[simps!]\ndef presheafEquivOfIso {X Y : TopCat} (H : X ‚âÖ Y) : X.Presheaf C ‚âå Y.Presheaf C :=\n  Equivalence.congrLeft (Opens.mapMapIso H).symm.op\n\n"}
{"name":"TopCat.Presheaf.presheafEquivOfIso_counitIso_inv_app_app","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù¬π Y : TopCat\nH : CategoryTheory.Iso X‚úù¬π Y\nX‚úù : CategoryTheory.Functor (Opposite (TopologicalSpace.Opens ‚ÜëY)) C\nX : Opposite (TopologicalSpace.Opens ‚ÜëY)\n‚ä¢ Eq (((TopCat.Presheaf.presheafEquivOfIso C H).counitIso.inv.app X‚úù).app X) (X‚úù.map (CategoryTheory.eqToHom ‚ãØ))","decl":"/-- A homeomorphism of spaces gives an equivalence of categories of presheaves. -/\n@[simps!]\ndef presheafEquivOfIso {X Y : TopCat} (H : X ‚âÖ Y) : X.Presheaf C ‚âå Y.Presheaf C :=\n  Equivalence.congrLeft (Opens.mapMapIso H).symm.op\n\n"}
{"name":"TopCat.Presheaf.presheafEquivOfIso_inverse_obj_map","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : TopCat\nH : CategoryTheory.Iso X Y\nG : CategoryTheory.Functor (Opposite (TopologicalSpace.Opens ‚ÜëY)) C\nX‚úù Y‚úù : Opposite (TopologicalSpace.Opens ‚ÜëX)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((TopCat.Presheaf.presheafEquivOfIso C H).inverse.obj G).map f) (G.map ((TopologicalSpace.Opens.map H.inv).map f.unop).op)","decl":"/-- A homeomorphism of spaces gives an equivalence of categories of presheaves. -/\n@[simps!]\ndef presheafEquivOfIso {X Y : TopCat} (H : X ‚âÖ Y) : X.Presheaf C ‚âå Y.Presheaf C :=\n  Equivalence.congrLeft (Opens.mapMapIso H).symm.op\n\n"}
{"name":"TopCat.Presheaf.presheafEquivOfIso_unitIso_inv_app_app","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù¬π Y : TopCat\nH : CategoryTheory.Iso X‚úù¬π Y\nX‚úù : CategoryTheory.Functor (Opposite (TopologicalSpace.Opens ‚ÜëX‚úù¬π)) C\nX : Opposite (TopologicalSpace.Opens ‚ÜëX‚úù¬π)\n‚ä¢ Eq (((TopCat.Presheaf.presheafEquivOfIso C H).unitIso.inv.app X‚úù).app X) (X‚úù.map (CategoryTheory.eqToHom ‚ãØ))","decl":"/-- A homeomorphism of spaces gives an equivalence of categories of presheaves. -/\n@[simps!]\ndef presheafEquivOfIso {X Y : TopCat} (H : X ‚âÖ Y) : X.Presheaf C ‚âå Y.Presheaf C :=\n  Equivalence.congrLeft (Opens.mapMapIso H).symm.op\n\n"}
{"name":"TopCat.Presheaf.presheafEquivOfIso_inverse_obj_obj","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y : TopCat\nH : CategoryTheory.Iso X‚úù Y\nG : CategoryTheory.Functor (Opposite (TopologicalSpace.Opens ‚ÜëY)) C\nX : Opposite (TopologicalSpace.Opens ‚ÜëX‚úù)\n‚ä¢ Eq (((TopCat.Presheaf.presheafEquivOfIso C H).inverse.obj G).obj X) (G.obj { unop := (TopologicalSpace.Opens.map H.inv).obj (Opposite.unop X) })","decl":"/-- A homeomorphism of spaces gives an equivalence of categories of presheaves. -/\n@[simps!]\ndef presheafEquivOfIso {X Y : TopCat} (H : X ‚âÖ Y) : X.Presheaf C ‚âå Y.Presheaf C :=\n  Equivalence.congrLeft (Opens.mapMapIso H).symm.op\n\n"}
{"name":"TopCat.Presheaf.presheafEquivOfIso_counitIso_hom_app_app","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù¬π Y : TopCat\nH : CategoryTheory.Iso X‚úù¬π Y\nX‚úù : CategoryTheory.Functor (Opposite (TopologicalSpace.Opens ‚ÜëY)) C\nX : Opposite (TopologicalSpace.Opens ‚ÜëY)\n‚ä¢ Eq (((TopCat.Presheaf.presheafEquivOfIso C H).counitIso.hom.app X‚úù).app X) (X‚úù.map (CategoryTheory.eqToHom ‚ãØ))","decl":"/-- A homeomorphism of spaces gives an equivalence of categories of presheaves. -/\n@[simps!]\ndef presheafEquivOfIso {X Y : TopCat} (H : X ‚âÖ Y) : X.Presheaf C ‚âå Y.Presheaf C :=\n  Equivalence.congrLeft (Opens.mapMapIso H).symm.op\n\n"}
{"name":"TopCat.Presheaf.presheafEquivOfIso_functor_map_app","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù¬π Y : TopCat\nH : CategoryTheory.Iso X‚úù¬π Y\nX‚úù Y‚úù : CategoryTheory.Functor (Opposite (TopologicalSpace.Opens ‚ÜëX‚úù¬π)) C\nŒ± : Quiver.Hom X‚úù Y‚úù\nX : Opposite (TopologicalSpace.Opens ‚ÜëY)\n‚ä¢ Eq (((TopCat.Presheaf.presheafEquivOfIso C H).functor.map Œ±).app X) (Œ±.app { unop := (TopologicalSpace.Opens.map H.hom).obj (Opposite.unop X) })","decl":"/-- A homeomorphism of spaces gives an equivalence of categories of presheaves. -/\n@[simps!]\ndef presheafEquivOfIso {X Y : TopCat} (H : X ‚âÖ Y) : X.Presheaf C ‚âå Y.Presheaf C :=\n  Equivalence.congrLeft (Opens.mapMapIso H).symm.op\n\n"}
{"name":"TopCat.Presheaf.toPushforwardOfIso_app","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : TopCat\nH‚ÇÅ : CategoryTheory.Iso X Y\n‚Ñ± : TopCat.Presheaf C X\nùí¢ : TopCat.Presheaf C Y\nH‚ÇÇ : Quiver.Hom ((TopCat.Presheaf.pushforward C H‚ÇÅ.hom).obj ‚Ñ±) ùí¢\nU : Opposite (TopologicalSpace.Opens ‚ÜëX)\n‚ä¢ Eq ((TopCat.Presheaf.toPushforwardOfIso H‚ÇÅ H‚ÇÇ).app U) (CategoryTheory.CategoryStruct.comp (‚Ñ±.map (CategoryTheory.eqToHom ‚ãØ)) (H‚ÇÇ.app { unop := (TopologicalSpace.Opens.map H‚ÇÅ.inv).obj (Opposite.unop U) }))","decl":"@[simp]\ntheorem toPushforwardOfIso_app {X Y : TopCat} (H‚ÇÅ : X ‚âÖ Y) {‚Ñ± : X.Presheaf C} {ùí¢ : Y.Presheaf C}\n    (H‚ÇÇ : H‚ÇÅ.hom _* ‚Ñ± ‚ü∂ ùí¢) (U : (Opens X)·µí·µñ) :\n    (toPushforwardOfIso H‚ÇÅ H‚ÇÇ).app U =\n      ‚Ñ±.map (eqToHom (by simp [Opens.map, Set.preimage_preimage])) ‚â´\n        H‚ÇÇ.app (op ((Opens.map H‚ÇÅ.inv).obj (unop U))) := by\n  simp [toPushforwardOfIso, Adjunction.homEquiv_unit]\n\n"}
{"name":"TopCat.Presheaf.pushforwardToOfIso_app","module":"Mathlib.Topology.Sheaves.Presheaf","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : TopCat\nH‚ÇÅ : CategoryTheory.Iso X Y\n‚Ñ± : TopCat.Presheaf C Y\nùí¢ : TopCat.Presheaf C X\nH‚ÇÇ : Quiver.Hom ‚Ñ± ((TopCat.Presheaf.pushforward C H‚ÇÅ.hom).obj ùí¢)\nU : Opposite (TopologicalSpace.Opens ‚ÜëX)\n‚ä¢ Eq ((TopCat.Presheaf.pushforwardToOfIso H‚ÇÅ H‚ÇÇ).app U) (CategoryTheory.CategoryStruct.comp (H‚ÇÇ.app { unop := (TopologicalSpace.Opens.map H‚ÇÅ.inv).obj (Opposite.unop U) }) (ùí¢.map (CategoryTheory.eqToHom ‚ãØ)))","decl":"@[simp]\ntheorem pushforwardToOfIso_app {X Y : TopCat} (H‚ÇÅ : X ‚âÖ Y) {‚Ñ± : Y.Presheaf C} {ùí¢ : X.Presheaf C}\n    (H‚ÇÇ : ‚Ñ± ‚ü∂ H‚ÇÅ.hom _* ùí¢) (U : (Opens X)·µí·µñ) :\n    (pushforwardToOfIso H‚ÇÅ H‚ÇÇ).app U =\n      H‚ÇÇ.app (op ((Opens.map H‚ÇÅ.inv).obj (unop U))) ‚â´\n        ùí¢.map (eqToHom (by simp [Opens.map, Set.preimage_preimage])) := by\n  simp [pushforwardToOfIso, Equivalence.toAdjunction, Adjunction.homEquiv_counit]\n\n"}
