{"name":"CategoryTheory.Retract.retract","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nself : CategoryTheory.Retract X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.i self.r) (CategoryTheory.CategoryStruct.id X)","decl":"/-- An object `X` is a retract of `Y` if there are morphisms `i : X ‚ü∂ Y` and `r : Y ‚ü∂ X` such\nthat `i ‚â´ r = ùüô X`. -/\nstructure Retract (X Y : C) where\n  /-- the split monomorphism -/\n  i : X ‚ü∂ Y\n  /-- the split epimorphism -/\n  r : Y ‚ü∂ X\n  retract : i ‚â´ r = ùüô X := by aesop_cat\n\n"}
{"name":"CategoryTheory.Retract.mk.inj","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\ni‚úù : Quiver.Hom X Y\nr‚úù : Quiver.Hom Y X\nretract‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp i‚úù r‚úù) (CategoryTheory.CategoryStruct.id X)) _auto‚úù\ni : Quiver.Hom X Y\nr : Quiver.Hom Y X\nretract : autoParam (Eq (CategoryTheory.CategoryStruct.comp i r) (CategoryTheory.CategoryStruct.id X)) _auto‚úù\nx‚úù : Eq { i := i‚úù, r := r‚úù, retract := retract‚úù } { i := i, r := r, retract := retract }\n‚ä¢ And (Eq i‚úù i) (Eq r‚úù r)","decl":"/-- An object `X` is a retract of `Y` if there are morphisms `i : X ‚ü∂ Y` and `r : Y ‚ü∂ X` such\nthat `i ‚â´ r = ùüô X`. -/\nstructure Retract (X Y : C) where\n  /-- the split monomorphism -/\n  i : X ‚ü∂ Y\n  /-- the split epimorphism -/\n  r : Y ‚ü∂ X\n  retract : i ‚â´ r = ùüô X := by aesop_cat\n\n"}
{"name":"CategoryTheory.Retract.mk.injEq","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\ni‚úù : Quiver.Hom X Y\nr‚úù : Quiver.Hom Y X\nretract‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp i‚úù r‚úù) (CategoryTheory.CategoryStruct.id X)) _auto‚úù\ni : Quiver.Hom X Y\nr : Quiver.Hom Y X\nretract : autoParam (Eq (CategoryTheory.CategoryStruct.comp i r) (CategoryTheory.CategoryStruct.id X)) _auto‚úù\n‚ä¢ Eq (Eq { i := i‚úù, r := r‚úù, retract := retract‚úù } { i := i, r := r, retract := retract }) (And (Eq i‚úù i) (Eq r‚úù r))","decl":"/-- An object `X` is a retract of `Y` if there are morphisms `i : X ‚ü∂ Y` and `r : Y ‚ü∂ X` such\nthat `i ‚â´ r = ùüô X`. -/\nstructure Retract (X Y : C) where\n  /-- the split monomorphism -/\n  i : X ‚ü∂ Y\n  /-- the split epimorphism -/\n  r : Y ‚ü∂ X\n  retract : i ‚â´ r = ùüô X := by aesop_cat\n\n"}
{"name":"CategoryTheory.Retract.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù : SizeOf C\ni : Quiver.Hom X Y\nr : Quiver.Hom Y X\nretract : autoParam (Eq (CategoryTheory.CategoryStruct.comp i r) (CategoryTheory.CategoryStruct.id X)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { i := i, r := r, retract := retract }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf i)) (SizeOf.sizeOf r)) (SizeOf.sizeOf retract))","decl":"/-- An object `X` is a retract of `Y` if there are morphisms `i : X ‚ü∂ Y` and `r : Y ‚ü∂ X` such\nthat `i ‚â´ r = ùüô X`. -/\nstructure Retract (X Y : C) where\n  /-- the split monomorphism -/\n  i : X ‚ü∂ Y\n  /-- the split epimorphism -/\n  r : Y ‚ü∂ X\n  retract : i ‚â´ r = ùüô X := by aesop_cat\n\n"}
{"name":"CategoryTheory.Retract.retract_assoc","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nself : CategoryTheory.Retract X Y\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.i (CategoryTheory.CategoryStruct.comp self.r h)) h","decl":"attribute [reassoc (attr := simp)] retract\n\n"}
{"name":"CategoryTheory.Retract.map_r","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nX Y : C\nh : CategoryTheory.Retract X Y\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (h.map F).r (F.map h.r)","decl":"/-- If `X` is a retract of `Y`, then `F.obj X` is a retract of `F.obj Y`. -/\n@[simps]\ndef map (F : C ‚•§ D) : Retract (F.obj X) (F.obj Y) where\n  i := F.map h.i\n  r := F.map h.r\n  retract := by rw [‚Üê F.map_comp h.i h.r, h.retract, F.map_id]\n\n"}
{"name":"CategoryTheory.Retract.map_i","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nX Y : C\nh : CategoryTheory.Retract X Y\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (h.map F).i (F.map h.i)","decl":"/-- If `X` is a retract of `Y`, then `F.obj X` is a retract of `F.obj Y`. -/\n@[simps]\ndef map (F : C ‚•§ D) : Retract (F.obj X) (F.obj Y) where\n  i := F.map h.i\n  r := F.map h.r\n  retract := by rw [‚Üê F.map_comp h.i h.r, h.retract, F.map_id]\n\n"}
{"name":"CategoryTheory.Retract.splitEpi_section_","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Retract X Y\n‚ä¢ Eq h.splitEpi.section_ h.i","decl":"/-- a retract determines a split epimorphism. -/\n@[simps] def splitEpi : SplitEpi h.r where\n  section_ := h.i\n\n"}
{"name":"CategoryTheory.Retract.splitMono_retraction","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Retract X Y\n‚ä¢ Eq h.splitMono.retraction h.r","decl":"/-- a retract determines a split monomorphism. -/\n@[simps] def splitMono : SplitMono h.i where\n  retraction := h.r\n\n"}
{"name":"CategoryTheory.Retract.instIsSplitEpiR","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Retract X Y\n‚ä¢ CategoryTheory.IsSplitEpi h.r","decl":"instance : IsSplitEpi h.r := ‚ü®‚ü®h.splitEpi‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Retract.instIsSplitMonoI","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Retract X Y\n‚ä¢ CategoryTheory.IsSplitMono h.i","decl":"instance : IsSplitMono h.i := ‚ü®‚ü®h.splitMono‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Retract.refl_i","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\n‚ä¢ Eq (CategoryTheory.Retract.refl X).i (CategoryTheory.CategoryStruct.id X)","decl":"variable (X) in\n/-- Any object is a retract of itself. -/\n@[simps]\ndef refl : Retract X X where\n  i := ùüô X\n  r := ùüô X\n\n"}
{"name":"CategoryTheory.Retract.refl_r","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\n‚ä¢ Eq (CategoryTheory.Retract.refl X).r (CategoryTheory.CategoryStruct.id X)","decl":"variable (X) in\n/-- Any object is a retract of itself. -/\n@[simps]\ndef refl : Retract X X where\n  i := ùüô X\n  r := ùüô X\n\n"}
{"name":"CategoryTheory.Retract.trans_r","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Retract X Y\nZ : C\nh' : CategoryTheory.Retract Y Z\n‚ä¢ Eq (h.trans h').r (CategoryTheory.CategoryStruct.comp h'.r h.r)","decl":"/-- A retract of a retract is a retract. -/\n@[simps]\ndef trans {Z : C} (h' : Retract Y Z) : Retract X Z where\n  i := h.i ‚â´ h'.i\n  r := h'.r ‚â´ h.r\n\n"}
{"name":"CategoryTheory.Retract.trans_i","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Retract X Y\nZ : C\nh' : CategoryTheory.Retract Y Z\n‚ä¢ Eq (h.trans h').i (CategoryTheory.CategoryStruct.comp h.i h'.i)","decl":"/-- A retract of a retract is a retract. -/\n@[simps]\ndef trans {Z : C} (h' : Retract Y Z) : Retract X Z where\n  i := h.i ‚â´ h'.i\n  r := h'.r ‚â´ h.r\n\n"}
{"name":"CategoryTheory.RetractArrow.i_w","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h.i.left g) (CategoryTheory.CategoryStruct.comp f h.i.right)","decl":"@[reassoc]\nlemma i_w : h.i.left ‚â´ g = f ‚â´ h.i.right := h.i.w\n\n"}
{"name":"CategoryTheory.RetractArrow.i_w_assoc","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z‚úù W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z‚úù W\nh‚úù : CategoryTheory.RetractArrow f g\nZ : C\nh : Quiver.Hom W Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h‚úù.i.left (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp h‚úù.i.right h))","decl":"@[reassoc]\nlemma i_w : h.i.left ‚â´ g = f ‚â´ h.i.right := h.i.w\n\n"}
{"name":"CategoryTheory.RetractArrow.r_w","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h.r.left f) (CategoryTheory.CategoryStruct.comp g h.r.right)","decl":"@[reassoc]\nlemma r_w : h.r.left ‚â´ f = g ‚â´ h.r.right := h.r.w\n\n"}
{"name":"CategoryTheory.RetractArrow.r_w_assoc","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z‚úù W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z‚úù W\nh‚úù : CategoryTheory.RetractArrow f g\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h‚úù.r.left (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp h‚úù.r.right h))","decl":"@[reassoc]\nlemma r_w : h.r.left ‚â´ f = g ‚â´ h.r.right := h.r.w\n\n"}
{"name":"CategoryTheory.RetractArrow.left_i","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n‚ä¢ Eq h.left.i h.i.left","decl":"/-- The top of a retract diagram of morphisms determines a retract of objects. -/\n@[simps!]\ndef left : Retract X Z := h.map Arrow.leftFunc\n\n"}
{"name":"CategoryTheory.RetractArrow.left_r","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n‚ä¢ Eq h.left.r h.r.left","decl":"/-- The top of a retract diagram of morphisms determines a retract of objects. -/\n@[simps!]\ndef left : Retract X Z := h.map Arrow.leftFunc\n\n"}
{"name":"CategoryTheory.RetractArrow.right_i","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n‚ä¢ Eq h.right.i h.i.right","decl":"/-- The bottom of a retract diagram of morphisms determines a retract of objects. -/\n@[simps!]\ndef right : Retract Y W := h.map Arrow.rightFunc\n\n"}
{"name":"CategoryTheory.RetractArrow.right_r","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n‚ä¢ Eq h.right.r h.r.right","decl":"/-- The bottom of a retract diagram of morphisms determines a retract of objects. -/\n@[simps!]\ndef right : Retract Y W := h.map Arrow.rightFunc\n\n"}
{"name":"CategoryTheory.RetractArrow.retract_left","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h.i.left h.r.left) (CategoryTheory.CategoryStruct.id X)","decl":"@[reassoc (attr := simp)]\nlemma retract_left : h.i.left ‚â´ h.r.left = ùüô X := h.left.retract\n\n"}
{"name":"CategoryTheory.RetractArrow.retract_left_assoc","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z‚úù W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z‚úù W\nh‚úù : CategoryTheory.RetractArrow f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Arrow.mk f).left Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h‚úù.i.left (CategoryTheory.CategoryStruct.comp h‚úù.r.left h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id X) h)","decl":"@[reassoc (attr := simp)]\nlemma retract_left : h.i.left ‚â´ h.r.left = ùüô X := h.left.retract\n\n"}
{"name":"CategoryTheory.RetractArrow.retract_right","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h.i.right h.r.right) (CategoryTheory.CategoryStruct.id Y)","decl":"@[reassoc (attr := simp)]\nlemma retract_right : h.i.right ‚â´ h.r.right = ùüô Y := h.right.retract\n\n"}
{"name":"CategoryTheory.RetractArrow.retract_right_assoc","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z‚úù W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z‚úù W\nh‚úù : CategoryTheory.RetractArrow f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Arrow.mk f).right Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h‚úù.i.right (CategoryTheory.CategoryStruct.comp h‚úù.r.right h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id Y) h)","decl":"@[reassoc (attr := simp)]\nlemma retract_right : h.i.right ‚â´ h.r.right = ùüô Y := h.right.retract\n\n"}
{"name":"CategoryTheory.RetractArrow.instIsSplitEpiLeftRArrow","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n‚ä¢ CategoryTheory.IsSplitEpi h.r.left","decl":"instance : IsSplitEpi h.r.left := ‚ü®‚ü®h.left.splitEpi‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.RetractArrow.instIsSplitEpiRightRArrow","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n‚ä¢ CategoryTheory.IsSplitEpi h.r.right","decl":"instance : IsSplitEpi h.r.right := ‚ü®‚ü®h.right.splitEpi‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.RetractArrow.instIsSplitMonoLeftIArrow","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n‚ä¢ CategoryTheory.IsSplitMono h.i.left","decl":"instance : IsSplitMono h.i.left := ‚ü®‚ü®h.left.splitMono‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.RetractArrow.instIsSplitMonoRightIArrow","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n‚ä¢ CategoryTheory.IsSplitMono h.i.right","decl":"instance : IsSplitMono h.i.right := ‚ü®‚ü®h.right.splitMono‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Iso.retract_r","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\ne : CategoryTheory.Iso X Y\n‚ä¢ Eq e.retract.r e.inv","decl":"/-- If `X` is isomorphic to `Y`, then `X` is a retract of `Y`. -/\n@[simps]\ndef retract {X Y : C} (e : X ‚âÖ Y) : Retract X Y where\n  i := e.hom\n  r := e.inv\n\n"}
{"name":"CategoryTheory.Iso.retract_i","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\ne : CategoryTheory.Iso X Y\n‚ä¢ Eq e.retract.i e.hom","decl":"/-- If `X` is isomorphic to `Y`, then `X` is a retract of `Y`. -/\n@[simps]\ndef retract {X Y : C} (e : X ‚âÖ Y) : Retract X Y where\n  i := e.hom\n  r := e.inv\n\n"}
