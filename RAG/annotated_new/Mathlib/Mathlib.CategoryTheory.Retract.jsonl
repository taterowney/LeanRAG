{"name":"CategoryTheory.Retract.retract","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nself : CategoryTheory.Retract X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.i self.r) (CategoryTheory.CategoryStruct.id X)","decl":"/-- An object `X` is a retract of `Y` if there are morphisms `i : X ⟶ Y` and `r : Y ⟶ X` such\nthat `i ≫ r = 𝟙 X`. -/\nstructure Retract (X Y : C) where\n  /-- the split monomorphism -/\n  i : X ⟶ Y\n  /-- the split epimorphism -/\n  r : Y ⟶ X\n  retract : i ≫ r = 𝟙 X := by aesop_cat\n\n"}
{"name":"CategoryTheory.Retract.mk.inj","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\ni✝ : Quiver.Hom X Y\nr✝ : Quiver.Hom Y X\nretract✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp i✝ r✝) (CategoryTheory.CategoryStruct.id X)) _auto✝\ni : Quiver.Hom X Y\nr : Quiver.Hom Y X\nretract : autoParam (Eq (CategoryTheory.CategoryStruct.comp i r) (CategoryTheory.CategoryStruct.id X)) _auto✝\nx✝ : Eq { i := i✝, r := r✝, retract := retract✝ } { i := i, r := r, retract := retract }\n⊢ And (Eq i✝ i) (Eq r✝ r)","decl":"/-- An object `X` is a retract of `Y` if there are morphisms `i : X ⟶ Y` and `r : Y ⟶ X` such\nthat `i ≫ r = 𝟙 X`. -/\nstructure Retract (X Y : C) where\n  /-- the split monomorphism -/\n  i : X ⟶ Y\n  /-- the split epimorphism -/\n  r : Y ⟶ X\n  retract : i ≫ r = 𝟙 X := by aesop_cat\n\n"}
{"name":"CategoryTheory.Retract.mk.injEq","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\ni✝ : Quiver.Hom X Y\nr✝ : Quiver.Hom Y X\nretract✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp i✝ r✝) (CategoryTheory.CategoryStruct.id X)) _auto✝\ni : Quiver.Hom X Y\nr : Quiver.Hom Y X\nretract : autoParam (Eq (CategoryTheory.CategoryStruct.comp i r) (CategoryTheory.CategoryStruct.id X)) _auto✝\n⊢ Eq (Eq { i := i✝, r := r✝, retract := retract✝ } { i := i, r := r, retract := retract }) (And (Eq i✝ i) (Eq r✝ r))","decl":"/-- An object `X` is a retract of `Y` if there are morphisms `i : X ⟶ Y` and `r : Y ⟶ X` such\nthat `i ≫ r = 𝟙 X`. -/\nstructure Retract (X Y : C) where\n  /-- the split monomorphism -/\n  i : X ⟶ Y\n  /-- the split epimorphism -/\n  r : Y ⟶ X\n  retract : i ≫ r = 𝟙 X := by aesop_cat\n\n"}
{"name":"CategoryTheory.Retract.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝ : SizeOf C\ni : Quiver.Hom X Y\nr : Quiver.Hom Y X\nretract : autoParam (Eq (CategoryTheory.CategoryStruct.comp i r) (CategoryTheory.CategoryStruct.id X)) _auto✝\n⊢ Eq (SizeOf.sizeOf { i := i, r := r, retract := retract }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf i)) (SizeOf.sizeOf r)) (SizeOf.sizeOf retract))","decl":"/-- An object `X` is a retract of `Y` if there are morphisms `i : X ⟶ Y` and `r : Y ⟶ X` such\nthat `i ≫ r = 𝟙 X`. -/\nstructure Retract (X Y : C) where\n  /-- the split monomorphism -/\n  i : X ⟶ Y\n  /-- the split epimorphism -/\n  r : Y ⟶ X\n  retract : i ≫ r = 𝟙 X := by aesop_cat\n\n"}
{"name":"CategoryTheory.Retract.retract_assoc","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nself : CategoryTheory.Retract X Y\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.i (CategoryTheory.CategoryStruct.comp self.r h)) h","decl":"attribute [reassoc (attr := simp)] retract\n\n"}
{"name":"CategoryTheory.Retract.map_r","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nX Y : C\nh : CategoryTheory.Retract X Y\nF : CategoryTheory.Functor C D\n⊢ Eq (h.map F).r (F.map h.r)","decl":"/-- If `X` is a retract of `Y`, then `F.obj X` is a retract of `F.obj Y`. -/\n@[simps]\ndef map (F : C ⥤ D) : Retract (F.obj X) (F.obj Y) where\n  i := F.map h.i\n  r := F.map h.r\n  retract := by rw [← F.map_comp h.i h.r, h.retract, F.map_id]\n\n"}
{"name":"CategoryTheory.Retract.map_i","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nX Y : C\nh : CategoryTheory.Retract X Y\nF : CategoryTheory.Functor C D\n⊢ Eq (h.map F).i (F.map h.i)","decl":"/-- If `X` is a retract of `Y`, then `F.obj X` is a retract of `F.obj Y`. -/\n@[simps]\ndef map (F : C ⥤ D) : Retract (F.obj X) (F.obj Y) where\n  i := F.map h.i\n  r := F.map h.r\n  retract := by rw [← F.map_comp h.i h.r, h.retract, F.map_id]\n\n"}
{"name":"CategoryTheory.Retract.splitEpi_section_","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Retract X Y\n⊢ Eq h.splitEpi.section_ h.i","decl":"/-- a retract determines a split epimorphism. -/\n@[simps] def splitEpi : SplitEpi h.r where\n  section_ := h.i\n\n"}
{"name":"CategoryTheory.Retract.splitMono_retraction","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Retract X Y\n⊢ Eq h.splitMono.retraction h.r","decl":"/-- a retract determines a split monomorphism. -/\n@[simps] def splitMono : SplitMono h.i where\n  retraction := h.r\n\n"}
{"name":"CategoryTheory.Retract.instIsSplitEpiR","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Retract X Y\n⊢ CategoryTheory.IsSplitEpi h.r","decl":"instance : IsSplitEpi h.r := ⟨⟨h.splitEpi⟩⟩\n\n"}
{"name":"CategoryTheory.Retract.instIsSplitMonoI","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Retract X Y\n⊢ CategoryTheory.IsSplitMono h.i","decl":"instance : IsSplitMono h.i := ⟨⟨h.splitMono⟩⟩\n\n"}
{"name":"CategoryTheory.Retract.refl_i","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\n⊢ Eq (CategoryTheory.Retract.refl X).i (CategoryTheory.CategoryStruct.id X)","decl":"variable (X) in\n/-- Any object is a retract of itself. -/\n@[simps]\ndef refl : Retract X X where\n  i := 𝟙 X\n  r := 𝟙 X\n\n"}
{"name":"CategoryTheory.Retract.refl_r","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\n⊢ Eq (CategoryTheory.Retract.refl X).r (CategoryTheory.CategoryStruct.id X)","decl":"variable (X) in\n/-- Any object is a retract of itself. -/\n@[simps]\ndef refl : Retract X X where\n  i := 𝟙 X\n  r := 𝟙 X\n\n"}
{"name":"CategoryTheory.Retract.trans_r","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Retract X Y\nZ : C\nh' : CategoryTheory.Retract Y Z\n⊢ Eq (h.trans h').r (CategoryTheory.CategoryStruct.comp h'.r h.r)","decl":"/-- A retract of a retract is a retract. -/\n@[simps]\ndef trans {Z : C} (h' : Retract Y Z) : Retract X Z where\n  i := h.i ≫ h'.i\n  r := h'.r ≫ h.r\n\n"}
{"name":"CategoryTheory.Retract.trans_i","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Retract X Y\nZ : C\nh' : CategoryTheory.Retract Y Z\n⊢ Eq (h.trans h').i (CategoryTheory.CategoryStruct.comp h.i h'.i)","decl":"/-- A retract of a retract is a retract. -/\n@[simps]\ndef trans {Z : C} (h' : Retract Y Z) : Retract X Z where\n  i := h.i ≫ h'.i\n  r := h'.r ≫ h.r\n\n"}
{"name":"CategoryTheory.RetractArrow.i_w","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.i.left g) (CategoryTheory.CategoryStruct.comp f h.i.right)","decl":"@[reassoc]\nlemma i_w : h.i.left ≫ g = f ≫ h.i.right := h.i.w\n\n"}
{"name":"CategoryTheory.RetractArrow.i_w_assoc","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z✝ W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z✝ W\nh✝ : CategoryTheory.RetractArrow f g\nZ : C\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.i.left (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp h✝.i.right h))","decl":"@[reassoc]\nlemma i_w : h.i.left ≫ g = f ≫ h.i.right := h.i.w\n\n"}
{"name":"CategoryTheory.RetractArrow.r_w","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.r.left f) (CategoryTheory.CategoryStruct.comp g h.r.right)","decl":"@[reassoc]\nlemma r_w : h.r.left ≫ f = g ≫ h.r.right := h.r.w\n\n"}
{"name":"CategoryTheory.RetractArrow.r_w_assoc","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z✝ W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z✝ W\nh✝ : CategoryTheory.RetractArrow f g\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.r.left (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp h✝.r.right h))","decl":"@[reassoc]\nlemma r_w : h.r.left ≫ f = g ≫ h.r.right := h.r.w\n\n"}
{"name":"CategoryTheory.RetractArrow.left_i","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n⊢ Eq h.left.i h.i.left","decl":"/-- The top of a retract diagram of morphisms determines a retract of objects. -/\n@[simps!]\ndef left : Retract X Z := h.map Arrow.leftFunc\n\n"}
{"name":"CategoryTheory.RetractArrow.left_r","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n⊢ Eq h.left.r h.r.left","decl":"/-- The top of a retract diagram of morphisms determines a retract of objects. -/\n@[simps!]\ndef left : Retract X Z := h.map Arrow.leftFunc\n\n"}
{"name":"CategoryTheory.RetractArrow.right_i","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n⊢ Eq h.right.i h.i.right","decl":"/-- The bottom of a retract diagram of morphisms determines a retract of objects. -/\n@[simps!]\ndef right : Retract Y W := h.map Arrow.rightFunc\n\n"}
{"name":"CategoryTheory.RetractArrow.right_r","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n⊢ Eq h.right.r h.r.right","decl":"/-- The bottom of a retract diagram of morphisms determines a retract of objects. -/\n@[simps!]\ndef right : Retract Y W := h.map Arrow.rightFunc\n\n"}
{"name":"CategoryTheory.RetractArrow.retract_left","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.i.left h.r.left) (CategoryTheory.CategoryStruct.id X)","decl":"@[reassoc (attr := simp)]\nlemma retract_left : h.i.left ≫ h.r.left = 𝟙 X := h.left.retract\n\n"}
{"name":"CategoryTheory.RetractArrow.retract_left_assoc","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z✝ W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z✝ W\nh✝ : CategoryTheory.RetractArrow f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Arrow.mk f).left Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.i.left (CategoryTheory.CategoryStruct.comp h✝.r.left h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id X) h)","decl":"@[reassoc (attr := simp)]\nlemma retract_left : h.i.left ≫ h.r.left = 𝟙 X := h.left.retract\n\n"}
{"name":"CategoryTheory.RetractArrow.retract_right","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.i.right h.r.right) (CategoryTheory.CategoryStruct.id Y)","decl":"@[reassoc (attr := simp)]\nlemma retract_right : h.i.right ≫ h.r.right = 𝟙 Y := h.right.retract\n\n"}
{"name":"CategoryTheory.RetractArrow.retract_right_assoc","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z✝ W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z✝ W\nh✝ : CategoryTheory.RetractArrow f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Arrow.mk f).right Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.i.right (CategoryTheory.CategoryStruct.comp h✝.r.right h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id Y) h)","decl":"@[reassoc (attr := simp)]\nlemma retract_right : h.i.right ≫ h.r.right = 𝟙 Y := h.right.retract\n\n"}
{"name":"CategoryTheory.RetractArrow.instIsSplitEpiLeftRArrow","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n⊢ CategoryTheory.IsSplitEpi h.r.left","decl":"instance : IsSplitEpi h.r.left := ⟨⟨h.left.splitEpi⟩⟩\n\n"}
{"name":"CategoryTheory.RetractArrow.instIsSplitEpiRightRArrow","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n⊢ CategoryTheory.IsSplitEpi h.r.right","decl":"instance : IsSplitEpi h.r.right := ⟨⟨h.right.splitEpi⟩⟩\n\n"}
{"name":"CategoryTheory.RetractArrow.instIsSplitMonoLeftIArrow","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n⊢ CategoryTheory.IsSplitMono h.i.left","decl":"instance : IsSplitMono h.i.left := ⟨⟨h.left.splitMono⟩⟩\n\n"}
{"name":"CategoryTheory.RetractArrow.instIsSplitMonoRightIArrow","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nh : CategoryTheory.RetractArrow f g\n⊢ CategoryTheory.IsSplitMono h.i.right","decl":"instance : IsSplitMono h.i.right := ⟨⟨h.right.splitMono⟩⟩\n\n"}
{"name":"CategoryTheory.Iso.retract_r","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\ne : CategoryTheory.Iso X Y\n⊢ Eq e.retract.r e.inv","decl":"/-- If `X` is isomorphic to `Y`, then `X` is a retract of `Y`. -/\n@[simps]\ndef retract {X Y : C} (e : X ≅ Y) : Retract X Y where\n  i := e.hom\n  r := e.inv\n\n"}
{"name":"CategoryTheory.Iso.retract_i","module":"Mathlib.CategoryTheory.Retract","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\ne : CategoryTheory.Iso X Y\n⊢ Eq e.retract.i e.hom","decl":"/-- If `X` is isomorphic to `Y`, then `X` is a retract of `Y`. -/\n@[simps]\ndef retract {X Y : C} (e : X ≅ Y) : Retract X Y where\n  i := e.hom\n  r := e.inv\n\n"}
