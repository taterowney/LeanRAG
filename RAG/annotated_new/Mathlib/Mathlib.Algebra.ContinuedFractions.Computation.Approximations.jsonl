{"name":"GenContFract.IntFractPair.nth_stream_fr_nonneg_lt_one","module":"Mathlib.Algebra.ContinuedFractions.Computation.Approximations","initialProofState":"K : Type u_1\nv : K\nn : Nat\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nifp_n : GenContFract.IntFractPair K\nnth_stream_eq : Eq (GenContFract.IntFractPair.stream v n) (Option.some ifp_n)\n⊢ And (LE.le 0 ifp_n.fr) (LT.lt ifp_n.fr 1)","decl":"/-- Shows that the fractional parts of the stream are in `[0,1)`. -/\ntheorem nth_stream_fr_nonneg_lt_one {ifp_n : IntFractPair K}\n    (nth_stream_eq : IntFractPair.stream v n = some ifp_n) : 0 ≤ ifp_n.fr ∧ ifp_n.fr < 1 := by\n  cases n with\n  | zero =>\n    have : IntFractPair.of v = ifp_n := by injection nth_stream_eq\n    rw [← this, IntFractPair.of]\n    exact ⟨fract_nonneg _, fract_lt_one _⟩\n  | succ =>\n    rcases succ_nth_stream_eq_some_iff.1 nth_stream_eq with ⟨_, _, _, ifp_of_eq_ifp_n⟩\n    rw [← ifp_of_eq_ifp_n, IntFractPair.of]\n    exact ⟨fract_nonneg _, fract_lt_one _⟩\n\n"}
{"name":"GenContFract.IntFractPair.nth_stream_fr_nonneg","module":"Mathlib.Algebra.ContinuedFractions.Computation.Approximations","initialProofState":"K : Type u_1\nv : K\nn : Nat\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nifp_n : GenContFract.IntFractPair K\nnth_stream_eq : Eq (GenContFract.IntFractPair.stream v n) (Option.some ifp_n)\n⊢ LE.le 0 ifp_n.fr","decl":"/-- Shows that the fractional parts of the stream are nonnegative. -/\ntheorem nth_stream_fr_nonneg {ifp_n : IntFractPair K}\n    (nth_stream_eq : IntFractPair.stream v n = some ifp_n) : 0 ≤ ifp_n.fr :=\n  (nth_stream_fr_nonneg_lt_one nth_stream_eq).left\n\n"}
{"name":"GenContFract.IntFractPair.nth_stream_fr_lt_one","module":"Mathlib.Algebra.ContinuedFractions.Computation.Approximations","initialProofState":"K : Type u_1\nv : K\nn : Nat\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nifp_n : GenContFract.IntFractPair K\nnth_stream_eq : Eq (GenContFract.IntFractPair.stream v n) (Option.some ifp_n)\n⊢ LT.lt ifp_n.fr 1","decl":"/-- Shows that the fractional parts of the stream are smaller than one. -/\ntheorem nth_stream_fr_lt_one {ifp_n : IntFractPair K}\n    (nth_stream_eq : IntFractPair.stream v n = some ifp_n) : ifp_n.fr < 1 :=\n  (nth_stream_fr_nonneg_lt_one nth_stream_eq).right\n\n"}
{"name":"GenContFract.IntFractPair.one_le_succ_nth_stream_b","module":"Mathlib.Algebra.ContinuedFractions.Computation.Approximations","initialProofState":"K : Type u_1\nv : K\nn : Nat\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nifp_succ_n : GenContFract.IntFractPair K\nsucc_nth_stream_eq : Eq (GenContFract.IntFractPair.stream v (HAdd.hAdd n 1)) (Option.some ifp_succ_n)\n⊢ LE.le 1 ifp_succ_n.b","decl":"/-- Shows that the integer parts of the stream are at least one. -/\ntheorem one_le_succ_nth_stream_b {ifp_succ_n : IntFractPair K}\n    (succ_nth_stream_eq : IntFractPair.stream v (n + 1) = some ifp_succ_n) : 1 ≤ ifp_succ_n.b := by\n  obtain ⟨ifp_n, nth_stream_eq, stream_nth_fr_ne_zero, ⟨-⟩⟩ :\n      ∃ ifp_n, IntFractPair.stream v n = some ifp_n ∧ ifp_n.fr ≠ 0\n        ∧ IntFractPair.of ifp_n.fr⁻¹ = ifp_succ_n :=\n    succ_nth_stream_eq_some_iff.1 succ_nth_stream_eq\n  rw [IntFractPair.of, le_floor, cast_one, one_le_inv₀\n    ((nth_stream_fr_nonneg nth_stream_eq).lt_of_ne' stream_nth_fr_ne_zero)]\n  exact (nth_stream_fr_lt_one nth_stream_eq).le\n\n"}
{"name":"GenContFract.IntFractPair.succ_nth_stream_b_le_nth_stream_fr_inv","module":"Mathlib.Algebra.ContinuedFractions.Computation.Approximations","initialProofState":"K : Type u_1\nv : K\nn : Nat\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nifp_n ifp_succ_n : GenContFract.IntFractPair K\nnth_stream_eq : Eq (GenContFract.IntFractPair.stream v n) (Option.some ifp_n)\nsucc_nth_stream_eq : Eq (GenContFract.IntFractPair.stream v (HAdd.hAdd n 1)) (Option.some ifp_succ_n)\n⊢ LE.le (↑ifp_succ_n.b) (Inv.inv ifp_n.fr)","decl":"/--\nShows that the `n + 1`th integer part `bₙ₊₁` of the stream is smaller or equal than the inverse of\nthe `n`th fractional part `frₙ` of the stream.\nThis result is straight-forward as `bₙ₊₁` is defined as the floor of `1 / frₙ`.\n-/\ntheorem succ_nth_stream_b_le_nth_stream_fr_inv {ifp_n ifp_succ_n : IntFractPair K}\n    (nth_stream_eq : IntFractPair.stream v n = some ifp_n)\n    (succ_nth_stream_eq : IntFractPair.stream v (n + 1) = some ifp_succ_n) :\n    (ifp_succ_n.b : K) ≤ ifp_n.fr⁻¹ := by\n  suffices (⌊ifp_n.fr⁻¹⌋ : K) ≤ ifp_n.fr⁻¹ by\n    obtain ⟨_, ifp_n_fr⟩ := ifp_n\n    have : ifp_n_fr ≠ 0 := by\n      intro h\n      simp [h, IntFractPair.stream, nth_stream_eq] at succ_nth_stream_eq\n    have : IntFractPair.of ifp_n_fr⁻¹ = ifp_succ_n := by\n      simpa [this, IntFractPair.stream, nth_stream_eq, Option.coe_def] using succ_nth_stream_eq\n    rwa [← this]\n  exact floor_le ifp_n.fr⁻¹\n\n"}
{"name":"GenContFract.of_one_le_get?_partDen","module":"Mathlib.Algebra.ContinuedFractions.Computation.Approximations","initialProofState":"K : Type u_1\nv : K\nn : Nat\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nb : K\nnth_partDen_eq : Eq ((GenContFract.of v).partDens.get? n) (Option.some b)\n⊢ LE.le 1 b","decl":"/-- Shows that the integer parts of the continued fraction are at least one. -/\ntheorem of_one_le_get?_partDen {b : K}\n    (nth_partDen_eq : (of v).partDens.get? n = some b) : 1 ≤ b := by\n  obtain ⟨gp_n, nth_s_eq, ⟨-⟩⟩ : ∃ gp_n, (of v).s.get? n = some gp_n ∧ gp_n.b = b :=\n    exists_s_b_of_partDen nth_partDen_eq\n  obtain ⟨ifp_n, succ_nth_stream_eq, ifp_n_b_eq_gp_n_b⟩ :\n      ∃ ifp, IntFractPair.stream v (n + 1) = some ifp ∧ (ifp.b : K) = gp_n.b :=\n    IntFractPair.exists_succ_get?_stream_of_gcf_of_get?_eq_some nth_s_eq\n  rw [← ifp_n_b_eq_gp_n_b]\n  exact mod_cast IntFractPair.one_le_succ_nth_stream_b succ_nth_stream_eq\n\n"}
{"name":"GenContFract.of_partNum_eq_one_and_exists_int_partDen_eq","module":"Mathlib.Algebra.ContinuedFractions.Computation.Approximations","initialProofState":"K : Type u_1\nv : K\nn : Nat\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\ngp : GenContFract.Pair K\nnth_s_eq : Eq ((GenContFract.of v).s.get? n) (Option.some gp)\n⊢ And (Eq gp.a 1) (Exists fun z => Eq gp.b ↑z)","decl":"/--\nShows that the partial numerators `aᵢ` of the continued fraction are equal to one and the partial\ndenominators `bᵢ` correspond to integers.\n-/\ntheorem of_partNum_eq_one_and_exists_int_partDen_eq {gp : GenContFract.Pair K}\n    (nth_s_eq : (of v).s.get? n = some gp) : gp.a = 1 ∧ ∃ z : ℤ, gp.b = (z : K) := by\n  obtain ⟨ifp, stream_succ_nth_eq, -⟩ : ∃ ifp, IntFractPair.stream v (n + 1) = some ifp ∧ _ :=\n    IntFractPair.exists_succ_get?_stream_of_gcf_of_get?_eq_some nth_s_eq\n  have : gp = ⟨1, ifp.b⟩ := by\n    have : (of v).s.get? n = some ⟨1, ifp.b⟩ :=\n      get?_of_eq_some_of_succ_get?_intFractPair_stream stream_succ_nth_eq\n    have : some gp = some ⟨1, ifp.b⟩ := by rwa [nth_s_eq] at this\n    injection this\n  simp [this]\n\n"}
{"name":"GenContFract.of_partNum_eq_one","module":"Mathlib.Algebra.ContinuedFractions.Computation.Approximations","initialProofState":"K : Type u_1\nv : K\nn : Nat\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\na : K\nnth_partNum_eq : Eq ((GenContFract.of v).partNums.get? n) (Option.some a)\n⊢ Eq a 1","decl":"/-- Shows that the partial numerators `aᵢ` are equal to one. -/\ntheorem of_partNum_eq_one {a : K} (nth_partNum_eq : (of v).partNums.get? n = some a) :\n    a = 1 := by\n  obtain ⟨gp, nth_s_eq, gp_a_eq_a_n⟩ : ∃ gp, (of v).s.get? n = some gp ∧ gp.a = a :=\n    exists_s_a_of_partNum nth_partNum_eq\n  have : gp.a = 1 := (of_partNum_eq_one_and_exists_int_partDen_eq nth_s_eq).left\n  rwa [gp_a_eq_a_n] at this\n\n"}
{"name":"GenContFract.exists_int_eq_of_partDen","module":"Mathlib.Algebra.ContinuedFractions.Computation.Approximations","initialProofState":"K : Type u_1\nv : K\nn : Nat\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nb : K\nnth_partDen_eq : Eq ((GenContFract.of v).partDens.get? n) (Option.some b)\n⊢ Exists fun z => Eq b ↑z","decl":"/-- Shows that the partial denominators `bᵢ` correspond to an integer. -/\ntheorem exists_int_eq_of_partDen {b : K}\n    (nth_partDen_eq : (of v).partDens.get? n = some b) : ∃ z : ℤ, b = (z : K) := by\n  obtain ⟨gp, nth_s_eq, gp_b_eq_b_n⟩ : ∃ gp, (of v).s.get? n = some gp ∧ gp.b = b :=\n    exists_s_b_of_partDen nth_partDen_eq\n  have : ∃ z : ℤ, gp.b = (z : K) := (of_partNum_eq_one_and_exists_int_partDen_eq nth_s_eq).right\n  rwa [gp_b_eq_b_n] at this\n\n"}
{"name":"GenContFract.of_isSimpContFract","module":"Mathlib.Algebra.ContinuedFractions.Computation.Approximations","initialProofState":"K : Type u_1\nv : K\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\n⊢ (GenContFract.of v).IsSimpContFract","decl":"theorem GenContFract.of_isSimpContFract :\n    (of v).IsSimpContFract := fun _ _ nth_partNum_eq =>\n  of_partNum_eq_one nth_partNum_eq\n\n"}
{"name":"SimpContFract.of_isContFract","module":"Mathlib.Algebra.ContinuedFractions.Computation.Approximations","initialProofState":"K : Type u_1\nv : K\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\n⊢ (SimpContFract.of v).IsContFract","decl":"theorem SimpContFract.of_isContFract :\n    (SimpContFract.of v).IsContFract := fun _ _ nth_partDen_eq =>\n  lt_of_lt_of_le zero_lt_one (of_one_le_get?_partDen nth_partDen_eq)\n\n"}
{"name":"GenContFract.fib_le_of_contsAux_b","module":"Mathlib.Algebra.ContinuedFractions.Computation.Approximations","initialProofState":"K : Type u_1\nv : K\nn : Nat\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\na✝ : Or (LE.le n 1) (Not ((GenContFract.of v).TerminatedAt (HSub.hSub n 2)))\n⊢ LE.le (↑(Nat.fib n)) ((GenContFract.of v).contsAux n).b","decl":"theorem fib_le_of_contsAux_b :\n    n ≤ 1 ∨ ¬(of v).TerminatedAt (n - 2) → (fib n : K) ≤ ((of v).contsAux n).b :=\n  Nat.strong_induction_on n\n    (by\n      intro n IH hyp\n      rcases n with (_ | _ | n)\n      · simp [fib_add_two, contsAux] -- case n = 0\n      · simp [fib_add_two, contsAux] -- case n = 1\n      · let g := of v -- case 2 ≤ n\n        have : ¬n + 2 ≤ 1 := by omega\n        have not_terminatedAt_n : ¬g.TerminatedAt n := Or.resolve_left hyp this\n        obtain ⟨gp, s_ppred_nth_eq⟩ : ∃ gp, g.s.get? n = some gp :=\n          Option.ne_none_iff_exists'.mp not_terminatedAt_n\n        set pconts := g.contsAux (n + 1) with pconts_eq\n        set ppconts := g.contsAux n with ppconts_eq\n        -- use the recurrence of `contsAux`\n        simp only [Nat.succ_eq_add_one, Nat.add_assoc, Nat.reduceAdd]\n        suffices (fib n : K) + fib (n + 1) ≤ gp.a * ppconts.b + gp.b * pconts.b by\n          simpa [g, fib_add_two, add_comm, contsAux_recurrence s_ppred_nth_eq ppconts_eq pconts_eq]\n        -- make use of the fact that `gp.a = 1`\n        suffices (fib n : K) + fib (n + 1) ≤ ppconts.b + gp.b * pconts.b by\n          simpa [of_partNum_eq_one <| partNum_eq_s_a s_ppred_nth_eq]\n        have not_terminatedAt_pred_n : ¬g.TerminatedAt (n - 1) :=\n          mt (terminated_stable <| Nat.sub_le n 1) not_terminatedAt_n\n        have not_terminatedAt_ppred_n : ¬TerminatedAt g (n - 2) :=\n          mt (terminated_stable (n - 1).pred_le) not_terminatedAt_pred_n\n        -- use the IH to get the inequalities for `pconts` and `ppconts`\n        have ppred_nth_fib_le_ppconts_B : (fib n : K) ≤ ppconts.b :=\n          IH n (lt_trans (Nat.lt.base n) <| Nat.lt.base <| n + 1) (Or.inr not_terminatedAt_ppred_n)\n        suffices (fib (n + 1) : K) ≤ gp.b * pconts.b by\n          solve_by_elim [_root_.add_le_add ppred_nth_fib_le_ppconts_B]\n        -- finally use the fact that `1 ≤ gp.b` to solve the goal\n        suffices 1 * (fib (n + 1) : K) ≤ gp.b * pconts.b by rwa [one_mul] at this\n        have one_le_gp_b : (1 : K) ≤ gp.b :=\n          of_one_le_get?_partDen (partDen_eq_s_b s_ppred_nth_eq)\n        have : (0 : K) ≤ fib (n + 1) := mod_cast (fib (n + 1)).zero_le\n        have : (0 : K) ≤ gp.b := le_trans zero_le_one one_le_gp_b\n        mono\n        · norm_num\n        · tauto)\n\n"}
{"name":"GenContFract.succ_nth_fib_le_of_nth_den","module":"Mathlib.Algebra.ContinuedFractions.Computation.Approximations","initialProofState":"K : Type u_1\nv : K\nn : Nat\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nhyp : Or (Eq n 0) (Not ((GenContFract.of v).TerminatedAt (HSub.hSub n 1)))\n⊢ LE.le (↑(Nat.fib (HAdd.hAdd n 1))) ((GenContFract.of v).dens n)","decl":"/-- Shows that the `n`th denominator is greater than or equal to the `n + 1`th fibonacci number,\nthat is `Nat.fib (n + 1) ≤ Bₙ`. -/\ntheorem succ_nth_fib_le_of_nth_den (hyp : n = 0 ∨ ¬(of v).TerminatedAt (n - 1)) :\n    (fib (n + 1) : K) ≤ (of v).dens n := by\n  rw [den_eq_conts_b, nth_cont_eq_succ_nth_contAux]\n  have : n + 1 ≤ 1 ∨ ¬(of v).TerminatedAt (n - 1) := by\n    cases n with\n    | zero => exact Or.inl <| le_refl 1\n    | succ n => exact Or.inr (Or.resolve_left hyp n.succ_ne_zero)\n  exact fib_le_of_contsAux_b this\n\n"}
{"name":"GenContFract.zero_le_of_contsAux_b","module":"Mathlib.Algebra.ContinuedFractions.Computation.Approximations","initialProofState":"K : Type u_1\nv : K\nn : Nat\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\n⊢ LE.le 0 ((GenContFract.of v).contsAux n).b","decl":"theorem zero_le_of_contsAux_b : 0 ≤ ((of v).contsAux n).b := by\n  let g := of v\n  induction n with\n  | zero => rfl\n  | succ n IH =>\n    rcases Decidable.em <| g.TerminatedAt (n - 1) with terminated | not_terminated\n    · -- terminating case\n      rcases n with - | n\n      · simp [zero_le_one]\n      · have : g.contsAux (n + 2) = g.contsAux (n + 1) :=\n          contsAux_stable_step_of_terminated terminated\n        simp only [g, this, IH]\n    · -- non-terminating case\n      calc\n        (0 : K) ≤ fib (n + 1) := mod_cast (n + 1).fib.zero_le\n        _ ≤ ((of v).contsAux (n + 1)).b := fib_le_of_contsAux_b (Or.inr not_terminated)\n\n"}
{"name":"GenContFract.zero_le_of_den","module":"Mathlib.Algebra.ContinuedFractions.Computation.Approximations","initialProofState":"K : Type u_1\nv : K\nn : Nat\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\n⊢ LE.le 0 ((GenContFract.of v).dens n)","decl":"/-- Shows that all denominators are nonnegative. -/\ntheorem zero_le_of_den : 0 ≤ (of v).dens n := by\n  rw [den_eq_conts_b, nth_cont_eq_succ_nth_contAux]; exact zero_le_of_contsAux_b\n\n"}
{"name":"GenContFract.le_of_succ_succ_get?_contsAux_b","module":"Mathlib.Algebra.ContinuedFractions.Computation.Approximations","initialProofState":"K : Type u_1\nv : K\nn : Nat\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nb : K\nnth_partDen_eq : Eq ((GenContFract.of v).partDens.get? n) (Option.some b)\n⊢ LE.le (HMul.hMul b ((GenContFract.of v).contsAux (HAdd.hAdd n 1)).b) ((GenContFract.of v).contsAux (HAdd.hAdd n 2)).b","decl":"theorem le_of_succ_succ_get?_contsAux_b {b : K}\n    (nth_partDen_eq : (of v).partDens.get? n = some b) :\n    b * ((of v).contsAux <| n + 1).b ≤ ((of v).contsAux <| n + 2).b := by\n  obtain ⟨gp_n, nth_s_eq, rfl⟩ : ∃ gp_n, (of v).s.get? n = some gp_n ∧ gp_n.b = b :=\n    exists_s_b_of_partDen nth_partDen_eq\n  simp [of_partNum_eq_one (partNum_eq_s_a nth_s_eq), zero_le_of_contsAux_b,\n    GenContFract.contsAux_recurrence nth_s_eq rfl rfl]\n\n"}
{"name":"GenContFract.le_of_succ_get?_den","module":"Mathlib.Algebra.ContinuedFractions.Computation.Approximations","initialProofState":"K : Type u_1\nv : K\nn : Nat\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nb : K\nnth_partDenom_eq : Eq ((GenContFract.of v).partDens.get? n) (Option.some b)\n⊢ LE.le (HMul.hMul b ((GenContFract.of v).dens n)) ((GenContFract.of v).dens (HAdd.hAdd n 1))","decl":"/-- Shows that `bₙ * Bₙ ≤ Bₙ₊₁`, where `bₙ` is the `n`th partial denominator and `Bₙ₊₁` and `Bₙ` are\nthe `n + 1`th and `n`th denominator of the continued fraction. -/\ntheorem le_of_succ_get?_den {b : K}\n    (nth_partDenom_eq : (of v).partDens.get? n = some b) :\n    b * (of v).dens n ≤ (of v).dens (n + 1) := by\n  rw [den_eq_conts_b, nth_cont_eq_succ_nth_contAux]\n  exact le_of_succ_succ_get?_contsAux_b nth_partDenom_eq\n\n"}
{"name":"GenContFract.of_den_mono","module":"Mathlib.Algebra.ContinuedFractions.Computation.Approximations","initialProofState":"K : Type u_1\nv : K\nn : Nat\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\n⊢ LE.le ((GenContFract.of v).dens n) ((GenContFract.of v).dens (HAdd.hAdd n 1))","decl":"/-- Shows that the sequence of denominators is monotone, that is `Bₙ ≤ Bₙ₊₁`. -/\ntheorem of_den_mono : (of v).dens n ≤ (of v).dens (n + 1) := by\n  let g := of v\n  rcases Decidable.em <| g.partDens.TerminatedAt n with terminated | not_terminated\n  · have : g.partDens.get? n = none := by rwa [Stream'.Seq.TerminatedAt] at terminated\n    have : g.TerminatedAt n :=\n      terminatedAt_iff_partDen_none.2 (by rwa [Stream'.Seq.TerminatedAt] at terminated)\n    have : g.dens (n + 1) = g.dens n :=\n      dens_stable_of_terminated n.le_succ this\n    rw [this]\n  · obtain ⟨b, nth_partDen_eq⟩ : ∃ b, g.partDens.get? n = some b :=\n      Option.ne_none_iff_exists'.mp not_terminated\n    have : 1 ≤ b := of_one_le_get?_partDen nth_partDen_eq\n    calc\n      g.dens n ≤ b * g.dens n := by\n        simpa using mul_le_mul_of_nonneg_right this zero_le_of_den\n      _ ≤ g.dens (n + 1) := le_of_succ_get?_den nth_partDen_eq\n\n"}
{"name":"GenContFract.sub_convs_eq","module":"Mathlib.Algebra.ContinuedFractions.Computation.Approximations","initialProofState":"K : Type u_1\nv : K\nn : Nat\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nifp : GenContFract.IntFractPair K\nstream_nth_eq : Eq (GenContFract.IntFractPair.stream v n) (Option.some ifp)\n⊢ let g := GenContFract.of v;\n  let B := (g.contsAux (HAdd.hAdd n 1)).b;\n  let pB := (g.contsAux n).b;\n  Eq (HSub.hSub v (g.convs n)) (ite (Eq ifp.fr 0) 0 (HDiv.hDiv (HPow.hPow (-1) n) (HMul.hMul B (HAdd.hAdd (HMul.hMul (Inv.inv ifp.fr) B) pB))))","decl":"/-- This lemma follows from the finite correctness proof, the determinant equality, and\nby simplifying the difference. -/\ntheorem sub_convs_eq {ifp : IntFractPair K}\n    (stream_nth_eq : IntFractPair.stream v n = some ifp) :\n    let g := of v\n    let B := (g.contsAux (n + 1)).b\n    let pB := (g.contsAux n).b\n    v - g.convs n = if ifp.fr = 0 then 0 else (-1) ^ n / (B * (ifp.fr⁻¹ * B + pB)) := by\n  -- set up some shorthand notation\n  let g := of v\n  let conts := g.contsAux (n + 1)\n  let pred_conts := g.contsAux n\n  have g_finite_correctness :\n    v = GenContFract.compExactValue pred_conts conts ifp.fr :=\n    compExactValue_correctness_of_stream_eq_some stream_nth_eq\n  obtain (ifp_fr_eq_zero | ifp_fr_ne_zero) := eq_or_ne ifp.fr 0\n  · suffices v - g.convs n = 0 by simpa [ifp_fr_eq_zero]\n    replace g_finite_correctness : v = g.convs n := by\n      simpa [GenContFract.compExactValue, ifp_fr_eq_zero] using g_finite_correctness\n    exact sub_eq_zero.2 g_finite_correctness\n  · -- more shorthand notation\n    let A := conts.a\n    let B := conts.b\n    let pA := pred_conts.a\n    let pB := pred_conts.b\n    -- first, let's simplify the goal as `ifp.fr ≠ 0`\n    suffices v - A / B = (-1) ^ n / (B * (ifp.fr⁻¹ * B + pB)) by simpa [ifp_fr_ne_zero]\n    -- now we can unfold `g.compExactValue` to derive the following equality for `v`\n    replace g_finite_correctness : v = (pA + ifp.fr⁻¹ * A) / (pB + ifp.fr⁻¹ * B) := by\n      simpa [GenContFract.compExactValue, ifp_fr_ne_zero, nextConts, nextNum, nextDen, add_comm]\n        using g_finite_correctness\n    -- let's rewrite this equality for `v` in our goal\n    suffices\n      (pA + ifp.fr⁻¹ * A) / (pB + ifp.fr⁻¹ * B) - A / B = (-1) ^ n / (B * (ifp.fr⁻¹ * B + pB)) by\n      rwa [g_finite_correctness]\n    -- To continue, we need use the determinant equality. So let's derive the needed hypothesis.\n    have n_eq_zero_or_not_terminatedAt_pred_n : n = 0 ∨ ¬g.TerminatedAt (n - 1) := by\n      rcases n with - | n'\n      · simp\n      · have : IntFractPair.stream v (n' + 1) ≠ none := by simp [stream_nth_eq]\n        have : ¬g.TerminatedAt n' :=\n          (not_congr of_terminatedAt_n_iff_succ_nth_intFractPair_stream_eq_none).2 this\n        exact Or.inr this\n    have determinant_eq : pA * B - pB * A = (-1) ^ n :=\n      (SimpContFract.of v).determinant_aux n_eq_zero_or_not_terminatedAt_pred_n\n    -- now all we got to do is to rewrite this equality in our goal and re-arrange terms;\n    -- however, for this, we first have to derive quite a few tedious inequalities.\n    have pB_ineq : (fib n : K) ≤ pB :=\n      haveI : n ≤ 1 ∨ ¬g.TerminatedAt (n - 2) := by\n        rcases n_eq_zero_or_not_terminatedAt_pred_n with n_eq_zero | not_terminatedAt_pred_n\n        · simp [n_eq_zero]\n        · exact Or.inr <| mt (terminated_stable (n - 1).pred_le) not_terminatedAt_pred_n\n      fib_le_of_contsAux_b this\n    have B_ineq : (fib (n + 1) : K) ≤ B :=\n      haveI : n + 1 ≤ 1 ∨ ¬g.TerminatedAt (n + 1 - 2) := by\n        rcases n_eq_zero_or_not_terminatedAt_pred_n with n_eq_zero | not_terminatedAt_pred_n\n        · simp [n_eq_zero, le_refl]\n        · exact Or.inr not_terminatedAt_pred_n\n      fib_le_of_contsAux_b this\n    have zero_lt_B : 0 < B := B_ineq.trans_lt' <| cast_pos.2 <| fib_pos.2 n.succ_pos\n    have : 0 ≤ pB := (cast_nonneg _).trans pB_ineq\n    have : 0 < ifp.fr :=\n      ifp_fr_ne_zero.lt_of_le' <| IntFractPair.nth_stream_fr_nonneg stream_nth_eq\n    have : pB + ifp.fr⁻¹ * B ≠ 0 := by positivity\n    -- finally, let's do the rewriting\n    calc\n      (pA + ifp.fr⁻¹ * A) / (pB + ifp.fr⁻¹ * B) - A / B =\n          ((pA + ifp.fr⁻¹ * A) * B - (pB + ifp.fr⁻¹ * B) * A) / ((pB + ifp.fr⁻¹ * B) * B) := by\n        rw [div_sub_div _ _ this zero_lt_B.ne']\n      _ = (pA * B + ifp.fr⁻¹ * A * B - (pB * A + ifp.fr⁻¹ * B * A)) / _ := by repeat' rw [add_mul]\n      _ = (pA * B - pB * A) / ((pB + ifp.fr⁻¹ * B) * B) := by ring\n      _ = (-1) ^ n / ((pB + ifp.fr⁻¹ * B) * B) := by rw [determinant_eq]\n      _ = (-1) ^ n / (B * (ifp.fr⁻¹ * B + pB)) := by ac_rfl\n\n"}
{"name":"GenContFract.abs_sub_convs_le","module":"Mathlib.Algebra.ContinuedFractions.Computation.Approximations","initialProofState":"K : Type u_1\nv : K\nn : Nat\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nnot_terminatedAt_n : Not ((GenContFract.of v).TerminatedAt n)\n⊢ LE.le (abs (HSub.hSub v ((GenContFract.of v).convs n))) (HDiv.hDiv 1 (HMul.hMul ((GenContFract.of v).dens n) ((GenContFract.of v).dens (HAdd.hAdd n 1))))","decl":"/-- Shows that `|v - Aₙ / Bₙ| ≤ 1 / (Bₙ * Bₙ₊₁)`. -/\ntheorem abs_sub_convs_le (not_terminatedAt_n : ¬(of v).TerminatedAt n) :\n    |v - (of v).convs n| ≤ 1 / ((of v).dens n * ((of v).dens <| n + 1)) := by\n  -- shorthand notation\n  let g := of v\n  let nextConts := g.contsAux (n + 2)\n  set conts := contsAux g (n + 1) with conts_eq\n  set pred_conts := contsAux g n with pred_conts_eq\n  -- change the goal to something more readable\n  change |v - convs g n| ≤ 1 / (conts.b * nextConts.b)\n  obtain ⟨gp, s_nth_eq⟩ : ∃ gp, g.s.get? n = some gp :=\n    Option.ne_none_iff_exists'.1 not_terminatedAt_n\n  have gp_a_eq_one : gp.a = 1 := of_partNum_eq_one (partNum_eq_s_a s_nth_eq)\n  -- unfold the recurrence relation for `nextConts.b`\n  have nextConts_b_eq : nextConts.b = pred_conts.b + gp.b * conts.b := by\n    simp [nextConts, contsAux_recurrence s_nth_eq pred_conts_eq conts_eq, gp_a_eq_one,\n      pred_conts_eq.symm, conts_eq.symm, add_comm]\n  let den := conts.b * (pred_conts.b + gp.b * conts.b)\n  suffices |v - g.convs n| ≤ 1 / den by rw [nextConts_b_eq]; congr 1\n  obtain ⟨ifp_succ_n, succ_nth_stream_eq, ifp_succ_n_b_eq_gp_b⟩ :\n      ∃ ifp_succ_n, IntFractPair.stream v (n + 1) = some ifp_succ_n ∧ (ifp_succ_n.b : K) = gp.b :=\n    IntFractPair.exists_succ_get?_stream_of_gcf_of_get?_eq_some s_nth_eq\n  obtain ⟨ifp_n, stream_nth_eq, stream_nth_fr_ne_zero, if_of_eq_ifp_succ_n⟩ :\n    ∃ ifp_n, IntFractPair.stream v n = some ifp_n ∧ ifp_n.fr ≠ 0\n      ∧ IntFractPair.of ifp_n.fr⁻¹ = ifp_succ_n :=\n    IntFractPair.succ_nth_stream_eq_some_iff.1 succ_nth_stream_eq\n  let den' := conts.b * (pred_conts.b + ifp_n.fr⁻¹ * conts.b)\n  -- now we can use `sub_convs_eq` to simplify our goal\n  suffices |(-1) ^ n / den'| ≤ 1 / den by\n    have : v - g.convs n = (-1) ^ n / den' := by\n      -- apply `sub_convs_eq` and simplify the result\n      have tmp := sub_convs_eq stream_nth_eq\n      simp only [stream_nth_fr_ne_zero, conts_eq.symm, pred_conts_eq.symm, if_false] at tmp\n      rw [tmp]\n      ring\n    rwa [this]\n  -- derive some tedious inequalities that we need to rewrite our goal\n  have nextConts_b_ineq : (fib (n + 2) : K) ≤ pred_conts.b + gp.b * conts.b := by\n    have : (fib (n + 2) : K) ≤ nextConts.b :=\n      fib_le_of_contsAux_b (Or.inr not_terminatedAt_n)\n    rwa [nextConts_b_eq] at this\n  have conts_b_ineq : (fib (n + 1) : K) ≤ conts.b :=\n    haveI : ¬g.TerminatedAt (n - 1) := mt (terminated_stable n.pred_le) not_terminatedAt_n\n    fib_le_of_contsAux_b <| Or.inr this\n  have zero_lt_conts_b : 0 < conts.b :=\n    conts_b_ineq.trans_lt' <| mod_cast fib_pos.2 n.succ_pos\n  -- `den'` is positive, so we can remove `|⬝|` from our goal\n  suffices 1 / den' ≤ 1 / den by\n    have : |(-1) ^ n / den'| = 1 / den' := by\n      suffices 1 / |den'| = 1 / den' by rwa [abs_div, abs_neg_one_pow n]\n      have : 0 < den' := by\n        have : 0 ≤ pred_conts.b :=\n          haveI : (fib n : K) ≤ pred_conts.b :=\n            haveI : ¬g.TerminatedAt (n - 2) :=\n              mt (terminated_stable (n.sub_le 2)) not_terminatedAt_n\n            fib_le_of_contsAux_b <| Or.inr this\n          le_trans (mod_cast (fib n).zero_le) this\n        have : 0 < ifp_n.fr⁻¹ :=\n          haveI zero_le_ifp_n_fract : 0 ≤ ifp_n.fr :=\n            IntFractPair.nth_stream_fr_nonneg stream_nth_eq\n          inv_pos.2 (lt_of_le_of_ne zero_le_ifp_n_fract stream_nth_fr_ne_zero.symm)\n        -- Porting note: replaced complicated positivity proof with tactic.\n        positivity\n      rw [abs_of_pos this]\n    rwa [this]\n  suffices 0 < den ∧ den ≤ den' from div_le_div_of_nonneg_left zero_le_one this.1 this.2\n  constructor\n  · have : 0 < pred_conts.b + gp.b * conts.b :=\n      nextConts_b_ineq.trans_lt' <| mod_cast fib_pos.2 <| succ_pos _\n    solve_by_elim [mul_pos]\n  · -- we can cancel multiplication by `conts.b` and addition with `pred_conts.b`\n    suffices gp.b * conts.b ≤ ifp_n.fr⁻¹ * conts.b from\n      (mul_le_mul_left zero_lt_conts_b).2 <| (add_le_add_iff_left pred_conts.b).2 this\n    suffices (ifp_succ_n.b : K) * conts.b ≤ ifp_n.fr⁻¹ * conts.b by rwa [← ifp_succ_n_b_eq_gp_b]\n    have : (ifp_succ_n.b : K) ≤ ifp_n.fr⁻¹ :=\n      IntFractPair.succ_nth_stream_b_le_nth_stream_fr_inv stream_nth_eq succ_nth_stream_eq\n    have : 0 ≤ conts.b := le_of_lt zero_lt_conts_b\n    gcongr; exact this\n\n"}
{"name":"GenContFract.abs_sub_convergents_le'","module":"Mathlib.Algebra.ContinuedFractions.Computation.Approximations","initialProofState":"K : Type u_1\nv : K\nn : Nat\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nb : K\nnth_partDen_eq : Eq ((GenContFract.of v).partDens.get? n) (Option.some b)\n⊢ LE.le (abs (HSub.hSub v ((GenContFract.of v).convs n))) (HDiv.hDiv 1 (HMul.hMul (HMul.hMul b ((GenContFract.of v).dens n)) ((GenContFract.of v).dens n)))","decl":"/-- Shows that `|v - Aₙ / Bₙ| ≤ 1 / (bₙ * Bₙ * Bₙ)`. This bound is worse than the one shown in\n`GenContFract.abs_sub_convs_le`, but sometimes it is easier to apply and\nsufficient for one's use case.\n -/\ntheorem abs_sub_convergents_le' {b : K}\n    (nth_partDen_eq : (of v).partDens.get? n = some b) :\n    |v - (of v).convs n| ≤ 1 / (b * (of v).dens n * (of v).dens n) := by\n  have not_terminatedAt_n : ¬(of v).TerminatedAt n := by\n    simp [terminatedAt_iff_partDen_none, nth_partDen_eq]\n  refine (abs_sub_convs_le not_terminatedAt_n).trans ?_\n  -- One can show that `0 < (GenContFract.of v).dens n` but it's easier\n  -- to consider the case `(GenContFract.of v).dens n = 0`.\n  rcases (zero_le_of_den (K := K)).eq_or_gt with\n    ((hB : (GenContFract.of v).dens n = 0) | hB)\n  · simp only [hB, mul_zero, zero_mul, div_zero, le_refl]\n  · apply one_div_le_one_div_of_le\n    · have : 0 < b := zero_lt_one.trans_le (of_one_le_get?_partDen nth_partDen_eq)\n      apply_rules [mul_pos]\n    · conv_rhs => rw [mul_comm]\n      exact mul_le_mul_of_nonneg_right (le_of_succ_get?_den nth_partDen_eq) hB.le\n\n"}
