{"name":"MeasureTheory.ComplexMeasure.re_apply","module":"Mathlib.MeasureTheory.Measure.Complex","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nv : MeasureTheory.VectorMeasure α Complex\n⊢ Eq (MeasureTheory.ComplexMeasure.re v) (v.mapRange Complex.reLm.toAddMonoidHom Complex.continuous_re)","decl":"/-- The real part of a complex measure is a signed measure. -/\n@[simps! apply]\ndef re : ComplexMeasure α →ₗ[ℝ] SignedMeasure α :=\n  mapRangeₗ Complex.reCLM Complex.continuous_re\n\n"}
{"name":"MeasureTheory.ComplexMeasure.im_apply","module":"Mathlib.MeasureTheory.Measure.Complex","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nv : MeasureTheory.VectorMeasure α Complex\n⊢ Eq (MeasureTheory.ComplexMeasure.im v) (v.mapRange Complex.imLm.toAddMonoidHom Complex.continuous_im)","decl":"/-- The imaginary part of a complex measure is a signed measure. -/\n@[simps! apply]\ndef im : ComplexMeasure α →ₗ[ℝ] SignedMeasure α :=\n  mapRangeₗ Complex.imCLM Complex.continuous_im\n\n"}
{"name":"MeasureTheory.SignedMeasure.toComplexMeasure_apply_im","module":"Mathlib.MeasureTheory.Measure.Complex","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns t : MeasureTheory.SignedMeasure α\ni : Set α\n⊢ Eq (↑(s.toComplexMeasure t) i).im (↑t i)","decl":"/-- Given `s` and `t` signed measures, `s + it` is a complex measure -/\n@[simps!]\ndef _root_.MeasureTheory.SignedMeasure.toComplexMeasure (s t : SignedMeasure α) :\n    ComplexMeasure α where\n  measureOf' i := ⟨s i, t i⟩\n  empty' := by dsimp only; rw [s.empty, t.empty]; rfl\n  not_measurable' i hi := by dsimp only; rw [s.not_measurable hi, t.not_measurable hi]; rfl\n  m_iUnion' _ hf hfdisj := (Complex.hasSum_iff _ _).2 ⟨s.m_iUnion hf hfdisj, t.m_iUnion hf hfdisj⟩\n\n"}
{"name":"MeasureTheory.SignedMeasure.toComplexMeasure_apply_re","module":"Mathlib.MeasureTheory.Measure.Complex","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns t : MeasureTheory.SignedMeasure α\ni : Set α\n⊢ Eq (↑(s.toComplexMeasure t) i).re (↑s i)","decl":"/-- Given `s` and `t` signed measures, `s + it` is a complex measure -/\n@[simps!]\ndef _root_.MeasureTheory.SignedMeasure.toComplexMeasure (s t : SignedMeasure α) :\n    ComplexMeasure α where\n  measureOf' i := ⟨s i, t i⟩\n  empty' := by dsimp only; rw [s.empty, t.empty]; rfl\n  not_measurable' i hi := by dsimp only; rw [s.not_measurable hi, t.not_measurable hi]; rfl\n  m_iUnion' _ hf hfdisj := (Complex.hasSum_iff _ _).2 ⟨s.m_iUnion hf hfdisj, t.m_iUnion hf hfdisj⟩\n\n"}
{"name":"MeasureTheory.SignedMeasure.toComplexMeasure_apply","module":"Mathlib.MeasureTheory.Measure.Complex","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns t : MeasureTheory.SignedMeasure α\ni : Set α\n⊢ Eq (↑(s.toComplexMeasure t) i) { re := ↑s i, im := ↑t i }","decl":"theorem _root_.MeasureTheory.SignedMeasure.toComplexMeasure_apply\n    {s t : SignedMeasure α} {i : Set α} : s.toComplexMeasure t i = ⟨s i, t i⟩ := rfl\n\n"}
{"name":"MeasureTheory.ComplexMeasure.toComplexMeasure_to_signedMeasure","module":"Mathlib.MeasureTheory.Measure.Complex","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nc : MeasureTheory.ComplexMeasure α\n⊢ Eq ((MeasureTheory.ComplexMeasure.re c).toComplexMeasure (MeasureTheory.ComplexMeasure.im c)) c","decl":"theorem toComplexMeasure_to_signedMeasure (c : ComplexMeasure α) :\n    SignedMeasure.toComplexMeasure (ComplexMeasure.re c) (ComplexMeasure.im c) = c := rfl\n\n"}
{"name":"MeasureTheory.SignedMeasure.re_toComplexMeasure","module":"Mathlib.MeasureTheory.Measure.Complex","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns t : MeasureTheory.SignedMeasure α\n⊢ Eq (MeasureTheory.ComplexMeasure.re (s.toComplexMeasure t)) s","decl":"theorem _root_.MeasureTheory.SignedMeasure.re_toComplexMeasure (s t : SignedMeasure α) :\n    ComplexMeasure.re (SignedMeasure.toComplexMeasure s t) = s := rfl\n\n"}
{"name":"MeasureTheory.SignedMeasure.im_toComplexMeasure","module":"Mathlib.MeasureTheory.Measure.Complex","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns t : MeasureTheory.SignedMeasure α\n⊢ Eq (MeasureTheory.ComplexMeasure.im (s.toComplexMeasure t)) t","decl":"theorem _root_.MeasureTheory.SignedMeasure.im_toComplexMeasure (s t : SignedMeasure α) :\n    ComplexMeasure.im (SignedMeasure.toComplexMeasure s t) = t := rfl\n\n"}
{"name":"MeasureTheory.ComplexMeasure.equivSignedMeasure_symm_apply","module":"Mathlib.MeasureTheory.Measure.Complex","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nx✝ : Prod (MeasureTheory.SignedMeasure α) (MeasureTheory.SignedMeasure α)\n⊢ Eq (MeasureTheory.ComplexMeasure.equivSignedMeasure.symm x✝) (MeasureTheory.ComplexMeasure.equivSignedMeasure.match_1 (fun x => MeasureTheory.ComplexMeasure α) x✝ fun s t => s.toComplexMeasure t)","decl":"/-- The complex measures form an equivalence to the type of pairs of signed measures. -/\n@[simps]\ndef equivSignedMeasure : ComplexMeasure α ≃ SignedMeasure α × SignedMeasure α where\n  toFun c := ⟨ComplexMeasure.re c, ComplexMeasure.im c⟩\n  invFun := fun ⟨s, t⟩ => s.toComplexMeasure t\n  left_inv c := c.toComplexMeasure_to_signedMeasure\n  right_inv := fun ⟨s, t⟩ => Prod.mk.inj_iff.2 ⟨s.re_toComplexMeasure t, s.im_toComplexMeasure t⟩\n\n"}
{"name":"MeasureTheory.ComplexMeasure.equivSignedMeasure_apply","module":"Mathlib.MeasureTheory.Measure.Complex","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nc : MeasureTheory.ComplexMeasure α\n⊢ Eq (MeasureTheory.ComplexMeasure.equivSignedMeasure c) { fst := MeasureTheory.ComplexMeasure.re c, snd := MeasureTheory.ComplexMeasure.im c }","decl":"/-- The complex measures form an equivalence to the type of pairs of signed measures. -/\n@[simps]\ndef equivSignedMeasure : ComplexMeasure α ≃ SignedMeasure α × SignedMeasure α where\n  toFun c := ⟨ComplexMeasure.re c, ComplexMeasure.im c⟩\n  invFun := fun ⟨s, t⟩ => s.toComplexMeasure t\n  left_inv c := c.toComplexMeasure_to_signedMeasure\n  right_inv := fun ⟨s, t⟩ => Prod.mk.inj_iff.2 ⟨s.re_toComplexMeasure t, s.im_toComplexMeasure t⟩\n\n"}
{"name":"MeasureTheory.ComplexMeasure.equivSignedMeasureₗ_apply","module":"Mathlib.MeasureTheory.Measure.Complex","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nR : Type u_2\ninst✝³ : Semiring R\ninst✝² : Module R Real\ninst✝¹ : ContinuousConstSMul R Real\ninst✝ : ContinuousConstSMul R Complex\na✝ : MeasureTheory.ComplexMeasure α\n⊢ Eq (MeasureTheory.ComplexMeasure.equivSignedMeasureₗ a✝) (MeasureTheory.ComplexMeasure.equivSignedMeasure.toFun a✝)","decl":"/-- The complex measures form a linear isomorphism to the type of pairs of signed measures. -/\n@[simps]\ndef equivSignedMeasureₗ : ComplexMeasure α ≃ₗ[R] SignedMeasure α × SignedMeasure α :=\n  { equivSignedMeasure with\n    map_add' := fun c d => by rfl\n    map_smul' := by\n      intro r c\n      dsimp\n      ext\n      · simp [Complex.smul_re]\n      · simp [Complex.smul_im] }\n\n"}
{"name":"MeasureTheory.ComplexMeasure.equivSignedMeasureₗ_symm_apply","module":"Mathlib.MeasureTheory.Measure.Complex","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nR : Type u_2\ninst✝³ : Semiring R\ninst✝² : Module R Real\ninst✝¹ : ContinuousConstSMul R Real\ninst✝ : ContinuousConstSMul R Complex\na✝ : Prod (MeasureTheory.SignedMeasure α) (MeasureTheory.SignedMeasure α)\n⊢ Eq (MeasureTheory.ComplexMeasure.equivSignedMeasureₗ.symm a✝) (MeasureTheory.ComplexMeasure.equivSignedMeasure.invFun a✝)","decl":"/-- The complex measures form a linear isomorphism to the type of pairs of signed measures. -/\n@[simps]\ndef equivSignedMeasureₗ : ComplexMeasure α ≃ₗ[R] SignedMeasure α × SignedMeasure α :=\n  { equivSignedMeasure with\n    map_add' := fun c d => by rfl\n    map_smul' := by\n      intro r c\n      dsimp\n      ext\n      · simp [Complex.smul_re]\n      · simp [Complex.smul_im] }\n\n"}
{"name":"MeasureTheory.ComplexMeasure.absolutelyContinuous_ennreal_iff","module":"Mathlib.MeasureTheory.Measure.Complex","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nc : MeasureTheory.ComplexMeasure α\nμ : MeasureTheory.VectorMeasure α ENNReal\n⊢ Iff (MeasureTheory.VectorMeasure.AbsolutelyContinuous c μ) (And (MeasureTheory.VectorMeasure.AbsolutelyContinuous (MeasureTheory.ComplexMeasure.re c) μ) (MeasureTheory.VectorMeasure.AbsolutelyContinuous (MeasureTheory.ComplexMeasure.im c) μ))","decl":"theorem absolutelyContinuous_ennreal_iff (c : ComplexMeasure α) (μ : VectorMeasure α ℝ≥0∞) :\n    c ≪ᵥ μ ↔ ComplexMeasure.re c ≪ᵥ μ ∧ ComplexMeasure.im c ≪ᵥ μ := by\n  constructor <;> intro h\n  · constructor <;> · intro i hi; simp [h hi]\n  · intro i hi\n    rw [← Complex.re_add_im (c i), (_ : (c i).re = 0), (_ : (c i).im = 0)]\n    exacts [by simp, h.2 hi, h.1 hi]\n\n"}
