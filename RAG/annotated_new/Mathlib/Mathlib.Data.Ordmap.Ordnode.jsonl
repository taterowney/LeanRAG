{"name":"Ordnode.nil.sizeOf_spec","module":"Mathlib.Data.Ordmap.Ordnode","initialProofState":"α : Type u\ninst✝ : SizeOf α\n⊢ Eq (SizeOf.sizeOf Ordnode.nil) 1","decl":"/-- An `Ordnode α` is a finite set of values, represented as a tree.\n  The operations on this type maintain that the tree is balanced\n  and correctly stores subtree sizes at each level. -/\ninductive Ordnode (α : Type u) : Type u\n  | nil : Ordnode α\n  | node (size : ℕ) (l : Ordnode α) (x : α) (r : Ordnode α) : Ordnode α\n\n-- Porting note: `Nat.Partrec.Code.recOn` is noncomputable in Lean4, so we make it computable.\n"}
{"name":"Ordnode.node.sizeOf_spec","module":"Mathlib.Data.Ordmap.Ordnode","initialProofState":"α : Type u\ninst✝ : SizeOf α\nsize : Nat\nl : Ordnode α\nx : α\nr : Ordnode α\n⊢ Eq (SizeOf.sizeOf (Ordnode.node size l x r)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf size)) (SizeOf.sizeOf l)) (SizeOf.sizeOf x)) (SizeOf.sizeOf r))","decl":"/-- An `Ordnode α` is a finite set of values, represented as a tree.\n  The operations on this type maintain that the tree is balanced\n  and correctly stores subtree sizes at each level. -/\ninductive Ordnode (α : Type u) : Type u\n  | nil : Ordnode α\n  | node (size : ℕ) (l : Ordnode α) (x : α) (r : Ordnode α) : Ordnode α\n\n-- Porting note: `Nat.Partrec.Code.recOn` is noncomputable in Lean4, so we make it computable.\n"}
{"name":"Ordnode.node.inj","module":"Mathlib.Data.Ordmap.Ordnode","initialProofState":"α : Type u\nsize✝ : Nat\nl✝ : Ordnode α\nx✝¹ : α\nr✝ : Ordnode α\nsize : Nat\nl : Ordnode α\nx : α\nr : Ordnode α\nx✝ : Eq (Ordnode.node size✝ l✝ x✝¹ r✝) (Ordnode.node size l x r)\n⊢ And (Eq size✝ size) (And (Eq l✝ l) (And (Eq x✝¹ x) (Eq r✝ r)))","decl":"/-- An `Ordnode α` is a finite set of values, represented as a tree.\n  The operations on this type maintain that the tree is balanced\n  and correctly stores subtree sizes at each level. -/\ninductive Ordnode (α : Type u) : Type u\n  | nil : Ordnode α\n  | node (size : ℕ) (l : Ordnode α) (x : α) (r : Ordnode α) : Ordnode α\n\n-- Porting note: `Nat.Partrec.Code.recOn` is noncomputable in Lean4, so we make it computable.\n"}
{"name":"Ordnode.node.injEq","module":"Mathlib.Data.Ordmap.Ordnode","initialProofState":"α : Type u\nsize✝ : Nat\nl✝ : Ordnode α\nx✝ : α\nr✝ : Ordnode α\nsize : Nat\nl : Ordnode α\nx : α\nr : Ordnode α\n⊢ Eq (Eq (Ordnode.node size✝ l✝ x✝ r✝) (Ordnode.node size l x r)) (And (Eq size✝ size) (And (Eq l✝ l) (And (Eq x✝ x) (Eq r✝ r))))","decl":"/-- An `Ordnode α` is a finite set of values, represented as a tree.\n  The operations on this type maintain that the tree is balanced\n  and correctly stores subtree sizes at each level. -/\ninductive Ordnode (α : Type u) : Type u\n  | nil : Ordnode α\n  | node (size : ℕ) (l : Ordnode α) (x : α) (r : Ordnode α) : Ordnode α\n\n-- Porting note: `Nat.Partrec.Code.recOn` is noncomputable in Lean4, so we make it computable.\n"}
{"name":"Ordnode.size_nil","module":"Mathlib.Data.Ordmap.Ordnode","initialProofState":"α : Type u_1\n⊢ Eq Ordnode.nil.size 0","decl":"@[simp] theorem size_nil : size (nil : Ordnode α) = 0 :=\n  rfl\n"}
{"name":"Ordnode.size_node","module":"Mathlib.Data.Ordmap.Ordnode","initialProofState":"α : Type u_1\nsz : Nat\nl : Ordnode α\nx : α\nr : Ordnode α\n⊢ Eq (Ordnode.node sz l x r).size sz","decl":"@[simp] theorem size_node (sz : ℕ) (l : Ordnode α) (x : α) (r : Ordnode α) :\n    size (node sz l x r) = sz :=\n  rfl\n\n"}
