{"name":"IsEvenlyCovered.mem_toTrivialization_baseSet","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝² : TopologicalSpace E\ninst✝¹ : TopologicalSpace X\nf : E → X\nx : X\nI : Type u_3\ninst✝ : TopologicalSpace I\nh : IsEvenlyCovered f x I\n⊢ Membership.mem h.toTrivialization.baseSet x","decl":"theorem mem_toTrivialization_baseSet {x : X} {I : Type*} [TopologicalSpace I]\n    (h : IsEvenlyCovered f x I) : x ∈ h.toTrivialization.baseSet :=\n  Classical.choose_spec h.2\n\n"}
{"name":"IsEvenlyCovered.toTrivialization_apply","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝² : TopologicalSpace E\ninst✝¹ : TopologicalSpace X\nf : E → X\nx : E\nI : Type u_3\ninst✝ : TopologicalSpace I\nh : IsEvenlyCovered f (f x) I\n⊢ Eq (↑h.toTrivialization x).2 ⟨x, ⋯⟩","decl":"theorem toTrivialization_apply {x : E} {I : Type*} [TopologicalSpace I]\n    (h : IsEvenlyCovered f (f x) I) : (h.toTrivialization x).2 = ⟨x, rfl⟩ :=\n  let e := Classical.choose h.2\n  let h := Classical.choose_spec h.2\n  let he := e.mk_proj_snd' h\n  Subtype.ext\n    ((e.toPartialEquiv.eq_symm_apply (e.mem_source.mpr h)\n            (by rwa [he, e.mem_target, e.coe_fst (e.mem_source.mpr h)])).mpr\n        he.symm).symm\n\n"}
{"name":"IsEvenlyCovered.continuousAt","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝² : TopologicalSpace E\ninst✝¹ : TopologicalSpace X\nf : E → X\nx : E\nI : Type u_3\ninst✝ : TopologicalSpace I\nh : IsEvenlyCovered f (f x) I\n⊢ ContinuousAt f x","decl":"protected theorem continuousAt {x : E} {I : Type*} [TopologicalSpace I]\n    (h : IsEvenlyCovered f (f x) I) : ContinuousAt f x :=\n  let e := h.toTrivialization\n  e.continuousAt_proj (e.mem_source.mpr (mem_toTrivialization_baseSet h))\n\n"}
{"name":"IsEvenlyCovered.to_isEvenlyCovered_preimage","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝² : TopologicalSpace E\ninst✝¹ : TopologicalSpace X\nf : E → X\nx : X\nI : Type u_3\ninst✝ : TopologicalSpace I\nh : IsEvenlyCovered f x I\n⊢ IsEvenlyCovered f x ↑(Set.preimage f (Singleton.singleton x))","decl":"theorem to_isEvenlyCovered_preimage {x : X} {I : Type*} [TopologicalSpace I]\n    (h : IsEvenlyCovered f x I) : IsEvenlyCovered f x (f ⁻¹' {x}) :=\n  let ⟨_, h2⟩ := h\n  ⟨((Classical.choose h2).preimageSingletonHomeomorph\n          (Classical.choose_spec h2)).isEmbedding.discreteTopology,\n    _, h.mem_toTrivialization_baseSet⟩\n\n"}
{"name":"IsCoveringMapOn.mk","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝² : TopologicalSpace E\ninst✝¹ : TopologicalSpace X\nf : E → X\ns : Set X\nF : X → Type u_3\ninst✝ : (x : X) → TopologicalSpace (F x)\nhF : ∀ (x : X), DiscreteTopology (F x)\ne : (x : X) → Membership.mem s x → Trivialization (F x) f\nh : ∀ (x : X) (hx : Membership.mem s x), Membership.mem (e x hx).baseSet x\n⊢ IsCoveringMapOn f s","decl":"theorem mk (F : X → Type*) [∀ x, TopologicalSpace (F x)] [hF : ∀ x, DiscreteTopology (F x)]\n    (e : ∀ x ∈ s, Trivialization (F x) f) (h : ∀ (x : X) (hx : x ∈ s), x ∈ (e x hx).baseSet) :\n    IsCoveringMapOn f s := fun x hx =>\n  IsEvenlyCovered.to_isEvenlyCovered_preimage ⟨hF x, e x hx, h x hx⟩\n\n"}
{"name":"IsCoveringMapOn.continuousAt","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalSpace X\nf : E → X\ns : Set X\nhf : IsCoveringMapOn f s\nx : E\nhx : Membership.mem s (f x)\n⊢ ContinuousAt f x","decl":"protected theorem continuousAt (hf : IsCoveringMapOn f s) {x : E} (hx : f x ∈ s) :\n    ContinuousAt f x :=\n  (hf (f x) hx).continuousAt\n\n"}
{"name":"IsCoveringMapOn.continuousOn","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalSpace X\nf : E → X\ns : Set X\nhf : IsCoveringMapOn f s\n⊢ ContinuousOn f (Set.preimage f s)","decl":"protected theorem continuousOn (hf : IsCoveringMapOn f s) : ContinuousOn f (f ⁻¹' s) :=\n  continuousOn_of_forall_continuousAt fun _ => hf.continuousAt\n\n"}
{"name":"IsCoveringMapOn.isLocalHomeomorphOn","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalSpace X\nf : E → X\ns : Set X\nhf : IsCoveringMapOn f s\n⊢ IsLocalHomeomorphOn f (Set.preimage f s)","decl":"protected theorem isLocalHomeomorphOn (hf : IsCoveringMapOn f s) :\n    IsLocalHomeomorphOn f (f ⁻¹' s) := by\n  refine IsLocalHomeomorphOn.mk f (f ⁻¹' s) fun x hx => ?_\n  let e := (hf (f x) hx).toTrivialization\n  have h := (hf (f x) hx).mem_toTrivialization_baseSet\n  let he := e.mem_source.2 h\n  refine\n    ⟨e.toPartialHomeomorph.trans\n        { toFun := fun p => p.1\n          invFun := fun p => ⟨p, x, rfl⟩\n          source := e.baseSet ×ˢ ({⟨x, rfl⟩} : Set (f ⁻¹' {f x}))\n          target := e.baseSet\n          open_source :=\n            e.open_baseSet.prod (singletons_open_iff_discrete.2 (hf (f x) hx).1 ⟨x, rfl⟩)\n          open_target := e.open_baseSet\n          map_source' := fun p => And.left\n          map_target' := fun p hp => ⟨hp, rfl⟩\n          left_inv' := fun p hp => Prod.ext rfl hp.2.symm\n          right_inv' := fun p _ => rfl\n          continuousOn_toFun := continuous_fst.continuousOn\n          continuousOn_invFun := (continuous_id'.prod_mk continuous_const).continuousOn },\n      ⟨he, by rwa [e.toPartialHomeomorph.symm_symm, e.proj_toFun x he],\n        (hf (f x) hx).toTrivialization_apply⟩,\n      fun p h => (e.proj_toFun p h.1).symm⟩\n\n"}
{"name":"isCoveringMap_iff_isCoveringMapOn_univ","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalSpace X\nf : E → X\n⊢ Iff (IsCoveringMap f) (IsCoveringMapOn f Set.univ)","decl":"theorem isCoveringMap_iff_isCoveringMapOn_univ : IsCoveringMap f ↔ IsCoveringMapOn f Set.univ := by\n  simp only [IsCoveringMap, IsCoveringMapOn, Set.mem_univ, forall_true_left]\n\n"}
{"name":"IsCoveringMap.isCoveringMapOn","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalSpace X\nf : E → X\nhf : IsCoveringMap f\n⊢ IsCoveringMapOn f Set.univ","decl":"protected theorem IsCoveringMap.isCoveringMapOn (hf : IsCoveringMap f) :\n    IsCoveringMapOn f Set.univ :=\n  isCoveringMap_iff_isCoveringMapOn_univ.mp hf\n\n"}
{"name":"IsCoveringMap.mk","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace E\ninst✝² : TopologicalSpace X\nf : E → X\nF : X → Type u_3\ninst✝¹ : (x : X) → TopologicalSpace (F x)\ninst✝ : ∀ (x : X), DiscreteTopology (F x)\ne : (x : X) → Trivialization (F x) f\nh : ∀ (x : X), Membership.mem (e x).baseSet x\n⊢ IsCoveringMap f","decl":"theorem mk (F : X → Type*) [∀ x, TopologicalSpace (F x)] [∀ x, DiscreteTopology (F x)]\n    (e : ∀ x, Trivialization (F x) f) (h : ∀ x, x ∈ (e x).baseSet) : IsCoveringMap f :=\n  isCoveringMap_iff_isCoveringMapOn_univ.mpr\n    (IsCoveringMapOn.mk f Set.univ F (fun x _ => e x) fun x _ => h x)\n\n"}
{"name":"IsCoveringMap.continuous","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalSpace X\nf : E → X\nhf : IsCoveringMap f\n⊢ Continuous f","decl":"protected theorem continuous : Continuous f :=\n  continuous_iff_continuousOn_univ.mpr hf.isCoveringMapOn.continuousOn\n\n"}
{"name":"IsCoveringMap.isLocalHomeomorph","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalSpace X\nf : E → X\nhf : IsCoveringMap f\n⊢ IsLocalHomeomorph f","decl":"protected theorem isLocalHomeomorph : IsLocalHomeomorph f :=\n  isLocalHomeomorph_iff_isLocalHomeomorphOn_univ.mpr hf.isCoveringMapOn.isLocalHomeomorphOn\n\n"}
{"name":"IsCoveringMap.isOpenMap","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalSpace X\nf : E → X\nhf : IsCoveringMap f\n⊢ IsOpenMap f","decl":"protected theorem isOpenMap : IsOpenMap f :=\n  hf.isLocalHomeomorph.isOpenMap\n\n"}
{"name":"IsCoveringMap.isQuotientMap","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalSpace X\nf : E → X\nhf : IsCoveringMap f\nhf' : Function.Surjective f\n⊢ Topology.IsQuotientMap f","decl":"theorem isQuotientMap (hf' : Function.Surjective f) : IsQuotientMap f :=\n  hf.isOpenMap.isQuotientMap hf.continuous hf'\n\n"}
{"name":"IsCoveringMap.quotientMap","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalSpace X\nf : E → X\nhf : IsCoveringMap f\nhf' : Function.Surjective f\n⊢ Topology.IsQuotientMap f","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap := isQuotientMap\n\n"}
{"name":"IsCoveringMap.isSeparatedMap","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalSpace X\nf : E → X\nhf : IsCoveringMap f\n⊢ IsSeparatedMap f","decl":"protected theorem isSeparatedMap : IsSeparatedMap f :=\n  fun e₁ e₂ he hne ↦ by\n    obtain ⟨_, t, he₁⟩ := hf (f e₁)\n    have he₂ := he₁; simp_rw [he] at he₂; rw [← t.mem_source] at he₁ he₂\n    refine ⟨t.source ∩ (Prod.snd ∘ t) ⁻¹' {(t e₁).2}, t.source ∩ (Prod.snd ∘ t) ⁻¹' {(t e₂).2},\n      ?_, ?_, ⟨he₁, rfl⟩, ⟨he₂, rfl⟩, Set.disjoint_left.mpr fun x h₁ h₂ ↦ hne (t.injOn he₁ he₂ ?_)⟩\n    iterate 2\n      exact t.continuousOn_toFun.isOpen_inter_preimage t.open_source\n        (continuous_snd.isOpen_preimage _ <| isOpen_discrete _)\n    refine Prod.ext ?_ (h₁.2.symm.trans h₂.2)\n    rwa [t.proj_toFun e₁ he₁, t.proj_toFun e₂ he₂]\n\n"}
{"name":"IsCoveringMap.eq_of_comp_eq","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace E\ninst✝² : TopologicalSpace X\nf : E → X\nhf : IsCoveringMap f\nA : Type u_3\ninst✝¹ : TopologicalSpace A\ng₁ g₂ : A → E\ninst✝ : PreconnectedSpace A\nh₁ : Continuous g₁\nh₂ : Continuous g₂\nhe : Eq (Function.comp f g₁) (Function.comp f g₂)\na : A\nha : Eq (g₁ a) (g₂ a)\n⊢ Eq g₁ g₂","decl":"theorem eq_of_comp_eq [PreconnectedSpace A] (h₁ : Continuous g₁) (h₂ : Continuous g₂)\n    (he : f ∘ g₁ = f ∘ g₂) (a : A) (ha : g₁ a = g₂ a) : g₁ = g₂ :=\n  hf.isSeparatedMap.eq_of_comp_eq hf.isLocalHomeomorph.isLocallyInjective h₁ h₂ he a ha\n\n"}
{"name":"IsCoveringMap.const_of_comp","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace E\ninst✝² : TopologicalSpace X\nf : E → X\nhf : IsCoveringMap f\nA : Type u_3\ninst✝¹ : TopologicalSpace A\ng : A → E\ninst✝ : PreconnectedSpace A\ncont : Continuous g\nhe : ∀ (a a' : A), Eq (f (g a)) (f (g a'))\na a' : A\n⊢ Eq (g a) (g a')","decl":"theorem const_of_comp [PreconnectedSpace A] (cont : Continuous g)\n    (he : ∀ a a', f (g a) = f (g a')) (a a') : g a = g a' :=\n  hf.isSeparatedMap.const_of_comp hf.isLocalHomeomorph.isLocallyInjective cont he a a'\n\n"}
{"name":"IsCoveringMap.eqOn_of_comp_eqOn","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝² : TopologicalSpace E\ninst✝¹ : TopologicalSpace X\nf : E → X\nhf : IsCoveringMap f\nA : Type u_3\ninst✝ : TopologicalSpace A\ns : Set A\ng₁ g₂ : A → E\nhs : IsPreconnected s\nh₁ : ContinuousOn g₁ s\nh₂ : ContinuousOn g₂ s\nhe : Set.EqOn (Function.comp f g₁) (Function.comp f g₂) s\na : A\nhas : Membership.mem s a\nha : Eq (g₁ a) (g₂ a)\n⊢ Set.EqOn g₁ g₂ s","decl":"theorem eqOn_of_comp_eqOn (hs : IsPreconnected s) (h₁ : ContinuousOn g₁ s) (h₂ : ContinuousOn g₂ s)\n    (he : s.EqOn (f ∘ g₁) (f ∘ g₂)) {a : A} (has : a ∈ s) (ha : g₁ a = g₂ a) : s.EqOn g₁ g₂ :=\n  hf.isSeparatedMap.eqOn_of_comp_eqOn hf.isLocalHomeomorph.isLocallyInjective hs h₁ h₂ he has ha\n\n"}
{"name":"IsCoveringMap.constOn_of_comp","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝² : TopologicalSpace E\ninst✝¹ : TopologicalSpace X\nf : E → X\nhf : IsCoveringMap f\nA : Type u_3\ninst✝ : TopologicalSpace A\ns : Set A\ng : A → E\nhs : IsPreconnected s\ncont : ContinuousOn g s\nhe : ∀ (a : A), Membership.mem s a → ∀ (a' : A), Membership.mem s a' → Eq (f (g a)) (f (g a'))\na a' : A\nha : Membership.mem s a\nha' : Membership.mem s a'\n⊢ Eq (g a) (g a')","decl":"theorem constOn_of_comp (hs : IsPreconnected s) (cont : ContinuousOn g s)\n    (he : ∀ a ∈ s, ∀ a' ∈ s, f (g a) = f (g a'))\n    {a a'} (ha : a ∈ s) (ha' : a' ∈ s) : g a = g a' :=\n  hf.isSeparatedMap.constOn_of_comp hf.isLocalHomeomorph.isLocallyInjective hs cont he ha ha'\n\n"}
{"name":"IsFiberBundle.isCoveringMap","module":"Mathlib.Topology.Covering","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace E\ninst✝² : TopologicalSpace X\nf : E → X\nF : Type u_3\ninst✝¹ : TopologicalSpace F\ninst✝ : DiscreteTopology F\nhf : ∀ (x : X), Exists fun e => Membership.mem e.baseSet x\n⊢ IsCoveringMap f","decl":"protected theorem IsFiberBundle.isCoveringMap {F : Type*} [TopologicalSpace F] [DiscreteTopology F]\n    (hf : ∀ x : X, ∃ e : Trivialization F f, x ∈ e.baseSet) : IsCoveringMap f :=\n  IsCoveringMap.mk f (fun _ => F) (fun x => Classical.choose (hf x)) fun x =>\n    Classical.choose_spec (hf x)\n\n"}
{"name":"FiberBundle.isCoveringMap","module":"Mathlib.Topology.Covering","initialProofState":"X : Type u_2\ninst✝⁵ : TopologicalSpace X\nF : Type u_3\nE : X → Type u_4\ninst✝⁴ : TopologicalSpace F\ninst✝³ : DiscreteTopology F\ninst✝² : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹ : (x : X) → TopologicalSpace (E x)\ninst✝ : FiberBundle F E\n⊢ IsCoveringMap Bundle.TotalSpace.proj","decl":"protected theorem FiberBundle.isCoveringMap {F : Type*} {E : X → Type*} [TopologicalSpace F]\n    [DiscreteTopology F] [TopologicalSpace (Bundle.TotalSpace F E)] [∀ x, TopologicalSpace (E x)]\n    [FiberBundle F E] : IsCoveringMap (π F E) :=\n  IsFiberBundle.isCoveringMap fun x => ⟨trivializationAt F E x, mem_baseSet_trivializationAt F E x⟩\n"}
