{"name":"PrimeSpectrum.instNonemptyOfNontrivial","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\n⊢ Nonempty (PrimeSpectrum R)","decl":"instance [Nontrivial R] : Nonempty <| PrimeSpectrum R :=\n  let ⟨I, hI⟩ := Ideal.exists_maximal R\n  ⟨⟨I, hI.isPrime⟩⟩\n\n"}
{"name":"PrimeSpectrum.instIsEmptyOfSubsingleton","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : Subsingleton R\n⊢ IsEmpty (PrimeSpectrum R)","decl":"/-- The prime spectrum of the zero ring is empty. -/\ninstance [Subsingleton R] : IsEmpty (PrimeSpectrum R) :=\n  ⟨fun x ↦ x.isPrime.ne_top <| SetLike.ext' <| Subsingleton.eq_univ_of_nonempty x.asIdeal.nonempty⟩\n\n"}
{"name":"PrimeSpectrum.equivSubtype_symm_apply_asIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Subtype fun I => I.IsPrime\n⊢ Eq ((PrimeSpectrum.equivSubtype R).symm I).asIdeal ↑I","decl":"/-- The prime spectrum is in bijection with the set of prime ideals. -/\n@[simps]\ndef equivSubtype : PrimeSpectrum R ≃ {I : Ideal R // I.IsPrime} where\n  toFun I := ⟨I.asIdeal, I.2⟩\n  invFun I := ⟨I, I.2⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"PrimeSpectrum.equivSubtype_apply_coe","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : PrimeSpectrum R\n⊢ Eq (↑((PrimeSpectrum.equivSubtype R) I)) I.asIdeal","decl":"/-- The prime spectrum is in bijection with the set of prime ideals. -/\n@[simps]\ndef equivSubtype : PrimeSpectrum R ≃ {I : Ideal R // I.IsPrime} where\n  toFun I := ⟨I.asIdeal, I.2⟩\n  invFun I := ⟨I, I.2⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"PrimeSpectrum.range_asIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Eq (Set.range PrimeSpectrum.asIdeal) (setOf fun J => J.IsPrime)","decl":"theorem range_asIdeal : Set.range PrimeSpectrum.asIdeal = {J : Ideal R | J.IsPrime} :=\n  Set.ext fun J ↦\n    ⟨fun hJ ↦ let ⟨j, hj⟩ := Set.mem_range.mp hJ; Set.mem_setOf.mpr <| hj ▸ j.isPrime,\n      fun hJ ↦ Set.mem_range.mpr ⟨⟨J, Set.mem_setOf.mp hJ⟩, rfl⟩⟩\n\n"}
{"name":"PrimeSpectrum.primeSpectrumProd_symm_inl_asIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nx : PrimeSpectrum R\n⊢ Eq ((PrimeSpectrum.primeSpectrumProd R S).symm (Sum.inl x)).asIdeal (x.asIdeal.prod Top.top)","decl":"@[simp]\ntheorem primeSpectrumProd_symm_inl_asIdeal (x : PrimeSpectrum R) :\n    ((primeSpectrumProd R S).symm <| Sum.inl x).asIdeal = Ideal.prod x.asIdeal ⊤ := by\n  cases x\n  rfl\n\n"}
{"name":"PrimeSpectrum.primeSpectrumProd_symm_inr_asIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nx : PrimeSpectrum S\n⊢ Eq ((PrimeSpectrum.primeSpectrumProd R S).symm (Sum.inr x)).asIdeal (Top.top.prod x.asIdeal)","decl":"@[simp]\ntheorem primeSpectrumProd_symm_inr_asIdeal (x : PrimeSpectrum S) :\n    ((primeSpectrumProd R S).symm <| Sum.inr x).asIdeal = Ideal.prod ⊤ x.asIdeal := by\n  cases x\n  rfl\n\n"}
{"name":"PrimeSpectrum.mem_zeroLocus","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx : PrimeSpectrum R\ns : Set R\n⊢ Iff (Membership.mem (PrimeSpectrum.zeroLocus s) x) (HasSubset.Subset s ↑x.asIdeal)","decl":"@[simp]\ntheorem mem_zeroLocus (x : PrimeSpectrum R) (s : Set R) : x ∈ zeroLocus s ↔ s ⊆ x.asIdeal :=\n  Iff.rfl\n\n"}
{"name":"PrimeSpectrum.zeroLocus_span","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Set R\n⊢ Eq (PrimeSpectrum.zeroLocus ↑(Ideal.span s)) (PrimeSpectrum.zeroLocus s)","decl":"@[simp]\ntheorem zeroLocus_span (s : Set R) : zeroLocus (Ideal.span s : Set R) = zeroLocus s := by\n  ext x\n  exact (Submodule.gi R R).gc s x.asIdeal\n\n"}
{"name":"PrimeSpectrum.coe_vanishingIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nt : Set (PrimeSpectrum R)\n⊢ Eq (↑(PrimeSpectrum.vanishingIdeal t)) (setOf fun f => ∀ (x : PrimeSpectrum R), Membership.mem t x → Membership.mem x.asIdeal f)","decl":"theorem coe_vanishingIdeal (t : Set (PrimeSpectrum R)) :\n    (vanishingIdeal t : Set R) = { f : R | ∀ x ∈ t, f ∈ x.asIdeal } := by\n  ext f\n  rw [vanishingIdeal, SetLike.mem_coe, Submodule.mem_iInf]\n  apply forall_congr'; intro x\n  rw [Submodule.mem_iInf]\n\n"}
{"name":"PrimeSpectrum.mem_vanishingIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nt : Set (PrimeSpectrum R)\nf : R\n⊢ Iff (Membership.mem (PrimeSpectrum.vanishingIdeal t) f) (∀ (x : PrimeSpectrum R), Membership.mem t x → Membership.mem x.asIdeal f)","decl":"theorem mem_vanishingIdeal (t : Set (PrimeSpectrum R)) (f : R) :\n    f ∈ vanishingIdeal t ↔ ∀ x ∈ t, f ∈ x.asIdeal := by\n  rw [← SetLike.mem_coe, coe_vanishingIdeal, Set.mem_setOf_eq]\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_singleton","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx : PrimeSpectrum R\n⊢ Eq (PrimeSpectrum.vanishingIdeal (Singleton.singleton x)) x.asIdeal","decl":"@[simp]\ntheorem vanishingIdeal_singleton (x : PrimeSpectrum R) :\n    vanishingIdeal ({x} : Set (PrimeSpectrum R)) = x.asIdeal := by simp [vanishingIdeal]\n\n"}
{"name":"PrimeSpectrum.subset_zeroLocus_iff_le_vanishingIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nt : Set (PrimeSpectrum R)\nI : Ideal R\n⊢ Iff (HasSubset.Subset t (PrimeSpectrum.zeroLocus ↑I)) (LE.le I (PrimeSpectrum.vanishingIdeal t))","decl":"theorem subset_zeroLocus_iff_le_vanishingIdeal (t : Set (PrimeSpectrum R)) (I : Ideal R) :\n    t ⊆ zeroLocus I ↔ I ≤ vanishingIdeal t :=\n  ⟨fun h _ k => (mem_vanishingIdeal _ _).mpr fun _ j => (mem_zeroLocus _ _).mpr (h j) k, fun h =>\n    fun x j => (mem_zeroLocus _ _).mpr (le_trans h fun _ h => ((mem_vanishingIdeal _ _).mp h) x j)⟩\n\n"}
{"name":"PrimeSpectrum.gc","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ GaloisConnection (fun I => PrimeSpectrum.zeroLocus ↑I) fun t => PrimeSpectrum.vanishingIdeal t","decl":"/-- `zeroLocus` and `vanishingIdeal` form a galois connection. -/\ntheorem gc :\n    @GaloisConnection (Ideal R) (Set (PrimeSpectrum R))ᵒᵈ _ _ (fun I => zeroLocus I) fun t =>\n      vanishingIdeal t :=\n  fun I t => subset_zeroLocus_iff_le_vanishingIdeal t I\n\n"}
{"name":"PrimeSpectrum.gc_set","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ GaloisConnection (fun s => PrimeSpectrum.zeroLocus s) fun t => ↑(PrimeSpectrum.vanishingIdeal t)","decl":"/-- `zeroLocus` and `vanishingIdeal` form a galois connection. -/\ntheorem gc_set :\n    @GaloisConnection (Set R) (Set (PrimeSpectrum R))ᵒᵈ _ _ (fun s => zeroLocus s) fun t =>\n      vanishingIdeal t := by\n  have ideal_gc : GaloisConnection Ideal.span _ := (Submodule.gi R R).gc\n  simpa [zeroLocus_span, Function.comp_def] using ideal_gc.compose (gc R)\n\n"}
{"name":"PrimeSpectrum.subset_zeroLocus_iff_subset_vanishingIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nt : Set (PrimeSpectrum R)\ns : Set R\n⊢ Iff (HasSubset.Subset t (PrimeSpectrum.zeroLocus s)) (HasSubset.Subset s ↑(PrimeSpectrum.vanishingIdeal t))","decl":"theorem subset_zeroLocus_iff_subset_vanishingIdeal (t : Set (PrimeSpectrum R)) (s : Set R) :\n    t ⊆ zeroLocus s ↔ s ⊆ vanishingIdeal t :=\n  (gc_set R) s t\n\n"}
{"name":"PrimeSpectrum.subset_vanishingIdeal_zeroLocus","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Set R\n⊢ HasSubset.Subset s ↑(PrimeSpectrum.vanishingIdeal (PrimeSpectrum.zeroLocus s))","decl":"theorem subset_vanishingIdeal_zeroLocus (s : Set R) : s ⊆ vanishingIdeal (zeroLocus s) :=\n  (gc_set R).le_u_l s\n\n"}
{"name":"PrimeSpectrum.le_vanishingIdeal_zeroLocus","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ LE.le I (PrimeSpectrum.vanishingIdeal (PrimeSpectrum.zeroLocus ↑I))","decl":"theorem le_vanishingIdeal_zeroLocus (I : Ideal R) : I ≤ vanishingIdeal (zeroLocus I) :=\n  (gc R).le_u_l I\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_zeroLocus_eq_radical","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ Eq (PrimeSpectrum.vanishingIdeal (PrimeSpectrum.zeroLocus ↑I)) I.radical","decl":"@[simp]\ntheorem vanishingIdeal_zeroLocus_eq_radical (I : Ideal R) :\n    vanishingIdeal (zeroLocus (I : Set R)) = I.radical :=\n  Ideal.ext fun f => by\n    rw [mem_vanishingIdeal, Ideal.radical_eq_sInf, Submodule.mem_sInf]\n    exact ⟨fun h x hx => h ⟨x, hx.2⟩ hx.1, fun h x hx => h x.1 ⟨hx, x.2⟩⟩\n\n"}
{"name":"PrimeSpectrum.nilradical_eq_iInf","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Eq (nilradical R) (iInf PrimeSpectrum.asIdeal)","decl":"theorem nilradical_eq_iInf : nilradical R = iInf asIdeal := by\n  apply range_asIdeal R ▸ nilradical_eq_sInf R\n\n"}
{"name":"PrimeSpectrum.zeroLocus_radical","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ Eq (PrimeSpectrum.zeroLocus ↑I.radical) (PrimeSpectrum.zeroLocus ↑I)","decl":"@[simp]\ntheorem zeroLocus_radical (I : Ideal R) : zeroLocus (I.radical : Set R) = zeroLocus I :=\n  vanishingIdeal_zeroLocus_eq_radical I ▸ (gc R).l_u_l_eq_l I\n\n"}
{"name":"PrimeSpectrum.subset_zeroLocus_vanishingIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nt : Set (PrimeSpectrum R)\n⊢ HasSubset.Subset t (PrimeSpectrum.zeroLocus ↑(PrimeSpectrum.vanishingIdeal t))","decl":"theorem subset_zeroLocus_vanishingIdeal (t : Set (PrimeSpectrum R)) :\n    t ⊆ zeroLocus (vanishingIdeal t) :=\n  (gc R).l_u_le t\n\n"}
{"name":"PrimeSpectrum.zeroLocus_anti_mono","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns t : Set R\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (PrimeSpectrum.zeroLocus t) (PrimeSpectrum.zeroLocus s)","decl":"theorem zeroLocus_anti_mono {s t : Set R} (h : s ⊆ t) : zeroLocus t ⊆ zeroLocus s :=\n  (gc_set R).monotone_l h\n\n"}
{"name":"PrimeSpectrum.zeroLocus_anti_mono_ideal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns t : Ideal R\nh : LE.le s t\n⊢ HasSubset.Subset (PrimeSpectrum.zeroLocus ↑t) (PrimeSpectrum.zeroLocus ↑s)","decl":"theorem zeroLocus_anti_mono_ideal {s t : Ideal R} (h : s ≤ t) :\n    zeroLocus (t : Set R) ⊆ zeroLocus (s : Set R) :=\n  (gc R).monotone_l h\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_anti_mono","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns t : Set (PrimeSpectrum R)\nh : HasSubset.Subset s t\n⊢ LE.le (PrimeSpectrum.vanishingIdeal t) (PrimeSpectrum.vanishingIdeal s)","decl":"theorem vanishingIdeal_anti_mono {s t : Set (PrimeSpectrum R)} (h : s ⊆ t) :\n    vanishingIdeal t ≤ vanishingIdeal s :=\n  (gc R).monotone_u h\n\n"}
{"name":"PrimeSpectrum.zeroLocus_subset_zeroLocus_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\n⊢ Iff (HasSubset.Subset (PrimeSpectrum.zeroLocus ↑I) (PrimeSpectrum.zeroLocus ↑J)) (LE.le J I.radical)","decl":"theorem zeroLocus_subset_zeroLocus_iff (I J : Ideal R) :\n    zeroLocus (I : Set R) ⊆ zeroLocus (J : Set R) ↔ J ≤ I.radical := by\n  rw [subset_zeroLocus_iff_le_vanishingIdeal, vanishingIdeal_zeroLocus_eq_radical]\n\n"}
{"name":"PrimeSpectrum.zeroLocus_subset_zeroLocus_singleton_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf g : R\n⊢ Iff (HasSubset.Subset (PrimeSpectrum.zeroLocus (Singleton.singleton f)) (PrimeSpectrum.zeroLocus (Singleton.singleton g))) (Membership.mem (Ideal.span (Singleton.singleton f)).radical g)","decl":"theorem zeroLocus_subset_zeroLocus_singleton_iff (f g : R) :\n    zeroLocus ({f} : Set R) ⊆ zeroLocus {g} ↔ g ∈ (Ideal.span ({f} : Set R)).radical := by\n  rw [← zeroLocus_span {f}, ← zeroLocus_span {g}, zeroLocus_subset_zeroLocus_iff, Ideal.span_le,\n    Set.singleton_subset_iff, SetLike.mem_coe]\n\n"}
{"name":"PrimeSpectrum.zeroLocus_bot","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Eq (PrimeSpectrum.zeroLocus ↑Bot.bot) Set.univ","decl":"theorem zeroLocus_bot : zeroLocus ((⊥ : Ideal R) : Set R) = Set.univ :=\n  (gc R).l_bot\n\n"}
{"name":"PrimeSpectrum.zeroLocus_singleton_zero","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Eq (PrimeSpectrum.zeroLocus (Singleton.singleton 0)) Set.univ","decl":"@[simp]\ntheorem zeroLocus_singleton_zero : zeroLocus ({0} : Set R) = Set.univ :=\n  zeroLocus_bot\n\n"}
{"name":"PrimeSpectrum.zeroLocus_empty","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Eq (PrimeSpectrum.zeroLocus EmptyCollection.emptyCollection) Set.univ","decl":"@[simp]\ntheorem zeroLocus_empty : zeroLocus (∅ : Set R) = Set.univ :=\n  (gc_set R).l_bot\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_empty","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Eq (PrimeSpectrum.vanishingIdeal EmptyCollection.emptyCollection) Top.top","decl":"@[simp]\ntheorem vanishingIdeal_empty : vanishingIdeal (∅ : Set (PrimeSpectrum R)) = ⊤ := by\n  simpa using (gc R).u_top\n\n"}
{"name":"PrimeSpectrum.zeroLocus_empty_of_one_mem","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Set R\nh : Membership.mem s 1\n⊢ Eq (PrimeSpectrum.zeroLocus s) EmptyCollection.emptyCollection","decl":"theorem zeroLocus_empty_of_one_mem {s : Set R} (h : (1 : R) ∈ s) : zeroLocus s = ∅ := by\n  rw [Set.eq_empty_iff_forall_not_mem]\n  intro x hx\n  rw [mem_zeroLocus] at hx\n  have x_prime : x.asIdeal.IsPrime := by infer_instance\n  have eq_top : x.asIdeal = ⊤ := by\n    rw [Ideal.eq_top_iff_one]\n    exact hx h\n  apply x_prime.ne_top eq_top\n\n"}
{"name":"PrimeSpectrum.zeroLocus_singleton_one","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Eq (PrimeSpectrum.zeroLocus (Singleton.singleton 1)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem zeroLocus_singleton_one : zeroLocus ({1} : Set R) = ∅ :=\n  zeroLocus_empty_of_one_mem (Set.mem_singleton (1 : R))\n\n"}
{"name":"PrimeSpectrum.zeroLocus_empty_iff_eq_top","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ Iff (Eq (PrimeSpectrum.zeroLocus ↑I) EmptyCollection.emptyCollection) (Eq I Top.top)","decl":"theorem zeroLocus_empty_iff_eq_top {I : Ideal R} : zeroLocus (I : Set R) = ∅ ↔ I = ⊤ := by\n  constructor\n  · contrapose!\n    intro h\n    rcases Ideal.exists_le_maximal I h with ⟨M, hM, hIM⟩\n    exact ⟨⟨M, hM.isPrime⟩, hIM⟩\n  · rintro rfl\n    apply zeroLocus_empty_of_one_mem\n    trivial\n\n"}
{"name":"PrimeSpectrum.zeroLocus_univ","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Eq (PrimeSpectrum.zeroLocus Set.univ) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem zeroLocus_univ : zeroLocus (Set.univ : Set R) = ∅ :=\n  zeroLocus_empty_of_one_mem (Set.mem_univ 1)\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_eq_top_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Set (PrimeSpectrum R)\n⊢ Iff (Eq (PrimeSpectrum.vanishingIdeal s) Top.top) (Eq s EmptyCollection.emptyCollection)","decl":"theorem vanishingIdeal_eq_top_iff {s : Set (PrimeSpectrum R)} : vanishingIdeal s = ⊤ ↔ s = ∅ := by\n  rw [← top_le_iff, ← subset_zeroLocus_iff_le_vanishingIdeal, Submodule.top_coe, zeroLocus_univ,\n    Set.subset_empty_iff]\n\n"}
{"name":"PrimeSpectrum.zeroLocus_eq_top_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Set R\n⊢ Iff (Eq (PrimeSpectrum.zeroLocus s) Top.top) (HasSubset.Subset s ↑(nilradical R))","decl":"theorem zeroLocus_eq_top_iff (s : Set R) :\n    zeroLocus s = ⊤ ↔ s ⊆ nilradical R := by\n  constructor\n  · intro h x hx\n    refine nilpotent_iff_mem_prime.mpr (fun J hJ ↦ ?_)\n    have hJz : ⟨J, hJ⟩ ∈ zeroLocus s := by\n      rw [h]\n      trivial\n    exact (mem_zeroLocus _ _).mpr hJz hx\n  · rw [eq_top_iff]\n    intro h p _\n    apply Set.Subset.trans h (nilradical_le_prime p.asIdeal)\n\n"}
{"name":"PrimeSpectrum.zeroLocus_sup","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\n⊢ Eq (PrimeSpectrum.zeroLocus ↑(Max.max I J)) (Inter.inter (PrimeSpectrum.zeroLocus ↑I) (PrimeSpectrum.zeroLocus ↑J))","decl":"theorem zeroLocus_sup (I J : Ideal R) :\n    zeroLocus ((I ⊔ J : Ideal R) : Set R) = zeroLocus I ∩ zeroLocus J :=\n  (gc R).l_sup\n\n"}
{"name":"PrimeSpectrum.zeroLocus_union","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns s' : Set R\n⊢ Eq (PrimeSpectrum.zeroLocus (Union.union s s')) (Inter.inter (PrimeSpectrum.zeroLocus s) (PrimeSpectrum.zeroLocus s'))","decl":"theorem zeroLocus_union (s s' : Set R) : zeroLocus (s ∪ s') = zeroLocus s ∩ zeroLocus s' :=\n  (gc_set R).l_sup\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_union","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nt t' : Set (PrimeSpectrum R)\n⊢ Eq (PrimeSpectrum.vanishingIdeal (Union.union t t')) (Min.min (PrimeSpectrum.vanishingIdeal t) (PrimeSpectrum.vanishingIdeal t'))","decl":"theorem vanishingIdeal_union (t t' : Set (PrimeSpectrum R)) :\n    vanishingIdeal (t ∪ t') = vanishingIdeal t ⊓ vanishingIdeal t' :=\n  (gc R).u_inf\n\n"}
{"name":"PrimeSpectrum.zeroLocus_iSup","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nι : Sort u_1\nI : ι → Ideal R\n⊢ Eq (PrimeSpectrum.zeroLocus ↑(iSup fun i => I i)) (Set.iInter fun i => PrimeSpectrum.zeroLocus ↑(I i))","decl":"theorem zeroLocus_iSup {ι : Sort*} (I : ι → Ideal R) :\n    zeroLocus ((⨆ i, I i : Ideal R) : Set R) = ⋂ i, zeroLocus (I i) :=\n  (gc R).l_iSup\n\n"}
{"name":"PrimeSpectrum.zeroLocus_iUnion","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nι : Sort u_1\ns : ι → Set R\n⊢ Eq (PrimeSpectrum.zeroLocus (Set.iUnion fun i => s i)) (Set.iInter fun i => PrimeSpectrum.zeroLocus (s i))","decl":"theorem zeroLocus_iUnion {ι : Sort*} (s : ι → Set R) :\n    zeroLocus (⋃ i, s i) = ⋂ i, zeroLocus (s i) :=\n  (gc_set R).l_iSup\n\n"}
{"name":"PrimeSpectrum.zeroLocus_iUnion₂","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nι : Sort u_1\nκ : ι → Sort u_2\ns : (i : ι) → κ i → Set R\n⊢ Eq (PrimeSpectrum.zeroLocus (Set.iUnion fun i => Set.iUnion fun j => s i j)) (Set.iInter fun i => Set.iInter fun j => PrimeSpectrum.zeroLocus (s i j))","decl":"theorem zeroLocus_iUnion₂ {ι : Sort*} {κ : (i : ι) → Sort*} (s : ∀ i, κ i → Set R) :\n    zeroLocus (⋃ (i) (j), s i j) = ⋂ (i) (j), zeroLocus (s i j) :=\n  (gc_set R).l_iSup₂\n\n"}
{"name":"PrimeSpectrum.zeroLocus_bUnion","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Set (Set R)\n⊢ Eq (PrimeSpectrum.zeroLocus (Set.iUnion fun s' => Set.iUnion fun h => s')) (Set.iInter fun s' => Set.iInter fun h => PrimeSpectrum.zeroLocus s')","decl":"theorem zeroLocus_bUnion (s : Set (Set R)) :\n    zeroLocus (⋃ s' ∈ s, s' : Set R) = ⋂ s' ∈ s, zeroLocus s' := by simp only [zeroLocus_iUnion]\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_iUnion","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nι : Sort u_1\nt : ι → Set (PrimeSpectrum R)\n⊢ Eq (PrimeSpectrum.vanishingIdeal (Set.iUnion fun i => t i)) (iInf fun i => PrimeSpectrum.vanishingIdeal (t i))","decl":"theorem vanishingIdeal_iUnion {ι : Sort*} (t : ι → Set (PrimeSpectrum R)) :\n    vanishingIdeal (⋃ i, t i) = ⨅ i, vanishingIdeal (t i) :=\n  (gc R).u_iInf\n\n"}
{"name":"PrimeSpectrum.zeroLocus_inf","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\n⊢ Eq (PrimeSpectrum.zeroLocus ↑(Min.min I J)) (Union.union (PrimeSpectrum.zeroLocus ↑I) (PrimeSpectrum.zeroLocus ↑J))","decl":"theorem zeroLocus_inf (I J : Ideal R) :\n    zeroLocus ((I ⊓ J : Ideal R) : Set R) = zeroLocus I ∪ zeroLocus J :=\n  Set.ext fun x => x.2.inf_le\n\n"}
{"name":"PrimeSpectrum.union_zeroLocus","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns s' : Set R\n⊢ Eq (Union.union (PrimeSpectrum.zeroLocus s) (PrimeSpectrum.zeroLocus s')) (PrimeSpectrum.zeroLocus ↑(Min.min (Ideal.span s) (Ideal.span s')))","decl":"theorem union_zeroLocus (s s' : Set R) :\n    zeroLocus s ∪ zeroLocus s' = zeroLocus (Ideal.span s ⊓ Ideal.span s' : Ideal R) := by\n  rw [zeroLocus_inf]\n  simp\n\n"}
{"name":"PrimeSpectrum.zeroLocus_mul","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\n⊢ Eq (PrimeSpectrum.zeroLocus ↑(HMul.hMul I J)) (Union.union (PrimeSpectrum.zeroLocus ↑I) (PrimeSpectrum.zeroLocus ↑J))","decl":"theorem zeroLocus_mul (I J : Ideal R) :\n    zeroLocus ((I * J : Ideal R) : Set R) = zeroLocus I ∪ zeroLocus J :=\n  Set.ext fun x => x.2.mul_le\n\n"}
{"name":"PrimeSpectrum.zeroLocus_singleton_mul","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf g : R\n⊢ Eq (PrimeSpectrum.zeroLocus (Singleton.singleton (HMul.hMul f g))) (Union.union (PrimeSpectrum.zeroLocus (Singleton.singleton f)) (PrimeSpectrum.zeroLocus (Singleton.singleton g)))","decl":"theorem zeroLocus_singleton_mul (f g : R) :\n    zeroLocus ({f * g} : Set R) = zeroLocus {f} ∪ zeroLocus {g} :=\n  Set.ext fun x => by simpa using x.2.mul_mem_iff_mem_or_mem\n\n"}
{"name":"PrimeSpectrum.zeroLocus_pow","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\nn : Nat\nhn : Ne n 0\n⊢ Eq (PrimeSpectrum.zeroLocus ↑(HPow.hPow I n)) (PrimeSpectrum.zeroLocus ↑I)","decl":"@[simp]\ntheorem zeroLocus_pow (I : Ideal R) {n : ℕ} (hn : n ≠ 0) :\n    zeroLocus ((I ^ n : Ideal R) : Set R) = zeroLocus I :=\n  zeroLocus_radical (I ^ n) ▸ (I.radical_pow hn).symm ▸ zeroLocus_radical I\n\n"}
{"name":"PrimeSpectrum.zeroLocus_singleton_pow","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf : R\nn : Nat\nhn : LT.lt 0 n\n⊢ Eq (PrimeSpectrum.zeroLocus (Singleton.singleton (HPow.hPow f n))) (PrimeSpectrum.zeroLocus (Singleton.singleton f))","decl":"@[simp]\ntheorem zeroLocus_singleton_pow (f : R) (n : ℕ) (hn : 0 < n) :\n    zeroLocus ({f ^ n} : Set R) = zeroLocus {f} :=\n  Set.ext fun x => by simpa using x.2.pow_mem_iff_mem n hn\n\n"}
{"name":"PrimeSpectrum.sup_vanishingIdeal_le","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nt t' : Set (PrimeSpectrum R)\n⊢ LE.le (Max.max (PrimeSpectrum.vanishingIdeal t) (PrimeSpectrum.vanishingIdeal t')) (PrimeSpectrum.vanishingIdeal (Inter.inter t t'))","decl":"theorem sup_vanishingIdeal_le (t t' : Set (PrimeSpectrum R)) :\n    vanishingIdeal t ⊔ vanishingIdeal t' ≤ vanishingIdeal (t ∩ t') := by\n  intro r\n  rw [Submodule.mem_sup, mem_vanishingIdeal]\n  rintro ⟨f, hf, g, hg, rfl⟩ x ⟨hxt, hxt'⟩\n  rw [mem_vanishingIdeal] at hf hg\n  apply Submodule.add_mem <;> solve_by_elim\n\n"}
{"name":"PrimeSpectrum.mem_compl_zeroLocus_iff_not_mem","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf : R\nI : PrimeSpectrum R\n⊢ Iff (Membership.mem (HasCompl.compl (PrimeSpectrum.zeroLocus (Singleton.singleton f))) I) (Not (Membership.mem I.asIdeal f))","decl":"theorem mem_compl_zeroLocus_iff_not_mem {f : R} {I : PrimeSpectrum R} :\n    I ∈ (zeroLocus {f} : Set (PrimeSpectrum R))ᶜ ↔ f ∉ I.asIdeal := by\n  rw [Set.mem_compl_iff, mem_zeroLocus, Set.singleton_subset_iff]; rfl\n\n"}
{"name":"PrimeSpectrum.zeroLocus_insert_zero","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Set R\n⊢ Eq (PrimeSpectrum.zeroLocus (Insert.insert 0 s)) (PrimeSpectrum.zeroLocus s)","decl":"@[simp]\nlemma zeroLocus_insert_zero (s : Set R) : zeroLocus (insert 0 s) = zeroLocus s := by\n  rw [← Set.union_singleton, zeroLocus_union, zeroLocus_singleton_zero, Set.inter_univ]\n\n"}
{"name":"PrimeSpectrum.zeroLocus_diff_singleton_zero","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Set R\n⊢ Eq (PrimeSpectrum.zeroLocus (SDiff.sdiff s (Singleton.singleton 0))) (PrimeSpectrum.zeroLocus s)","decl":"@[simp]\nlemma zeroLocus_diff_singleton_zero (s : Set R) : zeroLocus (s \\ {0}) = zeroLocus s := by\n  rw [← zeroLocus_insert_zero, ← zeroLocus_insert_zero (s := s)]; simp\n\n"}
{"name":"PrimeSpectrum.zeroLocus_smul_of_isUnit","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nr : R\nhr : IsUnit r\ns : Set R\n⊢ Eq (PrimeSpectrum.zeroLocus (HSMul.hSMul r s)) (PrimeSpectrum.zeroLocus s)","decl":"lemma zeroLocus_smul_of_isUnit {r : R} (hr : IsUnit r) (s : Set R) :\n    zeroLocus (r • s) = zeroLocus s := by\n  ext; simp [Set.subset_def, ← Set.image_smul, Ideal.unit_mul_mem_iff_mem _ hr]\n\n"}
{"name":"PrimeSpectrum.asIdeal_le_asIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y : PrimeSpectrum R\n⊢ Iff (LE.le x.asIdeal y.asIdeal) (LE.le x y)","decl":"@[simp]\ntheorem asIdeal_le_asIdeal (x y : PrimeSpectrum R) : x.asIdeal ≤ y.asIdeal ↔ x ≤ y :=\n  Iff.rfl\n\n"}
{"name":"PrimeSpectrum.asIdeal_lt_asIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y : PrimeSpectrum R\n⊢ Iff (LT.lt x.asIdeal y.asIdeal) (LT.lt x y)","decl":"@[simp]\ntheorem asIdeal_lt_asIdeal (x y : PrimeSpectrum R) : x.asIdeal < y.asIdeal ↔ x < y :=\n  Iff.rfl\n\n"}
{"name":"PrimeSpectrum.exists_primeSpectrum_prod_le","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsNoetherianRing R\nI : Ideal R\n⊢ Exists fun Z => LE.le (Multiset.map PrimeSpectrum.asIdeal Z).prod I","decl":"/-- In a noetherian ring, every ideal contains a product of prime ideals\n([samuel, § 3.3, Lemma 3])-/\ntheorem exists_primeSpectrum_prod_le (I : Ideal R) :\n    ∃ Z : Multiset (PrimeSpectrum R), Multiset.prod (Z.map asIdeal) ≤ I := by\n  -- Porting note: Need to specify `P` explicitly\n  refine IsNoetherian.induction\n    (P := fun I => ∃ Z : Multiset (PrimeSpectrum R), Multiset.prod (Z.map asIdeal) ≤ I)\n    (fun (M : Ideal R) hgt => ?_) I\n  by_cases h_prM : M.IsPrime\n  · use {⟨M, h_prM⟩}\n    rw [Multiset.map_singleton, Multiset.prod_singleton]\n  by_cases htop : M = ⊤\n  · rw [htop]\n    exact ⟨0, le_top⟩\n  have lt_add : ∀ z ∉ M, M < M + span R {z} := by\n    intro z hz\n    refine lt_of_le_of_ne le_sup_left fun m_eq => hz ?_\n    rw [m_eq]\n    exact Ideal.mem_sup_right (mem_span_singleton_self z)\n  obtain ⟨x, hx, y, hy, hxy⟩ := (Ideal.not_isPrime_iff.mp h_prM).resolve_left htop\n  obtain ⟨Wx, h_Wx⟩ := hgt (M + span R {x}) (lt_add _ hx)\n  obtain ⟨Wy, h_Wy⟩ := hgt (M + span R {y}) (lt_add _ hy)\n  use Wx + Wy\n  rw [Multiset.map_add, Multiset.prod_add]\n  apply le_trans (Submodule.mul_le_mul h_Wx h_Wy)\n  rw [add_mul]\n  apply sup_le (show M * (M + span R {y}) ≤ M from Ideal.mul_le_right)\n  rw [mul_add]\n  apply sup_le (show span R {x} * M ≤ M from Ideal.mul_le_left)\n  rwa [span_mul_span, Set.singleton_mul_singleton, span_singleton_le_iff_mem]\n\n"}
{"name":"PrimeSpectrum.exists_primeSpectrum_prod_le_and_ne_bot_of_domain","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"A : Type u\ninst✝² : CommRing A\ninst✝¹ : IsDomain A\ninst✝ : IsNoetherianRing A\nh_fA : Not (IsField A)\nI : Ideal A\nh_nzI : Ne I Bot.bot\n⊢ Exists fun Z => And (LE.le (Multiset.map PrimeSpectrum.asIdeal Z).prod I) (Ne (Multiset.map PrimeSpectrum.asIdeal Z).prod Bot.bot)","decl":"/-- In a noetherian integral domain which is not a field, every non-zero ideal contains a non-zero\n  product of prime ideals; in a field, the whole ring is a non-zero ideal containing only 0 as\n  product or prime ideals ([samuel, § 3.3, Lemma 3]) -/\ntheorem exists_primeSpectrum_prod_le_and_ne_bot_of_domain (h_fA : ¬IsField A) {I : Ideal A}\n    (h_nzI : I ≠ ⊥) :\n    ∃ Z : Multiset (PrimeSpectrum A),\n      Multiset.prod (Z.map asIdeal) ≤ I ∧ Multiset.prod (Z.map asIdeal) ≠ ⊥ := by\n  revert h_nzI\n  -- Porting note: Need to specify `P` explicitly\n  refine IsNoetherian.induction (P := fun I => I ≠ ⊥ → ∃ Z : Multiset (PrimeSpectrum A),\n      Multiset.prod (Z.map asIdeal) ≤ I ∧ Multiset.prod (Z.map asIdeal) ≠ ⊥)\n    (fun (M : Ideal A) hgt => ?_) I\n  intro h_nzM\n  have hA_nont : Nontrivial A := IsDomain.toNontrivial\n  by_cases h_topM : M = ⊤\n  · rcases h_topM with rfl\n    obtain ⟨p_id, h_nzp, h_pp⟩ : ∃ p : Ideal A, p ≠ ⊥ ∧ p.IsPrime := by\n      apply Ring.not_isField_iff_exists_prime.mp h_fA\n    use ({⟨p_id, h_pp⟩} : Multiset (PrimeSpectrum A)), le_top\n    rwa [Multiset.map_singleton, Multiset.prod_singleton]\n  by_cases h_prM : M.IsPrime\n  · use ({⟨M, h_prM⟩} : Multiset (PrimeSpectrum A))\n    rw [Multiset.map_singleton, Multiset.prod_singleton]\n    exact ⟨le_rfl, h_nzM⟩\n  obtain ⟨x, hx, y, hy, h_xy⟩ := (Ideal.not_isPrime_iff.mp h_prM).resolve_left h_topM\n  have lt_add : ∀ z ∉ M, M < M + span A {z} := by\n    intro z hz\n    refine lt_of_le_of_ne le_sup_left fun m_eq => hz ?_\n    rw [m_eq]\n    exact mem_sup_right (mem_span_singleton_self z)\n  obtain ⟨Wx, h_Wx_le, h_Wx_ne⟩ := hgt (M + span A {x}) (lt_add _ hx) (ne_bot_of_gt (lt_add _ hx))\n  obtain ⟨Wy, h_Wy_le, h_Wx_ne⟩ := hgt (M + span A {y}) (lt_add _ hy) (ne_bot_of_gt (lt_add _ hy))\n  use Wx + Wy\n  rw [Multiset.map_add, Multiset.prod_add]\n  refine ⟨le_trans (Submodule.mul_le_mul h_Wx_le h_Wy_le) ?_, mt Ideal.mul_eq_bot.mp ?_⟩\n  · rw [add_mul]\n    apply sup_le (show M * (M + span A {y}) ≤ M from Ideal.mul_le_right)\n    rw [mul_add]\n    apply sup_le (show span A {x} * M ≤ M from Ideal.mul_le_left)\n    rwa [span_mul_span, Set.singleton_mul_singleton, span_singleton_le_iff_mem]\n  · rintro (hx | hy) <;> contradiction\n\n"}
{"name":"PrimeSpectrum.preimage_specComap_zeroLocus_aux","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\ns : Set R\n⊢ Eq (Set.preimage f.specComap (PrimeSpectrum.zeroLocus s)) (PrimeSpectrum.zeroLocus (Set.image (⇑f) s))","decl":"theorem preimage_specComap_zeroLocus_aux (f : R →+* S) (s : Set R) :\n    f.specComap ⁻¹' zeroLocus s = zeroLocus (f '' s) := by\n  ext x\n  simp only [mem_zeroLocus, Set.image_subset_iff, Set.mem_preimage, mem_zeroLocus, Ideal.coe_comap]\n\n"}
{"name":"PrimeSpectrum.specComap_asIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\ny : PrimeSpectrum S\n⊢ Eq (f.specComap y).asIdeal (Ideal.comap f y.asIdeal)","decl":"@[simp]\ntheorem specComap_asIdeal (y : PrimeSpectrum S) :\n    (f.specComap y).asIdeal = Ideal.comap f y.asIdeal :=\n  rfl\n\n"}
{"name":"PrimeSpectrum.specComap_id","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Eq (RingHom.id R).specComap fun x => x","decl":"@[simp]\ntheorem specComap_id : (RingHom.id R).specComap = fun x => x :=\n  rfl\n\n"}
{"name":"PrimeSpectrum.specComap_comp","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\nS' : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : CommSemiring S'\nf : RingHom R S\ng : RingHom S S'\n⊢ Eq (g.comp f).specComap (Function.comp f.specComap g.specComap)","decl":"@[simp]\ntheorem specComap_comp (f : R →+* S) (g : S →+* S') :\n    (g.comp f).specComap = f.specComap.comp g.specComap :=\n  rfl\n\n"}
{"name":"PrimeSpectrum.specComap_comp_apply","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\nS' : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : CommSemiring S'\nf : RingHom R S\ng : RingHom S S'\nx : PrimeSpectrum S'\n⊢ Eq ((g.comp f).specComap x) (f.specComap (g.specComap x))","decl":"theorem specComap_comp_apply (f : R →+* S) (g : S →+* S') (x : PrimeSpectrum S') :\n    (g.comp f).specComap x = f.specComap (g.specComap x) :=\n  rfl\n\n"}
{"name":"PrimeSpectrum.preimage_specComap_zeroLocus","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\ns : Set R\n⊢ Eq (Set.preimage f.specComap (PrimeSpectrum.zeroLocus s)) (PrimeSpectrum.zeroLocus (Set.image (⇑f) s))","decl":"@[simp]\ntheorem preimage_specComap_zeroLocus (s : Set R) :\n    f.specComap ⁻¹' zeroLocus s = zeroLocus (f '' s) :=\n  preimage_specComap_zeroLocus_aux f s\n\n"}
{"name":"PrimeSpectrum.specComap_injective_of_surjective","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\nhf : Function.Surjective ⇑f\n⊢ Function.Injective f.specComap","decl":"theorem specComap_injective_of_surjective (f : R →+* S) (hf : Function.Surjective f) :\n    Function.Injective f.specComap := fun x y h =>\n  PrimeSpectrum.ext\n    (Ideal.comap_injective_of_surjective f hf\n      (congr_arg PrimeSpectrum.asIdeal h : (f.specComap x).asIdeal = (f.specComap y).asIdeal))\n\n"}
{"name":"PrimeSpectrum.comapEquiv_apply","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\ne : RingEquiv R S\na✝ : PrimeSpectrum R\n⊢ Eq ((PrimeSpectrum.comapEquiv e) a✝) (e.symm.toRingHom.specComap a✝)","decl":"/-- `RingHom.specComap` of an isomorphism of rings as an equivalence of their prime spectra. -/\n@[simps apply symm_apply]\ndef comapEquiv (e : R ≃+* S) : PrimeSpectrum R ≃ PrimeSpectrum S where\n  toFun := e.symm.toRingHom.specComap\n  invFun := e.toRingHom.specComap\n  left_inv x := by\n    rw [← specComap_comp_apply, RingEquiv.toRingHom_eq_coe,\n      RingEquiv.toRingHom_eq_coe, RingEquiv.symm_comp]\n    rfl\n  right_inv x := by\n    rw [← specComap_comp_apply, RingEquiv.toRingHom_eq_coe,\n      RingEquiv.toRingHom_eq_coe, RingEquiv.comp_symm]\n    rfl\n\n"}
{"name":"PrimeSpectrum.comapEquiv_symm_apply","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\ne : RingEquiv R S\na✝ : PrimeSpectrum S\n⊢ Eq ((PrimeSpectrum.comapEquiv e).symm a✝) (e.toRingHom.specComap a✝)","decl":"/-- `RingHom.specComap` of an isomorphism of rings as an equivalence of their prime spectra. -/\n@[simps apply symm_apply]\ndef comapEquiv (e : R ≃+* S) : PrimeSpectrum R ≃ PrimeSpectrum S where\n  toFun := e.symm.toRingHom.specComap\n  invFun := e.toRingHom.specComap\n  left_inv x := by\n    rw [← specComap_comp_apply, RingEquiv.toRingHom_eq_coe,\n      RingEquiv.toRingHom_eq_coe, RingEquiv.symm_comp]\n    rfl\n  right_inv x := by\n    rw [← specComap_comp_apply, RingEquiv.toRingHom_eq_coe,\n      RingEquiv.toRingHom_eq_coe, RingEquiv.comp_symm]\n    rfl\n\n"}
{"name":"PrimeSpectrum.sigmaToPi_asIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"ι : Type u_3\nR : ι → Type u_2\ninst✝ : (i : ι) → CommSemiring (R i)\na✝ : Sigma fun i => PrimeSpectrum (R i)\n⊢ Eq (PrimeSpectrum.sigmaToPi R a✝).asIdeal (Ideal.comap (Pi.evalRingHom R a✝.fst) a✝.snd.asIdeal)","decl":"/-- The canonical map from a disjoint union of prime spectra of commutative semirings to\nthe prime spectrum of the product semiring. -/\n/- TODO: show this is always a topological embedding (even when ι is infinite)\nand is a homeomorphism when ι is finite. -/\n@[simps] def sigmaToPi : (Σ i, PrimeSpectrum (R i)) → PrimeSpectrum (Π i, R i)\n  | ⟨i, p⟩ => (Pi.evalRingHom R i).specComap p\n\n"}
{"name":"PrimeSpectrum.sigmaToPi_injective","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"ι : Type u_3\nR : ι → Type u_2\ninst✝ : (i : ι) → CommSemiring (R i)\n⊢ Function.Injective (PrimeSpectrum.sigmaToPi R)","decl":"theorem sigmaToPi_injective : (sigmaToPi R).Injective := fun ⟨i, p⟩ ⟨j, q⟩ eq ↦ by\n  classical\n  obtain rfl | ne := eq_or_ne i j\n  · congr; ext x\n    simpa using congr_arg (Function.update (0 : ∀ i, R i) i x ∈ ·.asIdeal) eq\n  · refine (p.1.ne_top_iff_one.mp p.2.ne_top ?_).elim\n    have : Function.update (1 : ∀ i, R i) j 0 ∈ (sigmaToPi R ⟨j, q⟩).asIdeal := by simp\n    simpa [← eq, Function.update_of_ne ne]\n\n"}
{"name":"PrimeSpectrum.exists_maximal_nmem_range_sigmaToPi_of_infinite","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"ι : Type u_3\nR : ι → Type u_2\ninst✝² : (i : ι) → CommSemiring (R i)\ninst✝¹ : Infinite ι\ninst✝ : ∀ (i : ι), Nontrivial (R i)\n⊢ Exists fun I => Exists fun x => Not (Membership.mem (Set.range (PrimeSpectrum.sigmaToPi R)) { asIdeal := I, isPrime := ⋯ })","decl":"/-- An infinite product of nontrivial commutative semirings has a maximal ideal outside of the\nrange of `sigmaToPi`, i.e. is not of the form `πᵢ⁻¹(𝔭)` for some prime `𝔭 ⊂ R i`, where\n`πᵢ : (Π i, R i) →+* R i` is the projection. For a complete description of all prime ideals,\nsee https://math.stackexchange.com/a/1563190. -/\ntheorem exists_maximal_nmem_range_sigmaToPi_of_infinite :\n    ∃ (I : Ideal (Π i, R i)) (_ : I.IsMaximal), ⟨I, inferInstance⟩ ∉ Set.range (sigmaToPi R) := by\n  classical\n  let J : Ideal (Π i, R i) := -- `J := Π₀ i, R i` is an ideal in `Π i, R i`\n  { __ := AddMonoidHom.mrange DFinsupp.coeFnAddMonoidHom\n    smul_mem' := by\n      rintro r _ ⟨x, rfl⟩\n      refine ⟨.mk x.support fun i ↦ r i * x i, funext fun i ↦ show dite _ _ _ = _ from ?_⟩\n      simp_rw [DFinsupp.coeFnAddMonoidHom]\n      refine dite_eq_left_iff.mpr fun h ↦ ?_\n      rw [DFinsupp.not_mem_support_iff.mp h, mul_zero] }\n  have ⟨I, max, le⟩ := J.exists_le_maximal <| (Ideal.ne_top_iff_one _).mpr <| by\n    -- take a maximal ideal I containing J\n    rintro ⟨x, hx⟩\n    have ⟨i, hi⟩ := x.support.exists_not_mem\n    simpa [DFinsupp.coeFnAddMonoidHom, DFinsupp.not_mem_support_iff.mp hi] using congr_fun hx i\n  refine ⟨I, max, fun ⟨⟨i, p⟩, eq⟩ ↦ ?_⟩\n  -- then I is not in the range of `sigmaToPi`\n  have : ⇑(DFinsupp.single i 1) ∉ (sigmaToPi R ⟨i, p⟩).asIdeal := by\n    simpa using p.1.ne_top_iff_one.mp p.2.ne_top\n  rw [eq] at this\n  exact this (le ⟨.single i 1, rfl⟩)\n\n"}
{"name":"PrimeSpectrum.sigmaToPi_not_surjective_of_infinite","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"ι : Type u_3\nR : ι → Type u_2\ninst✝² : (i : ι) → CommSemiring (R i)\ninst✝¹ : Infinite ι\ninst✝ : ∀ (i : ι), Nontrivial (R i)\n⊢ Not (Function.Surjective (PrimeSpectrum.sigmaToPi R))","decl":"theorem sigmaToPi_not_surjective_of_infinite : ¬ (sigmaToPi R).Surjective := fun surj ↦\n  have ⟨_, _, nmem⟩ := exists_maximal_nmem_range_sigmaToPi_of_infinite R\n  (Set.range_eq_univ.mpr surj ▸ nmem) ⟨⟩\n\n"}
{"name":"image_specComap_zeroLocus_eq_zeroLocus_comap","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : Function.Surjective ⇑f\nI : Ideal S\n⊢ Eq (Set.image f.specComap (PrimeSpectrum.zeroLocus ↑I)) (PrimeSpectrum.zeroLocus ↑(Ideal.comap f I))","decl":"theorem image_specComap_zeroLocus_eq_zeroLocus_comap (hf : Surjective f) (I : Ideal S) :\n    f.specComap '' zeroLocus I = zeroLocus (I.comap f) := by\n  simp only [Set.ext_iff, Set.mem_image, mem_zeroLocus, SetLike.coe_subset_coe]\n  refine fun p => ⟨?_, fun h_I_p => ?_⟩\n  · rintro ⟨p, hp, rfl⟩ a ha\n    exact hp ha\n  · have hp : ker f ≤ p.asIdeal := (Ideal.comap_mono bot_le).trans h_I_p\n    refine ⟨⟨p.asIdeal.map f, Ideal.map_isPrime_of_surjective hf hp⟩, fun x hx => ?_, ?_⟩\n    · obtain ⟨x', rfl⟩ := hf x\n      exact Ideal.mem_map_of_mem f (h_I_p hx)\n    · ext x\n      rw [specComap_asIdeal, Ideal.mem_comap, Ideal.mem_map_iff_of_surjective f hf]\n      refine ⟨?_, fun hx => ⟨x, hx, rfl⟩⟩\n      rintro ⟨x', hx', heq⟩\n      rw [← sub_sub_cancel x' x]\n      refine p.asIdeal.sub_mem hx' (hp ?_)\n      rwa [mem_ker, map_sub, sub_eq_zero]\n\n"}
{"name":"range_specComap_of_surjective","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : Function.Surjective ⇑f\n⊢ Eq (Set.range f.specComap) (PrimeSpectrum.zeroLocus ↑(RingHom.ker f))","decl":"theorem range_specComap_of_surjective (hf : Surjective f) :\n    Set.range f.specComap = zeroLocus (ker f) := by\n  rw [← Set.image_univ]\n  convert image_specComap_zeroLocus_eq_zeroLocus_comap _ _ hf _\n  rw [zeroLocus_bot]\n\n"}
