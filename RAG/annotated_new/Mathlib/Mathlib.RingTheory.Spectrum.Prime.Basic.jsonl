{"name":"PrimeSpectrum.instNonemptyOfNontrivial","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù¬π : CommSemiring R\ninst‚úù : Nontrivial R\n‚ä¢ Nonempty (PrimeSpectrum R)","decl":"instance [Nontrivial R] : Nonempty <| PrimeSpectrum R :=\n  let ‚ü®I, hI‚ü© := Ideal.exists_maximal R\n  ‚ü®‚ü®I, hI.isPrime‚ü©‚ü©\n\n"}
{"name":"PrimeSpectrum.instIsEmptyOfSubsingleton","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù¬π : CommSemiring R\ninst‚úù : Subsingleton R\n‚ä¢ IsEmpty (PrimeSpectrum R)","decl":"/-- The prime spectrum of the zero ring is empty. -/\ninstance [Subsingleton R] : IsEmpty (PrimeSpectrum R) :=\n  ‚ü®fun x ‚Ü¶ x.isPrime.ne_top <| SetLike.ext' <| Subsingleton.eq_univ_of_nonempty x.asIdeal.nonempty‚ü©\n\n"}
{"name":"PrimeSpectrum.equivSubtype_symm_apply_asIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nI : Subtype fun I => I.IsPrime\n‚ä¢ Eq ((PrimeSpectrum.equivSubtype R).symm I).asIdeal ‚ÜëI","decl":"/-- The prime spectrum is in bijection with the set of prime ideals. -/\n@[simps]\ndef equivSubtype : PrimeSpectrum R ‚âÉ {I : Ideal R // I.IsPrime} where\n  toFun I := ‚ü®I.asIdeal, I.2‚ü©\n  invFun I := ‚ü®I, I.2‚ü©\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"PrimeSpectrum.equivSubtype_apply_coe","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nI : PrimeSpectrum R\n‚ä¢ Eq (‚Üë((PrimeSpectrum.equivSubtype R) I)) I.asIdeal","decl":"/-- The prime spectrum is in bijection with the set of prime ideals. -/\n@[simps]\ndef equivSubtype : PrimeSpectrum R ‚âÉ {I : Ideal R // I.IsPrime} where\n  toFun I := ‚ü®I.asIdeal, I.2‚ü©\n  invFun I := ‚ü®I, I.2‚ü©\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"PrimeSpectrum.range_asIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\n‚ä¢ Eq (Set.range PrimeSpectrum.asIdeal) (setOf fun J => J.IsPrime)","decl":"theorem range_asIdeal : Set.range PrimeSpectrum.asIdeal = {J : Ideal R | J.IsPrime} :=\n  Set.ext fun J ‚Ü¶\n    ‚ü®fun hJ ‚Ü¶ let ‚ü®j, hj‚ü© := Set.mem_range.mp hJ; Set.mem_setOf.mpr <| hj ‚ñ∏ j.isPrime,\n      fun hJ ‚Ü¶ Set.mem_range.mpr ‚ü®‚ü®J, Set.mem_setOf.mp hJ‚ü©, rfl‚ü©‚ü©\n\n"}
{"name":"PrimeSpectrum.primeSpectrumProd_symm_inl_asIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\ninst‚úù¬π : CommSemiring R\ninst‚úù : CommSemiring S\nx : PrimeSpectrum R\n‚ä¢ Eq ((PrimeSpectrum.primeSpectrumProd R S).symm (Sum.inl x)).asIdeal (x.asIdeal.prod Top.top)","decl":"@[simp]\ntheorem primeSpectrumProd_symm_inl_asIdeal (x : PrimeSpectrum R) :\n    ((primeSpectrumProd R S).symm <| Sum.inl x).asIdeal = Ideal.prod x.asIdeal ‚ä§ := by\n  cases x\n  rfl\n\n"}
{"name":"PrimeSpectrum.primeSpectrumProd_symm_inr_asIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\ninst‚úù¬π : CommSemiring R\ninst‚úù : CommSemiring S\nx : PrimeSpectrum S\n‚ä¢ Eq ((PrimeSpectrum.primeSpectrumProd R S).symm (Sum.inr x)).asIdeal (Top.top.prod x.asIdeal)","decl":"@[simp]\ntheorem primeSpectrumProd_symm_inr_asIdeal (x : PrimeSpectrum S) :\n    ((primeSpectrumProd R S).symm <| Sum.inr x).asIdeal = Ideal.prod ‚ä§ x.asIdeal := by\n  cases x\n  rfl\n\n"}
{"name":"PrimeSpectrum.mem_zeroLocus","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nx : PrimeSpectrum R\ns : Set R\n‚ä¢ Iff (Membership.mem (PrimeSpectrum.zeroLocus s) x) (HasSubset.Subset s ‚Üëx.asIdeal)","decl":"@[simp]\ntheorem mem_zeroLocus (x : PrimeSpectrum R) (s : Set R) : x ‚àà zeroLocus s ‚Üî s ‚äÜ x.asIdeal :=\n  Iff.rfl\n\n"}
{"name":"PrimeSpectrum.zeroLocus_span","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\ns : Set R\n‚ä¢ Eq (PrimeSpectrum.zeroLocus ‚Üë(Ideal.span s)) (PrimeSpectrum.zeroLocus s)","decl":"@[simp]\ntheorem zeroLocus_span (s : Set R) : zeroLocus (Ideal.span s : Set R) = zeroLocus s := by\n  ext x\n  exact (Submodule.gi R R).gc s x.asIdeal\n\n"}
{"name":"PrimeSpectrum.coe_vanishingIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nt : Set (PrimeSpectrum R)\n‚ä¢ Eq (‚Üë(PrimeSpectrum.vanishingIdeal t)) (setOf fun f => ‚àÄ (x : PrimeSpectrum R), Membership.mem t x ‚Üí Membership.mem x.asIdeal f)","decl":"theorem coe_vanishingIdeal (t : Set (PrimeSpectrum R)) :\n    (vanishingIdeal t : Set R) = { f : R | ‚àÄ x ‚àà t, f ‚àà x.asIdeal } := by\n  ext f\n  rw [vanishingIdeal, SetLike.mem_coe, Submodule.mem_iInf]\n  apply forall_congr'; intro x\n  rw [Submodule.mem_iInf]\n\n"}
{"name":"PrimeSpectrum.mem_vanishingIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nt : Set (PrimeSpectrum R)\nf : R\n‚ä¢ Iff (Membership.mem (PrimeSpectrum.vanishingIdeal t) f) (‚àÄ (x : PrimeSpectrum R), Membership.mem t x ‚Üí Membership.mem x.asIdeal f)","decl":"theorem mem_vanishingIdeal (t : Set (PrimeSpectrum R)) (f : R) :\n    f ‚àà vanishingIdeal t ‚Üî ‚àÄ x ‚àà t, f ‚àà x.asIdeal := by\n  rw [‚Üê SetLike.mem_coe, coe_vanishingIdeal, Set.mem_setOf_eq]\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_singleton","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nx : PrimeSpectrum R\n‚ä¢ Eq (PrimeSpectrum.vanishingIdeal (Singleton.singleton x)) x.asIdeal","decl":"@[simp]\ntheorem vanishingIdeal_singleton (x : PrimeSpectrum R) :\n    vanishingIdeal ({x} : Set (PrimeSpectrum R)) = x.asIdeal := by simp [vanishingIdeal]\n\n"}
{"name":"PrimeSpectrum.subset_zeroLocus_iff_le_vanishingIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nt : Set (PrimeSpectrum R)\nI : Ideal R\n‚ä¢ Iff (HasSubset.Subset t (PrimeSpectrum.zeroLocus ‚ÜëI)) (LE.le I (PrimeSpectrum.vanishingIdeal t))","decl":"theorem subset_zeroLocus_iff_le_vanishingIdeal (t : Set (PrimeSpectrum R)) (I : Ideal R) :\n    t ‚äÜ zeroLocus I ‚Üî I ‚â§ vanishingIdeal t :=\n  ‚ü®fun h _ k => (mem_vanishingIdeal _ _).mpr fun _ j => (mem_zeroLocus _ _).mpr (h j) k, fun h =>\n    fun x j => (mem_zeroLocus _ _).mpr (le_trans h fun _ h => ((mem_vanishingIdeal _ _).mp h) x j)‚ü©\n\n"}
{"name":"PrimeSpectrum.gc","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\n‚ä¢ GaloisConnection (fun I => PrimeSpectrum.zeroLocus ‚ÜëI) fun t => PrimeSpectrum.vanishingIdeal t","decl":"/-- `zeroLocus` and `vanishingIdeal` form a galois connection. -/\ntheorem gc :\n    @GaloisConnection (Ideal R) (Set (PrimeSpectrum R))·µí·µà _ _ (fun I => zeroLocus I) fun t =>\n      vanishingIdeal t :=\n  fun I t => subset_zeroLocus_iff_le_vanishingIdeal t I\n\n"}
{"name":"PrimeSpectrum.gc_set","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\n‚ä¢ GaloisConnection (fun s => PrimeSpectrum.zeroLocus s) fun t => ‚Üë(PrimeSpectrum.vanishingIdeal t)","decl":"/-- `zeroLocus` and `vanishingIdeal` form a galois connection. -/\ntheorem gc_set :\n    @GaloisConnection (Set R) (Set (PrimeSpectrum R))·µí·µà _ _ (fun s => zeroLocus s) fun t =>\n      vanishingIdeal t := by\n  have ideal_gc : GaloisConnection Ideal.span _ := (Submodule.gi R R).gc\n  simpa [zeroLocus_span, Function.comp_def] using ideal_gc.compose (gc R)\n\n"}
{"name":"PrimeSpectrum.subset_zeroLocus_iff_subset_vanishingIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nt : Set (PrimeSpectrum R)\ns : Set R\n‚ä¢ Iff (HasSubset.Subset t (PrimeSpectrum.zeroLocus s)) (HasSubset.Subset s ‚Üë(PrimeSpectrum.vanishingIdeal t))","decl":"theorem subset_zeroLocus_iff_subset_vanishingIdeal (t : Set (PrimeSpectrum R)) (s : Set R) :\n    t ‚äÜ zeroLocus s ‚Üî s ‚äÜ vanishingIdeal t :=\n  (gc_set R) s t\n\n"}
{"name":"PrimeSpectrum.subset_vanishingIdeal_zeroLocus","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\ns : Set R\n‚ä¢ HasSubset.Subset s ‚Üë(PrimeSpectrum.vanishingIdeal (PrimeSpectrum.zeroLocus s))","decl":"theorem subset_vanishingIdeal_zeroLocus (s : Set R) : s ‚äÜ vanishingIdeal (zeroLocus s) :=\n  (gc_set R).le_u_l s\n\n"}
{"name":"PrimeSpectrum.le_vanishingIdeal_zeroLocus","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nI : Ideal R\n‚ä¢ LE.le I (PrimeSpectrum.vanishingIdeal (PrimeSpectrum.zeroLocus ‚ÜëI))","decl":"theorem le_vanishingIdeal_zeroLocus (I : Ideal R) : I ‚â§ vanishingIdeal (zeroLocus I) :=\n  (gc R).le_u_l I\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_zeroLocus_eq_radical","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nI : Ideal R\n‚ä¢ Eq (PrimeSpectrum.vanishingIdeal (PrimeSpectrum.zeroLocus ‚ÜëI)) I.radical","decl":"@[simp]\ntheorem vanishingIdeal_zeroLocus_eq_radical (I : Ideal R) :\n    vanishingIdeal (zeroLocus (I : Set R)) = I.radical :=\n  Ideal.ext fun f => by\n    rw [mem_vanishingIdeal, Ideal.radical_eq_sInf, Submodule.mem_sInf]\n    exact ‚ü®fun h x hx => h ‚ü®x, hx.2‚ü© hx.1, fun h x hx => h x.1 ‚ü®hx, x.2‚ü©‚ü©\n\n"}
{"name":"PrimeSpectrum.nilradical_eq_iInf","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\n‚ä¢ Eq (nilradical R) (iInf PrimeSpectrum.asIdeal)","decl":"theorem nilradical_eq_iInf : nilradical R = iInf asIdeal := by\n  apply range_asIdeal R ‚ñ∏ nilradical_eq_sInf R\n\n"}
{"name":"PrimeSpectrum.zeroLocus_radical","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nI : Ideal R\n‚ä¢ Eq (PrimeSpectrum.zeroLocus ‚ÜëI.radical) (PrimeSpectrum.zeroLocus ‚ÜëI)","decl":"@[simp]\ntheorem zeroLocus_radical (I : Ideal R) : zeroLocus (I.radical : Set R) = zeroLocus I :=\n  vanishingIdeal_zeroLocus_eq_radical I ‚ñ∏ (gc R).l_u_l_eq_l I\n\n"}
{"name":"PrimeSpectrum.subset_zeroLocus_vanishingIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nt : Set (PrimeSpectrum R)\n‚ä¢ HasSubset.Subset t (PrimeSpectrum.zeroLocus ‚Üë(PrimeSpectrum.vanishingIdeal t))","decl":"theorem subset_zeroLocus_vanishingIdeal (t : Set (PrimeSpectrum R)) :\n    t ‚äÜ zeroLocus (vanishingIdeal t) :=\n  (gc R).l_u_le t\n\n"}
{"name":"PrimeSpectrum.zeroLocus_anti_mono","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\ns t : Set R\nh : HasSubset.Subset s t\n‚ä¢ HasSubset.Subset (PrimeSpectrum.zeroLocus t) (PrimeSpectrum.zeroLocus s)","decl":"theorem zeroLocus_anti_mono {s t : Set R} (h : s ‚äÜ t) : zeroLocus t ‚äÜ zeroLocus s :=\n  (gc_set R).monotone_l h\n\n"}
{"name":"PrimeSpectrum.zeroLocus_anti_mono_ideal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\ns t : Ideal R\nh : LE.le s t\n‚ä¢ HasSubset.Subset (PrimeSpectrum.zeroLocus ‚Üët) (PrimeSpectrum.zeroLocus ‚Üës)","decl":"theorem zeroLocus_anti_mono_ideal {s t : Ideal R} (h : s ‚â§ t) :\n    zeroLocus (t : Set R) ‚äÜ zeroLocus (s : Set R) :=\n  (gc R).monotone_l h\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_anti_mono","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\ns t : Set (PrimeSpectrum R)\nh : HasSubset.Subset s t\n‚ä¢ LE.le (PrimeSpectrum.vanishingIdeal t) (PrimeSpectrum.vanishingIdeal s)","decl":"theorem vanishingIdeal_anti_mono {s t : Set (PrimeSpectrum R)} (h : s ‚äÜ t) :\n    vanishingIdeal t ‚â§ vanishingIdeal s :=\n  (gc R).monotone_u h\n\n"}
{"name":"PrimeSpectrum.zeroLocus_subset_zeroLocus_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nI J : Ideal R\n‚ä¢ Iff (HasSubset.Subset (PrimeSpectrum.zeroLocus ‚ÜëI) (PrimeSpectrum.zeroLocus ‚ÜëJ)) (LE.le J I.radical)","decl":"theorem zeroLocus_subset_zeroLocus_iff (I J : Ideal R) :\n    zeroLocus (I : Set R) ‚äÜ zeroLocus (J : Set R) ‚Üî J ‚â§ I.radical := by\n  rw [subset_zeroLocus_iff_le_vanishingIdeal, vanishingIdeal_zeroLocus_eq_radical]\n\n"}
{"name":"PrimeSpectrum.zeroLocus_subset_zeroLocus_singleton_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nf g : R\n‚ä¢ Iff (HasSubset.Subset (PrimeSpectrum.zeroLocus (Singleton.singleton f)) (PrimeSpectrum.zeroLocus (Singleton.singleton g))) (Membership.mem (Ideal.span (Singleton.singleton f)).radical g)","decl":"theorem zeroLocus_subset_zeroLocus_singleton_iff (f g : R) :\n    zeroLocus ({f} : Set R) ‚äÜ zeroLocus {g} ‚Üî g ‚àà (Ideal.span ({f} : Set R)).radical := by\n  rw [‚Üê zeroLocus_span {f}, ‚Üê zeroLocus_span {g}, zeroLocus_subset_zeroLocus_iff, Ideal.span_le,\n    Set.singleton_subset_iff, SetLike.mem_coe]\n\n"}
{"name":"PrimeSpectrum.zeroLocus_bot","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\n‚ä¢ Eq (PrimeSpectrum.zeroLocus ‚ÜëBot.bot) Set.univ","decl":"theorem zeroLocus_bot : zeroLocus ((‚ä• : Ideal R) : Set R) = Set.univ :=\n  (gc R).l_bot\n\n"}
{"name":"PrimeSpectrum.zeroLocus_singleton_zero","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\n‚ä¢ Eq (PrimeSpectrum.zeroLocus (Singleton.singleton 0)) Set.univ","decl":"@[simp]\ntheorem zeroLocus_singleton_zero : zeroLocus ({0} : Set R) = Set.univ :=\n  zeroLocus_bot\n\n"}
{"name":"PrimeSpectrum.zeroLocus_empty","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\n‚ä¢ Eq (PrimeSpectrum.zeroLocus EmptyCollection.emptyCollection) Set.univ","decl":"@[simp]\ntheorem zeroLocus_empty : zeroLocus (‚àÖ : Set R) = Set.univ :=\n  (gc_set R).l_bot\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_empty","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\n‚ä¢ Eq (PrimeSpectrum.vanishingIdeal EmptyCollection.emptyCollection) Top.top","decl":"@[simp]\ntheorem vanishingIdeal_empty : vanishingIdeal (‚àÖ : Set (PrimeSpectrum R)) = ‚ä§ := by\n  simpa using (gc R).u_top\n\n"}
{"name":"PrimeSpectrum.zeroLocus_empty_of_one_mem","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\ns : Set R\nh : Membership.mem s 1\n‚ä¢ Eq (PrimeSpectrum.zeroLocus s) EmptyCollection.emptyCollection","decl":"theorem zeroLocus_empty_of_one_mem {s : Set R} (h : (1 : R) ‚àà s) : zeroLocus s = ‚àÖ := by\n  rw [Set.eq_empty_iff_forall_not_mem]\n  intro x hx\n  rw [mem_zeroLocus] at hx\n  have x_prime : x.asIdeal.IsPrime := by infer_instance\n  have eq_top : x.asIdeal = ‚ä§ := by\n    rw [Ideal.eq_top_iff_one]\n    exact hx h\n  apply x_prime.ne_top eq_top\n\n"}
{"name":"PrimeSpectrum.zeroLocus_singleton_one","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\n‚ä¢ Eq (PrimeSpectrum.zeroLocus (Singleton.singleton 1)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem zeroLocus_singleton_one : zeroLocus ({1} : Set R) = ‚àÖ :=\n  zeroLocus_empty_of_one_mem (Set.mem_singleton (1 : R))\n\n"}
{"name":"PrimeSpectrum.zeroLocus_empty_iff_eq_top","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nI : Ideal R\n‚ä¢ Iff (Eq (PrimeSpectrum.zeroLocus ‚ÜëI) EmptyCollection.emptyCollection) (Eq I Top.top)","decl":"theorem zeroLocus_empty_iff_eq_top {I : Ideal R} : zeroLocus (I : Set R) = ‚àÖ ‚Üî I = ‚ä§ := by\n  constructor\n  ¬∑ contrapose!\n    intro h\n    rcases Ideal.exists_le_maximal I h with ‚ü®M, hM, hIM‚ü©\n    exact ‚ü®‚ü®M, hM.isPrime‚ü©, hIM‚ü©\n  ¬∑ rintro rfl\n    apply zeroLocus_empty_of_one_mem\n    trivial\n\n"}
{"name":"PrimeSpectrum.zeroLocus_univ","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\n‚ä¢ Eq (PrimeSpectrum.zeroLocus Set.univ) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem zeroLocus_univ : zeroLocus (Set.univ : Set R) = ‚àÖ :=\n  zeroLocus_empty_of_one_mem (Set.mem_univ 1)\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_eq_top_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\ns : Set (PrimeSpectrum R)\n‚ä¢ Iff (Eq (PrimeSpectrum.vanishingIdeal s) Top.top) (Eq s EmptyCollection.emptyCollection)","decl":"theorem vanishingIdeal_eq_top_iff {s : Set (PrimeSpectrum R)} : vanishingIdeal s = ‚ä§ ‚Üî s = ‚àÖ := by\n  rw [‚Üê top_le_iff, ‚Üê subset_zeroLocus_iff_le_vanishingIdeal, Submodule.top_coe, zeroLocus_univ,\n    Set.subset_empty_iff]\n\n"}
{"name":"PrimeSpectrum.zeroLocus_eq_top_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\ns : Set R\n‚ä¢ Iff (Eq (PrimeSpectrum.zeroLocus s) Top.top) (HasSubset.Subset s ‚Üë(nilradical R))","decl":"theorem zeroLocus_eq_top_iff (s : Set R) :\n    zeroLocus s = ‚ä§ ‚Üî s ‚äÜ nilradical R := by\n  constructor\n  ¬∑ intro h x hx\n    refine nilpotent_iff_mem_prime.mpr (fun J hJ ‚Ü¶ ?_)\n    have hJz : ‚ü®J, hJ‚ü© ‚àà zeroLocus s := by\n      rw [h]\n      trivial\n    exact (mem_zeroLocus _ _).mpr hJz hx\n  ¬∑ rw [eq_top_iff]\n    intro h p _\n    apply Set.Subset.trans h (nilradical_le_prime p.asIdeal)\n\n"}
{"name":"PrimeSpectrum.zeroLocus_sup","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nI J : Ideal R\n‚ä¢ Eq (PrimeSpectrum.zeroLocus ‚Üë(Max.max I J)) (Inter.inter (PrimeSpectrum.zeroLocus ‚ÜëI) (PrimeSpectrum.zeroLocus ‚ÜëJ))","decl":"theorem zeroLocus_sup (I J : Ideal R) :\n    zeroLocus ((I ‚äî J : Ideal R) : Set R) = zeroLocus I ‚à© zeroLocus J :=\n  (gc R).l_sup\n\n"}
{"name":"PrimeSpectrum.zeroLocus_union","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\ns s' : Set R\n‚ä¢ Eq (PrimeSpectrum.zeroLocus (Union.union s s')) (Inter.inter (PrimeSpectrum.zeroLocus s) (PrimeSpectrum.zeroLocus s'))","decl":"theorem zeroLocus_union (s s' : Set R) : zeroLocus (s ‚à™ s') = zeroLocus s ‚à© zeroLocus s' :=\n  (gc_set R).l_sup\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_union","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nt t' : Set (PrimeSpectrum R)\n‚ä¢ Eq (PrimeSpectrum.vanishingIdeal (Union.union t t')) (Min.min (PrimeSpectrum.vanishingIdeal t) (PrimeSpectrum.vanishingIdeal t'))","decl":"theorem vanishingIdeal_union (t t' : Set (PrimeSpectrum R)) :\n    vanishingIdeal (t ‚à™ t') = vanishingIdeal t ‚äì vanishingIdeal t' :=\n  (gc R).u_inf\n\n"}
{"name":"PrimeSpectrum.zeroLocus_iSup","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nŒπ : Sort u_1\nI : Œπ ‚Üí Ideal R\n‚ä¢ Eq (PrimeSpectrum.zeroLocus ‚Üë(iSup fun i => I i)) (Set.iInter fun i => PrimeSpectrum.zeroLocus ‚Üë(I i))","decl":"theorem zeroLocus_iSup {Œπ : Sort*} (I : Œπ ‚Üí Ideal R) :\n    zeroLocus ((‚®Ü i, I i : Ideal R) : Set R) = ‚ãÇ i, zeroLocus (I i) :=\n  (gc R).l_iSup\n\n"}
{"name":"PrimeSpectrum.zeroLocus_iUnion","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nŒπ : Sort u_1\ns : Œπ ‚Üí Set R\n‚ä¢ Eq (PrimeSpectrum.zeroLocus (Set.iUnion fun i => s i)) (Set.iInter fun i => PrimeSpectrum.zeroLocus (s i))","decl":"theorem zeroLocus_iUnion {Œπ : Sort*} (s : Œπ ‚Üí Set R) :\n    zeroLocus (‚ãÉ i, s i) = ‚ãÇ i, zeroLocus (s i) :=\n  (gc_set R).l_iSup\n\n"}
{"name":"PrimeSpectrum.zeroLocus_iUnion‚ÇÇ","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nŒπ : Sort u_1\nŒ∫ : Œπ ‚Üí Sort u_2\ns : (i : Œπ) ‚Üí Œ∫ i ‚Üí Set R\n‚ä¢ Eq (PrimeSpectrum.zeroLocus (Set.iUnion fun i => Set.iUnion fun j => s i j)) (Set.iInter fun i => Set.iInter fun j => PrimeSpectrum.zeroLocus (s i j))","decl":"theorem zeroLocus_iUnion‚ÇÇ {Œπ : Sort*} {Œ∫ : (i : Œπ) ‚Üí Sort*} (s : ‚àÄ i, Œ∫ i ‚Üí Set R) :\n    zeroLocus (‚ãÉ (i) (j), s i j) = ‚ãÇ (i) (j), zeroLocus (s i j) :=\n  (gc_set R).l_iSup‚ÇÇ\n\n"}
{"name":"PrimeSpectrum.zeroLocus_bUnion","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\ns : Set (Set R)\n‚ä¢ Eq (PrimeSpectrum.zeroLocus (Set.iUnion fun s' => Set.iUnion fun h => s')) (Set.iInter fun s' => Set.iInter fun h => PrimeSpectrum.zeroLocus s')","decl":"theorem zeroLocus_bUnion (s : Set (Set R)) :\n    zeroLocus (‚ãÉ s' ‚àà s, s' : Set R) = ‚ãÇ s' ‚àà s, zeroLocus s' := by simp only [zeroLocus_iUnion]\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_iUnion","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nŒπ : Sort u_1\nt : Œπ ‚Üí Set (PrimeSpectrum R)\n‚ä¢ Eq (PrimeSpectrum.vanishingIdeal (Set.iUnion fun i => t i)) (iInf fun i => PrimeSpectrum.vanishingIdeal (t i))","decl":"theorem vanishingIdeal_iUnion {Œπ : Sort*} (t : Œπ ‚Üí Set (PrimeSpectrum R)) :\n    vanishingIdeal (‚ãÉ i, t i) = ‚®Ö i, vanishingIdeal (t i) :=\n  (gc R).u_iInf\n\n"}
{"name":"PrimeSpectrum.zeroLocus_inf","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nI J : Ideal R\n‚ä¢ Eq (PrimeSpectrum.zeroLocus ‚Üë(Min.min I J)) (Union.union (PrimeSpectrum.zeroLocus ‚ÜëI) (PrimeSpectrum.zeroLocus ‚ÜëJ))","decl":"theorem zeroLocus_inf (I J : Ideal R) :\n    zeroLocus ((I ‚äì J : Ideal R) : Set R) = zeroLocus I ‚à™ zeroLocus J :=\n  Set.ext fun x => x.2.inf_le\n\n"}
{"name":"PrimeSpectrum.union_zeroLocus","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\ns s' : Set R\n‚ä¢ Eq (Union.union (PrimeSpectrum.zeroLocus s) (PrimeSpectrum.zeroLocus s')) (PrimeSpectrum.zeroLocus ‚Üë(Min.min (Ideal.span s) (Ideal.span s')))","decl":"theorem union_zeroLocus (s s' : Set R) :\n    zeroLocus s ‚à™ zeroLocus s' = zeroLocus (Ideal.span s ‚äì Ideal.span s' : Ideal R) := by\n  rw [zeroLocus_inf]\n  simp\n\n"}
{"name":"PrimeSpectrum.zeroLocus_mul","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nI J : Ideal R\n‚ä¢ Eq (PrimeSpectrum.zeroLocus ‚Üë(HMul.hMul I J)) (Union.union (PrimeSpectrum.zeroLocus ‚ÜëI) (PrimeSpectrum.zeroLocus ‚ÜëJ))","decl":"theorem zeroLocus_mul (I J : Ideal R) :\n    zeroLocus ((I * J : Ideal R) : Set R) = zeroLocus I ‚à™ zeroLocus J :=\n  Set.ext fun x => x.2.mul_le\n\n"}
{"name":"PrimeSpectrum.zeroLocus_singleton_mul","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nf g : R\n‚ä¢ Eq (PrimeSpectrum.zeroLocus (Singleton.singleton (HMul.hMul f g))) (Union.union (PrimeSpectrum.zeroLocus (Singleton.singleton f)) (PrimeSpectrum.zeroLocus (Singleton.singleton g)))","decl":"theorem zeroLocus_singleton_mul (f g : R) :\n    zeroLocus ({f * g} : Set R) = zeroLocus {f} ‚à™ zeroLocus {g} :=\n  Set.ext fun x => by simpa using x.2.mul_mem_iff_mem_or_mem\n\n"}
{"name":"PrimeSpectrum.zeroLocus_pow","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nI : Ideal R\nn : Nat\nhn : Ne n 0\n‚ä¢ Eq (PrimeSpectrum.zeroLocus ‚Üë(HPow.hPow I n)) (PrimeSpectrum.zeroLocus ‚ÜëI)","decl":"@[simp]\ntheorem zeroLocus_pow (I : Ideal R) {n : ‚Ñï} (hn : n ‚â† 0) :\n    zeroLocus ((I ^ n : Ideal R) : Set R) = zeroLocus I :=\n  zeroLocus_radical (I ^ n) ‚ñ∏ (I.radical_pow hn).symm ‚ñ∏ zeroLocus_radical I\n\n"}
{"name":"PrimeSpectrum.zeroLocus_singleton_pow","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nf : R\nn : Nat\nhn : LT.lt 0 n\n‚ä¢ Eq (PrimeSpectrum.zeroLocus (Singleton.singleton (HPow.hPow f n))) (PrimeSpectrum.zeroLocus (Singleton.singleton f))","decl":"@[simp]\ntheorem zeroLocus_singleton_pow (f : R) (n : ‚Ñï) (hn : 0 < n) :\n    zeroLocus ({f ^ n} : Set R) = zeroLocus {f} :=\n  Set.ext fun x => by simpa using x.2.pow_mem_iff_mem n hn\n\n"}
{"name":"PrimeSpectrum.sup_vanishingIdeal_le","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nt t' : Set (PrimeSpectrum R)\n‚ä¢ LE.le (Max.max (PrimeSpectrum.vanishingIdeal t) (PrimeSpectrum.vanishingIdeal t')) (PrimeSpectrum.vanishingIdeal (Inter.inter t t'))","decl":"theorem sup_vanishingIdeal_le (t t' : Set (PrimeSpectrum R)) :\n    vanishingIdeal t ‚äî vanishingIdeal t' ‚â§ vanishingIdeal (t ‚à© t') := by\n  intro r\n  rw [Submodule.mem_sup, mem_vanishingIdeal]\n  rintro ‚ü®f, hf, g, hg, rfl‚ü© x ‚ü®hxt, hxt'‚ü©\n  rw [mem_vanishingIdeal] at hf hg\n  apply Submodule.add_mem <;> solve_by_elim\n\n"}
{"name":"PrimeSpectrum.mem_compl_zeroLocus_iff_not_mem","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nf : R\nI : PrimeSpectrum R\n‚ä¢ Iff (Membership.mem (HasCompl.compl (PrimeSpectrum.zeroLocus (Singleton.singleton f))) I) (Not (Membership.mem I.asIdeal f))","decl":"theorem mem_compl_zeroLocus_iff_not_mem {f : R} {I : PrimeSpectrum R} :\n    I ‚àà (zeroLocus {f} : Set (PrimeSpectrum R))·∂ú ‚Üî f ‚àâ I.asIdeal := by\n  rw [Set.mem_compl_iff, mem_zeroLocus, Set.singleton_subset_iff]; rfl\n\n"}
{"name":"PrimeSpectrum.zeroLocus_insert_zero","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\ns : Set R\n‚ä¢ Eq (PrimeSpectrum.zeroLocus (Insert.insert 0 s)) (PrimeSpectrum.zeroLocus s)","decl":"@[simp]\nlemma zeroLocus_insert_zero (s : Set R) : zeroLocus (insert 0 s) = zeroLocus s := by\n  rw [‚Üê Set.union_singleton, zeroLocus_union, zeroLocus_singleton_zero, Set.inter_univ]\n\n"}
{"name":"PrimeSpectrum.zeroLocus_diff_singleton_zero","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\ns : Set R\n‚ä¢ Eq (PrimeSpectrum.zeroLocus (SDiff.sdiff s (Singleton.singleton 0))) (PrimeSpectrum.zeroLocus s)","decl":"@[simp]\nlemma zeroLocus_diff_singleton_zero (s : Set R) : zeroLocus (s \\ {0}) = zeroLocus s := by\n  rw [‚Üê zeroLocus_insert_zero, ‚Üê zeroLocus_insert_zero (s := s)]; simp\n\n"}
{"name":"PrimeSpectrum.zeroLocus_smul_of_isUnit","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nr : R\nhr : IsUnit r\ns : Set R\n‚ä¢ Eq (PrimeSpectrum.zeroLocus (HSMul.hSMul r s)) (PrimeSpectrum.zeroLocus s)","decl":"lemma zeroLocus_smul_of_isUnit {r : R} (hr : IsUnit r) (s : Set R) :\n    zeroLocus (r ‚Ä¢ s) = zeroLocus s := by\n  ext; simp [Set.subset_def, ‚Üê Set.image_smul, Ideal.unit_mul_mem_iff_mem _ hr]\n\n"}
{"name":"PrimeSpectrum.asIdeal_le_asIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nx y : PrimeSpectrum R\n‚ä¢ Iff (LE.le x.asIdeal y.asIdeal) (LE.le x y)","decl":"@[simp]\ntheorem asIdeal_le_asIdeal (x y : PrimeSpectrum R) : x.asIdeal ‚â§ y.asIdeal ‚Üî x ‚â§ y :=\n  Iff.rfl\n\n"}
{"name":"PrimeSpectrum.asIdeal_lt_asIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\nx y : PrimeSpectrum R\n‚ä¢ Iff (LT.lt x.asIdeal y.asIdeal) (LT.lt x y)","decl":"@[simp]\ntheorem asIdeal_lt_asIdeal (x y : PrimeSpectrum R) : x.asIdeal < y.asIdeal ‚Üî x < y :=\n  Iff.rfl\n\n"}
{"name":"PrimeSpectrum.exists_primeSpectrum_prod_le","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù¬π : CommRing R\ninst‚úù : IsNoetherianRing R\nI : Ideal R\n‚ä¢ Exists fun Z => LE.le (Multiset.map PrimeSpectrum.asIdeal Z).prod I","decl":"/-- In a noetherian ring, every ideal contains a product of prime ideals\n([samuel, ¬ß 3.3, Lemma 3])-/\ntheorem exists_primeSpectrum_prod_le (I : Ideal R) :\n    ‚àÉ Z : Multiset (PrimeSpectrum R), Multiset.prod (Z.map asIdeal) ‚â§ I := by\n  -- Porting note: Need to specify `P` explicitly\n  refine IsNoetherian.induction\n    (P := fun I => ‚àÉ Z : Multiset (PrimeSpectrum R), Multiset.prod (Z.map asIdeal) ‚â§ I)\n    (fun (M : Ideal R) hgt => ?_) I\n  by_cases h_prM : M.IsPrime\n  ¬∑ use {‚ü®M, h_prM‚ü©}\n    rw [Multiset.map_singleton, Multiset.prod_singleton]\n  by_cases htop : M = ‚ä§\n  ¬∑ rw [htop]\n    exact ‚ü®0, le_top‚ü©\n  have lt_add : ‚àÄ z ‚àâ M, M < M + span R {z} := by\n    intro z hz\n    refine lt_of_le_of_ne le_sup_left fun m_eq => hz ?_\n    rw [m_eq]\n    exact Ideal.mem_sup_right (mem_span_singleton_self z)\n  obtain ‚ü®x, hx, y, hy, hxy‚ü© := (Ideal.not_isPrime_iff.mp h_prM).resolve_left htop\n  obtain ‚ü®Wx, h_Wx‚ü© := hgt (M + span R {x}) (lt_add _ hx)\n  obtain ‚ü®Wy, h_Wy‚ü© := hgt (M + span R {y}) (lt_add _ hy)\n  use Wx + Wy\n  rw [Multiset.map_add, Multiset.prod_add]\n  apply le_trans (Submodule.mul_le_mul h_Wx h_Wy)\n  rw [add_mul]\n  apply sup_le (show M * (M + span R {y}) ‚â§ M from Ideal.mul_le_right)\n  rw [mul_add]\n  apply sup_le (show span R {x} * M ‚â§ M from Ideal.mul_le_left)\n  rwa [span_mul_span, Set.singleton_mul_singleton, span_singleton_le_iff_mem]\n\n"}
{"name":"PrimeSpectrum.exists_primeSpectrum_prod_le_and_ne_bot_of_domain","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"A : Type u\ninst‚úù¬≤ : CommRing A\ninst‚úù¬π : IsDomain A\ninst‚úù : IsNoetherianRing A\nh_fA : Not (IsField A)\nI : Ideal A\nh_nzI : Ne I Bot.bot\n‚ä¢ Exists fun Z => And (LE.le (Multiset.map PrimeSpectrum.asIdeal Z).prod I) (Ne (Multiset.map PrimeSpectrum.asIdeal Z).prod Bot.bot)","decl":"/-- In a noetherian integral domain which is not a field, every non-zero ideal contains a non-zero\n  product of prime ideals; in a field, the whole ring is a non-zero ideal containing only 0 as\n  product or prime ideals ([samuel, ¬ß 3.3, Lemma 3]) -/\ntheorem exists_primeSpectrum_prod_le_and_ne_bot_of_domain (h_fA : ¬¨IsField A) {I : Ideal A}\n    (h_nzI : I ‚â† ‚ä•) :\n    ‚àÉ Z : Multiset (PrimeSpectrum A),\n      Multiset.prod (Z.map asIdeal) ‚â§ I ‚àß Multiset.prod (Z.map asIdeal) ‚â† ‚ä• := by\n  revert h_nzI\n  -- Porting note: Need to specify `P` explicitly\n  refine IsNoetherian.induction (P := fun I => I ‚â† ‚ä• ‚Üí ‚àÉ Z : Multiset (PrimeSpectrum A),\n      Multiset.prod (Z.map asIdeal) ‚â§ I ‚àß Multiset.prod (Z.map asIdeal) ‚â† ‚ä•)\n    (fun (M : Ideal A) hgt => ?_) I\n  intro h_nzM\n  have hA_nont : Nontrivial A := IsDomain.toNontrivial\n  by_cases h_topM : M = ‚ä§\n  ¬∑ rcases h_topM with rfl\n    obtain ‚ü®p_id, h_nzp, h_pp‚ü© : ‚àÉ p : Ideal A, p ‚â† ‚ä• ‚àß p.IsPrime := by\n      apply Ring.not_isField_iff_exists_prime.mp h_fA\n    use ({‚ü®p_id, h_pp‚ü©} : Multiset (PrimeSpectrum A)), le_top\n    rwa [Multiset.map_singleton, Multiset.prod_singleton]\n  by_cases h_prM : M.IsPrime\n  ¬∑ use ({‚ü®M, h_prM‚ü©} : Multiset (PrimeSpectrum A))\n    rw [Multiset.map_singleton, Multiset.prod_singleton]\n    exact ‚ü®le_rfl, h_nzM‚ü©\n  obtain ‚ü®x, hx, y, hy, h_xy‚ü© := (Ideal.not_isPrime_iff.mp h_prM).resolve_left h_topM\n  have lt_add : ‚àÄ z ‚àâ M, M < M + span A {z} := by\n    intro z hz\n    refine lt_of_le_of_ne le_sup_left fun m_eq => hz ?_\n    rw [m_eq]\n    exact mem_sup_right (mem_span_singleton_self z)\n  obtain ‚ü®Wx, h_Wx_le, h_Wx_ne‚ü© := hgt (M + span A {x}) (lt_add _ hx) (ne_bot_of_gt (lt_add _ hx))\n  obtain ‚ü®Wy, h_Wy_le, h_Wx_ne‚ü© := hgt (M + span A {y}) (lt_add _ hy) (ne_bot_of_gt (lt_add _ hy))\n  use Wx + Wy\n  rw [Multiset.map_add, Multiset.prod_add]\n  refine ‚ü®le_trans (Submodule.mul_le_mul h_Wx_le h_Wy_le) ?_, mt Ideal.mul_eq_bot.mp ?_‚ü©\n  ¬∑ rw [add_mul]\n    apply sup_le (show M * (M + span A {y}) ‚â§ M from Ideal.mul_le_right)\n    rw [mul_add]\n    apply sup_le (show span A {x} * M ‚â§ M from Ideal.mul_le_left)\n    rwa [span_mul_span, Set.singleton_mul_singleton, span_singleton_le_iff_mem]\n  ¬∑ rintro (hx | hy) <;> contradiction\n\n"}
{"name":"PrimeSpectrum.preimage_specComap_zeroLocus_aux","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\ninst‚úù¬π : CommSemiring R\ninst‚úù : CommSemiring S\nf : RingHom R S\ns : Set R\n‚ä¢ Eq (Set.preimage f.specComap (PrimeSpectrum.zeroLocus s)) (PrimeSpectrum.zeroLocus (Set.image (‚áëf) s))","decl":"theorem preimage_specComap_zeroLocus_aux (f : R ‚Üí+* S) (s : Set R) :\n    f.specComap ‚Åª¬π' zeroLocus s = zeroLocus (f '' s) := by\n  ext x\n  simp only [mem_zeroLocus, Set.image_subset_iff, Set.mem_preimage, mem_zeroLocus, Ideal.coe_comap]\n\n"}
{"name":"PrimeSpectrum.specComap_asIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\ninst‚úù¬π : CommSemiring R\ninst‚úù : CommSemiring S\nf : RingHom R S\ny : PrimeSpectrum S\n‚ä¢ Eq (f.specComap y).asIdeal (Ideal.comap f y.asIdeal)","decl":"@[simp]\ntheorem specComap_asIdeal (y : PrimeSpectrum S) :\n    (f.specComap y).asIdeal = Ideal.comap f y.asIdeal :=\n  rfl\n\n"}
{"name":"PrimeSpectrum.specComap_id","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\ninst‚úù : CommSemiring R\n‚ä¢ Eq (RingHom.id R).specComap fun x => x","decl":"@[simp]\ntheorem specComap_id : (RingHom.id R).specComap = fun x => x :=\n  rfl\n\n"}
{"name":"PrimeSpectrum.specComap_comp","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\nS' : Type u_1\ninst‚úù¬≤ : CommSemiring R\ninst‚úù¬π : CommSemiring S\ninst‚úù : CommSemiring S'\nf : RingHom R S\ng : RingHom S S'\n‚ä¢ Eq (g.comp f).specComap (Function.comp f.specComap g.specComap)","decl":"@[simp]\ntheorem specComap_comp (f : R ‚Üí+* S) (g : S ‚Üí+* S') :\n    (g.comp f).specComap = f.specComap.comp g.specComap :=\n  rfl\n\n"}
{"name":"PrimeSpectrum.specComap_comp_apply","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\nS' : Type u_1\ninst‚úù¬≤ : CommSemiring R\ninst‚úù¬π : CommSemiring S\ninst‚úù : CommSemiring S'\nf : RingHom R S\ng : RingHom S S'\nx : PrimeSpectrum S'\n‚ä¢ Eq ((g.comp f).specComap x) (f.specComap (g.specComap x))","decl":"theorem specComap_comp_apply (f : R ‚Üí+* S) (g : S ‚Üí+* S') (x : PrimeSpectrum S') :\n    (g.comp f).specComap x = f.specComap (g.specComap x) :=\n  rfl\n\n"}
{"name":"PrimeSpectrum.preimage_specComap_zeroLocus","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\ninst‚úù¬π : CommSemiring R\ninst‚úù : CommSemiring S\nf : RingHom R S\ns : Set R\n‚ä¢ Eq (Set.preimage f.specComap (PrimeSpectrum.zeroLocus s)) (PrimeSpectrum.zeroLocus (Set.image (‚áëf) s))","decl":"@[simp]\ntheorem preimage_specComap_zeroLocus (s : Set R) :\n    f.specComap ‚Åª¬π' zeroLocus s = zeroLocus (f '' s) :=\n  preimage_specComap_zeroLocus_aux f s\n\n"}
{"name":"PrimeSpectrum.specComap_injective_of_surjective","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\ninst‚úù¬π : CommSemiring R\ninst‚úù : CommSemiring S\nf : RingHom R S\nhf : Function.Surjective ‚áëf\n‚ä¢ Function.Injective f.specComap","decl":"theorem specComap_injective_of_surjective (f : R ‚Üí+* S) (hf : Function.Surjective f) :\n    Function.Injective f.specComap := fun x y h =>\n  PrimeSpectrum.ext\n    (Ideal.comap_injective_of_surjective f hf\n      (congr_arg PrimeSpectrum.asIdeal h : (f.specComap x).asIdeal = (f.specComap y).asIdeal))\n\n"}
{"name":"PrimeSpectrum.comapEquiv_apply","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\ninst‚úù¬π : CommSemiring R\ninst‚úù : CommSemiring S\ne : RingEquiv R S\na‚úù : PrimeSpectrum R\n‚ä¢ Eq ((PrimeSpectrum.comapEquiv e) a‚úù) (e.symm.toRingHom.specComap a‚úù)","decl":"/-- `RingHom.specComap` of an isomorphism of rings as an equivalence of their prime spectra. -/\n@[simps apply symm_apply]\ndef comapEquiv (e : R ‚âÉ+* S) : PrimeSpectrum R ‚âÉ PrimeSpectrum S where\n  toFun := e.symm.toRingHom.specComap\n  invFun := e.toRingHom.specComap\n  left_inv x := by\n    rw [‚Üê specComap_comp_apply, RingEquiv.toRingHom_eq_coe,\n      RingEquiv.toRingHom_eq_coe, RingEquiv.symm_comp]\n    rfl\n  right_inv x := by\n    rw [‚Üê specComap_comp_apply, RingEquiv.toRingHom_eq_coe,\n      RingEquiv.toRingHom_eq_coe, RingEquiv.comp_symm]\n    rfl\n\n"}
{"name":"PrimeSpectrum.comapEquiv_symm_apply","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\ninst‚úù¬π : CommSemiring R\ninst‚úù : CommSemiring S\ne : RingEquiv R S\na‚úù : PrimeSpectrum S\n‚ä¢ Eq ((PrimeSpectrum.comapEquiv e).symm a‚úù) (e.toRingHom.specComap a‚úù)","decl":"/-- `RingHom.specComap` of an isomorphism of rings as an equivalence of their prime spectra. -/\n@[simps apply symm_apply]\ndef comapEquiv (e : R ‚âÉ+* S) : PrimeSpectrum R ‚âÉ PrimeSpectrum S where\n  toFun := e.symm.toRingHom.specComap\n  invFun := e.toRingHom.specComap\n  left_inv x := by\n    rw [‚Üê specComap_comp_apply, RingEquiv.toRingHom_eq_coe,\n      RingEquiv.toRingHom_eq_coe, RingEquiv.symm_comp]\n    rfl\n  right_inv x := by\n    rw [‚Üê specComap_comp_apply, RingEquiv.toRingHom_eq_coe,\n      RingEquiv.toRingHom_eq_coe, RingEquiv.comp_symm]\n    rfl\n\n"}
{"name":"PrimeSpectrum.sigmaToPi_asIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"Œπ : Type u_3\nR : Œπ ‚Üí Type u_2\ninst‚úù : (i : Œπ) ‚Üí CommSemiring (R i)\na‚úù : Sigma fun i => PrimeSpectrum (R i)\n‚ä¢ Eq (PrimeSpectrum.sigmaToPi R a‚úù).asIdeal (Ideal.comap (Pi.evalRingHom R a‚úù.fst) a‚úù.snd.asIdeal)","decl":"/-- The canonical map from a disjoint union of prime spectra of commutative semirings to\nthe prime spectrum of the product semiring. -/\n/- TODO: show this is always a topological embedding (even when Œπ is infinite)\nand is a homeomorphism when Œπ is finite. -/\n@[simps] def sigmaToPi : (Œ£ i, PrimeSpectrum (R i)) ‚Üí PrimeSpectrum (Œ† i, R i)\n  | ‚ü®i, p‚ü© => (Pi.evalRingHom R i).specComap p\n\n"}
{"name":"PrimeSpectrum.sigmaToPi_injective","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"Œπ : Type u_3\nR : Œπ ‚Üí Type u_2\ninst‚úù : (i : Œπ) ‚Üí CommSemiring (R i)\n‚ä¢ Function.Injective (PrimeSpectrum.sigmaToPi R)","decl":"theorem sigmaToPi_injective : (sigmaToPi R).Injective := fun ‚ü®i, p‚ü© ‚ü®j, q‚ü© eq ‚Ü¶ by\n  classical\n  obtain rfl | ne := eq_or_ne i j\n  ¬∑ congr; ext x\n    simpa using congr_arg (Function.update (0 : ‚àÄ i, R i) i x ‚àà ¬∑.asIdeal) eq\n  ¬∑ refine (p.1.ne_top_iff_one.mp p.2.ne_top ?_).elim\n    have : Function.update (1 : ‚àÄ i, R i) j 0 ‚àà (sigmaToPi R ‚ü®j, q‚ü©).asIdeal := by simp\n    simpa [‚Üê eq, Function.update_of_ne ne]\n\n"}
{"name":"PrimeSpectrum.exists_maximal_nmem_range_sigmaToPi_of_infinite","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"Œπ : Type u_3\nR : Œπ ‚Üí Type u_2\ninst‚úù¬≤ : (i : Œπ) ‚Üí CommSemiring (R i)\ninst‚úù¬π : Infinite Œπ\ninst‚úù : ‚àÄ (i : Œπ), Nontrivial (R i)\n‚ä¢ Exists fun I => Exists fun x => Not (Membership.mem (Set.range (PrimeSpectrum.sigmaToPi R)) { asIdeal := I, isPrime := ‚ãØ })","decl":"/-- An infinite product of nontrivial commutative semirings has a maximal ideal outside of the\nrange of `sigmaToPi`, i.e. is not of the form `œÄ·µ¢‚Åª¬π(ùî≠)` for some prime `ùî≠ ‚äÇ R i`, where\n`œÄ·µ¢ : (Œ† i, R i) ‚Üí+* R i` is the projection. For a complete description of all prime ideals,\nsee https://math.stackexchange.com/a/1563190. -/\ntheorem exists_maximal_nmem_range_sigmaToPi_of_infinite :\n    ‚àÉ (I : Ideal (Œ† i, R i)) (_ : I.IsMaximal), ‚ü®I, inferInstance‚ü© ‚àâ Set.range (sigmaToPi R) := by\n  classical\n  let J : Ideal (Œ† i, R i) := -- `J := Œ†‚ÇÄ i, R i` is an ideal in `Œ† i, R i`\n  { __ := AddMonoidHom.mrange DFinsupp.coeFnAddMonoidHom\n    smul_mem' := by\n      rintro r _ ‚ü®x, rfl‚ü©\n      refine ‚ü®.mk x.support fun i ‚Ü¶ r i * x i, funext fun i ‚Ü¶ show dite _ _ _ = _ from ?_‚ü©\n      simp_rw [DFinsupp.coeFnAddMonoidHom]\n      refine dite_eq_left_iff.mpr fun h ‚Ü¶ ?_\n      rw [DFinsupp.not_mem_support_iff.mp h, mul_zero] }\n  have ‚ü®I, max, le‚ü© := J.exists_le_maximal <| (Ideal.ne_top_iff_one _).mpr <| by\n    -- take a maximal ideal I containing J\n    rintro ‚ü®x, hx‚ü©\n    have ‚ü®i, hi‚ü© := x.support.exists_not_mem\n    simpa [DFinsupp.coeFnAddMonoidHom, DFinsupp.not_mem_support_iff.mp hi] using congr_fun hx i\n  refine ‚ü®I, max, fun ‚ü®‚ü®i, p‚ü©, eq‚ü© ‚Ü¶ ?_‚ü©\n  -- then I is not in the range of `sigmaToPi`\n  have : ‚áë(DFinsupp.single i 1) ‚àâ (sigmaToPi R ‚ü®i, p‚ü©).asIdeal := by\n    simpa using p.1.ne_top_iff_one.mp p.2.ne_top\n  rw [eq] at this\n  exact this (le ‚ü®.single i 1, rfl‚ü©)\n\n"}
{"name":"PrimeSpectrum.sigmaToPi_not_surjective_of_infinite","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"Œπ : Type u_3\nR : Œπ ‚Üí Type u_2\ninst‚úù¬≤ : (i : Œπ) ‚Üí CommSemiring (R i)\ninst‚úù¬π : Infinite Œπ\ninst‚úù : ‚àÄ (i : Œπ), Nontrivial (R i)\n‚ä¢ Not (Function.Surjective (PrimeSpectrum.sigmaToPi R))","decl":"theorem sigmaToPi_not_surjective_of_infinite : ¬¨ (sigmaToPi R).Surjective := fun surj ‚Ü¶\n  have ‚ü®_, _, nmem‚ü© := exists_maximal_nmem_range_sigmaToPi_of_infinite R\n  (Set.range_eq_univ.mpr surj ‚ñ∏ nmem) ‚ü®‚ü©\n\n"}
{"name":"image_specComap_zeroLocus_eq_zeroLocus_comap","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nf : RingHom R S\nhf : Function.Surjective ‚áëf\nI : Ideal S\n‚ä¢ Eq (Set.image f.specComap (PrimeSpectrum.zeroLocus ‚ÜëI)) (PrimeSpectrum.zeroLocus ‚Üë(Ideal.comap f I))","decl":"theorem image_specComap_zeroLocus_eq_zeroLocus_comap (hf : Surjective f) (I : Ideal S) :\n    f.specComap '' zeroLocus I = zeroLocus (I.comap f) := by\n  simp only [Set.ext_iff, Set.mem_image, mem_zeroLocus, SetLike.coe_subset_coe]\n  refine fun p => ‚ü®?_, fun h_I_p => ?_‚ü©\n  ¬∑ rintro ‚ü®p, hp, rfl‚ü© a ha\n    exact hp ha\n  ¬∑ have hp : ker f ‚â§ p.asIdeal := (Ideal.comap_mono bot_le).trans h_I_p\n    refine ‚ü®‚ü®p.asIdeal.map f, Ideal.map_isPrime_of_surjective hf hp‚ü©, fun x hx => ?_, ?_‚ü©\n    ¬∑ obtain ‚ü®x', rfl‚ü© := hf x\n      exact Ideal.mem_map_of_mem f (h_I_p hx)\n    ¬∑ ext x\n      rw [specComap_asIdeal, Ideal.mem_comap, Ideal.mem_map_iff_of_surjective f hf]\n      refine ‚ü®?_, fun hx => ‚ü®x, hx, rfl‚ü©‚ü©\n      rintro ‚ü®x', hx', heq‚ü©\n      rw [‚Üê sub_sub_cancel x' x]\n      refine p.asIdeal.sub_mem hx' (hp ?_)\n      rwa [mem_ker, map_sub, sub_eq_zero]\n\n"}
{"name":"range_specComap_of_surjective","module":"Mathlib.RingTheory.Spectrum.Prime.Basic","initialProofState":"R : Type u\nS : Type v\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nf : RingHom R S\nhf : Function.Surjective ‚áëf\n‚ä¢ Eq (Set.range f.specComap) (PrimeSpectrum.zeroLocus ‚Üë(RingHom.ker f))","decl":"theorem range_specComap_of_surjective (hf : Surjective f) :\n    Set.range f.specComap = zeroLocus (ker f) := by\n  rw [‚Üê Set.image_univ]\n  convert image_specComap_zeroLocus_eq_zeroLocus_comap _ _ hf _\n  rw [zeroLocus_bot]\n\n"}
