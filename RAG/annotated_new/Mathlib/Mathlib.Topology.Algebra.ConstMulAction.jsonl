{"name":"ContinuousConstSMul.continuous_const_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Γ : Type u_1\nT : Type u_2\ninst✝¹ : TopologicalSpace T\ninst✝ : SMul Γ T\nself : ContinuousConstSMul Γ T\nγ : Γ\n⊢ Continuous fun x => HSMul.hSMul γ x","decl":"/-- Class `ContinuousConstSMul Γ T` says that the scalar multiplication `(•) : Γ → T → T`\nis continuous in the second argument. We use the same class for all kinds of multiplicative\nactions, including (semi)modules and algebras.\n\nNote that both `ContinuousConstSMul α α` and `ContinuousConstSMul αᵐᵒᵖ α` are\nweaker versions of `ContinuousMul α`. -/\nclass ContinuousConstSMul (Γ : Type*) (T : Type*) [TopologicalSpace T] [SMul Γ T] : Prop where\n  /-- The scalar multiplication `(•) : Γ → T → T` is continuous in the second argument. -/\n  continuous_const_smul : ∀ γ : Γ, Continuous fun x : T => γ • x\n\n"}
{"name":"ContinuousConstVAdd.continuous_const_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Γ : Type u_1\nT : Type u_2\ninst✝¹ : TopologicalSpace T\ninst✝ : VAdd Γ T\nself : ContinuousConstVAdd Γ T\nγ : Γ\n⊢ Continuous fun x => HVAdd.hVAdd γ x","decl":"/-- Class `ContinuousConstVAdd Γ T` says that the additive action `(+ᵥ) : Γ → T → T`\nis continuous in the second argument. We use the same class for all kinds of additive actions,\nincluding (semi)modules and algebras.\n\nNote that both `ContinuousConstVAdd α α` and `ContinuousConstVAdd αᵐᵒᵖ α` are\nweaker versions of `ContinuousVAdd α`. -/\nclass ContinuousConstVAdd (Γ : Type*) (T : Type*) [TopologicalSpace T] [VAdd Γ T] : Prop where\n  /-- The additive action `(+ᵥ) : Γ → T → T` is continuous in the second argument. -/\n  continuous_const_vadd : ∀ γ : Γ, Continuous fun x : T => γ +ᵥ x\n\n"}
{"name":"instContinuousConstSMulULift","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : SMul M α\ninst✝ : ContinuousConstSMul M α\n⊢ ContinuousConstSMul (ULift.{u_4, u_1} M) α","decl":"@[to_additive]\ninstance : ContinuousConstSMul (ULift M) α := ⟨fun γ ↦ continuous_const_smul (ULift.down γ)⟩\n\n"}
{"name":"instContinuousConstVAddULift","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : VAdd M α\ninst✝ : ContinuousConstVAdd M α\n⊢ ContinuousConstVAdd (ULift.{u_4, u_1} M) α","decl":"@[to_additive]\ninstance : ContinuousConstSMul (ULift M) α := ⟨fun γ ↦ continuous_const_smul (ULift.down γ)⟩\n\n"}
{"name":"Filter.Tendsto.const_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝² : TopologicalSpace α\ninst✝¹ : VAdd M α\ninst✝ : ContinuousConstVAdd M α\nf : β → α\nl : Filter β\na : α\nhf : Filter.Tendsto f l (nhds a)\nc : M\n⊢ Filter.Tendsto (fun x => HVAdd.hVAdd c (f x)) l (nhds (HVAdd.hVAdd c a))","decl":"@[to_additive]\ntheorem Filter.Tendsto.const_smul {f : β → α} {l : Filter β} {a : α} (hf : Tendsto f l (𝓝 a))\n    (c : M) : Tendsto (fun x => c • f x) l (𝓝 (c • a)) :=\n  ((continuous_const_smul _).tendsto _).comp hf\n\n"}
{"name":"Filter.Tendsto.const_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝² : TopologicalSpace α\ninst✝¹ : SMul M α\ninst✝ : ContinuousConstSMul M α\nf : β → α\nl : Filter β\na : α\nhf : Filter.Tendsto f l (nhds a)\nc : M\n⊢ Filter.Tendsto (fun x => HSMul.hSMul c (f x)) l (nhds (HSMul.hSMul c a))","decl":"@[to_additive]\ntheorem Filter.Tendsto.const_smul {f : β → α} {l : Filter β} {a : α} (hf : Tendsto f l (𝓝 a))\n    (c : M) : Tendsto (fun x => c • f x) l (𝓝 (c • a)) :=\n  ((continuous_const_smul _).tendsto _).comp hf\n\n"}
{"name":"ContinuousWithinAt.const_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : SMul M α\ninst✝¹ : ContinuousConstSMul M α\ninst✝ : TopologicalSpace β\ng : β → α\nb : β\ns : Set β\nhg : ContinuousWithinAt g s b\nc : M\n⊢ ContinuousWithinAt (fun x => HSMul.hSMul c (g x)) s b","decl":"@[to_additive]\nnonrec theorem ContinuousWithinAt.const_smul (hg : ContinuousWithinAt g s b) (c : M) :\n    ContinuousWithinAt (fun x => c • g x) s b :=\n  hg.const_smul c\n\n"}
{"name":"ContinuousWithinAt.const_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : VAdd M α\ninst✝¹ : ContinuousConstVAdd M α\ninst✝ : TopologicalSpace β\ng : β → α\nb : β\ns : Set β\nhg : ContinuousWithinAt g s b\nc : M\n⊢ ContinuousWithinAt (fun x => HVAdd.hVAdd c (g x)) s b","decl":"@[to_additive]\nnonrec theorem ContinuousWithinAt.const_smul (hg : ContinuousWithinAt g s b) (c : M) :\n    ContinuousWithinAt (fun x => c • g x) s b :=\n  hg.const_smul c\n\n"}
{"name":"ContinuousAt.const_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : SMul M α\ninst✝¹ : ContinuousConstSMul M α\ninst✝ : TopologicalSpace β\ng : β → α\nb : β\nhg : ContinuousAt g b\nc : M\n⊢ ContinuousAt (fun x => HSMul.hSMul c (g x)) b","decl":"@[to_additive (attr := fun_prop)]\nnonrec theorem ContinuousAt.const_smul (hg : ContinuousAt g b) (c : M) :\n    ContinuousAt (fun x => c • g x) b :=\n  hg.const_smul c\n\n"}
{"name":"ContinuousAt.const_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : VAdd M α\ninst✝¹ : ContinuousConstVAdd M α\ninst✝ : TopologicalSpace β\ng : β → α\nb : β\nhg : ContinuousAt g b\nc : M\n⊢ ContinuousAt (fun x => HVAdd.hVAdd c (g x)) b","decl":"@[to_additive (attr := fun_prop)]\nnonrec theorem ContinuousAt.const_smul (hg : ContinuousAt g b) (c : M) :\n    ContinuousAt (fun x => c • g x) b :=\n  hg.const_smul c\n\n"}
{"name":"ContinuousOn.const_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : VAdd M α\ninst✝¹ : ContinuousConstVAdd M α\ninst✝ : TopologicalSpace β\ng : β → α\ns : Set β\nhg : ContinuousOn g s\nc : M\n⊢ ContinuousOn (fun x => HVAdd.hVAdd c (g x)) s","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousOn.const_smul (hg : ContinuousOn g s) (c : M) :\n    ContinuousOn (fun x => c • g x) s := fun x hx => (hg x hx).const_smul c\n\n"}
{"name":"ContinuousOn.const_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : SMul M α\ninst✝¹ : ContinuousConstSMul M α\ninst✝ : TopologicalSpace β\ng : β → α\ns : Set β\nhg : ContinuousOn g s\nc : M\n⊢ ContinuousOn (fun x => HSMul.hSMul c (g x)) s","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousOn.const_smul (hg : ContinuousOn g s) (c : M) :\n    ContinuousOn (fun x => c • g x) s := fun x hx => (hg x hx).const_smul c\n\n"}
{"name":"Continuous.const_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : SMul M α\ninst✝¹ : ContinuousConstSMul M α\ninst✝ : TopologicalSpace β\ng : β → α\nhg : Continuous g\nc : M\n⊢ Continuous fun x => HSMul.hSMul c (g x)","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem Continuous.const_smul (hg : Continuous g) (c : M) : Continuous fun x => c • g x :=\n  (continuous_const_smul _).comp hg\n\n"}
{"name":"Continuous.const_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : VAdd M α\ninst✝¹ : ContinuousConstVAdd M α\ninst✝ : TopologicalSpace β\ng : β → α\nhg : Continuous g\nc : M\n⊢ Continuous fun x => HVAdd.hVAdd c (g x)","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem Continuous.const_smul (hg : Continuous g) (c : M) : Continuous fun x => c • g x :=\n  (continuous_const_smul _).comp hg\n\n"}
{"name":"ContinuousConstSMul.op","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : SMul M α\ninst✝¹ : SMul (MulOpposite M) α\ninst✝ : IsCentralScalar M α\n⊢ ContinuousConstSMul (MulOpposite M) α","decl":"/-- If a scalar is central, then its right action is continuous when its left action is. -/\n@[to_additive \"If an additive action is central, then its right action is continuous when its left\naction is.\"]\ninstance ContinuousConstSMul.op [SMul Mᵐᵒᵖ α] [IsCentralScalar M α] :\n    ContinuousConstSMul Mᵐᵒᵖ α :=\n  ⟨MulOpposite.rec' fun c => by simpa only [op_smul_eq_smul] using continuous_const_smul c⟩\n\n"}
{"name":"ContinuousConstVAdd.op","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : VAdd M α\ninst✝¹ : VAdd (AddOpposite M) α\ninst✝ : IsCentralVAdd M α\n⊢ ContinuousConstVAdd (AddOpposite M) α","decl":"/-- If a scalar is central, then its right action is continuous when its left action is. -/\n@[to_additive \"If an additive action is central, then its right action is continuous when its left\naction is.\"]\ninstance ContinuousConstSMul.op [SMul Mᵐᵒᵖ α] [IsCentralScalar M α] :\n    ContinuousConstSMul Mᵐᵒᵖ α :=\n  ⟨MulOpposite.rec' fun c => by simpa only [op_smul_eq_smul] using continuous_const_smul c⟩\n\n"}
{"name":"MulOpposite.continuousConstSMul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : SMul M α\ninst✝ : ContinuousConstSMul M α\n⊢ ContinuousConstSMul M (MulOpposite α)","decl":"@[to_additive]\ninstance MulOpposite.continuousConstSMul : ContinuousConstSMul M αᵐᵒᵖ :=\n  ⟨fun c => MulOpposite.continuous_op.comp <| MulOpposite.continuous_unop.const_smul c⟩\n\n"}
{"name":"AddOpposite.continuousConstVAdd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : VAdd M α\ninst✝ : ContinuousConstVAdd M α\n⊢ ContinuousConstVAdd M (AddOpposite α)","decl":"@[to_additive]\ninstance MulOpposite.continuousConstSMul : ContinuousConstSMul M αᵐᵒᵖ :=\n  ⟨fun c => MulOpposite.continuous_op.comp <| MulOpposite.continuous_unop.const_smul c⟩\n\n"}
{"name":"instContinuousConstSMulOrderDual","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : SMul M α\n⊢ ContinuousConstSMul M (OrderDual α)","decl":"@[to_additive]\ninstance : ContinuousConstSMul M αᵒᵈ := ‹ContinuousConstSMul M α›\n\n"}
{"name":"instContinuousConstVAddOrderDual","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : VAdd M α\n⊢ ContinuousConstVAdd M (OrderDual α)","decl":"@[to_additive]\ninstance : ContinuousConstSMul M αᵒᵈ := ‹ContinuousConstSMul M α›\n\n"}
{"name":"OrderDual.continuousConstSMul'","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : SMul M α\n⊢ ContinuousConstSMul (OrderDual M) α","decl":"@[to_additive]\ninstance OrderDual.continuousConstSMul' : ContinuousConstSMul Mᵒᵈ α :=\n  ‹ContinuousConstSMul M α›\n\n"}
{"name":"OrderDual.continuousConstVAdd'","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : VAdd M α\n⊢ ContinuousConstVAdd (OrderDual M) α","decl":"@[to_additive]\ninstance OrderDual.continuousConstSMul' : ContinuousConstSMul Mᵒᵈ α :=\n  ‹ContinuousConstSMul M α›\n\n"}
{"name":"Prod.continuousConstVAdd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : VAdd M α\ninst✝³ : ContinuousConstVAdd M α\ninst✝² : TopologicalSpace β\ninst✝¹ : VAdd M β\ninst✝ : ContinuousConstVAdd M β\n⊢ ContinuousConstVAdd M (Prod α β)","decl":"@[to_additive]\ninstance Prod.continuousConstSMul [SMul M β] [ContinuousConstSMul M β] :\n    ContinuousConstSMul M (α × β) :=\n  ⟨fun _ => (continuous_fst.const_smul _).prod_mk (continuous_snd.const_smul _)⟩\n\n"}
{"name":"Prod.continuousConstSMul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : SMul M α\ninst✝³ : ContinuousConstSMul M α\ninst✝² : TopologicalSpace β\ninst✝¹ : SMul M β\ninst✝ : ContinuousConstSMul M β\n⊢ ContinuousConstSMul M (Prod α β)","decl":"@[to_additive]\ninstance Prod.continuousConstSMul [SMul M β] [ContinuousConstSMul M β] :\n    ContinuousConstSMul M (α × β) :=\n  ⟨fun _ => (continuous_fst.const_smul _).prod_mk (continuous_snd.const_smul _)⟩\n\n"}
{"name":"instContinuousConstVAddForall","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nι : Type u_4\nγ : ι → Type u_5\ninst✝² : (i : ι) → TopologicalSpace (γ i)\ninst✝¹ : (i : ι) → VAdd M (γ i)\ninst✝ : ∀ (i : ι), ContinuousConstVAdd M (γ i)\n⊢ ContinuousConstVAdd M ((i : ι) → γ i)","decl":"@[to_additive]\ninstance {ι : Type*} {γ : ι → Type*} [∀ i, TopologicalSpace (γ i)] [∀ i, SMul M (γ i)]\n    [∀ i, ContinuousConstSMul M (γ i)] : ContinuousConstSMul M (∀ i, γ i) :=\n  ⟨fun _ => continuous_pi fun i => (continuous_apply i).const_smul _⟩\n\n"}
{"name":"instContinuousConstSMulForall","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nι : Type u_4\nγ : ι → Type u_5\ninst✝² : (i : ι) → TopologicalSpace (γ i)\ninst✝¹ : (i : ι) → SMul M (γ i)\ninst✝ : ∀ (i : ι), ContinuousConstSMul M (γ i)\n⊢ ContinuousConstSMul M ((i : ι) → γ i)","decl":"@[to_additive]\ninstance {ι : Type*} {γ : ι → Type*} [∀ i, TopologicalSpace (γ i)] [∀ i, SMul M (γ i)]\n    [∀ i, ContinuousConstSMul M (γ i)] : ContinuousConstSMul M (∀ i, γ i) :=\n  ⟨fun _ => continuous_pi fun i => (continuous_apply i).const_smul _⟩\n\n"}
{"name":"IsCompact.vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝² : VAdd α β\ninst✝¹ : TopologicalSpace β\ninst✝ : ContinuousConstVAdd α β\na : α\ns : Set β\nhs : IsCompact s\n⊢ IsCompact (HVAdd.hVAdd a s)","decl":"@[to_additive]\ntheorem IsCompact.smul {α β} [SMul α β] [TopologicalSpace β] [ContinuousConstSMul α β] (a : α)\n    {s : Set β} (hs : IsCompact s) : IsCompact (a • s) :=\n  hs.image (continuous_id.const_smul a)\n\n"}
{"name":"IsCompact.smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝² : SMul α β\ninst✝¹ : TopologicalSpace β\ninst✝ : ContinuousConstSMul α β\na : α\ns : Set β\nhs : IsCompact s\n⊢ IsCompact (HSMul.hSMul a s)","decl":"@[to_additive]\ntheorem IsCompact.smul {α β} [SMul α β] [TopologicalSpace β] [ContinuousConstSMul α β] (a : α)\n    {s : Set β} (hs : IsCompact s) : IsCompact (a • s) :=\n  hs.image (continuous_id.const_smul a)\n\n"}
{"name":"Specializes.const_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : VAdd M α\ninst✝ : ContinuousConstVAdd M α\nx y : α\nh : Specializes x y\nc : M\n⊢ Specializes (HVAdd.hVAdd c x) (HVAdd.hVAdd c y)","decl":"@[to_additive]\ntheorem Specializes.const_smul {x y : α} (h : x ⤳ y) (c : M) : (c • x) ⤳ (c • y) :=\n  h.map (continuous_const_smul c)\n\n"}
{"name":"Specializes.const_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : SMul M α\ninst✝ : ContinuousConstSMul M α\nx y : α\nh : Specializes x y\nc : M\n⊢ Specializes (HSMul.hSMul c x) (HSMul.hSMul c y)","decl":"@[to_additive]\ntheorem Specializes.const_smul {x y : α} (h : x ⤳ y) (c : M) : (c • x) ⤳ (c • y) :=\n  h.map (continuous_const_smul c)\n\n"}
{"name":"Inseparable.const_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : SMul M α\ninst✝ : ContinuousConstSMul M α\nx y : α\nh : Inseparable x y\nc : M\n⊢ Inseparable (HSMul.hSMul c x) (HSMul.hSMul c y)","decl":"@[to_additive]\ntheorem Inseparable.const_smul {x y : α} (h : Inseparable x y) (c : M) :\n    Inseparable (c • x) (c • y) :=\n  h.map (continuous_const_smul c)\n\n"}
{"name":"Inseparable.const_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : VAdd M α\ninst✝ : ContinuousConstVAdd M α\nx y : α\nh : Inseparable x y\nc : M\n⊢ Inseparable (HVAdd.hVAdd c x) (HVAdd.hVAdd c y)","decl":"@[to_additive]\ntheorem Inseparable.const_smul {x y : α} (h : Inseparable x y) (c : M) :\n    Inseparable (c • x) (c • y) :=\n  h.map (continuous_const_smul c)\n\n"}
{"name":"Topology.IsInducing.continuousConstVAdd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝⁴ : TopologicalSpace α\ninst✝³ : VAdd M α\ninst✝² : ContinuousConstVAdd M α\nN : Type u_4\nβ : Type u_5\ninst✝¹ : VAdd N β\ninst✝ : TopologicalSpace β\ng : β → α\nhg : Topology.IsInducing g\nf : N → M\nhf : ∀ {c : N} {x : β}, Eq (g (HVAdd.hVAdd c x)) (HVAdd.hVAdd (f c) (g x))\n⊢ ContinuousConstVAdd N β","decl":"@[to_additive]\ntheorem Topology.IsInducing.continuousConstSMul {N β : Type*} [SMul N β] [TopologicalSpace β]\n    {g : β → α} (hg : IsInducing g) (f : N → M) (hf : ∀ {c : N} {x : β}, g (c • x) = f c • g x) :\n    ContinuousConstSMul N β where\n  continuous_const_smul c := by\n    simpa only [Function.comp_def, hf, hg.continuous_iff] using hg.continuous.const_smul (f c)\n\n"}
{"name":"Topology.IsInducing.continuousConstSMul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝⁴ : TopologicalSpace α\ninst✝³ : SMul M α\ninst✝² : ContinuousConstSMul M α\nN : Type u_4\nβ : Type u_5\ninst✝¹ : SMul N β\ninst✝ : TopologicalSpace β\ng : β → α\nhg : Topology.IsInducing g\nf : N → M\nhf : ∀ {c : N} {x : β}, Eq (g (HSMul.hSMul c x)) (HSMul.hSMul (f c) (g x))\n⊢ ContinuousConstSMul N β","decl":"@[to_additive]\ntheorem Topology.IsInducing.continuousConstSMul {N β : Type*} [SMul N β] [TopologicalSpace β]\n    {g : β → α} (hg : IsInducing g) (f : N → M) (hf : ∀ {c : N} {x : β}, g (c • x) = f c • g x) :\n    ContinuousConstSMul N β where\n  continuous_const_smul c := by\n    simpa only [Function.comp_def, hf, hg.continuous_iff] using hg.continuous.const_smul (f c)\n\n"}
{"name":"Inducing.continuousConstSMul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝⁴ : TopologicalSpace α\ninst✝³ : SMul M α\ninst✝² : ContinuousConstSMul M α\nN : Type u_4\nβ : Type u_5\ninst✝¹ : SMul N β\ninst✝ : TopologicalSpace β\ng : β → α\nhg : Topology.IsInducing g\nf : N → M\nhf : ∀ {c : N} {x : β}, Eq (g (HSMul.hSMul c x)) (HSMul.hSMul (f c) (g x))\n⊢ ContinuousConstSMul N β","decl":"@[deprecated (since := \"2024-10-28\")]\nalias Inducing.continuousConstSMul := IsInducing.continuousConstSMul\n\n"}
{"name":"Units.continuousConstSMul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : Monoid M\ninst✝¹ : MulAction M α\ninst✝ : ContinuousConstSMul M α\n⊢ ContinuousConstSMul (Units M) α","decl":"@[to_additive]\ninstance Units.continuousConstSMul : ContinuousConstSMul Mˣ α where\n  continuous_const_smul m := continuous_const_smul (m : M)\n\n"}
{"name":"AddUnits.continuousConstVAdd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : AddMonoid M\ninst✝¹ : AddAction M α\ninst✝ : ContinuousConstVAdd M α\n⊢ ContinuousConstVAdd (AddUnits M) α","decl":"@[to_additive]\ninstance Units.continuousConstSMul : ContinuousConstSMul Mˣ α where\n  continuous_const_smul m := continuous_const_smul (m : M)\n\n"}
{"name":"vadd_closure_subset","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : AddMonoid M\ninst✝¹ : AddAction M α\ninst✝ : ContinuousConstVAdd M α\nc : M\ns : Set α\n⊢ HasSubset.Subset (HVAdd.hVAdd c (closure s)) (closure (HVAdd.hVAdd c s))","decl":"@[to_additive]\ntheorem smul_closure_subset (c : M) (s : Set α) : c • closure s ⊆ closure (c • s) :=\n  ((Set.mapsTo_image _ _).closure <| continuous_const_smul c).image_subset\n\n"}
{"name":"smul_closure_subset","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : Monoid M\ninst✝¹ : MulAction M α\ninst✝ : ContinuousConstSMul M α\nc : M\ns : Set α\n⊢ HasSubset.Subset (HSMul.hSMul c (closure s)) (closure (HSMul.hSMul c s))","decl":"@[to_additive]\ntheorem smul_closure_subset (c : M) (s : Set α) : c • closure s ⊆ closure (c • s) :=\n  ((Set.mapsTo_image _ _).closure <| continuous_const_smul c).image_subset\n\n"}
{"name":"vadd_closure_orbit_subset","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : AddMonoid M\ninst✝¹ : AddAction M α\ninst✝ : ContinuousConstVAdd M α\nc : M\nx : α\n⊢ HasSubset.Subset (HVAdd.hVAdd c (closure (AddAction.orbit M x))) (closure (AddAction.orbit M x))","decl":"@[to_additive]\ntheorem smul_closure_orbit_subset (c : M) (x : α) :\n    c • closure (MulAction.orbit M x) ⊆ closure (MulAction.orbit M x) :=\n  (smul_closure_subset c _).trans <| closure_mono <| MulAction.smul_orbit_subset _ _\n\n"}
{"name":"smul_closure_orbit_subset","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : Monoid M\ninst✝¹ : MulAction M α\ninst✝ : ContinuousConstSMul M α\nc : M\nx : α\n⊢ HasSubset.Subset (HSMul.hSMul c (closure (MulAction.orbit M x))) (closure (MulAction.orbit M x))","decl":"@[to_additive]\ntheorem smul_closure_orbit_subset (c : M) (x : α) :\n    c • closure (MulAction.orbit M x) ⊆ closure (MulAction.orbit M x) :=\n  (smul_closure_subset c _).trans <| closure_mono <| MulAction.smul_orbit_subset _ _\n\n"}
{"name":"isClosed_setOf_map_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\ninst✝⁶ : Monoid M\nN : Type u_4\ninst✝⁵ : Monoid N\nα : Type u_5\nβ : Type u_6\ninst✝⁴ : MulAction M α\ninst✝³ : MulAction N β\ninst✝² : TopologicalSpace β\ninst✝¹ : T2Space β\ninst✝ : ContinuousConstSMul N β\nσ : M → N\n⊢ IsClosed (setOf fun f => ∀ (c : M) (x : α), Eq (f (HSMul.hSMul c x)) (HSMul.hSMul (σ c) (f x)))","decl":"theorem isClosed_setOf_map_smul {N : Type*} [Monoid N] (α β) [MulAction M α] [MulAction N β]\n    [TopologicalSpace β] [T2Space β] [ContinuousConstSMul N β] (σ : M → N) :\n    IsClosed { f : α → β | ∀ c x, f (c • x) = σ c • f x } := by\n  simp only [Set.setOf_forall]\n  exact isClosed_iInter fun c => isClosed_iInter fun x =>\n    isClosed_eq (continuous_apply _) ((continuous_apply _).const_smul _)\n\n"}
{"name":"tendsto_const_vadd_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nβ : Type u_3\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : ContinuousConstVAdd G α\nf : β → α\nl : Filter β\na : α\nc : G\n⊢ Iff (Filter.Tendsto (fun x => HVAdd.hVAdd c (f x)) l (nhds (HVAdd.hVAdd c a))) (Filter.Tendsto f l (nhds a))","decl":"@[to_additive]\ntheorem tendsto_const_smul_iff {f : β → α} {l : Filter β} {a : α} (c : G) :\n    Tendsto (fun x => c • f x) l (𝓝 <| c • a) ↔ Tendsto f l (𝓝 a) :=\n  ⟨fun h => by simpa only [inv_smul_smul] using h.const_smul c⁻¹, fun h => h.const_smul _⟩\n\n"}
{"name":"tendsto_const_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nβ : Type u_3\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : ContinuousConstSMul G α\nf : β → α\nl : Filter β\na : α\nc : G\n⊢ Iff (Filter.Tendsto (fun x => HSMul.hSMul c (f x)) l (nhds (HSMul.hSMul c a))) (Filter.Tendsto f l (nhds a))","decl":"@[to_additive]\ntheorem tendsto_const_smul_iff {f : β → α} {l : Filter β} {a : α} (c : G) :\n    Tendsto (fun x => c • f x) l (𝓝 <| c • a) ↔ Tendsto f l (𝓝 a) :=\n  ⟨fun h => by simpa only [inv_smul_smul] using h.const_smul c⁻¹, fun h => h.const_smul _⟩\n\n"}
{"name":"continuousWithinAt_const_vadd_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nβ : Type u_3\nG : Type u_4\ninst✝⁴ : TopologicalSpace α\ninst✝³ : AddGroup G\ninst✝² : AddAction G α\ninst✝¹ : ContinuousConstVAdd G α\ninst✝ : TopologicalSpace β\nf : β → α\nb : β\ns : Set β\nc : G\n⊢ Iff (ContinuousWithinAt (fun x => HVAdd.hVAdd c (f x)) s b) (ContinuousWithinAt f s b)","decl":"@[to_additive]\ntheorem continuousWithinAt_const_smul_iff (c : G) :\n    ContinuousWithinAt (fun x => c • f x) s b ↔ ContinuousWithinAt f s b :=\n  tendsto_const_smul_iff c\n\n"}
{"name":"continuousWithinAt_const_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nβ : Type u_3\nG : Type u_4\ninst✝⁴ : TopologicalSpace α\ninst✝³ : Group G\ninst✝² : MulAction G α\ninst✝¹ : ContinuousConstSMul G α\ninst✝ : TopologicalSpace β\nf : β → α\nb : β\ns : Set β\nc : G\n⊢ Iff (ContinuousWithinAt (fun x => HSMul.hSMul c (f x)) s b) (ContinuousWithinAt f s b)","decl":"@[to_additive]\ntheorem continuousWithinAt_const_smul_iff (c : G) :\n    ContinuousWithinAt (fun x => c • f x) s b ↔ ContinuousWithinAt f s b :=\n  tendsto_const_smul_iff c\n\n"}
{"name":"continuousOn_const_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nβ : Type u_3\nG : Type u_4\ninst✝⁴ : TopologicalSpace α\ninst✝³ : Group G\ninst✝² : MulAction G α\ninst✝¹ : ContinuousConstSMul G α\ninst✝ : TopologicalSpace β\nf : β → α\ns : Set β\nc : G\n⊢ Iff (ContinuousOn (fun x => HSMul.hSMul c (f x)) s) (ContinuousOn f s)","decl":"@[to_additive]\ntheorem continuousOn_const_smul_iff (c : G) :\n    ContinuousOn (fun x => c • f x) s ↔ ContinuousOn f s :=\n  forall₂_congr fun _ _ => continuousWithinAt_const_smul_iff c\n\n"}
{"name":"continuousOn_const_vadd_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nβ : Type u_3\nG : Type u_4\ninst✝⁴ : TopologicalSpace α\ninst✝³ : AddGroup G\ninst✝² : AddAction G α\ninst✝¹ : ContinuousConstVAdd G α\ninst✝ : TopologicalSpace β\nf : β → α\ns : Set β\nc : G\n⊢ Iff (ContinuousOn (fun x => HVAdd.hVAdd c (f x)) s) (ContinuousOn f s)","decl":"@[to_additive]\ntheorem continuousOn_const_smul_iff (c : G) :\n    ContinuousOn (fun x => c • f x) s ↔ ContinuousOn f s :=\n  forall₂_congr fun _ _ => continuousWithinAt_const_smul_iff c\n\n"}
{"name":"continuousAt_const_vadd_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nβ : Type u_3\nG : Type u_4\ninst✝⁴ : TopologicalSpace α\ninst✝³ : AddGroup G\ninst✝² : AddAction G α\ninst✝¹ : ContinuousConstVAdd G α\ninst✝ : TopologicalSpace β\nf : β → α\nb : β\nc : G\n⊢ Iff (ContinuousAt (fun x => HVAdd.hVAdd c (f x)) b) (ContinuousAt f b)","decl":"@[to_additive]\ntheorem continuousAt_const_smul_iff (c : G) :\n    ContinuousAt (fun x => c • f x) b ↔ ContinuousAt f b :=\n  tendsto_const_smul_iff c\n\n"}
{"name":"continuousAt_const_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nβ : Type u_3\nG : Type u_4\ninst✝⁴ : TopologicalSpace α\ninst✝³ : Group G\ninst✝² : MulAction G α\ninst✝¹ : ContinuousConstSMul G α\ninst✝ : TopologicalSpace β\nf : β → α\nb : β\nc : G\n⊢ Iff (ContinuousAt (fun x => HSMul.hSMul c (f x)) b) (ContinuousAt f b)","decl":"@[to_additive]\ntheorem continuousAt_const_smul_iff (c : G) :\n    ContinuousAt (fun x => c • f x) b ↔ ContinuousAt f b :=\n  tendsto_const_smul_iff c\n\n"}
{"name":"continuous_const_vadd_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nβ : Type u_3\nG : Type u_4\ninst✝⁴ : TopologicalSpace α\ninst✝³ : AddGroup G\ninst✝² : AddAction G α\ninst✝¹ : ContinuousConstVAdd G α\ninst✝ : TopologicalSpace β\nf : β → α\nc : G\n⊢ Iff (Continuous fun x => HVAdd.hVAdd c (f x)) (Continuous f)","decl":"@[to_additive]\ntheorem continuous_const_smul_iff (c : G) : (Continuous fun x => c • f x) ↔ Continuous f := by\n  simp only [continuous_iff_continuousAt, continuousAt_const_smul_iff]\n\n"}
{"name":"continuous_const_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nβ : Type u_3\nG : Type u_4\ninst✝⁴ : TopologicalSpace α\ninst✝³ : Group G\ninst✝² : MulAction G α\ninst✝¹ : ContinuousConstSMul G α\ninst✝ : TopologicalSpace β\nf : β → α\nc : G\n⊢ Iff (Continuous fun x => HSMul.hSMul c (f x)) (Continuous f)","decl":"@[to_additive]\ntheorem continuous_const_smul_iff (c : G) : (Continuous fun x => c • f x) ↔ Continuous f := by\n  simp only [continuous_iff_continuousAt, continuousAt_const_smul_iff]\n\n"}
{"name":"Homeomorph.smul_apply","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : ContinuousConstSMul G α\nγ : G\nx : α\n⊢ Eq ((Homeomorph.smul γ) x) (HSMul.hSMul γ x)","decl":"/-- The homeomorphism given by scalar multiplication by a given element of a group `Γ` acting on\n  `T` is a homeomorphism from `T` to itself. -/\n@[to_additive (attr := simps!)]\ndef Homeomorph.smul (γ : G) : α ≃ₜ α where\n  toEquiv := MulAction.toPerm γ\n  continuous_toFun := continuous_const_smul γ\n  continuous_invFun := continuous_const_smul γ⁻¹\n\n"}
{"name":"Homeomorph.vadd_apply","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : ContinuousConstVAdd G α\nγ : G\nx : α\n⊢ Eq ((Homeomorph.vadd γ) x) (HVAdd.hVAdd γ x)","decl":"/-- The homeomorphism given by scalar multiplication by a given element of a group `Γ` acting on\n  `T` is a homeomorphism from `T` to itself. -/\n@[to_additive (attr := simps!)]\ndef Homeomorph.smul (γ : G) : α ≃ₜ α where\n  toEquiv := MulAction.toPerm γ\n  continuous_toFun := continuous_const_smul γ\n  continuous_invFun := continuous_const_smul γ⁻¹\n\n"}
{"name":"Homeomorph.vadd_symm_apply","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : ContinuousConstVAdd G α\nγ : G\nx : α\n⊢ Eq ((Homeomorph.vadd γ).symm x) (HVAdd.hVAdd (Neg.neg γ) x)","decl":"/-- The homeomorphism given by scalar multiplication by a given element of a group `Γ` acting on\n  `T` is a homeomorphism from `T` to itself. -/\n@[to_additive (attr := simps!)]\ndef Homeomorph.smul (γ : G) : α ≃ₜ α where\n  toEquiv := MulAction.toPerm γ\n  continuous_toFun := continuous_const_smul γ\n  continuous_invFun := continuous_const_smul γ⁻¹\n\n"}
{"name":"Homeomorph.smul_symm_apply","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : ContinuousConstSMul G α\nγ : G\nx : α\n⊢ Eq ((Homeomorph.smul γ).symm x) (HSMul.hSMul (Inv.inv γ) x)","decl":"/-- The homeomorphism given by scalar multiplication by a given element of a group `Γ` acting on\n  `T` is a homeomorphism from `T` to itself. -/\n@[to_additive (attr := simps!)]\ndef Homeomorph.smul (γ : G) : α ≃ₜ α where\n  toEquiv := MulAction.toPerm γ\n  continuous_toFun := continuous_const_smul γ\n  continuous_invFun := continuous_const_smul γ⁻¹\n\n"}
{"name":"isOpenMap_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : ContinuousConstVAdd G α\nc : G\n⊢ IsOpenMap fun x => HVAdd.hVAdd c x","decl":"@[to_additive]\ntheorem isOpenMap_smul (c : G) : IsOpenMap fun x : α => c • x :=\n  (Homeomorph.smul c).isOpenMap\n\n"}
{"name":"isOpenMap_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : ContinuousConstSMul G α\nc : G\n⊢ IsOpenMap fun x => HSMul.hSMul c x","decl":"@[to_additive]\ntheorem isOpenMap_smul (c : G) : IsOpenMap fun x : α => c • x :=\n  (Homeomorph.smul c).isOpenMap\n\n"}
{"name":"IsOpen.smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : ContinuousConstSMul G α\ns : Set α\nhs : IsOpen s\nc : G\n⊢ IsOpen (HSMul.hSMul c s)","decl":"@[to_additive]\ntheorem IsOpen.smul {s : Set α} (hs : IsOpen s) (c : G) : IsOpen (c • s) :=\n  isOpenMap_smul c s hs\n\n"}
{"name":"IsOpen.vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : ContinuousConstVAdd G α\ns : Set α\nhs : IsOpen s\nc : G\n⊢ IsOpen (HVAdd.hVAdd c s)","decl":"@[to_additive]\ntheorem IsOpen.smul {s : Set α} (hs : IsOpen s) (c : G) : IsOpen (c • s) :=\n  isOpenMap_smul c s hs\n\n"}
{"name":"isClosedMap_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : ContinuousConstVAdd G α\nc : G\n⊢ IsClosedMap fun x => HVAdd.hVAdd c x","decl":"@[to_additive]\ntheorem isClosedMap_smul (c : G) : IsClosedMap fun x : α => c • x :=\n  (Homeomorph.smul c).isClosedMap\n\n"}
{"name":"isClosedMap_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : ContinuousConstSMul G α\nc : G\n⊢ IsClosedMap fun x => HSMul.hSMul c x","decl":"@[to_additive]\ntheorem isClosedMap_smul (c : G) : IsClosedMap fun x : α => c • x :=\n  (Homeomorph.smul c).isClosedMap\n\n"}
{"name":"IsClosed.vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : ContinuousConstVAdd G α\ns : Set α\nhs : IsClosed s\nc : G\n⊢ IsClosed (HVAdd.hVAdd c s)","decl":"@[to_additive]\ntheorem IsClosed.smul {s : Set α} (hs : IsClosed s) (c : G) : IsClosed (c • s) :=\n  isClosedMap_smul c s hs\n\n"}
{"name":"IsClosed.smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : ContinuousConstSMul G α\ns : Set α\nhs : IsClosed s\nc : G\n⊢ IsClosed (HSMul.hSMul c s)","decl":"@[to_additive]\ntheorem IsClosed.smul {s : Set α} (hs : IsClosed s) (c : G) : IsClosed (c • s) :=\n  isClosedMap_smul c s hs\n\n"}
{"name":"closure_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : ContinuousConstVAdd G α\nc : G\ns : Set α\n⊢ Eq (closure (HVAdd.hVAdd c s)) (HVAdd.hVAdd c (closure s))","decl":"@[to_additive]\ntheorem closure_smul (c : G) (s : Set α) : closure (c • s) = c • closure s :=\n  ((Homeomorph.smul c).image_closure s).symm\n\n"}
{"name":"closure_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : ContinuousConstSMul G α\nc : G\ns : Set α\n⊢ Eq (closure (HSMul.hSMul c s)) (HSMul.hSMul c (closure s))","decl":"@[to_additive]\ntheorem closure_smul (c : G) (s : Set α) : closure (c • s) = c • closure s :=\n  ((Homeomorph.smul c).image_closure s).symm\n\n"}
{"name":"Dense.vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : ContinuousConstVAdd G α\nc : G\ns : Set α\nhs : Dense s\n⊢ Dense (HVAdd.hVAdd c s)","decl":"@[to_additive]\ntheorem Dense.smul (c : G) {s : Set α} (hs : Dense s) : Dense (c • s) := by\n  rw [dense_iff_closure_eq] at hs ⊢; rw [closure_smul, hs, smul_set_univ]\n\n"}
{"name":"Dense.smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : ContinuousConstSMul G α\nc : G\ns : Set α\nhs : Dense s\n⊢ Dense (HSMul.hSMul c s)","decl":"@[to_additive]\ntheorem Dense.smul (c : G) {s : Set α} (hs : Dense s) : Dense (c • s) := by\n  rw [dense_iff_closure_eq] at hs ⊢; rw [closure_smul, hs, smul_set_univ]\n\n"}
{"name":"interior_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : ContinuousConstSMul G α\nc : G\ns : Set α\n⊢ Eq (interior (HSMul.hSMul c s)) (HSMul.hSMul c (interior s))","decl":"@[to_additive]\ntheorem interior_smul (c : G) (s : Set α) : interior (c • s) = c • interior s :=\n  ((Homeomorph.smul c).image_interior s).symm\n\n"}
{"name":"interior_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : ContinuousConstVAdd G α\nc : G\ns : Set α\n⊢ Eq (interior (HVAdd.hVAdd c s)) (HVAdd.hVAdd c (interior s))","decl":"@[to_additive]\ntheorem interior_smul (c : G) (s : Set α) : interior (c • s) = c • interior s :=\n  ((Homeomorph.smul c).image_interior s).symm\n\n"}
{"name":"IsOpen.vadd_left","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : ContinuousConstVAdd G α\ns : Set G\nt : Set α\nht : IsOpen t\n⊢ IsOpen (HVAdd.hVAdd s t)","decl":"@[to_additive]\ntheorem IsOpen.smul_left {s : Set G} {t : Set α} (ht : IsOpen t) : IsOpen (s • t) := by\n  rw [← iUnion_smul_set]\n  exact isOpen_biUnion fun a _ => ht.smul _\n\n"}
{"name":"IsOpen.smul_left","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : ContinuousConstSMul G α\ns : Set G\nt : Set α\nht : IsOpen t\n⊢ IsOpen (HSMul.hSMul s t)","decl":"@[to_additive]\ntheorem IsOpen.smul_left {s : Set G} {t : Set α} (ht : IsOpen t) : IsOpen (s • t) := by\n  rw [← iUnion_smul_set]\n  exact isOpen_biUnion fun a _ => ht.smul _\n\n"}
{"name":"subset_interior_vadd_right","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : ContinuousConstVAdd G α\ns : Set G\nt : Set α\n⊢ HasSubset.Subset (HVAdd.hVAdd s (interior t)) (interior (HVAdd.hVAdd s t))","decl":"@[to_additive]\ntheorem subset_interior_smul_right {s : Set G} {t : Set α} : s • interior t ⊆ interior (s • t) :=\n  interior_maximal (Set.smul_subset_smul_left interior_subset) isOpen_interior.smul_left\n\n"}
{"name":"subset_interior_smul_right","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : ContinuousConstSMul G α\ns : Set G\nt : Set α\n⊢ HasSubset.Subset (HSMul.hSMul s (interior t)) (interior (HSMul.hSMul s t))","decl":"@[to_additive]\ntheorem subset_interior_smul_right {s : Set G} {t : Set α} : s • interior t ⊆ interior (s • t) :=\n  interior_maximal (Set.smul_subset_smul_left interior_subset) isOpen_interior.smul_left\n\n"}
{"name":"vadd_mem_nhds_vadd_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : ContinuousConstVAdd G α\nt : Set α\ng : G\na : α\n⊢ Iff (Membership.mem (nhds (HVAdd.hVAdd g a)) (HVAdd.hVAdd g t)) (Membership.mem (nhds a) t)","decl":"@[to_additive (attr := simp)]\ntheorem smul_mem_nhds_smul_iff {t : Set α} (g : G) {a : α} : g • t ∈ 𝓝 (g • a) ↔ t ∈ 𝓝 a :=\n  (Homeomorph.smul g).isOpenEmbedding.image_mem_nhds\n\n"}
{"name":"smul_mem_nhds_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : ContinuousConstSMul G α\nt : Set α\ng : G\na : α\n⊢ Iff (Membership.mem (nhds (HSMul.hSMul g a)) (HSMul.hSMul g t)) (Membership.mem (nhds a) t)","decl":"@[to_additive (attr := simp)]\ntheorem smul_mem_nhds_smul_iff {t : Set α} (g : G) {a : α} : g • t ∈ 𝓝 (g • a) ↔ t ∈ 𝓝 a :=\n  (Homeomorph.smul g).isOpenEmbedding.image_mem_nhds\n\n"}
{"name":"smul_mem_nhds_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : ContinuousConstSMul G α\nt : Set α\ng : G\na : α\na✝ : Membership.mem (nhds a) t\n⊢ Membership.mem (nhds (HSMul.hSMul g a)) (HSMul.hSMul g t)","decl":"@[to_additive] alias ⟨_, smul_mem_nhds_smul⟩ := smul_mem_nhds_smul_iff\n\n"}
{"name":"vadd_mem_nhds_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : ContinuousConstVAdd G α\nt : Set α\ng : G\na : α\na✝ : Membership.mem (nhds a) t\n⊢ Membership.mem (nhds (HVAdd.hVAdd g a)) (HVAdd.hVAdd g t)","decl":"@[to_additive] alias ⟨_, smul_mem_nhds_smul⟩ := smul_mem_nhds_smul_iff\n\n"}
{"name":"vadd_mem_nhds","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : ContinuousConstVAdd G α\nt : Set α\ng : G\na : α\na✝ : Membership.mem (nhds a) t\n⊢ Membership.mem (nhds (HVAdd.hVAdd g a)) (HVAdd.hVAdd g t)","decl":"@[to_additive (attr := deprecated \"No deprecation message was provided.\" (since := \"2024-08-06\"))]\nalias smul_mem_nhds := smul_mem_nhds_smul\n\n"}
{"name":"smul_mem_nhds","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : ContinuousConstSMul G α\nt : Set α\ng : G\na : α\na✝ : Membership.mem (nhds a) t\n⊢ Membership.mem (nhds (HSMul.hSMul g a)) (HSMul.hSMul g t)","decl":"@[to_additive (attr := deprecated \"No deprecation message was provided.\" (since := \"2024-08-06\"))]\nalias smul_mem_nhds := smul_mem_nhds_smul\n\n"}
{"name":"smul_mem_nhds_self","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"G : Type u_4\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : ContinuousConstSMul G G\ng : G\ns : Set G\n⊢ Iff (Membership.mem (nhds g) (HSMul.hSMul g s)) (Membership.mem (nhds 1) s)","decl":"@[to_additive (attr := simp)]\ntheorem smul_mem_nhds_self [TopologicalSpace G] [ContinuousConstSMul G G] {g : G} {s : Set G} :\n    g • s ∈ 𝓝 g ↔ s ∈ 𝓝 1 := by\n  rw [← smul_mem_nhds_smul_iff g⁻¹]; simp\n\n"}
{"name":"vadd_mem_nhds_self","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"G : Type u_4\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : ContinuousConstVAdd G G\ng : G\ns : Set G\n⊢ Iff (Membership.mem (nhds g) (HVAdd.hVAdd g s)) (Membership.mem (nhds 0) s)","decl":"@[to_additive (attr := simp)]\ntheorem smul_mem_nhds_self [TopologicalSpace G] [ContinuousConstSMul G G] {g : G} {s : Set G} :\n    g • s ∈ 𝓝 g ↔ s ∈ 𝓝 1 := by\n  rw [← smul_mem_nhds_smul_iff g⁻¹]; simp\n\n"}
{"name":"tendsto_const_smul_iff₀","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nβ : Type u_3\nG₀ : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : GroupWithZero G₀\ninst✝¹ : MulAction G₀ α\ninst✝ : ContinuousConstSMul G₀ α\nf : β → α\nl : Filter β\na : α\nc : G₀\nhc : Ne c 0\n⊢ Iff (Filter.Tendsto (fun x => HSMul.hSMul c (f x)) l (nhds (HSMul.hSMul c a))) (Filter.Tendsto f l (nhds a))","decl":"theorem tendsto_const_smul_iff₀ {f : β → α} {l : Filter β} {a : α} {c : G₀} (hc : c ≠ 0) :\n    Tendsto (fun x => c • f x) l (𝓝 <| c • a) ↔ Tendsto f l (𝓝 a) :=\n  tendsto_const_smul_iff (Units.mk0 c hc)\n\n"}
{"name":"continuousWithinAt_const_smul_iff₀","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nβ : Type u_3\nG₀ : Type u_4\ninst✝⁴ : TopologicalSpace α\ninst✝³ : GroupWithZero G₀\ninst✝² : MulAction G₀ α\ninst✝¹ : ContinuousConstSMul G₀ α\ninst✝ : TopologicalSpace β\nf : β → α\nb : β\nc : G₀\ns : Set β\nhc : Ne c 0\n⊢ Iff (ContinuousWithinAt (fun x => HSMul.hSMul c (f x)) s b) (ContinuousWithinAt f s b)","decl":"theorem continuousWithinAt_const_smul_iff₀ (hc : c ≠ 0) :\n    ContinuousWithinAt (fun x => c • f x) s b ↔ ContinuousWithinAt f s b :=\n  tendsto_const_smul_iff (Units.mk0 c hc)\n\n"}
{"name":"continuousOn_const_smul_iff₀","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nβ : Type u_3\nG₀ : Type u_4\ninst✝⁴ : TopologicalSpace α\ninst✝³ : GroupWithZero G₀\ninst✝² : MulAction G₀ α\ninst✝¹ : ContinuousConstSMul G₀ α\ninst✝ : TopologicalSpace β\nf : β → α\nc : G₀\ns : Set β\nhc : Ne c 0\n⊢ Iff (ContinuousOn (fun x => HSMul.hSMul c (f x)) s) (ContinuousOn f s)","decl":"theorem continuousOn_const_smul_iff₀ (hc : c ≠ 0) :\n    ContinuousOn (fun x => c • f x) s ↔ ContinuousOn f s :=\n  continuousOn_const_smul_iff (Units.mk0 c hc)\n\n"}
{"name":"continuousAt_const_smul_iff₀","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nβ : Type u_3\nG₀ : Type u_4\ninst✝⁴ : TopologicalSpace α\ninst✝³ : GroupWithZero G₀\ninst✝² : MulAction G₀ α\ninst✝¹ : ContinuousConstSMul G₀ α\ninst✝ : TopologicalSpace β\nf : β → α\nb : β\nc : G₀\nhc : Ne c 0\n⊢ Iff (ContinuousAt (fun x => HSMul.hSMul c (f x)) b) (ContinuousAt f b)","decl":"theorem continuousAt_const_smul_iff₀ (hc : c ≠ 0) :\n    ContinuousAt (fun x => c • f x) b ↔ ContinuousAt f b :=\n  continuousAt_const_smul_iff (Units.mk0 c hc)\n\n"}
{"name":"continuous_const_smul_iff₀","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nβ : Type u_3\nG₀ : Type u_4\ninst✝⁴ : TopologicalSpace α\ninst✝³ : GroupWithZero G₀\ninst✝² : MulAction G₀ α\ninst✝¹ : ContinuousConstSMul G₀ α\ninst✝ : TopologicalSpace β\nf : β → α\nc : G₀\nhc : Ne c 0\n⊢ Iff (Continuous fun x => HSMul.hSMul c (f x)) (Continuous f)","decl":"theorem continuous_const_smul_iff₀ (hc : c ≠ 0) : (Continuous fun x => c • f x) ↔ Continuous f :=\n  continuous_const_smul_iff (Units.mk0 c hc)\n\n"}
{"name":"Homeomorph.smulOfNeZero_apply","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG₀ : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : GroupWithZero G₀\ninst✝¹ : MulAction G₀ α\ninst✝ : ContinuousConstSMul G₀ α\nc : G₀\nhc : Ne c 0\n⊢ Eq ⇑(Homeomorph.smulOfNeZero c hc) fun x => HSMul.hSMul (Units.mk0 c hc) x","decl":"/-- Scalar multiplication by a non-zero element of a group with zero acting on `α` is a\nhomeomorphism from `α` onto itself. -/\n@[simps! (config := .asFn) apply]\nprotected def Homeomorph.smulOfNeZero (c : G₀) (hc : c ≠ 0) : α ≃ₜ α :=\n  Homeomorph.smul (Units.mk0 c hc)\n\n"}
{"name":"Homeomorph.smulOfNeZero_symm_apply","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG₀ : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : GroupWithZero G₀\ninst✝¹ : MulAction G₀ α\ninst✝ : ContinuousConstSMul G₀ α\nc : G₀\nhc : Ne c 0\n⊢ Eq ⇑(Homeomorph.smulOfNeZero c hc).symm fun x => HSMul.hSMul (Inv.inv c) x","decl":"@[simp]\ntheorem Homeomorph.smulOfNeZero_symm_apply {c : G₀} (hc : c ≠ 0) :\n    ⇑(Homeomorph.smulOfNeZero c hc).symm = (c⁻¹ • · : α → α) :=\n  rfl\n\n"}
{"name":"isOpenMap_smul₀","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG₀ : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : GroupWithZero G₀\ninst✝¹ : MulAction G₀ α\ninst✝ : ContinuousConstSMul G₀ α\nc : G₀\nhc : Ne c 0\n⊢ IsOpenMap fun x => HSMul.hSMul c x","decl":"theorem isOpenMap_smul₀ {c : G₀} (hc : c ≠ 0) : IsOpenMap fun x : α => c • x :=\n  (Homeomorph.smulOfNeZero c hc).isOpenMap\n\n"}
{"name":"IsOpen.smul₀","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG₀ : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : GroupWithZero G₀\ninst✝¹ : MulAction G₀ α\ninst✝ : ContinuousConstSMul G₀ α\nc : G₀\ns : Set α\nhs : IsOpen s\nhc : Ne c 0\n⊢ IsOpen (HSMul.hSMul c s)","decl":"theorem IsOpen.smul₀ {c : G₀} {s : Set α} (hs : IsOpen s) (hc : c ≠ 0) : IsOpen (c • s) :=\n  isOpenMap_smul₀ hc s hs\n\n"}
{"name":"interior_smul₀","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG₀ : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : GroupWithZero G₀\ninst✝¹ : MulAction G₀ α\ninst✝ : ContinuousConstSMul G₀ α\nc : G₀\nhc : Ne c 0\ns : Set α\n⊢ Eq (interior (HSMul.hSMul c s)) (HSMul.hSMul c (interior s))","decl":"theorem interior_smul₀ {c : G₀} (hc : c ≠ 0) (s : Set α) : interior (c • s) = c • interior s :=\n  ((Homeomorph.smulOfNeZero c hc).image_interior s).symm\n\n"}
{"name":"closure_smul₀'","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG₀ : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : GroupWithZero G₀\ninst✝¹ : MulAction G₀ α\ninst✝ : ContinuousConstSMul G₀ α\nc : G₀\nhc : Ne c 0\ns : Set α\n⊢ Eq (closure (HSMul.hSMul c s)) (HSMul.hSMul c (closure s))","decl":"theorem closure_smul₀' {c : G₀} (hc : c ≠ 0) (s : Set α) :\n    closure (c • s) = c • closure s :=\n  ((Homeomorph.smulOfNeZero c hc).image_closure s).symm\n\n"}
{"name":"closure_smul₀","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"G₀ : Type u_4\ninst✝⁵ : GroupWithZero G₀\nE : Type u_5\ninst✝⁴ : Zero E\ninst✝³ : MulActionWithZero G₀ E\ninst✝² : TopologicalSpace E\ninst✝¹ : T1Space E\ninst✝ : ContinuousConstSMul G₀ E\nc : G₀\ns : Set E\n⊢ Eq (closure (HSMul.hSMul c s)) (HSMul.hSMul c (closure s))","decl":"theorem closure_smul₀ {E} [Zero E] [MulActionWithZero G₀ E] [TopologicalSpace E] [T1Space E]\n    [ContinuousConstSMul G₀ E] (c : G₀) (s : Set E) : closure (c • s) = c • closure s := by\n  rcases eq_or_ne c 0 with (rfl | hc)\n  · rcases eq_empty_or_nonempty s with (rfl | hs)\n    · simp\n    · rw [zero_smul_set hs, zero_smul_set hs.closure]\n      exact closure_singleton\n  · exact closure_smul₀' hc s\n\n"}
{"name":"isClosedMap_smul_of_ne_zero","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG₀ : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : GroupWithZero G₀\ninst✝¹ : MulAction G₀ α\ninst✝ : ContinuousConstSMul G₀ α\nc : G₀\nhc : Ne c 0\n⊢ IsClosedMap fun x => HSMul.hSMul c x","decl":"/-- `smul` is a closed map in the second argument.\n\nThe lemma that `smul` is a closed map in the first argument (for a normed space over a complete\nnormed field) is `isClosedMap_smul_left` in `Analysis.Normed.Module.FiniteDimension`. -/\ntheorem isClosedMap_smul_of_ne_zero {c : G₀} (hc : c ≠ 0) : IsClosedMap fun x : α => c • x :=\n  (Homeomorph.smulOfNeZero c hc).isClosedMap\n\n"}
{"name":"IsClosed.smul_of_ne_zero","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG₀ : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : GroupWithZero G₀\ninst✝¹ : MulAction G₀ α\ninst✝ : ContinuousConstSMul G₀ α\nc : G₀\ns : Set α\nhs : IsClosed s\nhc : Ne c 0\n⊢ IsClosed (HSMul.hSMul c s)","decl":"theorem IsClosed.smul_of_ne_zero {c : G₀} {s : Set α} (hs : IsClosed s) (hc : c ≠ 0) :\n    IsClosed (c • s) :=\n  isClosedMap_smul_of_ne_zero hc s hs\n\n"}
{"name":"isClosedMap_smul₀","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"G₀ : Type u_4\ninst✝⁵ : GroupWithZero G₀\nE : Type u_5\ninst✝⁴ : Zero E\ninst✝³ : MulActionWithZero G₀ E\ninst✝² : TopologicalSpace E\ninst✝¹ : T1Space E\ninst✝ : ContinuousConstSMul G₀ E\nc : G₀\n⊢ IsClosedMap fun x => HSMul.hSMul c x","decl":"/-- `smul` is a closed map in the second argument.\n\nThe lemma that `smul` is a closed map in the first argument (for a normed space over a complete\nnormed field) is `isClosedMap_smul_left` in `Analysis.Normed.Module.FiniteDimension`. -/\ntheorem isClosedMap_smul₀ {E : Type*} [Zero E] [MulActionWithZero G₀ E] [TopologicalSpace E]\n    [T1Space E] [ContinuousConstSMul G₀ E] (c : G₀) : IsClosedMap fun x : E => c • x := by\n  rcases eq_or_ne c 0 with (rfl | hne)\n  · simp only [zero_smul]\n    exact isClosedMap_const\n  · exact (Homeomorph.smulOfNeZero c hne).isClosedMap\n\n"}
{"name":"IsClosed.smul₀","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"G₀ : Type u_4\ninst✝⁵ : GroupWithZero G₀\nE : Type u_5\ninst✝⁴ : Zero E\ninst✝³ : MulActionWithZero G₀ E\ninst✝² : TopologicalSpace E\ninst✝¹ : T1Space E\ninst✝ : ContinuousConstSMul G₀ E\nc : G₀\ns : Set E\nhs : IsClosed s\n⊢ IsClosed (HSMul.hSMul c s)","decl":"theorem IsClosed.smul₀ {E : Type*} [Zero E] [MulActionWithZero G₀ E] [TopologicalSpace E]\n    [T1Space E] [ContinuousConstSMul G₀ E] (c : G₀) {s : Set E} (hs : IsClosed s) :\n    IsClosed (c • s) :=\n  isClosedMap_smul₀ c s hs\n\n"}
{"name":"HasCompactMulSupport.comp_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG₀ : Type u_4\ninst✝⁴ : TopologicalSpace α\ninst✝³ : GroupWithZero G₀\ninst✝² : MulAction G₀ α\ninst✝¹ : ContinuousConstSMul G₀ α\nβ : Type u_5\ninst✝ : One β\nf : α → β\nh : HasCompactMulSupport f\nc : G₀\nhc : Ne c 0\n⊢ HasCompactMulSupport fun x => f (HSMul.hSMul c x)","decl":"theorem HasCompactMulSupport.comp_smul {β : Type*} [One β] {f : α → β} (h : HasCompactMulSupport f)\n    {c : G₀} (hc : c ≠ 0) : HasCompactMulSupport fun x => f (c • x) :=\n  h.comp_homeomorph (Homeomorph.smulOfNeZero c hc)\n\n"}
{"name":"HasCompactSupport.comp_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG₀ : Type u_4\ninst✝⁴ : TopologicalSpace α\ninst✝³ : GroupWithZero G₀\ninst✝² : MulAction G₀ α\ninst✝¹ : ContinuousConstSMul G₀ α\nβ : Type u_5\ninst✝ : Zero β\nf : α → β\nh : HasCompactSupport f\nc : G₀\nhc : Ne c 0\n⊢ HasCompactSupport fun x => f (HSMul.hSMul c x)","decl":"theorem HasCompactSupport.comp_smul {β : Type*} [Zero β] {f : α → β} (h : HasCompactSupport f)\n    {c : G₀} (hc : c ≠ 0) : HasCompactSupport fun x => f (c • x) :=\n  h.comp_homeomorph (Homeomorph.smulOfNeZero c hc)\n\n"}
{"name":"IsUnit.tendsto_const_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Monoid M\ninst✝² : TopologicalSpace α\ninst✝¹ : MulAction M α\ninst✝ : ContinuousConstSMul M α\nf : β → α\nl : Filter β\na : α\nc : M\nhc : IsUnit c\n⊢ Iff (Filter.Tendsto (fun x => HSMul.hSMul c (f x)) l (nhds (HSMul.hSMul c a))) (Filter.Tendsto f l (nhds a))","decl":"nonrec theorem tendsto_const_smul_iff {f : β → α} {l : Filter β} {a : α} {c : M} (hc : IsUnit c) :\n    Tendsto (fun x => c • f x) l (𝓝 <| c • a) ↔ Tendsto f l (𝓝 a) :=\n  tendsto_const_smul_iff hc.unit\n\n"}
{"name":"IsUnit.continuousWithinAt_const_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : Monoid M\ninst✝³ : TopologicalSpace α\ninst✝² : MulAction M α\ninst✝¹ : ContinuousConstSMul M α\ninst✝ : TopologicalSpace β\nf : β → α\nb : β\nc : M\ns : Set β\nhc : IsUnit c\n⊢ Iff (ContinuousWithinAt (fun x => HSMul.hSMul c (f x)) s b) (ContinuousWithinAt f s b)","decl":"nonrec theorem continuousWithinAt_const_smul_iff (hc : IsUnit c) :\n    ContinuousWithinAt (fun x => c • f x) s b ↔ ContinuousWithinAt f s b :=\n  continuousWithinAt_const_smul_iff hc.unit\n\n"}
{"name":"IsUnit.continuousOn_const_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : Monoid M\ninst✝³ : TopologicalSpace α\ninst✝² : MulAction M α\ninst✝¹ : ContinuousConstSMul M α\ninst✝ : TopologicalSpace β\nf : β → α\nc : M\ns : Set β\nhc : IsUnit c\n⊢ Iff (ContinuousOn (fun x => HSMul.hSMul c (f x)) s) (ContinuousOn f s)","decl":"nonrec theorem continuousOn_const_smul_iff (hc : IsUnit c) :\n    ContinuousOn (fun x => c • f x) s ↔ ContinuousOn f s :=\n  continuousOn_const_smul_iff hc.unit\n\n"}
{"name":"IsUnit.continuousAt_const_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : Monoid M\ninst✝³ : TopologicalSpace α\ninst✝² : MulAction M α\ninst✝¹ : ContinuousConstSMul M α\ninst✝ : TopologicalSpace β\nf : β → α\nb : β\nc : M\nhc : IsUnit c\n⊢ Iff (ContinuousAt (fun x => HSMul.hSMul c (f x)) b) (ContinuousAt f b)","decl":"nonrec theorem continuousAt_const_smul_iff (hc : IsUnit c) :\n    ContinuousAt (fun x => c • f x) b ↔ ContinuousAt f b :=\n  continuousAt_const_smul_iff hc.unit\n\n"}
{"name":"IsUnit.continuous_const_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : Monoid M\ninst✝³ : TopologicalSpace α\ninst✝² : MulAction M α\ninst✝¹ : ContinuousConstSMul M α\ninst✝ : TopologicalSpace β\nf : β → α\nc : M\nhc : IsUnit c\n⊢ Iff (Continuous fun x => HSMul.hSMul c (f x)) (Continuous f)","decl":"nonrec theorem continuous_const_smul_iff (hc : IsUnit c) :\n    (Continuous fun x => c • f x) ↔ Continuous f :=\n  continuous_const_smul_iff hc.unit\n\n"}
{"name":"IsUnit.isOpenMap_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝³ : Monoid M\ninst✝² : TopologicalSpace α\ninst✝¹ : MulAction M α\ninst✝ : ContinuousConstSMul M α\nc : M\nhc : IsUnit c\n⊢ IsOpenMap fun x => HSMul.hSMul c x","decl":"nonrec theorem isOpenMap_smul (hc : IsUnit c) : IsOpenMap fun x : α => c • x :=\n  isOpenMap_smul hc.unit\n\n"}
{"name":"IsUnit.isClosedMap_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝³ : Monoid M\ninst✝² : TopologicalSpace α\ninst✝¹ : MulAction M α\ninst✝ : ContinuousConstSMul M α\nc : M\nhc : IsUnit c\n⊢ IsClosedMap fun x => HSMul.hSMul c x","decl":"nonrec theorem isClosedMap_smul (hc : IsUnit c) : IsClosedMap fun x : α => c • x :=\n  isClosedMap_smul hc.unit\n\n"}
{"name":"IsUnit.smul_mem_nhds_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝³ : Monoid M\ninst✝² : TopologicalSpace α\ninst✝¹ : MulAction M α\ninst✝ : ContinuousConstSMul M α\nc : M\nhc : IsUnit c\ns : Set α\na : α\n⊢ Iff (Membership.mem (nhds (HSMul.hSMul c a)) (HSMul.hSMul c s)) (Membership.mem (nhds a) s)","decl":"nonrec theorem smul_mem_nhds_smul_iff (hc : IsUnit c) {s : Set α} {a : α} :\n    c • s ∈ 𝓝 (c • a) ↔ s ∈ 𝓝 a :=\n  smul_mem_nhds_smul_iff hc.unit\n\n"}
{"name":"ProperlyDiscontinuousSMul.finite_disjoint_inter_image","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Γ : Type u_4\nT : Type u_5\ninst✝¹ : TopologicalSpace T\ninst✝ : SMul Γ T\nself : ProperlyDiscontinuousSMul Γ T\nK L : Set T\na✝¹ : IsCompact K\na✝ : IsCompact L\n⊢ (setOf fun γ => Ne (Inter.inter (Set.image (fun x => HSMul.hSMul γ x) K) L) EmptyCollection.emptyCollection).Finite","decl":"/-- Class `ProperlyDiscontinuousSMul Γ T` says that the scalar multiplication `(•) : Γ → T → T`\nis properly discontinuous, that is, for any pair of compact sets `K, L` in `T`, only finitely many\n`γ:Γ` move `K` to have nontrivial intersection with `L`.\n-/\nclass ProperlyDiscontinuousSMul (Γ : Type*) (T : Type*) [TopologicalSpace T] [SMul Γ T] :\n    Prop where\n  /-- Given two compact sets `K` and `L`, `γ • K ∩ L` is nonempty for finitely many `γ`. -/\n  finite_disjoint_inter_image :\n    ∀ {K L : Set T}, IsCompact K → IsCompact L → Set.Finite { γ : Γ | (γ • ·) '' K ∩ L ≠ ∅ }\n\n"}
{"name":"ProperlyDiscontinuousVAdd.finite_disjoint_inter_image","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Γ : Type u_4\nT : Type u_5\ninst✝¹ : TopologicalSpace T\ninst✝ : VAdd Γ T\nself : ProperlyDiscontinuousVAdd Γ T\nK L : Set T\na✝¹ : IsCompact K\na✝ : IsCompact L\n⊢ (setOf fun γ => Ne (Inter.inter (Set.image (fun x => HVAdd.hVAdd γ x) K) L) EmptyCollection.emptyCollection).Finite","decl":"/-- Class `ProperlyDiscontinuousVAdd Γ T` says that the additive action `(+ᵥ) : Γ → T → T`\nis properly discontinuous, that is, for any pair of compact sets `K, L` in `T`, only finitely many\n`γ:Γ` move `K` to have nontrivial intersection with `L`.\n-/\nclass ProperlyDiscontinuousVAdd (Γ : Type*) (T : Type*) [TopologicalSpace T] [VAdd Γ T] :\n  Prop where\n  /-- Given two compact sets `K` and `L`, `γ +ᵥ K ∩ L` is nonempty for finitely many `γ`. -/\n  finite_disjoint_inter_image :\n    ∀ {K L : Set T}, IsCompact K → IsCompact L → Set.Finite { γ : Γ | (γ +ᵥ ·) '' K ∩ L ≠ ∅ }\n\n"}
{"name":"Finite.to_properlyDiscontinuousVAdd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Γ : Type u_4\ninst✝³ : AddGroup Γ\nT : Type u_5\ninst✝² : TopologicalSpace T\ninst✝¹ : AddAction Γ T\ninst✝ : Finite Γ\n⊢ ProperlyDiscontinuousVAdd Γ T","decl":"/-- A finite group action is always properly discontinuous. -/\n@[to_additive \"A finite group action is always properly discontinuous.\"]\ninstance (priority := 100) Finite.to_properlyDiscontinuousSMul [Finite Γ] :\n    ProperlyDiscontinuousSMul Γ T where finite_disjoint_inter_image _ _ := Set.toFinite _\n\n"}
{"name":"Finite.to_properlyDiscontinuousSMul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Γ : Type u_4\ninst✝³ : Group Γ\nT : Type u_5\ninst✝² : TopologicalSpace T\ninst✝¹ : MulAction Γ T\ninst✝ : Finite Γ\n⊢ ProperlyDiscontinuousSMul Γ T","decl":"/-- A finite group action is always properly discontinuous. -/\n@[to_additive \"A finite group action is always properly discontinuous.\"]\ninstance (priority := 100) Finite.to_properlyDiscontinuousSMul [Finite Γ] :\n    ProperlyDiscontinuousSMul Γ T where finite_disjoint_inter_image _ _ := Set.toFinite _\n\n"}
{"name":"isOpenMap_quotient_mk'_mul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Γ : Type u_4\ninst✝³ : Group Γ\nT : Type u_5\ninst✝² : TopologicalSpace T\ninst✝¹ : MulAction Γ T\ninst✝ : ContinuousConstSMul Γ T\n⊢ IsOpenMap Quotient.mk'","decl":"/-- The quotient map by a group action is open, i.e. the quotient by a group action is an open\n  quotient. -/\n@[to_additive \"The quotient map by a group action is open, i.e. the quotient by a group\naction is an open quotient. \"]\ntheorem isOpenMap_quotient_mk'_mul [ContinuousConstSMul Γ T] :\n    letI := MulAction.orbitRel Γ T\n    IsOpenMap (Quotient.mk' : T → Quotient (MulAction.orbitRel Γ T)) := fun U hU => by\n  rw [isOpen_coinduced, MulAction.quotient_preimage_image_eq_union_mul U]\n  exact isOpen_iUnion fun γ => isOpenMap_smul γ U hU\n\n"}
{"name":"isOpenMap_quotient_mk'_add","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Γ : Type u_4\ninst✝³ : AddGroup Γ\nT : Type u_5\ninst✝² : TopologicalSpace T\ninst✝¹ : AddAction Γ T\ninst✝ : ContinuousConstVAdd Γ T\n⊢ IsOpenMap Quotient.mk'","decl":"/-- The quotient map by a group action is open, i.e. the quotient by a group action is an open\n  quotient. -/\n@[to_additive \"The quotient map by a group action is open, i.e. the quotient by a group\naction is an open quotient. \"]\ntheorem isOpenMap_quotient_mk'_mul [ContinuousConstSMul Γ T] :\n    letI := MulAction.orbitRel Γ T\n    IsOpenMap (Quotient.mk' : T → Quotient (MulAction.orbitRel Γ T)) := fun U hU => by\n  rw [isOpen_coinduced, MulAction.quotient_preimage_image_eq_union_mul U]\n  exact isOpen_iUnion fun γ => isOpenMap_smul γ U hU\n\n"}
{"name":"AddAction.isOpenQuotientMap_quotientMk","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Γ : Type u_4\ninst✝³ : AddGroup Γ\nT : Type u_5\ninst✝² : TopologicalSpace T\ninst✝¹ : AddAction Γ T\ninst✝ : ContinuousConstVAdd Γ T\n⊢ IsOpenQuotientMap (Quotient.mk (AddAction.orbitRel Γ T))","decl":"@[to_additive]\ntheorem MulAction.isOpenQuotientMap_quotientMk [ContinuousConstSMul Γ T] :\n    IsOpenQuotientMap (Quotient.mk (MulAction.orbitRel Γ T)) :=\n  ⟨Quot.mk_surjective, continuous_quot_mk, isOpenMap_quotient_mk'_mul⟩\n\n"}
{"name":"MulAction.isOpenQuotientMap_quotientMk","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Γ : Type u_4\ninst✝³ : Group Γ\nT : Type u_5\ninst✝² : TopologicalSpace T\ninst✝¹ : MulAction Γ T\ninst✝ : ContinuousConstSMul Γ T\n⊢ IsOpenQuotientMap (Quotient.mk (MulAction.orbitRel Γ T))","decl":"@[to_additive]\ntheorem MulAction.isOpenQuotientMap_quotientMk [ContinuousConstSMul Γ T] :\n    IsOpenQuotientMap (Quotient.mk (MulAction.orbitRel Γ T)) :=\n  ⟨Quot.mk_surjective, continuous_quot_mk, isOpenMap_quotient_mk'_mul⟩\n\n"}
{"name":"t2Space_of_properlyDiscontinuousSMul_of_t2Space","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Γ : Type u_4\ninst✝⁶ : Group Γ\nT : Type u_5\ninst✝⁵ : TopologicalSpace T\ninst✝⁴ : MulAction Γ T\ninst✝³ : T2Space T\ninst✝² : LocallyCompactSpace T\ninst✝¹ : ContinuousConstSMul Γ T\ninst✝ : ProperlyDiscontinuousSMul Γ T\n⊢ T2Space (Quotient (MulAction.orbitRel Γ T))","decl":"/-- The quotient by a discontinuous group action of a locally compact t2 space is t2. -/\n@[to_additive \"The quotient by a discontinuous group action of a locally compact t2\nspace is t2.\"]\ninstance (priority := 100) t2Space_of_properlyDiscontinuousSMul_of_t2Space [T2Space T]\n    [LocallyCompactSpace T] [ContinuousConstSMul Γ T] [ProperlyDiscontinuousSMul Γ T] :\n    T2Space (Quotient (MulAction.orbitRel Γ T)) := by\n  letI := MulAction.orbitRel Γ T\n  set Q := Quotient (MulAction.orbitRel Γ T)\n  rw [t2Space_iff_nhds]\n  let f : T → Q := Quotient.mk'\n  have f_op : IsOpenMap f := isOpenMap_quotient_mk'_mul\n  rintro ⟨x₀⟩ ⟨y₀⟩ (hxy : f x₀ ≠ f y₀)\n  show ∃ U ∈ 𝓝 (f x₀), ∃ V ∈ 𝓝 (f y₀), _\n  have hγx₀y₀ : ∀ γ : Γ, γ • x₀ ≠ y₀ := not_exists.mp (mt Quotient.sound hxy.symm :)\n  obtain ⟨K₀, hK₀, K₀_in⟩ := exists_compact_mem_nhds x₀\n  obtain ⟨L₀, hL₀, L₀_in⟩ := exists_compact_mem_nhds y₀\n  let bad_Γ_set := { γ : Γ | (γ • ·) '' K₀ ∩ L₀ ≠ ∅ }\n  have bad_Γ_finite : bad_Γ_set.Finite := finite_disjoint_inter_image (Γ := Γ) hK₀ hL₀\n  choose u v hu hv u_v_disjoint using fun γ => t2_separation_nhds (hγx₀y₀ γ)\n  let U₀₀ := ⋂ γ ∈ bad_Γ_set, (γ • ·) ⁻¹' u γ\n  let U₀ := U₀₀ ∩ K₀\n  let V₀₀ := ⋂ γ ∈ bad_Γ_set, v γ\n  let V₀ := V₀₀ ∩ L₀\n  have U_nhds : f '' U₀ ∈ 𝓝 (f x₀) := by\n    refine f_op.image_mem_nhds (inter_mem ((biInter_mem bad_Γ_finite).mpr fun γ _ => ?_) K₀_in)\n    exact (continuous_const_smul _).continuousAt (hu γ)\n  have V_nhds : f '' V₀ ∈ 𝓝 (f y₀) :=\n    f_op.image_mem_nhds (inter_mem ((biInter_mem bad_Γ_finite).mpr fun γ _ => hv γ) L₀_in)\n  refine ⟨f '' U₀, U_nhds, f '' V₀, V_nhds, MulAction.disjoint_image_image_iff.2 ?_⟩\n  rintro x ⟨x_in_U₀₀, x_in_K₀⟩ γ\n  by_cases H : γ ∈ bad_Γ_set\n  · exact fun h => (u_v_disjoint γ).le_bot ⟨mem_iInter₂.mp x_in_U₀₀ γ H, mem_iInter₂.mp h.1 γ H⟩\n  · rintro ⟨-, h'⟩\n    simp only [bad_Γ_set, image_smul, Classical.not_not, mem_setOf_eq, Ne] at H\n    exact eq_empty_iff_forall_not_mem.mp H (γ • x) ⟨mem_image_of_mem _ x_in_K₀, h'⟩\n\n"}
{"name":"t2Space_of_properlyDiscontinuousVAdd_of_t2Space","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Γ : Type u_4\ninst✝⁶ : AddGroup Γ\nT : Type u_5\ninst✝⁵ : TopologicalSpace T\ninst✝⁴ : AddAction Γ T\ninst✝³ : T2Space T\ninst✝² : LocallyCompactSpace T\ninst✝¹ : ContinuousConstVAdd Γ T\ninst✝ : ProperlyDiscontinuousVAdd Γ T\n⊢ T2Space (Quotient (AddAction.orbitRel Γ T))","decl":"/-- The quotient by a discontinuous group action of a locally compact t2 space is t2. -/\n@[to_additive \"The quotient by a discontinuous group action of a locally compact t2\nspace is t2.\"]\ninstance (priority := 100) t2Space_of_properlyDiscontinuousSMul_of_t2Space [T2Space T]\n    [LocallyCompactSpace T] [ContinuousConstSMul Γ T] [ProperlyDiscontinuousSMul Γ T] :\n    T2Space (Quotient (MulAction.orbitRel Γ T)) := by\n  letI := MulAction.orbitRel Γ T\n  set Q := Quotient (MulAction.orbitRel Γ T)\n  rw [t2Space_iff_nhds]\n  let f : T → Q := Quotient.mk'\n  have f_op : IsOpenMap f := isOpenMap_quotient_mk'_mul\n  rintro ⟨x₀⟩ ⟨y₀⟩ (hxy : f x₀ ≠ f y₀)\n  show ∃ U ∈ 𝓝 (f x₀), ∃ V ∈ 𝓝 (f y₀), _\n  have hγx₀y₀ : ∀ γ : Γ, γ • x₀ ≠ y₀ := not_exists.mp (mt Quotient.sound hxy.symm :)\n  obtain ⟨K₀, hK₀, K₀_in⟩ := exists_compact_mem_nhds x₀\n  obtain ⟨L₀, hL₀, L₀_in⟩ := exists_compact_mem_nhds y₀\n  let bad_Γ_set := { γ : Γ | (γ • ·) '' K₀ ∩ L₀ ≠ ∅ }\n  have bad_Γ_finite : bad_Γ_set.Finite := finite_disjoint_inter_image (Γ := Γ) hK₀ hL₀\n  choose u v hu hv u_v_disjoint using fun γ => t2_separation_nhds (hγx₀y₀ γ)\n  let U₀₀ := ⋂ γ ∈ bad_Γ_set, (γ • ·) ⁻¹' u γ\n  let U₀ := U₀₀ ∩ K₀\n  let V₀₀ := ⋂ γ ∈ bad_Γ_set, v γ\n  let V₀ := V₀₀ ∩ L₀\n  have U_nhds : f '' U₀ ∈ 𝓝 (f x₀) := by\n    refine f_op.image_mem_nhds (inter_mem ((biInter_mem bad_Γ_finite).mpr fun γ _ => ?_) K₀_in)\n    exact (continuous_const_smul _).continuousAt (hu γ)\n  have V_nhds : f '' V₀ ∈ 𝓝 (f y₀) :=\n    f_op.image_mem_nhds (inter_mem ((biInter_mem bad_Γ_finite).mpr fun γ _ => hv γ) L₀_in)\n  refine ⟨f '' U₀, U_nhds, f '' V₀, V_nhds, MulAction.disjoint_image_image_iff.2 ?_⟩\n  rintro x ⟨x_in_U₀₀, x_in_K₀⟩ γ\n  by_cases H : γ ∈ bad_Γ_set\n  · exact fun h => (u_v_disjoint γ).le_bot ⟨mem_iInter₂.mp x_in_U₀₀ γ H, mem_iInter₂.mp h.1 γ H⟩\n  · rintro ⟨-, h'⟩\n    simp only [bad_Γ_set, image_smul, Classical.not_not, mem_setOf_eq, Ne] at H\n    exact eq_empty_iff_forall_not_mem.mp H (γ • x) ⟨mem_image_of_mem _ x_in_K₀, h'⟩\n\n"}
{"name":"ContinuousConstSMul.secondCountableTopology","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Γ : Type u_4\ninst✝⁴ : Group Γ\nT : Type u_5\ninst✝³ : TopologicalSpace T\ninst✝² : MulAction Γ T\ninst✝¹ : SecondCountableTopology T\ninst✝ : ContinuousConstSMul Γ T\n⊢ SecondCountableTopology (Quotient (MulAction.orbitRel Γ T))","decl":"/-- The quotient of a second countable space by a group action is second countable. -/\n@[to_additive \"The quotient of a second countable space by an additive group action is second\ncountable.\"]\ntheorem ContinuousConstSMul.secondCountableTopology [SecondCountableTopology T]\n    [ContinuousConstSMul Γ T] : SecondCountableTopology (Quotient (MulAction.orbitRel Γ T)) :=\n  TopologicalSpace.Quotient.secondCountableTopology isOpenMap_quotient_mk'_mul\n\n"}
{"name":"ContinuousConstVAdd.secondCountableTopology","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Γ : Type u_4\ninst✝⁴ : AddGroup Γ\nT : Type u_5\ninst✝³ : TopologicalSpace T\ninst✝² : AddAction Γ T\ninst✝¹ : SecondCountableTopology T\ninst✝ : ContinuousConstVAdd Γ T\n⊢ SecondCountableTopology (Quotient (AddAction.orbitRel Γ T))","decl":"/-- The quotient of a second countable space by a group action is second countable. -/\n@[to_additive \"The quotient of a second countable space by an additive group action is second\ncountable.\"]\ntheorem ContinuousConstSMul.secondCountableTopology [SecondCountableTopology T]\n    [ContinuousConstSMul Γ T] : SecondCountableTopology (Quotient (MulAction.orbitRel Γ T)) :=\n  TopologicalSpace.Quotient.secondCountableTopology isOpenMap_quotient_mk'_mul\n\n"}
{"name":"smul_mem_nhds_smul_iff₀","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG₀ : Type u_6\ninst✝³ : GroupWithZero G₀\ninst✝² : MulAction G₀ α\ninst✝¹ : TopologicalSpace α\ninst✝ : ContinuousConstSMul G₀ α\nc : G₀\ns : Set α\nx : α\nhc : Ne c 0\n⊢ Iff (Membership.mem (nhds (HSMul.hSMul c x)) (HSMul.hSMul c s)) (Membership.mem (nhds x) s)","decl":"/-- Scalar multiplication by a nonzero scalar preserves neighborhoods. -/\ntheorem smul_mem_nhds_smul_iff₀ {c : G₀} {s : Set α} {x : α} (hc : c ≠ 0) :\n    c • s ∈ 𝓝 (c • x : α) ↔ s ∈ 𝓝 x :=\n  smul_mem_nhds_smul_iff (Units.mk0 c hc)\n\n"}
{"name":"set_smul_mem_nhds_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG₀ : Type u_6\ninst✝³ : GroupWithZero G₀\ninst✝² : MulAction G₀ α\ninst✝¹ : TopologicalSpace α\ninst✝ : ContinuousConstSMul G₀ α\nc : G₀\ns : Set α\nx : α\nhc : Ne c 0\n⊢ Iff (Membership.mem (nhds (HSMul.hSMul c x)) (HSMul.hSMul c s)) (Membership.mem (nhds x) s)","decl":"@[deprecated (since := \"2024-08-06\")]\nalias set_smul_mem_nhds_smul_iff := smul_mem_nhds_smul_iff₀\n\n"}
{"name":"smul_mem_nhds_smul₀","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG₀ : Type u_6\ninst✝³ : GroupWithZero G₀\ninst✝² : MulAction G₀ α\ninst✝¹ : TopologicalSpace α\ninst✝ : ContinuousConstSMul G₀ α\nc : G₀\ns : Set α\nx : α\nhc : Ne c 0\na✝ : Membership.mem (nhds x) s\n⊢ Membership.mem (nhds (HSMul.hSMul c x)) (HSMul.hSMul c s)","decl":"alias ⟨_, smul_mem_nhds_smul₀⟩ := smul_mem_nhds_smul_iff₀\n\n"}
{"name":"set_smul_mem_nhds_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG₀ : Type u_6\ninst✝³ : GroupWithZero G₀\ninst✝² : MulAction G₀ α\ninst✝¹ : TopologicalSpace α\ninst✝ : ContinuousConstSMul G₀ α\nc : G₀\ns : Set α\nx : α\nhs : Membership.mem (nhds x) s\nhc : Ne c 0\n⊢ Membership.mem (nhds (HSMul.hSMul c x)) (HSMul.hSMul c s)","decl":"@[deprecated smul_mem_nhds_smul₀ (since := \"2024-08-06\")]\ntheorem set_smul_mem_nhds_smul {c : G₀} {s : Set α} {x : α} (hs : s ∈ 𝓝 x) (hc : c ≠ 0) :\n    c • s ∈ 𝓝 (c • x : α) :=\n  smul_mem_nhds_smul₀ hc hs\n\n"}
{"name":"set_smul_mem_nhds_zero_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"α : Type u_2\nG₀ : Type u_6\ninst✝⁴ : GroupWithZero G₀\ninst✝³ : AddMonoid α\ninst✝² : DistribMulAction G₀ α\ninst✝¹ : TopologicalSpace α\ninst✝ : ContinuousConstSMul G₀ α\ns : Set α\nc : G₀\nhc : Ne c 0\n⊢ Iff (Membership.mem (nhds 0) (HSMul.hSMul c s)) (Membership.mem (nhds 0) s)","decl":"theorem set_smul_mem_nhds_zero_iff {s : Set α} {c : G₀} (hc : c ≠ 0) :\n    c • s ∈ 𝓝 (0 : α) ↔ s ∈ 𝓝 (0 : α) := by\n  refine Iff.trans ?_ (smul_mem_nhds_smul_iff₀ hc)\n  rw [smul_zero]\n\n"}
