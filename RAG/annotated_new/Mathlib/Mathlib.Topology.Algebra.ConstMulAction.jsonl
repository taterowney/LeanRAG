{"name":"ContinuousConstSMul.continuous_const_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î“ : Type u_1\nT : Type u_2\ninstâœÂ¹ : TopologicalSpace T\ninstâœ : SMul Î“ T\nself : ContinuousConstSMul Î“ T\nÎ³ : Î“\nâŠ¢ Continuous fun x => HSMul.hSMul Î³ x","decl":"/-- Class `ContinuousConstSMul Î“ T` says that the scalar multiplication `(â€¢) : Î“ â†’ T â†’ T`\nis continuous in the second argument. We use the same class for all kinds of multiplicative\nactions, including (semi)modules and algebras.\n\nNote that both `ContinuousConstSMul Î± Î±` and `ContinuousConstSMul Î±áµáµ’áµ– Î±` are\nweaker versions of `ContinuousMul Î±`. -/\nclass ContinuousConstSMul (Î“ : Type*) (T : Type*) [TopologicalSpace T] [SMul Î“ T] : Prop where\n  /-- The scalar multiplication `(â€¢) : Î“ â†’ T â†’ T` is continuous in the second argument. -/\n  continuous_const_smul : âˆ€ Î³ : Î“, Continuous fun x : T => Î³ â€¢ x\n\n"}
{"name":"ContinuousConstVAdd.continuous_const_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î“ : Type u_1\nT : Type u_2\ninstâœÂ¹ : TopologicalSpace T\ninstâœ : VAdd Î“ T\nself : ContinuousConstVAdd Î“ T\nÎ³ : Î“\nâŠ¢ Continuous fun x => HVAdd.hVAdd Î³ x","decl":"/-- Class `ContinuousConstVAdd Î“ T` says that the additive action `(+áµ¥) : Î“ â†’ T â†’ T`\nis continuous in the second argument. We use the same class for all kinds of additive actions,\nincluding (semi)modules and algebras.\n\nNote that both `ContinuousConstVAdd Î± Î±` and `ContinuousConstVAdd Î±áµáµ’áµ– Î±` are\nweaker versions of `ContinuousVAdd Î±`. -/\nclass ContinuousConstVAdd (Î“ : Type*) (T : Type*) [TopologicalSpace T] [VAdd Î“ T] : Prop where\n  /-- The additive action `(+áµ¥) : Î“ â†’ T â†’ T` is continuous in the second argument. -/\n  continuous_const_vadd : âˆ€ Î³ : Î“, Continuous fun x : T => Î³ +áµ¥ x\n\n"}
{"name":"instContinuousConstSMulULift","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : SMul M Î±\ninstâœ : ContinuousConstSMul M Î±\nâŠ¢ ContinuousConstSMul (ULift.{u_4, u_1} M) Î±","decl":"@[to_additive]\ninstance : ContinuousConstSMul (ULift M) Î± := âŸ¨fun Î³ â†¦ continuous_const_smul (ULift.down Î³)âŸ©\n\n"}
{"name":"instContinuousConstVAddULift","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : VAdd M Î±\ninstâœ : ContinuousConstVAdd M Î±\nâŠ¢ ContinuousConstVAdd (ULift.{u_4, u_1} M) Î±","decl":"@[to_additive]\ninstance : ContinuousConstSMul (ULift M) Î± := âŸ¨fun Î³ â†¦ continuous_const_smul (ULift.down Î³)âŸ©\n\n"}
{"name":"Filter.Tendsto.const_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : VAdd M Î±\ninstâœ : ContinuousConstVAdd M Î±\nf : Î² â†’ Î±\nl : Filter Î²\na : Î±\nhf : Filter.Tendsto f l (nhds a)\nc : M\nâŠ¢ Filter.Tendsto (fun x => HVAdd.hVAdd c (f x)) l (nhds (HVAdd.hVAdd c a))","decl":"@[to_additive]\ntheorem Filter.Tendsto.const_smul {f : Î² â†’ Î±} {l : Filter Î²} {a : Î±} (hf : Tendsto f l (ğ“ a))\n    (c : M) : Tendsto (fun x => c â€¢ f x) l (ğ“ (c â€¢ a)) :=\n  ((continuous_const_smul _).tendsto _).comp hf\n\n"}
{"name":"Filter.Tendsto.const_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : SMul M Î±\ninstâœ : ContinuousConstSMul M Î±\nf : Î² â†’ Î±\nl : Filter Î²\na : Î±\nhf : Filter.Tendsto f l (nhds a)\nc : M\nâŠ¢ Filter.Tendsto (fun x => HSMul.hSMul c (f x)) l (nhds (HSMul.hSMul c a))","decl":"@[to_additive]\ntheorem Filter.Tendsto.const_smul {f : Î² â†’ Î±} {l : Filter Î²} {a : Î±} (hf : Tendsto f l (ğ“ a))\n    (c : M) : Tendsto (fun x => c â€¢ f x) l (ğ“ (c â€¢ a)) :=\n  ((continuous_const_smul _).tendsto _).comp hf\n\n"}
{"name":"ContinuousWithinAt.const_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : SMul M Î±\ninstâœÂ¹ : ContinuousConstSMul M Î±\ninstâœ : TopologicalSpace Î²\ng : Î² â†’ Î±\nb : Î²\ns : Set Î²\nhg : ContinuousWithinAt g s b\nc : M\nâŠ¢ ContinuousWithinAt (fun x => HSMul.hSMul c (g x)) s b","decl":"@[to_additive]\nnonrec theorem ContinuousWithinAt.const_smul (hg : ContinuousWithinAt g s b) (c : M) :\n    ContinuousWithinAt (fun x => c â€¢ g x) s b :=\n  hg.const_smul c\n\n"}
{"name":"ContinuousWithinAt.const_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : VAdd M Î±\ninstâœÂ¹ : ContinuousConstVAdd M Î±\ninstâœ : TopologicalSpace Î²\ng : Î² â†’ Î±\nb : Î²\ns : Set Î²\nhg : ContinuousWithinAt g s b\nc : M\nâŠ¢ ContinuousWithinAt (fun x => HVAdd.hVAdd c (g x)) s b","decl":"@[to_additive]\nnonrec theorem ContinuousWithinAt.const_smul (hg : ContinuousWithinAt g s b) (c : M) :\n    ContinuousWithinAt (fun x => c â€¢ g x) s b :=\n  hg.const_smul c\n\n"}
{"name":"ContinuousAt.const_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : SMul M Î±\ninstâœÂ¹ : ContinuousConstSMul M Î±\ninstâœ : TopologicalSpace Î²\ng : Î² â†’ Î±\nb : Î²\nhg : ContinuousAt g b\nc : M\nâŠ¢ ContinuousAt (fun x => HSMul.hSMul c (g x)) b","decl":"@[to_additive (attr := fun_prop)]\nnonrec theorem ContinuousAt.const_smul (hg : ContinuousAt g b) (c : M) :\n    ContinuousAt (fun x => c â€¢ g x) b :=\n  hg.const_smul c\n\n"}
{"name":"ContinuousAt.const_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : VAdd M Î±\ninstâœÂ¹ : ContinuousConstVAdd M Î±\ninstâœ : TopologicalSpace Î²\ng : Î² â†’ Î±\nb : Î²\nhg : ContinuousAt g b\nc : M\nâŠ¢ ContinuousAt (fun x => HVAdd.hVAdd c (g x)) b","decl":"@[to_additive (attr := fun_prop)]\nnonrec theorem ContinuousAt.const_smul (hg : ContinuousAt g b) (c : M) :\n    ContinuousAt (fun x => c â€¢ g x) b :=\n  hg.const_smul c\n\n"}
{"name":"ContinuousOn.const_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : VAdd M Î±\ninstâœÂ¹ : ContinuousConstVAdd M Î±\ninstâœ : TopologicalSpace Î²\ng : Î² â†’ Î±\ns : Set Î²\nhg : ContinuousOn g s\nc : M\nâŠ¢ ContinuousOn (fun x => HVAdd.hVAdd c (g x)) s","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousOn.const_smul (hg : ContinuousOn g s) (c : M) :\n    ContinuousOn (fun x => c â€¢ g x) s := fun x hx => (hg x hx).const_smul c\n\n"}
{"name":"ContinuousOn.const_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : SMul M Î±\ninstâœÂ¹ : ContinuousConstSMul M Î±\ninstâœ : TopologicalSpace Î²\ng : Î² â†’ Î±\ns : Set Î²\nhg : ContinuousOn g s\nc : M\nâŠ¢ ContinuousOn (fun x => HSMul.hSMul c (g x)) s","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousOn.const_smul (hg : ContinuousOn g s) (c : M) :\n    ContinuousOn (fun x => c â€¢ g x) s := fun x hx => (hg x hx).const_smul c\n\n"}
{"name":"Continuous.const_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : SMul M Î±\ninstâœÂ¹ : ContinuousConstSMul M Î±\ninstâœ : TopologicalSpace Î²\ng : Î² â†’ Î±\nhg : Continuous g\nc : M\nâŠ¢ Continuous fun x => HSMul.hSMul c (g x)","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem Continuous.const_smul (hg : Continuous g) (c : M) : Continuous fun x => c â€¢ g x :=\n  (continuous_const_smul _).comp hg\n\n"}
{"name":"Continuous.const_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : VAdd M Î±\ninstâœÂ¹ : ContinuousConstVAdd M Î±\ninstâœ : TopologicalSpace Î²\ng : Î² â†’ Î±\nhg : Continuous g\nc : M\nâŠ¢ Continuous fun x => HVAdd.hVAdd c (g x)","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem Continuous.const_smul (hg : Continuous g) (c : M) : Continuous fun x => c â€¢ g x :=\n  (continuous_const_smul _).comp hg\n\n"}
{"name":"ContinuousConstSMul.op","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : SMul M Î±\ninstâœÂ¹ : SMul (MulOpposite M) Î±\ninstâœ : IsCentralScalar M Î±\nâŠ¢ ContinuousConstSMul (MulOpposite M) Î±","decl":"/-- If a scalar is central, then its right action is continuous when its left action is. -/\n@[to_additive \"If an additive action is central, then its right action is continuous when its left\naction is.\"]\ninstance ContinuousConstSMul.op [SMul Máµáµ’áµ– Î±] [IsCentralScalar M Î±] :\n    ContinuousConstSMul Máµáµ’áµ– Î± :=\n  âŸ¨MulOpposite.rec' fun c => by simpa only [op_smul_eq_smul] using continuous_const_smul câŸ©\n\n"}
{"name":"ContinuousConstVAdd.op","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : VAdd M Î±\ninstâœÂ¹ : VAdd (AddOpposite M) Î±\ninstâœ : IsCentralVAdd M Î±\nâŠ¢ ContinuousConstVAdd (AddOpposite M) Î±","decl":"/-- If a scalar is central, then its right action is continuous when its left action is. -/\n@[to_additive \"If an additive action is central, then its right action is continuous when its left\naction is.\"]\ninstance ContinuousConstSMul.op [SMul Máµáµ’áµ– Î±] [IsCentralScalar M Î±] :\n    ContinuousConstSMul Máµáµ’áµ– Î± :=\n  âŸ¨MulOpposite.rec' fun c => by simpa only [op_smul_eq_smul] using continuous_const_smul câŸ©\n\n"}
{"name":"MulOpposite.continuousConstSMul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : SMul M Î±\ninstâœ : ContinuousConstSMul M Î±\nâŠ¢ ContinuousConstSMul M (MulOpposite Î±)","decl":"@[to_additive]\ninstance MulOpposite.continuousConstSMul : ContinuousConstSMul M Î±áµáµ’áµ– :=\n  âŸ¨fun c => MulOpposite.continuous_op.comp <| MulOpposite.continuous_unop.const_smul câŸ©\n\n"}
{"name":"AddOpposite.continuousConstVAdd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : VAdd M Î±\ninstâœ : ContinuousConstVAdd M Î±\nâŠ¢ ContinuousConstVAdd M (AddOpposite Î±)","decl":"@[to_additive]\ninstance MulOpposite.continuousConstSMul : ContinuousConstSMul M Î±áµáµ’áµ– :=\n  âŸ¨fun c => MulOpposite.continuous_op.comp <| MulOpposite.continuous_unop.const_smul câŸ©\n\n"}
{"name":"instContinuousConstSMulOrderDual","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SMul M Î±\nâŠ¢ ContinuousConstSMul M (OrderDual Î±)","decl":"@[to_additive]\ninstance : ContinuousConstSMul M Î±áµ’áµˆ := â€¹ContinuousConstSMul M Î±â€º\n\n"}
{"name":"instContinuousConstVAddOrderDual","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : VAdd M Î±\nâŠ¢ ContinuousConstVAdd M (OrderDual Î±)","decl":"@[to_additive]\ninstance : ContinuousConstSMul M Î±áµ’áµˆ := â€¹ContinuousConstSMul M Î±â€º\n\n"}
{"name":"OrderDual.continuousConstSMul'","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SMul M Î±\nâŠ¢ ContinuousConstSMul (OrderDual M) Î±","decl":"@[to_additive]\ninstance OrderDual.continuousConstSMul' : ContinuousConstSMul Máµ’áµˆ Î± :=\n  â€¹ContinuousConstSMul M Î±â€º\n\n"}
{"name":"OrderDual.continuousConstVAdd'","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : VAdd M Î±\nâŠ¢ ContinuousConstVAdd (OrderDual M) Î±","decl":"@[to_additive]\ninstance OrderDual.continuousConstSMul' : ContinuousConstSMul Máµ’áµˆ Î± :=\n  â€¹ContinuousConstSMul M Î±â€º\n\n"}
{"name":"Prod.continuousConstVAdd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : VAdd M Î±\ninstâœÂ³ : ContinuousConstVAdd M Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : VAdd M Î²\ninstâœ : ContinuousConstVAdd M Î²\nâŠ¢ ContinuousConstVAdd M (Prod Î± Î²)","decl":"@[to_additive]\ninstance Prod.continuousConstSMul [SMul M Î²] [ContinuousConstSMul M Î²] :\n    ContinuousConstSMul M (Î± Ã— Î²) :=\n  âŸ¨fun _ => (continuous_fst.const_smul _).prod_mk (continuous_snd.const_smul _)âŸ©\n\n"}
{"name":"Prod.continuousConstSMul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : SMul M Î±\ninstâœÂ³ : ContinuousConstSMul M Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : SMul M Î²\ninstâœ : ContinuousConstSMul M Î²\nâŠ¢ ContinuousConstSMul M (Prod Î± Î²)","decl":"@[to_additive]\ninstance Prod.continuousConstSMul [SMul M Î²] [ContinuousConstSMul M Î²] :\n    ContinuousConstSMul M (Î± Ã— Î²) :=\n  âŸ¨fun _ => (continuous_fst.const_smul _).prod_mk (continuous_snd.const_smul _)âŸ©\n\n"}
{"name":"instContinuousConstVAddForall","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ¹ : Type u_4\nÎ³ : Î¹ â†’ Type u_5\ninstâœÂ² : (i : Î¹) â†’ TopologicalSpace (Î³ i)\ninstâœÂ¹ : (i : Î¹) â†’ VAdd M (Î³ i)\ninstâœ : âˆ€ (i : Î¹), ContinuousConstVAdd M (Î³ i)\nâŠ¢ ContinuousConstVAdd M ((i : Î¹) â†’ Î³ i)","decl":"@[to_additive]\ninstance {Î¹ : Type*} {Î³ : Î¹ â†’ Type*} [âˆ€ i, TopologicalSpace (Î³ i)] [âˆ€ i, SMul M (Î³ i)]\n    [âˆ€ i, ContinuousConstSMul M (Î³ i)] : ContinuousConstSMul M (âˆ€ i, Î³ i) :=\n  âŸ¨fun _ => continuous_pi fun i => (continuous_apply i).const_smul _âŸ©\n\n"}
{"name":"instContinuousConstSMulForall","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ¹ : Type u_4\nÎ³ : Î¹ â†’ Type u_5\ninstâœÂ² : (i : Î¹) â†’ TopologicalSpace (Î³ i)\ninstâœÂ¹ : (i : Î¹) â†’ SMul M (Î³ i)\ninstâœ : âˆ€ (i : Î¹), ContinuousConstSMul M (Î³ i)\nâŠ¢ ContinuousConstSMul M ((i : Î¹) â†’ Î³ i)","decl":"@[to_additive]\ninstance {Î¹ : Type*} {Î³ : Î¹ â†’ Type*} [âˆ€ i, TopologicalSpace (Î³ i)] [âˆ€ i, SMul M (Î³ i)]\n    [âˆ€ i, ContinuousConstSMul M (Î³ i)] : ContinuousConstSMul M (âˆ€ i, Î³ i) :=\n  âŸ¨fun _ => continuous_pi fun i => (continuous_apply i).const_smul _âŸ©\n\n"}
{"name":"IsCompact.vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_4\nÎ² : Type u_5\ninstâœÂ² : VAdd Î± Î²\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : ContinuousConstVAdd Î± Î²\na : Î±\ns : Set Î²\nhs : IsCompact s\nâŠ¢ IsCompact (HVAdd.hVAdd a s)","decl":"@[to_additive]\ntheorem IsCompact.smul {Î± Î²} [SMul Î± Î²] [TopologicalSpace Î²] [ContinuousConstSMul Î± Î²] (a : Î±)\n    {s : Set Î²} (hs : IsCompact s) : IsCompact (a â€¢ s) :=\n  hs.image (continuous_id.const_smul a)\n\n"}
{"name":"IsCompact.smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_4\nÎ² : Type u_5\ninstâœÂ² : SMul Î± Î²\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : ContinuousConstSMul Î± Î²\na : Î±\ns : Set Î²\nhs : IsCompact s\nâŠ¢ IsCompact (HSMul.hSMul a s)","decl":"@[to_additive]\ntheorem IsCompact.smul {Î± Î²} [SMul Î± Î²] [TopologicalSpace Î²] [ContinuousConstSMul Î± Î²] (a : Î±)\n    {s : Set Î²} (hs : IsCompact s) : IsCompact (a â€¢ s) :=\n  hs.image (continuous_id.const_smul a)\n\n"}
{"name":"Specializes.const_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : VAdd M Î±\ninstâœ : ContinuousConstVAdd M Î±\nx y : Î±\nh : Specializes x y\nc : M\nâŠ¢ Specializes (HVAdd.hVAdd c x) (HVAdd.hVAdd c y)","decl":"@[to_additive]\ntheorem Specializes.const_smul {x y : Î±} (h : x â¤³ y) (c : M) : (c â€¢ x) â¤³ (c â€¢ y) :=\n  h.map (continuous_const_smul c)\n\n"}
{"name":"Specializes.const_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : SMul M Î±\ninstâœ : ContinuousConstSMul M Î±\nx y : Î±\nh : Specializes x y\nc : M\nâŠ¢ Specializes (HSMul.hSMul c x) (HSMul.hSMul c y)","decl":"@[to_additive]\ntheorem Specializes.const_smul {x y : Î±} (h : x â¤³ y) (c : M) : (c â€¢ x) â¤³ (c â€¢ y) :=\n  h.map (continuous_const_smul c)\n\n"}
{"name":"Inseparable.const_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : SMul M Î±\ninstâœ : ContinuousConstSMul M Î±\nx y : Î±\nh : Inseparable x y\nc : M\nâŠ¢ Inseparable (HSMul.hSMul c x) (HSMul.hSMul c y)","decl":"@[to_additive]\ntheorem Inseparable.const_smul {x y : Î±} (h : Inseparable x y) (c : M) :\n    Inseparable (c â€¢ x) (c â€¢ y) :=\n  h.map (continuous_const_smul c)\n\n"}
{"name":"Inseparable.const_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : VAdd M Î±\ninstâœ : ContinuousConstVAdd M Î±\nx y : Î±\nh : Inseparable x y\nc : M\nâŠ¢ Inseparable (HVAdd.hVAdd c x) (HVAdd.hVAdd c y)","decl":"@[to_additive]\ntheorem Inseparable.const_smul {x y : Î±} (h : Inseparable x y) (c : M) :\n    Inseparable (c â€¢ x) (c â€¢ y) :=\n  h.map (continuous_const_smul c)\n\n"}
{"name":"Topology.IsInducing.continuousConstVAdd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : VAdd M Î±\ninstâœÂ² : ContinuousConstVAdd M Î±\nN : Type u_4\nÎ² : Type u_5\ninstâœÂ¹ : VAdd N Î²\ninstâœ : TopologicalSpace Î²\ng : Î² â†’ Î±\nhg : Topology.IsInducing g\nf : N â†’ M\nhf : âˆ€ {c : N} {x : Î²}, Eq (g (HVAdd.hVAdd c x)) (HVAdd.hVAdd (f c) (g x))\nâŠ¢ ContinuousConstVAdd N Î²","decl":"@[to_additive]\ntheorem Topology.IsInducing.continuousConstSMul {N Î² : Type*} [SMul N Î²] [TopologicalSpace Î²]\n    {g : Î² â†’ Î±} (hg : IsInducing g) (f : N â†’ M) (hf : âˆ€ {c : N} {x : Î²}, g (c â€¢ x) = f c â€¢ g x) :\n    ContinuousConstSMul N Î² where\n  continuous_const_smul c := by\n    simpa only [Function.comp_def, hf, hg.continuous_iff] using hg.continuous.const_smul (f c)\n\n"}
{"name":"Topology.IsInducing.continuousConstSMul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : SMul M Î±\ninstâœÂ² : ContinuousConstSMul M Î±\nN : Type u_4\nÎ² : Type u_5\ninstâœÂ¹ : SMul N Î²\ninstâœ : TopologicalSpace Î²\ng : Î² â†’ Î±\nhg : Topology.IsInducing g\nf : N â†’ M\nhf : âˆ€ {c : N} {x : Î²}, Eq (g (HSMul.hSMul c x)) (HSMul.hSMul (f c) (g x))\nâŠ¢ ContinuousConstSMul N Î²","decl":"@[to_additive]\ntheorem Topology.IsInducing.continuousConstSMul {N Î² : Type*} [SMul N Î²] [TopologicalSpace Î²]\n    {g : Î² â†’ Î±} (hg : IsInducing g) (f : N â†’ M) (hf : âˆ€ {c : N} {x : Î²}, g (c â€¢ x) = f c â€¢ g x) :\n    ContinuousConstSMul N Î² where\n  continuous_const_smul c := by\n    simpa only [Function.comp_def, hf, hg.continuous_iff] using hg.continuous.const_smul (f c)\n\n"}
{"name":"Inducing.continuousConstSMul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : SMul M Î±\ninstâœÂ² : ContinuousConstSMul M Î±\nN : Type u_4\nÎ² : Type u_5\ninstâœÂ¹ : SMul N Î²\ninstâœ : TopologicalSpace Î²\ng : Î² â†’ Î±\nhg : Topology.IsInducing g\nf : N â†’ M\nhf : âˆ€ {c : N} {x : Î²}, Eq (g (HSMul.hSMul c x)) (HSMul.hSMul (f c) (g x))\nâŠ¢ ContinuousConstSMul N Î²","decl":"@[deprecated (since := \"2024-10-28\")]\nalias Inducing.continuousConstSMul := IsInducing.continuousConstSMul\n\n"}
{"name":"Units.continuousConstSMul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : Monoid M\ninstâœÂ¹ : MulAction M Î±\ninstâœ : ContinuousConstSMul M Î±\nâŠ¢ ContinuousConstSMul (Units M) Î±","decl":"@[to_additive]\ninstance Units.continuousConstSMul : ContinuousConstSMul MË£ Î± where\n  continuous_const_smul m := continuous_const_smul (m : M)\n\n"}
{"name":"AddUnits.continuousConstVAdd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : AddMonoid M\ninstâœÂ¹ : AddAction M Î±\ninstâœ : ContinuousConstVAdd M Î±\nâŠ¢ ContinuousConstVAdd (AddUnits M) Î±","decl":"@[to_additive]\ninstance Units.continuousConstSMul : ContinuousConstSMul MË£ Î± where\n  continuous_const_smul m := continuous_const_smul (m : M)\n\n"}
{"name":"vadd_closure_subset","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : AddMonoid M\ninstâœÂ¹ : AddAction M Î±\ninstâœ : ContinuousConstVAdd M Î±\nc : M\ns : Set Î±\nâŠ¢ HasSubset.Subset (HVAdd.hVAdd c (closure s)) (closure (HVAdd.hVAdd c s))","decl":"@[to_additive]\ntheorem smul_closure_subset (c : M) (s : Set Î±) : c â€¢ closure s âŠ† closure (c â€¢ s) :=\n  ((Set.mapsTo_image _ _).closure <| continuous_const_smul c).image_subset\n\n"}
{"name":"smul_closure_subset","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : Monoid M\ninstâœÂ¹ : MulAction M Î±\ninstâœ : ContinuousConstSMul M Î±\nc : M\ns : Set Î±\nâŠ¢ HasSubset.Subset (HSMul.hSMul c (closure s)) (closure (HSMul.hSMul c s))","decl":"@[to_additive]\ntheorem smul_closure_subset (c : M) (s : Set Î±) : c â€¢ closure s âŠ† closure (c â€¢ s) :=\n  ((Set.mapsTo_image _ _).closure <| continuous_const_smul c).image_subset\n\n"}
{"name":"vadd_closure_orbit_subset","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : AddMonoid M\ninstâœÂ¹ : AddAction M Î±\ninstâœ : ContinuousConstVAdd M Î±\nc : M\nx : Î±\nâŠ¢ HasSubset.Subset (HVAdd.hVAdd c (closure (AddAction.orbit M x))) (closure (AddAction.orbit M x))","decl":"@[to_additive]\ntheorem smul_closure_orbit_subset (c : M) (x : Î±) :\n    c â€¢ closure (MulAction.orbit M x) âŠ† closure (MulAction.orbit M x) :=\n  (smul_closure_subset c _).trans <| closure_mono <| MulAction.smul_orbit_subset _ _\n\n"}
{"name":"smul_closure_orbit_subset","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : Monoid M\ninstâœÂ¹ : MulAction M Î±\ninstâœ : ContinuousConstSMul M Î±\nc : M\nx : Î±\nâŠ¢ HasSubset.Subset (HSMul.hSMul c (closure (MulAction.orbit M x))) (closure (MulAction.orbit M x))","decl":"@[to_additive]\ntheorem smul_closure_orbit_subset (c : M) (x : Î±) :\n    c â€¢ closure (MulAction.orbit M x) âŠ† closure (MulAction.orbit M x) :=\n  (smul_closure_subset c _).trans <| closure_mono <| MulAction.smul_orbit_subset _ _\n\n"}
{"name":"isClosed_setOf_map_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\ninstâœâ¶ : Monoid M\nN : Type u_4\ninstâœâµ : Monoid N\nÎ± : Type u_5\nÎ² : Type u_6\ninstâœâ´ : MulAction M Î±\ninstâœÂ³ : MulAction N Î²\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : T2Space Î²\ninstâœ : ContinuousConstSMul N Î²\nÏƒ : M â†’ N\nâŠ¢ IsClosed (setOf fun f => âˆ€ (c : M) (x : Î±), Eq (f (HSMul.hSMul c x)) (HSMul.hSMul (Ïƒ c) (f x)))","decl":"theorem isClosed_setOf_map_smul {N : Type*} [Monoid N] (Î± Î²) [MulAction M Î±] [MulAction N Î²]\n    [TopologicalSpace Î²] [T2Space Î²] [ContinuousConstSMul N Î²] (Ïƒ : M â†’ N) :\n    IsClosed { f : Î± â†’ Î² | âˆ€ c x, f (c â€¢ x) = Ïƒ c â€¢ f x } := by\n  simp only [Set.setOf_forall]\n  exact isClosed_iInter fun c => isClosed_iInter fun x =>\n    isClosed_eq (continuous_apply _) ((continuous_apply _).const_smul _)\n\n"}
{"name":"tendsto_const_vadd_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : AddAction G Î±\ninstâœ : ContinuousConstVAdd G Î±\nf : Î² â†’ Î±\nl : Filter Î²\na : Î±\nc : G\nâŠ¢ Iff (Filter.Tendsto (fun x => HVAdd.hVAdd c (f x)) l (nhds (HVAdd.hVAdd c a))) (Filter.Tendsto f l (nhds a))","decl":"@[to_additive]\ntheorem tendsto_const_smul_iff {f : Î² â†’ Î±} {l : Filter Î²} {a : Î±} (c : G) :\n    Tendsto (fun x => c â€¢ f x) l (ğ“ <| c â€¢ a) â†” Tendsto f l (ğ“ a) :=\n  âŸ¨fun h => by simpa only [inv_smul_smul] using h.const_smul câ»Â¹, fun h => h.const_smul _âŸ©\n\n"}
{"name":"tendsto_const_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : Group G\ninstâœÂ¹ : MulAction G Î±\ninstâœ : ContinuousConstSMul G Î±\nf : Î² â†’ Î±\nl : Filter Î²\na : Î±\nc : G\nâŠ¢ Iff (Filter.Tendsto (fun x => HSMul.hSMul c (f x)) l (nhds (HSMul.hSMul c a))) (Filter.Tendsto f l (nhds a))","decl":"@[to_additive]\ntheorem tendsto_const_smul_iff {f : Î² â†’ Î±} {l : Filter Î²} {a : Î±} (c : G) :\n    Tendsto (fun x => c â€¢ f x) l (ğ“ <| c â€¢ a) â†” Tendsto f l (ğ“ a) :=\n  âŸ¨fun h => by simpa only [inv_smul_smul] using h.const_smul câ»Â¹, fun h => h.const_smul _âŸ©\n\n"}
{"name":"continuousWithinAt_const_vadd_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nG : Type u_4\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : AddGroup G\ninstâœÂ² : AddAction G Î±\ninstâœÂ¹ : ContinuousConstVAdd G Î±\ninstâœ : TopologicalSpace Î²\nf : Î² â†’ Î±\nb : Î²\ns : Set Î²\nc : G\nâŠ¢ Iff (ContinuousWithinAt (fun x => HVAdd.hVAdd c (f x)) s b) (ContinuousWithinAt f s b)","decl":"@[to_additive]\ntheorem continuousWithinAt_const_smul_iff (c : G) :\n    ContinuousWithinAt (fun x => c â€¢ f x) s b â†” ContinuousWithinAt f s b :=\n  tendsto_const_smul_iff c\n\n"}
{"name":"continuousWithinAt_const_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nG : Type u_4\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : Group G\ninstâœÂ² : MulAction G Î±\ninstâœÂ¹ : ContinuousConstSMul G Î±\ninstâœ : TopologicalSpace Î²\nf : Î² â†’ Î±\nb : Î²\ns : Set Î²\nc : G\nâŠ¢ Iff (ContinuousWithinAt (fun x => HSMul.hSMul c (f x)) s b) (ContinuousWithinAt f s b)","decl":"@[to_additive]\ntheorem continuousWithinAt_const_smul_iff (c : G) :\n    ContinuousWithinAt (fun x => c â€¢ f x) s b â†” ContinuousWithinAt f s b :=\n  tendsto_const_smul_iff c\n\n"}
{"name":"continuousOn_const_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nG : Type u_4\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : Group G\ninstâœÂ² : MulAction G Î±\ninstâœÂ¹ : ContinuousConstSMul G Î±\ninstâœ : TopologicalSpace Î²\nf : Î² â†’ Î±\ns : Set Î²\nc : G\nâŠ¢ Iff (ContinuousOn (fun x => HSMul.hSMul c (f x)) s) (ContinuousOn f s)","decl":"@[to_additive]\ntheorem continuousOn_const_smul_iff (c : G) :\n    ContinuousOn (fun x => c â€¢ f x) s â†” ContinuousOn f s :=\n  forallâ‚‚_congr fun _ _ => continuousWithinAt_const_smul_iff c\n\n"}
{"name":"continuousOn_const_vadd_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nG : Type u_4\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : AddGroup G\ninstâœÂ² : AddAction G Î±\ninstâœÂ¹ : ContinuousConstVAdd G Î±\ninstâœ : TopologicalSpace Î²\nf : Î² â†’ Î±\ns : Set Î²\nc : G\nâŠ¢ Iff (ContinuousOn (fun x => HVAdd.hVAdd c (f x)) s) (ContinuousOn f s)","decl":"@[to_additive]\ntheorem continuousOn_const_smul_iff (c : G) :\n    ContinuousOn (fun x => c â€¢ f x) s â†” ContinuousOn f s :=\n  forallâ‚‚_congr fun _ _ => continuousWithinAt_const_smul_iff c\n\n"}
{"name":"continuousAt_const_vadd_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nG : Type u_4\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : AddGroup G\ninstâœÂ² : AddAction G Î±\ninstâœÂ¹ : ContinuousConstVAdd G Î±\ninstâœ : TopologicalSpace Î²\nf : Î² â†’ Î±\nb : Î²\nc : G\nâŠ¢ Iff (ContinuousAt (fun x => HVAdd.hVAdd c (f x)) b) (ContinuousAt f b)","decl":"@[to_additive]\ntheorem continuousAt_const_smul_iff (c : G) :\n    ContinuousAt (fun x => c â€¢ f x) b â†” ContinuousAt f b :=\n  tendsto_const_smul_iff c\n\n"}
{"name":"continuousAt_const_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nG : Type u_4\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : Group G\ninstâœÂ² : MulAction G Î±\ninstâœÂ¹ : ContinuousConstSMul G Î±\ninstâœ : TopologicalSpace Î²\nf : Î² â†’ Î±\nb : Î²\nc : G\nâŠ¢ Iff (ContinuousAt (fun x => HSMul.hSMul c (f x)) b) (ContinuousAt f b)","decl":"@[to_additive]\ntheorem continuousAt_const_smul_iff (c : G) :\n    ContinuousAt (fun x => c â€¢ f x) b â†” ContinuousAt f b :=\n  tendsto_const_smul_iff c\n\n"}
{"name":"continuous_const_vadd_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nG : Type u_4\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : AddGroup G\ninstâœÂ² : AddAction G Î±\ninstâœÂ¹ : ContinuousConstVAdd G Î±\ninstâœ : TopologicalSpace Î²\nf : Î² â†’ Î±\nc : G\nâŠ¢ Iff (Continuous fun x => HVAdd.hVAdd c (f x)) (Continuous f)","decl":"@[to_additive]\ntheorem continuous_const_smul_iff (c : G) : (Continuous fun x => c â€¢ f x) â†” Continuous f := by\n  simp only [continuous_iff_continuousAt, continuousAt_const_smul_iff]\n\n"}
{"name":"continuous_const_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nG : Type u_4\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : Group G\ninstâœÂ² : MulAction G Î±\ninstâœÂ¹ : ContinuousConstSMul G Î±\ninstâœ : TopologicalSpace Î²\nf : Î² â†’ Î±\nc : G\nâŠ¢ Iff (Continuous fun x => HSMul.hSMul c (f x)) (Continuous f)","decl":"@[to_additive]\ntheorem continuous_const_smul_iff (c : G) : (Continuous fun x => c â€¢ f x) â†” Continuous f := by\n  simp only [continuous_iff_continuousAt, continuousAt_const_smul_iff]\n\n"}
{"name":"Homeomorph.smul_apply","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : Group G\ninstâœÂ¹ : MulAction G Î±\ninstâœ : ContinuousConstSMul G Î±\nÎ³ : G\nx : Î±\nâŠ¢ Eq ((Homeomorph.smul Î³) x) (HSMul.hSMul Î³ x)","decl":"/-- The homeomorphism given by scalar multiplication by a given element of a group `Î“` acting on\n  `T` is a homeomorphism from `T` to itself. -/\n@[to_additive (attr := simps!)]\ndef Homeomorph.smul (Î³ : G) : Î± â‰ƒâ‚œ Î± where\n  toEquiv := MulAction.toPerm Î³\n  continuous_toFun := continuous_const_smul Î³\n  continuous_invFun := continuous_const_smul Î³â»Â¹\n\n"}
{"name":"Homeomorph.vadd_apply","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : AddAction G Î±\ninstâœ : ContinuousConstVAdd G Î±\nÎ³ : G\nx : Î±\nâŠ¢ Eq ((Homeomorph.vadd Î³) x) (HVAdd.hVAdd Î³ x)","decl":"/-- The homeomorphism given by scalar multiplication by a given element of a group `Î“` acting on\n  `T` is a homeomorphism from `T` to itself. -/\n@[to_additive (attr := simps!)]\ndef Homeomorph.smul (Î³ : G) : Î± â‰ƒâ‚œ Î± where\n  toEquiv := MulAction.toPerm Î³\n  continuous_toFun := continuous_const_smul Î³\n  continuous_invFun := continuous_const_smul Î³â»Â¹\n\n"}
{"name":"Homeomorph.vadd_symm_apply","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : AddAction G Î±\ninstâœ : ContinuousConstVAdd G Î±\nÎ³ : G\nx : Î±\nâŠ¢ Eq ((Homeomorph.vadd Î³).symm x) (HVAdd.hVAdd (Neg.neg Î³) x)","decl":"/-- The homeomorphism given by scalar multiplication by a given element of a group `Î“` acting on\n  `T` is a homeomorphism from `T` to itself. -/\n@[to_additive (attr := simps!)]\ndef Homeomorph.smul (Î³ : G) : Î± â‰ƒâ‚œ Î± where\n  toEquiv := MulAction.toPerm Î³\n  continuous_toFun := continuous_const_smul Î³\n  continuous_invFun := continuous_const_smul Î³â»Â¹\n\n"}
{"name":"Homeomorph.smul_symm_apply","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : Group G\ninstâœÂ¹ : MulAction G Î±\ninstâœ : ContinuousConstSMul G Î±\nÎ³ : G\nx : Î±\nâŠ¢ Eq ((Homeomorph.smul Î³).symm x) (HSMul.hSMul (Inv.inv Î³) x)","decl":"/-- The homeomorphism given by scalar multiplication by a given element of a group `Î“` acting on\n  `T` is a homeomorphism from `T` to itself. -/\n@[to_additive (attr := simps!)]\ndef Homeomorph.smul (Î³ : G) : Î± â‰ƒâ‚œ Î± where\n  toEquiv := MulAction.toPerm Î³\n  continuous_toFun := continuous_const_smul Î³\n  continuous_invFun := continuous_const_smul Î³â»Â¹\n\n"}
{"name":"isOpenMap_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : AddAction G Î±\ninstâœ : ContinuousConstVAdd G Î±\nc : G\nâŠ¢ IsOpenMap fun x => HVAdd.hVAdd c x","decl":"@[to_additive]\ntheorem isOpenMap_smul (c : G) : IsOpenMap fun x : Î± => c â€¢ x :=\n  (Homeomorph.smul c).isOpenMap\n\n"}
{"name":"isOpenMap_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : Group G\ninstâœÂ¹ : MulAction G Î±\ninstâœ : ContinuousConstSMul G Î±\nc : G\nâŠ¢ IsOpenMap fun x => HSMul.hSMul c x","decl":"@[to_additive]\ntheorem isOpenMap_smul (c : G) : IsOpenMap fun x : Î± => c â€¢ x :=\n  (Homeomorph.smul c).isOpenMap\n\n"}
{"name":"IsOpen.smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : Group G\ninstâœÂ¹ : MulAction G Î±\ninstâœ : ContinuousConstSMul G Î±\ns : Set Î±\nhs : IsOpen s\nc : G\nâŠ¢ IsOpen (HSMul.hSMul c s)","decl":"@[to_additive]\ntheorem IsOpen.smul {s : Set Î±} (hs : IsOpen s) (c : G) : IsOpen (c â€¢ s) :=\n  isOpenMap_smul c s hs\n\n"}
{"name":"IsOpen.vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : AddAction G Î±\ninstâœ : ContinuousConstVAdd G Î±\ns : Set Î±\nhs : IsOpen s\nc : G\nâŠ¢ IsOpen (HVAdd.hVAdd c s)","decl":"@[to_additive]\ntheorem IsOpen.smul {s : Set Î±} (hs : IsOpen s) (c : G) : IsOpen (c â€¢ s) :=\n  isOpenMap_smul c s hs\n\n"}
{"name":"isClosedMap_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : AddAction G Î±\ninstâœ : ContinuousConstVAdd G Î±\nc : G\nâŠ¢ IsClosedMap fun x => HVAdd.hVAdd c x","decl":"@[to_additive]\ntheorem isClosedMap_smul (c : G) : IsClosedMap fun x : Î± => c â€¢ x :=\n  (Homeomorph.smul c).isClosedMap\n\n"}
{"name":"isClosedMap_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : Group G\ninstâœÂ¹ : MulAction G Î±\ninstâœ : ContinuousConstSMul G Î±\nc : G\nâŠ¢ IsClosedMap fun x => HSMul.hSMul c x","decl":"@[to_additive]\ntheorem isClosedMap_smul (c : G) : IsClosedMap fun x : Î± => c â€¢ x :=\n  (Homeomorph.smul c).isClosedMap\n\n"}
{"name":"IsClosed.vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : AddAction G Î±\ninstâœ : ContinuousConstVAdd G Î±\ns : Set Î±\nhs : IsClosed s\nc : G\nâŠ¢ IsClosed (HVAdd.hVAdd c s)","decl":"@[to_additive]\ntheorem IsClosed.smul {s : Set Î±} (hs : IsClosed s) (c : G) : IsClosed (c â€¢ s) :=\n  isClosedMap_smul c s hs\n\n"}
{"name":"IsClosed.smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : Group G\ninstâœÂ¹ : MulAction G Î±\ninstâœ : ContinuousConstSMul G Î±\ns : Set Î±\nhs : IsClosed s\nc : G\nâŠ¢ IsClosed (HSMul.hSMul c s)","decl":"@[to_additive]\ntheorem IsClosed.smul {s : Set Î±} (hs : IsClosed s) (c : G) : IsClosed (c â€¢ s) :=\n  isClosedMap_smul c s hs\n\n"}
{"name":"closure_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : AddAction G Î±\ninstâœ : ContinuousConstVAdd G Î±\nc : G\ns : Set Î±\nâŠ¢ Eq (closure (HVAdd.hVAdd c s)) (HVAdd.hVAdd c (closure s))","decl":"@[to_additive]\ntheorem closure_smul (c : G) (s : Set Î±) : closure (c â€¢ s) = c â€¢ closure s :=\n  ((Homeomorph.smul c).image_closure s).symm\n\n"}
{"name":"closure_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : Group G\ninstâœÂ¹ : MulAction G Î±\ninstâœ : ContinuousConstSMul G Î±\nc : G\ns : Set Î±\nâŠ¢ Eq (closure (HSMul.hSMul c s)) (HSMul.hSMul c (closure s))","decl":"@[to_additive]\ntheorem closure_smul (c : G) (s : Set Î±) : closure (c â€¢ s) = c â€¢ closure s :=\n  ((Homeomorph.smul c).image_closure s).symm\n\n"}
{"name":"Dense.vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : AddAction G Î±\ninstâœ : ContinuousConstVAdd G Î±\nc : G\ns : Set Î±\nhs : Dense s\nâŠ¢ Dense (HVAdd.hVAdd c s)","decl":"@[to_additive]\ntheorem Dense.smul (c : G) {s : Set Î±} (hs : Dense s) : Dense (c â€¢ s) := by\n  rw [dense_iff_closure_eq] at hs âŠ¢; rw [closure_smul, hs, smul_set_univ]\n\n"}
{"name":"Dense.smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : Group G\ninstâœÂ¹ : MulAction G Î±\ninstâœ : ContinuousConstSMul G Î±\nc : G\ns : Set Î±\nhs : Dense s\nâŠ¢ Dense (HSMul.hSMul c s)","decl":"@[to_additive]\ntheorem Dense.smul (c : G) {s : Set Î±} (hs : Dense s) : Dense (c â€¢ s) := by\n  rw [dense_iff_closure_eq] at hs âŠ¢; rw [closure_smul, hs, smul_set_univ]\n\n"}
{"name":"interior_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : Group G\ninstâœÂ¹ : MulAction G Î±\ninstâœ : ContinuousConstSMul G Î±\nc : G\ns : Set Î±\nâŠ¢ Eq (interior (HSMul.hSMul c s)) (HSMul.hSMul c (interior s))","decl":"@[to_additive]\ntheorem interior_smul (c : G) (s : Set Î±) : interior (c â€¢ s) = c â€¢ interior s :=\n  ((Homeomorph.smul c).image_interior s).symm\n\n"}
{"name":"interior_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : AddAction G Î±\ninstâœ : ContinuousConstVAdd G Î±\nc : G\ns : Set Î±\nâŠ¢ Eq (interior (HVAdd.hVAdd c s)) (HVAdd.hVAdd c (interior s))","decl":"@[to_additive]\ntheorem interior_smul (c : G) (s : Set Î±) : interior (c â€¢ s) = c â€¢ interior s :=\n  ((Homeomorph.smul c).image_interior s).symm\n\n"}
{"name":"IsOpen.vadd_left","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : AddAction G Î±\ninstâœ : ContinuousConstVAdd G Î±\ns : Set G\nt : Set Î±\nht : IsOpen t\nâŠ¢ IsOpen (HVAdd.hVAdd s t)","decl":"@[to_additive]\ntheorem IsOpen.smul_left {s : Set G} {t : Set Î±} (ht : IsOpen t) : IsOpen (s â€¢ t) := by\n  rw [â† iUnion_smul_set]\n  exact isOpen_biUnion fun a _ => ht.smul _\n\n"}
{"name":"IsOpen.smul_left","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : Group G\ninstâœÂ¹ : MulAction G Î±\ninstâœ : ContinuousConstSMul G Î±\ns : Set G\nt : Set Î±\nht : IsOpen t\nâŠ¢ IsOpen (HSMul.hSMul s t)","decl":"@[to_additive]\ntheorem IsOpen.smul_left {s : Set G} {t : Set Î±} (ht : IsOpen t) : IsOpen (s â€¢ t) := by\n  rw [â† iUnion_smul_set]\n  exact isOpen_biUnion fun a _ => ht.smul _\n\n"}
{"name":"subset_interior_vadd_right","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : AddAction G Î±\ninstâœ : ContinuousConstVAdd G Î±\ns : Set G\nt : Set Î±\nâŠ¢ HasSubset.Subset (HVAdd.hVAdd s (interior t)) (interior (HVAdd.hVAdd s t))","decl":"@[to_additive]\ntheorem subset_interior_smul_right {s : Set G} {t : Set Î±} : s â€¢ interior t âŠ† interior (s â€¢ t) :=\n  interior_maximal (Set.smul_subset_smul_left interior_subset) isOpen_interior.smul_left\n\n"}
{"name":"subset_interior_smul_right","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : Group G\ninstâœÂ¹ : MulAction G Î±\ninstâœ : ContinuousConstSMul G Î±\ns : Set G\nt : Set Î±\nâŠ¢ HasSubset.Subset (HSMul.hSMul s (interior t)) (interior (HSMul.hSMul s t))","decl":"@[to_additive]\ntheorem subset_interior_smul_right {s : Set G} {t : Set Î±} : s â€¢ interior t âŠ† interior (s â€¢ t) :=\n  interior_maximal (Set.smul_subset_smul_left interior_subset) isOpen_interior.smul_left\n\n"}
{"name":"vadd_mem_nhds_vadd_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : AddAction G Î±\ninstâœ : ContinuousConstVAdd G Î±\nt : Set Î±\ng : G\na : Î±\nâŠ¢ Iff (Membership.mem (nhds (HVAdd.hVAdd g a)) (HVAdd.hVAdd g t)) (Membership.mem (nhds a) t)","decl":"@[to_additive (attr := simp)]\ntheorem smul_mem_nhds_smul_iff {t : Set Î±} (g : G) {a : Î±} : g â€¢ t âˆˆ ğ“ (g â€¢ a) â†” t âˆˆ ğ“ a :=\n  (Homeomorph.smul g).isOpenEmbedding.image_mem_nhds\n\n"}
{"name":"smul_mem_nhds_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : Group G\ninstâœÂ¹ : MulAction G Î±\ninstâœ : ContinuousConstSMul G Î±\nt : Set Î±\ng : G\na : Î±\nâŠ¢ Iff (Membership.mem (nhds (HSMul.hSMul g a)) (HSMul.hSMul g t)) (Membership.mem (nhds a) t)","decl":"@[to_additive (attr := simp)]\ntheorem smul_mem_nhds_smul_iff {t : Set Î±} (g : G) {a : Î±} : g â€¢ t âˆˆ ğ“ (g â€¢ a) â†” t âˆˆ ğ“ a :=\n  (Homeomorph.smul g).isOpenEmbedding.image_mem_nhds\n\n"}
{"name":"smul_mem_nhds_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : Group G\ninstâœÂ¹ : MulAction G Î±\ninstâœ : ContinuousConstSMul G Î±\nt : Set Î±\ng : G\na : Î±\naâœ : Membership.mem (nhds a) t\nâŠ¢ Membership.mem (nhds (HSMul.hSMul g a)) (HSMul.hSMul g t)","decl":"@[to_additive] alias âŸ¨_, smul_mem_nhds_smulâŸ© := smul_mem_nhds_smul_iff\n\n"}
{"name":"vadd_mem_nhds_vadd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : AddAction G Î±\ninstâœ : ContinuousConstVAdd G Î±\nt : Set Î±\ng : G\na : Î±\naâœ : Membership.mem (nhds a) t\nâŠ¢ Membership.mem (nhds (HVAdd.hVAdd g a)) (HVAdd.hVAdd g t)","decl":"@[to_additive] alias âŸ¨_, smul_mem_nhds_smulâŸ© := smul_mem_nhds_smul_iff\n\n"}
{"name":"vadd_mem_nhds","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : AddAction G Î±\ninstâœ : ContinuousConstVAdd G Î±\nt : Set Î±\ng : G\na : Î±\naâœ : Membership.mem (nhds a) t\nâŠ¢ Membership.mem (nhds (HVAdd.hVAdd g a)) (HVAdd.hVAdd g t)","decl":"@[to_additive (attr := deprecated \"No deprecation message was provided.\" (since := \"2024-08-06\"))]\nalias smul_mem_nhds := smul_mem_nhds_smul\n\n"}
{"name":"smul_mem_nhds","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : Group G\ninstâœÂ¹ : MulAction G Î±\ninstâœ : ContinuousConstSMul G Î±\nt : Set Î±\ng : G\na : Î±\naâœ : Membership.mem (nhds a) t\nâŠ¢ Membership.mem (nhds (HSMul.hSMul g a)) (HSMul.hSMul g t)","decl":"@[to_additive (attr := deprecated \"No deprecation message was provided.\" (since := \"2024-08-06\"))]\nalias smul_mem_nhds := smul_mem_nhds_smul\n\n"}
{"name":"smul_mem_nhds_self","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"G : Type u_4\ninstâœÂ² : Group G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : ContinuousConstSMul G G\ng : G\ns : Set G\nâŠ¢ Iff (Membership.mem (nhds g) (HSMul.hSMul g s)) (Membership.mem (nhds 1) s)","decl":"@[to_additive (attr := simp)]\ntheorem smul_mem_nhds_self [TopologicalSpace G] [ContinuousConstSMul G G] {g : G} {s : Set G} :\n    g â€¢ s âˆˆ ğ“ g â†” s âˆˆ ğ“ 1 := by\n  rw [â† smul_mem_nhds_smul_iff gâ»Â¹]; simp\n\n"}
{"name":"vadd_mem_nhds_self","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"G : Type u_4\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : ContinuousConstVAdd G G\ng : G\ns : Set G\nâŠ¢ Iff (Membership.mem (nhds g) (HVAdd.hVAdd g s)) (Membership.mem (nhds 0) s)","decl":"@[to_additive (attr := simp)]\ntheorem smul_mem_nhds_self [TopologicalSpace G] [ContinuousConstSMul G G] {g : G} {s : Set G} :\n    g â€¢ s âˆˆ ğ“ g â†” s âˆˆ ğ“ 1 := by\n  rw [â† smul_mem_nhds_smul_iff gâ»Â¹]; simp\n\n"}
{"name":"tendsto_const_smul_iffâ‚€","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nGâ‚€ : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : GroupWithZero Gâ‚€\ninstâœÂ¹ : MulAction Gâ‚€ Î±\ninstâœ : ContinuousConstSMul Gâ‚€ Î±\nf : Î² â†’ Î±\nl : Filter Î²\na : Î±\nc : Gâ‚€\nhc : Ne c 0\nâŠ¢ Iff (Filter.Tendsto (fun x => HSMul.hSMul c (f x)) l (nhds (HSMul.hSMul c a))) (Filter.Tendsto f l (nhds a))","decl":"theorem tendsto_const_smul_iffâ‚€ {f : Î² â†’ Î±} {l : Filter Î²} {a : Î±} {c : Gâ‚€} (hc : c â‰  0) :\n    Tendsto (fun x => c â€¢ f x) l (ğ“ <| c â€¢ a) â†” Tendsto f l (ğ“ a) :=\n  tendsto_const_smul_iff (Units.mk0 c hc)\n\n"}
{"name":"continuousWithinAt_const_smul_iffâ‚€","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nGâ‚€ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : GroupWithZero Gâ‚€\ninstâœÂ² : MulAction Gâ‚€ Î±\ninstâœÂ¹ : ContinuousConstSMul Gâ‚€ Î±\ninstâœ : TopologicalSpace Î²\nf : Î² â†’ Î±\nb : Î²\nc : Gâ‚€\ns : Set Î²\nhc : Ne c 0\nâŠ¢ Iff (ContinuousWithinAt (fun x => HSMul.hSMul c (f x)) s b) (ContinuousWithinAt f s b)","decl":"theorem continuousWithinAt_const_smul_iffâ‚€ (hc : c â‰  0) :\n    ContinuousWithinAt (fun x => c â€¢ f x) s b â†” ContinuousWithinAt f s b :=\n  tendsto_const_smul_iff (Units.mk0 c hc)\n\n"}
{"name":"continuousOn_const_smul_iffâ‚€","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nGâ‚€ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : GroupWithZero Gâ‚€\ninstâœÂ² : MulAction Gâ‚€ Î±\ninstâœÂ¹ : ContinuousConstSMul Gâ‚€ Î±\ninstâœ : TopologicalSpace Î²\nf : Î² â†’ Î±\nc : Gâ‚€\ns : Set Î²\nhc : Ne c 0\nâŠ¢ Iff (ContinuousOn (fun x => HSMul.hSMul c (f x)) s) (ContinuousOn f s)","decl":"theorem continuousOn_const_smul_iffâ‚€ (hc : c â‰  0) :\n    ContinuousOn (fun x => c â€¢ f x) s â†” ContinuousOn f s :=\n  continuousOn_const_smul_iff (Units.mk0 c hc)\n\n"}
{"name":"continuousAt_const_smul_iffâ‚€","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nGâ‚€ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : GroupWithZero Gâ‚€\ninstâœÂ² : MulAction Gâ‚€ Î±\ninstâœÂ¹ : ContinuousConstSMul Gâ‚€ Î±\ninstâœ : TopologicalSpace Î²\nf : Î² â†’ Î±\nb : Î²\nc : Gâ‚€\nhc : Ne c 0\nâŠ¢ Iff (ContinuousAt (fun x => HSMul.hSMul c (f x)) b) (ContinuousAt f b)","decl":"theorem continuousAt_const_smul_iffâ‚€ (hc : c â‰  0) :\n    ContinuousAt (fun x => c â€¢ f x) b â†” ContinuousAt f b :=\n  continuousAt_const_smul_iff (Units.mk0 c hc)\n\n"}
{"name":"continuous_const_smul_iffâ‚€","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nGâ‚€ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : GroupWithZero Gâ‚€\ninstâœÂ² : MulAction Gâ‚€ Î±\ninstâœÂ¹ : ContinuousConstSMul Gâ‚€ Î±\ninstâœ : TopologicalSpace Î²\nf : Î² â†’ Î±\nc : Gâ‚€\nhc : Ne c 0\nâŠ¢ Iff (Continuous fun x => HSMul.hSMul c (f x)) (Continuous f)","decl":"theorem continuous_const_smul_iffâ‚€ (hc : c â‰  0) : (Continuous fun x => c â€¢ f x) â†” Continuous f :=\n  continuous_const_smul_iff (Units.mk0 c hc)\n\n"}
{"name":"Homeomorph.smulOfNeZero_apply","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nGâ‚€ : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : GroupWithZero Gâ‚€\ninstâœÂ¹ : MulAction Gâ‚€ Î±\ninstâœ : ContinuousConstSMul Gâ‚€ Î±\nc : Gâ‚€\nhc : Ne c 0\nâŠ¢ Eq â‡‘(Homeomorph.smulOfNeZero c hc) fun x => HSMul.hSMul (Units.mk0 c hc) x","decl":"/-- Scalar multiplication by a non-zero element of a group with zero acting on `Î±` is a\nhomeomorphism from `Î±` onto itself. -/\n@[simps! (config := .asFn) apply]\nprotected def Homeomorph.smulOfNeZero (c : Gâ‚€) (hc : c â‰  0) : Î± â‰ƒâ‚œ Î± :=\n  Homeomorph.smul (Units.mk0 c hc)\n\n"}
{"name":"Homeomorph.smulOfNeZero_symm_apply","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nGâ‚€ : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : GroupWithZero Gâ‚€\ninstâœÂ¹ : MulAction Gâ‚€ Î±\ninstâœ : ContinuousConstSMul Gâ‚€ Î±\nc : Gâ‚€\nhc : Ne c 0\nâŠ¢ Eq â‡‘(Homeomorph.smulOfNeZero c hc).symm fun x => HSMul.hSMul (Inv.inv c) x","decl":"@[simp]\ntheorem Homeomorph.smulOfNeZero_symm_apply {c : Gâ‚€} (hc : c â‰  0) :\n    â‡‘(Homeomorph.smulOfNeZero c hc).symm = (câ»Â¹ â€¢ Â· : Î± â†’ Î±) :=\n  rfl\n\n"}
{"name":"isOpenMap_smulâ‚€","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nGâ‚€ : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : GroupWithZero Gâ‚€\ninstâœÂ¹ : MulAction Gâ‚€ Î±\ninstâœ : ContinuousConstSMul Gâ‚€ Î±\nc : Gâ‚€\nhc : Ne c 0\nâŠ¢ IsOpenMap fun x => HSMul.hSMul c x","decl":"theorem isOpenMap_smulâ‚€ {c : Gâ‚€} (hc : c â‰  0) : IsOpenMap fun x : Î± => c â€¢ x :=\n  (Homeomorph.smulOfNeZero c hc).isOpenMap\n\n"}
{"name":"IsOpen.smulâ‚€","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nGâ‚€ : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : GroupWithZero Gâ‚€\ninstâœÂ¹ : MulAction Gâ‚€ Î±\ninstâœ : ContinuousConstSMul Gâ‚€ Î±\nc : Gâ‚€\ns : Set Î±\nhs : IsOpen s\nhc : Ne c 0\nâŠ¢ IsOpen (HSMul.hSMul c s)","decl":"theorem IsOpen.smulâ‚€ {c : Gâ‚€} {s : Set Î±} (hs : IsOpen s) (hc : c â‰  0) : IsOpen (c â€¢ s) :=\n  isOpenMap_smulâ‚€ hc s hs\n\n"}
{"name":"interior_smulâ‚€","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nGâ‚€ : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : GroupWithZero Gâ‚€\ninstâœÂ¹ : MulAction Gâ‚€ Î±\ninstâœ : ContinuousConstSMul Gâ‚€ Î±\nc : Gâ‚€\nhc : Ne c 0\ns : Set Î±\nâŠ¢ Eq (interior (HSMul.hSMul c s)) (HSMul.hSMul c (interior s))","decl":"theorem interior_smulâ‚€ {c : Gâ‚€} (hc : c â‰  0) (s : Set Î±) : interior (c â€¢ s) = c â€¢ interior s :=\n  ((Homeomorph.smulOfNeZero c hc).image_interior s).symm\n\n"}
{"name":"closure_smulâ‚€'","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nGâ‚€ : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : GroupWithZero Gâ‚€\ninstâœÂ¹ : MulAction Gâ‚€ Î±\ninstâœ : ContinuousConstSMul Gâ‚€ Î±\nc : Gâ‚€\nhc : Ne c 0\ns : Set Î±\nâŠ¢ Eq (closure (HSMul.hSMul c s)) (HSMul.hSMul c (closure s))","decl":"theorem closure_smulâ‚€' {c : Gâ‚€} (hc : c â‰  0) (s : Set Î±) :\n    closure (c â€¢ s) = c â€¢ closure s :=\n  ((Homeomorph.smulOfNeZero c hc).image_closure s).symm\n\n"}
{"name":"closure_smulâ‚€","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Gâ‚€ : Type u_4\ninstâœâµ : GroupWithZero Gâ‚€\nE : Type u_5\ninstâœâ´ : Zero E\ninstâœÂ³ : MulActionWithZero Gâ‚€ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : T1Space E\ninstâœ : ContinuousConstSMul Gâ‚€ E\nc : Gâ‚€\ns : Set E\nâŠ¢ Eq (closure (HSMul.hSMul c s)) (HSMul.hSMul c (closure s))","decl":"theorem closure_smulâ‚€ {E} [Zero E] [MulActionWithZero Gâ‚€ E] [TopologicalSpace E] [T1Space E]\n    [ContinuousConstSMul Gâ‚€ E] (c : Gâ‚€) (s : Set E) : closure (c â€¢ s) = c â€¢ closure s := by\n  rcases eq_or_ne c 0 with (rfl | hc)\n  Â· rcases eq_empty_or_nonempty s with (rfl | hs)\n    Â· simp\n    Â· rw [zero_smul_set hs, zero_smul_set hs.closure]\n      exact closure_singleton\n  Â· exact closure_smulâ‚€' hc s\n\n"}
{"name":"isClosedMap_smul_of_ne_zero","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nGâ‚€ : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : GroupWithZero Gâ‚€\ninstâœÂ¹ : MulAction Gâ‚€ Î±\ninstâœ : ContinuousConstSMul Gâ‚€ Î±\nc : Gâ‚€\nhc : Ne c 0\nâŠ¢ IsClosedMap fun x => HSMul.hSMul c x","decl":"/-- `smul` is a closed map in the second argument.\n\nThe lemma that `smul` is a closed map in the first argument (for a normed space over a complete\nnormed field) is `isClosedMap_smul_left` in `Analysis.Normed.Module.FiniteDimension`. -/\ntheorem isClosedMap_smul_of_ne_zero {c : Gâ‚€} (hc : c â‰  0) : IsClosedMap fun x : Î± => c â€¢ x :=\n  (Homeomorph.smulOfNeZero c hc).isClosedMap\n\n"}
{"name":"IsClosed.smul_of_ne_zero","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nGâ‚€ : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : GroupWithZero Gâ‚€\ninstâœÂ¹ : MulAction Gâ‚€ Î±\ninstâœ : ContinuousConstSMul Gâ‚€ Î±\nc : Gâ‚€\ns : Set Î±\nhs : IsClosed s\nhc : Ne c 0\nâŠ¢ IsClosed (HSMul.hSMul c s)","decl":"theorem IsClosed.smul_of_ne_zero {c : Gâ‚€} {s : Set Î±} (hs : IsClosed s) (hc : c â‰  0) :\n    IsClosed (c â€¢ s) :=\n  isClosedMap_smul_of_ne_zero hc s hs\n\n"}
{"name":"isClosedMap_smulâ‚€","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Gâ‚€ : Type u_4\ninstâœâµ : GroupWithZero Gâ‚€\nE : Type u_5\ninstâœâ´ : Zero E\ninstâœÂ³ : MulActionWithZero Gâ‚€ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : T1Space E\ninstâœ : ContinuousConstSMul Gâ‚€ E\nc : Gâ‚€\nâŠ¢ IsClosedMap fun x => HSMul.hSMul c x","decl":"/-- `smul` is a closed map in the second argument.\n\nThe lemma that `smul` is a closed map in the first argument (for a normed space over a complete\nnormed field) is `isClosedMap_smul_left` in `Analysis.Normed.Module.FiniteDimension`. -/\ntheorem isClosedMap_smulâ‚€ {E : Type*} [Zero E] [MulActionWithZero Gâ‚€ E] [TopologicalSpace E]\n    [T1Space E] [ContinuousConstSMul Gâ‚€ E] (c : Gâ‚€) : IsClosedMap fun x : E => c â€¢ x := by\n  rcases eq_or_ne c 0 with (rfl | hne)\n  Â· simp only [zero_smul]\n    exact isClosedMap_const\n  Â· exact (Homeomorph.smulOfNeZero c hne).isClosedMap\n\n"}
{"name":"IsClosed.smulâ‚€","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Gâ‚€ : Type u_4\ninstâœâµ : GroupWithZero Gâ‚€\nE : Type u_5\ninstâœâ´ : Zero E\ninstâœÂ³ : MulActionWithZero Gâ‚€ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : T1Space E\ninstâœ : ContinuousConstSMul Gâ‚€ E\nc : Gâ‚€\ns : Set E\nhs : IsClosed s\nâŠ¢ IsClosed (HSMul.hSMul c s)","decl":"theorem IsClosed.smulâ‚€ {E : Type*} [Zero E] [MulActionWithZero Gâ‚€ E] [TopologicalSpace E]\n    [T1Space E] [ContinuousConstSMul Gâ‚€ E] (c : Gâ‚€) {s : Set E} (hs : IsClosed s) :\n    IsClosed (c â€¢ s) :=\n  isClosedMap_smulâ‚€ c s hs\n\n"}
{"name":"HasCompactMulSupport.comp_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nGâ‚€ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : GroupWithZero Gâ‚€\ninstâœÂ² : MulAction Gâ‚€ Î±\ninstâœÂ¹ : ContinuousConstSMul Gâ‚€ Î±\nÎ² : Type u_5\ninstâœ : One Î²\nf : Î± â†’ Î²\nh : HasCompactMulSupport f\nc : Gâ‚€\nhc : Ne c 0\nâŠ¢ HasCompactMulSupport fun x => f (HSMul.hSMul c x)","decl":"theorem HasCompactMulSupport.comp_smul {Î² : Type*} [One Î²] {f : Î± â†’ Î²} (h : HasCompactMulSupport f)\n    {c : Gâ‚€} (hc : c â‰  0) : HasCompactMulSupport fun x => f (c â€¢ x) :=\n  h.comp_homeomorph (Homeomorph.smulOfNeZero c hc)\n\n"}
{"name":"HasCompactSupport.comp_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nGâ‚€ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : GroupWithZero Gâ‚€\ninstâœÂ² : MulAction Gâ‚€ Î±\ninstâœÂ¹ : ContinuousConstSMul Gâ‚€ Î±\nÎ² : Type u_5\ninstâœ : Zero Î²\nf : Î± â†’ Î²\nh : HasCompactSupport f\nc : Gâ‚€\nhc : Ne c 0\nâŠ¢ HasCompactSupport fun x => f (HSMul.hSMul c x)","decl":"theorem HasCompactSupport.comp_smul {Î² : Type*} [Zero Î²] {f : Î± â†’ Î²} (h : HasCompactSupport f)\n    {c : Gâ‚€} (hc : c â‰  0) : HasCompactSupport fun x => f (c â€¢ x) :=\n  h.comp_homeomorph (Homeomorph.smulOfNeZero c hc)\n\n"}
{"name":"IsUnit.tendsto_const_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : Monoid M\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : MulAction M Î±\ninstâœ : ContinuousConstSMul M Î±\nf : Î² â†’ Î±\nl : Filter Î²\na : Î±\nc : M\nhc : IsUnit c\nâŠ¢ Iff (Filter.Tendsto (fun x => HSMul.hSMul c (f x)) l (nhds (HSMul.hSMul c a))) (Filter.Tendsto f l (nhds a))","decl":"nonrec theorem tendsto_const_smul_iff {f : Î² â†’ Î±} {l : Filter Î²} {a : Î±} {c : M} (hc : IsUnit c) :\n    Tendsto (fun x => c â€¢ f x) l (ğ“ <| c â€¢ a) â†” Tendsto f l (ğ“ a) :=\n  tendsto_const_smul_iff hc.unit\n\n"}
{"name":"IsUnit.continuousWithinAt_const_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœâ´ : Monoid M\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : MulAction M Î±\ninstâœÂ¹ : ContinuousConstSMul M Î±\ninstâœ : TopologicalSpace Î²\nf : Î² â†’ Î±\nb : Î²\nc : M\ns : Set Î²\nhc : IsUnit c\nâŠ¢ Iff (ContinuousWithinAt (fun x => HSMul.hSMul c (f x)) s b) (ContinuousWithinAt f s b)","decl":"nonrec theorem continuousWithinAt_const_smul_iff (hc : IsUnit c) :\n    ContinuousWithinAt (fun x => c â€¢ f x) s b â†” ContinuousWithinAt f s b :=\n  continuousWithinAt_const_smul_iff hc.unit\n\n"}
{"name":"IsUnit.continuousOn_const_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœâ´ : Monoid M\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : MulAction M Î±\ninstâœÂ¹ : ContinuousConstSMul M Î±\ninstâœ : TopologicalSpace Î²\nf : Î² â†’ Î±\nc : M\ns : Set Î²\nhc : IsUnit c\nâŠ¢ Iff (ContinuousOn (fun x => HSMul.hSMul c (f x)) s) (ContinuousOn f s)","decl":"nonrec theorem continuousOn_const_smul_iff (hc : IsUnit c) :\n    ContinuousOn (fun x => c â€¢ f x) s â†” ContinuousOn f s :=\n  continuousOn_const_smul_iff hc.unit\n\n"}
{"name":"IsUnit.continuousAt_const_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœâ´ : Monoid M\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : MulAction M Î±\ninstâœÂ¹ : ContinuousConstSMul M Î±\ninstâœ : TopologicalSpace Î²\nf : Î² â†’ Î±\nb : Î²\nc : M\nhc : IsUnit c\nâŠ¢ Iff (ContinuousAt (fun x => HSMul.hSMul c (f x)) b) (ContinuousAt f b)","decl":"nonrec theorem continuousAt_const_smul_iff (hc : IsUnit c) :\n    ContinuousAt (fun x => c â€¢ f x) b â†” ContinuousAt f b :=\n  continuousAt_const_smul_iff hc.unit\n\n"}
{"name":"IsUnit.continuous_const_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœâ´ : Monoid M\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : MulAction M Î±\ninstâœÂ¹ : ContinuousConstSMul M Î±\ninstâœ : TopologicalSpace Î²\nf : Î² â†’ Î±\nc : M\nhc : IsUnit c\nâŠ¢ Iff (Continuous fun x => HSMul.hSMul c (f x)) (Continuous f)","decl":"nonrec theorem continuous_const_smul_iff (hc : IsUnit c) :\n    (Continuous fun x => c â€¢ f x) â†” Continuous f :=\n  continuous_const_smul_iff hc.unit\n\n"}
{"name":"IsUnit.isOpenMap_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ³ : Monoid M\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : MulAction M Î±\ninstâœ : ContinuousConstSMul M Î±\nc : M\nhc : IsUnit c\nâŠ¢ IsOpenMap fun x => HSMul.hSMul c x","decl":"nonrec theorem isOpenMap_smul (hc : IsUnit c) : IsOpenMap fun x : Î± => c â€¢ x :=\n  isOpenMap_smul hc.unit\n\n"}
{"name":"IsUnit.isClosedMap_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ³ : Monoid M\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : MulAction M Î±\ninstâœ : ContinuousConstSMul M Î±\nc : M\nhc : IsUnit c\nâŠ¢ IsClosedMap fun x => HSMul.hSMul c x","decl":"nonrec theorem isClosedMap_smul (hc : IsUnit c) : IsClosedMap fun x : Î± => c â€¢ x :=\n  isClosedMap_smul hc.unit\n\n"}
{"name":"IsUnit.smul_mem_nhds_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"M : Type u_1\nÎ± : Type u_2\ninstâœÂ³ : Monoid M\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : MulAction M Î±\ninstâœ : ContinuousConstSMul M Î±\nc : M\nhc : IsUnit c\ns : Set Î±\na : Î±\nâŠ¢ Iff (Membership.mem (nhds (HSMul.hSMul c a)) (HSMul.hSMul c s)) (Membership.mem (nhds a) s)","decl":"nonrec theorem smul_mem_nhds_smul_iff (hc : IsUnit c) {s : Set Î±} {a : Î±} :\n    c â€¢ s âˆˆ ğ“ (c â€¢ a) â†” s âˆˆ ğ“ a :=\n  smul_mem_nhds_smul_iff hc.unit\n\n"}
{"name":"ProperlyDiscontinuousSMul.finite_disjoint_inter_image","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î“ : Type u_4\nT : Type u_5\ninstâœÂ¹ : TopologicalSpace T\ninstâœ : SMul Î“ T\nself : ProperlyDiscontinuousSMul Î“ T\nK L : Set T\naâœÂ¹ : IsCompact K\naâœ : IsCompact L\nâŠ¢ (setOf fun Î³ => Ne (Inter.inter (Set.image (fun x => HSMul.hSMul Î³ x) K) L) EmptyCollection.emptyCollection).Finite","decl":"/-- Class `ProperlyDiscontinuousSMul Î“ T` says that the scalar multiplication `(â€¢) : Î“ â†’ T â†’ T`\nis properly discontinuous, that is, for any pair of compact sets `K, L` in `T`, only finitely many\n`Î³:Î“` move `K` to have nontrivial intersection with `L`.\n-/\nclass ProperlyDiscontinuousSMul (Î“ : Type*) (T : Type*) [TopologicalSpace T] [SMul Î“ T] :\n    Prop where\n  /-- Given two compact sets `K` and `L`, `Î³ â€¢ K âˆ© L` is nonempty for finitely many `Î³`. -/\n  finite_disjoint_inter_image :\n    âˆ€ {K L : Set T}, IsCompact K â†’ IsCompact L â†’ Set.Finite { Î³ : Î“ | (Î³ â€¢ Â·) '' K âˆ© L â‰  âˆ… }\n\n"}
{"name":"ProperlyDiscontinuousVAdd.finite_disjoint_inter_image","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î“ : Type u_4\nT : Type u_5\ninstâœÂ¹ : TopologicalSpace T\ninstâœ : VAdd Î“ T\nself : ProperlyDiscontinuousVAdd Î“ T\nK L : Set T\naâœÂ¹ : IsCompact K\naâœ : IsCompact L\nâŠ¢ (setOf fun Î³ => Ne (Inter.inter (Set.image (fun x => HVAdd.hVAdd Î³ x) K) L) EmptyCollection.emptyCollection).Finite","decl":"/-- Class `ProperlyDiscontinuousVAdd Î“ T` says that the additive action `(+áµ¥) : Î“ â†’ T â†’ T`\nis properly discontinuous, that is, for any pair of compact sets `K, L` in `T`, only finitely many\n`Î³:Î“` move `K` to have nontrivial intersection with `L`.\n-/\nclass ProperlyDiscontinuousVAdd (Î“ : Type*) (T : Type*) [TopologicalSpace T] [VAdd Î“ T] :\n  Prop where\n  /-- Given two compact sets `K` and `L`, `Î³ +áµ¥ K âˆ© L` is nonempty for finitely many `Î³`. -/\n  finite_disjoint_inter_image :\n    âˆ€ {K L : Set T}, IsCompact K â†’ IsCompact L â†’ Set.Finite { Î³ : Î“ | (Î³ +áµ¥ Â·) '' K âˆ© L â‰  âˆ… }\n\n"}
{"name":"Finite.to_properlyDiscontinuousVAdd","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î“ : Type u_4\ninstâœÂ³ : AddGroup Î“\nT : Type u_5\ninstâœÂ² : TopologicalSpace T\ninstâœÂ¹ : AddAction Î“ T\ninstâœ : Finite Î“\nâŠ¢ ProperlyDiscontinuousVAdd Î“ T","decl":"/-- A finite group action is always properly discontinuous. -/\n@[to_additive \"A finite group action is always properly discontinuous.\"]\ninstance (priority := 100) Finite.to_properlyDiscontinuousSMul [Finite Î“] :\n    ProperlyDiscontinuousSMul Î“ T where finite_disjoint_inter_image _ _ := Set.toFinite _\n\n"}
{"name":"Finite.to_properlyDiscontinuousSMul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î“ : Type u_4\ninstâœÂ³ : Group Î“\nT : Type u_5\ninstâœÂ² : TopologicalSpace T\ninstâœÂ¹ : MulAction Î“ T\ninstâœ : Finite Î“\nâŠ¢ ProperlyDiscontinuousSMul Î“ T","decl":"/-- A finite group action is always properly discontinuous. -/\n@[to_additive \"A finite group action is always properly discontinuous.\"]\ninstance (priority := 100) Finite.to_properlyDiscontinuousSMul [Finite Î“] :\n    ProperlyDiscontinuousSMul Î“ T where finite_disjoint_inter_image _ _ := Set.toFinite _\n\n"}
{"name":"isOpenMap_quotient_mk'_mul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î“ : Type u_4\ninstâœÂ³ : Group Î“\nT : Type u_5\ninstâœÂ² : TopologicalSpace T\ninstâœÂ¹ : MulAction Î“ T\ninstâœ : ContinuousConstSMul Î“ T\nâŠ¢ IsOpenMap Quotient.mk'","decl":"/-- The quotient map by a group action is open, i.e. the quotient by a group action is an open\n  quotient. -/\n@[to_additive \"The quotient map by a group action is open, i.e. the quotient by a group\naction is an open quotient. \"]\ntheorem isOpenMap_quotient_mk'_mul [ContinuousConstSMul Î“ T] :\n    letI := MulAction.orbitRel Î“ T\n    IsOpenMap (Quotient.mk' : T â†’ Quotient (MulAction.orbitRel Î“ T)) := fun U hU => by\n  rw [isOpen_coinduced, MulAction.quotient_preimage_image_eq_union_mul U]\n  exact isOpen_iUnion fun Î³ => isOpenMap_smul Î³ U hU\n\n"}
{"name":"isOpenMap_quotient_mk'_add","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î“ : Type u_4\ninstâœÂ³ : AddGroup Î“\nT : Type u_5\ninstâœÂ² : TopologicalSpace T\ninstâœÂ¹ : AddAction Î“ T\ninstâœ : ContinuousConstVAdd Î“ T\nâŠ¢ IsOpenMap Quotient.mk'","decl":"/-- The quotient map by a group action is open, i.e. the quotient by a group action is an open\n  quotient. -/\n@[to_additive \"The quotient map by a group action is open, i.e. the quotient by a group\naction is an open quotient. \"]\ntheorem isOpenMap_quotient_mk'_mul [ContinuousConstSMul Î“ T] :\n    letI := MulAction.orbitRel Î“ T\n    IsOpenMap (Quotient.mk' : T â†’ Quotient (MulAction.orbitRel Î“ T)) := fun U hU => by\n  rw [isOpen_coinduced, MulAction.quotient_preimage_image_eq_union_mul U]\n  exact isOpen_iUnion fun Î³ => isOpenMap_smul Î³ U hU\n\n"}
{"name":"AddAction.isOpenQuotientMap_quotientMk","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î“ : Type u_4\ninstâœÂ³ : AddGroup Î“\nT : Type u_5\ninstâœÂ² : TopologicalSpace T\ninstâœÂ¹ : AddAction Î“ T\ninstâœ : ContinuousConstVAdd Î“ T\nâŠ¢ IsOpenQuotientMap (Quotient.mk (AddAction.orbitRel Î“ T))","decl":"@[to_additive]\ntheorem MulAction.isOpenQuotientMap_quotientMk [ContinuousConstSMul Î“ T] :\n    IsOpenQuotientMap (Quotient.mk (MulAction.orbitRel Î“ T)) :=\n  âŸ¨Quot.mk_surjective, continuous_quot_mk, isOpenMap_quotient_mk'_mulâŸ©\n\n"}
{"name":"MulAction.isOpenQuotientMap_quotientMk","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î“ : Type u_4\ninstâœÂ³ : Group Î“\nT : Type u_5\ninstâœÂ² : TopologicalSpace T\ninstâœÂ¹ : MulAction Î“ T\ninstâœ : ContinuousConstSMul Î“ T\nâŠ¢ IsOpenQuotientMap (Quotient.mk (MulAction.orbitRel Î“ T))","decl":"@[to_additive]\ntheorem MulAction.isOpenQuotientMap_quotientMk [ContinuousConstSMul Î“ T] :\n    IsOpenQuotientMap (Quotient.mk (MulAction.orbitRel Î“ T)) :=\n  âŸ¨Quot.mk_surjective, continuous_quot_mk, isOpenMap_quotient_mk'_mulâŸ©\n\n"}
{"name":"t2Space_of_properlyDiscontinuousSMul_of_t2Space","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î“ : Type u_4\ninstâœâ¶ : Group Î“\nT : Type u_5\ninstâœâµ : TopologicalSpace T\ninstâœâ´ : MulAction Î“ T\ninstâœÂ³ : T2Space T\ninstâœÂ² : LocallyCompactSpace T\ninstâœÂ¹ : ContinuousConstSMul Î“ T\ninstâœ : ProperlyDiscontinuousSMul Î“ T\nâŠ¢ T2Space (Quotient (MulAction.orbitRel Î“ T))","decl":"/-- The quotient by a discontinuous group action of a locally compact t2 space is t2. -/\n@[to_additive \"The quotient by a discontinuous group action of a locally compact t2\nspace is t2.\"]\ninstance (priority := 100) t2Space_of_properlyDiscontinuousSMul_of_t2Space [T2Space T]\n    [LocallyCompactSpace T] [ContinuousConstSMul Î“ T] [ProperlyDiscontinuousSMul Î“ T] :\n    T2Space (Quotient (MulAction.orbitRel Î“ T)) := by\n  letI := MulAction.orbitRel Î“ T\n  set Q := Quotient (MulAction.orbitRel Î“ T)\n  rw [t2Space_iff_nhds]\n  let f : T â†’ Q := Quotient.mk'\n  have f_op : IsOpenMap f := isOpenMap_quotient_mk'_mul\n  rintro âŸ¨xâ‚€âŸ© âŸ¨yâ‚€âŸ© (hxy : f xâ‚€ â‰  f yâ‚€)\n  show âˆƒ U âˆˆ ğ“ (f xâ‚€), âˆƒ V âˆˆ ğ“ (f yâ‚€), _\n  have hÎ³xâ‚€yâ‚€ : âˆ€ Î³ : Î“, Î³ â€¢ xâ‚€ â‰  yâ‚€ := not_exists.mp (mt Quotient.sound hxy.symm :)\n  obtain âŸ¨Kâ‚€, hKâ‚€, Kâ‚€_inâŸ© := exists_compact_mem_nhds xâ‚€\n  obtain âŸ¨Lâ‚€, hLâ‚€, Lâ‚€_inâŸ© := exists_compact_mem_nhds yâ‚€\n  let bad_Î“_set := { Î³ : Î“ | (Î³ â€¢ Â·) '' Kâ‚€ âˆ© Lâ‚€ â‰  âˆ… }\n  have bad_Î“_finite : bad_Î“_set.Finite := finite_disjoint_inter_image (Î“ := Î“) hKâ‚€ hLâ‚€\n  choose u v hu hv u_v_disjoint using fun Î³ => t2_separation_nhds (hÎ³xâ‚€yâ‚€ Î³)\n  let Uâ‚€â‚€ := â‹‚ Î³ âˆˆ bad_Î“_set, (Î³ â€¢ Â·) â»Â¹' u Î³\n  let Uâ‚€ := Uâ‚€â‚€ âˆ© Kâ‚€\n  let Vâ‚€â‚€ := â‹‚ Î³ âˆˆ bad_Î“_set, v Î³\n  let Vâ‚€ := Vâ‚€â‚€ âˆ© Lâ‚€\n  have U_nhds : f '' Uâ‚€ âˆˆ ğ“ (f xâ‚€) := by\n    refine f_op.image_mem_nhds (inter_mem ((biInter_mem bad_Î“_finite).mpr fun Î³ _ => ?_) Kâ‚€_in)\n    exact (continuous_const_smul _).continuousAt (hu Î³)\n  have V_nhds : f '' Vâ‚€ âˆˆ ğ“ (f yâ‚€) :=\n    f_op.image_mem_nhds (inter_mem ((biInter_mem bad_Î“_finite).mpr fun Î³ _ => hv Î³) Lâ‚€_in)\n  refine âŸ¨f '' Uâ‚€, U_nhds, f '' Vâ‚€, V_nhds, MulAction.disjoint_image_image_iff.2 ?_âŸ©\n  rintro x âŸ¨x_in_Uâ‚€â‚€, x_in_Kâ‚€âŸ© Î³\n  by_cases H : Î³ âˆˆ bad_Î“_set\n  Â· exact fun h => (u_v_disjoint Î³).le_bot âŸ¨mem_iInterâ‚‚.mp x_in_Uâ‚€â‚€ Î³ H, mem_iInterâ‚‚.mp h.1 Î³ HâŸ©\n  Â· rintro âŸ¨-, h'âŸ©\n    simp only [bad_Î“_set, image_smul, Classical.not_not, mem_setOf_eq, Ne] at H\n    exact eq_empty_iff_forall_not_mem.mp H (Î³ â€¢ x) âŸ¨mem_image_of_mem _ x_in_Kâ‚€, h'âŸ©\n\n"}
{"name":"t2Space_of_properlyDiscontinuousVAdd_of_t2Space","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î“ : Type u_4\ninstâœâ¶ : AddGroup Î“\nT : Type u_5\ninstâœâµ : TopologicalSpace T\ninstâœâ´ : AddAction Î“ T\ninstâœÂ³ : T2Space T\ninstâœÂ² : LocallyCompactSpace T\ninstâœÂ¹ : ContinuousConstVAdd Î“ T\ninstâœ : ProperlyDiscontinuousVAdd Î“ T\nâŠ¢ T2Space (Quotient (AddAction.orbitRel Î“ T))","decl":"/-- The quotient by a discontinuous group action of a locally compact t2 space is t2. -/\n@[to_additive \"The quotient by a discontinuous group action of a locally compact t2\nspace is t2.\"]\ninstance (priority := 100) t2Space_of_properlyDiscontinuousSMul_of_t2Space [T2Space T]\n    [LocallyCompactSpace T] [ContinuousConstSMul Î“ T] [ProperlyDiscontinuousSMul Î“ T] :\n    T2Space (Quotient (MulAction.orbitRel Î“ T)) := by\n  letI := MulAction.orbitRel Î“ T\n  set Q := Quotient (MulAction.orbitRel Î“ T)\n  rw [t2Space_iff_nhds]\n  let f : T â†’ Q := Quotient.mk'\n  have f_op : IsOpenMap f := isOpenMap_quotient_mk'_mul\n  rintro âŸ¨xâ‚€âŸ© âŸ¨yâ‚€âŸ© (hxy : f xâ‚€ â‰  f yâ‚€)\n  show âˆƒ U âˆˆ ğ“ (f xâ‚€), âˆƒ V âˆˆ ğ“ (f yâ‚€), _\n  have hÎ³xâ‚€yâ‚€ : âˆ€ Î³ : Î“, Î³ â€¢ xâ‚€ â‰  yâ‚€ := not_exists.mp (mt Quotient.sound hxy.symm :)\n  obtain âŸ¨Kâ‚€, hKâ‚€, Kâ‚€_inâŸ© := exists_compact_mem_nhds xâ‚€\n  obtain âŸ¨Lâ‚€, hLâ‚€, Lâ‚€_inâŸ© := exists_compact_mem_nhds yâ‚€\n  let bad_Î“_set := { Î³ : Î“ | (Î³ â€¢ Â·) '' Kâ‚€ âˆ© Lâ‚€ â‰  âˆ… }\n  have bad_Î“_finite : bad_Î“_set.Finite := finite_disjoint_inter_image (Î“ := Î“) hKâ‚€ hLâ‚€\n  choose u v hu hv u_v_disjoint using fun Î³ => t2_separation_nhds (hÎ³xâ‚€yâ‚€ Î³)\n  let Uâ‚€â‚€ := â‹‚ Î³ âˆˆ bad_Î“_set, (Î³ â€¢ Â·) â»Â¹' u Î³\n  let Uâ‚€ := Uâ‚€â‚€ âˆ© Kâ‚€\n  let Vâ‚€â‚€ := â‹‚ Î³ âˆˆ bad_Î“_set, v Î³\n  let Vâ‚€ := Vâ‚€â‚€ âˆ© Lâ‚€\n  have U_nhds : f '' Uâ‚€ âˆˆ ğ“ (f xâ‚€) := by\n    refine f_op.image_mem_nhds (inter_mem ((biInter_mem bad_Î“_finite).mpr fun Î³ _ => ?_) Kâ‚€_in)\n    exact (continuous_const_smul _).continuousAt (hu Î³)\n  have V_nhds : f '' Vâ‚€ âˆˆ ğ“ (f yâ‚€) :=\n    f_op.image_mem_nhds (inter_mem ((biInter_mem bad_Î“_finite).mpr fun Î³ _ => hv Î³) Lâ‚€_in)\n  refine âŸ¨f '' Uâ‚€, U_nhds, f '' Vâ‚€, V_nhds, MulAction.disjoint_image_image_iff.2 ?_âŸ©\n  rintro x âŸ¨x_in_Uâ‚€â‚€, x_in_Kâ‚€âŸ© Î³\n  by_cases H : Î³ âˆˆ bad_Î“_set\n  Â· exact fun h => (u_v_disjoint Î³).le_bot âŸ¨mem_iInterâ‚‚.mp x_in_Uâ‚€â‚€ Î³ H, mem_iInterâ‚‚.mp h.1 Î³ HâŸ©\n  Â· rintro âŸ¨-, h'âŸ©\n    simp only [bad_Î“_set, image_smul, Classical.not_not, mem_setOf_eq, Ne] at H\n    exact eq_empty_iff_forall_not_mem.mp H (Î³ â€¢ x) âŸ¨mem_image_of_mem _ x_in_Kâ‚€, h'âŸ©\n\n"}
{"name":"ContinuousConstSMul.secondCountableTopology","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î“ : Type u_4\ninstâœâ´ : Group Î“\nT : Type u_5\ninstâœÂ³ : TopologicalSpace T\ninstâœÂ² : MulAction Î“ T\ninstâœÂ¹ : SecondCountableTopology T\ninstâœ : ContinuousConstSMul Î“ T\nâŠ¢ SecondCountableTopology (Quotient (MulAction.orbitRel Î“ T))","decl":"/-- The quotient of a second countable space by a group action is second countable. -/\n@[to_additive \"The quotient of a second countable space by an additive group action is second\ncountable.\"]\ntheorem ContinuousConstSMul.secondCountableTopology [SecondCountableTopology T]\n    [ContinuousConstSMul Î“ T] : SecondCountableTopology (Quotient (MulAction.orbitRel Î“ T)) :=\n  TopologicalSpace.Quotient.secondCountableTopology isOpenMap_quotient_mk'_mul\n\n"}
{"name":"ContinuousConstVAdd.secondCountableTopology","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î“ : Type u_4\ninstâœâ´ : AddGroup Î“\nT : Type u_5\ninstâœÂ³ : TopologicalSpace T\ninstâœÂ² : AddAction Î“ T\ninstâœÂ¹ : SecondCountableTopology T\ninstâœ : ContinuousConstVAdd Î“ T\nâŠ¢ SecondCountableTopology (Quotient (AddAction.orbitRel Î“ T))","decl":"/-- The quotient of a second countable space by a group action is second countable. -/\n@[to_additive \"The quotient of a second countable space by an additive group action is second\ncountable.\"]\ntheorem ContinuousConstSMul.secondCountableTopology [SecondCountableTopology T]\n    [ContinuousConstSMul Î“ T] : SecondCountableTopology (Quotient (MulAction.orbitRel Î“ T)) :=\n  TopologicalSpace.Quotient.secondCountableTopology isOpenMap_quotient_mk'_mul\n\n"}
{"name":"smul_mem_nhds_smul_iffâ‚€","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nGâ‚€ : Type u_6\ninstâœÂ³ : GroupWithZero Gâ‚€\ninstâœÂ² : MulAction Gâ‚€ Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : ContinuousConstSMul Gâ‚€ Î±\nc : Gâ‚€\ns : Set Î±\nx : Î±\nhc : Ne c 0\nâŠ¢ Iff (Membership.mem (nhds (HSMul.hSMul c x)) (HSMul.hSMul c s)) (Membership.mem (nhds x) s)","decl":"/-- Scalar multiplication by a nonzero scalar preserves neighborhoods. -/\ntheorem smul_mem_nhds_smul_iffâ‚€ {c : Gâ‚€} {s : Set Î±} {x : Î±} (hc : c â‰  0) :\n    c â€¢ s âˆˆ ğ“ (c â€¢ x : Î±) â†” s âˆˆ ğ“ x :=\n  smul_mem_nhds_smul_iff (Units.mk0 c hc)\n\n"}
{"name":"set_smul_mem_nhds_smul_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nGâ‚€ : Type u_6\ninstâœÂ³ : GroupWithZero Gâ‚€\ninstâœÂ² : MulAction Gâ‚€ Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : ContinuousConstSMul Gâ‚€ Î±\nc : Gâ‚€\ns : Set Î±\nx : Î±\nhc : Ne c 0\nâŠ¢ Iff (Membership.mem (nhds (HSMul.hSMul c x)) (HSMul.hSMul c s)) (Membership.mem (nhds x) s)","decl":"@[deprecated (since := \"2024-08-06\")]\nalias set_smul_mem_nhds_smul_iff := smul_mem_nhds_smul_iffâ‚€\n\n"}
{"name":"smul_mem_nhds_smulâ‚€","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nGâ‚€ : Type u_6\ninstâœÂ³ : GroupWithZero Gâ‚€\ninstâœÂ² : MulAction Gâ‚€ Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : ContinuousConstSMul Gâ‚€ Î±\nc : Gâ‚€\ns : Set Î±\nx : Î±\nhc : Ne c 0\naâœ : Membership.mem (nhds x) s\nâŠ¢ Membership.mem (nhds (HSMul.hSMul c x)) (HSMul.hSMul c s)","decl":"alias âŸ¨_, smul_mem_nhds_smulâ‚€âŸ© := smul_mem_nhds_smul_iffâ‚€\n\n"}
{"name":"set_smul_mem_nhds_smul","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nGâ‚€ : Type u_6\ninstâœÂ³ : GroupWithZero Gâ‚€\ninstâœÂ² : MulAction Gâ‚€ Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : ContinuousConstSMul Gâ‚€ Î±\nc : Gâ‚€\ns : Set Î±\nx : Î±\nhs : Membership.mem (nhds x) s\nhc : Ne c 0\nâŠ¢ Membership.mem (nhds (HSMul.hSMul c x)) (HSMul.hSMul c s)","decl":"@[deprecated smul_mem_nhds_smulâ‚€ (since := \"2024-08-06\")]\ntheorem set_smul_mem_nhds_smul {c : Gâ‚€} {s : Set Î±} {x : Î±} (hs : s âˆˆ ğ“ x) (hc : c â‰  0) :\n    c â€¢ s âˆˆ ğ“ (c â€¢ x : Î±) :=\n  smul_mem_nhds_smulâ‚€ hc hs\n\n"}
{"name":"set_smul_mem_nhds_zero_iff","module":"Mathlib.Topology.Algebra.ConstMulAction","initialProofState":"Î± : Type u_2\nGâ‚€ : Type u_6\ninstâœâ´ : GroupWithZero Gâ‚€\ninstâœÂ³ : AddMonoid Î±\ninstâœÂ² : DistribMulAction Gâ‚€ Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : ContinuousConstSMul Gâ‚€ Î±\ns : Set Î±\nc : Gâ‚€\nhc : Ne c 0\nâŠ¢ Iff (Membership.mem (nhds 0) (HSMul.hSMul c s)) (Membership.mem (nhds 0) s)","decl":"theorem set_smul_mem_nhds_zero_iff {s : Set Î±} {c : Gâ‚€} (hc : c â‰  0) :\n    c â€¢ s âˆˆ ğ“ (0 : Î±) â†” s âˆˆ ğ“ (0 : Î±) := by\n  refine Iff.trans ?_ (smul_mem_nhds_smul_iffâ‚€ hc)\n  rw [smul_zero]\n\n"}
