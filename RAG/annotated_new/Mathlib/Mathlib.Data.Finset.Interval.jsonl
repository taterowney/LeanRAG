{"name":"Finset.Icc_eq_filter_powerset","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (Finset.Icc s t) (Finset.filter (fun x => HasSubset.Subset s x) t.powerset)","decl":"theorem Icc_eq_filter_powerset : Icc s t = t.powerset.filter (s ⊆ ·) :=\n  rfl\n\n"}
{"name":"Finset.Ico_eq_filter_ssubsets","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (Finset.Ico s t) (Finset.filter (fun x => HasSubset.Subset s x) t.ssubsets)","decl":"theorem Ico_eq_filter_ssubsets : Ico s t = t.ssubsets.filter (s ⊆ ·) :=\n  rfl\n\n"}
{"name":"Finset.Ioc_eq_filter_powerset","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (Finset.Ioc s t) (Finset.filter (fun x => HasSSubset.SSubset s x) t.powerset)","decl":"theorem Ioc_eq_filter_powerset : Ioc s t = t.powerset.filter (s ⊂ ·) :=\n  rfl\n\n"}
{"name":"Finset.Ioo_eq_filter_ssubsets","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (Finset.Ioo s t) (Finset.filter (fun x => HasSSubset.SSubset s x) t.ssubsets)","decl":"theorem Ioo_eq_filter_ssubsets : Ioo s t = t.ssubsets.filter (s ⊂ ·) :=\n  rfl\n\n"}
{"name":"Finset.Iic_eq_powerset","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Finset.Iic s) s.powerset","decl":"theorem Iic_eq_powerset : Iic s = s.powerset :=\n  filter_true_of_mem fun t _ => empty_subset t\n\n"}
{"name":"Finset.Iio_eq_ssubsets","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Finset.Iio s) s.ssubsets","decl":"theorem Iio_eq_ssubsets : Iio s = s.ssubsets :=\n  filter_true_of_mem fun t _ => empty_subset t\n\n"}
{"name":"Finset.Icc_eq_image_powerset","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nh : HasSubset.Subset s t\n⊢ Eq (Finset.Icc s t) (Finset.image (fun x => Union.union s x) (SDiff.sdiff t s).powerset)","decl":"theorem Icc_eq_image_powerset (h : s ⊆ t) : Icc s t = (t \\ s).powerset.image (s ∪ ·) := by\n  ext u\n  simp_rw [mem_Icc, mem_image, mem_powerset]\n  constructor\n  · rintro ⟨hs, ht⟩\n    exact ⟨u \\ s, sdiff_le_sdiff_right ht, sup_sdiff_cancel_right hs⟩\n  · rintro ⟨v, hv, rfl⟩\n    exact ⟨le_sup_left, union_subset h <| hv.trans sdiff_subset⟩\n\n"}
{"name":"Finset.Ico_eq_image_ssubsets","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nh : HasSubset.Subset s t\n⊢ Eq (Finset.Ico s t) (Finset.image (fun x => Union.union s x) (SDiff.sdiff t s).ssubsets)","decl":"theorem Ico_eq_image_ssubsets (h : s ⊆ t) : Ico s t = (t \\ s).ssubsets.image (s ∪ ·) := by\n  ext u\n  simp_rw [mem_Ico, mem_image, mem_ssubsets]\n  constructor\n  · rintro ⟨hs, ht⟩\n    exact ⟨u \\ s, sdiff_lt_sdiff_right ht hs, sup_sdiff_cancel_right hs⟩\n  · rintro ⟨v, hv, rfl⟩\n    exact ⟨le_sup_left, sup_lt_of_lt_sdiff_left hv h⟩\n\n"}
{"name":"Finset.card_Icc_finset","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nh : HasSubset.Subset s t\n⊢ Eq (Finset.Icc s t).card (HPow.hPow 2 (HSub.hSub t.card s.card))","decl":"/-- Cardinality of a non-empty `Icc` of finsets. -/\ntheorem card_Icc_finset (h : s ⊆ t) : (Icc s t).card = 2 ^ (t.card - s.card) := by\n  rw [← card_sdiff h, ← card_powerset, Icc_eq_image_powerset h, Finset.card_image_iff]\n  rintro u hu v hv (huv : s ⊔ u = s ⊔ v)\n  rw [mem_coe, mem_powerset] at hu hv\n  rw [← (disjoint_sdiff.mono_right hu : Disjoint s u).sup_sdiff_cancel_left, ←\n    (disjoint_sdiff.mono_right hv : Disjoint s v).sup_sdiff_cancel_left, huv]\n\n"}
{"name":"Finset.card_Ico_finset","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nh : HasSubset.Subset s t\n⊢ Eq (Finset.Ico s t).card (HSub.hSub (HPow.hPow 2 (HSub.hSub t.card s.card)) 1)","decl":"/-- Cardinality of an `Ico` of finsets. -/\ntheorem card_Ico_finset (h : s ⊆ t) : (Ico s t).card = 2 ^ (t.card - s.card) - 1 := by\n  rw [card_Ico_eq_card_Icc_sub_one, card_Icc_finset h]\n\n"}
{"name":"Finset.card_Ioc_finset","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nh : HasSubset.Subset s t\n⊢ Eq (Finset.Ioc s t).card (HSub.hSub (HPow.hPow 2 (HSub.hSub t.card s.card)) 1)","decl":"/-- Cardinality of an `Ioc` of finsets. -/\ntheorem card_Ioc_finset (h : s ⊆ t) : (Ioc s t).card = 2 ^ (t.card - s.card) - 1 := by\n  rw [card_Ioc_eq_card_Icc_sub_one, card_Icc_finset h]\n\n"}
{"name":"Finset.card_Ioo_finset","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nh : HasSubset.Subset s t\n⊢ Eq (Finset.Ioo s t).card (HSub.hSub (HPow.hPow 2 (HSub.hSub t.card s.card)) 2)","decl":"/-- Cardinality of an `Ioo` of finsets. -/\ntheorem card_Ioo_finset (h : s ⊆ t) : (Ioo s t).card = 2 ^ (t.card - s.card) - 2 := by\n  rw [card_Ioo_eq_card_Icc_sub_two, card_Icc_finset h]\n\n"}
{"name":"Finset.card_Iic_finset","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Finset.Iic s).card (HPow.hPow 2 s.card)","decl":"/-- Cardinality of an `Iic` of finsets. -/\ntheorem card_Iic_finset : (Iic s).card = 2 ^ s.card := by rw [Iic_eq_powerset, card_powerset]\n\n"}
{"name":"Finset.card_Iio_finset","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Finset.Iio s).card (HSub.hSub (HPow.hPow 2 s.card) 1)","decl":"/-- Cardinality of an `Iio` of finsets. -/\ntheorem card_Iio_finset : (Iio s).card = 2 ^ s.card - 1 := by\n  rw [Iio_eq_ssubsets, ssubsets, card_erase_of_mem (mem_powerset_self _), card_powerset]\n\n"}
{"name":"Finset.monotone_iff_forall_le_cons","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nf : Finset α → β\n⊢ Iff (Monotone f) (∀ (s : Finset α) ⦃a : α⦄ (ha : Not (Membership.mem s a)), LE.le (f s) (f (Finset.cons a s ha)))","decl":"/-- A function `f` from `Finset α` is monotone if and only if `f s ≤ f (cons a s ha)` for all `s`\nand `a ∉ s`. -/\nlemma monotone_iff_forall_le_cons : Monotone f ↔ ∀ s, ∀ ⦃a⦄ (ha), f s ≤ f (cons a s ha) := by\n  classical simp [monotone_iff_forall_covBy, covBy_iff_exists_cons]\n\n"}
{"name":"Finset.antitone_iff_forall_cons_le","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nf : Finset α → β\n⊢ Iff (Antitone f) (∀ (s : Finset α) ⦃a : α⦄ (ha : Not (Membership.mem s a)), LE.le (f (Finset.cons a s ha)) (f s))","decl":"/-- A function `f` from `Finset α` is antitone if and only if `f (cons a s ha) ≤ f s` for all\n`s` and `a ∉ s`. -/\nlemma antitone_iff_forall_cons_le : Antitone f ↔ ∀ s ⦃a⦄ ha, f (cons a s ha) ≤ f s :=\n  monotone_iff_forall_le_cons (β := βᵒᵈ)\n\n"}
{"name":"Finset.strictMono_iff_forall_lt_cons","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nf : Finset α → β\n⊢ Iff (StrictMono f) (∀ (s : Finset α) ⦃a : α⦄ (ha : Not (Membership.mem s a)), LT.lt (f s) (f (Finset.cons a s ha)))","decl":"/-- A function `f` from `Finset α` is strictly monotone if and only if `f s < f (cons a s ha)` for\nall `s` and `a ∉ s`. -/\nlemma strictMono_iff_forall_lt_cons : StrictMono f ↔ ∀ s ⦃a⦄ ha, f s < f (cons a s ha) := by\n  classical simp [strictMono_iff_forall_covBy, covBy_iff_exists_cons]\n\n"}
{"name":"Finset.strictAnti_iff_forall_cons_lt","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nf : Finset α → β\n⊢ Iff (StrictAnti f) (∀ (s : Finset α) ⦃a : α⦄ (ha : Not (Membership.mem s a)), LT.lt (f (Finset.cons a s ha)) (f s))","decl":"/-- A function `f` from `Finset α` is strictly antitone if and only if `f (cons a s ha) < f s` for\nall `s` and `a ∉ s`. -/\nlemma strictAnti_iff_forall_cons_lt : StrictAnti f ↔ ∀ s ⦃a⦄ ha, f (cons a s ha) < f s :=\n  strictMono_iff_forall_lt_cons (β := βᵒᵈ)\n\n"}
{"name":"Finset.monotone_iff_forall_le_insert","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder β\nf : Finset α → β\ninst✝ : DecidableEq α\n⊢ Iff (Monotone f) (∀ (s : Finset α) ⦃a : α⦄, Not (Membership.mem s a) → LE.le (f s) (f (Insert.insert a s)))","decl":"/-- A function `f` from `Finset α` is monotone if and only if `f s ≤ f (insert a s)` for all `s` and\n`a ∉ s`. -/\nlemma monotone_iff_forall_le_insert : Monotone f ↔ ∀ s ⦃a⦄, a ∉ s → f s ≤ f (insert a s) := by\n  simp [monotone_iff_forall_le_cons]\n\n"}
{"name":"Finset.antitone_iff_forall_insert_le","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder β\nf : Finset α → β\ninst✝ : DecidableEq α\n⊢ Iff (Antitone f) (∀ (s : Finset α) ⦃a : α⦄, Not (Membership.mem s a) → LE.le (f (Insert.insert a s)) (f s))","decl":"/-- A function `f` from `Finset α` is antitone if and only if `f (insert a s) ≤ f s` for all\n`s` and `a ∉ s`. -/\nlemma antitone_iff_forall_insert_le : Antitone f ↔ ∀ s ⦃a⦄, a ∉ s → f (insert a s) ≤ f s :=\n  monotone_iff_forall_le_insert (β := βᵒᵈ)\n\n"}
{"name":"Finset.strictMono_iff_forall_lt_insert","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder β\nf : Finset α → β\ninst✝ : DecidableEq α\n⊢ Iff (StrictMono f) (∀ (s : Finset α) ⦃a : α⦄, Not (Membership.mem s a) → LT.lt (f s) (f (Insert.insert a s)))","decl":"/-- A function `f` from `Finset α` is strictly monotone if and only if `f s < f (insert a s)` for\nall `s` and `a ∉ s`. -/\nlemma strictMono_iff_forall_lt_insert : StrictMono f ↔ ∀ s ⦃a⦄, a ∉ s → f s < f (insert a s) := by\n  simp [strictMono_iff_forall_lt_cons]\n\n"}
{"name":"Finset.strictAnti_iff_forall_lt_insert","module":"Mathlib.Data.Finset.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder β\nf : Finset α → β\ninst✝ : DecidableEq α\n⊢ Iff (StrictAnti f) (∀ (s : Finset α) ⦃a : α⦄, Not (Membership.mem s a) → LT.lt (f (Insert.insert a s)) (f s))","decl":"/-- A function `f` from `Finset α` is strictly antitone if and only if `f (insert a s) < f s` for\nall `s` and `a ∉ s`. -/\nlemma strictAnti_iff_forall_lt_insert : StrictAnti f ↔ ∀ s ⦃a⦄, a ∉ s → f (insert a s) < f s :=\n  strictMono_iff_forall_lt_insert (β := βᵒᵈ)\n\n"}
