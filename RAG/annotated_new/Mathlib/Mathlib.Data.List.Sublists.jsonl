{"name":"List.sublists'_nil","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\n⊢ Eq List.nil.sublists' (List.cons List.nil List.nil)","decl":"@[simp]\ntheorem sublists'_nil : sublists' (@nil α) = [[]] :=\n  rfl\n\n"}
{"name":"List.sublists'_singleton","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\na : α\n⊢ Eq (List.cons a List.nil).sublists' (List.cons List.nil (List.cons (List.cons a List.nil) List.nil))","decl":"@[simp]\ntheorem sublists'_singleton (a : α) : sublists' [a] = [[], [a]] :=\n  rfl\n\n-- Porting note: Not the same as `sublists'_aux` from Lean3\n"}
{"name":"List.sublists'Aux_eq_array_foldl","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\na : α\nr₁ r₂ : List (List α)\n⊢ Eq (List.sublists'Aux a r₁ r₂) (Array.foldl (fun r l => r.push (List.cons a l)) r₂.toArray r₁.toArray).toList","decl":"theorem sublists'Aux_eq_array_foldl (a : α) : ∀ (r₁ r₂ : List (List α)),\n    sublists'Aux a r₁ r₂ = ((r₁.toArray).foldl (init := r₂.toArray)\n      (fun r l => r.push (a :: l))).toList := by\n  intro r₁ r₂\n  rw [sublists'Aux, Array.foldl_toList]\n  have := List.foldl_hom Array.toList (fun r l => r.push (a :: l))\n    (fun r l => r ++ [a :: l]) r₁ r₂.toArray (by simp)\n  simpa using this\n\n"}
{"name":"List.sublists'_eq_sublists'Aux","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl : List α\n⊢ Eq l.sublists' (List.foldr (fun a r => List.sublists'Aux a r r) (List.cons List.nil List.nil) l)","decl":"theorem sublists'_eq_sublists'Aux (l : List α) :\n    sublists' l = l.foldr (fun a r => sublists'Aux a r r) [[]] := by\n  simp only [sublists', sublists'Aux_eq_array_foldl]\n  rw [← List.foldr_hom Array.toList]\n  · intros _ _; congr\n\n"}
{"name":"List.sublists'Aux_eq_map","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\na : α\nr₁ r₂ : List (List α)\n⊢ Eq (List.sublists'Aux a r₁ r₂) (HAppend.hAppend r₂ (List.map (List.cons a) r₁))","decl":"theorem sublists'Aux_eq_map (a : α) (r₁ : List (List α)) : ∀ (r₂ : List (List α)),\n    sublists'Aux a r₁ r₂ = r₂ ++ map (cons a) r₁ :=\n  List.reverseRecOn r₁ (fun _ => by simp [sublists'Aux]) fun r₁ l ih r₂ => by\n    rw [map_append, map_singleton, ← append_assoc, ← ih, sublists'Aux, foldl_append, foldl]\n    simp [sublists'Aux]\n\n-- Porting note: simp can prove `sublists'_singleton`\n"}
{"name":"List.sublists'_cons","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\na : α\nl : List α\n⊢ Eq (List.cons a l).sublists' (HAppend.hAppend l.sublists' (List.map (List.cons a) l.sublists'))","decl":"@[simp 900]\ntheorem sublists'_cons (a : α) (l : List α) :\n    sublists' (a :: l) = sublists' l ++ map (cons a) (sublists' l) := by\n  simp [sublists'_eq_sublists'Aux, foldr_cons, sublists'Aux_eq_map]\n\n"}
{"name":"List.mem_sublists'","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\ns t : List α\n⊢ Iff (Membership.mem t.sublists' s) (s.Sublist t)","decl":"@[simp]\ntheorem mem_sublists' {s t : List α} : s ∈ sublists' t ↔ s <+ t := by\n  induction' t with a t IH generalizing s\n  · simp only [sublists'_nil, mem_singleton]\n    exact ⟨fun h => by rw [h], eq_nil_of_sublist_nil⟩\n  simp only [sublists'_cons, mem_append, IH, mem_map]\n  constructor <;> intro h\n  · rcases h with (h | ⟨s, h, rfl⟩)\n    · exact sublist_cons_of_sublist _ h\n    · exact h.cons_cons _\n  · cases' h with _ _ _ h s _ _ h\n    · exact Or.inl h\n    · exact Or.inr ⟨s, h, rfl⟩\n\n"}
{"name":"List.length_sublists'","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl : List α\n⊢ Eq l.sublists'.length (HPow.hPow 2 l.length)","decl":"@[simp]\ntheorem length_sublists' : ∀ l : List α, length (sublists' l) = 2 ^ length l\n  | [] => rfl\n  | a :: l => by\n    simp_arith only [sublists'_cons, length_append, length_sublists' l,\n      length_map, length, Nat.pow_succ']\n\n"}
{"name":"List.sublists_nil","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\n⊢ Eq List.nil.sublists (List.cons List.nil List.nil)","decl":"@[simp]\ntheorem sublists_nil : sublists (@nil α) = [[]] :=\n  rfl\n\n"}
{"name":"List.sublists_singleton","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\na : α\n⊢ Eq (List.cons a List.nil).sublists (List.cons List.nil (List.cons (List.cons a List.nil) List.nil))","decl":"@[simp]\ntheorem sublists_singleton (a : α) : sublists [a] = [[], [a]] :=\n  rfl\n\n-- Porting note: Not the same as `sublists_aux` from Lean3\n"}
{"name":"List.sublistsAux_eq_array_foldl","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\n⊢ Eq List.sublistsAux fun a r => (Array.foldl (fun r l => (r.push l).push (List.cons a l)) List.nil.toArray r.toArray).toList","decl":"theorem sublistsAux_eq_array_foldl :\n    sublistsAux = fun (a : α) (r : List (List α)) =>\n      (r.toArray.foldl (init := #[])\n        fun r l => (r.push l).push (a :: l)).toList := by\n  funext a r\n  simp only [sublistsAux, Array.foldl_toList, Array.mkEmpty]\n  have := foldl_hom Array.toList (fun r l => (r.push l).push (a :: l))\n    (fun (r : List (List α)) l => r ++ [l, a :: l]) r #[]\n    (by simp)\n  simpa using this\n\n"}
{"name":"List.sublistsAux_eq_flatMap","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\n⊢ Eq List.sublistsAux fun a r => r.flatMap fun l => List.cons l (List.cons (List.cons a l) List.nil)","decl":"theorem sublistsAux_eq_flatMap :\n    sublistsAux = fun (a : α) (r : List (List α)) => r.flatMap fun l => [l, a :: l] :=\n  funext fun a => funext fun r =>\n  List.reverseRecOn r\n    (by simp [sublistsAux])\n    (fun r l ih => by\n      rw [flatMap_append, ← ih, flatMap_singleton, sublistsAux, foldl_append]\n      simp [sublistsAux])\n\n"}
{"name":"List.sublistsAux_eq_bind","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\n⊢ Eq List.sublistsAux fun a r => r.flatMap fun l => List.cons l (List.cons (List.cons a l) List.nil)","decl":"@[deprecated (since := \"2024-10-16\")] alias sublistsAux_eq_bind := sublistsAux_eq_flatMap\n\n"}
{"name":"List.sublists_eq_sublistsFast","module":"Mathlib.Data.List.Sublists","initialProofState":"⊢ Eq @List.sublists @List.sublistsFast","decl":"@[csimp] theorem sublists_eq_sublistsFast : @sublists = @sublistsFast := by\n  ext α l : 2\n  trans l.foldr sublistsAux [[]]\n  · rw [sublistsAux_eq_flatMap, sublists]\n  · simp only [sublistsFast, sublistsAux_eq_array_foldl, Array.foldr_toList]\n    rw [← foldr_hom Array.toList]\n    · intros _ _; congr\n\n"}
{"name":"List.sublists_append","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl₁ l₂ : List α\n⊢ Eq (HAppend.hAppend l₁ l₂).sublists (Bind.bind l₂.sublists fun x => List.map (fun x_1 => HAppend.hAppend x_1 x) l₁.sublists)","decl":"theorem sublists_append (l₁ l₂ : List α) :\n    sublists (l₁ ++ l₂) = (sublists l₂) >>= (fun x => (sublists l₁).map (· ++ x)) := by\n  simp only [sublists, foldr_append]\n  induction l₁ with\n  | nil => simp\n  | cons a l₁ ih =>\n    rw [foldr_cons, ih]\n    simp [List.flatMap, flatten_flatten, Function.comp_def]\n\n"}
{"name":"List.sublists_cons","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\na : α\nl : List α\n⊢ Eq (List.cons a l).sublists (Bind.bind l.sublists fun x => List.cons x (List.cons (List.cons a x) List.nil))","decl":"theorem sublists_cons (a : α) (l : List α) :\n    sublists (a :: l) = sublists l >>= (fun x => [x, a :: x]) :=\n  show sublists ([a] ++ l) = _ by\n  rw [sublists_append]\n  simp only [sublists_singleton, map_cons, bind_eq_flatMap, nil_append, cons_append, map_nil]\n\n"}
{"name":"List.sublists_concat","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl : List α\na : α\n⊢ Eq (HAppend.hAppend l (List.cons a List.nil)).sublists (HAppend.hAppend l.sublists (List.map (fun x => HAppend.hAppend x (List.cons a List.nil)) l.sublists))","decl":"@[simp]\ntheorem sublists_concat (l : List α) (a : α) :\n    sublists (l ++ [a]) = sublists l ++ map (fun x => x ++ [a]) (sublists l) := by\n  rw [sublists_append, sublists_singleton, bind_eq_flatMap, flatMap_cons, flatMap_cons, flatMap_nil,\n     map_id'' append_nil, append_nil]\n\n"}
{"name":"List.sublists_reverse","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl : List α\n⊢ Eq l.reverse.sublists (List.map List.reverse l.sublists')","decl":"theorem sublists_reverse (l : List α) : sublists (reverse l) = map reverse (sublists' l) := by\n  induction' l with hd tl ih <;> [rfl;\n    simp only [reverse_cons, sublists_append, sublists'_cons, map_append, ih, sublists_singleton,\n      map_eq_map, bind_eq_flatMap, map_map, flatMap_cons, append_nil, flatMap_nil,\n      Function.comp_def]]\n\n"}
{"name":"List.sublists_eq_sublists'","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl : List α\n⊢ Eq l.sublists (List.map List.reverse l.reverse.sublists')","decl":"theorem sublists_eq_sublists' (l : List α) : sublists l = map reverse (sublists' (reverse l)) := by\n  rw [← sublists_reverse, reverse_reverse]\n\n"}
{"name":"List.sublists'_reverse","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl : List α\n⊢ Eq l.reverse.sublists' (List.map List.reverse l.sublists)","decl":"theorem sublists'_reverse (l : List α) : sublists' (reverse l) = map reverse (sublists l) := by\n  simp only [sublists_eq_sublists', map_map, map_id'' reverse_reverse, Function.comp_def]\n\n"}
{"name":"List.sublists'_eq_sublists","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl : List α\n⊢ Eq l.sublists' (List.map List.reverse l.reverse.sublists)","decl":"theorem sublists'_eq_sublists (l : List α) : sublists' l = map reverse (sublists (reverse l)) := by\n  rw [← sublists'_reverse, reverse_reverse]\n\n"}
{"name":"List.mem_sublists","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\ns t : List α\n⊢ Iff (Membership.mem t.sublists s) (s.Sublist t)","decl":"@[simp]\ntheorem mem_sublists {s t : List α} : s ∈ sublists t ↔ s <+ t := by\n  rw [← reverse_sublist, ← mem_sublists', sublists'_reverse,\n    mem_map_of_injective reverse_injective]\n\n"}
{"name":"List.length_sublists","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl : List α\n⊢ Eq l.sublists.length (HPow.hPow 2 l.length)","decl":"@[simp]\ntheorem length_sublists (l : List α) : length (sublists l) = 2 ^ length l := by\n  simp only [sublists_eq_sublists', length_map, length_sublists', length_reverse]\n\n"}
{"name":"List.map_pure_sublist_sublists","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl : List α\n⊢ (List.map Pure.pure l).Sublist l.sublists","decl":"theorem map_pure_sublist_sublists (l : List α) : map pure l <+ sublists l := by\n  induction' l using reverseRecOn with l a ih <;> simp only [map, map_append, sublists_concat]\n  · simp only [sublists_nil, sublist_cons_self]\n  exact ((append_sublist_append_left _).2 <|\n              singleton_sublist.2 <| mem_map.2 ⟨[], mem_sublists.2 (nil_sublist _), by rfl⟩).trans\n          ((append_sublist_append_right _).2 ih)\n\n"}
{"name":"List.sublistsLenAux_append","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nn : Nat\nl : List α\nf : List α → β\ng : β → γ\nr : List β\ns : List γ\n⊢ Eq (List.sublistsLenAux n l (Function.comp g f) (HAppend.hAppend (List.map g r) s)) (HAppend.hAppend (List.map g (List.sublistsLenAux n l f r)) s)","decl":"theorem sublistsLenAux_append :\n    ∀ (n : ℕ) (l : List α) (f : List α → β) (g : β → γ) (r : List β) (s : List γ),\n      sublistsLenAux n l (g ∘ f) (r.map g ++ s) = (sublistsLenAux n l f r).map g ++ s\n  | 0, l, f, g, r, s => by unfold sublistsLenAux; simp\n  | _ + 1, [], _, _, _, _ => rfl\n  | n + 1, a :: l, f, g, r, s => by\n    unfold sublistsLenAux\n    simp only [show (g ∘ f) ∘ List.cons a = g ∘ f ∘ List.cons a by rfl, sublistsLenAux_append,\n      sublistsLenAux_append]\n\n"}
{"name":"List.sublistsLenAux_eq","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nβ : Type v\nl : List α\nn : Nat\nf : List α → β\nr : List β\n⊢ Eq (List.sublistsLenAux n l f r) (HAppend.hAppend (List.map f (List.sublistsLen n l)) r)","decl":"theorem sublistsLenAux_eq (l : List α) (n) (f : List α → β) (r) :\n    sublistsLenAux n l f r = (sublistsLen n l).map f ++ r := by\n  rw [sublistsLen, ← sublistsLenAux_append]; rfl\n\n"}
{"name":"List.sublistsLenAux_zero","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nβ : Type v\nl : List α\nf : List α → β\nr : List β\n⊢ Eq (List.sublistsLenAux 0 l f r) (List.cons (f List.nil) r)","decl":"theorem sublistsLenAux_zero (l : List α) (f : List α → β) (r) :\n    sublistsLenAux 0 l f r = f [] :: r := by cases l <;> rfl\n\n"}
{"name":"List.sublistsLen_zero","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl : List α\n⊢ Eq (List.sublistsLen 0 l) (List.cons List.nil List.nil)","decl":"@[simp]\ntheorem sublistsLen_zero (l : List α) : sublistsLen 0 l = [[]] :=\n  sublistsLenAux_zero _ _ _\n\n"}
{"name":"List.sublistsLen_succ_nil","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nn : Nat\n⊢ Eq (List.sublistsLen (HAdd.hAdd n 1) List.nil) List.nil","decl":"@[simp]\ntheorem sublistsLen_succ_nil (n) : sublistsLen (n + 1) (@nil α) = [] :=\n  rfl\n\n"}
{"name":"List.sublistsLen_succ_cons","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nn : Nat\na : α\nl : List α\n⊢ Eq (List.sublistsLen (HAdd.hAdd n 1) (List.cons a l)) (HAppend.hAppend (List.sublistsLen (HAdd.hAdd n 1) l) (List.map (List.cons a) (List.sublistsLen n l)))","decl":"@[simp]\ntheorem sublistsLen_succ_cons (n) (a : α) (l) :\n    sublistsLen (n + 1) (a :: l) = sublistsLen (n + 1) l ++ (sublistsLen n l).map (cons a) := by\n  rw [sublistsLen, sublistsLenAux, sublistsLenAux_eq, sublistsLenAux_eq, map_id,\n      append_nil]; rfl\n\n"}
{"name":"List.sublistsLen_one","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl : List α\n⊢ Eq (List.sublistsLen 1 l) (List.map (fun x => List.cons x List.nil) l.reverse)","decl":"theorem sublistsLen_one (l : List α) : sublistsLen 1 l = l.reverse.map ([·]) :=\n  l.rec (by rw [sublistsLen_succ_nil, reverse_nil, map_nil]) fun a s ih ↦ by\n    rw [sublistsLen_succ_cons, ih, reverse_cons, map_append, sublistsLen_zero]; rfl\n\n"}
{"name":"List.length_sublistsLen","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nn : Nat\nl : List α\n⊢ Eq (List.sublistsLen n l).length (l.length.choose n)","decl":"@[simp]\ntheorem length_sublistsLen :\n    ∀ (n) (l : List α), length (sublistsLen n l) = Nat.choose (length l) n\n  | 0, l => by simp\n  | _ + 1, [] => by simp\n  | n + 1, a :: l => by\n    rw [sublistsLen_succ_cons, length_append, length_sublistsLen (n+1) l,\n      length_map, length_sublistsLen n l, length_cons, Nat.choose_succ_succ, Nat.add_comm]\n\n"}
{"name":"List.sublistsLen_sublist_sublists'","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nn : Nat\nl : List α\n⊢ (List.sublistsLen n l).Sublist l.sublists'","decl":"theorem sublistsLen_sublist_sublists' :\n    ∀ (n) (l : List α), sublistsLen n l <+ sublists' l\n  | 0, l => by simp\n  | _ + 1, [] => nil_sublist _\n  | n + 1, a :: l => by\n    rw [sublistsLen_succ_cons, sublists'_cons]\n    exact (sublistsLen_sublist_sublists' _ _).append ((sublistsLen_sublist_sublists' _ _).map _)\n\n"}
{"name":"List.sublistsLen_sublist_of_sublist","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nn : Nat\nl₁ l₂ : List α\nh : l₁.Sublist l₂\n⊢ (List.sublistsLen n l₁).Sublist (List.sublistsLen n l₂)","decl":"theorem sublistsLen_sublist_of_sublist (n) {l₁ l₂ : List α} (h : l₁ <+ l₂) :\n    sublistsLen n l₁ <+ sublistsLen n l₂ := by\n  induction' n with n IHn generalizing l₁ l₂; · simp\n  induction' h with l₁ l₂ a _ IH l₁ l₂ a s IH; · rfl\n  · refine IH.trans ?_\n    rw [sublistsLen_succ_cons]\n    apply sublist_append_left\n  · simpa only [sublistsLen_succ_cons] using IH.append ((IHn s).map _)\n\n"}
{"name":"List.length_of_sublistsLen","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nn : Nat\nl l' : List α\na✝ : Membership.mem (List.sublistsLen n l) l'\n⊢ Eq l'.length n","decl":"theorem length_of_sublistsLen :\n    ∀ {n} {l l' : List α}, l' ∈ sublistsLen n l → length l' = n\n  | 0, l, l', h => by simp_all\n  | n + 1, a :: l, l', h => by\n    rw [sublistsLen_succ_cons, mem_append, mem_map] at h\n    rcases h with (h | ⟨l', h, rfl⟩)\n    · exact length_of_sublistsLen h\n    · exact congr_arg (· + 1) (length_of_sublistsLen h)\n\n"}
{"name":"List.mem_sublistsLen_self","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl l' : List α\nh : l'.Sublist l\n⊢ Membership.mem (List.sublistsLen l'.length l) l'","decl":"theorem mem_sublistsLen_self {l l' : List α} (h : l' <+ l) :\n    l' ∈ sublistsLen (length l') l := by\n  induction' h with l₁ l₂ a s IH l₁ l₂ a s IH\n  · simp\n  · cases' l₁ with b l₁\n    · simp\n    · rw [length, sublistsLen_succ_cons]\n      exact mem_append_left _ IH\n  · rw [length, sublistsLen_succ_cons]\n    exact mem_append_right _ (mem_map.2 ⟨_, IH, rfl⟩)\n\n"}
{"name":"List.mem_sublistsLen","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nn : Nat\nl l' : List α\n⊢ Iff (Membership.mem (List.sublistsLen n l) l') (And (l'.Sublist l) (Eq l'.length n))","decl":"@[simp]\ntheorem mem_sublistsLen {n} {l l' : List α} :\n    l' ∈ sublistsLen n l ↔ l' <+ l ∧ length l' = n :=\n  ⟨fun h =>\n    ⟨mem_sublists'.1 ((sublistsLen_sublist_sublists' _ _).subset h), length_of_sublistsLen h⟩,\n    fun ⟨h₁, h₂⟩ => h₂ ▸ mem_sublistsLen_self h₁⟩\n\n"}
{"name":"List.sublistsLen_of_length_lt","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nn : Nat\nl : List α\nh : LT.lt l.length n\n⊢ Eq (List.sublistsLen n l) List.nil","decl":"theorem sublistsLen_of_length_lt {n} {l : List α} (h : l.length < n) : sublistsLen n l = [] :=\n  eq_nil_iff_forall_not_mem.mpr fun _ =>\n    mem_sublistsLen.not.mpr fun ⟨hs, hl⟩ => (h.trans_eq hl.symm).not_le (Sublist.length_le hs)\n\n"}
{"name":"List.sublistsLen_length","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl : List α\n⊢ Eq (List.sublistsLen l.length l) (List.cons l List.nil)","decl":"@[simp]\ntheorem sublistsLen_length : ∀ l : List α, sublistsLen l.length l = [l]\n  | [] => rfl\n  | a :: l => by\n    simp only [length, sublistsLen_succ_cons, sublistsLen_length, map,\n      sublistsLen_of_length_lt (lt_succ_self _), nil_append]\n\n"}
{"name":"List.Pairwise.sublists'","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nR : α → α → Prop\nl : List α\na✝ : List.Pairwise R l\n⊢ List.Pairwise (List.Lex (Function.swap R)) l.sublists'","decl":"theorem Pairwise.sublists' {R} :\n    ∀ {l : List α}, Pairwise R l → Pairwise (Lex (swap R)) (sublists' l)\n  | _, Pairwise.nil => pairwise_singleton _ _\n  | _, @Pairwise.cons _ _ a l H₁ H₂ => by\n    simp only [sublists'_cons, pairwise_append, pairwise_map, mem_sublists', mem_map, exists_imp,\n      and_imp]\n    refine ⟨H₂.sublists', H₂.sublists'.imp fun l₁ => Lex.cons l₁, ?_⟩\n    rintro l₁ sl₁ x l₂ _ rfl\n    cases' l₁ with b l₁; · constructor\n    exact Lex.rel (H₁ _ <| sl₁.subset <| mem_cons_self _ _)\n\n"}
{"name":"List.pairwise_sublists","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nR : α → α → Prop\nl : List α\nH : List.Pairwise R l\n⊢ List.Pairwise (Function.onFun (List.Lex R) List.reverse) l.sublists","decl":"theorem pairwise_sublists {R} {l : List α} (H : Pairwise R l) :\n    Pairwise (Lex R on reverse) (sublists l) := by\n  have := (pairwise_reverse.2 H).sublists'\n  rwa [sublists'_reverse, pairwise_map] at this\n\n"}
{"name":"List.nodup_sublists","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl : List α\n⊢ Iff l.sublists.Nodup l.Nodup","decl":"@[simp]\ntheorem nodup_sublists {l : List α} : Nodup (sublists l) ↔ Nodup l :=\n  ⟨fun h => (h.sublist (map_pure_sublist_sublists _)).of_map _, fun h =>\n    (pairwise_sublists h).imp @fun l₁ l₂ h => by simpa using h.to_ne⟩\n\n"}
{"name":"List.nodup_sublists'","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl : List α\n⊢ Iff l.sublists'.Nodup l.Nodup","decl":"@[simp]\ntheorem nodup_sublists' {l : List α} : Nodup (sublists' l) ↔ Nodup l := by\n  rw [sublists'_eq_sublists, nodup_map_iff reverse_injective, nodup_sublists, nodup_reverse]\n\n"}
{"name":"List.Nodup.of_sublists","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl : List α\na✝ : l.sublists.Nodup\n⊢ l.Nodup","decl":"protected alias ⟨Nodup.of_sublists, Nodup.sublists⟩ := nodup_sublists\n\n"}
{"name":"List.Nodup.sublists","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl : List α\na✝ : l.Nodup\n⊢ l.sublists.Nodup","decl":"protected alias ⟨Nodup.of_sublists, Nodup.sublists⟩ := nodup_sublists\n\n"}
{"name":"List.Nodup.of_sublists'","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl : List α\na✝ : l.sublists'.Nodup\n⊢ l.Nodup","decl":"protected alias ⟨Nodup.of_sublists', _⟩ := nodup_sublists'\n\n"}
{"name":"List.nodup_sublistsLen","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nn : Nat\nl : List α\nh : l.Nodup\n⊢ (List.sublistsLen n l).Nodup","decl":"theorem nodup_sublistsLen (n : ℕ) {l : List α} (h : Nodup l) : (sublistsLen n l).Nodup := by\n  have : Pairwise (· ≠ ·) l.sublists' := Pairwise.imp\n    (fun h => Lex.to_ne (by convert h using 3; simp [swap, eq_comm])) h.sublists'\n  exact this.sublist (sublistsLen_sublist_sublists' _ _)\n\n"}
{"name":"List.sublists_map","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nl : List α\n⊢ Eq (List.map f l).sublists (List.map (List.map f) l.sublists)","decl":"theorem sublists_map (f : α → β) : ∀ (l : List α),\n    sublists (map f l) = map (map f) (sublists l)\n  | [] => by simp\n  | a::l => by\n    rw [map_cons, sublists_cons, bind_eq_flatMap, sublists_map f l, sublists_cons,\n      bind_eq_flatMap, map_eq_flatMap, map_eq_flatMap]\n    induction sublists l <;> simp [*]\n\n"}
{"name":"List.sublists'_map","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nl : List α\n⊢ Eq (List.map f l).sublists' (List.map (List.map f) l.sublists')","decl":"theorem sublists'_map (f : α → β) : ∀ (l : List α),\n    sublists' (map f l) = map (map f) (sublists' l)\n  | [] => by simp\n  | a::l => by simp [map_cons, sublists'_cons, sublists'_map f l, Function.comp]\n\n-- Porting note: moved because it is now used to prove `sublists_cons_perm_append`\n"}
{"name":"List.sublists_perm_sublists'","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl : List α\n⊢ l.sublists.Perm l.sublists'","decl":"theorem sublists_perm_sublists' (l : List α) : sublists l ~ sublists' l := by\n  rw [← finRange_map_get l, sublists_map, sublists'_map]\n  apply Perm.map\n  apply (perm_ext_iff_of_nodup _ _).mpr\n  · simp\n  · exact nodup_sublists.mpr (nodup_finRange _)\n  · exact (nodup_sublists'.mpr (nodup_finRange _))\n\n"}
{"name":"List.sublists_cons_perm_append","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\na : α\nl : List α\n⊢ (List.cons a l).sublists.Perm (HAppend.hAppend l.sublists (List.map (List.cons a) l.sublists))","decl":"theorem sublists_cons_perm_append (a : α) (l : List α) :\n    sublists (a :: l) ~ sublists l ++ map (cons a) (sublists l) :=\n  Perm.trans (sublists_perm_sublists' _) <| by\n  rw [sublists'_cons]\n  exact Perm.append (sublists_perm_sublists' _).symm (Perm.map _ (sublists_perm_sublists' _).symm)\n\n"}
{"name":"List.revzip_sublists","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl l₁ l₂ : List α\na✝ : Membership.mem l.sublists.revzip { fst := l₁, snd := l₂ }\n⊢ (HAppend.hAppend l₁ l₂).Perm l","decl":"theorem revzip_sublists (l : List α) : ∀ l₁ l₂, (l₁, l₂) ∈ revzip l.sublists → l₁ ++ l₂ ~ l := by\n  rw [revzip]\n  induction' l using List.reverseRecOn with l' a ih\n  · intro l₁ l₂ h\n    simp? at h says\n      simp only [sublists_nil, reverse_cons, reverse_nil, nil_append, zip_cons_cons, zip_nil_right,\n        mem_singleton, Prod.mk.injEq] at h\n    simp [h]\n  · intro l₁ l₂ h\n    rw [sublists_concat, reverse_append, zip_append (by simp), ← map_reverse, zip_map_right,\n      zip_map_left] at *\n    simp only [Prod.mk.inj_iff, mem_map, mem_append, Prod.map_apply, Prod.exists] at h\n    rcases h with (⟨l₁, l₂', h, rfl, rfl⟩ | ⟨l₁', l₂, h, rfl, rfl⟩)\n    · rw [← append_assoc]\n      exact (ih _ _ h).append_right _\n    · rw [append_assoc]\n      apply (perm_append_comm.append_left _).trans\n      rw [← append_assoc]\n      exact (ih _ _ h).append_right _\n\n"}
{"name":"List.revzip_sublists'","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl l₁ l₂ : List α\na✝ : Membership.mem l.sublists'.revzip { fst := l₁, snd := l₂ }\n⊢ (HAppend.hAppend l₁ l₂).Perm l","decl":"theorem revzip_sublists' (l : List α) : ∀ l₁ l₂, (l₁, l₂) ∈ revzip l.sublists' → l₁ ++ l₂ ~ l := by\n  rw [revzip]\n  induction' l with a l IH <;> intro l₁ l₂ h\n  · simp_all only [sublists'_nil, reverse_cons, reverse_nil, nil_append, zip_cons_cons,\n      zip_nil_right, mem_singleton, Prod.mk.injEq, append_nil, Perm.refl]\n  · rw [sublists'_cons, reverse_append, zip_append, ← map_reverse, zip_map_right, zip_map_left] at *\n      <;> [simp only [mem_append, mem_map, Prod.map_apply, id_eq, Prod.mk.injEq, Prod.exists,\n        exists_eq_right_right] at h; simp]\n    rcases h with (⟨l₁, l₂', h, rfl, rfl⟩ | ⟨l₁', h, rfl⟩)\n    · exact perm_middle.trans ((IH _ _ h).cons _)\n    · exact (IH _ _ h).cons _\n\n"}
{"name":"List.range_bind_sublistsLen_perm","module":"Mathlib.Data.List.Sublists","initialProofState":"α : Type u\nl : List α\n⊢ ((List.range (HAdd.hAdd l.length 1)).flatMap fun n => List.sublistsLen n l).Perm l.sublists'","decl":"theorem range_bind_sublistsLen_perm (l : List α) :\n    ((List.range (l.length + 1)).flatMap fun n => sublistsLen n l) ~ sublists' l := by\n  induction' l with h tl l_ih\n  · simp [range_succ]\n  · simp_rw [range_succ_eq_map, length, flatMap_cons, flatMap_map, sublistsLen_succ_cons,\n      sublists'_cons, List.sublistsLen_zero, List.singleton_append]\n    refine ((flatMap_append_perm (range (tl.length + 1)) _ _).symm.cons _).trans ?_\n    simp_rw [← List.map_flatMap, ← cons_append]\n    rw [← List.singleton_append, ← List.sublistsLen_zero tl]\n    refine Perm.append ?_ (l_ih.map _)\n    rw [List.range_succ, flatMap_append, flatMap_singleton,\n      sublistsLen_of_length_lt (Nat.lt_succ_self _), append_nil,\n      ← List.flatMap_map Nat.succ fun n => sublistsLen n tl,\n      ← flatMap_cons 0 _ fun n => sublistsLen n tl, ← range_succ_eq_map]\n    exact l_ih\n\n"}
