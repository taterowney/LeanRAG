{"name":"univLE_iff_cardinal_le","module":"Mathlib.SetTheory.Cardinal.UnivLE","initialProofState":"⊢ Iff UnivLE.{u, v} (LE.le Cardinal.univ.{u, v + 1} Cardinal.univ.{v, u + 1})","decl":"theorem univLE_iff_cardinal_le : UnivLE.{u, v} ↔ univ.{u, v+1} ≤ univ.{v, u+1} := by\n  rw [← not_iff_not, UnivLE]; simp_rw [small_iff_lift_mk_lt_univ]; push_neg\n  -- strange: simp_rw [univ_umax.{v,u}] doesn't work\n  refine ⟨fun ⟨α, le⟩ ↦ ?_, fun h ↦ ?_⟩\n  · rw [univ_umax.{v,u}, ← lift_le.{u+1}, lift_univ, lift_lift] at le\n    exact le.trans_lt (lift_lt_univ'.{u,v+1} #α)\n  · obtain ⟨⟨α⟩, h⟩ := lt_univ'.mp h; use α\n    rw [univ_umax.{v,u}, ← lift_le.{u+1}, lift_univ, lift_lift]\n    exact h.le\n\n"}
{"name":"univLE_iff_exists_embedding","module":"Mathlib.SetTheory.Cardinal.UnivLE","initialProofState":"⊢ Iff UnivLE.{u, v} (Nonempty (Function.Embedding Ordinal.{u} Ordinal.{v}))","decl":"theorem univLE_iff_exists_embedding : UnivLE.{u, v} ↔ Nonempty (Ordinal.{u} ↪ Ordinal.{v}) := by\n  rw [univLE_iff_cardinal_le]\n  exact lift_mk_le'\n\n"}
{"name":"Ordinal.univLE_of_injective","module":"Mathlib.SetTheory.Cardinal.UnivLE","initialProofState":"f : Ordinal.{u} → Ordinal.{v}\nh : Function.Injective f\n⊢ UnivLE.{u, v}","decl":"theorem Ordinal.univLE_of_injective {f : Ordinal.{u} → Ordinal.{v}} (h : f.Injective) :\n    UnivLE.{u, v} :=\n  univLE_iff_exists_embedding.2 ⟨f, h⟩\n\n"}
{"name":"univLE_total","module":"Mathlib.SetTheory.Cardinal.UnivLE","initialProofState":"⊢ Or UnivLE.{u, v} UnivLE.{v, u}","decl":"/-- Together with transitivity, this shows `UnivLE` is a total preorder. -/\ntheorem univLE_total : UnivLE.{u, v} ∨ UnivLE.{v, u} := by\n  simp_rw [univLE_iff_cardinal_le]; apply le_total\n"}
