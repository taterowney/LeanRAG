{"name":"MvPolynomial.degree_degLexDegree","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder.DegLex","initialProofState":"σ : Type u_1\ninst✝² : LinearOrder σ\nR : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : WellFoundedGT σ\nf : MvPolynomial σ R\n⊢ Eq (MonomialOrder.degLex.degree f).degree f.totalDegree","decl":"theorem degree_degLexDegree : (degLex.degree f).degree = f.totalDegree := by\n  by_cases hf : f = 0\n  · simp [hf]\n  apply le_antisymm\n  · apply MvPolynomial.le_totalDegree\n    rw [MvPolynomial.mem_support_iff]\n    change degLex.leadingCoeff f ≠ 0\n    rw [leadingCoeff_ne_zero_iff]\n    exact hf\n  · unfold MvPolynomial.totalDegree\n    apply Finset.sup_le\n    intro b hb\n    exact DegLex.monotone_degree (degLex.le_degree hb)\n\n"}
{"name":"MvPolynomial.degLex_totalDegree_monotone","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder.DegLex","initialProofState":"σ : Type u_1\ninst✝² : LinearOrder σ\nR : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : WellFoundedGT σ\nf g : MvPolynomial σ R\nh : LE.le (MonomialOrder.degLex.toSyn (MonomialOrder.degLex.degree f)) (MonomialOrder.degLex.toSyn (MonomialOrder.degLex.degree g))\n⊢ LE.le f.totalDegree g.totalDegree","decl":"theorem degLex_totalDegree_monotone (h : degLex.degree f ≼[degLex] degLex.degree g) :\n    f.totalDegree ≤ g.totalDegree := by\n  simp only [← MvPolynomial.degree_degLexDegree]\n  exact DegLex.monotone_degree h\n\n"}
