{"name":"Ideal.mem_isPrincipalSubmonoid_iff","module":"Mathlib.RingTheory.Ideal.IsPrincipal","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal R\n⊢ Iff (Membership.mem (Ideal.isPrincipalSubmonoid R) I) (Submodule.IsPrincipal I)","decl":"theorem mem_isPrincipalSubmonoid_iff {I : Ideal R} :\n    I ∈ isPrincipalSubmonoid R ↔ IsPrincipal I := Iff.rfl\n\n"}
{"name":"Ideal.span_singleton_mem_isPrincipalSubmonoid","module":"Mathlib.RingTheory.Ideal.IsPrincipal","initialProofState":"R : Type u_1\ninst✝ : CommRing R\na : R\n⊢ Membership.mem (Ideal.isPrincipalSubmonoid R) (Ideal.span (Singleton.singleton a))","decl":"theorem span_singleton_mem_isPrincipalSubmonoid (a : R) :\n    span {a} ∈ isPrincipalSubmonoid R := mem_isPrincipalSubmonoid_iff.mpr ⟨a, rfl⟩\n\n"}
{"name":"Ideal.associatesEquivIsPrincipal_apply","module":"Mathlib.RingTheory.Ideal.IsPrincipal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nx : R\n⊢ Eq (↑((Ideal.associatesEquivIsPrincipal R) (Associates.mk x))) (Ideal.span (Singleton.singleton x))","decl":"@[simp]\ntheorem associatesEquivIsPrincipal_apply (x : R) :\n    associatesEquivIsPrincipal R (.mk x) = span {x} := rfl\n\n"}
{"name":"Ideal.associatesEquivIsPrincipal_symm_apply","module":"Mathlib.RingTheory.Ideal.IsPrincipal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nI : Ideal R\nhI : Submodule.IsPrincipal I\n⊢ Eq ((Ideal.associatesEquivIsPrincipal R).symm ⟨I, hI⟩) (Associates.mk (Submodule.IsPrincipal.generator I))","decl":"@[simp]\ntheorem associatesEquivIsPrincipal_symm_apply {I : Ideal R} (hI : IsPrincipal I) :\n    (associatesEquivIsPrincipal R).symm ⟨I, hI⟩ = .mk hI.generator := rfl\n\n"}
{"name":"Ideal.associatesEquivIsPrincipal_mul","module":"Mathlib.RingTheory.Ideal.IsPrincipal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nx y : Associates R\n⊢ Eq (↑((Ideal.associatesEquivIsPrincipal R) (HMul.hMul x y))) (HMul.hMul ↑((Ideal.associatesEquivIsPrincipal R) x) ↑((Ideal.associatesEquivIsPrincipal R) y))","decl":"theorem associatesEquivIsPrincipal_mul (x y : Associates R) :\n    (associatesEquivIsPrincipal R (x * y) : Ideal R) =\n      (associatesEquivIsPrincipal R x) * (associatesEquivIsPrincipal R y) := by\n  rw [← quot_out x, ← quot_out y]\n  simp_rw [mk_mul_mk, associatesEquivIsPrincipal_apply, span_singleton_mul_span_singleton]\n\n"}
{"name":"Ideal.associatesEquivIsPrincipal_map_zero","module":"Mathlib.RingTheory.Ideal.IsPrincipal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Eq (↑((Ideal.associatesEquivIsPrincipal R) 0)) 0","decl":"@[simp]\ntheorem associatesEquivIsPrincipal_map_zero :\n    (associatesEquivIsPrincipal R 0 : Ideal R) = 0 := by\n  rw [← mk_zero, associatesEquivIsPrincipal_apply, Submodule.zero_eq_bot, span_singleton_eq_bot]\n\n"}
{"name":"Ideal.associatesEquivIsPrincipal_map_one","module":"Mathlib.RingTheory.Ideal.IsPrincipal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Eq (↑((Ideal.associatesEquivIsPrincipal R) 1)) 1","decl":"@[simp]\ntheorem associatesEquivIsPrincipal_map_one :\n    (associatesEquivIsPrincipal R 1 : Ideal R) = 1 := by\n  rw [one_eq_mk_one, associatesEquivIsPrincipal_apply, span_singleton_one, one_eq_top]\n\n"}
{"name":"Ideal.associatesNonZeroDivisorsEquivIsPrincipal_apply","module":"Mathlib.RingTheory.Ideal.IsPrincipal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nx : Subtype fun x => Membership.mem (nonZeroDivisors R) x\n⊢ Eq (↑↑((Ideal.associatesNonZeroDivisorsEquivIsPrincipal R) (Associates.mk x))) (Ideal.span (Singleton.singleton ↑x))","decl":"@[simp]\ntheorem associatesNonZeroDivisorsEquivIsPrincipal_apply (x : R⁰) :\n    associatesNonZeroDivisorsEquivIsPrincipal R (.mk x) = Ideal.span {(x : R)} := rfl\n\n"}
{"name":"Ideal.associatesNonZeroDivisorsEquivIsPrincipal_coe","module":"Mathlib.RingTheory.Ideal.IsPrincipal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nx : Associates (Subtype fun x => Membership.mem (nonZeroDivisors R) x)\n⊢ Eq ↑↑((Ideal.associatesNonZeroDivisorsEquivIsPrincipal R) x) ↑((Ideal.associatesEquivIsPrincipal R) ↑(associatesNonZeroDivisorsEquiv.symm x))","decl":"theorem associatesNonZeroDivisorsEquivIsPrincipal_coe (x : Associates R⁰) :\n    (associatesNonZeroDivisorsEquivIsPrincipal R x : Ideal R) =\n      (associatesEquivIsPrincipal R (associatesNonZeroDivisorsEquiv.symm x)) := rfl\n\n"}
{"name":"Ideal.associatesNonZeroDivisorsEquivIsPrincipal_mul","module":"Mathlib.RingTheory.Ideal.IsPrincipal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nx y : Associates (Subtype fun x => Membership.mem (nonZeroDivisors R) x)\n⊢ Eq (↑↑((Ideal.associatesNonZeroDivisorsEquivIsPrincipal R) (HMul.hMul x y))) (HMul.hMul ↑↑((Ideal.associatesNonZeroDivisorsEquivIsPrincipal R) x) ↑↑((Ideal.associatesNonZeroDivisorsEquivIsPrincipal R) y))","decl":"theorem associatesNonZeroDivisorsEquivIsPrincipal_mul (x y : Associates R⁰) :\n    (associatesNonZeroDivisorsEquivIsPrincipal R (x * y) : Ideal R) =\n      (associatesNonZeroDivisorsEquivIsPrincipal R x) *\n        (associatesNonZeroDivisorsEquivIsPrincipal R y) := by\n  simp_rw [associatesNonZeroDivisorsEquivIsPrincipal_coe, _root_.map_mul, Submonoid.coe_mul,\n    associatesEquivIsPrincipal_mul]\n\n"}
{"name":"Ideal.associatesNonZeroDivisorsEquivIsPrincipal_map_one","module":"Mathlib.RingTheory.Ideal.IsPrincipal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Eq (↑↑((Ideal.associatesNonZeroDivisorsEquivIsPrincipal R) 1)) 1","decl":"@[simp]\ntheorem associatesNonZeroDivisorsEquivIsPrincipal_map_one :\n    (associatesNonZeroDivisorsEquivIsPrincipal R 1 : Ideal R) = 1 := by\n  rw [associatesNonZeroDivisorsEquivIsPrincipal_coe, map_one, OneMemClass.coe_one,\n    associatesEquivIsPrincipal_map_one]\n\n"}
