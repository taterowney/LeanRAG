{"name":"Rat.instZeroLEOneClass","module":"Mathlib.Data.NNRat.Defs","initialProofState":"⊢ ZeroLEOneClass Rat","decl":"instance Rat.instZeroLEOneClass : ZeroLEOneClass ℚ where\n  zero_le_one := rfl\n\n"}
{"name":"Rat.instPosMulMono","module":"Mathlib.Data.NNRat.Defs","initialProofState":"⊢ PosMulMono Rat","decl":"instance Rat.instPosMulMono : PosMulMono ℚ where\n  elim := fun r p q h => by\n    simp only [mul_comm]\n    simpa [sub_mul, sub_nonneg] using Rat.mul_nonneg (sub_nonneg.2 h) r.2\n\n"}
{"name":"NNRat.instNontrivial","module":"Mathlib.Data.NNRat.Defs","initialProofState":"⊢ Nontrivial NNRat","decl":"instance instNontrivial : Nontrivial ℚ≥0 where exists_pair_ne := ⟨1, 0, by decide⟩\n"}
{"name":"NNRat.val_eq_cast","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\n⊢ Eq ↑q ↑q","decl":"@[simp] lemma val_eq_cast (q : ℚ≥0) : q.1 = q := rfl\n\n"}
{"name":"NNRat.instCharZero","module":"Mathlib.Data.NNRat.Defs","initialProofState":"⊢ CharZero NNRat","decl":"instance instCharZero : CharZero ℚ≥0 where\n  cast_injective a b hab := by simpa using congr_arg num hab\n\n"}
{"name":"NNRat.canLift","module":"Mathlib.Data.NNRat.Defs","initialProofState":"⊢ CanLift Rat NNRat NNRat.cast fun q => LE.le 0 q","decl":"instance canLift : CanLift ℚ ℚ≥0 (↑) fun q ↦ 0 ≤ q where\n  prf q hq := ⟨⟨q, hq⟩, rfl⟩\n\n"}
{"name":"NNRat.ext","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p q : NNRat\na✝ : Eq ↑p ↑q\n⊢ Eq p q","decl":"@[ext]\ntheorem ext : (p : ℚ) = (q : ℚ) → p = q :=\n  Subtype.ext\n\n"}
{"name":"NNRat.ext_iff","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p q : NNRat\n⊢ Iff (Eq p q) (Eq ↑p ↑q)","decl":"@[ext]\ntheorem ext : (p : ℚ) = (q : ℚ) → p = q :=\n  Subtype.ext\n\n"}
{"name":"NNRat.coe_injective","module":"Mathlib.Data.NNRat.Defs","initialProofState":"⊢ Function.Injective NNRat.cast","decl":"protected theorem coe_injective : Injective ((↑) : ℚ≥0 → ℚ) :=\n  Subtype.coe_injective\n\n-- See note [specialised high priority simp lemma]\n"}
{"name":"NNRat.coe_inj","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p q : NNRat\n⊢ Iff (Eq ↑p ↑q) (Eq p q)","decl":"@[simp high, norm_cast]\ntheorem coe_inj : (p : ℚ) = q ↔ p = q :=\n  Subtype.coe_inj\n\n"}
{"name":"NNRat.ne_iff","module":"Mathlib.Data.NNRat.Defs","initialProofState":"x y : NNRat\n⊢ Iff (Ne ↑x ↑y) (Ne x y)","decl":"theorem ne_iff {x y : ℚ≥0} : (x : ℚ) ≠ (y : ℚ) ↔ x ≠ y :=\n  NNRat.coe_inj.not\n\n-- TODO: We have to write `NNRat.cast` explicitly, else the statement picks up `Subtype.val` instead\n"}
{"name":"NNRat.coe_mk","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : Rat\nhq : LE.le 0 q\n⊢ Eq (↑⟨q, hq⟩) q","decl":"@[simp, norm_cast] lemma coe_mk (q : ℚ) (hq) : NNRat.cast ⟨q, hq⟩ = q := rfl\n\n"}
{"name":"NNRat.forall","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p : NNRat → Prop\n⊢ Iff (∀ (q : NNRat), p q) (∀ (q : Rat) (hq : LE.le 0 q), p ⟨q, hq⟩)","decl":"lemma «forall» {p : ℚ≥0 → Prop} : (∀ q, p q) ↔ ∀ q hq, p ⟨q, hq⟩ := Subtype.forall\n"}
{"name":"NNRat.exists","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p : NNRat → Prop\n⊢ Iff (Exists fun q => p q) (Exists fun q => Exists fun hq => p ⟨q, hq⟩)","decl":"lemma «exists» {p : ℚ≥0 → Prop} : (∃ q, p q) ↔ ∃ q hq, p ⟨q, hq⟩ := Subtype.exists\n\n"}
{"name":"Rat.coe_toNNRat","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : Rat\nhq : LE.le 0 q\n⊢ Eq (↑q.toNNRat) q","decl":"theorem _root_.Rat.coe_toNNRat (q : ℚ) (hq : 0 ≤ q) : (q.toNNRat : ℚ) = q :=\n  max_eq_left hq\n\n"}
{"name":"Rat.le_coe_toNNRat","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : Rat\n⊢ LE.le q ↑q.toNNRat","decl":"theorem _root_.Rat.le_coe_toNNRat (q : ℚ) : q ≤ q.toNNRat :=\n  le_max_left _ _\n\n"}
{"name":"NNRat.coe_nonneg","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\n⊢ LE.le 0 ↑q","decl":"@[simp]\ntheorem coe_nonneg (q : ℚ≥0) : (0 : ℚ) ≤ q :=\n  q.2\n\n"}
{"name":"NNRat.coe_zero","module":"Mathlib.Data.NNRat.Defs","initialProofState":"⊢ Eq (↑0) 0","decl":"@[simp, norm_cast] lemma coe_zero : ((0 : ℚ≥0) : ℚ) = 0 := rfl\n"}
{"name":"NNRat.num_zero","module":"Mathlib.Data.NNRat.Defs","initialProofState":"⊢ Eq (NNRat.num 0) 0","decl":"@[simp] lemma num_zero : num 0 = 0 := rfl\n"}
{"name":"NNRat.den_zero","module":"Mathlib.Data.NNRat.Defs","initialProofState":"⊢ Eq (NNRat.den 0) 1","decl":"@[simp] lemma den_zero : den 0 = 1 := rfl\n\n"}
{"name":"NNRat.coe_one","module":"Mathlib.Data.NNRat.Defs","initialProofState":"⊢ Eq (↑1) 1","decl":"@[simp, norm_cast] lemma coe_one : ((1 : ℚ≥0) : ℚ) = 1 := rfl\n"}
{"name":"NNRat.num_one","module":"Mathlib.Data.NNRat.Defs","initialProofState":"⊢ Eq (NNRat.num 1) 1","decl":"@[simp] lemma num_one : num 1 = 1 := rfl\n"}
{"name":"NNRat.den_one","module":"Mathlib.Data.NNRat.Defs","initialProofState":"⊢ Eq (NNRat.den 1) 1","decl":"@[simp] lemma den_one : den 1 = 1 := rfl\n\n"}
{"name":"NNRat.coe_add","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p q : NNRat\n⊢ Eq (↑(HAdd.hAdd p q)) (HAdd.hAdd ↑p ↑q)","decl":"@[simp, norm_cast]\ntheorem coe_add (p q : ℚ≥0) : ((p + q : ℚ≥0) : ℚ) = p + q :=\n  rfl\n\n"}
{"name":"NNRat.coe_mul","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p q : NNRat\n⊢ Eq (↑(HMul.hMul p q)) (HMul.hMul ↑p ↑q)","decl":"@[simp, norm_cast]\ntheorem coe_mul (p q : ℚ≥0) : ((p * q : ℚ≥0) : ℚ) = p * q :=\n  rfl\n\n"}
{"name":"NNRat.coe_pow","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\nn : Nat\n⊢ Eq (↑(HPow.hPow q n)) (HPow.hPow (↑q) n)","decl":"@[simp, norm_cast] lemma coe_pow (q : ℚ≥0) (n : ℕ) : (↑(q ^ n) : ℚ) = (q : ℚ) ^ n :=\n  rfl\n\n"}
{"name":"NNRat.num_pow","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\nn : Nat\n⊢ Eq (HPow.hPow q n).num (HPow.hPow q.num n)","decl":"@[simp] lemma num_pow (q : ℚ≥0) (n : ℕ) : (q ^ n).num = q.num ^ n := by simp [num, Int.natAbs_pow]\n"}
{"name":"NNRat.den_pow","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\nn : Nat\n⊢ Eq (HPow.hPow q n).den (HPow.hPow q.den n)","decl":"@[simp] lemma den_pow (q : ℚ≥0) (n : ℕ) : (q ^ n).den = q.den ^ n := rfl\n\n"}
{"name":"NNRat.coe_sub","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p q : NNRat\nh : LE.le q p\n⊢ Eq (↑(HSub.hSub p q)) (HSub.hSub ↑p ↑q)","decl":"@[simp, norm_cast]\ntheorem coe_sub (h : q ≤ p) : ((p - q : ℚ≥0) : ℚ) = p - q :=\n  max_eq_left <| le_sub_comm.2 <| by rwa [sub_zero]\n\n-- See note [specialised high priority simp lemma]\n"}
{"name":"NNRat.coe_eq_zero","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\n⊢ Iff (Eq (↑q) 0) (Eq q 0)","decl":"@[simp high]\ntheorem coe_eq_zero : (q : ℚ) = 0 ↔ q = 0 := by norm_cast\n\n"}
{"name":"NNRat.coe_ne_zero","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\n⊢ Iff (Ne (↑q) 0) (Ne q 0)","decl":"theorem coe_ne_zero : (q : ℚ) ≠ 0 ↔ q ≠ 0 :=\n  coe_eq_zero.not\n\n"}
{"name":"NNRat.coe_le_coe","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p q : NNRat\n⊢ Iff (LE.le ↑p ↑q) (LE.le p q)","decl":"@[norm_cast]\ntheorem coe_le_coe : (p : ℚ) ≤ q ↔ p ≤ q :=\n  Iff.rfl\n\n"}
{"name":"NNRat.coe_lt_coe","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p q : NNRat\n⊢ Iff (LT.lt ↑p ↑q) (LT.lt p q)","decl":"@[norm_cast]\ntheorem coe_lt_coe : (p : ℚ) < q ↔ p < q :=\n  Iff.rfl\n\n"}
{"name":"NNRat.coe_pos","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\n⊢ Iff (LT.lt 0 ↑q) (LT.lt 0 q)","decl":"@[norm_cast]\ntheorem coe_pos : (0 : ℚ) < q ↔ 0 < q :=\n  Iff.rfl\n\n"}
{"name":"NNRat.coe_mono","module":"Mathlib.Data.NNRat.Defs","initialProofState":"⊢ Monotone NNRat.cast","decl":"theorem coe_mono : Monotone ((↑) : ℚ≥0 → ℚ) :=\n  fun _ _ ↦ coe_le_coe.2\n\n"}
{"name":"NNRat.toNNRat_mono","module":"Mathlib.Data.NNRat.Defs","initialProofState":"⊢ Monotone Rat.toNNRat","decl":"theorem toNNRat_mono : Monotone toNNRat :=\n  fun _ _ h ↦ max_le_max h le_rfl\n\n"}
{"name":"NNRat.toNNRat_coe","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\n⊢ Eq (↑q).toNNRat q","decl":"@[simp]\ntheorem toNNRat_coe (q : ℚ≥0) : toNNRat q = q :=\n  ext <| max_eq_left q.2\n\n"}
{"name":"NNRat.toNNRat_coe_nat","module":"Mathlib.Data.NNRat.Defs","initialProofState":"n : Nat\n⊢ Eq (↑n).toNNRat ↑n","decl":"@[simp]\ntheorem toNNRat_coe_nat (n : ℕ) : toNNRat n = n :=\n  ext <| by simp only [Nat.cast_nonneg', Rat.coe_toNNRat]; rfl\n\n"}
{"name":"NNRat.coe_natCast","module":"Mathlib.Data.NNRat.Defs","initialProofState":"n : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast] lemma coe_natCast (n : ℕ) : (↑(↑n : ℚ≥0) : ℚ) = n := rfl\n\n"}
{"name":"NNRat.mk_natCast","module":"Mathlib.Data.NNRat.Defs","initialProofState":"n : Nat\n⊢ Eq ⟨↑n, ⋯⟩ ↑n","decl":"@[simp]\ntheorem mk_natCast (n : ℕ) : @Eq ℚ≥0 (⟨(n : ℚ), Nat.cast_nonneg' n⟩ : ℚ≥0) n :=\n  rfl\n\n"}
{"name":"NNRat.coe_coeHom","module":"Mathlib.Data.NNRat.Defs","initialProofState":"⊢ Eq (⇑NNRat.coeHom) NNRat.cast","decl":"@[simp]\ntheorem coe_coeHom : ⇑coeHom = ((↑) : ℚ≥0 → ℚ) :=\n  rfl\n\n"}
{"name":"NNRat.nsmul_coe","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\nn : Nat\n⊢ Eq (↑(HSMul.hSMul n q)) (HSMul.hSMul n ↑q)","decl":"@[norm_cast]\ntheorem nsmul_coe (q : ℚ≥0) (n : ℕ) : ↑(n • q) = n • (q : ℚ) :=\n  coeHom.toAddMonoidHom.map_nsmul _ _\n\n"}
{"name":"NNRat.bddAbove_coe","module":"Mathlib.Data.NNRat.Defs","initialProofState":"s : Set NNRat\n⊢ Iff (BddAbove (Set.image NNRat.cast s)) (BddAbove s)","decl":"theorem bddAbove_coe {s : Set ℚ≥0} : BddAbove ((↑) '' s : Set ℚ) ↔ BddAbove s :=\n  ⟨fun ⟨b, hb⟩ ↦\n    ⟨toNNRat b, fun ⟨y, _⟩ hys ↦\n      show y ≤ max b 0 from (hb <| Set.mem_image_of_mem _ hys).trans <| le_max_left _ _⟩,\n    fun ⟨b, hb⟩ ↦ ⟨b, fun _ ⟨_, hx, Eq⟩ ↦ Eq ▸ hb hx⟩⟩\n\n"}
{"name":"NNRat.bddBelow_coe","module":"Mathlib.Data.NNRat.Defs","initialProofState":"s : Set NNRat\n⊢ BddBelow (Set.image NNRat.cast s)","decl":"theorem bddBelow_coe (s : Set ℚ≥0) : BddBelow (((↑) : ℚ≥0 → ℚ) '' s) :=\n  ⟨0, fun _ ⟨q, _, h⟩ ↦ h ▸ q.2⟩\n\n"}
{"name":"NNRat.coe_max","module":"Mathlib.Data.NNRat.Defs","initialProofState":"x y : NNRat\n⊢ Eq (↑(Max.max x y)) (Max.max ↑x ↑y)","decl":"@[norm_cast]\ntheorem coe_max (x y : ℚ≥0) : ((max x y : ℚ≥0) : ℚ) = max (x : ℚ) (y : ℚ) :=\n  coe_mono.map_max\n\n"}
{"name":"NNRat.coe_min","module":"Mathlib.Data.NNRat.Defs","initialProofState":"x y : NNRat\n⊢ Eq (↑(Min.min x y)) (Min.min ↑x ↑y)","decl":"@[norm_cast]\ntheorem coe_min (x y : ℚ≥0) : ((min x y : ℚ≥0) : ℚ) = min (x : ℚ) (y : ℚ) :=\n  coe_mono.map_min\n\n"}
{"name":"NNRat.sub_def","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p q : NNRat\n⊢ Eq (HSub.hSub p q) (HSub.hSub ↑p ↑q).toNNRat","decl":"theorem sub_def (p q : ℚ≥0) : p - q = toNNRat (p - q) :=\n  rfl\n\n"}
{"name":"NNRat.abs_coe","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\n⊢ Eq (abs ↑q) ↑q","decl":"@[simp]\ntheorem abs_coe (q : ℚ≥0) : |(q : ℚ)| = q :=\n  abs_of_nonneg q.2\n\n-- See note [specialised high priority simp lemma]\n"}
{"name":"NNRat.nonpos_iff_eq_zero","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\n⊢ Iff (LE.le q 0) (Eq q 0)","decl":"@[simp high]\ntheorem nonpos_iff_eq_zero (q : ℚ≥0) : q ≤ 0 ↔ q = 0 :=\n  ⟨fun h => le_antisymm h q.2, fun h => h.symm ▸ q.2⟩\n\n"}
{"name":"Rat.toNNRat_zero","module":"Mathlib.Data.NNRat.Defs","initialProofState":"⊢ Eq (Rat.toNNRat 0) 0","decl":"@[simp]\ntheorem toNNRat_zero : toNNRat 0 = 0 := rfl\n\n"}
{"name":"Rat.toNNRat_one","module":"Mathlib.Data.NNRat.Defs","initialProofState":"⊢ Eq (Rat.toNNRat 1) 1","decl":"@[simp]\ntheorem toNNRat_one : toNNRat 1 = 1 := rfl\n\n"}
{"name":"Rat.toNNRat_pos","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : Rat\n⊢ Iff (LT.lt 0 q.toNNRat) (LT.lt 0 q)","decl":"@[simp]\ntheorem toNNRat_pos : 0 < toNNRat q ↔ 0 < q := by simp [toNNRat, ← coe_lt_coe]\n\n"}
{"name":"Rat.toNNRat_eq_zero","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : Rat\n⊢ Iff (Eq q.toNNRat 0) (LE.le q 0)","decl":"@[simp]\ntheorem toNNRat_eq_zero : toNNRat q = 0 ↔ q ≤ 0 := by\n  simpa [-toNNRat_pos] using (@toNNRat_pos q).not\n\n"}
{"name":"Rat.toNNRat_of_nonpos","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : Rat\na✝ : LE.le q 0\n⊢ Eq q.toNNRat 0","decl":"alias ⟨_, toNNRat_of_nonpos⟩ := toNNRat_eq_zero\n\n"}
{"name":"Rat.toNNRat_le_toNNRat_iff","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p q : Rat\nhp : LE.le 0 p\n⊢ Iff (LE.le q.toNNRat p.toNNRat) (LE.le q p)","decl":"@[simp]\ntheorem toNNRat_le_toNNRat_iff (hp : 0 ≤ p) : toNNRat q ≤ toNNRat p ↔ q ≤ p := by\n  simp [← coe_le_coe, toNNRat, hp]\n\n"}
{"name":"Rat.toNNRat_lt_toNNRat_iff'","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p q : Rat\n⊢ Iff (LT.lt q.toNNRat p.toNNRat) (And (LT.lt q p) (LT.lt 0 p))","decl":"@[simp]\ntheorem toNNRat_lt_toNNRat_iff' : toNNRat q < toNNRat p ↔ q < p ∧ 0 < p := by\n  simp [← coe_lt_coe, toNNRat, lt_irrefl]\n\n"}
{"name":"Rat.toNNRat_lt_toNNRat_iff","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p q : Rat\nh : LT.lt 0 p\n⊢ Iff (LT.lt q.toNNRat p.toNNRat) (LT.lt q p)","decl":"theorem toNNRat_lt_toNNRat_iff (h : 0 < p) : toNNRat q < toNNRat p ↔ q < p :=\n  toNNRat_lt_toNNRat_iff'.trans (and_iff_left h)\n\n"}
{"name":"Rat.toNNRat_lt_toNNRat_iff_of_nonneg","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p q : Rat\nhq : LE.le 0 q\n⊢ Iff (LT.lt q.toNNRat p.toNNRat) (LT.lt q p)","decl":"theorem toNNRat_lt_toNNRat_iff_of_nonneg (hq : 0 ≤ q) : toNNRat q < toNNRat p ↔ q < p :=\n  toNNRat_lt_toNNRat_iff'.trans ⟨And.left, fun h ↦ ⟨h, hq.trans_lt h⟩⟩\n\n"}
{"name":"Rat.toNNRat_add","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p q : Rat\nhq : LE.le 0 q\nhp : LE.le 0 p\n⊢ Eq (HAdd.hAdd q p).toNNRat (HAdd.hAdd q.toNNRat p.toNNRat)","decl":"@[simp]\ntheorem toNNRat_add (hq : 0 ≤ q) (hp : 0 ≤ p) : toNNRat (q + p) = toNNRat q + toNNRat p :=\n  NNRat.ext <| by simp [toNNRat, hq, hp, add_nonneg]\n\n"}
{"name":"Rat.toNNRat_add_le","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p q : Rat\n⊢ LE.le (HAdd.hAdd q p).toNNRat (HAdd.hAdd q.toNNRat p.toNNRat)","decl":"theorem toNNRat_add_le : toNNRat (q + p) ≤ toNNRat q + toNNRat p :=\n  coe_le_coe.1 <| max_le (add_le_add (le_max_left _ _) (le_max_left _ _)) <| coe_nonneg _\n\n"}
{"name":"Rat.toNNRat_le_iff_le_coe","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : Rat\np : NNRat\n⊢ Iff (LE.le q.toNNRat p) (LE.le q ↑p)","decl":"theorem toNNRat_le_iff_le_coe {p : ℚ≥0} : toNNRat q ≤ p ↔ q ≤ ↑p :=\n  NNRat.gi.gc q p\n\n"}
{"name":"Rat.le_toNNRat_iff_coe_le","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p : Rat\nq : NNRat\nhp : LE.le 0 p\n⊢ Iff (LE.le q p.toNNRat) (LE.le (↑q) p)","decl":"theorem le_toNNRat_iff_coe_le {q : ℚ≥0} (hp : 0 ≤ p) : q ≤ toNNRat p ↔ ↑q ≤ p := by\n  rw [← coe_le_coe, Rat.coe_toNNRat p hp]\n\n"}
{"name":"Rat.le_toNNRat_iff_coe_le'","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p : Rat\nq : NNRat\nhq : LT.lt 0 q\n⊢ Iff (LE.le q p.toNNRat) (LE.le (↑q) p)","decl":"theorem le_toNNRat_iff_coe_le' {q : ℚ≥0} (hq : 0 < q) : q ≤ toNNRat p ↔ ↑q ≤ p :=\n  (le_or_lt 0 p).elim le_toNNRat_iff_coe_le fun hp ↦ by\n    simp only [(hp.trans_le q.coe_nonneg).not_le, toNNRat_eq_zero.2 hp.le, hq.not_le]\n\n"}
{"name":"Rat.toNNRat_lt_iff_lt_coe","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : Rat\np : NNRat\nhq : LE.le 0 q\n⊢ Iff (LT.lt q.toNNRat p) (LT.lt q ↑p)","decl":"theorem toNNRat_lt_iff_lt_coe {p : ℚ≥0} (hq : 0 ≤ q) : toNNRat q < p ↔ q < ↑p := by\n  rw [← coe_lt_coe, Rat.coe_toNNRat q hq]\n\n"}
{"name":"Rat.lt_toNNRat_iff_coe_lt","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p : Rat\nq : NNRat\n⊢ Iff (LT.lt q p.toNNRat) (LT.lt (↑q) p)","decl":"theorem lt_toNNRat_iff_coe_lt {q : ℚ≥0} : q < toNNRat p ↔ ↑q < p :=\n  NNRat.gi.gc.lt_iff_lt\n\n"}
{"name":"Rat.toNNRat_mul","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p q : Rat\nhp : LE.le 0 p\n⊢ Eq (HMul.hMul p q).toNNRat (HMul.hMul p.toNNRat q.toNNRat)","decl":"theorem toNNRat_mul (hp : 0 ≤ p) : toNNRat (p * q) = toNNRat p * toNNRat q := by\n  rcases le_total 0 q with hq | hq\n  · ext; simp [toNNRat, hp, hq, max_eq_left, mul_nonneg]\n  · have hpq := mul_nonpos_of_nonneg_of_nonpos hp hq\n    rw [toNNRat_eq_zero.2 hq, toNNRat_eq_zero.2 hpq, mul_zero]\n\n"}
{"name":"Rat.coe_nnabs","module":"Mathlib.Data.NNRat.Defs","initialProofState":"x : Rat\n⊢ Eq (↑(Rat.nnabs x)) (abs x)","decl":"@[norm_cast, simp]\ntheorem Rat.coe_nnabs (x : ℚ) : (Rat.nnabs x : ℚ) = abs x := rfl\n\n"}
{"name":"NNRat.num_coe","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\n⊢ Eq (↑q).num ↑q.num","decl":"@[norm_cast] lemma num_coe (q : ℚ≥0) : (q : ℚ).num = q.num := by\n  simp only [num, Int.natCast_natAbs, Rat.num_nonneg, coe_nonneg, abs_of_nonneg]\n\n"}
{"name":"NNRat.natAbs_num_coe","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\n⊢ Eq (↑q).num.natAbs q.num","decl":"theorem natAbs_num_coe : (q : ℚ).num.natAbs = q.num := rfl\n\n"}
{"name":"NNRat.den_coe","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\n⊢ Eq (↑q).den q.den","decl":"@[norm_cast] lemma den_coe : (q : ℚ).den = q.den := rfl\n\n"}
{"name":"NNRat.num_ne_zero","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\n⊢ Iff (Ne q.num 0) (Ne q 0)","decl":"@[simp] lemma num_ne_zero : q.num ≠ 0 ↔ q ≠ 0 := by simp [num]\n"}
{"name":"NNRat.num_pos","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\n⊢ Iff (LT.lt 0 q.num) (LT.lt 0 q)","decl":"@[simp] lemma num_pos : 0 < q.num ↔ 0 < q := by\n  simpa [num, -nonpos_iff_eq_zero] using nonpos_iff_eq_zero _ |>.not.symm\n"}
{"name":"NNRat.den_pos","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\n⊢ LT.lt 0 q.den","decl":"@[simp] lemma den_pos (q : ℚ≥0) : 0 < q.den := Rat.den_pos _\n"}
{"name":"NNRat.den_ne_zero","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\n⊢ Ne q.den 0","decl":"@[simp] lemma den_ne_zero (q : ℚ≥0) : q.den ≠ 0 := Rat.den_ne_zero _\n\n"}
{"name":"NNRat.coprime_num_den","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\n⊢ q.num.Coprime q.den","decl":"lemma coprime_num_den (q : ℚ≥0) : q.num.Coprime q.den := by simpa [num, den] using Rat.reduced _\n\n-- TODO: Rename `Rat.coe_nat_num`, `Rat.intCast_den`, `Rat.ofNat_num`, `Rat.ofNat_den`\n"}
{"name":"NNRat.num_natCast","module":"Mathlib.Data.NNRat.Defs","initialProofState":"n : Nat\n⊢ Eq (↑n).num n","decl":"@[simp, norm_cast] lemma num_natCast (n : ℕ) : num n = n := rfl\n"}
{"name":"NNRat.den_natCast","module":"Mathlib.Data.NNRat.Defs","initialProofState":"n : Nat\n⊢ Eq (↑n).den 1","decl":"@[simp, norm_cast] lemma den_natCast (n : ℕ) : den n = 1 := rfl\n\n"}
{"name":"NNRat.num_ofNat","module":"Mathlib.Data.NNRat.Defs","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n).num (OfNat.ofNat n)","decl":"@[simp] lemma num_ofNat (n : ℕ) [n.AtLeastTwo] : num ofNat(n) = OfNat.ofNat n :=\n  rfl\n"}
{"name":"NNRat.den_ofNat","module":"Mathlib.Data.NNRat.Defs","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n).den 1","decl":"@[simp] lemma den_ofNat (n : ℕ) [n.AtLeastTwo] : den ofNat(n) = 1 := rfl\n\n"}
{"name":"NNRat.ext_num_den","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p q : NNRat\nhn : Eq p.num q.num\nhd : Eq p.den q.den\n⊢ Eq p q","decl":"theorem ext_num_den (hn : p.num = q.num) (hd : p.den = q.den) : p = q := by\n  refine ext <| Rat.ext ?_ hd\n  simpa [num_coe]\n\n"}
{"name":"NNRat.ext_num_den_iff","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p q : NNRat\n⊢ Iff (Eq p q) (And (Eq p.num q.num) (Eq p.den q.den))","decl":"theorem ext_num_den_iff : p = q ↔ p.num = q.num ∧ p.den = q.den :=\n  ⟨by rintro rfl; exact ⟨rfl, rfl⟩, fun h ↦ ext_num_den h.1 h.2⟩\n\n"}
{"name":"NNRat.coe_divNat","module":"Mathlib.Data.NNRat.Defs","initialProofState":"n d : Nat\n⊢ Eq (↑(NNRat.divNat n d)) (Rat.divInt ↑n ↑d)","decl":"@[simp, norm_cast] lemma coe_divNat (n d : ℕ) : (divNat n d : ℚ) = .divInt n d := rfl\n\n"}
{"name":"NNRat.mk_divInt","module":"Mathlib.Data.NNRat.Defs","initialProofState":"n d : Nat\n⊢ Eq ⟨Rat.divInt ↑n ↑d, ⋯⟩ (NNRat.divNat n d)","decl":"lemma mk_divInt (n d : ℕ) :\n    ⟨.divInt n d, Rat.divInt_nonneg (Int.ofNat_zero_le n) (Int.ofNat_zero_le d)⟩ = divNat n d := rfl\n\n"}
{"name":"NNRat.divNat_inj","module":"Mathlib.Data.NNRat.Defs","initialProofState":"n₁ n₂ d₁ d₂ : Nat\nh₁ : Ne d₁ 0\nh₂ : Ne d₂ 0\n⊢ Iff (Eq (NNRat.divNat n₁ d₁) (NNRat.divNat n₂ d₂)) (Eq (HMul.hMul n₁ d₂) (HMul.hMul n₂ d₁))","decl":"lemma divNat_inj (h₁ : d₁ ≠ 0) (h₂ : d₂ ≠ 0) : divNat n₁ d₁ = divNat n₂ d₂ ↔ n₁ * d₂ = n₂ * d₁ := by\n  rw [← coe_inj]; simp [Rat.mkRat_eq_iff, h₁, h₂]; norm_cast\n\n"}
{"name":"NNRat.divNat_zero","module":"Mathlib.Data.NNRat.Defs","initialProofState":"n : Nat\n⊢ Eq (NNRat.divNat n 0) 0","decl":"@[simp] lemma divNat_zero (n : ℕ) : divNat n 0 = 0 := by simp [divNat]; rfl\n\n"}
{"name":"NNRat.num_divNat_den","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\n⊢ Eq (NNRat.divNat q.num q.den) q","decl":"@[simp] lemma num_divNat_den (q : ℚ≥0) : divNat q.num q.den = q :=\n  ext <| by rw [← (q : ℚ).mkRat_num_den']; simp [num_coe, den_coe]\n\n"}
{"name":"NNRat.natCast_eq_divNat","module":"Mathlib.Data.NNRat.Defs","initialProofState":"n : Nat\n⊢ Eq (↑n) (NNRat.divNat n 1)","decl":"lemma natCast_eq_divNat (n : ℕ) : (n : ℚ≥0) = divNat n 1 := (num_divNat_den _).symm\n\n"}
{"name":"NNRat.divNat_mul_divNat","module":"Mathlib.Data.NNRat.Defs","initialProofState":"n₁ n₂ d₁ d₂ : Nat\nhd₁ : Ne d₁ 0\nhd₂ : Ne d₂ 0\n⊢ Eq (HMul.hMul (NNRat.divNat n₁ d₁) (NNRat.divNat n₂ d₂)) (NNRat.divNat (HMul.hMul n₁ n₂) (HMul.hMul d₁ d₂))","decl":"lemma divNat_mul_divNat (n₁ n₂ : ℕ) {d₁ d₂} (hd₁ : d₁ ≠ 0) (hd₂ : d₂ ≠ 0) :\n    divNat n₁ d₁ * divNat n₂ d₂ = divNat (n₁ * n₂) (d₁ * d₂) := by\n  ext; push_cast; exact Rat.divInt_mul_divInt _ _ (mod_cast hd₁) (mod_cast hd₂)\n\n"}
{"name":"NNRat.divNat_mul_left","module":"Mathlib.Data.NNRat.Defs","initialProofState":"a : Nat\nha : Ne a 0\nn d : Nat\n⊢ Eq (NNRat.divNat (HMul.hMul a n) (HMul.hMul a d)) (NNRat.divNat n d)","decl":"lemma divNat_mul_left {a : ℕ} (ha : a ≠ 0) (n d : ℕ) : divNat (a * n) (a * d) = divNat n d := by\n  ext; push_cast; exact Rat.divInt_mul_left (mod_cast ha)\n\n"}
{"name":"NNRat.divNat_mul_right","module":"Mathlib.Data.NNRat.Defs","initialProofState":"a : Nat\nha : Ne a 0\nn d : Nat\n⊢ Eq (NNRat.divNat (HMul.hMul n a) (HMul.hMul d a)) (NNRat.divNat n d)","decl":"lemma divNat_mul_right {a : ℕ} (ha : a ≠ 0) (n d : ℕ) : divNat (n * a) (d * a) = divNat n d := by\n  ext; push_cast; exact Rat.divInt_mul_right (mod_cast ha)\n\n"}
{"name":"NNRat.mul_den_eq_num","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\n⊢ Eq (HMul.hMul q ↑q.den) ↑q.num","decl":"@[simp] lemma mul_den_eq_num (q : ℚ≥0) : q * q.den = q.num := by\n  ext\n  push_cast\n  rw [← Int.cast_natCast, ← den_coe, ← Int.cast_natCast q.num, ← num_coe]\n  exact Rat.mul_den_eq_num _\n\n"}
{"name":"NNRat.den_mul_eq_num","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q : NNRat\n⊢ Eq (HMul.hMul (↑q.den) q) ↑q.num","decl":"@[simp] lemma den_mul_eq_num (q : ℚ≥0) : q.den * q = q.num := by rw [mul_comm, mul_den_eq_num]\n\n"}
{"name":"NNRat.add_def","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q r : NNRat\n⊢ Eq (HAdd.hAdd q r) (NNRat.divNat (HAdd.hAdd (HMul.hMul q.num r.den) (HMul.hMul r.num q.den)) (HMul.hMul q.den r.den))","decl":"lemma add_def (q r : ℚ≥0) : q + r = divNat (q.num * r.den + r.num * q.den) (q.den * r.den) := by\n  ext; simp [Rat.add_def', Rat.mkRat_eq_divInt, num_coe, den_coe]\n\n"}
{"name":"NNRat.mul_def","module":"Mathlib.Data.NNRat.Defs","initialProofState":"q r : NNRat\n⊢ Eq (HMul.hMul q r) (NNRat.divNat (HMul.hMul q.num r.num) (HMul.hMul q.den r.den))","decl":"lemma mul_def (q r : ℚ≥0) : q * r = divNat (q.num * r.num) (q.den * r.den) := by\n  ext; simp [Rat.mul_eq_mkRat, Rat.mkRat_eq_divInt, num_coe, den_coe]\n\n"}
{"name":"NNRat.lt_def","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p q : NNRat\n⊢ Iff (LT.lt p q) (LT.lt (HMul.hMul p.num q.den) (HMul.hMul q.num p.den))","decl":"theorem lt_def {p q : ℚ≥0} : p < q ↔ p.num * q.den < q.num * p.den := by\n  rw [← NNRat.coe_lt_coe, Rat.lt_def]; norm_cast\n\n"}
{"name":"NNRat.le_def","module":"Mathlib.Data.NNRat.Defs","initialProofState":"p q : NNRat\n⊢ Iff (LE.le p q) (LE.le (HMul.hMul p.num q.den) (HMul.hMul q.num p.den))","decl":"theorem le_def {p q : ℚ≥0} : p ≤ q ↔ p.num * q.den ≤ q.num * p.den := by\n  rw [← NNRat.coe_le_coe, Rat.le_def]; norm_cast\n\n"}
{"name":"Mathlib.Tactic.Qify.nnratCast_eq","module":"Mathlib.Data.NNRat.Defs","initialProofState":"a b : NNRat\n⊢ Iff (Eq a b) (Eq ↑a ↑b)","decl":"@[qify_simps] lemma nnratCast_eq (a b : ℚ≥0) : a = b ↔ (a : ℚ) = (b : ℚ) := NNRat.coe_inj.symm\n"}
{"name":"Mathlib.Tactic.Qify.nnratCast_le","module":"Mathlib.Data.NNRat.Defs","initialProofState":"a b : NNRat\n⊢ Iff (LE.le a b) (LE.le ↑a ↑b)","decl":"@[qify_simps] lemma nnratCast_le (a b : ℚ≥0) : a ≤ b ↔ (a : ℚ) ≤ (b : ℚ) := NNRat.coe_le_coe.symm\n"}
{"name":"Mathlib.Tactic.Qify.nnratCast_lt","module":"Mathlib.Data.NNRat.Defs","initialProofState":"a b : NNRat\n⊢ Iff (LT.lt a b) (LT.lt ↑a ↑b)","decl":"@[qify_simps] lemma nnratCast_lt (a b : ℚ≥0) : a < b ↔ (a : ℚ) < (b : ℚ) := NNRat.coe_lt_coe.symm\n"}
{"name":"Mathlib.Tactic.Qify.nnratCast_ne","module":"Mathlib.Data.NNRat.Defs","initialProofState":"a b : NNRat\n⊢ Iff (Ne a b) (Ne ↑a ↑b)","decl":"@[qify_simps] lemma nnratCast_ne (a b : ℚ≥0) : a ≠ b ↔ (a : ℚ) ≠ (b : ℚ) := NNRat.ne_iff.symm\n\n"}
