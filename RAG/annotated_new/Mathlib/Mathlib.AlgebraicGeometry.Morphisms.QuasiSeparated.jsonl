{"name":"AlgebraicGeometry.QuasiSeparated.diagonalQuasiCompact","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nself : AlgebraicGeometry.QuasiSeparated f\n‚ä¢ AlgebraicGeometry.QuasiCompact (CategoryTheory.Limits.pullback.diagonal f)","decl":"/-- A morphism is `QuasiSeparated` if diagonal map is quasi-compact. -/\n@[mk_iff]\nclass QuasiSeparated (f : X ‚ü∂ Y) : Prop where\n  /-- A morphism is `QuasiSeparated` if diagonal map is quasi-compact. -/\n  diagonalQuasiCompact : QuasiCompact (pullback.diagonal f) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.quasiSeparated_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n‚ä¢ Iff (AlgebraicGeometry.QuasiSeparated f) (autoParam (AlgebraicGeometry.QuasiCompact (CategoryTheory.Limits.pullback.diagonal f)) _auto‚úù)","decl":"/-- A morphism is `QuasiSeparated` if diagonal map is quasi-compact. -/\n@[mk_iff]\nclass QuasiSeparated (f : X ‚ü∂ Y) : Prop where\n  /-- A morphism is `QuasiSeparated` if diagonal map is quasi-compact. -/\n  diagonalQuasiCompact : QuasiCompact (pullback.diagonal f) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.quasiSeparatedSpace_iff_affine","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\n‚ä¢ Iff (QuasiSeparatedSpace ‚Üë‚ÜëX.toPresheafedSpace) (‚àÄ (U V : ‚ÜëX.affineOpens), IsCompact (Inter.inter ‚Üë‚ÜëU ‚Üë‚ÜëV))","decl":"theorem quasiSeparatedSpace_iff_affine (X : Scheme) :\n    QuasiSeparatedSpace X ‚Üî ‚àÄ U V : X.affineOpens, IsCompact (U ‚à© V : Set X) := by\n  rw [quasiSeparatedSpace_iff]\n  constructor\n  ¬∑ intro H U V; exact H U V U.1.2 U.2.isCompact V.1.2 V.2.isCompact\n  ¬∑ intro H\n    suffices\n      ‚àÄ (U : X.Opens) (_ : IsCompact U.1) (V : X.Opens) (_ : IsCompact V.1),\n        IsCompact (U ‚äì V).1\n      by intro U V hU hU' hV hV'; exact this ‚ü®U, hU‚ü© hU' ‚ü®V, hV‚ü© hV'\n    intro U hU V hV\n    refine compact_open_induction_on V hV ?_ ?_\n    ¬∑ simp\n    ¬∑ intro S _ V hV\n      change IsCompact (U.1 ‚à© (S.1 ‚à™ V.1))\n      rw [Set.inter_union_distrib_left]\n      apply hV.union\n      clear hV\n      refine compact_open_induction_on U hU ?_ ?_\n      ¬∑ simp\n      ¬∑ intro S _ W hW\n        change IsCompact ((S.1 ‚à™ W.1) ‚à© V.1)\n        rw [Set.union_inter_distrib_right]\n        apply hW.union\n        apply H\n\n"}
{"name":"AlgebraicGeometry.quasiCompact_affineProperty_iff_quasiSeparatedSpace","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\n‚ä¢ Iff (AlgebraicGeometry.AffineTargetMorphismProperty.diagonal (fun X x x_1 x => CompactSpace ‚Üë‚ÜëX.toPresheafedSpace) f) (QuasiSeparatedSpace ‚Üë‚ÜëX.toPresheafedSpace)","decl":"theorem quasiCompact_affineProperty_iff_quasiSeparatedSpace {X Y : Scheme} [IsAffine Y]\n    (f : X ‚ü∂ Y) :\n    AffineTargetMorphismProperty.diagonal (fun X _ _ _ ‚Ü¶ CompactSpace X) f ‚Üî\n      QuasiSeparatedSpace X := by\n  delta AffineTargetMorphismProperty.diagonal\n  rw [quasiSeparatedSpace_iff_affine]\n  constructor\n  ¬∑ intro H U V\n    haveI : IsAffine _ := U.2\n    haveI : IsAffine _ := V.2\n    let g : pullback U.1.Œπ V.1.Œπ ‚ü∂ X := pullback.fst _ _ ‚â´ U.1.Œπ\n    -- Porting note: `inferInstance` does not work here\n    have : IsOpenImmersion g := PresheafedSpace.IsOpenImmersion.comp _ _\n    have e := Homeomorph.ofIsEmbedding _ this.base_open.isEmbedding\n    rw [IsOpenImmersion.range_pullback_to_base_of_left] at e\n    erw [Subtype.range_coe, Subtype.range_coe] at e\n    rw [isCompact_iff_compactSpace]\n    exact @Homeomorph.compactSpace _ _ _ _ (H _ _) e\n  ¬∑ introv H h‚ÇÅ h‚ÇÇ\n    let g : pullback f‚ÇÅ f‚ÇÇ ‚ü∂ X := pullback.fst _ _ ‚â´ f‚ÇÅ\n    -- Porting note: `inferInstance` does not work here\n    have : IsOpenImmersion g := PresheafedSpace.IsOpenImmersion.comp _ _\n    have e := Homeomorph.ofIsEmbedding _ this.base_open.isEmbedding\n    rw [IsOpenImmersion.range_pullback_to_base_of_left] at e\n    simp_rw [isCompact_iff_compactSpace] at H\n    exact\n      @Homeomorph.compactSpace _ _ _ _\n        (H ‚ü®‚ü®_, h‚ÇÅ.base_open.isOpen_range‚ü©, isAffineOpen_opensRange _‚ü©\n          ‚ü®‚ü®_, h‚ÇÇ.base_open.isOpen_range‚ü©, isAffineOpen_opensRange _‚ü©)\n        e.symm\n\n"}
{"name":"AlgebraicGeometry.quasiSeparated_eq_diagonal_is_quasiCompact","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"‚ä¢ Eq (@AlgebraicGeometry.QuasiSeparated) (CategoryTheory.MorphismProperty.diagonal @AlgebraicGeometry.QuasiCompact)","decl":"theorem quasiSeparated_eq_diagonal_is_quasiCompact :\n    @QuasiSeparated = MorphismProperty.diagonal @QuasiCompact := by ext; exact quasiSeparated_iff _\n\n"}
{"name":"AlgebraicGeometry.instHasAffinePropertyQuasiSeparatedQuasiSeparatedSpaceŒ±TopologicalSpaceCarrierCommRingCat","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"‚ä¢ AlgebraicGeometry.HasAffineProperty @AlgebraicGeometry.QuasiSeparated fun X x x_1 x => QuasiSeparatedSpace ‚Üë‚ÜëX.toPresheafedSpace","decl":"instance : HasAffineProperty @QuasiSeparated (fun X _ _ _ ‚Ü¶ QuasiSeparatedSpace X) where\n  __ := HasAffineProperty.copy\n    quasiSeparated_eq_diagonal_is_quasiCompact.symm\n    (by ext; exact quasiCompact_affineProperty_iff_quasiSeparatedSpace _)\n\n"}
{"name":"AlgebraicGeometry.quasiSeparatedOfMono","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ AlgebraicGeometry.QuasiSeparated f","decl":"instance (priority := 900) quasiSeparatedOfMono {X Y : Scheme} (f : X ‚ü∂ Y) [Mono f] :\n    QuasiSeparated f where\n\n"}
{"name":"AlgebraicGeometry.quasiSeparated_isStableUnderComposition","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"‚ä¢ CategoryTheory.MorphismProperty.IsStableUnderComposition @AlgebraicGeometry.QuasiSeparated","decl":"instance quasiSeparated_isStableUnderComposition :\n    MorphismProperty.IsStableUnderComposition @QuasiSeparated :=\n  quasiSeparated_eq_diagonal_is_quasiCompact.symm ‚ñ∏ inferInstance\n\n"}
{"name":"AlgebraicGeometry.quasiSeparated_isStableUnderBaseChange","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"‚ä¢ CategoryTheory.MorphismProperty.IsStableUnderBaseChange @AlgebraicGeometry.QuasiSeparated","decl":"instance quasiSeparated_isStableUnderBaseChange :\n    MorphismProperty.IsStableUnderBaseChange @QuasiSeparated :=\n  quasiSeparated_eq_diagonal_is_quasiCompact.symm ‚ñ∏ inferInstance\n\n"}
{"name":"AlgebraicGeometry.quasiSeparatedComp","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : AlgebraicGeometry.QuasiSeparated f\ninst‚úù : AlgebraicGeometry.QuasiSeparated g\n‚ä¢ AlgebraicGeometry.QuasiSeparated (CategoryTheory.CategoryStruct.comp f g)","decl":"instance quasiSeparatedComp {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [QuasiSeparated f]\n    [QuasiSeparated g] : QuasiSeparated (f ‚â´ g) :=\n  MorphismProperty.comp_mem _ f g inferInstance inferInstance\n\n"}
{"name":"AlgebraicGeometry.quasiSeparated_over_affine_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : AlgebraicGeometry.IsAffine Y\n‚ä¢ Iff (AlgebraicGeometry.QuasiSeparated f) (QuasiSeparatedSpace ‚Üë‚ÜëX.toPresheafedSpace)","decl":"theorem quasiSeparated_over_affine_iff {X Y : Scheme} (f : X ‚ü∂ Y) [IsAffine Y] :\n    QuasiSeparated f ‚Üî QuasiSeparatedSpace X := by\n  rw [HasAffineProperty.iff_of_isAffine (P := @QuasiSeparated)]\n\n"}
{"name":"AlgebraicGeometry.quasiSeparatedSpace_iff_quasiSeparated","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\n‚ä¢ Iff (QuasiSeparatedSpace ‚Üë‚ÜëX.toPresheafedSpace) (AlgebraicGeometry.QuasiSeparated (CategoryTheory.Limits.terminal.from X))","decl":"theorem quasiSeparatedSpace_iff_quasiSeparated (X : Scheme) :\n    QuasiSeparatedSpace X ‚Üî QuasiSeparated (terminal.from X) :=\n  (quasiSeparated_over_affine_iff _).symm\n\n"}
{"name":"AlgebraicGeometry.instQuasiSeparatedFstScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\ninst‚úù : AlgebraicGeometry.QuasiSeparated g\n‚ä¢ AlgebraicGeometry.QuasiSeparated (CategoryTheory.Limits.pullback.fst f g)","decl":"instance {X Y S : Scheme} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) [QuasiSeparated g] :\n    QuasiSeparated (pullback.fst f g) :=\n  MorphismProperty.pullback_fst f g inferInstance\n\n"}
{"name":"AlgebraicGeometry.instQuasiSeparatedSndScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\ninst‚úù : AlgebraicGeometry.QuasiSeparated f\n‚ä¢ AlgebraicGeometry.QuasiSeparated (CategoryTheory.Limits.pullback.snd f g)","decl":"instance {X Y S : Scheme} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) [QuasiSeparated f] :\n    QuasiSeparated (pullback.snd f g) :=\n  MorphismProperty.pullback_snd f g inferInstance\n\n"}
{"name":"AlgebraicGeometry.quasiSeparatedSpace_of_quasiSeparated","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhY : QuasiSeparatedSpace ‚Üë‚ÜëY.toPresheafedSpace\ninst‚úù : AlgebraicGeometry.QuasiSeparated f\n‚ä¢ QuasiSeparatedSpace ‚Üë‚ÜëX.toPresheafedSpace","decl":"theorem quasiSeparatedSpace_of_quasiSeparated {X Y : Scheme} (f : X ‚ü∂ Y)\n    [hY : QuasiSeparatedSpace Y] [QuasiSeparated f] : QuasiSeparatedSpace X := by\n  rw [quasiSeparatedSpace_iff_quasiSeparated] at hY ‚ä¢\n  rw [‚Üê terminalIsTerminal.hom_ext (f ‚â´ terminal.from Y) (terminal.from X)]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.quasiSeparatedSpace_of_isAffine","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\n‚ä¢ QuasiSeparatedSpace ‚Üë‚ÜëX.toPresheafedSpace","decl":"instance quasiSeparatedSpace_of_isAffine (X : Scheme) [IsAffine X] :\n    QuasiSeparatedSpace X := by\n  constructor\n  intro U V hU hU' hV hV'\n  obtain ‚ü®s, hs, e‚ü© := (isCompactOpen_iff_eq_basicOpen_union _).mp ‚ü®hU', hU‚ü©\n  obtain ‚ü®s', hs', e'‚ü© := (isCompactOpen_iff_eq_basicOpen_union _).mp ‚ü®hV', hV‚ü©\n  rw [e, e', Set.iUnion‚ÇÇ_inter]\n  simp_rw [Set.inter_iUnion‚ÇÇ]\n  apply hs.isCompact_biUnion\n  intro i _\n  apply hs'.isCompact_biUnion\n  intro i' _\n  change IsCompact (X.basicOpen i ‚äì X.basicOpen i').1\n  rw [‚Üê Scheme.basicOpen_mul]\n  exact ((isAffineOpen_top _).basicOpen _).isCompact\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.isQuasiSeparated","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\n‚ä¢ IsQuasiSeparated ‚ÜëU","decl":"theorem IsAffineOpen.isQuasiSeparated {X : Scheme} {U : X.Opens} (hU : IsAffineOpen U) :\n    IsQuasiSeparated (U : Set X) := by\n  rw [isQuasiSeparated_iff_quasiSeparatedSpace]\n  exacts [@AlgebraicGeometry.quasiSeparatedSpace_of_isAffine _ hU, U.isOpen]\n\n"}
{"name":"AlgebraicGeometry.quasiSeparatedSpace_iff_quasiCompact_prod_lift","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\n‚ä¢ Iff (QuasiSeparatedSpace ‚Üë‚ÜëX.toPresheafedSpace) (AlgebraicGeometry.QuasiCompact (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X)))","decl":"lemma quasiSeparatedSpace_iff_quasiCompact_prod_lift :\n    QuasiSeparatedSpace X ‚Üî QuasiCompact (prod.lift (ùüô X) (ùüô X)) := by\n  rw [‚Üê MorphismProperty.cancel_right_of_respectsIso @QuasiCompact _ (prodIsoPullback X X).hom,\n    ‚Üê HasAffineProperty.iff_of_isAffine (f := terminal.from X) (P := @QuasiSeparated),\n    quasiSeparated_iff]\n  congr!\n  ext : 1 <;> simp\n\n"}
{"name":"AlgebraicGeometry.instQuasiCompactLiftSchemeIdOfQuasiSeparatedSpaceŒ±TopologicalSpaceCarrierCommRingCat","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : QuasiSeparatedSpace ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ AlgebraicGeometry.QuasiCompact (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X))","decl":"instance [QuasiSeparatedSpace X] : QuasiCompact (prod.lift (ùüô X) (ùüô X)) := by\n  rwa [‚Üê quasiSeparatedSpace_iff_quasiCompact_prod_lift]\n\n"}
{"name":"AlgebraicGeometry.instQuasiCompactŒπSchemeOfQuasiSeparatedSpaceŒ±TopologicalSpaceCarrierCommRingCat","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù : QuasiSeparatedSpace ‚Üë‚ÜëY.toPresheafedSpace\nf g : Quiver.Hom X Y\n‚ä¢ AlgebraicGeometry.QuasiCompact (CategoryTheory.Limits.equalizer.Œπ f g)","decl":"instance [QuasiSeparatedSpace Y] (f g : X ‚ü∂ Y) : QuasiCompact (equalizer.Œπ f g) :=\n  MorphismProperty.of_isPullback (P := @QuasiCompact)\n    (isPullback_equalizer_prod f g).flip inferInstance\n\n"}
{"name":"AlgebraicGeometry.instCompactSpaceŒ±TopologicalSpaceCarrierCommRingCatEqualizerSchemeOfQuasiSeparatedSpace","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù¬π : CompactSpace ‚Üë‚ÜëX.toPresheafedSpace\ninst‚úù : QuasiSeparatedSpace ‚Üë‚ÜëY.toPresheafedSpace\nf g : Quiver.Hom X Y\n‚ä¢ CompactSpace ‚Üë‚Üë(CategoryTheory.Limits.equalizer f g).toPresheafedSpace","decl":"instance [CompactSpace X] [QuasiSeparatedSpace Y] (f g : X ‚ü∂ Y) :\n    CompactSpace (equalizer f g).carrier := by\n  constructor\n  simpa using QuasiCompact.isCompact_preimage (f := equalizer.Œπ f g) _ isOpen_univ isCompact_univ\n\n"}
{"name":"AlgebraicGeometry.QuasiSeparated.of_comp","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù : AlgebraicGeometry.QuasiSeparated (CategoryTheory.CategoryStruct.comp f g)\n‚ä¢ AlgebraicGeometry.QuasiSeparated f","decl":"theorem QuasiSeparated.of_comp {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [QuasiSeparated (f ‚â´ g)] :\n    QuasiSeparated f := by\n  let ùí∞ := (Z.affineCover.pullbackCover g).bind fun x => Scheme.affineCover _\n  have (i) : IsAffine (ùí∞.obj i) := by dsimp [ùí∞]; infer_instance\n  apply HasAffineProperty.of_openCover\n    ((Z.affineCover.pullbackCover g).bind fun x => Scheme.affineCover _)\n  rintro ‚ü®i, j‚ü©; dsimp at i j\n  refine @quasiSeparatedSpace_of_quasiSeparated _ _ ?_\n    (HasAffineProperty.of_isPullback (.of_hasPullback _ (Z.affineCover.map i)) ‚Äπ_‚Ä∫) ?_\n  ¬∑ exact pullback.map _ _ _ _ (ùüô _) _ _ (by simp) (Category.comp_id _) ‚â´\n      (pullbackRightPullbackFstIso g (Z.affineCover.map i) f).hom\n  ¬∑ exact inferInstance\n\n"}
{"name":"AlgebraicGeometry.exists_eq_pow_mul_of_isAffineOpen","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nf : ‚Üë(X.presheaf.obj { unop := U })\nx : ‚Üë(X.presheaf.obj { unop := X.basicOpen f })\n‚ä¢ Exists fun n => Exists fun y => Eq (TopCat.Presheaf.restrictOpen y (X.basicOpen f) ‚ãØ) (HMul.hMul (HPow.hPow (TopCat.Presheaf.restrictOpen f (X.basicOpen f) ‚ãØ) n) x)","decl":"theorem exists_eq_pow_mul_of_isAffineOpen (X : Scheme) (U : X.Opens) (hU : IsAffineOpen U)\n    (f : Œì(X, U)) (x : Œì(X, X.basicOpen f)) :\n    ‚àÉ (n : ‚Ñï) (y : Œì(X, U)), y |_ X.basicOpen f = (f |_ X.basicOpen f) ^ n * x := by\n  have := (hU.isLocalization_basicOpen f).2\n  obtain ‚ü®‚ü®y, _, n, rfl‚ü©, d‚ü© := this x\n  use n, y\n  simpa [mul_comm x] using d.symm\n\n"}
{"name":"AlgebraicGeometry.exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux_aux","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : TopCat\nF : TopCat.Presheaf CommRingCat X\nU‚ÇÅ U‚ÇÇ U‚ÇÉ U‚ÇÑ U‚ÇÖ U‚ÇÜ U‚Çá : TopologicalSpace.Opens ‚ÜëX\nn‚ÇÅ n‚ÇÇ : Nat\ny‚ÇÅ : ‚Üë(F.obj { unop := U‚ÇÅ })\ny‚ÇÇ : ‚Üë(F.obj { unop := U‚ÇÇ })\nf : ‚Üë(F.obj { unop := Max.max U‚ÇÅ U‚ÇÇ })\nx : ‚Üë(F.obj { unop := U‚ÇÉ })\nh‚ÇÑ‚ÇÅ : LE.le U‚ÇÑ U‚ÇÅ\nh‚ÇÑ‚ÇÇ : LE.le U‚ÇÑ U‚ÇÇ\nh‚ÇÖ‚ÇÅ : LE.le U‚ÇÖ U‚ÇÅ\nh‚ÇÖ‚ÇÉ : LE.le U‚ÇÖ U‚ÇÉ\nh‚ÇÜ‚ÇÇ : LE.le U‚ÇÜ U‚ÇÇ\nh‚ÇÜ‚ÇÉ : LE.le U‚ÇÜ U‚ÇÉ\nh‚Çá‚ÇÑ : LE.le U‚Çá U‚ÇÑ\nh‚Çá‚ÇÖ : LE.le U‚Çá U‚ÇÖ\nh‚Çá‚ÇÜ : LE.le U‚Çá U‚ÇÜ\ne‚ÇÅ : Eq (TopCat.Presheaf.restrictOpen y‚ÇÅ U‚ÇÖ ‚ãØ) (HMul.hMul (HPow.hPow (TopCat.Presheaf.restrictOpen (TopCat.Presheaf.restrictOpen f U‚ÇÅ ‚ãØ) U‚ÇÖ ‚ãØ) n‚ÇÅ) (TopCat.Presheaf.restrictOpen x U‚ÇÖ ‚ãØ))\ne‚ÇÇ : Eq (TopCat.Presheaf.restrictOpen y‚ÇÇ U‚ÇÜ ‚ãØ) (HMul.hMul (HPow.hPow (TopCat.Presheaf.restrictOpen (TopCat.Presheaf.restrictOpen f U‚ÇÇ ‚ãØ) U‚ÇÜ ‚ãØ) n‚ÇÇ) (TopCat.Presheaf.restrictOpen x U‚ÇÜ ‚ãØ))\n‚ä¢ Eq (TopCat.Presheaf.restrictOpen (TopCat.Presheaf.restrictOpen (HMul.hMul (HPow.hPow (TopCat.Presheaf.restrictOpen f U‚ÇÅ ‚ãØ) n‚ÇÇ) y‚ÇÅ) U‚ÇÑ ‚ãØ) U‚Çá ‚ãØ) (TopCat.Presheaf.restrictOpen (TopCat.Presheaf.restrictOpen (HMul.hMul (HPow.hPow (TopCat.Presheaf.restrictOpen f U‚ÇÇ ‚ãØ) n‚ÇÅ) y‚ÇÇ) U‚ÇÑ ‚ãØ) U‚Çá ‚ãØ)","decl":"theorem exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux_aux {X : TopCat}\n    (F : X.Presheaf CommRingCat) {U‚ÇÅ U‚ÇÇ U‚ÇÉ U‚ÇÑ U‚ÇÖ U‚ÇÜ U‚Çá : Opens X} {n‚ÇÅ n‚ÇÇ : ‚Ñï}\n    {y‚ÇÅ : F.obj (op U‚ÇÅ)} {y‚ÇÇ : F.obj (op U‚ÇÇ)} {f : F.obj (op <| U‚ÇÅ ‚äî U‚ÇÇ)}\n    {x : F.obj (op U‚ÇÉ)} (h‚ÇÑ‚ÇÅ : U‚ÇÑ ‚â§ U‚ÇÅ) (h‚ÇÑ‚ÇÇ : U‚ÇÑ ‚â§ U‚ÇÇ) (h‚ÇÖ‚ÇÅ : U‚ÇÖ ‚â§ U‚ÇÅ) (h‚ÇÖ‚ÇÉ : U‚ÇÖ ‚â§ U‚ÇÉ)\n    (h‚ÇÜ‚ÇÇ : U‚ÇÜ ‚â§ U‚ÇÇ) (h‚ÇÜ‚ÇÉ : U‚ÇÜ ‚â§ U‚ÇÉ) (h‚Çá‚ÇÑ : U‚Çá ‚â§ U‚ÇÑ) (h‚Çá‚ÇÖ : U‚Çá ‚â§ U‚ÇÖ) (h‚Çá‚ÇÜ : U‚Çá ‚â§ U‚ÇÜ)\n    (e‚ÇÅ : y‚ÇÅ |_ U‚ÇÖ = (f |_ U‚ÇÅ |_ U‚ÇÖ) ^ n‚ÇÅ * x |_ U‚ÇÖ)\n    (e‚ÇÇ : y‚ÇÇ |_ U‚ÇÜ = (f |_ U‚ÇÇ |_ U‚ÇÜ) ^ n‚ÇÇ * x |_ U‚ÇÜ) :\n    (((f |_ U‚ÇÅ) ^ n‚ÇÇ * y‚ÇÅ) |_ U‚ÇÑ) |_ U‚Çá = (((f |_ U‚ÇÇ) ^ n‚ÇÅ * y‚ÇÇ) |_ U‚ÇÑ) |_ U‚Çá := by\n  apply_fun (fun x : F.obj (op U‚ÇÖ) ‚Ü¶ x |_ U‚Çá) at e‚ÇÅ\n  apply_fun (fun x : F.obj (op U‚ÇÜ) ‚Ü¶ x |_ U‚Çá) at e‚ÇÇ\n  dsimp only [TopCat.Presheaf.restrictOpenCommRingCat_apply] at e‚ÇÅ e‚ÇÇ ‚ä¢\n  simp only [map_mul, map_pow, ‚Üê op_comp, ‚Üê F.map_comp, homOfLE_comp, ‚Üê CommRingCat.comp_apply]\n    at e‚ÇÅ e‚ÇÇ ‚ä¢\n  rw [e‚ÇÅ, e‚ÇÇ, mul_left_comm]\n\n"}
{"name":"AlgebraicGeometry.exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\nS : ‚ÜëX.affineOpens\nU‚ÇÅ U‚ÇÇ : X.Opens\nn‚ÇÅ n‚ÇÇ : Nat\ny‚ÇÅ : ‚Üë(X.presheaf.obj { unop := U‚ÇÅ })\ny‚ÇÇ : ‚Üë(X.presheaf.obj { unop := U‚ÇÇ })\nf : ‚Üë(X.presheaf.obj { unop := Max.max U‚ÇÅ U‚ÇÇ })\nx : ‚Üë(X.presheaf.obj { unop := X.basicOpen f })\nh‚ÇÅ : LE.le (‚ÜëS) U‚ÇÅ\nh‚ÇÇ : LE.le (‚ÜëS) U‚ÇÇ\ne‚ÇÅ : Eq (TopCat.Presheaf.restrictOpen y‚ÇÅ (X.basicOpen (TopCat.Presheaf.restrictOpen f U‚ÇÅ ‚ãØ)) ‚ãØ) (HMul.hMul (HPow.hPow (TopCat.Presheaf.restrictOpen (TopCat.Presheaf.restrictOpen f U‚ÇÅ ‚ãØ) (X.basicOpen (TopCat.Presheaf.restrictOpen f U‚ÇÅ ‚ãØ)) ‚ãØ) n‚ÇÅ) (TopCat.Presheaf.restrictOpen x (X.basicOpen (TopCat.Presheaf.restrictOpen f U‚ÇÅ ‚ãØ)) ‚ãØ))\ne‚ÇÇ : Eq (TopCat.Presheaf.restrictOpen y‚ÇÇ (X.basicOpen (TopCat.Presheaf.restrictOpen f U‚ÇÇ ‚ãØ)) ‚ãØ) (HMul.hMul (HPow.hPow (TopCat.Presheaf.restrictOpen (TopCat.Presheaf.restrictOpen f U‚ÇÇ ‚ãØ) (X.basicOpen (TopCat.Presheaf.restrictOpen f U‚ÇÇ ‚ãØ)) ‚ãØ) n‚ÇÇ) (TopCat.Presheaf.restrictOpen x (X.basicOpen (TopCat.Presheaf.restrictOpen f U‚ÇÇ ‚ãØ)) ‚ãØ))\n‚ä¢ Exists fun n => ‚àÄ (m : Nat), LE.le n m ‚Üí Eq (TopCat.Presheaf.restrictOpen (HMul.hMul (HPow.hPow (TopCat.Presheaf.restrictOpen f U‚ÇÅ ‚ãØ) (HAdd.hAdd m n‚ÇÇ)) y‚ÇÅ) ‚ÜëS ‚ãØ) (TopCat.Presheaf.restrictOpen (HMul.hMul (HPow.hPow (TopCat.Presheaf.restrictOpen f U‚ÇÇ ‚ãØ) (HAdd.hAdd m n‚ÇÅ)) y‚ÇÇ) ‚ÜëS ‚ãØ)","decl":"theorem exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux (X : Scheme)\n    (S : X.affineOpens) (U‚ÇÅ U‚ÇÇ : X.Opens) {n‚ÇÅ n‚ÇÇ : ‚Ñï} {y‚ÇÅ : Œì(X, U‚ÇÅ)}\n    {y‚ÇÇ : Œì(X, U‚ÇÇ)} {f : Œì(X, U‚ÇÅ ‚äî U‚ÇÇ)}\n    {x : Œì(X, X.basicOpen f)} (h‚ÇÅ : S.1 ‚â§ U‚ÇÅ) (h‚ÇÇ : S.1 ‚â§ U‚ÇÇ)\n    (e‚ÇÅ : y‚ÇÅ |_ X.basicOpen (f |_ U‚ÇÅ) =\n      ((f |_ U‚ÇÅ |_ X.basicOpen _) ^ n‚ÇÅ) * x |_ X.basicOpen _)\n    (e‚ÇÇ : y‚ÇÇ |_ X.basicOpen (f |_ U‚ÇÇ) =\n      ((f |_ U‚ÇÇ |_ X.basicOpen _) ^ n‚ÇÇ) * x |_ X.basicOpen _) :\n    ‚àÉ n : ‚Ñï, ‚àÄ m, n ‚â§ m ‚Üí\n      ((f |_ U‚ÇÅ) ^ (m + n‚ÇÇ) * y‚ÇÅ) |_ S.1 = ((f |_ U‚ÇÇ) ^ (m + n‚ÇÅ) * y‚ÇÇ) |_ S.1 := by\n  obtain ‚ü®‚ü®_, n, rfl‚ü©, e‚ü© :=\n    (@IsLocalization.eq_iff_exists _ _ _ _ _ _\n      (S.2.isLocalization_basicOpen (f |_ S.1))\n        (((f |_ U‚ÇÅ) ^ n‚ÇÇ * y‚ÇÅ) |_ S.1)\n        (((f |_ U‚ÇÇ) ^ n‚ÇÅ * y‚ÇÇ) |_ S.1)).mp <| by\n    apply exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux_aux (e‚ÇÅ := e‚ÇÅ) (e‚ÇÇ := e‚ÇÇ)\n    ¬∑ show X.basicOpen _ ‚â§ _\n      simp only [TopCat.Presheaf.restrictOpenCommRingCat_apply, Scheme.basicOpen_res]\n      exact inf_le_inf h‚ÇÅ le_rfl\n    ¬∑ show X.basicOpen _ ‚â§ _\n      simp only [TopCat.Presheaf.restrictOpenCommRingCat_apply, Scheme.basicOpen_res]\n      exact inf_le_inf h‚ÇÇ le_rfl\n  use n\n  intros m hm\n  rw [‚Üê tsub_add_cancel_of_le hm]\n  simp only [TopCat.Presheaf.restrictOpenCommRingCat_apply,\n    pow_add, map_pow, map_mul, mul_assoc, ‚Üê Functor.map_comp, ‚Üê op_comp, homOfLE_comp,\n    Subtype.coe_mk, ‚Üê CommRingCat.comp_apply] at e ‚ä¢\n  rw [e]\n\n"}
{"name":"AlgebraicGeometry.exists_eq_pow_mul_of_isCompact_of_isQuasiSeparated","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : IsCompact U.carrier\nhU' : IsQuasiSeparated U.carrier\nf : ‚Üë(X.presheaf.obj { unop := U })\nx : ‚Üë(X.presheaf.obj { unop := X.basicOpen f })\n‚ä¢ Exists fun n => Exists fun y => Eq (TopCat.Presheaf.restrictOpen y (X.basicOpen f) ‚ãØ) (HMul.hMul (HPow.hPow (TopCat.Presheaf.restrictOpen f (X.basicOpen f) ‚ãØ) n) x)","decl":"theorem exists_eq_pow_mul_of_isCompact_of_isQuasiSeparated (X : Scheme.{u}) (U : X.Opens)\n    (hU : IsCompact U.1) (hU' : IsQuasiSeparated U.1) (f : Œì(X, U)) (x : Œì(X, X.basicOpen f)) :\n    ‚àÉ (n : ‚Ñï) (y : Œì(X, U)), y |_ X.basicOpen f = (f |_ X.basicOpen f) ^ n * x := by\n  dsimp only [TopCat.Presheaf.restrictOpenCommRingCat_apply]\n  revert hU' f x\n  refine compact_open_induction_on U hU ?_ ?_\n  ¬∑ intro _ f x\n    use 0, f\n    refine @Subsingleton.elim _\n      (CommRingCat.subsingleton_of_isTerminal (X.sheaf.isTerminalOfEqEmpty ?_)) _ _\n    rw [eq_bot_iff]\n    exact X.basicOpen_le f\n  ¬∑ -- Given `f : ùí™(S ‚à™ U), x : ùí™(X_f)`, we need to show that `f ^ n * x` is the restriction of\n    -- some `y : ùí™(S ‚à™ U)` for some `n : ‚Ñï`.\n    intro S hS U hU hSU f x\n    -- We know that such `y‚ÇÅ, n‚ÇÅ` exists on `S` by the induction hypothesis.\n    obtain ‚ü®n‚ÇÅ, y‚ÇÅ, hy‚ÇÅ‚ü© :=\n      hU (hSU.of_subset Set.subset_union_left) (X.presheaf.map (homOfLE le_sup_left).op f)\n        (X.presheaf.map (homOfLE _).op x)\n    -- ¬∑ rw [X.basicOpen_res]; exact inf_le_right\n    -- We know that such `y‚ÇÇ, n‚ÇÇ` exists on `U` since `U` is affine.\n    obtain ‚ü®n‚ÇÇ, y‚ÇÇ, hy‚ÇÇ‚ü© :=\n      exists_eq_pow_mul_of_isAffineOpen X _ U.2 (X.presheaf.map (homOfLE le_sup_right).op f)\n        (X.presheaf.map (homOfLE _).op x)\n    dsimp only [TopCat.Presheaf.restrictOpenCommRingCat_apply] at hy‚ÇÇ\n    -- swap; ¬∑ rw [X.basicOpen_res]; exact inf_le_right\n    -- Since `S ‚à™ U` is quasi-separated, `S ‚à© U` can be covered by finite affine opens.\n    obtain ‚ü®s, hs', hs‚ü© :=\n      (isCompactOpen_iff_eq_finset_affine_union _).mp\n        ‚ü®hSU _ _ Set.subset_union_left S.2 hS Set.subset_union_right U.1.2\n            U.2.isCompact,\n          (S ‚äì U.1).2‚ü©\n    haveI := hs'.to_subtype\n    cases nonempty_fintype s\n    replace hs : S ‚äì U.1 = iSup fun i : s => (i : X.Opens) := by ext1; simpa using hs\n    have hs‚ÇÅ : ‚àÄ i : s, i.1.1 ‚â§ S := by\n      intro i; change (i : X.Opens) ‚â§ S\n      refine le_trans ?_ (inf_le_left (b := U.1))\n      rw [hs]\n      -- Porting note: have to add argument explicitly\n      exact @le_iSup X.Opens s _ (fun (i : s) => (i : X.Opens)) i\n    have hs‚ÇÇ : ‚àÄ i : s, i.1.1 ‚â§ U.1 := by\n      intro i; change (i : X.Opens) ‚â§ U\n      refine le_trans ?_ (inf_le_right (a := S))\n      rw [hs]\n      -- Porting note: have to add argument explicitly\n      exact @le_iSup X.Opens s _ (fun (i : s) => (i : X.Opens)) i\n    -- On each affine open in the intersection, we have `f ^ (n + n‚ÇÇ) * y‚ÇÅ = f ^ (n + n‚ÇÅ) * y‚ÇÇ`\n    -- for some `n` since `f ^ n‚ÇÇ * y‚ÇÅ = f ^ (n‚ÇÅ + n‚ÇÇ) * x = f ^ n‚ÇÅ * y‚ÇÇ` on `X_f`.\n    have := fun i ‚Ü¶ exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux\n      X i.1 S U (hs‚ÇÅ i) (hs‚ÇÇ i) hy‚ÇÅ hy‚ÇÇ\n    choose n hn using this\n    -- We can thus choose a big enough `n` such that `f ^ (n + n‚ÇÇ) * y‚ÇÅ = f ^ (n + n‚ÇÅ) * y‚ÇÇ`\n    -- on `S ‚à© U`.\n    have :\n      X.presheaf.map (homOfLE <| inf_le_left).op\n          (X.presheaf.map (homOfLE le_sup_left).op f ^ (Finset.univ.sup n + n‚ÇÇ) * y‚ÇÅ) =\n        X.presheaf.map (homOfLE <| inf_le_right).op\n          (X.presheaf.map (homOfLE le_sup_right).op f ^ (Finset.univ.sup n + n‚ÇÅ) * y‚ÇÇ) := by\n      fapply X.sheaf.eq_of_locally_eq' fun i : s => i.1.1\n      ¬∑ refine fun i => homOfLE ?_; rw [hs]\n        -- Porting note: have to add argument explicitly\n        exact @le_iSup X.Opens s _ (fun (i : s) => (i : X.Opens)) i\n      ¬∑ exact le_of_eq hs\n      ¬∑ intro i\n        -- This unfolds `X.sheaf` and ensures we use `CommRingCat.hom` to apply the morphism\n        show (X.presheaf.map _) _ = (X.presheaf.map _) _\n        simp only [‚Üê CommRingCat.comp_apply, ‚Üê Functor.map_comp, ‚Üê op_comp]\n        apply hn\n        exact Finset.le_sup (Finset.mem_univ _)\n    use Finset.univ.sup n + n‚ÇÅ + n‚ÇÇ\n    -- By the sheaf condition, since `f ^ (n + n‚ÇÇ) * y‚ÇÅ = f ^ (n + n‚ÇÅ) * y‚ÇÇ`, it can be glued into\n    -- the desired section on `S ‚à™ U`.\n    use (X.sheaf.objSupIsoProdEqLocus S U.1).inv ‚ü®‚ü®_ * _, _ * _‚ü©, this‚ü©\n    refine (X.sheaf.objSupIsoProdEqLocus_inv_eq_iff _ _ _ (X.basicOpen_res _\n      (homOfLE le_sup_left).op) (X.basicOpen_res _ (homOfLE le_sup_right).op)).mpr ‚ü®?_, ?_‚ü©\n    ¬∑ -- This unfolds `X.sheaf` and ensures we use `CommRingCat.hom` to apply the morphism\n      show (X.presheaf.map _) _ = (X.presheaf.map _) _\n      rw [add_assoc, add_comm n‚ÇÅ]\n      simp only [pow_add, map_pow, map_mul, hy‚ÇÅ, ‚Üê CommRingCat.comp_apply, ‚Üê mul_assoc,\n        ‚Üê Functor.map_comp, ‚Üê op_comp, homOfLE_comp]\n    ¬∑ -- This unfolds `X.sheaf` and ensures we use `CommRingCat.hom` to apply the morphism\n      show (X.presheaf.map _) _ = (X.presheaf.map _) _\n      simp only [pow_add, map_pow, map_mul, hy‚ÇÇ, ‚Üê CommRingCat.comp_apply, ‚Üê mul_assoc,\n        ‚Üê Functor.map_comp, ‚Üê op_comp, homOfLE_comp]\n\n"}
{"name":"AlgebraicGeometry.is_localization_basicOpen_of_qcqs","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : IsCompact U.carrier\nhU' : IsQuasiSeparated U.carrier\nf : ‚Üë(X.presheaf.obj { unop := U })\n‚ä¢ IsLocalization.Away f ‚Üë(X.presheaf.obj { unop := X.basicOpen f })","decl":"/-- If `U` is qcqs, then `Œì(X, D(f)) ‚âÉ Œì(X, U)_f` for every `f : Œì(X, U)`.\nThis is known as the **Qcqs lemma** in [R. Vakil, *The rising sea*][RisingSea]. -/\ntheorem is_localization_basicOpen_of_qcqs {X : Scheme} {U : X.Opens} (hU : IsCompact U.1)\n    (hU' : IsQuasiSeparated U.1) (f : Œì(X, U)) :\n    IsLocalization.Away f (Œì(X, X.basicOpen f)) := by\n  constructor\n  ¬∑ rintro ‚ü®_, n, rfl‚ü©\n    simp only [map_pow, Subtype.coe_mk, RingHom.algebraMap_toAlgebra]\n    exact IsUnit.pow _ (RingedSpace.isUnit_res_basicOpen _ f)\n  ¬∑ intro z\n    obtain ‚ü®n, y, e‚ü© := exists_eq_pow_mul_of_isCompact_of_isQuasiSeparated X U hU hU' f z\n    refine ‚ü®‚ü®y, _, n, rfl‚ü©, ?_‚ü©\n    simpa only [map_pow, Subtype.coe_mk, RingHom.algebraMap_toAlgebra, mul_comm z] using e.symm\n  ¬∑ intro x y\n    rw [‚Üê sub_eq_zero, ‚Üê map_sub, RingHom.algebraMap_toAlgebra]\n    simp_rw [‚Üê @sub_eq_zero _ _ (_ * x) (_ * y), ‚Üê mul_sub]\n    generalize x - y = z\n    intro H\n    obtain ‚ü®n, e‚ü© := exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isCompact X hU _ _ H\n    refine ‚ü®‚ü®_, n, rfl‚ü©, ?_‚ü©\n    simpa [mul_comm z] using e\n\n"}
{"name":"AlgebraicGeometry.exists_of_res_eq_of_qcqs","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\nU : TopologicalSpace.Opens ‚Üë‚ÜëX.toPresheafedSpace\nhU : IsCompact U.carrier\nhU' : IsQuasiSeparated U.carrier\nf g s : ‚Üë(X.presheaf.obj { unop := U })\nhfg : Eq (TopCat.Presheaf.restrictOpen f (X.basicOpen s) ‚ãØ) (TopCat.Presheaf.restrictOpen g (X.basicOpen s) ‚ãØ)\n‚ä¢ Exists fun n => Eq (HMul.hMul (HPow.hPow s n) f) (HMul.hMul (HPow.hPow s n) g)","decl":"lemma exists_of_res_eq_of_qcqs {X : Scheme.{u}} {U : TopologicalSpace.Opens X}\n    (hU : IsCompact U.carrier) (hU' : IsQuasiSeparated U.carrier)\n    {f g s : Œì(X, U)} (hfg : f |_ X.basicOpen s = g |_ X.basicOpen s) :\n    ‚àÉ n, s ^ n * f = s ^ n * g := by\n  obtain ‚ü®n, hc‚ü© := (is_localization_basicOpen_of_qcqs hU hU' s).exists_of_eq s hfg\n  use n\n\n"}
{"name":"AlgebraicGeometry.exists_of_res_eq_of_qcqs_of_top","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù¬π : CompactSpace ‚Üë‚ÜëX.toPresheafedSpace\ninst‚úù : QuasiSeparatedSpace ‚Üë‚ÜëX.toPresheafedSpace\nf g s : ‚Üë(X.presheaf.obj { unop := Top.top })\nhfg : Eq (TopCat.Presheaf.restrictOpen f (X.basicOpen s) ‚ãØ) (TopCat.Presheaf.restrictOpen g (X.basicOpen s) ‚ãØ)\n‚ä¢ Exists fun n => Eq (HMul.hMul (HPow.hPow s n) f) (HMul.hMul (HPow.hPow s n) g)","decl":"lemma exists_of_res_eq_of_qcqs_of_top {X : Scheme.{u}} [CompactSpace X] [QuasiSeparatedSpace X]\n    {f g s : Œì(X, ‚ä§)} (hfg : f |_ X.basicOpen s = g |_ X.basicOpen s) :\n    ‚àÉ n, s ^ n * f = s ^ n * g :=\n  exists_of_res_eq_of_qcqs (U := ‚ä§) CompactSpace.isCompact_univ isQuasiSeparated_univ hfg\n\n"}
{"name":"AlgebraicGeometry.exists_of_res_zero_of_qcqs","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\nU : TopologicalSpace.Opens ‚Üë‚ÜëX.toPresheafedSpace\nhU : IsCompact U.carrier\nhU' : IsQuasiSeparated U.carrier\nf s : ‚Üë(X.presheaf.obj { unop := U })\nhf : Eq (TopCat.Presheaf.restrictOpen f (X.basicOpen s) ‚ãØ) 0\n‚ä¢ Exists fun n => Eq (HMul.hMul (HPow.hPow s n) f) 0","decl":"lemma exists_of_res_zero_of_qcqs {X : Scheme.{u}} {U : TopologicalSpace.Opens X}\n    (hU : IsCompact U.carrier) (hU' : IsQuasiSeparated U.carrier)\n    {f s : Œì(X, U)} (hf : f |_ X.basicOpen s = 0) :\n    ‚àÉ n, s ^ n * f = 0 := by\n  suffices h : ‚àÉ n, s ^ n * f = s ^ n * 0 by\n    simpa using h\n  apply exists_of_res_eq_of_qcqs hU hU'\n  simpa\n\n"}
{"name":"AlgebraicGeometry.exists_of_res_zero_of_qcqs_of_top","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù¬π : CompactSpace ‚Üë‚ÜëX.toPresheafedSpace\ninst‚úù : QuasiSeparatedSpace ‚Üë‚ÜëX.toPresheafedSpace\nf s : ‚Üë(X.presheaf.obj { unop := Top.top })\nhf : Eq (TopCat.Presheaf.restrictOpen f (X.basicOpen s) ‚ãØ) 0\n‚ä¢ Exists fun n => Eq (HMul.hMul (HPow.hPow s n) f) 0","decl":"lemma exists_of_res_zero_of_qcqs_of_top {X : Scheme} [CompactSpace X] [QuasiSeparatedSpace X]\n    {f s : Œì(X, ‚ä§)} (hf : f |_ X.basicOpen s = 0) :\n    ‚àÉ n, s ^ n * f = 0 :=\n  exists_of_res_zero_of_qcqs (U := ‚ä§) CompactSpace.isCompact_univ isQuasiSeparated_univ hf\n\n"}
{"name":"AlgebraicGeometry.isIso_ŒìSpec_adjunction_unit_app_basicOpen","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù¬π : CompactSpace ‚Üë‚ÜëX.toPresheafedSpace\ninst‚úù : QuasiSeparatedSpace ‚Üë‚ÜëX.toPresheafedSpace\nf : ‚Üë(X.presheaf.obj { unop := Top.top })\n‚ä¢ CategoryTheory.IsIso ((AlgebraicGeometry.ŒìSpec.adjunction.unit.app X).c.app { unop := PrimeSpectrum.basicOpen f })","decl":"/-- If `U` is qcqs, then `Œì(X, D(f)) ‚âÉ Œì(X, U)_f` for every `f : Œì(X, U)`.\nThis is known as the **Qcqs lemma** in [R. Vakil, *The rising sea*][RisingSea]. -/\ntheorem isIso_ŒìSpec_adjunction_unit_app_basicOpen {X : Scheme} [CompactSpace X]\n    [QuasiSeparatedSpace X] (f : X.presheaf.obj (op ‚ä§)) :\n    IsIso ((ŒìSpec.adjunction.unit.app X).c.app (op (PrimeSpectrum.basicOpen f))) := by\n  refine @IsIso.of_isIso_comp_right _ _ _ _ _ _ (X.presheaf.map\n    (eqToHom (Scheme.toSpecŒì_preimage_basicOpen _ _).symm).op) _ ?_\n  rw [ConcreteCategory.isIso_iff_bijective, CommRingCat.forget_map]\n  apply (config := { allowSynthFailures := true }) IsLocalization.bijective\n  ¬∑ exact StructureSheaf.IsLocalization.to_basicOpen _ _\n  ¬∑ refine is_localization_basicOpen_of_qcqs ?_ ?_ _\n    ¬∑ exact isCompact_univ\n    ¬∑ exact isQuasiSeparated_univ\n  ¬∑ simp only [RingHom.algebraMap_toAlgebra]\n    -- This `rw` doesn't fire as a `simp` (`only`).\n    rw [‚Üê CommRingCat.hom_comp]\n    simp [RingHom.algebraMap_toAlgebra, ‚Üê Functor.map_comp]\n\n"}
