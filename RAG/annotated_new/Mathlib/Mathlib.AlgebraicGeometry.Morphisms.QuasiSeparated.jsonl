{"name":"AlgebraicGeometry.QuasiSeparated.diagonalQuasiCompact","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nself : AlgebraicGeometry.QuasiSeparated f\n⊢ AlgebraicGeometry.QuasiCompact (CategoryTheory.Limits.pullback.diagonal f)","decl":"/-- A morphism is `QuasiSeparated` if diagonal map is quasi-compact. -/\n@[mk_iff]\nclass QuasiSeparated (f : X ⟶ Y) : Prop where\n  /-- A morphism is `QuasiSeparated` if diagonal map is quasi-compact. -/\n  diagonalQuasiCompact : QuasiCompact (pullback.diagonal f) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.quasiSeparated_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n⊢ Iff (AlgebraicGeometry.QuasiSeparated f) (autoParam (AlgebraicGeometry.QuasiCompact (CategoryTheory.Limits.pullback.diagonal f)) _auto✝)","decl":"/-- A morphism is `QuasiSeparated` if diagonal map is quasi-compact. -/\n@[mk_iff]\nclass QuasiSeparated (f : X ⟶ Y) : Prop where\n  /-- A morphism is `QuasiSeparated` if diagonal map is quasi-compact. -/\n  diagonalQuasiCompact : QuasiCompact (pullback.diagonal f) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.quasiSeparatedSpace_iff_affine","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\n⊢ Iff (QuasiSeparatedSpace ↑↑X.toPresheafedSpace) (∀ (U V : ↑X.affineOpens), IsCompact (Inter.inter ↑↑U ↑↑V))","decl":"theorem quasiSeparatedSpace_iff_affine (X : Scheme) :\n    QuasiSeparatedSpace X ↔ ∀ U V : X.affineOpens, IsCompact (U ∩ V : Set X) := by\n  rw [quasiSeparatedSpace_iff]\n  constructor\n  · intro H U V; exact H U V U.1.2 U.2.isCompact V.1.2 V.2.isCompact\n  · intro H\n    suffices\n      ∀ (U : X.Opens) (_ : IsCompact U.1) (V : X.Opens) (_ : IsCompact V.1),\n        IsCompact (U ⊓ V).1\n      by intro U V hU hU' hV hV'; exact this ⟨U, hU⟩ hU' ⟨V, hV⟩ hV'\n    intro U hU V hV\n    refine compact_open_induction_on V hV ?_ ?_\n    · simp\n    · intro S _ V hV\n      change IsCompact (U.1 ∩ (S.1 ∪ V.1))\n      rw [Set.inter_union_distrib_left]\n      apply hV.union\n      clear hV\n      refine compact_open_induction_on U hU ?_ ?_\n      · simp\n      · intro S _ W hW\n        change IsCompact ((S.1 ∪ W.1) ∩ V.1)\n        rw [Set.union_inter_distrib_right]\n        apply hW.union\n        apply H\n\n"}
{"name":"AlgebraicGeometry.quasiCompact_affineProperty_iff_quasiSeparatedSpace","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst✝ : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\n⊢ Iff (AlgebraicGeometry.AffineTargetMorphismProperty.diagonal (fun X x x_1 x => CompactSpace ↑↑X.toPresheafedSpace) f) (QuasiSeparatedSpace ↑↑X.toPresheafedSpace)","decl":"theorem quasiCompact_affineProperty_iff_quasiSeparatedSpace {X Y : Scheme} [IsAffine Y]\n    (f : X ⟶ Y) :\n    AffineTargetMorphismProperty.diagonal (fun X _ _ _ ↦ CompactSpace X) f ↔\n      QuasiSeparatedSpace X := by\n  delta AffineTargetMorphismProperty.diagonal\n  rw [quasiSeparatedSpace_iff_affine]\n  constructor\n  · intro H U V\n    haveI : IsAffine _ := U.2\n    haveI : IsAffine _ := V.2\n    let g : pullback U.1.ι V.1.ι ⟶ X := pullback.fst _ _ ≫ U.1.ι\n    -- Porting note: `inferInstance` does not work here\n    have : IsOpenImmersion g := PresheafedSpace.IsOpenImmersion.comp _ _\n    have e := Homeomorph.ofIsEmbedding _ this.base_open.isEmbedding\n    rw [IsOpenImmersion.range_pullback_to_base_of_left] at e\n    erw [Subtype.range_coe, Subtype.range_coe] at e\n    rw [isCompact_iff_compactSpace]\n    exact @Homeomorph.compactSpace _ _ _ _ (H _ _) e\n  · introv H h₁ h₂\n    let g : pullback f₁ f₂ ⟶ X := pullback.fst _ _ ≫ f₁\n    -- Porting note: `inferInstance` does not work here\n    have : IsOpenImmersion g := PresheafedSpace.IsOpenImmersion.comp _ _\n    have e := Homeomorph.ofIsEmbedding _ this.base_open.isEmbedding\n    rw [IsOpenImmersion.range_pullback_to_base_of_left] at e\n    simp_rw [isCompact_iff_compactSpace] at H\n    exact\n      @Homeomorph.compactSpace _ _ _ _\n        (H ⟨⟨_, h₁.base_open.isOpen_range⟩, isAffineOpen_opensRange _⟩\n          ⟨⟨_, h₂.base_open.isOpen_range⟩, isAffineOpen_opensRange _⟩)\n        e.symm\n\n"}
{"name":"AlgebraicGeometry.quasiSeparated_eq_diagonal_is_quasiCompact","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"⊢ Eq (@AlgebraicGeometry.QuasiSeparated) (CategoryTheory.MorphismProperty.diagonal @AlgebraicGeometry.QuasiCompact)","decl":"theorem quasiSeparated_eq_diagonal_is_quasiCompact :\n    @QuasiSeparated = MorphismProperty.diagonal @QuasiCompact := by ext; exact quasiSeparated_iff _\n\n"}
{"name":"AlgebraicGeometry.instHasAffinePropertyQuasiSeparatedQuasiSeparatedSpaceαTopologicalSpaceCarrierCommRingCat","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"⊢ AlgebraicGeometry.HasAffineProperty @AlgebraicGeometry.QuasiSeparated fun X x x_1 x => QuasiSeparatedSpace ↑↑X.toPresheafedSpace","decl":"instance : HasAffineProperty @QuasiSeparated (fun X _ _ _ ↦ QuasiSeparatedSpace X) where\n  __ := HasAffineProperty.copy\n    quasiSeparated_eq_diagonal_is_quasiCompact.symm\n    (by ext; exact quasiCompact_affineProperty_iff_quasiSeparatedSpace _)\n\n"}
{"name":"AlgebraicGeometry.quasiSeparatedOfMono","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\n⊢ AlgebraicGeometry.QuasiSeparated f","decl":"instance (priority := 900) quasiSeparatedOfMono {X Y : Scheme} (f : X ⟶ Y) [Mono f] :\n    QuasiSeparated f where\n\n"}
{"name":"AlgebraicGeometry.quasiSeparated_isStableUnderComposition","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"⊢ CategoryTheory.MorphismProperty.IsStableUnderComposition @AlgebraicGeometry.QuasiSeparated","decl":"instance quasiSeparated_isStableUnderComposition :\n    MorphismProperty.IsStableUnderComposition @QuasiSeparated :=\n  quasiSeparated_eq_diagonal_is_quasiCompact.symm ▸ inferInstance\n\n"}
{"name":"AlgebraicGeometry.quasiSeparated_isStableUnderBaseChange","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"⊢ CategoryTheory.MorphismProperty.IsStableUnderBaseChange @AlgebraicGeometry.QuasiSeparated","decl":"instance quasiSeparated_isStableUnderBaseChange :\n    MorphismProperty.IsStableUnderBaseChange @QuasiSeparated :=\n  quasiSeparated_eq_diagonal_is_quasiCompact.symm ▸ inferInstance\n\n"}
{"name":"AlgebraicGeometry.quasiSeparatedComp","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝¹ : AlgebraicGeometry.QuasiSeparated f\ninst✝ : AlgebraicGeometry.QuasiSeparated g\n⊢ AlgebraicGeometry.QuasiSeparated (CategoryTheory.CategoryStruct.comp f g)","decl":"instance quasiSeparatedComp {X Y Z : Scheme} (f : X ⟶ Y) (g : Y ⟶ Z) [QuasiSeparated f]\n    [QuasiSeparated g] : QuasiSeparated (f ≫ g) :=\n  MorphismProperty.comp_mem _ f g inferInstance inferInstance\n\n"}
{"name":"AlgebraicGeometry.quasiSeparated_over_affine_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsAffine Y\n⊢ Iff (AlgebraicGeometry.QuasiSeparated f) (QuasiSeparatedSpace ↑↑X.toPresheafedSpace)","decl":"theorem quasiSeparated_over_affine_iff {X Y : Scheme} (f : X ⟶ Y) [IsAffine Y] :\n    QuasiSeparated f ↔ QuasiSeparatedSpace X := by\n  rw [HasAffineProperty.iff_of_isAffine (P := @QuasiSeparated)]\n\n"}
{"name":"AlgebraicGeometry.quasiSeparatedSpace_iff_quasiSeparated","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\n⊢ Iff (QuasiSeparatedSpace ↑↑X.toPresheafedSpace) (AlgebraicGeometry.QuasiSeparated (CategoryTheory.Limits.terminal.from X))","decl":"theorem quasiSeparatedSpace_iff_quasiSeparated (X : Scheme) :\n    QuasiSeparatedSpace X ↔ QuasiSeparated (terminal.from X) :=\n  (quasiSeparated_over_affine_iff _).symm\n\n"}
{"name":"AlgebraicGeometry.instQuasiSeparatedFstScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\ninst✝ : AlgebraicGeometry.QuasiSeparated g\n⊢ AlgebraicGeometry.QuasiSeparated (CategoryTheory.Limits.pullback.fst f g)","decl":"instance {X Y S : Scheme} (f : X ⟶ S) (g : Y ⟶ S) [QuasiSeparated g] :\n    QuasiSeparated (pullback.fst f g) :=\n  MorphismProperty.pullback_fst f g inferInstance\n\n"}
{"name":"AlgebraicGeometry.instQuasiSeparatedSndScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\ninst✝ : AlgebraicGeometry.QuasiSeparated f\n⊢ AlgebraicGeometry.QuasiSeparated (CategoryTheory.Limits.pullback.snd f g)","decl":"instance {X Y S : Scheme} (f : X ⟶ S) (g : Y ⟶ S) [QuasiSeparated f] :\n    QuasiSeparated (pullback.snd f g) :=\n  MorphismProperty.pullback_snd f g inferInstance\n\n"}
{"name":"AlgebraicGeometry.quasiSeparatedSpace_of_quasiSeparated","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhY : QuasiSeparatedSpace ↑↑Y.toPresheafedSpace\ninst✝ : AlgebraicGeometry.QuasiSeparated f\n⊢ QuasiSeparatedSpace ↑↑X.toPresheafedSpace","decl":"theorem quasiSeparatedSpace_of_quasiSeparated {X Y : Scheme} (f : X ⟶ Y)\n    [hY : QuasiSeparatedSpace Y] [QuasiSeparated f] : QuasiSeparatedSpace X := by\n  rw [quasiSeparatedSpace_iff_quasiSeparated] at hY ⊢\n  rw [← terminalIsTerminal.hom_ext (f ≫ terminal.from Y) (terminal.from X)]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.quasiSeparatedSpace_of_isAffine","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\ninst✝ : AlgebraicGeometry.IsAffine X\n⊢ QuasiSeparatedSpace ↑↑X.toPresheafedSpace","decl":"instance quasiSeparatedSpace_of_isAffine (X : Scheme) [IsAffine X] :\n    QuasiSeparatedSpace X := by\n  constructor\n  intro U V hU hU' hV hV'\n  obtain ⟨s, hs, e⟩ := (isCompactOpen_iff_eq_basicOpen_union _).mp ⟨hU', hU⟩\n  obtain ⟨s', hs', e'⟩ := (isCompactOpen_iff_eq_basicOpen_union _).mp ⟨hV', hV⟩\n  rw [e, e', Set.iUnion₂_inter]\n  simp_rw [Set.inter_iUnion₂]\n  apply hs.isCompact_biUnion\n  intro i _\n  apply hs'.isCompact_biUnion\n  intro i' _\n  change IsCompact (X.basicOpen i ⊓ X.basicOpen i').1\n  rw [← Scheme.basicOpen_mul]\n  exact ((isAffineOpen_top _).basicOpen _).isCompact\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.isQuasiSeparated","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\n⊢ IsQuasiSeparated ↑U","decl":"theorem IsAffineOpen.isQuasiSeparated {X : Scheme} {U : X.Opens} (hU : IsAffineOpen U) :\n    IsQuasiSeparated (U : Set X) := by\n  rw [isQuasiSeparated_iff_quasiSeparatedSpace]\n  exacts [@AlgebraicGeometry.quasiSeparatedSpace_of_isAffine _ hU, U.isOpen]\n\n"}
{"name":"AlgebraicGeometry.quasiSeparatedSpace_iff_quasiCompact_prod_lift","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\n⊢ Iff (QuasiSeparatedSpace ↑↑X.toPresheafedSpace) (AlgebraicGeometry.QuasiCompact (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X)))","decl":"lemma quasiSeparatedSpace_iff_quasiCompact_prod_lift :\n    QuasiSeparatedSpace X ↔ QuasiCompact (prod.lift (𝟙 X) (𝟙 X)) := by\n  rw [← MorphismProperty.cancel_right_of_respectsIso @QuasiCompact _ (prodIsoPullback X X).hom,\n    ← HasAffineProperty.iff_of_isAffine (f := terminal.from X) (P := @QuasiSeparated),\n    quasiSeparated_iff]\n  congr!\n  ext : 1 <;> simp\n\n"}
{"name":"AlgebraicGeometry.instQuasiCompactLiftSchemeIdOfQuasiSeparatedSpaceαTopologicalSpaceCarrierCommRingCat","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\ninst✝ : QuasiSeparatedSpace ↑↑X.toPresheafedSpace\n⊢ AlgebraicGeometry.QuasiCompact (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X))","decl":"instance [QuasiSeparatedSpace X] : QuasiCompact (prod.lift (𝟙 X) (𝟙 X)) := by\n  rwa [← quasiSeparatedSpace_iff_quasiCompact_prod_lift]\n\n"}
{"name":"AlgebraicGeometry.instQuasiCompactιSchemeOfQuasiSeparatedSpaceαTopologicalSpaceCarrierCommRingCat","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst✝ : QuasiSeparatedSpace ↑↑Y.toPresheafedSpace\nf g : Quiver.Hom X Y\n⊢ AlgebraicGeometry.QuasiCompact (CategoryTheory.Limits.equalizer.ι f g)","decl":"instance [QuasiSeparatedSpace Y] (f g : X ⟶ Y) : QuasiCompact (equalizer.ι f g) :=\n  MorphismProperty.of_isPullback (P := @QuasiCompact)\n    (isPullback_equalizer_prod f g).flip inferInstance\n\n"}
{"name":"AlgebraicGeometry.instCompactSpaceαTopologicalSpaceCarrierCommRingCatEqualizerSchemeOfQuasiSeparatedSpace","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst✝¹ : CompactSpace ↑↑X.toPresheafedSpace\ninst✝ : QuasiSeparatedSpace ↑↑Y.toPresheafedSpace\nf g : Quiver.Hom X Y\n⊢ CompactSpace ↑↑(CategoryTheory.Limits.equalizer f g).toPresheafedSpace","decl":"instance [CompactSpace X] [QuasiSeparatedSpace Y] (f g : X ⟶ Y) :\n    CompactSpace (equalizer f g).carrier := by\n  constructor\n  simpa using QuasiCompact.isCompact_preimage (f := equalizer.ι f g) _ isOpen_univ isCompact_univ\n\n"}
{"name":"AlgebraicGeometry.QuasiSeparated.of_comp","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝ : AlgebraicGeometry.QuasiSeparated (CategoryTheory.CategoryStruct.comp f g)\n⊢ AlgebraicGeometry.QuasiSeparated f","decl":"theorem QuasiSeparated.of_comp {X Y Z : Scheme} (f : X ⟶ Y) (g : Y ⟶ Z) [QuasiSeparated (f ≫ g)] :\n    QuasiSeparated f := by\n  let 𝒰 := (Z.affineCover.pullbackCover g).bind fun x => Scheme.affineCover _\n  have (i) : IsAffine (𝒰.obj i) := by dsimp [𝒰]; infer_instance\n  apply HasAffineProperty.of_openCover\n    ((Z.affineCover.pullbackCover g).bind fun x => Scheme.affineCover _)\n  rintro ⟨i, j⟩; dsimp at i j\n  refine @quasiSeparatedSpace_of_quasiSeparated _ _ ?_\n    (HasAffineProperty.of_isPullback (.of_hasPullback _ (Z.affineCover.map i)) ‹_›) ?_\n  · exact pullback.map _ _ _ _ (𝟙 _) _ _ (by simp) (Category.comp_id _) ≫\n      (pullbackRightPullbackFstIso g (Z.affineCover.map i) f).hom\n  · exact inferInstance\n\n"}
{"name":"AlgebraicGeometry.exists_eq_pow_mul_of_isAffineOpen","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nf : ↑(X.presheaf.obj { unop := U })\nx : ↑(X.presheaf.obj { unop := X.basicOpen f })\n⊢ Exists fun n => Exists fun y => Eq (TopCat.Presheaf.restrictOpen y (X.basicOpen f) ⋯) (HMul.hMul (HPow.hPow (TopCat.Presheaf.restrictOpen f (X.basicOpen f) ⋯) n) x)","decl":"theorem exists_eq_pow_mul_of_isAffineOpen (X : Scheme) (U : X.Opens) (hU : IsAffineOpen U)\n    (f : Γ(X, U)) (x : Γ(X, X.basicOpen f)) :\n    ∃ (n : ℕ) (y : Γ(X, U)), y |_ X.basicOpen f = (f |_ X.basicOpen f) ^ n * x := by\n  have := (hU.isLocalization_basicOpen f).2\n  obtain ⟨⟨y, _, n, rfl⟩, d⟩ := this x\n  use n, y\n  simpa [mul_comm x] using d.symm\n\n"}
{"name":"AlgebraicGeometry.exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux_aux","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : TopCat\nF : TopCat.Presheaf CommRingCat X\nU₁ U₂ U₃ U₄ U₅ U₆ U₇ : TopologicalSpace.Opens ↑X\nn₁ n₂ : Nat\ny₁ : ↑(F.obj { unop := U₁ })\ny₂ : ↑(F.obj { unop := U₂ })\nf : ↑(F.obj { unop := Max.max U₁ U₂ })\nx : ↑(F.obj { unop := U₃ })\nh₄₁ : LE.le U₄ U₁\nh₄₂ : LE.le U₄ U₂\nh₅₁ : LE.le U₅ U₁\nh₅₃ : LE.le U₅ U₃\nh₆₂ : LE.le U₆ U₂\nh₆₃ : LE.le U₆ U₃\nh₇₄ : LE.le U₇ U₄\nh₇₅ : LE.le U₇ U₅\nh₇₆ : LE.le U₇ U₆\ne₁ : Eq (TopCat.Presheaf.restrictOpen y₁ U₅ ⋯) (HMul.hMul (HPow.hPow (TopCat.Presheaf.restrictOpen (TopCat.Presheaf.restrictOpen f U₁ ⋯) U₅ ⋯) n₁) (TopCat.Presheaf.restrictOpen x U₅ ⋯))\ne₂ : Eq (TopCat.Presheaf.restrictOpen y₂ U₆ ⋯) (HMul.hMul (HPow.hPow (TopCat.Presheaf.restrictOpen (TopCat.Presheaf.restrictOpen f U₂ ⋯) U₆ ⋯) n₂) (TopCat.Presheaf.restrictOpen x U₆ ⋯))\n⊢ Eq (TopCat.Presheaf.restrictOpen (TopCat.Presheaf.restrictOpen (HMul.hMul (HPow.hPow (TopCat.Presheaf.restrictOpen f U₁ ⋯) n₂) y₁) U₄ ⋯) U₇ ⋯) (TopCat.Presheaf.restrictOpen (TopCat.Presheaf.restrictOpen (HMul.hMul (HPow.hPow (TopCat.Presheaf.restrictOpen f U₂ ⋯) n₁) y₂) U₄ ⋯) U₇ ⋯)","decl":"theorem exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux_aux {X : TopCat}\n    (F : X.Presheaf CommRingCat) {U₁ U₂ U₃ U₄ U₅ U₆ U₇ : Opens X} {n₁ n₂ : ℕ}\n    {y₁ : F.obj (op U₁)} {y₂ : F.obj (op U₂)} {f : F.obj (op <| U₁ ⊔ U₂)}\n    {x : F.obj (op U₃)} (h₄₁ : U₄ ≤ U₁) (h₄₂ : U₄ ≤ U₂) (h₅₁ : U₅ ≤ U₁) (h₅₃ : U₅ ≤ U₃)\n    (h₆₂ : U₆ ≤ U₂) (h₆₃ : U₆ ≤ U₃) (h₇₄ : U₇ ≤ U₄) (h₇₅ : U₇ ≤ U₅) (h₇₆ : U₇ ≤ U₆)\n    (e₁ : y₁ |_ U₅ = (f |_ U₁ |_ U₅) ^ n₁ * x |_ U₅)\n    (e₂ : y₂ |_ U₆ = (f |_ U₂ |_ U₆) ^ n₂ * x |_ U₆) :\n    (((f |_ U₁) ^ n₂ * y₁) |_ U₄) |_ U₇ = (((f |_ U₂) ^ n₁ * y₂) |_ U₄) |_ U₇ := by\n  apply_fun (fun x : F.obj (op U₅) ↦ x |_ U₇) at e₁\n  apply_fun (fun x : F.obj (op U₆) ↦ x |_ U₇) at e₂\n  dsimp only [TopCat.Presheaf.restrictOpenCommRingCat_apply] at e₁ e₂ ⊢\n  simp only [map_mul, map_pow, ← op_comp, ← F.map_comp, homOfLE_comp, ← CommRingCat.comp_apply]\n    at e₁ e₂ ⊢\n  rw [e₁, e₂, mul_left_comm]\n\n"}
{"name":"AlgebraicGeometry.exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\nS : ↑X.affineOpens\nU₁ U₂ : X.Opens\nn₁ n₂ : Nat\ny₁ : ↑(X.presheaf.obj { unop := U₁ })\ny₂ : ↑(X.presheaf.obj { unop := U₂ })\nf : ↑(X.presheaf.obj { unop := Max.max U₁ U₂ })\nx : ↑(X.presheaf.obj { unop := X.basicOpen f })\nh₁ : LE.le (↑S) U₁\nh₂ : LE.le (↑S) U₂\ne₁ : Eq (TopCat.Presheaf.restrictOpen y₁ (X.basicOpen (TopCat.Presheaf.restrictOpen f U₁ ⋯)) ⋯) (HMul.hMul (HPow.hPow (TopCat.Presheaf.restrictOpen (TopCat.Presheaf.restrictOpen f U₁ ⋯) (X.basicOpen (TopCat.Presheaf.restrictOpen f U₁ ⋯)) ⋯) n₁) (TopCat.Presheaf.restrictOpen x (X.basicOpen (TopCat.Presheaf.restrictOpen f U₁ ⋯)) ⋯))\ne₂ : Eq (TopCat.Presheaf.restrictOpen y₂ (X.basicOpen (TopCat.Presheaf.restrictOpen f U₂ ⋯)) ⋯) (HMul.hMul (HPow.hPow (TopCat.Presheaf.restrictOpen (TopCat.Presheaf.restrictOpen f U₂ ⋯) (X.basicOpen (TopCat.Presheaf.restrictOpen f U₂ ⋯)) ⋯) n₂) (TopCat.Presheaf.restrictOpen x (X.basicOpen (TopCat.Presheaf.restrictOpen f U₂ ⋯)) ⋯))\n⊢ Exists fun n => ∀ (m : Nat), LE.le n m → Eq (TopCat.Presheaf.restrictOpen (HMul.hMul (HPow.hPow (TopCat.Presheaf.restrictOpen f U₁ ⋯) (HAdd.hAdd m n₂)) y₁) ↑S ⋯) (TopCat.Presheaf.restrictOpen (HMul.hMul (HPow.hPow (TopCat.Presheaf.restrictOpen f U₂ ⋯) (HAdd.hAdd m n₁)) y₂) ↑S ⋯)","decl":"theorem exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux (X : Scheme)\n    (S : X.affineOpens) (U₁ U₂ : X.Opens) {n₁ n₂ : ℕ} {y₁ : Γ(X, U₁)}\n    {y₂ : Γ(X, U₂)} {f : Γ(X, U₁ ⊔ U₂)}\n    {x : Γ(X, X.basicOpen f)} (h₁ : S.1 ≤ U₁) (h₂ : S.1 ≤ U₂)\n    (e₁ : y₁ |_ X.basicOpen (f |_ U₁) =\n      ((f |_ U₁ |_ X.basicOpen _) ^ n₁) * x |_ X.basicOpen _)\n    (e₂ : y₂ |_ X.basicOpen (f |_ U₂) =\n      ((f |_ U₂ |_ X.basicOpen _) ^ n₂) * x |_ X.basicOpen _) :\n    ∃ n : ℕ, ∀ m, n ≤ m →\n      ((f |_ U₁) ^ (m + n₂) * y₁) |_ S.1 = ((f |_ U₂) ^ (m + n₁) * y₂) |_ S.1 := by\n  obtain ⟨⟨_, n, rfl⟩, e⟩ :=\n    (@IsLocalization.eq_iff_exists _ _ _ _ _ _\n      (S.2.isLocalization_basicOpen (f |_ S.1))\n        (((f |_ U₁) ^ n₂ * y₁) |_ S.1)\n        (((f |_ U₂) ^ n₁ * y₂) |_ S.1)).mp <| by\n    apply exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux_aux (e₁ := e₁) (e₂ := e₂)\n    · show X.basicOpen _ ≤ _\n      simp only [TopCat.Presheaf.restrictOpenCommRingCat_apply, Scheme.basicOpen_res]\n      exact inf_le_inf h₁ le_rfl\n    · show X.basicOpen _ ≤ _\n      simp only [TopCat.Presheaf.restrictOpenCommRingCat_apply, Scheme.basicOpen_res]\n      exact inf_le_inf h₂ le_rfl\n  use n\n  intros m hm\n  rw [← tsub_add_cancel_of_le hm]\n  simp only [TopCat.Presheaf.restrictOpenCommRingCat_apply,\n    pow_add, map_pow, map_mul, mul_assoc, ← Functor.map_comp, ← op_comp, homOfLE_comp,\n    Subtype.coe_mk, ← CommRingCat.comp_apply] at e ⊢\n  rw [e]\n\n"}
{"name":"AlgebraicGeometry.exists_eq_pow_mul_of_isCompact_of_isQuasiSeparated","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : IsCompact U.carrier\nhU' : IsQuasiSeparated U.carrier\nf : ↑(X.presheaf.obj { unop := U })\nx : ↑(X.presheaf.obj { unop := X.basicOpen f })\n⊢ Exists fun n => Exists fun y => Eq (TopCat.Presheaf.restrictOpen y (X.basicOpen f) ⋯) (HMul.hMul (HPow.hPow (TopCat.Presheaf.restrictOpen f (X.basicOpen f) ⋯) n) x)","decl":"theorem exists_eq_pow_mul_of_isCompact_of_isQuasiSeparated (X : Scheme.{u}) (U : X.Opens)\n    (hU : IsCompact U.1) (hU' : IsQuasiSeparated U.1) (f : Γ(X, U)) (x : Γ(X, X.basicOpen f)) :\n    ∃ (n : ℕ) (y : Γ(X, U)), y |_ X.basicOpen f = (f |_ X.basicOpen f) ^ n * x := by\n  dsimp only [TopCat.Presheaf.restrictOpenCommRingCat_apply]\n  revert hU' f x\n  refine compact_open_induction_on U hU ?_ ?_\n  · intro _ f x\n    use 0, f\n    refine @Subsingleton.elim _\n      (CommRingCat.subsingleton_of_isTerminal (X.sheaf.isTerminalOfEqEmpty ?_)) _ _\n    rw [eq_bot_iff]\n    exact X.basicOpen_le f\n  · -- Given `f : 𝒪(S ∪ U), x : 𝒪(X_f)`, we need to show that `f ^ n * x` is the restriction of\n    -- some `y : 𝒪(S ∪ U)` for some `n : ℕ`.\n    intro S hS U hU hSU f x\n    -- We know that such `y₁, n₁` exists on `S` by the induction hypothesis.\n    obtain ⟨n₁, y₁, hy₁⟩ :=\n      hU (hSU.of_subset Set.subset_union_left) (X.presheaf.map (homOfLE le_sup_left).op f)\n        (X.presheaf.map (homOfLE _).op x)\n    -- · rw [X.basicOpen_res]; exact inf_le_right\n    -- We know that such `y₂, n₂` exists on `U` since `U` is affine.\n    obtain ⟨n₂, y₂, hy₂⟩ :=\n      exists_eq_pow_mul_of_isAffineOpen X _ U.2 (X.presheaf.map (homOfLE le_sup_right).op f)\n        (X.presheaf.map (homOfLE _).op x)\n    dsimp only [TopCat.Presheaf.restrictOpenCommRingCat_apply] at hy₂\n    -- swap; · rw [X.basicOpen_res]; exact inf_le_right\n    -- Since `S ∪ U` is quasi-separated, `S ∩ U` can be covered by finite affine opens.\n    obtain ⟨s, hs', hs⟩ :=\n      (isCompactOpen_iff_eq_finset_affine_union _).mp\n        ⟨hSU _ _ Set.subset_union_left S.2 hS Set.subset_union_right U.1.2\n            U.2.isCompact,\n          (S ⊓ U.1).2⟩\n    haveI := hs'.to_subtype\n    cases nonempty_fintype s\n    replace hs : S ⊓ U.1 = iSup fun i : s => (i : X.Opens) := by ext1; simpa using hs\n    have hs₁ : ∀ i : s, i.1.1 ≤ S := by\n      intro i; change (i : X.Opens) ≤ S\n      refine le_trans ?_ (inf_le_left (b := U.1))\n      rw [hs]\n      -- Porting note: have to add argument explicitly\n      exact @le_iSup X.Opens s _ (fun (i : s) => (i : X.Opens)) i\n    have hs₂ : ∀ i : s, i.1.1 ≤ U.1 := by\n      intro i; change (i : X.Opens) ≤ U\n      refine le_trans ?_ (inf_le_right (a := S))\n      rw [hs]\n      -- Porting note: have to add argument explicitly\n      exact @le_iSup X.Opens s _ (fun (i : s) => (i : X.Opens)) i\n    -- On each affine open in the intersection, we have `f ^ (n + n₂) * y₁ = f ^ (n + n₁) * y₂`\n    -- for some `n` since `f ^ n₂ * y₁ = f ^ (n₁ + n₂) * x = f ^ n₁ * y₂` on `X_f`.\n    have := fun i ↦ exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux\n      X i.1 S U (hs₁ i) (hs₂ i) hy₁ hy₂\n    choose n hn using this\n    -- We can thus choose a big enough `n` such that `f ^ (n + n₂) * y₁ = f ^ (n + n₁) * y₂`\n    -- on `S ∩ U`.\n    have :\n      X.presheaf.map (homOfLE <| inf_le_left).op\n          (X.presheaf.map (homOfLE le_sup_left).op f ^ (Finset.univ.sup n + n₂) * y₁) =\n        X.presheaf.map (homOfLE <| inf_le_right).op\n          (X.presheaf.map (homOfLE le_sup_right).op f ^ (Finset.univ.sup n + n₁) * y₂) := by\n      fapply X.sheaf.eq_of_locally_eq' fun i : s => i.1.1\n      · refine fun i => homOfLE ?_; rw [hs]\n        -- Porting note: have to add argument explicitly\n        exact @le_iSup X.Opens s _ (fun (i : s) => (i : X.Opens)) i\n      · exact le_of_eq hs\n      · intro i\n        -- This unfolds `X.sheaf` and ensures we use `CommRingCat.hom` to apply the morphism\n        show (X.presheaf.map _) _ = (X.presheaf.map _) _\n        simp only [← CommRingCat.comp_apply, ← Functor.map_comp, ← op_comp]\n        apply hn\n        exact Finset.le_sup (Finset.mem_univ _)\n    use Finset.univ.sup n + n₁ + n₂\n    -- By the sheaf condition, since `f ^ (n + n₂) * y₁ = f ^ (n + n₁) * y₂`, it can be glued into\n    -- the desired section on `S ∪ U`.\n    use (X.sheaf.objSupIsoProdEqLocus S U.1).inv ⟨⟨_ * _, _ * _⟩, this⟩\n    refine (X.sheaf.objSupIsoProdEqLocus_inv_eq_iff _ _ _ (X.basicOpen_res _\n      (homOfLE le_sup_left).op) (X.basicOpen_res _ (homOfLE le_sup_right).op)).mpr ⟨?_, ?_⟩\n    · -- This unfolds `X.sheaf` and ensures we use `CommRingCat.hom` to apply the morphism\n      show (X.presheaf.map _) _ = (X.presheaf.map _) _\n      rw [add_assoc, add_comm n₁]\n      simp only [pow_add, map_pow, map_mul, hy₁, ← CommRingCat.comp_apply, ← mul_assoc,\n        ← Functor.map_comp, ← op_comp, homOfLE_comp]\n    · -- This unfolds `X.sheaf` and ensures we use `CommRingCat.hom` to apply the morphism\n      show (X.presheaf.map _) _ = (X.presheaf.map _) _\n      simp only [pow_add, map_pow, map_mul, hy₂, ← CommRingCat.comp_apply, ← mul_assoc,\n        ← Functor.map_comp, ← op_comp, homOfLE_comp]\n\n"}
{"name":"AlgebraicGeometry.is_localization_basicOpen_of_qcqs","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : IsCompact U.carrier\nhU' : IsQuasiSeparated U.carrier\nf : ↑(X.presheaf.obj { unop := U })\n⊢ IsLocalization.Away f ↑(X.presheaf.obj { unop := X.basicOpen f })","decl":"/-- If `U` is qcqs, then `Γ(X, D(f)) ≃ Γ(X, U)_f` for every `f : Γ(X, U)`.\nThis is known as the **Qcqs lemma** in [R. Vakil, *The rising sea*][RisingSea]. -/\ntheorem is_localization_basicOpen_of_qcqs {X : Scheme} {U : X.Opens} (hU : IsCompact U.1)\n    (hU' : IsQuasiSeparated U.1) (f : Γ(X, U)) :\n    IsLocalization.Away f (Γ(X, X.basicOpen f)) := by\n  constructor\n  · rintro ⟨_, n, rfl⟩\n    simp only [map_pow, Subtype.coe_mk, RingHom.algebraMap_toAlgebra]\n    exact IsUnit.pow _ (RingedSpace.isUnit_res_basicOpen _ f)\n  · intro z\n    obtain ⟨n, y, e⟩ := exists_eq_pow_mul_of_isCompact_of_isQuasiSeparated X U hU hU' f z\n    refine ⟨⟨y, _, n, rfl⟩, ?_⟩\n    simpa only [map_pow, Subtype.coe_mk, RingHom.algebraMap_toAlgebra, mul_comm z] using e.symm\n  · intro x y\n    rw [← sub_eq_zero, ← map_sub, RingHom.algebraMap_toAlgebra]\n    simp_rw [← @sub_eq_zero _ _ (_ * x) (_ * y), ← mul_sub]\n    generalize x - y = z\n    intro H\n    obtain ⟨n, e⟩ := exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isCompact X hU _ _ H\n    refine ⟨⟨_, n, rfl⟩, ?_⟩\n    simpa [mul_comm z] using e\n\n"}
{"name":"AlgebraicGeometry.exists_of_res_eq_of_qcqs","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\nU : TopologicalSpace.Opens ↑↑X.toPresheafedSpace\nhU : IsCompact U.carrier\nhU' : IsQuasiSeparated U.carrier\nf g s : ↑(X.presheaf.obj { unop := U })\nhfg : Eq (TopCat.Presheaf.restrictOpen f (X.basicOpen s) ⋯) (TopCat.Presheaf.restrictOpen g (X.basicOpen s) ⋯)\n⊢ Exists fun n => Eq (HMul.hMul (HPow.hPow s n) f) (HMul.hMul (HPow.hPow s n) g)","decl":"lemma exists_of_res_eq_of_qcqs {X : Scheme.{u}} {U : TopologicalSpace.Opens X}\n    (hU : IsCompact U.carrier) (hU' : IsQuasiSeparated U.carrier)\n    {f g s : Γ(X, U)} (hfg : f |_ X.basicOpen s = g |_ X.basicOpen s) :\n    ∃ n, s ^ n * f = s ^ n * g := by\n  obtain ⟨n, hc⟩ := (is_localization_basicOpen_of_qcqs hU hU' s).exists_of_eq s hfg\n  use n\n\n"}
{"name":"AlgebraicGeometry.exists_of_res_eq_of_qcqs_of_top","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\ninst✝¹ : CompactSpace ↑↑X.toPresheafedSpace\ninst✝ : QuasiSeparatedSpace ↑↑X.toPresheafedSpace\nf g s : ↑(X.presheaf.obj { unop := Top.top })\nhfg : Eq (TopCat.Presheaf.restrictOpen f (X.basicOpen s) ⋯) (TopCat.Presheaf.restrictOpen g (X.basicOpen s) ⋯)\n⊢ Exists fun n => Eq (HMul.hMul (HPow.hPow s n) f) (HMul.hMul (HPow.hPow s n) g)","decl":"lemma exists_of_res_eq_of_qcqs_of_top {X : Scheme.{u}} [CompactSpace X] [QuasiSeparatedSpace X]\n    {f g s : Γ(X, ⊤)} (hfg : f |_ X.basicOpen s = g |_ X.basicOpen s) :\n    ∃ n, s ^ n * f = s ^ n * g :=\n  exists_of_res_eq_of_qcqs (U := ⊤) CompactSpace.isCompact_univ isQuasiSeparated_univ hfg\n\n"}
{"name":"AlgebraicGeometry.exists_of_res_zero_of_qcqs","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\nU : TopologicalSpace.Opens ↑↑X.toPresheafedSpace\nhU : IsCompact U.carrier\nhU' : IsQuasiSeparated U.carrier\nf s : ↑(X.presheaf.obj { unop := U })\nhf : Eq (TopCat.Presheaf.restrictOpen f (X.basicOpen s) ⋯) 0\n⊢ Exists fun n => Eq (HMul.hMul (HPow.hPow s n) f) 0","decl":"lemma exists_of_res_zero_of_qcqs {X : Scheme.{u}} {U : TopologicalSpace.Opens X}\n    (hU : IsCompact U.carrier) (hU' : IsQuasiSeparated U.carrier)\n    {f s : Γ(X, U)} (hf : f |_ X.basicOpen s = 0) :\n    ∃ n, s ^ n * f = 0 := by\n  suffices h : ∃ n, s ^ n * f = s ^ n * 0 by\n    simpa using h\n  apply exists_of_res_eq_of_qcqs hU hU'\n  simpa\n\n"}
{"name":"AlgebraicGeometry.exists_of_res_zero_of_qcqs_of_top","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\ninst✝¹ : CompactSpace ↑↑X.toPresheafedSpace\ninst✝ : QuasiSeparatedSpace ↑↑X.toPresheafedSpace\nf s : ↑(X.presheaf.obj { unop := Top.top })\nhf : Eq (TopCat.Presheaf.restrictOpen f (X.basicOpen s) ⋯) 0\n⊢ Exists fun n => Eq (HMul.hMul (HPow.hPow s n) f) 0","decl":"lemma exists_of_res_zero_of_qcqs_of_top {X : Scheme} [CompactSpace X] [QuasiSeparatedSpace X]\n    {f s : Γ(X, ⊤)} (hf : f |_ X.basicOpen s = 0) :\n    ∃ n, s ^ n * f = 0 :=\n  exists_of_res_zero_of_qcqs (U := ⊤) CompactSpace.isCompact_univ isQuasiSeparated_univ hf\n\n"}
{"name":"AlgebraicGeometry.isIso_ΓSpec_adjunction_unit_app_basicOpen","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated","initialProofState":"X : AlgebraicGeometry.Scheme\ninst✝¹ : CompactSpace ↑↑X.toPresheafedSpace\ninst✝ : QuasiSeparatedSpace ↑↑X.toPresheafedSpace\nf : ↑(X.presheaf.obj { unop := Top.top })\n⊢ CategoryTheory.IsIso ((AlgebraicGeometry.ΓSpec.adjunction.unit.app X).c.app { unop := PrimeSpectrum.basicOpen f })","decl":"/-- If `U` is qcqs, then `Γ(X, D(f)) ≃ Γ(X, U)_f` for every `f : Γ(X, U)`.\nThis is known as the **Qcqs lemma** in [R. Vakil, *The rising sea*][RisingSea]. -/\ntheorem isIso_ΓSpec_adjunction_unit_app_basicOpen {X : Scheme} [CompactSpace X]\n    [QuasiSeparatedSpace X] (f : X.presheaf.obj (op ⊤)) :\n    IsIso ((ΓSpec.adjunction.unit.app X).c.app (op (PrimeSpectrum.basicOpen f))) := by\n  refine @IsIso.of_isIso_comp_right _ _ _ _ _ _ (X.presheaf.map\n    (eqToHom (Scheme.toSpecΓ_preimage_basicOpen _ _).symm).op) _ ?_\n  rw [ConcreteCategory.isIso_iff_bijective, CommRingCat.forget_map]\n  apply (config := { allowSynthFailures := true }) IsLocalization.bijective\n  · exact StructureSheaf.IsLocalization.to_basicOpen _ _\n  · refine is_localization_basicOpen_of_qcqs ?_ ?_ _\n    · exact isCompact_univ\n    · exact isQuasiSeparated_univ\n  · simp only [RingHom.algebraMap_toAlgebra]\n    -- This `rw` doesn't fire as a `simp` (`only`).\n    rw [← CommRingCat.hom_comp]\n    simp [RingHom.algebraMap_toAlgebra, ← Functor.map_comp]\n\n"}
