{"name":"IsAtom.Iic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\na x : α\nha : IsAtom a\nhax : LE.le a x\n⊢ IsAtom ⟨a, hax⟩","decl":"theorem IsAtom.Iic (ha : IsAtom a) (hax : a ≤ x) : IsAtom (⟨a, hax⟩ : Set.Iic x) :=\n  ⟨fun con => ha.1 (Subtype.mk_eq_mk.1 con), fun ⟨b, _⟩ hba => Subtype.mk_eq_mk.2 (ha.2 b hba)⟩\n\n"}
{"name":"IsAtom.of_isAtom_coe_Iic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\nx : α\na : ↑(Set.Iic x)\nha : IsAtom a\n⊢ IsAtom ↑a","decl":"theorem IsAtom.of_isAtom_coe_Iic {a : Set.Iic x} (ha : IsAtom a) : IsAtom (a : α) :=\n  ⟨fun con => ha.1 (Subtype.ext con), fun b hba =>\n    Subtype.mk_eq_mk.1 (ha.2 ⟨b, hba.le.trans a.prop⟩ hba)⟩\n\n"}
{"name":"isAtom_iff_le_of_ge","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\na : α\n⊢ Iff (IsAtom a) (And (Ne a Bot.bot) (∀ (b : α), Ne b Bot.bot → LE.le b a → LE.le a b))","decl":"theorem isAtom_iff_le_of_ge : IsAtom a ↔ a ≠ ⊥ ∧ ∀ b ≠ ⊥, b ≤ a → a ≤ b :=\n  and_congr Iff.rfl <|\n    forall_congr' fun b => by\n      simp only [Ne, @not_imp_comm (b = ⊥), Classical.not_imp, lt_iff_le_not_le]\n\n"}
{"name":"IsAtom.lt_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na x : α\nh : IsAtom a\n⊢ Iff (LT.lt x a) (Eq x Bot.bot)","decl":"theorem IsAtom.lt_iff (h : IsAtom a) : x < a ↔ x = ⊥ :=\n  ⟨h.2 x, fun hx => hx.symm ▸ h.1.bot_lt⟩\n\n"}
{"name":"IsAtom.le_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na x : α\nh : IsAtom a\n⊢ Iff (LE.le x a) (Or (Eq x Bot.bot) (Eq x a))","decl":"theorem IsAtom.le_iff (h : IsAtom a) : x ≤ a ↔ x = ⊥ ∨ x = a := by rw [le_iff_lt_or_eq, h.lt_iff]\n\n"}
{"name":"IsAtom.bot_lt","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na : α\nh : IsAtom a\n⊢ LT.lt Bot.bot a","decl":"lemma IsAtom.bot_lt (h : IsAtom a) : ⊥ < a :=\n  h.lt_iff.mpr rfl\n\n"}
{"name":"IsAtom.le_iff_eq","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na b : α\nha : IsAtom a\nhb : Ne b Bot.bot\n⊢ Iff (LE.le b a) (Eq b a)","decl":"lemma IsAtom.le_iff_eq (ha : IsAtom a) (hb : b ≠ ⊥) : b ≤ a ↔ b = a :=\n  ha.le_iff.trans <| or_iff_right hb\n\n"}
{"name":"IsAtom.Iic_eq","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na : α\nh : IsAtom a\n⊢ Eq (Set.Iic a) (Insert.insert Bot.bot (Singleton.singleton a))","decl":"theorem IsAtom.Iic_eq (h : IsAtom a) : Set.Iic a = {⊥, a} :=\n  Set.ext fun _ => h.le_iff\n\n"}
{"name":"bot_covBy_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na : α\n⊢ Iff (CovBy Bot.bot a) (IsAtom a)","decl":"@[simp]\ntheorem bot_covBy_iff : ⊥ ⋖ a ↔ IsAtom a := by\n  simp only [CovBy, bot_lt_iff_ne_bot, IsAtom, not_imp_not]\n\n"}
{"name":"CovBy.is_atom","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na : α\na✝ : CovBy Bot.bot a\n⊢ IsAtom a","decl":"alias ⟨CovBy.is_atom, IsAtom.bot_covBy⟩ := bot_covBy_iff\n\n"}
{"name":"IsAtom.bot_covBy","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na : α\na✝ : IsAtom a\n⊢ CovBy Bot.bot a","decl":"alias ⟨CovBy.is_atom, IsAtom.bot_covBy⟩ := bot_covBy_iff\n\n"}
{"name":"atom_le_iSup","module":"Mathlib.Order.Atoms","initialProofState":"ι : Sort u_1\nα : Type u_2\ninst✝ : Order.Frame α\na : α\nha : IsAtom a\nf : ι → α\n⊢ Iff (LE.le a (iSup f)) (Exists fun i => LE.le a (f i))","decl":"theorem atom_le_iSup [Order.Frame α] {a : α} (ha : IsAtom a) {f : ι → α} :\n    a ≤ iSup f ↔ ∃ i, a ≤ f i := by\n  refine ⟨?_, fun ⟨i, hi⟩ => le_trans hi (le_iSup _ _)⟩\n  show (a ≤ ⨆ i, f i) → _\n  refine fun h => of_not_not fun ha' => ?_\n  push_neg at ha'\n  have ha'' : Disjoint a (⨆ i, f i) :=\n    disjoint_iSup_iff.2 fun i => fun x hxa hxf => le_bot_iff.2 <| of_not_not fun hx =>\n      have hxa : x < a := (le_iff_eq_or_lt.1 hxa).resolve_left (by rintro rfl; exact ha' _ hxf)\n      hx (ha.2 _ hxa)\n  obtain rfl := le_bot_iff.1 (ha'' le_rfl h)\n  exact ha.1 rfl\n\n"}
{"name":"isCoatom_dual_iff_isAtom","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\na : α\n⊢ Iff (IsCoatom (OrderDual.toDual a)) (IsAtom a)","decl":"@[simp]\ntheorem isCoatom_dual_iff_isAtom [OrderBot α] {a : α} :\n    IsCoatom (OrderDual.toDual a) ↔ IsAtom a :=\n  Iff.rfl\n\n"}
{"name":"isAtom_dual_iff_isCoatom","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\na : α\n⊢ Iff (IsAtom (OrderDual.toDual a)) (IsCoatom a)","decl":"@[simp]\ntheorem isAtom_dual_iff_isCoatom [OrderTop α] {a : α} :\n    IsAtom (OrderDual.toDual a) ↔ IsCoatom a :=\n  Iff.rfl\n\n"}
{"name":"IsAtom.dual","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\na : α\na✝ : IsAtom a\n⊢ IsCoatom (OrderDual.toDual a)","decl":"alias ⟨_, IsAtom.dual⟩ := isCoatom_dual_iff_isAtom\n\n"}
{"name":"IsCoatom.dual","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\na : α\na✝ : IsCoatom a\n⊢ IsAtom (OrderDual.toDual a)","decl":"alias ⟨_, IsCoatom.dual⟩ := isAtom_dual_iff_isCoatom\n\n"}
{"name":"IsCoatom.Ici","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\na x : α\nha : IsCoatom a\nhax : LE.le x a\n⊢ IsCoatom ⟨a, hax⟩","decl":"theorem IsCoatom.Ici (ha : IsCoatom a) (hax : x ≤ a) : IsCoatom (⟨a, hax⟩ : Set.Ici x) :=\n  ha.dual.Iic hax\n\n"}
{"name":"IsCoatom.of_isCoatom_coe_Ici","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\nx : α\na : ↑(Set.Ici x)\nha : IsCoatom a\n⊢ IsCoatom ↑a","decl":"theorem IsCoatom.of_isCoatom_coe_Ici {a : Set.Ici x} (ha : IsCoatom a) : IsCoatom (a : α) :=\n  @IsAtom.of_isAtom_coe_Iic αᵒᵈ _ _ x a ha\n\n"}
{"name":"isCoatom_iff_ge_of_le","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\na : α\n⊢ Iff (IsCoatom a) (And (Ne a Top.top) (∀ (b : α), Ne b Top.top → LE.le a b → LE.le b a))","decl":"theorem isCoatom_iff_ge_of_le : IsCoatom a ↔ a ≠ ⊤ ∧ ∀ b ≠ ⊤, a ≤ b → b ≤ a :=\n  isAtom_iff_le_of_ge (α := αᵒᵈ)\n\n"}
{"name":"IsCoatom.lt_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na x : α\nh : IsCoatom a\n⊢ Iff (LT.lt a x) (Eq x Top.top)","decl":"theorem IsCoatom.lt_iff (h : IsCoatom a) : a < x ↔ x = ⊤ :=\n  h.dual.lt_iff\n\n"}
{"name":"IsCoatom.le_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na x : α\nh : IsCoatom a\n⊢ Iff (LE.le a x) (Or (Eq x Top.top) (Eq x a))","decl":"theorem IsCoatom.le_iff (h : IsCoatom a) : a ≤ x ↔ x = ⊤ ∨ x = a :=\n  h.dual.le_iff\n\n"}
{"name":"IsCoatom.lt_top","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na : α\nh : IsCoatom a\n⊢ LT.lt a Top.top","decl":"lemma IsCoatom.lt_top (h : IsCoatom a) : a < ⊤ :=\n  h.lt_iff.mpr rfl\n\n"}
{"name":"IsCoatom.le_iff_eq","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na b : α\nha : IsCoatom a\nhb : Ne b Top.top\n⊢ Iff (LE.le a b) (Eq b a)","decl":"lemma IsCoatom.le_iff_eq (ha : IsCoatom a) (hb : b ≠ ⊤) : a ≤ b ↔ b = a := ha.dual.le_iff_eq hb\n\n"}
{"name":"IsCoatom.Ici_eq","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na : α\nh : IsCoatom a\n⊢ Eq (Set.Ici a) (Insert.insert Top.top (Singleton.singleton a))","decl":"theorem IsCoatom.Ici_eq (h : IsCoatom a) : Set.Ici a = {⊤, a} :=\n  h.dual.Iic_eq\n\n"}
{"name":"covBy_top_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na : α\n⊢ Iff (CovBy a Top.top) (IsCoatom a)","decl":"@[simp]\ntheorem covBy_top_iff : a ⋖ ⊤ ↔ IsCoatom a :=\n  toDual_covBy_toDual_iff.symm.trans bot_covBy_iff\n\n"}
{"name":"IsCoatom.covBy_top","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na : α\na✝ : IsCoatom a\n⊢ CovBy a Top.top","decl":"alias ⟨CovBy.isCoatom, IsCoatom.covBy_top⟩ := covBy_top_iff\n\n"}
{"name":"CovBy.isCoatom","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na : α\na✝ : CovBy a Top.top\n⊢ IsCoatom a","decl":"alias ⟨CovBy.isCoatom, IsCoatom.covBy_top⟩ := covBy_top_iff\n\n"}
{"name":"SetLike.isAtom_iff","module":"Mathlib.Order.Atoms","initialProofState":"A : Type u_4\nB : Type u_5\ninst✝¹ : SetLike A B\ninst✝ : OrderBot A\nK : A\n⊢ Iff (IsAtom K) (And (Ne K Bot.bot) (∀ (H : A) (g : B), LE.le H K → Not (Membership.mem H g) → Membership.mem K g → Eq H Bot.bot))","decl":"theorem isAtom_iff [OrderBot A] {K : A} :\n    IsAtom K ↔ K ≠ ⊥ ∧ ∀ H g, H ≤ K → g ∉ H → g ∈ K → H = ⊥ := by\n  simp_rw [IsAtom, lt_iff_le_not_le, SetLike.not_le_iff_exists,\n    and_comm (a := _ ≤ _), and_imp, exists_imp, ← and_imp, and_comm]\n\n"}
{"name":"SetLike.isCoatom_iff","module":"Mathlib.Order.Atoms","initialProofState":"A : Type u_4\nB : Type u_5\ninst✝¹ : SetLike A B\ninst✝ : OrderTop A\nK : A\n⊢ Iff (IsCoatom K) (And (Ne K Top.top) (∀ (H : A) (g : B), LE.le K H → Not (Membership.mem K g) → Membership.mem H g → Eq H Top.top))","decl":"theorem isCoatom_iff [OrderTop A] {K : A} :\n    IsCoatom K ↔ K ≠ ⊤ ∧ ∀ H g, K ≤ H → g ∉ K → g ∈ H → H = ⊤ := by\n  simp_rw [IsCoatom, lt_iff_le_not_le, SetLike.not_le_iff_exists,\n    and_comm (a := _ ≤ _), and_imp, exists_imp, ← and_imp, and_comm]\n\n"}
{"name":"SetLike.covBy_iff","module":"Mathlib.Order.Atoms","initialProofState":"A : Type u_4\nB : Type u_5\ninst✝ : SetLike A B\nK L : A\n⊢ Iff (CovBy K L) (And (LT.lt K L) (∀ (H : A) (g : B), LE.le K H → LE.le H L → Not (Membership.mem K g) → Membership.mem H g → Eq H L))","decl":"theorem covBy_iff {K L : A} :\n    K ⋖ L ↔ K < L ∧ ∀ H g, K ≤ H → H ≤ L → g ∉ K → g ∈ H → H = L := by\n  refine and_congr_right fun _ ↦ forall_congr' fun H ↦ not_iff_not.mp ?_\n  push_neg\n  rw [lt_iff_le_not_le, lt_iff_le_and_ne, and_and_and_comm]\n  simp_rw [exists_and_left, and_assoc, and_congr_right_iff, ← and_assoc, and_comm, exists_and_left,\n    SetLike.not_le_iff_exists, and_comm, implies_true]\n\n"}
{"name":"SetLike.covBy_iff'","module":"Mathlib.Order.Atoms","initialProofState":"A : Type u_4\nB : Type u_5\ninst✝ : SetLike A B\nK L : A\n⊢ Iff (CovBy K L) (And (LT.lt K L) (∀ (H : A) (g : B), LE.le K H → LE.le H L → Not (Membership.mem H g) → Membership.mem L g → Eq H K))","decl":"/-- Dual variant of `SetLike.covBy_iff` -/\ntheorem covBy_iff' {K L : A} :\n    K ⋖ L ↔ K < L ∧ ∀ H g, K ≤ H → H ≤ L → g ∉ H → g ∈ L → H = K := by\n  refine and_congr_right fun _ ↦ forall_congr' fun H ↦ not_iff_not.mp ?_\n  push_neg\n  rw [lt_iff_le_and_ne, lt_iff_le_not_le, and_and_and_comm]\n  simp_rw [exists_and_left, and_assoc, and_congr_right_iff, ← and_assoc, and_comm, exists_and_left,\n    SetLike.not_le_iff_exists, ne_comm, implies_true]\n\n"}
{"name":"iInf_le_coatom","module":"Mathlib.Order.Atoms","initialProofState":"ι : Sort u_1\nα : Type u_2\ninst✝ : Order.Coframe α\na : α\nha : IsCoatom a\nf : ι → α\n⊢ Iff (LE.le (iInf f) a) (Exists fun i => LE.le (f i) a)","decl":"theorem iInf_le_coatom [Order.Coframe α] {a : α} (ha : IsCoatom a) {f : ι → α} :\n    iInf f ≤ a ↔ ∃ i, f i ≤ a :=\n  atom_le_iSup (α := αᵒᵈ) ha\n\n"}
{"name":"Set.Ici.isAtom_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na : α\nb : ↑(Set.Ici a)\n⊢ Iff (IsAtom b) (CovBy a ↑b)","decl":"@[simp]\ntheorem Set.Ici.isAtom_iff {b : Set.Ici a} : IsAtom b ↔ a ⋖ b := by\n  rw [← bot_covBy_iff]\n  refine (Set.OrdConnected.apply_covBy_apply_iff (OrderEmbedding.subtype fun c => a ≤ c) ?_).symm\n  simpa only [OrderEmbedding.subtype_apply, Subtype.range_coe_subtype] using Set.ordConnected_Ici\n\n"}
{"name":"Set.Iic.isCoatom_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\nb : α\na : ↑(Set.Iic b)\n⊢ Iff (IsCoatom a) (CovBy (↑a) b)","decl":"@[simp]\ntheorem Set.Iic.isCoatom_iff {a : Set.Iic b} : IsCoatom a ↔ ↑a ⋖ b := by\n  rw [← covBy_top_iff]\n  refine (Set.OrdConnected.apply_covBy_apply_iff (OrderEmbedding.subtype fun c => c ≤ b) ?_).symm\n  simpa only [OrderEmbedding.subtype_apply, Subtype.range_coe_subtype] using Set.ordConnected_Iic\n\n"}
{"name":"covBy_iff_atom_Ici","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nh : LE.le a b\n⊢ Iff (CovBy a b) (IsAtom ⟨b, h⟩)","decl":"theorem covBy_iff_atom_Ici (h : a ≤ b) : a ⋖ b ↔ IsAtom (⟨b, h⟩ : Set.Ici a) := by simp\n\n"}
{"name":"covBy_iff_coatom_Iic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nh : LE.le a b\n⊢ Iff (CovBy a b) (IsCoatom ⟨a, h⟩)","decl":"theorem covBy_iff_coatom_Iic (h : a ≤ b) : a ⋖ b ↔ IsCoatom (⟨a, h⟩ : Set.Iic b) := by simp\n\n"}
{"name":"IsAtom.inf_eq_bot_of_ne","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderBot α\na b : α\nha : IsAtom a\nhb : IsAtom b\nhab : Ne a b\n⊢ Eq (Min.min a b) Bot.bot","decl":"theorem IsAtom.inf_eq_bot_of_ne [SemilatticeInf α] [OrderBot α] {a b : α} (ha : IsAtom a)\n    (hb : IsAtom b) (hab : a ≠ b) : a ⊓ b = ⊥ :=\n  hab.not_le_or_not_le.elim (ha.lt_iff.1 ∘ inf_lt_left.2) (hb.lt_iff.1 ∘ inf_lt_right.2)\n\n"}
{"name":"IsAtom.disjoint_of_ne","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderBot α\na b : α\nha : IsAtom a\nhb : IsAtom b\nhab : Ne a b\n⊢ Disjoint a b","decl":"theorem IsAtom.disjoint_of_ne [SemilatticeInf α] [OrderBot α] {a b : α} (ha : IsAtom a)\n    (hb : IsAtom b) (hab : a ≠ b) : Disjoint a b :=\n  disjoint_iff.mpr (IsAtom.inf_eq_bot_of_ne ha hb hab)\n\n"}
{"name":"IsCoatom.sup_eq_top_of_ne","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderTop α\na b : α\nha : IsCoatom a\nhb : IsCoatom b\nhab : Ne a b\n⊢ Eq (Max.max a b) Top.top","decl":"theorem IsCoatom.sup_eq_top_of_ne [SemilatticeSup α] [OrderTop α] {a b : α} (ha : IsCoatom a)\n    (hb : IsCoatom b) (hab : a ≠ b) : a ⊔ b = ⊤ :=\n  ha.dual.inf_eq_bot_of_ne hb.dual hab\n\n"}
{"name":"isAtomic_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\n⊢ Iff (IsAtomic α) (∀ (b : α), Or (Eq b Bot.bot) (Exists fun a => And (IsAtom a) (LE.le a b)))","decl":"/-- A lattice is atomic iff every element other than `⊥` has an atom below it. -/\n@[mk_iff]\nclass IsAtomic [OrderBot α] : Prop where\n  /-- Every element other than `⊥` has an atom below it. -/\n  eq_bot_or_exists_atom_le : ∀ b : α, b = ⊥ ∨ ∃ a : α, IsAtom a ∧ a ≤ b\n\n"}
{"name":"IsAtomic.eq_bot_or_exists_atom_le","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\nself : IsAtomic α\nb : α\n⊢ Or (Eq b Bot.bot) (Exists fun a => And (IsAtom a) (LE.le a b))","decl":"/-- A lattice is atomic iff every element other than `⊥` has an atom below it. -/\n@[mk_iff]\nclass IsAtomic [OrderBot α] : Prop where\n  /-- Every element other than `⊥` has an atom below it. -/\n  eq_bot_or_exists_atom_le : ∀ b : α, b = ⊥ ∨ ∃ a : α, IsAtom a ∧ a ≤ b\n\n"}
{"name":"IsCoatomic.eq_top_or_exists_le_coatom","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\nself : IsCoatomic α\nb : α\n⊢ Or (Eq b Top.top) (Exists fun a => And (IsCoatom a) (LE.le b a))","decl":"/-- A lattice is coatomic iff every element other than `⊤` has a coatom above it. -/\n@[mk_iff]\nclass IsCoatomic [OrderTop α] : Prop where\n  /-- Every element other than `⊤` has an atom above it. -/\n  eq_top_or_exists_le_coatom : ∀ b : α, b = ⊤ ∨ ∃ a : α, IsCoatom a ∧ b ≤ a\n\n"}
{"name":"isCoatomic_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\n⊢ Iff (IsCoatomic α) (∀ (b : α), Or (Eq b Top.top) (Exists fun a => And (IsCoatom a) (LE.le b a)))","decl":"/-- A lattice is coatomic iff every element other than `⊤` has a coatom above it. -/\n@[mk_iff]\nclass IsCoatomic [OrderTop α] : Prop where\n  /-- Every element other than `⊤` has an atom above it. -/\n  eq_top_or_exists_le_coatom : ∀ b : α, b = ⊤ ∨ ∃ a : α, IsCoatom a ∧ b ≤ a\n\n"}
{"name":"IsAtomic.exists_atom","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝³ : PartialOrder α\ninst✝² : OrderBot α\ninst✝¹ : Nontrivial α\ninst✝ : IsAtomic α\n⊢ Exists fun a => IsAtom a","decl":"lemma IsAtomic.exists_atom [OrderBot α] [Nontrivial α] [IsAtomic α] : ∃ a : α, IsAtom a :=\n  have ⟨b, hb⟩ := exists_ne (⊥ : α)\n  have ⟨a, ha⟩ := (eq_bot_or_exists_atom_le b).resolve_left hb\n  ⟨a, ha.1⟩\n\n"}
{"name":"IsCoatomic.exists_coatom","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝³ : PartialOrder α\ninst✝² : OrderTop α\ninst✝¹ : Nontrivial α\ninst✝ : IsCoatomic α\n⊢ Exists fun a => IsCoatom a","decl":"lemma IsCoatomic.exists_coatom [OrderTop α] [Nontrivial α] [IsCoatomic α] : ∃ a : α, IsCoatom a :=\n  have ⟨b, hb⟩ := exists_ne (⊤ : α)\n  have ⟨a, ha⟩ := (eq_top_or_exists_le_coatom b).resolve_left hb\n  ⟨a, ha.1⟩\n\n"}
{"name":"isCoatomic_dual_iff_isAtomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\n⊢ Iff (IsCoatomic (OrderDual α)) (IsAtomic α)","decl":"@[simp]\ntheorem isCoatomic_dual_iff_isAtomic [OrderBot α] : IsCoatomic αᵒᵈ ↔ IsAtomic α :=\n  ⟨fun h => ⟨fun b => by apply h.eq_top_or_exists_le_coatom⟩, fun h =>\n    ⟨fun b => by apply h.eq_bot_or_exists_atom_le⟩⟩\n\n"}
{"name":"isAtomic_dual_iff_isCoatomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\n⊢ Iff (IsAtomic (OrderDual α)) (IsCoatomic α)","decl":"@[simp]\ntheorem isAtomic_dual_iff_isCoatomic [OrderTop α] : IsAtomic αᵒᵈ ↔ IsCoatomic α :=\n  ⟨fun h => ⟨fun b => by apply h.eq_bot_or_exists_atom_le⟩, fun h =>\n    ⟨fun b => by apply h.eq_top_or_exists_le_coatom⟩⟩\n\n"}
{"name":"OrderDual.instIsCoatomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\n⊢ IsCoatomic (OrderDual α)","decl":"instance _root_.OrderDual.instIsCoatomic : IsCoatomic αᵒᵈ :=\n  isCoatomic_dual_iff_isAtomic.2 ‹IsAtomic α›\n\n"}
{"name":"IsAtomic.Set.Iic.isAtomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : OrderBot α\ninst✝ : IsAtomic α\nx : α\n⊢ IsAtomic ↑(Set.Iic x)","decl":"instance Set.Iic.isAtomic {x : α} : IsAtomic (Set.Iic x) :=\n  ⟨fun ⟨y, hy⟩ =>\n    (eq_bot_or_exists_atom_le y).imp Subtype.mk_eq_mk.2 fun ⟨a, ha, hay⟩ =>\n      ⟨⟨a, hay.trans hy⟩, ha.Iic (hay.trans hy), hay⟩⟩\n\n"}
{"name":"OrderDual.instIsAtomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\n⊢ IsAtomic (OrderDual α)","decl":"instance _root_.OrderDual.instIsAtomic : IsAtomic αᵒᵈ :=\n  isAtomic_dual_iff_isCoatomic.2 ‹IsCoatomic α›\n\n"}
{"name":"IsCoatomic.Set.Ici.isCoatomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : OrderTop α\ninst✝ : IsCoatomic α\nx : α\n⊢ IsCoatomic ↑(Set.Ici x)","decl":"instance Set.Ici.isCoatomic {x : α} : IsCoatomic (Set.Ici x) :=\n  ⟨fun ⟨y, hy⟩ =>\n    (eq_top_or_exists_le_coatom y).imp Subtype.mk_eq_mk.2 fun ⟨a, ha, hay⟩ =>\n      ⟨⟨a, le_trans hy hay⟩, ha.Ici (le_trans hy hay), hay⟩⟩\n\n"}
{"name":"isAtomic_iff_forall_isAtomic_Iic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\n⊢ Iff (IsAtomic α) (∀ (x : α), IsAtomic ↑(Set.Iic x))","decl":"theorem isAtomic_iff_forall_isAtomic_Iic [OrderBot α] :\n    IsAtomic α ↔ ∀ x : α, IsAtomic (Set.Iic x) :=\n  ⟨@IsAtomic.Set.Iic.isAtomic _ _ _, fun h =>\n    ⟨fun x =>\n      ((@eq_bot_or_exists_atom_le _ _ _ (h x)) (⊤ : Set.Iic x)).imp Subtype.mk_eq_mk.1\n        (Exists.imp' (↑) fun ⟨_, _⟩ => And.imp_left IsAtom.of_isAtom_coe_Iic)⟩⟩\n\n"}
{"name":"isCoatomic_iff_forall_isCoatomic_Ici","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\n⊢ Iff (IsCoatomic α) (∀ (x : α), IsCoatomic ↑(Set.Ici x))","decl":"theorem isCoatomic_iff_forall_isCoatomic_Ici [OrderTop α] :\n    IsCoatomic α ↔ ∀ x : α, IsCoatomic (Set.Ici x) :=\n  isAtomic_dual_iff_isCoatomic.symm.trans <|\n    isAtomic_iff_forall_isAtomic_Iic.trans <|\n      forall_congr' fun _ => isCoatomic_dual_iff_isAtomic.symm.trans Iff.rfl\n\n"}
{"name":"isStronglyAtomic_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_5\ninst✝ : Preorder α\n⊢ Iff (IsStronglyAtomic α) (∀ (a b : α), LT.lt a b → Exists fun x => And (CovBy a x) (LE.le x b))","decl":"/-- An order is strongly atomic if every nontrivial interval `[a, b]`\ncontains an element covering `a`. -/\n@[mk_iff]\nclass IsStronglyAtomic (α : Type*) [Preorder α] : Prop where\n  exists_covBy_le_of_lt : ∀ (a b : α), a < b → ∃ x, a ⋖ x ∧ x ≤ b\n\n"}
{"name":"IsStronglyAtomic.exists_covBy_le_of_lt","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_5\ninst✝ : Preorder α\nself : IsStronglyAtomic α\na b : α\na✝ : LT.lt a b\n⊢ Exists fun x => And (CovBy a x) (LE.le x b)","decl":"/-- An order is strongly atomic if every nontrivial interval `[a, b]`\ncontains an element covering `a`. -/\n@[mk_iff]\nclass IsStronglyAtomic (α : Type*) [Preorder α] : Prop where\n  exists_covBy_le_of_lt : ∀ (a b : α), a < b → ∃ x, a ⋖ x ∧ x ≤ b\n\n"}
{"name":"exists_covBy_le_of_lt","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\na b : α\ninst✝¹ : Preorder α\ninst✝ : IsStronglyAtomic α\nh : LT.lt a b\n⊢ Exists fun x => And (CovBy a x) (LE.le x b)","decl":"theorem exists_covBy_le_of_lt [IsStronglyAtomic α] (h : a < b) : ∃ x, a ⋖ x ∧ x ≤ b :=\n  IsStronglyAtomic.exists_covBy_le_of_lt a b h\n\n"}
{"name":"LT.lt.exists_covby_le","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\na b : α\ninst✝¹ : Preorder α\ninst✝ : IsStronglyAtomic α\nh : LT.lt a b\n⊢ Exists fun x => And (CovBy a x) (LE.le x b)","decl":"alias LT.lt.exists_covby_le := exists_covBy_le_of_lt\n\n"}
{"name":"IsStronglyCoatomic.exists_le_covBy_of_lt","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_5\ninst✝ : Preorder α\nself : IsStronglyCoatomic α\na b : α\na✝ : LT.lt a b\n⊢ Exists fun x => And (LE.le a x) (CovBy x b)","decl":"/-- An order is strongly coatomic if every nontrivial interval `[a, b]`\ncontains an element covered by `b`. -/\n@[mk_iff]\nclass IsStronglyCoatomic (α : Type*) [Preorder α] : Prop where\n  (exists_le_covBy_of_lt : ∀ (a b : α), a < b → ∃ x, a ≤ x ∧ x ⋖ b)\n\n"}
{"name":"isStronglyCoatomic_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_5\ninst✝ : Preorder α\n⊢ Iff (IsStronglyCoatomic α) (∀ (a b : α), LT.lt a b → Exists fun x => And (LE.le a x) (CovBy x b))","decl":"/-- An order is strongly coatomic if every nontrivial interval `[a, b]`\ncontains an element covered by `b`. -/\n@[mk_iff]\nclass IsStronglyCoatomic (α : Type*) [Preorder α] : Prop where\n  (exists_le_covBy_of_lt : ∀ (a b : α), a < b → ∃ x, a ≤ x ∧ x ⋖ b)\n\n"}
{"name":"exists_le_covBy_of_lt","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\na b : α\ninst✝¹ : Preorder α\ninst✝ : IsStronglyCoatomic α\nh : LT.lt a b\n⊢ Exists fun x => And (LE.le a x) (CovBy x b)","decl":"theorem exists_le_covBy_of_lt [IsStronglyCoatomic α] (h : a < b) : ∃ x, a ≤ x ∧ x ⋖ b :=\n  IsStronglyCoatomic.exists_le_covBy_of_lt a b h\n\n"}
{"name":"LT.lt.exists_le_covby","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\na b : α\ninst✝¹ : Preorder α\ninst✝ : IsStronglyCoatomic α\nh : LT.lt a b\n⊢ Exists fun x => And (LE.le a x) (CovBy x b)","decl":"alias LT.lt.exists_le_covby := exists_le_covBy_of_lt\n\n"}
{"name":"isStronglyAtomic_dual_iff_is_stronglyCoatomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\ninst✝ : Preorder α\n⊢ Iff (IsStronglyAtomic (OrderDual α)) (IsStronglyCoatomic α)","decl":"theorem isStronglyAtomic_dual_iff_is_stronglyCoatomic :\n    IsStronglyAtomic αᵒᵈ ↔ IsStronglyCoatomic α := by\n  simpa [isStronglyAtomic_iff, OrderDual.exists, OrderDual.forall,\n    OrderDual.toDual_le_toDual, and_comm, isStronglyCoatomic_iff] using forall_comm\n\n"}
{"name":"isStronglyCoatomic_dual_iff_is_stronglyAtomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\ninst✝ : Preorder α\n⊢ Iff (IsStronglyCoatomic (OrderDual α)) (IsStronglyAtomic α)","decl":"@[simp] theorem isStronglyCoatomic_dual_iff_is_stronglyAtomic :\n    IsStronglyCoatomic αᵒᵈ ↔ IsStronglyAtomic α := by\n  rw [← isStronglyAtomic_dual_iff_is_stronglyCoatomic]; rfl\n\n"}
{"name":"OrderDual.instIsStronglyCoatomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\ninst✝¹ : Preorder α\ninst✝ : IsStronglyAtomic α\n⊢ IsStronglyCoatomic (OrderDual α)","decl":"instance OrderDual.instIsStronglyCoatomic [IsStronglyAtomic α] : IsStronglyCoatomic αᵒᵈ := by\n  rwa [isStronglyCoatomic_dual_iff_is_stronglyAtomic]\n\n"}
{"name":"instIsStronglyAtomicOrderDualOfIsStronglyCoatomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\ninst✝¹ : Preorder α\ninst✝ : IsStronglyCoatomic α\n⊢ IsStronglyAtomic (OrderDual α)","decl":"instance [IsStronglyCoatomic α] : IsStronglyAtomic αᵒᵈ := by\n  rwa [isStronglyAtomic_dual_iff_is_stronglyCoatomic]\n\n"}
{"name":"IsStronglyAtomic.isAtomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_5\ninst✝² : PartialOrder α\ninst✝¹ : OrderBot α\ninst✝ : IsStronglyAtomic α\n⊢ IsAtomic α","decl":"instance IsStronglyAtomic.isAtomic (α : Type*) [PartialOrder α] [OrderBot α] [IsStronglyAtomic α] :\n    IsAtomic α where\n  eq_bot_or_exists_atom_le a := by\n    rw [or_iff_not_imp_left, ← Ne, ← bot_lt_iff_ne_bot]\n    refine fun hlt ↦ ?_\n    obtain ⟨x, hx, hxa⟩ := hlt.exists_covby_le\n    exact ⟨x, bot_covBy_iff.1 hx, hxa⟩\n\n"}
{"name":"IsStronglyCoatomic.toIsCoatomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_5\ninst✝² : PartialOrder α\ninst✝¹ : OrderTop α\ninst✝ : IsStronglyCoatomic α\n⊢ IsCoatomic α","decl":"instance IsStronglyCoatomic.toIsCoatomic (α : Type*) [PartialOrder α] [OrderTop α]\n    [IsStronglyCoatomic α] : IsCoatomic α :=\n  isAtomic_dual_iff_isCoatomic.1 <| IsStronglyAtomic.isAtomic (α := αᵒᵈ)\n\n"}
{"name":"Set.OrdConnected.isStronglyAtomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\ninst✝¹ : Preorder α\ninst✝ : IsStronglyAtomic α\ns : Set α\nh : s.OrdConnected\n⊢ IsStronglyAtomic ↑s","decl":"theorem Set.OrdConnected.isStronglyAtomic [IsStronglyAtomic α] {s : Set α}\n    (h : Set.OrdConnected s) : IsStronglyAtomic s where\n  exists_covBy_le_of_lt := by\n    rintro ⟨c, hc⟩ ⟨d, hd⟩ hcd\n    obtain ⟨x, hcx, hxd⟩ := (Subtype.mk_lt_mk.1 hcd).exists_covby_le\n    exact ⟨⟨x, h.out' hc hd ⟨hcx.le, hxd⟩⟩,\n      ⟨by simpa using hcx.lt, fun y hy hy' ↦ hcx.2 (by simpa using hy) (by simpa using hy')⟩, hxd⟩\n\n"}
{"name":"Set.OrdConnected.isStronglyCoatomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\ninst✝¹ : Preorder α\ninst✝ : IsStronglyCoatomic α\ns : Set α\nh : s.OrdConnected\n⊢ IsStronglyCoatomic ↑s","decl":"theorem Set.OrdConnected.isStronglyCoatomic [IsStronglyCoatomic α] {s : Set α}\n    (h : Set.OrdConnected s) : IsStronglyCoatomic s :=\n  isStronglyAtomic_dual_iff_is_stronglyCoatomic.1 h.dual.isStronglyAtomic\n\n"}
{"name":"instIsStronglyAtomicElemOfOrdConnected","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\ninst✝² : Preorder α\ninst✝¹ : IsStronglyAtomic α\ns : Set α\ninst✝ : s.OrdConnected\n⊢ IsStronglyAtomic ↑s","decl":"instance [IsStronglyAtomic α] {s : Set α} [Set.OrdConnected s] : IsStronglyAtomic s :=\n  Set.OrdConnected.isStronglyAtomic <| by assumption\n\n"}
{"name":"instIsStronglyCoatomicElemOfOrdConnected","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\ninst✝¹ : Preorder α\ninst✝ : IsStronglyCoatomic α\ns : Set α\nh : s.OrdConnected\n⊢ IsStronglyCoatomic ↑s","decl":"instance [IsStronglyCoatomic α] {s : Set α} [h : Set.OrdConnected s] : IsStronglyCoatomic s :=\n  Set.OrdConnected.isStronglyCoatomic <| by assumption\n\n"}
{"name":"SuccOrder.toIsStronglyAtomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\n⊢ IsStronglyAtomic α","decl":"instance SuccOrder.toIsStronglyAtomic [SuccOrder α] : IsStronglyAtomic α where\n  exists_covBy_le_of_lt a _ hab :=\n    ⟨SuccOrder.succ a, Order.covBy_succ_of_not_isMax fun ha ↦ ha.not_lt hab,\n      SuccOrder.succ_le_of_lt hab⟩\n\n"}
{"name":"instIsStronglyCoatomicOfPredOrder","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\n⊢ IsStronglyCoatomic α","decl":"instance [PredOrder α] : IsStronglyCoatomic α := by\n  rw [← isStronglyAtomic_dual_iff_is_stronglyCoatomic]; infer_instance\n\n"}
{"name":"IsStronglyAtomic.of_wellFounded_lt","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\nh : WellFounded fun x1 x2 => LT.lt x1 x2\n⊢ IsStronglyAtomic α","decl":"theorem IsStronglyAtomic.of_wellFounded_lt (h : WellFounded ((· < ·) : α → α → Prop)) :\n    IsStronglyAtomic α where\n  exists_covBy_le_of_lt a b hab := by\n    refine ⟨WellFounded.min h (Set.Ioc a b) ⟨b, hab,rfl.le⟩, ?_⟩\n    have hmem := (WellFounded.min_mem h (Set.Ioc a b) ⟨b, hab,rfl.le⟩)\n    exact ⟨⟨hmem.1,fun c hac hlt ↦ WellFounded.not_lt_min h\n      (Set.Ioc a b) ⟨b, hab,rfl.le⟩ ⟨hac, hlt.le.trans hmem.2⟩ hlt ⟩, hmem.2⟩\n\n"}
{"name":"IsStronglyCoatomic.of_wellFounded_gt","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\nh : WellFounded fun x1 x2 => GT.gt x1 x2\n⊢ IsStronglyCoatomic α","decl":"theorem IsStronglyCoatomic.of_wellFounded_gt (h : WellFounded ((· > ·) : α → α → Prop)) :\n    IsStronglyCoatomic α :=\n  isStronglyAtomic_dual_iff_is_stronglyCoatomic.1 <| IsStronglyAtomic.of_wellFounded_lt (α := αᵒᵈ) h\n\n"}
{"name":"instIsStronglyAtomicOfWellFoundedLT","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : WellFoundedLT α\n⊢ IsStronglyAtomic α","decl":"instance [WellFoundedLT α] : IsStronglyAtomic α :=\n  IsStronglyAtomic.of_wellFounded_lt wellFounded_lt\n\n"}
{"name":"instIsStronglyCoatomicOfWellFoundedGT","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : WellFoundedGT α\n⊢ IsStronglyCoatomic α","decl":"instance [WellFoundedGT α] : IsStronglyCoatomic α :=\n    IsStronglyCoatomic.of_wellFounded_gt wellFounded_gt\n\n"}
{"name":"isAtomic_of_orderBot_wellFounded_lt","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\nh : WellFounded fun x1 x2 => LT.lt x1 x2\n⊢ IsAtomic α","decl":"theorem isAtomic_of_orderBot_wellFounded_lt [OrderBot α]\n    (h : WellFounded ((· < ·) : α → α → Prop)) : IsAtomic α :=\n  (IsStronglyAtomic.of_wellFounded_lt h).isAtomic\n\n"}
{"name":"isCoatomic_of_orderTop_gt_wellFounded","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\nh : WellFounded fun x1 x2 => GT.gt x1 x2\n⊢ IsCoatomic α","decl":"theorem isCoatomic_of_orderTop_gt_wellFounded [OrderTop α]\n    (h : WellFounded ((· > ·) : α → α → Prop)) : IsCoatomic α :=\n  isAtomic_dual_iff_isCoatomic.1 (@isAtomic_of_orderBot_wellFounded_lt αᵒᵈ _ _ h)\n\n"}
{"name":"BooleanAlgebra.le_iff_atom_le_imp","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\ninst✝¹ : BooleanAlgebra α\ninst✝ : IsAtomic α\nx y : α\n⊢ Iff (LE.le x y) (∀ (a : α), IsAtom a → LE.le a x → LE.le a y)","decl":"theorem le_iff_atom_le_imp {α} [BooleanAlgebra α] [IsAtomic α] {x y : α} :\n    x ≤ y ↔ ∀ a, IsAtom a → a ≤ x → a ≤ y := by\n  refine ⟨fun h a _ => (le_trans · h), fun h => ?_⟩\n  have : x ⊓ yᶜ = ⊥ := of_not_not fun hbot =>\n    have ⟨a, ha, hle⟩ := (eq_bot_or_exists_atom_le _).resolve_left hbot\n    have ⟨hx, hy'⟩ := le_inf_iff.1 hle\n    have hy := h a ha hx\n    have : a ≤ y ⊓ yᶜ := le_inf_iff.2 ⟨hy, hy'⟩\n    ha.1 (by simpa using this)\n  exact (eq_compl_iff_isCompl.1 (by simp)).inf_right_eq_bot_iff.1 this\n\n"}
{"name":"BooleanAlgebra.eq_iff_atom_le_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\ninst✝¹ : BooleanAlgebra α\ninst✝ : IsAtomic α\nx y : α\n⊢ Iff (Eq x y) (∀ (a : α), IsAtom a → Iff (LE.le a x) (LE.le a y))","decl":"theorem eq_iff_atom_le_iff {α} [BooleanAlgebra α] [IsAtomic α] {x y : α} :\n    x = y ↔ ∀ a, IsAtom a → (a ≤ x ↔ a ≤ y) := by\n  refine ⟨fun h => h ▸ by simp, fun h => ?_⟩\n  exact le_antisymm (le_iff_atom_le_imp.2 fun a ha hx => (h a ha).1 hx)\n    (le_iff_atom_le_imp.2 fun a ha hy => (h a ha).2 hy)\n\n"}
{"name":"IsAtomistic.eq_sSup_atoms","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\nself : IsAtomistic α\nb : α\n⊢ Exists fun s => And (Eq b (SupSet.sSup s)) (∀ (a : α), Membership.mem s a → IsAtom a)","decl":"/-- A lattice is atomistic iff every element is a `sSup` of a set of atoms. -/\nclass IsAtomistic : Prop where\n  /-- Every element is a `sSup` of a set of atoms. -/\n  eq_sSup_atoms : ∀ b : α, ∃ s : Set α, b = sSup s ∧ ∀ a, a ∈ s → IsAtom a\n\n"}
{"name":"IsCoatomistic.eq_sInf_coatoms","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\nself : IsCoatomistic α\nb : α\n⊢ Exists fun s => And (Eq b (InfSet.sInf s)) (∀ (a : α), Membership.mem s a → IsCoatom a)","decl":"/-- A lattice is coatomistic iff every element is an `sInf` of a set of coatoms. -/\nclass IsCoatomistic : Prop where\n  /-- Every element is a `sInf` of a set of coatoms. -/\n  eq_sInf_coatoms : ∀ b : α, ∃ s : Set α, b = sInf s ∧ ∀ a, a ∈ s → IsCoatom a\n\n"}
{"name":"isCoatomistic_dual_iff_isAtomistic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\n⊢ Iff (IsCoatomistic (OrderDual α)) (IsAtomistic α)","decl":"@[simp]\ntheorem isCoatomistic_dual_iff_isAtomistic : IsCoatomistic αᵒᵈ ↔ IsAtomistic α :=\n  ⟨fun h => ⟨fun b => by apply h.eq_sInf_coatoms⟩, fun h => ⟨fun b => by apply h.eq_sSup_atoms⟩⟩\n\n"}
{"name":"isAtomistic_dual_iff_isCoatomistic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\n⊢ Iff (IsAtomistic (OrderDual α)) (IsCoatomistic α)","decl":"@[simp]\ntheorem isAtomistic_dual_iff_isCoatomistic : IsAtomistic αᵒᵈ ↔ IsCoatomistic α :=\n  ⟨fun h => ⟨fun b => by apply h.eq_sSup_atoms⟩, fun h => ⟨fun b => by apply h.eq_sInf_coatoms⟩⟩\n\n"}
{"name":"OrderDual.instIsCoatomistic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\nh : IsAtomistic α\n⊢ IsCoatomistic (OrderDual α)","decl":"instance _root_.OrderDual.instIsCoatomistic [h : IsAtomistic α] : IsCoatomistic αᵒᵈ :=\n  isCoatomistic_dual_iff_isAtomistic.2 h\n\n"}
{"name":"IsAtomistic.instIsAtomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\n⊢ IsAtomic α","decl":"instance (priority := 100) : IsAtomic α :=\n  ⟨fun b => by\n    rcases eq_sSup_atoms b with ⟨s, rfl, hs⟩\n    rcases s.eq_empty_or_nonempty with h | h\n    · simp [h]\n    · exact Or.intro_right _ ⟨h.some, hs _ h.choose_spec, le_sSup h.choose_spec⟩⟩\n\n"}
{"name":"sSup_atoms_le_eq","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : IsAtomistic α\nb : α\n⊢ Eq (SupSet.sSup (setOf fun a => And (IsAtom a) (LE.le a b))) b","decl":"@[simp]\ntheorem sSup_atoms_le_eq (b : α) : sSup { a : α | IsAtom a ∧ a ≤ b } = b := by\n  rcases eq_sSup_atoms b with ⟨s, rfl, hs⟩\n  exact le_antisymm (sSup_le fun _ => And.right) (sSup_le_sSup fun a ha => ⟨hs a ha, le_sSup ha⟩)\n\n"}
{"name":"sSup_atoms_eq_top","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : IsAtomistic α\n⊢ Eq (SupSet.sSup (setOf fun a => IsAtom a)) Top.top","decl":"@[simp]\ntheorem sSup_atoms_eq_top : sSup { a : α | IsAtom a } = ⊤ := by\n  refine Eq.trans (congr rfl (Set.ext fun x => ?_)) (sSup_atoms_le_eq ⊤)\n  exact (and_iff_left le_top).symm\n\n"}
{"name":"le_iff_atom_le_imp","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : IsAtomistic α\na b : α\n⊢ Iff (LE.le a b) (∀ (c : α), IsAtom c → LE.le c a → LE.le c b)","decl":"theorem le_iff_atom_le_imp {a b : α} : a ≤ b ↔ ∀ c : α, IsAtom c → c ≤ a → c ≤ b :=\n  ⟨fun ab _ _ ca => le_trans ca ab, fun h => by\n    rw [← sSup_atoms_le_eq a, ← sSup_atoms_le_eq b]\n    exact sSup_le_sSup fun c hc => ⟨hc.1, h c hc.1 hc.2⟩⟩\n\n"}
{"name":"eq_iff_atom_le_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : IsAtomistic α\na b : α\n⊢ Iff (Eq a b) (∀ (c : α), IsAtom c → Iff (LE.le c a) (LE.le c b))","decl":"theorem eq_iff_atom_le_iff {a b : α} : a = b ↔ ∀ c, IsAtom c → (c ≤ a ↔ c ≤ b) := by\n  refine ⟨fun h => h ▸ by simp, fun h => ?_⟩\n  exact le_antisymm (le_iff_atom_le_imp.2 fun a ha hx => (h a ha).1 hx)\n    (le_iff_atom_le_imp.2 fun a ha hy => (h a ha).2 hy)\n\n"}
{"name":"OrderDual.instIsAtomistic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\nh : IsCoatomistic α\n⊢ IsAtomistic (OrderDual α)","decl":"instance _root_.OrderDual.instIsAtomistic [h : IsCoatomistic α] : IsAtomistic αᵒᵈ :=\n  isAtomistic_dual_iff_isCoatomistic.2 h\n\n"}
{"name":"IsCoatomistic.instIsCoatomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\n⊢ IsCoatomic α","decl":"instance (priority := 100) : IsCoatomic α :=\n  ⟨fun b => by\n    rcases eq_sInf_coatoms b with ⟨s, rfl, hs⟩\n    rcases s.eq_empty_or_nonempty with h | h\n    · simp [h]\n    · exact Or.intro_right _ ⟨h.some, hs _ h.choose_spec, sInf_le h.choose_spec⟩⟩\n\n"}
{"name":"CompleteAtomicBooleanAlgebra.instIsAtomistic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\ninst✝ : CompleteAtomicBooleanAlgebra α\n⊢ IsAtomistic α","decl":"instance {α} [CompleteAtomicBooleanAlgebra α] : IsAtomistic α where\n  eq_sSup_atoms b := by\n    inhabit α\n    refine ⟨{ a | IsAtom a ∧ a ≤ b }, ?_, fun a ha => ha.1⟩\n    refine le_antisymm ?_ (sSup_le fun c hc => hc.2)\n    have : (⨅ c : α, ⨆ x, b ⊓ cond x c (cᶜ)) = b := by simp [iSup_bool_eq, iInf_const]\n    rw [← this]; clear this\n    simp_rw [iInf_iSup_eq, iSup_le_iff]; intro g\n    if h : (⨅ a, b ⊓ cond (g a) a (aᶜ)) = ⊥ then simp [h] else\n    refine le_sSup ⟨⟨h, fun c hc => ?_⟩, le_trans (by rfl) (le_iSup _ g)⟩; clear h\n    have := lt_of_lt_of_le hc (le_trans (iInf_le _ c) inf_le_right)\n    revert this\n    nontriviality α\n    cases g c <;> simp\n\n"}
{"name":"CompleteAtomicBooleanAlgebra.instIsCoatomistic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\ninst✝ : CompleteAtomicBooleanAlgebra α\n⊢ IsCoatomistic α","decl":"instance {α} [CompleteAtomicBooleanAlgebra α] : IsCoatomistic α :=\n  isAtomistic_dual_iff_isCoatomistic.1 inferInstance\n\n"}
{"name":"IsSimpleOrder.eq_bot_or_eq_top","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\ninst✝¹ : LE α\ninst✝ : BoundedOrder α\nself : IsSimpleOrder α\na : α\n⊢ Or (Eq a Bot.bot) (Eq a Top.top)","decl":"/-- An order is simple iff it has exactly two elements, `⊥` and `⊤`. -/\nclass IsSimpleOrder (α : Type*) [LE α] [BoundedOrder α] extends Nontrivial α : Prop where\n  /-- Every element is either `⊥` or `⊤` -/\n  eq_bot_or_eq_top : ∀ a : α, a = ⊥ ∨ a = ⊤\n\n"}
{"name":"IsSimpleOrder.toNontrivial","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\ninst✝¹ : LE α\ninst✝ : BoundedOrder α\nself : IsSimpleOrder α\n⊢ Nontrivial α","decl":"/-- An order is simple iff it has exactly two elements, `⊥` and `⊤`. -/\nclass IsSimpleOrder (α : Type*) [LE α] [BoundedOrder α] extends Nontrivial α : Prop where\n  /-- Every element is either `⊥` or `⊤` -/\n  eq_bot_or_eq_top : ∀ a : α, a = ⊥ ∨ a = ⊤\n\n"}
{"name":"isSimpleOrder_iff_isSimpleOrder_orderDual","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : LE α\ninst✝ : BoundedOrder α\n⊢ Iff (IsSimpleOrder α) (IsSimpleOrder (OrderDual α))","decl":"theorem isSimpleOrder_iff_isSimpleOrder_orderDual [LE α] [BoundedOrder α] :\n    IsSimpleOrder α ↔ IsSimpleOrder αᵒᵈ := by\n  constructor <;> intro i <;> haveI := i\n  · exact\n      { exists_pair_ne := @exists_pair_ne α _\n        eq_bot_or_eq_top := fun a => Or.symm (eq_bot_or_eq_top (OrderDual.ofDual a) : _ ∨ _) }\n  · exact\n      { exists_pair_ne := @exists_pair_ne αᵒᵈ _\n        eq_bot_or_eq_top := fun a => Or.symm (eq_bot_or_eq_top (OrderDual.toDual a)) }\n\n"}
{"name":"IsSimpleOrder.bot_ne_top","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝² : LE α\ninst✝¹ : BoundedOrder α\ninst✝ : IsSimpleOrder α\n⊢ Ne Bot.bot Top.top","decl":"theorem IsSimpleOrder.bot_ne_top [LE α] [BoundedOrder α] [IsSimpleOrder α] : (⊥ : α) ≠ (⊤ : α) := by\n  obtain ⟨a, b, h⟩ := exists_pair_ne α\n  rcases eq_bot_or_eq_top a with (rfl | rfl) <;> rcases eq_bot_or_eq_top b with (rfl | rfl) <;>\n    first |simpa|simpa using h.symm\n\n"}
{"name":"OrderDual.instIsSimpleOrder","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\ninst✝² : LE α\ninst✝¹ : BoundedOrder α\ninst✝ : IsSimpleOrder α\n⊢ IsSimpleOrder (OrderDual α)","decl":"instance OrderDual.instIsSimpleOrder {α} [LE α] [BoundedOrder α] [IsSimpleOrder α] :\n    IsSimpleOrder αᵒᵈ := isSimpleOrder_iff_isSimpleOrder_orderDual.1 (by infer_instance)\n\n"}
{"name":"isAtom_top","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : BoundedOrder α\ninst✝ : IsSimpleOrder α\n⊢ IsAtom Top.top","decl":"@[simp]\ntheorem isAtom_top : IsAtom (⊤ : α) :=\n  ⟨top_ne_bot, fun a ha => Or.resolve_right (eq_bot_or_eq_top a) (ne_of_lt ha)⟩\n\n"}
{"name":"isCoatom_bot","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : BoundedOrder α\ninst✝ : IsSimpleOrder α\n⊢ IsCoatom Bot.bot","decl":"@[simp]\ntheorem isCoatom_bot : IsCoatom (⊥ : α) :=\n  isAtom_dual_iff_isCoatom.1 isAtom_top\n\n"}
{"name":"bot_covBy_top","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : BoundedOrder α\ninst✝ : IsSimpleOrder α\n⊢ CovBy Bot.bot Top.top","decl":"theorem bot_covBy_top : (⊥ : α) ⋖ ⊤ :=\n  isAtom_top.bot_covBy\n\n"}
{"name":"IsSimpleOrder.eq_bot_of_lt","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : BoundedOrder α\ninst✝ : IsSimpleOrder α\na b : α\nh : LT.lt a b\n⊢ Eq a Bot.bot","decl":"theorem eq_bot_of_lt : a = ⊥ :=\n  (IsSimpleOrder.eq_bot_or_eq_top _).resolve_right h.ne_top\n\n"}
{"name":"IsSimpleOrder.eq_top_of_lt","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : BoundedOrder α\ninst✝ : IsSimpleOrder α\na b : α\nh : LT.lt a b\n⊢ Eq b Top.top","decl":"theorem eq_top_of_lt : b = ⊤ :=\n  (IsSimpleOrder.eq_bot_or_eq_top _).resolve_left h.ne_bot\n\n"}
{"name":"LT.lt.eq_bot","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : BoundedOrder α\ninst✝ : IsSimpleOrder α\na b : α\nh : LT.lt a b\n⊢ Eq a Bot.bot","decl":"alias _root_.LT.lt.eq_bot := eq_bot_of_lt\n"}
{"name":"LT.lt.eq_top","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : BoundedOrder α\ninst✝ : IsSimpleOrder α\na b : α\nh : LT.lt a b\n⊢ Eq b Top.top","decl":"alias _root_.LT.lt.eq_top := eq_top_of_lt\n"}
{"name":"IsSimpleOrder.instIsAtomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝² : Lattice α\ninst✝¹ : BoundedOrder α\ninst✝ : IsSimpleOrder α\n⊢ IsAtomic α","decl":"instance (priority := 100) : IsAtomic α :=\n  ⟨fun b => (eq_bot_or_eq_top b).imp_right fun h => ⟨⊤, ⟨isAtom_top, ge_of_eq h⟩⟩⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"IsSimpleOrder.instIsCoatomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : Lattice α\ninst✝ : BoundedOrder α\n⊢ IsCoatomic α","decl":"instance (priority := 100) : IsCoatomic α :=\n  isAtomic_dual_iff_isCoatomic.1 (by infer_instance)\n\n"}
{"name":"IsSimpleOrder.equivBool_symm_apply","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\ninst✝³ : DecidableEq α\ninst✝² : LE α\ninst✝¹ : BoundedOrder α\ninst✝ : IsSimpleOrder α\nx : Bool\n⊢ Eq (IsSimpleOrder.equivBool.symm x) (Bool.casesOn x Bot.bot Top.top)","decl":"/-- Every simple lattice is isomorphic to `Bool`, regardless of order. -/\n@[simps]\ndef equivBool {α} [DecidableEq α] [LE α] [BoundedOrder α] [IsSimpleOrder α] : α ≃ Bool where\n  toFun x := x = ⊤\n  invFun x := x.casesOn ⊥ ⊤\n  left_inv x := by rcases eq_bot_or_eq_top x with (rfl | rfl) <;> simp [bot_ne_top]\n  right_inv x := by cases x <;> simp [bot_ne_top]\n\n"}
{"name":"IsSimpleOrder.equivBool_apply","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_4\ninst✝³ : DecidableEq α\ninst✝² : LE α\ninst✝¹ : BoundedOrder α\ninst✝ : IsSimpleOrder α\nx : α\n⊢ Eq (IsSimpleOrder.equivBool x) (Decidable.decide (Eq x Top.top))","decl":"/-- Every simple lattice is isomorphic to `Bool`, regardless of order. -/\n@[simps]\ndef equivBool {α} [DecidableEq α] [LE α] [BoundedOrder α] [IsSimpleOrder α] : α ≃ Bool where\n  toFun x := x = ⊤\n  invFun x := x.casesOn ⊥ ⊤\n  left_inv x := by rcases eq_bot_or_eq_top x with (rfl | rfl) <;> simp [bot_ne_top]\n  right_inv x := by cases x <;> simp [bot_ne_top]\n\n"}
{"name":"IsSimpleOrder.instComplementedLattice","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝² : Lattice α\ninst✝¹ : BoundedOrder α\ninst✝ : IsSimpleOrder α\n⊢ ComplementedLattice α","decl":"instance : ComplementedLattice α :=\n  letI := IsSimpleOrder.completeBooleanAlgebra (α := α); inferInstance\n\n"}
{"name":"IsSimpleOrder.instIsAtomistic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : IsSimpleOrder α\n⊢ IsAtomistic α","decl":"instance (priority := 100) : IsAtomistic α :=\n  ⟨fun b =>\n    (eq_bot_or_eq_top b).elim\n      (fun h => ⟨∅, ⟨h.trans sSup_empty.symm, fun _ ha => False.elim (Set.not_mem_empty _ ha)⟩⟩)\n      fun h =>\n      ⟨{⊤}, h.trans sSup_singleton.symm, fun _ ha =>\n        (Set.mem_singleton_iff.1 ha).symm ▸ isAtom_top⟩⟩\n\n"}
{"name":"IsSimpleOrder.instIsCoatomistic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\n⊢ IsCoatomistic α","decl":"instance : IsCoatomistic α :=\n  isAtomistic_dual_iff_isCoatomistic.1 (by infer_instance)\n\n"}
{"name":"isSimpleOrder_iff_isAtom_top","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : BoundedOrder α\n⊢ Iff (IsSimpleOrder α) (IsAtom Top.top)","decl":"theorem isSimpleOrder_iff_isAtom_top [PartialOrder α] [BoundedOrder α] :\n    IsSimpleOrder α ↔ IsAtom (⊤ : α) :=\n  ⟨fun h => @isAtom_top _ _ _ h, fun h =>\n    { exists_pair_ne := ⟨⊤, ⊥, h.1⟩\n      eq_bot_or_eq_top := fun a => ((eq_or_lt_of_le le_top).imp_right (h.2 a)).symm }⟩\n\n"}
{"name":"isSimpleOrder_iff_isCoatom_bot","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : BoundedOrder α\n⊢ Iff (IsSimpleOrder α) (IsCoatom Bot.bot)","decl":"theorem isSimpleOrder_iff_isCoatom_bot [PartialOrder α] [BoundedOrder α] :\n    IsSimpleOrder α ↔ IsCoatom (⊥ : α) :=\n  isSimpleOrder_iff_isSimpleOrder_orderDual.trans isSimpleOrder_iff_isAtom_top\n\n"}
{"name":"Set.isSimpleOrder_Iic_iff_isAtom","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na : α\n⊢ Iff (IsSimpleOrder ↑(Set.Iic a)) (IsAtom a)","decl":"theorem isSimpleOrder_Iic_iff_isAtom [PartialOrder α] [OrderBot α] {a : α} :\n    IsSimpleOrder (Iic a) ↔ IsAtom a :=\n  isSimpleOrder_iff_isAtom_top.trans <|\n    and_congr (not_congr Subtype.mk_eq_mk)\n      ⟨fun h b ab => Subtype.mk_eq_mk.1 (h ⟨b, le_of_lt ab⟩ ab), fun h ⟨b, _⟩ hbotb =>\n        Subtype.mk_eq_mk.2 (h b (Subtype.mk_lt_mk.1 hbotb))⟩\n\n"}
{"name":"Set.isSimpleOrder_Ici_iff_isCoatom","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na : α\n⊢ Iff (IsSimpleOrder ↑(Set.Ici a)) (IsCoatom a)","decl":"theorem isSimpleOrder_Ici_iff_isCoatom [PartialOrder α] [OrderTop α] {a : α} :\n    IsSimpleOrder (Ici a) ↔ IsCoatom a :=\n  isSimpleOrder_iff_isCoatom_bot.trans <|\n    and_congr (not_congr Subtype.mk_eq_mk)\n      ⟨fun h b ab => Subtype.mk_eq_mk.1 (h ⟨b, le_of_lt ab⟩ ab), fun h ⟨b, _⟩ hbotb =>\n        Subtype.mk_eq_mk.2 (h b (Subtype.mk_lt_mk.1 hbotb))⟩\n\n"}
{"name":"OrderEmbedding.isAtom_of_map_bot_of_image","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : PartialOrder α\ninst✝² : PartialOrder β\ninst✝¹ : OrderBot α\ninst✝ : OrderBot β\nf : OrderEmbedding β α\nhbot : Eq (f Bot.bot) Bot.bot\nb : β\nhb : IsAtom (f b)\n⊢ IsAtom b","decl":"theorem isAtom_of_map_bot_of_image [OrderBot α] [OrderBot β] (f : β ↪o α) (hbot : f ⊥ = ⊥) {b : β}\n    (hb : IsAtom (f b)) : IsAtom b := by\n  simp only [← bot_covBy_iff] at hb ⊢\n  exact CovBy.of_image f (hbot.symm ▸ hb)\n\n"}
{"name":"OrderEmbedding.isCoatom_of_map_top_of_image","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : PartialOrder α\ninst✝² : PartialOrder β\ninst✝¹ : OrderTop α\ninst✝ : OrderTop β\nf : OrderEmbedding β α\nhtop : Eq (f Top.top) Top.top\nb : β\nhb : IsCoatom (f b)\n⊢ IsCoatom b","decl":"theorem isCoatom_of_map_top_of_image [OrderTop α] [OrderTop β] (f : β ↪o α) (htop : f ⊤ = ⊤)\n    {b : β} (hb : IsCoatom (f b)) : IsCoatom b :=\n  f.dual.isAtom_of_map_bot_of_image htop hb\n\n"}
{"name":"GaloisInsertion.isAtom_of_u_bot","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : PartialOrder α\ninst✝² : PartialOrder β\ninst✝¹ : OrderBot α\ninst✝ : OrderBot β\nl : α → β\nu : β → α\ngi : GaloisInsertion l u\nhbot : Eq (u Bot.bot) Bot.bot\nb : β\nhb : IsAtom (u b)\n⊢ IsAtom b","decl":"theorem isAtom_of_u_bot [OrderBot α] [OrderBot β] {l : α → β} {u : β → α}\n    (gi : GaloisInsertion l u) (hbot : u ⊥ = ⊥) {b : β} (hb : IsAtom (u b)) : IsAtom b :=\n  OrderEmbedding.isAtom_of_map_bot_of_image\n    ⟨⟨u, gi.u_injective⟩, @GaloisInsertion.u_le_u_iff _ _ _ _ _ _ gi⟩ hbot hb\n\n"}
{"name":"GaloisInsertion.isAtom_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : PartialOrder α\ninst✝³ : PartialOrder β\ninst✝² : OrderBot α\ninst✝¹ : IsAtomic α\ninst✝ : OrderBot β\nl : α → β\nu : β → α\ngi : GaloisInsertion l u\nhbot : Eq (u Bot.bot) Bot.bot\nh_atom : ∀ (a : α), IsAtom a → Eq (u (l a)) a\na : α\n⊢ Iff (IsAtom (l a)) (IsAtom a)","decl":"theorem isAtom_iff [OrderBot α] [IsAtomic α] [OrderBot β] {l : α → β} {u : β → α}\n    (gi : GaloisInsertion l u) (hbot : u ⊥ = ⊥) (h_atom : ∀ a, IsAtom a → u (l a) = a) (a : α) :\n    IsAtom (l a) ↔ IsAtom a := by\n  refine ⟨fun hla => ?_, fun ha => gi.isAtom_of_u_bot hbot ((h_atom a ha).symm ▸ ha)⟩\n  obtain ⟨a', ha', hab'⟩ :=\n    (eq_bot_or_exists_atom_le (u (l a))).resolve_left (hbot ▸ fun h => hla.1 (gi.u_injective h))\n  have :=\n    (hla.le_iff.mp <| (gi.l_u_eq (l a) ▸ gi.gc.monotone_l hab' : l a' ≤ l a)).resolve_left fun h =>\n      ha'.1 (hbot ▸ h_atom a' ha' ▸ congr_arg u h)\n  have haa' : a = a' :=\n    (ha'.le_iff.mp <|\n          (gi.gc.le_u_l a).trans_eq (h_atom a' ha' ▸ congr_arg u this.symm)).resolve_left\n      (mt (congr_arg l) (gi.gc.l_bot.symm ▸ hla.1))\n  exact haa'.symm ▸ ha'\n\n"}
{"name":"GaloisInsertion.isAtom_iff'","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : PartialOrder α\ninst✝³ : PartialOrder β\ninst✝² : OrderBot α\ninst✝¹ : IsAtomic α\ninst✝ : OrderBot β\nl : α → β\nu : β → α\ngi : GaloisInsertion l u\nhbot : Eq (u Bot.bot) Bot.bot\nh_atom : ∀ (a : α), IsAtom a → Eq (u (l a)) a\nb : β\n⊢ Iff (IsAtom (u b)) (IsAtom b)","decl":"theorem isAtom_iff' [OrderBot α] [IsAtomic α] [OrderBot β] {l : α → β} {u : β → α}\n    (gi : GaloisInsertion l u) (hbot : u ⊥ = ⊥) (h_atom : ∀ a, IsAtom a → u (l a) = a) (b : β) :\n    IsAtom (u b) ↔ IsAtom b := by rw [← gi.isAtom_iff hbot h_atom, gi.l_u_eq]\n\n"}
{"name":"GaloisInsertion.isCoatom_of_image","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : PartialOrder α\ninst✝² : PartialOrder β\ninst✝¹ : OrderTop α\ninst✝ : OrderTop β\nl : α → β\nu : β → α\ngi : GaloisInsertion l u\nb : β\nhb : IsCoatom (u b)\n⊢ IsCoatom b","decl":"theorem isCoatom_of_image [OrderTop α] [OrderTop β] {l : α → β} {u : β → α}\n    (gi : GaloisInsertion l u) {b : β} (hb : IsCoatom (u b)) : IsCoatom b :=\n  OrderEmbedding.isCoatom_of_map_top_of_image\n    ⟨⟨u, gi.u_injective⟩, @GaloisInsertion.u_le_u_iff _ _ _ _ _ _ gi⟩ gi.gc.u_top hb\n\n"}
{"name":"GaloisInsertion.isCoatom_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : PartialOrder α\ninst✝³ : PartialOrder β\ninst✝² : OrderTop α\ninst✝¹ : IsCoatomic α\ninst✝ : OrderTop β\nl : α → β\nu : β → α\ngi : GaloisInsertion l u\nh_coatom : ∀ (a : α), IsCoatom a → Eq (u (l a)) a\nb : β\n⊢ Iff (IsCoatom (u b)) (IsCoatom b)","decl":"theorem isCoatom_iff [OrderTop α] [IsCoatomic α] [OrderTop β] {l : α → β} {u : β → α}\n    (gi : GaloisInsertion l u) (h_coatom : ∀ a : α, IsCoatom a → u (l a) = a) (b : β) :\n    IsCoatom (u b) ↔ IsCoatom b := by\n  refine ⟨fun hb => gi.isCoatom_of_image hb, fun hb => ?_⟩\n  obtain ⟨a, ha, hab⟩ :=\n    (eq_top_or_exists_le_coatom (u b)).resolve_left fun h =>\n      hb.1 <| (gi.gc.u_top ▸ gi.l_u_eq ⊤ : l ⊤ = ⊤) ▸ gi.l_u_eq b ▸ congr_arg l h\n  have : l a = b :=\n    (hb.le_iff.mp (gi.l_u_eq b ▸ gi.gc.monotone_l hab : b ≤ l a)).resolve_left fun hla =>\n      ha.1 (gi.gc.u_top ▸ h_coatom a ha ▸ congr_arg u hla)\n  exact this ▸ (h_coatom a ha).symm ▸ ha\n\n"}
{"name":"GaloisCoinsertion.isCoatom_of_l_top","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : PartialOrder α\ninst✝² : PartialOrder β\ninst✝¹ : OrderTop α\ninst✝ : OrderTop β\nl : α → β\nu : β → α\ngi : GaloisCoinsertion l u\nhbot : Eq (l Top.top) Top.top\na : α\nhb : IsCoatom (l a)\n⊢ IsCoatom a","decl":"theorem isCoatom_of_l_top [OrderTop α] [OrderTop β] {l : α → β} {u : β → α}\n    (gi : GaloisCoinsertion l u) (hbot : l ⊤ = ⊤) {a : α} (hb : IsCoatom (l a)) : IsCoatom a :=\n  gi.dual.isAtom_of_u_bot hbot hb.dual\n\n"}
{"name":"GaloisCoinsertion.isCoatom_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : PartialOrder α\ninst✝³ : PartialOrder β\ninst✝² : OrderTop α\ninst✝¹ : OrderTop β\ninst✝ : IsCoatomic β\nl : α → β\nu : β → α\ngi : GaloisCoinsertion l u\nhtop : Eq (l Top.top) Top.top\nh_coatom : ∀ (b : β), IsCoatom b → Eq (l (u b)) b\nb : β\n⊢ Iff (IsCoatom (u b)) (IsCoatom b)","decl":"theorem isCoatom_iff [OrderTop α] [OrderTop β] [IsCoatomic β] {l : α → β} {u : β → α}\n    (gi : GaloisCoinsertion l u) (htop : l ⊤ = ⊤) (h_coatom : ∀ b, IsCoatom b → l (u b) = b)\n    (b : β) : IsCoatom (u b) ↔ IsCoatom b :=\n  gi.dual.isAtom_iff htop h_coatom b\n\n"}
{"name":"GaloisCoinsertion.isCoatom_iff'","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : PartialOrder α\ninst✝³ : PartialOrder β\ninst✝² : OrderTop α\ninst✝¹ : OrderTop β\ninst✝ : IsCoatomic β\nl : α → β\nu : β → α\ngi : GaloisCoinsertion l u\nhtop : Eq (l Top.top) Top.top\nh_coatom : ∀ (b : β), IsCoatom b → Eq (l (u b)) b\na : α\n⊢ Iff (IsCoatom (l a)) (IsCoatom a)","decl":"theorem isCoatom_iff' [OrderTop α] [OrderTop β] [IsCoatomic β] {l : α → β} {u : β → α}\n    (gi : GaloisCoinsertion l u) (htop : l ⊤ = ⊤) (h_coatom : ∀ b, IsCoatom b → l (u b) = b)\n    (a : α) : IsCoatom (l a) ↔ IsCoatom a :=\n  gi.dual.isAtom_iff' htop h_coatom a\n\n"}
{"name":"GaloisCoinsertion.isAtom_of_image","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : PartialOrder α\ninst✝² : PartialOrder β\ninst✝¹ : OrderBot α\ninst✝ : OrderBot β\nl : α → β\nu : β → α\ngi : GaloisCoinsertion l u\na : α\nhb : IsAtom (l a)\n⊢ IsAtom a","decl":"theorem isAtom_of_image [OrderBot α] [OrderBot β] {l : α → β} {u : β → α}\n    (gi : GaloisCoinsertion l u) {a : α} (hb : IsAtom (l a)) : IsAtom a :=\n  gi.dual.isCoatom_of_image hb.dual\n\n"}
{"name":"GaloisCoinsertion.isAtom_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : PartialOrder α\ninst✝³ : PartialOrder β\ninst✝² : OrderBot α\ninst✝¹ : OrderBot β\ninst✝ : IsAtomic β\nl : α → β\nu : β → α\ngi : GaloisCoinsertion l u\nh_atom : ∀ (b : β), IsAtom b → Eq (l (u b)) b\na : α\n⊢ Iff (IsAtom (l a)) (IsAtom a)","decl":"theorem isAtom_iff [OrderBot α] [OrderBot β] [IsAtomic β] {l : α → β} {u : β → α}\n    (gi : GaloisCoinsertion l u) (h_atom : ∀ b, IsAtom b → l (u b) = b) (a : α) :\n    IsAtom (l a) ↔ IsAtom a :=\n  gi.dual.isCoatom_iff h_atom a\n\n"}
{"name":"OrderIso.isAtom_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : PartialOrder α\ninst✝² : PartialOrder β\ninst✝¹ : OrderBot α\ninst✝ : OrderBot β\nf : OrderIso α β\na : α\n⊢ Iff (IsAtom (f a)) (IsAtom a)","decl":"@[simp]\ntheorem isAtom_iff [OrderBot α] [OrderBot β] (f : α ≃o β) (a : α) : IsAtom (f a) ↔ IsAtom a :=\n  ⟨f.toGaloisCoinsertion.isAtom_of_image, fun ha =>\n    f.toGaloisInsertion.isAtom_of_u_bot (map_bot f.symm) <| (f.symm_apply_apply a).symm ▸ ha⟩\n\n"}
{"name":"OrderIso.isCoatom_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : PartialOrder α\ninst✝² : PartialOrder β\ninst✝¹ : OrderTop α\ninst✝ : OrderTop β\nf : OrderIso α β\na : α\n⊢ Iff (IsCoatom (f a)) (IsCoatom a)","decl":"@[simp]\ntheorem isCoatom_iff [OrderTop α] [OrderTop β] (f : α ≃o β) (a : α) :\n    IsCoatom (f a) ↔ IsCoatom a :=\n  f.dual.isAtom_iff a\n\n"}
{"name":"OrderIso.isSimpleOrder_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : PartialOrder α\ninst✝² : PartialOrder β\ninst✝¹ : BoundedOrder α\ninst✝ : BoundedOrder β\nf : OrderIso α β\n⊢ Iff (IsSimpleOrder α) (IsSimpleOrder β)","decl":"theorem isSimpleOrder_iff [BoundedOrder α] [BoundedOrder β] (f : α ≃o β) :\n    IsSimpleOrder α ↔ IsSimpleOrder β := by\n  rw [isSimpleOrder_iff_isAtom_top, isSimpleOrder_iff_isAtom_top, ← f.isAtom_iff ⊤,\n    f.map_top]\n\n"}
{"name":"OrderIso.isSimpleOrder","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : PartialOrder α\ninst✝² : PartialOrder β\ninst✝¹ : BoundedOrder α\ninst✝ : BoundedOrder β\nh : IsSimpleOrder β\nf : OrderIso α β\n⊢ IsSimpleOrder α","decl":"theorem isSimpleOrder [BoundedOrder α] [BoundedOrder β] [h : IsSimpleOrder β] (f : α ≃o β) :\n    IsSimpleOrder α :=\n  f.isSimpleOrder_iff.mpr h\n\n"}
{"name":"OrderIso.isAtomic_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : PartialOrder α\ninst✝² : PartialOrder β\ninst✝¹ : OrderBot α\ninst✝ : OrderBot β\nf : OrderIso α β\n⊢ Iff (IsAtomic α) (IsAtomic β)","decl":"protected theorem isAtomic_iff [OrderBot α] [OrderBot β] (f : α ≃o β) :\n    IsAtomic α ↔ IsAtomic β := by\n  simp only [isAtomic_iff, f.surjective.forall, f.surjective.exists, ← map_bot f, f.eq_iff_eq,\n    f.le_iff_le, f.isAtom_iff]\n\n"}
{"name":"OrderIso.isCoatomic_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : PartialOrder α\ninst✝² : PartialOrder β\ninst✝¹ : OrderTop α\ninst✝ : OrderTop β\nf : OrderIso α β\n⊢ Iff (IsCoatomic α) (IsCoatomic β)","decl":"protected theorem isCoatomic_iff [OrderTop α] [OrderTop β] (f : α ≃o β) :\n    IsCoatomic α ↔ IsCoatomic β := by\n  simp only [← isAtomic_dual_iff_isCoatomic, f.dual.isAtomic_iff]\n\n"}
{"name":"CompleteLattice.isStronglyAtomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝² : CompleteLattice α\ninst✝¹ : IsUpperModularLattice α\ninst✝ : IsAtomistic α\n⊢ IsStronglyAtomic α","decl":"/-- A complete upper-modular lattice that is atomistic is strongly atomic.\nNot an instance to prevent loops. -/\ntheorem CompleteLattice.isStronglyAtomic [IsUpperModularLattice α] [IsAtomistic α] :\n    IsStronglyAtomic α where\n  exists_covBy_le_of_lt a b hab := by\n    obtain ⟨s, rfl, h⟩ := eq_sSup_atoms b\n    refine by_contra fun hcon ↦ hab.not_le <| sSup_le_iff.2 fun x hx ↦ ?_\n    simp_rw [not_exists, and_comm (b := _ ≤ _), not_and] at hcon\n    specialize hcon (x ⊔ a) (sup_le (le_sSup _ _ hx) hab.le)\n    obtain (hbot | h_inf) := (h x hx).bot_covBy.eq_or_eq (c := x ⊓ a) (by simp) (by simp)\n    · exact False.elim <| hcon <|\n        (hbot ▸ IsUpperModularLattice.covBy_sup_of_inf_covBy) (h x hx).bot_covBy\n    rwa [inf_eq_left] at h_inf\n\n"}
{"name":"CompleteLattice.isStronglyCoatomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝² : CompleteLattice α\ninst✝¹ : IsLowerModularLattice α\ninst✝ : IsCoatomistic α\n⊢ IsStronglyCoatomic α","decl":"/-- A complete lower-modular lattice that is coatomistic is strongly coatomic.\nNot an instance to prevent loops. -/\ntheorem CompleteLattice.isStronglyCoatomic [IsLowerModularLattice α] [IsCoatomistic α] :\n    IsStronglyCoatomic α := by\n  rw [← isStronglyAtomic_dual_iff_is_stronglyCoatomic]\n  exact CompleteLattice.isStronglyAtomic\n\n"}
{"name":"IsCompl.isAtom_iff_isCoatom","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝² : Lattice α\ninst✝¹ : BoundedOrder α\ninst✝ : IsModularLattice α\na b : α\nhc : IsCompl a b\n⊢ Iff (IsAtom a) (IsCoatom b)","decl":"theorem isAtom_iff_isCoatom : IsAtom a ↔ IsCoatom b :=\n  Set.isSimpleOrder_Iic_iff_isAtom.symm.trans <|\n    hc.IicOrderIsoIci.isSimpleOrder_iff.trans Set.isSimpleOrder_Ici_iff_isCoatom\n\n"}
{"name":"IsCompl.isCoatom_iff_isAtom","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝² : Lattice α\ninst✝¹ : BoundedOrder α\ninst✝ : IsModularLattice α\na b : α\nhc : IsCompl a b\n⊢ Iff (IsCoatom a) (IsAtom b)","decl":"theorem isCoatom_iff_isAtom : IsCoatom a ↔ IsAtom b :=\n  hc.symm.isAtom_iff_isCoatom.symm\n\n"}
{"name":"isCoatomic_of_isAtomic_of_complementedLattice_of_isModular","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝⁴ : Lattice α\ninst✝³ : BoundedOrder α\ninst✝² : IsModularLattice α\ninst✝¹ : ComplementedLattice α\ninst✝ : IsAtomic α\n⊢ IsCoatomic α","decl":"theorem isCoatomic_of_isAtomic_of_complementedLattice_of_isModular [IsAtomic α] :\n    IsCoatomic α :=\n  ⟨fun x => by\n    rcases exists_isCompl x with ⟨y, xy⟩\n    apply (eq_bot_or_exists_atom_le y).imp _ _\n    · rintro rfl\n      exact eq_top_of_isCompl_bot xy\n    · rintro ⟨a, ha, ay⟩\n      rcases exists_isCompl (xy.symm.IicOrderIsoIci ⟨a, ay⟩) with ⟨⟨b, xb⟩, hb⟩\n      refine ⟨↑(⟨b, xb⟩ : Set.Ici x), IsCoatom.of_isCoatom_coe_Ici ?_, xb⟩\n      rw [← hb.isAtom_iff_isCoatom, OrderIso.isAtom_iff]\n      apply ha.Iic⟩\n\n"}
{"name":"isAtomic_of_isCoatomic_of_complementedLattice_of_isModular","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝⁴ : Lattice α\ninst✝³ : BoundedOrder α\ninst✝² : IsModularLattice α\ninst✝¹ : ComplementedLattice α\ninst✝ : IsCoatomic α\n⊢ IsAtomic α","decl":"theorem isAtomic_of_isCoatomic_of_complementedLattice_of_isModular [IsCoatomic α] :\n    IsAtomic α :=\n  isCoatomic_dual_iff_isAtomic.1 isCoatomic_of_isAtomic_of_complementedLattice_of_isModular\n\n"}
{"name":"isAtomic_iff_isCoatomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝³ : Lattice α\ninst✝² : BoundedOrder α\ninst✝¹ : IsModularLattice α\ninst✝ : ComplementedLattice α\n⊢ Iff (IsAtomic α) (IsCoatomic α)","decl":"theorem isAtomic_iff_isCoatomic : IsAtomic α ↔ IsCoatomic α :=\n  ⟨fun _ => isCoatomic_of_isAtomic_of_complementedLattice_of_isModular,\n   fun _ => isAtomic_of_isCoatomic_of_complementedLattice_of_isModular⟩\n\n"}
{"name":"ComplementedLattice.isStronglyAtomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝⁴ : Lattice α\ninst✝³ : BoundedOrder α\ninst✝² : IsModularLattice α\ninst✝¹ : ComplementedLattice α\ninst✝ : IsAtomic α\n⊢ IsStronglyAtomic α","decl":"/-- A complemented modular atomic lattice is strongly atomic.\nNot an instance to prevent loops. -/\ntheorem ComplementedLattice.isStronglyAtomic [IsAtomic α] : IsStronglyAtomic α where\n  exists_covBy_le_of_lt a b hab := by\n    obtain ⟨⟨a', ha'b : a' ≤ b⟩, ha'⟩ := exists_isCompl (α := Set.Iic b) ⟨a, hab.le⟩\n    obtain (rfl | ⟨d, hd⟩) := eq_bot_or_exists_atom_le a'\n    · obtain rfl : a = b := by simpa [codisjoint_bot, ← Subtype.coe_inj] using ha'.codisjoint\n      exact False.elim <| hab.ne rfl\n    refine ⟨d ⊔ a, IsUpperModularLattice.covBy_sup_of_inf_covBy ?_, sup_le (hd.2.trans ha'b) hab.le⟩\n    convert hd.1.bot_covBy\n    rw [← le_bot_iff, ← show a ⊓ a' = ⊥ by simpa using Subtype.coe_inj.2 ha'.inf_eq_bot, inf_comm]\n    exact inf_le_inf_left _ hd.2\n\n"}
{"name":"ComplementedLattice.isStronglyCoatomic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝⁴ : Lattice α\ninst✝³ : BoundedOrder α\ninst✝² : IsModularLattice α\ninst✝¹ : ComplementedLattice α\ninst✝ : IsCoatomic α\n⊢ IsStronglyCoatomic α","decl":"/-- A complemented modular coatomic lattice is strongly coatomic.\nNot an instance to prevent loops. -/\ntheorem ComplementedLattice.isStronglyCoatomic [IsCoatomic α] : IsStronglyCoatomic α :=\n  isStronglyAtomic_dual_iff_is_stronglyCoatomic.1 <| ComplementedLattice.isStronglyAtomic\n\n"}
{"name":"ComplementedLattice.isStronglyAtomic'","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝³ : Lattice α\ninst✝² : BoundedOrder α\ninst✝¹ : IsModularLattice α\ninst✝ : ComplementedLattice α\nh : IsAtomic α\n⊢ IsStronglyCoatomic α","decl":"/-- A complemented modular atomic lattice is strongly coatomic.\nNot an instance to prevent loops. -/\ntheorem ComplementedLattice.isStronglyAtomic' [h : IsAtomic α] : IsStronglyCoatomic α := by\n  rw [isAtomic_iff_isCoatomic] at h\n  exact isStronglyCoatomic\n\n"}
{"name":"ComplementedLattice.isStronglyCoatomic'","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝³ : Lattice α\ninst✝² : BoundedOrder α\ninst✝¹ : IsModularLattice α\ninst✝ : ComplementedLattice α\nh : IsCoatomic α\n⊢ IsStronglyAtomic α","decl":"/-- A complemented modular coatomic lattice is strongly atomic.\nNot an instance to prevent loops. -/\ntheorem ComplementedLattice.isStronglyCoatomic' [h : IsCoatomic α] : IsStronglyAtomic α := by\n  rw [← isAtomic_iff_isCoatomic] at h\n  exact isStronglyAtomic\n\n"}
{"name":"Prop.isAtom_iff","module":"Mathlib.Order.Atoms","initialProofState":"p : Prop\n⊢ Iff (IsAtom p) p","decl":"@[simp] theorem isAtom_iff {p : Prop} : IsAtom p ↔ p := by\n  simp [IsAtom, show ⊥ = False from rfl, fun q r : Prop => show q < r ↔ _ ∧ _ from .rfl]\n\n"}
{"name":"Prop.isCoatom_iff","module":"Mathlib.Order.Atoms","initialProofState":"p : Prop\n⊢ Iff (IsCoatom p) (Not p)","decl":"@[simp] theorem isCoatom_iff {p : Prop} : IsCoatom p ↔ ¬ p := by\n  simp [IsCoatom, show ⊤ = True from rfl, fun q r : Prop => show q < r ↔ _ ∧ _ from .rfl]; tauto\n\n"}
{"name":"Prop.instIsSimpleOrderProp","module":"Mathlib.Order.Atoms","initialProofState":"⊢ IsSimpleOrder Prop","decl":"instance : IsSimpleOrder Prop where\n  eq_bot_or_eq_top p := by simp [em']\n\n"}
{"name":"Pi.eq_bot_iff","module":"Mathlib.Order.Atoms","initialProofState":"ι : Type u_4\nπ : ι → Type u\ninst✝ : (i : ι) → Bot (π i)\nf : (i : ι) → π i\n⊢ Iff (Eq f Bot.bot) (∀ (i : ι), Eq (f i) Bot.bot)","decl":"protected theorem eq_bot_iff [∀ i, Bot (π i)] {f : ∀ i, π i} : f = ⊥ ↔ ∀ i, f i = ⊥ :=\n  ⟨(· ▸ by simp), fun h => funext fun i => by simp [h]⟩\n\n"}
{"name":"Pi.isAtom_iff","module":"Mathlib.Order.Atoms","initialProofState":"ι : Type u_4\nπ : ι → Type u\nf : (i : ι) → π i\ninst✝¹ : (i : ι) → PartialOrder (π i)\ninst✝ : (i : ι) → OrderBot (π i)\n⊢ Iff (IsAtom f) (Exists fun i => And (IsAtom (f i)) (∀ (j : ι), Ne j i → Eq (f j) Bot.bot))","decl":"theorem isAtom_iff {f : ∀ i, π i} [∀ i, PartialOrder (π i)] [∀ i, OrderBot (π i)] :\n    IsAtom f ↔ ∃ i, IsAtom (f i) ∧ ∀ j, j ≠ i → f j = ⊥ := by\n  classical\n  constructor\n  case mpr =>\n    rintro ⟨i, ⟨hfi, hlt⟩, hbot⟩\n    refine ⟨fun h => hfi ((Pi.eq_bot_iff.1 h) _), fun g hgf => Pi.eq_bot_iff.2 fun j => ?_⟩\n    have ⟨hgf, k, hgfk⟩ := Pi.lt_def.1 hgf\n    obtain rfl : i = k := of_not_not fun hki => by rw [hbot _ (Ne.symm hki)] at hgfk; simp at hgfk\n    if hij : j = i then subst hij; refine hlt _ hgfk else\n    exact eq_bot_iff.2 <| le_trans (hgf _) (eq_bot_iff.1 (hbot _ hij))\n  case mp =>\n    rintro ⟨hbot, h⟩\n    have ⟨i, hbot⟩ : ∃ i, f i ≠ ⊥ := by rw [ne_eq, Pi.eq_bot_iff, not_forall] at hbot; exact hbot\n    refine ⟨i, ⟨hbot, ?c⟩, ?d⟩\n    case c =>\n      intro b hb\n      have := h (Function.update ⊥ i b)\n      simp only [lt_def, le_def, Pi.eq_bot_iff, and_imp, forall_exists_index] at this\n      simpa using this\n        (fun j => by by_cases h : j = i; { subst h; simpa using le_of_lt hb }; simp [h])\n        i (by simpa using hb) i\n    case d =>\n      intro j hj\n      have := h (Function.update ⊥ j (f j))\n      simp only [lt_def, le_def, Pi.eq_bot_iff, and_imp, forall_exists_index] at this\n      simpa using this (fun k => by by_cases h : k = j; { subst h; simp }; simp [h]) i\n        (by rwa [Function.update_of_ne (Ne.symm hj), bot_apply, bot_lt_iff_ne_bot]) j\n\n"}
{"name":"Pi.isAtom_single","module":"Mathlib.Order.Atoms","initialProofState":"ι : Type u_4\nπ : ι → Type u\ni : ι\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → PartialOrder (π i)\ninst✝ : (i : ι) → OrderBot (π i)\na : π i\nh : IsAtom a\n⊢ IsAtom (Function.update Bot.bot i a)","decl":"theorem isAtom_single {i : ι} [DecidableEq ι] [∀ i, PartialOrder (π i)] [∀ i, OrderBot (π i)]\n    {a : π i} (h : IsAtom a) : IsAtom (Function.update (⊥ : ∀ i, π i) i a) :=\n  isAtom_iff.2 ⟨i, by simpa, fun _ hji => Function.update_of_ne hji ..⟩\n\n"}
{"name":"Pi.isAtom_iff_eq_single","module":"Mathlib.Order.Atoms","initialProofState":"ι : Type u_4\nπ : ι → Type u\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → PartialOrder (π i)\ninst✝ : (i : ι) → OrderBot (π i)\nf : (i : ι) → π i\n⊢ Iff (IsAtom f) (Exists fun i => Exists fun a => And (IsAtom a) (Eq f (Function.update Bot.bot i a)))","decl":"theorem isAtom_iff_eq_single [DecidableEq ι] [∀ i, PartialOrder (π i)]\n    [∀ i, OrderBot (π i)] {f : ∀ i, π i} :\n    IsAtom f ↔ ∃ i a, IsAtom a ∧ f = Function.update ⊥ i a := by\n  constructor\n  case mp =>\n    intro h\n    have ⟨i, h, hbot⟩ := isAtom_iff.1 h\n    refine ⟨_, _, h, funext fun j => if hij : j = i then hij ▸ by simp else ?_⟩\n    rw [Function.update_of_ne hij, hbot _ hij, bot_apply]\n  case mpr =>\n    rintro ⟨i, a, h, rfl⟩\n    exact isAtom_single h\n\n"}
{"name":"Pi.isAtomic","module":"Mathlib.Order.Atoms","initialProofState":"ι : Type u_4\nπ : ι → Type u\ninst✝² : (i : ι) → PartialOrder (π i)\ninst✝¹ : (i : ι) → OrderBot (π i)\ninst✝ : ∀ (i : ι), IsAtomic (π i)\n⊢ IsAtomic ((i : ι) → π i)","decl":"instance isAtomic [∀ i, PartialOrder (π i)] [∀ i, OrderBot (π i)] [∀ i, IsAtomic (π i)] :\n    IsAtomic (∀ i, π i) where\n  eq_bot_or_exists_atom_le b := or_iff_not_imp_left.2 fun h =>\n    have ⟨i, hi⟩ : ∃ i, b i ≠ ⊥ := not_forall.1 (h.imp Pi.eq_bot_iff.2)\n    have ⟨a, ha, hab⟩ := (eq_bot_or_exists_atom_le (b i)).resolve_left hi\n    have : DecidableEq ι := open scoped Classical in inferInstance\n    ⟨Function.update ⊥ i a, isAtom_single ha, update_le_iff.2 ⟨hab, by simp⟩⟩\n\n"}
{"name":"Pi.isCoatomic","module":"Mathlib.Order.Atoms","initialProofState":"ι : Type u_4\nπ : ι → Type u\ninst✝² : (i : ι) → PartialOrder (π i)\ninst✝¹ : (i : ι) → OrderTop (π i)\ninst✝ : ∀ (i : ι), IsCoatomic (π i)\n⊢ IsCoatomic ((i : ι) → π i)","decl":"instance isCoatomic [∀ i, PartialOrder (π i)] [∀ i, OrderTop (π i)] [∀ i, IsCoatomic (π i)] :\n    IsCoatomic (∀ i, π i) :=\n  isAtomic_dual_iff_isCoatomic.1 <|\n    show IsAtomic (∀ i, (π i)ᵒᵈ) from inferInstance\n\n"}
{"name":"Pi.isAtomistic","module":"Mathlib.Order.Atoms","initialProofState":"ι : Type u_4\nπ : ι → Type u\ninst✝¹ : (i : ι) → CompleteLattice (π i)\ninst✝ : ∀ (i : ι), IsAtomistic (π i)\n⊢ IsAtomistic ((i : ι) → π i)","decl":"instance isAtomistic [∀ i, CompleteLattice (π i)] [∀ i, IsAtomistic (π i)] :\n    IsAtomistic (∀ i, π i) where\n  eq_sSup_atoms s := by\n    classical\n    refine ⟨{ f | IsAtom f ∧ f ≤ s }, ?_, by simp; tauto⟩\n    ext i\n    rw [← sSup_atoms_le_eq (s i)]\n    simp_rw [isAtom_iff_eq_single]\n    refine le_antisymm ?le ?ge\n    case le =>\n      refine sSup_le fun a ⟨ha, hle⟩ => ?_\n      refine le_sSup ⟨⟨_, ⟨_, _, ha, rfl⟩, fun j => ?_⟩, by simp⟩\n      if hij : j = i then subst hij; simpa else simp [hij]\n    case ge =>\n      refine sSup_le ?_\n      rintro _ ⟨⟨_, ⟨j, a, ha, rfl⟩, hle⟩, rfl⟩\n      if hij : i = j then ?_ else simp [Function.update_of_ne hij]\n      subst hij; simp only [Function.update_self]\n      exact le_sSup ⟨ha, by simpa using hle i⟩\n\n"}
{"name":"Pi.isCoatomistic","module":"Mathlib.Order.Atoms","initialProofState":"ι : Type u_4\nπ : ι → Type u\ninst✝¹ : (i : ι) → CompleteLattice (π i)\ninst✝ : ∀ (i : ι), IsCoatomistic (π i)\n⊢ IsCoatomistic ((i : ι) → π i)","decl":"instance isCoatomistic [∀ i, CompleteLattice (π i)] [∀ i, IsCoatomistic (π i)] :\n    IsCoatomistic (∀ i, π i) :=\n  isAtomistic_dual_iff_isCoatomistic.1 <|\n    show IsAtomistic (∀ i, (π i)ᵒᵈ) from inferInstance\n\n"}
{"name":"isAtom_compl","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝ : BooleanAlgebra α\na : α\n⊢ Iff (IsAtom (HasCompl.compl a)) (IsCoatom a)","decl":"@[simp] lemma isAtom_compl : IsAtom aᶜ ↔ IsCoatom a := isCompl_compl.symm.isAtom_iff_isCoatom\n"}
{"name":"isCoatom_compl","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝ : BooleanAlgebra α\na : α\n⊢ Iff (IsCoatom (HasCompl.compl a)) (IsAtom a)","decl":"@[simp] lemma isCoatom_compl : IsCoatom aᶜ ↔ IsAtom a := isCompl_compl.symm.isCoatom_iff_isAtom\n\n"}
{"name":"IsCoatom.compl","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝ : BooleanAlgebra α\na : α\na✝ : IsCoatom a\n⊢ IsAtom (HasCompl.compl a)","decl":"protected alias ⟨IsAtom.of_compl, IsCoatom.compl⟩ := isAtom_compl\n"}
{"name":"IsAtom.of_compl","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝ : BooleanAlgebra α\na : α\na✝ : IsAtom (HasCompl.compl a)\n⊢ IsCoatom a","decl":"protected alias ⟨IsAtom.of_compl, IsCoatom.compl⟩ := isAtom_compl\n"}
{"name":"IsCoatom.of_compl","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝ : BooleanAlgebra α\na : α\na✝ : IsCoatom (HasCompl.compl a)\n⊢ IsAtom a","decl":"protected alias ⟨IsCoatom.of_compl, IsAtom.compl⟩ := isCoatom_compl\n\n"}
{"name":"IsAtom.compl","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ninst✝ : BooleanAlgebra α\na : α\na✝ : IsAtom a\n⊢ IsCoatom (HasCompl.compl a)","decl":"protected alias ⟨IsCoatom.of_compl, IsAtom.compl⟩ := isCoatom_compl\n\n"}
{"name":"Set.isAtom_singleton","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\nx : α\n⊢ IsAtom (Singleton.singleton x)","decl":"theorem isAtom_singleton (x : α) : IsAtom ({x} : Set α) :=\n  ⟨singleton_ne_empty _, fun _ hs => ssubset_singleton_iff.mp hs⟩\n\n"}
{"name":"Set.isAtom_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ns : Set α\n⊢ Iff (IsAtom s) (Exists fun x => Eq s (Singleton.singleton x))","decl":"theorem isAtom_iff {s : Set α} : IsAtom s ↔ ∃ x, s = {x} := by\n  refine\n    ⟨?_, by\n      rintro ⟨x, rfl⟩\n      exact isAtom_singleton x⟩\n  rw [isAtom_iff_le_of_ge, bot_eq_empty, ← nonempty_iff_ne_empty]\n  rintro ⟨⟨x, hx⟩, hs⟩\n  exact\n    ⟨x, eq_singleton_iff_unique_mem.2\n        ⟨hx, fun y hy => (hs {y} (singleton_ne_empty _) (singleton_subset_iff.2 hy) hx).symm⟩⟩\n\n"}
{"name":"Set.isCoatom_iff","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\ns : Set α\n⊢ Iff (IsCoatom s) (Exists fun x => Eq s (HasCompl.compl (Singleton.singleton x)))","decl":"theorem isCoatom_iff (s : Set α) : IsCoatom s ↔ ∃ x, s = {x}ᶜ := by\n  rw [isCompl_compl.isCoatom_iff_isAtom, isAtom_iff]\n  simp_rw [@eq_comm _ s, compl_eq_comm]\n\n"}
{"name":"Set.isCoatom_singleton_compl","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\nx : α\n⊢ IsCoatom (HasCompl.compl (Singleton.singleton x))","decl":"theorem isCoatom_singleton_compl (x : α) : IsCoatom ({x}ᶜ : Set α) :=\n  (isCoatom_iff {x}ᶜ).mpr ⟨x, rfl⟩\n\n"}
{"name":"Set.instIsAtomistic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\n⊢ IsAtomistic (Set α)","decl":"instance : IsAtomistic (Set α) where\n  eq_sSup_atoms s :=\n    ⟨(fun x => {x}) '' s, by rw [sSup_eq_sUnion, sUnion_image, biUnion_of_singleton],\n      by { rintro _ ⟨x, _, rfl⟩\n           exact isAtom_singleton x }⟩\n\n"}
{"name":"Set.instIsCoatomistic","module":"Mathlib.Order.Atoms","initialProofState":"α : Type u_2\n⊢ IsCoatomistic (Set α)","decl":"instance : IsCoatomistic (Set α) where\n  eq_sInf_coatoms s :=\n    ⟨(fun x => {x}ᶜ) '' sᶜ,\n      by { rw [sInf_eq_sInter, sInter_image, ← compl_iUnion₂, biUnion_of_singleton, compl_compl] },\n      by { rintro _ ⟨x, _, rfl⟩\n           exact isCoatom_singleton_compl x }⟩\n\n"}
