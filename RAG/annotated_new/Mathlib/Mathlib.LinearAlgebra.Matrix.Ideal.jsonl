{"name":"Ideal.mem_matricesOver","module":"Mathlib.LinearAlgebra.Matrix.Ideal","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nn : Type u_2\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nI : Ideal R\nM : Matrix n n R\n⊢ Iff (Membership.mem (Ideal.matricesOver n I) M) (∀ (i j : n), Membership.mem I (M i j))","decl":"@[simp]\ntheorem mem_matricesOver (I : Ideal R) (M : Matrix n n R) :\n    M ∈ I.matricesOver n ↔ ∀ i j, M i j ∈ I := by rfl\n\n"}
{"name":"Ideal.matricesOver_monotone","module":"Mathlib.LinearAlgebra.Matrix.Ideal","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nn : Type u_2\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\n⊢ Monotone (Ideal.matricesOver n)","decl":"theorem matricesOver_monotone : Monotone (matricesOver (R := R) n) :=\n  fun _ _ IJ _ MI i j => IJ (MI i j)\n\n"}
{"name":"Ideal.matricesOver_strictMono_of_nonempty","module":"Mathlib.LinearAlgebra.Matrix.Ideal","initialProofState":"R : Type u_1\ninst✝³ : Semiring R\nn : Type u_2\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : Nonempty n\n⊢ StrictMono (Ideal.matricesOver n)","decl":"theorem matricesOver_strictMono_of_nonempty [Nonempty n] :\n    StrictMono (matricesOver (R := R) n) :=\n  matricesOver_monotone n |>.strictMono_of_injective <| fun I J eq => by\n    ext x\n    have : (∀ _ _, x ∈ I) ↔ (∀ _ _, x ∈ J) := congr((Matrix.of fun _ _ => x) ∈ $eq)\n    simpa only [forall_const] using this\n\n"}
{"name":"Ideal.matricesOver_bot","module":"Mathlib.LinearAlgebra.Matrix.Ideal","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nn : Type u_2\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\n⊢ Eq (Ideal.matricesOver n Bot.bot) Bot.bot","decl":"@[simp]\ntheorem matricesOver_bot : (⊥ : Ideal R).matricesOver n = ⊥ := by\n  ext M\n  simp only [mem_matricesOver, mem_bot]\n  constructor\n  · intro H; ext; apply H\n  · intro H; simp [H]\n\n"}
{"name":"Ideal.matricesOver_top","module":"Mathlib.LinearAlgebra.Matrix.Ideal","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nn : Type u_2\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\n⊢ Eq (Ideal.matricesOver n Top.top) Top.top","decl":"@[simp]\ntheorem matricesOver_top : (⊤ : Ideal R).matricesOver n = ⊤ := by\n  ext; simp\n\n"}
{"name":"Ideal.stdBasisMatrix_mem_jacobson_matricesOver","module":"Mathlib.LinearAlgebra.Matrix.Ideal","initialProofState":"R : Type u_1\ninst✝² : Ring R\nn : Type u_2\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nI : Ideal R\nx : R\na✝ : Membership.mem I.jacobson x\ni j : n\n⊢ Membership.mem (Ideal.matricesOver n I).jacobson (Matrix.stdBasisMatrix i j x)","decl":"/-- A standard basis matrix is in $J(Mₙ(I))$\nas long as its one possibly non-zero entry is in $J(I)$. -/\ntheorem stdBasisMatrix_mem_jacobson_matricesOver (I : Ideal R) :\n    ∀ x ∈ I.jacobson, ∀ (i j : n), stdBasisMatrix i j x ∈ (I.matricesOver n).jacobson := by\n  -- Proof generalized from example 8 in\n  -- https://ysharifi.wordpress.com/2022/08/16/the-jacobson-radical-basic-examples/\n  simp_rw [Ideal.mem_jacobson_iff]\n  intro x xIJ p q M\n  have ⟨z, zMx⟩ := xIJ (M q p)\n  let N : Matrix n n R := 1 - ∑ i, stdBasisMatrix i q (if i = q then 1 - z else (M i p)*x*z)\n  use N\n  intro i j\n  obtain rfl | qj := eq_or_ne q j\n  · by_cases iq : i = q\n    · simp [iq, N, zMx, stdBasisMatrix, mul_apply, sum_apply, ite_and, sub_mul]\n    · convert I.mul_mem_left (-M i p * x) zMx\n      simp [iq, N, zMx, stdBasisMatrix, mul_apply, sum_apply, ite_and, sub_mul]\n      simp [sub_add, mul_add, mul_sub, mul_assoc]\n  · simp [N, qj, sum_apply, mul_apply]\n\n"}
{"name":"Ideal.matricesOver_jacobson_le","module":"Mathlib.LinearAlgebra.Matrix.Ideal","initialProofState":"R : Type u_1\ninst✝² : Ring R\nn : Type u_2\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nI : Ideal R\n⊢ LE.le (Ideal.matricesOver n I.jacobson) (Ideal.matricesOver n I).jacobson","decl":"/-- For any left ideal $I ≤ R$, we have $Mₙ(J(I)) ≤ J(Mₙ(I))$. -/\ntheorem matricesOver_jacobson_le (I : Ideal R) :\n    I.jacobson.matricesOver n ≤ (I.matricesOver n).jacobson := by\n  intro M MI\n  rw [matrix_eq_sum_stdBasisMatrix M]\n  apply sum_mem\n  intro i _\n  apply sum_mem\n  intro j _\n  apply stdBasisMatrix_mem_jacobson_matricesOver I _ (MI i j)\n\n"}
{"name":"TwoSidedIdeal.mem_matricesOver","module":"Mathlib.LinearAlgebra.Matrix.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\nn : Type u_2\ninst✝ : Fintype n\nI : TwoSidedIdeal R\nM : Matrix n n R\n⊢ Iff (Membership.mem (TwoSidedIdeal.matricesOver n I) M) (∀ (i j : n), Membership.mem I (M i j))","decl":"@[simp]\nlemma mem_matricesOver (I : TwoSidedIdeal R) (M : Matrix n n R) :\n    M ∈ I.matricesOver n ↔ ∀ i j, M i j ∈ I := by\n  simp [matricesOver]\n\n"}
{"name":"TwoSidedIdeal.matricesOver_monotone","module":"Mathlib.LinearAlgebra.Matrix.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\nn : Type u_2\ninst✝ : Fintype n\n⊢ Monotone (TwoSidedIdeal.matricesOver n)","decl":"theorem matricesOver_monotone : Monotone (matricesOver (R := R) n) :=\n  fun _ _ IJ _ MI i j => IJ (MI i j)\n\n"}
{"name":"TwoSidedIdeal.matricesOver_strictMono_of_nonempty","module":"Mathlib.LinearAlgebra.Matrix.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\nn : Type u_2\ninst✝ : Fintype n\nh : Nonempty n\n⊢ StrictMono (TwoSidedIdeal.matricesOver n)","decl":"theorem matricesOver_strictMono_of_nonempty [h : Nonempty n] :\n    StrictMono (matricesOver (R := R) n) :=\n  matricesOver_monotone n |>.strictMono_of_injective <| fun I J eq => by\n    ext x\n    have : _ ↔ _ := congr((Matrix.of fun _ _ => x) ∈ $eq)\n    simpa only [mem_matricesOver, of_apply, forall_const] using this\n\n"}
{"name":"TwoSidedIdeal.matricesOver_bot","module":"Mathlib.LinearAlgebra.Matrix.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\nn : Type u_2\ninst✝ : Fintype n\n⊢ Eq (TwoSidedIdeal.matricesOver n Bot.bot) Bot.bot","decl":"@[simp]\ntheorem matricesOver_bot : (⊥ : TwoSidedIdeal R).matricesOver n = ⊥ := by\n  ext M\n  simp only [mem_matricesOver, mem_bot]\n  constructor\n  · intro H; ext; apply H\n  · intro H; simp [H]\n\n"}
{"name":"TwoSidedIdeal.matricesOver_top","module":"Mathlib.LinearAlgebra.Matrix.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\nn : Type u_2\ninst✝ : Fintype n\n⊢ Eq (TwoSidedIdeal.matricesOver n Top.top) Top.top","decl":"@[simp]\ntheorem matricesOver_top : (⊤ : TwoSidedIdeal R).matricesOver n = ⊤ := by\n  ext; simp\n\n"}
{"name":"TwoSidedIdeal.asIdeal_matricesOver","module":"Mathlib.LinearAlgebra.Matrix.Ideal","initialProofState":"R : Type u_1\ninst✝² : Ring R\nn : Type u_2\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nI : TwoSidedIdeal R\n⊢ Eq (TwoSidedIdeal.asIdeal (TwoSidedIdeal.matricesOver n I)) (Ideal.matricesOver n (TwoSidedIdeal.asIdeal I))","decl":"theorem asIdeal_matricesOver [DecidableEq n] (I : TwoSidedIdeal R) :\n    asIdeal (I.matricesOver n) = (asIdeal I).matricesOver n := by\n  ext; simp\n\n"}
{"name":"TwoSidedIdeal.equivMatricesOver_symm_apply","module":"Mathlib.LinearAlgebra.Matrix.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\nn : Type u_3\ninst✝ : Fintype n\ni j : n\nJ : TwoSidedIdeal (Matrix n n R)\n⊢ Eq ((TwoSidedIdeal.equivMatricesOver i j).symm J) (TwoSidedIdeal.mk' (setOf fun x => Exists fun N => And (Membership.mem J N) (Eq (N i j) x)) ⋯ ⋯ ⋯ ⋯ ⋯)","decl":"/--\nTwo-sided ideals in $R$ correspond bijectively to those in $Mₙ(R)$.\nGiven an ideal $I ≤ R$, we send it to $Mₙ(I)$.\nGiven an ideal $J ≤ Mₙ(R)$, we send it to $\\{Nᵢⱼ ∣ ∃ N ∈ J\\}$.\n-/\n@[simps]\ndef equivMatricesOver (i j : n) : TwoSidedIdeal R ≃ TwoSidedIdeal (Matrix n n R) where\n  toFun I := I.matricesOver n\n  invFun J := TwoSidedIdeal.mk'\n    { N i j | N ∈ J }\n    ⟨0, J.zero_mem, rfl⟩\n    (by rintro _ _ ⟨x, hx, rfl⟩ ⟨y, hy, rfl⟩; exact ⟨x + y, J.add_mem hx hy, rfl⟩)\n    (by rintro _ ⟨x, hx, rfl⟩; exact ⟨-x, J.neg_mem hx, rfl⟩)\n    (by\n      classical\n      rintro x _ ⟨y, hy, rfl⟩\n      exact ⟨diagonal (fun _ ↦ x) * y, J.mul_mem_left _ _ hy, by simp⟩)\n    (by\n      classical\n      rintro _ y ⟨x, hx, rfl⟩\n      exact ⟨x * diagonal (fun _ ↦ y), J.mul_mem_right _ _ hx, by simp⟩)\n  right_inv J := SetLike.ext fun x ↦ by\n    classical\n    simp only [mem_mk', Set.mem_image, SetLike.mem_coe, mem_matricesOver]\n    constructor\n    · intro h\n      choose y hy1 hy2 using h\n      rw [matrix_eq_sum_stdBasisMatrix x]\n      refine sum_mem fun k _ ↦ sum_mem fun l _ ↦ ?_\n      suffices\n          stdBasisMatrix k l (x k l) =\n          stdBasisMatrix k i 1 * y k l * stdBasisMatrix j l 1 by\n        rw [this]\n        exact J.mul_mem_right _ _ (J.mul_mem_left _ _ <| hy1 _ _)\n      ext a b\n      by_cases hab : a = k ∧ b = l\n      · rcases hab with ⟨ha, hb⟩\n        subst ha hb\n        simp only [StdBasisMatrix.apply_same, StdBasisMatrix.mul_right_apply_same,\n          StdBasisMatrix.mul_left_apply_same, one_mul, mul_one]\n        rw [hy2 a b]\n      · conv_lhs =>\n          dsimp [stdBasisMatrix]\n          rw [if_neg (by tauto)]\n        rw [not_and_or] at hab\n        rcases hab with ha | hb\n        · rw [mul_assoc, StdBasisMatrix.mul_left_apply_of_ne (h := ha)]\n        · rw [StdBasisMatrix.mul_right_apply_of_ne (hbj := hb)]\n    · intro hx k l\n      refine ⟨stdBasisMatrix i k 1 * x * stdBasisMatrix l j 1,\n        J.mul_mem_right _ _ (J.mul_mem_left _ _ hx), ?_⟩\n      rw [StdBasisMatrix.mul_right_apply_same, StdBasisMatrix.mul_left_apply_same,\n        mul_one, one_mul]\n  left_inv I := SetLike.ext fun x ↦ by\n    simp only [mem_mk', Set.mem_image, SetLike.mem_coe, mem_matricesOver]\n    constructor\n    · intro h\n      choose y hy1 hy2 using h\n      exact hy2 ▸ hy1 _ _\n    · intro h\n      exact ⟨of fun _ _ => x, by simp [h], rfl⟩\n\n"}
{"name":"TwoSidedIdeal.equivMatricesOver_apply","module":"Mathlib.LinearAlgebra.Matrix.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\nn : Type u_3\ninst✝ : Fintype n\ni j : n\nI : TwoSidedIdeal R\n⊢ Eq ((TwoSidedIdeal.equivMatricesOver i j) I) (TwoSidedIdeal.matricesOver n I)","decl":"/--\nTwo-sided ideals in $R$ correspond bijectively to those in $Mₙ(R)$.\nGiven an ideal $I ≤ R$, we send it to $Mₙ(I)$.\nGiven an ideal $J ≤ Mₙ(R)$, we send it to $\\{Nᵢⱼ ∣ ∃ N ∈ J\\}$.\n-/\n@[simps]\ndef equivMatricesOver (i j : n) : TwoSidedIdeal R ≃ TwoSidedIdeal (Matrix n n R) where\n  toFun I := I.matricesOver n\n  invFun J := TwoSidedIdeal.mk'\n    { N i j | N ∈ J }\n    ⟨0, J.zero_mem, rfl⟩\n    (by rintro _ _ ⟨x, hx, rfl⟩ ⟨y, hy, rfl⟩; exact ⟨x + y, J.add_mem hx hy, rfl⟩)\n    (by rintro _ ⟨x, hx, rfl⟩; exact ⟨-x, J.neg_mem hx, rfl⟩)\n    (by\n      classical\n      rintro x _ ⟨y, hy, rfl⟩\n      exact ⟨diagonal (fun _ ↦ x) * y, J.mul_mem_left _ _ hy, by simp⟩)\n    (by\n      classical\n      rintro _ y ⟨x, hx, rfl⟩\n      exact ⟨x * diagonal (fun _ ↦ y), J.mul_mem_right _ _ hx, by simp⟩)\n  right_inv J := SetLike.ext fun x ↦ by\n    classical\n    simp only [mem_mk', Set.mem_image, SetLike.mem_coe, mem_matricesOver]\n    constructor\n    · intro h\n      choose y hy1 hy2 using h\n      rw [matrix_eq_sum_stdBasisMatrix x]\n      refine sum_mem fun k _ ↦ sum_mem fun l _ ↦ ?_\n      suffices\n          stdBasisMatrix k l (x k l) =\n          stdBasisMatrix k i 1 * y k l * stdBasisMatrix j l 1 by\n        rw [this]\n        exact J.mul_mem_right _ _ (J.mul_mem_left _ _ <| hy1 _ _)\n      ext a b\n      by_cases hab : a = k ∧ b = l\n      · rcases hab with ⟨ha, hb⟩\n        subst ha hb\n        simp only [StdBasisMatrix.apply_same, StdBasisMatrix.mul_right_apply_same,\n          StdBasisMatrix.mul_left_apply_same, one_mul, mul_one]\n        rw [hy2 a b]\n      · conv_lhs =>\n          dsimp [stdBasisMatrix]\n          rw [if_neg (by tauto)]\n        rw [not_and_or] at hab\n        rcases hab with ha | hb\n        · rw [mul_assoc, StdBasisMatrix.mul_left_apply_of_ne (h := ha)]\n        · rw [StdBasisMatrix.mul_right_apply_of_ne (hbj := hb)]\n    · intro hx k l\n      refine ⟨stdBasisMatrix i k 1 * x * stdBasisMatrix l j 1,\n        J.mul_mem_right _ _ (J.mul_mem_left _ _ hx), ?_⟩\n      rw [StdBasisMatrix.mul_right_apply_same, StdBasisMatrix.mul_left_apply_same,\n        mul_one, one_mul]\n  left_inv I := SetLike.ext fun x ↦ by\n    simp only [mem_mk', Set.mem_image, SetLike.mem_coe, mem_matricesOver]\n    constructor\n    · intro h\n      choose y hy1 hy2 using h\n      exact hy2 ▸ hy1 _ _\n    · intro h\n      exact ⟨of fun _ _ => x, by simp [h], rfl⟩\n\n"}
{"name":"TwoSidedIdeal.orderIsoMatricesOver_symm_apply_ringCon_r","module":"Mathlib.LinearAlgebra.Matrix.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\nn : Type u_3\ninst✝ : Fintype n\ni j : n\nJ : TwoSidedIdeal (Matrix n n R)\nx y : R\n⊢ Eq (((RelIso.symm (TwoSidedIdeal.orderIsoMatricesOver i j)) J).ringCon.toSetoid x y) (Exists fun N => And (Membership.mem J N) (Eq (N i j) (HSub.hSub x y)))","decl":"/--\nTwo-sided ideals in $R$ are order-isomorphic with those in $Mₙ(R)$.\nSee also `equivMatricesOver`.\n-/\n@[simps!]\ndef orderIsoMatricesOver (i j : n) : TwoSidedIdeal R ≃o TwoSidedIdeal (Matrix n n R) where\n  __ := equivMatricesOver i j\n  map_rel_iff' {I J} := by\n    simp only [equivMatricesOver_apply]\n    constructor\n    · intro le x xI\n      specialize @le (of fun _ _ => x) (by simp [xI])\n      letI : Inhabited n := ⟨i⟩\n      simpa using le\n    · intro IJ M MI i j\n      exact IJ <| MI i j\n\n"}
{"name":"TwoSidedIdeal.orderIsoMatricesOver_apply_ringCon_r","module":"Mathlib.LinearAlgebra.Matrix.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\nn : Type u_3\ninst✝ : Fintype n\ni j : n\nI : TwoSidedIdeal R\nx y : Matrix n n R\n⊢ Eq (((TwoSidedIdeal.orderIsoMatricesOver i j) I).ringCon.toSetoid x y) (∀ (i j : n), Membership.mem I (HSub.hSub (x i j) (y i j)))","decl":"/--\nTwo-sided ideals in $R$ are order-isomorphic with those in $Mₙ(R)$.\nSee also `equivMatricesOver`.\n-/\n@[simps!]\ndef orderIsoMatricesOver (i j : n) : TwoSidedIdeal R ≃o TwoSidedIdeal (Matrix n n R) where\n  __ := equivMatricesOver i j\n  map_rel_iff' {I J} := by\n    simp only [equivMatricesOver_apply]\n    constructor\n    · intro le x xI\n      specialize @le (of fun _ _ => x) (by simp [xI])\n      letI : Inhabited n := ⟨i⟩\n      simpa using le\n    · intro IJ M MI i j\n      exact IJ <| MI i j\n\n"}
{"name":"TwoSidedIdeal.jacobson_matricesOver","module":"Mathlib.LinearAlgebra.Matrix.Ideal","initialProofState":"R : Type u_1\ninst✝² : Ring R\nn : Type u_2\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nI : TwoSidedIdeal R\n⊢ Eq (TwoSidedIdeal.matricesOver n I).jacobson (TwoSidedIdeal.matricesOver n I.jacobson)","decl":"/-- For any two-sided ideal $I ≤ R$, we have $J(Mₙ(I)) = Mₙ(J(I))$. -/\ntheorem jacobson_matricesOver (I : TwoSidedIdeal R) :\n    (I.matricesOver n).jacobson = I.jacobson.matricesOver n := by\n  apply le_antisymm\n  · apply jacobson_matricesOver_le\n  · show asIdeal (I.matricesOver n).jacobson ≥ asIdeal (I.jacobson.matricesOver n)\n    simp [asIdeal_jacobson, asIdeal_matricesOver, Ideal.matricesOver_jacobson_le]\n\n"}
{"name":"TwoSidedIdeal.matricesOver_jacobson_bot","module":"Mathlib.LinearAlgebra.Matrix.Ideal","initialProofState":"R : Type u_1\ninst✝² : Ring R\nn : Type u_2\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\n⊢ Eq (TwoSidedIdeal.matricesOver n Bot.bot.jacobson) Bot.bot.jacobson","decl":"theorem matricesOver_jacobson_bot :\n    (⊥ : TwoSidedIdeal R).jacobson.matricesOver n = (⊥ : TwoSidedIdeal (Matrix n n R)).jacobson :=\n  matricesOver_bot n (R := R) ▸ (jacobson_matricesOver _).symm\n\n"}
