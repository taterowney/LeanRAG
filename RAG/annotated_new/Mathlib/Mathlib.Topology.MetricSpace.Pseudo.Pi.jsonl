{"name":"nndist_pi_def","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"β : Type u_2\nπ : β → Type u_3\ninst✝¹ : Fintype β\ninst✝ : (b : β) → PseudoMetricSpace (π b)\nf g : (b : β) → π b\n⊢ Eq (NNDist.nndist f g) (Finset.univ.sup fun b => NNDist.nndist (f b) (g b))","decl":"lemma nndist_pi_def (f g : ∀ b, π b) : nndist f g = sup univ fun b => nndist (f b) (g b) := rfl\n\n"}
{"name":"dist_pi_def","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"β : Type u_2\nπ : β → Type u_3\ninst✝¹ : Fintype β\ninst✝ : (b : β) → PseudoMetricSpace (π b)\nf g : (b : β) → π b\n⊢ Eq (Dist.dist f g) ↑(Finset.univ.sup fun b => NNDist.nndist (f b) (g b))","decl":"lemma dist_pi_def (f g : ∀ b, π b) : dist f g = (sup univ fun b => nndist (f b) (g b) : ℝ≥0) := rfl\n\n"}
{"name":"nndist_pi_le_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"β : Type u_2\nπ : β → Type u_3\ninst✝¹ : Fintype β\ninst✝ : (b : β) → PseudoMetricSpace (π b)\nf g : (b : β) → π b\nr : NNReal\n⊢ Iff (LE.le (NNDist.nndist f g) r) (∀ (b : β), LE.le (NNDist.nndist (f b) (g b)) r)","decl":"lemma nndist_pi_le_iff {f g : ∀ b, π b} {r : ℝ≥0} :\n    nndist f g ≤ r ↔ ∀ b, nndist (f b) (g b) ≤ r := by simp [nndist_pi_def]\n\n"}
{"name":"nndist_pi_lt_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"β : Type u_2\nπ : β → Type u_3\ninst✝¹ : Fintype β\ninst✝ : (b : β) → PseudoMetricSpace (π b)\nf g : (b : β) → π b\nr : NNReal\nhr : LT.lt 0 r\n⊢ Iff (LT.lt (NNDist.nndist f g) r) (∀ (b : β), LT.lt (NNDist.nndist (f b) (g b)) r)","decl":"lemma nndist_pi_lt_iff {f g : ∀ b, π b} {r : ℝ≥0} (hr : 0 < r) :\n    nndist f g < r ↔ ∀ b, nndist (f b) (g b) < r := by\n  rw [← bot_eq_zero'] at hr\n  simp [nndist_pi_def, Finset.sup_lt_iff hr]\n\n"}
{"name":"nndist_pi_eq_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"β : Type u_2\nπ : β → Type u_3\ninst✝¹ : Fintype β\ninst✝ : (b : β) → PseudoMetricSpace (π b)\nf g : (b : β) → π b\nr : NNReal\nhr : LT.lt 0 r\n⊢ Iff (Eq (NNDist.nndist f g) r) (And (Exists fun i => Eq (NNDist.nndist (f i) (g i)) r) (∀ (b : β), LE.le (NNDist.nndist (f b) (g b)) r))","decl":"lemma nndist_pi_eq_iff {f g : ∀ b, π b} {r : ℝ≥0} (hr : 0 < r) :\n    nndist f g = r ↔ (∃ i, nndist (f i) (g i) = r) ∧ ∀ b, nndist (f b) (g b) ≤ r := by\n  rw [eq_iff_le_not_lt, nndist_pi_lt_iff hr, nndist_pi_le_iff, not_forall, and_comm]\n  simp_rw [not_lt, and_congr_left_iff, le_antisymm_iff]\n  intro h\n  refine exists_congr fun b => ?_\n  apply (and_iff_right <| h _).symm\n\n"}
{"name":"dist_pi_lt_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"β : Type u_2\nπ : β → Type u_3\ninst✝¹ : Fintype β\ninst✝ : (b : β) → PseudoMetricSpace (π b)\nf g : (b : β) → π b\nr : Real\nhr : LT.lt 0 r\n⊢ Iff (LT.lt (Dist.dist f g) r) (∀ (b : β), LT.lt (Dist.dist (f b) (g b)) r)","decl":"lemma dist_pi_lt_iff {f g : ∀ b, π b} {r : ℝ} (hr : 0 < r) :\n    dist f g < r ↔ ∀ b, dist (f b) (g b) < r := by\n  lift r to ℝ≥0 using hr.le\n  exact nndist_pi_lt_iff hr\n\n"}
{"name":"dist_pi_le_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"β : Type u_2\nπ : β → Type u_3\ninst✝¹ : Fintype β\ninst✝ : (b : β) → PseudoMetricSpace (π b)\nf g : (b : β) → π b\nr : Real\nhr : LE.le 0 r\n⊢ Iff (LE.le (Dist.dist f g) r) (∀ (b : β), LE.le (Dist.dist (f b) (g b)) r)","decl":"lemma dist_pi_le_iff {f g : ∀ b, π b} {r : ℝ} (hr : 0 ≤ r) :\n    dist f g ≤ r ↔ ∀ b, dist (f b) (g b) ≤ r := by\n  lift r to ℝ≥0 using hr\n  exact nndist_pi_le_iff\n\n"}
{"name":"dist_pi_eq_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"β : Type u_2\nπ : β → Type u_3\ninst✝¹ : Fintype β\ninst✝ : (b : β) → PseudoMetricSpace (π b)\nf g : (b : β) → π b\nr : Real\nhr : LT.lt 0 r\n⊢ Iff (Eq (Dist.dist f g) r) (And (Exists fun i => Eq (Dist.dist (f i) (g i)) r) (∀ (b : β), LE.le (Dist.dist (f b) (g b)) r))","decl":"lemma dist_pi_eq_iff {f g : ∀ b, π b} {r : ℝ} (hr : 0 < r) :\n    dist f g = r ↔ (∃ i, dist (f i) (g i) = r) ∧ ∀ b, dist (f b) (g b) ≤ r := by\n  lift r to ℝ≥0 using hr.le\n  simp_rw [← coe_nndist, NNReal.coe_inj, nndist_pi_eq_iff hr, NNReal.coe_le_coe]\n\n"}
{"name":"dist_pi_le_iff'","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"β : Type u_2\nπ : β → Type u_3\ninst✝² : Fintype β\ninst✝¹ : (b : β) → PseudoMetricSpace (π b)\ninst✝ : Nonempty β\nf g : (b : β) → π b\nr : Real\n⊢ Iff (LE.le (Dist.dist f g) r) (∀ (b : β), LE.le (Dist.dist (f b) (g b)) r)","decl":"lemma dist_pi_le_iff' [Nonempty β] {f g : ∀ b, π b} {r : ℝ} :\n    dist f g ≤ r ↔ ∀ b, dist (f b) (g b) ≤ r := by\n  by_cases hr : 0 ≤ r\n  · exact dist_pi_le_iff hr\n  · exact iff_of_false (fun h => hr <| dist_nonneg.trans h) fun h =>\n      hr <| dist_nonneg.trans <| h <| Classical.arbitrary _\n\n"}
{"name":"dist_pi_const_le","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PseudoMetricSpace α\ninst✝ : Fintype β\na b : α\n⊢ LE.le (Dist.dist (fun x => a) fun x => b) (Dist.dist a b)","decl":"lemma dist_pi_const_le (a b : α) : (dist (fun _ : β => a) fun _ => b) ≤ dist a b :=\n  (dist_pi_le_iff dist_nonneg).2 fun _ => le_rfl\n\n"}
{"name":"nndist_pi_const_le","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PseudoMetricSpace α\ninst✝ : Fintype β\na b : α\n⊢ LE.le (NNDist.nndist (fun x => a) fun x => b) (NNDist.nndist a b)","decl":"lemma nndist_pi_const_le (a b : α) : (nndist (fun _ : β => a) fun _ => b) ≤ nndist a b :=\n  nndist_pi_le_iff.2 fun _ => le_rfl\n\n"}
{"name":"dist_pi_const","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : PseudoMetricSpace α\ninst✝¹ : Fintype β\ninst✝ : Nonempty β\na b : α\n⊢ Eq (Dist.dist (fun x => a) fun x => b) (Dist.dist a b)","decl":"@[simp]\nlemma dist_pi_const [Nonempty β] (a b : α) : (dist (fun _ : β => a) fun _ => b) = dist a b := by\n  simpa only [dist_edist] using congr_arg ENNReal.toReal (edist_pi_const a b)\n\n"}
{"name":"nndist_pi_const","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : PseudoMetricSpace α\ninst✝¹ : Fintype β\ninst✝ : Nonempty β\na b : α\n⊢ Eq (NNDist.nndist (fun x => a) fun x => b) (NNDist.nndist a b)","decl":"@[simp]\nlemma nndist_pi_const [Nonempty β] (a b : α) : (nndist (fun _ : β => a) fun _ => b) = nndist a b :=\n  NNReal.eq <| dist_pi_const a b\n\n"}
{"name":"nndist_le_pi_nndist","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"β : Type u_2\nπ : β → Type u_3\ninst✝¹ : Fintype β\ninst✝ : (b : β) → PseudoMetricSpace (π b)\nf g : (b : β) → π b\nb : β\n⊢ LE.le (NNDist.nndist (f b) (g b)) (NNDist.nndist f g)","decl":"lemma nndist_le_pi_nndist (f g : ∀ b, π b) (b : β) : nndist (f b) (g b) ≤ nndist f g := by\n  rw [← ENNReal.coe_le_coe, ← edist_nndist, ← edist_nndist]\n  exact edist_le_pi_edist f g b\n\n"}
{"name":"dist_le_pi_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"β : Type u_2\nπ : β → Type u_3\ninst✝¹ : Fintype β\ninst✝ : (b : β) → PseudoMetricSpace (π b)\nf g : (b : β) → π b\nb : β\n⊢ LE.le (Dist.dist (f b) (g b)) (Dist.dist f g)","decl":"lemma dist_le_pi_dist (f g : ∀ b, π b) (b : β) : dist (f b) (g b) ≤ dist f g := by\n  simp only [dist_nndist, NNReal.coe_le_coe, nndist_le_pi_nndist f g b]\n\n"}
{"name":"ball_pi","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"β : Type u_2\nπ : β → Type u_3\ninst✝¹ : Fintype β\ninst✝ : (b : β) → PseudoMetricSpace (π b)\nx : (b : β) → π b\nr : Real\nhr : LT.lt 0 r\n⊢ Eq (Metric.ball x r) (Set.univ.pi fun b => Metric.ball (x b) r)","decl":"/-- An open ball in a product space is a product of open balls. See also `ball_pi'`\nfor a version assuming `Nonempty β` instead of `0 < r`. -/\nlemma ball_pi (x : ∀ b, π b) {r : ℝ} (hr : 0 < r) :\n    ball x r = Set.pi univ fun b => ball (x b) r := by\n  ext p\n  simp [dist_pi_lt_iff hr]\n\n"}
{"name":"ball_pi'","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"β : Type u_2\nπ : β → Type u_3\ninst✝² : Fintype β\ninst✝¹ : (b : β) → PseudoMetricSpace (π b)\ninst✝ : Nonempty β\nx : (b : β) → π b\nr : Real\n⊢ Eq (Metric.ball x r) (Set.univ.pi fun b => Metric.ball (x b) r)","decl":"/-- An open ball in a product space is a product of open balls. See also `ball_pi`\nfor a version assuming `0 < r` instead of `Nonempty β`. -/\nlemma ball_pi' [Nonempty β] (x : ∀ b, π b) (r : ℝ) :\n    ball x r = Set.pi univ fun b => ball (x b) r :=\n  (lt_or_le 0 r).elim (ball_pi x) fun hr => by simp [ball_eq_empty.2 hr]\n\n"}
{"name":"closedBall_pi","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"β : Type u_2\nπ : β → Type u_3\ninst✝¹ : Fintype β\ninst✝ : (b : β) → PseudoMetricSpace (π b)\nx : (b : β) → π b\nr : Real\nhr : LE.le 0 r\n⊢ Eq (Metric.closedBall x r) (Set.univ.pi fun b => Metric.closedBall (x b) r)","decl":"/-- A closed ball in a product space is a product of closed balls. See also `closedBall_pi'`\nfor a version assuming `Nonempty β` instead of `0 ≤ r`. -/\nlemma closedBall_pi (x : ∀ b, π b) {r : ℝ} (hr : 0 ≤ r) :\n    closedBall x r = Set.pi univ fun b => closedBall (x b) r := by\n  ext p\n  simp [dist_pi_le_iff hr]\n\n"}
{"name":"closedBall_pi'","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"β : Type u_2\nπ : β → Type u_3\ninst✝² : Fintype β\ninst✝¹ : (b : β) → PseudoMetricSpace (π b)\ninst✝ : Nonempty β\nx : (b : β) → π b\nr : Real\n⊢ Eq (Metric.closedBall x r) (Set.univ.pi fun b => Metric.closedBall (x b) r)","decl":"/-- A closed ball in a product space is a product of closed balls. See also `closedBall_pi`\nfor a version assuming `0 ≤ r` instead of `Nonempty β`. -/\nlemma closedBall_pi' [Nonempty β] (x : ∀ b, π b) (r : ℝ) :\n    closedBall x r = Set.pi univ fun b => closedBall (x b) r :=\n  (le_or_lt 0 r).elim (closedBall_pi x) fun hr => by simp [closedBall_eq_empty.2 hr]\n\n"}
{"name":"sphere_pi","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"β : Type u_2\nπ : β → Type u_3\ninst✝¹ : Fintype β\ninst✝ : (b : β) → PseudoMetricSpace (π b)\nx : (b : β) → π b\nr : Real\nh : Or (LT.lt 0 r) (Nonempty β)\n⊢ Eq (Metric.sphere x r) (Inter.inter (Set.iUnion fun i => Set.preimage (Function.eval i) (Metric.sphere (x i) r)) (Metric.closedBall x r))","decl":"/-- A sphere in a product space is a union of spheres on each component restricted to the closed\nball. -/\nlemma sphere_pi (x : ∀ b, π b) {r : ℝ} (h : 0 < r ∨ Nonempty β) :\n    sphere x r = (⋃ i : β, Function.eval i ⁻¹' sphere (x i) r) ∩ closedBall x r := by\n  obtain hr | rfl | hr := lt_trichotomy r 0\n  · simp [hr]\n  · rw [closedBall_eq_sphere_of_nonpos le_rfl, eq_comm, Set.inter_eq_right]\n    letI := h.resolve_left (lt_irrefl _)\n    inhabit β\n    refine subset_iUnion_of_subset default ?_\n    intro x hx\n    replace hx := hx.le\n    rw [dist_pi_le_iff le_rfl] at hx\n    exact le_antisymm (hx default) dist_nonneg\n  · ext\n    simp [dist_pi_eq_iff hr, dist_pi_le_iff hr.le]\n\n"}
{"name":"Fin.nndist_insertNth_insertNth","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_4\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → PseudoMetricSpace (α i)\ni : Fin (HAdd.hAdd n 1)\nx y : α i\nf g : (j : Fin n) → α (i.succAbove j)\n⊢ Eq (NNDist.nndist (i.insertNth x f) (i.insertNth y g)) (Max.max (NNDist.nndist x y) (NNDist.nndist f g))","decl":"@[simp]\nlemma Fin.nndist_insertNth_insertNth {n : ℕ} {α : Fin (n + 1) → Type*}\n    [∀ i, PseudoMetricSpace (α i)] (i : Fin (n + 1)) (x y : α i) (f g : ∀ j, α (i.succAbove j)) :\n    nndist (i.insertNth x f) (i.insertNth y g) = max (nndist x y) (nndist f g) :=\n  eq_of_forall_ge_iff fun c => by simp [nndist_pi_le_iff, i.forall_iff_succAbove]\n\n"}
{"name":"Fin.dist_insertNth_insertNth","module":"Mathlib.Topology.MetricSpace.Pseudo.Pi","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_4\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → PseudoMetricSpace (α i)\ni : Fin (HAdd.hAdd n 1)\nx y : α i\nf g : (j : Fin n) → α (i.succAbove j)\n⊢ Eq (Dist.dist (i.insertNth x f) (i.insertNth y g)) (Max.max (Dist.dist x y) (Dist.dist f g))","decl":"@[simp]\nlemma Fin.dist_insertNth_insertNth {n : ℕ} {α : Fin (n + 1) → Type*}\n    [∀ i, PseudoMetricSpace (α i)] (i : Fin (n + 1)) (x y : α i) (f g : ∀ j, α (i.succAbove j)) :\n    dist (i.insertNth x f) (i.insertNth y g) = max (dist x y) (dist f g) := by\n  simp only [dist_nndist, Fin.nndist_insertNth_insertNth, NNReal.coe_max]\n"}
