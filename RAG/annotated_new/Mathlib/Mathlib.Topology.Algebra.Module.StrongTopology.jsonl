{"name":"UniformConvergenceCLM.instContinuousSemilinearMapClass","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ· : NormedField ğ•œâ‚\ninstâœâ¶ : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module ğ•œâ‚ E\ninstâœÂ³ : TopologicalSpace E\ninstâœÂ² : AddCommGroup F\ninstâœÂ¹ : Module ğ•œâ‚‚ F\ninstâœ : TopologicalSpace F\nğ”– : Set (Set E)\nâŠ¢ ContinuousSemilinearMapClass (UniformConvergenceCLM Ïƒ F ğ”–) Ïƒ E F","decl":"instance instContinuousSemilinearMapClass [TopologicalSpace F] (ğ”– : Set (Set E)) :\n    ContinuousSemilinearMapClass (UniformConvergenceCLM Ïƒ F ğ”–) Ïƒ E F :=\n  ContinuousLinearMap.continuousSemilinearMapClass\n\n"}
{"name":"UniformConvergenceCLM.topologicalSpace_eq","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\ninstâœÂ¹ : UniformSpace F\ninstâœ : UniformAddGroup F\nğ”– : Set (Set E)\nâŠ¢ Eq (UniformConvergenceCLM.instTopologicalSpace Ïƒ F ğ”–) (TopologicalSpace.induced (Function.comp (â‡‘(UniformOnFun.ofFun ğ”–)) DFunLike.coe) (UniformOnFun.topologicalSpace E F ğ”–))","decl":"theorem topologicalSpace_eq [UniformSpace F] [UniformAddGroup F] (ğ”– : Set (Set E)) :\n    instTopologicalSpace Ïƒ F ğ”– = TopologicalSpace.induced (UniformOnFun.ofFun ğ”– âˆ˜ DFunLike.coe)\n      (UniformOnFun.topologicalSpace E F ğ”–) := by\n  rw [instTopologicalSpace]\n  congr\n  exact UniformAddGroup.toUniformSpace_eq\n\n"}
{"name":"UniformConvergenceCLM.uniformSpace_eq","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\ninstâœÂ¹ : UniformSpace F\ninstâœ : UniformAddGroup F\nğ”– : Set (Set E)\nâŠ¢ Eq (UniformConvergenceCLM.instUniformSpace Ïƒ F ğ”–) (UniformSpace.comap (Function.comp (â‡‘(UniformOnFun.ofFun ğ”–)) DFunLike.coe) (UniformOnFun.uniformSpace E F ğ”–))","decl":"theorem uniformSpace_eq [UniformSpace F] [UniformAddGroup F] (ğ”– : Set (Set E)) :\n    instUniformSpace Ïƒ F ğ”– =\n      UniformSpace.comap (UniformOnFun.ofFun ğ”– âˆ˜ DFunLike.coe)\n        (UniformOnFun.uniformSpace E F ğ”–) := by\n  rw [instUniformSpace, UniformSpace.replaceTopology_eq]\n\n"}
{"name":"UniformConvergenceCLM.uniformity_toTopologicalSpace_eq","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\ninstâœÂ¹ : UniformSpace F\ninstâœ : UniformAddGroup F\nğ”– : Set (Set E)\nâŠ¢ Eq UniformSpace.toTopologicalSpace (UniformConvergenceCLM.instTopologicalSpace Ïƒ F ğ”–)","decl":"@[simp]\ntheorem uniformity_toTopologicalSpace_eq [UniformSpace F] [UniformAddGroup F] (ğ”– : Set (Set E)) :\n    (UniformConvergenceCLM.instUniformSpace Ïƒ F ğ”–).toTopologicalSpace =\n      UniformConvergenceCLM.instTopologicalSpace Ïƒ F ğ”– :=\n  rfl\n\n"}
{"name":"UniformConvergenceCLM.isUniformInducing_coeFn","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\ninstâœÂ¹ : UniformSpace F\ninstâœ : UniformAddGroup F\nğ”– : Set (Set E)\nâŠ¢ IsUniformInducing (Function.comp (â‡‘(UniformOnFun.ofFun ğ”–)) DFunLike.coe)","decl":"theorem isUniformInducing_coeFn [UniformSpace F] [UniformAddGroup F] (ğ”– : Set (Set E)) :\n    IsUniformInducing (Î± := UniformConvergenceCLM Ïƒ F ğ”–) (UniformOnFun.ofFun ğ”– âˆ˜ DFunLike.coe) :=\n  âŸ¨rflâŸ©\n\n"}
{"name":"UniformConvergenceCLM.isUniformEmbedding_coeFn","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\ninstâœÂ¹ : UniformSpace F\ninstâœ : UniformAddGroup F\nğ”– : Set (Set E)\nâŠ¢ IsUniformEmbedding (Function.comp (â‡‘(UniformOnFun.ofFun ğ”–)) DFunLike.coe)","decl":"theorem isUniformEmbedding_coeFn [UniformSpace F] [UniformAddGroup F] (ğ”– : Set (Set E)) :\n    IsUniformEmbedding (Î± := UniformConvergenceCLM Ïƒ F ğ”–) (UniformOnFun.ofFun ğ”– âˆ˜ DFunLike.coe) :=\n  âŸ¨isUniformInducing_coeFn .., DFunLike.coe_injectiveâŸ©\n\n"}
{"name":"UniformConvergenceCLM.uniformEmbedding_coeFn","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\ninstâœÂ¹ : UniformSpace F\ninstâœ : UniformAddGroup F\nğ”– : Set (Set E)\nâŠ¢ IsUniformEmbedding (Function.comp (â‡‘(UniformOnFun.ofFun ğ”–)) DFunLike.coe)","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_coeFn := isUniformEmbedding_coeFn\n\n"}
{"name":"UniformConvergenceCLM.isEmbedding_coeFn","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\ninstâœÂ¹ : UniformSpace F\ninstâœ : UniformAddGroup F\nğ”– : Set (Set E)\nâŠ¢ Topology.IsEmbedding (Function.comp (â‡‘(UniformOnFun.ofFun ğ”–)) DFunLike.coe)","decl":"theorem isEmbedding_coeFn [UniformSpace F] [UniformAddGroup F] (ğ”– : Set (Set E)) :\n    IsEmbedding (X := UniformConvergenceCLM Ïƒ F ğ”–) (Y := E â†’áµ¤[ğ”–] F)\n      (UniformOnFun.ofFun ğ”– âˆ˜ DFunLike.coe) :=\n  IsUniformEmbedding.isEmbedding (isUniformEmbedding_coeFn _ _ _)\n\n"}
{"name":"UniformConvergenceCLM.embedding_coeFn","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\ninstâœÂ¹ : UniformSpace F\ninstâœ : UniformAddGroup F\nğ”– : Set (Set E)\nâŠ¢ Topology.IsEmbedding (Function.comp (â‡‘(UniformOnFun.ofFun ğ”–)) DFunLike.coe)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_coeFn := isEmbedding_coeFn\n\n"}
{"name":"UniformConvergenceCLM.coe_zero","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\ninstâœÂ¹ : TopologicalSpace F\ninstâœ : TopologicalAddGroup F\nğ”– : Set (Set E)\nâŠ¢ Eq (â‡‘0) 0","decl":"@[simp]\ntheorem coe_zero [TopologicalSpace F] [TopologicalAddGroup F] (ğ”– : Set (Set E)) :\n    â‡‘(0 : UniformConvergenceCLM Ïƒ F ğ”–) = 0 :=\n  rfl\n\n"}
{"name":"UniformConvergenceCLM.instUniformAddGroup","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\ninstâœÂ¹ : UniformSpace F\ninstâœ : UniformAddGroup F\nğ”– : Set (Set E)\nâŠ¢ UniformAddGroup (UniformConvergenceCLM Ïƒ F ğ”–)","decl":"instance instUniformAddGroup [UniformSpace F] [UniformAddGroup F] (ğ”– : Set (Set E)) :\n    UniformAddGroup (UniformConvergenceCLM Ïƒ F ğ”–) := by\n  let Ï† : (UniformConvergenceCLM Ïƒ F ğ”–) â†’+ E â†’áµ¤[ğ”–] F :=\n    âŸ¨âŸ¨(DFunLike.coe : (UniformConvergenceCLM Ïƒ F ğ”–) â†’ E â†’áµ¤[ğ”–] F), rflâŸ©, fun _ _ => rflâŸ©\n  exact (isUniformEmbedding_coeFn _ _ _).uniformAddGroup Ï†\n\n"}
{"name":"UniformConvergenceCLM.instTopologicalAddGroup","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\ninstâœÂ¹ : TopologicalSpace F\ninstâœ : TopologicalAddGroup F\nğ”– : Set (Set E)\nâŠ¢ TopologicalAddGroup (UniformConvergenceCLM Ïƒ F ğ”–)","decl":"instance instTopologicalAddGroup [TopologicalSpace F] [TopologicalAddGroup F]\n    (ğ”– : Set (Set E)) : TopologicalAddGroup (UniformConvergenceCLM Ïƒ F ğ”–) := by\n  letI : UniformSpace F := TopologicalAddGroup.toUniformSpace F\n  haveI : UniformAddGroup F := comm_topologicalAddGroup_is_uniform\n  infer_instance\n\n"}
{"name":"UniformConvergenceCLM.continuousEvalConst","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\ninstâœÂ¹ : TopologicalSpace F\ninstâœ : TopologicalAddGroup F\nğ”– : Set (Set E)\nhğ”– : Eq ğ”–.sUnion Set.univ\nâŠ¢ ContinuousEvalConst (UniformConvergenceCLM Ïƒ F ğ”–) E F","decl":"theorem continuousEvalConst [TopologicalSpace F] [TopologicalAddGroup F]\n    (ğ”– : Set (Set E)) (hğ”– : â‹ƒâ‚€ ğ”– = Set.univ) :\n    ContinuousEvalConst (UniformConvergenceCLM Ïƒ F ğ”–) E F where\n  continuous_eval_const x := by\n    letI : UniformSpace F := TopologicalAddGroup.toUniformSpace F\n    haveI : UniformAddGroup F := comm_topologicalAddGroup_is_uniform\n    exact (UniformOnFun.uniformContinuous_eval hğ”– x).continuous.comp\n      (isEmbedding_coeFn Ïƒ F ğ”–).continuous\n\n"}
{"name":"UniformConvergenceCLM.t2Space","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¹ : NormedField ğ•œâ‚\ninstâœâ¸ : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ· : AddCommGroup E\ninstâœâ¶ : Module ğ•œâ‚ E\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : AddCommGroup F\ninstâœÂ³ : Module ğ•œâ‚‚ F\ninstâœÂ² : TopologicalSpace F\ninstâœÂ¹ : TopologicalAddGroup F\ninstâœ : T2Space F\nğ”– : Set (Set E)\nhğ”– : Eq ğ”–.sUnion Set.univ\nâŠ¢ T2Space (UniformConvergenceCLM Ïƒ F ğ”–)","decl":"theorem t2Space [TopologicalSpace F] [TopologicalAddGroup F] [T2Space F]\n    (ğ”– : Set (Set E)) (hğ”– : â‹ƒâ‚€ ğ”– = univ) : T2Space (UniformConvergenceCLM Ïƒ F ğ”–) := by\n  letI : UniformSpace F := TopologicalAddGroup.toUniformSpace F\n  haveI : UniformAddGroup F := comm_topologicalAddGroup_is_uniform\n  haveI : T2Space (E â†’áµ¤[ğ”–] F) := UniformOnFun.t2Space_of_covering hğ”–\n  exact (isEmbedding_coeFn Ïƒ F ğ”–).t2Space\n\n"}
{"name":"UniformConvergenceCLM.continuousSMul","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœÂ¹Â¹ : NormedField ğ•œâ‚\ninstâœÂ¹â° : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¹ : AddCommGroup E\ninstâœâ¸ : Module ğ•œâ‚ E\ninstâœâ· : TopologicalSpace E\ninstâœâ¶ : AddCommGroup F\ninstâœâµ : Module ğ•œâ‚‚ F\ninstâœâ´ : RingHomSurjective Ïƒ\ninstâœÂ³ : RingHomIsometric Ïƒ\ninstâœÂ² : TopologicalSpace F\ninstâœÂ¹ : TopologicalAddGroup F\ninstâœ : ContinuousSMul ğ•œâ‚‚ F\nğ”– : Set (Set E)\nhğ”–â‚ƒ : âˆ€ (S : Set E), Membership.mem ğ”– S â†’ Bornology.IsVonNBounded ğ•œâ‚ S\nâŠ¢ ContinuousSMul ğ•œâ‚‚ (UniformConvergenceCLM Ïƒ F ğ”–)","decl":"theorem continuousSMul [RingHomSurjective Ïƒ] [RingHomIsometric Ïƒ]\n    [TopologicalSpace F] [TopologicalAddGroup F] [ContinuousSMul ğ•œâ‚‚ F] (ğ”– : Set (Set E))\n    (hğ”–â‚ƒ : âˆ€ S âˆˆ ğ”–, IsVonNBounded ğ•œâ‚ S) :\n    ContinuousSMul ğ•œâ‚‚ (UniformConvergenceCLM Ïƒ F ğ”–) := by\n  letI : UniformSpace F := TopologicalAddGroup.toUniformSpace F\n  haveI : UniformAddGroup F := comm_topologicalAddGroup_is_uniform\n  let Ï† : (UniformConvergenceCLM Ïƒ F ğ”–) â†’â‚—[ğ•œâ‚‚] E â†’ F :=\n    âŸ¨âŸ¨DFunLike.coe, fun _ _ => rflâŸ©, fun _ _ => rflâŸ©\n  exact UniformOnFun.continuousSMul_induced_of_image_bounded ğ•œâ‚‚ E F (UniformConvergenceCLM Ïƒ F ğ”–) Ï†\n    âŸ¨rflâŸ© fun u s hs => (hğ”–â‚ƒ s hs).image u\n\n"}
{"name":"UniformConvergenceCLM.hasBasis_nhds_zero_of_basis","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\ninstâœÂ¹ : TopologicalSpace F\ninstâœ : TopologicalAddGroup F\nÎ¹ : Type u_5\nğ”– : Set (Set E)\nhğ”–â‚ : ğ”–.Nonempty\nhğ”–â‚‚ : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) ğ”–\np : Î¹ â†’ Prop\nb : Î¹ â†’ Set F\nh : (nhds 0).HasBasis p b\nâŠ¢ (nhds 0).HasBasis (fun Si => And (Membership.mem ğ”– Si.1) (p Si.2)) fun Si => setOf fun f => âˆ€ (x : E), Membership.mem Si.1 x â†’ Membership.mem (b Si.2) (f x)","decl":"theorem hasBasis_nhds_zero_of_basis [TopologicalSpace F] [TopologicalAddGroup F]\n    {Î¹ : Type*} (ğ”– : Set (Set E)) (hğ”–â‚ : ğ”–.Nonempty) (hğ”–â‚‚ : DirectedOn (Â· âŠ† Â·) ğ”–) {p : Î¹ â†’ Prop}\n    {b : Î¹ â†’ Set F} (h : (ğ“ 0 : Filter F).HasBasis p b) :\n    (ğ“ (0 : UniformConvergenceCLM Ïƒ F ğ”–)).HasBasis\n      (fun Si : Set E Ã— Î¹ => Si.1 âˆˆ ğ”– âˆ§ p Si.2)\n      fun Si => { f : E â†’SL[Ïƒ] F | âˆ€ x âˆˆ Si.1, f x âˆˆ b Si.2 } := by\n  letI : UniformSpace F := TopologicalAddGroup.toUniformSpace F\n  haveI : UniformAddGroup F := comm_topologicalAddGroup_is_uniform\n  rw [(isEmbedding_coeFn Ïƒ F ğ”–).isInducing.nhds_eq_comap]\n  exact (UniformOnFun.hasBasis_nhds_zero_of_basis ğ”– hğ”–â‚ hğ”–â‚‚ h).comap DFunLike.coe\n\n"}
{"name":"UniformConvergenceCLM.hasBasis_nhds_zero","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\ninstâœÂ¹ : TopologicalSpace F\ninstâœ : TopologicalAddGroup F\nğ”– : Set (Set E)\nhğ”–â‚ : ğ”–.Nonempty\nhğ”–â‚‚ : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) ğ”–\nâŠ¢ (nhds 0).HasBasis (fun SV => And (Membership.mem ğ”– SV.1) (Membership.mem (nhds 0) SV.2)) fun SV => setOf fun f => âˆ€ (x : E), Membership.mem SV.1 x â†’ Membership.mem SV.2 (f x)","decl":"theorem hasBasis_nhds_zero [TopologicalSpace F] [TopologicalAddGroup F]\n    (ğ”– : Set (Set E)) (hğ”–â‚ : ğ”–.Nonempty) (hğ”–â‚‚ : DirectedOn (Â· âŠ† Â·) ğ”–) :\n    (ğ“ (0 : UniformConvergenceCLM Ïƒ F ğ”–)).HasBasis\n      (fun SV : Set E Ã— Set F => SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ (ğ“ 0 : Filter F)) fun SV =>\n      { f : UniformConvergenceCLM Ïƒ F ğ”– | âˆ€ x âˆˆ SV.1, f x âˆˆ SV.2 } :=\n  hasBasis_nhds_zero_of_basis Ïƒ F ğ”– hğ”–â‚ hğ”–â‚‚ (ğ“ 0).basis_sets\n\n"}
{"name":"UniformConvergenceCLM.nhds_zero_eq_of_basis","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\ninstâœÂ¹ : TopologicalSpace F\ninstâœ : TopologicalAddGroup F\nğ”– : Set (Set E)\nÎ¹ : Type u_5\np : Î¹ â†’ Prop\nb : Î¹ â†’ Set F\nh : (nhds 0).HasBasis p b\nâŠ¢ Eq (nhds 0) (iInf fun s => iInf fun x => iInf fun i => iInf fun x => Filter.principal (setOf fun f => Set.MapsTo (â‡‘f) s (b i)))","decl":"theorem nhds_zero_eq_of_basis [TopologicalSpace F] [TopologicalAddGroup F] (ğ”– : Set (Set E))\n    {Î¹ : Type*} {p : Î¹ â†’ Prop} {b : Î¹ â†’ Set F} (h : (ğ“ 0 : Filter F).HasBasis p b) :\n    ğ“ (0 : UniformConvergenceCLM Ïƒ F ğ”–) =\n      â¨… (s : Set E) (_ : s âˆˆ ğ”–) (i : Î¹) (_ : p i),\n        ğ“Ÿ {f : UniformConvergenceCLM Ïƒ F ğ”– | MapsTo f s (b i)} := by\n  letI : UniformSpace F := TopologicalAddGroup.toUniformSpace F\n  haveI : UniformAddGroup F := comm_topologicalAddGroup_is_uniform\n  rw [(isEmbedding_coeFn Ïƒ F ğ”–).isInducing.nhds_eq_comap,\n    UniformOnFun.nhds_eq_of_basis _ _ h.uniformity_of_nhds_zero]\n  simp [MapsTo]\n\n"}
{"name":"UniformConvergenceCLM.nhds_zero_eq","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\ninstâœÂ¹ : TopologicalSpace F\ninstâœ : TopologicalAddGroup F\nğ”– : Set (Set E)\nâŠ¢ Eq (nhds 0) (iInf fun s => iInf fun h => iInf fun t => iInf fun h => Filter.principal (setOf fun f => Set.MapsTo (â‡‘f) s t))","decl":"theorem nhds_zero_eq [TopologicalSpace F] [TopologicalAddGroup F] (ğ”– : Set (Set E)) :\n    ğ“ (0 : UniformConvergenceCLM Ïƒ F ğ”–) =\n      â¨… s âˆˆ ğ”–, â¨… t âˆˆ ğ“ (0 : F),\n        ğ“Ÿ {f : UniformConvergenceCLM Ïƒ F ğ”– | MapsTo f s t} :=\n  nhds_zero_eq_of_basis _ _ _ (ğ“ 0).basis_sets\n\n"}
{"name":"UniformConvergenceCLM.eventually_nhds_zero_mapsTo","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\ninstâœÂ¹ : TopologicalSpace F\ninstâœ : TopologicalAddGroup F\nğ”– : Set (Set E)\ns : Set E\nhs : Membership.mem ğ”– s\nU : Set F\nhu : Membership.mem (nhds 0) U\nâŠ¢ Filter.Eventually (fun f => Set.MapsTo (â‡‘f) s U) (nhds 0)","decl":"variable {F} in\ntheorem eventually_nhds_zero_mapsTo [TopologicalSpace F] [TopologicalAddGroup F]\n    {ğ”– : Set (Set E)} {s : Set E} (hs : s âˆˆ ğ”–) {U : Set F} (hu : U âˆˆ ğ“ 0) :\n    âˆ€á¶  f : UniformConvergenceCLM Ïƒ F ğ”– in ğ“ 0, MapsTo f s U := by\n  rw [nhds_zero_eq]\n  apply_rules [mem_iInf_of_mem, mem_principal_self]\n\n"}
{"name":"UniformConvergenceCLM.isVonNBounded_image2_apply","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœÂ¹Â² : NormedField ğ•œâ‚\ninstâœÂ¹Â¹ : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœÂ¹â° : AddCommGroup E\ninstâœâ¹ : Module ğ•œâ‚ E\ninstâœâ¸ : TopologicalSpace E\ninstâœâ· : AddCommGroup F\ninstâœâ¶ : Module ğ•œâ‚‚ F\nR : Type u_5\ninstâœâµ : SeminormedRing R\ninstâœâ´ : TopologicalSpace F\ninstâœÂ³ : TopologicalAddGroup F\ninstâœÂ² : Module R F\ninstâœÂ¹ : ContinuousConstSMul R F\ninstâœ : SMulCommClass ğ•œâ‚‚ R F\nğ”– : Set (Set E)\nS : Set (UniformConvergenceCLM Ïƒ F ğ”–)\nhS : Bornology.IsVonNBounded R S\ns : Set E\nhs : Membership.mem ğ”– s\nâŠ¢ Bornology.IsVonNBounded R (Set.image2 (fun f x => f x) S s)","decl":"variable {Ïƒ F} in\ntheorem isVonNBounded_image2_apply {R : Type*} [SeminormedRing R]\n    [TopologicalSpace F] [TopologicalAddGroup F]\n    [Module R F] [ContinuousConstSMul R F] [SMulCommClass ğ•œâ‚‚ R F]\n    {ğ”– : Set (Set E)} {S : Set (UniformConvergenceCLM Ïƒ F ğ”–)} (hS : IsVonNBounded R S)\n    {s : Set E} (hs : s âˆˆ ğ”–) : IsVonNBounded R (Set.image2 (fun f x â†¦ f x) S s) := by\n  intro U hU\n  filter_upwards [hS (eventually_nhds_zero_mapsTo Ïƒ hs hU)] with c hc\n  rw [image2_subset_iff]\n  intro f hf x hx\n  rcases hc hf with âŸ¨g, hg, rflâŸ©\n  exact smul_mem_smul_set (hg hx)\n\n"}
{"name":"UniformConvergenceCLM.isVonNBounded_iff","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœÂ¹Â² : NormedField ğ•œâ‚\ninstâœÂ¹Â¹ : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœÂ¹â° : AddCommGroup E\ninstâœâ¹ : Module ğ•œâ‚ E\ninstâœâ¸ : TopologicalSpace E\ninstâœâ· : AddCommGroup F\ninstâœâ¶ : Module ğ•œâ‚‚ F\nR : Type u_5\ninstâœâµ : NormedDivisionRing R\ninstâœâ´ : TopologicalSpace F\ninstâœÂ³ : TopologicalAddGroup F\ninstâœÂ² : Module R F\ninstâœÂ¹ : ContinuousConstSMul R F\ninstâœ : SMulCommClass ğ•œâ‚‚ R F\nğ”– : Set (Set E)\nS : Set (UniformConvergenceCLM Ïƒ F ğ”–)\nâŠ¢ Iff (Bornology.IsVonNBounded R S) (âˆ€ (s : Set E), Membership.mem ğ”– s â†’ Bornology.IsVonNBounded R (Set.image2 (fun f x => f x) S s))","decl":"variable {Ïƒ F} in\n/-- A set `S` of continuous linear maps with topology of uniform convergence on sets `s âˆˆ ğ”–`\nis von Neumann bounded iff for any `s âˆˆ ğ”–`,\nthe set `{f x | (f âˆˆ S) (x âˆˆ s)}` is von Neumann bounded. -/\ntheorem isVonNBounded_iff {R : Type*} [NormedDivisionRing R]\n    [TopologicalSpace F] [TopologicalAddGroup F]\n    [Module R F] [ContinuousConstSMul R F] [SMulCommClass ğ•œâ‚‚ R F]\n    {ğ”– : Set (Set E)} {S : Set (UniformConvergenceCLM Ïƒ F ğ”–)} :\n    IsVonNBounded R S â†” âˆ€ s âˆˆ ğ”–, IsVonNBounded R (Set.image2 (fun f x â†¦ f x) S s) := by\n  refine âŸ¨fun hS s hs â†¦ isVonNBounded_image2_apply hS hs, fun h â†¦ ?_âŸ©\n  simp_rw [isVonNBounded_iff_absorbing_le, nhds_zero_eq, le_iInf_iff, le_principal_iff]\n  intro s hs U hU\n  rw [Filter.mem_absorbing, Absorbs]\n  filter_upwards [h s hs hU, eventually_ne_cobounded 0] with c hc hcâ‚€ f hf\n  rw [mem_smul_set_iff_inv_smul_memâ‚€ hcâ‚€]\n  intro x hx\n  simpa only [mem_smul_set_iff_inv_smul_memâ‚€ hcâ‚€] using hc (mem_image2_of_mem hf hx)\n\n"}
{"name":"UniformConvergenceCLM.instUniformContinuousConstSMul","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœÂ¹Â² : NormedField ğ•œâ‚\ninstâœÂ¹Â¹ : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœÂ¹â° : AddCommGroup E\ninstâœâ¹ : Module ğ•œâ‚ E\ninstâœâ¸ : TopologicalSpace E\ninstâœâ· : AddCommGroup F\ninstâœâ¶ : Module ğ•œâ‚‚ F\nM : Type u_5\ninstâœâµ : Monoid M\ninstâœâ´ : DistribMulAction M F\ninstâœÂ³ : SMulCommClass ğ•œâ‚‚ M F\ninstâœÂ² : UniformSpace F\ninstâœÂ¹ : UniformAddGroup F\ninstâœ : UniformContinuousConstSMul M F\nğ”– : Set (Set E)\nâŠ¢ UniformContinuousConstSMul M (UniformConvergenceCLM Ïƒ F ğ”–)","decl":"instance instUniformContinuousConstSMul (M : Type*)\n    [Monoid M] [DistribMulAction M F] [SMulCommClass ğ•œâ‚‚ M F]\n    [UniformSpace F] [UniformAddGroup F] [UniformContinuousConstSMul M F] (ğ”– : Set (Set E)) :\n    UniformContinuousConstSMul M (UniformConvergenceCLM Ïƒ F ğ”–) :=\n  (isUniformInducing_coeFn Ïƒ F ğ”–).uniformContinuousConstSMul fun _ _ â†¦ by rfl\n\n"}
{"name":"UniformConvergenceCLM.instContinuousConstSMul","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœÂ¹Â² : NormedField ğ•œâ‚\ninstâœÂ¹Â¹ : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœÂ¹â° : AddCommGroup E\ninstâœâ¹ : Module ğ•œâ‚ E\ninstâœâ¸ : TopologicalSpace E\ninstâœâ· : AddCommGroup F\ninstâœâ¶ : Module ğ•œâ‚‚ F\nM : Type u_5\ninstâœâµ : Monoid M\ninstâœâ´ : DistribMulAction M F\ninstâœÂ³ : SMulCommClass ğ•œâ‚‚ M F\ninstâœÂ² : TopologicalSpace F\ninstâœÂ¹ : TopologicalAddGroup F\ninstâœ : ContinuousConstSMul M F\nğ”– : Set (Set E)\nâŠ¢ ContinuousConstSMul M (UniformConvergenceCLM Ïƒ F ğ”–)","decl":"instance instContinuousConstSMul (M : Type*)\n    [Monoid M] [DistribMulAction M F] [SMulCommClass ğ•œâ‚‚ M F]\n    [TopologicalSpace F] [TopologicalAddGroup F] [ContinuousConstSMul M F] (ğ”– : Set (Set E)) :\n    ContinuousConstSMul M (UniformConvergenceCLM Ïƒ F ğ”–) :=\n  let _ := TopologicalAddGroup.toUniformSpace F\n  have _ : UniformAddGroup F := comm_topologicalAddGroup_is_uniform\n  have _ := uniformContinuousConstSMul_of_continuousConstSMul M F\n  inferInstance\n\n"}
{"name":"UniformConvergenceCLM.tendsto_iff_tendstoUniformlyOn","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\nÎ¹ : Type u_5\np : Filter Î¹\ninstâœÂ¹ : UniformSpace F\ninstâœ : UniformAddGroup F\nğ”– : Set (Set E)\na : Î¹ â†’ UniformConvergenceCLM Ïƒ F ğ”–\naâ‚€ : UniformConvergenceCLM Ïƒ F ğ”–\nâŠ¢ Iff (Filter.Tendsto a p (nhds aâ‚€)) (âˆ€ (s : Set E), Membership.mem ğ”– s â†’ TendstoUniformlyOn (fun x1 x2 => (a x1) x2) (â‡‘aâ‚€) p s)","decl":"theorem tendsto_iff_tendstoUniformlyOn {Î¹ : Type*} {p : Filter Î¹} [UniformSpace F]\n    [UniformAddGroup F] (ğ”– : Set (Set E)) {a : Î¹ â†’ UniformConvergenceCLM Ïƒ F ğ”–}\n    {aâ‚€ : UniformConvergenceCLM Ïƒ F ğ”–} :\n    Filter.Tendsto a p (ğ“ aâ‚€) â†” âˆ€ s âˆˆ ğ”–, TendstoUniformlyOn (a Â· Â·) aâ‚€ p s := by\n  rw [(isEmbedding_coeFn Ïƒ F ğ”–).tendsto_nhds_iff, UniformOnFun.tendsto_iff_tendstoUniformlyOn]\n  rfl\n\n"}
{"name":"UniformConvergenceCLM.isUniformInducing_postcomp","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœÂ¹â´ : NormedField ğ•œâ‚\ninstâœÂ¹Â³ : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœÂ¹Â² : AddCommGroup E\ninstâœÂ¹Â¹ : Module ğ•œâ‚ E\ninstâœÂ¹â° : TopologicalSpace E\ninstâœâ¹ : AddCommGroup F\ninstâœâ¸ : Module ğ•œâ‚‚ F\nG : Type u_5\ninstâœâ· : AddCommGroup G\ninstâœâ¶ : UniformSpace G\ninstâœâµ : UniformAddGroup G\nğ•œâ‚ƒ : Type u_6\ninstâœâ´ : NormedField ğ•œâ‚ƒ\ninstâœÂ³ : Module ğ•œâ‚ƒ G\nÏ„ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏ : RingHom ğ•œâ‚ ğ•œâ‚ƒ\ninstâœÂ² : RingHomCompTriple Ïƒ Ï„ Ï\ninstâœÂ¹ : UniformSpace F\ninstâœ : UniformAddGroup F\ng : ContinuousLinearMap Ï„ F G\nhg : IsUniformInducing â‡‘g\nğ”– : Set (Set E)\nâŠ¢ IsUniformInducing g.comp","decl":"variable {F} in\ntheorem isUniformInducing_postcomp\n    {G : Type*} [AddCommGroup G] [UniformSpace G] [UniformAddGroup G]\n    {ğ•œâ‚ƒ : Type*} [NormedField ğ•œâ‚ƒ] [Module ğ•œâ‚ƒ G]\n    {Ï„ : ğ•œâ‚‚ â†’+* ğ•œâ‚ƒ} {Ï : ğ•œâ‚ â†’+* ğ•œâ‚ƒ} [RingHomCompTriple Ïƒ Ï„ Ï] [UniformSpace F] [UniformAddGroup F]\n    (g : F â†’SL[Ï„] G) (hg : IsUniformInducing g) (ğ”– : Set (Set E)) :\n    IsUniformInducing (Î± := UniformConvergenceCLM Ïƒ F ğ”–) (Î² := UniformConvergenceCLM Ï G ğ”–)\n      g.comp := by\n  rw [â† (isUniformInducing_coeFn _ _ _).of_comp_iff]\n  exact (UniformOnFun.postcomp_isUniformInducing hg).comp (isUniformInducing_coeFn _ _ _)\n\n"}
{"name":"UniformConvergenceCLM.completeSpace","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœÂ¹â° : NormedField ğ•œâ‚\ninstâœâ¹ : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¸ : AddCommGroup E\ninstâœâ· : Module ğ•œâ‚ E\ninstâœâ¶ : TopologicalSpace E\ninstâœâµ : AddCommGroup F\ninstâœâ´ : Module ğ•œâ‚‚ F\ninstâœÂ³ : UniformSpace F\ninstâœÂ² : UniformAddGroup F\ninstâœÂ¹ : ContinuousSMul ğ•œâ‚‚ F\ninstâœ : CompleteSpace F\nğ”– : Set (Set E)\nhğ”– : Topology.RestrictGenTopology ğ”–\nhğ”–U : Eq ğ”–.sUnion Set.univ\nâŠ¢ CompleteSpace (UniformConvergenceCLM Ïƒ F ğ”–)","decl":"theorem completeSpace [UniformSpace F] [UniformAddGroup F] [ContinuousSMul ğ•œâ‚‚ F] [CompleteSpace F]\n    {ğ”– : Set (Set E)} (hğ”– : RestrictGenTopology ğ”–) (hğ”–U : â‹ƒâ‚€ ğ”– = univ) :\n    CompleteSpace (UniformConvergenceCLM Ïƒ F ğ”–) := by\n  wlog hF : T2Space F generalizing F\n  Â· rw [(isUniformInducing_postcomp Ïƒ (SeparationQuotient.mkCLM ğ•œâ‚‚ F)\n      SeparationQuotient.isUniformInducing_mk _).completeSpace_congr]\n    exacts [this _ inferInstance, SeparationQuotient.postcomp_mkCLM_surjective F Ïƒ E]\n  rw [completeSpace_iff_isComplete_range (isUniformInducing_coeFn _ _ _)]\n  apply IsClosed.isComplete\n  have Hâ‚ : IsClosed {f : E â†’áµ¤[ğ”–] F | Continuous ((UniformOnFun.toFun ğ”–) f)} :=\n    UniformOnFun.isClosed_setOf_continuous hğ”–\n  convert Hâ‚.inter <| (LinearMap.isClosed_range_coe E F Ïƒ).preimage\n    (UniformOnFun.uniformContinuous_toFun hğ”–U).continuous\n  exact ContinuousLinearMap.range_coeFn_eq\n\n"}
{"name":"UniformConvergenceCLM.uniformSpace_mono","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\nğ”–â‚ ğ”–â‚‚ : Set (Set E)\ninstâœÂ¹ : UniformSpace F\ninstâœ : UniformAddGroup F\nh : HasSubset.Subset ğ”–â‚‚ ğ”–â‚\nâŠ¢ LE.le (UniformConvergenceCLM.instUniformSpace Ïƒ F ğ”–â‚) (UniformConvergenceCLM.instUniformSpace Ïƒ F ğ”–â‚‚)","decl":"theorem uniformSpace_mono [UniformSpace F] [UniformAddGroup F] (h : ğ”–â‚‚ âŠ† ğ”–â‚) :\n    instUniformSpace Ïƒ F ğ”–â‚ â‰¤ instUniformSpace Ïƒ F ğ”–â‚‚ := by\n  simp_rw [uniformSpace_eq]\n  exact UniformSpace.comap_mono (UniformOnFun.mono (le_refl _) h)\n\n"}
{"name":"UniformConvergenceCLM.topologicalSpace_mono","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\nğ”–â‚ ğ”–â‚‚ : Set (Set E)\ninstâœÂ¹ : TopologicalSpace F\ninstâœ : TopologicalAddGroup F\nh : HasSubset.Subset ğ”–â‚‚ ğ”–â‚\nâŠ¢ LE.le (UniformConvergenceCLM.instTopologicalSpace Ïƒ F ğ”–â‚) (UniformConvergenceCLM.instTopologicalSpace Ïƒ F ğ”–â‚‚)","decl":"theorem topologicalSpace_mono [TopologicalSpace F] [TopologicalAddGroup F] (h : ğ”–â‚‚ âŠ† ğ”–â‚) :\n    instTopologicalSpace Ïƒ F ğ”–â‚ â‰¤ instTopologicalSpace Ïƒ F ğ”–â‚‚ := by\n  letI := TopologicalAddGroup.toUniformSpace F\n  haveI : UniformAddGroup F := comm_topologicalAddGroup_is_uniform\n  simp_rw [â† uniformity_toTopologicalSpace_eq]\n  exact UniformSpace.toTopologicalSpace_mono (uniformSpace_mono Ïƒ F h)\n\n"}
{"name":"ContinuousLinearMap.topologicalAddGroup","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : AddCommGroup F\ninstâœÂ³ : Module ğ•œâ‚‚ F\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalSpace F\ninstâœ : TopologicalAddGroup F\nâŠ¢ TopologicalAddGroup (ContinuousLinearMap Ïƒ E F)","decl":"instance topologicalAddGroup [TopologicalSpace F] [TopologicalAddGroup F] :\n    TopologicalAddGroup (E â†’SL[Ïƒ] F) :=\n  UniformConvergenceCLM.instTopologicalAddGroup Ïƒ F _\n\n"}
{"name":"ContinuousLinearMap.continuousSMul","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœÂ¹Â¹ : NormedField ğ•œâ‚\ninstâœÂ¹â° : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_4\nF : Type u_5\ninstâœâ¹ : AddCommGroup E\ninstâœâ¸ : Module ğ•œâ‚ E\ninstâœâ· : AddCommGroup F\ninstâœâ¶ : Module ğ•œâ‚‚ F\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : RingHomSurjective Ïƒ\ninstâœÂ³ : RingHomIsometric Ïƒ\ninstâœÂ² : TopologicalSpace F\ninstâœÂ¹ : TopologicalAddGroup F\ninstâœ : ContinuousSMul ğ•œâ‚‚ F\nâŠ¢ ContinuousSMul ğ•œâ‚‚ (ContinuousLinearMap Ïƒ E F)","decl":"instance continuousSMul [RingHomSurjective Ïƒ] [RingHomIsometric Ïƒ] [TopologicalSpace F]\n    [TopologicalAddGroup F] [ContinuousSMul ğ•œâ‚‚ F] : ContinuousSMul ğ•œâ‚‚ (E â†’SL[Ïƒ] F) :=\n  UniformConvergenceCLM.continuousSMul Ïƒ F { S | IsVonNBounded ğ•œâ‚ S } fun _ hs => hs\n\n"}
{"name":"ContinuousLinearMap.uniformAddGroup","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : AddCommGroup F\ninstâœÂ³ : Module ğ•œâ‚‚ F\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : UniformSpace F\ninstâœ : UniformAddGroup F\nâŠ¢ UniformAddGroup (ContinuousLinearMap Ïƒ E F)","decl":"instance uniformAddGroup [UniformSpace F] [UniformAddGroup F] : UniformAddGroup (E â†’SL[Ïƒ] F) :=\n  UniformConvergenceCLM.instUniformAddGroup Ïƒ F _\n\n"}
{"name":"ContinuousLinearMap.instContinuousEvalConst","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¹ : NormedField ğ•œâ‚\ninstâœâ¸ : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_4\nF : Type u_5\ninstâœâ· : AddCommGroup E\ninstâœâ¶ : Module ğ•œâ‚ E\ninstâœâµ : AddCommGroup F\ninstâœâ´ : Module ğ•œâ‚‚ F\ninstâœÂ³ : TopologicalSpace E\ninstâœÂ² : TopologicalSpace F\ninstâœÂ¹ : TopologicalAddGroup F\ninstâœ : ContinuousSMul ğ•œâ‚ E\nâŠ¢ ContinuousEvalConst (ContinuousLinearMap Ïƒ E F) E F","decl":"instance instContinuousEvalConst [TopologicalSpace F] [TopologicalAddGroup F]\n    [ContinuousSMul ğ•œâ‚ E] : ContinuousEvalConst (E â†’SL[Ïƒ] F) E F :=\n  UniformConvergenceCLM.continuousEvalConst Ïƒ F _ Bornology.isVonNBounded_covers\n\n"}
{"name":"ContinuousLinearMap.instT2Space","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœÂ¹â° : NormedField ğ•œâ‚\ninstâœâ¹ : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_4\nF : Type u_5\ninstâœâ¸ : AddCommGroup E\ninstâœâ· : Module ğ•œâ‚ E\ninstâœâ¶ : AddCommGroup F\ninstâœâµ : Module ğ•œâ‚‚ F\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : TopologicalSpace F\ninstâœÂ² : TopologicalAddGroup F\ninstâœÂ¹ : ContinuousSMul ğ•œâ‚ E\ninstâœ : T2Space F\nâŠ¢ T2Space (ContinuousLinearMap Ïƒ E F)","decl":"instance instT2Space [TopologicalSpace F] [TopologicalAddGroup F] [ContinuousSMul ğ•œâ‚ E]\n    [T2Space F] : T2Space (E â†’SL[Ïƒ] F) :=\n  UniformConvergenceCLM.t2Space Ïƒ F _ Bornology.isVonNBounded_covers\n\n"}
{"name":"ContinuousLinearMap.hasBasis_nhds_zero_of_basis","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : AddCommGroup F\ninstâœÂ³ : Module ğ•œâ‚‚ F\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalSpace F\ninstâœ : TopologicalAddGroup F\nÎ¹ : Type u_7\np : Î¹ â†’ Prop\nb : Î¹ â†’ Set F\nh : (nhds 0).HasBasis p b\nâŠ¢ (nhds 0).HasBasis (fun Si => And (Bornology.IsVonNBounded ğ•œâ‚ Si.1) (p Si.2)) fun Si => setOf fun f => âˆ€ (x : E), Membership.mem Si.1 x â†’ Membership.mem (b Si.2) (f x)","decl":"protected theorem hasBasis_nhds_zero_of_basis [TopologicalSpace F] [TopologicalAddGroup F]\n    {Î¹ : Type*} {p : Î¹ â†’ Prop} {b : Î¹ â†’ Set F} (h : (ğ“ 0 : Filter F).HasBasis p b) :\n    (ğ“ (0 : E â†’SL[Ïƒ] F)).HasBasis (fun Si : Set E Ã— Î¹ => IsVonNBounded ğ•œâ‚ Si.1 âˆ§ p Si.2)\n      fun Si => { f : E â†’SL[Ïƒ] F | âˆ€ x âˆˆ Si.1, f x âˆˆ b Si.2 } :=\n  UniformConvergenceCLM.hasBasis_nhds_zero_of_basis Ïƒ F { S | IsVonNBounded ğ•œâ‚ S }\n    âŸ¨âˆ…, isVonNBounded_empty ğ•œâ‚ EâŸ©\n    (directedOn_of_sup_mem fun _ _ => IsVonNBounded.union) h\n\n"}
{"name":"ContinuousLinearMap.hasBasis_nhds_zero","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : AddCommGroup F\ninstâœÂ³ : Module ğ•œâ‚‚ F\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalSpace F\ninstâœ : TopologicalAddGroup F\nâŠ¢ (nhds 0).HasBasis (fun SV => And (Bornology.IsVonNBounded ğ•œâ‚ SV.1) (Membership.mem (nhds 0) SV.2)) fun SV => setOf fun f => âˆ€ (x : E), Membership.mem SV.1 x â†’ Membership.mem SV.2 (f x)","decl":"protected theorem hasBasis_nhds_zero [TopologicalSpace F] [TopologicalAddGroup F] :\n    (ğ“ (0 : E â†’SL[Ïƒ] F)).HasBasis\n      (fun SV : Set E Ã— Set F => IsVonNBounded ğ•œâ‚ SV.1 âˆ§ SV.2 âˆˆ (ğ“ 0 : Filter F))\n      fun SV => { f : E â†’SL[Ïƒ] F | âˆ€ x âˆˆ SV.1, f x âˆˆ SV.2 } :=\n  ContinuousLinearMap.hasBasis_nhds_zero_of_basis (ğ“ 0).basis_sets\n\n"}
{"name":"ContinuousLinearMap.isUniformEmbedding_toUniformOnFun","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : AddCommGroup F\ninstâœÂ³ : Module ğ•œâ‚‚ F\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : UniformSpace F\ninstâœ : UniformAddGroup F\nâŠ¢ IsUniformEmbedding fun f => (UniformOnFun.ofFun (setOf fun s => Bornology.IsVonNBounded ğ•œâ‚ s)) â‡‘f","decl":"theorem isUniformEmbedding_toUniformOnFun [UniformSpace F] [UniformAddGroup F] :\n    IsUniformEmbedding\n      fun f : E â†’SL[Ïƒ] F â†¦ UniformOnFun.ofFun {s | Bornology.IsVonNBounded ğ•œâ‚ s} f :=\n  UniformConvergenceCLM.isUniformEmbedding_coeFn ..\n\n"}
{"name":"ContinuousLinearMap.uniformEmbedding_toUniformOnFun","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : AddCommGroup F\ninstâœÂ³ : Module ğ•œâ‚‚ F\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : UniformSpace F\ninstâœ : UniformAddGroup F\nâŠ¢ IsUniformEmbedding fun f => (UniformOnFun.ofFun (setOf fun s => Bornology.IsVonNBounded ğ•œâ‚ s)) â‡‘f","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_toUniformOnFun := isUniformEmbedding_toUniformOnFun\n\n"}
{"name":"ContinuousLinearMap.uniformContinuousConstSMul","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœÂ¹Â² : NormedField ğ•œâ‚\ninstâœÂ¹Â¹ : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_4\nF : Type u_5\ninstâœÂ¹â° : AddCommGroup E\ninstâœâ¹ : Module ğ•œâ‚ E\ninstâœâ¸ : AddCommGroup F\ninstâœâ· : Module ğ•œâ‚‚ F\ninstâœâ¶ : TopologicalSpace E\nM : Type u_7\ninstâœâµ : Monoid M\ninstâœâ´ : DistribMulAction M F\ninstâœÂ³ : SMulCommClass ğ•œâ‚‚ M F\ninstâœÂ² : UniformSpace F\ninstâœÂ¹ : UniformAddGroup F\ninstâœ : UniformContinuousConstSMul M F\nâŠ¢ UniformContinuousConstSMul M (ContinuousLinearMap Ïƒ E F)","decl":"instance uniformContinuousConstSMul\n    {M : Type*} [Monoid M] [DistribMulAction M F] [SMulCommClass ğ•œâ‚‚ M F]\n    [UniformSpace F] [UniformAddGroup F] [UniformContinuousConstSMul M F] :\n    UniformContinuousConstSMul M (E â†’SL[Ïƒ] F) :=\n  UniformConvergenceCLM.instUniformContinuousConstSMul Ïƒ F _ _\n\n"}
{"name":"ContinuousLinearMap.continuousConstSMul","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœÂ¹Â² : NormedField ğ•œâ‚\ninstâœÂ¹Â¹ : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_4\nF : Type u_5\ninstâœÂ¹â° : AddCommGroup E\ninstâœâ¹ : Module ğ•œâ‚ E\ninstâœâ¸ : AddCommGroup F\ninstâœâ· : Module ğ•œâ‚‚ F\ninstâœâ¶ : TopologicalSpace E\nM : Type u_7\ninstâœâµ : Monoid M\ninstâœâ´ : DistribMulAction M F\ninstâœÂ³ : SMulCommClass ğ•œâ‚‚ M F\ninstâœÂ² : TopologicalSpace F\ninstâœÂ¹ : TopologicalAddGroup F\ninstâœ : ContinuousConstSMul M F\nâŠ¢ ContinuousConstSMul M (ContinuousLinearMap Ïƒ E F)","decl":"instance continuousConstSMul {M : Type*} [Monoid M] [DistribMulAction M F] [SMulCommClass ğ•œâ‚‚ M F]\n    [TopologicalSpace F] [TopologicalAddGroup F] [ContinuousConstSMul M F] :\n    ContinuousConstSMul M (E â†’SL[Ïƒ] F) :=\n  UniformConvergenceCLM.instContinuousConstSMul Ïƒ F _ _\n\n"}
{"name":"ContinuousLinearMap.nhds_zero_eq_of_basis","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : AddCommGroup F\ninstâœÂ³ : Module ğ•œâ‚‚ F\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalSpace F\ninstâœ : TopologicalAddGroup F\nÎ¹ : Type u_7\np : Î¹ â†’ Prop\nb : Î¹ â†’ Set F\nh : (nhds 0).HasBasis p b\nâŠ¢ Eq (nhds 0) (iInf fun s => iInf fun x => iInf fun i => iInf fun x => Filter.principal (setOf fun f => Set.MapsTo (â‡‘f) s (b i)))","decl":"protected theorem nhds_zero_eq_of_basis [TopologicalSpace F] [TopologicalAddGroup F]\n    {Î¹ : Type*} {p : Î¹ â†’ Prop} {b : Î¹ â†’ Set F} (h : (ğ“ 0 : Filter F).HasBasis p b) :\n    ğ“ (0 : E â†’SL[Ïƒ] F) =\n      â¨… (s : Set E) (_ : IsVonNBounded ğ•œâ‚ s) (i : Î¹) (_ : p i),\n        ğ“Ÿ {f : E â†’SL[Ïƒ] F | MapsTo f s (b i)} :=\n  UniformConvergenceCLM.nhds_zero_eq_of_basis _ _ _ h\n\n"}
{"name":"ContinuousLinearMap.nhds_zero_eq","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : AddCommGroup F\ninstâœÂ³ : Module ğ•œâ‚‚ F\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalSpace F\ninstâœ : TopologicalAddGroup F\nâŠ¢ Eq (nhds 0) (iInf fun s => iInf fun x => iInf fun U => iInf fun x => Filter.principal (setOf fun f => Set.MapsTo (â‡‘f) s U))","decl":"protected theorem nhds_zero_eq [TopologicalSpace F] [TopologicalAddGroup F] :\n    ğ“ (0 : E â†’SL[Ïƒ] F) =\n      â¨… (s : Set E) (_ : IsVonNBounded ğ•œâ‚ s) (U : Set F) (_ : U âˆˆ ğ“ 0),\n        ğ“Ÿ {f : E â†’SL[Ïƒ] F | MapsTo f s U} :=\n  UniformConvergenceCLM.nhds_zero_eq ..\n\n"}
{"name":"ContinuousLinearMap.eventually_nhds_zero_mapsTo","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NormedField ğ•œâ‚\ninstâœâ· : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œâ‚ E\ninstâœâ´ : AddCommGroup F\ninstâœÂ³ : Module ğ•œâ‚‚ F\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalSpace F\ninstâœ : TopologicalAddGroup F\ns : Set E\nhs : Bornology.IsVonNBounded ğ•œâ‚ s\nU : Set F\nhu : Membership.mem (nhds 0) U\nâŠ¢ Filter.Eventually (fun f => Set.MapsTo (â‡‘f) s U) (nhds 0)","decl":"/-- If `s` is a von Neumann bounded set and `U` is a neighbourhood of zero,\nthen sufficiently small continuous linear maps map `s` to `U`. -/\ntheorem eventually_nhds_zero_mapsTo [TopologicalSpace F] [TopologicalAddGroup F]\n    {s : Set E} (hs : IsVonNBounded ğ•œâ‚ s) {U : Set F} (hu : U âˆˆ ğ“ 0) :\n    âˆ€á¶  f : E â†’SL[Ïƒ] F in ğ“ 0, MapsTo f s U :=\n  UniformConvergenceCLM.eventually_nhds_zero_mapsTo _ hs hu\n\n"}
{"name":"ContinuousLinearMap.isVonNBounded_image2_apply","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœÂ¹Â² : NormedField ğ•œâ‚\ninstâœÂ¹Â¹ : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_4\nF : Type u_5\ninstâœÂ¹â° : AddCommGroup E\ninstâœâ¹ : Module ğ•œâ‚ E\ninstâœâ¸ : AddCommGroup F\ninstâœâ· : Module ğ•œâ‚‚ F\ninstâœâ¶ : TopologicalSpace E\nR : Type u_7\ninstâœâµ : SeminormedRing R\ninstâœâ´ : TopologicalSpace F\ninstâœÂ³ : TopologicalAddGroup F\ninstâœÂ² : Module R F\ninstâœÂ¹ : ContinuousConstSMul R F\ninstâœ : SMulCommClass ğ•œâ‚‚ R F\nS : Set (ContinuousLinearMap Ïƒ E F)\nhS : Bornology.IsVonNBounded R S\ns : Set E\nhs : Bornology.IsVonNBounded ğ•œâ‚ s\nâŠ¢ Bornology.IsVonNBounded R (Set.image2 (fun f x => f x) S s)","decl":"/-- If `S` is a von Neumann bounded set of continuous linear maps `f : E â†’SL[Ïƒ] F`\nand `s` is a von Neumann bounded set in the domain,\nthen the set `{f x | (f âˆˆ S) (x âˆˆ s)}` is von Neumann bounded.\n\nSee also `isVonNBounded_iff` for an `Iff` version with stronger typeclass assumptions. -/\ntheorem isVonNBounded_image2_apply {R : Type*} [SeminormedRing R]\n    [TopologicalSpace F] [TopologicalAddGroup F]\n    [Module R F] [ContinuousConstSMul R F] [SMulCommClass ğ•œâ‚‚ R F]\n    {S : Set (E â†’SL[Ïƒ] F)} (hS : IsVonNBounded R S) {s : Set E} (hs : IsVonNBounded ğ•œâ‚ s) :\n    IsVonNBounded R (Set.image2 (fun f x â†¦ f x) S s) :=\n  UniformConvergenceCLM.isVonNBounded_image2_apply hS hs\n\n"}
{"name":"ContinuousLinearMap.isVonNBounded_iff","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœÂ¹Â² : NormedField ğ•œâ‚\ninstâœÂ¹Â¹ : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_4\nF : Type u_5\ninstâœÂ¹â° : AddCommGroup E\ninstâœâ¹ : Module ğ•œâ‚ E\ninstâœâ¸ : AddCommGroup F\ninstâœâ· : Module ğ•œâ‚‚ F\ninstâœâ¶ : TopologicalSpace E\nR : Type u_7\ninstâœâµ : NormedDivisionRing R\ninstâœâ´ : TopologicalSpace F\ninstâœÂ³ : TopologicalAddGroup F\ninstâœÂ² : Module R F\ninstâœÂ¹ : ContinuousConstSMul R F\ninstâœ : SMulCommClass ğ•œâ‚‚ R F\nS : Set (ContinuousLinearMap Ïƒ E F)\nâŠ¢ Iff (Bornology.IsVonNBounded R S) (âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œâ‚ s â†’ Bornology.IsVonNBounded R (Set.image2 (fun f x => f x) S s))","decl":"/-- A set `S` of continuous linear maps is von Neumann bounded\niff for any von Neumann bounded set `s`,\nthe set `{f x | (f âˆˆ S) (x âˆˆ s)}` is von Neumann bounded.\n\nFor the forward implication with weaker typeclass assumptions, see `isVonNBounded_image2_apply`. -/\ntheorem isVonNBounded_iff {R : Type*} [NormedDivisionRing R]\n    [TopologicalSpace F] [TopologicalAddGroup F]\n    [Module R F] [ContinuousConstSMul R F] [SMulCommClass ğ•œâ‚‚ R F]\n    {S : Set (E â†’SL[Ïƒ] F)} :\n    IsVonNBounded R S â†”\n      âˆ€ s, IsVonNBounded ğ•œâ‚ s â†’ IsVonNBounded R (Set.image2 (fun f x â†¦ f x) S s) :=\n  UniformConvergenceCLM.isVonNBounded_iff\n\n"}
{"name":"ContinuousLinearMap.completeSpace","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœÂ¹Â¹ : NormedField ğ•œâ‚\ninstâœÂ¹â° : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_4\nF : Type u_5\ninstâœâ¹ : AddCommGroup E\ninstâœâ¸ : Module ğ•œâ‚ E\ninstâœâ· : AddCommGroup F\ninstâœâ¶ : Module ğ•œâ‚‚ F\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : UniformSpace F\ninstâœÂ³ : UniformAddGroup F\ninstâœÂ² : ContinuousSMul ğ•œâ‚‚ F\ninstâœÂ¹ : CompleteSpace F\ninstâœ : ContinuousSMul ğ•œâ‚ E\nh : Topology.RestrictGenTopology (setOf fun s => Bornology.IsVonNBounded ğ•œâ‚ s)\nâŠ¢ CompleteSpace (ContinuousLinearMap Ïƒ E F)","decl":"theorem completeSpace [UniformSpace F] [UniformAddGroup F] [ContinuousSMul ğ•œâ‚‚ F] [CompleteSpace F]\n    [ContinuousSMul ğ•œâ‚ E] (h : RestrictGenTopology {s : Set E | IsVonNBounded ğ•œâ‚ s}) :\n    CompleteSpace (E â†’SL[Ïƒ] F) :=\n  UniformConvergenceCLM.completeSpace _ _ h isVonNBounded_covers\n\n"}
{"name":"ContinuousLinearMap.instCompleteSpace","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœÂ¹Â³ : NormedField ğ•œâ‚\ninstâœÂ¹Â² : NormedField ğ•œâ‚‚\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nE : Type u_4\nF : Type u_5\ninstâœÂ¹Â¹ : AddCommGroup E\ninstâœÂ¹â° : Module ğ•œâ‚ E\ninstâœâ¹ : AddCommGroup F\ninstâœâ¸ : Module ğ•œâ‚‚ F\ninstâœâ· : TopologicalSpace E\ninstâœâ¶ : TopologicalAddGroup E\ninstâœâµ : ContinuousSMul ğ•œâ‚ E\ninstâœâ´ : SequentialSpace E\ninstâœÂ³ : UniformSpace F\ninstâœÂ² : UniformAddGroup F\ninstâœÂ¹ : ContinuousSMul ğ•œâ‚‚ F\ninstâœ : CompleteSpace F\nâŠ¢ CompleteSpace (ContinuousLinearMap Ïƒ E F)","decl":"instance instCompleteSpace [TopologicalAddGroup E] [ContinuousSMul ğ•œâ‚ E] [SequentialSpace E]\n    [UniformSpace F] [UniformAddGroup F] [ContinuousSMul ğ•œâ‚‚ F] [CompleteSpace F] :\n    CompleteSpace (E â†’SL[Ïƒ] F) :=\n  completeSpace <| .of_seq fun _ _ h â†¦ (h.isVonNBounded_range ğ•œâ‚).insert _\n\n"}
{"name":"ContinuousLinearMap.precomp_apply","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\ninstâœÂ¹â¶ : NormedField ğ•œâ‚\ninstâœÂ¹âµ : NormedField ğ•œâ‚‚\ninstâœÂ¹â´ : NormedField ğ•œâ‚ƒ\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nÏ„ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏ : RingHom ğ•œâ‚ ğ•œâ‚ƒ\ninstâœÂ¹Â³ : RingHomCompTriple Ïƒ Ï„ Ï\nE : Type u_4\nF : Type u_5\nG : Type u_6\ninstâœÂ¹Â² : AddCommGroup E\ninstâœÂ¹Â¹ : Module ğ•œâ‚ E\ninstâœÂ¹â° : AddCommGroup F\ninstâœâ¹ : Module ğ•œâ‚‚ F\ninstâœâ¸ : AddCommGroup G\ninstâœâ· : Module ğ•œâ‚ƒ G\ninstâœâ¶ : TopologicalSpace E\ninstâœâµ : TopologicalSpace F\ninstâœâ´ : TopologicalSpace G\ninstâœÂ³ : TopologicalAddGroup G\ninstâœÂ² : ContinuousConstSMul ğ•œâ‚ƒ G\ninstâœÂ¹ : RingHomSurjective Ïƒ\ninstâœ : RingHomIsometric Ïƒ\nL : ContinuousLinearMap Ïƒ E F\nf : ContinuousLinearMap Ï„ F G\nâŠ¢ Eq ((ContinuousLinearMap.precomp G L) f) (f.comp L)","decl":"/-- Pre-composition by a *fixed* continuous linear map as a continuous linear map.\nNote that in non-normed space it is not always true that composition is continuous\nin both variables, so we have to fix one of them. -/\n@[simps]\ndef precomp [TopologicalAddGroup G] [ContinuousConstSMul ğ•œâ‚ƒ G] [RingHomSurjective Ïƒ]\n    [RingHomIsometric Ïƒ] (L : E â†’SL[Ïƒ] F) : (F â†’SL[Ï„] G) â†’L[ğ•œâ‚ƒ] E â†’SL[Ï] G where\n  toFun f := f.comp L\n  map_add' f g := add_comp f g L\n  map_smul' a f := smul_comp a f L\n  cont := by\n    letI : UniformSpace G := TopologicalAddGroup.toUniformSpace G\n    haveI : UniformAddGroup G := comm_topologicalAddGroup_is_uniform\n    rw [(UniformConvergenceCLM.isEmbedding_coeFn _ _ _).continuous_iff]\n    -- Porting note: without this, the following doesn't work\n    change Continuous ((fun f â†¦ UniformOnFun.ofFun _ (f âˆ˜ L)) âˆ˜ DFunLike.coe)\n    exact (UniformOnFun.precomp_uniformContinuous fun S hS => hS.image L).continuous.comp\n        (UniformConvergenceCLM.isEmbedding_coeFn _ _ _).continuous\n\n"}
{"name":"ContinuousLinearMap.postcomp_apply","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\ninstâœÂ¹â¶ : NormedField ğ•œâ‚\ninstâœÂ¹âµ : NormedField ğ•œâ‚‚\ninstâœÂ¹â´ : NormedField ğ•œâ‚ƒ\nÏƒ : RingHom ğ•œâ‚ ğ•œâ‚‚\nÏ„ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏ : RingHom ğ•œâ‚ ğ•œâ‚ƒ\ninstâœÂ¹Â³ : RingHomCompTriple Ïƒ Ï„ Ï\nE : Type u_4\nF : Type u_5\nG : Type u_6\ninstâœÂ¹Â² : AddCommGroup E\ninstâœÂ¹Â¹ : Module ğ•œâ‚ E\ninstâœÂ¹â° : AddCommGroup F\ninstâœâ¹ : Module ğ•œâ‚‚ F\ninstâœâ¸ : AddCommGroup G\ninstâœâ· : Module ğ•œâ‚ƒ G\ninstâœâ¶ : TopologicalSpace E\ninstâœâµ : TopologicalSpace F\ninstâœâ´ : TopologicalSpace G\ninstâœÂ³ : TopologicalAddGroup F\ninstâœÂ² : TopologicalAddGroup G\ninstâœÂ¹ : ContinuousConstSMul ğ•œâ‚ƒ G\ninstâœ : ContinuousConstSMul ğ•œâ‚‚ F\nL : ContinuousLinearMap Ï„ F G\nf : ContinuousLinearMap Ïƒ E F\nâŠ¢ Eq ((ContinuousLinearMap.postcomp E L) f) (L.comp f)","decl":"/-- Post-composition by a *fixed* continuous linear map as a continuous linear map.\nNote that in non-normed space it is not always true that composition is continuous\nin both variables, so we have to fix one of them. -/\n@[simps]\ndef postcomp [TopologicalAddGroup F] [TopologicalAddGroup G] [ContinuousConstSMul ğ•œâ‚ƒ G]\n    [ContinuousConstSMul ğ•œâ‚‚ F] (L : F â†’SL[Ï„] G) : (E â†’SL[Ïƒ] F) â†’SL[Ï„] E â†’SL[Ï] G where\n  toFun f := L.comp f\n  map_add' := comp_add L\n  map_smul' := comp_smulâ‚›â‚— L\n  cont := by\n    letI : UniformSpace G := TopologicalAddGroup.toUniformSpace G\n    haveI : UniformAddGroup G := comm_topologicalAddGroup_is_uniform\n    letI : UniformSpace F := TopologicalAddGroup.toUniformSpace F\n    haveI : UniformAddGroup F := comm_topologicalAddGroup_is_uniform\n    rw [(UniformConvergenceCLM.isEmbedding_coeFn _ _ _).continuous_iff]\n    exact\n      (UniformOnFun.postcomp_uniformContinuous L.uniformContinuous).continuous.comp\n        (UniformConvergenceCLM.isEmbedding_coeFn _ _ _).continuous\n\n"}
{"name":"ContinuousLinearMap.toLinearMapâ‚‚_apply","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹Â¹ : NormedField ğ•œ\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœÂ¹â° : AddCommGroup E\ninstâœâ¹ : Module ğ•œ E\ninstâœâ¸ : TopologicalSpace E\ninstâœâ· : AddCommGroup F\ninstâœâ¶ : Module ğ•œ F\ninstâœâµ : TopologicalSpace F\ninstâœâ´ : AddCommGroup G\ninstâœÂ³ : Module ğ•œ G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : ContinuousConstSMul ğ•œ G\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) F G)\nv : E\nw : F\nâŠ¢ Eq ((L.toLinearMapâ‚‚ v) w) ((L v) w)","decl":"@[simp] lemma toLinearMapâ‚‚_apply (L : E â†’L[ğ•œ] F â†’L[ğ•œ] G) (v : E) (w : F) :\n    L.toLinearMapâ‚‚ v w = L v w := rfl\n\n"}
{"name":"ContinuousLinearMap.isUniformEmbedding_restrictScalars","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹Â³ : AddCommGroup E\ninstâœÂ¹Â² : TopologicalSpace E\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : ContinuousSMul ğ•œ E\nF : Type u_3\ninstâœâ¹ : AddCommGroup F\ninstâœâ¸ : UniformSpace F\ninstâœâ· : UniformAddGroup F\ninstâœâ¶ : Module ğ•œ F\nğ•œ' : Type u_4\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ' ğ•œ\ninstâœÂ³ : Module ğ•œ' E\ninstâœÂ² : IsScalarTower ğ•œ' ğ•œ E\ninstâœÂ¹ : Module ğ•œ' F\ninstâœ : IsScalarTower ğ•œ' ğ•œ F\nâŠ¢ IsUniformEmbedding (ContinuousLinearMap.restrictScalars ğ•œ')","decl":"theorem isUniformEmbedding_restrictScalars :\n    IsUniformEmbedding (restrictScalars ğ•œ' : (E â†’L[ğ•œ] F) â†’ (E â†’L[ğ•œ'] F)) := by\n  rw [â† isUniformEmbedding_toUniformOnFun.of_comp_iff]\n  convert isUniformEmbedding_toUniformOnFun using 4 with s\n  exact âŸ¨fun h â†¦ h.extend_scalars _, fun h â†¦ h.restrict_scalars _âŸ©\n\n"}
{"name":"ContinuousLinearMap.uniformEmbedding_restrictScalars","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹Â³ : AddCommGroup E\ninstâœÂ¹Â² : TopologicalSpace E\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : ContinuousSMul ğ•œ E\nF : Type u_3\ninstâœâ¹ : AddCommGroup F\ninstâœâ¸ : UniformSpace F\ninstâœâ· : UniformAddGroup F\ninstâœâ¶ : Module ğ•œ F\nğ•œ' : Type u_4\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ' ğ•œ\ninstâœÂ³ : Module ğ•œ' E\ninstâœÂ² : IsScalarTower ğ•œ' ğ•œ E\ninstâœÂ¹ : Module ğ•œ' F\ninstâœ : IsScalarTower ğ•œ' ğ•œ F\nâŠ¢ IsUniformEmbedding (ContinuousLinearMap.restrictScalars ğ•œ')","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_restrictScalars := isUniformEmbedding_restrictScalars\n\n"}
{"name":"ContinuousLinearMap.uniformContinuous_restrictScalars","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹Â³ : AddCommGroup E\ninstâœÂ¹Â² : TopologicalSpace E\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : ContinuousSMul ğ•œ E\nF : Type u_3\ninstâœâ¹ : AddCommGroup F\ninstâœâ¸ : UniformSpace F\ninstâœâ· : UniformAddGroup F\ninstâœâ¶ : Module ğ•œ F\nğ•œ' : Type u_4\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ' ğ•œ\ninstâœÂ³ : Module ğ•œ' E\ninstâœÂ² : IsScalarTower ğ•œ' ğ•œ E\ninstâœÂ¹ : Module ğ•œ' F\ninstâœ : IsScalarTower ğ•œ' ğ•œ F\nâŠ¢ UniformContinuous (ContinuousLinearMap.restrictScalars ğ•œ')","decl":"theorem uniformContinuous_restrictScalars :\n    UniformContinuous (restrictScalars ğ•œ' : (E â†’L[ğ•œ] F) â†’ (E â†’L[ğ•œ'] F)) :=\n  (isUniformEmbedding_restrictScalars ğ•œ').uniformContinuous\n\n"}
{"name":"ContinuousLinearMap.isEmbedding_restrictScalars","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹Â³ : AddCommGroup E\ninstâœÂ¹Â² : TopologicalSpace E\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : ContinuousSMul ğ•œ E\nF : Type u_3\ninstâœâ¹ : AddCommGroup F\ninstâœâ¸ : TopologicalSpace F\ninstâœâ· : TopologicalAddGroup F\ninstâœâ¶ : Module ğ•œ F\nğ•œ' : Type u_4\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ' ğ•œ\ninstâœÂ³ : Module ğ•œ' E\ninstâœÂ² : IsScalarTower ğ•œ' ğ•œ E\ninstâœÂ¹ : Module ğ•œ' F\ninstâœ : IsScalarTower ğ•œ' ğ•œ F\nâŠ¢ Topology.IsEmbedding (ContinuousLinearMap.restrictScalars ğ•œ')","decl":"theorem isEmbedding_restrictScalars :\n    IsEmbedding (restrictScalars ğ•œ' : (E â†’L[ğ•œ] F) â†’ (E â†’L[ğ•œ'] F)) :=\n  letI : UniformSpace F := TopologicalAddGroup.toUniformSpace F\n  haveI : UniformAddGroup F := comm_topologicalAddGroup_is_uniform\n  (isUniformEmbedding_restrictScalars _).isEmbedding\n\n"}
{"name":"ContinuousLinearMap.embedding_restrictScalars","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹Â³ : AddCommGroup E\ninstâœÂ¹Â² : TopologicalSpace E\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : ContinuousSMul ğ•œ E\nF : Type u_3\ninstâœâ¹ : AddCommGroup F\ninstâœâ¸ : TopologicalSpace F\ninstâœâ· : TopologicalAddGroup F\ninstâœâ¶ : Module ğ•œ F\nğ•œ' : Type u_4\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ' ğ•œ\ninstâœÂ³ : Module ğ•œ' E\ninstâœÂ² : IsScalarTower ğ•œ' ğ•œ E\ninstâœÂ¹ : Module ğ•œ' F\ninstâœ : IsScalarTower ğ•œ' ğ•œ F\nâŠ¢ Topology.IsEmbedding (ContinuousLinearMap.restrictScalars ğ•œ')","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_restrictScalars := isEmbedding_restrictScalars\n\n"}
{"name":"ContinuousLinearMap.continuous_restrictScalars","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹Â³ : AddCommGroup E\ninstâœÂ¹Â² : TopologicalSpace E\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : ContinuousSMul ğ•œ E\nF : Type u_3\ninstâœâ¹ : AddCommGroup F\ninstâœâ¸ : TopologicalSpace F\ninstâœâ· : TopologicalAddGroup F\ninstâœâ¶ : Module ğ•œ F\nğ•œ' : Type u_4\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ' ğ•œ\ninstâœÂ³ : Module ğ•œ' E\ninstâœÂ² : IsScalarTower ğ•œ' ğ•œ E\ninstâœÂ¹ : Module ğ•œ' F\ninstâœ : IsScalarTower ğ•œ' ğ•œ F\nâŠ¢ Continuous (ContinuousLinearMap.restrictScalars ğ•œ')","decl":"@[continuity, fun_prop]\ntheorem continuous_restrictScalars :\n    Continuous (restrictScalars ğ•œ' : (E â†’L[ğ•œ] F) â†’ (E â†’L[ğ•œ'] F)) :=\n   (isEmbedding_restrictScalars _).continuous\n\n"}
{"name":"ContinuousLinearMap.coe_restrictScalarsL","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹â¸ : AddCommGroup E\ninstâœÂ¹â· : TopologicalSpace E\ninstâœÂ¹â¶ : Module ğ•œ E\ninstâœÂ¹âµ : ContinuousSMul ğ•œ E\nF : Type u_3\ninstâœÂ¹â´ : AddCommGroup F\ninstâœÂ¹Â³ : TopologicalSpace F\ninstâœÂ¹Â² : TopologicalAddGroup F\ninstâœÂ¹Â¹ : Module ğ•œ F\nğ•œ' : Type u_4\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ'\ninstâœâ¹ : NormedAlgebra ğ•œ' ğ•œ\ninstâœâ¸ : Module ğ•œ' E\ninstâœâ· : IsScalarTower ğ•œ' ğ•œ E\ninstâœâ¶ : Module ğ•œ' F\ninstâœâµ : IsScalarTower ğ•œ' ğ•œ F\nğ•œ'' : Type u_5\ninstâœâ´ : Ring ğ•œ''\ninstâœÂ³ : Module ğ•œ'' F\ninstâœÂ² : ContinuousConstSMul ğ•œ'' F\ninstâœÂ¹ : SMulCommClass ğ•œ ğ•œ'' F\ninstâœ : SMulCommClass ğ•œ' ğ•œ'' F\nâŠ¢ Eq (â†‘(ContinuousLinearMap.restrictScalarsL ğ•œ E F ğ•œ' ğ•œ'')) (ContinuousLinearMap.restrictScalarsâ‚— ğ•œ E F ğ•œ' ğ•œ'')","decl":"@[simp]\ntheorem coe_restrictScalarsL : (restrictScalarsL ğ•œ E F ğ•œ' ğ•œ'' : (E â†’L[ğ•œ] F) â†’â‚—[ğ•œ''] E â†’L[ğ•œ'] F) =\n    restrictScalarsâ‚— ğ•œ E F ğ•œ' ğ•œ'' :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_restrict_scalarsL'","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹â¸ : AddCommGroup E\ninstâœÂ¹â· : TopologicalSpace E\ninstâœÂ¹â¶ : Module ğ•œ E\ninstâœÂ¹âµ : ContinuousSMul ğ•œ E\nF : Type u_3\ninstâœÂ¹â´ : AddCommGroup F\ninstâœÂ¹Â³ : TopologicalSpace F\ninstâœÂ¹Â² : TopologicalAddGroup F\ninstâœÂ¹Â¹ : Module ğ•œ F\nğ•œ' : Type u_4\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ'\ninstâœâ¹ : NormedAlgebra ğ•œ' ğ•œ\ninstâœâ¸ : Module ğ•œ' E\ninstâœâ· : IsScalarTower ğ•œ' ğ•œ E\ninstâœâ¶ : Module ğ•œ' F\ninstâœâµ : IsScalarTower ğ•œ' ğ•œ F\nğ•œ'' : Type u_5\ninstâœâ´ : Ring ğ•œ''\ninstâœÂ³ : Module ğ•œ'' F\ninstâœÂ² : ContinuousConstSMul ğ•œ'' F\ninstâœÂ¹ : SMulCommClass ğ•œ ğ•œ'' F\ninstâœ : SMulCommClass ğ•œ' ğ•œ'' F\nâŠ¢ Eq (â‡‘(ContinuousLinearMap.restrictScalarsL ğ•œ E F ğ•œ' ğ•œ'')) (ContinuousLinearMap.restrictScalars ğ•œ')","decl":"@[simp]\ntheorem coe_restrict_scalarsL' : â‡‘(restrictScalarsL ğ•œ E F ğ•œ' ğ•œ'') = restrictScalars ğ•œ' :=\n  rfl\n\n"}
{"name":"ContinuousLinearEquiv.arrowCongrSL_symm_apply","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nğ•œâ‚„ : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\nH : Type u_8\ninstâœÂ³Â¹ : AddCommGroup E\ninstâœÂ³â° : AddCommGroup F\ninstâœÂ²â¹ : AddCommGroup G\ninstâœÂ²â¸ : AddCommGroup H\ninstâœÂ²â· : NormedField ğ•œ\ninstâœÂ²â¶ : NormedField ğ•œâ‚‚\ninstâœÂ²âµ : NormedField ğ•œâ‚ƒ\ninstâœÂ²â´ : NormedField ğ•œâ‚„\ninstâœÂ²Â³ : Module ğ•œ E\ninstâœÂ²Â² : Module ğ•œâ‚‚ F\ninstâœÂ²Â¹ : Module ğ•œâ‚ƒ G\ninstâœÂ²â° : Module ğ•œâ‚„ H\ninstâœÂ¹â¹ : TopologicalSpace E\ninstâœÂ¹â¸ : TopologicalSpace F\ninstâœÂ¹â· : TopologicalSpace G\ninstâœÂ¹â¶ : TopologicalSpace H\ninstâœÂ¹âµ : TopologicalAddGroup G\ninstâœÂ¹â´ : TopologicalAddGroup H\ninstâœÂ¹Â³ : ContinuousConstSMul ğ•œâ‚ƒ G\ninstâœÂ¹Â² : ContinuousConstSMul ğ•œâ‚„ H\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚‚â‚ : RingHom ğ•œâ‚‚ ğ•œ\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\nÏƒâ‚ƒâ‚„ : RingHom ğ•œâ‚ƒ ğ•œâ‚„\nÏƒâ‚„â‚ƒ : RingHom ğ•œâ‚„ ğ•œâ‚ƒ\nÏƒâ‚‚â‚„ : RingHom ğ•œâ‚‚ ğ•œâ‚„\nÏƒâ‚â‚„ : RingHom ğ•œ ğ•œâ‚„\ninstâœÂ¹Â¹ : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚\ninstâœÂ¹â° : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚\ninstâœâ¹ : RingHomInvPair Ïƒâ‚ƒâ‚„ Ïƒâ‚„â‚ƒ\ninstâœâ¸ : RingHomInvPair Ïƒâ‚„â‚ƒ Ïƒâ‚ƒâ‚„\ninstâœâ· : RingHomCompTriple Ïƒâ‚‚â‚ Ïƒâ‚â‚„ Ïƒâ‚‚â‚„\ninstâœâ¶ : RingHomCompTriple Ïƒâ‚‚â‚„ Ïƒâ‚„â‚ƒ Ïƒâ‚‚â‚ƒ\ninstâœâµ : RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ\ninstâœâ´ : RingHomCompTriple Ïƒâ‚â‚ƒ Ïƒâ‚ƒâ‚„ Ïƒâ‚â‚„\ninstâœÂ³ : RingHomCompTriple Ïƒâ‚‚â‚ƒ Ïƒâ‚ƒâ‚„ Ïƒâ‚‚â‚„\ninstâœÂ² : RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚„ Ïƒâ‚â‚„\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœ : RingHomIsometric Ïƒâ‚‚â‚\neâ‚â‚‚ : ContinuousLinearEquiv Ïƒâ‚â‚‚ E F\neâ‚„â‚ƒ : ContinuousLinearEquiv Ïƒâ‚„â‚ƒ H G\nL : ContinuousLinearMap Ïƒâ‚‚â‚ƒ F G\nâŠ¢ Eq ((eâ‚â‚‚.arrowCongrSL eâ‚„â‚ƒ).symm L) ((â†‘eâ‚„â‚ƒ.symm).comp (L.comp â†‘eâ‚â‚‚))","decl":"/-- A pair of continuous (semi)linear equivalences generates a (semi)linear equivalence between the\nspaces of continuous (semi)linear maps. -/\n@[simps apply symm_apply toLinearEquiv_apply toLinearEquiv_symm_apply]\ndef arrowCongrSL (eâ‚â‚‚ : E â‰ƒSL[Ïƒâ‚â‚‚] F) (eâ‚„â‚ƒ : H â‰ƒSL[Ïƒâ‚„â‚ƒ] G) :\n    (E â†’SL[Ïƒâ‚â‚„] H) â‰ƒSL[Ïƒâ‚„â‚ƒ] F â†’SL[Ïƒâ‚‚â‚ƒ] G :=\n{ eâ‚â‚‚.arrowCongrEquiv eâ‚„â‚ƒ with\n    -- given explicitly to help `simps`\n    toFun := fun L => (eâ‚„â‚ƒ : H â†’SL[Ïƒâ‚„â‚ƒ] G).comp (L.comp (eâ‚â‚‚.symm : F â†’SL[Ïƒâ‚‚â‚] E))\n    -- given explicitly to help `simps`\n    invFun := fun L => (eâ‚„â‚ƒ.symm : G â†’SL[Ïƒâ‚ƒâ‚„] H).comp (L.comp (eâ‚â‚‚ : E â†’SL[Ïƒâ‚â‚‚] F))\n    map_add' := fun f g => by simp only [add_comp, comp_add]\n    map_smul' := fun t f => by simp only [smul_comp, comp_smulâ‚›â‚—]\n    continuous_toFun := ((postcomp F eâ‚„â‚ƒ.toContinuousLinearMap).comp\n      (precomp H eâ‚â‚‚.symm.toContinuousLinearMap)).continuous\n    continuous_invFun := ((precomp H eâ‚â‚‚.toContinuousLinearMap).comp\n      (postcomp F eâ‚„â‚ƒ.symm.toContinuousLinearMap)).continuous }\n\n"}
{"name":"ContinuousLinearEquiv.arrowCongrSL_toLinearEquiv_apply","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nğ•œâ‚„ : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\nH : Type u_8\ninstâœÂ³Â¹ : AddCommGroup E\ninstâœÂ³â° : AddCommGroup F\ninstâœÂ²â¹ : AddCommGroup G\ninstâœÂ²â¸ : AddCommGroup H\ninstâœÂ²â· : NormedField ğ•œ\ninstâœÂ²â¶ : NormedField ğ•œâ‚‚\ninstâœÂ²âµ : NormedField ğ•œâ‚ƒ\ninstâœÂ²â´ : NormedField ğ•œâ‚„\ninstâœÂ²Â³ : Module ğ•œ E\ninstâœÂ²Â² : Module ğ•œâ‚‚ F\ninstâœÂ²Â¹ : Module ğ•œâ‚ƒ G\ninstâœÂ²â° : Module ğ•œâ‚„ H\ninstâœÂ¹â¹ : TopologicalSpace E\ninstâœÂ¹â¸ : TopologicalSpace F\ninstâœÂ¹â· : TopologicalSpace G\ninstâœÂ¹â¶ : TopologicalSpace H\ninstâœÂ¹âµ : TopologicalAddGroup G\ninstâœÂ¹â´ : TopologicalAddGroup H\ninstâœÂ¹Â³ : ContinuousConstSMul ğ•œâ‚ƒ G\ninstâœÂ¹Â² : ContinuousConstSMul ğ•œâ‚„ H\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚‚â‚ : RingHom ğ•œâ‚‚ ğ•œ\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\nÏƒâ‚ƒâ‚„ : RingHom ğ•œâ‚ƒ ğ•œâ‚„\nÏƒâ‚„â‚ƒ : RingHom ğ•œâ‚„ ğ•œâ‚ƒ\nÏƒâ‚‚â‚„ : RingHom ğ•œâ‚‚ ğ•œâ‚„\nÏƒâ‚â‚„ : RingHom ğ•œ ğ•œâ‚„\ninstâœÂ¹Â¹ : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚\ninstâœÂ¹â° : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚\ninstâœâ¹ : RingHomInvPair Ïƒâ‚ƒâ‚„ Ïƒâ‚„â‚ƒ\ninstâœâ¸ : RingHomInvPair Ïƒâ‚„â‚ƒ Ïƒâ‚ƒâ‚„\ninstâœâ· : RingHomCompTriple Ïƒâ‚‚â‚ Ïƒâ‚â‚„ Ïƒâ‚‚â‚„\ninstâœâ¶ : RingHomCompTriple Ïƒâ‚‚â‚„ Ïƒâ‚„â‚ƒ Ïƒâ‚‚â‚ƒ\ninstâœâµ : RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ\ninstâœâ´ : RingHomCompTriple Ïƒâ‚â‚ƒ Ïƒâ‚ƒâ‚„ Ïƒâ‚â‚„\ninstâœÂ³ : RingHomCompTriple Ïƒâ‚‚â‚ƒ Ïƒâ‚ƒâ‚„ Ïƒâ‚‚â‚„\ninstâœÂ² : RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚„ Ïƒâ‚â‚„\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœ : RingHomIsometric Ïƒâ‚‚â‚\neâ‚â‚‚ : ContinuousLinearEquiv Ïƒâ‚â‚‚ E F\neâ‚„â‚ƒ : ContinuousLinearEquiv Ïƒâ‚„â‚ƒ H G\nL : ContinuousLinearMap Ïƒâ‚â‚„ E H\nâŠ¢ Eq ((eâ‚â‚‚.arrowCongrSL eâ‚„â‚ƒ).toLinearEquiv L) ((â†‘eâ‚„â‚ƒ).comp (L.comp â†‘eâ‚â‚‚.symm))","decl":"/-- A pair of continuous (semi)linear equivalences generates a (semi)linear equivalence between the\nspaces of continuous (semi)linear maps. -/\n@[simps apply symm_apply toLinearEquiv_apply toLinearEquiv_symm_apply]\ndef arrowCongrSL (eâ‚â‚‚ : E â‰ƒSL[Ïƒâ‚â‚‚] F) (eâ‚„â‚ƒ : H â‰ƒSL[Ïƒâ‚„â‚ƒ] G) :\n    (E â†’SL[Ïƒâ‚â‚„] H) â‰ƒSL[Ïƒâ‚„â‚ƒ] F â†’SL[Ïƒâ‚‚â‚ƒ] G :=\n{ eâ‚â‚‚.arrowCongrEquiv eâ‚„â‚ƒ with\n    -- given explicitly to help `simps`\n    toFun := fun L => (eâ‚„â‚ƒ : H â†’SL[Ïƒâ‚„â‚ƒ] G).comp (L.comp (eâ‚â‚‚.symm : F â†’SL[Ïƒâ‚‚â‚] E))\n    -- given explicitly to help `simps`\n    invFun := fun L => (eâ‚„â‚ƒ.symm : G â†’SL[Ïƒâ‚ƒâ‚„] H).comp (L.comp (eâ‚â‚‚ : E â†’SL[Ïƒâ‚â‚‚] F))\n    map_add' := fun f g => by simp only [add_comp, comp_add]\n    map_smul' := fun t f => by simp only [smul_comp, comp_smulâ‚›â‚—]\n    continuous_toFun := ((postcomp F eâ‚„â‚ƒ.toContinuousLinearMap).comp\n      (precomp H eâ‚â‚‚.symm.toContinuousLinearMap)).continuous\n    continuous_invFun := ((precomp H eâ‚â‚‚.toContinuousLinearMap).comp\n      (postcomp F eâ‚„â‚ƒ.symm.toContinuousLinearMap)).continuous }\n\n"}
{"name":"ContinuousLinearEquiv.arrowCongrSL_toLinearEquiv_symm_apply","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nğ•œâ‚„ : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\nH : Type u_8\ninstâœÂ³Â¹ : AddCommGroup E\ninstâœÂ³â° : AddCommGroup F\ninstâœÂ²â¹ : AddCommGroup G\ninstâœÂ²â¸ : AddCommGroup H\ninstâœÂ²â· : NormedField ğ•œ\ninstâœÂ²â¶ : NormedField ğ•œâ‚‚\ninstâœÂ²âµ : NormedField ğ•œâ‚ƒ\ninstâœÂ²â´ : NormedField ğ•œâ‚„\ninstâœÂ²Â³ : Module ğ•œ E\ninstâœÂ²Â² : Module ğ•œâ‚‚ F\ninstâœÂ²Â¹ : Module ğ•œâ‚ƒ G\ninstâœÂ²â° : Module ğ•œâ‚„ H\ninstâœÂ¹â¹ : TopologicalSpace E\ninstâœÂ¹â¸ : TopologicalSpace F\ninstâœÂ¹â· : TopologicalSpace G\ninstâœÂ¹â¶ : TopologicalSpace H\ninstâœÂ¹âµ : TopologicalAddGroup G\ninstâœÂ¹â´ : TopologicalAddGroup H\ninstâœÂ¹Â³ : ContinuousConstSMul ğ•œâ‚ƒ G\ninstâœÂ¹Â² : ContinuousConstSMul ğ•œâ‚„ H\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚‚â‚ : RingHom ğ•œâ‚‚ ğ•œ\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\nÏƒâ‚ƒâ‚„ : RingHom ğ•œâ‚ƒ ğ•œâ‚„\nÏƒâ‚„â‚ƒ : RingHom ğ•œâ‚„ ğ•œâ‚ƒ\nÏƒâ‚‚â‚„ : RingHom ğ•œâ‚‚ ğ•œâ‚„\nÏƒâ‚â‚„ : RingHom ğ•œ ğ•œâ‚„\ninstâœÂ¹Â¹ : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚\ninstâœÂ¹â° : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚\ninstâœâ¹ : RingHomInvPair Ïƒâ‚ƒâ‚„ Ïƒâ‚„â‚ƒ\ninstâœâ¸ : RingHomInvPair Ïƒâ‚„â‚ƒ Ïƒâ‚ƒâ‚„\ninstâœâ· : RingHomCompTriple Ïƒâ‚‚â‚ Ïƒâ‚â‚„ Ïƒâ‚‚â‚„\ninstâœâ¶ : RingHomCompTriple Ïƒâ‚‚â‚„ Ïƒâ‚„â‚ƒ Ïƒâ‚‚â‚ƒ\ninstâœâµ : RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ\ninstâœâ´ : RingHomCompTriple Ïƒâ‚â‚ƒ Ïƒâ‚ƒâ‚„ Ïƒâ‚â‚„\ninstâœÂ³ : RingHomCompTriple Ïƒâ‚‚â‚ƒ Ïƒâ‚ƒâ‚„ Ïƒâ‚‚â‚„\ninstâœÂ² : RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚„ Ïƒâ‚â‚„\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœ : RingHomIsometric Ïƒâ‚‚â‚\neâ‚â‚‚ : ContinuousLinearEquiv Ïƒâ‚â‚‚ E F\neâ‚„â‚ƒ : ContinuousLinearEquiv Ïƒâ‚„â‚ƒ H G\nL : ContinuousLinearMap Ïƒâ‚‚â‚ƒ F G\nâŠ¢ Eq ((eâ‚â‚‚.arrowCongrSL eâ‚„â‚ƒ).symm L) ((â†‘eâ‚„â‚ƒ.symm).comp (L.comp â†‘eâ‚â‚‚))","decl":"/-- A pair of continuous (semi)linear equivalences generates a (semi)linear equivalence between the\nspaces of continuous (semi)linear maps. -/\n@[simps apply symm_apply toLinearEquiv_apply toLinearEquiv_symm_apply]\ndef arrowCongrSL (eâ‚â‚‚ : E â‰ƒSL[Ïƒâ‚â‚‚] F) (eâ‚„â‚ƒ : H â‰ƒSL[Ïƒâ‚„â‚ƒ] G) :\n    (E â†’SL[Ïƒâ‚â‚„] H) â‰ƒSL[Ïƒâ‚„â‚ƒ] F â†’SL[Ïƒâ‚‚â‚ƒ] G :=\n{ eâ‚â‚‚.arrowCongrEquiv eâ‚„â‚ƒ with\n    -- given explicitly to help `simps`\n    toFun := fun L => (eâ‚„â‚ƒ : H â†’SL[Ïƒâ‚„â‚ƒ] G).comp (L.comp (eâ‚â‚‚.symm : F â†’SL[Ïƒâ‚‚â‚] E))\n    -- given explicitly to help `simps`\n    invFun := fun L => (eâ‚„â‚ƒ.symm : G â†’SL[Ïƒâ‚ƒâ‚„] H).comp (L.comp (eâ‚â‚‚ : E â†’SL[Ïƒâ‚â‚‚] F))\n    map_add' := fun f g => by simp only [add_comp, comp_add]\n    map_smul' := fun t f => by simp only [smul_comp, comp_smulâ‚›â‚—]\n    continuous_toFun := ((postcomp F eâ‚„â‚ƒ.toContinuousLinearMap).comp\n      (precomp H eâ‚â‚‚.symm.toContinuousLinearMap)).continuous\n    continuous_invFun := ((precomp H eâ‚â‚‚.toContinuousLinearMap).comp\n      (postcomp F eâ‚„â‚ƒ.symm.toContinuousLinearMap)).continuous }\n\n"}
{"name":"ContinuousLinearEquiv.arrowCongrSL_apply","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nğ•œâ‚„ : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\nH : Type u_8\ninstâœÂ³Â¹ : AddCommGroup E\ninstâœÂ³â° : AddCommGroup F\ninstâœÂ²â¹ : AddCommGroup G\ninstâœÂ²â¸ : AddCommGroup H\ninstâœÂ²â· : NormedField ğ•œ\ninstâœÂ²â¶ : NormedField ğ•œâ‚‚\ninstâœÂ²âµ : NormedField ğ•œâ‚ƒ\ninstâœÂ²â´ : NormedField ğ•œâ‚„\ninstâœÂ²Â³ : Module ğ•œ E\ninstâœÂ²Â² : Module ğ•œâ‚‚ F\ninstâœÂ²Â¹ : Module ğ•œâ‚ƒ G\ninstâœÂ²â° : Module ğ•œâ‚„ H\ninstâœÂ¹â¹ : TopologicalSpace E\ninstâœÂ¹â¸ : TopologicalSpace F\ninstâœÂ¹â· : TopologicalSpace G\ninstâœÂ¹â¶ : TopologicalSpace H\ninstâœÂ¹âµ : TopologicalAddGroup G\ninstâœÂ¹â´ : TopologicalAddGroup H\ninstâœÂ¹Â³ : ContinuousConstSMul ğ•œâ‚ƒ G\ninstâœÂ¹Â² : ContinuousConstSMul ğ•œâ‚„ H\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚‚â‚ : RingHom ğ•œâ‚‚ ğ•œ\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\nÏƒâ‚ƒâ‚„ : RingHom ğ•œâ‚ƒ ğ•œâ‚„\nÏƒâ‚„â‚ƒ : RingHom ğ•œâ‚„ ğ•œâ‚ƒ\nÏƒâ‚‚â‚„ : RingHom ğ•œâ‚‚ ğ•œâ‚„\nÏƒâ‚â‚„ : RingHom ğ•œ ğ•œâ‚„\ninstâœÂ¹Â¹ : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚\ninstâœÂ¹â° : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚\ninstâœâ¹ : RingHomInvPair Ïƒâ‚ƒâ‚„ Ïƒâ‚„â‚ƒ\ninstâœâ¸ : RingHomInvPair Ïƒâ‚„â‚ƒ Ïƒâ‚ƒâ‚„\ninstâœâ· : RingHomCompTriple Ïƒâ‚‚â‚ Ïƒâ‚â‚„ Ïƒâ‚‚â‚„\ninstâœâ¶ : RingHomCompTriple Ïƒâ‚‚â‚„ Ïƒâ‚„â‚ƒ Ïƒâ‚‚â‚ƒ\ninstâœâµ : RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ\ninstâœâ´ : RingHomCompTriple Ïƒâ‚â‚ƒ Ïƒâ‚ƒâ‚„ Ïƒâ‚â‚„\ninstâœÂ³ : RingHomCompTriple Ïƒâ‚‚â‚ƒ Ïƒâ‚ƒâ‚„ Ïƒâ‚‚â‚„\ninstâœÂ² : RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚„ Ïƒâ‚â‚„\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœ : RingHomIsometric Ïƒâ‚‚â‚\neâ‚â‚‚ : ContinuousLinearEquiv Ïƒâ‚â‚‚ E F\neâ‚„â‚ƒ : ContinuousLinearEquiv Ïƒâ‚„â‚ƒ H G\nL : ContinuousLinearMap Ïƒâ‚â‚„ E H\nâŠ¢ Eq ((eâ‚â‚‚.arrowCongrSL eâ‚„â‚ƒ) L) ((â†‘eâ‚„â‚ƒ).comp (L.comp â†‘eâ‚â‚‚.symm))","decl":"/-- A pair of continuous (semi)linear equivalences generates a (semi)linear equivalence between the\nspaces of continuous (semi)linear maps. -/\n@[simps apply symm_apply toLinearEquiv_apply toLinearEquiv_symm_apply]\ndef arrowCongrSL (eâ‚â‚‚ : E â‰ƒSL[Ïƒâ‚â‚‚] F) (eâ‚„â‚ƒ : H â‰ƒSL[Ïƒâ‚„â‚ƒ] G) :\n    (E â†’SL[Ïƒâ‚â‚„] H) â‰ƒSL[Ïƒâ‚„â‚ƒ] F â†’SL[Ïƒâ‚‚â‚ƒ] G :=\n{ eâ‚â‚‚.arrowCongrEquiv eâ‚„â‚ƒ with\n    -- given explicitly to help `simps`\n    toFun := fun L => (eâ‚„â‚ƒ : H â†’SL[Ïƒâ‚„â‚ƒ] G).comp (L.comp (eâ‚â‚‚.symm : F â†’SL[Ïƒâ‚‚â‚] E))\n    -- given explicitly to help `simps`\n    invFun := fun L => (eâ‚„â‚ƒ.symm : G â†’SL[Ïƒâ‚ƒâ‚„] H).comp (L.comp (eâ‚â‚‚ : E â†’SL[Ïƒâ‚â‚‚] F))\n    map_add' := fun f g => by simp only [add_comp, comp_add]\n    map_smul' := fun t f => by simp only [smul_comp, comp_smulâ‚›â‚—]\n    continuous_toFun := ((postcomp F eâ‚„â‚ƒ.toContinuousLinearMap).comp\n      (precomp H eâ‚â‚‚.symm.toContinuousLinearMap)).continuous\n    continuous_invFun := ((precomp H eâ‚â‚‚.toContinuousLinearMap).comp\n      (postcomp F eâ‚„â‚ƒ.symm.toContinuousLinearMap)).continuous }\n\n"}
{"name":"ContinuousLinearEquiv.arrowCongr_apply","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nH : Type u_5\ninstâœÂ¹â¶ : AddCommGroup E\ninstâœÂ¹âµ : AddCommGroup F\ninstâœÂ¹â´ : AddCommGroup G\ninstâœÂ¹Â³ : AddCommGroup H\ninstâœÂ¹Â² : NormedField ğ•œ\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : Module ğ•œ F\ninstâœâ¹ : Module ğ•œ G\ninstâœâ¸ : Module ğ•œ H\ninstâœâ· : TopologicalSpace E\ninstâœâ¶ : TopologicalSpace F\ninstâœâµ : TopologicalSpace G\ninstâœâ´ : TopologicalSpace H\ninstâœÂ³ : TopologicalAddGroup G\ninstâœÂ² : TopologicalAddGroup H\ninstâœÂ¹ : ContinuousConstSMul ğ•œ G\ninstâœ : ContinuousConstSMul ğ•œ H\neâ‚ : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\neâ‚‚ : ContinuousLinearEquiv (RingHom.id ğ•œ) H G\nf : ContinuousLinearMap (RingHom.id ğ•œ) E H\nx : F\nâŠ¢ Eq (((eâ‚.arrowCongr eâ‚‚) f) x) (eâ‚‚ (f (eâ‚.symm x)))","decl":"@[simp] lemma arrowCongr_apply (eâ‚ : E â‰ƒL[ğ•œ] F) (eâ‚‚ : H â‰ƒL[ğ•œ] G) (f : E â†’L[ğ•œ] H) (x : F) :\n    eâ‚.arrowCongr eâ‚‚ f x = eâ‚‚ (f (eâ‚.symm x)) := rfl\n\n"}
{"name":"ContinuousLinearEquiv.arrowCongr_symm","module":"Mathlib.Topology.Algebra.Module.StrongTopology","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nH : Type u_5\ninstâœÂ¹â¶ : AddCommGroup E\ninstâœÂ¹âµ : AddCommGroup F\ninstâœÂ¹â´ : AddCommGroup G\ninstâœÂ¹Â³ : AddCommGroup H\ninstâœÂ¹Â² : NormedField ğ•œ\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : Module ğ•œ F\ninstâœâ¹ : Module ğ•œ G\ninstâœâ¸ : Module ğ•œ H\ninstâœâ· : TopologicalSpace E\ninstâœâ¶ : TopologicalSpace F\ninstâœâµ : TopologicalSpace G\ninstâœâ´ : TopologicalSpace H\ninstâœÂ³ : TopologicalAddGroup G\ninstâœÂ² : TopologicalAddGroup H\ninstâœÂ¹ : ContinuousConstSMul ğ•œ G\ninstâœ : ContinuousConstSMul ğ•œ H\neâ‚ : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\neâ‚‚ : ContinuousLinearEquiv (RingHom.id ğ•œ) H G\nâŠ¢ Eq (eâ‚.arrowCongr eâ‚‚).symm (eâ‚.symm.arrowCongr eâ‚‚.symm)","decl":"@[simp] lemma arrowCongr_symm (eâ‚ : E â‰ƒL[ğ•œ] F) (eâ‚‚ : H â‰ƒL[ğ•œ] G) :\n    (eâ‚.arrowCongr eâ‚‚).symm = eâ‚.symm.arrowCongr eâ‚‚.symm := rfl\n\n"}
