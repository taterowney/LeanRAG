{"name":"instSubsingletonSubtype","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\ninst✝ : Subsingleton α\np : α → Prop\n⊢ Subsingleton (Subtype p)","decl":"instance [Subsingleton α] (p : α → Prop) : Subsingleton (Subtype p) :=\n  ⟨fun ⟨x, _⟩ ⟨y, _⟩ ↦ by cases Subsingleton.elim x y; rfl⟩\n\n"}
{"name":"congr_heq","module":"Mathlib.Logic.Basic","initialProofState":"α β : Sort u_2\nγ : Sort u_3\nf : α → γ\ng : β → γ\nx : α\ny : β\nh₁ : HEq f g\nh₂ : HEq x y\n⊢ Eq (f x) (g y)","decl":"theorem congr_heq {α β γ : Sort _} {f : α → γ} {g : β → γ} {x : α} {y : β}\n    (h₁ : HEq f g) (h₂ : HEq x y) : f x = g y := by\n  cases h₂; cases h₁; rfl\n\n"}
{"name":"congr_arg_heq","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : α → Sort u_2\nf : (a : α) → β a\na₁ a₂ : α\na✝ : Eq a₁ a₂\n⊢ HEq (f a₁) (f a₂)","decl":"theorem congr_arg_heq {β : α → Sort*} (f : ∀ a, β a) :\n    ∀ {a₁ a₂ : α}, a₁ = a₂ → HEq (f a₁) (f a₂)\n  | _, _, rfl => HEq.rfl\n\n"}
{"name":"eq_iff_eq_cancel_left","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nb c : α\n⊢ Iff (∀ {a : α}, Iff (Eq a b) (Eq a c)) (Eq b c)","decl":"@[simp] theorem eq_iff_eq_cancel_left {b c : α} : (∀ {a}, a = b ↔ a = c) ↔ b = c :=\n  ⟨fun h ↦ by rw [← h], fun h a ↦ by rw [h]⟩\n\n"}
{"name":"eq_iff_eq_cancel_right","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\na b : α\n⊢ Iff (∀ {c : α}, Iff (Eq a c) (Eq b c)) (Eq a b)","decl":"@[simp] theorem eq_iff_eq_cancel_right {a b : α} : (∀ {c}, a = c ↔ b = c) ↔ a = b :=\n  ⟨fun h ↦ by rw [h], fun h a ↦ by rw [h]⟩\n\n"}
{"name":"ne_and_eq_iff_right","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\na b c : α\nh : Ne b c\n⊢ Iff (And (Ne a b) (Eq a c)) (Eq a c)","decl":"lemma ne_and_eq_iff_right {a b c : α} (h : b ≠ c) : a ≠ b ∧ a = c ↔ a = c :=\n  and_iff_right_of_imp (fun h2 => h2.symm ▸ h.symm)\n\n"}
{"name":"Fact.out","module":"Mathlib.Logic.Basic","initialProofState":"p : Prop\nself : Fact p\n⊢ p","decl":"/-- Wrapper for adding elementary propositions to the type class systems.\nWarning: this can easily be abused. See the rest of this docstring for details.\n\nCertain propositions should not be treated as a class globally,\nbut sometimes it is very convenient to be able to use the type class system\nin specific circumstances.\n\nFor example, `ZMod p` is a field if and only if `p` is a prime number.\nIn order to be able to find this field instance automatically by type class search,\nwe have to turn `p.prime` into an instance implicit assumption.\n\nOn the other hand, making `Nat.prime` a class would require a major refactoring of the library,\nand it is questionable whether making `Nat.prime` a class is desirable at all.\nThe compromise is to add the assumption `[Fact p.prime]` to `ZMod.field`.\n\nIn particular, this class is not intended for turning the type class system\ninto an automated theorem prover for first order logic. -/\nclass Fact (p : Prop) : Prop where\n  /-- `Fact.out` contains the unwrapped witness for the fact represented by the instance of\n  `Fact p`. -/\n  out : p\n\n"}
{"name":"Fact.elim","module":"Mathlib.Logic.Basic","initialProofState":"p : Prop\nh : Fact p\n⊢ p","decl":"theorem Fact.elim {p : Prop} (h : Fact p) : p := h.1\n"}
{"name":"fact_iff","module":"Mathlib.Logic.Basic","initialProofState":"p : Prop\n⊢ Iff (Fact p) p","decl":"theorem fact_iff {p : Prop} : Fact p ↔ p := ⟨fun h ↦ h.1, fun h ↦ ⟨h⟩⟩\n\n"}
{"name":"Iff.imp","module":"Mathlib.Logic.Basic","initialProofState":"a b c d : Prop\nh₁ : Iff a c\nh₂ : Iff b d\n⊢ Iff (a → b) (c → d)","decl":"alias Iff.imp := imp_congr\n\n-- This is a duplicate of `Classical.imp_iff_right_iff`. Deprecate?\n"}
{"name":"imp_iff_right_iff","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Iff (Iff (a → b) b) (Or a b)","decl":"theorem imp_iff_right_iff {a b : Prop} : (a → b ↔ b) ↔ a ∨ b := Decidable.imp_iff_right_iff\n\n-- This is a duplicate of `Classical.and_or_imp`. Deprecate?\n"}
{"name":"and_or_imp","module":"Mathlib.Logic.Basic","initialProofState":"a b c : Prop\n⊢ Iff (Or (And a b) (a → c)) (a → Or b c)","decl":"theorem and_or_imp {a b c : Prop} : a ∧ b ∨ (a → c) ↔ a → b ∨ c := Decidable.and_or_imp\n\n"}
{"name":"Function.mt","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\na✝¹ : a → b\na✝ : Not b\n⊢ Not a","decl":"/-- Provide modus tollens (`mt`) as dot notation for implications. -/\nprotected theorem Function.mt {a b : Prop} : (a → b) → ¬b → ¬a := mt\n\n"}
{"name":"dec_em","module":"Mathlib.Logic.Basic","initialProofState":"p : Prop\ninst✝ : Decidable p\n⊢ Or p (Not p)","decl":"alias dec_em := Decidable.em\n\n"}
{"name":"dec_em'","module":"Mathlib.Logic.Basic","initialProofState":"p : Prop\ninst✝ : Decidable p\n⊢ Or (Not p) p","decl":"theorem dec_em' (p : Prop) [Decidable p] : ¬p ∨ p := (dec_em p).symm\n\n"}
{"name":"em","module":"Mathlib.Logic.Basic","initialProofState":"p : Prop\n⊢ Or p (Not p)","decl":"alias em := Classical.em\n\n"}
{"name":"em'","module":"Mathlib.Logic.Basic","initialProofState":"p : Prop\n⊢ Or (Not p) p","decl":"theorem em' (p : Prop) : ¬p ∨ p := (em p).symm\n\n"}
{"name":"or_not","module":"Mathlib.Logic.Basic","initialProofState":"p : Prop\n⊢ Or p (Not p)","decl":"theorem or_not {p : Prop} : p ∨ ¬p := em _\n\n"}
{"name":"Decidable.eq_or_ne","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nx y : α\ninst✝ : Decidable (Eq x y)\n⊢ Or (Eq x y) (Ne x y)","decl":"theorem Decidable.eq_or_ne {α : Sort*} (x y : α) [Decidable (x = y)] : x = y ∨ x ≠ y :=\n  dec_em <| x = y\n\n"}
{"name":"Decidable.ne_or_eq","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nx y : α\ninst✝ : Decidable (Eq x y)\n⊢ Or (Ne x y) (Eq x y)","decl":"theorem Decidable.ne_or_eq {α : Sort*} (x y : α) [Decidable (x = y)] : x ≠ y ∨ x = y :=\n  dec_em' <| x = y\n\n"}
{"name":"eq_or_ne","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nx y : α\n⊢ Or (Eq x y) (Ne x y)","decl":"theorem eq_or_ne {α : Sort*} (x y : α) : x = y ∨ x ≠ y := em <| x = y\n\n"}
{"name":"ne_or_eq","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nx y : α\n⊢ Or (Ne x y) (Eq x y)","decl":"theorem ne_or_eq {α : Sort*} (x y : α) : x ≠ y ∨ x = y := em' <| x = y\n\n"}
{"name":"by_contradiction","module":"Mathlib.Logic.Basic","initialProofState":"p : Prop\na✝ : Not p → False\n⊢ p","decl":"theorem by_contradiction {p : Prop} : (¬p → False) → p := Decidable.byContradiction\n\n"}
{"name":"by_cases","module":"Mathlib.Logic.Basic","initialProofState":"p q : Prop\nhpq : p → q\nhnpq : Not p → q\n⊢ q","decl":"theorem by_cases {p q : Prop} (hpq : p → q) (hnpq : ¬p → q) : q :=\nif hp : p then hpq hp else hnpq hp\n\n"}
{"name":"by_contra","module":"Mathlib.Logic.Basic","initialProofState":"p : Prop\na✝ : Not p → False\n⊢ p","decl":"alias by_contra := by_contradiction\n\n"}
{"name":"of_not_not","module":"Mathlib.Logic.Basic","initialProofState":"a : Prop\na✝ : Not (Not a)\n⊢ a","decl":"theorem of_not_not {a : Prop} : ¬¬a → a := by_contra\n\n"}
{"name":"not_ne_iff","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\na b : α\n⊢ Iff (Not (Ne a b)) (Eq a b)","decl":"theorem not_ne_iff {α : Sort*} {a b : α} : ¬a ≠ b ↔ a = b := not_not\n\n"}
{"name":"of_not_imp","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\na✝ : Not (a → b)\n⊢ a","decl":"theorem of_not_imp : ¬(a → b) → a := Decidable.of_not_imp\n\n"}
{"name":"Not.decidable_imp_symm","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\ninst✝ : Decidable a\nh : Not a → b\nhb : Not b\n⊢ a","decl":"alias Not.decidable_imp_symm := Decidable.not_imp_symm\n\n"}
{"name":"Not.imp_symm","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\na✝¹ : Not a → b\na✝ : Not b\n⊢ a","decl":"theorem Not.imp_symm : (¬a → b) → ¬b → a := Not.decidable_imp_symm\n\n"}
{"name":"not_imp_comm","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Iff (Not a → b) (Not b → a)","decl":"theorem not_imp_comm : ¬a → b ↔ ¬b → a := Decidable.not_imp_comm\n\n"}
{"name":"not_imp_self","module":"Mathlib.Logic.Basic","initialProofState":"a : Prop\n⊢ Iff (Not a → a) a","decl":"@[simp] theorem not_imp_self : ¬a → a ↔ a := Decidable.not_imp_self\n\n"}
{"name":"Imp.swap","module":"Mathlib.Logic.Basic","initialProofState":"a : Sort u_1\nb : Sort u_2\nc : Prop\n⊢ Iff (a → b → c) (b → a → c)","decl":"theorem Imp.swap {a b : Sort*} {c : Prop} : a → b → c ↔ b → a → c :=\n  ⟨fun h x y ↦ h y x, fun h x y ↦ h y x⟩\n\n"}
{"name":"Iff.not","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\nh : Iff a b\n⊢ Iff (Not a) (Not b)","decl":"alias Iff.not := not_congr\n\n"}
{"name":"Iff.not_left","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\nh : Iff a (Not b)\n⊢ Iff (Not a) b","decl":"theorem Iff.not_left (h : a ↔ ¬b) : ¬a ↔ b := h.not.trans not_not\n\n"}
{"name":"Iff.not_right","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\nh : Iff (Not a) b\n⊢ Iff a (Not b)","decl":"theorem Iff.not_right (h : ¬a ↔ b) : a ↔ ¬b := not_not.symm.trans h.not\n\n"}
{"name":"Iff.ne","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\na b : α\nc d : β\na✝ : Iff (Eq a b) (Eq c d)\n⊢ Iff (Ne a b) (Ne c d)","decl":"protected lemma Iff.ne {α β : Sort*} {a b : α} {c d : β} : (a = b ↔ c = d) → (a ≠ b ↔ c ≠ d) :=\n  Iff.not\n\n"}
{"name":"Iff.ne_left","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\na b : α\nc d : β\na✝ : Iff (Eq a b) (Ne c d)\n⊢ Iff (Ne a b) (Eq c d)","decl":"lemma Iff.ne_left {α β : Sort*} {a b : α} {c d : β} : (a = b ↔ c ≠ d) → (a ≠ b ↔ c = d) :=\n  Iff.not_left\n\n"}
{"name":"Iff.ne_right","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\na b : α\nc d : β\na✝ : Iff (Ne a b) (Eq c d)\n⊢ Iff (Eq a b) (Ne c d)","decl":"lemma Iff.ne_right {α β : Sort*} {a b : α} {c d : β} : (a ≠ b ↔ c = d) → (a = b ↔ c ≠ d) :=\n  Iff.not_right\n\n"}
{"name":"xor_true","module":"Mathlib.Logic.Basic","initialProofState":"⊢ Eq (Xor' True) Not","decl":"@[simp] theorem xor_true : Xor' True = Not := by\n  simp (config := { unfoldPartialApp := true }) [Xor']\n\n"}
{"name":"xor_false","module":"Mathlib.Logic.Basic","initialProofState":"⊢ Eq (Xor' False) id","decl":"@[simp] theorem xor_false : Xor' False = id := by ext; simp [Xor']\n\n"}
{"name":"xor_comm","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Eq (Xor' a b) (Xor' b a)","decl":"theorem xor_comm (a b : Prop) : Xor' a b = Xor' b a := by simp [Xor', and_comm, or_comm]\n\n"}
{"name":"instCommutativeXor'","module":"Mathlib.Logic.Basic","initialProofState":"⊢ Std.Commutative Xor'","decl":"instance : Std.Commutative Xor' := ⟨xor_comm⟩\n\n"}
{"name":"xor_self","module":"Mathlib.Logic.Basic","initialProofState":"a : Prop\n⊢ Eq (Xor' a a) False","decl":"@[simp] theorem xor_self (a : Prop) : Xor' a a = False := by simp [Xor']\n\n"}
{"name":"xor_not_left","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Iff (Xor' (Not a) b) (Iff a b)","decl":"@[simp] theorem xor_not_left : Xor' (¬a) b ↔ (a ↔ b) := by by_cases a <;> simp [*]\n\n"}
{"name":"xor_not_right","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Iff (Xor' a (Not b)) (Iff a b)","decl":"@[simp] theorem xor_not_right : Xor' a (¬b) ↔ (a ↔ b) := by by_cases a <;> simp [*]\n\n"}
{"name":"xor_not_not","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Iff (Xor' (Not a) (Not b)) (Xor' a b)","decl":"theorem xor_not_not : Xor' (¬a) (¬b) ↔ Xor' a b := by simp [Xor', or_comm, and_comm]\n\n"}
{"name":"Xor'.or","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\nh : Xor' a b\n⊢ Or a b","decl":"protected theorem Xor'.or (h : Xor' a b) : a ∨ b := h.imp And.left And.left\n\n"}
{"name":"Iff.and","module":"Mathlib.Logic.Basic","initialProofState":"a c b d : Prop\nh₁ : Iff a c\nh₂ : Iff b d\n⊢ Iff (And a b) (And c d)","decl":"alias Iff.and := and_congr\n"}
{"name":"And.rotate","module":"Mathlib.Logic.Basic","initialProofState":"a b c : Prop\na✝ : And a (And b c)\n⊢ And b (And c a)","decl":"alias ⟨And.rotate, _⟩ := and_rotate\n\n"}
{"name":"and_symm_right","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\na b : α\np : Prop\n⊢ Iff (And p (Eq a b)) (And p (Eq b a))","decl":"theorem and_symm_right {α : Sort*} (a b : α) (p : Prop) : p ∧ a = b ↔ p ∧ b = a := by simp [eq_comm]\n"}
{"name":"and_symm_left","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\na b : α\np : Prop\n⊢ Iff (And (Eq a b) p) (And (Eq b a) p)","decl":"theorem and_symm_left {α : Sort*} (a b : α) (p : Prop) : a = b ∧ p ↔ b = a ∧ p := by simp [eq_comm]\n\n"}
{"name":"Iff.or","module":"Mathlib.Logic.Basic","initialProofState":"a c b d : Prop\nh₁ : Iff a c\nh₂ : Iff b d\n⊢ Iff (Or a b) (Or c d)","decl":"alias Iff.or := or_congr\n"}
{"name":"Or.rotate","module":"Mathlib.Logic.Basic","initialProofState":"a b c : Prop\na✝ : Or a (Or b c)\n⊢ Or b (Or c a)","decl":"alias ⟨Or.rotate, _⟩ := or_rotate\n\n"}
{"name":"Or.elim3","module":"Mathlib.Logic.Basic","initialProofState":"a b c d : Prop\nh : Or a (Or b c)\nha : a → d\nhb : b → d\nhc : c → d\n⊢ d","decl":"theorem Or.elim3 {c d : Prop} (h : a ∨ b ∨ c) (ha : a → d) (hb : b → d) (hc : c → d) : d :=\n  Or.elim h ha fun h₂ ↦ Or.elim h₂ hb hc\n\n"}
{"name":"Or.imp3","module":"Mathlib.Logic.Basic","initialProofState":"a b d e c f : Prop\nhad : a → d\nhbe : b → e\nhcf : c → f\na✝ : Or a (Or b c)\n⊢ Or d (Or e f)","decl":"theorem Or.imp3 {d e c f : Prop} (had : a → d) (hbe : b → e) (hcf : c → f) :\n    a ∨ b ∨ c → d ∨ e ∨ f :=\n  Or.imp had <| Or.imp hbe hcf\n\n"}
{"name":"not_or_of_imp","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\na✝ : a → b\n⊢ Or (Not a) b","decl":"theorem not_or_of_imp : (a → b) → ¬a ∨ b := Decidable.not_or_of_imp\n\n-- See Note [decidable namespace]\n"}
{"name":"Decidable.or_not_of_imp","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\ninst✝ : Decidable a\nh : a → b\n⊢ Or b (Not a)","decl":"protected theorem Decidable.or_not_of_imp [Decidable a] (h : a → b) : b ∨ ¬a :=\n  dite _ (Or.inl ∘ h) Or.inr\n\n"}
{"name":"or_not_of_imp","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\na✝ : a → b\n⊢ Or b (Not a)","decl":"theorem or_not_of_imp : (a → b) → b ∨ ¬a := Decidable.or_not_of_imp\n\n"}
{"name":"imp_iff_not_or","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Iff (a → b) (Or (Not a) b)","decl":"theorem imp_iff_not_or : a → b ↔ ¬a ∨ b := Decidable.imp_iff_not_or\n\n"}
{"name":"imp_iff_or_not","module":"Mathlib.Logic.Basic","initialProofState":"b a : Prop\n⊢ Iff (b → a) (Or a (Not b))","decl":"theorem imp_iff_or_not {b a : Prop} : b → a ↔ a ∨ ¬b := Decidable.imp_iff_or_not\n\n"}
{"name":"not_imp_not","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Iff (Not a → Not b) (b → a)","decl":"theorem not_imp_not : ¬a → ¬b ↔ b → a := Decidable.not_imp_not\n\n"}
{"name":"imp_and_neg_imp_iff","module":"Mathlib.Logic.Basic","initialProofState":"p q : Prop\n⊢ Iff (And (p → q) (Not p → q)) q","decl":"theorem imp_and_neg_imp_iff (p q : Prop) : (p → q) ∧ (¬p → q) ↔ q := by simp\n\n"}
{"name":"Function.mtr","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\na✝¹ : Not a → Not b\na✝ : b\n⊢ a","decl":"/-- Provide the reverse of modus tollens (`mt`) as dot notation for implications. -/\nprotected theorem Function.mtr : (¬a → ¬b) → b → a := not_imp_not.mp\n\n"}
{"name":"or_congr_left'","module":"Mathlib.Logic.Basic","initialProofState":"c a b : Prop\nh : Not c → Iff a b\n⊢ Iff (Or a c) (Or b c)","decl":"theorem or_congr_left' {c a b : Prop} (h : ¬c → (a ↔ b)) : a ∨ c ↔ b ∨ c :=\n  Decidable.or_congr_left' h\n\n"}
{"name":"or_congr_right'","module":"Mathlib.Logic.Basic","initialProofState":"a b c : Prop\nh : Not a → Iff b c\n⊢ Iff (Or a b) (Or a c)","decl":"theorem or_congr_right' {c : Prop} (h : ¬a → (b ↔ c)) : a ∨ b ↔ a ∨ c := Decidable.or_congr_right' h\n\n"}
{"name":"Iff.iff","module":"Mathlib.Logic.Basic","initialProofState":"p₁ p₂ q₁ q₂ : Prop\nh₁ : Iff p₁ p₂\nh₂ : Iff q₁ q₂\n⊢ Iff (Iff p₁ q₁) (Iff p₂ q₂)","decl":"alias Iff.iff := iff_congr\n\n-- @[simp] -- FIXME simp ignores proof rewrites\n"}
{"name":"iff_mpr_iff_true_intro","module":"Mathlib.Logic.Basic","initialProofState":"P : Prop\nh : P\n⊢ Eq ⋯ h","decl":"theorem iff_mpr_iff_true_intro {P : Prop} (h : P) : Iff.mpr (iff_true_intro h) True.intro = h := rfl\n\n"}
{"name":"imp_or","module":"Mathlib.Logic.Basic","initialProofState":"a b c : Prop\n⊢ Iff (a → Or b c) (Or (a → b) (a → c))","decl":"theorem imp_or {a b c : Prop} : a → b ∨ c ↔ (a → b) ∨ (a → c) := Decidable.imp_or\n\n"}
{"name":"imp_or'","module":"Mathlib.Logic.Basic","initialProofState":"a : Sort u_1\nb c : Prop\n⊢ Iff (a → Or b c) (Or (a → b) (a → c))","decl":"theorem imp_or' {a : Sort*} {b c : Prop} : a → b ∨ c ↔ (a → b) ∨ (a → c) := Decidable.imp_or'\n\n"}
{"name":"not_imp","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Iff (Not (a → b)) (And a (Not b))","decl":"theorem not_imp : ¬(a → b) ↔ a ∧ ¬b := Decidable.not_imp_iff_and_not\n\n"}
{"name":"peirce","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\na✝ : (a → b) → a\n⊢ a","decl":"theorem peirce (a b : Prop) : ((a → b) → a) → a := Decidable.peirce _ _\n\n"}
{"name":"not_iff_not","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Iff (Iff (Not a) (Not b)) (Iff a b)","decl":"theorem not_iff_not : (¬a ↔ ¬b) ↔ (a ↔ b) := Decidable.not_iff_not\n\n"}
{"name":"not_iff_comm","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Iff (Iff (Not a) b) (Iff (Not b) a)","decl":"theorem not_iff_comm : (¬a ↔ b) ↔ (¬b ↔ a) := Decidable.not_iff_comm\n\n"}
{"name":"not_iff","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Iff (Not (Iff a b)) (Iff (Not a) b)","decl":"theorem not_iff : ¬(a ↔ b) ↔ (¬a ↔ b) := Decidable.not_iff\n\n"}
{"name":"iff_not_comm","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Iff (Iff a (Not b)) (Iff b (Not a))","decl":"theorem iff_not_comm : (a ↔ ¬b) ↔ (b ↔ ¬a) := Decidable.iff_not_comm\n\n"}
{"name":"iff_iff_and_or_not_and_not","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Iff (Iff a b) (Or (And a b) (And (Not a) (Not b)))","decl":"theorem iff_iff_and_or_not_and_not : (a ↔ b) ↔ a ∧ b ∨ ¬a ∧ ¬b :=\n  Decidable.iff_iff_and_or_not_and_not\n\n"}
{"name":"iff_iff_not_or_and_or_not","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Iff (Iff a b) (And (Or (Not a) b) (Or a (Not b)))","decl":"theorem iff_iff_not_or_and_or_not : (a ↔ b) ↔ (¬a ∨ b) ∧ (a ∨ ¬b) :=\n  Decidable.iff_iff_not_or_and_or_not\n\n"}
{"name":"not_and_not_right","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Iff (Not (And a (Not b))) (a → b)","decl":"theorem not_and_not_right : ¬(a ∧ ¬b) ↔ a → b := Decidable.not_and_not_right\n\n"}
{"name":"not_and_or","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Iff (Not (And a b)) (Or (Not a) (Not b))","decl":"/-- One of **de Morgan's laws**: the negation of a conjunction is logically equivalent to the\ndisjunction of the negations. -/\ntheorem not_and_or : ¬(a ∧ b) ↔ ¬a ∨ ¬b := Decidable.not_and_iff_or_not_not\n\n"}
{"name":"or_iff_not_and_not","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Iff (Or a b) (Not (And (Not a) (Not b)))","decl":"theorem or_iff_not_and_not : a ∨ b ↔ ¬(¬a ∧ ¬b) := Decidable.or_iff_not_and_not\n\n"}
{"name":"and_iff_not_or_not","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Iff (And a b) (Not (Or (Not a) (Not b)))","decl":"theorem and_iff_not_or_not : a ∧ b ↔ ¬(¬a ∨ ¬b) := Decidable.and_iff_not_or_not\n\n"}
{"name":"not_xor","module":"Mathlib.Logic.Basic","initialProofState":"P Q : Prop\n⊢ Iff (Not (Xor' P Q)) (Iff P Q)","decl":"@[simp] theorem not_xor (P Q : Prop) : ¬Xor' P Q ↔ (P ↔ Q) := by\n  simp only [not_and, Xor', not_or, not_not, ← iff_iff_implies_and_implies]\n\n"}
{"name":"xor_iff_not_iff","module":"Mathlib.Logic.Basic","initialProofState":"P Q : Prop\n⊢ Iff (Xor' P Q) (Not (Iff P Q))","decl":"theorem xor_iff_not_iff (P Q : Prop) : Xor' P Q ↔ ¬ (P ↔ Q) := (not_xor P Q).not_right\n\n"}
{"name":"xor_iff_iff_not","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Iff (Xor' a b) (Iff a (Not b))","decl":"theorem xor_iff_iff_not : Xor' a b ↔ (a ↔ ¬b) := by simp only [← @xor_not_right a, not_not]\n\n"}
{"name":"xor_iff_not_iff'","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Iff (Xor' a b) (Iff (Not a) b)","decl":"theorem xor_iff_not_iff' : Xor' a b ↔ (¬a ↔ b) := by simp only [← @xor_not_left _ b, not_not]\n\n"}
{"name":"xor_iff_or_and_not_and","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Iff (Xor' a b) (And (Or a b) (Not (And a b)))","decl":"theorem xor_iff_or_and_not_and (a b : Prop) : Xor' a b ↔ (a ∨ b) ∧ (¬ (a ∧ b)) := by\n  rw [Xor', or_and_right, not_and_or, and_or_left, and_not_self_iff, false_or,\n    and_or_left, and_not_self_iff, or_false]\n\n"}
{"name":"Membership.mem.ne_of_not_mem","module":"Mathlib.Logic.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Membership α β\ns : β\na b : α\nh : Membership.mem s a\na✝ : Not (Membership.mem s b)\n⊢ Ne a b","decl":"alias Membership.mem.ne_of_not_mem := ne_of_mem_of_not_mem\n"}
{"name":"Membership.mem.ne_of_not_mem'","module":"Mathlib.Logic.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Membership α β\ns t : β\na : α\nh : Membership.mem s a\na✝ : Not (Membership.mem t a)\n⊢ Ne s t","decl":"alias Membership.mem.ne_of_not_mem' := ne_of_mem_of_not_mem'\n\n"}
{"name":"mem_dite","module":"Mathlib.Logic.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Membership α β\np : Prop\ninst✝ : Decidable p\na : α\ns : p → β\nt : Not p → β\n⊢ Iff (Membership.mem (dite p (fun h => s h) fun h => t h) a) (And (∀ (h : p), Membership.mem (s h) a) (∀ (h : Not p), Membership.mem (t h) a))","decl":"theorem mem_dite {a : α} {s : p → β} {t : ¬p → β} :\n    (a ∈ if h : p then s h else t h) ↔ (∀ h, a ∈ s h) ∧ (∀ h, a ∈ t h) := by\n  by_cases h : p <;> simp [h]\n\n"}
{"name":"dite_mem","module":"Mathlib.Logic.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Membership α β\np : Prop\ninst✝ : Decidable p\na : p → α\nb : Not p → α\ns : β\n⊢ Iff (Membership.mem s (dite p (fun h => a h) fun h => b h)) (And (∀ (h : p), Membership.mem s (a h)) (∀ (h : Not p), Membership.mem s (b h)))","decl":"theorem dite_mem {a : p → α} {b : ¬p → α} {s : β} :\n    (if h : p then a h else b h) ∈ s ↔ (∀ h, a h ∈ s) ∧ (∀ h, b h ∈ s) := by\n  by_cases h : p <;> simp [h]\n\n"}
{"name":"mem_ite","module":"Mathlib.Logic.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Membership α β\np : Prop\ninst✝ : Decidable p\na : α\ns t : β\n⊢ Iff (Membership.mem (ite p s t) a) (And (p → Membership.mem s a) (Not p → Membership.mem t a))","decl":"theorem mem_ite {a : α} {s t : β} : (a ∈ if p then s else t) ↔ (p → a ∈ s) ∧ (¬p → a ∈ t) :=\n  mem_dite\n\n"}
{"name":"ite_mem","module":"Mathlib.Logic.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Membership α β\np : Prop\ninst✝ : Decidable p\na b : α\ns : β\n⊢ Iff (Membership.mem s (ite p a b)) (And (p → Membership.mem s a) (Not p → Membership.mem s b))","decl":"theorem ite_mem {a b : α} {s : β} : (if p then a else b) ∈ s ↔ (p → a ∈ s) ∧ (¬p → b ∈ s) :=\n  dite_mem\n\n"}
{"name":"forall_cond_comm","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\ns : α → Prop\np : α → α → Prop\n⊢ Iff (∀ (a : α), s a → ∀ (b : α), s b → p a b) (∀ (a b : α), s a → s b → p a b)","decl":"theorem forall_cond_comm {α} {s : α → Prop} {p : α → α → Prop} :\n    (∀ a, s a → ∀ b, s b → p a b) ↔ ∀ a b, s a → s b → p a b :=\n  ⟨fun h a b ha hb ↦ h a ha b hb, fun h a ha b hb ↦ h a b ha hb⟩\n\n"}
{"name":"forall_mem_comm","module":"Mathlib.Logic.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Membership α β\ns : β\np : α → α → Prop\n⊢ Iff (∀ (a : α), Membership.mem s a → ∀ (b : α), Membership.mem s b → p a b) (∀ (a b : α), Membership.mem s a → Membership.mem s b → p a b)","decl":"theorem forall_mem_comm {α β} [Membership α β] {s : β} {p : α → α → Prop} :\n    (∀ a (_ : a ∈ s) b (_ : b ∈ s), p a b) ↔ ∀ a b, a ∈ s → b ∈ s → p a b :=\n  forall_cond_comm\n\n\n"}
{"name":"ne_of_eq_of_ne","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\na b c : α\nh₁ : Eq a b\nh₂ : Ne b c\n⊢ Ne a c","decl":"lemma ne_of_eq_of_ne {α : Sort*} {a b c : α} (h₁ : a = b) (h₂ : b ≠ c) : a ≠ c := h₁.symm ▸ h₂\n"}
{"name":"ne_of_ne_of_eq","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\na b c : α\nh₁ : Ne a b\nh₂ : Eq b c\n⊢ Ne a c","decl":"lemma ne_of_ne_of_eq {α : Sort*} {a b c : α} (h₁ : a ≠ b) (h₂ : b = c) : a ≠ c := h₂ ▸ h₁\n\n"}
{"name":"Eq.trans_ne","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\na b c : α\nh₁ : Eq a b\nh₂ : Ne b c\n⊢ Ne a c","decl":"alias Eq.trans_ne := ne_of_eq_of_ne\n"}
{"name":"Ne.trans_eq","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\na b c : α\nh₁ : Ne a b\nh₂ : Eq b c\n⊢ Ne a c","decl":"alias Ne.trans_eq := ne_of_ne_of_eq\n\n"}
{"name":"eq_equivalence","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\n⊢ Equivalence Eq","decl":"theorem eq_equivalence {α : Sort*} : Equivalence (@Eq α) :=\n  ⟨Eq.refl, @Eq.symm _, @Eq.trans _⟩\n\n-- These were migrated to Batteries but the `@[simp]` attributes were (mysteriously?) removed.\n"}
{"name":"congr_refl_left","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\na b : α\nh : Eq a b\n⊢ Eq ⋯ ⋯","decl":"theorem congr_refl_left {α β : Sort*} (f : α → β) {a b : α} (h : a = b) :\n    congr (Eq.refl f) h = congr_arg f h := rfl\n\n-- @[simp] -- FIXME simp ignores proof rewrites\n"}
{"name":"congr_refl_right","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf g : α → β\nh : Eq f g\na : α\n⊢ Eq ⋯ ⋯","decl":"theorem congr_refl_right {α β : Sort*} {f g : α → β} (h : f = g) (a : α) :\n    congr h (Eq.refl a) = congr_fun h a := rfl\n\n-- @[simp] -- FIXME simp ignores proof rewrites\n"}
{"name":"congr_arg_refl","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\na : α\n⊢ Eq ⋯ ⋯","decl":"theorem congr_arg_refl {α β : Sort*} (f : α → β) (a : α) :\n    congr_arg f (Eq.refl a) = Eq.refl (f a) :=\n  rfl\n\n-- @[simp] -- FIXME simp ignores proof rewrites\n"}
{"name":"congr_fun_rfl","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\na : α\n⊢ Eq ⋯ ⋯","decl":"theorem congr_fun_rfl {α β : Sort*} (f : α → β) (a : α) : congr_fun (Eq.refl f) a = Eq.refl (f a) :=\n  rfl\n\n-- @[simp] -- FIXME simp ignores proof rewrites\n"}
{"name":"congr_fun_congr_arg","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β → γ\na a' : α\np : Eq a a'\nb : β\n⊢ Eq ⋯ ⋯","decl":"theorem congr_fun_congr_arg {α β γ : Sort*} (f : α → β → γ) {a a' : α} (p : a = a') (b : β) :\n    congr_fun (congr_arg f p) b = congr_arg (fun a ↦ f a b) p := rfl\n\n"}
{"name":"Eq.rec_eq_cast","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : α → Sort u_2\nx y : α\nh : Eq x y\nz : P x\n⊢ Eq (Eq.rec z h) (cast ⋯ z)","decl":"theorem Eq.rec_eq_cast {α : Sort _} {P : α → Sort _} {x y : α} (h : x = y) (z : P x) :\n    h ▸ z = cast (congr_arg P h) z := by induction h; rfl\n\n"}
{"name":"eqRec_heq'","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\na' : α\nmotive : (a : α) → Eq a' a → Sort u_2\np : motive a' ⋯\na : α\nt : Eq a' a\n⊢ HEq (Eq.rec p t) p","decl":"theorem eqRec_heq' {α : Sort*} {a' : α} {motive : (a : α) → a' = a → Sort*}\n    (p : motive a' (rfl : a' = a')) {a : α} (t : a' = a) :\n    HEq (@Eq.rec α a' motive p a t) p := by\n  subst t; rfl\n\n"}
{"name":"rec_heq_of_heq","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_2\nβ : Sort u_1\na b : α\nC : α → Sort u_1\nx : C a\ny : β\ne : Eq a b\nh : HEq x y\n⊢ HEq (Eq.rec x e) y","decl":"theorem rec_heq_of_heq {α β : Sort _} {a b : α} {C : α → Sort*} {x : C a} {y : β}\n    (e : a = b) (h : HEq x y) : HEq (e ▸ x) y := by subst e; exact h\n\n"}
{"name":"rec_heq_iff_heq","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_2\nβ : Sort u_1\na b : α\nC : α → Sort u_1\nx : C a\ny : β\ne : Eq a b\n⊢ Iff (HEq (Eq.rec x e) y) (HEq x y)","decl":"theorem rec_heq_iff_heq {α β : Sort _} {a b : α} {C : α → Sort*} {x : C a} {y : β} {e : a = b} :\n    HEq (e ▸ x) y ↔ HEq x y := by subst e; rfl\n\n"}
{"name":"heq_rec_iff_heq","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_2\nβ : Sort u_1\na b : α\nC : α → Sort u_1\nx : β\ny : C a\ne : Eq a b\n⊢ Iff (HEq x (Eq.rec y e)) (HEq x y)","decl":"theorem heq_rec_iff_heq {α β : Sort _} {a b : α} {C : α → Sort*} {x : β} {y : C a} {e : a = b} :\n    HEq x (e ▸ y) ↔ HEq x y := by subst e; rfl\n\n"}
{"name":"cast_heq_iff_heq","module":"Mathlib.Logic.Basic","initialProofState":"α β γ : Sort u_1\ne : Eq α β\na : α\nc : γ\n⊢ Iff (HEq (cast e a) c) (HEq a c)","decl":"@[simp]\ntheorem cast_heq_iff_heq {α β γ : Sort _} (e : α = β) (a : α) (c : γ) :\n    HEq (cast e a) c ↔ HEq a c := by subst e; rfl\n\n"}
{"name":"heq_cast_iff_heq","module":"Mathlib.Logic.Basic","initialProofState":"α β γ : Sort u_1\ne : Eq β γ\na : α\nb : β\n⊢ Iff (HEq a (cast e b)) (HEq a b)","decl":"@[simp]\ntheorem heq_cast_iff_heq {α β γ : Sort _} (e : β = γ) (a : α) (b : β) :\n    HEq a (cast e b) ↔ HEq a b := by subst e; rfl\n\n"}
{"name":"heq_of_eq_cast","module":"Mathlib.Logic.Basic","initialProofState":"α β : Sort u\na : α\nb : β\ne : Eq β α\na✝ : Eq a (cast e b)\n⊢ HEq a b","decl":"lemma heq_of_eq_cast (e : β = α) : a = cast e b → HEq a b := by rintro rfl; simp\n\n"}
{"name":"eq_cast_iff_heq","module":"Mathlib.Logic.Basic","initialProofState":"α β : Sort u\ne : Eq β α\na : α\nb : β\n⊢ Iff (Eq a (cast e b)) (HEq a b)","decl":"lemma eq_cast_iff_heq : a = cast e b ↔ HEq a b := ⟨heq_of_eq_cast _, fun h ↦ by cases h; rfl⟩\n\n"}
{"name":"forall₂_imp","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : α → Sort u_2\np q : (a : α) → β a → Prop\nh : ∀ (a : α) (b : β a), p a b → q a b\na✝ : ∀ (a : α) (b : β a), p a b\na : α\nb : β a\n⊢ q a b","decl":"theorem forall₂_imp {p q : ∀ a, β a → Prop} (h : ∀ a b, p a b → q a b) :\n    (∀ a b, p a b) → ∀ a b, q a b :=\n  forall_imp fun i ↦ forall_imp <| h i\n\n"}
{"name":"forall₃_imp","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : α → Sort u_2\nγ : (a : α) → β a → Sort u_3\np q : (a : α) → (b : β a) → γ a b → Prop\nh : ∀ (a : α) (b : β a) (c : γ a b), p a b c → q a b c\na✝ : ∀ (a : α) (b : β a) (c : γ a b), p a b c\na : α\nb : β a\nc : γ a b\n⊢ q a b c","decl":"theorem forall₃_imp {p q : ∀ a b, γ a b → Prop} (h : ∀ a b c, p a b c → q a b c) :\n    (∀ a b c, p a b c) → ∀ a b c, q a b c :=\n  forall_imp fun a ↦ forall₂_imp <| h a\n\n"}
{"name":"Exists₂.imp","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : α → Sort u_2\np q : (a : α) → β a → Prop\nh : ∀ (a : α) (b : β a), p a b → q a b\na✝ : Exists fun a => Exists fun b => p a b\n⊢ Exists fun a => Exists fun b => q a b","decl":"theorem Exists₂.imp {p q : ∀ a, β a → Prop} (h : ∀ a b, p a b → q a b) :\n    (∃ a b, p a b) → ∃ a b, q a b :=\n  Exists.imp fun a ↦ Exists.imp <| h a\n\n"}
{"name":"Exists₃.imp","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : α → Sort u_2\nγ : (a : α) → β a → Sort u_3\np q : (a : α) → (b : β a) → γ a b → Prop\nh : ∀ (a : α) (b : β a) (c : γ a b), p a b c → q a b c\na✝ : Exists fun a => Exists fun b => Exists fun c => p a b c\n⊢ Exists fun a => Exists fun b => Exists fun c => q a b c","decl":"theorem Exists₃.imp {p q : ∀ a b, γ a b → Prop} (h : ∀ a b c, p a b c → q a b c) :\n    (∃ a b c, p a b c) → ∃ a b c, q a b c :=\n  Exists.imp fun a ↦ Exists₂.imp <| h a\n\n"}
{"name":"forall_swap","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\np : α → β → Prop\n⊢ Iff (∀ (x : α) (y : β), p x y) (∀ (y : β) (x : α), p x y)","decl":"theorem forall_swap {p : α → β → Prop} : (∀ x y, p x y) ↔ ∀ y x, p x y :=\n  ⟨fun f x y ↦ f y x, fun f x y ↦ f y x⟩\n\n"}
{"name":"forall₂_swap","module":"Mathlib.Logic.Basic","initialProofState":"ι₁ : Sort u_3\nι₂ : Sort u_4\nκ₁ : ι₁ → Sort u_5\nκ₂ : ι₂ → Sort u_6\np : (i₁ : ι₁) → κ₁ i₁ → (i₂ : ι₂) → κ₂ i₂ → Prop\n⊢ Iff (∀ (i₁ : ι₁) (j₁ : κ₁ i₁) (i₂ : ι₂) (j₂ : κ₂ i₂), p i₁ j₁ i₂ j₂) (∀ (i₂ : ι₂) (j₂ : κ₂ i₂) (i₁ : ι₁) (j₁ : κ₁ i₁), p i₁ j₁ i₂ j₂)","decl":"theorem forall₂_swap\n    {ι₁ ι₂ : Sort*} {κ₁ : ι₁ → Sort*} {κ₂ : ι₂ → Sort*} {p : ∀ i₁, κ₁ i₁ → ∀ i₂, κ₂ i₂ → Prop} :\n    (∀ i₁ j₁ i₂ j₂, p i₁ j₁ i₂ j₂) ↔ ∀ i₂ j₂ i₁ j₁, p i₁ j₁ i₂ j₂ := ⟨swap₂, swap₂⟩\n\n"}
{"name":"imp_forall_iff","module":"Mathlib.Logic.Basic","initialProofState":"α : Type u_3\np : Prop\nq : α → Prop\n⊢ Iff (p → ∀ (x : α), q x) (∀ (x : α), p → q x)","decl":"/-- We intentionally restrict the type of `α` in this lemma so that this is a safer to use in simp\nthan `forall_swap`. -/\ntheorem imp_forall_iff {α : Type*} {p : Prop} {q : α → Prop} : (p → ∀ x, q x) ↔ ∀ x, p → q x :=\n  forall_swap\n\n"}
{"name":"imp_forall_iff_forall","module":"Mathlib.Logic.Basic","initialProofState":"A : Prop\nB : A → Prop\n⊢ Iff (A → ∀ (h : A), B h) (∀ (h : A), B h)","decl":"lemma imp_forall_iff_forall (A : Prop) (B : A → Prop) :\n  (A → ∀ h : A, B h) ↔ ∀ h : A, B h := by by_cases h : A <;> simp [h]\n\n"}
{"name":"exists_swap","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\np : α → β → Prop\n⊢ Iff (Exists fun x => Exists fun y => p x y) (Exists fun y => Exists fun x => p x y)","decl":"theorem exists_swap {p : α → β → Prop} : (∃ x y, p x y) ↔ ∃ y x, p x y :=\n  ⟨fun ⟨x, y, h⟩ ↦ ⟨y, x, h⟩, fun ⟨y, x, h⟩ ↦ ⟨x, y, h⟩⟩\n\n"}
{"name":"exists_and_exists_comm","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nP : α → Prop\nQ : β → Prop\n⊢ Iff (And (Exists fun a => P a) (Exists fun b => Q b)) (Exists fun a => Exists fun b => And (P a) (Q b))","decl":"theorem exists_and_exists_comm {P : α → Prop} {Q : β → Prop} :\n    (∃ a, P a) ∧ (∃ b, Q b) ↔ ∃ a b, P a ∧ Q b :=\n  ⟨fun ⟨⟨a, ha⟩, ⟨b, hb⟩⟩ ↦ ⟨a, b, ⟨ha, hb⟩⟩, fun ⟨a, b, ⟨ha, hb⟩⟩ ↦ ⟨⟨a, ha⟩, ⟨b, hb⟩⟩⟩\n\n"}
{"name":"not_forall_not","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\np : α → Prop\n⊢ Iff (Not (∀ (x : α), Not (p x))) (Exists fun x => p x)","decl":"theorem not_forall_not : (¬∀ x, ¬p x) ↔ ∃ x, p x := Decidable.not_forall_not\n\n"}
{"name":"forall_or_exists_not","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : α → Prop\n⊢ Or (∀ (a : α), P a) (Exists fun a => Not (P a))","decl":"lemma forall_or_exists_not (P : α → Prop) : (∀ a, P a) ∨ ∃ a, ¬ P a := by\n  rw [← not_forall]; exact em _\n\n"}
{"name":"exists_or_forall_not","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : α → Prop\n⊢ Or (Exists fun a => P a) (∀ (a : α), Not (P a))","decl":"lemma exists_or_forall_not (P : α → Prop) : (∃ a, P a) ∨ ∀ a, ¬ P a := by\n  rw [← not_exists]; exact em _\n\n"}
{"name":"forall_imp_iff_exists_imp","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_3\np : α → Prop\nb : Prop\nha : Nonempty α\n⊢ Iff ((∀ (x : α), p x) → b) (Exists fun x => p x → b)","decl":"theorem forall_imp_iff_exists_imp {α : Sort*} {p : α → Prop} {b : Prop} [ha : Nonempty α] :\n    (∀ x, p x) → b ↔ ∃ x, p x → b := by\n  let ⟨a⟩ := ha\n  refine ⟨fun h ↦ not_forall_not.1 fun h' ↦ ?_, fun ⟨x, hx⟩ h ↦ hx (h x)⟩\n  exact if hb : b then h' a fun _ ↦ hb else hb <| h fun x ↦ (_root_.not_imp.1 (h' x)).1\n\n"}
{"name":"forall_true_iff","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\n⊢ Iff (α → True) True","decl":"@[mfld_simps]\ntheorem forall_true_iff : (α → True) ↔ True := imp_true_iff _\n\n-- Unfortunately this causes simp to loop sometimes, so we\n-- add the 2 and 3 cases as simp lemmas instead\n"}
{"name":"forall_true_iff'","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\np : α → Prop\nh : ∀ (a : α), Iff (p a) True\n⊢ Iff (∀ (a : α), p a) True","decl":"theorem forall_true_iff' (h : ∀ a, p a ↔ True) : (∀ a, p a) ↔ True :=\n  iff_true_intro fun _ ↦ of_iff_true (h _)\n\n-- This is not marked `@[simp]` because `implies_true : (α → True) = True` works\n"}
{"name":"forall₂_true_iff","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : α → Sort u_3\n⊢ Iff (∀ (a : α), β a → True) True","decl":"theorem forall₂_true_iff {β : α → Sort*} : (∀ a, β a → True) ↔ True := by simp\n\n-- This is not marked `@[simp]` because `implies_true : (α → True) = True` works\n"}
{"name":"forall₃_true_iff","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : α → Sort u_3\nγ : (a : α) → β a → Sort u_4\n⊢ Iff (∀ (a : α) (b : β a), γ a b → True) True","decl":"theorem forall₃_true_iff {β : α → Sort*} {γ : ∀ a, β a → Sort*} :\n    (∀ (a) (b : β a), γ a b → True) ↔ True := by simp\n\n"}
{"name":"Decidable.and_forall_ne","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\ninst✝ : DecidableEq α\na : α\np : α → Prop\n⊢ Iff (And (p a) (∀ (b : α), Ne b a → p b)) (∀ (b : α), p b)","decl":"theorem Decidable.and_forall_ne [DecidableEq α] (a : α) {p : α → Prop} :\n    (p a ∧ ∀ b, b ≠ a → p b) ↔ ∀ b, p b := by\n  simp only [← @forall_eq _ p a, ← forall_and, ← or_imp, Decidable.em, forall_const]\n\n"}
{"name":"and_forall_ne","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\np : α → Prop\na : α\n⊢ Iff (And (p a) (∀ (b : α), Ne b a → p b)) (∀ (b : α), p b)","decl":"theorem and_forall_ne (a : α) : (p a ∧ ∀ b, b ≠ a → p b) ↔ ∀ b, p b :=\n  Decidable.and_forall_ne a\n\n"}
{"name":"Ne.ne_or_ne","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nx y z : α\nh : Ne x y\n⊢ Or (Ne x z) (Ne y z)","decl":"theorem Ne.ne_or_ne {x y : α} (z : α) (h : x ≠ y) : x ≠ z ∨ y ≠ z :=\n  not_and_or.1 <| mt (and_imp.2 (· ▸ ·)) h.symm\n\n"}
{"name":"exists_apply_eq_apply'","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\na' : α\n⊢ Exists fun a => Eq (f a') (f a)","decl":"@[simp]\ntheorem exists_apply_eq_apply' (f : α → β) (a' : α) : ∃ a, f a' = f a := ⟨a', rfl⟩\n\n"}
{"name":"exists_apply_eq_apply2","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_3\nβ : Sort u_4\nγ : Sort u_5\nf : α → β → γ\na : α\nb : β\n⊢ Exists fun x => Exists fun y => Eq (f x y) (f a b)","decl":"@[simp]\nlemma exists_apply_eq_apply2 {α β γ} {f : α → β → γ} {a : α} {b : β} : ∃ x y, f x y = f a b :=\n  ⟨a, b, rfl⟩\n\n"}
{"name":"exists_apply_eq_apply2'","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_3\nβ : Sort u_4\nγ : Sort u_5\nf : α → β → γ\na : α\nb : β\n⊢ Exists fun x => Exists fun y => Eq (f a b) (f x y)","decl":"@[simp]\nlemma exists_apply_eq_apply2' {α β γ} {f : α → β → γ} {a : α} {b : β} : ∃ x y, f a b = f x y :=\n  ⟨a, b, rfl⟩\n\n"}
{"name":"exists_apply_eq_apply3","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_3\nβ : Sort u_4\nγ : Sort u_5\nδ : Sort u_6\nf : α → β → γ → δ\na : α\nb : β\nc : γ\n⊢ Exists fun x => Exists fun y => Exists fun z => Eq (f x y z) (f a b c)","decl":"@[simp]\nlemma exists_apply_eq_apply3 {α β γ δ} {f : α → β → γ → δ} {a : α} {b : β} {c : γ} :\n    ∃ x y z, f x y z = f a b c :=\n  ⟨a, b, c, rfl⟩\n\n"}
{"name":"exists_apply_eq_apply3'","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_3\nβ : Sort u_4\nγ : Sort u_5\nδ : Sort u_6\nf : α → β → γ → δ\na : α\nb : β\nc : γ\n⊢ Exists fun x => Exists fun y => Exists fun z => Eq (f a b c) (f x y z)","decl":"@[simp]\nlemma exists_apply_eq_apply3' {α β γ δ} {f : α → β → γ → δ} {a : α} {b : β} {c : γ} :\n    ∃ x y z, f a b c = f x y z :=\n  ⟨a, b, c, rfl⟩\n\n-- Porting note: an alternative workaround theorem:\n"}
{"name":"exists_apply_eq","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\na : α\nb : β\n⊢ Exists fun f => Eq (f a) b","decl":"theorem exists_apply_eq (a : α) (b : β) : ∃ f : α → β, f a = b := ⟨fun _ ↦ b, rfl⟩\n\n"}
{"name":"exists_exists_and_eq_and","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\np : α → Prop\nq : β → Prop\n⊢ Iff (Exists fun b => And (Exists fun a => And (p a) (Eq (f a) b)) (q b)) (Exists fun a => And (p a) (q (f a)))","decl":"@[simp] theorem exists_exists_and_eq_and {f : α → β} {p : α → Prop} {q : β → Prop} :\n    (∃ b, (∃ a, p a ∧ f a = b) ∧ q b) ↔ ∃ a, p a ∧ q (f a) :=\n  ⟨fun ⟨_, ⟨a, ha, hab⟩, hb⟩ ↦ ⟨a, ha, hab.symm ▸ hb⟩, fun ⟨a, hp, hq⟩ ↦ ⟨f a, ⟨a, hp, rfl⟩, hq⟩⟩\n\n"}
{"name":"exists_exists_eq_and","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\np : β → Prop\n⊢ Iff (Exists fun b => And (Exists fun a => Eq (f a) b) (p b)) (Exists fun a => p (f a))","decl":"@[simp] theorem exists_exists_eq_and {f : α → β} {p : β → Prop} :\n    (∃ b, (∃ a, f a = b) ∧ p b) ↔ ∃ a, p (f a) :=\n  ⟨fun ⟨_, ⟨a, ha⟩, hb⟩ ↦ ⟨a, ha.symm ▸ hb⟩, fun ⟨a, ha⟩ ↦ ⟨f a, ⟨a, rfl⟩, ha⟩⟩\n\n"}
{"name":"exists_exists_and_exists_and_eq_and","module":"Mathlib.Logic.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\nf : α → β → γ\np : α → Prop\nq : β → Prop\nr : γ → Prop\n⊢ Iff (Exists fun c => And (Exists fun a => And (p a) (Exists fun b => And (q b) (Eq (f a b) c))) (r c)) (Exists fun a => And (p a) (Exists fun b => And (q b) (r (f a b))))","decl":"@[simp] theorem exists_exists_and_exists_and_eq_and {α β γ : Type*}\n    {f : α → β → γ} {p : α → Prop} {q : β → Prop} {r : γ → Prop} :\n    (∃ c, (∃ a, p a ∧ ∃ b, q b ∧ f a b = c) ∧ r c) ↔ ∃ a, p a ∧ ∃ b, q b ∧ r (f a b) :=\n  ⟨fun ⟨_, ⟨a, ha, b, hb, hab⟩, hc⟩ ↦ ⟨a, ha, b, hb, hab.symm ▸ hc⟩,\n    fun ⟨a, ha, b, hb, hab⟩ ↦ ⟨f a b, ⟨a, ha, b, hb, rfl⟩, hab⟩⟩\n\n"}
{"name":"exists_exists_exists_and_eq","module":"Mathlib.Logic.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\nf : α → β → γ\np : γ → Prop\n⊢ Iff (Exists fun c => And (Exists fun a => Exists fun b => Eq (f a b) c) (p c)) (Exists fun a => Exists fun b => p (f a b))","decl":"@[simp] theorem exists_exists_exists_and_eq {α β γ : Type*}\n    {f : α → β → γ} {p : γ → Prop} :\n    (∃ c, (∃ a, ∃ b, f a b = c) ∧ p c) ↔ ∃ a, ∃ b, p (f a b) :=\n  ⟨fun ⟨_, ⟨a, b, hab⟩, hc⟩ ↦ ⟨a, b, hab.symm ▸ hc⟩,\n    fun ⟨a, b, hab⟩ ↦ ⟨f a b, ⟨a, b, rfl⟩, hab⟩⟩\n\n"}
{"name":"forall_apply_eq_imp_iff'","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\np : β → Prop\n⊢ Iff (∀ (a : α) (b : β), Eq (f a) b → p b) (∀ (a : α), p (f a))","decl":"theorem forall_apply_eq_imp_iff' {f : α → β} {p : β → Prop} :\n    (∀ a b, f a = b → p b) ↔ ∀ a, p (f a) := by simp\n\n"}
{"name":"forall_eq_apply_imp_iff'","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\np : β → Prop\n⊢ Iff (∀ (a : α) (b : β), Eq b (f a) → p b) (∀ (a : α), p (f a))","decl":"theorem forall_eq_apply_imp_iff' {f : α → β} {p : β → Prop} :\n    (∀ a b, b = f a → p b) ↔ ∀ a, p (f a) := by simp\n\n"}
{"name":"exists₂_comm","module":"Mathlib.Logic.Basic","initialProofState":"ι₁ : Sort u_3\nι₂ : Sort u_4\nκ₁ : ι₁ → Sort u_5\nκ₂ : ι₂ → Sort u_6\np : (i₁ : ι₁) → κ₁ i₁ → (i₂ : ι₂) → κ₂ i₂ → Prop\n⊢ Iff (Exists fun i₁ => Exists fun j₁ => Exists fun i₂ => Exists fun j₂ => p i₁ j₁ i₂ j₂) (Exists fun i₂ => Exists fun j₂ => Exists fun i₁ => Exists fun j₁ => p i₁ j₁ i₂ j₂)","decl":"theorem exists₂_comm\n    {ι₁ ι₂ : Sort*} {κ₁ : ι₁ → Sort*} {κ₂ : ι₂ → Sort*} {p : ∀ i₁, κ₁ i₁ → ∀ i₂, κ₂ i₂ → Prop} :\n    (∃ i₁ j₁ i₂ j₂, p i₁ j₁ i₂ j₂) ↔ ∃ i₂ j₂ i₁ j₁, p i₁ j₁ i₂ j₂ := by\n  simp only [@exists_comm (κ₁ _), @exists_comm ι₁]\n\n"}
{"name":"And.exists","module":"Mathlib.Logic.Basic","initialProofState":"p q : Prop\nf : And p q → Prop\n⊢ Iff (Exists fun h => f h) (Exists fun hp => Exists fun hq => f ⋯)","decl":"theorem And.exists {p q : Prop} {f : p ∧ q → Prop} : (∃ h, f h) ↔ ∃ hp hq, f ⟨hp, hq⟩ :=\n  ⟨fun ⟨h, H⟩ ↦ ⟨h.1, h.2, H⟩, fun ⟨hp, hq, H⟩ ↦ ⟨⟨hp, hq⟩, H⟩⟩\n\n"}
{"name":"forall_or_of_or_forall","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_3\np : α → Prop\nb : Prop\nh : Or b (∀ (x : α), p x)\nx : α\n⊢ Or b (p x)","decl":"theorem forall_or_of_or_forall {α : Sort*} {p : α → Prop} {b : Prop} (h : b ∨ ∀ x, p x) (x : α) :\n    b ∨ p x :=\n  h.imp_right fun h₂ ↦ h₂ x\n\n-- See Note [decidable namespace]\n"}
{"name":"Decidable.forall_or_left","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nq : Prop\np : α → Prop\ninst✝ : Decidable q\n⊢ Iff (∀ (x : α), Or q (p x)) (Or q (∀ (x : α), p x))","decl":"protected theorem Decidable.forall_or_left {q : Prop} {p : α → Prop} [Decidable q] :\n    (∀ x, q ∨ p x) ↔ q ∨ ∀ x, p x :=\n  ⟨fun h ↦ if hq : q then Or.inl hq else\n    Or.inr fun x ↦ (h x).resolve_left hq, forall_or_of_or_forall⟩\n\n"}
{"name":"forall_or_left","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nq : Prop\np : α → Prop\n⊢ Iff (∀ (x : α), Or q (p x)) (Or q (∀ (x : α), p x))","decl":"theorem forall_or_left {q} {p : α → Prop} : (∀ x, q ∨ p x) ↔ q ∨ ∀ x, p x :=\n  Decidable.forall_or_left\n\n-- See Note [decidable namespace]\n"}
{"name":"Decidable.forall_or_right","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nq : Prop\np : α → Prop\ninst✝ : Decidable q\n⊢ Iff (∀ (x : α), Or (p x) q) (Or (∀ (x : α), p x) q)","decl":"protected theorem Decidable.forall_or_right {q} {p : α → Prop} [Decidable q] :\n    (∀ x, p x ∨ q) ↔ (∀ x, p x) ∨ q := by simp [or_comm, Decidable.forall_or_left]\n\n"}
{"name":"forall_or_right","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nq : Prop\np : α → Prop\n⊢ Iff (∀ (x : α), Or (p x) q) (Or (∀ (x : α), p x) q)","decl":"theorem forall_or_right {q} {p : α → Prop} : (∀ x, p x ∨ q) ↔ (∀ x, p x) ∨ q :=\n  Decidable.forall_or_right\n\n"}
{"name":"Exists.fst","module":"Mathlib.Logic.Basic","initialProofState":"b : Prop\np : b → Prop\na✝ : Exists p\n⊢ b","decl":"theorem Exists.fst {b : Prop} {p : b → Prop} : Exists p → b\n  | ⟨h, _⟩ => h\n\n"}
{"name":"Exists.snd","module":"Mathlib.Logic.Basic","initialProofState":"b : Prop\np : b → Prop\nh : Exists p\n⊢ p ⋯","decl":"theorem Exists.snd {b : Prop} {p : b → Prop} : ∀ h : Exists p, p h.fst\n  | ⟨_, h⟩ => h\n\n"}
{"name":"Prop.exists_iff","module":"Mathlib.Logic.Basic","initialProofState":"p : Prop → Prop\n⊢ Iff (Exists fun h => p h) (Or (p False) (p True))","decl":"theorem Prop.exists_iff {p : Prop → Prop} : (∃ h, p h) ↔ p False ∨ p True :=\n  ⟨fun ⟨h₁, h₂⟩ ↦ by_cases (fun H : h₁ ↦ .inr <| by simpa only [H] using h₂)\n    (fun H ↦ .inl <| by simpa only [H] using h₂), fun h ↦ h.elim (.intro _) (.intro _)⟩\n\n"}
{"name":"Prop.forall_iff","module":"Mathlib.Logic.Basic","initialProofState":"p : Prop → Prop\n⊢ Iff (∀ (h : Prop), p h) (And (p False) (p True))","decl":"theorem Prop.forall_iff {p : Prop → Prop} : (∀ h, p h) ↔ p False ∧ p True :=\n  ⟨fun H ↦ ⟨H _, H _⟩, fun ⟨h₁, h₂⟩ h ↦ by by_cases H : h <;> simpa only [H]⟩\n\n"}
{"name":"exists_iff_of_forall","module":"Mathlib.Logic.Basic","initialProofState":"p : Prop\nq : p → Prop\nh : ∀ (h : p), q h\n⊢ Iff (Exists fun h => q h) p","decl":"theorem exists_iff_of_forall {p : Prop} {q : p → Prop} (h : ∀ h, q h) : (∃ h, q h) ↔ p :=\n  ⟨Exists.fst, fun H ↦ ⟨H, h H⟩⟩\n\n"}
{"name":"exists_prop_of_false","module":"Mathlib.Logic.Basic","initialProofState":"p : Prop\nq : p → Prop\na✝ : Not p\n⊢ Not (Exists fun h' => q h')","decl":"theorem exists_prop_of_false {p : Prop} {q : p → Prop} : ¬p → ¬∃ h' : p, q h' :=\n  mt Exists.fst\n\n/- See `IsEmpty.exists_iff` for the `False` version of `exists_true_left`. -/\n\n-- Porting note: `@[congr]` commented out for now.\n-- @[congr]\n"}
{"name":"forall_prop_congr","module":"Mathlib.Logic.Basic","initialProofState":"p p' : Prop\nq q' : p → Prop\nhq : ∀ (h : p), Iff (q h) (q' h)\nhp : Iff p p'\n⊢ Iff (∀ (h : p), q h) (∀ (h : p'), q' ⋯)","decl":"theorem forall_prop_congr {p p' : Prop} {q q' : p → Prop} (hq : ∀ h, q h ↔ q' h) (hp : p ↔ p') :\n    (∀ h, q h) ↔ ∀ h : p', q' (hp.2 h) :=\n  ⟨fun h1 h2 ↦ (hq _).1 (h1 (hp.2 h2)), fun h1 h2 ↦ (hq _).2 (h1 (hp.1 h2))⟩\n\n-- Porting note: `@[congr]` commented out for now.\n-- @[congr]\n"}
{"name":"forall_prop_congr'","module":"Mathlib.Logic.Basic","initialProofState":"p p' : Prop\nq q' : p → Prop\nhq : ∀ (h : p), Iff (q h) (q' h)\nhp : Iff p p'\n⊢ Eq (∀ (h : p), q h) (∀ (h : p'), q' ⋯)","decl":"theorem forall_prop_congr' {p p' : Prop} {q q' : p → Prop} (hq : ∀ h, q h ↔ q' h) (hp : p ↔ p') :\n    (∀ h, q h) = ∀ h : p', q' (hp.2 h) :=\n  propext (forall_prop_congr hq hp)\n\n"}
{"name":"imp_congr_eq","module":"Mathlib.Logic.Basic","initialProofState":"a b c d : Prop\nh₁ : Eq a c\nh₂ : Eq b d\n⊢ Eq (a → b) (c → d)","decl":"lemma imp_congr_eq {a b c d : Prop} (h₁ : a = c) (h₂ : b = d) : (a → b) = (c → d) :=\n  propext (imp_congr h₁.to_iff h₂.to_iff)\n\n"}
{"name":"imp_congr_ctx_eq","module":"Mathlib.Logic.Basic","initialProofState":"a b c d : Prop\nh₁ : Eq a c\nh₂ : c → Eq b d\n⊢ Eq (a → b) (c → d)","decl":"lemma imp_congr_ctx_eq {a b c d : Prop} (h₁ : a = c) (h₂ : c → b = d) : (a → b) = (c → d) :=\n  propext (imp_congr_ctx h₁.to_iff fun hc ↦ (h₂ hc).to_iff)\n\n"}
{"name":"eq_true_intro","module":"Mathlib.Logic.Basic","initialProofState":"a : Prop\nh : a\n⊢ Eq a True","decl":"lemma eq_true_intro {a : Prop} (h : a) : a = True := propext (iff_true_intro h)\n\n"}
{"name":"eq_false_intro","module":"Mathlib.Logic.Basic","initialProofState":"a : Prop\nh : Not a\n⊢ Eq a False","decl":"lemma eq_false_intro {a : Prop} (h : ¬a) : a = False := propext (iff_false_intro h)\n\n-- FIXME: `alias` creates `def Iff.eq := propext` instead of `lemma Iff.eq := propext`\n"}
{"name":"iff_eq_eq","module":"Mathlib.Logic.Basic","initialProofState":"a b : Prop\n⊢ Eq (Iff a b) (Eq a b)","decl":"lemma iff_eq_eq {a b : Prop} : (a ↔ b) = (a = b) := propext ⟨propext, Eq.to_iff⟩\n\n-- They were not used in Lean 3 and there are already lemmas with those names in Lean 4\n\n"}
{"name":"forall_true_left","module":"Mathlib.Logic.Basic","initialProofState":"p : True → Prop\n⊢ Iff (∀ (x : True), p x) (p True.intro)","decl":"/-- See `IsEmpty.forall_iff` for the `False` version. -/\n@[simp] theorem forall_true_left (p : True → Prop) : (∀ x, p x) ↔ p True.intro :=\n  forall_prop_of_true _\n\n"}
{"name":"Classical.some_spec₂","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_2\np : α → Prop\nh : Exists fun a => p a\nq : α → Prop\nhpq : ∀ (a : α), p a → q a\n⊢ q (Classical.choose h)","decl":"theorem some_spec₂ {α : Sort*} {p : α → Prop} {h : ∃ a, p a} (q : α → Prop)\n    (hpq : ∀ a, p a → q a) : q (choose h) := hpq _ <| choose_spec _\n\n"}
{"name":"Classical.choose_eq","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\na : α\n⊢ Eq ⋯.choose a","decl":"@[simp] lemma choose_eq (a : α) : @Exists.choose _ (· = a) ⟨a, rfl⟩ = a := @choose_spec _ (· = a) _\n\n"}
{"name":"Classical.choose_eq'","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\na : α\n⊢ Eq ⋯.choose a","decl":"@[simp]\nlemma choose_eq' (a : α) : @Exists.choose _ (a = ·) ⟨a, rfl⟩ = a :=\n  (@choose_spec _ (a = ·) _).symm\n\n"}
{"name":"Classical.axiom_of_choice","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u\nβ : α → Sort v\nr : (x : α) → β x → Prop\nh : ∀ (x : α), Exists fun y => r x y\n⊢ Exists fun f => ∀ (x : α), r x (f x)","decl":"alias axiom_of_choice := axiomOfChoice -- TODO: remove? rename in core?\n"}
{"name":"Classical.by_cases","module":"Mathlib.Logic.Basic","initialProofState":"p q : Prop\nhpq : p → q\nhnpq : Not p → q\n⊢ q","decl":"alias by_cases := byCases -- TODO: remove? rename in core?\n"}
{"name":"Classical.by_contradiction","module":"Mathlib.Logic.Basic","initialProofState":"p : Prop\nh : Not p → False\n⊢ p","decl":"alias by_contradiction := byContradiction -- TODO: remove? rename in core?\n\n-- The remaining theorems in this section were ported from Lean 3,\n-- but are currently unused in Mathlib, so have been deprecated.\n-- If any are being used downstream, please remove the deprecation.\n\n"}
{"name":"Classical.prop_complete","module":"Mathlib.Logic.Basic","initialProofState":"a : Prop\n⊢ Or (Eq a True) (Eq a False)","decl":"alias prop_complete := propComplete -- TODO: remove? rename in core?\n\n"}
{"name":"bex_def","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\np q : α → Prop\n⊢ Iff (Exists fun x => Exists fun x_1 => q x) (Exists fun x => And (p x) (q x))","decl":"theorem bex_def : (∃ (x : _) (_ : p x), q x) ↔ ∃ x, p x ∧ q x :=\n  ⟨fun ⟨x, px, qx⟩ ↦ ⟨x, px, qx⟩, fun ⟨x, px, qx⟩ ↦ ⟨x, px, qx⟩⟩\n\n"}
{"name":"BEx.elim","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\np : α → Prop\nP : (x : α) → p x → Prop\nb : Prop\na✝¹ : Exists fun x => Exists fun h => P x h\na✝ : ∀ (a : α) (h : p a), P a h → b\n⊢ b","decl":"theorem BEx.elim {b : Prop} : (∃ x h, P x h) → (∀ a h, P a h → b) → b\n  | ⟨a, h₁, h₂⟩, h' => h' a h₁ h₂\n\n"}
{"name":"BEx.intro","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\np : α → Prop\nP : (x : α) → p x → Prop\na : α\nh₁ : p a\nh₂ : P a h₁\n⊢ Exists fun x => Exists fun h => P x h","decl":"theorem BEx.intro (a : α) (h₁ : p a) (h₂ : P a h₁) : ∃ (x : _) (h : p x), P x h :=\n  ⟨a, h₁, h₂⟩\n\n"}
{"name":"BAll.imp_right","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\np : α → Prop\nP Q : (x : α) → p x → Prop\nH : ∀ (x : α) (h : p x), P x h → Q x h\nh₁ : ∀ (x : α) (h : p x), P x h\nx : α\nh : p x\n⊢ Q x h","decl":"theorem BAll.imp_right (H : ∀ x h, P x h → Q x h) (h₁ : ∀ x h, P x h) (x h) : Q x h :=\n  H _ _ <| h₁ _ _\n\n"}
{"name":"BEx.imp_right","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\np : α → Prop\nP Q : (x : α) → p x → Prop\nH : ∀ (x : α) (h : p x), P x h → Q x h\na✝ : Exists fun x => Exists fun h => P x h\n⊢ Exists fun x => Exists fun h => Q x h","decl":"theorem BEx.imp_right (H : ∀ x h, P x h → Q x h) : (∃ x h, P x h) → ∃ x h, Q x h\n  | ⟨_, _, h'⟩ => ⟨_, _, H _ _ h'⟩\n\n"}
{"name":"BAll.imp_left","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nr p q : α → Prop\nH : ∀ (x : α), p x → q x\nh₁ : ∀ (x : α), q x → r x\nx : α\nh : p x\n⊢ r x","decl":"theorem BAll.imp_left (H : ∀ x, p x → q x) (h₁ : ∀ x, q x → r x) (x) (h : p x) : r x :=\n  h₁ _ <| H _ h\n\n"}
{"name":"BEx.imp_left","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nr p q : α → Prop\nH : ∀ (x : α), p x → q x\na✝ : Exists fun x => Exists fun x_1 => r x\n⊢ Exists fun x => Exists fun x_1 => r x","decl":"theorem BEx.imp_left (H : ∀ x, p x → q x) : (∃ (x : _) (_ : p x), r x) → ∃ (x : _) (_ : q x), r x\n  | ⟨x, hp, hr⟩ => ⟨x, H _ hp, hr⟩\n\n"}
{"name":"exists_mem_of_exists","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\np q : α → Prop\nH : ∀ (x : α), p x\na✝ : Exists fun x => q x\n⊢ Exists fun x => Exists fun x_1 => q x","decl":"theorem exists_mem_of_exists (H : ∀ x, p x) : (∃ x, q x) → ∃ (x : _) (_ : p x), q x\n  | ⟨x, hq⟩ => ⟨x, H x, hq⟩\n\n"}
{"name":"exists_of_exists_mem","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\np q : α → Prop\na✝ : Exists fun x => Exists fun x_1 => q x\n⊢ Exists fun x => q x","decl":"theorem exists_of_exists_mem : (∃ (x : _) (_ : p x), q x) → ∃ x, q x\n  | ⟨x, _, hq⟩ => ⟨x, hq⟩\n\n\n"}
{"name":"not_exists_mem","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\np : α → Prop\nP : (x : α) → p x → Prop\n⊢ Iff (Not (Exists fun x => Exists fun h => P x h)) (∀ (x : α) (h : p x), Not (P x h))","decl":"theorem not_exists_mem : (¬∃ x h, P x h) ↔ ∀ x h, ¬P x h := exists₂_imp\n\n"}
{"name":"not_forall₂_of_exists₂_not","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\np : α → Prop\nP : (x : α) → p x → Prop\na✝ : Exists fun x => Exists fun h => Not (P x h)\n⊢ Not (∀ (x : α) (h : p x), P x h)","decl":"theorem not_forall₂_of_exists₂_not : (∃ x h, ¬P x h) → ¬∀ x h, P x h\n  | ⟨x, h, hp⟩, al => hp <| al x h\n\n-- See Note [decidable namespace]\n"}
{"name":"Decidable.not_forall₂","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\np : α → Prop\nP : (x : α) → p x → Prop\ninst✝¹ : Decidable (Exists fun x => Exists fun h => Not (P x h))\ninst✝ : (x : α) → (h : p x) → Decidable (P x h)\n⊢ Iff (Not (∀ (x : α) (h : p x), P x h)) (Exists fun x => Exists fun h => Not (P x h))","decl":"protected theorem Decidable.not_forall₂ [Decidable (∃ x h, ¬P x h)] [∀ x h, Decidable (P x h)] :\n    (¬∀ x h, P x h) ↔ ∃ x h, ¬P x h :=\n  ⟨Not.decidable_imp_symm fun nx x h ↦ nx.decidable_imp_symm\n    fun h' ↦ ⟨x, h, h'⟩, not_forall₂_of_exists₂_not⟩\n\n"}
{"name":"not_forall₂","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\np : α → Prop\nP : (x : α) → p x → Prop\n⊢ Iff (Not (∀ (x : α) (h : p x), P x h)) (Exists fun x => Exists fun h => Not (P x h))","decl":"theorem not_forall₂ : (¬∀ x h, P x h) ↔ ∃ x h, ¬P x h := Decidable.not_forall₂\n\n"}
{"name":"forall₂_and","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\np : α → Prop\nP Q : (x : α) → p x → Prop\n⊢ Iff (∀ (x : α) (h : p x), And (P x h) (Q x h)) (And (∀ (x : α) (h : p x), P x h) (∀ (x : α) (h : p x), Q x h))","decl":"theorem forall₂_and : (∀ x h, P x h ∧ Q x h) ↔ (∀ x h, P x h) ∧ ∀ x h, Q x h :=\n  Iff.trans (forall_congr' fun _ ↦ forall_and) forall_and\n\n"}
{"name":"forall_and_left","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\ninst✝ : Nonempty α\nq : Prop\np : α → Prop\n⊢ Iff (∀ (x : α), And q (p x)) (And q (∀ (x : α), p x))","decl":"theorem forall_and_left [Nonempty α] (q : Prop) (p : α → Prop) :\n    (∀ x, q ∧ p x) ↔ (q ∧ ∀ x, p x) := by rw [forall_and, forall_const]\n\n"}
{"name":"forall_and_right","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\ninst✝ : Nonempty α\np : α → Prop\nq : Prop\n⊢ Iff (∀ (x : α), And (p x) q) (And (∀ (x : α), p x) q)","decl":"theorem forall_and_right [Nonempty α] (p : α → Prop) (q : Prop) :\n    (∀ x, p x ∧ q) ↔ (∀ x, p x) ∧ q := by rw [forall_and, forall_const]\n\n"}
{"name":"exists_mem_or","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\np : α → Prop\nP Q : (x : α) → p x → Prop\n⊢ Iff (Exists fun x => Exists fun h => Or (P x h) (Q x h)) (Or (Exists fun x => Exists fun h => P x h) (Exists fun x => Exists fun h => Q x h))","decl":"theorem exists_mem_or : (∃ x h, P x h ∨ Q x h) ↔ (∃ x h, P x h) ∨ ∃ x h, Q x h :=\n  Iff.trans (exists_congr fun _ ↦ exists_or) exists_or\n\n"}
{"name":"forall₂_or_left","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nr p q : α → Prop\n⊢ Iff (∀ (x : α), Or (p x) (q x) → r x) (And (∀ (x : α), p x → r x) (∀ (x : α), q x → r x))","decl":"theorem forall₂_or_left : (∀ x, p x ∨ q x → r x) ↔ (∀ x, p x → r x) ∧ ∀ x, q x → r x :=\n  Iff.trans (forall_congr' fun _ ↦ or_imp) forall_and\n\n"}
{"name":"exists_mem_or_left","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nr p q : α → Prop\n⊢ Iff (Exists fun x => Exists fun x_1 => r x) (Or (Exists fun x => Exists fun x_1 => r x) (Exists fun x => Exists fun x_1 => r x))","decl":"theorem exists_mem_or_left :\n    (∃ (x : _) (_ : p x ∨ q x), r x) ↔ (∃ (x : _) (_ : p x), r x) ∨ ∃ (x : _) (_ : q x), r x := by\n  simp only [exists_prop]\n  exact Iff.trans (exists_congr fun x ↦ or_and_right) exists_or\n\n"}
{"name":"dite_eq_iff","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : Prop\ninst✝ : Decidable P\nc : α\nA : P → α\nB : Not P → α\n⊢ Iff (Eq (dite P A B) c) (Or (Exists fun h => Eq (A h) c) (Exists fun h => Eq (B h) c))","decl":"theorem dite_eq_iff : dite P A B = c ↔ (∃ h, A h = c) ∨ ∃ h, B h = c := by\n  by_cases P <;> simp [*, exists_prop_of_true, exists_prop_of_false]\n\n"}
{"name":"ite_eq_iff","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : Prop\ninst✝ : Decidable P\na b c : α\n⊢ Iff (Eq (ite P a b) c) (Or (And P (Eq a c)) (And (Not P) (Eq b c)))","decl":"theorem ite_eq_iff : ite P a b = c ↔ P ∧ a = c ∨ ¬P ∧ b = c :=\n  dite_eq_iff.trans <| by rw [exists_prop, exists_prop]\n\n"}
{"name":"eq_ite_iff","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : Prop\ninst✝ : Decidable P\na b c : α\n⊢ Iff (Eq a (ite P b c)) (Or (And P (Eq a b)) (And (Not P) (Eq a c)))","decl":"theorem eq_ite_iff : a = ite P b c ↔ P ∧ a = b ∨ ¬P ∧ a = c :=\n  eq_comm.trans <| ite_eq_iff.trans <| (Iff.rfl.and eq_comm).or (Iff.rfl.and eq_comm)\n\n"}
{"name":"dite_eq_iff'","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : Prop\ninst✝ : Decidable P\nc : α\nA : P → α\nB : Not P → α\n⊢ Iff (Eq (dite P A B) c) (And (∀ (h : P), Eq (A h) c) (∀ (h : Not P), Eq (B h) c))","decl":"theorem dite_eq_iff' : dite P A B = c ↔ (∀ h, A h = c) ∧ ∀ h, B h = c :=\n  ⟨fun he ↦ ⟨fun h ↦ (dif_pos h).symm.trans he, fun h ↦ (dif_neg h).symm.trans he⟩, fun he ↦\n    (em P).elim (fun h ↦ (dif_pos h).trans <| he.1 h) fun h ↦ (dif_neg h).trans <| he.2 h⟩\n\n"}
{"name":"ite_eq_iff'","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : Prop\ninst✝ : Decidable P\na b c : α\n⊢ Iff (Eq (ite P a b) c) (And (P → Eq a c) (Not P → Eq b c))","decl":"theorem ite_eq_iff' : ite P a b = c ↔ (P → a = c) ∧ (¬P → b = c) := dite_eq_iff'\n\n"}
{"name":"dite_ne_left_iff","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : Prop\ninst✝ : Decidable P\na : α\nB : Not P → α\n⊢ Iff (Ne (dite P (fun x => a) B) a) (Exists fun h => Ne a (B h))","decl":"theorem dite_ne_left_iff : dite P (fun _ ↦ a) B ≠ a ↔ ∃ h, a ≠ B h := by\n  rw [Ne, dite_eq_left_iff, not_forall]\n  exact exists_congr fun h ↦ by rw [ne_comm]\n\n"}
{"name":"dite_ne_right_iff","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : Prop\ninst✝ : Decidable P\nb : α\nA : P → α\n⊢ Iff (Ne (dite P A fun x => b) b) (Exists fun h => Ne (A h) b)","decl":"theorem dite_ne_right_iff : (dite P A fun _ ↦ b) ≠ b ↔ ∃ h, A h ≠ b := by\n  simp only [Ne, dite_eq_right_iff, not_forall]\n\n"}
{"name":"ite_ne_left_iff","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : Prop\ninst✝ : Decidable P\na b : α\n⊢ Iff (Ne (ite P a b) a) (And (Not P) (Ne a b))","decl":"theorem ite_ne_left_iff : ite P a b ≠ a ↔ ¬P ∧ a ≠ b :=\n  dite_ne_left_iff.trans <| by rw [exists_prop]\n\n"}
{"name":"ite_ne_right_iff","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : Prop\ninst✝ : Decidable P\na b : α\n⊢ Iff (Ne (ite P a b) b) (And P (Ne a b))","decl":"theorem ite_ne_right_iff : ite P a b ≠ b ↔ P ∧ a ≠ b :=\n  dite_ne_right_iff.trans <| by rw [exists_prop]\n\n"}
{"name":"Ne.dite_eq_left_iff","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : Prop\ninst✝ : Decidable P\na : α\nB : Not P → α\nh : ∀ (h : Not P), Ne a (B h)\n⊢ Iff (Eq (dite P (fun x => a) B) a) P","decl":"protected theorem Ne.dite_eq_left_iff (h : ∀ h, a ≠ B h) : dite P (fun _ ↦ a) B = a ↔ P :=\n  dite_eq_left_iff.trans ⟨fun H ↦ of_not_not fun h' ↦ h h' (H h').symm, fun h H ↦ (H h).elim⟩\n\n"}
{"name":"Ne.dite_eq_right_iff","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : Prop\ninst✝ : Decidable P\nb : α\nA : P → α\nh : ∀ (h : P), Ne (A h) b\n⊢ Iff (Eq (dite P A fun x => b) b) (Not P)","decl":"protected theorem Ne.dite_eq_right_iff (h : ∀ h, A h ≠ b) : (dite P A fun _ ↦ b) = b ↔ ¬P :=\n  dite_eq_right_iff.trans ⟨fun H h' ↦ h h' (H h'), fun h' H ↦ (h' H).elim⟩\n\n"}
{"name":"Ne.ite_eq_left_iff","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : Prop\ninst✝ : Decidable P\na b : α\nh : Ne a b\n⊢ Iff (Eq (ite P a b) a) P","decl":"protected theorem Ne.ite_eq_left_iff (h : a ≠ b) : ite P a b = a ↔ P :=\n  Ne.dite_eq_left_iff fun _ ↦ h\n\n"}
{"name":"Ne.ite_eq_right_iff","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : Prop\ninst✝ : Decidable P\na b : α\nh : Ne a b\n⊢ Iff (Eq (ite P a b) b) (Not P)","decl":"protected theorem Ne.ite_eq_right_iff (h : a ≠ b) : ite P a b = b ↔ ¬P :=\n  Ne.dite_eq_right_iff fun _ ↦ h\n\n"}
{"name":"Ne.dite_ne_left_iff","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : Prop\ninst✝ : Decidable P\na : α\nB : Not P → α\nh : ∀ (h : Not P), Ne a (B h)\n⊢ Iff (Ne (dite P (fun x => a) B) a) (Not P)","decl":"protected theorem Ne.dite_ne_left_iff (h : ∀ h, a ≠ B h) : dite P (fun _ ↦ a) B ≠ a ↔ ¬P :=\n  dite_ne_left_iff.trans <| exists_iff_of_forall h\n\n"}
{"name":"Ne.dite_ne_right_iff","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : Prop\ninst✝ : Decidable P\nb : α\nA : P → α\nh : ∀ (h : P), Ne (A h) b\n⊢ Iff (Ne (dite P A fun x => b) b) P","decl":"protected theorem Ne.dite_ne_right_iff (h : ∀ h, A h ≠ b) : (dite P A fun _ ↦ b) ≠ b ↔ P :=\n  dite_ne_right_iff.trans <| exists_iff_of_forall h\n\n"}
{"name":"Ne.ite_ne_left_iff","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : Prop\ninst✝ : Decidable P\na b : α\nh : Ne a b\n⊢ Iff (Ne (ite P a b) a) (Not P)","decl":"protected theorem Ne.ite_ne_left_iff (h : a ≠ b) : ite P a b ≠ a ↔ ¬P :=\n  Ne.dite_ne_left_iff fun _ ↦ h\n\n"}
{"name":"Ne.ite_ne_right_iff","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : Prop\ninst✝ : Decidable P\na b : α\nh : Ne a b\n⊢ Iff (Ne (ite P a b) b) P","decl":"protected theorem Ne.ite_ne_right_iff (h : a ≠ b) : ite P a b ≠ b ↔ P :=\n  Ne.dite_ne_right_iff fun _ ↦ h\n\n"}
{"name":"dite_eq_or_eq","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : Prop\ninst✝ : Decidable P\nA : P → α\nB : Not P → α\n⊢ Or (Exists fun h => Eq (dite P A B) (A h)) (Exists fun h => Eq (dite P A B) (B h))","decl":"theorem dite_eq_or_eq : (∃ h, dite P A B = A h) ∨ ∃ h, dite P A B = B h :=\n  if h : _ then .inl ⟨h, dif_pos h⟩ else .inr ⟨h, dif_neg h⟩\n\n"}
{"name":"ite_eq_or_eq","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP : Prop\ninst✝ : Decidable P\na b : α\n⊢ Or (Eq (ite P a b) a) (Eq (ite P a b) b)","decl":"theorem ite_eq_or_eq : ite P a b = a ∨ ite P a b = b :=\n  if h : _ then .inl (if_pos h) else .inr (if_neg h)\n\n"}
{"name":"apply_dite₂","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_3\nβ : Sort u_4\nγ : Sort u_5\nf : α → β → γ\nP : Prop\ninst✝ : Decidable P\na : P → α\nb : Not P → α\nc : P → β\nd : Not P → β\n⊢ Eq (f (dite P a b) (dite P c d)) (dite P (fun h => f (a h) (c h)) fun h => f (b h) (d h))","decl":"/-- A two-argument function applied to two `dite`s is a `dite` of that two-argument function\napplied to each of the branches. -/\ntheorem apply_dite₂ {α β γ : Sort*} (f : α → β → γ) (P : Prop) [Decidable P]\n    (a : P → α) (b : ¬P → α) (c : P → β) (d : ¬P → β) :\n    f (dite P a b) (dite P c d) = dite P (fun h ↦ f (a h) (c h)) fun h ↦ f (b h) (d h) := by\n  by_cases h : P <;> simp [h]\n\n"}
{"name":"apply_ite₂","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_3\nβ : Sort u_4\nγ : Sort u_5\nf : α → β → γ\nP : Prop\ninst✝ : Decidable P\na b : α\nc d : β\n⊢ Eq (f (ite P a b) (ite P c d)) (ite P (f a c) (f b d))","decl":"/-- A two-argument function applied to two `ite`s is a `ite` of that two-argument function\napplied to each of the branches. -/\ntheorem apply_ite₂ {α β γ : Sort*} (f : α → β → γ) (P : Prop) [Decidable P] (a b : α) (c d : β) :\n    f (ite P a b) (ite P c d) = ite P (f a c) (f b d) :=\n  apply_dite₂ f P (fun _ ↦ a) (fun _ ↦ b) (fun _ ↦ c) fun _ ↦ d\n\n"}
{"name":"dite_apply","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nσ : α → Sort u_2\nP : Prop\ninst✝ : Decidable P\nf : P → (a : α) → σ a\ng : Not P → (a : α) → σ a\na : α\n⊢ Eq (dite P f g a) (dite P (fun h => f h a) fun h => g h a)","decl":"/-- A 'dite' producing a `Pi` type `Π a, σ a`, applied to a value `a : α` is a `dite` that applies\neither branch to `a`. -/\ntheorem dite_apply (f : P → ∀ a, σ a) (g : ¬P → ∀ a, σ a) (a : α) :\n    (dite P f g) a = dite P (fun h ↦ f h a) fun h ↦ g h a := by by_cases h : P <;> simp [h]\n\n"}
{"name":"ite_apply","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nσ : α → Sort u_2\nP : Prop\ninst✝ : Decidable P\nf g : (a : α) → σ a\na : α\n⊢ Eq (ite P f g a) (ite P (f a) (g a))","decl":"/-- A 'ite' producing a `Pi` type `Π a, σ a`, applied to a value `a : α` is a `ite` that applies\neither branch to `a`. -/\ntheorem ite_apply (f g : ∀ a, σ a) (a : α) : (ite P f g) a = ite P (f a) (g a) :=\n  dite_apply P (fun _ ↦ f) (fun _ ↦ g) a\n\n"}
{"name":"ite_and","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP Q : Prop\ninst✝¹ : Decidable P\na b : α\ninst✝ : Decidable Q\n⊢ Eq (ite (And P Q) a b) (ite P (ite Q a b) b)","decl":"theorem ite_and : ite (P ∧ Q) a b = ite P (ite Q a b) b := by\n  by_cases hp : P <;> by_cases hq : Q <;> simp [hp, hq]\n\n"}
{"name":"ite_or","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP Q : Prop\ninst✝¹ : Decidable P\na b : α\ninst✝ : Decidable Q\n⊢ Eq (ite (Or P Q) a b) (ite P a (ite Q a b))","decl":"theorem ite_or : ite (P ∨ Q) a b = ite P a (ite Q a b) := by\n  by_cases hp : P <;> by_cases hq : Q <;> simp [hp, hq]\n\n"}
{"name":"dite_dite_comm","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP Q : Prop\ninst✝¹ : Decidable P\nA : P → α\ninst✝ : Decidable Q\nB : Q → α\nC : Not P → Not Q → α\nh : P → Not Q\n⊢ Eq (dite P (fun p => A p) fun p => dite Q (fun q => B q) fun q => C p q) (dite Q (fun q => B q) fun q => dite P (fun p => A p) fun p => C p q)","decl":"theorem dite_dite_comm {B : Q → α} {C : ¬P → ¬Q → α} (h : P → ¬Q) :\n    (if p : P then A p else if q : Q then B q else C p q) =\n     if q : Q then B q else if p : P then A p else C p q :=\n  dite_eq_iff'.2 ⟨\n    fun p ↦ by rw [dif_neg (h p), dif_pos p],\n    fun np ↦ by congr; funext _; rw [dif_neg np]⟩\n\n"}
{"name":"ite_ite_comm","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP Q : Prop\ninst✝¹ : Decidable P\na b c : α\ninst✝ : Decidable Q\nh : P → Not Q\n⊢ Eq (ite P a (ite Q b c)) (ite Q b (ite P a c))","decl":"theorem ite_ite_comm (h : P → ¬Q) :\n    (if P then a else if Q then b else c) =\n     if Q then b else if P then a else c :=\n  dite_dite_comm P Q h\n\n"}
{"name":"ite_prop_iff_or","module":"Mathlib.Logic.Basic","initialProofState":"P Q R : Prop\ninst✝ : Decidable P\n⊢ Iff (ite P Q R) (Or (And P Q) (And (Not P) R))","decl":"theorem ite_prop_iff_or : (if P then Q else R) ↔ (P ∧ Q ∨ ¬ P ∧ R) := by\n  by_cases p : P <;> simp [p]\n\n"}
{"name":"dite_prop_iff_or","module":"Mathlib.Logic.Basic","initialProofState":"P : Prop\ninst✝ : Decidable P\nQ : P → Prop\nR : Not P → Prop\n⊢ Iff (dite P Q R) (Or (Exists fun p => Q p) (Exists fun p => R p))","decl":"theorem dite_prop_iff_or {Q : P → Prop} {R : ¬P → Prop} :\n    dite P Q R ↔ (∃ p, Q p) ∨ (∃ p, R p) := by\n  by_cases h : P <;> simp [h, exists_prop_of_false, exists_prop_of_true]\n\n-- TODO make this a simp lemma in a future PR\n"}
{"name":"ite_prop_iff_and","module":"Mathlib.Logic.Basic","initialProofState":"P Q R : Prop\ninst✝ : Decidable P\n⊢ Iff (ite P Q R) (And (P → Q) (Not P → R))","decl":"theorem ite_prop_iff_and : (if P then Q else R) ↔ ((P → Q) ∧ (¬ P → R)) := by\n  by_cases p : P <;> simp [p]\n\n"}
{"name":"dite_prop_iff_and","module":"Mathlib.Logic.Basic","initialProofState":"P : Prop\ninst✝ : Decidable P\nQ : P → Prop\nR : Not P → Prop\n⊢ Iff (dite P Q R) (And (∀ (h : P), Q h) (∀ (h : Not P), R h))","decl":"theorem dite_prop_iff_and {Q : P → Prop} {R : ¬P → Prop} :\n    dite P Q R ↔ (∀ h, Q h) ∧ (∀ h, R h) := by\n  by_cases h : P <;> simp [h, forall_prop_of_false, forall_prop_of_true]\n\n"}
{"name":"if_ctx_congr","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP Q : Prop\ninst✝¹ : Decidable P\ninst✝ : Decidable Q\nx y u v : α\nh_c : Iff P Q\nh_t : Q → Eq x u\nh_e : Not Q → Eq y v\n⊢ Eq (ite P x y) (ite Q u v)","decl":"theorem if_ctx_congr (h_c : P ↔ Q) (h_t : Q → x = u) (h_e : ¬Q → y = v) : ite P x y = ite Q u v :=\n  match ‹Decidable P›, ‹Decidable Q› with\n  | isFalse _,  isFalse h₂ => by simp_all\n  | isTrue _,   isTrue h₂  => by simp_all\n  | isFalse h₁, isTrue h₂  => absurd h₂ (Iff.mp (not_congr h_c) h₁)\n  | isTrue h₁,  isFalse h₂ => absurd h₁ (Iff.mpr (not_congr h_c) h₂)\n\n"}
{"name":"if_congr","module":"Mathlib.Logic.Basic","initialProofState":"α : Sort u_1\nP Q : Prop\ninst✝¹ : Decidable P\ninst✝ : Decidable Q\nx y u v : α\nh_c : Iff P Q\nh_t : Eq x u\nh_e : Eq y v\n⊢ Eq (ite P x y) (ite Q u v)","decl":"theorem if_congr (h_c : P ↔ Q) (h_t : x = u) (h_e : y = v) : ite P x y = ite Q u v :=\n  if_ctx_congr h_c (fun _ ↦ h_t) (fun _ ↦ h_e)\n\n"}
{"name":"not_beq_of_ne","module":"Mathlib.Logic.Basic","initialProofState":"α : Type u_1\ninst✝¹ : BEq α\ninst✝ : LawfulBEq α\na b : α\nne : Ne a b\n⊢ Not (Eq (BEq.beq a b) Bool.true)","decl":"theorem not_beq_of_ne {α : Type*} [BEq α] [LawfulBEq α] {a b : α} (ne : a ≠ b) : ¬(a == b) :=\n  fun h => ne (eq_of_beq h)\n\n"}
{"name":"beq_eq_decide","module":"Mathlib.Logic.Basic","initialProofState":"α : Type u_1\ninst✝¹ : BEq α\ninst✝ : LawfulBEq α\na b : α\n⊢ Eq (BEq.beq a b) (Decidable.decide (Eq a b))","decl":"theorem beq_eq_decide {α : Type*} [BEq α] [LawfulBEq α] {a b : α} : (a == b) = decide (a = b) := by\n  rw [← beq_iff_eq (a := a) (b := b)]\n  cases a == b <;> simp\n\n"}
{"name":"beq_eq_beq","module":"Mathlib.Logic.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : BEq α\ninst✝² : LawfulBEq α\ninst✝¹ : BEq β\ninst✝ : LawfulBEq β\na₁ a₂ : α\nb₁ b₂ : β\n⊢ Iff (Eq (BEq.beq a₁ a₂) (BEq.beq b₁ b₂)) (Iff (Eq a₁ a₂) (Eq b₁ b₂))","decl":"@[simp] lemma beq_eq_beq {α β : Type*} [BEq α] [LawfulBEq α] [BEq β] [LawfulBEq β] {a₁ a₂ : α}\n    {b₁ b₂ : β} : (a₁ == a₂) = (b₁ == b₂) ↔ (a₁ = a₂ ↔ b₁ = b₂) := by rw [Bool.eq_iff_iff]; simp\n\n"}
{"name":"beq_ext_iff","module":"Mathlib.Logic.Basic","initialProofState":"α : Type u_1\ninst1 inst2 : BEq α\n⊢ Iff (Eq inst1 inst2) (∀ (x y : α), Eq (BEq.beq x y) (BEq.beq x y))","decl":"@[ext]\ntheorem beq_ext {α : Type*} (inst1 : BEq α) (inst2 : BEq α)\n    (h : ∀ x y, @BEq.beq _ inst1 x y = @BEq.beq _ inst2 x y) :\n    inst1 = inst2 := by\n  have ⟨beq1⟩ := inst1\n  have ⟨beq2⟩ := inst2\n  congr\n  funext x y\n  exact h x y\n\n"}
{"name":"beq_ext","module":"Mathlib.Logic.Basic","initialProofState":"α : Type u_1\ninst1 inst2 : BEq α\nh : ∀ (x y : α), Eq (BEq.beq x y) (BEq.beq x y)\n⊢ Eq inst1 inst2","decl":"@[ext]\ntheorem beq_ext {α : Type*} (inst1 : BEq α) (inst2 : BEq α)\n    (h : ∀ x y, @BEq.beq _ inst1 x y = @BEq.beq _ inst2 x y) :\n    inst1 = inst2 := by\n  have ⟨beq1⟩ := inst1\n  have ⟨beq2⟩ := inst2\n  congr\n  funext x y\n  exact h x y\n\n"}
{"name":"lawful_beq_subsingleton","module":"Mathlib.Logic.Basic","initialProofState":"α : Type u_1\ninst1 inst2 : BEq α\ninst✝¹ : LawfulBEq α\ninst✝ : LawfulBEq α\n⊢ Eq inst1 inst2","decl":"theorem lawful_beq_subsingleton {α : Type*} (inst1 : BEq α) (inst2 : BEq α)\n    [@LawfulBEq α inst1] [@LawfulBEq α inst2] :\n    inst1 = inst2 := by\n  apply beq_ext\n  intro x y\n  simp only [beq_eq_decide]\n"}
