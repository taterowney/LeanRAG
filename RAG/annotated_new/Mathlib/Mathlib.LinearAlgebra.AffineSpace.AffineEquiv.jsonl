{"name":"AffineEquiv.map_vadd'","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_4\nV₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nself : AffineEquiv k P₁ P₂\np : P₁\nv : V₁\n⊢ Eq (self.toEquiv (HVAdd.hVAdd v p)) (HVAdd.hVAdd (self.linear v) (self.toEquiv p))","decl":"/-- An affine equivalence, denoted `P₁ ≃ᵃ[k] P₂`, is an equivalence between affine spaces\nsuch that both forward and inverse maps are affine.\n\nWe define it using an `Equiv` for the map and a `LinearEquiv` for the linear part in order\nto allow affine equivalences with good definitional equalities. -/\nstructure AffineEquiv (k P₁ P₂ : Type*) {V₁ V₂ : Type*} [Ring k] [AddCommGroup V₁] [Module k V₁]\n  [AddTorsor V₁ P₁] [AddCommGroup V₂] [Module k V₂] [AddTorsor V₂ P₂] extends P₁ ≃ P₂ where\n  linear : V₁ ≃ₗ[k] V₂\n  map_vadd' : ∀ (p : P₁) (v : V₁), toEquiv (v +ᵥ p) = linear v +ᵥ toEquiv p\n\n"}
{"name":"AffineEquiv.mk.injEq","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_4\nV₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ntoEquiv✝ : Equiv P₁ P₂\nlinear✝ : LinearEquiv (RingHom.id k) V₁ V₂\nmap_vadd'✝ : ∀ (p : P₁) (v : V₁), Eq (toEquiv✝ (HVAdd.hVAdd v p)) (HVAdd.hVAdd (linear✝ v) (toEquiv✝ p))\ntoEquiv : Equiv P₁ P₂\nlinear : LinearEquiv (RingHom.id k) V₁ V₂\nmap_vadd' : ∀ (p : P₁) (v : V₁), Eq (toEquiv (HVAdd.hVAdd v p)) (HVAdd.hVAdd (linear v) (toEquiv p))\n⊢ Eq (Eq { toEquiv := toEquiv✝, linear := linear✝, map_vadd' := map_vadd'✝ } { toEquiv := toEquiv, linear := linear, map_vadd' := map_vadd' }) (And (Eq toEquiv✝ toEquiv) (Eq linear✝ linear))","decl":"/-- An affine equivalence, denoted `P₁ ≃ᵃ[k] P₂`, is an equivalence between affine spaces\nsuch that both forward and inverse maps are affine.\n\nWe define it using an `Equiv` for the map and a `LinearEquiv` for the linear part in order\nto allow affine equivalences with good definitional equalities. -/\nstructure AffineEquiv (k P₁ P₂ : Type*) {V₁ V₂ : Type*} [Ring k] [AddCommGroup V₁] [Module k V₁]\n  [AddTorsor V₁ P₁] [AddCommGroup V₂] [Module k V₂] [AddTorsor V₂ P₂] extends P₁ ≃ P₂ where\n  linear : V₁ ≃ₗ[k] V₂\n  map_vadd' : ∀ (p : P₁) (v : V₁), toEquiv (v +ᵥ p) = linear v +ᵥ toEquiv p\n\n"}
{"name":"AffineEquiv.mk.inj","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_4\nV₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ntoEquiv✝ : Equiv P₁ P₂\nlinear✝ : LinearEquiv (RingHom.id k) V₁ V₂\nmap_vadd'✝ : ∀ (p : P₁) (v : V₁), Eq (toEquiv✝ (HVAdd.hVAdd v p)) (HVAdd.hVAdd (linear✝ v) (toEquiv✝ p))\ntoEquiv : Equiv P₁ P₂\nlinear : LinearEquiv (RingHom.id k) V₁ V₂\nmap_vadd' : ∀ (p : P₁) (v : V₁), Eq (toEquiv (HVAdd.hVAdd v p)) (HVAdd.hVAdd (linear v) (toEquiv p))\nx✝ : Eq { toEquiv := toEquiv✝, linear := linear✝, map_vadd' := map_vadd'✝ } { toEquiv := toEquiv, linear := linear, map_vadd' := map_vadd' }\n⊢ And (Eq toEquiv✝ toEquiv) (Eq linear✝ linear)","decl":"/-- An affine equivalence, denoted `P₁ ≃ᵃ[k] P₂`, is an equivalence between affine spaces\nsuch that both forward and inverse maps are affine.\n\nWe define it using an `Equiv` for the map and a `LinearEquiv` for the linear part in order\nto allow affine equivalences with good definitional equalities. -/\nstructure AffineEquiv (k P₁ P₂ : Type*) {V₁ V₂ : Type*} [Ring k] [AddCommGroup V₁] [Module k V₁]\n  [AddTorsor V₁ P₁] [AddCommGroup V₂] [Module k V₂] [AddTorsor V₂ P₂] extends P₁ ≃ P₂ where\n  linear : V₁ ≃ₗ[k] V₂\n  map_vadd' : ∀ (p : P₁) (v : V₁), toEquiv (v +ᵥ p) = linear v +ᵥ toEquiv p\n\n"}
{"name":"AffineEquiv.mk.sizeOf_spec","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_4\nV₂ : Type u_5\ninst✝¹¹ : Ring k\ninst✝¹⁰ : AddCommGroup V₁\ninst✝⁹ : Module k V₁\ninst✝⁸ : AddTorsor V₁ P₁\ninst✝⁷ : AddCommGroup V₂\ninst✝⁶ : Module k V₂\ninst✝⁵ : AddTorsor V₂ P₂\ninst✝⁴ : SizeOf k\ninst✝³ : SizeOf P₁\ninst✝² : SizeOf P₂\ninst✝¹ : SizeOf V₁\ninst✝ : SizeOf V₂\ntoEquiv : Equiv P₁ P₂\nlinear : LinearEquiv (RingHom.id k) V₁ V₂\nmap_vadd' : ∀ (p : P₁) (v : V₁), Eq (toEquiv (HVAdd.hVAdd v p)) (HVAdd.hVAdd (linear v) (toEquiv p))\n⊢ Eq (SizeOf.sizeOf { toEquiv := toEquiv, linear := linear, map_vadd' := map_vadd' }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toEquiv)) (SizeOf.sizeOf linear))","decl":"/-- An affine equivalence, denoted `P₁ ≃ᵃ[k] P₂`, is an equivalence between affine spaces\nsuch that both forward and inverse maps are affine.\n\nWe define it using an `Equiv` for the map and a `LinearEquiv` for the linear part in order\nto allow affine equivalences with good definitional equalities. -/\nstructure AffineEquiv (k P₁ P₂ : Type*) {V₁ V₂ : Type*} [Ring k] [AddCommGroup V₁] [Module k V₁]\n  [AddTorsor V₁ P₁] [AddCommGroup V₂] [Module k V₂] [AddTorsor V₂ P₂] extends P₁ ≃ P₂ where\n  linear : V₁ ≃ₗ[k] V₂\n  map_vadd' : ∀ (p : P₁) (v : V₁), toEquiv (v +ᵥ p) = linear v +ᵥ toEquiv p\n\n"}
{"name":"AffineEquiv.toAffineMap_mk","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : Equiv P₁ P₂\nf' : LinearEquiv (RingHom.id k) V₁ V₂\nh : ∀ (p : P₁) (v : V₁), Eq (f (HVAdd.hVAdd v p)) (HVAdd.hVAdd (f' v) (f p))\n⊢ Eq ↑{ toEquiv := f, linear := f', map_vadd' := h } { toFun := ⇑f, linear := ↑f', map_vadd' := h }","decl":"@[simp]\ntheorem toAffineMap_mk (f : P₁ ≃ P₂) (f' : V₁ ≃ₗ[k] V₂) (h) :\n    toAffineMap (mk f f' h) = ⟨f, f', h⟩ :=\n  rfl\n\n"}
{"name":"AffineEquiv.linear_toAffineMap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\n⊢ Eq (↑e).linear ↑e.linear","decl":"@[simp]\ntheorem linear_toAffineMap (e : P₁ ≃ᵃ[k] P₂) : e.toAffineMap.linear = e.linear :=\n  rfl\n\n"}
{"name":"AffineEquiv.toAffineMap_injective","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\n⊢ Function.Injective AffineEquiv.toAffineMap","decl":"theorem toAffineMap_injective : Injective (toAffineMap : (P₁ ≃ᵃ[k] P₂) → P₁ →ᵃ[k] P₂) := by\n  rintro ⟨e, el, h⟩ ⟨e', el', h'⟩ H\n  -- Porting note: added `AffineMap.mk.injEq`\n  simp only [toAffineMap_mk, AffineMap.mk.injEq, Equiv.coe_inj,\n    LinearEquiv.toLinearMap_inj] at H\n  congr\n  exacts [H.1, H.2]\n\n"}
{"name":"AffineEquiv.toAffineMap_inj","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne e' : AffineEquiv k P₁ P₂\n⊢ Iff (Eq ↑e ↑e') (Eq e e')","decl":"@[simp]\ntheorem toAffineMap_inj {e e' : P₁ ≃ᵃ[k] P₂} : e.toAffineMap = e'.toAffineMap ↔ e = e' :=\n  toAffineMap_injective.eq_iff\n\n"}
{"name":"AffineEquiv.map_vadd","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\np : P₁\nv : V₁\n⊢ Eq (e (HVAdd.hVAdd v p)) (HVAdd.hVAdd (e.linear v) (e p))","decl":"@[simp]\ntheorem map_vadd (e : P₁ ≃ᵃ[k] P₂) (p : P₁) (v : V₁) : e (v +ᵥ p) = e.linear v +ᵥ e p :=\n  e.map_vadd' p v\n\n"}
{"name":"AffineEquiv.coe_toEquiv","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\n⊢ Eq ⇑e.toEquiv ⇑e","decl":"@[simp]\ntheorem coe_toEquiv (e : P₁ ≃ᵃ[k] P₂) : ⇑e.toEquiv = e :=\n  rfl\n\n"}
{"name":"AffineEquiv.coe_toAffineMap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\n⊢ Eq ⇑↑e ⇑e","decl":"@[simp]\ntheorem coe_toAffineMap (e : P₁ ≃ᵃ[k] P₂) : (e.toAffineMap : P₁ → P₂) = (e : P₁ → P₂) :=\n  rfl\n\n"}
{"name":"AffineEquiv.coe_coe","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\n⊢ Eq ⇑↑e ⇑e","decl":"@[norm_cast, simp]\ntheorem coe_coe (e : P₁ ≃ᵃ[k] P₂) : ((e : P₁ →ᵃ[k] P₂) : P₁ → P₂) = e :=\n  rfl\n\n"}
{"name":"AffineEquiv.coe_linear","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\n⊢ Eq (↑e).linear ↑e.linear","decl":"@[simp]\ntheorem coe_linear (e : P₁ ≃ᵃ[k] P₂) : (e : P₁ →ᵃ[k] P₂).linear = e.linear :=\n  rfl\n\n"}
{"name":"AffineEquiv.ext_iff","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne e' : AffineEquiv k P₁ P₂\n⊢ Iff (Eq e e') (∀ (x : P₁), Eq (e x) (e' x))","decl":"@[ext]\ntheorem ext {e e' : P₁ ≃ᵃ[k] P₂} (h : ∀ x, e x = e' x) : e = e' :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"AffineEquiv.ext","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne e' : AffineEquiv k P₁ P₂\nh : ∀ (x : P₁), Eq (e x) (e' x)\n⊢ Eq e e'","decl":"@[ext]\ntheorem ext {e e' : P₁ ≃ᵃ[k] P₂} (h : ∀ x, e x = e' x) : e = e' :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"AffineEquiv.coeFn_injective","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\n⊢ Function.Injective DFunLike.coe","decl":"theorem coeFn_injective : @Injective (P₁ ≃ᵃ[k] P₂) (P₁ → P₂) (⇑) :=\n  DFunLike.coe_injective\n\n"}
{"name":"AffineEquiv.coeFn_inj","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne e' : AffineEquiv k P₁ P₂\n⊢ Iff (Eq ⇑e ⇑e') (Eq e e')","decl":"@[norm_cast]\n-- Porting note: removed `simp`: proof is `simp only [DFunLike.coe_fn_eq]`\ntheorem coeFn_inj {e e' : P₁ ≃ᵃ[k] P₂} : (e : P₁ → P₂) = e' ↔ e = e' :=\n  coeFn_injective.eq_iff\n\n"}
{"name":"AffineEquiv.toEquiv_injective","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\n⊢ Function.Injective AffineEquiv.toEquiv","decl":"theorem toEquiv_injective : Injective (toEquiv : (P₁ ≃ᵃ[k] P₂) → P₁ ≃ P₂) := fun _ _ H =>\n  ext <| Equiv.ext_iff.1 H\n\n"}
{"name":"AffineEquiv.toEquiv_inj","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne e' : AffineEquiv k P₁ P₂\n⊢ Iff (Eq e.toEquiv e'.toEquiv) (Eq e e')","decl":"@[simp]\ntheorem toEquiv_inj {e e' : P₁ ≃ᵃ[k] P₂} : e.toEquiv = e'.toEquiv ↔ e = e' :=\n  toEquiv_injective.eq_iff\n\n"}
{"name":"AffineEquiv.coe_mk","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : Equiv P₁ P₂\ne' : LinearEquiv (RingHom.id k) V₁ V₂\nh : ∀ (p : P₁) (v : V₁), Eq (e (HVAdd.hVAdd v p)) (HVAdd.hVAdd (e' v) (e p))\n⊢ Eq ⇑{ toEquiv := e, linear := e', map_vadd' := h } ⇑e","decl":"@[simp]\ntheorem coe_mk (e : P₁ ≃ P₂) (e' : V₁ ≃ₗ[k] V₂) (h) : ((⟨e, e', h⟩ : P₁ ≃ᵃ[k] P₂) : P₁ → P₂) = e :=\n  rfl\n\n"}
{"name":"AffineEquiv.coe_mk'","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : Equiv P₁ P₂\ne' : LinearEquiv (RingHom.id k) V₁ V₂\np : P₁\nh : ∀ (p' : P₁), Eq (e p') (HVAdd.hVAdd (e' (VSub.vsub p' p)) (e p))\n⊢ Eq ⇑(AffineEquiv.mk' (⇑e) e' p h) ⇑e","decl":"@[simp]\ntheorem coe_mk' (e : P₁ ≃ P₂) (e' : V₁ ≃ₗ[k] V₂) (p h) : ⇑(mk' e e' p h) = e :=\n  rfl\n\n"}
{"name":"AffineEquiv.linear_mk'","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : Equiv P₁ P₂\ne' : LinearEquiv (RingHom.id k) V₁ V₂\np : P₁\nh : ∀ (p' : P₁), Eq (e p') (HVAdd.hVAdd (e' (VSub.vsub p' p)) (e p))\n⊢ Eq (AffineEquiv.mk' (⇑e) e' p h).linear e'","decl":"@[simp]\ntheorem linear_mk' (e : P₁ ≃ P₂) (e' : V₁ ≃ₗ[k] V₂) (p h) : (mk' e e' p h).linear = e' :=\n  rfl\n\n"}
{"name":"AffineEquiv.symm_toEquiv","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\n⊢ Eq e.symm e.symm.toEquiv","decl":"@[simp]\ntheorem symm_toEquiv (e : P₁ ≃ᵃ[k] P₂) : e.toEquiv.symm = e.symm.toEquiv :=\n  rfl\n\n"}
{"name":"AffineEquiv.symm_linear","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\n⊢ Eq e.linear.symm e.symm.linear","decl":"@[simp]\ntheorem symm_linear (e : P₁ ≃ᵃ[k] P₂) : e.linear.symm = e.symm.linear :=\n  rfl\n\n"}
{"name":"AffineEquiv.bijective","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\n⊢ Function.Bijective ⇑e","decl":"protected theorem bijective (e : P₁ ≃ᵃ[k] P₂) : Bijective e :=\n  e.toEquiv.bijective\n\n"}
{"name":"AffineEquiv.surjective","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\n⊢ Function.Surjective ⇑e","decl":"protected theorem surjective (e : P₁ ≃ᵃ[k] P₂) : Surjective e :=\n  e.toEquiv.surjective\n\n"}
{"name":"AffineEquiv.injective","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\n⊢ Function.Injective ⇑e","decl":"protected theorem injective (e : P₁ ≃ᵃ[k] P₂) : Injective e :=\n  e.toEquiv.injective\n\n"}
{"name":"AffineEquiv.linear_ofBijective","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nφ : AffineMap k P₁ P₂\nhφ : Function.Bijective ⇑φ\n⊢ Eq (AffineEquiv.ofBijective hφ).linear (LinearEquiv.ofBijective φ.linear ⋯)","decl":"/-- Bijective affine maps are affine isomorphisms. -/\n@[simps! linear apply]\nnoncomputable def ofBijective {φ : P₁ →ᵃ[k] P₂} (hφ : Function.Bijective φ) : P₁ ≃ᵃ[k] P₂ :=\n  { Equiv.ofBijective _ hφ with\n    linear := LinearEquiv.ofBijective φ.linear (φ.linear_bijective_iff.mpr hφ)\n    map_vadd' := φ.map_vadd }\n\n"}
{"name":"AffineEquiv.ofBijective_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nφ : AffineMap k P₁ P₂\nhφ : Function.Bijective ⇑φ\na : P₁\n⊢ Eq ((AffineEquiv.ofBijective hφ) a) (φ a)","decl":"/-- Bijective affine maps are affine isomorphisms. -/\n@[simps! linear apply]\nnoncomputable def ofBijective {φ : P₁ →ᵃ[k] P₂} (hφ : Function.Bijective φ) : P₁ ≃ᵃ[k] P₂ :=\n  { Equiv.ofBijective _ hφ with\n    linear := LinearEquiv.ofBijective φ.linear (φ.linear_bijective_iff.mpr hφ)\n    map_vadd' := φ.map_vadd }\n\n"}
{"name":"AffineEquiv.ofBijective.symm_eq","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nφ : AffineMap k P₁ P₂\nhφ : Function.Bijective ⇑φ\n⊢ Eq (AffineEquiv.ofBijective hφ).symm.toEquiv (Equiv.ofBijective (⇑φ) hφ).symm","decl":"theorem ofBijective.symm_eq {φ : P₁ →ᵃ[k] P₂} (hφ : Function.Bijective φ) :\n    (ofBijective hφ).symm.toEquiv = (Equiv.ofBijective _ hφ).symm :=\n  rfl\n\n"}
{"name":"AffineEquiv.range_eq","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\n⊢ Eq (Set.range ⇑e) Set.univ","decl":"@[simp]\ntheorem range_eq (e : P₁ ≃ᵃ[k] P₂) : range e = univ :=\n  e.surjective.range_eq\n\n"}
{"name":"AffineEquiv.apply_symm_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\np : P₂\n⊢ Eq (e (e.symm p)) p","decl":"@[simp]\ntheorem apply_symm_apply (e : P₁ ≃ᵃ[k] P₂) (p : P₂) : e (e.symm p) = p :=\n  e.toEquiv.apply_symm_apply p\n\n"}
{"name":"AffineEquiv.symm_apply_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\np : P₁\n⊢ Eq (e.symm (e p)) p","decl":"@[simp]\ntheorem symm_apply_apply (e : P₁ ≃ᵃ[k] P₂) (p : P₁) : e.symm (e p) = p :=\n  e.toEquiv.symm_apply_apply p\n\n"}
{"name":"AffineEquiv.apply_eq_iff_eq_symm_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\np₁ : P₁\np₂ : P₂\n⊢ Iff (Eq (e p₁) p₂) (Eq p₁ (e.symm p₂))","decl":"theorem apply_eq_iff_eq_symm_apply (e : P₁ ≃ᵃ[k] P₂) {p₁ p₂} : e p₁ = p₂ ↔ p₁ = e.symm p₂ :=\n  e.toEquiv.apply_eq_iff_eq_symm_apply\n\n-- Porting note: removed `simp`, proof is `by simp only [@EmbeddingLike.apply_eq_iff_eq]`\n"}
{"name":"AffineEquiv.apply_eq_iff_eq","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\np₁ p₂ : P₁\n⊢ Iff (Eq (e p₁) (e p₂)) (Eq p₁ p₂)","decl":"theorem apply_eq_iff_eq (e : P₁ ≃ᵃ[k] P₂) {p₁ p₂ : P₁} : e p₁ = e p₂ ↔ p₁ = p₂ :=\n  e.toEquiv.apply_eq_iff_eq\n\n"}
{"name":"AffineEquiv.image_symm","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineEquiv k P₁ P₂\ns : Set P₂\n⊢ Eq (Set.image (⇑f.symm) s) (Set.preimage (⇑f) s)","decl":"@[simp]\ntheorem image_symm (f : P₁ ≃ᵃ[k] P₂) (s : Set P₂) : f.symm '' s = f ⁻¹' s :=\n  f.symm.toEquiv.image_eq_preimage _\n\n"}
{"name":"AffineEquiv.preimage_symm","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineEquiv k P₁ P₂\ns : Set P₁\n⊢ Eq (Set.preimage (⇑f.symm) s) (Set.image (⇑f) s)","decl":"@[simp]\ntheorem preimage_symm (f : P₁ ≃ᵃ[k] P₂) (s : Set P₁) : f.symm ⁻¹' s = f '' s :=\n  (f.symm.image_symm _).symm\n\n"}
{"name":"AffineEquiv.coe_refl","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\n⊢ Eq (⇑(AffineEquiv.refl k P₁)) id","decl":"@[simp]\ntheorem coe_refl : ⇑(refl k P₁) = id :=\n  rfl\n\n"}
{"name":"AffineEquiv.coe_refl_to_affineMap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\n⊢ Eq (↑(AffineEquiv.refl k P₁)) (AffineMap.id k P₁)","decl":"@[simp]\ntheorem coe_refl_to_affineMap : ↑(refl k P₁) = AffineMap.id k P₁ :=\n  rfl\n\n"}
{"name":"AffineEquiv.refl_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nx : P₁\n⊢ Eq ((AffineEquiv.refl k P₁) x) x","decl":"@[simp]\ntheorem refl_apply (x : P₁) : refl k P₁ x = x :=\n  rfl\n\n"}
{"name":"AffineEquiv.toEquiv_refl","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\n⊢ Eq (AffineEquiv.refl k P₁).toEquiv (Equiv.refl P₁)","decl":"@[simp]\ntheorem toEquiv_refl : (refl k P₁).toEquiv = Equiv.refl P₁ :=\n  rfl\n\n"}
{"name":"AffineEquiv.linear_refl","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\n⊢ Eq (AffineEquiv.refl k P₁).linear (LinearEquiv.refl k V₁)","decl":"@[simp]\ntheorem linear_refl : (refl k P₁).linear = LinearEquiv.refl k V₁ :=\n  rfl\n\n"}
{"name":"AffineEquiv.symm_refl","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\n⊢ Eq (AffineEquiv.refl k P₁).symm (AffineEquiv.refl k P₁)","decl":"@[simp]\ntheorem symm_refl : (refl k P₁).symm = refl k P₁ :=\n  rfl\n\n"}
{"name":"AffineEquiv.coe_trans","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nP₃ : Type u_4\nV₁ : Type u_6\nV₂ : Type u_7\nV₃ : Type u_8\ninst✝⁹ : Ring k\ninst✝⁸ : AddCommGroup V₁\ninst✝⁷ : Module k V₁\ninst✝⁶ : AddTorsor V₁ P₁\ninst✝⁵ : AddCommGroup V₂\ninst✝⁴ : Module k V₂\ninst✝³ : AddTorsor V₂ P₂\ninst✝² : AddCommGroup V₃\ninst✝¹ : Module k V₃\ninst✝ : AddTorsor V₃ P₃\ne : AffineEquiv k P₁ P₂\ne' : AffineEquiv k P₂ P₃\n⊢ Eq (⇑(e.trans e')) (Function.comp ⇑e' ⇑e)","decl":"@[simp]\ntheorem coe_trans (e : P₁ ≃ᵃ[k] P₂) (e' : P₂ ≃ᵃ[k] P₃) : ⇑(e.trans e') = e' ∘ e :=\n  rfl\n\n"}
{"name":"AffineEquiv.coe_trans_to_affineMap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nP₃ : Type u_4\nV₁ : Type u_6\nV₂ : Type u_7\nV₃ : Type u_8\ninst✝⁹ : Ring k\ninst✝⁸ : AddCommGroup V₁\ninst✝⁷ : Module k V₁\ninst✝⁶ : AddTorsor V₁ P₁\ninst✝⁵ : AddCommGroup V₂\ninst✝⁴ : Module k V₂\ninst✝³ : AddTorsor V₂ P₂\ninst✝² : AddCommGroup V₃\ninst✝¹ : Module k V₃\ninst✝ : AddTorsor V₃ P₃\ne : AffineEquiv k P₁ P₂\ne' : AffineEquiv k P₂ P₃\n⊢ Eq (↑(e.trans e')) ((↑e').comp ↑e)","decl":"@[simp]\ntheorem coe_trans_to_affineMap (e : P₁ ≃ᵃ[k] P₂) (e' : P₂ ≃ᵃ[k] P₃) :\n    (e.trans e' : P₁ →ᵃ[k] P₃) = (e' : P₂ →ᵃ[k] P₃).comp e :=\n  rfl\n\n"}
{"name":"AffineEquiv.trans_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nP₃ : Type u_4\nV₁ : Type u_6\nV₂ : Type u_7\nV₃ : Type u_8\ninst✝⁹ : Ring k\ninst✝⁸ : AddCommGroup V₁\ninst✝⁷ : Module k V₁\ninst✝⁶ : AddTorsor V₁ P₁\ninst✝⁵ : AddCommGroup V₂\ninst✝⁴ : Module k V₂\ninst✝³ : AddTorsor V₂ P₂\ninst✝² : AddCommGroup V₃\ninst✝¹ : Module k V₃\ninst✝ : AddTorsor V₃ P₃\ne : AffineEquiv k P₁ P₂\ne' : AffineEquiv k P₂ P₃\np : P₁\n⊢ Eq ((e.trans e') p) (e' (e p))","decl":"@[simp]\ntheorem trans_apply (e : P₁ ≃ᵃ[k] P₂) (e' : P₂ ≃ᵃ[k] P₃) (p : P₁) : e.trans e' p = e' (e p) :=\n  rfl\n\n"}
{"name":"AffineEquiv.trans_assoc","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nP₃ : Type u_4\nP₄ : Type u_5\nV₁ : Type u_6\nV₂ : Type u_7\nV₃ : Type u_8\nV₄ : Type u_9\ninst✝¹² : Ring k\ninst✝¹¹ : AddCommGroup V₁\ninst✝¹⁰ : Module k V₁\ninst✝⁹ : AddTorsor V₁ P₁\ninst✝⁸ : AddCommGroup V₂\ninst✝⁷ : Module k V₂\ninst✝⁶ : AddTorsor V₂ P₂\ninst✝⁵ : AddCommGroup V₃\ninst✝⁴ : Module k V₃\ninst✝³ : AddTorsor V₃ P₃\ninst✝² : AddCommGroup V₄\ninst✝¹ : Module k V₄\ninst✝ : AddTorsor V₄ P₄\ne₁ : AffineEquiv k P₁ P₂\ne₂ : AffineEquiv k P₂ P₃\ne₃ : AffineEquiv k P₃ P₄\n⊢ Eq ((e₁.trans e₂).trans e₃) (e₁.trans (e₂.trans e₃))","decl":"theorem trans_assoc (e₁ : P₁ ≃ᵃ[k] P₂) (e₂ : P₂ ≃ᵃ[k] P₃) (e₃ : P₃ ≃ᵃ[k] P₄) :\n    (e₁.trans e₂).trans e₃ = e₁.trans (e₂.trans e₃) :=\n  ext fun _ => rfl\n\n"}
{"name":"AffineEquiv.trans_refl","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\n⊢ Eq (e.trans (AffineEquiv.refl k P₂)) e","decl":"@[simp]\ntheorem trans_refl (e : P₁ ≃ᵃ[k] P₂) : e.trans (refl k P₂) = e :=\n  ext fun _ => rfl\n\n"}
{"name":"AffineEquiv.refl_trans","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\n⊢ Eq ((AffineEquiv.refl k P₁).trans e) e","decl":"@[simp]\ntheorem refl_trans (e : P₁ ≃ᵃ[k] P₂) : (refl k P₁).trans e = e :=\n  ext fun _ => rfl\n\n"}
{"name":"AffineEquiv.self_trans_symm","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\n⊢ Eq (e.trans e.symm) (AffineEquiv.refl k P₁)","decl":"@[simp]\ntheorem self_trans_symm (e : P₁ ≃ᵃ[k] P₂) : e.trans e.symm = refl k P₁ :=\n  ext e.symm_apply_apply\n\n"}
{"name":"AffineEquiv.symm_trans_self","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\n⊢ Eq (e.symm.trans e) (AffineEquiv.refl k P₂)","decl":"@[simp]\ntheorem symm_trans_self (e : P₁ ≃ᵃ[k] P₂) : e.symm.trans e = refl k P₂ :=\n  ext e.apply_symm_apply\n\n"}
{"name":"AffineEquiv.apply_lineMap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nP₂ : Type u_3\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\na b : P₁\nc : k\n⊢ Eq (e ((AffineMap.lineMap a b) c)) ((AffineMap.lineMap (e a) (e b)) c)","decl":"@[simp]\ntheorem apply_lineMap (e : P₁ ≃ᵃ[k] P₂) (a b : P₁) (c : k) :\n    e (AffineMap.lineMap a b c) = AffineMap.lineMap (e a) (e b) c :=\n  e.toAffineMap.apply_lineMap a b c\n\n"}
{"name":"AffineEquiv.one_def","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\n⊢ Eq 1 (AffineEquiv.refl k P₁)","decl":"theorem one_def : (1 : P₁ ≃ᵃ[k] P₁) = refl k P₁ :=\n  rfl\n\n"}
{"name":"AffineEquiv.coe_one","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\n⊢ Eq (⇑1) id","decl":"@[simp]\ntheorem coe_one : ⇑(1 : P₁ ≃ᵃ[k] P₁) = id :=\n  rfl\n\n"}
{"name":"AffineEquiv.mul_def","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\ne e' : AffineEquiv k P₁ P₁\n⊢ Eq (HMul.hMul e e') (e'.trans e)","decl":"theorem mul_def (e e' : P₁ ≃ᵃ[k] P₁) : e * e' = e'.trans e :=\n  rfl\n\n"}
{"name":"AffineEquiv.coe_mul","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\ne e' : AffineEquiv k P₁ P₁\n⊢ Eq (⇑(HMul.hMul e e')) (Function.comp ⇑e ⇑e')","decl":"@[simp]\ntheorem coe_mul (e e' : P₁ ≃ᵃ[k] P₁) : ⇑(e * e') = e ∘ e' :=\n  rfl\n\n"}
{"name":"AffineEquiv.inv_def","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\ne : AffineEquiv k P₁ P₁\n⊢ Eq (Inv.inv e) e.symm","decl":"theorem inv_def (e : P₁ ≃ᵃ[k] P₁) : e⁻¹ = e.symm :=\n  rfl\n\n"}
{"name":"AffineEquiv.linearHom_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nself : AffineEquiv k P₁ P₁\n⊢ Eq (AffineEquiv.linearHom self) self.linear","decl":"/-- `AffineEquiv.linear` on automorphisms is a `MonoidHom`. -/\n@[simps]\ndef linearHom : (P₁ ≃ᵃ[k] P₁) →* V₁ ≃ₗ[k] V₁ where\n  toFun := linear\n  map_one' := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AffineEquiv.equivUnitsAffineMap_symm_apply_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nu : Units (AffineMap k P₁ P₁)\na : P₁\n⊢ Eq ((AffineEquiv.equivUnitsAffineMap.symm u) a) (↑u a)","decl":"/-- The group of `AffineEquiv`s are equivalent to the group of units of `AffineMap`.\n\nThis is the affine version of `LinearMap.GeneralLinearGroup.generalLinearEquiv`. -/\n@[simps]\ndef equivUnitsAffineMap : (P₁ ≃ᵃ[k] P₁) ≃* (P₁ →ᵃ[k] P₁)ˣ where\n  toFun e :=\n    { val := e, inv := e.symm,\n      val_inv := congr_arg toAffineMap e.symm_trans_self\n      inv_val := congr_arg toAffineMap e.self_trans_symm }\n  invFun u :=\n    { toFun := (u : P₁ →ᵃ[k] P₁)\n      invFun := (↑u⁻¹ : P₁ →ᵃ[k] P₁)\n      left_inv := AffineMap.congr_fun u.inv_mul\n      right_inv := AffineMap.congr_fun u.mul_inv\n      linear :=\n        LinearMap.GeneralLinearGroup.generalLinearEquiv _ _ <| Units.map AffineMap.linearHom u\n      map_vadd' := fun _ _ => (u : P₁ →ᵃ[k] P₁).map_vadd _ _ }\n  left_inv _ := AffineEquiv.ext fun _ => rfl\n  right_inv _ := Units.ext <| AffineMap.ext fun _ => rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AffineEquiv.equivUnitsAffineMap_symm_apply_invFun","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nu : Units (AffineMap k P₁ P₁)\na : P₁\n⊢ Eq ((AffineEquiv.equivUnitsAffineMap.symm u).invFun a) (↑(Inv.inv u) a)","decl":"/-- The group of `AffineEquiv`s are equivalent to the group of units of `AffineMap`.\n\nThis is the affine version of `LinearMap.GeneralLinearGroup.generalLinearEquiv`. -/\n@[simps]\ndef equivUnitsAffineMap : (P₁ ≃ᵃ[k] P₁) ≃* (P₁ →ᵃ[k] P₁)ˣ where\n  toFun e :=\n    { val := e, inv := e.symm,\n      val_inv := congr_arg toAffineMap e.symm_trans_self\n      inv_val := congr_arg toAffineMap e.self_trans_symm }\n  invFun u :=\n    { toFun := (u : P₁ →ᵃ[k] P₁)\n      invFun := (↑u⁻¹ : P₁ →ᵃ[k] P₁)\n      left_inv := AffineMap.congr_fun u.inv_mul\n      right_inv := AffineMap.congr_fun u.mul_inv\n      linear :=\n        LinearMap.GeneralLinearGroup.generalLinearEquiv _ _ <| Units.map AffineMap.linearHom u\n      map_vadd' := fun _ _ => (u : P₁ →ᵃ[k] P₁).map_vadd _ _ }\n  left_inv _ := AffineEquiv.ext fun _ => rfl\n  right_inv _ := Units.ext <| AffineMap.ext fun _ => rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AffineEquiv.equivUnitsAffineMap_symm_apply_symm_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nu : Units (AffineMap k P₁ P₁)\na : P₁\n⊢ Eq ((AffineEquiv.equivUnitsAffineMap.symm u).symm a) (↑(Inv.inv u) a)","decl":"/-- The group of `AffineEquiv`s are equivalent to the group of units of `AffineMap`.\n\nThis is the affine version of `LinearMap.GeneralLinearGroup.generalLinearEquiv`. -/\n@[simps]\ndef equivUnitsAffineMap : (P₁ ≃ᵃ[k] P₁) ≃* (P₁ →ᵃ[k] P₁)ˣ where\n  toFun e :=\n    { val := e, inv := e.symm,\n      val_inv := congr_arg toAffineMap e.symm_trans_self\n      inv_val := congr_arg toAffineMap e.self_trans_symm }\n  invFun u :=\n    { toFun := (u : P₁ →ᵃ[k] P₁)\n      invFun := (↑u⁻¹ : P₁ →ᵃ[k] P₁)\n      left_inv := AffineMap.congr_fun u.inv_mul\n      right_inv := AffineMap.congr_fun u.mul_inv\n      linear :=\n        LinearMap.GeneralLinearGroup.generalLinearEquiv _ _ <| Units.map AffineMap.linearHom u\n      map_vadd' := fun _ _ => (u : P₁ →ᵃ[k] P₁).map_vadd _ _ }\n  left_inv _ := AffineEquiv.ext fun _ => rfl\n  right_inv _ := Units.ext <| AffineMap.ext fun _ => rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AffineEquiv.linear_equivUnitsAffineMap_symm_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nu : Units (AffineMap k P₁ P₁)\n⊢ Eq (AffineEquiv.equivUnitsAffineMap.symm u).linear ((LinearMap.GeneralLinearGroup.generalLinearEquiv k V₁) ((Units.map AffineMap.linearHom) u))","decl":"/-- The group of `AffineEquiv`s are equivalent to the group of units of `AffineMap`.\n\nThis is the affine version of `LinearMap.GeneralLinearGroup.generalLinearEquiv`. -/\n@[simps]\ndef equivUnitsAffineMap : (P₁ ≃ᵃ[k] P₁) ≃* (P₁ →ᵃ[k] P₁)ˣ where\n  toFun e :=\n    { val := e, inv := e.symm,\n      val_inv := congr_arg toAffineMap e.symm_trans_self\n      inv_val := congr_arg toAffineMap e.self_trans_symm }\n  invFun u :=\n    { toFun := (u : P₁ →ᵃ[k] P₁)\n      invFun := (↑u⁻¹ : P₁ →ᵃ[k] P₁)\n      left_inv := AffineMap.congr_fun u.inv_mul\n      right_inv := AffineMap.congr_fun u.mul_inv\n      linear :=\n        LinearMap.GeneralLinearGroup.generalLinearEquiv _ _ <| Units.map AffineMap.linearHom u\n      map_vadd' := fun _ _ => (u : P₁ →ᵃ[k] P₁).map_vadd _ _ }\n  left_inv _ := AffineEquiv.ext fun _ => rfl\n  right_inv _ := Units.ext <| AffineMap.ext fun _ => rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AffineEquiv.val_inv_equivUnitsAffineMap_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\ne : AffineEquiv k P₁ P₁\n⊢ Eq ↑(Inv.inv (AffineEquiv.equivUnitsAffineMap e)) ↑e.symm","decl":"/-- The group of `AffineEquiv`s are equivalent to the group of units of `AffineMap`.\n\nThis is the affine version of `LinearMap.GeneralLinearGroup.generalLinearEquiv`. -/\n@[simps]\ndef equivUnitsAffineMap : (P₁ ≃ᵃ[k] P₁) ≃* (P₁ →ᵃ[k] P₁)ˣ where\n  toFun e :=\n    { val := e, inv := e.symm,\n      val_inv := congr_arg toAffineMap e.symm_trans_self\n      inv_val := congr_arg toAffineMap e.self_trans_symm }\n  invFun u :=\n    { toFun := (u : P₁ →ᵃ[k] P₁)\n      invFun := (↑u⁻¹ : P₁ →ᵃ[k] P₁)\n      left_inv := AffineMap.congr_fun u.inv_mul\n      right_inv := AffineMap.congr_fun u.mul_inv\n      linear :=\n        LinearMap.GeneralLinearGroup.generalLinearEquiv _ _ <| Units.map AffineMap.linearHom u\n      map_vadd' := fun _ _ => (u : P₁ →ᵃ[k] P₁).map_vadd _ _ }\n  left_inv _ := AffineEquiv.ext fun _ => rfl\n  right_inv _ := Units.ext <| AffineMap.ext fun _ => rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AffineEquiv.val_equivUnitsAffineMap_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\ne : AffineEquiv k P₁ P₁\n⊢ Eq ↑(AffineEquiv.equivUnitsAffineMap e) ↑e","decl":"/-- The group of `AffineEquiv`s are equivalent to the group of units of `AffineMap`.\n\nThis is the affine version of `LinearMap.GeneralLinearGroup.generalLinearEquiv`. -/\n@[simps]\ndef equivUnitsAffineMap : (P₁ ≃ᵃ[k] P₁) ≃* (P₁ →ᵃ[k] P₁)ˣ where\n  toFun e :=\n    { val := e, inv := e.symm,\n      val_inv := congr_arg toAffineMap e.symm_trans_self\n      inv_val := congr_arg toAffineMap e.self_trans_symm }\n  invFun u :=\n    { toFun := (u : P₁ →ᵃ[k] P₁)\n      invFun := (↑u⁻¹ : P₁ →ᵃ[k] P₁)\n      left_inv := AffineMap.congr_fun u.inv_mul\n      right_inv := AffineMap.congr_fun u.mul_inv\n      linear :=\n        LinearMap.GeneralLinearGroup.generalLinearEquiv _ _ <| Units.map AffineMap.linearHom u\n      map_vadd' := fun _ _ => (u : P₁ →ᵃ[k] P₁).map_vadd _ _ }\n  left_inv _ := AffineEquiv.ext fun _ => rfl\n  right_inv _ := Units.ext <| AffineMap.ext fun _ => rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AffineEquiv.equivUnitsAffineMap_symm_apply_toFun","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nu : Units (AffineMap k P₁ P₁)\na : P₁\n⊢ Eq ((AffineEquiv.equivUnitsAffineMap.symm u) a) (↑u a)","decl":"/-- The group of `AffineEquiv`s are equivalent to the group of units of `AffineMap`.\n\nThis is the affine version of `LinearMap.GeneralLinearGroup.generalLinearEquiv`. -/\n@[simps]\ndef equivUnitsAffineMap : (P₁ ≃ᵃ[k] P₁) ≃* (P₁ →ᵃ[k] P₁)ˣ where\n  toFun e :=\n    { val := e, inv := e.symm,\n      val_inv := congr_arg toAffineMap e.symm_trans_self\n      inv_val := congr_arg toAffineMap e.self_trans_symm }\n  invFun u :=\n    { toFun := (u : P₁ →ᵃ[k] P₁)\n      invFun := (↑u⁻¹ : P₁ →ᵃ[k] P₁)\n      left_inv := AffineMap.congr_fun u.inv_mul\n      right_inv := AffineMap.congr_fun u.mul_inv\n      linear :=\n        LinearMap.GeneralLinearGroup.generalLinearEquiv _ _ <| Units.map AffineMap.linearHom u\n      map_vadd' := fun _ _ => (u : P₁ →ᵃ[k] P₁).map_vadd _ _ }\n  left_inv _ := AffineEquiv.ext fun _ => rfl\n  right_inv _ := Units.ext <| AffineMap.ext fun _ => rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AffineEquiv.linear_vaddConst","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nb : P₁\n⊢ Eq (AffineEquiv.vaddConst k b).linear (LinearEquiv.refl k V₁)","decl":"/-- The map `v ↦ v +ᵥ b` as an affine equivalence between a module `V` and an affine space `P` with\ntangent space `V`. -/\n@[simps! linear apply symm_apply]\ndef vaddConst (b : P₁) : V₁ ≃ᵃ[k] P₁ where\n  toEquiv := Equiv.vaddConst b\n  linear := LinearEquiv.refl _ _\n  map_vadd' _ _ := add_vadd _ _ _\n\n"}
{"name":"AffineEquiv.vaddConst_symm_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nb p' : P₁\n⊢ Eq ((AffineEquiv.vaddConst k b).symm p') (VSub.vsub p' b)","decl":"/-- The map `v ↦ v +ᵥ b` as an affine equivalence between a module `V` and an affine space `P` with\ntangent space `V`. -/\n@[simps! linear apply symm_apply]\ndef vaddConst (b : P₁) : V₁ ≃ᵃ[k] P₁ where\n  toEquiv := Equiv.vaddConst b\n  linear := LinearEquiv.refl _ _\n  map_vadd' _ _ := add_vadd _ _ _\n\n"}
{"name":"AffineEquiv.vaddConst_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nb : P₁\nv : V₁\n⊢ Eq ((AffineEquiv.vaddConst k b) v) (HVAdd.hVAdd v b)","decl":"/-- The map `v ↦ v +ᵥ b` as an affine equivalence between a module `V` and an affine space `P` with\ntangent space `V`. -/\n@[simps! linear apply symm_apply]\ndef vaddConst (b : P₁) : V₁ ≃ᵃ[k] P₁ where\n  toEquiv := Equiv.vaddConst b\n  linear := LinearEquiv.refl _ _\n  map_vadd' _ _ := add_vadd _ _ _\n\n"}
{"name":"AffineEquiv.coe_constVSub","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\np : P₁\n⊢ Eq ⇑(AffineEquiv.constVSub k p) fun x => VSub.vsub p x","decl":"@[simp]\ntheorem coe_constVSub (p : P₁) : ⇑(constVSub k p) = (p -ᵥ ·) :=\n  rfl\n\n"}
{"name":"AffineEquiv.coe_constVSub_symm","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\np : P₁\n⊢ Eq ⇑(AffineEquiv.constVSub k p).symm fun v => HVAdd.hVAdd (Neg.neg v) p","decl":"@[simp]\ntheorem coe_constVSub_symm (p : P₁) : ⇑(constVSub k p).symm = fun v : V₁ => -v +ᵥ p :=\n  rfl\n\n"}
{"name":"AffineEquiv.linear_constVAdd","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nv : V₁\n⊢ Eq (AffineEquiv.constVAdd k P₁ v).linear (LinearEquiv.refl k V₁)","decl":"/-- The map `p ↦ v +ᵥ p` as an affine automorphism of an affine space.\n\nNote that there is no need for an `AffineMap.constVAdd` as it is always an equivalence.\nThis is roughly to `DistribMulAction.toLinearEquiv` as `+ᵥ` is to `•`. -/\n@[simps! apply linear]\ndef constVAdd (v : V₁) : P₁ ≃ᵃ[k] P₁ where\n  toEquiv := Equiv.constVAdd P₁ v\n  linear := LinearEquiv.refl _ _\n  map_vadd' _ _ := vadd_comm _ _ _\n\n"}
{"name":"AffineEquiv.constVAdd_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nv : V₁\nx✝ : P₁\n⊢ Eq ((AffineEquiv.constVAdd k P₁ v) x✝) (HVAdd.hVAdd v x✝)","decl":"/-- The map `p ↦ v +ᵥ p` as an affine automorphism of an affine space.\n\nNote that there is no need for an `AffineMap.constVAdd` as it is always an equivalence.\nThis is roughly to `DistribMulAction.toLinearEquiv` as `+ᵥ` is to `•`. -/\n@[simps! apply linear]\ndef constVAdd (v : V₁) : P₁ ≃ᵃ[k] P₁ where\n  toEquiv := Equiv.constVAdd P₁ v\n  linear := LinearEquiv.refl _ _\n  map_vadd' _ _ := vadd_comm _ _ _\n\n"}
{"name":"AffineEquiv.constVAdd_zero","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\n⊢ Eq (AffineEquiv.constVAdd k P₁ 0) (AffineEquiv.refl k P₁)","decl":"@[simp]\ntheorem constVAdd_zero : constVAdd k P₁ 0 = AffineEquiv.refl _ _ :=\n  ext <| zero_vadd _\n\n"}
{"name":"AffineEquiv.constVAdd_add","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nv w : V₁\n⊢ Eq (AffineEquiv.constVAdd k P₁ (HAdd.hAdd v w)) ((AffineEquiv.constVAdd k P₁ w).trans (AffineEquiv.constVAdd k P₁ v))","decl":"@[simp]\ntheorem constVAdd_add (v w : V₁) :\n    constVAdd k P₁ (v + w) = (constVAdd k P₁ w).trans (constVAdd k P₁ v) :=\n  ext <| add_vadd _ _\n\n"}
{"name":"AffineEquiv.constVAdd_symm","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nv : V₁\n⊢ Eq (AffineEquiv.constVAdd k P₁ v).symm (AffineEquiv.constVAdd k P₁ (Neg.neg v))","decl":"@[simp]\ntheorem constVAdd_symm (v : V₁) : (constVAdd k P₁ v).symm = constVAdd k P₁ (-v) :=\n  ext fun _ => rfl\n\n"}
{"name":"AffineEquiv.constVAddHom_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nv : Multiplicative V₁\n⊢ Eq ((AffineEquiv.constVAddHom k P₁) v) (AffineEquiv.constVAdd k P₁ (Multiplicative.toAdd v))","decl":"/-- A more bundled version of `AffineEquiv.constVAdd`. -/\n@[simps]\ndef constVAddHom : Multiplicative V₁ →* P₁ ≃ᵃ[k] P₁ where\n  toFun v := constVAdd k P₁ v.toAdd\n  map_one' := constVAdd_zero _ _\n  map_mul' := constVAdd_add _ P₁\n\n"}
{"name":"AffineEquiv.constVAdd_nsmul","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nn : Nat\nv : V₁\n⊢ Eq (AffineEquiv.constVAdd k P₁ (HSMul.hSMul n v)) (HPow.hPow (AffineEquiv.constVAdd k P₁ v) n)","decl":"theorem constVAdd_nsmul (n : ℕ) (v : V₁) : constVAdd k P₁ (n • v) = constVAdd k P₁ v ^ n :=\n  (constVAddHom k P₁).map_pow _ _\n\n"}
{"name":"AffineEquiv.constVAdd_zsmul","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nz : Int\nv : V₁\n⊢ Eq (AffineEquiv.constVAdd k P₁ (HSMul.hSMul z v)) (HPow.hPow (AffineEquiv.constVAdd k P₁ v) z)","decl":"theorem constVAdd_zsmul (z : ℤ) (v : V₁) : constVAdd k P₁ (z • v) = constVAdd k P₁ v ^ z :=\n  (constVAddHom k P₁).map_zpow _ _\n\n"}
{"name":"AffineEquiv.coe_homothetyUnitsMulHom_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"R : Type u_10\nV : Type u_11\nP : Type u_12\ninst✝³ : CommRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\np : P\nt : Units R\n⊢ Eq ⇑((AffineEquiv.homothetyUnitsMulHom p) t) ⇑(AffineMap.homothety p ↑t)","decl":"@[simp]\ntheorem coe_homothetyUnitsMulHom_apply (p : P) (t : Rˣ) :\n    (homothetyUnitsMulHom p t : P → P) = AffineMap.homothety p (t : R) :=\n  rfl\n\n"}
{"name":"AffineEquiv.coe_homothetyUnitsMulHom_apply_symm","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"R : Type u_10\nV : Type u_11\nP : Type u_12\ninst✝³ : CommRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\np : P\nt : Units R\n⊢ Eq ⇑((AffineEquiv.homothetyUnitsMulHom p) t).symm ⇑(AffineMap.homothety p ↑(Inv.inv t))","decl":"@[simp]\ntheorem coe_homothetyUnitsMulHom_apply_symm (p : P) (t : Rˣ) :\n    ((homothetyUnitsMulHom p t).symm : P → P) = AffineMap.homothety p (↑t⁻¹ : R) :=\n  rfl\n\n"}
{"name":"AffineEquiv.coe_homothetyUnitsMulHom_eq_homothetyHom_coe","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"R : Type u_10\nV : Type u_11\nP : Type u_12\ninst✝³ : CommRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\np : P\n⊢ Eq (Function.comp AffineEquiv.toAffineMap ⇑(AffineEquiv.homothetyUnitsMulHom p)) (Function.comp (⇑(AffineMap.homothetyHom p)) Units.val)","decl":"@[simp]\ntheorem coe_homothetyUnitsMulHom_eq_homothetyHom_coe (p : P) :\n    ((↑) : (P ≃ᵃ[R] P) → P →ᵃ[R] P) ∘ homothetyUnitsMulHom p =\n      AffineMap.homothetyHom p ∘ ((↑) : Rˣ → R) :=\n  funext fun _ => rfl\n\n"}
{"name":"AffineEquiv.pointReflection_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nx y : P₁\n⊢ Eq ((AffineEquiv.pointReflection k x) y) (HVAdd.hVAdd (VSub.vsub x y) x)","decl":"theorem pointReflection_apply (x y : P₁) : pointReflection k x y = (x -ᵥ y) +ᵥ x :=\n  rfl\n\n"}
{"name":"AffineEquiv.pointReflection_symm","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nx : P₁\n⊢ Eq (AffineEquiv.pointReflection k x).symm (AffineEquiv.pointReflection k x)","decl":"@[simp]\ntheorem pointReflection_symm (x : P₁) : (pointReflection k x).symm = pointReflection k x :=\n  toEquiv_injective <| Equiv.pointReflection_symm x\n\n"}
{"name":"AffineEquiv.toEquiv_pointReflection","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nx : P₁\n⊢ Eq (AffineEquiv.pointReflection k x).toEquiv (Equiv.pointReflection x)","decl":"@[simp]\ntheorem toEquiv_pointReflection (x : P₁) :\n    (pointReflection k x).toEquiv = Equiv.pointReflection x :=\n  rfl\n\n"}
{"name":"AffineEquiv.pointReflection_self","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nx : P₁\n⊢ Eq ((AffineEquiv.pointReflection k x) x) x","decl":"@[simp]\ntheorem pointReflection_self (x : P₁) : pointReflection k x x = x :=\n  vsub_vadd _ _\n\n"}
{"name":"AffineEquiv.pointReflection_involutive","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nx : P₁\n⊢ Function.Involutive ⇑(AffineEquiv.pointReflection k x)","decl":"theorem pointReflection_involutive (x : P₁) : Involutive (pointReflection k x : P₁ → P₁) :=\n  Equiv.pointReflection_involutive x\n\n"}
{"name":"AffineEquiv.pointReflection_fixed_iff_of_injective_two_nsmul","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nx y : P₁\nh : Function.Injective fun x => HSMul.hSMul 2 x\n⊢ Iff (Eq ((AffineEquiv.pointReflection k x) y) y) (Eq y x)","decl":"/-- `x` is the only fixed point of `pointReflection x`. This lemma requires\n`x + x = y + y ↔ x = y`. There is no typeclass to use here, so we add it as an explicit argument. -/\ntheorem pointReflection_fixed_iff_of_injective_two_nsmul {x y : P₁}\n    (h : Injective (2 • · : V₁ → V₁)) : pointReflection k x y = y ↔ y = x :=\n  Equiv.pointReflection_fixed_iff_of_injective_two_nsmul h\n\n"}
{"name":"AffineEquiv.pointReflection_fixed_iff_of_injective_bit0","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nx y : P₁\nh : Function.Injective fun x => HSMul.hSMul 2 x\n⊢ Iff (Eq ((AffineEquiv.pointReflection k x) y) y) (Eq y x)","decl":"@[deprecated (since := \"2024-11-18\")] alias pointReflection_fixed_iff_of_injective_bit0 :=\npointReflection_fixed_iff_of_injective_two_nsmul\n\n"}
{"name":"AffineEquiv.injective_pointReflection_left_of_injective_two_nsmul","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nh : Function.Injective fun x => HSMul.hSMul 2 x\ny : P₁\n⊢ Function.Injective fun x => (AffineEquiv.pointReflection k x) y","decl":"theorem injective_pointReflection_left_of_injective_two_nsmul\n    (h : Injective (2 • · : V₁ → V₁)) (y : P₁) :\n    Injective fun x : P₁ => pointReflection k x y :=\n  Equiv.injective_pointReflection_left_of_injective_two_nsmul h y\n\n"}
{"name":"AffineEquiv.injective_pointReflection_left_of_injective_bit0","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nh : Function.Injective fun x => HSMul.hSMul 2 x\ny : P₁\n⊢ Function.Injective fun x => (AffineEquiv.pointReflection k x) y","decl":"@[deprecated (since := \"2024-11-18\")] alias injective_pointReflection_left_of_injective_bit0 :=\ninjective_pointReflection_left_of_injective_two_nsmul\n\n"}
{"name":"AffineEquiv.injective_pointReflection_left_of_module","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V₁\ninst✝² : Module k V₁\ninst✝¹ : AddTorsor V₁ P₁\ninst✝ : Invertible 2\ny : P₁\n⊢ Function.Injective fun x => (AffineEquiv.pointReflection k x) y","decl":"theorem injective_pointReflection_left_of_module [Invertible (2 : k)] :\n    ∀ y, Injective fun x : P₁ => pointReflection k x y :=\n  injective_pointReflection_left_of_injective_two_nsmul k fun x y h => by\n    dsimp at h\n    rwa [two_nsmul, two_nsmul, ← two_smul k x, ← two_smul k y,\n      (isUnit_of_invertible (2 : k)).smul_left_cancel] at h\n\n"}
{"name":"AffineEquiv.pointReflection_fixed_iff_of_module","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V₁\ninst✝² : Module k V₁\ninst✝¹ : AddTorsor V₁ P₁\ninst✝ : Invertible 2\nx y : P₁\n⊢ Iff (Eq ((AffineEquiv.pointReflection k x) y) y) (Eq y x)","decl":"theorem pointReflection_fixed_iff_of_module [Invertible (2 : k)] {x y : P₁} :\n    pointReflection k x y = y ↔ y = x :=\n  ((injective_pointReflection_left_of_module k y).eq_iff' (pointReflection_self k y)).trans eq_comm\n\n"}
{"name":"LinearEquiv.coe_toAffineEquiv","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nV₁ : Type u_6\nV₂ : Type u_7\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V₁\ninst✝² : Module k V₁\ninst✝¹ : AddCommGroup V₂\ninst✝ : Module k V₂\ne : LinearEquiv (RingHom.id k) V₁ V₂\n⊢ Eq ⇑e.toAffineEquiv ⇑e","decl":"@[simp]\ntheorem coe_toAffineEquiv (e : V₁ ≃ₗ[k] V₂) : ⇑e.toAffineEquiv = e :=\n  rfl\n\n"}
{"name":"AffineMap.lineMap_vadd","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nv v' : V₁\np : P₁\nc : k\n⊢ Eq (HVAdd.hVAdd ((AffineMap.lineMap v v') c) p) ((AffineMap.lineMap (HVAdd.hVAdd v p) (HVAdd.hVAdd v' p)) c)","decl":"theorem lineMap_vadd (v v' : V₁) (p : P₁) (c : k) :\n    lineMap v v' c +ᵥ p = lineMap (v +ᵥ p) (v' +ᵥ p) c :=\n  (vaddConst k p).apply_lineMap v v' c\n\n"}
{"name":"AffineMap.lineMap_vsub","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\np₁ p₂ p₃ : P₁\nc : k\n⊢ Eq (VSub.vsub ((AffineMap.lineMap p₁ p₂) c) p₃) ((AffineMap.lineMap (VSub.vsub p₁ p₃) (VSub.vsub p₂ p₃)) c)","decl":"theorem lineMap_vsub (p₁ p₂ p₃ : P₁) (c : k) :\n    lineMap p₁ p₂ c -ᵥ p₃ = lineMap (p₁ -ᵥ p₃) (p₂ -ᵥ p₃) c :=\n  (vaddConst k p₃).symm.apply_lineMap p₁ p₂ c\n\n"}
{"name":"AffineMap.vsub_lineMap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\np₁ p₂ p₃ : P₁\nc : k\n⊢ Eq (VSub.vsub p₁ ((AffineMap.lineMap p₂ p₃) c)) ((AffineMap.lineMap (VSub.vsub p₁ p₂) (VSub.vsub p₁ p₃)) c)","decl":"theorem vsub_lineMap (p₁ p₂ p₃ : P₁) (c : k) :\n    p₁ -ᵥ lineMap p₂ p₃ c = lineMap (p₁ -ᵥ p₂) (p₁ -ᵥ p₃) c :=\n  (constVSub k p₁).apply_lineMap p₂ p₃ c\n\n"}
{"name":"AffineMap.vadd_lineMap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"k : Type u_1\nP₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\nv : V₁\np₁ p₂ : P₁\nc : k\n⊢ Eq (HVAdd.hVAdd v ((AffineMap.lineMap p₁ p₂) c)) ((AffineMap.lineMap (HVAdd.hVAdd v p₁) (HVAdd.hVAdd v p₂)) c)","decl":"theorem vadd_lineMap (v : V₁) (p₁ p₂ : P₁) (c : k) :\n    v +ᵥ lineMap p₁ p₂ c = lineMap (v +ᵥ p₁) (v +ᵥ p₂) c :=\n  (constVAdd k P₁ v).apply_lineMap p₁ p₂ c\n\n"}
{"name":"AffineMap.homothety_neg_one_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineEquiv","initialProofState":"P₁ : Type u_2\nV₁ : Type u_6\ninst✝³ : AddCommGroup V₁\ninst✝² : AddTorsor V₁ P₁\nR' : Type u_10\ninst✝¹ : CommRing R'\ninst✝ : Module R' V₁\nc p : P₁\n⊢ Eq ((AffineMap.homothety c (-1)) p) ((AffineEquiv.pointReflection R' c) p)","decl":"theorem homothety_neg_one_apply (c p : P₁) : homothety c (-1 : R') p = pointReflection R' c p := by\n  simp [homothety_apply, pointReflection_apply]\n\n"}
