{"name":"CategoryTheory.Grothendieck.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\ninst‚úù : SizeOf C\nbase : C\nfiber : ‚Üë(F.obj base)\n‚ä¢ Eq (SizeOf.sizeOf { base := base, fiber := fiber }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf base)) (SizeOf.sizeOf fiber))","decl":"/--\nThe Grothendieck construction (often written as `‚à´ F` in mathematics) for a functor `F : C ‚•§ Cat`\ngives a category whose\n* objects `X` consist of `X.base : C` and `X.fiber : F.obj base`\n* morphisms `f : X ‚ü∂ Y` consist of\n  `base : X.base ‚ü∂ Y.base` and\n  `f.fiber : (F.map base).obj X.fiber ‚ü∂ Y.fiber`\n-/\nstructure Grothendieck where\n  /-- The underlying object in `C` -/\n  base : C\n  /-- The object in the fiber of the base object. -/\n  fiber : F.obj base\n\n"}
{"name":"CategoryTheory.Grothendieck.mk.inj","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nbase‚úù : C\nfiber‚úù : ‚Üë(F.obj base‚úù)\nbase : C\nfiber : ‚Üë(F.obj base)\nx‚úù : Eq { base := base‚úù, fiber := fiber‚úù } { base := base, fiber := fiber }\n‚ä¢ And (Eq base‚úù base) (HEq fiber‚úù fiber)","decl":"/--\nThe Grothendieck construction (often written as `‚à´ F` in mathematics) for a functor `F : C ‚•§ Cat`\ngives a category whose\n* objects `X` consist of `X.base : C` and `X.fiber : F.obj base`\n* morphisms `f : X ‚ü∂ Y` consist of\n  `base : X.base ‚ü∂ Y.base` and\n  `f.fiber : (F.map base).obj X.fiber ‚ü∂ Y.fiber`\n-/\nstructure Grothendieck where\n  /-- The underlying object in `C` -/\n  base : C\n  /-- The object in the fiber of the base object. -/\n  fiber : F.obj base\n\n"}
{"name":"CategoryTheory.Grothendieck.mk.injEq","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nbase‚úù : C\nfiber‚úù : ‚Üë(F.obj base‚úù)\nbase : C\nfiber : ‚Üë(F.obj base)\n‚ä¢ Eq (Eq { base := base‚úù, fiber := fiber‚úù } { base := base, fiber := fiber }) (And (Eq base‚úù base) (HEq fiber‚úù fiber))","decl":"/--\nThe Grothendieck construction (often written as `‚à´ F` in mathematics) for a functor `F : C ‚•§ Cat`\ngives a category whose\n* objects `X` consist of `X.base : C` and `X.fiber : F.obj base`\n* morphisms `f : X ‚ü∂ Y` consist of\n  `base : X.base ‚ü∂ Y.base` and\n  `f.fiber : (F.map base).obj X.fiber ‚ü∂ Y.fiber`\n-/\nstructure Grothendieck where\n  /-- The underlying object in `C` -/\n  base : C\n  /-- The object in the fiber of the base object. -/\n  fiber : F.obj base\n\n"}
{"name":"CategoryTheory.Grothendieck.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX Y : CategoryTheory.Grothendieck F\nbase‚úù : Quiver.Hom X.base Y.base\nfiber‚úù : Quiver.Hom ((F.map base‚úù).obj X.fiber) Y.fiber\nbase : Quiver.Hom X.base Y.base\nfiber : Quiver.Hom ((F.map base).obj X.fiber) Y.fiber\n‚ä¢ Eq (Eq { base := base‚úù, fiber := fiber‚úù } { base := base, fiber := fiber }) (And (Eq base‚úù base) (HEq fiber‚úù fiber))","decl":"/-- A morphism in the Grothendieck category `F : C ‚•§ Cat` consists of\n`base : X.base ‚ü∂ Y.base` and `f.fiber : (F.map base).obj X.fiber ‚ü∂ Y.fiber`.\n-/\nstructure Hom (X Y : Grothendieck F) where\n  /-- The morphism between base objects. -/\n  base : X.base ‚ü∂ Y.base\n  /-- The morphism from the pushforward to the source fiber object to the target fiber object. -/\n  fiber : (F.map base).obj X.fiber ‚ü∂ Y.fiber\n\n"}
{"name":"CategoryTheory.Grothendieck.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX Y : CategoryTheory.Grothendieck F\ninst‚úù : SizeOf C\nbase : Quiver.Hom X.base Y.base\nfiber : Quiver.Hom ((F.map base).obj X.fiber) Y.fiber\n‚ä¢ Eq (SizeOf.sizeOf { base := base, fiber := fiber }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf base)) (SizeOf.sizeOf fiber))","decl":"/-- A morphism in the Grothendieck category `F : C ‚•§ Cat` consists of\n`base : X.base ‚ü∂ Y.base` and `f.fiber : (F.map base).obj X.fiber ‚ü∂ Y.fiber`.\n-/\nstructure Hom (X Y : Grothendieck F) where\n  /-- The morphism between base objects. -/\n  base : X.base ‚ü∂ Y.base\n  /-- The morphism from the pushforward to the source fiber object to the target fiber object. -/\n  fiber : (F.map base).obj X.fiber ‚ü∂ Y.fiber\n\n"}
{"name":"CategoryTheory.Grothendieck.Hom.mk.inj","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX Y : CategoryTheory.Grothendieck F\nbase‚úù : Quiver.Hom X.base Y.base\nfiber‚úù : Quiver.Hom ((F.map base‚úù).obj X.fiber) Y.fiber\nbase : Quiver.Hom X.base Y.base\nfiber : Quiver.Hom ((F.map base).obj X.fiber) Y.fiber\nx‚úù : Eq { base := base‚úù, fiber := fiber‚úù } { base := base, fiber := fiber }\n‚ä¢ And (Eq base‚úù base) (HEq fiber‚úù fiber)","decl":"/-- A morphism in the Grothendieck category `F : C ‚•§ Cat` consists of\n`base : X.base ‚ü∂ Y.base` and `f.fiber : (F.map base).obj X.fiber ‚ü∂ Y.fiber`.\n-/\nstructure Hom (X Y : Grothendieck F) where\n  /-- The morphism between base objects. -/\n  base : X.base ‚ü∂ Y.base\n  /-- The morphism from the pushforward to the source fiber object to the target fiber object. -/\n  fiber : (F.map base).obj X.fiber ‚ü∂ Y.fiber\n\n"}
{"name":"CategoryTheory.Grothendieck.ext","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX Y : CategoryTheory.Grothendieck F\nf g : X.Hom Y\nw_base : Eq f.base g.base\nw_fiber : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) f.fiber) g.fiber\n‚ä¢ Eq f g","decl":"@[ext (iff := false)]\ntheorem ext {X Y : Grothendieck F} (f g : Hom X Y) (w_base : f.base = g.base)\n    (w_fiber : eqToHom (by rw [w_base]) ‚â´ f.fiber = g.fiber) : f = g := by\n  cases f; cases g\n  congr\n  dsimp at w_base\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Grothendieck.id_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX : CategoryTheory.Grothendieck F\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X).base (CategoryTheory.CategoryStruct.id X.base)","decl":"@[simp]\ntheorem id_base (X : Grothendieck F) :\n    Hom.base (ùüô X) = ùüô X.base := by\n  rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.id_fiber","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX : CategoryTheory.Grothendieck F\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X).fiber (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\ntheorem id_fiber (X : Grothendieck F) :\n    Hom.fiber (ùüô X) = eqToHom (by simp) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.comp_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX Y Z : CategoryTheory.Grothendieck F\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).base (CategoryTheory.CategoryStruct.comp f.base g.base)","decl":"@[simp]\ntheorem comp_base {X Y Z : Grothendieck F} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    (f ‚â´ g).base = f.base ‚â´ g.base :=\n  rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.comp_fiber","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX Y Z : CategoryTheory.Grothendieck F\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).fiber (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp ((F.map g.base).map f.fiber) g.fiber))","decl":"@[simp]\ntheorem comp_fiber {X Y Z : Grothendieck F} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    Hom.fiber (f ‚â´ g) =\n      eqToHom (by simp) ‚â´ (F.map g.base).map f.fiber ‚â´ g.fiber :=\n  rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.congr","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX Y : CategoryTheory.Grothendieck F\nf g : Quiver.Hom X Y\nh : Eq f g\n‚ä¢ Eq f.fiber (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) g.fiber)","decl":"theorem congr {X Y : Grothendieck F} {f g : X ‚ü∂ Y} (h : f = g) :\n    f.fiber = eqToHom (by subst h; rfl) ‚â´ g.fiber := by\n  subst h\n  dsimp\n  simp\n\n"}
{"name":"CategoryTheory.Grothendieck.base_eqToHom","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX Y : CategoryTheory.Grothendieck F\nh : Eq X Y\n‚ä¢ Eq (CategoryTheory.eqToHom h).base (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\ntheorem base_eqToHom {X Y : Grothendieck F} (h : X = Y) :\n    (eqToHom h).base = eqToHom (congrArg Grothendieck.base h) := by subst h; rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.fiber_eqToHom","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX Y : CategoryTheory.Grothendieck F\nh : Eq X Y\n‚ä¢ Eq (CategoryTheory.eqToHom h).fiber (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\ntheorem fiber_eqToHom {X Y : Grothendieck F} (h : X = Y) :\n    (eqToHom h).fiber = eqToHom (by subst h; simp) := by subst h; rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.eqToHom_eq","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX Y : CategoryTheory.Grothendieck F\nhF : Eq X Y\n‚ä¢ Eq (CategoryTheory.eqToHom hF) { base := CategoryTheory.eqToHom ‚ãØ, fiber := CategoryTheory.eqToHom ‚ãØ }","decl":"lemma eqToHom_eq {X Y : Grothendieck F} (hF : X = Y) :\n    eqToHom hF = { base := eqToHom (by subst hF; rfl), fiber := eqToHom (by subst hF; simp) } := by\n  subst hF\n  rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.transport_fiber","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nx : CategoryTheory.Grothendieck F\nc : C\nt : Quiver.Hom x.base c\n‚ä¢ Eq (x.transport t).fiber ((F.map t).obj x.fiber)","decl":"/--\nIf `F : C ‚•§ Cat` is a functor and `t : c ‚ü∂ d` is a morphism in `C`, then `transport` maps each\n`c`-based element of `Grothendieck F` to a `d`-based element.\n-/\n@[simps]\ndef transport (x : Grothendieck F) {c : C} (t : x.base ‚ü∂ c) : Grothendieck F :=\n  ‚ü®c, (F.map t).obj x.fiber‚ü©\n\n"}
{"name":"CategoryTheory.Grothendieck.transport_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nx : CategoryTheory.Grothendieck F\nc : C\nt : Quiver.Hom x.base c\n‚ä¢ Eq (x.transport t).base c","decl":"/--\nIf `F : C ‚•§ Cat` is a functor and `t : c ‚ü∂ d` is a morphism in `C`, then `transport` maps each\n`c`-based element of `Grothendieck F` to a `d`-based element.\n-/\n@[simps]\ndef transport (x : Grothendieck F) {c : C} (t : x.base ‚ü∂ c) : Grothendieck F :=\n  ‚ü®c, (F.map t).obj x.fiber‚ü©\n\n"}
{"name":"CategoryTheory.Grothendieck.toTransport_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nx : CategoryTheory.Grothendieck F\nc : C\nt : Quiver.Hom x.base c\n‚ä¢ Eq (x.toTransport t).base t","decl":"/--\nIf `F : C ‚•§ Cat` is a functor and `t : c ‚ü∂ d` is a morphism in `C`, then `transport` maps each\n`c`-based element `x` of `Grothendieck F` to a `d`-based element `x.transport t`.\n\n`transport_hom` is the morphism `x ‚ü∂ x.transport t` induced by `t` and the identity on fibers.\n-/\n@[simps]\ndef toTransport (x : Grothendieck F) {c : C} (t : x.base ‚ü∂ c) : x ‚ü∂ x.transport t :=\n  ‚ü®t, ùüô _‚ü©\n\n"}
{"name":"CategoryTheory.Grothendieck.toTransport_fiber","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nx : CategoryTheory.Grothendieck F\nc : C\nt : Quiver.Hom x.base c\n‚ä¢ Eq (x.toTransport t).fiber (CategoryTheory.CategoryStruct.id ((F.map t).obj x.fiber))","decl":"/--\nIf `F : C ‚•§ Cat` is a functor and `t : c ‚ü∂ d` is a morphism in `C`, then `transport` maps each\n`c`-based element `x` of `Grothendieck F` to a `d`-based element `x.transport t`.\n\n`transport_hom` is the morphism `x ‚ü∂ x.transport t` induced by `t` and the identity on fibers.\n-/\n@[simps]\ndef toTransport (x : Grothendieck F) {c : C} (t : x.base ‚ü∂ c) : x ‚ü∂ x.transport t :=\n  ‚ü®t, ùüô _‚ü©\n\n"}
{"name":"CategoryTheory.Grothendieck.isoMk_hom_fiber","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX Y : CategoryTheory.Grothendieck F\ne‚ÇÅ : CategoryTheory.Iso X.base Y.base\ne‚ÇÇ : CategoryTheory.Iso ((F.map e‚ÇÅ.hom).obj X.fiber) Y.fiber\n‚ä¢ Eq (CategoryTheory.Grothendieck.isoMk e‚ÇÅ e‚ÇÇ).hom.fiber e‚ÇÇ.hom","decl":"/--\nConstruct an isomorphism in a Grothendieck construction from isomorphisms in its base and fiber.\n-/\n@[simps]\ndef isoMk {X Y : Grothendieck F} (e‚ÇÅ : X.base ‚âÖ Y.base)\n    (e‚ÇÇ : (F.map e‚ÇÅ.hom).obj X.fiber ‚âÖ Y.fiber) :\n    X ‚âÖ Y where\n  hom := ‚ü®e‚ÇÅ.hom, e‚ÇÇ.hom‚ü©\n  inv := ‚ü®e‚ÇÅ.inv, (F.map e‚ÇÅ.inv).map e‚ÇÇ.inv ‚â´\n    eqToHom (Functor.congr_obj (F.mapIso e‚ÇÅ).hom_inv_id X.fiber)‚ü©\n  hom_inv_id := Grothendieck.ext _ _ (by simp) (by simp)\n  inv_hom_id := Grothendieck.ext _ _ (by simp) (by\n    have := Functor.congr_hom (F.mapIso e‚ÇÅ).inv_hom_id e‚ÇÇ.inv\n    dsimp at this\n    simp [this])\n\n"}
{"name":"CategoryTheory.Grothendieck.isoMk_inv_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX Y : CategoryTheory.Grothendieck F\ne‚ÇÅ : CategoryTheory.Iso X.base Y.base\ne‚ÇÇ : CategoryTheory.Iso ((F.map e‚ÇÅ.hom).obj X.fiber) Y.fiber\n‚ä¢ Eq (CategoryTheory.Grothendieck.isoMk e‚ÇÅ e‚ÇÇ).inv.base e‚ÇÅ.inv","decl":"/--\nConstruct an isomorphism in a Grothendieck construction from isomorphisms in its base and fiber.\n-/\n@[simps]\ndef isoMk {X Y : Grothendieck F} (e‚ÇÅ : X.base ‚âÖ Y.base)\n    (e‚ÇÇ : (F.map e‚ÇÅ.hom).obj X.fiber ‚âÖ Y.fiber) :\n    X ‚âÖ Y where\n  hom := ‚ü®e‚ÇÅ.hom, e‚ÇÇ.hom‚ü©\n  inv := ‚ü®e‚ÇÅ.inv, (F.map e‚ÇÅ.inv).map e‚ÇÇ.inv ‚â´\n    eqToHom (Functor.congr_obj (F.mapIso e‚ÇÅ).hom_inv_id X.fiber)‚ü©\n  hom_inv_id := Grothendieck.ext _ _ (by simp) (by simp)\n  inv_hom_id := Grothendieck.ext _ _ (by simp) (by\n    have := Functor.congr_hom (F.mapIso e‚ÇÅ).inv_hom_id e‚ÇÇ.inv\n    dsimp at this\n    simp [this])\n\n"}
{"name":"CategoryTheory.Grothendieck.isoMk_inv_fiber","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX Y : CategoryTheory.Grothendieck F\ne‚ÇÅ : CategoryTheory.Iso X.base Y.base\ne‚ÇÇ : CategoryTheory.Iso ((F.map e‚ÇÅ.hom).obj X.fiber) Y.fiber\n‚ä¢ Eq (CategoryTheory.Grothendieck.isoMk e‚ÇÅ e‚ÇÇ).inv.fiber (CategoryTheory.CategoryStruct.comp ((F.map e‚ÇÅ.inv).map e‚ÇÇ.inv) (CategoryTheory.eqToHom ‚ãØ))","decl":"/--\nConstruct an isomorphism in a Grothendieck construction from isomorphisms in its base and fiber.\n-/\n@[simps]\ndef isoMk {X Y : Grothendieck F} (e‚ÇÅ : X.base ‚âÖ Y.base)\n    (e‚ÇÇ : (F.map e‚ÇÅ.hom).obj X.fiber ‚âÖ Y.fiber) :\n    X ‚âÖ Y where\n  hom := ‚ü®e‚ÇÅ.hom, e‚ÇÇ.hom‚ü©\n  inv := ‚ü®e‚ÇÅ.inv, (F.map e‚ÇÅ.inv).map e‚ÇÇ.inv ‚â´\n    eqToHom (Functor.congr_obj (F.mapIso e‚ÇÅ).hom_inv_id X.fiber)‚ü©\n  hom_inv_id := Grothendieck.ext _ _ (by simp) (by simp)\n  inv_hom_id := Grothendieck.ext _ _ (by simp) (by\n    have := Functor.congr_hom (F.mapIso e‚ÇÅ).inv_hom_id e‚ÇÇ.inv\n    dsimp at this\n    simp [this])\n\n"}
{"name":"CategoryTheory.Grothendieck.isoMk_hom_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX Y : CategoryTheory.Grothendieck F\ne‚ÇÅ : CategoryTheory.Iso X.base Y.base\ne‚ÇÇ : CategoryTheory.Iso ((F.map e‚ÇÅ.hom).obj X.fiber) Y.fiber\n‚ä¢ Eq (CategoryTheory.Grothendieck.isoMk e‚ÇÅ e‚ÇÇ).hom.base e‚ÇÅ.hom","decl":"/--\nConstruct an isomorphism in a Grothendieck construction from isomorphisms in its base and fiber.\n-/\n@[simps]\ndef isoMk {X Y : Grothendieck F} (e‚ÇÅ : X.base ‚âÖ Y.base)\n    (e‚ÇÇ : (F.map e‚ÇÅ.hom).obj X.fiber ‚âÖ Y.fiber) :\n    X ‚âÖ Y where\n  hom := ‚ü®e‚ÇÅ.hom, e‚ÇÇ.hom‚ü©\n  inv := ‚ü®e‚ÇÅ.inv, (F.map e‚ÇÅ.inv).map e‚ÇÇ.inv ‚â´\n    eqToHom (Functor.congr_obj (F.mapIso e‚ÇÅ).hom_inv_id X.fiber)‚ü©\n  hom_inv_id := Grothendieck.ext _ _ (by simp) (by simp)\n  inv_hom_id := Grothendieck.ext _ _ (by simp) (by\n    have := Functor.congr_hom (F.mapIso e‚ÇÅ).inv_hom_id e‚ÇÇ.inv\n    dsimp at this\n    simp [this])\n\n"}
{"name":"CategoryTheory.Grothendieck.transportIso_inv_fiber","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nx : CategoryTheory.Grothendieck F\nc : C\nŒ± : CategoryTheory.Iso x.base c\n‚ä¢ Eq (x.transportIso Œ±).inv.fiber (CategoryTheory.CategoryStruct.id ((F.map Œ±.hom).obj x.fiber))","decl":"/--\nIf `F : C ‚•§ Cat` and `x : Grothendieck F`, then every `C`-isomorphism `Œ± : x.base ‚âÖ c` induces\nan isomorphism between `x` and its transport along `Œ±`\n-/\n@[simps!]\ndef transportIso (x : Grothendieck F) {c : C} (Œ± : x.base ‚âÖ c) :\n    x.transport Œ±.hom ‚âÖ x := (isoMk Œ± (Iso.refl _)).symm\n\n"}
{"name":"CategoryTheory.Grothendieck.transportIso_hom_fiber","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nx : CategoryTheory.Grothendieck F\nc : C\nŒ± : CategoryTheory.Iso x.base c\n‚ä¢ Eq (x.transportIso Œ±).hom.fiber (CategoryTheory.eqToHom ‚ãØ)","decl":"/--\nIf `F : C ‚•§ Cat` and `x : Grothendieck F`, then every `C`-isomorphism `Œ± : x.base ‚âÖ c` induces\nan isomorphism between `x` and its transport along `Œ±`\n-/\n@[simps!]\ndef transportIso (x : Grothendieck F) {c : C} (Œ± : x.base ‚âÖ c) :\n    x.transport Œ±.hom ‚âÖ x := (isoMk Œ± (Iso.refl _)).symm\n\n"}
{"name":"CategoryTheory.Grothendieck.transportIso_hom_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nx : CategoryTheory.Grothendieck F\nc : C\nŒ± : CategoryTheory.Iso x.base c\n‚ä¢ Eq (x.transportIso Œ±).hom.base Œ±.inv","decl":"/--\nIf `F : C ‚•§ Cat` and `x : Grothendieck F`, then every `C`-isomorphism `Œ± : x.base ‚âÖ c` induces\nan isomorphism between `x` and its transport along `Œ±`\n-/\n@[simps!]\ndef transportIso (x : Grothendieck F) {c : C} (Œ± : x.base ‚âÖ c) :\n    x.transport Œ±.hom ‚âÖ x := (isoMk Œ± (Iso.refl _)).symm\n\n"}
{"name":"CategoryTheory.Grothendieck.transportIso_inv_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nx : CategoryTheory.Grothendieck F\nc : C\nŒ± : CategoryTheory.Iso x.base c\n‚ä¢ Eq (x.transportIso Œ±).inv.base Œ±.hom","decl":"/--\nIf `F : C ‚•§ Cat` and `x : Grothendieck F`, then every `C`-isomorphism `Œ± : x.base ‚âÖ c` induces\nan isomorphism between `x` and its transport along `Œ±`\n-/\n@[simps!]\ndef transportIso (x : Grothendieck F) {c : C} (Œ± : x.base ‚âÖ c) :\n    x.transport Œ±.hom ‚âÖ x := (isoMk Œ± (Iso.refl _)).symm\n\n"}
{"name":"CategoryTheory.Grothendieck.forget_obj","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX : CategoryTheory.Grothendieck F\n‚ä¢ Eq ((CategoryTheory.Grothendieck.forget F).obj X) X.base","decl":"/-- The forgetful functor from `Grothendieck F` to the source category. -/\n@[simps!]\ndef forget : Grothendieck F ‚•§ C where\n  obj X := X.1\n  map f := f.1\n\n"}
{"name":"CategoryTheory.Grothendieck.forget_map","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX‚úù Y‚úù : CategoryTheory.Grothendieck F\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Grothendieck.forget F).map f) f.base","decl":"/-- The forgetful functor from `Grothendieck F` to the source category. -/\n@[simps!]\ndef forget : Grothendieck F ‚•§ C where\n  obj X := X.1\n  map f := f.1\n\n"}
{"name":"CategoryTheory.Grothendieck.map_map_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C CategoryTheory.Cat\nŒ± : Quiver.Hom F G\nX Y : CategoryTheory.Grothendieck F\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Grothendieck.map Œ±).map f).base f.base","decl":"/-- The Grothendieck construction is functorial: a natural transformation `Œ± : F ‚ü∂ G` induces\na functor `Grothendieck.map : Grothendieck F ‚•§ Grothendieck G`.\n-/\n@[simps!]\ndef map (Œ± : F ‚ü∂ G) : Grothendieck F ‚•§ Grothendieck G where\n  obj X :=\n  { base := X.base\n    fiber := (Œ±.app X.base).obj X.fiber }\n  map {X Y} f :=\n  { base := f.base\n    fiber := (eqToHom (Œ±.naturality f.base).symm).app X.fiber ‚â´ (Œ±.app Y.base).map f.fiber }\n  map_id X := by simp only [Cat.eqToHom_app, id_fiber, eqToHom_map, eqToHom_trans]; rfl\n  map_comp {X Y Z} f g := by\n    dsimp\n    congr 1\n    simp only [comp_fiber f g, ‚Üê Category.assoc, Functor.map_comp, eqToHom_map]\n    congr 1\n    simp only [Cat.eqToHom_app, Cat.comp_obj, eqToHom_trans, eqToHom_map, Category.assoc]\n    erw [Functor.congr_hom (Œ±.naturality g.base).symm f.fiber]\n    simp\n\n"}
{"name":"CategoryTheory.Grothendieck.map_obj_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C CategoryTheory.Cat\nŒ± : Quiver.Hom F G\nX : CategoryTheory.Grothendieck F\n‚ä¢ Eq ((CategoryTheory.Grothendieck.map Œ±).obj X).base X.base","decl":"/-- The Grothendieck construction is functorial: a natural transformation `Œ± : F ‚ü∂ G` induces\na functor `Grothendieck.map : Grothendieck F ‚•§ Grothendieck G`.\n-/\n@[simps!]\ndef map (Œ± : F ‚ü∂ G) : Grothendieck F ‚•§ Grothendieck G where\n  obj X :=\n  { base := X.base\n    fiber := (Œ±.app X.base).obj X.fiber }\n  map {X Y} f :=\n  { base := f.base\n    fiber := (eqToHom (Œ±.naturality f.base).symm).app X.fiber ‚â´ (Œ±.app Y.base).map f.fiber }\n  map_id X := by simp only [Cat.eqToHom_app, id_fiber, eqToHom_map, eqToHom_trans]; rfl\n  map_comp {X Y Z} f g := by\n    dsimp\n    congr 1\n    simp only [comp_fiber f g, ‚Üê Category.assoc, Functor.map_comp, eqToHom_map]\n    congr 1\n    simp only [Cat.eqToHom_app, Cat.comp_obj, eqToHom_trans, eqToHom_map, Category.assoc]\n    erw [Functor.congr_hom (Œ±.naturality g.base).symm f.fiber]\n    simp\n\n"}
{"name":"CategoryTheory.Grothendieck.map_map_fiber","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C CategoryTheory.Cat\nŒ± : Quiver.Hom F G\nX Y : CategoryTheory.Grothendieck F\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Grothendieck.map Œ±).map f).fiber (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) ((Œ±.app Y.base).map f.fiber))","decl":"/-- The Grothendieck construction is functorial: a natural transformation `Œ± : F ‚ü∂ G` induces\na functor `Grothendieck.map : Grothendieck F ‚•§ Grothendieck G`.\n-/\n@[simps!]\ndef map (Œ± : F ‚ü∂ G) : Grothendieck F ‚•§ Grothendieck G where\n  obj X :=\n  { base := X.base\n    fiber := (Œ±.app X.base).obj X.fiber }\n  map {X Y} f :=\n  { base := f.base\n    fiber := (eqToHom (Œ±.naturality f.base).symm).app X.fiber ‚â´ (Œ±.app Y.base).map f.fiber }\n  map_id X := by simp only [Cat.eqToHom_app, id_fiber, eqToHom_map, eqToHom_trans]; rfl\n  map_comp {X Y Z} f g := by\n    dsimp\n    congr 1\n    simp only [comp_fiber f g, ‚Üê Category.assoc, Functor.map_comp, eqToHom_map]\n    congr 1\n    simp only [Cat.eqToHom_app, Cat.comp_obj, eqToHom_trans, eqToHom_map, Category.assoc]\n    erw [Functor.congr_hom (Œ±.naturality g.base).symm f.fiber]\n    simp\n\n"}
{"name":"CategoryTheory.Grothendieck.map_obj_fiber","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C CategoryTheory.Cat\nŒ± : Quiver.Hom F G\nX : CategoryTheory.Grothendieck F\n‚ä¢ Eq ((CategoryTheory.Grothendieck.map Œ±).obj X).fiber ((Œ±.app X.base).obj X.fiber)","decl":"/-- The Grothendieck construction is functorial: a natural transformation `Œ± : F ‚ü∂ G` induces\na functor `Grothendieck.map : Grothendieck F ‚•§ Grothendieck G`.\n-/\n@[simps!]\ndef map (Œ± : F ‚ü∂ G) : Grothendieck F ‚•§ Grothendieck G where\n  obj X :=\n  { base := X.base\n    fiber := (Œ±.app X.base).obj X.fiber }\n  map {X Y} f :=\n  { base := f.base\n    fiber := (eqToHom (Œ±.naturality f.base).symm).app X.fiber ‚â´ (Œ±.app Y.base).map f.fiber }\n  map_id X := by simp only [Cat.eqToHom_app, id_fiber, eqToHom_map, eqToHom_trans]; rfl\n  map_comp {X Y Z} f g := by\n    dsimp\n    congr 1\n    simp only [comp_fiber f g, ‚Üê Category.assoc, Functor.map_comp, eqToHom_map]\n    congr 1\n    simp only [Cat.eqToHom_app, Cat.comp_obj, eqToHom_trans, eqToHom_map, Category.assoc]\n    erw [Functor.congr_hom (Œ±.naturality g.base).symm f.fiber]\n    simp\n\n"}
{"name":"CategoryTheory.Grothendieck.map_obj","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C CategoryTheory.Cat\nŒ± : Quiver.Hom F G\nX : CategoryTheory.Grothendieck F\n‚ä¢ Eq ((CategoryTheory.Grothendieck.map Œ±).obj X) { base := X.base, fiber := (Œ±.app X.base).obj X.fiber }","decl":"theorem map_obj {Œ± : F ‚ü∂ G} (X : Grothendieck F) :\n    (Grothendieck.map Œ±).obj X = ‚ü®X.base, (Œ±.app X.base).obj X.fiber‚ü© := rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.map_map","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C CategoryTheory.Cat\nŒ± : Quiver.Hom F G\nX Y : CategoryTheory.Grothendieck F\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Grothendieck.map Œ±).map f) { base := f.base, fiber := CategoryTheory.CategoryStruct.comp ((CategoryTheory.eqToHom ‚ãØ).app X.fiber) ((Œ±.app Y.base).map f.fiber) }","decl":"theorem map_map {Œ± : F ‚ü∂ G} {X Y : Grothendieck F} {f : X ‚ü∂ Y} :\n    (Grothendieck.map Œ±).map f =\n    ‚ü®f.base, (eqToHom (Œ±.naturality f.base).symm).app X.fiber ‚â´ (Œ±.app Y.base).map f.fiber‚ü© := rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.functor_comp_forget","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C CategoryTheory.Cat\nŒ± : Quiver.Hom F G\n‚ä¢ Eq ((CategoryTheory.Grothendieck.map Œ±).comp (CategoryTheory.Grothendieck.forget G)) (CategoryTheory.Grothendieck.forget F)","decl":"/-- The functor `Grothendieck.map Œ± : Grothendieck F ‚•§ Grothendieck G` lies over `C`.-/\ntheorem functor_comp_forget {Œ± : F ‚ü∂ G} :\n    Grothendieck.map Œ± ‚ãô Grothendieck.forget G = Grothendieck.forget F := rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.map_id_eq","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\n‚ä¢ Eq (CategoryTheory.Grothendieck.map (CategoryTheory.CategoryStruct.id F)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Cat.of (CategoryTheory.Grothendieck F)))","decl":"theorem map_id_eq : map (ùüô F) = ùüô (Cat.of <| Grothendieck <| F) := by\n  fapply Functor.ext\n  ¬∑ intro X\n    rfl\n  ¬∑ intro X Y f\n    simp [map_map]\n    rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.map_comp_eq","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G H : CategoryTheory.Functor C CategoryTheory.Cat\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\n‚ä¢ Eq (CategoryTheory.Grothendieck.map (CategoryTheory.CategoryStruct.comp Œ± Œ≤)) ((CategoryTheory.Grothendieck.map Œ±).comp (CategoryTheory.Grothendieck.map Œ≤))","decl":"theorem map_comp_eq (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) :\n    map (Œ± ‚â´ Œ≤) = map Œ± ‚ãô map Œ≤ := by\n  fapply Functor.ext\n  ¬∑ intro X\n    rfl\n  ¬∑ intro X Y f\n    simp only [map_map, map_obj_base, NatTrans.comp_app, Cat.comp_obj, Cat.comp_map,\n      eqToHom_refl, Functor.comp_map, Functor.map_comp, Category.comp_id, Category.id_comp]\n    fapply Grothendieck.ext\n    ¬∑ rfl\n    ¬∑ simp\n\n"}
{"name":"CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceInverse_map_fiber","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX‚úù Y‚úù : CategoryTheory.Grothendieck F\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceInverse F).map f).fiber (CategoryTheory.AsSmall.up.map f.fiber)","decl":"/-- The inverse functor to build the equivalence `compAsSmallFunctorEquivalence`. -/\n@[simps]\ndef compAsSmallFunctorEquivalenceInverse :\n    Grothendieck F ‚•§ Grothendieck (F ‚ãô Cat.asSmallFunctor.{w}) where\n  obj X := ‚ü®X.base, AsSmall.up.obj X.fiber‚ü©\n  map f := ‚ü®f.base, AsSmall.up.map f.fiber‚ü©\n\n"}
{"name":"CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceInverse_obj_fiber","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX : CategoryTheory.Grothendieck F\n‚ä¢ Eq ((CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceInverse F).obj X).fiber (CategoryTheory.AsSmall.up.obj X.fiber)","decl":"/-- The inverse functor to build the equivalence `compAsSmallFunctorEquivalence`. -/\n@[simps]\ndef compAsSmallFunctorEquivalenceInverse :\n    Grothendieck F ‚•§ Grothendieck (F ‚ãô Cat.asSmallFunctor.{w}) where\n  obj X := ‚ü®X.base, AsSmall.up.obj X.fiber‚ü©\n  map f := ‚ü®f.base, AsSmall.up.map f.fiber‚ü©\n\n"}
{"name":"CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceInverse_map_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX‚úù Y‚úù : CategoryTheory.Grothendieck F\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceInverse F).map f).base f.base","decl":"/-- The inverse functor to build the equivalence `compAsSmallFunctorEquivalence`. -/\n@[simps]\ndef compAsSmallFunctorEquivalenceInverse :\n    Grothendieck F ‚•§ Grothendieck (F ‚ãô Cat.asSmallFunctor.{w}) where\n  obj X := ‚ü®X.base, AsSmall.up.obj X.fiber‚ü©\n  map f := ‚ü®f.base, AsSmall.up.map f.fiber‚ü©\n\n"}
{"name":"CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceInverse_obj_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX : CategoryTheory.Grothendieck F\n‚ä¢ Eq ((CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceInverse F).obj X).base X.base","decl":"/-- The inverse functor to build the equivalence `compAsSmallFunctorEquivalence`. -/\n@[simps]\ndef compAsSmallFunctorEquivalenceInverse :\n    Grothendieck F ‚•§ Grothendieck (F ‚ãô Cat.asSmallFunctor.{w}) where\n  obj X := ‚ü®X.base, AsSmall.up.obj X.fiber‚ü©\n  map f := ‚ü®f.base, AsSmall.up.map f.fiber‚ü©\n\n"}
{"name":"CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceFunctor_obj_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX : CategoryTheory.Grothendieck (F.comp CategoryTheory.Cat.asSmallFunctor)\n‚ä¢ Eq ((CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceFunctor F).obj X).base X.base","decl":"/-- The functor to build the equivalence `compAsSmallFunctorEquivalence`. -/\n@[simps]\ndef compAsSmallFunctorEquivalenceFunctor :\n    Grothendieck (F ‚ãô Cat.asSmallFunctor.{w}) ‚•§ Grothendieck F where\n  obj X := ‚ü®X.base, AsSmall.down.obj X.fiber‚ü©\n  map f := ‚ü®f.base, AsSmall.down.map f.fiber‚ü©\n  map_id _ := by apply Grothendieck.ext <;> simp\n  map_comp _ _ := by apply Grothendieck.ext <;> simp [down_comp]\n\n"}
{"name":"CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceFunctor_map_fiber","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX‚úù Y‚úù : CategoryTheory.Grothendieck (F.comp CategoryTheory.Cat.asSmallFunctor)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceFunctor F).map f).fiber (CategoryTheory.AsSmall.down.map f.fiber)","decl":"/-- The functor to build the equivalence `compAsSmallFunctorEquivalence`. -/\n@[simps]\ndef compAsSmallFunctorEquivalenceFunctor :\n    Grothendieck (F ‚ãô Cat.asSmallFunctor.{w}) ‚•§ Grothendieck F where\n  obj X := ‚ü®X.base, AsSmall.down.obj X.fiber‚ü©\n  map f := ‚ü®f.base, AsSmall.down.map f.fiber‚ü©\n  map_id _ := by apply Grothendieck.ext <;> simp\n  map_comp _ _ := by apply Grothendieck.ext <;> simp [down_comp]\n\n"}
{"name":"CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceFunctor_map_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX‚úù Y‚úù : CategoryTheory.Grothendieck (F.comp CategoryTheory.Cat.asSmallFunctor)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceFunctor F).map f).base f.base","decl":"/-- The functor to build the equivalence `compAsSmallFunctorEquivalence`. -/\n@[simps]\ndef compAsSmallFunctorEquivalenceFunctor :\n    Grothendieck (F ‚ãô Cat.asSmallFunctor.{w}) ‚•§ Grothendieck F where\n  obj X := ‚ü®X.base, AsSmall.down.obj X.fiber‚ü©\n  map f := ‚ü®f.base, AsSmall.down.map f.fiber‚ü©\n  map_id _ := by apply Grothendieck.ext <;> simp\n  map_comp _ _ := by apply Grothendieck.ext <;> simp [down_comp]\n\n"}
{"name":"CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceFunctor_obj_fiber","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX : CategoryTheory.Grothendieck (F.comp CategoryTheory.Cat.asSmallFunctor)\n‚ä¢ Eq ((CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceFunctor F).obj X).fiber (CategoryTheory.AsSmall.down.obj X.fiber)","decl":"/-- The functor to build the equivalence `compAsSmallFunctorEquivalence`. -/\n@[simps]\ndef compAsSmallFunctorEquivalenceFunctor :\n    Grothendieck (F ‚ãô Cat.asSmallFunctor.{w}) ‚•§ Grothendieck F where\n  obj X := ‚ü®X.base, AsSmall.down.obj X.fiber‚ü©\n  map f := ‚ü®f.base, AsSmall.down.map f.fiber‚ü©\n  map_id _ := by apply Grothendieck.ext <;> simp\n  map_comp _ _ := by apply Grothendieck.ext <;> simp [down_comp]\n\n"}
{"name":"CategoryTheory.Grothendieck.compAsSmallFunctorEquivalence_counitIso","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\n‚ä¢ Eq (CategoryTheory.Grothendieck.compAsSmallFunctorEquivalence F).counitIso (CategoryTheory.Iso.refl ((CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceInverse F).comp (CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceFunctor F)))","decl":"/-- Taking the Grothendieck construction on `F ‚ãô asSmallFunctor`, where\n`asSmallFunctor : Cat ‚•§ Cat` is the functor which turns each category into a small category of a\n(potentiall) larger universe, is equivalent to the Grothendieck construction on `F` itself. -/\n@[simps]\ndef compAsSmallFunctorEquivalence :\n    Grothendieck (F ‚ãô Cat.asSmallFunctor.{w}) ‚âå Grothendieck F where\n  functor := compAsSmallFunctorEquivalenceFunctor F\n  inverse := compAsSmallFunctorEquivalenceInverse F\n  counitIso := Iso.refl _\n  unitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Grothendieck.compAsSmallFunctorEquivalence_functor","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\n‚ä¢ Eq (CategoryTheory.Grothendieck.compAsSmallFunctorEquivalence F).functor (CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceFunctor F)","decl":"/-- Taking the Grothendieck construction on `F ‚ãô asSmallFunctor`, where\n`asSmallFunctor : Cat ‚•§ Cat` is the functor which turns each category into a small category of a\n(potentiall) larger universe, is equivalent to the Grothendieck construction on `F` itself. -/\n@[simps]\ndef compAsSmallFunctorEquivalence :\n    Grothendieck (F ‚ãô Cat.asSmallFunctor.{w}) ‚âå Grothendieck F where\n  functor := compAsSmallFunctorEquivalenceFunctor F\n  inverse := compAsSmallFunctorEquivalenceInverse F\n  counitIso := Iso.refl _\n  unitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Grothendieck.compAsSmallFunctorEquivalence_unitIso","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\n‚ä¢ Eq (CategoryTheory.Grothendieck.compAsSmallFunctorEquivalence F).unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (CategoryTheory.Grothendieck (F.comp CategoryTheory.Cat.asSmallFunctor))))","decl":"/-- Taking the Grothendieck construction on `F ‚ãô asSmallFunctor`, where\n`asSmallFunctor : Cat ‚•§ Cat` is the functor which turns each category into a small category of a\n(potentiall) larger universe, is equivalent to the Grothendieck construction on `F` itself. -/\n@[simps]\ndef compAsSmallFunctorEquivalence :\n    Grothendieck (F ‚ãô Cat.asSmallFunctor.{w}) ‚âå Grothendieck F where\n  functor := compAsSmallFunctorEquivalenceFunctor F\n  inverse := compAsSmallFunctorEquivalenceInverse F\n  counitIso := Iso.refl _\n  unitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Grothendieck.compAsSmallFunctorEquivalence_inverse","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\n‚ä¢ Eq (CategoryTheory.Grothendieck.compAsSmallFunctorEquivalence F).inverse (CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceInverse F)","decl":"/-- Taking the Grothendieck construction on `F ‚ãô asSmallFunctor`, where\n`asSmallFunctor : Cat ‚•§ Cat` is the functor which turns each category into a small category of a\n(potentiall) larger universe, is equivalent to the Grothendieck construction on `F` itself. -/\n@[simps]\ndef compAsSmallFunctorEquivalence :\n    Grothendieck (F ‚ãô Cat.asSmallFunctor.{w}) ‚âå Grothendieck F where\n  functor := compAsSmallFunctorEquivalenceFunctor F\n  inverse := compAsSmallFunctorEquivalenceInverse F\n  counitIso := Iso.refl _\n  unitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Grothendieck.grothendieckTypeToCatFunctor_obj_snd","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nG : CategoryTheory.Functor C (Type w)\nX : CategoryTheory.Grothendieck (G.comp CategoryTheory.typeToCat)\n‚ä¢ Eq ((CategoryTheory.Grothendieck.grothendieckTypeToCatFunctor G).obj X).snd X.fiber.as","decl":"/-- Auxiliary definition for `grothendieckTypeToCat`, to speed up elaboration. -/\n@[simps!]\ndef grothendieckTypeToCatFunctor : Grothendieck (G ‚ãô typeToCat) ‚•§ G.Elements where\n  obj X := ‚ü®X.1, X.2.as‚ü©\n  map f := ‚ü®f.1, f.2.1.1‚ü©\n\n"}
{"name":"CategoryTheory.Grothendieck.grothendieckTypeToCatFunctor_obj_fst","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nG : CategoryTheory.Functor C (Type w)\nX : CategoryTheory.Grothendieck (G.comp CategoryTheory.typeToCat)\n‚ä¢ Eq ((CategoryTheory.Grothendieck.grothendieckTypeToCatFunctor G).obj X).fst X.base","decl":"/-- Auxiliary definition for `grothendieckTypeToCat`, to speed up elaboration. -/\n@[simps!]\ndef grothendieckTypeToCatFunctor : Grothendieck (G ‚ãô typeToCat) ‚•§ G.Elements where\n  obj X := ‚ü®X.1, X.2.as‚ü©\n  map f := ‚ü®f.1, f.2.1.1‚ü©\n\n"}
{"name":"CategoryTheory.Grothendieck.grothendieckTypeToCatFunctor_map_coe","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nG : CategoryTheory.Functor C (Type w)\nX‚úù Y‚úù : CategoryTheory.Grothendieck (G.comp CategoryTheory.typeToCat)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (‚Üë((CategoryTheory.Grothendieck.grothendieckTypeToCatFunctor G).map f)) f.base","decl":"/-- Auxiliary definition for `grothendieckTypeToCat`, to speed up elaboration. -/\n@[simps!]\ndef grothendieckTypeToCatFunctor : Grothendieck (G ‚ãô typeToCat) ‚•§ G.Elements where\n  obj X := ‚ü®X.1, X.2.as‚ü©\n  map f := ‚ü®f.1, f.2.1.1‚ü©\n\n"}
{"name":"CategoryTheory.Grothendieck.grothendieckTypeToCatInverse_obj_fiber_as","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nG : CategoryTheory.Functor C (Type w)\nX : G.Elements\n‚ä¢ Eq ((CategoryTheory.Grothendieck.grothendieckTypeToCatInverse G).obj X).fiber.as X.snd","decl":"/-- Auxiliary definition for `grothendieckTypeToCat`, to speed up elaboration. -/\n-- Porting note:\n-- `simps` is incorrectly producing Prop-valued projections here,\n-- so we manually specify which ones to produce.\n-- See https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/!4.233204.20simps.20bug.20.28Grothendieck.20construction.29\n@[simps! obj_base obj_fiber_as map_base]\ndef grothendieckTypeToCatInverse : G.Elements ‚•§ Grothendieck (G ‚ãô typeToCat) where\n  obj X := ‚ü®X.1, ‚ü®X.2‚ü©‚ü©\n  map f := ‚ü®f.1, ‚ü®‚ü®f.2‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Grothendieck.grothendieckTypeToCatInverse_obj_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nG : CategoryTheory.Functor C (Type w)\nX : G.Elements\n‚ä¢ Eq ((CategoryTheory.Grothendieck.grothendieckTypeToCatInverse G).obj X).base X.fst","decl":"/-- Auxiliary definition for `grothendieckTypeToCat`, to speed up elaboration. -/\n-- Porting note:\n-- `simps` is incorrectly producing Prop-valued projections here,\n-- so we manually specify which ones to produce.\n-- See https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/!4.233204.20simps.20bug.20.28Grothendieck.20construction.29\n@[simps! obj_base obj_fiber_as map_base]\ndef grothendieckTypeToCatInverse : G.Elements ‚•§ Grothendieck (G ‚ãô typeToCat) where\n  obj X := ‚ü®X.1, ‚ü®X.2‚ü©‚ü©\n  map f := ‚ü®f.1, ‚ü®‚ü®f.2‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Grothendieck.grothendieckTypeToCatInverse_map_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nG : CategoryTheory.Functor C (Type w)\nX‚úù Y‚úù : G.Elements\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Grothendieck.grothendieckTypeToCatInverse G).map f).base ‚Üëf","decl":"/-- Auxiliary definition for `grothendieckTypeToCat`, to speed up elaboration. -/\n-- Porting note:\n-- `simps` is incorrectly producing Prop-valued projections here,\n-- so we manually specify which ones to produce.\n-- See https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/!4.233204.20simps.20bug.20.28Grothendieck.20construction.29\n@[simps! obj_base obj_fiber_as map_base]\ndef grothendieckTypeToCatInverse : G.Elements ‚•§ Grothendieck (G ‚ãô typeToCat) where\n  obj X := ‚ü®X.1, ‚ü®X.2‚ü©‚ü©\n  map f := ‚ü®f.1, ‚ü®‚ü®f.2‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Grothendieck.grothendieckTypeToCat_functor_map_coe","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nG : CategoryTheory.Functor C (Type w)\nX‚úù Y‚úù : CategoryTheory.Grothendieck (G.comp CategoryTheory.typeToCat)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (‚Üë((CategoryTheory.Grothendieck.grothendieckTypeToCat G).functor.map f)) f.base","decl":"/-- The Grothendieck construction applied to a functor to `Type`\n(thought of as a functor to `Cat` by realising a type as a discrete category)\nis the same as the 'category of elements' construction.\n-/\n-- See porting note on grothendieckTypeToCatInverse.\n-- We just want to turn off grothendieckTypeToCat_inverse_map_fiber_down_down,\n-- so have to list the complement here for `@[simps]`.\n@[simps! functor_obj_fst functor_obj_snd functor_map_coe inverse_obj_base inverse_obj_fiber_as\n  inverse_map_base unitIso_hom_app_base unitIso_hom_app_fiber unitIso_inv_app_base\n  unitIso_inv_app_fiber counitIso_hom_app_coe counitIso_inv_app_coe]\ndef grothendieckTypeToCat : Grothendieck (G ‚ãô typeToCat) ‚âå G.Elements where\n  functor := grothendieckTypeToCatFunctor G\n  inverse := grothendieckTypeToCatInverse G\n  unitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        rcases X with ‚ü®_, ‚ü®‚ü©‚ü©\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®base, ‚ü®‚ü®f‚ü©‚ü©‚ü©\n        dsimp at *\n        simp\n        rfl)\n  counitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        cases X\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®‚ü© ‚ü®‚ü© ‚ü®f, e‚ü©\n        dsimp at *\n        simp\n        rfl)\n  functor_unitIso_comp := by\n    rintro ‚ü®_, ‚ü®‚ü©‚ü©\n    dsimp\n    simp\n    rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.grothendieckTypeToCat_functor_obj_snd","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nG : CategoryTheory.Functor C (Type w)\nX : CategoryTheory.Grothendieck (G.comp CategoryTheory.typeToCat)\n‚ä¢ Eq ((CategoryTheory.Grothendieck.grothendieckTypeToCat G).functor.obj X).snd X.fiber.as","decl":"/-- The Grothendieck construction applied to a functor to `Type`\n(thought of as a functor to `Cat` by realising a type as a discrete category)\nis the same as the 'category of elements' construction.\n-/\n-- See porting note on grothendieckTypeToCatInverse.\n-- We just want to turn off grothendieckTypeToCat_inverse_map_fiber_down_down,\n-- so have to list the complement here for `@[simps]`.\n@[simps! functor_obj_fst functor_obj_snd functor_map_coe inverse_obj_base inverse_obj_fiber_as\n  inverse_map_base unitIso_hom_app_base unitIso_hom_app_fiber unitIso_inv_app_base\n  unitIso_inv_app_fiber counitIso_hom_app_coe counitIso_inv_app_coe]\ndef grothendieckTypeToCat : Grothendieck (G ‚ãô typeToCat) ‚âå G.Elements where\n  functor := grothendieckTypeToCatFunctor G\n  inverse := grothendieckTypeToCatInverse G\n  unitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        rcases X with ‚ü®_, ‚ü®‚ü©‚ü©\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®base, ‚ü®‚ü®f‚ü©‚ü©‚ü©\n        dsimp at *\n        simp\n        rfl)\n  counitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        cases X\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®‚ü© ‚ü®‚ü© ‚ü®f, e‚ü©\n        dsimp at *\n        simp\n        rfl)\n  functor_unitIso_comp := by\n    rintro ‚ü®_, ‚ü®‚ü©‚ü©\n    dsimp\n    simp\n    rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.grothendieckTypeToCat_inverse_obj_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nG : CategoryTheory.Functor C (Type w)\nX : G.Elements\n‚ä¢ Eq ((CategoryTheory.Grothendieck.grothendieckTypeToCat G).inverse.obj X).base X.fst","decl":"/-- The Grothendieck construction applied to a functor to `Type`\n(thought of as a functor to `Cat` by realising a type as a discrete category)\nis the same as the 'category of elements' construction.\n-/\n-- See porting note on grothendieckTypeToCatInverse.\n-- We just want to turn off grothendieckTypeToCat_inverse_map_fiber_down_down,\n-- so have to list the complement here for `@[simps]`.\n@[simps! functor_obj_fst functor_obj_snd functor_map_coe inverse_obj_base inverse_obj_fiber_as\n  inverse_map_base unitIso_hom_app_base unitIso_hom_app_fiber unitIso_inv_app_base\n  unitIso_inv_app_fiber counitIso_hom_app_coe counitIso_inv_app_coe]\ndef grothendieckTypeToCat : Grothendieck (G ‚ãô typeToCat) ‚âå G.Elements where\n  functor := grothendieckTypeToCatFunctor G\n  inverse := grothendieckTypeToCatInverse G\n  unitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        rcases X with ‚ü®_, ‚ü®‚ü©‚ü©\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®base, ‚ü®‚ü®f‚ü©‚ü©‚ü©\n        dsimp at *\n        simp\n        rfl)\n  counitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        cases X\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®‚ü© ‚ü®‚ü© ‚ü®f, e‚ü©\n        dsimp at *\n        simp\n        rfl)\n  functor_unitIso_comp := by\n    rintro ‚ü®_, ‚ü®‚ü©‚ü©\n    dsimp\n    simp\n    rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.grothendieckTypeToCat_counitIso_hom_app_coe","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nG : CategoryTheory.Functor C (Type w)\nX : G.Elements\n‚ä¢ Eq (‚Üë((CategoryTheory.Grothendieck.grothendieckTypeToCat G).counitIso.hom.app X)) (CategoryTheory.CategoryStruct.id X.fst)","decl":"/-- The Grothendieck construction applied to a functor to `Type`\n(thought of as a functor to `Cat` by realising a type as a discrete category)\nis the same as the 'category of elements' construction.\n-/\n-- See porting note on grothendieckTypeToCatInverse.\n-- We just want to turn off grothendieckTypeToCat_inverse_map_fiber_down_down,\n-- so have to list the complement here for `@[simps]`.\n@[simps! functor_obj_fst functor_obj_snd functor_map_coe inverse_obj_base inverse_obj_fiber_as\n  inverse_map_base unitIso_hom_app_base unitIso_hom_app_fiber unitIso_inv_app_base\n  unitIso_inv_app_fiber counitIso_hom_app_coe counitIso_inv_app_coe]\ndef grothendieckTypeToCat : Grothendieck (G ‚ãô typeToCat) ‚âå G.Elements where\n  functor := grothendieckTypeToCatFunctor G\n  inverse := grothendieckTypeToCatInverse G\n  unitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        rcases X with ‚ü®_, ‚ü®‚ü©‚ü©\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®base, ‚ü®‚ü®f‚ü©‚ü©‚ü©\n        dsimp at *\n        simp\n        rfl)\n  counitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        cases X\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®‚ü© ‚ü®‚ü© ‚ü®f, e‚ü©\n        dsimp at *\n        simp\n        rfl)\n  functor_unitIso_comp := by\n    rintro ‚ü®_, ‚ü®‚ü©‚ü©\n    dsimp\n    simp\n    rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.grothendieckTypeToCat_unitIso_hom_app_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nG : CategoryTheory.Functor C (Type w)\nX : CategoryTheory.Grothendieck (G.comp CategoryTheory.typeToCat)\n‚ä¢ Eq ((CategoryTheory.Grothendieck.grothendieckTypeToCat G).unitIso.hom.app X).base (CategoryTheory.CategoryStruct.id X.base)","decl":"/-- The Grothendieck construction applied to a functor to `Type`\n(thought of as a functor to `Cat` by realising a type as a discrete category)\nis the same as the 'category of elements' construction.\n-/\n-- See porting note on grothendieckTypeToCatInverse.\n-- We just want to turn off grothendieckTypeToCat_inverse_map_fiber_down_down,\n-- so have to list the complement here for `@[simps]`.\n@[simps! functor_obj_fst functor_obj_snd functor_map_coe inverse_obj_base inverse_obj_fiber_as\n  inverse_map_base unitIso_hom_app_base unitIso_hom_app_fiber unitIso_inv_app_base\n  unitIso_inv_app_fiber counitIso_hom_app_coe counitIso_inv_app_coe]\ndef grothendieckTypeToCat : Grothendieck (G ‚ãô typeToCat) ‚âå G.Elements where\n  functor := grothendieckTypeToCatFunctor G\n  inverse := grothendieckTypeToCatInverse G\n  unitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        rcases X with ‚ü®_, ‚ü®‚ü©‚ü©\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®base, ‚ü®‚ü®f‚ü©‚ü©‚ü©\n        dsimp at *\n        simp\n        rfl)\n  counitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        cases X\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®‚ü© ‚ü®‚ü© ‚ü®f, e‚ü©\n        dsimp at *\n        simp\n        rfl)\n  functor_unitIso_comp := by\n    rintro ‚ü®_, ‚ü®‚ü©‚ü©\n    dsimp\n    simp\n    rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.grothendieckTypeToCat_counitIso_inv_app_coe","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nG : CategoryTheory.Functor C (Type w)\nX : G.Elements\n‚ä¢ Eq (‚Üë((CategoryTheory.Grothendieck.grothendieckTypeToCat G).counitIso.inv.app X)) (CategoryTheory.CategoryStruct.id X.fst)","decl":"/-- The Grothendieck construction applied to a functor to `Type`\n(thought of as a functor to `Cat` by realising a type as a discrete category)\nis the same as the 'category of elements' construction.\n-/\n-- See porting note on grothendieckTypeToCatInverse.\n-- We just want to turn off grothendieckTypeToCat_inverse_map_fiber_down_down,\n-- so have to list the complement here for `@[simps]`.\n@[simps! functor_obj_fst functor_obj_snd functor_map_coe inverse_obj_base inverse_obj_fiber_as\n  inverse_map_base unitIso_hom_app_base unitIso_hom_app_fiber unitIso_inv_app_base\n  unitIso_inv_app_fiber counitIso_hom_app_coe counitIso_inv_app_coe]\ndef grothendieckTypeToCat : Grothendieck (G ‚ãô typeToCat) ‚âå G.Elements where\n  functor := grothendieckTypeToCatFunctor G\n  inverse := grothendieckTypeToCatInverse G\n  unitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        rcases X with ‚ü®_, ‚ü®‚ü©‚ü©\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®base, ‚ü®‚ü®f‚ü©‚ü©‚ü©\n        dsimp at *\n        simp\n        rfl)\n  counitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        cases X\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®‚ü© ‚ü®‚ü© ‚ü®f, e‚ü©\n        dsimp at *\n        simp\n        rfl)\n  functor_unitIso_comp := by\n    rintro ‚ü®_, ‚ü®‚ü©‚ü©\n    dsimp\n    simp\n    rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.grothendieckTypeToCat_inverse_obj_fiber_as","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nG : CategoryTheory.Functor C (Type w)\nX : G.Elements\n‚ä¢ Eq ((CategoryTheory.Grothendieck.grothendieckTypeToCat G).inverse.obj X).fiber.as X.snd","decl":"/-- The Grothendieck construction applied to a functor to `Type`\n(thought of as a functor to `Cat` by realising a type as a discrete category)\nis the same as the 'category of elements' construction.\n-/\n-- See porting note on grothendieckTypeToCatInverse.\n-- We just want to turn off grothendieckTypeToCat_inverse_map_fiber_down_down,\n-- so have to list the complement here for `@[simps]`.\n@[simps! functor_obj_fst functor_obj_snd functor_map_coe inverse_obj_base inverse_obj_fiber_as\n  inverse_map_base unitIso_hom_app_base unitIso_hom_app_fiber unitIso_inv_app_base\n  unitIso_inv_app_fiber counitIso_hom_app_coe counitIso_inv_app_coe]\ndef grothendieckTypeToCat : Grothendieck (G ‚ãô typeToCat) ‚âå G.Elements where\n  functor := grothendieckTypeToCatFunctor G\n  inverse := grothendieckTypeToCatInverse G\n  unitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        rcases X with ‚ü®_, ‚ü®‚ü©‚ü©\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®base, ‚ü®‚ü®f‚ü©‚ü©‚ü©\n        dsimp at *\n        simp\n        rfl)\n  counitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        cases X\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®‚ü© ‚ü®‚ü© ‚ü®f, e‚ü©\n        dsimp at *\n        simp\n        rfl)\n  functor_unitIso_comp := by\n    rintro ‚ü®_, ‚ü®‚ü©‚ü©\n    dsimp\n    simp\n    rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.grothendieckTypeToCat_unitIso_hom_app_fiber","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nG : CategoryTheory.Functor C (Type w)\nX : CategoryTheory.Grothendieck (G.comp CategoryTheory.typeToCat)\n‚ä¢ Eq ((CategoryTheory.Grothendieck.grothendieckTypeToCat G).unitIso.hom.app X).fiber (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- The Grothendieck construction applied to a functor to `Type`\n(thought of as a functor to `Cat` by realising a type as a discrete category)\nis the same as the 'category of elements' construction.\n-/\n-- See porting note on grothendieckTypeToCatInverse.\n-- We just want to turn off grothendieckTypeToCat_inverse_map_fiber_down_down,\n-- so have to list the complement here for `@[simps]`.\n@[simps! functor_obj_fst functor_obj_snd functor_map_coe inverse_obj_base inverse_obj_fiber_as\n  inverse_map_base unitIso_hom_app_base unitIso_hom_app_fiber unitIso_inv_app_base\n  unitIso_inv_app_fiber counitIso_hom_app_coe counitIso_inv_app_coe]\ndef grothendieckTypeToCat : Grothendieck (G ‚ãô typeToCat) ‚âå G.Elements where\n  functor := grothendieckTypeToCatFunctor G\n  inverse := grothendieckTypeToCatInverse G\n  unitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        rcases X with ‚ü®_, ‚ü®‚ü©‚ü©\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®base, ‚ü®‚ü®f‚ü©‚ü©‚ü©\n        dsimp at *\n        simp\n        rfl)\n  counitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        cases X\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®‚ü© ‚ü®‚ü© ‚ü®f, e‚ü©\n        dsimp at *\n        simp\n        rfl)\n  functor_unitIso_comp := by\n    rintro ‚ü®_, ‚ü®‚ü©‚ü©\n    dsimp\n    simp\n    rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.grothendieckTypeToCat_unitIso_inv_app_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nG : CategoryTheory.Functor C (Type w)\nX : CategoryTheory.Grothendieck (G.comp CategoryTheory.typeToCat)\n‚ä¢ Eq ((CategoryTheory.Grothendieck.grothendieckTypeToCat G).unitIso.inv.app X).base (CategoryTheory.CategoryStruct.id X.base)","decl":"/-- The Grothendieck construction applied to a functor to `Type`\n(thought of as a functor to `Cat` by realising a type as a discrete category)\nis the same as the 'category of elements' construction.\n-/\n-- See porting note on grothendieckTypeToCatInverse.\n-- We just want to turn off grothendieckTypeToCat_inverse_map_fiber_down_down,\n-- so have to list the complement here for `@[simps]`.\n@[simps! functor_obj_fst functor_obj_snd functor_map_coe inverse_obj_base inverse_obj_fiber_as\n  inverse_map_base unitIso_hom_app_base unitIso_hom_app_fiber unitIso_inv_app_base\n  unitIso_inv_app_fiber counitIso_hom_app_coe counitIso_inv_app_coe]\ndef grothendieckTypeToCat : Grothendieck (G ‚ãô typeToCat) ‚âå G.Elements where\n  functor := grothendieckTypeToCatFunctor G\n  inverse := grothendieckTypeToCatInverse G\n  unitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        rcases X with ‚ü®_, ‚ü®‚ü©‚ü©\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®base, ‚ü®‚ü®f‚ü©‚ü©‚ü©\n        dsimp at *\n        simp\n        rfl)\n  counitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        cases X\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®‚ü© ‚ü®‚ü© ‚ü®f, e‚ü©\n        dsimp at *\n        simp\n        rfl)\n  functor_unitIso_comp := by\n    rintro ‚ü®_, ‚ü®‚ü©‚ü©\n    dsimp\n    simp\n    rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.grothendieckTypeToCat_inverse_map_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nG : CategoryTheory.Functor C (Type w)\nX‚úù Y‚úù : G.Elements\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Grothendieck.grothendieckTypeToCat G).inverse.map f).base ‚Üëf","decl":"/-- The Grothendieck construction applied to a functor to `Type`\n(thought of as a functor to `Cat` by realising a type as a discrete category)\nis the same as the 'category of elements' construction.\n-/\n-- See porting note on grothendieckTypeToCatInverse.\n-- We just want to turn off grothendieckTypeToCat_inverse_map_fiber_down_down,\n-- so have to list the complement here for `@[simps]`.\n@[simps! functor_obj_fst functor_obj_snd functor_map_coe inverse_obj_base inverse_obj_fiber_as\n  inverse_map_base unitIso_hom_app_base unitIso_hom_app_fiber unitIso_inv_app_base\n  unitIso_inv_app_fiber counitIso_hom_app_coe counitIso_inv_app_coe]\ndef grothendieckTypeToCat : Grothendieck (G ‚ãô typeToCat) ‚âå G.Elements where\n  functor := grothendieckTypeToCatFunctor G\n  inverse := grothendieckTypeToCatInverse G\n  unitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        rcases X with ‚ü®_, ‚ü®‚ü©‚ü©\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®base, ‚ü®‚ü®f‚ü©‚ü©‚ü©\n        dsimp at *\n        simp\n        rfl)\n  counitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        cases X\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®‚ü© ‚ü®‚ü© ‚ü®f, e‚ü©\n        dsimp at *\n        simp\n        rfl)\n  functor_unitIso_comp := by\n    rintro ‚ü®_, ‚ü®‚ü©‚ü©\n    dsimp\n    simp\n    rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.grothendieckTypeToCat_unitIso_inv_app_fiber","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nG : CategoryTheory.Functor C (Type w)\nX : CategoryTheory.Grothendieck (G.comp CategoryTheory.typeToCat)\n‚ä¢ Eq ((CategoryTheory.Grothendieck.grothendieckTypeToCat G).unitIso.inv.app X).fiber (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- The Grothendieck construction applied to a functor to `Type`\n(thought of as a functor to `Cat` by realising a type as a discrete category)\nis the same as the 'category of elements' construction.\n-/\n-- See porting note on grothendieckTypeToCatInverse.\n-- We just want to turn off grothendieckTypeToCat_inverse_map_fiber_down_down,\n-- so have to list the complement here for `@[simps]`.\n@[simps! functor_obj_fst functor_obj_snd functor_map_coe inverse_obj_base inverse_obj_fiber_as\n  inverse_map_base unitIso_hom_app_base unitIso_hom_app_fiber unitIso_inv_app_base\n  unitIso_inv_app_fiber counitIso_hom_app_coe counitIso_inv_app_coe]\ndef grothendieckTypeToCat : Grothendieck (G ‚ãô typeToCat) ‚âå G.Elements where\n  functor := grothendieckTypeToCatFunctor G\n  inverse := grothendieckTypeToCatInverse G\n  unitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        rcases X with ‚ü®_, ‚ü®‚ü©‚ü©\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®base, ‚ü®‚ü®f‚ü©‚ü©‚ü©\n        dsimp at *\n        simp\n        rfl)\n  counitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        cases X\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®‚ü© ‚ü®‚ü© ‚ü®f, e‚ü©\n        dsimp at *\n        simp\n        rfl)\n  functor_unitIso_comp := by\n    rintro ‚ü®_, ‚ü®‚ü©‚ü©\n    dsimp\n    simp\n    rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.grothendieckTypeToCat_functor_obj_fst","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nG : CategoryTheory.Functor C (Type w)\nX : CategoryTheory.Grothendieck (G.comp CategoryTheory.typeToCat)\n‚ä¢ Eq ((CategoryTheory.Grothendieck.grothendieckTypeToCat G).functor.obj X).fst X.base","decl":"/-- The Grothendieck construction applied to a functor to `Type`\n(thought of as a functor to `Cat` by realising a type as a discrete category)\nis the same as the 'category of elements' construction.\n-/\n-- See porting note on grothendieckTypeToCatInverse.\n-- We just want to turn off grothendieckTypeToCat_inverse_map_fiber_down_down,\n-- so have to list the complement here for `@[simps]`.\n@[simps! functor_obj_fst functor_obj_snd functor_map_coe inverse_obj_base inverse_obj_fiber_as\n  inverse_map_base unitIso_hom_app_base unitIso_hom_app_fiber unitIso_inv_app_base\n  unitIso_inv_app_fiber counitIso_hom_app_coe counitIso_inv_app_coe]\ndef grothendieckTypeToCat : Grothendieck (G ‚ãô typeToCat) ‚âå G.Elements where\n  functor := grothendieckTypeToCatFunctor G\n  inverse := grothendieckTypeToCatInverse G\n  unitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        rcases X with ‚ü®_, ‚ü®‚ü©‚ü©\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®base, ‚ü®‚ü®f‚ü©‚ü©‚ü©\n        dsimp at *\n        simp\n        rfl)\n  counitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        cases X\n        exact Iso.refl _)\n      (by\n        rintro ‚ü®‚ü© ‚ü®‚ü© ‚ü®f, e‚ü©\n        dsimp at *\n        simp\n        rfl)\n  functor_unitIso_comp := by\n    rintro ‚ü®_, ‚ü®‚ü©‚ü©\n    dsimp\n    simp\n    rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.pre_map_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nF : CategoryTheory.Functor C CategoryTheory.Cat\nG : CategoryTheory.Functor D C\nX‚úù Y‚úù : CategoryTheory.Grothendieck (G.comp F)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Grothendieck.pre F G).map f).base (G.map f.base)","decl":"/-- Applying a functor `G : D ‚•§ C` to the base of the Grothendieck construction induces a functor\n`Grothendieck (G ‚ãô F) ‚•§ Grothendieck F`. -/\n@[simps]\ndef pre (G : D ‚•§ C) : Grothendieck (G ‚ãô F) ‚•§ Grothendieck F where\n  obj X := ‚ü®G.obj X.base, X.fiber‚ü©\n  map f := ‚ü®G.map f.base, f.fiber‚ü©\n  map_id X := Grothendieck.ext _ _ (G.map_id _) (by simp)\n  map_comp f g := Grothendieck.ext _ _ (G.map_comp _ _) (by simp)\n\n"}
{"name":"CategoryTheory.Grothendieck.pre_obj_fiber","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nF : CategoryTheory.Functor C CategoryTheory.Cat\nG : CategoryTheory.Functor D C\nX : CategoryTheory.Grothendieck (G.comp F)\n‚ä¢ Eq ((CategoryTheory.Grothendieck.pre F G).obj X).fiber X.fiber","decl":"/-- Applying a functor `G : D ‚•§ C` to the base of the Grothendieck construction induces a functor\n`Grothendieck (G ‚ãô F) ‚•§ Grothendieck F`. -/\n@[simps]\ndef pre (G : D ‚•§ C) : Grothendieck (G ‚ãô F) ‚•§ Grothendieck F where\n  obj X := ‚ü®G.obj X.base, X.fiber‚ü©\n  map f := ‚ü®G.map f.base, f.fiber‚ü©\n  map_id X := Grothendieck.ext _ _ (G.map_id _) (by simp)\n  map_comp f g := Grothendieck.ext _ _ (G.map_comp _ _) (by simp)\n\n"}
{"name":"CategoryTheory.Grothendieck.pre_obj_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nF : CategoryTheory.Functor C CategoryTheory.Cat\nG : CategoryTheory.Functor D C\nX : CategoryTheory.Grothendieck (G.comp F)\n‚ä¢ Eq ((CategoryTheory.Grothendieck.pre F G).obj X).base (G.obj X.base)","decl":"/-- Applying a functor `G : D ‚•§ C` to the base of the Grothendieck construction induces a functor\n`Grothendieck (G ‚ãô F) ‚•§ Grothendieck F`. -/\n@[simps]\ndef pre (G : D ‚•§ C) : Grothendieck (G ‚ãô F) ‚•§ Grothendieck F where\n  obj X := ‚ü®G.obj X.base, X.fiber‚ü©\n  map f := ‚ü®G.map f.base, f.fiber‚ü©\n  map_id X := Grothendieck.ext _ _ (G.map_id _) (by simp)\n  map_comp f g := Grothendieck.ext _ _ (G.map_comp _ _) (by simp)\n\n"}
{"name":"CategoryTheory.Grothendieck.pre_map_fiber","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nF : CategoryTheory.Functor C CategoryTheory.Cat\nG : CategoryTheory.Functor D C\nX‚úù Y‚úù : CategoryTheory.Grothendieck (G.comp F)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Grothendieck.pre F G).map f).fiber f.fiber","decl":"/-- Applying a functor `G : D ‚•§ C` to the base of the Grothendieck construction induces a functor\n`Grothendieck (G ‚ãô F) ‚•§ Grothendieck F`. -/\n@[simps]\ndef pre (G : D ‚•§ C) : Grothendieck (G ‚ãô F) ‚•§ Grothendieck F where\n  obj X := ‚ü®G.obj X.base, X.fiber‚ü©\n  map f := ‚ü®G.map f.base, f.fiber‚ü©\n  map_id X := Grothendieck.ext _ _ (G.map_id _) (by simp)\n  map_comp f g := Grothendieck.ext _ _ (G.map_comp _ _) (by simp)\n\n"}
{"name":"CategoryTheory.Grothendieck.pre_id","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\n‚ä¢ Eq (CategoryTheory.Grothendieck.pre F (CategoryTheory.Functor.id C)) (CategoryTheory.Functor.id (CategoryTheory.Grothendieck ((CategoryTheory.Functor.id C).comp F)))","decl":"@[simp]\ntheorem pre_id : pre F (ùü≠ C) = ùü≠ _ := rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.pre_comp_map","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nF : CategoryTheory.Functor C CategoryTheory.Cat\nG : CategoryTheory.Functor D C\nH : CategoryTheory.Functor C CategoryTheory.Cat\nŒ± : Quiver.Hom F H\n‚ä¢ Eq ((CategoryTheory.Grothendieck.pre F G).comp (CategoryTheory.Grothendieck.map Œ±)) ((CategoryTheory.Grothendieck.map (CategoryTheory.whiskerLeft G Œ±)).comp (CategoryTheory.Grothendieck.pre H G))","decl":"variable {F} in\nlemma pre_comp_map (G: D ‚•§ C) {H : C ‚•§ Cat} (Œ± : F ‚ü∂ H) :\n    pre F G ‚ãô map Œ± = map (whiskerLeft G Œ±) ‚ãô pre H G := rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.pre_comp_map_assoc","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nF : CategoryTheory.Functor C CategoryTheory.Cat\nG : CategoryTheory.Functor D C\nH : CategoryTheory.Functor C CategoryTheory.Cat\nŒ± : Quiver.Hom F H\nE : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} E\nK : CategoryTheory.Functor (CategoryTheory.Grothendieck H) E\n‚ä¢ Eq ((CategoryTheory.Grothendieck.pre F G).comp ((CategoryTheory.Grothendieck.map Œ±).comp K)) ((CategoryTheory.Grothendieck.map (CategoryTheory.whiskerLeft G Œ±)).comp ((CategoryTheory.Grothendieck.pre H G).comp K))","decl":"variable {F} in\nlemma pre_comp_map_assoc (G: D ‚•§ C) {H : C ‚•§ Cat} (Œ± : F ‚ü∂ H) {E : Type*} [Category E]\n    (K : Grothendieck H ‚•§ E) : pre F G ‚ãô map Œ± ‚ãô K= map (whiskerLeft G Œ±) ‚ãô pre H G ‚ãô K := rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.pre_comp","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nF : CategoryTheory.Functor C CategoryTheory.Cat\nE : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} E\nG : CategoryTheory.Functor D C\nH : CategoryTheory.Functor E D\n‚ä¢ Eq (CategoryTheory.Grothendieck.pre F (H.comp G)) ((CategoryTheory.Grothendieck.pre (G.comp F) H).comp (CategoryTheory.Grothendieck.pre F G))","decl":"variable {E : Type*} [Category E] in\n@[simp]\nlemma pre_comp (G : D ‚•§ C) (H : E ‚•§ D) : pre F (H ‚ãô G) = pre (G ‚ãô F) H ‚ãô pre F G := rfl\n\n"}
{"name":"CategoryTheory.Grothendieck.Œπ_obj","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nc : C\nd : ‚Üë(F.obj c)\n‚ä¢ Eq ((CategoryTheory.Grothendieck.Œπ F c).obj d) { base := c, fiber := d }","decl":"variable (F) in\n/-- The inclusion of a fiber `F.obj c` of a functor `F : C ‚•§ Cat` into its Grothendieck\nconstruction.-/\n@[simps obj map]\ndef Œπ (c : C) : F.obj c ‚•§ Grothendieck F where\n  obj d := ‚ü®c, d‚ü©\n  map f := ‚ü®ùüô _, eqToHom (by simp) ‚â´ f‚ü©\n  map_id d := by\n    dsimp\n    congr\n    simp only [Category.comp_id]\n  map_comp f g := by\n    apply Grothendieck.ext _ _ (by simp)\n    simp only [comp_base, ‚Üê Category.assoc, eqToHom_trans, comp_fiber, Functor.map_comp,\n      eqToHom_map]\n    congr 1\n    simp only [eqToHom_comp_iff, Category.assoc, eqToHom_trans_assoc]\n    apply Functor.congr_hom (F.map_id _).symm\n\n"}
{"name":"CategoryTheory.Grothendieck.Œπ_map","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nc : C\nX‚úù Y‚úù : ‚Üë(F.obj c)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Grothendieck.Œπ F c).map f) { base := CategoryTheory.CategoryStruct.id ((fun d => { base := c, fiber := d }) X‚úù).base, fiber := CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) f }","decl":"variable (F) in\n/-- The inclusion of a fiber `F.obj c` of a functor `F : C ‚•§ Cat` into its Grothendieck\nconstruction.-/\n@[simps obj map]\ndef Œπ (c : C) : F.obj c ‚•§ Grothendieck F where\n  obj d := ‚ü®c, d‚ü©\n  map f := ‚ü®ùüô _, eqToHom (by simp) ‚â´ f‚ü©\n  map_id d := by\n    dsimp\n    congr\n    simp only [Category.comp_id]\n  map_comp f g := by\n    apply Grothendieck.ext _ _ (by simp)\n    simp only [comp_base, ‚Üê Category.assoc, eqToHom_trans, comp_fiber, Functor.map_comp,\n      eqToHom_map]\n    congr 1\n    simp only [eqToHom_comp_iff, Category.assoc, eqToHom_trans_assoc]\n    apply Functor.congr_hom (F.map_id _).symm\n\n"}
{"name":"CategoryTheory.Grothendieck.faithful_Œπ","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nc : C\n‚ä¢ (CategoryTheory.Grothendieck.Œπ F c).Faithful","decl":"instance faithful_Œπ (c : C) : (Œπ F c).Faithful where\n  map_injective f := by\n    injection f with _ f\n    rwa [cancel_epi] at f\n\n"}
{"name":"CategoryTheory.Grothendieck.ŒπNatTrans_app_fiber","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX Y : C\nf : Quiver.Hom X Y\nd : ‚Üë(F.obj X)\n‚ä¢ Eq ((CategoryTheory.Grothendieck.ŒπNatTrans f).app d).fiber (CategoryTheory.CategoryStruct.id ((F.map f).obj ((CategoryTheory.Grothendieck.Œπ F X).obj d).fiber))","decl":"/-- Every morphism `f : X ‚ü∂ Y` in the base category induces a natural transformation from the fiber\ninclusion `Œπ F X` to the composition `F.map f ‚ãô Œπ F Y`. -/\n@[simps]\ndef ŒπNatTrans {X Y : C} (f : X ‚ü∂ Y) : Œπ F X ‚ü∂ F.map f ‚ãô Œπ F Y where\n  app d := ‚ü®f, ùüô _‚ü©\n  naturality _ _ _ := by\n    simp only [Œπ, Functor.comp_obj, Functor.comp_map]\n    exact Grothendieck.ext _ _ (by simp) (by simp [eqToHom_map])\n\n"}
{"name":"CategoryTheory.Grothendieck.ŒπNatTrans_app_base","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nX Y : C\nf : Quiver.Hom X Y\nd : ‚Üë(F.obj X)\n‚ä¢ Eq ((CategoryTheory.Grothendieck.ŒπNatTrans f).app d).base f","decl":"/-- Every morphism `f : X ‚ü∂ Y` in the base category induces a natural transformation from the fiber\ninclusion `Œπ F X` to the composition `F.map f ‚ãô Œπ F Y`. -/\n@[simps]\ndef ŒπNatTrans {X Y : C} (f : X ‚ü∂ Y) : Œπ F X ‚ü∂ F.map f ‚ãô Œπ F Y where\n  app d := ‚ü®f, ùüô _‚ü©\n  naturality _ _ _ := by\n    simp only [Œπ, Functor.comp_obj, Functor.comp_map]\n    exact Grothendieck.ext _ _ (by simp) (by simp [eqToHom_map])\n\n"}
{"name":"CategoryTheory.Grothendieck.functorFrom_obj","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nE : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} E\nfib : (c : C) ‚Üí CategoryTheory.Functor (‚Üë(F.obj c)) E\nhom : {c c' : C} ‚Üí (f : Quiver.Hom c c') ‚Üí Quiver.Hom (fib c) (CategoryTheory.Functor.comp (F.map f) (fib c'))\nX : CategoryTheory.Grothendieck F\n‚ä¢ Eq ((CategoryTheory.Grothendieck.functorFrom fib hom).obj X) ((fib X.base).obj X.fiber)","decl":"/-- Construct a functor from `Grothendieck F` to another category `E` by providing a family of\nfunctors on the fibers of `Grothendieck F`, a family of natural transformations on morphisms in the\nbase of `Grothendieck F` and coherence data for this family of natural transformations. -/\n@[simps]\ndef functorFrom : Grothendieck F ‚•§ E where\n  obj X := (fib X.base).obj X.fiber\n  map {X Y} f := (hom f.base).app X.fiber ‚â´ (fib Y.base).map f.fiber\n  map_id X := by simp [hom_id]\n  map_comp f g := by simp [hom_comp]\n\n"}
{"name":"CategoryTheory.Grothendieck.functorFrom_map","module":"Mathlib.CategoryTheory.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\nE : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} E\nfib : (c : C) ‚Üí CategoryTheory.Functor (‚Üë(F.obj c)) E\nhom : {c c' : C} ‚Üí (f : Quiver.Hom c c') ‚Üí Quiver.Hom (fib c) (CategoryTheory.Functor.comp (F.map f) (fib c'))\nX Y : CategoryTheory.Grothendieck F\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Grothendieck.functorFrom fib hom).map f) (CategoryTheory.CategoryStruct.comp ((hom f.base).app X.fiber) ((fib Y.base).map f.fiber))","decl":"/-- Construct a functor from `Grothendieck F` to another category `E` by providing a family of\nfunctors on the fibers of `Grothendieck F`, a family of natural transformations on morphisms in the\nbase of `Grothendieck F` and coherence data for this family of natural transformations. -/\n@[simps]\ndef functorFrom : Grothendieck F ‚•§ E where\n  obj X := (fib X.base).obj X.fiber\n  map {X Y} f := (hom f.base).app X.fiber ‚â´ (fib Y.base).map f.fiber\n  map_id X := by simp [hom_id]\n  map_comp f g := by simp [hom_comp]\n\n"}
