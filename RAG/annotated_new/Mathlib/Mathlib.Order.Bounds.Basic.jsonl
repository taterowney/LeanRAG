{"name":"mem_upperBounds","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\n⊢ Iff (Membership.mem (upperBounds s) a) (∀ (x : α), Membership.mem s x → LE.le x a)","decl":"theorem mem_upperBounds : a ∈ upperBounds s ↔ ∀ x ∈ s, x ≤ a :=\n  Iff.rfl\n\n"}
{"name":"mem_lowerBounds","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\n⊢ Iff (Membership.mem (lowerBounds s) a) (∀ (x : α), Membership.mem s x → LE.le a x)","decl":"theorem mem_lowerBounds : a ∈ lowerBounds s ↔ ∀ x ∈ s, a ≤ x :=\n  Iff.rfl\n\n"}
{"name":"mem_upperBounds_iff_subset_Iic","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\n⊢ Iff (Membership.mem (upperBounds s) a) (HasSubset.Subset s (Set.Iic a))","decl":"lemma mem_upperBounds_iff_subset_Iic : a ∈ upperBounds s ↔ s ⊆ Iic a := Iff.rfl\n\n"}
{"name":"mem_lowerBounds_iff_subset_Ici","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\n⊢ Iff (Membership.mem (lowerBounds s) a) (HasSubset.Subset s (Set.Ici a))","decl":"lemma mem_lowerBounds_iff_subset_Ici : a ∈ lowerBounds s ↔ s ⊆ Ici a := Iff.rfl\n\n"}
{"name":"bddAbove_def","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (BddAbove s) (Exists fun x => ∀ (y : α), Membership.mem s y → LE.le y x)","decl":"theorem bddAbove_def : BddAbove s ↔ ∃ x, ∀ y ∈ s, y ≤ x :=\n  Iff.rfl\n\n"}
{"name":"bddBelow_def","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (BddBelow s) (Exists fun x => ∀ (y : α), Membership.mem s y → LE.le x y)","decl":"theorem bddBelow_def : BddBelow s ↔ ∃ x, ∀ y ∈ s, x ≤ y :=\n  Iff.rfl\n\n"}
{"name":"bot_mem_lowerBounds","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\ns : Set α\n⊢ Membership.mem (lowerBounds s) Bot.bot","decl":"theorem bot_mem_lowerBounds [OrderBot α] (s : Set α) : ⊥ ∈ lowerBounds s := fun _ _ => bot_le\n\n"}
{"name":"top_mem_upperBounds","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\ns : Set α\n⊢ Membership.mem (upperBounds s) Top.top","decl":"theorem top_mem_upperBounds [OrderTop α] (s : Set α) : ⊤ ∈ upperBounds s := fun _ _ => le_top\n\n"}
{"name":"isLeast_bot_iff","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ns : Set α\ninst✝ : OrderBot α\n⊢ Iff (IsLeast s Bot.bot) (Membership.mem s Bot.bot)","decl":"@[simp]\ntheorem isLeast_bot_iff [OrderBot α] : IsLeast s ⊥ ↔ ⊥ ∈ s :=\n  and_iff_left <| bot_mem_lowerBounds _\n\n"}
{"name":"isGreatest_top_iff","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ns : Set α\ninst✝ : OrderTop α\n⊢ Iff (IsGreatest s Top.top) (Membership.mem s Top.top)","decl":"@[simp]\ntheorem isGreatest_top_iff [OrderTop α] : IsGreatest s ⊤ ↔ ⊤ ∈ s :=\n  and_iff_left <| top_mem_upperBounds _\n\n"}
{"name":"not_bddAbove_iff'","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (Not (BddAbove s)) (∀ (x : α), Exists fun y => And (Membership.mem s y) (Not (LE.le y x)))","decl":"/-- A set `s` is not bounded above if and only if for each `x` there exists `y ∈ s` such that `x`\nis not greater than or equal to `y`. This version only assumes `Preorder` structure and uses\n`¬(y ≤ x)`. A version for linear orders is called `not_bddAbove_iff`. -/\ntheorem not_bddAbove_iff' : ¬BddAbove s ↔ ∀ x, ∃ y ∈ s, ¬y ≤ x := by\n  simp [BddAbove, upperBounds, Set.Nonempty]\n\n"}
{"name":"not_bddBelow_iff'","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (Not (BddBelow s)) (∀ (x : α), Exists fun y => And (Membership.mem s y) (Not (LE.le x y)))","decl":"/-- A set `s` is not bounded below if and only if for each `x` there exists `y ∈ s` such that `x`\nis not less than or equal to `y`. This version only assumes `Preorder` structure and uses\n`¬(x ≤ y)`. A version for linear orders is called `not_bddBelow_iff`. -/\ntheorem not_bddBelow_iff' : ¬BddBelow s ↔ ∀ x, ∃ y ∈ s, ¬x ≤ y :=\n  @not_bddAbove_iff' αᵒᵈ _ _\n\n"}
{"name":"not_bddAbove_iff","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\n⊢ Iff (Not (BddAbove s)) (∀ (x : α), Exists fun y => And (Membership.mem s y) (LT.lt x y))","decl":"/-- A set `s` is not bounded above if and only if for each `x` there exists `y ∈ s` that is greater\nthan `x`. A version for preorders is called `not_bddAbove_iff'`. -/\ntheorem not_bddAbove_iff {α : Type*} [LinearOrder α] {s : Set α} :\n    ¬BddAbove s ↔ ∀ x, ∃ y ∈ s, x < y := by\n  simp only [not_bddAbove_iff', not_le]\n\n"}
{"name":"not_bddBelow_iff","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\n⊢ Iff (Not (BddBelow s)) (∀ (x : α), Exists fun y => And (Membership.mem s y) (LT.lt y x))","decl":"/-- A set `s` is not bounded below if and only if for each `x` there exists `y ∈ s` that is less\nthan `x`. A version for preorders is called `not_bddBelow_iff'`. -/\ntheorem not_bddBelow_iff {α : Type*} [LinearOrder α] {s : Set α} :\n    ¬BddBelow s ↔ ∀ x, ∃ y ∈ s, y < x :=\n  @not_bddAbove_iff αᵒᵈ _ _\n\n"}
{"name":"bddBelow_preimage_ofDual","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (BddBelow (Set.preimage (⇑OrderDual.ofDual) s)) (BddAbove s)","decl":"@[simp] lemma bddBelow_preimage_ofDual {s : Set α} : BddBelow (ofDual ⁻¹' s) ↔ BddAbove s := Iff.rfl\n"}
{"name":"bddAbove_preimage_ofDual","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (BddAbove (Set.preimage (⇑OrderDual.ofDual) s)) (BddBelow s)","decl":"@[simp] lemma bddAbove_preimage_ofDual {s : Set α} : BddAbove (ofDual ⁻¹' s) ↔ BddBelow s := Iff.rfl\n\n"}
{"name":"bddBelow_preimage_toDual","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set (OrderDual α)\n⊢ Iff (BddBelow (Set.preimage (⇑OrderDual.toDual) s)) (BddAbove s)","decl":"@[simp] lemma bddBelow_preimage_toDual {s : Set αᵒᵈ} :\n    BddBelow (toDual ⁻¹' s) ↔ BddAbove s := Iff.rfl\n\n"}
{"name":"bddAbove_preimage_toDual","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set (OrderDual α)\n⊢ Iff (BddAbove (Set.preimage (⇑OrderDual.toDual) s)) (BddBelow s)","decl":"@[simp] lemma bddAbove_preimage_toDual {s : Set αᵒᵈ} :\n    BddAbove (toDual ⁻¹' s) ↔ BddBelow s := Iff.rfl\n\n"}
{"name":"BddAbove.dual","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\nh : BddAbove s\n⊢ BddBelow (Set.preimage (⇑OrderDual.ofDual) s)","decl":"theorem BddAbove.dual (h : BddAbove s) : BddBelow (ofDual ⁻¹' s) :=\n  h\n\n"}
{"name":"BddBelow.dual","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\nh : BddBelow s\n⊢ BddAbove (Set.preimage (⇑OrderDual.ofDual) s)","decl":"theorem BddBelow.dual (h : BddBelow s) : BddAbove (ofDual ⁻¹' s) :=\n  h\n\n"}
{"name":"IsLeast.dual","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\nh : IsLeast s a\n⊢ IsGreatest (Set.preimage (⇑OrderDual.ofDual) s) (OrderDual.toDual a)","decl":"theorem IsLeast.dual (h : IsLeast s a) : IsGreatest (ofDual ⁻¹' s) (toDual a) :=\n  h\n\n"}
{"name":"IsGreatest.dual","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\nh : IsGreatest s a\n⊢ IsLeast (Set.preimage (⇑OrderDual.ofDual) s) (OrderDual.toDual a)","decl":"theorem IsGreatest.dual (h : IsGreatest s a) : IsLeast (ofDual ⁻¹' s) (toDual a) :=\n  h\n\n"}
{"name":"IsLUB.dual","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\nh : IsLUB s a\n⊢ IsGLB (Set.preimage (⇑OrderDual.ofDual) s) (OrderDual.toDual a)","decl":"theorem IsLUB.dual (h : IsLUB s a) : IsGLB (ofDual ⁻¹' s) (toDual a) :=\n  h\n\n"}
{"name":"IsGLB.dual","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\nh : IsGLB s a\n⊢ IsLUB (Set.preimage (⇑OrderDual.ofDual) s) (OrderDual.toDual a)","decl":"theorem IsGLB.dual (h : IsGLB s a) : IsLUB (ofDual ⁻¹' s) (toDual a) :=\n  h\n\n"}
{"name":"isLUB_congr","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns t : Set α\na : α\nh : Eq (upperBounds s) (upperBounds t)\n⊢ Iff (IsLUB s a) (IsLUB t a)","decl":"theorem isLUB_congr (h : upperBounds s = upperBounds t) : IsLUB s a ↔ IsLUB t a := by\n  rw [IsLUB, IsLUB, h]\n\n"}
{"name":"isGLB_congr","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns t : Set α\na : α\nh : Eq (lowerBounds s) (lowerBounds t)\n⊢ Iff (IsGLB s a) (IsGLB t a)","decl":"theorem isGLB_congr (h : lowerBounds s = lowerBounds t) : IsGLB s a ↔ IsGLB t a := by\n  rw [IsGLB, IsGLB, h]\n\n"}
{"name":"upperBounds_mono_set","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns t : Set α\nhst : HasSubset.Subset s t\n⊢ HasSubset.Subset (upperBounds t) (upperBounds s)","decl":"theorem upperBounds_mono_set ⦃s t : Set α⦄ (hst : s ⊆ t) : upperBounds t ⊆ upperBounds s :=\n  fun _ hb _ h => hb <| hst h\n\n"}
{"name":"lowerBounds_mono_set","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns t : Set α\nhst : HasSubset.Subset s t\n⊢ HasSubset.Subset (lowerBounds t) (lowerBounds s)","decl":"theorem lowerBounds_mono_set ⦃s t : Set α⦄ (hst : s ⊆ t) : lowerBounds t ⊆ lowerBounds s :=\n  fun _ hb _ h => hb <| hst h\n\n"}
{"name":"upperBounds_mono_mem","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na b : α\nhab : LE.le a b\na✝ : Membership.mem (upperBounds s) a\n⊢ Membership.mem (upperBounds s) b","decl":"theorem upperBounds_mono_mem ⦃a b⦄ (hab : a ≤ b) : a ∈ upperBounds s → b ∈ upperBounds s :=\n  fun ha _ h => le_trans (ha h) hab\n\n"}
{"name":"lowerBounds_mono_mem","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na b : α\nhab : LE.le a b\na✝ : Membership.mem (lowerBounds s) b\n⊢ Membership.mem (lowerBounds s) a","decl":"theorem lowerBounds_mono_mem ⦃a b⦄ (hab : a ≤ b) : b ∈ lowerBounds s → a ∈ lowerBounds s :=\n  fun hb _ h => le_trans hab (hb h)\n\n"}
{"name":"upperBounds_mono","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns t : Set α\nhst : HasSubset.Subset s t\na b : α\nhab : LE.le a b\na✝ : Membership.mem (upperBounds t) a\n⊢ Membership.mem (upperBounds s) b","decl":"theorem upperBounds_mono ⦃s t : Set α⦄ (hst : s ⊆ t) ⦃a b⦄ (hab : a ≤ b) :\n    a ∈ upperBounds t → b ∈ upperBounds s := fun ha =>\n  upperBounds_mono_set hst <| upperBounds_mono_mem hab ha\n\n"}
{"name":"lowerBounds_mono","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns t : Set α\nhst : HasSubset.Subset s t\na b : α\nhab : LE.le a b\na✝ : Membership.mem (lowerBounds t) b\n⊢ Membership.mem (lowerBounds s) a","decl":"theorem lowerBounds_mono ⦃s t : Set α⦄ (hst : s ⊆ t) ⦃a b⦄ (hab : a ≤ b) :\n    b ∈ lowerBounds t → a ∈ lowerBounds s := fun hb =>\n  lowerBounds_mono_set hst <| lowerBounds_mono_mem hab hb\n\n"}
{"name":"BddAbove.mono","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns t : Set α\nh : HasSubset.Subset s t\na✝ : BddAbove t\n⊢ BddAbove s","decl":"/-- If `s ⊆ t` and `t` is bounded above, then so is `s`. -/\ntheorem BddAbove.mono ⦃s t : Set α⦄ (h : s ⊆ t) : BddAbove t → BddAbove s :=\n  Nonempty.mono <| upperBounds_mono_set h\n\n"}
{"name":"BddBelow.mono","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns t : Set α\nh : HasSubset.Subset s t\na✝ : BddBelow t\n⊢ BddBelow s","decl":"/-- If `s ⊆ t` and `t` is bounded below, then so is `s`. -/\ntheorem BddBelow.mono ⦃s t : Set α⦄ (h : s ⊆ t) : BddBelow t → BddBelow s :=\n  Nonempty.mono <| lowerBounds_mono_set h\n\n"}
{"name":"IsLUB.of_subset_of_superset","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\ns t p : Set α\nhs : IsLUB s a\nhp : IsLUB p a\nhst : HasSubset.Subset s t\nhtp : HasSubset.Subset t p\n⊢ IsLUB t a","decl":"/-- If `a` is a least upper bound for sets `s` and `p`, then it is a least upper bound for any\nset `t`, `s ⊆ t ⊆ p`. -/\ntheorem IsLUB.of_subset_of_superset {s t p : Set α} (hs : IsLUB s a) (hp : IsLUB p a) (hst : s ⊆ t)\n    (htp : t ⊆ p) : IsLUB t a :=\n  ⟨upperBounds_mono_set htp hp.1, lowerBounds_mono_set (upperBounds_mono_set hst) hs.2⟩\n\n"}
{"name":"IsGLB.of_subset_of_superset","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\ns t p : Set α\nhs : IsGLB s a\nhp : IsGLB p a\nhst : HasSubset.Subset s t\nhtp : HasSubset.Subset t p\n⊢ IsGLB t a","decl":"/-- If `a` is a greatest lower bound for sets `s` and `p`, then it is a greater lower bound for any\nset `t`, `s ⊆ t ⊆ p`. -/\ntheorem IsGLB.of_subset_of_superset {s t p : Set α} (hs : IsGLB s a) (hp : IsGLB p a) (hst : s ⊆ t)\n    (htp : t ⊆ p) : IsGLB t a :=\n  hs.dual.of_subset_of_superset hp hst htp\n\n"}
{"name":"IsLeast.mono","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns t : Set α\na b : α\nha : IsLeast s a\nhb : IsLeast t b\nhst : HasSubset.Subset s t\n⊢ LE.le b a","decl":"theorem IsLeast.mono (ha : IsLeast s a) (hb : IsLeast t b) (hst : s ⊆ t) : b ≤ a :=\n  hb.2 (hst ha.1)\n\n"}
{"name":"IsGreatest.mono","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns t : Set α\na b : α\nha : IsGreatest s a\nhb : IsGreatest t b\nhst : HasSubset.Subset s t\n⊢ LE.le a b","decl":"theorem IsGreatest.mono (ha : IsGreatest s a) (hb : IsGreatest t b) (hst : s ⊆ t) : a ≤ b :=\n  hb.2 (hst ha.1)\n\n"}
{"name":"IsLUB.mono","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns t : Set α\na b : α\nha : IsLUB s a\nhb : IsLUB t b\nhst : HasSubset.Subset s t\n⊢ LE.le a b","decl":"theorem IsLUB.mono (ha : IsLUB s a) (hb : IsLUB t b) (hst : s ⊆ t) : a ≤ b :=\n  IsLeast.mono hb ha <| upperBounds_mono_set hst\n\n"}
{"name":"IsGLB.mono","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns t : Set α\na b : α\nha : IsGLB s a\nhb : IsGLB t b\nhst : HasSubset.Subset s t\n⊢ LE.le b a","decl":"theorem IsGLB.mono (ha : IsGLB s a) (hb : IsGLB t b) (hst : s ⊆ t) : b ≤ a :=\n  IsGreatest.mono hb ha <| lowerBounds_mono_set hst\n\n"}
{"name":"subset_lowerBounds_upperBounds","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\n⊢ HasSubset.Subset s (lowerBounds (upperBounds s))","decl":"theorem subset_lowerBounds_upperBounds (s : Set α) : s ⊆ lowerBounds (upperBounds s) :=\n  fun _ hx _ hy => hy hx\n\n"}
{"name":"subset_upperBounds_lowerBounds","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\n⊢ HasSubset.Subset s (upperBounds (lowerBounds s))","decl":"theorem subset_upperBounds_lowerBounds (s : Set α) : s ⊆ upperBounds (lowerBounds s) :=\n  fun _ hx _ hy => hy hx\n\n"}
{"name":"Set.Nonempty.bddAbove_lowerBounds","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\nhs : s.Nonempty\n⊢ BddAbove (lowerBounds s)","decl":"theorem Set.Nonempty.bddAbove_lowerBounds (hs : s.Nonempty) : BddAbove (lowerBounds s) :=\n  hs.mono (subset_upperBounds_lowerBounds s)\n\n"}
{"name":"Set.Nonempty.bddBelow_upperBounds","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\nhs : s.Nonempty\n⊢ BddBelow (upperBounds s)","decl":"theorem Set.Nonempty.bddBelow_upperBounds (hs : s.Nonempty) : BddBelow (upperBounds s) :=\n  hs.mono (subset_lowerBounds_upperBounds s)\n\n"}
{"name":"IsLeast.isGLB","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\nh : IsLeast s a\n⊢ IsGLB s a","decl":"theorem IsLeast.isGLB (h : IsLeast s a) : IsGLB s a :=\n  ⟨h.2, fun _ hb => hb h.1⟩\n\n"}
{"name":"IsGreatest.isLUB","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\nh : IsGreatest s a\n⊢ IsLUB s a","decl":"theorem IsGreatest.isLUB (h : IsGreatest s a) : IsLUB s a :=\n  ⟨h.2, fun _ hb => hb h.1⟩\n\n"}
{"name":"IsLUB.upperBounds_eq","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\nh : IsLUB s a\n⊢ Eq (upperBounds s) (Set.Ici a)","decl":"theorem IsLUB.upperBounds_eq (h : IsLUB s a) : upperBounds s = Ici a :=\n  Set.ext fun _ => ⟨fun hb => h.2 hb, fun hb => upperBounds_mono_mem hb h.1⟩\n\n"}
{"name":"IsGLB.lowerBounds_eq","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\nh : IsGLB s a\n⊢ Eq (lowerBounds s) (Set.Iic a)","decl":"theorem IsGLB.lowerBounds_eq (h : IsGLB s a) : lowerBounds s = Iic a :=\n  h.dual.upperBounds_eq\n\n"}
{"name":"IsLeast.lowerBounds_eq","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\nh : IsLeast s a\n⊢ Eq (lowerBounds s) (Set.Iic a)","decl":"theorem IsLeast.lowerBounds_eq (h : IsLeast s a) : lowerBounds s = Iic a :=\n  h.isGLB.lowerBounds_eq\n\n"}
{"name":"IsGreatest.upperBounds_eq","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\nh : IsGreatest s a\n⊢ Eq (upperBounds s) (Set.Ici a)","decl":"theorem IsGreatest.upperBounds_eq (h : IsGreatest s a) : upperBounds s = Ici a :=\n  h.isLUB.upperBounds_eq\n\n"}
{"name":"IsGreatest.lt_iff","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na b : α\nh : IsGreatest s a\n⊢ Iff (LT.lt a b) (∀ (x : α), Membership.mem s x → LT.lt x b)","decl":"theorem IsGreatest.lt_iff (h : IsGreatest s a) : a < b ↔ ∀ x ∈ s, x < b :=\n  ⟨fun hlt _x hx => (h.2 hx).trans_lt hlt, fun h' => h' _ h.1⟩\n\n"}
{"name":"IsLeast.lt_iff","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na b : α\nh : IsLeast s a\n⊢ Iff (LT.lt b a) (∀ (x : α), Membership.mem s x → LT.lt b x)","decl":"theorem IsLeast.lt_iff (h : IsLeast s a) : b < a ↔ ∀ x ∈ s, b < x :=\n  h.dual.lt_iff\n\n"}
{"name":"isLUB_le_iff","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na b : α\nh : IsLUB s a\n⊢ Iff (LE.le a b) (Membership.mem (upperBounds s) b)","decl":"theorem isLUB_le_iff (h : IsLUB s a) : a ≤ b ↔ b ∈ upperBounds s := by\n  rw [h.upperBounds_eq]\n  rfl\n\n"}
{"name":"le_isGLB_iff","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na b : α\nh : IsGLB s a\n⊢ Iff (LE.le b a) (Membership.mem (lowerBounds s) b)","decl":"theorem le_isGLB_iff (h : IsGLB s a) : b ≤ a ↔ b ∈ lowerBounds s := by\n  rw [h.lowerBounds_eq]\n  rfl\n\n"}
{"name":"isLUB_iff_le_iff","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\n⊢ Iff (IsLUB s a) (∀ (b : α), Iff (LE.le a b) (Membership.mem (upperBounds s) b))","decl":"theorem isLUB_iff_le_iff : IsLUB s a ↔ ∀ b, a ≤ b ↔ b ∈ upperBounds s :=\n  ⟨fun h _ => isLUB_le_iff h, fun H => ⟨(H _).1 le_rfl, fun b hb => (H b).2 hb⟩⟩\n\n"}
{"name":"isGLB_iff_le_iff","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\n⊢ Iff (IsGLB s a) (∀ (b : α), Iff (LE.le b a) (Membership.mem (lowerBounds s) b))","decl":"theorem isGLB_iff_le_iff : IsGLB s a ↔ ∀ b, b ≤ a ↔ b ∈ lowerBounds s :=\n  @isLUB_iff_le_iff αᵒᵈ _ _ _\n\n"}
{"name":"IsLUB.bddAbove","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\nh : IsLUB s a\n⊢ BddAbove s","decl":"/-- If `s` has a least upper bound, then it is bounded above. -/\ntheorem IsLUB.bddAbove (h : IsLUB s a) : BddAbove s :=\n  ⟨a, h.1⟩\n\n"}
{"name":"IsGLB.bddBelow","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\nh : IsGLB s a\n⊢ BddBelow s","decl":"/-- If `s` has a greatest lower bound, then it is bounded below. -/\ntheorem IsGLB.bddBelow (h : IsGLB s a) : BddBelow s :=\n  ⟨a, h.1⟩\n\n"}
{"name":"IsGreatest.bddAbove","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\nh : IsGreatest s a\n⊢ BddAbove s","decl":"/-- If `s` has a greatest element, then it is bounded above. -/\ntheorem IsGreatest.bddAbove (h : IsGreatest s a) : BddAbove s :=\n  ⟨a, h.2⟩\n\n"}
{"name":"IsLeast.bddBelow","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\nh : IsLeast s a\n⊢ BddBelow s","decl":"/-- If `s` has a least element, then it is bounded below. -/\ntheorem IsLeast.bddBelow (h : IsLeast s a) : BddBelow s :=\n  ⟨a, h.2⟩\n\n"}
{"name":"IsLeast.nonempty","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\nh : IsLeast s a\n⊢ s.Nonempty","decl":"theorem IsLeast.nonempty (h : IsLeast s a) : s.Nonempty :=\n  ⟨a, h.1⟩\n\n"}
{"name":"IsGreatest.nonempty","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\nh : IsGreatest s a\n⊢ s.Nonempty","decl":"theorem IsGreatest.nonempty (h : IsGreatest s a) : s.Nonempty :=\n  ⟨a, h.1⟩\n\n"}
{"name":"upperBounds_union","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns t : Set α\n⊢ Eq (upperBounds (Union.union s t)) (Inter.inter (upperBounds s) (upperBounds t))","decl":"@[simp]\ntheorem upperBounds_union : upperBounds (s ∪ t) = upperBounds s ∩ upperBounds t :=\n  Subset.antisymm (fun _ hb => ⟨fun _ hx => hb (Or.inl hx), fun _ hx => hb (Or.inr hx)⟩)\n    fun _ hb _ hx => hx.elim (fun hs => hb.1 hs) fun ht => hb.2 ht\n\n"}
{"name":"lowerBounds_union","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns t : Set α\n⊢ Eq (lowerBounds (Union.union s t)) (Inter.inter (lowerBounds s) (lowerBounds t))","decl":"@[simp]\ntheorem lowerBounds_union : lowerBounds (s ∪ t) = lowerBounds s ∩ lowerBounds t :=\n  @upperBounds_union αᵒᵈ _ s t\n\n"}
{"name":"union_upperBounds_subset_upperBounds_inter","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns t : Set α\n⊢ HasSubset.Subset (Union.union (upperBounds s) (upperBounds t)) (upperBounds (Inter.inter s t))","decl":"theorem union_upperBounds_subset_upperBounds_inter :\n    upperBounds s ∪ upperBounds t ⊆ upperBounds (s ∩ t) :=\n  union_subset (upperBounds_mono_set inter_subset_left)\n    (upperBounds_mono_set inter_subset_right)\n\n"}
{"name":"union_lowerBounds_subset_lowerBounds_inter","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns t : Set α\n⊢ HasSubset.Subset (Union.union (lowerBounds s) (lowerBounds t)) (lowerBounds (Inter.inter s t))","decl":"theorem union_lowerBounds_subset_lowerBounds_inter :\n    lowerBounds s ∪ lowerBounds t ⊆ lowerBounds (s ∩ t) :=\n  @union_upperBounds_subset_upperBounds_inter αᵒᵈ _ s t\n\n"}
{"name":"isLeast_union_iff","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\ns t : Set α\n⊢ Iff (IsLeast (Union.union s t) a) (Or (And (IsLeast s a) (Membership.mem (lowerBounds t) a)) (And (Membership.mem (lowerBounds s) a) (IsLeast t a)))","decl":"theorem isLeast_union_iff {a : α} {s t : Set α} :\n    IsLeast (s ∪ t) a ↔ IsLeast s a ∧ a ∈ lowerBounds t ∨ a ∈ lowerBounds s ∧ IsLeast t a := by\n  simp [IsLeast, lowerBounds_union, or_and_right, and_comm (a := a ∈ t), and_assoc]\n\n"}
{"name":"isGreatest_union_iff","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns t : Set α\na : α\n⊢ Iff (IsGreatest (Union.union s t) a) (Or (And (IsGreatest s a) (Membership.mem (upperBounds t) a)) (And (Membership.mem (upperBounds s) a) (IsGreatest t a)))","decl":"theorem isGreatest_union_iff :\n    IsGreatest (s ∪ t) a ↔\n      IsGreatest s a ∧ a ∈ upperBounds t ∨ a ∈ upperBounds s ∧ IsGreatest t a :=\n  @isLeast_union_iff αᵒᵈ _ a s t\n\n"}
{"name":"BddAbove.inter_of_left","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns t : Set α\nh : BddAbove s\n⊢ BddAbove (Inter.inter s t)","decl":"/-- If `s` is bounded, then so is `s ∩ t` -/\ntheorem BddAbove.inter_of_left (h : BddAbove s) : BddAbove (s ∩ t) :=\n  h.mono inter_subset_left\n\n"}
{"name":"BddAbove.inter_of_right","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns t : Set α\nh : BddAbove t\n⊢ BddAbove (Inter.inter s t)","decl":"/-- If `t` is bounded, then so is `s ∩ t` -/\ntheorem BddAbove.inter_of_right (h : BddAbove t) : BddAbove (s ∩ t) :=\n  h.mono inter_subset_right\n\n"}
{"name":"BddBelow.inter_of_left","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns t : Set α\nh : BddBelow s\n⊢ BddBelow (Inter.inter s t)","decl":"/-- If `s` is bounded, then so is `s ∩ t` -/\ntheorem BddBelow.inter_of_left (h : BddBelow s) : BddBelow (s ∩ t) :=\n  h.mono inter_subset_left\n\n"}
{"name":"BddBelow.inter_of_right","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns t : Set α\nh : BddBelow t\n⊢ BddBelow (Inter.inter s t)","decl":"/-- If `t` is bounded, then so is `s ∩ t` -/\ntheorem BddBelow.inter_of_right (h : BddBelow t) : BddBelow (s ∩ t) :=\n  h.mono inter_subset_right\n\n"}
{"name":"BddAbove.union","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : IsDirected α fun x1 x2 => LE.le x1 x2\ns t : Set α\na✝¹ : BddAbove s\na✝ : BddAbove t\n⊢ BddAbove (Union.union s t)","decl":"/-- In a directed order, the union of bounded above sets is bounded above. -/\ntheorem BddAbove.union [IsDirected α (· ≤ ·)] {s t : Set α} :\n    BddAbove s → BddAbove t → BddAbove (s ∪ t) := by\n  rintro ⟨a, ha⟩ ⟨b, hb⟩\n  obtain ⟨c, hca, hcb⟩ := exists_ge_ge a b\n  rw [BddAbove, upperBounds_union]\n  exact ⟨c, upperBounds_mono_mem hca ha, upperBounds_mono_mem hcb hb⟩\n\n"}
{"name":"bddAbove_union","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : IsDirected α fun x1 x2 => LE.le x1 x2\ns t : Set α\n⊢ Iff (BddAbove (Union.union s t)) (And (BddAbove s) (BddAbove t))","decl":"/-- In a directed order, the union of two sets is bounded above if and only if both sets are. -/\ntheorem bddAbove_union [IsDirected α (· ≤ ·)] {s t : Set α} :\n    BddAbove (s ∪ t) ↔ BddAbove s ∧ BddAbove t :=\n  ⟨fun h => ⟨h.mono subset_union_left, h.mono subset_union_right⟩, fun h =>\n    h.1.union h.2⟩\n\n"}
{"name":"BddBelow.union","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : IsDirected α fun x1 x2 => GE.ge x1 x2\ns t : Set α\na✝¹ : BddBelow s\na✝ : BddBelow t\n⊢ BddBelow (Union.union s t)","decl":"/-- In a codirected order, the union of bounded below sets is bounded below. -/\ntheorem BddBelow.union [IsDirected α (· ≥ ·)] {s t : Set α} :\n    BddBelow s → BddBelow t → BddBelow (s ∪ t) :=\n  @BddAbove.union αᵒᵈ _ _ _ _\n\n"}
{"name":"bddBelow_union","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : IsDirected α fun x1 x2 => GE.ge x1 x2\ns t : Set α\n⊢ Iff (BddBelow (Union.union s t)) (And (BddBelow s) (BddBelow t))","decl":"/-- In a codirected order, the union of two sets is bounded below if and only if both sets are. -/\ntheorem bddBelow_union [IsDirected α (· ≥ ·)] {s t : Set α} :\n    BddBelow (s ∪ t) ↔ BddBelow s ∧ BddBelow t :=\n  @bddAbove_union αᵒᵈ _ _ _ _\n\n"}
{"name":"IsLUB.union","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : SemilatticeSup γ\na b : γ\ns t : Set γ\nhs : IsLUB s a\nht : IsLUB t b\n⊢ IsLUB (Union.union s t) (Max.max a b)","decl":"/-- If `a` is the least upper bound of `s` and `b` is the least upper bound of `t`,\nthen `a ⊔ b` is the least upper bound of `s ∪ t`. -/\ntheorem IsLUB.union [SemilatticeSup γ] {a b : γ} {s t : Set γ} (hs : IsLUB s a) (ht : IsLUB t b) :\n    IsLUB (s ∪ t) (a ⊔ b) :=\n  ⟨fun _ h =>\n    h.casesOn (fun h => le_sup_of_le_left <| hs.left h) fun h => le_sup_of_le_right <| ht.left h,\n    fun _ hc =>\n    sup_le (hs.right fun _ hd => hc <| Or.inl hd) (ht.right fun _ hd => hc <| Or.inr hd)⟩\n\n"}
{"name":"IsGLB.union","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : SemilatticeInf γ\na₁ a₂ : γ\ns t : Set γ\nhs : IsGLB s a₁\nht : IsGLB t a₂\n⊢ IsGLB (Union.union s t) (Min.min a₁ a₂)","decl":"/-- If `a` is the greatest lower bound of `s` and `b` is the greatest lower bound of `t`,\nthen `a ⊓ b` is the greatest lower bound of `s ∪ t`. -/\ntheorem IsGLB.union [SemilatticeInf γ] {a₁ a₂ : γ} {s t : Set γ} (hs : IsGLB s a₁)\n    (ht : IsGLB t a₂) : IsGLB (s ∪ t) (a₁ ⊓ a₂) :=\n  hs.dual.union ht\n\n"}
{"name":"IsLeast.union","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : LinearOrder γ\na b : γ\ns t : Set γ\nha : IsLeast s a\nhb : IsLeast t b\n⊢ IsLeast (Union.union s t) (Min.min a b)","decl":"/-- If `a` is the least element of `s` and `b` is the least element of `t`,\nthen `min a b` is the least element of `s ∪ t`. -/\ntheorem IsLeast.union [LinearOrder γ] {a b : γ} {s t : Set γ} (ha : IsLeast s a)\n    (hb : IsLeast t b) : IsLeast (s ∪ t) (min a b) :=\n  ⟨by rcases le_total a b with h | h <;> simp [h, ha.1, hb.1], (ha.isGLB.union hb.isGLB).1⟩\n\n"}
{"name":"IsGreatest.union","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : LinearOrder γ\na b : γ\ns t : Set γ\nha : IsGreatest s a\nhb : IsGreatest t b\n⊢ IsGreatest (Union.union s t) (Max.max a b)","decl":"/-- If `a` is the greatest element of `s` and `b` is the greatest element of `t`,\nthen `max a b` is the greatest element of `s ∪ t`. -/\ntheorem IsGreatest.union [LinearOrder γ] {a b : γ} {s t : Set γ} (ha : IsGreatest s a)\n    (hb : IsGreatest t b) : IsGreatest (s ∪ t) (max a b) :=\n  ⟨by rcases le_total a b with h | h <;> simp [h, ha.1, hb.1], (ha.isLUB.union hb.isLUB).1⟩\n\n"}
{"name":"IsLUB.inter_Ici_of_mem","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : LinearOrder γ\ns : Set γ\na b : γ\nha : IsLUB s a\nhb : Membership.mem s b\n⊢ IsLUB (Inter.inter s (Set.Ici b)) a","decl":"theorem IsLUB.inter_Ici_of_mem [LinearOrder γ] {s : Set γ} {a b : γ} (ha : IsLUB s a) (hb : b ∈ s) :\n    IsLUB (s ∩ Ici b) a :=\n  ⟨fun _ hx => ha.1 hx.1, fun c hc =>\n    have hbc : b ≤ c := hc ⟨hb, le_rfl⟩\n    ha.2 fun x hx => ((le_total x b).elim fun hxb => hxb.trans hbc) fun hbx => hc ⟨hx, hbx⟩⟩\n\n"}
{"name":"IsGLB.inter_Iic_of_mem","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : LinearOrder γ\ns : Set γ\na b : γ\nha : IsGLB s a\nhb : Membership.mem s b\n⊢ IsGLB (Inter.inter s (Set.Iic b)) a","decl":"theorem IsGLB.inter_Iic_of_mem [LinearOrder γ] {s : Set γ} {a b : γ} (ha : IsGLB s a) (hb : b ∈ s) :\n    IsGLB (s ∩ Iic b) a :=\n  ha.dual.inter_Ici_of_mem hb\n\n"}
{"name":"bddAbove_iff_exists_ge","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : SemilatticeSup γ\ns : Set γ\nx₀ : γ\n⊢ Iff (BddAbove s) (Exists fun x => And (LE.le x₀ x) (∀ (y : γ), Membership.mem s y → LE.le y x))","decl":"theorem bddAbove_iff_exists_ge [SemilatticeSup γ] {s : Set γ} (x₀ : γ) :\n    BddAbove s ↔ ∃ x, x₀ ≤ x ∧ ∀ y ∈ s, y ≤ x := by\n  rw [bddAbove_def, exists_ge_and_iff_exists]\n  exact Monotone.ball fun x _ => monotone_le\n\n"}
{"name":"bddBelow_iff_exists_le","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : SemilatticeInf γ\ns : Set γ\nx₀ : γ\n⊢ Iff (BddBelow s) (Exists fun x => And (LE.le x x₀) (∀ (y : γ), Membership.mem s y → LE.le x y))","decl":"theorem bddBelow_iff_exists_le [SemilatticeInf γ] {s : Set γ} (x₀ : γ) :\n    BddBelow s ↔ ∃ x, x ≤ x₀ ∧ ∀ y ∈ s, x ≤ y :=\n  bddAbove_iff_exists_ge (toDual x₀)\n\n"}
{"name":"BddAbove.exists_ge","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : SemilatticeSup γ\ns : Set γ\nhs : BddAbove s\nx₀ : γ\n⊢ Exists fun x => And (LE.le x₀ x) (∀ (y : γ), Membership.mem s y → LE.le y x)","decl":"theorem BddAbove.exists_ge [SemilatticeSup γ] {s : Set γ} (hs : BddAbove s) (x₀ : γ) :\n    ∃ x, x₀ ≤ x ∧ ∀ y ∈ s, y ≤ x :=\n  (bddAbove_iff_exists_ge x₀).mp hs\n\n"}
{"name":"BddBelow.exists_le","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : SemilatticeInf γ\ns : Set γ\nhs : BddBelow s\nx₀ : γ\n⊢ Exists fun x => And (LE.le x x₀) (∀ (y : γ), Membership.mem s y → LE.le x y)","decl":"theorem BddBelow.exists_le [SemilatticeInf γ] {s : Set γ} (hs : BddBelow s) (x₀ : γ) :\n    ∃ x, x ≤ x₀ ∧ ∀ y ∈ s, x ≤ y :=\n  (bddBelow_iff_exists_le x₀).mp hs\n\n"}
{"name":"isLeast_Ici","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ IsLeast (Set.Ici a) a","decl":"theorem isLeast_Ici : IsLeast (Ici a) a :=\n  ⟨left_mem_Ici, fun _ => id⟩\n\n"}
{"name":"isGreatest_Iic","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ IsGreatest (Set.Iic a) a","decl":"theorem isGreatest_Iic : IsGreatest (Iic a) a :=\n  ⟨right_mem_Iic, fun _ => id⟩\n\n"}
{"name":"isLUB_Iic","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ IsLUB (Set.Iic a) a","decl":"theorem isLUB_Iic : IsLUB (Iic a) a :=\n  isGreatest_Iic.isLUB\n\n"}
{"name":"isGLB_Ici","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ IsGLB (Set.Ici a) a","decl":"theorem isGLB_Ici : IsGLB (Ici a) a :=\n  isLeast_Ici.isGLB\n\n"}
{"name":"upperBounds_Iic","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ Eq (upperBounds (Set.Iic a)) (Set.Ici a)","decl":"theorem upperBounds_Iic : upperBounds (Iic a) = Ici a :=\n  isLUB_Iic.upperBounds_eq\n\n"}
{"name":"lowerBounds_Ici","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ Eq (lowerBounds (Set.Ici a)) (Set.Iic a)","decl":"theorem lowerBounds_Ici : lowerBounds (Ici a) = Iic a :=\n  isGLB_Ici.lowerBounds_eq\n\n"}
{"name":"bddAbove_Iic","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ BddAbove (Set.Iic a)","decl":"theorem bddAbove_Iic : BddAbove (Iic a) :=\n  isLUB_Iic.bddAbove\n\n"}
{"name":"bddBelow_Ici","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ BddBelow (Set.Ici a)","decl":"theorem bddBelow_Ici : BddBelow (Ici a) :=\n  isGLB_Ici.bddBelow\n\n"}
{"name":"bddAbove_Iio","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ BddAbove (Set.Iio a)","decl":"theorem bddAbove_Iio : BddAbove (Iio a) :=\n  ⟨a, fun _ hx => le_of_lt hx⟩\n\n"}
{"name":"bddBelow_Ioi","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ BddBelow (Set.Ioi a)","decl":"theorem bddBelow_Ioi : BddBelow (Ioi a) :=\n  ⟨a, fun _ hx => le_of_lt hx⟩\n\n"}
{"name":"lub_Iio_le","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\nb a : α\nhb : IsLUB (Set.Iio a) b\n⊢ LE.le b a","decl":"theorem lub_Iio_le (a : α) (hb : IsLUB (Iio a) b) : b ≤ a :=\n  (isLUB_le_iff hb).mpr fun _ hk => le_of_lt hk\n\n"}
{"name":"le_glb_Ioi","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\nb a : α\nhb : IsGLB (Set.Ioi a) b\n⊢ LE.le a b","decl":"theorem le_glb_Ioi (a : α) (hb : IsGLB (Ioi a) b) : a ≤ b :=\n  @lub_Iio_le αᵒᵈ _ _ a hb\n\n"}
{"name":"lub_Iio_eq_self_or_Iio_eq_Iic","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : PartialOrder γ\nj i : γ\nhj : IsLUB (Set.Iio i) j\n⊢ Or (Eq j i) (Eq (Set.Iio i) (Set.Iic j))","decl":"theorem lub_Iio_eq_self_or_Iio_eq_Iic [PartialOrder γ] {j : γ} (i : γ) (hj : IsLUB (Iio i) j) :\n    j = i ∨ Iio i = Iic j := by\n  rcases eq_or_lt_of_le (lub_Iio_le i hj) with hj_eq_i | hj_lt_i\n  · exact Or.inl hj_eq_i\n  · right\n    exact Set.ext fun k => ⟨fun hk_lt => hj.1 hk_lt, fun hk_le_j => lt_of_le_of_lt hk_le_j hj_lt_i⟩\n\n"}
{"name":"glb_Ioi_eq_self_or_Ioi_eq_Ici","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : PartialOrder γ\nj i : γ\nhj : IsGLB (Set.Ioi i) j\n⊢ Or (Eq j i) (Eq (Set.Ioi i) (Set.Ici j))","decl":"theorem glb_Ioi_eq_self_or_Ioi_eq_Ici [PartialOrder γ] {j : γ} (i : γ) (hj : IsGLB (Ioi i) j) :\n    j = i ∨ Ioi i = Ici j :=\n  @lub_Iio_eq_self_or_Iio_eq_Iic γᵒᵈ _ j i hj\n\n"}
{"name":"exists_lub_Iio","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : LinearOrder γ\ni : γ\n⊢ Exists fun j => IsLUB (Set.Iio i) j","decl":"theorem exists_lub_Iio (i : γ) : ∃ j, IsLUB (Iio i) j := by\n  by_cases h_exists_lt : ∃ j, j ∈ upperBounds (Iio i) ∧ j < i\n  · obtain ⟨j, hj_ub, hj_lt_i⟩ := h_exists_lt\n    exact ⟨j, hj_ub, fun k hk_ub => hk_ub hj_lt_i⟩\n  · refine ⟨i, fun j hj => le_of_lt hj, ?_⟩\n    rw [mem_lowerBounds]\n    by_contra h\n    refine h_exists_lt ?_\n    push_neg at h\n    exact h\n\n"}
{"name":"exists_glb_Ioi","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : LinearOrder γ\ni : γ\n⊢ Exists fun j => IsGLB (Set.Ioi i) j","decl":"theorem exists_glb_Ioi (i : γ) : ∃ j, IsGLB (Ioi i) j :=\n  @exists_lub_Iio γᵒᵈ _ i\n\n"}
{"name":"isLUB_Iio","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝¹ : LinearOrder γ\ninst✝ : DenselyOrdered γ\na : γ\n⊢ IsLUB (Set.Iio a) a","decl":"theorem isLUB_Iio {a : γ} : IsLUB (Iio a) a :=\n  ⟨fun _ hx => le_of_lt hx, fun _ hy => le_of_forall_lt_imp_le_of_dense hy⟩\n\n"}
{"name":"isGLB_Ioi","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝¹ : LinearOrder γ\ninst✝ : DenselyOrdered γ\na : γ\n⊢ IsGLB (Set.Ioi a) a","decl":"theorem isGLB_Ioi {a : γ} : IsGLB (Ioi a) a :=\n  @isLUB_Iio γᵒᵈ _ _ a\n\n"}
{"name":"upperBounds_Iio","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝¹ : LinearOrder γ\ninst✝ : DenselyOrdered γ\na : γ\n⊢ Eq (upperBounds (Set.Iio a)) (Set.Ici a)","decl":"theorem upperBounds_Iio {a : γ} : upperBounds (Iio a) = Ici a :=\n  isLUB_Iio.upperBounds_eq\n\n"}
{"name":"lowerBounds_Ioi","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝¹ : LinearOrder γ\ninst✝ : DenselyOrdered γ\na : γ\n⊢ Eq (lowerBounds (Set.Ioi a)) (Set.Iic a)","decl":"theorem lowerBounds_Ioi {a : γ} : lowerBounds (Ioi a) = Iic a :=\n  isGLB_Ioi.lowerBounds_eq\n\n"}
{"name":"isGreatest_singleton","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ IsGreatest (Singleton.singleton a) a","decl":"@[simp] theorem isGreatest_singleton : IsGreatest {a} a :=\n  ⟨mem_singleton a, fun _ hx => le_of_eq <| eq_of_mem_singleton hx⟩\n\n"}
{"name":"isLeast_singleton","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ IsLeast (Singleton.singleton a) a","decl":"@[simp] theorem isLeast_singleton : IsLeast {a} a :=\n  @isGreatest_singleton αᵒᵈ _ a\n\n"}
{"name":"isLUB_singleton","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ IsLUB (Singleton.singleton a) a","decl":"@[simp] theorem isLUB_singleton : IsLUB {a} a :=\n  isGreatest_singleton.isLUB\n\n"}
{"name":"isGLB_singleton","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ IsGLB (Singleton.singleton a) a","decl":"@[simp] theorem isGLB_singleton : IsGLB {a} a :=\n  isLeast_singleton.isGLB\n\n"}
{"name":"bddAbove_singleton","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ BddAbove (Singleton.singleton a)","decl":"@[simp] lemma bddAbove_singleton : BddAbove ({a} : Set α) := isLUB_singleton.bddAbove\n\n"}
{"name":"bddBelow_singleton","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ BddBelow (Singleton.singleton a)","decl":"@[simp] lemma bddBelow_singleton : BddBelow ({a} : Set α) := isGLB_singleton.bddBelow\n\n"}
{"name":"upperBounds_singleton","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ Eq (upperBounds (Singleton.singleton a)) (Set.Ici a)","decl":"@[simp]\ntheorem upperBounds_singleton : upperBounds {a} = Ici a :=\n  isLUB_singleton.upperBounds_eq\n\n"}
{"name":"lowerBounds_singleton","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ Eq (lowerBounds (Singleton.singleton a)) (Set.Iic a)","decl":"@[simp]\ntheorem lowerBounds_singleton : lowerBounds {a} = Iic a :=\n  isGLB_singleton.lowerBounds_eq\n\n"}
{"name":"bddAbove_Icc","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na b : α\n⊢ BddAbove (Set.Icc a b)","decl":"theorem bddAbove_Icc : BddAbove (Icc a b) :=\n  ⟨b, fun _ => And.right⟩\n\n"}
{"name":"bddBelow_Icc","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na b : α\n⊢ BddBelow (Set.Icc a b)","decl":"theorem bddBelow_Icc : BddBelow (Icc a b) :=\n  ⟨a, fun _ => And.left⟩\n\n"}
{"name":"bddAbove_Ico","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na b : α\n⊢ BddAbove (Set.Ico a b)","decl":"theorem bddAbove_Ico : BddAbove (Ico a b) :=\n  bddAbove_Icc.mono Ico_subset_Icc_self\n\n"}
{"name":"bddBelow_Ico","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na b : α\n⊢ BddBelow (Set.Ico a b)","decl":"theorem bddBelow_Ico : BddBelow (Ico a b) :=\n  bddBelow_Icc.mono Ico_subset_Icc_self\n\n"}
{"name":"bddAbove_Ioc","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na b : α\n⊢ BddAbove (Set.Ioc a b)","decl":"theorem bddAbove_Ioc : BddAbove (Ioc a b) :=\n  bddAbove_Icc.mono Ioc_subset_Icc_self\n\n"}
{"name":"bddBelow_Ioc","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na b : α\n⊢ BddBelow (Set.Ioc a b)","decl":"theorem bddBelow_Ioc : BddBelow (Ioc a b) :=\n  bddBelow_Icc.mono Ioc_subset_Icc_self\n\n"}
{"name":"bddAbove_Ioo","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na b : α\n⊢ BddAbove (Set.Ioo a b)","decl":"theorem bddAbove_Ioo : BddAbove (Ioo a b) :=\n  bddAbove_Icc.mono Ioo_subset_Icc_self\n\n"}
{"name":"bddBelow_Ioo","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na b : α\n⊢ BddBelow (Set.Ioo a b)","decl":"theorem bddBelow_Ioo : BddBelow (Ioo a b) :=\n  bddBelow_Icc.mono Ioo_subset_Icc_self\n\n"}
{"name":"isGreatest_Icc","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na b : α\nh : LE.le a b\n⊢ IsGreatest (Set.Icc a b) b","decl":"theorem isGreatest_Icc (h : a ≤ b) : IsGreatest (Icc a b) b :=\n  ⟨right_mem_Icc.2 h, fun _ => And.right⟩\n\n"}
{"name":"isLUB_Icc","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na b : α\nh : LE.le a b\n⊢ IsLUB (Set.Icc a b) b","decl":"theorem isLUB_Icc (h : a ≤ b) : IsLUB (Icc a b) b :=\n  (isGreatest_Icc h).isLUB\n\n"}
{"name":"upperBounds_Icc","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na b : α\nh : LE.le a b\n⊢ Eq (upperBounds (Set.Icc a b)) (Set.Ici b)","decl":"theorem upperBounds_Icc (h : a ≤ b) : upperBounds (Icc a b) = Ici b :=\n  (isLUB_Icc h).upperBounds_eq\n\n"}
{"name":"isLeast_Icc","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na b : α\nh : LE.le a b\n⊢ IsLeast (Set.Icc a b) a","decl":"theorem isLeast_Icc (h : a ≤ b) : IsLeast (Icc a b) a :=\n  ⟨left_mem_Icc.2 h, fun _ => And.left⟩\n\n"}
{"name":"isGLB_Icc","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na b : α\nh : LE.le a b\n⊢ IsGLB (Set.Icc a b) a","decl":"theorem isGLB_Icc (h : a ≤ b) : IsGLB (Icc a b) a :=\n  (isLeast_Icc h).isGLB\n\n"}
{"name":"lowerBounds_Icc","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na b : α\nh : LE.le a b\n⊢ Eq (lowerBounds (Set.Icc a b)) (Set.Iic a)","decl":"theorem lowerBounds_Icc (h : a ≤ b) : lowerBounds (Icc a b) = Iic a :=\n  (isGLB_Icc h).lowerBounds_eq\n\n"}
{"name":"isGreatest_Ioc","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na b : α\nh : LT.lt a b\n⊢ IsGreatest (Set.Ioc a b) b","decl":"theorem isGreatest_Ioc (h : a < b) : IsGreatest (Ioc a b) b :=\n  ⟨right_mem_Ioc.2 h, fun _ => And.right⟩\n\n"}
{"name":"isLUB_Ioc","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na b : α\nh : LT.lt a b\n⊢ IsLUB (Set.Ioc a b) b","decl":"theorem isLUB_Ioc (h : a < b) : IsLUB (Ioc a b) b :=\n  (isGreatest_Ioc h).isLUB\n\n"}
{"name":"upperBounds_Ioc","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na b : α\nh : LT.lt a b\n⊢ Eq (upperBounds (Set.Ioc a b)) (Set.Ici b)","decl":"theorem upperBounds_Ioc (h : a < b) : upperBounds (Ioc a b) = Ici b :=\n  (isLUB_Ioc h).upperBounds_eq\n\n"}
{"name":"isLeast_Ico","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na b : α\nh : LT.lt a b\n⊢ IsLeast (Set.Ico a b) a","decl":"theorem isLeast_Ico (h : a < b) : IsLeast (Ico a b) a :=\n  ⟨left_mem_Ico.2 h, fun _ => And.left⟩\n\n"}
{"name":"isGLB_Ico","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na b : α\nh : LT.lt a b\n⊢ IsGLB (Set.Ico a b) a","decl":"theorem isGLB_Ico (h : a < b) : IsGLB (Ico a b) a :=\n  (isLeast_Ico h).isGLB\n\n"}
{"name":"lowerBounds_Ico","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na b : α\nh : LT.lt a b\n⊢ Eq (lowerBounds (Set.Ico a b)) (Set.Iic a)","decl":"theorem lowerBounds_Ico (h : a < b) : lowerBounds (Ico a b) = Iic a :=\n  (isGLB_Ico h).lowerBounds_eq\n\n"}
{"name":"isGLB_Ioo","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝¹ : SemilatticeSup γ\ninst✝ : DenselyOrdered γ\na b : γ\nh : LT.lt a b\n⊢ IsGLB (Set.Ioo a b) a","decl":"theorem isGLB_Ioo {a b : γ} (h : a < b) : IsGLB (Ioo a b) a :=\n  ⟨fun _ hx => hx.1.le, fun x hx => by\n    rcases eq_or_lt_of_le (le_sup_right : a ≤ x ⊔ a) with h₁ | h₂\n    · exact h₁.symm ▸ le_sup_left\n    obtain ⟨y, lty, ylt⟩ := exists_between h₂\n    apply (not_lt_of_le (sup_le (hx ⟨lty, ylt.trans_le (sup_le _ h.le)⟩) lty.le) ylt).elim\n    obtain ⟨u, au, ub⟩ := exists_between h\n    apply (hx ⟨au, ub⟩).trans ub.le⟩\n\n"}
{"name":"lowerBounds_Ioo","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝¹ : SemilatticeSup γ\ninst✝ : DenselyOrdered γ\na b : γ\nhab : LT.lt a b\n⊢ Eq (lowerBounds (Set.Ioo a b)) (Set.Iic a)","decl":"theorem lowerBounds_Ioo {a b : γ} (hab : a < b) : lowerBounds (Ioo a b) = Iic a :=\n  (isGLB_Ioo hab).lowerBounds_eq\n\n"}
{"name":"isGLB_Ioc","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝¹ : SemilatticeSup γ\ninst✝ : DenselyOrdered γ\na b : γ\nhab : LT.lt a b\n⊢ IsGLB (Set.Ioc a b) a","decl":"theorem isGLB_Ioc {a b : γ} (hab : a < b) : IsGLB (Ioc a b) a :=\n  (isGLB_Ioo hab).of_subset_of_superset (isGLB_Icc hab.le) Ioo_subset_Ioc_self Ioc_subset_Icc_self\n\n"}
{"name":"lowerBounds_Ioc","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝¹ : SemilatticeSup γ\ninst✝ : DenselyOrdered γ\na b : γ\nhab : LT.lt a b\n⊢ Eq (lowerBounds (Set.Ioc a b)) (Set.Iic a)","decl":"theorem lowerBounds_Ioc {a b : γ} (hab : a < b) : lowerBounds (Ioc a b) = Iic a :=\n  (isGLB_Ioc hab).lowerBounds_eq\n\n"}
{"name":"isLUB_Ioo","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝¹ : SemilatticeInf γ\ninst✝ : DenselyOrdered γ\na b : γ\nhab : LT.lt a b\n⊢ IsLUB (Set.Ioo a b) b","decl":"theorem isLUB_Ioo {a b : γ} (hab : a < b) : IsLUB (Ioo a b) b := by\n  simpa only [dual_Ioo] using isGLB_Ioo hab.dual\n\n"}
{"name":"upperBounds_Ioo","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝¹ : SemilatticeInf γ\ninst✝ : DenselyOrdered γ\na b : γ\nhab : LT.lt a b\n⊢ Eq (upperBounds (Set.Ioo a b)) (Set.Ici b)","decl":"theorem upperBounds_Ioo {a b : γ} (hab : a < b) : upperBounds (Ioo a b) = Ici b :=\n  (isLUB_Ioo hab).upperBounds_eq\n\n"}
{"name":"isLUB_Ico","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝¹ : SemilatticeInf γ\ninst✝ : DenselyOrdered γ\na b : γ\nhab : LT.lt a b\n⊢ IsLUB (Set.Ico a b) b","decl":"theorem isLUB_Ico {a b : γ} (hab : a < b) : IsLUB (Ico a b) b := by\n  simpa only [dual_Ioc] using isGLB_Ioc hab.dual\n\n"}
{"name":"upperBounds_Ico","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝¹ : SemilatticeInf γ\ninst✝ : DenselyOrdered γ\na b : γ\nhab : LT.lt a b\n⊢ Eq (upperBounds (Set.Ico a b)) (Set.Ici b)","decl":"theorem upperBounds_Ico {a b : γ} (hab : a < b) : upperBounds (Ico a b) = Ici b :=\n  (isLUB_Ico hab).upperBounds_eq\n\n"}
{"name":"bddBelow_iff_subset_Ici","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (BddBelow s) (Exists fun a => HasSubset.Subset s (Set.Ici a))","decl":"theorem bddBelow_iff_subset_Ici : BddBelow s ↔ ∃ a, s ⊆ Ici a :=\n  Iff.rfl\n\n"}
{"name":"bddAbove_iff_subset_Iic","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (BddAbove s) (Exists fun a => HasSubset.Subset s (Set.Iic a))","decl":"theorem bddAbove_iff_subset_Iic : BddAbove s ↔ ∃ a, s ⊆ Iic a :=\n  Iff.rfl\n\n"}
{"name":"bddBelow_bddAbove_iff_subset_Icc","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (And (BddBelow s) (BddAbove s)) (Exists fun a => Exists fun b => HasSubset.Subset s (Set.Icc a b))","decl":"theorem bddBelow_bddAbove_iff_subset_Icc : BddBelow s ∧ BddAbove s ↔ ∃ a b, s ⊆ Icc a b := by\n  simp [Ici_inter_Iic.symm, subset_inter_iff, bddBelow_iff_subset_Ici,\n    bddAbove_iff_subset_Iic, exists_and_left, exists_and_right]\n\n"}
{"name":"isGreatest_univ_iff","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ Iff (IsGreatest Set.univ a) (IsTop a)","decl":"@[simp] theorem isGreatest_univ_iff : IsGreatest univ a ↔ IsTop a := by\n  simp [IsGreatest, mem_upperBounds, IsTop]\n\n"}
{"name":"isGreatest_univ","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\n⊢ IsGreatest Set.univ Top.top","decl":"theorem isGreatest_univ [OrderTop α] : IsGreatest (univ : Set α) ⊤ :=\n  isGreatest_univ_iff.2 isTop_top\n\n"}
{"name":"OrderTop.upperBounds_univ","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝¹ : PartialOrder γ\ninst✝ : OrderTop γ\n⊢ Eq (upperBounds Set.univ) (Singleton.singleton Top.top)","decl":"@[simp]\ntheorem OrderTop.upperBounds_univ [PartialOrder γ] [OrderTop γ] :\n    upperBounds (univ : Set γ) = {⊤} := by rw [isGreatest_univ.upperBounds_eq, Ici_top]\n\n"}
{"name":"isLUB_univ","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\n⊢ IsLUB Set.univ Top.top","decl":"theorem isLUB_univ [OrderTop α] : IsLUB (univ : Set α) ⊤ :=\n  isGreatest_univ.isLUB\n\n"}
{"name":"OrderBot.lowerBounds_univ","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝¹ : PartialOrder γ\ninst✝ : OrderBot γ\n⊢ Eq (lowerBounds Set.univ) (Singleton.singleton Bot.bot)","decl":"@[simp]\ntheorem OrderBot.lowerBounds_univ [PartialOrder γ] [OrderBot γ] :\n    lowerBounds (univ : Set γ) = {⊥} :=\n  @OrderTop.upperBounds_univ γᵒᵈ _ _\n\n"}
{"name":"isLeast_univ_iff","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ Iff (IsLeast Set.univ a) (IsBot a)","decl":"@[simp] theorem isLeast_univ_iff : IsLeast univ a ↔ IsBot a :=\n  @isGreatest_univ_iff αᵒᵈ _ _\n\n"}
{"name":"isLeast_univ","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\n⊢ IsLeast Set.univ Bot.bot","decl":"theorem isLeast_univ [OrderBot α] : IsLeast (univ : Set α) ⊥ :=\n  @isGreatest_univ αᵒᵈ _ _\n\n"}
{"name":"isGLB_univ","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\n⊢ IsGLB Set.univ Bot.bot","decl":"theorem isGLB_univ [OrderBot α] : IsGLB (univ : Set α) ⊥ :=\n  isLeast_univ.isGLB\n\n"}
{"name":"NoMaxOrder.upperBounds_univ","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : NoMaxOrder α\n⊢ Eq (upperBounds Set.univ) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem NoMaxOrder.upperBounds_univ [NoMaxOrder α] : upperBounds (univ : Set α) = ∅ :=\n  eq_empty_of_subset_empty fun b hb =>\n    let ⟨_, hx⟩ := exists_gt b\n    not_le_of_lt hx (hb trivial)\n\n"}
{"name":"NoMinOrder.lowerBounds_univ","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : NoMinOrder α\n⊢ Eq (lowerBounds Set.univ) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem NoMinOrder.lowerBounds_univ [NoMinOrder α] : lowerBounds (univ : Set α) = ∅ :=\n  @NoMaxOrder.upperBounds_univ αᵒᵈ _ _\n\n"}
{"name":"not_bddAbove_univ","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : NoMaxOrder α\n⊢ Not (BddAbove Set.univ)","decl":"@[simp]\ntheorem not_bddAbove_univ [NoMaxOrder α] : ¬BddAbove (univ : Set α) := by simp [BddAbove]\n\n"}
{"name":"not_bddBelow_univ","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : NoMinOrder α\n⊢ Not (BddBelow Set.univ)","decl":"@[simp]\ntheorem not_bddBelow_univ [NoMinOrder α] : ¬BddBelow (univ : Set α) :=\n  @not_bddAbove_univ αᵒᵈ _ _\n\n"}
{"name":"upperBounds_empty","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ Eq (upperBounds EmptyCollection.emptyCollection) Set.univ","decl":"@[simp]\ntheorem upperBounds_empty : upperBounds (∅ : Set α) = univ := by\n  simp only [upperBounds, eq_univ_iff_forall, mem_setOf_eq, forall_mem_empty, forall_true_iff]\n\n"}
{"name":"lowerBounds_empty","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ Eq (lowerBounds EmptyCollection.emptyCollection) Set.univ","decl":"@[simp]\ntheorem lowerBounds_empty : lowerBounds (∅ : Set α) = univ :=\n  @upperBounds_empty αᵒᵈ _\n\n"}
{"name":"bddAbove_empty","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\n⊢ BddAbove EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem bddAbove_empty [Nonempty α] : BddAbove (∅ : Set α) := by\n  simp only [BddAbove, upperBounds_empty, univ_nonempty]\n\n"}
{"name":"bddBelow_empty","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\n⊢ BddBelow EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem bddBelow_empty [Nonempty α] : BddBelow (∅ : Set α) := by\n  simp only [BddBelow, lowerBounds_empty, univ_nonempty]\n\n"}
{"name":"isGLB_empty_iff","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ Iff (IsGLB EmptyCollection.emptyCollection a) (IsTop a)","decl":"@[simp] theorem isGLB_empty_iff : IsGLB ∅ a ↔ IsTop a := by\n  simp [IsGLB]\n\n"}
{"name":"isLUB_empty_iff","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\n⊢ Iff (IsLUB EmptyCollection.emptyCollection a) (IsBot a)","decl":"@[simp] theorem isLUB_empty_iff : IsLUB ∅ a ↔ IsBot a :=\n  @isGLB_empty_iff αᵒᵈ _ _\n\n"}
{"name":"isGLB_empty","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\n⊢ IsGLB EmptyCollection.emptyCollection Top.top","decl":"theorem isGLB_empty [OrderTop α] : IsGLB ∅ (⊤ : α) :=\n  isGLB_empty_iff.2 isTop_top\n\n"}
{"name":"isLUB_empty","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\n⊢ IsLUB EmptyCollection.emptyCollection Bot.bot","decl":"theorem isLUB_empty [OrderBot α] : IsLUB ∅ (⊥ : α) :=\n  @isGLB_empty αᵒᵈ _ _\n\n"}
{"name":"IsLUB.nonempty","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ns : Set α\na : α\ninst✝ : NoMinOrder α\nhs : IsLUB s a\n⊢ s.Nonempty","decl":"theorem IsLUB.nonempty [NoMinOrder α] (hs : IsLUB s a) : s.Nonempty :=\n  let ⟨a', ha'⟩ := exists_lt a\n  nonempty_iff_ne_empty.2 fun h =>\n    not_le_of_lt ha' <| hs.right <| by rw [h, upperBounds_empty]; exact mem_univ _\n\n"}
{"name":"IsGLB.nonempty","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ns : Set α\na : α\ninst✝ : NoMaxOrder α\nhs : IsGLB s a\n⊢ s.Nonempty","decl":"theorem IsGLB.nonempty [NoMaxOrder α] (hs : IsGLB s a) : s.Nonempty :=\n  hs.dual.nonempty\n\n"}
{"name":"nonempty_of_not_bddAbove","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\nha : Nonempty α\nh : Not (BddAbove s)\n⊢ s.Nonempty","decl":"theorem nonempty_of_not_bddAbove [ha : Nonempty α] (h : ¬BddAbove s) : s.Nonempty :=\n  (Nonempty.elim ha) fun x => (not_bddAbove_iff'.1 h x).imp fun _ ha => ha.1\n\n"}
{"name":"nonempty_of_not_bddBelow","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ns : Set α\ninst✝ : Nonempty α\nh : Not (BddBelow s)\n⊢ s.Nonempty","decl":"theorem nonempty_of_not_bddBelow [Nonempty α] (h : ¬BddBelow s) : s.Nonempty :=\n  @nonempty_of_not_bddAbove αᵒᵈ _ _ _ h\n\n"}
{"name":"bddAbove_insert","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : IsDirected α fun x1 x2 => LE.le x1 x2\ns : Set α\na : α\n⊢ Iff (BddAbove (Insert.insert a s)) (BddAbove s)","decl":"/-- Adding a point to a set preserves its boundedness above. -/\n@[simp]\ntheorem bddAbove_insert [IsDirected α (· ≤ ·)] {s : Set α} {a : α} :\n    BddAbove (insert a s) ↔ BddAbove s := by\n  simp only [insert_eq, bddAbove_union, bddAbove_singleton, true_and]\n\n"}
{"name":"BddAbove.insert","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : IsDirected α fun x1 x2 => LE.le x1 x2\ns : Set α\na : α\na✝ : BddAbove s\n⊢ BddAbove (Insert.insert a s)","decl":"protected theorem BddAbove.insert [IsDirected α (· ≤ ·)] {s : Set α} (a : α) :\n    BddAbove s → BddAbove (insert a s) :=\n  bddAbove_insert.2\n\n"}
{"name":"bddBelow_insert","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : IsDirected α fun x1 x2 => GE.ge x1 x2\ns : Set α\na : α\n⊢ Iff (BddBelow (Insert.insert a s)) (BddBelow s)","decl":"/-- Adding a point to a set preserves its boundedness below. -/\n@[simp]\ntheorem bddBelow_insert [IsDirected α (· ≥ ·)] {s : Set α} {a : α} :\n    BddBelow (insert a s) ↔ BddBelow s := by\n  simp only [insert_eq, bddBelow_union, bddBelow_singleton, true_and]\n\n"}
{"name":"BddBelow.insert","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : IsDirected α fun x1 x2 => GE.ge x1 x2\ns : Set α\na : α\na✝ : BddBelow s\n⊢ BddBelow (Insert.insert a s)","decl":"protected theorem BddBelow.insert [IsDirected α (· ≥ ·)] {s : Set α} (a : α) :\n    BddBelow s → BddBelow (insert a s) :=\n  bddBelow_insert.2\n\n"}
{"name":"IsLUB.insert","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : SemilatticeSup γ\na b : γ\ns : Set γ\nhs : IsLUB s b\n⊢ IsLUB (Insert.insert a s) (Max.max a b)","decl":"protected theorem IsLUB.insert [SemilatticeSup γ] (a) {b} {s : Set γ} (hs : IsLUB s b) :\n    IsLUB (insert a s) (a ⊔ b) := by\n  rw [insert_eq]\n  exact isLUB_singleton.union hs\n\n"}
{"name":"IsGLB.insert","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : SemilatticeInf γ\na b : γ\ns : Set γ\nhs : IsGLB s b\n⊢ IsGLB (Insert.insert a s) (Min.min a b)","decl":"protected theorem IsGLB.insert [SemilatticeInf γ] (a) {b} {s : Set γ} (hs : IsGLB s b) :\n    IsGLB (insert a s) (a ⊓ b) := by\n  rw [insert_eq]\n  exact isGLB_singleton.union hs\n\n"}
{"name":"IsGreatest.insert","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : LinearOrder γ\na b : γ\ns : Set γ\nhs : IsGreatest s b\n⊢ IsGreatest (Insert.insert a s) (Max.max a b)","decl":"protected theorem IsGreatest.insert [LinearOrder γ] (a) {b} {s : Set γ} (hs : IsGreatest s b) :\n    IsGreatest (insert a s) (max a b) := by\n  rw [insert_eq]\n  exact isGreatest_singleton.union hs\n\n"}
{"name":"IsLeast.insert","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : LinearOrder γ\na b : γ\ns : Set γ\nhs : IsLeast s b\n⊢ IsLeast (Insert.insert a s) (Min.min a b)","decl":"protected theorem IsLeast.insert [LinearOrder γ] (a) {b} {s : Set γ} (hs : IsLeast s b) :\n    IsLeast (insert a s) (min a b) := by\n  rw [insert_eq]\n  exact isLeast_singleton.union hs\n\n"}
{"name":"upperBounds_insert","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\ns : Set α\n⊢ Eq (upperBounds (Insert.insert a s)) (Inter.inter (Set.Ici a) (upperBounds s))","decl":"@[simp]\ntheorem upperBounds_insert (a : α) (s : Set α) :\n    upperBounds (insert a s) = Ici a ∩ upperBounds s := by\n  rw [insert_eq, upperBounds_union, upperBounds_singleton]\n\n"}
{"name":"lowerBounds_insert","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\na : α\ns : Set α\n⊢ Eq (lowerBounds (Insert.insert a s)) (Inter.inter (Set.Iic a) (lowerBounds s))","decl":"@[simp]\ntheorem lowerBounds_insert (a : α) (s : Set α) :\n    lowerBounds (insert a s) = Iic a ∩ lowerBounds s := by\n  rw [insert_eq, lowerBounds_union, lowerBounds_singleton]\n\n"}
{"name":"OrderTop.bddAbove","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\ns : Set α\n⊢ BddAbove s","decl":"/-- When there is a global maximum, every set is bounded above. -/\n@[simp]\nprotected theorem OrderTop.bddAbove [OrderTop α] (s : Set α) : BddAbove s :=\n  ⟨⊤, fun a _ => OrderTop.le_top a⟩\n\n"}
{"name":"OrderBot.bddBelow","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\ns : Set α\n⊢ BddBelow s","decl":"/-- When there is a global minimum, every set is bounded below. -/\n@[simp]\nprotected theorem OrderBot.bddBelow [OrderBot α] (s : Set α) : BddBelow s :=\n  ⟨⊥, fun a _ => OrderBot.bot_le a⟩\n\n"}
{"name":"isLUB_pair","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : SemilatticeSup γ\na b : γ\n⊢ IsLUB (Insert.insert a (Singleton.singleton b)) (Max.max a b)","decl":"theorem isLUB_pair [SemilatticeSup γ] {a b : γ} : IsLUB {a, b} (a ⊔ b) :=\n  isLUB_singleton.insert _\n\n"}
{"name":"isGLB_pair","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : SemilatticeInf γ\na b : γ\n⊢ IsGLB (Insert.insert a (Singleton.singleton b)) (Min.min a b)","decl":"theorem isGLB_pair [SemilatticeInf γ] {a b : γ} : IsGLB {a, b} (a ⊓ b) :=\n  isGLB_singleton.insert _\n\n"}
{"name":"isLeast_pair","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : LinearOrder γ\na b : γ\n⊢ IsLeast (Insert.insert a (Singleton.singleton b)) (Min.min a b)","decl":"theorem isLeast_pair [LinearOrder γ] {a b : γ} : IsLeast {a, b} (min a b) :=\n  isLeast_singleton.insert _\n\n"}
{"name":"isGreatest_pair","module":"Mathlib.Order.Bounds.Basic","initialProofState":"γ : Type v\ninst✝ : LinearOrder γ\na b : γ\n⊢ IsGreatest (Insert.insert a (Singleton.singleton b)) (Max.max a b)","decl":"theorem isGreatest_pair [LinearOrder γ] {a b : γ} : IsGreatest {a, b} (max a b) :=\n  isGreatest_singleton.insert _\n\n"}
{"name":"isLUB_lowerBounds","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\n⊢ Iff (IsLUB (lowerBounds s) a) (IsGLB s a)","decl":"@[simp]\ntheorem isLUB_lowerBounds : IsLUB (lowerBounds s) a ↔ IsGLB s a :=\n  ⟨fun H => ⟨fun _ hx => H.2 <| subset_upperBounds_lowerBounds s hx, H.1⟩, IsGreatest.isLUB⟩\n\n"}
{"name":"isGLB_upperBounds","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na : α\n⊢ Iff (IsGLB (upperBounds s) a) (IsLUB s a)","decl":"@[simp]\ntheorem isGLB_upperBounds : IsGLB (upperBounds s) a ↔ IsLUB s a :=\n  @isLUB_lowerBounds αᵒᵈ _ _ _\n\n"}
{"name":"lowerBounds_le_upperBounds","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na b : α\nha : Membership.mem (lowerBounds s) a\nhb : Membership.mem (upperBounds s) b\na✝ : s.Nonempty\n⊢ LE.le a b","decl":"theorem lowerBounds_le_upperBounds (ha : a ∈ lowerBounds s) (hb : b ∈ upperBounds s) :\n    s.Nonempty → a ≤ b\n  | ⟨_, hc⟩ => le_trans (ha hc) (hb hc)\n\n"}
{"name":"isGLB_le_isLUB","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na b : α\nha : IsGLB s a\nhb : IsLUB s b\nhs : s.Nonempty\n⊢ LE.le a b","decl":"theorem isGLB_le_isLUB (ha : IsGLB s a) (hb : IsLUB s b) (hs : s.Nonempty) : a ≤ b :=\n  lowerBounds_le_upperBounds ha.1 hb.1 hs\n\n"}
{"name":"isLUB_lt_iff","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na b : α\nha : IsLUB s a\n⊢ Iff (LT.lt a b) (Exists fun c => And (Membership.mem (upperBounds s) c) (LT.lt c b))","decl":"theorem isLUB_lt_iff (ha : IsLUB s a) : a < b ↔ ∃ c ∈ upperBounds s, c < b :=\n  ⟨fun hb => ⟨a, ha.1, hb⟩, fun ⟨_, hcs, hcb⟩ => lt_of_le_of_lt (ha.2 hcs) hcb⟩\n\n"}
{"name":"lt_isGLB_iff","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na b : α\nha : IsGLB s a\n⊢ Iff (LT.lt b a) (Exists fun c => And (Membership.mem (lowerBounds s) c) (LT.lt b c))","decl":"theorem lt_isGLB_iff (ha : IsGLB s a) : b < a ↔ ∃ c ∈ lowerBounds s, b < c :=\n  isLUB_lt_iff ha.dual\n\n"}
{"name":"le_of_isLUB_le_isGLB","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\na b x y : α\nha : IsGLB s a\nhb : IsLUB s b\nhab : LE.le b a\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ LE.le x y","decl":"theorem le_of_isLUB_le_isGLB {x y} (ha : IsGLB s a) (hb : IsLUB s b) (hab : b ≤ a) (hx : x ∈ s)\n    (hy : y ∈ s) : x ≤ y :=\n  calc\n    x ≤ b := hb.1 hx\n    _ ≤ a := hab\n    _ ≤ y := ha.1 hy\n\n"}
{"name":"IsLeast.unique","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : PartialOrder α\ns : Set α\na b : α\nHa : IsLeast s a\nHb : IsLeast s b\n⊢ Eq a b","decl":"theorem IsLeast.unique (Ha : IsLeast s a) (Hb : IsLeast s b) : a = b :=\n  le_antisymm (Ha.right Hb.left) (Hb.right Ha.left)\n\n"}
{"name":"IsLeast.isLeast_iff_eq","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : PartialOrder α\ns : Set α\na b : α\nHa : IsLeast s a\n⊢ Iff (IsLeast s b) (Eq a b)","decl":"theorem IsLeast.isLeast_iff_eq (Ha : IsLeast s a) : IsLeast s b ↔ a = b :=\n  Iff.intro Ha.unique fun h => h ▸ Ha\n\n"}
{"name":"IsGreatest.unique","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : PartialOrder α\ns : Set α\na b : α\nHa : IsGreatest s a\nHb : IsGreatest s b\n⊢ Eq a b","decl":"theorem IsGreatest.unique (Ha : IsGreatest s a) (Hb : IsGreatest s b) : a = b :=\n  le_antisymm (Hb.right Ha.left) (Ha.right Hb.left)\n\n"}
{"name":"IsGreatest.isGreatest_iff_eq","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : PartialOrder α\ns : Set α\na b : α\nHa : IsGreatest s a\n⊢ Iff (IsGreatest s b) (Eq a b)","decl":"theorem IsGreatest.isGreatest_iff_eq (Ha : IsGreatest s a) : IsGreatest s b ↔ a = b :=\n  Iff.intro Ha.unique fun h => h ▸ Ha\n\n"}
{"name":"IsLUB.unique","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : PartialOrder α\ns : Set α\na b : α\nHa : IsLUB s a\nHb : IsLUB s b\n⊢ Eq a b","decl":"theorem IsLUB.unique (Ha : IsLUB s a) (Hb : IsLUB s b) : a = b :=\n  IsLeast.unique Ha Hb\n\n"}
{"name":"IsGLB.unique","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : PartialOrder α\ns : Set α\na b : α\nHa : IsGLB s a\nHb : IsGLB s b\n⊢ Eq a b","decl":"theorem IsGLB.unique (Ha : IsGLB s a) (Hb : IsGLB s b) : a = b :=\n  IsGreatest.unique Ha Hb\n\n"}
{"name":"Set.subsingleton_of_isLUB_le_isGLB","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : PartialOrder α\ns : Set α\na b : α\nHa : IsGLB s a\nHb : IsLUB s b\nhab : LE.le b a\n⊢ s.Subsingleton","decl":"theorem Set.subsingleton_of_isLUB_le_isGLB (Ha : IsGLB s a) (Hb : IsLUB s b) (hab : b ≤ a) :\n    s.Subsingleton := fun _ hx _ hy =>\n  le_antisymm (le_of_isLUB_le_isGLB Ha Hb hab hx hy) (le_of_isLUB_le_isGLB Ha Hb hab hy hx)\n\n"}
{"name":"isGLB_lt_isLUB_of_ne","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : PartialOrder α\ns : Set α\na b : α\nHa : IsGLB s a\nHb : IsLUB s b\nx y : α\nHx : Membership.mem s x\nHy : Membership.mem s y\nHxy : Ne x y\n⊢ LT.lt a b","decl":"theorem isGLB_lt_isLUB_of_ne (Ha : IsGLB s a) (Hb : IsLUB s b) {x y} (Hx : x ∈ s) (Hy : y ∈ s)\n    (Hxy : x ≠ y) : a < b :=\n  lt_iff_le_not_le.2\n    ⟨lowerBounds_le_upperBounds Ha.1 Hb.1 ⟨x, Hx⟩, fun hab =>\n      Hxy <| Set.subsingleton_of_isLUB_le_isGLB Ha Hb hab Hx Hy⟩\n\n"}
{"name":"lt_isLUB_iff","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : LinearOrder α\ns : Set α\na b : α\nh : IsLUB s a\n⊢ Iff (LT.lt b a) (Exists fun c => And (Membership.mem s c) (LT.lt b c))","decl":"theorem lt_isLUB_iff (h : IsLUB s a) : b < a ↔ ∃ c ∈ s, b < c := by\n  simp_rw [← not_le, isLUB_le_iff h, mem_upperBounds, not_forall, not_le, exists_prop]\n\n"}
{"name":"isGLB_lt_iff","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : LinearOrder α\ns : Set α\na b : α\nh : IsGLB s a\n⊢ Iff (LT.lt a b) (Exists fun c => And (Membership.mem s c) (LT.lt c b))","decl":"theorem isGLB_lt_iff (h : IsGLB s a) : a < b ↔ ∃ c ∈ s, c < b :=\n  lt_isLUB_iff h.dual\n\n"}
{"name":"IsLUB.exists_between","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : LinearOrder α\ns : Set α\na b : α\nh : IsLUB s a\nhb : LT.lt b a\n⊢ Exists fun c => And (Membership.mem s c) (And (LT.lt b c) (LE.le c a))","decl":"theorem IsLUB.exists_between (h : IsLUB s a) (hb : b < a) : ∃ c ∈ s, b < c ∧ c ≤ a :=\n  let ⟨c, hcs, hbc⟩ := (lt_isLUB_iff h).1 hb\n  ⟨c, hcs, hbc, h.1 hcs⟩\n\n"}
{"name":"IsLUB.exists_between'","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : LinearOrder α\ns : Set α\na b : α\nh : IsLUB s a\nh' : Not (Membership.mem s a)\nhb : LT.lt b a\n⊢ Exists fun c => And (Membership.mem s c) (And (LT.lt b c) (LT.lt c a))","decl":"theorem IsLUB.exists_between' (h : IsLUB s a) (h' : a ∉ s) (hb : b < a) : ∃ c ∈ s, b < c ∧ c < a :=\n  let ⟨c, hcs, hbc, hca⟩ := h.exists_between hb\n  ⟨c, hcs, hbc, hca.lt_of_ne fun hac => h' <| hac ▸ hcs⟩\n\n"}
{"name":"IsGLB.exists_between","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : LinearOrder α\ns : Set α\na b : α\nh : IsGLB s a\nhb : LT.lt a b\n⊢ Exists fun c => And (Membership.mem s c) (And (LE.le a c) (LT.lt c b))","decl":"theorem IsGLB.exists_between (h : IsGLB s a) (hb : a < b) : ∃ c ∈ s, a ≤ c ∧ c < b :=\n  let ⟨c, hcs, hbc⟩ := (isGLB_lt_iff h).1 hb\n  ⟨c, hcs, h.1 hcs, hbc⟩\n\n"}
{"name":"IsGLB.exists_between'","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : LinearOrder α\ns : Set α\na b : α\nh : IsGLB s a\nh' : Not (Membership.mem s a)\nhb : LT.lt a b\n⊢ Exists fun c => And (Membership.mem s c) (And (LT.lt a c) (LT.lt c b))","decl":"theorem IsGLB.exists_between' (h : IsGLB s a) (h' : a ∉ s) (hb : a < b) : ∃ c ∈ s, a < c ∧ c < b :=\n  let ⟨c, hcs, hac, hcb⟩ := h.exists_between hb\n  ⟨c, hcs, hac.lt_of_ne fun hac => h' <| hac.symm ▸ hcs, hcb⟩\n\n"}
{"name":"isGreatest_himp","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : GeneralizedHeytingAlgebra α\na b : α\n⊢ IsGreatest (setOf fun w => LE.le (Min.min w a) b) (HImp.himp a b)","decl":"theorem isGreatest_himp [GeneralizedHeytingAlgebra α] (a b : α) :\n    IsGreatest {w | w ⊓ a ≤ b} (a ⇨ b) := by\n  simp [IsGreatest, mem_upperBounds]\n\n"}
{"name":"isLeast_sdiff","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : GeneralizedCoheytingAlgebra α\na b : α\n⊢ IsLeast (setOf fun w => LE.le a (Max.max b w)) (SDiff.sdiff a b)","decl":"theorem isLeast_sdiff [GeneralizedCoheytingAlgebra α] (a b : α) :\n    IsLeast {w | a ≤ b ⊔ w} (a \\ b) := by\n  simp [IsLeast, mem_lowerBounds]\n\n"}
{"name":"isGreatest_compl","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : HeytingAlgebra α\na : α\n⊢ IsGreatest (setOf fun w => Disjoint w a) (HasCompl.compl a)","decl":"theorem isGreatest_compl [HeytingAlgebra α] (a : α) :\n    IsGreatest {w | Disjoint w a} (aᶜ) := by\n  simpa only [himp_bot, disjoint_iff_inf_le] using isGreatest_himp a ⊥\n\n"}
{"name":"isLeast_hnot","module":"Mathlib.Order.Bounds.Basic","initialProofState":"α : Type u\ninst✝ : CoheytingAlgebra α\na : α\n⊢ IsLeast (setOf fun w => Codisjoint a w) (HNot.hnot a)","decl":"theorem isLeast_hnot [CoheytingAlgebra α] (a : α) :\n    IsLeast {w | Codisjoint a w} (￢a) := by\n  simpa only [CoheytingAlgebra.top_sdiff, codisjoint_iff_le_sup] using isLeast_sdiff ⊤ a\n"}
