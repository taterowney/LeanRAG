{"name":"Subfield.list_prod_mem","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nl : List K\na✝ : ∀ (x : K), Membership.mem l x → Membership.mem s x\n⊢ Membership.mem s l.prod","decl":"/-- Product of a list of elements in a subfield is in the subfield. -/\nprotected theorem list_prod_mem {l : List K} : (∀ x ∈ l, x ∈ s) → l.prod ∈ s :=\n  list_prod_mem\n\n"}
{"name":"Subfield.list_sum_mem","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nl : List K\na✝ : ∀ (x : K), Membership.mem l x → Membership.mem s x\n⊢ Membership.mem s l.sum","decl":"/-- Sum of a list of elements in a subfield is in the subfield. -/\nprotected theorem list_sum_mem {l : List K} : (∀ x ∈ l, x ∈ s) → l.sum ∈ s :=\n  list_sum_mem\n\n"}
{"name":"Subfield.multiset_sum_mem","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nm : Multiset K\na✝ : ∀ (a : K), Membership.mem m a → Membership.mem s a\n⊢ Membership.mem s m.sum","decl":"/-- Sum of a multiset of elements in a `Subfield` is in the `Subfield`. -/\nprotected theorem multiset_sum_mem (m : Multiset K) : (∀ a ∈ m, a ∈ s) → m.sum ∈ s :=\n  multiset_sum_mem m\n\n"}
{"name":"Subfield.sum_mem","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nι : Type u_1\nt : Finset ι\nf : ι → K\nh : ∀ (c : ι), Membership.mem t c → Membership.mem s (f c)\n⊢ Membership.mem s (t.sum fun i => f i)","decl":"/-- Sum of elements in a `Subfield` indexed by a `Finset` is in the `Subfield`. -/\nprotected theorem sum_mem {ι : Type*} {t : Finset ι} {f : ι → K} (h : ∀ c ∈ t, f c ∈ s) :\n    (∑ i ∈ t, f i) ∈ s :=\n  sum_mem h\n\n"}
{"name":"Subfield.mem_top","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nx : K\n⊢ Membership.mem Top.top x","decl":"@[simp]\ntheorem mem_top (x : K) : x ∈ (⊤ : Subfield K) :=\n  Set.mem_univ x\n\n"}
{"name":"Subfield.coe_top","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\n⊢ Eq (↑Top.top) Set.univ","decl":"@[simp]\ntheorem coe_top : ((⊤ : Subfield K) : Set K) = Set.univ :=\n  rfl\n\n"}
{"name":"Subfield.coe_comap","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\nf : RingHom K L\ns : Subfield L\n⊢ Eq (↑(Subfield.comap f s)) (Set.preimage ⇑f ↑s)","decl":"@[simp]\ntheorem coe_comap (s : Subfield L) : (s.comap f : Set K) = f ⁻¹' s :=\n  rfl\n\n"}
{"name":"Subfield.mem_comap","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\ns : Subfield L\nf : RingHom K L\nx : K\n⊢ Iff (Membership.mem (Subfield.comap f s) x) (Membership.mem s (f x))","decl":"@[simp]\ntheorem mem_comap {s : Subfield L} {f : K →+* L} {x : K} : x ∈ s.comap f ↔ f x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Subfield.comap_comap","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\nM : Type w\ninst✝² : DivisionRing K\ninst✝¹ : DivisionRing L\ninst✝ : DivisionRing M\ns : Subfield M\ng : RingHom L M\nf : RingHom K L\n⊢ Eq (Subfield.comap f (Subfield.comap g s)) (Subfield.comap (g.comp f) s)","decl":"theorem comap_comap (s : Subfield M) (g : L →+* M) (f : K →+* L) :\n    (s.comap g).comap f = s.comap (g.comp f) :=\n  rfl\n\n"}
{"name":"Subfield.coe_map","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\ns : Subfield K\nf : RingHom K L\n⊢ Eq (↑(Subfield.map f s)) (Set.image ⇑f ↑s)","decl":"@[simp]\ntheorem coe_map : (s.map f : Set L) = f '' s :=\n  rfl\n\n"}
{"name":"Subfield.mem_map","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\nf : RingHom K L\ns : Subfield K\ny : L\n⊢ Iff (Membership.mem (Subfield.map f s) y) (Exists fun x => And (Membership.mem s x) (Eq (f x) y))","decl":"@[simp]\ntheorem mem_map {f : K →+* L} {s : Subfield K} {y : L} : y ∈ s.map f ↔ ∃ x ∈ s, f x = y := by\n  unfold map\n  simp only [mem_mk, Subring.mem_mk, Subring.mem_toSubsemiring, Subring.mem_map, mem_toSubring]\n\n"}
{"name":"Subfield.map_map","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\nM : Type w\ninst✝² : DivisionRing K\ninst✝¹ : DivisionRing L\ninst✝ : DivisionRing M\ns : Subfield K\ng : RingHom L M\nf : RingHom K L\n⊢ Eq (Subfield.map g (Subfield.map f s)) (Subfield.map (g.comp f) s)","decl":"theorem map_map (g : L →+* M) (f : K →+* L) : (s.map f).map g = s.map (g.comp f) :=\n  SetLike.ext' <| Set.image_image _ _ _\n\n"}
{"name":"Subfield.map_le_iff_le_comap","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\nf : RingHom K L\ns : Subfield K\nt : Subfield L\n⊢ Iff (LE.le (Subfield.map f s) t) (LE.le s (Subfield.comap f t))","decl":"theorem map_le_iff_le_comap {f : K →+* L} {s : Subfield K} {t : Subfield L} :\n    s.map f ≤ t ↔ s ≤ t.comap f :=\n  Set.image_subset_iff\n\n"}
{"name":"Subfield.gc_map_comap","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\nf : RingHom K L\n⊢ GaloisConnection (Subfield.map f) (Subfield.comap f)","decl":"theorem gc_map_comap (f : K →+* L) : GaloisConnection (map f) (comap f) := fun _ _ =>\n  map_le_iff_le_comap\n\n"}
{"name":"RingHom.coe_fieldRange","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\nf : RingHom K L\n⊢ Eq (↑f.fieldRange) (Set.range ⇑f)","decl":"@[simp]\ntheorem coe_fieldRange : (f.fieldRange : Set L) = Set.range f :=\n  rfl\n\n"}
{"name":"RingHom.mem_fieldRange","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\nf : RingHom K L\ny : L\n⊢ Iff (Membership.mem f.fieldRange y) (Exists fun x => Eq (f x) y)","decl":"@[simp]\ntheorem mem_fieldRange {f : K →+* L} {y : L} : y ∈ f.fieldRange ↔ ∃ x, f x = y :=\n  Iff.rfl\n\n"}
{"name":"RingHom.fieldRange_eq_map","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\nf : RingHom K L\n⊢ Eq f.fieldRange (Subfield.map f Top.top)","decl":"theorem fieldRange_eq_map : f.fieldRange = Subfield.map f ⊤ := by\n  ext\n  simp\n\n"}
{"name":"RingHom.map_fieldRange","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\nM : Type w\ninst✝² : DivisionRing K\ninst✝¹ : DivisionRing L\ninst✝ : DivisionRing M\ng : RingHom L M\nf : RingHom K L\n⊢ Eq (Subfield.map g f.fieldRange) (g.comp f).fieldRange","decl":"theorem map_fieldRange : f.fieldRange.map g = (g.comp f).fieldRange := by\n  simpa only [fieldRange_eq_map] using (⊤ : Subfield K).map_map g f\n\n"}
{"name":"RingHom.mem_fieldRange_self","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\nf : RingHom K L\nx : K\n⊢ Membership.mem f.fieldRange (f x)","decl":"theorem mem_fieldRange_self (x : K) : f x ∈ f.fieldRange :=\n  exists_apply_eq_apply _ _\n\n"}
{"name":"RingHom.fieldRange_eq_top_iff","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\nf : RingHom K L\n⊢ Iff (Eq f.fieldRange Top.top) (Function.Surjective ⇑f)","decl":"theorem fieldRange_eq_top_iff {f : K →+* L} :\n    f.fieldRange = ⊤ ↔ Function.Surjective f :=\n  SetLike.ext'_iff.trans Set.range_eq_univ\n\n"}
{"name":"Subfield.coe_inf","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\np p' : Subfield K\n⊢ Eq (↑(Min.min p p')) (Inter.inter p.carrier p'.carrier)","decl":"@[simp]\ntheorem coe_inf (p p' : Subfield K) : ((p ⊓ p' : Subfield K) : Set K) = p.carrier ∩ p'.carrier :=\n  rfl\n\n"}
{"name":"Subfield.mem_inf","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\np p' : Subfield K\nx : K\n⊢ Iff (Membership.mem (Min.min p p') x) (And (Membership.mem p x) (Membership.mem p' x))","decl":"@[simp]\ntheorem mem_inf {p p' : Subfield K} {x : K} : x ∈ p ⊓ p' ↔ x ∈ p ∧ x ∈ p' :=\n  Iff.rfl\n\n"}
{"name":"Subfield.coe_sInf","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nS : Set (Subfield K)\n⊢ Eq (↑(InfSet.sInf S)) (Set.iInter fun s => Set.iInter fun h => ↑s)","decl":"@[simp, norm_cast]\ntheorem coe_sInf (S : Set (Subfield K)) : ((sInf S : Subfield K) : Set K) = ⋂ s ∈ S, ↑s :=\n  show ((sInf (Subfield.toSubring '' S) : Subring K) : Set K) = ⋂ s ∈ S, ↑s by\n    ext x\n    rw [Subring.coe_sInf, Set.mem_iInter, Set.mem_iInter]\n    exact\n      ⟨fun h s s' ⟨s_mem, s'_eq⟩ => h s.toSubring _ ⟨⟨s, s_mem, rfl⟩, s'_eq⟩,\n        fun h s s' ⟨⟨s'', s''_mem, s_eq⟩, (s'_eq : ↑s = s')⟩ =>\n        h s'' _ ⟨s''_mem, by simp [← s_eq, ← s'_eq]⟩⟩\n\n"}
{"name":"Subfield.mem_sInf","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nS : Set (Subfield K)\nx : K\n⊢ Iff (Membership.mem (InfSet.sInf S) x) (∀ (p : Subfield K), Membership.mem S p → Membership.mem p x)","decl":"theorem mem_sInf {S : Set (Subfield K)} {x : K} : x ∈ sInf S ↔ ∀ p ∈ S, x ∈ p :=\n  Subring.mem_sInf.trans\n    ⟨fun h p hp => h p.toSubring ⟨p, hp, rfl⟩, fun h _ ⟨p', hp', p_eq⟩ => p_eq ▸ h p' hp'⟩\n\n"}
{"name":"Subfield.coe_iInf","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nι : Sort u_1\nS : ι → Subfield K\n⊢ Eq (↑(iInf fun i => S i)) (Set.iInter fun i => ↑(S i))","decl":"@[simp, norm_cast]\ntheorem coe_iInf {ι : Sort*} {S : ι → Subfield K} : (↑(⨅ i, S i) : Set K) = ⋂ i, S i := by\n  simp only [iInf, coe_sInf, Set.biInter_range]\n\n"}
{"name":"Subfield.mem_iInf","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nι : Sort u_1\nS : ι → Subfield K\nx : K\n⊢ Iff (Membership.mem (iInf fun i => S i) x) (∀ (i : ι), Membership.mem (S i) x)","decl":"theorem mem_iInf {ι : Sort*} {S : ι → Subfield K} {x : K} : (x ∈ ⨅ i, S i) ↔ ∀ i, x ∈ S i := by\n  simp only [iInf, mem_sInf, Set.forall_mem_range]\n\n"}
{"name":"Subfield.sInf_toSubring","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Set (Subfield K)\n⊢ Eq (InfSet.sInf s).toSubring (iInf fun t => iInf fun h => t.toSubring)","decl":"@[simp]\ntheorem sInf_toSubring (s : Set (Subfield K)) :\n    (sInf s).toSubring = ⨅ t ∈ s, Subfield.toSubring t := by\n  ext x\n  rw [mem_toSubring, mem_sInf]\n  erw [Subring.mem_sInf]\n  exact\n    ⟨fun h p ⟨p', hp⟩ => hp ▸ Subring.mem_sInf.mpr fun p ⟨hp', hp⟩ => hp ▸ h _ hp', fun h p hp =>\n      h p.toSubring\n        ⟨p,\n          Subring.ext fun x =>\n            ⟨fun hx => Subring.mem_sInf.mp hx _ ⟨hp, rfl⟩, fun hx =>\n              Subring.mem_sInf.mpr fun p' ⟨_, p'_eq⟩ => p'_eq ▸ hx⟩⟩⟩\n\n"}
{"name":"Subfield.isGLB_sInf","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nS : Set (Subfield K)\n⊢ IsGLB S (InfSet.sInf S)","decl":"theorem isGLB_sInf (S : Set (Subfield K)) : IsGLB S (sInf S) := by\n  have : ∀ {s t : Subfield K}, (s : Set K) ≤ t ↔ s ≤ t := by simp [SetLike.coe_subset_coe]\n  refine IsGLB.of_image this ?_\n  convert isGLB_biInf (s := S) (f := SetLike.coe)\n  exact coe_sInf _\n\n"}
{"name":"Subfield.mem_closure","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nx : K\ns : Set K\n⊢ Iff (Membership.mem (Subfield.closure s) x) (∀ (S : Subfield K), HasSubset.Subset s ↑S → Membership.mem S x)","decl":"theorem mem_closure {x : K} {s : Set K} : x ∈ closure s ↔ ∀ S : Subfield K, s ⊆ S → x ∈ S :=\n  mem_sInf\n\n"}
{"name":"Subfield.subset_closure","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Set K\n⊢ HasSubset.Subset s ↑(Subfield.closure s)","decl":"/-- The subfield generated by a set includes the set. -/\n@[simp, aesop safe 20 apply (rule_sets := [SetLike])]\ntheorem subset_closure {s : Set K} : s ⊆ closure s := fun _ hx => mem_closure.2 fun _ hS => hS hx\n\n"}
{"name":"Subfield.subring_closure_le","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Set K\n⊢ LE.le (Subring.closure s) (Subfield.closure s).toSubring","decl":"theorem subring_closure_le (s : Set K) : Subring.closure s ≤ (closure s).toSubring :=\n  Subring.closure_le.mpr subset_closure\n\n"}
{"name":"Subfield.not_mem_of_not_mem_closure","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Set K\nP : K\nhP : Not (Membership.mem (Subfield.closure s) P)\n⊢ Not (Membership.mem s P)","decl":"theorem not_mem_of_not_mem_closure {s : Set K} {P : K} (hP : P ∉ closure s) : P ∉ s := fun h =>\n  hP (subset_closure h)\n\n"}
{"name":"Subfield.closure_le","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Set K\nt : Subfield K\n⊢ Iff (LE.le (Subfield.closure s) t) (HasSubset.Subset s ↑t)","decl":"/-- A subfield `t` includes `closure s` if and only if it includes `s`. -/\n@[simp]\ntheorem closure_le {s : Set K} {t : Subfield K} : closure s ≤ t ↔ s ⊆ t :=\n  ⟨Set.Subset.trans subset_closure, fun h _ hx => mem_closure.mp hx t h⟩\n\n"}
{"name":"Subfield.closure_mono","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns t : Set K\nh : HasSubset.Subset s t\n⊢ LE.le (Subfield.closure s) (Subfield.closure t)","decl":"/-- Subfield closure of a set is monotone in its argument: if `s ⊆ t`,\nthen `closure s ≤ closure t`. -/\n@[gcongr]\ntheorem closure_mono ⦃s t : Set K⦄ (h : s ⊆ t) : closure s ≤ closure t :=\n  closure_le.2 <| Set.Subset.trans h subset_closure\n\n"}
{"name":"Subfield.closure_eq_of_le","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Set K\nt : Subfield K\nh₁ : HasSubset.Subset s ↑t\nh₂ : LE.le t (Subfield.closure s)\n⊢ Eq (Subfield.closure s) t","decl":"theorem closure_eq_of_le {s : Set K} {t : Subfield K} (h₁ : s ⊆ t) (h₂ : t ≤ closure s) :\n    closure s = t :=\n  le_antisymm (closure_le.2 h₁) h₂\n\n"}
{"name":"Subfield.closure_induction","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Set K\np : (x : K) → Membership.mem (Subfield.closure s) x → Prop\nmem : ∀ (x : K) (hx : Membership.mem s x), p x ⋯\none : p 1 ⋯\nadd : ∀ (x y : K) (hx : Membership.mem (Subfield.closure s) x) (hy : Membership.mem (Subfield.closure s) y), p x hx → p y hy → p (HAdd.hAdd x y) ⋯\nneg : ∀ (x : K) (hx : Membership.mem (Subfield.closure s) x), p x hx → p (Neg.neg x) ⋯\ninv : ∀ (x : K) (hx : Membership.mem (Subfield.closure s) x), p x hx → p (Inv.inv x) ⋯\nmul : ∀ (x y : K) (hx : Membership.mem (Subfield.closure s) x) (hy : Membership.mem (Subfield.closure s) y), p x hx → p y hy → p (HMul.hMul x y) ⋯\nx : K\nh : Membership.mem (Subfield.closure s) x\n⊢ p x h","decl":"/-- An induction principle for closure membership. If `p` holds for `1`, and all elements\nof `s`, and is preserved under addition, negation, and multiplication, then `p` holds for all\nelements of the closure of `s`. -/\n@[elab_as_elim]\ntheorem closure_induction {s : Set K} {p : ∀ x ∈ closure s, Prop}\n    (mem : ∀ x hx, p x (subset_closure hx))\n    (one : p 1 (one_mem _)) (add : ∀ x y hx hy, p x hx → p y hy → p (x + y) (add_mem hx hy))\n    (neg : ∀ x hx, p x hx → p (-x) (neg_mem hx)) (inv : ∀ x hx, p x hx → p x⁻¹ (inv_mem hx))\n    (mul : ∀ x y hx hy, p x hx → p y hy → p (x * y) (mul_mem hx hy))\n    {x} (h : x ∈ closure s) : p x h :=\n  letI : Subfield K :=\n    { carrier := {x | ∃ hx, p x hx}\n      mul_mem' := by rintro _ _ ⟨_, hx⟩ ⟨_, hy⟩; exact ⟨_, mul _ _ _ _ hx hy⟩\n      one_mem' := ⟨_, one⟩\n      add_mem' := by rintro _ _ ⟨_, hx⟩ ⟨_, hy⟩; exact ⟨_, add _ _ _ _ hx hy⟩\n      zero_mem' := ⟨zero_mem _, by\n        simp_rw [← @add_neg_cancel K _ 1]; exact add _ _ _ _ one (neg _ _ one)⟩\n      neg_mem' := by rintro _ ⟨_, hx⟩; exact ⟨_, neg _ _ hx⟩\n      inv_mem' := by rintro _ ⟨_, hx⟩; exact ⟨_, inv _ _ hx⟩ }\n  ((closure_le (t := this)).2 (fun x hx ↦ ⟨_, mem x hx⟩) h).2\n\n"}
{"name":"Subfield.closure_eq","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\n⊢ Eq (Subfield.closure ↑s) s","decl":"/-- Closure of a subfield `S` equals `S`. -/\n@[simp]\ntheorem closure_eq (s : Subfield K) : closure (s : Set K) = s :=\n  (Subfield.gi K).l_u_eq s\n\n"}
{"name":"Subfield.closure_empty","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\n⊢ Eq (Subfield.closure EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem closure_empty : closure (∅ : Set K) = ⊥ :=\n  (Subfield.gi K).gc.l_bot\n\n"}
{"name":"Subfield.closure_univ","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\n⊢ Eq (Subfield.closure Set.univ) Top.top","decl":"@[simp]\ntheorem closure_univ : closure (Set.univ : Set K) = ⊤ :=\n  @coe_top K _ ▸ closure_eq ⊤\n\n"}
{"name":"Subfield.closure_union","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns t : Set K\n⊢ Eq (Subfield.closure (Union.union s t)) (Max.max (Subfield.closure s) (Subfield.closure t))","decl":"theorem closure_union (s t : Set K) : closure (s ∪ t) = closure s ⊔ closure t :=\n  (Subfield.gi K).gc.l_sup\n\n"}
{"name":"Subfield.closure_iUnion","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nι : Sort u_1\ns : ι → Set K\n⊢ Eq (Subfield.closure (Set.iUnion fun i => s i)) (iSup fun i => Subfield.closure (s i))","decl":"theorem closure_iUnion {ι} (s : ι → Set K) : closure (⋃ i, s i) = ⨆ i, closure (s i) :=\n  (Subfield.gi K).gc.l_iSup\n\n"}
{"name":"Subfield.closure_sUnion","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Set (Set K)\n⊢ Eq (Subfield.closure s.sUnion) (iSup fun t => iSup fun h => Subfield.closure t)","decl":"theorem closure_sUnion (s : Set (Set K)) : closure (⋃₀ s) = ⨆ t ∈ s, closure t :=\n  (Subfield.gi K).gc.l_sSup\n\n"}
{"name":"Subfield.map_sup","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\ns t : Subfield K\nf : RingHom K L\n⊢ Eq (Subfield.map f (Max.max s t)) (Max.max (Subfield.map f s) (Subfield.map f t))","decl":"theorem map_sup (s t : Subfield K) (f : K →+* L) : (s ⊔ t).map f = s.map f ⊔ t.map f :=\n  (gc_map_comap f).l_sup\n\n"}
{"name":"Subfield.map_iSup","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\nι : Sort u_1\nf : RingHom K L\ns : ι → Subfield K\n⊢ Eq (Subfield.map f (iSup s)) (iSup fun i => Subfield.map f (s i))","decl":"theorem map_iSup {ι : Sort*} (f : K →+* L) (s : ι → Subfield K) :\n    (iSup s).map f = ⨆ i, (s i).map f :=\n  (gc_map_comap f).l_iSup\n\n"}
{"name":"Subfield.map_inf","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\ns t : Subfield K\nf : RingHom K L\n⊢ Eq (Subfield.map f (Min.min s t)) (Min.min (Subfield.map f s) (Subfield.map f t))","decl":"theorem map_inf (s t : Subfield K) (f : K →+* L) : (s ⊓ t).map f = s.map f ⊓ t.map f :=\n  SetLike.coe_injective (Set.image_inter f.injective)\n\n"}
{"name":"Subfield.map_iInf","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝² : DivisionRing K\ninst✝¹ : DivisionRing L\nι : Sort u_1\ninst✝ : Nonempty ι\nf : RingHom K L\ns : ι → Subfield K\n⊢ Eq (Subfield.map f (iInf s)) (iInf fun i => Subfield.map f (s i))","decl":"theorem map_iInf {ι : Sort*} [Nonempty ι] (f : K →+* L) (s : ι → Subfield K) :\n    (iInf s).map f = ⨅ i, (s i).map f := by\n  apply SetLike.coe_injective\n  simpa using (Set.injOn_of_injective f.injective).image_iInter_eq (s := SetLike.coe ∘ s)\n\n"}
{"name":"Subfield.comap_inf","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\ns t : Subfield L\nf : RingHom K L\n⊢ Eq (Subfield.comap f (Min.min s t)) (Min.min (Subfield.comap f s) (Subfield.comap f t))","decl":"theorem comap_inf (s t : Subfield L) (f : K →+* L) : (s ⊓ t).comap f = s.comap f ⊓ t.comap f :=\n  (gc_map_comap f).u_inf\n\n"}
{"name":"Subfield.comap_iInf","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\nι : Sort u_1\nf : RingHom K L\ns : ι → Subfield L\n⊢ Eq (Subfield.comap f (iInf s)) (iInf fun i => Subfield.comap f (s i))","decl":"theorem comap_iInf {ι : Sort*} (f : K →+* L) (s : ι → Subfield L) :\n    (iInf s).comap f = ⨅ i, (s i).comap f :=\n  (gc_map_comap f).u_iInf\n\n"}
{"name":"Subfield.map_bot","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\nf : RingHom K L\n⊢ Eq (Subfield.map f Bot.bot) Bot.bot","decl":"@[simp]\ntheorem map_bot (f : K →+* L) : (⊥ : Subfield K).map f = ⊥ :=\n  (gc_map_comap f).l_bot\n\n"}
{"name":"Subfield.comap_top","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\nf : RingHom K L\n⊢ Eq (Subfield.comap f Top.top) Top.top","decl":"@[simp]\ntheorem comap_top (f : K →+* L) : (⊤ : Subfield L).comap f = ⊤ :=\n  (gc_map_comap f).u_top\n\n"}
{"name":"Subfield.mem_iSup_of_directed","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nι : Sort u_1\nhι : Nonempty ι\nS : ι → Subfield K\nhS : Directed (fun x1 x2 => LE.le x1 x2) S\nx : K\n⊢ Iff (Membership.mem (iSup fun i => S i) x) (Exists fun i => Membership.mem (S i) x)","decl":"/-- The underlying set of a non-empty directed sSup of subfields is just a union of the subfields.\n  Note that this fails without the directedness assumption (the union of two subfields is\n  typically not a subfield) -/\ntheorem mem_iSup_of_directed {ι} [hι : Nonempty ι] {S : ι → Subfield K} (hS : Directed (· ≤ ·) S)\n    {x : K} : (x ∈ ⨆ i, S i) ↔ ∃ i, x ∈ S i := by\n  let s : Subfield K :=\n    { __ := Subring.copy _ _ (Subring.coe_iSup_of_directed hS).symm\n      inv_mem' := fun _ hx ↦ have ⟨i, hi⟩ := Set.mem_iUnion.mp hx\n        Set.mem_iUnion.mpr ⟨i, (S i).inv_mem hi⟩ }\n  have : iSup S = s := le_antisymm\n    (iSup_le fun i ↦ le_iSup (fun i ↦ (S i : Set K)) i) (Set.iUnion_subset fun _ ↦ le_iSup S _)\n  exact this ▸ Set.mem_iUnion\n\n"}
{"name":"Subfield.coe_iSup_of_directed","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nι : Sort u_1\nhι : Nonempty ι\nS : ι → Subfield K\nhS : Directed (fun x1 x2 => LE.le x1 x2) S\n⊢ Eq (↑(iSup fun i => S i)) (Set.iUnion fun i => ↑(S i))","decl":"theorem coe_iSup_of_directed {ι} [hι : Nonempty ι] {S : ι → Subfield K} (hS : Directed (· ≤ ·) S) :\n    ((⨆ i, S i : Subfield K) : Set K) = ⋃ i, ↑(S i) :=\n  Set.ext fun x => by simp [mem_iSup_of_directed hS]\n\n"}
{"name":"Subfield.mem_sSup_of_directedOn","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nS : Set (Subfield K)\nSne : S.Nonempty\nhS : DirectedOn (fun x1 x2 => LE.le x1 x2) S\nx : K\n⊢ Iff (Membership.mem (SupSet.sSup S) x) (Exists fun s => And (Membership.mem S s) (Membership.mem s x))","decl":"theorem mem_sSup_of_directedOn {S : Set (Subfield K)} (Sne : S.Nonempty) (hS : DirectedOn (· ≤ ·) S)\n    {x : K} : x ∈ sSup S ↔ ∃ s ∈ S, x ∈ s := by\n  haveI : Nonempty S := Sne.to_subtype\n  simp only [sSup_eq_iSup', mem_iSup_of_directed hS.directed_val, Subtype.exists, exists_prop]\n\n"}
{"name":"Subfield.coe_sSup_of_directedOn","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nS : Set (Subfield K)\nSne : S.Nonempty\nhS : DirectedOn (fun x1 x2 => LE.le x1 x2) S\n⊢ Eq (↑(SupSet.sSup S)) (Set.iUnion fun s => Set.iUnion fun h => ↑s)","decl":"theorem coe_sSup_of_directedOn {S : Set (Subfield K)} (Sne : S.Nonempty)\n    (hS : DirectedOn (· ≤ ·) S) : (↑(sSup S) : Set K) = ⋃ s ∈ S, ↑s :=\n  Set.ext fun x => by simp [mem_sSup_of_directedOn Sne hS]\n\n"}
{"name":"RingHom.coe_rangeRestrictField","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\nf : RingHom K L\nx : K\n⊢ Eq (↑(f.rangeRestrictField x)) (f x)","decl":"@[simp]\ntheorem coe_rangeRestrictField (f : K →+* L) (x : K) : (f.rangeRestrictField x : L) = f x :=\n  rfl\n\n"}
{"name":"RingHom.eqOn_field_closure","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝¹ : DivisionRing K\nL : Type v\ninst✝ : Semiring L\nf g : RingHom K L\ns : Set K\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Set.EqOn ⇑f ⇑g ↑(Subfield.closure s)","decl":"/-- If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. -/\ntheorem eqOn_field_closure {f g : K →+* L} {s : Set K} (h : Set.EqOn f g s) :\n    Set.EqOn f g (closure s) :=\n  show closure s ≤ f.eqLocusField g from closure_le.2 h\n\n"}
{"name":"RingHom.eq_of_eqOn_subfield_top","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝¹ : DivisionRing K\nL : Type v\ninst✝ : Semiring L\nf g : RingHom K L\nh : Set.EqOn ⇑f ⇑g ↑Top.top\n⊢ Eq f g","decl":"theorem eq_of_eqOn_subfield_top {f g : K →+* L} (h : Set.EqOn f g (⊤ : Subfield K)) : f = g :=\n  ext fun _ => h trivial\n\n"}
{"name":"RingHom.eq_of_eqOn_of_field_closure_eq_top","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝¹ : DivisionRing K\nL : Type v\ninst✝ : Semiring L\ns : Set K\nhs : Eq (Subfield.closure s) Top.top\nf g : RingHom K L\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Eq f g","decl":"theorem eq_of_eqOn_of_field_closure_eq_top {s : Set K} (hs : closure s = ⊤) {f g : K →+* L}\n    (h : s.EqOn f g) : f = g :=\n  eq_of_eqOn_subfield_top <| hs ▸ eqOn_field_closure h\n\n"}
{"name":"RingHom.field_closure_preimage_le","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\nf : RingHom K L\ns : Set L\n⊢ LE.le (Subfield.closure (Set.preimage (⇑f) s)) (Subfield.comap f (Subfield.closure s))","decl":"theorem field_closure_preimage_le (f : K →+* L) (s : Set L) :\n    closure (f ⁻¹' s) ≤ (closure s).comap f :=\n  closure_le.2 fun _ hx => SetLike.mem_coe.2 <| mem_comap.2 <| subset_closure hx\n\n"}
{"name":"RingHom.map_field_closure","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\nf : RingHom K L\ns : Set K\n⊢ Eq (Subfield.map f (Subfield.closure s)) (Subfield.closure (Set.image (⇑f) s))","decl":"/-- The image under a ring homomorphism of the subfield generated by a set equals\nthe subfield generated by the image of the set. -/\ntheorem map_field_closure (f : K →+* L) (s : Set K) : (closure s).map f = closure (f '' s) :=\n  Set.image_preimage.l_comm_of_u_comm (gc_map_comap f) (Subfield.gi L).gc (Subfield.gi K).gc\n    fun _ ↦ rfl\n\n"}
{"name":"Subfield.fieldRange_subtype","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\n⊢ Eq s.subtype.fieldRange s","decl":"@[simp]\ntheorem fieldRange_subtype (s : Subfield K) : s.subtype.fieldRange = s :=\n  SetLike.ext' <| (coe_rangeS _).trans Subtype.range_coe\n\n"}
{"name":"Subfield.closure_preimage_le","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\nf : RingHom K L\ns : Set L\n⊢ LE.le (Subfield.closure (Set.preimage (⇑f) s)) (Subfield.comap f (Subfield.closure s))","decl":"theorem closure_preimage_le (f : K →+* L) (s : Set L) : closure (f ⁻¹' s) ≤ (closure s).comap f :=\n  closure_le.2 fun _ hx => SetLike.mem_coe.2 <| mem_comap.2 <| subset_closure hx\n\n"}
{"name":"Subfield.multiset_prod_mem","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : Field K\ns : Subfield K\nm : Multiset K\na✝ : ∀ (a : K), Membership.mem m a → Membership.mem s a\n⊢ Membership.mem s m.prod","decl":"/-- Product of a multiset of elements in a subfield is in the subfield. -/\nprotected theorem multiset_prod_mem (m : Multiset K) : (∀ a ∈ m, a ∈ s) → m.prod ∈ s :=\n  multiset_prod_mem m\n\n"}
{"name":"Subfield.prod_mem","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : Field K\ns : Subfield K\nι : Type u_1\nt : Finset ι\nf : ι → K\nh : ∀ (c : ι), Membership.mem t c → Membership.mem s (f c)\n⊢ Membership.mem s (t.prod fun i => f i)","decl":"/-- Product of elements of a subfield indexed by a `Finset` is in the subfield. -/\nprotected theorem prod_mem {ι : Type*} {t : Finset ι} {f : ι → K} (h : ∀ c ∈ t, f c ∈ s) :\n    (∏ i ∈ t, f i) ∈ s :=\n  prod_mem h\n\n"}
{"name":"Subfield.mem_closure_iff","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝ : Field K\ns : Set K\nx : K\n⊢ Iff (Membership.mem (Subfield.closure s) x) (Exists fun y => And (Membership.mem (Subring.closure s) y) (Exists fun z => And (Membership.mem (Subring.closure s) z) (Eq (HDiv.hDiv y z) x)))","decl":"theorem mem_closure_iff {s : Set K} {x} :\n    x ∈ closure s ↔ ∃ y ∈ Subring.closure s, ∃ z ∈ Subring.closure s, y / z = x := by\n  rw [← commClosure_eq_closure]; rfl\n\n"}
{"name":"Subfield.map_comap_eq","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\nf : RingHom K L\ns : Subfield L\n⊢ Eq (Subfield.map f (Subfield.comap f s)) (Min.min s f.fieldRange)","decl":"theorem map_comap_eq (f : K →+* L) (s : Subfield L) : (s.comap f).map f = s ⊓ f.fieldRange :=\n  SetLike.coe_injective Set.image_preimage_eq_inter_range\n\n"}
{"name":"Subfield.map_comap_eq_self","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\nf : RingHom K L\ns : Subfield L\nh : LE.le s f.fieldRange\n⊢ Eq (Subfield.map f (Subfield.comap f s)) s","decl":"theorem map_comap_eq_self\n    {f : K →+* L} {s : Subfield L} (h : s ≤ f.fieldRange) : (s.comap f).map f = s := by\n  simpa only [inf_of_le_left h] using map_comap_eq f s\n\n"}
{"name":"Subfield.map_comap_eq_self_of_surjective","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\nf : RingHom K L\nhf : Function.Surjective ⇑f\ns : Subfield L\n⊢ Eq (Subfield.map f (Subfield.comap f s)) s","decl":"theorem map_comap_eq_self_of_surjective\n    {f : K →+* L} (hf : Function.Surjective f) (s : Subfield L) : (s.comap f).map f = s :=\n  SetLike.coe_injective (Set.image_preimage_eq _ hf)\n\n"}
{"name":"Subfield.comap_map","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\nL : Type v\ninst✝¹ : DivisionRing K\ninst✝ : DivisionRing L\nf : RingHom K L\ns : Subfield K\n⊢ Eq (Subfield.comap f (Subfield.map f s)) s","decl":"theorem comap_map (f : K →+* L) (s : Subfield K) : (s.map f).comap f = s :=\n  SetLike.coe_injective (Set.preimage_image_eq _ f.injective)\n\n"}
{"name":"Subfield.smul_def","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝¹ : DivisionRing K\nX : Type u_1\ninst✝ : SMul K X\nF : Subfield K\ng : Subtype fun x => Membership.mem F x\nm : X\n⊢ Eq (HSMul.hSMul g m) (HSMul.hSMul (↑g) m)","decl":"theorem smul_def [SMul K X] {F : Subfield K} (g : F) (m : X) : g • m = (g : K) • m :=\n  rfl\n\n"}
{"name":"Subfield.smulCommClass_left","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝³ : DivisionRing K\nX : Type u_2\nY : Type u_1\ninst✝² : SMul K Y\ninst✝¹ : SMul X Y\ninst✝ : SMulCommClass K X Y\nF : Subfield K\n⊢ SMulCommClass (Subtype fun x => Membership.mem F x) X Y","decl":"instance smulCommClass_left [SMul K Y] [SMul X Y] [SMulCommClass K X Y] (F : Subfield K) :\n    SMulCommClass F X Y :=\n  inferInstanceAs (SMulCommClass F.toSubsemiring X Y)\n\n"}
{"name":"Subfield.smulCommClass_right","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝³ : DivisionRing K\nX : Type u_1\nY : Type u_2\ninst✝² : SMul X Y\ninst✝¹ : SMul K Y\ninst✝ : SMulCommClass X K Y\nF : Subfield K\n⊢ SMulCommClass X (Subtype fun x => Membership.mem F x) Y","decl":"instance smulCommClass_right [SMul X Y] [SMul K Y] [SMulCommClass X K Y] (F : Subfield K) :\n    SMulCommClass X F Y :=\n  inferInstanceAs (SMulCommClass X F.toSubsemiring Y)\n\n"}
{"name":"Subfield.instIsScalarTowerSubtypeMem","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝⁴ : DivisionRing K\nX : Type u_1\nY : Type u_2\ninst✝³ : SMul X Y\ninst✝² : SMul K X\ninst✝¹ : SMul K Y\ninst✝ : IsScalarTower K X Y\nF : Subfield K\n⊢ IsScalarTower (Subtype fun x => Membership.mem F x) X Y","decl":"/-- Note that this provides `IsScalarTower F K K` which is needed by `smul_mul_assoc`. -/\ninstance [SMul X Y] [SMul K X] [SMul K Y] [IsScalarTower K X Y] (F : Subfield K) :\n    IsScalarTower F X Y :=\n  inferInstanceAs (IsScalarTower F.toSubsemiring X Y)\n\n"}
{"name":"Subfield.instFaithfulSMulSubtypeMem","module":"Mathlib.Algebra.Field.Subfield.Basic","initialProofState":"K : Type u\ninst✝² : DivisionRing K\nX : Type u_1\ninst✝¹ : SMul K X\ninst✝ : FaithfulSMul K X\nF : Subfield K\n⊢ FaithfulSMul (Subtype fun x => Membership.mem F x) X","decl":"instance [SMul K X] [FaithfulSMul K X] (F : Subfield K) : FaithfulSMul F X :=\n  inferInstanceAs (FaithfulSMul F.toSubsemiring X)\n\n"}
