{"name":"PiLp.inner_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nι : Type u_7\ninst✝² : Fintype ι\nf : ι → Type u_8\ninst✝¹ : (i : ι) → NormedAddCommGroup (f i)\ninst✝ : (i : ι) → InnerProductSpace 𝕜 (f i)\nx y : PiLp 2 f\n⊢ Eq (Inner.inner x y) (Finset.univ.sum fun i => Inner.inner (x i) (y i))","decl":"@[simp]\ntheorem PiLp.inner_apply {ι : Type*} [Fintype ι] {f : ι → Type*} [∀ i, NormedAddCommGroup (f i)]\n    [∀ i, InnerProductSpace 𝕜 (f i)] (x y : PiLp 2 f) : ⟪x, y⟫ = ∑ i, ⟪x i, y i⟫ :=\n  rfl\n\n"}
{"name":"EuclideanSpace.nnnorm_eq","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"𝕜 : Type u_7\ninst✝¹ : RCLike 𝕜\nn : Type u_8\ninst✝ : Fintype n\nx : EuclideanSpace 𝕜 n\n⊢ Eq (NNNorm.nnnorm x) (NNReal.sqrt (Finset.univ.sum fun i => HPow.hPow (NNNorm.nnnorm (x i)) 2))","decl":"theorem EuclideanSpace.nnnorm_eq {𝕜 : Type*} [RCLike 𝕜] {n : Type*} [Fintype n]\n    (x : EuclideanSpace 𝕜 n) : ‖x‖₊ = NNReal.sqrt (∑ i, ‖x i‖₊ ^ 2) :=\n  PiLp.nnnorm_eq_of_L2 x\n\n"}
{"name":"EuclideanSpace.norm_eq","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"𝕜 : Type u_7\ninst✝¹ : RCLike 𝕜\nn : Type u_8\ninst✝ : Fintype n\nx : EuclideanSpace 𝕜 n\n⊢ Eq (Norm.norm x) (Finset.univ.sum fun i => HPow.hPow (Norm.norm (x i)) 2).sqrt","decl":"theorem EuclideanSpace.norm_eq {𝕜 : Type*} [RCLike 𝕜] {n : Type*} [Fintype n]\n    (x : EuclideanSpace 𝕜 n) : ‖x‖ = √(∑ i, ‖x i‖ ^ 2) := by\n  simpa only [Real.coe_sqrt, NNReal.coe_sum] using congr_arg ((↑) : ℝ≥0 → ℝ) x.nnnorm_eq\n\n"}
{"name":"EuclideanSpace.dist_eq","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"𝕜 : Type u_7\ninst✝¹ : RCLike 𝕜\nn : Type u_8\ninst✝ : Fintype n\nx y : EuclideanSpace 𝕜 n\n⊢ Eq (Dist.dist x y) (Finset.univ.sum fun i => HPow.hPow (Dist.dist (x i) (y i)) 2).sqrt","decl":"theorem EuclideanSpace.dist_eq {𝕜 : Type*} [RCLike 𝕜] {n : Type*} [Fintype n]\n    (x y : EuclideanSpace 𝕜 n) : dist x y = √(∑ i, dist (x i) (y i) ^ 2) :=\n  PiLp.dist_eq_of_L2 x y\n\n"}
{"name":"EuclideanSpace.nndist_eq","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"𝕜 : Type u_7\ninst✝¹ : RCLike 𝕜\nn : Type u_8\ninst✝ : Fintype n\nx y : EuclideanSpace 𝕜 n\n⊢ Eq (NNDist.nndist x y) (NNReal.sqrt (Finset.univ.sum fun i => HPow.hPow (NNDist.nndist (x i) (y i)) 2))","decl":"theorem EuclideanSpace.nndist_eq {𝕜 : Type*} [RCLike 𝕜] {n : Type*} [Fintype n]\n    (x y : EuclideanSpace 𝕜 n) : nndist x y = NNReal.sqrt (∑ i, nndist (x i) (y i) ^ 2) :=\n  PiLp.nndist_eq_of_L2 x y\n\n"}
{"name":"EuclideanSpace.edist_eq","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"𝕜 : Type u_7\ninst✝¹ : RCLike 𝕜\nn : Type u_8\ninst✝ : Fintype n\nx y : EuclideanSpace 𝕜 n\n⊢ Eq (EDist.edist x y) (HPow.hPow (Finset.univ.sum fun i => HPow.hPow (EDist.edist (x i) (y i)) 2) (1 / 2))","decl":"theorem EuclideanSpace.edist_eq {𝕜 : Type*} [RCLike 𝕜] {n : Type*} [Fintype n]\n    (x y : EuclideanSpace 𝕜 n) : edist x y = (∑ i, edist (x i) (y i) ^ 2) ^ (1 / 2 : ℝ) :=\n  PiLp.edist_eq_of_L2 x y\n\n"}
{"name":"EuclideanSpace.ball_zero_eq","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"n : Type u_7\ninst✝ : Fintype n\nr : Real\nhr : LE.le 0 r\n⊢ Eq (Metric.ball 0 r) (setOf fun x => LT.lt (Finset.univ.sum fun i => HPow.hPow (x i) 2) (HPow.hPow r 2))","decl":"theorem EuclideanSpace.ball_zero_eq {n : Type*} [Fintype n] (r : ℝ) (hr : 0 ≤ r) :\n    Metric.ball (0 : EuclideanSpace ℝ n) r = {x | ∑ i, x i ^ 2 < r ^ 2} := by\n  ext x\n  have : (0 : ℝ) ≤ ∑ i, x i ^ 2 := Finset.sum_nonneg fun _ _ => sq_nonneg _\n  simp_rw [mem_setOf, mem_ball_zero_iff, norm_eq, norm_eq_abs, sq_abs, sqrt_lt this hr]\n\n"}
{"name":"EuclideanSpace.closedBall_zero_eq","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"n : Type u_7\ninst✝ : Fintype n\nr : Real\nhr : LE.le 0 r\n⊢ Eq (Metric.closedBall 0 r) (setOf fun x => LE.le (Finset.univ.sum fun i => HPow.hPow (x i) 2) (HPow.hPow r 2))","decl":"theorem EuclideanSpace.closedBall_zero_eq {n : Type*} [Fintype n] (r : ℝ) (hr : 0 ≤ r) :\n    Metric.closedBall (0 : EuclideanSpace ℝ n) r = {x | ∑ i, x i ^ 2 ≤ r ^ 2} := by\n  ext\n  simp_rw [mem_setOf, mem_closedBall_zero_iff, norm_eq, norm_eq_abs, sq_abs, sqrt_le_left hr]\n\n"}
{"name":"EuclideanSpace.sphere_zero_eq","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"n : Type u_7\ninst✝ : Fintype n\nr : Real\nhr : LE.le 0 r\n⊢ Eq (Metric.sphere 0 r) (setOf fun x => Eq (Finset.univ.sum fun i => HPow.hPow (x i) 2) (HPow.hPow r 2))","decl":"theorem EuclideanSpace.sphere_zero_eq {n : Type*} [Fintype n] (r : ℝ) (hr : 0 ≤ r) :\n    Metric.sphere (0 : EuclideanSpace ℝ n) r = {x | ∑ i, x i ^ 2 = r ^ 2} := by\n  ext x\n  have : (0 : ℝ) ≤ ∑ i, x i ^ 2 := Finset.sum_nonneg fun _ _ => sq_nonneg _\n  simp_rw [mem_setOf, mem_sphere_zero_iff_norm, norm_eq, norm_eq_abs, sq_abs,\n    Real.sqrt_eq_iff_eq_sq this hr]\n\n"}
{"name":"finrank_euclideanSpace","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝¹ : RCLike 𝕜\ninst✝ : Fintype ι\n⊢ Eq (Module.finrank 𝕜 (EuclideanSpace 𝕜 ι)) (Fintype.card ι)","decl":"@[simp]\ntheorem finrank_euclideanSpace :\n    Module.finrank 𝕜 (EuclideanSpace 𝕜 ι) = Fintype.card ι := by\n  simp [EuclideanSpace, PiLp, WithLp]\n\n"}
{"name":"finrank_euclideanSpace_fin","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"𝕜 : Type u_3\ninst✝ : RCLike 𝕜\nn : Nat\n⊢ Eq (Module.finrank 𝕜 (EuclideanSpace 𝕜 (Fin n))) n","decl":"theorem finrank_euclideanSpace_fin {n : ℕ} :\n    Module.finrank 𝕜 (EuclideanSpace 𝕜 (Fin n)) = n := by simp\n\n"}
{"name":"EuclideanSpace.inner_eq_star_dotProduct","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝¹ : RCLike 𝕜\ninst✝ : Fintype ι\nx y : EuclideanSpace 𝕜 ι\n⊢ Eq (Inner.inner x y) (dotProduct (Star.star ((WithLp.equiv 2 (ι → 𝕜)) x)) ((WithLp.equiv 2 (ι → 𝕜)) y))","decl":"theorem EuclideanSpace.inner_eq_star_dotProduct (x y : EuclideanSpace 𝕜 ι) :\n    ⟪x, y⟫ = dotProduct (star <| WithLp.equiv _ _ x) (WithLp.equiv _ _ y) :=\n  rfl\n\n"}
{"name":"EuclideanSpace.inner_piLp_equiv_symm","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝¹ : RCLike 𝕜\ninst✝ : Fintype ι\nx y : ι → 𝕜\n⊢ Eq (Inner.inner ((WithLp.equiv 2 (ι → 𝕜)).symm x) ((WithLp.equiv 2 (ι → 𝕜)).symm y)) (dotProduct (Star.star x) y)","decl":"theorem EuclideanSpace.inner_piLp_equiv_symm (x y : ι → 𝕜) :\n    ⟪(WithLp.equiv 2 _).symm x, (WithLp.equiv 2 _).symm y⟫ = dotProduct (star x) y :=\n  rfl\n\n"}
{"name":"DirectSum.IsInternal.isometryL2OfOrthogonalFamily_symm_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝⁴ : RCLike 𝕜\nE : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nV : ι → Submodule 𝕜 E\nhV : DirectSum.IsInternal V\nhV' : OrthogonalFamily 𝕜 (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeₗᵢ\nw : PiLp 2 fun i => Subtype fun x => Membership.mem (V i) x\n⊢ Eq ((hV.isometryL2OfOrthogonalFamily hV').symm w) (Finset.univ.sum fun i => ↑(w i))","decl":"@[simp]\ntheorem DirectSum.IsInternal.isometryL2OfOrthogonalFamily_symm_apply [DecidableEq ι]\n    {V : ι → Submodule 𝕜 E} (hV : DirectSum.IsInternal V)\n    (hV' : OrthogonalFamily 𝕜 (fun i => V i) fun i => (V i).subtypeₗᵢ) (w : PiLp 2 fun i => V i) :\n    (hV.isometryL2OfOrthogonalFamily hV').symm w = ∑ i, (w i : E) := by\n  classical\n    let e₁ := DirectSum.linearEquivFunOnFintype 𝕜 ι fun i => V i\n    let e₂ := LinearEquiv.ofBijective (DirectSum.coeLinearMap V) hV\n    suffices ∀ v : ⨁ i, V i, e₂ v = ∑ i, e₁ v i by exact this (e₁.symm w)\n    intro v\n    -- Porting note: added `DFinsupp.lsum`\n    simp [e₁, e₂, DirectSum.coeLinearMap, DirectSum.toModule, DFinsupp.lsum,\n      DFinsupp.sumAddHom_apply]\n\n"}
{"name":"WithLp.equiv_single","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝¹ : RCLike 𝕜\ninst✝ : DecidableEq ι\ni : ι\na : 𝕜\n⊢ Eq ((WithLp.equiv 2 ((i : ι) → (fun x => 𝕜) i)) (EuclideanSpace.single i a)) (Pi.single i a)","decl":"@[simp]\ntheorem WithLp.equiv_single (i : ι) (a : 𝕜) :\n    WithLp.equiv _ _ (EuclideanSpace.single i a) = Pi.single i a :=\n  rfl\n\n"}
{"name":"WithLp.equiv_symm_single","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝¹ : RCLike 𝕜\ninst✝ : DecidableEq ι\ni : ι\na : 𝕜\n⊢ Eq ((WithLp.equiv 2 (ι → 𝕜)).symm (Pi.single i a)) (EuclideanSpace.single i a)","decl":"@[simp]\ntheorem WithLp.equiv_symm_single (i : ι) (a : 𝕜) :\n    (WithLp.equiv _ _).symm (Pi.single i a) = EuclideanSpace.single i a :=\n  rfl\n\n"}
{"name":"EuclideanSpace.single_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝¹ : RCLike 𝕜\ninst✝ : DecidableEq ι\ni : ι\na : 𝕜\nj : ι\n⊢ Eq (EuclideanSpace.single i a j) (ite (Eq j i) a 0)","decl":"@[simp]\ntheorem EuclideanSpace.single_apply (i : ι) (a : 𝕜) (j : ι) :\n    (EuclideanSpace.single i a) j = ite (j = i) a 0 := by\n  rw [EuclideanSpace.single, WithLp.equiv_symm_pi_apply, ← Pi.single_apply i a j]\n\n"}
{"name":"EuclideanSpace.inner_single_left","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ni : ι\na : 𝕜\nv : EuclideanSpace 𝕜 ι\n⊢ Eq (Inner.inner (EuclideanSpace.single i a) v) (HMul.hMul ((starRingEnd 𝕜) a) (v i))","decl":"theorem EuclideanSpace.inner_single_left (i : ι) (a : 𝕜) (v : EuclideanSpace 𝕜 ι) :\n    ⟪EuclideanSpace.single i (a : 𝕜), v⟫ = conj a * v i := by simp [apply_ite conj]\n\n"}
{"name":"EuclideanSpace.inner_single_right","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ni : ι\na : 𝕜\nv : EuclideanSpace 𝕜 ι\n⊢ Eq (Inner.inner v (EuclideanSpace.single i a)) (HMul.hMul a ((starRingEnd ((fun x => 𝕜) i)) (v i)))","decl":"theorem EuclideanSpace.inner_single_right (i : ι) (a : 𝕜) (v : EuclideanSpace 𝕜 ι) :\n    ⟪v, EuclideanSpace.single i (a : 𝕜)⟫ = a * conj (v i) := by simp [apply_ite conj, mul_comm]\n\n"}
{"name":"EuclideanSpace.norm_single","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ni : ι\na : 𝕜\n⊢ Eq (Norm.norm (EuclideanSpace.single i a)) (Norm.norm a)","decl":"@[simp]\ntheorem EuclideanSpace.norm_single (i : ι) (a : 𝕜) :\n    ‖EuclideanSpace.single i (a : 𝕜)‖ = ‖a‖ :=\n  PiLp.norm_equiv_symm_single 2 (fun _ => 𝕜) i a\n\n"}
{"name":"EuclideanSpace.nnnorm_single","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ni : ι\na : 𝕜\n⊢ Eq (NNNorm.nnnorm (EuclideanSpace.single i a)) (NNNorm.nnnorm a)","decl":"@[simp]\ntheorem EuclideanSpace.nnnorm_single (i : ι) (a : 𝕜) :\n    ‖EuclideanSpace.single i (a : 𝕜)‖₊ = ‖a‖₊ :=\n  PiLp.nnnorm_equiv_symm_single 2 (fun _ => 𝕜) i a\n\n"}
{"name":"EuclideanSpace.dist_single_same","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ni : ι\na b : 𝕜\n⊢ Eq (Dist.dist (EuclideanSpace.single i a) (EuclideanSpace.single i b)) (Dist.dist a b)","decl":"@[simp]\ntheorem EuclideanSpace.dist_single_same (i : ι) (a b : 𝕜) :\n    dist (EuclideanSpace.single i (a : 𝕜)) (EuclideanSpace.single i (b : 𝕜)) = dist a b :=\n  PiLp.dist_equiv_symm_single_same 2 (fun _ => 𝕜) i a b\n\n"}
{"name":"EuclideanSpace.nndist_single_same","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ni : ι\na b : 𝕜\n⊢ Eq (NNDist.nndist (EuclideanSpace.single i a) (EuclideanSpace.single i b)) (NNDist.nndist a b)","decl":"@[simp]\ntheorem EuclideanSpace.nndist_single_same (i : ι) (a b : 𝕜) :\n    nndist (EuclideanSpace.single i (a : 𝕜)) (EuclideanSpace.single i (b : 𝕜)) = nndist a b :=\n  PiLp.nndist_equiv_symm_single_same 2 (fun _ => 𝕜) i a b\n\n"}
{"name":"EuclideanSpace.edist_single_same","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ni : ι\na b : 𝕜\n⊢ Eq (EDist.edist (EuclideanSpace.single i a) (EuclideanSpace.single i b)) (EDist.edist a b)","decl":"@[simp]\ntheorem EuclideanSpace.edist_single_same (i : ι) (a b : 𝕜) :\n    edist (EuclideanSpace.single i (a : 𝕜)) (EuclideanSpace.single i (b : 𝕜)) = edist a b :=\n  PiLp.edist_equiv_symm_single_same 2 (fun _ => 𝕜) i a b\n\n"}
{"name":"EuclideanSpace.orthonormal_single","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\n⊢ Orthonormal 𝕜 fun i => EuclideanSpace.single i 1","decl":"/-- `EuclideanSpace.single` forms an orthonormal family. -/\ntheorem EuclideanSpace.orthonormal_single :\n    Orthonormal 𝕜 fun i : ι => EuclideanSpace.single i (1 : 𝕜) := by\n  simp_rw [orthonormal_iff_ite, EuclideanSpace.inner_single_left, map_one, one_mul,\n    EuclideanSpace.single_apply]\n  intros\n  trivial\n\n"}
{"name":"EuclideanSpace.piLpCongrLeft_single","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝⁴ : RCLike 𝕜\ninst✝³ : DecidableEq ι\ninst✝² : Fintype ι\nι' : Type u_7\ninst✝¹ : Fintype ι'\ninst✝ : DecidableEq ι'\ne : Equiv ι' ι\ni' : ι'\nv : 𝕜\n⊢ Eq ((LinearIsometryEquiv.piLpCongrLeft 2 𝕜 𝕜 e) (EuclideanSpace.single i' v)) (EuclideanSpace.single (e i') v)","decl":"theorem EuclideanSpace.piLpCongrLeft_single\n    {ι' : Type*} [Fintype ι'] [DecidableEq ι'] (e : ι' ≃ ι) (i' : ι') (v : 𝕜) :\n    LinearIsometryEquiv.piLpCongrLeft 2 𝕜 𝕜 e (EuclideanSpace.single i' v) =\n      EuclideanSpace.single (e i') v :=\n  LinearIsometryEquiv.piLpCongrLeft_single e i' _\n\n"}
{"name":"OrthonormalBasis.ofRepr.inj","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : Fintype ι\nrepr✝ repr : LinearIsometryEquiv (RingHom.id 𝕜) E (EuclideanSpace 𝕜 ι)\nx✝ : Eq { repr := repr✝ } { repr := repr }\n⊢ Eq repr✝ repr","decl":"/-- An orthonormal basis on E is an identification of `E` with its dimensional-matching\n`EuclideanSpace 𝕜 ι`. -/\nstructure OrthonormalBasis where ofRepr ::\n  /-- Linear isometry between `E` and `EuclideanSpace 𝕜 ι` representing the orthonormal basis. -/\n  repr : E ≃ₗᵢ[𝕜] EuclideanSpace 𝕜 ι\n\n"}
{"name":"OrthonormalBasis.ofRepr.injEq","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : Fintype ι\nrepr✝ repr : LinearIsometryEquiv (RingHom.id 𝕜) E (EuclideanSpace 𝕜 ι)\n⊢ Eq (Eq { repr := repr✝ } { repr := repr }) (Eq repr✝ repr)","decl":"/-- An orthonormal basis on E is an identification of `E` with its dimensional-matching\n`EuclideanSpace 𝕜 ι`. -/\nstructure OrthonormalBasis where ofRepr ::\n  /-- Linear isometry between `E` and `EuclideanSpace 𝕜 ι` representing the orthonormal basis. -/\n  repr : E ≃ₗᵢ[𝕜] EuclideanSpace 𝕜 ι\n\n"}
{"name":"OrthonormalBasis.ofRepr.sizeOf_spec","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝⁶ : RCLike 𝕜\nE : Type u_4\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : InnerProductSpace 𝕜 E\ninst✝³ : Fintype ι\ninst✝² : SizeOf ι\ninst✝¹ : SizeOf 𝕜\ninst✝ : SizeOf E\nrepr : LinearIsometryEquiv (RingHom.id 𝕜) E (EuclideanSpace 𝕜 ι)\n⊢ Eq (SizeOf.sizeOf { repr := repr }) (HAdd.hAdd 1 (SizeOf.sizeOf repr))","decl":"/-- An orthonormal basis on E is an identification of `E` with its dimensional-matching\n`EuclideanSpace 𝕜 ι`. -/\nstructure OrthonormalBasis where ofRepr ::\n  /-- Linear isometry between `E` and `EuclideanSpace 𝕜 ι` representing the orthonormal basis. -/\n  repr : E ≃ₗᵢ[𝕜] EuclideanSpace 𝕜 ι\n\n"}
{"name":"OrthonormalBasis.repr_injective","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : Fintype ι\n⊢ Function.Injective OrthonormalBasis.repr","decl":"theorem repr_injective :\n    Injective (repr : OrthonormalBasis ι 𝕜 E → E ≃ₗᵢ[𝕜] EuclideanSpace 𝕜 ι) := fun f g h => by\n  cases f\n  cases g\n  congr\n\n"}
{"name":"OrthonormalBasis.coe_ofRepr","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝⁴ : RCLike 𝕜\nE : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\ne : LinearIsometryEquiv (RingHom.id 𝕜) E (EuclideanSpace 𝕜 ι)\n⊢ Eq ⇑{ repr := e } fun i => e.symm (EuclideanSpace.single i 1)","decl":"@[simp]\ntheorem coe_ofRepr [DecidableEq ι] (e : E ≃ₗᵢ[𝕜] EuclideanSpace 𝕜 ι) :\n    ⇑(OrthonormalBasis.ofRepr e) = fun i => e.symm (EuclideanSpace.single i (1 : 𝕜)) := by\n  -- Porting note: simplified with `congr!`\n  dsimp only [DFunLike.coe]\n  funext\n  congr!\n\n"}
{"name":"OrthonormalBasis.repr_symm_single","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝⁴ : RCLike 𝕜\nE : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nb : OrthonormalBasis ι 𝕜 E\ni : ι\n⊢ Eq (b.repr.symm (EuclideanSpace.single i 1)) (b i)","decl":"@[simp]\nprotected theorem repr_symm_single [DecidableEq ι] (b : OrthonormalBasis ι 𝕜 E) (i : ι) :\n    b.repr.symm (EuclideanSpace.single i (1 : 𝕜)) = b i := by\n  -- Porting note: simplified with `congr!`\n  dsimp only [DFunLike.coe]\n  congr!\n\n"}
{"name":"OrthonormalBasis.repr_self","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝⁴ : RCLike 𝕜\nE : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nb : OrthonormalBasis ι 𝕜 E\ni : ι\n⊢ Eq (b.repr (b i)) (EuclideanSpace.single i 1)","decl":"@[simp]\nprotected theorem repr_self [DecidableEq ι] (b : OrthonormalBasis ι 𝕜 E) (i : ι) :\n    b.repr (b i) = EuclideanSpace.single i (1 : 𝕜) := by\n  rw [← b.repr_symm_single i, LinearIsometryEquiv.apply_symm_apply]\n\n"}
{"name":"OrthonormalBasis.repr_apply_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : Fintype ι\nb : OrthonormalBasis ι 𝕜 E\nv : E\ni : ι\n⊢ Eq (b.repr v i) (Inner.inner (b i) v)","decl":"protected theorem repr_apply_apply (b : OrthonormalBasis ι 𝕜 E) (v : E) (i : ι) :\n    b.repr v i = ⟪b i, v⟫ := by\n  classical\n    rw [← b.repr.inner_map_map (b i) v, b.repr_self i, EuclideanSpace.inner_single_left]\n    simp only [one_mul, eq_self_iff_true, map_one]\n\n"}
{"name":"OrthonormalBasis.orthonormal","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : Fintype ι\nb : OrthonormalBasis ι 𝕜 E\n⊢ Orthonormal 𝕜 ⇑b","decl":"@[simp]\nprotected theorem orthonormal (b : OrthonormalBasis ι 𝕜 E) : Orthonormal 𝕜 b := by\n  classical\n    rw [orthonormal_iff_ite]\n    intro i j\n    rw [← b.repr.inner_map_map (b i) (b j), b.repr_self i, b.repr_self j,\n      EuclideanSpace.inner_single_left, EuclideanSpace.single_apply, map_one, one_mul]\n\n"}
{"name":"OrthonormalBasis.coe_toBasis","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : Fintype ι\nb : OrthonormalBasis ι 𝕜 E\n⊢ Eq ⇑b.toBasis ⇑b","decl":"@[simp]\nprotected theorem coe_toBasis (b : OrthonormalBasis ι 𝕜 E) : (⇑b.toBasis : ι → E) = ⇑b := by\n  rw [OrthonormalBasis.toBasis] -- Porting note: was `change`\n  ext j\n  classical\n    rw [Basis.coe_ofEquivFun]\n    congr\n\n"}
{"name":"OrthonormalBasis.coe_toBasis_repr","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : Fintype ι\nb : OrthonormalBasis ι 𝕜 E\n⊢ Eq b.toBasis.equivFun b.repr.toLinearEquiv","decl":"@[simp]\nprotected theorem coe_toBasis_repr (b : OrthonormalBasis ι 𝕜 E) :\n    b.toBasis.equivFun = b.repr.toLinearEquiv :=\n  Basis.equivFun_ofEquivFun _\n\n"}
{"name":"OrthonormalBasis.coe_toBasis_repr_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : Fintype ι\nb : OrthonormalBasis ι 𝕜 E\nx : E\ni : ι\n⊢ Eq ((b.toBasis.repr x) i) (b.repr x i)","decl":"@[simp]\nprotected theorem coe_toBasis_repr_apply (b : OrthonormalBasis ι 𝕜 E) (x : E) (i : ι) :\n    b.toBasis.repr x i = b.repr x i := by\n  rw [← Basis.equivFun_apply, OrthonormalBasis.coe_toBasis_repr]\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [LinearIsometryEquiv.coe_toLinearEquiv]\n\n"}
{"name":"OrthonormalBasis.sum_repr","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : Fintype ι\nb : OrthonormalBasis ι 𝕜 E\nx : E\n⊢ Eq (Finset.univ.sum fun i => HSMul.hSMul (b.repr x i) (b i)) x","decl":"protected theorem sum_repr (b : OrthonormalBasis ι 𝕜 E) (x : E) : ∑ i, b.repr x i • b i = x := by\n  simp_rw [← b.coe_toBasis_repr_apply, ← b.coe_toBasis]\n  exact b.toBasis.sum_repr x\n\n"}
{"name":"OrthonormalBasis.sum_repr'","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : Fintype ι\nb : OrthonormalBasis ι 𝕜 E\nx : E\n⊢ Eq (Finset.univ.sum fun i => HSMul.hSMul (Inner.inner (b i) x) (b i)) x","decl":"open scoped InnerProductSpace in\nprotected theorem sum_repr' (b : OrthonormalBasis ι 𝕜 E) (x : E) : ∑ i, ⟪b i, x⟫_𝕜 • b i = x := by\n  nth_rw 2 [← (b.sum_repr x)]\n  simp_rw [b.repr_apply_apply x]\n\n"}
{"name":"OrthonormalBasis.sum_repr_symm","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : Fintype ι\nb : OrthonormalBasis ι 𝕜 E\nv : EuclideanSpace 𝕜 ι\n⊢ Eq (Finset.univ.sum fun i => HSMul.hSMul (v i) (b i)) (b.repr.symm v)","decl":"protected theorem sum_repr_symm (b : OrthonormalBasis ι 𝕜 E) (v : EuclideanSpace 𝕜 ι) :\n    ∑ i, v i • b i = b.repr.symm v := by simpa using (b.toBasis.equivFun_symm_apply v).symm\n\n"}
{"name":"OrthonormalBasis.sum_inner_mul_inner","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : Fintype ι\nb : OrthonormalBasis ι 𝕜 E\nx y : E\n⊢ Eq (Finset.univ.sum fun i => HMul.hMul (Inner.inner x (b i)) (Inner.inner (b i) y)) (Inner.inner x y)","decl":"protected theorem sum_inner_mul_inner (b : OrthonormalBasis ι 𝕜 E) (x y : E) :\n    ∑ i, ⟪x, b i⟫ * ⟪b i, y⟫ = ⟪x, y⟫ := by\n  have := congr_arg (innerSL 𝕜 x) (b.sum_repr y)\n  rw [map_sum] at this\n  convert this\n  rw [map_smul, b.repr_apply_apply, mul_comm]\n  simp only [innerSL_apply, smul_eq_mul] -- Porting note: was `rfl`\n\n"}
{"name":"OrthonormalBasis.orthogonalProjection_eq_sum","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝⁴ : RCLike 𝕜\nE : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : Fintype ι\nU : Submodule 𝕜 E\ninst✝ : CompleteSpace (Subtype fun x => Membership.mem U x)\nb : OrthonormalBasis ι 𝕜 (Subtype fun x => Membership.mem U x)\nx : E\n⊢ Eq ((orthogonalProjection U) x) (Finset.univ.sum fun i => HSMul.hSMul (Inner.inner (↑(b i)) x) (b i))","decl":"protected theorem orthogonalProjection_eq_sum {U : Submodule 𝕜 E} [CompleteSpace U]\n    (b : OrthonormalBasis ι 𝕜 U) (x : E) :\n    orthogonalProjection U x = ∑ i, ⟪(b i : E), x⟫ • b i := by\n  simpa only [b.repr_apply_apply, inner_orthogonalProjection_eq_of_mem_left] using\n    (b.sum_repr (orthogonalProjection U x)).symm\n\n"}
{"name":"OrthonormalBasis.map_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝⁵ : RCLike 𝕜\nE : Type u_4\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : Fintype ι\nG : Type u_7\ninst✝¹ : NormedAddCommGroup G\ninst✝ : InnerProductSpace 𝕜 G\nb : OrthonormalBasis ι 𝕜 E\nL : LinearIsometryEquiv (RingHom.id 𝕜) E G\ni : ι\n⊢ Eq ((b.map L) i) (L (b i))","decl":"@[simp]\nprotected theorem map_apply {G : Type*} [NormedAddCommGroup G] [InnerProductSpace 𝕜 G]\n    (b : OrthonormalBasis ι 𝕜 E) (L : E ≃ₗᵢ[𝕜] G) (i : ι) : b.map L i = L (b i) :=\n  rfl\n\n"}
{"name":"OrthonormalBasis.toBasis_map","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝⁵ : RCLike 𝕜\nE : Type u_4\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : Fintype ι\nG : Type u_7\ninst✝¹ : NormedAddCommGroup G\ninst✝ : InnerProductSpace 𝕜 G\nb : OrthonormalBasis ι 𝕜 E\nL : LinearIsometryEquiv (RingHom.id 𝕜) E G\n⊢ Eq (b.map L).toBasis (b.toBasis.map L.toLinearEquiv)","decl":"@[simp]\nprotected theorem toBasis_map {G : Type*} [NormedAddCommGroup G] [InnerProductSpace 𝕜 G]\n    (b : OrthonormalBasis ι 𝕜 E) (L : E ≃ₗᵢ[𝕜] G) :\n    (b.map L).toBasis = b.toBasis.map L.toLinearEquiv :=\n  rfl\n\n"}
{"name":"Basis.coe_toOrthonormalBasis_repr","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : Fintype ι\nv : Basis ι 𝕜 E\nhv : Orthonormal 𝕜 ⇑v\n⊢ Eq ⇑(v.toOrthonormalBasis hv).repr ⇑v.equivFun","decl":"@[simp]\ntheorem _root_.Basis.coe_toOrthonormalBasis_repr (v : Basis ι 𝕜 E) (hv : Orthonormal 𝕜 v) :\n    ((v.toOrthonormalBasis hv).repr : E → EuclideanSpace 𝕜 ι) = v.equivFun :=\n  rfl\n\n"}
{"name":"Basis.coe_toOrthonormalBasis_repr_symm","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : Fintype ι\nv : Basis ι 𝕜 E\nhv : Orthonormal 𝕜 ⇑v\n⊢ Eq ⇑(v.toOrthonormalBasis hv).repr.symm ⇑v.equivFun.symm","decl":"@[simp]\ntheorem _root_.Basis.coe_toOrthonormalBasis_repr_symm (v : Basis ι 𝕜 E) (hv : Orthonormal 𝕜 v) :\n    ((v.toOrthonormalBasis hv).repr.symm : EuclideanSpace 𝕜 ι → E) = v.equivFun.symm :=\n  rfl\n\n"}
{"name":"Basis.toBasis_toOrthonormalBasis","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : Fintype ι\nv : Basis ι 𝕜 E\nhv : Orthonormal 𝕜 ⇑v\n⊢ Eq (v.toOrthonormalBasis hv).toBasis v","decl":"@[simp]\ntheorem _root_.Basis.toBasis_toOrthonormalBasis (v : Basis ι 𝕜 E) (hv : Orthonormal 𝕜 v) :\n    (v.toOrthonormalBasis hv).toBasis = v := by\n  simp [Basis.toOrthonormalBasis, OrthonormalBasis.toBasis]\n\n"}
{"name":"Basis.coe_toOrthonormalBasis","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : Fintype ι\nv : Basis ι 𝕜 E\nhv : Orthonormal 𝕜 ⇑v\n⊢ Eq ⇑(v.toOrthonormalBasis hv) ⇑v","decl":"@[simp]\ntheorem _root_.Basis.coe_toOrthonormalBasis (v : Basis ι 𝕜 E) (hv : Orthonormal 𝕜 v) :\n    (v.toOrthonormalBasis hv : ι → E) = (v : ι → E) :=\n  calc\n    (v.toOrthonormalBasis hv : ι → E) = ((v.toOrthonormalBasis hv).toBasis : ι → E) := by\n      classical rw [OrthonormalBasis.coe_toBasis]\n    _ = (v : ι → E) := by simp\n\n"}
{"name":"Pi.orthonormalBasis.toBasis","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"η : Type u_7\ninst✝⁴ : Fintype η\nι : η → Type u_8\ninst✝³ : (i : η) → Fintype (ι i)\n𝕜 : Type u_9\ninst✝² : RCLike 𝕜\nE : η → Type u_10\ninst✝¹ : (i : η) → NormedAddCommGroup (E i)\ninst✝ : (i : η) → InnerProductSpace 𝕜 (E i)\nB : (i : η) → OrthonormalBasis (ι i) 𝕜 (E i)\n⊢ Eq (Pi.orthonormalBasis B).toBasis ((Pi.basis fun i => (B i).toBasis).map (WithLp.linearEquiv 2 𝕜 ((j : η) → E j)).symm)","decl":"theorem _root_.Pi.orthonormalBasis.toBasis {η : Type*} [Fintype η] {ι : η → Type*}\n    [∀ i, Fintype (ι i)] {𝕜 : Type*} [RCLike 𝕜] {E : η → Type*} [∀ i, NormedAddCommGroup (E i)]\n    [∀ i, InnerProductSpace 𝕜 (E i)] (B : ∀ i, OrthonormalBasis (ι i) 𝕜 (E i)) :\n    (Pi.orthonormalBasis B).toBasis =\n      ((Pi.basis fun i : η ↦ (B i).toBasis).map (WithLp.linearEquiv 2 _ _).symm) := by ext; rfl\n\n"}
{"name":"Pi.orthonormalBasis_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"η : Type u_7\ninst✝⁵ : Fintype η\ninst✝⁴ : DecidableEq η\nι : η → Type u_8\ninst✝³ : (i : η) → Fintype (ι i)\n𝕜 : Type u_9\ninst✝² : RCLike 𝕜\nE : η → Type u_10\ninst✝¹ : (i : η) → NormedAddCommGroup (E i)\ninst✝ : (i : η) → InnerProductSpace 𝕜 (E i)\nB : (i : η) → OrthonormalBasis (ι i) 𝕜 (E i)\nj : Sigma fun i => ι i\n⊢ Eq ((Pi.orthonormalBasis B) j) ((WithLp.equiv 2 ((j : η) → E j)).symm (Pi.single j.fst ((B j.fst) j.snd)))","decl":"@[simp]\ntheorem _root_.Pi.orthonormalBasis_apply {η : Type*} [Fintype η] [DecidableEq η] {ι : η → Type*}\n    [∀ i, Fintype (ι i)] {𝕜 : Type*} [RCLike 𝕜] {E : η → Type*} [∀ i, NormedAddCommGroup (E i)]\n    [∀ i, InnerProductSpace 𝕜 (E i)] (B : ∀ i, OrthonormalBasis (ι i) 𝕜 (E i))\n    (j : (i : η) × (ι i)) :\n    Pi.orthonormalBasis B j = (WithLp.equiv _ _).symm (Pi.single _ (B j.fst j.snd)) := by\n  classical\n  ext k\n  obtain ⟨i, j⟩ := j\n  simp only [Pi.orthonormalBasis, coe_ofRepr, LinearIsometryEquiv.symm_trans,\n    LinearIsometryEquiv.symm_symm, LinearIsometryEquiv.piLpCongrRight_symm,\n    LinearIsometryEquiv.trans_apply, LinearIsometryEquiv.piLpCongrRight_apply,\n    LinearIsometryEquiv.piLpCurry_apply, WithLp.equiv_single, WithLp.equiv_symm_pi_apply,\n    Sigma.curry_single (γ := fun _ _ => 𝕜)]\n  obtain rfl | hi := Decidable.eq_or_ne i k\n  · simp only [Pi.single_eq_same, WithLp.equiv_symm_single, OrthonormalBasis.repr_symm_single]\n  · simp only [Pi.single_eq_of_ne' hi, WithLp.equiv_symm_zero, _root_.map_zero]\n\n"}
{"name":"Pi.orthonormalBasis_repr","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"η : Type u_7\ninst✝⁴ : Fintype η\nι : η → Type u_8\ninst✝³ : (i : η) → Fintype (ι i)\n𝕜 : Type u_9\ninst✝² : RCLike 𝕜\nE : η → Type u_10\ninst✝¹ : (i : η) → NormedAddCommGroup (E i)\ninst✝ : (i : η) → InnerProductSpace 𝕜 (E i)\nB : (i : η) → OrthonormalBasis (ι i) 𝕜 (E i)\nx : (i : η) → E i\nj : Sigma fun i => ι i\n⊢ Eq ((Pi.orthonormalBasis B).repr x j) ((B j.fst).repr (x j.fst) j.snd)","decl":"@[simp]\ntheorem _root_.Pi.orthonormalBasis_repr {η : Type*} [Fintype η] {ι : η → Type*}\n    [∀ i, Fintype (ι i)] {𝕜 : Type*} [RCLike 𝕜] {E : η → Type*} [∀ i, NormedAddCommGroup (E i)]\n    [∀ i, InnerProductSpace 𝕜 (E i)] (B : ∀ i, OrthonormalBasis (ι i) 𝕜 (E i)) (x : (i : η ) → E i)\n    (j : (i : η) × (ι i)) :\n    (Pi.orthonormalBasis B).repr x j = (B j.fst).repr (x j.fst) j.snd := rfl\n\n"}
{"name":"OrthonormalBasis.coe_mk","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : Fintype ι\nv : ι → E\nhon : Orthonormal 𝕜 v\nhsp : LE.le Top.top (Submodule.span 𝕜 (Set.range v))\n⊢ Eq (⇑(OrthonormalBasis.mk hon hsp)) v","decl":"@[simp]\nprotected theorem coe_mk (hon : Orthonormal 𝕜 v) (hsp : ⊤ ≤ Submodule.span 𝕜 (Set.range v)) :\n    ⇑(OrthonormalBasis.mk hon hsp) = v := by\n  classical rw [OrthonormalBasis.mk, _root_.Basis.coe_toOrthonormalBasis, Basis.coe_mk]\n\n"}
{"name":"OrthonormalBasis.span_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι' : Type u_2\n𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : DecidableEq E\nv' : ι' → E\nh : Orthonormal 𝕜 v'\ns : Finset ι'\ni : Subtype fun x => Membership.mem s x\n⊢ Eq (↑((OrthonormalBasis.span h s) i)) (v' ↑i)","decl":"@[simp]\nprotected theorem span_apply [DecidableEq E] {v' : ι' → E} (h : Orthonormal 𝕜 v') (s : Finset ι')\n    (i : s) : (OrthonormalBasis.span h s i : E) = v' i := by\n  simp only [OrthonormalBasis.span, Basis.span_apply, LinearIsometryEquiv.ofEq_symm,\n    OrthonormalBasis.map_apply, OrthonormalBasis.coe_mk, LinearIsometryEquiv.coe_ofEq_apply,\n    comp_apply]\n\n"}
{"name":"OrthonormalBasis.coe_of_orthogonal_eq_bot_mk","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : Fintype ι\nv : ι → E\nhon : Orthonormal 𝕜 v\nhsp : Eq (Submodule.span 𝕜 (Set.range v)).orthogonal Bot.bot\n⊢ Eq (⇑(OrthonormalBasis.mkOfOrthogonalEqBot hon hsp)) v","decl":"@[simp]\nprotected theorem coe_of_orthogonal_eq_bot_mk (hon : Orthonormal 𝕜 v)\n    (hsp : (span 𝕜 (Set.range v))ᗮ = ⊥) : ⇑(OrthonormalBasis.mkOfOrthogonalEqBot hon hsp) = v :=\n  OrthonormalBasis.coe_mk hon _\n\n"}
{"name":"OrthonormalBasis.reindex_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\nι' : Type u_2\n𝕜 : Type u_3\ninst✝⁴ : RCLike 𝕜\nE : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : Fintype ι\ninst✝ : Fintype ι'\nb : OrthonormalBasis ι 𝕜 E\ne : Equiv ι ι'\ni' : ι'\n⊢ Eq ((b.reindex e) i') (b (e.symm i'))","decl":"protected theorem reindex_apply (b : OrthonormalBasis ι 𝕜 E) (e : ι ≃ ι') (i' : ι') :\n    (b.reindex e) i' = b (e.symm i') := by\n  classical\n    dsimp [reindex]\n    rw [coe_ofRepr]\n    dsimp\n    rw [← b.repr_symm_single, LinearIsometryEquiv.piLpCongrLeft_symm,\n      EuclideanSpace.piLpCongrLeft_single]\n\n"}
{"name":"OrthonormalBasis.reindex_toBasis","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\nι' : Type u_2\n𝕜 : Type u_3\ninst✝⁴ : RCLike 𝕜\nE : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : Fintype ι\ninst✝ : Fintype ι'\nb : OrthonormalBasis ι 𝕜 E\ne : Equiv ι ι'\n⊢ Eq (b.reindex e).toBasis (b.toBasis.reindex e)","decl":"@[simp]\ntheorem reindex_toBasis (b : OrthonormalBasis ι 𝕜 E) (e : ι ≃ ι') :\n    (b.reindex e).toBasis = b.toBasis.reindex e := Basis.eq_ofRepr_eq_repr fun _ ↦ congr_fun rfl\n\n"}
{"name":"OrthonormalBasis.coe_reindex","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\nι' : Type u_2\n𝕜 : Type u_3\ninst✝⁴ : RCLike 𝕜\nE : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : Fintype ι\ninst✝ : Fintype ι'\nb : OrthonormalBasis ι 𝕜 E\ne : Equiv ι ι'\n⊢ Eq (⇑(b.reindex e)) (Function.comp ⇑b ⇑e.symm)","decl":"@[simp]\nprotected theorem coe_reindex (b : OrthonormalBasis ι 𝕜 E) (e : ι ≃ ι') :\n    ⇑(b.reindex e) = b ∘ e.symm :=\n  funext (b.reindex_apply e)\n\n"}
{"name":"OrthonormalBasis.repr_reindex","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\nι' : Type u_2\n𝕜 : Type u_3\ninst✝⁴ : RCLike 𝕜\nE : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : Fintype ι\ninst✝ : Fintype ι'\nb : OrthonormalBasis ι 𝕜 E\ne : Equiv ι ι'\nx : E\ni' : ι'\n⊢ Eq ((b.reindex e).repr x i') (b.repr x (e.symm i'))","decl":"@[simp]\nprotected theorem repr_reindex (b : OrthonormalBasis ι 𝕜 E) (e : ι ≃ ι') (x : E) (i' : ι') :\n    (b.reindex e).repr x i' = b.repr x (e.symm i') := by\n  classical\n  rw [OrthonormalBasis.repr_apply_apply, b.repr_apply_apply, OrthonormalBasis.coe_reindex,\n    comp_apply]\n\n"}
{"name":"EuclideanSpace.basisFun_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\ni : ι\n⊢ Eq ((EuclideanSpace.basisFun ι 𝕜) i) (EuclideanSpace.single i 1)","decl":"@[simp]\ntheorem basisFun_apply [DecidableEq ι] (i : ι) : basisFun ι 𝕜 i = EuclideanSpace.single i 1 :=\n  PiLp.basisFun_apply _ _ _ _\n\n"}
{"name":"EuclideanSpace.basisFun_repr","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝¹ : RCLike 𝕜\ninst✝ : Fintype ι\nx : EuclideanSpace 𝕜 ι\ni : ι\n⊢ Eq ((EuclideanSpace.basisFun ι 𝕜).repr x i) (x i)","decl":"@[simp]\ntheorem basisFun_repr (x : EuclideanSpace 𝕜 ι) (i : ι) : (basisFun ι 𝕜).repr x i = x i := rfl\n\n"}
{"name":"EuclideanSpace.basisFun_toBasis","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝¹ : RCLike 𝕜\ninst✝ : Fintype ι\n⊢ Eq (EuclideanSpace.basisFun ι 𝕜).toBasis (PiLp.basisFun 2 𝕜 ι)","decl":"theorem basisFun_toBasis : (basisFun ι 𝕜).toBasis = PiLp.basisFun _ 𝕜 ι := rfl\n\n"}
{"name":"Complex.orthonormalBasisOneI_repr_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"z : Complex\n⊢ Eq (Complex.orthonormalBasisOneI.repr z) (Matrix.vecCons z.re (Matrix.vecCons z.im Matrix.vecEmpty))","decl":"@[simp]\ntheorem Complex.orthonormalBasisOneI_repr_apply (z : ℂ) :\n    Complex.orthonormalBasisOneI.repr z = ![z.re, z.im] :=\n  rfl\n\n"}
{"name":"Complex.orthonormalBasisOneI_repr_symm_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"x : EuclideanSpace Real (Fin 2)\n⊢ Eq (Complex.orthonormalBasisOneI.repr.symm x) (HAdd.hAdd (↑(x 0)) (HMul.hMul (↑(x 1)) Complex.I))","decl":"@[simp]\ntheorem Complex.orthonormalBasisOneI_repr_symm_apply (x : EuclideanSpace ℝ (Fin 2)) :\n    Complex.orthonormalBasisOneI.repr.symm x = x 0 + x 1 * I :=\n  rfl\n\n"}
{"name":"Complex.toBasis_orthonormalBasisOneI","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"⊢ Eq Complex.orthonormalBasisOneI.toBasis Complex.basisOneI","decl":"@[simp]\ntheorem Complex.toBasis_orthonormalBasisOneI :\n    Complex.orthonormalBasisOneI.toBasis = Complex.basisOneI :=\n  Basis.toBasis_toOrthonormalBasis _ _\n\n"}
{"name":"Complex.coe_orthonormalBasisOneI","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"⊢ Eq (⇑Complex.orthonormalBasisOneI) (Matrix.vecCons 1 (Matrix.vecCons Complex.I Matrix.vecEmpty))","decl":"@[simp]\ntheorem Complex.coe_orthonormalBasisOneI :\n    (Complex.orthonormalBasisOneI : Fin 2 → ℂ) = ![1, I] := by\n  simp [Complex.orthonormalBasisOneI]\n\n"}
{"name":"Complex.map_isometryOfOrthonormal","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"F : Type u_5\ninst✝³ : NormedAddCommGroup F\ninst✝² : InnerProductSpace Real F\nF' : Type u_6\ninst✝¹ : NormedAddCommGroup F'\ninst✝ : InnerProductSpace Real F'\nv : OrthonormalBasis (Fin 2) Real F\nf : LinearIsometryEquiv (RingHom.id Real) F F'\n⊢ Eq (Complex.isometryOfOrthonormal (v.map f)) ((Complex.isometryOfOrthonormal v).trans f)","decl":"@[simp]\ntheorem Complex.map_isometryOfOrthonormal (v : OrthonormalBasis (Fin 2) ℝ F) (f : F ≃ₗᵢ[ℝ] F') :\n    Complex.isometryOfOrthonormal (v.map f) = (Complex.isometryOfOrthonormal v).trans f := by\n  simp only [isometryOfOrthonormal, OrthonormalBasis.map, LinearIsometryEquiv.symm_trans,\n    LinearIsometryEquiv.symm_symm]\n  -- Porting note: `LinearIsometryEquiv.trans_assoc` doesn't trigger in the `simp` above\n  rw [LinearIsometryEquiv.trans_assoc]\n\n"}
{"name":"Complex.isometryOfOrthonormal_symm_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"F : Type u_5\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nv : OrthonormalBasis (Fin 2) Real F\nf : F\n⊢ Eq ((Complex.isometryOfOrthonormal v).symm f) (HAdd.hAdd (↑((v.toBasis.coord 0) f)) (HMul.hMul (↑((v.toBasis.coord 1) f)) Complex.I))","decl":"theorem Complex.isometryOfOrthonormal_symm_apply (v : OrthonormalBasis (Fin 2) ℝ F) (f : F) :\n    (Complex.isometryOfOrthonormal v).symm f =\n      (v.toBasis.coord 0 f : ℂ) + (v.toBasis.coord 1 f : ℂ) * I := by\n  simp [Complex.isometryOfOrthonormal]\n\n"}
{"name":"Complex.isometryOfOrthonormal_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"F : Type u_5\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nv : OrthonormalBasis (Fin 2) Real F\nz : Complex\n⊢ Eq ((Complex.isometryOfOrthonormal v) z) (HAdd.hAdd (HSMul.hSMul z.re (v 0)) (HSMul.hSMul z.im (v 1)))","decl":"theorem Complex.isometryOfOrthonormal_apply (v : OrthonormalBasis (Fin 2) ℝ F) (z : ℂ) :\n    Complex.isometryOfOrthonormal v z = z.re • v 0 + z.im • v 1 := by\n  -- Porting note: was\n  -- simp [Complex.isometryOfOrthonormal, ← v.sum_repr_symm]\n  rw [Complex.isometryOfOrthonormal, LinearIsometryEquiv.trans_apply]\n  simp [← v.sum_repr_symm]\n\n"}
{"name":"OrthonormalBasis.toMatrix_orthonormalBasis_conjTranspose_mul_self","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\nι' : Type u_2\n𝕜 : Type u_3\ninst✝⁵ : RCLike 𝕜\nE : Type u_4\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι'\na : OrthonormalBasis ι' 𝕜 E\nb : OrthonormalBasis ι 𝕜 E\n⊢ Eq (HMul.hMul (a.toBasis.toMatrix ⇑b).conjTranspose (a.toBasis.toMatrix ⇑b)) 1","decl":"/-- A version of `OrthonormalBasis.toMatrix_orthonormalBasis_mem_unitary` that works for bases with\ndifferent index types. -/\n@[simp]\ntheorem OrthonormalBasis.toMatrix_orthonormalBasis_conjTranspose_mul_self [Fintype ι']\n    (a : OrthonormalBasis ι' 𝕜 E) (b : OrthonormalBasis ι 𝕜 E) :\n    (a.toBasis.toMatrix b)ᴴ * a.toBasis.toMatrix b = 1 := by\n  ext i j\n  convert a.repr.inner_map_map (b i) (b j)\n  rw [orthonormal_iff_ite.mp b.orthonormal i j]\n  rfl\n\n"}
{"name":"OrthonormalBasis.toMatrix_orthonormalBasis_self_mul_conjTranspose","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\nι' : Type u_2\n𝕜 : Type u_3\ninst✝⁵ : RCLike 𝕜\nE : Type u_4\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι'\na : OrthonormalBasis ι 𝕜 E\nb : OrthonormalBasis ι' 𝕜 E\n⊢ Eq (HMul.hMul (a.toBasis.toMatrix ⇑b) (a.toBasis.toMatrix ⇑b).conjTranspose) 1","decl":"/-- A version of `OrthonormalBasis.toMatrix_orthonormalBasis_mem_unitary` that works for bases with\ndifferent index types. -/\n@[simp]\ntheorem OrthonormalBasis.toMatrix_orthonormalBasis_self_mul_conjTranspose [Fintype ι']\n    (a : OrthonormalBasis ι 𝕜 E) (b : OrthonormalBasis ι' 𝕜 E) :\n    a.toBasis.toMatrix b * (a.toBasis.toMatrix b)ᴴ = 1 := by\n  classical\n  rw [Matrix.mul_eq_one_comm_of_equiv (a.toBasis.indexEquiv b.toBasis),\n    a.toMatrix_orthonormalBasis_conjTranspose_mul_self b]\n\n"}
{"name":"OrthonormalBasis.toMatrix_orthonormalBasis_mem_unitary","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝⁴ : RCLike 𝕜\nE : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\na b : OrthonormalBasis ι 𝕜 E\n⊢ Membership.mem (Matrix.unitaryGroup ι 𝕜) (a.toBasis.toMatrix ⇑b)","decl":"/-- The change-of-basis matrix between two orthonormal bases `a`, `b` is a unitary matrix. -/\ntheorem OrthonormalBasis.toMatrix_orthonormalBasis_mem_unitary :\n    a.toBasis.toMatrix b ∈ Matrix.unitaryGroup ι 𝕜 := by\n  rw [Matrix.mem_unitaryGroup_iff']\n  exact a.toMatrix_orthonormalBasis_conjTranspose_mul_self b\n\n"}
{"name":"OrthonormalBasis.det_to_matrix_orthonormalBasis","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝⁴ : RCLike 𝕜\nE : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\na b : OrthonormalBasis ι 𝕜 E\n⊢ Eq (Norm.norm (a.toBasis.det ⇑b)) 1","decl":"/-- The determinant of the change-of-basis matrix between two orthonormal bases `a`, `b` has\nunit length. -/\n@[simp]\ntheorem OrthonormalBasis.det_to_matrix_orthonormalBasis : ‖a.toBasis.det b‖ = 1 := by\n  have := (Matrix.det_of_mem_unitary (a.toMatrix_orthonormalBasis_mem_unitary b)).2\n  rw [star_def, RCLike.mul_conj] at this\n  norm_cast at this\n  rwa [pow_eq_one_iff_of_nonneg (norm_nonneg _) two_ne_zero] at this\n\n"}
{"name":"OrthonormalBasis.toMatrix_orthonormalBasis_mem_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\nF : Type u_5\ninst✝³ : NormedAddCommGroup F\ninst✝² : InnerProductSpace Real F\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\na b : OrthonormalBasis ι Real F\n⊢ Membership.mem (Matrix.orthogonalGroup ι Real) (a.toBasis.toMatrix ⇑b)","decl":"/-- The change-of-basis matrix between two orthonormal bases `a`, `b` is an orthogonal matrix. -/\ntheorem OrthonormalBasis.toMatrix_orthonormalBasis_mem_orthogonal :\n    a.toBasis.toMatrix b ∈ Matrix.orthogonalGroup ι ℝ :=\n  a.toMatrix_orthonormalBasis_mem_unitary b\n\n"}
{"name":"OrthonormalBasis.det_to_matrix_orthonormalBasis_real","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\nF : Type u_5\ninst✝³ : NormedAddCommGroup F\ninst✝² : InnerProductSpace Real F\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\na b : OrthonormalBasis ι Real F\n⊢ Or (Eq (a.toBasis.det ⇑b) 1) (Eq (a.toBasis.det ⇑b) (-1))","decl":"/-- The determinant of the change-of-basis matrix between two orthonormal bases `a`, `b` is ±1. -/\ntheorem OrthonormalBasis.det_to_matrix_orthonormalBasis_real :\n    a.toBasis.det b = 1 ∨ a.toBasis.det b = -1 := by\n  rw [← sq_eq_one_iff]\n  simpa [unitary, sq] using Matrix.det_of_mem_unitary (a.toMatrix_orthonormalBasis_mem_unitary b)\n\n"}
{"name":"DirectSum.IsInternal.collectedOrthonormalBasis_mem","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝⁵ : RCLike 𝕜\nE : Type u_4\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : Fintype ι\nA : ι → Submodule 𝕜 E\ninst✝¹ : DecidableEq ι\nh : DirectSum.IsInternal A\nα : ι → Type u_7\ninst✝ : (i : ι) → Fintype (α i)\nhV : OrthogonalFamily 𝕜 (fun i => Subtype fun x => Membership.mem (A i) x) fun i => (A i).subtypeₗᵢ\nv : (i : ι) → OrthonormalBasis (α i) 𝕜 (Subtype fun x => Membership.mem (A i) x)\na : Sigma fun i => α i\n⊢ Membership.mem (A a.fst) ((DirectSum.IsInternal.collectedOrthonormalBasis hV h v) a)","decl":"theorem DirectSum.IsInternal.collectedOrthonormalBasis_mem [DecidableEq ι]\n    (h : DirectSum.IsInternal A) {α : ι → Type*} [∀ i, Fintype (α i)]\n    (hV : OrthogonalFamily 𝕜 (fun i => A i) fun i => (A i).subtypeₗᵢ)\n    (v : ∀ i, OrthonormalBasis (α i) 𝕜 (A i)) (a : Σi, α i) :\n    h.collectedOrthonormalBasis hV v a ∈ A a.1 := by\n  simp [DirectSum.IsInternal.collectedOrthonormalBasis]\n\n"}
{"name":"Orthonormal.exists_orthonormalBasis_extension","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nv : Set E\ninst✝ : FiniteDimensional 𝕜 E\nhv : Orthonormal 𝕜 Subtype.val\n⊢ Exists fun u => Exists fun b => And (HasSubset.Subset v ↑u) (Eq (⇑b) Subtype.val)","decl":"/-- In a finite-dimensional `InnerProductSpace`, any orthonormal subset can be extended to an\northonormal basis. -/\ntheorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal 𝕜 ((↑) : v → E)) :\n    ∃ (u : Finset E) (b : OrthonormalBasis u 𝕜 E), v ⊆ u ∧ ⇑b = ((↑) : u → E) := by\n  obtain ⟨u₀, hu₀s, hu₀, hu₀_max⟩ := exists_maximal_orthonormal hv\n  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu₀] at hu₀_max\n  have hu₀_finite : u₀.Finite := hu₀.linearIndependent.setFinite\n  let u : Finset E := hu₀_finite.toFinset\n  let fu : ↥u ≃ ↥u₀ := hu₀_finite.subtypeEquivToFinset.symm\n  have hu : Orthonormal 𝕜 ((↑) : u → E) := by simpa using hu₀.comp _ fu.injective\n  refine ⟨u, OrthonormalBasis.mkOfOrthogonalEqBot hu ?_, ?_, ?_⟩\n  · simpa [u] using hu₀_max\n  · simpa [u] using hu₀s\n  · simp\n\n"}
{"name":"Orthonormal.exists_orthonormalBasis_extension_of_card_eq","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"𝕜 : Type u_3\ninst✝⁴ : RCLike 𝕜\nE : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : FiniteDimensional 𝕜 E\nι : Type u_7\ninst✝ : Fintype ι\ncard_ι : Eq (Module.finrank 𝕜 E) (Fintype.card ι)\nv : ι → E\ns : Set ι\nhv : Orthonormal 𝕜 (s.restrict v)\n⊢ Exists fun b => ∀ (i : ι), Membership.mem s i → Eq (b i) (v i)","decl":"theorem Orthonormal.exists_orthonormalBasis_extension_of_card_eq {ι : Type*} [Fintype ι]\n    (card_ι : finrank 𝕜 E = Fintype.card ι) {v : ι → E} {s : Set ι}\n    (hv : Orthonormal 𝕜 (s.restrict v)) : ∃ b : OrthonormalBasis ι 𝕜 E, ∀ i ∈ s, b i = v i := by\n  have hsv : Injective (s.restrict v) := hv.linearIndependent.injective\n  have hX : Orthonormal 𝕜 ((↑) : Set.range (s.restrict v) → E) := by\n    rwa [orthonormal_subtype_range hsv]\n  obtain ⟨Y, b₀, hX, hb₀⟩ := hX.exists_orthonormalBasis_extension\n  have hιY : Fintype.card ι = Y.card := by\n    refine card_ι.symm.trans ?_\n    exact Module.finrank_eq_card_finset_basis b₀.toBasis\n  have hvsY : s.MapsTo v Y := (s.mapsTo_image v).mono_right (by rwa [← range_restrict])\n  have hsv' : Set.InjOn v s := by\n    rw [Set.injOn_iff_injective]\n    exact hsv\n  obtain ⟨g, hg⟩ := hvsY.exists_equiv_extend_of_card_eq hιY hsv'\n  use b₀.reindex g.symm\n  intro i hi\n  simp [hb₀, hg i hi]\n\n"}
{"name":"exists_orthonormalBasis","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : FiniteDimensional 𝕜 E\n⊢ Exists fun w => Exists fun b => Eq (⇑b) Subtype.val","decl":"/-- A finite-dimensional inner product space admits an orthonormal basis. -/\ntheorem _root_.exists_orthonormalBasis :\n    ∃ (w : Finset E) (b : OrthonormalBasis w 𝕜 E), ⇑b = ((↑) : w → E) :=\n  let ⟨w, hw, _, hw''⟩ := (orthonormal_empty 𝕜 E).exists_orthonormalBasis_extension\n  ⟨w, hw, hw''⟩\n\n"}
{"name":"stdOrthonormalBasis_def","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"𝕜 : Type u_7\ninst✝³ : RCLike 𝕜\nE : Type u_8\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : FiniteDimensional 𝕜 E\n⊢ Eq (stdOrthonormalBasis 𝕜 E)\n    (let b := Classical.choose ⋯;\n    ⋯.mpr (b.reindex (Fintype.equivFinOfCardEq ⋯)))","decl":"/-- A finite-dimensional `InnerProductSpace` has an orthonormal basis. -/\nirreducible_def stdOrthonormalBasis : OrthonormalBasis (Fin (finrank 𝕜 E)) 𝕜 E := by\n  let b := Classical.choose (Classical.choose_spec <| exists_orthonormalBasis 𝕜 E)\n  rw [finrank_eq_card_basis b.toBasis]\n  exact b.reindex (Fintype.equivFinOfCardEq rfl)\n\n"}
{"name":"orthonormalBasis_one_dim","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nb : OrthonormalBasis ι Real Real\n⊢ Or (Eq ⇑b fun x => 1) (Eq ⇑b fun x => -1)","decl":"/-- An orthonormal basis of `ℝ` is made either of the vector `1`, or of the vector `-1`. -/\ntheorem orthonormalBasis_one_dim (b : OrthonormalBasis ι ℝ ℝ) :\n    (⇑b = fun _ => (1 : ℝ)) ∨ ⇑b = fun _ => (-1 : ℝ) := by\n  have : Unique ι := b.toBasis.unique\n  have : b default = 1 ∨ b default = -1 := by\n    have : ‖b default‖ = 1 := b.orthonormal.1 _\n    rwa [Real.norm_eq_abs, abs_eq (zero_le_one' ℝ)] at this\n  rw [eq_const_of_unique b]\n  refine this.imp ?_ ?_ <;> (intro; ext; simp [*])\n\n"}
{"name":"DirectSum.IsInternal.sigmaOrthonormalBasisIndexEquiv_def","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_7\n𝕜 : Type u_8\ninst✝⁵ : RCLike 𝕜\nE : Type u_9\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : Fintype ι\ninst✝¹ : FiniteDimensional 𝕜 E\nn : Nat\nhn : Eq (Module.finrank 𝕜 E) n\ninst✝ : DecidableEq ι\nV : ι → Submodule 𝕜 E\nhV : DirectSum.IsInternal V\nhV' : OrthogonalFamily 𝕜 (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeₗᵢ\n⊢ Eq (DirectSum.IsInternal.sigmaOrthonormalBasisIndexEquiv hn hV hV')\n    (let b := DirectSum.IsInternal.collectedOrthonormalBasis hV' hV fun i => stdOrthonormalBasis 𝕜 (Subtype fun x => Membership.mem (V i) x);\n    Fintype.equivFinOfCardEq ⋯)","decl":"/-- Exhibit a bijection between `Fin n` and the index set of a certain basis of an `n`-dimensional\ninner product space `E`.  This should not be accessed directly, but only via the subsequent API. -/\nirreducible_def DirectSum.IsInternal.sigmaOrthonormalBasisIndexEquiv\n    (hV' : OrthogonalFamily 𝕜 (fun i => V i) fun i => (V i).subtypeₗᵢ) :\n    (Σi, Fin (finrank 𝕜 (V i))) ≃ Fin n :=\n  let b := hV.collectedOrthonormalBasis hV' fun i => stdOrthonormalBasis 𝕜 (V i)\n  Fintype.equivFinOfCardEq <| (Module.finrank_eq_card_basis b.toBasis).symm.trans hn\n\n"}
{"name":"DirectSum.IsInternal.subordinateOrthonormalBasis_def","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_7\n𝕜 : Type u_8\ninst✝⁵ : RCLike 𝕜\nE : Type u_9\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : Fintype ι\ninst✝¹ : FiniteDimensional 𝕜 E\nn : Nat\nhn : Eq (Module.finrank 𝕜 E) n\ninst✝ : DecidableEq ι\nV : ι → Submodule 𝕜 E\nhV : DirectSum.IsInternal V\nhV' : OrthogonalFamily 𝕜 (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeₗᵢ\n⊢ Eq (DirectSum.IsInternal.subordinateOrthonormalBasis hn hV hV') ((DirectSum.IsInternal.collectedOrthonormalBasis hV' hV fun i => stdOrthonormalBasis 𝕜 (Subtype fun x => Membership.mem (V i) x)).reindex (DirectSum.IsInternal.sigmaOrthonormalBasisIndexEquiv hn hV hV'))","decl":"/-- An `n`-dimensional `InnerProductSpace` equipped with a decomposition as an internal direct\nsum has an orthonormal basis indexed by `Fin n` and subordinate to that direct sum. -/\nirreducible_def DirectSum.IsInternal.subordinateOrthonormalBasis\n    (hV' : OrthogonalFamily 𝕜 (fun i => V i) fun i => (V i).subtypeₗᵢ) :\n    OrthonormalBasis (Fin n) 𝕜 E :=\n  (hV.collectedOrthonormalBasis hV' fun i => stdOrthonormalBasis 𝕜 (V i)).reindex\n    (hV.sigmaOrthonormalBasisIndexEquiv hn hV')\n\n"}
{"name":"DirectSum.IsInternal.subordinateOrthonormalBasisIndex_def","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_7\n𝕜 : Type u_8\ninst✝⁵ : RCLike 𝕜\nE : Type u_9\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : Fintype ι\ninst✝¹ : FiniteDimensional 𝕜 E\nn : Nat\nhn : Eq (Module.finrank 𝕜 E) n\ninst✝ : DecidableEq ι\nV : ι → Submodule 𝕜 E\nhV : DirectSum.IsInternal V\na : Fin n\nhV' : OrthogonalFamily 𝕜 (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeₗᵢ\n⊢ Eq (DirectSum.IsInternal.subordinateOrthonormalBasisIndex hn hV a hV') ((DirectSum.IsInternal.sigmaOrthonormalBasisIndexEquiv hn hV hV').symm a).fst","decl":"/-- An `n`-dimensional `InnerProductSpace` equipped with a decomposition as an internal direct\nsum has an orthonormal basis indexed by `Fin n` and subordinate to that direct sum. This function\nprovides the mapping by which it is subordinate. -/\nirreducible_def DirectSum.IsInternal.subordinateOrthonormalBasisIndex (a : Fin n)\n    (hV' : OrthogonalFamily 𝕜 (fun i => V i) fun i => (V i).subtypeₗᵢ) : ι :=\n  ((hV.sigmaOrthonormalBasisIndexEquiv hn hV').symm a).1\n\n"}
{"name":"DirectSum.IsInternal.subordinateOrthonormalBasis_subordinate","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ι : Type u_1\n𝕜 : Type u_3\ninst✝⁵ : RCLike 𝕜\nE : Type u_4\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : Fintype ι\ninst✝¹ : FiniteDimensional 𝕜 E\nn : Nat\nhn : Eq (Module.finrank 𝕜 E) n\ninst✝ : DecidableEq ι\nV : ι → Submodule 𝕜 E\nhV : DirectSum.IsInternal V\na : Fin n\nhV' : OrthogonalFamily 𝕜 (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeₗᵢ\n⊢ Membership.mem (V (DirectSum.IsInternal.subordinateOrthonormalBasisIndex hn hV a hV')) ((DirectSum.IsInternal.subordinateOrthonormalBasis hn hV hV') a)","decl":"/-- The basis constructed in `DirectSum.IsInternal.subordinateOrthonormalBasis` is subordinate to\nthe `OrthogonalFamily` in question. -/\ntheorem DirectSum.IsInternal.subordinateOrthonormalBasis_subordinate (a : Fin n)\n    (hV' : OrthogonalFamily 𝕜 (fun i => V i) fun i => (V i).subtypeₗᵢ) :\n    hV.subordinateOrthonormalBasis hn hV' a ∈ V (hV.subordinateOrthonormalBasisIndex hn a hV') := by\n  simpa only [DirectSum.IsInternal.subordinateOrthonormalBasis, OrthonormalBasis.coe_reindex,\n    DirectSum.IsInternal.subordinateOrthonormalBasisIndex] using\n    hV.collectedOrthonormalBasis_mem hV' (fun i => stdOrthonormalBasis 𝕜 (V i))\n      ((hV.sigmaOrthonormalBasisIndexEquiv hn hV').symm a)\n\n"}
{"name":"LinearIsometry.extend_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nV : Type u_7\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace 𝕜 V\ninst✝ : FiniteDimensional 𝕜 V\nS : Submodule 𝕜 V\nL : LinearIsometry (RingHom.id 𝕜) (Subtype fun x => Membership.mem S x) V\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (L.extend ↑s) (L s)","decl":"theorem LinearIsometry.extend_apply (L : S →ₗᵢ[𝕜] V) (s : S) : L.extend s = L s := by\n  haveI : CompleteSpace S := FiniteDimensional.complete 𝕜 S\n  simp only [LinearIsometry.extend, ← LinearIsometry.coe_toLinearMap]\n  simp only [add_right_eq_self, LinearIsometry.coe_toLinearMap,\n    LinearIsometryEquiv.coe_toLinearIsometry, LinearIsometry.coe_comp, Function.comp_apply,\n    orthogonalProjection_mem_subspace_eq_self, LinearMap.coe_comp, ContinuousLinearMap.coe_coe,\n    Submodule.coe_subtype, LinearMap.add_apply, Submodule.coe_eq_zero,\n    LinearIsometryEquiv.map_eq_zero_iff, Submodule.coe_subtypeₗᵢ,\n    orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero, Submodule.orthogonal_orthogonal,\n    Submodule.coe_mem]\n\n"}
{"name":"Matrix.toEuclideanLin_piLp_equiv_symm","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"𝕜 : Type u_3\ninst✝² : RCLike 𝕜\nm : Type u_7\nn : Type u_8\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix m n 𝕜\nx : n → 𝕜\n⊢ Eq ((Matrix.toEuclideanLin A) ((WithLp.equiv 2 ((i : n) → (fun x => 𝕜) i)).symm x)) ((WithLp.equiv 2 (m → 𝕜)).symm ((Matrix.toLin' A) x))","decl":"@[simp]\ntheorem toEuclideanLin_piLp_equiv_symm (A : Matrix m n 𝕜) (x : n → 𝕜) :\n    Matrix.toEuclideanLin A ((WithLp.equiv _ _).symm x) =\n      (WithLp.equiv _ _).symm (Matrix.toLin' A x) :=\n  rfl\n\n"}
{"name":"Matrix.piLp_equiv_toEuclideanLin","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"𝕜 : Type u_3\ninst✝² : RCLike 𝕜\nm : Type u_7\nn : Type u_8\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix m n 𝕜\nx : EuclideanSpace 𝕜 n\n⊢ Eq ((WithLp.equiv 2 ((i : m) → (fun x => 𝕜) i)) ((Matrix.toEuclideanLin A) x)) ((Matrix.toLin' A) ((WithLp.equiv 2 (n → 𝕜)) x))","decl":"@[simp]\ntheorem piLp_equiv_toEuclideanLin (A : Matrix m n 𝕜) (x : EuclideanSpace 𝕜 n) :\n    WithLp.equiv _ _ (Matrix.toEuclideanLin A x) = Matrix.toLin' A (WithLp.equiv _ _ x) :=\n  rfl\n\n"}
{"name":"Matrix.toEuclideanLin_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"𝕜 : Type u_3\ninst✝² : RCLike 𝕜\nm : Type u_7\nn : Type u_8\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nM : Matrix m n 𝕜\nv : EuclideanSpace 𝕜 n\n⊢ Eq ((Matrix.toEuclideanLin M) v) ((WithLp.equiv 2 (m → 𝕜)).symm (M.mulVec ((WithLp.equiv 2 (n → 𝕜)) v)))","decl":"theorem toEuclideanLin_apply (M : Matrix m n 𝕜) (v : EuclideanSpace 𝕜 n) :\n    toEuclideanLin M v = (WithLp.equiv 2 (m → 𝕜)).symm (M *ᵥ (WithLp.equiv 2 (n → 𝕜)) v) :=\n  rfl\n\n"}
{"name":"Matrix.piLp_equiv_toEuclideanLin_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"𝕜 : Type u_3\ninst✝² : RCLike 𝕜\nm : Type u_7\nn : Type u_8\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nM : Matrix m n 𝕜\nv : EuclideanSpace 𝕜 n\n⊢ Eq ((WithLp.equiv 2 (m → 𝕜)) ((Matrix.toEuclideanLin M) v)) (M.mulVec ((WithLp.equiv 2 (n → 𝕜)) v))","decl":"@[simp]\ntheorem piLp_equiv_toEuclideanLin_apply (M : Matrix m n 𝕜) (v : EuclideanSpace 𝕜 n) :\n    WithLp.equiv 2 (m → 𝕜) (toEuclideanLin M v) = M *ᵥ WithLp.equiv 2 (n → 𝕜) v :=\n  rfl\n\n"}
{"name":"Matrix.toEuclideanLin_apply_piLp_equiv_symm","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"𝕜 : Type u_3\ninst✝² : RCLike 𝕜\nm : Type u_7\nn : Type u_8\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nM : Matrix m n 𝕜\nv : n → 𝕜\n⊢ Eq ((Matrix.toEuclideanLin M) ((WithLp.equiv 2 (n → 𝕜)).symm v)) ((WithLp.equiv 2 (m → 𝕜)).symm (M.mulVec v))","decl":"@[simp]\ntheorem toEuclideanLin_apply_piLp_equiv_symm (M : Matrix m n 𝕜) (v : n → 𝕜) :\n    toEuclideanLin M ((WithLp.equiv 2 (n→ 𝕜)).symm v) = (WithLp.equiv 2 (m → 𝕜)).symm (M *ᵥ v) :=\n  rfl\n\n-- `Matrix.toEuclideanLin` is the same as `Matrix.toLin` applied to `PiLp.basisFun`,\n"}
{"name":"Matrix.toEuclideanLin_eq_toLin","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nm : Type u_7\nn : Type u_8\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : Finite m\n⊢ Eq Matrix.toEuclideanLin (Matrix.toLin (PiLp.basisFun 2 𝕜 n) (PiLp.basisFun 2 𝕜 m))","decl":"theorem toEuclideanLin_eq_toLin [Finite m] :\n    (toEuclideanLin : Matrix m n 𝕜 ≃ₗ[𝕜] _) =\n      Matrix.toLin (PiLp.basisFun _ _ _) (PiLp.basisFun _ _ _) :=\n  rfl\n\n"}
{"name":"Matrix.toEuclideanLin_eq_toLin_orthonormal","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nm : Type u_7\nn : Type u_8\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : Fintype m\n⊢ Eq Matrix.toEuclideanLin (Matrix.toLin (EuclideanSpace.basisFun n 𝕜).toBasis (EuclideanSpace.basisFun m 𝕜).toBasis)","decl":"open EuclideanSpace in\nlemma toEuclideanLin_eq_toLin_orthonormal [Fintype m] :\n    toEuclideanLin = toLin (basisFun n 𝕜).toBasis (basisFun m 𝕜).toBasis :=\n  rfl\n\n"}
{"name":"inner_matrix_row_row","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"𝕜 : Type u_3\ninst✝¹ : RCLike 𝕜\nm : Type u_7\nn : Type u_8\ninst✝ : Fintype n\nA B : Matrix m n 𝕜\ni j : m\n⊢ Eq (Inner.inner ((WithLp.equiv 2 (n → 𝕜)).symm (A i)) ((WithLp.equiv 2 (n → 𝕜)).symm (B j))) (HMul.hMul B A.conjTranspose j i)","decl":"/-- The inner product of a row of `A` and a row of `B` is an entry of `B * Aᴴ`. -/\ntheorem inner_matrix_row_row [Fintype n] (A B : Matrix m n 𝕜) (i j : m) :\n    ⟪A i, B j⟫ₑ = (B * Aᴴ) j i := by\n  simp_rw [EuclideanSpace.inner_piLp_equiv_symm, Matrix.mul_apply', dotProduct_comm,\n    Matrix.conjTranspose_apply, Pi.star_def]\n\n"}
{"name":"inner_matrix_col_col","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"𝕜 : Type u_3\ninst✝¹ : RCLike 𝕜\nm : Type u_7\nn : Type u_8\ninst✝ : Fintype m\nA B : Matrix m n 𝕜\ni j : n\n⊢ Eq (Inner.inner ((WithLp.equiv 2 (m → 𝕜)).symm (A.transpose i)) ((WithLp.equiv 2 (m → 𝕜)).symm (B.transpose j))) (HMul.hMul A.conjTranspose B i j)","decl":"/-- The inner product of a column of `A` and a column of `B` is an entry of `Aᴴ * B`. -/\ntheorem inner_matrix_col_col [Fintype m] (A B : Matrix m n 𝕜) (i j : n) :\n    ⟪Aᵀ i, Bᵀ j⟫ₑ = (Aᴴ * B) i j :=\n  rfl\n\n"}
