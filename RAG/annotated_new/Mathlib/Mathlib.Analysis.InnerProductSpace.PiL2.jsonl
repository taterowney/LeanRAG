{"name":"PiLp.inner_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nÎ¹ : Type u_7\ninstâœÂ² : Fintype Î¹\nf : Î¹ â†’ Type u_8\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (f i)\ninstâœ : (i : Î¹) â†’ InnerProductSpace ğ•œ (f i)\nx y : PiLp 2 f\nâŠ¢ Eq (Inner.inner x y) (Finset.univ.sum fun i => Inner.inner (x i) (y i))","decl":"@[simp]\ntheorem PiLp.inner_apply {Î¹ : Type*} [Fintype Î¹] {f : Î¹ â†’ Type*} [âˆ€ i, NormedAddCommGroup (f i)]\n    [âˆ€ i, InnerProductSpace ğ•œ (f i)] (x y : PiLp 2 f) : âŸªx, yâŸ« = âˆ‘ i, âŸªx i, y iâŸ« :=\n  rfl\n\n"}
{"name":"EuclideanSpace.nnnorm_eq","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ğ•œ : Type u_7\ninstâœÂ¹ : RCLike ğ•œ\nn : Type u_8\ninstâœ : Fintype n\nx : EuclideanSpace ğ•œ n\nâŠ¢ Eq (NNNorm.nnnorm x) (NNReal.sqrt (Finset.univ.sum fun i => HPow.hPow (NNNorm.nnnorm (x i)) 2))","decl":"theorem EuclideanSpace.nnnorm_eq {ğ•œ : Type*} [RCLike ğ•œ] {n : Type*} [Fintype n]\n    (x : EuclideanSpace ğ•œ n) : â€–xâ€–â‚Š = NNReal.sqrt (âˆ‘ i, â€–x iâ€–â‚Š ^ 2) :=\n  PiLp.nnnorm_eq_of_L2 x\n\n"}
{"name":"EuclideanSpace.norm_eq","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ğ•œ : Type u_7\ninstâœÂ¹ : RCLike ğ•œ\nn : Type u_8\ninstâœ : Fintype n\nx : EuclideanSpace ğ•œ n\nâŠ¢ Eq (Norm.norm x) (Finset.univ.sum fun i => HPow.hPow (Norm.norm (x i)) 2).sqrt","decl":"theorem EuclideanSpace.norm_eq {ğ•œ : Type*} [RCLike ğ•œ] {n : Type*} [Fintype n]\n    (x : EuclideanSpace ğ•œ n) : â€–xâ€– = âˆš(âˆ‘ i, â€–x iâ€– ^ 2) := by\n  simpa only [Real.coe_sqrt, NNReal.coe_sum] using congr_arg ((â†‘) : â„â‰¥0 â†’ â„) x.nnnorm_eq\n\n"}
{"name":"EuclideanSpace.dist_eq","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ğ•œ : Type u_7\ninstâœÂ¹ : RCLike ğ•œ\nn : Type u_8\ninstâœ : Fintype n\nx y : EuclideanSpace ğ•œ n\nâŠ¢ Eq (Dist.dist x y) (Finset.univ.sum fun i => HPow.hPow (Dist.dist (x i) (y i)) 2).sqrt","decl":"theorem EuclideanSpace.dist_eq {ğ•œ : Type*} [RCLike ğ•œ] {n : Type*} [Fintype n]\n    (x y : EuclideanSpace ğ•œ n) : dist x y = âˆš(âˆ‘ i, dist (x i) (y i) ^ 2) :=\n  PiLp.dist_eq_of_L2 x y\n\n"}
{"name":"EuclideanSpace.nndist_eq","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ğ•œ : Type u_7\ninstâœÂ¹ : RCLike ğ•œ\nn : Type u_8\ninstâœ : Fintype n\nx y : EuclideanSpace ğ•œ n\nâŠ¢ Eq (NNDist.nndist x y) (NNReal.sqrt (Finset.univ.sum fun i => HPow.hPow (NNDist.nndist (x i) (y i)) 2))","decl":"theorem EuclideanSpace.nndist_eq {ğ•œ : Type*} [RCLike ğ•œ] {n : Type*} [Fintype n]\n    (x y : EuclideanSpace ğ•œ n) : nndist x y = NNReal.sqrt (âˆ‘ i, nndist (x i) (y i) ^ 2) :=\n  PiLp.nndist_eq_of_L2 x y\n\n"}
{"name":"EuclideanSpace.edist_eq","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ğ•œ : Type u_7\ninstâœÂ¹ : RCLike ğ•œ\nn : Type u_8\ninstâœ : Fintype n\nx y : EuclideanSpace ğ•œ n\nâŠ¢ Eq (EDist.edist x y) (HPow.hPow (Finset.univ.sum fun i => HPow.hPow (EDist.edist (x i) (y i)) 2) (1 / 2))","decl":"theorem EuclideanSpace.edist_eq {ğ•œ : Type*} [RCLike ğ•œ] {n : Type*} [Fintype n]\n    (x y : EuclideanSpace ğ•œ n) : edist x y = (âˆ‘ i, edist (x i) (y i) ^ 2) ^ (1 / 2 : â„) :=\n  PiLp.edist_eq_of_L2 x y\n\n"}
{"name":"EuclideanSpace.ball_zero_eq","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"n : Type u_7\ninstâœ : Fintype n\nr : Real\nhr : LE.le 0 r\nâŠ¢ Eq (Metric.ball 0 r) (setOf fun x => LT.lt (Finset.univ.sum fun i => HPow.hPow (x i) 2) (HPow.hPow r 2))","decl":"theorem EuclideanSpace.ball_zero_eq {n : Type*} [Fintype n] (r : â„) (hr : 0 â‰¤ r) :\n    Metric.ball (0 : EuclideanSpace â„ n) r = {x | âˆ‘ i, x i ^ 2 < r ^ 2} := by\n  ext x\n  have : (0 : â„) â‰¤ âˆ‘ i, x i ^ 2 := Finset.sum_nonneg fun _ _ => sq_nonneg _\n  simp_rw [mem_setOf, mem_ball_zero_iff, norm_eq, norm_eq_abs, sq_abs, sqrt_lt this hr]\n\n"}
{"name":"EuclideanSpace.closedBall_zero_eq","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"n : Type u_7\ninstâœ : Fintype n\nr : Real\nhr : LE.le 0 r\nâŠ¢ Eq (Metric.closedBall 0 r) (setOf fun x => LE.le (Finset.univ.sum fun i => HPow.hPow (x i) 2) (HPow.hPow r 2))","decl":"theorem EuclideanSpace.closedBall_zero_eq {n : Type*} [Fintype n] (r : â„) (hr : 0 â‰¤ r) :\n    Metric.closedBall (0 : EuclideanSpace â„ n) r = {x | âˆ‘ i, x i ^ 2 â‰¤ r ^ 2} := by\n  ext\n  simp_rw [mem_setOf, mem_closedBall_zero_iff, norm_eq, norm_eq_abs, sq_abs, sqrt_le_left hr]\n\n"}
{"name":"EuclideanSpace.sphere_zero_eq","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"n : Type u_7\ninstâœ : Fintype n\nr : Real\nhr : LE.le 0 r\nâŠ¢ Eq (Metric.sphere 0 r) (setOf fun x => Eq (Finset.univ.sum fun i => HPow.hPow (x i) 2) (HPow.hPow r 2))","decl":"theorem EuclideanSpace.sphere_zero_eq {n : Type*} [Fintype n] (r : â„) (hr : 0 â‰¤ r) :\n    Metric.sphere (0 : EuclideanSpace â„ n) r = {x | âˆ‘ i, x i ^ 2 = r ^ 2} := by\n  ext x\n  have : (0 : â„) â‰¤ âˆ‘ i, x i ^ 2 := Finset.sum_nonneg fun _ _ => sq_nonneg _\n  simp_rw [mem_setOf, mem_sphere_zero_iff_norm, norm_eq, norm_eq_abs, sq_abs,\n    Real.sqrt_eq_iff_eq_sq this hr]\n\n"}
{"name":"finrank_euclideanSpace","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : Fintype Î¹\nâŠ¢ Eq (Module.finrank ğ•œ (EuclideanSpace ğ•œ Î¹)) (Fintype.card Î¹)","decl":"@[simp]\ntheorem finrank_euclideanSpace :\n    Module.finrank ğ•œ (EuclideanSpace ğ•œ Î¹) = Fintype.card Î¹ := by\n  simp [EuclideanSpace, PiLp, WithLp]\n\n"}
{"name":"finrank_euclideanSpace_fin","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ğ•œ : Type u_3\ninstâœ : RCLike ğ•œ\nn : Nat\nâŠ¢ Eq (Module.finrank ğ•œ (EuclideanSpace ğ•œ (Fin n))) n","decl":"theorem finrank_euclideanSpace_fin {n : â„•} :\n    Module.finrank ğ•œ (EuclideanSpace ğ•œ (Fin n)) = n := by simp\n\n"}
{"name":"EuclideanSpace.inner_eq_star_dotProduct","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : Fintype Î¹\nx y : EuclideanSpace ğ•œ Î¹\nâŠ¢ Eq (Inner.inner x y) (dotProduct (Star.star ((WithLp.equiv 2 (Î¹ â†’ ğ•œ)) x)) ((WithLp.equiv 2 (Î¹ â†’ ğ•œ)) y))","decl":"theorem EuclideanSpace.inner_eq_star_dotProduct (x y : EuclideanSpace ğ•œ Î¹) :\n    âŸªx, yâŸ« = dotProduct (star <| WithLp.equiv _ _ x) (WithLp.equiv _ _ y) :=\n  rfl\n\n"}
{"name":"EuclideanSpace.inner_piLp_equiv_symm","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : Fintype Î¹\nx y : Î¹ â†’ ğ•œ\nâŠ¢ Eq (Inner.inner ((WithLp.equiv 2 (Î¹ â†’ ğ•œ)).symm x) ((WithLp.equiv 2 (Î¹ â†’ ğ•œ)).symm y)) (dotProduct (Star.star x) y)","decl":"theorem EuclideanSpace.inner_piLp_equiv_symm (x y : Î¹ â†’ ğ•œ) :\n    âŸª(WithLp.equiv 2 _).symm x, (WithLp.equiv 2 _).symm yâŸ« = dotProduct (star x) y :=\n  rfl\n\n"}
{"name":"DirectSum.IsInternal.isometryL2OfOrthogonalFamily_symm_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœâ´ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : Fintype Î¹\ninstâœ : DecidableEq Î¹\nV : Î¹ â†’ Submodule ğ•œ E\nhV : DirectSum.IsInternal V\nhV' : OrthogonalFamily ğ•œ (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeâ‚—áµ¢\nw : PiLp 2 fun i => Subtype fun x => Membership.mem (V i) x\nâŠ¢ Eq ((hV.isometryL2OfOrthogonalFamily hV').symm w) (Finset.univ.sum fun i => â†‘(w i))","decl":"@[simp]\ntheorem DirectSum.IsInternal.isometryL2OfOrthogonalFamily_symm_apply [DecidableEq Î¹]\n    {V : Î¹ â†’ Submodule ğ•œ E} (hV : DirectSum.IsInternal V)\n    (hV' : OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢) (w : PiLp 2 fun i => V i) :\n    (hV.isometryL2OfOrthogonalFamily hV').symm w = âˆ‘ i, (w i : E) := by\n  classical\n    let eâ‚ := DirectSum.linearEquivFunOnFintype ğ•œ Î¹ fun i => V i\n    let eâ‚‚ := LinearEquiv.ofBijective (DirectSum.coeLinearMap V) hV\n    suffices âˆ€ v : â¨ i, V i, eâ‚‚ v = âˆ‘ i, eâ‚ v i by exact this (eâ‚.symm w)\n    intro v\n    -- Porting note: added `DFinsupp.lsum`\n    simp [eâ‚, eâ‚‚, DirectSum.coeLinearMap, DirectSum.toModule, DFinsupp.lsum,\n      DFinsupp.sumAddHom_apply]\n\n"}
{"name":"WithLp.equiv_single","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : DecidableEq Î¹\ni : Î¹\na : ğ•œ\nâŠ¢ Eq ((WithLp.equiv 2 ((i : Î¹) â†’ (fun x => ğ•œ) i)) (EuclideanSpace.single i a)) (Pi.single i a)","decl":"@[simp]\ntheorem WithLp.equiv_single (i : Î¹) (a : ğ•œ) :\n    WithLp.equiv _ _ (EuclideanSpace.single i a) = Pi.single i a :=\n  rfl\n\n"}
{"name":"WithLp.equiv_symm_single","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : DecidableEq Î¹\ni : Î¹\na : ğ•œ\nâŠ¢ Eq ((WithLp.equiv 2 (Î¹ â†’ ğ•œ)).symm (Pi.single i a)) (EuclideanSpace.single i a)","decl":"@[simp]\ntheorem WithLp.equiv_symm_single (i : Î¹) (a : ğ•œ) :\n    (WithLp.equiv _ _).symm (Pi.single i a) = EuclideanSpace.single i a :=\n  rfl\n\n"}
{"name":"EuclideanSpace.single_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : DecidableEq Î¹\ni : Î¹\na : ğ•œ\nj : Î¹\nâŠ¢ Eq (EuclideanSpace.single i a j) (ite (Eq j i) a 0)","decl":"@[simp]\ntheorem EuclideanSpace.single_apply (i : Î¹) (a : ğ•œ) (j : Î¹) :\n    (EuclideanSpace.single i a) j = ite (j = i) a 0 := by\n  rw [EuclideanSpace.single, WithLp.equiv_symm_pi_apply, â† Pi.single_apply i a j]\n\n"}
{"name":"EuclideanSpace.inner_single_left","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\ni : Î¹\na : ğ•œ\nv : EuclideanSpace ğ•œ Î¹\nâŠ¢ Eq (Inner.inner (EuclideanSpace.single i a) v) (HMul.hMul ((starRingEnd ğ•œ) a) (v i))","decl":"theorem EuclideanSpace.inner_single_left (i : Î¹) (a : ğ•œ) (v : EuclideanSpace ğ•œ Î¹) :\n    âŸªEuclideanSpace.single i (a : ğ•œ), vâŸ« = conj a * v i := by simp [apply_ite conj]\n\n"}
{"name":"EuclideanSpace.inner_single_right","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\ni : Î¹\na : ğ•œ\nv : EuclideanSpace ğ•œ Î¹\nâŠ¢ Eq (Inner.inner v (EuclideanSpace.single i a)) (HMul.hMul a ((starRingEnd ((fun x => ğ•œ) i)) (v i)))","decl":"theorem EuclideanSpace.inner_single_right (i : Î¹) (a : ğ•œ) (v : EuclideanSpace ğ•œ Î¹) :\n    âŸªv, EuclideanSpace.single i (a : ğ•œ)âŸ« = a * conj (v i) := by simp [apply_ite conj, mul_comm]\n\n"}
{"name":"EuclideanSpace.norm_single","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\ni : Î¹\na : ğ•œ\nâŠ¢ Eq (Norm.norm (EuclideanSpace.single i a)) (Norm.norm a)","decl":"@[simp]\ntheorem EuclideanSpace.norm_single (i : Î¹) (a : ğ•œ) :\n    â€–EuclideanSpace.single i (a : ğ•œ)â€– = â€–aâ€– :=\n  PiLp.norm_equiv_symm_single 2 (fun _ => ğ•œ) i a\n\n"}
{"name":"EuclideanSpace.nnnorm_single","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\ni : Î¹\na : ğ•œ\nâŠ¢ Eq (NNNorm.nnnorm (EuclideanSpace.single i a)) (NNNorm.nnnorm a)","decl":"@[simp]\ntheorem EuclideanSpace.nnnorm_single (i : Î¹) (a : ğ•œ) :\n    â€–EuclideanSpace.single i (a : ğ•œ)â€–â‚Š = â€–aâ€–â‚Š :=\n  PiLp.nnnorm_equiv_symm_single 2 (fun _ => ğ•œ) i a\n\n"}
{"name":"EuclideanSpace.dist_single_same","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\ni : Î¹\na b : ğ•œ\nâŠ¢ Eq (Dist.dist (EuclideanSpace.single i a) (EuclideanSpace.single i b)) (Dist.dist a b)","decl":"@[simp]\ntheorem EuclideanSpace.dist_single_same (i : Î¹) (a b : ğ•œ) :\n    dist (EuclideanSpace.single i (a : ğ•œ)) (EuclideanSpace.single i (b : ğ•œ)) = dist a b :=\n  PiLp.dist_equiv_symm_single_same 2 (fun _ => ğ•œ) i a b\n\n"}
{"name":"EuclideanSpace.nndist_single_same","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\ni : Î¹\na b : ğ•œ\nâŠ¢ Eq (NNDist.nndist (EuclideanSpace.single i a) (EuclideanSpace.single i b)) (NNDist.nndist a b)","decl":"@[simp]\ntheorem EuclideanSpace.nndist_single_same (i : Î¹) (a b : ğ•œ) :\n    nndist (EuclideanSpace.single i (a : ğ•œ)) (EuclideanSpace.single i (b : ğ•œ)) = nndist a b :=\n  PiLp.nndist_equiv_symm_single_same 2 (fun _ => ğ•œ) i a b\n\n"}
{"name":"EuclideanSpace.edist_single_same","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\ni : Î¹\na b : ğ•œ\nâŠ¢ Eq (EDist.edist (EuclideanSpace.single i a) (EuclideanSpace.single i b)) (EDist.edist a b)","decl":"@[simp]\ntheorem EuclideanSpace.edist_single_same (i : Î¹) (a b : ğ•œ) :\n    edist (EuclideanSpace.single i (a : ğ•œ)) (EuclideanSpace.single i (b : ğ•œ)) = edist a b :=\n  PiLp.edist_equiv_symm_single_same 2 (fun _ => ğ•œ) i a b\n\n"}
{"name":"EuclideanSpace.orthonormal_single","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\nâŠ¢ Orthonormal ğ•œ fun i => EuclideanSpace.single i 1","decl":"/-- `EuclideanSpace.single` forms an orthonormal family. -/\ntheorem EuclideanSpace.orthonormal_single :\n    Orthonormal ğ•œ fun i : Î¹ => EuclideanSpace.single i (1 : ğ•œ) := by\n  simp_rw [orthonormal_iff_ite, EuclideanSpace.inner_single_left, map_one, one_mul,\n    EuclideanSpace.single_apply]\n  intros\n  trivial\n\n"}
{"name":"EuclideanSpace.piLpCongrLeft_single","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : DecidableEq Î¹\ninstâœÂ² : Fintype Î¹\nÎ¹' : Type u_7\ninstâœÂ¹ : Fintype Î¹'\ninstâœ : DecidableEq Î¹'\ne : Equiv Î¹' Î¹\ni' : Î¹'\nv : ğ•œ\nâŠ¢ Eq ((LinearIsometryEquiv.piLpCongrLeft 2 ğ•œ ğ•œ e) (EuclideanSpace.single i' v)) (EuclideanSpace.single (e i') v)","decl":"theorem EuclideanSpace.piLpCongrLeft_single\n    {Î¹' : Type*} [Fintype Î¹'] [DecidableEq Î¹'] (e : Î¹' â‰ƒ Î¹) (i' : Î¹') (v : ğ•œ) :\n    LinearIsometryEquiv.piLpCongrLeft 2 ğ•œ ğ•œ e (EuclideanSpace.single i' v) =\n      EuclideanSpace.single (e i') v :=\n  LinearIsometryEquiv.piLpCongrLeft_single e i' _\n\n"}
{"name":"OrthonormalBasis.ofRepr.inj","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : Fintype Î¹\nreprâœ repr : LinearIsometryEquiv (RingHom.id ğ•œ) E (EuclideanSpace ğ•œ Î¹)\nxâœ : Eq { repr := reprâœ } { repr := repr }\nâŠ¢ Eq reprâœ repr","decl":"/-- An orthonormal basis on E is an identification of `E` with its dimensional-matching\n`EuclideanSpace ğ•œ Î¹`. -/\nstructure OrthonormalBasis where ofRepr ::\n  /-- Linear isometry between `E` and `EuclideanSpace ğ•œ Î¹` representing the orthonormal basis. -/\n  repr : E â‰ƒâ‚—áµ¢[ğ•œ] EuclideanSpace ğ•œ Î¹\n\n"}
{"name":"OrthonormalBasis.ofRepr.injEq","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : Fintype Î¹\nreprâœ repr : LinearIsometryEquiv (RingHom.id ğ•œ) E (EuclideanSpace ğ•œ Î¹)\nâŠ¢ Eq (Eq { repr := reprâœ } { repr := repr }) (Eq reprâœ repr)","decl":"/-- An orthonormal basis on E is an identification of `E` with its dimensional-matching\n`EuclideanSpace ğ•œ Î¹`. -/\nstructure OrthonormalBasis where ofRepr ::\n  /-- Linear isometry between `E` and `EuclideanSpace ğ•œ Î¹` representing the orthonormal basis. -/\n  repr : E â‰ƒâ‚—áµ¢[ğ•œ] EuclideanSpace ğ•œ Î¹\n\n"}
{"name":"OrthonormalBasis.ofRepr.sizeOf_spec","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœâ¶ : RCLike ğ•œ\nE : Type u_4\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : InnerProductSpace ğ•œ E\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : SizeOf Î¹\ninstâœÂ¹ : SizeOf ğ•œ\ninstâœ : SizeOf E\nrepr : LinearIsometryEquiv (RingHom.id ğ•œ) E (EuclideanSpace ğ•œ Î¹)\nâŠ¢ Eq (SizeOf.sizeOf { repr := repr }) (HAdd.hAdd 1 (SizeOf.sizeOf repr))","decl":"/-- An orthonormal basis on E is an identification of `E` with its dimensional-matching\n`EuclideanSpace ğ•œ Î¹`. -/\nstructure OrthonormalBasis where ofRepr ::\n  /-- Linear isometry between `E` and `EuclideanSpace ğ•œ Î¹` representing the orthonormal basis. -/\n  repr : E â‰ƒâ‚—áµ¢[ğ•œ] EuclideanSpace ğ•œ Î¹\n\n"}
{"name":"OrthonormalBasis.repr_injective","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : Fintype Î¹\nâŠ¢ Function.Injective OrthonormalBasis.repr","decl":"theorem repr_injective :\n    Injective (repr : OrthonormalBasis Î¹ ğ•œ E â†’ E â‰ƒâ‚—áµ¢[ğ•œ] EuclideanSpace ğ•œ Î¹) := fun f g h => by\n  cases f\n  cases g\n  congr\n\n"}
{"name":"OrthonormalBasis.coe_ofRepr","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœâ´ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : Fintype Î¹\ninstâœ : DecidableEq Î¹\ne : LinearIsometryEquiv (RingHom.id ğ•œ) E (EuclideanSpace ğ•œ Î¹)\nâŠ¢ Eq â‡‘{ repr := e } fun i => e.symm (EuclideanSpace.single i 1)","decl":"@[simp]\ntheorem coe_ofRepr [DecidableEq Î¹] (e : E â‰ƒâ‚—áµ¢[ğ•œ] EuclideanSpace ğ•œ Î¹) :\n    â‡‘(OrthonormalBasis.ofRepr e) = fun i => e.symm (EuclideanSpace.single i (1 : ğ•œ)) := by\n  -- Porting note: simplified with `congr!`\n  dsimp only [DFunLike.coe]\n  funext\n  congr!\n\n"}
{"name":"OrthonormalBasis.repr_symm_single","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœâ´ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : Fintype Î¹\ninstâœ : DecidableEq Î¹\nb : OrthonormalBasis Î¹ ğ•œ E\ni : Î¹\nâŠ¢ Eq (b.repr.symm (EuclideanSpace.single i 1)) (b i)","decl":"@[simp]\nprotected theorem repr_symm_single [DecidableEq Î¹] (b : OrthonormalBasis Î¹ ğ•œ E) (i : Î¹) :\n    b.repr.symm (EuclideanSpace.single i (1 : ğ•œ)) = b i := by\n  -- Porting note: simplified with `congr!`\n  dsimp only [DFunLike.coe]\n  congr!\n\n"}
{"name":"OrthonormalBasis.repr_self","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœâ´ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : Fintype Î¹\ninstâœ : DecidableEq Î¹\nb : OrthonormalBasis Î¹ ğ•œ E\ni : Î¹\nâŠ¢ Eq (b.repr (b i)) (EuclideanSpace.single i 1)","decl":"@[simp]\nprotected theorem repr_self [DecidableEq Î¹] (b : OrthonormalBasis Î¹ ğ•œ E) (i : Î¹) :\n    b.repr (b i) = EuclideanSpace.single i (1 : ğ•œ) := by\n  rw [â† b.repr_symm_single i, LinearIsometryEquiv.apply_symm_apply]\n\n"}
{"name":"OrthonormalBasis.repr_apply_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : Fintype Î¹\nb : OrthonormalBasis Î¹ ğ•œ E\nv : E\ni : Î¹\nâŠ¢ Eq (b.repr v i) (Inner.inner (b i) v)","decl":"protected theorem repr_apply_apply (b : OrthonormalBasis Î¹ ğ•œ E) (v : E) (i : Î¹) :\n    b.repr v i = âŸªb i, vâŸ« := by\n  classical\n    rw [â† b.repr.inner_map_map (b i) v, b.repr_self i, EuclideanSpace.inner_single_left]\n    simp only [one_mul, eq_self_iff_true, map_one]\n\n"}
{"name":"OrthonormalBasis.orthonormal","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : Fintype Î¹\nb : OrthonormalBasis Î¹ ğ•œ E\nâŠ¢ Orthonormal ğ•œ â‡‘b","decl":"@[simp]\nprotected theorem orthonormal (b : OrthonormalBasis Î¹ ğ•œ E) : Orthonormal ğ•œ b := by\n  classical\n    rw [orthonormal_iff_ite]\n    intro i j\n    rw [â† b.repr.inner_map_map (b i) (b j), b.repr_self i, b.repr_self j,\n      EuclideanSpace.inner_single_left, EuclideanSpace.single_apply, map_one, one_mul]\n\n"}
{"name":"OrthonormalBasis.coe_toBasis","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : Fintype Î¹\nb : OrthonormalBasis Î¹ ğ•œ E\nâŠ¢ Eq â‡‘b.toBasis â‡‘b","decl":"@[simp]\nprotected theorem coe_toBasis (b : OrthonormalBasis Î¹ ğ•œ E) : (â‡‘b.toBasis : Î¹ â†’ E) = â‡‘b := by\n  rw [OrthonormalBasis.toBasis] -- Porting note: was `change`\n  ext j\n  classical\n    rw [Basis.coe_ofEquivFun]\n    congr\n\n"}
{"name":"OrthonormalBasis.coe_toBasis_repr","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : Fintype Î¹\nb : OrthonormalBasis Î¹ ğ•œ E\nâŠ¢ Eq b.toBasis.equivFun b.repr.toLinearEquiv","decl":"@[simp]\nprotected theorem coe_toBasis_repr (b : OrthonormalBasis Î¹ ğ•œ E) :\n    b.toBasis.equivFun = b.repr.toLinearEquiv :=\n  Basis.equivFun_ofEquivFun _\n\n"}
{"name":"OrthonormalBasis.coe_toBasis_repr_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : Fintype Î¹\nb : OrthonormalBasis Î¹ ğ•œ E\nx : E\ni : Î¹\nâŠ¢ Eq ((b.toBasis.repr x) i) (b.repr x i)","decl":"@[simp]\nprotected theorem coe_toBasis_repr_apply (b : OrthonormalBasis Î¹ ğ•œ E) (x : E) (i : Î¹) :\n    b.toBasis.repr x i = b.repr x i := by\n  rw [â† Basis.equivFun_apply, OrthonormalBasis.coe_toBasis_repr]\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [LinearIsometryEquiv.coe_toLinearEquiv]\n\n"}
{"name":"OrthonormalBasis.sum_repr","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : Fintype Î¹\nb : OrthonormalBasis Î¹ ğ•œ E\nx : E\nâŠ¢ Eq (Finset.univ.sum fun i => HSMul.hSMul (b.repr x i) (b i)) x","decl":"protected theorem sum_repr (b : OrthonormalBasis Î¹ ğ•œ E) (x : E) : âˆ‘ i, b.repr x i â€¢ b i = x := by\n  simp_rw [â† b.coe_toBasis_repr_apply, â† b.coe_toBasis]\n  exact b.toBasis.sum_repr x\n\n"}
{"name":"OrthonormalBasis.sum_repr'","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : Fintype Î¹\nb : OrthonormalBasis Î¹ ğ•œ E\nx : E\nâŠ¢ Eq (Finset.univ.sum fun i => HSMul.hSMul (Inner.inner (b i) x) (b i)) x","decl":"open scoped InnerProductSpace in\nprotected theorem sum_repr' (b : OrthonormalBasis Î¹ ğ•œ E) (x : E) : âˆ‘ i, âŸªb i, xâŸ«_ğ•œ â€¢ b i = x := by\n  nth_rw 2 [â† (b.sum_repr x)]\n  simp_rw [b.repr_apply_apply x]\n\n"}
{"name":"OrthonormalBasis.sum_repr_symm","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : Fintype Î¹\nb : OrthonormalBasis Î¹ ğ•œ E\nv : EuclideanSpace ğ•œ Î¹\nâŠ¢ Eq (Finset.univ.sum fun i => HSMul.hSMul (v i) (b i)) (b.repr.symm v)","decl":"protected theorem sum_repr_symm (b : OrthonormalBasis Î¹ ğ•œ E) (v : EuclideanSpace ğ•œ Î¹) :\n    âˆ‘ i, v i â€¢ b i = b.repr.symm v := by simpa using (b.toBasis.equivFun_symm_apply v).symm\n\n"}
{"name":"OrthonormalBasis.sum_inner_mul_inner","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : Fintype Î¹\nb : OrthonormalBasis Î¹ ğ•œ E\nx y : E\nâŠ¢ Eq (Finset.univ.sum fun i => HMul.hMul (Inner.inner x (b i)) (Inner.inner (b i) y)) (Inner.inner x y)","decl":"protected theorem sum_inner_mul_inner (b : OrthonormalBasis Î¹ ğ•œ E) (x y : E) :\n    âˆ‘ i, âŸªx, b iâŸ« * âŸªb i, yâŸ« = âŸªx, yâŸ« := by\n  have := congr_arg (innerSL ğ•œ x) (b.sum_repr y)\n  rw [map_sum] at this\n  convert this\n  rw [map_smul, b.repr_apply_apply, mul_comm]\n  simp only [innerSL_apply, smul_eq_mul] -- Porting note: was `rfl`\n\n"}
{"name":"OrthonormalBasis.orthogonalProjection_eq_sum","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœâ´ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : Fintype Î¹\nU : Submodule ğ•œ E\ninstâœ : CompleteSpace (Subtype fun x => Membership.mem U x)\nb : OrthonormalBasis Î¹ ğ•œ (Subtype fun x => Membership.mem U x)\nx : E\nâŠ¢ Eq ((orthogonalProjection U) x) (Finset.univ.sum fun i => HSMul.hSMul (Inner.inner (â†‘(b i)) x) (b i))","decl":"protected theorem orthogonalProjection_eq_sum {U : Submodule ğ•œ E} [CompleteSpace U]\n    (b : OrthonormalBasis Î¹ ğ•œ U) (x : E) :\n    orthogonalProjection U x = âˆ‘ i, âŸª(b i : E), xâŸ« â€¢ b i := by\n  simpa only [b.repr_apply_apply, inner_orthogonalProjection_eq_of_mem_left] using\n    (b.sum_repr (orthogonalProjection U x)).symm\n\n"}
{"name":"OrthonormalBasis.map_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœâµ : RCLike ğ•œ\nE : Type u_4\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : Fintype Î¹\nG : Type u_7\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : InnerProductSpace ğ•œ G\nb : OrthonormalBasis Î¹ ğ•œ E\nL : LinearIsometryEquiv (RingHom.id ğ•œ) E G\ni : Î¹\nâŠ¢ Eq ((b.map L) i) (L (b i))","decl":"@[simp]\nprotected theorem map_apply {G : Type*} [NormedAddCommGroup G] [InnerProductSpace ğ•œ G]\n    (b : OrthonormalBasis Î¹ ğ•œ E) (L : E â‰ƒâ‚—áµ¢[ğ•œ] G) (i : Î¹) : b.map L i = L (b i) :=\n  rfl\n\n"}
{"name":"OrthonormalBasis.toBasis_map","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœâµ : RCLike ğ•œ\nE : Type u_4\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : Fintype Î¹\nG : Type u_7\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : InnerProductSpace ğ•œ G\nb : OrthonormalBasis Î¹ ğ•œ E\nL : LinearIsometryEquiv (RingHom.id ğ•œ) E G\nâŠ¢ Eq (b.map L).toBasis (b.toBasis.map L.toLinearEquiv)","decl":"@[simp]\nprotected theorem toBasis_map {G : Type*} [NormedAddCommGroup G] [InnerProductSpace ğ•œ G]\n    (b : OrthonormalBasis Î¹ ğ•œ E) (L : E â‰ƒâ‚—áµ¢[ğ•œ] G) :\n    (b.map L).toBasis = b.toBasis.map L.toLinearEquiv :=\n  rfl\n\n"}
{"name":"Basis.coe_toOrthonormalBasis_repr","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : Fintype Î¹\nv : Basis Î¹ ğ•œ E\nhv : Orthonormal ğ•œ â‡‘v\nâŠ¢ Eq â‡‘(v.toOrthonormalBasis hv).repr â‡‘v.equivFun","decl":"@[simp]\ntheorem _root_.Basis.coe_toOrthonormalBasis_repr (v : Basis Î¹ ğ•œ E) (hv : Orthonormal ğ•œ v) :\n    ((v.toOrthonormalBasis hv).repr : E â†’ EuclideanSpace ğ•œ Î¹) = v.equivFun :=\n  rfl\n\n"}
{"name":"Basis.coe_toOrthonormalBasis_repr_symm","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : Fintype Î¹\nv : Basis Î¹ ğ•œ E\nhv : Orthonormal ğ•œ â‡‘v\nâŠ¢ Eq â‡‘(v.toOrthonormalBasis hv).repr.symm â‡‘v.equivFun.symm","decl":"@[simp]\ntheorem _root_.Basis.coe_toOrthonormalBasis_repr_symm (v : Basis Î¹ ğ•œ E) (hv : Orthonormal ğ•œ v) :\n    ((v.toOrthonormalBasis hv).repr.symm : EuclideanSpace ğ•œ Î¹ â†’ E) = v.equivFun.symm :=\n  rfl\n\n"}
{"name":"Basis.toBasis_toOrthonormalBasis","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : Fintype Î¹\nv : Basis Î¹ ğ•œ E\nhv : Orthonormal ğ•œ â‡‘v\nâŠ¢ Eq (v.toOrthonormalBasis hv).toBasis v","decl":"@[simp]\ntheorem _root_.Basis.toBasis_toOrthonormalBasis (v : Basis Î¹ ğ•œ E) (hv : Orthonormal ğ•œ v) :\n    (v.toOrthonormalBasis hv).toBasis = v := by\n  simp [Basis.toOrthonormalBasis, OrthonormalBasis.toBasis]\n\n"}
{"name":"Basis.coe_toOrthonormalBasis","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : Fintype Î¹\nv : Basis Î¹ ğ•œ E\nhv : Orthonormal ğ•œ â‡‘v\nâŠ¢ Eq â‡‘(v.toOrthonormalBasis hv) â‡‘v","decl":"@[simp]\ntheorem _root_.Basis.coe_toOrthonormalBasis (v : Basis Î¹ ğ•œ E) (hv : Orthonormal ğ•œ v) :\n    (v.toOrthonormalBasis hv : Î¹ â†’ E) = (v : Î¹ â†’ E) :=\n  calc\n    (v.toOrthonormalBasis hv : Î¹ â†’ E) = ((v.toOrthonormalBasis hv).toBasis : Î¹ â†’ E) := by\n      classical rw [OrthonormalBasis.coe_toBasis]\n    _ = (v : Î¹ â†’ E) := by simp\n\n"}
{"name":"Pi.orthonormalBasis.toBasis","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î· : Type u_7\ninstâœâ´ : Fintype Î·\nÎ¹ : Î· â†’ Type u_8\ninstâœÂ³ : (i : Î·) â†’ Fintype (Î¹ i)\nğ•œ : Type u_9\ninstâœÂ² : RCLike ğ•œ\nE : Î· â†’ Type u_10\ninstâœÂ¹ : (i : Î·) â†’ NormedAddCommGroup (E i)\ninstâœ : (i : Î·) â†’ InnerProductSpace ğ•œ (E i)\nB : (i : Î·) â†’ OrthonormalBasis (Î¹ i) ğ•œ (E i)\nâŠ¢ Eq (Pi.orthonormalBasis B).toBasis ((Pi.basis fun i => (B i).toBasis).map (WithLp.linearEquiv 2 ğ•œ ((j : Î·) â†’ E j)).symm)","decl":"theorem _root_.Pi.orthonormalBasis.toBasis {Î· : Type*} [Fintype Î·] {Î¹ : Î· â†’ Type*}\n    [âˆ€ i, Fintype (Î¹ i)] {ğ•œ : Type*} [RCLike ğ•œ] {E : Î· â†’ Type*} [âˆ€ i, NormedAddCommGroup (E i)]\n    [âˆ€ i, InnerProductSpace ğ•œ (E i)] (B : âˆ€ i, OrthonormalBasis (Î¹ i) ğ•œ (E i)) :\n    (Pi.orthonormalBasis B).toBasis =\n      ((Pi.basis fun i : Î· â†¦ (B i).toBasis).map (WithLp.linearEquiv 2 _ _).symm) := by ext; rfl\n\n"}
{"name":"Pi.orthonormalBasis_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î· : Type u_7\ninstâœâµ : Fintype Î·\ninstâœâ´ : DecidableEq Î·\nÎ¹ : Î· â†’ Type u_8\ninstâœÂ³ : (i : Î·) â†’ Fintype (Î¹ i)\nğ•œ : Type u_9\ninstâœÂ² : RCLike ğ•œ\nE : Î· â†’ Type u_10\ninstâœÂ¹ : (i : Î·) â†’ NormedAddCommGroup (E i)\ninstâœ : (i : Î·) â†’ InnerProductSpace ğ•œ (E i)\nB : (i : Î·) â†’ OrthonormalBasis (Î¹ i) ğ•œ (E i)\nj : Sigma fun i => Î¹ i\nâŠ¢ Eq ((Pi.orthonormalBasis B) j) ((WithLp.equiv 2 ((j : Î·) â†’ E j)).symm (Pi.single j.fst ((B j.fst) j.snd)))","decl":"@[simp]\ntheorem _root_.Pi.orthonormalBasis_apply {Î· : Type*} [Fintype Î·] [DecidableEq Î·] {Î¹ : Î· â†’ Type*}\n    [âˆ€ i, Fintype (Î¹ i)] {ğ•œ : Type*} [RCLike ğ•œ] {E : Î· â†’ Type*} [âˆ€ i, NormedAddCommGroup (E i)]\n    [âˆ€ i, InnerProductSpace ğ•œ (E i)] (B : âˆ€ i, OrthonormalBasis (Î¹ i) ğ•œ (E i))\n    (j : (i : Î·) Ã— (Î¹ i)) :\n    Pi.orthonormalBasis B j = (WithLp.equiv _ _).symm (Pi.single _ (B j.fst j.snd)) := by\n  classical\n  ext k\n  obtain âŸ¨i, jâŸ© := j\n  simp only [Pi.orthonormalBasis, coe_ofRepr, LinearIsometryEquiv.symm_trans,\n    LinearIsometryEquiv.symm_symm, LinearIsometryEquiv.piLpCongrRight_symm,\n    LinearIsometryEquiv.trans_apply, LinearIsometryEquiv.piLpCongrRight_apply,\n    LinearIsometryEquiv.piLpCurry_apply, WithLp.equiv_single, WithLp.equiv_symm_pi_apply,\n    Sigma.curry_single (Î³ := fun _ _ => ğ•œ)]\n  obtain rfl | hi := Decidable.eq_or_ne i k\n  Â· simp only [Pi.single_eq_same, WithLp.equiv_symm_single, OrthonormalBasis.repr_symm_single]\n  Â· simp only [Pi.single_eq_of_ne' hi, WithLp.equiv_symm_zero, _root_.map_zero]\n\n"}
{"name":"Pi.orthonormalBasis_repr","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î· : Type u_7\ninstâœâ´ : Fintype Î·\nÎ¹ : Î· â†’ Type u_8\ninstâœÂ³ : (i : Î·) â†’ Fintype (Î¹ i)\nğ•œ : Type u_9\ninstâœÂ² : RCLike ğ•œ\nE : Î· â†’ Type u_10\ninstâœÂ¹ : (i : Î·) â†’ NormedAddCommGroup (E i)\ninstâœ : (i : Î·) â†’ InnerProductSpace ğ•œ (E i)\nB : (i : Î·) â†’ OrthonormalBasis (Î¹ i) ğ•œ (E i)\nx : (i : Î·) â†’ E i\nj : Sigma fun i => Î¹ i\nâŠ¢ Eq ((Pi.orthonormalBasis B).repr x j) ((B j.fst).repr (x j.fst) j.snd)","decl":"@[simp]\ntheorem _root_.Pi.orthonormalBasis_repr {Î· : Type*} [Fintype Î·] {Î¹ : Î· â†’ Type*}\n    [âˆ€ i, Fintype (Î¹ i)] {ğ•œ : Type*} [RCLike ğ•œ] {E : Î· â†’ Type*} [âˆ€ i, NormedAddCommGroup (E i)]\n    [âˆ€ i, InnerProductSpace ğ•œ (E i)] (B : âˆ€ i, OrthonormalBasis (Î¹ i) ğ•œ (E i)) (x : (i : Î· ) â†’ E i)\n    (j : (i : Î·) Ã— (Î¹ i)) :\n    (Pi.orthonormalBasis B).repr x j = (B j.fst).repr (x j.fst) j.snd := rfl\n\n"}
{"name":"OrthonormalBasis.coe_mk","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : Fintype Î¹\nv : Î¹ â†’ E\nhon : Orthonormal ğ•œ v\nhsp : LE.le Top.top (Submodule.span ğ•œ (Set.range v))\nâŠ¢ Eq (â‡‘(OrthonormalBasis.mk hon hsp)) v","decl":"@[simp]\nprotected theorem coe_mk (hon : Orthonormal ğ•œ v) (hsp : âŠ¤ â‰¤ Submodule.span ğ•œ (Set.range v)) :\n    â‡‘(OrthonormalBasis.mk hon hsp) = v := by\n  classical rw [OrthonormalBasis.mk, _root_.Basis.coe_toOrthonormalBasis, Basis.coe_mk]\n\n"}
{"name":"OrthonormalBasis.span_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹' : Type u_2\nğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : DecidableEq E\nv' : Î¹' â†’ E\nh : Orthonormal ğ•œ v'\ns : Finset Î¹'\ni : Subtype fun x => Membership.mem s x\nâŠ¢ Eq (â†‘((OrthonormalBasis.span h s) i)) (v' â†‘i)","decl":"@[simp]\nprotected theorem span_apply [DecidableEq E] {v' : Î¹' â†’ E} (h : Orthonormal ğ•œ v') (s : Finset Î¹')\n    (i : s) : (OrthonormalBasis.span h s i : E) = v' i := by\n  simp only [OrthonormalBasis.span, Basis.span_apply, LinearIsometryEquiv.ofEq_symm,\n    OrthonormalBasis.map_apply, OrthonormalBasis.coe_mk, LinearIsometryEquiv.coe_ofEq_apply,\n    comp_apply]\n\n"}
{"name":"OrthonormalBasis.coe_of_orthogonal_eq_bot_mk","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : Fintype Î¹\nv : Î¹ â†’ E\nhon : Orthonormal ğ•œ v\nhsp : Eq (Submodule.span ğ•œ (Set.range v)).orthogonal Bot.bot\nâŠ¢ Eq (â‡‘(OrthonormalBasis.mkOfOrthogonalEqBot hon hsp)) v","decl":"@[simp]\nprotected theorem coe_of_orthogonal_eq_bot_mk (hon : Orthonormal ğ•œ v)\n    (hsp : (span ğ•œ (Set.range v))á—® = âŠ¥) : â‡‘(OrthonormalBasis.mkOfOrthogonalEqBot hon hsp) = v :=\n  OrthonormalBasis.coe_mk hon _\n\n"}
{"name":"OrthonormalBasis.reindex_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nğ•œ : Type u_3\ninstâœâ´ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : Fintype Î¹\ninstâœ : Fintype Î¹'\nb : OrthonormalBasis Î¹ ğ•œ E\ne : Equiv Î¹ Î¹'\ni' : Î¹'\nâŠ¢ Eq ((b.reindex e) i') (b (e.symm i'))","decl":"protected theorem reindex_apply (b : OrthonormalBasis Î¹ ğ•œ E) (e : Î¹ â‰ƒ Î¹') (i' : Î¹') :\n    (b.reindex e) i' = b (e.symm i') := by\n  classical\n    dsimp [reindex]\n    rw [coe_ofRepr]\n    dsimp\n    rw [â† b.repr_symm_single, LinearIsometryEquiv.piLpCongrLeft_symm,\n      EuclideanSpace.piLpCongrLeft_single]\n\n"}
{"name":"OrthonormalBasis.reindex_toBasis","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nğ•œ : Type u_3\ninstâœâ´ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : Fintype Î¹\ninstâœ : Fintype Î¹'\nb : OrthonormalBasis Î¹ ğ•œ E\ne : Equiv Î¹ Î¹'\nâŠ¢ Eq (b.reindex e).toBasis (b.toBasis.reindex e)","decl":"@[simp]\ntheorem reindex_toBasis (b : OrthonormalBasis Î¹ ğ•œ E) (e : Î¹ â‰ƒ Î¹') :\n    (b.reindex e).toBasis = b.toBasis.reindex e := Basis.eq_ofRepr_eq_repr fun _ â†¦ congr_fun rfl\n\n"}
{"name":"OrthonormalBasis.coe_reindex","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nğ•œ : Type u_3\ninstâœâ´ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : Fintype Î¹\ninstâœ : Fintype Î¹'\nb : OrthonormalBasis Î¹ ğ•œ E\ne : Equiv Î¹ Î¹'\nâŠ¢ Eq (â‡‘(b.reindex e)) (Function.comp â‡‘b â‡‘e.symm)","decl":"@[simp]\nprotected theorem coe_reindex (b : OrthonormalBasis Î¹ ğ•œ E) (e : Î¹ â‰ƒ Î¹') :\n    â‡‘(b.reindex e) = b âˆ˜ e.symm :=\n  funext (b.reindex_apply e)\n\n"}
{"name":"OrthonormalBasis.repr_reindex","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nğ•œ : Type u_3\ninstâœâ´ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : Fintype Î¹\ninstâœ : Fintype Î¹'\nb : OrthonormalBasis Î¹ ğ•œ E\ne : Equiv Î¹ Î¹'\nx : E\ni' : Î¹'\nâŠ¢ Eq ((b.reindex e).repr x i') (b.repr x (e.symm i'))","decl":"@[simp]\nprotected theorem repr_reindex (b : OrthonormalBasis Î¹ ğ•œ E) (e : Î¹ â‰ƒ Î¹') (x : E) (i' : Î¹') :\n    (b.reindex e).repr x i' = b.repr x (e.symm i') := by\n  classical\n  rw [OrthonormalBasis.repr_apply_apply, b.repr_apply_apply, OrthonormalBasis.coe_reindex,\n    comp_apply]\n\n"}
{"name":"EuclideanSpace.basisFun_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : Fintype Î¹\ninstâœ : DecidableEq Î¹\ni : Î¹\nâŠ¢ Eq ((EuclideanSpace.basisFun Î¹ ğ•œ) i) (EuclideanSpace.single i 1)","decl":"@[simp]\ntheorem basisFun_apply [DecidableEq Î¹] (i : Î¹) : basisFun Î¹ ğ•œ i = EuclideanSpace.single i 1 :=\n  PiLp.basisFun_apply _ _ _ _\n\n"}
{"name":"EuclideanSpace.basisFun_repr","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : Fintype Î¹\nx : EuclideanSpace ğ•œ Î¹\ni : Î¹\nâŠ¢ Eq ((EuclideanSpace.basisFun Î¹ ğ•œ).repr x i) (x i)","decl":"@[simp]\ntheorem basisFun_repr (x : EuclideanSpace ğ•œ Î¹) (i : Î¹) : (basisFun Î¹ ğ•œ).repr x i = x i := rfl\n\n"}
{"name":"EuclideanSpace.basisFun_toBasis","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : Fintype Î¹\nâŠ¢ Eq (EuclideanSpace.basisFun Î¹ ğ•œ).toBasis (PiLp.basisFun 2 ğ•œ Î¹)","decl":"theorem basisFun_toBasis : (basisFun Î¹ ğ•œ).toBasis = PiLp.basisFun _ ğ•œ Î¹ := rfl\n\n"}
{"name":"Complex.orthonormalBasisOneI_repr_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"z : Complex\nâŠ¢ Eq (Complex.orthonormalBasisOneI.repr z) (Matrix.vecCons z.re (Matrix.vecCons z.im Matrix.vecEmpty))","decl":"@[simp]\ntheorem Complex.orthonormalBasisOneI_repr_apply (z : â„‚) :\n    Complex.orthonormalBasisOneI.repr z = ![z.re, z.im] :=\n  rfl\n\n"}
{"name":"Complex.orthonormalBasisOneI_repr_symm_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"x : EuclideanSpace Real (Fin 2)\nâŠ¢ Eq (Complex.orthonormalBasisOneI.repr.symm x) (HAdd.hAdd (â†‘(x 0)) (HMul.hMul (â†‘(x 1)) Complex.I))","decl":"@[simp]\ntheorem Complex.orthonormalBasisOneI_repr_symm_apply (x : EuclideanSpace â„ (Fin 2)) :\n    Complex.orthonormalBasisOneI.repr.symm x = x 0 + x 1 * I :=\n  rfl\n\n"}
{"name":"Complex.toBasis_orthonormalBasisOneI","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"âŠ¢ Eq Complex.orthonormalBasisOneI.toBasis Complex.basisOneI","decl":"@[simp]\ntheorem Complex.toBasis_orthonormalBasisOneI :\n    Complex.orthonormalBasisOneI.toBasis = Complex.basisOneI :=\n  Basis.toBasis_toOrthonormalBasis _ _\n\n"}
{"name":"Complex.coe_orthonormalBasisOneI","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"âŠ¢ Eq (â‡‘Complex.orthonormalBasisOneI) (Matrix.vecCons 1 (Matrix.vecCons Complex.I Matrix.vecEmpty))","decl":"@[simp]\ntheorem Complex.coe_orthonormalBasisOneI :\n    (Complex.orthonormalBasisOneI : Fin 2 â†’ â„‚) = ![1, I] := by\n  simp [Complex.orthonormalBasisOneI]\n\n"}
{"name":"Complex.map_isometryOfOrthonormal","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"F : Type u_5\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : InnerProductSpace Real F\nF' : Type u_6\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : InnerProductSpace Real F'\nv : OrthonormalBasis (Fin 2) Real F\nf : LinearIsometryEquiv (RingHom.id Real) F F'\nâŠ¢ Eq (Complex.isometryOfOrthonormal (v.map f)) ((Complex.isometryOfOrthonormal v).trans f)","decl":"@[simp]\ntheorem Complex.map_isometryOfOrthonormal (v : OrthonormalBasis (Fin 2) â„ F) (f : F â‰ƒâ‚—áµ¢[â„] F') :\n    Complex.isometryOfOrthonormal (v.map f) = (Complex.isometryOfOrthonormal v).trans f := by\n  simp only [isometryOfOrthonormal, OrthonormalBasis.map, LinearIsometryEquiv.symm_trans,\n    LinearIsometryEquiv.symm_symm]\n  -- Porting note: `LinearIsometryEquiv.trans_assoc` doesn't trigger in the `simp` above\n  rw [LinearIsometryEquiv.trans_assoc]\n\n"}
{"name":"Complex.isometryOfOrthonormal_symm_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"F : Type u_5\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nv : OrthonormalBasis (Fin 2) Real F\nf : F\nâŠ¢ Eq ((Complex.isometryOfOrthonormal v).symm f) (HAdd.hAdd (â†‘((v.toBasis.coord 0) f)) (HMul.hMul (â†‘((v.toBasis.coord 1) f)) Complex.I))","decl":"theorem Complex.isometryOfOrthonormal_symm_apply (v : OrthonormalBasis (Fin 2) â„ F) (f : F) :\n    (Complex.isometryOfOrthonormal v).symm f =\n      (v.toBasis.coord 0 f : â„‚) + (v.toBasis.coord 1 f : â„‚) * I := by\n  simp [Complex.isometryOfOrthonormal]\n\n"}
{"name":"Complex.isometryOfOrthonormal_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"F : Type u_5\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nv : OrthonormalBasis (Fin 2) Real F\nz : Complex\nâŠ¢ Eq ((Complex.isometryOfOrthonormal v) z) (HAdd.hAdd (HSMul.hSMul z.re (v 0)) (HSMul.hSMul z.im (v 1)))","decl":"theorem Complex.isometryOfOrthonormal_apply (v : OrthonormalBasis (Fin 2) â„ F) (z : â„‚) :\n    Complex.isometryOfOrthonormal v z = z.re â€¢ v 0 + z.im â€¢ v 1 := by\n  -- Porting note: was\n  -- simp [Complex.isometryOfOrthonormal, â† v.sum_repr_symm]\n  rw [Complex.isometryOfOrthonormal, LinearIsometryEquiv.trans_apply]\n  simp [â† v.sum_repr_symm]\n\n"}
{"name":"OrthonormalBasis.toMatrix_orthonormalBasis_conjTranspose_mul_self","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nğ•œ : Type u_3\ninstâœâµ : RCLike ğ•œ\nE : Type u_4\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹'\na : OrthonormalBasis Î¹' ğ•œ E\nb : OrthonormalBasis Î¹ ğ•œ E\nâŠ¢ Eq (HMul.hMul (a.toBasis.toMatrix â‡‘b).conjTranspose (a.toBasis.toMatrix â‡‘b)) 1","decl":"/-- A version of `OrthonormalBasis.toMatrix_orthonormalBasis_mem_unitary` that works for bases with\ndifferent index types. -/\n@[simp]\ntheorem OrthonormalBasis.toMatrix_orthonormalBasis_conjTranspose_mul_self [Fintype Î¹']\n    (a : OrthonormalBasis Î¹' ğ•œ E) (b : OrthonormalBasis Î¹ ğ•œ E) :\n    (a.toBasis.toMatrix b)á´´ * a.toBasis.toMatrix b = 1 := by\n  ext i j\n  convert a.repr.inner_map_map (b i) (b j)\n  rw [orthonormal_iff_ite.mp b.orthonormal i j]\n  rfl\n\n"}
{"name":"OrthonormalBasis.toMatrix_orthonormalBasis_self_mul_conjTranspose","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nğ•œ : Type u_3\ninstâœâµ : RCLike ğ•œ\nE : Type u_4\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹'\na : OrthonormalBasis Î¹ ğ•œ E\nb : OrthonormalBasis Î¹' ğ•œ E\nâŠ¢ Eq (HMul.hMul (a.toBasis.toMatrix â‡‘b) (a.toBasis.toMatrix â‡‘b).conjTranspose) 1","decl":"/-- A version of `OrthonormalBasis.toMatrix_orthonormalBasis_mem_unitary` that works for bases with\ndifferent index types. -/\n@[simp]\ntheorem OrthonormalBasis.toMatrix_orthonormalBasis_self_mul_conjTranspose [Fintype Î¹']\n    (a : OrthonormalBasis Î¹ ğ•œ E) (b : OrthonormalBasis Î¹' ğ•œ E) :\n    a.toBasis.toMatrix b * (a.toBasis.toMatrix b)á´´ = 1 := by\n  classical\n  rw [Matrix.mul_eq_one_comm_of_equiv (a.toBasis.indexEquiv b.toBasis),\n    a.toMatrix_orthonormalBasis_conjTranspose_mul_self b]\n\n"}
{"name":"OrthonormalBasis.toMatrix_orthonormalBasis_mem_unitary","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœâ´ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : Fintype Î¹\ninstâœ : DecidableEq Î¹\na b : OrthonormalBasis Î¹ ğ•œ E\nâŠ¢ Membership.mem (Matrix.unitaryGroup Î¹ ğ•œ) (a.toBasis.toMatrix â‡‘b)","decl":"/-- The change-of-basis matrix between two orthonormal bases `a`, `b` is a unitary matrix. -/\ntheorem OrthonormalBasis.toMatrix_orthonormalBasis_mem_unitary :\n    a.toBasis.toMatrix b âˆˆ Matrix.unitaryGroup Î¹ ğ•œ := by\n  rw [Matrix.mem_unitaryGroup_iff']\n  exact a.toMatrix_orthonormalBasis_conjTranspose_mul_self b\n\n"}
{"name":"OrthonormalBasis.det_to_matrix_orthonormalBasis","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœâ´ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : Fintype Î¹\ninstâœ : DecidableEq Î¹\na b : OrthonormalBasis Î¹ ğ•œ E\nâŠ¢ Eq (Norm.norm (a.toBasis.det â‡‘b)) 1","decl":"/-- The determinant of the change-of-basis matrix between two orthonormal bases `a`, `b` has\nunit length. -/\n@[simp]\ntheorem OrthonormalBasis.det_to_matrix_orthonormalBasis : â€–a.toBasis.det bâ€– = 1 := by\n  have := (Matrix.det_of_mem_unitary (a.toMatrix_orthonormalBasis_mem_unitary b)).2\n  rw [star_def, RCLike.mul_conj] at this\n  norm_cast at this\n  rwa [pow_eq_one_iff_of_nonneg (norm_nonneg _) two_ne_zero] at this\n\n"}
{"name":"OrthonormalBasis.toMatrix_orthonormalBasis_mem_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nF : Type u_5\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : InnerProductSpace Real F\ninstâœÂ¹ : Fintype Î¹\ninstâœ : DecidableEq Î¹\na b : OrthonormalBasis Î¹ Real F\nâŠ¢ Membership.mem (Matrix.orthogonalGroup Î¹ Real) (a.toBasis.toMatrix â‡‘b)","decl":"/-- The change-of-basis matrix between two orthonormal bases `a`, `b` is an orthogonal matrix. -/\ntheorem OrthonormalBasis.toMatrix_orthonormalBasis_mem_orthogonal :\n    a.toBasis.toMatrix b âˆˆ Matrix.orthogonalGroup Î¹ â„ :=\n  a.toMatrix_orthonormalBasis_mem_unitary b\n\n"}
{"name":"OrthonormalBasis.det_to_matrix_orthonormalBasis_real","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nF : Type u_5\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : InnerProductSpace Real F\ninstâœÂ¹ : Fintype Î¹\ninstâœ : DecidableEq Î¹\na b : OrthonormalBasis Î¹ Real F\nâŠ¢ Or (Eq (a.toBasis.det â‡‘b) 1) (Eq (a.toBasis.det â‡‘b) (-1))","decl":"/-- The determinant of the change-of-basis matrix between two orthonormal bases `a`, `b` is Â±1. -/\ntheorem OrthonormalBasis.det_to_matrix_orthonormalBasis_real :\n    a.toBasis.det b = 1 âˆ¨ a.toBasis.det b = -1 := by\n  rw [â† sq_eq_one_iff]\n  simpa [unitary, sq] using Matrix.det_of_mem_unitary (a.toMatrix_orthonormalBasis_mem_unitary b)\n\n"}
{"name":"DirectSum.IsInternal.collectedOrthonormalBasis_mem","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœâµ : RCLike ğ•œ\nE : Type u_4\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : Fintype Î¹\nA : Î¹ â†’ Submodule ğ•œ E\ninstâœÂ¹ : DecidableEq Î¹\nh : DirectSum.IsInternal A\nÎ± : Î¹ â†’ Type u_7\ninstâœ : (i : Î¹) â†’ Fintype (Î± i)\nhV : OrthogonalFamily ğ•œ (fun i => Subtype fun x => Membership.mem (A i) x) fun i => (A i).subtypeâ‚—áµ¢\nv : (i : Î¹) â†’ OrthonormalBasis (Î± i) ğ•œ (Subtype fun x => Membership.mem (A i) x)\na : Sigma fun i => Î± i\nâŠ¢ Membership.mem (A a.fst) ((DirectSum.IsInternal.collectedOrthonormalBasis hV h v) a)","decl":"theorem DirectSum.IsInternal.collectedOrthonormalBasis_mem [DecidableEq Î¹]\n    (h : DirectSum.IsInternal A) {Î± : Î¹ â†’ Type*} [âˆ€ i, Fintype (Î± i)]\n    (hV : OrthogonalFamily ğ•œ (fun i => A i) fun i => (A i).subtypeâ‚—áµ¢)\n    (v : âˆ€ i, OrthonormalBasis (Î± i) ğ•œ (A i)) (a : Î£i, Î± i) :\n    h.collectedOrthonormalBasis hV v a âˆˆ A a.1 := by\n  simp [DirectSum.IsInternal.collectedOrthonormalBasis]\n\n"}
{"name":"Orthonormal.exists_orthonormalBasis_extension","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nv : Set E\ninstâœ : FiniteDimensional ğ•œ E\nhv : Orthonormal ğ•œ Subtype.val\nâŠ¢ Exists fun u => Exists fun b => And (HasSubset.Subset v â†‘u) (Eq (â‡‘b) Subtype.val)","decl":"/-- In a finite-dimensional `InnerProductSpace`, any orthonormal subset can be extended to an\northonormal basis. -/\ntheorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal ğ•œ ((â†‘) : v â†’ E)) :\n    âˆƒ (u : Finset E) (b : OrthonormalBasis u ğ•œ E), v âŠ† u âˆ§ â‡‘b = ((â†‘) : u â†’ E) := by\n  obtain âŸ¨uâ‚€, huâ‚€s, huâ‚€, huâ‚€_maxâŸ© := exists_maximal_orthonormal hv\n  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot huâ‚€] at huâ‚€_max\n  have huâ‚€_finite : uâ‚€.Finite := huâ‚€.linearIndependent.setFinite\n  let u : Finset E := huâ‚€_finite.toFinset\n  let fu : â†¥u â‰ƒ â†¥uâ‚€ := huâ‚€_finite.subtypeEquivToFinset.symm\n  have hu : Orthonormal ğ•œ ((â†‘) : u â†’ E) := by simpa using huâ‚€.comp _ fu.injective\n  refine âŸ¨u, OrthonormalBasis.mkOfOrthogonalEqBot hu ?_, ?_, ?_âŸ©\n  Â· simpa [u] using huâ‚€_max\n  Â· simpa [u] using huâ‚€s\n  Â· simp\n\n"}
{"name":"Orthonormal.exists_orthonormalBasis_extension_of_card_eq","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ğ•œ : Type u_3\ninstâœâ´ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : FiniteDimensional ğ•œ E\nÎ¹ : Type u_7\ninstâœ : Fintype Î¹\ncard_Î¹ : Eq (Module.finrank ğ•œ E) (Fintype.card Î¹)\nv : Î¹ â†’ E\ns : Set Î¹\nhv : Orthonormal ğ•œ (s.restrict v)\nâŠ¢ Exists fun b => âˆ€ (i : Î¹), Membership.mem s i â†’ Eq (b i) (v i)","decl":"theorem Orthonormal.exists_orthonormalBasis_extension_of_card_eq {Î¹ : Type*} [Fintype Î¹]\n    (card_Î¹ : finrank ğ•œ E = Fintype.card Î¹) {v : Î¹ â†’ E} {s : Set Î¹}\n    (hv : Orthonormal ğ•œ (s.restrict v)) : âˆƒ b : OrthonormalBasis Î¹ ğ•œ E, âˆ€ i âˆˆ s, b i = v i := by\n  have hsv : Injective (s.restrict v) := hv.linearIndependent.injective\n  have hX : Orthonormal ğ•œ ((â†‘) : Set.range (s.restrict v) â†’ E) := by\n    rwa [orthonormal_subtype_range hsv]\n  obtain âŸ¨Y, bâ‚€, hX, hbâ‚€âŸ© := hX.exists_orthonormalBasis_extension\n  have hÎ¹Y : Fintype.card Î¹ = Y.card := by\n    refine card_Î¹.symm.trans ?_\n    exact Module.finrank_eq_card_finset_basis bâ‚€.toBasis\n  have hvsY : s.MapsTo v Y := (s.mapsTo_image v).mono_right (by rwa [â† range_restrict])\n  have hsv' : Set.InjOn v s := by\n    rw [Set.injOn_iff_injective]\n    exact hsv\n  obtain âŸ¨g, hgâŸ© := hvsY.exists_equiv_extend_of_card_eq hÎ¹Y hsv'\n  use bâ‚€.reindex g.symm\n  intro i hi\n  simp [hbâ‚€, hg i hi]\n\n"}
{"name":"exists_orthonormalBasis","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\nâŠ¢ Exists fun w => Exists fun b => Eq (â‡‘b) Subtype.val","decl":"/-- A finite-dimensional inner product space admits an orthonormal basis. -/\ntheorem _root_.exists_orthonormalBasis :\n    âˆƒ (w : Finset E) (b : OrthonormalBasis w ğ•œ E), â‡‘b = ((â†‘) : w â†’ E) :=\n  let âŸ¨w, hw, _, hw''âŸ© := (orthonormal_empty ğ•œ E).exists_orthonormalBasis_extension\n  âŸ¨w, hw, hw''âŸ©\n\n"}
{"name":"stdOrthonormalBasis_def","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ğ•œ : Type u_7\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_8\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\nâŠ¢ Eq (stdOrthonormalBasis ğ•œ E)\n    (let b := Classical.choose â‹¯;\n    â‹¯.mpr (b.reindex (Fintype.equivFinOfCardEq â‹¯)))","decl":"/-- A finite-dimensional `InnerProductSpace` has an orthonormal basis. -/\nirreducible_def stdOrthonormalBasis : OrthonormalBasis (Fin (finrank ğ•œ E)) ğ•œ E := by\n  let b := Classical.choose (Classical.choose_spec <| exists_orthonormalBasis ğ•œ E)\n  rw [finrank_eq_card_basis b.toBasis]\n  exact b.reindex (Fintype.equivFinOfCardEq rfl)\n\n"}
{"name":"orthonormalBasis_one_dim","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\ninstâœ : Fintype Î¹\nb : OrthonormalBasis Î¹ Real Real\nâŠ¢ Or (Eq â‡‘b fun x => 1) (Eq â‡‘b fun x => -1)","decl":"/-- An orthonormal basis of `â„` is made either of the vector `1`, or of the vector `-1`. -/\ntheorem orthonormalBasis_one_dim (b : OrthonormalBasis Î¹ â„ â„) :\n    (â‡‘b = fun _ => (1 : â„)) âˆ¨ â‡‘b = fun _ => (-1 : â„) := by\n  have : Unique Î¹ := b.toBasis.unique\n  have : b default = 1 âˆ¨ b default = -1 := by\n    have : â€–b defaultâ€– = 1 := b.orthonormal.1 _\n    rwa [Real.norm_eq_abs, abs_eq (zero_le_one' â„)] at this\n  rw [eq_const_of_unique b]\n  refine this.imp ?_ ?_ <;> (intro; ext; simp [*])\n\n"}
{"name":"DirectSum.IsInternal.sigmaOrthonormalBasisIndexEquiv_def","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_7\nğ•œ : Type u_8\ninstâœâµ : RCLike ğ•œ\nE : Type u_9\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : FiniteDimensional ğ•œ E\nn : Nat\nhn : Eq (Module.finrank ğ•œ E) n\ninstâœ : DecidableEq Î¹\nV : Î¹ â†’ Submodule ğ•œ E\nhV : DirectSum.IsInternal V\nhV' : OrthogonalFamily ğ•œ (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeâ‚—áµ¢\nâŠ¢ Eq (DirectSum.IsInternal.sigmaOrthonormalBasisIndexEquiv hn hV hV')\n    (let b := DirectSum.IsInternal.collectedOrthonormalBasis hV' hV fun i => stdOrthonormalBasis ğ•œ (Subtype fun x => Membership.mem (V i) x);\n    Fintype.equivFinOfCardEq â‹¯)","decl":"/-- Exhibit a bijection between `Fin n` and the index set of a certain basis of an `n`-dimensional\ninner product space `E`.  This should not be accessed directly, but only via the subsequent API. -/\nirreducible_def DirectSum.IsInternal.sigmaOrthonormalBasisIndexEquiv\n    (hV' : OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢) :\n    (Î£i, Fin (finrank ğ•œ (V i))) â‰ƒ Fin n :=\n  let b := hV.collectedOrthonormalBasis hV' fun i => stdOrthonormalBasis ğ•œ (V i)\n  Fintype.equivFinOfCardEq <| (Module.finrank_eq_card_basis b.toBasis).symm.trans hn\n\n"}
{"name":"DirectSum.IsInternal.subordinateOrthonormalBasis_def","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_7\nğ•œ : Type u_8\ninstâœâµ : RCLike ğ•œ\nE : Type u_9\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : FiniteDimensional ğ•œ E\nn : Nat\nhn : Eq (Module.finrank ğ•œ E) n\ninstâœ : DecidableEq Î¹\nV : Î¹ â†’ Submodule ğ•œ E\nhV : DirectSum.IsInternal V\nhV' : OrthogonalFamily ğ•œ (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeâ‚—áµ¢\nâŠ¢ Eq (DirectSum.IsInternal.subordinateOrthonormalBasis hn hV hV') ((DirectSum.IsInternal.collectedOrthonormalBasis hV' hV fun i => stdOrthonormalBasis ğ•œ (Subtype fun x => Membership.mem (V i) x)).reindex (DirectSum.IsInternal.sigmaOrthonormalBasisIndexEquiv hn hV hV'))","decl":"/-- An `n`-dimensional `InnerProductSpace` equipped with a decomposition as an internal direct\nsum has an orthonormal basis indexed by `Fin n` and subordinate to that direct sum. -/\nirreducible_def DirectSum.IsInternal.subordinateOrthonormalBasis\n    (hV' : OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢) :\n    OrthonormalBasis (Fin n) ğ•œ E :=\n  (hV.collectedOrthonormalBasis hV' fun i => stdOrthonormalBasis ğ•œ (V i)).reindex\n    (hV.sigmaOrthonormalBasisIndexEquiv hn hV')\n\n"}
{"name":"DirectSum.IsInternal.subordinateOrthonormalBasisIndex_def","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_7\nğ•œ : Type u_8\ninstâœâµ : RCLike ğ•œ\nE : Type u_9\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : FiniteDimensional ğ•œ E\nn : Nat\nhn : Eq (Module.finrank ğ•œ E) n\ninstâœ : DecidableEq Î¹\nV : Î¹ â†’ Submodule ğ•œ E\nhV : DirectSum.IsInternal V\na : Fin n\nhV' : OrthogonalFamily ğ•œ (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeâ‚—áµ¢\nâŠ¢ Eq (DirectSum.IsInternal.subordinateOrthonormalBasisIndex hn hV a hV') ((DirectSum.IsInternal.sigmaOrthonormalBasisIndexEquiv hn hV hV').symm a).fst","decl":"/-- An `n`-dimensional `InnerProductSpace` equipped with a decomposition as an internal direct\nsum has an orthonormal basis indexed by `Fin n` and subordinate to that direct sum. This function\nprovides the mapping by which it is subordinate. -/\nirreducible_def DirectSum.IsInternal.subordinateOrthonormalBasisIndex (a : Fin n)\n    (hV' : OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢) : Î¹ :=\n  ((hV.sigmaOrthonormalBasisIndexEquiv hn hV').symm a).1\n\n"}
{"name":"DirectSum.IsInternal.subordinateOrthonormalBasis_subordinate","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_3\ninstâœâµ : RCLike ğ•œ\nE : Type u_4\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : FiniteDimensional ğ•œ E\nn : Nat\nhn : Eq (Module.finrank ğ•œ E) n\ninstâœ : DecidableEq Î¹\nV : Î¹ â†’ Submodule ğ•œ E\nhV : DirectSum.IsInternal V\na : Fin n\nhV' : OrthogonalFamily ğ•œ (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeâ‚—áµ¢\nâŠ¢ Membership.mem (V (DirectSum.IsInternal.subordinateOrthonormalBasisIndex hn hV a hV')) ((DirectSum.IsInternal.subordinateOrthonormalBasis hn hV hV') a)","decl":"/-- The basis constructed in `DirectSum.IsInternal.subordinateOrthonormalBasis` is subordinate to\nthe `OrthogonalFamily` in question. -/\ntheorem DirectSum.IsInternal.subordinateOrthonormalBasis_subordinate (a : Fin n)\n    (hV' : OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢) :\n    hV.subordinateOrthonormalBasis hn hV' a âˆˆ V (hV.subordinateOrthonormalBasisIndex hn a hV') := by\n  simpa only [DirectSum.IsInternal.subordinateOrthonormalBasis, OrthonormalBasis.coe_reindex,\n    DirectSum.IsInternal.subordinateOrthonormalBasisIndex] using\n    hV.collectedOrthonormalBasis_mem hV' (fun i => stdOrthonormalBasis ğ•œ (V i))\n      ((hV.sigmaOrthonormalBasisIndexEquiv hn hV').symm a)\n\n"}
{"name":"LinearIsometry.extend_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nV : Type u_7\ninstâœÂ² : NormedAddCommGroup V\ninstâœÂ¹ : InnerProductSpace ğ•œ V\ninstâœ : FiniteDimensional ğ•œ V\nS : Submodule ğ•œ V\nL : LinearIsometry (RingHom.id ğ•œ) (Subtype fun x => Membership.mem S x) V\ns : Subtype fun x => Membership.mem S x\nâŠ¢ Eq (L.extend â†‘s) (L s)","decl":"theorem LinearIsometry.extend_apply (L : S â†’â‚—áµ¢[ğ•œ] V) (s : S) : L.extend s = L s := by\n  haveI : CompleteSpace S := FiniteDimensional.complete ğ•œ S\n  simp only [LinearIsometry.extend, â† LinearIsometry.coe_toLinearMap]\n  simp only [add_right_eq_self, LinearIsometry.coe_toLinearMap,\n    LinearIsometryEquiv.coe_toLinearIsometry, LinearIsometry.coe_comp, Function.comp_apply,\n    orthogonalProjection_mem_subspace_eq_self, LinearMap.coe_comp, ContinuousLinearMap.coe_coe,\n    Submodule.coe_subtype, LinearMap.add_apply, Submodule.coe_eq_zero,\n    LinearIsometryEquiv.map_eq_zero_iff, Submodule.coe_subtypeâ‚—áµ¢,\n    orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero, Submodule.orthogonal_orthogonal,\n    Submodule.coe_mem]\n\n"}
{"name":"Matrix.toEuclideanLin_piLp_equiv_symm","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ğ•œ : Type u_3\ninstâœÂ² : RCLike ğ•œ\nm : Type u_7\nn : Type u_8\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix m n ğ•œ\nx : n â†’ ğ•œ\nâŠ¢ Eq ((Matrix.toEuclideanLin A) ((WithLp.equiv 2 ((i : n) â†’ (fun x => ğ•œ) i)).symm x)) ((WithLp.equiv 2 (m â†’ ğ•œ)).symm ((Matrix.toLin' A) x))","decl":"@[simp]\ntheorem toEuclideanLin_piLp_equiv_symm (A : Matrix m n ğ•œ) (x : n â†’ ğ•œ) :\n    Matrix.toEuclideanLin A ((WithLp.equiv _ _).symm x) =\n      (WithLp.equiv _ _).symm (Matrix.toLin' A x) :=\n  rfl\n\n"}
{"name":"Matrix.piLp_equiv_toEuclideanLin","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ğ•œ : Type u_3\ninstâœÂ² : RCLike ğ•œ\nm : Type u_7\nn : Type u_8\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix m n ğ•œ\nx : EuclideanSpace ğ•œ n\nâŠ¢ Eq ((WithLp.equiv 2 ((i : m) â†’ (fun x => ğ•œ) i)) ((Matrix.toEuclideanLin A) x)) ((Matrix.toLin' A) ((WithLp.equiv 2 (n â†’ ğ•œ)) x))","decl":"@[simp]\ntheorem piLp_equiv_toEuclideanLin (A : Matrix m n ğ•œ) (x : EuclideanSpace ğ•œ n) :\n    WithLp.equiv _ _ (Matrix.toEuclideanLin A x) = Matrix.toLin' A (WithLp.equiv _ _ x) :=\n  rfl\n\n"}
{"name":"Matrix.toEuclideanLin_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ğ•œ : Type u_3\ninstâœÂ² : RCLike ğ•œ\nm : Type u_7\nn : Type u_8\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nM : Matrix m n ğ•œ\nv : EuclideanSpace ğ•œ n\nâŠ¢ Eq ((Matrix.toEuclideanLin M) v) ((WithLp.equiv 2 (m â†’ ğ•œ)).symm (M.mulVec ((WithLp.equiv 2 (n â†’ ğ•œ)) v)))","decl":"theorem toEuclideanLin_apply (M : Matrix m n ğ•œ) (v : EuclideanSpace ğ•œ n) :\n    toEuclideanLin M v = (WithLp.equiv 2 (m â†’ ğ•œ)).symm (M *áµ¥ (WithLp.equiv 2 (n â†’ ğ•œ)) v) :=\n  rfl\n\n"}
{"name":"Matrix.piLp_equiv_toEuclideanLin_apply","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ğ•œ : Type u_3\ninstâœÂ² : RCLike ğ•œ\nm : Type u_7\nn : Type u_8\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nM : Matrix m n ğ•œ\nv : EuclideanSpace ğ•œ n\nâŠ¢ Eq ((WithLp.equiv 2 (m â†’ ğ•œ)) ((Matrix.toEuclideanLin M) v)) (M.mulVec ((WithLp.equiv 2 (n â†’ ğ•œ)) v))","decl":"@[simp]\ntheorem piLp_equiv_toEuclideanLin_apply (M : Matrix m n ğ•œ) (v : EuclideanSpace ğ•œ n) :\n    WithLp.equiv 2 (m â†’ ğ•œ) (toEuclideanLin M v) = M *áµ¥ WithLp.equiv 2 (n â†’ ğ•œ) v :=\n  rfl\n\n"}
{"name":"Matrix.toEuclideanLin_apply_piLp_equiv_symm","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ğ•œ : Type u_3\ninstâœÂ² : RCLike ğ•œ\nm : Type u_7\nn : Type u_8\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nM : Matrix m n ğ•œ\nv : n â†’ ğ•œ\nâŠ¢ Eq ((Matrix.toEuclideanLin M) ((WithLp.equiv 2 (n â†’ ğ•œ)).symm v)) ((WithLp.equiv 2 (m â†’ ğ•œ)).symm (M.mulVec v))","decl":"@[simp]\ntheorem toEuclideanLin_apply_piLp_equiv_symm (M : Matrix m n ğ•œ) (v : n â†’ ğ•œ) :\n    toEuclideanLin M ((WithLp.equiv 2 (nâ†’ ğ•œ)).symm v) = (WithLp.equiv 2 (m â†’ ğ•œ)).symm (M *áµ¥ v) :=\n  rfl\n\n-- `Matrix.toEuclideanLin` is the same as `Matrix.toLin` applied to `PiLp.basisFun`,\n"}
{"name":"Matrix.toEuclideanLin_eq_toLin","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nm : Type u_7\nn : Type u_8\ninstâœÂ² : Fintype n\ninstâœÂ¹ : DecidableEq n\ninstâœ : Finite m\nâŠ¢ Eq Matrix.toEuclideanLin (Matrix.toLin (PiLp.basisFun 2 ğ•œ n) (PiLp.basisFun 2 ğ•œ m))","decl":"theorem toEuclideanLin_eq_toLin [Finite m] :\n    (toEuclideanLin : Matrix m n ğ•œ â‰ƒâ‚—[ğ•œ] _) =\n      Matrix.toLin (PiLp.basisFun _ _ _) (PiLp.basisFun _ _ _) :=\n  rfl\n\n"}
{"name":"Matrix.toEuclideanLin_eq_toLin_orthonormal","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nm : Type u_7\nn : Type u_8\ninstâœÂ² : Fintype n\ninstâœÂ¹ : DecidableEq n\ninstâœ : Fintype m\nâŠ¢ Eq Matrix.toEuclideanLin (Matrix.toLin (EuclideanSpace.basisFun n ğ•œ).toBasis (EuclideanSpace.basisFun m ğ•œ).toBasis)","decl":"open EuclideanSpace in\nlemma toEuclideanLin_eq_toLin_orthonormal [Fintype m] :\n    toEuclideanLin = toLin (basisFun n ğ•œ).toBasis (basisFun m ğ•œ).toBasis :=\n  rfl\n\n"}
{"name":"inner_matrix_row_row","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ğ•œ : Type u_3\ninstâœÂ¹ : RCLike ğ•œ\nm : Type u_7\nn : Type u_8\ninstâœ : Fintype n\nA B : Matrix m n ğ•œ\ni j : m\nâŠ¢ Eq (Inner.inner ((WithLp.equiv 2 (n â†’ ğ•œ)).symm (A i)) ((WithLp.equiv 2 (n â†’ ğ•œ)).symm (B j))) (HMul.hMul B A.conjTranspose j i)","decl":"/-- The inner product of a row of `A` and a row of `B` is an entry of `B * Aá´´`. -/\ntheorem inner_matrix_row_row [Fintype n] (A B : Matrix m n ğ•œ) (i j : m) :\n    âŸªA i, B jâŸ«â‚‘ = (B * Aá´´) j i := by\n  simp_rw [EuclideanSpace.inner_piLp_equiv_symm, Matrix.mul_apply', dotProduct_comm,\n    Matrix.conjTranspose_apply, Pi.star_def]\n\n"}
{"name":"inner_matrix_col_col","module":"Mathlib.Analysis.InnerProductSpace.PiL2","initialProofState":"ğ•œ : Type u_3\ninstâœÂ¹ : RCLike ğ•œ\nm : Type u_7\nn : Type u_8\ninstâœ : Fintype m\nA B : Matrix m n ğ•œ\ni j : n\nâŠ¢ Eq (Inner.inner ((WithLp.equiv 2 (m â†’ ğ•œ)).symm (A.transpose i)) ((WithLp.equiv 2 (m â†’ ğ•œ)).symm (B.transpose j))) (HMul.hMul A.conjTranspose B i j)","decl":"/-- The inner product of a column of `A` and a column of `B` is an entry of `Aá´´ * B`. -/\ntheorem inner_matrix_col_col [Fintype m] (A B : Matrix m n ğ•œ) (i j : n) :\n    âŸªAáµ€ i, Báµ€ jâŸ«â‚‘ = (Aá´´ * B) i j :=\n  rfl\n\n"}
