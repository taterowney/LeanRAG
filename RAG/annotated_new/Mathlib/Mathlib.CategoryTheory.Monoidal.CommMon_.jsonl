{"name":"CommMon_.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\ntoMon_‚úù : Mon_ C\nmul_comm‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding toMon_‚úù.X toMon_‚úù.X).hom toMon_‚úù.mul) toMon_‚úù.mul) _auto‚úù\ntoMon_ : Mon_ C\nmul_comm : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding toMon_.X toMon_.X).hom toMon_.mul) toMon_.mul) _auto‚úù\n‚ä¢ Eq (Eq { toMon_ := toMon_‚úù, mul_comm := mul_comm‚úù } { toMon_ := toMon_, mul_comm := mul_comm }) (Eq toMon_‚úù toMon_)","decl":"/-- A commutative monoid object internal to a monoidal category.\n-/\nstructure CommMon_ extends Mon_ C where\n  mul_comm : (Œ≤_ _ _).hom ‚â´ mul = mul := by aesop_cat\n\n"}
{"name":"CommMon_.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\ntoMon_‚úù : Mon_ C\nmul_comm‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding toMon_‚úù.X toMon_‚úù.X).hom toMon_‚úù.mul) toMon_‚úù.mul) _auto‚úù\ntoMon_ : Mon_ C\nmul_comm : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding toMon_.X toMon_.X).hom toMon_.mul) toMon_.mul) _auto‚úù\nx‚úù : Eq { toMon_ := toMon_‚úù, mul_comm := mul_comm‚úù } { toMon_ := toMon_, mul_comm := mul_comm }\n‚ä¢ Eq toMon_‚úù toMon_","decl":"/-- A commutative monoid object internal to a monoidal category.\n-/\nstructure CommMon_ extends Mon_ C where\n  mul_comm : (Œ≤_ _ _).hom ‚â´ mul = mul := by aesop_cat\n\n"}
{"name":"CommMon_.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\ninst‚úù¬π : CategoryTheory.BraidedCategory C\ninst‚úù : SizeOf C\ntoMon_ : Mon_ C\nmul_comm : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding toMon_.X toMon_.X).hom toMon_.mul) toMon_.mul) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { toMon_ := toMon_, mul_comm := mul_comm }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toMon_)) (SizeOf.sizeOf mul_comm))","decl":"/-- A commutative monoid object internal to a monoidal category.\n-/\nstructure CommMon_ extends Mon_ C where\n  mul_comm : (Œ≤_ _ _).hom ‚â´ mul = mul := by aesop_cat\n\n"}
{"name":"CommMon_.mul_comm","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nself : CommMon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding self.X self.X).hom self.mul) self.mul","decl":"/-- A commutative monoid object internal to a monoidal category.\n-/\nstructure CommMon_ extends Mon_ C where\n  mul_comm : (Œ≤_ _ _).hom ‚â´ mul = mul := by aesop_cat\n\n"}
{"name":"CommMon_.mul_comm_assoc","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nself : CommMon_ C\nZ : C\nh : Quiver.Hom self.X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding self.X self.X).hom (CategoryTheory.CategoryStruct.comp self.mul h)) (CategoryTheory.CategoryStruct.comp self.mul h)","decl":"attribute [reassoc (attr := simp)] CommMon_.mul_comm\n\n"}
{"name":"CommMon_.trivial_one","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq (CommMon_.trivial C).one (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"/-- The trivial commutative monoid object. We later show this is initial in `CommMon_ C`.\n-/\n@[simps!]\ndef trivial : CommMon_ C :=\n  { Mon_.trivial C with mul_comm := by dsimp; rw [braiding_leftUnitor, unitors_equal] }\n\n"}
{"name":"CommMon_.trivial_X","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq (CommMon_.trivial C).X CategoryTheory.MonoidalCategoryStruct.tensorUnit","decl":"/-- The trivial commutative monoid object. We later show this is initial in `CommMon_ C`.\n-/\n@[simps!]\ndef trivial : CommMon_ C :=\n  { Mon_.trivial C with mul_comm := by dsimp; rw [braiding_leftUnitor, unitors_equal] }\n\n"}
{"name":"CommMon_.trivial_mul","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq (CommMon_.trivial C).mul (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom","decl":"/-- The trivial commutative monoid object. We later show this is initial in `CommMon_ C`.\n-/\n@[simps!]\ndef trivial : CommMon_ C :=\n  { Mon_.trivial C with mul_comm := by dsimp; rw [braiding_leftUnitor, unitors_equal] }\n\n"}
{"name":"CommMon_.id_hom","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : CommMon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id A).hom (CategoryTheory.CategoryStruct.id A.X)","decl":"@[simp]\ntheorem id_hom (A : CommMon_ C) : Mon_.Hom.hom (ùüô A) = ùüô A.X :=\n  rfl\n\n"}
{"name":"CommMon_.comp_hom","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nR S T : CommMon_ C\nf : Quiver.Hom R S\ng : Quiver.Hom S T\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"@[simp]\ntheorem comp_hom {R S T : CommMon_ C} (f : R ‚ü∂ S) (g : S ‚ü∂ T) :\n    Mon_.Hom.hom (f ‚â´ g) = f.hom ‚â´ g.hom :=\n  rfl\n\n"}
{"name":"CommMon_.hom_ext","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA B : CommMon_ C\nf g : Quiver.Hom A B\nh : Eq f.hom g.hom\n‚ä¢ Eq f g","decl":"@[ext]\nlemma hom_ext {A B : CommMon_ C} (f g : A ‚ü∂ B) (h : f.hom = g.hom) : f = g :=\n  Mon_.Hom.ext h\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10688): the following two lemmas `id'` and `comp'`\n-- have been added to ease automation;\n"}
{"name":"CommMon_.hom_ext_iff","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA B : CommMon_ C\nf g : Quiver.Hom A B\n‚ä¢ Iff (Eq f g) (Eq f.hom g.hom)","decl":"@[ext]\nlemma hom_ext {A B : CommMon_ C} (f g : A ‚ü∂ B) (h : f.hom = g.hom) : f = g :=\n  Mon_.Hom.ext h\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10688): the following two lemmas `id'` and `comp'`\n-- have been added to ease automation;\n"}
{"name":"CommMon_.id'","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : CommMon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id A) (CategoryTheory.CategoryStruct.id A.toMon_)","decl":"@[simp]\nlemma id' (A : CommMon_ C) : (ùüô A : A.toMon_ ‚ü∂ A.toMon_) = ùüô (A.toMon_) := rfl\n\n"}
{"name":"CommMon_.comp'","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA‚ÇÅ A‚ÇÇ A‚ÇÉ : CommMon_ C\nf : Quiver.Hom A‚ÇÅ A‚ÇÇ\ng : Quiver.Hom A‚ÇÇ A‚ÇÉ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f g)","decl":"@[simp]\nlemma comp' {A‚ÇÅ A‚ÇÇ A‚ÇÉ : CommMon_ C} (f : A‚ÇÅ ‚ü∂ A‚ÇÇ) (g : A‚ÇÇ ‚ü∂ A‚ÇÉ) :\n    ((f ‚â´ g : A‚ÇÅ ‚ü∂ A‚ÇÉ) : A‚ÇÅ.toMon_ ‚ü∂ A‚ÇÉ.toMon_) = @CategoryStruct.comp (Mon_ C) _ _ _ _ f g := rfl\n\n"}
{"name":"CommMon_.instFullMon_Forget‚ÇÇMon_","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ (CommMon_.forget‚ÇÇMon_ C).Full","decl":"instance : (forget‚ÇÇMon_ C).Full := InducedCategory.full _\n"}
{"name":"CommMon_.instFaithfulMon_Forget‚ÇÇMon_","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ (CommMon_.forget‚ÇÇMon_ C).Faithful","decl":"instance : (forget‚ÇÇMon_ C).Faithful := InducedCategory.faithful _\n\n"}
{"name":"CommMon_.forget‚ÇÇ_Mon_obj_one","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : CommMon_ C\n‚ä¢ Eq ((CommMon_.forget‚ÇÇMon_ C).obj A).one A.one","decl":"@[simp]\ntheorem forget‚ÇÇ_Mon_obj_one (A : CommMon_ C) : ((forget‚ÇÇMon_ C).obj A).one = A.one :=\n  rfl\n\n"}
{"name":"CommMon_.forget‚ÇÇ_Mon_obj_mul","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : CommMon_ C\n‚ä¢ Eq ((CommMon_.forget‚ÇÇMon_ C).obj A).mul A.mul","decl":"@[simp]\ntheorem forget‚ÇÇ_Mon_obj_mul (A : CommMon_ C) : ((forget‚ÇÇMon_ C).obj A).mul = A.mul :=\n  rfl\n\n"}
{"name":"CommMon_.forget‚ÇÇ_Mon_map_hom","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA B : CommMon_ C\nf : Quiver.Hom A B\n‚ä¢ Eq ((CommMon_.forget‚ÇÇMon_ C).map f).hom f.hom","decl":"@[simp]\ntheorem forget‚ÇÇ_Mon_map_hom {A B : CommMon_ C} (f : A ‚ü∂ B) : ((forget‚ÇÇMon_ C).map f).hom = f.hom :=\n  rfl\n\n"}
{"name":"CommMon_.mkIso_hom_hom","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM N : CommMon_ C\nf : CategoryTheory.Iso M.X N.X\none_f : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.one f.hom) N.one) _auto‚úù\nmul_f : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.mul f.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f.hom f.hom) N.mul)) _auto‚úù\n‚ä¢ Eq (CommMon_.mkIso f one_f mul_f).hom.hom f.hom","decl":"@[simp] lemma mkIso_hom_hom : (mkIso f one_f mul_f).hom.hom = f.hom := rfl\n"}
{"name":"CommMon_.mkIso_inv_hom","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM N : CommMon_ C\nf : CategoryTheory.Iso M.X N.X\none_f : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.one f.hom) N.one) _auto‚úù\nmul_f : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.mul f.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f.hom f.hom) N.mul)) _auto‚úù\n‚ä¢ Eq (CommMon_.mkIso f one_f mul_f).inv.hom f.inv","decl":"@[simp] lemma mkIso_inv_hom : (mkIso f one_f mul_f).inv.hom = f.inv := rfl\n\n"}
{"name":"CommMon_.instHasInitial","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ CategoryTheory.Limits.HasInitial (CommMon_ C)","decl":"instance : HasInitial (CommMon_ C) :=\n  hasInitial_of_unique (trivial C)\n\n"}
{"name":"CategoryTheory.Functor.mapCommMon_obj_mul","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.MonoidalCategory C\ninst‚úù‚Å¥ : CategoryTheory.BraidedCategory C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory D\ninst‚úù¬π : CategoryTheory.BraidedCategory D\nF : CategoryTheory.Functor C D\ninst‚úù : F.LaxBraided\nA : CommMon_ C\n‚ä¢ Eq (F.mapCommMon.obj A).mul (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Œº F A.X A.X) (F.map A.mul))","decl":"/-- A lax braided functor takes commutative monoid objects to commutative monoid objects.\n\nThat is, a lax braided functor `F : C ‚•§ D` induces a functor `CommMon_ C ‚•§ CommMon_ D`.\n-/\n@[simps!]\ndef mapCommMon (F : C ‚•§ D) [F.LaxBraided] : CommMon_ C ‚•§ CommMon_ D where\n  obj A :=\n    { F.mapMon.obj A.toMon_ with\n      mul_comm := by\n        dsimp\n        rw [‚Üê Functor.LaxBraided.braided_assoc, ‚Üê Functor.map_comp, A.mul_comm] }\n  map f := F.mapMon.map f\n\n"}
{"name":"CategoryTheory.Functor.mapCommMon_obj_one","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.MonoidalCategory C\ninst‚úù‚Å¥ : CategoryTheory.BraidedCategory C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory D\ninst‚úù¬π : CategoryTheory.BraidedCategory D\nF : CategoryTheory.Functor C D\ninst‚úù : F.LaxBraided\nA : CommMon_ C\n‚ä¢ Eq (F.mapCommMon.obj A).one (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Œµ F) (F.map A.one))","decl":"/-- A lax braided functor takes commutative monoid objects to commutative monoid objects.\n\nThat is, a lax braided functor `F : C ‚•§ D` induces a functor `CommMon_ C ‚•§ CommMon_ D`.\n-/\n@[simps!]\ndef mapCommMon (F : C ‚•§ D) [F.LaxBraided] : CommMon_ C ‚•§ CommMon_ D where\n  obj A :=\n    { F.mapMon.obj A.toMon_ with\n      mul_comm := by\n        dsimp\n        rw [‚Üê Functor.LaxBraided.braided_assoc, ‚Üê Functor.map_comp, A.mul_comm] }\n  map f := F.mapMon.map f\n\n"}
{"name":"CategoryTheory.Functor.mapCommMon_map_hom","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.MonoidalCategory C\ninst‚úù‚Å¥ : CategoryTheory.BraidedCategory C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory D\ninst‚úù¬π : CategoryTheory.BraidedCategory D\nF : CategoryTheory.Functor C D\ninst‚úù : F.LaxBraided\nX‚úù Y‚úù : CommMon_ C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (F.mapCommMon.map f).hom (F.map f.hom)","decl":"/-- A lax braided functor takes commutative monoid objects to commutative monoid objects.\n\nThat is, a lax braided functor `F : C ‚•§ D` induces a functor `CommMon_ C ‚•§ CommMon_ D`.\n-/\n@[simps!]\ndef mapCommMon (F : C ‚•§ D) [F.LaxBraided] : CommMon_ C ‚•§ CommMon_ D where\n  obj A :=\n    { F.mapMon.obj A.toMon_ with\n      mul_comm := by\n        dsimp\n        rw [‚Üê Functor.LaxBraided.braided_assoc, ‚Üê Functor.map_comp, A.mul_comm] }\n  map f := F.mapMon.map f\n\n"}
{"name":"CategoryTheory.Functor.mapCommMon_obj_X","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.MonoidalCategory C\ninst‚úù‚Å¥ : CategoryTheory.BraidedCategory C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory D\ninst‚úù¬π : CategoryTheory.BraidedCategory D\nF : CategoryTheory.Functor C D\ninst‚úù : F.LaxBraided\nA : CommMon_ C\n‚ä¢ Eq (F.mapCommMon.obj A).X (F.obj A.X)","decl":"/-- A lax braided functor takes commutative monoid objects to commutative monoid objects.\n\nThat is, a lax braided functor `F : C ‚•§ D` induces a functor `CommMon_ C ‚•§ CommMon_ D`.\n-/\n@[simps!]\ndef mapCommMon (F : C ‚•§ D) [F.LaxBraided] : CommMon_ C ‚•§ CommMon_ D where\n  obj A :=\n    { F.mapMon.obj A.toMon_ with\n      mul_comm := by\n        dsimp\n        rw [‚Üê Functor.LaxBraided.braided_assoc, ‚Üê Functor.map_comp, A.mul_comm] }\n  map f := F.mapMon.map f\n\n"}
{"name":"CategoryTheory.Functor.mapCommMonFunctor_obj","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Å¥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≥ : CategoryTheory.BraidedCategory C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\ninst‚úù : CategoryTheory.BraidedCategory D\nF : CategoryTheory.LaxBraidedFunctor C D\n‚ä¢ Eq ((CategoryTheory.Functor.mapCommMonFunctor C D).obj F) F.mapCommMon","decl":"/-- `mapCommMon` is functorial in the lax braided functor. -/\n@[simps]\ndef mapCommMonFunctor : LaxBraidedFunctor C D ‚•§ CommMon_ C ‚•§ CommMon_ D where\n  obj F := F.mapCommMon\n  map Œ± := { app := fun A => { hom := Œ±.hom.app A.X } }\n  map_comp _ _ := rfl\n\n"}
{"name":"CategoryTheory.Functor.mapCommMonFunctor_map_app_hom","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Å¥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≥ : CategoryTheory.BraidedCategory C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\ninst‚úù : CategoryTheory.BraidedCategory D\nX‚úù Y‚úù : CategoryTheory.LaxBraidedFunctor C D\nŒ± : Quiver.Hom X‚úù Y‚úù\nA : CommMon_ C\n‚ä¢ Eq (((CategoryTheory.Functor.mapCommMonFunctor C D).map Œ±).app A).hom (Œ±.hom.app A.X)","decl":"/-- `mapCommMon` is functorial in the lax braided functor. -/\n@[simps]\ndef mapCommMonFunctor : LaxBraidedFunctor C D ‚•§ CommMon_ C ‚•§ CommMon_ D where\n  obj F := F.mapCommMon\n  map Œ± := { app := fun A => { hom := Œ±.hom.app A.X } }\n  map_comp _ _ := rfl\n\n"}
{"name":"CommMon_.EquivLaxBraidedFunctorPUnit.laxBraidedToCommMon_obj","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nF : CategoryTheory.LaxBraidedFunctor (CategoryTheory.Discrete PUnit.{u + 1}) C\n‚ä¢ Eq ((CommMon_.EquivLaxBraidedFunctorPUnit.laxBraidedToCommMon C).obj F) (F.mapCommMon.obj (CommMon_.trivial (CategoryTheory.Discrete PUnit.{u + 1})))","decl":"/-- Implementation of `CommMon_.equivLaxBraidedFunctorPUnit`. -/\n@[simps]\ndef laxBraidedToCommMon : LaxBraidedFunctor (Discrete PUnit.{u + 1}) C ‚•§ CommMon_ C where\n  obj F := (F.mapCommMon : CommMon_ _ ‚•§ CommMon_ C).obj (trivial (Discrete PUnit.{u+1}))\n  map Œ± := ((Functor.mapCommMonFunctor (Discrete PUnit) C).map Œ±).app _\n\n"}
{"name":"CommMon_.EquivLaxBraidedFunctorPUnit.laxBraidedToCommMon_map","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX‚úù Y‚úù : CategoryTheory.LaxBraidedFunctor (CategoryTheory.Discrete PUnit.{u + 1}) C\nŒ± : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CommMon_.EquivLaxBraidedFunctorPUnit.laxBraidedToCommMon C).map Œ±) (((CategoryTheory.Functor.mapCommMonFunctor (CategoryTheory.Discrete PUnit.{u + 1}) C).map Œ±).app (CommMon_.trivial (CategoryTheory.Discrete PUnit.{u + 1})))","decl":"/-- Implementation of `CommMon_.equivLaxBraidedFunctorPUnit`. -/\n@[simps]\ndef laxBraidedToCommMon : LaxBraidedFunctor (Discrete PUnit.{u + 1}) C ‚•§ CommMon_ C where\n  obj F := (F.mapCommMon : CommMon_ _ ‚•§ CommMon_ C).obj (trivial (Discrete PUnit.{u+1}))\n  map Œ± := ((Functor.mapCommMonFunctor (Discrete PUnit) C).map Œ±).app _\n\n"}
{"name":"CommMon_.EquivLaxBraidedFunctorPUnit.commMonToLaxBraidedObj_obj","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : CommMon_ C\nx‚úù : CategoryTheory.Discrete PUnit.{u + 1}\n‚ä¢ Eq ((CommMon_.EquivLaxBraidedFunctorPUnit.commMonToLaxBraidedObj A).obj x‚úù) A.X","decl":"/-- Implementation of `CommMon_.equivLaxBraidedFunctorPUnit`. -/\n@[simps!]\ndef commMonToLaxBraidedObj (A : CommMon_ C) :\n    Discrete PUnit.{u + 1} ‚•§ C := (Functor.const _).obj A.X\n\n"}
{"name":"CommMon_.EquivLaxBraidedFunctorPUnit.commMonToLaxBraidedObj_map","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : CommMon_ C\nX‚úù Y‚úù : CategoryTheory.Discrete PUnit.{u + 1}\nx‚úù : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CommMon_.EquivLaxBraidedFunctorPUnit.commMonToLaxBraidedObj A).map x‚úù) (CategoryTheory.CategoryStruct.id A.X)","decl":"/-- Implementation of `CommMon_.equivLaxBraidedFunctorPUnit`. -/\n@[simps!]\ndef commMonToLaxBraidedObj (A : CommMon_ C) :\n    Discrete PUnit.{u + 1} ‚•§ C := (Functor.const _).obj A.X\n\n"}
{"name":"CommMon_.EquivLaxBraidedFunctorPUnit.commMonToLaxBraidedObj_Œµ","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : CommMon_ C\n‚ä¢ Eq (CategoryTheory.Functor.LaxMonoidal.Œµ (CommMon_.EquivLaxBraidedFunctorPUnit.commMonToLaxBraidedObj A)) A.one","decl":"@[simp]\nlemma commMonToLaxBraidedObj_Œµ (A : CommMon_ C) :\n    Œµ (commMonToLaxBraidedObj A) = A.one := rfl\n\n"}
{"name":"CommMon_.EquivLaxBraidedFunctorPUnit.commMonToLaxBraidedObj_Œº","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : CommMon_ C\nX Y : CategoryTheory.Discrete PUnit.{u_1 + 1}\n‚ä¢ Eq (CategoryTheory.Functor.LaxMonoidal.Œº (CommMon_.EquivLaxBraidedFunctorPUnit.commMonToLaxBraidedObj A) X Y) A.mul","decl":"@[simp]\nlemma commMonToLaxBraidedObj_Œº (A : CommMon_ C) (X Y) :\n    Œº (commMonToLaxBraidedObj A) X Y = A.mul := rfl\n\n"}
{"name":"CommMon_.EquivLaxBraidedFunctorPUnit.commMonToLaxBraided_map_hom_app","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX‚úù Y‚úù : CommMon_ C\nf : Quiver.Hom X‚úù Y‚úù\nx‚úù : CategoryTheory.Discrete PUnit.{u + 1}\n‚ä¢ Eq (((CommMon_.EquivLaxBraidedFunctorPUnit.commMonToLaxBraided C).map f).hom.app x‚úù) f.hom","decl":"/-- Implementation of `CommMon_.equivLaxBraidedFunctorPUnit`. -/\n@[simps]\ndef commMonToLaxBraided : CommMon_ C ‚•§ LaxBraidedFunctor (Discrete PUnit.{u + 1}) C where\n  obj A := LaxBraidedFunctor.of (commMonToLaxBraidedObj A)\n  map f :=\n    { hom := { app := fun _ => f.hom }\n      isMonoidal := { } }\n\n"}
{"name":"CommMon_.EquivLaxBraidedFunctorPUnit.commMonToLaxBraided_obj","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : CommMon_ C\n‚ä¢ Eq ((CommMon_.EquivLaxBraidedFunctorPUnit.commMonToLaxBraided C).obj A) (CategoryTheory.LaxBraidedFunctor.of (CommMon_.EquivLaxBraidedFunctorPUnit.commMonToLaxBraidedObj A))","decl":"/-- Implementation of `CommMon_.equivLaxBraidedFunctorPUnit`. -/\n@[simps]\ndef commMonToLaxBraided : CommMon_ C ‚•§ LaxBraidedFunctor (Discrete PUnit.{u + 1}) C where\n  obj A := LaxBraidedFunctor.of (commMonToLaxBraidedObj A)\n  map f :=\n    { hom := { app := fun _ => f.hom }\n      isMonoidal := { } }\n\n"}
{"name":"CommMon_.EquivLaxBraidedFunctorPUnit.unitIso_inv_app_hom_app","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX‚úù : CategoryTheory.LaxBraidedFunctor (CategoryTheory.Discrete PUnit.{u + 1}) C\nX : CategoryTheory.Discrete PUnit.{u + 1}\n‚ä¢ Eq (((CommMon_.EquivLaxBraidedFunctorPUnit.unitIso C).inv.app X‚úù).hom.app X) (CategoryTheory.CategoryStruct.id (X‚úù.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit))","decl":"/-- Implementation of `CommMon_.equivLaxBraidedFunctorPUnit`. -/\n@[simps!]\ndef unitIso :\n    ùü≠ (LaxBraidedFunctor (Discrete PUnit.{u + 1}) C) ‚âÖ\n        laxBraidedToCommMon C ‚ãô commMonToLaxBraided C :=\n  NatIso.ofComponents\n    (fun F ‚Ü¶ LaxBraidedFunctor.isoOfComponents (fun _ ‚Ü¶ F.mapIso (eqToIso (by ext))))\n    (fun f ‚Ü¶ by ext ‚ü®‚ü®‚ü©‚ü©; dsimp; simp)\n\n"}
{"name":"CommMon_.EquivLaxBraidedFunctorPUnit.unitIso_hom_app_hom_app","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX‚úù : CategoryTheory.LaxBraidedFunctor (CategoryTheory.Discrete PUnit.{u + 1}) C\nX : CategoryTheory.Discrete PUnit.{u + 1}\n‚ä¢ Eq (((CommMon_.EquivLaxBraidedFunctorPUnit.unitIso C).hom.app X‚úù).hom.app X) (CategoryTheory.CategoryStruct.id (X‚úù.obj X))","decl":"/-- Implementation of `CommMon_.equivLaxBraidedFunctorPUnit`. -/\n@[simps!]\ndef unitIso :\n    ùü≠ (LaxBraidedFunctor (Discrete PUnit.{u + 1}) C) ‚âÖ\n        laxBraidedToCommMon C ‚ãô commMonToLaxBraided C :=\n  NatIso.ofComponents\n    (fun F ‚Ü¶ LaxBraidedFunctor.isoOfComponents (fun _ ‚Ü¶ F.mapIso (eqToIso (by ext))))\n    (fun f ‚Ü¶ by ext ‚ü®‚ü®‚ü©‚ü©; dsimp; simp)\n\n"}
{"name":"CommMon_.EquivLaxBraidedFunctorPUnit.counitIso_hom_app_hom","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX : CommMon_ C\n‚ä¢ Eq ((CommMon_.EquivLaxBraidedFunctorPUnit.counitIso C).hom.app X).hom (CategoryTheory.CategoryStruct.id X.X)","decl":"/-- Implementation of `CommMon_.equivLaxBraidedFunctorPUnit`. -/\n@[simps!]\ndef counitIso : commMonToLaxBraided C ‚ãô laxBraidedToCommMon C ‚âÖ ùü≠ (CommMon_ C) :=\n  NatIso.ofComponents (fun F ‚Ü¶ mkIso (Iso.refl _))\n\n"}
{"name":"CommMon_.EquivLaxBraidedFunctorPUnit.counitIso_inv_app_hom","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX : CommMon_ C\n‚ä¢ Eq ((CommMon_.EquivLaxBraidedFunctorPUnit.counitIso C).inv.app X).hom (CategoryTheory.CategoryStruct.id X.X)","decl":"/-- Implementation of `CommMon_.equivLaxBraidedFunctorPUnit`. -/\n@[simps!]\ndef counitIso : commMonToLaxBraided C ‚ãô laxBraidedToCommMon C ‚âÖ ùü≠ (CommMon_ C) :=\n  NatIso.ofComponents (fun F ‚Ü¶ mkIso (Iso.refl _))\n\n"}
{"name":"CommMon_.equivLaxBraidedFunctorPUnit_counitIso","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq (CommMon_.equivLaxBraidedFunctorPUnit C).counitIso (CommMon_.EquivLaxBraidedFunctorPUnit.counitIso C)","decl":"/-- Commutative monoid objects in `C` are \"just\" braided lax monoidal functors from the trivial\nbraided monoidal category to `C`.\n-/\n@[simps]\ndef equivLaxBraidedFunctorPUnit : LaxBraidedFunctor (Discrete PUnit.{u + 1}) C ‚âå CommMon_ C where\n  functor := laxBraidedToCommMon C\n  inverse := commMonToLaxBraided C\n  unitIso := unitIso C\n  counitIso := counitIso C\n\n"}
{"name":"CommMon_.equivLaxBraidedFunctorPUnit_unitIso","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq (CommMon_.equivLaxBraidedFunctorPUnit C).unitIso (CommMon_.EquivLaxBraidedFunctorPUnit.unitIso C)","decl":"/-- Commutative monoid objects in `C` are \"just\" braided lax monoidal functors from the trivial\nbraided monoidal category to `C`.\n-/\n@[simps]\ndef equivLaxBraidedFunctorPUnit : LaxBraidedFunctor (Discrete PUnit.{u + 1}) C ‚âå CommMon_ C where\n  functor := laxBraidedToCommMon C\n  inverse := commMonToLaxBraided C\n  unitIso := unitIso C\n  counitIso := counitIso C\n\n"}
{"name":"CommMon_.equivLaxBraidedFunctorPUnit_inverse","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq (CommMon_.equivLaxBraidedFunctorPUnit C).inverse (CommMon_.EquivLaxBraidedFunctorPUnit.commMonToLaxBraided C)","decl":"/-- Commutative monoid objects in `C` are \"just\" braided lax monoidal functors from the trivial\nbraided monoidal category to `C`.\n-/\n@[simps]\ndef equivLaxBraidedFunctorPUnit : LaxBraidedFunctor (Discrete PUnit.{u + 1}) C ‚âå CommMon_ C where\n  functor := laxBraidedToCommMon C\n  inverse := commMonToLaxBraided C\n  unitIso := unitIso C\n  counitIso := counitIso C\n\n"}
{"name":"CommMon_.equivLaxBraidedFunctorPUnit_functor","module":"Mathlib.CategoryTheory.Monoidal.CommMon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq (CommMon_.equivLaxBraidedFunctorPUnit C).functor (CommMon_.EquivLaxBraidedFunctorPUnit.laxBraidedToCommMon C)","decl":"/-- Commutative monoid objects in `C` are \"just\" braided lax monoidal functors from the trivial\nbraided monoidal category to `C`.\n-/\n@[simps]\ndef equivLaxBraidedFunctorPUnit : LaxBraidedFunctor (Discrete PUnit.{u + 1}) C ‚âå CommMon_ C where\n  functor := laxBraidedToCommMon C\n  inverse := commMonToLaxBraided C\n  unitIso := unitIso C\n  counitIso := counitIso C\n\n"}
