{"name":"Int.cast_ite","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝¹ : AddGroupWithOne α\nP : Prop\ninst✝ : Decidable P\nm n : Int\n⊢ Eq (↑(ite P m n)) (ite P ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_ite [AddGroupWithOne α] (P : Prop) [Decidable P] (m n : ℤ) :\n    ((ite P m n : ℤ) : α) = ite P (m : α) (n : α) :=\n  apply_ite _ _ _ _\n\n"}
{"name":"Int.coe_castAddHom","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : AddGroupWithOne α\n⊢ Eq ⇑(Int.castAddHom α) fun x => ↑x","decl":"@[simp] lemma coe_castAddHom : ⇑(castAddHom α) = fun x : ℤ => (x : α) := rfl\n\n"}
{"name":"Even.intCast","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : AddGroupWithOne α\nn : Int\nh : Even n\n⊢ Even ↑n","decl":"lemma _root_.Even.intCast {n : ℤ} (h : Even n) : Even (n : α) := h.map (castAddHom α)\n\n"}
{"name":"Int.cast_eq_zero","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝¹ : AddGroupWithOne α\ninst✝ : CharZero α\nn : Int\n⊢ Iff (Eq (↑n) 0) (Eq n 0)","decl":"@[simp] lemma cast_eq_zero : (n : α) = 0 ↔ n = 0 where\n  mp h := by\n    cases n\n    · erw [Int.cast_natCast] at h\n      exact congr_arg _ (Nat.cast_eq_zero.1 h)\n    · rw [cast_negSucc, neg_eq_zero, Nat.cast_eq_zero] at h\n      contradiction\n  mpr h := by rw [h, cast_zero]\n\n"}
{"name":"Int.cast_inj","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝¹ : AddGroupWithOne α\ninst✝ : CharZero α\nm n : Int\n⊢ Iff (Eq ↑m ↑n) (Eq m n)","decl":"@[simp, norm_cast]\nlemma cast_inj : (m : α) = n ↔ m = n := by rw [← sub_eq_zero, ← cast_sub, cast_eq_zero, sub_eq_zero]\n\n"}
{"name":"Int.cast_injective","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝¹ : AddGroupWithOne α\ninst✝ : CharZero α\n⊢ Function.Injective Int.cast","decl":"lemma cast_injective : Injective (Int.cast : ℤ → α) := fun _ _ ↦ cast_inj.1\n\n"}
{"name":"Int.cast_ne_zero","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝¹ : AddGroupWithOne α\ninst✝ : CharZero α\nn : Int\n⊢ Iff (Ne (↑n) 0) (Ne n 0)","decl":"lemma cast_ne_zero : (n : α) ≠ 0 ↔ n ≠ 0 := not_congr cast_eq_zero\n\n"}
{"name":"Int.cast_eq_one","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝¹ : AddGroupWithOne α\ninst✝ : CharZero α\nn : Int\n⊢ Iff (Eq (↑n) 1) (Eq n 1)","decl":"@[simp] lemma cast_eq_one : (n : α) = 1 ↔ n = 1 := by rw [← cast_one, cast_inj]\n\n"}
{"name":"Int.cast_ne_one","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝¹ : AddGroupWithOne α\ninst✝ : CharZero α\nn : Int\n⊢ Iff (Ne (↑n) 1) (Ne n 1)","decl":"lemma cast_ne_one : (n : α) ≠ 1 ↔ n ≠ 1 := cast_eq_one.not\n\n"}
{"name":"Int.coe_castRingHom","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : NonAssocRing α\n⊢ Eq ⇑(Int.castRingHom α) fun x => ↑x","decl":"@[simp] lemma coe_castRingHom : ⇑(castRingHom α) = fun x : ℤ ↦ (x : α) := rfl\n\n"}
{"name":"Int.cast_commute","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : NonAssocRing α\nn : Int\na : α\n⊢ Commute (↑n) a","decl":"lemma cast_commute : ∀ (n : ℤ) (a : α), Commute ↑n a\n  | (n : ℕ), x => by simpa using n.cast_commute x\n  | -[n+1], x => by\n    simpa only [cast_negSucc, Commute.neg_left_iff, Commute.neg_right_iff] using\n      (n + 1).cast_commute (-x)\n\n"}
{"name":"Int.cast_comm","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : NonAssocRing α\nn : Int\nx : α\n⊢ Eq (HMul.hMul (↑n) x) (HMul.hMul x ↑n)","decl":"lemma cast_comm (n : ℤ) (x : α) : n * x = x * n := (cast_commute ..).eq\n\n"}
{"name":"Int.commute_cast","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : NonAssocRing α\na : α\nn : Int\n⊢ Commute a ↑n","decl":"lemma commute_cast (a : α) (n : ℤ) : Commute a n := (cast_commute ..).symm\n\n"}
{"name":"zsmul_eq_mul","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : NonAssocRing α\na : α\nn : Int\n⊢ Eq (HSMul.hSMul n a) (HMul.hMul (↑n) a)","decl":"@[simp] lemma _root_.zsmul_eq_mul (a : α) : ∀ n : ℤ, n • a = n * a\n  | (n : ℕ) => by rw [natCast_zsmul, nsmul_eq_mul, Int.cast_natCast]\n  | -[n+1] => by simp [Nat.cast_succ, neg_add_rev, Int.cast_negSucc, add_mul]\n\n"}
{"name":"zsmul_eq_mul'","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : NonAssocRing α\na : α\nn : Int\n⊢ Eq (HSMul.hSMul n a) (HMul.hMul a ↑n)","decl":"lemma _root_.zsmul_eq_mul' (a : α) (n : ℤ) : n • a = a * n := by\n  rw [zsmul_eq_mul, (n.cast_commute a).eq]\n\n"}
{"name":"Odd.intCast","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : Ring α\nn : Int\nhn : Odd n\n⊢ Odd ↑n","decl":"lemma _root_.Odd.intCast (hn : Odd n) : Odd (n : α) := hn.map (castRingHom α)\n\n"}
{"name":"Int.cast_dvd_cast","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : CommRing α\nm n : Int\nh : Dvd.dvd m n\n⊢ Dvd.dvd ↑m ↑n","decl":"theorem cast_dvd_cast [CommRing α] (m n : ℤ) (h : m ∣ n) : (m : α) ∣ (n : α) :=\n  RingHom.map_dvd (Int.castRingHom α) h\n\n"}
{"name":"SemiconjBy.intCast_mul_right","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : Ring α\na x y : α\nh : SemiconjBy a x y\nn : Int\n⊢ SemiconjBy a (HMul.hMul (↑n) x) (HMul.hMul (↑n) y)","decl":"@[simp] lemma intCast_mul_right (h : SemiconjBy a x y) (n : ℤ) : SemiconjBy a (n * x) (n * y) :=\n  SemiconjBy.mul_right (Int.commute_cast _ _) h\n\n"}
{"name":"SemiconjBy.intCast_mul_left","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : Ring α\na x y : α\nh : SemiconjBy a x y\nn : Int\n⊢ SemiconjBy (HMul.hMul (↑n) a) x y","decl":"@[simp] lemma intCast_mul_left (h : SemiconjBy a x y) (n : ℤ) : SemiconjBy (n * a) x y :=\n  SemiconjBy.mul_left (Int.cast_commute _ _) h\n\n"}
{"name":"SemiconjBy.intCast_mul_intCast_mul","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : Ring α\na x y : α\nh : SemiconjBy a x y\nm n : Int\n⊢ SemiconjBy (HMul.hMul (↑m) a) (HMul.hMul (↑n) x) (HMul.hMul (↑n) y)","decl":"@[simp] lemma intCast_mul_intCast_mul (h : SemiconjBy a x y) (m n : ℤ) :\n    SemiconjBy (m * a) (n * x) (n * y) := (h.intCast_mul_left m).intCast_mul_right n\n\n"}
{"name":"Commute.intCast_left","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : NonAssocRing α\na : α\nn : Int\n⊢ Commute (↑n) a","decl":"@[simp] lemma intCast_left : Commute (n : α) a := Int.cast_commute _ _\n\n"}
{"name":"Commute.intCast_right","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : NonAssocRing α\na : α\nn : Int\n⊢ Commute a ↑n","decl":"@[simp] lemma intCast_right : Commute a n := Int.commute_cast _ _\n\n"}
{"name":"Commute.intCast_mul_right","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : Ring α\na b : α\nh : Commute a b\nm : Int\n⊢ Commute a (HMul.hMul (↑m) b)","decl":"@[simp] lemma intCast_mul_right (h : Commute a b) (m : ℤ) : Commute a (m * b) :=\n  SemiconjBy.intCast_mul_right h m\n\n"}
{"name":"Commute.intCast_mul_left","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : Ring α\na b : α\nh : Commute a b\nm : Int\n⊢ Commute (HMul.hMul (↑m) a) b","decl":"@[simp] lemma intCast_mul_left (h : Commute a b) (m : ℤ) : Commute (m  * a) b :=\n  SemiconjBy.intCast_mul_left h m\n\n"}
{"name":"Commute.intCast_mul_intCast_mul","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : Ring α\na b : α\nh : Commute a b\nm n : Int\n⊢ Commute (HMul.hMul (↑m) a) (HMul.hMul (↑n) b)","decl":"lemma intCast_mul_intCast_mul (h : Commute a b) (m n : ℤ) : Commute (m * a) (n * b) :=\n  SemiconjBy.intCast_mul_intCast_mul h m n\n\n"}
{"name":"Commute.self_intCast_mul","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : Ring α\na : α\nn : Int\n⊢ Commute a (HMul.hMul (↑n) a)","decl":"lemma self_intCast_mul : Commute a (n * a : α) := (Commute.refl a).intCast_mul_right n\n\n"}
{"name":"Commute.intCast_mul_self","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : Ring α\na : α\nn : Int\n⊢ Commute (HMul.hMul (↑n) a) a","decl":"lemma intCast_mul_self : Commute ((n : α) * a) a := (Commute.refl a).intCast_mul_left n\n\n"}
{"name":"Commute.self_intCast_mul_intCast_mul","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : Ring α\na : α\nm n : Int\n⊢ Commute (HMul.hMul (↑m) a) (HMul.hMul (↑n) a)","decl":"lemma self_intCast_mul_intCast_mul : Commute (m * a : α) (n * a : α) :=\n  (Commute.refl a).intCast_mul_intCast_mul m n\n\n"}
{"name":"AddMonoidHom.ext_int_iff","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"A : Type u_5\ninst✝ : AddMonoid A\nf g : AddMonoidHom Int A\n⊢ Iff (Eq f g) (Eq (f 1) (g 1))","decl":"/-- Two additive monoid homomorphisms `f`, `g` from `ℤ` to an additive monoid are equal\nif `f 1 = g 1`. -/\n@[ext high]\ntheorem ext_int [AddMonoid A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=\n  have : f.comp (Int.ofNatHom : ℕ →+ ℤ) = g.comp (Int.ofNatHom : ℕ →+ ℤ) := ext_nat' _ _ h1\n  have this' : ∀ n : ℕ, f n = g n := DFunLike.ext_iff.1 this\n  ext fun n => match n with\n  | (n : ℕ) => this' n\n  | .negSucc n => eq_on_neg _ _ (this' <| n + 1)\n\n"}
{"name":"AddMonoidHom.ext_int","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"A : Type u_5\ninst✝ : AddMonoid A\nf g : AddMonoidHom Int A\nh1 : Eq (f 1) (g 1)\n⊢ Eq f g","decl":"/-- Two additive monoid homomorphisms `f`, `g` from `ℤ` to an additive monoid are equal\nif `f 1 = g 1`. -/\n@[ext high]\ntheorem ext_int [AddMonoid A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=\n  have : f.comp (Int.ofNatHom : ℕ →+ ℤ) = g.comp (Int.ofNatHom : ℕ →+ ℤ) := ext_nat' _ _ h1\n  have this' : ∀ n : ℕ, f n = g n := DFunLike.ext_iff.1 this\n  ext fun n => match n with\n  | (n : ℕ) => this' n\n  | .negSucc n => eq_on_neg _ _ (this' <| n + 1)\n\n"}
{"name":"AddMonoidHom.eq_intCastAddHom","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"A : Type u_5\ninst✝ : AddGroupWithOne A\nf : AddMonoidHom Int A\nh1 : Eq (f 1) 1\n⊢ Eq f (Int.castAddHom A)","decl":"theorem eq_intCastAddHom (f : ℤ →+ A) (h1 : f 1 = 1) : f = Int.castAddHom A :=\n  ext_int <| by simp [h1]\n\n"}
{"name":"eq_intCast'","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"F : Type u_1\nα : Type u_3\ninst✝² : AddGroupWithOne α\ninst✝¹ : FunLike F Int α\ninst✝ : AddMonoidHomClass F Int α\nf : F\nh₁ : Eq (f 1) 1\nn : Int\n⊢ Eq (f n) ↑n","decl":"theorem eq_intCast' [AddGroupWithOne α] [FunLike F ℤ α] [AddMonoidHomClass F ℤ α]\n    (f : F) (h₁ : f 1 = 1) :\n    ∀ n : ℤ, f n = n :=\n  DFunLike.ext_iff.1 <| (f : ℤ →+ α).eq_intCastAddHom h₁\n\n"}
{"name":"map_intCast'","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"F : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝³ : AddGroupWithOne α\ninst✝² : AddGroupWithOne β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nf : F\nh₁ : Eq (f 1) 1\nn : Int\n⊢ Eq (f ↑n) ↑n","decl":"/-- This version is primed so that the `RingHomClass` versions aren't. -/\ntheorem map_intCast' [AddGroupWithOne α] [AddGroupWithOne β] [FunLike F α β]\n    [AddMonoidHomClass F α β] (f : F) (h₁ : f 1 = 1) : ∀ n : ℤ, f n = n :=\n  eq_intCast' ((f : α →+ β).comp <| Int.castAddHom _) (by simpa)\n\n"}
{"name":"Int.castAddHom_int","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"⊢ Eq (Int.castAddHom Int) (AddMonoidHom.id Int)","decl":"@[simp]\ntheorem Int.castAddHom_int : Int.castAddHom ℤ = AddMonoidHom.id ℤ :=\n  ((AddMonoidHom.id ℤ).eq_intCastAddHom rfl).symm\n\n"}
{"name":"MonoidHom.ext_mint_iff","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"M : Type u_5\ninst✝ : Monoid M\nf g : MonoidHom (Multiplicative Int) M\n⊢ Iff (Eq f g) (Eq (f (Multiplicative.ofAdd 1)) (g (Multiplicative.ofAdd 1)))","decl":"@[ext]\ntheorem ext_mint {f g : Multiplicative ℤ →* M} (h1 : f (ofAdd 1) = g (ofAdd 1)) : f = g :=\n  MonoidHom.toAdditive''.injective <| AddMonoidHom.ext_int <| Additive.toMul.injective h1\n\n"}
{"name":"MonoidHom.ext_mint","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"M : Type u_5\ninst✝ : Monoid M\nf g : MonoidHom (Multiplicative Int) M\nh1 : Eq (f (Multiplicative.ofAdd 1)) (g (Multiplicative.ofAdd 1))\n⊢ Eq f g","decl":"@[ext]\ntheorem ext_mint {f g : Multiplicative ℤ →* M} (h1 : f (ofAdd 1) = g (ofAdd 1)) : f = g :=\n  MonoidHom.toAdditive''.injective <| AddMonoidHom.ext_int <| Additive.toMul.injective h1\n\n"}
{"name":"MonoidHom.ext_int_iff","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"M : Type u_5\ninst✝ : Monoid M\nf g : MonoidHom Int M\n⊢ Iff (Eq f g) (And (Eq (f (-1)) (g (-1))) (Eq (f.comp ↑Int.ofNatHom) (g.comp ↑Int.ofNatHom)))","decl":"/-- If two `MonoidHom`s agree on `-1` and the naturals then they are equal. -/\n@[ext]\ntheorem ext_int {f g : ℤ →* M} (h_neg_one : f (-1) = g (-1))\n    (h_nat : f.comp Int.ofNatHom.toMonoidHom = g.comp Int.ofNatHom.toMonoidHom) : f = g := by\n  ext (x | x)\n  · exact (DFunLike.congr_fun h_nat x :)\n  · rw [Int.negSucc_eq, ← neg_one_mul, f.map_mul, g.map_mul]\n    congr 1\n    exact mod_cast (DFunLike.congr_fun h_nat (x + 1) :)\n\n"}
{"name":"MonoidHom.ext_int","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"M : Type u_5\ninst✝ : Monoid M\nf g : MonoidHom Int M\nh_neg_one : Eq (f (-1)) (g (-1))\nh_nat : Eq (f.comp ↑Int.ofNatHom) (g.comp ↑Int.ofNatHom)\n⊢ Eq f g","decl":"/-- If two `MonoidHom`s agree on `-1` and the naturals then they are equal. -/\n@[ext]\ntheorem ext_int {f g : ℤ →* M} (h_neg_one : f (-1) = g (-1))\n    (h_nat : f.comp Int.ofNatHom.toMonoidHom = g.comp Int.ofNatHom.toMonoidHom) : f = g := by\n  ext (x | x)\n  · exact (DFunLike.congr_fun h_nat x :)\n  · rw [Int.negSucc_eq, ← neg_one_mul, f.map_mul, g.map_mul]\n    congr 1\n    exact mod_cast (DFunLike.congr_fun h_nat (x + 1) :)\n\n"}
{"name":"MonoidWithZeroHom.ext_int","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"M : Type u_5\ninst✝ : MonoidWithZero M\nf g : MonoidWithZeroHom Int M\nh_neg_one : Eq (f (-1)) (g (-1))\nh_nat : Eq (f.comp Int.ofNatHom.toMonoidWithZeroHom) (g.comp Int.ofNatHom.toMonoidWithZeroHom)\n⊢ Eq f g","decl":"/-- If two `MonoidWithZeroHom`s agree on `-1` and the naturals then they are equal. -/\n@[ext]\ntheorem ext_int {f g : ℤ →*₀ M} (h_neg_one : f (-1) = g (-1))\n    (h_nat : f.comp Int.ofNatHom.toMonoidWithZeroHom = g.comp Int.ofNatHom.toMonoidWithZeroHom) :\n    f = g :=\n  toMonoidHom_injective <| MonoidHom.ext_int h_neg_one <|\n    MonoidHom.ext (DFunLike.congr_fun h_nat :)\n\n"}
{"name":"MonoidWithZeroHom.ext_int_iff","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"M : Type u_5\ninst✝ : MonoidWithZero M\nf g : MonoidWithZeroHom Int M\n⊢ Iff (Eq f g) (And (Eq (f (-1)) (g (-1))) (Eq (f.comp Int.ofNatHom.toMonoidWithZeroHom) (g.comp Int.ofNatHom.toMonoidWithZeroHom)))","decl":"/-- If two `MonoidWithZeroHom`s agree on `-1` and the naturals then they are equal. -/\n@[ext]\ntheorem ext_int {f g : ℤ →*₀ M} (h_neg_one : f (-1) = g (-1))\n    (h_nat : f.comp Int.ofNatHom.toMonoidWithZeroHom = g.comp Int.ofNatHom.toMonoidWithZeroHom) :\n    f = g :=\n  toMonoidHom_injective <| MonoidHom.ext_int h_neg_one <|\n    MonoidHom.ext (DFunLike.congr_fun h_nat :)\n\n"}
{"name":"ext_int'","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"F : Type u_1\nα : Type u_3\ninst✝² : MonoidWithZero α\ninst✝¹ : FunLike F Int α\ninst✝ : MonoidWithZeroHomClass F Int α\nf g : F\nh_neg_one : Eq (f (-1)) (g (-1))\nh_pos : ∀ (n : Nat), LT.lt 0 n → Eq (f ↑n) (g ↑n)\n⊢ Eq f g","decl":"/-- If two `MonoidWithZeroHom`s agree on `-1` and the _positive_ naturals then they are equal. -/\ntheorem ext_int' [MonoidWithZero α] [FunLike F ℤ α] [MonoidWithZeroHomClass F ℤ α] {f g : F}\n    (h_neg_one : f (-1) = g (-1)) (h_pos : ∀ n : ℕ, 0 < n → f n = g n) : f = g :=\n  (DFunLike.ext _ _) fun n =>\n    haveI :=\n      DFunLike.congr_fun\n        (@MonoidWithZeroHom.ext_int _ _ (f : ℤ →*₀ α) (g : ℤ →*₀ α) h_neg_one <|\n          MonoidWithZeroHom.ext_nat (h_pos _))\n        n\n    this\n\n"}
{"name":"zmultiplesHom_apply","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"β : Type u_4\ninst✝ : AddGroup β\nx : β\nn : Int\n⊢ Eq (((zmultiplesHom β) x) n) (HSMul.hSMul n x)","decl":"lemma zmultiplesHom_apply (x : β) (n : ℤ) : zmultiplesHom β x n = n • x := rfl\n\n"}
{"name":"zmultiplesHom_symm_apply","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"β : Type u_4\ninst✝ : AddGroup β\nf : AddMonoidHom Int β\n⊢ Eq ((zmultiplesHom β).symm f) (f 1)","decl":"lemma zmultiplesHom_symm_apply (f : ℤ →+ β) : (zmultiplesHom β).symm f = f 1 := rfl\n\n"}
{"name":"zpowersHom_apply","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : Group α\nx : α\nn : Multiplicative Int\n⊢ Eq (((zpowersHom α) x) n) (HPow.hPow x (Multiplicative.toAdd n))","decl":"@[to_additive existing (attr := simp)]\nlemma zpowersHom_apply (x : α) (n : Multiplicative ℤ) : zpowersHom α x n = x ^ n.toAdd := rfl\n\n"}
{"name":"zpowersHom_symm_apply","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : Group α\nf : MonoidHom (Multiplicative Int) α\n⊢ Eq ((zpowersHom α).symm f) (f (Multiplicative.ofAdd 1))","decl":"@[to_additive existing (attr := simp)]\nlemma zpowersHom_symm_apply (f : Multiplicative ℤ →* α) :\n    (zpowersHom α).symm f = f (ofAdd 1) := rfl\n\n"}
{"name":"MonoidHom.apply_mint","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : Group α\nf : MonoidHom (Multiplicative Int) α\nn : Multiplicative Int\n⊢ Eq (f n) (HPow.hPow (f (Multiplicative.ofAdd 1)) (Multiplicative.toAdd n))","decl":"lemma MonoidHom.apply_mint (f : Multiplicative ℤ →* α) (n : Multiplicative ℤ) :\n    f n = f (ofAdd 1) ^ n.toAdd := by\n  rw [← zpowersHom_symm_apply, ← zpowersHom_apply, Equiv.apply_symm_apply]\n\n"}
{"name":"AddMonoidHom.apply_int","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"β : Type u_4\ninst✝ : AddGroup β\nf : AddMonoidHom Int β\nn : Int\n⊢ Eq (f n) (HSMul.hSMul n (f 1))","decl":"lemma AddMonoidHom.apply_int (f : ℤ →+ β) (n : ℤ) : f n = n • f 1 := by\n  rw [← zmultiplesHom_symm_apply, ← zmultiplesHom_apply, Equiv.apply_symm_apply]\n\n"}
{"name":"zpowersMulHom_apply","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : CommGroup α\nx : α\nn : Multiplicative Int\n⊢ Eq (((zpowersMulHom α) x) n) (HPow.hPow x (Multiplicative.toAdd n))","decl":"@[simp]\nlemma zpowersMulHom_apply (x : α) (n : Multiplicative ℤ) : zpowersMulHom α x n = x ^ n.toAdd := rfl\n\n"}
{"name":"zpowersMulHom_symm_apply","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : CommGroup α\nf : MonoidHom (Multiplicative Int) α\n⊢ Eq ((zpowersMulHom α).symm f) (f (Multiplicative.ofAdd 1))","decl":"@[simp]\nlemma zpowersMulHom_symm_apply (f : Multiplicative ℤ →* α) :\n    (zpowersMulHom α).symm f = f (ofAdd 1) := rfl\n\n"}
{"name":"zmultiplesAddHom_apply","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"β : Type u_4\ninst✝ : AddCommGroup β\nx : β\nn : Int\n⊢ Eq (((zmultiplesAddHom β) x) n) (HSMul.hSMul n x)","decl":"@[simp] lemma zmultiplesAddHom_apply (x : β) (n : ℤ) : zmultiplesAddHom β x n = n • x := rfl\n\n"}
{"name":"zmultiplesAddHom_symm_apply","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"β : Type u_4\ninst✝ : AddCommGroup β\nf : AddMonoidHom Int β\n⊢ Eq ((zmultiplesAddHom β).symm f) (f 1)","decl":"@[simp] lemma zmultiplesAddHom_symm_apply (f : ℤ →+ β) : (zmultiplesAddHom β).symm f = f 1 := rfl\n\n"}
{"name":"eq_intCast","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"F : Type u_1\nα : Type u_3\ninst✝² : NonAssocRing α\ninst✝¹ : FunLike F Int α\ninst✝ : RingHomClass F Int α\nf : F\nn : Int\n⊢ Eq (f n) ↑n","decl":"@[simp]\ntheorem eq_intCast [FunLike F ℤ α] [RingHomClass F ℤ α] (f : F) (n : ℤ) : f n = n :=\n  eq_intCast' f (map_one _) n\n\n"}
{"name":"map_intCast","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"F : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝³ : NonAssocRing α\ninst✝² : NonAssocRing β\ninst✝¹ : FunLike F α β\ninst✝ : RingHomClass F α β\nf : F\nn : Int\n⊢ Eq (f ↑n) ↑n","decl":"@[simp]\ntheorem map_intCast [FunLike F α β] [RingHomClass F α β] (f : F) (n : ℤ) : f n = n :=\n  eq_intCast ((f : α →+* β).comp (Int.castRingHom α)) n\n\n"}
{"name":"RingHom.eq_intCast'","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"α : Type u_3\ninst✝ : NonAssocRing α\nf : RingHom Int α\n⊢ Eq f (Int.castRingHom α)","decl":"theorem eq_intCast' (f : ℤ →+* α) : f = Int.castRingHom α :=\n  RingHom.ext <| eq_intCast f\n\n"}
{"name":"RingHom.ext_int","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"R : Type u_5\ninst✝ : NonAssocSemiring R\nf g : RingHom Int R\n⊢ Eq f g","decl":"theorem ext_int {R : Type*} [NonAssocSemiring R] (f g : ℤ →+* R) : f = g :=\n  coe_addMonoidHom_injective <| AddMonoidHom.ext_int <| f.map_one.trans g.map_one.symm\n\n"}
{"name":"RingHom.Int.subsingleton_ringHom","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"R : Type u_5\ninst✝ : NonAssocSemiring R\n⊢ Subsingleton (RingHom Int R)","decl":"instance Int.subsingleton_ringHom {R : Type*} [NonAssocSemiring R] : Subsingleton (ℤ →+* R) :=\n  ⟨RingHom.ext_int⟩\n\n"}
{"name":"Int.castRingHom_int","module":"Mathlib.Data.Int.Cast.Lemmas","initialProofState":"⊢ Eq (Int.castRingHom Int) (RingHom.id Int)","decl":"@[simp]\ntheorem Int.castRingHom_int : Int.castRingHom ℤ = RingHom.id ℤ :=\n  (RingHom.id ℤ).eq_intCast'.symm\n"}
