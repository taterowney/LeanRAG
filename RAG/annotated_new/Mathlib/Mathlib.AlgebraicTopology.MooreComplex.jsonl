{"name":"AlgebraicTopology.NormalizedMooreComplex.objX_zero","module":"Mathlib.AlgebraicTopology.MooreComplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX : CategoryTheory.SimplicialObject C\n⊢ Eq (AlgebraicTopology.NormalizedMooreComplex.objX X 0) Top.top","decl":"@[simp] theorem objX_zero : objX X 0 = ⊤ :=\n  rfl\n\n"}
{"name":"AlgebraicTopology.NormalizedMooreComplex.objX_add_one","module":"Mathlib.AlgebraicTopology.MooreComplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX : CategoryTheory.SimplicialObject C\nn : Nat\n⊢ Eq (AlgebraicTopology.NormalizedMooreComplex.objX X (HAdd.hAdd n 1)) (Finset.univ.inf fun k => CategoryTheory.Limits.kernelSubobject (X.δ k.succ))","decl":"@[simp] theorem objX_add_one (n) :\n    objX X (n + 1) = Finset.univ.inf fun k : Fin (n + 1) => kernelSubobject (X.δ k.succ) :=\n  rfl\n\n"}
{"name":"AlgebraicTopology.NormalizedMooreComplex.d_squared","module":"Mathlib.AlgebraicTopology.MooreComplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX : CategoryTheory.SimplicialObject C\nn : Nat\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.NormalizedMooreComplex.objD X (HAdd.hAdd n 1)) (AlgebraicTopology.NormalizedMooreComplex.objD X n)) 0","decl":"theorem d_squared (n : ℕ) : objD X (n + 1) ≫ objD X n = 0 := by\n  -- It's a pity we need to do a case split here;\n    -- after the first erw the proofs are almost identical\n  rcases n with _ | n <;> dsimp [objD]\n  · erw [Subobject.factorThru_arrow_assoc, Category.assoc,\n      ← X.δ_comp_δ_assoc (Fin.zero_le (0 : Fin 2)),\n      ← factorThru_arrow _ _ (finset_inf_arrow_factors Finset.univ _ (0 : Fin 2) (by simp)),\n      Category.assoc, kernelSubobject_arrow_comp_assoc, zero_comp, comp_zero]\n  · erw [factorThru_right, factorThru_eq_zero, factorThru_arrow_assoc, Category.assoc,\n      ← X.δ_comp_δ (Fin.zero_le (0 : Fin (n + 3))),\n      ← factorThru_arrow _ _ (finset_inf_arrow_factors Finset.univ _ (0 : Fin (n + 3)) (by simp)),\n      Category.assoc, kernelSubobject_arrow_comp_assoc, zero_comp, comp_zero]\n\n"}
{"name":"AlgebraicTopology.NormalizedMooreComplex.obj_X","module":"Mathlib.AlgebraicTopology.MooreComplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX : CategoryTheory.SimplicialObject C\nn : Nat\n⊢ Eq ((AlgebraicTopology.NormalizedMooreComplex.obj X).X n) (CategoryTheory.Subobject.underlying.obj (AlgebraicTopology.NormalizedMooreComplex.objX X n))","decl":"/-- The normalized Moore complex functor, on objects.\n-/\n@[simps!]\ndef obj (X : SimplicialObject C) : ChainComplex C ℕ :=\n  ChainComplex.of (fun n => (objX X n : C))\n    (-- the coercion here picks a representative of the subobject\n      objD X) (d_squared X)\n\n"}
{"name":"AlgebraicTopology.NormalizedMooreComplex.obj_d","module":"Mathlib.AlgebraicTopology.MooreComplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX : CategoryTheory.SimplicialObject C\ni j : Nat\n⊢ Eq ((AlgebraicTopology.NormalizedMooreComplex.obj X).d i j) (dite (Eq i (HAdd.hAdd j 1)) (fun h => CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (AlgebraicTopology.NormalizedMooreComplex.objX.match_1 (fun x => Quiver.Hom (CategoryTheory.Subobject.underlying.obj (Finset.univ.inf fun k => CategoryTheory.Limits.kernelSubobject (X.δ k.succ))) (CategoryTheory.Subobject.underlying.obj (AlgebraicTopology.NormalizedMooreComplex.objX X x))) j (fun _ => CategoryTheory.CategoryStruct.comp (Finset.univ.inf fun k => CategoryTheory.Limits.kernelSubobject (X.δ k.succ)).arrow (CategoryTheory.CategoryStruct.comp (X.δ 0) (CategoryTheory.inv Top.top.arrow))) fun n => (Finset.univ.inf fun k => CategoryTheory.Limits.kernelSubobject (X.δ k.succ)).factorThru (CategoryTheory.CategoryStruct.comp (Finset.univ.inf fun k => CategoryTheory.Limits.kernelSubobject (X.δ k.succ)).arrow (X.δ 0)) ⋯)) fun h => 0)","decl":"/-- The normalized Moore complex functor, on objects.\n-/\n@[simps!]\ndef obj (X : SimplicialObject C) : ChainComplex C ℕ :=\n  ChainComplex.of (fun n => (objX X n : C))\n    (-- the coercion here picks a representative of the subobject\n      objD X) (d_squared X)\n\n"}
{"name":"AlgebraicTopology.NormalizedMooreComplex.map_f","module":"Mathlib.AlgebraicTopology.MooreComplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX Y : CategoryTheory.SimplicialObject C\nf : Quiver.Hom X Y\nn : Nat\n⊢ Eq ((AlgebraicTopology.NormalizedMooreComplex.map f).f n) ((AlgebraicTopology.NormalizedMooreComplex.objX Y n).factorThru (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.NormalizedMooreComplex.objX X n).arrow (f.app { unop := SimplexCategory.mk n })) ⋯)","decl":"/-- The normalized Moore complex functor, on morphisms.\n-/\n@[simps!]\ndef map (f : X ⟶ Y) : obj X ⟶ obj Y :=\n  ChainComplex.ofHom _ _ _ _ _ _\n    (fun n => factorThru _ (arrow _ ≫ f.app (op (SimplexCategory.mk n))) (by\n      cases n <;> dsimp\n      · apply top_factors\n      · refine (finset_inf_factors _).mpr fun i _ => kernelSubobject_factors _ _ ?_\n        erw [Category.assoc, ← f.naturality,\n          ← factorThru_arrow _ _ (finset_inf_arrow_factors Finset.univ _ i (by simp)),\n          Category.assoc, kernelSubobject_arrow_comp_assoc, zero_comp, comp_zero]))\n    fun n => by\n    cases n <;> dsimp [objD, objX] <;> aesop_cat\n\n"}
{"name":"AlgebraicTopology.normalizedMooreComplex_obj","module":"Mathlib.AlgebraicTopology.MooreComplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX : CategoryTheory.SimplicialObject C\n⊢ Eq ((AlgebraicTopology.normalizedMooreComplex C).obj X) (AlgebraicTopology.NormalizedMooreComplex.obj X)","decl":"/-- The (normalized) Moore complex of a simplicial object `X` in an abelian category `C`.\n\nThe `n`-th object is intersection of\nthe kernels of `X.δ i : X.obj n ⟶ X.obj (n-1)`, for `i = 1, ..., n`.\n\nThe differentials are induced from `X.δ 0`,\nwhich maps each of these intersections of kernels to the next.\n-/\n@[simps]\ndef normalizedMooreComplex : SimplicialObject C ⥤ ChainComplex C ℕ where\n  obj := obj\n  map f := map f\n  -- Porting note: Why `aesop_cat` can't do `dsimp` steps?\n  map_id X := by ext (_ | _) <;> dsimp <;> aesop_cat\n  map_comp f g := by ext (_ | _) <;> apply Subobject.eq_of_comp_arrow_eq <;> dsimp <;> aesop_cat\n\n"}
{"name":"AlgebraicTopology.normalizedMooreComplex_map","module":"Mathlib.AlgebraicTopology.MooreComplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX✝ Y✝ : CategoryTheory.SimplicialObject C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((AlgebraicTopology.normalizedMooreComplex C).map f) (AlgebraicTopology.NormalizedMooreComplex.map f)","decl":"/-- The (normalized) Moore complex of a simplicial object `X` in an abelian category `C`.\n\nThe `n`-th object is intersection of\nthe kernels of `X.δ i : X.obj n ⟶ X.obj (n-1)`, for `i = 1, ..., n`.\n\nThe differentials are induced from `X.δ 0`,\nwhich maps each of these intersections of kernels to the next.\n-/\n@[simps]\ndef normalizedMooreComplex : SimplicialObject C ⥤ ChainComplex C ℕ where\n  obj := obj\n  map f := map f\n  -- Porting note: Why `aesop_cat` can't do `dsimp` steps?\n  map_id X := by ext (_ | _) <;> dsimp <;> aesop_cat\n  map_comp f g := by ext (_ | _) <;> apply Subobject.eq_of_comp_arrow_eq <;> dsimp <;> aesop_cat\n\n"}
{"name":"AlgebraicTopology.normalizedMooreComplex_objD","module":"Mathlib.AlgebraicTopology.MooreComplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX : CategoryTheory.SimplicialObject C\nn : Nat\n⊢ Eq (((AlgebraicTopology.normalizedMooreComplex C).obj X).d (HAdd.hAdd n 1) n) (AlgebraicTopology.NormalizedMooreComplex.objD X n)","decl":"theorem normalizedMooreComplex_objD (X : SimplicialObject C) (n : ℕ) :\n    ((normalizedMooreComplex C).obj X).d (n + 1) n = NormalizedMooreComplex.objD X n :=\n-- Porting note: in mathlib, `apply ChainComplex.of_d` was enough\n  ChainComplex.of_d _ _ (d_squared X) n\n\n"}
