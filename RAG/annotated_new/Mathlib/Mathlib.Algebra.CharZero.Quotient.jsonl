{"name":"AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div","module":"Mathlib.Algebra.CharZero.Quotient","initialProofState":"R : Type u_1\ninst✝¹ : DivisionRing R\ninst✝ : CharZero R\np r : R\nz : Int\nhz : Ne z 0\n⊢ Iff (Membership.mem (AddSubgroup.zmultiples p) (HSMul.hSMul z r)) (Exists fun k => Membership.mem (AddSubgroup.zmultiples p) (HSub.hSub r (HSMul.hSMul (↑k) (HDiv.hDiv p ↑z))))","decl":"/-- `z • r` is a multiple of `p` iff `r` is `pk/z` above a multiple of `p`, where `0 ≤ k < |z|`. -/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : ℤ} (hz : z ≠ 0) :\n    z • r ∈ AddSubgroup.zmultiples p ↔\n      ∃ k : Fin z.natAbs, r - (k : ℕ) • (p / z : R) ∈ AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, ← smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) ≠ 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [← (mul_right_injective₀ hz').eq_iff]\n  simp_rw [← zsmul_eq_mul, smul_add, ← mul_smul_comm, zsmul_eq_mul (z : R)⁻¹, mul_inv_cancel₀ hz',\n    mul_one, ← natCast_zsmul, smul_smul, ← add_smul]\n  constructor\n  · rintro ⟨k, h⟩\n    simp_rw [← h]\n    refine ⟨⟨(k % z).toNat, ?_⟩, k / z, ?_⟩\n    · rw [← Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [← Int.ediv_add_emod k z]\n    rfl\n  · rintro ⟨k, n, h⟩\n    exact ⟨_, h⟩\n\n"}
{"name":"AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div","module":"Mathlib.Algebra.CharZero.Quotient","initialProofState":"R : Type u_1\ninst✝¹ : DivisionRing R\ninst✝ : CharZero R\np r : R\nn : Nat\nhn : Ne n 0\n⊢ Iff (Membership.mem (AddSubgroup.zmultiples p) (HSMul.hSMul n r)) (Exists fun k => Membership.mem (AddSubgroup.zmultiples p) (HSub.hSub r (HSMul.hSMul (↑k) (HDiv.hDiv p ↑n))))","decl":"theorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : ℕ} (hn : n ≠ 0) :\n    n • r ∈ AddSubgroup.zmultiples p ↔\n      ∃ k : Fin n, r - (k : ℕ) • (p / n : R) ∈ AddSubgroup.zmultiples p := by\n  rw [← natCast_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.natCast_ne_zero.mpr hn),\n    Int.cast_natCast]\n  rfl\n\n"}
{"name":"QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff","module":"Mathlib.Algebra.CharZero.Quotient","initialProofState":"R : Type u_1\ninst✝¹ : DivisionRing R\ninst✝ : CharZero R\np : R\nψ θ : HasQuotient.Quotient R (AddSubgroup.zmultiples p)\nz : Int\nhz : Ne z 0\n⊢ Iff (Eq (HSMul.hSMul z ψ) (HSMul.hSMul z θ)) (Exists fun k => Eq ψ (HAdd.hAdd θ ↑(HSMul.hSMul (↑k) (HDiv.hDiv p ↑z))))","decl":"theorem zmultiples_zsmul_eq_zsmul_iff {ψ θ : R ⧸ AddSubgroup.zmultiples p} {z : ℤ} (hz : z ≠ 0) :\n    z • ψ = z • θ ↔ ∃ k : Fin z.natAbs, ψ = θ + ((k : ℕ) • (p / z) : R) := by\n  induction ψ using Quotient.inductionOn\n  induction θ using Quotient.inductionOn\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk _ : R → R ⧸ Zp) = ((↑) : R → R ⧸ Zp) := rfl\n  simp only [Zp, this]\n  simp_rw [← QuotientAddGroup.mk_zsmul, ← QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, ← smul_sub, ← sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n\n"}
{"name":"QuotientAddGroup.zmultiples_nsmul_eq_nsmul_iff","module":"Mathlib.Algebra.CharZero.Quotient","initialProofState":"R : Type u_1\ninst✝¹ : DivisionRing R\ninst✝ : CharZero R\np : R\nψ θ : HasQuotient.Quotient R (AddSubgroup.zmultiples p)\nn : Nat\nhz : Ne n 0\n⊢ Iff (Eq (HSMul.hSMul n ψ) (HSMul.hSMul n θ)) (Exists fun k => Eq ψ (HAdd.hAdd θ (HSMul.hSMul ↑k ↑(HDiv.hDiv p ↑n))))","decl":"theorem zmultiples_nsmul_eq_nsmul_iff {ψ θ : R ⧸ AddSubgroup.zmultiples p} {n : ℕ} (hz : n ≠ 0) :\n    n • ψ = n • θ ↔ ∃ k : Fin n, ψ = θ + (k : ℕ) • (p / n : R) := by\n  rw [← natCast_zsmul ψ, ← natCast_zsmul θ,\n    zmultiples_zsmul_eq_zsmul_iff (Int.natCast_ne_zero.mpr hz), Int.cast_natCast]\n  rfl\n\n"}
