{"name":"Complex.instSMulCommClassOfReal","module":"Mathlib.Data.Complex.Module","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : SMul R Real\ninst✝¹ : SMul S Real\ninst✝ : SMulCommClass R S Real\n⊢ SMulCommClass R S Complex","decl":"instance (priority := 90) [SMul R ℝ] [SMul S ℝ] [SMulCommClass R S ℝ] : SMulCommClass R S ℂ where\n  smul_comm r s x := by ext <;> simp [smul_re, smul_im, smul_comm]\n\n-- priority manually adjusted in https://github.com/leanprover-community/mathlib4/pull/11980\n"}
{"name":"Complex.instIsScalarTowerOfReal","module":"Mathlib.Data.Complex.Module","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : SMul R S\ninst✝² : SMul R Real\ninst✝¹ : SMul S Real\ninst✝ : IsScalarTower R S Real\n⊢ IsScalarTower R S Complex","decl":"instance (priority := 90) [SMul R S] [SMul R ℝ] [SMul S ℝ] [IsScalarTower R S ℝ] :\n    IsScalarTower R S ℂ where\n  smul_assoc r s x := by ext <;> simp [smul_re, smul_im, smul_assoc]\n\n-- priority manually adjusted in https://github.com/leanprover-community/mathlib4/pull/11980\n"}
{"name":"Complex.instIsCentralScalarOfReal","module":"Mathlib.Data.Complex.Module","initialProofState":"R : Type u_1\ninst✝² : SMul R Real\ninst✝¹ : SMul (MulOpposite R) Real\ninst✝ : IsCentralScalar R Real\n⊢ IsCentralScalar R Complex","decl":"instance (priority := 90) [SMul R ℝ] [SMul Rᵐᵒᵖ ℝ] [IsCentralScalar R ℝ] :\n    IsCentralScalar R ℂ where\n  op_smul_eq_smul r x := by ext <;> simp [smul_re, smul_im, op_smul_eq_smul]\n\n-- priority manually adjusted in https://github.com/leanprover-community/mathlib4/pull/11980\n"}
{"name":"Complex.instStarModuleReal","module":"Mathlib.Data.Complex.Module","initialProofState":"⊢ StarModule Real Complex","decl":"instance : StarModule ℝ ℂ :=\n  ⟨fun r x => by simp only [star_def, star_trivial, real_smul, map_mul, conj_ofReal]⟩\n\n"}
{"name":"Complex.coe_algebraMap","module":"Mathlib.Data.Complex.Module","initialProofState":"⊢ Eq (⇑(algebraMap Real Complex)) Complex.ofReal","decl":"@[simp]\ntheorem coe_algebraMap : (algebraMap ℝ ℂ : ℝ → ℂ) = ((↑) : ℝ → ℂ) :=\n  rfl\n\n"}
{"name":"AlgHom.map_coe_real_complex","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra Real A\nf : AlgHom Real Complex A\nx : Real\n⊢ Eq (f ↑x) ((algebraMap Real A) x)","decl":"/-- We need this lemma since `Complex.coe_algebraMap` diverts the simp-normal form away from\n`AlgHom.commutes`. -/\n@[simp]\ntheorem _root_.AlgHom.map_coe_real_complex (f : ℂ →ₐ[ℝ] A) (x : ℝ) : f x = algebraMap ℝ A x :=\n  f.commutes x\n\n"}
{"name":"Complex.algHom_ext_iff","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra Real A\nf g : AlgHom Real Complex A\n⊢ Iff (Eq f g) (Eq (f Complex.I) (g Complex.I))","decl":"/-- Two `ℝ`-algebra homomorphisms from `ℂ` are equal if they agree on `Complex.I`. -/\n@[ext]\ntheorem algHom_ext ⦃f g : ℂ →ₐ[ℝ] A⦄ (h : f I = g I) : f = g := by\n  ext ⟨x, y⟩\n  simp only [mk_eq_add_mul_I, map_add, AlgHom.map_coe_real_complex, map_mul, h]\n\n"}
{"name":"Complex.algHom_ext","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra Real A\nf g : AlgHom Real Complex A\nh : Eq (f Complex.I) (g Complex.I)\n⊢ Eq f g","decl":"/-- Two `ℝ`-algebra homomorphisms from `ℂ` are equal if they agree on `Complex.I`. -/\n@[ext]\ntheorem algHom_ext ⦃f g : ℂ →ₐ[ℝ] A⦄ (h : f I = g I) : f = g := by\n  ext ⟨x, y⟩\n  simp only [mk_eq_add_mul_I, map_add, AlgHom.map_coe_real_complex, map_mul, h]\n\n"}
{"name":"Complex.coe_basisOneI_repr","module":"Mathlib.Data.Complex.Module","initialProofState":"z : Complex\n⊢ Eq (⇑(Complex.basisOneI.repr z)) (Matrix.vecCons z.re (Matrix.vecCons z.im Matrix.vecEmpty))","decl":"@[simp]\ntheorem coe_basisOneI_repr (z : ℂ) : ⇑(basisOneI.repr z) = ![z.re, z.im] :=\n  rfl\n\n"}
{"name":"Complex.coe_basisOneI","module":"Mathlib.Data.Complex.Module","initialProofState":"⊢ Eq (⇑Complex.basisOneI) (Matrix.vecCons 1 (Matrix.vecCons Complex.I Matrix.vecEmpty))","decl":"@[simp]\ntheorem coe_basisOneI : ⇑basisOneI = ![1, I] :=\n  funext fun i =>\n    Basis.apply_eq_iff.mpr <|\n      Finsupp.ext fun j => by\n        fin_cases i <;> fin_cases j <;>\n          -- Porting note: removed `only`, consider squeezing again\n          simp [coe_basisOneI_repr, Finsupp.single_eq_of_ne, Matrix.cons_val_zero,\n            Matrix.cons_val_one, Matrix.head_cons, Fin.one_eq_zero_iff, Ne, not_false_iff, I_re,\n            Nat.succ_succ_ne_one, one_im, I_im, one_re, Finsupp.single_eq_same, Fin.zero_eq_one_iff]\n\n"}
{"name":"Complex.coe_smul","module":"Mathlib.Data.Complex.Module","initialProofState":"E : Type u_1\ninst✝¹ : AddCommGroup E\ninst✝ : Module Complex E\nx : Real\ny : E\n⊢ Eq (HSMul.hSMul (↑x) y) (HSMul.hSMul x y)","decl":"@[simp, norm_cast]\ntheorem Complex.coe_smul {E : Type*} [AddCommGroup E] [Module ℂ E] (x : ℝ) (y : E) :\n    (x : ℂ) • y = x • y :=\n  rfl\n\n"}
{"name":"SMulCommClass.complexToReal","module":"Mathlib.Data.Complex.Module","initialProofState":"M : Type u_1\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module Complex E\ninst✝¹ : SMul M E\ninst✝ : SMulCommClass Complex M E\n⊢ SMulCommClass Real M E","decl":"/-- The scalar action of `ℝ` on a `ℂ`-module `E` induced by `Module.complexToReal` commutes with\nanother scalar action of `M` on `E` whenever the action of `ℂ` commutes with the action of `M`. -/\ninstance (priority := 900) SMulCommClass.complexToReal {M E : Type*} [AddCommGroup E] [Module ℂ E]\n    [SMul M E] [SMulCommClass ℂ M E] : SMulCommClass ℝ M E where\n  smul_comm r _ _ := smul_comm (r : ℂ) _ _\n\n"}
{"name":"IsScalarTower.complexToReal","module":"Mathlib.Data.Complex.Module","initialProofState":"M : Type u_1\nE : Type u_2\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module Complex M\ninst✝³ : AddCommGroup E\ninst✝² : Module Complex E\ninst✝¹ : SMul M E\ninst✝ : IsScalarTower Complex M E\n⊢ IsScalarTower Real M E","decl":"/-- The scalar action of `ℝ` on a `ℂ`-module `E` induced by `Module.complexToReal` associates with\nanother scalar action of `M` on `E` whenever the action of `ℂ` associates with the action of `M`. -/\ninstance IsScalarTower.complexToReal {M E : Type*} [AddCommGroup M] [Module ℂ M] [AddCommGroup E]\n    [Module ℂ E] [SMul M E] [IsScalarTower ℂ M E] : IsScalarTower ℝ M E where\n  smul_assoc r _ _ := smul_assoc (r : ℂ) _ _\n\n-- check that the following instance is implied by the one above.\n"}
{"name":"StarModule.complexToReal","module":"Mathlib.Data.Complex.Module","initialProofState":"E : Type u_1\ninst✝³ : AddCommGroup E\ninst✝² : Star E\ninst✝¹ : Module Complex E\ninst✝ : StarModule Complex E\n⊢ StarModule Real E","decl":"instance (priority := 900) StarModule.complexToReal {E : Type*} [AddCommGroup E] [Star E]\n    [Module ℂ E] [StarModule ℂ E] : StarModule ℝ E :=\n  ⟨fun r a => by rw [← smul_one_smul ℂ r a, star_smul, star_smul, star_one, smul_one_smul]⟩\n\n"}
{"name":"Complex.reLm_coe","module":"Mathlib.Data.Complex.Module","initialProofState":"⊢ Eq (⇑Complex.reLm) Complex.re","decl":"@[simp]\ntheorem reLm_coe : ⇑reLm = re :=\n  rfl\n\n"}
{"name":"Complex.imLm_coe","module":"Mathlib.Data.Complex.Module","initialProofState":"⊢ Eq (⇑Complex.imLm) Complex.im","decl":"@[simp]\ntheorem imLm_coe : ⇑imLm = im :=\n  rfl\n\n"}
{"name":"Complex.ofRealAm_coe","module":"Mathlib.Data.Complex.Module","initialProofState":"⊢ Eq (⇑Complex.ofRealAm) Complex.ofReal","decl":"@[simp]\ntheorem ofRealAm_coe : ⇑ofRealAm = ((↑) : ℝ → ℂ) :=\n  rfl\n\n"}
{"name":"Complex.conjAe_coe","module":"Mathlib.Data.Complex.Module","initialProofState":"⊢ Eq ⇑Complex.conjAe ⇑(starRingEnd Complex)","decl":"@[simp]\ntheorem conjAe_coe : ⇑conjAe = conj :=\n  rfl\n\n"}
{"name":"Complex.toMatrix_conjAe","module":"Mathlib.Data.Complex.Module","initialProofState":"⊢ Eq ((LinearMap.toMatrix Complex.basisOneI Complex.basisOneI) Complex.conjAe.toLinearMap) (Matrix.of (Matrix.vecCons (Matrix.vecCons 1 (Matrix.vecCons 0 Matrix.vecEmpty)) (Matrix.vecCons (Matrix.vecCons 0 (Matrix.vecCons (-1) Matrix.vecEmpty)) Matrix.vecEmpty)))","decl":"/-- The matrix representation of `conjAe`. -/\n@[simp]\ntheorem toMatrix_conjAe :\n    LinearMap.toMatrix basisOneI basisOneI conjAe.toLinearMap = !![1, 0; 0, -1] := by\n  ext i j\n  -- Porting note: replaced non-terminal `simp [LinearMap.toMatrix_apply]`\n  fin_cases i <;> fin_cases j <;> simp [LinearMap.toMatrix_apply]\n\n"}
{"name":"Complex.real_algHom_eq_id_or_conj","module":"Mathlib.Data.Complex.Module","initialProofState":"f : AlgHom Real Complex Complex\n⊢ Or (Eq f (AlgHom.id Real Complex)) (Eq f ↑Complex.conjAe)","decl":"/-- The identity and the complex conjugation are the only two `ℝ`-algebra homomorphisms of `ℂ`. -/\ntheorem real_algHom_eq_id_or_conj (f : ℂ →ₐ[ℝ] ℂ) : f = AlgHom.id ℝ ℂ ∨ f = conjAe := by\n  refine\n      (eq_or_eq_neg_of_sq_eq_sq (f I) I <| by rw [← map_pow, I_sq, map_neg, map_one]).imp ?_ ?_ <;>\n    refine fun h => algHom_ext ?_\n  exacts [h, conj_I.symm ▸ h]\n\n"}
{"name":"Complex.equivRealProdLm_apply","module":"Mathlib.Data.Complex.Module","initialProofState":"a✝ : Complex\n⊢ Eq (Complex.equivRealProdLm a✝) { fst := a✝.re, snd := a✝.im }","decl":"/-- The natural `LinearEquiv` from `ℂ` to `ℝ × ℝ`. -/\n@[simps! (config := { simpRhs := true }) apply symm_apply_re symm_apply_im]\ndef equivRealProdLm : ℂ ≃ₗ[ℝ] ℝ × ℝ :=\n  { equivRealProdAddHom with\n    -- Porting note: `simp` has issues with `Prod.smul_def`\n    map_smul' := fun r c => by simp [equivRealProdAddHom, Prod.smul_def, smul_eq_mul] }\n\n"}
{"name":"Complex.equivRealProdLm_symm_apply_im","module":"Mathlib.Data.Complex.Module","initialProofState":"a✝ : Prod Real Real\n⊢ Eq (Complex.equivRealProdLm.symm a✝).im a✝.2","decl":"/-- The natural `LinearEquiv` from `ℂ` to `ℝ × ℝ`. -/\n@[simps! (config := { simpRhs := true }) apply symm_apply_re symm_apply_im]\ndef equivRealProdLm : ℂ ≃ₗ[ℝ] ℝ × ℝ :=\n  { equivRealProdAddHom with\n    -- Porting note: `simp` has issues with `Prod.smul_def`\n    map_smul' := fun r c => by simp [equivRealProdAddHom, Prod.smul_def, smul_eq_mul] }\n\n"}
{"name":"Complex.equivRealProdLm_symm_apply_re","module":"Mathlib.Data.Complex.Module","initialProofState":"a✝ : Prod Real Real\n⊢ Eq (Complex.equivRealProdLm.symm a✝).re a✝.1","decl":"/-- The natural `LinearEquiv` from `ℂ` to `ℝ × ℝ`. -/\n@[simps! (config := { simpRhs := true }) apply symm_apply_re symm_apply_im]\ndef equivRealProdLm : ℂ ≃ₗ[ℝ] ℝ × ℝ :=\n  { equivRealProdAddHom with\n    -- Porting note: `simp` has issues with `Prod.smul_def`\n    map_smul' := fun r c => by simp [equivRealProdAddHom, Prod.smul_def, smul_eq_mul] }\n\n"}
{"name":"Complex.equivRealProdLm_symm_apply","module":"Mathlib.Data.Complex.Module","initialProofState":"p : Prod Real Real\n⊢ Eq (Complex.equivRealProdLm.symm p) (HAdd.hAdd (↑p.1) (HMul.hMul (↑p.2) Complex.I))","decl":"theorem equivRealProdLm_symm_apply (p : ℝ × ℝ) :\n    Complex.equivRealProdLm.symm p = p.1 + p.2 * Complex.I := Complex.equivRealProd_symm_apply p\n"}
{"name":"Complex.liftAux_apply","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝¹ : Ring A\ninst✝ : Algebra Real A\nI' : A\nhI' : Eq (HMul.hMul I' I') (-1)\nz : Complex\n⊢ Eq ((Complex.liftAux I' hI') z) (HAdd.hAdd ((algebraMap Real A) z.re) (HSMul.hSMul z.im I'))","decl":"@[simp]\ntheorem liftAux_apply (I' : A) (hI') (z : ℂ) : liftAux I' hI' z = algebraMap ℝ A z.re + z.im • I' :=\n  rfl\n\n"}
{"name":"Complex.liftAux_apply_I","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝¹ : Ring A\ninst✝ : Algebra Real A\nI' : A\nhI' : Eq (HMul.hMul I' I') (-1)\n⊢ Eq ((Complex.liftAux I' hI') Complex.I) I'","decl":"theorem liftAux_apply_I (I' : A) (hI') : liftAux I' hI' I = I' := by simp\n\n"}
{"name":"Complex.lift_apply","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝¹ : Ring A\ninst✝ : Algebra Real A\nI' : Subtype fun I' => Eq (HMul.hMul I' I') (-1)\n⊢ Eq (Complex.lift I') (Complex.liftAux ↑I' ⋯)","decl":"/-- A universal property of the complex numbers, providing a unique `ℂ →ₐ[ℝ] A` for every element\nof `A` which squares to `-1`.\n\nThis can be used to embed the complex numbers in the `Quaternion`s.\n\nThis isomorphism is named to match the very similar `Zsqrtd.lift`. -/\n@[simps (config := { simpRhs := true })]\ndef lift : { I' : A // I' * I' = -1 } ≃ (ℂ →ₐ[ℝ] A) where\n  toFun I' := liftAux I' I'.prop\n  invFun F := ⟨F I, by rw [← map_mul, I_mul_I, map_neg, map_one]⟩\n  left_inv I' := Subtype.ext <| liftAux_apply_I (I' : A) I'.prop\n  right_inv _ := algHom_ext <| liftAux_apply_I _ _\n\n-- When applied to `Complex.I` itself, `lift` is the identity.\n"}
{"name":"Complex.lift_symm_apply_coe","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝¹ : Ring A\ninst✝ : Algebra Real A\nF : AlgHom Real Complex A\n⊢ Eq (↑(Complex.lift.symm F)) (F Complex.I)","decl":"/-- A universal property of the complex numbers, providing a unique `ℂ →ₐ[ℝ] A` for every element\nof `A` which squares to `-1`.\n\nThis can be used to embed the complex numbers in the `Quaternion`s.\n\nThis isomorphism is named to match the very similar `Zsqrtd.lift`. -/\n@[simps (config := { simpRhs := true })]\ndef lift : { I' : A // I' * I' = -1 } ≃ (ℂ →ₐ[ℝ] A) where\n  toFun I' := liftAux I' I'.prop\n  invFun F := ⟨F I, by rw [← map_mul, I_mul_I, map_neg, map_one]⟩\n  left_inv I' := Subtype.ext <| liftAux_apply_I (I' : A) I'.prop\n  right_inv _ := algHom_ext <| liftAux_apply_I _ _\n\n-- When applied to `Complex.I` itself, `lift` is the identity.\n"}
{"name":"Complex.liftAux_I","module":"Mathlib.Data.Complex.Module","initialProofState":"⊢ Eq (Complex.liftAux Complex.I Complex.I_mul_I) (AlgHom.id Real Complex)","decl":"@[simp]\ntheorem liftAux_I : liftAux I I_mul_I = AlgHom.id ℝ ℂ :=\n  algHom_ext <| liftAux_apply_I _ _\n\n-- When applied to `-Complex.I`, `lift` is conjugation, `conj`.\n"}
{"name":"Complex.liftAux_neg_I","module":"Mathlib.Data.Complex.Module","initialProofState":"⊢ Eq (Complex.liftAux (Neg.neg Complex.I) ⋯) ↑Complex.conjAe","decl":"@[simp]\ntheorem liftAux_neg_I : liftAux (-I) ((neg_mul_neg _ _).trans I_mul_I) = conjAe :=\n  algHom_ext <| (liftAux_apply_I _ _).trans conj_I.symm\n\n"}
{"name":"skewAdjoint.negISMul_apply_coe","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\na : Subtype fun x => Membership.mem (skewAdjoint A) x\n⊢ Eq (↑(skewAdjoint.negISMul a)) (HSMul.hSMul (Neg.neg Complex.I) ↑a)","decl":"/-- Create a `selfAdjoint` element from a `skewAdjoint` element by multiplying by the scalar\n`-Complex.I`. -/\n@[simps]\ndef skewAdjoint.negISMul : skewAdjoint A →ₗ[ℝ] selfAdjoint A where\n  toFun a :=\n    ⟨-I • ↑a, by\n      simp only [neg_smul, neg_mem_iff, selfAdjoint.mem_iff, star_smul, star_def, conj_I,\n        star_val_eq, smul_neg, neg_neg]⟩\n  map_add' a b := by\n    ext\n    simp only [AddSubgroup.coe_add, smul_add, AddMemClass.mk_add_mk]\n  map_smul' a b := by\n    ext\n    simp only [neg_smul, skewAdjoint.val_smul, AddSubgroup.coe_mk, RingHom.id_apply,\n      selfAdjoint.val_smul, smul_neg, neg_inj]\n    rw [smul_comm]\n\n"}
{"name":"skewAdjoint.I_smul_neg_I","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\na : Subtype fun x => Membership.mem (skewAdjoint A) x\n⊢ Eq (HSMul.hSMul Complex.I ↑(skewAdjoint.negISMul a)) ↑a","decl":"theorem skewAdjoint.I_smul_neg_I (a : skewAdjoint A) : I • (skewAdjoint.negISMul a : A) = a := by\n  simp only [smul_smul, skewAdjoint.negISMul_apply_coe, neg_smul, smul_neg, I_mul_I, one_smul,\n    neg_neg]\n\n"}
{"name":"realPart_apply_coe","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\na : A\n⊢ Eq (↑(realPart a)) (HSMul.hSMul (Inv.inv 2) (HAdd.hAdd a (Star.star a)))","decl":"theorem realPart_apply_coe (a : A) : (ℜ a : A) = (2 : ℝ)⁻¹ • (a + star a) := by\n  unfold realPart\n  simp only [selfAdjointPart_apply_coe, invOf_eq_inv]\n\n"}
{"name":"imaginaryPart_apply_coe","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\na : A\n⊢ Eq (↑(imaginaryPart a)) (HSMul.hSMul (Neg.neg Complex.I) (HSMul.hSMul (Inv.inv 2) (HSub.hSub a (Star.star a))))","decl":"theorem imaginaryPart_apply_coe (a : A) : (ℑ a : A) = -I • (2 : ℝ)⁻¹ • (a - star a) := by\n  unfold imaginaryPart\n  simp only [LinearMap.coe_comp, Function.comp_apply, skewAdjoint.negISMul_apply_coe,\n    skewAdjointPart_apply_coe, invOf_eq_inv, neg_smul]\n\n"}
{"name":"realPart_add_I_smul_imaginaryPart","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\na : A\n⊢ Eq (HAdd.hAdd (↑(realPart a)) (HSMul.hSMul Complex.I ↑(imaginaryPart a))) a","decl":"/-- The standard decomposition of `ℜ a + Complex.I • ℑ a = a` of an element of a star module over\n`ℂ` into a linear combination of self adjoint elements. -/\ntheorem realPart_add_I_smul_imaginaryPart (a : A) : (ℜ a : A) + I • (ℑ a : A) = a := by\n  simpa only [smul_smul, realPart_apply_coe, imaginaryPart_apply_coe, neg_smul, I_mul_I, one_smul,\n    neg_sub, add_add_sub_cancel, smul_sub, smul_add, neg_sub_neg, invOf_eq_inv] using\n    invOf_two_smul_add_invOf_two_smul ℝ a\n\n"}
{"name":"realPart_I_smul","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\na : A\n⊢ Eq (realPart (HSMul.hSMul Complex.I a)) (Neg.neg (imaginaryPart a))","decl":"@[simp]\ntheorem realPart_I_smul (a : A) : ℜ (I • a) = -ℑ a := by\n  ext\n  -- Porting note: was\n  -- simp [smul_comm I, smul_sub, sub_eq_add_neg, add_comm]\n  rw [realPart_apply_coe, NegMemClass.coe_neg, imaginaryPart_apply_coe, neg_smul, neg_neg,\n    smul_comm I, star_smul, star_def, conj_I, smul_sub, neg_smul, sub_eq_add_neg]\n\n"}
{"name":"imaginaryPart_I_smul","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\na : A\n⊢ Eq (imaginaryPart (HSMul.hSMul Complex.I a)) (realPart a)","decl":"@[simp]\ntheorem imaginaryPart_I_smul (a : A) : ℑ (I • a) = ℜ a := by\n  ext\n  -- Porting note: was\n  -- simp [smul_comm I, smul_smul I]\n  rw [realPart_apply_coe, imaginaryPart_apply_coe, smul_comm]\n  simp [← smul_assoc]\n\n"}
{"name":"realPart_smul","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\nz : Complex\na : A\n⊢ Eq (realPart (HSMul.hSMul z a)) (HSub.hSub (HSMul.hSMul z.re (realPart a)) (HSMul.hSMul z.im (imaginaryPart a)))","decl":"theorem realPart_smul (z : ℂ) (a : A) : ℜ (z • a) = z.re • ℜ a - z.im • ℑ a := by\n  have := by congrm (ℜ ($((re_add_im z).symm) • a))\n  simpa [-re_add_im, add_smul, ← smul_smul, sub_eq_add_neg]\n\n"}
{"name":"imaginaryPart_smul","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\nz : Complex\na : A\n⊢ Eq (imaginaryPart (HSMul.hSMul z a)) (HAdd.hAdd (HSMul.hSMul z.re (imaginaryPart a)) (HSMul.hSMul z.im (realPart a)))","decl":"theorem imaginaryPart_smul (z : ℂ) (a : A) : ℑ (z • a) = z.re • ℑ a + z.im • ℜ a := by\n  have := by congrm (ℑ ($((re_add_im z).symm) • a))\n  simpa [-re_add_im, add_smul, ← smul_smul]\n\n"}
{"name":"skewAdjointPart_eq_I_smul_imaginaryPart","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\nx : A\n⊢ Eq (↑((skewAdjointPart Real) x)) (HSMul.hSMul Complex.I ↑(imaginaryPart x))","decl":"lemma skewAdjointPart_eq_I_smul_imaginaryPart (x : A) :\n    (skewAdjointPart ℝ x : A) = I • (imaginaryPart x : A) := by\n  simp [imaginaryPart_apply_coe, smul_smul]\n\n"}
{"name":"imaginaryPart_eq_neg_I_smul_skewAdjointPart","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\nx : A\n⊢ Eq (↑(imaginaryPart x)) (HSMul.hSMul (Neg.neg Complex.I) ↑((skewAdjointPart Real) x))","decl":"lemma imaginaryPart_eq_neg_I_smul_skewAdjointPart (x : A) :\n    (imaginaryPart x : A) = -I • (skewAdjointPart ℝ x : A) :=\n  rfl\n\n"}
{"name":"IsSelfAdjoint.coe_realPart","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\nx : A\nhx : IsSelfAdjoint x\n⊢ Eq (↑(realPart x)) x","decl":"lemma IsSelfAdjoint.coe_realPart {x : A} (hx : IsSelfAdjoint x) :\n    (ℜ x : A) = x :=\n  hx.coe_selfAdjointPart_apply ℝ\n\n"}
{"name":"IsSelfAdjoint.imaginaryPart","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\nx : A\nhx : IsSelfAdjoint x\n⊢ Eq (imaginaryPart x) 0","decl":"nonrec lemma IsSelfAdjoint.imaginaryPart {x : A} (hx : IsSelfAdjoint x) :\n    ℑ x = 0 := by\n  rw [imaginaryPart, LinearMap.comp_apply, hx.skewAdjointPart_apply _, map_zero]\n\n"}
{"name":"realPart_comp_subtype_selfAdjoint","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\n⊢ Eq (realPart.comp (selfAdjoint.submodule Real A).subtype) LinearMap.id","decl":"lemma realPart_comp_subtype_selfAdjoint :\n    realPart.comp (selfAdjoint.submodule ℝ A).subtype = LinearMap.id :=\n  selfAdjointPart_comp_subtype_selfAdjoint ℝ\n\n"}
{"name":"imaginaryPart_comp_subtype_selfAdjoint","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\n⊢ Eq (imaginaryPart.comp (selfAdjoint.submodule Real A).subtype) 0","decl":"lemma imaginaryPart_comp_subtype_selfAdjoint :\n    imaginaryPart.comp (selfAdjoint.submodule ℝ A).subtype = 0 := by\n  rw [imaginaryPart, LinearMap.comp_assoc, skewAdjointPart_comp_subtype_selfAdjoint,\n    LinearMap.comp_zero]\n\n"}
{"name":"imaginaryPart_realPart","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\nx : A\n⊢ Eq (imaginaryPart ↑(realPart x)) 0","decl":"@[simp]\nlemma imaginaryPart_realPart {x : A} : ℑ (ℜ x : A) = 0 :=\n  (ℜ x).property.imaginaryPart\n\n"}
{"name":"imaginaryPart_imaginaryPart","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\nx : A\n⊢ Eq (imaginaryPart ↑(imaginaryPart x)) 0","decl":"@[simp]\nlemma imaginaryPart_imaginaryPart {x : A} : ℑ (ℑ x : A) = 0 :=\n  (ℑ x).property.imaginaryPart\n\n"}
{"name":"realPart_idem","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\nx : A\n⊢ Eq (realPart ↑(realPart x)) (realPart x)","decl":"@[simp]\nlemma realPart_idem {x : A} : ℜ (ℜ x : A) = ℜ x :=\n  Subtype.ext <| (ℜ x).property.coe_realPart\n\n"}
{"name":"realPart_imaginaryPart","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\nx : A\n⊢ Eq (realPart ↑(imaginaryPart x)) (imaginaryPart x)","decl":"@[simp]\nlemma realPart_imaginaryPart {x : A} : ℜ (ℑ x : A) = ℑ x :=\n  Subtype.ext <| (ℑ x).property.coe_realPart\n\n"}
{"name":"realPart_surjective","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\n⊢ Function.Surjective ⇑realPart","decl":"lemma realPart_surjective : Function.Surjective (realPart (A := A)) :=\n  fun x ↦ ⟨(x : A), Subtype.ext x.property.coe_realPart⟩\n\n"}
{"name":"imaginaryPart_surjective","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\n⊢ Function.Surjective ⇑imaginaryPart","decl":"lemma imaginaryPart_surjective : Function.Surjective (imaginaryPart (A := A)) :=\n  fun x ↦\n    ⟨I • (x : A), Subtype.ext <| by simp only [imaginaryPart_I_smul, x.property.coe_realPart]⟩\n\n"}
{"name":"span_selfAdjoint","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_1\ninst✝³ : AddCommGroup A\ninst✝² : Module Complex A\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule Complex A\n⊢ Eq (Submodule.span Complex ↑(selfAdjoint A)) Top.top","decl":"lemma span_selfAdjoint : span ℂ (selfAdjoint A : Set A) = ⊤ := by\n  refine eq_top_iff'.mpr fun x ↦ ?_\n  rw [← realPart_add_I_smul_imaginaryPart x]\n  exact add_mem (subset_span (ℜ x).property) <|\n    SMulMemClass.smul_mem _ <| subset_span (ℑ x).property\n\n"}
{"name":"Complex.selfAdjointEquiv_apply","module":"Mathlib.Data.Complex.Module","initialProofState":"z : Subtype fun x => Membership.mem (selfAdjoint Complex) x\n⊢ Eq (Complex.selfAdjointEquiv z) (↑z).re","decl":"/-- The natural `ℝ`-linear equivalence between `selfAdjoint ℂ` and `ℝ`. -/\n@[simps apply symm_apply]\ndef Complex.selfAdjointEquiv : selfAdjoint ℂ ≃ₗ[ℝ] ℝ where\n  toFun := fun z ↦ (z : ℂ).re\n  invFun := fun x ↦ ⟨x, conj_ofReal x⟩\n  left_inv := fun z ↦ Subtype.ext <| conj_eq_iff_re.mp z.property.star_eq\n  right_inv := fun _ ↦ rfl\n  map_add' := by simp\n  map_smul' := by simp\n\n"}
{"name":"Complex.selfAdjointEquiv_symm_apply","module":"Mathlib.Data.Complex.Module","initialProofState":"x : Real\n⊢ Eq (Complex.selfAdjointEquiv.symm x) ⟨↑x, ⋯⟩","decl":"/-- The natural `ℝ`-linear equivalence between `selfAdjoint ℂ` and `ℝ`. -/\n@[simps apply symm_apply]\ndef Complex.selfAdjointEquiv : selfAdjoint ℂ ≃ₗ[ℝ] ℝ where\n  toFun := fun z ↦ (z : ℂ).re\n  invFun := fun x ↦ ⟨x, conj_ofReal x⟩\n  left_inv := fun z ↦ Subtype.ext <| conj_eq_iff_re.mp z.property.star_eq\n  right_inv := fun _ ↦ rfl\n  map_add' := by simp\n  map_smul' := by simp\n\n"}
{"name":"Complex.coe_selfAdjointEquiv","module":"Mathlib.Data.Complex.Module","initialProofState":"z : Subtype fun x => Membership.mem (selfAdjoint Complex) x\n⊢ Eq ↑(Complex.selfAdjointEquiv z) ↑z","decl":"lemma Complex.coe_selfAdjointEquiv (z : selfAdjoint ℂ) :\n    (selfAdjointEquiv z : ℂ) = z := by\n  simpa [selfAdjointEquiv_symm_apply]\n    using (congr_arg Subtype.val <| Complex.selfAdjointEquiv.left_inv z)\n\n"}
{"name":"realPart_ofReal","module":"Mathlib.Data.Complex.Module","initialProofState":"r : Real\n⊢ Eq ↑(realPart ↑r) ↑r","decl":"@[simp]\nlemma realPart_ofReal (r : ℝ) : (ℜ (r : ℂ) : ℂ) = r := by\n  rw [realPart_apply_coe, star_def, conj_ofReal, ← two_smul ℝ (r : ℂ)]\n  simp\n\n"}
{"name":"imaginaryPart_ofReal","module":"Mathlib.Data.Complex.Module","initialProofState":"r : Real\n⊢ Eq (imaginaryPart ↑r) 0","decl":"@[simp]\nlemma imaginaryPart_ofReal (r : ℝ) : ℑ (r : ℂ) = 0 := by\n  ext1; simp [imaginaryPart_apply_coe, conj_ofReal]\n\n"}
{"name":"Complex.coe_realPart","module":"Mathlib.Data.Complex.Module","initialProofState":"z : Complex\n⊢ Eq ↑(realPart z) ↑z.re","decl":"lemma Complex.coe_realPart (z : ℂ) : (ℜ z : ℂ) = z.re := calc\n  (ℜ z : ℂ) = (↑(ℜ (↑z.re + ↑z.im * I))) := by congrm (ℜ $((re_add_im z).symm))\n  _         = z.re                       := by\n    rw [map_add, AddSubmonoid.coe_add, mul_comm, ← smul_eq_mul, realPart_I_smul]\n    simp [conj_ofReal, ← two_mul]\n\n"}
{"name":"star_mul_self_add_self_mul_star","module":"Mathlib.Data.Complex.Module","initialProofState":"A : Type u_2\ninst✝⁵ : NonUnitalRing A\ninst✝⁴ : StarRing A\ninst✝³ : Module Complex A\ninst✝² : IsScalarTower Complex A A\ninst✝¹ : SMulCommClass Complex A A\ninst✝ : StarModule Complex A\na : A\n⊢ Eq (HAdd.hAdd (HMul.hMul (Star.star a) a) (HMul.hMul a (Star.star a))) (HSMul.hSMul 2 (HAdd.hAdd (HMul.hMul ↑(realPart a) ↑(realPart a)) (HMul.hMul ↑(imaginaryPart a) ↑(imaginaryPart a))))","decl":"lemma star_mul_self_add_self_mul_star {A : Type*} [NonUnitalRing A] [StarRing A]\n    [Module ℂ A] [IsScalarTower ℂ A A] [SMulCommClass ℂ A A] [StarModule ℂ A] (a : A) :\n    star a * a + a * star a = 2 • (ℜ a * ℜ a + ℑ a * ℑ a) :=\n  have a_eq := (realPart_add_I_smul_imaginaryPart a).symm\n  calc\n    star a * a + a * star a = _ :=\n      congr((star $(a_eq)) * $(a_eq) + $(a_eq) * (star $(a_eq)))\n    _ = 2 • (ℜ a * ℜ a + ℑ a * ℑ a) := by\n      simp [mul_add, add_mul, smul_smul, two_smul, mul_smul_comm,\n        smul_mul_assoc]\n      abel\n\n"}
