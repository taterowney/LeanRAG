{"name":"MeasureTheory.Measure.le_dirac_apply","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : Set α\na : α\n⊢ LE.le (s.indicator 1 a) ((MeasureTheory.Measure.dirac a) s)","decl":"theorem le_dirac_apply {a} : s.indicator 1 a ≤ dirac a s :=\n  OuterMeasure.dirac_apply a s ▸ le_toMeasure_apply _ _ _\n\n"}
{"name":"MeasureTheory.Measure.dirac_apply'","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : Set α\na : α\nhs : MeasurableSet s\n⊢ Eq ((MeasureTheory.Measure.dirac a) s) (s.indicator 1 a)","decl":"@[simp]\ntheorem dirac_apply' (a : α) (hs : MeasurableSet s) : dirac a s = s.indicator 1 a :=\n  toMeasure_apply _ _ hs\n\n"}
{"name":"MeasureTheory.Measure.dirac_apply_of_mem","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : Set α\na : α\nh : Membership.mem s a\n⊢ Eq ((MeasureTheory.Measure.dirac a) s) 1","decl":"@[simp]\ntheorem dirac_apply_of_mem {a : α} (h : a ∈ s) : dirac a s = 1 := by\n  have : ∀ t : Set α, a ∈ t → t.indicator (1 : α → ℝ≥0∞) a = 1 := fun t ht => indicator_of_mem ht 1\n  refine le_antisymm (this univ trivial ▸ ?_) (this s h ▸ le_dirac_apply)\n  rw [← dirac_apply' a MeasurableSet.univ]\n  exact measure_mono (subset_univ s)\n\n"}
{"name":"MeasureTheory.Measure.dirac_apply","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSingletonClass α\na : α\ns : Set α\n⊢ Eq ((MeasureTheory.Measure.dirac a) s) (s.indicator 1 a)","decl":"@[simp]\ntheorem dirac_apply [MeasurableSingletonClass α] (a : α) (s : Set α) :\n    dirac a s = s.indicator 1 a := by\n  by_cases h : a ∈ s; · rw [dirac_apply_of_mem h, indicator_of_mem h, Pi.one_apply]\n  rw [indicator_of_not_mem h, ← nonpos_iff_eq_zero]\n  calc\n    dirac a s ≤ dirac a {a}ᶜ := measure_mono (subset_compl_comm.1 <| singleton_subset_iff.2 h)\n    _ = 0 := by simp [dirac_apply' _ (measurableSet_singleton _).compl]\n\n"}
{"name":"MeasureTheory.Measure.dirac_ne_zero","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\na : α\n⊢ Ne (MeasureTheory.Measure.dirac a) 0","decl":"@[simp] lemma dirac_ne_zero : dirac a ≠ 0 :=\n  fun h ↦ by simpa [h] using dirac_apply_of_mem (mem_univ a)\n\n"}
{"name":"MeasureTheory.Measure.map_dirac","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nhf : Measurable f\na : α\n⊢ Eq (MeasureTheory.Measure.map f (MeasureTheory.Measure.dirac a)) (MeasureTheory.Measure.dirac (f a))","decl":"theorem map_dirac {f : α → β} (hf : Measurable f) (a : α) : (dirac a).map f = dirac (f a) := by\n  classical\n  exact ext fun s hs => by simp [hs, map_apply hf hs, hf hs, indicator_apply]\n\n"}
{"name":"MeasureTheory.Measure.map_const","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nc : β\n⊢ Eq (MeasureTheory.Measure.map (fun x => c) μ) (HSMul.hSMul (μ Set.univ) (MeasureTheory.Measure.dirac c))","decl":"lemma map_const (μ : Measure α) (c : β) : μ.map (fun _ ↦ c) = (μ Set.univ) • dirac c := by\n  ext s hs\n  simp only [aemeasurable_const, measurable_const, Measure.coe_smul, Pi.smul_apply,\n    dirac_apply' _ hs, smul_eq_mul]\n  classical\n  rw [Measure.map_apply measurable_const hs, Set.preimage_const]\n  by_cases hsc : c ∈ s\n  · rw [(Set.indicator_eq_one_iff_mem _).mpr hsc, mul_one, if_pos hsc]\n  · rw [if_neg hsc, (Set.indicator_eq_zero_iff_not_mem _).mpr hsc, measure_empty, mul_zero]\n\n"}
{"name":"MeasureTheory.Measure.restrict_singleton","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\na : α\n⊢ Eq (μ.restrict (Singleton.singleton a)) (HSMul.hSMul (μ (Singleton.singleton a)) (MeasureTheory.Measure.dirac a))","decl":"@[simp]\ntheorem restrict_singleton (μ : Measure α) (a : α) : μ.restrict {a} = μ {a} • dirac a := by\n  ext1 s hs\n  by_cases ha : a ∈ s\n  · have : s ∩ {a} = {a} := by simpa\n    simp [*]\n  · have : s ∩ {a} = ∅ := inter_singleton_eq_empty.2 ha\n    simp [*]\n\n"}
{"name":"MeasureTheory.Measure.ext_of_singleton","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : Countable α\nμ ν : MeasureTheory.Measure α\nh : ∀ (a : α), Eq (μ (Singleton.singleton a)) (ν (Singleton.singleton a))\n⊢ Eq μ ν","decl":"/-- Two measures on a countable space are equal if they agree on singletons. -/\ntheorem ext_of_singleton [Countable α] {μ ν : Measure α} (h : ∀ a, μ {a} = ν {a}) : μ = ν :=\n  ext_of_sUnion_eq_univ (countable_range singleton) (by aesop) (by aesop)\n\n"}
{"name":"MeasureTheory.Measure.ext_iff_singleton","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : Countable α\nμ ν : MeasureTheory.Measure α\n⊢ Iff (Eq μ ν) (∀ (a : α), Eq (μ (Singleton.singleton a)) (ν (Singleton.singleton a)))","decl":"/-- Two measures on a countable space are equal if and only if they agree on singletons. -/\ntheorem ext_iff_singleton [Countable α] {μ ν : Measure α} : μ = ν ↔ ∀ a, μ {a} = ν {a} :=\n  ⟨fun h _ ↦ h ▸ rfl, ext_of_singleton⟩\n\n"}
{"name":"MeasureTheory.Measure.map_eq_sum","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\ninst✝¹ : Countable β\ninst✝ : MeasurableSingletonClass β\nμ : MeasureTheory.Measure α\nf : α → β\nhf : Measurable f\n⊢ Eq (MeasureTheory.Measure.map f μ) (MeasureTheory.Measure.sum fun b => HSMul.hSMul (μ (Set.preimage f (Singleton.singleton b))) (MeasureTheory.Measure.dirac b))","decl":"/-- If `f` is a map with countable codomain, then `μ.map f` is a sum of Dirac measures. -/\ntheorem map_eq_sum [Countable β] [MeasurableSingletonClass β] (μ : Measure α) (f : α → β)\n    (hf : Measurable f) : μ.map f = sum fun b : β => μ (f ⁻¹' {b}) • dirac b := by\n  ext s\n  have : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y}) := fun y _ => hf (measurableSet_singleton _)\n  simp [← tsum_measure_preimage_singleton (to_countable s) this, *,\n    tsum_subtype s fun b => μ (f ⁻¹' {b}), ← indicator_mul_right s fun b => μ (f ⁻¹' {b})]\n\n"}
{"name":"MeasureTheory.Measure.sum_smul_dirac","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : Countable α\ninst✝ : MeasurableSingletonClass α\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.Measure.sum fun a => HSMul.hSMul (μ (Singleton.singleton a)) (MeasureTheory.Measure.dirac a)) μ","decl":"/-- A measure on a countable type is a sum of Dirac measures. -/\n@[simp]\ntheorem sum_smul_dirac [Countable α] [MeasurableSingletonClass α] (μ : Measure α) :\n    (sum fun a => μ {a} • dirac a) = μ := by simpa using (map_eq_sum μ id measurable_id).symm\n\n"}
{"name":"MeasureTheory.Measure.tsum_indicator_apply_singleton","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : Countable α\ninst✝ : MeasurableSingletonClass α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (tsum fun x => s.indicator (fun x => μ (Singleton.singleton x)) x) (μ s)","decl":"/-- Given that `α` is a countable, measurable space with all singleton sets measurable,\nwrite the measure of a set `s` as the sum of the measure of `{x}` for all `x ∈ s`. -/\ntheorem tsum_indicator_apply_singleton [Countable α] [MeasurableSingletonClass α] (μ : Measure α)\n    (s : Set α) (hs : MeasurableSet s) : (∑' x : α, s.indicator (fun x => μ {x}) x) = μ s := by\n  classical\n  calc\n    (∑' x : α, s.indicator (fun x => μ {x}) x) =\n      Measure.sum (fun a => μ {a} • Measure.dirac a) s := by\n      simp only [Measure.sum_apply _ hs, Measure.smul_apply, smul_eq_mul, Measure.dirac_apply,\n        Set.indicator_apply, mul_ite, Pi.one_apply, mul_one, mul_zero]\n    _ = μ s := by rw [μ.sum_smul_dirac]\n\n"}
{"name":"MeasureTheory.mem_ae_dirac_iff","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : Set α\na : α\nhs : MeasurableSet s\n⊢ Iff (Membership.mem (MeasureTheory.ae (MeasureTheory.Measure.dirac a)) s) (Membership.mem s a)","decl":"theorem mem_ae_dirac_iff {a : α} (hs : MeasurableSet s) : s ∈ ae (dirac a) ↔ a ∈ s := by\n  by_cases a ∈ s <;> simp [mem_ae_iff, dirac_apply', hs.compl, indicator_apply, *]\n\n"}
{"name":"MeasureTheory.ae_dirac_iff","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\na : α\np : α → Prop\nhp : MeasurableSet (setOf fun x => p x)\n⊢ Iff (Filter.Eventually (fun x => p x) (MeasureTheory.ae (MeasureTheory.Measure.dirac a))) (p a)","decl":"theorem ae_dirac_iff {a : α} {p : α → Prop} (hp : MeasurableSet { x | p x }) :\n    (∀ᵐ x ∂dirac a, p x) ↔ p a :=\n  mem_ae_dirac_iff hp\n\n"}
{"name":"MeasureTheory.ae_dirac_eq","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSingletonClass α\na : α\n⊢ Eq (MeasureTheory.ae (MeasureTheory.Measure.dirac a)) (Pure.pure a)","decl":"@[simp]\ntheorem ae_dirac_eq [MeasurableSingletonClass α] (a : α) : ae (dirac a) = pure a := by\n  ext s\n  simp [mem_ae_iff, imp_false]\n\n"}
{"name":"MeasureTheory.ae_eq_dirac'","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSingletonClass β\na : α\nf : α → β\nhf : Measurable f\n⊢ (MeasureTheory.ae (MeasureTheory.Measure.dirac a)).EventuallyEq f (Function.const α (f a))","decl":"theorem ae_eq_dirac' [MeasurableSingletonClass β] {a : α} {f : α → β} (hf : Measurable f) :\n    f =ᵐ[dirac a] const α (f a) :=\n  (ae_dirac_iff <| show MeasurableSet (f ⁻¹' {f a}) from hf <| measurableSet_singleton _).2 rfl\n\n"}
{"name":"MeasureTheory.ae_eq_dirac","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\nδ : Type u_3\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSingletonClass α\na : α\nf : α → δ\n⊢ (MeasureTheory.ae (MeasureTheory.Measure.dirac a)).EventuallyEq f (Function.const α (f a))","decl":"theorem ae_eq_dirac [MeasurableSingletonClass α] {a : α} (f : α → δ) :\n    f =ᵐ[dirac a] const α (f a) := by simp [Filter.EventuallyEq]\n\n"}
{"name":"MeasureTheory.Measure.dirac.isProbabilityMeasure","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nx : α\n⊢ MeasureTheory.IsProbabilityMeasure (MeasureTheory.Measure.dirac x)","decl":"instance Measure.dirac.isProbabilityMeasure {x : α} : IsProbabilityMeasure (dirac x) :=\n  ⟨dirac_apply_of_mem <| mem_univ x⟩\n\n"}
{"name":"MeasureTheory.Measure.dirac.instIsFiniteMeasure","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\na : α\n⊢ MeasureTheory.IsFiniteMeasure (MeasureTheory.Measure.dirac a)","decl":"instance Measure.dirac.instIsFiniteMeasure {a : α} : IsFiniteMeasure (dirac a) := inferInstance\n"}
{"name":"MeasureTheory.Measure.dirac.instSigmaFinite","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\na : α\n⊢ MeasureTheory.SigmaFinite (MeasureTheory.Measure.dirac a)","decl":"instance Measure.dirac.instSigmaFinite {a : α} : SigmaFinite (dirac a) := inferInstance\n\n"}
{"name":"MeasureTheory.restrict_dirac'","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ns : Set α\na : α\nhs : MeasurableSet s\ninst✝ : Decidable (Membership.mem s a)\n⊢ Eq ((MeasureTheory.Measure.dirac a).restrict s) (ite (Membership.mem s a) (MeasureTheory.Measure.dirac a) 0)","decl":"theorem restrict_dirac' (hs : MeasurableSet s) [Decidable (a ∈ s)] :\n    (Measure.dirac a).restrict s = if a ∈ s then Measure.dirac a else 0 := by\n  split_ifs with has\n  · apply restrict_eq_self_of_ae_mem\n    rw [ae_dirac_iff] <;> assumption\n  · rw [restrict_eq_zero, dirac_apply' _ hs, indicator_of_not_mem has]\n\n"}
{"name":"MeasureTheory.restrict_dirac","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ns : Set α\na : α\ninst✝¹ : MeasurableSingletonClass α\ninst✝ : Decidable (Membership.mem s a)\n⊢ Eq ((MeasureTheory.Measure.dirac a).restrict s) (ite (Membership.mem s a) (MeasureTheory.Measure.dirac a) 0)","decl":"theorem restrict_dirac [MeasurableSingletonClass α] [Decidable (a ∈ s)] :\n    (Measure.dirac a).restrict s = if a ∈ s then Measure.dirac a else 0 := by\n  split_ifs with has\n  · apply restrict_eq_self_of_ae_mem\n    rwa [ae_dirac_eq]\n  · rw [restrict_eq_zero, dirac_apply, indicator_of_not_mem has]\n\n"}
{"name":"MeasureTheory.mutuallySingular_dirac","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSingletonClass α\nx : α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.NoAtoms μ\n⊢ (MeasureTheory.Measure.dirac x).MutuallySingular μ","decl":"lemma mutuallySingular_dirac [MeasurableSingletonClass α] (x : α) (μ : Measure α) [NoAtoms μ] :\n    Measure.dirac x ⟂ₘ μ :=\n  ⟨{x}ᶜ, (MeasurableSet.singleton x).compl, by simp, by simp⟩\n\n"}
{"name":"MeasureTheory.dirac_eq_dirac_iff_forall_mem_iff_mem","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nx y : α\n⊢ Iff (Eq (MeasureTheory.Measure.dirac x) (MeasureTheory.Measure.dirac y)) (∀ (A : Set α), MeasurableSet A → Iff (Membership.mem A x) (Membership.mem A y))","decl":"/-- Dirac delta measures at two points are equal if every measurable set contains either both or\nneither of the points. -/\nlemma dirac_eq_dirac_iff_forall_mem_iff_mem {x y : α} :\n    Measure.dirac x = Measure.dirac y ↔ ∀ A, MeasurableSet A → (x ∈ A ↔ y ∈ A) := by\n  constructor\n  · intro h A A_mble\n    have obs := congr_arg (fun μ ↦ μ A) h\n    simp only [Measure.dirac_apply' _ A_mble] at obs\n    by_cases x_in_A : x ∈ A\n    · simpa only [x_in_A, indicator_of_mem, Pi.one_apply, true_iff, Eq.comm (a := (1 : ℝ≥0∞)),\n                  indicator_eq_one_iff_mem] using obs\n    · simpa only [x_in_A, indicator_of_not_mem, Eq.comm (a := (0 : ℝ≥0∞)), indicator_apply_eq_zero,\n                  false_iff, not_false_eq_true, Pi.one_apply, one_ne_zero, imp_false] using obs\n  · intro h\n    ext A A_mble\n    by_cases x_in_A : x ∈ A\n    · simp only [Measure.dirac_apply' _ A_mble, x_in_A, indicator_of_mem, Pi.one_apply,\n                 (h A A_mble).mp x_in_A]\n    · have y_notin_A : y ∉ A := by simp_all only [false_iff, not_false_eq_true]\n      simp only [Measure.dirac_apply' _ A_mble, x_in_A, y_notin_A,\n                 not_false_eq_true, indicator_of_not_mem]\n\n"}
{"name":"MeasureTheory.dirac_ne_dirac_iff_exists_measurableSet","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nx y : α\n⊢ Iff (Ne (MeasureTheory.Measure.dirac x) (MeasureTheory.Measure.dirac y)) (Exists fun A => And (MeasurableSet A) (And (Membership.mem A x) (Not (Membership.mem A y))))","decl":"/-- Dirac delta measures at two points are different if and only if there is a measurable set\ncontaining one of the points but not the other. -/\nlemma dirac_ne_dirac_iff_exists_measurableSet {x y : α} :\n    Measure.dirac x ≠ Measure.dirac y ↔ ∃ A, MeasurableSet A ∧ x ∈ A ∧ y ∉ A := by\n  apply not_iff_not.mp\n  simp only [ne_eq, not_not, not_exists, not_and, dirac_eq_dirac_iff_forall_mem_iff_mem]\n  refine ⟨fun h A A_mble ↦ by simp only [h A A_mble, imp_self], fun h A A_mble ↦ ?_⟩\n  by_cases x_in_A : x ∈ A\n  · simp only [x_in_A, h A A_mble x_in_A]\n  · simpa only [x_in_A, false_iff] using h Aᶜ (MeasurableSet.compl_iff.mpr A_mble) x_in_A\n\n"}
{"name":"MeasureTheory.dirac_ne_dirac","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace.SeparatesPoints α\nx y : α\nx_ne_y : Ne x y\n⊢ Ne (MeasureTheory.Measure.dirac x) (MeasureTheory.Measure.dirac y)","decl":"/-- Dirac delta measures at two different points are different, assuming the measurable space\nseparates points. -/\nlemma dirac_ne_dirac [SeparatesPoints α] {x y : α} (x_ne_y : x ≠ y) :\n    Measure.dirac x ≠ Measure.dirac y := by\n  obtain ⟨A, A_mble, x_in_A, y_notin_A⟩ := exists_measurableSet_of_ne x_ne_y\n  exact dirac_ne_dirac_iff_exists_measurableSet.mpr ⟨A, A_mble, x_in_A, y_notin_A⟩\n\n"}
{"name":"MeasureTheory.dirac_ne_dirac_iff","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace.SeparatesPoints α\nx y : α\n⊢ Iff (Ne (MeasureTheory.Measure.dirac x) (MeasureTheory.Measure.dirac y)) (Ne x y)","decl":"/-- Dirac delta measures at two points are different if and only if the two points are different,\nassuming the measurable space separates points. -/\nlemma dirac_ne_dirac_iff [SeparatesPoints α] {x y : α} :\n    Measure.dirac x ≠ Measure.dirac y ↔ x ≠ y :=\n  ⟨fun h x_eq_y ↦ h <| congrArg dirac x_eq_y, fun h ↦ dirac_ne_dirac h⟩\n\n"}
{"name":"MeasureTheory.dirac_eq_dirac_iff","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace.SeparatesPoints α\nx y : α\n⊢ Iff (Eq (MeasureTheory.Measure.dirac x) (MeasureTheory.Measure.dirac y)) (Eq x y)","decl":"/-- Dirac delta measures at two points are equal if and only if the two points are equal,\nassuming the measurable space separates points. -/\nlemma dirac_eq_dirac_iff [SeparatesPoints α] {x y : α} :\n    Measure.dirac x = Measure.dirac y ↔ x = y := not_iff_not.mp dirac_ne_dirac_iff\n\n"}
{"name":"MeasureTheory.injective_dirac","module":"Mathlib.MeasureTheory.Measure.Dirac","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace.SeparatesPoints α\n⊢ Function.Injective fun x => MeasureTheory.Measure.dirac x","decl":"/-- The assignment `x ↦ dirac x` is injective, assuming the measurable space separates points. -/\nlemma injective_dirac [SeparatesPoints α] :\n    Function.Injective (fun (x : α) ↦ dirac x) := fun x y x_ne_y ↦ by rwa [← dirac_eq_dirac_iff]\n\n"}
