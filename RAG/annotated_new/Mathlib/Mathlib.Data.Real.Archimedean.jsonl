{"name":"Real.instArchimedean","module":"Mathlib.Data.Real.Archimedean","initialProofState":"⊢ Archimedean Real","decl":"instance instArchimedean : Archimedean ℝ :=\n  archimedean_iff_rat_le.2 fun x =>\n    Real.ind_mk x fun f =>\n      let ⟨M, _, H⟩ := f.bounded' 0\n      ⟨M, mk_le_of_forall_le ⟨0, fun i _ => Rat.cast_le.2 <| le_of_lt (abs_lt.1 (H i)).2⟩⟩\n\n"}
{"name":"Real.isCauSeq_iff_lift","module":"Mathlib.Data.Real.Archimedean","initialProofState":"f : Nat → Rat\n⊢ Iff (IsCauSeq abs f) (IsCauSeq abs fun i => ↑(f i))","decl":"theorem isCauSeq_iff_lift {f : ℕ → ℚ} : IsCauSeq abs f ↔ IsCauSeq abs fun i => (f i : ℝ) where\n  mp H ε ε0 :=\n    let ⟨δ, δ0, δε⟩ := exists_pos_rat_lt ε0\n    (H _ δ0).imp fun i hi j ij => by dsimp; exact lt_trans (mod_cast hi _ ij) δε\n  mpr H ε ε0 :=\n    (H _ (Rat.cast_pos.2 ε0)).imp fun i hi j ij => by dsimp at hi; exact mod_cast hi _ ij\n\n"}
{"name":"Real.of_near","module":"Mathlib.Data.Real.Archimedean","initialProofState":"f : Nat → Rat\nx : Real\nh : ∀ (ε : Real), GT.gt ε 0 → Exists fun i => ∀ (j : Nat), GE.ge j i → LT.lt (abs (HSub.hSub (↑(f j)) x)) ε\n⊢ Exists fun h' => Eq (Real.mk ⟨f, h'⟩) x","decl":"theorem of_near (f : ℕ → ℚ) (x : ℝ) (h : ∀ ε > 0, ∃ i, ∀ j ≥ i, |(f j : ℝ) - x| < ε) :\n    ∃ h', Real.mk ⟨f, h'⟩ = x :=\n  ⟨isCauSeq_iff_lift.2 (CauSeq.of_near _ (const abs x) h),\n    sub_eq_zero.1 <|\n      abs_eq_zero.1 <|\n        (eq_of_le_of_forall_lt_imp_le_of_dense (abs_nonneg _)) fun _ε ε0 =>\n          mk_near_of_forall_near <| (h _ ε0).imp fun _i h j ij => le_of_lt (h j ij)⟩\n\n"}
{"name":"Real.exists_floor","module":"Mathlib.Data.Real.Archimedean","initialProofState":"x : Real\n⊢ Exists fun ub => And (LE.le (↑ub) x) (∀ (z : Int), LE.le (↑z) x → LE.le z ub)","decl":"theorem exists_floor (x : ℝ) : ∃ ub : ℤ, (ub : ℝ) ≤ x ∧ ∀ z : ℤ, (z : ℝ) ≤ x → z ≤ ub :=\n  Int.exists_greatest_of_bdd\n    (let ⟨n, hn⟩ := exists_int_gt x\n    ⟨n, fun _ h' => Int.cast_le.1 <| le_trans h' <| le_of_lt hn⟩)\n    (let ⟨n, hn⟩ := exists_int_lt x\n    ⟨n, le_of_lt hn⟩)\n\n"}
{"name":"Real.exists_isLUB","module":"Mathlib.Data.Real.Archimedean","initialProofState":"s : Set Real\nhne : s.Nonempty\nhbdd : BddAbove s\n⊢ Exists fun x => IsLUB s x","decl":"theorem exists_isLUB (hne : s.Nonempty) (hbdd : BddAbove s) : ∃ x, IsLUB s x := by\n  rcases hne, hbdd with ⟨⟨L, hL⟩, ⟨U, hU⟩⟩\n  have : ∀ d : ℕ, BddAbove { m : ℤ | ∃ y ∈ s, (m : ℝ) ≤ y * d } := by\n    cases' exists_int_gt U with k hk\n    refine fun d => ⟨k * d, fun z h => ?_⟩\n    rcases h with ⟨y, yS, hy⟩\n    refine Int.cast_le.1 (hy.trans ?_)\n    push_cast\n    exact mul_le_mul_of_nonneg_right ((hU yS).trans hk.le) d.cast_nonneg\n  choose f hf using fun d : ℕ =>\n    Int.exists_greatest_of_bdd (this d) ⟨⌊L * d⌋, L, hL, Int.floor_le _⟩\n  have hf₁ : ∀ n > 0, ∃ y ∈ s, ((f n / n : ℚ) : ℝ) ≤ y := fun n n0 =>\n    let ⟨y, yS, hy⟩ := (hf n).1\n    ⟨y, yS, by simpa using (div_le_iff₀ (Nat.cast_pos.2 n0 : (_ : ℝ) < _)).2 hy⟩\n  have hf₂ : ∀ n > 0, ∀ y ∈ s, (y - ((n : ℕ) : ℝ)⁻¹) < (f n / n : ℚ) := by\n    intro n n0 y yS\n    have := (Int.sub_one_lt_floor _).trans_le (Int.cast_le.2 <| (hf n).2 _ ⟨y, yS, Int.floor_le _⟩)\n    simp only [Rat.cast_div, Rat.cast_intCast, Rat.cast_natCast, gt_iff_lt]\n    rwa [lt_div_iff₀ (Nat.cast_pos.2 n0 : (_ : ℝ) < _), sub_mul, inv_mul_cancel₀]\n    exact ne_of_gt (Nat.cast_pos.2 n0)\n  have hg : IsCauSeq abs (fun n => f n / n : ℕ → ℚ) := by\n    intro ε ε0\n    suffices ∀ j ≥ ⌈ε⁻¹⌉₊, ∀ k ≥ ⌈ε⁻¹⌉₊, (f j / j - f k / k : ℚ) < ε by\n      refine ⟨_, fun j ij => abs_lt.2 ⟨?_, this _ ij _ le_rfl⟩⟩\n      rw [neg_lt, neg_sub]\n      exact this _ le_rfl _ ij\n    intro j ij k ik\n    replace ij := le_trans (Nat.le_ceil _) (Nat.cast_le.2 ij)\n    replace ik := le_trans (Nat.le_ceil _) (Nat.cast_le.2 ik)\n    have j0 := Nat.cast_pos.1 ((inv_pos.2 ε0).trans_le ij)\n    have k0 := Nat.cast_pos.1 ((inv_pos.2 ε0).trans_le ik)\n    rcases hf₁ _ j0 with ⟨y, yS, hy⟩\n    refine lt_of_lt_of_le ((Rat.cast_lt (K := ℝ)).1 ?_) ((inv_le_comm₀ ε0 (Nat.cast_pos.2 k0)).1 ik)\n    simpa using sub_lt_iff_lt_add'.2 (lt_of_le_of_lt hy <| sub_lt_iff_lt_add.1 <| hf₂ _ k0 _ yS)\n  let g : CauSeq ℚ abs := ⟨fun n => f n / n, hg⟩\n  refine ⟨mk g, ⟨fun x xS => ?_, fun y h => ?_⟩⟩\n  · refine le_of_forall_lt_imp_le_of_dense fun z xz => ?_\n    cases' exists_nat_gt (x - z)⁻¹ with K hK\n    refine le_mk_of_forall_le ⟨K, fun n nK => ?_⟩\n    replace xz := sub_pos.2 xz\n    replace hK := hK.le.trans (Nat.cast_le.2 nK)\n    have n0 : 0 < n := Nat.cast_pos.1 ((inv_pos.2 xz).trans_le hK)\n    refine le_trans ?_ (hf₂ _ n0 _ xS).le\n    rwa [le_sub_comm, inv_le_comm₀ (Nat.cast_pos.2 n0 : (_ : ℝ) < _) xz]\n  · exact\n      mk_le_of_forall_le\n        ⟨1, fun n n1 =>\n          let ⟨x, xS, hx⟩ := hf₁ _ n1\n          le_trans hx (h xS)⟩\n\n"}
{"name":"Real.exists_isGLB","module":"Mathlib.Data.Real.Archimedean","initialProofState":"s : Set Real\nhne : s.Nonempty\nhbdd : BddBelow s\n⊢ Exists fun x => IsGLB s x","decl":"/-- A nonempty, bounded below set of real numbers has a greatest lower bound. -/\ntheorem exists_isGLB (hne : s.Nonempty) (hbdd : BddBelow s) : ∃ x, IsGLB s x := by\n  have hne' : (-s).Nonempty := Set.nonempty_neg.mpr hne\n  have hbdd' : BddAbove (-s) := bddAbove_neg.mpr hbdd\n  use -Classical.choose (Real.exists_isLUB hne' hbdd')\n  rw [← isLUB_neg]\n  exact Classical.choose_spec (Real.exists_isLUB hne' hbdd')\n\n"}
{"name":"Real.sSup_def","module":"Mathlib.Data.Real.Archimedean","initialProofState":"s : Set Real\n⊢ Eq (SupSet.sSup s) (dite (And s.Nonempty (BddAbove s)) (fun h => Classical.choose ⋯) fun h => 0)","decl":"open scoped Classical in\ntheorem sSup_def (s : Set ℝ) :\n    sSup s = if h : s.Nonempty ∧ BddAbove s then Classical.choose (exists_isLUB h.1 h.2) else 0 :=\n  rfl\n\n"}
{"name":"Real.isLUB_sSup","module":"Mathlib.Data.Real.Archimedean","initialProofState":"s : Set Real\nh₁ : s.Nonempty\nh₂ : BddAbove s\n⊢ IsLUB s (SupSet.sSup s)","decl":"protected theorem isLUB_sSup (h₁ : s.Nonempty) (h₂ : BddAbove s) : IsLUB s (sSup s) := by\n  simp only [sSup_def, dif_pos (And.intro h₁ h₂)]\n  apply Classical.choose_spec\n\n"}
{"name":"Real.sInf_def","module":"Mathlib.Data.Real.Archimedean","initialProofState":"s : Set Real\n⊢ Eq (InfSet.sInf s) (Neg.neg (SupSet.sSup (Neg.neg s)))","decl":"theorem sInf_def (s : Set ℝ) : sInf s = -sSup (-s) := rfl\n\n"}
{"name":"Real.isGLB_sInf","module":"Mathlib.Data.Real.Archimedean","initialProofState":"s : Set Real\nh₁ : s.Nonempty\nh₂ : BddBelow s\n⊢ IsGLB s (InfSet.sInf s)","decl":"protected theorem isGLB_sInf (h₁ : s.Nonempty) (h₂ : BddBelow s) : IsGLB s (sInf s) := by\n  rw [sInf_def, ← isLUB_neg', neg_neg]\n  exact Real.isLUB_sSup h₁.neg h₂.neg\n\n"}
{"name":"Real.is_glb_sInf","module":"Mathlib.Data.Real.Archimedean","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeInf α\ns : Set α\n⊢ IsGLB s (InfSet.sInf s)","decl":"@[deprecated (since := \"2024-10-02\")] alias is_glb_sInf := isGLB_sInf\n\n"}
{"name":"Real.lt_sInf_add_pos","module":"Mathlib.Data.Real.Archimedean","initialProofState":"s : Set Real\nh : s.Nonempty\nε : Real\nhε : LT.lt 0 ε\n⊢ Exists fun a => And (Membership.mem s a) (LT.lt a (HAdd.hAdd (InfSet.sInf s) ε))","decl":"theorem lt_sInf_add_pos (h : s.Nonempty) {ε : ℝ} (hε : 0 < ε) : ∃ a ∈ s, a < sInf s + ε :=\n  exists_lt_of_csInf_lt h <| lt_add_of_pos_right _ hε\n\n"}
{"name":"Real.add_neg_lt_sSup","module":"Mathlib.Data.Real.Archimedean","initialProofState":"s : Set Real\nh : s.Nonempty\nε : Real\nhε : LT.lt ε 0\n⊢ Exists fun a => And (Membership.mem s a) (LT.lt (HAdd.hAdd (SupSet.sSup s) ε) a)","decl":"theorem add_neg_lt_sSup (h : s.Nonempty) {ε : ℝ} (hε : ε < 0) : ∃ a ∈ s, sSup s + ε < a :=\n  exists_lt_of_lt_csSup h <| add_lt_iff_neg_left.2 hε\n\n"}
{"name":"Real.sInf_le_iff","module":"Mathlib.Data.Real.Archimedean","initialProofState":"s : Set Real\na : Real\nh : BddBelow s\nh' : s.Nonempty\n⊢ Iff (LE.le (InfSet.sInf s) a) (∀ (ε : Real), LT.lt 0 ε → Exists fun x => And (Membership.mem s x) (LT.lt x (HAdd.hAdd a ε)))","decl":"theorem sInf_le_iff (h : BddBelow s) (h' : s.Nonempty) :\n    sInf s ≤ a ↔ ∀ ε, 0 < ε → ∃ x ∈ s, x < a + ε := by\n  rw [le_iff_forall_pos_lt_add]\n  constructor <;> intro H ε ε_pos\n  · exact exists_lt_of_csInf_lt h' (H ε ε_pos)\n  · rcases H ε ε_pos with ⟨x, x_in, hx⟩\n    exact csInf_lt_of_lt h x_in hx\n\n"}
{"name":"Real.le_sSup_iff","module":"Mathlib.Data.Real.Archimedean","initialProofState":"s : Set Real\na : Real\nh : BddAbove s\nh' : s.Nonempty\n⊢ Iff (LE.le a (SupSet.sSup s)) (∀ (ε : Real), LT.lt ε 0 → Exists fun x => And (Membership.mem s x) (LT.lt (HAdd.hAdd a ε) x))","decl":"theorem le_sSup_iff (h : BddAbove s) (h' : s.Nonempty) :\n    a ≤ sSup s ↔ ∀ ε, ε < 0 → ∃ x ∈ s, a + ε < x := by\n  rw [le_iff_forall_pos_lt_add]\n  refine ⟨fun H ε ε_neg => ?_, fun H ε ε_pos => ?_⟩\n  · exact exists_lt_of_lt_csSup h' (lt_sub_iff_add_lt.mp (H _ (neg_pos.mpr ε_neg)))\n  · rcases H _ (neg_lt_zero.mpr ε_pos) with ⟨x, x_in, hx⟩\n    exact sub_lt_iff_lt_add.mp (lt_csSup_of_lt h x_in hx)\n\n"}
{"name":"Real.sSup_empty","module":"Mathlib.Data.Real.Archimedean","initialProofState":"⊢ Eq (SupSet.sSup EmptyCollection.emptyCollection) 0","decl":"@[simp]\ntheorem sSup_empty : sSup (∅ : Set ℝ) = 0 :=\n  dif_neg <| by simp\n\n"}
{"name":"Real.iSup_of_isEmpty","module":"Mathlib.Data.Real.Archimedean","initialProofState":"ι : Sort u_1\ninst✝ : IsEmpty ι\nf : ι → Real\n⊢ Eq (iSup fun i => f i) 0","decl":"@[simp] lemma iSup_of_isEmpty [IsEmpty ι] (f : ι → ℝ) : ⨆ i, f i = 0 := by\n  dsimp [iSup]\n  convert Real.sSup_empty\n  rw [Set.range_eq_empty_iff]\n  infer_instance\n\n"}
{"name":"Real.iSup_const_zero","module":"Mathlib.Data.Real.Archimedean","initialProofState":"ι : Sort u_1\n⊢ Eq (iSup fun x => 0) 0","decl":"@[simp]\ntheorem iSup_const_zero : ⨆ _ : ι, (0 : ℝ) = 0 := by\n  cases isEmpty_or_nonempty ι\n  · exact Real.iSup_of_isEmpty _\n  · exact ciSup_const\n\n"}
{"name":"Real.sSup_of_not_bddAbove","module":"Mathlib.Data.Real.Archimedean","initialProofState":"s : Set Real\nhs : Not (BddAbove s)\n⊢ Eq (SupSet.sSup s) 0","decl":"lemma sSup_of_not_bddAbove (hs : ¬BddAbove s) : sSup s = 0 := dif_neg fun h => hs h.2\n"}
{"name":"Real.iSup_of_not_bddAbove","module":"Mathlib.Data.Real.Archimedean","initialProofState":"ι : Sort u_1\nf : ι → Real\nhf : Not (BddAbove (Set.range f))\n⊢ Eq (iSup fun i => f i) 0","decl":"lemma iSup_of_not_bddAbove (hf : ¬BddAbove (Set.range f)) : ⨆ i, f i = 0 := sSup_of_not_bddAbove hf\n\n"}
{"name":"Real.sSup_univ","module":"Mathlib.Data.Real.Archimedean","initialProofState":"⊢ Eq (SupSet.sSup Set.univ) 0","decl":"theorem sSup_univ : sSup (@Set.univ ℝ) = 0 := Real.sSup_of_not_bddAbove not_bddAbove_univ\n\n"}
{"name":"Real.sInf_empty","module":"Mathlib.Data.Real.Archimedean","initialProofState":"⊢ Eq (InfSet.sInf EmptyCollection.emptyCollection) 0","decl":"@[simp]\ntheorem sInf_empty : sInf (∅ : Set ℝ) = 0 := by simp [sInf_def, sSup_empty]\n\n"}
{"name":"Real.iInf_of_isEmpty","module":"Mathlib.Data.Real.Archimedean","initialProofState":"ι : Sort u_1\ninst✝ : IsEmpty ι\nf : ι → Real\n⊢ Eq (iInf fun i => f i) 0","decl":"@[simp] nonrec lemma iInf_of_isEmpty [IsEmpty ι] (f : ι → ℝ) : ⨅ i, f i = 0 := by\n  rw [iInf_of_isEmpty, sInf_empty]\n\n"}
{"name":"Real.iInf_const_zero","module":"Mathlib.Data.Real.Archimedean","initialProofState":"ι : Sort u_1\n⊢ Eq (iInf fun x => 0) 0","decl":"@[simp]\ntheorem iInf_const_zero : ⨅ _ : ι, (0 : ℝ) = 0 := by\n  cases isEmpty_or_nonempty ι\n  · exact Real.iInf_of_isEmpty _\n  · exact ciInf_const\n\n"}
{"name":"Real.sInf_of_not_bddBelow","module":"Mathlib.Data.Real.Archimedean","initialProofState":"s : Set Real\nhs : Not (BddBelow s)\n⊢ Eq (InfSet.sInf s) 0","decl":"theorem sInf_of_not_bddBelow (hs : ¬BddBelow s) : sInf s = 0 :=\n  neg_eq_zero.2 <| sSup_of_not_bddAbove <| mt bddAbove_neg.1 hs\n\n"}
{"name":"Real.iInf_of_not_bddBelow","module":"Mathlib.Data.Real.Archimedean","initialProofState":"ι : Sort u_1\nf : ι → Real\nhf : Not (BddBelow (Set.range f))\n⊢ Eq (iInf fun i => f i) 0","decl":"theorem iInf_of_not_bddBelow (hf : ¬BddBelow (Set.range f)) : ⨅ i, f i = 0 :=\n  sInf_of_not_bddBelow hf\n\n"}
{"name":"Real.sSup_le","module":"Mathlib.Data.Real.Archimedean","initialProofState":"s : Set Real\na : Real\nhs : ∀ (x : Real), Membership.mem s x → LE.le x a\nha : LE.le 0 a\n⊢ LE.le (SupSet.sSup s) a","decl":"/-- As `sSup s = 0` when `s` is an empty set of reals, it suffices to show that all elements of `s`\nare at most some nonnegative number `a` to show that `sSup s ≤ a`.\n\nSee also `csSup_le`. -/\nprotected lemma sSup_le (hs : ∀ x ∈ s, x ≤ a) (ha : 0 ≤ a) : sSup s ≤ a := by\n  obtain rfl | hs' := s.eq_empty_or_nonempty\n  exacts [sSup_empty.trans_le ha, csSup_le hs' hs]\n\n"}
{"name":"Real.iSup_le","module":"Mathlib.Data.Real.Archimedean","initialProofState":"ι : Sort u_1\nf : ι → Real\na : Real\nhf : ∀ (i : ι), LE.le (f i) a\nha : LE.le 0 a\n⊢ LE.le (iSup fun i => f i) a","decl":"/-- As `⨆ i, f i = 0` when the domain of the real-valued function `f` is empty, it suffices to show\nthat all values of `f` are at most some nonnegative number `a` to show that `⨆ i, f i ≤ a`.\n\nSee also `ciSup_le`. -/\nprotected lemma iSup_le (hf : ∀ i, f i ≤ a) (ha : 0 ≤ a) : ⨆ i, f i ≤ a :=\n  Real.sSup_le (Set.forall_mem_range.2 hf) ha\n\n"}
{"name":"Real.le_sInf","module":"Mathlib.Data.Real.Archimedean","initialProofState":"s : Set Real\na : Real\nhs : ∀ (x : Real), Membership.mem s x → LE.le a x\nha : LE.le a 0\n⊢ LE.le a (InfSet.sInf s)","decl":"/-- As `sInf s = 0` when `s` is an empty set of reals, it suffices to show that all elements of `s`\nare at least some nonpositive number `a` to show that `a ≤ sInf s`.\n\nSee also `le_csInf`. -/\nprotected lemma le_sInf (hs : ∀ x ∈ s, a ≤ x) (ha : a ≤ 0) : a ≤ sInf s := by\n  obtain rfl | hs' := s.eq_empty_or_nonempty\n  exacts [ha.trans_eq sInf_empty.symm, le_csInf hs' hs]\n\n"}
{"name":"Real.le_iInf","module":"Mathlib.Data.Real.Archimedean","initialProofState":"ι : Sort u_1\nf : ι → Real\na : Real\nhf : ∀ (i : ι), LE.le a (f i)\nha : LE.le a 0\n⊢ LE.le a (iInf fun i => f i)","decl":"/-- As `⨅ i, f i = 0` when the domain of the real-valued function `f` is empty, it suffices to show\nthat all values of `f` are at least some nonpositive number `a` to show that `a ≤ ⨅ i, f i`.\n\nSee also `le_ciInf`. -/\nprotected lemma le_iInf (hf : ∀ i, a ≤ f i) (ha : a ≤ 0) : a ≤ ⨅ i, f i :=\n  Real.le_sInf (Set.forall_mem_range.2 hf) ha\n\n"}
{"name":"Real.sSup_nonpos","module":"Mathlib.Data.Real.Archimedean","initialProofState":"s : Set Real\nhs : ∀ (x : Real), Membership.mem s x → LE.le x 0\n⊢ LE.le (SupSet.sSup s) 0","decl":"/-- As `sSup s = 0` when `s` is an empty set of reals, it suffices to show that all elements of `s`\nare nonpositive to show that `sSup s ≤ 0`. -/\nlemma sSup_nonpos (hs : ∀ x ∈ s, x ≤ 0) : sSup s ≤ 0 := Real.sSup_le hs le_rfl\n\n"}
{"name":"Real.iSup_nonpos","module":"Mathlib.Data.Real.Archimedean","initialProofState":"ι : Sort u_1\nf : ι → Real\nhf : ∀ (i : ι), LE.le (f i) 0\n⊢ LE.le (iSup fun i => f i) 0","decl":"/-- As `⨆ i, f i = 0` when the domain of the real-valued function `f` is empty,\nit suffices to show that all values of `f` are nonpositive to show that `⨆ i, f i ≤ 0`. -/\nlemma iSup_nonpos (hf : ∀ i, f i ≤ 0) : ⨆ i, f i ≤ 0 := Real.iSup_le hf le_rfl\n\n"}
{"name":"Real.sInf_nonneg","module":"Mathlib.Data.Real.Archimedean","initialProofState":"s : Set Real\nhs : ∀ (x : Real), Membership.mem s x → LE.le 0 x\n⊢ LE.le 0 (InfSet.sInf s)","decl":"/-- As `sInf s = 0` when `s` is an empty set of reals, it suffices to show that all elements of `s`\nare nonnegative to show that `0 ≤ sInf s`. -/\nlemma sInf_nonneg (hs : ∀ x ∈ s, 0 ≤ x) : 0 ≤ sInf s := Real.le_sInf hs le_rfl\n\n"}
{"name":"Real.iInf_nonneg","module":"Mathlib.Data.Real.Archimedean","initialProofState":"ι : Sort u_1\nf : ι → Real\nhf : ∀ (i : ι), LE.le 0 (f i)\n⊢ LE.le 0 (iInf f)","decl":"/-- As `⨅ i, f i = 0` when the domain of the real-valued function `f` is empty,\nit suffices to show that all values of `f` are nonnegative to show that `0 ≤ ⨅ i, f i`. -/\nlemma iInf_nonneg (hf : ∀ i, 0 ≤ f i) : 0 ≤ iInf f := Real.le_iInf hf le_rfl\n\n"}
{"name":"Real.sSup_nonneg'","module":"Mathlib.Data.Real.Archimedean","initialProofState":"s : Set Real\nhs : Exists fun x => And (Membership.mem s x) (LE.le 0 x)\n⊢ LE.le 0 (SupSet.sSup s)","decl":"/-- As `sSup s = 0` when `s` is a set of reals that's unbounded above, it suffices to show that `s`\ncontains a nonnegative element to show that `0 ≤ sSup s`. -/\nlemma sSup_nonneg' (hs : ∃ x ∈ s, 0 ≤ x) : 0 ≤ sSup s := by\n  classical\n  obtain ⟨x, hxs, hx⟩ := hs\n  exact dite _ (fun h ↦ le_csSup_of_le h hxs hx) fun h ↦ (sSup_of_not_bddAbove h).ge\n\n"}
{"name":"Real.iSup_nonneg'","module":"Mathlib.Data.Real.Archimedean","initialProofState":"ι : Sort u_1\nf : ι → Real\nhf : Exists fun i => LE.le 0 (f i)\n⊢ LE.le 0 (iSup fun i => f i)","decl":"/-- As `⨆ i, f i = 0` when the real-valued function `f` is unbounded above,\nit suffices to show that `f` takes a nonnegative value to show that `0 ≤ ⨆ i, f i`. -/\nlemma iSup_nonneg' (hf : ∃ i, 0 ≤ f i) : 0 ≤ ⨆ i, f i := sSup_nonneg' <| Set.exists_range_iff.2 hf\n\n"}
{"name":"Real.sInf_nonpos'","module":"Mathlib.Data.Real.Archimedean","initialProofState":"s : Set Real\nhs : Exists fun x => And (Membership.mem s x) (LE.le x 0)\n⊢ LE.le (InfSet.sInf s) 0","decl":"/-- As `sInf s = 0` when `s` is a set of reals that's unbounded below, it suffices to show that `s`\ncontains a nonpositive element to show that `sInf s ≤ 0`. -/\nlemma sInf_nonpos' (hs : ∃ x ∈ s, x ≤ 0) : sInf s ≤ 0 := by\n  classical\n  obtain ⟨x, hxs, hx⟩ := hs\n  exact dite _ (fun h ↦ csInf_le_of_le h hxs hx) fun h ↦ (sInf_of_not_bddBelow h).le\n\n"}
{"name":"Real.iInf_nonpos'","module":"Mathlib.Data.Real.Archimedean","initialProofState":"ι : Sort u_1\nf : ι → Real\nhf : Exists fun i => LE.le (f i) 0\n⊢ LE.le (iInf fun i => f i) 0","decl":"/-- As `⨅ i, f i = 0` when the real-valued function `f` is unbounded below,\nit suffices to show that `f` takes a nonpositive value to show that `0 ≤ ⨅ i, f i`. -/\nlemma iInf_nonpos' (hf : ∃ i, f i ≤ 0) : ⨅ i, f i ≤ 0 := sInf_nonpos' <| Set.exists_range_iff.2 hf\n\n"}
{"name":"Real.sSup_nonneg","module":"Mathlib.Data.Real.Archimedean","initialProofState":"s : Set Real\nhs : ∀ (x : Real), Membership.mem s x → LE.le 0 x\n⊢ LE.le 0 (SupSet.sSup s)","decl":"/-- As `sSup s = 0` when `s` is a set of reals that's either empty or unbounded above,\nit suffices to show that all elements of `s` are nonnegative to show that `0 ≤ sSup s`. -/\nlemma sSup_nonneg (hs : ∀ x ∈ s, 0 ≤ x) : 0 ≤ sSup s := by\n  obtain rfl | ⟨x, hx⟩ := s.eq_empty_or_nonempty\n  · exact sSup_empty.ge\n  · exact sSup_nonneg' ⟨x, hx, hs _ hx⟩\n\n"}
{"name":"Real.iSup_nonneg","module":"Mathlib.Data.Real.Archimedean","initialProofState":"ι : Sort u_1\nf : ι → Real\nhf : ∀ (i : ι), LE.le 0 (f i)\n⊢ LE.le 0 (iSup fun i => f i)","decl":"/-- As `⨆ i, f i = 0` when the domain of the real-valued function `f` is empty or unbounded above,\nit suffices to show that all values of `f` are nonnegative to show that `0 ≤ ⨆ i, f i`. -/\nlemma iSup_nonneg (hf : ∀ i, 0 ≤ f i) : 0 ≤ ⨆ i, f i := sSup_nonneg <| Set.forall_mem_range.2 hf\n\n"}
{"name":"Real.sInf_nonpos","module":"Mathlib.Data.Real.Archimedean","initialProofState":"s : Set Real\nhs : ∀ (x : Real), Membership.mem s x → LE.le x 0\n⊢ LE.le (InfSet.sInf s) 0","decl":"/-- As `sInf s = 0` when `s` is a set of reals that's either empty or unbounded below,\nit suffices to show that all elements of `s` are nonpositive to show that `sInf s ≤ 0`. -/\nlemma sInf_nonpos (hs : ∀ x ∈ s, x ≤ 0) : sInf s ≤ 0 := by\n  obtain rfl | ⟨x, hx⟩ := s.eq_empty_or_nonempty\n  · exact sInf_empty.le\n  · exact sInf_nonpos' ⟨x, hx, hs _ hx⟩\n\n"}
{"name":"Real.iInf_nonpos","module":"Mathlib.Data.Real.Archimedean","initialProofState":"ι : Sort u_1\nf : ι → Real\nhf : ∀ (i : ι), LE.le (f i) 0\n⊢ LE.le (iInf fun i => f i) 0","decl":"/-- As `⨅ i, f i = 0` when the domain of the real-valued function `f` is empty or unbounded below,\nit suffices to show that all values of `f` are nonpositive to show that `0 ≤ ⨅ i, f i`. -/\nlemma iInf_nonpos (hf : ∀ i, f i ≤ 0) : ⨅ i, f i ≤ 0 := sInf_nonpos <| Set.forall_mem_range.2 hf\n\n"}
{"name":"Real.sInf_le_sSup","module":"Mathlib.Data.Real.Archimedean","initialProofState":"s : Set Real\nh₁ : BddBelow s\nh₂ : BddAbove s\n⊢ LE.le (InfSet.sInf s) (SupSet.sSup s)","decl":"theorem sInf_le_sSup (s : Set ℝ) (h₁ : BddBelow s) (h₂ : BddAbove s) : sInf s ≤ sSup s := by\n  rcases s.eq_empty_or_nonempty with (rfl | hne)\n  · rw [sInf_empty, sSup_empty]\n  · exact csInf_le_csSup h₁ h₂ hne\n\n"}
{"name":"Real.cauSeq_converges","module":"Mathlib.Data.Real.Archimedean","initialProofState":"f : CauSeq Real abs\n⊢ Exists fun x => HasEquiv.Equiv f (CauSeq.const abs x)","decl":"theorem cauSeq_converges (f : CauSeq ℝ abs) : ∃ x, f ≈ const abs x := by\n  let s := {x : ℝ | const abs x < f}\n  have lb : ∃ x, x ∈ s := exists_lt f\n  have ub' : ∀ x, f < const abs x → ∀ y ∈ s, y ≤ x := fun x h y yS =>\n    le_of_lt <| const_lt.1 <| CauSeq.lt_trans yS h\n  have ub : ∃ x, ∀ y ∈ s, y ≤ x := (exists_gt f).imp ub'\n  refine ⟨sSup s, ((lt_total _ _).resolve_left fun h => ?_).resolve_right fun h => ?_⟩\n  · rcases h with ⟨ε, ε0, i, ih⟩\n    refine (csSup_le lb (ub' _ ?_)).not_lt (sub_lt_self _ (half_pos ε0))\n    refine ⟨_, half_pos ε0, i, fun j ij => ?_⟩\n    rw [sub_apply, const_apply, sub_right_comm, le_sub_iff_add_le, add_halves]\n    exact ih _ ij\n  · rcases h with ⟨ε, ε0, i, ih⟩\n    refine (le_csSup ub ?_).not_lt ((lt_add_iff_pos_left _).2 (half_pos ε0))\n    refine ⟨_, half_pos ε0, i, fun j ij => ?_⟩\n    rw [sub_apply, const_apply, add_comm, ← sub_sub, le_sub_iff_add_le, add_halves]\n    exact ih _ ij\n\n"}
{"name":"Real.instIsCompleteAbs","module":"Mathlib.Data.Real.Archimedean","initialProofState":"⊢ CauSeq.IsComplete Real abs","decl":"instance : CauSeq.IsComplete ℝ abs :=\n  ⟨cauSeq_converges⟩\n\n"}
{"name":"Real.iInf_Ioi_eq_iInf_rat_gt","module":"Mathlib.Data.Real.Archimedean","initialProofState":"f : Real → Real\nx : Real\nhf : BddBelow (Set.image f (Set.Ioi x))\nhf_mono : Monotone f\n⊢ Eq (iInf fun r => f ↑r) (iInf fun q => f ↑↑q)","decl":"theorem iInf_Ioi_eq_iInf_rat_gt {f : ℝ → ℝ} (x : ℝ) (hf : BddBelow (f '' Ioi x))\n    (hf_mono : Monotone f) : ⨅ r : Ioi x, f r = ⨅ q : { q' : ℚ // x < q' }, f q := by\n  refine le_antisymm ?_ ?_\n  · have : Nonempty { r' : ℚ // x < ↑r' } := by\n      obtain ⟨r, hrx⟩ := exists_rat_gt x\n      exact ⟨⟨r, hrx⟩⟩\n    refine le_ciInf fun r => ?_\n    obtain ⟨y, hxy, hyr⟩ := exists_rat_btwn r.prop\n    refine ciInf_set_le hf (hxy.trans ?_)\n    exact_mod_cast hyr\n  · refine le_ciInf fun q => ?_\n    have hq := q.prop\n    rw [mem_Ioi] at hq\n    obtain ⟨y, hxy, hyq⟩ := exists_rat_btwn hq\n    refine (ciInf_le ?_ ?_).trans ?_\n    · refine ⟨hf.some, fun z => ?_⟩\n      rintro ⟨u, rfl⟩\n      suffices hfu : f u ∈ f '' Ioi x from hf.choose_spec hfu\n      exact ⟨u, u.prop, rfl⟩\n    · exact ⟨y, hxy⟩\n    · refine hf_mono (le_trans ?_ hyq.le)\n      norm_cast\n\n"}
{"name":"Real.not_bddAbove_coe","module":"Mathlib.Data.Real.Archimedean","initialProofState":"⊢ Not (BddAbove (Set.range fun x => ↑x))","decl":"theorem not_bddAbove_coe : ¬ (BddAbove <| range (fun (x : ℚ) ↦ (x : ℝ))) := by\n  dsimp only [BddAbove, upperBounds]\n  rw [Set.not_nonempty_iff_eq_empty]\n  ext\n  simpa using exists_rat_gt _\n\n"}
{"name":"Real.not_bddBelow_coe","module":"Mathlib.Data.Real.Archimedean","initialProofState":"⊢ Not (BddBelow (Set.range fun x => ↑x))","decl":"theorem not_bddBelow_coe : ¬ (BddBelow <| range (fun (x : ℚ) ↦ (x : ℝ))) := by\n  dsimp only [BddBelow, lowerBounds]\n  rw [Set.not_nonempty_iff_eq_empty]\n  ext\n  simpa using exists_rat_lt _\n\n"}
{"name":"Real.iUnion_Iic_rat","module":"Mathlib.Data.Real.Archimedean","initialProofState":"⊢ Eq (Set.iUnion fun r => Set.Iic ↑r) Set.univ","decl":"theorem iUnion_Iic_rat : ⋃ r : ℚ, Iic (r : ℝ) = univ := by\n  exact iUnion_Iic_of_not_bddAbove_range not_bddAbove_coe\n\n"}
{"name":"Real.iInter_Iic_rat","module":"Mathlib.Data.Real.Archimedean","initialProofState":"⊢ Eq (Set.iInter fun r => Set.Iic ↑r) EmptyCollection.emptyCollection","decl":"theorem iInter_Iic_rat : ⋂ r : ℚ, Iic (r : ℝ) = ∅ := by\n  exact iInter_Iic_eq_empty_iff.mpr not_bddBelow_coe\n\n"}
{"name":"Real.exists_natCast_add_one_lt_pow_of_one_lt","module":"Mathlib.Data.Real.Archimedean","initialProofState":"a : Real\nha : LT.lt 1 a\n⊢ Exists fun m => LT.lt (HAdd.hAdd (↑m) 1) (HPow.hPow a m)","decl":"/-- Exponentiation is eventually larger than linear growth. -/\nlemma exists_natCast_add_one_lt_pow_of_one_lt (ha : 1 < a) : ∃ m : ℕ, (m + 1 : ℝ) < a ^ m := by\n  obtain ⟨k, posk, hk⟩ : ∃ k : ℕ, 0 < k ∧ 1 / k + 1 < a := by\n    contrapose! ha\n    refine le_of_forall_lt_rat_imp_le ?_\n    intro q hq\n    refine (ha q.den (by positivity)).trans ?_\n    rw [← le_sub_iff_add_le, div_le_iff₀ (by positivity), sub_mul, one_mul]\n    norm_cast at hq ⊢\n    rw [← q.num_div_den, one_lt_div (by positivity)] at hq\n    rw [q.mul_den_eq_num]\n    norm_cast at hq ⊢\n    omega\n  use 2 * k ^ 2\n  calc\n    ((2 * k ^ 2 : ℕ) + 1 : ℝ) ≤ 2 ^ (2 * k) := mod_cast Nat.two_mul_sq_add_one_le_two_pow_two_mul _\n    _ = (1 / k * k + 1 : ℝ) ^ (2 * k) := by simp [posk.ne']; norm_num\n    _ ≤ ((1 / k + 1) ^ k : ℝ) ^ (2 * k) := by gcongr; exact mul_add_one_le_add_one_pow (by simp) _\n    _ = (1 / k + 1 : ℝ) ^ (2 * k ^ 2) := by rw [← pow_mul, mul_left_comm, sq]\n    _ < a ^ (2 * k ^ 2) := by gcongr\n\n"}
