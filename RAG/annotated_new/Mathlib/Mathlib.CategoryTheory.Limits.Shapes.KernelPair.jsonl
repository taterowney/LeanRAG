{"name":"CategoryTheory.IsKernelPair.instSubsingleton","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nR X Y : C\nf : Quiver.Hom X Y\na b : Quiver.Hom R X\n⊢ Subsingleton (CategoryTheory.IsKernelPair f a b)","decl":"/-- The data expressing that `(a, b)` is a kernel pair is subsingleton. -/\ninstance : Subsingleton (IsKernelPair f a b) :=\n  ⟨fun P Q => by\n    cases P\n    cases Q\n    congr ⟩\n\n"}
{"name":"CategoryTheory.IsKernelPair.id_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.IsKernelPair f (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- If `f` is a monomorphism, then `(𝟙 _, 𝟙 _)` is a kernel pair for `f`. -/\ntheorem id_of_mono [Mono f] : IsKernelPair f (𝟙 _) (𝟙 _) :=\n  ⟨⟨rfl⟩, ⟨PullbackCone.isLimitMkIdId _⟩⟩\n\n"}
{"name":"CategoryTheory.IsKernelPair.lift_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nR X Y : C\nf : Quiver.Hom X Y\na b : Quiver.Hom R X\nS : C\nk : CategoryTheory.IsKernelPair f a b\np q : Quiver.Hom S X\nw : Eq (CategoryTheory.CategoryStruct.comp p f) (CategoryTheory.CategoryStruct.comp q f)\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (k.lift p q w) (CategoryTheory.CategoryStruct.comp a h)) (CategoryTheory.CategoryStruct.comp p h)","decl":"@[reassoc (attr := simp)]\nlemma lift_fst {S : C} (k : IsKernelPair f a b) (p q : S ⟶ X) (w : p ≫ f = q ≫ f) :\n    k.lift p q w ≫ a = p :=\n  PullbackCone.IsLimit.lift_fst _ _ _ _\n\n"}
{"name":"CategoryTheory.IsKernelPair.lift_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nR X Y : C\nf : Quiver.Hom X Y\na b : Quiver.Hom R X\nS : C\nk : CategoryTheory.IsKernelPair f a b\np q : Quiver.Hom S X\nw : Eq (CategoryTheory.CategoryStruct.comp p f) (CategoryTheory.CategoryStruct.comp q f)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (k.lift p q w) a) p","decl":"@[reassoc (attr := simp)]\nlemma lift_fst {S : C} (k : IsKernelPair f a b) (p q : S ⟶ X) (w : p ≫ f = q ≫ f) :\n    k.lift p q w ≫ a = p :=\n  PullbackCone.IsLimit.lift_fst _ _ _ _\n\n"}
{"name":"CategoryTheory.IsKernelPair.lift_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nR X Y : C\nf : Quiver.Hom X Y\na b : Quiver.Hom R X\nS : C\nk : CategoryTheory.IsKernelPair f a b\np q : Quiver.Hom S X\nw : Eq (CategoryTheory.CategoryStruct.comp p f) (CategoryTheory.CategoryStruct.comp q f)\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (k.lift p q w) (CategoryTheory.CategoryStruct.comp b h)) (CategoryTheory.CategoryStruct.comp q h)","decl":"@[reassoc (attr := simp)]\nlemma lift_snd {S : C} (k : IsKernelPair f a b) (p q : S ⟶ X) (w : p ≫ f = q ≫ f) :\n    k.lift p q w ≫ b = q :=\n  PullbackCone.IsLimit.lift_snd _ _ _ _\n\n"}
{"name":"CategoryTheory.IsKernelPair.lift_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nR X Y : C\nf : Quiver.Hom X Y\na b : Quiver.Hom R X\nS : C\nk : CategoryTheory.IsKernelPair f a b\np q : Quiver.Hom S X\nw : Eq (CategoryTheory.CategoryStruct.comp p f) (CategoryTheory.CategoryStruct.comp q f)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (k.lift p q w) b) q","decl":"@[reassoc (attr := simp)]\nlemma lift_snd {S : C} (k : IsKernelPair f a b) (p q : S ⟶ X) (w : p ≫ f = q ≫ f) :\n    k.lift p q w ≫ b = q :=\n  PullbackCone.IsLimit.lift_snd _ _ _ _\n\n"}
{"name":"CategoryTheory.IsKernelPair.cancel_right","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nR X Y Z : C\na b : Quiver.Hom R X\nf₁ : Quiver.Hom X Y\nf₂ : Quiver.Hom Y Z\ncomm : Eq (CategoryTheory.CategoryStruct.comp a f₁) (CategoryTheory.CategoryStruct.comp b f₁)\nbig_k : CategoryTheory.IsKernelPair (CategoryTheory.CategoryStruct.comp f₁ f₂) a b\n⊢ CategoryTheory.IsKernelPair f₁ a b","decl":"/--\nIf `(a,b)` is a kernel pair for `f₁ ≫ f₂` and `a ≫ f₁ = b ≫ f₁`, then `(a,b)` is a kernel pair for\njust `f₁`.\nThat is, to show that `(a,b)` is a kernel pair for `f₁` it suffices to only show the square\ncommutes, rather than to additionally show it's a pullback.\n-/\ntheorem cancel_right {f₁ : X ⟶ Y} {f₂ : Y ⟶ Z} (comm : a ≫ f₁ = b ≫ f₁)\n    (big_k : IsKernelPair (f₁ ≫ f₂) a b) : IsKernelPair f₁ a b :=\n  { w := comm\n    isLimit' :=\n      ⟨PullbackCone.isLimitAux' _ fun s => by\n        let s' : PullbackCone (f₁ ≫ f₂) (f₁ ≫ f₂) :=\n          PullbackCone.mk s.fst s.snd (s.condition_assoc _)\n        refine ⟨big_k.isLimit.lift s', big_k.isLimit.fac _ WalkingCospan.left,\n          big_k.isLimit.fac _ WalkingCospan.right, fun m₁ m₂ => ?_⟩\n        apply big_k.isLimit.hom_ext\n        refine (PullbackCone.mk a b ?_ : PullbackCone (f₁ ≫ f₂) _).equalizer_ext ?_ ?_\n        · apply reassoc_of% comm\n        · apply m₁.trans (big_k.isLimit.fac s' WalkingCospan.left).symm\n        · apply m₂.trans (big_k.isLimit.fac s' WalkingCospan.right).symm⟩ }\n\n"}
{"name":"CategoryTheory.IsKernelPair.cancel_right_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nR X Y Z : C\na b : Quiver.Hom R X\nf₁ : Quiver.Hom X Y\nf₂ : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Mono f₂\nbig_k : CategoryTheory.IsKernelPair (CategoryTheory.CategoryStruct.comp f₁ f₂) a b\n⊢ CategoryTheory.IsKernelPair f₁ a b","decl":"/-- If `(a,b)` is a kernel pair for `f₁ ≫ f₂` and `f₂` is mono, then `(a,b)` is a kernel pair for\njust `f₁`.\nThe converse of `comp_of_mono`.\n-/\ntheorem cancel_right_of_mono {f₁ : X ⟶ Y} {f₂ : Y ⟶ Z} [Mono f₂]\n    (big_k : IsKernelPair (f₁ ≫ f₂) a b) : IsKernelPair f₁ a b :=\n  cancel_right (by rw [← cancel_mono f₂, assoc, assoc, big_k.w]) big_k\n\n"}
{"name":"CategoryTheory.IsKernelPair.comp_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nR X Y Z : C\na b : Quiver.Hom R X\nf₁ : Quiver.Hom X Y\nf₂ : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Mono f₂\nsmall_k : CategoryTheory.IsKernelPair f₁ a b\n⊢ CategoryTheory.IsKernelPair (CategoryTheory.CategoryStruct.comp f₁ f₂) a b","decl":"/--\nIf `(a,b)` is a kernel pair for `f₁` and `f₂` is mono, then `(a,b)` is a kernel pair for `f₁ ≫ f₂`.\nThe converse of `cancel_right_of_mono`.\n-/\ntheorem comp_of_mono {f₁ : X ⟶ Y} {f₂ : Y ⟶ Z} [Mono f₂] (small_k : IsKernelPair f₁ a b) :\n    IsKernelPair (f₁ ≫ f₂) a b :=\n  { w := by rw [small_k.w_assoc]\n    isLimit' := ⟨by\n      refine PullbackCone.isLimitAux _\n        (fun s => small_k.lift s.fst s.snd (by rw [← cancel_mono f₂, assoc, s.condition, assoc]))\n        (by simp) (by simp) ?_\n      intro s m hm\n      apply small_k.isLimit.hom_ext\n      apply PullbackCone.equalizer_ext small_k.cone _ _\n      · exact (hm WalkingCospan.left).trans (by simp)\n      · exact (hm WalkingCospan.right).trans (by simp)⟩ }\n\n"}
{"name":"CategoryTheory.IsKernelPair.pullback","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y Z A : C\ng : Quiver.Hom Y Z\na₁ a₂ : Quiver.Hom A Y\nh : CategoryTheory.IsKernelPair g a₁ a₂\nf : Quiver.Hom X Z\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback f (CategoryTheory.CategoryStruct.comp a₁ g)\n⊢ CategoryTheory.IsKernelPair (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.map f (CategoryTheory.CategoryStruct.comp a₁ g) f g (CategoryTheory.CategoryStruct.id X) a₁ (CategoryTheory.CategoryStruct.id Z) ⋯ ⋯) (CategoryTheory.Limits.pullback.map f (CategoryTheory.CategoryStruct.comp a₁ g) f g (CategoryTheory.CategoryStruct.id X) a₂ (CategoryTheory.CategoryStruct.id Z) ⋯ ⋯)","decl":"/-- If `a₁ a₂ : A ⟶ Y` is a kernel pair for `g : Y ⟶ Z`, then `a₁ ×[Z] X` and `a₂ ×[Z] X`\n(`A ×[Z] X ⟶ Y ×[Z] X`) is a kernel pair for `Y ×[Z] X ⟶ X`. -/\nprotected theorem pullback {X Y Z A : C} {g : Y ⟶ Z} {a₁ a₂ : A ⟶ Y} (h : IsKernelPair g a₁ a₂)\n    (f : X ⟶ Z) [HasPullback f g] [HasPullback f (a₁ ≫ g)] :\n    IsKernelPair (pullback.fst f g)\n      (pullback.map f _ f _ (𝟙 X) a₁ (𝟙 Z) (by simp) <| Category.comp_id _)\n      (pullback.map _ _ _ _ (𝟙 X) a₂ (𝟙 Z) (by simp) <| (Category.comp_id _).trans h.1.1) := by\n  refine ⟨⟨by rw [pullback.lift_fst, pullback.lift_fst]⟩, ⟨PullbackCone.isLimitAux _\n    (fun s => pullback.lift (s.fst ≫ pullback.fst _ _)\n      (h.lift (s.fst ≫ pullback.snd _ _) (s.snd ≫ pullback.snd _ _) ?_ ) ?_) (fun s => ?_)\n        (fun s => ?_) (fun s m hm => ?_)⟩⟩\n  · simp_rw [Category.assoc, ← pullback.condition, ← Category.assoc, s.condition]\n  · simp only [assoc, lift_fst_assoc, pullback.condition]\n  · ext <;> simp\n  · ext\n    · simp [s.condition]\n    · simp\n  · #adaptation_note /-- nightly-2024-04-01\n    This `symm` (or the following ones that undo it) wasn't previously necessary. -/\n    symm\n    apply pullback.hom_ext\n    · symm\n      simpa using hm WalkingCospan.left =≫ pullback.fst f g\n    · symm\n      apply PullbackCone.IsLimit.hom_ext h.isLimit\n      · simpa using hm WalkingCospan.left =≫ pullback.snd f g\n      · simpa using hm WalkingCospan.right =≫ pullback.snd f g\n\n"}
{"name":"CategoryTheory.IsKernelPair.mono_of_isIso_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nR X Y : C\nf : Quiver.Hom X Y\na b : Quiver.Hom R X\nh : CategoryTheory.IsKernelPair f a b\ninst✝ : CategoryTheory.IsIso a\n⊢ CategoryTheory.Mono f","decl":"theorem mono_of_isIso_fst (h : IsKernelPair f a b) [IsIso a] : Mono f := by\n  obtain ⟨l, h₁, h₂⟩ := Limits.PullbackCone.IsLimit.lift' h.isLimit (𝟙 _) (𝟙 _) (by simp [h.w])\n  rw [IsPullback.cone_fst, ← IsIso.eq_comp_inv, Category.id_comp] at h₁\n  rw [h₁, IsIso.inv_comp_eq, Category.comp_id] at h₂\n  constructor\n  intro Z g₁ g₂ e\n  obtain ⟨l', rfl, rfl⟩ := Limits.PullbackCone.IsLimit.lift' h.isLimit _ _ e\n  rw [IsPullback.cone_fst, h₂]\n\n"}
{"name":"CategoryTheory.IsKernelPair.isIso_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nR X Y : C\nf : Quiver.Hom X Y\na b : Quiver.Hom R X\nh : CategoryTheory.IsKernelPair f a b\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.IsIso a","decl":"theorem isIso_of_mono (h : IsKernelPair f a b) [Mono f] : IsIso a := by\n  rw [←\n    show _ = a from\n      (Category.comp_id _).symm.trans\n        ((IsKernelPair.id_of_mono f).isLimit.conePointUniqueUpToIso_inv_comp h.isLimit\n          WalkingCospan.left)]\n  infer_instance\n\n"}
{"name":"CategoryTheory.IsKernelPair.of_isIso_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nR X Y : C\nf : Quiver.Hom X Y\na : Quiver.Hom R X\ninst✝¹ : CategoryTheory.IsIso a\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.IsKernelPair f a a","decl":"theorem of_isIso_of_mono [IsIso a] [Mono f] : IsKernelPair f a a := by\n  change IsPullback _ _ _ _\n  convert (IsPullback.of_horiz_isIso ⟨(rfl : a ≫ 𝟙 X = _ )⟩).paste_vert (IsKernelPair.id_of_mono f)\n  all_goals { simp }\n\n"}
