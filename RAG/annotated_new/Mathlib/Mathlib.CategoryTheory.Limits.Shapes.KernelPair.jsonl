{"name":"CategoryTheory.IsKernelPair.instSubsingleton","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nR X Y : C\nf : Quiver.Hom X Y\na b : Quiver.Hom R X\nâŠ¢ Subsingleton (CategoryTheory.IsKernelPair f a b)","decl":"/-- The data expressing that `(a, b)` is a kernel pair is subsingleton. -/\ninstance : Subsingleton (IsKernelPair f a b) :=\n  âŸ¨fun P Q => by\n    cases P\n    cases Q\n    congr âŸ©\n\n"}
{"name":"CategoryTheory.IsKernelPair.id_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Mono f\nâŠ¢ CategoryTheory.IsKernelPair f (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- If `f` is a monomorphism, then `(ğŸ™ _, ğŸ™ _)` is a kernel pair for `f`. -/\ntheorem id_of_mono [Mono f] : IsKernelPair f (ğŸ™ _) (ğŸ™ _) :=\n  âŸ¨âŸ¨rflâŸ©, âŸ¨PullbackCone.isLimitMkIdId _âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.IsKernelPair.lift_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nR X Y : C\nf : Quiver.Hom X Y\na b : Quiver.Hom R X\nS : C\nk : CategoryTheory.IsKernelPair f a b\np q : Quiver.Hom S X\nw : Eq (CategoryTheory.CategoryStruct.comp p f) (CategoryTheory.CategoryStruct.comp q f)\nZ : C\nh : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (k.lift p q w) (CategoryTheory.CategoryStruct.comp a h)) (CategoryTheory.CategoryStruct.comp p h)","decl":"@[reassoc (attr := simp)]\nlemma lift_fst {S : C} (k : IsKernelPair f a b) (p q : S âŸ¶ X) (w : p â‰« f = q â‰« f) :\n    k.lift p q w â‰« a = p :=\n  PullbackCone.IsLimit.lift_fst _ _ _ _\n\n"}
{"name":"CategoryTheory.IsKernelPair.lift_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nR X Y : C\nf : Quiver.Hom X Y\na b : Quiver.Hom R X\nS : C\nk : CategoryTheory.IsKernelPair f a b\np q : Quiver.Hom S X\nw : Eq (CategoryTheory.CategoryStruct.comp p f) (CategoryTheory.CategoryStruct.comp q f)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (k.lift p q w) a) p","decl":"@[reassoc (attr := simp)]\nlemma lift_fst {S : C} (k : IsKernelPair f a b) (p q : S âŸ¶ X) (w : p â‰« f = q â‰« f) :\n    k.lift p q w â‰« a = p :=\n  PullbackCone.IsLimit.lift_fst _ _ _ _\n\n"}
{"name":"CategoryTheory.IsKernelPair.lift_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nR X Y : C\nf : Quiver.Hom X Y\na b : Quiver.Hom R X\nS : C\nk : CategoryTheory.IsKernelPair f a b\np q : Quiver.Hom S X\nw : Eq (CategoryTheory.CategoryStruct.comp p f) (CategoryTheory.CategoryStruct.comp q f)\nZ : C\nh : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (k.lift p q w) (CategoryTheory.CategoryStruct.comp b h)) (CategoryTheory.CategoryStruct.comp q h)","decl":"@[reassoc (attr := simp)]\nlemma lift_snd {S : C} (k : IsKernelPair f a b) (p q : S âŸ¶ X) (w : p â‰« f = q â‰« f) :\n    k.lift p q w â‰« b = q :=\n  PullbackCone.IsLimit.lift_snd _ _ _ _\n\n"}
{"name":"CategoryTheory.IsKernelPair.lift_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nR X Y : C\nf : Quiver.Hom X Y\na b : Quiver.Hom R X\nS : C\nk : CategoryTheory.IsKernelPair f a b\np q : Quiver.Hom S X\nw : Eq (CategoryTheory.CategoryStruct.comp p f) (CategoryTheory.CategoryStruct.comp q f)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (k.lift p q w) b) q","decl":"@[reassoc (attr := simp)]\nlemma lift_snd {S : C} (k : IsKernelPair f a b) (p q : S âŸ¶ X) (w : p â‰« f = q â‰« f) :\n    k.lift p q w â‰« b = q :=\n  PullbackCone.IsLimit.lift_snd _ _ _ _\n\n"}
{"name":"CategoryTheory.IsKernelPair.cancel_right","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nR X Y Z : C\na b : Quiver.Hom R X\nfâ‚ : Quiver.Hom X Y\nfâ‚‚ : Quiver.Hom Y Z\ncomm : Eq (CategoryTheory.CategoryStruct.comp a fâ‚) (CategoryTheory.CategoryStruct.comp b fâ‚)\nbig_k : CategoryTheory.IsKernelPair (CategoryTheory.CategoryStruct.comp fâ‚ fâ‚‚) a b\nâŠ¢ CategoryTheory.IsKernelPair fâ‚ a b","decl":"/--\nIf `(a,b)` is a kernel pair for `fâ‚ â‰« fâ‚‚` and `a â‰« fâ‚ = b â‰« fâ‚`, then `(a,b)` is a kernel pair for\njust `fâ‚`.\nThat is, to show that `(a,b)` is a kernel pair for `fâ‚` it suffices to only show the square\ncommutes, rather than to additionally show it's a pullback.\n-/\ntheorem cancel_right {fâ‚ : X âŸ¶ Y} {fâ‚‚ : Y âŸ¶ Z} (comm : a â‰« fâ‚ = b â‰« fâ‚)\n    (big_k : IsKernelPair (fâ‚ â‰« fâ‚‚) a b) : IsKernelPair fâ‚ a b :=\n  { w := comm\n    isLimit' :=\n      âŸ¨PullbackCone.isLimitAux' _ fun s => by\n        let s' : PullbackCone (fâ‚ â‰« fâ‚‚) (fâ‚ â‰« fâ‚‚) :=\n          PullbackCone.mk s.fst s.snd (s.condition_assoc _)\n        refine âŸ¨big_k.isLimit.lift s', big_k.isLimit.fac _ WalkingCospan.left,\n          big_k.isLimit.fac _ WalkingCospan.right, fun mâ‚ mâ‚‚ => ?_âŸ©\n        apply big_k.isLimit.hom_ext\n        refine (PullbackCone.mk a b ?_ : PullbackCone (fâ‚ â‰« fâ‚‚) _).equalizer_ext ?_ ?_\n        Â· apply reassoc_of% comm\n        Â· apply mâ‚.trans (big_k.isLimit.fac s' WalkingCospan.left).symm\n        Â· apply mâ‚‚.trans (big_k.isLimit.fac s' WalkingCospan.right).symmâŸ© }\n\n"}
{"name":"CategoryTheory.IsKernelPair.cancel_right_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nR X Y Z : C\na b : Quiver.Hom R X\nfâ‚ : Quiver.Hom X Y\nfâ‚‚ : Quiver.Hom Y Z\ninstâœ : CategoryTheory.Mono fâ‚‚\nbig_k : CategoryTheory.IsKernelPair (CategoryTheory.CategoryStruct.comp fâ‚ fâ‚‚) a b\nâŠ¢ CategoryTheory.IsKernelPair fâ‚ a b","decl":"/-- If `(a,b)` is a kernel pair for `fâ‚ â‰« fâ‚‚` and `fâ‚‚` is mono, then `(a,b)` is a kernel pair for\njust `fâ‚`.\nThe converse of `comp_of_mono`.\n-/\ntheorem cancel_right_of_mono {fâ‚ : X âŸ¶ Y} {fâ‚‚ : Y âŸ¶ Z} [Mono fâ‚‚]\n    (big_k : IsKernelPair (fâ‚ â‰« fâ‚‚) a b) : IsKernelPair fâ‚ a b :=\n  cancel_right (by rw [â† cancel_mono fâ‚‚, assoc, assoc, big_k.w]) big_k\n\n"}
{"name":"CategoryTheory.IsKernelPair.comp_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nR X Y Z : C\na b : Quiver.Hom R X\nfâ‚ : Quiver.Hom X Y\nfâ‚‚ : Quiver.Hom Y Z\ninstâœ : CategoryTheory.Mono fâ‚‚\nsmall_k : CategoryTheory.IsKernelPair fâ‚ a b\nâŠ¢ CategoryTheory.IsKernelPair (CategoryTheory.CategoryStruct.comp fâ‚ fâ‚‚) a b","decl":"/--\nIf `(a,b)` is a kernel pair for `fâ‚` and `fâ‚‚` is mono, then `(a,b)` is a kernel pair for `fâ‚ â‰« fâ‚‚`.\nThe converse of `cancel_right_of_mono`.\n-/\ntheorem comp_of_mono {fâ‚ : X âŸ¶ Y} {fâ‚‚ : Y âŸ¶ Z} [Mono fâ‚‚] (small_k : IsKernelPair fâ‚ a b) :\n    IsKernelPair (fâ‚ â‰« fâ‚‚) a b :=\n  { w := by rw [small_k.w_assoc]\n    isLimit' := âŸ¨by\n      refine PullbackCone.isLimitAux _\n        (fun s => small_k.lift s.fst s.snd (by rw [â† cancel_mono fâ‚‚, assoc, s.condition, assoc]))\n        (by simp) (by simp) ?_\n      intro s m hm\n      apply small_k.isLimit.hom_ext\n      apply PullbackCone.equalizer_ext small_k.cone _ _\n      Â· exact (hm WalkingCospan.left).trans (by simp)\n      Â· exact (hm WalkingCospan.right).trans (by simp)âŸ© }\n\n"}
{"name":"CategoryTheory.IsKernelPair.pullback","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nX Y Z A : C\ng : Quiver.Hom Y Z\naâ‚ aâ‚‚ : Quiver.Hom A Y\nh : CategoryTheory.IsKernelPair g aâ‚ aâ‚‚\nf : Quiver.Hom X Z\ninstâœÂ¹ : CategoryTheory.Limits.HasPullback f g\ninstâœ : CategoryTheory.Limits.HasPullback f (CategoryTheory.CategoryStruct.comp aâ‚ g)\nâŠ¢ CategoryTheory.IsKernelPair (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.map f (CategoryTheory.CategoryStruct.comp aâ‚ g) f g (CategoryTheory.CategoryStruct.id X) aâ‚ (CategoryTheory.CategoryStruct.id Z) â‹¯ â‹¯) (CategoryTheory.Limits.pullback.map f (CategoryTheory.CategoryStruct.comp aâ‚ g) f g (CategoryTheory.CategoryStruct.id X) aâ‚‚ (CategoryTheory.CategoryStruct.id Z) â‹¯ â‹¯)","decl":"/-- If `aâ‚ aâ‚‚ : A âŸ¶ Y` is a kernel pair for `g : Y âŸ¶ Z`, then `aâ‚ Ã—[Z] X` and `aâ‚‚ Ã—[Z] X`\n(`A Ã—[Z] X âŸ¶ Y Ã—[Z] X`) is a kernel pair for `Y Ã—[Z] X âŸ¶ X`. -/\nprotected theorem pullback {X Y Z A : C} {g : Y âŸ¶ Z} {aâ‚ aâ‚‚ : A âŸ¶ Y} (h : IsKernelPair g aâ‚ aâ‚‚)\n    (f : X âŸ¶ Z) [HasPullback f g] [HasPullback f (aâ‚ â‰« g)] :\n    IsKernelPair (pullback.fst f g)\n      (pullback.map f _ f _ (ğŸ™ X) aâ‚ (ğŸ™ Z) (by simp) <| Category.comp_id _)\n      (pullback.map _ _ _ _ (ğŸ™ X) aâ‚‚ (ğŸ™ Z) (by simp) <| (Category.comp_id _).trans h.1.1) := by\n  refine âŸ¨âŸ¨by rw [pullback.lift_fst, pullback.lift_fst]âŸ©, âŸ¨PullbackCone.isLimitAux _\n    (fun s => pullback.lift (s.fst â‰« pullback.fst _ _)\n      (h.lift (s.fst â‰« pullback.snd _ _) (s.snd â‰« pullback.snd _ _) ?_ ) ?_) (fun s => ?_)\n        (fun s => ?_) (fun s m hm => ?_)âŸ©âŸ©\n  Â· simp_rw [Category.assoc, â† pullback.condition, â† Category.assoc, s.condition]\n  Â· simp only [assoc, lift_fst_assoc, pullback.condition]\n  Â· ext <;> simp\n  Â· ext\n    Â· simp [s.condition]\n    Â· simp\n  Â· #adaptation_note /-- nightly-2024-04-01\n    This `symm` (or the following ones that undo it) wasn't previously necessary. -/\n    symm\n    apply pullback.hom_ext\n    Â· symm\n      simpa using hm WalkingCospan.left =â‰« pullback.fst f g\n    Â· symm\n      apply PullbackCone.IsLimit.hom_ext h.isLimit\n      Â· simpa using hm WalkingCospan.left =â‰« pullback.snd f g\n      Â· simpa using hm WalkingCospan.right =â‰« pullback.snd f g\n\n"}
{"name":"CategoryTheory.IsKernelPair.mono_of_isIso_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nR X Y : C\nf : Quiver.Hom X Y\na b : Quiver.Hom R X\nh : CategoryTheory.IsKernelPair f a b\ninstâœ : CategoryTheory.IsIso a\nâŠ¢ CategoryTheory.Mono f","decl":"theorem mono_of_isIso_fst (h : IsKernelPair f a b) [IsIso a] : Mono f := by\n  obtain âŸ¨l, hâ‚, hâ‚‚âŸ© := Limits.PullbackCone.IsLimit.lift' h.isLimit (ğŸ™ _) (ğŸ™ _) (by simp [h.w])\n  rw [IsPullback.cone_fst, â† IsIso.eq_comp_inv, Category.id_comp] at hâ‚\n  rw [hâ‚, IsIso.inv_comp_eq, Category.comp_id] at hâ‚‚\n  constructor\n  intro Z gâ‚ gâ‚‚ e\n  obtain âŸ¨l', rfl, rflâŸ© := Limits.PullbackCone.IsLimit.lift' h.isLimit _ _ e\n  rw [IsPullback.cone_fst, hâ‚‚]\n\n"}
{"name":"CategoryTheory.IsKernelPair.isIso_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nR X Y : C\nf : Quiver.Hom X Y\na b : Quiver.Hom R X\nh : CategoryTheory.IsKernelPair f a b\ninstâœ : CategoryTheory.Mono f\nâŠ¢ CategoryTheory.IsIso a","decl":"theorem isIso_of_mono (h : IsKernelPair f a b) [Mono f] : IsIso a := by\n  rw [â†\n    show _ = a from\n      (Category.comp_id _).symm.trans\n        ((IsKernelPair.id_of_mono f).isLimit.conePointUniqueUpToIso_inv_comp h.isLimit\n          WalkingCospan.left)]\n  infer_instance\n\n"}
{"name":"CategoryTheory.IsKernelPair.of_isIso_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.KernelPair","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nR X Y : C\nf : Quiver.Hom X Y\na : Quiver.Hom R X\ninstâœÂ¹ : CategoryTheory.IsIso a\ninstâœ : CategoryTheory.Mono f\nâŠ¢ CategoryTheory.IsKernelPair f a a","decl":"theorem of_isIso_of_mono [IsIso a] [Mono f] : IsKernelPair f a a := by\n  change IsPullback _ _ _ _\n  convert (IsPullback.of_horiz_isIso âŸ¨(rfl : a â‰« ğŸ™ X = _ )âŸ©).paste_vert (IsKernelPair.id_of_mono f)\n  all_goals { simp }\n\n"}
