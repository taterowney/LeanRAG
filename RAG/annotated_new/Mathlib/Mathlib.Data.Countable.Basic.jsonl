{"name":"instCountableInt","module":"Mathlib.Data.Countable.Basic","initialProofState":"⊢ Countable Int","decl":"instance : Countable ℤ :=\n  Countable.of_equiv ℕ Equiv.intEquivNat.symm\n\n"}
{"name":"countable_iff_nonempty_embedding","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Sort u\n⊢ Iff (Countable α) (Nonempty (Function.Embedding α Nat))","decl":"theorem countable_iff_nonempty_embedding : Countable α ↔ Nonempty (α ↪ ℕ) :=\n  ⟨fun ⟨⟨f, hf⟩⟩ => ⟨⟨f, hf⟩⟩, fun ⟨f⟩ => ⟨⟨f, f.2⟩⟩⟩\n\n"}
{"name":"uncountable_iff_isEmpty_embedding","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Sort u\n⊢ Iff (Uncountable α) (IsEmpty (Function.Embedding α Nat))","decl":"theorem uncountable_iff_isEmpty_embedding : Uncountable α ↔ IsEmpty (α ↪ ℕ) := by\n  rw [← not_countable_iff, countable_iff_nonempty_embedding, not_nonempty_iff]\n\n"}
{"name":"nonempty_embedding_nat","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Sort u_1\ninst✝ : Countable α\n⊢ Nonempty (Function.Embedding α Nat)","decl":"theorem nonempty_embedding_nat (α) [Countable α] : Nonempty (α ↪ ℕ) :=\n  countable_iff_nonempty_embedding.1 ‹_›\n\n"}
{"name":"Function.Embedding.countable","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Sort u\nβ : Sort v\ninst✝ : Countable β\nf : Function.Embedding α β\n⊢ Countable α","decl":"protected theorem Function.Embedding.countable [Countable β] (f : α ↪ β) : Countable α :=\n  f.injective.countable\n\n"}
{"name":"Function.Embedding.uncountable","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Sort u\nβ : Sort v\ninst✝ : Uncountable α\nf : Function.Embedding α β\n⊢ Uncountable β","decl":"protected lemma Function.Embedding.uncountable [Uncountable α] (f : α ↪ β) : Uncountable β :=\n  f.injective.uncountable\n\n"}
{"name":"instCountableSum","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Countable α\ninst✝ : Countable β\n⊢ Countable (Sum α β)","decl":"instance [Countable α] [Countable β] : Countable (α ⊕ β) := by\n  rcases exists_injective_nat α with ⟨f, hf⟩\n  rcases exists_injective_nat β with ⟨g, hg⟩\n  exact (Equiv.natSumNatEquivNat.injective.comp <| hf.sum_map hg).countable\n\n"}
{"name":"Sum.uncountable_inl","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Uncountable α\n⊢ Uncountable (Sum α β)","decl":"instance Sum.uncountable_inl [Uncountable α] : Uncountable (α ⊕ β) :=\n  inl_injective.uncountable\n\n"}
{"name":"Sum.uncountable_inr","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Uncountable β\n⊢ Uncountable (Sum α β)","decl":"instance Sum.uncountable_inr [Uncountable β] : Uncountable (α ⊕ β) :=\n  inr_injective.uncountable\n\n"}
{"name":"Option.instCountable","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Type u\ninst✝ : Countable α\n⊢ Countable (Option α)","decl":"instance Option.instCountable [Countable α] : Countable (Option α) :=\n  Countable.of_equiv _ (Equiv.optionEquivSumPUnit.{0, _} α).symm\n\n"}
{"name":"WithTop.instCountable","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Type u\ninst✝ : Countable α\n⊢ Countable (WithTop α)","decl":"instance WithTop.instCountable [Countable α] : Countable (WithTop α) := Option.instCountable\n"}
{"name":"WithBot.instCountable","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Type u\ninst✝ : Countable α\n⊢ Countable (WithBot α)","decl":"instance WithBot.instCountable [Countable α] : Countable (WithBot α) := Option.instCountable\n"}
{"name":"ENat.instCountable","module":"Mathlib.Data.Countable.Basic","initialProofState":"⊢ Countable ENat","decl":"instance ENat.instCountable : Countable ℕ∞ := Option.instCountable\n\n"}
{"name":"Option.instUncountable","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Type u\ninst✝ : Uncountable α\n⊢ Uncountable (Option α)","decl":"instance Option.instUncountable [Uncountable α] : Uncountable (Option α) :=\n  Injective.uncountable fun _ _ ↦ Option.some_inj.1\n\n"}
{"name":"WithTop.instUncountable","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Type u\ninst✝ : Uncountable α\n⊢ Uncountable (WithTop α)","decl":"instance WithTop.instUncountable [Uncountable α] : Uncountable (WithTop α) := Option.instUncountable\n"}
{"name":"WithBot.instUncountable","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Type u\ninst✝ : Uncountable α\n⊢ Uncountable (WithBot α)","decl":"instance WithBot.instUncountable [Uncountable α] : Uncountable (WithBot α) := Option.instUncountable\n\n"}
{"name":"instCountableProd","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Countable α\ninst✝ : Countable β\n⊢ Countable (Prod α β)","decl":"instance [Countable α] [Countable β] : Countable (α × β) := by\n  rcases exists_injective_nat α with ⟨f, hf⟩\n  rcases exists_injective_nat β with ⟨g, hg⟩\n  exact (Nat.pairEquiv.injective.comp <| hf.prodMap hg).countable\n\n"}
{"name":"instUncountableProdOfNonempty","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Uncountable α\ninst✝ : Nonempty β\n⊢ Uncountable (Prod α β)","decl":"instance [Uncountable α] [Nonempty β] : Uncountable (α × β) := by\n  inhabit β\n  exact (Prod.mk.inj_right default).uncountable\n\n"}
{"name":"instUncountableProdOfNonempty_1","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Nonempty α\ninst✝ : Uncountable β\n⊢ Uncountable (Prod α β)","decl":"instance [Nonempty α] [Uncountable β] : Uncountable (α × β) := by\n  inhabit α\n  exact (Prod.mk.inj_left default).uncountable\n\n"}
{"name":"countable_left_of_prod_of_nonempty","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Nonempty β\nh : Countable (Prod α β)\n⊢ Countable α","decl":"lemma countable_left_of_prod_of_nonempty [Nonempty β] (h : Countable (α × β)) : Countable α := by\n  contrapose h\n  rw [not_countable_iff] at *\n  infer_instance\n\n"}
{"name":"countable_right_of_prod_of_nonempty","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Nonempty α\nh : Countable (Prod α β)\n⊢ Countable β","decl":"lemma countable_right_of_prod_of_nonempty [Nonempty α] (h : Countable (α × β)) : Countable β := by\n  contrapose h\n  rw [not_countable_iff] at *\n  infer_instance\n\n"}
{"name":"countable_prod_swap","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Countable (Prod α β)\n⊢ Countable (Prod β α)","decl":"lemma countable_prod_swap [Countable (α × β)] : Countable (β × α) :=\n  Countable.of_equiv _ (Equiv.prodComm α β)\n\n"}
{"name":"instCountableSigma","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Type u\nπ : α → Type w\ninst✝¹ : Countable α\ninst✝ : ∀ (a : α), Countable (π a)\n⊢ Countable (Sigma π)","decl":"instance [Countable α] [∀ a, Countable (π a)] : Countable (Sigma π) := by\n  rcases exists_injective_nat α with ⟨f, hf⟩\n  choose g hg using fun a => exists_injective_nat (π a)\n  exact ((Equiv.sigmaEquivProd ℕ ℕ).injective.comp <| hf.sigma_map hg).countable\n\n"}
{"name":"Sigma.uncountable","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Type u\nπ : α → Type w\na : α\ninst✝ : Uncountable (π a)\n⊢ Uncountable (Sigma π)","decl":"lemma Sigma.uncountable (a : α) [Uncountable (π a)] : Uncountable (Sigma π) :=\n  (sigma_mk_injective (i := a)).uncountable\n\n"}
{"name":"instUncountableSigmaOfNonempty","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Type u\nπ : α → Type w\ninst✝¹ : Nonempty α\ninst✝ : ∀ (a : α), Uncountable (π a)\n⊢ Uncountable (Sigma π)","decl":"instance [Nonempty α] [∀ a, Uncountable (π a)] : Uncountable (Sigma π) := by\n  inhabit α; exact Sigma.uncountable default\n\n"}
{"name":"SetCoe.countable","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Type u\ninst✝ : Countable α\ns : Set α\n⊢ Countable ↑s","decl":"instance (priority := 500) SetCoe.countable [Countable α] (s : Set α) : Countable s :=\n  Subtype.countable\n\n"}
{"name":"instCountablePSum","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Sort u\nβ : Sort v\ninst✝¹ : Countable α\ninst✝ : Countable β\n⊢ Countable (PSum α β)","decl":"instance [Countable α] [Countable β] : Countable (α ⊕' β) :=\n  Countable.of_equiv (PLift α ⊕ PLift β) (Equiv.plift.sumPSum Equiv.plift)\n\n"}
{"name":"instCountablePProd","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Sort u\nβ : Sort v\ninst✝¹ : Countable α\ninst✝ : Countable β\n⊢ Countable (PProd α β)","decl":"instance [Countable α] [Countable β] : Countable (PProd α β) :=\n  Countable.of_equiv (PLift α × PLift β) (Equiv.plift.prodPProd Equiv.plift)\n\n"}
{"name":"instCountablePSigma","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Sort u\nπ : α → Sort w\ninst✝¹ : Countable α\ninst✝ : ∀ (a : α), Countable (π a)\n⊢ Countable (PSigma π)","decl":"instance [Countable α] [∀ a, Countable (π a)] : Countable (PSigma π) :=\n  Countable.of_equiv (Σa : PLift α, PLift (π a.down)) (Equiv.psigmaEquivSigmaPLift π).symm\n\n"}
{"name":"instCountableForallOfFinite","module":"Mathlib.Data.Countable.Basic","initialProofState":"α : Sort u\nπ : α → Sort w\ninst✝¹ : Finite α\ninst✝ : ∀ (a : α), Countable (π a)\n⊢ Countable ((a : α) → π a)","decl":"instance [Finite α] [∀ a, Countable (π a)] : Countable (∀ a, π a) := by\n  have : ∀ n, Countable (Fin n → ℕ) := by\n    intro n\n    induction' n with n ihn\n    · change Countable (Fin 0 → ℕ); infer_instance\n    · haveI := ihn\n      exact Countable.of_equiv (ℕ × (Fin n → ℕ)) (Fin.consEquiv fun _ ↦ ℕ)\n  rcases Finite.exists_equiv_fin α with ⟨n, ⟨e⟩⟩\n  have f := fun a => (nonempty_embedding_nat (π a)).some\n  exact ((Embedding.piCongrRight f).trans (Equiv.piCongrLeft' _ e).toEmbedding).countable\n\n"}
