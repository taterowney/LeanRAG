{"name":"NumberField.FinitePlace.prod_eq_inv_abs_norm_int","module":"Mathlib.NumberTheory.NumberField.ProductFormula","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : NumberField.RingOfIntegers K\nh_x_nezero : Ne x 0\n⊢ Eq (finprod fun w => w ↑x) (Inv.inv (abs ↑((Algebra.norm Int) x)))","decl":"open Function Ideal IsDedekindDomain HeightOneSpectrum in\n/-- For any non-zero `x` in `𝓞 K`, the prduct of `w x`, where `w` runs over `FinitePlace K`, is\nequal to the inverse of the absolute value of `Algebra.norm ℤ x`. -/\ntheorem FinitePlace.prod_eq_inv_abs_norm_int {x : 𝓞 K} (h_x_nezero : x ≠ 0) :\n    ∏ᶠ w : FinitePlace K, w x = (|norm ℤ x| : ℝ)⁻¹ := by\n  simp only [← finprod_comp_equiv equivHeightOneSpectrum.symm, equivHeightOneSpectrum_symm_apply]\n  refine (inv_eq_of_mul_eq_one_left ?_).symm\n  norm_cast\n  have h_span_nezero : span {x} ≠ 0 := by simp [h_x_nezero]\n  rw [Int.abs_eq_natAbs, ← absNorm_span_singleton,\n    ← finprod_heightOneSpectrum_factorization h_span_nezero, Int.cast_natCast]\n  let t₀ := {v : HeightOneSpectrum (𝓞 K) | x ∈ v.asIdeal}\n  have h_fin₀ : t₀.Finite := by simp only [← dvd_span_singleton, finite_factors h_span_nezero, t₀]\n  let t₁ := (fun v : HeightOneSpectrum (𝓞 K) ↦ ‖embedding v x‖).mulSupport\n  let t₂ :=\n    (fun v : HeightOneSpectrum (𝓞 K) ↦ (absNorm (v.maxPowDividing (span {x})) : ℝ)).mulSupport\n  have h_fin₁ : t₁.Finite := h_fin₀.subset <| by simp [norm_eq_one_iff_not_mem, t₁, t₀]\n  have h_fin₂ : t₂.Finite := by\n    refine h_fin₀.subset ?_\n    simp only [Set.le_eq_subset, mulSupport_subset_iff, Set.mem_setOf_eq, t₂, t₀,\n      maxPowDividing, ← dvd_span_singleton]\n    intro v hv\n    simp only [map_pow, Nat.cast_pow, ← pow_zero (absNorm v.asIdeal : ℝ)] at hv\n    classical\n    refine (Associates.count_ne_zero_iff_dvd h_span_nezero (irreducible v)).1 <| fun h ↦ hv ?_\n    congr\n  have h_prod : (absNorm (∏ᶠ (v : HeightOneSpectrum (𝓞 K)), v.maxPowDividing (span {x})) : ℝ) =\n      ∏ᶠ (v : HeightOneSpectrum (𝓞 K)), (absNorm (v.maxPowDividing (span {x})) : ℝ) :=\n    ((Nat.castRingHom ℝ).toMonoidHom.comp absNorm.toMonoidHom).map_finprod_of_preimage_one\n      (by simp) _\n  rw [h_prod, ← finprod_mul_distrib h_fin₁ h_fin₂]\n  exact finprod_eq_one_of_forall_eq_one fun v ↦ v.embedding_mul_absNorm h_x_nezero\n\n"}
{"name":"NumberField.FinitePlace.prod_eq_inv_abs_norm","module":"Mathlib.NumberTheory.NumberField.ProductFormula","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : K\nh_x_nezero : Ne x 0\n⊢ Eq (finprod fun w => w x) ↑(Inv.inv (abs ((Algebra.norm Rat) x)))","decl":"/-- For any non-zero `x` in `K`, the prduct of `w x`, where `w` runs over `FinitePlace K`, is\nequal to the inverse of the absolute value of `Algebra.norm ℚ x`. -/\ntheorem FinitePlace.prod_eq_inv_abs_norm {x : K} (h_x_nezero : x ≠ 0) :\n    ∏ᶠ w : FinitePlace K, w x = |(Algebra.norm ℚ) x|⁻¹ := by\n  --reduce to 𝓞 K\n  rcases IsFractionRing.div_surjective (A := 𝓞 K) x with ⟨a, b, hb, rfl⟩\n  apply nonZeroDivisors.ne_zero at hb\n  have ha : a ≠ 0 := by\n    rintro rfl\n    simp at h_x_nezero\n  simp_rw [map_div₀, Rat.cast_inv, Rat.cast_abs, finprod_div_distrib (mulSupport_finite_int ha)\n    (mulSupport_finite_int hb), prod_eq_inv_abs_norm_int ha, prod_eq_inv_abs_norm_int hb]\n  rw [← inv_eq_iff_eq_inv, inv_inv_div_inv, ← abs_div]\n  congr\n  have hb₀ : ((Algebra.norm ℤ) b : ℝ) ≠ 0 := by simp [hb]\n  refine (eq_div_of_mul_eq hb₀ ?_).symm\n  norm_cast\n  rw [coe_norm_int a, coe_norm_int b, ← MonoidHom.map_mul, div_mul_cancel₀ _\n    (RingOfIntegers.coe_ne_zero_iff.mpr hb)]\n\n"}
{"name":"NumberField.prod_abs_eq_one","module":"Mathlib.NumberTheory.NumberField.ProductFormula","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : K\nh_x_nezero : Ne x 0\n⊢ Eq (HMul.hMul (Finset.univ.prod fun w => HPow.hPow (w x) w.mult) (finprod fun w => w x)) 1","decl":"open FinitePlace in\n/-- The Product Formula for the Number Field `K`. -/\ntheorem prod_abs_eq_one {x : K} (h_x_nezero : x ≠ 0) :\n    (∏ w : InfinitePlace K, w x ^ w.mult) * ∏ᶠ w : FinitePlace K, w x = 1 := by\n  simp [prod_eq_inv_abs_norm, InfinitePlace.prod_eq_abs_norm, h_x_nezero]\n\n"}
