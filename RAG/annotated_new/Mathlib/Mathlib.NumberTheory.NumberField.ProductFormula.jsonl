{"name":"NumberField.FinitePlace.prod_eq_inv_abs_norm_int","module":"Mathlib.NumberTheory.NumberField.ProductFormula","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.RingOfIntegers K\nh_x_nezero : Ne x 0\nâŠ¢ Eq (finprod fun w => w â†‘x) (Inv.inv (abs â†‘((Algebra.norm Int) x)))","decl":"open Function Ideal IsDedekindDomain HeightOneSpectrum in\n/-- For any non-zero `x` in `ğ“ K`, the prduct of `w x`, where `w` runs over `FinitePlace K`, is\nequal to the inverse of the absolute value of `Algebra.norm â„¤ x`. -/\ntheorem FinitePlace.prod_eq_inv_abs_norm_int {x : ğ“ K} (h_x_nezero : x â‰  0) :\n    âˆá¶  w : FinitePlace K, w x = (|norm â„¤ x| : â„)â»Â¹ := by\n  simp only [â† finprod_comp_equiv equivHeightOneSpectrum.symm, equivHeightOneSpectrum_symm_apply]\n  refine (inv_eq_of_mul_eq_one_left ?_).symm\n  norm_cast\n  have h_span_nezero : span {x} â‰  0 := by simp [h_x_nezero]\n  rw [Int.abs_eq_natAbs, â† absNorm_span_singleton,\n    â† finprod_heightOneSpectrum_factorization h_span_nezero, Int.cast_natCast]\n  let tâ‚€ := {v : HeightOneSpectrum (ğ“ K) | x âˆˆ v.asIdeal}\n  have h_finâ‚€ : tâ‚€.Finite := by simp only [â† dvd_span_singleton, finite_factors h_span_nezero, tâ‚€]\n  let tâ‚ := (fun v : HeightOneSpectrum (ğ“ K) â†¦ â€–embedding v xâ€–).mulSupport\n  let tâ‚‚ :=\n    (fun v : HeightOneSpectrum (ğ“ K) â†¦ (absNorm (v.maxPowDividing (span {x})) : â„)).mulSupport\n  have h_finâ‚ : tâ‚.Finite := h_finâ‚€.subset <| by simp [norm_eq_one_iff_not_mem, tâ‚, tâ‚€]\n  have h_finâ‚‚ : tâ‚‚.Finite := by\n    refine h_finâ‚€.subset ?_\n    simp only [Set.le_eq_subset, mulSupport_subset_iff, Set.mem_setOf_eq, tâ‚‚, tâ‚€,\n      maxPowDividing, â† dvd_span_singleton]\n    intro v hv\n    simp only [map_pow, Nat.cast_pow, â† pow_zero (absNorm v.asIdeal : â„)] at hv\n    classical\n    refine (Associates.count_ne_zero_iff_dvd h_span_nezero (irreducible v)).1 <| fun h â†¦ hv ?_\n    congr\n  have h_prod : (absNorm (âˆá¶  (v : HeightOneSpectrum (ğ“ K)), v.maxPowDividing (span {x})) : â„) =\n      âˆá¶  (v : HeightOneSpectrum (ğ“ K)), (absNorm (v.maxPowDividing (span {x})) : â„) :=\n    ((Nat.castRingHom â„).toMonoidHom.comp absNorm.toMonoidHom).map_finprod_of_preimage_one\n      (by simp) _\n  rw [h_prod, â† finprod_mul_distrib h_finâ‚ h_finâ‚‚]\n  exact finprod_eq_one_of_forall_eq_one fun v â†¦ v.embedding_mul_absNorm h_x_nezero\n\n"}
{"name":"NumberField.FinitePlace.prod_eq_inv_abs_norm","module":"Mathlib.NumberTheory.NumberField.ProductFormula","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : K\nh_x_nezero : Ne x 0\nâŠ¢ Eq (finprod fun w => w x) â†‘(Inv.inv (abs ((Algebra.norm Rat) x)))","decl":"/-- For any non-zero `x` in `K`, the prduct of `w x`, where `w` runs over `FinitePlace K`, is\nequal to the inverse of the absolute value of `Algebra.norm â„š x`. -/\ntheorem FinitePlace.prod_eq_inv_abs_norm {x : K} (h_x_nezero : x â‰  0) :\n    âˆá¶  w : FinitePlace K, w x = |(Algebra.norm â„š) x|â»Â¹ := by\n  --reduce to ğ“ K\n  rcases IsFractionRing.div_surjective (A := ğ“ K) x with âŸ¨a, b, hb, rflâŸ©\n  apply nonZeroDivisors.ne_zero at hb\n  have ha : a â‰  0 := by\n    rintro rfl\n    simp at h_x_nezero\n  simp_rw [map_divâ‚€, Rat.cast_inv, Rat.cast_abs, finprod_div_distrib (mulSupport_finite_int ha)\n    (mulSupport_finite_int hb), prod_eq_inv_abs_norm_int ha, prod_eq_inv_abs_norm_int hb]\n  rw [â† inv_eq_iff_eq_inv, inv_inv_div_inv, â† abs_div]\n  congr\n  have hbâ‚€ : ((Algebra.norm â„¤) b : â„) â‰  0 := by simp [hb]\n  refine (eq_div_of_mul_eq hbâ‚€ ?_).symm\n  norm_cast\n  rw [coe_norm_int a, coe_norm_int b, â† MonoidHom.map_mul, div_mul_cancelâ‚€ _\n    (RingOfIntegers.coe_ne_zero_iff.mpr hb)]\n\n"}
{"name":"NumberField.prod_abs_eq_one","module":"Mathlib.NumberTheory.NumberField.ProductFormula","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : K\nh_x_nezero : Ne x 0\nâŠ¢ Eq (HMul.hMul (Finset.univ.prod fun w => HPow.hPow (w x) w.mult) (finprod fun w => w x)) 1","decl":"open FinitePlace in\n/-- The Product Formula for the Number Field `K`. -/\ntheorem prod_abs_eq_one {x : K} (h_x_nezero : x â‰  0) :\n    (âˆ w : InfinitePlace K, w x ^ w.mult) * âˆá¶  w : FinitePlace K, w x = 1 := by\n  simp [prod_eq_inv_abs_norm, InfinitePlace.prod_eq_abs_norm, h_x_nezero]\n\n"}
