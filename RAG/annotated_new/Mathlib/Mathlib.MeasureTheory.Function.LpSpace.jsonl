{"name":"MeasureTheory.eLpNorm_aeeqFun","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_5\nE : Type u_6\ninst‚úù¬π : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nf : Œ± ‚Üí E\nhf : MeasureTheory.AEStronglyMeasurable f Œº\n‚ä¢ Eq (MeasureTheory.eLpNorm (‚Üë(MeasureTheory.AEEqFun.mk f hf)) p Œº) (MeasureTheory.eLpNorm f p Œº)","decl":"@[simp]\ntheorem eLpNorm_aeeqFun {Œ± E : Type*} [MeasurableSpace Œ±] {Œº : Measure Œ±} [NormedAddCommGroup E]\n    {p : ‚Ñù‚â•0‚àû} {f : Œ± ‚Üí E} (hf : AEStronglyMeasurable f Œº) :\n    eLpNorm (AEEqFun.mk f hf) p Œº = eLpNorm f p Œº :=\n  eLpNorm_congr_ae (AEEqFun.coeFn_mk _ _)\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.eLpNorm_mk_lt_top","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_5\nE : Type u_6\ninst‚úù¬π : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nf : Œ± ‚Üí E\nhfp : MeasureTheory.Mem‚Ñíp f p Œº\n‚ä¢ LT.lt (MeasureTheory.eLpNorm (‚Üë(MeasureTheory.AEEqFun.mk f ‚ãØ)) p Œº) Top.top","decl":"theorem Mem‚Ñíp.eLpNorm_mk_lt_top {Œ± E : Type*} [MeasurableSpace Œ±] {Œº : Measure Œ±}\n    [NormedAddCommGroup E] {p : ‚Ñù‚â•0‚àû} {f : Œ± ‚Üí E} (hfp : Mem‚Ñíp f p Œº) :\n    eLpNorm (AEEqFun.mk f hfp.1) p Œº < ‚àû := by simp [hfp.2]\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.toLp_val","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Œ± ‚Üí E\nh : MeasureTheory.Mem‚Ñíp f p Œº\n‚ä¢ Eq (‚Üë(MeasureTheory.Mem‚Ñíp.toLp f h)) (MeasureTheory.AEEqFun.mk f ‚ãØ)","decl":"theorem toLp_val {f : Œ± ‚Üí E} (h : Mem‚Ñíp f p Œº) : (toLp f h).1 = AEEqFun.mk f h.1 := rfl\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.coeFn_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f p Œº\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (‚Üë‚Üë(MeasureTheory.Mem‚Ñíp.toLp f hf)) f","decl":"theorem coeFn_toLp {f : Œ± ‚Üí E} (hf : Mem‚Ñíp f p Œº) : hf.toLp f =·µê[Œº] f :=\n  AEEqFun.coeFn_mk _ _\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.toLp_congr","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf g : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nhg : MeasureTheory.Mem‚Ñíp g p Œº\nhfg : (MeasureTheory.ae Œº).EventuallyEq f g\n‚ä¢ Eq (MeasureTheory.Mem‚Ñíp.toLp f hf) (MeasureTheory.Mem‚Ñíp.toLp g hg)","decl":"theorem toLp_congr {f g : Œ± ‚Üí E} (hf : Mem‚Ñíp f p Œº) (hg : Mem‚Ñíp g p Œº) (hfg : f =·µê[Œº] g) :\n    hf.toLp f = hg.toLp g := by simp [toLp, hfg]\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.toLp_eq_toLp_iff","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf g : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nhg : MeasureTheory.Mem‚Ñíp g p Œº\n‚ä¢ Iff (Eq (MeasureTheory.Mem‚Ñíp.toLp f hf) (MeasureTheory.Mem‚Ñíp.toLp g hg)) ((MeasureTheory.ae Œº).EventuallyEq f g)","decl":"@[simp]\ntheorem toLp_eq_toLp_iff {f g : Œ± ‚Üí E} (hf : Mem‚Ñíp f p Œº) (hg : Mem‚Ñíp g p Œº) :\n    hf.toLp f = hg.toLp g ‚Üî f =·µê[Œº] g := by simp [toLp]\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.toLp_zero","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nh : MeasureTheory.Mem‚Ñíp 0 p Œº\n‚ä¢ Eq (MeasureTheory.Mem‚Ñíp.toLp 0 h) 0","decl":"@[simp]\ntheorem toLp_zero (h : Mem‚Ñíp (0 : Œ± ‚Üí E) p Œº) : h.toLp 0 = 0 :=\n  rfl\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.toLp_add","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf g : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nhg : MeasureTheory.Mem‚Ñíp g p Œº\n‚ä¢ Eq (MeasureTheory.Mem‚Ñíp.toLp (HAdd.hAdd f g) ‚ãØ) (HAdd.hAdd (MeasureTheory.Mem‚Ñíp.toLp f hf) (MeasureTheory.Mem‚Ñíp.toLp g hg))","decl":"theorem toLp_add {f g : Œ± ‚Üí E} (hf : Mem‚Ñíp f p Œº) (hg : Mem‚Ñíp g p Œº) :\n    (hf.add hg).toLp (f + g) = hf.toLp f + hg.toLp g :=\n  rfl\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.toLp_neg","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f p Œº\n‚ä¢ Eq (MeasureTheory.Mem‚Ñíp.toLp (Neg.neg f) ‚ãØ) (Neg.neg (MeasureTheory.Mem‚Ñíp.toLp f hf))","decl":"theorem toLp_neg {f : Œ± ‚Üí E} (hf : Mem‚Ñíp f p Œº) : hf.neg.toLp (-f) = -hf.toLp f :=\n  rfl\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.toLp_sub","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf g : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nhg : MeasureTheory.Mem‚Ñíp g p Œº\n‚ä¢ Eq (MeasureTheory.Mem‚Ñíp.toLp (HSub.hSub f g) ‚ãØ) (HSub.hSub (MeasureTheory.Mem‚Ñíp.toLp f hf) (MeasureTheory.Mem‚Ñíp.toLp g hg))","decl":"theorem toLp_sub {f g : Œ± ‚Üí E} (hf : Mem‚Ñíp f p Œº) (hg : Mem‚Ñíp g p Œº) :\n    (hf.sub hg).toLp (f - g) = hf.toLp f - hg.toLp g :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.ext","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\nh : (MeasureTheory.ae Œº).EventuallyEq ‚Üë‚Üëf ‚Üë‚Üëg\n‚ä¢ Eq f g","decl":"@[ext high]\ntheorem ext {f g : Lp E p Œº} (h : f =·µê[Œº] g) : f = g := by\n  cases f\n  cases g\n  simp only [Subtype.mk_eq_mk]\n  exact AEEqFun.ext h\n\n"}
{"name":"MeasureTheory.Lp.ext_iff","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Iff (Eq f g) ((MeasureTheory.ae Œº).EventuallyEq ‚Üë‚Üëf ‚Üë‚Üëg)","decl":"@[ext high]\ntheorem ext {f g : Lp E p Œº} (h : f =·µê[Œº] g) : f = g := by\n  cases f\n  cases g\n  simp only [Subtype.mk_eq_mk]\n  exact AEEqFun.ext h\n\n"}
{"name":"MeasureTheory.Lp.mem_Lp_iff_eLpNorm_lt_top","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : MeasureTheory.AEEqFun Œ± E Œº\n‚ä¢ Iff (Membership.mem (MeasureTheory.Lp E p Œº) f) (LT.lt (MeasureTheory.eLpNorm (‚Üëf) p Œº) Top.top)","decl":"theorem mem_Lp_iff_eLpNorm_lt_top {f : Œ± ‚Üí‚Çò[Œº] E} : f ‚àà Lp E p Œº ‚Üî eLpNorm f p Œº < ‚àû := Iff.rfl\n\n"}
{"name":"MeasureTheory.Lp.mem_Lp_iff_mem‚Ñíp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : MeasureTheory.AEEqFun Œ± E Œº\n‚ä¢ Iff (Membership.mem (MeasureTheory.Lp E p Œº) f) (MeasureTheory.Mem‚Ñíp (‚Üëf) p Œº)","decl":"theorem mem_Lp_iff_mem‚Ñíp {f : Œ± ‚Üí‚Çò[Œº] E} : f ‚àà Lp E p Œº ‚Üî Mem‚Ñíp f p Œº := by\n  simp [mem_Lp_iff_eLpNorm_lt_top, Mem‚Ñíp, f.stronglyMeasurable.aestronglyMeasurable]\n\n"}
{"name":"MeasureTheory.Lp.antitone","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\np q : ENNReal\nhpq : LE.le p q\n‚ä¢ LE.le (MeasureTheory.Lp E q Œº) (MeasureTheory.Lp E p Œº)","decl":"protected theorem antitone [IsFiniteMeasure Œº] {p q : ‚Ñù‚â•0‚àû} (hpq : p ‚â§ q) : Lp E q Œº ‚â§ Lp E p Œº :=\n  fun f hf => (Mem‚Ñíp.mono_exponent ‚ü®f.aestronglyMeasurable, hf‚ü© hpq).2\n\n"}
{"name":"MeasureTheory.Lp.coeFn_mk","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : MeasureTheory.AEEqFun Œ± E Œº\nhf : LT.lt (MeasureTheory.eLpNorm (‚Üëf) p Œº) Top.top\n‚ä¢ Eq ‚Üë‚Üë‚ü®f, hf‚ü© ‚Üëf","decl":"@[simp]\ntheorem coeFn_mk {f : Œ± ‚Üí‚Çò[Œº] E} (hf : eLpNorm f p Œº < ‚àû) : ((‚ü®f, hf‚ü© : Lp E p Œº) : Œ± ‚Üí E) = f :=\n  rfl\n\n-- @[simp] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10685): dsimp can prove this\n"}
{"name":"MeasureTheory.Lp.coe_mk","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : MeasureTheory.AEEqFun Œ± E Œº\nhf : LT.lt (MeasureTheory.eLpNorm (‚Üëf) p Œº) Top.top\n‚ä¢ Eq (‚Üë‚ü®f, hf‚ü©) f","decl":"theorem coe_mk {f : Œ± ‚Üí‚Çò[Œº] E} (hf : eLpNorm f p Œº < ‚àû) : ((‚ü®f, hf‚ü© : Lp E p Œº) : Œ± ‚Üí‚Çò[Œº] E) = f :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.toLp_coeFn","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\nhf : MeasureTheory.Mem‚Ñíp (‚Üë‚Üëf) p Œº\n‚ä¢ Eq (MeasureTheory.Mem‚Ñíp.toLp (‚Üë‚Üëf) hf) f","decl":"@[simp]\ntheorem toLp_coeFn (f : Lp E p Œº) (hf : Mem‚Ñíp f p Œº) : hf.toLp f = f := by\n  cases f\n  simp [Mem‚Ñíp.toLp]\n\n"}
{"name":"MeasureTheory.Lp.eLpNorm_lt_top","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ LT.lt (MeasureTheory.eLpNorm (‚Üë‚Üëf) p Œº) Top.top","decl":"theorem eLpNorm_lt_top (f : Lp E p Œº) : eLpNorm f p Œº < ‚àû :=\n  f.prop\n\n"}
{"name":"MeasureTheory.Lp.eLpNorm_ne_top","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Ne (MeasureTheory.eLpNorm (‚Üë‚Üëf) p Œº) Top.top","decl":"theorem eLpNorm_ne_top (f : Lp E p Œº) : eLpNorm f p Œº ‚â† ‚àû :=\n  (eLpNorm_lt_top f).ne\n\n"}
{"name":"MeasureTheory.Lp.stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ MeasureTheory.StronglyMeasurable ‚Üë‚Üëf","decl":"@[measurability]\nprotected theorem stronglyMeasurable (f : Lp E p Œº) : StronglyMeasurable f :=\n  f.val.stronglyMeasurable\n\n"}
{"name":"MeasureTheory.Lp.aestronglyMeasurable","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ MeasureTheory.AEStronglyMeasurable (‚Üë‚Üëf) Œº","decl":"@[measurability]\nprotected theorem aestronglyMeasurable (f : Lp E p Œº) : AEStronglyMeasurable f Œº :=\n  f.val.aestronglyMeasurable\n\n"}
{"name":"MeasureTheory.Lp.mem‚Ñíp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ MeasureTheory.Mem‚Ñíp (‚Üë‚Üëf) p Œº","decl":"protected theorem mem‚Ñíp (f : Lp E p Œº) : Mem‚Ñíp f p Œº :=\n  ‚ü®Lp.aestronglyMeasurable f, f.prop‚ü©\n\n"}
{"name":"MeasureTheory.Lp.coeFn_zero","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (‚Üë‚Üë0) 0","decl":"theorem coeFn_zero : ‚áë(0 : Lp E p Œº) =·µê[Œº] 0 :=\n  AEEqFun.coeFn_zero\n\n"}
{"name":"MeasureTheory.Lp.coeFn_neg","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (‚Üë‚Üë(Neg.neg f)) (Neg.neg ‚Üë‚Üëf)","decl":"theorem coeFn_neg (f : Lp E p Œº) : ‚áë(-f) =·µê[Œº] -f :=\n  AEEqFun.coeFn_neg _\n\n"}
{"name":"MeasureTheory.Lp.coeFn_add","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (‚Üë‚Üë(HAdd.hAdd f g)) (HAdd.hAdd ‚Üë‚Üëf ‚Üë‚Üëg)","decl":"theorem coeFn_add (f g : Lp E p Œº) : ‚áë(f + g) =·µê[Œº] f + g :=\n  AEEqFun.coeFn_add _ _\n\n"}
{"name":"MeasureTheory.Lp.coeFn_sub","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (‚Üë‚Üë(HSub.hSub f g)) (HSub.hSub ‚Üë‚Üëf ‚Üë‚Üëg)","decl":"theorem coeFn_sub (f g : Lp E p Œº) : ‚áë(f - g) =·µê[Œº] f - g :=\n  AEEqFun.coeFn_sub _ _\n\n"}
{"name":"MeasureTheory.Lp.const_mem_Lp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"E : Type u_2\np : ENNReal\ninst‚úù¬π : NormedAddCommGroup E\nŒ± : Type u_5\nx‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nc : E\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\n‚ä¢ Membership.mem (MeasureTheory.Lp E p Œº) (MeasureTheory.AEEqFun.const Œ± c)","decl":"theorem const_mem_Lp (Œ±) {_ : MeasurableSpace Œ±} (Œº : Measure Œ±) (c : E) [IsFiniteMeasure Œº] :\n    @AEEqFun.const Œ± _ _ Œº _ c ‚àà Lp E p Œº :=\n  (mem‚Ñíp_const c).eLpNorm_mk_lt_top\n\n"}
{"name":"MeasureTheory.Lp.norm_def","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Eq (Norm.norm f) (MeasureTheory.eLpNorm (‚Üë‚Üëf) p Œº).toReal","decl":"theorem norm_def (f : Lp E p Œº) : ‚Äñf‚Äñ = ENNReal.toReal (eLpNorm f p Œº) :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.nnnorm_def","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Eq (NNNorm.nnnorm f) (MeasureTheory.eLpNorm (‚Üë‚Üëf) p Œº).toNNReal","decl":"theorem nnnorm_def (f : Lp E p Œº) : ‚Äñf‚Äñ‚Çä = ENNReal.toNNReal (eLpNorm f p Œº) :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.coe_nnnorm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Eq (‚Üë(NNNorm.nnnorm f)) (Norm.norm f)","decl":"@[simp, norm_cast]\nprotected theorem coe_nnnorm (f : Lp E p Œº) : (‚Äñf‚Äñ‚Çä : ‚Ñù) = ‚Äñf‚Äñ :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.enorm_def","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Eq (ENorm.enorm f) (MeasureTheory.eLpNorm (‚Üë‚Üëf) p Œº)","decl":"@[simp]\ntheorem enorm_def (f : Lp E p Œº) : ‚Äñf‚Äñ‚Çë = eLpNorm f p Œº :=\n  ENNReal.coe_toNNReal <| Lp.eLpNorm_ne_top f\n\n"}
{"name":"MeasureTheory.Lp.nnnorm_coe_ennreal","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Eq (ENorm.enorm f) (MeasureTheory.eLpNorm (‚Üë‚Üëf) p Œº)","decl":"@[deprecated (since := \"2025-01-20\")] alias nnnorm_coe_ennreal := enorm_def\n\n"}
{"name":"MeasureTheory.Lp.norm_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f p Œº\n‚ä¢ Eq (Norm.norm (MeasureTheory.Mem‚Ñíp.toLp f hf)) (MeasureTheory.eLpNorm f p Œº).toReal","decl":"@[simp]\nlemma norm_toLp (f : Œ± ‚Üí E) (hf : Mem‚Ñíp f p Œº) : ‚Äñhf.toLp f‚Äñ = ENNReal.toReal (eLpNorm f p Œº) := by\n  rw [norm_def, eLpNorm_congr_ae (Mem‚Ñíp.coeFn_toLp hf)]\n\n"}
{"name":"MeasureTheory.Lp.nnnorm_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f p Œº\n‚ä¢ Eq (NNNorm.nnnorm (MeasureTheory.Mem‚Ñíp.toLp f hf)) (MeasureTheory.eLpNorm f p Œº).toNNReal","decl":"@[simp]\ntheorem nnnorm_toLp (f : Œ± ‚Üí E) (hf : Mem‚Ñíp f p Œº) :\n    ‚Äñhf.toLp f‚Äñ‚Çä = ENNReal.toNNReal (eLpNorm f p Œº) :=\n  NNReal.eq <| norm_toLp f hf\n\n"}
{"name":"MeasureTheory.Lp.enorm_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f p Œº\n‚ä¢ Eq (ENorm.enorm (MeasureTheory.Mem‚Ñíp.toLp f hf)) (MeasureTheory.eLpNorm f p Œº)","decl":"lemma enorm_toLp {f : Œ± ‚Üí E} (hf : Mem‚Ñíp f p Œº) : ‚Äñhf.toLp f‚Äñ‚Çë = eLpNorm f p Œº := by\n  simp [enorm, nnnorm_toLp f hf, ENNReal.coe_toNNReal hf.2.ne]\n\n"}
{"name":"MeasureTheory.Lp.coe_nnnorm_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f p Œº\n‚ä¢ Eq (ENorm.enorm (MeasureTheory.Mem‚Ñíp.toLp f hf)) (MeasureTheory.eLpNorm f p Œº)","decl":"@[deprecated (since := \"2025-01-20\")] alias coe_nnnorm_toLp := enorm_toLp\n\n"}
{"name":"MeasureTheory.Lp.dist_def","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Eq (Dist.dist f g) (MeasureTheory.eLpNorm (HSub.hSub ‚Üë‚Üëf ‚Üë‚Üëg) p Œº).toReal","decl":"theorem dist_def (f g : Lp E p Œº) : dist f g = (eLpNorm (‚áëf - ‚áëg) p Œº).toReal := by\n  simp_rw [dist, norm_def]\n  refine congr_arg _ ?_\n  apply eLpNorm_congr_ae (coeFn_sub _ _)\n\n"}
{"name":"MeasureTheory.Lp.edist_def","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Eq (EDist.edist f g) (MeasureTheory.eLpNorm (HSub.hSub ‚Üë‚Üëf ‚Üë‚Üëg) p Œº)","decl":"theorem edist_def (f g : Lp E p Œº) : edist f g = eLpNorm (‚áëf - ‚áëg) p Œº :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.edist_dist","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Eq (EDist.edist f g) (ENNReal.ofReal (Dist.dist f g))","decl":"protected theorem edist_dist (f g : Lp E p Œº) : edist f g = .ofReal (dist f g) := by\n  rw [edist_def, dist_def, ‚Üê eLpNorm_congr_ae (coeFn_sub _ _),\n    ENNReal.ofReal_toReal (eLpNorm_ne_top (f - g))]\n\n"}
{"name":"MeasureTheory.Lp.dist_edist","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Eq (Dist.dist f g) (EDist.edist f g).toReal","decl":"protected theorem dist_edist (f g : Lp E p Œº) : dist f g = (edist f g).toReal :=\n  MeasureTheory.Lp.dist_def ..\n\n"}
{"name":"MeasureTheory.Lp.dist_eq_norm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Eq (Dist.dist f g) (Norm.norm (HSub.hSub f g))","decl":"theorem dist_eq_norm (f g : Lp E p Œº) : dist f g = ‚Äñf - g‚Äñ := rfl\n\n"}
{"name":"MeasureTheory.Lp.edist_toLp_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf g : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nhg : MeasureTheory.Mem‚Ñíp g p Œº\n‚ä¢ Eq (EDist.edist (MeasureTheory.Mem‚Ñíp.toLp f hf) (MeasureTheory.Mem‚Ñíp.toLp g hg)) (MeasureTheory.eLpNorm (HSub.hSub f g) p Œº)","decl":"@[simp]\ntheorem edist_toLp_toLp (f g : Œ± ‚Üí E) (hf : Mem‚Ñíp f p Œº) (hg : Mem‚Ñíp g p Œº) :\n    edist (hf.toLp f) (hg.toLp g) = eLpNorm (f - g) p Œº := by\n  rw [edist_def]\n  exact eLpNorm_congr_ae (hf.coeFn_toLp.sub hg.coeFn_toLp)\n\n"}
{"name":"MeasureTheory.Lp.edist_toLp_zero","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f p Œº\n‚ä¢ Eq (EDist.edist (MeasureTheory.Mem‚Ñíp.toLp f hf) 0) (MeasureTheory.eLpNorm f p Œº)","decl":"@[simp]\ntheorem edist_toLp_zero (f : Œ± ‚Üí E) (hf : Mem‚Ñíp f p Œº) : edist (hf.toLp f) 0 = eLpNorm f p Œº := by\n  simpa using edist_toLp_toLp f 0 hf Mem‚Ñíp.zero\n\n"}
{"name":"MeasureTheory.Lp.nnnorm_zero","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\n‚ä¢ Eq (NNNorm.nnnorm 0) 0","decl":"@[simp]\ntheorem nnnorm_zero : ‚Äñ(0 : Lp E p Œº)‚Äñ‚Çä = 0 := by\n  rw [nnnorm_def]\n  change (eLpNorm (‚áë(0 : Œ± ‚Üí‚Çò[Œº] E)) p Œº).toNNReal = 0\n  simp [eLpNorm_congr_ae AEEqFun.coeFn_zero, eLpNorm_zero]\n\n"}
{"name":"MeasureTheory.Lp.norm_zero","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\n‚ä¢ Eq (Norm.norm 0) 0","decl":"@[simp]\ntheorem norm_zero : ‚Äñ(0 : Lp E p Œº)‚Äñ = 0 :=\n  congr_arg ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù) nnnorm_zero\n\n"}
{"name":"MeasureTheory.Lp.norm_measure_zero","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p 0) x\n‚ä¢ Eq (Norm.norm f) 0","decl":"@[simp]\ntheorem norm_measure_zero (f : Lp E p (0 : MeasureTheory.Measure Œ±)) : ‚Äñf‚Äñ = 0 := by\n  -- Squeezed for performance reasons\n  simp only [norm_def, eLpNorm_measure_zero, ENNReal.zero_toReal]\n\n"}
{"name":"MeasureTheory.Lp.norm_exponent_zero","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 0 Œº) x\n‚ä¢ Eq (Norm.norm f) 0","decl":"@[simp] theorem norm_exponent_zero (f : Lp E 0 Œº) : ‚Äñf‚Äñ = 0 := by\n  -- Squeezed for performance reasons\n  simp only [norm_def, eLpNorm_exponent_zero, ENNReal.zero_toReal]\n\n"}
{"name":"MeasureTheory.Lp.nnnorm_eq_zero_iff","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\nhp : LT.lt 0 p\n‚ä¢ Iff (Eq (NNNorm.nnnorm f) 0) (Eq f 0)","decl":"theorem nnnorm_eq_zero_iff {f : Lp E p Œº} (hp : 0 < p) : ‚Äñf‚Äñ‚Çä = 0 ‚Üî f = 0 := by\n  refine ‚ü®fun hf => ?_, fun hf => by simp [hf]‚ü©\n  rw [nnnorm_def, ENNReal.toNNReal_eq_zero_iff] at hf\n  cases hf with\n  | inl hf =>\n    rw [eLpNorm_eq_zero_iff (Lp.aestronglyMeasurable f) hp.ne.symm] at hf\n    exact Subtype.eq (AEEqFun.ext (hf.trans AEEqFun.coeFn_zero.symm))\n  | inr hf =>\n    exact absurd hf (eLpNorm_ne_top f)\n\n"}
{"name":"MeasureTheory.Lp.norm_eq_zero_iff","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\nhp : LT.lt 0 p\n‚ä¢ Iff (Eq (Norm.norm f) 0) (Eq f 0)","decl":"theorem norm_eq_zero_iff {f : Lp E p Œº} (hp : 0 < p) : ‚Äñf‚Äñ = 0 ‚Üî f = 0 :=\n  NNReal.coe_eq_zero.trans (nnnorm_eq_zero_iff hp)\n\n"}
{"name":"MeasureTheory.Lp.eq_zero_iff_ae_eq_zero","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Iff (Eq f 0) ((MeasureTheory.ae Œº).EventuallyEq (‚Üë‚Üëf) 0)","decl":"theorem eq_zero_iff_ae_eq_zero {f : Lp E p Œº} : f = 0 ‚Üî f =·µê[Œº] 0 := by\n  rw [‚Üê (Lp.mem‚Ñíp f).toLp_eq_toLp_iff Mem‚Ñíp.zero, Mem‚Ñíp.toLp_zero, toLp_coeFn]\n\n"}
{"name":"MeasureTheory.Lp.nnnorm_neg","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Eq (NNNorm.nnnorm (Neg.neg f)) (NNNorm.nnnorm f)","decl":"@[simp]\ntheorem nnnorm_neg (f : Lp E p Œº) : ‚Äñ-f‚Äñ‚Çä = ‚Äñf‚Äñ‚Çä := by\n  rw [nnnorm_def, nnnorm_def, eLpNorm_congr_ae (coeFn_neg _), eLpNorm_neg]\n\n"}
{"name":"MeasureTheory.Lp.norm_neg","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Eq (Norm.norm (Neg.neg f)) (Norm.norm f)","decl":"@[simp]\ntheorem norm_neg (f : Lp E p Œº) : ‚Äñ-f‚Äñ = ‚Äñf‚Äñ :=\n  congr_arg ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù) (nnnorm_neg f)\n\n"}
{"name":"MeasureTheory.Lp.nnnorm_le_mul_nnnorm_of_ae_le_mul","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedAddCommGroup F\nc : NNReal\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\ng : Subtype fun x => Membership.mem (MeasureTheory.Lp F p Œº) x\nh : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (‚Üë‚Üëf x)) (HMul.hMul c (NNNorm.nnnorm (‚Üë‚Üëg x)))) (MeasureTheory.ae Œº)\n‚ä¢ LE.le (NNNorm.nnnorm f) (HMul.hMul c (NNNorm.nnnorm g))","decl":"theorem nnnorm_le_mul_nnnorm_of_ae_le_mul {c : ‚Ñù‚â•0} {f : Lp E p Œº} {g : Lp F p Œº}\n    (h : ‚àÄ·µê x ‚àÇŒº, ‚Äñf x‚Äñ‚Çä ‚â§ c * ‚Äñg x‚Äñ‚Çä) : ‚Äñf‚Äñ‚Çä ‚â§ c * ‚Äñg‚Äñ‚Çä := by\n  simp only [nnnorm_def]\n  have := eLpNorm_le_nnreal_smul_eLpNorm_of_ae_le_mul h p\n  rwa [‚Üê ENNReal.toNNReal_le_toNNReal, ENNReal.smul_def, smul_eq_mul, ENNReal.toNNReal_mul,\n    ENNReal.toNNReal_coe] at this\n  ¬∑ exact (Lp.mem‚Ñíp _).eLpNorm_ne_top\n  ¬∑ exact ENNReal.mul_ne_top ENNReal.coe_ne_top (Lp.mem‚Ñíp _).eLpNorm_ne_top\n\n"}
{"name":"MeasureTheory.Lp.norm_le_mul_norm_of_ae_le_mul","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedAddCommGroup F\nc : Real\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\ng : Subtype fun x => Membership.mem (MeasureTheory.Lp F p Œº) x\nh : Filter.Eventually (fun x => LE.le (Norm.norm (‚Üë‚Üëf x)) (HMul.hMul c (Norm.norm (‚Üë‚Üëg x)))) (MeasureTheory.ae Œº)\n‚ä¢ LE.le (Norm.norm f) (HMul.hMul c (Norm.norm g))","decl":"theorem norm_le_mul_norm_of_ae_le_mul {c : ‚Ñù} {f : Lp E p Œº} {g : Lp F p Œº}\n    (h : ‚àÄ·µê x ‚àÇŒº, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) : ‚Äñf‚Äñ ‚â§ c * ‚Äñg‚Äñ := by\n  rcases le_or_lt 0 c with hc | hc\n  ¬∑ lift c to ‚Ñù‚â•0 using hc\n    exact NNReal.coe_le_coe.mpr (nnnorm_le_mul_nnnorm_of_ae_le_mul h)\n  ¬∑ simp only [norm_def]\n    have := eLpNorm_eq_zero_and_zero_of_ae_le_mul_neg h hc p\n    simp [this]\n\n"}
{"name":"MeasureTheory.Lp.norm_le_norm_of_ae_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedAddCommGroup F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\ng : Subtype fun x => Membership.mem (MeasureTheory.Lp F p Œº) x\nh : Filter.Eventually (fun x => LE.le (Norm.norm (‚Üë‚Üëf x)) (Norm.norm (‚Üë‚Üëg x))) (MeasureTheory.ae Œº)\n‚ä¢ LE.le (Norm.norm f) (Norm.norm g)","decl":"theorem norm_le_norm_of_ae_le {f : Lp E p Œº} {g : Lp F p Œº} (h : ‚àÄ·µê x ‚àÇŒº, ‚Äñf x‚Äñ ‚â§ ‚Äñg x‚Äñ) :\n    ‚Äñf‚Äñ ‚â§ ‚Äñg‚Äñ := by\n  rw [norm_def, norm_def]\n  exact ENNReal.toReal_mono (eLpNorm_ne_top _) (eLpNorm_mono_ae h)\n\n"}
{"name":"MeasureTheory.Lp.mem_Lp_of_nnnorm_ae_le_mul","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedAddCommGroup F\nc : NNReal\nf : MeasureTheory.AEEqFun Œ± E Œº\ng : Subtype fun x => Membership.mem (MeasureTheory.Lp F p Œº) x\nh : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (‚Üëf x)) (HMul.hMul c (NNNorm.nnnorm (‚Üë‚Üëg x)))) (MeasureTheory.ae Œº)\n‚ä¢ Membership.mem (MeasureTheory.Lp E p Œº) f","decl":"theorem mem_Lp_of_nnnorm_ae_le_mul {c : ‚Ñù‚â•0} {f : Œ± ‚Üí‚Çò[Œº] E} {g : Lp F p Œº}\n    (h : ‚àÄ·µê x ‚àÇŒº, ‚Äñf x‚Äñ‚Çä ‚â§ c * ‚Äñg x‚Äñ‚Çä) : f ‚àà Lp E p Œº :=\n  mem_Lp_iff_mem‚Ñíp.2 <| Mem‚Ñíp.of_nnnorm_le_mul (Lp.mem‚Ñíp g) f.aestronglyMeasurable h\n\n"}
{"name":"MeasureTheory.Lp.mem_Lp_of_ae_le_mul","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedAddCommGroup F\nc : Real\nf : MeasureTheory.AEEqFun Œ± E Œº\ng : Subtype fun x => Membership.mem (MeasureTheory.Lp F p Œº) x\nh : Filter.Eventually (fun x => LE.le (Norm.norm (‚Üëf x)) (HMul.hMul c (Norm.norm (‚Üë‚Üëg x)))) (MeasureTheory.ae Œº)\n‚ä¢ Membership.mem (MeasureTheory.Lp E p Œº) f","decl":"theorem mem_Lp_of_ae_le_mul {c : ‚Ñù} {f : Œ± ‚Üí‚Çò[Œº] E} {g : Lp F p Œº}\n    (h : ‚àÄ·µê x ‚àÇŒº, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) : f ‚àà Lp E p Œº :=\n  mem_Lp_iff_mem‚Ñíp.2 <| Mem‚Ñíp.of_le_mul (Lp.mem‚Ñíp g) f.aestronglyMeasurable h\n\n"}
{"name":"MeasureTheory.Lp.mem_Lp_of_nnnorm_ae_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedAddCommGroup F\nf : MeasureTheory.AEEqFun Œ± E Œº\ng : Subtype fun x => Membership.mem (MeasureTheory.Lp F p Œº) x\nh : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (‚Üëf x)) (NNNorm.nnnorm (‚Üë‚Üëg x))) (MeasureTheory.ae Œº)\n‚ä¢ Membership.mem (MeasureTheory.Lp E p Œº) f","decl":"theorem mem_Lp_of_nnnorm_ae_le {f : Œ± ‚Üí‚Çò[Œº] E} {g : Lp F p Œº} (h : ‚àÄ·µê x ‚àÇŒº, ‚Äñf x‚Äñ‚Çä ‚â§ ‚Äñg x‚Äñ‚Çä) :\n    f ‚àà Lp E p Œº :=\n  mem_Lp_iff_mem‚Ñíp.2 <| Mem‚Ñíp.of_le (Lp.mem‚Ñíp g) f.aestronglyMeasurable h\n\n"}
{"name":"MeasureTheory.Lp.mem_Lp_of_ae_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedAddCommGroup F\nf : MeasureTheory.AEEqFun Œ± E Œº\ng : Subtype fun x => Membership.mem (MeasureTheory.Lp F p Œº) x\nh : Filter.Eventually (fun x => LE.le (Norm.norm (‚Üëf x)) (Norm.norm (‚Üë‚Üëg x))) (MeasureTheory.ae Œº)\n‚ä¢ Membership.mem (MeasureTheory.Lp E p Œº) f","decl":"theorem mem_Lp_of_ae_le {f : Œ± ‚Üí‚Çò[Œº] E} {g : Lp F p Œº} (h : ‚àÄ·µê x ‚àÇŒº, ‚Äñf x‚Äñ ‚â§ ‚Äñg x‚Äñ) :\n    f ‚àà Lp E p Œº :=\n  mem_Lp_of_nnnorm_ae_le h\n\n"}
{"name":"MeasureTheory.Lp.mem_Lp_of_ae_nnnorm_bound","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nf : MeasureTheory.AEEqFun Œ± E Œº\nC : NNReal\nhfC : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (‚Üëf x)) C) (MeasureTheory.ae Œº)\n‚ä¢ Membership.mem (MeasureTheory.Lp E p Œº) f","decl":"theorem mem_Lp_of_ae_nnnorm_bound [IsFiniteMeasure Œº] {f : Œ± ‚Üí‚Çò[Œº] E} (C : ‚Ñù‚â•0)\n    (hfC : ‚àÄ·µê x ‚àÇŒº, ‚Äñf x‚Äñ‚Çä ‚â§ C) : f ‚àà Lp E p Œº :=\n  mem_Lp_iff_mem‚Ñíp.2 <| Mem‚Ñíp.of_bound f.aestronglyMeasurable _ hfC\n\n"}
{"name":"MeasureTheory.Lp.mem_Lp_of_ae_bound","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nf : MeasureTheory.AEEqFun Œ± E Œº\nC : Real\nhfC : Filter.Eventually (fun x => LE.le (Norm.norm (‚Üëf x)) C) (MeasureTheory.ae Œº)\n‚ä¢ Membership.mem (MeasureTheory.Lp E p Œº) f","decl":"theorem mem_Lp_of_ae_bound [IsFiniteMeasure Œº] {f : Œ± ‚Üí‚Çò[Œº] E} (C : ‚Ñù) (hfC : ‚àÄ·µê x ‚àÇŒº, ‚Äñf x‚Äñ ‚â§ C) :\n    f ‚àà Lp E p Œº :=\n  mem_Lp_iff_mem‚Ñíp.2 <| Mem‚Ñíp.of_bound f.aestronglyMeasurable _ hfC\n\n"}
{"name":"MeasureTheory.Lp.nnnorm_le_of_ae_bound","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\nC : NNReal\nhfC : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (‚Üë‚Üëf x)) C) (MeasureTheory.ae Œº)\n‚ä¢ LE.le (NNNorm.nnnorm f) (HMul.hMul (HPow.hPow (MeasureTheory.measureUnivNNReal Œº) (Inv.inv p.toReal)) C)","decl":"theorem nnnorm_le_of_ae_bound [IsFiniteMeasure Œº] {f : Lp E p Œº} {C : ‚Ñù‚â•0}\n    (hfC : ‚àÄ·µê x ‚àÇŒº, ‚Äñf x‚Äñ‚Çä ‚â§ C) : ‚Äñf‚Äñ‚Çä ‚â§ measureUnivNNReal Œº ^ p.toReal‚Åª¬π * C := by\n  by_cases hŒº : Œº = 0\n  ¬∑ by_cases hp : p.toReal‚Åª¬π = 0\n    ¬∑ simp [hp, hŒº, nnnorm_def]\n    ¬∑ simp [hŒº, nnnorm_def, Real.zero_rpow hp]\n  rw [‚Üê ENNReal.coe_le_coe, nnnorm_def, ENNReal.coe_toNNReal (eLpNorm_ne_top _)]\n  refine (eLpNorm_le_of_ae_nnnorm_bound hfC).trans_eq ?_\n  rw [‚Üê coe_measureUnivNNReal Œº, ‚Üê ENNReal.coe_rpow_of_ne_zero (measureUnivNNReal_pos hŒº).ne',\n    ENNReal.coe_mul, mul_comm, ENNReal.smul_def, smul_eq_mul]\n\n"}
{"name":"MeasureTheory.Lp.norm_le_of_ae_bound","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\nC : Real\nhC : LE.le 0 C\nhfC : Filter.Eventually (fun x => LE.le (Norm.norm (‚Üë‚Üëf x)) C) (MeasureTheory.ae Œº)\n‚ä¢ LE.le (Norm.norm f) (HMul.hMul (HPow.hPow (‚Üë(MeasureTheory.measureUnivNNReal Œº)) (Inv.inv p.toReal)) C)","decl":"theorem norm_le_of_ae_bound [IsFiniteMeasure Œº] {f : Lp E p Œº} {C : ‚Ñù} (hC : 0 ‚â§ C)\n    (hfC : ‚àÄ·µê x ‚àÇŒº, ‚Äñf x‚Äñ ‚â§ C) : ‚Äñf‚Äñ ‚â§ measureUnivNNReal Œº ^ p.toReal‚Åª¬π * C := by\n  lift C to ‚Ñù‚â•0 using hC\n  have := nnnorm_le_of_ae_bound hfC\n  rwa [‚Üê NNReal.coe_le_coe, NNReal.coe_mul, NNReal.coe_rpow] at this\n\n"}
{"name":"MeasureTheory.Lp.const_smul_mem_Lp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : NormedAddCommGroup E\nùïú : Type u_5\ninst‚úù¬≤ : NormedRing ùïú\ninst‚úù¬π : Module ùïú E\ninst‚úù : BoundedSMul ùïú E\nc : ùïú\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Membership.mem (MeasureTheory.Lp E p Œº) (HSMul.hSMul c ‚Üëf)","decl":"theorem const_smul_mem_Lp (c : ùïú) (f : Lp E p Œº) : c ‚Ä¢ (f : Œ± ‚Üí‚Çò[Œº] E) ‚àà Lp E p Œº := by\n  rw [mem_Lp_iff_eLpNorm_lt_top, eLpNorm_congr_ae (AEEqFun.coeFn_smul _ _)]\n  exact eLpNorm_const_smul_le.trans_lt <| ENNReal.mul_lt_top ENNReal.coe_lt_top f.prop\n\n"}
{"name":"MeasureTheory.Lp.coe_LpSubmodule","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : NormedAddCommGroup E\nùïú : Type u_5\ninst‚úù¬≤ : NormedRing ùïú\ninst‚úù¬π : Module ùïú E\ninst‚úù : BoundedSMul ùïú E\n‚ä¢ Eq (MeasureTheory.Lp.LpSubmodule E p Œº ùïú).toAddSubgroup (MeasureTheory.Lp E p Œº)","decl":"theorem coe_LpSubmodule : (LpSubmodule E p Œº ùïú).toAddSubgroup = Lp E p Œº :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.coeFn_smul","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : NormedAddCommGroup E\nùïú : Type u_5\ninst‚úù¬≤ : NormedRing ùïú\ninst‚úù¬π : Module ùïú E\ninst‚úù : BoundedSMul ùïú E\nc : ùïú\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (‚Üë‚Üë(HSMul.hSMul c f)) (HSMul.hSMul c ‚Üë‚Üëf)","decl":"theorem coeFn_smul (c : ùïú) (f : Lp E p Œº) : ‚áë(c ‚Ä¢ f) =·µê[Œº] c ‚Ä¢ ‚áëf :=\n  AEEqFun.coeFn_smul _ _\n\n"}
{"name":"MeasureTheory.Lp.instIsCentralScalar","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å∂ : NormedAddCommGroup E\nùïú : Type u_5\ninst‚úù‚Åµ : NormedRing ùïú\ninst‚úù‚Å¥ : Module ùïú E\ninst‚úù¬≥ : BoundedSMul ùïú E\ninst‚úù¬≤ : Module (MulOpposite ùïú) E\ninst‚úù¬π : BoundedSMul (MulOpposite ùïú) E\ninst‚úù : IsCentralScalar ùïú E\n‚ä¢ IsCentralScalar ùïú (Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x)","decl":"instance instIsCentralScalar [Module ùïú·µê·µí·µñ E] [BoundedSMul ùïú·µê·µí·µñ E] [IsCentralScalar ùïú E] :\n    IsCentralScalar ùïú (Lp E p Œº) where\n  op_smul_eq_smul k f := Subtype.ext <| op_smul_eq_smul k (f : Œ± ‚Üí‚Çò[Œº] E)\n\n"}
{"name":"MeasureTheory.Lp.instSMulCommClass","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å∑ : NormedAddCommGroup E\nùïú : Type u_5\nùïú' : Type u_6\ninst‚úù‚Å∂ : NormedRing ùïú\ninst‚úù‚Åµ : NormedRing ùïú'\ninst‚úù‚Å¥ : Module ùïú E\ninst‚úù¬≥ : Module ùïú' E\ninst‚úù¬≤ : BoundedSMul ùïú E\ninst‚úù¬π : BoundedSMul ùïú' E\ninst‚úù : SMulCommClass ùïú ùïú' E\n‚ä¢ SMulCommClass ùïú ùïú' (Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x)","decl":"instance instSMulCommClass [SMulCommClass ùïú ùïú' E] : SMulCommClass ùïú ùïú' (Lp E p Œº) where\n  smul_comm k k' f := Subtype.ext <| smul_comm k k' (f : Œ± ‚Üí‚Çò[Œº] E)\n\n"}
{"name":"MeasureTheory.Lp.instIsScalarTower","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å∏ : NormedAddCommGroup E\nùïú : Type u_5\nùïú' : Type u_6\ninst‚úù‚Å∑ : NormedRing ùïú\ninst‚úù‚Å∂ : NormedRing ùïú'\ninst‚úù‚Åµ : Module ùïú E\ninst‚úù‚Å¥ : Module ùïú' E\ninst‚úù¬≥ : BoundedSMul ùïú E\ninst‚úù¬≤ : BoundedSMul ùïú' E\ninst‚úù¬π : SMul ùïú ùïú'\ninst‚úù : IsScalarTower ùïú ùïú' E\n‚ä¢ IsScalarTower ùïú ùïú' (Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x)","decl":"instance instIsScalarTower [SMul ùïú ùïú'] [IsScalarTower ùïú ùïú' E] : IsScalarTower ùïú ùïú' (Lp E p Œº) where\n  smul_assoc k k' f := Subtype.ext <| smul_assoc k k' (f : Œ± ‚Üí‚Çò[Œº] E)\n\n"}
{"name":"MeasureTheory.Lp.instBoundedSMul","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å¥ : NormedAddCommGroup E\nùïú : Type u_5\ninst‚úù¬≥ : NormedRing ùïú\ninst‚úù¬≤ : Module ùïú E\ninst‚úù¬π : BoundedSMul ùïú E\ninst‚úù : Fact (LE.le 1 p)\n‚ä¢ BoundedSMul ùïú (Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x)","decl":"instance instBoundedSMul [Fact (1 ‚â§ p)] : BoundedSMul ùïú (Lp E p Œº) :=\n  -- TODO: add `BoundedSMul.of_nnnorm_smul_le`\n  BoundedSMul.of_norm_smul_le fun r f => by\n    suffices ‚Äñr ‚Ä¢ f‚Äñ‚Çë ‚â§ ‚Äñr‚Äñ‚Çë * ‚Äñf‚Äñ‚Çë by\n      -- squeezed for performance reasons\n      simpa only [ge_iff_le, enorm, ‚ÜêENNReal.coe_mul, ENNReal.coe_le_coe] using this\n    simpa only [eLpNorm_congr_ae (coeFn_smul _ _), enorm_def]\n      using eLpNorm_const_smul_le (c := r) (f := f) (p := p)\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.toLp_const_smul","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : NormedAddCommGroup E\nùïú : Type u_5\ninst‚úù¬≤ : NormedRing ùïú\ninst‚úù¬π : Module ùïú E\ninst‚úù : BoundedSMul ùïú E\nf : Œ± ‚Üí E\nc : ùïú\nhf : MeasureTheory.Mem‚Ñíp f p Œº\n‚ä¢ Eq (MeasureTheory.Mem‚Ñíp.toLp (HSMul.hSMul c f) ‚ãØ) (HSMul.hSMul c (MeasureTheory.Mem‚Ñíp.toLp f hf))","decl":"theorem toLp_const_smul {f : Œ± ‚Üí E} (c : ùïú) (hf : Mem‚Ñíp f p Œº) :\n    (hf.const_smul c).toLp (c ‚Ä¢ f) = c ‚Ä¢ hf.toLp f :=\n  rfl\n\n"}
{"name":"MeasureTheory.exists_eLpNorm_indicator_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nhp : Ne p Top.top\nc : E\nŒµ : ENNReal\nhŒµ : Ne Œµ 0\n‚ä¢ Exists fun Œ∑ => And (LT.lt 0 Œ∑) (‚àÄ (s : Set Œ±), LE.le (Œº s) ‚ÜëŒ∑ ‚Üí LE.le (MeasureTheory.eLpNorm (s.indicator fun x => c) p Œº) Œµ)","decl":"/-- The `‚Ñí^p` norm of the indicator of a set is uniformly small if the set itself has small measure,\nfor any `p < ‚àû`. Given here as an existential `‚àÄ Œµ > 0, ‚àÉ Œ∑ > 0, ...` to avoid later\nmanagement of `‚Ñù‚â•0‚àû`-arithmetic. -/\ntheorem exists_eLpNorm_indicator_le (hp : p ‚â† ‚àû) (c : E) {Œµ : ‚Ñù‚â•0‚àû} (hŒµ : Œµ ‚â† 0) :\n    ‚àÉ Œ∑ : ‚Ñù‚â•0, 0 < Œ∑ ‚àß ‚àÄ s : Set Œ±, Œº s ‚â§ Œ∑ ‚Üí eLpNorm (s.indicator fun _ => c) p Œº ‚â§ Œµ := by\n  rcases eq_or_ne p 0 with (rfl | h'p)\n  ¬∑ exact ‚ü®1, zero_lt_one, fun s _ => by simp‚ü©\n  have hp‚ÇÄ : 0 < p := bot_lt_iff_ne_bot.2 h'p\n  have hp‚ÇÄ' : 0 ‚â§ 1 / p.toReal := div_nonneg zero_le_one ENNReal.toReal_nonneg\n  have hp‚ÇÄ'' : 0 < p.toReal := ENNReal.toReal_pos hp‚ÇÄ.ne' hp\n  obtain ‚ü®Œ∑, hŒ∑_pos, hŒ∑_le‚ü© : ‚àÉ Œ∑ : ‚Ñù‚â•0, 0 < Œ∑ ‚àß ‚Äñc‚Äñ‚Çë * (Œ∑ : ‚Ñù‚â•0‚àû) ^ (1 / p.toReal) ‚â§ Œµ := by\n    have :\n      Filter.Tendsto (fun x : ‚Ñù‚â•0 => ((‚Äñc‚Äñ‚Çä * x ^ (1 / p.toReal) : ‚Ñù‚â•0) : ‚Ñù‚â•0‚àû)) (ùìù 0)\n        (ùìù (0 : ‚Ñù‚â•0)) := by\n      rw [ENNReal.tendsto_coe]\n      convert (NNReal.continuousAt_rpow_const (Or.inr hp‚ÇÄ')).tendsto.const_mul _\n      simp [hp‚ÇÄ''.ne']\n    have hŒµ' : 0 < Œµ := hŒµ.bot_lt\n    obtain ‚ü®Œ¥, hŒ¥, hŒ¥Œµ'‚ü© := NNReal.nhds_zero_basis.eventually_iff.mp (this.eventually_le_const hŒµ')\n    obtain ‚ü®Œ∑, hŒ∑, hŒ∑Œ¥‚ü© := exists_between hŒ¥\n    refine ‚ü®Œ∑, hŒ∑, ?_‚ü©\n    simpa only [‚Üê ENNReal.coe_rpow_of_nonneg _ hp‚ÇÄ', enorm, ‚Üê ENNReal.coe_mul] using hŒ¥Œµ' hŒ∑Œ¥\n  refine ‚ü®Œ∑, hŒ∑_pos, fun s hs => ?_‚ü©\n  refine (eLpNorm_indicator_const_le _ _).trans (le_trans ?_ hŒ∑_le)\n  exact mul_le_mul_left' (ENNReal.rpow_le_rpow hs hp‚ÇÄ') _\n\n"}
{"name":"HasCompactSupport.mem‚Ñíp_of_bound","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"E : Type u_2\np : ENNReal\ninst‚úù¬≥ : NormedAddCommGroup E\nX : Type u_5\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù : MeasureTheory.IsFiniteMeasureOnCompacts Œº\nf : X ‚Üí E\nhf : HasCompactSupport f\nh2f : MeasureTheory.AEStronglyMeasurable f Œº\nC : Real\nhfC : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) C) (MeasureTheory.ae Œº)\n‚ä¢ MeasureTheory.Mem‚Ñíp f p Œº","decl":"/-- A bounded measurable function with compact support is in L^p. -/\ntheorem _root_.HasCompactSupport.mem‚Ñíp_of_bound {f : X ‚Üí E} (hf : HasCompactSupport f)\n    (h2f : AEStronglyMeasurable f Œº) (C : ‚Ñù) (hfC : ‚àÄ·µê x ‚àÇŒº, ‚Äñf x‚Äñ ‚â§ C) : Mem‚Ñíp f p Œº := by\n  have := mem‚Ñíp_top_of_bound h2f C hfC\n  exact this.mono_exponent_of_measure_support_ne_top\n    (fun x ‚Ü¶ image_eq_zero_of_nmem_tsupport) (hf.measure_lt_top.ne) le_top\n\n"}
{"name":"Continuous.mem‚Ñíp_of_hasCompactSupport","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"E : Type u_2\np : ENNReal\ninst‚úù‚Å¥ : NormedAddCommGroup E\nX : Type u_5\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù¬π : MeasureTheory.IsFiniteMeasureOnCompacts Œº\ninst‚úù : OpensMeasurableSpace X\nf : X ‚Üí E\nhf : Continuous f\nh'f : HasCompactSupport f\n‚ä¢ MeasureTheory.Mem‚Ñíp f p Œº","decl":"/-- A continuous function with compact support is in L^p. -/\ntheorem _root_.Continuous.mem‚Ñíp_of_hasCompactSupport [OpensMeasurableSpace X]\n    {f : X ‚Üí E} (hf : Continuous f) (h'f : HasCompactSupport f) : Mem‚Ñíp f p Œº := by\n  have := hf.mem‚Ñíp_top_of_hasCompactSupport h'f Œº\n  exact this.mono_exponent_of_measure_support_ne_top\n    (fun x ‚Ü¶ image_eq_zero_of_nmem_tsupport) (h'f.measure_lt_top.ne) le_top\n\n"}
{"name":"MeasureTheory.indicatorConstLp_add","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nc c' : E\n‚ä¢ Eq (HAdd.hAdd (MeasureTheory.indicatorConstLp p hs hŒºs c) (MeasureTheory.indicatorConstLp p hs hŒºs c')) (MeasureTheory.indicatorConstLp p hs hŒºs (HAdd.hAdd c c'))","decl":"/-- A version of `Set.indicator_add` for `MeasureTheory.indicatorConstLp`.-/\ntheorem indicatorConstLp_add {c' : E} :\n    indicatorConstLp p hs hŒºs c + indicatorConstLp p hs hŒºs c' =\n    indicatorConstLp p hs hŒºs (c + c') := by\n  simp_rw [indicatorConstLp, ‚Üê Mem‚Ñíp.toLp_add, indicator_add]\n  rfl\n\n"}
{"name":"MeasureTheory.indicatorConstLp_sub","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nc c' : E\n‚ä¢ Eq (HSub.hSub (MeasureTheory.indicatorConstLp p hs hŒºs c) (MeasureTheory.indicatorConstLp p hs hŒºs c')) (MeasureTheory.indicatorConstLp p hs hŒºs (HSub.hSub c c'))","decl":"/-- A version of `Set.indicator_sub` for `MeasureTheory.indicatorConstLp`.-/\ntheorem indicatorConstLp_sub {c' : E} :\n    indicatorConstLp p hs hŒºs c - indicatorConstLp p hs hŒºs c' =\n    indicatorConstLp p hs hŒºs (c - c') := by\n  simp_rw [indicatorConstLp, ‚Üê Mem‚Ñíp.toLp_sub, indicator_sub]\n  rfl\n\n"}
{"name":"MeasureTheory.indicatorConstLp_coeFn","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nc : E\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (‚Üë‚Üë(MeasureTheory.indicatorConstLp p hs hŒºs c)) (s.indicator fun x => c)","decl":"theorem indicatorConstLp_coeFn : ‚áë(indicatorConstLp p hs hŒºs c) =·µê[Œº] s.indicator fun _ => c :=\n  Mem‚Ñíp.coeFn_toLp (mem‚Ñíp_indicator_const p hs c (Or.inr hŒºs))\n\n"}
{"name":"MeasureTheory.indicatorConstLp_coeFn_mem","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nc : E\n‚ä¢ Filter.Eventually (fun x => Membership.mem s x ‚Üí Eq (‚Üë‚Üë(MeasureTheory.indicatorConstLp p hs hŒºs c) x) c) (MeasureTheory.ae Œº)","decl":"theorem indicatorConstLp_coeFn_mem : ‚àÄ·µê x : Œ± ‚àÇŒº, x ‚àà s ‚Üí indicatorConstLp p hs hŒºs c x = c :=\n  indicatorConstLp_coeFn.mono fun _x hx hxs => hx.trans (Set.indicator_of_mem hxs _)\n\n"}
{"name":"MeasureTheory.indicatorConstLp_coeFn_nmem","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nc : E\n‚ä¢ Filter.Eventually (fun x => Not (Membership.mem s x) ‚Üí Eq (‚Üë‚Üë(MeasureTheory.indicatorConstLp p hs hŒºs c) x) 0) (MeasureTheory.ae Œº)","decl":"theorem indicatorConstLp_coeFn_nmem : ‚àÄ·µê x : Œ± ‚àÇŒº, x ‚àâ s ‚Üí indicatorConstLp p hs hŒºs c x = 0 :=\n  indicatorConstLp_coeFn.mono fun _x hx hxs => hx.trans (Set.indicator_of_not_mem hxs _)\n\n"}
{"name":"MeasureTheory.norm_indicatorConstLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nc : E\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\n‚ä¢ Eq (Norm.norm (MeasureTheory.indicatorConstLp p hs hŒºs c)) (HMul.hMul (Norm.norm c) (HPow.hPow (Œº s).toReal (HDiv.hDiv 1 p.toReal)))","decl":"theorem norm_indicatorConstLp (hp_ne_zero : p ‚â† 0) (hp_ne_top : p ‚â† ‚àû) :\n    ‚ÄñindicatorConstLp p hs hŒºs c‚Äñ = ‚Äñc‚Äñ * (Œº s).toReal ^ (1 / p.toReal) := by\n  rw [Lp.norm_def, eLpNorm_congr_ae indicatorConstLp_coeFn,\n    eLpNorm_indicator_const hs hp_ne_zero hp_ne_top, ENNReal.toReal_mul, ENNReal.toReal_rpow,\n    toReal_enorm]\n\n"}
{"name":"MeasureTheory.norm_indicatorConstLp_top","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nc : E\nhŒºs_ne_zero : Ne (Œº s) 0\n‚ä¢ Eq (Norm.norm (MeasureTheory.indicatorConstLp Top.top hs hŒºs c)) (Norm.norm c)","decl":"theorem norm_indicatorConstLp_top (hŒºs_ne_zero : Œº s ‚â† 0) :\n    ‚ÄñindicatorConstLp ‚àû hs hŒºs c‚Äñ = ‚Äñc‚Äñ := by\n  rw [Lp.norm_def, eLpNorm_congr_ae indicatorConstLp_coeFn,\n    eLpNorm_indicator_const' hs hŒºs_ne_zero ENNReal.top_ne_zero, ENNReal.top_toReal,\n    _root_.div_zero, ENNReal.rpow_zero, mul_one, toReal_enorm]\n\n"}
{"name":"MeasureTheory.norm_indicatorConstLp'","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nc : E\nhp_pos : Ne p 0\nhŒºs_pos : Ne (Œº s) 0\n‚ä¢ Eq (Norm.norm (MeasureTheory.indicatorConstLp p hs hŒºs c)) (HMul.hMul (Norm.norm c) (HPow.hPow (Œº s).toReal (HDiv.hDiv 1 p.toReal)))","decl":"theorem norm_indicatorConstLp' (hp_pos : p ‚â† 0) (hŒºs_pos : Œº s ‚â† 0) :\n    ‚ÄñindicatorConstLp p hs hŒºs c‚Äñ = ‚Äñc‚Äñ * (Œº s).toReal ^ (1 / p.toReal) := by\n  by_cases hp_top : p = ‚àû\n  ¬∑ rw [hp_top, ENNReal.top_toReal, _root_.div_zero, Real.rpow_zero, mul_one]\n    exact norm_indicatorConstLp_top hŒºs_pos\n  ¬∑ exact norm_indicatorConstLp hp_pos hp_top\n\n"}
{"name":"MeasureTheory.norm_indicatorConstLp_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nc : E\n‚ä¢ LE.le (Norm.norm (MeasureTheory.indicatorConstLp p hs hŒºs c)) (HMul.hMul (Norm.norm c) (HPow.hPow (Œº s).toReal (HDiv.hDiv 1 p.toReal)))","decl":"theorem norm_indicatorConstLp_le :\n    ‚ÄñindicatorConstLp p hs hŒºs c‚Äñ ‚â§ ‚Äñc‚Äñ * (Œº s).toReal ^ (1 / p.toReal) := by\n  rw [indicatorConstLp, Lp.norm_toLp]\n  refine ENNReal.toReal_le_of_le_ofReal (by positivity) ?_\n  refine (eLpNorm_indicator_const_le _ _).trans_eq ?_\n  rw [ENNReal.ofReal_mul (norm_nonneg _), ofReal_norm, ENNReal.toReal_rpow, ENNReal.ofReal_toReal]\n  exact ENNReal.rpow_ne_top_of_nonneg (by positivity) hŒºs\n\n"}
{"name":"MeasureTheory.nnnorm_indicatorConstLp_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nc : E\n‚ä¢ LE.le (NNNorm.nnnorm (MeasureTheory.indicatorConstLp p hs hŒºs c)) (HMul.hMul (NNNorm.nnnorm c) (HPow.hPow (Œº s).toNNReal (HDiv.hDiv 1 p.toReal)))","decl":"theorem nnnorm_indicatorConstLp_le :\n    ‚ÄñindicatorConstLp p hs hŒºs c‚Äñ‚Çä ‚â§ ‚Äñc‚Äñ‚Çä * (Œº s).toNNReal ^ (1 / p.toReal) :=\n  norm_indicatorConstLp_le\n\n"}
{"name":"MeasureTheory.enorm_indicatorConstLp_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nc : E\n‚ä¢ LE.le (ENorm.enorm (MeasureTheory.indicatorConstLp p hs hŒºs c)) (HMul.hMul (ENorm.enorm c) (HPow.hPow (Œº s) (HDiv.hDiv 1 p.toReal)))","decl":"theorem enorm_indicatorConstLp_le :\n    ‚ÄñindicatorConstLp p hs hŒºs c‚Äñ‚Çë ‚â§ ‚Äñc‚Äñ‚Çë * Œº s ^ (1 / p.toReal) := by\n  simpa [ENNReal.coe_rpow_of_nonneg, ENNReal.coe_toNNReal hŒºs, Lp.enorm_def, ‚Üê enorm_eq_nnnorm]\n    using ENNReal.coe_le_coe.2 <| nnnorm_indicatorConstLp_le (c := c) (hŒºs := hŒºs)\n\n"}
{"name":"MeasureTheory.ennnorm_indicatorConstLp_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nc : E\n‚ä¢ LE.le (ENorm.enorm (MeasureTheory.indicatorConstLp p hs hŒºs c)) (HMul.hMul (ENorm.enorm c) (HPow.hPow (Œº s) (HDiv.hDiv 1 p.toReal)))","decl":"@[deprecated (since := \"2025-01-20\")] alias ennnorm_indicatorConstLp_le := enorm_indicatorConstLp_le\n\n"}
{"name":"MeasureTheory.edist_indicatorConstLp_eq_enorm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nc : E\nt : Set Œ±\nht : MeasurableSet t\nhŒºt : Ne (Œº t) Top.top\n‚ä¢ Eq (EDist.edist (MeasureTheory.indicatorConstLp p hs hŒºs c) (MeasureTheory.indicatorConstLp p ht hŒºt c)) (ENorm.enorm (MeasureTheory.indicatorConstLp p ‚ãØ ‚ãØ c))","decl":"theorem edist_indicatorConstLp_eq_enorm {t : Set Œ±} {ht : MeasurableSet t} {hŒºt : Œº t ‚â† ‚àû} :\n    edist (indicatorConstLp p hs hŒºs c) (indicatorConstLp p ht hŒºt c) =\n      ‚ÄñindicatorConstLp p (hs.symmDiff ht) (measure_symmDiff_ne_top hŒºs hŒºt) c‚Äñ‚Çë := by\n  unfold indicatorConstLp\n  rw [Lp.edist_toLp_toLp, eLpNorm_indicator_sub_indicator, Lp.enorm_toLp]\n\n"}
{"name":"MeasureTheory.edist_indicatorConstLp_eq_nnnorm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nc : E\nt : Set Œ±\nht : MeasurableSet t\nhŒºt : Ne (Œº t) Top.top\n‚ä¢ Eq (EDist.edist (MeasureTheory.indicatorConstLp p hs hŒºs c) (MeasureTheory.indicatorConstLp p ht hŒºt c)) (ENorm.enorm (MeasureTheory.indicatorConstLp p ‚ãØ ‚ãØ c))","decl":"@[deprecated (since := \"2025-01-20\")]\nalias edist_indicatorConstLp_eq_nnnorm := edist_indicatorConstLp_eq_enorm\n\n"}
{"name":"MeasureTheory.dist_indicatorConstLp_eq_norm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nc : E\nt : Set Œ±\nht : MeasurableSet t\nhŒºt : Ne (Œº t) Top.top\n‚ä¢ Eq (Dist.dist (MeasureTheory.indicatorConstLp p hs hŒºs c) (MeasureTheory.indicatorConstLp p ht hŒºt c)) (Norm.norm (MeasureTheory.indicatorConstLp p ‚ãØ ‚ãØ c))","decl":"theorem dist_indicatorConstLp_eq_norm {t : Set Œ±} {ht : MeasurableSet t} {hŒºt : Œº t ‚â† ‚àû} :\n    dist (indicatorConstLp p hs hŒºs c) (indicatorConstLp p ht hŒºt c) =\n      ‚ÄñindicatorConstLp p (hs.symmDiff ht) (measure_symmDiff_ne_top hŒºs hŒºt) c‚Äñ := by\n  -- Squeezed for performance reasons\n  simp only [Lp.dist_edist, edist_indicatorConstLp_eq_enorm, enorm, ENNReal.coe_toReal,\n    Lp.coe_nnnorm]\n\n"}
{"name":"MeasureTheory.tendsto_indicatorConstLp_set","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nc : E\nhp‚ÇÅ : Fact (LE.le 1 p)\nŒ≤ : Type u_5\nl : Filter Œ≤\nt : Œ≤ ‚Üí Set Œ±\nht : ‚àÄ (b : Œ≤), MeasurableSet (t b)\nhŒºt : ‚àÄ (b : Œ≤), Ne (Œº (t b)) Top.top\nhp : Ne p Top.top\nh : Filter.Tendsto (fun b => Œº (symmDiff (t b) s)) l (nhds 0)\n‚ä¢ Filter.Tendsto (fun b => MeasureTheory.indicatorConstLp p ‚ãØ ‚ãØ c) l (nhds (MeasureTheory.indicatorConstLp p hs hŒºs c))","decl":"/-- A family of `indicatorConstLp` functions tends to an `indicatorConstLp`,\nif the underlying sets tend to the set in the sense of the measure of the symmetric difference. -/\ntheorem tendsto_indicatorConstLp_set [hp‚ÇÅ : Fact (1 ‚â§ p)] {Œ≤ : Type*} {l : Filter Œ≤} {t : Œ≤ ‚Üí Set Œ±}\n    {ht : ‚àÄ b, MeasurableSet (t b)} {hŒºt : ‚àÄ b, Œº (t b) ‚â† ‚àû} (hp : p ‚â† ‚àû)\n    (h : Tendsto (fun b ‚Ü¶ Œº (t b ‚àÜ s)) l (ùìù 0)) :\n    Tendsto (fun b ‚Ü¶ indicatorConstLp p (ht b) (hŒºt b) c) l (ùìù (indicatorConstLp p hs hŒºs c)) := by\n  rw [tendsto_iff_dist_tendsto_zero]\n  have hp‚ÇÄ : p ‚â† 0 := (one_pos.trans_le hp‚ÇÅ.out).ne'\n  simp only [dist_indicatorConstLp_eq_norm, norm_indicatorConstLp hp‚ÇÄ hp]\n  convert tendsto_const_nhds.mul\n    (((ENNReal.tendsto_toReal ENNReal.zero_ne_top).comp h).rpow_const _)\n  ¬∑ simp [Real.rpow_eq_zero_iff_of_nonneg, ENNReal.toReal_eq_zero_iff, hp, hp‚ÇÄ]\n  ¬∑ simp\n\n"}
{"name":"MeasureTheory.continuous_indicatorConstLp_set","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : NormedAddCommGroup E\nc : E\ninst‚úù¬π : Fact (LE.le 1 p)\nX : Type u_5\ninst‚úù : TopologicalSpace X\ns : X ‚Üí Set Œ±\nhs : ‚àÄ (x : X), MeasurableSet (s x)\nhŒºs : ‚àÄ (x : X), Ne (Œº (s x)) Top.top\nhp : Ne p Top.top\nh : ‚àÄ (x : X), Filter.Tendsto (fun y => Œº (symmDiff (s y) (s x))) (nhds x) (nhds 0)\n‚ä¢ Continuous fun x => MeasureTheory.indicatorConstLp p ‚ãØ ‚ãØ c","decl":"/-- A family of `indicatorConstLp` functions is continuous in the parameter,\nif `Œº (s y ‚àÜ s x)` tends to zero as `y` tends to `x` for all `x`. -/\ntheorem continuous_indicatorConstLp_set [Fact (1 ‚â§ p)] {X : Type*} [TopologicalSpace X]\n    {s : X ‚Üí Set Œ±} {hs : ‚àÄ x, MeasurableSet (s x)} {hŒºs : ‚àÄ x, Œº (s x) ‚â† ‚àû} (hp : p ‚â† ‚àû)\n    (h : ‚àÄ x, Tendsto (fun y ‚Ü¶ Œº (s y ‚àÜ s x)) (ùìù x) (ùìù 0)) :\n    Continuous fun x ‚Ü¶ indicatorConstLp p (hs x) (hŒºs x) c :=\n  continuous_iff_continuousAt.2 fun x ‚Ü¶ tendsto_indicatorConstLp_set hp (h x)\n\n"}
{"name":"MeasureTheory.indicatorConstLp_empty","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nc : E\n‚ä¢ Eq (MeasureTheory.indicatorConstLp p ‚ãØ ‚ãØ c) 0","decl":"@[simp]\ntheorem indicatorConstLp_empty :\n    indicatorConstLp p MeasurableSet.empty (by simp : Œº ‚àÖ ‚â† ‚àû) c = 0 := by\n  simp only [indicatorConstLp, Set.indicator_empty', Mem‚Ñíp.toLp_zero]\n\n"}
{"name":"MeasureTheory.indicatorConstLp_inj","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\ns t : Set Œ±\nhs : MeasurableSet s\nhsŒº : Ne (Œº s) Top.top\nht : MeasurableSet t\nhtŒº : Ne (Œº t) Top.top\nc : E\nhc : Ne c 0\n‚ä¢ Iff (Eq (MeasureTheory.indicatorConstLp p hs hsŒº c) (MeasureTheory.indicatorConstLp p ht htŒº c)) ((MeasureTheory.ae Œº).EventuallyEq s t)","decl":"theorem indicatorConstLp_inj {s t : Set Œ±} (hs : MeasurableSet s) (hsŒº : Œº s ‚â† ‚àû)\n    (ht : MeasurableSet t) (htŒº : Œº t ‚â† ‚àû) {c : E} (hc : c ‚â† 0) :\n    indicatorConstLp p hs hsŒº c = indicatorConstLp p ht htŒº c ‚Üî s =·µê[Œº] t := by\n  simp_rw [‚Üê indicator_const_eventuallyEq hc, indicatorConstLp, Mem‚Ñíp.toLp_eq_toLp_iff]\n\n"}
{"name":"MeasureTheory.mem‚Ñíp_add_of_disjoint","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf g : Œ± ‚Üí E\nh : Disjoint (Function.support f) (Function.support g)\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\n‚ä¢ Iff (MeasureTheory.Mem‚Ñíp (HAdd.hAdd f g) p Œº) (And (MeasureTheory.Mem‚Ñíp f p Œº) (MeasureTheory.Mem‚Ñíp g p Œº))","decl":"theorem mem‚Ñíp_add_of_disjoint {f g : Œ± ‚Üí E} (h : Disjoint (support f) (support g))\n    (hf : StronglyMeasurable f) (hg : StronglyMeasurable g) :\n    Mem‚Ñíp (f + g) p Œº ‚Üî Mem‚Ñíp f p Œº ‚àß Mem‚Ñíp g p Œº := by\n  borelize E\n  refine ‚ü®fun hfg => ‚ü®?_, ?_‚ü©, fun h => h.1.add h.2‚ü©\n  ¬∑ rw [‚Üê Set.indicator_add_eq_left h]; exact hfg.indicator (measurableSet_support hf.measurable)\n  ¬∑ rw [‚Üê Set.indicator_add_eq_right h]; exact hfg.indicator (measurableSet_support hg.measurable)\n\n"}
{"name":"MeasureTheory.indicatorConstLp_disjoint_union","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\ns t : Set Œ±\nhs : MeasurableSet s\nht : MeasurableSet t\nhŒºs : Ne (Œº s) Top.top\nhŒºt : Ne (Œº t) Top.top\nhst : Disjoint s t\nc : E\n‚ä¢ Eq (MeasureTheory.indicatorConstLp p ‚ãØ ‚ãØ c) (HAdd.hAdd (MeasureTheory.indicatorConstLp p hs hŒºs c) (MeasureTheory.indicatorConstLp p ht hŒºt c))","decl":"/-- The indicator of a disjoint union of two sets is the sum of the indicators of the sets. -/\ntheorem indicatorConstLp_disjoint_union {s t : Set Œ±} (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (hŒºs : Œº s ‚â† ‚àû) (hŒºt : Œº t ‚â† ‚àû) (hst : Disjoint s t) (c : E) :\n    indicatorConstLp p (hs.union ht) (measure_union_ne_top hŒºs hŒºt) c =\n      indicatorConstLp p hs hŒºs c + indicatorConstLp p ht hŒºt c := by\n  ext1\n  refine indicatorConstLp_coeFn.trans (EventuallyEq.trans ?_ (Lp.coeFn_add _ _).symm)\n  refine\n    EventuallyEq.trans ?_\n      (EventuallyEq.add indicatorConstLp_coeFn.symm indicatorConstLp_coeFn.symm)\n  rw [Set.indicator_union_of_disjoint hst]\n\n"}
{"name":"MeasureTheory.Lp.coeFn_const","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nc : E\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (‚Üë‚Üë((MeasureTheory.Lp.const p Œº) c)) (Function.const Œ± c)","decl":"lemma Lp.coeFn_const : Lp.const p Œº c =·µê[Œº] Function.const Œ± c :=\n  AEEqFun.coeFn_const Œ± c\n\n"}
{"name":"MeasureTheory.Lp.const_val","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nc : E\n‚ä¢ Eq (‚Üë((MeasureTheory.Lp.const p Œº) c)) (MeasureTheory.AEEqFun.const Œ± c)","decl":"@[simp] lemma Lp.const_val : (Lp.const p Œº c).1 = AEEqFun.const Œ± c := rfl\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.toLp_const","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nc : E\n‚ä¢ Eq (MeasureTheory.Mem‚Ñíp.toLp (fun x => c) ‚ãØ) ((MeasureTheory.Lp.const p Œº) c)","decl":"@[simp]\nlemma Mem‚Ñíp.toLp_const : Mem‚Ñíp.toLp _ (mem‚Ñíp_const c) = Lp.const p Œº c := rfl\n\n"}
{"name":"MeasureTheory.indicatorConstLp_univ","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nc : E\n‚ä¢ Eq (MeasureTheory.indicatorConstLp p ‚ãØ ‚ãØ c) ((MeasureTheory.Lp.const p Œº) c)","decl":"@[simp]\nlemma indicatorConstLp_univ :\n    indicatorConstLp p .univ (measure_ne_top Œº _) c = Lp.const p Œº c := by\n  rw [‚Üê Mem‚Ñíp.toLp_const, indicatorConstLp]\n  simp only [Set.indicator_univ, Function.const]\n\n"}
{"name":"MeasureTheory.Lp.norm_const","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : MeasureTheory.IsFiniteMeasure Œº\nc : E\ninst‚úù : NeZero Œº\nhp_zero : Ne p 0\n‚ä¢ Eq (Norm.norm ((MeasureTheory.Lp.const p Œº) c)) (HMul.hMul (Norm.norm c) (HPow.hPow (Œº Set.univ).toReal (HDiv.hDiv 1 p.toReal)))","decl":"theorem Lp.norm_const [NeZero Œº] (hp_zero : p ‚â† 0) :\n    ‚ÄñLp.const p Œº c‚Äñ = ‚Äñc‚Äñ * (Œº Set.univ).toReal ^ (1 / p.toReal) := by\n  have := NeZero.ne Œº\n  rw [‚Üê Mem‚Ñíp.toLp_const, Lp.norm_toLp, eLpNorm_const] <;> try assumption\n  rw [ENNReal.toReal_mul, toReal_enorm, ‚Üê ENNReal.toReal_rpow]\n\n"}
{"name":"MeasureTheory.Lp.norm_const'","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nc : E\nhp_zero : Ne p 0\nhp_top : Ne p Top.top\n‚ä¢ Eq (Norm.norm ((MeasureTheory.Lp.const p Œº) c)) (HMul.hMul (Norm.norm c) (HPow.hPow (Œº Set.univ).toReal (HDiv.hDiv 1 p.toReal)))","decl":"theorem Lp.norm_const' (hp_zero : p ‚â† 0) (hp_top : p ‚â† ‚àû) :\n    ‚ÄñLp.const p Œº c‚Äñ = ‚Äñc‚Äñ * (Œº Set.univ).toReal ^ (1 / p.toReal) := by\n  rw [‚Üê Mem‚Ñíp.toLp_const, Lp.norm_toLp, eLpNorm_const'] <;> try assumption\n  rw [ENNReal.toReal_mul, toReal_enorm, ‚Üê ENNReal.toReal_rpow]\n\n"}
{"name":"MeasureTheory.Lp.norm_const_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nc : E\n‚ä¢ LE.le (Norm.norm ((MeasureTheory.Lp.const p Œº) c)) (HMul.hMul (Norm.norm c) (HPow.hPow (Œº Set.univ).toReal (HDiv.hDiv 1 p.toReal)))","decl":"theorem Lp.norm_const_le : ‚ÄñLp.const p Œº c‚Äñ ‚â§ ‚Äñc‚Äñ * (Œº Set.univ).toReal ^ (1 / p.toReal) := by\n  rw [‚Üê indicatorConstLp_univ]\n  exact norm_indicatorConstLp_le\n\n"}
{"name":"MeasureTheory.Lp.const‚Çó_apply","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : MeasureTheory.IsFiniteMeasure Œº\nùïú : Type u_5\ninst‚úù¬≤ : NormedRing ùïú\ninst‚úù¬π : Module ùïú E\ninst‚úù : BoundedSMul ùïú E\na : E\n‚ä¢ Eq ((MeasureTheory.Lp.const‚Çó p Œº ùïú) a) ((MeasureTheory.Lp.const p Œº) a)","decl":"/-- `MeasureTheory.Lp.const` as a `LinearMap`. -/\n@[simps] protected def Lp.const‚Çó (ùïú : Type*) [NormedRing ùïú] [Module ùïú E] [BoundedSMul ùïú E] :\n    E ‚Üí‚Çó[ùïú] Lp E p Œº where\n  toFun := Lp.const p Œº\n  map_add' := map_add _\n  map_smul' _ _ := rfl\n\n"}
{"name":"MeasureTheory.Lp.constL_apply","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : MeasureTheory.IsFiniteMeasure Œº\nùïú : Type u_5\ninst‚úù¬≤ : NormedField ùïú\ninst‚úù¬π : NormedSpace ùïú E\ninst‚úù : Fact (LE.le 1 p)\na : E\n‚ä¢ Eq ((MeasureTheory.Lp.constL p Œº ùïú) a) ((MeasureTheory.Lp.const p Œº) a)","decl":"@[simps! apply]\nprotected def Lp.constL (ùïú : Type*) [NormedField ùïú] [NormedSpace ùïú E] [Fact (1 ‚â§ p)] :\n    E ‚ÜíL[ùïú] Lp E p Œº :=\n  (Lp.const‚Çó p Œº ùïú).mkContinuous ((Œº Set.univ).toReal ^ (1 / p.toReal)) fun _ ‚Ü¶\n    (Lp.norm_const_le _ _ _).trans_eq (mul_comm _ _)\n\n"}
{"name":"MeasureTheory.Lp.norm_constL_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : MeasureTheory.IsFiniteMeasure Œº\nùïú : Type u_5\ninst‚úù¬≤ : NontriviallyNormedField ùïú\ninst‚úù¬π : NormedSpace ùïú E\ninst‚úù : Fact (LE.le 1 p)\n‚ä¢ LE.le (Norm.norm (MeasureTheory.Lp.constL p Œº ùïú)) (HPow.hPow (Œº Set.univ).toReal (HDiv.hDiv 1 p.toReal))","decl":"theorem Lp.norm_constL_le (ùïú : Type*) [NontriviallyNormedField ùïú] [NormedSpace ùïú E]\n    [Fact (1 ‚â§ p)] :\n    ‚Äñ(Lp.constL p Œº ùïú : E ‚ÜíL[ùïú] Lp E p Œº)‚Äñ ‚â§ (Œº Set.univ).toReal ^ (1 / p.toReal) :=\n  LinearMap.mkContinuous_norm_le _ (by positivity) _\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.norm_rpow_div","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nq : ENNReal\n‚ä¢ MeasureTheory.Mem‚Ñíp (fun x => HPow.hPow (Norm.norm (f x)) q.toReal) (HDiv.hDiv p q) Œº","decl":"theorem Mem‚Ñíp.norm_rpow_div {f : Œ± ‚Üí E} (hf : Mem‚Ñíp f p Œº) (q : ‚Ñù‚â•0‚àû) :\n    Mem‚Ñíp (fun x : Œ± => ‚Äñf x‚Äñ ^ q.toReal) (p / q) Œº := by\n  refine ‚ü®(hf.1.norm.aemeasurable.pow_const q.toReal).aestronglyMeasurable, ?_‚ü©\n  by_cases q_top : q = ‚àû\n  ¬∑ simp [q_top]\n  by_cases q_zero : q = 0\n  ¬∑ simp only [q_zero, ENNReal.zero_toReal, Real.rpow_zero]\n    by_cases p_zero : p = 0\n    ¬∑ simp [p_zero]\n    rw [ENNReal.div_zero p_zero]\n    exact (mem‚Ñíp_top_const (1 : ‚Ñù)).2\n  rw [eLpNorm_norm_rpow _ (ENNReal.toReal_pos q_zero q_top)]\n  apply ENNReal.rpow_lt_top_of_nonneg ENNReal.toReal_nonneg\n  rw [ENNReal.ofReal_toReal q_top, div_eq_mul_inv, mul_assoc, ENNReal.inv_mul_cancel q_zero q_top,\n    mul_one]\n  exact hf.2.ne\n\n"}
{"name":"MeasureTheory.mem‚Ñíp_norm_rpow_iff","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nq : ENNReal\nf : Œ± ‚Üí E\nhf : MeasureTheory.AEStronglyMeasurable f Œº\nq_zero : Ne q 0\nq_top : Ne q Top.top\n‚ä¢ Iff (MeasureTheory.Mem‚Ñíp (fun x => HPow.hPow (Norm.norm (f x)) q.toReal) (HDiv.hDiv p q) Œº) (MeasureTheory.Mem‚Ñíp f p Œº)","decl":"theorem mem‚Ñíp_norm_rpow_iff {q : ‚Ñù‚â•0‚àû} {f : Œ± ‚Üí E} (hf : AEStronglyMeasurable f Œº) (q_zero : q ‚â† 0)\n    (q_top : q ‚â† ‚àû) : Mem‚Ñíp (fun x : Œ± => ‚Äñf x‚Äñ ^ q.toReal) (p / q) Œº ‚Üî Mem‚Ñíp f p Œº := by\n  refine ‚ü®fun h => ?_, fun h => h.norm_rpow_div q‚ü©\n  apply (mem‚Ñíp_norm_iff hf).1\n  convert h.norm_rpow_div q‚Åª¬π using 1\n  ¬∑ ext x\n    rw [Real.norm_eq_abs, Real.abs_rpow_of_nonneg (norm_nonneg _), ‚Üê Real.rpow_mul (abs_nonneg _),\n      ENNReal.toReal_inv, mul_inv_cancel‚ÇÄ, abs_of_nonneg (norm_nonneg _), Real.rpow_one]\n    simp [ENNReal.toReal_eq_zero_iff, not_or, q_zero, q_top]\n  ¬∑ rw [div_eq_mul_inv, inv_inv, div_eq_mul_inv, mul_assoc, ENNReal.inv_mul_cancel q_zero q_top,\n      mul_one]\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.norm_rpow","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\n‚ä¢ MeasureTheory.Mem‚Ñíp (fun x => HPow.hPow (Norm.norm (f x)) p.toReal) 1 Œº","decl":"theorem Mem‚Ñíp.norm_rpow {f : Œ± ‚Üí E} (hf : Mem‚Ñíp f p Œº) (hp_ne_zero : p ‚â† 0) (hp_ne_top : p ‚â† ‚àû) :\n    Mem‚Ñíp (fun x : Œ± => ‚Äñf x‚Äñ ^ p.toReal) 1 Œº := by\n  convert hf.norm_rpow_div p\n  rw [div_eq_mul_inv, ENNReal.mul_inv_cancel hp_ne_zero hp_ne_top]\n\n"}
{"name":"MeasureTheory.AEEqFun.compMeasurePreserving_mem_Lp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\nŒ≤ : Type u_5\ninst‚úù : MeasurableSpace Œ≤\nŒºb : MeasureTheory.Measure Œ≤\ng : MeasureTheory.AEEqFun Œ≤ E Œºb\nhg : Membership.mem (MeasureTheory.Lp E p Œºb) g\nf : Œ± ‚Üí Œ≤\nhf : MeasureTheory.MeasurePreserving f Œº Œºb\n‚ä¢ Membership.mem (MeasureTheory.Lp E p Œº) (g.compMeasurePreserving f hf)","decl":"theorem AEEqFun.compMeasurePreserving_mem_Lp {Œ≤ : Type*} [MeasurableSpace Œ≤]\n    {Œºb : MeasureTheory.Measure Œ≤} {g : Œ≤ ‚Üí‚Çò[Œºb] E} (hg : g ‚àà Lp E p Œºb) {f : Œ± ‚Üí Œ≤}\n    (hf : MeasurePreserving f Œº Œºb) :\n    g.compMeasurePreserving f hf ‚àà Lp E p Œº := by\n  rw [Lp.mem_Lp_iff_eLpNorm_lt_top] at hg ‚ä¢\n  rwa [eLpNorm_compMeasurePreserving]\n\n"}
{"name":"MeasureTheory.Lp.compMeasurePreserving_val","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\nŒ≤ : Type u_5\ninst‚úù : MeasurableSpace Œ≤\nŒºb : MeasureTheory.Measure Œ≤\nf : Œ± ‚Üí Œ≤\ng : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œºb) x\nhf : MeasureTheory.MeasurePreserving f Œº Œºb\n‚ä¢ Eq (‚Üë((MeasureTheory.Lp.compMeasurePreserving f hf) g)) ((‚Üëg).compMeasurePreserving f hf)","decl":"@[simp]\ntheorem compMeasurePreserving_val (g : Lp E p Œºb) (hf : MeasurePreserving f Œº Œºb) :\n    (compMeasurePreserving f hf g).1 = g.1.compMeasurePreserving f hf :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.coeFn_compMeasurePreserving","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\nŒ≤ : Type u_5\ninst‚úù : MeasurableSpace Œ≤\nŒºb : MeasureTheory.Measure Œ≤\nf : Œ± ‚Üí Œ≤\ng : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œºb) x\nhf : MeasureTheory.MeasurePreserving f Œº Œºb\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (‚Üë‚Üë((MeasureTheory.Lp.compMeasurePreserving f hf) g)) (Function.comp (‚Üë‚Üëg) f)","decl":"theorem coeFn_compMeasurePreserving (g : Lp E p Œºb) (hf : MeasurePreserving f Œº Œºb) :\n    compMeasurePreserving f hf g =·µê[Œº] g ‚àò f :=\n  g.1.coeFn_compMeasurePreserving hf\n\n"}
{"name":"MeasureTheory.Lp.norm_compMeasurePreserving","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\nŒ≤ : Type u_5\ninst‚úù : MeasurableSpace Œ≤\nŒºb : MeasureTheory.Measure Œ≤\nf : Œ± ‚Üí Œ≤\ng : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œºb) x\nhf : MeasureTheory.MeasurePreserving f Œº Œºb\n‚ä¢ Eq (Norm.norm ((MeasureTheory.Lp.compMeasurePreserving f hf) g)) (Norm.norm g)","decl":"@[simp]\ntheorem norm_compMeasurePreserving (g : Lp E p Œºb) (hf : MeasurePreserving f Œº Œºb) :\n    ‚ÄñcompMeasurePreserving f hf g‚Äñ = ‚Äñg‚Äñ :=\n  congr_arg ENNReal.toReal <| g.1.eLpNorm_compMeasurePreserving hf\n\n"}
{"name":"MeasureTheory.Lp.isometry_compMeasurePreserving","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : NormedAddCommGroup E\nŒ≤ : Type u_5\ninst‚úù¬π : MeasurableSpace Œ≤\nŒºb : MeasureTheory.Measure Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : Fact (LE.le 1 p)\nhf : MeasureTheory.MeasurePreserving f Œº Œºb\n‚ä¢ Isometry ‚áë(MeasureTheory.Lp.compMeasurePreserving f hf)","decl":"theorem isometry_compMeasurePreserving [Fact (1 ‚â§ p)] (hf : MeasurePreserving f Œº Œºb) :\n    Isometry (compMeasurePreserving f hf : Lp E p Œºb ‚Üí Lp E p Œº) :=\n  AddMonoidHomClass.isometry_of_norm _ (norm_compMeasurePreserving ¬∑ hf)\n\n"}
{"name":"MeasureTheory.Lp.toLp_compMeasurePreserving","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\nŒ≤ : Type u_5\ninst‚úù : MeasurableSpace Œ≤\nŒºb : MeasureTheory.Measure Œ≤\nf : Œ± ‚Üí Œ≤\ng : Œ≤ ‚Üí E\nhg : MeasureTheory.Mem‚Ñíp g p Œºb\nhf : MeasureTheory.MeasurePreserving f Œº Œºb\n‚ä¢ Eq ((MeasureTheory.Lp.compMeasurePreserving f hf) (MeasureTheory.Mem‚Ñíp.toLp g hg)) (MeasureTheory.Mem‚Ñíp.toLp (Function.comp g f) ‚ãØ)","decl":"theorem toLp_compMeasurePreserving {g : Œ≤ ‚Üí E} (hg : Mem‚Ñíp g p Œºb) (hf : MeasurePreserving f Œº Œºb) :\n    compMeasurePreserving f hf (hg.toLp g) = (hg.comp_measurePreserving hf).toLp _ := rfl\n\n"}
{"name":"MeasureTheory.Lp.indicatorConstLp_compMeasurePreserving","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\nŒ≤ : Type u_5\ninst‚úù : MeasurableSpace Œ≤\nŒºb : MeasureTheory.Measure Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ≤\nhs : MeasurableSet s\nhŒºs : Ne (Œºb s) Top.top\nc : E\nhf : MeasureTheory.MeasurePreserving f Œº Œºb\n‚ä¢ Eq ((MeasureTheory.Lp.compMeasurePreserving f hf) (MeasureTheory.indicatorConstLp p hs hŒºs c)) (MeasureTheory.indicatorConstLp p ‚ãØ ‚ãØ c)","decl":"theorem indicatorConstLp_compMeasurePreserving {s : Set Œ≤} (hs : MeasurableSet s)\n    (hŒºs : Œºb s ‚â† ‚àû) (c : E) (hf : MeasurePreserving f Œº Œºb) :\n    Lp.compMeasurePreserving f hf (indicatorConstLp p hs hŒºs c) =\n      indicatorConstLp p (hs.preimage hf.measurable)\n        (by rwa [hf.measure_preimage hs.nullMeasurableSet]) c :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.compMeasurePreserving‚Çó_apply","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å¥ : NormedAddCommGroup E\nŒ≤ : Type u_5\ninst‚úù¬≥ : MeasurableSpace Œ≤\nŒºb : MeasureTheory.Measure Œ≤\nùïú : Type u_6\ninst‚úù¬≤ : NormedRing ùïú\ninst‚úù¬π : Module ùïú E\ninst‚úù : BoundedSMul ùïú E\nf : Œ± ‚Üí Œ≤\nhf : MeasureTheory.MeasurePreserving f Œº Œºb\na‚úù : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œºb) x\n‚ä¢ Eq ((MeasureTheory.Lp.compMeasurePreserving‚Çó ùïú f hf) a‚úù) ((‚Üë(MeasureTheory.Lp.compMeasurePreserving f hf)).toFun a‚úù)","decl":"/-- `MeasureTheory.Lp.compMeasurePreserving` as a linear map. -/\n@[simps]\ndef compMeasurePreserving‚Çó (f : Œ± ‚Üí Œ≤) (hf : MeasurePreserving f Œº Œºb) :\n    Lp E p Œºb ‚Üí‚Çó[ùïú] Lp E p Œº where\n  __ := compMeasurePreserving f hf\n  map_smul' c g := by rcases g with ‚ü®‚ü®_‚ü©, _‚ü©; rfl\n\n"}
{"name":"MeasureTheory.Lp.compMeasurePreserving‚Çó·µ¢_apply_coe","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Åµ : NormedAddCommGroup E\nŒ≤ : Type u_5\ninst‚úù‚Å¥ : MeasurableSpace Œ≤\nŒºb : MeasureTheory.Measure Œ≤\nùïú : Type u_6\ninst‚úù¬≥ : NormedRing ùïú\ninst‚úù¬≤ : Module ùïú E\ninst‚úù¬π : BoundedSMul ùïú E\ninst‚úù : Fact (LE.le 1 p)\nf : Œ± ‚Üí Œ≤\nhf : MeasureTheory.MeasurePreserving f Œº Œºb\na‚úù : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œºb) x\n‚ä¢ Eq (‚Üë((MeasureTheory.Lp.compMeasurePreserving‚Çó·µ¢ ùïú f hf) a‚úù)) ((‚Üëa‚úù).compMeasurePreserving f hf)","decl":"/-- `MeasureTheory.Lp.compMeasurePreserving` as a linear isometry. -/\n@[simps!]\ndef compMeasurePreserving‚Çó·µ¢ [Fact (1 ‚â§ p)] (f : Œ± ‚Üí Œ≤) (hf : MeasurePreserving f Œº Œºb) :\n    Lp E p Œºb ‚Üí‚Çó·µ¢[ùïú] Lp E p Œº where\n  toLinearMap := compMeasurePreserving‚Çó ùïú f hf\n  norm_map' := (norm_compMeasurePreserving ¬∑ hf)\n\n"}
{"name":"LipschitzWith.comp_mem‚Ñíp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"p : ENNReal\nŒ± : Type u_5\nE : Type u_6\nF : Type u_7\nK : NNReal\ninst‚úù¬≤ : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedAddCommGroup F\nf : Œ± ‚Üí E\ng : E ‚Üí F\nhg : LipschitzWith K g\ng0 : Eq (g 0) 0\nhL : MeasureTheory.Mem‚Ñíp f p Œº\n‚ä¢ MeasureTheory.Mem‚Ñíp (Function.comp g f) p Œº","decl":"theorem LipschitzWith.comp_mem‚Ñíp {Œ± E F} {K} [MeasurableSpace Œ±] {Œº : Measure Œ±}\n    [NormedAddCommGroup E] [NormedAddCommGroup F] {f : Œ± ‚Üí E} {g : E ‚Üí F} (hg : LipschitzWith K g)\n    (g0 : g 0 = 0) (hL : Mem‚Ñíp f p Œº) : Mem‚Ñíp (g ‚àò f) p Œº :=\n  have : ‚àÄ x, ‚Äñg (f x)‚Äñ ‚â§ K * ‚Äñf x‚Äñ := fun x ‚Ü¶ by\n    -- TODO: add `LipschitzWith.nnnorm_sub_le` and `LipschitzWith.nnnorm_le`\n    simpa [g0] using hg.norm_sub_le (f x) 0\n  hL.of_le_mul (hg.continuous.comp_aestronglyMeasurable hL.1) (Eventually.of_forall this)\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.of_comp_antilipschitzWith","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"p : ENNReal\nŒ± : Type u_5\nE : Type u_6\nF : Type u_7\nK' : NNReal\ninst‚úù¬≤ : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedAddCommGroup F\nf : Œ± ‚Üí E\ng : E ‚Üí F\nhL : MeasureTheory.Mem‚Ñíp (Function.comp g f) p Œº\nhg : UniformContinuous g\nhg' : AntilipschitzWith K' g\ng0 : Eq (g 0) 0\n‚ä¢ MeasureTheory.Mem‚Ñíp f p Œº","decl":"theorem MeasureTheory.Mem‚Ñíp.of_comp_antilipschitzWith {Œ± E F} {K'} [MeasurableSpace Œ±]\n    {Œº : Measure Œ±} [NormedAddCommGroup E] [NormedAddCommGroup F] {f : Œ± ‚Üí E} {g : E ‚Üí F}\n    (hL : Mem‚Ñíp (g ‚àò f) p Œº) (hg : UniformContinuous g) (hg' : AntilipschitzWith K' g)\n    (g0 : g 0 = 0) : Mem‚Ñíp f p Œº := by\n  have A : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ K' * ‚Äñg (f x)‚Äñ := by\n    intro x\n    -- TODO: add `AntilipschitzWith.le_mul_nnnorm_sub` and `AntilipschitzWith.le_mul_norm`\n    rw [‚Üê dist_zero_right, ‚Üê dist_zero_right, ‚Üê g0]\n    apply hg'.le_mul_dist\n  have B : AEStronglyMeasurable f Œº :=\n    (hg'.isUniformEmbedding hg).isEmbedding.aestronglyMeasurable_comp_iff.1 hL.1\n  exact hL.of_le_mul B (Filter.Eventually.of_forall A)\n\n"}
{"name":"LipschitzWith.mem‚Ñíp_comp_iff_of_antilipschitz","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"p : ENNReal\nŒ± : Type u_5\nE : Type u_6\nF : Type u_7\nK K' : NNReal\ninst‚úù¬≤ : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedAddCommGroup F\nf : Œ± ‚Üí E\ng : E ‚Üí F\nhg : LipschitzWith K g\nhg' : AntilipschitzWith K' g\ng0 : Eq (g 0) 0\n‚ä¢ Iff (MeasureTheory.Mem‚Ñíp (Function.comp g f) p Œº) (MeasureTheory.Mem‚Ñíp f p Œº)","decl":"theorem mem‚Ñíp_comp_iff_of_antilipschitz {Œ± E F} {K K'} [MeasurableSpace Œ±] {Œº : Measure Œ±}\n    [NormedAddCommGroup E] [NormedAddCommGroup F] {f : Œ± ‚Üí E} {g : E ‚Üí F} (hg : LipschitzWith K g)\n    (hg' : AntilipschitzWith K' g) (g0 : g 0 = 0) : Mem‚Ñíp (g ‚àò f) p Œº ‚Üî Mem‚Ñíp f p Œº :=\n  ‚ü®fun h => h.of_comp_antilipschitzWith hg.uniformContinuous hg' g0, fun h => hg.comp_mem‚Ñíp g0 h‚ü©\n\n"}
{"name":"LipschitzWith.coeFn_compLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedAddCommGroup F\ng : E ‚Üí F\nc : NNReal\nhg : LipschitzWith c g\ng0 : Eq (g 0) 0\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (‚Üë‚Üë(hg.compLp g0 f)) (Function.comp g ‚Üë‚Üëf)","decl":"theorem coeFn_compLp (hg : LipschitzWith c g) (g0 : g 0 = 0) (f : Lp E p Œº) :\n    hg.compLp g0 f =·µê[Œº] g ‚àò f :=\n  AEEqFun.coeFn_comp _ hg.continuous _\n\n"}
{"name":"LipschitzWith.compLp_zero","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedAddCommGroup F\ng : E ‚Üí F\nc : NNReal\nhg : LipschitzWith c g\ng0 : Eq (g 0) 0\n‚ä¢ Eq (hg.compLp g0 0) 0","decl":"@[simp]\ntheorem compLp_zero (hg : LipschitzWith c g) (g0 : g 0 = 0) : hg.compLp g0 (0 : Lp E p Œº) = 0 := by\n  rw [Lp.eq_zero_iff_ae_eq_zero]\n  apply (coeFn_compLp _ _ _).trans\n  filter_upwards [Lp.coeFn_zero E p Œº] with _ ha\n  simp only [ha, g0, Function.comp_apply, Pi.zero_apply]\n\n"}
{"name":"LipschitzWith.norm_compLp_sub_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedAddCommGroup F\ng : E ‚Üí F\nc : NNReal\nhg : LipschitzWith c g\ng0 : Eq (g 0) 0\nf f' : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ LE.le (Norm.norm (HSub.hSub (hg.compLp g0 f) (hg.compLp g0 f'))) (HMul.hMul (‚Üëc) (Norm.norm (HSub.hSub f f')))","decl":"theorem norm_compLp_sub_le (hg : LipschitzWith c g) (g0 : g 0 = 0) (f f' : Lp E p Œº) :\n    ‚Äñhg.compLp g0 f - hg.compLp g0 f'‚Äñ ‚â§ c * ‚Äñf - f'‚Äñ := by\n  apply Lp.norm_le_mul_norm_of_ae_le_mul\n  filter_upwards [hg.coeFn_compLp g0 f, hg.coeFn_compLp g0 f',\n    Lp.coeFn_sub (hg.compLp g0 f) (hg.compLp g0 f'), Lp.coeFn_sub f f'] with a ha1 ha2 ha3 ha4\n  simp only [ha1, ha2, ha3, ha4, ‚Üê dist_eq_norm, Pi.sub_apply, Function.comp_apply]\n  exact hg.dist_le_mul (f a) (f' a)\n\n"}
{"name":"LipschitzWith.norm_compLp_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedAddCommGroup F\ng : E ‚Üí F\nc : NNReal\nhg : LipschitzWith c g\ng0 : Eq (g 0) 0\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ LE.le (Norm.norm (hg.compLp g0 f)) (HMul.hMul (‚Üëc) (Norm.norm f))","decl":"theorem norm_compLp_le (hg : LipschitzWith c g) (g0 : g 0 = 0) (f : Lp E p Œº) :\n    ‚Äñhg.compLp g0 f‚Äñ ‚â§ c * ‚Äñf‚Äñ := by\n  -- squeezed for performance reasons\n  simpa only [compLp_zero, sub_zero] using hg.norm_compLp_sub_le g0 f 0\n\n"}
{"name":"LipschitzWith.lipschitzWith_compLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedAddCommGroup F\ng : E ‚Üí F\nc : NNReal\ninst‚úù : Fact (LE.le 1 p)\nhg : LipschitzWith c g\ng0 : Eq (g 0) 0\n‚ä¢ LipschitzWith c (hg.compLp g0)","decl":"theorem lipschitzWith_compLp [Fact (1 ‚â§ p)] (hg : LipschitzWith c g) (g0 : g 0 = 0) :\n    LipschitzWith c (hg.compLp g0 : Lp E p Œº ‚Üí Lp F p Œº) :=\n  -- squeezed for performance reasons\n  LipschitzWith.of_dist_le_mul fun f g => by simp only [dist_eq_norm, norm_compLp_sub_le]\n\n"}
{"name":"LipschitzWith.continuous_compLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedAddCommGroup F\ng : E ‚Üí F\nc : NNReal\ninst‚úù : Fact (LE.le 1 p)\nhg : LipschitzWith c g\ng0 : Eq (g 0) 0\n‚ä¢ Continuous (hg.compLp g0)","decl":"theorem continuous_compLp [Fact (1 ‚â§ p)] (hg : LipschitzWith c g) (g0 : g 0 = 0) :\n    Continuous (hg.compLp g0 : Lp E p Œº ‚Üí Lp F p Œº) :=\n  (lipschitzWith_compLp hg g0).continuous\n\n"}
{"name":"ContinuousLinearMap.coeFn_compLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedAddCommGroup F\nùïú : Type u_5\ninst‚úù¬≤ : NontriviallyNormedField ùïú\ninst‚úù¬π : NormedSpace ùïú E\ninst‚úù : NormedSpace ùïú F\nL : ContinuousLinearMap (RingHom.id ùïú) E F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Filter.Eventually (fun a => Eq (‚Üë‚Üë(L.compLp f) a) (L (‚Üë‚Üëf a))) (MeasureTheory.ae Œº)","decl":"theorem coeFn_compLp (L : E ‚ÜíL[ùïú] F) (f : Lp E p Œº) : ‚àÄ·µê a ‚àÇŒº, (L.compLp f) a = L (f a) :=\n  LipschitzWith.coeFn_compLp _ _ _\n\n"}
{"name":"ContinuousLinearMap.coeFn_compLp'","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedAddCommGroup F\nùïú : Type u_5\ninst‚úù¬≤ : NontriviallyNormedField ùïú\ninst‚úù¬π : NormedSpace ùïú E\ninst‚úù : NormedSpace ùïú F\nL : ContinuousLinearMap (RingHom.id ùïú) E F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq ‚Üë‚Üë(L.compLp f) fun a => L (‚Üë‚Üëf a)","decl":"theorem coeFn_compLp' (L : E ‚ÜíL[ùïú] F) (f : Lp E p Œº) : L.compLp f =·µê[Œº] fun a => L (f a) :=\n  L.coeFn_compLp f\n\n"}
{"name":"ContinuousLinearMap.comp_mem‚Ñíp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedAddCommGroup F\nùïú : Type u_5\ninst‚úù¬≤ : NontriviallyNormedField ùïú\ninst‚úù¬π : NormedSpace ùïú E\ninst‚úù : NormedSpace ùïú F\nL : ContinuousLinearMap (RingHom.id ùïú) E F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ MeasureTheory.Mem‚Ñíp (Function.comp ‚áëL ‚Üë‚Üëf) p Œº","decl":"theorem comp_mem‚Ñíp (L : E ‚ÜíL[ùïú] F) (f : Lp E p Œº) : Mem‚Ñíp (L ‚àò f) p Œº :=\n  (Lp.mem‚Ñíp (L.compLp f)).ae_eq (L.coeFn_compLp' f)\n\n"}
{"name":"ContinuousLinearMap.comp_mem‚Ñíp'","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedAddCommGroup F\nùïú : Type u_5\ninst‚úù¬≤ : NontriviallyNormedField ùïú\ninst‚úù¬π : NormedSpace ùïú E\ninst‚úù : NormedSpace ùïú F\nL : ContinuousLinearMap (RingHom.id ùïú) E F\nf : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f p Œº\n‚ä¢ MeasureTheory.Mem‚Ñíp (Function.comp (‚áëL) f) p Œº","decl":"theorem comp_mem‚Ñíp' (L : E ‚ÜíL[ùïú] F) {f : Œ± ‚Üí E} (hf : Mem‚Ñíp f p Œº) : Mem‚Ñíp (L ‚àò f) p Œº :=\n  (L.comp_mem‚Ñíp (hf.toLp f)).ae_eq (EventuallyEq.fun_comp hf.coeFn_toLp _)\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.ofReal","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nK : Type u_6\ninst‚úù : RCLike K\nf : Œ± ‚Üí Real\nhf : MeasureTheory.Mem‚Ñíp f p Œº\n‚ä¢ MeasureTheory.Mem‚Ñíp (fun x => ‚Üë(f x)) p Œº","decl":"theorem _root_.MeasureTheory.Mem‚Ñíp.ofReal {f : Œ± ‚Üí ‚Ñù} (hf : Mem‚Ñíp f p Œº) :\n    Mem‚Ñíp (fun x => (f x : K)) p Œº :=\n  (@RCLike.ofRealCLM K _).comp_mem‚Ñíp' hf\n\n"}
{"name":"MeasureTheory.mem‚Ñíp_re_im_iff","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nK : Type u_6\ninst‚úù : RCLike K\nf : Œ± ‚Üí K\n‚ä¢ Iff (And (MeasureTheory.Mem‚Ñíp (fun x => RCLike.re (f x)) p Œº) (MeasureTheory.Mem‚Ñíp (fun x => RCLike.im (f x)) p Œº)) (MeasureTheory.Mem‚Ñíp f p Œº)","decl":"theorem _root_.MeasureTheory.mem‚Ñíp_re_im_iff {f : Œ± ‚Üí K} :\n    Mem‚Ñíp (fun x ‚Ü¶ RCLike.re (f x)) p Œº ‚àß Mem‚Ñíp (fun x ‚Ü¶ RCLike.im (f x)) p Œº ‚Üî\n      Mem‚Ñíp f p Œº := by\n  refine ‚ü®?_, fun hf => ‚ü®hf.re, hf.im‚ü©‚ü©\n  rintro ‚ü®hre, him‚ü©\n  convert MeasureTheory.Mem‚Ñíp.add (E := K) hre.ofReal (him.ofReal.const_mul RCLike.I)\n  ext1 x\n  rw [Pi.add_apply, mul_comm, RCLike.re_add_im]\n\n"}
{"name":"ContinuousLinearMap.add_compLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedAddCommGroup F\nùïú : Type u_5\ninst‚úù¬≤ : NontriviallyNormedField ùïú\ninst‚úù¬π : NormedSpace ùïú E\ninst‚úù : NormedSpace ùïú F\nL L' : ContinuousLinearMap (RingHom.id ùïú) E F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Eq ((HAdd.hAdd L L').compLp f) (HAdd.hAdd (L.compLp f) (L'.compLp f))","decl":"theorem add_compLp (L L' : E ‚ÜíL[ùïú] F) (f : Lp E p Œº) :\n    (L + L').compLp f = L.compLp f + L'.compLp f := by\n  ext1\n  refine (coeFn_compLp' (L + L') f).trans ?_\n  refine EventuallyEq.trans ?_ (Lp.coeFn_add _ _).symm\n  refine\n    EventuallyEq.trans ?_ (EventuallyEq.add (L.coeFn_compLp' f).symm (L'.coeFn_compLp' f).symm)\n  filter_upwards with x\n  rw [coe_add', Pi.add_def]\n\n"}
{"name":"ContinuousLinearMap.smul_compLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : NormedAddCommGroup F\nùïú : Type u_5\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\ninst‚úù‚Åµ : NormedSpace ùïú E\ninst‚úù‚Å¥ : NormedSpace ùïú F\nùïú' : Type u_6\ninst‚úù¬≥ : NormedRing ùïú'\ninst‚úù¬≤ : Module ùïú' F\ninst‚úù¬π : BoundedSMul ùïú' F\ninst‚úù : SMulCommClass ùïú ùïú' F\nc : ùïú'\nL : ContinuousLinearMap (RingHom.id ùïú) E F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Eq ((HSMul.hSMul c L).compLp f) (HSMul.hSMul c (L.compLp f))","decl":"theorem smul_compLp {ùïú'} [NormedRing ùïú'] [Module ùïú' F] [BoundedSMul ùïú' F] [SMulCommClass ùïú ùïú' F]\n    (c : ùïú') (L : E ‚ÜíL[ùïú] F) (f : Lp E p Œº) : (c ‚Ä¢ L).compLp f = c ‚Ä¢ L.compLp f := by\n  ext1\n  refine (coeFn_compLp' (c ‚Ä¢ L) f).trans ?_\n  refine EventuallyEq.trans ?_ (Lp.coeFn_smul _ _).symm\n  refine (L.coeFn_compLp' f).mono fun x hx => ?_\n  rw [Pi.smul_apply, hx, coe_smul', Pi.smul_def]\n\n"}
{"name":"ContinuousLinearMap.norm_compLp_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedAddCommGroup F\nùïú : Type u_5\ninst‚úù¬≤ : NontriviallyNormedField ùïú\ninst‚úù¬π : NormedSpace ùïú E\ninst‚úù : NormedSpace ùïú F\nL : ContinuousLinearMap (RingHom.id ùïú) E F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ LE.le (Norm.norm (L.compLp f)) (HMul.hMul (Norm.norm L) (Norm.norm f))","decl":"theorem norm_compLp_le (L : E ‚ÜíL[ùïú] F) (f : Lp E p Œº) : ‚ÄñL.compLp f‚Äñ ‚â§ ‚ÄñL‚Äñ * ‚Äñf‚Äñ :=\n  LipschitzWith.norm_compLp_le _ _ _\n\n"}
{"name":"ContinuousLinearMap.coeFn_compLpL","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedAddCommGroup F\nùïú : Type u_5\ninst‚úù¬≥ : NontriviallyNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : Fact (LE.le 1 p)\nL : ContinuousLinearMap (RingHom.id ùïú) E F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq ‚Üë‚Üë((ContinuousLinearMap.compLpL p Œº L) f) fun a => L (‚Üë‚Üëf a)","decl":"theorem coeFn_compLpL [Fact (1 ‚â§ p)] (L : E ‚ÜíL[ùïú] F) (f : Lp E p Œº) :\n    L.compLpL p Œº f =·µê[Œº] fun a => L (f a) :=\n  L.coeFn_compLp f\n\n"}
{"name":"ContinuousLinearMap.add_compLpL","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedAddCommGroup F\nùïú : Type u_5\ninst‚úù¬≥ : NontriviallyNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : Fact (LE.le 1 p)\nL L' : ContinuousLinearMap (RingHom.id ùïú) E F\n‚ä¢ Eq (ContinuousLinearMap.compLpL p Œº (HAdd.hAdd L L')) (HAdd.hAdd (ContinuousLinearMap.compLpL p Œº L) (ContinuousLinearMap.compLpL p Œº L'))","decl":"theorem add_compLpL [Fact (1 ‚â§ p)] (L L' : E ‚ÜíL[ùïú] F) :\n    (L + L').compLpL p Œº = L.compLpL p Œº + L'.compLpL p Œº := by ext1 f; exact add_compLp L L' f\n\n"}
{"name":"ContinuousLinearMap.smul_compLpL","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Åπ : NormedAddCommGroup E\ninst‚úù‚Å∏ : NormedAddCommGroup F\nùïú : Type u_5\ninst‚úù‚Å∑ : NontriviallyNormedField ùïú\ninst‚úù‚Å∂ : NormedSpace ùïú E\ninst‚úù‚Åµ : NormedSpace ùïú F\ninst‚úù‚Å¥ : Fact (LE.le 1 p)\nùïú' : Type u_6\ninst‚úù¬≥ : NormedRing ùïú'\ninst‚úù¬≤ : Module ùïú' F\ninst‚úù¬π : BoundedSMul ùïú' F\ninst‚úù : SMulCommClass ùïú ùïú' F\nc : ùïú'\nL : ContinuousLinearMap (RingHom.id ùïú) E F\n‚ä¢ Eq (ContinuousLinearMap.compLpL p Œº (HSMul.hSMul c L)) (HSMul.hSMul c (ContinuousLinearMap.compLpL p Œº L))","decl":"theorem smul_compLpL [Fact (1 ‚â§ p)] {ùïú'} [NormedRing ùïú'] [Module ùïú' F] [BoundedSMul ùïú' F]\n    [SMulCommClass ùïú ùïú' F] (c : ùïú') (L : E ‚ÜíL[ùïú] F) : (c ‚Ä¢ L).compLpL p Œº = c ‚Ä¢ L.compLpL p Œº := by\n  ext1 f; exact smul_compLp c L f\n\n"}
{"name":"ContinuousLinearMap.norm_compLpL_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedAddCommGroup F\nùïú : Type u_5\ninst‚úù¬≥ : NontriviallyNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : Fact (LE.le 1 p)\nL : ContinuousLinearMap (RingHom.id ùïú) E F\n‚ä¢ LE.le (Norm.norm (ContinuousLinearMap.compLpL p Œº L)) (Norm.norm L)","decl":"theorem norm_compLpL_le [Fact (1 ‚â§ p)] (L : E ‚ÜíL[ùïú] F) : ‚ÄñL.compLpL p Œº‚Äñ ‚â§ ‚ÄñL‚Äñ :=\n  LinearMap.mkContinuous_norm_le _ (norm_nonneg _) _\n\n"}
{"name":"MeasureTheory.indicatorConstLp_eq_toSpanSingleton_compLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nF : Type u_3\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup F\ns : Set Œ±\ninst‚úù : NormedSpace Real F\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nx : F\n‚ä¢ Eq (MeasureTheory.indicatorConstLp 2 hs hŒºs x) ((ContinuousLinearMap.toSpanSingleton Real x).compLp (MeasureTheory.indicatorConstLp 2 hs hŒºs 1))","decl":"theorem indicatorConstLp_eq_toSpanSingleton_compLp {s : Set Œ±} [NormedSpace ‚Ñù F]\n    (hs : MeasurableSet s) (hŒºs : Œº s ‚â† ‚àû) (x : F) :\n    indicatorConstLp 2 hs hŒºs x =\n      (ContinuousLinearMap.toSpanSingleton ‚Ñù x).compLp (indicatorConstLp 2 hs hŒºs (1 : ‚Ñù)) := by\n  ext1\n  refine indicatorConstLp_coeFn.trans ?_\n  have h_compLp :=\n    (ContinuousLinearMap.toSpanSingleton ‚Ñù x).coeFn_compLp (indicatorConstLp 2 hs hŒºs (1 : ‚Ñù))\n  rw [‚Üê EventuallyEq] at h_compLp\n  refine EventuallyEq.trans ?_ h_compLp.symm\n  refine (@indicatorConstLp_coeFn _ _ _ 2 Œº _ s hs hŒºs (1 : ‚Ñù)).mono fun y hy => ?_\n  dsimp only\n  rw [hy]\n  simp_rw [ContinuousLinearMap.toSpanSingleton_apply]\n  by_cases hy_mem : y ‚àà s <;> simp [hy_mem]\n\n"}
{"name":"MeasureTheory.Lp.lipschitzWith_pos_part","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"‚ä¢ LipschitzWith 1 fun x => Max.max x 0","decl":"theorem lipschitzWith_pos_part : LipschitzWith 1 fun x : ‚Ñù => max x 0 :=\n  LipschitzWith.id.max_const _\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.pos_part","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Real\nhf : MeasureTheory.Mem‚Ñíp f p Œº\n‚ä¢ MeasureTheory.Mem‚Ñíp (fun x => Max.max (f x) 0) p Œº","decl":"theorem _root_.MeasureTheory.Mem‚Ñíp.pos_part {f : Œ± ‚Üí ‚Ñù} (hf : Mem‚Ñíp f p Œº) :\n    Mem‚Ñíp (fun x => max (f x) 0) p Œº :=\n  lipschitzWith_pos_part.comp_mem‚Ñíp (max_eq_right le_rfl) hf\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.neg_part","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Real\nhf : MeasureTheory.Mem‚Ñíp f p Œº\n‚ä¢ MeasureTheory.Mem‚Ñíp (fun x => Max.max (Neg.neg (f x)) 0) p Œº","decl":"theorem _root_.MeasureTheory.Mem‚Ñíp.neg_part {f : Œ± ‚Üí ‚Ñù} (hf : Mem‚Ñíp f p Œº) :\n    Mem‚Ñíp (fun x => max (-f x) 0) p Œº :=\n  lipschitzWith_pos_part.comp_mem‚Ñíp (max_eq_right le_rfl) hf.neg\n\n"}
{"name":"MeasureTheory.Lp.coe_posPart","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp Real p Œº) x\n‚ä¢ Eq (‚Üë(MeasureTheory.Lp.posPart f)) (‚Üëf).posPart","decl":"@[norm_cast]\ntheorem coe_posPart (f : Lp ‚Ñù p Œº) : (posPart f : Œ± ‚Üí‚Çò[Œº] ‚Ñù) = (f : Œ± ‚Üí‚Çò[Œº] ‚Ñù).posPart :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.coeFn_posPart","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp Real p Œº) x\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq ‚Üë‚Üë(MeasureTheory.Lp.posPart f) fun a => Max.max (‚Üë‚Üëf a) 0","decl":"theorem coeFn_posPart (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 0 :=\n  AEEqFun.coeFn_posPart _\n\n"}
{"name":"MeasureTheory.Lp.coeFn_negPart_eq_max","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp Real p Œº) x\n‚ä¢ Filter.Eventually (fun a => Eq (‚Üë‚Üë(MeasureTheory.Lp.negPart f) a) (Max.max (Neg.neg (‚Üë‚Üëf a)) 0)) (MeasureTheory.ae Œº)","decl":"theorem coeFn_negPart_eq_max (f : Lp ‚Ñù p Œº) : ‚àÄ·µê a ‚àÇŒº, negPart f a = max (-f a) 0 := by\n  rw [negPart]\n  filter_upwards [coeFn_posPart (-f), coeFn_neg f] with _ h‚ÇÅ h‚ÇÇ\n  rw [h‚ÇÅ, h‚ÇÇ, Pi.neg_apply]\n\n"}
{"name":"MeasureTheory.Lp.coeFn_negPart","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp Real p Œº) x\n‚ä¢ Filter.Eventually (fun a => Eq (‚Üë‚Üë(MeasureTheory.Lp.negPart f) a) (Neg.neg (Min.min (‚Üë‚Üëf a) 0))) (MeasureTheory.ae Œº)","decl":"theorem coeFn_negPart (f : Lp ‚Ñù p Œº) : ‚àÄ·µê a ‚àÇŒº, negPart f a = -min (f a) 0 :=\n  (coeFn_negPart_eq_max f).mono fun a h => by rw [h, ‚Üê max_neg_neg, neg_zero]\n\n"}
{"name":"MeasureTheory.Lp.continuous_posPart","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : Fact (LE.le 1 p)\n‚ä¢ Continuous fun f => MeasureTheory.Lp.posPart f","decl":"theorem continuous_posPart [Fact (1 ‚â§ p)] : Continuous fun f : Lp ‚Ñù p Œº => posPart f :=\n  LipschitzWith.continuous_compLp _ _\n\n"}
{"name":"MeasureTheory.Lp.continuous_negPart","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : Fact (LE.le 1 p)\n‚ä¢ Continuous fun f => MeasureTheory.Lp.negPart f","decl":"theorem continuous_negPart [Fact (1 ‚â§ p)] : Continuous fun f : Lp ‚Ñù p Œº => negPart f := by\n  unfold negPart\n  exact continuous_posPart.comp continuous_neg\n\n"}
{"name":"MeasureTheory.Lp.eLpNorm'_lim_eq_lintegral_liminf","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nG : Type u_4\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : NormedAddCommGroup G\nŒπ : Type u_5\ninst‚úù¬π : Nonempty Œπ\ninst‚úù : LinearOrder Œπ\nf : Œπ ‚Üí Œ± ‚Üí G\np : Real\nf_lim : Œ± ‚Üí G\nh_lim : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (f_lim x))) (MeasureTheory.ae Œº)\n‚ä¢ Eq (MeasureTheory.eLpNorm' f_lim p Œº) (HPow.hPow (MeasureTheory.lintegral Œº fun a => Filter.liminf (fun x => HPow.hPow (ENorm.enorm (f x a)) p) Filter.atTop) (HDiv.hDiv 1 p))","decl":"theorem eLpNorm'_lim_eq_lintegral_liminf {Œπ} [Nonempty Œπ] [LinearOrder Œπ] {f : Œπ ‚Üí Œ± ‚Üí G} {p : ‚Ñù}\n    {f_lim : Œ± ‚Üí G} (h_lim : ‚àÄ·µê x : Œ± ‚àÇŒº, Tendsto (fun n => f n x) atTop (ùìù (f_lim x))) :\n    eLpNorm' f_lim p Œº = (‚à´‚Åª a, atTop.liminf (‚Äñf ¬∑ a‚Äñ‚Çë ^ p) ‚àÇŒº) ^ (1 / p) := by\n  suffices h_no_pow : (‚à´‚Åª a, ‚Äñf_lim a‚Äñ‚Çë ^ p ‚àÇŒº) = ‚à´‚Åª a, atTop.liminf fun m => ‚Äñf m a‚Äñ‚Çë ^ p ‚àÇŒº by\n    rw [eLpNorm'_eq_lintegral_enorm, h_no_pow]\n  refine lintegral_congr_ae (h_lim.mono fun a ha => ?_)\n  dsimp only\n  rw [Tendsto.liminf_eq]\n  refine (ENNReal.continuous_rpow_const.tendsto ‚Äñf_lim a‚Äñ‚Çä).comp ?_\n  exact (continuous_enorm.tendsto (f_lim a)).comp ha\n\n"}
{"name":"MeasureTheory.Lp.eLpNorm'_lim_le_liminf_eLpNorm'","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nE : Type u_5\ninst‚úù : NormedAddCommGroup E\nf : Nat ‚Üí Œ± ‚Üí E\np : Real\nhp_pos : LT.lt 0 p\nhf : ‚àÄ (n : Nat), MeasureTheory.AEStronglyMeasurable (f n) Œº\nf_lim : Œ± ‚Üí E\nh_lim : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (f_lim x))) (MeasureTheory.ae Œº)\n‚ä¢ LE.le (MeasureTheory.eLpNorm' f_lim p Œº) (Filter.liminf (fun n => MeasureTheory.eLpNorm' (f n) p Œº) Filter.atTop)","decl":"theorem eLpNorm'_lim_le_liminf_eLpNorm' {E} [NormedAddCommGroup E] {f : ‚Ñï ‚Üí Œ± ‚Üí E} {p : ‚Ñù}\n    (hp_pos : 0 < p) (hf : ‚àÄ n, AEStronglyMeasurable (f n) Œº) {f_lim : Œ± ‚Üí E}\n    (h_lim : ‚àÄ·µê x : Œ± ‚àÇŒº, Tendsto (fun n => f n x) atTop (ùìù (f_lim x))) :\n    eLpNorm' f_lim p Œº ‚â§ atTop.liminf fun n => eLpNorm' (f n) p Œº := by\n  rw [eLpNorm'_lim_eq_lintegral_liminf h_lim]\n  rw [one_div, ‚Üê ENNReal.le_rpow_inv_iff (by simp [hp_pos] : 0 < p‚Åª¬π), inv_inv]\n  refine (lintegral_liminf_le' fun m => (hf m).enorm.pow_const _).trans_eq ?_\n  have h_pow_liminf :\n    atTop.liminf (fun n ‚Ü¶ eLpNorm' (f n) p Œº) ^ p\n      = atTop.liminf fun n ‚Ü¶ eLpNorm' (f n) p Œº ^ p := by\n    have h_rpow_mono := ENNReal.strictMono_rpow_of_pos hp_pos\n    have h_rpow_surj := (ENNReal.rpow_left_bijective hp_pos.ne.symm).2\n    refine (h_rpow_mono.orderIsoOfSurjective _ h_rpow_surj).liminf_apply ?_ ?_ ?_ ?_\n    all_goals isBoundedDefault\n  rw [h_pow_liminf]\n  simp_rw [eLpNorm'_eq_lintegral_enorm, ‚Üê ENNReal.rpow_mul, one_div,\n    inv_mul_cancel‚ÇÄ hp_pos.ne.symm, ENNReal.rpow_one]\n\n"}
{"name":"MeasureTheory.Lp.eLpNorm_exponent_top_lim_eq_essSup_liminf","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nG : Type u_4\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : NormedAddCommGroup G\nŒπ : Type u_5\ninst‚úù¬π : Nonempty Œπ\ninst‚úù : LinearOrder Œπ\nf : Œπ ‚Üí Œ± ‚Üí G\nf_lim : Œ± ‚Üí G\nh_lim : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (f_lim x))) (MeasureTheory.ae Œº)\n‚ä¢ Eq (MeasureTheory.eLpNorm f_lim Top.top Œº) (essSup (fun x => Filter.liminf (fun m => ENorm.enorm (f m x)) Filter.atTop) Œº)","decl":"theorem eLpNorm_exponent_top_lim_eq_essSup_liminf {Œπ} [Nonempty Œπ] [LinearOrder Œπ] {f : Œπ ‚Üí Œ± ‚Üí G}\n    {f_lim : Œ± ‚Üí G} (h_lim : ‚àÄ·µê x : Œ± ‚àÇŒº, Tendsto (fun n => f n x) atTop (ùìù (f_lim x))) :\n    eLpNorm f_lim ‚àû Œº = essSup (fun x => atTop.liminf fun m => ‚Äñf m x‚Äñ‚Çë) Œº := by\n  rw [eLpNorm_exponent_top, eLpNormEssSup_eq_essSup_enorm]\n  refine essSup_congr_ae (h_lim.mono fun x hx => ?_)\n  dsimp only\n  apply (Tendsto.liminf_eq ..).symm\n  exact (continuous_enorm.tendsto (f_lim x)).comp hx\n\n"}
{"name":"MeasureTheory.Lp.eLpNorm_exponent_top_lim_le_liminf_eLpNorm_exponent_top","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nF : Type u_3\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : NormedAddCommGroup F\nŒπ : Type u_5\ninst‚úù¬≤ : Nonempty Œπ\ninst‚úù¬π : Countable Œπ\ninst‚úù : LinearOrder Œπ\nf : Œπ ‚Üí Œ± ‚Üí F\nf_lim : Œ± ‚Üí F\nh_lim : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (f_lim x))) (MeasureTheory.ae Œº)\n‚ä¢ LE.le (MeasureTheory.eLpNorm f_lim Top.top Œº) (Filter.liminf (fun n => MeasureTheory.eLpNorm (f n) Top.top Œº) Filter.atTop)","decl":"theorem eLpNorm_exponent_top_lim_le_liminf_eLpNorm_exponent_top {Œπ} [Nonempty Œπ] [Countable Œπ]\n    [LinearOrder Œπ] {f : Œπ ‚Üí Œ± ‚Üí F} {f_lim : Œ± ‚Üí F}\n    (h_lim : ‚àÄ·µê x : Œ± ‚àÇŒº, Tendsto (fun n => f n x) atTop (ùìù (f_lim x))) :\n    eLpNorm f_lim ‚àû Œº ‚â§ atTop.liminf fun n => eLpNorm (f n) ‚àû Œº := by\n  rw [eLpNorm_exponent_top_lim_eq_essSup_liminf h_lim]\n  simp_rw [eLpNorm_exponent_top, eLpNormEssSup]\n  exact ENNReal.essSup_liminf_le _\n\n"}
{"name":"MeasureTheory.Lp.eLpNorm_lim_le_liminf_eLpNorm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nE : Type u_5\ninst‚úù : NormedAddCommGroup E\nf : Nat ‚Üí Œ± ‚Üí E\nhf : ‚àÄ (n : Nat), MeasureTheory.AEStronglyMeasurable (f n) Œº\nf_lim : Œ± ‚Üí E\nh_lim : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (f_lim x))) (MeasureTheory.ae Œº)\n‚ä¢ LE.le (MeasureTheory.eLpNorm f_lim p Œº) (Filter.liminf (fun n => MeasureTheory.eLpNorm (f n) p Œº) Filter.atTop)","decl":"theorem eLpNorm_lim_le_liminf_eLpNorm {E} [NormedAddCommGroup E] {f : ‚Ñï ‚Üí Œ± ‚Üí E}\n    (hf : ‚àÄ n, AEStronglyMeasurable (f n) Œº) (f_lim : Œ± ‚Üí E)\n    (h_lim : ‚àÄ·µê x : Œ± ‚àÇŒº, Tendsto (fun n => f n x) atTop (ùìù (f_lim x))) :\n    eLpNorm f_lim p Œº ‚â§ atTop.liminf fun n => eLpNorm (f n) p Œº := by\n  obtain rfl|hp0 := eq_or_ne p 0\n  ¬∑ simp\n  by_cases hp_top : p = ‚àû\n  ¬∑ simp_rw [hp_top]\n    exact eLpNorm_exponent_top_lim_le_liminf_eLpNorm_exponent_top h_lim\n  simp_rw [eLpNorm_eq_eLpNorm' hp0 hp_top]\n  have hp_pos : 0 < p.toReal := ENNReal.toReal_pos hp0 hp_top\n  exact eLpNorm'_lim_le_liminf_eLpNorm' hp_pos hf h_lim\n\n"}
{"name":"MeasureTheory.Lp.tendsto_Lp_iff_tendsto_‚Ñíp'","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\nŒπ : Type u_5\nfi : Filter Œπ\ninst‚úù : Fact (LE.le 1 p)\nf : Œπ ‚Üí Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\nf_lim : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Iff (Filter.Tendsto f fi (nhds f_lim)) (Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub ‚Üë‚Üë(f n) ‚Üë‚Üëf_lim) p Œº) fi (nhds 0))","decl":"theorem tendsto_Lp_iff_tendsto_‚Ñíp' {Œπ} {fi : Filter Œπ} [Fact (1 ‚â§ p)] (f : Œπ ‚Üí Lp E p Œº)\n    (f_lim : Lp E p Œº) :\n    fi.Tendsto f (ùìù f_lim) ‚Üî fi.Tendsto (fun n => eLpNorm (‚áë(f n) - ‚áëf_lim) p Œº) (ùìù 0) := by\n  rw [tendsto_iff_dist_tendsto_zero]\n  simp_rw [dist_def]\n  rw [‚Üê ENNReal.zero_toReal, ENNReal.tendsto_toReal_iff (fun n => ?_) ENNReal.zero_ne_top]\n  rw [eLpNorm_congr_ae (Lp.coeFn_sub _ _).symm]\n  exact Lp.eLpNorm_ne_top _\n\n"}
{"name":"MeasureTheory.Lp.tendsto_Lp_iff_tendsto_‚Ñíp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\nŒπ : Type u_5\nfi : Filter Œπ\ninst‚úù : Fact (LE.le 1 p)\nf : Œπ ‚Üí Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\nf_lim : Œ± ‚Üí E\nf_lim_‚Ñíp : MeasureTheory.Mem‚Ñíp f_lim p Œº\n‚ä¢ Iff (Filter.Tendsto f fi (nhds (MeasureTheory.Mem‚Ñíp.toLp f_lim f_lim_‚Ñíp))) (Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (‚Üë‚Üë(f n)) f_lim) p Œº) fi (nhds 0))","decl":"theorem tendsto_Lp_iff_tendsto_‚Ñíp {Œπ} {fi : Filter Œπ} [Fact (1 ‚â§ p)] (f : Œπ ‚Üí Lp E p Œº)\n    (f_lim : Œ± ‚Üí E) (f_lim_‚Ñíp : Mem‚Ñíp f_lim p Œº) :\n    fi.Tendsto f (ùìù (f_lim_‚Ñíp.toLp f_lim)) ‚Üî\n      fi.Tendsto (fun n => eLpNorm (‚áë(f n) - f_lim) p Œº) (ùìù 0) := by\n  rw [tendsto_Lp_iff_tendsto_‚Ñíp']\n  suffices h_eq :\n      (fun n => eLpNorm (‚áë(f n) - ‚áë(Mem‚Ñíp.toLp f_lim f_lim_‚Ñíp)) p Œº) =\n        (fun n => eLpNorm (‚áë(f n) - f_lim) p Œº) by\n    rw [h_eq]\n  exact funext fun n => eLpNorm_congr_ae (EventuallyEq.rfl.sub (Mem‚Ñíp.coeFn_toLp f_lim_‚Ñíp))\n\n"}
{"name":"MeasureTheory.Lp.tendsto_Lp_iff_tendsto_‚Ñíp''","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\nŒπ : Type u_5\nfi : Filter Œπ\ninst‚úù : Fact (LE.le 1 p)\nf : Œπ ‚Üí Œ± ‚Üí E\nf_‚Ñíp : ‚àÄ (n : Œπ), MeasureTheory.Mem‚Ñíp (f n) p Œº\nf_lim : Œ± ‚Üí E\nf_lim_‚Ñíp : MeasureTheory.Mem‚Ñíp f_lim p Œº\n‚ä¢ Iff (Filter.Tendsto (fun n => MeasureTheory.Mem‚Ñíp.toLp (f n) ‚ãØ) fi (nhds (MeasureTheory.Mem‚Ñíp.toLp f_lim f_lim_‚Ñíp))) (Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) f_lim) p Œº) fi (nhds 0))","decl":"theorem tendsto_Lp_iff_tendsto_‚Ñíp'' {Œπ} {fi : Filter Œπ} [Fact (1 ‚â§ p)] (f : Œπ ‚Üí Œ± ‚Üí E)\n    (f_‚Ñíp : ‚àÄ n, Mem‚Ñíp (f n) p Œº) (f_lim : Œ± ‚Üí E) (f_lim_‚Ñíp : Mem‚Ñíp f_lim p Œº) :\n    fi.Tendsto (fun n => (f_‚Ñíp n).toLp (f n)) (ùìù (f_lim_‚Ñíp.toLp f_lim)) ‚Üî\n      fi.Tendsto (fun n => eLpNorm (f n - f_lim) p Œº) (ùìù 0) := by\n  rw [Lp.tendsto_Lp_iff_tendsto_‚Ñíp' (fun n => (f_‚Ñíp n).toLp (f n)) (f_lim_‚Ñíp.toLp f_lim)]\n  refine Filter.tendsto_congr fun n => ?_\n  apply eLpNorm_congr_ae\n  filter_upwards [((f_‚Ñíp n).sub f_lim_‚Ñíp).coeFn_toLp,\n    Lp.coeFn_sub ((f_‚Ñíp n).toLp (f n)) (f_lim_‚Ñíp.toLp f_lim)] with _ hx‚ÇÅ hx‚ÇÇ\n  rw [‚Üê hx‚ÇÇ]\n  exact hx‚ÇÅ\n\n"}
{"name":"MeasureTheory.Lp.tendsto_Lp_of_tendsto_‚Ñíp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\nŒπ : Type u_5\nfi : Filter Œπ\ninst‚úù : Fact (LE.le 1 p)\nf : Œπ ‚Üí Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\nf_lim : Œ± ‚Üí E\nf_lim_‚Ñíp : MeasureTheory.Mem‚Ñíp f_lim p Œº\nh_tendsto : Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (‚Üë‚Üë(f n)) f_lim) p Œº) fi (nhds 0)\n‚ä¢ Filter.Tendsto f fi (nhds (MeasureTheory.Mem‚Ñíp.toLp f_lim f_lim_‚Ñíp))","decl":"theorem tendsto_Lp_of_tendsto_‚Ñíp {Œπ} {fi : Filter Œπ} [Fact (1 ‚â§ p)] {f : Œπ ‚Üí Lp E p Œº}\n    (f_lim : Œ± ‚Üí E) (f_lim_‚Ñíp : Mem‚Ñíp f_lim p Œº)\n    (h_tendsto : fi.Tendsto (fun n => eLpNorm (‚áë(f n) - f_lim) p Œº) (ùìù 0)) :\n    fi.Tendsto f (ùìù (f_lim_‚Ñíp.toLp f_lim)) :=\n  (tendsto_Lp_iff_tendsto_‚Ñíp f f_lim f_lim_‚Ñíp).mpr h_tendsto\n\n"}
{"name":"MeasureTheory.Lp.cauchySeq_Lp_iff_cauchySeq_‚Ñíp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : NormedAddCommGroup E\nŒπ : Type u_5\ninst‚úù¬π : Nonempty Œπ\ninst‚úù : SemilatticeSup Œπ\nhp : Fact (LE.le 1 p)\nf : Œπ ‚Üí Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Iff (CauchySeq f) (Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub ‚Üë‚Üë(f n.1) ‚Üë‚Üë(f n.2)) p Œº) Filter.atTop (nhds 0))","decl":"theorem cauchySeq_Lp_iff_cauchySeq_‚Ñíp {Œπ} [Nonempty Œπ] [SemilatticeSup Œπ] [hp : Fact (1 ‚â§ p)]\n    (f : Œπ ‚Üí Lp E p Œº) :\n    CauchySeq f ‚Üî Tendsto (fun n : Œπ √ó Œπ => eLpNorm (‚áë(f n.fst) - ‚áë(f n.snd)) p Œº) atTop (ùìù 0) := by\n  simp_rw [cauchySeq_iff_tendsto_dist_atTop_0, dist_def]\n  rw [‚Üê ENNReal.zero_toReal, ENNReal.tendsto_toReal_iff (fun n => ?_) ENNReal.zero_ne_top]\n  rw [eLpNorm_congr_ae (Lp.coeFn_sub _ _).symm]\n  exact eLpNorm_ne_top _\n\n"}
{"name":"MeasureTheory.Lp.completeSpace_lp_of_cauchy_complete_‚Ñíp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nhp : Fact (LE.le 1 p)\nH : ‚àÄ (f : Nat ‚Üí Œ± ‚Üí E), (‚àÄ (n : Nat), MeasureTheory.Mem‚Ñíp (f n) p Œº) ‚Üí ‚àÄ (B : Nat ‚Üí ENNReal), LT.lt (tsum fun i => B i) Top.top ‚Üí (‚àÄ (N n m : Nat), LE.le N n ‚Üí LE.le N m ‚Üí LT.lt (MeasureTheory.eLpNorm (HSub.hSub (f n) (f m)) p Œº) (B N)) ‚Üí Exists fun f_lim => And (MeasureTheory.Mem‚Ñíp f_lim p Œº) (Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) f_lim) p Œº) Filter.atTop (nhds 0))\n‚ä¢ CompleteSpace (Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x)","decl":"theorem completeSpace_lp_of_cauchy_complete_‚Ñíp [hp : Fact (1 ‚â§ p)]\n    (H :\n      ‚àÄ (f : ‚Ñï ‚Üí Œ± ‚Üí E) (_ : ‚àÄ n, Mem‚Ñíp (f n) p Œº) (B : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû) (_ : ‚àë' i, B i < ‚àû)\n        (_ : ‚àÄ N n m : ‚Ñï, N ‚â§ n ‚Üí N ‚â§ m ‚Üí eLpNorm (f n - f m) p Œº < B N),\n        ‚àÉ (f_lim : Œ± ‚Üí E), Mem‚Ñíp f_lim p Œº ‚àß\n          atTop.Tendsto (fun n => eLpNorm (f n - f_lim) p Œº) (ùìù 0)) :\n    CompleteSpace (Lp E p Œº) := by\n  let B := fun n : ‚Ñï => ((1 : ‚Ñù) / 2) ^ n\n  have hB_pos : ‚àÄ n, 0 < B n := fun n => pow_pos (div_pos zero_lt_one zero_lt_two) n\n  refine Metric.complete_of_convergent_controlled_sequences B hB_pos fun f hf => ?_\n  rsuffices ‚ü®f_lim, hf_lim_meas, h_tendsto‚ü© :\n    ‚àÉ (f_lim : Œ± ‚Üí E), Mem‚Ñíp f_lim p Œº ‚àß\n      atTop.Tendsto (fun n => eLpNorm (‚áë(f n) - f_lim) p Œº) (ùìù 0)\n  ¬∑ exact ‚ü®hf_lim_meas.toLp f_lim, tendsto_Lp_of_tendsto_‚Ñíp f_lim hf_lim_meas h_tendsto‚ü©\n  obtain ‚ü®M, hB‚ü© : Summable B := summable_geometric_two\n  let B1 n := ENNReal.ofReal (B n)\n  have hB1_has : HasSum B1 (ENNReal.ofReal M) := by\n    have h_tsum_B1 : ‚àë' i, B1 i = ENNReal.ofReal M := by\n      change (‚àë' n : ‚Ñï, ENNReal.ofReal (B n)) = ENNReal.ofReal M\n      rw [‚Üê hB.tsum_eq]\n      exact (ENNReal.ofReal_tsum_of_nonneg (fun n => le_of_lt (hB_pos n)) hB.summable).symm\n    have h_sum := (@ENNReal.summable _ B1).hasSum\n    rwa [h_tsum_B1] at h_sum\n  have hB1 : ‚àë' i, B1 i < ‚àû := by\n    rw [hB1_has.tsum_eq]\n    exact ENNReal.ofReal_lt_top\n  let f1 : ‚Ñï ‚Üí Œ± ‚Üí E := fun n => f n\n  refine H f1 (fun n => Lp.mem‚Ñíp (f n)) B1 hB1 fun N n m hn hm => ?_\n  specialize hf N n m hn hm\n  rw [dist_def] at hf\n  dsimp only [f1]\n  rwa [ENNReal.lt_ofReal_iff_toReal_lt]\n  rw [eLpNorm_congr_ae (Lp.coeFn_sub _ _).symm]\n  exact Lp.eLpNorm_ne_top _\n\n"}
{"name":"MeasureTheory.Lp.ae_tendsto_of_cauchy_eLpNorm'","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : CompleteSpace E\nf : Nat ‚Üí Œ± ‚Üí E\np : Real\nhf : ‚àÄ (n : Nat), MeasureTheory.AEStronglyMeasurable (f n) Œº\nhp1 : LE.le 1 p\nB : Nat ‚Üí ENNReal\nhB : Ne (tsum fun i => B i) Top.top\nh_cau : ‚àÄ (N n m : Nat), LE.le N n ‚Üí LE.le N m ‚Üí LT.lt (MeasureTheory.eLpNorm' (HSub.hSub (f n) (f m)) p Œº) (B N)\n‚ä¢ Filter.Eventually (fun x => Exists fun l => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds l)) (MeasureTheory.ae Œº)","decl":"theorem ae_tendsto_of_cauchy_eLpNorm' [CompleteSpace E] {f : ‚Ñï ‚Üí Œ± ‚Üí E} {p : ‚Ñù}\n    (hf : ‚àÄ n, AEStronglyMeasurable (f n) Œº) (hp1 : 1 ‚â§ p) {B : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû} (hB : ‚àë' i, B i ‚â† ‚àû)\n    (h_cau : ‚àÄ N n m : ‚Ñï, N ‚â§ n ‚Üí N ‚â§ m ‚Üí eLpNorm' (f n - f m) p Œº < B N) :\n    ‚àÄ·µê x ‚àÇŒº, ‚àÉ l : E, atTop.Tendsto (fun n => f n x) (ùìù l) := by\n  have h_summable : ‚àÄ·µê x ‚àÇŒº, Summable fun i : ‚Ñï => f (i + 1) x - f i x := by\n    have h1 :\n      ‚àÄ n, eLpNorm' (fun x => ‚àë i ‚àà Finset.range (n + 1), ‚Äñf (i + 1) x - f i x‚Äñ) p Œº ‚â§ ‚àë' i, B i :=\n      eLpNorm'_sum_norm_sub_le_tsum_of_cauchy_eLpNorm' hf hp1 h_cau\n    have h2 n :\n        ‚à´‚Åª a, (‚àë i ‚àà Finset.range (n + 1), ‚Äñf (i + 1) a - f i a‚Äñ‚Çë) ^ p ‚àÇŒº ‚â§ (‚àë' i, B i) ^ p :=\n      lintegral_rpow_sum_enorm_sub_le_rpow_tsum hp1 n (h1 n)\n    have h3 : (‚à´‚Åª a, (‚àë' i, ‚Äñf (i + 1) a - f i a‚Äñ‚Çë) ^ p ‚àÇŒº) ^ (1 / p) ‚â§ ‚àë' i, B i :=\n      lintegral_rpow_tsum_coe_enorm_sub_le_tsum hf hp1 h2\n    have h4 : ‚àÄ·µê x ‚àÇŒº, ‚àë' i, ‚Äñf (i + 1) x - f i x‚Äñ‚Çë < ‚àû :=\n      tsum_enorm_sub_ae_lt_top hf hp1 hB h3\n    exact h4.mono fun x hx => .of_nnnorm <| ENNReal.tsum_coe_ne_top_iff_summable.mp hx.ne\n  have h :\n    ‚àÄ·µê x ‚àÇŒº, ‚àÉ l : E,\n      atTop.Tendsto (fun n => ‚àë i ‚àà Finset.range n, (f (i + 1) x - f i x)) (ùìù l) := by\n    refine h_summable.mono fun x hx => ?_\n    let hx_sum := hx.hasSum.tendsto_sum_nat\n    exact ‚ü®‚àë' i, (f (i + 1) x - f i x), hx_sum‚ü©\n  refine h.mono fun x hx => ?_\n  cases' hx with l hx\n  have h_rw_sum :\n      (fun n => ‚àë i ‚àà Finset.range n, (f (i + 1) x - f i x)) = fun n => f n x - f 0 x := by\n    ext1 n\n    change\n      (‚àë i ‚àà Finset.range n, ((fun m => f m x) (i + 1) - (fun m => f m x) i)) = f n x - f 0 x\n    rw [Finset.sum_range_sub (fun m => f m x)]\n  rw [h_rw_sum] at hx\n  have hf_rw : (fun n => f n x) = fun n => f n x - f 0 x + f 0 x := by\n    ext1 n\n    abel\n  rw [hf_rw]\n  exact ‚ü®l + f 0 x, Tendsto.add_const _ hx‚ü©\n\n"}
{"name":"MeasureTheory.Lp.ae_tendsto_of_cauchy_eLpNorm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : CompleteSpace E\nf : Nat ‚Üí Œ± ‚Üí E\nhf : ‚àÄ (n : Nat), MeasureTheory.AEStronglyMeasurable (f n) Œº\nhp : LE.le 1 p\nB : Nat ‚Üí ENNReal\nhB : Ne (tsum fun i => B i) Top.top\nh_cau : ‚àÄ (N n m : Nat), LE.le N n ‚Üí LE.le N m ‚Üí LT.lt (MeasureTheory.eLpNorm (HSub.hSub (f n) (f m)) p Œº) (B N)\n‚ä¢ Filter.Eventually (fun x => Exists fun l => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds l)) (MeasureTheory.ae Œº)","decl":"theorem ae_tendsto_of_cauchy_eLpNorm [CompleteSpace E] {f : ‚Ñï ‚Üí Œ± ‚Üí E}\n    (hf : ‚àÄ n, AEStronglyMeasurable (f n) Œº) (hp : 1 ‚â§ p) {B : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû} (hB : ‚àë' i, B i ‚â† ‚àû)\n    (h_cau : ‚àÄ N n m : ‚Ñï, N ‚â§ n ‚Üí N ‚â§ m ‚Üí eLpNorm (f n - f m) p Œº < B N) :\n    ‚àÄ·µê x ‚àÇŒº, ‚àÉ l : E, atTop.Tendsto (fun n => f n x) (ùìù l) := by\n  by_cases hp_top : p = ‚àû\n  ¬∑ simp_rw [hp_top] at *\n    have h_cau_ae : ‚àÄ·µê x ‚àÇŒº, ‚àÄ N n m, N ‚â§ n ‚Üí N ‚â§ m ‚Üí ‚Äñ(f n - f m) x‚Äñ‚Çë < B N := by\n      simp_rw [ae_all_iff]\n      exact fun N n m hnN hmN => ae_lt_of_essSup_lt (h_cau N n m hnN hmN)\n    simp_rw [eLpNorm_exponent_top, eLpNormEssSup] at h_cau\n    refine h_cau_ae.mono fun x hx => cauchySeq_tendsto_of_complete ?_\n    refine cauchySeq_of_le_tendsto_0 (fun n => (B n).toReal) ?_ ?_\n    ¬∑ intro n m N hnN hmN\n      specialize hx N n m hnN hmN\n      rw [_root_.dist_eq_norm,\n        ‚Üê ENNReal.ofReal_le_iff_le_toReal (ENNReal.ne_top_of_tsum_ne_top hB N),\n        ofReal_norm_eq_enorm]\n      exact hx.le\n    ¬∑ rw [‚Üê ENNReal.zero_toReal]\n      exact\n        Tendsto.comp (g := ENNReal.toReal) (ENNReal.tendsto_toReal ENNReal.zero_ne_top)\n          (ENNReal.tendsto_atTop_zero_of_tsum_ne_top hB)\n  have hp1 : 1 ‚â§ p.toReal := by\n    rw [‚Üê ENNReal.ofReal_le_iff_le_toReal hp_top, ENNReal.ofReal_one]\n    exact hp\n  have h_cau' : ‚àÄ N n m : ‚Ñï, N ‚â§ n ‚Üí N ‚â§ m ‚Üí eLpNorm' (f n - f m) p.toReal Œº < B N := by\n    intro N n m hn hm\n    specialize h_cau N n m hn hm\n    rwa [eLpNorm_eq_eLpNorm' (zero_lt_one.trans_le hp).ne.symm hp_top] at h_cau\n  exact ae_tendsto_of_cauchy_eLpNorm' hf hp1 hB h_cau'\n\n"}
{"name":"MeasureTheory.Lp.cauchy_tendsto_of_tendsto","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Nat ‚Üí Œ± ‚Üí E\nhf : ‚àÄ (n : Nat), MeasureTheory.AEStronglyMeasurable (f n) Œº\nf_lim : Œ± ‚Üí E\nB : Nat ‚Üí ENNReal\nhB : Ne (tsum fun i => B i) Top.top\nh_cau : ‚àÄ (N n m : Nat), LE.le N n ‚Üí LE.le N m ‚Üí LT.lt (MeasureTheory.eLpNorm (HSub.hSub (f n) (f m)) p Œº) (B N)\nh_lim : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (f_lim x))) (MeasureTheory.ae Œº)\n‚ä¢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) f_lim) p Œº) Filter.atTop (nhds 0)","decl":"theorem cauchy_tendsto_of_tendsto {f : ‚Ñï ‚Üí Œ± ‚Üí E} (hf : ‚àÄ n, AEStronglyMeasurable (f n) Œº)\n    (f_lim : Œ± ‚Üí E) {B : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû} (hB : ‚àë' i, B i ‚â† ‚àû)\n    (h_cau : ‚àÄ N n m : ‚Ñï, N ‚â§ n ‚Üí N ‚â§ m ‚Üí eLpNorm (f n - f m) p Œº < B N)\n    (h_lim : ‚àÄ·µê x : Œ± ‚àÇŒº, Tendsto (fun n => f n x) atTop (ùìù (f_lim x))) :\n    atTop.Tendsto (fun n => eLpNorm (f n - f_lim) p Œº) (ùìù 0) := by\n  rw [ENNReal.tendsto_atTop_zero]\n  intro Œµ hŒµ\n  have h_B : ‚àÉ N : ‚Ñï, B N ‚â§ Œµ := by\n    suffices h_tendsto_zero : ‚àÉ N : ‚Ñï, ‚àÄ n : ‚Ñï, N ‚â§ n ‚Üí B n ‚â§ Œµ from\n      ‚ü®h_tendsto_zero.choose, h_tendsto_zero.choose_spec _ le_rfl‚ü©\n    exact (ENNReal.tendsto_atTop_zero.mp (ENNReal.tendsto_atTop_zero_of_tsum_ne_top hB)) Œµ hŒµ\n  cases' h_B with N h_B\n  refine ‚ü®N, fun n hn => ?_‚ü©\n  have h_sub : eLpNorm (f n - f_lim) p Œº ‚â§ atTop.liminf fun m => eLpNorm (f n - f m) p Œº := by\n    refine eLpNorm_lim_le_liminf_eLpNorm (fun m => (hf n).sub (hf m)) (f n - f_lim) ?_\n    refine h_lim.mono fun x hx => ?_\n    simp_rw [sub_eq_add_neg]\n    exact Tendsto.add tendsto_const_nhds (Tendsto.neg hx)\n  refine h_sub.trans ?_\n  refine liminf_le_of_frequently_le' (frequently_atTop.mpr ?_)\n  refine fun N1 => ‚ü®max N N1, le_max_right _ _, ?_‚ü©\n  exact (h_cau N n (max N N1) hn (le_max_left _ _)).le.trans h_B\n\n"}
{"name":"MeasureTheory.Lp.mem‚Ñíp_of_cauchy_tendsto","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nhp : LE.le 1 p\nf : Nat ‚Üí Œ± ‚Üí E\nhf : ‚àÄ (n : Nat), MeasureTheory.Mem‚Ñíp (f n) p Œº\nf_lim : Œ± ‚Üí E\nh_lim_meas : MeasureTheory.AEStronglyMeasurable f_lim Œº\nh_tendsto : Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) f_lim) p Œº) Filter.atTop (nhds 0)\n‚ä¢ MeasureTheory.Mem‚Ñíp f_lim p Œº","decl":"theorem mem‚Ñíp_of_cauchy_tendsto (hp : 1 ‚â§ p) {f : ‚Ñï ‚Üí Œ± ‚Üí E} (hf : ‚àÄ n, Mem‚Ñíp (f n) p Œº)\n    (f_lim : Œ± ‚Üí E) (h_lim_meas : AEStronglyMeasurable f_lim Œº)\n    (h_tendsto : atTop.Tendsto (fun n => eLpNorm (f n - f_lim) p Œº) (ùìù 0)) : Mem‚Ñíp f_lim p Œº := by\n  refine ‚ü®h_lim_meas, ?_‚ü©\n  rw [ENNReal.tendsto_atTop_zero] at h_tendsto\n  cases' h_tendsto 1 zero_lt_one with N h_tendsto_1\n  specialize h_tendsto_1 N (le_refl N)\n  have h_add : f_lim = f_lim - f N + f N := by abel\n  rw [h_add]\n  refine lt_of_le_of_lt (eLpNorm_add_le (h_lim_meas.sub (hf N).1) (hf N).1 hp) ?_\n  rw [ENNReal.add_lt_top]\n  constructor\n  ¬∑ refine lt_of_le_of_lt ?_ ENNReal.one_lt_top\n    have h_neg : f_lim - f N = -(f N - f_lim) := by simp\n    rwa [h_neg, eLpNorm_neg]\n  ¬∑ exact (hf N).2\n\n"}
{"name":"MeasureTheory.Lp.cauchy_complete_‚Ñíp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : CompleteSpace E\nhp : LE.le 1 p\nf : Nat ‚Üí Œ± ‚Üí E\nhf : ‚àÄ (n : Nat), MeasureTheory.Mem‚Ñíp (f n) p Œº\nB : Nat ‚Üí ENNReal\nhB : Ne (tsum fun i => B i) Top.top\nh_cau : ‚àÄ (N n m : Nat), LE.le N n ‚Üí LE.le N m ‚Üí LT.lt (MeasureTheory.eLpNorm (HSub.hSub (f n) (f m)) p Œº) (B N)\n‚ä¢ Exists fun f_lim => And (MeasureTheory.Mem‚Ñíp f_lim p Œº) (Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) f_lim) p Œº) Filter.atTop (nhds 0))","decl":"theorem cauchy_complete_‚Ñíp [CompleteSpace E] (hp : 1 ‚â§ p) {f : ‚Ñï ‚Üí Œ± ‚Üí E}\n    (hf : ‚àÄ n, Mem‚Ñíp (f n) p Œº) {B : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû} (hB : ‚àë' i, B i ‚â† ‚àû)\n    (h_cau : ‚àÄ N n m : ‚Ñï, N ‚â§ n ‚Üí N ‚â§ m ‚Üí eLpNorm (f n - f m) p Œº < B N) :\n    ‚àÉ (f_lim : Œ± ‚Üí E), Mem‚Ñíp f_lim p Œº ‚àß\n      atTop.Tendsto (fun n => eLpNorm (f n - f_lim) p Œº) (ùìù 0) := by\n  obtain ‚ü®f_lim, h_f_lim_meas, h_lim‚ü© :\n      ‚àÉ f_lim : Œ± ‚Üí E, StronglyMeasurable f_lim ‚àß\n        ‚àÄ·µê x ‚àÇŒº, Tendsto (fun n => f n x) atTop (ùìù (f_lim x)) :=\n    exists_stronglyMeasurable_limit_of_tendsto_ae (fun n => (hf n).1)\n      (ae_tendsto_of_cauchy_eLpNorm (fun n => (hf n).1) hp hB h_cau)\n  have h_tendsto' : atTop.Tendsto (fun n => eLpNorm (f n - f_lim) p Œº) (ùìù 0) :=\n    cauchy_tendsto_of_tendsto (fun m => (hf m).1) f_lim hB h_cau h_lim\n  have h_‚Ñíp_lim : Mem‚Ñíp f_lim p Œº :=\n    mem‚Ñíp_of_cauchy_tendsto hp hf f_lim h_f_lim_meas.aestronglyMeasurable h_tendsto'\n  exact ‚ü®f_lim, h_‚Ñíp_lim, h_tendsto'‚ü©\n\n"}
{"name":"MeasureTheory.Lp.instCompleteSpace","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : CompleteSpace E\nhp : Fact (LE.le 1 p)\n‚ä¢ CompleteSpace (Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x)","decl":"instance instCompleteSpace [CompleteSpace E] [hp : Fact (1 ‚â§ p)] : CompleteSpace (Lp E p Œº) :=\n  completeSpace_lp_of_cauchy_complete_‚Ñíp fun _f hf _B hB h_cau =>\n    cauchy_complete_‚Ñíp hp.elim hf hB.ne h_cau\n\n"}
{"name":"MeasureTheory.Lp.mem_boundedContinuousFunction_iff","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : BorelSpace Œ±\ninst‚úù : SecondCountableTopologyEither Œ± E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ Iff (Membership.mem (MeasureTheory.Lp.boundedContinuousFunction E p Œº) f) (Exists fun f‚ÇÄ => Eq (ContinuousMap.toAEEqFun Œº f‚ÇÄ.toContinuousMap) ‚Üëf)","decl":"/-- By definition, the elements of `Lp.boundedContinuousFunction E p Œº` are the elements of\n`Lp E p Œº` which contain a bounded continuous representative. -/\ntheorem MeasureTheory.Lp.mem_boundedContinuousFunction_iff {f : Lp E p Œº} :\n    f ‚àà MeasureTheory.Lp.boundedContinuousFunction E p Œº ‚Üî\n      ‚àÉ f‚ÇÄ : Œ± ‚Üí·µá E, f‚ÇÄ.toContinuousMap.toAEEqFun Œº = (f : Œ± ‚Üí‚Çò[Œº] E) :=\n  AddSubgroup.mem_addSubgroupOf\n\n"}
{"name":"BoundedContinuousFunction.mem_Lp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : BorelSpace Œ±\ninst‚úù¬π : SecondCountableTopologyEither Œ± E\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nf : BoundedContinuousFunction Œ± E\n‚ä¢ Membership.mem (MeasureTheory.Lp E p Œº) (ContinuousMap.toAEEqFun Œº f.toContinuousMap)","decl":"/-- A bounded continuous function on a finite-measure space is in `Lp`. -/\ntheorem mem_Lp (f : Œ± ‚Üí·µá E) : f.toContinuousMap.toAEEqFun Œº ‚àà Lp E p Œº := by\n  refine Lp.mem_Lp_of_ae_bound ‚Äñf‚Äñ ?_\n  filter_upwards [f.toContinuousMap.coeFn_toAEEqFun Œº] with x _\n  convert f.norm_coe_le_norm x using 2\n\n"}
{"name":"BoundedContinuousFunction.Lp_nnnorm_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : BorelSpace Œ±\ninst‚úù¬π : SecondCountableTopologyEither Œ± E\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nf : BoundedContinuousFunction Œ± E\n‚ä¢ LE.le (NNNorm.nnnorm ‚ü®ContinuousMap.toAEEqFun Œº f.toContinuousMap, ‚ãØ‚ü©) (HMul.hMul (HPow.hPow (MeasureTheory.measureUnivNNReal Œº) (Inv.inv p.toReal)) (NNNorm.nnnorm f))","decl":"/-- The `Lp`-norm of a bounded continuous function is at most a constant (depending on the measure\nof the whole space) times its sup-norm. -/\ntheorem Lp_nnnorm_le (f : Œ± ‚Üí·µá E) :\n    ‚Äñ(‚ü®f.toContinuousMap.toAEEqFun Œº, mem_Lp f‚ü© : Lp E p Œº)‚Äñ‚Çä ‚â§\n      measureUnivNNReal Œº ^ p.toReal‚Åª¬π * ‚Äñf‚Äñ‚Çä := by\n  apply Lp.nnnorm_le_of_ae_bound\n  refine (f.toContinuousMap.coeFn_toAEEqFun Œº).mono ?_\n  intro x hx\n  rw [‚Üê NNReal.coe_le_coe, coe_nnnorm, coe_nnnorm]\n  convert f.norm_coe_le_norm x using 2\n\n"}
{"name":"BoundedContinuousFunction.Lp_norm_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : BorelSpace Œ±\ninst‚úù¬π : SecondCountableTopologyEither Œ± E\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nf : BoundedContinuousFunction Œ± E\n‚ä¢ LE.le (Norm.norm ‚ü®ContinuousMap.toAEEqFun Œº f.toContinuousMap, ‚ãØ‚ü©) (HMul.hMul (HPow.hPow (‚Üë(MeasureTheory.measureUnivNNReal Œº)) (Inv.inv p.toReal)) (Norm.norm f))","decl":"/-- The `Lp`-norm of a bounded continuous function is at most a constant (depending on the measure\nof the whole space) times its sup-norm. -/\ntheorem Lp_norm_le (f : Œ± ‚Üí·µá E) :\n    ‚Äñ(‚ü®f.toContinuousMap.toAEEqFun Œº, mem_Lp f‚ü© : Lp E p Œº)‚Äñ ‚â§\n      measureUnivNNReal Œº ^ p.toReal‚Åª¬π * ‚Äñf‚Äñ :=\n  Lp_nnnorm_le f\n\n"}
{"name":"BoundedContinuousFunction.range_toLpHom","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : BorelSpace Œ±\ninst‚úù¬≤ : SecondCountableTopologyEither Œ± E\ninst‚úù¬π : MeasureTheory.IsFiniteMeasure Œº\ninst‚úù : Fact (LE.le 1 p)\n‚ä¢ Eq (BoundedContinuousFunction.toLpHom p Œº).range (MeasureTheory.Lp.boundedContinuousFunction E p Œº)","decl":"theorem range_toLpHom [Fact (1 ‚â§ p)] :\n    ((toLpHom p Œº).range : AddSubgroup (Lp E p Œº)) =\n      MeasureTheory.Lp.boundedContinuousFunction E p Œº := by\n  symm\n  exact AddMonoidHom.addSubgroupOf_range_eq_of_le\n      ((ContinuousMap.toAEEqFunAddHom Œº).comp (toContinuousMapAddHom Œ± E))\n      (by rintro - ‚ü®f, rfl‚ü©; exact mem_Lp f : _ ‚â§ Lp E p Œº)\n\n"}
{"name":"BoundedContinuousFunction.coeFn_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : TopologicalSpace Œ±\ninst‚úù‚Åµ : BorelSpace Œ±\ninst‚úù‚Å¥ : SecondCountableTopologyEither Œ± E\ninst‚úù¬≥ : MeasureTheory.IsFiniteMeasure Œº\nùïú : Type u_5\ninst‚úù¬≤ : Fact (LE.le 1 p)\ninst‚úù¬π : NormedField ùïú\ninst‚úù : NormedSpace ùïú E\nf : BoundedContinuousFunction Œ± E\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq ‚Üë‚Üë((BoundedContinuousFunction.toLp p Œº ùïú) f) ‚áëf","decl":"theorem coeFn_toLp [NormedField ùïú] [NormedSpace ùïú E] (f : Œ± ‚Üí·µá E) :\n    toLp (E := E) p Œº ùïú f =·µê[Œº] f :=\n  AEEqFun.coeFn_mk f _\n\n"}
{"name":"BoundedContinuousFunction.range_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : TopologicalSpace Œ±\ninst‚úù‚Åµ : BorelSpace Œ±\ninst‚úù‚Å¥ : SecondCountableTopologyEither Œ± E\ninst‚úù¬≥ : MeasureTheory.IsFiniteMeasure Œº\nùïú : Type u_5\ninst‚úù¬≤ : Fact (LE.le 1 p)\ninst‚úù¬π : NormedField ùïú\ninst‚úù : NormedSpace ùïú E\n‚ä¢ Eq (LinearMap.range (BoundedContinuousFunction.toLp p Œº ùïú)).toAddSubgroup (MeasureTheory.Lp.boundedContinuousFunction E p Œº)","decl":"theorem range_toLp [NormedField ùïú] [NormedSpace ùïú E] :\n    (LinearMap.range (toLp p Œº ùïú : (Œ± ‚Üí·µá E) ‚ÜíL[ùïú] Lp E p Œº)).toAddSubgroup =\n      MeasureTheory.Lp.boundedContinuousFunction E p Œº :=\n  range_toLpHom p Œº\n\n"}
{"name":"BoundedContinuousFunction.toLp_norm_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : TopologicalSpace Œ±\ninst‚úù‚Åµ : BorelSpace Œ±\ninst‚úù‚Å¥ : SecondCountableTopologyEither Œ± E\ninst‚úù¬≥ : MeasureTheory.IsFiniteMeasure Œº\nùïú : Type u_5\ninst‚úù¬≤ : Fact (LE.le 1 p)\ninst‚úù¬π : NontriviallyNormedField ùïú\ninst‚úù : NormedSpace ùïú E\n‚ä¢ LE.le (Norm.norm (BoundedContinuousFunction.toLp p Œº ùïú)) (HPow.hPow (‚Üë(MeasureTheory.measureUnivNNReal Œº)) (Inv.inv p.toReal))","decl":"theorem toLp_norm_le [NontriviallyNormedField ùïú] [NormedSpace ùïú E] :\n    ‚Äñ(toLp p Œº ùïú : (Œ± ‚Üí·µá E) ‚ÜíL[ùïú] Lp E p Œº)‚Äñ ‚â§ measureUnivNNReal Œº ^ p.toReal‚Åª¬π :=\n  LinearMap.mkContinuous_norm_le _ (measureUnivNNReal Œº ^ p.toReal‚Åª¬π).coe_nonneg _\n\n"}
{"name":"BoundedContinuousFunction.toLp_inj","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : TopologicalSpace Œ±\ninst‚úù‚Å∂ : BorelSpace Œ±\ninst‚úù‚Åµ : SecondCountableTopologyEither Œ± E\ninst‚úù‚Å¥ : MeasureTheory.IsFiniteMeasure Œº\nùïú : Type u_5\ninst‚úù¬≥ : Fact (LE.le 1 p)\nf g : BoundedContinuousFunction Œ± E\ninst‚úù¬≤ : Œº.IsOpenPosMeasure\ninst‚úù¬π : NormedField ùïú\ninst‚úù : NormedSpace ùïú E\n‚ä¢ Iff (Eq ((BoundedContinuousFunction.toLp p Œº ùïú) f) ((BoundedContinuousFunction.toLp p Œº ùïú) g)) (Eq f g)","decl":"theorem toLp_inj {f g : Œ± ‚Üí·µá E} [Œº.IsOpenPosMeasure] [NormedField ùïú] [NormedSpace ùïú E] :\n    toLp (E := E) p Œº ùïú f = toLp (E := E) p Œº ùïú g ‚Üî f = g := by\n  refine ‚ü®fun h => ?_, by tauto‚ü©\n  rw [‚Üê DFunLike.coe_fn_eq, ‚Üê (map_continuous f).ae_eq_iff_eq Œº (map_continuous g)]\n  refine (coeFn_toLp p Œº ùïú f).symm.trans (EventuallyEq.trans ?_ <| coeFn_toLp p Œº ùïú g)\n  rw [h]\n\n"}
{"name":"BoundedContinuousFunction.toLp_injective","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : TopologicalSpace Œ±\ninst‚úù‚Å∂ : BorelSpace Œ±\ninst‚úù‚Åµ : SecondCountableTopologyEither Œ± E\ninst‚úù‚Å¥ : MeasureTheory.IsFiniteMeasure Œº\nùïú : Type u_5\ninst‚úù¬≥ : Fact (LE.le 1 p)\ninst‚úù¬≤ : Œº.IsOpenPosMeasure\ninst‚úù¬π : NormedField ùïú\ninst‚úù : NormedSpace ùïú E\n‚ä¢ Function.Injective ‚áë(BoundedContinuousFunction.toLp p Œº ùïú)","decl":"theorem toLp_injective [Œº.IsOpenPosMeasure] [NormedField ùïú] [NormedSpace ùïú E] :\n    Function.Injective (‚áë(toLp p Œº ùïú : (Œ± ‚Üí·µá E) ‚ÜíL[ùïú] Lp E p Œº)) :=\n  fun _f _g hfg => (toLp_inj Œº).mp hfg\n\n"}
{"name":"ContinuousMap.range_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : TopologicalSpace Œ±\ninst‚úù‚Å∂ : BorelSpace Œ±\ninst‚úù‚Åµ : SecondCountableTopologyEither Œ± E\ninst‚úù‚Å¥ : CompactSpace Œ±\ninst‚úù¬≥ : MeasureTheory.IsFiniteMeasure Œº\nùïú : Type u_5\ninst‚úù¬≤ : Fact (LE.le 1 p)\ninst‚úù¬π : NormedField ùïú\ninst‚úù : NormedSpace ùïú E\n‚ä¢ Eq (LinearMap.range (ContinuousMap.toLp p Œº ùïú)).toAddSubgroup (MeasureTheory.Lp.boundedContinuousFunction E p Œº)","decl":"theorem range_toLp [NormedField ùïú] [NormedSpace ùïú E] :\n    (LinearMap.range (toLp p Œº ùïú : C(Œ±, E) ‚ÜíL[ùïú] Lp E p Œº)).toAddSubgroup =\n      MeasureTheory.Lp.boundedContinuousFunction E p Œº := by\n  refine SetLike.ext' ?_\n  have := (linearIsometryBoundedOfCompact Œ± E ùïú).surjective\n  convert Function.Surjective.range_comp this (BoundedContinuousFunction.toLp (E := E) p Œº ùïú)\n  rw [‚Üê BoundedContinuousFunction.range_toLp p Œº (ùïú := ùïú), Submodule.coe_toAddSubgroup,\n    LinearMap.range_coe]\n\n"}
{"name":"ContinuousMap.coeFn_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : TopologicalSpace Œ±\ninst‚úù‚Å∂ : BorelSpace Œ±\ninst‚úù‚Åµ : SecondCountableTopologyEither Œ± E\ninst‚úù‚Å¥ : CompactSpace Œ±\ninst‚úù¬≥ : MeasureTheory.IsFiniteMeasure Œº\nùïú : Type u_5\ninst‚úù¬≤ : Fact (LE.le 1 p)\ninst‚úù¬π : NormedField ùïú\ninst‚úù : NormedSpace ùïú E\nf : ContinuousMap Œ± E\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq ‚Üë‚Üë((ContinuousMap.toLp p Œº ùïú) f) ‚áëf","decl":"theorem coeFn_toLp [NormedField ùïú] [NormedSpace ùïú E] (f : C(Œ±, E)) :\n    toLp (E := E) p Œº ùïú f =·µê[Œº] f :=\n  AEEqFun.coeFn_mk f _\n\n"}
{"name":"ContinuousMap.toLp_def","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : TopologicalSpace Œ±\ninst‚úù‚Å∂ : BorelSpace Œ±\ninst‚úù‚Åµ : SecondCountableTopologyEither Œ± E\ninst‚úù‚Å¥ : CompactSpace Œ±\ninst‚úù¬≥ : MeasureTheory.IsFiniteMeasure Œº\nùïú : Type u_5\ninst‚úù¬≤ : Fact (LE.le 1 p)\ninst‚úù¬π : NormedField ùïú\ninst‚úù : NormedSpace ùïú E\nf : ContinuousMap Œ± E\n‚ä¢ Eq ((ContinuousMap.toLp p Œº ùïú) f) ((BoundedContinuousFunction.toLp p Œº ùïú) ((ContinuousMap.linearIsometryBoundedOfCompact Œ± E ùïú) f))","decl":"theorem toLp_def [NormedField ùïú] [NormedSpace ùïú E] (f : C(Œ±, E)) :\n    toLp (E := E) p Œº ùïú f =\n      BoundedContinuousFunction.toLp (E := E) p Œº ùïú (linearIsometryBoundedOfCompact Œ± E ùïú f) :=\n  rfl\n\n"}
{"name":"ContinuousMap.toLp_comp_toContinuousMap","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : TopologicalSpace Œ±\ninst‚úù‚Å∂ : BorelSpace Œ±\ninst‚úù‚Åµ : SecondCountableTopologyEither Œ± E\ninst‚úù‚Å¥ : CompactSpace Œ±\ninst‚úù¬≥ : MeasureTheory.IsFiniteMeasure Œº\nùïú : Type u_5\ninst‚úù¬≤ : Fact (LE.le 1 p)\ninst‚úù¬π : NormedField ùïú\ninst‚úù : NormedSpace ùïú E\nf : BoundedContinuousFunction Œ± E\n‚ä¢ Eq ((ContinuousMap.toLp p Œº ùïú) f.toContinuousMap) ((BoundedContinuousFunction.toLp p Œº ùïú) f)","decl":"@[simp]\ntheorem toLp_comp_toContinuousMap [NormedField ùïú] [NormedSpace ùïú E] (f : Œ± ‚Üí·µá E) :\n    toLp (E := E) p Œº ùïú f.toContinuousMap = BoundedContinuousFunction.toLp (E := E) p Œº ùïú f :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : TopologicalSpace Œ±\ninst‚úù‚Å∂ : BorelSpace Œ±\ninst‚úù‚Åµ : SecondCountableTopologyEither Œ± E\ninst‚úù‚Å¥ : CompactSpace Œ±\ninst‚úù¬≥ : MeasureTheory.IsFiniteMeasure Œº\nùïú : Type u_5\ninst‚úù¬≤ : Fact (LE.le 1 p)\ninst‚úù¬π : NormedField ùïú\ninst‚úù : NormedSpace ùïú E\nf : ContinuousMap Œ± E\n‚ä¢ Eq (‚Üë((ContinuousMap.toLp p Œº ùïú) f)) (ContinuousMap.toAEEqFun Œº f)","decl":"@[simp]\ntheorem coe_toLp [NormedField ùïú] [NormedSpace ùïú E] (f : C(Œ±, E)) :\n    (toLp (E := E) p Œº ùïú f : Œ± ‚Üí‚Çò[Œº] E) = f.toAEEqFun Œº :=\n  rfl\n\n"}
{"name":"ContinuousMap.toLp_injective","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Åπ : NormedAddCommGroup E\ninst‚úù‚Å∏ : TopologicalSpace Œ±\ninst‚úù‚Å∑ : BorelSpace Œ±\ninst‚úù‚Å∂ : SecondCountableTopologyEither Œ± E\ninst‚úù‚Åµ : CompactSpace Œ±\ninst‚úù‚Å¥ : MeasureTheory.IsFiniteMeasure Œº\nùïú : Type u_5\ninst‚úù¬≥ : Fact (LE.le 1 p)\ninst‚úù¬≤ : Œº.IsOpenPosMeasure\ninst‚úù¬π : NormedField ùïú\ninst‚úù : NormedSpace ùïú E\n‚ä¢ Function.Injective ‚áë(ContinuousMap.toLp p Œº ùïú)","decl":"theorem toLp_injective [Œº.IsOpenPosMeasure] [NormedField ùïú] [NormedSpace ùïú E] :\n    Function.Injective (‚áë(toLp p Œº ùïú : C(Œ±, E) ‚ÜíL[ùïú] Lp E p Œº)) :=\n  (BoundedContinuousFunction.toLp_injective _).comp (linearIsometryBoundedOfCompact Œ± E ùïú).injective\n\n"}
{"name":"ContinuousMap.toLp_inj","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Åπ : NormedAddCommGroup E\ninst‚úù‚Å∏ : TopologicalSpace Œ±\ninst‚úù‚Å∑ : BorelSpace Œ±\ninst‚úù‚Å∂ : SecondCountableTopologyEither Œ± E\ninst‚úù‚Åµ : CompactSpace Œ±\ninst‚úù‚Å¥ : MeasureTheory.IsFiniteMeasure Œº\nùïú : Type u_5\ninst‚úù¬≥ : Fact (LE.le 1 p)\nf g : ContinuousMap Œ± E\ninst‚úù¬≤ : Œº.IsOpenPosMeasure\ninst‚úù¬π : NormedField ùïú\ninst‚úù : NormedSpace ùïú E\n‚ä¢ Iff (Eq ((ContinuousMap.toLp p Œº ùïú) f) ((ContinuousMap.toLp p Œº ùïú) g)) (Eq f g)","decl":"theorem toLp_inj {f g : C(Œ±, E)} [Œº.IsOpenPosMeasure] [NormedField ùïú] [NormedSpace ùïú E] :\n    toLp (E := E) p Œº ùïú f = toLp (E := E) p Œº ùïú g ‚Üî f = g :=\n  (toLp_injective Œº).eq_iff\n\n"}
{"name":"ContinuousMap.hasSum_of_hasSum_Lp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Åπ : NormedAddCommGroup E\ninst‚úù‚Å∏ : TopologicalSpace Œ±\ninst‚úù‚Å∑ : BorelSpace Œ±\ninst‚úù‚Å∂ : SecondCountableTopologyEither Œ± E\ninst‚úù‚Åµ : CompactSpace Œ±\ninst‚úù‚Å¥ : MeasureTheory.IsFiniteMeasure Œº\nùïú : Type u_5\ninst‚úù¬≥ : Fact (LE.le 1 p)\nŒ≤ : Type u_6\ninst‚úù¬≤ : Œº.IsOpenPosMeasure\ninst‚úù¬π : NormedField ùïú\ninst‚úù : NormedSpace ùïú E\ng : Œ≤ ‚Üí ContinuousMap Œ± E\nf : ContinuousMap Œ± E\nhg : Summable g\nhg2 : HasSum (Function.comp (‚áë(ContinuousMap.toLp p Œº ùïú)) g) ((ContinuousMap.toLp p Œº ùïú) f)\n‚ä¢ HasSum g f","decl":"/-- If a sum of continuous functions `g n` is convergent, and the same sum converges in `L·µñ` to `h`,\nthen in fact `g n` converges uniformly to `h`. -/\ntheorem hasSum_of_hasSum_Lp {Œ≤ : Type*} [Œº.IsOpenPosMeasure] [NormedField ùïú] [NormedSpace ùïú E]\n    {g : Œ≤ ‚Üí C(Œ±, E)} {f : C(Œ±, E)} (hg : Summable g)\n    (hg2 : HasSum (toLp (E := E) p Œº ùïú ‚àò g) (toLp (E := E) p Œº ùïú f)) : HasSum g f := by\n  convert Summable.hasSum hg\n  exact toLp_injective Œº (hg2.unique ((toLp p Œº ùïú).hasSum <| Summable.hasSum hg))\n\n"}
{"name":"ContinuousMap.toLp_norm_eq_toLp_norm_coe","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : TopologicalSpace Œ±\ninst‚úù‚Å∂ : BorelSpace Œ±\ninst‚úù‚Åµ : SecondCountableTopologyEither Œ± E\ninst‚úù‚Å¥ : CompactSpace Œ±\ninst‚úù¬≥ : MeasureTheory.IsFiniteMeasure Œº\nùïú : Type u_5\ninst‚úù¬≤ : Fact (LE.le 1 p)\ninst‚úù¬π : NontriviallyNormedField ùïú\ninst‚úù : NormedSpace ùïú E\n‚ä¢ Eq (Norm.norm (ContinuousMap.toLp p Œº ùïú)) (Norm.norm (BoundedContinuousFunction.toLp p Œº ùïú))","decl":"theorem toLp_norm_eq_toLp_norm_coe :\n    ‚Äñ(toLp p Œº ùïú : C(Œ±, E) ‚ÜíL[ùïú] Lp E p Œº)‚Äñ =\n      ‚Äñ(BoundedContinuousFunction.toLp p Œº ùïú : (Œ± ‚Üí·µá E) ‚ÜíL[ùïú] Lp E p Œº)‚Äñ :=\n  ContinuousLinearMap.opNorm_comp_linearIsometryEquiv _ _\n\n"}
{"name":"ContinuousMap.toLp_norm_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : TopologicalSpace Œ±\ninst‚úù‚Å∂ : BorelSpace Œ±\ninst‚úù‚Åµ : SecondCountableTopologyEither Œ± E\ninst‚úù‚Å¥ : CompactSpace Œ±\ninst‚úù¬≥ : MeasureTheory.IsFiniteMeasure Œº\nùïú : Type u_5\ninst‚úù¬≤ : Fact (LE.le 1 p)\ninst‚úù¬π : NontriviallyNormedField ùïú\ninst‚úù : NormedSpace ùïú E\n‚ä¢ LE.le (Norm.norm (ContinuousMap.toLp p Œº ùïú)) (HPow.hPow (‚Üë(MeasureTheory.measureUnivNNReal Œº)) (Inv.inv p.toReal))","decl":"/-- Bound for the operator norm of `ContinuousMap.toLp`. -/\ntheorem toLp_norm_le :\n    ‚Äñ(toLp p Œº ùïú : C(Œ±, E) ‚ÜíL[ùïú] Lp E p Œº)‚Äñ ‚â§ measureUnivNNReal Œº ^ p.toReal‚Åª¬π := by\n  rw [toLp_norm_eq_toLp_norm_coe]\n  exact BoundedContinuousFunction.toLp_norm_le Œº\n\n"}
{"name":"MeasureTheory.Lp.pow_mul_meas_ge_le_enorm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nŒµ : ENNReal\n‚ä¢ LE.le (HPow.hPow (HMul.hMul Œµ (Œº (setOf fun x => LE.le Œµ (HPow.hPow (ENorm.enorm (‚Üë‚Üëf x)) p.toReal)))) (HDiv.hDiv 1 p.toReal)) (ENNReal.ofReal (Norm.norm f))","decl":"/-- A version of **Markov's inequality** with elements of Lp. -/\nlemma pow_mul_meas_ge_le_enorm (f : Lp E p Œº) (hp_ne_zero : p ‚â† 0) (hp_ne_top : p ‚â† ‚àû) (Œµ : ‚Ñù‚â•0‚àû) :\n    (Œµ * Œº {x | Œµ ‚â§ ‚Äñf x‚Äñ‚Çë ^ p.toReal}) ^ (1 / p.toReal) ‚â§ ENNReal.ofReal ‚Äñf‚Äñ :=\n  (ENNReal.ofReal_toReal (eLpNorm_ne_top f)).symm ‚ñ∏\n    pow_mul_meas_ge_le_eLpNorm Œº hp_ne_zero hp_ne_top (Lp.aestronglyMeasurable f) Œµ\n\n"}
{"name":"MeasureTheory.Lp.mul_meas_ge_le_pow_enorm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nŒµ : ENNReal\n‚ä¢ LE.le (HMul.hMul Œµ (Œº (setOf fun x => LE.le Œµ (HPow.hPow (ENorm.enorm (‚Üë‚Üëf x)) p.toReal)))) (HPow.hPow (ENNReal.ofReal (Norm.norm f)) p.toReal)","decl":"/-- A version of **Markov's inequality** with elements of Lp. -/\nlemma mul_meas_ge_le_pow_enorm (f : Lp E p Œº) (hp_ne_zero : p ‚â† 0) (hp_ne_top : p ‚â† ‚àû) (Œµ : ‚Ñù‚â•0‚àû) :\n    Œµ * Œº {x | Œµ ‚â§ ‚Äñf x‚Äñ‚Çë ^ p.toReal} ‚â§ ENNReal.ofReal ‚Äñf‚Äñ ^ p.toReal :=\n  (ENNReal.ofReal_toReal (eLpNorm_ne_top f)).symm ‚ñ∏\n    mul_meas_ge_le_pow_eLpNorm Œº hp_ne_zero hp_ne_top (Lp.aestronglyMeasurable f) Œµ\n\n"}
{"name":"MeasureTheory.Lp.mul_meas_ge_le_pow_enorm'","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nŒµ : ENNReal\n‚ä¢ LE.le (HMul.hMul (HPow.hPow Œµ p.toReal) (Œº (setOf fun x => LE.le Œµ ‚Üë(NNNorm.nnnorm (‚Üë‚Üëf x))))) (HPow.hPow (ENNReal.ofReal (Norm.norm f)) p.toReal)","decl":"/-- A version of **Markov's inequality** with elements of Lp. -/\ntheorem mul_meas_ge_le_pow_enorm' (f : Lp E p Œº) (hp_ne_zero : p ‚â† 0) (hp_ne_top : p ‚â† ‚àû)\n    (Œµ : ‚Ñù‚â•0‚àû) : Œµ ^ p.toReal * Œº {x | Œµ ‚â§ ‚Äñf x‚Äñ‚Çä } ‚â§ ENNReal.ofReal ‚Äñf‚Äñ ^ p.toReal :=\n  (ENNReal.ofReal_toReal (eLpNorm_ne_top f)).symm ‚ñ∏\n    mul_meas_ge_le_pow_eLpNorm' Œº hp_ne_zero hp_ne_top (Lp.aestronglyMeasurable f) Œµ\n\n"}
{"name":"MeasureTheory.Lp.meas_ge_le_mul_pow_enorm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nŒµ : ENNReal\nhŒµ : Ne Œµ 0\n‚ä¢ LE.le (Œº (setOf fun x => LE.le Œµ ‚Üë(NNNorm.nnnorm (‚Üë‚Üëf x)))) (HMul.hMul (HPow.hPow (Inv.inv Œµ) p.toReal) (HPow.hPow (ENNReal.ofReal (Norm.norm f)) p.toReal))","decl":"/-- A version of **Markov's inequality** with elements of Lp. -/\ntheorem meas_ge_le_mul_pow_enorm (f : Lp E p Œº) (hp_ne_zero : p ‚â† 0) (hp_ne_top : p ‚â† ‚àû) {Œµ : ‚Ñù‚â•0‚àû}\n    (hŒµ : Œµ ‚â† 0) : Œº {x | Œµ ‚â§ ‚Äñf x‚Äñ‚Çä} ‚â§ Œµ‚Åª¬π ^ p.toReal * ENNReal.ofReal ‚Äñf‚Äñ ^ p.toReal :=\n  (ENNReal.ofReal_toReal (eLpNorm_ne_top f)).symm ‚ñ∏\n    meas_ge_le_mul_pow_eLpNorm Œº hp_ne_zero hp_ne_top (Lp.aestronglyMeasurable f) hŒµ\n\n"}
{"name":"MeasureTheory.Lp.pow_mul_meas_ge_le_norm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nŒµ : ENNReal\n‚ä¢ LE.le (HPow.hPow (HMul.hMul Œµ (Œº (setOf fun x => LE.le Œµ (HPow.hPow (ENorm.enorm (‚Üë‚Üëf x)) p.toReal)))) (HDiv.hDiv 1 p.toReal)) (ENNReal.ofReal (Norm.norm f))","decl":"@[deprecated (since := \"2025-01-20\")] alias pow_mul_meas_ge_le_norm := pow_mul_meas_ge_le_enorm\n"}
{"name":"MeasureTheory.Lp.mul_meas_ge_le_pow_norm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nŒµ : ENNReal\n‚ä¢ LE.le (HMul.hMul Œµ (Œº (setOf fun x => LE.le Œµ (HPow.hPow (ENorm.enorm (‚Üë‚Üëf x)) p.toReal)))) (HPow.hPow (ENNReal.ofReal (Norm.norm f)) p.toReal)","decl":"@[deprecated (since := \"2025-01-20\")] alias mul_meas_ge_le_pow_norm := mul_meas_ge_le_pow_enorm\n"}
{"name":"MeasureTheory.Lp.mul_meas_ge_le_pow_norm'","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nŒµ : ENNReal\n‚ä¢ LE.le (HMul.hMul (HPow.hPow Œµ p.toReal) (Œº (setOf fun x => LE.le Œµ ‚Üë(NNNorm.nnnorm (‚Üë‚Üëf x))))) (HPow.hPow (ENNReal.ofReal (Norm.norm f)) p.toReal)","decl":"@[deprecated (since := \"2025-01-20\")] alias mul_meas_ge_le_pow_norm' := mul_meas_ge_le_pow_enorm'\n"}
{"name":"MeasureTheory.Lp.meas_ge_le_mul_pow_norm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nŒµ : ENNReal\nhŒµ : Ne Œµ 0\n‚ä¢ LE.le (Œº (setOf fun x => LE.le Œµ ‚Üë(NNNorm.nnnorm (‚Üë‚Üëf x)))) (HMul.hMul (HPow.hPow (Inv.inv Œµ) p.toReal) (HPow.hPow (ENNReal.ofReal (Norm.norm f)) p.toReal))","decl":"@[deprecated (since := \"2025-01-20\")] alias meas_ge_le_mul_pow_norm := meas_ge_le_mul_pow_enorm\n\n"}
