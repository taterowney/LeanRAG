{"name":"MeasureTheory.eLpNorm_aeeqFun","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_5\nE : Type u_6\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nf : α → E\nhf : MeasureTheory.AEStronglyMeasurable f μ\n⊢ Eq (MeasureTheory.eLpNorm (↑(MeasureTheory.AEEqFun.mk f hf)) p μ) (MeasureTheory.eLpNorm f p μ)","decl":"@[simp]\ntheorem eLpNorm_aeeqFun {α E : Type*} [MeasurableSpace α] {μ : Measure α} [NormedAddCommGroup E]\n    {p : ℝ≥0∞} {f : α → E} (hf : AEStronglyMeasurable f μ) :\n    eLpNorm (AEEqFun.mk f hf) p μ = eLpNorm f p μ :=\n  eLpNorm_congr_ae (AEEqFun.coeFn_mk _ _)\n\n"}
{"name":"MeasureTheory.Memℒp.eLpNorm_mk_lt_top","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_5\nE : Type u_6\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nf : α → E\nhfp : MeasureTheory.Memℒp f p μ\n⊢ LT.lt (MeasureTheory.eLpNorm (↑(MeasureTheory.AEEqFun.mk f ⋯)) p μ) Top.top","decl":"theorem Memℒp.eLpNorm_mk_lt_top {α E : Type*} [MeasurableSpace α] {μ : Measure α}\n    [NormedAddCommGroup E] {p : ℝ≥0∞} {f : α → E} (hfp : Memℒp f p μ) :\n    eLpNorm (AEEqFun.mk f hfp.1) p μ < ∞ := by simp [hfp.2]\n\n"}
{"name":"MeasureTheory.Memℒp.toLp_val","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nh : MeasureTheory.Memℒp f p μ\n⊢ Eq (↑(MeasureTheory.Memℒp.toLp f h)) (MeasureTheory.AEEqFun.mk f ⋯)","decl":"theorem toLp_val {f : α → E} (h : Memℒp f p μ) : (toLp f h).1 = AEEqFun.mk f h.1 := rfl\n\n"}
{"name":"MeasureTheory.Memℒp.coeFn_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nhf : MeasureTheory.Memℒp f p μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (↑↑(MeasureTheory.Memℒp.toLp f hf)) f","decl":"theorem coeFn_toLp {f : α → E} (hf : Memℒp f p μ) : hf.toLp f =ᵐ[μ] f :=\n  AEEqFun.coeFn_mk _ _\n\n"}
{"name":"MeasureTheory.Memℒp.toLp_congr","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf g : α → E\nhf : MeasureTheory.Memℒp f p μ\nhg : MeasureTheory.Memℒp g p μ\nhfg : (MeasureTheory.ae μ).EventuallyEq f g\n⊢ Eq (MeasureTheory.Memℒp.toLp f hf) (MeasureTheory.Memℒp.toLp g hg)","decl":"theorem toLp_congr {f g : α → E} (hf : Memℒp f p μ) (hg : Memℒp g p μ) (hfg : f =ᵐ[μ] g) :\n    hf.toLp f = hg.toLp g := by simp [toLp, hfg]\n\n"}
{"name":"MeasureTheory.Memℒp.toLp_eq_toLp_iff","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf g : α → E\nhf : MeasureTheory.Memℒp f p μ\nhg : MeasureTheory.Memℒp g p μ\n⊢ Iff (Eq (MeasureTheory.Memℒp.toLp f hf) (MeasureTheory.Memℒp.toLp g hg)) ((MeasureTheory.ae μ).EventuallyEq f g)","decl":"@[simp]\ntheorem toLp_eq_toLp_iff {f g : α → E} (hf : Memℒp f p μ) (hg : Memℒp g p μ) :\n    hf.toLp f = hg.toLp g ↔ f =ᵐ[μ] g := by simp [toLp]\n\n"}
{"name":"MeasureTheory.Memℒp.toLp_zero","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nh : MeasureTheory.Memℒp 0 p μ\n⊢ Eq (MeasureTheory.Memℒp.toLp 0 h) 0","decl":"@[simp]\ntheorem toLp_zero (h : Memℒp (0 : α → E) p μ) : h.toLp 0 = 0 :=\n  rfl\n\n"}
{"name":"MeasureTheory.Memℒp.toLp_add","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf g : α → E\nhf : MeasureTheory.Memℒp f p μ\nhg : MeasureTheory.Memℒp g p μ\n⊢ Eq (MeasureTheory.Memℒp.toLp (HAdd.hAdd f g) ⋯) (HAdd.hAdd (MeasureTheory.Memℒp.toLp f hf) (MeasureTheory.Memℒp.toLp g hg))","decl":"theorem toLp_add {f g : α → E} (hf : Memℒp f p μ) (hg : Memℒp g p μ) :\n    (hf.add hg).toLp (f + g) = hf.toLp f + hg.toLp g :=\n  rfl\n\n"}
{"name":"MeasureTheory.Memℒp.toLp_neg","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nhf : MeasureTheory.Memℒp f p μ\n⊢ Eq (MeasureTheory.Memℒp.toLp (Neg.neg f) ⋯) (Neg.neg (MeasureTheory.Memℒp.toLp f hf))","decl":"theorem toLp_neg {f : α → E} (hf : Memℒp f p μ) : hf.neg.toLp (-f) = -hf.toLp f :=\n  rfl\n\n"}
{"name":"MeasureTheory.Memℒp.toLp_sub","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf g : α → E\nhf : MeasureTheory.Memℒp f p μ\nhg : MeasureTheory.Memℒp g p μ\n⊢ Eq (MeasureTheory.Memℒp.toLp (HSub.hSub f g) ⋯) (HSub.hSub (MeasureTheory.Memℒp.toLp f hf) (MeasureTheory.Memℒp.toLp g hg))","decl":"theorem toLp_sub {f g : α → E} (hf : Memℒp f p μ) (hg : Memℒp g p μ) :\n    (hf.sub hg).toLp (f - g) = hf.toLp f - hg.toLp g :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.ext","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\nh : (MeasureTheory.ae μ).EventuallyEq ↑↑f ↑↑g\n⊢ Eq f g","decl":"@[ext high]\ntheorem ext {f g : Lp E p μ} (h : f =ᵐ[μ] g) : f = g := by\n  cases f\n  cases g\n  simp only [Subtype.mk_eq_mk]\n  exact AEEqFun.ext h\n\n"}
{"name":"MeasureTheory.Lp.ext_iff","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Iff (Eq f g) ((MeasureTheory.ae μ).EventuallyEq ↑↑f ↑↑g)","decl":"@[ext high]\ntheorem ext {f g : Lp E p μ} (h : f =ᵐ[μ] g) : f = g := by\n  cases f\n  cases g\n  simp only [Subtype.mk_eq_mk]\n  exact AEEqFun.ext h\n\n"}
{"name":"MeasureTheory.Lp.mem_Lp_iff_eLpNorm_lt_top","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : MeasureTheory.AEEqFun α E μ\n⊢ Iff (Membership.mem (MeasureTheory.Lp E p μ) f) (LT.lt (MeasureTheory.eLpNorm (↑f) p μ) Top.top)","decl":"theorem mem_Lp_iff_eLpNorm_lt_top {f : α →ₘ[μ] E} : f ∈ Lp E p μ ↔ eLpNorm f p μ < ∞ := Iff.rfl\n\n"}
{"name":"MeasureTheory.Lp.mem_Lp_iff_memℒp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : MeasureTheory.AEEqFun α E μ\n⊢ Iff (Membership.mem (MeasureTheory.Lp E p μ) f) (MeasureTheory.Memℒp (↑f) p μ)","decl":"theorem mem_Lp_iff_memℒp {f : α →ₘ[μ] E} : f ∈ Lp E p μ ↔ Memℒp f p μ := by\n  simp [mem_Lp_iff_eLpNorm_lt_top, Memℒp, f.stronglyMeasurable.aestronglyMeasurable]\n\n"}
{"name":"MeasureTheory.Lp.antitone","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\np q : ENNReal\nhpq : LE.le p q\n⊢ LE.le (MeasureTheory.Lp E q μ) (MeasureTheory.Lp E p μ)","decl":"protected theorem antitone [IsFiniteMeasure μ] {p q : ℝ≥0∞} (hpq : p ≤ q) : Lp E q μ ≤ Lp E p μ :=\n  fun f hf => (Memℒp.mono_exponent ⟨f.aestronglyMeasurable, hf⟩ hpq).2\n\n"}
{"name":"MeasureTheory.Lp.coeFn_mk","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : MeasureTheory.AEEqFun α E μ\nhf : LT.lt (MeasureTheory.eLpNorm (↑f) p μ) Top.top\n⊢ Eq ↑↑⟨f, hf⟩ ↑f","decl":"@[simp]\ntheorem coeFn_mk {f : α →ₘ[μ] E} (hf : eLpNorm f p μ < ∞) : ((⟨f, hf⟩ : Lp E p μ) : α → E) = f :=\n  rfl\n\n-- @[simp] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10685): dsimp can prove this\n"}
{"name":"MeasureTheory.Lp.coe_mk","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : MeasureTheory.AEEqFun α E μ\nhf : LT.lt (MeasureTheory.eLpNorm (↑f) p μ) Top.top\n⊢ Eq (↑⟨f, hf⟩) f","decl":"theorem coe_mk {f : α →ₘ[μ] E} (hf : eLpNorm f p μ < ∞) : ((⟨f, hf⟩ : Lp E p μ) : α →ₘ[μ] E) = f :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.toLp_coeFn","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\nhf : MeasureTheory.Memℒp (↑↑f) p μ\n⊢ Eq (MeasureTheory.Memℒp.toLp (↑↑f) hf) f","decl":"@[simp]\ntheorem toLp_coeFn (f : Lp E p μ) (hf : Memℒp f p μ) : hf.toLp f = f := by\n  cases f\n  simp [Memℒp.toLp]\n\n"}
{"name":"MeasureTheory.Lp.eLpNorm_lt_top","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ LT.lt (MeasureTheory.eLpNorm (↑↑f) p μ) Top.top","decl":"theorem eLpNorm_lt_top (f : Lp E p μ) : eLpNorm f p μ < ∞ :=\n  f.prop\n\n"}
{"name":"MeasureTheory.Lp.eLpNorm_ne_top","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Ne (MeasureTheory.eLpNorm (↑↑f) p μ) Top.top","decl":"theorem eLpNorm_ne_top (f : Lp E p μ) : eLpNorm f p μ ≠ ∞ :=\n  (eLpNorm_lt_top f).ne\n\n"}
{"name":"MeasureTheory.Lp.stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ MeasureTheory.StronglyMeasurable ↑↑f","decl":"@[measurability]\nprotected theorem stronglyMeasurable (f : Lp E p μ) : StronglyMeasurable f :=\n  f.val.stronglyMeasurable\n\n"}
{"name":"MeasureTheory.Lp.aestronglyMeasurable","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ MeasureTheory.AEStronglyMeasurable (↑↑f) μ","decl":"@[measurability]\nprotected theorem aestronglyMeasurable (f : Lp E p μ) : AEStronglyMeasurable f μ :=\n  f.val.aestronglyMeasurable\n\n"}
{"name":"MeasureTheory.Lp.memℒp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ MeasureTheory.Memℒp (↑↑f) p μ","decl":"protected theorem memℒp (f : Lp E p μ) : Memℒp f p μ :=\n  ⟨Lp.aestronglyMeasurable f, f.prop⟩\n\n"}
{"name":"MeasureTheory.Lp.coeFn_zero","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\n⊢ (MeasureTheory.ae μ).EventuallyEq (↑↑0) 0","decl":"theorem coeFn_zero : ⇑(0 : Lp E p μ) =ᵐ[μ] 0 :=\n  AEEqFun.coeFn_zero\n\n"}
{"name":"MeasureTheory.Lp.coeFn_neg","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ (MeasureTheory.ae μ).EventuallyEq (↑↑(Neg.neg f)) (Neg.neg ↑↑f)","decl":"theorem coeFn_neg (f : Lp E p μ) : ⇑(-f) =ᵐ[μ] -f :=\n  AEEqFun.coeFn_neg _\n\n"}
{"name":"MeasureTheory.Lp.coeFn_add","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ (MeasureTheory.ae μ).EventuallyEq (↑↑(HAdd.hAdd f g)) (HAdd.hAdd ↑↑f ↑↑g)","decl":"theorem coeFn_add (f g : Lp E p μ) : ⇑(f + g) =ᵐ[μ] f + g :=\n  AEEqFun.coeFn_add _ _\n\n"}
{"name":"MeasureTheory.Lp.coeFn_sub","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ (MeasureTheory.ae μ).EventuallyEq (↑↑(HSub.hSub f g)) (HSub.hSub ↑↑f ↑↑g)","decl":"theorem coeFn_sub (f g : Lp E p μ) : ⇑(f - g) =ᵐ[μ] f - g :=\n  AEEqFun.coeFn_sub _ _\n\n"}
{"name":"MeasureTheory.Lp.const_mem_Lp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"E : Type u_2\np : ENNReal\ninst✝¹ : NormedAddCommGroup E\nα : Type u_5\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nc : E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Membership.mem (MeasureTheory.Lp E p μ) (MeasureTheory.AEEqFun.const α c)","decl":"theorem const_mem_Lp (α) {_ : MeasurableSpace α} (μ : Measure α) (c : E) [IsFiniteMeasure μ] :\n    @AEEqFun.const α _ _ μ _ c ∈ Lp E p μ :=\n  (memℒp_const c).eLpNorm_mk_lt_top\n\n"}
{"name":"MeasureTheory.Lp.norm_def","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Eq (Norm.norm f) (MeasureTheory.eLpNorm (↑↑f) p μ).toReal","decl":"theorem norm_def (f : Lp E p μ) : ‖f‖ = ENNReal.toReal (eLpNorm f p μ) :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.nnnorm_def","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Eq (NNNorm.nnnorm f) (MeasureTheory.eLpNorm (↑↑f) p μ).toNNReal","decl":"theorem nnnorm_def (f : Lp E p μ) : ‖f‖₊ = ENNReal.toNNReal (eLpNorm f p μ) :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.coe_nnnorm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Eq (↑(NNNorm.nnnorm f)) (Norm.norm f)","decl":"@[simp, norm_cast]\nprotected theorem coe_nnnorm (f : Lp E p μ) : (‖f‖₊ : ℝ) = ‖f‖ :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.enorm_def","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Eq (ENorm.enorm f) (MeasureTheory.eLpNorm (↑↑f) p μ)","decl":"@[simp]\ntheorem enorm_def (f : Lp E p μ) : ‖f‖ₑ = eLpNorm f p μ :=\n  ENNReal.coe_toNNReal <| Lp.eLpNorm_ne_top f\n\n"}
{"name":"MeasureTheory.Lp.nnnorm_coe_ennreal","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Eq (ENorm.enorm f) (MeasureTheory.eLpNorm (↑↑f) p μ)","decl":"@[deprecated (since := \"2025-01-20\")] alias nnnorm_coe_ennreal := enorm_def\n\n"}
{"name":"MeasureTheory.Lp.norm_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nhf : MeasureTheory.Memℒp f p μ\n⊢ Eq (Norm.norm (MeasureTheory.Memℒp.toLp f hf)) (MeasureTheory.eLpNorm f p μ).toReal","decl":"@[simp]\nlemma norm_toLp (f : α → E) (hf : Memℒp f p μ) : ‖hf.toLp f‖ = ENNReal.toReal (eLpNorm f p μ) := by\n  rw [norm_def, eLpNorm_congr_ae (Memℒp.coeFn_toLp hf)]\n\n"}
{"name":"MeasureTheory.Lp.nnnorm_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nhf : MeasureTheory.Memℒp f p μ\n⊢ Eq (NNNorm.nnnorm (MeasureTheory.Memℒp.toLp f hf)) (MeasureTheory.eLpNorm f p μ).toNNReal","decl":"@[simp]\ntheorem nnnorm_toLp (f : α → E) (hf : Memℒp f p μ) :\n    ‖hf.toLp f‖₊ = ENNReal.toNNReal (eLpNorm f p μ) :=\n  NNReal.eq <| norm_toLp f hf\n\n"}
{"name":"MeasureTheory.Lp.enorm_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nhf : MeasureTheory.Memℒp f p μ\n⊢ Eq (ENorm.enorm (MeasureTheory.Memℒp.toLp f hf)) (MeasureTheory.eLpNorm f p μ)","decl":"lemma enorm_toLp {f : α → E} (hf : Memℒp f p μ) : ‖hf.toLp f‖ₑ = eLpNorm f p μ := by\n  simp [enorm, nnnorm_toLp f hf, ENNReal.coe_toNNReal hf.2.ne]\n\n"}
{"name":"MeasureTheory.Lp.coe_nnnorm_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nhf : MeasureTheory.Memℒp f p μ\n⊢ Eq (ENorm.enorm (MeasureTheory.Memℒp.toLp f hf)) (MeasureTheory.eLpNorm f p μ)","decl":"@[deprecated (since := \"2025-01-20\")] alias coe_nnnorm_toLp := enorm_toLp\n\n"}
{"name":"MeasureTheory.Lp.dist_def","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Eq (Dist.dist f g) (MeasureTheory.eLpNorm (HSub.hSub ↑↑f ↑↑g) p μ).toReal","decl":"theorem dist_def (f g : Lp E p μ) : dist f g = (eLpNorm (⇑f - ⇑g) p μ).toReal := by\n  simp_rw [dist, norm_def]\n  refine congr_arg _ ?_\n  apply eLpNorm_congr_ae (coeFn_sub _ _)\n\n"}
{"name":"MeasureTheory.Lp.edist_def","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Eq (EDist.edist f g) (MeasureTheory.eLpNorm (HSub.hSub ↑↑f ↑↑g) p μ)","decl":"theorem edist_def (f g : Lp E p μ) : edist f g = eLpNorm (⇑f - ⇑g) p μ :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.edist_dist","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Eq (EDist.edist f g) (ENNReal.ofReal (Dist.dist f g))","decl":"protected theorem edist_dist (f g : Lp E p μ) : edist f g = .ofReal (dist f g) := by\n  rw [edist_def, dist_def, ← eLpNorm_congr_ae (coeFn_sub _ _),\n    ENNReal.ofReal_toReal (eLpNorm_ne_top (f - g))]\n\n"}
{"name":"MeasureTheory.Lp.dist_edist","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Eq (Dist.dist f g) (EDist.edist f g).toReal","decl":"protected theorem dist_edist (f g : Lp E p μ) : dist f g = (edist f g).toReal :=\n  MeasureTheory.Lp.dist_def ..\n\n"}
{"name":"MeasureTheory.Lp.dist_eq_norm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Eq (Dist.dist f g) (Norm.norm (HSub.hSub f g))","decl":"theorem dist_eq_norm (f g : Lp E p μ) : dist f g = ‖f - g‖ := rfl\n\n"}
{"name":"MeasureTheory.Lp.edist_toLp_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf g : α → E\nhf : MeasureTheory.Memℒp f p μ\nhg : MeasureTheory.Memℒp g p μ\n⊢ Eq (EDist.edist (MeasureTheory.Memℒp.toLp f hf) (MeasureTheory.Memℒp.toLp g hg)) (MeasureTheory.eLpNorm (HSub.hSub f g) p μ)","decl":"@[simp]\ntheorem edist_toLp_toLp (f g : α → E) (hf : Memℒp f p μ) (hg : Memℒp g p μ) :\n    edist (hf.toLp f) (hg.toLp g) = eLpNorm (f - g) p μ := by\n  rw [edist_def]\n  exact eLpNorm_congr_ae (hf.coeFn_toLp.sub hg.coeFn_toLp)\n\n"}
{"name":"MeasureTheory.Lp.edist_toLp_zero","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nhf : MeasureTheory.Memℒp f p μ\n⊢ Eq (EDist.edist (MeasureTheory.Memℒp.toLp f hf) 0) (MeasureTheory.eLpNorm f p μ)","decl":"@[simp]\ntheorem edist_toLp_zero (f : α → E) (hf : Memℒp f p μ) : edist (hf.toLp f) 0 = eLpNorm f p μ := by\n  simpa using edist_toLp_toLp f 0 hf Memℒp.zero\n\n"}
{"name":"MeasureTheory.Lp.nnnorm_zero","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\n⊢ Eq (NNNorm.nnnorm 0) 0","decl":"@[simp]\ntheorem nnnorm_zero : ‖(0 : Lp E p μ)‖₊ = 0 := by\n  rw [nnnorm_def]\n  change (eLpNorm (⇑(0 : α →ₘ[μ] E)) p μ).toNNReal = 0\n  simp [eLpNorm_congr_ae AEEqFun.coeFn_zero, eLpNorm_zero]\n\n"}
{"name":"MeasureTheory.Lp.norm_zero","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\n⊢ Eq (Norm.norm 0) 0","decl":"@[simp]\ntheorem norm_zero : ‖(0 : Lp E p μ)‖ = 0 :=\n  congr_arg ((↑) : ℝ≥0 → ℝ) nnnorm_zero\n\n"}
{"name":"MeasureTheory.Lp.norm_measure_zero","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p 0) x\n⊢ Eq (Norm.norm f) 0","decl":"@[simp]\ntheorem norm_measure_zero (f : Lp E p (0 : MeasureTheory.Measure α)) : ‖f‖ = 0 := by\n  -- Squeezed for performance reasons\n  simp only [norm_def, eLpNorm_measure_zero, ENNReal.zero_toReal]\n\n"}
{"name":"MeasureTheory.Lp.norm_exponent_zero","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 0 μ) x\n⊢ Eq (Norm.norm f) 0","decl":"@[simp] theorem norm_exponent_zero (f : Lp E 0 μ) : ‖f‖ = 0 := by\n  -- Squeezed for performance reasons\n  simp only [norm_def, eLpNorm_exponent_zero, ENNReal.zero_toReal]\n\n"}
{"name":"MeasureTheory.Lp.nnnorm_eq_zero_iff","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\nhp : LT.lt 0 p\n⊢ Iff (Eq (NNNorm.nnnorm f) 0) (Eq f 0)","decl":"theorem nnnorm_eq_zero_iff {f : Lp E p μ} (hp : 0 < p) : ‖f‖₊ = 0 ↔ f = 0 := by\n  refine ⟨fun hf => ?_, fun hf => by simp [hf]⟩\n  rw [nnnorm_def, ENNReal.toNNReal_eq_zero_iff] at hf\n  cases hf with\n  | inl hf =>\n    rw [eLpNorm_eq_zero_iff (Lp.aestronglyMeasurable f) hp.ne.symm] at hf\n    exact Subtype.eq (AEEqFun.ext (hf.trans AEEqFun.coeFn_zero.symm))\n  | inr hf =>\n    exact absurd hf (eLpNorm_ne_top f)\n\n"}
{"name":"MeasureTheory.Lp.norm_eq_zero_iff","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\nhp : LT.lt 0 p\n⊢ Iff (Eq (Norm.norm f) 0) (Eq f 0)","decl":"theorem norm_eq_zero_iff {f : Lp E p μ} (hp : 0 < p) : ‖f‖ = 0 ↔ f = 0 :=\n  NNReal.coe_eq_zero.trans (nnnorm_eq_zero_iff hp)\n\n"}
{"name":"MeasureTheory.Lp.eq_zero_iff_ae_eq_zero","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Iff (Eq f 0) ((MeasureTheory.ae μ).EventuallyEq (↑↑f) 0)","decl":"theorem eq_zero_iff_ae_eq_zero {f : Lp E p μ} : f = 0 ↔ f =ᵐ[μ] 0 := by\n  rw [← (Lp.memℒp f).toLp_eq_toLp_iff Memℒp.zero, Memℒp.toLp_zero, toLp_coeFn]\n\n"}
{"name":"MeasureTheory.Lp.nnnorm_neg","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Eq (NNNorm.nnnorm (Neg.neg f)) (NNNorm.nnnorm f)","decl":"@[simp]\ntheorem nnnorm_neg (f : Lp E p μ) : ‖-f‖₊ = ‖f‖₊ := by\n  rw [nnnorm_def, nnnorm_def, eLpNorm_congr_ae (coeFn_neg _), eLpNorm_neg]\n\n"}
{"name":"MeasureTheory.Lp.norm_neg","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Eq (Norm.norm (Neg.neg f)) (Norm.norm f)","decl":"@[simp]\ntheorem norm_neg (f : Lp E p μ) : ‖-f‖ = ‖f‖ :=\n  congr_arg ((↑) : ℝ≥0 → ℝ) (nnnorm_neg f)\n\n"}
{"name":"MeasureTheory.Lp.nnnorm_le_mul_nnnorm_of_ae_le_mul","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedAddCommGroup F\nc : NNReal\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\ng : Subtype fun x => Membership.mem (MeasureTheory.Lp F p μ) x\nh : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (↑↑f x)) (HMul.hMul c (NNNorm.nnnorm (↑↑g x)))) (MeasureTheory.ae μ)\n⊢ LE.le (NNNorm.nnnorm f) (HMul.hMul c (NNNorm.nnnorm g))","decl":"theorem nnnorm_le_mul_nnnorm_of_ae_le_mul {c : ℝ≥0} {f : Lp E p μ} {g : Lp F p μ}\n    (h : ∀ᵐ x ∂μ, ‖f x‖₊ ≤ c * ‖g x‖₊) : ‖f‖₊ ≤ c * ‖g‖₊ := by\n  simp only [nnnorm_def]\n  have := eLpNorm_le_nnreal_smul_eLpNorm_of_ae_le_mul h p\n  rwa [← ENNReal.toNNReal_le_toNNReal, ENNReal.smul_def, smul_eq_mul, ENNReal.toNNReal_mul,\n    ENNReal.toNNReal_coe] at this\n  · exact (Lp.memℒp _).eLpNorm_ne_top\n  · exact ENNReal.mul_ne_top ENNReal.coe_ne_top (Lp.memℒp _).eLpNorm_ne_top\n\n"}
{"name":"MeasureTheory.Lp.norm_le_mul_norm_of_ae_le_mul","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedAddCommGroup F\nc : Real\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\ng : Subtype fun x => Membership.mem (MeasureTheory.Lp F p μ) x\nh : Filter.Eventually (fun x => LE.le (Norm.norm (↑↑f x)) (HMul.hMul c (Norm.norm (↑↑g x)))) (MeasureTheory.ae μ)\n⊢ LE.le (Norm.norm f) (HMul.hMul c (Norm.norm g))","decl":"theorem norm_le_mul_norm_of_ae_le_mul {c : ℝ} {f : Lp E p μ} {g : Lp F p μ}\n    (h : ∀ᵐ x ∂μ, ‖f x‖ ≤ c * ‖g x‖) : ‖f‖ ≤ c * ‖g‖ := by\n  rcases le_or_lt 0 c with hc | hc\n  · lift c to ℝ≥0 using hc\n    exact NNReal.coe_le_coe.mpr (nnnorm_le_mul_nnnorm_of_ae_le_mul h)\n  · simp only [norm_def]\n    have := eLpNorm_eq_zero_and_zero_of_ae_le_mul_neg h hc p\n    simp [this]\n\n"}
{"name":"MeasureTheory.Lp.norm_le_norm_of_ae_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedAddCommGroup F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\ng : Subtype fun x => Membership.mem (MeasureTheory.Lp F p μ) x\nh : Filter.Eventually (fun x => LE.le (Norm.norm (↑↑f x)) (Norm.norm (↑↑g x))) (MeasureTheory.ae μ)\n⊢ LE.le (Norm.norm f) (Norm.norm g)","decl":"theorem norm_le_norm_of_ae_le {f : Lp E p μ} {g : Lp F p μ} (h : ∀ᵐ x ∂μ, ‖f x‖ ≤ ‖g x‖) :\n    ‖f‖ ≤ ‖g‖ := by\n  rw [norm_def, norm_def]\n  exact ENNReal.toReal_mono (eLpNorm_ne_top _) (eLpNorm_mono_ae h)\n\n"}
{"name":"MeasureTheory.Lp.mem_Lp_of_nnnorm_ae_le_mul","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedAddCommGroup F\nc : NNReal\nf : MeasureTheory.AEEqFun α E μ\ng : Subtype fun x => Membership.mem (MeasureTheory.Lp F p μ) x\nh : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (↑f x)) (HMul.hMul c (NNNorm.nnnorm (↑↑g x)))) (MeasureTheory.ae μ)\n⊢ Membership.mem (MeasureTheory.Lp E p μ) f","decl":"theorem mem_Lp_of_nnnorm_ae_le_mul {c : ℝ≥0} {f : α →ₘ[μ] E} {g : Lp F p μ}\n    (h : ∀ᵐ x ∂μ, ‖f x‖₊ ≤ c * ‖g x‖₊) : f ∈ Lp E p μ :=\n  mem_Lp_iff_memℒp.2 <| Memℒp.of_nnnorm_le_mul (Lp.memℒp g) f.aestronglyMeasurable h\n\n"}
{"name":"MeasureTheory.Lp.mem_Lp_of_ae_le_mul","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedAddCommGroup F\nc : Real\nf : MeasureTheory.AEEqFun α E μ\ng : Subtype fun x => Membership.mem (MeasureTheory.Lp F p μ) x\nh : Filter.Eventually (fun x => LE.le (Norm.norm (↑f x)) (HMul.hMul c (Norm.norm (↑↑g x)))) (MeasureTheory.ae μ)\n⊢ Membership.mem (MeasureTheory.Lp E p μ) f","decl":"theorem mem_Lp_of_ae_le_mul {c : ℝ} {f : α →ₘ[μ] E} {g : Lp F p μ}\n    (h : ∀ᵐ x ∂μ, ‖f x‖ ≤ c * ‖g x‖) : f ∈ Lp E p μ :=\n  mem_Lp_iff_memℒp.2 <| Memℒp.of_le_mul (Lp.memℒp g) f.aestronglyMeasurable h\n\n"}
{"name":"MeasureTheory.Lp.mem_Lp_of_nnnorm_ae_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedAddCommGroup F\nf : MeasureTheory.AEEqFun α E μ\ng : Subtype fun x => Membership.mem (MeasureTheory.Lp F p μ) x\nh : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (↑f x)) (NNNorm.nnnorm (↑↑g x))) (MeasureTheory.ae μ)\n⊢ Membership.mem (MeasureTheory.Lp E p μ) f","decl":"theorem mem_Lp_of_nnnorm_ae_le {f : α →ₘ[μ] E} {g : Lp F p μ} (h : ∀ᵐ x ∂μ, ‖f x‖₊ ≤ ‖g x‖₊) :\n    f ∈ Lp E p μ :=\n  mem_Lp_iff_memℒp.2 <| Memℒp.of_le (Lp.memℒp g) f.aestronglyMeasurable h\n\n"}
{"name":"MeasureTheory.Lp.mem_Lp_of_ae_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedAddCommGroup F\nf : MeasureTheory.AEEqFun α E μ\ng : Subtype fun x => Membership.mem (MeasureTheory.Lp F p μ) x\nh : Filter.Eventually (fun x => LE.le (Norm.norm (↑f x)) (Norm.norm (↑↑g x))) (MeasureTheory.ae μ)\n⊢ Membership.mem (MeasureTheory.Lp E p μ) f","decl":"theorem mem_Lp_of_ae_le {f : α →ₘ[μ] E} {g : Lp F p μ} (h : ∀ᵐ x ∂μ, ‖f x‖ ≤ ‖g x‖) :\n    f ∈ Lp E p μ :=\n  mem_Lp_of_nnnorm_ae_le h\n\n"}
{"name":"MeasureTheory.Lp.mem_Lp_of_ae_nnnorm_bound","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : MeasureTheory.AEEqFun α E μ\nC : NNReal\nhfC : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (↑f x)) C) (MeasureTheory.ae μ)\n⊢ Membership.mem (MeasureTheory.Lp E p μ) f","decl":"theorem mem_Lp_of_ae_nnnorm_bound [IsFiniteMeasure μ] {f : α →ₘ[μ] E} (C : ℝ≥0)\n    (hfC : ∀ᵐ x ∂μ, ‖f x‖₊ ≤ C) : f ∈ Lp E p μ :=\n  mem_Lp_iff_memℒp.2 <| Memℒp.of_bound f.aestronglyMeasurable _ hfC\n\n"}
{"name":"MeasureTheory.Lp.mem_Lp_of_ae_bound","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : MeasureTheory.AEEqFun α E μ\nC : Real\nhfC : Filter.Eventually (fun x => LE.le (Norm.norm (↑f x)) C) (MeasureTheory.ae μ)\n⊢ Membership.mem (MeasureTheory.Lp E p μ) f","decl":"theorem mem_Lp_of_ae_bound [IsFiniteMeasure μ] {f : α →ₘ[μ] E} (C : ℝ) (hfC : ∀ᵐ x ∂μ, ‖f x‖ ≤ C) :\n    f ∈ Lp E p μ :=\n  mem_Lp_iff_memℒp.2 <| Memℒp.of_bound f.aestronglyMeasurable _ hfC\n\n"}
{"name":"MeasureTheory.Lp.nnnorm_le_of_ae_bound","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\nC : NNReal\nhfC : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (↑↑f x)) C) (MeasureTheory.ae μ)\n⊢ LE.le (NNNorm.nnnorm f) (HMul.hMul (HPow.hPow (MeasureTheory.measureUnivNNReal μ) (Inv.inv p.toReal)) C)","decl":"theorem nnnorm_le_of_ae_bound [IsFiniteMeasure μ] {f : Lp E p μ} {C : ℝ≥0}\n    (hfC : ∀ᵐ x ∂μ, ‖f x‖₊ ≤ C) : ‖f‖₊ ≤ measureUnivNNReal μ ^ p.toReal⁻¹ * C := by\n  by_cases hμ : μ = 0\n  · by_cases hp : p.toReal⁻¹ = 0\n    · simp [hp, hμ, nnnorm_def]\n    · simp [hμ, nnnorm_def, Real.zero_rpow hp]\n  rw [← ENNReal.coe_le_coe, nnnorm_def, ENNReal.coe_toNNReal (eLpNorm_ne_top _)]\n  refine (eLpNorm_le_of_ae_nnnorm_bound hfC).trans_eq ?_\n  rw [← coe_measureUnivNNReal μ, ← ENNReal.coe_rpow_of_ne_zero (measureUnivNNReal_pos hμ).ne',\n    ENNReal.coe_mul, mul_comm, ENNReal.smul_def, smul_eq_mul]\n\n"}
{"name":"MeasureTheory.Lp.norm_le_of_ae_bound","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\nC : Real\nhC : LE.le 0 C\nhfC : Filter.Eventually (fun x => LE.le (Norm.norm (↑↑f x)) C) (MeasureTheory.ae μ)\n⊢ LE.le (Norm.norm f) (HMul.hMul (HPow.hPow (↑(MeasureTheory.measureUnivNNReal μ)) (Inv.inv p.toReal)) C)","decl":"theorem norm_le_of_ae_bound [IsFiniteMeasure μ] {f : Lp E p μ} {C : ℝ} (hC : 0 ≤ C)\n    (hfC : ∀ᵐ x ∂μ, ‖f x‖ ≤ C) : ‖f‖ ≤ measureUnivNNReal μ ^ p.toReal⁻¹ * C := by\n  lift C to ℝ≥0 using hC\n  have := nnnorm_le_of_ae_bound hfC\n  rwa [← NNReal.coe_le_coe, NNReal.coe_mul, NNReal.coe_rpow] at this\n\n"}
{"name":"MeasureTheory.Lp.const_smul_mem_Lp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup E\n𝕜 : Type u_5\ninst✝² : NormedRing 𝕜\ninst✝¹ : Module 𝕜 E\ninst✝ : BoundedSMul 𝕜 E\nc : 𝕜\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Membership.mem (MeasureTheory.Lp E p μ) (HSMul.hSMul c ↑f)","decl":"theorem const_smul_mem_Lp (c : 𝕜) (f : Lp E p μ) : c • (f : α →ₘ[μ] E) ∈ Lp E p μ := by\n  rw [mem_Lp_iff_eLpNorm_lt_top, eLpNorm_congr_ae (AEEqFun.coeFn_smul _ _)]\n  exact eLpNorm_const_smul_le.trans_lt <| ENNReal.mul_lt_top ENNReal.coe_lt_top f.prop\n\n"}
{"name":"MeasureTheory.Lp.coe_LpSubmodule","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup E\n𝕜 : Type u_5\ninst✝² : NormedRing 𝕜\ninst✝¹ : Module 𝕜 E\ninst✝ : BoundedSMul 𝕜 E\n⊢ Eq (MeasureTheory.Lp.LpSubmodule E p μ 𝕜).toAddSubgroup (MeasureTheory.Lp E p μ)","decl":"theorem coe_LpSubmodule : (LpSubmodule E p μ 𝕜).toAddSubgroup = Lp E p μ :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.coeFn_smul","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup E\n𝕜 : Type u_5\ninst✝² : NormedRing 𝕜\ninst✝¹ : Module 𝕜 E\ninst✝ : BoundedSMul 𝕜 E\nc : 𝕜\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ (MeasureTheory.ae μ).EventuallyEq (↑↑(HSMul.hSMul c f)) (HSMul.hSMul c ↑↑f)","decl":"theorem coeFn_smul (c : 𝕜) (f : Lp E p μ) : ⇑(c • f) =ᵐ[μ] c • ⇑f :=\n  AEEqFun.coeFn_smul _ _\n\n"}
{"name":"MeasureTheory.Lp.instIsCentralScalar","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁶ : NormedAddCommGroup E\n𝕜 : Type u_5\ninst✝⁵ : NormedRing 𝕜\ninst✝⁴ : Module 𝕜 E\ninst✝³ : BoundedSMul 𝕜 E\ninst✝² : Module (MulOpposite 𝕜) E\ninst✝¹ : BoundedSMul (MulOpposite 𝕜) E\ninst✝ : IsCentralScalar 𝕜 E\n⊢ IsCentralScalar 𝕜 (Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x)","decl":"instance instIsCentralScalar [Module 𝕜ᵐᵒᵖ E] [BoundedSMul 𝕜ᵐᵒᵖ E] [IsCentralScalar 𝕜 E] :\n    IsCentralScalar 𝕜 (Lp E p μ) where\n  op_smul_eq_smul k f := Subtype.ext <| op_smul_eq_smul k (f : α →ₘ[μ] E)\n\n"}
{"name":"MeasureTheory.Lp.instSMulCommClass","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁷ : NormedAddCommGroup E\n𝕜 : Type u_5\n𝕜' : Type u_6\ninst✝⁶ : NormedRing 𝕜\ninst✝⁵ : NormedRing 𝕜'\ninst✝⁴ : Module 𝕜 E\ninst✝³ : Module 𝕜' E\ninst✝² : BoundedSMul 𝕜 E\ninst✝¹ : BoundedSMul 𝕜' E\ninst✝ : SMulCommClass 𝕜 𝕜' E\n⊢ SMulCommClass 𝕜 𝕜' (Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x)","decl":"instance instSMulCommClass [SMulCommClass 𝕜 𝕜' E] : SMulCommClass 𝕜 𝕜' (Lp E p μ) where\n  smul_comm k k' f := Subtype.ext <| smul_comm k k' (f : α →ₘ[μ] E)\n\n"}
{"name":"MeasureTheory.Lp.instIsScalarTower","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁸ : NormedAddCommGroup E\n𝕜 : Type u_5\n𝕜' : Type u_6\ninst✝⁷ : NormedRing 𝕜\ninst✝⁶ : NormedRing 𝕜'\ninst✝⁵ : Module 𝕜 E\ninst✝⁴ : Module 𝕜' E\ninst✝³ : BoundedSMul 𝕜 E\ninst✝² : BoundedSMul 𝕜' E\ninst✝¹ : SMul 𝕜 𝕜'\ninst✝ : IsScalarTower 𝕜 𝕜' E\n⊢ IsScalarTower 𝕜 𝕜' (Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x)","decl":"instance instIsScalarTower [SMul 𝕜 𝕜'] [IsScalarTower 𝕜 𝕜' E] : IsScalarTower 𝕜 𝕜' (Lp E p μ) where\n  smul_assoc k k' f := Subtype.ext <| smul_assoc k k' (f : α →ₘ[μ] E)\n\n"}
{"name":"MeasureTheory.Lp.instBoundedSMul","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁴ : NormedAddCommGroup E\n𝕜 : Type u_5\ninst✝³ : NormedRing 𝕜\ninst✝² : Module 𝕜 E\ninst✝¹ : BoundedSMul 𝕜 E\ninst✝ : Fact (LE.le 1 p)\n⊢ BoundedSMul 𝕜 (Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x)","decl":"instance instBoundedSMul [Fact (1 ≤ p)] : BoundedSMul 𝕜 (Lp E p μ) :=\n  -- TODO: add `BoundedSMul.of_nnnorm_smul_le`\n  BoundedSMul.of_norm_smul_le fun r f => by\n    suffices ‖r • f‖ₑ ≤ ‖r‖ₑ * ‖f‖ₑ by\n      -- squeezed for performance reasons\n      simpa only [ge_iff_le, enorm, ←ENNReal.coe_mul, ENNReal.coe_le_coe] using this\n    simpa only [eLpNorm_congr_ae (coeFn_smul _ _), enorm_def]\n      using eLpNorm_const_smul_le (c := r) (f := f) (p := p)\n\n"}
{"name":"MeasureTheory.Memℒp.toLp_const_smul","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup E\n𝕜 : Type u_5\ninst✝² : NormedRing 𝕜\ninst✝¹ : Module 𝕜 E\ninst✝ : BoundedSMul 𝕜 E\nf : α → E\nc : 𝕜\nhf : MeasureTheory.Memℒp f p μ\n⊢ Eq (MeasureTheory.Memℒp.toLp (HSMul.hSMul c f) ⋯) (HSMul.hSMul c (MeasureTheory.Memℒp.toLp f hf))","decl":"theorem toLp_const_smul {f : α → E} (c : 𝕜) (hf : Memℒp f p μ) :\n    (hf.const_smul c).toLp (c • f) = c • hf.toLp f :=\n  rfl\n\n"}
{"name":"MeasureTheory.exists_eLpNorm_indicator_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nhp : Ne p Top.top\nc : E\nε : ENNReal\nhε : Ne ε 0\n⊢ Exists fun η => And (LT.lt 0 η) (∀ (s : Set α), LE.le (μ s) ↑η → LE.le (MeasureTheory.eLpNorm (s.indicator fun x => c) p μ) ε)","decl":"/-- The `ℒ^p` norm of the indicator of a set is uniformly small if the set itself has small measure,\nfor any `p < ∞`. Given here as an existential `∀ ε > 0, ∃ η > 0, ...` to avoid later\nmanagement of `ℝ≥0∞`-arithmetic. -/\ntheorem exists_eLpNorm_indicator_le (hp : p ≠ ∞) (c : E) {ε : ℝ≥0∞} (hε : ε ≠ 0) :\n    ∃ η : ℝ≥0, 0 < η ∧ ∀ s : Set α, μ s ≤ η → eLpNorm (s.indicator fun _ => c) p μ ≤ ε := by\n  rcases eq_or_ne p 0 with (rfl | h'p)\n  · exact ⟨1, zero_lt_one, fun s _ => by simp⟩\n  have hp₀ : 0 < p := bot_lt_iff_ne_bot.2 h'p\n  have hp₀' : 0 ≤ 1 / p.toReal := div_nonneg zero_le_one ENNReal.toReal_nonneg\n  have hp₀'' : 0 < p.toReal := ENNReal.toReal_pos hp₀.ne' hp\n  obtain ⟨η, hη_pos, hη_le⟩ : ∃ η : ℝ≥0, 0 < η ∧ ‖c‖ₑ * (η : ℝ≥0∞) ^ (1 / p.toReal) ≤ ε := by\n    have :\n      Filter.Tendsto (fun x : ℝ≥0 => ((‖c‖₊ * x ^ (1 / p.toReal) : ℝ≥0) : ℝ≥0∞)) (𝓝 0)\n        (𝓝 (0 : ℝ≥0)) := by\n      rw [ENNReal.tendsto_coe]\n      convert (NNReal.continuousAt_rpow_const (Or.inr hp₀')).tendsto.const_mul _\n      simp [hp₀''.ne']\n    have hε' : 0 < ε := hε.bot_lt\n    obtain ⟨δ, hδ, hδε'⟩ := NNReal.nhds_zero_basis.eventually_iff.mp (this.eventually_le_const hε')\n    obtain ⟨η, hη, hηδ⟩ := exists_between hδ\n    refine ⟨η, hη, ?_⟩\n    simpa only [← ENNReal.coe_rpow_of_nonneg _ hp₀', enorm, ← ENNReal.coe_mul] using hδε' hηδ\n  refine ⟨η, hη_pos, fun s hs => ?_⟩\n  refine (eLpNorm_indicator_const_le _ _).trans (le_trans ?_ hη_le)\n  exact mul_le_mul_left' (ENNReal.rpow_le_rpow hs hp₀') _\n\n"}
{"name":"HasCompactSupport.memℒp_of_bound","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"E : Type u_2\np : ENNReal\ninst✝³ : NormedAddCommGroup E\nX : Type u_5\ninst✝² : TopologicalSpace X\ninst✝¹ : MeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ\nf : X → E\nhf : HasCompactSupport f\nh2f : MeasureTheory.AEStronglyMeasurable f μ\nC : Real\nhfC : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) C) (MeasureTheory.ae μ)\n⊢ MeasureTheory.Memℒp f p μ","decl":"/-- A bounded measurable function with compact support is in L^p. -/\ntheorem _root_.HasCompactSupport.memℒp_of_bound {f : X → E} (hf : HasCompactSupport f)\n    (h2f : AEStronglyMeasurable f μ) (C : ℝ) (hfC : ∀ᵐ x ∂μ, ‖f x‖ ≤ C) : Memℒp f p μ := by\n  have := memℒp_top_of_bound h2f C hfC\n  exact this.mono_exponent_of_measure_support_ne_top\n    (fun x ↦ image_eq_zero_of_nmem_tsupport) (hf.measure_lt_top.ne) le_top\n\n"}
{"name":"Continuous.memℒp_of_hasCompactSupport","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"E : Type u_2\np : ENNReal\ninst✝⁴ : NormedAddCommGroup E\nX : Type u_5\ninst✝³ : TopologicalSpace X\ninst✝² : MeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ\ninst✝ : OpensMeasurableSpace X\nf : X → E\nhf : Continuous f\nh'f : HasCompactSupport f\n⊢ MeasureTheory.Memℒp f p μ","decl":"/-- A continuous function with compact support is in L^p. -/\ntheorem _root_.Continuous.memℒp_of_hasCompactSupport [OpensMeasurableSpace X]\n    {f : X → E} (hf : Continuous f) (h'f : HasCompactSupport f) : Memℒp f p μ := by\n  have := hf.memℒp_top_of_hasCompactSupport h'f μ\n  exact this.mono_exponent_of_measure_support_ne_top\n    (fun x ↦ image_eq_zero_of_nmem_tsupport) (h'f.measure_lt_top.ne) le_top\n\n"}
{"name":"MeasureTheory.indicatorConstLp_add","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns : Set α\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nc c' : E\n⊢ Eq (HAdd.hAdd (MeasureTheory.indicatorConstLp p hs hμs c) (MeasureTheory.indicatorConstLp p hs hμs c')) (MeasureTheory.indicatorConstLp p hs hμs (HAdd.hAdd c c'))","decl":"/-- A version of `Set.indicator_add` for `MeasureTheory.indicatorConstLp`.-/\ntheorem indicatorConstLp_add {c' : E} :\n    indicatorConstLp p hs hμs c + indicatorConstLp p hs hμs c' =\n    indicatorConstLp p hs hμs (c + c') := by\n  simp_rw [indicatorConstLp, ← Memℒp.toLp_add, indicator_add]\n  rfl\n\n"}
{"name":"MeasureTheory.indicatorConstLp_sub","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns : Set α\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nc c' : E\n⊢ Eq (HSub.hSub (MeasureTheory.indicatorConstLp p hs hμs c) (MeasureTheory.indicatorConstLp p hs hμs c')) (MeasureTheory.indicatorConstLp p hs hμs (HSub.hSub c c'))","decl":"/-- A version of `Set.indicator_sub` for `MeasureTheory.indicatorConstLp`.-/\ntheorem indicatorConstLp_sub {c' : E} :\n    indicatorConstLp p hs hμs c - indicatorConstLp p hs hμs c' =\n    indicatorConstLp p hs hμs (c - c') := by\n  simp_rw [indicatorConstLp, ← Memℒp.toLp_sub, indicator_sub]\n  rfl\n\n"}
{"name":"MeasureTheory.indicatorConstLp_coeFn","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns : Set α\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nc : E\n⊢ (MeasureTheory.ae μ).EventuallyEq (↑↑(MeasureTheory.indicatorConstLp p hs hμs c)) (s.indicator fun x => c)","decl":"theorem indicatorConstLp_coeFn : ⇑(indicatorConstLp p hs hμs c) =ᵐ[μ] s.indicator fun _ => c :=\n  Memℒp.coeFn_toLp (memℒp_indicator_const p hs c (Or.inr hμs))\n\n"}
{"name":"MeasureTheory.indicatorConstLp_coeFn_mem","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns : Set α\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nc : E\n⊢ Filter.Eventually (fun x => Membership.mem s x → Eq (↑↑(MeasureTheory.indicatorConstLp p hs hμs c) x) c) (MeasureTheory.ae μ)","decl":"theorem indicatorConstLp_coeFn_mem : ∀ᵐ x : α ∂μ, x ∈ s → indicatorConstLp p hs hμs c x = c :=\n  indicatorConstLp_coeFn.mono fun _x hx hxs => hx.trans (Set.indicator_of_mem hxs _)\n\n"}
{"name":"MeasureTheory.indicatorConstLp_coeFn_nmem","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns : Set α\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nc : E\n⊢ Filter.Eventually (fun x => Not (Membership.mem s x) → Eq (↑↑(MeasureTheory.indicatorConstLp p hs hμs c) x) 0) (MeasureTheory.ae μ)","decl":"theorem indicatorConstLp_coeFn_nmem : ∀ᵐ x : α ∂μ, x ∉ s → indicatorConstLp p hs hμs c x = 0 :=\n  indicatorConstLp_coeFn.mono fun _x hx hxs => hx.trans (Set.indicator_of_not_mem hxs _)\n\n"}
{"name":"MeasureTheory.norm_indicatorConstLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns : Set α\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nc : E\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\n⊢ Eq (Norm.norm (MeasureTheory.indicatorConstLp p hs hμs c)) (HMul.hMul (Norm.norm c) (HPow.hPow (μ s).toReal (HDiv.hDiv 1 p.toReal)))","decl":"theorem norm_indicatorConstLp (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ∞) :\n    ‖indicatorConstLp p hs hμs c‖ = ‖c‖ * (μ s).toReal ^ (1 / p.toReal) := by\n  rw [Lp.norm_def, eLpNorm_congr_ae indicatorConstLp_coeFn,\n    eLpNorm_indicator_const hs hp_ne_zero hp_ne_top, ENNReal.toReal_mul, ENNReal.toReal_rpow,\n    toReal_enorm]\n\n"}
{"name":"MeasureTheory.norm_indicatorConstLp_top","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns : Set α\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nc : E\nhμs_ne_zero : Ne (μ s) 0\n⊢ Eq (Norm.norm (MeasureTheory.indicatorConstLp Top.top hs hμs c)) (Norm.norm c)","decl":"theorem norm_indicatorConstLp_top (hμs_ne_zero : μ s ≠ 0) :\n    ‖indicatorConstLp ∞ hs hμs c‖ = ‖c‖ := by\n  rw [Lp.norm_def, eLpNorm_congr_ae indicatorConstLp_coeFn,\n    eLpNorm_indicator_const' hs hμs_ne_zero ENNReal.top_ne_zero, ENNReal.top_toReal,\n    _root_.div_zero, ENNReal.rpow_zero, mul_one, toReal_enorm]\n\n"}
{"name":"MeasureTheory.norm_indicatorConstLp'","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns : Set α\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nc : E\nhp_pos : Ne p 0\nhμs_pos : Ne (μ s) 0\n⊢ Eq (Norm.norm (MeasureTheory.indicatorConstLp p hs hμs c)) (HMul.hMul (Norm.norm c) (HPow.hPow (μ s).toReal (HDiv.hDiv 1 p.toReal)))","decl":"theorem norm_indicatorConstLp' (hp_pos : p ≠ 0) (hμs_pos : μ s ≠ 0) :\n    ‖indicatorConstLp p hs hμs c‖ = ‖c‖ * (μ s).toReal ^ (1 / p.toReal) := by\n  by_cases hp_top : p = ∞\n  · rw [hp_top, ENNReal.top_toReal, _root_.div_zero, Real.rpow_zero, mul_one]\n    exact norm_indicatorConstLp_top hμs_pos\n  · exact norm_indicatorConstLp hp_pos hp_top\n\n"}
{"name":"MeasureTheory.norm_indicatorConstLp_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns : Set α\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nc : E\n⊢ LE.le (Norm.norm (MeasureTheory.indicatorConstLp p hs hμs c)) (HMul.hMul (Norm.norm c) (HPow.hPow (μ s).toReal (HDiv.hDiv 1 p.toReal)))","decl":"theorem norm_indicatorConstLp_le :\n    ‖indicatorConstLp p hs hμs c‖ ≤ ‖c‖ * (μ s).toReal ^ (1 / p.toReal) := by\n  rw [indicatorConstLp, Lp.norm_toLp]\n  refine ENNReal.toReal_le_of_le_ofReal (by positivity) ?_\n  refine (eLpNorm_indicator_const_le _ _).trans_eq ?_\n  rw [ENNReal.ofReal_mul (norm_nonneg _), ofReal_norm, ENNReal.toReal_rpow, ENNReal.ofReal_toReal]\n  exact ENNReal.rpow_ne_top_of_nonneg (by positivity) hμs\n\n"}
{"name":"MeasureTheory.nnnorm_indicatorConstLp_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns : Set α\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nc : E\n⊢ LE.le (NNNorm.nnnorm (MeasureTheory.indicatorConstLp p hs hμs c)) (HMul.hMul (NNNorm.nnnorm c) (HPow.hPow (μ s).toNNReal (HDiv.hDiv 1 p.toReal)))","decl":"theorem nnnorm_indicatorConstLp_le :\n    ‖indicatorConstLp p hs hμs c‖₊ ≤ ‖c‖₊ * (μ s).toNNReal ^ (1 / p.toReal) :=\n  norm_indicatorConstLp_le\n\n"}
{"name":"MeasureTheory.enorm_indicatorConstLp_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns : Set α\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nc : E\n⊢ LE.le (ENorm.enorm (MeasureTheory.indicatorConstLp p hs hμs c)) (HMul.hMul (ENorm.enorm c) (HPow.hPow (μ s) (HDiv.hDiv 1 p.toReal)))","decl":"theorem enorm_indicatorConstLp_le :\n    ‖indicatorConstLp p hs hμs c‖ₑ ≤ ‖c‖ₑ * μ s ^ (1 / p.toReal) := by\n  simpa [ENNReal.coe_rpow_of_nonneg, ENNReal.coe_toNNReal hμs, Lp.enorm_def, ← enorm_eq_nnnorm]\n    using ENNReal.coe_le_coe.2 <| nnnorm_indicatorConstLp_le (c := c) (hμs := hμs)\n\n"}
{"name":"MeasureTheory.ennnorm_indicatorConstLp_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns : Set α\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nc : E\n⊢ LE.le (ENorm.enorm (MeasureTheory.indicatorConstLp p hs hμs c)) (HMul.hMul (ENorm.enorm c) (HPow.hPow (μ s) (HDiv.hDiv 1 p.toReal)))","decl":"@[deprecated (since := \"2025-01-20\")] alias ennnorm_indicatorConstLp_le := enorm_indicatorConstLp_le\n\n"}
{"name":"MeasureTheory.edist_indicatorConstLp_eq_enorm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns : Set α\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nc : E\nt : Set α\nht : MeasurableSet t\nhμt : Ne (μ t) Top.top\n⊢ Eq (EDist.edist (MeasureTheory.indicatorConstLp p hs hμs c) (MeasureTheory.indicatorConstLp p ht hμt c)) (ENorm.enorm (MeasureTheory.indicatorConstLp p ⋯ ⋯ c))","decl":"theorem edist_indicatorConstLp_eq_enorm {t : Set α} {ht : MeasurableSet t} {hμt : μ t ≠ ∞} :\n    edist (indicatorConstLp p hs hμs c) (indicatorConstLp p ht hμt c) =\n      ‖indicatorConstLp p (hs.symmDiff ht) (measure_symmDiff_ne_top hμs hμt) c‖ₑ := by\n  unfold indicatorConstLp\n  rw [Lp.edist_toLp_toLp, eLpNorm_indicator_sub_indicator, Lp.enorm_toLp]\n\n"}
{"name":"MeasureTheory.edist_indicatorConstLp_eq_nnnorm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns : Set α\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nc : E\nt : Set α\nht : MeasurableSet t\nhμt : Ne (μ t) Top.top\n⊢ Eq (EDist.edist (MeasureTheory.indicatorConstLp p hs hμs c) (MeasureTheory.indicatorConstLp p ht hμt c)) (ENorm.enorm (MeasureTheory.indicatorConstLp p ⋯ ⋯ c))","decl":"@[deprecated (since := \"2025-01-20\")]\nalias edist_indicatorConstLp_eq_nnnorm := edist_indicatorConstLp_eq_enorm\n\n"}
{"name":"MeasureTheory.dist_indicatorConstLp_eq_norm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns : Set α\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nc : E\nt : Set α\nht : MeasurableSet t\nhμt : Ne (μ t) Top.top\n⊢ Eq (Dist.dist (MeasureTheory.indicatorConstLp p hs hμs c) (MeasureTheory.indicatorConstLp p ht hμt c)) (Norm.norm (MeasureTheory.indicatorConstLp p ⋯ ⋯ c))","decl":"theorem dist_indicatorConstLp_eq_norm {t : Set α} {ht : MeasurableSet t} {hμt : μ t ≠ ∞} :\n    dist (indicatorConstLp p hs hμs c) (indicatorConstLp p ht hμt c) =\n      ‖indicatorConstLp p (hs.symmDiff ht) (measure_symmDiff_ne_top hμs hμt) c‖ := by\n  -- Squeezed for performance reasons\n  simp only [Lp.dist_edist, edist_indicatorConstLp_eq_enorm, enorm, ENNReal.coe_toReal,\n    Lp.coe_nnnorm]\n\n"}
{"name":"MeasureTheory.tendsto_indicatorConstLp_set","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns : Set α\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nc : E\nhp₁ : Fact (LE.le 1 p)\nβ : Type u_5\nl : Filter β\nt : β → Set α\nht : ∀ (b : β), MeasurableSet (t b)\nhμt : ∀ (b : β), Ne (μ (t b)) Top.top\nhp : Ne p Top.top\nh : Filter.Tendsto (fun b => μ (symmDiff (t b) s)) l (nhds 0)\n⊢ Filter.Tendsto (fun b => MeasureTheory.indicatorConstLp p ⋯ ⋯ c) l (nhds (MeasureTheory.indicatorConstLp p hs hμs c))","decl":"/-- A family of `indicatorConstLp` functions tends to an `indicatorConstLp`,\nif the underlying sets tend to the set in the sense of the measure of the symmetric difference. -/\ntheorem tendsto_indicatorConstLp_set [hp₁ : Fact (1 ≤ p)] {β : Type*} {l : Filter β} {t : β → Set α}\n    {ht : ∀ b, MeasurableSet (t b)} {hμt : ∀ b, μ (t b) ≠ ∞} (hp : p ≠ ∞)\n    (h : Tendsto (fun b ↦ μ (t b ∆ s)) l (𝓝 0)) :\n    Tendsto (fun b ↦ indicatorConstLp p (ht b) (hμt b) c) l (𝓝 (indicatorConstLp p hs hμs c)) := by\n  rw [tendsto_iff_dist_tendsto_zero]\n  have hp₀ : p ≠ 0 := (one_pos.trans_le hp₁.out).ne'\n  simp only [dist_indicatorConstLp_eq_norm, norm_indicatorConstLp hp₀ hp]\n  convert tendsto_const_nhds.mul\n    (((ENNReal.tendsto_toReal ENNReal.zero_ne_top).comp h).rpow_const _)\n  · simp [Real.rpow_eq_zero_iff_of_nonneg, ENNReal.toReal_eq_zero_iff, hp, hp₀]\n  · simp\n\n"}
{"name":"MeasureTheory.continuous_indicatorConstLp_set","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝² : NormedAddCommGroup E\nc : E\ninst✝¹ : Fact (LE.le 1 p)\nX : Type u_5\ninst✝ : TopologicalSpace X\ns : X → Set α\nhs : ∀ (x : X), MeasurableSet (s x)\nhμs : ∀ (x : X), Ne (μ (s x)) Top.top\nhp : Ne p Top.top\nh : ∀ (x : X), Filter.Tendsto (fun y => μ (symmDiff (s y) (s x))) (nhds x) (nhds 0)\n⊢ Continuous fun x => MeasureTheory.indicatorConstLp p ⋯ ⋯ c","decl":"/-- A family of `indicatorConstLp` functions is continuous in the parameter,\nif `μ (s y ∆ s x)` tends to zero as `y` tends to `x` for all `x`. -/\ntheorem continuous_indicatorConstLp_set [Fact (1 ≤ p)] {X : Type*} [TopologicalSpace X]\n    {s : X → Set α} {hs : ∀ x, MeasurableSet (s x)} {hμs : ∀ x, μ (s x) ≠ ∞} (hp : p ≠ ∞)\n    (h : ∀ x, Tendsto (fun y ↦ μ (s y ∆ s x)) (𝓝 x) (𝓝 0)) :\n    Continuous fun x ↦ indicatorConstLp p (hs x) (hμs x) c :=\n  continuous_iff_continuousAt.2 fun x ↦ tendsto_indicatorConstLp_set hp (h x)\n\n"}
{"name":"MeasureTheory.indicatorConstLp_empty","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nc : E\n⊢ Eq (MeasureTheory.indicatorConstLp p ⋯ ⋯ c) 0","decl":"@[simp]\ntheorem indicatorConstLp_empty :\n    indicatorConstLp p MeasurableSet.empty (by simp : μ ∅ ≠ ∞) c = 0 := by\n  simp only [indicatorConstLp, Set.indicator_empty', Memℒp.toLp_zero]\n\n"}
{"name":"MeasureTheory.indicatorConstLp_inj","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns t : Set α\nhs : MeasurableSet s\nhsμ : Ne (μ s) Top.top\nht : MeasurableSet t\nhtμ : Ne (μ t) Top.top\nc : E\nhc : Ne c 0\n⊢ Iff (Eq (MeasureTheory.indicatorConstLp p hs hsμ c) (MeasureTheory.indicatorConstLp p ht htμ c)) ((MeasureTheory.ae μ).EventuallyEq s t)","decl":"theorem indicatorConstLp_inj {s t : Set α} (hs : MeasurableSet s) (hsμ : μ s ≠ ∞)\n    (ht : MeasurableSet t) (htμ : μ t ≠ ∞) {c : E} (hc : c ≠ 0) :\n    indicatorConstLp p hs hsμ c = indicatorConstLp p ht htμ c ↔ s =ᵐ[μ] t := by\n  simp_rw [← indicator_const_eventuallyEq hc, indicatorConstLp, Memℒp.toLp_eq_toLp_iff]\n\n"}
{"name":"MeasureTheory.memℒp_add_of_disjoint","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf g : α → E\nh : Disjoint (Function.support f) (Function.support g)\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\n⊢ Iff (MeasureTheory.Memℒp (HAdd.hAdd f g) p μ) (And (MeasureTheory.Memℒp f p μ) (MeasureTheory.Memℒp g p μ))","decl":"theorem memℒp_add_of_disjoint {f g : α → E} (h : Disjoint (support f) (support g))\n    (hf : StronglyMeasurable f) (hg : StronglyMeasurable g) :\n    Memℒp (f + g) p μ ↔ Memℒp f p μ ∧ Memℒp g p μ := by\n  borelize E\n  refine ⟨fun hfg => ⟨?_, ?_⟩, fun h => h.1.add h.2⟩\n  · rw [← Set.indicator_add_eq_left h]; exact hfg.indicator (measurableSet_support hf.measurable)\n  · rw [← Set.indicator_add_eq_right h]; exact hfg.indicator (measurableSet_support hg.measurable)\n\n"}
{"name":"MeasureTheory.indicatorConstLp_disjoint_union","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns t : Set α\nhs : MeasurableSet s\nht : MeasurableSet t\nhμs : Ne (μ s) Top.top\nhμt : Ne (μ t) Top.top\nhst : Disjoint s t\nc : E\n⊢ Eq (MeasureTheory.indicatorConstLp p ⋯ ⋯ c) (HAdd.hAdd (MeasureTheory.indicatorConstLp p hs hμs c) (MeasureTheory.indicatorConstLp p ht hμt c))","decl":"/-- The indicator of a disjoint union of two sets is the sum of the indicators of the sets. -/\ntheorem indicatorConstLp_disjoint_union {s t : Set α} (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (hμs : μ s ≠ ∞) (hμt : μ t ≠ ∞) (hst : Disjoint s t) (c : E) :\n    indicatorConstLp p (hs.union ht) (measure_union_ne_top hμs hμt) c =\n      indicatorConstLp p hs hμs c + indicatorConstLp p ht hμt c := by\n  ext1\n  refine indicatorConstLp_coeFn.trans (EventuallyEq.trans ?_ (Lp.coeFn_add _ _).symm)\n  refine\n    EventuallyEq.trans ?_\n      (EventuallyEq.add indicatorConstLp_coeFn.symm indicatorConstLp_coeFn.symm)\n  rw [Set.indicator_union_of_disjoint hst]\n\n"}
{"name":"MeasureTheory.Lp.coeFn_const","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nc : E\n⊢ (MeasureTheory.ae μ).EventuallyEq (↑↑((MeasureTheory.Lp.const p μ) c)) (Function.const α c)","decl":"lemma Lp.coeFn_const : Lp.const p μ c =ᵐ[μ] Function.const α c :=\n  AEEqFun.coeFn_const α c\n\n"}
{"name":"MeasureTheory.Lp.const_val","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nc : E\n⊢ Eq (↑((MeasureTheory.Lp.const p μ) c)) (MeasureTheory.AEEqFun.const α c)","decl":"@[simp] lemma Lp.const_val : (Lp.const p μ c).1 = AEEqFun.const α c := rfl\n\n"}
{"name":"MeasureTheory.Memℒp.toLp_const","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nc : E\n⊢ Eq (MeasureTheory.Memℒp.toLp (fun x => c) ⋯) ((MeasureTheory.Lp.const p μ) c)","decl":"@[simp]\nlemma Memℒp.toLp_const : Memℒp.toLp _ (memℒp_const c) = Lp.const p μ c := rfl\n\n"}
{"name":"MeasureTheory.indicatorConstLp_univ","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nc : E\n⊢ Eq (MeasureTheory.indicatorConstLp p ⋯ ⋯ c) ((MeasureTheory.Lp.const p μ) c)","decl":"@[simp]\nlemma indicatorConstLp_univ :\n    indicatorConstLp p .univ (measure_ne_top μ _) c = Lp.const p μ c := by\n  rw [← Memℒp.toLp_const, indicatorConstLp]\n  simp only [Set.indicator_univ, Function.const]\n\n"}
{"name":"MeasureTheory.Lp.norm_const","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\nc : E\ninst✝ : NeZero μ\nhp_zero : Ne p 0\n⊢ Eq (Norm.norm ((MeasureTheory.Lp.const p μ) c)) (HMul.hMul (Norm.norm c) (HPow.hPow (μ Set.univ).toReal (HDiv.hDiv 1 p.toReal)))","decl":"theorem Lp.norm_const [NeZero μ] (hp_zero : p ≠ 0) :\n    ‖Lp.const p μ c‖ = ‖c‖ * (μ Set.univ).toReal ^ (1 / p.toReal) := by\n  have := NeZero.ne μ\n  rw [← Memℒp.toLp_const, Lp.norm_toLp, eLpNorm_const] <;> try assumption\n  rw [ENNReal.toReal_mul, toReal_enorm, ← ENNReal.toReal_rpow]\n\n"}
{"name":"MeasureTheory.Lp.norm_const'","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nc : E\nhp_zero : Ne p 0\nhp_top : Ne p Top.top\n⊢ Eq (Norm.norm ((MeasureTheory.Lp.const p μ) c)) (HMul.hMul (Norm.norm c) (HPow.hPow (μ Set.univ).toReal (HDiv.hDiv 1 p.toReal)))","decl":"theorem Lp.norm_const' (hp_zero : p ≠ 0) (hp_top : p ≠ ∞) :\n    ‖Lp.const p μ c‖ = ‖c‖ * (μ Set.univ).toReal ^ (1 / p.toReal) := by\n  rw [← Memℒp.toLp_const, Lp.norm_toLp, eLpNorm_const'] <;> try assumption\n  rw [ENNReal.toReal_mul, toReal_enorm, ← ENNReal.toReal_rpow]\n\n"}
{"name":"MeasureTheory.Lp.norm_const_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nc : E\n⊢ LE.le (Norm.norm ((MeasureTheory.Lp.const p μ) c)) (HMul.hMul (Norm.norm c) (HPow.hPow (μ Set.univ).toReal (HDiv.hDiv 1 p.toReal)))","decl":"theorem Lp.norm_const_le : ‖Lp.const p μ c‖ ≤ ‖c‖ * (μ Set.univ).toReal ^ (1 / p.toReal) := by\n  rw [← indicatorConstLp_univ]\n  exact norm_indicatorConstLp_le\n\n"}
{"name":"MeasureTheory.Lp.constₗ_apply","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : MeasureTheory.IsFiniteMeasure μ\n𝕜 : Type u_5\ninst✝² : NormedRing 𝕜\ninst✝¹ : Module 𝕜 E\ninst✝ : BoundedSMul 𝕜 E\na : E\n⊢ Eq ((MeasureTheory.Lp.constₗ p μ 𝕜) a) ((MeasureTheory.Lp.const p μ) a)","decl":"/-- `MeasureTheory.Lp.const` as a `LinearMap`. -/\n@[simps] protected def Lp.constₗ (𝕜 : Type*) [NormedRing 𝕜] [Module 𝕜 E] [BoundedSMul 𝕜 E] :\n    E →ₗ[𝕜] Lp E p μ where\n  toFun := Lp.const p μ\n  map_add' := map_add _\n  map_smul' _ _ := rfl\n\n"}
{"name":"MeasureTheory.Lp.constL_apply","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : MeasureTheory.IsFiniteMeasure μ\n𝕜 : Type u_5\ninst✝² : NormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : Fact (LE.le 1 p)\na : E\n⊢ Eq ((MeasureTheory.Lp.constL p μ 𝕜) a) ((MeasureTheory.Lp.const p μ) a)","decl":"@[simps! apply]\nprotected def Lp.constL (𝕜 : Type*) [NormedField 𝕜] [NormedSpace 𝕜 E] [Fact (1 ≤ p)] :\n    E →L[𝕜] Lp E p μ :=\n  (Lp.constₗ p μ 𝕜).mkContinuous ((μ Set.univ).toReal ^ (1 / p.toReal)) fun _ ↦\n    (Lp.norm_const_le _ _ _).trans_eq (mul_comm _ _)\n\n"}
{"name":"MeasureTheory.Lp.norm_constL_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : MeasureTheory.IsFiniteMeasure μ\n𝕜 : Type u_5\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : Fact (LE.le 1 p)\n⊢ LE.le (Norm.norm (MeasureTheory.Lp.constL p μ 𝕜)) (HPow.hPow (μ Set.univ).toReal (HDiv.hDiv 1 p.toReal))","decl":"theorem Lp.norm_constL_le (𝕜 : Type*) [NontriviallyNormedField 𝕜] [NormedSpace 𝕜 E]\n    [Fact (1 ≤ p)] :\n    ‖(Lp.constL p μ 𝕜 : E →L[𝕜] Lp E p μ)‖ ≤ (μ Set.univ).toReal ^ (1 / p.toReal) :=\n  LinearMap.mkContinuous_norm_le _ (by positivity) _\n\n"}
{"name":"MeasureTheory.Memℒp.norm_rpow_div","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nhf : MeasureTheory.Memℒp f p μ\nq : ENNReal\n⊢ MeasureTheory.Memℒp (fun x => HPow.hPow (Norm.norm (f x)) q.toReal) (HDiv.hDiv p q) μ","decl":"theorem Memℒp.norm_rpow_div {f : α → E} (hf : Memℒp f p μ) (q : ℝ≥0∞) :\n    Memℒp (fun x : α => ‖f x‖ ^ q.toReal) (p / q) μ := by\n  refine ⟨(hf.1.norm.aemeasurable.pow_const q.toReal).aestronglyMeasurable, ?_⟩\n  by_cases q_top : q = ∞\n  · simp [q_top]\n  by_cases q_zero : q = 0\n  · simp only [q_zero, ENNReal.zero_toReal, Real.rpow_zero]\n    by_cases p_zero : p = 0\n    · simp [p_zero]\n    rw [ENNReal.div_zero p_zero]\n    exact (memℒp_top_const (1 : ℝ)).2\n  rw [eLpNorm_norm_rpow _ (ENNReal.toReal_pos q_zero q_top)]\n  apply ENNReal.rpow_lt_top_of_nonneg ENNReal.toReal_nonneg\n  rw [ENNReal.ofReal_toReal q_top, div_eq_mul_inv, mul_assoc, ENNReal.inv_mul_cancel q_zero q_top,\n    mul_one]\n  exact hf.2.ne\n\n"}
{"name":"MeasureTheory.memℒp_norm_rpow_iff","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nq : ENNReal\nf : α → E\nhf : MeasureTheory.AEStronglyMeasurable f μ\nq_zero : Ne q 0\nq_top : Ne q Top.top\n⊢ Iff (MeasureTheory.Memℒp (fun x => HPow.hPow (Norm.norm (f x)) q.toReal) (HDiv.hDiv p q) μ) (MeasureTheory.Memℒp f p μ)","decl":"theorem memℒp_norm_rpow_iff {q : ℝ≥0∞} {f : α → E} (hf : AEStronglyMeasurable f μ) (q_zero : q ≠ 0)\n    (q_top : q ≠ ∞) : Memℒp (fun x : α => ‖f x‖ ^ q.toReal) (p / q) μ ↔ Memℒp f p μ := by\n  refine ⟨fun h => ?_, fun h => h.norm_rpow_div q⟩\n  apply (memℒp_norm_iff hf).1\n  convert h.norm_rpow_div q⁻¹ using 1\n  · ext x\n    rw [Real.norm_eq_abs, Real.abs_rpow_of_nonneg (norm_nonneg _), ← Real.rpow_mul (abs_nonneg _),\n      ENNReal.toReal_inv, mul_inv_cancel₀, abs_of_nonneg (norm_nonneg _), Real.rpow_one]\n    simp [ENNReal.toReal_eq_zero_iff, not_or, q_zero, q_top]\n  · rw [div_eq_mul_inv, inv_inv, div_eq_mul_inv, mul_assoc, ENNReal.inv_mul_cancel q_zero q_top,\n      mul_one]\n\n"}
{"name":"MeasureTheory.Memℒp.norm_rpow","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nhf : MeasureTheory.Memℒp f p μ\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\n⊢ MeasureTheory.Memℒp (fun x => HPow.hPow (Norm.norm (f x)) p.toReal) 1 μ","decl":"theorem Memℒp.norm_rpow {f : α → E} (hf : Memℒp f p μ) (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ∞) :\n    Memℒp (fun x : α => ‖f x‖ ^ p.toReal) 1 μ := by\n  convert hf.norm_rpow_div p\n  rw [div_eq_mul_inv, ENNReal.mul_inv_cancel hp_ne_zero hp_ne_top]\n\n"}
{"name":"MeasureTheory.AEEqFun.compMeasurePreserving_mem_Lp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\nβ : Type u_5\ninst✝ : MeasurableSpace β\nμb : MeasureTheory.Measure β\ng : MeasureTheory.AEEqFun β E μb\nhg : Membership.mem (MeasureTheory.Lp E p μb) g\nf : α → β\nhf : MeasureTheory.MeasurePreserving f μ μb\n⊢ Membership.mem (MeasureTheory.Lp E p μ) (g.compMeasurePreserving f hf)","decl":"theorem AEEqFun.compMeasurePreserving_mem_Lp {β : Type*} [MeasurableSpace β]\n    {μb : MeasureTheory.Measure β} {g : β →ₘ[μb] E} (hg : g ∈ Lp E p μb) {f : α → β}\n    (hf : MeasurePreserving f μ μb) :\n    g.compMeasurePreserving f hf ∈ Lp E p μ := by\n  rw [Lp.mem_Lp_iff_eLpNorm_lt_top] at hg ⊢\n  rwa [eLpNorm_compMeasurePreserving]\n\n"}
{"name":"MeasureTheory.Lp.compMeasurePreserving_val","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\nβ : Type u_5\ninst✝ : MeasurableSpace β\nμb : MeasureTheory.Measure β\nf : α → β\ng : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μb) x\nhf : MeasureTheory.MeasurePreserving f μ μb\n⊢ Eq (↑((MeasureTheory.Lp.compMeasurePreserving f hf) g)) ((↑g).compMeasurePreserving f hf)","decl":"@[simp]\ntheorem compMeasurePreserving_val (g : Lp E p μb) (hf : MeasurePreserving f μ μb) :\n    (compMeasurePreserving f hf g).1 = g.1.compMeasurePreserving f hf :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.coeFn_compMeasurePreserving","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\nβ : Type u_5\ninst✝ : MeasurableSpace β\nμb : MeasureTheory.Measure β\nf : α → β\ng : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μb) x\nhf : MeasureTheory.MeasurePreserving f μ μb\n⊢ (MeasureTheory.ae μ).EventuallyEq (↑↑((MeasureTheory.Lp.compMeasurePreserving f hf) g)) (Function.comp (↑↑g) f)","decl":"theorem coeFn_compMeasurePreserving (g : Lp E p μb) (hf : MeasurePreserving f μ μb) :\n    compMeasurePreserving f hf g =ᵐ[μ] g ∘ f :=\n  g.1.coeFn_compMeasurePreserving hf\n\n"}
{"name":"MeasureTheory.Lp.norm_compMeasurePreserving","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\nβ : Type u_5\ninst✝ : MeasurableSpace β\nμb : MeasureTheory.Measure β\nf : α → β\ng : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μb) x\nhf : MeasureTheory.MeasurePreserving f μ μb\n⊢ Eq (Norm.norm ((MeasureTheory.Lp.compMeasurePreserving f hf) g)) (Norm.norm g)","decl":"@[simp]\ntheorem norm_compMeasurePreserving (g : Lp E p μb) (hf : MeasurePreserving f μ μb) :\n    ‖compMeasurePreserving f hf g‖ = ‖g‖ :=\n  congr_arg ENNReal.toReal <| g.1.eLpNorm_compMeasurePreserving hf\n\n"}
{"name":"MeasureTheory.Lp.isometry_compMeasurePreserving","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝² : NormedAddCommGroup E\nβ : Type u_5\ninst✝¹ : MeasurableSpace β\nμb : MeasureTheory.Measure β\nf : α → β\ninst✝ : Fact (LE.le 1 p)\nhf : MeasureTheory.MeasurePreserving f μ μb\n⊢ Isometry ⇑(MeasureTheory.Lp.compMeasurePreserving f hf)","decl":"theorem isometry_compMeasurePreserving [Fact (1 ≤ p)] (hf : MeasurePreserving f μ μb) :\n    Isometry (compMeasurePreserving f hf : Lp E p μb → Lp E p μ) :=\n  AddMonoidHomClass.isometry_of_norm _ (norm_compMeasurePreserving · hf)\n\n"}
{"name":"MeasureTheory.Lp.toLp_compMeasurePreserving","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\nβ : Type u_5\ninst✝ : MeasurableSpace β\nμb : MeasureTheory.Measure β\nf : α → β\ng : β → E\nhg : MeasureTheory.Memℒp g p μb\nhf : MeasureTheory.MeasurePreserving f μ μb\n⊢ Eq ((MeasureTheory.Lp.compMeasurePreserving f hf) (MeasureTheory.Memℒp.toLp g hg)) (MeasureTheory.Memℒp.toLp (Function.comp g f) ⋯)","decl":"theorem toLp_compMeasurePreserving {g : β → E} (hg : Memℒp g p μb) (hf : MeasurePreserving f μ μb) :\n    compMeasurePreserving f hf (hg.toLp g) = (hg.comp_measurePreserving hf).toLp _ := rfl\n\n"}
{"name":"MeasureTheory.Lp.indicatorConstLp_compMeasurePreserving","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\nβ : Type u_5\ninst✝ : MeasurableSpace β\nμb : MeasureTheory.Measure β\nf : α → β\ns : Set β\nhs : MeasurableSet s\nhμs : Ne (μb s) Top.top\nc : E\nhf : MeasureTheory.MeasurePreserving f μ μb\n⊢ Eq ((MeasureTheory.Lp.compMeasurePreserving f hf) (MeasureTheory.indicatorConstLp p hs hμs c)) (MeasureTheory.indicatorConstLp p ⋯ ⋯ c)","decl":"theorem indicatorConstLp_compMeasurePreserving {s : Set β} (hs : MeasurableSet s)\n    (hμs : μb s ≠ ∞) (c : E) (hf : MeasurePreserving f μ μb) :\n    Lp.compMeasurePreserving f hf (indicatorConstLp p hs hμs c) =\n      indicatorConstLp p (hs.preimage hf.measurable)\n        (by rwa [hf.measure_preimage hs.nullMeasurableSet]) c :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.compMeasurePreservingₗ_apply","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁴ : NormedAddCommGroup E\nβ : Type u_5\ninst✝³ : MeasurableSpace β\nμb : MeasureTheory.Measure β\n𝕜 : Type u_6\ninst✝² : NormedRing 𝕜\ninst✝¹ : Module 𝕜 E\ninst✝ : BoundedSMul 𝕜 E\nf : α → β\nhf : MeasureTheory.MeasurePreserving f μ μb\na✝ : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μb) x\n⊢ Eq ((MeasureTheory.Lp.compMeasurePreservingₗ 𝕜 f hf) a✝) ((↑(MeasureTheory.Lp.compMeasurePreserving f hf)).toFun a✝)","decl":"/-- `MeasureTheory.Lp.compMeasurePreserving` as a linear map. -/\n@[simps]\ndef compMeasurePreservingₗ (f : α → β) (hf : MeasurePreserving f μ μb) :\n    Lp E p μb →ₗ[𝕜] Lp E p μ where\n  __ := compMeasurePreserving f hf\n  map_smul' c g := by rcases g with ⟨⟨_⟩, _⟩; rfl\n\n"}
{"name":"MeasureTheory.Lp.compMeasurePreservingₗᵢ_apply_coe","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁵ : NormedAddCommGroup E\nβ : Type u_5\ninst✝⁴ : MeasurableSpace β\nμb : MeasureTheory.Measure β\n𝕜 : Type u_6\ninst✝³ : NormedRing 𝕜\ninst✝² : Module 𝕜 E\ninst✝¹ : BoundedSMul 𝕜 E\ninst✝ : Fact (LE.le 1 p)\nf : α → β\nhf : MeasureTheory.MeasurePreserving f μ μb\na✝ : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μb) x\n⊢ Eq (↑((MeasureTheory.Lp.compMeasurePreservingₗᵢ 𝕜 f hf) a✝)) ((↑a✝).compMeasurePreserving f hf)","decl":"/-- `MeasureTheory.Lp.compMeasurePreserving` as a linear isometry. -/\n@[simps!]\ndef compMeasurePreservingₗᵢ [Fact (1 ≤ p)] (f : α → β) (hf : MeasurePreserving f μ μb) :\n    Lp E p μb →ₗᵢ[𝕜] Lp E p μ where\n  toLinearMap := compMeasurePreservingₗ 𝕜 f hf\n  norm_map' := (norm_compMeasurePreserving · hf)\n\n"}
{"name":"LipschitzWith.comp_memℒp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"p : ENNReal\nα : Type u_5\nE : Type u_6\nF : Type u_7\nK : NNReal\ninst✝² : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedAddCommGroup F\nf : α → E\ng : E → F\nhg : LipschitzWith K g\ng0 : Eq (g 0) 0\nhL : MeasureTheory.Memℒp f p μ\n⊢ MeasureTheory.Memℒp (Function.comp g f) p μ","decl":"theorem LipschitzWith.comp_memℒp {α E F} {K} [MeasurableSpace α] {μ : Measure α}\n    [NormedAddCommGroup E] [NormedAddCommGroup F] {f : α → E} {g : E → F} (hg : LipschitzWith K g)\n    (g0 : g 0 = 0) (hL : Memℒp f p μ) : Memℒp (g ∘ f) p μ :=\n  have : ∀ x, ‖g (f x)‖ ≤ K * ‖f x‖ := fun x ↦ by\n    -- TODO: add `LipschitzWith.nnnorm_sub_le` and `LipschitzWith.nnnorm_le`\n    simpa [g0] using hg.norm_sub_le (f x) 0\n  hL.of_le_mul (hg.continuous.comp_aestronglyMeasurable hL.1) (Eventually.of_forall this)\n\n"}
{"name":"MeasureTheory.Memℒp.of_comp_antilipschitzWith","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"p : ENNReal\nα : Type u_5\nE : Type u_6\nF : Type u_7\nK' : NNReal\ninst✝² : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedAddCommGroup F\nf : α → E\ng : E → F\nhL : MeasureTheory.Memℒp (Function.comp g f) p μ\nhg : UniformContinuous g\nhg' : AntilipschitzWith K' g\ng0 : Eq (g 0) 0\n⊢ MeasureTheory.Memℒp f p μ","decl":"theorem MeasureTheory.Memℒp.of_comp_antilipschitzWith {α E F} {K'} [MeasurableSpace α]\n    {μ : Measure α} [NormedAddCommGroup E] [NormedAddCommGroup F] {f : α → E} {g : E → F}\n    (hL : Memℒp (g ∘ f) p μ) (hg : UniformContinuous g) (hg' : AntilipschitzWith K' g)\n    (g0 : g 0 = 0) : Memℒp f p μ := by\n  have A : ∀ x, ‖f x‖ ≤ K' * ‖g (f x)‖ := by\n    intro x\n    -- TODO: add `AntilipschitzWith.le_mul_nnnorm_sub` and `AntilipschitzWith.le_mul_norm`\n    rw [← dist_zero_right, ← dist_zero_right, ← g0]\n    apply hg'.le_mul_dist\n  have B : AEStronglyMeasurable f μ :=\n    (hg'.isUniformEmbedding hg).isEmbedding.aestronglyMeasurable_comp_iff.1 hL.1\n  exact hL.of_le_mul B (Filter.Eventually.of_forall A)\n\n"}
{"name":"LipschitzWith.memℒp_comp_iff_of_antilipschitz","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"p : ENNReal\nα : Type u_5\nE : Type u_6\nF : Type u_7\nK K' : NNReal\ninst✝² : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedAddCommGroup F\nf : α → E\ng : E → F\nhg : LipschitzWith K g\nhg' : AntilipschitzWith K' g\ng0 : Eq (g 0) 0\n⊢ Iff (MeasureTheory.Memℒp (Function.comp g f) p μ) (MeasureTheory.Memℒp f p μ)","decl":"theorem memℒp_comp_iff_of_antilipschitz {α E F} {K K'} [MeasurableSpace α] {μ : Measure α}\n    [NormedAddCommGroup E] [NormedAddCommGroup F] {f : α → E} {g : E → F} (hg : LipschitzWith K g)\n    (hg' : AntilipschitzWith K' g) (g0 : g 0 = 0) : Memℒp (g ∘ f) p μ ↔ Memℒp f p μ :=\n  ⟨fun h => h.of_comp_antilipschitzWith hg.uniformContinuous hg' g0, fun h => hg.comp_memℒp g0 h⟩\n\n"}
{"name":"LipschitzWith.coeFn_compLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedAddCommGroup F\ng : E → F\nc : NNReal\nhg : LipschitzWith c g\ng0 : Eq (g 0) 0\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ (MeasureTheory.ae μ).EventuallyEq (↑↑(hg.compLp g0 f)) (Function.comp g ↑↑f)","decl":"theorem coeFn_compLp (hg : LipschitzWith c g) (g0 : g 0 = 0) (f : Lp E p μ) :\n    hg.compLp g0 f =ᵐ[μ] g ∘ f :=\n  AEEqFun.coeFn_comp _ hg.continuous _\n\n"}
{"name":"LipschitzWith.compLp_zero","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedAddCommGroup F\ng : E → F\nc : NNReal\nhg : LipschitzWith c g\ng0 : Eq (g 0) 0\n⊢ Eq (hg.compLp g0 0) 0","decl":"@[simp]\ntheorem compLp_zero (hg : LipschitzWith c g) (g0 : g 0 = 0) : hg.compLp g0 (0 : Lp E p μ) = 0 := by\n  rw [Lp.eq_zero_iff_ae_eq_zero]\n  apply (coeFn_compLp _ _ _).trans\n  filter_upwards [Lp.coeFn_zero E p μ] with _ ha\n  simp only [ha, g0, Function.comp_apply, Pi.zero_apply]\n\n"}
{"name":"LipschitzWith.norm_compLp_sub_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedAddCommGroup F\ng : E → F\nc : NNReal\nhg : LipschitzWith c g\ng0 : Eq (g 0) 0\nf f' : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ LE.le (Norm.norm (HSub.hSub (hg.compLp g0 f) (hg.compLp g0 f'))) (HMul.hMul (↑c) (Norm.norm (HSub.hSub f f')))","decl":"theorem norm_compLp_sub_le (hg : LipschitzWith c g) (g0 : g 0 = 0) (f f' : Lp E p μ) :\n    ‖hg.compLp g0 f - hg.compLp g0 f'‖ ≤ c * ‖f - f'‖ := by\n  apply Lp.norm_le_mul_norm_of_ae_le_mul\n  filter_upwards [hg.coeFn_compLp g0 f, hg.coeFn_compLp g0 f',\n    Lp.coeFn_sub (hg.compLp g0 f) (hg.compLp g0 f'), Lp.coeFn_sub f f'] with a ha1 ha2 ha3 ha4\n  simp only [ha1, ha2, ha3, ha4, ← dist_eq_norm, Pi.sub_apply, Function.comp_apply]\n  exact hg.dist_le_mul (f a) (f' a)\n\n"}
{"name":"LipschitzWith.norm_compLp_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedAddCommGroup F\ng : E → F\nc : NNReal\nhg : LipschitzWith c g\ng0 : Eq (g 0) 0\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ LE.le (Norm.norm (hg.compLp g0 f)) (HMul.hMul (↑c) (Norm.norm f))","decl":"theorem norm_compLp_le (hg : LipschitzWith c g) (g0 : g 0 = 0) (f : Lp E p μ) :\n    ‖hg.compLp g0 f‖ ≤ c * ‖f‖ := by\n  -- squeezed for performance reasons\n  simpa only [compLp_zero, sub_zero] using hg.norm_compLp_sub_le g0 f 0\n\n"}
{"name":"LipschitzWith.lipschitzWith_compLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedAddCommGroup F\ng : E → F\nc : NNReal\ninst✝ : Fact (LE.le 1 p)\nhg : LipschitzWith c g\ng0 : Eq (g 0) 0\n⊢ LipschitzWith c (hg.compLp g0)","decl":"theorem lipschitzWith_compLp [Fact (1 ≤ p)] (hg : LipschitzWith c g) (g0 : g 0 = 0) :\n    LipschitzWith c (hg.compLp g0 : Lp E p μ → Lp F p μ) :=\n  -- squeezed for performance reasons\n  LipschitzWith.of_dist_le_mul fun f g => by simp only [dist_eq_norm, norm_compLp_sub_le]\n\n"}
{"name":"LipschitzWith.continuous_compLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedAddCommGroup F\ng : E → F\nc : NNReal\ninst✝ : Fact (LE.le 1 p)\nhg : LipschitzWith c g\ng0 : Eq (g 0) 0\n⊢ Continuous (hg.compLp g0)","decl":"theorem continuous_compLp [Fact (1 ≤ p)] (hg : LipschitzWith c g) (g0 : g 0 = 0) :\n    Continuous (hg.compLp g0 : Lp E p μ → Lp F p μ) :=\n  (lipschitzWith_compLp hg g0).continuous\n\n"}
{"name":"ContinuousLinearMap.coeFn_compLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedAddCommGroup F\n𝕜 : Type u_5\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Filter.Eventually (fun a => Eq (↑↑(L.compLp f) a) (L (↑↑f a))) (MeasureTheory.ae μ)","decl":"theorem coeFn_compLp (L : E →L[𝕜] F) (f : Lp E p μ) : ∀ᵐ a ∂μ, (L.compLp f) a = L (f a) :=\n  LipschitzWith.coeFn_compLp _ _ _\n\n"}
{"name":"ContinuousLinearMap.coeFn_compLp'","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedAddCommGroup F\n𝕜 : Type u_5\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ (MeasureTheory.ae μ).EventuallyEq ↑↑(L.compLp f) fun a => L (↑↑f a)","decl":"theorem coeFn_compLp' (L : E →L[𝕜] F) (f : Lp E p μ) : L.compLp f =ᵐ[μ] fun a => L (f a) :=\n  L.coeFn_compLp f\n\n"}
{"name":"ContinuousLinearMap.comp_memℒp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedAddCommGroup F\n𝕜 : Type u_5\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ MeasureTheory.Memℒp (Function.comp ⇑L ↑↑f) p μ","decl":"theorem comp_memℒp (L : E →L[𝕜] F) (f : Lp E p μ) : Memℒp (L ∘ f) p μ :=\n  (Lp.memℒp (L.compLp f)).ae_eq (L.coeFn_compLp' f)\n\n"}
{"name":"ContinuousLinearMap.comp_memℒp'","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedAddCommGroup F\n𝕜 : Type u_5\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E F\nf : α → E\nhf : MeasureTheory.Memℒp f p μ\n⊢ MeasureTheory.Memℒp (Function.comp (⇑L) f) p μ","decl":"theorem comp_memℒp' (L : E →L[𝕜] F) {f : α → E} (hf : Memℒp f p μ) : Memℒp (L ∘ f) p μ :=\n  (L.comp_memℒp (hf.toLp f)).ae_eq (EventuallyEq.fun_comp hf.coeFn_toLp _)\n\n"}
{"name":"MeasureTheory.Memℒp.ofReal","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\nK : Type u_6\ninst✝ : RCLike K\nf : α → Real\nhf : MeasureTheory.Memℒp f p μ\n⊢ MeasureTheory.Memℒp (fun x => ↑(f x)) p μ","decl":"theorem _root_.MeasureTheory.Memℒp.ofReal {f : α → ℝ} (hf : Memℒp f p μ) :\n    Memℒp (fun x => (f x : K)) p μ :=\n  (@RCLike.ofRealCLM K _).comp_memℒp' hf\n\n"}
{"name":"MeasureTheory.memℒp_re_im_iff","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\nK : Type u_6\ninst✝ : RCLike K\nf : α → K\n⊢ Iff (And (MeasureTheory.Memℒp (fun x => RCLike.re (f x)) p μ) (MeasureTheory.Memℒp (fun x => RCLike.im (f x)) p μ)) (MeasureTheory.Memℒp f p μ)","decl":"theorem _root_.MeasureTheory.memℒp_re_im_iff {f : α → K} :\n    Memℒp (fun x ↦ RCLike.re (f x)) p μ ∧ Memℒp (fun x ↦ RCLike.im (f x)) p μ ↔\n      Memℒp f p μ := by\n  refine ⟨?_, fun hf => ⟨hf.re, hf.im⟩⟩\n  rintro ⟨hre, him⟩\n  convert MeasureTheory.Memℒp.add (E := K) hre.ofReal (him.ofReal.const_mul RCLike.I)\n  ext1 x\n  rw [Pi.add_apply, mul_comm, RCLike.re_add_im]\n\n"}
{"name":"ContinuousLinearMap.add_compLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedAddCommGroup F\n𝕜 : Type u_5\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜 F\nL L' : ContinuousLinearMap (RingHom.id 𝕜) E F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Eq ((HAdd.hAdd L L').compLp f) (HAdd.hAdd (L.compLp f) (L'.compLp f))","decl":"theorem add_compLp (L L' : E →L[𝕜] F) (f : Lp E p μ) :\n    (L + L').compLp f = L.compLp f + L'.compLp f := by\n  ext1\n  refine (coeFn_compLp' (L + L') f).trans ?_\n  refine EventuallyEq.trans ?_ (Lp.coeFn_add _ _).symm\n  refine\n    EventuallyEq.trans ?_ (EventuallyEq.add (L.coeFn_compLp' f).symm (L'.coeFn_compLp' f).symm)\n  filter_upwards with x\n  rw [coe_add', Pi.add_def]\n\n"}
{"name":"ContinuousLinearMap.smul_compLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedAddCommGroup F\n𝕜 : Type u_5\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : NormedSpace 𝕜 F\n𝕜' : Type u_6\ninst✝³ : NormedRing 𝕜'\ninst✝² : Module 𝕜' F\ninst✝¹ : BoundedSMul 𝕜' F\ninst✝ : SMulCommClass 𝕜 𝕜' F\nc : 𝕜'\nL : ContinuousLinearMap (RingHom.id 𝕜) E F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Eq ((HSMul.hSMul c L).compLp f) (HSMul.hSMul c (L.compLp f))","decl":"theorem smul_compLp {𝕜'} [NormedRing 𝕜'] [Module 𝕜' F] [BoundedSMul 𝕜' F] [SMulCommClass 𝕜 𝕜' F]\n    (c : 𝕜') (L : E →L[𝕜] F) (f : Lp E p μ) : (c • L).compLp f = c • L.compLp f := by\n  ext1\n  refine (coeFn_compLp' (c • L) f).trans ?_\n  refine EventuallyEq.trans ?_ (Lp.coeFn_smul _ _).symm\n  refine (L.coeFn_compLp' f).mono fun x hx => ?_\n  rw [Pi.smul_apply, hx, coe_smul', Pi.smul_def]\n\n"}
{"name":"ContinuousLinearMap.norm_compLp_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedAddCommGroup F\n𝕜 : Type u_5\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ LE.le (Norm.norm (L.compLp f)) (HMul.hMul (Norm.norm L) (Norm.norm f))","decl":"theorem norm_compLp_le (L : E →L[𝕜] F) (f : Lp E p μ) : ‖L.compLp f‖ ≤ ‖L‖ * ‖f‖ :=\n  LipschitzWith.norm_compLp_le _ _ _\n\n"}
{"name":"ContinuousLinearMap.coeFn_compLpL","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\n𝕜 : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : Fact (LE.le 1 p)\nL : ContinuousLinearMap (RingHom.id 𝕜) E F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ (MeasureTheory.ae μ).EventuallyEq ↑↑((ContinuousLinearMap.compLpL p μ L) f) fun a => L (↑↑f a)","decl":"theorem coeFn_compLpL [Fact (1 ≤ p)] (L : E →L[𝕜] F) (f : Lp E p μ) :\n    L.compLpL p μ f =ᵐ[μ] fun a => L (f a) :=\n  L.coeFn_compLp f\n\n"}
{"name":"ContinuousLinearMap.add_compLpL","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\n𝕜 : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : Fact (LE.le 1 p)\nL L' : ContinuousLinearMap (RingHom.id 𝕜) E F\n⊢ Eq (ContinuousLinearMap.compLpL p μ (HAdd.hAdd L L')) (HAdd.hAdd (ContinuousLinearMap.compLpL p μ L) (ContinuousLinearMap.compLpL p μ L'))","decl":"theorem add_compLpL [Fact (1 ≤ p)] (L L' : E →L[𝕜] F) :\n    (L + L').compLpL p μ = L.compLpL p μ + L'.compLpL p μ := by ext1 f; exact add_compLp L L' f\n\n"}
{"name":"ContinuousLinearMap.smul_compLpL","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedAddCommGroup F\n𝕜 : Type u_5\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedSpace 𝕜 F\ninst✝⁴ : Fact (LE.le 1 p)\n𝕜' : Type u_6\ninst✝³ : NormedRing 𝕜'\ninst✝² : Module 𝕜' F\ninst✝¹ : BoundedSMul 𝕜' F\ninst✝ : SMulCommClass 𝕜 𝕜' F\nc : 𝕜'\nL : ContinuousLinearMap (RingHom.id 𝕜) E F\n⊢ Eq (ContinuousLinearMap.compLpL p μ (HSMul.hSMul c L)) (HSMul.hSMul c (ContinuousLinearMap.compLpL p μ L))","decl":"theorem smul_compLpL [Fact (1 ≤ p)] {𝕜'} [NormedRing 𝕜'] [Module 𝕜' F] [BoundedSMul 𝕜' F]\n    [SMulCommClass 𝕜 𝕜' F] (c : 𝕜') (L : E →L[𝕜] F) : (c • L).compLpL p μ = c • L.compLpL p μ := by\n  ext1 f; exact smul_compLp c L f\n\n"}
{"name":"ContinuousLinearMap.norm_compLpL_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\n𝕜 : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : Fact (LE.le 1 p)\nL : ContinuousLinearMap (RingHom.id 𝕜) E F\n⊢ LE.le (Norm.norm (ContinuousLinearMap.compLpL p μ L)) (Norm.norm L)","decl":"theorem norm_compLpL_le [Fact (1 ≤ p)] (L : E →L[𝕜] F) : ‖L.compLpL p μ‖ ≤ ‖L‖ :=\n  LinearMap.mkContinuous_norm_le _ (norm_nonneg _) _\n\n"}
{"name":"MeasureTheory.indicatorConstLp_eq_toSpanSingleton_compLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nF : Type u_3\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup F\ns : Set α\ninst✝ : NormedSpace Real F\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nx : F\n⊢ Eq (MeasureTheory.indicatorConstLp 2 hs hμs x) ((ContinuousLinearMap.toSpanSingleton Real x).compLp (MeasureTheory.indicatorConstLp 2 hs hμs 1))","decl":"theorem indicatorConstLp_eq_toSpanSingleton_compLp {s : Set α} [NormedSpace ℝ F]\n    (hs : MeasurableSet s) (hμs : μ s ≠ ∞) (x : F) :\n    indicatorConstLp 2 hs hμs x =\n      (ContinuousLinearMap.toSpanSingleton ℝ x).compLp (indicatorConstLp 2 hs hμs (1 : ℝ)) := by\n  ext1\n  refine indicatorConstLp_coeFn.trans ?_\n  have h_compLp :=\n    (ContinuousLinearMap.toSpanSingleton ℝ x).coeFn_compLp (indicatorConstLp 2 hs hμs (1 : ℝ))\n  rw [← EventuallyEq] at h_compLp\n  refine EventuallyEq.trans ?_ h_compLp.symm\n  refine (@indicatorConstLp_coeFn _ _ _ 2 μ _ s hs hμs (1 : ℝ)).mono fun y hy => ?_\n  dsimp only\n  rw [hy]\n  simp_rw [ContinuousLinearMap.toSpanSingleton_apply]\n  by_cases hy_mem : y ∈ s <;> simp [hy_mem]\n\n"}
{"name":"MeasureTheory.Lp.lipschitzWith_pos_part","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"⊢ LipschitzWith 1 fun x => Max.max x 0","decl":"theorem lipschitzWith_pos_part : LipschitzWith 1 fun x : ℝ => max x 0 :=\n  LipschitzWith.id.max_const _\n\n"}
{"name":"MeasureTheory.Memℒp.pos_part","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.Memℒp f p μ\n⊢ MeasureTheory.Memℒp (fun x => Max.max (f x) 0) p μ","decl":"theorem _root_.MeasureTheory.Memℒp.pos_part {f : α → ℝ} (hf : Memℒp f p μ) :\n    Memℒp (fun x => max (f x) 0) p μ :=\n  lipschitzWith_pos_part.comp_memℒp (max_eq_right le_rfl) hf\n\n"}
{"name":"MeasureTheory.Memℒp.neg_part","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.Memℒp f p μ\n⊢ MeasureTheory.Memℒp (fun x => Max.max (Neg.neg (f x)) 0) p μ","decl":"theorem _root_.MeasureTheory.Memℒp.neg_part {f : α → ℝ} (hf : Memℒp f p μ) :\n    Memℒp (fun x => max (-f x) 0) p μ :=\n  lipschitzWith_pos_part.comp_memℒp (max_eq_right le_rfl) hf.neg\n\n"}
{"name":"MeasureTheory.Lp.coe_posPart","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp Real p μ) x\n⊢ Eq (↑(MeasureTheory.Lp.posPart f)) (↑f).posPart","decl":"@[norm_cast]\ntheorem coe_posPart (f : Lp ℝ p μ) : (posPart f : α →ₘ[μ] ℝ) = (f : α →ₘ[μ] ℝ).posPart :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.coeFn_posPart","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp Real p μ) x\n⊢ (MeasureTheory.ae μ).EventuallyEq ↑↑(MeasureTheory.Lp.posPart f) fun a => Max.max (↑↑f a) 0","decl":"theorem coeFn_posPart (f : Lp ℝ p μ) : ⇑(posPart f) =ᵐ[μ] fun a => max (f a) 0 :=\n  AEEqFun.coeFn_posPart _\n\n"}
{"name":"MeasureTheory.Lp.coeFn_negPart_eq_max","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp Real p μ) x\n⊢ Filter.Eventually (fun a => Eq (↑↑(MeasureTheory.Lp.negPart f) a) (Max.max (Neg.neg (↑↑f a)) 0)) (MeasureTheory.ae μ)","decl":"theorem coeFn_negPart_eq_max (f : Lp ℝ p μ) : ∀ᵐ a ∂μ, negPart f a = max (-f a) 0 := by\n  rw [negPart]\n  filter_upwards [coeFn_posPart (-f), coeFn_neg f] with _ h₁ h₂\n  rw [h₁, h₂, Pi.neg_apply]\n\n"}
{"name":"MeasureTheory.Lp.coeFn_negPart","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp Real p μ) x\n⊢ Filter.Eventually (fun a => Eq (↑↑(MeasureTheory.Lp.negPart f) a) (Neg.neg (Min.min (↑↑f a) 0))) (MeasureTheory.ae μ)","decl":"theorem coeFn_negPart (f : Lp ℝ p μ) : ∀ᵐ a ∂μ, negPart f a = -min (f a) 0 :=\n  (coeFn_negPart_eq_max f).mono fun a h => by rw [h, ← max_neg_neg, neg_zero]\n\n"}
{"name":"MeasureTheory.Lp.continuous_posPart","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : Fact (LE.le 1 p)\n⊢ Continuous fun f => MeasureTheory.Lp.posPart f","decl":"theorem continuous_posPart [Fact (1 ≤ p)] : Continuous fun f : Lp ℝ p μ => posPart f :=\n  LipschitzWith.continuous_compLp _ _\n\n"}
{"name":"MeasureTheory.Lp.continuous_negPart","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : Fact (LE.le 1 p)\n⊢ Continuous fun f => MeasureTheory.Lp.negPart f","decl":"theorem continuous_negPart [Fact (1 ≤ p)] : Continuous fun f : Lp ℝ p μ => negPart f := by\n  unfold negPart\n  exact continuous_posPart.comp continuous_neg\n\n"}
{"name":"MeasureTheory.Lp.eLpNorm'_lim_eq_lintegral_liminf","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nG : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : NormedAddCommGroup G\nι : Type u_5\ninst✝¹ : Nonempty ι\ninst✝ : LinearOrder ι\nf : ι → α → G\np : Real\nf_lim : α → G\nh_lim : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (f_lim x))) (MeasureTheory.ae μ)\n⊢ Eq (MeasureTheory.eLpNorm' f_lim p μ) (HPow.hPow (MeasureTheory.lintegral μ fun a => Filter.liminf (fun x => HPow.hPow (ENorm.enorm (f x a)) p) Filter.atTop) (HDiv.hDiv 1 p))","decl":"theorem eLpNorm'_lim_eq_lintegral_liminf {ι} [Nonempty ι] [LinearOrder ι] {f : ι → α → G} {p : ℝ}\n    {f_lim : α → G} (h_lim : ∀ᵐ x : α ∂μ, Tendsto (fun n => f n x) atTop (𝓝 (f_lim x))) :\n    eLpNorm' f_lim p μ = (∫⁻ a, atTop.liminf (‖f · a‖ₑ ^ p) ∂μ) ^ (1 / p) := by\n  suffices h_no_pow : (∫⁻ a, ‖f_lim a‖ₑ ^ p ∂μ) = ∫⁻ a, atTop.liminf fun m => ‖f m a‖ₑ ^ p ∂μ by\n    rw [eLpNorm'_eq_lintegral_enorm, h_no_pow]\n  refine lintegral_congr_ae (h_lim.mono fun a ha => ?_)\n  dsimp only\n  rw [Tendsto.liminf_eq]\n  refine (ENNReal.continuous_rpow_const.tendsto ‖f_lim a‖₊).comp ?_\n  exact (continuous_enorm.tendsto (f_lim a)).comp ha\n\n"}
{"name":"MeasureTheory.Lp.eLpNorm'_lim_le_liminf_eLpNorm'","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_5\ninst✝ : NormedAddCommGroup E\nf : Nat → α → E\np : Real\nhp_pos : LT.lt 0 p\nhf : ∀ (n : Nat), MeasureTheory.AEStronglyMeasurable (f n) μ\nf_lim : α → E\nh_lim : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (f_lim x))) (MeasureTheory.ae μ)\n⊢ LE.le (MeasureTheory.eLpNorm' f_lim p μ) (Filter.liminf (fun n => MeasureTheory.eLpNorm' (f n) p μ) Filter.atTop)","decl":"theorem eLpNorm'_lim_le_liminf_eLpNorm' {E} [NormedAddCommGroup E] {f : ℕ → α → E} {p : ℝ}\n    (hp_pos : 0 < p) (hf : ∀ n, AEStronglyMeasurable (f n) μ) {f_lim : α → E}\n    (h_lim : ∀ᵐ x : α ∂μ, Tendsto (fun n => f n x) atTop (𝓝 (f_lim x))) :\n    eLpNorm' f_lim p μ ≤ atTop.liminf fun n => eLpNorm' (f n) p μ := by\n  rw [eLpNorm'_lim_eq_lintegral_liminf h_lim]\n  rw [one_div, ← ENNReal.le_rpow_inv_iff (by simp [hp_pos] : 0 < p⁻¹), inv_inv]\n  refine (lintegral_liminf_le' fun m => (hf m).enorm.pow_const _).trans_eq ?_\n  have h_pow_liminf :\n    atTop.liminf (fun n ↦ eLpNorm' (f n) p μ) ^ p\n      = atTop.liminf fun n ↦ eLpNorm' (f n) p μ ^ p := by\n    have h_rpow_mono := ENNReal.strictMono_rpow_of_pos hp_pos\n    have h_rpow_surj := (ENNReal.rpow_left_bijective hp_pos.ne.symm).2\n    refine (h_rpow_mono.orderIsoOfSurjective _ h_rpow_surj).liminf_apply ?_ ?_ ?_ ?_\n    all_goals isBoundedDefault\n  rw [h_pow_liminf]\n  simp_rw [eLpNorm'_eq_lintegral_enorm, ← ENNReal.rpow_mul, one_div,\n    inv_mul_cancel₀ hp_pos.ne.symm, ENNReal.rpow_one]\n\n"}
{"name":"MeasureTheory.Lp.eLpNorm_exponent_top_lim_eq_essSup_liminf","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nG : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : NormedAddCommGroup G\nι : Type u_5\ninst✝¹ : Nonempty ι\ninst✝ : LinearOrder ι\nf : ι → α → G\nf_lim : α → G\nh_lim : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (f_lim x))) (MeasureTheory.ae μ)\n⊢ Eq (MeasureTheory.eLpNorm f_lim Top.top μ) (essSup (fun x => Filter.liminf (fun m => ENorm.enorm (f m x)) Filter.atTop) μ)","decl":"theorem eLpNorm_exponent_top_lim_eq_essSup_liminf {ι} [Nonempty ι] [LinearOrder ι] {f : ι → α → G}\n    {f_lim : α → G} (h_lim : ∀ᵐ x : α ∂μ, Tendsto (fun n => f n x) atTop (𝓝 (f_lim x))) :\n    eLpNorm f_lim ∞ μ = essSup (fun x => atTop.liminf fun m => ‖f m x‖ₑ) μ := by\n  rw [eLpNorm_exponent_top, eLpNormEssSup_eq_essSup_enorm]\n  refine essSup_congr_ae (h_lim.mono fun x hx => ?_)\n  dsimp only\n  apply (Tendsto.liminf_eq ..).symm\n  exact (continuous_enorm.tendsto (f_lim x)).comp hx\n\n"}
{"name":"MeasureTheory.Lp.eLpNorm_exponent_top_lim_le_liminf_eLpNorm_exponent_top","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nF : Type u_3\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup F\nι : Type u_5\ninst✝² : Nonempty ι\ninst✝¹ : Countable ι\ninst✝ : LinearOrder ι\nf : ι → α → F\nf_lim : α → F\nh_lim : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (f_lim x))) (MeasureTheory.ae μ)\n⊢ LE.le (MeasureTheory.eLpNorm f_lim Top.top μ) (Filter.liminf (fun n => MeasureTheory.eLpNorm (f n) Top.top μ) Filter.atTop)","decl":"theorem eLpNorm_exponent_top_lim_le_liminf_eLpNorm_exponent_top {ι} [Nonempty ι] [Countable ι]\n    [LinearOrder ι] {f : ι → α → F} {f_lim : α → F}\n    (h_lim : ∀ᵐ x : α ∂μ, Tendsto (fun n => f n x) atTop (𝓝 (f_lim x))) :\n    eLpNorm f_lim ∞ μ ≤ atTop.liminf fun n => eLpNorm (f n) ∞ μ := by\n  rw [eLpNorm_exponent_top_lim_eq_essSup_liminf h_lim]\n  simp_rw [eLpNorm_exponent_top, eLpNormEssSup]\n  exact ENNReal.essSup_liminf_le _\n\n"}
{"name":"MeasureTheory.Lp.eLpNorm_lim_le_liminf_eLpNorm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\nE : Type u_5\ninst✝ : NormedAddCommGroup E\nf : Nat → α → E\nhf : ∀ (n : Nat), MeasureTheory.AEStronglyMeasurable (f n) μ\nf_lim : α → E\nh_lim : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (f_lim x))) (MeasureTheory.ae μ)\n⊢ LE.le (MeasureTheory.eLpNorm f_lim p μ) (Filter.liminf (fun n => MeasureTheory.eLpNorm (f n) p μ) Filter.atTop)","decl":"theorem eLpNorm_lim_le_liminf_eLpNorm {E} [NormedAddCommGroup E] {f : ℕ → α → E}\n    (hf : ∀ n, AEStronglyMeasurable (f n) μ) (f_lim : α → E)\n    (h_lim : ∀ᵐ x : α ∂μ, Tendsto (fun n => f n x) atTop (𝓝 (f_lim x))) :\n    eLpNorm f_lim p μ ≤ atTop.liminf fun n => eLpNorm (f n) p μ := by\n  obtain rfl|hp0 := eq_or_ne p 0\n  · simp\n  by_cases hp_top : p = ∞\n  · simp_rw [hp_top]\n    exact eLpNorm_exponent_top_lim_le_liminf_eLpNorm_exponent_top h_lim\n  simp_rw [eLpNorm_eq_eLpNorm' hp0 hp_top]\n  have hp_pos : 0 < p.toReal := ENNReal.toReal_pos hp0 hp_top\n  exact eLpNorm'_lim_le_liminf_eLpNorm' hp_pos hf h_lim\n\n"}
{"name":"MeasureTheory.Lp.tendsto_Lp_iff_tendsto_ℒp'","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\nι : Type u_5\nfi : Filter ι\ninst✝ : Fact (LE.le 1 p)\nf : ι → Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\nf_lim : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Iff (Filter.Tendsto f fi (nhds f_lim)) (Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub ↑↑(f n) ↑↑f_lim) p μ) fi (nhds 0))","decl":"theorem tendsto_Lp_iff_tendsto_ℒp' {ι} {fi : Filter ι} [Fact (1 ≤ p)] (f : ι → Lp E p μ)\n    (f_lim : Lp E p μ) :\n    fi.Tendsto f (𝓝 f_lim) ↔ fi.Tendsto (fun n => eLpNorm (⇑(f n) - ⇑f_lim) p μ) (𝓝 0) := by\n  rw [tendsto_iff_dist_tendsto_zero]\n  simp_rw [dist_def]\n  rw [← ENNReal.zero_toReal, ENNReal.tendsto_toReal_iff (fun n => ?_) ENNReal.zero_ne_top]\n  rw [eLpNorm_congr_ae (Lp.coeFn_sub _ _).symm]\n  exact Lp.eLpNorm_ne_top _\n\n"}
{"name":"MeasureTheory.Lp.tendsto_Lp_iff_tendsto_ℒp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\nι : Type u_5\nfi : Filter ι\ninst✝ : Fact (LE.le 1 p)\nf : ι → Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\nf_lim : α → E\nf_lim_ℒp : MeasureTheory.Memℒp f_lim p μ\n⊢ Iff (Filter.Tendsto f fi (nhds (MeasureTheory.Memℒp.toLp f_lim f_lim_ℒp))) (Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (↑↑(f n)) f_lim) p μ) fi (nhds 0))","decl":"theorem tendsto_Lp_iff_tendsto_ℒp {ι} {fi : Filter ι} [Fact (1 ≤ p)] (f : ι → Lp E p μ)\n    (f_lim : α → E) (f_lim_ℒp : Memℒp f_lim p μ) :\n    fi.Tendsto f (𝓝 (f_lim_ℒp.toLp f_lim)) ↔\n      fi.Tendsto (fun n => eLpNorm (⇑(f n) - f_lim) p μ) (𝓝 0) := by\n  rw [tendsto_Lp_iff_tendsto_ℒp']\n  suffices h_eq :\n      (fun n => eLpNorm (⇑(f n) - ⇑(Memℒp.toLp f_lim f_lim_ℒp)) p μ) =\n        (fun n => eLpNorm (⇑(f n) - f_lim) p μ) by\n    rw [h_eq]\n  exact funext fun n => eLpNorm_congr_ae (EventuallyEq.rfl.sub (Memℒp.coeFn_toLp f_lim_ℒp))\n\n"}
{"name":"MeasureTheory.Lp.tendsto_Lp_iff_tendsto_ℒp''","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\nι : Type u_5\nfi : Filter ι\ninst✝ : Fact (LE.le 1 p)\nf : ι → α → E\nf_ℒp : ∀ (n : ι), MeasureTheory.Memℒp (f n) p μ\nf_lim : α → E\nf_lim_ℒp : MeasureTheory.Memℒp f_lim p μ\n⊢ Iff (Filter.Tendsto (fun n => MeasureTheory.Memℒp.toLp (f n) ⋯) fi (nhds (MeasureTheory.Memℒp.toLp f_lim f_lim_ℒp))) (Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) f_lim) p μ) fi (nhds 0))","decl":"theorem tendsto_Lp_iff_tendsto_ℒp'' {ι} {fi : Filter ι} [Fact (1 ≤ p)] (f : ι → α → E)\n    (f_ℒp : ∀ n, Memℒp (f n) p μ) (f_lim : α → E) (f_lim_ℒp : Memℒp f_lim p μ) :\n    fi.Tendsto (fun n => (f_ℒp n).toLp (f n)) (𝓝 (f_lim_ℒp.toLp f_lim)) ↔\n      fi.Tendsto (fun n => eLpNorm (f n - f_lim) p μ) (𝓝 0) := by\n  rw [Lp.tendsto_Lp_iff_tendsto_ℒp' (fun n => (f_ℒp n).toLp (f n)) (f_lim_ℒp.toLp f_lim)]\n  refine Filter.tendsto_congr fun n => ?_\n  apply eLpNorm_congr_ae\n  filter_upwards [((f_ℒp n).sub f_lim_ℒp).coeFn_toLp,\n    Lp.coeFn_sub ((f_ℒp n).toLp (f n)) (f_lim_ℒp.toLp f_lim)] with _ hx₁ hx₂\n  rw [← hx₂]\n  exact hx₁\n\n"}
{"name":"MeasureTheory.Lp.tendsto_Lp_of_tendsto_ℒp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\nι : Type u_5\nfi : Filter ι\ninst✝ : Fact (LE.le 1 p)\nf : ι → Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\nf_lim : α → E\nf_lim_ℒp : MeasureTheory.Memℒp f_lim p μ\nh_tendsto : Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (↑↑(f n)) f_lim) p μ) fi (nhds 0)\n⊢ Filter.Tendsto f fi (nhds (MeasureTheory.Memℒp.toLp f_lim f_lim_ℒp))","decl":"theorem tendsto_Lp_of_tendsto_ℒp {ι} {fi : Filter ι} [Fact (1 ≤ p)] {f : ι → Lp E p μ}\n    (f_lim : α → E) (f_lim_ℒp : Memℒp f_lim p μ)\n    (h_tendsto : fi.Tendsto (fun n => eLpNorm (⇑(f n) - f_lim) p μ) (𝓝 0)) :\n    fi.Tendsto f (𝓝 (f_lim_ℒp.toLp f_lim)) :=\n  (tendsto_Lp_iff_tendsto_ℒp f f_lim f_lim_ℒp).mpr h_tendsto\n\n"}
{"name":"MeasureTheory.Lp.cauchySeq_Lp_iff_cauchySeq_ℒp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝² : NormedAddCommGroup E\nι : Type u_5\ninst✝¹ : Nonempty ι\ninst✝ : SemilatticeSup ι\nhp : Fact (LE.le 1 p)\nf : ι → Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Iff (CauchySeq f) (Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub ↑↑(f n.1) ↑↑(f n.2)) p μ) Filter.atTop (nhds 0))","decl":"theorem cauchySeq_Lp_iff_cauchySeq_ℒp {ι} [Nonempty ι] [SemilatticeSup ι] [hp : Fact (1 ≤ p)]\n    (f : ι → Lp E p μ) :\n    CauchySeq f ↔ Tendsto (fun n : ι × ι => eLpNorm (⇑(f n.fst) - ⇑(f n.snd)) p μ) atTop (𝓝 0) := by\n  simp_rw [cauchySeq_iff_tendsto_dist_atTop_0, dist_def]\n  rw [← ENNReal.zero_toReal, ENNReal.tendsto_toReal_iff (fun n => ?_) ENNReal.zero_ne_top]\n  rw [eLpNorm_congr_ae (Lp.coeFn_sub _ _).symm]\n  exact eLpNorm_ne_top _\n\n"}
{"name":"MeasureTheory.Lp.completeSpace_lp_of_cauchy_complete_ℒp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nhp : Fact (LE.le 1 p)\nH : ∀ (f : Nat → α → E), (∀ (n : Nat), MeasureTheory.Memℒp (f n) p μ) → ∀ (B : Nat → ENNReal), LT.lt (tsum fun i => B i) Top.top → (∀ (N n m : Nat), LE.le N n → LE.le N m → LT.lt (MeasureTheory.eLpNorm (HSub.hSub (f n) (f m)) p μ) (B N)) → Exists fun f_lim => And (MeasureTheory.Memℒp f_lim p μ) (Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) f_lim) p μ) Filter.atTop (nhds 0))\n⊢ CompleteSpace (Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x)","decl":"theorem completeSpace_lp_of_cauchy_complete_ℒp [hp : Fact (1 ≤ p)]\n    (H :\n      ∀ (f : ℕ → α → E) (_ : ∀ n, Memℒp (f n) p μ) (B : ℕ → ℝ≥0∞) (_ : ∑' i, B i < ∞)\n        (_ : ∀ N n m : ℕ, N ≤ n → N ≤ m → eLpNorm (f n - f m) p μ < B N),\n        ∃ (f_lim : α → E), Memℒp f_lim p μ ∧\n          atTop.Tendsto (fun n => eLpNorm (f n - f_lim) p μ) (𝓝 0)) :\n    CompleteSpace (Lp E p μ) := by\n  let B := fun n : ℕ => ((1 : ℝ) / 2) ^ n\n  have hB_pos : ∀ n, 0 < B n := fun n => pow_pos (div_pos zero_lt_one zero_lt_two) n\n  refine Metric.complete_of_convergent_controlled_sequences B hB_pos fun f hf => ?_\n  rsuffices ⟨f_lim, hf_lim_meas, h_tendsto⟩ :\n    ∃ (f_lim : α → E), Memℒp f_lim p μ ∧\n      atTop.Tendsto (fun n => eLpNorm (⇑(f n) - f_lim) p μ) (𝓝 0)\n  · exact ⟨hf_lim_meas.toLp f_lim, tendsto_Lp_of_tendsto_ℒp f_lim hf_lim_meas h_tendsto⟩\n  obtain ⟨M, hB⟩ : Summable B := summable_geometric_two\n  let B1 n := ENNReal.ofReal (B n)\n  have hB1_has : HasSum B1 (ENNReal.ofReal M) := by\n    have h_tsum_B1 : ∑' i, B1 i = ENNReal.ofReal M := by\n      change (∑' n : ℕ, ENNReal.ofReal (B n)) = ENNReal.ofReal M\n      rw [← hB.tsum_eq]\n      exact (ENNReal.ofReal_tsum_of_nonneg (fun n => le_of_lt (hB_pos n)) hB.summable).symm\n    have h_sum := (@ENNReal.summable _ B1).hasSum\n    rwa [h_tsum_B1] at h_sum\n  have hB1 : ∑' i, B1 i < ∞ := by\n    rw [hB1_has.tsum_eq]\n    exact ENNReal.ofReal_lt_top\n  let f1 : ℕ → α → E := fun n => f n\n  refine H f1 (fun n => Lp.memℒp (f n)) B1 hB1 fun N n m hn hm => ?_\n  specialize hf N n m hn hm\n  rw [dist_def] at hf\n  dsimp only [f1]\n  rwa [ENNReal.lt_ofReal_iff_toReal_lt]\n  rw [eLpNorm_congr_ae (Lp.coeFn_sub _ _).symm]\n  exact Lp.eLpNorm_ne_top _\n\n"}
{"name":"MeasureTheory.Lp.ae_tendsto_of_cauchy_eLpNorm'","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : CompleteSpace E\nf : Nat → α → E\np : Real\nhf : ∀ (n : Nat), MeasureTheory.AEStronglyMeasurable (f n) μ\nhp1 : LE.le 1 p\nB : Nat → ENNReal\nhB : Ne (tsum fun i => B i) Top.top\nh_cau : ∀ (N n m : Nat), LE.le N n → LE.le N m → LT.lt (MeasureTheory.eLpNorm' (HSub.hSub (f n) (f m)) p μ) (B N)\n⊢ Filter.Eventually (fun x => Exists fun l => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds l)) (MeasureTheory.ae μ)","decl":"theorem ae_tendsto_of_cauchy_eLpNorm' [CompleteSpace E] {f : ℕ → α → E} {p : ℝ}\n    (hf : ∀ n, AEStronglyMeasurable (f n) μ) (hp1 : 1 ≤ p) {B : ℕ → ℝ≥0∞} (hB : ∑' i, B i ≠ ∞)\n    (h_cau : ∀ N n m : ℕ, N ≤ n → N ≤ m → eLpNorm' (f n - f m) p μ < B N) :\n    ∀ᵐ x ∂μ, ∃ l : E, atTop.Tendsto (fun n => f n x) (𝓝 l) := by\n  have h_summable : ∀ᵐ x ∂μ, Summable fun i : ℕ => f (i + 1) x - f i x := by\n    have h1 :\n      ∀ n, eLpNorm' (fun x => ∑ i ∈ Finset.range (n + 1), ‖f (i + 1) x - f i x‖) p μ ≤ ∑' i, B i :=\n      eLpNorm'_sum_norm_sub_le_tsum_of_cauchy_eLpNorm' hf hp1 h_cau\n    have h2 n :\n        ∫⁻ a, (∑ i ∈ Finset.range (n + 1), ‖f (i + 1) a - f i a‖ₑ) ^ p ∂μ ≤ (∑' i, B i) ^ p :=\n      lintegral_rpow_sum_enorm_sub_le_rpow_tsum hp1 n (h1 n)\n    have h3 : (∫⁻ a, (∑' i, ‖f (i + 1) a - f i a‖ₑ) ^ p ∂μ) ^ (1 / p) ≤ ∑' i, B i :=\n      lintegral_rpow_tsum_coe_enorm_sub_le_tsum hf hp1 h2\n    have h4 : ∀ᵐ x ∂μ, ∑' i, ‖f (i + 1) x - f i x‖ₑ < ∞ :=\n      tsum_enorm_sub_ae_lt_top hf hp1 hB h3\n    exact h4.mono fun x hx => .of_nnnorm <| ENNReal.tsum_coe_ne_top_iff_summable.mp hx.ne\n  have h :\n    ∀ᵐ x ∂μ, ∃ l : E,\n      atTop.Tendsto (fun n => ∑ i ∈ Finset.range n, (f (i + 1) x - f i x)) (𝓝 l) := by\n    refine h_summable.mono fun x hx => ?_\n    let hx_sum := hx.hasSum.tendsto_sum_nat\n    exact ⟨∑' i, (f (i + 1) x - f i x), hx_sum⟩\n  refine h.mono fun x hx => ?_\n  cases' hx with l hx\n  have h_rw_sum :\n      (fun n => ∑ i ∈ Finset.range n, (f (i + 1) x - f i x)) = fun n => f n x - f 0 x := by\n    ext1 n\n    change\n      (∑ i ∈ Finset.range n, ((fun m => f m x) (i + 1) - (fun m => f m x) i)) = f n x - f 0 x\n    rw [Finset.sum_range_sub (fun m => f m x)]\n  rw [h_rw_sum] at hx\n  have hf_rw : (fun n => f n x) = fun n => f n x - f 0 x + f 0 x := by\n    ext1 n\n    abel\n  rw [hf_rw]\n  exact ⟨l + f 0 x, Tendsto.add_const _ hx⟩\n\n"}
{"name":"MeasureTheory.Lp.ae_tendsto_of_cauchy_eLpNorm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : CompleteSpace E\nf : Nat → α → E\nhf : ∀ (n : Nat), MeasureTheory.AEStronglyMeasurable (f n) μ\nhp : LE.le 1 p\nB : Nat → ENNReal\nhB : Ne (tsum fun i => B i) Top.top\nh_cau : ∀ (N n m : Nat), LE.le N n → LE.le N m → LT.lt (MeasureTheory.eLpNorm (HSub.hSub (f n) (f m)) p μ) (B N)\n⊢ Filter.Eventually (fun x => Exists fun l => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds l)) (MeasureTheory.ae μ)","decl":"theorem ae_tendsto_of_cauchy_eLpNorm [CompleteSpace E] {f : ℕ → α → E}\n    (hf : ∀ n, AEStronglyMeasurable (f n) μ) (hp : 1 ≤ p) {B : ℕ → ℝ≥0∞} (hB : ∑' i, B i ≠ ∞)\n    (h_cau : ∀ N n m : ℕ, N ≤ n → N ≤ m → eLpNorm (f n - f m) p μ < B N) :\n    ∀ᵐ x ∂μ, ∃ l : E, atTop.Tendsto (fun n => f n x) (𝓝 l) := by\n  by_cases hp_top : p = ∞\n  · simp_rw [hp_top] at *\n    have h_cau_ae : ∀ᵐ x ∂μ, ∀ N n m, N ≤ n → N ≤ m → ‖(f n - f m) x‖ₑ < B N := by\n      simp_rw [ae_all_iff]\n      exact fun N n m hnN hmN => ae_lt_of_essSup_lt (h_cau N n m hnN hmN)\n    simp_rw [eLpNorm_exponent_top, eLpNormEssSup] at h_cau\n    refine h_cau_ae.mono fun x hx => cauchySeq_tendsto_of_complete ?_\n    refine cauchySeq_of_le_tendsto_0 (fun n => (B n).toReal) ?_ ?_\n    · intro n m N hnN hmN\n      specialize hx N n m hnN hmN\n      rw [_root_.dist_eq_norm,\n        ← ENNReal.ofReal_le_iff_le_toReal (ENNReal.ne_top_of_tsum_ne_top hB N),\n        ofReal_norm_eq_enorm]\n      exact hx.le\n    · rw [← ENNReal.zero_toReal]\n      exact\n        Tendsto.comp (g := ENNReal.toReal) (ENNReal.tendsto_toReal ENNReal.zero_ne_top)\n          (ENNReal.tendsto_atTop_zero_of_tsum_ne_top hB)\n  have hp1 : 1 ≤ p.toReal := by\n    rw [← ENNReal.ofReal_le_iff_le_toReal hp_top, ENNReal.ofReal_one]\n    exact hp\n  have h_cau' : ∀ N n m : ℕ, N ≤ n → N ≤ m → eLpNorm' (f n - f m) p.toReal μ < B N := by\n    intro N n m hn hm\n    specialize h_cau N n m hn hm\n    rwa [eLpNorm_eq_eLpNorm' (zero_lt_one.trans_le hp).ne.symm hp_top] at h_cau\n  exact ae_tendsto_of_cauchy_eLpNorm' hf hp1 hB h_cau'\n\n"}
{"name":"MeasureTheory.Lp.cauchy_tendsto_of_tendsto","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Nat → α → E\nhf : ∀ (n : Nat), MeasureTheory.AEStronglyMeasurable (f n) μ\nf_lim : α → E\nB : Nat → ENNReal\nhB : Ne (tsum fun i => B i) Top.top\nh_cau : ∀ (N n m : Nat), LE.le N n → LE.le N m → LT.lt (MeasureTheory.eLpNorm (HSub.hSub (f n) (f m)) p μ) (B N)\nh_lim : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (f_lim x))) (MeasureTheory.ae μ)\n⊢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) f_lim) p μ) Filter.atTop (nhds 0)","decl":"theorem cauchy_tendsto_of_tendsto {f : ℕ → α → E} (hf : ∀ n, AEStronglyMeasurable (f n) μ)\n    (f_lim : α → E) {B : ℕ → ℝ≥0∞} (hB : ∑' i, B i ≠ ∞)\n    (h_cau : ∀ N n m : ℕ, N ≤ n → N ≤ m → eLpNorm (f n - f m) p μ < B N)\n    (h_lim : ∀ᵐ x : α ∂μ, Tendsto (fun n => f n x) atTop (𝓝 (f_lim x))) :\n    atTop.Tendsto (fun n => eLpNorm (f n - f_lim) p μ) (𝓝 0) := by\n  rw [ENNReal.tendsto_atTop_zero]\n  intro ε hε\n  have h_B : ∃ N : ℕ, B N ≤ ε := by\n    suffices h_tendsto_zero : ∃ N : ℕ, ∀ n : ℕ, N ≤ n → B n ≤ ε from\n      ⟨h_tendsto_zero.choose, h_tendsto_zero.choose_spec _ le_rfl⟩\n    exact (ENNReal.tendsto_atTop_zero.mp (ENNReal.tendsto_atTop_zero_of_tsum_ne_top hB)) ε hε\n  cases' h_B with N h_B\n  refine ⟨N, fun n hn => ?_⟩\n  have h_sub : eLpNorm (f n - f_lim) p μ ≤ atTop.liminf fun m => eLpNorm (f n - f m) p μ := by\n    refine eLpNorm_lim_le_liminf_eLpNorm (fun m => (hf n).sub (hf m)) (f n - f_lim) ?_\n    refine h_lim.mono fun x hx => ?_\n    simp_rw [sub_eq_add_neg]\n    exact Tendsto.add tendsto_const_nhds (Tendsto.neg hx)\n  refine h_sub.trans ?_\n  refine liminf_le_of_frequently_le' (frequently_atTop.mpr ?_)\n  refine fun N1 => ⟨max N N1, le_max_right _ _, ?_⟩\n  exact (h_cau N n (max N N1) hn (le_max_left _ _)).le.trans h_B\n\n"}
{"name":"MeasureTheory.Lp.memℒp_of_cauchy_tendsto","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nhp : LE.le 1 p\nf : Nat → α → E\nhf : ∀ (n : Nat), MeasureTheory.Memℒp (f n) p μ\nf_lim : α → E\nh_lim_meas : MeasureTheory.AEStronglyMeasurable f_lim μ\nh_tendsto : Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) f_lim) p μ) Filter.atTop (nhds 0)\n⊢ MeasureTheory.Memℒp f_lim p μ","decl":"theorem memℒp_of_cauchy_tendsto (hp : 1 ≤ p) {f : ℕ → α → E} (hf : ∀ n, Memℒp (f n) p μ)\n    (f_lim : α → E) (h_lim_meas : AEStronglyMeasurable f_lim μ)\n    (h_tendsto : atTop.Tendsto (fun n => eLpNorm (f n - f_lim) p μ) (𝓝 0)) : Memℒp f_lim p μ := by\n  refine ⟨h_lim_meas, ?_⟩\n  rw [ENNReal.tendsto_atTop_zero] at h_tendsto\n  cases' h_tendsto 1 zero_lt_one with N h_tendsto_1\n  specialize h_tendsto_1 N (le_refl N)\n  have h_add : f_lim = f_lim - f N + f N := by abel\n  rw [h_add]\n  refine lt_of_le_of_lt (eLpNorm_add_le (h_lim_meas.sub (hf N).1) (hf N).1 hp) ?_\n  rw [ENNReal.add_lt_top]\n  constructor\n  · refine lt_of_le_of_lt ?_ ENNReal.one_lt_top\n    have h_neg : f_lim - f N = -(f N - f_lim) := by simp\n    rwa [h_neg, eLpNorm_neg]\n  · exact (hf N).2\n\n"}
{"name":"MeasureTheory.Lp.cauchy_complete_ℒp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : CompleteSpace E\nhp : LE.le 1 p\nf : Nat → α → E\nhf : ∀ (n : Nat), MeasureTheory.Memℒp (f n) p μ\nB : Nat → ENNReal\nhB : Ne (tsum fun i => B i) Top.top\nh_cau : ∀ (N n m : Nat), LE.le N n → LE.le N m → LT.lt (MeasureTheory.eLpNorm (HSub.hSub (f n) (f m)) p μ) (B N)\n⊢ Exists fun f_lim => And (MeasureTheory.Memℒp f_lim p μ) (Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) f_lim) p μ) Filter.atTop (nhds 0))","decl":"theorem cauchy_complete_ℒp [CompleteSpace E] (hp : 1 ≤ p) {f : ℕ → α → E}\n    (hf : ∀ n, Memℒp (f n) p μ) {B : ℕ → ℝ≥0∞} (hB : ∑' i, B i ≠ ∞)\n    (h_cau : ∀ N n m : ℕ, N ≤ n → N ≤ m → eLpNorm (f n - f m) p μ < B N) :\n    ∃ (f_lim : α → E), Memℒp f_lim p μ ∧\n      atTop.Tendsto (fun n => eLpNorm (f n - f_lim) p μ) (𝓝 0) := by\n  obtain ⟨f_lim, h_f_lim_meas, h_lim⟩ :\n      ∃ f_lim : α → E, StronglyMeasurable f_lim ∧\n        ∀ᵐ x ∂μ, Tendsto (fun n => f n x) atTop (𝓝 (f_lim x)) :=\n    exists_stronglyMeasurable_limit_of_tendsto_ae (fun n => (hf n).1)\n      (ae_tendsto_of_cauchy_eLpNorm (fun n => (hf n).1) hp hB h_cau)\n  have h_tendsto' : atTop.Tendsto (fun n => eLpNorm (f n - f_lim) p μ) (𝓝 0) :=\n    cauchy_tendsto_of_tendsto (fun m => (hf m).1) f_lim hB h_cau h_lim\n  have h_ℒp_lim : Memℒp f_lim p μ :=\n    memℒp_of_cauchy_tendsto hp hf f_lim h_f_lim_meas.aestronglyMeasurable h_tendsto'\n  exact ⟨f_lim, h_ℒp_lim, h_tendsto'⟩\n\n"}
{"name":"MeasureTheory.Lp.instCompleteSpace","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : CompleteSpace E\nhp : Fact (LE.le 1 p)\n⊢ CompleteSpace (Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x)","decl":"instance instCompleteSpace [CompleteSpace E] [hp : Fact (1 ≤ p)] : CompleteSpace (Lp E p μ) :=\n  completeSpace_lp_of_cauchy_complete_ℒp fun _f hf _B hB h_cau =>\n    cauchy_complete_ℒp hp.elim hf hB.ne h_cau\n\n"}
{"name":"MeasureTheory.Lp.mem_boundedContinuousFunction_iff","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup E\ninst✝² : TopologicalSpace α\ninst✝¹ : BorelSpace α\ninst✝ : SecondCountableTopologyEither α E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Iff (Membership.mem (MeasureTheory.Lp.boundedContinuousFunction E p μ) f) (Exists fun f₀ => Eq (ContinuousMap.toAEEqFun μ f₀.toContinuousMap) ↑f)","decl":"/-- By definition, the elements of `Lp.boundedContinuousFunction E p μ` are the elements of\n`Lp E p μ` which contain a bounded continuous representative. -/\ntheorem MeasureTheory.Lp.mem_boundedContinuousFunction_iff {f : Lp E p μ} :\n    f ∈ MeasureTheory.Lp.boundedContinuousFunction E p μ ↔\n      ∃ f₀ : α →ᵇ E, f₀.toContinuousMap.toAEEqFun μ = (f : α →ₘ[μ] E) :=\n  AddSubgroup.mem_addSubgroupOf\n\n"}
{"name":"BoundedContinuousFunction.mem_Lp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : TopologicalSpace α\ninst✝² : BorelSpace α\ninst✝¹ : SecondCountableTopologyEither α E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : BoundedContinuousFunction α E\n⊢ Membership.mem (MeasureTheory.Lp E p μ) (ContinuousMap.toAEEqFun μ f.toContinuousMap)","decl":"/-- A bounded continuous function on a finite-measure space is in `Lp`. -/\ntheorem mem_Lp (f : α →ᵇ E) : f.toContinuousMap.toAEEqFun μ ∈ Lp E p μ := by\n  refine Lp.mem_Lp_of_ae_bound ‖f‖ ?_\n  filter_upwards [f.toContinuousMap.coeFn_toAEEqFun μ] with x _\n  convert f.norm_coe_le_norm x using 2\n\n"}
{"name":"BoundedContinuousFunction.Lp_nnnorm_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : TopologicalSpace α\ninst✝² : BorelSpace α\ninst✝¹ : SecondCountableTopologyEither α E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : BoundedContinuousFunction α E\n⊢ LE.le (NNNorm.nnnorm ⟨ContinuousMap.toAEEqFun μ f.toContinuousMap, ⋯⟩) (HMul.hMul (HPow.hPow (MeasureTheory.measureUnivNNReal μ) (Inv.inv p.toReal)) (NNNorm.nnnorm f))","decl":"/-- The `Lp`-norm of a bounded continuous function is at most a constant (depending on the measure\nof the whole space) times its sup-norm. -/\ntheorem Lp_nnnorm_le (f : α →ᵇ E) :\n    ‖(⟨f.toContinuousMap.toAEEqFun μ, mem_Lp f⟩ : Lp E p μ)‖₊ ≤\n      measureUnivNNReal μ ^ p.toReal⁻¹ * ‖f‖₊ := by\n  apply Lp.nnnorm_le_of_ae_bound\n  refine (f.toContinuousMap.coeFn_toAEEqFun μ).mono ?_\n  intro x hx\n  rw [← NNReal.coe_le_coe, coe_nnnorm, coe_nnnorm]\n  convert f.norm_coe_le_norm x using 2\n\n"}
{"name":"BoundedContinuousFunction.Lp_norm_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : TopologicalSpace α\ninst✝² : BorelSpace α\ninst✝¹ : SecondCountableTopologyEither α E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : BoundedContinuousFunction α E\n⊢ LE.le (Norm.norm ⟨ContinuousMap.toAEEqFun μ f.toContinuousMap, ⋯⟩) (HMul.hMul (HPow.hPow (↑(MeasureTheory.measureUnivNNReal μ)) (Inv.inv p.toReal)) (Norm.norm f))","decl":"/-- The `Lp`-norm of a bounded continuous function is at most a constant (depending on the measure\nof the whole space) times its sup-norm. -/\ntheorem Lp_norm_le (f : α →ᵇ E) :\n    ‖(⟨f.toContinuousMap.toAEEqFun μ, mem_Lp f⟩ : Lp E p μ)‖ ≤\n      measureUnivNNReal μ ^ p.toReal⁻¹ * ‖f‖ :=\n  Lp_nnnorm_le f\n\n"}
{"name":"BoundedContinuousFunction.range_toLpHom","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : TopologicalSpace α\ninst✝³ : BorelSpace α\ninst✝² : SecondCountableTopologyEither α E\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : Fact (LE.le 1 p)\n⊢ Eq (BoundedContinuousFunction.toLpHom p μ).range (MeasureTheory.Lp.boundedContinuousFunction E p μ)","decl":"theorem range_toLpHom [Fact (1 ≤ p)] :\n    ((toLpHom p μ).range : AddSubgroup (Lp E p μ)) =\n      MeasureTheory.Lp.boundedContinuousFunction E p μ := by\n  symm\n  exact AddMonoidHom.addSubgroupOf_range_eq_of_le\n      ((ContinuousMap.toAEEqFunAddHom μ).comp (toContinuousMapAddHom α E))\n      (by rintro - ⟨f, rfl⟩; exact mem_Lp f : _ ≤ Lp E p μ)\n\n"}
{"name":"BoundedContinuousFunction.coeFn_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : BorelSpace α\ninst✝⁴ : SecondCountableTopologyEither α E\ninst✝³ : MeasureTheory.IsFiniteMeasure μ\n𝕜 : Type u_5\ninst✝² : Fact (LE.le 1 p)\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\nf : BoundedContinuousFunction α E\n⊢ (MeasureTheory.ae μ).EventuallyEq ↑↑((BoundedContinuousFunction.toLp p μ 𝕜) f) ⇑f","decl":"theorem coeFn_toLp [NormedField 𝕜] [NormedSpace 𝕜 E] (f : α →ᵇ E) :\n    toLp (E := E) p μ 𝕜 f =ᵐ[μ] f :=\n  AEEqFun.coeFn_mk f _\n\n"}
{"name":"BoundedContinuousFunction.range_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : BorelSpace α\ninst✝⁴ : SecondCountableTopologyEither α E\ninst✝³ : MeasureTheory.IsFiniteMeasure μ\n𝕜 : Type u_5\ninst✝² : Fact (LE.le 1 p)\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\n⊢ Eq (LinearMap.range (BoundedContinuousFunction.toLp p μ 𝕜)).toAddSubgroup (MeasureTheory.Lp.boundedContinuousFunction E p μ)","decl":"theorem range_toLp [NormedField 𝕜] [NormedSpace 𝕜 E] :\n    (LinearMap.range (toLp p μ 𝕜 : (α →ᵇ E) →L[𝕜] Lp E p μ)).toAddSubgroup =\n      MeasureTheory.Lp.boundedContinuousFunction E p μ :=\n  range_toLpHom p μ\n\n"}
{"name":"BoundedContinuousFunction.toLp_norm_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : BorelSpace α\ninst✝⁴ : SecondCountableTopologyEither α E\ninst✝³ : MeasureTheory.IsFiniteMeasure μ\n𝕜 : Type u_5\ninst✝² : Fact (LE.le 1 p)\ninst✝¹ : NontriviallyNormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\n⊢ LE.le (Norm.norm (BoundedContinuousFunction.toLp p μ 𝕜)) (HPow.hPow (↑(MeasureTheory.measureUnivNNReal μ)) (Inv.inv p.toReal))","decl":"theorem toLp_norm_le [NontriviallyNormedField 𝕜] [NormedSpace 𝕜 E] :\n    ‖(toLp p μ 𝕜 : (α →ᵇ E) →L[𝕜] Lp E p μ)‖ ≤ measureUnivNNReal μ ^ p.toReal⁻¹ :=\n  LinearMap.mkContinuous_norm_le _ (measureUnivNNReal μ ^ p.toReal⁻¹).coe_nonneg _\n\n"}
{"name":"BoundedContinuousFunction.toLp_inj","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : TopologicalSpace α\ninst✝⁶ : BorelSpace α\ninst✝⁵ : SecondCountableTopologyEither α E\ninst✝⁴ : MeasureTheory.IsFiniteMeasure μ\n𝕜 : Type u_5\ninst✝³ : Fact (LE.le 1 p)\nf g : BoundedContinuousFunction α E\ninst✝² : μ.IsOpenPosMeasure\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\n⊢ Iff (Eq ((BoundedContinuousFunction.toLp p μ 𝕜) f) ((BoundedContinuousFunction.toLp p μ 𝕜) g)) (Eq f g)","decl":"theorem toLp_inj {f g : α →ᵇ E} [μ.IsOpenPosMeasure] [NormedField 𝕜] [NormedSpace 𝕜 E] :\n    toLp (E := E) p μ 𝕜 f = toLp (E := E) p μ 𝕜 g ↔ f = g := by\n  refine ⟨fun h => ?_, by tauto⟩\n  rw [← DFunLike.coe_fn_eq, ← (map_continuous f).ae_eq_iff_eq μ (map_continuous g)]\n  refine (coeFn_toLp p μ 𝕜 f).symm.trans (EventuallyEq.trans ?_ <| coeFn_toLp p μ 𝕜 g)\n  rw [h]\n\n"}
{"name":"BoundedContinuousFunction.toLp_injective","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : TopologicalSpace α\ninst✝⁶ : BorelSpace α\ninst✝⁵ : SecondCountableTopologyEither α E\ninst✝⁴ : MeasureTheory.IsFiniteMeasure μ\n𝕜 : Type u_5\ninst✝³ : Fact (LE.le 1 p)\ninst✝² : μ.IsOpenPosMeasure\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\n⊢ Function.Injective ⇑(BoundedContinuousFunction.toLp p μ 𝕜)","decl":"theorem toLp_injective [μ.IsOpenPosMeasure] [NormedField 𝕜] [NormedSpace 𝕜 E] :\n    Function.Injective (⇑(toLp p μ 𝕜 : (α →ᵇ E) →L[𝕜] Lp E p μ)) :=\n  fun _f _g hfg => (toLp_inj μ).mp hfg\n\n"}
{"name":"ContinuousMap.range_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : TopologicalSpace α\ninst✝⁶ : BorelSpace α\ninst✝⁵ : SecondCountableTopologyEither α E\ninst✝⁴ : CompactSpace α\ninst✝³ : MeasureTheory.IsFiniteMeasure μ\n𝕜 : Type u_5\ninst✝² : Fact (LE.le 1 p)\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\n⊢ Eq (LinearMap.range (ContinuousMap.toLp p μ 𝕜)).toAddSubgroup (MeasureTheory.Lp.boundedContinuousFunction E p μ)","decl":"theorem range_toLp [NormedField 𝕜] [NormedSpace 𝕜 E] :\n    (LinearMap.range (toLp p μ 𝕜 : C(α, E) →L[𝕜] Lp E p μ)).toAddSubgroup =\n      MeasureTheory.Lp.boundedContinuousFunction E p μ := by\n  refine SetLike.ext' ?_\n  have := (linearIsometryBoundedOfCompact α E 𝕜).surjective\n  convert Function.Surjective.range_comp this (BoundedContinuousFunction.toLp (E := E) p μ 𝕜)\n  rw [← BoundedContinuousFunction.range_toLp p μ (𝕜 := 𝕜), Submodule.coe_toAddSubgroup,\n    LinearMap.range_coe]\n\n"}
{"name":"ContinuousMap.coeFn_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : TopologicalSpace α\ninst✝⁶ : BorelSpace α\ninst✝⁵ : SecondCountableTopologyEither α E\ninst✝⁴ : CompactSpace α\ninst✝³ : MeasureTheory.IsFiniteMeasure μ\n𝕜 : Type u_5\ninst✝² : Fact (LE.le 1 p)\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\nf : ContinuousMap α E\n⊢ (MeasureTheory.ae μ).EventuallyEq ↑↑((ContinuousMap.toLp p μ 𝕜) f) ⇑f","decl":"theorem coeFn_toLp [NormedField 𝕜] [NormedSpace 𝕜 E] (f : C(α, E)) :\n    toLp (E := E) p μ 𝕜 f =ᵐ[μ] f :=\n  AEEqFun.coeFn_mk f _\n\n"}
{"name":"ContinuousMap.toLp_def","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : TopologicalSpace α\ninst✝⁶ : BorelSpace α\ninst✝⁵ : SecondCountableTopologyEither α E\ninst✝⁴ : CompactSpace α\ninst✝³ : MeasureTheory.IsFiniteMeasure μ\n𝕜 : Type u_5\ninst✝² : Fact (LE.le 1 p)\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\nf : ContinuousMap α E\n⊢ Eq ((ContinuousMap.toLp p μ 𝕜) f) ((BoundedContinuousFunction.toLp p μ 𝕜) ((ContinuousMap.linearIsometryBoundedOfCompact α E 𝕜) f))","decl":"theorem toLp_def [NormedField 𝕜] [NormedSpace 𝕜 E] (f : C(α, E)) :\n    toLp (E := E) p μ 𝕜 f =\n      BoundedContinuousFunction.toLp (E := E) p μ 𝕜 (linearIsometryBoundedOfCompact α E 𝕜 f) :=\n  rfl\n\n"}
{"name":"ContinuousMap.toLp_comp_toContinuousMap","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : TopologicalSpace α\ninst✝⁶ : BorelSpace α\ninst✝⁵ : SecondCountableTopologyEither α E\ninst✝⁴ : CompactSpace α\ninst✝³ : MeasureTheory.IsFiniteMeasure μ\n𝕜 : Type u_5\ninst✝² : Fact (LE.le 1 p)\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\nf : BoundedContinuousFunction α E\n⊢ Eq ((ContinuousMap.toLp p μ 𝕜) f.toContinuousMap) ((BoundedContinuousFunction.toLp p μ 𝕜) f)","decl":"@[simp]\ntheorem toLp_comp_toContinuousMap [NormedField 𝕜] [NormedSpace 𝕜 E] (f : α →ᵇ E) :\n    toLp (E := E) p μ 𝕜 f.toContinuousMap = BoundedContinuousFunction.toLp (E := E) p μ 𝕜 f :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_toLp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : TopologicalSpace α\ninst✝⁶ : BorelSpace α\ninst✝⁵ : SecondCountableTopologyEither α E\ninst✝⁴ : CompactSpace α\ninst✝³ : MeasureTheory.IsFiniteMeasure μ\n𝕜 : Type u_5\ninst✝² : Fact (LE.le 1 p)\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\nf : ContinuousMap α E\n⊢ Eq (↑((ContinuousMap.toLp p μ 𝕜) f)) (ContinuousMap.toAEEqFun μ f)","decl":"@[simp]\ntheorem coe_toLp [NormedField 𝕜] [NormedSpace 𝕜 E] (f : C(α, E)) :\n    (toLp (E := E) p μ 𝕜 f : α →ₘ[μ] E) = f.toAEEqFun μ :=\n  rfl\n\n"}
{"name":"ContinuousMap.toLp_injective","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : TopologicalSpace α\ninst✝⁷ : BorelSpace α\ninst✝⁶ : SecondCountableTopologyEither α E\ninst✝⁵ : CompactSpace α\ninst✝⁴ : MeasureTheory.IsFiniteMeasure μ\n𝕜 : Type u_5\ninst✝³ : Fact (LE.le 1 p)\ninst✝² : μ.IsOpenPosMeasure\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\n⊢ Function.Injective ⇑(ContinuousMap.toLp p μ 𝕜)","decl":"theorem toLp_injective [μ.IsOpenPosMeasure] [NormedField 𝕜] [NormedSpace 𝕜 E] :\n    Function.Injective (⇑(toLp p μ 𝕜 : C(α, E) →L[𝕜] Lp E p μ)) :=\n  (BoundedContinuousFunction.toLp_injective _).comp (linearIsometryBoundedOfCompact α E 𝕜).injective\n\n"}
{"name":"ContinuousMap.toLp_inj","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : TopologicalSpace α\ninst✝⁷ : BorelSpace α\ninst✝⁶ : SecondCountableTopologyEither α E\ninst✝⁵ : CompactSpace α\ninst✝⁴ : MeasureTheory.IsFiniteMeasure μ\n𝕜 : Type u_5\ninst✝³ : Fact (LE.le 1 p)\nf g : ContinuousMap α E\ninst✝² : μ.IsOpenPosMeasure\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\n⊢ Iff (Eq ((ContinuousMap.toLp p μ 𝕜) f) ((ContinuousMap.toLp p μ 𝕜) g)) (Eq f g)","decl":"theorem toLp_inj {f g : C(α, E)} [μ.IsOpenPosMeasure] [NormedField 𝕜] [NormedSpace 𝕜 E] :\n    toLp (E := E) p μ 𝕜 f = toLp (E := E) p μ 𝕜 g ↔ f = g :=\n  (toLp_injective μ).eq_iff\n\n"}
{"name":"ContinuousMap.hasSum_of_hasSum_Lp","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : TopologicalSpace α\ninst✝⁷ : BorelSpace α\ninst✝⁶ : SecondCountableTopologyEither α E\ninst✝⁵ : CompactSpace α\ninst✝⁴ : MeasureTheory.IsFiniteMeasure μ\n𝕜 : Type u_5\ninst✝³ : Fact (LE.le 1 p)\nβ : Type u_6\ninst✝² : μ.IsOpenPosMeasure\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\ng : β → ContinuousMap α E\nf : ContinuousMap α E\nhg : Summable g\nhg2 : HasSum (Function.comp (⇑(ContinuousMap.toLp p μ 𝕜)) g) ((ContinuousMap.toLp p μ 𝕜) f)\n⊢ HasSum g f","decl":"/-- If a sum of continuous functions `g n` is convergent, and the same sum converges in `Lᵖ` to `h`,\nthen in fact `g n` converges uniformly to `h`. -/\ntheorem hasSum_of_hasSum_Lp {β : Type*} [μ.IsOpenPosMeasure] [NormedField 𝕜] [NormedSpace 𝕜 E]\n    {g : β → C(α, E)} {f : C(α, E)} (hg : Summable g)\n    (hg2 : HasSum (toLp (E := E) p μ 𝕜 ∘ g) (toLp (E := E) p μ 𝕜 f)) : HasSum g f := by\n  convert Summable.hasSum hg\n  exact toLp_injective μ (hg2.unique ((toLp p μ 𝕜).hasSum <| Summable.hasSum hg))\n\n"}
{"name":"ContinuousMap.toLp_norm_eq_toLp_norm_coe","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : TopologicalSpace α\ninst✝⁶ : BorelSpace α\ninst✝⁵ : SecondCountableTopologyEither α E\ninst✝⁴ : CompactSpace α\ninst✝³ : MeasureTheory.IsFiniteMeasure μ\n𝕜 : Type u_5\ninst✝² : Fact (LE.le 1 p)\ninst✝¹ : NontriviallyNormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\n⊢ Eq (Norm.norm (ContinuousMap.toLp p μ 𝕜)) (Norm.norm (BoundedContinuousFunction.toLp p μ 𝕜))","decl":"theorem toLp_norm_eq_toLp_norm_coe :\n    ‖(toLp p μ 𝕜 : C(α, E) →L[𝕜] Lp E p μ)‖ =\n      ‖(BoundedContinuousFunction.toLp p μ 𝕜 : (α →ᵇ E) →L[𝕜] Lp E p μ)‖ :=\n  ContinuousLinearMap.opNorm_comp_linearIsometryEquiv _ _\n\n"}
{"name":"ContinuousMap.toLp_norm_le","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : TopologicalSpace α\ninst✝⁶ : BorelSpace α\ninst✝⁵ : SecondCountableTopologyEither α E\ninst✝⁴ : CompactSpace α\ninst✝³ : MeasureTheory.IsFiniteMeasure μ\n𝕜 : Type u_5\ninst✝² : Fact (LE.le 1 p)\ninst✝¹ : NontriviallyNormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\n⊢ LE.le (Norm.norm (ContinuousMap.toLp p μ 𝕜)) (HPow.hPow (↑(MeasureTheory.measureUnivNNReal μ)) (Inv.inv p.toReal))","decl":"/-- Bound for the operator norm of `ContinuousMap.toLp`. -/\ntheorem toLp_norm_le :\n    ‖(toLp p μ 𝕜 : C(α, E) →L[𝕜] Lp E p μ)‖ ≤ measureUnivNNReal μ ^ p.toReal⁻¹ := by\n  rw [toLp_norm_eq_toLp_norm_coe]\n  exact BoundedContinuousFunction.toLp_norm_le μ\n\n"}
{"name":"MeasureTheory.Lp.pow_mul_meas_ge_le_enorm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nε : ENNReal\n⊢ LE.le (HPow.hPow (HMul.hMul ε (μ (setOf fun x => LE.le ε (HPow.hPow (ENorm.enorm (↑↑f x)) p.toReal)))) (HDiv.hDiv 1 p.toReal)) (ENNReal.ofReal (Norm.norm f))","decl":"/-- A version of **Markov's inequality** with elements of Lp. -/\nlemma pow_mul_meas_ge_le_enorm (f : Lp E p μ) (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ∞) (ε : ℝ≥0∞) :\n    (ε * μ {x | ε ≤ ‖f x‖ₑ ^ p.toReal}) ^ (1 / p.toReal) ≤ ENNReal.ofReal ‖f‖ :=\n  (ENNReal.ofReal_toReal (eLpNorm_ne_top f)).symm ▸\n    pow_mul_meas_ge_le_eLpNorm μ hp_ne_zero hp_ne_top (Lp.aestronglyMeasurable f) ε\n\n"}
{"name":"MeasureTheory.Lp.mul_meas_ge_le_pow_enorm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nε : ENNReal\n⊢ LE.le (HMul.hMul ε (μ (setOf fun x => LE.le ε (HPow.hPow (ENorm.enorm (↑↑f x)) p.toReal)))) (HPow.hPow (ENNReal.ofReal (Norm.norm f)) p.toReal)","decl":"/-- A version of **Markov's inequality** with elements of Lp. -/\nlemma mul_meas_ge_le_pow_enorm (f : Lp E p μ) (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ∞) (ε : ℝ≥0∞) :\n    ε * μ {x | ε ≤ ‖f x‖ₑ ^ p.toReal} ≤ ENNReal.ofReal ‖f‖ ^ p.toReal :=\n  (ENNReal.ofReal_toReal (eLpNorm_ne_top f)).symm ▸\n    mul_meas_ge_le_pow_eLpNorm μ hp_ne_zero hp_ne_top (Lp.aestronglyMeasurable f) ε\n\n"}
{"name":"MeasureTheory.Lp.mul_meas_ge_le_pow_enorm'","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nε : ENNReal\n⊢ LE.le (HMul.hMul (HPow.hPow ε p.toReal) (μ (setOf fun x => LE.le ε ↑(NNNorm.nnnorm (↑↑f x))))) (HPow.hPow (ENNReal.ofReal (Norm.norm f)) p.toReal)","decl":"/-- A version of **Markov's inequality** with elements of Lp. -/\ntheorem mul_meas_ge_le_pow_enorm' (f : Lp E p μ) (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ∞)\n    (ε : ℝ≥0∞) : ε ^ p.toReal * μ {x | ε ≤ ‖f x‖₊ } ≤ ENNReal.ofReal ‖f‖ ^ p.toReal :=\n  (ENNReal.ofReal_toReal (eLpNorm_ne_top f)).symm ▸\n    mul_meas_ge_le_pow_eLpNorm' μ hp_ne_zero hp_ne_top (Lp.aestronglyMeasurable f) ε\n\n"}
{"name":"MeasureTheory.Lp.meas_ge_le_mul_pow_enorm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nε : ENNReal\nhε : Ne ε 0\n⊢ LE.le (μ (setOf fun x => LE.le ε ↑(NNNorm.nnnorm (↑↑f x)))) (HMul.hMul (HPow.hPow (Inv.inv ε) p.toReal) (HPow.hPow (ENNReal.ofReal (Norm.norm f)) p.toReal))","decl":"/-- A version of **Markov's inequality** with elements of Lp. -/\ntheorem meas_ge_le_mul_pow_enorm (f : Lp E p μ) (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ∞) {ε : ℝ≥0∞}\n    (hε : ε ≠ 0) : μ {x | ε ≤ ‖f x‖₊} ≤ ε⁻¹ ^ p.toReal * ENNReal.ofReal ‖f‖ ^ p.toReal :=\n  (ENNReal.ofReal_toReal (eLpNorm_ne_top f)).symm ▸\n    meas_ge_le_mul_pow_eLpNorm μ hp_ne_zero hp_ne_top (Lp.aestronglyMeasurable f) hε\n\n"}
{"name":"MeasureTheory.Lp.pow_mul_meas_ge_le_norm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nε : ENNReal\n⊢ LE.le (HPow.hPow (HMul.hMul ε (μ (setOf fun x => LE.le ε (HPow.hPow (ENorm.enorm (↑↑f x)) p.toReal)))) (HDiv.hDiv 1 p.toReal)) (ENNReal.ofReal (Norm.norm f))","decl":"@[deprecated (since := \"2025-01-20\")] alias pow_mul_meas_ge_le_norm := pow_mul_meas_ge_le_enorm\n"}
{"name":"MeasureTheory.Lp.mul_meas_ge_le_pow_norm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nε : ENNReal\n⊢ LE.le (HMul.hMul ε (μ (setOf fun x => LE.le ε (HPow.hPow (ENorm.enorm (↑↑f x)) p.toReal)))) (HPow.hPow (ENNReal.ofReal (Norm.norm f)) p.toReal)","decl":"@[deprecated (since := \"2025-01-20\")] alias mul_meas_ge_le_pow_norm := mul_meas_ge_le_pow_enorm\n"}
{"name":"MeasureTheory.Lp.mul_meas_ge_le_pow_norm'","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nε : ENNReal\n⊢ LE.le (HMul.hMul (HPow.hPow ε p.toReal) (μ (setOf fun x => LE.le ε ↑(NNNorm.nnnorm (↑↑f x))))) (HPow.hPow (ENNReal.ofReal (Norm.norm f)) p.toReal)","decl":"@[deprecated (since := \"2025-01-20\")] alias mul_meas_ge_le_pow_norm' := mul_meas_ge_le_pow_enorm'\n"}
{"name":"MeasureTheory.Lp.meas_ge_le_mul_pow_norm","module":"Mathlib.MeasureTheory.Function.LpSpace","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nε : ENNReal\nhε : Ne ε 0\n⊢ LE.le (μ (setOf fun x => LE.le ε ↑(NNNorm.nnnorm (↑↑f x)))) (HMul.hMul (HPow.hPow (Inv.inv ε) p.toReal) (HPow.hPow (ENNReal.ofReal (Norm.norm f)) p.toReal))","decl":"@[deprecated (since := \"2025-01-20\")] alias meas_ge_le_mul_pow_norm := meas_ge_le_mul_pow_enorm\n\n"}
