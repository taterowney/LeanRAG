{"name":"CochainComplex.mappingConeCompTriangle_obj‚ÇÇ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Triangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ : CochainComplex C Int\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom X‚ÇÇ X‚ÇÉ\n‚ä¢ Eq (CochainComplex.mappingConeCompTriangle f g).obj‚ÇÇ (CochainComplex.mappingCone (CategoryTheory.CategoryStruct.comp f g))","decl":"/-- Given two composable morphisms `f : X‚ÇÅ ‚ü∂ X‚ÇÇ` and `g : X‚ÇÇ ‚ü∂ X‚ÇÉ` in the category\nof cochain complexes, this is the canonical triangle\n`mappingCone f ‚ü∂ mappingCone (f ‚â´ g) ‚ü∂ mappingCone g ‚ü∂ (mappingCone f)‚ü¶1‚üß`. -/\n@[simps! mor‚ÇÅ mor‚ÇÇ mor‚ÇÉ obj‚ÇÅ obj‚ÇÇ obj‚ÇÉ]\nnoncomputable def mappingConeCompTriangle : Triangle (CochainComplex C ‚Ñ§) :=\n  Triangle.mk (map f (f ‚â´ g) (ùüô X‚ÇÅ) g (by rw [id_comp]))\n    (map (f ‚â´ g) g f (ùüô X‚ÇÉ) (by rw [comp_id]))\n    ((triangle g).mor‚ÇÉ ‚â´ (inr f)‚ü¶1‚üß')\n\n"}
{"name":"CochainComplex.mappingConeCompTriangle_obj‚ÇÅ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Triangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ : CochainComplex C Int\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom X‚ÇÇ X‚ÇÉ\n‚ä¢ Eq (CochainComplex.mappingConeCompTriangle f g).obj‚ÇÅ (CochainComplex.mappingCone f)","decl":"/-- Given two composable morphisms `f : X‚ÇÅ ‚ü∂ X‚ÇÇ` and `g : X‚ÇÇ ‚ü∂ X‚ÇÉ` in the category\nof cochain complexes, this is the canonical triangle\n`mappingCone f ‚ü∂ mappingCone (f ‚â´ g) ‚ü∂ mappingCone g ‚ü∂ (mappingCone f)‚ü¶1‚üß`. -/\n@[simps! mor‚ÇÅ mor‚ÇÇ mor‚ÇÉ obj‚ÇÅ obj‚ÇÇ obj‚ÇÉ]\nnoncomputable def mappingConeCompTriangle : Triangle (CochainComplex C ‚Ñ§) :=\n  Triangle.mk (map f (f ‚â´ g) (ùüô X‚ÇÅ) g (by rw [id_comp]))\n    (map (f ‚â´ g) g f (ùüô X‚ÇÉ) (by rw [comp_id]))\n    ((triangle g).mor‚ÇÉ ‚â´ (inr f)‚ü¶1‚üß')\n\n"}
{"name":"CochainComplex.mappingConeCompTriangle_mor‚ÇÇ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Triangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ : CochainComplex C Int\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom X‚ÇÇ X‚ÇÉ\n‚ä¢ Eq (CochainComplex.mappingConeCompTriangle f g).mor‚ÇÇ (CochainComplex.mappingCone.map (CategoryTheory.CategoryStruct.comp f g) g f (CategoryTheory.CategoryStruct.id X‚ÇÉ) ‚ãØ)","decl":"/-- Given two composable morphisms `f : X‚ÇÅ ‚ü∂ X‚ÇÇ` and `g : X‚ÇÇ ‚ü∂ X‚ÇÉ` in the category\nof cochain complexes, this is the canonical triangle\n`mappingCone f ‚ü∂ mappingCone (f ‚â´ g) ‚ü∂ mappingCone g ‚ü∂ (mappingCone f)‚ü¶1‚üß`. -/\n@[simps! mor‚ÇÅ mor‚ÇÇ mor‚ÇÉ obj‚ÇÅ obj‚ÇÇ obj‚ÇÉ]\nnoncomputable def mappingConeCompTriangle : Triangle (CochainComplex C ‚Ñ§) :=\n  Triangle.mk (map f (f ‚â´ g) (ùüô X‚ÇÅ) g (by rw [id_comp]))\n    (map (f ‚â´ g) g f (ùüô X‚ÇÉ) (by rw [comp_id]))\n    ((triangle g).mor‚ÇÉ ‚â´ (inr f)‚ü¶1‚üß')\n\n"}
{"name":"CochainComplex.mappingConeCompTriangle_obj‚ÇÉ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Triangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ : CochainComplex C Int\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom X‚ÇÇ X‚ÇÉ\n‚ä¢ Eq (CochainComplex.mappingConeCompTriangle f g).obj‚ÇÉ (CochainComplex.mappingCone g)","decl":"/-- Given two composable morphisms `f : X‚ÇÅ ‚ü∂ X‚ÇÇ` and `g : X‚ÇÇ ‚ü∂ X‚ÇÉ` in the category\nof cochain complexes, this is the canonical triangle\n`mappingCone f ‚ü∂ mappingCone (f ‚â´ g) ‚ü∂ mappingCone g ‚ü∂ (mappingCone f)‚ü¶1‚üß`. -/\n@[simps! mor‚ÇÅ mor‚ÇÇ mor‚ÇÉ obj‚ÇÅ obj‚ÇÇ obj‚ÇÉ]\nnoncomputable def mappingConeCompTriangle : Triangle (CochainComplex C ‚Ñ§) :=\n  Triangle.mk (map f (f ‚â´ g) (ùüô X‚ÇÅ) g (by rw [id_comp]))\n    (map (f ‚â´ g) g f (ùüô X‚ÇÉ) (by rw [comp_id]))\n    ((triangle g).mor‚ÇÉ ‚â´ (inr f)‚ü¶1‚üß')\n\n"}
{"name":"CochainComplex.mappingConeCompTriangle_mor‚ÇÅ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Triangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ : CochainComplex C Int\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom X‚ÇÇ X‚ÇÉ\n‚ä¢ Eq (CochainComplex.mappingConeCompTriangle f g).mor‚ÇÅ (CochainComplex.mappingCone.map f (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.id X‚ÇÅ) g ‚ãØ)","decl":"/-- Given two composable morphisms `f : X‚ÇÅ ‚ü∂ X‚ÇÇ` and `g : X‚ÇÇ ‚ü∂ X‚ÇÉ` in the category\nof cochain complexes, this is the canonical triangle\n`mappingCone f ‚ü∂ mappingCone (f ‚â´ g) ‚ü∂ mappingCone g ‚ü∂ (mappingCone f)‚ü¶1‚üß`. -/\n@[simps! mor‚ÇÅ mor‚ÇÇ mor‚ÇÉ obj‚ÇÅ obj‚ÇÇ obj‚ÇÉ]\nnoncomputable def mappingConeCompTriangle : Triangle (CochainComplex C ‚Ñ§) :=\n  Triangle.mk (map f (f ‚â´ g) (ùüô X‚ÇÅ) g (by rw [id_comp]))\n    (map (f ‚â´ g) g f (ùüô X‚ÇÉ) (by rw [comp_id]))\n    ((triangle g).mor‚ÇÉ ‚â´ (inr f)‚ü¶1‚üß')\n\n"}
{"name":"CochainComplex.mappingConeCompTriangle_mor‚ÇÉ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Triangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ : CochainComplex C Int\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom X‚ÇÇ X‚ÇÉ\n‚ä¢ Eq (CochainComplex.mappingConeCompTriangle f g).mor‚ÇÉ (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.triangle g).mor‚ÇÉ ((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).map (CochainComplex.mappingCone.inr f)))","decl":"/-- Given two composable morphisms `f : X‚ÇÅ ‚ü∂ X‚ÇÇ` and `g : X‚ÇÇ ‚ü∂ X‚ÇÉ` in the category\nof cochain complexes, this is the canonical triangle\n`mappingCone f ‚ü∂ mappingCone (f ‚â´ g) ‚ü∂ mappingCone g ‚ü∂ (mappingCone f)‚ü¶1‚üß`. -/\n@[simps! mor‚ÇÅ mor‚ÇÇ mor‚ÇÉ obj‚ÇÅ obj‚ÇÇ obj‚ÇÉ]\nnoncomputable def mappingConeCompTriangle : Triangle (CochainComplex C ‚Ñ§) :=\n  Triangle.mk (map f (f ‚â´ g) (ùüô X‚ÇÅ) g (by rw [id_comp]))\n    (map (f ‚â´ g) g f (ùüô X‚ÇÉ) (by rw [comp_id]))\n    ((triangle g).mor‚ÇÉ ‚â´ (inr f)‚ü¶1‚üß')\n\n"}
{"name":"CochainComplex.mappingConeCompTriangle_mor‚ÇÉ_naturality","module":"Mathlib.Algebra.Homology.HomotopyCategory.Triangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ : CochainComplex C Int\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom X‚ÇÇ X‚ÇÉ\nY‚ÇÅ Y‚ÇÇ Y‚ÇÉ : CochainComplex C Int\nf' : Quiver.Hom Y‚ÇÅ Y‚ÇÇ\ng' : Quiver.Hom Y‚ÇÇ Y‚ÇÉ\nœÜ : Quiver.Hom (CategoryTheory.ComposableArrows.mk‚ÇÇ f g) (CategoryTheory.ComposableArrows.mk‚ÇÇ f' g')\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.map g g' (œÜ.app 1) (œÜ.app 2) ‚ãØ) (CochainComplex.mappingConeCompTriangle f' g').mor‚ÇÉ) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingConeCompTriangle f g).mor‚ÇÉ ((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).map (CochainComplex.mappingCone.map f f' (œÜ.app 0) (œÜ.app 1) ‚ãØ)))","decl":"@[reassoc]\nlemma mappingConeCompTriangle_mor‚ÇÉ_naturality {Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : CochainComplex C ‚Ñ§} (f' : Y‚ÇÅ ‚ü∂ Y‚ÇÇ)\n    (g' : Y‚ÇÇ ‚ü∂ Y‚ÇÉ) (œÜ : mk‚ÇÇ f g ‚ü∂ mk‚ÇÇ f' g') :\n    map g g' (œÜ.app 1) (œÜ.app 2) (naturality' œÜ 1 2) ‚â´ (mappingConeCompTriangle f' g').mor‚ÇÉ =\n      (mappingConeCompTriangle f g).mor‚ÇÉ ‚â´\n        (map f f' (œÜ.app 0) (œÜ.app 1) (naturality' œÜ 0 1))‚ü¶1‚üß' := by\n  ext n\n  dsimp [map]\n  -- the following list of lemmas was obtained by doing simp? [ext_from_iff _ (n + 1) _ rfl]\n  simp only [Int.reduceNeg, Fin.isValue, assoc, inr_f_desc_f, HomologicalComplex.comp_f,\n    ext_from_iff _ (n + 1) _ rfl, inl_v_desc_f_assoc, Cochain.zero_cochain_comp_v, Cochain.ofHom_v,\n    inl_v_triangle_mor‚ÇÉ_f_assoc, triangle_obj‚ÇÅ, shiftFunctor_obj_X', shiftFunctor_obj_X,\n    shiftFunctorObjXIso, HomologicalComplex.XIsoOfEq_rfl, Iso.refl_inv, Preadditive.neg_comp,\n    id_comp, Preadditive.comp_neg, inr_f_desc_f_assoc, inr_f_triangle_mor‚ÇÉ_f_assoc, zero_comp,\n    comp_zero, and_self]\n\n"}
{"name":"CochainComplex.mappingConeCompTriangle_mor‚ÇÉ_naturality_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Triangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ : CochainComplex C Int\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom X‚ÇÇ X‚ÇÉ\nY‚ÇÅ Y‚ÇÇ Y‚ÇÉ : CochainComplex C Int\nf' : Quiver.Hom Y‚ÇÅ Y‚ÇÇ\ng' : Quiver.Hom Y‚ÇÇ Y‚ÇÉ\nœÜ : Quiver.Hom (CategoryTheory.ComposableArrows.mk‚ÇÇ f g) (CategoryTheory.ComposableArrows.mk‚ÇÇ f' g')\nZ : HomologicalComplex C (ComplexShape.up Int)\nh : Quiver.Hom ((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).obj (CochainComplex.mappingConeCompTriangle f' g').obj‚ÇÅ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.map g g' (œÜ.app 1) (œÜ.app 2) ‚ãØ) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingConeCompTriangle f' g').mor‚ÇÉ h)) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingConeCompTriangle f g).mor‚ÇÉ (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).map (CochainComplex.mappingCone.map f f' (œÜ.app 0) (œÜ.app 1) ‚ãØ)) h))","decl":"@[reassoc]\nlemma mappingConeCompTriangle_mor‚ÇÉ_naturality {Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : CochainComplex C ‚Ñ§} (f' : Y‚ÇÅ ‚ü∂ Y‚ÇÇ)\n    (g' : Y‚ÇÇ ‚ü∂ Y‚ÇÉ) (œÜ : mk‚ÇÇ f g ‚ü∂ mk‚ÇÇ f' g') :\n    map g g' (œÜ.app 1) (œÜ.app 2) (naturality' œÜ 1 2) ‚â´ (mappingConeCompTriangle f' g').mor‚ÇÉ =\n      (mappingConeCompTriangle f g).mor‚ÇÉ ‚â´\n        (map f f' (œÜ.app 0) (œÜ.app 1) (naturality' œÜ 0 1))‚ü¶1‚üß' := by\n  ext n\n  dsimp [map]\n  -- the following list of lemmas was obtained by doing simp? [ext_from_iff _ (n + 1) _ rfl]\n  simp only [Int.reduceNeg, Fin.isValue, assoc, inr_f_desc_f, HomologicalComplex.comp_f,\n    ext_from_iff _ (n + 1) _ rfl, inl_v_desc_f_assoc, Cochain.zero_cochain_comp_v, Cochain.ofHom_v,\n    inl_v_triangle_mor‚ÇÉ_f_assoc, triangle_obj‚ÇÅ, shiftFunctor_obj_X', shiftFunctor_obj_X,\n    shiftFunctorObjXIso, HomologicalComplex.XIsoOfEq_rfl, Iso.refl_inv, Preadditive.neg_comp,\n    id_comp, Preadditive.comp_neg, inr_f_desc_f_assoc, inr_f_triangle_mor‚ÇÉ_f_assoc, zero_comp,\n    comp_zero, and_self]\n\n"}
{"name":"CochainComplex.MappingConeCompHomotopyEquiv.hom_inv_id","module":"Mathlib.Algebra.Homology.HomotopyCategory.Triangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ : CochainComplex C Int\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom X‚ÇÇ X‚ÇÉ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.MappingConeCompHomotopyEquiv.hom f g) (CochainComplex.MappingConeCompHomotopyEquiv.inv f g)) (CategoryTheory.CategoryStruct.id (CochainComplex.mappingCone g))","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id : hom f g ‚â´ inv f g = ùüô _ := by\n  ext n\n  simp [hom, inv, lift_desc_f _ _ _ _ _ _ _ n (n+1) rfl, ext_from_iff _ (n + 1) _ rfl]\n\n"}
{"name":"CochainComplex.MappingConeCompHomotopyEquiv.hom_inv_id_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Triangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ : CochainComplex C Int\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom X‚ÇÇ X‚ÇÉ\nZ : HomologicalComplex C (ComplexShape.up Int)\nh : Quiver.Hom (CochainComplex.mappingCone g) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.MappingConeCompHomotopyEquiv.hom f g) (CategoryTheory.CategoryStruct.comp (CochainComplex.MappingConeCompHomotopyEquiv.inv f g) h)) h","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id : hom f g ‚â´ inv f g = ùüô _ := by\n  ext n\n  simp [hom, inv, lift_desc_f _ _ _ _ _ _ _ n (n+1) rfl, ext_from_iff _ (n + 1) _ rfl]\n\n"}
{"name":"CochainComplex.mappingConeCompHomotopyEquiv_hom_inv_id","module":"Mathlib.Algebra.Homology.HomotopyCategory.Triangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ : CochainComplex C Int\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom X‚ÇÇ X‚ÇÉ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingConeCompHomotopyEquiv f g).hom (CochainComplex.mappingConeCompHomotopyEquiv f g).inv) (CategoryTheory.CategoryStruct.id (CochainComplex.mappingCone g))","decl":"@[reassoc (attr := simp)]\nlemma mappingConeCompHomotopyEquiv_hom_inv_id :\n    (mappingConeCompHomotopyEquiv f g).hom ‚â´\n      (mappingConeCompHomotopyEquiv f g).inv = ùüô _ := by\n  simp [mappingConeCompHomotopyEquiv]\n\n"}
{"name":"CochainComplex.mappingConeCompHomotopyEquiv_hom_inv_id_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Triangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ : CochainComplex C Int\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom X‚ÇÇ X‚ÇÉ\nZ : HomologicalComplex C (ComplexShape.up Int)\nh : Quiver.Hom (CochainComplex.mappingCone g) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingConeCompHomotopyEquiv f g).hom (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingConeCompHomotopyEquiv f g).inv h)) h","decl":"@[reassoc (attr := simp)]\nlemma mappingConeCompHomotopyEquiv_hom_inv_id :\n    (mappingConeCompHomotopyEquiv f g).hom ‚â´\n      (mappingConeCompHomotopyEquiv f g).inv = ùüô _ := by\n  simp [mappingConeCompHomotopyEquiv]\n\n"}
{"name":"CochainComplex.mappingConeCompHomotopyEquiv_comm‚ÇÅ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Triangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ : CochainComplex C Int\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom X‚ÇÇ X‚ÇÉ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.inr (CochainComplex.mappingCone.map f (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.id X‚ÇÅ) g ‚ãØ)) (CochainComplex.mappingConeCompHomotopyEquiv f g).inv) (CochainComplex.mappingConeCompTriangle f g).mor‚ÇÇ","decl":"@[reassoc]\nlemma mappingConeCompHomotopyEquiv_comm‚ÇÅ :\n    inr (map f (f ‚â´ g) (ùüô X‚ÇÅ) g (by rw [id_comp])) ‚â´\n      (mappingConeCompHomotopyEquiv f g).inv = (mappingConeCompTriangle f g).mor‚ÇÇ := by\n  simp [map, mappingConeCompHomotopyEquiv, MappingConeCompHomotopyEquiv.inv]\n\n"}
{"name":"CochainComplex.mappingConeCompHomotopyEquiv_comm‚ÇÅ_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Triangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ : CochainComplex C Int\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom X‚ÇÇ X‚ÇÉ\nZ : CochainComplex C Int\nh : Quiver.Hom (CochainComplex.mappingCone g) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.inr (CochainComplex.mappingCone.map f (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.id X‚ÇÅ) g ‚ãØ)) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingConeCompHomotopyEquiv f g).inv h)) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingConeCompTriangle f g).mor‚ÇÇ h)","decl":"@[reassoc]\nlemma mappingConeCompHomotopyEquiv_comm‚ÇÅ :\n    inr (map f (f ‚â´ g) (ùüô X‚ÇÅ) g (by rw [id_comp])) ‚â´\n      (mappingConeCompHomotopyEquiv f g).inv = (mappingConeCompTriangle f g).mor‚ÇÇ := by\n  simp [map, mappingConeCompHomotopyEquiv, MappingConeCompHomotopyEquiv.inv]\n\n"}
{"name":"CochainComplex.mappingConeCompHomotopyEquiv_comm‚ÇÇ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Triangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ : CochainComplex C Int\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom X‚ÇÇ X‚ÇÉ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingConeCompHomotopyEquiv f g).hom (CochainComplex.mappingCone.triangle (CochainComplex.mappingConeCompTriangle f g).mor‚ÇÅ).mor‚ÇÉ) (CochainComplex.mappingConeCompTriangle f g).mor‚ÇÉ","decl":"@[reassoc]\nlemma mappingConeCompHomotopyEquiv_comm‚ÇÇ :\n    (mappingConeCompHomotopyEquiv f g).hom ‚â´\n      (triangle (mappingConeCompTriangle f g).mor‚ÇÅ).mor‚ÇÉ =\n      (mappingConeCompTriangle f g).mor‚ÇÉ := by\n  ext n\n  simp [map, mappingConeCompHomotopyEquiv, MappingConeCompHomotopyEquiv.hom,\n    lift_f _ _ _ _ _ (n+1) rfl, ext_from_iff _ (n+1) _ rfl]\n\n"}
{"name":"CochainComplex.mappingConeCompHomotopyEquiv_comm‚ÇÇ_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Triangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ : CochainComplex C Int\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom X‚ÇÇ X‚ÇÉ\nZ : HomologicalComplex C (ComplexShape.up Int)\nh : Quiver.Hom ((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).obj (CochainComplex.mappingCone.triangle (CochainComplex.mappingConeCompTriangle f g).mor‚ÇÅ).obj‚ÇÅ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingConeCompHomotopyEquiv f g).hom (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.triangle (CochainComplex.mappingConeCompTriangle f g).mor‚ÇÅ).mor‚ÇÉ h)) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingConeCompTriangle f g).mor‚ÇÉ h)","decl":"@[reassoc]\nlemma mappingConeCompHomotopyEquiv_comm‚ÇÇ :\n    (mappingConeCompHomotopyEquiv f g).hom ‚â´\n      (triangle (mappingConeCompTriangle f g).mor‚ÇÅ).mor‚ÇÉ =\n      (mappingConeCompTriangle f g).mor‚ÇÉ := by\n  ext n\n  simp [map, mappingConeCompHomotopyEquiv, MappingConeCompHomotopyEquiv.hom,\n    lift_f _ _ _ _ _ (n+1) rfl, ext_from_iff _ (n+1) _ rfl]\n\n"}
{"name":"CochainComplex.mappingConeCompTriangleh_comm‚ÇÅ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Triangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ : CochainComplex C Int\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom X‚ÇÇ X‚ÇÉ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingConeCompTriangleh f g).mor‚ÇÇ ((HomotopyCategory.quotient C (ComplexShape.up Int)).map (CochainComplex.mappingConeCompHomotopyEquiv f g).hom)) ((HomotopyCategory.quotient C (ComplexShape.up Int)).map (CochainComplex.mappingCone.inr (CochainComplex.mappingConeCompTriangle f g).mor‚ÇÅ))","decl":"@[reassoc (attr := simp)]\nlemma mappingConeCompTriangleh_comm‚ÇÅ :\n    (mappingConeCompTriangleh f g).mor‚ÇÇ ‚â´\n      (HomotopyCategory.quotient _ _).map (mappingConeCompHomotopyEquiv f g).hom =\n    (HomotopyCategory.quotient _ _).map (mappingCone.inr _) := by\n  rw [‚Üê cancel_mono (HomotopyCategory.isoOfHomotopyEquiv\n      (mappingConeCompHomotopyEquiv f g)).inv, assoc]\n  dsimp [mappingConeCompTriangleh]\n  rw [‚Üê Functor.map_comp, ‚Üê Functor.map_comp, ‚Üê Functor.map_comp,\n    mappingConeCompHomotopyEquiv_hom_inv_id, comp_id,\n    mappingConeCompHomotopyEquiv_comm‚ÇÅ f g,\n    mappingConeCompTriangle_mor‚ÇÇ]\n\n"}
{"name":"CochainComplex.mappingConeCompTriangleh_comm‚ÇÅ_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Triangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ : CochainComplex C Int\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom X‚ÇÇ X‚ÇÉ\nZ : HomotopyCategory C (ComplexShape.up Int)\nh : Quiver.Hom ((HomotopyCategory.quotient C (ComplexShape.up Int)).obj (CochainComplex.mappingCone (CochainComplex.mappingConeCompTriangle f g).mor‚ÇÅ)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingConeCompTriangleh f g).mor‚ÇÇ (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.up Int)).map (CochainComplex.mappingConeCompHomotopyEquiv f g).hom) h)) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.up Int)).map (CochainComplex.mappingCone.inr (CochainComplex.mappingConeCompTriangle f g).mor‚ÇÅ)) h)","decl":"@[reassoc (attr := simp)]\nlemma mappingConeCompTriangleh_comm‚ÇÅ :\n    (mappingConeCompTriangleh f g).mor‚ÇÇ ‚â´\n      (HomotopyCategory.quotient _ _).map (mappingConeCompHomotopyEquiv f g).hom =\n    (HomotopyCategory.quotient _ _).map (mappingCone.inr _) := by\n  rw [‚Üê cancel_mono (HomotopyCategory.isoOfHomotopyEquiv\n      (mappingConeCompHomotopyEquiv f g)).inv, assoc]\n  dsimp [mappingConeCompTriangleh]\n  rw [‚Üê Functor.map_comp, ‚Üê Functor.map_comp, ‚Üê Functor.map_comp,\n    mappingConeCompHomotopyEquiv_hom_inv_id, comp_id,\n    mappingConeCompHomotopyEquiv_comm‚ÇÅ f g,\n    mappingConeCompTriangle_mor‚ÇÇ]\n\n"}
{"name":"HomotopyCategory.mappingConeCompTriangleh_distinguished","module":"Mathlib.Algebra.Homology.HomotopyCategory.Triangulated","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ : CochainComplex C Int\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom X‚ÇÇ X‚ÇÉ\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\n‚ä¢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CochainComplex.mappingConeCompTriangleh f g)","decl":"lemma mappingConeCompTriangleh_distinguished :\n    (mappingConeCompTriangleh f g) ‚àà\n      distTriang (HomotopyCategory C (ComplexShape.up ‚Ñ§)) := by\n  refine ‚ü®_, _, (mappingConeCompTriangle f g).mor‚ÇÅ, ‚ü®?_‚ü©‚ü©\n  refine Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (isoOfHomotopyEquiv\n    (mappingConeCompHomotopyEquiv f g)) (by aesop_cat) (by simp) ?_\n  dsimp [mappingConeCompTriangleh]\n  rw [CategoryTheory.Functor.map_id, comp_id, ‚Üê Functor.map_comp_assoc]\n  congr 2\n  exact (mappingConeCompHomotopyEquiv_comm‚ÇÇ f g).symm\n\n"}
{"name":"HomotopyCategory.instIsTriangulatedIntUp","module":"Mathlib.Algebra.Homology.HomotopyCategory.Triangulated","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproducts C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\n‚ä¢ CategoryTheory.IsTriangulated (HomotopyCategory C (ComplexShape.up Int))","decl":"noncomputable instance : IsTriangulated (HomotopyCategory C (ComplexShape.up ‚Ñ§)) :=\n  IsTriangulated.mk' (by\n    rintro ‚ü®X‚ÇÅ : CochainComplex C ‚Ñ§‚ü© ‚ü®X‚ÇÇ : CochainComplex C ‚Ñ§‚ü© ‚ü®X‚ÇÉ : CochainComplex C ‚Ñ§‚ü© u‚ÇÅ‚ÇÇ' u‚ÇÇ‚ÇÉ'\n    obtain ‚ü®u‚ÇÅ‚ÇÇ, rfl‚ü© := (HomotopyCategory.quotient C (ComplexShape.up ‚Ñ§)).map_surjective u‚ÇÅ‚ÇÇ'\n    obtain ‚ü®u‚ÇÇ‚ÇÉ, rfl‚ü© := (HomotopyCategory.quotient C (ComplexShape.up ‚Ñ§)).map_surjective u‚ÇÇ‚ÇÉ'\n    refine ‚ü®_, _, _, _, _, _, _, _, Iso.refl _, Iso.refl _, Iso.refl _, by simp, by simp,\n        _, _, mappingCone_triangleh_distinguished u‚ÇÅ‚ÇÇ,\n        _, _, mappingCone_triangleh_distinguished u‚ÇÇ‚ÇÉ,\n        _, _, mappingCone_triangleh_distinguished (u‚ÇÅ‚ÇÇ ‚â´ u‚ÇÇ‚ÇÉ), ‚ü®?_‚ü©‚ü©\n    let Œ± := mappingCone.triangleMap u‚ÇÅ‚ÇÇ (u‚ÇÅ‚ÇÇ ‚â´ u‚ÇÇ‚ÇÉ) (ùüô X‚ÇÅ) u‚ÇÇ‚ÇÉ (by rw [id_comp])\n    let Œ≤ := mappingCone.triangleMap (u‚ÇÅ‚ÇÇ ‚â´ u‚ÇÇ‚ÇÉ) u‚ÇÇ‚ÇÉ u‚ÇÅ‚ÇÇ (ùüô X‚ÇÉ) (by rw [comp_id])\n    refine Triangulated.Octahedron.mk ((HomotopyCategory.quotient _ _).map Œ±.hom‚ÇÉ)\n      ((HomotopyCategory.quotient _ _).map Œ≤.hom‚ÇÉ) ?_ ?_ ?_ ?_ ?_\n    ¬∑ exact ((quotient _ _).mapTriangle.map Œ±).comm‚ÇÇ\n    ¬∑ exact ((quotient _ _).mapTriangle.map Œ±).comm‚ÇÉ.symm.trans (by dsimp [Œ±]; simp)\n    ¬∑ exact ((quotient _ _).mapTriangle.map Œ≤).comm‚ÇÇ.trans (by dsimp [Œ≤]; simp)\n    ¬∑ exact ((quotient _ _).mapTriangle.map Œ≤).comm‚ÇÉ\n    ¬∑ refine isomorphic_distinguished _ (mappingConeCompTriangleh_distinguished u‚ÇÅ‚ÇÇ u‚ÇÇ‚ÇÉ) _ ?_\n      exact Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _)\n        (by dsimp [Œ±, mappingConeCompTriangleh]; simp)\n        (by dsimp [Œ≤, mappingConeCompTriangleh]; simp)\n        (by dsimp [mappingConeCompTriangleh]; simp))\n\n"}
