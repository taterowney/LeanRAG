{"name":"EuclideanGeometry.continuousAt_oangle","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\nx : Prod P (Prod P P)\nhx12 : Ne x.1 x.2.1\nhx32 : Ne x.2.2 x.2.1\n⊢ ContinuousAt (fun y => EuclideanGeometry.oangle y.1 y.2.1 y.2.2) x","decl":"/-- Oriented angles are continuous when neither end point equals the middle point. -/\ntheorem continuousAt_oangle {x : P × P × P} (hx12 : x.1 ≠ x.2.1) (hx32 : x.2.2 ≠ x.2.1) :\n    ContinuousAt (fun y : P × P × P => ∡ y.1 y.2.1 y.2.2) x := by\n  let f : P × P × P → V × V := fun y => (y.1 -ᵥ y.2.1, y.2.2 -ᵥ y.2.1)\n  have hf1 : (f x).1 ≠ 0 := by simp [f, hx12]\n  have hf2 : (f x).2 ≠ 0 := by simp [f, hx32]\n  exact (o.continuousAt_oangle hf1 hf2).comp ((continuous_fst.vsub continuous_snd.fst).prod_mk\n    (continuous_snd.snd.vsub continuous_snd.fst)).continuousAt\n\n"}
{"name":"EuclideanGeometry.oangle_self_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ : P\n⊢ Eq (EuclideanGeometry.oangle p₁ p₁ p₂) 0","decl":"/-- The angle ∡AAB at a point. -/\n@[simp]\ntheorem oangle_self_left (p₁ p₂ : P) : ∡ p₁ p₁ p₂ = 0 := by simp [oangle]\n\n"}
{"name":"EuclideanGeometry.oangle_self_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ : P\n⊢ Eq (EuclideanGeometry.oangle p₁ p₂ p₂) 0","decl":"/-- The angle ∡ABB at a point. -/\n@[simp]\ntheorem oangle_self_right (p₁ p₂ : P) : ∡ p₁ p₂ p₂ = 0 := by simp [oangle]\n\n"}
{"name":"EuclideanGeometry.oangle_self_left_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ : P\n⊢ Eq (EuclideanGeometry.oangle p₁ p₂ p₁) 0","decl":"/-- The angle ∡ABA at a point. -/\n@[simp]\ntheorem oangle_self_left_right (p₁ p₂ : P) : ∡ p₁ p₂ p₁ = 0 :=\n  o.oangle_self _\n\n"}
{"name":"EuclideanGeometry.left_ne_of_oangle_ne_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Ne (EuclideanGeometry.oangle p₁ p₂ p₃) 0\n⊢ Ne p₁ p₂","decl":"/-- If the angle between three points is nonzero, the first two points are not equal. -/\ntheorem left_ne_of_oangle_ne_zero {p₁ p₂ p₃ : P} (h : ∡ p₁ p₂ p₃ ≠ 0) : p₁ ≠ p₂ := by\n  rw [← @vsub_ne_zero V]; exact o.left_ne_zero_of_oangle_ne_zero h\n\n"}
{"name":"EuclideanGeometry.right_ne_of_oangle_ne_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Ne (EuclideanGeometry.oangle p₁ p₂ p₃) 0\n⊢ Ne p₃ p₂","decl":"/-- If the angle between three points is nonzero, the last two points are not equal. -/\ntheorem right_ne_of_oangle_ne_zero {p₁ p₂ p₃ : P} (h : ∡ p₁ p₂ p₃ ≠ 0) : p₃ ≠ p₂ := by\n  rw [← @vsub_ne_zero V]; exact o.right_ne_zero_of_oangle_ne_zero h\n\n"}
{"name":"EuclideanGeometry.left_ne_right_of_oangle_ne_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Ne (EuclideanGeometry.oangle p₁ p₂ p₃) 0\n⊢ Ne p₁ p₃","decl":"/-- If the angle between three points is nonzero, the first and third points are not equal. -/\ntheorem left_ne_right_of_oangle_ne_zero {p₁ p₂ p₃ : P} (h : ∡ p₁ p₂ p₃ ≠ 0) : p₁ ≠ p₃ := by\n  rw [← (vsub_left_injective p₂).ne_iff]; exact o.ne_of_oangle_ne_zero h\n\n"}
{"name":"EuclideanGeometry.left_ne_of_oangle_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.oangle p₁ p₂ p₃) ↑Real.pi\n⊢ Ne p₁ p₂","decl":"/-- If the angle between three points is `π`, the first two points are not equal. -/\ntheorem left_ne_of_oangle_eq_pi {p₁ p₂ p₃ : P} (h : ∡ p₁ p₂ p₃ = π) : p₁ ≠ p₂ :=\n  left_ne_of_oangle_ne_zero (h.symm ▸ Real.Angle.pi_ne_zero : ∡ p₁ p₂ p₃ ≠ 0)\n\n"}
{"name":"EuclideanGeometry.right_ne_of_oangle_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.oangle p₁ p₂ p₃) ↑Real.pi\n⊢ Ne p₃ p₂","decl":"/-- If the angle between three points is `π`, the last two points are not equal. -/\ntheorem right_ne_of_oangle_eq_pi {p₁ p₂ p₃ : P} (h : ∡ p₁ p₂ p₃ = π) : p₃ ≠ p₂ :=\n  right_ne_of_oangle_ne_zero (h.symm ▸ Real.Angle.pi_ne_zero : ∡ p₁ p₂ p₃ ≠ 0)\n\n"}
{"name":"EuclideanGeometry.left_ne_right_of_oangle_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.oangle p₁ p₂ p₃) ↑Real.pi\n⊢ Ne p₁ p₃","decl":"/-- If the angle between three points is `π`, the first and third points are not equal. -/\ntheorem left_ne_right_of_oangle_eq_pi {p₁ p₂ p₃ : P} (h : ∡ p₁ p₂ p₃ = π) : p₁ ≠ p₃ :=\n  left_ne_right_of_oangle_ne_zero (h.symm ▸ Real.Angle.pi_ne_zero : ∡ p₁ p₂ p₃ ≠ 0)\n\n"}
{"name":"EuclideanGeometry.left_ne_of_oangle_eq_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.oangle p₁ p₂ p₃) ↑(HDiv.hDiv Real.pi 2)\n⊢ Ne p₁ p₂","decl":"/-- If the angle between three points is `π / 2`, the first two points are not equal. -/\ntheorem left_ne_of_oangle_eq_pi_div_two {p₁ p₂ p₃ : P} (h : ∡ p₁ p₂ p₃ = (π / 2 : ℝ)) : p₁ ≠ p₂ :=\n  left_ne_of_oangle_ne_zero (h.symm ▸ Real.Angle.pi_div_two_ne_zero : ∡ p₁ p₂ p₃ ≠ 0)\n\n"}
{"name":"EuclideanGeometry.right_ne_of_oangle_eq_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.oangle p₁ p₂ p₃) ↑(HDiv.hDiv Real.pi 2)\n⊢ Ne p₃ p₂","decl":"/-- If the angle between three points is `π / 2`, the last two points are not equal. -/\ntheorem right_ne_of_oangle_eq_pi_div_two {p₁ p₂ p₃ : P} (h : ∡ p₁ p₂ p₃ = (π / 2 : ℝ)) : p₃ ≠ p₂ :=\n  right_ne_of_oangle_ne_zero (h.symm ▸ Real.Angle.pi_div_two_ne_zero : ∡ p₁ p₂ p₃ ≠ 0)\n\n"}
{"name":"EuclideanGeometry.left_ne_right_of_oangle_eq_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.oangle p₁ p₂ p₃) ↑(HDiv.hDiv Real.pi 2)\n⊢ Ne p₁ p₃","decl":"/-- If the angle between three points is `π / 2`, the first and third points are not equal. -/\ntheorem left_ne_right_of_oangle_eq_pi_div_two {p₁ p₂ p₃ : P} (h : ∡ p₁ p₂ p₃ = (π / 2 : ℝ)) :\n    p₁ ≠ p₃ :=\n  left_ne_right_of_oangle_ne_zero (h.symm ▸ Real.Angle.pi_div_two_ne_zero : ∡ p₁ p₂ p₃ ≠ 0)\n\n"}
{"name":"EuclideanGeometry.left_ne_of_oangle_eq_neg_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.oangle p₁ p₂ p₃) ↑(HDiv.hDiv (Neg.neg Real.pi) 2)\n⊢ Ne p₁ p₂","decl":"/-- If the angle between three points is `-π / 2`, the first two points are not equal. -/\ntheorem left_ne_of_oangle_eq_neg_pi_div_two {p₁ p₂ p₃ : P} (h : ∡ p₁ p₂ p₃ = (-π / 2 : ℝ)) :\n    p₁ ≠ p₂ :=\n  left_ne_of_oangle_ne_zero (h.symm ▸ Real.Angle.neg_pi_div_two_ne_zero : ∡ p₁ p₂ p₃ ≠ 0)\n\n"}
{"name":"EuclideanGeometry.right_ne_of_oangle_eq_neg_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.oangle p₁ p₂ p₃) ↑(HDiv.hDiv (Neg.neg Real.pi) 2)\n⊢ Ne p₃ p₂","decl":"/-- If the angle between three points is `-π / 2`, the last two points are not equal. -/\ntheorem right_ne_of_oangle_eq_neg_pi_div_two {p₁ p₂ p₃ : P} (h : ∡ p₁ p₂ p₃ = (-π / 2 : ℝ)) :\n    p₃ ≠ p₂ :=\n  right_ne_of_oangle_ne_zero (h.symm ▸ Real.Angle.neg_pi_div_two_ne_zero : ∡ p₁ p₂ p₃ ≠ 0)\n\n"}
{"name":"EuclideanGeometry.left_ne_right_of_oangle_eq_neg_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.oangle p₁ p₂ p₃) ↑(HDiv.hDiv (Neg.neg Real.pi) 2)\n⊢ Ne p₁ p₃","decl":"/-- If the angle between three points is `-π / 2`, the first and third points are not equal. -/\ntheorem left_ne_right_of_oangle_eq_neg_pi_div_two {p₁ p₂ p₃ : P} (h : ∡ p₁ p₂ p₃ = (-π / 2 : ℝ)) :\n    p₁ ≠ p₃ :=\n  left_ne_right_of_oangle_ne_zero (h.symm ▸ Real.Angle.neg_pi_div_two_ne_zero : ∡ p₁ p₂ p₃ ≠ 0)\n\n"}
{"name":"EuclideanGeometry.left_ne_of_oangle_sign_ne_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Ne (EuclideanGeometry.oangle p₁ p₂ p₃).sign 0\n⊢ Ne p₁ p₂","decl":"/-- If the sign of the angle between three points is nonzero, the first two points are not\nequal. -/\ntheorem left_ne_of_oangle_sign_ne_zero {p₁ p₂ p₃ : P} (h : (∡ p₁ p₂ p₃).sign ≠ 0) : p₁ ≠ p₂ :=\n  left_ne_of_oangle_ne_zero (Real.Angle.sign_ne_zero_iff.1 h).1\n\n"}
{"name":"EuclideanGeometry.right_ne_of_oangle_sign_ne_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Ne (EuclideanGeometry.oangle p₁ p₂ p₃).sign 0\n⊢ Ne p₃ p₂","decl":"/-- If the sign of the angle between three points is nonzero, the last two points are not\nequal. -/\ntheorem right_ne_of_oangle_sign_ne_zero {p₁ p₂ p₃ : P} (h : (∡ p₁ p₂ p₃).sign ≠ 0) : p₃ ≠ p₂ :=\n  right_ne_of_oangle_ne_zero (Real.Angle.sign_ne_zero_iff.1 h).1\n\n"}
{"name":"EuclideanGeometry.left_ne_right_of_oangle_sign_ne_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Ne (EuclideanGeometry.oangle p₁ p₂ p₃).sign 0\n⊢ Ne p₁ p₃","decl":"/-- If the sign of the angle between three points is nonzero, the first and third points are not\nequal. -/\ntheorem left_ne_right_of_oangle_sign_ne_zero {p₁ p₂ p₃ : P} (h : (∡ p₁ p₂ p₃).sign ≠ 0) : p₁ ≠ p₃ :=\n  left_ne_right_of_oangle_ne_zero (Real.Angle.sign_ne_zero_iff.1 h).1\n\n"}
{"name":"EuclideanGeometry.left_ne_of_oangle_sign_eq_one","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.oangle p₁ p₂ p₃).sign 1\n⊢ Ne p₁ p₂","decl":"/-- If the sign of the angle between three points is positive, the first two points are not\nequal. -/\ntheorem left_ne_of_oangle_sign_eq_one {p₁ p₂ p₃ : P} (h : (∡ p₁ p₂ p₃).sign = 1) : p₁ ≠ p₂ :=\n  left_ne_of_oangle_sign_ne_zero (h.symm ▸ by decide : (∡ p₁ p₂ p₃).sign ≠ 0)\n\n"}
{"name":"EuclideanGeometry.right_ne_of_oangle_sign_eq_one","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.oangle p₁ p₂ p₃).sign 1\n⊢ Ne p₃ p₂","decl":"/-- If the sign of the angle between three points is positive, the last two points are not\nequal. -/\ntheorem right_ne_of_oangle_sign_eq_one {p₁ p₂ p₃ : P} (h : (∡ p₁ p₂ p₃).sign = 1) : p₃ ≠ p₂ :=\n  right_ne_of_oangle_sign_ne_zero (h.symm ▸ by decide : (∡ p₁ p₂ p₃).sign ≠ 0)\n\n"}
{"name":"EuclideanGeometry.left_ne_right_of_oangle_sign_eq_one","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.oangle p₁ p₂ p₃).sign 1\n⊢ Ne p₁ p₃","decl":"/-- If the sign of the angle between three points is positive, the first and third points are not\nequal. -/\ntheorem left_ne_right_of_oangle_sign_eq_one {p₁ p₂ p₃ : P} (h : (∡ p₁ p₂ p₃).sign = 1) : p₁ ≠ p₃ :=\n  left_ne_right_of_oangle_sign_ne_zero (h.symm ▸ by decide : (∡ p₁ p₂ p₃).sign ≠ 0)\n\n"}
{"name":"EuclideanGeometry.left_ne_of_oangle_sign_eq_neg_one","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.oangle p₁ p₂ p₃).sign (-1)\n⊢ Ne p₁ p₂","decl":"/-- If the sign of the angle between three points is negative, the first two points are not\nequal. -/\ntheorem left_ne_of_oangle_sign_eq_neg_one {p₁ p₂ p₃ : P} (h : (∡ p₁ p₂ p₃).sign = -1) : p₁ ≠ p₂ :=\n  left_ne_of_oangle_sign_ne_zero (h.symm ▸ by decide : (∡ p₁ p₂ p₃).sign ≠ 0)\n\n"}
{"name":"EuclideanGeometry.right_ne_of_oangle_sign_eq_neg_one","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.oangle p₁ p₂ p₃).sign (-1)\n⊢ Ne p₃ p₂","decl":"/-- If the sign of the angle between three points is negative, the last two points are not equal.\n-/\ntheorem right_ne_of_oangle_sign_eq_neg_one {p₁ p₂ p₃ : P} (h : (∡ p₁ p₂ p₃).sign = -1) : p₃ ≠ p₂ :=\n  right_ne_of_oangle_sign_ne_zero (h.symm ▸ by decide : (∡ p₁ p₂ p₃).sign ≠ 0)\n\n"}
{"name":"EuclideanGeometry.left_ne_right_of_oangle_sign_eq_neg_one","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.oangle p₁ p₂ p₃).sign (-1)\n⊢ Ne p₁ p₃","decl":"/-- If the sign of the angle between three points is negative, the first and third points are not\nequal. -/\ntheorem left_ne_right_of_oangle_sign_eq_neg_one {p₁ p₂ p₃ : P} (h : (∡ p₁ p₂ p₃).sign = -1) :\n    p₁ ≠ p₃ :=\n  left_ne_right_of_oangle_sign_ne_zero (h.symm ▸ by decide : (∡ p₁ p₂ p₃).sign ≠ 0)\n\n"}
{"name":"EuclideanGeometry.oangle_rev","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\n⊢ Eq (EuclideanGeometry.oangle p₃ p₂ p₁) (Neg.neg (EuclideanGeometry.oangle p₁ p₂ p₃))","decl":"/-- Reversing the order of the points passed to `oangle` negates the angle. -/\ntheorem oangle_rev (p₁ p₂ p₃ : P) : ∡ p₃ p₂ p₁ = -∡ p₁ p₂ p₃ :=\n  o.oangle_rev _ _\n\n"}
{"name":"EuclideanGeometry.oangle_add_oangle_rev","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\n⊢ Eq (HAdd.hAdd (EuclideanGeometry.oangle p₁ p₂ p₃) (EuclideanGeometry.oangle p₃ p₂ p₁)) 0","decl":"/-- Adding an angle to that with the order of the points reversed results in 0. -/\n@[simp]\ntheorem oangle_add_oangle_rev (p₁ p₂ p₃ : P) : ∡ p₁ p₂ p₃ + ∡ p₃ p₂ p₁ = 0 :=\n  o.oangle_add_oangle_rev _ _\n\n"}
{"name":"EuclideanGeometry.oangle_eq_zero_iff_oangle_rev_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\n⊢ Iff (Eq (EuclideanGeometry.oangle p₁ p₂ p₃) 0) (Eq (EuclideanGeometry.oangle p₃ p₂ p₁) 0)","decl":"/-- An oriented angle is zero if and only if the angle with the order of the points reversed is\nzero. -/\ntheorem oangle_eq_zero_iff_oangle_rev_eq_zero {p₁ p₂ p₃ : P} : ∡ p₁ p₂ p₃ = 0 ↔ ∡ p₃ p₂ p₁ = 0 :=\n  o.oangle_eq_zero_iff_oangle_rev_eq_zero\n\n"}
{"name":"EuclideanGeometry.oangle_eq_pi_iff_oangle_rev_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\n⊢ Iff (Eq (EuclideanGeometry.oangle p₁ p₂ p₃) ↑Real.pi) (Eq (EuclideanGeometry.oangle p₃ p₂ p₁) ↑Real.pi)","decl":"/-- An oriented angle is `π` if and only if the angle with the order of the points reversed is\n`π`. -/\ntheorem oangle_eq_pi_iff_oangle_rev_eq_pi {p₁ p₂ p₃ : P} : ∡ p₁ p₂ p₃ = π ↔ ∡ p₃ p₂ p₁ = π :=\n  o.oangle_eq_pi_iff_oangle_rev_eq_pi\n\n"}
{"name":"EuclideanGeometry.oangle_ne_zero_and_ne_pi_iff_affineIndependent","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\n⊢ Iff (And (Ne (EuclideanGeometry.oangle p₁ p₂ p₃) 0) (Ne (EuclideanGeometry.oangle p₁ p₂ p₃) ↑Real.pi)) (AffineIndependent Real (Matrix.vecCons p₁ (Matrix.vecCons p₂ (Matrix.vecCons p₃ Matrix.vecEmpty))))","decl":"/-- An oriented angle is not zero or `π` if and only if the three points are affinely\nindependent. -/\ntheorem oangle_ne_zero_and_ne_pi_iff_affineIndependent {p₁ p₂ p₃ : P} :\n    ∡ p₁ p₂ p₃ ≠ 0 ∧ ∡ p₁ p₂ p₃ ≠ π ↔ AffineIndependent ℝ ![p₁, p₂, p₃] := by\n  rw [oangle, o.oangle_ne_zero_and_ne_pi_iff_linearIndependent,\n    affineIndependent_iff_linearIndependent_vsub ℝ _ (1 : Fin 3), ←\n    linearIndependent_equiv (finSuccAboveEquiv (1 : Fin 3))]\n  convert Iff.rfl\n  ext i\n  fin_cases i <;> rfl\n\n"}
{"name":"EuclideanGeometry.oangle_eq_zero_or_eq_pi_iff_collinear","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\n⊢ Iff (Or (Eq (EuclideanGeometry.oangle p₁ p₂ p₃) 0) (Eq (EuclideanGeometry.oangle p₁ p₂ p₃) ↑Real.pi)) (Collinear Real (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃))))","decl":"/-- An oriented angle is zero or `π` if and only if the three points are collinear. -/\ntheorem oangle_eq_zero_or_eq_pi_iff_collinear {p₁ p₂ p₃ : P} :\n    ∡ p₁ p₂ p₃ = 0 ∨ ∡ p₁ p₂ p₃ = π ↔ Collinear ℝ ({p₁, p₂, p₃} : Set P) := by\n  rw [← not_iff_not, not_or, oangle_ne_zero_and_ne_pi_iff_affineIndependent,\n    affineIndependent_iff_not_collinear_set]\n\n"}
{"name":"EuclideanGeometry.oangle_sign_eq_zero_iff_collinear","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\n⊢ Iff (Eq (EuclideanGeometry.oangle p₁ p₂ p₃).sign 0) (Collinear Real (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃))))","decl":"/-- An oriented angle has a sign zero if and only if the three points are collinear. -/\ntheorem oangle_sign_eq_zero_iff_collinear {p₁ p₂ p₃ : P} :\n    (∡ p₁ p₂ p₃).sign = 0 ↔ Collinear ℝ ({p₁, p₂, p₃} : Set P) := by\n  rw [Real.Angle.sign_eq_zero_iff, oangle_eq_zero_or_eq_pi_iff_collinear]\n\n"}
{"name":"EuclideanGeometry.affineIndependent_iff_of_two_zsmul_oangle_eq","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ p₄ p₅ p₆ : P\nh : Eq (HSMul.hSMul 2 (EuclideanGeometry.oangle p₁ p₂ p₃)) (HSMul.hSMul 2 (EuclideanGeometry.oangle p₄ p₅ p₆))\n⊢ Iff (AffineIndependent Real (Matrix.vecCons p₁ (Matrix.vecCons p₂ (Matrix.vecCons p₃ Matrix.vecEmpty)))) (AffineIndependent Real (Matrix.vecCons p₄ (Matrix.vecCons p₅ (Matrix.vecCons p₆ Matrix.vecEmpty))))","decl":"/-- If twice the oriented angles between two triples of points are equal, one triple is affinely\nindependent if and only if the other is. -/\ntheorem affineIndependent_iff_of_two_zsmul_oangle_eq {p₁ p₂ p₃ p₄ p₅ p₆ : P}\n    (h : (2 : ℤ) • ∡ p₁ p₂ p₃ = (2 : ℤ) • ∡ p₄ p₅ p₆) :\n    AffineIndependent ℝ ![p₁, p₂, p₃] ↔ AffineIndependent ℝ ![p₄, p₅, p₆] := by\n  simp_rw [← oangle_ne_zero_and_ne_pi_iff_affineIndependent, ← Real.Angle.two_zsmul_ne_zero_iff, h]\n\n"}
{"name":"EuclideanGeometry.collinear_iff_of_two_zsmul_oangle_eq","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ p₄ p₅ p₆ : P\nh : Eq (HSMul.hSMul 2 (EuclideanGeometry.oangle p₁ p₂ p₃)) (HSMul.hSMul 2 (EuclideanGeometry.oangle p₄ p₅ p₆))\n⊢ Iff (Collinear Real (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃)))) (Collinear Real (Insert.insert p₄ (Insert.insert p₅ (Singleton.singleton p₆))))","decl":"/-- If twice the oriented angles between two triples of points are equal, one triple is collinear\nif and only if the other is. -/\ntheorem collinear_iff_of_two_zsmul_oangle_eq {p₁ p₂ p₃ p₄ p₅ p₆ : P}\n    (h : (2 : ℤ) • ∡ p₁ p₂ p₃ = (2 : ℤ) • ∡ p₄ p₅ p₆) :\n    Collinear ℝ ({p₁, p₂, p₃} : Set P) ↔ Collinear ℝ ({p₄, p₅, p₆} : Set P) := by\n  simp_rw [← oangle_eq_zero_or_eq_pi_iff_collinear, ← Real.Angle.two_zsmul_eq_zero_iff, h]\n\n"}
{"name":"EuclideanGeometry.two_zsmul_oangle_of_vectorSpan_eq","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ p₄ p₅ p₆ : P\nh₁₂₄₅ : Eq (vectorSpan Real (Insert.insert p₁ (Singleton.singleton p₂))) (vectorSpan Real (Insert.insert p₄ (Singleton.singleton p₅)))\nh₃₂₆₅ : Eq (vectorSpan Real (Insert.insert p₃ (Singleton.singleton p₂))) (vectorSpan Real (Insert.insert p₆ (Singleton.singleton p₅)))\n⊢ Eq (HSMul.hSMul 2 (EuclideanGeometry.oangle p₁ p₂ p₃)) (HSMul.hSMul 2 (EuclideanGeometry.oangle p₄ p₅ p₆))","decl":"/-- If corresponding pairs of points in two angles have the same vector span, twice those angles\nare equal. -/\ntheorem two_zsmul_oangle_of_vectorSpan_eq {p₁ p₂ p₃ p₄ p₅ p₆ : P}\n    (h₁₂₄₅ : vectorSpan ℝ ({p₁, p₂} : Set P) = vectorSpan ℝ ({p₄, p₅} : Set P))\n    (h₃₂₆₅ : vectorSpan ℝ ({p₃, p₂} : Set P) = vectorSpan ℝ ({p₆, p₅} : Set P)) :\n    (2 : ℤ) • ∡ p₁ p₂ p₃ = (2 : ℤ) • ∡ p₄ p₅ p₆ := by\n  simp_rw [vectorSpan_pair] at h₁₂₄₅ h₃₂₆₅\n  exact o.two_zsmul_oangle_of_span_eq_of_span_eq h₁₂₄₅ h₃₂₆₅\n\n"}
{"name":"EuclideanGeometry.two_zsmul_oangle_of_parallel","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ p₄ p₅ p₆ : P\nh₁₂₄₅ : (affineSpan Real (Insert.insert p₁ (Singleton.singleton p₂))).Parallel (affineSpan Real (Insert.insert p₄ (Singleton.singleton p₅)))\nh₃₂₆₅ : (affineSpan Real (Insert.insert p₃ (Singleton.singleton p₂))).Parallel (affineSpan Real (Insert.insert p₆ (Singleton.singleton p₅)))\n⊢ Eq (HSMul.hSMul 2 (EuclideanGeometry.oangle p₁ p₂ p₃)) (HSMul.hSMul 2 (EuclideanGeometry.oangle p₄ p₅ p₆))","decl":"/-- If the lines determined by corresponding pairs of points in two angles are parallel, twice\nthose angles are equal. -/\ntheorem two_zsmul_oangle_of_parallel {p₁ p₂ p₃ p₄ p₅ p₆ : P}\n    (h₁₂₄₅ : line[ℝ, p₁, p₂] ∥ line[ℝ, p₄, p₅]) (h₃₂₆₅ : line[ℝ, p₃, p₂] ∥ line[ℝ, p₆, p₅]) :\n    (2 : ℤ) • ∡ p₁ p₂ p₃ = (2 : ℤ) • ∡ p₄ p₅ p₆ := by\n  rw [AffineSubspace.affineSpan_pair_parallel_iff_vectorSpan_eq] at h₁₂₄₅ h₃₂₆₅\n  exact two_zsmul_oangle_of_vectorSpan_eq h₁₂₄₅ h₃₂₆₅\n\n"}
{"name":"EuclideanGeometry.oangle_add","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np p₁ p₂ p₃ : P\nhp₁ : Ne p₁ p\nhp₂ : Ne p₂ p\nhp₃ : Ne p₃ p\n⊢ Eq (HAdd.hAdd (EuclideanGeometry.oangle p₁ p p₂) (EuclideanGeometry.oangle p₂ p p₃)) (EuclideanGeometry.oangle p₁ p p₃)","decl":"/-- Given three points not equal to `p`, the angle between the first and the second at `p` plus\nthe angle between the second and the third equals the angle between the first and the third. -/\n@[simp]\ntheorem oangle_add {p p₁ p₂ p₃ : P} (hp₁ : p₁ ≠ p) (hp₂ : p₂ ≠ p) (hp₃ : p₃ ≠ p) :\n    ∡ p₁ p p₂ + ∡ p₂ p p₃ = ∡ p₁ p p₃ :=\n  o.oangle_add (vsub_ne_zero.2 hp₁) (vsub_ne_zero.2 hp₂) (vsub_ne_zero.2 hp₃)\n\n"}
{"name":"EuclideanGeometry.oangle_add_swap","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np p₁ p₂ p₃ : P\nhp₁ : Ne p₁ p\nhp₂ : Ne p₂ p\nhp₃ : Ne p₃ p\n⊢ Eq (HAdd.hAdd (EuclideanGeometry.oangle p₂ p p₃) (EuclideanGeometry.oangle p₁ p p₂)) (EuclideanGeometry.oangle p₁ p p₃)","decl":"/-- Given three points not equal to `p`, the angle between the second and the third at `p` plus\nthe angle between the first and the second equals the angle between the first and the third. -/\n@[simp]\ntheorem oangle_add_swap {p p₁ p₂ p₃ : P} (hp₁ : p₁ ≠ p) (hp₂ : p₂ ≠ p) (hp₃ : p₃ ≠ p) :\n    ∡ p₂ p p₃ + ∡ p₁ p p₂ = ∡ p₁ p p₃ :=\n  o.oangle_add_swap (vsub_ne_zero.2 hp₁) (vsub_ne_zero.2 hp₂) (vsub_ne_zero.2 hp₃)\n\n"}
{"name":"EuclideanGeometry.oangle_sub_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np p₁ p₂ p₃ : P\nhp₁ : Ne p₁ p\nhp₂ : Ne p₂ p\nhp₃ : Ne p₃ p\n⊢ Eq (HSub.hSub (EuclideanGeometry.oangle p₁ p p₃) (EuclideanGeometry.oangle p₁ p p₂)) (EuclideanGeometry.oangle p₂ p p₃)","decl":"/-- Given three points not equal to `p`, the angle between the first and the third at `p` minus\nthe angle between the first and the second equals the angle between the second and the third. -/\n@[simp]\ntheorem oangle_sub_left {p p₁ p₂ p₃ : P} (hp₁ : p₁ ≠ p) (hp₂ : p₂ ≠ p) (hp₃ : p₃ ≠ p) :\n    ∡ p₁ p p₃ - ∡ p₁ p p₂ = ∡ p₂ p p₃ :=\n  o.oangle_sub_left (vsub_ne_zero.2 hp₁) (vsub_ne_zero.2 hp₂) (vsub_ne_zero.2 hp₃)\n\n"}
{"name":"EuclideanGeometry.oangle_sub_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np p₁ p₂ p₃ : P\nhp₁ : Ne p₁ p\nhp₂ : Ne p₂ p\nhp₃ : Ne p₃ p\n⊢ Eq (HSub.hSub (EuclideanGeometry.oangle p₁ p p₃) (EuclideanGeometry.oangle p₂ p p₃)) (EuclideanGeometry.oangle p₁ p p₂)","decl":"/-- Given three points not equal to `p`, the angle between the first and the third at `p` minus\nthe angle between the second and the third equals the angle between the first and the second. -/\n@[simp]\ntheorem oangle_sub_right {p p₁ p₂ p₃ : P} (hp₁ : p₁ ≠ p) (hp₂ : p₂ ≠ p) (hp₃ : p₃ ≠ p) :\n    ∡ p₁ p p₃ - ∡ p₂ p p₃ = ∡ p₁ p p₂ :=\n  o.oangle_sub_right (vsub_ne_zero.2 hp₁) (vsub_ne_zero.2 hp₂) (vsub_ne_zero.2 hp₃)\n\n"}
{"name":"EuclideanGeometry.oangle_add_cyc3","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np p₁ p₂ p₃ : P\nhp₁ : Ne p₁ p\nhp₂ : Ne p₂ p\nhp₃ : Ne p₃ p\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (EuclideanGeometry.oangle p₁ p p₂) (EuclideanGeometry.oangle p₂ p p₃)) (EuclideanGeometry.oangle p₃ p p₁)) 0","decl":"/-- Given three points not equal to `p`, adding the angles between them at `p` in cyclic order\nresults in 0. -/\n@[simp]\ntheorem oangle_add_cyc3 {p p₁ p₂ p₃ : P} (hp₁ : p₁ ≠ p) (hp₂ : p₂ ≠ p) (hp₃ : p₃ ≠ p) :\n    ∡ p₁ p p₂ + ∡ p₂ p p₃ + ∡ p₃ p p₁ = 0 :=\n  o.oangle_add_cyc3 (vsub_ne_zero.2 hp₁) (vsub_ne_zero.2 hp₂) (vsub_ne_zero.2 hp₃)\n\n"}
{"name":"EuclideanGeometry.oangle_eq_oangle_of_dist_eq","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (Dist.dist p₁ p₂) (Dist.dist p₁ p₃)\n⊢ Eq (EuclideanGeometry.oangle p₁ p₂ p₃) (EuclideanGeometry.oangle p₂ p₃ p₁)","decl":"/-- Pons asinorum, oriented angle-at-point form. -/\ntheorem oangle_eq_oangle_of_dist_eq {p₁ p₂ p₃ : P} (h : dist p₁ p₂ = dist p₁ p₃) :\n    ∡ p₁ p₂ p₃ = ∡ p₂ p₃ p₁ := by\n  simp_rw [dist_eq_norm_vsub V] at h\n  rw [oangle, oangle, ← vsub_sub_vsub_cancel_left p₃ p₂ p₁, ← vsub_sub_vsub_cancel_left p₂ p₃ p₁,\n    o.oangle_sub_eq_oangle_sub_rev_of_norm_eq h]\n\n"}
{"name":"EuclideanGeometry.oangle_eq_pi_sub_two_zsmul_oangle_of_dist_eq","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nhn : Ne p₂ p₃\nh : Eq (Dist.dist p₁ p₂) (Dist.dist p₁ p₃)\n⊢ Eq (EuclideanGeometry.oangle p₃ p₁ p₂) (HSub.hSub (↑Real.pi) (HSMul.hSMul 2 (EuclideanGeometry.oangle p₁ p₂ p₃)))","decl":"/-- The angle at the apex of an isosceles triangle is `π` minus twice a base angle, oriented\nangle-at-point form. -/\ntheorem oangle_eq_pi_sub_two_zsmul_oangle_of_dist_eq {p₁ p₂ p₃ : P} (hn : p₂ ≠ p₃)\n    (h : dist p₁ p₂ = dist p₁ p₃) : ∡ p₃ p₁ p₂ = π - (2 : ℤ) • ∡ p₁ p₂ p₃ := by\n  simp_rw [dist_eq_norm_vsub V] at h\n  rw [oangle, oangle]\n  convert o.oangle_eq_pi_sub_two_zsmul_oangle_sub_of_norm_eq _ h using 1\n  · rw [← neg_vsub_eq_vsub_rev p₁ p₃, ← neg_vsub_eq_vsub_rev p₁ p₂, o.oangle_neg_neg]\n  · rw [← o.oangle_sub_eq_oangle_sub_rev_of_norm_eq h]; simp\n  · simpa using hn\n\n"}
{"name":"EuclideanGeometry.abs_oangle_right_toReal_lt_pi_div_two_of_dist_eq","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (Dist.dist p₁ p₂) (Dist.dist p₁ p₃)\n⊢ LT.lt (abs (EuclideanGeometry.oangle p₁ p₂ p₃).toReal) (HDiv.hDiv Real.pi 2)","decl":"/-- A base angle of an isosceles triangle is acute, oriented angle-at-point form. -/\ntheorem abs_oangle_right_toReal_lt_pi_div_two_of_dist_eq {p₁ p₂ p₃ : P}\n    (h : dist p₁ p₂ = dist p₁ p₃) : |(∡ p₁ p₂ p₃).toReal| < π / 2 := by\n  simp_rw [dist_eq_norm_vsub V] at h\n  rw [oangle, ← vsub_sub_vsub_cancel_left p₃ p₂ p₁]\n  exact o.abs_oangle_sub_right_toReal_lt_pi_div_two h\n\n"}
{"name":"EuclideanGeometry.abs_oangle_left_toReal_lt_pi_div_two_of_dist_eq","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (Dist.dist p₁ p₂) (Dist.dist p₁ p₃)\n⊢ LT.lt (abs (EuclideanGeometry.oangle p₂ p₃ p₁).toReal) (HDiv.hDiv Real.pi 2)","decl":"/-- A base angle of an isosceles triangle is acute, oriented angle-at-point form. -/\ntheorem abs_oangle_left_toReal_lt_pi_div_two_of_dist_eq {p₁ p₂ p₃ : P}\n    (h : dist p₁ p₂ = dist p₁ p₃) : |(∡ p₂ p₃ p₁).toReal| < π / 2 :=\n  oangle_eq_oangle_of_dist_eq h ▸ abs_oangle_right_toReal_lt_pi_div_two_of_dist_eq h\n\n"}
{"name":"EuclideanGeometry.cos_oangle_eq_cos_angle","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np p₁ p₂ : P\nhp₁ : Ne p₁ p\nhp₂ : Ne p₂ p\n⊢ Eq (EuclideanGeometry.oangle p₁ p p₂).cos (Real.cos (EuclideanGeometry.angle p₁ p p₂))","decl":"/-- The cosine of the oriented angle at `p` between two points not equal to `p` equals that of the\nunoriented angle. -/\ntheorem cos_oangle_eq_cos_angle {p p₁ p₂ : P} (hp₁ : p₁ ≠ p) (hp₂ : p₂ ≠ p) :\n    Real.Angle.cos (∡ p₁ p p₂) = Real.cos (∠ p₁ p p₂) :=\n  o.cos_oangle_eq_cos_angle (vsub_ne_zero.2 hp₁) (vsub_ne_zero.2 hp₂)\n\n"}
{"name":"EuclideanGeometry.oangle_eq_angle_or_eq_neg_angle","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np p₁ p₂ : P\nhp₁ : Ne p₁ p\nhp₂ : Ne p₂ p\n⊢ Or (Eq (EuclideanGeometry.oangle p₁ p p₂) ↑(EuclideanGeometry.angle p₁ p p₂)) (Eq (EuclideanGeometry.oangle p₁ p p₂) (Neg.neg ↑(EuclideanGeometry.angle p₁ p p₂)))","decl":"/-- The oriented angle at `p` between two points not equal to `p` is plus or minus the unoriented\nangle. -/\ntheorem oangle_eq_angle_or_eq_neg_angle {p p₁ p₂ : P} (hp₁ : p₁ ≠ p) (hp₂ : p₂ ≠ p) :\n    ∡ p₁ p p₂ = ∠ p₁ p p₂ ∨ ∡ p₁ p p₂ = -∠ p₁ p p₂ :=\n  o.oangle_eq_angle_or_eq_neg_angle (vsub_ne_zero.2 hp₁) (vsub_ne_zero.2 hp₂)\n\n"}
{"name":"EuclideanGeometry.angle_eq_abs_oangle_toReal","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np p₁ p₂ : P\nhp₁ : Ne p₁ p\nhp₂ : Ne p₂ p\n⊢ Eq (EuclideanGeometry.angle p₁ p p₂) (abs (EuclideanGeometry.oangle p₁ p p₂).toReal)","decl":"/-- The unoriented angle at `p` between two points not equal to `p` is the absolute value of the\noriented angle. -/\ntheorem angle_eq_abs_oangle_toReal {p p₁ p₂ : P} (hp₁ : p₁ ≠ p) (hp₂ : p₂ ≠ p) :\n    ∠ p₁ p p₂ = |(∡ p₁ p p₂).toReal| :=\n  o.angle_eq_abs_oangle_toReal (vsub_ne_zero.2 hp₁) (vsub_ne_zero.2 hp₂)\n\n"}
{"name":"EuclideanGeometry.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np p₁ p₂ : P\nh : Eq (EuclideanGeometry.oangle p₁ p p₂).sign 0\n⊢ Or (Eq p₁ p) (Or (Eq p₂ p) (Or (Eq (EuclideanGeometry.angle p₁ p p₂) 0) (Eq (EuclideanGeometry.angle p₁ p p₂) Real.pi)))","decl":"/-- If the sign of the oriented angle at `p` between two points is zero, either one of the points\nequals `p` or the unoriented angle is 0 or π. -/\ntheorem eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero {p p₁ p₂ : P}\n    (h : (∡ p₁ p p₂).sign = 0) : p₁ = p ∨ p₂ = p ∨ ∠ p₁ p p₂ = 0 ∨ ∠ p₁ p p₂ = π := by\n  convert o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero h <;> simp\n\n"}
{"name":"EuclideanGeometry.oangle_eq_of_angle_eq_of_sign_eq","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ p₄ p₅ p₆ : P\nh : Eq (EuclideanGeometry.angle p₁ p₂ p₃) (EuclideanGeometry.angle p₄ p₅ p₆)\nhs : Eq (EuclideanGeometry.oangle p₁ p₂ p₃).sign (EuclideanGeometry.oangle p₄ p₅ p₆).sign\n⊢ Eq (EuclideanGeometry.oangle p₁ p₂ p₃) (EuclideanGeometry.oangle p₄ p₅ p₆)","decl":"/-- If two unoriented angles are equal, and the signs of the corresponding oriented angles are\nequal, then the oriented angles are equal (even in degenerate cases). -/\ntheorem oangle_eq_of_angle_eq_of_sign_eq {p₁ p₂ p₃ p₄ p₅ p₆ : P} (h : ∠ p₁ p₂ p₃ = ∠ p₄ p₅ p₆)\n    (hs : (∡ p₁ p₂ p₃).sign = (∡ p₄ p₅ p₆).sign) : ∡ p₁ p₂ p₃ = ∡ p₄ p₅ p₆ :=\n  o.oangle_eq_of_angle_eq_of_sign_eq h hs\n\n"}
{"name":"EuclideanGeometry.angle_eq_iff_oangle_eq_of_sign_eq","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ p₄ p₅ p₆ : P\nhp₁ : Ne p₁ p₂\nhp₃ : Ne p₃ p₂\nhp₄ : Ne p₄ p₅\nhp₆ : Ne p₆ p₅\nhs : Eq (EuclideanGeometry.oangle p₁ p₂ p₃).sign (EuclideanGeometry.oangle p₄ p₅ p₆).sign\n⊢ Iff (Eq (EuclideanGeometry.angle p₁ p₂ p₃) (EuclideanGeometry.angle p₄ p₅ p₆)) (Eq (EuclideanGeometry.oangle p₁ p₂ p₃) (EuclideanGeometry.oangle p₄ p₅ p₆))","decl":"/-- If the signs of two nondegenerate oriented angles between points are equal, the oriented\nangles are equal if and only if the unoriented angles are equal. -/\ntheorem angle_eq_iff_oangle_eq_of_sign_eq {p₁ p₂ p₃ p₄ p₅ p₆ : P} (hp₁ : p₁ ≠ p₂) (hp₃ : p₃ ≠ p₂)\n    (hp₄ : p₄ ≠ p₅) (hp₆ : p₆ ≠ p₅) (hs : (∡ p₁ p₂ p₃).sign = (∡ p₄ p₅ p₆).sign) :\n    ∠ p₁ p₂ p₃ = ∠ p₄ p₅ p₆ ↔ ∡ p₁ p₂ p₃ = ∡ p₄ p₅ p₆ :=\n  o.angle_eq_iff_oangle_eq_of_sign_eq (vsub_ne_zero.2 hp₁) (vsub_ne_zero.2 hp₃) (vsub_ne_zero.2 hp₄)\n    (vsub_ne_zero.2 hp₆) hs\n\n"}
{"name":"EuclideanGeometry.oangle_eq_angle_of_sign_eq_one","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.oangle p₁ p₂ p₃).sign 1\n⊢ Eq (EuclideanGeometry.oangle p₁ p₂ p₃) ↑(EuclideanGeometry.angle p₁ p₂ p₃)","decl":"/-- The oriented angle between three points equals the unoriented angle if the sign is\npositive. -/\ntheorem oangle_eq_angle_of_sign_eq_one {p₁ p₂ p₃ : P} (h : (∡ p₁ p₂ p₃).sign = 1) :\n    ∡ p₁ p₂ p₃ = ∠ p₁ p₂ p₃ :=\n  o.oangle_eq_angle_of_sign_eq_one h\n\n"}
{"name":"EuclideanGeometry.oangle_eq_neg_angle_of_sign_eq_neg_one","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.oangle p₁ p₂ p₃).sign (-1)\n⊢ Eq (EuclideanGeometry.oangle p₁ p₂ p₃) (Neg.neg ↑(EuclideanGeometry.angle p₁ p₂ p₃))","decl":"/-- The oriented angle between three points equals minus the unoriented angle if the sign is\nnegative. -/\ntheorem oangle_eq_neg_angle_of_sign_eq_neg_one {p₁ p₂ p₃ : P} (h : (∡ p₁ p₂ p₃).sign = -1) :\n    ∡ p₁ p₂ p₃ = -∠ p₁ p₂ p₃ :=\n  o.oangle_eq_neg_angle_of_sign_eq_neg_one h\n\n"}
{"name":"EuclideanGeometry.oangle_eq_zero_iff_angle_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np p₁ p₂ : P\nhp₁ : Ne p₁ p\nhp₂ : Ne p₂ p\n⊢ Iff (Eq (EuclideanGeometry.oangle p₁ p p₂) 0) (Eq (EuclideanGeometry.angle p₁ p p₂) 0)","decl":"/-- The unoriented angle at `p` between two points not equal to `p` is zero if and only if the\nunoriented angle is zero. -/\ntheorem oangle_eq_zero_iff_angle_eq_zero {p p₁ p₂ : P} (hp₁ : p₁ ≠ p) (hp₂ : p₂ ≠ p) :\n    ∡ p₁ p p₂ = 0 ↔ ∠ p₁ p p₂ = 0 :=\n  o.oangle_eq_zero_iff_angle_eq_zero (vsub_ne_zero.2 hp₁) (vsub_ne_zero.2 hp₂)\n\n"}
{"name":"EuclideanGeometry.oangle_eq_pi_iff_angle_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\n⊢ Iff (Eq (EuclideanGeometry.oangle p₁ p₂ p₃) ↑Real.pi) (Eq (EuclideanGeometry.angle p₁ p₂ p₃) Real.pi)","decl":"/-- The oriented angle between three points is `π` if and only if the unoriented angle is `π`. -/\ntheorem oangle_eq_pi_iff_angle_eq_pi {p₁ p₂ p₃ : P} : ∡ p₁ p₂ p₃ = π ↔ ∠ p₁ p₂ p₃ = π :=\n  o.oangle_eq_pi_iff_angle_eq_pi\n\n"}
{"name":"EuclideanGeometry.angle_eq_pi_div_two_of_oangle_eq_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.oangle p₁ p₂ p₃) ↑(HDiv.hDiv Real.pi 2)\n⊢ Eq (EuclideanGeometry.angle p₁ p₂ p₃) (HDiv.hDiv Real.pi 2)","decl":"/-- If the oriented angle between three points is `π / 2`, so is the unoriented angle. -/\ntheorem angle_eq_pi_div_two_of_oangle_eq_pi_div_two {p₁ p₂ p₃ : P} (h : ∡ p₁ p₂ p₃ = ↑(π / 2)) :\n    ∠ p₁ p₂ p₃ = π / 2 := by\n  rw [angle, ← InnerProductGeometry.inner_eq_zero_iff_angle_eq_pi_div_two]\n  exact o.inner_eq_zero_of_oangle_eq_pi_div_two h\n\n"}
{"name":"EuclideanGeometry.angle_rev_eq_pi_div_two_of_oangle_eq_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.oangle p₁ p₂ p₃) ↑(HDiv.hDiv Real.pi 2)\n⊢ Eq (EuclideanGeometry.angle p₃ p₂ p₁) (HDiv.hDiv Real.pi 2)","decl":"/-- If the oriented angle between three points is `π / 2`, so is the unoriented angle\n(reversed). -/\ntheorem angle_rev_eq_pi_div_two_of_oangle_eq_pi_div_two {p₁ p₂ p₃ : P} (h : ∡ p₁ p₂ p₃ = ↑(π / 2)) :\n    ∠ p₃ p₂ p₁ = π / 2 := by\n  rw [angle_comm]\n  exact angle_eq_pi_div_two_of_oangle_eq_pi_div_two h\n\n"}
{"name":"EuclideanGeometry.angle_eq_pi_div_two_of_oangle_eq_neg_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.oangle p₁ p₂ p₃) ↑(HDiv.hDiv (Neg.neg Real.pi) 2)\n⊢ Eq (EuclideanGeometry.angle p₁ p₂ p₃) (HDiv.hDiv Real.pi 2)","decl":"/-- If the oriented angle between three points is `-π / 2`, the unoriented angle is `π / 2`. -/\ntheorem angle_eq_pi_div_two_of_oangle_eq_neg_pi_div_two {p₁ p₂ p₃ : P}\n    (h : ∡ p₁ p₂ p₃ = ↑(-π / 2)) : ∠ p₁ p₂ p₃ = π / 2 := by\n  rw [angle, ← InnerProductGeometry.inner_eq_zero_iff_angle_eq_pi_div_two]\n  exact o.inner_eq_zero_of_oangle_eq_neg_pi_div_two h\n\n"}
{"name":"EuclideanGeometry.angle_rev_eq_pi_div_two_of_oangle_eq_neg_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.oangle p₁ p₂ p₃) ↑(HDiv.hDiv (Neg.neg Real.pi) 2)\n⊢ Eq (EuclideanGeometry.angle p₃ p₂ p₁) (HDiv.hDiv Real.pi 2)","decl":"/-- If the oriented angle between three points is `-π / 2`, the unoriented angle (reversed) is\n`π / 2`. -/\ntheorem angle_rev_eq_pi_div_two_of_oangle_eq_neg_pi_div_two {p₁ p₂ p₃ : P}\n    (h : ∡ p₁ p₂ p₃ = ↑(-π / 2)) : ∠ p₃ p₂ p₁ = π / 2 := by\n  rw [angle_comm]\n  exact angle_eq_pi_div_two_of_oangle_eq_neg_pi_div_two h\n\n"}
{"name":"EuclideanGeometry.oangle_swap₁₂_sign","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\n⊢ Eq (Neg.neg (EuclideanGeometry.oangle p₁ p₂ p₃).sign) (EuclideanGeometry.oangle p₂ p₁ p₃).sign","decl":"/-- Swapping the first and second points in an oriented angle negates the sign of that angle. -/\ntheorem oangle_swap₁₂_sign (p₁ p₂ p₃ : P) : -(∡ p₁ p₂ p₃).sign = (∡ p₂ p₁ p₃).sign := by\n  rw [eq_comm, oangle, oangle, ← o.oangle_neg_neg, neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev, ←\n    vsub_sub_vsub_cancel_left p₁ p₃ p₂, ← neg_vsub_eq_vsub_rev p₃ p₂, sub_eq_add_neg,\n    neg_vsub_eq_vsub_rev p₂ p₁, add_comm, ← @neg_one_smul ℝ]\n  nth_rw 2 [← one_smul ℝ (p₁ -ᵥ p₂)]\n  rw [o.oangle_sign_smul_add_smul_right]\n  simp\n\n"}
{"name":"EuclideanGeometry.oangle_swap₁₃_sign","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\n⊢ Eq (Neg.neg (EuclideanGeometry.oangle p₁ p₂ p₃).sign) (EuclideanGeometry.oangle p₃ p₂ p₁).sign","decl":"/-- Swapping the first and third points in an oriented angle negates the sign of that angle. -/\ntheorem oangle_swap₁₃_sign (p₁ p₂ p₃ : P) : -(∡ p₁ p₂ p₃).sign = (∡ p₃ p₂ p₁).sign := by\n  rw [oangle_rev, Real.Angle.sign_neg, neg_neg]\n\n"}
{"name":"EuclideanGeometry.oangle_swap₂₃_sign","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\n⊢ Eq (Neg.neg (EuclideanGeometry.oangle p₁ p₂ p₃).sign) (EuclideanGeometry.oangle p₁ p₃ p₂).sign","decl":"/-- Swapping the second and third points in an oriented angle negates the sign of that angle. -/\ntheorem oangle_swap₂₃_sign (p₁ p₂ p₃ : P) : -(∡ p₁ p₂ p₃).sign = (∡ p₁ p₃ p₂).sign := by\n  rw [oangle_swap₁₃_sign, ← oangle_swap₁₂_sign, oangle_swap₁₃_sign]\n\n"}
{"name":"EuclideanGeometry.oangle_rotate_sign","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\n⊢ Eq (EuclideanGeometry.oangle p₂ p₃ p₁).sign (EuclideanGeometry.oangle p₁ p₂ p₃).sign","decl":"/-- Rotating the points in an oriented angle does not change the sign of that angle. -/\ntheorem oangle_rotate_sign (p₁ p₂ p₃ : P) : (∡ p₂ p₃ p₁).sign = (∡ p₁ p₂ p₃).sign := by\n  rw [← oangle_swap₁₂_sign, oangle_swap₁₃_sign]\n\n"}
{"name":"EuclideanGeometry.oangle_eq_pi_iff_sbtw","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\n⊢ Iff (Eq (EuclideanGeometry.oangle p₁ p₂ p₃) ↑Real.pi) (Sbtw Real p₁ p₂ p₃)","decl":"/-- The oriented angle between three points is π if and only if the second point is strictly\nbetween the other two. -/\ntheorem oangle_eq_pi_iff_sbtw {p₁ p₂ p₃ : P} : ∡ p₁ p₂ p₃ = π ↔ Sbtw ℝ p₁ p₂ p₃ := by\n  rw [oangle_eq_pi_iff_angle_eq_pi, angle_eq_pi_iff_sbtw]\n\n"}
{"name":"Sbtw.oangle₁₂₃_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Sbtw Real p₁ p₂ p₃\n⊢ Eq (EuclideanGeometry.oangle p₁ p₂ p₃) ↑Real.pi","decl":"/-- If the second of three points is strictly between the other two, the oriented angle at that\npoint is π. -/\ntheorem _root_.Sbtw.oangle₁₂₃_eq_pi {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) : ∡ p₁ p₂ p₃ = π :=\n  oangle_eq_pi_iff_sbtw.2 h\n\n"}
{"name":"Sbtw.oangle₃₂₁_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Sbtw Real p₁ p₂ p₃\n⊢ Eq (EuclideanGeometry.oangle p₃ p₂ p₁) ↑Real.pi","decl":"/-- If the second of three points is strictly between the other two, the oriented angle at that\npoint (reversed) is π. -/\ntheorem _root_.Sbtw.oangle₃₂₁_eq_pi {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) : ∡ p₃ p₂ p₁ = π := by\n  rw [oangle_eq_pi_iff_oangle_rev_eq_pi, ← h.oangle₁₂₃_eq_pi]\n\n"}
{"name":"Wbtw.oangle₂₁₃_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Wbtw Real p₁ p₂ p₃\n⊢ Eq (EuclideanGeometry.oangle p₂ p₁ p₃) 0","decl":"/-- If the second of three points is weakly between the other two, the oriented angle at the\nfirst point is zero. -/\ntheorem _root_.Wbtw.oangle₂₁₃_eq_zero {p₁ p₂ p₃ : P} (h : Wbtw ℝ p₁ p₂ p₃) : ∡ p₂ p₁ p₃ = 0 := by\n  by_cases hp₂p₁ : p₂ = p₁; · simp [hp₂p₁]\n  by_cases hp₃p₁ : p₃ = p₁; · simp [hp₃p₁]\n  rw [oangle_eq_zero_iff_angle_eq_zero hp₂p₁ hp₃p₁]\n  exact h.angle₂₁₃_eq_zero_of_ne hp₂p₁\n\n"}
{"name":"Sbtw.oangle₂₁₃_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Sbtw Real p₁ p₂ p₃\n⊢ Eq (EuclideanGeometry.oangle p₂ p₁ p₃) 0","decl":"/-- If the second of three points is strictly between the other two, the oriented angle at the\nfirst point is zero. -/\ntheorem _root_.Sbtw.oangle₂₁₃_eq_zero {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) : ∡ p₂ p₁ p₃ = 0 :=\n  h.wbtw.oangle₂₁₃_eq_zero\n\n"}
{"name":"Wbtw.oangle₃₁₂_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Wbtw Real p₁ p₂ p₃\n⊢ Eq (EuclideanGeometry.oangle p₃ p₁ p₂) 0","decl":"/-- If the second of three points is weakly between the other two, the oriented angle at the\nfirst point (reversed) is zero. -/\ntheorem _root_.Wbtw.oangle₃₁₂_eq_zero {p₁ p₂ p₃ : P} (h : Wbtw ℝ p₁ p₂ p₃) : ∡ p₃ p₁ p₂ = 0 := by\n  rw [oangle_eq_zero_iff_oangle_rev_eq_zero, h.oangle₂₁₃_eq_zero]\n\n"}
{"name":"Sbtw.oangle₃₁₂_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Sbtw Real p₁ p₂ p₃\n⊢ Eq (EuclideanGeometry.oangle p₃ p₁ p₂) 0","decl":"/-- If the second of three points is strictly between the other two, the oriented angle at the\nfirst point (reversed) is zero. -/\ntheorem _root_.Sbtw.oangle₃₁₂_eq_zero {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) : ∡ p₃ p₁ p₂ = 0 :=\n  h.wbtw.oangle₃₁₂_eq_zero\n\n"}
{"name":"Wbtw.oangle₂₃₁_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Wbtw Real p₁ p₂ p₃\n⊢ Eq (EuclideanGeometry.oangle p₂ p₃ p₁) 0","decl":"/-- If the second of three points is weakly between the other two, the oriented angle at the\nthird point is zero. -/\ntheorem _root_.Wbtw.oangle₂₃₁_eq_zero {p₁ p₂ p₃ : P} (h : Wbtw ℝ p₁ p₂ p₃) : ∡ p₂ p₃ p₁ = 0 :=\n  h.symm.oangle₂₁₃_eq_zero\n\n"}
{"name":"Sbtw.oangle₂₃₁_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Sbtw Real p₁ p₂ p₃\n⊢ Eq (EuclideanGeometry.oangle p₂ p₃ p₁) 0","decl":"/-- If the second of three points is strictly between the other two, the oriented angle at the\nthird point is zero. -/\ntheorem _root_.Sbtw.oangle₂₃₁_eq_zero {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) : ∡ p₂ p₃ p₁ = 0 :=\n  h.wbtw.oangle₂₃₁_eq_zero\n\n"}
{"name":"Wbtw.oangle₁₃₂_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Wbtw Real p₁ p₂ p₃\n⊢ Eq (EuclideanGeometry.oangle p₁ p₃ p₂) 0","decl":"/-- If the second of three points is weakly between the other two, the oriented angle at the\nthird point (reversed) is zero. -/\ntheorem _root_.Wbtw.oangle₁₃₂_eq_zero {p₁ p₂ p₃ : P} (h : Wbtw ℝ p₁ p₂ p₃) : ∡ p₁ p₃ p₂ = 0 :=\n  h.symm.oangle₃₁₂_eq_zero\n\n"}
{"name":"Sbtw.oangle₁₃₂_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\nh : Sbtw Real p₁ p₂ p₃\n⊢ Eq (EuclideanGeometry.oangle p₁ p₃ p₂) 0","decl":"/-- If the second of three points is strictly between the other two, the oriented angle at the\nthird point (reversed) is zero. -/\ntheorem _root_.Sbtw.oangle₁₃₂_eq_zero {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) : ∡ p₁ p₃ p₂ = 0 :=\n  h.wbtw.oangle₁₃₂_eq_zero\n\n"}
{"name":"EuclideanGeometry.oangle_eq_zero_iff_wbtw","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\n⊢ Iff (Eq (EuclideanGeometry.oangle p₁ p₂ p₃) 0) (Or (Wbtw Real p₂ p₁ p₃) (Wbtw Real p₂ p₃ p₁))","decl":"/-- The oriented angle between three points is zero if and only if one of the first and third\npoints is weakly between the other two. -/\ntheorem oangle_eq_zero_iff_wbtw {p₁ p₂ p₃ : P} :\n    ∡ p₁ p₂ p₃ = 0 ↔ Wbtw ℝ p₂ p₁ p₃ ∨ Wbtw ℝ p₂ p₃ p₁ := by\n  by_cases hp₁p₂ : p₁ = p₂; · simp [hp₁p₂]\n  by_cases hp₃p₂ : p₃ = p₂; · simp [hp₃p₂]\n  rw [oangle_eq_zero_iff_angle_eq_zero hp₁p₂ hp₃p₂, angle_eq_zero_iff_ne_and_wbtw]\n  simp [hp₁p₂, hp₃p₂]\n\n"}
{"name":"Wbtw.oangle_eq_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₁' p₂ p₃ : P\nh : Wbtw Real p₂ p₁ p₁'\nhp₁p₂ : Ne p₁ p₂\n⊢ Eq (EuclideanGeometry.oangle p₁ p₂ p₃) (EuclideanGeometry.oangle p₁' p₂ p₃)","decl":"/-- An oriented angle is unchanged by replacing the first point by one weakly further away on the\nsame ray. -/\ntheorem _root_.Wbtw.oangle_eq_left {p₁ p₁' p₂ p₃ : P} (h : Wbtw ℝ p₂ p₁ p₁') (hp₁p₂ : p₁ ≠ p₂) :\n    ∡ p₁ p₂ p₃ = ∡ p₁' p₂ p₃ := by\n  by_cases hp₃p₂ : p₃ = p₂; · simp [hp₃p₂]\n  by_cases hp₁'p₂ : p₁' = p₂; · rw [hp₁'p₂, wbtw_self_iff] at h; exact False.elim (hp₁p₂ h)\n  rw [← oangle_add hp₁'p₂ hp₁p₂ hp₃p₂, h.oangle₃₁₂_eq_zero, zero_add]\n\n"}
{"name":"Sbtw.oangle_eq_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₁' p₂ p₃ : P\nh : Sbtw Real p₂ p₁ p₁'\n⊢ Eq (EuclideanGeometry.oangle p₁ p₂ p₃) (EuclideanGeometry.oangle p₁' p₂ p₃)","decl":"/-- An oriented angle is unchanged by replacing the first point by one strictly further away on\nthe same ray. -/\ntheorem _root_.Sbtw.oangle_eq_left {p₁ p₁' p₂ p₃ : P} (h : Sbtw ℝ p₂ p₁ p₁') :\n    ∡ p₁ p₂ p₃ = ∡ p₁' p₂ p₃ :=\n  h.wbtw.oangle_eq_left h.ne_left\n\n"}
{"name":"Wbtw.oangle_eq_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ p₃' : P\nh : Wbtw Real p₂ p₃ p₃'\nhp₃p₂ : Ne p₃ p₂\n⊢ Eq (EuclideanGeometry.oangle p₁ p₂ p₃) (EuclideanGeometry.oangle p₁ p₂ p₃')","decl":"/-- An oriented angle is unchanged by replacing the third point by one weakly further away on the\nsame ray. -/\ntheorem _root_.Wbtw.oangle_eq_right {p₁ p₂ p₃ p₃' : P} (h : Wbtw ℝ p₂ p₃ p₃') (hp₃p₂ : p₃ ≠ p₂) :\n    ∡ p₁ p₂ p₃ = ∡ p₁ p₂ p₃' := by rw [oangle_rev, h.oangle_eq_left hp₃p₂, ← oangle_rev]\n\n"}
{"name":"Sbtw.oangle_eq_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ p₃' : P\nh : Sbtw Real p₂ p₃ p₃'\n⊢ Eq (EuclideanGeometry.oangle p₁ p₂ p₃) (EuclideanGeometry.oangle p₁ p₂ p₃')","decl":"/-- An oriented angle is unchanged by replacing the third point by one strictly further away on\nthe same ray. -/\ntheorem _root_.Sbtw.oangle_eq_right {p₁ p₂ p₃ p₃' : P} (h : Sbtw ℝ p₂ p₃ p₃') :\n    ∡ p₁ p₂ p₃ = ∡ p₁ p₂ p₃' :=\n  h.wbtw.oangle_eq_right h.ne_left\n\n"}
{"name":"EuclideanGeometry.oangle_midpoint_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\n⊢ Eq (EuclideanGeometry.oangle (midpoint Real p₁ p₂) p₂ p₃) (EuclideanGeometry.oangle p₁ p₂ p₃)","decl":"/-- An oriented angle is unchanged by replacing the first point with the midpoint of the segment\nbetween it and the second point. -/\n@[simp]\ntheorem oangle_midpoint_left (p₁ p₂ p₃ : P) : ∡ (midpoint ℝ p₁ p₂) p₂ p₃ = ∡ p₁ p₂ p₃ := by\n  by_cases h : p₁ = p₂; · simp [h]\n  exact (sbtw_midpoint_of_ne ℝ h).symm.oangle_eq_left\n\n"}
{"name":"EuclideanGeometry.oangle_midpoint_rev_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\n⊢ Eq (EuclideanGeometry.oangle (midpoint Real p₂ p₁) p₂ p₃) (EuclideanGeometry.oangle p₁ p₂ p₃)","decl":"/-- An oriented angle is unchanged by replacing the first point with the midpoint of the segment\nbetween the second point and that point. -/\n@[simp]\ntheorem oangle_midpoint_rev_left (p₁ p₂ p₃ : P) : ∡ (midpoint ℝ p₂ p₁) p₂ p₃ = ∡ p₁ p₂ p₃ := by\n  rw [midpoint_comm, oangle_midpoint_left]\n\n"}
{"name":"EuclideanGeometry.oangle_midpoint_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\n⊢ Eq (EuclideanGeometry.oangle p₁ p₂ (midpoint Real p₃ p₂)) (EuclideanGeometry.oangle p₁ p₂ p₃)","decl":"/-- An oriented angle is unchanged by replacing the third point with the midpoint of the segment\nbetween it and the second point. -/\n@[simp]\ntheorem oangle_midpoint_right (p₁ p₂ p₃ : P) : ∡ p₁ p₂ (midpoint ℝ p₃ p₂) = ∡ p₁ p₂ p₃ := by\n  by_cases h : p₃ = p₂; · simp [h]\n  exact (sbtw_midpoint_of_ne ℝ h).symm.oangle_eq_right\n\n"}
{"name":"EuclideanGeometry.oangle_midpoint_rev_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ : P\n⊢ Eq (EuclideanGeometry.oangle p₁ p₂ (midpoint Real p₂ p₃)) (EuclideanGeometry.oangle p₁ p₂ p₃)","decl":"/-- An oriented angle is unchanged by replacing the third point with the midpoint of the segment\nbetween the second point and that point. -/\n@[simp]\ntheorem oangle_midpoint_rev_right (p₁ p₂ p₃ : P) : ∡ p₁ p₂ (midpoint ℝ p₂ p₃) = ∡ p₁ p₂ p₃ := by\n  rw [midpoint_comm, oangle_midpoint_right]\n\n"}
{"name":"Sbtw.oangle_eq_add_pi_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₁' p₂ p₃ : P\nh : Sbtw Real p₁ p₂ p₁'\nhp₃p₂ : Ne p₃ p₂\n⊢ Eq (EuclideanGeometry.oangle p₁ p₂ p₃) (HAdd.hAdd (EuclideanGeometry.oangle p₁' p₂ p₃) ↑Real.pi)","decl":"/-- Replacing the first point by one on the same line but the opposite ray adds π to the oriented\nangle. -/\ntheorem _root_.Sbtw.oangle_eq_add_pi_left\n    {p₁ p₁' p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₁') (hp₃p₂ : p₃ ≠ p₂) :\n    ∡ p₁ p₂ p₃ = ∡ p₁' p₂ p₃ + π := by\n  rw [← h.oangle₁₂₃_eq_pi, oangle_add_swap h.left_ne h.right_ne hp₃p₂]\n\n"}
{"name":"Sbtw.oangle_eq_add_pi_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ p₃' : P\nh : Sbtw Real p₃ p₂ p₃'\nhp₁p₂ : Ne p₁ p₂\n⊢ Eq (EuclideanGeometry.oangle p₁ p₂ p₃) (HAdd.hAdd (EuclideanGeometry.oangle p₁ p₂ p₃') ↑Real.pi)","decl":"/-- Replacing the third point by one on the same line but the opposite ray adds π to the oriented\nangle. -/\ntheorem _root_.Sbtw.oangle_eq_add_pi_right\n    {p₁ p₂ p₃ p₃' : P} (h : Sbtw ℝ p₃ p₂ p₃') (hp₁p₂ : p₁ ≠ p₂) :\n    ∡ p₁ p₂ p₃ = ∡ p₁ p₂ p₃' + π := by\n  rw [← h.oangle₃₂₁_eq_pi, oangle_add hp₁p₂ h.right_ne h.left_ne]\n\n"}
{"name":"Sbtw.oangle_eq_left_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₁' p₂ p₃ p₃' : P\nh₁ : Sbtw Real p₁ p₂ p₁'\nh₃ : Sbtw Real p₃ p₂ p₃'\n⊢ Eq (EuclideanGeometry.oangle p₁ p₂ p₃) (EuclideanGeometry.oangle p₁' p₂ p₃')","decl":"/-- Replacing both the first and third points by ones on the same lines but the opposite rays\ndoes not change the oriented angle (vertically opposite angles). -/\ntheorem _root_.Sbtw.oangle_eq_left_right {p₁ p₁' p₂ p₃ p₃' : P} (h₁ : Sbtw ℝ p₁ p₂ p₁')\n    (h₃ : Sbtw ℝ p₃ p₂ p₃') : ∡ p₁ p₂ p₃ = ∡ p₁' p₂ p₃' := by\n  rw [h₁.oangle_eq_add_pi_left h₃.left_ne, h₃.oangle_eq_add_pi_right h₁.right_ne, add_assoc,\n    Real.Angle.coe_pi_add_coe_pi, add_zero]\n\n"}
{"name":"Collinear.two_zsmul_oangle_eq_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₁' p₂ p₃ : P\nh : Collinear Real (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₁')))\nhp₁p₂ : Ne p₁ p₂\nhp₁'p₂ : Ne p₁' p₂\n⊢ Eq (HSMul.hSMul 2 (EuclideanGeometry.oangle p₁ p₂ p₃)) (HSMul.hSMul 2 (EuclideanGeometry.oangle p₁' p₂ p₃))","decl":"/-- Replacing the first point by one on the same line does not change twice the oriented angle. -/\ntheorem _root_.Collinear.two_zsmul_oangle_eq_left {p₁ p₁' p₂ p₃ : P}\n    (h : Collinear ℝ ({p₁, p₂, p₁'} : Set P)) (hp₁p₂ : p₁ ≠ p₂) (hp₁'p₂ : p₁' ≠ p₂) :\n    (2 : ℤ) • ∡ p₁ p₂ p₃ = (2 : ℤ) • ∡ p₁' p₂ p₃ := by\n  by_cases hp₃p₂ : p₃ = p₂; · simp [hp₃p₂]\n  rcases h.wbtw_or_wbtw_or_wbtw with (hw | hw | hw)\n  · have hw' : Sbtw ℝ p₁ p₂ p₁' := ⟨hw, hp₁p₂.symm, hp₁'p₂.symm⟩\n    rw [hw'.oangle_eq_add_pi_left hp₃p₂, smul_add, Real.Angle.two_zsmul_coe_pi, add_zero]\n  · rw [hw.oangle_eq_left hp₁'p₂]\n  · rw [hw.symm.oangle_eq_left hp₁p₂]\n\n"}
{"name":"Collinear.two_zsmul_oangle_eq_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ p₃' : P\nh : Collinear Real (Insert.insert p₃ (Insert.insert p₂ (Singleton.singleton p₃')))\nhp₃p₂ : Ne p₃ p₂\nhp₃'p₂ : Ne p₃' p₂\n⊢ Eq (HSMul.hSMul 2 (EuclideanGeometry.oangle p₁ p₂ p₃)) (HSMul.hSMul 2 (EuclideanGeometry.oangle p₁ p₂ p₃'))","decl":"/-- Replacing the third point by one on the same line does not change twice the oriented angle. -/\ntheorem _root_.Collinear.two_zsmul_oangle_eq_right {p₁ p₂ p₃ p₃' : P}\n    (h : Collinear ℝ ({p₃, p₂, p₃'} : Set P)) (hp₃p₂ : p₃ ≠ p₂) (hp₃'p₂ : p₃' ≠ p₂) :\n    (2 : ℤ) • ∡ p₁ p₂ p₃ = (2 : ℤ) • ∡ p₁ p₂ p₃' := by\n  rw [oangle_rev, smul_neg, h.two_zsmul_oangle_eq_left hp₃p₂ hp₃'p₂, ← smul_neg, ← oangle_rev]\n\n"}
{"name":"EuclideanGeometry.dist_eq_iff_eq_smul_rotation_pi_div_two_vadd_midpoint","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p : P\nh : Ne p₁ p₂\n⊢ Iff (Eq (Dist.dist p₁ p) (Dist.dist p₂ p)) (Exists fun r => Eq (HVAdd.hVAdd (HSMul.hSMul r ((EuclideanGeometry.o.rotation ↑(HDiv.hDiv Real.pi 2)) (VSub.vsub p₂ p₁))) (midpoint Real p₁ p₂)) p)","decl":"/-- Two different points are equidistant from a third point if and only if that third point\nequals some multiple of a `π / 2` rotation of the vector between those points, plus the midpoint\nof those points. -/\ntheorem dist_eq_iff_eq_smul_rotation_pi_div_two_vadd_midpoint {p₁ p₂ p : P} (h : p₁ ≠ p₂) :\n    dist p₁ p = dist p₂ p ↔\n      ∃ r : ℝ, r • o.rotation (π / 2 : ℝ) (p₂ -ᵥ p₁) +ᵥ midpoint ℝ p₁ p₂ = p := by\n  refine ⟨fun hd => ?_, fun hr => ?_⟩\n  · have hi : ⟪p₂ -ᵥ p₁, p -ᵥ midpoint ℝ p₁ p₂⟫ = 0 := by\n      rw [@dist_eq_norm_vsub' V, @dist_eq_norm_vsub' V, ←\n        mul_self_inj (norm_nonneg _) (norm_nonneg _), ← real_inner_self_eq_norm_mul_norm, ←\n        real_inner_self_eq_norm_mul_norm] at hd\n      simp_rw [vsub_midpoint, ← vsub_sub_vsub_cancel_left p₂ p₁ p, inner_sub_left, inner_add_right,\n        inner_smul_right, hd, real_inner_comm (p -ᵥ p₁)]\n      abel\n    rw [@Orientation.inner_eq_zero_iff_eq_zero_or_eq_smul_rotation_pi_div_two V _ _ _ o,\n      or_iff_right (vsub_ne_zero.2 h.symm)] at hi\n    rcases hi with ⟨r, hr⟩\n    rw [eq_comm, ← eq_vadd_iff_vsub_eq] at hr\n    exact ⟨r, hr.symm⟩\n  · rcases hr with ⟨r, rfl⟩\n    simp_rw [@dist_eq_norm_vsub V, vsub_vadd_eq_vsub_sub, left_vsub_midpoint, right_vsub_midpoint,\n      invOf_eq_inv, ← neg_vsub_eq_vsub_rev p₂ p₁, ← mul_self_inj (norm_nonneg _) (norm_nonneg _), ←\n      real_inner_self_eq_norm_mul_norm, inner_sub_sub_self]\n    simp [-neg_vsub_eq_vsub_rev]\n\n"}
{"name":"Collinear.oangle_sign_of_sameRay_vsub","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ p₄ p₅ : P\nhp₁p₂ : Ne p₁ p₂\nhp₃p₄ : Ne p₃ p₄\nhc : Collinear Real (Insert.insert p₁ (Insert.insert p₂ (Insert.insert p₃ (Singleton.singleton p₄))))\nhr : SameRay Real (VSub.vsub p₂ p₁) (VSub.vsub p₄ p₃)\n⊢ Eq (EuclideanGeometry.oangle p₁ p₅ p₂).sign (EuclideanGeometry.oangle p₃ p₅ p₄).sign","decl":"/-- Given two pairs of distinct points on the same line, such that the vectors between those\npairs of points are on the same ray (oriented in the same direction on that line), and a fifth\npoint, the angles at the fifth point between each of those two pairs of points have the same\nsign. -/\ntheorem _root_.Collinear.oangle_sign_of_sameRay_vsub {p₁ p₂ p₃ p₄ : P} (p₅ : P) (hp₁p₂ : p₁ ≠ p₂)\n    (hp₃p₄ : p₃ ≠ p₄) (hc : Collinear ℝ ({p₁, p₂, p₃, p₄} : Set P))\n    (hr : SameRay ℝ (p₂ -ᵥ p₁) (p₄ -ᵥ p₃)) : (∡ p₁ p₅ p₂).sign = (∡ p₃ p₅ p₄).sign := by\n  by_cases hc₅₁₂ : Collinear ℝ ({p₅, p₁, p₂} : Set P)\n  · have hc₅₁₂₃₄ : Collinear ℝ ({p₅, p₁, p₂, p₃, p₄} : Set P) :=\n      (hc.collinear_insert_iff_of_ne (Set.mem_insert _ _)\n        (Set.mem_insert_of_mem _ (Set.mem_insert _ _)) hp₁p₂).2 hc₅₁₂\n    have hc₅₃₄ : Collinear ℝ ({p₅, p₃, p₄} : Set P) :=\n      (hc.collinear_insert_iff_of_ne\n        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _)))\n        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _\n          (Set.mem_singleton _)))) hp₃p₄).1 hc₅₁₂₃₄\n    rw [Set.insert_comm] at hc₅₁₂ hc₅₃₄\n    have hs₁₅₂ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc₅₁₂\n    have hs₃₅₄ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc₅₃₄\n    rw [← Real.Angle.sign_eq_zero_iff] at hs₁₅₂ hs₃₅₄\n    rw [hs₁₅₂, hs₃₅₄]\n  · let s : Set (P × P × P) :=\n      (fun x : line[ℝ, p₁, p₂] × V => (x.1, p₅, x.2 +ᵥ (x.1 : P))) ''\n        Set.univ ×ˢ {v | SameRay ℝ (p₂ -ᵥ p₁) v ∧ v ≠ 0}\n    have hco : IsConnected s :=\n      haveI : ConnectedSpace line[ℝ, p₁, p₂] := AddTorsor.connectedSpace _ _\n      (isConnected_univ.prod (isConnected_setOf_sameRay_and_ne_zero\n        (vsub_ne_zero.2 hp₁p₂.symm))).image _\n        (continuous_fst.subtype_val.prod_mk (continuous_const.prod_mk\n          (continuous_snd.vadd continuous_fst.subtype_val))).continuousOn\n    have hf : ContinuousOn (fun p : P × P × P => ∡ p.1 p.2.1 p.2.2) s := by\n      refine continuousOn_of_forall_continuousAt fun p hp => continuousAt_oangle ?_ ?_\n      all_goals\n        simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_univ, true_and, Prod.ext_iff] at hp\n        obtain ⟨q₁, q₅, q₂⟩ := p\n        dsimp only at hp ⊢\n        obtain ⟨⟨⟨q, hq⟩, v⟩, hv, rfl, rfl, rfl⟩ := hp\n        dsimp only [Subtype.coe_mk, Set.mem_setOf] at hv ⊢\n        obtain ⟨hvr, -⟩ := hv\n        rintro rfl\n        refine hc₅₁₂ ((collinear_insert_iff_of_mem_affineSpan ?_).2 (collinear_pair _ _ _))\n      · exact hq\n      · refine vadd_mem_of_mem_direction ?_ hq\n        rw [← exists_nonneg_left_iff_sameRay (vsub_ne_zero.2 hp₁p₂.symm)] at hvr\n        obtain ⟨r, -, rfl⟩ := hvr\n        rw [direction_affineSpan]\n        exact smul_vsub_rev_mem_vectorSpan_pair _ _ _\n    have hsp : ∀ p : P × P × P, p ∈ s → ∡ p.1 p.2.1 p.2.2 ≠ 0 ∧ ∡ p.1 p.2.1 p.2.2 ≠ π := by\n      intro p hp\n      simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and,\n        Prod.ext_iff] at hp\n      obtain ⟨q₁, q₅, q₂⟩ := p\n      dsimp only at hp ⊢\n      obtain ⟨⟨⟨q, hq⟩, v⟩, hv, rfl, rfl, rfl⟩ := hp\n      dsimp only [Subtype.coe_mk, Set.mem_setOf] at hv ⊢\n      obtain ⟨hvr, hv0⟩ := hv\n      rw [← exists_nonneg_left_iff_sameRay (vsub_ne_zero.2 hp₁p₂.symm)] at hvr\n      obtain ⟨r, -, rfl⟩ := hvr\n      change q ∈ line[ℝ, p₁, p₂] at hq\n      rw [oangle_ne_zero_and_ne_pi_iff_affineIndependent]\n      refine affineIndependent_of_ne_of_mem_of_not_mem_of_mem ?_ hq\n          (fun h => hc₅₁₂ ((collinear_insert_iff_of_mem_affineSpan h).2 (collinear_pair _ _ _))) ?_\n      · rwa [← @vsub_ne_zero V, vsub_vadd_eq_vsub_sub, vsub_self, zero_sub, neg_ne_zero]\n      · refine vadd_mem_of_mem_direction ?_ hq\n        rw [direction_affineSpan]\n        exact smul_vsub_rev_mem_vectorSpan_pair _ _ _\n    have hp₁p₂s : (p₁, p₅, p₂) ∈ s := by\n      simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and,\n        Prod.ext_iff]\n      refine ⟨⟨⟨p₁, left_mem_affineSpan_pair ℝ _ _⟩, p₂ -ᵥ p₁⟩,\n        ⟨SameRay.rfl, vsub_ne_zero.2 hp₁p₂.symm⟩, ?_⟩\n      simp\n    have hp₃p₄s : (p₃, p₅, p₄) ∈ s := by\n      simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and,\n        Prod.ext_iff]\n      refine ⟨⟨⟨p₃, hc.mem_affineSpan_of_mem_of_ne (Set.mem_insert _ _)\n        (Set.mem_insert_of_mem _ (Set.mem_insert _ _))\n        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _))) hp₁p₂⟩, p₄ -ᵥ p₃⟩,\n        ⟨hr, vsub_ne_zero.2 hp₃p₄.symm⟩, ?_⟩\n      simp\n    convert Real.Angle.sign_eq_of_continuousOn hco hf hsp hp₃p₄s hp₁p₂s\n\n"}
{"name":"Sbtw.oangle_sign_eq","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ p₄ : P\nh : Sbtw Real p₁ p₂ p₃\n⊢ Eq (EuclideanGeometry.oangle p₁ p₄ p₂).sign (EuclideanGeometry.oangle p₂ p₄ p₃).sign","decl":"/-- Given three points in strict order on the same line, and a fourth point, the angles at the\nfourth point between the first and second or second and third points have the same sign. -/\ntheorem _root_.Sbtw.oangle_sign_eq {p₁ p₂ p₃ : P} (p₄ : P) (h : Sbtw ℝ p₁ p₂ p₃) :\n    (∡ p₁ p₄ p₂).sign = (∡ p₂ p₄ p₃).sign :=\n  haveI hc : Collinear ℝ ({p₁, p₂, p₂, p₃} : Set P) := by simpa using h.wbtw.collinear\n  hc.oangle_sign_of_sameRay_vsub _ h.left_ne h.ne_right h.wbtw.sameRay_vsub\n\n"}
{"name":"Wbtw.oangle_sign_eq_of_ne_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ p₄ : P\nh : Wbtw Real p₁ p₂ p₃\nhne : Ne p₁ p₂\n⊢ Eq (EuclideanGeometry.oangle p₁ p₄ p₂).sign (EuclideanGeometry.oangle p₁ p₄ p₃).sign","decl":"/-- Given three points in weak order on the same line, with the first not equal to the second,\nand a fourth point, the angles at the fourth point between the first and second or first and\nthird points have the same sign. -/\ntheorem _root_.Wbtw.oangle_sign_eq_of_ne_left {p₁ p₂ p₃ : P} (p₄ : P) (h : Wbtw ℝ p₁ p₂ p₃)\n    (hne : p₁ ≠ p₂) : (∡ p₁ p₄ p₂).sign = (∡ p₁ p₄ p₃).sign :=\n  haveI hc : Collinear ℝ ({p₁, p₂, p₁, p₃} : Set P) := by\n    simpa [Set.insert_comm p₂] using h.collinear\n  hc.oangle_sign_of_sameRay_vsub _ hne (h.left_ne_right_of_ne_left hne.symm) h.sameRay_vsub_left\n\n"}
{"name":"Sbtw.oangle_sign_eq_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ p₄ : P\nh : Sbtw Real p₁ p₂ p₃\n⊢ Eq (EuclideanGeometry.oangle p₁ p₄ p₂).sign (EuclideanGeometry.oangle p₁ p₄ p₃).sign","decl":"/-- Given three points in strict order on the same line, and a fourth point, the angles at the\nfourth point between the first and second or first and third points have the same sign. -/\ntheorem _root_.Sbtw.oangle_sign_eq_left {p₁ p₂ p₃ : P} (p₄ : P) (h : Sbtw ℝ p₁ p₂ p₃) :\n    (∡ p₁ p₄ p₂).sign = (∡ p₁ p₄ p₃).sign :=\n  h.wbtw.oangle_sign_eq_of_ne_left _ h.left_ne\n\n"}
{"name":"Wbtw.oangle_sign_eq_of_ne_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ p₄ : P\nh : Wbtw Real p₁ p₂ p₃\nhne : Ne p₂ p₃\n⊢ Eq (EuclideanGeometry.oangle p₂ p₄ p₃).sign (EuclideanGeometry.oangle p₁ p₄ p₃).sign","decl":"/-- Given three points in weak order on the same line, with the second not equal to the third,\nand a fourth point, the angles at the fourth point between the second and third or first and\nthird points have the same sign. -/\ntheorem _root_.Wbtw.oangle_sign_eq_of_ne_right {p₁ p₂ p₃ : P} (p₄ : P) (h : Wbtw ℝ p₁ p₂ p₃)\n    (hne : p₂ ≠ p₃) : (∡ p₂ p₄ p₃).sign = (∡ p₁ p₄ p₃).sign := by\n  simp_rw [oangle_rev p₃, Real.Angle.sign_neg, h.symm.oangle_sign_eq_of_ne_left _ hne.symm]\n\n"}
{"name":"Sbtw.oangle_sign_eq_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\np₁ p₂ p₃ p₄ : P\nh : Sbtw Real p₁ p₂ p₃\n⊢ Eq (EuclideanGeometry.oangle p₂ p₄ p₃).sign (EuclideanGeometry.oangle p₁ p₄ p₃).sign","decl":"/-- Given three points in strict order on the same line, and a fourth point, the angles at the\nfourth point between the second and third or first and third points have the same sign. -/\ntheorem _root_.Sbtw.oangle_sign_eq_right {p₁ p₂ p₃ : P} (p₄ : P) (h : Sbtw ℝ p₁ p₂ p₃) :\n    (∡ p₂ p₄ p₃).sign = (∡ p₁ p₄ p₃).sign :=\n  h.wbtw.oangle_sign_eq_of_ne_right _ h.ne_right\n\n"}
{"name":"AffineSubspace.SSameSide.oangle_sign_eq","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\ns : AffineSubspace Real P\np₁ p₂ p₃ p₄ : P\nhp₁ : Membership.mem s p₁\nhp₂ : Membership.mem s p₂\nhp₃p₄ : s.SSameSide p₃ p₄\n⊢ Eq (EuclideanGeometry.oangle p₁ p₄ p₂).sign (EuclideanGeometry.oangle p₁ p₃ p₂).sign","decl":"/-- Given two points in an affine subspace, the angles between those two points at two other\npoints on the same side of that subspace have the same sign. -/\ntheorem _root_.AffineSubspace.SSameSide.oangle_sign_eq {s : AffineSubspace ℝ P} {p₁ p₂ p₃ p₄ : P}\n    (hp₁ : p₁ ∈ s) (hp₂ : p₂ ∈ s) (hp₃p₄ : s.SSameSide p₃ p₄) :\n    (∡ p₁ p₄ p₂).sign = (∡ p₁ p₃ p₂).sign := by\n  by_cases h : p₁ = p₂; · simp [h]\n  let sp : Set (P × P × P) := (fun p : P => (p₁, p, p₂)) '' {p | s.SSameSide p₃ p}\n  have hc : IsConnected sp := (isConnected_setOf_sSameSide hp₃p₄.2.1 hp₃p₄.nonempty).image _\n    (continuous_const.prod_mk (Continuous.Prod.mk_left _)).continuousOn\n  have hf : ContinuousOn (fun p : P × P × P => ∡ p.1 p.2.1 p.2.2) sp := by\n    refine continuousOn_of_forall_continuousAt fun p hp => continuousAt_oangle ?_ ?_\n    all_goals\n      simp_rw [sp, Set.mem_image, Set.mem_setOf] at hp\n      obtain ⟨p', hp', rfl⟩ := hp\n      dsimp only\n      rintro rfl\n    · exact hp'.2.2 hp₁\n    · exact hp'.2.2 hp₂\n  have hsp : ∀ p : P × P × P, p ∈ sp → ∡ p.1 p.2.1 p.2.2 ≠ 0 ∧ ∡ p.1 p.2.1 p.2.2 ≠ π := by\n    intro p hp\n    simp_rw [sp, Set.mem_image, Set.mem_setOf] at hp\n    obtain ⟨p', hp', rfl⟩ := hp\n    dsimp only\n    rw [oangle_ne_zero_and_ne_pi_iff_affineIndependent]\n    exact affineIndependent_of_ne_of_mem_of_not_mem_of_mem h hp₁ hp'.2.2 hp₂\n  have hp₃ : (p₁, p₃, p₂) ∈ sp :=\n    Set.mem_image_of_mem _ (sSameSide_self_iff.2 ⟨hp₃p₄.nonempty, hp₃p₄.2.1⟩)\n  have hp₄ : (p₁, p₄, p₂) ∈ sp := Set.mem_image_of_mem _ hp₃p₄\n  convert Real.Angle.sign_eq_of_continuousOn hc hf hsp hp₃ hp₄\n\n"}
{"name":"AffineSubspace.SOppSide.oangle_sign_eq_neg","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nhd2 : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Module.Oriented Real V (Fin 2)\ns : AffineSubspace Real P\np₁ p₂ p₃ p₄ : P\nhp₁ : Membership.mem s p₁\nhp₂ : Membership.mem s p₂\nhp₃p₄ : s.SOppSide p₃ p₄\n⊢ Eq (EuclideanGeometry.oangle p₁ p₄ p₂).sign (Neg.neg (EuclideanGeometry.oangle p₁ p₃ p₂).sign)","decl":"/-- Given two points in an affine subspace, the angles between those two points at two other\npoints on opposite sides of that subspace have opposite signs. -/\ntheorem _root_.AffineSubspace.SOppSide.oangle_sign_eq_neg {s : AffineSubspace ℝ P} {p₁ p₂ p₃ p₄ : P}\n    (hp₁ : p₁ ∈ s) (hp₂ : p₂ ∈ s) (hp₃p₄ : s.SOppSide p₃ p₄) :\n    (∡ p₁ p₄ p₂).sign = -(∡ p₁ p₃ p₂).sign := by\n  have hp₁p₃ : p₁ ≠ p₃ := by rintro rfl; exact hp₃p₄.left_not_mem hp₁\n  rw [← (hp₃p₄.symm.trans (sOppSide_pointReflection hp₁ hp₃p₄.left_not_mem)).oangle_sign_eq hp₁ hp₂,\n    ← oangle_rotate_sign p₁, ← oangle_rotate_sign p₁, oangle_swap₁₃_sign,\n    (sbtw_pointReflection_of_ne ℝ hp₁p₃).symm.oangle_sign_eq _]\n\n"}
