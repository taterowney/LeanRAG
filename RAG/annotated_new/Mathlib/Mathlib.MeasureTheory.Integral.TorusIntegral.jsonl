{"name":"torusMap_sub_center","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nc : Fin n ‚Üí Complex\nR Œ∏ : Fin n ‚Üí Real\n‚ä¢ Eq (HSub.hSub (torusMap c R Œ∏) c) (torusMap 0 R Œ∏)","decl":"theorem torusMap_sub_center (c : ‚ÑÇ‚Åø) (R : ‚Ñù‚Åø) (Œ∏ : ‚Ñù‚Åø) : torusMap c R Œ∏ - c = torusMap 0 R Œ∏ := by\n  ext1 i; simp [torusMap]\n\n"}
{"name":"torusMap_eq_center_iff","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nc : Fin n ‚Üí Complex\nR Œ∏ : Fin n ‚Üí Real\n‚ä¢ Iff (Eq (torusMap c R Œ∏) c) (Eq R 0)","decl":"theorem torusMap_eq_center_iff {c : ‚ÑÇ‚Åø} {R : ‚Ñù‚Åø} {Œ∏ : ‚Ñù‚Åø} : torusMap c R Œ∏ = c ‚Üî R = 0 := by\n  simp [funext_iff, torusMap, exp_ne_zero]\n\n"}
{"name":"torusMap_zero_radius","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nc : Fin n ‚Üí Complex\n‚ä¢ Eq (torusMap c 0) (Function.const (Fin n ‚Üí Real) c)","decl":"@[simp]\ntheorem torusMap_zero_radius (c : ‚ÑÇ‚Åø) : torusMap c 0 = const ‚Ñù‚Åø c :=\n  funext fun _ ‚Ü¶ torusMap_eq_center_iff.2 rfl\n\n"}
{"name":"TorusIntegrable.torusIntegrable_const","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninst‚úù : NormedAddCommGroup E\na : E\nc : Fin n ‚Üí Complex\nR : Fin n ‚Üí Real\n‚ä¢ TorusIntegrable (fun x => a) c R","decl":"/-- Constant functions are torus integrable -/\ntheorem torusIntegrable_const (a : E) (c : ‚ÑÇ‚Åø) (R : ‚Ñù‚Åø) : TorusIntegrable (fun _ => a) c R := by\n  simp [TorusIntegrable, measure_Icc_lt_top]\n\n"}
{"name":"TorusIntegrable.neg","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : (Fin n ‚Üí Complex) ‚Üí E\nc : Fin n ‚Üí Complex\nR : Fin n ‚Üí Real\nhf : TorusIntegrable f c R\n‚ä¢ TorusIntegrable (Neg.neg f) c R","decl":"/-- If `f` is torus integrable then `-f` is torus integrable. -/\nprotected nonrec theorem neg (hf : TorusIntegrable f c R) : TorusIntegrable (-f) c R := hf.neg\n\n"}
{"name":"TorusIntegrable.add","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninst‚úù : NormedAddCommGroup E\nf g : (Fin n ‚Üí Complex) ‚Üí E\nc : Fin n ‚Üí Complex\nR : Fin n ‚Üí Real\nhf : TorusIntegrable f c R\nhg : TorusIntegrable g c R\n‚ä¢ TorusIntegrable (HAdd.hAdd f g) c R","decl":"/-- If `f` and `g` are two torus integrable functions, then so is `f + g`. -/\nprotected nonrec theorem add (hf : TorusIntegrable f c R) (hg : TorusIntegrable g c R) :\n    TorusIntegrable (f + g) c R :=\n  hf.add hg\n\n"}
{"name":"TorusIntegrable.sub","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninst‚úù : NormedAddCommGroup E\nf g : (Fin n ‚Üí Complex) ‚Üí E\nc : Fin n ‚Üí Complex\nR : Fin n ‚Üí Real\nhf : TorusIntegrable f c R\nhg : TorusIntegrable g c R\n‚ä¢ TorusIntegrable (HSub.hSub f g) c R","decl":"/-- If `f` and `g` are two torus integrable functions, then so is `f - g`. -/\nprotected nonrec theorem sub (hf : TorusIntegrable f c R) (hg : TorusIntegrable g c R) :\n    TorusIntegrable (f - g) c R :=\n  hf.sub hg\n\n"}
{"name":"TorusIntegrable.torusIntegrable_zero_radius","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : (Fin n ‚Üí Complex) ‚Üí E\nc : Fin n ‚Üí Complex\n‚ä¢ TorusIntegrable f c 0","decl":"theorem torusIntegrable_zero_radius {f : ‚ÑÇ‚Åø ‚Üí E} {c : ‚ÑÇ‚Åø} : TorusIntegrable f c 0 := by\n  rw [TorusIntegrable, torusMap_zero_radius]\n  apply torusIntegrable_const (f c) c 0\n\n"}
{"name":"TorusIntegrable.function_integrable","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\nf : (Fin n ‚Üí Complex) ‚Üí E\nc : Fin n ‚Üí Complex\nR : Fin n ‚Üí Real\ninst‚úù : NormedSpace Complex E\nhf : TorusIntegrable f c R\n‚ä¢ MeasureTheory.IntegrableOn (fun Œ∏ => HSMul.hSMul (Finset.univ.prod fun i => HMul.hMul (HMul.hMul (‚Üë(R i)) (Complex.exp (HMul.hMul (‚Üë(Œ∏ i)) Complex.I))) Complex.I) (f (torusMap c R Œ∏))) (Set.Icc 0 fun x => HMul.hMul 2 Real.pi) MeasureTheory.MeasureSpace.volume","decl":"/-- The function given in the definition of `torusIntegral` is integrable. -/\ntheorem function_integrable [NormedSpace ‚ÑÇ E] (hf : TorusIntegrable f c R) :\n    IntegrableOn (fun Œ∏ : ‚Ñù‚Åø => (‚àè i, R i * exp (Œ∏ i * I) * I : ‚ÑÇ) ‚Ä¢ f (torusMap c R Œ∏))\n      (Icc (0 : ‚Ñù‚Åø) fun _ => 2 * œÄ) volume := by\n  refine (hf.norm.const_mul (‚àè i, |R i|)).mono' ?_ ?_\n  ¬∑ refine (Continuous.aestronglyMeasurable ?_).smul hf.1; fun_prop\n  simp [norm_smul, map_prod]\n\n"}
{"name":"torusIntegral_radius_zero","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nhn : Ne n 0\nf : (Fin n ‚Üí Complex) ‚Üí E\nc : Fin n ‚Üí Complex\n‚ä¢ Eq (torusIntegral (fun x => f x) c 0) 0","decl":"theorem torusIntegral_radius_zero (hn : n ‚â† 0) (f : ‚ÑÇ‚Åø ‚Üí E) (c : ‚ÑÇ‚Åø) :\n    (‚àØ x in T(c, 0), f x) = 0 := by\n  simp only [torusIntegral, Pi.zero_apply, ofReal_zero, mul_zero, zero_mul, Fin.prod_const,\n    zero_pow hn, zero_smul, integral_zero]\n\n"}
{"name":"torusIntegral_neg","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : (Fin n ‚Üí Complex) ‚Üí E\nc : Fin n ‚Üí Complex\nR : Fin n ‚Üí Real\n‚ä¢ Eq (torusIntegral (fun x => Neg.neg (f x)) c R) (Neg.neg (torusIntegral (fun x => f x) c R))","decl":"theorem torusIntegral_neg (f : ‚ÑÇ‚Åø ‚Üí E) (c : ‚ÑÇ‚Åø) (R : ‚Ñù‚Åø) :\n    (‚àØ x in T(c, R), -f x) = -‚àØ x in T(c, R), f x := by simp [torusIntegral, integral_neg]\n\n"}
{"name":"torusIntegral_add","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf g : (Fin n ‚Üí Complex) ‚Üí E\nc : Fin n ‚Üí Complex\nR : Fin n ‚Üí Real\nhf : TorusIntegrable f c R\nhg : TorusIntegrable g c R\n‚ä¢ Eq (torusIntegral (fun x => HAdd.hAdd (f x) (g x)) c R) (HAdd.hAdd (torusIntegral (fun x => f x) c R) (torusIntegral (fun x => g x) c R))","decl":"theorem torusIntegral_add (hf : TorusIntegrable f c R) (hg : TorusIntegrable g c R) :\n    (‚àØ x in T(c, R), f x + g x) = (‚àØ x in T(c, R), f x) + ‚àØ x in T(c, R), g x := by\n  simpa only [torusIntegral, smul_add, Pi.add_apply] using\n    integral_add hf.function_integrable hg.function_integrable\n\n"}
{"name":"torusIntegral_sub","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf g : (Fin n ‚Üí Complex) ‚Üí E\nc : Fin n ‚Üí Complex\nR : Fin n ‚Üí Real\nhf : TorusIntegrable f c R\nhg : TorusIntegrable g c R\n‚ä¢ Eq (torusIntegral (fun x => HSub.hSub (f x) (g x)) c R) (HSub.hSub (torusIntegral (fun x => f x) c R) (torusIntegral (fun x => g x) c R))","decl":"theorem torusIntegral_sub (hf : TorusIntegrable f c R) (hg : TorusIntegrable g c R) :\n    (‚àØ x in T(c, R), f x - g x) = (‚àØ x in T(c, R), f x) - ‚àØ x in T(c, R), g x := by\n  simpa only [sub_eq_add_neg, ‚Üê torusIntegral_neg] using torusIntegral_add hf hg.neg\n\n"}
{"name":"torusIntegral_smul","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Complex E\nùïú : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedSpace ùïú E\ninst‚úù : SMulCommClass ùïú Complex E\na : ùïú\nf : (Fin n ‚Üí Complex) ‚Üí E\nc : Fin n ‚Üí Complex\nR : Fin n ‚Üí Real\n‚ä¢ Eq (torusIntegral (fun x => HSMul.hSMul a (f x)) c R) (HSMul.hSMul a (torusIntegral (fun x => f x) c R))","decl":"theorem torusIntegral_smul {ùïú : Type*} [RCLike ùïú] [NormedSpace ùïú E] [SMulCommClass ùïú ‚ÑÇ E] (a : ùïú)\n    (f : ‚ÑÇ‚Åø ‚Üí E) (c : ‚ÑÇ‚Åø) (R : ‚Ñù‚Åø) : (‚àØ x in T(c, R), a ‚Ä¢ f x) = a ‚Ä¢ ‚àØ x in T(c, R), f x := by\n  simp only [torusIntegral, integral_smul, ‚Üê smul_comm a (_ : ‚ÑÇ) (_ : E)]\n\n"}
{"name":"torusIntegral_const_mul","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\na : Complex\nf : (Fin n ‚Üí Complex) ‚Üí Complex\nc : Fin n ‚Üí Complex\nR : Fin n ‚Üí Real\n‚ä¢ Eq (torusIntegral (fun x => HMul.hMul a (f x)) c R) (HMul.hMul a (torusIntegral (fun x => f x) c R))","decl":"theorem torusIntegral_const_mul (a : ‚ÑÇ) (f : ‚ÑÇ‚Åø ‚Üí ‚ÑÇ) (c : ‚ÑÇ‚Åø) (R : ‚Ñù‚Åø) :\n    (‚àØ x in T(c, R), a * f x) = a * ‚àØ x in T(c, R), f x :=\n  torusIntegral_smul a f c R\n\n"}
{"name":"norm_torusIntegral_le_of_norm_le_const","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : (Fin n ‚Üí Complex) ‚Üí E\nc : Fin n ‚Üí Complex\nR : Fin n ‚Üí Real\nC : Real\nhf : ‚àÄ (Œ∏ : Fin n ‚Üí Real), LE.le (Norm.norm (f (torusMap c R Œ∏))) C\n‚ä¢ LE.le (Norm.norm (torusIntegral (fun x => f x) c R)) (HMul.hMul (HMul.hMul (HPow.hPow (HMul.hMul 2 Real.pi) n) (Finset.univ.prod fun i => abs (R i))) C)","decl":"/-- If for all `Œ∏ : ‚Ñù‚Åø`, `‚Äñf (torusMap c R Œ∏)‚Äñ` is less than or equal to a constant `C : ‚Ñù`, then\n`‚Äñ‚àØ x in T(c, R), f x‚Äñ` is less than or equal to `(2 * œÄ)^n * (‚àè i, |R i|) * C`-/\ntheorem norm_torusIntegral_le_of_norm_le_const {C : ‚Ñù} (hf : ‚àÄ Œ∏, ‚Äñf (torusMap c R Œ∏)‚Äñ ‚â§ C) :\n    ‚Äñ‚àØ x in T(c, R), f x‚Äñ ‚â§ ((2 * œÄ) ^ (n : ‚Ñï) * ‚àè i, |R i|) * C :=\n  calc\n    ‚Äñ‚àØ x in T(c, R), f x‚Äñ ‚â§ (‚àè i, |R i|) * C * (volume (Icc (0 : ‚Ñù‚Åø) fun _ => 2 * œÄ)).toReal :=\n      norm_setIntegral_le_of_norm_le_const' measure_Icc_lt_top measurableSet_Icc fun Œ∏ _ =>\n        calc\n          ‚Äñ(‚àè i : Fin n, R i * exp (Œ∏ i * I) * I : ‚ÑÇ) ‚Ä¢ f (torusMap c R Œ∏)‚Äñ =\n              (‚àè i : Fin n, |R i|) * ‚Äñf (torusMap c R Œ∏)‚Äñ := by simp [norm_smul]\n          _ ‚â§ (‚àè i : Fin n, |R i|) * C := mul_le_mul_of_nonneg_left (hf _) <| by positivity\n    _ = ((2 * œÄ) ^ (n : ‚Ñï) * ‚àè i, |R i|) * C := by\n      simp only [Pi.zero_def, Real.volume_Icc_pi_toReal fun _ => Real.two_pi_pos.le, sub_zero,\n        Fin.prod_const, mul_assoc, mul_comm ((2 * œÄ) ^ (n : ‚Ñï))]\n\n"}
{"name":"torusIntegral_dim0","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"E : Type u_1\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Complex E\ninst‚úù : CompleteSpace E\nf : (Fin 0 ‚Üí Complex) ‚Üí E\nc : Fin 0 ‚Üí Complex\nR : Fin 0 ‚Üí Real\n‚ä¢ Eq (torusIntegral (fun x => f x) c R) (f c)","decl":"@[simp]\ntheorem torusIntegral_dim0 [CompleteSpace E]\n    (f : ‚ÑÇ‚Å∞ ‚Üí E) (c : ‚ÑÇ‚Å∞) (R : ‚Ñù‚Å∞) : (‚àØ x in T(c, R), f x) = f c := by\n  simp only [torusIntegral, Fin.prod_univ_zero, one_smul,\n    Subsingleton.elim (fun _ : Fin 0 => 2 * œÄ) 0, Icc_self, Measure.restrict_singleton, volume_pi,\n    integral_smul_measure, integral_dirac, Measure.pi_of_empty (fun _ : Fin 0 ‚Ü¶ volume) 0,\n    Measure.dirac_apply_of_mem (mem_singleton _), Subsingleton.elim (torusMap c R 0) c]\n\n"}
{"name":"torusIntegral_dim1","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : (Fin 1 ‚Üí Complex) ‚Üí E\nc : Fin 1 ‚Üí Complex\nR : Fin 1 ‚Üí Real\n‚ä¢ Eq (torusIntegral (fun x => f x) c R) (circleIntegral (fun z => f fun x => z) (c 0) (R 0))","decl":"/-- In dimension one, `torusIntegral` is the same as `circleIntegral`\n(up to the natural equivalence between `‚ÑÇ` and `Fin 1 ‚Üí ‚ÑÇ`). -/\ntheorem torusIntegral_dim1 (f : ‚ÑÇ¬π ‚Üí E) (c : ‚ÑÇ¬π) (R : ‚Ñù¬π) :\n    (‚àØ x in T(c, R), f x) = ‚àÆ z in C(c 0, R 0), f fun _ => z := by\n  have H‚ÇÅ : (((MeasurableEquiv.funUnique _ _).symm) ‚Åª¬π' Icc 0 fun _ => 2 * œÄ) = Icc 0 (2 * œÄ) :=\n    (OrderIso.funUnique (Fin 1) ‚Ñù).symm.preimage_Icc _ _\n  have H‚ÇÇ : torusMap c R = fun Œ∏ _ ‚Ü¶ circleMap (c 0) (R 0) (Œ∏ 0) := by\n    ext Œ∏ i : 2\n    rw [Subsingleton.elim i 0]; rfl\n  rw [torusIntegral, circleIntegral, intervalIntegral.integral_of_le Real.two_pi_pos.le,\n    Measure.restrict_congr_set Ioc_ae_eq_Icc,\n    ‚Üê ((volume_preserving_funUnique (Fin 1) ‚Ñù).symm _).setIntegral_preimage_emb\n      (MeasurableEquiv.measurableEmbedding _), H‚ÇÅ, H‚ÇÇ]\n  simp [circleMap_zero]\n\n"}
{"name":"torusIntegral_succAbove","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : (Fin (HAdd.hAdd n 1) ‚Üí Complex) ‚Üí E\nc : Fin (HAdd.hAdd n 1) ‚Üí Complex\nR : Fin (HAdd.hAdd n 1) ‚Üí Real\nhf : TorusIntegrable f c R\ni : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq (torusIntegral (fun x => f x) c R) (circleIntegral (fun x => torusIntegral (fun y => f (i.insertNth x y)) (Function.comp c i.succAbove) (Function.comp R i.succAbove)) (c i) (R i))","decl":"/-- Recurrent formula for `torusIntegral`, see also `torusIntegral_succ`. -/\ntheorem torusIntegral_succAbove\n    {f : ‚ÑÇ‚Åø‚Å∫¬π ‚Üí E} {c : ‚ÑÇ‚Åø‚Å∫¬π} {R : ‚Ñù‚Åø‚Å∫¬π} (hf : TorusIntegrable f c R)\n    (i : Fin (n + 1)) :\n    (‚àØ x in T(c, R), f x) =\n      ‚àÆ x in C(c i, R i), ‚àØ y in T(c ‚àò i.succAbove, R ‚àò i.succAbove), f (i.insertNth x y) := by\n  set e : ‚Ñù √ó ‚Ñù‚Åø ‚âÉ·µê ‚Ñù‚Åø‚Å∫¬π := (MeasurableEquiv.piFinSuccAbove (fun _ => ‚Ñù) i).symm\n  have hem : MeasurePreserving e :=\n    (volume_preserving_piFinSuccAbove (fun _ : Fin (n + 1) => ‚Ñù) i).symm _\n  have heœÄ : (e ‚Åª¬π' Icc 0 fun _ => 2 * œÄ) = Icc 0 (2 * œÄ) √óÀ¢ Icc (0 : ‚Ñù‚Åø) fun _ => 2 * œÄ :=\n    ((Fin.insertNthOrderIso (fun _ => ‚Ñù) i).preimage_Icc _ _).trans (Icc_prod_eq _ _)\n  rw [torusIntegral, ‚Üê hem.map_eq, setIntegral_map_equiv, heœÄ, Measure.volume_eq_prod,\n    setIntegral_prod, circleIntegral_def_Icc]\n  ¬∑ refine setIntegral_congr_fun measurableSet_Icc fun Œ∏ _ => ?_\n    simp (config := { unfoldPartialApp := true }) only [e, torusIntegral, ‚Üê integral_smul,\n      deriv_circleMap, i.prod_univ_succAbove _, smul_smul, torusMap, circleMap_zero]\n    refine setIntegral_congr_fun measurableSet_Icc fun Œò _ => ?_\n    simp only [MeasurableEquiv.piFinSuccAbove_symm_apply, i.insertNth_apply_same,\n      i.insertNth_apply_succAbove, (¬∑ ‚àò ¬∑), Fin.insertNthEquiv, Equiv.coe_fn_mk]\n    congr 2\n    simp only [funext_iff, i.forall_iff_succAbove, circleMap, Fin.insertNth_apply_same,\n      eq_self_iff_true, Fin.insertNth_apply_succAbove, imp_true_iff, and_self_iff]\n  ¬∑ have := hf.function_integrable\n    rwa [‚Üê hem.integrableOn_comp_preimage e.measurableEmbedding, heœÄ] at this\n\n"}
{"name":"torusIntegral_succ","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : (Fin (HAdd.hAdd n 1) ‚Üí Complex) ‚Üí E\nc : Fin (HAdd.hAdd n 1) ‚Üí Complex\nR : Fin (HAdd.hAdd n 1) ‚Üí Real\nhf : TorusIntegrable f c R\n‚ä¢ Eq (torusIntegral (fun x => f x) c R) (circleIntegral (fun x => torusIntegral (fun y => f (Fin.cons x y)) (Function.comp c Fin.succ) (Function.comp R Fin.succ)) (c 0) (R 0))","decl":"/-- Recurrent formula for `torusIntegral`, see also `torusIntegral_succAbove`. -/\ntheorem torusIntegral_succ\n    {f : ‚ÑÇ‚Åø‚Å∫¬π ‚Üí E} {c : ‚ÑÇ‚Åø‚Å∫¬π} {R : ‚Ñù‚Åø‚Å∫¬π} (hf : TorusIntegrable f c R) :\n    (‚àØ x in T(c, R), f x) =\n      ‚àÆ x in C(c 0, R 0), ‚àØ y in T(c ‚àò Fin.succ, R ‚àò Fin.succ), f (Fin.cons x y) := by\n  simpa using torusIntegral_succAbove hf 0\n"}
