{"name":"torusMap_sub_center","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nc : Fin n â†’ Complex\nR Î¸ : Fin n â†’ Real\nâŠ¢ Eq (HSub.hSub (torusMap c R Î¸) c) (torusMap 0 R Î¸)","decl":"theorem torusMap_sub_center (c : â„‚â¿) (R : â„â¿) (Î¸ : â„â¿) : torusMap c R Î¸ - c = torusMap 0 R Î¸ := by\n  ext1 i; simp [torusMap]\n\n"}
{"name":"torusMap_eq_center_iff","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nc : Fin n â†’ Complex\nR Î¸ : Fin n â†’ Real\nâŠ¢ Iff (Eq (torusMap c R Î¸) c) (Eq R 0)","decl":"theorem torusMap_eq_center_iff {c : â„‚â¿} {R : â„â¿} {Î¸ : â„â¿} : torusMap c R Î¸ = c â†” R = 0 := by\n  simp [funext_iff, torusMap, exp_ne_zero]\n\n"}
{"name":"torusMap_zero_radius","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nc : Fin n â†’ Complex\nâŠ¢ Eq (torusMap c 0) (Function.const (Fin n â†’ Real) c)","decl":"@[simp]\ntheorem torusMap_zero_radius (c : â„‚â¿) : torusMap c 0 = const â„â¿ c :=\n  funext fun _ â†¦ torusMap_eq_center_iff.2 rfl\n\n"}
{"name":"TorusIntegrable.torusIntegrable_const","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninstâœ : NormedAddCommGroup E\na : E\nc : Fin n â†’ Complex\nR : Fin n â†’ Real\nâŠ¢ TorusIntegrable (fun x => a) c R","decl":"/-- Constant functions are torus integrable -/\ntheorem torusIntegrable_const (a : E) (c : â„‚â¿) (R : â„â¿) : TorusIntegrable (fun _ => a) c R := by\n  simp [TorusIntegrable, measure_Icc_lt_top]\n\n"}
{"name":"TorusIntegrable.neg","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninstâœ : NormedAddCommGroup E\nf : (Fin n â†’ Complex) â†’ E\nc : Fin n â†’ Complex\nR : Fin n â†’ Real\nhf : TorusIntegrable f c R\nâŠ¢ TorusIntegrable (Neg.neg f) c R","decl":"/-- If `f` is torus integrable then `-f` is torus integrable. -/\nprotected nonrec theorem neg (hf : TorusIntegrable f c R) : TorusIntegrable (-f) c R := hf.neg\n\n"}
{"name":"TorusIntegrable.add","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninstâœ : NormedAddCommGroup E\nf g : (Fin n â†’ Complex) â†’ E\nc : Fin n â†’ Complex\nR : Fin n â†’ Real\nhf : TorusIntegrable f c R\nhg : TorusIntegrable g c R\nâŠ¢ TorusIntegrable (HAdd.hAdd f g) c R","decl":"/-- If `f` and `g` are two torus integrable functions, then so is `f + g`. -/\nprotected nonrec theorem add (hf : TorusIntegrable f c R) (hg : TorusIntegrable g c R) :\n    TorusIntegrable (f + g) c R :=\n  hf.add hg\n\n"}
{"name":"TorusIntegrable.sub","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninstâœ : NormedAddCommGroup E\nf g : (Fin n â†’ Complex) â†’ E\nc : Fin n â†’ Complex\nR : Fin n â†’ Real\nhf : TorusIntegrable f c R\nhg : TorusIntegrable g c R\nâŠ¢ TorusIntegrable (HSub.hSub f g) c R","decl":"/-- If `f` and `g` are two torus integrable functions, then so is `f - g`. -/\nprotected nonrec theorem sub (hf : TorusIntegrable f c R) (hg : TorusIntegrable g c R) :\n    TorusIntegrable (f - g) c R :=\n  hf.sub hg\n\n"}
{"name":"TorusIntegrable.torusIntegrable_zero_radius","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninstâœ : NormedAddCommGroup E\nf : (Fin n â†’ Complex) â†’ E\nc : Fin n â†’ Complex\nâŠ¢ TorusIntegrable f c 0","decl":"theorem torusIntegrable_zero_radius {f : â„‚â¿ â†’ E} {c : â„‚â¿} : TorusIntegrable f c 0 := by\n  rw [TorusIntegrable, torusMap_zero_radius]\n  apply torusIntegrable_const (f c) c 0\n\n"}
{"name":"TorusIntegrable.function_integrable","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\nf : (Fin n â†’ Complex) â†’ E\nc : Fin n â†’ Complex\nR : Fin n â†’ Real\ninstâœ : NormedSpace Complex E\nhf : TorusIntegrable f c R\nâŠ¢ MeasureTheory.IntegrableOn (fun Î¸ => HSMul.hSMul (Finset.univ.prod fun i => HMul.hMul (HMul.hMul (â†‘(R i)) (Complex.exp (HMul.hMul (â†‘(Î¸ i)) Complex.I))) Complex.I) (f (torusMap c R Î¸))) (Set.Icc 0 fun x => HMul.hMul 2 Real.pi) MeasureTheory.MeasureSpace.volume","decl":"/-- The function given in the definition of `torusIntegral` is integrable. -/\ntheorem function_integrable [NormedSpace â„‚ E] (hf : TorusIntegrable f c R) :\n    IntegrableOn (fun Î¸ : â„â¿ => (âˆ i, R i * exp (Î¸ i * I) * I : â„‚) â€¢ f (torusMap c R Î¸))\n      (Icc (0 : â„â¿) fun _ => 2 * Ï€) volume := by\n  refine (hf.norm.const_mul (âˆ i, |R i|)).mono' ?_ ?_\n  Â· refine (Continuous.aestronglyMeasurable ?_).smul hf.1; fun_prop\n  simp [norm_smul, map_prod]\n\n"}
{"name":"torusIntegral_radius_zero","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nhn : Ne n 0\nf : (Fin n â†’ Complex) â†’ E\nc : Fin n â†’ Complex\nâŠ¢ Eq (torusIntegral (fun x => f x) c 0) 0","decl":"theorem torusIntegral_radius_zero (hn : n â‰  0) (f : â„‚â¿ â†’ E) (c : â„‚â¿) :\n    (âˆ¯ x in T(c, 0), f x) = 0 := by\n  simp only [torusIntegral, Pi.zero_apply, ofReal_zero, mul_zero, zero_mul, Fin.prod_const,\n    zero_pow hn, zero_smul, integral_zero]\n\n"}
{"name":"torusIntegral_neg","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : (Fin n â†’ Complex) â†’ E\nc : Fin n â†’ Complex\nR : Fin n â†’ Real\nâŠ¢ Eq (torusIntegral (fun x => Neg.neg (f x)) c R) (Neg.neg (torusIntegral (fun x => f x) c R))","decl":"theorem torusIntegral_neg (f : â„‚â¿ â†’ E) (c : â„‚â¿) (R : â„â¿) :\n    (âˆ¯ x in T(c, R), -f x) = -âˆ¯ x in T(c, R), f x := by simp [torusIntegral, integral_neg]\n\n"}
{"name":"torusIntegral_add","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf g : (Fin n â†’ Complex) â†’ E\nc : Fin n â†’ Complex\nR : Fin n â†’ Real\nhf : TorusIntegrable f c R\nhg : TorusIntegrable g c R\nâŠ¢ Eq (torusIntegral (fun x => HAdd.hAdd (f x) (g x)) c R) (HAdd.hAdd (torusIntegral (fun x => f x) c R) (torusIntegral (fun x => g x) c R))","decl":"theorem torusIntegral_add (hf : TorusIntegrable f c R) (hg : TorusIntegrable g c R) :\n    (âˆ¯ x in T(c, R), f x + g x) = (âˆ¯ x in T(c, R), f x) + âˆ¯ x in T(c, R), g x := by\n  simpa only [torusIntegral, smul_add, Pi.add_apply] using\n    integral_add hf.function_integrable hg.function_integrable\n\n"}
{"name":"torusIntegral_sub","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf g : (Fin n â†’ Complex) â†’ E\nc : Fin n â†’ Complex\nR : Fin n â†’ Real\nhf : TorusIntegrable f c R\nhg : TorusIntegrable g c R\nâŠ¢ Eq (torusIntegral (fun x => HSub.hSub (f x) (g x)) c R) (HSub.hSub (torusIntegral (fun x => f x) c R) (torusIntegral (fun x => g x) c R))","decl":"theorem torusIntegral_sub (hf : TorusIntegrable f c R) (hg : TorusIntegrable g c R) :\n    (âˆ¯ x in T(c, R), f x - g x) = (âˆ¯ x in T(c, R), f x) - âˆ¯ x in T(c, R), g x := by\n  simpa only [sub_eq_add_neg, â† torusIntegral_neg] using torusIntegral_add hf hg.neg\n\n"}
{"name":"torusIntegral_smul","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Complex E\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : SMulCommClass ğ•œ Complex E\na : ğ•œ\nf : (Fin n â†’ Complex) â†’ E\nc : Fin n â†’ Complex\nR : Fin n â†’ Real\nâŠ¢ Eq (torusIntegral (fun x => HSMul.hSMul a (f x)) c R) (HSMul.hSMul a (torusIntegral (fun x => f x) c R))","decl":"theorem torusIntegral_smul {ğ•œ : Type*} [RCLike ğ•œ] [NormedSpace ğ•œ E] [SMulCommClass ğ•œ â„‚ E] (a : ğ•œ)\n    (f : â„‚â¿ â†’ E) (c : â„‚â¿) (R : â„â¿) : (âˆ¯ x in T(c, R), a â€¢ f x) = a â€¢ âˆ¯ x in T(c, R), f x := by\n  simp only [torusIntegral, integral_smul, â† smul_comm a (_ : â„‚) (_ : E)]\n\n"}
{"name":"torusIntegral_const_mul","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\na : Complex\nf : (Fin n â†’ Complex) â†’ Complex\nc : Fin n â†’ Complex\nR : Fin n â†’ Real\nâŠ¢ Eq (torusIntegral (fun x => HMul.hMul a (f x)) c R) (HMul.hMul a (torusIntegral (fun x => f x) c R))","decl":"theorem torusIntegral_const_mul (a : â„‚) (f : â„‚â¿ â†’ â„‚) (c : â„‚â¿) (R : â„â¿) :\n    (âˆ¯ x in T(c, R), a * f x) = a * âˆ¯ x in T(c, R), f x :=\n  torusIntegral_smul a f c R\n\n"}
{"name":"norm_torusIntegral_le_of_norm_le_const","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : (Fin n â†’ Complex) â†’ E\nc : Fin n â†’ Complex\nR : Fin n â†’ Real\nC : Real\nhf : âˆ€ (Î¸ : Fin n â†’ Real), LE.le (Norm.norm (f (torusMap c R Î¸))) C\nâŠ¢ LE.le (Norm.norm (torusIntegral (fun x => f x) c R)) (HMul.hMul (HMul.hMul (HPow.hPow (HMul.hMul 2 Real.pi) n) (Finset.univ.prod fun i => abs (R i))) C)","decl":"/-- If for all `Î¸ : â„â¿`, `â€–f (torusMap c R Î¸)â€–` is less than or equal to a constant `C : â„`, then\n`â€–âˆ¯ x in T(c, R), f xâ€–` is less than or equal to `(2 * Ï€)^n * (âˆ i, |R i|) * C`-/\ntheorem norm_torusIntegral_le_of_norm_le_const {C : â„} (hf : âˆ€ Î¸, â€–f (torusMap c R Î¸)â€– â‰¤ C) :\n    â€–âˆ¯ x in T(c, R), f xâ€– â‰¤ ((2 * Ï€) ^ (n : â„•) * âˆ i, |R i|) * C :=\n  calc\n    â€–âˆ¯ x in T(c, R), f xâ€– â‰¤ (âˆ i, |R i|) * C * (volume (Icc (0 : â„â¿) fun _ => 2 * Ï€)).toReal :=\n      norm_setIntegral_le_of_norm_le_const' measure_Icc_lt_top measurableSet_Icc fun Î¸ _ =>\n        calc\n          â€–(âˆ i : Fin n, R i * exp (Î¸ i * I) * I : â„‚) â€¢ f (torusMap c R Î¸)â€– =\n              (âˆ i : Fin n, |R i|) * â€–f (torusMap c R Î¸)â€– := by simp [norm_smul]\n          _ â‰¤ (âˆ i : Fin n, |R i|) * C := mul_le_mul_of_nonneg_left (hf _) <| by positivity\n    _ = ((2 * Ï€) ^ (n : â„•) * âˆ i, |R i|) * C := by\n      simp only [Pi.zero_def, Real.volume_Icc_pi_toReal fun _ => Real.two_pi_pos.le, sub_zero,\n        Fin.prod_const, mul_assoc, mul_comm ((2 * Ï€) ^ (n : â„•))]\n\n"}
{"name":"torusIntegral_dim0","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Complex E\ninstâœ : CompleteSpace E\nf : (Fin 0 â†’ Complex) â†’ E\nc : Fin 0 â†’ Complex\nR : Fin 0 â†’ Real\nâŠ¢ Eq (torusIntegral (fun x => f x) c R) (f c)","decl":"@[simp]\ntheorem torusIntegral_dim0 [CompleteSpace E]\n    (f : â„‚â° â†’ E) (c : â„‚â°) (R : â„â°) : (âˆ¯ x in T(c, R), f x) = f c := by\n  simp only [torusIntegral, Fin.prod_univ_zero, one_smul,\n    Subsingleton.elim (fun _ : Fin 0 => 2 * Ï€) 0, Icc_self, Measure.restrict_singleton, volume_pi,\n    integral_smul_measure, integral_dirac, Measure.pi_of_empty (fun _ : Fin 0 â†¦ volume) 0,\n    Measure.dirac_apply_of_mem (mem_singleton _), Subsingleton.elim (torusMap c R 0) c]\n\n"}
{"name":"torusIntegral_dim1","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : (Fin 1 â†’ Complex) â†’ E\nc : Fin 1 â†’ Complex\nR : Fin 1 â†’ Real\nâŠ¢ Eq (torusIntegral (fun x => f x) c R) (circleIntegral (fun z => f fun x => z) (c 0) (R 0))","decl":"/-- In dimension one, `torusIntegral` is the same as `circleIntegral`\n(up to the natural equivalence between `â„‚` and `Fin 1 â†’ â„‚`). -/\ntheorem torusIntegral_dim1 (f : â„‚Â¹ â†’ E) (c : â„‚Â¹) (R : â„Â¹) :\n    (âˆ¯ x in T(c, R), f x) = âˆ® z in C(c 0, R 0), f fun _ => z := by\n  have Hâ‚ : (((MeasurableEquiv.funUnique _ _).symm) â»Â¹' Icc 0 fun _ => 2 * Ï€) = Icc 0 (2 * Ï€) :=\n    (OrderIso.funUnique (Fin 1) â„).symm.preimage_Icc _ _\n  have Hâ‚‚ : torusMap c R = fun Î¸ _ â†¦ circleMap (c 0) (R 0) (Î¸ 0) := by\n    ext Î¸ i : 2\n    rw [Subsingleton.elim i 0]; rfl\n  rw [torusIntegral, circleIntegral, intervalIntegral.integral_of_le Real.two_pi_pos.le,\n    Measure.restrict_congr_set Ioc_ae_eq_Icc,\n    â† ((volume_preserving_funUnique (Fin 1) â„).symm _).setIntegral_preimage_emb\n      (MeasurableEquiv.measurableEmbedding _), Hâ‚, Hâ‚‚]\n  simp [circleMap_zero]\n\n"}
{"name":"torusIntegral_succAbove","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : (Fin (HAdd.hAdd n 1) â†’ Complex) â†’ E\nc : Fin (HAdd.hAdd n 1) â†’ Complex\nR : Fin (HAdd.hAdd n 1) â†’ Real\nhf : TorusIntegrable f c R\ni : Fin (HAdd.hAdd n 1)\nâŠ¢ Eq (torusIntegral (fun x => f x) c R) (circleIntegral (fun x => torusIntegral (fun y => f (i.insertNth x y)) (Function.comp c i.succAbove) (Function.comp R i.succAbove)) (c i) (R i))","decl":"/-- Recurrent formula for `torusIntegral`, see also `torusIntegral_succ`. -/\ntheorem torusIntegral_succAbove\n    {f : â„‚â¿âºÂ¹ â†’ E} {c : â„‚â¿âºÂ¹} {R : â„â¿âºÂ¹} (hf : TorusIntegrable f c R)\n    (i : Fin (n + 1)) :\n    (âˆ¯ x in T(c, R), f x) =\n      âˆ® x in C(c i, R i), âˆ¯ y in T(c âˆ˜ i.succAbove, R âˆ˜ i.succAbove), f (i.insertNth x y) := by\n  set e : â„ Ã— â„â¿ â‰ƒáµ â„â¿âºÂ¹ := (MeasurableEquiv.piFinSuccAbove (fun _ => â„) i).symm\n  have hem : MeasurePreserving e :=\n    (volume_preserving_piFinSuccAbove (fun _ : Fin (n + 1) => â„) i).symm _\n  have heÏ€ : (e â»Â¹' Icc 0 fun _ => 2 * Ï€) = Icc 0 (2 * Ï€) Ã—Ë¢ Icc (0 : â„â¿) fun _ => 2 * Ï€ :=\n    ((Fin.insertNthOrderIso (fun _ => â„) i).preimage_Icc _ _).trans (Icc_prod_eq _ _)\n  rw [torusIntegral, â† hem.map_eq, setIntegral_map_equiv, heÏ€, Measure.volume_eq_prod,\n    setIntegral_prod, circleIntegral_def_Icc]\n  Â· refine setIntegral_congr_fun measurableSet_Icc fun Î¸ _ => ?_\n    simp (config := { unfoldPartialApp := true }) only [e, torusIntegral, â† integral_smul,\n      deriv_circleMap, i.prod_univ_succAbove _, smul_smul, torusMap, circleMap_zero]\n    refine setIntegral_congr_fun measurableSet_Icc fun Î˜ _ => ?_\n    simp only [MeasurableEquiv.piFinSuccAbove_symm_apply, i.insertNth_apply_same,\n      i.insertNth_apply_succAbove, (Â· âˆ˜ Â·), Fin.insertNthEquiv, Equiv.coe_fn_mk]\n    congr 2\n    simp only [funext_iff, i.forall_iff_succAbove, circleMap, Fin.insertNth_apply_same,\n      eq_self_iff_true, Fin.insertNth_apply_succAbove, imp_true_iff, and_self_iff]\n  Â· have := hf.function_integrable\n    rwa [â† hem.integrableOn_comp_preimage e.measurableEmbedding, heÏ€] at this\n\n"}
{"name":"torusIntegral_succ","module":"Mathlib.MeasureTheory.Integral.TorusIntegral","initialProofState":"n : Nat\nE : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : (Fin (HAdd.hAdd n 1) â†’ Complex) â†’ E\nc : Fin (HAdd.hAdd n 1) â†’ Complex\nR : Fin (HAdd.hAdd n 1) â†’ Real\nhf : TorusIntegrable f c R\nâŠ¢ Eq (torusIntegral (fun x => f x) c R) (circleIntegral (fun x => torusIntegral (fun y => f (Fin.cons x y)) (Function.comp c Fin.succ) (Function.comp R Fin.succ)) (c 0) (R 0))","decl":"/-- Recurrent formula for `torusIntegral`, see also `torusIntegral_succAbove`. -/\ntheorem torusIntegral_succ\n    {f : â„‚â¿âºÂ¹ â†’ E} {c : â„‚â¿âºÂ¹} {R : â„â¿âºÂ¹} (hf : TorusIntegrable f c R) :\n    (âˆ¯ x in T(c, R), f x) =\n      âˆ® x in C(c 0, R 0), âˆ¯ y in T(c âˆ˜ Fin.succ, R âˆ˜ Fin.succ), f (Fin.cons x y) := by\n  simpa using torusIntegral_succAbove hf 0\n"}
