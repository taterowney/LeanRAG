{"name":"AddGrp.mk.sizeOf_spec","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"carrier : Type u\nstr : AddGroup carrier\n‚ä¢ Eq (SizeOf.sizeOf (AddGrp.mk carrier)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf carrier)) (SizeOf.sizeOf str))","decl":"/-- The category of additive groups and group morphisms. -/\nstructure AddGrp : Type (u + 1) where\n  /-- The underlying type. -/\n  (carrier : Type u)\n  [str : AddGroup carrier]\n\n"}
{"name":"AddGrp.mk.inj","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"carrier‚úù : Type u\nstr‚úù : AddGroup carrier‚úù\ncarrier : Type u\nstr : AddGroup carrier\nx‚úù : Eq (AddGrp.mk carrier‚úù) (AddGrp.mk carrier)\n‚ä¢ And (Eq carrier‚úù carrier) (HEq str‚úù str)","decl":"/-- The category of additive groups and group morphisms. -/\nstructure AddGrp : Type (u + 1) where\n  /-- The underlying type. -/\n  (carrier : Type u)\n  [str : AddGroup carrier]\n\n"}
{"name":"AddGrp.mk.injEq","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"carrier‚úù : Type u\nstr‚úù : AddGroup carrier‚úù\ncarrier : Type u\nstr : AddGroup carrier\n‚ä¢ Eq (Eq (AddGrp.mk carrier‚úù) (AddGrp.mk carrier)) (And (Eq carrier‚úù carrier) (HEq str‚úù str))","decl":"/-- The category of additive groups and group morphisms. -/\nstructure AddGrp : Type (u + 1) where\n  /-- The underlying type. -/\n  (carrier : Type u)\n  [str : AddGroup carrier]\n\n"}
{"name":"Grp.mk.injEq","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"carrier‚úù : Type u\nstr‚úù : Group carrier‚úù\ncarrier : Type u\nstr : Group carrier\n‚ä¢ Eq (Eq (Grp.mk carrier‚úù) (Grp.mk carrier)) (And (Eq carrier‚úù carrier) (HEq str‚úù str))","decl":"/-- The category of groups and group morphisms. -/\n@[to_additive]\nstructure Grp : Type (u + 1) where\n  /-- The underlying type. -/\n  (carrier : Type u)\n  [str : Group carrier]\n\n"}
{"name":"Grp.mk.inj","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"carrier‚úù : Type u\nstr‚úù : Group carrier‚úù\ncarrier : Type u\nstr : Group carrier\nx‚úù : Eq (Grp.mk carrier‚úù) (Grp.mk carrier)\n‚ä¢ And (Eq carrier‚úù carrier) (HEq str‚úù str)","decl":"/-- The category of groups and group morphisms. -/\n@[to_additive]\nstructure Grp : Type (u + 1) where\n  /-- The underlying type. -/\n  (carrier : Type u)\n  [str : Group carrier]\n\n"}
{"name":"Grp.mk.sizeOf_spec","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"carrier : Type u\nstr : Group carrier\n‚ä¢ Eq (SizeOf.sizeOf (Grp.mk carrier)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf carrier)) (SizeOf.sizeOf str))","decl":"/-- The category of groups and group morphisms. -/\n@[to_additive]\nstructure Grp : Type (u + 1) where\n  /-- The underlying type. -/\n  (carrier : Type u)\n  [str : Group carrier]\n\n"}
{"name":"AddGrp.Hom.ext","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"A B : AddGrp\nx y : A.Hom B\nhom' : Eq x.hom' y.hom'\n‚ä¢ Eq x y","decl":"/-- The type of morphisms in `AddGrp R`. -/\n@[ext]\nstructure AddGrp.Hom (A B : AddGrp.{u}) where\n  private mk ::\n  /-- The underlying monoid homomorphism. -/\n  hom' : A ‚Üí+ B\n\n"}
{"name":"AddGrp.Hom.ext_iff","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"A B : AddGrp\nx y : A.Hom B\n‚ä¢ Iff (Eq x y) (Eq x.hom' y.hom')","decl":"/-- The type of morphisms in `AddGrp R`. -/\n@[ext]\nstructure AddGrp.Hom (A B : AddGrp.{u}) where\n  private mk ::\n  /-- The underlying monoid homomorphism. -/\n  hom' : A ‚Üí+ B\n\n"}
{"name":"Grp.Hom.ext_iff","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"A B : Grp\nx y : A.Hom B\n‚ä¢ Iff (Eq x y) (Eq x.hom' y.hom')","decl":"/-- The type of morphisms in `Grp R`. -/\n@[to_additive, ext]\nstructure Grp.Hom (A B : Grp.{u}) where\n  private mk ::\n  /-- The underlying monoid homomorphism. -/\n  hom' : A ‚Üí* B\n\n"}
{"name":"Grp.Hom.ext","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"A B : Grp\nx y : A.Hom B\nhom' : Eq x.hom' y.hom'\n‚ä¢ Eq x y","decl":"/-- The type of morphisms in `Grp R`. -/\n@[to_additive, ext]\nstructure Grp.Hom (A B : Grp.{u}) where\n  private mk ::\n  /-- The underlying monoid homomorphism. -/\n  hom' : A ‚Üí* B\n\n"}
{"name":"Grp.coe_id","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : Grp\n‚ä¢ Eq (‚áë(CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.id X))) id","decl":"@[to_additive (attr := simp)]\nlemma coe_id {X : Grp} : (ùüô X : X ‚Üí X) = id := rfl\n\n"}
{"name":"AddGrp.coe_id","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : AddGrp\n‚ä¢ Eq (‚áë(CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.id X))) id","decl":"@[to_additive (attr := simp)]\nlemma coe_id {X : Grp} : (ùüô X : X ‚Üí X) = id := rfl\n\n"}
{"name":"AddGrp.coe_comp","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y Z : AddGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (‚áë(CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.comp f g))) (Function.comp ‚áë(CategoryTheory.ConcreteCategory.hom g) ‚áë(CategoryTheory.ConcreteCategory.hom f))","decl":"@[to_additive (attr := simp)]\nlemma coe_comp {X Y Z : Grp} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} : (f ‚â´ g : X ‚Üí Z) = g ‚àò f := rfl\n\n"}
{"name":"Grp.coe_comp","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y Z : Grp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (‚áë(CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.comp f g))) (Function.comp ‚áë(CategoryTheory.ConcreteCategory.hom g) ‚áë(CategoryTheory.ConcreteCategory.hom f))","decl":"@[to_additive (attr := simp)]\nlemma coe_comp {X Y Z : Grp} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} : (f ‚â´ g : X ‚Üí Z) = g ‚àò f := rfl\n\n"}
{"name":"Grp.comp_def","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y Z : Grp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (Grp.Hom.hom (CategoryTheory.CategoryStruct.comp f g)) ((Grp.Hom.hom g).comp (Grp.Hom.hom f))","decl":"@[to_additive (attr := deprecated \"Use hom_comp instead\" (since := \"2025-01-28\"))]\nlemma comp_def {X Y Z : Grp} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} : (f ‚â´ g).hom = g.hom.comp f.hom := rfl\n\n"}
{"name":"AddGrp.comp_def","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y Z : AddGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (AddGrp.Hom.hom (CategoryTheory.CategoryStruct.comp f g)) ((AddGrp.Hom.hom g).comp (AddGrp.Hom.hom f))","decl":"@[to_additive (attr := deprecated \"Use hom_comp instead\" (since := \"2025-01-28\"))]\nlemma comp_def {X Y Z : Grp} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} : (f ‚â´ g).hom = g.hom.comp f.hom := rfl\n\n"}
{"name":"Grp.forget_map","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Grp\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.forget Grp).map f) ‚áë(CategoryTheory.ConcreteCategory.hom f)","decl":"@[simp] lemma forget_map {X Y : Grp} (f : X ‚ü∂ Y) : (forget Grp).map f = (f : X ‚Üí Y) := rfl\n\n"}
{"name":"AddGrp.ext_iff","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : AddGrp\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (‚àÄ (x : ‚ÜëX), Eq ((CategoryTheory.ConcreteCategory.hom f) x) ((CategoryTheory.ConcreteCategory.hom g) x))","decl":"@[to_additive (attr := ext)]\nlemma ext {X Y : Grp} {f g : X ‚ü∂ Y} (w : ‚àÄ x : X, f x = g x) : f = g :=\n  ConcreteCategory.hom_ext _ _ w\n\n"}
{"name":"Grp.ext_iff","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Grp\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (‚àÄ (x : ‚ÜëX), Eq ((CategoryTheory.ConcreteCategory.hom f) x) ((CategoryTheory.ConcreteCategory.hom g) x))","decl":"@[to_additive (attr := ext)]\nlemma ext {X Y : Grp} {f g : X ‚ü∂ Y} (w : ‚àÄ x : X, f x = g x) : f = g :=\n  ConcreteCategory.hom_ext _ _ w\n\n"}
{"name":"AddGrp.ext","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : AddGrp\nf g : Quiver.Hom X Y\nw : ‚àÄ (x : ‚ÜëX), Eq ((CategoryTheory.ConcreteCategory.hom f) x) ((CategoryTheory.ConcreteCategory.hom g) x)\n‚ä¢ Eq f g","decl":"@[to_additive (attr := ext)]\nlemma ext {X Y : Grp} {f g : X ‚ü∂ Y} (w : ‚àÄ x : X, f x = g x) : f = g :=\n  ConcreteCategory.hom_ext _ _ w\n\n"}
{"name":"Grp.ext","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Grp\nf g : Quiver.Hom X Y\nw : ‚àÄ (x : ‚ÜëX), Eq ((CategoryTheory.ConcreteCategory.hom f) x) ((CategoryTheory.ConcreteCategory.hom g) x)\n‚ä¢ Eq f g","decl":"@[to_additive (attr := ext)]\nlemma ext {X Y : Grp} {f g : X ‚ü∂ Y} (w : ‚àÄ x : X, f x = g x) : f = g :=\n  ConcreteCategory.hom_ext _ _ w\n\n"}
{"name":"AddGrp.coe_of","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"R : Type u\ninst‚úù : AddGroup R\n‚ä¢ Eq (‚Üë(AddGrp.of R)) R","decl":"@[to_additive]\n-- This is not `simp` to avoid rewriting in types of terms.\ntheorem coe_of (R : Type u) [Group R] : ‚Üë(Grp.of R) = R :=\n  rfl\n\n"}
{"name":"Grp.coe_of","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"R : Type u\ninst‚úù : Group R\n‚ä¢ Eq (‚Üë(Grp.of R)) R","decl":"@[to_additive]\n-- This is not `simp` to avoid rewriting in types of terms.\ntheorem coe_of (R : Type u) [Group R] : ‚Üë(Grp.of R) = R :=\n  rfl\n\n"}
{"name":"AddGrp.hom_id","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : AddGrp\n‚ä¢ Eq (AddGrp.Hom.hom (CategoryTheory.CategoryStruct.id X)) (AddMonoidHom.id ‚ÜëX)","decl":"@[to_additive (attr := simp)]\nlemma hom_id {X : Grp} : (ùüô X : X ‚ü∂ X).hom = MonoidHom.id X := rfl\n\n/- Provided for rewriting. -/\n"}
{"name":"Grp.hom_id","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : Grp\n‚ä¢ Eq (Grp.Hom.hom (CategoryTheory.CategoryStruct.id X)) (MonoidHom.id ‚ÜëX)","decl":"@[to_additive (attr := simp)]\nlemma hom_id {X : Grp} : (ùüô X : X ‚ü∂ X).hom = MonoidHom.id X := rfl\n\n/- Provided for rewriting. -/\n"}
{"name":"AddGrp.id_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : AddGrp\nx : ‚ÜëX\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.id X)) x) x","decl":"@[to_additive]\nlemma id_apply (X : Grp) (x : X) :\n    (ùüô X : X ‚ü∂ X) x = x := by simp\n\n"}
{"name":"Grp.id_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : Grp\nx : ‚ÜëX\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.id X)) x) x","decl":"@[to_additive]\nlemma id_apply (X : Grp) (x : X) :\n    (ùüô X : X ‚ü∂ X) x = x := by simp\n\n"}
{"name":"Grp.hom_comp","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y T : Grp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y T\n‚ä¢ Eq (Grp.Hom.hom (CategoryTheory.CategoryStruct.comp f g)) ((Grp.Hom.hom g).comp (Grp.Hom.hom f))","decl":"@[to_additive (attr := simp)]\nlemma hom_comp {X Y T : Grp} (f : X ‚ü∂ Y) (g : Y ‚ü∂ T) :\n    (f ‚â´ g).hom = g.hom.comp f.hom := rfl\n\n/- Provided for rewriting. -/\n"}
{"name":"AddGrp.hom_comp","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y T : AddGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y T\n‚ä¢ Eq (AddGrp.Hom.hom (CategoryTheory.CategoryStruct.comp f g)) ((AddGrp.Hom.hom g).comp (AddGrp.Hom.hom f))","decl":"@[to_additive (attr := simp)]\nlemma hom_comp {X Y T : Grp} (f : X ‚ü∂ Y) (g : Y ‚ü∂ T) :\n    (f ‚â´ g).hom = g.hom.comp f.hom := rfl\n\n/- Provided for rewriting. -/\n"}
{"name":"AddGrp.comp_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y T : AddGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y T\nx : ‚ÜëX\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.comp f g)) x) ((CategoryTheory.ConcreteCategory.hom g) ((CategoryTheory.ConcreteCategory.hom f) x))","decl":"@[to_additive]\nlemma comp_apply {X Y T : Grp} (f : X ‚ü∂ Y) (g : Y ‚ü∂ T) (x : X) :\n    (f ‚â´ g) x = g (f x) := by simp\n\n"}
{"name":"Grp.comp_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y T : Grp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y T\nx : ‚ÜëX\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.comp f g)) x) ((CategoryTheory.ConcreteCategory.hom g) ((CategoryTheory.ConcreteCategory.hom f) x))","decl":"@[to_additive]\nlemma comp_apply {X Y T : Grp} (f : X ‚ü∂ Y) (g : Y ‚ü∂ T) (x : X) :\n    (f ‚â´ g) x = g (f x) := by simp\n\n"}
{"name":"Grp.hom_ext","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Grp\nf g : Quiver.Hom X Y\nhf : Eq (Grp.Hom.hom f) (Grp.Hom.hom g)\n‚ä¢ Eq f g","decl":"@[to_additive (attr := ext)]\nlemma hom_ext {X Y : Grp} {f g : X ‚ü∂ Y} (hf : f.hom = g.hom) : f = g :=\n  Hom.ext hf\n\n"}
{"name":"Grp.hom_ext_iff","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Grp\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (Eq (Grp.Hom.hom f) (Grp.Hom.hom g))","decl":"@[to_additive (attr := ext)]\nlemma hom_ext {X Y : Grp} {f g : X ‚ü∂ Y} (hf : f.hom = g.hom) : f = g :=\n  Hom.ext hf\n\n"}
{"name":"AddGrp.hom_ext_iff","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : AddGrp\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (Eq (AddGrp.Hom.hom f) (AddGrp.Hom.hom g))","decl":"@[to_additive (attr := ext)]\nlemma hom_ext {X Y : Grp} {f g : X ‚ü∂ Y} (hf : f.hom = g.hom) : f = g :=\n  Hom.ext hf\n\n"}
{"name":"AddGrp.hom_ext","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : AddGrp\nf g : Quiver.Hom X Y\nhf : Eq (AddGrp.Hom.hom f) (AddGrp.Hom.hom g)\n‚ä¢ Eq f g","decl":"@[to_additive (attr := ext)]\nlemma hom_ext {X Y : Grp} {f g : X ‚ü∂ Y} (hf : f.hom = g.hom) : f = g :=\n  Hom.ext hf\n\n"}
{"name":"AddGrp.hom_ofHom","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"R S : Type u\ninst‚úù¬π : AddGroup R\ninst‚úù : AddGroup S\nf : AddMonoidHom R S\n‚ä¢ Eq (AddGrp.Hom.hom (AddGrp.ofHom f)) f","decl":"@[to_additive (attr := simp)]\nlemma hom_ofHom {R S : Type u} [Group R] [Group S] (f : R ‚Üí* S) : (ofHom f).hom = f := rfl\n\n"}
{"name":"Grp.hom_ofHom","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"R S : Type u\ninst‚úù¬π : Group R\ninst‚úù : Group S\nf : MonoidHom R S\n‚ä¢ Eq (Grp.Hom.hom (Grp.ofHom f)) f","decl":"@[to_additive (attr := simp)]\nlemma hom_ofHom {R S : Type u} [Group R] [Group S] (f : R ‚Üí* S) : (ofHom f).hom = f := rfl\n\n"}
{"name":"Grp.ofHom_hom","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Grp\nf : Quiver.Hom X Y\n‚ä¢ Eq (Grp.ofHom (Grp.Hom.hom f)) f","decl":"@[to_additive (attr := simp)]\nlemma ofHom_hom {X Y : Grp} (f : X ‚ü∂ Y) :\n    ofHom (Hom.hom f) = f := rfl\n\n"}
{"name":"AddGrp.ofHom_hom","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : AddGrp\nf : Quiver.Hom X Y\n‚ä¢ Eq (AddGrp.ofHom (AddGrp.Hom.hom f)) f","decl":"@[to_additive (attr := simp)]\nlemma ofHom_hom {X Y : Grp} (f : X ‚ü∂ Y) :\n    ofHom (Hom.hom f) = f := rfl\n\n"}
{"name":"Grp.ofHom_id","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : Type u\ninst‚úù : Group X\n‚ä¢ Eq (Grp.ofHom (MonoidHom.id X)) (CategoryTheory.CategoryStruct.id (Grp.of X))","decl":"@[to_additive (attr := simp)]\nlemma ofHom_id {X : Type u} [Group X] : ofHom (MonoidHom.id X) = ùüô (of X) := rfl\n\n"}
{"name":"AddGrp.ofHom_id","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : Type u\ninst‚úù : AddGroup X\n‚ä¢ Eq (AddGrp.ofHom (AddMonoidHom.id X)) (CategoryTheory.CategoryStruct.id (AddGrp.of X))","decl":"@[to_additive (attr := simp)]\nlemma ofHom_id {X : Type u} [Group X] : ofHom (MonoidHom.id X) = ùüô (of X) := rfl\n\n"}
{"name":"Grp.ofHom_comp","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y Z : Type u\ninst‚úù¬≤ : Group X\ninst‚úù¬π : Group Y\ninst‚úù : Group Z\nf : MonoidHom X Y\ng : MonoidHom Y Z\n‚ä¢ Eq (Grp.ofHom (g.comp f)) (CategoryTheory.CategoryStruct.comp (Grp.ofHom f) (Grp.ofHom g))","decl":"@[to_additive (attr := simp)]\nlemma ofHom_comp {X Y Z : Type u} [Group X] [Group Y] [Group Z]\n    (f : X ‚Üí* Y) (g : Y ‚Üí* Z) :\n    ofHom (g.comp f) = ofHom f ‚â´ ofHom g :=\n  rfl\n\n"}
{"name":"AddGrp.ofHom_comp","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y Z : Type u\ninst‚úù¬≤ : AddGroup X\ninst‚úù¬π : AddGroup Y\ninst‚úù : AddGroup Z\nf : AddMonoidHom X Y\ng : AddMonoidHom Y Z\n‚ä¢ Eq (AddGrp.ofHom (g.comp f)) (CategoryTheory.CategoryStruct.comp (AddGrp.ofHom f) (AddGrp.ofHom g))","decl":"@[to_additive (attr := simp)]\nlemma ofHom_comp {X Y Z : Type u} [Group X] [Group Y] [Group Z]\n    (f : X ‚Üí* Y) (g : Y ‚Üí* Z) :\n    ofHom (g.comp f) = ofHom f ‚â´ ofHom g :=\n  rfl\n\n"}
{"name":"Grp.ofHom_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Type u\ninst‚úù¬π : Group X\ninst‚úù : Group Y\nf : MonoidHom X Y\nx : X\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (Grp.ofHom f)) x) (f x)","decl":"@[to_additive]\nlemma ofHom_apply {X Y : Type u} [Group X] [Group Y] (f : X ‚Üí* Y) (x : X) :\n    (ofHom f) x = f x := rfl\n\n"}
{"name":"AddGrp.ofHom_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Type u\ninst‚úù¬π : AddGroup X\ninst‚úù : AddGroup Y\nf : AddMonoidHom X Y\nx : X\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (AddGrp.ofHom f)) x) (f x)","decl":"@[to_additive]\nlemma ofHom_apply {X Y : Type u} [Group X] [Group Y] (f : X ‚Üí* Y) (x : X) :\n    (ofHom f) x = f x := rfl\n\n"}
{"name":"Grp.inv_hom_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Grp\ne : CategoryTheory.Iso X Y\nx : ‚ÜëX\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom e.inv) ((CategoryTheory.ConcreteCategory.hom e.hom) x)) x","decl":"@[to_additive (attr := simp)]\nlemma inv_hom_apply {X Y : Grp} (e : X ‚âÖ Y) (x : X) : e.inv (e.hom x) = x := by\n  rw [‚Üê comp_apply]\n  simp\n\n"}
{"name":"AddGrp.neg_hom_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : AddGrp\ne : CategoryTheory.Iso X Y\nx : ‚ÜëX\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom e.inv) ((CategoryTheory.ConcreteCategory.hom e.hom) x)) x","decl":"@[to_additive (attr := simp)]\nlemma inv_hom_apply {X Y : Grp} (e : X ‚âÖ Y) (x : X) : e.inv (e.hom x) = x := by\n  rw [‚Üê comp_apply]\n  simp\n\n"}
{"name":"AddGrp.hom_neg_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : AddGrp\ne : CategoryTheory.Iso X Y\ns : ‚ÜëY\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom e.hom) ((CategoryTheory.ConcreteCategory.hom e.inv) s)) s","decl":"@[to_additive (attr := simp)]\nlemma hom_inv_apply {X Y : Grp} (e : X ‚âÖ Y) (s : Y) : e.hom (e.inv s) = s := by\n  rw [‚Üê comp_apply]\n  simp\n\n"}
{"name":"Grp.hom_inv_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Grp\ne : CategoryTheory.Iso X Y\ns : ‚ÜëY\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom e.hom) ((CategoryTheory.ConcreteCategory.hom e.inv) s)) s","decl":"@[to_additive (attr := simp)]\nlemma hom_inv_apply {X Y : Grp} (e : X ‚âÖ Y) (s : Y) : e.hom (e.inv s) = s := by\n  rw [‚Üê comp_apply]\n  simp\n\n"}
{"name":"AddGrp.coe_comp'","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y Z : AddGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (‚áë(CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.comp f g))) (Function.comp ‚áë(CategoryTheory.ConcreteCategory.hom g) ‚áë(CategoryTheory.ConcreteCategory.hom f))","decl":"@[to_additive (attr := deprecated \"use `coe_comp` instead\" (since := \"2025-01-28\"))]\nalias coe_comp' := coe_comp\n\n"}
{"name":"Grp.coe_comp'","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y Z : Grp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (‚áë(CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.comp f g))) (Function.comp ‚áë(CategoryTheory.ConcreteCategory.hom g) ‚áë(CategoryTheory.ConcreteCategory.hom f))","decl":"@[to_additive (attr := deprecated \"use `coe_comp` instead\" (since := \"2025-01-28\"))]\nalias coe_comp' := coe_comp\n\n"}
{"name":"Grp.coe_id'","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : Grp\n‚ä¢ Eq (‚áë(CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.id X))) id","decl":"@[to_additive (attr := deprecated \"use `coe_id` instead\" (since := \"2025-01-28\"))]\nalias coe_id' := coe_id\n\n"}
{"name":"AddGrp.coe_id'","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : AddGrp\n‚ä¢ Eq (‚áë(CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.id X))) id","decl":"@[to_additive (attr := deprecated \"use `coe_id` instead\" (since := \"2025-01-28\"))]\nalias coe_id' := coe_id\n\n"}
{"name":"Grp.forget‚ÇÇ_map_ofHom","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Type u\ninst‚úù¬π : Group X\ninst‚úù : Group Y\nf : MonoidHom X Y\n‚ä¢ Eq ((CategoryTheory.forget‚ÇÇ Grp MonCat).map (Grp.ofHom f)) (MonCat.ofHom f)","decl":"@[to_additive (attr := simp)] lemma forget‚ÇÇ_map_ofHom {X Y : Type u} [Group X] [Group Y]\n    (f : X ‚Üí* Y) :\n    (forget‚ÇÇ Grp MonCat).map (ofHom f) = MonCat.ofHom f := rfl\n\n"}
{"name":"AddGrp.forget‚ÇÇ_map_ofHom","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Type u\ninst‚úù¬π : AddGroup X\ninst‚úù : AddGroup Y\nf : AddMonoidHom X Y\n‚ä¢ Eq ((CategoryTheory.forget‚ÇÇ AddGrp AddMonCat).map (AddGrp.ofHom f)) (AddMonCat.ofHom f)","decl":"@[to_additive (attr := simp)] lemma forget‚ÇÇ_map_ofHom {X Y : Type u} [Group X] [Group Y]\n    (f : X ‚Üí* Y) :\n    (forget‚ÇÇ Grp MonCat).map (ofHom f) = MonCat.ofHom f := rfl\n\n"}
{"name":"AddGrp.zero_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"G H : AddGrp\ng : ‚ÜëG\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom 0) g) 0","decl":"@[to_additive (attr := simp)]\ntheorem one_apply (G H : Grp) (g : G) : ((1 : G ‚ü∂ H) : G ‚Üí H) g = 1 :=\n  rfl\n\n"}
{"name":"Grp.one_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"G H : Grp\ng : ‚ÜëG\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom 1) g) 1","decl":"@[to_additive (attr := simp)]\ntheorem one_apply (G H : Grp) (g : G) : ((1 : G ‚ü∂ H) : G ‚Üí H) g = 1 :=\n  rfl\n\n"}
{"name":"AddGrp.ofHom_injective","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Type u\ninst‚úù¬π : AddGroup X\ninst‚úù : AddGroup Y\n‚ä¢ Function.Injective fun f => AddGrp.ofHom f","decl":"@[to_additive]\nlemma ofHom_injective {X Y : Type u} [Group X] [Group Y] :\n    Function.Injective (fun (f : X ‚Üí* Y) ‚Ü¶ ofHom f) := by\n  intro _ _ h\n  ext\n  apply ConcreteCategory.congr_hom h\n\n"}
{"name":"Grp.ofHom_injective","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Type u\ninst‚úù¬π : Group X\ninst‚úù : Group Y\n‚ä¢ Function.Injective fun f => Grp.ofHom f","decl":"@[to_additive]\nlemma ofHom_injective {X Y : Type u} [Group X] [Group Y] :\n    Function.Injective (fun (f : X ‚Üí* Y) ‚Ü¶ ofHom f) := by\n  intro _ _ h\n  ext\n  apply ConcreteCategory.congr_hom h\n\n"}
{"name":"Grp.uliftFunctor_map","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"x‚úù¬π x‚úù : Grp\nf : Quiver.Hom x‚úù¬π x‚úù\n‚ä¢ Eq (Grp.uliftFunctor.map f) (Grp.ofHom (MulEquiv.ulift.symm.toMonoidHom.comp ((Grp.Hom.hom f).comp MulEquiv.ulift.toMonoidHom)))","decl":"/-- Universe lift functor for groups. -/\n@[to_additive (attr := simps obj map)\n  \"Universe lift functor for additive groups.\"]\ndef uliftFunctor : Grp.{v} ‚•§ Grp.{max v u} where\n  obj X := Grp.of (ULift.{u, v} X)\n  map {_ _} f := Grp.ofHom <|\n    MulEquiv.ulift.symm.toMonoidHom.comp <| f.hom.comp MulEquiv.ulift.toMonoidHom\n  map_id X := by rfl\n  map_comp {X Y Z} f g := by rfl\n\n"}
{"name":"AddGrp.uliftFunctor_map","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"x‚úù¬π x‚úù : AddGrp\nf : Quiver.Hom x‚úù¬π x‚úù\n‚ä¢ Eq (AddGrp.uliftFunctor.map f) (AddGrp.ofHom (AddEquiv.ulift.symm.toAddMonoidHom.comp ((AddGrp.Hom.hom f).comp AddEquiv.ulift.toAddMonoidHom)))","decl":"/-- Universe lift functor for groups. -/\n@[to_additive (attr := simps obj map)\n  \"Universe lift functor for additive groups.\"]\ndef uliftFunctor : Grp.{v} ‚•§ Grp.{max v u} where\n  obj X := Grp.of (ULift.{u, v} X)\n  map {_ _} f := Grp.ofHom <|\n    MulEquiv.ulift.symm.toMonoidHom.comp <| f.hom.comp MulEquiv.ulift.toMonoidHom\n  map_id X := by rfl\n  map_comp {X Y Z} f g := by rfl\n\n"}
{"name":"AddGrp.uliftFunctor_obj","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : AddGrp\n‚ä¢ Eq (AddGrp.uliftFunctor.obj X) (AddGrp.of (ULift.{u, v} ‚ÜëX))","decl":"/-- Universe lift functor for groups. -/\n@[to_additive (attr := simps obj map)\n  \"Universe lift functor for additive groups.\"]\ndef uliftFunctor : Grp.{v} ‚•§ Grp.{max v u} where\n  obj X := Grp.of (ULift.{u, v} X)\n  map {_ _} f := Grp.ofHom <|\n    MulEquiv.ulift.symm.toMonoidHom.comp <| f.hom.comp MulEquiv.ulift.toMonoidHom\n  map_id X := by rfl\n  map_comp {X Y Z} f g := by rfl\n\n"}
{"name":"Grp.uliftFunctor_obj","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : Grp\n‚ä¢ Eq (Grp.uliftFunctor.obj X) (Grp.of (ULift.{u, v} ‚ÜëX))","decl":"/-- Universe lift functor for groups. -/\n@[to_additive (attr := simps obj map)\n  \"Universe lift functor for additive groups.\"]\ndef uliftFunctor : Grp.{v} ‚•§ Grp.{max v u} where\n  obj X := Grp.of (ULift.{u, v} X)\n  map {_ _} f := Grp.ofHom <|\n    MulEquiv.ulift.symm.toMonoidHom.comp <| f.hom.comp MulEquiv.ulift.toMonoidHom\n  map_id X := by rfl\n  map_comp {X Y Z} f g := by rfl\n\n"}
{"name":"AddCommGrp.mk.inj","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"carrier‚úù : Type u\nstr‚úù : AddCommGroup carrier‚úù\ncarrier : Type u\nstr : AddCommGroup carrier\nx‚úù : Eq (AddCommGrp.mk carrier‚úù) (AddCommGrp.mk carrier)\n‚ä¢ And (Eq carrier‚úù carrier) (HEq str‚úù str)","decl":"/-- The category of additive groups and group morphisms. -/\nstructure AddCommGrp : Type (u + 1) where\n  /-- The underlying type. -/\n  (carrier : Type u)\n  [str : AddCommGroup carrier]\n\n"}
{"name":"AddCommGrp.mk.sizeOf_spec","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"carrier : Type u\nstr : AddCommGroup carrier\n‚ä¢ Eq (SizeOf.sizeOf (AddCommGrp.mk carrier)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf carrier)) (SizeOf.sizeOf str))","decl":"/-- The category of additive groups and group morphisms. -/\nstructure AddCommGrp : Type (u + 1) where\n  /-- The underlying type. -/\n  (carrier : Type u)\n  [str : AddCommGroup carrier]\n\n"}
{"name":"AddCommGrp.mk.injEq","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"carrier‚úù : Type u\nstr‚úù : AddCommGroup carrier‚úù\ncarrier : Type u\nstr : AddCommGroup carrier\n‚ä¢ Eq (Eq (AddCommGrp.mk carrier‚úù) (AddCommGrp.mk carrier)) (And (Eq carrier‚úù carrier) (HEq str‚úù str))","decl":"/-- The category of additive groups and group morphisms. -/\nstructure AddCommGrp : Type (u + 1) where\n  /-- The underlying type. -/\n  (carrier : Type u)\n  [str : AddCommGroup carrier]\n\n"}
{"name":"CommGrp.mk.inj","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"carrier‚úù : Type u\nstr‚úù : CommGroup carrier‚úù\ncarrier : Type u\nstr : CommGroup carrier\nx‚úù : Eq (CommGrp.mk carrier‚úù) (CommGrp.mk carrier)\n‚ä¢ And (Eq carrier‚úù carrier) (HEq str‚úù str)","decl":"/-- The category of groups and group morphisms. -/\n@[to_additive]\nstructure CommGrp : Type (u + 1) where\n  /-- The underlying type. -/\n  (carrier : Type u)\n  [str : CommGroup carrier]\n\n"}
{"name":"CommGrp.mk.injEq","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"carrier‚úù : Type u\nstr‚úù : CommGroup carrier‚úù\ncarrier : Type u\nstr : CommGroup carrier\n‚ä¢ Eq (Eq (CommGrp.mk carrier‚úù) (CommGrp.mk carrier)) (And (Eq carrier‚úù carrier) (HEq str‚úù str))","decl":"/-- The category of groups and group morphisms. -/\n@[to_additive]\nstructure CommGrp : Type (u + 1) where\n  /-- The underlying type. -/\n  (carrier : Type u)\n  [str : CommGroup carrier]\n\n"}
{"name":"CommGrp.mk.sizeOf_spec","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"carrier : Type u\nstr : CommGroup carrier\n‚ä¢ Eq (SizeOf.sizeOf (CommGrp.mk carrier)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf carrier)) (SizeOf.sizeOf str))","decl":"/-- The category of groups and group morphisms. -/\n@[to_additive]\nstructure CommGrp : Type (u + 1) where\n  /-- The underlying type. -/\n  (carrier : Type u)\n  [str : CommGroup carrier]\n\n"}
{"name":"AddCommGrp.Hom.ext_iff","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"A B : AddCommGrp\nx y : A.Hom B\n‚ä¢ Iff (Eq x y) (Eq x.hom' y.hom')","decl":"/-- The type of morphisms in `AddCommGrp R`. -/\n@[ext]\nstructure AddCommGrp.Hom (A B : AddCommGrp.{u}) where\n  private mk ::\n  /-- The underlying monoid homomorphism. -/\n  hom' : A ‚Üí+ B\n\n"}
{"name":"AddCommGrp.Hom.ext","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"A B : AddCommGrp\nx y : A.Hom B\nhom' : Eq x.hom' y.hom'\n‚ä¢ Eq x y","decl":"/-- The type of morphisms in `AddCommGrp R`. -/\n@[ext]\nstructure AddCommGrp.Hom (A B : AddCommGrp.{u}) where\n  private mk ::\n  /-- The underlying monoid homomorphism. -/\n  hom' : A ‚Üí+ B\n\n"}
{"name":"CommGrp.Hom.ext_iff","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"A B : CommGrp\nx y : A.Hom B\n‚ä¢ Iff (Eq x y) (Eq x.hom' y.hom')","decl":"/-- The type of morphisms in `CommGrp R`. -/\n@[to_additive, ext]\nstructure CommGrp.Hom (A B : CommGrp.{u}) where\n  private mk ::\n  /-- The underlying monoid homomorphism. -/\n  hom' : A ‚Üí* B\n\n"}
{"name":"CommGrp.Hom.ext","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"A B : CommGrp\nx y : A.Hom B\nhom' : Eq x.hom' y.hom'\n‚ä¢ Eq x y","decl":"/-- The type of morphisms in `CommGrp R`. -/\n@[to_additive, ext]\nstructure CommGrp.Hom (A B : CommGrp.{u}) where\n  private mk ::\n  /-- The underlying monoid homomorphism. -/\n  hom' : A ‚Üí* B\n\n"}
{"name":"CommGrp.coe_id","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : CommGrp\n‚ä¢ Eq (‚áë(CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.id X))) id","decl":"@[to_additive (attr := simp)]\nlemma coe_id {X : CommGrp} : (ùüô X : X ‚Üí X) = id := rfl\n\n"}
{"name":"AddCommGrp.coe_id","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : AddCommGrp\n‚ä¢ Eq (‚áë(CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.id X))) id","decl":"@[to_additive (attr := simp)]\nlemma coe_id {X : CommGrp} : (ùüô X : X ‚Üí X) = id := rfl\n\n"}
{"name":"AddCommGrp.coe_comp","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y Z : AddCommGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (‚áë(CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.comp f g))) (Function.comp ‚áë(CategoryTheory.ConcreteCategory.hom g) ‚áë(CategoryTheory.ConcreteCategory.hom f))","decl":"@[to_additive (attr := simp)]\nlemma coe_comp {X Y Z : CommGrp} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} : (f ‚â´ g : X ‚Üí Z) = g ‚àò f := rfl\n\n"}
{"name":"CommGrp.coe_comp","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y Z : CommGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (‚áë(CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.comp f g))) (Function.comp ‚áë(CategoryTheory.ConcreteCategory.hom g) ‚áë(CategoryTheory.ConcreteCategory.hom f))","decl":"@[to_additive (attr := simp)]\nlemma coe_comp {X Y Z : CommGrp} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} : (f ‚â´ g : X ‚Üí Z) = g ‚àò f := rfl\n\n"}
{"name":"CommGrp.comp_def","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y Z : CommGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CommGrp.Hom.hom (CategoryTheory.CategoryStruct.comp f g)) ((CommGrp.Hom.hom g).comp (CommGrp.Hom.hom f))","decl":"@[to_additive (attr := deprecated \"Use hom_comp instead\" (since := \"2025-01-28\"))]\nlemma comp_def {X Y Z : CommGrp} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} : (f ‚â´ g).hom = g.hom.comp f.hom := rfl\n\n"}
{"name":"AddCommGrp.comp_def","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y Z : AddCommGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (AddCommGrp.Hom.hom (CategoryTheory.CategoryStruct.comp f g)) ((AddCommGrp.Hom.hom g).comp (AddCommGrp.Hom.hom f))","decl":"@[to_additive (attr := deprecated \"Use hom_comp instead\" (since := \"2025-01-28\"))]\nlemma comp_def {X Y Z : CommGrp} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} : (f ‚â´ g).hom = g.hom.comp f.hom := rfl\n\n"}
{"name":"AddCommGrp.forget_map","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : AddCommGrp\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.forget AddCommGrp).map f) ‚áë(CategoryTheory.ConcreteCategory.hom f)","decl":"@[to_additive (attr := simp)]\nlemma forget_map {X Y : CommGrp} (f : X ‚ü∂ Y) :\n    (forget CommGrp).map f = (f : X ‚Üí Y) :=\n  rfl\n\n"}
{"name":"CommGrp.forget_map","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : CommGrp\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.forget CommGrp).map f) ‚áë(CategoryTheory.ConcreteCategory.hom f)","decl":"@[to_additive (attr := simp)]\nlemma forget_map {X Y : CommGrp} (f : X ‚ü∂ Y) :\n    (forget CommGrp).map f = (f : X ‚Üí Y) :=\n  rfl\n\n"}
{"name":"CommGrp.ext","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : CommGrp\nf g : Quiver.Hom X Y\nw : ‚àÄ (x : ‚ÜëX), Eq ((CategoryTheory.ConcreteCategory.hom f) x) ((CategoryTheory.ConcreteCategory.hom g) x)\n‚ä¢ Eq f g","decl":"@[to_additive (attr := ext)]\nlemma ext {X Y : CommGrp} {f g : X ‚ü∂ Y} (w : ‚àÄ x : X, f x = g x) : f = g :=\n  ConcreteCategory.hom_ext _ _ w\n\n"}
{"name":"CommGrp.ext_iff","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : CommGrp\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (‚àÄ (x : ‚ÜëX), Eq ((CategoryTheory.ConcreteCategory.hom f) x) ((CategoryTheory.ConcreteCategory.hom g) x))","decl":"@[to_additive (attr := ext)]\nlemma ext {X Y : CommGrp} {f g : X ‚ü∂ Y} (w : ‚àÄ x : X, f x = g x) : f = g :=\n  ConcreteCategory.hom_ext _ _ w\n\n"}
{"name":"AddCommGrp.ext","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : AddCommGrp\nf g : Quiver.Hom X Y\nw : ‚àÄ (x : ‚ÜëX), Eq ((CategoryTheory.ConcreteCategory.hom f) x) ((CategoryTheory.ConcreteCategory.hom g) x)\n‚ä¢ Eq f g","decl":"@[to_additive (attr := ext)]\nlemma ext {X Y : CommGrp} {f g : X ‚ü∂ Y} (w : ‚àÄ x : X, f x = g x) : f = g :=\n  ConcreteCategory.hom_ext _ _ w\n\n"}
{"name":"AddCommGrp.ext_iff","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : AddCommGrp\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (‚àÄ (x : ‚ÜëX), Eq ((CategoryTheory.ConcreteCategory.hom f) x) ((CategoryTheory.ConcreteCategory.hom g) x))","decl":"@[to_additive (attr := ext)]\nlemma ext {X Y : CommGrp} {f g : X ‚ü∂ Y} (w : ‚àÄ x : X, f x = g x) : f = g :=\n  ConcreteCategory.hom_ext _ _ w\n\n"}
{"name":"AddCommGrp.coe_of","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"R : Type u\ninst‚úù : AddCommGroup R\n‚ä¢ Eq (‚Üë(AddCommGrp.of R)) R","decl":"@[to_additive]\n-- This is not `simp` to avoid rewriting in types of terms.\ntheorem coe_of (R : Type u) [CommGroup R] : ‚Üë(CommGrp.of R) = R :=\n  rfl\n\n"}
{"name":"CommGrp.coe_of","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"R : Type u\ninst‚úù : CommGroup R\n‚ä¢ Eq (‚Üë(CommGrp.of R)) R","decl":"@[to_additive]\n-- This is not `simp` to avoid rewriting in types of terms.\ntheorem coe_of (R : Type u) [CommGroup R] : ‚Üë(CommGrp.of R) = R :=\n  rfl\n\n"}
{"name":"AddCommGrp.hom_id","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : AddCommGrp\n‚ä¢ Eq (AddCommGrp.Hom.hom (CategoryTheory.CategoryStruct.id X)) (AddMonoidHom.id ‚ÜëX)","decl":"@[to_additive (attr := simp)]\nlemma hom_id {X : CommGrp} : (ùüô X : X ‚ü∂ X).hom = MonoidHom.id X := rfl\n\n/- Provided for rewriting. -/\n"}
{"name":"CommGrp.hom_id","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : CommGrp\n‚ä¢ Eq (CommGrp.Hom.hom (CategoryTheory.CategoryStruct.id X)) (MonoidHom.id ‚ÜëX)","decl":"@[to_additive (attr := simp)]\nlemma hom_id {X : CommGrp} : (ùüô X : X ‚ü∂ X).hom = MonoidHom.id X := rfl\n\n/- Provided for rewriting. -/\n"}
{"name":"AddCommGrp.id_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : AddCommGrp\nx : ‚ÜëX\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.id X)) x) x","decl":"@[to_additive]\nlemma id_apply (X : CommGrp) (x : X) :\n    (ùüô X : X ‚ü∂ X) x = x := by simp\n\n"}
{"name":"CommGrp.id_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : CommGrp\nx : ‚ÜëX\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.id X)) x) x","decl":"@[to_additive]\nlemma id_apply (X : CommGrp) (x : X) :\n    (ùüô X : X ‚ü∂ X) x = x := by simp\n\n"}
{"name":"AddCommGrp.hom_comp","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y T : AddCommGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y T\n‚ä¢ Eq (AddCommGrp.Hom.hom (CategoryTheory.CategoryStruct.comp f g)) ((AddCommGrp.Hom.hom g).comp (AddCommGrp.Hom.hom f))","decl":"@[to_additive (attr := simp)]\nlemma hom_comp {X Y T : CommGrp} (f : X ‚ü∂ Y) (g : Y ‚ü∂ T) :\n    (f ‚â´ g).hom = g.hom.comp f.hom := rfl\n\n/- Provided for rewriting. -/\n"}
{"name":"CommGrp.hom_comp","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y T : CommGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y T\n‚ä¢ Eq (CommGrp.Hom.hom (CategoryTheory.CategoryStruct.comp f g)) ((CommGrp.Hom.hom g).comp (CommGrp.Hom.hom f))","decl":"@[to_additive (attr := simp)]\nlemma hom_comp {X Y T : CommGrp} (f : X ‚ü∂ Y) (g : Y ‚ü∂ T) :\n    (f ‚â´ g).hom = g.hom.comp f.hom := rfl\n\n/- Provided for rewriting. -/\n"}
{"name":"AddCommGrp.comp_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y T : AddCommGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y T\nx : ‚ÜëX\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.comp f g)) x) ((CategoryTheory.ConcreteCategory.hom g) ((CategoryTheory.ConcreteCategory.hom f) x))","decl":"@[to_additive]\nlemma comp_apply {X Y T : CommGrp} (f : X ‚ü∂ Y) (g : Y ‚ü∂ T) (x : X) :\n    (f ‚â´ g) x = g (f x) := by simp\n\n"}
{"name":"CommGrp.comp_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y T : CommGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y T\nx : ‚ÜëX\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.comp f g)) x) ((CategoryTheory.ConcreteCategory.hom g) ((CategoryTheory.ConcreteCategory.hom f) x))","decl":"@[to_additive]\nlemma comp_apply {X Y T : CommGrp} (f : X ‚ü∂ Y) (g : Y ‚ü∂ T) (x : X) :\n    (f ‚â´ g) x = g (f x) := by simp\n\n"}
{"name":"CommGrp.hom_ext_iff","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : CommGrp\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (Eq (CommGrp.Hom.hom f) (CommGrp.Hom.hom g))","decl":"@[to_additive (attr := ext)]\nlemma hom_ext {X Y : CommGrp} {f g : X ‚ü∂ Y} (hf : f.hom = g.hom) : f = g :=\n  Hom.ext hf\n\n"}
{"name":"AddCommGrp.hom_ext_iff","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : AddCommGrp\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (Eq (AddCommGrp.Hom.hom f) (AddCommGrp.Hom.hom g))","decl":"@[to_additive (attr := ext)]\nlemma hom_ext {X Y : CommGrp} {f g : X ‚ü∂ Y} (hf : f.hom = g.hom) : f = g :=\n  Hom.ext hf\n\n"}
{"name":"CommGrp.hom_ext","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : CommGrp\nf g : Quiver.Hom X Y\nhf : Eq (CommGrp.Hom.hom f) (CommGrp.Hom.hom g)\n‚ä¢ Eq f g","decl":"@[to_additive (attr := ext)]\nlemma hom_ext {X Y : CommGrp} {f g : X ‚ü∂ Y} (hf : f.hom = g.hom) : f = g :=\n  Hom.ext hf\n\n"}
{"name":"AddCommGrp.hom_ext","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : AddCommGrp\nf g : Quiver.Hom X Y\nhf : Eq (AddCommGrp.Hom.hom f) (AddCommGrp.Hom.hom g)\n‚ä¢ Eq f g","decl":"@[to_additive (attr := ext)]\nlemma hom_ext {X Y : CommGrp} {f g : X ‚ü∂ Y} (hf : f.hom = g.hom) : f = g :=\n  Hom.ext hf\n\n"}
{"name":"CommGrp.hom_ofHom","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Type u\ninst‚úù¬π : CommGroup X\ninst‚úù : CommGroup Y\nf : MonoidHom X Y\n‚ä¢ Eq (CommGrp.Hom.hom (CommGrp.ofHom f)) f","decl":"@[to_additive (attr := simp)]\nlemma hom_ofHom {X Y : Type u} [CommGroup X] [CommGroup Y] (f : X ‚Üí* Y) :\n  (ofHom f).hom = f := rfl\n\n"}
{"name":"AddCommGrp.hom_ofHom","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Type u\ninst‚úù¬π : AddCommGroup X\ninst‚úù : AddCommGroup Y\nf : AddMonoidHom X Y\n‚ä¢ Eq (AddCommGrp.Hom.hom (AddCommGrp.ofHom f)) f","decl":"@[to_additive (attr := simp)]\nlemma hom_ofHom {X Y : Type u} [CommGroup X] [CommGroup Y] (f : X ‚Üí* Y) :\n  (ofHom f).hom = f := rfl\n\n"}
{"name":"AddCommGrp.ofHom_hom","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : AddCommGrp\nf : Quiver.Hom X Y\n‚ä¢ Eq (AddCommGrp.ofHom (AddCommGrp.Hom.hom f)) f","decl":"@[to_additive (attr := simp)]\nlemma ofHom_hom {X Y : CommGrp} (f : X ‚ü∂ Y) :\n    ofHom (Hom.hom f) = f := rfl\n\n"}
{"name":"CommGrp.ofHom_hom","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : CommGrp\nf : Quiver.Hom X Y\n‚ä¢ Eq (CommGrp.ofHom (CommGrp.Hom.hom f)) f","decl":"@[to_additive (attr := simp)]\nlemma ofHom_hom {X Y : CommGrp} (f : X ‚ü∂ Y) :\n    ofHom (Hom.hom f) = f := rfl\n\n"}
{"name":"CommGrp.ofHom_id","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : Type u\ninst‚úù : CommGroup X\n‚ä¢ Eq (CommGrp.ofHom (MonoidHom.id X)) (CategoryTheory.CategoryStruct.id (CommGrp.of X))","decl":"@[to_additive (attr := simp)]\nlemma ofHom_id {X : Type u} [CommGroup X] : ofHom (MonoidHom.id X) = ùüô (of X) := rfl\n\n"}
{"name":"AddCommGrp.ofHom_id","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : Type u\ninst‚úù : AddCommGroup X\n‚ä¢ Eq (AddCommGrp.ofHom (AddMonoidHom.id X)) (CategoryTheory.CategoryStruct.id (AddCommGrp.of X))","decl":"@[to_additive (attr := simp)]\nlemma ofHom_id {X : Type u} [CommGroup X] : ofHom (MonoidHom.id X) = ùüô (of X) := rfl\n\n"}
{"name":"CommGrp.ofHom_comp","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y Z : Type u\ninst‚úù¬≤ : CommGroup X\ninst‚úù¬π : CommGroup Y\ninst‚úù : CommGroup Z\nf : MonoidHom X Y\ng : MonoidHom Y Z\n‚ä¢ Eq (CommGrp.ofHom (g.comp f)) (CategoryTheory.CategoryStruct.comp (CommGrp.ofHom f) (CommGrp.ofHom g))","decl":"@[to_additive (attr := simp)]\nlemma ofHom_comp {X Y Z : Type u} [CommGroup X] [CommGroup Y] [CommGroup Z]\n    (f : X ‚Üí* Y) (g : Y ‚Üí* Z) :\n    ofHom (g.comp f) = ofHom f ‚â´ ofHom g :=\n  rfl\n\n"}
{"name":"AddCommGrp.ofHom_comp","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y Z : Type u\ninst‚úù¬≤ : AddCommGroup X\ninst‚úù¬π : AddCommGroup Y\ninst‚úù : AddCommGroup Z\nf : AddMonoidHom X Y\ng : AddMonoidHom Y Z\n‚ä¢ Eq (AddCommGrp.ofHom (g.comp f)) (CategoryTheory.CategoryStruct.comp (AddCommGrp.ofHom f) (AddCommGrp.ofHom g))","decl":"@[to_additive (attr := simp)]\nlemma ofHom_comp {X Y Z : Type u} [CommGroup X] [CommGroup Y] [CommGroup Z]\n    (f : X ‚Üí* Y) (g : Y ‚Üí* Z) :\n    ofHom (g.comp f) = ofHom f ‚â´ ofHom g :=\n  rfl\n\n"}
{"name":"CommGrp.ofHom_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Type u\ninst‚úù¬π : CommGroup X\ninst‚úù : CommGroup Y\nf : MonoidHom X Y\nx : X\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (CommGrp.ofHom f)) x) (f x)","decl":"@[to_additive]\nlemma ofHom_apply {X Y : Type u} [CommGroup X] [CommGroup Y] (f : X ‚Üí* Y) (x : X) :\n    (ofHom f) x = f x := rfl\n\n"}
{"name":"AddCommGrp.ofHom_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Type u\ninst‚úù¬π : AddCommGroup X\ninst‚úù : AddCommGroup Y\nf : AddMonoidHom X Y\nx : X\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (AddCommGrp.ofHom f)) x) (f x)","decl":"@[to_additive]\nlemma ofHom_apply {X Y : Type u} [CommGroup X] [CommGroup Y] (f : X ‚Üí* Y) (x : X) :\n    (ofHom f) x = f x := rfl\n\n"}
{"name":"AddCommGrp.neg_hom_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : AddCommGrp\ne : CategoryTheory.Iso X Y\nx : ‚ÜëX\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom e.inv) ((CategoryTheory.ConcreteCategory.hom e.hom) x)) x","decl":"@[to_additive (attr := simp)]\nlemma inv_hom_apply {X Y : CommGrp} (e : X ‚âÖ Y) (x : X) : e.inv (e.hom x) = x := by\n  rw [‚Üê comp_apply]\n  simp\n\n"}
{"name":"CommGrp.inv_hom_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : CommGrp\ne : CategoryTheory.Iso X Y\nx : ‚ÜëX\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom e.inv) ((CategoryTheory.ConcreteCategory.hom e.hom) x)) x","decl":"@[to_additive (attr := simp)]\nlemma inv_hom_apply {X Y : CommGrp} (e : X ‚âÖ Y) (x : X) : e.inv (e.hom x) = x := by\n  rw [‚Üê comp_apply]\n  simp\n\n"}
{"name":"CommGrp.hom_inv_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : CommGrp\ne : CategoryTheory.Iso X Y\ns : ‚ÜëY\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom e.hom) ((CategoryTheory.ConcreteCategory.hom e.inv) s)) s","decl":"@[to_additive (attr := simp)]\nlemma hom_inv_apply {X Y : CommGrp} (e : X ‚âÖ Y) (s : Y) : e.hom (e.inv s) = s := by\n  rw [‚Üê comp_apply]\n  simp\n\n"}
{"name":"AddCommGrp.hom_neg_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : AddCommGrp\ne : CategoryTheory.Iso X Y\ns : ‚ÜëY\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom e.hom) ((CategoryTheory.ConcreteCategory.hom e.inv) s)) s","decl":"@[to_additive (attr := simp)]\nlemma hom_inv_apply {X Y : CommGrp} (e : X ‚âÖ Y) (s : Y) : e.hom (e.inv s) = s := by\n  rw [‚Üê comp_apply]\n  simp\n\n"}
{"name":"CommGrp.coe_comp'","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y Z : CommGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (‚áë(CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.comp f g))) (Function.comp ‚áë(CategoryTheory.ConcreteCategory.hom g) ‚áë(CategoryTheory.ConcreteCategory.hom f))","decl":"@[to_additive (attr := deprecated \"use `coe_comp` instead\" (since := \"2025-01-28\"))]\nalias coe_comp' := coe_comp\n\n"}
{"name":"AddCommGrp.coe_comp'","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y Z : AddCommGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (‚áë(CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.comp f g))) (Function.comp ‚áë(CategoryTheory.ConcreteCategory.hom g) ‚áë(CategoryTheory.ConcreteCategory.hom f))","decl":"@[to_additive (attr := deprecated \"use `coe_comp` instead\" (since := \"2025-01-28\"))]\nalias coe_comp' := coe_comp\n\n"}
{"name":"AddCommGrp.coe_id'","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : AddCommGrp\n‚ä¢ Eq (‚áë(CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.id X))) id","decl":"@[to_additive (attr := deprecated \"use `coe_id` instead\" (since := \"2025-01-28\"))]\nalias coe_id' := coe_id\n\n"}
{"name":"CommGrp.coe_id'","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : CommGrp\n‚ä¢ Eq (‚áë(CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.id X))) id","decl":"@[to_additive (attr := deprecated \"use `coe_id` instead\" (since := \"2025-01-28\"))]\nalias coe_id' := coe_id\n\n"}
{"name":"CommGrp.forget‚ÇÇ_grp_map_ofHom","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Type u\ninst‚úù¬π : CommGroup X\ninst‚úù : CommGroup Y\nf : MonoidHom X Y\n‚ä¢ Eq ((CategoryTheory.forget‚ÇÇ CommGrp Grp).map (CommGrp.ofHom f)) (Grp.ofHom f)","decl":"@[to_additive (attr := simp)] lemma forget‚ÇÇ_grp_map_ofHom {X Y : Type u} [CommGroup X] [CommGroup Y]\n    (f : X ‚Üí* Y) :\n    (forget‚ÇÇ CommGrp Grp).map (ofHom f) = Grp.ofHom f := rfl\n\n"}
{"name":"AddCommGrp.forget‚ÇÇ_addGrp_map_ofHom","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Type u\ninst‚úù¬π : AddCommGroup X\ninst‚úù : AddCommGroup Y\nf : AddMonoidHom X Y\n‚ä¢ Eq ((CategoryTheory.forget‚ÇÇ AddCommGrp AddGrp).map (AddCommGrp.ofHom f)) (AddGrp.ofHom f)","decl":"@[to_additive (attr := simp)] lemma forget‚ÇÇ_grp_map_ofHom {X Y : Type u} [CommGroup X] [CommGroup Y]\n    (f : X ‚Üí* Y) :\n    (forget‚ÇÇ CommGrp Grp).map (ofHom f) = Grp.ofHom f := rfl\n\n"}
{"name":"AddCommGrp.forget‚ÇÇ_commMonCat_map_ofHom","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Type u\ninst‚úù¬π : AddCommGroup X\ninst‚úù : AddCommGroup Y\nf : AddMonoidHom X Y\n‚ä¢ Eq ((CategoryTheory.forget‚ÇÇ AddCommGrp AddCommMonCat).map (AddCommGrp.ofHom f)) (AddCommMonCat.ofHom f)","decl":"@[to_additive (attr := simp)] lemma forget‚ÇÇ_commMonCat_map_ofHom {X Y : Type u}\n    [CommGroup X] [CommGroup Y] (f : X ‚Üí* Y) :\n    (forget‚ÇÇ CommGrp CommMonCat).map (ofHom f) = CommMonCat.ofHom f := rfl\n\n"}
{"name":"CommGrp.forget‚ÇÇ_commMonCat_map_ofHom","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Type u\ninst‚úù¬π : CommGroup X\ninst‚úù : CommGroup Y\nf : MonoidHom X Y\n‚ä¢ Eq ((CategoryTheory.forget‚ÇÇ CommGrp CommMonCat).map (CommGrp.ofHom f)) (CommMonCat.ofHom f)","decl":"@[to_additive (attr := simp)] lemma forget‚ÇÇ_commMonCat_map_ofHom {X Y : Type u}\n    [CommGroup X] [CommGroup Y] (f : X ‚Üí* Y) :\n    (forget‚ÇÇ CommGrp CommMonCat).map (ofHom f) = CommMonCat.ofHom f := rfl\n\n"}
{"name":"AddCommGrp.zero_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"G H : AddCommGrp\ng : ‚ÜëG\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom 0) g) 0","decl":"@[to_additive (attr := simp)]\ntheorem one_apply (G H : CommGrp) (g : G) : ((1 : G ‚ü∂ H) : G ‚Üí H) g = 1 :=\n  rfl\n\n"}
{"name":"CommGrp.one_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"G H : CommGrp\ng : ‚ÜëG\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom 1) g) 1","decl":"@[to_additive (attr := simp)]\ntheorem one_apply (G H : CommGrp) (g : G) : ((1 : G ‚ü∂ H) : G ‚Üí H) g = 1 :=\n  rfl\n\n"}
{"name":"CommGrp.ofHom_injective","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Type u\ninst‚úù¬π : CommGroup X\ninst‚úù : CommGroup Y\n‚ä¢ Function.Injective fun f => CommGrp.ofHom f","decl":"@[to_additive]\nlemma ofHom_injective {X Y : Type u} [CommGroup X] [CommGroup Y] :\n    Function.Injective (fun (f : X ‚Üí* Y) ‚Ü¶ ofHom f) := by\n  intro _ _ h\n  ext\n  apply ConcreteCategory.congr_hom h\n\n-- We verify that simp lemmas apply when coercing morphisms to functions.\n"}
{"name":"AddCommGrp.ofHom_injective","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Type u\ninst‚úù¬π : AddCommGroup X\ninst‚úù : AddCommGroup Y\n‚ä¢ Function.Injective fun f => AddCommGrp.ofHom f","decl":"@[to_additive]\nlemma ofHom_injective {X Y : Type u} [CommGroup X] [CommGroup Y] :\n    Function.Injective (fun (f : X ‚Üí* Y) ‚Ü¶ ofHom f) := by\n  intro _ _ h\n  ext\n  apply ConcreteCategory.congr_hom h\n\n-- We verify that simp lemmas apply when coercing morphisms to functions.\n"}
{"name":"CommGrp.uliftFunctor_map","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"x‚úù¬π x‚úù : CommGrp\nf : Quiver.Hom x‚úù¬π x‚úù\n‚ä¢ Eq (CommGrp.uliftFunctor.map f) (CommGrp.ofHom (MulEquiv.ulift.symm.toMonoidHom.comp ((CommGrp.Hom.hom f).comp MulEquiv.ulift.toMonoidHom)))","decl":"/-- Universe lift functor for commutative groups. -/\n@[to_additive (attr := simps obj map)\n  \"Universe lift functor for additive commutative groups.\"]\ndef uliftFunctor : CommGrp.{v} ‚•§ CommGrp.{max v u} where\n  obj X := CommGrp.of (ULift.{u, v} X)\n  map {_ _} f := CommGrp.ofHom <|\n    MulEquiv.ulift.symm.toMonoidHom.comp <| f.hom.comp MulEquiv.ulift.toMonoidHom\n  map_id X := by rfl\n  map_comp {X Y Z} f g := by rfl\n\n"}
{"name":"AddCommGrp.uliftFunctor_obj","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : AddCommGrp\n‚ä¢ Eq (AddCommGrp.uliftFunctor.obj X) (AddCommGrp.of (ULift.{u, v} ‚ÜëX))","decl":"/-- Universe lift functor for commutative groups. -/\n@[to_additive (attr := simps obj map)\n  \"Universe lift functor for additive commutative groups.\"]\ndef uliftFunctor : CommGrp.{v} ‚•§ CommGrp.{max v u} where\n  obj X := CommGrp.of (ULift.{u, v} X)\n  map {_ _} f := CommGrp.ofHom <|\n    MulEquiv.ulift.symm.toMonoidHom.comp <| f.hom.comp MulEquiv.ulift.toMonoidHom\n  map_id X := by rfl\n  map_comp {X Y Z} f g := by rfl\n\n"}
{"name":"AddCommGrp.uliftFunctor_map","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"x‚úù¬π x‚úù : AddCommGrp\nf : Quiver.Hom x‚úù¬π x‚úù\n‚ä¢ Eq (AddCommGrp.uliftFunctor.map f) (AddCommGrp.ofHom (AddEquiv.ulift.symm.toAddMonoidHom.comp ((AddCommGrp.Hom.hom f).comp AddEquiv.ulift.toAddMonoidHom)))","decl":"/-- Universe lift functor for commutative groups. -/\n@[to_additive (attr := simps obj map)\n  \"Universe lift functor for additive commutative groups.\"]\ndef uliftFunctor : CommGrp.{v} ‚•§ CommGrp.{max v u} where\n  obj X := CommGrp.of (ULift.{u, v} X)\n  map {_ _} f := CommGrp.ofHom <|\n    MulEquiv.ulift.symm.toMonoidHom.comp <| f.hom.comp MulEquiv.ulift.toMonoidHom\n  map_id X := by rfl\n  map_comp {X Y Z} f g := by rfl\n\n"}
{"name":"CommGrp.uliftFunctor_obj","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X : CommGrp\n‚ä¢ Eq (CommGrp.uliftFunctor.obj X) (CommGrp.of (ULift.{u, v} ‚ÜëX))","decl":"/-- Universe lift functor for commutative groups. -/\n@[to_additive (attr := simps obj map)\n  \"Universe lift functor for additive commutative groups.\"]\ndef uliftFunctor : CommGrp.{v} ‚•§ CommGrp.{max v u} where\n  obj X := CommGrp.of (ULift.{u, v} X)\n  map {_ _} f := CommGrp.ofHom <|\n    MulEquiv.ulift.symm.toMonoidHom.comp <| f.hom.comp MulEquiv.ulift.toMonoidHom\n  map_id X := by rfl\n  map_comp {X Y Z} f g := by rfl\n\n"}
{"name":"AddCommGrp.asHom_hom_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"G : AddCommGrp\ng : ‚ÜëG\nn : Int\n‚ä¢ Eq ((AddCommGrp.Hom.hom (AddCommGrp.asHom g)) n) (HSMul.hSMul n g)","decl":"/-- Any element of an abelian group gives a unique morphism from `‚Ñ§` sending\n`1` to that element. -/\n@[simps!]\ndef asHom {G : AddCommGrp.{0}} (g : G) : AddCommGrp.of ‚Ñ§ ‚ü∂ G :=\n  ofHom (zmultiplesHom G g)\n\n"}
{"name":"AddCommGrp.asHom_injective","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"G : AddCommGrp\n‚ä¢ Function.Injective AddCommGrp.asHom","decl":"theorem asHom_injective {G : AddCommGrp.{0}} : Function.Injective (@asHom G) := fun h k w => by\n  simpa using CategoryTheory.congr_fun w 1\n\n"}
{"name":"AddCommGrp.int_hom_ext_iff","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"G : AddCommGrp\nf g : Quiver.Hom (AddCommGrp.of Int) G\n‚ä¢ Iff (Eq f g) (Eq ((CategoryTheory.ConcreteCategory.hom f) 1) ((CategoryTheory.ConcreteCategory.hom g) 1))","decl":"@[ext]\ntheorem int_hom_ext {G : AddCommGrp.{0}} (f g : AddCommGrp.of ‚Ñ§ ‚ü∂ G)\n    (w : f (1 : ‚Ñ§) = g (1 : ‚Ñ§)) : f = g :=\n  hom_ext (AddMonoidHom.ext_int w)\n\n-- TODO: this argument should be generalised to the situation where\n-- the forgetful functor is representable.\n"}
{"name":"AddCommGrp.int_hom_ext","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"G : AddCommGrp\nf g : Quiver.Hom (AddCommGrp.of Int) G\nw : Eq ((CategoryTheory.ConcreteCategory.hom f) 1) ((CategoryTheory.ConcreteCategory.hom g) 1)\n‚ä¢ Eq f g","decl":"@[ext]\ntheorem int_hom_ext {G : AddCommGrp.{0}} (f g : AddCommGrp.of ‚Ñ§ ‚ü∂ G)\n    (w : f (1 : ‚Ñ§) = g (1 : ‚Ñ§)) : f = g :=\n  hom_ext (AddMonoidHom.ext_int w)\n\n-- TODO: this argument should be generalised to the situation where\n-- the forgetful functor is representable.\n"}
{"name":"AddCommGrp.injective_of_mono","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"G H : AddCommGrp\nf : Quiver.Hom G H\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ Function.Injective ‚áë(CategoryTheory.ConcreteCategory.hom f)","decl":"theorem injective_of_mono {G H : AddCommGrp.{0}} (f : G ‚ü∂ H) [Mono f] : Function.Injective f :=\n  fun g‚ÇÅ g‚ÇÇ h => by\n  have t0 : asHom g‚ÇÅ ‚â´ f = asHom g‚ÇÇ ‚â´ f := by aesop_cat\n  have t1 : asHom g‚ÇÅ = asHom g‚ÇÇ := (cancel_mono _).1 t0\n  apply asHom_injective t1\n\n"}
{"name":"MulEquiv.toGrpIso_hom","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Grp\ne : MulEquiv ‚ÜëX ‚ÜëY\n‚ä¢ Eq e.toGrpIso.hom (Grp.ofHom e.toMonoidHom)","decl":"/-- Build an isomorphism in the category `Grp` from a `MulEquiv` between `Group`s. -/\n@[to_additive (attr := simps)]\ndef MulEquiv.toGrpIso {X Y : Grp} (e : X ‚âÉ* Y) : X ‚âÖ Y where\n  hom := Grp.ofHom e.toMonoidHom\n  inv := Grp.ofHom e.symm.toMonoidHom\n\n"}
{"name":"MulEquiv.toGrpIso_inv","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : Grp\ne : MulEquiv ‚ÜëX ‚ÜëY\n‚ä¢ Eq e.toGrpIso.inv (Grp.ofHom e.symm.toMonoidHom)","decl":"/-- Build an isomorphism in the category `Grp` from a `MulEquiv` between `Group`s. -/\n@[to_additive (attr := simps)]\ndef MulEquiv.toGrpIso {X Y : Grp} (e : X ‚âÉ* Y) : X ‚âÖ Y where\n  hom := Grp.ofHom e.toMonoidHom\n  inv := Grp.ofHom e.symm.toMonoidHom\n\n"}
{"name":"AddEquiv.toAddGrpIso_hom","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : AddGrp\ne : AddEquiv ‚ÜëX ‚ÜëY\n‚ä¢ Eq e.toAddGrpIso.hom (AddGrp.ofHom e.toAddMonoidHom)","decl":"/-- Build an isomorphism in the category `Grp` from a `MulEquiv` between `Group`s. -/\n@[to_additive (attr := simps)]\ndef MulEquiv.toGrpIso {X Y : Grp} (e : X ‚âÉ* Y) : X ‚âÖ Y where\n  hom := Grp.ofHom e.toMonoidHom\n  inv := Grp.ofHom e.symm.toMonoidHom\n\n"}
{"name":"AddEquiv.toAddGrpIso_inv","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : AddGrp\ne : AddEquiv ‚ÜëX ‚ÜëY\n‚ä¢ Eq e.toAddGrpIso.inv (AddGrp.ofHom e.symm.toAddMonoidHom)","decl":"/-- Build an isomorphism in the category `Grp` from a `MulEquiv` between `Group`s. -/\n@[to_additive (attr := simps)]\ndef MulEquiv.toGrpIso {X Y : Grp} (e : X ‚âÉ* Y) : X ‚âÖ Y where\n  hom := Grp.ofHom e.toMonoidHom\n  inv := Grp.ofHom e.symm.toMonoidHom\n\n"}
{"name":"MulEquiv.toCommGrpIso_hom","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : CommGrp\ne : MulEquiv ‚ÜëX ‚ÜëY\n‚ä¢ Eq e.toCommGrpIso.hom (CommGrp.ofHom e.toMonoidHom)","decl":"/-- Build an isomorphism in the category `CommGrp` from a `MulEquiv`\nbetween `CommGroup`s. -/\n@[to_additive (attr := simps)]\ndef MulEquiv.toCommGrpIso {X Y : CommGrp} (e : X ‚âÉ* Y) : X ‚âÖ Y where\n  hom := CommGrp.ofHom e.toMonoidHom\n  inv := CommGrp.ofHom e.symm.toMonoidHom\n\n"}
{"name":"AddEquiv.toAddCommGrpIso_inv","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : AddCommGrp\ne : AddEquiv ‚ÜëX ‚ÜëY\n‚ä¢ Eq e.toAddCommGrpIso.inv (AddCommGrp.ofHom e.symm.toAddMonoidHom)","decl":"/-- Build an isomorphism in the category `CommGrp` from a `MulEquiv`\nbetween `CommGroup`s. -/\n@[to_additive (attr := simps)]\ndef MulEquiv.toCommGrpIso {X Y : CommGrp} (e : X ‚âÉ* Y) : X ‚âÖ Y where\n  hom := CommGrp.ofHom e.toMonoidHom\n  inv := CommGrp.ofHom e.symm.toMonoidHom\n\n"}
{"name":"AddEquiv.toAddCommGrpIso_hom","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : AddCommGrp\ne : AddEquiv ‚ÜëX ‚ÜëY\n‚ä¢ Eq e.toAddCommGrpIso.hom (AddCommGrp.ofHom e.toAddMonoidHom)","decl":"/-- Build an isomorphism in the category `CommGrp` from a `MulEquiv`\nbetween `CommGroup`s. -/\n@[to_additive (attr := simps)]\ndef MulEquiv.toCommGrpIso {X Y : CommGrp} (e : X ‚âÉ* Y) : X ‚âÖ Y where\n  hom := CommGrp.ofHom e.toMonoidHom\n  inv := CommGrp.ofHom e.symm.toMonoidHom\n\n"}
{"name":"MulEquiv.toCommGrpIso_inv","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : CommGrp\ne : MulEquiv ‚ÜëX ‚ÜëY\n‚ä¢ Eq e.toCommGrpIso.inv (CommGrp.ofHom e.symm.toMonoidHom)","decl":"/-- Build an isomorphism in the category `CommGrp` from a `MulEquiv`\nbetween `CommGroup`s. -/\n@[to_additive (attr := simps)]\ndef MulEquiv.toCommGrpIso {X Y : CommGrp} (e : X ‚âÉ* Y) : X ‚âÖ Y where\n  hom := CommGrp.ofHom e.toMonoidHom\n  inv := CommGrp.ofHom e.symm.toMonoidHom\n\n"}
{"name":"CategoryTheory.Iso.commGroupIsoToMulEquiv_symm_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : CommGrp\ni : CategoryTheory.Iso X Y\na : ‚ÜëY\n‚ä¢ Eq (i.commGroupIsoToMulEquiv.symm a) ((CommGrp.Hom.hom i.inv) a)","decl":"/-- Build a `MulEquiv` from an isomorphism in the category `CommGroup`. -/\n@[to_additive (attr := simps!)]\ndef commGroupIsoToMulEquiv {X Y : CommGrp} (i : X ‚âÖ Y) : X ‚âÉ* Y :=\n  MonoidHom.toMulEquiv i.hom.hom i.inv.hom (by ext; simp) (by ext; simp)\n\n"}
{"name":"CategoryTheory.Iso.addCommGroupIsoToAddEquiv_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : AddCommGrp\ni : CategoryTheory.Iso X Y\na : ‚ÜëX\n‚ä¢ Eq (i.addCommGroupIsoToAddEquiv a) ((AddCommGrp.Hom.hom i.hom) a)","decl":"/-- Build a `MulEquiv` from an isomorphism in the category `CommGroup`. -/\n@[to_additive (attr := simps!)]\ndef commGroupIsoToMulEquiv {X Y : CommGrp} (i : X ‚âÖ Y) : X ‚âÉ* Y :=\n  MonoidHom.toMulEquiv i.hom.hom i.inv.hom (by ext; simp) (by ext; simp)\n\n"}
{"name":"CategoryTheory.Iso.addCommGroupIsoToAddEquiv_symm_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : AddCommGrp\ni : CategoryTheory.Iso X Y\na : ‚ÜëY\n‚ä¢ Eq (i.addCommGroupIsoToAddEquiv.symm a) ((AddCommGrp.Hom.hom i.inv) a)","decl":"/-- Build a `MulEquiv` from an isomorphism in the category `CommGroup`. -/\n@[to_additive (attr := simps!)]\ndef commGroupIsoToMulEquiv {X Y : CommGrp} (i : X ‚âÖ Y) : X ‚âÉ* Y :=\n  MonoidHom.toMulEquiv i.hom.hom i.inv.hom (by ext; simp) (by ext; simp)\n\n"}
{"name":"CategoryTheory.Iso.commGroupIsoToMulEquiv_apply","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"X Y : CommGrp\ni : CategoryTheory.Iso X Y\na : ‚ÜëX\n‚ä¢ Eq (i.commGroupIsoToMulEquiv a) ((CommGrp.Hom.hom i.hom) a)","decl":"/-- Build a `MulEquiv` from an isomorphism in the category `CommGroup`. -/\n@[to_additive (attr := simps!)]\ndef commGroupIsoToMulEquiv {X Y : CommGrp} (i : X ‚âÖ Y) : X ‚âÉ* Y :=\n  MonoidHom.toMulEquiv i.hom.hom i.inv.hom (by ext; simp) (by ext; simp)\n\n"}
{"name":"Grp.forget_reflects_isos","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"‚ä¢ (CategoryTheory.forget Grp).ReflectsIsomorphisms","decl":"@[to_additive]\ninstance Grp.forget_reflects_isos : (forget Grp.{u}).ReflectsIsomorphisms where\n  reflects {X Y} f _ := by\n    let i := asIso ((forget Grp).map f)\n    let e : X ‚âÉ* Y := { i.toEquiv with map_mul' := map_mul _ }\n    exact e.toGrpIso.isIso_hom\n\n"}
{"name":"AddGrp.forget_reflects_isos","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"‚ä¢ (CategoryTheory.forget AddGrp).ReflectsIsomorphisms","decl":"@[to_additive]\ninstance Grp.forget_reflects_isos : (forget Grp.{u}).ReflectsIsomorphisms where\n  reflects {X Y} f _ := by\n    let i := asIso ((forget Grp).map f)\n    let e : X ‚âÉ* Y := { i.toEquiv with map_mul' := map_mul _ }\n    exact e.toGrpIso.isIso_hom\n\n"}
{"name":"AddCommGrp.forget_reflects_isos","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"‚ä¢ (CategoryTheory.forget AddCommGrp).ReflectsIsomorphisms","decl":"@[to_additive]\ninstance CommGrp.forget_reflects_isos : (forget CommGrp.{u}).ReflectsIsomorphisms where\n  reflects {X Y} f _ := by\n    let i := asIso ((forget CommGrp).map f)\n    let e : X ‚âÉ* Y := { i.toEquiv with map_mul' := map_mul _}\n    exact e.toCommGrpIso.isIso_hom\n\n-- note: in the following definitions, there is a problem with `@[to_additive]`\n-- as the `Category` instance is not found on the additive variant\n-- this variant is then renamed with a `Aux` suffix\n\n"}
{"name":"CommGrp.forget_reflects_isos","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"‚ä¢ (CategoryTheory.forget CommGrp).ReflectsIsomorphisms","decl":"@[to_additive]\ninstance CommGrp.forget_reflects_isos : (forget CommGrp.{u}).ReflectsIsomorphisms where\n  reflects {X Y} f _ := by\n    let i := asIso ((forget CommGrp).map f)\n    let e : X ‚âÉ* Y := { i.toEquiv with map_mul' := map_mul _}\n    exact e.toCommGrpIso.isIso_hom\n\n-- note: in the following definitions, there is a problem with `@[to_additive]`\n-- as the `Category` instance is not found on the additive variant\n-- this variant is then renamed with a `Aux` suffix\n\n"}
{"name":"MonoidHom.comp_id_grp","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"G : Grp\nH : Type u\ninst‚úù : Monoid H\nf : MonoidHom (‚ÜëG) H\n‚ä¢ Eq (f.comp (Grp.Hom.hom (CategoryTheory.CategoryStruct.id G))) f","decl":"@[to_additive (attr := deprecated\n  \"Proven by `simp only [Grp.hom_id, comp_id]`\"\n  (since := \"2025-01-28\"))]\ntheorem MonoidHom.comp_id_grp {G : Grp.{u}} {H : Type u} [Monoid H] (f : G ‚Üí* H) :\n    f.comp (Grp.Hom.hom (ùüô G)) = f := by simp\n"}
{"name":"AddMonoidHom.comp_id_addGrp","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"G : AddGrp\nH : Type u\ninst‚úù : AddMonoid H\nf : AddMonoidHom (‚ÜëG) H\n‚ä¢ Eq (f.comp (AddGrp.Hom.hom (CategoryTheory.CategoryStruct.id G))) f","decl":"@[to_additive (attr := deprecated\n  \"Proven by `simp only [Grp.hom_id, comp_id]`\"\n  (since := \"2025-01-28\"))]\ntheorem MonoidHom.comp_id_grp {G : Grp.{u}} {H : Type u} [Monoid H] (f : G ‚Üí* H) :\n    f.comp (Grp.Hom.hom (ùüô G)) = f := by simp\n"}
{"name":"AddMonoidHom.id_addGrp_comp","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"G : Type u\ninst‚úù : AddMonoid G\nH : AddGrp\nf : AddMonoidHom G ‚ÜëH\n‚ä¢ Eq ((AddGrp.Hom.hom (CategoryTheory.CategoryStruct.id H)).comp f) f","decl":"@[to_additive (attr := deprecated\n  \"Proven by `simp only [Grp.hom_id, id_comp]`\"\n  (since := \"2025-01-28\"))]\ntheorem MonoidHom.id_grp_comp {G : Type u} [Monoid G] {H : Grp.{u}} (f : G ‚Üí* H) :\n    MonoidHom.comp (Grp.Hom.hom (ùüô H)) f = f := by simp\n\n"}
{"name":"MonoidHom.id_grp_comp","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"G : Type u\ninst‚úù : Monoid G\nH : Grp\nf : MonoidHom G ‚ÜëH\n‚ä¢ Eq ((Grp.Hom.hom (CategoryTheory.CategoryStruct.id H)).comp f) f","decl":"@[to_additive (attr := deprecated\n  \"Proven by `simp only [Grp.hom_id, id_comp]`\"\n  (since := \"2025-01-28\"))]\ntheorem MonoidHom.id_grp_comp {G : Type u} [Monoid G] {H : Grp.{u}} (f : G ‚Üí* H) :\n    MonoidHom.comp (Grp.Hom.hom (ùüô H)) f = f := by simp\n\n"}
{"name":"AddMonoidHom.comp_id_addCommGrp","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"G : AddCommGrp\nH : Type u\ninst‚úù : AddMonoid H\nf : AddMonoidHom (‚ÜëG) H\n‚ä¢ Eq (f.comp (AddCommGrp.Hom.hom (CategoryTheory.CategoryStruct.id G))) f","decl":"@[to_additive (attr := deprecated\n  \"Proven by `simp only [CommGrp.hom_id, comp_id]`\"\n  (since := \"2025-01-28\"))]\ntheorem MonoidHom.comp_id_commGrp {G : CommGrp.{u}} {H : Type u} [Monoid H] (f : G ‚Üí* H) :\n    f.comp (CommGrp.Hom.hom (ùüô G)) = f := by\n  simp\n"}
{"name":"MonoidHom.comp_id_commGrp","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"G : CommGrp\nH : Type u\ninst‚úù : Monoid H\nf : MonoidHom (‚ÜëG) H\n‚ä¢ Eq (f.comp (CommGrp.Hom.hom (CategoryTheory.CategoryStruct.id G))) f","decl":"@[to_additive (attr := deprecated\n  \"Proven by `simp only [CommGrp.hom_id, comp_id]`\"\n  (since := \"2025-01-28\"))]\ntheorem MonoidHom.comp_id_commGrp {G : CommGrp.{u}} {H : Type u} [Monoid H] (f : G ‚Üí* H) :\n    f.comp (CommGrp.Hom.hom (ùüô G)) = f := by\n  simp\n"}
{"name":"MonoidHom.id_commGrp_comp","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"G : Type u\ninst‚úù : Monoid G\nH : CommGrp\nf : MonoidHom G ‚ÜëH\n‚ä¢ Eq ((CommGrp.Hom.hom (CategoryTheory.CategoryStruct.id H)).comp f) f","decl":"@[to_additive (attr := deprecated\n  \"Proven by `simp only [CommGrp.hom_id, id_comp]`\"\n  (since := \"2025-01-28\"))]\ntheorem MonoidHom.id_commGrp_comp {G : Type u} [Monoid G] {H : CommGrp.{u}} (f : G ‚Üí* H) :\n    MonoidHom.comp (CommGrp.Hom.hom (ùüô H)) f = f := by\n  simp\n"}
{"name":"AddMonoidHom.id_addCommGrp_comp","module":"Mathlib.Algebra.Category.Grp.Basic","initialProofState":"G : Type u\ninst‚úù : AddMonoid G\nH : AddCommGrp\nf : AddMonoidHom G ‚ÜëH\n‚ä¢ Eq ((AddCommGrp.Hom.hom (CategoryTheory.CategoryStruct.id H)).comp f) f","decl":"@[to_additive (attr := deprecated\n  \"Proven by `simp only [CommGrp.hom_id, id_comp]`\"\n  (since := \"2025-01-28\"))]\ntheorem MonoidHom.id_commGrp_comp {G : Type u} [Monoid G] {H : CommGrp.{u}} (f : G ‚Üí* H) :\n    MonoidHom.comp (CommGrp.Hom.hom (ùüô H)) f = f := by\n  simp\n"}
