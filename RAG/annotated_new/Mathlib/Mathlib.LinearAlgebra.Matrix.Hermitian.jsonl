{"name":"Matrix.IsHermitian.eq","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝ : Star α\nA : Matrix n n α\nh : A.IsHermitian\n⊢ Eq A.conjTranspose A","decl":"theorem IsHermitian.eq {A : Matrix n n α} (h : A.IsHermitian) : Aᴴ = A := h\n\n"}
{"name":"Matrix.IsHermitian.isSelfAdjoint","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝ : Star α\nA : Matrix n n α\nh : A.IsHermitian\n⊢ IsSelfAdjoint A","decl":"protected theorem IsHermitian.isSelfAdjoint {A : Matrix n n α} (h : A.IsHermitian) :\n    IsSelfAdjoint A := h\n\n-- @[ext] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): incorrect `ext`, not a structure or a lemma proving `x = y`.\n"}
{"name":"Matrix.IsHermitian.ext","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝ : Star α\nA : Matrix n n α\na✝ : ∀ (i j : n), Eq (Star.star (A j i)) (A i j)\n⊢ A.IsHermitian","decl":"theorem IsHermitian.ext {A : Matrix n n α} : (∀ i j, star (A j i) = A i j) → A.IsHermitian := by\n  intro h; ext i j; exact h i j\n\n"}
{"name":"Matrix.IsHermitian.apply","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝ : Star α\nA : Matrix n n α\nh : A.IsHermitian\ni j : n\n⊢ Eq (Star.star (A j i)) (A i j)","decl":"theorem IsHermitian.apply {A : Matrix n n α} (h : A.IsHermitian) (i j : n) : star (A j i) = A i j :=\n  congr_fun (congr_fun h _) _\n\n"}
{"name":"Matrix.IsHermitian.ext_iff","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝ : Star α\nA : Matrix n n α\n⊢ Iff A.IsHermitian (∀ (i j : n), Eq (Star.star (A j i)) (A i j))","decl":"theorem IsHermitian.ext_iff {A : Matrix n n α} : A.IsHermitian ↔ ∀ i j, star (A j i) = A i j :=\n  ⟨IsHermitian.apply, IsHermitian.ext⟩\n\n"}
{"name":"Matrix.IsHermitian.map","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Type u_4\ninst✝¹ : Star α\ninst✝ : Star β\nA : Matrix n n α\nh : A.IsHermitian\nf : α → β\nhf : Function.Semiconj f Star.star Star.star\n⊢ (A.map f).IsHermitian","decl":"@[simp]\ntheorem IsHermitian.map {A : Matrix n n α} (h : A.IsHermitian) (f : α → β)\n    (hf : Function.Semiconj f star star) : (A.map f).IsHermitian :=\n  (conjTranspose_map f hf).symm.trans <| h.eq.symm ▸ rfl\n\n"}
{"name":"Matrix.IsHermitian.transpose","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝ : Star α\nA : Matrix n n α\nh : A.IsHermitian\n⊢ A.transpose.IsHermitian","decl":"theorem IsHermitian.transpose {A : Matrix n n α} (h : A.IsHermitian) : Aᵀ.IsHermitian := by\n  rw [IsHermitian, conjTranspose, transpose_map]\n  exact congr_arg Matrix.transpose h\n\n"}
{"name":"Matrix.isHermitian_transpose_iff","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝ : Star α\nA : Matrix n n α\n⊢ Iff A.transpose.IsHermitian A.IsHermitian","decl":"@[simp]\ntheorem isHermitian_transpose_iff (A : Matrix n n α) : Aᵀ.IsHermitian ↔ A.IsHermitian :=\n  ⟨by intro h; rw [← transpose_transpose A]; exact IsHermitian.transpose h, IsHermitian.transpose⟩\n\n"}
{"name":"Matrix.IsHermitian.conjTranspose","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝ : Star α\nA : Matrix n n α\nh : A.IsHermitian\n⊢ A.conjTranspose.IsHermitian","decl":"theorem IsHermitian.conjTranspose {A : Matrix n n α} (h : A.IsHermitian) : Aᴴ.IsHermitian :=\n  h.transpose.map _ fun _ => rfl\n\n"}
{"name":"Matrix.IsHermitian.submatrix","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nm : Type u_3\nn : Type u_4\ninst✝ : Star α\nA : Matrix n n α\nh : A.IsHermitian\nf : m → n\n⊢ (A.submatrix f f).IsHermitian","decl":"@[simp]\ntheorem IsHermitian.submatrix {A : Matrix n n α} (h : A.IsHermitian) (f : m → n) :\n    (A.submatrix f f).IsHermitian := (conjTranspose_submatrix _ _ _).trans (h.symm ▸ rfl)\n\n"}
{"name":"Matrix.isHermitian_submatrix_equiv","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nm : Type u_3\nn : Type u_4\ninst✝ : Star α\nA : Matrix n n α\ne : Equiv m n\n⊢ Iff (A.submatrix ⇑e ⇑e).IsHermitian A.IsHermitian","decl":"@[simp]\ntheorem isHermitian_submatrix_equiv {A : Matrix n n α} (e : m ≃ n) :\n    (A.submatrix e e).IsHermitian ↔ A.IsHermitian :=\n  ⟨fun h => by simpa using h.submatrix e.symm, fun h => h.submatrix _⟩\n\n"}
{"name":"Matrix.isHermitian_conjTranspose_iff","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝ : InvolutiveStar α\nA : Matrix n n α\n⊢ Iff A.conjTranspose.IsHermitian A.IsHermitian","decl":"@[simp]\ntheorem isHermitian_conjTranspose_iff (A : Matrix n n α) : Aᴴ.IsHermitian ↔ A.IsHermitian :=\n  IsSelfAdjoint.star_iff\n\n"}
{"name":"Matrix.IsHermitian.fromBlocks","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nm : Type u_3\nn : Type u_4\ninst✝ : InvolutiveStar α\nA : Matrix m m α\nB : Matrix m n α\nC : Matrix n m α\nD : Matrix n n α\nhA : A.IsHermitian\nhBC : Eq B.conjTranspose C\nhD : D.IsHermitian\n⊢ (Matrix.fromBlocks A B C D).IsHermitian","decl":"/-- A block matrix `A.from_blocks B C D` is hermitian,\n    if `A` and `D` are hermitian and `Bᴴ = C`. -/\ntheorem IsHermitian.fromBlocks {A : Matrix m m α} {B : Matrix m n α} {C : Matrix n m α}\n    {D : Matrix n n α} (hA : A.IsHermitian) (hBC : Bᴴ = C) (hD : D.IsHermitian) :\n    (A.fromBlocks B C D).IsHermitian := by\n  have hCB : Cᴴ = B := by rw [← hBC, conjTranspose_conjTranspose]\n  unfold Matrix.IsHermitian\n  rw [fromBlocks_conjTranspose, hBC, hCB, hA, hD]\n\n"}
{"name":"Matrix.isHermitian_fromBlocks_iff","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nm : Type u_3\nn : Type u_4\ninst✝ : InvolutiveStar α\nA : Matrix m m α\nB : Matrix m n α\nC : Matrix n m α\nD : Matrix n n α\n⊢ Iff (Matrix.fromBlocks A B C D).IsHermitian (And A.IsHermitian (And (Eq B.conjTranspose C) (And (Eq C.conjTranspose B) D.IsHermitian)))","decl":"/-- This is the `iff` version of `Matrix.IsHermitian.fromBlocks`. -/\ntheorem isHermitian_fromBlocks_iff {A : Matrix m m α} {B : Matrix m n α} {C : Matrix n m α}\n    {D : Matrix n n α} :\n    (A.fromBlocks B C D).IsHermitian ↔ A.IsHermitian ∧ Bᴴ = C ∧ Cᴴ = B ∧ D.IsHermitian :=\n  ⟨fun h =>\n    ⟨congr_arg toBlocks₁₁ h, congr_arg toBlocks₂₁ h, congr_arg toBlocks₁₂ h,\n      congr_arg toBlocks₂₂ h⟩,\n    fun ⟨hA, hBC, _hCB, hD⟩ => IsHermitian.fromBlocks hA hBC hD⟩\n\n"}
{"name":"Matrix.isHermitian_diagonal_of_self_adjoint","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝² : AddMonoid α\ninst✝¹ : StarAddMonoid α\ninst✝ : DecidableEq n\nv : n → α\nh : IsSelfAdjoint v\n⊢ (Matrix.diagonal v).IsHermitian","decl":"/-- A diagonal matrix is hermitian if the entries are self-adjoint (as a vector) -/\ntheorem isHermitian_diagonal_of_self_adjoint [DecidableEq n] (v : n → α) (h : IsSelfAdjoint v) :\n    (diagonal v).IsHermitian :=\n  (-- TODO: add a `pi.has_trivial_star` instance and remove the `funext`\n        diagonal_conjTranspose v).trans <| congr_arg _ h\n\n"}
{"name":"Matrix.isHermitian_diagonal_iff","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝² : AddMonoid α\ninst✝¹ : StarAddMonoid α\ninst✝ : DecidableEq n\nd : n → α\n⊢ Iff (Matrix.diagonal d).IsHermitian (∀ (i : n), IsSelfAdjoint (d i))","decl":"/-- A diagonal matrix is hermitian if each diagonal entry is self-adjoint -/\nlemma isHermitian_diagonal_iff [DecidableEq n] {d : n → α} :\n    IsHermitian (diagonal d) ↔ (∀ i : n, IsSelfAdjoint (d i)) := by\n  simp [isSelfAdjoint_iff, IsHermitian, conjTranspose, diagonal_transpose, diagonal_map]\n\n"}
{"name":"Matrix.isHermitian_diagonal","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝³ : AddMonoid α\ninst✝² : StarAddMonoid α\ninst✝¹ : TrivialStar α\ninst✝ : DecidableEq n\nv : n → α\n⊢ (Matrix.diagonal v).IsHermitian","decl":"/-- A diagonal matrix is hermitian if the entries have the trivial `star` operation\n(such as on the reals). -/\n@[simp]\ntheorem isHermitian_diagonal [TrivialStar α] [DecidableEq n] (v : n → α) :\n    (diagonal v).IsHermitian :=\n  isHermitian_diagonal_of_self_adjoint _ (IsSelfAdjoint.all _)\n\n"}
{"name":"Matrix.isHermitian_zero","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝¹ : AddMonoid α\ninst✝ : StarAddMonoid α\n⊢ Matrix.IsHermitian 0","decl":"@[simp]\ntheorem isHermitian_zero : (0 : Matrix n n α).IsHermitian :=\n  IsSelfAdjoint.zero _\n\n"}
{"name":"Matrix.IsHermitian.add","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝¹ : AddMonoid α\ninst✝ : StarAddMonoid α\nA B : Matrix n n α\nhA : A.IsHermitian\nhB : B.IsHermitian\n⊢ (HAdd.hAdd A B).IsHermitian","decl":"@[simp]\ntheorem IsHermitian.add {A B : Matrix n n α} (hA : A.IsHermitian) (hB : B.IsHermitian) :\n    (A + B).IsHermitian :=\n  IsSelfAdjoint.add hA hB\n\n"}
{"name":"Matrix.isHermitian_add_transpose_self","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝¹ : AddCommMonoid α\ninst✝ : StarAddMonoid α\nA : Matrix n n α\n⊢ (HAdd.hAdd A A.conjTranspose).IsHermitian","decl":"theorem isHermitian_add_transpose_self (A : Matrix n n α) : (A + Aᴴ).IsHermitian :=\n  IsSelfAdjoint.add_star_self A\n\n"}
{"name":"Matrix.isHermitian_transpose_add_self","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝¹ : AddCommMonoid α\ninst✝ : StarAddMonoid α\nA : Matrix n n α\n⊢ (HAdd.hAdd A.conjTranspose A).IsHermitian","decl":"theorem isHermitian_transpose_add_self (A : Matrix n n α) : (Aᴴ + A).IsHermitian :=\n  IsSelfAdjoint.star_add_self A\n\n"}
{"name":"Matrix.IsHermitian.neg","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝¹ : AddGroup α\ninst✝ : StarAddMonoid α\nA : Matrix n n α\nh : A.IsHermitian\n⊢ (Neg.neg A).IsHermitian","decl":"@[simp]\ntheorem IsHermitian.neg {A : Matrix n n α} (h : A.IsHermitian) : (-A).IsHermitian :=\n  IsSelfAdjoint.neg h\n\n"}
{"name":"Matrix.IsHermitian.sub","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝¹ : AddGroup α\ninst✝ : StarAddMonoid α\nA B : Matrix n n α\nhA : A.IsHermitian\nhB : B.IsHermitian\n⊢ (HSub.hSub A B).IsHermitian","decl":"@[simp]\ntheorem IsHermitian.sub {A B : Matrix n n α} (hA : A.IsHermitian) (hB : B.IsHermitian) :\n    (A - B).IsHermitian :=\n  IsSelfAdjoint.sub hA hB\n\n"}
{"name":"Matrix.isHermitian_mul_conjTranspose_self","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nm : Type u_3\nn : Type u_4\ninst✝² : NonUnitalSemiring α\ninst✝¹ : StarRing α\ninst✝ : Fintype n\nA : Matrix m n α\n⊢ (HMul.hMul A A.conjTranspose).IsHermitian","decl":"/-- Note this is more general than `IsSelfAdjoint.mul_star_self` as `B` can be rectangular. -/\ntheorem isHermitian_mul_conjTranspose_self [Fintype n] (A : Matrix m n α) :\n    (A * Aᴴ).IsHermitian := by rw [IsHermitian, conjTranspose_mul, conjTranspose_conjTranspose]\n\n"}
{"name":"Matrix.isHermitian_transpose_mul_self","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nm : Type u_3\nn : Type u_4\ninst✝² : NonUnitalSemiring α\ninst✝¹ : StarRing α\ninst✝ : Fintype m\nA : Matrix m n α\n⊢ (HMul.hMul A.conjTranspose A).IsHermitian","decl":"/-- Note this is more general than `IsSelfAdjoint.star_mul_self` as `B` can be rectangular. -/\ntheorem isHermitian_transpose_mul_self [Fintype m] (A : Matrix m n α) : (Aᴴ * A).IsHermitian := by\n  rw [IsHermitian, conjTranspose_mul, conjTranspose_conjTranspose]\n\n"}
{"name":"Matrix.isHermitian_conjTranspose_mul_mul","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nm : Type u_3\nn : Type u_4\ninst✝² : NonUnitalSemiring α\ninst✝¹ : StarRing α\ninst✝ : Fintype m\nA : Matrix m m α\nB : Matrix m n α\nhA : A.IsHermitian\n⊢ (HMul.hMul (HMul.hMul B.conjTranspose A) B).IsHermitian","decl":"/-- Note this is more general than `IsSelfAdjoint.conjugate'` as `B` can be rectangular. -/\ntheorem isHermitian_conjTranspose_mul_mul [Fintype m] {A : Matrix m m α} (B : Matrix m n α)\n    (hA : A.IsHermitian) : (Bᴴ * A * B).IsHermitian := by\n  simp only [IsHermitian, conjTranspose_mul, conjTranspose_conjTranspose, hA.eq, Matrix.mul_assoc]\n\n"}
{"name":"Matrix.isHermitian_mul_mul_conjTranspose","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nm : Type u_3\nn : Type u_4\ninst✝² : NonUnitalSemiring α\ninst✝¹ : StarRing α\ninst✝ : Fintype m\nA : Matrix m m α\nB : Matrix n m α\nhA : A.IsHermitian\n⊢ (HMul.hMul (HMul.hMul B A) B.conjTranspose).IsHermitian","decl":"/-- Note this is more general than `IsSelfAdjoint.conjugate` as `B` can be rectangular. -/\ntheorem isHermitian_mul_mul_conjTranspose [Fintype m] {A : Matrix m m α} (B : Matrix n m α)\n    (hA : A.IsHermitian) : (B * A * Bᴴ).IsHermitian := by\n  simp only [IsHermitian, conjTranspose_mul, conjTranspose_conjTranspose, hA.eq, Matrix.mul_assoc]\n\n"}
{"name":"Matrix.commute_iff","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝² : NonUnitalSemiring α\ninst✝¹ : StarRing α\ninst✝ : Fintype n\nA B : Matrix n n α\nhA : A.IsHermitian\nhB : B.IsHermitian\n⊢ Iff (Commute A B) (HMul.hMul A B).IsHermitian","decl":"lemma commute_iff [Fintype n] {A B : Matrix n n α}\n    (hA : A.IsHermitian) (hB : B.IsHermitian) : Commute A B ↔ (A * B).IsHermitian :=\n  hA.isSelfAdjoint.commute_iff hB.isSelfAdjoint\n\n"}
{"name":"Matrix.isHermitian_one","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝² : Semiring α\ninst✝¹ : StarRing α\ninst✝ : DecidableEq n\n⊢ Matrix.IsHermitian 1","decl":"/-- Note this is more general for matrices than `isSelfAdjoint_one` as it does not\nrequire `Fintype n`, which is necessary for `Monoid (Matrix n n R)`. -/\n@[simp]\ntheorem isHermitian_one [DecidableEq n] : (1 : Matrix n n α).IsHermitian :=\n  conjTranspose_one\n\n"}
{"name":"Matrix.isHermitian_natCast","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝² : Semiring α\ninst✝¹ : StarRing α\ninst✝ : DecidableEq n\nd : Nat\n⊢ (↑d).IsHermitian","decl":"@[simp]\ntheorem isHermitian_natCast [DecidableEq n] (d : ℕ) : (d : Matrix n n α).IsHermitian :=\n  conjTranspose_natCast _\n\n"}
{"name":"Matrix.IsHermitian.pow","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝³ : Semiring α\ninst✝² : StarRing α\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n α\nh : A.IsHermitian\nk : Nat\n⊢ (HPow.hPow A k).IsHermitian","decl":"theorem IsHermitian.pow [Fintype n] [DecidableEq n] {A : Matrix n n α} (h : A.IsHermitian) (k : ℕ) :\n    (A ^ k).IsHermitian := IsSelfAdjoint.pow h _\n\n"}
{"name":"Matrix.isHermitian_intCast","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝² : Ring α\ninst✝¹ : StarRing α\ninst✝ : DecidableEq n\nd : Int\n⊢ (↑d).IsHermitian","decl":"@[simp]\ntheorem isHermitian_intCast [DecidableEq n] (d : ℤ) : (d : Matrix n n α).IsHermitian :=\n  conjTranspose_intCast _\n\n"}
{"name":"Matrix.IsHermitian.inv","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nm : Type u_3\ninst✝³ : CommRing α\ninst✝² : StarRing α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nA : Matrix m m α\nhA : A.IsHermitian\n⊢ (Inv.inv A).IsHermitian","decl":"theorem IsHermitian.inv [Fintype m] [DecidableEq m] {A : Matrix m m α} (hA : A.IsHermitian) :\n    A⁻¹.IsHermitian := by simp [IsHermitian, conjTranspose_nonsing_inv, hA.eq]\n\n"}
{"name":"Matrix.isHermitian_inv","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nm : Type u_3\ninst✝⁴ : CommRing α\ninst✝³ : StarRing α\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\nA : Matrix m m α\ninst✝ : Invertible A\n⊢ Iff (Inv.inv A).IsHermitian A.IsHermitian","decl":"@[simp]\ntheorem isHermitian_inv [Fintype m] [DecidableEq m] (A : Matrix m m α) [Invertible A] :\n    A⁻¹.IsHermitian ↔ A.IsHermitian :=\n  ⟨fun h => by rw [← inv_inv_of_invertible A]; exact IsHermitian.inv h, IsHermitian.inv⟩\n\n"}
{"name":"Matrix.IsHermitian.adjugate","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nm : Type u_3\ninst✝³ : CommRing α\ninst✝² : StarRing α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nA : Matrix m m α\nhA : A.IsHermitian\n⊢ A.adjugate.IsHermitian","decl":"theorem IsHermitian.adjugate [Fintype m] [DecidableEq m] {A : Matrix m m α} (hA : A.IsHermitian) :\n    A.adjugate.IsHermitian := by simp [IsHermitian, adjugate_conjTranspose, hA.eq]\n\n"}
{"name":"Matrix.IsHermitian.zpow","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nm : Type u_3\ninst✝³ : CommRing α\ninst✝² : StarRing α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nA : Matrix m m α\nh : A.IsHermitian\nk : Int\n⊢ (HPow.hPow A k).IsHermitian","decl":"/-- Note that `IsSelfAdjoint.zpow` does not apply to matrices as they are not a division ring. -/\ntheorem IsHermitian.zpow [Fintype m] [DecidableEq m] {A : Matrix m m α} (h : A.IsHermitian)\n    (k : ℤ) :\n    (A ^ k).IsHermitian := by\n  rw [IsHermitian, conjTranspose_zpow, h]\n\n"}
{"name":"Matrix.IsHermitian.coe_re_apply_self","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝ : RCLike α\nA : Matrix n n α\nh : A.IsHermitian\ni : n\n⊢ Eq (↑(RCLike.re (A i i))) (A i i)","decl":"/-- The diagonal elements of a complex hermitian matrix are real. -/\ntheorem IsHermitian.coe_re_apply_self {A : Matrix n n α} (h : A.IsHermitian) (i : n) :\n    (re (A i i) : α) = A i i := by rw [← conj_eq_iff_re, ← star_def, ← conjTranspose_apply, h.eq]\n\n"}
{"name":"Matrix.IsHermitian.coe_re_diag","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝ : RCLike α\nA : Matrix n n α\nh : A.IsHermitian\n⊢ Eq (fun i => ↑(RCLike.re (A.diag i))) A.diag","decl":"/-- The diagonal elements of a complex hermitian matrix are real. -/\ntheorem IsHermitian.coe_re_diag {A : Matrix n n α} (h : A.IsHermitian) :\n    (fun i => (re (A.diag i) : α)) = A.diag :=\n  funext h.coe_re_apply_self\n\n"}
{"name":"Matrix.isHermitian_iff_isSymmetric","module":"Mathlib.LinearAlgebra.Matrix.Hermitian","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝² : RCLike α\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n α\n⊢ Iff A.IsHermitian (Matrix.toEuclideanLin A).IsSymmetric","decl":"/-- A matrix is hermitian iff the corresponding linear map is self adjoint. -/\ntheorem isHermitian_iff_isSymmetric [Fintype n] [DecidableEq n] {A : Matrix n n α} :\n    IsHermitian A ↔ A.toEuclideanLin.IsSymmetric := by\n  rw [LinearMap.IsSymmetric, (WithLp.equiv 2 (n → α)).symm.surjective.forall₂]\n  simp only [toEuclideanLin_piLp_equiv_symm, EuclideanSpace.inner_piLp_equiv_symm, toLin'_apply,\n    star_mulVec, dotProduct_mulVec]\n  constructor\n  · rintro (h : Aᴴ = A) x y\n    rw [h]\n  · intro h\n    ext i j\n    simpa only [(Pi.single_star i 1).symm, ← star_mulVec, mul_one, dotProduct_single,\n      single_one_vecMul, star_one] using h (Pi.single i 1) (Pi.single j 1)\n\n"}
