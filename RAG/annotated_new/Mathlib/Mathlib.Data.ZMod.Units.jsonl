{"name":"ZMod.unitsMap_def","module":"Mathlib.Data.ZMod.Units","initialProofState":"n m : Nat\nhm : Dvd.dvd n m\n⊢ Eq (ZMod.unitsMap hm) (Units.map ↑(ZMod.castHom hm (ZMod n)))","decl":"lemma unitsMap_def (hm : n ∣ m) : unitsMap hm = Units.map (castHom hm (ZMod n)) := rfl\n\n"}
{"name":"ZMod.unitsMap_comp","module":"Mathlib.Data.ZMod.Units","initialProofState":"n m d : Nat\nhm : Dvd.dvd n m\nhd : Dvd.dvd m d\n⊢ Eq ((ZMod.unitsMap hm).comp (ZMod.unitsMap hd)) (ZMod.unitsMap ⋯)","decl":"lemma unitsMap_comp {d : ℕ} (hm : n ∣ m) (hd : m ∣ d) :\n    (unitsMap hm).comp (unitsMap hd) = unitsMap (dvd_trans hm hd) := by\n  simp only [unitsMap_def]\n  rw [← Units.map_comp]\n  exact congr_arg Units.map <| congr_arg RingHom.toMonoidHom <| castHom_comp hm hd\n\n"}
{"name":"ZMod.unitsMap_self","module":"Mathlib.Data.ZMod.Units","initialProofState":"n : Nat\n⊢ Eq (ZMod.unitsMap ⋯) (MonoidHom.id (Units (ZMod n)))","decl":"@[simp]\nlemma unitsMap_self (n : ℕ) : unitsMap (dvd_refl n) = MonoidHom.id _ := by\n  simp [unitsMap, castHom_self]\n\n"}
{"name":"ZMod.unitsMap_val","module":"Mathlib.Data.ZMod.Units","initialProofState":"n m : Nat\nh : Dvd.dvd n m\na : Units (ZMod m)\n⊢ Eq (↑((ZMod.unitsMap h) a)) (↑a).cast","decl":"/-- `unitsMap_val` shows that coercing from `(ZMod m)ˣ` to `ZMod n` gives the same result\nwhen going via `(ZMod n)ˣ` and `ZMod m`. -/\nlemma unitsMap_val (h : n ∣ m) (a : (ZMod m)ˣ) :\n    ↑(unitsMap h a) = ((a : ZMod m).cast : ZMod n) := rfl\n\n"}
{"name":"ZMod.isUnit_cast_of_dvd","module":"Mathlib.Data.ZMod.Units","initialProofState":"n m : Nat\nhm : Dvd.dvd n m\na : Units (ZMod m)\n⊢ IsUnit (↑a).cast","decl":"lemma isUnit_cast_of_dvd (hm : n ∣ m) (a : Units (ZMod m)) : IsUnit (cast (a : ZMod m) : ZMod n) :=\n  Units.isUnit (unitsMap hm a)\n"}
{"name":"ZMod.IsUnit_cast_of_dvd","module":"Mathlib.Data.ZMod.Units","initialProofState":"n m : Nat\nhm : Dvd.dvd n m\na : Units (ZMod m)\n⊢ IsUnit (↑a).cast","decl":"@[deprecated (since := \"2024-12-16\")] alias IsUnit_cast_of_dvd := isUnit_cast_of_dvd\n\n"}
{"name":"ZMod.unitsMap_surjective","module":"Mathlib.Data.ZMod.Units","initialProofState":"n m : Nat\nhm : NeZero m\nh : Dvd.dvd n m\n⊢ Function.Surjective ⇑(ZMod.unitsMap h)","decl":"theorem unitsMap_surjective [hm : NeZero m] (h : n ∣ m) :\n    Function.Surjective (unitsMap h) := by\n  suffices ∀ x : ℕ, x.Coprime n → ∃ k : ℕ, (x + k * n).Coprime m by\n    intro x\n    have ⟨k, hk⟩ := this x.val.val (val_coe_unit_coprime x)\n    refine ⟨unitOfCoprime _ hk, Units.ext ?_⟩\n    have : NeZero n := ⟨fun hn ↦ hm.out (eq_zero_of_zero_dvd (hn ▸ h))⟩\n    simp [unitsMap_def, - castHom_apply]\n  intro x hx\n  let ps := m.primeFactors.filter (fun p ↦ ¬p ∣ x)\n  use ps.prod id\n  apply Nat.coprime_of_dvd\n  intro p pp hp hpn\n  by_cases hpx : p ∣ x\n  · have h := Nat.dvd_sub' hp hpx\n    rw [add_comm, Nat.add_sub_cancel] at h\n    rcases pp.dvd_mul.mp h with h | h\n    · have ⟨q, hq, hq'⟩ := (pp.prime.dvd_finset_prod_iff id).mp h\n      rw [Finset.mem_filter, Nat.mem_primeFactors,\n        ← (Nat.prime_dvd_prime_iff_eq pp hq.1.1).mp hq'] at hq\n      exact hq.2 hpx\n    · exact Nat.Prime.not_coprime_iff_dvd.mpr ⟨p, pp, hpx, h⟩ hx\n  · have pps : p ∈ ps := Finset.mem_filter.mpr ⟨Nat.mem_primeFactors.mpr ⟨pp, hpn, hm.out⟩, hpx⟩\n    have h := Nat.dvd_sub' hp ((Finset.dvd_prod_of_mem id pps).mul_right n)\n    rw [Nat.add_sub_cancel] at h\n    contradiction\n\n-- This needs `Nat.primeFactors`, so cannot go into `Mathlib.Data.ZMod.Basic`.\n"}
{"name":"ZMod.not_isUnit_of_mem_primeFactors","module":"Mathlib.Data.ZMod.Units","initialProofState":"n p : Nat\nh : Membership.mem n.primeFactors p\n⊢ Not (IsUnit ↑p)","decl":"open Nat in\nlemma not_isUnit_of_mem_primeFactors {n p : ℕ} (h : p ∈ n.primeFactors) :\n    ¬ IsUnit (p : ZMod n) := by\n  rw [isUnit_iff_coprime]\n  exact (Prime.dvd_iff_not_coprime <| prime_of_mem_primeFactors h).mp <| dvd_of_mem_primeFactors h\n\n"}
{"name":"ZMod.eq_unit_mul_divisor","module":"Mathlib.Data.ZMod.Units","initialProofState":"N : Nat\na : ZMod N\n⊢ Exists fun d => And (Dvd.dvd d N) (Exists fun u => And (IsUnit u) (Eq a (HMul.hMul u ↑d)))","decl":"/-- Any element of `ZMod N` has the form `u * d` where `u` is a unit and `d` is a divisor of `N`. -/\nlemma eq_unit_mul_divisor {N : ℕ} (a : ZMod N) :\n    ∃ d : ℕ, d ∣ N ∧ ∃ (u : ZMod N), IsUnit u ∧ a = u * d := by\n  rcases eq_or_ne N 0 with rfl | hN\n  -- Silly special case : N = 0. Of no mathematical interest, but true, so let's prove it.\n  · change ℤ at a\n    rcases eq_or_ne a 0 with rfl | ha\n    · refine ⟨0, dvd_zero _, 1, isUnit_one, by rw [Nat.cast_zero, mul_zero]⟩\n    refine ⟨a.natAbs, dvd_zero _, Int.sign a, ?_, (Int.sign_mul_natAbs a).symm⟩\n    rcases lt_or_gt_of_ne ha with h | h\n    · simp only [Int.sign_eq_neg_one_of_neg h, IsUnit.neg_iff, isUnit_one]\n    · simp only [Int.sign_eq_one_of_pos h, isUnit_one]\n  -- now the interesting case\n  have : NeZero N := ⟨hN⟩\n  -- Define `d` as the GCD of a lift of `a` and `N`.\n  let d := a.val.gcd N\n  have hd : d ≠ 0 := Nat.gcd_ne_zero_right hN\n  obtain ⟨a₀, (ha₀ : _ = d * _)⟩ := a.val.gcd_dvd_left N\n  obtain ⟨N₀, (hN₀ : _ = d * _)⟩ := a.val.gcd_dvd_right N\n  refine ⟨d, ⟨N₀, hN₀⟩, ?_⟩\n  -- Show `a` is a unit mod `N / d`.\n  have hu₀ : IsUnit (a₀ : ZMod N₀) := by\n    refine (isUnit_iff_coprime _ _).mpr (Nat.isCoprime_iff_coprime.mp ?_)\n    obtain ⟨p, q, hpq⟩ : ∃ (p q : ℤ), d = a.val * p + N * q := ⟨_, _, Nat.gcd_eq_gcd_ab _ _⟩\n    rw [ha₀, hN₀, Nat.cast_mul, Nat.cast_mul, mul_assoc, mul_assoc, ← mul_add, eq_comm,\n      mul_comm _ p, mul_comm _ q] at hpq\n    exact ⟨p, q, Int.eq_one_of_mul_eq_self_right (Nat.cast_ne_zero.mpr hd) hpq⟩\n  -- Lift it arbitrarily to a unit mod `N`.\n  obtain ⟨u, hu⟩ := (ZMod.unitsMap_surjective (⟨d, mul_comm d N₀ ▸ hN₀⟩ : N₀ ∣ N)) hu₀.unit\n  rw [unitsMap_def, ← Units.eq_iff, Units.coe_map, IsUnit.unit_spec, MonoidHom.coe_coe] at hu\n  refine ⟨u.val, u.isUnit, ?_⟩\n  rw [← ZMod.natCast_zmod_val a, ← ZMod.natCast_zmod_val u.1, ha₀, ← Nat.cast_mul,\n    ZMod.natCast_eq_natCast_iff, mul_comm _ d, Nat.ModEq]\n  simp only [hN₀, Nat.mul_mod_mul_left, Nat.mul_right_inj hd]\n  rw [← Nat.ModEq, ← ZMod.natCast_eq_natCast_iff, ← hu, natCast_val, castHom_apply]\n\n"}
