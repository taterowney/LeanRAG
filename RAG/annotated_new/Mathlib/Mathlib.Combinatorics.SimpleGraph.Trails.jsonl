{"name":"SimpleGraph.Walk.IsTrail.even_countP_edges_iff","module":"Mathlib.Combinatorics.SimpleGraph.Trails","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\np : G.Walk u v\nht : p.IsTrail\nx : V\n⊢ Iff (Even (List.countP (fun e => Decidable.decide (Membership.mem e x)) p.edges)) (Ne u v → And (Ne x u) (Ne x v))","decl":"theorem IsTrail.even_countP_edges_iff {u v : V} {p : G.Walk u v} (ht : p.IsTrail) (x : V) :\n    Even (p.edges.countP fun e => x ∈ e) ↔ u ≠ v → x ≠ u ∧ x ≠ v := by\n  induction' p with u u v w huv p ih\n  · simp\n  · rw [cons_isTrail_iff] at ht\n    specialize ih ht.1\n    simp only [List.countP_cons, Ne, edges_cons, Sym2.mem_iff]\n    split_ifs with h\n    · rw [decide_eq_true_eq] at h\n      obtain (rfl | rfl) := h\n      · rw [Nat.even_add_one, ih]\n        simp only [huv.ne, imp_false, Ne, not_false_iff, true_and, not_forall,\n          Classical.not_not, exists_prop, eq_self_iff_true, not_true, false_and,\n          and_iff_right_iff_imp]\n        rintro rfl rfl\n        exact G.loopless _ huv\n      · rw [Nat.even_add_one, ih, ← not_iff_not]\n        simp only [huv.ne.symm, Ne, eq_self_iff_true, not_true, false_and, not_forall,\n          not_false_iff, exists_prop, and_true, Classical.not_not, true_and, iff_and_self]\n        rintro rfl\n        exact huv.ne\n    · rw [decide_eq_true_eq, not_or] at h\n      simp only [h.1, h.2, not_false_iff, true_and, add_zero, Ne] at ih ⊢\n      rw [ih]\n      constructor <;>\n        · rintro h' h'' rfl\n          simp only [imp_false, eq_self_iff_true, not_true, Classical.not_not] at h'\n          cases h'\n          simp only [not_true, and_false, false_and] at h\n\n"}
{"name":"SimpleGraph.Walk.IsEulerian.isTrail","module":"Mathlib.Combinatorics.SimpleGraph.Trails","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\np : G.Walk u v\nh : p.IsEulerian\n⊢ p.IsTrail","decl":"theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail := by\n  rw [isTrail_def, List.nodup_iff_count_le_one]\n  intro e\n  by_cases he : e ∈ p.edges\n  · exact (h e (edges_subset_edgeSet _ he)).le\n  · simp [List.count_eq_zero_of_not_mem he]\n\n"}
{"name":"SimpleGraph.Walk.IsEulerian.mem_edges_iff","module":"Mathlib.Combinatorics.SimpleGraph.Trails","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\np : G.Walk u v\nh : p.IsEulerian\ne : Sym2 V\n⊢ Iff (Membership.mem p.edges e) (Membership.mem G.edgeSet e)","decl":"theorem IsEulerian.mem_edges_iff {u v : V} {p : G.Walk u v} (h : p.IsEulerian) {e : Sym2 V} :\n    e ∈ p.edges ↔ e ∈ G.edgeSet :=\n  ⟨ fun h => p.edges_subset_edgeSet h\n  , fun he => by simpa [Nat.succ_le] using (h e he).ge ⟩\n\n"}
{"name":"SimpleGraph.Walk.IsTrail.isEulerian_of_forall_mem","module":"Mathlib.Combinatorics.SimpleGraph.Trails","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\np : G.Walk u v\nh : p.IsTrail\nhc : ∀ (e : Sym2 V), Membership.mem G.edgeSet e → Membership.mem p.edges e\n⊢ p.IsEulerian","decl":"theorem IsTrail.isEulerian_of_forall_mem {u v : V} {p : G.Walk u v} (h : p.IsTrail)\n    (hc : ∀ e, e ∈ G.edgeSet → e ∈ p.edges) : p.IsEulerian := fun e he =>\n  List.count_eq_one_of_mem h.edges_nodup (hc e he)\n\n"}
{"name":"SimpleGraph.Walk.isEulerian_iff","module":"Mathlib.Combinatorics.SimpleGraph.Trails","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\np : G.Walk u v\n⊢ Iff p.IsEulerian (And p.IsTrail (∀ (e : Sym2 V), Membership.mem G.edgeSet e → Membership.mem p.edges e))","decl":"theorem isEulerian_iff {u v : V} (p : G.Walk u v) :\n    p.IsEulerian ↔ p.IsTrail ∧ ∀ e, e ∈ G.edgeSet → e ∈ p.edges := by\n  constructor\n  · intro h\n    exact ⟨h.isTrail, fun _ => h.mem_edges_iff.mpr⟩\n  · rintro ⟨h, hl⟩\n    exact h.isEulerian_of_forall_mem hl\n\n"}
{"name":"SimpleGraph.Walk.IsEulerian.edgesFinset_eq","module":"Mathlib.Combinatorics.SimpleGraph.Trails","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝¹ : DecidableEq V\ninst✝ : Fintype ↑G.edgeSet\nu v : V\np : G.Walk u v\nh : p.IsEulerian\n⊢ Eq ⋯.edgesFinset G.edgeFinset","decl":"theorem IsEulerian.edgesFinset_eq [Fintype G.edgeSet] {u v : V} {p : G.Walk u v}\n    (h : p.IsEulerian) : h.isTrail.edgesFinset = G.edgeFinset := by\n  ext e\n  simp [h.mem_edges_iff]\n\n"}
{"name":"SimpleGraph.Walk.IsEulerian.even_degree_iff","module":"Mathlib.Combinatorics.SimpleGraph.Trails","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝² : DecidableEq V\nx u v : V\np : G.Walk u v\nht : p.IsEulerian\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\n⊢ Iff (Even (G.degree x)) (Ne u v → And (Ne x u) (Ne x v))","decl":"theorem IsEulerian.even_degree_iff {x u v : V} {p : G.Walk u v} (ht : p.IsEulerian) [Fintype V]\n    [DecidableRel G.Adj] : Even (G.degree x) ↔ u ≠ v → x ≠ u ∧ x ≠ v := by\n  convert ht.isTrail.even_countP_edges_iff x\n  rw [← Multiset.coe_countP, Multiset.countP_eq_card_filter, ← card_incidenceFinset_eq_degree]\n  change Multiset.card _ = _\n  congr 1\n  convert_to _ = (ht.isTrail.edgesFinset.filter (x ∈ ·)).val\n  have : Fintype G.edgeSet := fintypeEdgeSet ht\n  rw [ht.edgesFinset_eq, G.incidenceFinset_eq_filter x]\n\n"}
{"name":"SimpleGraph.Walk.IsEulerian.card_filter_odd_degree","module":"Mathlib.Combinatorics.SimpleGraph.Trails","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝² : DecidableEq V\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\nu v : V\np : G.Walk u v\nht : p.IsEulerian\ns : Finset V\nh : Eq s (Finset.filter (fun v => Odd (G.degree v)) Finset.univ)\n⊢ Or (Eq s.card 0) (Eq s.card 2)","decl":"theorem IsEulerian.card_filter_odd_degree [Fintype V] [DecidableRel G.Adj] {u v : V}\n    {p : G.Walk u v} (ht : p.IsEulerian) {s}\n    (h : s = (Finset.univ : Finset V).filter fun v => Odd (G.degree v)) :\n    s.card = 0 ∨ s.card = 2 := by\n  subst s\n  simp only [← Nat.not_even_iff_odd, Finset.card_eq_zero]\n  simp only [ht.even_degree_iff, Ne, not_forall, not_and, Classical.not_not, exists_prop]\n  obtain rfl | hn := eq_or_ne u v\n  · left\n    simp\n  · right\n    convert_to _ = ({u, v} : Finset V).card\n    · simp [hn]\n    · congr\n      ext x\n      simp [hn, imp_iff_not_or]\n\n"}
{"name":"SimpleGraph.Walk.IsEulerian.card_odd_degree","module":"Mathlib.Combinatorics.SimpleGraph.Trails","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝² : DecidableEq V\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\nu v : V\np : G.Walk u v\nht : p.IsEulerian\n⊢ Or (Eq (Fintype.card ↑(setOf fun v => Odd (G.degree v))) 0) (Eq (Fintype.card ↑(setOf fun v => Odd (G.degree v))) 2)","decl":"theorem IsEulerian.card_odd_degree [Fintype V] [DecidableRel G.Adj] {u v : V} {p : G.Walk u v}\n    (ht : p.IsEulerian) : Fintype.card { v : V | Odd (G.degree v) } = 0 ∨\n      Fintype.card { v : V | Odd (G.degree v) } = 2 := by\n  rw [← Set.toFinset_card]\n  apply IsEulerian.card_filter_odd_degree ht\n  ext v\n  simp\n\n"}
