{"name":"PNat.XgcdType.mk.injEq","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"wp✝ x✝ y✝ zp✝ ap✝ bp✝ wp x y zp ap bp : Nat\n⊢ Eq (Eq { wp := wp✝, x := x✝, y := y✝, zp := zp✝, ap := ap✝, bp := bp✝ } { wp := wp, x := x, y := y, zp := zp, ap := ap, bp := bp }) (And (Eq wp✝ wp) (And (Eq x✝ x) (And (Eq y✝ y) (And (Eq zp✝ zp) (And (Eq ap✝ ap) (Eq bp✝ bp))))))","decl":"/-- A term of `XgcdType` is a system of six naturals.  They should\n be thought of as representing the matrix\n [[w, x], [y, z]] = [[wp + 1, x], [y, zp + 1]]\n together with the vector [a, b] = [ap + 1, bp + 1].\n-/\nstructure XgcdType where\n  /-- `wp` is a variable which changes through the algorithm. -/\n  wp : ℕ\n  /-- `x` satisfies `a / d = w + x` at the final step. -/\n  x : ℕ\n  /-- `y` satisfies `b / d = z + y` at the final step. -/\n  y : ℕ\n  /-- `zp` is a variable which changes through the algorithm. -/\n  zp : ℕ\n  /-- `ap` is a variable which changes through the algorithm. -/\n  ap : ℕ\n  /-- `bp` is a variable which changes through the algorithm. -/\n  bp : ℕ\n  deriving Inhabited\n\n"}
{"name":"PNat.XgcdType.mk.sizeOf_spec","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"wp x y zp ap bp : Nat\n⊢ Eq (SizeOf.sizeOf { wp := wp, x := x, y := y, zp := zp, ap := ap, bp := bp }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf wp)) (SizeOf.sizeOf x)) (SizeOf.sizeOf y)) (SizeOf.sizeOf zp)) (SizeOf.sizeOf ap)) (SizeOf.sizeOf bp))","decl":"/-- A term of `XgcdType` is a system of six naturals.  They should\n be thought of as representing the matrix\n [[w, x], [y, z]] = [[wp + 1, x], [y, zp + 1]]\n together with the vector [a, b] = [ap + 1, bp + 1].\n-/\nstructure XgcdType where\n  /-- `wp` is a variable which changes through the algorithm. -/\n  wp : ℕ\n  /-- `x` satisfies `a / d = w + x` at the final step. -/\n  x : ℕ\n  /-- `y` satisfies `b / d = z + y` at the final step. -/\n  y : ℕ\n  /-- `zp` is a variable which changes through the algorithm. -/\n  zp : ℕ\n  /-- `ap` is a variable which changes through the algorithm. -/\n  ap : ℕ\n  /-- `bp` is a variable which changes through the algorithm. -/\n  bp : ℕ\n  deriving Inhabited\n\n"}
{"name":"PNat.XgcdType.mk.inj","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"wp✝ x✝¹ y✝ zp✝ ap✝ bp✝ wp x y zp ap bp : Nat\nx✝ : Eq { wp := wp✝, x := x✝¹, y := y✝, zp := zp✝, ap := ap✝, bp := bp✝ } { wp := wp, x := x, y := y, zp := zp, ap := ap, bp := bp }\n⊢ And (Eq wp✝ wp) (And (Eq x✝¹ x) (And (Eq y✝ y) (And (Eq zp✝ zp) (And (Eq ap✝ ap) (Eq bp✝ bp)))))","decl":"/-- A term of `XgcdType` is a system of six naturals.  They should\n be thought of as representing the matrix\n [[w, x], [y, z]] = [[wp + 1, x], [y, zp + 1]]\n together with the vector [a, b] = [ap + 1, bp + 1].\n-/\nstructure XgcdType where\n  /-- `wp` is a variable which changes through the algorithm. -/\n  wp : ℕ\n  /-- `x` satisfies `a / d = w + x` at the final step. -/\n  x : ℕ\n  /-- `y` satisfies `b / d = z + y` at the final step. -/\n  y : ℕ\n  /-- `zp` is a variable which changes through the algorithm. -/\n  zp : ℕ\n  /-- `ap` is a variable which changes through the algorithm. -/\n  ap : ℕ\n  /-- `bp` is a variable which changes through the algorithm. -/\n  bp : ℕ\n  deriving Inhabited\n\n"}
{"name":"PNat.XgcdType.v_eq_succ_vp","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\n⊢ Eq u.v (PNat.XgcdType.succ₂ u.vp)","decl":"theorem v_eq_succ_vp : u.v = succ₂ u.vp := by\n  ext <;> dsimp [v, vp, w, z, a, b, succ₂] <;> ring_nf\n\n"}
{"name":"PNat.XgcdType.isSpecial_iff","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\n⊢ Iff u.IsSpecial u.IsSpecial'","decl":"theorem isSpecial_iff : u.IsSpecial ↔ u.IsSpecial' := by\n  dsimp [IsSpecial, IsSpecial']\n  let ⟨wp, x, y, zp, ap, bp⟩ := u\n  constructor <;> intro h <;> simp only [w, succPNat, succ_eq_add_one, z] at * <;>\n    simp only [← coe_inj, mul_coe, mk_coe] at *\n  · simp_all [← h]; ring\n  · simp [Nat.mul_add, Nat.add_mul, ← Nat.add_assoc] at h; rw [← h]; ring\n  -- Porting note: Old code has been removed as it was much more longer.\n\n"}
{"name":"PNat.XgcdType.isReduced_iff","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\n⊢ Iff u.IsReduced u.IsReduced'","decl":"theorem isReduced_iff : u.IsReduced ↔ u.IsReduced' :=\n  succPNat_inj.symm\n\n"}
{"name":"PNat.XgcdType.flip_w","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\n⊢ Eq u.flip.w u.z","decl":"@[simp]\ntheorem flip_w : (flip u).w = u.z :=\n  rfl\n\n"}
{"name":"PNat.XgcdType.flip_x","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\n⊢ Eq u.flip.x u.y","decl":"@[simp]\ntheorem flip_x : (flip u).x = u.y :=\n  rfl\n\n"}
{"name":"PNat.XgcdType.flip_y","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\n⊢ Eq u.flip.y u.x","decl":"@[simp]\ntheorem flip_y : (flip u).y = u.x :=\n  rfl\n\n"}
{"name":"PNat.XgcdType.flip_z","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\n⊢ Eq u.flip.z u.w","decl":"@[simp]\ntheorem flip_z : (flip u).z = u.w :=\n  rfl\n\n"}
{"name":"PNat.XgcdType.flip_a","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\n⊢ Eq u.flip.a u.b","decl":"@[simp]\ntheorem flip_a : (flip u).a = u.b :=\n  rfl\n\n"}
{"name":"PNat.XgcdType.flip_b","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\n⊢ Eq u.flip.b u.a","decl":"@[simp]\ntheorem flip_b : (flip u).b = u.a :=\n  rfl\n\n"}
{"name":"PNat.XgcdType.flip_isReduced","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\n⊢ Iff u.flip.IsReduced u.IsReduced","decl":"theorem flip_isReduced : (flip u).IsReduced ↔ u.IsReduced := by\n  dsimp [IsReduced, flip]\n  constructor <;> intro h <;> exact h.symm\n\n"}
{"name":"PNat.XgcdType.flip_isSpecial","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\n⊢ Iff u.flip.IsSpecial u.IsSpecial","decl":"theorem flip_isSpecial : (flip u).IsSpecial ↔ u.IsSpecial := by\n  dsimp [IsSpecial, flip]\n  rw [mul_comm u.x, mul_comm u.zp, add_comm u.zp]\n\n"}
{"name":"PNat.XgcdType.flip_v","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\n⊢ Eq u.flip.v u.v.swap","decl":"theorem flip_v : (flip u).v = u.v.swap := by\n  dsimp [v]\n  ext\n  · simp only\n    ring\n  · simp only\n    ring\n\n"}
{"name":"PNat.XgcdType.rq_eq","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\n⊢ Eq (HAdd.hAdd u.r (HMul.hMul (HAdd.hAdd u.bp 1) u.q)) (HAdd.hAdd u.ap 1)","decl":"/-- Properties of division with remainder for a / b. -/\ntheorem rq_eq : u.r + (u.bp + 1) * u.q = u.ap + 1 :=\n  Nat.mod_add_div (u.ap + 1) (u.bp + 1)\n\n"}
{"name":"PNat.XgcdType.qp_eq","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\nhr : Eq u.r 0\n⊢ Eq u.q (HAdd.hAdd u.qp 1)","decl":"theorem qp_eq (hr : u.r = 0) : u.q = u.qp + 1 := by\n  by_cases hq : u.q = 0\n  · let h := u.rq_eq\n    rw [hr, hq, mul_zero, add_zero] at h\n    cases h\n  · exact (Nat.succ_pred_eq_of_pos (Nat.pos_of_ne_zero hq)).symm\n\n"}
{"name":"PNat.XgcdType.start_isSpecial","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"a b : PNat\n⊢ (PNat.XgcdType.start a b).IsSpecial","decl":"theorem start_isSpecial (a b : ℕ+) : (start a b).IsSpecial := by\n  dsimp [start, IsSpecial]\n\n"}
{"name":"PNat.XgcdType.start_v","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"a b : PNat\n⊢ Eq (PNat.XgcdType.start a b).v { fst := ↑a, snd := ↑b }","decl":"theorem start_v (a b : ℕ+) : (start a b).v = ⟨a, b⟩ := by\n  dsimp [start, v, XgcdType.a, XgcdType.b, w, z]\n  rw [one_mul, one_mul, zero_mul, zero_mul]\n  have := a.pos\n  have := b.pos\n  congr <;> omega\n\n"}
{"name":"PNat.XgcdType.finish_isReduced","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\n⊢ u.finish.IsReduced","decl":"theorem finish_isReduced : u.finish.IsReduced := by\n  dsimp [IsReduced]\n  rfl\n\n"}
{"name":"PNat.XgcdType.finish_isSpecial","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\nhs : u.IsSpecial\n⊢ u.finish.IsSpecial","decl":"theorem finish_isSpecial (hs : u.IsSpecial) : u.finish.IsSpecial := by\n  dsimp [IsSpecial, finish] at hs ⊢\n  rw [add_mul _ _ u.y, add_comm _ (u.x * u.y), ← hs]\n  ring\n\n"}
{"name":"PNat.XgcdType.finish_v","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\nhr : Eq u.r 0\n⊢ Eq u.finish.v u.v","decl":"theorem finish_v (hr : u.r = 0) : u.finish.v = u.v := by\n  let ha : u.r + u.b * u.q = u.a := u.rq_eq\n  rw [hr, zero_add] at ha\n  ext\n  · change (u.wp + 1) * u.b + ((u.wp + 1) * u.qp + u.x) * u.b = u.w * u.a + u.x * u.b\n    have : u.wp + 1 = u.w := rfl\n    rw [this, ← ha, u.qp_eq hr]\n    ring\n  · change u.y * u.b + (u.y * u.qp + u.z) * u.b = u.y * u.a + u.z * u.b\n    rw [← ha, u.qp_eq hr]\n    ring\n\n"}
{"name":"PNat.XgcdType.step_wf","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\nhr : Ne u.r 0\n⊢ LT.lt (SizeOf.sizeOf u.step) (SizeOf.sizeOf u)","decl":"/-- We will apply the above step recursively.  The following result\n is used to ensure that the process terminates. -/\ntheorem step_wf (hr : u.r ≠ 0) : SizeOf.sizeOf u.step < SizeOf.sizeOf u := by\n  change u.r - 1 < u.bp\n  have h₀ : u.r - 1 + 1 = u.r := Nat.succ_pred_eq_of_pos (Nat.pos_of_ne_zero hr)\n  have h₁ : u.r < u.bp + 1 := Nat.mod_lt (u.ap + 1) u.bp.succ_pos\n  rw [← h₀] at h₁\n  exact lt_of_succ_lt_succ h₁\n\n"}
{"name":"PNat.XgcdType.step_isSpecial","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\nhs : u.IsSpecial\n⊢ u.step.IsSpecial","decl":"theorem step_isSpecial (hs : u.IsSpecial) : u.step.IsSpecial := by\n  dsimp [IsSpecial, step] at hs ⊢\n  rw [mul_add, mul_comm u.y u.x, ← hs]\n  ring\n\n"}
{"name":"PNat.XgcdType.step_v","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\nhr : Ne u.r 0\n⊢ Eq u.step.v u.v.swap","decl":"/-- The reduction step does not change the product vector. -/\ntheorem step_v (hr : u.r ≠ 0) : u.step.v = u.v.swap := by\n  let ha : u.r + u.b * u.q = u.a := u.rq_eq\n  let hr : u.r - 1 + 1 = u.r := (add_comm _ 1).trans (add_tsub_cancel_of_le (Nat.pos_of_ne_zero hr))\n  ext\n  · change ((u.y * u.q + u.z) * u.b + u.y * (u.r - 1 + 1) : ℕ) = u.y * u.a + u.z * u.b\n    rw [← ha, hr]\n    ring\n  · change ((u.w * u.q + u.x) * u.b + u.w * (u.r - 1 + 1) : ℕ) = u.w * u.a + u.x * u.b\n    rw [← ha, hr]\n    ring\n\n-- Porting note: removed 'have' and added decreasing_by to avoid lint errors\n"}
{"name":"PNat.XgcdType.reduce_a","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\nh : Eq u.r 0\n⊢ Eq u.reduce u.finish","decl":"theorem reduce_a {u : XgcdType} (h : u.r = 0) : u.reduce = u.finish := by\n  rw [reduce]\n  exact if_pos h\n\n"}
{"name":"PNat.XgcdType.reduce_b","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\nh : Ne u.r 0\n⊢ Eq u.reduce u.step.reduce.flip","decl":"theorem reduce_b {u : XgcdType} (h : u.r ≠ 0) : u.reduce = u.step.reduce.flip := by\n  rw [reduce]\n  exact if_neg h\n\n"}
{"name":"PNat.XgcdType.reduce_isReduced","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\n⊢ u.reduce.IsReduced","decl":"theorem reduce_isReduced : ∀ u : XgcdType, u.reduce.IsReduced\n  | u =>\n    dite (u.r = 0)\n      (fun h => by\n        rw [reduce_a h]\n        exact u.finish_isReduced)\n      fun h => by\n      have : SizeOf.sizeOf u.step < SizeOf.sizeOf u := u.step_wf h\n      rw [reduce_b h, flip_isReduced]\n      apply reduce_isReduced\n\n"}
{"name":"PNat.XgcdType.reduce_isReduced'","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\n⊢ u.reduce.IsReduced'","decl":"theorem reduce_isReduced' (u : XgcdType) : u.reduce.IsReduced' :=\n  (isReduced_iff _).mp u.reduce_isReduced\n\n"}
{"name":"PNat.XgcdType.reduce_isSpecial","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\na✝ : u.IsSpecial\n⊢ u.reduce.IsSpecial","decl":"theorem reduce_isSpecial : ∀ u : XgcdType, u.IsSpecial → u.reduce.IsSpecial\n  | u =>\n    dite (u.r = 0)\n      (fun h hs => by\n        rw [reduce_a h]\n        exact u.finish_isSpecial hs)\n      fun h hs => by\n      have : SizeOf.sizeOf u.step < SizeOf.sizeOf u := u.step_wf h\n      rw [reduce_b h]\n      exact (flip_isSpecial _).mpr (reduce_isSpecial _ (u.step_isSpecial hs))\n\n"}
{"name":"PNat.XgcdType.reduce_isSpecial'","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\nhs : u.IsSpecial\n⊢ u.reduce.IsSpecial'","decl":"theorem reduce_isSpecial' (u : XgcdType) (hs : u.IsSpecial) : u.reduce.IsSpecial' :=\n  (isSpecial_iff _).mp (u.reduce_isSpecial hs)\n\n"}
{"name":"PNat.XgcdType.reduce_v","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"u : PNat.XgcdType\n⊢ Eq u.reduce.v u.v","decl":"theorem reduce_v : ∀ u : XgcdType, u.reduce.v = u.v\n  | u =>\n    dite (u.r = 0) (fun h => by rw [reduce_a h, finish_v u h]) fun h => by\n      have : SizeOf.sizeOf u.step < SizeOf.sizeOf u := u.step_wf h\n      rw [reduce_b h, flip_v, reduce_v (step u), step_v u h, Prod.swap_swap]\n\n"}
{"name":"PNat.gcdA'_coe","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"a b : PNat\n⊢ Eq (↑(a.gcdA' b)) (HAdd.hAdd (↑(a.gcdW b)) (a.gcdX b))","decl":"theorem gcdA'_coe : (gcdA' a b : ℕ) = gcdW a b + gcdX a b := by\n  dsimp [gcdA', gcdX, gcdW, XgcdType.w]\n  rw [add_right_comm]\n\n"}
{"name":"PNat.gcdB'_coe","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"a b : PNat\n⊢ Eq (↑(a.gcdB' b)) (HAdd.hAdd (a.gcdY b) ↑(a.gcdZ b))","decl":"theorem gcdB'_coe : (gcdB' a b : ℕ) = gcdY a b + gcdZ a b := by\n  dsimp [gcdB', gcdY, gcdZ, XgcdType.z]\n  rw [add_assoc]\n\n"}
{"name":"PNat.gcd_props","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"a b : PNat\n⊢ let d := a.gcdD b;\n  let w := a.gcdW b;\n  let x := a.gcdX b;\n  let y := a.gcdY b;\n  let z := a.gcdZ b;\n  let a' := a.gcdA' b;\n  let b' := a.gcdB' b;\n  And (Eq (HMul.hMul w z) (HMul.hMul x y).succPNat) (And (Eq a (HMul.hMul a' d)) (And (Eq b (HMul.hMul b' d)) (And (Eq (HMul.hMul z a') (HMul.hMul x ↑b').succPNat) (And (Eq (HMul.hMul w b') (HMul.hMul y ↑a').succPNat) (And (Eq (HMul.hMul ↑z ↑a) (HAdd.hAdd (HMul.hMul x ↑b) ↑d)) (Eq (HMul.hMul ↑w ↑b) (HAdd.hAdd (HMul.hMul y ↑a) ↑d)))))))","decl":"theorem gcd_props :\n    let d := gcdD a b\n    let w := gcdW a b\n    let x := gcdX a b\n    let y := gcdY a b\n    let z := gcdZ a b\n    let a' := gcdA' a b\n    let b' := gcdB' a b\n    w * z = succPNat (x * y) ∧\n      a = a' * d ∧\n        b = b' * d ∧\n          z * a' = succPNat (x * b') ∧\n            w * b' = succPNat (y * a') ∧ (z * a : ℕ) = x * b + d ∧ (w * b : ℕ) = y * a + d := by\n  intros d w x y z a' b'\n  let u := XgcdType.start a b\n  let ur := u.reduce\n\n  have _ : d = ur.a := rfl\n  have hb : d = ur.b := u.reduce_isReduced'\n  have ha' : (a' : ℕ) = w + x := gcdA'_coe a b\n  have hb' : (b' : ℕ) = y + z := gcdB'_coe a b\n  have hdet : w * z = succPNat (x * y) := u.reduce_isSpecial' rfl\n  constructor\n  · exact hdet\n  have hdet' : (w * z : ℕ) = x * y + 1 := by rw [← mul_coe, hdet, succPNat_coe]\n  have _ : u.v = ⟨a, b⟩ := XgcdType.start_v a b\n  let hv : Prod.mk (w * d + x * ur.b : ℕ) (y * d + z * ur.b : ℕ) = ⟨a, b⟩ :=\n    u.reduce_v.trans (XgcdType.start_v a b)\n  rw [← hb, ← add_mul, ← add_mul, ← ha', ← hb'] at hv\n  have ha'' : (a : ℕ) = a' * d := (congr_arg Prod.fst hv).symm\n  have hb'' : (b : ℕ) = b' * d := (congr_arg Prod.snd hv).symm\n  constructor\n  · exact eq ha''\n  constructor\n  · exact eq hb''\n  have hza' : (z * a' : ℕ) = x * b' + 1 := by\n    rw [ha', hb', mul_add, mul_add, mul_comm (z : ℕ), hdet']\n    ring\n  have hwb' : (w * b' : ℕ) = y * a' + 1 := by\n    rw [ha', hb', mul_add, mul_add, hdet']\n    ring\n  constructor\n  · apply eq\n    rw [succPNat_coe, Nat.succ_eq_add_one, mul_coe, hza']\n  constructor\n  · apply eq\n    rw [succPNat_coe, Nat.succ_eq_add_one, mul_coe, hwb']\n  rw [ha'', hb'']\n  repeat rw [← @mul_assoc]\n  rw [hza', hwb']\n  constructor <;> ring\n\n"}
{"name":"PNat.gcd_eq","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"a b : PNat\n⊢ Eq (a.gcdD b) (a.gcd b)","decl":"theorem gcd_eq : gcdD a b = gcd a b := by\n  rcases gcd_props a b with ⟨_, h₁, h₂, _, _, h₅, _⟩\n  apply dvd_antisymm\n  · apply dvd_gcd\n    · exact Dvd.intro (gcdA' a b) (h₁.trans (mul_comm _ _)).symm\n    · exact Dvd.intro (gcdB' a b) (h₂.trans (mul_comm _ _)).symm\n  · have h₇ : (gcd a b : ℕ) ∣ gcdZ a b * a := (Nat.gcd_dvd_left a b).trans (dvd_mul_left _ _)\n    have h₈ : (gcd a b : ℕ) ∣ gcdX a b * b := (Nat.gcd_dvd_right a b).trans (dvd_mul_left _ _)\n    rw [h₅] at h₇\n    rw [dvd_iff]\n    exact (Nat.dvd_add_iff_right h₈).mpr h₇\n\n"}
{"name":"PNat.gcd_det_eq","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"a b : PNat\n⊢ Eq (HMul.hMul (a.gcdW b) (a.gcdZ b)) (HMul.hMul (a.gcdX b) (a.gcdY b)).succPNat","decl":"theorem gcd_det_eq : gcdW a b * gcdZ a b = succPNat (gcdX a b * gcdY a b) :=\n  (gcd_props a b).1\n\n"}
{"name":"PNat.gcd_a_eq","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"a b : PNat\n⊢ Eq a (HMul.hMul (a.gcdA' b) (a.gcd b))","decl":"theorem gcd_a_eq : a = gcdA' a b * gcd a b :=\n  gcd_eq a b ▸ (gcd_props a b).2.1\n\n"}
{"name":"PNat.gcd_b_eq","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"a b : PNat\n⊢ Eq b (HMul.hMul (a.gcdB' b) (a.gcd b))","decl":"theorem gcd_b_eq : b = gcdB' a b * gcd a b :=\n  gcd_eq a b ▸ (gcd_props a b).2.2.1\n\n"}
{"name":"PNat.gcd_rel_left'","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"a b : PNat\n⊢ Eq (HMul.hMul (a.gcdZ b) (a.gcdA' b)) (HMul.hMul (a.gcdX b) ↑(a.gcdB' b)).succPNat","decl":"theorem gcd_rel_left' : gcdZ a b * gcdA' a b = succPNat (gcdX a b * gcdB' a b) :=\n  (gcd_props a b).2.2.2.1\n\n"}
{"name":"PNat.gcd_rel_right'","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"a b : PNat\n⊢ Eq (HMul.hMul (a.gcdW b) (a.gcdB' b)) (HMul.hMul (a.gcdY b) ↑(a.gcdA' b)).succPNat","decl":"theorem gcd_rel_right' : gcdW a b * gcdB' a b = succPNat (gcdY a b * gcdA' a b) :=\n  (gcd_props a b).2.2.2.2.1\n\n"}
{"name":"PNat.gcd_rel_left","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"a b : PNat\n⊢ Eq (HMul.hMul ↑(a.gcdZ b) ↑a) (HAdd.hAdd (HMul.hMul (a.gcdX b) ↑b) ↑(a.gcd b))","decl":"theorem gcd_rel_left : (gcdZ a b * a : ℕ) = gcdX a b * b + gcd a b :=\n  gcd_eq a b ▸ (gcd_props a b).2.2.2.2.2.1\n\n"}
{"name":"PNat.gcd_rel_right","module":"Mathlib.Data.PNat.Xgcd","initialProofState":"a b : PNat\n⊢ Eq (HMul.hMul ↑(a.gcdW b) ↑b) (HAdd.hAdd (HMul.hMul (a.gcdY b) ↑a) ↑(a.gcd b))","decl":"theorem gcd_rel_right : (gcdW a b * b : ℕ) = gcdY a b * a + gcd a b :=\n  gcd_eq a b ▸ (gcd_props a b).2.2.2.2.2.2\n\n"}
