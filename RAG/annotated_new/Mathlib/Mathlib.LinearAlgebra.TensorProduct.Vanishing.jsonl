{"name":"TensorProduct.VanishesTrivially.of_fintype","module":"Mathlib.LinearAlgebra.TensorProduct.Vanishing","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nM : Type u_2\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\nι : Type u_4\ninst✝¹ : Fintype ι\nm : ι → M\nn : ι → N\nκ : Type u_5\ninst✝ : Fintype κ\na : ι → κ → R\ny : κ → N\nhay : ∀ (i : ι), Eq (n i) (Finset.univ.sum fun j => HSMul.hSMul (a i j) (y j))\nham : ∀ (j : κ), Eq (Finset.univ.sum fun i => HSMul.hSMul (a i j) (m i)) 0\n⊢ TensorProduct.VanishesTrivially R m n","decl":"theorem VanishesTrivially.of_fintype {κ} [Fintype κ] (a : ι → κ → R) (y : κ → N)\n    (hay : ∀ i, n i = ∑ j, a i j • y j) (ham : ∀ j, ∑ i, a i j • m i = 0) :\n    VanishesTrivially R m n :=\n  have e := (Fintype.equivFin κ).symm\n  ⟨Fintype.card κ, (a · ∘ e), y ∘ e, by simpa only [← e.sum_comp] using hay, by\n    rwa [← e.forall_congr_right] at ham⟩\n\n"}
{"name":"Equiv.vanishesTrivially_comp","module":"Mathlib.LinearAlgebra.TensorProduct.Vanishing","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nM : Type u_2\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\nι : Type u_4\ninst✝¹ : Fintype ι\nm : ι → M\nn : ι → N\nκ : Type u_5\ninst✝ : Fintype κ\ne : Equiv κ ι\n⊢ Iff (TensorProduct.VanishesTrivially R (Function.comp m ⇑e) (Function.comp n ⇑e)) (TensorProduct.VanishesTrivially R m n)","decl":"theorem _root_.Equiv.vanishesTrivially_comp {κ} [Fintype κ] (e : κ ≃ ι) :\n    VanishesTrivially R (m ∘ e) (n ∘ e) ↔ VanishesTrivially R m n := by\n  simp [VanishesTrivially, ← e.forall_congr_right,\n    ← (e.arrowCongr (.refl _)).exists_congr_right, ← e.sum_comp]\n\n"}
{"name":"TensorProduct.sum_tmul_eq_zero_of_vanishesTrivially","module":"Mathlib.LinearAlgebra.TensorProduct.Vanishing","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nM : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nN : Type u_3\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nι : Type u_4\ninst✝ : Fintype ι\nm : ι → M\nn : ι → N\nhmn : TensorProduct.VanishesTrivially R m n\n⊢ Eq (Finset.univ.sum fun i => TensorProduct.tmul R (m i) (n i)) 0","decl":"/-- **Equational criterion for vanishing**\n[A. Altman and S. Kleiman, *A term of commutative algebra* (Lemma 8.16)][altman2021term],\nbackward direction.\n\nIf the expression $\\sum_i m_i \\otimes n_i$ vanishes trivially, then it vanishes.\nThat is, $\\sum_i m_i \\otimes n_i = 0$. -/\ntheorem sum_tmul_eq_zero_of_vanishesTrivially (hmn : VanishesTrivially R m n) :\n    ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) := by\n  obtain ⟨k, a, y, h₁, h₂⟩ := hmn\n  simp_rw [h₁, tmul_sum, tmul_smul]\n  rw [Finset.sum_comm]\n  simp_rw [← tmul_smul, ← smul_tmul, ← sum_tmul, h₂, zero_tmul, Finset.sum_const_zero]\n\n"}
{"name":"TensorProduct.vanishesTrivially_of_sum_tmul_eq_zero","module":"Mathlib.LinearAlgebra.TensorProduct.Vanishing","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nM : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nN : Type u_3\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nι : Type u_4\ninst✝ : Fintype ι\nm : ι → M\nn : ι → N\nhm : Eq (Submodule.span R (Set.range m)) Top.top\nhmn : Eq (Finset.univ.sum fun i => TensorProduct.tmul R (m i) (n i)) 0\n⊢ TensorProduct.VanishesTrivially R m n","decl":"/-- **Equational criterion for vanishing**\n[A. Altman and S. Kleiman, *A term of commutative algebra* (Lemma 8.16)][altman2021term],\nforward direction.\n\nAssume that the $m_i$ generate $M$. If the expression $\\sum_i m_i \\otimes n_i$\nvanishes, then it vanishes trivially. -/\ntheorem vanishesTrivially_of_sum_tmul_eq_zero (hm : Submodule.span R (Set.range m) = ⊤)\n    (hmn : ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N)) : VanishesTrivially R m n := by\n  -- Define a map $G \\colon R^\\iota \\to M$ whose matrix entries are the $m_i$. It is surjective.\n  set G : (ι →₀ R) →ₗ[R] M := Finsupp.linearCombination R m with hG\n  have G_basis_eq (i : ι) : G (Finsupp.single i 1) = m i := by simp [hG, toModule_lof]\n  have G_surjective : Surjective G := by\n    apply LinearMap.range_eq_top.mp\n    apply top_le_iff.mp\n    rw [← hm]\n    apply Submodule.span_le.mpr\n    rintro _ ⟨i, rfl⟩\n    use Finsupp.single i 1, G_basis_eq i\n  /- Consider the element $\\sum_i e_i \\otimes n_i$ of $R^\\iota \\otimes N$. It is in the kernel of\n  $R^\\iota \\otimes N \\to M \\otimes N$. -/\n  set en : (ι →₀ R) ⊗[R] N := ∑ i, Finsupp.single i 1 ⊗ₜ n i with hen\n  have en_mem_ker : en ∈ ker (rTensor N G) := by simp [hen, G_basis_eq, hmn]\n  -- We have an exact sequence $\\ker G \\to R^\\iota \\to M \\to 0$.\n  have exact_ker_subtype : Exact (ker G).subtype G := G.exact_subtype_ker_map\n  -- Tensor the exact sequence with $N$.\n  have exact_rTensor_ker_subtype : Exact (rTensor N (ker G).subtype) (rTensor N G) :=\n    rTensor_exact (M := ↥(ker G)) N exact_ker_subtype G_surjective\n  /- We conclude that $\\sum_i e_i \\otimes n_i$ is in the range of\n    $\\ker G \\otimes N \\to R^\\iota \\otimes N$. -/\n  have en_mem_range : en ∈ range (rTensor N (ker G).subtype) :=\n    exact_rTensor_ker_subtype.linearMap_ker_eq ▸ en_mem_ker\n  /- There is an element of in $\\ker G \\otimes N$ that maps to $\\sum_i e_i \\otimes n_i$.\n  Write it as a finite sum of pure tensors. -/\n  obtain ⟨kn, hkn⟩ := en_mem_range\n  obtain ⟨ma, rfl : kn = ∑ kj ∈ ma, kj.1 ⊗ₜ[R] kj.2⟩ := exists_finset kn\n  /- Let $\\sum_j k_j \\otimes y_j$ be the sum obtained in the previous step.\n  In order to show that $\\sum_i m_i \\otimes n_i$ vanishes trivially, it suffices to prove that there\n  exist $(a_{ij})_{i, j}$ such that for all $i$,\n  $$n_i = \\sum_j a_{ij} y_j$$\n  and for all $j$,\n  $$\\sum_i a_{ij} m_i = 0.$$\n  For this, take $a_{ij}$ to be the coefficient of $e_i$ in $k_j$. -/\n  refine .of_fintype (κ := ma) (fun i ⟨⟨kj, _⟩, _⟩ ↦ (kj : ι →₀ R) i) (fun ⟨⟨_, yj⟩, _⟩ ↦ yj) ?_ ?_\n  · intro i\n    classical\n    apply_fun finsuppScalarLeft R N ι at hkn\n    apply_fun (· i) at hkn\n    symm at hkn\n    simp only [map_sum, finsuppScalarLeft_apply_tmul, zero_smul, Finsupp.single_zero,\n      Finsupp.sum_single_index, one_smul, Finsupp.finset_sum_apply, Finsupp.single_apply,\n      Finset.sum_ite_eq', Finset.mem_univ, ↓reduceIte, rTensor_tmul, coe_subtype, Finsupp.sum_apply,\n      Finsupp.sum_ite_eq', Finsupp.mem_support_iff, ne_eq, ite_not, en] at hkn\n    simp only [Finset.univ_eq_attach, Finset.sum_attach ma (fun x ↦ (x.1 : ι →₀ R) i • x.2)]\n    convert hkn using 2 with x _\n    split\n    · next h'x => rw [h'x, zero_smul]\n    · rfl\n  · rintro ⟨⟨⟨k, hk⟩, _⟩, _⟩\n    simpa only [hG, linearCombination_apply, zero_smul, implies_true, Finsupp.sum_fintype] using\n      mem_ker.mp hk\n\n"}
{"name":"TensorProduct.vanishesTrivially_iff_sum_tmul_eq_zero","module":"Mathlib.LinearAlgebra.TensorProduct.Vanishing","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nM : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nN : Type u_3\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nι : Type u_4\ninst✝ : Fintype ι\nm : ι → M\nn : ι → N\nhm : Eq (Submodule.span R (Set.range m)) Top.top\n⊢ Iff (TensorProduct.VanishesTrivially R m n) (Eq (Finset.univ.sum fun i => TensorProduct.tmul R (m i) (n i)) 0)","decl":"/-- **Equational criterion for vanishing**\n[A. Altman and S. Kleiman, *A term of commutative algebra* (Lemma 8.16)][altman2021term].\n\nAssume that the $m_i$ generate $M$. Then the expression $\\sum_i m_i \\otimes n_i$ vanishes\ntrivially if and only if it vanishes. -/\ntheorem vanishesTrivially_iff_sum_tmul_eq_zero (hm : Submodule.span R (Set.range m) = ⊤) :\n    VanishesTrivially R m n ↔ ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) :=\n  ⟨sum_tmul_eq_zero_of_vanishesTrivially R, vanishesTrivially_of_sum_tmul_eq_zero R hm⟩\n\n"}
{"name":"TensorProduct.vanishesTrivially_of_sum_tmul_eq_zero_of_rTensor_injective","module":"Mathlib.LinearAlgebra.TensorProduct.Vanishing","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nM : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nN : Type u_3\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nι : Type u_4\ninst✝ : Fintype ι\nm : ι → M\nn : ι → N\nhm : Function.Injective ⇑(LinearMap.rTensor N (Submodule.span R (Set.range m)).subtype)\nhmn : Eq (Finset.univ.sum fun i => TensorProduct.tmul R (m i) (n i)) 0\n⊢ TensorProduct.VanishesTrivially R m n","decl":"/-- **Equational criterion for vanishing**\n[A. Altman and S. Kleiman, *A term of commutative algebra* (Lemma 8.16)][altman2021term],\nforward direction, generalization.\n\nAssume that the submodule $M' \\subseteq M$ generated by the $m_i$\nsatisfies the property that the map $M' \\otimes N \\to M \\otimes N$ is injective. If the expression\n$\\sum_i m_i \\otimes n_i$ vanishes, then it vanishes trivially. -/\ntheorem vanishesTrivially_of_sum_tmul_eq_zero_of_rTensor_injective\n    (hm : Injective (rTensor N (span R (Set.range m)).subtype))\n    (hmn : ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N)) : VanishesTrivially R m n := by\n  -- Restrict `m` on the codomain to $M'$, then apply `vanishesTrivially_of_sum_tmul_eq_zero`.\n  have mem_M' i : m i ∈ span R (Set.range m) := subset_span ⟨i, rfl⟩\n  set m' : ι → span R (Set.range m) := Subtype.coind m mem_M' with m'_eq\n  have hm' : span R (Set.range m') = ⊤ := by\n    apply map_injective_of_injective (injective_subtype (span R (Set.range m)))\n    rw [Submodule.map_span, Submodule.map_top, range_subtype, coe_subtype, ← Set.range_comp]\n    rfl\n  have hm'n : ∑ i, m' i ⊗ₜ n i = (0 : span R (Set.range m) ⊗[R] N) := by\n    apply hm\n    simp only [m'_eq, map_sum, rTensor_tmul, coe_subtype, Subtype.coind_coe, _root_.map_zero, hmn]\n  have : VanishesTrivially R m' n := vanishesTrivially_of_sum_tmul_eq_zero R hm' hm'n\n  unfold VanishesTrivially at this ⊢\n  convert this with κ _ a y j\n  convert (injective_iff_map_eq_zero' _).mp (injective_subtype (span R (Set.range m))) _\n  simp [m'_eq]\n\n"}
{"name":"TensorProduct.vanishesTrivially_iff_sum_tmul_eq_zero_of_rTensor_injective","module":"Mathlib.LinearAlgebra.TensorProduct.Vanishing","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nM : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nN : Type u_3\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nι : Type u_4\ninst✝ : Fintype ι\nm : ι → M\nn : ι → N\nhm : Function.Injective ⇑(LinearMap.rTensor N (Submodule.span R (Set.range m)).subtype)\n⊢ Iff (TensorProduct.VanishesTrivially R m n) (Eq (Finset.univ.sum fun i => TensorProduct.tmul R (m i) (n i)) 0)","decl":"/-- **Equational criterion for vanishing**\n[A. Altman and S. Kleiman, *A term of commutative algebra* (Lemma 8.16)][altman2021term],\ngeneralization.\n\nAssume that the submodule $M' \\subseteq M$ generated by the $m_i$ satisfies the\nproperty that the map $M' \\otimes N \\to M \\otimes N$ is injective. Then the expression\n$\\sum_i m_i \\otimes n_i$ vanishes trivially if and only if it vanishes. -/\ntheorem vanishesTrivially_iff_sum_tmul_eq_zero_of_rTensor_injective\n    (hm : Injective (rTensor N (span R (Set.range m)).subtype)) :\n    VanishesTrivially R m n ↔ ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) :=\n  ⟨sum_tmul_eq_zero_of_vanishesTrivially R,\n    vanishesTrivially_of_sum_tmul_eq_zero_of_rTensor_injective R hm⟩\n\n"}
{"name":"TensorProduct.rTensor_injective_of_forall_vanishesTrivially","module":"Mathlib.LinearAlgebra.TensorProduct.Vanishing","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nhMN : ∀ {l : Nat} {m : Fin l → M} {n : Fin l → N}, Eq (Finset.univ.sum fun i => TensorProduct.tmul R (m i) (n i)) 0 → TensorProduct.VanishesTrivially R m n\nM' : Submodule R M\n⊢ Function.Injective ⇑(LinearMap.rTensor N M'.subtype)","decl":"/-- Converse of `TensorProduct.vanishesTrivially_of_sum_tmul_eq_zero_of_rTensor_injective`.\n\nAssume that every expression $\\sum_i m_i \\otimes n_i$ which vanishes also vanishes trivially.\nThen, for every submodule $M' \\subseteq M$, the map $M' \\otimes N \\to M \\otimes N$ is injective. -/\ntheorem rTensor_injective_of_forall_vanishesTrivially\n    (hMN : ∀ {l : ℕ} {m : Fin l → M} {n : Fin l → N},\n      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n)\n    (M' : Submodule R M) : Injective (rTensor N M'.subtype) := by\n  apply (injective_iff_map_eq_zero _).mpr\n  rintro x hx\n  obtain ⟨s, rfl⟩ := exists_finset x\n  rw [← Finset.sum_attach]\n  apply sum_tmul_eq_zero_of_vanishesTrivially\n  simp only [map_sum, rTensor_tmul, coe_subtype] at hx\n  have e := (Fintype.equivFin s).symm\n  rw [← Finset.sum_coe_sort, ← e.sum_comp] at hx\n  have := hMN hx\n  rw [← e.vanishesTrivially_comp]\n  unfold VanishesTrivially at this ⊢\n  convert this\n  symm\n  convert (injective_iff_map_eq_zero' _).mp (injective_subtype M') _\n  simp\n\n"}
{"name":"TensorProduct.forall_vanishesTrivially_iff_forall_rTensor_injective","module":"Mathlib.LinearAlgebra.TensorProduct.Vanishing","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\n⊢ Iff (∀ {l : Nat} {m : Fin l → M} {n : Fin l → N}, Eq (Finset.univ.sum fun i => TensorProduct.tmul R (m i) (n i)) 0 → TensorProduct.VanishesTrivially R m n) (∀ (M' : Submodule R M), Function.Injective ⇑(LinearMap.rTensor N M'.subtype))","decl":"/-- Every expression $\\sum_i m_i \\otimes n_i$ which vanishes also vanishes trivially if and only if\nfor every submodule $M' \\subseteq M$, the map $M' \\otimes N \\to M \\otimes N$ is injective. -/\ntheorem forall_vanishesTrivially_iff_forall_rTensor_injective :\n    (∀ {l : ℕ} {m : Fin l → M} {n : Fin l → N},\n      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔\n    ∀ M' : Submodule R M, Injective (rTensor N M'.subtype) := by\n  constructor\n  · intro h\n    exact rTensor_injective_of_forall_vanishesTrivially R h\n  · intro h k m n hmn\n    exact vanishesTrivially_of_sum_tmul_eq_zero_of_rTensor_injective R (h _) hmn\n\n"}
{"name":"TensorProduct.forall_vanishesTrivially_iff_forall_fg_rTensor_injective","module":"Mathlib.LinearAlgebra.TensorProduct.Vanishing","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\n⊢ Iff (∀ {l : Nat} {m : Fin l → M} {n : Fin l → N}, Eq (Finset.univ.sum fun i => TensorProduct.tmul R (m i) (n i)) 0 → TensorProduct.VanishesTrivially R m n) (∀ (M' : Submodule R M), M'.FG → Function.Injective ⇑(LinearMap.rTensor N M'.subtype))","decl":"/-- Every expression $\\sum_i m_i \\otimes n_i$ which vanishes also vanishes trivially if and only if\nfor every finitely generated submodule $M' \\subseteq M$, the map $M' \\otimes N \\to M \\otimes N$ is\ninjective. -/\ntheorem forall_vanishesTrivially_iff_forall_fg_rTensor_injective :\n    (∀ {l : ℕ} {m : Fin l → M} {n : Fin l → N},\n      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔\n    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by\n  constructor\n  · intro h M' _\n    exact rTensor_injective_of_forall_vanishesTrivially R h M'\n  · intro h k m n hmn\n    exact vanishesTrivially_of_sum_tmul_eq_zero_of_rTensor_injective R\n      (h _ (fg_span (Set.finite_range _))) hmn\n\n"}
{"name":"TensorProduct.rTensor_injective_of_forall_fg_rTensor_injective","module":"Mathlib.LinearAlgebra.TensorProduct.Vanishing","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nhMN : ∀ (M' : Submodule R M), M'.FG → Function.Injective ⇑(LinearMap.rTensor N M'.subtype)\nM' : Submodule R M\n⊢ Function.Injective ⇑(LinearMap.rTensor N M'.subtype)","decl":"/-- If the map $M' \\otimes N \\to M \\otimes N$ is injective for every finitely generated submodule\n$M' \\subseteq M$, then it is in fact injective for every submodule $M' \\subseteq M$. -/\ntheorem rTensor_injective_of_forall_fg_rTensor_injective\n    (hMN : ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype))\n    (M' : Submodule R M) : Injective (rTensor N M'.subtype) :=\n  (forall_vanishesTrivially_iff_forall_rTensor_injective R).mp\n    ((forall_vanishesTrivially_iff_forall_fg_rTensor_injective R).mpr hMN) M'\n\n"}
{"name":"TensorProduct.forall_vanishesTrivially_iff_forall_FG_rTensor_injective","module":"Mathlib.LinearAlgebra.TensorProduct.Vanishing","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\n⊢ Iff (∀ {l : Nat} {m : Fin l → M} {n : Fin l → N}, Eq (Finset.univ.sum fun i => TensorProduct.tmul R (m i) (n i)) 0 → TensorProduct.VanishesTrivially R m n) (∀ (M' : Submodule R M), M'.FG → Function.Injective ⇑(LinearMap.rTensor N M'.subtype))","decl":"@[deprecated (since := \"2025-01-03\")] alias forall_vanishesTrivially_iff_forall_FG_rTensor_injective\n  := forall_vanishesTrivially_iff_forall_fg_rTensor_injective\n"}
{"name":"TensorProduct.rTensor_injective_of_forall_FG_rTensor_injective","module":"Mathlib.LinearAlgebra.TensorProduct.Vanishing","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nhMN : ∀ (M' : Submodule R M), M'.FG → Function.Injective ⇑(LinearMap.rTensor N M'.subtype)\nM' : Submodule R M\n⊢ Function.Injective ⇑(LinearMap.rTensor N M'.subtype)","decl":"@[deprecated (since := \"2025-01-03\")] alias rTensor_injective_of_forall_FG_rTensor_injective :=\n  rTensor_injective_of_forall_fg_rTensor_injective\n\n"}
