{"name":"CategoryTheory.coherentTopology.instIsCoverDense","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Precoherent D\n⊢ F.IsCoverDense (CategoryTheory.coherentTopology D)","decl":"instance : F.IsCoverDense (coherentTopology _) := by\n  refine F.isCoverDense_of_generate_singleton_functor_π_mem _ fun B ↦ ⟨_, F.effectiveEpiOver B, ?_⟩\n  apply Coverage.Saturate.of\n  refine ⟨Unit, inferInstance, fun _ => F.effectiveEpiOverObj B,\n    fun _ => F.effectiveEpiOver B, ?_ , ?_⟩\n  · funext; ext -- Do we want `Presieve.ext`?\n    refine ⟨fun ⟨⟩ ↦ ⟨()⟩, ?_⟩\n    rintro ⟨⟩\n    simp\n  · rw [← effectiveEpi_iff_effectiveEpiFamily]\n    infer_instance\n\n"}
{"name":"CategoryTheory.coherentTopology.exists_effectiveEpiFamily_iff_mem_induced","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝⁵ : F.PreservesFiniteEffectiveEpiFamilies\ninst✝⁴ : F.ReflectsFiniteEffectiveEpiFamilies\ninst✝³ : F.Full\ninst✝² : F.Faithful\ninst✝¹ : F.EffectivelyEnough\ninst✝ : CategoryTheory.Precoherent D\nX : C\nS : CategoryTheory.Sieve X\n⊢ Iff (Exists fun α => Exists fun x => Exists fun Y => Exists fun π => And (CategoryTheory.EffectiveEpiFamily Y π) (∀ (a : α), S.arrows (π a))) (Membership.mem ((F.inducedTopology (CategoryTheory.coherentTopology D)) X) S)","decl":"theorem exists_effectiveEpiFamily_iff_mem_induced (X : C) (S : Sieve X) :\n    (∃ (α : Type) (_ : Finite α) (Y : α → C) (π : (a : α) → (Y a ⟶ X)),\n      EffectiveEpiFamily Y π ∧ (∀ a : α, (S.arrows) (π a)) ) ↔\n    (S ∈ F.inducedTopology (coherentTopology _) X) := by\n  refine ⟨fun ⟨α, _, Y, π, ⟨H₁, H₂⟩⟩ ↦ ?_, fun hS ↦ ?_⟩\n  · apply (mem_sieves_iff_hasEffectiveEpiFamily (Sieve.functorPushforward _ S)).mpr\n    refine ⟨α, inferInstance, fun i => F.obj (Y i),\n      fun i => F.map (π i), ⟨?_,\n      fun a => Sieve.image_mem_functorPushforward F S (H₂ a)⟩⟩\n    exact F.map_finite_effectiveEpiFamily _ _\n  · obtain ⟨α, _, Y, π, ⟨H₁, H₂⟩⟩ := (mem_sieves_iff_hasEffectiveEpiFamily _).mp hS\n    refine ⟨α, inferInstance, ?_⟩\n    let Z : α → C := fun a ↦ (Functor.EffectivelyEnough.presentation (F := F) (Y a)).some.p\n    let g₀ : (a : α) → F.obj (Z a) ⟶ Y a := fun a ↦ F.effectiveEpiOver (Y a)\n    have : EffectiveEpiFamily _ (fun a ↦ g₀ a ≫ π a) := inferInstance\n    refine ⟨Z , fun a ↦ F.preimage (g₀ a ≫ π a), ?_, fun a ↦ (?_ : S.arrows (F.preimage _))⟩\n    · refine F.finite_effectiveEpiFamily_of_map _ _ ?_\n      simpa using this\n    · obtain ⟨W, g₁, g₂, h₁, h₂⟩ := H₂ a\n      rw [h₂]\n      convert S.downward_closed h₁ (F.preimage (g₀ a ≫ g₂))\n      exact F.map_injective (by simp)\n\n"}
{"name":"CategoryTheory.coherentTopology.eq_induced","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝⁵ : F.PreservesFiniteEffectiveEpiFamilies\ninst✝⁴ : F.ReflectsFiniteEffectiveEpiFamilies\ninst✝³ : F.Full\ninst✝² : F.Faithful\ninst✝¹ : F.EffectivelyEnough\ninst✝ : CategoryTheory.Precoherent D\n⊢ Eq (CategoryTheory.coherentTopology C) (F.inducedTopology (CategoryTheory.coherentTopology D))","decl":"lemma eq_induced : haveI := F.reflects_precoherent\n    coherentTopology C =\n      F.inducedTopology (coherentTopology _) := by\n  ext X S\n  have := F.reflects_precoherent\n  rw [← exists_effectiveEpiFamily_iff_mem_induced F X]\n  rw [← coherentTopology.mem_sieves_iff_hasEffectiveEpiFamily S]\n\n"}
{"name":"CategoryTheory.coherentTopology.instIsDenseSubsite","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝⁵ : F.PreservesFiniteEffectiveEpiFamilies\ninst✝⁴ : F.ReflectsFiniteEffectiveEpiFamilies\ninst✝³ : F.Full\ninst✝² : F.Faithful\ninst✝¹ : F.EffectivelyEnough\ninst✝ : CategoryTheory.Precoherent D\n⊢ CategoryTheory.Functor.IsDenseSubsite (CategoryTheory.coherentTopology C) (CategoryTheory.coherentTopology D) F","decl":"instance : haveI := F.reflects_precoherent;\n    F.IsDenseSubsite (coherentTopology C) (coherentTopology D) where\n  functorPushforward_mem_iff := by\n    rw [eq_induced F]\n    rfl\n\n"}
{"name":"CategoryTheory.coherentTopology.coverPreserving","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝⁵ : F.PreservesFiniteEffectiveEpiFamilies\ninst✝⁴ : F.ReflectsFiniteEffectiveEpiFamilies\ninst✝³ : F.Full\ninst✝² : F.Faithful\ninst✝¹ : F.EffectivelyEnough\ninst✝ : CategoryTheory.Precoherent D\n⊢ CategoryTheory.CoverPreserving (CategoryTheory.coherentTopology C) (CategoryTheory.coherentTopology D) F","decl":"lemma coverPreserving : haveI := F.reflects_precoherent\n    CoverPreserving (coherentTopology _) (coherentTopology _) F :=\n  IsDenseSubsite.coverPreserving _ _ _\n\n"}
{"name":"CategoryTheory.regularTopology.instIsCoverDense","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Preregular D\n⊢ F.IsCoverDense (CategoryTheory.regularTopology D)","decl":"instance : F.IsCoverDense (regularTopology _) := by\n  refine F.isCoverDense_of_generate_singleton_functor_π_mem _ fun B ↦ ⟨_, F.effectiveEpiOver B, ?_⟩\n  apply Coverage.Saturate.of\n  refine ⟨F.effectiveEpiOverObj B, F.effectiveEpiOver B, ?_, inferInstance⟩\n  funext; ext -- Do we want `Presieve.ext`?\n  refine ⟨fun ⟨⟩ ↦ ⟨()⟩, ?_⟩\n  rintro ⟨⟩\n  simp\n\n"}
{"name":"CategoryTheory.regularTopology.exists_effectiveEpi_iff_mem_induced","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝⁵ : F.PreservesEffectiveEpis\ninst✝⁴ : F.ReflectsEffectiveEpis\ninst✝³ : F.Full\ninst✝² : F.Faithful\ninst✝¹ : F.EffectivelyEnough\ninst✝ : CategoryTheory.Preregular D\nX : C\nS : CategoryTheory.Sieve X\n⊢ Iff (Exists fun Y => Exists fun π => And (CategoryTheory.EffectiveEpi π) (S.arrows π)) (Membership.mem ((F.inducedTopology (CategoryTheory.regularTopology D)) X) S)","decl":"theorem exists_effectiveEpi_iff_mem_induced (X : C) (S : Sieve X) :\n    (∃ (Y : C) (π : Y ⟶ X),\n      EffectiveEpi π ∧ S.arrows π) ↔\n    (S ∈ F.inducedTopology (regularTopology _) X) := by\n  refine ⟨fun ⟨Y, π, ⟨H₁, H₂⟩⟩ ↦ ?_, fun hS ↦ ?_⟩\n  · apply (mem_sieves_iff_hasEffectiveEpi (Sieve.functorPushforward _ S)).mpr\n    refine ⟨F.obj Y, F.map π, ⟨?_, Sieve.image_mem_functorPushforward F S H₂⟩⟩\n    exact F.map_effectiveEpi _\n  · obtain ⟨Y, π, ⟨H₁, H₂⟩⟩ := (mem_sieves_iff_hasEffectiveEpi _).mp hS\n    let g₀ := F.effectiveEpiOver Y\n    refine ⟨_, F.preimage (g₀ ≫ π), ?_, (?_ : S.arrows (F.preimage _))⟩\n    · refine F.effectiveEpi_of_map _ ?_\n      simp only [map_preimage]\n      infer_instance\n    · obtain ⟨W, g₁, g₂, h₁, h₂⟩ := H₂\n      rw [h₂]\n      convert S.downward_closed h₁ (F.preimage (g₀ ≫ g₂))\n      exact F.map_injective (by simp)\n\n"}
{"name":"CategoryTheory.regularTopology.eq_induced","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝⁵ : F.PreservesEffectiveEpis\ninst✝⁴ : F.ReflectsEffectiveEpis\ninst✝³ : F.Full\ninst✝² : F.Faithful\ninst✝¹ : F.EffectivelyEnough\ninst✝ : CategoryTheory.Preregular D\n⊢ Eq (CategoryTheory.regularTopology C) (F.inducedTopology (CategoryTheory.regularTopology D))","decl":"lemma eq_induced : haveI := F.reflects_preregular\n    regularTopology C =\n      F.inducedTopology (regularTopology _) := by\n  ext X S\n  have := F.reflects_preregular\n  rw [← exists_effectiveEpi_iff_mem_induced F X]\n  rw [← mem_sieves_iff_hasEffectiveEpi S]\n\n"}
{"name":"CategoryTheory.regularTopology.instIsDenseSubsite","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝⁵ : F.PreservesEffectiveEpis\ninst✝⁴ : F.ReflectsEffectiveEpis\ninst✝³ : F.Full\ninst✝² : F.Faithful\ninst✝¹ : F.EffectivelyEnough\ninst✝ : CategoryTheory.Preregular D\n⊢ CategoryTheory.Functor.IsDenseSubsite (CategoryTheory.regularTopology C) (CategoryTheory.regularTopology D) F","decl":"instance : haveI := F.reflects_preregular;\n    F.IsDenseSubsite (regularTopology C) (regularTopology D) where\n  functorPushforward_mem_iff := by\n    rw [eq_induced F]\n    rfl\n\n"}
{"name":"CategoryTheory.regularTopology.coverPreserving","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝⁵ : F.PreservesEffectiveEpis\ninst✝⁴ : F.ReflectsEffectiveEpis\ninst✝³ : F.Full\ninst✝² : F.Faithful\ninst✝¹ : F.EffectivelyEnough\ninst✝ : CategoryTheory.Preregular D\n⊢ CategoryTheory.CoverPreserving (CategoryTheory.regularTopology C) (CategoryTheory.regularTopology D) F","decl":"lemma coverPreserving : haveI := F.reflects_preregular\n    CoverPreserving (regularTopology _) (regularTopology _) F :=\n  IsDenseSubsite.coverPreserving _ _ _\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_coherent_iff_regular_and_extensive","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\nA : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} A\nF : CategoryTheory.Functor (Opposite C) A\ninst✝¹ : CategoryTheory.Preregular C\ninst✝ : CategoryTheory.FinitaryPreExtensive C\n⊢ Iff (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.coherentTopology C) F) (And (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.extensiveTopology C) F) (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.regularTopology C) F))","decl":"theorem isSheaf_coherent_iff_regular_and_extensive [Preregular C] [FinitaryPreExtensive C] :\n    IsSheaf (coherentTopology C) F ↔\n    IsSheaf (extensiveTopology C) F ∧ IsSheaf (regularTopology C) F := by\n  rw [← extensive_regular_generate_coherent]\n  exact isSheaf_sup (extensiveCoverage C) (regularCoverage C) F\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_iff_preservesFiniteProducts_and_equalizerCondition","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\nA : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} A\nF : CategoryTheory.Functor (Opposite C) A\ninst✝¹ : CategoryTheory.Preregular C\ninst✝ : CategoryTheory.FinitaryExtensive C\nh : ∀ {Y X : C} (f : Quiver.Hom Y X) [inst : CategoryTheory.EffectiveEpi f], CategoryTheory.Limits.HasPullback f f\n⊢ Iff (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.coherentTopology C) F) (And (CategoryTheory.Limits.PreservesFiniteProducts F) (CategoryTheory.regularTopology.EqualizerCondition F))","decl":"theorem isSheaf_iff_preservesFiniteProducts_and_equalizerCondition\n    [Preregular C] [FinitaryExtensive C]\n    [h : ∀ {Y X : C} (f : Y ⟶ X) [EffectiveEpi f], HasPullback f f] :\n    IsSheaf (coherentTopology C) F ↔ PreservesFiniteProducts F ∧\n      EqualizerCondition F := by\n  rw [isSheaf_coherent_iff_regular_and_extensive]\n  exact and_congr (isSheaf_iff_preservesFiniteProducts _)\n    (@equalizerCondition_iff_isSheaf _ _ _ _ F _ h).symm\n\n"}
{"name":"CategoryTheory.Presheaf.instPreservesFiniteProductsOppositeVal","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\nA : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} A\ninst✝¹ : CategoryTheory.Preregular C\ninst✝ : CategoryTheory.FinitaryExtensive C\nF : CategoryTheory.Sheaf (CategoryTheory.coherentTopology C) A\n⊢ CategoryTheory.Limits.PreservesFiniteProducts F.val","decl":"noncomputable instance [Preregular C] [FinitaryExtensive C]\n    (F : Sheaf (coherentTopology C) A) : PreservesFiniteProducts F.val :=\n  (Presheaf.isSheaf_iff_preservesFiniteProducts F.val).1\n    ((Presheaf.isSheaf_coherent_iff_regular_and_extensive F.val).mp F.cond).1\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_iff_preservesFiniteProducts_of_projective","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\nA : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} A\nF : CategoryTheory.Functor (Opposite C) A\ninst✝² : CategoryTheory.Preregular C\ninst✝¹ : CategoryTheory.FinitaryExtensive C\ninst✝ : ∀ (X : C), CategoryTheory.Projective X\n⊢ Iff (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.coherentTopology C) F) (CategoryTheory.Limits.PreservesFiniteProducts F)","decl":"theorem isSheaf_iff_preservesFiniteProducts_of_projective [Preregular C] [FinitaryExtensive C]\n    [∀ (X : C), Projective X] :\n    IsSheaf (coherentTopology C) F ↔ PreservesFiniteProducts F := by\n  rw [isSheaf_coherent_iff_regular_and_extensive, and_iff_left (isSheaf_of_projective F),\n    isSheaf_iff_preservesFiniteProducts]\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_iff_extensiveSheaf_of_projective","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\nA : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} A\nF : CategoryTheory.Functor (Opposite C) A\ninst✝² : CategoryTheory.Preregular C\ninst✝¹ : CategoryTheory.FinitaryExtensive C\ninst✝ : ∀ (X : C), CategoryTheory.Projective X\n⊢ Iff (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.coherentTopology C) F) (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.extensiveTopology C) F)","decl":"theorem isSheaf_iff_extensiveSheaf_of_projective [Preregular C] [FinitaryExtensive C]\n    [∀ (X : C), Projective X] :\n    IsSheaf (coherentTopology C) F ↔ IsSheaf (extensiveTopology C) F := by\n  rw [isSheaf_iff_preservesFiniteProducts_of_projective, isSheaf_iff_preservesFiniteProducts]\n\n"}
{"name":"CategoryTheory.Presheaf.coherentExtensiveEquivalence_unitIso","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\nA : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} A\ninst✝² : CategoryTheory.Preregular C\ninst✝¹ : CategoryTheory.FinitaryExtensive C\ninst✝ : ∀ (X : C), CategoryTheory.Projective X\n⊢ Eq CategoryTheory.Presheaf.coherentExtensiveEquivalence.unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (CategoryTheory.Sheaf (CategoryTheory.coherentTopology C) A)))","decl":"/--\nThe categories of coherent sheaves and extensive sheaves on `C` are equivalent if `C` is\npreregular, finitary extensive, and every object is projective.\n-/\n@[simps]\ndef coherentExtensiveEquivalence [Preregular C] [FinitaryExtensive C] [∀ (X : C), Projective X] :\n    Sheaf (coherentTopology C) A ≌ Sheaf (extensiveTopology C) A where\n  functor := {\n    obj := fun F ↦ ⟨F.val, (isSheaf_iff_extensiveSheaf_of_projective F.val).mp F.cond⟩\n    map := fun f ↦ ⟨f.val⟩ }\n  inverse := {\n    obj := fun F ↦ ⟨F.val, (isSheaf_iff_extensiveSheaf_of_projective F.val).mpr F.cond⟩\n    map := fun f ↦ ⟨f.val⟩ }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Presheaf.coherentExtensiveEquivalence_inverse_obj_val","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\nA : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} A\ninst✝² : CategoryTheory.Preregular C\ninst✝¹ : CategoryTheory.FinitaryExtensive C\ninst✝ : ∀ (X : C), CategoryTheory.Projective X\nF : CategoryTheory.Sheaf (CategoryTheory.extensiveTopology C) A\n⊢ Eq (CategoryTheory.Presheaf.coherentExtensiveEquivalence.inverse.obj F).val F.val","decl":"/--\nThe categories of coherent sheaves and extensive sheaves on `C` are equivalent if `C` is\npreregular, finitary extensive, and every object is projective.\n-/\n@[simps]\ndef coherentExtensiveEquivalence [Preregular C] [FinitaryExtensive C] [∀ (X : C), Projective X] :\n    Sheaf (coherentTopology C) A ≌ Sheaf (extensiveTopology C) A where\n  functor := {\n    obj := fun F ↦ ⟨F.val, (isSheaf_iff_extensiveSheaf_of_projective F.val).mp F.cond⟩\n    map := fun f ↦ ⟨f.val⟩ }\n  inverse := {\n    obj := fun F ↦ ⟨F.val, (isSheaf_iff_extensiveSheaf_of_projective F.val).mpr F.cond⟩\n    map := fun f ↦ ⟨f.val⟩ }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Presheaf.coherentExtensiveEquivalence_functor_obj_val","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\nA : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} A\ninst✝² : CategoryTheory.Preregular C\ninst✝¹ : CategoryTheory.FinitaryExtensive C\ninst✝ : ∀ (X : C), CategoryTheory.Projective X\nF : CategoryTheory.Sheaf (CategoryTheory.coherentTopology C) A\n⊢ Eq (CategoryTheory.Presheaf.coherentExtensiveEquivalence.functor.obj F).val F.val","decl":"/--\nThe categories of coherent sheaves and extensive sheaves on `C` are equivalent if `C` is\npreregular, finitary extensive, and every object is projective.\n-/\n@[simps]\ndef coherentExtensiveEquivalence [Preregular C] [FinitaryExtensive C] [∀ (X : C), Projective X] :\n    Sheaf (coherentTopology C) A ≌ Sheaf (extensiveTopology C) A where\n  functor := {\n    obj := fun F ↦ ⟨F.val, (isSheaf_iff_extensiveSheaf_of_projective F.val).mp F.cond⟩\n    map := fun f ↦ ⟨f.val⟩ }\n  inverse := {\n    obj := fun F ↦ ⟨F.val, (isSheaf_iff_extensiveSheaf_of_projective F.val).mpr F.cond⟩\n    map := fun f ↦ ⟨f.val⟩ }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Presheaf.coherentExtensiveEquivalence_counitIso","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\nA : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} A\ninst✝² : CategoryTheory.Preregular C\ninst✝¹ : CategoryTheory.FinitaryExtensive C\ninst✝ : ∀ (X : C), CategoryTheory.Projective X\n⊢ Eq CategoryTheory.Presheaf.coherentExtensiveEquivalence.counitIso (CategoryTheory.Iso.refl ({ obj := fun F => { val := F.val, cond := ⋯ }, map := fun {X Y} f => { val := f.val }, map_id := ⋯, map_comp := ⋯ }.comp { obj := fun F => { val := F.val, cond := ⋯ }, map := fun {X Y} f => { val := f.val }, map_id := ⋯, map_comp := ⋯ }))","decl":"/--\nThe categories of coherent sheaves and extensive sheaves on `C` are equivalent if `C` is\npreregular, finitary extensive, and every object is projective.\n-/\n@[simps]\ndef coherentExtensiveEquivalence [Preregular C] [FinitaryExtensive C] [∀ (X : C), Projective X] :\n    Sheaf (coherentTopology C) A ≌ Sheaf (extensiveTopology C) A where\n  functor := {\n    obj := fun F ↦ ⟨F.val, (isSheaf_iff_extensiveSheaf_of_projective F.val).mp F.cond⟩\n    map := fun f ↦ ⟨f.val⟩ }\n  inverse := {\n    obj := fun F ↦ ⟨F.val, (isSheaf_iff_extensiveSheaf_of_projective F.val).mpr F.cond⟩\n    map := fun f ↦ ⟨f.val⟩ }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Presheaf.coherentExtensiveEquivalence_inverse_map_val","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\nA : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} A\ninst✝² : CategoryTheory.Preregular C\ninst✝¹ : CategoryTheory.FinitaryExtensive C\ninst✝ : ∀ (X : C), CategoryTheory.Projective X\nX✝ Y✝ : CategoryTheory.Sheaf (CategoryTheory.extensiveTopology C) A\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Presheaf.coherentExtensiveEquivalence.inverse.map f).val f.val","decl":"/--\nThe categories of coherent sheaves and extensive sheaves on `C` are equivalent if `C` is\npreregular, finitary extensive, and every object is projective.\n-/\n@[simps]\ndef coherentExtensiveEquivalence [Preregular C] [FinitaryExtensive C] [∀ (X : C), Projective X] :\n    Sheaf (coherentTopology C) A ≌ Sheaf (extensiveTopology C) A where\n  functor := {\n    obj := fun F ↦ ⟨F.val, (isSheaf_iff_extensiveSheaf_of_projective F.val).mp F.cond⟩\n    map := fun f ↦ ⟨f.val⟩ }\n  inverse := {\n    obj := fun F ↦ ⟨F.val, (isSheaf_iff_extensiveSheaf_of_projective F.val).mpr F.cond⟩\n    map := fun f ↦ ⟨f.val⟩ }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Presheaf.coherentExtensiveEquivalence_functor_map_val","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\nA : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} A\ninst✝² : CategoryTheory.Preregular C\ninst✝¹ : CategoryTheory.FinitaryExtensive C\ninst✝ : ∀ (X : C), CategoryTheory.Projective X\nX✝ Y✝ : CategoryTheory.Sheaf (CategoryTheory.coherentTopology C) A\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Presheaf.coherentExtensiveEquivalence.functor.map f).val f.val","decl":"/--\nThe categories of coherent sheaves and extensive sheaves on `C` are equivalent if `C` is\npreregular, finitary extensive, and every object is projective.\n-/\n@[simps]\ndef coherentExtensiveEquivalence [Preregular C] [FinitaryExtensive C] [∀ (X : C), Projective X] :\n    Sheaf (coherentTopology C) A ≌ Sheaf (extensiveTopology C) A where\n  functor := {\n    obj := fun F ↦ ⟨F.val, (isSheaf_iff_extensiveSheaf_of_projective F.val).mp F.cond⟩\n    map := fun f ↦ ⟨f.val⟩ }\n  inverse := {\n    obj := fun F ↦ ⟨F.val, (isSheaf_iff_extensiveSheaf_of_projective F.val).mpr F.cond⟩\n    map := fun f ↦ ⟨f.val⟩ }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_coherent_of_hasPullbacks_comp","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\nA : Type u₃\ninst✝⁴ : CategoryTheory.Category.{v₃, u₃} A\nF : CategoryTheory.Functor (Opposite C) A\nB : Type u₄\ninst✝³ : CategoryTheory.Category.{v₄, u₄} B\ns : CategoryTheory.Functor A B\ninst✝² : CategoryTheory.Preregular C\ninst✝¹ : CategoryTheory.FinitaryExtensive C\nh : ∀ {Y X : C} (f : Quiver.Hom Y X) [inst : CategoryTheory.EffectiveEpi f], CategoryTheory.Limits.HasPullback f f\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits s\nhF : CategoryTheory.Presheaf.IsSheaf (CategoryTheory.coherentTopology C) F\n⊢ CategoryTheory.Presheaf.IsSheaf (CategoryTheory.coherentTopology C) (F.comp s)","decl":"lemma isSheaf_coherent_of_hasPullbacks_comp [Preregular C] [FinitaryExtensive C]\n    [h : ∀ {Y X : C} (f : Y ⟶ X) [EffectiveEpi f], HasPullback f f] [PreservesFiniteLimits s]\n    (hF : IsSheaf (coherentTopology C) F) : IsSheaf (coherentTopology C) (F ⋙ s) := by\n  rw [isSheaf_iff_preservesFiniteProducts_and_equalizerCondition (h := h)] at hF ⊢\n  have := hF.1\n  refine ⟨inferInstance, fun _ _ π _ c hc ↦ ⟨?_⟩⟩\n  exact isLimitForkMapOfIsLimit s _ (hF.2 π c hc).some\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_coherent_of_hasPullbacks_of_comp","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\nA : Type u₃\ninst✝⁴ : CategoryTheory.Category.{v₃, u₃} A\nF : CategoryTheory.Functor (Opposite C) A\nB : Type u₄\ninst✝³ : CategoryTheory.Category.{v₄, u₄} B\ns : CategoryTheory.Functor A B\ninst✝² : CategoryTheory.Preregular C\ninst✝¹ : CategoryTheory.FinitaryExtensive C\nh : ∀ {Y X : C} (f : Quiver.Hom Y X) [inst : CategoryTheory.EffectiveEpi f], CategoryTheory.Limits.HasPullback f f\ninst✝ : CategoryTheory.Limits.ReflectsFiniteLimits s\nhF : CategoryTheory.Presheaf.IsSheaf (CategoryTheory.coherentTopology C) (F.comp s)\n⊢ CategoryTheory.Presheaf.IsSheaf (CategoryTheory.coherentTopology C) F","decl":"lemma isSheaf_coherent_of_hasPullbacks_of_comp [Preregular C] [FinitaryExtensive C]\n    [h : ∀ {Y X : C} (f : Y ⟶ X) [EffectiveEpi f], HasPullback f f]\n    [ReflectsFiniteLimits s]\n    (hF : IsSheaf (coherentTopology C) (F ⋙ s)) : IsSheaf (coherentTopology C) F := by\n  rw [isSheaf_iff_preservesFiniteProducts_and_equalizerCondition (h := h)] at hF ⊢\n  obtain ⟨_, hF₂⟩ := hF\n  refine ⟨⟨fun J _ ↦ ⟨fun {K} ↦ ⟨fun {c} hc ↦ ?_⟩⟩⟩, fun _ _ π _ c hc ↦ ⟨?_⟩⟩\n  · exact ⟨isLimitOfReflects s (isLimitOfPreserves (F ⋙ s) hc)⟩\n  · exact isLimitOfIsLimitForkMap s _ (hF₂ π c hc).some\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_coherent_of_projective_comp","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\nA : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₃, u₃} A\nF : CategoryTheory.Functor (Opposite C) A\nB : Type u₄\ninst✝⁴ : CategoryTheory.Category.{v₄, u₄} B\ns : CategoryTheory.Functor A B\ninst✝³ : CategoryTheory.Preregular C\ninst✝² : CategoryTheory.FinitaryExtensive C\ninst✝¹ : ∀ (X : C), CategoryTheory.Projective X\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts s\nhF : CategoryTheory.Presheaf.IsSheaf (CategoryTheory.coherentTopology C) F\n⊢ CategoryTheory.Presheaf.IsSheaf (CategoryTheory.coherentTopology C) (F.comp s)","decl":"lemma isSheaf_coherent_of_projective_comp [Preregular C] [FinitaryExtensive C]\n    [∀ (X : C), Projective X] [PreservesFiniteProducts s]\n    (hF : IsSheaf (coherentTopology C) F) : IsSheaf (coherentTopology C) (F ⋙ s) := by\n  rw [isSheaf_iff_preservesFiniteProducts_of_projective] at hF ⊢\n  infer_instance\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_coherent_of_projective_of_comp","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\nA : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₃, u₃} A\nF : CategoryTheory.Functor (Opposite C) A\nB : Type u₄\ninst✝⁴ : CategoryTheory.Category.{v₄, u₄} B\ns : CategoryTheory.Functor A B\ninst✝³ : CategoryTheory.Preregular C\ninst✝² : CategoryTheory.FinitaryExtensive C\ninst✝¹ : ∀ (X : C), CategoryTheory.Projective X\ninst✝ : CategoryTheory.Limits.ReflectsFiniteProducts s\nhF : CategoryTheory.Presheaf.IsSheaf (CategoryTheory.coherentTopology C) (F.comp s)\n⊢ CategoryTheory.Presheaf.IsSheaf (CategoryTheory.coherentTopology C) F","decl":"lemma isSheaf_coherent_of_projective_of_comp [Preregular C] [FinitaryExtensive C]\n    [∀ (X : C), Projective X]\n    [ReflectsFiniteProducts s]\n    (hF : IsSheaf (coherentTopology C) (F ⋙ s)) : IsSheaf (coherentTopology C) F := by\n  rw [isSheaf_iff_preservesFiniteProducts_of_projective] at hF ⊢\n  exact ⟨fun J _ ↦ ⟨fun {K} ↦ ⟨fun {c} hc ↦\n    ⟨isLimitOfReflects s (isLimitOfPreserves (F ⋙ s) hc)⟩⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Presheaf.instHasSheafComposeCoherentTopologyOfForallEffectiveEpiHasPullbackOfPreservesFiniteLimits","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\nA : Type u₃\ninst✝⁴ : CategoryTheory.Category.{v₃, u₃} A\nB : Type u₄\ninst✝³ : CategoryTheory.Category.{v₄, u₄} B\ns : CategoryTheory.Functor A B\ninst✝² : CategoryTheory.Preregular C\ninst✝¹ : CategoryTheory.FinitaryExtensive C\nh : ∀ {Y X : C} (f : Quiver.Hom Y X) [inst : CategoryTheory.EffectiveEpi f], CategoryTheory.Limits.HasPullback f f\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits s\n⊢ (CategoryTheory.coherentTopology C).HasSheafCompose s","decl":"instance [Preregular C] [FinitaryExtensive C]\n    [h : ∀ {Y X : C} (f : Y ⟶ X) [EffectiveEpi f], HasPullback f f]\n    [PreservesFiniteLimits s] : (coherentTopology C).HasSheafCompose s where\n      isSheaf F hF := isSheaf_coherent_of_hasPullbacks_comp (h := h) F s hF\n\n"}
{"name":"CategoryTheory.Presheaf.instHasSheafComposeCoherentTopologyOfProjectiveOfPreservesFiniteProducts","module":"Mathlib.CategoryTheory.Sites.Coherent.SheafComparison","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\nA : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₃, u₃} A\nB : Type u₄\ninst✝⁴ : CategoryTheory.Category.{v₄, u₄} B\ns : CategoryTheory.Functor A B\ninst✝³ : CategoryTheory.Preregular C\ninst✝² : CategoryTheory.FinitaryExtensive C\ninst✝¹ : ∀ (X : C), CategoryTheory.Projective X\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts s\n⊢ (CategoryTheory.coherentTopology C).HasSheafCompose s","decl":"instance [Preregular C] [FinitaryExtensive C] [∀ (X : C), Projective X]\n    [PreservesFiniteProducts s] : (coherentTopology C).HasSheafCompose s where\n  isSheaf F hF := isSheaf_coherent_of_projective_comp F s hF\n\n"}
