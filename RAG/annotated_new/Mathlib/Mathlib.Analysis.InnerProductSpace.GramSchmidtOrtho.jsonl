{"name":"gramSchmidt_def","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\nn : ι\n⊢ Eq (gramSchmidt 𝕜 f n) (HSub.hSub (f n) ((Finset.Iio n).sum fun i => ↑((orthogonalProjection (Submodule.span 𝕜 (Singleton.singleton (gramSchmidt 𝕜 f i)))) (f n))))","decl":"/-- This lemma uses `∑ i in` instead of `∑ i :`. -/\ntheorem gramSchmidt_def (f : ι → E) (n : ι) :\n    gramSchmidt 𝕜 f n = f n - ∑ i ∈ Iio n, orthogonalProjection (𝕜 ∙ gramSchmidt 𝕜 f i) (f n) := by\n  rw [← sum_attach, attach_eq_univ, gramSchmidt]\n\n"}
{"name":"gramSchmidt_def'","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\nn : ι\n⊢ Eq (f n) (HAdd.hAdd (gramSchmidt 𝕜 f n) ((Finset.Iio n).sum fun i => ↑((orthogonalProjection (Submodule.span 𝕜 (Singleton.singleton (gramSchmidt 𝕜 f i)))) (f n))))","decl":"theorem gramSchmidt_def' (f : ι → E) (n : ι) :\n    f n = gramSchmidt 𝕜 f n + ∑ i ∈ Iio n, orthogonalProjection (𝕜 ∙ gramSchmidt 𝕜 f i) (f n) := by\n  rw [gramSchmidt_def, sub_add_cancel]\n\n"}
{"name":"gramSchmidt_def''","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\nn : ι\n⊢ Eq (f n) (HAdd.hAdd (gramSchmidt 𝕜 f n) ((Finset.Iio n).sum fun i => HSMul.hSMul (HDiv.hDiv (Inner.inner (gramSchmidt 𝕜 f i) (f n)) (HPow.hPow (↑(Norm.norm (gramSchmidt 𝕜 f i))) 2)) (gramSchmidt 𝕜 f i)))","decl":"theorem gramSchmidt_def'' (f : ι → E) (n : ι) :\n    f n = gramSchmidt 𝕜 f n + ∑ i ∈ Iio n,\n      (⟪gramSchmidt 𝕜 f i, f n⟫ / (‖gramSchmidt 𝕜 f i‖ : 𝕜) ^ 2) • gramSchmidt 𝕜 f i := by\n  convert gramSchmidt_def' 𝕜 f n\n  rw [orthogonalProjection_singleton, RCLike.ofReal_pow]\n\n"}
{"name":"gramSchmidt_zero","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : InnerProductSpace 𝕜 E\nι : Type u_4\ninst✝³ : LinearOrder ι\ninst✝² : LocallyFiniteOrder ι\ninst✝¹ : OrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\n⊢ Eq (gramSchmidt 𝕜 f Bot.bot) (f Bot.bot)","decl":"@[simp]\ntheorem gramSchmidt_zero {ι : Type*} [LinearOrder ι] [LocallyFiniteOrder ι] [OrderBot ι]\n    [WellFoundedLT ι] (f : ι → E) : gramSchmidt 𝕜 f ⊥ = f ⊥ := by\n  rw [gramSchmidt_def, Iio_eq_Ico, Finset.Ico_self, Finset.sum_empty, sub_zero]\n\n"}
{"name":"gramSchmidt_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\na b : ι\nh₀ : Ne a b\n⊢ Eq (Inner.inner (gramSchmidt 𝕜 f a) (gramSchmidt 𝕜 f b)) 0","decl":"/-- **Gram-Schmidt Orthogonalisation**:\n`gramSchmidt` produces an orthogonal system of vectors. -/\ntheorem gramSchmidt_orthogonal (f : ι → E) {a b : ι} (h₀ : a ≠ b) :\n    ⟪gramSchmidt 𝕜 f a, gramSchmidt 𝕜 f b⟫ = 0 := by\n  suffices ∀ a b : ι, a < b → ⟪gramSchmidt 𝕜 f a, gramSchmidt 𝕜 f b⟫ = 0 by\n    cases' h₀.lt_or_lt with ha hb\n    · exact this _ _ ha\n    · rw [inner_eq_zero_symm]\n      exact this _ _ hb\n  clear h₀ a b\n  intro a b h₀\n  revert a\n  apply wellFounded_lt.induction b\n  intro b ih a h₀\n  simp only [gramSchmidt_def 𝕜 f b, inner_sub_right, inner_sum, orthogonalProjection_singleton,\n    inner_smul_right]\n  rw [Finset.sum_eq_single_of_mem a (Finset.mem_Iio.mpr h₀)]\n  · by_cases h : gramSchmidt 𝕜 f a = 0\n    · simp only [h, inner_zero_left, zero_div, zero_mul, sub_zero]\n    · rw [RCLike.ofReal_pow, ← inner_self_eq_norm_sq_to_K, div_mul_cancel₀, sub_self]\n      rwa [inner_self_ne_zero]\n  intro i hi hia\n  simp only [mul_eq_zero, div_eq_zero_iff, inner_self_eq_zero]\n  right\n  cases' hia.lt_or_lt with hia₁ hia₂\n  · rw [inner_eq_zero_symm]\n    exact ih a h₀ i hia₁\n  · exact ih i (mem_Iio.1 hi) a hia₂\n\n"}
{"name":"gramSchmidt_pairwise_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\n⊢ Pairwise fun a b => Eq (Inner.inner (gramSchmidt 𝕜 f a) (gramSchmidt 𝕜 f b)) 0","decl":"/-- This is another version of `gramSchmidt_orthogonal` using `Pairwise` instead. -/\ntheorem gramSchmidt_pairwise_orthogonal (f : ι → E) :\n    Pairwise fun a b => ⟪gramSchmidt 𝕜 f a, gramSchmidt 𝕜 f b⟫ = 0 := fun _ _ =>\n  gramSchmidt_orthogonal 𝕜 f\n\n"}
{"name":"gramSchmidt_inv_triangular","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nv : ι → E\ni j : ι\nhij : LT.lt i j\n⊢ Eq (Inner.inner (gramSchmidt 𝕜 v j) (v i)) 0","decl":"theorem gramSchmidt_inv_triangular (v : ι → E) {i j : ι} (hij : i < j) :\n    ⟪gramSchmidt 𝕜 v j, v i⟫ = 0 := by\n  rw [gramSchmidt_def'' 𝕜 v]\n  simp only [inner_add_right, inner_sum, inner_smul_right]\n  set b : ι → E := gramSchmidt 𝕜 v\n  convert zero_add (0 : 𝕜)\n  · exact gramSchmidt_orthogonal 𝕜 v hij.ne'\n  apply Finset.sum_eq_zero\n  rintro k hki'\n  have hki : k < i := by simpa using hki'\n  have : ⟪b j, b k⟫ = 0 := gramSchmidt_orthogonal 𝕜 v (hki.trans hij).ne'\n  simp [this]\n\n"}
{"name":"mem_span_gramSchmidt","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\ni j : ι\nhij : LE.le i j\n⊢ Membership.mem (Submodule.span 𝕜 (Set.image (gramSchmidt 𝕜 f) (Set.Iic j))) (f i)","decl":"theorem mem_span_gramSchmidt (f : ι → E) {i j : ι} (hij : i ≤ j) :\n    f i ∈ span 𝕜 (gramSchmidt 𝕜 f '' Set.Iic j) := by\n  rw [gramSchmidt_def' 𝕜 f i]\n  simp_rw [orthogonalProjection_singleton]\n  exact Submodule.add_mem _ (subset_span <| mem_image_of_mem _ hij)\n    (Submodule.sum_mem _ fun k hk => smul_mem (span 𝕜 (gramSchmidt 𝕜 f '' Set.Iic j)) _ <|\n      subset_span <| mem_image_of_mem (gramSchmidt 𝕜 f) <| (Finset.mem_Iio.1 hk).le.trans hij)\n\n"}
{"name":"gramSchmidt_mem_span","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\nj i : ι\na✝ : LE.le i j\n⊢ Membership.mem (Submodule.span 𝕜 (Set.image f (Set.Iic j))) (gramSchmidt 𝕜 f i)","decl":"theorem gramSchmidt_mem_span (f : ι → E) :\n    ∀ {j i}, i ≤ j → gramSchmidt 𝕜 f i ∈ span 𝕜 (f '' Set.Iic j) := by\n  intro j i hij\n  rw [gramSchmidt_def 𝕜 f i]\n  simp_rw [orthogonalProjection_singleton]\n  refine Submodule.sub_mem _ (subset_span (mem_image_of_mem _ hij))\n    (Submodule.sum_mem _ fun k hk => ?_)\n  let hkj : k < j := (Finset.mem_Iio.1 hk).trans_le hij\n  exact smul_mem _ _\n    (span_mono (image_subset f <| Set.Iic_subset_Iic.2 hkj.le) <| gramSchmidt_mem_span _ le_rfl)\ntermination_by j => j\n\n"}
{"name":"span_gramSchmidt_Iic","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\nc : ι\n⊢ Eq (Submodule.span 𝕜 (Set.image (gramSchmidt 𝕜 f) (Set.Iic c))) (Submodule.span 𝕜 (Set.image f (Set.Iic c)))","decl":"theorem span_gramSchmidt_Iic (f : ι → E) (c : ι) :\n    span 𝕜 (gramSchmidt 𝕜 f '' Set.Iic c) = span 𝕜 (f '' Set.Iic c) :=\n  span_eq_span (Set.image_subset_iff.2 fun _ => gramSchmidt_mem_span _ _) <|\n    Set.image_subset_iff.2 fun _ => mem_span_gramSchmidt _ _\n\n"}
{"name":"span_gramSchmidt_Iio","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\nc : ι\n⊢ Eq (Submodule.span 𝕜 (Set.image (gramSchmidt 𝕜 f) (Set.Iio c))) (Submodule.span 𝕜 (Set.image f (Set.Iio c)))","decl":"theorem span_gramSchmidt_Iio (f : ι → E) (c : ι) :\n    span 𝕜 (gramSchmidt 𝕜 f '' Set.Iio c) = span 𝕜 (f '' Set.Iio c) :=\n  span_eq_span (Set.image_subset_iff.2 fun _ hi =>\n    span_mono (image_subset _ <| Iic_subset_Iio.2 hi) <| gramSchmidt_mem_span _ _ le_rfl) <|\n      Set.image_subset_iff.2 fun _ hi =>\n        span_mono (image_subset _ <| Iic_subset_Iio.2 hi) <| mem_span_gramSchmidt _ _ le_rfl\n\n"}
{"name":"span_gramSchmidt","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\n⊢ Eq (Submodule.span 𝕜 (Set.range (gramSchmidt 𝕜 f))) (Submodule.span 𝕜 (Set.range f))","decl":"/-- `gramSchmidt` preserves span of vectors. -/\ntheorem span_gramSchmidt (f : ι → E) : span 𝕜 (range (gramSchmidt 𝕜 f)) = span 𝕜 (range f) :=\n  span_eq_span (range_subset_iff.2 fun _ =>\n    span_mono (image_subset_range _ _) <| gramSchmidt_mem_span _ _ le_rfl) <|\n      range_subset_iff.2 fun _ =>\n        span_mono (image_subset_range _ _) <| mem_span_gramSchmidt _ _ le_rfl\n\n"}
{"name":"gramSchmidt_of_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\nhf : Pairwise fun i j => Eq (Inner.inner (f i) (f j)) 0\n⊢ Eq (gramSchmidt 𝕜 f) f","decl":"theorem gramSchmidt_of_orthogonal {f : ι → E} (hf : Pairwise fun i j => ⟪f i, f j⟫ = 0) :\n    gramSchmidt 𝕜 f = f := by\n  ext i\n  rw [gramSchmidt_def]\n  trans f i - 0\n  · congr\n    apply Finset.sum_eq_zero\n    intro j hj\n    rw [Submodule.coe_eq_zero]\n    suffices span 𝕜 (f '' Set.Iic j) ⟂ 𝕜 ∙ f i by\n      apply orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero\n      rw [mem_orthogonal_singleton_iff_inner_left]\n      rw [← mem_orthogonal_singleton_iff_inner_right]\n      exact this (gramSchmidt_mem_span 𝕜 f (le_refl j))\n    rw [isOrtho_span]\n    rintro u ⟨k, hk, rfl⟩ v (rfl : v = f i)\n    apply hf\n    exact (lt_of_le_of_lt hk (Finset.mem_Iio.mp hj)).ne\n  · simp\n\n"}
{"name":"gramSchmidt_ne_zero_coe","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\nn : ι\nh₀ : LinearIndependent 𝕜 (Function.comp f Subtype.val)\n⊢ Ne (gramSchmidt 𝕜 f n) 0","decl":"theorem gramSchmidt_ne_zero_coe {f : ι → E} (n : ι)\n    (h₀ : LinearIndependent 𝕜 (f ∘ ((↑) : Set.Iic n → ι))) : gramSchmidt 𝕜 f n ≠ 0 := by\n  by_contra h\n  have h₁ : f n ∈ span 𝕜 (f '' Set.Iio n) := by\n    rw [← span_gramSchmidt_Iio 𝕜 f n, gramSchmidt_def' 𝕜 f, h, zero_add]\n    apply Submodule.sum_mem _ _\n    intro a ha\n    simp only [Set.mem_image, Set.mem_Iio, orthogonalProjection_singleton]\n    apply Submodule.smul_mem _ _ _\n    rw [Finset.mem_Iio] at ha\n    exact subset_span ⟨a, ha, by rfl⟩\n  have h₂ : (f ∘ ((↑) : Set.Iic n → ι)) ⟨n, le_refl n⟩ ∈\n      span 𝕜 (f ∘ ((↑) : Set.Iic n → ι) '' Set.Iio ⟨n, le_refl n⟩) := by\n    rw [image_comp]\n    simpa using h₁\n  apply LinearIndependent.not_mem_span_image h₀ _ h₂\n  simp only [Set.mem_Iio, lt_self_iff_false, not_false_iff]\n\n"}
{"name":"gramSchmidt_ne_zero","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\nn : ι\nh₀ : LinearIndependent 𝕜 f\n⊢ Ne (gramSchmidt 𝕜 f n) 0","decl":"/-- If the input vectors of `gramSchmidt` are linearly independent,\nthen the output vectors are non-zero. -/\ntheorem gramSchmidt_ne_zero {f : ι → E} (n : ι) (h₀ : LinearIndependent 𝕜 f) :\n    gramSchmidt 𝕜 f n ≠ 0 :=\n  gramSchmidt_ne_zero_coe _ (LinearIndependent.comp h₀ _ Subtype.coe_injective)\n\n"}
{"name":"gramSchmidt_triangular","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\ni j : ι\nhij : LT.lt i j\nb : Basis ι 𝕜 E\n⊢ Eq ((b.repr (gramSchmidt 𝕜 (⇑b) i)) j) 0","decl":"/-- `gramSchmidt` produces a triangular matrix of vectors when given a basis. -/\ntheorem gramSchmidt_triangular {i j : ι} (hij : i < j) (b : Basis ι 𝕜 E) :\n    b.repr (gramSchmidt 𝕜 b i) j = 0 := by\n  have : gramSchmidt 𝕜 b i ∈ span 𝕜 (gramSchmidt 𝕜 b '' Set.Iio j) :=\n    subset_span ((Set.mem_image _ _ _).2 ⟨i, hij, rfl⟩)\n  have : gramSchmidt 𝕜 b i ∈ span 𝕜 (b '' Set.Iio j) := by rwa [← span_gramSchmidt_Iio 𝕜 b j]\n  have : ↑(b.repr (gramSchmidt 𝕜 b i)).support ⊆ Set.Iio j :=\n    Basis.repr_support_subset_of_mem_span b (Set.Iio j) this\n  exact (Finsupp.mem_supported' _ _).1 ((Finsupp.mem_supported 𝕜 _).2 this) j Set.not_mem_Iio_self\n\n"}
{"name":"gramSchmidt_linearIndependent","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\nh₀ : LinearIndependent 𝕜 f\n⊢ LinearIndependent 𝕜 (gramSchmidt 𝕜 f)","decl":"/-- `gramSchmidt` produces linearly independent vectors when given linearly independent vectors. -/\ntheorem gramSchmidt_linearIndependent {f : ι → E} (h₀ : LinearIndependent 𝕜 f) :\n    LinearIndependent 𝕜 (gramSchmidt 𝕜 f) :=\n  linearIndependent_of_ne_zero_of_inner_eq_zero (fun _ => gramSchmidt_ne_zero _ h₀) fun _ _ =>\n    gramSchmidt_orthogonal 𝕜 f\n\n"}
{"name":"coe_gramSchmidtBasis","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nb : Basis ι 𝕜 E\n⊢ Eq (⇑(gramSchmidtBasis b)) (gramSchmidt 𝕜 ⇑b)","decl":"theorem coe_gramSchmidtBasis (b : Basis ι 𝕜 E) : (gramSchmidtBasis b : ι → E) = gramSchmidt 𝕜 b :=\n  Basis.coe_mk _ _\n\n"}
{"name":"gramSchmidtNormed_unit_length_coe","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\nn : ι\nh₀ : LinearIndependent 𝕜 (Function.comp f Subtype.val)\n⊢ Eq (Norm.norm (gramSchmidtNormed 𝕜 f n)) 1","decl":"theorem gramSchmidtNormed_unit_length_coe {f : ι → E} (n : ι)\n    (h₀ : LinearIndependent 𝕜 (f ∘ ((↑) : Set.Iic n → ι))) : ‖gramSchmidtNormed 𝕜 f n‖ = 1 := by\n  simp only [gramSchmidt_ne_zero_coe n h₀, gramSchmidtNormed, norm_smul_inv_norm, Ne,\n    not_false_iff]\n\n"}
{"name":"gramSchmidtNormed_unit_length","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\nn : ι\nh₀ : LinearIndependent 𝕜 f\n⊢ Eq (Norm.norm (gramSchmidtNormed 𝕜 f n)) 1","decl":"theorem gramSchmidtNormed_unit_length {f : ι → E} (n : ι) (h₀ : LinearIndependent 𝕜 f) :\n    ‖gramSchmidtNormed 𝕜 f n‖ = 1 :=\n  gramSchmidtNormed_unit_length_coe _ (LinearIndependent.comp h₀ _ Subtype.coe_injective)\n\n"}
{"name":"gramSchmidtNormed_unit_length'","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\nn : ι\nhn : Ne (gramSchmidtNormed 𝕜 f n) 0\n⊢ Eq (Norm.norm (gramSchmidtNormed 𝕜 f n)) 1","decl":"theorem gramSchmidtNormed_unit_length' {f : ι → E} {n : ι} (hn : gramSchmidtNormed 𝕜 f n ≠ 0) :\n    ‖gramSchmidtNormed 𝕜 f n‖ = 1 := by\n  rw [gramSchmidtNormed] at *\n  rw [norm_smul_inv_norm]\n  simpa using hn\n\n"}
{"name":"gramSchmidt_orthonormal","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\nh₀ : LinearIndependent 𝕜 f\n⊢ Orthonormal 𝕜 (gramSchmidtNormed 𝕜 f)","decl":"/-- **Gram-Schmidt Orthonormalization**:\n`gramSchmidtNormed` applied to a linearly independent set of vectors produces an orthornormal\nsystem of vectors. -/\ntheorem gramSchmidt_orthonormal {f : ι → E} (h₀ : LinearIndependent 𝕜 f) :\n    Orthonormal 𝕜 (gramSchmidtNormed 𝕜 f) := by\n  unfold Orthonormal\n  constructor\n  · simp only [gramSchmidtNormed_unit_length, h₀, eq_self_iff_true, imp_true_iff]\n  · intro i j hij\n    simp only [gramSchmidtNormed, inner_smul_left, inner_smul_right, RCLike.conj_inv,\n      RCLike.conj_ofReal, mul_eq_zero, inv_eq_zero, RCLike.ofReal_eq_zero, norm_eq_zero]\n    repeat' right\n    exact gramSchmidt_orthogonal 𝕜 f hij\n\n"}
{"name":"gramSchmidt_orthonormal'","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\n⊢ Orthonormal 𝕜 fun i => gramSchmidtNormed 𝕜 f ↑i","decl":"/-- **Gram-Schmidt Orthonormalization**:\n`gramSchmidtNormed` produces an orthornormal system of vectors after removing the vectors which\nbecome zero in the process. -/\ntheorem gramSchmidt_orthonormal' (f : ι → E) :\n    Orthonormal 𝕜 fun i : { i | gramSchmidtNormed 𝕜 f i ≠ 0 } => gramSchmidtNormed 𝕜 f i := by\n  refine ⟨fun i => gramSchmidtNormed_unit_length' i.prop, ?_⟩\n  rintro i j (hij : ¬_)\n  rw [Subtype.ext_iff] at hij\n  simp [gramSchmidtNormed, inner_smul_left, inner_smul_right, gramSchmidt_orthogonal 𝕜 f hij]\n\n"}
{"name":"span_gramSchmidtNormed","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\ns : Set ι\n⊢ Eq (Submodule.span 𝕜 (Set.image (gramSchmidtNormed 𝕜 f) s)) (Submodule.span 𝕜 (Set.image (gramSchmidt 𝕜 f) s))","decl":"theorem span_gramSchmidtNormed (f : ι → E) (s : Set ι) :\n    span 𝕜 (gramSchmidtNormed 𝕜 f '' s) = span 𝕜 (gramSchmidt 𝕜 f '' s) := by\n  refine span_eq_span\n    (Set.image_subset_iff.2 fun i hi => smul_mem _ _ <| subset_span <| mem_image_of_mem _ hi)\n    (Set.image_subset_iff.2 fun i hi =>\n      span_mono (image_subset _ <| singleton_subset_set_iff.2 hi) ?_)\n  simp only [coe_singleton, Set.image_singleton]\n  by_cases h : gramSchmidt 𝕜 f i = 0\n  · simp [h]\n  · refine mem_span_singleton.2 ⟨‖gramSchmidt 𝕜 f i‖, smul_inv_smul₀ ?_ _⟩\n    exact mod_cast norm_ne_zero_iff.2 h\n\n"}
{"name":"span_gramSchmidtNormed_range","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : WellFoundedLT ι\nf : ι → E\n⊢ Eq (Submodule.span 𝕜 (Set.range (gramSchmidtNormed 𝕜 f))) (Submodule.span 𝕜 (Set.range (gramSchmidt 𝕜 f)))","decl":"theorem span_gramSchmidtNormed_range (f : ι → E) :\n    span 𝕜 (range (gramSchmidtNormed 𝕜 f)) = span 𝕜 (range (gramSchmidt 𝕜 f)) := by\n  simpa only [image_univ.symm] using span_gramSchmidtNormed f univ\n\n"}
{"name":"gramSchmidtOrthonormalBasis_apply","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁷ : RCLike 𝕜\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝⁴ : LinearOrder ι\ninst✝³ : LocallyFiniteOrderBot ι\ninst✝² : WellFoundedLT ι\ninst✝¹ : Fintype ι\ninst✝ : FiniteDimensional 𝕜 E\nh : Eq (Module.finrank 𝕜 E) (Fintype.card ι)\nf : ι → E\ni : ι\nhi : Ne (gramSchmidtNormed 𝕜 f i) 0\n⊢ Eq ((gramSchmidtOrthonormalBasis h f) i) (gramSchmidtNormed 𝕜 f i)","decl":"theorem gramSchmidtOrthonormalBasis_apply {f : ι → E} {i : ι} (hi : gramSchmidtNormed 𝕜 f i ≠ 0) :\n    gramSchmidtOrthonormalBasis h f i = gramSchmidtNormed 𝕜 f i :=\n  ((gramSchmidt_orthonormal' f).exists_orthonormalBasis_extension_of_card_eq\n    (v := gramSchmidtNormed 𝕜 f) h).choose_spec i hi\n\n"}
{"name":"gramSchmidtOrthonormalBasis_apply_of_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁷ : RCLike 𝕜\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝⁴ : LinearOrder ι\ninst✝³ : LocallyFiniteOrderBot ι\ninst✝² : WellFoundedLT ι\ninst✝¹ : Fintype ι\ninst✝ : FiniteDimensional 𝕜 E\nh : Eq (Module.finrank 𝕜 E) (Fintype.card ι)\nf : ι → E\nhf : Pairwise fun i j => Eq (Inner.inner (f i) (f j)) 0\ni : ι\nhi : Ne (f i) 0\n⊢ Eq ((gramSchmidtOrthonormalBasis h f) i) (HSMul.hSMul (Inv.inv ↑(Norm.norm (f i))) (f i))","decl":"theorem gramSchmidtOrthonormalBasis_apply_of_orthogonal {f : ι → E}\n    (hf : Pairwise fun i j => ⟪f i, f j⟫ = 0) {i : ι} (hi : f i ≠ 0) :\n    gramSchmidtOrthonormalBasis h f i = (‖f i‖⁻¹ : 𝕜) • f i := by\n  have H : gramSchmidtNormed 𝕜 f i = (‖f i‖⁻¹ : 𝕜) • f i := by\n    rw [gramSchmidtNormed, gramSchmidt_of_orthogonal 𝕜 hf]\n  rw [gramSchmidtOrthonormalBasis_apply h, H]\n  simpa [H] using hi\n\n"}
{"name":"inner_gramSchmidtOrthonormalBasis_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁷ : RCLike 𝕜\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝⁴ : LinearOrder ι\ninst✝³ : LocallyFiniteOrderBot ι\ninst✝² : WellFoundedLT ι\ninst✝¹ : Fintype ι\ninst✝ : FiniteDimensional 𝕜 E\nh : Eq (Module.finrank 𝕜 E) (Fintype.card ι)\nf : ι → E\ni : ι\nhi : Eq (gramSchmidtNormed 𝕜 f i) 0\nj : ι\n⊢ Eq (Inner.inner ((gramSchmidtOrthonormalBasis h f) i) (f j)) 0","decl":"theorem inner_gramSchmidtOrthonormalBasis_eq_zero {f : ι → E} {i : ι}\n    (hi : gramSchmidtNormed 𝕜 f i = 0) (j : ι) : ⟪gramSchmidtOrthonormalBasis h f i, f j⟫ = 0 := by\n  rw [← mem_orthogonal_singleton_iff_inner_right]\n  suffices span 𝕜 (gramSchmidtNormed 𝕜 f '' Set.Iic j) ⟂ 𝕜 ∙ gramSchmidtOrthonormalBasis h f i by\n    apply this\n    rw [span_gramSchmidtNormed]\n    exact mem_span_gramSchmidt 𝕜 f le_rfl\n  rw [isOrtho_span]\n  rintro u ⟨k, _, rfl⟩ v (rfl : v = _)\n  by_cases hk : gramSchmidtNormed 𝕜 f k = 0\n  · rw [hk, inner_zero_left]\n  rw [← gramSchmidtOrthonormalBasis_apply h hk]\n  have : k ≠ i := by\n    rintro rfl\n    exact hk hi\n  exact (gramSchmidtOrthonormalBasis h f).orthonormal.2 this\n\n"}
{"name":"gramSchmidtOrthonormalBasis_inv_triangular","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁷ : RCLike 𝕜\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝⁴ : LinearOrder ι\ninst✝³ : LocallyFiniteOrderBot ι\ninst✝² : WellFoundedLT ι\ninst✝¹ : Fintype ι\ninst✝ : FiniteDimensional 𝕜 E\nh : Eq (Module.finrank 𝕜 E) (Fintype.card ι)\nf : ι → E\ni j : ι\nhij : LT.lt i j\n⊢ Eq (Inner.inner ((gramSchmidtOrthonormalBasis h f) j) (f i)) 0","decl":"theorem gramSchmidtOrthonormalBasis_inv_triangular {i j : ι} (hij : i < j) :\n    ⟪gramSchmidtOrthonormalBasis h f j, f i⟫ = 0 := by\n  by_cases hi : gramSchmidtNormed 𝕜 f j = 0\n  · rw [inner_gramSchmidtOrthonormalBasis_eq_zero h hi]\n  · simp [gramSchmidtOrthonormalBasis_apply h hi, gramSchmidtNormed, inner_smul_left,\n      gramSchmidt_inv_triangular 𝕜 f hij]\n\n"}
{"name":"gramSchmidtOrthonormalBasis_inv_triangular'","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁷ : RCLike 𝕜\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝⁴ : LinearOrder ι\ninst✝³ : LocallyFiniteOrderBot ι\ninst✝² : WellFoundedLT ι\ninst✝¹ : Fintype ι\ninst✝ : FiniteDimensional 𝕜 E\nh : Eq (Module.finrank 𝕜 E) (Fintype.card ι)\nf : ι → E\ni j : ι\nhij : LT.lt i j\n⊢ Eq ((gramSchmidtOrthonormalBasis h f).repr (f i) j) 0","decl":"theorem gramSchmidtOrthonormalBasis_inv_triangular' {i j : ι} (hij : i < j) :\n    (gramSchmidtOrthonormalBasis h f).repr (f i) j = 0 := by\n  simpa [OrthonormalBasis.repr_apply_apply] using gramSchmidtOrthonormalBasis_inv_triangular h f hij\n\n"}
{"name":"gramSchmidtOrthonormalBasis_inv_blockTriangular","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁷ : RCLike 𝕜\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝⁴ : LinearOrder ι\ninst✝³ : LocallyFiniteOrderBot ι\ninst✝² : WellFoundedLT ι\ninst✝¹ : Fintype ι\ninst✝ : FiniteDimensional 𝕜 E\nh : Eq (Module.finrank 𝕜 E) (Fintype.card ι)\nf : ι → E\n⊢ ((gramSchmidtOrthonormalBasis h f).toBasis.toMatrix f).BlockTriangular id","decl":"/-- Given an indexed family `f : ι → E` of vectors in an inner product space `E`, for which the\nsize of the index set is the dimension of `E`, the matrix of coefficients of `f` with respect to the\northonormal basis `gramSchmidtOrthonormalBasis` constructed from `f` is upper-triangular. -/\ntheorem gramSchmidtOrthonormalBasis_inv_blockTriangular :\n    ((gramSchmidtOrthonormalBasis h f).toBasis.toMatrix f).BlockTriangular id := fun _ _ =>\n  gramSchmidtOrthonormalBasis_inv_triangular' h f\n\n-- Porting note: added a `DecidableEq` argument to help with timeouts in\n-- `Mathlib/Analysis/InnerProductSpace/Orientation.lean`\n"}
{"name":"gramSchmidtOrthonormalBasis_det","module":"Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁸ : RCLike 𝕜\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : InnerProductSpace 𝕜 E\nι : Type u_3\ninst✝⁵ : LinearOrder ι\ninst✝⁴ : LocallyFiniteOrderBot ι\ninst✝³ : WellFoundedLT ι\ninst✝² : Fintype ι\ninst✝¹ : FiniteDimensional 𝕜 E\nh : Eq (Module.finrank 𝕜 E) (Fintype.card ι)\nf : ι → E\ninst✝ : DecidableEq ι\n⊢ Eq ((gramSchmidtOrthonormalBasis h f).toBasis.det f) (Finset.univ.prod fun i => Inner.inner ((gramSchmidtOrthonormalBasis h f) i) (f i))","decl":"theorem gramSchmidtOrthonormalBasis_det [DecidableEq ι] :\n    (gramSchmidtOrthonormalBasis h f).toBasis.det f =\n      ∏ i, ⟪gramSchmidtOrthonormalBasis h f i, f i⟫ := by\n  convert Matrix.det_of_upperTriangular (gramSchmidtOrthonormalBasis_inv_blockTriangular h f)\n  exact ((gramSchmidtOrthonormalBasis h f).repr_apply_apply (f _) _).symm\n\n"}
