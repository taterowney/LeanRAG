{"name":"Filter.rmap_sets","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nr : Rel Œ± Œ≤\nl : Filter Œ±\n‚ä¢ Eq (Filter.rmap r l).sets (Set.preimage r.core l.sets)","decl":"theorem rmap_sets (r : Rel Œ± Œ≤) (l : Filter Œ±) : (l.rmap r).sets = r.core ‚Åª¬π' l.sets :=\n  rfl\n\n"}
{"name":"Filter.mem_rmap","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nr : Rel Œ± Œ≤\nl : Filter Œ±\ns : Set Œ≤\n‚ä¢ Iff (Membership.mem (Filter.rmap r l) s) (Membership.mem l (r.core s))","decl":"@[simp]\ntheorem mem_rmap (r : Rel Œ± Œ≤) (l : Filter Œ±) (s : Set Œ≤) : s ‚àà l.rmap r ‚Üî r.core s ‚àà l :=\n  Iff.rfl\n\n"}
{"name":"Filter.rmap_rmap","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\nr : Rel Œ± Œ≤\ns : Rel Œ≤ Œ≥\nl : Filter Œ±\n‚ä¢ Eq (Filter.rmap s (Filter.rmap r l)) (Filter.rmap (r.comp s) l)","decl":"@[simp]\ntheorem rmap_rmap (r : Rel Œ± Œ≤) (s : Rel Œ≤ Œ≥) (l : Filter Œ±) :\n    rmap s (rmap r l) = rmap (r.comp s) l :=\n  filter_eq <| by simp [rmap_sets, Set.preimage, Rel.core_comp]\n\n"}
{"name":"Filter.rmap_compose","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\nr : Rel Œ± Œ≤\ns : Rel Œ≤ Œ≥\n‚ä¢ Eq (Function.comp (Filter.rmap s) (Filter.rmap r)) (Filter.rmap (r.comp s))","decl":"@[simp]\ntheorem rmap_compose (r : Rel Œ± Œ≤) (s : Rel Œ≤ Œ≥) : rmap s ‚àò rmap r = rmap (r.comp s) :=\n  funext <| rmap_rmap _ _\n\n"}
{"name":"Filter.rtendsto_def","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nr : Rel Œ± Œ≤\nl‚ÇÅ : Filter Œ±\nl‚ÇÇ : Filter Œ≤\n‚ä¢ Iff (Filter.RTendsto r l‚ÇÅ l‚ÇÇ) (‚àÄ (s : Set Œ≤), Membership.mem l‚ÇÇ s ‚Üí Membership.mem l‚ÇÅ (r.core s))","decl":"theorem rtendsto_def (r : Rel Œ± Œ≤) (l‚ÇÅ : Filter Œ±) (l‚ÇÇ : Filter Œ≤) :\n    RTendsto r l‚ÇÅ l‚ÇÇ ‚Üî ‚àÄ s ‚àà l‚ÇÇ, r.core s ‚àà l‚ÇÅ :=\n  Iff.rfl\n\n"}
{"name":"Filter.rcomap_sets","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nr : Rel Œ± Œ≤\nf : Filter Œ≤\n‚ä¢ Eq (Filter.rcomap r f).sets (Rel.image (fun s t => HasSubset.Subset (r.core s) t) f.sets)","decl":"theorem rcomap_sets (r : Rel Œ± Œ≤) (f : Filter Œ≤) :\n    (rcomap r f).sets = Rel.image (fun s t => r.core s ‚äÜ t) f.sets :=\n  rfl\n\n"}
{"name":"Filter.rcomap_rcomap","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\nr : Rel Œ± Œ≤\ns : Rel Œ≤ Œ≥\nl : Filter Œ≥\n‚ä¢ Eq (Filter.rcomap r (Filter.rcomap s l)) (Filter.rcomap (r.comp s) l)","decl":"theorem rcomap_rcomap (r : Rel Œ± Œ≤) (s : Rel Œ≤ Œ≥) (l : Filter Œ≥) :\n    rcomap r (rcomap s l) = rcomap (r.comp s) l :=\n  filter_eq <| by\n    ext t; simp only [rcomap_sets, Rel.image, Filter.mem_sets, Set.mem_setOf_eq, Rel.core_comp]\n    constructor\n    ¬∑ rintro ‚ü®u, ‚ü®v, vsets, hv‚ü©, h‚ü©\n      exact ‚ü®v, vsets, Set.Subset.trans (Rel.core_mono _ hv) h‚ü©\n    rintro ‚ü®t, tsets, ht‚ü©\n    exact ‚ü®Rel.core s t, ‚ü®t, tsets, Set.Subset.rfl‚ü©, ht‚ü©\n\n"}
{"name":"Filter.rcomap_compose","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\nr : Rel Œ± Œ≤\ns : Rel Œ≤ Œ≥\n‚ä¢ Eq (Function.comp (Filter.rcomap r) (Filter.rcomap s)) (Filter.rcomap (r.comp s))","decl":"@[simp]\ntheorem rcomap_compose (r : Rel Œ± Œ≤) (s : Rel Œ≤ Œ≥) : rcomap r ‚àò rcomap s = rcomap (r.comp s) :=\n  funext <| rcomap_rcomap _ _\n\n"}
{"name":"Filter.rtendsto_iff_le_rcomap","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nr : Rel Œ± Œ≤\nl‚ÇÅ : Filter Œ±\nl‚ÇÇ : Filter Œ≤\n‚ä¢ Iff (Filter.RTendsto r l‚ÇÅ l‚ÇÇ) (LE.le l‚ÇÅ (Filter.rcomap r l‚ÇÇ))","decl":"theorem rtendsto_iff_le_rcomap (r : Rel Œ± Œ≤) (l‚ÇÅ : Filter Œ±) (l‚ÇÇ : Filter Œ≤) :\n    RTendsto r l‚ÇÅ l‚ÇÇ ‚Üî l‚ÇÅ ‚â§ l‚ÇÇ.rcomap r := by\n  rw [rtendsto_def]\n  simp_rw [‚Üê l‚ÇÇ.mem_sets]\n  constructor\n  ¬∑ simpa [Filter.le_def, rcomap, Rel.mem_image] using fun h s t tl‚ÇÇ => mem_of_superset (h t tl‚ÇÇ)\n  ¬∑ simpa [Filter.le_def, rcomap, Rel.mem_image] using fun h t tl‚ÇÇ => h _ t tl‚ÇÇ Set.Subset.rfl\n\n-- Interestingly, there does not seem to be a way to express this relation using a forward map.\n-- Given a filter `f` on `Œ±`, we want a filter `f'` on `Œ≤` such that `r.preimage s ‚àà f` if\n-- and only if `s ‚àà f'`. But the intersection of two sets satisfying the lhs may be empty.\n"}
{"name":"Filter.mem_rcomap'","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nr : Rel Œ± Œ≤\nl : Filter Œ≤\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (Filter.rcomap' r l) s) (Exists fun t => And (Membership.mem l t) (HasSubset.Subset (r.preimage t) s))","decl":"@[simp]\ntheorem mem_rcomap' (r : Rel Œ± Œ≤) (l : Filter Œ≤) (s : Set Œ±) :\n    s ‚àà l.rcomap' r ‚Üî ‚àÉ t ‚àà l, r.preimage t ‚äÜ s :=\n  Iff.rfl\n\n"}
{"name":"Filter.rcomap'_sets","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nr : Rel Œ± Œ≤\nf : Filter Œ≤\n‚ä¢ Eq (Filter.rcomap' r f).sets (Rel.image (fun s t => HasSubset.Subset (r.preimage s) t) f.sets)","decl":"theorem rcomap'_sets (r : Rel Œ± Œ≤) (f : Filter Œ≤) :\n    (rcomap' r f).sets = Rel.image (fun s t => r.preimage s ‚äÜ t) f.sets :=\n  rfl\n\n"}
{"name":"Filter.rcomap'_rcomap'","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\nr : Rel Œ± Œ≤\ns : Rel Œ≤ Œ≥\nl : Filter Œ≥\n‚ä¢ Eq (Filter.rcomap' r (Filter.rcomap' s l)) (Filter.rcomap' (r.comp s) l)","decl":"@[simp]\ntheorem rcomap'_rcomap' (r : Rel Œ± Œ≤) (s : Rel Œ≤ Œ≥) (l : Filter Œ≥) :\n    rcomap' r (rcomap' s l) = rcomap' (r.comp s) l :=\n  Filter.ext fun t => by\n    simp only [mem_rcomap', Rel.preimage_comp]\n    constructor\n    ¬∑ rintro ‚ü®u, ‚ü®v, vsets, hv‚ü©, h‚ü©\n      exact ‚ü®v, vsets, (Rel.preimage_mono _ hv).trans h‚ü©\n    rintro ‚ü®t, tsets, ht‚ü©\n    exact ‚ü®s.preimage t, ‚ü®t, tsets, Set.Subset.rfl‚ü©, ht‚ü©\n\n"}
{"name":"Filter.rcomap'_compose","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\nr : Rel Œ± Œ≤\ns : Rel Œ≤ Œ≥\n‚ä¢ Eq (Function.comp (Filter.rcomap' r) (Filter.rcomap' s)) (Filter.rcomap' (r.comp s))","decl":"@[simp]\ntheorem rcomap'_compose (r : Rel Œ± Œ≤) (s : Rel Œ≤ Œ≥) : rcomap' r ‚àò rcomap' s = rcomap' (r.comp s) :=\n  funext <| rcomap'_rcomap' _ _\n\n"}
{"name":"Filter.rtendsto'_def","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nr : Rel Œ± Œ≤\nl‚ÇÅ : Filter Œ±\nl‚ÇÇ : Filter Œ≤\n‚ä¢ Iff (Filter.RTendsto' r l‚ÇÅ l‚ÇÇ) (‚àÄ (s : Set Œ≤), Membership.mem l‚ÇÇ s ‚Üí Membership.mem l‚ÇÅ (r.preimage s))","decl":"theorem rtendsto'_def (r : Rel Œ± Œ≤) (l‚ÇÅ : Filter Œ±) (l‚ÇÇ : Filter Œ≤) :\n    RTendsto' r l‚ÇÅ l‚ÇÇ ‚Üî ‚àÄ s ‚àà l‚ÇÇ, r.preimage s ‚àà l‚ÇÅ := by\n  unfold RTendsto' rcomap'; constructor\n  ¬∑ simpa [le_def, Rel.mem_image] using fun h s hs => h _ _ hs Set.Subset.rfl\n  ¬∑ simpa [le_def, Rel.mem_image] using fun h s t ht => mem_of_superset (h t ht)\n\n"}
{"name":"Filter.tendsto_iff_rtendsto","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nl‚ÇÅ : Filter Œ±\nl‚ÇÇ : Filter Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (Filter.Tendsto f l‚ÇÅ l‚ÇÇ) (Filter.RTendsto (Function.graph f) l‚ÇÅ l‚ÇÇ)","decl":"theorem tendsto_iff_rtendsto (l‚ÇÅ : Filter Œ±) (l‚ÇÇ : Filter Œ≤) (f : Œ± ‚Üí Œ≤) :\n    Tendsto f l‚ÇÅ l‚ÇÇ ‚Üî RTendsto (Function.graph f) l‚ÇÅ l‚ÇÇ := by\n  simp [tendsto_def, Function.graph, rtendsto_def, Rel.core, Set.preimage]\n\n"}
{"name":"Filter.tendsto_iff_rtendsto'","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nl‚ÇÅ : Filter Œ±\nl‚ÇÇ : Filter Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (Filter.Tendsto f l‚ÇÅ l‚ÇÇ) (Filter.RTendsto' (Function.graph f) l‚ÇÅ l‚ÇÇ)","decl":"theorem tendsto_iff_rtendsto' (l‚ÇÅ : Filter Œ±) (l‚ÇÇ : Filter Œ≤) (f : Œ± ‚Üí Œ≤) :\n    Tendsto f l‚ÇÅ l‚ÇÇ ‚Üî RTendsto' (Function.graph f) l‚ÇÅ l‚ÇÇ := by\n  simp [tendsto_def, Function.graph, rtendsto'_def, Rel.preimage_def, Set.preimage]\n\n"}
{"name":"Filter.mem_pmap","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : PFun Œ± Œ≤\nl : Filter Œ±\ns : Set Œ≤\n‚ä¢ Iff (Membership.mem (Filter.pmap f l) s) (Membership.mem l (f.core s))","decl":"@[simp]\ntheorem mem_pmap (f : Œ± ‚Üí. Œ≤) (l : Filter Œ±) (s : Set Œ≤) : s ‚àà l.pmap f ‚Üî f.core s ‚àà l :=\n  Iff.rfl\n\n"}
{"name":"Filter.ptendsto_def","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : PFun Œ± Œ≤\nl‚ÇÅ : Filter Œ±\nl‚ÇÇ : Filter Œ≤\n‚ä¢ Iff (Filter.PTendsto f l‚ÇÅ l‚ÇÇ) (‚àÄ (s : Set Œ≤), Membership.mem l‚ÇÇ s ‚Üí Membership.mem l‚ÇÅ (f.core s))","decl":"theorem ptendsto_def (f : Œ± ‚Üí. Œ≤) (l‚ÇÅ : Filter Œ±) (l‚ÇÇ : Filter Œ≤) :\n    PTendsto f l‚ÇÅ l‚ÇÇ ‚Üî ‚àÄ s ‚àà l‚ÇÇ, f.core s ‚àà l‚ÇÅ :=\n  Iff.rfl\n\n"}
{"name":"Filter.ptendsto_iff_rtendsto","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nl‚ÇÅ : Filter Œ±\nl‚ÇÇ : Filter Œ≤\nf : PFun Œ± Œ≤\n‚ä¢ Iff (Filter.PTendsto f l‚ÇÅ l‚ÇÇ) (Filter.RTendsto f.graph' l‚ÇÅ l‚ÇÇ)","decl":"theorem ptendsto_iff_rtendsto (l‚ÇÅ : Filter Œ±) (l‚ÇÇ : Filter Œ≤) (f : Œ± ‚Üí. Œ≤) :\n    PTendsto f l‚ÇÅ l‚ÇÇ ‚Üî RTendsto f.graph' l‚ÇÅ l‚ÇÇ :=\n  Iff.rfl\n\n"}
{"name":"Filter.pmap_res","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nl : Filter Œ±\ns : Set Œ±\nf : Œ± ‚Üí Œ≤\n‚ä¢ Eq (Filter.pmap (PFun.res f s) l) (Filter.map f (Min.min l (Filter.principal s)))","decl":"theorem pmap_res (l : Filter Œ±) (s : Set Œ±) (f : Œ± ‚Üí Œ≤) :\n    pmap (PFun.res f s) l = map f (l ‚äì ùìü s) := by\n  ext t\n  simp only [PFun.core_res, mem_pmap, mem_map, mem_inf_principal, imp_iff_not_or]\n  rfl\n\n"}
{"name":"Filter.tendsto_iff_ptendsto","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nl‚ÇÅ : Filter Œ±\nl‚ÇÇ : Filter Œ≤\ns : Set Œ±\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (Filter.Tendsto f (Min.min l‚ÇÅ (Filter.principal s)) l‚ÇÇ) (Filter.PTendsto (PFun.res f s) l‚ÇÅ l‚ÇÇ)","decl":"theorem tendsto_iff_ptendsto (l‚ÇÅ : Filter Œ±) (l‚ÇÇ : Filter Œ≤) (s : Set Œ±) (f : Œ± ‚Üí Œ≤) :\n    Tendsto f (l‚ÇÅ ‚äì ùìü s) l‚ÇÇ ‚Üî PTendsto (PFun.res f s) l‚ÇÅ l‚ÇÇ := by\n  simp only [Tendsto, PTendsto, pmap_res]\n\n"}
{"name":"Filter.tendsto_iff_ptendsto_univ","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nl‚ÇÅ : Filter Œ±\nl‚ÇÇ : Filter Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (Filter.Tendsto f l‚ÇÅ l‚ÇÇ) (Filter.PTendsto (PFun.res f Set.univ) l‚ÇÅ l‚ÇÇ)","decl":"theorem tendsto_iff_ptendsto_univ (l‚ÇÅ : Filter Œ±) (l‚ÇÇ : Filter Œ≤) (f : Œ± ‚Üí Œ≤) :\n    Tendsto f l‚ÇÅ l‚ÇÇ ‚Üî PTendsto (PFun.res f Set.univ) l‚ÇÅ l‚ÇÇ := by\n  rw [‚Üê tendsto_iff_ptendsto]\n  simp [principal_univ]\n\n"}
{"name":"Filter.ptendsto'_def","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : PFun Œ± Œ≤\nl‚ÇÅ : Filter Œ±\nl‚ÇÇ : Filter Œ≤\n‚ä¢ Iff (Filter.PTendsto' f l‚ÇÅ l‚ÇÇ) (‚àÄ (s : Set Œ≤), Membership.mem l‚ÇÇ s ‚Üí Membership.mem l‚ÇÅ (f.preimage s))","decl":"theorem ptendsto'_def (f : Œ± ‚Üí. Œ≤) (l‚ÇÅ : Filter Œ±) (l‚ÇÇ : Filter Œ≤) :\n    PTendsto' f l‚ÇÅ l‚ÇÇ ‚Üî ‚àÄ s ‚àà l‚ÇÇ, f.preimage s ‚àà l‚ÇÅ :=\n  rtendsto'_def _ _ _\n\n"}
{"name":"Filter.ptendsto_of_ptendsto'","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : PFun Œ± Œ≤\nl‚ÇÅ : Filter Œ±\nl‚ÇÇ : Filter Œ≤\na‚úù : Filter.PTendsto' f l‚ÇÅ l‚ÇÇ\n‚ä¢ Filter.PTendsto f l‚ÇÅ l‚ÇÇ","decl":"theorem ptendsto_of_ptendsto' {f : Œ± ‚Üí. Œ≤} {l‚ÇÅ : Filter Œ±} {l‚ÇÇ : Filter Œ≤} :\n    PTendsto' f l‚ÇÅ l‚ÇÇ ‚Üí PTendsto f l‚ÇÅ l‚ÇÇ := by\n  rw [ptendsto_def, ptendsto'_def]\n  exact fun h s sl‚ÇÇ => mem_of_superset (h s sl‚ÇÇ) (PFun.preimage_subset_core _ _)\n\n"}
{"name":"Filter.ptendsto'_of_ptendsto","module":"Mathlib.Order.Filter.Partial","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : PFun Œ± Œ≤\nl‚ÇÅ : Filter Œ±\nl‚ÇÇ : Filter Œ≤\nh : Membership.mem l‚ÇÅ f.Dom\na‚úù : Filter.PTendsto f l‚ÇÅ l‚ÇÇ\n‚ä¢ Filter.PTendsto' f l‚ÇÅ l‚ÇÇ","decl":"theorem ptendsto'_of_ptendsto {f : Œ± ‚Üí. Œ≤} {l‚ÇÅ : Filter Œ±} {l‚ÇÇ : Filter Œ≤} (h : f.Dom ‚àà l‚ÇÅ) :\n    PTendsto f l‚ÇÅ l‚ÇÇ ‚Üí PTendsto' f l‚ÇÅ l‚ÇÇ := by\n  rw [ptendsto_def, ptendsto'_def]\n  intro h' s sl‚ÇÇ\n  rw [PFun.preimage_eq]\n  exact inter_mem (h' s sl‚ÇÇ) h\n\n"}
