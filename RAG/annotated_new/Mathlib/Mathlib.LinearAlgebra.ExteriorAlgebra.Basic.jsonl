{"name":"ExteriorAlgebra.ι_sq_zero","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nm : M\n⊢ Eq (HMul.hMul ((ExteriorAlgebra.ι R) m) ((ExteriorAlgebra.ι R) m)) 0","decl":"/-- As well as being linear, `ι m` squares to zero. -/\ntheorem ι_sq_zero (m : M) : ι R m * ι R m = 0 :=\n  (CliffordAlgebra.ι_sq_scalar _ m).trans <| map_zero _\n\n"}
{"name":"ExteriorAlgebra.comp_ι_sq_zero","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝⁴ : CommRing R\nM : Type u2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nA : Type u_1\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ng : AlgHom R (ExteriorAlgebra R M) A\nm : M\n⊢ Eq (HMul.hMul (g ((ExteriorAlgebra.ι R) m)) (g ((ExteriorAlgebra.ι R) m))) 0","decl":"theorem comp_ι_sq_zero (g : ExteriorAlgebra R M →ₐ[R] A) (m : M) : g (ι R m) * g (ι R m) = 0 := by\n  rw [← map_mul, ι_sq_zero, map_zero]\n\n"}
{"name":"ExteriorAlgebra.lift_symm_apply","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝⁴ : CommRing R\nM : Type u2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nA : Type u_1\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\na✝ : AlgHom R (ExteriorAlgebra R M) A\n⊢ Eq ((ExteriorAlgebra.lift R).symm a✝) ⟨↑((CliffordAlgebra.lift 0).symm a✝), ⋯⟩","decl":"/-- Given a linear map `f : M →ₗ[R] A` into an `R`-algebra `A`, which satisfies the condition:\n`cond : ∀ m : M, f m * f m = 0`, this is the canonical lift of `f` to a morphism of `R`-algebras\nfrom `ExteriorAlgebra R M` to `A`.\n-/\n@[simps! symm_apply]\ndef lift : { f : M →ₗ[R] A // ∀ m, f m * f m = 0 } ≃ (ExteriorAlgebra R M →ₐ[R] A) :=\n  Equiv.trans (Equiv.subtypeEquiv (Equiv.refl _) <| by simp) <| CliffordAlgebra.lift _\n\n"}
{"name":"ExteriorAlgebra.ι_comp_lift","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝⁴ : CommRing R\nM : Type u2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nA : Type u_1\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : LinearMap (RingHom.id R) M A\ncond : ∀ (m : M), Eq (HMul.hMul (f m) (f m)) 0\n⊢ Eq (((ExteriorAlgebra.lift R) ⟨f, cond⟩).toLinearMap.comp (ExteriorAlgebra.ι R)) f","decl":"@[simp]\ntheorem ι_comp_lift (f : M →ₗ[R] A) (cond : ∀ m, f m * f m = 0) :\n    (lift R ⟨f, cond⟩).toLinearMap.comp (ι R) = f :=\n  CliffordAlgebra.ι_comp_lift f _\n\n"}
{"name":"ExteriorAlgebra.lift_ι_apply","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝⁴ : CommRing R\nM : Type u2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nA : Type u_1\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : LinearMap (RingHom.id R) M A\ncond : ∀ (m : M), Eq (HMul.hMul (f m) (f m)) 0\nx : M\n⊢ Eq (((ExteriorAlgebra.lift R) ⟨f, cond⟩) ((ExteriorAlgebra.ι R) x)) (f x)","decl":"@[simp]\ntheorem lift_ι_apply (f : M →ₗ[R] A) (cond : ∀ m, f m * f m = 0) (x) :\n    lift R ⟨f, cond⟩ (ι R x) = f x :=\n  CliffordAlgebra.lift_ι_apply f _ x\n\n"}
{"name":"ExteriorAlgebra.lift_unique","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝⁴ : CommRing R\nM : Type u2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nA : Type u_1\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : LinearMap (RingHom.id R) M A\ncond : ∀ (m : M), Eq (HMul.hMul (f m) (f m)) 0\ng : AlgHom R (ExteriorAlgebra R M) A\n⊢ Iff (Eq (g.toLinearMap.comp (ExteriorAlgebra.ι R)) f) (Eq g ((ExteriorAlgebra.lift R) ⟨f, cond⟩))","decl":"@[simp]\ntheorem lift_unique (f : M →ₗ[R] A) (cond : ∀ m, f m * f m = 0) (g : ExteriorAlgebra R M →ₐ[R] A) :\n    g.toLinearMap.comp (ι R) = f ↔ g = lift R ⟨f, cond⟩ :=\n  CliffordAlgebra.lift_unique f _ _\n\n"}
{"name":"ExteriorAlgebra.lift_comp_ι","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝⁴ : CommRing R\nM : Type u2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nA : Type u_1\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ng : AlgHom R (ExteriorAlgebra R M) A\n⊢ Eq ((ExteriorAlgebra.lift R) ⟨g.toLinearMap.comp (ExteriorAlgebra.ι R), ⋯⟩) g","decl":"@[simp]\ntheorem lift_comp_ι (g : ExteriorAlgebra R M →ₐ[R] A) :\n    lift R ⟨g.toLinearMap.comp (ι R), comp_ι_sq_zero _⟩ = g :=\n  CliffordAlgebra.lift_comp_ι g\n\n"}
{"name":"ExteriorAlgebra.hom_ext_iff","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝⁴ : CommRing R\nM : Type u2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nA : Type u_1\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf g : AlgHom R (ExteriorAlgebra R M) A\n⊢ Iff (Eq f g) (Eq (f.toLinearMap.comp (ExteriorAlgebra.ι R)) (g.toLinearMap.comp (ExteriorAlgebra.ι R)))","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem hom_ext {f g : ExteriorAlgebra R M →ₐ[R] A}\n    (h : f.toLinearMap.comp (ι R) = g.toLinearMap.comp (ι R)) : f = g :=\n  CliffordAlgebra.hom_ext h\n\n"}
{"name":"ExteriorAlgebra.hom_ext","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝⁴ : CommRing R\nM : Type u2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nA : Type u_1\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf g : AlgHom R (ExteriorAlgebra R M) A\nh : Eq (f.toLinearMap.comp (ExteriorAlgebra.ι R)) (g.toLinearMap.comp (ExteriorAlgebra.ι R))\n⊢ Eq f g","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem hom_ext {f g : ExteriorAlgebra R M →ₐ[R] A}\n    (h : f.toLinearMap.comp (ι R) = g.toLinearMap.comp (ι R)) : f = g :=\n  CliffordAlgebra.hom_ext h\n\n"}
{"name":"ExteriorAlgebra.induction","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nC : ExteriorAlgebra R M → Prop\nalgebraMap : ∀ (r : R), C ((_root_.algebraMap R (ExteriorAlgebra R M)) r)\nι : ∀ (x : M), C ((ExteriorAlgebra.ι R) x)\nmul : ∀ (a b : ExteriorAlgebra R M), C a → C b → C (HMul.hMul a b)\nadd : ∀ (a b : ExteriorAlgebra R M), C a → C b → C (HAdd.hAdd a b)\na : ExteriorAlgebra R M\n⊢ C a","decl":"/-- If `C` holds for the `algebraMap` of `r : R` into `ExteriorAlgebra R M`, the `ι` of `x : M`,\nand is preserved under addition and multiplication, then it holds for all of `ExteriorAlgebra R M`.\n-/\n@[elab_as_elim]\ntheorem induction {C : ExteriorAlgebra R M → Prop}\n    (algebraMap : ∀ r, C (algebraMap R (ExteriorAlgebra R M) r)) (ι : ∀ x, C (ι R x))\n    (mul : ∀ a b, C a → C b → C (a * b)) (add : ∀ a b, C a → C b → C (a + b))\n    (a : ExteriorAlgebra R M) : C a :=\n  CliffordAlgebra.induction algebraMap ι mul add a\n\n"}
{"name":"ExteriorAlgebra.algebraMap_leftInverse","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Function.LeftInverse ⇑ExteriorAlgebra.algebraMapInv ⇑(algebraMap R (ExteriorAlgebra R M))","decl":"theorem algebraMap_leftInverse :\n    Function.LeftInverse algebraMapInv (algebraMap R <| ExteriorAlgebra R M) := fun x => by\n  simp [algebraMapInv]\n\n"}
{"name":"ExteriorAlgebra.algebraMap_inj","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : R\n⊢ Iff (Eq ((algebraMap R (ExteriorAlgebra R M)) x) ((algebraMap R (ExteriorAlgebra R M)) y)) (Eq x y)","decl":"@[simp]\ntheorem algebraMap_inj (x y : R) :\n    algebraMap R (ExteriorAlgebra R M) x = algebraMap R (ExteriorAlgebra R M) y ↔ x = y :=\n  (algebraMap_leftInverse M).injective.eq_iff\n\n"}
{"name":"ExteriorAlgebra.algebraMap_eq_zero_iff","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : R\n⊢ Iff (Eq ((algebraMap R (ExteriorAlgebra R M)) x) 0) (Eq x 0)","decl":"@[simp]\ntheorem algebraMap_eq_zero_iff (x : R) : algebraMap R (ExteriorAlgebra R M) x = 0 ↔ x = 0 :=\n  map_eq_zero_iff (algebraMap _ _) (algebraMap_leftInverse _).injective\n\n"}
{"name":"ExteriorAlgebra.algebraMap_eq_one_iff","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : R\n⊢ Iff (Eq ((algebraMap R (ExteriorAlgebra R M)) x) 1) (Eq x 1)","decl":"@[simp]\ntheorem algebraMap_eq_one_iff (x : R) : algebraMap R (ExteriorAlgebra R M) x = 1 ↔ x = 1 :=\n  map_eq_one_iff (algebraMap _ _) (algebraMap_leftInverse _).injective\n\n"}
{"name":"ExteriorAlgebra.isLocalHom_algebraMap","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ IsLocalHom (algebraMap R (ExteriorAlgebra R M))","decl":"@[instance]\ntheorem isLocalHom_algebraMap : IsLocalHom (algebraMap R (ExteriorAlgebra R M)) :=\n  isLocalHom_of_leftInverse _ (algebraMap_leftInverse M)\n\n"}
{"name":"ExteriorAlgebra.isLocalRingHom_algebraMap","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ IsLocalHom (algebraMap R (ExteriorAlgebra R M))","decl":"@[deprecated (since := \"2024-10-10\")]\nalias isLocalRingHom_algebraMap := isLocalHom_algebraMap\n\n"}
{"name":"ExteriorAlgebra.isUnit_algebraMap","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\n⊢ Iff (IsUnit ((algebraMap R (ExteriorAlgebra R M)) r)) (IsUnit r)","decl":"theorem isUnit_algebraMap (r : R) : IsUnit (algebraMap R (ExteriorAlgebra R M) r) ↔ IsUnit r :=\n  isUnit_map_of_leftInverse _ (algebraMap_leftInverse M)\n\n"}
{"name":"ExteriorAlgebra.invertibleAlgebraMapEquiv_symm_apply_invOf_toQuot","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\nx✝ : Invertible r\n⊢ Eq (Invertible.invOf ((algebraMap R (ExteriorAlgebra R M)) r)).toQuot (Quot.mk (RingQuot.Rel (CliffordAlgebra.Rel 0)) ((algebraMap R (TensorAlgebra R M)) (Invertible.invOf r)))","decl":"/-- Invertibility in the exterior algebra is the same as invertibility of the base ring. -/\n@[simps!]\ndef invertibleAlgebraMapEquiv (r : R) :\n    Invertible (algebraMap R (ExteriorAlgebra R M) r) ≃ Invertible r :=\n  invertibleEquivOfLeftInverse _ _ _ (algebraMap_leftInverse M)\n\n"}
{"name":"ExteriorAlgebra.invertibleAlgebraMapEquiv_apply_invOf","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\nx✝ : Invertible ((algebraMap R (ExteriorAlgebra R M)) r)\n⊢ Eq (Invertible.invOf r) (Invertible.invOf (ExteriorAlgebra.algebraMapInv ((algebraMap R (ExteriorAlgebra R M)) r)))","decl":"/-- Invertibility in the exterior algebra is the same as invertibility of the base ring. -/\n@[simps!]\ndef invertibleAlgebraMapEquiv (r : R) :\n    Invertible (algebraMap R (ExteriorAlgebra R M) r) ≃ Invertible r :=\n  invertibleEquivOfLeftInverse _ _ _ (algebraMap_leftInverse M)\n\n"}
{"name":"ExteriorAlgebra.toTrivSqZeroExt_ι","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝⁴ : CommRing R\nM : Type u2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module (MulOpposite R) M\ninst✝ : IsCentralScalar R M\nx : M\n⊢ Eq (ExteriorAlgebra.toTrivSqZeroExt ((ExteriorAlgebra.ι R) x)) (TrivSqZeroExt.inr x)","decl":"@[simp]\ntheorem toTrivSqZeroExt_ι [Module Rᵐᵒᵖ M] [IsCentralScalar R M] (x : M) :\n    toTrivSqZeroExt (ι R x) = TrivSqZeroExt.inr x :=\n  lift_ι_apply _ _ _ _\n\n"}
{"name":"ExteriorAlgebra.ι_leftInverse","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Function.LeftInverse ⇑ExteriorAlgebra.ιInv ⇑(ExteriorAlgebra.ι R)","decl":"theorem ι_leftInverse : Function.LeftInverse ιInv (ι R : M → ExteriorAlgebra R M) := fun x => by\n  -- Porting note: Original proof didn't have `letI` and `haveI`\n  letI : Module Rᵐᵒᵖ M := Module.compHom _ ((RingHom.id R).fromOpposite mul_comm)\n  haveI : IsCentralScalar R M := ⟨fun r m => rfl⟩\n  simp [ιInv]\n\n"}
{"name":"ExteriorAlgebra.ι_inj","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\n⊢ Iff (Eq ((ExteriorAlgebra.ι R) x) ((ExteriorAlgebra.ι R) y)) (Eq x y)","decl":"@[simp]\ntheorem ι_inj (x y : M) : ι R x = ι R y ↔ x = y :=\n  ι_leftInverse.injective.eq_iff\n\n"}
{"name":"ExteriorAlgebra.ι_eq_zero_iff","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : M\n⊢ Iff (Eq ((ExteriorAlgebra.ι R) x) 0) (Eq x 0)","decl":"@[simp]\ntheorem ι_eq_zero_iff (x : M) : ι R x = 0 ↔ x = 0 := by rw [← ι_inj R x 0, LinearMap.map_zero]\n\n"}
{"name":"ExteriorAlgebra.ι_eq_algebraMap_iff","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : M\nr : R\n⊢ Iff (Eq ((ExteriorAlgebra.ι R) x) ((algebraMap R (ExteriorAlgebra R M)) r)) (And (Eq x 0) (Eq r 0))","decl":"@[simp]\ntheorem ι_eq_algebraMap_iff (x : M) (r : R) : ι R x = algebraMap R _ r ↔ x = 0 ∧ r = 0 := by\n  refine ⟨fun h => ?_, ?_⟩\n  · letI : Module Rᵐᵒᵖ M := Module.compHom _ ((RingHom.id R).fromOpposite mul_comm)\n    haveI : IsCentralScalar R M := ⟨fun r m => rfl⟩\n    have hf0 : toTrivSqZeroExt (ι R x) = (0, x) := toTrivSqZeroExt_ι _\n    rw [h, AlgHom.commutes] at hf0\n    have : r = 0 ∧ 0 = x := Prod.ext_iff.1 hf0\n    exact this.symm.imp_left Eq.symm\n  · rintro ⟨rfl, rfl⟩\n    rw [LinearMap.map_zero, RingHom.map_zero]\n\n"}
{"name":"ExteriorAlgebra.ι_ne_one","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝³ : CommRing R\nM : Type u2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\nx : M\n⊢ Ne ((ExteriorAlgebra.ι R) x) 1","decl":"@[simp]\ntheorem ι_ne_one [Nontrivial R] (x : M) : ι R x ≠ 1 := by\n  rw [← (algebraMap R (ExteriorAlgebra R M)).map_one, Ne, ι_eq_algebraMap_iff]\n  exact one_ne_zero ∘ And.right\n\n"}
{"name":"ExteriorAlgebra.ι_range_disjoint_one","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Disjoint (LinearMap.range (ExteriorAlgebra.ι R)) 1","decl":"/-- The generators of the exterior algebra are disjoint from its scalars. -/\ntheorem ι_range_disjoint_one :\n    Disjoint (LinearMap.range (ι R : M →ₗ[R] ExteriorAlgebra R M))\n      (1 : Submodule R (ExteriorAlgebra R M)) := by\n  rw [Submodule.disjoint_def]\n  rintro _ ⟨x, hx⟩ h\n  obtain ⟨r, rfl : algebraMap R (ExteriorAlgebra R M) r = _⟩ := Submodule.mem_one.mp h\n  rw [ι_eq_algebraMap_iff x] at hx\n  rw [hx.2, RingHom.map_zero]\n\n"}
{"name":"ExteriorAlgebra.ι_add_mul_swap","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\n⊢ Eq (HAdd.hAdd (HMul.hMul ((ExteriorAlgebra.ι R) x) ((ExteriorAlgebra.ι R) y)) (HMul.hMul ((ExteriorAlgebra.ι R) y) ((ExteriorAlgebra.ι R) x))) 0","decl":"@[simp]\ntheorem ι_add_mul_swap (x y : M) : ι R x * ι R y + ι R y * ι R x = 0 :=\n  CliffordAlgebra.ι_mul_ι_add_swap_of_isOrtho <| .all _ _\n\n"}
{"name":"ExteriorAlgebra.ι_mul_prod_list","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nf : Fin n → M\ni : Fin n\n⊢ Eq (HMul.hMul ((ExteriorAlgebra.ι R) (f i)) (List.ofFn fun i => (ExteriorAlgebra.ι R) (f i)).prod) 0","decl":"theorem ι_mul_prod_list {n : ℕ} (f : Fin n → M) (i : Fin n) :\n    (ι R <| f i) * (List.ofFn fun i => ι R <| f i).prod = 0 := by\n  induction n with\n  | zero => exact i.elim0\n  | succ n hn =>\n    rw [List.ofFn_succ, List.prod_cons, ← mul_assoc]\n    by_cases h : i = 0\n    · rw [h, ι_sq_zero, zero_mul]\n    · replace hn :=\n        congr_arg (ι R (f 0) * ·) <| hn (fun i => f <| Fin.succ i) (i.pred h)\n      simp only at hn\n      rw [Fin.succ_pred, ← mul_assoc, mul_zero] at hn\n      refine (eq_zero_iff_eq_zero_of_add_eq_zero ?_).mp hn\n      rw [← add_mul, ι_add_mul_swap, zero_mul]\n\n"}
{"name":"ExteriorAlgebra.ιMulti_apply","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nv : Fin n → M\n⊢ Eq ((ExteriorAlgebra.ιMulti R n) v) (List.ofFn fun i => (ExteriorAlgebra.ι R) (v i)).prod","decl":"theorem ιMulti_apply {n : ℕ} (v : Fin n → M) : ιMulti R n v = (List.ofFn fun i => ι R (v i)).prod :=\n  rfl\n\n"}
{"name":"ExteriorAlgebra.ιMulti_zero_apply","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nv : Fin 0 → M\n⊢ Eq ((ExteriorAlgebra.ιMulti R 0) v) 1","decl":"@[simp]\ntheorem ιMulti_zero_apply (v : Fin 0 → M) : ιMulti R 0 v = 1 := by\n  simp [ιMulti]\n\n"}
{"name":"ExteriorAlgebra.ιMulti_succ_apply","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nv : Fin n.succ → M\n⊢ Eq ((ExteriorAlgebra.ιMulti R n.succ) v) (HMul.hMul ((ExteriorAlgebra.ι R) (v 0)) ((ExteriorAlgebra.ιMulti R n) (Matrix.vecTail v)))","decl":"@[simp]\ntheorem ιMulti_succ_apply {n : ℕ} (v : Fin n.succ → M) :\n    ιMulti R _ v = ι R (v 0) * ιMulti R _ (Matrix.vecTail v) := by\n  simp [ιMulti, Matrix.vecTail]\n\n"}
{"name":"ExteriorAlgebra.ιMulti_succ_curryLeft","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nm : M\n⊢ Eq ((ExteriorAlgebra.ιMulti R n.succ).curryLeft m) ((LinearMap.mulLeft R ((ExteriorAlgebra.ι R) m)).compAlternatingMap (ExteriorAlgebra.ιMulti R n))","decl":"theorem ιMulti_succ_curryLeft {n : ℕ} (m : M) :\n    (ιMulti R n.succ).curryLeft m = (LinearMap.mulLeft R (ι R m)).compAlternatingMap (ιMulti R n) :=\n  AlternatingMap.ext fun v =>\n    (ιMulti_succ_apply _).trans <| by\n      simp_rw [Matrix.tail_cons]\n      rfl\n\n"}
{"name":"ExteriorAlgebra.ιMulti_range","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\n⊢ HasSubset.Subset (Set.range ⇑(ExteriorAlgebra.ιMulti R n)) ↑(ExteriorAlgebra.exteriorPower R n M)","decl":"/-- The image of `ExteriorAlgebra.ιMulti R n` is contained in the `n`th exterior power. -/\nlemma ιMulti_range (n : ℕ) :\n    Set.range (ιMulti R n (M := M)) ⊆ ↑(⋀[R]^n M) := by\n  rw [Set.range_subset_iff]\n  intro v\n  rw [ιMulti_apply]\n  apply Submodule.pow_subset_pow\n  rw [Set.mem_pow]\n  exact ⟨fun i => ⟨ι R (v i), LinearMap.mem_range_self _ _⟩, rfl⟩\n\n"}
{"name":"ExteriorAlgebra.ιMulti_span_fixedDegree","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\n⊢ Eq (Submodule.span R (Set.range ⇑(ExteriorAlgebra.ιMulti R n))) (ExteriorAlgebra.exteriorPower R n M)","decl":"/-- The image of `ExteriorAlgebra.ιMulti R n` spans the `n`th exterior power, as a submodule\nof the exterior algebra. -/\nlemma ιMulti_span_fixedDegree (n : ℕ) :\n    Submodule.span R (Set.range (ιMulti R n)) = ⋀[R]^n M := by\n  refine le_antisymm (Submodule.span_le.2 (ιMulti_range R n)) ?_\n  rw [exteriorPower, Submodule.pow_eq_span_pow_set, Submodule.span_le]\n  refine fun u hu ↦ Submodule.subset_span ?_\n  obtain ⟨f, rfl⟩ := Set.mem_pow.mp hu\n  refine ⟨fun i => ιInv (f i).1, ?_⟩\n  rw [ιMulti_apply]\n  congr with i\n  obtain ⟨v, hv⟩ := (f i).prop\n  rw [← hv, ι_leftInverse]\n\n"}
{"name":"ExteriorAlgebra.instNontrivial","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝³ : CommRing R\nM : Type u2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\n⊢ Nontrivial (ExteriorAlgebra R M)","decl":"/-- An `ExteriorAlgebra` over a nontrivial ring is nontrivial. -/\ninstance [Nontrivial R] : Nontrivial (ExteriorAlgebra R M) :=\n  (algebraMap_leftInverse M).injective.nontrivial\n\n"}
{"name":"ExteriorAlgebra.map_comp_ι","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝⁴ : CommRing R\nM : Type u2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u4\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\n⊢ Eq ((ExteriorAlgebra.map f).toLinearMap.comp (ExteriorAlgebra.ι R)) ((ExteriorAlgebra.ι R).comp f)","decl":"@[simp]\ntheorem map_comp_ι (f : M →ₗ[R] N) : (map f).toLinearMap ∘ₗ ι R = ι R ∘ₗ f :=\n  CliffordAlgebra.map_comp_ι _\n\n"}
{"name":"ExteriorAlgebra.map_apply_ι","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝⁴ : CommRing R\nM : Type u2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u4\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\nm : M\n⊢ Eq ((ExteriorAlgebra.map f) ((ExteriorAlgebra.ι R) m)) ((ExteriorAlgebra.ι R) (f m))","decl":"@[simp]\ntheorem map_apply_ι (f : M →ₗ[R] N) (m : M) : map f (ι R m) = ι R (f m) :=\n  CliffordAlgebra.map_apply_ι _ m\n\n"}
{"name":"ExteriorAlgebra.map_apply_ιMulti","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝⁴ : CommRing R\nM : Type u2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u4\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nn : Nat\nf : LinearMap (RingHom.id R) M N\nm : Fin n → M\n⊢ Eq ((ExteriorAlgebra.map f) ((ExteriorAlgebra.ιMulti R n) m)) ((ExteriorAlgebra.ιMulti R n) (Function.comp (⇑f) m))","decl":"@[simp]\ntheorem map_apply_ιMulti {n : ℕ} (f : M →ₗ[R] N) (m : Fin n → M) :\n    map f (ιMulti R n m) = ιMulti R n (f ∘ m) := by\n  rw [ιMulti_apply, ιMulti_apply, map_list_prod]\n  simp only [List.map_ofFn, Function.comp_def, map_apply_ι]\n\n"}
{"name":"ExteriorAlgebra.map_comp_ιMulti","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝⁴ : CommRing R\nM : Type u2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u4\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nn : Nat\nf : LinearMap (RingHom.id R) M N\n⊢ Eq ((ExteriorAlgebra.map f).toLinearMap.compAlternatingMap (ExteriorAlgebra.ιMulti R n)) ((ExteriorAlgebra.ιMulti R n).compLinearMap f)","decl":"@[simp]\ntheorem map_comp_ιMulti {n : ℕ} (f : M →ₗ[R] N) :\n    (map f).toLinearMap.compAlternatingMap (ιMulti R n (M := M)) =\n    (ιMulti R n (M := N)).compLinearMap f := by\n  ext m\n  exact map_apply_ιMulti _ _\n\n"}
{"name":"ExteriorAlgebra.map_id","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq (ExteriorAlgebra.map LinearMap.id) (AlgHom.id R (ExteriorAlgebra R M))","decl":"@[simp]\ntheorem map_id :\n    map LinearMap.id = AlgHom.id R (ExteriorAlgebra R M) :=\n  CliffordAlgebra.map_id 0\n\n"}
{"name":"ExteriorAlgebra.map_comp_map","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝⁶ : CommRing R\nM : Type u2\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nN : Type u4\nN' : Type u5\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : AddCommGroup N'\ninst✝ : Module R N'\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N N'\n⊢ Eq ((ExteriorAlgebra.map g).comp (ExteriorAlgebra.map f)) (ExteriorAlgebra.map (g.comp f))","decl":"@[simp]\ntheorem map_comp_map (f : M →ₗ[R] N) (g : N →ₗ[R] N') :\n    AlgHom.comp (map g) (map f) = map (LinearMap.comp g f) :=\n  CliffordAlgebra.map_comp_map _ _\n\n"}
{"name":"ExteriorAlgebra.ι_range_map_map","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝⁴ : CommRing R\nM : Type u2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u4\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\n⊢ Eq (Submodule.map (ExteriorAlgebra.map f).toLinearMap (LinearMap.range (ExteriorAlgebra.ι R))) (Submodule.map (ExteriorAlgebra.ι R) (LinearMap.range f))","decl":"@[simp]\ntheorem ι_range_map_map (f : M →ₗ[R] N) :\n    Submodule.map (AlgHom.toLinearMap (map f)) (LinearMap.range (ι R (M := M))) =\n    Submodule.map (ι R) (LinearMap.range f) :=\n  CliffordAlgebra.ι_range_map_map _\n\n"}
{"name":"ExteriorAlgebra.toTrivSqZeroExt_comp_map","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝⁸ : CommRing R\nM : Type u2\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nN : Type u4\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\ninst✝³ : Module (MulOpposite R) M\ninst✝² : IsCentralScalar R M\ninst✝¹ : Module (MulOpposite R) N\ninst✝ : IsCentralScalar R N\nf : LinearMap (RingHom.id R) M N\n⊢ Eq (ExteriorAlgebra.toTrivSqZeroExt.comp (ExteriorAlgebra.map f)) ((TrivSqZeroExt.map f).comp ExteriorAlgebra.toTrivSqZeroExt)","decl":"theorem toTrivSqZeroExt_comp_map [Module Rᵐᵒᵖ M] [IsCentralScalar R M] [Module Rᵐᵒᵖ N]\n    [IsCentralScalar R N] (f : M →ₗ[R] N) :\n    toTrivSqZeroExt.comp (map f) = (TrivSqZeroExt.map f).comp toTrivSqZeroExt := by\n  apply hom_ext\n  apply LinearMap.ext\n  simp only [AlgHom.comp_toLinearMap, LinearMap.coe_comp, Function.comp_apply,\n    AlgHom.toLinearMap_apply, map_apply_ι, toTrivSqZeroExt_ι, TrivSqZeroExt.map_inr, forall_const]\n\n"}
{"name":"ExteriorAlgebra.ιInv_comp_map","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝⁴ : CommRing R\nM : Type u2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u4\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\n⊢ Eq (ExteriorAlgebra.ιInv.comp (ExteriorAlgebra.map f).toLinearMap) (f.comp ExteriorAlgebra.ιInv)","decl":"theorem ιInv_comp_map (f : M →ₗ[R] N) :\n    ιInv.comp (map f).toLinearMap = f.comp ιInv := by\n  letI : Module Rᵐᵒᵖ M := Module.compHom _ ((RingHom.id R).fromOpposite mul_comm)\n  haveI : IsCentralScalar R M := ⟨fun r m => rfl⟩\n  letI : Module Rᵐᵒᵖ N := Module.compHom _ ((RingHom.id R).fromOpposite mul_comm)\n  haveI : IsCentralScalar R N := ⟨fun r m => rfl⟩\n  unfold ιInv\n  conv_lhs => rw [LinearMap.comp_assoc, ← AlgHom.comp_toLinearMap, toTrivSqZeroExt_comp_map,\n                AlgHom.comp_toLinearMap, ← LinearMap.comp_assoc, TrivSqZeroExt.sndHom_comp_map]\n  rfl\n\n"}
{"name":"ExteriorAlgebra.leftInverse_map_iff","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝⁴ : CommRing R\nM : Type u2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u4\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N M\n⊢ Iff (Function.LeftInverse ⇑(ExteriorAlgebra.map g) ⇑(ExteriorAlgebra.map f)) (Function.LeftInverse ⇑g ⇑f)","decl":"open Function in\n/-- For a linear map `f` from `M` to `N`,\n`ExteriorAlgebra.map g` is a retraction of `ExteriorAlgebra.map f` iff\n`g` is a retraction of `f`. -/\n@[simp]\nlemma leftInverse_map_iff {f : M →ₗ[R] N} {g : N →ₗ[R] M} :\n    LeftInverse (map g) (map f) ↔ LeftInverse g f := by\n  refine ⟨fun h x => ?_, fun h => CliffordAlgebra.leftInverse_map_of_leftInverse _ _ h⟩\n  simpa using h (ι _ x)\n\n"}
{"name":"ExteriorAlgebra.map_injective","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝⁴ : CommRing R\nM : Type u2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u4\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\nhf : Exists fun g => Eq (g.comp f) LinearMap.id\n⊢ Function.Injective ⇑(ExteriorAlgebra.map f)","decl":"/-- A morphism of modules that admits a linear retraction induces an injective morphism of\nexterior algebras. -/\nlemma map_injective {f : M →ₗ[R] N} (hf : ∃ (g : N →ₗ[R] M), g.comp f = LinearMap.id) :\n    Function.Injective (map f) :=\n  let ⟨_, hgf⟩ := hf; (leftInverse_map_iff.mpr (DFunLike.congr_fun hgf)).injective\n\n"}
{"name":"ExteriorAlgebra.map_surjective_iff","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝⁴ : CommRing R\nM : Type u2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u4\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\n⊢ Iff (Function.Surjective ⇑(ExteriorAlgebra.map f)) (Function.Surjective ⇑f)","decl":"/-- A morphism of modules is surjective if and only the morphism of exterior algebras that it\ninduces is surjective. -/\n@[simp]\nlemma map_surjective_iff {f : M →ₗ[R] N} :\n    Function.Surjective (map f) ↔ Function.Surjective f := by\n  refine ⟨fun h y ↦ ?_, fun h ↦ CliffordAlgebra.map_surjective _ h⟩\n  obtain ⟨x, hx⟩ := h (ι R y)\n  existsi ιInv x\n  rw [← LinearMap.comp_apply, ← ιInv_comp_map, LinearMap.comp_apply]\n  erw [hx, ExteriorAlgebra.ι_leftInverse]\n\n"}
{"name":"ExteriorAlgebra.map_injective_field","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"K : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : Field K\ninst✝³ : AddCommGroup E\ninst✝² : Module K E\ninst✝¹ : AddCommGroup F\ninst✝ : Module K F\nf : LinearMap (RingHom.id K) E F\nhf : Eq (LinearMap.ker f) Bot.bot\n⊢ Function.Injective ⇑(ExteriorAlgebra.map f)","decl":"/-- An injective morphism of vector spaces induces an injective morphism of exterior algebras. -/\nlemma map_injective_field {f : E →ₗ[K] F} (hf : LinearMap.ker f = ⊥) :\n    Function.Injective (map f) :=\n  map_injective (LinearMap.exists_leftInverse_of_injective f hf)\n\n"}
{"name":"TensorAlgebra.toExterior_ι","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nm : M\n⊢ Eq (TensorAlgebra.toExterior ((TensorAlgebra.ι R) m)) ((ExteriorAlgebra.ι R) m)","decl":"@[simp]\ntheorem toExterior_ι (m : M) :\n    TensorAlgebra.toExterior (TensorAlgebra.ι R m) = ExteriorAlgebra.ι R m := by\n  simp [toExterior]\n\n"}
