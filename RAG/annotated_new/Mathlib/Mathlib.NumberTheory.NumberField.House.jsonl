{"name":"NumberField.house_eq_sup'","module":"Mathlib.NumberTheory.NumberField.House","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nÎ± : K\nâŠ¢ Eq (NumberField.house Î±) â†‘(Finset.univ.sup' â‹¯ fun Ï† => NNNorm.nnnorm (Ï† Î±))","decl":"/-- The house is the largest of the modulus of the conjugates of an algebraic number. -/\ntheorem house_eq_sup' (Î± : K) :\n    house Î± = univ.sup' univ_nonempty (fun Ï† : K â†’+* â„‚ â†¦ â€–Ï† Î±â€–â‚Š) := by\n  rw [house, â† coe_nnnorm, nnnorm_eq, â† sup'_eq_sup univ_nonempty]\n\n"}
{"name":"NumberField.house_sum_le_sum_house","module":"Mathlib.NumberTheory.NumberField.House","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nÎ¹ : Type u_2\ns : Finset Î¹\nÎ± : Î¹ â†’ K\nâŠ¢ LE.le (NumberField.house (s.sum fun i => Î± i)) (s.sum fun i => NumberField.house (Î± i))","decl":"theorem house_sum_le_sum_house {Î¹ : Type*} (s : Finset Î¹) (Î± : Î¹ â†’ K) :\n    house (âˆ‘ i âˆˆ s, Î± i) â‰¤ âˆ‘ i âˆˆ s, house (Î± i) := by\n  simp only [house, map_sum]; apply norm_sum_le_of_le; intros; rfl\n\n"}
{"name":"NumberField.house_nonneg","module":"Mathlib.NumberTheory.NumberField.House","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nÎ± : K\nâŠ¢ LE.le 0 (NumberField.house Î±)","decl":"theorem house_nonneg (Î± : K) : 0 â‰¤ house Î± := norm_nonneg _\n\n"}
{"name":"NumberField.house_mul_le","module":"Mathlib.NumberTheory.NumberField.House","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nÎ± Î² : K\nâŠ¢ LE.le (NumberField.house (HMul.hMul Î± Î²)) (HMul.hMul (NumberField.house Î±) (NumberField.house Î²))","decl":"theorem house_mul_le (Î± Î² : K) : house (Î± * Î²) â‰¤ house Î± * house Î² := by\n  simp only [house, _root_.map_mul]; apply norm_mul_le\n\n"}
{"name":"NumberField.house_intCast","module":"Mathlib.NumberTheory.NumberField.House","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : Int\nâŠ¢ Eq (NumberField.house â†‘x) â†‘(abs x)","decl":"@[simp] theorem house_intCast (x : â„¤) : house (x : K) = |x| := by\n  simp only [house, map_intCast, Pi.intCast_def, pi_norm_const, Complex.norm_eq_abs,\n    Complex.abs_intCast, Int.cast_abs]\n\n"}
{"name":"NumberField.house.basis_repr_abs_le_const_mul_house","module":"Mathlib.NumberTheory.NumberField.House","initialProofState":"K : Type u_1\ninstâœÂ² : Field K\ninstâœÂ¹ : NumberField K\ninstâœ : DecidableEq (RingHom K Complex)\nÎ± : NumberField.RingOfIntegers K\ni : RingHom K Complex\nâŠ¢ LE.le (Complex.abs â†‘((((NumberField.integralBasis K).reindex (NumberField.equivReindex K).symm).repr â†‘Î±) i)) (HMul.hMul (NumberField.house.c K) (NumberField.house ((algebraMap (NumberField.RingOfIntegers K) K) Î±)))","decl":"theorem basis_repr_abs_le_const_mul_house (Î± : ğ“ K) (i : K â†’+* â„‚) :\n    Complex.abs (((integralBasis K).reindex (equivReindex K).symm).repr Î± i) â‰¤\n      (c K) * house (algebraMap (ğ“ K) K Î±) := by\n  let Ïƒ := canonicalEmbedding K\n  calc\n    _ â‰¤ âˆ‘ j, â€–((basisMatrix K).transpose)â»Â¹â€– * Complex.abs (Ïƒ (algebraMap (ğ“ K) K Î±) j) := ?_\n    _ â‰¤ âˆ‘ _ : K â†’+* â„‚, â€–fun i j => ((basisMatrix K).transpose)â»Â¹ i jâ€–\n        * house (algebraMap (ğ“ K) K Î±) := ?_\n    _ = â†‘(finrank â„š K) * â€–((basisMatrix K).transpose)â»Â¹â€– * house (algebraMap (ğ“ K) K Î±) := ?_\n\n  Â· rw [â† inverse_basisMatrix_mulVec_eq_repr]\n    apply le_trans\n    Â· apply le_trans (AbsoluteValue.sum_le Complex.abs _ _)\n      Â· exact sum_le_sum (fun _ _ => (AbsoluteValue.map_mul Complex.abs _ _).le)\n    Â· apply sum_le_sum (fun _ _ => mul_le_mul_of_nonneg_right ?_\n        (AbsoluteValue.nonneg Complex.abs _))\n      Â· exact norm_entry_le_entrywise_sup_norm ((basisMatrix K).transpose)â»Â¹\n  Â· apply sum_le_sum; intros j _\n    apply mul_le_mul_of_nonneg_left _ (norm_nonneg fun i j â†¦ ((basisMatrix K).transpose)â»Â¹ i j)\n    Â· exact norm_le_pi_norm (Ïƒ ((algebraMap (ğ“ K) K) Î±)) j\n  Â· rw [sum_const, card_univ, nsmul_eq_mul, Embeddings.card, mul_assoc]\n\n"}
{"name":"NumberField.house.exists_ne_zero_int_vec_house_le","module":"Mathlib.NumberTheory.NumberField.House","initialProofState":"K : Type u_1\ninstâœâ´ : Field K\ninstâœÂ³ : NumberField K\nÎ± : Type u_2\nÎ² : Type u_3\na : Matrix Î± Î² (NumberField.RingOfIntegers K)\nha : Ne a 0\np q : Nat\nh0p : LT.lt 0 p\nhpq : LT.lt p q\ninstâœÂ² : Fintype Î²\ncardÎ² : Eq (Fintype.card Î²) q\nA : Real\nhabs : âˆ€ (k : Î±) (l : Î²), LE.le (NumberField.house ((algebraMap (NumberField.RingOfIntegers K) K) (a k l))) A\ninstâœÂ¹ : DecidableEq (RingHom K Complex)\ninstâœ : Fintype Î±\ncardÎ± : Eq (Fintype.card Î±) p\nâŠ¢ Exists fun Î¾ => And (Ne Î¾ 0) (And (Eq (a.mulVec Î¾) 0) (âˆ€ (l : Î²), LE.le (NumberField.house â†‘(Î¾ l)) (HMul.hMul (NumberField.house.câ‚ K) (HPow.hPow (HMul.hMul (HMul.hMul (NumberField.house.câ‚ K) â†‘q) A) (HDiv.hDiv (â†‘p) (HSub.hSub â†‘q â†‘p))))))","decl":"include hpq h0p cardÎ± cardÎ² ha habs in\n/-- There exists a \"small\" non-zero algebraic integral solution of an\n non-trivial underdetermined system of linear equations with algebraic integer coefficients.-/\ntheorem exists_ne_zero_int_vec_house_le :\n    âˆƒ (Î¾ : Î² â†’ ğ“ K), Î¾ â‰  0 âˆ§ a *áµ¥ Î¾ = 0 âˆ§\n    âˆ€ l, house (Î¾ l).1 â‰¤ câ‚ K * ((câ‚ K * q * A) ^ ((p : â„) / (q - p))) := by\n  classical\n  let h := finrank â„š K\n  have hphqh : p * h < q * h := mul_lt_mul_of_pos_right hpq finrank_pos\n  have h0ph : 0 < p * h := by rw [mul_pos_iff]; constructor; exact âŸ¨h0p, finrank_posâŸ©\n  have hfinp : Fintype.card (Î± Ã— (K â†’+* â„‚)) = p * h := by\n    rw [Fintype.card_prod, cardÎ±, Embeddings.card]\n  have hfinq : Fintype.card (Î² Ã— (K â†’+* â„‚)) = q * h := by\n    rw [Fintype.card_prod, cardÎ², Embeddings.card]\n  have âŸ¨x, hxl, hmulvec0, hxboundâŸ© :=\n    Int.Matrix.exists_ne_zero_int_vec_norm_le' (asiegel K a)\n      (by rwa [hfinp, hfinq]) (by rwa [hfinp]) (asiegel_ne_0 K a ha)\n  simp only [hfinp, hfinq, Nat.cast_mul] at hmulvec0 hxbound\n  rw [â† sub_mul, mul_div_mul_right _ _ (mod_cast finrank_pos.ne')] at hxbound\n  have Apos : 0 â‰¤ A := by\n    have âŸ¨kâŸ© := Fintype.card_pos_iff.1 (cardÎ± â–¸ h0p)\n    have âŸ¨lâŸ© := Fintype.card_pos_iff.1 (cardÎ² â–¸ h0p.trans hpq)\n    exact le_trans (house_nonneg _) (habs k l)\n  use Î¾ K x, Î¾_ne_0 K x hxl, Î¾_mulVec_eq_0 K a x hxl hmulvec0,\n    house_le_bound K a hpq x habs Apos hxbound\n\n"}
