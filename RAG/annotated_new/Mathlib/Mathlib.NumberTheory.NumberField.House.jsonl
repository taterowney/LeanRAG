{"name":"NumberField.house_eq_sup'","module":"Mathlib.NumberTheory.NumberField.House","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nα : K\n⊢ Eq (NumberField.house α) ↑(Finset.univ.sup' ⋯ fun φ => NNNorm.nnnorm (φ α))","decl":"/-- The house is the largest of the modulus of the conjugates of an algebraic number. -/\ntheorem house_eq_sup' (α : K) :\n    house α = univ.sup' univ_nonempty (fun φ : K →+* ℂ ↦ ‖φ α‖₊) := by\n  rw [house, ← coe_nnnorm, nnnorm_eq, ← sup'_eq_sup univ_nonempty]\n\n"}
{"name":"NumberField.house_sum_le_sum_house","module":"Mathlib.NumberTheory.NumberField.House","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nι : Type u_2\ns : Finset ι\nα : ι → K\n⊢ LE.le (NumberField.house (s.sum fun i => α i)) (s.sum fun i => NumberField.house (α i))","decl":"theorem house_sum_le_sum_house {ι : Type*} (s : Finset ι) (α : ι → K) :\n    house (∑ i ∈ s, α i) ≤ ∑ i ∈ s, house (α i) := by\n  simp only [house, map_sum]; apply norm_sum_le_of_le; intros; rfl\n\n"}
{"name":"NumberField.house_nonneg","module":"Mathlib.NumberTheory.NumberField.House","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nα : K\n⊢ LE.le 0 (NumberField.house α)","decl":"theorem house_nonneg (α : K) : 0 ≤ house α := norm_nonneg _\n\n"}
{"name":"NumberField.house_mul_le","module":"Mathlib.NumberTheory.NumberField.House","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nα β : K\n⊢ LE.le (NumberField.house (HMul.hMul α β)) (HMul.hMul (NumberField.house α) (NumberField.house β))","decl":"theorem house_mul_le (α β : K) : house (α * β) ≤ house α * house β := by\n  simp only [house, _root_.map_mul]; apply norm_mul_le\n\n"}
{"name":"NumberField.house_intCast","module":"Mathlib.NumberTheory.NumberField.House","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : Int\n⊢ Eq (NumberField.house ↑x) ↑(abs x)","decl":"@[simp] theorem house_intCast (x : ℤ) : house (x : K) = |x| := by\n  simp only [house, map_intCast, Pi.intCast_def, pi_norm_const, Complex.norm_eq_abs,\n    Complex.abs_intCast, Int.cast_abs]\n\n"}
{"name":"NumberField.house.basis_repr_abs_le_const_mul_house","module":"Mathlib.NumberTheory.NumberField.House","initialProofState":"K : Type u_1\ninst✝² : Field K\ninst✝¹ : NumberField K\ninst✝ : DecidableEq (RingHom K Complex)\nα : NumberField.RingOfIntegers K\ni : RingHom K Complex\n⊢ LE.le (Complex.abs ↑((((NumberField.integralBasis K).reindex (NumberField.equivReindex K).symm).repr ↑α) i)) (HMul.hMul (NumberField.house.c K) (NumberField.house ((algebraMap (NumberField.RingOfIntegers K) K) α)))","decl":"theorem basis_repr_abs_le_const_mul_house (α : 𝓞 K) (i : K →+* ℂ) :\n    Complex.abs (((integralBasis K).reindex (equivReindex K).symm).repr α i) ≤\n      (c K) * house (algebraMap (𝓞 K) K α) := by\n  let σ := canonicalEmbedding K\n  calc\n    _ ≤ ∑ j, ‖((basisMatrix K).transpose)⁻¹‖ * Complex.abs (σ (algebraMap (𝓞 K) K α) j) := ?_\n    _ ≤ ∑ _ : K →+* ℂ, ‖fun i j => ((basisMatrix K).transpose)⁻¹ i j‖\n        * house (algebraMap (𝓞 K) K α) := ?_\n    _ = ↑(finrank ℚ K) * ‖((basisMatrix K).transpose)⁻¹‖ * house (algebraMap (𝓞 K) K α) := ?_\n\n  · rw [← inverse_basisMatrix_mulVec_eq_repr]\n    apply le_trans\n    · apply le_trans (AbsoluteValue.sum_le Complex.abs _ _)\n      · exact sum_le_sum (fun _ _ => (AbsoluteValue.map_mul Complex.abs _ _).le)\n    · apply sum_le_sum (fun _ _ => mul_le_mul_of_nonneg_right ?_\n        (AbsoluteValue.nonneg Complex.abs _))\n      · exact norm_entry_le_entrywise_sup_norm ((basisMatrix K).transpose)⁻¹\n  · apply sum_le_sum; intros j _\n    apply mul_le_mul_of_nonneg_left _ (norm_nonneg fun i j ↦ ((basisMatrix K).transpose)⁻¹ i j)\n    · exact norm_le_pi_norm (σ ((algebraMap (𝓞 K) K) α)) j\n  · rw [sum_const, card_univ, nsmul_eq_mul, Embeddings.card, mul_assoc]\n\n"}
{"name":"NumberField.house.exists_ne_zero_int_vec_house_le","module":"Mathlib.NumberTheory.NumberField.House","initialProofState":"K : Type u_1\ninst✝⁴ : Field K\ninst✝³ : NumberField K\nα : Type u_2\nβ : Type u_3\na : Matrix α β (NumberField.RingOfIntegers K)\nha : Ne a 0\np q : Nat\nh0p : LT.lt 0 p\nhpq : LT.lt p q\ninst✝² : Fintype β\ncardβ : Eq (Fintype.card β) q\nA : Real\nhabs : ∀ (k : α) (l : β), LE.le (NumberField.house ((algebraMap (NumberField.RingOfIntegers K) K) (a k l))) A\ninst✝¹ : DecidableEq (RingHom K Complex)\ninst✝ : Fintype α\ncardα : Eq (Fintype.card α) p\n⊢ Exists fun ξ => And (Ne ξ 0) (And (Eq (a.mulVec ξ) 0) (∀ (l : β), LE.le (NumberField.house ↑(ξ l)) (HMul.hMul (NumberField.house.c₁ K) (HPow.hPow (HMul.hMul (HMul.hMul (NumberField.house.c₁ K) ↑q) A) (HDiv.hDiv (↑p) (HSub.hSub ↑q ↑p))))))","decl":"include hpq h0p cardα cardβ ha habs in\n/-- There exists a \"small\" non-zero algebraic integral solution of an\n non-trivial underdetermined system of linear equations with algebraic integer coefficients.-/\ntheorem exists_ne_zero_int_vec_house_le :\n    ∃ (ξ : β → 𝓞 K), ξ ≠ 0 ∧ a *ᵥ ξ = 0 ∧\n    ∀ l, house (ξ l).1 ≤ c₁ K * ((c₁ K * q * A) ^ ((p : ℝ) / (q - p))) := by\n  classical\n  let h := finrank ℚ K\n  have hphqh : p * h < q * h := mul_lt_mul_of_pos_right hpq finrank_pos\n  have h0ph : 0 < p * h := by rw [mul_pos_iff]; constructor; exact ⟨h0p, finrank_pos⟩\n  have hfinp : Fintype.card (α × (K →+* ℂ)) = p * h := by\n    rw [Fintype.card_prod, cardα, Embeddings.card]\n  have hfinq : Fintype.card (β × (K →+* ℂ)) = q * h := by\n    rw [Fintype.card_prod, cardβ, Embeddings.card]\n  have ⟨x, hxl, hmulvec0, hxbound⟩ :=\n    Int.Matrix.exists_ne_zero_int_vec_norm_le' (asiegel K a)\n      (by rwa [hfinp, hfinq]) (by rwa [hfinp]) (asiegel_ne_0 K a ha)\n  simp only [hfinp, hfinq, Nat.cast_mul] at hmulvec0 hxbound\n  rw [← sub_mul, mul_div_mul_right _ _ (mod_cast finrank_pos.ne')] at hxbound\n  have Apos : 0 ≤ A := by\n    have ⟨k⟩ := Fintype.card_pos_iff.1 (cardα ▸ h0p)\n    have ⟨l⟩ := Fintype.card_pos_iff.1 (cardβ ▸ h0p.trans hpq)\n    exact le_trans (house_nonneg _) (habs k l)\n  use ξ K x, ξ_ne_0 K x hxl, ξ_mulVec_eq_0 K a x hxl hmulvec0,\n    house_le_bound K a hpq x habs Apos hxbound\n\n"}
