{"name":"CategoryTheory.OverPresheafAux.MakesOverArrow.app","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nu : F.obj { unop := X }\nself : CategoryTheory.OverPresheafAux.MakesOverArrow η s u\n⊢ Eq (η.app { unop := X } u) (CategoryTheory.yonedaEquiv s)","decl":"/-- Via the Yoneda lemma, `u : F.obj (op X)` defines a natural transformation `yoneda.obj X ⟶ F`\n    and via the element `η.app (op X) u` also a morphism `yoneda.obj X ⟶ A`. This structure\n    witnesses the fact that these morphisms from a commutative triangle with `η : F ⟶ A`, i.e.,\n    that `yoneda.obj X ⟶ F` lifts to a morphism in `Over A`. -/\nstructure MakesOverArrow {F : Cᵒᵖ ⥤ Type v} (η : F ⟶ A) {X : C} (s : yoneda.obj X ⟶ A)\n    (u : F.obj (op X)) : Prop where\n  app : η.app (op X) u = yonedaEquiv s\n\n"}
{"name":"CategoryTheory.OverPresheafAux.MakesOverArrow.map₁","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F G : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nμ : Quiver.Hom G A\nε : Quiver.Hom F G\nhε : Eq (CategoryTheory.CategoryStruct.comp ε μ) η\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nu : F.obj { unop := X }\nh : CategoryTheory.OverPresheafAux.MakesOverArrow η s u\n⊢ CategoryTheory.OverPresheafAux.MakesOverArrow μ s (ε.app { unop := X } u)","decl":"/-- \"Functoriality\" of `MakesOverArrow η s` in `η`. -/\nlemma map₁ {F G : Cᵒᵖ ⥤ Type v} {η : F ⟶ A} {μ : G ⟶ A} {ε : F ⟶ G}\n    (hε : ε ≫ μ = η) {X : C} {s : yoneda.obj X ⟶ A} {u : F.obj (op X)}\n    (h : MakesOverArrow η s u) : MakesOverArrow μ s (ε.app _ u) :=\n  ⟨by rw [← elementwise_of% NatTrans.comp_app ε μ, hε, h.app]⟩\n\n"}
{"name":"CategoryTheory.OverPresheafAux.MakesOverArrow.map₂","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nX Y : C\nf : Quiver.Hom X Y\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nt : Quiver.Hom (CategoryTheory.yoneda.obj Y) A\nhst : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map f) t) s\nu : F.obj { unop := Y }\nh : CategoryTheory.OverPresheafAux.MakesOverArrow η t u\n⊢ CategoryTheory.OverPresheafAux.MakesOverArrow η s (F.map f.op u)","decl":"/-- \"Functoriality of `MakesOverArrow η s` in `s`. -/\nlemma map₂ {F : Cᵒᵖ ⥤ Type v} {η : F ⟶ A} {X Y : C} (f : X ⟶ Y)\n    {s : yoneda.obj X ⟶ A} {t : yoneda.obj Y ⟶ A} (hst : yoneda.map f ≫ t = s)\n    {u : F.obj (op Y)} (h : MakesOverArrow η t u) : MakesOverArrow η s (F.map f.op u) :=\n  ⟨by rw [elementwise_of% η.naturality, h.app, yonedaEquiv_naturality, hst]⟩\n\n"}
{"name":"CategoryTheory.OverPresheafAux.MakesOverArrow.of_arrow","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nf : Quiver.Hom (CategoryTheory.yoneda.obj X) F\nhf : Eq (CategoryTheory.CategoryStruct.comp f η) s\n⊢ CategoryTheory.OverPresheafAux.MakesOverArrow η s (CategoryTheory.yonedaEquiv f)","decl":"lemma of_arrow {F : Cᵒᵖ ⥤ Type v} {η : F ⟶ A} {X : C} {s : yoneda.obj X ⟶ A}\n    {f : yoneda.obj X ⟶ F} (hf : f ≫ η = s) : MakesOverArrow η s (yonedaEquiv f) :=\n  ⟨hf ▸ rfl⟩\n\n"}
{"name":"CategoryTheory.OverPresheafAux.MakesOverArrow.of_yoneda_arrow","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nY : C\nη : Quiver.Hom (CategoryTheory.yoneda.obj Y) A\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nf : Quiver.Hom X Y\nhf : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map f) η) s\n⊢ CategoryTheory.OverPresheafAux.MakesOverArrow η s f","decl":"lemma of_yoneda_arrow {Y : C} {η : yoneda.obj Y ⟶ A} {X : C} {s : yoneda.obj X ⟶ A} {f : X ⟶ Y}\n    (hf : yoneda.map f ≫ η = s) : MakesOverArrow η s f := by\n  simpa only [yonedaEquiv_yoneda_map f] using of_arrow hf\n\n"}
{"name":"CategoryTheory.OverPresheafAux.OverArrows.val_mk","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nu : F.obj { unop := X }\nh : CategoryTheory.OverPresheafAux.MakesOverArrow η s u\n⊢ Eq (CategoryTheory.OverPresheafAux.OverArrows.val ⟨u, h⟩) u","decl":"@[simp]\nlemma val_mk {F : Cᵒᵖ ⥤ Type v} (η : F ⟶ A) {X : C} (s : yoneda.obj X ⟶ A) (u : F.obj (op X))\n    (h : MakesOverArrow η s u) : val ⟨u, h⟩ = u :=\n  rfl\n\n"}
{"name":"CategoryTheory.OverPresheafAux.OverArrows.ext","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nu v : CategoryTheory.OverPresheafAux.OverArrows η s\na✝ : Eq u.val v.val\n⊢ Eq u v","decl":"@[ext]\nlemma ext {F : Cᵒᵖ ⥤ Type v} {η : F ⟶ A} {X : C} {s : yoneda.obj X ⟶ A}\n    {u v : OverArrows η s} : u.val = v.val → u = v :=\n  Subtype.ext\n\n"}
{"name":"CategoryTheory.OverPresheafAux.OverArrows.ext_iff","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nu v : CategoryTheory.OverPresheafAux.OverArrows η s\n⊢ Iff (Eq u v) (Eq u.val v.val)","decl":"@[ext]\nlemma ext {F : Cᵒᵖ ⥤ Type v} {η : F ⟶ A} {X : C} {s : yoneda.obj X ⟶ A}\n    {u v : OverArrows η s} : u.val = v.val → u = v :=\n  Subtype.ext\n\n"}
{"name":"CategoryTheory.OverPresheafAux.OverArrows.app_val","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\np : CategoryTheory.OverPresheafAux.OverArrows η s\n⊢ Eq (η.app { unop := X } p.val) (CategoryTheory.yonedaEquiv s)","decl":"/-- The defining property of `OverArrows.val`. -/\nlemma app_val {F : Cᵒᵖ ⥤ Type v} {η : F ⟶ A} {X : C} {s : yoneda.obj X ⟶ A}\n    (p : OverArrows η s) : η.app (op X) p.val = yonedaEquiv s :=\n  p.prop.app\n\n"}
{"name":"CategoryTheory.OverPresheafAux.OverArrows.map_val","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nY : C\nη : Quiver.Hom (CategoryTheory.yoneda.obj Y) A\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\np : CategoryTheory.OverPresheafAux.OverArrows η s\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map p.val) η) s","decl":"/-- In the special case `F = yoneda.obj Y`, the element `p.val` for `p : OverArrows η s` is itself\n    a morphism `X ⟶ Y`. -/\n@[simp]\nlemma map_val {Y : C} {η : yoneda.obj Y ⟶ A} {X : C} {s : yoneda.obj X ⟶ A}\n    (p : OverArrows η s) : yoneda.map p.val ≫ η = s := by\n  rw [← yonedaEquiv.injective.eq_iff, yonedaEquiv_comp, yonedaEquiv_yoneda_map]\n  simp only [unop_op, p.app_val]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.OverArrows.map₁_val","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F G : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nμ : Quiver.Hom G A\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nu : CategoryTheory.OverPresheafAux.OverArrows η s\nε : Quiver.Hom F G\nhε : Eq (CategoryTheory.CategoryStruct.comp ε μ) η\n⊢ Eq (u.map₁ ε hε).val (ε.app { unop := X } u.val)","decl":"@[simp]\nlemma map₁_val {F G : Cᵒᵖ ⥤ Type v} {η : F ⟶ A} {μ : G ⟶ A} {X : C}\n    (s : yoneda.obj X ⟶ A) (u : OverArrows η s) (ε : F ⟶ G) (hε : ε ≫ μ = η) :\n    (u.map₁ ε hε).val = ε.app _ u.val :=\n  rfl\n\n"}
{"name":"CategoryTheory.OverPresheafAux.OverArrows.map₂_val","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nX Y : C\nf : Quiver.Hom X Y\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nt : Quiver.Hom (CategoryTheory.yoneda.obj Y) A\nhst : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map f) t) s\nu : CategoryTheory.OverPresheafAux.OverArrows η t\n⊢ Eq (u.map₂ f hst).val (F.map f.op u.val)","decl":"@[simp]\nlemma map₂_val {F : Cᵒᵖ ⥤ Type v} {η : F ⟶ A} {X Y : C} (f : X ⟶ Y)\n    {s : yoneda.obj X ⟶ A} {t : yoneda.obj Y ⟶ A} (hst : yoneda.map f ≫ t = s)\n    (u : OverArrows η t) : (u.map₂ f hst).val = F.map f.op u.val :=\n  rfl\n\n"}
{"name":"CategoryTheory.OverPresheafAux.OverArrows.map₁_map₂","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F G : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nμ : Quiver.Hom G A\nε : Quiver.Hom F G\nhε : Eq (CategoryTheory.CategoryStruct.comp ε μ) η\nX Y : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nt : Quiver.Hom (CategoryTheory.yoneda.obj Y) A\nf : Quiver.Hom X Y\nhf : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map f) t) s\nu : CategoryTheory.OverPresheafAux.OverArrows η t\n⊢ Eq ((u.map₁ ε hε).map₂ f hf) ((u.map₂ f hf).map₁ ε hε)","decl":"@[simp]\nlemma map₁_map₂ {F G : Cᵒᵖ ⥤ Type v} {η : F ⟶ A} {μ : G ⟶ A} (ε : F ⟶ G)\n    (hε : ε ≫ μ = η) {X Y : C} {s : yoneda.obj X ⟶ A} {t : yoneda.obj Y ⟶ A} (f : X ⟶ Y)\n    (hf : yoneda.map f ≫ t = s) (u : OverArrows η t) :\n    (u.map₁ ε hε).map₂ f hf = (u.map₂ f hf).map₁ ε hε :=\n  OverArrows.ext <| (elementwise_of% (ε.naturality f.op).symm) u.val\n\n"}
{"name":"CategoryTheory.OverPresheafAux.OverArrows.yonedaArrow_val","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nY : C\nη : Quiver.Hom (CategoryTheory.yoneda.obj Y) A\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nf : Quiver.Hom X Y\nhf : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map f) η) s\n⊢ Eq (CategoryTheory.OverPresheafAux.OverArrows.yonedaArrow f hf).val f","decl":"@[simp]\nlemma yonedaArrow_val {Y : C} {η : yoneda.obj Y ⟶ A} {X : C} {s : yoneda.obj X ⟶ A} {f : X ⟶ Y}\n    (hf : yoneda.map f ≫ η = s) : (yonedaArrow f hf).val = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.OverPresheafAux.restrictedYonedaObj_obj","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\ns : Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)\n⊢ Eq ((CategoryTheory.OverPresheafAux.restrictedYonedaObj η).obj s) (CategoryTheory.OverPresheafAux.OverArrows η (Opposite.unop s).hom)","decl":"/-- This is basically just `yoneda.obj η : (Over A)ᵒᵖ ⥤ Type (max u v)` restricted along the\n    forgetful functor `CostructuredArrow yoneda A ⥤ Over A`, but done in a way that we land in a\n    smaller universe. -/\n@[simps]\ndef restrictedYonedaObj {F : Cᵒᵖ ⥤ Type v} (η : F ⟶ A) :\n    (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v where\n  obj s := OverArrows η s.unop.hom\n  map f u := u.map₂ f.unop.left f.unop.w\n\n"}
{"name":"CategoryTheory.OverPresheafAux.restrictedYonedaObj_map","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nX✝ Y✝ : Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)\nf : Quiver.Hom X✝ Y✝\nu : CategoryTheory.OverPresheafAux.OverArrows η (Opposite.unop X✝).hom\n⊢ Eq ((CategoryTheory.OverPresheafAux.restrictedYonedaObj η).map f u) (u.map₂ f.unop.left ⋯)","decl":"/-- This is basically just `yoneda.obj η : (Over A)ᵒᵖ ⥤ Type (max u v)` restricted along the\n    forgetful functor `CostructuredArrow yoneda A ⥤ Over A`, but done in a way that we land in a\n    smaller universe. -/\n@[simps]\ndef restrictedYonedaObj {F : Cᵒᵖ ⥤ Type v} (η : F ⟶ A) :\n    (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v where\n  obj s := OverArrows η s.unop.hom\n  map f u := u.map₂ f.unop.left f.unop.w\n\n"}
{"name":"CategoryTheory.OverPresheafAux.restrictedYonedaObjMap₁_app","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F G : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nμ : Quiver.Hom G A\nε : Quiver.Hom F G\nhε : Eq (CategoryTheory.CategoryStruct.comp ε μ) η\nx✝ : Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)\nu : (CategoryTheory.OverPresheafAux.restrictedYonedaObj η).obj x✝\n⊢ Eq ((CategoryTheory.OverPresheafAux.restrictedYonedaObjMap₁ ε hε).app x✝ u) (CategoryTheory.OverPresheafAux.OverArrows.map₁ u ε hε)","decl":"/-- Functoriality of `restrictedYonedaObj η` in `η`. -/\n@[simps]\ndef restrictedYonedaObjMap₁ {F G : Cᵒᵖ ⥤ Type v} {η : F ⟶ A} {μ : G ⟶ A} (ε : F ⟶ G)\n    (hε : ε ≫ μ = η) : restrictedYonedaObj η ⟶ restrictedYonedaObj μ where\n  app _ u := u.map₁ ε hε\n\n"}
{"name":"CategoryTheory.OverPresheafAux.restrictedYoneda_obj","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nη : CategoryTheory.Over A\n⊢ Eq ((CategoryTheory.OverPresheafAux.restrictedYoneda A).obj η) (CategoryTheory.OverPresheafAux.restrictedYonedaObj η.hom)","decl":"/-- This is basically just `yoneda : Over A ⥤ (Over A)ᵒᵖ ⥤ Type (max u v)` restricted in the second\n    argument along the forgetful functor `CostructuredArrow yoneda A ⥤ Over A`, but done in a way\n    that we land in a smaller universe.\n\n    This is one direction of the equivalence we're constructing. -/\n@[simps]\ndef restrictedYoneda (A : Cᵒᵖ ⥤ Type v) : Over A ⥤ (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v where\n  obj η := restrictedYonedaObj η.hom\n  map ε := restrictedYonedaObjMap₁ ε.left ε.w\n\n"}
{"name":"CategoryTheory.OverPresheafAux.restrictedYoneda_map","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nX✝ Y✝ : CategoryTheory.Over A\nε : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.OverPresheafAux.restrictedYoneda A).map ε) (CategoryTheory.OverPresheafAux.restrictedYonedaObjMap₁ ε.left ⋯)","decl":"/-- This is basically just `yoneda : Over A ⥤ (Over A)ᵒᵖ ⥤ Type (max u v)` restricted in the second\n    argument along the forgetful functor `CostructuredArrow yoneda A ⥤ Over A`, but done in a way\n    that we land in a smaller universe.\n\n    This is one direction of the equivalence we're constructing. -/\n@[simps]\ndef restrictedYoneda (A : Cᵒᵖ ⥤ Type v) : Over A ⥤ (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v where\n  obj η := restrictedYonedaObj η.hom\n  map ε := restrictedYonedaObjMap₁ ε.left ε.w\n\n"}
{"name":"CategoryTheory.OverPresheafAux.map_mkPrecomp_eqToHom","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX Y : C\nf : Quiver.Hom X Y\ng g' : Quiver.Hom (CategoryTheory.yoneda.obj Y) A\nh : Eq g g'\nx : F.obj { unop := CategoryTheory.CostructuredArrow.mk g' }\n⊢ Eq (F.map (CategoryTheory.CostructuredArrow.mkPrecomp g f).op (F.map (CategoryTheory.eqToHom ⋯) x)) (F.map (CategoryTheory.eqToHom ⋯) (F.map (CategoryTheory.CostructuredArrow.mkPrecomp g' f).op x))","decl":"/-- This lemma will be key to establishing good simp normal forms. -/\nlemma map_mkPrecomp_eqToHom {F : (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v} {X Y : C} {f : X ⟶ Y}\n    {g g' : yoneda.obj Y ⟶ A} (h : g = g') {x : F.obj (op (CostructuredArrow.mk g'))} :\n    F.map (CostructuredArrow.mkPrecomp g f).op (F.map (eqToHom (by rw [h])) x) =\n      F.map (eqToHom (by rw [h])) (F.map (CostructuredArrow.mkPrecomp g' f).op x) := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.yonedaEquivFst_eq","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\np : CategoryTheory.OverPresheafAux.YonedaCollection F X\n⊢ Eq p.yonedaEquivFst (CategoryTheory.yonedaEquiv p.fst)","decl":"lemma yonedaEquivFst_eq (p : YonedaCollection F X) : p.yonedaEquivFst = yonedaEquiv p.fst :=\n  rfl\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.mk_fst","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nx : F.obj { unop := CategoryTheory.CostructuredArrow.mk s }\n⊢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.mk s x).fst s","decl":"@[simp]\nlemma mk_fst (s : yoneda.obj X ⟶ A) (x : F.obj (op (CostructuredArrow.mk s))) : (mk s x).fst = s :=\n  Equiv.apply_symm_apply _ _\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.mk_snd","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nx : F.obj { unop := CategoryTheory.CostructuredArrow.mk s }\n⊢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.mk s x).snd (F.map (CategoryTheory.eqToHom ⋯) x)","decl":"@[simp]\nlemma mk_snd (s : yoneda.obj X ⟶ A) (x : F.obj (op (CostructuredArrow.mk s))) :\n    (mk s x).snd = F.map (eqToHom <| by rw [YonedaCollection.mk_fst]) x :=\n  rfl\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.ext","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\np q : CategoryTheory.OverPresheafAux.YonedaCollection F X\nh : Eq p.fst q.fst\nh' : Eq (F.map (CategoryTheory.eqToHom ⋯) q.snd) p.snd\n⊢ Eq p q","decl":"@[ext (iff := false)]\nlemma ext {p q : YonedaCollection F X} (h : p.fst = q.fst)\n    (h' : F.map (eqToHom <| by rw [h]) q.snd = p.snd) : p = q := by\n  rcases p with ⟨p, p'⟩\n  rcases q with ⟨q, q'⟩\n  obtain rfl : p = q := yonedaEquiv.symm.injective h\n  exact Sigma.ext rfl (by simpa [snd] using h'.symm)\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map₁_fst","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\nG : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nη : Quiver.Hom F G\np : CategoryTheory.OverPresheafAux.YonedaCollection F X\n⊢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map₁ η p).fst p.fst","decl":"@[simp]\nlemma map₁_fst {G : (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v} (η : F ⟶ G)\n    (p : YonedaCollection F X) : (YonedaCollection.map₁ η p).fst = p.fst := by\n  simp [map₁]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map₁_yonedaEquivFst","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\nG : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nη : Quiver.Hom F G\np : CategoryTheory.OverPresheafAux.YonedaCollection F X\n⊢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map₁ η p).yonedaEquivFst p.yonedaEquivFst","decl":"@[simp]\nlemma map₁_yonedaEquivFst {G : (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v} (η : F ⟶ G)\n    (p : YonedaCollection F X) :\n    (YonedaCollection.map₁ η p).yonedaEquivFst = p.yonedaEquivFst := by\n  simp only [YonedaCollection.yonedaEquivFst_eq, map₁_fst]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map₁_snd","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\nG : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nη : Quiver.Hom F G\np : CategoryTheory.OverPresheafAux.YonedaCollection F X\n⊢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map₁ η p).snd (G.map (CategoryTheory.eqToHom ⋯) (η.app { unop := CategoryTheory.CostructuredArrow.mk p.fst } p.snd))","decl":"@[simp]\nlemma map₁_snd {G : (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v} (η : F ⟶ G)\n    (p : YonedaCollection F X) : (YonedaCollection.map₁ η p).snd =\n      G.map (eqToHom (by rw [YonedaCollection.map₁_fst])) (η.app _ p.snd) := by\n  simp [map₁]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map₂_fst","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX Y : C\nf : Quiver.Hom X Y\np : CategoryTheory.OverPresheafAux.YonedaCollection F Y\n⊢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map₂ F f p).fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map f) p.fst)","decl":"@[simp]\nlemma map₂_fst {Y : C} (f : X ⟶ Y) (p : YonedaCollection F Y) :\n    (YonedaCollection.map₂ F f p).fst = yoneda.map f ≫ p.fst := by\n  simp [map₂]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map₂_yonedaEquivFst","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX Y : C\nf : Quiver.Hom X Y\np : CategoryTheory.OverPresheafAux.YonedaCollection F Y\n⊢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map₂ F f p).yonedaEquivFst (A.map f.op p.yonedaEquivFst)","decl":"@[simp]\nlemma map₂_yonedaEquivFst {Y : C} (f : X ⟶ Y) (p : YonedaCollection F Y) :\n    (YonedaCollection.map₂ F f p).yonedaEquivFst = A.map f.op p.yonedaEquivFst := by\n  simp only [YonedaCollection.yonedaEquivFst_eq, map₂_fst, yonedaEquiv_naturality]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map₂_snd","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX Y : C\nf : Quiver.Hom X Y\np : CategoryTheory.OverPresheafAux.YonedaCollection F Y\n⊢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map₂ F f p).snd (F.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.CostructuredArrow.mkPrecomp p.fst f).op (CategoryTheory.eqToHom ⋯)) p.snd)","decl":"@[simp]\nlemma map₂_snd {Y : C} (f : X ⟶ Y) (p : YonedaCollection F Y) :\n    (YonedaCollection.map₂ F f p).snd = F.map ((CostructuredArrow.mkPrecomp p.fst f).op ≫\n      eqToHom (by rw [YonedaCollection.map₂_fst f])) p.snd := by\n  simp [map₂]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map₁_id","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\n⊢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map₁ (CategoryTheory.CategoryStruct.id F)) id","decl":"@[simp]\nlemma map₁_id : YonedaCollection.map₁ (𝟙 F) (X := X) = id := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map₁_comp","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\nG H : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nη : Quiver.Hom F G\nμ : Quiver.Hom G H\n⊢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map₁ (CategoryTheory.CategoryStruct.comp η μ)) (Function.comp (CategoryTheory.OverPresheafAux.YonedaCollection.map₁ μ) (CategoryTheory.OverPresheafAux.YonedaCollection.map₁ η))","decl":"@[simp]\nlemma map₁_comp {G H : (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v} (η : F ⟶ G) (μ : G ⟶ H) :\n    YonedaCollection.map₁ (η ≫ μ) (X := X) =\n      YonedaCollection.map₁ μ (X := X) ∘ YonedaCollection.map₁ η (X := X) := by\n  ext; all_goals simp\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map₂_id","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\n⊢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map₂ F (CategoryTheory.CategoryStruct.id X)) id","decl":"@[simp]\nlemma map₂_id : YonedaCollection.map₂ F (𝟙 X) = id := by\n  ext; all_goals simp\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map₂_comp","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map₂ F (CategoryTheory.CategoryStruct.comp f g)) (Function.comp (CategoryTheory.OverPresheafAux.YonedaCollection.map₂ F f) (CategoryTheory.OverPresheafAux.YonedaCollection.map₂ F g))","decl":"@[simp]\nlemma map₂_comp {Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    YonedaCollection.map₂ F (f ≫ g) = YonedaCollection.map₂ F f ∘ YonedaCollection.map₂ F g := by\n  ext; all_goals simp\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map₁_map₂","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\nG : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nη : Quiver.Hom F G\nY : C\nf : Quiver.Hom X Y\np : CategoryTheory.OverPresheafAux.YonedaCollection F Y\n⊢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map₂ G f (CategoryTheory.OverPresheafAux.YonedaCollection.map₁ η p)) (CategoryTheory.OverPresheafAux.YonedaCollection.map₁ η (CategoryTheory.OverPresheafAux.YonedaCollection.map₂ F f p))","decl":"@[simp]\nlemma map₁_map₂ {G : (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v} (η : F ⟶ G) {Y : C} (f : X ⟶ Y)\n    (p : YonedaCollection F Y) :\n    YonedaCollection.map₂ G f (YonedaCollection.map₁ η p) =\n      YonedaCollection.map₁ η (YonedaCollection.map₂ F f p) := by\n  ext; all_goals simp\n\n"}
{"name":"CategoryTheory.OverPresheafAux.yonedaCollectionPresheaf_map","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX✝ Y✝ : Opposite C\nf : Quiver.Hom X✝ Y✝\np : CategoryTheory.OverPresheafAux.YonedaCollection F (Opposite.unop X✝)\n⊢ Eq ((CategoryTheory.OverPresheafAux.yonedaCollectionPresheaf A F).map f p) (CategoryTheory.OverPresheafAux.YonedaCollection.map₂ F f.unop p)","decl":"/-- Given `F : (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v`, this is the presheaf that is given by\n    `YonedaCollection F X` on objects. -/\n@[simps]\ndef yonedaCollectionPresheaf (A : Cᵒᵖ ⥤ Type v) (F : (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v) :\n    Cᵒᵖ ⥤ Type v where\n  obj X := YonedaCollection F X.unop\n  map f := YonedaCollection.map₂ F f.unop\n\n"}
{"name":"CategoryTheory.OverPresheafAux.yonedaCollectionPresheaf_obj","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : Opposite C\n⊢ Eq ((CategoryTheory.OverPresheafAux.yonedaCollectionPresheaf A F).obj X) (CategoryTheory.OverPresheafAux.YonedaCollection F (Opposite.unop X))","decl":"/-- Given `F : (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v`, this is the presheaf that is given by\n    `YonedaCollection F X` on objects. -/\n@[simps]\ndef yonedaCollectionPresheaf (A : Cᵒᵖ ⥤ Type v) (F : (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v) :\n    Cᵒᵖ ⥤ Type v where\n  obj X := YonedaCollection F X.unop\n  map f := YonedaCollection.map₂ F f.unop\n\n"}
{"name":"CategoryTheory.OverPresheafAux.yonedaCollectionPresheafMap₁_app","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF G : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nη : Quiver.Hom F G\nx✝ : Opposite C\na✝ : CategoryTheory.OverPresheafAux.YonedaCollection F (Opposite.unop x✝)\n⊢ Eq ((CategoryTheory.OverPresheafAux.yonedaCollectionPresheafMap₁ η).app x✝ a✝) (CategoryTheory.OverPresheafAux.YonedaCollection.map₁ η a✝)","decl":"/-- Functoriality of `yonedaCollectionPresheaf A F` in `F`. -/\n@[simps]\ndef yonedaCollectionPresheafMap₁ {F G : (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v} (η : F ⟶ G) :\n    yonedaCollectionPresheaf A F ⟶ yonedaCollectionPresheaf A G where\n  app _ := YonedaCollection.map₁ η\n  naturality := by\n    intros\n    ext\n    simp\n\n"}
{"name":"CategoryTheory.OverPresheafAux.yonedaCollectionFunctor_map","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nX✝ Y✝ : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nη : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.OverPresheafAux.yonedaCollectionFunctor A).map η) (CategoryTheory.OverPresheafAux.yonedaCollectionPresheafMap₁ η)","decl":"/-- This is the functor `F ↦ X ↦ YonedaCollection F X`. -/\n@[simps]\ndef yonedaCollectionFunctor (A : Cᵒᵖ ⥤ Type v) :\n    ((CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v) ⥤ Cᵒᵖ ⥤ Type v where\n  obj := yonedaCollectionPresheaf A\n  map η := yonedaCollectionPresheafMap₁ η\n\n"}
{"name":"CategoryTheory.OverPresheafAux.yonedaCollectionFunctor_obj","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\n⊢ Eq ((CategoryTheory.OverPresheafAux.yonedaCollectionFunctor A).obj F) (CategoryTheory.OverPresheafAux.yonedaCollectionPresheaf A F)","decl":"/-- This is the functor `F ↦ X ↦ YonedaCollection F X`. -/\n@[simps]\ndef yonedaCollectionFunctor (A : Cᵒᵖ ⥤ Type v) :\n    ((CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v) ⥤ Cᵒᵖ ⥤ Type v where\n  obj := yonedaCollectionPresheaf A\n  map η := yonedaCollectionPresheafMap₁ η\n\n"}
{"name":"CategoryTheory.OverPresheafAux.yonedaCollectionPresheafToA_app","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nx✝ : Opposite C\np : CategoryTheory.OverPresheafAux.YonedaCollection F (Opposite.unop x✝)\n⊢ Eq ((CategoryTheory.OverPresheafAux.yonedaCollectionPresheafToA F).app x✝ p) p.yonedaEquivFst","decl":"/-- The Yoneda lemma yields a natural transformation `yonedaCollectionPresheaf A F ⟶ A`. -/\n@[simps]\ndef yonedaCollectionPresheafToA (F : (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v) :\n    yonedaCollectionPresheaf A F ⟶ A where\n  app _ := YonedaCollection.yonedaEquivFst\n\n"}
{"name":"CategoryTheory.OverPresheafAux.costructuredArrowPresheafToOver_obj","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nY : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\n⊢ Eq ((CategoryTheory.OverPresheafAux.costructuredArrowPresheafToOver A).obj Y) (CategoryTheory.CostructuredArrow.mk (CategoryTheory.OverPresheafAux.yonedaCollectionPresheafToA Y))","decl":"/-- This is the reverse direction of the equivalence we're constructing. -/\n@[simps! obj map]\ndef costructuredArrowPresheafToOver (A : Cᵒᵖ ⥤ Type v) :\n    ((CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v) ⥤ Over A :=\n  (yonedaCollectionFunctor A).toOver _ (yonedaCollectionPresheafToA) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.OverPresheafAux.costructuredArrowPresheafToOver_map","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nX✝ Y✝ : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\ng : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.OverPresheafAux.costructuredArrowPresheafToOver A).map g) (CategoryTheory.CostructuredArrow.homMk (CategoryTheory.OverPresheafAux.yonedaCollectionPresheafMap₁ g) ⋯)","decl":"/-- This is the reverse direction of the equivalence we're constructing. -/\n@[simps! obj map]\ndef costructuredArrowPresheafToOver (A : Cᵒᵖ ⥤ Type v) :\n    ((CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v) ⥤ Over A :=\n  (yonedaCollectionFunctor A).toOver _ (yonedaCollectionPresheafToA) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.OverPresheafAux.unitForward_naturality₁","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F G : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nμ : Quiver.Hom G A\nε : Quiver.Hom F G\nhε : Eq (CategoryTheory.CategoryStruct.comp ε μ) η\nX : C\np : CategoryTheory.OverPresheafAux.YonedaCollection (CategoryTheory.OverPresheafAux.restrictedYonedaObj η) X\n⊢ Eq (CategoryTheory.OverPresheafAux.unitForward μ X (CategoryTheory.OverPresheafAux.YonedaCollection.map₁ (CategoryTheory.OverPresheafAux.restrictedYonedaObjMap₁ ε hε) p)) (ε.app { unop := X } (CategoryTheory.OverPresheafAux.unitForward η X p))","decl":"@[simp]\nlemma unitForward_naturality₁ {F G : Cᵒᵖ ⥤ Type v} {η : F ⟶ A} {μ : G ⟶ A} (ε : F ⟶ G)\n    (hε : ε ≫ μ = η) (X : C) (p : YonedaCollection (restrictedYonedaObj η) X) :\n    unitForward μ X (p.map₁ (restrictedYonedaObjMap₁ ε hε)) = ε.app _ (unitForward η X p) := by\n  simp [unitForward]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.unitForward_naturality₂","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nX Y : C\nf : Quiver.Hom X Y\np : CategoryTheory.OverPresheafAux.YonedaCollection (CategoryTheory.OverPresheafAux.restrictedYonedaObj η) Y\n⊢ Eq (CategoryTheory.OverPresheafAux.unitForward η X (CategoryTheory.OverPresheafAux.YonedaCollection.map₂ (CategoryTheory.OverPresheafAux.restrictedYonedaObj η) f p)) (F.map f.op (CategoryTheory.OverPresheafAux.unitForward η Y p))","decl":"@[simp]\nlemma unitForward_naturality₂ {F : Cᵒᵖ ⥤ Type v} (η : F ⟶ A) (X Y : C) (f : X ⟶ Y)\n    (p : YonedaCollection (restrictedYonedaObj η) Y) :\n    unitForward η X (YonedaCollection.map₂ (restrictedYonedaObj η) f p) =\n      F.map f.op (unitForward η Y p) := by\n  simp [unitForward]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.app_unitForward","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nX : Opposite C\np : CategoryTheory.OverPresheafAux.YonedaCollection (CategoryTheory.OverPresheafAux.restrictedYonedaObj η) (Opposite.unop X)\n⊢ Eq (η.app X (CategoryTheory.OverPresheafAux.unitForward η (Opposite.unop X) p)) p.yonedaEquivFst","decl":"@[simp]\nlemma app_unitForward {F : Cᵒᵖ ⥤ Type v} (η : F ⟶ A) (X : Cᵒᵖ)\n    (p : YonedaCollection (restrictedYonedaObj η) X.unop) :\n    η.app X (unitForward η X.unop p) = p.yonedaEquivFst := by\n  simpa [unitForward] using p.snd.app_val\n\n"}
{"name":"CategoryTheory.OverPresheafAux.unitForward_unitBackward","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nX : C\n⊢ Eq (Function.comp (CategoryTheory.OverPresheafAux.unitForward η X) (CategoryTheory.OverPresheafAux.unitBackward η X)) id","decl":"lemma unitForward_unitBackward {F : Cᵒᵖ ⥤ Type v} (η : F ⟶ A) (X : C) :\n    unitForward η X ∘ unitBackward η X = id :=\n  funext fun x => by simp [unitForward, unitBackward]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.unitBackward_unitForward","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nX : C\n⊢ Eq (Function.comp (CategoryTheory.OverPresheafAux.unitBackward η X) (CategoryTheory.OverPresheafAux.unitForward η X)) id","decl":"lemma unitBackward_unitForward {F : Cᵒᵖ ⥤ Type v} (η : F ⟶ A) (X : C) :\n    unitBackward η X ∘ unitForward η X = id := by\n  refine funext fun p => YonedaCollection.ext ?_ (OverArrows.ext ?_)\n  · simpa [unitForward, unitBackward] using congrArg yonedaEquiv.symm p.snd.app_val\n  · simp [unitForward, unitBackward]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.unitAuxAuxAux_hom","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nX : C\na✝ : CategoryTheory.OverPresheafAux.YonedaCollection (CategoryTheory.OverPresheafAux.restrictedYonedaObj η) X\n⊢ Eq ((CategoryTheory.OverPresheafAux.unitAuxAuxAux η X).hom a✝) (CategoryTheory.OverPresheafAux.unitForward η X a✝)","decl":"/-- Intermediate stage of assembling the unit. -/\n@[simps]\ndef unitAuxAuxAux {F : Cᵒᵖ ⥤ Type v} (η : F ⟶ A) (X : C) :\n    YonedaCollection (restrictedYonedaObj η) X ≅ F.obj (op X) where\n  hom := unitForward η X\n  inv := unitBackward η X\n  hom_inv_id := unitBackward_unitForward η X\n  inv_hom_id := unitForward_unitBackward η X\n\n"}
{"name":"CategoryTheory.OverPresheafAux.unitAuxAuxAux_inv","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nX : C\na✝ : F.obj { unop := X }\n⊢ Eq ((CategoryTheory.OverPresheafAux.unitAuxAuxAux η X).inv a✝) (CategoryTheory.OverPresheafAux.unitBackward η X a✝)","decl":"/-- Intermediate stage of assembling the unit. -/\n@[simps]\ndef unitAuxAuxAux {F : Cᵒᵖ ⥤ Type v} (η : F ⟶ A) (X : C) :\n    YonedaCollection (restrictedYonedaObj η) X ≅ F.obj (op X) where\n  hom := unitForward η X\n  inv := unitBackward η X\n  hom_inv_id := unitBackward_unitForward η X\n  inv_hom_id := unitForward_unitBackward η X\n\n"}
{"name":"CategoryTheory.OverPresheafAux.unitAuxAux_inv_app_snd_coe","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nX : Opposite C\na✝ : F.obj X\n⊢ Eq (↑((CategoryTheory.OverPresheafAux.unitAuxAux η).inv.app X a✝).snd) (CategoryTheory.OverPresheafAux.OverArrows.val ⟨a✝, ⋯⟩)","decl":"/-- Intermediate stage of assembling the unit. -/\n@[simps!]\ndef unitAuxAux {F : Cᵒᵖ ⥤ Type v} (η : F ⟶ A) :\n    yonedaCollectionPresheaf A (restrictedYonedaObj η) ≅ F :=\n  NatIso.ofComponents (fun X => unitAuxAuxAux η X.unop) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.OverPresheafAux.unitAuxAux_hom_app","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nX : Opposite C\na✝ : (CategoryTheory.OverPresheafAux.yonedaCollectionPresheaf A (CategoryTheory.OverPresheafAux.restrictedYonedaObj η)).obj X\n⊢ Eq ((CategoryTheory.OverPresheafAux.unitAuxAux η).hom.app X a✝) (CategoryTheory.OverPresheafAux.unitForward η (Opposite.unop X) a✝)","decl":"/-- Intermediate stage of assembling the unit. -/\n@[simps!]\ndef unitAuxAux {F : Cᵒᵖ ⥤ Type v} (η : F ⟶ A) :\n    yonedaCollectionPresheaf A (restrictedYonedaObj η) ≅ F :=\n  NatIso.ofComponents (fun X => unitAuxAuxAux η X.unop) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.OverPresheafAux.unitAuxAux_inv_app_fst","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom F A\nX : Opposite C\na✝ : F.obj X\n⊢ Eq ((CategoryTheory.OverPresheafAux.unitAuxAux η).inv.app X a✝).fst (η.app X a✝)","decl":"/-- Intermediate stage of assembling the unit. -/\n@[simps!]\ndef unitAuxAux {F : Cᵒᵖ ⥤ Type v} (η : F ⟶ A) :\n    yonedaCollectionPresheaf A (restrictedYonedaObj η) ≅ F :=\n  NatIso.ofComponents (fun X => unitAuxAuxAux η X.unop) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.OverPresheafAux.unitAux_hom","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nη : CategoryTheory.Over A\n⊢ Eq (CategoryTheory.OverPresheafAux.unitAux η).hom { left := (CategoryTheory.OverPresheafAux.unitAuxAux η.hom).hom, right := CategoryTheory.CategoryStruct.id { as := PUnit.unit }, w := ⋯ }","decl":"/-- Intermediate stage of assembling the unit. -/\n@[simps! hom]\ndef unitAux (η : Over A) : (restrictedYoneda A ⋙ costructuredArrowPresheafToOver A).obj η ≅ η :=\n  Over.isoMk (unitAuxAux η.hom) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.OverPresheafAux.OverArrows.yonedaCollectionPresheafToA_val_fst","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\np : CategoryTheory.OverPresheafAux.OverArrows (CategoryTheory.OverPresheafAux.yonedaCollectionPresheafToA F) s\n⊢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.fst p.val) s","decl":"@[simp]\nlemma OverArrows.yonedaCollectionPresheafToA_val_fst (s : yoneda.obj X ⟶ A)\n    (p : OverArrows (yonedaCollectionPresheafToA F) s) : p.val.fst = s := by\n  simpa [YonedaCollection.yonedaEquivFst_eq] using p.app_val\n\n"}
{"name":"CategoryTheory.OverPresheafAux.counitForward_val_fst","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\ns : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\nx : F.obj { unop := s }\n⊢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.fst (CategoryTheory.OverPresheafAux.counitForward F s x).val) s.hom","decl":"lemma counitForward_val_fst (s : CostructuredArrow yoneda A) (x : F.obj (op s)) :\n    (counitForward F s x).val.fst = s.hom := by\n  simp\n\n"}
{"name":"CategoryTheory.OverPresheafAux.counitForward_val_snd","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\ns : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\nx : F.obj { unop := s }\n⊢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.snd (CategoryTheory.OverPresheafAux.counitForward F s x).val) (F.map (CategoryTheory.eqToHom ⋯) x)","decl":"@[simp]\nlemma counitForward_val_snd (s : CostructuredArrow yoneda A) (x : F.obj (op s)) :\n    (counitForward F s x).val.snd = F.map (eqToHom (by simp [← CostructuredArrow.eq_mk])) x :=\n  YonedaCollection.mk_snd _ _\n\n"}
{"name":"CategoryTheory.OverPresheafAux.counitForward_naturality₁","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF G : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nη : Quiver.Hom F G\ns : Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)\nx : F.obj s\n⊢ Eq (CategoryTheory.OverPresheafAux.counitForward G (Opposite.unop s) (η.app s x)) ((CategoryTheory.OverPresheafAux.counitForward F (Opposite.unop s) x).map₁ (CategoryTheory.OverPresheafAux.yonedaCollectionPresheafMap₁ η) ⋯)","decl":"@[simp]\nlemma counitForward_naturality₁ {G : (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v} (η : F ⟶ G)\n    (s : (CostructuredArrow yoneda A)ᵒᵖ) (x : F.obj s) : counitForward G s.unop (η.app s x) =\n      OverArrows.map₁ (counitForward F s.unop x) (yonedaCollectionPresheafMap₁ η) (by aesop_cat) :=\n  OverArrows.ext <| YonedaCollection.ext (by simp) (by simp)\n\n"}
{"name":"CategoryTheory.OverPresheafAux.counitForward_naturality₂","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\ns t : Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)\nf : Quiver.Hom t s\nx : F.obj t\n⊢ Eq (CategoryTheory.OverPresheafAux.counitForward F (Opposite.unop s) (F.map f x)) ((CategoryTheory.OverPresheafAux.counitForward F (Opposite.unop t) x).map₂ f.unop.left ⋯)","decl":"@[simp]\nlemma counitForward_naturality₂ (s t : (CostructuredArrow yoneda A)ᵒᵖ) (f : t ⟶ s) (x : F.obj t) :\n    counitForward F s.unop (F.map f x) =\n      OverArrows.map₂ (counitForward F t.unop x) f.unop.left (by simp) := by\n  refine OverArrows.ext <| YonedaCollection.ext (by simp) ?_\n  have : (CostructuredArrow.mkPrecomp t.unop.hom f.unop.left).op =\n      f ≫ eqToHom (by simp [← CostructuredArrow.eq_mk]) := by\n    apply Quiver.Hom.unop_inj\n    simp\n  aesop_cat\n\n"}
{"name":"CategoryTheory.OverPresheafAux.counitForward_counitBackward","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\ns : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\n⊢ Eq (Function.comp (CategoryTheory.OverPresheafAux.counitForward F s) (CategoryTheory.OverPresheafAux.counitBackward F s)) id","decl":"lemma counitForward_counitBackward (F : (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v)\n    (s : CostructuredArrow yoneda A) : counitForward F s ∘ counitBackward F s = id :=\n  funext fun p => OverArrows.ext <| YonedaCollection.ext (by simp) (by simp [counitBackward])\n\n"}
{"name":"CategoryTheory.OverPresheafAux.counitBackward_counitForward","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\ns : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\n⊢ Eq (Function.comp (CategoryTheory.OverPresheafAux.counitBackward F s) (CategoryTheory.OverPresheafAux.counitForward F s)) id","decl":"lemma counitBackward_counitForward (F : (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v)\n    (s : CostructuredArrow yoneda A) : counitBackward F s ∘ counitForward F s = id :=\n  funext fun x => by simp [counitBackward]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.counitAuxAux_inv","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\ns : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\na✝ : CategoryTheory.OverPresheafAux.OverArrows (CategoryTheory.OverPresheafAux.yonedaCollectionPresheafToA F) s.hom\n⊢ Eq ((CategoryTheory.OverPresheafAux.counitAuxAux F s).inv a✝) (CategoryTheory.OverPresheafAux.counitBackward F s a✝)","decl":"/-- Intermediate stage of assembling the counit. -/\n@[simps]\ndef counitAuxAux (F : (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v) (s : CostructuredArrow yoneda A) :\n    F.obj (op s) ≅ OverArrows (yonedaCollectionPresheafToA F) s.hom where\n  hom := counitForward F s\n  inv := counitBackward F s\n  hom_inv_id := counitBackward_counitForward F s\n  inv_hom_id := counitForward_counitBackward F s\n\n"}
{"name":"CategoryTheory.OverPresheafAux.counitAuxAux_hom","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\ns : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\na✝ : F.obj { unop := s }\n⊢ Eq ((CategoryTheory.OverPresheafAux.counitAuxAux F s).hom a✝) (CategoryTheory.OverPresheafAux.counitForward F s a✝)","decl":"/-- Intermediate stage of assembling the counit. -/\n@[simps]\ndef counitAuxAux (F : (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v) (s : CostructuredArrow yoneda A) :\n    F.obj (op s) ≅ OverArrows (yonedaCollectionPresheafToA F) s.hom where\n  hom := counitForward F s\n  inv := counitBackward F s\n  hom_inv_id := counitBackward_counitForward F s\n  inv_hom_id := counitForward_counitBackward F s\n\n"}
{"name":"CategoryTheory.OverPresheafAux.counitAux_hom","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\n⊢ Eq (CategoryTheory.OverPresheafAux.counitAux F).hom { app := fun X => (CategoryTheory.OverPresheafAux.counitAuxAux F (Opposite.unop X)).hom, naturality := ⋯ }","decl":"/-- Intermediate stage of assembling the counit. -/\n@[simps! hom]\ndef counitAux (F : (CostructuredArrow yoneda A)ᵒᵖ ⥤ Type v) :\n    F ≅ restrictedYonedaObj (yonedaCollectionPresheafToA F) :=\n  NatIso.ofComponents (fun s => counitAuxAux F s.unop) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.overEquivPresheafCostructuredArrow_inverse_map_toOverCompYoneda","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nT : CategoryTheory.Over A\nX : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\nf : Quiver.Hom ((CategoryTheory.CostructuredArrow.toOver CategoryTheory.yoneda A).obj X) T\n⊢ Eq ((CategoryTheory.overEquivPresheafCostructuredArrow A).inverse.map ((CategoryTheory.CostructuredArrow.toOverCompYoneda A T).hom.app { unop := X } f)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CostructuredArrow.toOverCompOverEquivPresheafCostructuredArrow A).isoCompInverse.inv.app X) (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.overEquivPresheafCostructuredArrow A).unit.app T)))","decl":"@[simp]\ntheorem CostructuredArrow.overEquivPresheafCostructuredArrow_inverse_map_toOverCompYoneda\n    {A : Cᵒᵖ ⥤ Type v} {T : Over A} {X : CostructuredArrow yoneda A}\n    (f : (CostructuredArrow.toOver yoneda A).obj X ⟶ T) :\n    (overEquivPresheafCostructuredArrow A).inverse.map\n      (((CostructuredArrow.toOverCompYoneda A T).hom.app (op X) f)) =\n      (CostructuredArrow.toOverCompOverEquivPresheafCostructuredArrow A).isoCompInverse.inv.app X ≫\n        f ≫ (overEquivPresheafCostructuredArrow A).unit.app T := by\n  simp [CostructuredArrow.toOverCompYoneda]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.overEquivPresheafCostructuredArrow_functor_map_toOverCompYoneda","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nT : CategoryTheory.Over A\nX : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\nf : Quiver.Hom (CategoryTheory.yoneda.obj X) ((CategoryTheory.overEquivPresheafCostructuredArrow A).functor.obj T)\n⊢ Eq ((CategoryTheory.overEquivPresheafCostructuredArrow A).functor.map ((CategoryTheory.CostructuredArrow.toOverCompYoneda A T).inv.app { unop := X } f)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CostructuredArrow.toOverCompOverEquivPresheafCostructuredArrow A).hom.app X) f)","decl":"@[simp]\ntheorem CostructuredArrow.overEquivPresheafCostructuredArrow_functor_map_toOverCompYoneda\n    {A : Cᵒᵖ ⥤ Type v} {T : Over A} {X : CostructuredArrow yoneda A}\n    (f : yoneda.obj X ⟶ (overEquivPresheafCostructuredArrow A).functor.obj T) :\n    (overEquivPresheafCostructuredArrow A).functor.map\n      (((CostructuredArrow.toOverCompYoneda A T).inv.app (op X) f)) =\n      (CostructuredArrow.toOverCompOverEquivPresheafCostructuredArrow A).hom.app X ≫ f := by\n  simp [CostructuredArrow.toOverCompYoneda]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.overEquivPresheafCostructuredArrow_inverse_map_toOverCompCoyoneda","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nT : CategoryTheory.Over A\nX : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\nf : Quiver.Hom ((CategoryTheory.CostructuredArrow.toOver CategoryTheory.yoneda A).obj X) T\n⊢ Eq ((CategoryTheory.overEquivPresheafCostructuredArrow A).inverse.map (((CategoryTheory.CostructuredArrow.toOverCompCoyoneda A).hom.app { unop := X }).app T f)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CostructuredArrow.toOverCompOverEquivPresheafCostructuredArrow A).isoCompInverse.inv.app X) (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.overEquivPresheafCostructuredArrow A).unit.app T)))","decl":"@[simp]\ntheorem CostructuredArrow.overEquivPresheafCostructuredArrow_inverse_map_toOverCompCoyoneda\n    {A : Cᵒᵖ ⥤ Type v} {T : Over A} {X : CostructuredArrow yoneda A}\n    (f : (CostructuredArrow.toOver yoneda A).obj X ⟶ T) :\n    (overEquivPresheafCostructuredArrow A).inverse.map\n      (((CostructuredArrow.toOverCompCoyoneda A).hom.app (op X)).app T f) =\n      (CostructuredArrow.toOverCompOverEquivPresheafCostructuredArrow A).isoCompInverse.inv.app X ≫\n        f ≫ (overEquivPresheafCostructuredArrow A).unit.app T := by\n  simp [CostructuredArrow.toOverCompCoyoneda]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.overEquivPresheafCostructuredArrow_functor_map_toOverCompCoyoneda","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nT : CategoryTheory.Over A\nX : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\nf : Quiver.Hom (CategoryTheory.yoneda.obj X) ((CategoryTheory.overEquivPresheafCostructuredArrow A).functor.obj T)\n⊢ Eq ((CategoryTheory.overEquivPresheafCostructuredArrow A).functor.map (((CategoryTheory.CostructuredArrow.toOverCompCoyoneda A).inv.app { unop := X }).app T f)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CostructuredArrow.toOverCompOverEquivPresheafCostructuredArrow A).hom.app X) f)","decl":"@[simp]\ntheorem CostructuredArrow.overEquivPresheafCostructuredArrow_functor_map_toOverCompCoyoneda\n    {A : Cᵒᵖ ⥤ Type v} {T : Over A} {X : CostructuredArrow yoneda A}\n    (f : yoneda.obj X ⟶ (overEquivPresheafCostructuredArrow A).functor.obj T) :\n    (overEquivPresheafCostructuredArrow A).functor.map\n      (((CostructuredArrow.toOverCompCoyoneda A).inv.app (op X)).app T f) =\n      (CostructuredArrow.toOverCompOverEquivPresheafCostructuredArrow A).hom.app X ≫ f := by\n  simp [CostructuredArrow.toOverCompCoyoneda]\n\n"}
