{"name":"CategoryTheory.OverPresheafAux.MakesOverArrow.app","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nu : F.obj { unop := X }\nself : CategoryTheory.OverPresheafAux.MakesOverArrow Œ∑ s u\n‚ä¢ Eq (Œ∑.app { unop := X } u) (CategoryTheory.yonedaEquiv s)","decl":"/-- Via the Yoneda lemma, `u : F.obj (op X)` defines a natural transformation `yoneda.obj X ‚ü∂ F`\n    and via the element `Œ∑.app (op X) u` also a morphism `yoneda.obj X ‚ü∂ A`. This structure\n    witnesses the fact that these morphisms from a commutative triangle with `Œ∑ : F ‚ü∂ A`, i.e.,\n    that `yoneda.obj X ‚ü∂ F` lifts to a morphism in `Over A`. -/\nstructure MakesOverArrow {F : C·µí·µñ ‚•§ Type v} (Œ∑ : F ‚ü∂ A) {X : C} (s : yoneda.obj X ‚ü∂ A)\n    (u : F.obj (op X)) : Prop where\n  app : Œ∑.app (op X) u = yonedaEquiv s\n\n"}
{"name":"CategoryTheory.OverPresheafAux.MakesOverArrow.map‚ÇÅ","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F G : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nŒº : Quiver.Hom G A\nŒµ : Quiver.Hom F G\nhŒµ : Eq (CategoryTheory.CategoryStruct.comp Œµ Œº) Œ∑\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nu : F.obj { unop := X }\nh : CategoryTheory.OverPresheafAux.MakesOverArrow Œ∑ s u\n‚ä¢ CategoryTheory.OverPresheafAux.MakesOverArrow Œº s (Œµ.app { unop := X } u)","decl":"/-- \"Functoriality\" of `MakesOverArrow Œ∑ s` in `Œ∑`. -/\nlemma map‚ÇÅ {F G : C·µí·µñ ‚•§ Type v} {Œ∑ : F ‚ü∂ A} {Œº : G ‚ü∂ A} {Œµ : F ‚ü∂ G}\n    (hŒµ : Œµ ‚â´ Œº = Œ∑) {X : C} {s : yoneda.obj X ‚ü∂ A} {u : F.obj (op X)}\n    (h : MakesOverArrow Œ∑ s u) : MakesOverArrow Œº s (Œµ.app _ u) :=\n  ‚ü®by rw [‚Üê elementwise_of% NatTrans.comp_app Œµ Œº, hŒµ, h.app]‚ü©\n\n"}
{"name":"CategoryTheory.OverPresheafAux.MakesOverArrow.map‚ÇÇ","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nX Y : C\nf : Quiver.Hom X Y\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nt : Quiver.Hom (CategoryTheory.yoneda.obj Y) A\nhst : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map f) t) s\nu : F.obj { unop := Y }\nh : CategoryTheory.OverPresheafAux.MakesOverArrow Œ∑ t u\n‚ä¢ CategoryTheory.OverPresheafAux.MakesOverArrow Œ∑ s (F.map f.op u)","decl":"/-- \"Functoriality of `MakesOverArrow Œ∑ s` in `s`. -/\nlemma map‚ÇÇ {F : C·µí·µñ ‚•§ Type v} {Œ∑ : F ‚ü∂ A} {X Y : C} (f : X ‚ü∂ Y)\n    {s : yoneda.obj X ‚ü∂ A} {t : yoneda.obj Y ‚ü∂ A} (hst : yoneda.map f ‚â´ t = s)\n    {u : F.obj (op Y)} (h : MakesOverArrow Œ∑ t u) : MakesOverArrow Œ∑ s (F.map f.op u) :=\n  ‚ü®by rw [elementwise_of% Œ∑.naturality, h.app, yonedaEquiv_naturality, hst]‚ü©\n\n"}
{"name":"CategoryTheory.OverPresheafAux.MakesOverArrow.of_arrow","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nf : Quiver.Hom (CategoryTheory.yoneda.obj X) F\nhf : Eq (CategoryTheory.CategoryStruct.comp f Œ∑) s\n‚ä¢ CategoryTheory.OverPresheafAux.MakesOverArrow Œ∑ s (CategoryTheory.yonedaEquiv f)","decl":"lemma of_arrow {F : C·µí·µñ ‚•§ Type v} {Œ∑ : F ‚ü∂ A} {X : C} {s : yoneda.obj X ‚ü∂ A}\n    {f : yoneda.obj X ‚ü∂ F} (hf : f ‚â´ Œ∑ = s) : MakesOverArrow Œ∑ s (yonedaEquiv f) :=\n  ‚ü®hf ‚ñ∏ rfl‚ü©\n\n"}
{"name":"CategoryTheory.OverPresheafAux.MakesOverArrow.of_yoneda_arrow","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nY : C\nŒ∑ : Quiver.Hom (CategoryTheory.yoneda.obj Y) A\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nf : Quiver.Hom X Y\nhf : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map f) Œ∑) s\n‚ä¢ CategoryTheory.OverPresheafAux.MakesOverArrow Œ∑ s f","decl":"lemma of_yoneda_arrow {Y : C} {Œ∑ : yoneda.obj Y ‚ü∂ A} {X : C} {s : yoneda.obj X ‚ü∂ A} {f : X ‚ü∂ Y}\n    (hf : yoneda.map f ‚â´ Œ∑ = s) : MakesOverArrow Œ∑ s f := by\n  simpa only [yonedaEquiv_yoneda_map f] using of_arrow hf\n\n"}
{"name":"CategoryTheory.OverPresheafAux.OverArrows.val_mk","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nu : F.obj { unop := X }\nh : CategoryTheory.OverPresheafAux.MakesOverArrow Œ∑ s u\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.OverArrows.val ‚ü®u, h‚ü©) u","decl":"@[simp]\nlemma val_mk {F : C·µí·µñ ‚•§ Type v} (Œ∑ : F ‚ü∂ A) {X : C} (s : yoneda.obj X ‚ü∂ A) (u : F.obj (op X))\n    (h : MakesOverArrow Œ∑ s u) : val ‚ü®u, h‚ü© = u :=\n  rfl\n\n"}
{"name":"CategoryTheory.OverPresheafAux.OverArrows.ext","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nu v : CategoryTheory.OverPresheafAux.OverArrows Œ∑ s\na‚úù : Eq u.val v.val\n‚ä¢ Eq u v","decl":"@[ext]\nlemma ext {F : C·µí·µñ ‚•§ Type v} {Œ∑ : F ‚ü∂ A} {X : C} {s : yoneda.obj X ‚ü∂ A}\n    {u v : OverArrows Œ∑ s} : u.val = v.val ‚Üí u = v :=\n  Subtype.ext\n\n"}
{"name":"CategoryTheory.OverPresheafAux.OverArrows.ext_iff","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nu v : CategoryTheory.OverPresheafAux.OverArrows Œ∑ s\n‚ä¢ Iff (Eq u v) (Eq u.val v.val)","decl":"@[ext]\nlemma ext {F : C·µí·µñ ‚•§ Type v} {Œ∑ : F ‚ü∂ A} {X : C} {s : yoneda.obj X ‚ü∂ A}\n    {u v : OverArrows Œ∑ s} : u.val = v.val ‚Üí u = v :=\n  Subtype.ext\n\n"}
{"name":"CategoryTheory.OverPresheafAux.OverArrows.app_val","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\np : CategoryTheory.OverPresheafAux.OverArrows Œ∑ s\n‚ä¢ Eq (Œ∑.app { unop := X } p.val) (CategoryTheory.yonedaEquiv s)","decl":"/-- The defining property of `OverArrows.val`. -/\nlemma app_val {F : C·µí·µñ ‚•§ Type v} {Œ∑ : F ‚ü∂ A} {X : C} {s : yoneda.obj X ‚ü∂ A}\n    (p : OverArrows Œ∑ s) : Œ∑.app (op X) p.val = yonedaEquiv s :=\n  p.prop.app\n\n"}
{"name":"CategoryTheory.OverPresheafAux.OverArrows.map_val","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nY : C\nŒ∑ : Quiver.Hom (CategoryTheory.yoneda.obj Y) A\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\np : CategoryTheory.OverPresheafAux.OverArrows Œ∑ s\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map p.val) Œ∑) s","decl":"/-- In the special case `F = yoneda.obj Y`, the element `p.val` for `p : OverArrows Œ∑ s` is itself\n    a morphism `X ‚ü∂ Y`. -/\n@[simp]\nlemma map_val {Y : C} {Œ∑ : yoneda.obj Y ‚ü∂ A} {X : C} {s : yoneda.obj X ‚ü∂ A}\n    (p : OverArrows Œ∑ s) : yoneda.map p.val ‚â´ Œ∑ = s := by\n  rw [‚Üê yonedaEquiv.injective.eq_iff, yonedaEquiv_comp, yonedaEquiv_yoneda_map]\n  simp only [unop_op, p.app_val]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.OverArrows.map‚ÇÅ_val","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F G : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nŒº : Quiver.Hom G A\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nu : CategoryTheory.OverPresheafAux.OverArrows Œ∑ s\nŒµ : Quiver.Hom F G\nhŒµ : Eq (CategoryTheory.CategoryStruct.comp Œµ Œº) Œ∑\n‚ä¢ Eq (u.map‚ÇÅ Œµ hŒµ).val (Œµ.app { unop := X } u.val)","decl":"@[simp]\nlemma map‚ÇÅ_val {F G : C·µí·µñ ‚•§ Type v} {Œ∑ : F ‚ü∂ A} {Œº : G ‚ü∂ A} {X : C}\n    (s : yoneda.obj X ‚ü∂ A) (u : OverArrows Œ∑ s) (Œµ : F ‚ü∂ G) (hŒµ : Œµ ‚â´ Œº = Œ∑) :\n    (u.map‚ÇÅ Œµ hŒµ).val = Œµ.app _ u.val :=\n  rfl\n\n"}
{"name":"CategoryTheory.OverPresheafAux.OverArrows.map‚ÇÇ_val","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nX Y : C\nf : Quiver.Hom X Y\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nt : Quiver.Hom (CategoryTheory.yoneda.obj Y) A\nhst : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map f) t) s\nu : CategoryTheory.OverPresheafAux.OverArrows Œ∑ t\n‚ä¢ Eq (u.map‚ÇÇ f hst).val (F.map f.op u.val)","decl":"@[simp]\nlemma map‚ÇÇ_val {F : C·µí·µñ ‚•§ Type v} {Œ∑ : F ‚ü∂ A} {X Y : C} (f : X ‚ü∂ Y)\n    {s : yoneda.obj X ‚ü∂ A} {t : yoneda.obj Y ‚ü∂ A} (hst : yoneda.map f ‚â´ t = s)\n    (u : OverArrows Œ∑ t) : (u.map‚ÇÇ f hst).val = F.map f.op u.val :=\n  rfl\n\n"}
{"name":"CategoryTheory.OverPresheafAux.OverArrows.map‚ÇÅ_map‚ÇÇ","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F G : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nŒº : Quiver.Hom G A\nŒµ : Quiver.Hom F G\nhŒµ : Eq (CategoryTheory.CategoryStruct.comp Œµ Œº) Œ∑\nX Y : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nt : Quiver.Hom (CategoryTheory.yoneda.obj Y) A\nf : Quiver.Hom X Y\nhf : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map f) t) s\nu : CategoryTheory.OverPresheafAux.OverArrows Œ∑ t\n‚ä¢ Eq ((u.map‚ÇÅ Œµ hŒµ).map‚ÇÇ f hf) ((u.map‚ÇÇ f hf).map‚ÇÅ Œµ hŒµ)","decl":"@[simp]\nlemma map‚ÇÅ_map‚ÇÇ {F G : C·µí·µñ ‚•§ Type v} {Œ∑ : F ‚ü∂ A} {Œº : G ‚ü∂ A} (Œµ : F ‚ü∂ G)\n    (hŒµ : Œµ ‚â´ Œº = Œ∑) {X Y : C} {s : yoneda.obj X ‚ü∂ A} {t : yoneda.obj Y ‚ü∂ A} (f : X ‚ü∂ Y)\n    (hf : yoneda.map f ‚â´ t = s) (u : OverArrows Œ∑ t) :\n    (u.map‚ÇÅ Œµ hŒµ).map‚ÇÇ f hf = (u.map‚ÇÇ f hf).map‚ÇÅ Œµ hŒµ :=\n  OverArrows.ext <| (elementwise_of% (Œµ.naturality f.op).symm) u.val\n\n"}
{"name":"CategoryTheory.OverPresheafAux.OverArrows.yonedaArrow_val","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nY : C\nŒ∑ : Quiver.Hom (CategoryTheory.yoneda.obj Y) A\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nf : Quiver.Hom X Y\nhf : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map f) Œ∑) s\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.OverArrows.yonedaArrow f hf).val f","decl":"@[simp]\nlemma yonedaArrow_val {Y : C} {Œ∑ : yoneda.obj Y ‚ü∂ A} {X : C} {s : yoneda.obj X ‚ü∂ A} {f : X ‚ü∂ Y}\n    (hf : yoneda.map f ‚â´ Œ∑ = s) : (yonedaArrow f hf).val = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.OverPresheafAux.restrictedYonedaObj_obj","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\ns : Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)\n‚ä¢ Eq ((CategoryTheory.OverPresheafAux.restrictedYonedaObj Œ∑).obj s) (CategoryTheory.OverPresheafAux.OverArrows Œ∑ (Opposite.unop s).hom)","decl":"/-- This is basically just `yoneda.obj Œ∑ : (Over A)·µí·µñ ‚•§ Type (max u v)` restricted along the\n    forgetful functor `CostructuredArrow yoneda A ‚•§ Over A`, but done in a way that we land in a\n    smaller universe. -/\n@[simps]\ndef restrictedYonedaObj {F : C·µí·µñ ‚•§ Type v} (Œ∑ : F ‚ü∂ A) :\n    (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v where\n  obj s := OverArrows Œ∑ s.unop.hom\n  map f u := u.map‚ÇÇ f.unop.left f.unop.w\n\n"}
{"name":"CategoryTheory.OverPresheafAux.restrictedYonedaObj_map","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nX‚úù Y‚úù : Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)\nf : Quiver.Hom X‚úù Y‚úù\nu : CategoryTheory.OverPresheafAux.OverArrows Œ∑ (Opposite.unop X‚úù).hom\n‚ä¢ Eq ((CategoryTheory.OverPresheafAux.restrictedYonedaObj Œ∑).map f u) (u.map‚ÇÇ f.unop.left ‚ãØ)","decl":"/-- This is basically just `yoneda.obj Œ∑ : (Over A)·µí·µñ ‚•§ Type (max u v)` restricted along the\n    forgetful functor `CostructuredArrow yoneda A ‚•§ Over A`, but done in a way that we land in a\n    smaller universe. -/\n@[simps]\ndef restrictedYonedaObj {F : C·µí·µñ ‚•§ Type v} (Œ∑ : F ‚ü∂ A) :\n    (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v where\n  obj s := OverArrows Œ∑ s.unop.hom\n  map f u := u.map‚ÇÇ f.unop.left f.unop.w\n\n"}
{"name":"CategoryTheory.OverPresheafAux.restrictedYonedaObjMap‚ÇÅ_app","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F G : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nŒº : Quiver.Hom G A\nŒµ : Quiver.Hom F G\nhŒµ : Eq (CategoryTheory.CategoryStruct.comp Œµ Œº) Œ∑\nx‚úù : Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)\nu : (CategoryTheory.OverPresheafAux.restrictedYonedaObj Œ∑).obj x‚úù\n‚ä¢ Eq ((CategoryTheory.OverPresheafAux.restrictedYonedaObjMap‚ÇÅ Œµ hŒµ).app x‚úù u) (CategoryTheory.OverPresheafAux.OverArrows.map‚ÇÅ u Œµ hŒµ)","decl":"/-- Functoriality of `restrictedYonedaObj Œ∑` in `Œ∑`. -/\n@[simps]\ndef restrictedYonedaObjMap‚ÇÅ {F G : C·µí·µñ ‚•§ Type v} {Œ∑ : F ‚ü∂ A} {Œº : G ‚ü∂ A} (Œµ : F ‚ü∂ G)\n    (hŒµ : Œµ ‚â´ Œº = Œ∑) : restrictedYonedaObj Œ∑ ‚ü∂ restrictedYonedaObj Œº where\n  app _ u := u.map‚ÇÅ Œµ hŒµ\n\n"}
{"name":"CategoryTheory.OverPresheafAux.restrictedYoneda_obj","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : CategoryTheory.Over A\n‚ä¢ Eq ((CategoryTheory.OverPresheafAux.restrictedYoneda A).obj Œ∑) (CategoryTheory.OverPresheafAux.restrictedYonedaObj Œ∑.hom)","decl":"/-- This is basically just `yoneda : Over A ‚•§ (Over A)·µí·µñ ‚•§ Type (max u v)` restricted in the second\n    argument along the forgetful functor `CostructuredArrow yoneda A ‚•§ Over A`, but done in a way\n    that we land in a smaller universe.\n\n    This is one direction of the equivalence we're constructing. -/\n@[simps]\ndef restrictedYoneda (A : C·µí·µñ ‚•§ Type v) : Over A ‚•§ (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v where\n  obj Œ∑ := restrictedYonedaObj Œ∑.hom\n  map Œµ := restrictedYonedaObjMap‚ÇÅ Œµ.left Œµ.w\n\n"}
{"name":"CategoryTheory.OverPresheafAux.restrictedYoneda_map","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nX‚úù Y‚úù : CategoryTheory.Over A\nŒµ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.OverPresheafAux.restrictedYoneda A).map Œµ) (CategoryTheory.OverPresheafAux.restrictedYonedaObjMap‚ÇÅ Œµ.left ‚ãØ)","decl":"/-- This is basically just `yoneda : Over A ‚•§ (Over A)·µí·µñ ‚•§ Type (max u v)` restricted in the second\n    argument along the forgetful functor `CostructuredArrow yoneda A ‚•§ Over A`, but done in a way\n    that we land in a smaller universe.\n\n    This is one direction of the equivalence we're constructing. -/\n@[simps]\ndef restrictedYoneda (A : C·µí·µñ ‚•§ Type v) : Over A ‚•§ (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v where\n  obj Œ∑ := restrictedYonedaObj Œ∑.hom\n  map Œµ := restrictedYonedaObjMap‚ÇÅ Œµ.left Œµ.w\n\n"}
{"name":"CategoryTheory.OverPresheafAux.map_mkPrecomp_eqToHom","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX Y : C\nf : Quiver.Hom X Y\ng g' : Quiver.Hom (CategoryTheory.yoneda.obj Y) A\nh : Eq g g'\nx : F.obj { unop := CategoryTheory.CostructuredArrow.mk g' }\n‚ä¢ Eq (F.map (CategoryTheory.CostructuredArrow.mkPrecomp g f).op (F.map (CategoryTheory.eqToHom ‚ãØ) x)) (F.map (CategoryTheory.eqToHom ‚ãØ) (F.map (CategoryTheory.CostructuredArrow.mkPrecomp g' f).op x))","decl":"/-- This lemma will be key to establishing good simp normal forms. -/\nlemma map_mkPrecomp_eqToHom {F : (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v} {X Y : C} {f : X ‚ü∂ Y}\n    {g g' : yoneda.obj Y ‚ü∂ A} (h : g = g') {x : F.obj (op (CostructuredArrow.mk g'))} :\n    F.map (CostructuredArrow.mkPrecomp g f).op (F.map (eqToHom (by rw [h])) x) =\n      F.map (eqToHom (by rw [h])) (F.map (CostructuredArrow.mkPrecomp g' f).op x) := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.yonedaEquivFst_eq","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\np : CategoryTheory.OverPresheafAux.YonedaCollection F X\n‚ä¢ Eq p.yonedaEquivFst (CategoryTheory.yonedaEquiv p.fst)","decl":"lemma yonedaEquivFst_eq (p : YonedaCollection F X) : p.yonedaEquivFst = yonedaEquiv p.fst :=\n  rfl\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.mk_fst","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nx : F.obj { unop := CategoryTheory.CostructuredArrow.mk s }\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.mk s x).fst s","decl":"@[simp]\nlemma mk_fst (s : yoneda.obj X ‚ü∂ A) (x : F.obj (op (CostructuredArrow.mk s))) : (mk s x).fst = s :=\n  Equiv.apply_symm_apply _ _\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.mk_snd","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\nx : F.obj { unop := CategoryTheory.CostructuredArrow.mk s }\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.mk s x).snd (F.map (CategoryTheory.eqToHom ‚ãØ) x)","decl":"@[simp]\nlemma mk_snd (s : yoneda.obj X ‚ü∂ A) (x : F.obj (op (CostructuredArrow.mk s))) :\n    (mk s x).snd = F.map (eqToHom <| by rw [YonedaCollection.mk_fst]) x :=\n  rfl\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.ext","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\np q : CategoryTheory.OverPresheafAux.YonedaCollection F X\nh : Eq p.fst q.fst\nh' : Eq (F.map (CategoryTheory.eqToHom ‚ãØ) q.snd) p.snd\n‚ä¢ Eq p q","decl":"@[ext (iff := false)]\nlemma ext {p q : YonedaCollection F X} (h : p.fst = q.fst)\n    (h' : F.map (eqToHom <| by rw [h]) q.snd = p.snd) : p = q := by\n  rcases p with ‚ü®p, p'‚ü©\n  rcases q with ‚ü®q, q'‚ü©\n  obtain rfl : p = q := yonedaEquiv.symm.injective h\n  exact Sigma.ext rfl (by simpa [snd] using h'.symm)\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÅ_fst","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\nG : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nŒ∑ : Quiver.Hom F G\np : CategoryTheory.OverPresheafAux.YonedaCollection F X\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÅ Œ∑ p).fst p.fst","decl":"@[simp]\nlemma map‚ÇÅ_fst {G : (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v} (Œ∑ : F ‚ü∂ G)\n    (p : YonedaCollection F X) : (YonedaCollection.map‚ÇÅ Œ∑ p).fst = p.fst := by\n  simp [map‚ÇÅ]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÅ_yonedaEquivFst","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\nG : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nŒ∑ : Quiver.Hom F G\np : CategoryTheory.OverPresheafAux.YonedaCollection F X\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÅ Œ∑ p).yonedaEquivFst p.yonedaEquivFst","decl":"@[simp]\nlemma map‚ÇÅ_yonedaEquivFst {G : (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v} (Œ∑ : F ‚ü∂ G)\n    (p : YonedaCollection F X) :\n    (YonedaCollection.map‚ÇÅ Œ∑ p).yonedaEquivFst = p.yonedaEquivFst := by\n  simp only [YonedaCollection.yonedaEquivFst_eq, map‚ÇÅ_fst]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÅ_snd","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\nG : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nŒ∑ : Quiver.Hom F G\np : CategoryTheory.OverPresheafAux.YonedaCollection F X\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÅ Œ∑ p).snd (G.map (CategoryTheory.eqToHom ‚ãØ) (Œ∑.app { unop := CategoryTheory.CostructuredArrow.mk p.fst } p.snd))","decl":"@[simp]\nlemma map‚ÇÅ_snd {G : (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v} (Œ∑ : F ‚ü∂ G)\n    (p : YonedaCollection F X) : (YonedaCollection.map‚ÇÅ Œ∑ p).snd =\n      G.map (eqToHom (by rw [YonedaCollection.map‚ÇÅ_fst])) (Œ∑.app _ p.snd) := by\n  simp [map‚ÇÅ]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÇ_fst","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX Y : C\nf : Quiver.Hom X Y\np : CategoryTheory.OverPresheafAux.YonedaCollection F Y\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÇ F f p).fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map f) p.fst)","decl":"@[simp]\nlemma map‚ÇÇ_fst {Y : C} (f : X ‚ü∂ Y) (p : YonedaCollection F Y) :\n    (YonedaCollection.map‚ÇÇ F f p).fst = yoneda.map f ‚â´ p.fst := by\n  simp [map‚ÇÇ]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÇ_yonedaEquivFst","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX Y : C\nf : Quiver.Hom X Y\np : CategoryTheory.OverPresheafAux.YonedaCollection F Y\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÇ F f p).yonedaEquivFst (A.map f.op p.yonedaEquivFst)","decl":"@[simp]\nlemma map‚ÇÇ_yonedaEquivFst {Y : C} (f : X ‚ü∂ Y) (p : YonedaCollection F Y) :\n    (YonedaCollection.map‚ÇÇ F f p).yonedaEquivFst = A.map f.op p.yonedaEquivFst := by\n  simp only [YonedaCollection.yonedaEquivFst_eq, map‚ÇÇ_fst, yonedaEquiv_naturality]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÇ_snd","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX Y : C\nf : Quiver.Hom X Y\np : CategoryTheory.OverPresheafAux.YonedaCollection F Y\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÇ F f p).snd (F.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.CostructuredArrow.mkPrecomp p.fst f).op (CategoryTheory.eqToHom ‚ãØ)) p.snd)","decl":"@[simp]\nlemma map‚ÇÇ_snd {Y : C} (f : X ‚ü∂ Y) (p : YonedaCollection F Y) :\n    (YonedaCollection.map‚ÇÇ F f p).snd = F.map ((CostructuredArrow.mkPrecomp p.fst f).op ‚â´\n      eqToHom (by rw [YonedaCollection.map‚ÇÇ_fst f])) p.snd := by\n  simp [map‚ÇÇ]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÅ_id","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÅ (CategoryTheory.CategoryStruct.id F)) id","decl":"@[simp]\nlemma map‚ÇÅ_id : YonedaCollection.map‚ÇÅ (ùüô F) (X := X) = id := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÅ_comp","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\nG H : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nŒ∑ : Quiver.Hom F G\nŒº : Quiver.Hom G H\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÅ (CategoryTheory.CategoryStruct.comp Œ∑ Œº)) (Function.comp (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÅ Œº) (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÅ Œ∑))","decl":"@[simp]\nlemma map‚ÇÅ_comp {G H : (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v} (Œ∑ : F ‚ü∂ G) (Œº : G ‚ü∂ H) :\n    YonedaCollection.map‚ÇÅ (Œ∑ ‚â´ Œº) (X := X) =\n      YonedaCollection.map‚ÇÅ Œº (X := X) ‚àò YonedaCollection.map‚ÇÅ Œ∑ (X := X) := by\n  ext; all_goals simp\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÇ_id","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÇ F (CategoryTheory.CategoryStruct.id X)) id","decl":"@[simp]\nlemma map‚ÇÇ_id : YonedaCollection.map‚ÇÇ F (ùüô X) = id := by\n  ext; all_goals simp\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÇ_comp","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÇ F (CategoryTheory.CategoryStruct.comp f g)) (Function.comp (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÇ F f) (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÇ F g))","decl":"@[simp]\nlemma map‚ÇÇ_comp {Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    YonedaCollection.map‚ÇÇ F (f ‚â´ g) = YonedaCollection.map‚ÇÇ F f ‚àò YonedaCollection.map‚ÇÇ F g := by\n  ext; all_goals simp\n\n"}
{"name":"CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÅ_map‚ÇÇ","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\nG : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nŒ∑ : Quiver.Hom F G\nY : C\nf : Quiver.Hom X Y\np : CategoryTheory.OverPresheafAux.YonedaCollection F Y\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÇ G f (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÅ Œ∑ p)) (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÅ Œ∑ (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÇ F f p))","decl":"@[simp]\nlemma map‚ÇÅ_map‚ÇÇ {G : (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v} (Œ∑ : F ‚ü∂ G) {Y : C} (f : X ‚ü∂ Y)\n    (p : YonedaCollection F Y) :\n    YonedaCollection.map‚ÇÇ G f (YonedaCollection.map‚ÇÅ Œ∑ p) =\n      YonedaCollection.map‚ÇÅ Œ∑ (YonedaCollection.map‚ÇÇ F f p) := by\n  ext; all_goals simp\n\n"}
{"name":"CategoryTheory.OverPresheafAux.yonedaCollectionPresheaf_map","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX‚úù Y‚úù : Opposite C\nf : Quiver.Hom X‚úù Y‚úù\np : CategoryTheory.OverPresheafAux.YonedaCollection F (Opposite.unop X‚úù)\n‚ä¢ Eq ((CategoryTheory.OverPresheafAux.yonedaCollectionPresheaf A F).map f p) (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÇ F f.unop p)","decl":"/-- Given `F : (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v`, this is the presheaf that is given by\n    `YonedaCollection F X` on objects. -/\n@[simps]\ndef yonedaCollectionPresheaf (A : C·µí·µñ ‚•§ Type v) (F : (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v) :\n    C·µí·µñ ‚•§ Type v where\n  obj X := YonedaCollection F X.unop\n  map f := YonedaCollection.map‚ÇÇ F f.unop\n\n"}
{"name":"CategoryTheory.OverPresheafAux.yonedaCollectionPresheaf_obj","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : Opposite C\n‚ä¢ Eq ((CategoryTheory.OverPresheafAux.yonedaCollectionPresheaf A F).obj X) (CategoryTheory.OverPresheafAux.YonedaCollection F (Opposite.unop X))","decl":"/-- Given `F : (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v`, this is the presheaf that is given by\n    `YonedaCollection F X` on objects. -/\n@[simps]\ndef yonedaCollectionPresheaf (A : C·µí·µñ ‚•§ Type v) (F : (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v) :\n    C·µí·µñ ‚•§ Type v where\n  obj X := YonedaCollection F X.unop\n  map f := YonedaCollection.map‚ÇÇ F f.unop\n\n"}
{"name":"CategoryTheory.OverPresheafAux.yonedaCollectionPresheafMap‚ÇÅ_app","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF G : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nŒ∑ : Quiver.Hom F G\nx‚úù : Opposite C\na‚úù : CategoryTheory.OverPresheafAux.YonedaCollection F (Opposite.unop x‚úù)\n‚ä¢ Eq ((CategoryTheory.OverPresheafAux.yonedaCollectionPresheafMap‚ÇÅ Œ∑).app x‚úù a‚úù) (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÅ Œ∑ a‚úù)","decl":"/-- Functoriality of `yonedaCollectionPresheaf A F` in `F`. -/\n@[simps]\ndef yonedaCollectionPresheafMap‚ÇÅ {F G : (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v} (Œ∑ : F ‚ü∂ G) :\n    yonedaCollectionPresheaf A F ‚ü∂ yonedaCollectionPresheaf A G where\n  app _ := YonedaCollection.map‚ÇÅ Œ∑\n  naturality := by\n    intros\n    ext\n    simp\n\n"}
{"name":"CategoryTheory.OverPresheafAux.yonedaCollectionFunctor_map","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nX‚úù Y‚úù : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nŒ∑ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.OverPresheafAux.yonedaCollectionFunctor A).map Œ∑) (CategoryTheory.OverPresheafAux.yonedaCollectionPresheafMap‚ÇÅ Œ∑)","decl":"/-- This is the functor `F ‚Ü¶ X ‚Ü¶ YonedaCollection F X`. -/\n@[simps]\ndef yonedaCollectionFunctor (A : C·µí·µñ ‚•§ Type v) :\n    ((CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v) ‚•§ C·µí·µñ ‚•§ Type v where\n  obj := yonedaCollectionPresheaf A\n  map Œ∑ := yonedaCollectionPresheafMap‚ÇÅ Œ∑\n\n"}
{"name":"CategoryTheory.OverPresheafAux.yonedaCollectionFunctor_obj","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\n‚ä¢ Eq ((CategoryTheory.OverPresheafAux.yonedaCollectionFunctor A).obj F) (CategoryTheory.OverPresheafAux.yonedaCollectionPresheaf A F)","decl":"/-- This is the functor `F ‚Ü¶ X ‚Ü¶ YonedaCollection F X`. -/\n@[simps]\ndef yonedaCollectionFunctor (A : C·µí·µñ ‚•§ Type v) :\n    ((CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v) ‚•§ C·µí·µñ ‚•§ Type v where\n  obj := yonedaCollectionPresheaf A\n  map Œ∑ := yonedaCollectionPresheafMap‚ÇÅ Œ∑\n\n"}
{"name":"CategoryTheory.OverPresheafAux.yonedaCollectionPresheafToA_app","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nx‚úù : Opposite C\np : CategoryTheory.OverPresheafAux.YonedaCollection F (Opposite.unop x‚úù)\n‚ä¢ Eq ((CategoryTheory.OverPresheafAux.yonedaCollectionPresheafToA F).app x‚úù p) p.yonedaEquivFst","decl":"/-- The Yoneda lemma yields a natural transformation `yonedaCollectionPresheaf A F ‚ü∂ A`. -/\n@[simps]\ndef yonedaCollectionPresheafToA (F : (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v) :\n    yonedaCollectionPresheaf A F ‚ü∂ A where\n  app _ := YonedaCollection.yonedaEquivFst\n\n"}
{"name":"CategoryTheory.OverPresheafAux.costructuredArrowPresheafToOver_obj","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nY : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\n‚ä¢ Eq ((CategoryTheory.OverPresheafAux.costructuredArrowPresheafToOver A).obj Y) (CategoryTheory.CostructuredArrow.mk (CategoryTheory.OverPresheafAux.yonedaCollectionPresheafToA Y))","decl":"/-- This is the reverse direction of the equivalence we're constructing. -/\n@[simps! obj map]\ndef costructuredArrowPresheafToOver (A : C·µí·µñ ‚•§ Type v) :\n    ((CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v) ‚•§ Over A :=\n  (yonedaCollectionFunctor A).toOver _ (yonedaCollectionPresheafToA) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.OverPresheafAux.costructuredArrowPresheafToOver_map","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nX‚úù Y‚úù : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.OverPresheafAux.costructuredArrowPresheafToOver A).map g) (CategoryTheory.CostructuredArrow.homMk (CategoryTheory.OverPresheafAux.yonedaCollectionPresheafMap‚ÇÅ g) ‚ãØ)","decl":"/-- This is the reverse direction of the equivalence we're constructing. -/\n@[simps! obj map]\ndef costructuredArrowPresheafToOver (A : C·µí·µñ ‚•§ Type v) :\n    ((CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v) ‚•§ Over A :=\n  (yonedaCollectionFunctor A).toOver _ (yonedaCollectionPresheafToA) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.OverPresheafAux.unitForward_naturality‚ÇÅ","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F G : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nŒº : Quiver.Hom G A\nŒµ : Quiver.Hom F G\nhŒµ : Eq (CategoryTheory.CategoryStruct.comp Œµ Œº) Œ∑\nX : C\np : CategoryTheory.OverPresheafAux.YonedaCollection (CategoryTheory.OverPresheafAux.restrictedYonedaObj Œ∑) X\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.unitForward Œº X (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÅ (CategoryTheory.OverPresheafAux.restrictedYonedaObjMap‚ÇÅ Œµ hŒµ) p)) (Œµ.app { unop := X } (CategoryTheory.OverPresheafAux.unitForward Œ∑ X p))","decl":"@[simp]\nlemma unitForward_naturality‚ÇÅ {F G : C·µí·µñ ‚•§ Type v} {Œ∑ : F ‚ü∂ A} {Œº : G ‚ü∂ A} (Œµ : F ‚ü∂ G)\n    (hŒµ : Œµ ‚â´ Œº = Œ∑) (X : C) (p : YonedaCollection (restrictedYonedaObj Œ∑) X) :\n    unitForward Œº X (p.map‚ÇÅ (restrictedYonedaObjMap‚ÇÅ Œµ hŒµ)) = Œµ.app _ (unitForward Œ∑ X p) := by\n  simp [unitForward]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.unitForward_naturality‚ÇÇ","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nX Y : C\nf : Quiver.Hom X Y\np : CategoryTheory.OverPresheafAux.YonedaCollection (CategoryTheory.OverPresheafAux.restrictedYonedaObj Œ∑) Y\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.unitForward Œ∑ X (CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÇ (CategoryTheory.OverPresheafAux.restrictedYonedaObj Œ∑) f p)) (F.map f.op (CategoryTheory.OverPresheafAux.unitForward Œ∑ Y p))","decl":"@[simp]\nlemma unitForward_naturality‚ÇÇ {F : C·µí·µñ ‚•§ Type v} (Œ∑ : F ‚ü∂ A) (X Y : C) (f : X ‚ü∂ Y)\n    (p : YonedaCollection (restrictedYonedaObj Œ∑) Y) :\n    unitForward Œ∑ X (YonedaCollection.map‚ÇÇ (restrictedYonedaObj Œ∑) f p) =\n      F.map f.op (unitForward Œ∑ Y p) := by\n  simp [unitForward]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.app_unitForward","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nX : Opposite C\np : CategoryTheory.OverPresheafAux.YonedaCollection (CategoryTheory.OverPresheafAux.restrictedYonedaObj Œ∑) (Opposite.unop X)\n‚ä¢ Eq (Œ∑.app X (CategoryTheory.OverPresheafAux.unitForward Œ∑ (Opposite.unop X) p)) p.yonedaEquivFst","decl":"@[simp]\nlemma app_unitForward {F : C·µí·µñ ‚•§ Type v} (Œ∑ : F ‚ü∂ A) (X : C·µí·µñ)\n    (p : YonedaCollection (restrictedYonedaObj Œ∑) X.unop) :\n    Œ∑.app X (unitForward Œ∑ X.unop p) = p.yonedaEquivFst := by\n  simpa [unitForward] using p.snd.app_val\n\n"}
{"name":"CategoryTheory.OverPresheafAux.unitForward_unitBackward","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nX : C\n‚ä¢ Eq (Function.comp (CategoryTheory.OverPresheafAux.unitForward Œ∑ X) (CategoryTheory.OverPresheafAux.unitBackward Œ∑ X)) id","decl":"lemma unitForward_unitBackward {F : C·µí·µñ ‚•§ Type v} (Œ∑ : F ‚ü∂ A) (X : C) :\n    unitForward Œ∑ X ‚àò unitBackward Œ∑ X = id :=\n  funext fun x => by simp [unitForward, unitBackward]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.unitBackward_unitForward","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nX : C\n‚ä¢ Eq (Function.comp (CategoryTheory.OverPresheafAux.unitBackward Œ∑ X) (CategoryTheory.OverPresheafAux.unitForward Œ∑ X)) id","decl":"lemma unitBackward_unitForward {F : C·µí·µñ ‚•§ Type v} (Œ∑ : F ‚ü∂ A) (X : C) :\n    unitBackward Œ∑ X ‚àò unitForward Œ∑ X = id := by\n  refine funext fun p => YonedaCollection.ext ?_ (OverArrows.ext ?_)\n  ¬∑ simpa [unitForward, unitBackward] using congrArg yonedaEquiv.symm p.snd.app_val\n  ¬∑ simp [unitForward, unitBackward]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.unitAuxAuxAux_hom","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nX : C\na‚úù : CategoryTheory.OverPresheafAux.YonedaCollection (CategoryTheory.OverPresheafAux.restrictedYonedaObj Œ∑) X\n‚ä¢ Eq ((CategoryTheory.OverPresheafAux.unitAuxAuxAux Œ∑ X).hom a‚úù) (CategoryTheory.OverPresheafAux.unitForward Œ∑ X a‚úù)","decl":"/-- Intermediate stage of assembling the unit. -/\n@[simps]\ndef unitAuxAuxAux {F : C·µí·µñ ‚•§ Type v} (Œ∑ : F ‚ü∂ A) (X : C) :\n    YonedaCollection (restrictedYonedaObj Œ∑) X ‚âÖ F.obj (op X) where\n  hom := unitForward Œ∑ X\n  inv := unitBackward Œ∑ X\n  hom_inv_id := unitBackward_unitForward Œ∑ X\n  inv_hom_id := unitForward_unitBackward Œ∑ X\n\n"}
{"name":"CategoryTheory.OverPresheafAux.unitAuxAuxAux_inv","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nX : C\na‚úù : F.obj { unop := X }\n‚ä¢ Eq ((CategoryTheory.OverPresheafAux.unitAuxAuxAux Œ∑ X).inv a‚úù) (CategoryTheory.OverPresheafAux.unitBackward Œ∑ X a‚úù)","decl":"/-- Intermediate stage of assembling the unit. -/\n@[simps]\ndef unitAuxAuxAux {F : C·µí·µñ ‚•§ Type v} (Œ∑ : F ‚ü∂ A) (X : C) :\n    YonedaCollection (restrictedYonedaObj Œ∑) X ‚âÖ F.obj (op X) where\n  hom := unitForward Œ∑ X\n  inv := unitBackward Œ∑ X\n  hom_inv_id := unitBackward_unitForward Œ∑ X\n  inv_hom_id := unitForward_unitBackward Œ∑ X\n\n"}
{"name":"CategoryTheory.OverPresheafAux.unitAuxAux_inv_app_snd_coe","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nX : Opposite C\na‚úù : F.obj X\n‚ä¢ Eq (‚Üë((CategoryTheory.OverPresheafAux.unitAuxAux Œ∑).inv.app X a‚úù).snd) (CategoryTheory.OverPresheafAux.OverArrows.val ‚ü®a‚úù, ‚ãØ‚ü©)","decl":"/-- Intermediate stage of assembling the unit. -/\n@[simps!]\ndef unitAuxAux {F : C·µí·µñ ‚•§ Type v} (Œ∑ : F ‚ü∂ A) :\n    yonedaCollectionPresheaf A (restrictedYonedaObj Œ∑) ‚âÖ F :=\n  NatIso.ofComponents (fun X => unitAuxAuxAux Œ∑ X.unop) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.OverPresheafAux.unitAuxAux_hom_app","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nX : Opposite C\na‚úù : (CategoryTheory.OverPresheafAux.yonedaCollectionPresheaf A (CategoryTheory.OverPresheafAux.restrictedYonedaObj Œ∑)).obj X\n‚ä¢ Eq ((CategoryTheory.OverPresheafAux.unitAuxAux Œ∑).hom.app X a‚úù) (CategoryTheory.OverPresheafAux.unitForward Œ∑ (Opposite.unop X) a‚úù)","decl":"/-- Intermediate stage of assembling the unit. -/\n@[simps!]\ndef unitAuxAux {F : C·µí·µñ ‚•§ Type v} (Œ∑ : F ‚ü∂ A) :\n    yonedaCollectionPresheaf A (restrictedYonedaObj Œ∑) ‚âÖ F :=\n  NatIso.ofComponents (fun X => unitAuxAuxAux Œ∑ X.unop) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.OverPresheafAux.unitAuxAux_inv_app_fst","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA F : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom F A\nX : Opposite C\na‚úù : F.obj X\n‚ä¢ Eq ((CategoryTheory.OverPresheafAux.unitAuxAux Œ∑).inv.app X a‚úù).fst (Œ∑.app X a‚úù)","decl":"/-- Intermediate stage of assembling the unit. -/\n@[simps!]\ndef unitAuxAux {F : C·µí·µñ ‚•§ Type v} (Œ∑ : F ‚ü∂ A) :\n    yonedaCollectionPresheaf A (restrictedYonedaObj Œ∑) ‚âÖ F :=\n  NatIso.ofComponents (fun X => unitAuxAuxAux Œ∑ X.unop) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.OverPresheafAux.unitAux_hom","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : CategoryTheory.Over A\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.unitAux Œ∑).hom { left := (CategoryTheory.OverPresheafAux.unitAuxAux Œ∑.hom).hom, right := CategoryTheory.CategoryStruct.id { as := PUnit.unit }, w := ‚ãØ }","decl":"/-- Intermediate stage of assembling the unit. -/\n@[simps! hom]\ndef unitAux (Œ∑ : Over A) : (restrictedYoneda A ‚ãô costructuredArrowPresheafToOver A).obj Œ∑ ‚âÖ Œ∑ :=\n  Over.isoMk (unitAuxAux Œ∑.hom) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.OverPresheafAux.OverArrows.yonedaCollectionPresheafToA_val_fst","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nX : C\ns : Quiver.Hom (CategoryTheory.yoneda.obj X) A\np : CategoryTheory.OverPresheafAux.OverArrows (CategoryTheory.OverPresheafAux.yonedaCollectionPresheafToA F) s\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.fst p.val) s","decl":"@[simp]\nlemma OverArrows.yonedaCollectionPresheafToA_val_fst (s : yoneda.obj X ‚ü∂ A)\n    (p : OverArrows (yonedaCollectionPresheafToA F) s) : p.val.fst = s := by\n  simpa [YonedaCollection.yonedaEquivFst_eq] using p.app_val\n\n"}
{"name":"CategoryTheory.OverPresheafAux.counitForward_val_fst","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\ns : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\nx : F.obj { unop := s }\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.fst (CategoryTheory.OverPresheafAux.counitForward F s x).val) s.hom","decl":"lemma counitForward_val_fst (s : CostructuredArrow yoneda A) (x : F.obj (op s)) :\n    (counitForward F s x).val.fst = s.hom := by\n  simp\n\n"}
{"name":"CategoryTheory.OverPresheafAux.counitForward_val_snd","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\ns : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\nx : F.obj { unop := s }\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.YonedaCollection.snd (CategoryTheory.OverPresheafAux.counitForward F s x).val) (F.map (CategoryTheory.eqToHom ‚ãØ) x)","decl":"@[simp]\nlemma counitForward_val_snd (s : CostructuredArrow yoneda A) (x : F.obj (op s)) :\n    (counitForward F s x).val.snd = F.map (eqToHom (by simp [‚Üê CostructuredArrow.eq_mk])) x :=\n  YonedaCollection.mk_snd _ _\n\n"}
{"name":"CategoryTheory.OverPresheafAux.counitForward_naturality‚ÇÅ","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF G : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\nŒ∑ : Quiver.Hom F G\ns : Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)\nx : F.obj s\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.counitForward G (Opposite.unop s) (Œ∑.app s x)) ((CategoryTheory.OverPresheafAux.counitForward F (Opposite.unop s) x).map‚ÇÅ (CategoryTheory.OverPresheafAux.yonedaCollectionPresheafMap‚ÇÅ Œ∑) ‚ãØ)","decl":"@[simp]\nlemma counitForward_naturality‚ÇÅ {G : (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v} (Œ∑ : F ‚ü∂ G)\n    (s : (CostructuredArrow yoneda A)·µí·µñ) (x : F.obj s) : counitForward G s.unop (Œ∑.app s x) =\n      OverArrows.map‚ÇÅ (counitForward F s.unop x) (yonedaCollectionPresheafMap‚ÇÅ Œ∑) (by aesop_cat) :=\n  OverArrows.ext <| YonedaCollection.ext (by simp) (by simp)\n\n"}
{"name":"CategoryTheory.OverPresheafAux.counitForward_naturality‚ÇÇ","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\ns t : Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)\nf : Quiver.Hom t s\nx : F.obj t\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.counitForward F (Opposite.unop s) (F.map f x)) ((CategoryTheory.OverPresheafAux.counitForward F (Opposite.unop t) x).map‚ÇÇ f.unop.left ‚ãØ)","decl":"@[simp]\nlemma counitForward_naturality‚ÇÇ (s t : (CostructuredArrow yoneda A)·µí·µñ) (f : t ‚ü∂ s) (x : F.obj t) :\n    counitForward F s.unop (F.map f x) =\n      OverArrows.map‚ÇÇ (counitForward F t.unop x) f.unop.left (by simp) := by\n  refine OverArrows.ext <| YonedaCollection.ext (by simp) ?_\n  have : (CostructuredArrow.mkPrecomp t.unop.hom f.unop.left).op =\n      f ‚â´ eqToHom (by simp [‚Üê CostructuredArrow.eq_mk]) := by\n    apply Quiver.Hom.unop_inj\n    simp\n  aesop_cat\n\n"}
{"name":"CategoryTheory.OverPresheafAux.counitForward_counitBackward","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\ns : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\n‚ä¢ Eq (Function.comp (CategoryTheory.OverPresheafAux.counitForward F s) (CategoryTheory.OverPresheafAux.counitBackward F s)) id","decl":"lemma counitForward_counitBackward (F : (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v)\n    (s : CostructuredArrow yoneda A) : counitForward F s ‚àò counitBackward F s = id :=\n  funext fun p => OverArrows.ext <| YonedaCollection.ext (by simp) (by simp [counitBackward])\n\n"}
{"name":"CategoryTheory.OverPresheafAux.counitBackward_counitForward","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\ns : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\n‚ä¢ Eq (Function.comp (CategoryTheory.OverPresheafAux.counitBackward F s) (CategoryTheory.OverPresheafAux.counitForward F s)) id","decl":"lemma counitBackward_counitForward (F : (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v)\n    (s : CostructuredArrow yoneda A) : counitBackward F s ‚àò counitForward F s = id :=\n  funext fun x => by simp [counitBackward]\n\n"}
{"name":"CategoryTheory.OverPresheafAux.counitAuxAux_inv","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\ns : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\na‚úù : CategoryTheory.OverPresheafAux.OverArrows (CategoryTheory.OverPresheafAux.yonedaCollectionPresheafToA F) s.hom\n‚ä¢ Eq ((CategoryTheory.OverPresheafAux.counitAuxAux F s).inv a‚úù) (CategoryTheory.OverPresheafAux.counitBackward F s a‚úù)","decl":"/-- Intermediate stage of assembling the counit. -/\n@[simps]\ndef counitAuxAux (F : (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v) (s : CostructuredArrow yoneda A) :\n    F.obj (op s) ‚âÖ OverArrows (yonedaCollectionPresheafToA F) s.hom where\n  hom := counitForward F s\n  inv := counitBackward F s\n  hom_inv_id := counitBackward_counitForward F s\n  inv_hom_id := counitForward_counitBackward F s\n\n"}
{"name":"CategoryTheory.OverPresheafAux.counitAuxAux_hom","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\ns : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\na‚úù : F.obj { unop := s }\n‚ä¢ Eq ((CategoryTheory.OverPresheafAux.counitAuxAux F s).hom a‚úù) (CategoryTheory.OverPresheafAux.counitForward F s a‚úù)","decl":"/-- Intermediate stage of assembling the counit. -/\n@[simps]\ndef counitAuxAux (F : (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v) (s : CostructuredArrow yoneda A) :\n    F.obj (op s) ‚âÖ OverArrows (yonedaCollectionPresheafToA F) s.hom where\n  hom := counitForward F s\n  inv := counitBackward F s\n  hom_inv_id := counitBackward_counitForward F s\n  inv_hom_id := counitForward_counitBackward F s\n\n"}
{"name":"CategoryTheory.OverPresheafAux.counitAux_hom","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nF : CategoryTheory.Functor (Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Type v)\n‚ä¢ Eq (CategoryTheory.OverPresheafAux.counitAux F).hom { app := fun X => (CategoryTheory.OverPresheafAux.counitAuxAux F (Opposite.unop X)).hom, naturality := ‚ãØ }","decl":"/-- Intermediate stage of assembling the counit. -/\n@[simps! hom]\ndef counitAux (F : (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v) :\n    F ‚âÖ restrictedYonedaObj (yonedaCollectionPresheafToA F) :=\n  NatIso.ofComponents (fun s => counitAuxAux F s.unop) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.overEquivPresheafCostructuredArrow_inverse_map_toOverCompYoneda","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nT : CategoryTheory.Over A\nX : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\nf : Quiver.Hom ((CategoryTheory.CostructuredArrow.toOver CategoryTheory.yoneda A).obj X) T\n‚ä¢ Eq ((CategoryTheory.overEquivPresheafCostructuredArrow A).inverse.map ((CategoryTheory.CostructuredArrow.toOverCompYoneda A T).hom.app { unop := X } f)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CostructuredArrow.toOverCompOverEquivPresheafCostructuredArrow A).isoCompInverse.inv.app X) (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.overEquivPresheafCostructuredArrow A).unit.app T)))","decl":"@[simp]\ntheorem CostructuredArrow.overEquivPresheafCostructuredArrow_inverse_map_toOverCompYoneda\n    {A : C·µí·µñ ‚•§ Type v} {T : Over A} {X : CostructuredArrow yoneda A}\n    (f : (CostructuredArrow.toOver yoneda A).obj X ‚ü∂ T) :\n    (overEquivPresheafCostructuredArrow A).inverse.map\n      (((CostructuredArrow.toOverCompYoneda A T).hom.app (op X) f)) =\n      (CostructuredArrow.toOverCompOverEquivPresheafCostructuredArrow A).isoCompInverse.inv.app X ‚â´\n        f ‚â´ (overEquivPresheafCostructuredArrow A).unit.app T := by\n  simp [CostructuredArrow.toOverCompYoneda]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.overEquivPresheafCostructuredArrow_functor_map_toOverCompYoneda","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nT : CategoryTheory.Over A\nX : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\nf : Quiver.Hom (CategoryTheory.yoneda.obj X) ((CategoryTheory.overEquivPresheafCostructuredArrow A).functor.obj T)\n‚ä¢ Eq ((CategoryTheory.overEquivPresheafCostructuredArrow A).functor.map ((CategoryTheory.CostructuredArrow.toOverCompYoneda A T).inv.app { unop := X } f)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CostructuredArrow.toOverCompOverEquivPresheafCostructuredArrow A).hom.app X) f)","decl":"@[simp]\ntheorem CostructuredArrow.overEquivPresheafCostructuredArrow_functor_map_toOverCompYoneda\n    {A : C·µí·µñ ‚•§ Type v} {T : Over A} {X : CostructuredArrow yoneda A}\n    (f : yoneda.obj X ‚ü∂ (overEquivPresheafCostructuredArrow A).functor.obj T) :\n    (overEquivPresheafCostructuredArrow A).functor.map\n      (((CostructuredArrow.toOverCompYoneda A T).inv.app (op X) f)) =\n      (CostructuredArrow.toOverCompOverEquivPresheafCostructuredArrow A).hom.app X ‚â´ f := by\n  simp [CostructuredArrow.toOverCompYoneda]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.overEquivPresheafCostructuredArrow_inverse_map_toOverCompCoyoneda","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nT : CategoryTheory.Over A\nX : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\nf : Quiver.Hom ((CategoryTheory.CostructuredArrow.toOver CategoryTheory.yoneda A).obj X) T\n‚ä¢ Eq ((CategoryTheory.overEquivPresheafCostructuredArrow A).inverse.map (((CategoryTheory.CostructuredArrow.toOverCompCoyoneda A).hom.app { unop := X }).app T f)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CostructuredArrow.toOverCompOverEquivPresheafCostructuredArrow A).isoCompInverse.inv.app X) (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.overEquivPresheafCostructuredArrow A).unit.app T)))","decl":"@[simp]\ntheorem CostructuredArrow.overEquivPresheafCostructuredArrow_inverse_map_toOverCompCoyoneda\n    {A : C·µí·µñ ‚•§ Type v} {T : Over A} {X : CostructuredArrow yoneda A}\n    (f : (CostructuredArrow.toOver yoneda A).obj X ‚ü∂ T) :\n    (overEquivPresheafCostructuredArrow A).inverse.map\n      (((CostructuredArrow.toOverCompCoyoneda A).hom.app (op X)).app T f) =\n      (CostructuredArrow.toOverCompOverEquivPresheafCostructuredArrow A).isoCompInverse.inv.app X ‚â´\n        f ‚â´ (overEquivPresheafCostructuredArrow A).unit.app T := by\n  simp [CostructuredArrow.toOverCompCoyoneda]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.overEquivPresheafCostructuredArrow_functor_map_toOverCompCoyoneda","module":"Mathlib.CategoryTheory.Comma.Presheaf.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nT : CategoryTheory.Over A\nX : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\nf : Quiver.Hom (CategoryTheory.yoneda.obj X) ((CategoryTheory.overEquivPresheafCostructuredArrow A).functor.obj T)\n‚ä¢ Eq ((CategoryTheory.overEquivPresheafCostructuredArrow A).functor.map (((CategoryTheory.CostructuredArrow.toOverCompCoyoneda A).inv.app { unop := X }).app T f)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CostructuredArrow.toOverCompOverEquivPresheafCostructuredArrow A).hom.app X) f)","decl":"@[simp]\ntheorem CostructuredArrow.overEquivPresheafCostructuredArrow_functor_map_toOverCompCoyoneda\n    {A : C·µí·µñ ‚•§ Type v} {T : Over A} {X : CostructuredArrow yoneda A}\n    (f : yoneda.obj X ‚ü∂ (overEquivPresheafCostructuredArrow A).functor.obj T) :\n    (overEquivPresheafCostructuredArrow A).functor.map\n      (((CostructuredArrow.toOverCompCoyoneda A).inv.app (op X)).app T f) =\n      (CostructuredArrow.toOverCompOverEquivPresheafCostructuredArrow A).hom.app X ‚â´ f := by\n  simp [CostructuredArrow.toOverCompCoyoneda]\n\n"}
