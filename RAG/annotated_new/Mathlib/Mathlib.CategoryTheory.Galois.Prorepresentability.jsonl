{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\ninst✝¹ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝ : SizeOf C\nobj : C\npt : ↑(F.obj obj)\nisGalois : autoParam (CategoryTheory.PreGaloisCategory.IsGalois obj) _auto✝\n⊢ Eq (SizeOf.sizeOf { obj := obj, pt := pt, isGalois := isGalois }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf obj)) (SizeOf.sizeOf pt)) (SizeOf.sizeOf isGalois))","decl":"/-- A pointed Galois object is a Galois object with a fixed point of its fiber. -/\nstructure PointedGaloisObject (F : C ⥤ FintypeCat.{w}) : Type (max u₁ u₂ w) where\n  /-- The underlying object of `C`. -/\n  obj : C\n  /-- An element of the fiber of `obj`. -/\n  pt : F.obj obj\n  /-- `obj` is Galois. -/\n  isGalois : IsGalois obj := by infer_instance\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.isGalois","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nself : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\n⊢ CategoryTheory.PreGaloisCategory.IsGalois self.obj","decl":"/-- A pointed Galois object is a Galois object with a fixed point of its fiber. -/\nstructure PointedGaloisObject (F : C ⥤ FintypeCat.{w}) : Type (max u₁ u₂ w) where\n  /-- The underlying object of `C`. -/\n  obj : C\n  /-- An element of the fiber of `obj`. -/\n  pt : F.obj obj\n  /-- `obj` is Galois. -/\n  isGalois : IsGalois obj := by infer_instance\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.mk.injEq","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nobj✝ : C\npt✝ : ↑(F.obj obj✝)\nisGalois✝ : autoParam (CategoryTheory.PreGaloisCategory.IsGalois obj✝) _auto✝\nobj : C\npt : ↑(F.obj obj)\nisGalois : autoParam (CategoryTheory.PreGaloisCategory.IsGalois obj) _auto✝\n⊢ Eq (Eq { obj := obj✝, pt := pt✝, isGalois := isGalois✝ } { obj := obj, pt := pt, isGalois := isGalois }) (And (Eq obj✝ obj) (HEq pt✝ pt))","decl":"/-- A pointed Galois object is a Galois object with a fixed point of its fiber. -/\nstructure PointedGaloisObject (F : C ⥤ FintypeCat.{w}) : Type (max u₁ u₂ w) where\n  /-- The underlying object of `C`. -/\n  obj : C\n  /-- An element of the fiber of `obj`. -/\n  pt : F.obj obj\n  /-- `obj` is Galois. -/\n  isGalois : IsGalois obj := by infer_instance\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.mk.inj","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nobj✝ : C\npt✝ : ↑(F.obj obj✝)\nisGalois✝ : autoParam (CategoryTheory.PreGaloisCategory.IsGalois obj✝) _auto✝\nobj : C\npt : ↑(F.obj obj)\nisGalois : autoParam (CategoryTheory.PreGaloisCategory.IsGalois obj) _auto✝\nx✝ : Eq { obj := obj✝, pt := pt✝, isGalois := isGalois✝ } { obj := obj, pt := pt, isGalois := isGalois }\n⊢ And (Eq obj✝ obj) (HEq pt✝ pt)","decl":"/-- A pointed Galois object is a Galois object with a fixed point of its fiber. -/\nstructure PointedGaloisObject (F : C ⥤ FintypeCat.{w}) : Type (max u₁ u₂ w) where\n  /-- The underlying object of `C`. -/\n  obj : C\n  /-- An element of the fiber of `obj`. -/\n  pt : F.obj obj\n  /-- `obj` is Galois. -/\n  isGalois : IsGalois obj := by infer_instance\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nval✝ : Quiver.Hom A.obj B.obj\ncomp✝ : autoParam (Eq (F.map val✝ A.pt) B.pt) _auto✝\nval : Quiver.Hom A.obj B.obj\ncomp : autoParam (Eq (F.map val A.pt) B.pt) _auto✝\n⊢ Eq (Eq { val := val✝, comp := comp✝ } { val := val, comp := comp }) (Eq val✝ val)","decl":"variable {F} in\n/-- The type of homomorphisms between two pointed Galois objects. This is a homomorphism\nof the underlying objects of `C` that maps the distinguished points to each other. -/\n@[ext]\nstructure Hom (A B : PointedGaloisObject F) where\n  /-- The underlying homomorphism of `C`. -/\n  val : A.obj ⟶ B.obj\n  /-- The distinguished point of `A` is mapped to the distinguished point of `B`. -/\n  comp : F.map val A.pt = B.pt := by simp\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.Hom.mk.inj","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nval✝ : Quiver.Hom A.obj B.obj\ncomp✝ : autoParam (Eq (F.map val✝ A.pt) B.pt) _auto✝\nval : Quiver.Hom A.obj B.obj\ncomp : autoParam (Eq (F.map val A.pt) B.pt) _auto✝\nx✝ : Eq { val := val✝, comp := comp✝ } { val := val, comp := comp }\n⊢ Eq val✝ val","decl":"variable {F} in\n/-- The type of homomorphisms between two pointed Galois objects. This is a homomorphism\nof the underlying objects of `C` that maps the distinguished points to each other. -/\n@[ext]\nstructure Hom (A B : PointedGaloisObject F) where\n  /-- The underlying homomorphism of `C`. -/\n  val : A.obj ⟶ B.obj\n  /-- The distinguished point of `A` is mapped to the distinguished point of `B`. -/\n  comp : F.map val A.pt = B.pt := by simp\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.Hom.ext_iff","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nx y : A.Hom B\n⊢ Iff (Eq x y) (Eq x.val y.val)","decl":"variable {F} in\n/-- The type of homomorphisms between two pointed Galois objects. This is a homomorphism\nof the underlying objects of `C` that maps the distinguished points to each other. -/\n@[ext]\nstructure Hom (A B : PointedGaloisObject F) where\n  /-- The underlying homomorphism of `C`. -/\n  val : A.obj ⟶ B.obj\n  /-- The distinguished point of `A` is mapped to the distinguished point of `B`. -/\n  comp : F.map val A.pt = B.pt := by simp\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\ninst✝¹ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\ninst✝ : SizeOf C\nval : Quiver.Hom A.obj B.obj\ncomp : autoParam (Eq (F.map val A.pt) B.pt) _auto✝\n⊢ Eq (SizeOf.sizeOf { val := val, comp := comp }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf val)) (SizeOf.sizeOf comp))","decl":"variable {F} in\n/-- The type of homomorphisms between two pointed Galois objects. This is a homomorphism\nof the underlying objects of `C` that maps the distinguished points to each other. -/\n@[ext]\nstructure Hom (A B : PointedGaloisObject F) where\n  /-- The underlying homomorphism of `C`. -/\n  val : A.obj ⟶ B.obj\n  /-- The distinguished point of `A` is mapped to the distinguished point of `B`. -/\n  comp : F.map val A.pt = B.pt := by simp\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.Hom.comp","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nself : A.Hom B\n⊢ Eq (F.map self.val A.pt) B.pt","decl":"variable {F} in\n/-- The type of homomorphisms between two pointed Galois objects. This is a homomorphism\nof the underlying objects of `C` that maps the distinguished points to each other. -/\n@[ext]\nstructure Hom (A B : PointedGaloisObject F) where\n  /-- The underlying homomorphism of `C`. -/\n  val : A.obj ⟶ B.obj\n  /-- The distinguished point of `A` is mapped to the distinguished point of `B`. -/\n  comp : F.map val A.pt = B.pt := by simp\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.Hom.ext","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nx y : A.Hom B\nval : Eq x.val y.val\n⊢ Eq x y","decl":"variable {F} in\n/-- The type of homomorphisms between two pointed Galois objects. This is a homomorphism\nof the underlying objects of `C` that maps the distinguished points to each other. -/\n@[ext]\nstructure Hom (A B : PointedGaloisObject F) where\n  /-- The underlying homomorphism of `C`. -/\n  val : A.obj ⟶ B.obj\n  /-- The distinguished point of `A` is mapped to the distinguished point of `B`. -/\n  comp : F.map val A.pt = B.pt := by simp\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.hom_ext_iff","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nf g : Quiver.Hom A B\n⊢ Iff (Eq f g) (Eq f.val g.val)","decl":"@[ext]\nlemma hom_ext {A B : PointedGaloisObject F} {f g : A ⟶ B} (h : f.val = g.val) : f = g :=\n  Hom.ext h\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.hom_ext","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nf g : Quiver.Hom A B\nh : Eq f.val g.val\n⊢ Eq f g","decl":"@[ext]\nlemma hom_ext {A B : PointedGaloisObject F} {f g : A ⟶ B} (h : f.val = g.val) : f = g :=\n  Hom.ext h\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.id_val","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\n⊢ Eq (CategoryTheory.CategoryStruct.id A).val (CategoryTheory.CategoryStruct.id A.obj)","decl":"@[simp]\nlemma id_val (A : PointedGaloisObject F) : 𝟙 A = 𝟙 A.obj :=\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.comp_val","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C✝ : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C✝\ninst✝ : CategoryTheory.GaloisCategory C✝\nF : CategoryTheory.Functor C✝ FintypeCat\nA B C : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nf : Quiver.Hom A B\ng : Quiver.Hom B C\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).val (CategoryTheory.CategoryStruct.comp f.val g.val)","decl":"@[simp, reassoc]\nlemma comp_val {A B C : PointedGaloisObject F} (f : A ⟶ B) (g : B ⟶ C) :\n    (f ≫ g).val = f.val ≫ g.val :=\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.comp_val_assoc","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C✝ : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C✝\ninst✝ : CategoryTheory.GaloisCategory C✝\nF : CategoryTheory.Functor C✝ FintypeCat\nA B C : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nf : Quiver.Hom A B\ng : Quiver.Hom B C\nZ : C✝\nh : Quiver.Hom C.obj Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).val h) (CategoryTheory.CategoryStruct.comp f.val (CategoryTheory.CategoryStruct.comp g.val h))","decl":"@[simp, reassoc]\nlemma comp_val {A B C : PointedGaloisObject F} (f : A ⟶ B) (g : B ⟶ C) :\n    (f ≫ g).val = f.val ≫ g.val :=\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.incl_obj","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\n⊢ Eq ((CategoryTheory.PreGaloisCategory.PointedGaloisObject.incl F).obj A) A.obj","decl":"@[simp]\nlemma incl_obj (A : PointedGaloisObject F) : (incl F).obj A = A :=\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.incl_map","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nf : Quiver.Hom A B\n⊢ Eq ((CategoryTheory.PreGaloisCategory.PointedGaloisObject.incl F).map f) f.val","decl":"@[simp]\nlemma incl_map {A B : PointedGaloisObject F} (f : A ⟶ B) : (incl F).map f = f.val :=\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.cocone_app","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nB : C\nf : Quiver.Hom A.obj B\n⊢ Eq (((CategoryTheory.PreGaloisCategory.PointedGaloisObject.cocone F).ι.app { unop := A }).app B f) (F.map f A.pt)","decl":"@[simp]\nlemma cocone_app (A : PointedGaloisObject F) (B : C) (f : (A : C) ⟶ B) :\n    ((cocone F).ι.app ⟨A⟩).app B f = F.map f A.pt :=\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.instIsCofilteredOrEmpty","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\n⊢ CategoryTheory.IsCofilteredOrEmpty (CategoryTheory.PreGaloisCategory.PointedGaloisObject F)","decl":"/-- The category of pointed Galois objects is cofiltered. -/\ninstance : IsCofilteredOrEmpty (PointedGaloisObject F) where\n  cone_objs := fun ⟨A, a, _⟩ ⟨B, b, _⟩ ↦ by\n    obtain ⟨Z, f, z, hgal, hfz⟩ := exists_hom_from_galois_of_fiber F (A ⨯ B)\n      <| (fiberBinaryProductEquiv F A B).symm (a, b)\n    refine ⟨⟨Z, z, hgal⟩, ⟨f ≫ prod.fst, ?_⟩, ⟨f ≫ prod.snd, ?_⟩, trivial⟩\n    · simp only [F.map_comp, hfz, FintypeCat.comp_apply, fiberBinaryProductEquiv_symm_fst_apply]\n    · simp only [F.map_comp, hfz, FintypeCat.comp_apply, fiberBinaryProductEquiv_symm_snd_apply]\n  cone_maps := fun ⟨A, a, _⟩ ⟨B, b, _⟩ ⟨f, hf⟩ ⟨g, hg⟩ ↦ by\n    obtain ⟨Z, h, z, hgal, hhz⟩ := exists_hom_from_galois_of_fiber F A a\n    refine ⟨⟨Z, z, hgal⟩, ⟨h, hhz⟩, hom_ext ?_⟩\n    apply evaluation_injective_of_isConnected F Z B z\n    simp [hhz, hf, hg]\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.instHasColimitOppositeFunctorTypeCompOpInclCoyoneda","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\ninst✝¹ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\n⊢ CategoryTheory.Limits.HasColimit ((CategoryTheory.PreGaloisCategory.PointedGaloisObject.incl F).op.comp CategoryTheory.coyoneda)","decl":"instance : HasColimit ((incl F).op ⋙ coyoneda) where\n  exists_colimit := ⟨cocone F, isColimit F⟩\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autGaloisSystem_obj_coe","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\n⊢ Eq (↑((CategoryTheory.PreGaloisCategory.autGaloisSystem F).obj A)) (CategoryTheory.Aut A.obj)","decl":"/-- The diagram sending each pointed Galois object to its automorphism group\nas an object of `C`. -/\n@[simps]\nnoncomputable def autGaloisSystem : PointedGaloisObject F ⥤ Grp.{u₂} where\n  obj := fun A ↦ Grp.of <| Aut (A : C)\n  map := fun {A B} f ↦ Grp.ofHom (autMapHom f)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autGaloisSystem_map","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nf : Quiver.Hom A B\n⊢ Eq ((CategoryTheory.PreGaloisCategory.autGaloisSystem F).map f) (Grp.ofHom (CategoryTheory.PreGaloisCategory.autMapHom f.val))","decl":"/-- The diagram sending each pointed Galois object to its automorphism group\nas an object of `C`. -/\n@[simps]\nnoncomputable def autGaloisSystem : PointedGaloisObject F ⥤ Grp.{u₂} where\n  obj := fun A ↦ Grp.of <| Aut (A : C)\n  map := fun {A B} f ↦ Grp.ofHom (autMapHom f)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.AutGalois.π_apply","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nx : CategoryTheory.PreGaloisCategory.AutGalois F\n⊢ Eq ((CategoryTheory.PreGaloisCategory.AutGalois.π F A) x) (↑x A)","decl":"lemma AutGalois.π_apply (A : PointedGaloisObject F) (x : AutGalois F) :\n    AutGalois.π F A x = x.val A :=\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autGaloisSystem_map_surjective","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nf : Quiver.Hom A B\n⊢ Function.Surjective ⇑(CategoryTheory.ConcreteCategory.hom ((CategoryTheory.PreGaloisCategory.autGaloisSystem F).map f))","decl":"lemma autGaloisSystem_map_surjective ⦃A B : PointedGaloisObject F⦄ (f : A ⟶ B) :\n    Function.Surjective ((autGaloisSystem F).map f) := by\n  intro (φ : Aut B.obj)\n  obtain ⟨ψ, hψ⟩ := autMap_surjective_of_isGalois f.val φ\n  use ψ\n  simp only [autGaloisSystem_map]\n  exact hψ\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.AutGalois.ext","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nf g : CategoryTheory.PreGaloisCategory.AutGalois F\nh : ∀ (A : CategoryTheory.PreGaloisCategory.PointedGaloisObject F), Eq ((CategoryTheory.PreGaloisCategory.AutGalois.π F A) f) ((CategoryTheory.PreGaloisCategory.AutGalois.π F A) g)\n⊢ Eq f g","decl":"/-- Equality of elements of `AutGalois F` can be checked on the projections on each pointed\nGalois object. -/\nlemma AutGalois.ext {f g : AutGalois F}\n    (h : ∀ (A : PointedGaloisObject F), AutGalois.π F A f = AutGalois.π F A g) : f = g := by\n  dsimp only [AutGalois]\n  ext A\n  exact h A\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.AutGalois.π_surjective","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\ninst✝¹ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nA : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\n⊢ Function.Surjective ⇑(CategoryTheory.PreGaloisCategory.AutGalois.π F A)","decl":"/-- `autGalois.π` is surjective for every pointed Galois object. -/\ntheorem AutGalois.π_surjective (A : PointedGaloisObject F) :\n    Function.Surjective (AutGalois.π F A) := fun (σ : Aut A.obj) ↦ by\n  have (i : PointedGaloisObject F) : Finite ((autGaloisSystem F ⋙ forget _).obj i) :=\n    inferInstanceAs <| Finite (Aut (i.obj))\n  exact eval_section_surjective_of_surjective\n    (autGaloisSystem F ⋙ forget _) (autGaloisSystem_map_surjective F) A σ\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.endEquivSectionsFibers_π","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\ninst✝¹ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nf : CategoryTheory.End F\nA : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\n⊢ Eq (↑((CategoryTheory.PreGaloisCategory.endEquivSectionsFibers F) f) A) (f.app A.obj A.pt)","decl":"@[simp]\nlemma endEquivSectionsFibers_π (f : End F) (A : PointedGaloisObject F) :\n    (endEquivSectionsFibers F f).val A = f.app A A.pt := by\n  dsimp [endEquivSectionsFibers, Types.sectionsEquiv]\n  erw [Types.limitEquivSections_apply]\n  simp only [colimitCoyonedaHomIsoLimit'_π_apply, incl_obj, comp_obj, FintypeCat.incl_obj, op_obj,\n    FunctorToTypes.comp]\n  change (((FullyFaithful.whiskeringRight (FullyFaithful.ofFullyFaithful\n      FintypeCat.incl) C).homEquiv) f).app A\n    (((colimit.ι _ _) ≫ (colimit.isoColimitCocone ⟨cocone F, isColimit F⟩).hom).app\n      A _) = f.app A A.pt\n  simp\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autIsoFibers_inv_app","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\ninst✝¹ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nA : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nb : ↑(F.obj A.obj)\n⊢ Eq ((CategoryTheory.PreGaloisCategory.autIsoFibers F).inv.app A b) ((CategoryTheory.PreGaloisCategory.evaluationEquivOfIsGalois F A.obj A.pt).symm b)","decl":"lemma autIsoFibers_inv_app (A : PointedGaloisObject F) (b : F.obj A) :\n    (autIsoFibers F).inv.app A b = (evaluationEquivOfIsGalois F A A.pt).symm b :=\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.endEquivAutGalois_π","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\ninst✝¹ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nf : CategoryTheory.End F\nA : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\n⊢ Eq (F.map ((CategoryTheory.PreGaloisCategory.AutGalois.π F A) ((CategoryTheory.PreGaloisCategory.endEquivAutGalois F) f)).hom A.pt) (f.app A.obj A.pt)","decl":"lemma endEquivAutGalois_π (f : End F) (A : PointedGaloisObject F) :\n    F.map (AutGalois.π F A (endEquivAutGalois F f)).hom A.pt = f.app A A.pt := by\n  dsimp [endEquivAutGalois, AutGalois.π_apply]\n  change F.map ((((sectionsFunctor _).map (autIsoFibers F).inv) _).val A).hom A.pt = _\n  dsimp [autIsoFibers]\n  simp only [endEquivSectionsFibers_π]\n  erw [evaluationEquivOfIsGalois_symm_fiber]\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.endEquivAutGalois_mul","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\ninst✝¹ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nf g : CategoryTheory.End F\n⊢ Eq ((CategoryTheory.PreGaloisCategory.endEquivAutGalois F) (CategoryTheory.CategoryStruct.comp g f)) (HMul.hMul ((CategoryTheory.PreGaloisCategory.endEquivAutGalois F) g) ((CategoryTheory.PreGaloisCategory.endEquivAutGalois F) f))","decl":"@[simp]\ntheorem endEquivAutGalois_mul (f g : End F) :\n    (endEquivAutGalois F) (g ≫ f) = (endEquivAutGalois F g) * (endEquivAutGalois F f) := by\n  refine AutGalois.ext F (fun A ↦ evaluation_aut_injective_of_isConnected F A A.pt ?_)\n  simp only [map_mul, endEquivAutGalois_π, Aut.Aut_mul_def, NatTrans.comp_app, Iso.trans_hom]\n  simp only [map_comp, FintypeCat.comp_apply, endEquivAutGalois_π]\n  change f.app A (g.app A A.pt) =\n    (f.app A ≫ F.map ((AutGalois.π F A) ((endEquivAutGalois F) g)).hom) A.pt\n  rw [← f.naturality, FintypeCat.comp_apply, endEquivAutGalois_π]\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.endMulEquivAutGalois_pi","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\ninst✝¹ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nf : CategoryTheory.End F\nA : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\n⊢ Eq (F.map ((CategoryTheory.PreGaloisCategory.AutGalois.π F A) (MulOpposite.unop ((CategoryTheory.PreGaloisCategory.endMulEquivAutGalois F) f))).hom A.pt) (f.app A.obj A.pt)","decl":"lemma endMulEquivAutGalois_pi (f : End F) (A : PointedGaloisObject F) :\n    F.map (AutGalois.π F A (endMulEquivAutGalois F f).unop).hom A.2 = f.app A A.pt :=\n  endEquivAutGalois_π F f A\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.FibreFunctor.end_isUnit","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\ninst✝¹ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nf : CategoryTheory.End F\n⊢ IsUnit f","decl":"/-- Any endomorphism of a fiber functor is a unit. -/\ntheorem FibreFunctor.end_isUnit (f : End F) : IsUnit f :=\n  (isUnit_map_iff (endMulEquivAutGalois F) _).mp\n    (Group.isUnit ((endMulEquivAutGalois F) f))\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.FibreFunctor.end_isIso","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\nf : CategoryTheory.End F\n⊢ CategoryTheory.IsIso f","decl":"/-- Any endomorphism of a fiber functor is an isomorphism. -/\ninstance FibreFunctor.end_isIso (f : End F) : IsIso f := by\n  rw [← isUnit_iff_isIso]\n  exact FibreFunctor.end_isUnit F f\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autMulEquivAutGalois_π","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\ninst✝² : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nf : CategoryTheory.Aut F\nA : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsGalois A\na : ↑(F.obj A)\n⊢ Eq (F.map ((CategoryTheory.PreGaloisCategory.AutGalois.π F { obj := A, pt := a, isGalois := ⋯ }) (MulOpposite.unop ((CategoryTheory.PreGaloisCategory.autMulEquivAutGalois F) f))).hom a) (f.hom.app A a)","decl":"lemma autMulEquivAutGalois_π (f : Aut F) (A : C) [IsGalois A] (a : F.obj A) :\n    F.map (AutGalois.π F { obj := A, pt := a } (autMulEquivAutGalois F f).unop).hom a =\n      f.hom.app A a := by\n  dsimp [autMulEquivAutGalois, endMulEquivAutGalois]\n  rw [endEquivAutGalois_π]\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autMulEquivAutGalois_symm_app","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\ninst✝² : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nx : CategoryTheory.PreGaloisCategory.AutGalois F\nA : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsGalois A\na : ↑(F.obj A)\n⊢ Eq (((CategoryTheory.PreGaloisCategory.autMulEquivAutGalois F).symm { unop' := x }).hom.app A a) (F.map ((CategoryTheory.PreGaloisCategory.AutGalois.π F { obj := A, pt := a, isGalois := ⋯ }) x).hom a)","decl":"@[simp]\nlemma autMulEquivAutGalois_symm_app (x : AutGalois F) (A : C) [IsGalois A] (a : F.obj A) :\n    ((autMulEquivAutGalois F).symm ⟨x⟩).hom.app A a =\n      F.map (AutGalois.π F ⟨A, a, inferInstance⟩ x).hom a := by\n  rw [← autMulEquivAutGalois_π, MulEquiv.apply_symm_apply]\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.FiberFunctor.isPretransitive_of_isGalois","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\ninst✝² : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsGalois X\n⊢ MulAction.IsPretransitive (CategoryTheory.Aut F) ↑(F.obj X)","decl":"/-- The `Aut F` action on the fiber of a Galois object is transitive. See\n`pretransitive_of_isConnected` for the same result for connected objects. -/\ntheorem FiberFunctor.isPretransitive_of_isGalois (X : C) [IsGalois X] :\n    MulAction.IsPretransitive (Aut F) (F.obj X) := by\n  refine ⟨fun x y ↦ ?_⟩\n  obtain ⟨(φ : Aut X), h⟩ := MulAction.IsPretransitive.exists_smul_eq (M := Aut X) x y\n  obtain ⟨a, ha⟩ := AutGalois.π_surjective F ⟨X, x, inferInstance⟩ φ\n  use (autMulEquivAutGalois F).symm ⟨a⟩\n  simpa [mulAction_def, ha]\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.FiberFunctor.isPretransitive_of_isConnected","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\nX : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsConnected X\n⊢ MulAction.IsPretransitive (CategoryTheory.Aut F) ↑(F.obj X)","decl":"/-- The `Aut F` action on the fiber of a connected object is transitive. -/\ninstance FiberFunctor.isPretransitive_of_isConnected (X : C) [IsConnected X] :\n    MulAction.IsPretransitive (Aut F) (F.obj X) where\n  exists_smul_eq x y := by\n    let F' : C ⥤ FintypeCat.{u₂} := F ⋙ FintypeCat.uSwitch.{w, u₂}\n    letI : FiberFunctor F' := FiberFunctor.comp_right _\n    let e (Y : C) : F'.obj Y ≃ F.obj Y := (F.obj Y).uSwitchEquiv\n    set x' : F'.obj X := (e X).symm x with hx'\n    set y' : F'.obj X := (e X).symm y with hy'\n    obtain ⟨g', (hg' : g'.hom.app X x' = y')⟩ := MulAction.exists_smul_eq (Aut F') x' y'\n    let gapp (Y : C) : F.obj Y ≅ F.obj Y := FintypeCat.equivEquivIso <|\n      (e Y).symm.trans <| (FintypeCat.equivEquivIso.symm (g'.app Y)).trans (e Y)\n    let g : F ≅ F := NatIso.ofComponents gapp <| fun {X Y} f ↦ by\n      ext x\n      simp only [FintypeCat.comp_apply, FintypeCat.equivEquivIso_apply_hom,\n        Equiv.trans_apply, FintypeCat.equivEquivIso_symm_apply_apply, Iso.app_hom, gapp, e]\n      erw [FintypeCat.uSwitchEquiv_naturality (F.map f)]\n      rw [← Functor.comp_map, ← FunctorToFintypeCat.naturality]\n      simp only [comp_obj, Functor.comp_map, F']\n      rw [FintypeCat.uSwitchEquiv_symm_naturality (F.map f)]\n    refine ⟨g, show (gapp X).hom x = y from ?_⟩\n    simp only [FintypeCat.equivEquivIso_apply_hom, Equiv.trans_apply,\n      FintypeCat.equivEquivIso_symm_apply_apply, Iso.app_hom, gapp]\n    rw [← hx', hg', hy', Equiv.apply_symm_apply]\n\n"}
