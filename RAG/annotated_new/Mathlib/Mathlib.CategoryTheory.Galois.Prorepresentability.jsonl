{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst‚úù : SizeOf C\nobj : C\npt : ‚Üë(F.obj obj)\nisGalois : autoParam (CategoryTheory.PreGaloisCategory.IsGalois obj) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { obj := obj, pt := pt, isGalois := isGalois }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf obj)) (SizeOf.sizeOf pt)) (SizeOf.sizeOf isGalois))","decl":"/-- A pointed Galois object is a Galois object with a fixed point of its fiber. -/\nstructure PointedGaloisObject (F : C ‚•§ FintypeCat.{w}) : Type (max u‚ÇÅ u‚ÇÇ w) where\n  /-- The underlying object of `C`. -/\n  obj : C\n  /-- An element of the fiber of `obj`. -/\n  pt : F.obj obj\n  /-- `obj` is Galois. -/\n  isGalois : IsGalois obj := by infer_instance\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.isGalois","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nself : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\n‚ä¢ CategoryTheory.PreGaloisCategory.IsGalois self.obj","decl":"/-- A pointed Galois object is a Galois object with a fixed point of its fiber. -/\nstructure PointedGaloisObject (F : C ‚•§ FintypeCat.{w}) : Type (max u‚ÇÅ u‚ÇÇ w) where\n  /-- The underlying object of `C`. -/\n  obj : C\n  /-- An element of the fiber of `obj`. -/\n  pt : F.obj obj\n  /-- `obj` is Galois. -/\n  isGalois : IsGalois obj := by infer_instance\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.mk.injEq","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nobj‚úù : C\npt‚úù : ‚Üë(F.obj obj‚úù)\nisGalois‚úù : autoParam (CategoryTheory.PreGaloisCategory.IsGalois obj‚úù) _auto‚úù\nobj : C\npt : ‚Üë(F.obj obj)\nisGalois : autoParam (CategoryTheory.PreGaloisCategory.IsGalois obj) _auto‚úù\n‚ä¢ Eq (Eq { obj := obj‚úù, pt := pt‚úù, isGalois := isGalois‚úù } { obj := obj, pt := pt, isGalois := isGalois }) (And (Eq obj‚úù obj) (HEq pt‚úù pt))","decl":"/-- A pointed Galois object is a Galois object with a fixed point of its fiber. -/\nstructure PointedGaloisObject (F : C ‚•§ FintypeCat.{w}) : Type (max u‚ÇÅ u‚ÇÇ w) where\n  /-- The underlying object of `C`. -/\n  obj : C\n  /-- An element of the fiber of `obj`. -/\n  pt : F.obj obj\n  /-- `obj` is Galois. -/\n  isGalois : IsGalois obj := by infer_instance\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.mk.inj","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nobj‚úù : C\npt‚úù : ‚Üë(F.obj obj‚úù)\nisGalois‚úù : autoParam (CategoryTheory.PreGaloisCategory.IsGalois obj‚úù) _auto‚úù\nobj : C\npt : ‚Üë(F.obj obj)\nisGalois : autoParam (CategoryTheory.PreGaloisCategory.IsGalois obj) _auto‚úù\nx‚úù : Eq { obj := obj‚úù, pt := pt‚úù, isGalois := isGalois‚úù } { obj := obj, pt := pt, isGalois := isGalois }\n‚ä¢ And (Eq obj‚úù obj) (HEq pt‚úù pt)","decl":"/-- A pointed Galois object is a Galois object with a fixed point of its fiber. -/\nstructure PointedGaloisObject (F : C ‚•§ FintypeCat.{w}) : Type (max u‚ÇÅ u‚ÇÇ w) where\n  /-- The underlying object of `C`. -/\n  obj : C\n  /-- An element of the fiber of `obj`. -/\n  pt : F.obj obj\n  /-- `obj` is Galois. -/\n  isGalois : IsGalois obj := by infer_instance\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nval‚úù : Quiver.Hom A.obj B.obj\ncomp‚úù : autoParam (Eq (F.map val‚úù A.pt) B.pt) _auto‚úù\nval : Quiver.Hom A.obj B.obj\ncomp : autoParam (Eq (F.map val A.pt) B.pt) _auto‚úù\n‚ä¢ Eq (Eq { val := val‚úù, comp := comp‚úù } { val := val, comp := comp }) (Eq val‚úù val)","decl":"variable {F} in\n/-- The type of homomorphisms between two pointed Galois objects. This is a homomorphism\nof the underlying objects of `C` that maps the distinguished points to each other. -/\n@[ext]\nstructure Hom (A B : PointedGaloisObject F) where\n  /-- The underlying homomorphism of `C`. -/\n  val : A.obj ‚ü∂ B.obj\n  /-- The distinguished point of `A` is mapped to the distinguished point of `B`. -/\n  comp : F.map val A.pt = B.pt := by simp\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.Hom.mk.inj","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nval‚úù : Quiver.Hom A.obj B.obj\ncomp‚úù : autoParam (Eq (F.map val‚úù A.pt) B.pt) _auto‚úù\nval : Quiver.Hom A.obj B.obj\ncomp : autoParam (Eq (F.map val A.pt) B.pt) _auto‚úù\nx‚úù : Eq { val := val‚úù, comp := comp‚úù } { val := val, comp := comp }\n‚ä¢ Eq val‚úù val","decl":"variable {F} in\n/-- The type of homomorphisms between two pointed Galois objects. This is a homomorphism\nof the underlying objects of `C` that maps the distinguished points to each other. -/\n@[ext]\nstructure Hom (A B : PointedGaloisObject F) where\n  /-- The underlying homomorphism of `C`. -/\n  val : A.obj ‚ü∂ B.obj\n  /-- The distinguished point of `A` is mapped to the distinguished point of `B`. -/\n  comp : F.map val A.pt = B.pt := by simp\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.Hom.ext_iff","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nx y : A.Hom B\n‚ä¢ Iff (Eq x y) (Eq x.val y.val)","decl":"variable {F} in\n/-- The type of homomorphisms between two pointed Galois objects. This is a homomorphism\nof the underlying objects of `C` that maps the distinguished points to each other. -/\n@[ext]\nstructure Hom (A B : PointedGaloisObject F) where\n  /-- The underlying homomorphism of `C`. -/\n  val : A.obj ‚ü∂ B.obj\n  /-- The distinguished point of `A` is mapped to the distinguished point of `B`. -/\n  comp : F.map val A.pt = B.pt := by simp\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\ninst‚úù : SizeOf C\nval : Quiver.Hom A.obj B.obj\ncomp : autoParam (Eq (F.map val A.pt) B.pt) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { val := val, comp := comp }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf val)) (SizeOf.sizeOf comp))","decl":"variable {F} in\n/-- The type of homomorphisms between two pointed Galois objects. This is a homomorphism\nof the underlying objects of `C` that maps the distinguished points to each other. -/\n@[ext]\nstructure Hom (A B : PointedGaloisObject F) where\n  /-- The underlying homomorphism of `C`. -/\n  val : A.obj ‚ü∂ B.obj\n  /-- The distinguished point of `A` is mapped to the distinguished point of `B`. -/\n  comp : F.map val A.pt = B.pt := by simp\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.Hom.comp","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nself : A.Hom B\n‚ä¢ Eq (F.map self.val A.pt) B.pt","decl":"variable {F} in\n/-- The type of homomorphisms between two pointed Galois objects. This is a homomorphism\nof the underlying objects of `C` that maps the distinguished points to each other. -/\n@[ext]\nstructure Hom (A B : PointedGaloisObject F) where\n  /-- The underlying homomorphism of `C`. -/\n  val : A.obj ‚ü∂ B.obj\n  /-- The distinguished point of `A` is mapped to the distinguished point of `B`. -/\n  comp : F.map val A.pt = B.pt := by simp\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.Hom.ext","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nx y : A.Hom B\nval : Eq x.val y.val\n‚ä¢ Eq x y","decl":"variable {F} in\n/-- The type of homomorphisms between two pointed Galois objects. This is a homomorphism\nof the underlying objects of `C` that maps the distinguished points to each other. -/\n@[ext]\nstructure Hom (A B : PointedGaloisObject F) where\n  /-- The underlying homomorphism of `C`. -/\n  val : A.obj ‚ü∂ B.obj\n  /-- The distinguished point of `A` is mapped to the distinguished point of `B`. -/\n  comp : F.map val A.pt = B.pt := by simp\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.hom_ext_iff","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nf g : Quiver.Hom A B\n‚ä¢ Iff (Eq f g) (Eq f.val g.val)","decl":"@[ext]\nlemma hom_ext {A B : PointedGaloisObject F} {f g : A ‚ü∂ B} (h : f.val = g.val) : f = g :=\n  Hom.ext h\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.hom_ext","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nf g : Quiver.Hom A B\nh : Eq f.val g.val\n‚ä¢ Eq f g","decl":"@[ext]\nlemma hom_ext {A B : PointedGaloisObject F} {f g : A ‚ü∂ B} (h : f.val = g.val) : f = g :=\n  Hom.ext h\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.id_val","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id A).val (CategoryTheory.CategoryStruct.id A.obj)","decl":"@[simp]\nlemma id_val (A : PointedGaloisObject F) : ùüô A = ùüô A.obj :=\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.comp_val","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C‚úù : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C‚úù\ninst‚úù : CategoryTheory.GaloisCategory C‚úù\nF : CategoryTheory.Functor C‚úù FintypeCat\nA B C : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nf : Quiver.Hom A B\ng : Quiver.Hom B C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).val (CategoryTheory.CategoryStruct.comp f.val g.val)","decl":"@[simp, reassoc]\nlemma comp_val {A B C : PointedGaloisObject F} (f : A ‚ü∂ B) (g : B ‚ü∂ C) :\n    (f ‚â´ g).val = f.val ‚â´ g.val :=\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.comp_val_assoc","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C‚úù : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C‚úù\ninst‚úù : CategoryTheory.GaloisCategory C‚úù\nF : CategoryTheory.Functor C‚úù FintypeCat\nA B C : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nf : Quiver.Hom A B\ng : Quiver.Hom B C\nZ : C‚úù\nh : Quiver.Hom C.obj Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).val h) (CategoryTheory.CategoryStruct.comp f.val (CategoryTheory.CategoryStruct.comp g.val h))","decl":"@[simp, reassoc]\nlemma comp_val {A B C : PointedGaloisObject F} (f : A ‚ü∂ B) (g : B ‚ü∂ C) :\n    (f ‚â´ g).val = f.val ‚â´ g.val :=\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.incl_obj","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\n‚ä¢ Eq ((CategoryTheory.PreGaloisCategory.PointedGaloisObject.incl F).obj A) A.obj","decl":"@[simp]\nlemma incl_obj (A : PointedGaloisObject F) : (incl F).obj A = A :=\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.incl_map","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nf : Quiver.Hom A B\n‚ä¢ Eq ((CategoryTheory.PreGaloisCategory.PointedGaloisObject.incl F).map f) f.val","decl":"@[simp]\nlemma incl_map {A B : PointedGaloisObject F} (f : A ‚ü∂ B) : (incl F).map f = f.val :=\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.cocone_app","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nB : C\nf : Quiver.Hom A.obj B\n‚ä¢ Eq (((CategoryTheory.PreGaloisCategory.PointedGaloisObject.cocone F).Œπ.app { unop := A }).app B f) (F.map f A.pt)","decl":"@[simp]\nlemma cocone_app (A : PointedGaloisObject F) (B : C) (f : (A : C) ‚ü∂ B) :\n    ((cocone F).Œπ.app ‚ü®A‚ü©).app B f = F.map f A.pt :=\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.instIsCofilteredOrEmpty","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\n‚ä¢ CategoryTheory.IsCofilteredOrEmpty (CategoryTheory.PreGaloisCategory.PointedGaloisObject F)","decl":"/-- The category of pointed Galois objects is cofiltered. -/\ninstance : IsCofilteredOrEmpty (PointedGaloisObject F) where\n  cone_objs := fun ‚ü®A, a, _‚ü© ‚ü®B, b, _‚ü© ‚Ü¶ by\n    obtain ‚ü®Z, f, z, hgal, hfz‚ü© := exists_hom_from_galois_of_fiber F (A ‚®Ø B)\n      <| (fiberBinaryProductEquiv F A B).symm (a, b)\n    refine ‚ü®‚ü®Z, z, hgal‚ü©, ‚ü®f ‚â´ prod.fst, ?_‚ü©, ‚ü®f ‚â´ prod.snd, ?_‚ü©, trivial‚ü©\n    ¬∑ simp only [F.map_comp, hfz, FintypeCat.comp_apply, fiberBinaryProductEquiv_symm_fst_apply]\n    ¬∑ simp only [F.map_comp, hfz, FintypeCat.comp_apply, fiberBinaryProductEquiv_symm_snd_apply]\n  cone_maps := fun ‚ü®A, a, _‚ü© ‚ü®B, b, _‚ü© ‚ü®f, hf‚ü© ‚ü®g, hg‚ü© ‚Ü¶ by\n    obtain ‚ü®Z, h, z, hgal, hhz‚ü© := exists_hom_from_galois_of_fiber F A a\n    refine ‚ü®‚ü®Z, z, hgal‚ü©, ‚ü®h, hhz‚ü©, hom_ext ?_‚ü©\n    apply evaluation_injective_of_isConnected F Z B z\n    simp [hhz, hf, hg]\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.PointedGaloisObject.instHasColimitOppositeFunctorTypeCompOpInclCoyoneda","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst‚úù : CategoryTheory.PreGaloisCategory.FiberFunctor F\n‚ä¢ CategoryTheory.Limits.HasColimit ((CategoryTheory.PreGaloisCategory.PointedGaloisObject.incl F).op.comp CategoryTheory.coyoneda)","decl":"instance : HasColimit ((incl F).op ‚ãô coyoneda) where\n  exists_colimit := ‚ü®cocone F, isColimit F‚ü©\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autGaloisSystem_obj_coe","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\n‚ä¢ Eq (‚Üë((CategoryTheory.PreGaloisCategory.autGaloisSystem F).obj A)) (CategoryTheory.Aut A.obj)","decl":"/-- The diagram sending each pointed Galois object to its automorphism group\nas an object of `C`. -/\n@[simps]\nnoncomputable def autGaloisSystem : PointedGaloisObject F ‚•§ Grp.{u‚ÇÇ} where\n  obj := fun A ‚Ü¶ Grp.of <| Aut (A : C)\n  map := fun {A B} f ‚Ü¶ Grp.ofHom (autMapHom f)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autGaloisSystem_map","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nf : Quiver.Hom A B\n‚ä¢ Eq ((CategoryTheory.PreGaloisCategory.autGaloisSystem F).map f) (Grp.ofHom (CategoryTheory.PreGaloisCategory.autMapHom f.val))","decl":"/-- The diagram sending each pointed Galois object to its automorphism group\nas an object of `C`. -/\n@[simps]\nnoncomputable def autGaloisSystem : PointedGaloisObject F ‚•§ Grp.{u‚ÇÇ} where\n  obj := fun A ‚Ü¶ Grp.of <| Aut (A : C)\n  map := fun {A B} f ‚Ü¶ Grp.ofHom (autMapHom f)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.AutGalois.œÄ_apply","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nx : CategoryTheory.PreGaloisCategory.AutGalois F\n‚ä¢ Eq ((CategoryTheory.PreGaloisCategory.AutGalois.œÄ F A) x) (‚Üëx A)","decl":"lemma AutGalois.œÄ_apply (A : PointedGaloisObject F) (x : AutGalois F) :\n    AutGalois.œÄ F A x = x.val A :=\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autGaloisSystem_map_surjective","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nf : Quiver.Hom A B\n‚ä¢ Function.Surjective ‚áë(CategoryTheory.ConcreteCategory.hom ((CategoryTheory.PreGaloisCategory.autGaloisSystem F).map f))","decl":"lemma autGaloisSystem_map_surjective ‚¶ÉA B : PointedGaloisObject F‚¶Ñ (f : A ‚ü∂ B) :\n    Function.Surjective ((autGaloisSystem F).map f) := by\n  intro (œÜ : Aut B.obj)\n  obtain ‚ü®œà, hœà‚ü© := autMap_surjective_of_isGalois f.val œÜ\n  use œà\n  simp only [autGaloisSystem_map]\n  exact hœà\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.AutGalois.ext","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nf g : CategoryTheory.PreGaloisCategory.AutGalois F\nh : ‚àÄ (A : CategoryTheory.PreGaloisCategory.PointedGaloisObject F), Eq ((CategoryTheory.PreGaloisCategory.AutGalois.œÄ F A) f) ((CategoryTheory.PreGaloisCategory.AutGalois.œÄ F A) g)\n‚ä¢ Eq f g","decl":"/-- Equality of elements of `AutGalois F` can be checked on the projections on each pointed\nGalois object. -/\nlemma AutGalois.ext {f g : AutGalois F}\n    (h : ‚àÄ (A : PointedGaloisObject F), AutGalois.œÄ F A f = AutGalois.œÄ F A g) : f = g := by\n  dsimp only [AutGalois]\n  ext A\n  exact h A\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.AutGalois.œÄ_surjective","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst‚úù : CategoryTheory.PreGaloisCategory.FiberFunctor F\nA : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\n‚ä¢ Function.Surjective ‚áë(CategoryTheory.PreGaloisCategory.AutGalois.œÄ F A)","decl":"/-- `autGalois.œÄ` is surjective for every pointed Galois object. -/\ntheorem AutGalois.œÄ_surjective (A : PointedGaloisObject F) :\n    Function.Surjective (AutGalois.œÄ F A) := fun (œÉ : Aut A.obj) ‚Ü¶ by\n  have (i : PointedGaloisObject F) : Finite ((autGaloisSystem F ‚ãô forget _).obj i) :=\n    inferInstanceAs <| Finite (Aut (i.obj))\n  exact eval_section_surjective_of_surjective\n    (autGaloisSystem F ‚ãô forget _) (autGaloisSystem_map_surjective F) A œÉ\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.endEquivSectionsFibers_œÄ","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst‚úù : CategoryTheory.PreGaloisCategory.FiberFunctor F\nf : CategoryTheory.End F\nA : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\n‚ä¢ Eq (‚Üë((CategoryTheory.PreGaloisCategory.endEquivSectionsFibers F) f) A) (f.app A.obj A.pt)","decl":"@[simp]\nlemma endEquivSectionsFibers_œÄ (f : End F) (A : PointedGaloisObject F) :\n    (endEquivSectionsFibers F f).val A = f.app A A.pt := by\n  dsimp [endEquivSectionsFibers, Types.sectionsEquiv]\n  erw [Types.limitEquivSections_apply]\n  simp only [colimitCoyonedaHomIsoLimit'_œÄ_apply, incl_obj, comp_obj, FintypeCat.incl_obj, op_obj,\n    FunctorToTypes.comp]\n  change (((FullyFaithful.whiskeringRight (FullyFaithful.ofFullyFaithful\n      FintypeCat.incl) C).homEquiv) f).app A\n    (((colimit.Œπ _ _) ‚â´ (colimit.isoColimitCocone ‚ü®cocone F, isColimit F‚ü©).hom).app\n      A _) = f.app A A.pt\n  simp\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autIsoFibers_inv_app","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst‚úù : CategoryTheory.PreGaloisCategory.FiberFunctor F\nA : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\nb : ‚Üë(F.obj A.obj)\n‚ä¢ Eq ((CategoryTheory.PreGaloisCategory.autIsoFibers F).inv.app A b) ((CategoryTheory.PreGaloisCategory.evaluationEquivOfIsGalois F A.obj A.pt).symm b)","decl":"lemma autIsoFibers_inv_app (A : PointedGaloisObject F) (b : F.obj A) :\n    (autIsoFibers F).inv.app A b = (evaluationEquivOfIsGalois F A A.pt).symm b :=\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.endEquivAutGalois_œÄ","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst‚úù : CategoryTheory.PreGaloisCategory.FiberFunctor F\nf : CategoryTheory.End F\nA : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\n‚ä¢ Eq (F.map ((CategoryTheory.PreGaloisCategory.AutGalois.œÄ F A) ((CategoryTheory.PreGaloisCategory.endEquivAutGalois F) f)).hom A.pt) (f.app A.obj A.pt)","decl":"lemma endEquivAutGalois_œÄ (f : End F) (A : PointedGaloisObject F) :\n    F.map (AutGalois.œÄ F A (endEquivAutGalois F f)).hom A.pt = f.app A A.pt := by\n  dsimp [endEquivAutGalois, AutGalois.œÄ_apply]\n  change F.map ((((sectionsFunctor _).map (autIsoFibers F).inv) _).val A).hom A.pt = _\n  dsimp [autIsoFibers]\n  simp only [endEquivSectionsFibers_œÄ]\n  erw [evaluationEquivOfIsGalois_symm_fiber]\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.endEquivAutGalois_mul","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst‚úù : CategoryTheory.PreGaloisCategory.FiberFunctor F\nf g : CategoryTheory.End F\n‚ä¢ Eq ((CategoryTheory.PreGaloisCategory.endEquivAutGalois F) (CategoryTheory.CategoryStruct.comp g f)) (HMul.hMul ((CategoryTheory.PreGaloisCategory.endEquivAutGalois F) g) ((CategoryTheory.PreGaloisCategory.endEquivAutGalois F) f))","decl":"@[simp]\ntheorem endEquivAutGalois_mul (f g : End F) :\n    (endEquivAutGalois F) (g ‚â´ f) = (endEquivAutGalois F g) * (endEquivAutGalois F f) := by\n  refine AutGalois.ext F (fun A ‚Ü¶ evaluation_aut_injective_of_isConnected F A A.pt ?_)\n  simp only [map_mul, endEquivAutGalois_œÄ, Aut.Aut_mul_def, NatTrans.comp_app, Iso.trans_hom]\n  simp only [map_comp, FintypeCat.comp_apply, endEquivAutGalois_œÄ]\n  change f.app A (g.app A A.pt) =\n    (f.app A ‚â´ F.map ((AutGalois.œÄ F A) ((endEquivAutGalois F) g)).hom) A.pt\n  rw [‚Üê f.naturality, FintypeCat.comp_apply, endEquivAutGalois_œÄ]\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.endMulEquivAutGalois_pi","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst‚úù : CategoryTheory.PreGaloisCategory.FiberFunctor F\nf : CategoryTheory.End F\nA : CategoryTheory.PreGaloisCategory.PointedGaloisObject F\n‚ä¢ Eq (F.map ((CategoryTheory.PreGaloisCategory.AutGalois.œÄ F A) (MulOpposite.unop ((CategoryTheory.PreGaloisCategory.endMulEquivAutGalois F) f))).hom A.pt) (f.app A.obj A.pt)","decl":"lemma endMulEquivAutGalois_pi (f : End F) (A : PointedGaloisObject F) :\n    F.map (AutGalois.œÄ F A (endMulEquivAutGalois F f).unop).hom A.2 = f.app A A.pt :=\n  endEquivAutGalois_œÄ F f A\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.FibreFunctor.end_isUnit","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst‚úù : CategoryTheory.PreGaloisCategory.FiberFunctor F\nf : CategoryTheory.End F\n‚ä¢ IsUnit f","decl":"/-- Any endomorphism of a fiber functor is a unit. -/\ntheorem FibreFunctor.end_isUnit (f : End F) : IsUnit f :=\n  (isUnit_map_iff (endMulEquivAutGalois F) _).mp\n    (Group.isUnit ((endMulEquivAutGalois F) f))\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.FibreFunctor.end_isIso","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\nf : CategoryTheory.End F\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- Any endomorphism of a fiber functor is an isomorphism. -/\ninstance FibreFunctor.end_isIso (f : End F) : IsIso f := by\n  rw [‚Üê isUnit_iff_isIso]\n  exact FibreFunctor.end_isUnit F f\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autMulEquivAutGalois_œÄ","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst‚úù¬π : CategoryTheory.PreGaloisCategory.FiberFunctor F\nf : CategoryTheory.Aut F\nA : C\ninst‚úù : CategoryTheory.PreGaloisCategory.IsGalois A\na : ‚Üë(F.obj A)\n‚ä¢ Eq (F.map ((CategoryTheory.PreGaloisCategory.AutGalois.œÄ F { obj := A, pt := a, isGalois := ‚ãØ }) (MulOpposite.unop ((CategoryTheory.PreGaloisCategory.autMulEquivAutGalois F) f))).hom a) (f.hom.app A a)","decl":"lemma autMulEquivAutGalois_œÄ (f : Aut F) (A : C) [IsGalois A] (a : F.obj A) :\n    F.map (AutGalois.œÄ F { obj := A, pt := a } (autMulEquivAutGalois F f).unop).hom a =\n      f.hom.app A a := by\n  dsimp [autMulEquivAutGalois, endMulEquivAutGalois]\n  rw [endEquivAutGalois_œÄ]\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autMulEquivAutGalois_symm_app","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst‚úù¬π : CategoryTheory.PreGaloisCategory.FiberFunctor F\nx : CategoryTheory.PreGaloisCategory.AutGalois F\nA : C\ninst‚úù : CategoryTheory.PreGaloisCategory.IsGalois A\na : ‚Üë(F.obj A)\n‚ä¢ Eq (((CategoryTheory.PreGaloisCategory.autMulEquivAutGalois F).symm { unop' := x }).hom.app A a) (F.map ((CategoryTheory.PreGaloisCategory.AutGalois.œÄ F { obj := A, pt := a, isGalois := ‚ãØ }) x).hom a)","decl":"@[simp]\nlemma autMulEquivAutGalois_symm_app (x : AutGalois F) (A : C) [IsGalois A] (a : F.obj A) :\n    ((autMulEquivAutGalois F).symm ‚ü®x‚ü©).hom.app A a =\n      F.map (AutGalois.œÄ F ‚ü®A, a, inferInstance‚ü© x).hom a := by\n  rw [‚Üê autMulEquivAutGalois_œÄ, MulEquiv.apply_symm_apply]\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.FiberFunctor.isPretransitive_of_isGalois","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst‚úù¬π : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX : C\ninst‚úù : CategoryTheory.PreGaloisCategory.IsGalois X\n‚ä¢ MulAction.IsPretransitive (CategoryTheory.Aut F) ‚Üë(F.obj X)","decl":"/-- The `Aut F` action on the fiber of a Galois object is transitive. See\n`pretransitive_of_isConnected` for the same result for connected objects. -/\ntheorem FiberFunctor.isPretransitive_of_isGalois (X : C) [IsGalois X] :\n    MulAction.IsPretransitive (Aut F) (F.obj X) := by\n  refine ‚ü®fun x y ‚Ü¶ ?_‚ü©\n  obtain ‚ü®(œÜ : Aut X), h‚ü© := MulAction.IsPretransitive.exists_smul_eq (M := Aut X) x y\n  obtain ‚ü®a, ha‚ü© := AutGalois.œÄ_surjective F ‚ü®X, x, inferInstance‚ü© œÜ\n  use (autMulEquivAutGalois F).symm ‚ü®a‚ü©\n  simpa [mulAction_def, ha]\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.FiberFunctor.isPretransitive_of_isConnected","module":"Mathlib.CategoryTheory.Galois.Prorepresentability","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\nX : C\ninst‚úù : CategoryTheory.PreGaloisCategory.IsConnected X\n‚ä¢ MulAction.IsPretransitive (CategoryTheory.Aut F) ‚Üë(F.obj X)","decl":"/-- The `Aut F` action on the fiber of a connected object is transitive. -/\ninstance FiberFunctor.isPretransitive_of_isConnected (X : C) [IsConnected X] :\n    MulAction.IsPretransitive (Aut F) (F.obj X) where\n  exists_smul_eq x y := by\n    let F' : C ‚•§ FintypeCat.{u‚ÇÇ} := F ‚ãô FintypeCat.uSwitch.{w, u‚ÇÇ}\n    letI : FiberFunctor F' := FiberFunctor.comp_right _\n    let e (Y : C) : F'.obj Y ‚âÉ F.obj Y := (F.obj Y).uSwitchEquiv\n    set x' : F'.obj X := (e X).symm x with hx'\n    set y' : F'.obj X := (e X).symm y with hy'\n    obtain ‚ü®g', (hg' : g'.hom.app X x' = y')‚ü© := MulAction.exists_smul_eq (Aut F') x' y'\n    let gapp (Y : C) : F.obj Y ‚âÖ F.obj Y := FintypeCat.equivEquivIso <|\n      (e Y).symm.trans <| (FintypeCat.equivEquivIso.symm (g'.app Y)).trans (e Y)\n    let g : F ‚âÖ F := NatIso.ofComponents gapp <| fun {X Y} f ‚Ü¶ by\n      ext x\n      simp only [FintypeCat.comp_apply, FintypeCat.equivEquivIso_apply_hom,\n        Equiv.trans_apply, FintypeCat.equivEquivIso_symm_apply_apply, Iso.app_hom, gapp, e]\n      erw [FintypeCat.uSwitchEquiv_naturality (F.map f)]\n      rw [‚Üê Functor.comp_map, ‚Üê FunctorToFintypeCat.naturality]\n      simp only [comp_obj, Functor.comp_map, F']\n      rw [FintypeCat.uSwitchEquiv_symm_naturality (F.map f)]\n    refine ‚ü®g, show (gapp X).hom x = y from ?_‚ü©\n    simp only [FintypeCat.equivEquivIso_apply_hom, Equiv.trans_apply,\n      FintypeCat.equivEquivIso_symm_apply_apply, Iso.app_hom, gapp]\n    rw [‚Üê hx', hg', hy', Equiv.apply_symm_apply]\n\n"}
