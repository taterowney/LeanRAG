{"name":"Projectivization.independent_iff","module":"Mathlib.LinearAlgebra.Projectivization.Independence","initialProofState":"ι : Type u_1\nK : Type u_2\nV : Type u_3\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nf : ι → Projectivization K V\n⊢ Iff (Projectivization.Independent f) (LinearIndependent K (Function.comp Projectivization.rep f))","decl":"/-- A family of points in a projective space is independent if and only if the representative\nvectors determined by the family are linearly independent. -/\ntheorem independent_iff : Independent f ↔ LinearIndependent K (Projectivization.rep ∘ f) := by\n  refine ⟨?_, fun h => ?_⟩\n  · rintro ⟨ff, hff, hh⟩\n    choose a ha using fun i : ι => exists_smul_eq_mk_rep K (ff i) (hff i)\n    convert hh.units_smul a\n    ext i\n    exact (ha i).symm\n  · convert Independent.mk _ _ h\n    · simp only [mk_rep, Function.comp_apply]\n    · intro i\n      apply rep_nonzero\n\n"}
{"name":"Projectivization.independent_iff_iSupIndep","module":"Mathlib.LinearAlgebra.Projectivization.Independence","initialProofState":"ι : Type u_1\nK : Type u_2\nV : Type u_3\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nf : ι → Projectivization K V\n⊢ Iff (Projectivization.Independent f) (iSupIndep fun i => (f i).submodule)","decl":"/-- A family of points in projective space is independent if and only if the family of\nsubmodules which the points determine is independent in the lattice-theoretic sense. -/\ntheorem independent_iff_iSupIndep : Independent f ↔ iSupIndep fun i => (f i).submodule := by\n  refine ⟨?_, fun h => ?_⟩\n  · rintro ⟨f, hf, hi⟩\n    simp only [submodule_mk]\n    exact (iSupIndep_iff_linearIndependent_of_ne_zero (R := K) hf).mpr hi\n  · rw [independent_iff]\n    refine h.linearIndependent (Projectivization.submodule ∘ f) (fun i => ?_) fun i => ?_\n    · simpa only [Function.comp_apply, submodule_eq] using Submodule.mem_span_singleton_self _\n    · exact rep_nonzero (f i)\n\n"}
{"name":"Projectivization.independent_iff_completeLattice_independent","module":"Mathlib.LinearAlgebra.Projectivization.Independence","initialProofState":"ι : Type u_1\nK : Type u_2\nV : Type u_3\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nf : ι → Projectivization K V\n⊢ Iff (Projectivization.Independent f) (iSupIndep fun i => (f i).submodule)","decl":"@[deprecated (since := \"2024-11-24\")]\nalias independent_iff_completeLattice_independent := independent_iff_iSupIndep\n\n"}
{"name":"Projectivization.dependent_iff","module":"Mathlib.LinearAlgebra.Projectivization.Independence","initialProofState":"ι : Type u_1\nK : Type u_2\nV : Type u_3\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nf : ι → Projectivization K V\n⊢ Iff (Projectivization.Dependent f) (Not (LinearIndependent K (Function.comp Projectivization.rep f)))","decl":"/-- A family of points in a projective space is dependent if and only if their\nrepresentatives are linearly dependent. -/\ntheorem dependent_iff : Dependent f ↔ ¬LinearIndependent K (Projectivization.rep ∘ f) := by\n  refine ⟨?_, fun h => ?_⟩\n  · rintro ⟨ff, hff, hh1⟩\n    contrapose! hh1\n    choose a ha using fun i : ι => exists_smul_eq_mk_rep K (ff i) (hff i)\n    convert hh1.units_smul a⁻¹\n    ext i\n    simp only [← ha, inv_smul_smul, Pi.smul_apply', Pi.inv_apply, Function.comp_apply]\n  · convert Dependent.mk _ _ h\n    · simp only [mk_rep, Function.comp_apply]\n    · exact fun i => rep_nonzero (f i)\n\n"}
{"name":"Projectivization.dependent_iff_not_independent","module":"Mathlib.LinearAlgebra.Projectivization.Independence","initialProofState":"ι : Type u_1\nK : Type u_2\nV : Type u_3\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nf : ι → Projectivization K V\n⊢ Iff (Projectivization.Dependent f) (Not (Projectivization.Independent f))","decl":"/-- Dependence is the negation of independence. -/\ntheorem dependent_iff_not_independent : Dependent f ↔ ¬Independent f := by\n  rw [dependent_iff, independent_iff]\n\n"}
{"name":"Projectivization.independent_iff_not_dependent","module":"Mathlib.LinearAlgebra.Projectivization.Independence","initialProofState":"ι : Type u_1\nK : Type u_2\nV : Type u_3\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nf : ι → Projectivization K V\n⊢ Iff (Projectivization.Independent f) (Not (Projectivization.Dependent f))","decl":"/-- Independence is the negation of dependence. -/\ntheorem independent_iff_not_dependent : Independent f ↔ ¬Dependent f := by\n  rw [dependent_iff_not_independent, Classical.not_not]\n\n"}
{"name":"Projectivization.dependent_pair_iff_eq","module":"Mathlib.LinearAlgebra.Projectivization.Independence","initialProofState":"K : Type u_2\nV : Type u_3\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nu v : Projectivization K V\n⊢ Iff (Projectivization.Dependent (Matrix.vecCons u (Matrix.vecCons v Matrix.vecEmpty))) (Eq u v)","decl":"/-- Two points in a projective space are dependent if and only if they are equal. -/\n@[simp]\ntheorem dependent_pair_iff_eq (u v : ℙ K V) : Dependent ![u, v] ↔ u = v := by\n  rw [dependent_iff_not_independent, independent_iff, linearIndependent_fin2,\n    Function.comp_apply, Matrix.cons_val_one, Matrix.head_cons, Ne]\n  simp only [Matrix.cons_val_zero, not_and, not_forall, Classical.not_not, Function.comp_apply,\n    ← mk_eq_mk_iff' K _ _ (rep_nonzero u) (rep_nonzero v), mk_rep, Classical.imp_iff_right_iff]\n  exact Or.inl (rep_nonzero v)\n\n"}
{"name":"Projectivization.independent_pair_iff_neq","module":"Mathlib.LinearAlgebra.Projectivization.Independence","initialProofState":"K : Type u_2\nV : Type u_3\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nu v : Projectivization K V\n⊢ Iff (Projectivization.Independent (Matrix.vecCons u (Matrix.vecCons v Matrix.vecEmpty))) (Ne u v)","decl":"/-- Two points in a projective space are independent if and only if the points are not equal. -/\n@[simp]\ntheorem independent_pair_iff_neq (u v : ℙ K V) : Independent ![u, v] ↔ u ≠ v := by\n  rw [independent_iff_not_dependent, dependent_pair_iff_eq u v]\n\n"}
