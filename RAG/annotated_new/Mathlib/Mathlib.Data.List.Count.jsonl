{"name":"List.countP_erase","module":"Mathlib.Data.List.Count","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\np : α → Bool\nl : List α\na : α\n⊢ Eq (List.countP p (l.erase a)) (HSub.hSub (List.countP p l) (ite (And (Membership.mem l a) (Eq (p a) Bool.true)) 1 0))","decl":"lemma countP_erase [DecidableEq α] (p : α → Bool) (l : List α) (a : α) :\n    countP p (l.erase a) = countP p l - if a ∈ l ∧ p a then 1 else 0 := by\n  rw [countP_eq_length_filter, countP_eq_length_filter, ← erase_filter, length_erase]\n  aesop\n\n"}
{"name":"List.count_diff","module":"Mathlib.Data.List.Count","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nl₁ l₂ : List α\n⊢ Eq (List.count a (l₁.diff l₂)) (HSub.hSub (List.count a l₁) (List.count a l₂))","decl":"lemma count_diff [DecidableEq α] (a : α) (l₁ : List α) :\n    ∀ l₂, count a (l₁.diff l₂) = count a l₁ - count a l₂\n  | [] => rfl\n  | b :: l₂ => by\n    simp only [diff_cons, count_diff, count_erase, beq_iff_eq, Nat.sub_right_comm, count_cons,\n      Nat.sub_add_eq]\n\n"}
{"name":"List.countP_diff","module":"Mathlib.Data.List.Count","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl₁ l₂ : List α\nhl : l₂.Subperm l₁\np : α → Bool\n⊢ Eq (List.countP p (l₁.diff l₂)) (HSub.hSub (List.countP p l₁) (List.countP p l₂))","decl":"lemma countP_diff [DecidableEq α] {l₁ l₂ : List α} (hl : l₂ <+~ l₁) (p : α → Bool) :\n    countP p (l₁.diff l₂) = countP p l₁ - countP p l₂ := by\n  refine (Nat.sub_eq_of_eq_add ?_).symm\n  rw [← countP_append]\n  exact ((subperm_append_diff_self_of_count_le <| subperm_ext_iff.1 hl).symm.trans\n    perm_append_comm).countP_eq _\n\n"}
{"name":"List.count_map_of_injective","module":"Mathlib.Data.List.Count","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nl : List α\nf : α → β\nhf : Function.Injective f\nx : α\n⊢ Eq (List.count (f x) (List.map f l)) (List.count x l)","decl":"@[simp]\ntheorem count_map_of_injective {β} [DecidableEq α] [DecidableEq β] (l : List α) (f : α → β)\n    (hf : Function.Injective f) (x : α) : count (f x) (map f l) = count x l := by\n  simp only [count, countP_map]\n  unfold Function.comp\n  simp only [hf.beq_eq]\n\n"}
