{"name":"Filter.tendsto_def","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nl₁ : Filter α\nl₂ : Filter β\n⊢ Iff (Filter.Tendsto f l₁ l₂) (∀ (s : Set β), Membership.mem l₂ s → Membership.mem l₁ (Set.preimage f s))","decl":"theorem tendsto_def {f : α → β} {l₁ : Filter α} {l₂ : Filter β} :\n    Tendsto f l₁ l₂ ↔ ∀ s ∈ l₂, f ⁻¹' s ∈ l₁ :=\n  Iff.rfl\n\n"}
{"name":"Filter.tendsto_iff_eventually","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nl₁ : Filter α\nl₂ : Filter β\n⊢ Iff (Filter.Tendsto f l₁ l₂) (∀ ⦃p : β → Prop⦄, Filter.Eventually (fun y => p y) l₂ → Filter.Eventually (fun x => p (f x)) l₁)","decl":"theorem tendsto_iff_eventually {f : α → β} {l₁ : Filter α} {l₂ : Filter β} :\n    Tendsto f l₁ l₂ ↔ ∀ ⦃p : β → Prop⦄, (∀ᶠ y in l₂, p y) → ∀ᶠ x in l₁, p (f x) :=\n  Iff.rfl\n\n"}
{"name":"Filter.tendsto_iff_forall_eventually_mem","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nl₁ : Filter α\nl₂ : Filter β\n⊢ Iff (Filter.Tendsto f l₁ l₂) (∀ (s : Set β), Membership.mem l₂ s → Filter.Eventually (fun x => Membership.mem s (f x)) l₁)","decl":"theorem tendsto_iff_forall_eventually_mem {f : α → β} {l₁ : Filter α} {l₂ : Filter β} :\n    Tendsto f l₁ l₂ ↔ ∀ s ∈ l₂, ∀ᶠ x in l₁, f x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Filter.Tendsto.eventually_mem","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nl₁ : Filter α\nl₂ : Filter β\ns : Set β\nhf : Filter.Tendsto f l₁ l₂\nh : Membership.mem l₂ s\n⊢ Filter.Eventually (fun x => Membership.mem s (f x)) l₁","decl":"lemma Tendsto.eventually_mem {f : α → β} {l₁ : Filter α} {l₂ : Filter β} {s : Set β}\n    (hf : Tendsto f l₁ l₂) (h : s ∈ l₂) : ∀ᶠ x in l₁, f x ∈ s :=\n  hf h\n\n"}
{"name":"Filter.Tendsto.eventually","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nl₁ : Filter α\nl₂ : Filter β\np : β → Prop\nhf : Filter.Tendsto f l₁ l₂\nh : Filter.Eventually (fun y => p y) l₂\n⊢ Filter.Eventually (fun x => p (f x)) l₁","decl":"theorem Tendsto.eventually {f : α → β} {l₁ : Filter α} {l₂ : Filter β} {p : β → Prop}\n    (hf : Tendsto f l₁ l₂) (h : ∀ᶠ y in l₂, p y) : ∀ᶠ x in l₁, p (f x) :=\n  hf h\n\n"}
{"name":"Filter.not_tendsto_iff_exists_frequently_nmem","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nl₁ : Filter α\nl₂ : Filter β\n⊢ Iff (Not (Filter.Tendsto f l₁ l₂)) (Exists fun s => And (Membership.mem l₂ s) (Filter.Frequently (fun x => Not (Membership.mem s (f x))) l₁))","decl":"theorem not_tendsto_iff_exists_frequently_nmem {f : α → β} {l₁ : Filter α} {l₂ : Filter β} :\n    ¬Tendsto f l₁ l₂ ↔ ∃ s ∈ l₂, ∃ᶠ x in l₁, f x ∉ s := by\n  simp only [tendsto_iff_forall_eventually_mem, not_forall, exists_prop, not_eventually]\n\n"}
{"name":"Filter.Tendsto.frequently","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nl₁ : Filter α\nl₂ : Filter β\np : β → Prop\nhf : Filter.Tendsto f l₁ l₂\nh : Filter.Frequently (fun x => p (f x)) l₁\n⊢ Filter.Frequently (fun y => p y) l₂","decl":"theorem Tendsto.frequently {f : α → β} {l₁ : Filter α} {l₂ : Filter β} {p : β → Prop}\n    (hf : Tendsto f l₁ l₂) (h : ∃ᶠ x in l₁, p (f x)) : ∃ᶠ y in l₂, p y :=\n  mt hf.eventually h\n\n"}
{"name":"Filter.Tendsto.frequently_map","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nl₁ : Filter α\nl₂ : Filter β\np : α → Prop\nq : β → Prop\nf : α → β\nc : Filter.Tendsto f l₁ l₂\nw : ∀ (x : α), p x → q (f x)\nh : Filter.Frequently (fun x => p x) l₁\n⊢ Filter.Frequently (fun y => q y) l₂","decl":"theorem Tendsto.frequently_map {l₁ : Filter α} {l₂ : Filter β} {p : α → Prop} {q : β → Prop}\n    (f : α → β) (c : Filter.Tendsto f l₁ l₂) (w : ∀ x, p x → q (f x)) (h : ∃ᶠ x in l₁, p x) :\n    ∃ᶠ y in l₂, q y :=\n  c.frequently (h.mono w)\n\n"}
{"name":"Filter.tendsto_bot","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nl : Filter β\n⊢ Filter.Tendsto f Bot.bot l","decl":"@[simp]\ntheorem tendsto_bot {f : α → β} {l : Filter β} : Tendsto f ⊥ l := by simp [Tendsto]\n\n"}
{"name":"Filter.Tendsto.of_neBot_imp","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nla : Filter α\nlb : Filter β\nh : la.NeBot → Filter.Tendsto f la lb\n⊢ Filter.Tendsto f la lb","decl":"theorem Tendsto.of_neBot_imp {f : α → β} {la : Filter α} {lb : Filter β}\n    (h : NeBot la → Tendsto f la lb) : Tendsto f la lb := by\n  rcases eq_or_neBot la with rfl | hla\n  · exact tendsto_bot\n  · exact h hla\n\n"}
{"name":"Filter.tendsto_top","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nl : Filter α\n⊢ Filter.Tendsto f l Top.top","decl":"@[simp] theorem tendsto_top {f : α → β} {l : Filter α} : Tendsto f l ⊤ := le_top\n\n"}
{"name":"Filter.le_map_of_right_inverse","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nmab : α → β\nmba : β → α\nf : Filter α\ng : Filter β\nh₁ : g.EventuallyEq (Function.comp mab mba) id\nh₂ : Filter.Tendsto mba g f\n⊢ LE.le g (Filter.map mab f)","decl":"theorem le_map_of_right_inverse {mab : α → β} {mba : β → α} {f : Filter α} {g : Filter β}\n    (h₁ : mab ∘ mba =ᶠ[g] id) (h₂ : Tendsto mba g f) : g ≤ map mab f := by\n  rw [← @map_id _ g, ← map_congr h₁, ← map_map]\n  exact map_mono h₂\n\n"}
{"name":"Filter.tendsto_of_isEmpty","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : IsEmpty α\nf : α → β\nla : Filter α\nlb : Filter β\n⊢ Filter.Tendsto f la lb","decl":"theorem tendsto_of_isEmpty [IsEmpty α] {f : α → β} {la : Filter α} {lb : Filter β} :\n    Tendsto f la lb := by simp only [filter_eq_bot_of_isEmpty la, tendsto_bot]\n\n"}
{"name":"Filter.eventuallyEq_of_left_inv_of_right_inv","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ng₁ g₂ : β → α\nfa : Filter α\nfb : Filter β\nhleft : Filter.Eventually (fun x => Eq (g₁ (f x)) x) fa\nhright : Filter.Eventually (fun y => Eq (f (g₂ y)) y) fb\nhtendsto : Filter.Tendsto g₂ fb fa\n⊢ fb.EventuallyEq g₁ g₂","decl":"theorem eventuallyEq_of_left_inv_of_right_inv {f : α → β} {g₁ g₂ : β → α} {fa : Filter α}\n    {fb : Filter β} (hleft : ∀ᶠ x in fa, g₁ (f x) = x) (hright : ∀ᶠ y in fb, f (g₂ y) = y)\n    (htendsto : Tendsto g₂ fb fa) : g₁ =ᶠ[fb] g₂ :=\n  (htendsto.eventually hleft).mp <| hright.mono fun _ hr hl => (congr_arg g₁ hr.symm).trans hl\n\n"}
{"name":"Filter.tendsto_iff_comap","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nl₁ : Filter α\nl₂ : Filter β\n⊢ Iff (Filter.Tendsto f l₁ l₂) (LE.le l₁ (Filter.comap f l₂))","decl":"theorem tendsto_iff_comap {f : α → β} {l₁ : Filter α} {l₂ : Filter β} :\n    Tendsto f l₁ l₂ ↔ l₁ ≤ l₂.comap f :=\n  map_le_iff_le_comap\n\n"}
{"name":"Filter.Tendsto.le_comap","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nl₁ : Filter α\nl₂ : Filter β\na✝ : Filter.Tendsto f l₁ l₂\n⊢ LE.le l₁ (Filter.comap f l₂)","decl":"alias ⟨Tendsto.le_comap, _⟩ := tendsto_iff_comap\n\n"}
{"name":"Filter.Tendsto.disjoint","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nla₁ la₂ : Filter α\nlb₁ lb₂ : Filter β\nh₁ : Filter.Tendsto f la₁ lb₁\nhd : Disjoint lb₁ lb₂\nh₂ : Filter.Tendsto f la₂ lb₂\n⊢ Disjoint la₁ la₂","decl":"protected theorem Tendsto.disjoint {f : α → β} {la₁ la₂ : Filter α} {lb₁ lb₂ : Filter β}\n    (h₁ : Tendsto f la₁ lb₁) (hd : Disjoint lb₁ lb₂) (h₂ : Tendsto f la₂ lb₂) : Disjoint la₁ la₂ :=\n  (disjoint_comap hd).mono h₁.le_comap h₂.le_comap\n\n"}
{"name":"Filter.tendsto_congr'","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf₁ f₂ : α → β\nl₁ : Filter α\nl₂ : Filter β\nhl : l₁.EventuallyEq f₁ f₂\n⊢ Iff (Filter.Tendsto f₁ l₁ l₂) (Filter.Tendsto f₂ l₁ l₂)","decl":"theorem tendsto_congr' {f₁ f₂ : α → β} {l₁ : Filter α} {l₂ : Filter β} (hl : f₁ =ᶠ[l₁] f₂) :\n    Tendsto f₁ l₁ l₂ ↔ Tendsto f₂ l₁ l₂ := by rw [Tendsto, Tendsto, map_congr hl]\n\n"}
{"name":"Filter.Tendsto.congr'","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf₁ f₂ : α → β\nl₁ : Filter α\nl₂ : Filter β\nhl : l₁.EventuallyEq f₁ f₂\nh : Filter.Tendsto f₁ l₁ l₂\n⊢ Filter.Tendsto f₂ l₁ l₂","decl":"theorem Tendsto.congr' {f₁ f₂ : α → β} {l₁ : Filter α} {l₂ : Filter β} (hl : f₁ =ᶠ[l₁] f₂)\n    (h : Tendsto f₁ l₁ l₂) : Tendsto f₂ l₁ l₂ :=\n  (tendsto_congr' hl).1 h\n\n"}
{"name":"Filter.tendsto_congr","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf₁ f₂ : α → β\nl₁ : Filter α\nl₂ : Filter β\nh : ∀ (x : α), Eq (f₁ x) (f₂ x)\n⊢ Iff (Filter.Tendsto f₁ l₁ l₂) (Filter.Tendsto f₂ l₁ l₂)","decl":"theorem tendsto_congr {f₁ f₂ : α → β} {l₁ : Filter α} {l₂ : Filter β} (h : ∀ x, f₁ x = f₂ x) :\n    Tendsto f₁ l₁ l₂ ↔ Tendsto f₂ l₁ l₂ :=\n  tendsto_congr' (univ_mem' h)\n\n"}
{"name":"Filter.Tendsto.congr","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf₁ f₂ : α → β\nl₁ : Filter α\nl₂ : Filter β\nh : ∀ (x : α), Eq (f₁ x) (f₂ x)\na✝ : Filter.Tendsto f₁ l₁ l₂\n⊢ Filter.Tendsto f₂ l₁ l₂","decl":"theorem Tendsto.congr {f₁ f₂ : α → β} {l₁ : Filter α} {l₂ : Filter β} (h : ∀ x, f₁ x = f₂ x) :\n    Tendsto f₁ l₁ l₂ → Tendsto f₂ l₁ l₂ :=\n  (tendsto_congr h).1\n\n"}
{"name":"Filter.tendsto_id'","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nx y : Filter α\n⊢ Iff (Filter.Tendsto id x y) (LE.le x y)","decl":"theorem tendsto_id' {x y : Filter α} : Tendsto id x y ↔ x ≤ y :=\n  Iff.rfl\n\n"}
{"name":"Filter.tendsto_id","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nx : Filter α\n⊢ Filter.Tendsto id x x","decl":"theorem tendsto_id {x : Filter α} : Tendsto id x x :=\n  le_refl x\n\n"}
{"name":"Filter.Tendsto.comp","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\ng : β → γ\nx : Filter α\ny : Filter β\nz : Filter γ\nhg : Filter.Tendsto g y z\nhf : Filter.Tendsto f x y\n⊢ Filter.Tendsto (Function.comp g f) x z","decl":"theorem Tendsto.comp {f : α → β} {g : β → γ} {x : Filter α} {y : Filter β} {z : Filter γ}\n    (hg : Tendsto g y z) (hf : Tendsto f x y) : Tendsto (g ∘ f) x z := fun _ hs => hf (hg hs)\n\n"}
{"name":"Filter.Tendsto.iterate","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nf : α → α\nl : Filter α\nh : Filter.Tendsto f l l\nn : Nat\n⊢ Filter.Tendsto (Nat.iterate f n) l l","decl":"protected theorem Tendsto.iterate {f : α → α} {l : Filter α} (h : Tendsto f l l) :\n    ∀ n, Tendsto (f^[n]) l l\n  | 0 => tendsto_id\n  | (n + 1) => (h.iterate n).comp h\n\n"}
{"name":"Filter.Tendsto.mono_left","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx y : Filter α\nz : Filter β\nhx : Filter.Tendsto f x z\nh : LE.le y x\n⊢ Filter.Tendsto f y z","decl":"theorem Tendsto.mono_left {f : α → β} {x y : Filter α} {z : Filter β} (hx : Tendsto f x z)\n    (h : y ≤ x) : Tendsto f y z :=\n  (map_mono h).trans hx\n\n"}
{"name":"Filter.Tendsto.mono_right","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx : Filter α\ny z : Filter β\nhy : Filter.Tendsto f x y\nhz : LE.le y z\n⊢ Filter.Tendsto f x z","decl":"theorem Tendsto.mono_right {f : α → β} {x : Filter α} {y z : Filter β} (hy : Tendsto f x y)\n    (hz : y ≤ z) : Tendsto f x z :=\n  le_trans hy hz\n\n"}
{"name":"Filter.Tendsto.neBot","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx : Filter α\ny : Filter β\nh : Filter.Tendsto f x y\nhx : x.NeBot\n⊢ y.NeBot","decl":"theorem Tendsto.neBot {f : α → β} {x : Filter α} {y : Filter β} (h : Tendsto f x y) [hx : NeBot x] :\n    NeBot y :=\n  (hx.map _).mono h\n\n"}
{"name":"Filter.tendsto_map","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx : Filter α\n⊢ Filter.Tendsto f x (Filter.map f x)","decl":"theorem tendsto_map {f : α → β} {x : Filter α} : Tendsto f x (map f x) :=\n  le_refl (map f x)\n\n"}
{"name":"Filter.tendsto_map'_iff","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : β → γ\ng : α → β\nx : Filter α\ny : Filter γ\n⊢ Iff (Filter.Tendsto f (Filter.map g x) y) (Filter.Tendsto (Function.comp f g) x y)","decl":"@[simp]\ntheorem tendsto_map'_iff {f : β → γ} {g : α → β} {x : Filter α} {y : Filter γ} :\n    Tendsto f (map g x) y ↔ Tendsto (f ∘ g) x y := by\n  rw [Tendsto, Tendsto, map_map]\n\n"}
{"name":"Filter.tendsto_map'","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : β → γ\ng : α → β\nx : Filter α\ny : Filter γ\na✝ : Filter.Tendsto (Function.comp f g) x y\n⊢ Filter.Tendsto f (Filter.map g x) y","decl":"alias ⟨_, tendsto_map'⟩ := tendsto_map'_iff\n\n"}
{"name":"Filter.tendsto_comap","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx : Filter β\n⊢ Filter.Tendsto f (Filter.comap f x) x","decl":"theorem tendsto_comap {f : α → β} {x : Filter β} : Tendsto f (comap f x) x :=\n  map_comap_le\n\n"}
{"name":"Filter.tendsto_comap_iff","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\ng : β → γ\na : Filter α\nc : Filter γ\n⊢ Iff (Filter.Tendsto f a (Filter.comap g c)) (Filter.Tendsto (Function.comp g f) a c)","decl":"@[simp]\ntheorem tendsto_comap_iff {f : α → β} {g : β → γ} {a : Filter α} {c : Filter γ} :\n    Tendsto f a (c.comap g) ↔ Tendsto (g ∘ f) a c :=\n  ⟨fun h => tendsto_comap.comp h, fun h => map_le_iff_le_comap.mp <| by rwa [map_map]⟩\n\n"}
{"name":"Filter.tendsto_comap'_iff","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : α → β\nf : Filter α\ng : Filter β\ni : γ → α\nh : Membership.mem f (Set.range i)\n⊢ Iff (Filter.Tendsto (Function.comp m i) (Filter.comap i f) g) (Filter.Tendsto m f g)","decl":"theorem tendsto_comap'_iff {m : α → β} {f : Filter α} {g : Filter β} {i : γ → α} (h : range i ∈ f) :\n    Tendsto (m ∘ i) (comap i f) g ↔ Tendsto m f g := by\n  rw [Tendsto, ← map_compose]\n  simp only [(· ∘ ·), map_comap_of_mem h, Tendsto]\n\n"}
{"name":"Filter.Tendsto.of_tendsto_comp","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\ng : β → γ\na : Filter α\nb : Filter β\nc : Filter γ\nhfg : Filter.Tendsto (Function.comp g f) a c\nhg : LE.le (Filter.comap g c) b\n⊢ Filter.Tendsto f a b","decl":"theorem Tendsto.of_tendsto_comp {f : α → β} {g : β → γ} {a : Filter α} {b : Filter β} {c : Filter γ}\n    (hfg : Tendsto (g ∘ f) a c) (hg : comap g c ≤ b) : Tendsto f a b := by\n  rw [tendsto_iff_comap] at hfg ⊢\n  calc\n    a ≤ comap (g ∘ f) c := hfg\n    _ ≤ comap f b := by simpa [comap_comap] using comap_mono hg\n\n"}
{"name":"Filter.comap_eq_of_inverse","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\nφ : α → β\nψ : β → α\neq : Eq (Function.comp ψ φ) id\nhφ : Filter.Tendsto φ f g\nhψ : Filter.Tendsto ψ g f\n⊢ Eq (Filter.comap φ g) f","decl":"theorem comap_eq_of_inverse {f : Filter α} {g : Filter β} {φ : α → β} (ψ : β → α) (eq : ψ ∘ φ = id)\n    (hφ : Tendsto φ f g) (hψ : Tendsto ψ g f) : comap φ g = f := by\n  refine ((comap_mono <| map_le_iff_le_comap.1 hψ).trans ?_).antisymm (map_le_iff_le_comap.1 hφ)\n  rw [comap_comap, eq, comap_id]\n\n"}
{"name":"Filter.map_eq_of_inverse","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\nφ : α → β\nψ : β → α\neq : Eq (Function.comp φ ψ) id\nhφ : Filter.Tendsto φ f g\nhψ : Filter.Tendsto ψ g f\n⊢ Eq (Filter.map φ f) g","decl":"theorem map_eq_of_inverse {f : Filter α} {g : Filter β} {φ : α → β} (ψ : β → α) (eq : φ ∘ ψ = id)\n    (hφ : Tendsto φ f g) (hψ : Tendsto ψ g f) : map φ f = g := by\n  refine le_antisymm hφ (le_trans ?_ (map_mono hψ))\n  rw [map_map, eq, map_id]\n\n"}
{"name":"Filter.tendsto_inf","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx : Filter α\ny₁ y₂ : Filter β\n⊢ Iff (Filter.Tendsto f x (Min.min y₁ y₂)) (And (Filter.Tendsto f x y₁) (Filter.Tendsto f x y₂))","decl":"theorem tendsto_inf {f : α → β} {x : Filter α} {y₁ y₂ : Filter β} :\n    Tendsto f x (y₁ ⊓ y₂) ↔ Tendsto f x y₁ ∧ Tendsto f x y₂ := by\n  simp only [Tendsto, le_inf_iff]\n\n"}
{"name":"Filter.tendsto_inf_left","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx₁ x₂ : Filter α\ny : Filter β\nh : Filter.Tendsto f x₁ y\n⊢ Filter.Tendsto f (Min.min x₁ x₂) y","decl":"theorem tendsto_inf_left {f : α → β} {x₁ x₂ : Filter α} {y : Filter β} (h : Tendsto f x₁ y) :\n    Tendsto f (x₁ ⊓ x₂) y :=\n  le_trans (map_mono inf_le_left) h\n\n"}
{"name":"Filter.tendsto_inf_right","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx₁ x₂ : Filter α\ny : Filter β\nh : Filter.Tendsto f x₂ y\n⊢ Filter.Tendsto f (Min.min x₁ x₂) y","decl":"theorem tendsto_inf_right {f : α → β} {x₁ x₂ : Filter α} {y : Filter β} (h : Tendsto f x₂ y) :\n    Tendsto f (x₁ ⊓ x₂) y :=\n  le_trans (map_mono inf_le_right) h\n\n"}
{"name":"Filter.Tendsto.inf","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx₁ x₂ : Filter α\ny₁ y₂ : Filter β\nh₁ : Filter.Tendsto f x₁ y₁\nh₂ : Filter.Tendsto f x₂ y₂\n⊢ Filter.Tendsto f (Min.min x₁ x₂) (Min.min y₁ y₂)","decl":"theorem Tendsto.inf {f : α → β} {x₁ x₂ : Filter α} {y₁ y₂ : Filter β} (h₁ : Tendsto f x₁ y₁)\n    (h₂ : Tendsto f x₂ y₂) : Tendsto f (x₁ ⊓ x₂) (y₁ ⊓ y₂) :=\n  tendsto_inf.2 ⟨tendsto_inf_left h₁, tendsto_inf_right h₂⟩\n\n"}
{"name":"Filter.tendsto_iInf","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nf : α → β\nx : Filter α\ny : ι → Filter β\n⊢ Iff (Filter.Tendsto f x (iInf fun i => y i)) (∀ (i : ι), Filter.Tendsto f x (y i))","decl":"@[simp]\ntheorem tendsto_iInf {f : α → β} {x : Filter α} {y : ι → Filter β} :\n    Tendsto f x (⨅ i, y i) ↔ ∀ i, Tendsto f x (y i) := by\n  simp only [Tendsto, le_iInf_iff]\n\n"}
{"name":"Filter.tendsto_iInf'","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nf : α → β\nx : ι → Filter α\ny : Filter β\ni : ι\nhi : Filter.Tendsto f (x i) y\n⊢ Filter.Tendsto f (iInf fun i => x i) y","decl":"theorem tendsto_iInf' {f : α → β} {x : ι → Filter α} {y : Filter β} (i : ι)\n    (hi : Tendsto f (x i) y) : Tendsto f (⨅ i, x i) y :=\n  hi.mono_left <| iInf_le _ _\n\n"}
{"name":"Filter.tendsto_iInf_iInf","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nf : α → β\nx : ι → Filter α\ny : ι → Filter β\nh : ∀ (i : ι), Filter.Tendsto f (x i) (y i)\n⊢ Filter.Tendsto f (iInf x) (iInf y)","decl":"theorem tendsto_iInf_iInf {f : α → β} {x : ι → Filter α} {y : ι → Filter β}\n    (h : ∀ i, Tendsto f (x i) (y i)) : Tendsto f (iInf x) (iInf y) :=\n  tendsto_iInf.2 fun i => tendsto_iInf' i (h i)\n\n"}
{"name":"Filter.tendsto_sup","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx₁ x₂ : Filter α\ny : Filter β\n⊢ Iff (Filter.Tendsto f (Max.max x₁ x₂) y) (And (Filter.Tendsto f x₁ y) (Filter.Tendsto f x₂ y))","decl":"@[simp]\ntheorem tendsto_sup {f : α → β} {x₁ x₂ : Filter α} {y : Filter β} :\n    Tendsto f (x₁ ⊔ x₂) y ↔ Tendsto f x₁ y ∧ Tendsto f x₂ y := by\n  simp only [Tendsto, map_sup, sup_le_iff]\n\n"}
{"name":"Filter.Tendsto.sup","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx₁ x₂ : Filter α\ny : Filter β\na✝¹ : Filter.Tendsto f x₁ y\na✝ : Filter.Tendsto f x₂ y\n⊢ Filter.Tendsto f (Max.max x₁ x₂) y","decl":"theorem Tendsto.sup {f : α → β} {x₁ x₂ : Filter α} {y : Filter β} :\n    Tendsto f x₁ y → Tendsto f x₂ y → Tendsto f (x₁ ⊔ x₂) y := fun h₁ h₂ => tendsto_sup.mpr ⟨h₁, h₂⟩\n\n"}
{"name":"Filter.Tendsto.sup_sup","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx₁ x₂ : Filter α\ny₁ y₂ : Filter β\nh₁ : Filter.Tendsto f x₁ y₁\nh₂ : Filter.Tendsto f x₂ y₂\n⊢ Filter.Tendsto f (Max.max x₁ x₂) (Max.max y₁ y₂)","decl":"theorem Tendsto.sup_sup {f : α → β} {x₁ x₂ : Filter α} {y₁ y₂ : Filter β}\n    (h₁ : Tendsto f x₁ y₁) (h₂ : Tendsto f x₂ y₂) : Tendsto f (x₁ ⊔ x₂) (y₁ ⊔ y₂) :=\n  tendsto_sup.mpr ⟨h₁.mono_right le_sup_left, h₂.mono_right le_sup_right⟩\n\n"}
{"name":"Filter.tendsto_iSup","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nf : α → β\nx : ι → Filter α\ny : Filter β\n⊢ Iff (Filter.Tendsto f (iSup fun i => x i) y) (∀ (i : ι), Filter.Tendsto f (x i) y)","decl":"@[simp]\ntheorem tendsto_iSup {f : α → β} {x : ι → Filter α} {y : Filter β} :\n    Tendsto f (⨆ i, x i) y ↔ ∀ i, Tendsto f (x i) y := by simp only [Tendsto, map_iSup, iSup_le_iff]\n\n"}
{"name":"Filter.tendsto_iSup_iSup","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nf : α → β\nx : ι → Filter α\ny : ι → Filter β\nh : ∀ (i : ι), Filter.Tendsto f (x i) (y i)\n⊢ Filter.Tendsto f (iSup x) (iSup y)","decl":"theorem tendsto_iSup_iSup {f : α → β} {x : ι → Filter α} {y : ι → Filter β}\n    (h : ∀ i, Tendsto f (x i) (y i)) : Tendsto f (iSup x) (iSup y) :=\n  tendsto_iSup.2 fun i => (h i).mono_right <| le_iSup _ _\n\n"}
{"name":"Filter.tendsto_principal","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nl : Filter α\ns : Set β\n⊢ Iff (Filter.Tendsto f l (Filter.principal s)) (Filter.Eventually (fun a => Membership.mem s (f a)) l)","decl":"@[simp] theorem tendsto_principal {f : α → β} {l : Filter α} {s : Set β} :\n    Tendsto f l (𝓟 s) ↔ ∀ᶠ a in l, f a ∈ s := by\n  simp only [Tendsto, le_principal_iff, mem_map', Filter.Eventually]\n\n-- Porting note: was a `simp` lemma\n"}
{"name":"Filter.tendsto_principal_principal","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nt : Set β\n⊢ Iff (Filter.Tendsto f (Filter.principal s) (Filter.principal t)) (∀ (a : α), Membership.mem s a → Membership.mem t (f a))","decl":"theorem tendsto_principal_principal {f : α → β} {s : Set α} {t : Set β} :\n    Tendsto f (𝓟 s) (𝓟 t) ↔ ∀ a ∈ s, f a ∈ t := by\n  simp only [tendsto_principal, eventually_principal]\n\n"}
{"name":"Filter.tendsto_pure","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : Filter α\nb : β\n⊢ Iff (Filter.Tendsto f a (Pure.pure b)) (Filter.Eventually (fun x => Eq (f x) b) a)","decl":"@[simp] theorem tendsto_pure {f : α → β} {a : Filter α} {b : β} :\n    Tendsto f a (pure b) ↔ ∀ᶠ x in a, f x = b := by\n  simp only [Tendsto, le_pure_iff, mem_map', mem_singleton_iff, Filter.Eventually]\n\n"}
{"name":"Filter.tendsto_pure_pure","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : α\n⊢ Filter.Tendsto f (Pure.pure a) (Pure.pure (f a))","decl":"theorem tendsto_pure_pure (f : α → β) (a : α) : Tendsto f (pure a) (pure (f a)) :=\n  tendsto_pure.2 rfl\n\n"}
{"name":"Filter.tendsto_const_pure","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\na : Filter α\nb : β\n⊢ Filter.Tendsto (fun x => b) a (Pure.pure b)","decl":"theorem tendsto_const_pure {a : Filter α} {b : β} : Tendsto (fun _ => b) a (pure b) :=\n  tendsto_pure.2 <| univ_mem' fun _ => rfl\n\n"}
{"name":"Filter.pure_le_iff","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\na : α\nl : Filter α\n⊢ Iff (LE.le (Pure.pure a) l) (∀ (s : Set α), Membership.mem l s → Membership.mem s a)","decl":"theorem pure_le_iff {a : α} {l : Filter α} : pure a ≤ l ↔ ∀ s ∈ l, a ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Filter.tendsto_pure_left","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : α\nl : Filter β\n⊢ Iff (Filter.Tendsto f (Pure.pure a) l) (∀ (s : Set β), Membership.mem l s → Membership.mem s (f a))","decl":"theorem tendsto_pure_left {f : α → β} {a : α} {l : Filter β} :\n    Tendsto f (pure a) l ↔ ∀ s ∈ l, f a ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Filter.map_inf_principal_preimage","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\nl : Filter α\n⊢ Eq (Filter.map f (Min.min l (Filter.principal (Set.preimage f s)))) (Min.min (Filter.map f l) (Filter.principal s))","decl":"@[simp]\ntheorem map_inf_principal_preimage {f : α → β} {s : Set β} {l : Filter α} :\n    map f (l ⊓ 𝓟 (f ⁻¹' s)) = map f l ⊓ 𝓟 s :=\n  Filter.ext fun t => by simp only [mem_map', mem_inf_principal, mem_setOf_eq, mem_preimage]\n\n"}
{"name":"Filter.Tendsto.not_tendsto","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : Filter α\nb₁ b₂ : Filter β\nhf : Filter.Tendsto f a b₁\ninst✝ : a.NeBot\nhb : Disjoint b₁ b₂\n⊢ Not (Filter.Tendsto f a b₂)","decl":"/-- If two filters are disjoint, then a function cannot tend to both of them along a non-trivial\nfilter. -/\ntheorem Tendsto.not_tendsto {f : α → β} {a : Filter α} {b₁ b₂ : Filter β} (hf : Tendsto f a b₁)\n    [NeBot a] (hb : Disjoint b₁ b₂) : ¬Tendsto f a b₂ := fun hf' =>\n  (tendsto_inf.2 ⟨hf, hf'⟩).neBot.ne hb.eq_bot\n\n"}
{"name":"Filter.Tendsto.if","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nl₁ : Filter α\nl₂ : Filter β\nf g : α → β\np : α → Prop\ninst✝ : (x : α) → Decidable (p x)\nh₀ : Filter.Tendsto f (Min.min l₁ (Filter.principal (setOf fun x => p x))) l₂\nh₁ : Filter.Tendsto g (Min.min l₁ (Filter.principal (setOf fun x => Not (p x)))) l₂\n⊢ Filter.Tendsto (fun x => ite (p x) (f x) (g x)) l₁ l₂","decl":"protected theorem Tendsto.if {l₁ : Filter α} {l₂ : Filter β} {f g : α → β} {p : α → Prop}\n    [∀ x, Decidable (p x)] (h₀ : Tendsto f (l₁ ⊓ 𝓟 { x | p x }) l₂)\n    (h₁ : Tendsto g (l₁ ⊓ 𝓟 { x | ¬p x }) l₂) :\n    Tendsto (fun x => if p x then f x else g x) l₁ l₂ := by\n  simp only [tendsto_def, mem_inf_principal] at *\n  intro s hs\n  filter_upwards [h₀ s hs, h₁ s hs] with x hp₀ hp₁\n  rw [mem_preimage]\n  split_ifs with h\n  exacts [hp₀ h, hp₁ h]\n\n"}
{"name":"Filter.Tendsto.if'","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_5\nβ : Type u_6\nl₁ : Filter α\nl₂ : Filter β\nf g : α → β\np : α → Prop\ninst✝ : DecidablePred p\nhf : Filter.Tendsto f l₁ l₂\nhg : Filter.Tendsto g l₁ l₂\n⊢ Filter.Tendsto (fun a => ite (p a) (f a) (g a)) l₁ l₂","decl":"protected theorem Tendsto.if' {α β : Type*} {l₁ : Filter α} {l₂ : Filter β} {f g : α → β}\n    {p : α → Prop} [DecidablePred p] (hf : Tendsto f l₁ l₂) (hg : Tendsto g l₁ l₂) :\n    Tendsto (fun a => if p a then f a else g a) l₁ l₂ :=\n  (tendsto_inf_left hf).if (tendsto_inf_left hg)\n\n"}
{"name":"Filter.Tendsto.piecewise","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nl₁ : Filter α\nl₂ : Filter β\nf g : α → β\ns : Set α\ninst✝ : (x : α) → Decidable (Membership.mem s x)\nh₀ : Filter.Tendsto f (Min.min l₁ (Filter.principal s)) l₂\nh₁ : Filter.Tendsto g (Min.min l₁ (Filter.principal (HasCompl.compl s))) l₂\n⊢ Filter.Tendsto (s.piecewise f g) l₁ l₂","decl":"protected theorem Tendsto.piecewise {l₁ : Filter α} {l₂ : Filter β} {f g : α → β} {s : Set α}\n    [∀ x, Decidable (x ∈ s)] (h₀ : Tendsto f (l₁ ⊓ 𝓟 s) l₂) (h₁ : Tendsto g (l₁ ⊓ 𝓟 sᶜ) l₂) :\n    Tendsto (piecewise s f g) l₁ l₂ :=\n  Tendsto.if h₀ h₁\n\n"}
{"name":"Set.MapsTo.tendsto","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh : Set.MapsTo f s t\n⊢ Filter.Tendsto f (Filter.principal s) (Filter.principal t)","decl":"theorem Set.MapsTo.tendsto {s : Set α} {t : Set β} {f : α → β} (h : MapsTo f s t) :\n    Filter.Tendsto f (𝓟 s) (𝓟 t) :=\n  Filter.tendsto_principal_principal.2 h\n\n"}
{"name":"Filter.EventuallyEq.comp_tendsto","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nl : Filter α\nf f' : α → β\nH : l.EventuallyEq f f'\ng : γ → α\nlc : Filter γ\nhg : Filter.Tendsto g lc l\n⊢ lc.EventuallyEq (Function.comp f g) (Function.comp f' g)","decl":"theorem Filter.EventuallyEq.comp_tendsto {l : Filter α} {f : α → β} {f' : α → β}\n    (H : f =ᶠ[l] f') {g : γ → α} {lc : Filter γ} (hg : Tendsto g lc l) :\n    f ∘ g =ᶠ[lc] f' ∘ g :=\n  hg.eventually H\n\n"}
{"name":"Filter.map_mapsTo_Iic_iff_tendsto","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Filter α\nG : Filter β\nm : α → β\n⊢ Iff (Set.MapsTo (Filter.map m) (Set.Iic F) (Set.Iic G)) (Filter.Tendsto m F G)","decl":"theorem Filter.map_mapsTo_Iic_iff_tendsto {m : α → β} :\n    MapsTo (map m) (Iic F) (Iic G) ↔ Tendsto m F G :=\n  ⟨fun hm ↦ hm right_mem_Iic, fun hm _ ↦ hm.mono_left⟩\n\n"}
{"name":"Filter.Tendsto.map_mapsTo_Iic","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Filter α\nG : Filter β\nm : α → β\na✝ : Filter.Tendsto m F G\n⊢ Set.MapsTo (Filter.map m) (Set.Iic F) (Set.Iic G)","decl":"alias ⟨_, Filter.Tendsto.map_mapsTo_Iic⟩ := Filter.map_mapsTo_Iic_iff_tendsto\n\n"}
{"name":"Filter.map_mapsTo_Iic_iff_mapsTo","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nm : α → β\n⊢ Iff (Set.MapsTo (Filter.map m) (Set.Iic (Filter.principal s)) (Set.Iic (Filter.principal t))) (Set.MapsTo m s t)","decl":"theorem Filter.map_mapsTo_Iic_iff_mapsTo {s : Set α} {t : Set β} {m : α → β} :\n    MapsTo (map m) (Iic <| 𝓟 s) (Iic <| 𝓟 t) ↔ MapsTo m s t := by\n  rw [map_mapsTo_Iic_iff_tendsto, tendsto_principal_principal, MapsTo]\n\n"}
{"name":"Set.MapsTo.filter_map_Iic","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nm : α → β\na✝ : Set.MapsTo m s t\n⊢ Set.MapsTo (Filter.map m) (Set.Iic (Filter.principal s)) (Set.Iic (Filter.principal t))","decl":"alias ⟨_, Set.MapsTo.filter_map_Iic⟩ := Filter.map_mapsTo_Iic_iff_mapsTo\n"}
