{"name":"Filter.tendsto_def","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nlâ‚ : Filter Î±\nlâ‚‚ : Filter Î²\nâŠ¢ Iff (Filter.Tendsto f lâ‚ lâ‚‚) (âˆ€ (s : Set Î²), Membership.mem lâ‚‚ s â†’ Membership.mem lâ‚ (Set.preimage f s))","decl":"theorem tendsto_def {f : Î± â†’ Î²} {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} :\n    Tendsto f lâ‚ lâ‚‚ â†” âˆ€ s âˆˆ lâ‚‚, f â»Â¹' s âˆˆ lâ‚ :=\n  Iff.rfl\n\n"}
{"name":"Filter.tendsto_iff_eventually","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nlâ‚ : Filter Î±\nlâ‚‚ : Filter Î²\nâŠ¢ Iff (Filter.Tendsto f lâ‚ lâ‚‚) (âˆ€ â¦ƒp : Î² â†’ Propâ¦„, Filter.Eventually (fun y => p y) lâ‚‚ â†’ Filter.Eventually (fun x => p (f x)) lâ‚)","decl":"theorem tendsto_iff_eventually {f : Î± â†’ Î²} {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} :\n    Tendsto f lâ‚ lâ‚‚ â†” âˆ€ â¦ƒp : Î² â†’ Propâ¦„, (âˆ€á¶  y in lâ‚‚, p y) â†’ âˆ€á¶  x in lâ‚, p (f x) :=\n  Iff.rfl\n\n"}
{"name":"Filter.tendsto_iff_forall_eventually_mem","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nlâ‚ : Filter Î±\nlâ‚‚ : Filter Î²\nâŠ¢ Iff (Filter.Tendsto f lâ‚ lâ‚‚) (âˆ€ (s : Set Î²), Membership.mem lâ‚‚ s â†’ Filter.Eventually (fun x => Membership.mem s (f x)) lâ‚)","decl":"theorem tendsto_iff_forall_eventually_mem {f : Î± â†’ Î²} {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} :\n    Tendsto f lâ‚ lâ‚‚ â†” âˆ€ s âˆˆ lâ‚‚, âˆ€á¶  x in lâ‚, f x âˆˆ s :=\n  Iff.rfl\n\n"}
{"name":"Filter.Tendsto.eventually_mem","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nlâ‚ : Filter Î±\nlâ‚‚ : Filter Î²\ns : Set Î²\nhf : Filter.Tendsto f lâ‚ lâ‚‚\nh : Membership.mem lâ‚‚ s\nâŠ¢ Filter.Eventually (fun x => Membership.mem s (f x)) lâ‚","decl":"lemma Tendsto.eventually_mem {f : Î± â†’ Î²} {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} {s : Set Î²}\n    (hf : Tendsto f lâ‚ lâ‚‚) (h : s âˆˆ lâ‚‚) : âˆ€á¶  x in lâ‚, f x âˆˆ s :=\n  hf h\n\n"}
{"name":"Filter.Tendsto.eventually","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nlâ‚ : Filter Î±\nlâ‚‚ : Filter Î²\np : Î² â†’ Prop\nhf : Filter.Tendsto f lâ‚ lâ‚‚\nh : Filter.Eventually (fun y => p y) lâ‚‚\nâŠ¢ Filter.Eventually (fun x => p (f x)) lâ‚","decl":"theorem Tendsto.eventually {f : Î± â†’ Î²} {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} {p : Î² â†’ Prop}\n    (hf : Tendsto f lâ‚ lâ‚‚) (h : âˆ€á¶  y in lâ‚‚, p y) : âˆ€á¶  x in lâ‚, p (f x) :=\n  hf h\n\n"}
{"name":"Filter.not_tendsto_iff_exists_frequently_nmem","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nlâ‚ : Filter Î±\nlâ‚‚ : Filter Î²\nâŠ¢ Iff (Not (Filter.Tendsto f lâ‚ lâ‚‚)) (Exists fun s => And (Membership.mem lâ‚‚ s) (Filter.Frequently (fun x => Not (Membership.mem s (f x))) lâ‚))","decl":"theorem not_tendsto_iff_exists_frequently_nmem {f : Î± â†’ Î²} {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} :\n    Â¬Tendsto f lâ‚ lâ‚‚ â†” âˆƒ s âˆˆ lâ‚‚, âˆƒá¶  x in lâ‚, f x âˆ‰ s := by\n  simp only [tendsto_iff_forall_eventually_mem, not_forall, exists_prop, not_eventually]\n\n"}
{"name":"Filter.Tendsto.frequently","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nlâ‚ : Filter Î±\nlâ‚‚ : Filter Î²\np : Î² â†’ Prop\nhf : Filter.Tendsto f lâ‚ lâ‚‚\nh : Filter.Frequently (fun x => p (f x)) lâ‚\nâŠ¢ Filter.Frequently (fun y => p y) lâ‚‚","decl":"theorem Tendsto.frequently {f : Î± â†’ Î²} {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} {p : Î² â†’ Prop}\n    (hf : Tendsto f lâ‚ lâ‚‚) (h : âˆƒá¶  x in lâ‚, p (f x)) : âˆƒá¶  y in lâ‚‚, p y :=\n  mt hf.eventually h\n\n"}
{"name":"Filter.Tendsto.frequently_map","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nlâ‚ : Filter Î±\nlâ‚‚ : Filter Î²\np : Î± â†’ Prop\nq : Î² â†’ Prop\nf : Î± â†’ Î²\nc : Filter.Tendsto f lâ‚ lâ‚‚\nw : âˆ€ (x : Î±), p x â†’ q (f x)\nh : Filter.Frequently (fun x => p x) lâ‚\nâŠ¢ Filter.Frequently (fun y => q y) lâ‚‚","decl":"theorem Tendsto.frequently_map {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} {p : Î± â†’ Prop} {q : Î² â†’ Prop}\n    (f : Î± â†’ Î²) (c : Filter.Tendsto f lâ‚ lâ‚‚) (w : âˆ€ x, p x â†’ q (f x)) (h : âˆƒá¶  x in lâ‚, p x) :\n    âˆƒá¶  y in lâ‚‚, q y :=\n  c.frequently (h.mono w)\n\n"}
{"name":"Filter.tendsto_bot","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nl : Filter Î²\nâŠ¢ Filter.Tendsto f Bot.bot l","decl":"@[simp]\ntheorem tendsto_bot {f : Î± â†’ Î²} {l : Filter Î²} : Tendsto f âŠ¥ l := by simp [Tendsto]\n\n"}
{"name":"Filter.Tendsto.of_neBot_imp","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nla : Filter Î±\nlb : Filter Î²\nh : la.NeBot â†’ Filter.Tendsto f la lb\nâŠ¢ Filter.Tendsto f la lb","decl":"theorem Tendsto.of_neBot_imp {f : Î± â†’ Î²} {la : Filter Î±} {lb : Filter Î²}\n    (h : NeBot la â†’ Tendsto f la lb) : Tendsto f la lb := by\n  rcases eq_or_neBot la with rfl | hla\n  Â· exact tendsto_bot\n  Â· exact h hla\n\n"}
{"name":"Filter.tendsto_top","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nl : Filter Î±\nâŠ¢ Filter.Tendsto f l Top.top","decl":"@[simp] theorem tendsto_top {f : Î± â†’ Î²} {l : Filter Î±} : Tendsto f l âŠ¤ := le_top\n\n"}
{"name":"Filter.le_map_of_right_inverse","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nmab : Î± â†’ Î²\nmba : Î² â†’ Î±\nf : Filter Î±\ng : Filter Î²\nhâ‚ : g.EventuallyEq (Function.comp mab mba) id\nhâ‚‚ : Filter.Tendsto mba g f\nâŠ¢ LE.le g (Filter.map mab f)","decl":"theorem le_map_of_right_inverse {mab : Î± â†’ Î²} {mba : Î² â†’ Î±} {f : Filter Î±} {g : Filter Î²}\n    (hâ‚ : mab âˆ˜ mba =á¶ [g] id) (hâ‚‚ : Tendsto mba g f) : g â‰¤ map mab f := by\n  rw [â† @map_id _ g, â† map_congr hâ‚, â† map_map]\n  exact map_mono hâ‚‚\n\n"}
{"name":"Filter.tendsto_of_isEmpty","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : IsEmpty Î±\nf : Î± â†’ Î²\nla : Filter Î±\nlb : Filter Î²\nâŠ¢ Filter.Tendsto f la lb","decl":"theorem tendsto_of_isEmpty [IsEmpty Î±] {f : Î± â†’ Î²} {la : Filter Î±} {lb : Filter Î²} :\n    Tendsto f la lb := by simp only [filter_eq_bot_of_isEmpty la, tendsto_bot]\n\n"}
{"name":"Filter.eventuallyEq_of_left_inv_of_right_inv","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ngâ‚ gâ‚‚ : Î² â†’ Î±\nfa : Filter Î±\nfb : Filter Î²\nhleft : Filter.Eventually (fun x => Eq (gâ‚ (f x)) x) fa\nhright : Filter.Eventually (fun y => Eq (f (gâ‚‚ y)) y) fb\nhtendsto : Filter.Tendsto gâ‚‚ fb fa\nâŠ¢ fb.EventuallyEq gâ‚ gâ‚‚","decl":"theorem eventuallyEq_of_left_inv_of_right_inv {f : Î± â†’ Î²} {gâ‚ gâ‚‚ : Î² â†’ Î±} {fa : Filter Î±}\n    {fb : Filter Î²} (hleft : âˆ€á¶  x in fa, gâ‚ (f x) = x) (hright : âˆ€á¶  y in fb, f (gâ‚‚ y) = y)\n    (htendsto : Tendsto gâ‚‚ fb fa) : gâ‚ =á¶ [fb] gâ‚‚ :=\n  (htendsto.eventually hleft).mp <| hright.mono fun _ hr hl => (congr_arg gâ‚ hr.symm).trans hl\n\n"}
{"name":"Filter.tendsto_iff_comap","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nlâ‚ : Filter Î±\nlâ‚‚ : Filter Î²\nâŠ¢ Iff (Filter.Tendsto f lâ‚ lâ‚‚) (LE.le lâ‚ (Filter.comap f lâ‚‚))","decl":"theorem tendsto_iff_comap {f : Î± â†’ Î²} {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} :\n    Tendsto f lâ‚ lâ‚‚ â†” lâ‚ â‰¤ lâ‚‚.comap f :=\n  map_le_iff_le_comap\n\n"}
{"name":"Filter.Tendsto.le_comap","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nlâ‚ : Filter Î±\nlâ‚‚ : Filter Î²\naâœ : Filter.Tendsto f lâ‚ lâ‚‚\nâŠ¢ LE.le lâ‚ (Filter.comap f lâ‚‚)","decl":"alias âŸ¨Tendsto.le_comap, _âŸ© := tendsto_iff_comap\n\n"}
{"name":"Filter.Tendsto.disjoint","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nlaâ‚ laâ‚‚ : Filter Î±\nlbâ‚ lbâ‚‚ : Filter Î²\nhâ‚ : Filter.Tendsto f laâ‚ lbâ‚\nhd : Disjoint lbâ‚ lbâ‚‚\nhâ‚‚ : Filter.Tendsto f laâ‚‚ lbâ‚‚\nâŠ¢ Disjoint laâ‚ laâ‚‚","decl":"protected theorem Tendsto.disjoint {f : Î± â†’ Î²} {laâ‚ laâ‚‚ : Filter Î±} {lbâ‚ lbâ‚‚ : Filter Î²}\n    (hâ‚ : Tendsto f laâ‚ lbâ‚) (hd : Disjoint lbâ‚ lbâ‚‚) (hâ‚‚ : Tendsto f laâ‚‚ lbâ‚‚) : Disjoint laâ‚ laâ‚‚ :=\n  (disjoint_comap hd).mono hâ‚.le_comap hâ‚‚.le_comap\n\n"}
{"name":"Filter.tendsto_congr'","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nfâ‚ fâ‚‚ : Î± â†’ Î²\nlâ‚ : Filter Î±\nlâ‚‚ : Filter Î²\nhl : lâ‚.EventuallyEq fâ‚ fâ‚‚\nâŠ¢ Iff (Filter.Tendsto fâ‚ lâ‚ lâ‚‚) (Filter.Tendsto fâ‚‚ lâ‚ lâ‚‚)","decl":"theorem tendsto_congr' {fâ‚ fâ‚‚ : Î± â†’ Î²} {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} (hl : fâ‚ =á¶ [lâ‚] fâ‚‚) :\n    Tendsto fâ‚ lâ‚ lâ‚‚ â†” Tendsto fâ‚‚ lâ‚ lâ‚‚ := by rw [Tendsto, Tendsto, map_congr hl]\n\n"}
{"name":"Filter.Tendsto.congr'","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nfâ‚ fâ‚‚ : Î± â†’ Î²\nlâ‚ : Filter Î±\nlâ‚‚ : Filter Î²\nhl : lâ‚.EventuallyEq fâ‚ fâ‚‚\nh : Filter.Tendsto fâ‚ lâ‚ lâ‚‚\nâŠ¢ Filter.Tendsto fâ‚‚ lâ‚ lâ‚‚","decl":"theorem Tendsto.congr' {fâ‚ fâ‚‚ : Î± â†’ Î²} {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} (hl : fâ‚ =á¶ [lâ‚] fâ‚‚)\n    (h : Tendsto fâ‚ lâ‚ lâ‚‚) : Tendsto fâ‚‚ lâ‚ lâ‚‚ :=\n  (tendsto_congr' hl).1 h\n\n"}
{"name":"Filter.tendsto_congr","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nfâ‚ fâ‚‚ : Î± â†’ Î²\nlâ‚ : Filter Î±\nlâ‚‚ : Filter Î²\nh : âˆ€ (x : Î±), Eq (fâ‚ x) (fâ‚‚ x)\nâŠ¢ Iff (Filter.Tendsto fâ‚ lâ‚ lâ‚‚) (Filter.Tendsto fâ‚‚ lâ‚ lâ‚‚)","decl":"theorem tendsto_congr {fâ‚ fâ‚‚ : Î± â†’ Î²} {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} (h : âˆ€ x, fâ‚ x = fâ‚‚ x) :\n    Tendsto fâ‚ lâ‚ lâ‚‚ â†” Tendsto fâ‚‚ lâ‚ lâ‚‚ :=\n  tendsto_congr' (univ_mem' h)\n\n"}
{"name":"Filter.Tendsto.congr","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nfâ‚ fâ‚‚ : Î± â†’ Î²\nlâ‚ : Filter Î±\nlâ‚‚ : Filter Î²\nh : âˆ€ (x : Î±), Eq (fâ‚ x) (fâ‚‚ x)\naâœ : Filter.Tendsto fâ‚ lâ‚ lâ‚‚\nâŠ¢ Filter.Tendsto fâ‚‚ lâ‚ lâ‚‚","decl":"theorem Tendsto.congr {fâ‚ fâ‚‚ : Î± â†’ Î²} {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} (h : âˆ€ x, fâ‚ x = fâ‚‚ x) :\n    Tendsto fâ‚ lâ‚ lâ‚‚ â†’ Tendsto fâ‚‚ lâ‚ lâ‚‚ :=\n  (tendsto_congr h).1\n\n"}
{"name":"Filter.tendsto_id'","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nx y : Filter Î±\nâŠ¢ Iff (Filter.Tendsto id x y) (LE.le x y)","decl":"theorem tendsto_id' {x y : Filter Î±} : Tendsto id x y â†” x â‰¤ y :=\n  Iff.rfl\n\n"}
{"name":"Filter.tendsto_id","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nx : Filter Î±\nâŠ¢ Filter.Tendsto id x x","decl":"theorem tendsto_id {x : Filter Î±} : Tendsto id x x :=\n  le_refl x\n\n"}
{"name":"Filter.Tendsto.comp","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Î± â†’ Î²\ng : Î² â†’ Î³\nx : Filter Î±\ny : Filter Î²\nz : Filter Î³\nhg : Filter.Tendsto g y z\nhf : Filter.Tendsto f x y\nâŠ¢ Filter.Tendsto (Function.comp g f) x z","decl":"theorem Tendsto.comp {f : Î± â†’ Î²} {g : Î² â†’ Î³} {x : Filter Î±} {y : Filter Î²} {z : Filter Î³}\n    (hg : Tendsto g y z) (hf : Tendsto f x y) : Tendsto (g âˆ˜ f) x z := fun _ hs => hf (hg hs)\n\n"}
{"name":"Filter.Tendsto.iterate","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nf : Î± â†’ Î±\nl : Filter Î±\nh : Filter.Tendsto f l l\nn : Nat\nâŠ¢ Filter.Tendsto (Nat.iterate f n) l l","decl":"protected theorem Tendsto.iterate {f : Î± â†’ Î±} {l : Filter Î±} (h : Tendsto f l l) :\n    âˆ€ n, Tendsto (f^[n]) l l\n  | 0 => tendsto_id\n  | (n + 1) => (h.iterate n).comp h\n\n"}
{"name":"Filter.Tendsto.mono_left","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nx y : Filter Î±\nz : Filter Î²\nhx : Filter.Tendsto f x z\nh : LE.le y x\nâŠ¢ Filter.Tendsto f y z","decl":"theorem Tendsto.mono_left {f : Î± â†’ Î²} {x y : Filter Î±} {z : Filter Î²} (hx : Tendsto f x z)\n    (h : y â‰¤ x) : Tendsto f y z :=\n  (map_mono h).trans hx\n\n"}
{"name":"Filter.Tendsto.mono_right","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nx : Filter Î±\ny z : Filter Î²\nhy : Filter.Tendsto f x y\nhz : LE.le y z\nâŠ¢ Filter.Tendsto f x z","decl":"theorem Tendsto.mono_right {f : Î± â†’ Î²} {x : Filter Î±} {y z : Filter Î²} (hy : Tendsto f x y)\n    (hz : y â‰¤ z) : Tendsto f x z :=\n  le_trans hy hz\n\n"}
{"name":"Filter.Tendsto.neBot","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nx : Filter Î±\ny : Filter Î²\nh : Filter.Tendsto f x y\nhx : x.NeBot\nâŠ¢ y.NeBot","decl":"theorem Tendsto.neBot {f : Î± â†’ Î²} {x : Filter Î±} {y : Filter Î²} (h : Tendsto f x y) [hx : NeBot x] :\n    NeBot y :=\n  (hx.map _).mono h\n\n"}
{"name":"Filter.tendsto_map","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nx : Filter Î±\nâŠ¢ Filter.Tendsto f x (Filter.map f x)","decl":"theorem tendsto_map {f : Î± â†’ Î²} {x : Filter Î±} : Tendsto f x (map f x) :=\n  le_refl (map f x)\n\n"}
{"name":"Filter.tendsto_map'_iff","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Î² â†’ Î³\ng : Î± â†’ Î²\nx : Filter Î±\ny : Filter Î³\nâŠ¢ Iff (Filter.Tendsto f (Filter.map g x) y) (Filter.Tendsto (Function.comp f g) x y)","decl":"@[simp]\ntheorem tendsto_map'_iff {f : Î² â†’ Î³} {g : Î± â†’ Î²} {x : Filter Î±} {y : Filter Î³} :\n    Tendsto f (map g x) y â†” Tendsto (f âˆ˜ g) x y := by\n  rw [Tendsto, Tendsto, map_map]\n\n"}
{"name":"Filter.tendsto_map'","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Î² â†’ Î³\ng : Î± â†’ Î²\nx : Filter Î±\ny : Filter Î³\naâœ : Filter.Tendsto (Function.comp f g) x y\nâŠ¢ Filter.Tendsto f (Filter.map g x) y","decl":"alias âŸ¨_, tendsto_map'âŸ© := tendsto_map'_iff\n\n"}
{"name":"Filter.tendsto_comap","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nx : Filter Î²\nâŠ¢ Filter.Tendsto f (Filter.comap f x) x","decl":"theorem tendsto_comap {f : Î± â†’ Î²} {x : Filter Î²} : Tendsto f (comap f x) x :=\n  map_comap_le\n\n"}
{"name":"Filter.tendsto_comap_iff","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Î± â†’ Î²\ng : Î² â†’ Î³\na : Filter Î±\nc : Filter Î³\nâŠ¢ Iff (Filter.Tendsto f a (Filter.comap g c)) (Filter.Tendsto (Function.comp g f) a c)","decl":"@[simp]\ntheorem tendsto_comap_iff {f : Î± â†’ Î²} {g : Î² â†’ Î³} {a : Filter Î±} {c : Filter Î³} :\n    Tendsto f a (c.comap g) â†” Tendsto (g âˆ˜ f) a c :=\n  âŸ¨fun h => tendsto_comap.comp h, fun h => map_le_iff_le_comap.mp <| by rwa [map_map]âŸ©\n\n"}
{"name":"Filter.tendsto_comap'_iff","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nm : Î± â†’ Î²\nf : Filter Î±\ng : Filter Î²\ni : Î³ â†’ Î±\nh : Membership.mem f (Set.range i)\nâŠ¢ Iff (Filter.Tendsto (Function.comp m i) (Filter.comap i f) g) (Filter.Tendsto m f g)","decl":"theorem tendsto_comap'_iff {m : Î± â†’ Î²} {f : Filter Î±} {g : Filter Î²} {i : Î³ â†’ Î±} (h : range i âˆˆ f) :\n    Tendsto (m âˆ˜ i) (comap i f) g â†” Tendsto m f g := by\n  rw [Tendsto, â† map_compose]\n  simp only [(Â· âˆ˜ Â·), map_comap_of_mem h, Tendsto]\n\n"}
{"name":"Filter.Tendsto.of_tendsto_comp","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Î± â†’ Î²\ng : Î² â†’ Î³\na : Filter Î±\nb : Filter Î²\nc : Filter Î³\nhfg : Filter.Tendsto (Function.comp g f) a c\nhg : LE.le (Filter.comap g c) b\nâŠ¢ Filter.Tendsto f a b","decl":"theorem Tendsto.of_tendsto_comp {f : Î± â†’ Î²} {g : Î² â†’ Î³} {a : Filter Î±} {b : Filter Î²} {c : Filter Î³}\n    (hfg : Tendsto (g âˆ˜ f) a c) (hg : comap g c â‰¤ b) : Tendsto f a b := by\n  rw [tendsto_iff_comap] at hfg âŠ¢\n  calc\n    a â‰¤ comap (g âˆ˜ f) c := hfg\n    _ â‰¤ comap f b := by simpa [comap_comap] using comap_mono hg\n\n"}
{"name":"Filter.comap_eq_of_inverse","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\ng : Filter Î²\nÏ† : Î± â†’ Î²\nÏˆ : Î² â†’ Î±\neq : Eq (Function.comp Ïˆ Ï†) id\nhÏ† : Filter.Tendsto Ï† f g\nhÏˆ : Filter.Tendsto Ïˆ g f\nâŠ¢ Eq (Filter.comap Ï† g) f","decl":"theorem comap_eq_of_inverse {f : Filter Î±} {g : Filter Î²} {Ï† : Î± â†’ Î²} (Ïˆ : Î² â†’ Î±) (eq : Ïˆ âˆ˜ Ï† = id)\n    (hÏ† : Tendsto Ï† f g) (hÏˆ : Tendsto Ïˆ g f) : comap Ï† g = f := by\n  refine ((comap_mono <| map_le_iff_le_comap.1 hÏˆ).trans ?_).antisymm (map_le_iff_le_comap.1 hÏ†)\n  rw [comap_comap, eq, comap_id]\n\n"}
{"name":"Filter.map_eq_of_inverse","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\ng : Filter Î²\nÏ† : Î± â†’ Î²\nÏˆ : Î² â†’ Î±\neq : Eq (Function.comp Ï† Ïˆ) id\nhÏ† : Filter.Tendsto Ï† f g\nhÏˆ : Filter.Tendsto Ïˆ g f\nâŠ¢ Eq (Filter.map Ï† f) g","decl":"theorem map_eq_of_inverse {f : Filter Î±} {g : Filter Î²} {Ï† : Î± â†’ Î²} (Ïˆ : Î² â†’ Î±) (eq : Ï† âˆ˜ Ïˆ = id)\n    (hÏ† : Tendsto Ï† f g) (hÏˆ : Tendsto Ïˆ g f) : map Ï† f = g := by\n  refine le_antisymm hÏ† (le_trans ?_ (map_mono hÏˆ))\n  rw [map_map, eq, map_id]\n\n"}
{"name":"Filter.tendsto_inf","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nx : Filter Î±\nyâ‚ yâ‚‚ : Filter Î²\nâŠ¢ Iff (Filter.Tendsto f x (Min.min yâ‚ yâ‚‚)) (And (Filter.Tendsto f x yâ‚) (Filter.Tendsto f x yâ‚‚))","decl":"theorem tendsto_inf {f : Î± â†’ Î²} {x : Filter Î±} {yâ‚ yâ‚‚ : Filter Î²} :\n    Tendsto f x (yâ‚ âŠ“ yâ‚‚) â†” Tendsto f x yâ‚ âˆ§ Tendsto f x yâ‚‚ := by\n  simp only [Tendsto, le_inf_iff]\n\n"}
{"name":"Filter.tendsto_inf_left","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nxâ‚ xâ‚‚ : Filter Î±\ny : Filter Î²\nh : Filter.Tendsto f xâ‚ y\nâŠ¢ Filter.Tendsto f (Min.min xâ‚ xâ‚‚) y","decl":"theorem tendsto_inf_left {f : Î± â†’ Î²} {xâ‚ xâ‚‚ : Filter Î±} {y : Filter Î²} (h : Tendsto f xâ‚ y) :\n    Tendsto f (xâ‚ âŠ“ xâ‚‚) y :=\n  le_trans (map_mono inf_le_left) h\n\n"}
{"name":"Filter.tendsto_inf_right","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nxâ‚ xâ‚‚ : Filter Î±\ny : Filter Î²\nh : Filter.Tendsto f xâ‚‚ y\nâŠ¢ Filter.Tendsto f (Min.min xâ‚ xâ‚‚) y","decl":"theorem tendsto_inf_right {f : Î± â†’ Î²} {xâ‚ xâ‚‚ : Filter Î±} {y : Filter Î²} (h : Tendsto f xâ‚‚ y) :\n    Tendsto f (xâ‚ âŠ“ xâ‚‚) y :=\n  le_trans (map_mono inf_le_right) h\n\n"}
{"name":"Filter.Tendsto.inf","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nxâ‚ xâ‚‚ : Filter Î±\nyâ‚ yâ‚‚ : Filter Î²\nhâ‚ : Filter.Tendsto f xâ‚ yâ‚\nhâ‚‚ : Filter.Tendsto f xâ‚‚ yâ‚‚\nâŠ¢ Filter.Tendsto f (Min.min xâ‚ xâ‚‚) (Min.min yâ‚ yâ‚‚)","decl":"theorem Tendsto.inf {f : Î± â†’ Î²} {xâ‚ xâ‚‚ : Filter Î±} {yâ‚ yâ‚‚ : Filter Î²} (hâ‚ : Tendsto f xâ‚ yâ‚)\n    (hâ‚‚ : Tendsto f xâ‚‚ yâ‚‚) : Tendsto f (xâ‚ âŠ“ xâ‚‚) (yâ‚ âŠ“ yâ‚‚) :=\n  tendsto_inf.2 âŸ¨tendsto_inf_left hâ‚, tendsto_inf_right hâ‚‚âŸ©\n\n"}
{"name":"Filter.tendsto_iInf","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\nf : Î± â†’ Î²\nx : Filter Î±\ny : Î¹ â†’ Filter Î²\nâŠ¢ Iff (Filter.Tendsto f x (iInf fun i => y i)) (âˆ€ (i : Î¹), Filter.Tendsto f x (y i))","decl":"@[simp]\ntheorem tendsto_iInf {f : Î± â†’ Î²} {x : Filter Î±} {y : Î¹ â†’ Filter Î²} :\n    Tendsto f x (â¨… i, y i) â†” âˆ€ i, Tendsto f x (y i) := by\n  simp only [Tendsto, le_iInf_iff]\n\n"}
{"name":"Filter.tendsto_iInf'","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\nf : Î± â†’ Î²\nx : Î¹ â†’ Filter Î±\ny : Filter Î²\ni : Î¹\nhi : Filter.Tendsto f (x i) y\nâŠ¢ Filter.Tendsto f (iInf fun i => x i) y","decl":"theorem tendsto_iInf' {f : Î± â†’ Î²} {x : Î¹ â†’ Filter Î±} {y : Filter Î²} (i : Î¹)\n    (hi : Tendsto f (x i) y) : Tendsto f (â¨… i, x i) y :=\n  hi.mono_left <| iInf_le _ _\n\n"}
{"name":"Filter.tendsto_iInf_iInf","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\nf : Î± â†’ Î²\nx : Î¹ â†’ Filter Î±\ny : Î¹ â†’ Filter Î²\nh : âˆ€ (i : Î¹), Filter.Tendsto f (x i) (y i)\nâŠ¢ Filter.Tendsto f (iInf x) (iInf y)","decl":"theorem tendsto_iInf_iInf {f : Î± â†’ Î²} {x : Î¹ â†’ Filter Î±} {y : Î¹ â†’ Filter Î²}\n    (h : âˆ€ i, Tendsto f (x i) (y i)) : Tendsto f (iInf x) (iInf y) :=\n  tendsto_iInf.2 fun i => tendsto_iInf' i (h i)\n\n"}
{"name":"Filter.tendsto_sup","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nxâ‚ xâ‚‚ : Filter Î±\ny : Filter Î²\nâŠ¢ Iff (Filter.Tendsto f (Max.max xâ‚ xâ‚‚) y) (And (Filter.Tendsto f xâ‚ y) (Filter.Tendsto f xâ‚‚ y))","decl":"@[simp]\ntheorem tendsto_sup {f : Î± â†’ Î²} {xâ‚ xâ‚‚ : Filter Î±} {y : Filter Î²} :\n    Tendsto f (xâ‚ âŠ” xâ‚‚) y â†” Tendsto f xâ‚ y âˆ§ Tendsto f xâ‚‚ y := by\n  simp only [Tendsto, map_sup, sup_le_iff]\n\n"}
{"name":"Filter.Tendsto.sup","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nxâ‚ xâ‚‚ : Filter Î±\ny : Filter Î²\naâœÂ¹ : Filter.Tendsto f xâ‚ y\naâœ : Filter.Tendsto f xâ‚‚ y\nâŠ¢ Filter.Tendsto f (Max.max xâ‚ xâ‚‚) y","decl":"theorem Tendsto.sup {f : Î± â†’ Î²} {xâ‚ xâ‚‚ : Filter Î±} {y : Filter Î²} :\n    Tendsto f xâ‚ y â†’ Tendsto f xâ‚‚ y â†’ Tendsto f (xâ‚ âŠ” xâ‚‚) y := fun hâ‚ hâ‚‚ => tendsto_sup.mpr âŸ¨hâ‚, hâ‚‚âŸ©\n\n"}
{"name":"Filter.Tendsto.sup_sup","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nxâ‚ xâ‚‚ : Filter Î±\nyâ‚ yâ‚‚ : Filter Î²\nhâ‚ : Filter.Tendsto f xâ‚ yâ‚\nhâ‚‚ : Filter.Tendsto f xâ‚‚ yâ‚‚\nâŠ¢ Filter.Tendsto f (Max.max xâ‚ xâ‚‚) (Max.max yâ‚ yâ‚‚)","decl":"theorem Tendsto.sup_sup {f : Î± â†’ Î²} {xâ‚ xâ‚‚ : Filter Î±} {yâ‚ yâ‚‚ : Filter Î²}\n    (hâ‚ : Tendsto f xâ‚ yâ‚) (hâ‚‚ : Tendsto f xâ‚‚ yâ‚‚) : Tendsto f (xâ‚ âŠ” xâ‚‚) (yâ‚ âŠ” yâ‚‚) :=\n  tendsto_sup.mpr âŸ¨hâ‚.mono_right le_sup_left, hâ‚‚.mono_right le_sup_rightâŸ©\n\n"}
{"name":"Filter.tendsto_iSup","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\nf : Î± â†’ Î²\nx : Î¹ â†’ Filter Î±\ny : Filter Î²\nâŠ¢ Iff (Filter.Tendsto f (iSup fun i => x i) y) (âˆ€ (i : Î¹), Filter.Tendsto f (x i) y)","decl":"@[simp]\ntheorem tendsto_iSup {f : Î± â†’ Î²} {x : Î¹ â†’ Filter Î±} {y : Filter Î²} :\n    Tendsto f (â¨† i, x i) y â†” âˆ€ i, Tendsto f (x i) y := by simp only [Tendsto, map_iSup, iSup_le_iff]\n\n"}
{"name":"Filter.tendsto_iSup_iSup","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\nf : Î± â†’ Î²\nx : Î¹ â†’ Filter Î±\ny : Î¹ â†’ Filter Î²\nh : âˆ€ (i : Î¹), Filter.Tendsto f (x i) (y i)\nâŠ¢ Filter.Tendsto f (iSup x) (iSup y)","decl":"theorem tendsto_iSup_iSup {f : Î± â†’ Î²} {x : Î¹ â†’ Filter Î±} {y : Î¹ â†’ Filter Î²}\n    (h : âˆ€ i, Tendsto f (x i) (y i)) : Tendsto f (iSup x) (iSup y) :=\n  tendsto_iSup.2 fun i => (h i).mono_right <| le_iSup _ _\n\n"}
{"name":"Filter.tendsto_principal","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nl : Filter Î±\ns : Set Î²\nâŠ¢ Iff (Filter.Tendsto f l (Filter.principal s)) (Filter.Eventually (fun a => Membership.mem s (f a)) l)","decl":"@[simp] theorem tendsto_principal {f : Î± â†’ Î²} {l : Filter Î±} {s : Set Î²} :\n    Tendsto f l (ğ“Ÿ s) â†” âˆ€á¶  a in l, f a âˆˆ s := by\n  simp only [Tendsto, le_principal_iff, mem_map', Filter.Eventually]\n\n-- Porting note: was a `simp` lemma\n"}
{"name":"Filter.tendsto_principal_principal","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î±\nt : Set Î²\nâŠ¢ Iff (Filter.Tendsto f (Filter.principal s) (Filter.principal t)) (âˆ€ (a : Î±), Membership.mem s a â†’ Membership.mem t (f a))","decl":"theorem tendsto_principal_principal {f : Î± â†’ Î²} {s : Set Î±} {t : Set Î²} :\n    Tendsto f (ğ“Ÿ s) (ğ“Ÿ t) â†” âˆ€ a âˆˆ s, f a âˆˆ t := by\n  simp only [tendsto_principal, eventually_principal]\n\n"}
{"name":"Filter.tendsto_pure","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\na : Filter Î±\nb : Î²\nâŠ¢ Iff (Filter.Tendsto f a (Pure.pure b)) (Filter.Eventually (fun x => Eq (f x) b) a)","decl":"@[simp] theorem tendsto_pure {f : Î± â†’ Î²} {a : Filter Î±} {b : Î²} :\n    Tendsto f a (pure b) â†” âˆ€á¶  x in a, f x = b := by\n  simp only [Tendsto, le_pure_iff, mem_map', mem_singleton_iff, Filter.Eventually]\n\n"}
{"name":"Filter.tendsto_pure_pure","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\na : Î±\nâŠ¢ Filter.Tendsto f (Pure.pure a) (Pure.pure (f a))","decl":"theorem tendsto_pure_pure (f : Î± â†’ Î²) (a : Î±) : Tendsto f (pure a) (pure (f a)) :=\n  tendsto_pure.2 rfl\n\n"}
{"name":"Filter.tendsto_const_pure","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\na : Filter Î±\nb : Î²\nâŠ¢ Filter.Tendsto (fun x => b) a (Pure.pure b)","decl":"theorem tendsto_const_pure {a : Filter Î±} {b : Î²} : Tendsto (fun _ => b) a (pure b) :=\n  tendsto_pure.2 <| univ_mem' fun _ => rfl\n\n"}
{"name":"Filter.pure_le_iff","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\na : Î±\nl : Filter Î±\nâŠ¢ Iff (LE.le (Pure.pure a) l) (âˆ€ (s : Set Î±), Membership.mem l s â†’ Membership.mem s a)","decl":"theorem pure_le_iff {a : Î±} {l : Filter Î±} : pure a â‰¤ l â†” âˆ€ s âˆˆ l, a âˆˆ s :=\n  Iff.rfl\n\n"}
{"name":"Filter.tendsto_pure_left","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\na : Î±\nl : Filter Î²\nâŠ¢ Iff (Filter.Tendsto f (Pure.pure a) l) (âˆ€ (s : Set Î²), Membership.mem l s â†’ Membership.mem s (f a))","decl":"theorem tendsto_pure_left {f : Î± â†’ Î²} {a : Î±} {l : Filter Î²} :\n    Tendsto f (pure a) l â†” âˆ€ s âˆˆ l, f a âˆˆ s :=\n  Iff.rfl\n\n"}
{"name":"Filter.map_inf_principal_preimage","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Set Î²\nl : Filter Î±\nâŠ¢ Eq (Filter.map f (Min.min l (Filter.principal (Set.preimage f s)))) (Min.min (Filter.map f l) (Filter.principal s))","decl":"@[simp]\ntheorem map_inf_principal_preimage {f : Î± â†’ Î²} {s : Set Î²} {l : Filter Î±} :\n    map f (l âŠ“ ğ“Ÿ (f â»Â¹' s)) = map f l âŠ“ ğ“Ÿ s :=\n  Filter.ext fun t => by simp only [mem_map', mem_inf_principal, mem_setOf_eq, mem_preimage]\n\n"}
{"name":"Filter.Tendsto.not_tendsto","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\na : Filter Î±\nbâ‚ bâ‚‚ : Filter Î²\nhf : Filter.Tendsto f a bâ‚\ninstâœ : a.NeBot\nhb : Disjoint bâ‚ bâ‚‚\nâŠ¢ Not (Filter.Tendsto f a bâ‚‚)","decl":"/-- If two filters are disjoint, then a function cannot tend to both of them along a non-trivial\nfilter. -/\ntheorem Tendsto.not_tendsto {f : Î± â†’ Î²} {a : Filter Î±} {bâ‚ bâ‚‚ : Filter Î²} (hf : Tendsto f a bâ‚)\n    [NeBot a] (hb : Disjoint bâ‚ bâ‚‚) : Â¬Tendsto f a bâ‚‚ := fun hf' =>\n  (tendsto_inf.2 âŸ¨hf, hf'âŸ©).neBot.ne hb.eq_bot\n\n"}
{"name":"Filter.Tendsto.if","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nlâ‚ : Filter Î±\nlâ‚‚ : Filter Î²\nf g : Î± â†’ Î²\np : Î± â†’ Prop\ninstâœ : (x : Î±) â†’ Decidable (p x)\nhâ‚€ : Filter.Tendsto f (Min.min lâ‚ (Filter.principal (setOf fun x => p x))) lâ‚‚\nhâ‚ : Filter.Tendsto g (Min.min lâ‚ (Filter.principal (setOf fun x => Not (p x)))) lâ‚‚\nâŠ¢ Filter.Tendsto (fun x => ite (p x) (f x) (g x)) lâ‚ lâ‚‚","decl":"protected theorem Tendsto.if {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} {f g : Î± â†’ Î²} {p : Î± â†’ Prop}\n    [âˆ€ x, Decidable (p x)] (hâ‚€ : Tendsto f (lâ‚ âŠ“ ğ“Ÿ { x | p x }) lâ‚‚)\n    (hâ‚ : Tendsto g (lâ‚ âŠ“ ğ“Ÿ { x | Â¬p x }) lâ‚‚) :\n    Tendsto (fun x => if p x then f x else g x) lâ‚ lâ‚‚ := by\n  simp only [tendsto_def, mem_inf_principal] at *\n  intro s hs\n  filter_upwards [hâ‚€ s hs, hâ‚ s hs] with x hpâ‚€ hpâ‚\n  rw [mem_preimage]\n  split_ifs with h\n  exacts [hpâ‚€ h, hpâ‚ h]\n\n"}
{"name":"Filter.Tendsto.if'","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_5\nÎ² : Type u_6\nlâ‚ : Filter Î±\nlâ‚‚ : Filter Î²\nf g : Î± â†’ Î²\np : Î± â†’ Prop\ninstâœ : DecidablePred p\nhf : Filter.Tendsto f lâ‚ lâ‚‚\nhg : Filter.Tendsto g lâ‚ lâ‚‚\nâŠ¢ Filter.Tendsto (fun a => ite (p a) (f a) (g a)) lâ‚ lâ‚‚","decl":"protected theorem Tendsto.if' {Î± Î² : Type*} {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} {f g : Î± â†’ Î²}\n    {p : Î± â†’ Prop} [DecidablePred p] (hf : Tendsto f lâ‚ lâ‚‚) (hg : Tendsto g lâ‚ lâ‚‚) :\n    Tendsto (fun a => if p a then f a else g a) lâ‚ lâ‚‚ :=\n  (tendsto_inf_left hf).if (tendsto_inf_left hg)\n\n"}
{"name":"Filter.Tendsto.piecewise","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nlâ‚ : Filter Î±\nlâ‚‚ : Filter Î²\nf g : Î± â†’ Î²\ns : Set Î±\ninstâœ : (x : Î±) â†’ Decidable (Membership.mem s x)\nhâ‚€ : Filter.Tendsto f (Min.min lâ‚ (Filter.principal s)) lâ‚‚\nhâ‚ : Filter.Tendsto g (Min.min lâ‚ (Filter.principal (HasCompl.compl s))) lâ‚‚\nâŠ¢ Filter.Tendsto (s.piecewise f g) lâ‚ lâ‚‚","decl":"protected theorem Tendsto.piecewise {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} {f g : Î± â†’ Î²} {s : Set Î±}\n    [âˆ€ x, Decidable (x âˆˆ s)] (hâ‚€ : Tendsto f (lâ‚ âŠ“ ğ“Ÿ s) lâ‚‚) (hâ‚ : Tendsto g (lâ‚ âŠ“ ğ“Ÿ sá¶œ) lâ‚‚) :\n    Tendsto (piecewise s f g) lâ‚ lâ‚‚ :=\n  Tendsto.if hâ‚€ hâ‚\n\n"}
{"name":"Set.MapsTo.tendsto","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nt : Set Î²\nf : Î± â†’ Î²\nh : Set.MapsTo f s t\nâŠ¢ Filter.Tendsto f (Filter.principal s) (Filter.principal t)","decl":"theorem Set.MapsTo.tendsto {s : Set Î±} {t : Set Î²} {f : Î± â†’ Î²} (h : MapsTo f s t) :\n    Filter.Tendsto f (ğ“Ÿ s) (ğ“Ÿ t) :=\n  Filter.tendsto_principal_principal.2 h\n\n"}
{"name":"Filter.EventuallyEq.comp_tendsto","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nl : Filter Î±\nf f' : Î± â†’ Î²\nH : l.EventuallyEq f f'\ng : Î³ â†’ Î±\nlc : Filter Î³\nhg : Filter.Tendsto g lc l\nâŠ¢ lc.EventuallyEq (Function.comp f g) (Function.comp f' g)","decl":"theorem Filter.EventuallyEq.comp_tendsto {l : Filter Î±} {f : Î± â†’ Î²} {f' : Î± â†’ Î²}\n    (H : f =á¶ [l] f') {g : Î³ â†’ Î±} {lc : Filter Î³} (hg : Tendsto g lc l) :\n    f âˆ˜ g =á¶ [lc] f' âˆ˜ g :=\n  hg.eventually H\n\n"}
{"name":"Filter.map_mapsTo_Iic_iff_tendsto","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Filter Î±\nG : Filter Î²\nm : Î± â†’ Î²\nâŠ¢ Iff (Set.MapsTo (Filter.map m) (Set.Iic F) (Set.Iic G)) (Filter.Tendsto m F G)","decl":"theorem Filter.map_mapsTo_Iic_iff_tendsto {m : Î± â†’ Î²} :\n    MapsTo (map m) (Iic F) (Iic G) â†” Tendsto m F G :=\n  âŸ¨fun hm â†¦ hm right_mem_Iic, fun hm _ â†¦ hm.mono_leftâŸ©\n\n"}
{"name":"Filter.Tendsto.map_mapsTo_Iic","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Filter Î±\nG : Filter Î²\nm : Î± â†’ Î²\naâœ : Filter.Tendsto m F G\nâŠ¢ Set.MapsTo (Filter.map m) (Set.Iic F) (Set.Iic G)","decl":"alias âŸ¨_, Filter.Tendsto.map_mapsTo_IicâŸ© := Filter.map_mapsTo_Iic_iff_tendsto\n\n"}
{"name":"Filter.map_mapsTo_Iic_iff_mapsTo","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nt : Set Î²\nm : Î± â†’ Î²\nâŠ¢ Iff (Set.MapsTo (Filter.map m) (Set.Iic (Filter.principal s)) (Set.Iic (Filter.principal t))) (Set.MapsTo m s t)","decl":"theorem Filter.map_mapsTo_Iic_iff_mapsTo {s : Set Î±} {t : Set Î²} {m : Î± â†’ Î²} :\n    MapsTo (map m) (Iic <| ğ“Ÿ s) (Iic <| ğ“Ÿ t) â†” MapsTo m s t := by\n  rw [map_mapsTo_Iic_iff_tendsto, tendsto_principal_principal, MapsTo]\n\n"}
{"name":"Set.MapsTo.filter_map_Iic","module":"Mathlib.Order.Filter.Tendsto","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nt : Set Î²\nm : Î± â†’ Î²\naâœ : Set.MapsTo m s t\nâŠ¢ Set.MapsTo (Filter.map m) (Set.Iic (Filter.principal s)) (Set.Iic (Filter.principal t))","decl":"alias âŸ¨_, Set.MapsTo.filter_map_IicâŸ© := Filter.map_mapsTo_Iic_iff_mapsTo\n"}
