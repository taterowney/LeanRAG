{"name":"ComplexShape.Embedding.boundaryGE","module":"Mathlib.Algebra.Homology.Embedding.Boundary","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ni' : ι'\nj : ι\nhj : c'.Rel i' (e.f j)\nhi' : ∀ (i : ι), Ne (e.f i) i'\n⊢ e.BoundaryGE j","decl":"lemma boundaryGE {i' : ι'} {j : ι} (hj : c'.Rel i' (e.f j)) (hi' : ∀ i, e.f i ≠ i') :\n    e.BoundaryGE j := by\n  constructor\n  · simpa only [c'.prev_eq' hj] using hj\n  · intro i hi\n    apply hi' i\n    rw [← c'.prev_eq' hj, c'.prev_eq' hi]\n\n"}
{"name":"ComplexShape.Embedding.not_boundaryGE_next","module":"Mathlib.Algebra.Homology.Embedding.Boundary","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ninst✝ : e.IsRelIff\nj k : ι\nhk : c.Rel j k\n⊢ Not (e.BoundaryGE k)","decl":"lemma not_boundaryGE_next [e.IsRelIff] {j k : ι} (hk : c.Rel j k) :\n    ¬ e.BoundaryGE k := by\n  dsimp [BoundaryGE]\n  simp only [not_and, not_forall, not_not]\n  intro\n  exact ⟨j, by simpa only [e.rel_iff] using hk⟩\n\n"}
{"name":"ComplexShape.Embedding.not_boundaryGE_next'","module":"Mathlib.Algebra.Homology.Embedding.Boundary","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ninst✝ : e.IsRelIff\nj k : ι\nhj : Not (e.BoundaryGE j)\nhk : Eq (c.next j) k\n⊢ Not (e.BoundaryGE k)","decl":"lemma not_boundaryGE_next' [e.IsRelIff] {j k : ι} (hj : ¬ e.BoundaryGE j) (hk : c.next j = k) :\n    ¬ e.BoundaryGE k := by\n  by_cases hjk : c.Rel j k\n  · exact e.not_boundaryGE_next hjk\n  · subst hk\n    simpa only [c.next_eq_self j hjk] using hj\n\n"}
{"name":"ComplexShape.Embedding.BoundaryGE.not_mem","module":"Mathlib.Algebra.Homology.Embedding.Boundary","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\nj : ι\nhj : e.BoundaryGE j\ni' : ι'\nhi' : c'.Rel i' (e.f j)\na : ι\n⊢ Ne (e.f a) i'","decl":"variable {e} in\nlemma BoundaryGE.not_mem {j : ι} (hj : e.BoundaryGE j) {i' : ι'} (hi' : c'.Rel i' (e.f j))\n    (a : ι) : e.f a ≠ i' := fun ha =>\n  hj.2 a (by simpa only [ha] using hi')\n\n"}
{"name":"ComplexShape.Embedding.prev_f_of_not_boundaryGE","module":"Mathlib.Algebra.Homology.Embedding.Boundary","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ninst✝ : e.IsRelIff\ni j : ι\nhij : Eq (c.prev j) i\nhj : Not (e.BoundaryGE j)\n⊢ Eq (c'.prev (e.f j)) (e.f i)","decl":"lemma prev_f_of_not_boundaryGE [e.IsRelIff] {i j : ι} (hij : c.prev j = i)\n    (hj : ¬ e.BoundaryGE j) :\n    c'.prev (e.f j) = e.f i := by\n  by_cases hij' : c.Rel i j\n  · exact c'.prev_eq' (by simpa only [e.rel_iff] using hij')\n  · obtain rfl : j = i := by\n      simpa only [c.prev_eq_self j (by simpa only [hij] using hij')] using hij\n    apply c'.prev_eq_self\n    intro hj'\n    simp only [BoundaryGE, not_and, not_forall, not_not] at hj\n    obtain ⟨i, hi⟩ := hj hj'\n    rw [e.rel_iff] at hi\n    rw [c.prev_eq' hi] at hij\n    exact hij' (by simpa only [hij] using hi)\n\n"}
{"name":"ComplexShape.Embedding.BoundaryGE.false_of_isTruncLE","module":"Mathlib.Algebra.Homology.Embedding.Boundary","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\nj : ι\nhj : e.BoundaryGE j\ninst✝ : e.IsTruncLE\n⊢ False","decl":"variable {e} in\nlemma BoundaryGE.false_of_isTruncLE {j : ι} (hj : e.BoundaryGE j) [e.IsTruncLE] : False := by\n  obtain ⟨i, hi⟩ := e.mem_prev hj.1\n  exact hj.2 i (by simpa only [hi] using hj.1)\n\n"}
{"name":"ComplexShape.Embedding.boundaryLE","module":"Mathlib.Algebra.Homology.Embedding.Boundary","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\nk' : ι'\nj : ι\nhj : c'.Rel (e.f j) k'\nhk' : ∀ (i : ι), Ne (e.f i) k'\n⊢ e.BoundaryLE j","decl":"lemma boundaryLE {k' : ι'} {j : ι} (hj : c'.Rel (e.f j) k') (hk' : ∀ i, e.f i ≠ k') :\n    e.BoundaryLE j := by\n  constructor\n  · simpa only [c'.next_eq' hj] using hj\n  · intro k hk\n    apply hk' k\n    rw [← c'.next_eq' hj, c'.next_eq' hk]\n\n"}
{"name":"ComplexShape.Embedding.not_boundaryLE_prev","module":"Mathlib.Algebra.Homology.Embedding.Boundary","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ninst✝ : e.IsRelIff\ni j : ι\nhi : c.Rel i j\n⊢ Not (e.BoundaryLE i)","decl":"lemma not_boundaryLE_prev [e.IsRelIff] {i j : ι} (hi : c.Rel i j) :\n    ¬ e.BoundaryLE i := by\n  dsimp [BoundaryLE]\n  simp only [not_and, not_forall, not_not]\n  intro\n  exact ⟨j, by simpa only [e.rel_iff] using hi⟩\n\n"}
{"name":"ComplexShape.Embedding.not_boundaryLE_prev'","module":"Mathlib.Algebra.Homology.Embedding.Boundary","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ninst✝ : e.IsRelIff\ni j : ι\nhj : Not (e.BoundaryLE j)\nhk : Eq (c.prev j) i\n⊢ Not (e.BoundaryLE i)","decl":"lemma not_boundaryLE_prev' [e.IsRelIff] {i j : ι} (hj : ¬ e.BoundaryLE j) (hk : c.prev j = i) :\n    ¬ e.BoundaryLE i := by\n  by_cases hij : c.Rel i j\n  · exact e.not_boundaryLE_prev hij\n  · subst hk\n    simpa only [c.prev_eq_self j hij] using hj\n\n"}
{"name":"ComplexShape.Embedding.BoundaryLE.not_mem","module":"Mathlib.Algebra.Homology.Embedding.Boundary","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\nj : ι\nhj : e.BoundaryLE j\nk' : ι'\nhk' : c'.Rel (e.f j) k'\na : ι\n⊢ Ne (e.f a) k'","decl":"variable {e} in\nlemma BoundaryLE.not_mem {j : ι} (hj : e.BoundaryLE j) {k' : ι'} (hk' : c'.Rel (e.f j) k')\n    (a : ι) : e.f a ≠ k' := fun ha =>\n  hj.2 a (by simpa only [ha] using hk')\n\n"}
{"name":"ComplexShape.Embedding.next_f_of_not_boundaryLE","module":"Mathlib.Algebra.Homology.Embedding.Boundary","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ninst✝ : e.IsRelIff\nj k : ι\nhjk : Eq (c.next j) k\nhj : Not (e.BoundaryLE j)\n⊢ Eq (c'.next (e.f j)) (e.f k)","decl":"lemma next_f_of_not_boundaryLE [e.IsRelIff] {j k : ι} (hjk : c.next j = k)\n    (hj : ¬ e.BoundaryLE j) :\n    c'.next (e.f j) = e.f k := by\n  by_cases hjk' : c.Rel j k\n  · exact c'.next_eq' (by simpa only [e.rel_iff] using hjk')\n  · obtain rfl : j = k := by\n      simpa only [c.next_eq_self j (by simpa only [hjk] using hjk')] using hjk\n    apply c'.next_eq_self\n    intro hj'\n    simp only [BoundaryLE, not_and, not_forall, not_not] at hj\n    obtain ⟨k, hk⟩ := hj hj'\n    rw [e.rel_iff] at hk\n    rw [c.next_eq' hk] at hjk\n    exact hjk' (by simpa only [hjk] using hk)\n\n"}
{"name":"ComplexShape.Embedding.next_f","module":"Mathlib.Algebra.Homology.Embedding.Boundary","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ninst✝ : e.IsTruncGE\nj k : ι\nhjk : Eq (c.next j) k\n⊢ Eq (c'.next (e.f j)) (e.f k)","decl":"lemma next_f [e.IsTruncGE] {j k : ι} (hjk : c.next j = k) : c'.next (e.f j) = e.f k := by\n  by_cases hj : c'.Rel (e.f j) (c'.next (e.f j))\n  · obtain ⟨k', hk'⟩ := e.mem_next hj\n    rw [← hk', e.rel_iff] at hj\n    rw [← hk', ← c.next_eq' hj, hjk]\n  · rw [c'.next_eq_self _ hj, ← hjk, c.next_eq_self j]\n    intro hj'\n    apply hj\n    rw [← e.rel_iff] at hj'\n    simpa only [c'.next_eq' hj'] using hj'\n\n"}
{"name":"ComplexShape.Embedding.prev_f","module":"Mathlib.Algebra.Homology.Embedding.Boundary","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ninst✝ : e.IsTruncLE\ni j : ι\nhij : Eq (c.prev j) i\n⊢ Eq (c'.prev (e.f j)) (e.f i)","decl":"lemma prev_f [e.IsTruncLE] {i j : ι} (hij : c.prev j = i) : c'.prev (e.f j) = e.f i :=\n  e.op.next_f hij\n\n"}
{"name":"ComplexShape.Embedding.BoundaryLE.false_of_isTruncGE","module":"Mathlib.Algebra.Homology.Embedding.Boundary","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\nj : ι\nhj : e.BoundaryLE j\ninst✝ : e.IsTruncGE\n⊢ False","decl":"variable {e} in\nlemma BoundaryLE.false_of_isTruncGE {j : ι} (hj : e.BoundaryLE j) [e.IsTruncGE] : False := by\n  obtain ⟨k, hk⟩ := e.mem_next hj.1\n  exact hj.2 k (by simpa only [hk] using hj.1)\n\n"}
{"name":"ComplexShape.Embedding.op_boundaryLE_iff","module":"Mathlib.Algebra.Homology.Embedding.Boundary","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\nj : ι\n⊢ Iff (e.op.BoundaryLE j) (e.BoundaryGE j)","decl":"@[simp] lemma op_boundaryLE_iff {j : ι} : e.op.BoundaryLE j ↔ e.BoundaryGE j := by rfl\n"}
{"name":"ComplexShape.Embedding.op_boundaryGE_iff","module":"Mathlib.Algebra.Homology.Embedding.Boundary","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\nj : ι\n⊢ Iff (e.op.BoundaryGE j) (e.BoundaryLE j)","decl":"@[simp] lemma op_boundaryGE_iff {j : ι} : e.op.BoundaryGE j ↔ e.BoundaryLE j := by rfl\n\n"}
{"name":"ComplexShape.boundaryGE_embeddingUpIntGE_iff","module":"Mathlib.Algebra.Homology.Embedding.Boundary","initialProofState":"p : Int\nn : Nat\n⊢ Iff ((ComplexShape.embeddingUpIntGE p).BoundaryGE n) (Eq n 0)","decl":"lemma boundaryGE_embeddingUpIntGE_iff (p : ℤ) (n : ℕ) :\n    (embeddingUpIntGE p).BoundaryGE n ↔ n = 0 := by\n  constructor\n  · intro h\n    obtain _|n := n\n    · rfl\n    · have := h.2 n\n      dsimp at this\n      omega\n  · rintro rfl\n    constructor\n    · simp\n    · intro i hi\n      dsimp at hi\n      omega\n\n"}
{"name":"ComplexShape.boundaryLE_embeddingUpIntLE_iff","module":"Mathlib.Algebra.Homology.Embedding.Boundary","initialProofState":"p : Int\nn : Nat\n⊢ Iff ((ComplexShape.embeddingUpIntGE p).BoundaryGE n) (Eq n 0)","decl":"lemma boundaryLE_embeddingUpIntLE_iff (p : ℤ) (n : ℕ) :\n    (embeddingUpIntGE p).BoundaryGE n ↔ n = 0 := by\n  constructor\n  · intro h\n    obtain _|n := n\n    · rfl\n    · have := h.2 n\n      dsimp at this\n      omega\n  · rintro rfl\n    constructor\n    · simp\n    · intro i hi\n      dsimp at hi\n      omega\n\n"}
