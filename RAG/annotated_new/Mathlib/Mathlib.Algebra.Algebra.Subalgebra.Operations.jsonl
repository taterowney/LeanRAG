{"name":"AlgHom.ker_rangeRestrict","module":"Mathlib.Algebra.Algebra.Subalgebra.Operations","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\nf : AlgHom R A B\n⊢ Eq (RingHom.ker f.rangeRestrict) (RingHom.ker f)","decl":"theorem ker_rangeRestrict (f : A →ₐ[R] B) : RingHom.ker f.rangeRestrict = RingHom.ker f :=\n  Ideal.ext fun _ ↦ Subtype.ext_iff\n\n"}
{"name":"Subalgebra.mem_of_finset_sum_eq_one_of_pow_smul_mem","module":"Mathlib.Algebra.Algebra.Subalgebra.Operations","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nS' : Subalgebra R S\nι : Type u_3\nι' : Finset ι\ns l : ι → S\ne : Eq (ι'.sum fun i => HMul.hMul (l i) (s i)) 1\nhs : ∀ (i : ι), Membership.mem S' (s i)\nhl : ∀ (i : ι), Membership.mem S' (l i)\nx : S\nH : ∀ (i : ι), Exists fun n => Membership.mem S' (HSMul.hSMul (HPow.hPow (s i) n) x)\n⊢ Membership.mem S' x","decl":"/-- Suppose we are given `∑ i, lᵢ * sᵢ = 1` ∈ `S`, and `S'` a subalgebra of `S` that contains\n`lᵢ` and `sᵢ`. To check that an `x : S` falls in `S'`, we only need to show that\n`sᵢ ^ n • x ∈ S'` for some `n` for each `sᵢ`. -/\ntheorem mem_of_finset_sum_eq_one_of_pow_smul_mem\n    {ι : Type*} (ι' : Finset ι) (s : ι → S) (l : ι → S)\n    (e : ∑ i ∈ ι', l i * s i = 1) (hs : ∀ i, s i ∈ S') (hl : ∀ i, l i ∈ S') (x : S)\n    (H : ∀ i, ∃ n : ℕ, (s i ^ n : S) • x ∈ S') : x ∈ S' := by\n  -- Porting note: needed to add this instance\n  let _i : Algebra { x // x ∈ S' } { x // x ∈ S' } := Algebra.id _\n  suffices x ∈ Subalgebra.toSubmodule (Algebra.ofId S' S).range by\n    obtain ⟨x, rfl⟩ := this\n    exact x.2\n  choose n hn using H\n  let s' : ι → S' := fun x => ⟨s x, hs x⟩\n  let l' : ι → S' := fun x => ⟨l x, hl x⟩\n  have e' : ∑ i ∈ ι', l' i * s' i = 1 := by\n    ext\n    show S'.subtype (∑ i ∈ ι', l' i * s' i) = 1\n    simpa only [map_sum, map_mul] using e\n  have : Ideal.span (s' '' ι') = ⊤ := by\n    rw [Ideal.eq_top_iff_one, ← e']\n    apply sum_mem\n    intros i hi\n    exact Ideal.mul_mem_left _ _ <| Ideal.subset_span <| Set.mem_image_of_mem s' hi\n  let N := ι'.sup n\n  have hN := Ideal.span_pow_eq_top _ this N\n  apply (Algebra.ofId S' S).range.toSubmodule.mem_of_span_top_of_smul_mem _ hN\n  rintro ⟨_, _, ⟨i, hi, rfl⟩, rfl⟩\n  change s' i ^ N • x ∈ _\n  rw [← tsub_add_cancel_of_le (show n i ≤ N from Finset.le_sup hi), pow_add, mul_smul]\n  refine Submodule.smul_mem _ (⟨_, pow_mem (hs i) _⟩ : S') ?_\n  exact ⟨⟨_, hn i⟩, rfl⟩\n\n"}
{"name":"Subalgebra.mem_of_span_eq_top_of_smul_pow_mem","module":"Mathlib.Algebra.Algebra.Subalgebra.Operations","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nS' : Subalgebra R S\ns : Set S\nl : Finsupp (↑s) S\nhs : Eq ((Finsupp.linearCombination S Subtype.val) l) 1\nhs' : HasSubset.Subset s ↑S'\nhl : ∀ (i : ↑s), Membership.mem S' (l i)\nx : S\nH : ∀ (r : ↑s), Exists fun n => Membership.mem S' (HSMul.hSMul (HPow.hPow (↑r) n) x)\n⊢ Membership.mem S' x","decl":"theorem mem_of_span_eq_top_of_smul_pow_mem\n    (s : Set S) (l : s →₀ S) (hs : Finsupp.linearCombination S ((↑) : s → S) l = 1)\n    (hs' : s ⊆ S') (hl : ∀ i, l i ∈ S') (x : S) (H : ∀ r : s, ∃ n : ℕ, (r : S) ^ n • x ∈ S') :\n    x ∈ S' :=\n  mem_of_finset_sum_eq_one_of_pow_smul_mem S' l.support (↑) l hs (fun x => hs' x.2) hl x H\n\n"}
