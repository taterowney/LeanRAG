{"name":"MeasureTheory.VectorMeasure.mk.inj","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_3\ninst✝² : MeasurableSpace α\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nmeasureOf'✝ : Set α → M\nempty'✝ : Eq (measureOf'✝ EmptyCollection.emptyCollection) 0\nnot_measurable'✝ : ∀ ⦃i : Set α⦄, Not (MeasurableSet i) → Eq (measureOf'✝ i) 0\nm_iUnion'✝ : ∀ ⦃f : Nat → Set α⦄, (∀ (i : Nat), MeasurableSet (f i)) → Pairwise (Function.onFun Disjoint f) → HasSum (fun i => measureOf'✝ (f i)) (measureOf'✝ (Set.iUnion fun i => f i))\nmeasureOf' : Set α → M\nempty' : Eq (measureOf' EmptyCollection.emptyCollection) 0\nnot_measurable' : ∀ ⦃i : Set α⦄, Not (MeasurableSet i) → Eq (measureOf' i) 0\nm_iUnion' : ∀ ⦃f : Nat → Set α⦄, (∀ (i : Nat), MeasurableSet (f i)) → Pairwise (Function.onFun Disjoint f) → HasSum (fun i => measureOf' (f i)) (measureOf' (Set.iUnion fun i => f i))\nx✝ : Eq { measureOf' := measureOf'✝, empty' := empty'✝, not_measurable' := not_measurable'✝, m_iUnion' := m_iUnion'✝ } { measureOf' := measureOf', empty' := empty', not_measurable' := not_measurable', m_iUnion' := m_iUnion' }\n⊢ Eq measureOf'✝ measureOf'","decl":"/-- A vector measure on a measurable space `α` is a σ-additive `M`-valued function (for some `M`\nan add monoid) such that the empty set and non-measurable sets are mapped to zero. -/\nstructure VectorMeasure (α : Type*) [MeasurableSpace α] (M : Type*) [AddCommMonoid M]\n    [TopologicalSpace M] where\n  measureOf' : Set α → M\n  empty' : measureOf' ∅ = 0\n  not_measurable' ⦃i : Set α⦄ : ¬MeasurableSet i → measureOf' i = 0\n  m_iUnion' ⦃f : ℕ → Set α⦄ : (∀ i, MeasurableSet (f i)) → Pairwise (Disjoint on f) →\n    HasSum (fun i => measureOf' (f i)) (measureOf' (⋃ i, f i))\n\n"}
{"name":"MeasureTheory.VectorMeasure.mk.injEq","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_3\ninst✝² : MeasurableSpace α\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nmeasureOf'✝ : Set α → M\nempty'✝ : Eq (measureOf'✝ EmptyCollection.emptyCollection) 0\nnot_measurable'✝ : ∀ ⦃i : Set α⦄, Not (MeasurableSet i) → Eq (measureOf'✝ i) 0\nm_iUnion'✝ : ∀ ⦃f : Nat → Set α⦄, (∀ (i : Nat), MeasurableSet (f i)) → Pairwise (Function.onFun Disjoint f) → HasSum (fun i => measureOf'✝ (f i)) (measureOf'✝ (Set.iUnion fun i => f i))\nmeasureOf' : Set α → M\nempty' : Eq (measureOf' EmptyCollection.emptyCollection) 0\nnot_measurable' : ∀ ⦃i : Set α⦄, Not (MeasurableSet i) → Eq (measureOf' i) 0\nm_iUnion' : ∀ ⦃f : Nat → Set α⦄, (∀ (i : Nat), MeasurableSet (f i)) → Pairwise (Function.onFun Disjoint f) → HasSum (fun i => measureOf' (f i)) (measureOf' (Set.iUnion fun i => f i))\n⊢ Eq (Eq { measureOf' := measureOf'✝, empty' := empty'✝, not_measurable' := not_measurable'✝, m_iUnion' := m_iUnion'✝ } { measureOf' := measureOf', empty' := empty', not_measurable' := not_measurable', m_iUnion' := m_iUnion' }) (Eq measureOf'✝ measureOf')","decl":"/-- A vector measure on a measurable space `α` is a σ-additive `M`-valued function (for some `M`\nan add monoid) such that the empty set and non-measurable sets are mapped to zero. -/\nstructure VectorMeasure (α : Type*) [MeasurableSpace α] (M : Type*) [AddCommMonoid M]\n    [TopologicalSpace M] where\n  measureOf' : Set α → M\n  empty' : measureOf' ∅ = 0\n  not_measurable' ⦃i : Set α⦄ : ¬MeasurableSet i → measureOf' i = 0\n  m_iUnion' ⦃f : ℕ → Set α⦄ : (∀ i, MeasurableSet (f i)) → Pairwise (Disjoint on f) →\n    HasSum (fun i => measureOf' (f i)) (measureOf' (⋃ i, f i))\n\n"}
{"name":"MeasureTheory.VectorMeasure.m_iUnion'","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_3\ninst✝² : MeasurableSpace α\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nself : MeasureTheory.VectorMeasure α M\nf : Nat → Set α\na✝¹ : ∀ (i : Nat), MeasurableSet (f i)\na✝ : Pairwise (Function.onFun Disjoint f)\n⊢ HasSum (fun i => self.measureOf' (f i)) (self.measureOf' (Set.iUnion fun i => f i))","decl":"/-- A vector measure on a measurable space `α` is a σ-additive `M`-valued function (for some `M`\nan add monoid) such that the empty set and non-measurable sets are mapped to zero. -/\nstructure VectorMeasure (α : Type*) [MeasurableSpace α] (M : Type*) [AddCommMonoid M]\n    [TopologicalSpace M] where\n  measureOf' : Set α → M\n  empty' : measureOf' ∅ = 0\n  not_measurable' ⦃i : Set α⦄ : ¬MeasurableSet i → measureOf' i = 0\n  m_iUnion' ⦃f : ℕ → Set α⦄ : (∀ i, MeasurableSet (f i)) → Pairwise (Disjoint on f) →\n    HasSum (fun i => measureOf' (f i)) (measureOf' (⋃ i, f i))\n\n"}
{"name":"MeasureTheory.VectorMeasure.mk.sizeOf_spec","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_3\ninst✝⁴ : MeasurableSpace α\nM : Type u_4\ninst✝³ : AddCommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : SizeOf α\ninst✝ : SizeOf M\nmeasureOf' : Set α → M\nempty' : Eq (measureOf' EmptyCollection.emptyCollection) 0\nnot_measurable' : ∀ ⦃i : Set α⦄, Not (MeasurableSet i) → Eq (measureOf' i) 0\nm_iUnion' : ∀ ⦃f : Nat → Set α⦄, (∀ (i : Nat), MeasurableSet (f i)) → Pairwise (Function.onFun Disjoint f) → HasSum (fun i => measureOf' (f i)) (measureOf' (Set.iUnion fun i => f i))\n⊢ Eq (SizeOf.sizeOf { measureOf' := measureOf', empty' := empty', not_measurable' := not_measurable', m_iUnion' := m_iUnion' }) (HAdd.hAdd 1 (SizeOf.sizeOf empty'))","decl":"/-- A vector measure on a measurable space `α` is a σ-additive `M`-valued function (for some `M`\nan add monoid) such that the empty set and non-measurable sets are mapped to zero. -/\nstructure VectorMeasure (α : Type*) [MeasurableSpace α] (M : Type*) [AddCommMonoid M]\n    [TopologicalSpace M] where\n  measureOf' : Set α → M\n  empty' : measureOf' ∅ = 0\n  not_measurable' ⦃i : Set α⦄ : ¬MeasurableSet i → measureOf' i = 0\n  m_iUnion' ⦃f : ℕ → Set α⦄ : (∀ i, MeasurableSet (f i)) → Pairwise (Disjoint on f) →\n    HasSum (fun i => measureOf' (f i)) (measureOf' (⋃ i, f i))\n\n"}
{"name":"MeasureTheory.VectorMeasure.empty'","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_3\ninst✝² : MeasurableSpace α\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nself : MeasureTheory.VectorMeasure α M\n⊢ Eq (self.measureOf' EmptyCollection.emptyCollection) 0","decl":"/-- A vector measure on a measurable space `α` is a σ-additive `M`-valued function (for some `M`\nan add monoid) such that the empty set and non-measurable sets are mapped to zero. -/\nstructure VectorMeasure (α : Type*) [MeasurableSpace α] (M : Type*) [AddCommMonoid M]\n    [TopologicalSpace M] where\n  measureOf' : Set α → M\n  empty' : measureOf' ∅ = 0\n  not_measurable' ⦃i : Set α⦄ : ¬MeasurableSet i → measureOf' i = 0\n  m_iUnion' ⦃f : ℕ → Set α⦄ : (∀ i, MeasurableSet (f i)) → Pairwise (Disjoint on f) →\n    HasSum (fun i => measureOf' (f i)) (measureOf' (⋃ i, f i))\n\n"}
{"name":"MeasureTheory.VectorMeasure.not_measurable'","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_3\ninst✝² : MeasurableSpace α\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nself : MeasureTheory.VectorMeasure α M\ni : Set α\na✝ : Not (MeasurableSet i)\n⊢ Eq (self.measureOf' i) 0","decl":"/-- A vector measure on a measurable space `α` is a σ-additive `M`-valued function (for some `M`\nan add monoid) such that the empty set and non-measurable sets are mapped to zero. -/\nstructure VectorMeasure (α : Type*) [MeasurableSpace α] (M : Type*) [AddCommMonoid M]\n    [TopologicalSpace M] where\n  measureOf' : Set α → M\n  empty' : measureOf' ∅ = 0\n  not_measurable' ⦃i : Set α⦄ : ¬MeasurableSet i → measureOf' i = 0\n  m_iUnion' ⦃f : ℕ → Set α⦄ : (∀ i, MeasurableSet (f i)) → Pairwise (Disjoint on f) →\n    HasSum (fun i => measureOf' (f i)) (measureOf' (⋃ i, f i))\n\n"}
{"name":"MeasureTheory.VectorMeasure.empty","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nv : MeasureTheory.VectorMeasure α M\n⊢ Eq (↑v EmptyCollection.emptyCollection) 0","decl":"@[simp]\ntheorem empty (v : VectorMeasure α M) : v ∅ = 0 :=\n  v.empty'\n\n"}
{"name":"MeasureTheory.VectorMeasure.not_measurable","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nv : MeasureTheory.VectorMeasure α M\ni : Set α\nhi : Not (MeasurableSet i)\n⊢ Eq (↑v i) 0","decl":"theorem not_measurable (v : VectorMeasure α M) {i : Set α} (hi : ¬MeasurableSet i) : v i = 0 :=\n  v.not_measurable' hi\n\n"}
{"name":"MeasureTheory.VectorMeasure.m_iUnion","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nv : MeasureTheory.VectorMeasure α M\nf : Nat → Set α\nhf₁ : ∀ (i : Nat), MeasurableSet (f i)\nhf₂ : Pairwise (Function.onFun Disjoint f)\n⊢ HasSum (fun i => ↑v (f i)) (↑v (Set.iUnion fun i => f i))","decl":"theorem m_iUnion (v : VectorMeasure α M) {f : ℕ → Set α} (hf₁ : ∀ i, MeasurableSet (f i))\n    (hf₂ : Pairwise (Disjoint on f)) : HasSum (fun i => v (f i)) (v (⋃ i, f i)) :=\n  v.m_iUnion' hf₁ hf₂\n\n"}
{"name":"MeasureTheory.VectorMeasure.coe_injective","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\n⊢ Function.Injective MeasureTheory.VectorMeasure.measureOf'","decl":"theorem coe_injective : @Function.Injective (VectorMeasure α M) (Set α → M) (⇑) := fun v w h => by\n  cases v\n  cases w\n  congr\n\n"}
{"name":"MeasureTheory.VectorMeasure.ext_iff'","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nv w : MeasureTheory.VectorMeasure α M\n⊢ Iff (Eq v w) (∀ (i : Set α), Eq (↑v i) (↑w i))","decl":"theorem ext_iff' (v w : VectorMeasure α M) : v = w ↔ ∀ i : Set α, v i = w i := by\n  rw [← coe_injective.eq_iff, funext_iff]\n\n"}
{"name":"MeasureTheory.VectorMeasure.ext_iff","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nv w : MeasureTheory.VectorMeasure α M\n⊢ Iff (Eq v w) (∀ (i : Set α), MeasurableSet i → Eq (↑v i) (↑w i))","decl":"theorem ext_iff (v w : VectorMeasure α M) : v = w ↔ ∀ i : Set α, MeasurableSet i → v i = w i := by\n  constructor\n  · rintro rfl _ _\n    rfl\n  · rw [ext_iff']\n    intro h i\n    by_cases hi : MeasurableSet i\n    · exact h i hi\n    · simp_rw [not_measurable _ hi]\n\n"}
{"name":"MeasureTheory.VectorMeasure.ext","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\ns t : MeasureTheory.VectorMeasure α M\nh : ∀ (i : Set α), MeasurableSet i → Eq (↑s i) (↑t i)\n⊢ Eq s t","decl":"@[ext]\ntheorem ext {s t : VectorMeasure α M} (h : ∀ i : Set α, MeasurableSet i → s i = t i) : s = t :=\n  (ext_iff s t).2 h\n\n"}
{"name":"MeasureTheory.VectorMeasure.hasSum_of_disjoint_iUnion","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : Countable β\nv : MeasureTheory.VectorMeasure α M\nf : β → Set α\nhm : ∀ (i : β), MeasurableSet (f i)\nhd : Pairwise (Function.onFun Disjoint f)\n⊢ HasSum (fun i => ↑v (f i)) (↑v (Set.iUnion fun i => f i))","decl":"theorem hasSum_of_disjoint_iUnion (hm : ∀ i, MeasurableSet (f i)) (hd : Pairwise (Disjoint on f)) :\n    HasSum (fun i => v (f i)) (v (⋃ i, f i)) := by\n  rcases Countable.exists_injective_nat β with ⟨e, he⟩\n  rw [← hasSum_extend_zero he]\n  convert m_iUnion v (f := Function.extend e f fun _ ↦ ∅) _ _\n  · simp only [Pi.zero_def, Function.apply_extend v, Function.comp_def, empty]\n  · exact (iSup_extend_bot he _).symm\n  · simp [Function.apply_extend MeasurableSet, Function.comp_def, hm]\n  · exact hd.disjoint_extend_bot (he.factorsThrough _)\n\n"}
{"name":"MeasureTheory.VectorMeasure.of_disjoint_iUnion","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nM : Type u_3\ninst✝³ : AddCommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : Countable β\nv : MeasureTheory.VectorMeasure α M\nf : β → Set α\ninst✝ : T2Space M\nhm : ∀ (i : β), MeasurableSet (f i)\nhd : Pairwise (Function.onFun Disjoint f)\n⊢ Eq (↑v (Set.iUnion fun i => f i)) (tsum fun i => ↑v (f i))","decl":"theorem of_disjoint_iUnion (hm : ∀ i, MeasurableSet (f i)) (hd : Pairwise (Disjoint on f)) :\n    v (⋃ i, f i) = ∑' i, v (f i) :=\n  (hasSum_of_disjoint_iUnion hm hd).tsum_eq.symm\n\n"}
{"name":"MeasureTheory.VectorMeasure.of_disjoint_iUnion_nat","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : T2Space M\nv : MeasureTheory.VectorMeasure α M\nf : Nat → Set α\nhf₁ : ∀ (i : Nat), MeasurableSet (f i)\nhf₂ : Pairwise (Function.onFun Disjoint f)\n⊢ Eq (↑v (Set.iUnion fun i => f i)) (tsum fun i => ↑v (f i))","decl":"@[deprecated of_disjoint_iUnion (since := \"2024-09-15\")]\ntheorem of_disjoint_iUnion_nat (v : VectorMeasure α M) {f : ℕ → Set α}\n    (hf₁ : ∀ i, MeasurableSet (f i)) (hf₂ : Pairwise (Disjoint on f)) :\n    v (⋃ i, f i) = ∑' i, v (f i) :=\n  of_disjoint_iUnion hf₁ hf₂\n\n"}
{"name":"MeasureTheory.VectorMeasure.of_union","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\nv : MeasureTheory.VectorMeasure α M\ninst✝ : T2Space M\nA B : Set α\nh : Disjoint A B\nhA : MeasurableSet A\nhB : MeasurableSet B\n⊢ Eq (↑v (Union.union A B)) (HAdd.hAdd (↑v A) (↑v B))","decl":"theorem of_union {A B : Set α} (h : Disjoint A B) (hA : MeasurableSet A) (hB : MeasurableSet B) :\n    v (A ∪ B) = v A + v B := by\n  rw [Set.union_eq_iUnion, of_disjoint_iUnion, tsum_fintype, Fintype.sum_bool, cond, cond]\n  exacts [fun b => Bool.casesOn b hB hA, pairwise_disjoint_on_bool.2 h]\n\n"}
{"name":"MeasureTheory.VectorMeasure.of_add_of_diff","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\nv : MeasureTheory.VectorMeasure α M\ninst✝ : T2Space M\nA B : Set α\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : HasSubset.Subset A B\n⊢ Eq (HAdd.hAdd (↑v A) (↑v (SDiff.sdiff B A))) (↑v B)","decl":"theorem of_add_of_diff {A B : Set α} (hA : MeasurableSet A) (hB : MeasurableSet B) (h : A ⊆ B) :\n    v A + v (B \\ A) = v B := by\n  rw [← of_union (@Set.disjoint_sdiff_right _ A B) hA (hB.diff hA), Set.union_diff_cancel h]\n\n"}
{"name":"MeasureTheory.VectorMeasure.of_diff","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\ninst✝² : AddCommGroup M\ninst✝¹ : TopologicalSpace M\ninst✝ : T2Space M\nv : MeasureTheory.VectorMeasure α M\nA B : Set α\nhA : MeasurableSet A\nhB : MeasurableSet B\nh : HasSubset.Subset A B\n⊢ Eq (↑v (SDiff.sdiff B A)) (HSub.hSub (↑v B) (↑v A))","decl":"theorem of_diff {M : Type*} [AddCommGroup M] [TopologicalSpace M] [T2Space M]\n    {v : VectorMeasure α M} {A B : Set α} (hA : MeasurableSet A) (hB : MeasurableSet B)\n    (h : A ⊆ B) : v (B \\ A) = v B - v A := by\n  rw [← of_add_of_diff hA hB h, add_sub_cancel_left]\n\n"}
{"name":"MeasureTheory.VectorMeasure.of_diff_of_diff_eq_zero","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\nv : MeasureTheory.VectorMeasure α M\ninst✝ : T2Space M\nA B : Set α\nhA : MeasurableSet A\nhB : MeasurableSet B\nh' : Eq (↑v (SDiff.sdiff B A)) 0\n⊢ Eq (HAdd.hAdd (↑v (SDiff.sdiff A B)) (↑v B)) (↑v A)","decl":"theorem of_diff_of_diff_eq_zero {A B : Set α} (hA : MeasurableSet A) (hB : MeasurableSet B)\n    (h' : v (B \\ A) = 0) : v (A \\ B) + v B = v A := by\n  symm\n  calc\n    v A = v (A \\ B ∪ A ∩ B) := by simp only [Set.diff_union_inter]\n    _ = v (A \\ B) + v (A ∩ B) := by\n      rw [of_union]\n      · rw [disjoint_comm]\n        exact Set.disjoint_of_subset_left A.inter_subset_right disjoint_sdiff_self_right\n      · exact hA.diff hB\n      · exact hA.inter hB\n    _ = v (A \\ B) + v (A ∩ B ∪ B \\ A) := by\n      rw [of_union, h', add_zero]\n      · exact Set.disjoint_of_subset_left A.inter_subset_left disjoint_sdiff_self_right\n      · exact hA.inter hB\n      · exact hB.diff hA\n    _ = v (A \\ B) + v B := by rw [Set.union_comm, Set.inter_comm, Set.diff_union_inter]\n\n"}
{"name":"MeasureTheory.VectorMeasure.of_iUnion_nonneg","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝³ : Countable β\nf : β → Set α\nM : Type u_4\ninst✝² : TopologicalSpace M\ninst✝¹ : OrderedAddCommMonoid M\ninst✝ : OrderClosedTopology M\nv : MeasureTheory.VectorMeasure α M\nhf₁ : ∀ (i : β), MeasurableSet (f i)\nhf₂ : Pairwise (Function.onFun Disjoint f)\nhf₃ : ∀ (i : β), LE.le 0 (↑v (f i))\n⊢ LE.le 0 (↑v (Set.iUnion fun i => f i))","decl":"theorem of_iUnion_nonneg {M : Type*} [TopologicalSpace M] [OrderedAddCommMonoid M]\n    [OrderClosedTopology M] {v : VectorMeasure α M} (hf₁ : ∀ i, MeasurableSet (f i))\n    (hf₂ : Pairwise (Disjoint on f)) (hf₃ : ∀ i, 0 ≤ v (f i)) : 0 ≤ v (⋃ i, f i) :=\n  (v.of_disjoint_iUnion hf₁ hf₂).symm ▸ tsum_nonneg hf₃\n\n"}
{"name":"MeasureTheory.VectorMeasure.of_iUnion_nonpos","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝³ : Countable β\nf : β → Set α\nM : Type u_4\ninst✝² : TopologicalSpace M\ninst✝¹ : OrderedAddCommMonoid M\ninst✝ : OrderClosedTopology M\nv : MeasureTheory.VectorMeasure α M\nhf₁ : ∀ (i : β), MeasurableSet (f i)\nhf₂ : Pairwise (Function.onFun Disjoint f)\nhf₃ : ∀ (i : β), LE.le (↑v (f i)) 0\n⊢ LE.le (↑v (Set.iUnion fun i => f i)) 0","decl":"theorem of_iUnion_nonpos {M : Type*} [TopologicalSpace M] [OrderedAddCommMonoid M]\n    [OrderClosedTopology M] {v : VectorMeasure α M} (hf₁ : ∀ i, MeasurableSet (f i))\n    (hf₂ : Pairwise (Disjoint on f)) (hf₃ : ∀ i, v (f i) ≤ 0) : v (⋃ i, f i) ≤ 0 :=\n  (v.of_disjoint_iUnion hf₁ hf₂).symm ▸ tsum_nonpos hf₃\n\n"}
{"name":"MeasureTheory.VectorMeasure.of_nonneg_disjoint_union_eq_zero","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nA B : Set α\nh : Disjoint A B\nhA₁ : MeasurableSet A\nhB₁ : MeasurableSet B\nhA₂ : LE.le 0 (↑s A)\nhB₂ : LE.le 0 (↑s B)\nhAB : Eq (↑s (Union.union A B)) 0\n⊢ Eq (↑s A) 0","decl":"theorem of_nonneg_disjoint_union_eq_zero {s : SignedMeasure α} {A B : Set α} (h : Disjoint A B)\n    (hA₁ : MeasurableSet A) (hB₁ : MeasurableSet B) (hA₂ : 0 ≤ s A) (hB₂ : 0 ≤ s B)\n    (hAB : s (A ∪ B) = 0) : s A = 0 := by\n  rw [of_union h hA₁ hB₁] at hAB\n  linarith\n\n"}
{"name":"MeasureTheory.VectorMeasure.of_nonpos_disjoint_union_eq_zero","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nA B : Set α\nh : Disjoint A B\nhA₁ : MeasurableSet A\nhB₁ : MeasurableSet B\nhA₂ : LE.le (↑s A) 0\nhB₂ : LE.le (↑s B) 0\nhAB : Eq (↑s (Union.union A B)) 0\n⊢ Eq (↑s A) 0","decl":"theorem of_nonpos_disjoint_union_eq_zero {s : SignedMeasure α} {A B : Set α} (h : Disjoint A B)\n    (hA₁ : MeasurableSet A) (hB₁ : MeasurableSet B) (hA₂ : s A ≤ 0) (hB₂ : s B ≤ 0)\n    (hAB : s (A ∪ B) = 0) : s A = 0 := by\n  rw [of_union h hA₁ hB₁] at hAB\n  linarith\n\n"}
{"name":"MeasureTheory.VectorMeasure.coe_smul","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : TopologicalSpace M\nR : Type u_4\ninst✝² : Semiring R\ninst✝¹ : DistribMulAction R M\ninst✝ : ContinuousConstSMul R M\nr : R\nv : MeasureTheory.VectorMeasure α M\n⊢ Eq (↑(HSMul.hSMul r v)) (HSMul.hSMul r ↑v)","decl":"@[simp]\ntheorem coe_smul (r : R) (v : VectorMeasure α M) : ⇑(r • v) = r • ⇑v := rfl\n\n"}
{"name":"MeasureTheory.VectorMeasure.smul_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : TopologicalSpace M\nR : Type u_4\ninst✝² : Semiring R\ninst✝¹ : DistribMulAction R M\ninst✝ : ContinuousConstSMul R M\nr : R\nv : MeasureTheory.VectorMeasure α M\ni : Set α\n⊢ Eq (↑(HSMul.hSMul r v) i) (HSMul.hSMul r (↑v i))","decl":"theorem smul_apply (r : R) (v : VectorMeasure α M) (i : Set α) : (r • v) i = r • v i := rfl\n\n"}
{"name":"MeasureTheory.VectorMeasure.coe_zero","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\n⊢ Eq (↑0) 0","decl":"@[simp]\ntheorem coe_zero : ⇑(0 : VectorMeasure α M) = 0 := rfl\n\n"}
{"name":"MeasureTheory.VectorMeasure.zero_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\ni : Set α\n⊢ Eq (↑0 i) 0","decl":"theorem zero_apply (i : Set α) : (0 : VectorMeasure α M) i = 0 := rfl\n\n"}
{"name":"MeasureTheory.VectorMeasure.coe_add","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nv w : MeasureTheory.VectorMeasure α M\n⊢ Eq (↑(HAdd.hAdd v w)) (HAdd.hAdd ↑v ↑w)","decl":"@[simp]\ntheorem coe_add (v w : VectorMeasure α M) : ⇑(v + w) = v + w := rfl\n\n"}
{"name":"MeasureTheory.VectorMeasure.add_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nv w : MeasureTheory.VectorMeasure α M\ni : Set α\n⊢ Eq (↑(HAdd.hAdd v w) i) (HAdd.hAdd (↑v i) (↑w i))","decl":"theorem add_apply (v w : VectorMeasure α M) (i : Set α) : (v + w) i = v i + w i := rfl\n\n"}
{"name":"MeasureTheory.VectorMeasure.coeFnAddMonoidHom_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nself : MeasureTheory.VectorMeasure α M\na✝ : Set α\n⊢ Eq (MeasureTheory.VectorMeasure.coeFnAddMonoidHom self a✝) (↑self a✝)","decl":"/-- `(⇑)` is an `AddMonoidHom`. -/\n@[simps]\ndef coeFnAddMonoidHom : VectorMeasure α M →+ Set α → M where\n  toFun := (⇑)\n  map_zero' := coe_zero\n  map_add' := coe_add\n\n"}
{"name":"MeasureTheory.VectorMeasure.coe_neg","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : AddCommGroup M\ninst✝¹ : TopologicalSpace M\ninst✝ : TopologicalAddGroup M\nv : MeasureTheory.VectorMeasure α M\n⊢ Eq (↑(Neg.neg v)) (Neg.neg ↑v)","decl":"@[simp]\ntheorem coe_neg (v : VectorMeasure α M) : ⇑(-v) = -v := rfl\n\n"}
{"name":"MeasureTheory.VectorMeasure.neg_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : AddCommGroup M\ninst✝¹ : TopologicalSpace M\ninst✝ : TopologicalAddGroup M\nv : MeasureTheory.VectorMeasure α M\ni : Set α\n⊢ Eq (↑(Neg.neg v) i) (Neg.neg (↑v i))","decl":"theorem neg_apply (v : VectorMeasure α M) (i : Set α) : (-v) i = -v i := rfl\n\n"}
{"name":"MeasureTheory.VectorMeasure.coe_sub","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : AddCommGroup M\ninst✝¹ : TopologicalSpace M\ninst✝ : TopologicalAddGroup M\nv w : MeasureTheory.VectorMeasure α M\n⊢ Eq (↑(HSub.hSub v w)) (HSub.hSub ↑v ↑w)","decl":"@[simp]\ntheorem coe_sub (v w : VectorMeasure α M) : ⇑(v - w) = v - w := rfl\n\n"}
{"name":"MeasureTheory.VectorMeasure.sub_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : AddCommGroup M\ninst✝¹ : TopologicalSpace M\ninst✝ : TopologicalAddGroup M\nv w : MeasureTheory.VectorMeasure α M\ni : Set α\n⊢ Eq (↑(HSub.hSub v w) i) (HSub.hSub (↑v i) (↑w i))","decl":"theorem sub_apply (v w : VectorMeasure α M) (i : Set α) : (v - w) i = v i - w i := rfl\n\n"}
{"name":"MeasureTheory.Measure.toSignedMeasure_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhμ : MeasureTheory.IsFiniteMeasure μ\ns : Set α\n⊢ Eq (↑μ.toSignedMeasure s) (ite (MeasurableSet s) (μ s).toReal 0)","decl":"open Classical in\n/-- A finite measure coerced into a real function is a signed measure. -/\n@[simps]\ndef toSignedMeasure (μ : Measure α) [hμ : IsFiniteMeasure μ] : SignedMeasure α where\n  measureOf' := fun s : Set α => if MeasurableSet s then (μ s).toReal else 0\n  empty' := by simp [μ.empty]\n  not_measurable' _ hi := if_neg hi\n  m_iUnion' f hf₁ hf₂ := by\n    simp only [*, MeasurableSet.iUnion hf₁, if_true, measure_iUnion hf₂ hf₁]\n    rw [ENNReal.tsum_toReal_eq]\n    exacts [(summable_measure_toReal hf₁ hf₂).hasSum, fun _ ↦ measure_ne_top _ _]\n\n"}
{"name":"MeasureTheory.Measure.toSignedMeasure_apply_measurable","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ni : Set α\nhi : MeasurableSet i\n⊢ Eq (↑μ.toSignedMeasure i) (μ i).toReal","decl":"theorem toSignedMeasure_apply_measurable {μ : Measure α} [IsFiniteMeasure μ] {i : Set α}\n    (hi : MeasurableSet i) : μ.toSignedMeasure i = (μ i).toReal :=\n  if_pos hi\n\n-- Without this lemma, `singularPart_neg` in `MeasureTheory.Decomposition.Lebesgue` is\n-- extremely slow\n"}
{"name":"MeasureTheory.Measure.toSignedMeasure_congr","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : MeasureTheory.IsFiniteMeasure ν\nh : Eq μ ν\n⊢ Eq μ.toSignedMeasure ν.toSignedMeasure","decl":"theorem toSignedMeasure_congr {μ ν : Measure α} [IsFiniteMeasure μ] [IsFiniteMeasure ν]\n    (h : μ = ν) : μ.toSignedMeasure = ν.toSignedMeasure := by\n  congr\n\n"}
{"name":"MeasureTheory.Measure.toSignedMeasure_eq_toSignedMeasure_iff","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : MeasureTheory.IsFiniteMeasure ν\n⊢ Iff (Eq μ.toSignedMeasure ν.toSignedMeasure) (Eq μ ν)","decl":"theorem toSignedMeasure_eq_toSignedMeasure_iff {μ ν : Measure α} [IsFiniteMeasure μ]\n    [IsFiniteMeasure ν] : μ.toSignedMeasure = ν.toSignedMeasure ↔ μ = ν := by\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · ext1 i hi\n    have : μ.toSignedMeasure i = ν.toSignedMeasure i := by rw [h]\n    rwa [toSignedMeasure_apply_measurable hi, toSignedMeasure_apply_measurable hi,\n        ENNReal.toReal_eq_toReal] at this\n      <;> exact measure_ne_top _ _\n  · congr\n\n"}
{"name":"MeasureTheory.Measure.toSignedMeasure_zero","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\n⊢ Eq (MeasureTheory.Measure.toSignedMeasure 0) 0","decl":"@[simp]\ntheorem toSignedMeasure_zero : (0 : Measure α).toSignedMeasure = 0 := by\n  ext i\n  simp\n\n"}
{"name":"MeasureTheory.Measure.toSignedMeasure_add","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : MeasureTheory.IsFiniteMeasure ν\n⊢ Eq (HAdd.hAdd μ ν).toSignedMeasure (HAdd.hAdd μ.toSignedMeasure ν.toSignedMeasure)","decl":"@[simp]\ntheorem toSignedMeasure_add (μ ν : Measure α) [IsFiniteMeasure μ] [IsFiniteMeasure ν] :\n    (μ + ν).toSignedMeasure = μ.toSignedMeasure + ν.toSignedMeasure := by\n  ext i hi\n  rw [toSignedMeasure_apply_measurable hi, add_apply,\n    ENNReal.toReal_add (ne_of_lt (measure_lt_top _ _)) (ne_of_lt (measure_lt_top _ _)),\n    VectorMeasure.add_apply, toSignedMeasure_apply_measurable hi,\n    toSignedMeasure_apply_measurable hi]\n\n"}
{"name":"MeasureTheory.Measure.toSignedMeasure_smul","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nr : NNReal\n⊢ Eq (HSMul.hSMul r μ).toSignedMeasure (HSMul.hSMul r μ.toSignedMeasure)","decl":"@[simp]\ntheorem toSignedMeasure_smul (μ : Measure α) [IsFiniteMeasure μ] (r : ℝ≥0) :\n    (r • μ).toSignedMeasure = r • μ.toSignedMeasure := by\n  ext i hi\n  rw [toSignedMeasure_apply_measurable hi, VectorMeasure.smul_apply,\n    toSignedMeasure_apply_measurable hi, coe_smul, Pi.smul_apply, ENNReal.toReal_smul]\n\n"}
{"name":"MeasureTheory.Measure.toENNRealVectorMeasure_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ni : Set α\n⊢ Eq (↑μ.toENNRealVectorMeasure i) (ite (MeasurableSet i) (μ i) 0)","decl":"open Classical in\n/-- A measure is a vector measure over `ℝ≥0∞`. -/\n@[simps]\ndef toENNRealVectorMeasure (μ : Measure α) : VectorMeasure α ℝ≥0∞ where\n  measureOf' := fun i : Set α => if MeasurableSet i then μ i else 0\n  empty' := by simp [μ.empty]\n  not_measurable' _ hi := if_neg hi\n  m_iUnion' _ hf₁ hf₂ := by\n    simp only\n    rw [Summable.hasSum_iff ENNReal.summable, if_pos (MeasurableSet.iUnion hf₁),\n      MeasureTheory.measure_iUnion hf₂ hf₁]\n    exact tsum_congr fun n => if_pos (hf₁ n)\n\n"}
{"name":"MeasureTheory.Measure.toENNRealVectorMeasure_apply_measurable","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ni : Set α\nhi : MeasurableSet i\n⊢ Eq (↑μ.toENNRealVectorMeasure i) (μ i)","decl":"theorem toENNRealVectorMeasure_apply_measurable {μ : Measure α} {i : Set α} (hi : MeasurableSet i) :\n    μ.toENNRealVectorMeasure i = μ i :=\n  if_pos hi\n\n"}
{"name":"MeasureTheory.Measure.toENNRealVectorMeasure_zero","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\n⊢ Eq (MeasureTheory.Measure.toENNRealVectorMeasure 0) 0","decl":"@[simp]\ntheorem toENNRealVectorMeasure_zero : (0 : Measure α).toENNRealVectorMeasure = 0 := by\n  ext i\n  simp\n\n"}
{"name":"MeasureTheory.Measure.toENNRealVectorMeasure_add","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ Eq (HAdd.hAdd μ ν).toENNRealVectorMeasure (HAdd.hAdd μ.toENNRealVectorMeasure ν.toENNRealVectorMeasure)","decl":"@[simp]\ntheorem toENNRealVectorMeasure_add (μ ν : Measure α) :\n    (μ + ν).toENNRealVectorMeasure = μ.toENNRealVectorMeasure + ν.toENNRealVectorMeasure := by\n  refine MeasureTheory.VectorMeasure.ext fun i hi => ?_\n  rw [toENNRealVectorMeasure_apply_measurable hi, add_apply, VectorMeasure.add_apply,\n    toENNRealVectorMeasure_apply_measurable hi, toENNRealVectorMeasure_apply_measurable hi]\n\n"}
{"name":"MeasureTheory.Measure.toSignedMeasure_sub_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : MeasureTheory.IsFiniteMeasure ν\ni : Set α\nhi : MeasurableSet i\n⊢ Eq (↑(HSub.hSub μ.toSignedMeasure ν.toSignedMeasure) i) (HSub.hSub (μ i).toReal (ν i).toReal)","decl":"theorem toSignedMeasure_sub_apply {μ ν : Measure α} [IsFiniteMeasure μ] [IsFiniteMeasure ν]\n    {i : Set α} (hi : MeasurableSet i) :\n    (μ.toSignedMeasure - ν.toSignedMeasure) i = (μ i).toReal - (ν i).toReal := by\n  rw [VectorMeasure.sub_apply, toSignedMeasure_apply_measurable hi,\n    Measure.toSignedMeasure_apply_measurable hi]\n\n"}
{"name":"MeasureTheory.VectorMeasure.ennrealToMeasure_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nv : MeasureTheory.VectorMeasure α ENNReal\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (v.ennrealToMeasure s) (↑v s)","decl":"theorem ennrealToMeasure_apply {m : MeasurableSpace α} {v : VectorMeasure α ℝ≥0∞} {s : Set α}\n    (hs : MeasurableSet s) : ennrealToMeasure v s = v s := by\n  rw [ennrealToMeasure, ofMeasurable_apply _ hs]\n\n"}
{"name":"MeasureTheory.Measure.toENNRealVectorMeasure_ennrealToMeasure","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.VectorMeasure α ENNReal\n⊢ Eq μ.ennrealToMeasure.toENNRealVectorMeasure μ","decl":"@[simp]\ntheorem _root_.MeasureTheory.Measure.toENNRealVectorMeasure_ennrealToMeasure\n    (μ : VectorMeasure α ℝ≥0∞) :\n    toENNRealVectorMeasure (ennrealToMeasure μ) = μ := ext fun s hs => by\n  rw [toENNRealVectorMeasure_apply_measurable hs, ennrealToMeasure_apply hs]\n\n"}
{"name":"MeasureTheory.VectorMeasure.ennrealToMeasure_toENNRealVectorMeasure","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq μ.toENNRealVectorMeasure.ennrealToMeasure μ","decl":"@[simp]\ntheorem ennrealToMeasure_toENNRealVectorMeasure (μ : Measure α) :\n    ennrealToMeasure (toENNRealVectorMeasure μ) = μ := Measure.ext fun s hs => by\n  rw [ennrealToMeasure_apply hs, toENNRealVectorMeasure_apply_measurable hs]\n\n"}
{"name":"MeasureTheory.VectorMeasure.equivMeasure_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nv : MeasureTheory.VectorMeasure α ENNReal\n⊢ Eq (MeasureTheory.VectorMeasure.equivMeasure v) v.ennrealToMeasure","decl":"/-- The equiv between `VectorMeasure α ℝ≥0∞` and `Measure α` formed by\n`MeasureTheory.VectorMeasure.ennrealToMeasure` and\n`MeasureTheory.Measure.toENNRealVectorMeasure`. -/\n@[simps]\ndef equivMeasure [MeasurableSpace α] : VectorMeasure α ℝ≥0∞ ≃ Measure α where\n  toFun := ennrealToMeasure\n  invFun := toENNRealVectorMeasure\n  left_inv := toENNRealVectorMeasure_ennrealToMeasure\n  right_inv := ennrealToMeasure_toENNRealVectorMeasure\n\n"}
{"name":"MeasureTheory.VectorMeasure.equivMeasure_symm_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.VectorMeasure.equivMeasure.symm μ) μ.toENNRealVectorMeasure","decl":"/-- The equiv between `VectorMeasure α ℝ≥0∞` and `Measure α` formed by\n`MeasureTheory.VectorMeasure.ennrealToMeasure` and\n`MeasureTheory.Measure.toENNRealVectorMeasure`. -/\n@[simps]\ndef equivMeasure [MeasurableSpace α] : VectorMeasure α ℝ≥0∞ ≃ Measure α where\n  toFun := ennrealToMeasure\n  invFun := toENNRealVectorMeasure\n  left_inv := toENNRealVectorMeasure_ennrealToMeasure\n  right_inv := ennrealToMeasure_toENNRealVectorMeasure\n\n"}
{"name":"MeasureTheory.VectorMeasure.map_not_measurable","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nv : MeasureTheory.VectorMeasure α M\nf : α → β\nhf : Not (Measurable f)\n⊢ Eq (v.map f) 0","decl":"theorem map_not_measurable {f : α → β} (hf : ¬Measurable f) : v.map f = 0 :=\n  dif_neg hf\n\n"}
{"name":"MeasureTheory.VectorMeasure.map_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nv : MeasureTheory.VectorMeasure α M\nf : α → β\nhf : Measurable f\ns : Set β\nhs : MeasurableSet s\n⊢ Eq (↑(v.map f) s) (↑v (Set.preimage f s))","decl":"theorem map_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    v.map f s = v (f ⁻¹' s) := by\n  rw [map, dif_pos hf]\n  exact if_pos hs\n\n"}
{"name":"MeasureTheory.VectorMeasure.map_id","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nv : MeasureTheory.VectorMeasure α M\n⊢ Eq (v.map id) v","decl":"@[simp]\ntheorem map_id : v.map id = v :=\n  ext fun i hi => by rw [map_apply v measurable_id hi, Set.preimage_id]\n\n"}
{"name":"MeasureTheory.VectorMeasure.map_zero","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nf : α → β\n⊢ Eq (MeasureTheory.VectorMeasure.map 0 f) 0","decl":"@[simp]\ntheorem map_zero (f : α → β) : (0 : VectorMeasure α M).map f = 0 := by\n  by_cases hf : Measurable f\n  · ext i hi\n    rw [map_apply _ hf hi, zero_apply, zero_apply]\n  · exact dif_neg hf\n\n"}
{"name":"MeasureTheory.VectorMeasure.mapRange_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\ninst✝⁴ : MeasurableSpace α\nM : Type u_3\ninst✝³ : AddCommMonoid M\ninst✝² : TopologicalSpace M\nv : MeasureTheory.VectorMeasure α M\nN : Type u_4\ninst✝¹ : AddCommMonoid N\ninst✝ : TopologicalSpace N\nf : AddMonoidHom M N\nhf : Continuous ⇑f\ns : Set α\n⊢ Eq (↑(v.mapRange f hf) s) (f (↑v s))","decl":"@[simp]\ntheorem mapRange_apply {f : M →+ N} (hf : Continuous f) {s : Set α} : v.mapRange f hf s = f (v s) :=\n  rfl\n\n"}
{"name":"MeasureTheory.VectorMeasure.mapRange_id","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nv : MeasureTheory.VectorMeasure α M\n⊢ Eq (v.mapRange (AddMonoidHom.id M) ⋯) v","decl":"@[simp]\ntheorem mapRange_id : v.mapRange (AddMonoidHom.id M) continuous_id = v := by\n  ext\n  rfl\n\n"}
{"name":"MeasureTheory.VectorMeasure.mapRange_zero","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\ninst✝⁴ : MeasurableSpace α\nM : Type u_3\ninst✝³ : AddCommMonoid M\ninst✝² : TopologicalSpace M\nN : Type u_4\ninst✝¹ : AddCommMonoid N\ninst✝ : TopologicalSpace N\nf : AddMonoidHom M N\nhf : Continuous ⇑f\n⊢ Eq (MeasureTheory.VectorMeasure.mapRange 0 f hf) 0","decl":"@[simp]\ntheorem mapRange_zero {f : M →+ N} (hf : Continuous f) :\n    mapRange (0 : VectorMeasure α M) f hf = 0 := by\n  ext\n  simp\n\n"}
{"name":"MeasureTheory.VectorMeasure.mapRange_add","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\ninst✝⁶ : MeasurableSpace α\nM : Type u_3\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : TopologicalSpace M\nN : Type u_4\ninst✝³ : AddCommMonoid N\ninst✝² : TopologicalSpace N\ninst✝¹ : ContinuousAdd M\ninst✝ : ContinuousAdd N\nv w : MeasureTheory.VectorMeasure α M\nf : AddMonoidHom M N\nhf : Continuous ⇑f\n⊢ Eq ((HAdd.hAdd v w).mapRange f hf) (HAdd.hAdd (v.mapRange f hf) (w.mapRange f hf))","decl":"@[simp]\ntheorem mapRange_add {v w : VectorMeasure α M} {f : M →+ N} (hf : Continuous f) :\n    (v + w).mapRange f hf = v.mapRange f hf + w.mapRange f hf := by\n  ext\n  simp\n\n"}
{"name":"MeasureTheory.VectorMeasure.restrict_not_measurable","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nv : MeasureTheory.VectorMeasure α M\ni : Set α\nhi : Not (MeasurableSet i)\n⊢ Eq (v.restrict i) 0","decl":"theorem restrict_not_measurable {i : Set α} (hi : ¬MeasurableSet i) : v.restrict i = 0 :=\n  dif_neg hi\n\n"}
{"name":"MeasureTheory.VectorMeasure.restrict_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nv : MeasureTheory.VectorMeasure α M\ni : Set α\nhi : MeasurableSet i\nj : Set α\nhj : MeasurableSet j\n⊢ Eq (↑(v.restrict i) j) (↑v (Inter.inter j i))","decl":"theorem restrict_apply {i : Set α} (hi : MeasurableSet i) {j : Set α} (hj : MeasurableSet j) :\n    v.restrict i j = v (j ∩ i) := by\n  rw [restrict, dif_pos hi]\n  exact if_pos hj\n\n"}
{"name":"MeasureTheory.VectorMeasure.restrict_eq_self","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nv : MeasureTheory.VectorMeasure α M\ni : Set α\nhi : MeasurableSet i\nj : Set α\nhj : MeasurableSet j\nhij : HasSubset.Subset j i\n⊢ Eq (↑(v.restrict i) j) (↑v j)","decl":"theorem restrict_eq_self {i : Set α} (hi : MeasurableSet i) {j : Set α} (hj : MeasurableSet j)\n    (hij : j ⊆ i) : v.restrict i j = v j := by\n  rw [restrict_apply v hi hj, Set.inter_eq_left.2 hij]\n\n"}
{"name":"MeasureTheory.VectorMeasure.restrict_empty","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nv : MeasureTheory.VectorMeasure α M\n⊢ Eq (v.restrict EmptyCollection.emptyCollection) 0","decl":"@[simp]\ntheorem restrict_empty : v.restrict ∅ = 0 :=\n  ext fun i hi => by\n    rw [restrict_apply v MeasurableSet.empty hi, Set.inter_empty, v.empty, zero_apply]\n\n"}
{"name":"MeasureTheory.VectorMeasure.restrict_univ","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nv : MeasureTheory.VectorMeasure α M\n⊢ Eq (v.restrict Set.univ) v","decl":"@[simp]\ntheorem restrict_univ : v.restrict Set.univ = v :=\n  ext fun i hi => by rw [restrict_apply v MeasurableSet.univ hi, Set.inter_univ]\n\n"}
{"name":"MeasureTheory.VectorMeasure.restrict_zero","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\ni : Set α\n⊢ Eq (MeasureTheory.VectorMeasure.restrict 0 i) 0","decl":"@[simp]\ntheorem restrict_zero {i : Set α} : (0 : VectorMeasure α M).restrict i = 0 := by\n  by_cases hi : MeasurableSet i\n  · ext j hj\n    rw [restrict_apply 0 hi hj, zero_apply, zero_apply]\n  · exact dif_neg hi\n\n"}
{"name":"MeasureTheory.VectorMeasure.map_add","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : MeasurableSpace α\ninst✝³ : MeasurableSpace β\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nv w : MeasureTheory.VectorMeasure α M\nf : α → β\n⊢ Eq ((HAdd.hAdd v w).map f) (HAdd.hAdd (v.map f) (w.map f))","decl":"theorem map_add (v w : VectorMeasure α M) (f : α → β) : (v + w).map f = v.map f + w.map f := by\n  by_cases hf : Measurable f\n  · ext i hi\n    simp [map_apply _ hf hi]\n  · simp [map, dif_neg hf]\n\n"}
{"name":"MeasureTheory.VectorMeasure.mapGm_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : MeasurableSpace α\ninst✝³ : MeasurableSpace β\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nf : α → β\nv : MeasureTheory.VectorMeasure α M\n⊢ Eq ((MeasureTheory.VectorMeasure.mapGm f) v) (v.map f)","decl":"/-- `VectorMeasure.map` as an additive monoid homomorphism. -/\n@[simps]\ndef mapGm (f : α → β) : VectorMeasure α M →+ VectorMeasure β M where\n  toFun v := v.map f\n  map_zero' := map_zero f\n  map_add' _ _ := map_add _ _ f\n\n"}
{"name":"MeasureTheory.VectorMeasure.restrict_add","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\ninst✝³ : MeasurableSpace α\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nv w : MeasureTheory.VectorMeasure α M\ni : Set α\n⊢ Eq ((HAdd.hAdd v w).restrict i) (HAdd.hAdd (v.restrict i) (w.restrict i))","decl":"theorem restrict_add (v w : VectorMeasure α M) (i : Set α) :\n    (v + w).restrict i = v.restrict i + w.restrict i := by\n  by_cases hi : MeasurableSet i\n  · ext j hj\n    simp [restrict_apply _ hi hj]\n  · simp [restrict_not_measurable _ hi]\n\n"}
{"name":"MeasureTheory.VectorMeasure.restrictGm_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\ninst✝³ : MeasurableSpace α\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\ni : Set α\nv : MeasureTheory.VectorMeasure α M\n⊢ Eq ((MeasureTheory.VectorMeasure.restrictGm i) v) (v.restrict i)","decl":"/-- `VectorMeasure.restrict` as an additive monoid homomorphism. -/\n@[simps]\ndef restrictGm (i : Set α) : VectorMeasure α M →+ VectorMeasure α M where\n  toFun v := v.restrict i\n  map_zero' := restrict_zero\n  map_add' _ _ := restrict_add _ _ i\n\n"}
{"name":"MeasureTheory.VectorMeasure.map_smul","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝⁵ : MeasurableSpace β\nM : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : TopologicalSpace M\nR : Type u_4\ninst✝² : Semiring R\ninst✝¹ : DistribMulAction R M\ninst✝ : ContinuousConstSMul R M\nv : MeasureTheory.VectorMeasure α M\nf : α → β\nc : R\n⊢ Eq ((HSMul.hSMul c v).map f) (HSMul.hSMul c (v.map f))","decl":"@[simp]\ntheorem map_smul {v : VectorMeasure α M} {f : α → β} (c : R) : (c • v).map f = c • v.map f := by\n  by_cases hf : Measurable f\n  · ext i hi\n    simp [map_apply _ hf hi]\n  · simp only [map, dif_neg hf]\n    -- `smul_zero` does not work since we do not require `ContinuousAdd`\n    ext i\n    simp\n\n"}
{"name":"MeasureTheory.VectorMeasure.restrict_smul","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : TopologicalSpace M\nR : Type u_4\ninst✝² : Semiring R\ninst✝¹ : DistribMulAction R M\ninst✝ : ContinuousConstSMul R M\nv : MeasureTheory.VectorMeasure α M\ni : Set α\nc : R\n⊢ Eq ((HSMul.hSMul c v).restrict i) (HSMul.hSMul c (v.restrict i))","decl":"@[simp]\ntheorem restrict_smul {v : VectorMeasure α M} {i : Set α} (c : R) :\n    (c • v).restrict i = c • v.restrict i := by\n  by_cases hi : MeasurableSet i\n  · ext j hj\n    simp [restrict_apply _ hi hj]\n  · simp only [restrict_not_measurable _ hi]\n    -- `smul_zero` does not work since we do not require `ContinuousAdd`\n    ext j\n    simp\n\n"}
{"name":"MeasureTheory.VectorMeasure.mapₗ_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝⁶ : MeasurableSpace β\nM : Type u_3\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : TopologicalSpace M\nR : Type u_4\ninst✝³ : Semiring R\ninst✝² : Module R M\ninst✝¹ : ContinuousConstSMul R M\ninst✝ : ContinuousAdd M\nf : α → β\nv : MeasureTheory.VectorMeasure α M\n⊢ Eq ((MeasureTheory.VectorMeasure.mapₗ f) v) (v.map f)","decl":"/-- `VectorMeasure.map` as a linear map. -/\n@[simps]\ndef mapₗ (f : α → β) : VectorMeasure α M →ₗ[R] VectorMeasure β M where\n  toFun v := v.map f\n  map_add' _ _ := map_add _ _ f\n  map_smul' _ _ := map_smul _\n\n"}
{"name":"MeasureTheory.VectorMeasure.restrictₗ_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : TopologicalSpace M\nR : Type u_4\ninst✝³ : Semiring R\ninst✝² : Module R M\ninst✝¹ : ContinuousConstSMul R M\ninst✝ : ContinuousAdd M\ni : Set α\nv : MeasureTheory.VectorMeasure α M\n⊢ Eq ((MeasureTheory.VectorMeasure.restrictₗ i) v) (v.restrict i)","decl":"/-- `VectorMeasure.restrict` as an additive monoid homomorphism. -/\n@[simps]\ndef restrictₗ (i : Set α) : VectorMeasure α M →ₗ[R] VectorMeasure α M where\n  toFun v := v.restrict i\n  map_add' _ _ := restrict_add _ _ i\n  map_smul' _ _ := restrict_smul _\n\n"}
{"name":"MeasureTheory.VectorMeasure.le_iff","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid M\ninst✝ : PartialOrder M\nv w : MeasureTheory.VectorMeasure α M\n⊢ Iff (LE.le v w) (∀ (i : Set α), MeasurableSet i → LE.le (↑v i) (↑w i))","decl":"theorem le_iff : v ≤ w ↔ ∀ i, MeasurableSet i → v i ≤ w i := Iff.rfl\n\n"}
{"name":"MeasureTheory.VectorMeasure.le_iff'","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid M\ninst✝ : PartialOrder M\nv w : MeasureTheory.VectorMeasure α M\n⊢ Iff (LE.le v w) (∀ (i : Set α), LE.le (↑v i) (↑w i))","decl":"theorem le_iff' : v ≤ w ↔ ∀ i, v i ≤ w i := by\n  refine ⟨fun h i => ?_, fun h i _ => h i⟩\n  by_cases hi : MeasurableSet i\n  · exact h i hi\n  · rw [v.not_measurable hi, w.not_measurable hi]\n\n"}
{"name":"MeasureTheory.VectorMeasure.restrict_le_restrict_iff","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid M\ninst✝ : PartialOrder M\nv w : MeasureTheory.VectorMeasure α M\ni : Set α\nhi : MeasurableSet i\n⊢ Iff (LE.le (v.restrict i) (w.restrict i)) (∀ ⦃j : Set α⦄, MeasurableSet j → HasSubset.Subset j i → LE.le (↑v j) (↑w j))","decl":"theorem restrict_le_restrict_iff {i : Set α} (hi : MeasurableSet i) :\n    v ≤[i] w ↔ ∀ ⦃j⦄, MeasurableSet j → j ⊆ i → v j ≤ w j :=\n  ⟨fun h j hj₁ hj₂ => restrict_eq_self v hi hj₁ hj₂ ▸ restrict_eq_self w hi hj₁ hj₂ ▸ h j hj₁,\n    fun h => le_iff.1 fun _ hj =>\n      (restrict_apply v hi hj).symm ▸ (restrict_apply w hi hj).symm ▸\n      h (hj.inter hi) Set.inter_subset_right⟩\n\n"}
{"name":"MeasureTheory.VectorMeasure.subset_le_of_restrict_le_restrict","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid M\ninst✝ : PartialOrder M\nv w : MeasureTheory.VectorMeasure α M\ni : Set α\nhi : MeasurableSet i\nhi₂ : LE.le (v.restrict i) (w.restrict i)\nj : Set α\nhj : HasSubset.Subset j i\n⊢ LE.le (↑v j) (↑w j)","decl":"theorem subset_le_of_restrict_le_restrict {i : Set α} (hi : MeasurableSet i) (hi₂ : v ≤[i] w)\n    {j : Set α} (hj : j ⊆ i) : v j ≤ w j := by\n  by_cases hj₁ : MeasurableSet j\n  · exact (restrict_le_restrict_iff _ _ hi).1 hi₂ hj₁ hj\n  · rw [v.not_measurable hj₁, w.not_measurable hj₁]\n\n"}
{"name":"MeasureTheory.VectorMeasure.restrict_le_restrict_of_subset_le","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid M\ninst✝ : PartialOrder M\nv w : MeasureTheory.VectorMeasure α M\ni : Set α\nh : ∀ ⦃j : Set α⦄, MeasurableSet j → HasSubset.Subset j i → LE.le (↑v j) (↑w j)\n⊢ LE.le (v.restrict i) (w.restrict i)","decl":"theorem restrict_le_restrict_of_subset_le {i : Set α}\n    (h : ∀ ⦃j⦄, MeasurableSet j → j ⊆ i → v j ≤ w j) : v ≤[i] w := by\n  by_cases hi : MeasurableSet i\n  · exact (restrict_le_restrict_iff _ _ hi).2 h\n  · rw [restrict_not_measurable v hi, restrict_not_measurable w hi]\n\n"}
{"name":"MeasureTheory.VectorMeasure.restrict_le_restrict_subset","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid M\ninst✝ : PartialOrder M\nv w : MeasureTheory.VectorMeasure α M\ni j : Set α\nhi₁ : MeasurableSet i\nhi₂ : LE.le (v.restrict i) (w.restrict i)\nhij : HasSubset.Subset j i\n⊢ LE.le (v.restrict j) (w.restrict j)","decl":"theorem restrict_le_restrict_subset {i j : Set α} (hi₁ : MeasurableSet i) (hi₂ : v ≤[i] w)\n    (hij : j ⊆ i) : v ≤[j] w :=\n  restrict_le_restrict_of_subset_le v w fun _ _ hk₂ =>\n    subset_le_of_restrict_le_restrict v w hi₁ hi₂ (Set.Subset.trans hk₂ hij)\n\n"}
{"name":"MeasureTheory.VectorMeasure.le_restrict_empty","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid M\ninst✝ : PartialOrder M\nv w : MeasureTheory.VectorMeasure α M\n⊢ LE.le (v.restrict EmptyCollection.emptyCollection) (w.restrict EmptyCollection.emptyCollection)","decl":"theorem le_restrict_empty : v ≤[∅] w := by\n  intro j _\n  rw [restrict_empty, restrict_empty]\n\n"}
{"name":"MeasureTheory.VectorMeasure.le_restrict_univ_iff_le","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid M\ninst✝ : PartialOrder M\nv w : MeasureTheory.VectorMeasure α M\n⊢ Iff (LE.le (v.restrict Set.univ) (w.restrict Set.univ)) (LE.le v w)","decl":"theorem le_restrict_univ_iff_le : v ≤[Set.univ] w ↔ v ≤ w := by\n  constructor\n  · intro h s hs\n    have := h s hs\n    rwa [restrict_apply _ MeasurableSet.univ hs, Set.inter_univ,\n      restrict_apply _ MeasurableSet.univ hs, Set.inter_univ] at this\n  · intro h s hs\n    rw [restrict_apply _ MeasurableSet.univ hs, Set.inter_univ,\n      restrict_apply _ MeasurableSet.univ hs, Set.inter_univ]\n    exact h s hs\n\n"}
{"name":"MeasureTheory.VectorMeasure.neg_le_neg","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : OrderedAddCommGroup M\ninst✝ : TopologicalAddGroup M\nv w : MeasureTheory.VectorMeasure α M\ni : Set α\nhi : MeasurableSet i\nh : LE.le (v.restrict i) (w.restrict i)\n⊢ LE.le ((Neg.neg w).restrict i) ((Neg.neg v).restrict i)","decl":"nonrec theorem neg_le_neg {i : Set α} (hi : MeasurableSet i) (h : v ≤[i] w) : -w ≤[i] -v := by\n  intro j hj₁\n  rw [restrict_apply _ hi hj₁, restrict_apply _ hi hj₁, neg_apply, neg_apply]\n  refine neg_le_neg ?_\n  rw [← restrict_apply _ hi hj₁, ← restrict_apply _ hi hj₁]\n  exact h j hj₁\n\n"}
{"name":"MeasureTheory.VectorMeasure.neg_le_neg_iff","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : OrderedAddCommGroup M\ninst✝ : TopologicalAddGroup M\nv w : MeasureTheory.VectorMeasure α M\ni : Set α\nhi : MeasurableSet i\n⊢ Iff (LE.le ((Neg.neg w).restrict i) ((Neg.neg v).restrict i)) (LE.le (v.restrict i) (w.restrict i))","decl":"@[simp]\ntheorem neg_le_neg_iff {i : Set α} (hi : MeasurableSet i) : -w ≤[i] -v ↔ v ≤[i] w :=\n  ⟨fun h => neg_neg v ▸ neg_neg w ▸ neg_le_neg _ _ hi h, fun h => neg_le_neg _ _ hi h⟩\n\n"}
{"name":"MeasureTheory.VectorMeasure.restrict_le_restrict_iUnion","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : OrderedAddCommMonoid M\ninst✝ : OrderClosedTopology M\nv w : MeasureTheory.VectorMeasure α M\nf : Nat → Set α\nhf₁ : ∀ (n : Nat), MeasurableSet (f n)\nhf₂ : ∀ (n : Nat), LE.le (v.restrict (f n)) (w.restrict (f n))\n⊢ LE.le (v.restrict (Set.iUnion fun n => f n)) (w.restrict (Set.iUnion fun n => f n))","decl":"theorem restrict_le_restrict_iUnion {f : ℕ → Set α} (hf₁ : ∀ n, MeasurableSet (f n))\n    (hf₂ : ∀ n, v ≤[f n] w) : v ≤[⋃ n, f n] w := by\n  refine restrict_le_restrict_of_subset_le v w fun a ha₁ ha₂ => ?_\n  have ha₃ : ⋃ n, a ∩ disjointed f n = a := by\n    rwa [← Set.inter_iUnion, iUnion_disjointed, Set.inter_eq_left]\n  have ha₄ : Pairwise (Disjoint on fun n => a ∩ disjointed f n) :=\n    (disjoint_disjointed _).mono fun i j => Disjoint.mono inf_le_right inf_le_right\n  rw [← ha₃, v.of_disjoint_iUnion _ ha₄, w.of_disjoint_iUnion _ ha₄]\n  · refine tsum_le_tsum (fun n => (restrict_le_restrict_iff v w (hf₁ n)).1 (hf₂ n) ?_ ?_) ?_ ?_\n    · exact ha₁.inter (MeasurableSet.disjointed hf₁ n)\n    · exact Set.Subset.trans Set.inter_subset_right (disjointed_subset _ _)\n    · refine (v.m_iUnion (fun n => ?_) ?_).summable\n      · exact ha₁.inter (MeasurableSet.disjointed hf₁ n)\n      · exact (disjoint_disjointed _).mono fun i j => Disjoint.mono inf_le_right inf_le_right\n    · refine (w.m_iUnion (fun n => ?_) ?_).summable\n      · exact ha₁.inter (MeasurableSet.disjointed hf₁ n)\n      · exact (disjoint_disjointed _).mono fun i j => Disjoint.mono inf_le_right inf_le_right\n  · intro n\n    exact ha₁.inter (MeasurableSet.disjointed hf₁ n)\n  · exact fun n => ha₁.inter (MeasurableSet.disjointed hf₁ n)\n\n"}
{"name":"MeasureTheory.VectorMeasure.restrict_le_restrict_countable_iUnion","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nM : Type u_3\ninst✝³ : TopologicalSpace M\ninst✝² : OrderedAddCommMonoid M\ninst✝¹ : OrderClosedTopology M\nv w : MeasureTheory.VectorMeasure α M\ninst✝ : Countable β\nf : β → Set α\nhf₁ : ∀ (b : β), MeasurableSet (f b)\nhf₂ : ∀ (b : β), LE.le (v.restrict (f b)) (w.restrict (f b))\n⊢ LE.le (v.restrict (Set.iUnion fun b => f b)) (w.restrict (Set.iUnion fun b => f b))","decl":"theorem restrict_le_restrict_countable_iUnion [Countable β] {f : β → Set α}\n    (hf₁ : ∀ b, MeasurableSet (f b)) (hf₂ : ∀ b, v ≤[f b] w) : v ≤[⋃ b, f b] w := by\n  cases nonempty_encodable β\n  rw [← Encodable.iUnion_decode₂]\n  refine restrict_le_restrict_iUnion v w ?_ ?_\n  · intro n\n    measurability\n  · intro n\n    cases' Encodable.decode₂ β n with b\n    · simp\n    · simp [hf₂ b]\n\n"}
{"name":"MeasureTheory.VectorMeasure.restrict_le_restrict_union","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝² : TopologicalSpace M\ninst✝¹ : OrderedAddCommMonoid M\ninst✝ : OrderClosedTopology M\nv w : MeasureTheory.VectorMeasure α M\ni j : Set α\nhi₁ : MeasurableSet i\nhi₂ : LE.le (v.restrict i) (w.restrict i)\nhj₁ : MeasurableSet j\nhj₂ : LE.le (v.restrict j) (w.restrict j)\n⊢ LE.le (v.restrict (Union.union i j)) (w.restrict (Union.union i j))","decl":"theorem restrict_le_restrict_union (hi₁ : MeasurableSet i) (hi₂ : v ≤[i] w) (hj₁ : MeasurableSet j)\n    (hj₂ : v ≤[j] w) : v ≤[i ∪ j] w := by\n  rw [Set.union_eq_iUnion]\n  refine restrict_le_restrict_countable_iUnion v w ?_ ?_\n  · measurability\n  · rintro (_ | _) <;> simpa\n\n"}
{"name":"MeasureTheory.VectorMeasure.nonneg_of_zero_le_restrict","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : OrderedAddCommMonoid M\nv : MeasureTheory.VectorMeasure α M\ni : Set α\nhi₂ : LE.le (MeasureTheory.VectorMeasure.restrict 0 i) (v.restrict i)\n⊢ LE.le 0 (↑v i)","decl":"theorem nonneg_of_zero_le_restrict (hi₂ : 0 ≤[i] v) : 0 ≤ v i := by\n  by_cases hi₁ : MeasurableSet i\n  · exact (restrict_le_restrict_iff _ _ hi₁).1 hi₂ hi₁ Set.Subset.rfl\n  · rw [v.not_measurable hi₁]\n\n"}
{"name":"MeasureTheory.VectorMeasure.nonpos_of_restrict_le_zero","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : OrderedAddCommMonoid M\nv : MeasureTheory.VectorMeasure α M\ni : Set α\nhi₂ : LE.le (v.restrict i) (MeasureTheory.VectorMeasure.restrict 0 i)\n⊢ LE.le (↑v i) 0","decl":"theorem nonpos_of_restrict_le_zero (hi₂ : v ≤[i] 0) : v i ≤ 0 := by\n  by_cases hi₁ : MeasurableSet i\n  · exact (restrict_le_restrict_iff _ _ hi₁).1 hi₂ hi₁ Set.Subset.rfl\n  · rw [v.not_measurable hi₁]\n\n"}
{"name":"MeasureTheory.VectorMeasure.zero_le_restrict_not_measurable","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : OrderedAddCommMonoid M\nv : MeasureTheory.VectorMeasure α M\ni : Set α\nhi : Not (MeasurableSet i)\n⊢ LE.le (MeasureTheory.VectorMeasure.restrict 0 i) (v.restrict i)","decl":"theorem zero_le_restrict_not_measurable (hi : ¬MeasurableSet i) : 0 ≤[i] v := by\n  rw [restrict_zero, restrict_not_measurable _ hi]\n\n"}
{"name":"MeasureTheory.VectorMeasure.restrict_le_zero_of_not_measurable","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : OrderedAddCommMonoid M\nv : MeasureTheory.VectorMeasure α M\ni : Set α\nhi : Not (MeasurableSet i)\n⊢ LE.le (v.restrict i) (MeasureTheory.VectorMeasure.restrict 0 i)","decl":"theorem restrict_le_zero_of_not_measurable (hi : ¬MeasurableSet i) : v ≤[i] 0 := by\n  rw [restrict_zero, restrict_not_measurable _ hi]\n\n"}
{"name":"MeasureTheory.VectorMeasure.measurable_of_not_zero_le_restrict","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : OrderedAddCommMonoid M\nv : MeasureTheory.VectorMeasure α M\ni : Set α\nhi : Not (LE.le (MeasureTheory.VectorMeasure.restrict 0 i) (v.restrict i))\n⊢ MeasurableSet i","decl":"theorem measurable_of_not_zero_le_restrict (hi : ¬0 ≤[i] v) : MeasurableSet i :=\n  Not.imp_symm (zero_le_restrict_not_measurable _) hi\n\n"}
{"name":"MeasureTheory.VectorMeasure.measurable_of_not_restrict_le_zero","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : OrderedAddCommMonoid M\nv : MeasureTheory.VectorMeasure α M\ni : Set α\nhi : Not (LE.le (v.restrict i) (MeasureTheory.VectorMeasure.restrict 0 i))\n⊢ MeasurableSet i","decl":"theorem measurable_of_not_restrict_le_zero (hi : ¬v ≤[i] 0) : MeasurableSet i :=\n  Not.imp_symm (restrict_le_zero_of_not_measurable _) hi\n\n"}
{"name":"MeasureTheory.VectorMeasure.zero_le_restrict_subset","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : OrderedAddCommMonoid M\nv : MeasureTheory.VectorMeasure α M\ni j : Set α\nhi₁ : MeasurableSet i\nhij : HasSubset.Subset j i\nhi₂ : LE.le (MeasureTheory.VectorMeasure.restrict 0 i) (v.restrict i)\n⊢ LE.le (MeasureTheory.VectorMeasure.restrict 0 j) (v.restrict j)","decl":"theorem zero_le_restrict_subset (hi₁ : MeasurableSet i) (hij : j ⊆ i) (hi₂ : 0 ≤[i] v) : 0 ≤[j] v :=\n  restrict_le_restrict_of_subset_le _ _ fun _ hk₁ hk₂ =>\n    (restrict_le_restrict_iff _ _ hi₁).1 hi₂ hk₁ (Set.Subset.trans hk₂ hij)\n\n"}
{"name":"MeasureTheory.VectorMeasure.restrict_le_zero_subset","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : OrderedAddCommMonoid M\nv : MeasureTheory.VectorMeasure α M\ni j : Set α\nhi₁ : MeasurableSet i\nhij : HasSubset.Subset j i\nhi₂ : LE.le (v.restrict i) (MeasureTheory.VectorMeasure.restrict 0 i)\n⊢ LE.le (v.restrict j) (MeasureTheory.VectorMeasure.restrict 0 j)","decl":"theorem restrict_le_zero_subset (hi₁ : MeasurableSet i) (hij : j ⊆ i) (hi₂ : v ≤[i] 0) : v ≤[j] 0 :=\n  restrict_le_restrict_of_subset_le _ _ fun _ hk₁ hk₂ =>\n    (restrict_le_restrict_iff _ _ hi₁).1 hi₂ hk₁ (Set.Subset.trans hk₂ hij)\n\n"}
{"name":"MeasureTheory.VectorMeasure.exists_pos_measure_of_not_restrict_le_zero","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : LinearOrderedAddCommMonoid M\nv : MeasureTheory.VectorMeasure α M\ni : Set α\nhi : Not (LE.le (v.restrict i) (MeasureTheory.VectorMeasure.restrict 0 i))\n⊢ Exists fun j => And (MeasurableSet j) (And (HasSubset.Subset j i) (LT.lt 0 (↑v j)))","decl":"theorem exists_pos_measure_of_not_restrict_le_zero (hi : ¬v ≤[i] 0) :\n    ∃ j : Set α, MeasurableSet j ∧ j ⊆ i ∧ 0 < v j := by\n  have hi₁ : MeasurableSet i := measurable_of_not_restrict_le_zero _ hi\n  rw [restrict_le_restrict_iff _ _ hi₁] at hi\n  push_neg at hi\n  exact hi\n\n"}
{"name":"MeasureTheory.VectorMeasure.instAddLeftMono","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_3\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid M\ninst✝² : PartialOrder M\ninst✝¹ : AddLeftMono M\ninst✝ : ContinuousAdd M\n⊢ AddLeftMono (MeasureTheory.VectorMeasure α M)","decl":"instance instAddLeftMono : AddLeftMono (VectorMeasure α M) :=\n  ⟨fun _ _ _ h i hi => add_le_add_left (h i hi) _⟩\n\n"}
{"name":"MeasureTheory.VectorMeasure.AbsolutelyContinuous.mk","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\nN : Type u_5\ninst✝³ : AddCommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid N\ninst✝ : TopologicalSpace N\nv : MeasureTheory.VectorMeasure α M\nw : MeasureTheory.VectorMeasure α N\nh : ∀ ⦃s : Set α⦄, MeasurableSet s → Eq (↑w s) 0 → Eq (↑v s) 0\n⊢ v.AbsolutelyContinuous w","decl":"theorem mk (h : ∀ ⦃s : Set α⦄, MeasurableSet s → w s = 0 → v s = 0) : v ≪ᵥ w := by\n  intro s hs\n  by_cases hmeas : MeasurableSet s\n  · exact h hmeas hs\n  · exact not_measurable v hmeas\n\n"}
{"name":"MeasureTheory.VectorMeasure.AbsolutelyContinuous.eq","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nv w : MeasureTheory.VectorMeasure α M\nh : Eq v w\n⊢ v.AbsolutelyContinuous w","decl":"theorem eq {w : VectorMeasure α M} (h : v = w) : v ≪ᵥ w :=\n  fun _ hs => h.symm ▸ hs\n\n"}
{"name":"MeasureTheory.VectorMeasure.AbsolutelyContinuous.refl","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nv : MeasureTheory.VectorMeasure α M\n⊢ v.AbsolutelyContinuous v","decl":"@[refl]\ntheorem refl (v : VectorMeasure α M) : v ≪ᵥ v :=\n  eq rfl\n\n"}
{"name":"MeasureTheory.VectorMeasure.AbsolutelyContinuous.trans","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nL : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁵ : AddCommMonoid L\ninst✝⁴ : TopologicalSpace L\ninst✝³ : AddCommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid N\ninst✝ : TopologicalSpace N\nu : MeasureTheory.VectorMeasure α L\nv : MeasureTheory.VectorMeasure α M\nw : MeasureTheory.VectorMeasure α N\nhuv : u.AbsolutelyContinuous v\nhvw : v.AbsolutelyContinuous w\n⊢ u.AbsolutelyContinuous w","decl":"@[trans]\ntheorem trans {u : VectorMeasure α L} {v : VectorMeasure α M} {w : VectorMeasure α N} (huv : u ≪ᵥ v)\n    (hvw : v ≪ᵥ w) : u ≪ᵥ w :=\n  fun _ hs => huv <| hvw hs\n\n"}
{"name":"MeasureTheory.VectorMeasure.AbsolutelyContinuous.zero","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\nN : Type u_5\ninst✝³ : AddCommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid N\ninst✝ : TopologicalSpace N\nv : MeasureTheory.VectorMeasure α N\n⊢ MeasureTheory.VectorMeasure.AbsolutelyContinuous 0 v","decl":"theorem zero (v : VectorMeasure α N) : (0 : VectorMeasure α M) ≪ᵥ v :=\n  fun s _ => VectorMeasure.zero_apply s\n\n"}
{"name":"MeasureTheory.VectorMeasure.AbsolutelyContinuous.neg_left","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nN : Type u_5\ninst✝⁴ : AddCommMonoid N\ninst✝³ : TopologicalSpace N\nM : Type u_6\ninst✝² : AddCommGroup M\ninst✝¹ : TopologicalSpace M\ninst✝ : TopologicalAddGroup M\nv : MeasureTheory.VectorMeasure α M\nw : MeasureTheory.VectorMeasure α N\nh : v.AbsolutelyContinuous w\n⊢ (Neg.neg v).AbsolutelyContinuous w","decl":"theorem neg_left {M : Type*} [AddCommGroup M] [TopologicalSpace M] [TopologicalAddGroup M]\n    {v : VectorMeasure α M} {w : VectorMeasure α N} (h : v ≪ᵥ w) : -v ≪ᵥ w := by\n  intro s hs\n  rw [neg_apply, h hs, neg_zero]\n\n"}
{"name":"MeasureTheory.VectorMeasure.AbsolutelyContinuous.neg_right","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\ninst✝⁴ : AddCommMonoid M\ninst✝³ : TopologicalSpace M\nN : Type u_6\ninst✝² : AddCommGroup N\ninst✝¹ : TopologicalSpace N\ninst✝ : TopologicalAddGroup N\nv : MeasureTheory.VectorMeasure α M\nw : MeasureTheory.VectorMeasure α N\nh : v.AbsolutelyContinuous w\n⊢ v.AbsolutelyContinuous (Neg.neg w)","decl":"theorem neg_right {N : Type*} [AddCommGroup N] [TopologicalSpace N] [TopologicalAddGroup N]\n    {v : VectorMeasure α M} {w : VectorMeasure α N} (h : v ≪ᵥ w) : v ≪ᵥ -w := by\n  intro s hs\n  rw [neg_apply, neg_eq_zero] at hs\n  exact h hs\n\n"}
{"name":"MeasureTheory.VectorMeasure.AbsolutelyContinuous.add","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\nN : Type u_5\ninst✝⁴ : AddCommMonoid M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : TopologicalSpace N\ninst✝ : ContinuousAdd M\nv₁ v₂ : MeasureTheory.VectorMeasure α M\nw : MeasureTheory.VectorMeasure α N\nhv₁ : v₁.AbsolutelyContinuous w\nhv₂ : v₂.AbsolutelyContinuous w\n⊢ (HAdd.hAdd v₁ v₂).AbsolutelyContinuous w","decl":"theorem add [ContinuousAdd M] {v₁ v₂ : VectorMeasure α M} {w : VectorMeasure α N} (hv₁ : v₁ ≪ᵥ w)\n    (hv₂ : v₂ ≪ᵥ w) : v₁ + v₂ ≪ᵥ w := by\n  intro s hs\n  rw [add_apply, hv₁ hs, hv₂ hs, zero_add]\n\n"}
{"name":"MeasureTheory.VectorMeasure.AbsolutelyContinuous.sub","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nN : Type u_5\ninst✝⁴ : AddCommMonoid N\ninst✝³ : TopologicalSpace N\nM : Type u_6\ninst✝² : AddCommGroup M\ninst✝¹ : TopologicalSpace M\ninst✝ : TopologicalAddGroup M\nv₁ v₂ : MeasureTheory.VectorMeasure α M\nw : MeasureTheory.VectorMeasure α N\nhv₁ : v₁.AbsolutelyContinuous w\nhv₂ : v₂.AbsolutelyContinuous w\n⊢ (HSub.hSub v₁ v₂).AbsolutelyContinuous w","decl":"theorem sub {M : Type*} [AddCommGroup M] [TopologicalSpace M] [TopologicalAddGroup M]\n    {v₁ v₂ : VectorMeasure α M} {w : VectorMeasure α N} (hv₁ : v₁ ≪ᵥ w) (hv₂ : v₂ ≪ᵥ w) :\n    v₁ - v₂ ≪ᵥ w := by\n  intro s hs\n  rw [sub_apply, hv₁ hs, hv₂ hs, zero_sub, neg_zero]\n\n"}
{"name":"MeasureTheory.VectorMeasure.AbsolutelyContinuous.smul","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\nN : Type u_5\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : TopologicalSpace N\nR : Type u_6\ninst✝² : Semiring R\ninst✝¹ : DistribMulAction R M\ninst✝ : ContinuousConstSMul R M\nr : R\nv : MeasureTheory.VectorMeasure α M\nw : MeasureTheory.VectorMeasure α N\nh : v.AbsolutelyContinuous w\n⊢ (HSMul.hSMul r v).AbsolutelyContinuous w","decl":"theorem smul {R : Type*} [Semiring R] [DistribMulAction R M] [ContinuousConstSMul R M] {r : R}\n    {v : VectorMeasure α M} {w : VectorMeasure α N} (h : v ≪ᵥ w) : r • v ≪ᵥ w := by\n  intro s hs\n  rw [smul_apply, h hs, smul_zero]\n\n"}
{"name":"MeasureTheory.VectorMeasure.AbsolutelyContinuous.map","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nM : Type u_4\nN : Type u_5\ninst✝⁴ : AddCommMonoid M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : TopologicalSpace N\nv : MeasureTheory.VectorMeasure α M\nw : MeasureTheory.VectorMeasure α N\ninst✝ : MeasureTheory.MeasureSpace β\nh : v.AbsolutelyContinuous w\nf : α → β\n⊢ (v.map f).AbsolutelyContinuous (w.map f)","decl":"theorem map [MeasureSpace β] (h : v ≪ᵥ w) (f : α → β) : v.map f ≪ᵥ w.map f := by\n  by_cases hf : Measurable f\n  · refine mk fun s hs hws => ?_\n    rw [map_apply _ hf hs] at hws ⊢\n    exact h hws\n  · intro s _\n    rw [map_not_measurable v hf, zero_apply]\n\n"}
{"name":"MeasureTheory.VectorMeasure.AbsolutelyContinuous.ennrealToMeasure","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nv : MeasureTheory.VectorMeasure α M\nμ : MeasureTheory.VectorMeasure α ENNReal\n⊢ Iff (∀ ⦃s : Set α⦄, Eq (μ.ennrealToMeasure s) 0 → Eq (↑v s) 0) (v.AbsolutelyContinuous μ)","decl":"theorem ennrealToMeasure {μ : VectorMeasure α ℝ≥0∞} :\n    (∀ ⦃s : Set α⦄, μ.ennrealToMeasure s = 0 → v s = 0) ↔ v ≪ᵥ μ := by\n  constructor <;> intro h\n  · refine mk fun s hmeas hs => h ?_\n    rw [← hs, ennrealToMeasure_apply hmeas]\n  · intro s hs\n    by_cases hmeas : MeasurableSet s\n    · rw [ennrealToMeasure_apply hmeas] at hs\n      exact h hs\n    · exact not_measurable v hmeas\n\n"}
{"name":"MeasureTheory.VectorMeasure.MutuallySingular.mk","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\nN : Type u_5\ninst✝³ : AddCommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid N\ninst✝ : TopologicalSpace N\nv : MeasureTheory.VectorMeasure α M\nw : MeasureTheory.VectorMeasure α N\ns : Set α\nhs : MeasurableSet s\nh₁ : ∀ (t : Set α), HasSubset.Subset t s → MeasurableSet t → Eq (↑v t) 0\nh₂ : ∀ (t : Set α), HasSubset.Subset t (HasCompl.compl s) → MeasurableSet t → Eq (↑w t) 0\n⊢ v.MutuallySingular w","decl":"theorem mk (s : Set α) (hs : MeasurableSet s) (h₁ : ∀ t ⊆ s, MeasurableSet t → v t = 0)\n    (h₂ : ∀ t ⊆ sᶜ, MeasurableSet t → w t = 0) : v ⟂ᵥ w := by\n  refine ⟨s, hs, fun t hst => ?_, fun t hst => ?_⟩ <;> by_cases ht : MeasurableSet t\n  · exact h₁ t hst ht\n  · exact not_measurable v ht\n  · exact h₂ t hst ht\n  · exact not_measurable w ht\n\n"}
{"name":"MeasureTheory.VectorMeasure.MutuallySingular.symm","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\nN : Type u_5\ninst✝³ : AddCommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid N\ninst✝ : TopologicalSpace N\nv : MeasureTheory.VectorMeasure α M\nw : MeasureTheory.VectorMeasure α N\nh : v.MutuallySingular w\n⊢ w.MutuallySingular v","decl":"theorem symm (h : v ⟂ᵥ w) : w ⟂ᵥ v :=\n  let ⟨s, hmeas, hs₁, hs₂⟩ := h\n  ⟨sᶜ, hmeas.compl, hs₂, fun t ht => hs₁ _ (compl_compl s ▸ ht : t ⊆ s)⟩\n\n"}
{"name":"MeasureTheory.VectorMeasure.MutuallySingular.zero_right","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\nN : Type u_5\ninst✝³ : AddCommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid N\ninst✝ : TopologicalSpace N\nv : MeasureTheory.VectorMeasure α M\n⊢ v.MutuallySingular 0","decl":"theorem zero_right : v ⟂ᵥ (0 : VectorMeasure α N) :=\n  ⟨∅, MeasurableSet.empty, fun _ ht => (Set.subset_empty_iff.1 ht).symm ▸ v.empty,\n    fun _ _ => zero_apply _⟩\n\n"}
{"name":"MeasureTheory.VectorMeasure.MutuallySingular.zero_left","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\nN : Type u_5\ninst✝³ : AddCommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : AddCommMonoid N\ninst✝ : TopologicalSpace N\nw : MeasureTheory.VectorMeasure α N\n⊢ MeasureTheory.VectorMeasure.MutuallySingular 0 w","decl":"theorem zero_left : (0 : VectorMeasure α M) ⟂ᵥ w :=\n  zero_right.symm\n\n"}
{"name":"MeasureTheory.VectorMeasure.MutuallySingular.add_left","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\nN : Type u_5\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : TopologicalSpace N\nv₁ v₂ : MeasureTheory.VectorMeasure α M\nw : MeasureTheory.VectorMeasure α N\ninst✝¹ : T2Space N\ninst✝ : ContinuousAdd M\nh₁ : v₁.MutuallySingular w\nh₂ : v₂.MutuallySingular w\n⊢ (HAdd.hAdd v₁ v₂).MutuallySingular w","decl":"theorem add_left [T2Space N] [ContinuousAdd M] (h₁ : v₁ ⟂ᵥ w) (h₂ : v₂ ⟂ᵥ w) : v₁ + v₂ ⟂ᵥ w := by\n  obtain ⟨u, hmu, hu₁, hu₂⟩ := h₁\n  obtain ⟨v, hmv, hv₁, hv₂⟩ := h₂\n  refine mk (u ∩ v) (hmu.inter hmv) (fun t ht _ => ?_) fun t ht hmt => ?_\n  · rw [add_apply, hu₁ _ (Set.subset_inter_iff.1 ht).1, hv₁ _ (Set.subset_inter_iff.1 ht).2,\n      zero_add]\n  · rw [Set.compl_inter] at ht\n    rw [(_ : t = uᶜ ∩ t ∪ vᶜ \\ uᶜ ∩ t),\n      of_union _ (hmu.compl.inter hmt) ((hmv.compl.diff hmu.compl).inter hmt), hu₂, hv₂, add_zero]\n    · exact Set.Subset.trans Set.inter_subset_left diff_subset\n    · exact Set.inter_subset_left\n    · exact disjoint_sdiff_self_right.mono Set.inter_subset_left Set.inter_subset_left\n    · apply Set.Subset.antisymm <;> intro x hx\n      · by_cases hxu' : x ∈ uᶜ\n        · exact Or.inl ⟨hxu', hx⟩\n        rcases ht hx with (hxu | hxv)\n        exacts [False.elim (hxu' hxu), Or.inr ⟨⟨hxv, hxu'⟩, hx⟩]\n      · cases' hx with hx hx <;> exact hx.2\n\n"}
{"name":"MeasureTheory.VectorMeasure.MutuallySingular.add_right","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\nN : Type u_5\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : TopologicalSpace N\nv : MeasureTheory.VectorMeasure α M\nw₁ w₂ : MeasureTheory.VectorMeasure α N\ninst✝¹ : T2Space M\ninst✝ : ContinuousAdd N\nh₁ : v.MutuallySingular w₁\nh₂ : v.MutuallySingular w₂\n⊢ v.MutuallySingular (HAdd.hAdd w₁ w₂)","decl":"theorem add_right [T2Space M] [ContinuousAdd N] (h₁ : v ⟂ᵥ w₁) (h₂ : v ⟂ᵥ w₂) : v ⟂ᵥ w₁ + w₂ :=\n  (add_left h₁.symm h₂.symm).symm\n\n"}
{"name":"MeasureTheory.VectorMeasure.MutuallySingular.smul_right","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\nN : Type u_5\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : TopologicalSpace N\nv : MeasureTheory.VectorMeasure α M\nw : MeasureTheory.VectorMeasure α N\nR : Type u_6\ninst✝² : Semiring R\ninst✝¹ : DistribMulAction R N\ninst✝ : ContinuousConstSMul R N\nr : R\nh : v.MutuallySingular w\n⊢ v.MutuallySingular (HSMul.hSMul r w)","decl":"theorem smul_right {R : Type*} [Semiring R] [DistribMulAction R N] [ContinuousConstSMul R N]\n    (r : R) (h : v ⟂ᵥ w) : v ⟂ᵥ r • w :=\n  let ⟨s, hmeas, hs₁, hs₂⟩ := h\n  ⟨s, hmeas, hs₁, fun t ht => by simp only [coe_smul, Pi.smul_apply, hs₂ t ht, smul_zero]⟩\n\n"}
{"name":"MeasureTheory.VectorMeasure.MutuallySingular.smul_left","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\nN : Type u_5\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : TopologicalSpace N\nv : MeasureTheory.VectorMeasure α M\nw : MeasureTheory.VectorMeasure α N\nR : Type u_6\ninst✝² : Semiring R\ninst✝¹ : DistribMulAction R M\ninst✝ : ContinuousConstSMul R M\nr : R\nh : v.MutuallySingular w\n⊢ (HSMul.hSMul r v).MutuallySingular w","decl":"theorem smul_left {R : Type*} [Semiring R] [DistribMulAction R M] [ContinuousConstSMul R M] (r : R)\n    (h : v ⟂ᵥ w) : r • v ⟂ᵥ w :=\n  (smul_right r h.symm).symm\n\n"}
{"name":"MeasureTheory.VectorMeasure.MutuallySingular.neg_left","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nN : Type u_5\ninst✝⁴ : AddCommMonoid N\ninst✝³ : TopologicalSpace N\nM : Type u_6\ninst✝² : AddCommGroup M\ninst✝¹ : TopologicalSpace M\ninst✝ : TopologicalAddGroup M\nv : MeasureTheory.VectorMeasure α M\nw : MeasureTheory.VectorMeasure α N\nh : v.MutuallySingular w\n⊢ (Neg.neg v).MutuallySingular w","decl":"theorem neg_left {M : Type*} [AddCommGroup M] [TopologicalSpace M] [TopologicalAddGroup M]\n    {v : VectorMeasure α M} {w : VectorMeasure α N} (h : v ⟂ᵥ w) : -v ⟂ᵥ w := by\n  obtain ⟨u, hmu, hu₁, hu₂⟩ := h\n  refine ⟨u, hmu, fun s hs => ?_, hu₂⟩\n  rw [neg_apply v s, neg_eq_zero]\n  exact hu₁ s hs\n\n"}
{"name":"MeasureTheory.VectorMeasure.MutuallySingular.neg_right","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\ninst✝⁴ : AddCommMonoid M\ninst✝³ : TopologicalSpace M\nN : Type u_6\ninst✝² : AddCommGroup N\ninst✝¹ : TopologicalSpace N\ninst✝ : TopologicalAddGroup N\nv : MeasureTheory.VectorMeasure α M\nw : MeasureTheory.VectorMeasure α N\nh : v.MutuallySingular w\n⊢ v.MutuallySingular (Neg.neg w)","decl":"theorem neg_right {N : Type*} [AddCommGroup N] [TopologicalSpace N] [TopologicalAddGroup N]\n    {v : VectorMeasure α M} {w : VectorMeasure α N} (h : v ⟂ᵥ w) : v ⟂ᵥ -w :=\n  h.symm.neg_left.symm\n\n"}
{"name":"MeasureTheory.VectorMeasure.MutuallySingular.neg_left_iff","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nN : Type u_5\ninst✝⁴ : AddCommMonoid N\ninst✝³ : TopologicalSpace N\nM : Type u_6\ninst✝² : AddCommGroup M\ninst✝¹ : TopologicalSpace M\ninst✝ : TopologicalAddGroup M\nv : MeasureTheory.VectorMeasure α M\nw : MeasureTheory.VectorMeasure α N\n⊢ Iff ((Neg.neg v).MutuallySingular w) (v.MutuallySingular w)","decl":"@[simp]\ntheorem neg_left_iff {M : Type*} [AddCommGroup M] [TopologicalSpace M] [TopologicalAddGroup M]\n    {v : VectorMeasure α M} {w : VectorMeasure α N} : -v ⟂ᵥ w ↔ v ⟂ᵥ w :=\n  ⟨fun h => neg_neg v ▸ h.neg_left, neg_left⟩\n\n"}
{"name":"MeasureTheory.VectorMeasure.MutuallySingular.neg_right_iff","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\ninst✝⁴ : AddCommMonoid M\ninst✝³ : TopologicalSpace M\nN : Type u_6\ninst✝² : AddCommGroup N\ninst✝¹ : TopologicalSpace N\ninst✝ : TopologicalAddGroup N\nv : MeasureTheory.VectorMeasure α M\nw : MeasureTheory.VectorMeasure α N\n⊢ Iff (v.MutuallySingular (Neg.neg w)) (v.MutuallySingular w)","decl":"@[simp]\ntheorem neg_right_iff {N : Type*} [AddCommGroup N] [TopologicalSpace N] [TopologicalAddGroup N]\n    {v : VectorMeasure α M} {w : VectorMeasure α N} : v ⟂ᵥ -w ↔ v ⟂ᵥ w :=\n  ⟨fun h => neg_neg w ▸ h.neg_right, neg_right⟩\n\n"}
{"name":"MeasureTheory.VectorMeasure.trim_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nm n : MeasurableSpace α\nv : MeasureTheory.VectorMeasure α M\nhle : LE.le m n\ni : Set α\n⊢ Eq (↑(v.trim hle) i) (ite (MeasurableSet i) (↑v i) 0)","decl":"open Classical in\n/-- Restriction of a vector measure onto a sub-σ-algebra. -/\n@[simps]\ndef trim {m n : MeasurableSpace α} (v : VectorMeasure α M) (hle : m ≤ n) :\n    @VectorMeasure α m M _ _ :=\n  @VectorMeasure.mk α m M _ _\n    (fun i => if MeasurableSet[m] i then v i else 0)\n    (by dsimp only; rw [if_pos (@MeasurableSet.empty _ m), v.empty])\n    (fun i hi => by dsimp only; rw [if_neg hi])\n    (fun f hf₁ hf₂ => by\n      dsimp only\n      have hf₁' : ∀ k, MeasurableSet[n] (f k) := fun k => hle _ (hf₁ k)\n      convert v.m_iUnion hf₁' hf₂ using 1\n      · ext n\n        rw [if_pos (hf₁ n)]\n      · rw [if_pos (@MeasurableSet.iUnion _ _ m _ _ hf₁)])\n\n"}
{"name":"MeasureTheory.VectorMeasure.trim_eq_self","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nn : MeasurableSpace α\nv : MeasureTheory.VectorMeasure α M\n⊢ Eq (v.trim ⋯) v","decl":"theorem trim_eq_self : v.trim le_rfl = v := by\n  ext i hi\n  exact if_pos hi\n\n"}
{"name":"MeasureTheory.VectorMeasure.zero_trim","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nn : MeasurableSpace α\nhle : LE.le m n\n⊢ Eq (MeasureTheory.VectorMeasure.trim 0 hle) 0","decl":"@[simp]\ntheorem zero_trim (hle : m ≤ n) : (0 : VectorMeasure α M).trim hle = 0 := by\n  ext i hi\n  exact if_pos hi\n\n"}
{"name":"MeasureTheory.VectorMeasure.trim_measurableSet_eq","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nn : MeasurableSpace α\nv : MeasureTheory.VectorMeasure α M\nhle : LE.le m n\ni : Set α\nhi : MeasurableSet i\n⊢ Eq (↑(v.trim hle) i) (↑v i)","decl":"theorem trim_measurableSet_eq (hle : m ≤ n) {i : Set α} (hi : MeasurableSet[m] i) :\n    v.trim hle i = v i :=\n  if_pos hi\n\n"}
{"name":"MeasureTheory.VectorMeasure.restrict_trim","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nn : MeasurableSpace α\nv : MeasureTheory.VectorMeasure α M\nhle : LE.le m n\ni : Set α\nhi : MeasurableSet i\n⊢ Eq ((v.trim hle).restrict i) ((v.restrict i).trim hle)","decl":"theorem restrict_trim (hle : m ≤ n) {i : Set α} (hi : MeasurableSet[m] i) :\n    @VectorMeasure.restrict α m M _ _ (v.trim hle) i = (v.restrict i).trim hle := by\n  ext j hj\n  rw [@restrict_apply _ m, trim_measurableSet_eq hle hj, restrict_apply, trim_measurableSet_eq]\n  all_goals measurability\n\n"}
{"name":"MeasureTheory.SignedMeasure.toMeasureOfZeroLE_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\ni j : Set α\nhi : LE.le (MeasureTheory.VectorMeasure.restrict 0 i) (MeasureTheory.VectorMeasure.restrict s i)\nhi₁ : MeasurableSet i\nhj₁ : MeasurableSet j\n⊢ Eq ((s.toMeasureOfZeroLE i hi₁ hi) j) ↑⟨↑s (Inter.inter i j), ⋯⟩","decl":"theorem toMeasureOfZeroLE_apply (hi : 0 ≤[i] s) (hi₁ : MeasurableSet i) (hj₁ : MeasurableSet j) :\n    s.toMeasureOfZeroLE i hi₁ hi j = ((↑) : ℝ≥0 → ℝ≥0∞) ⟨s (i ∩ j), nonneg_of_zero_le_restrict\n      s (zero_le_restrict_subset s hi₁ Set.inter_subset_left hi)⟩ := by\n  simp_rw [toMeasureOfZeroLE, Measure.ofMeasurable_apply _ hj₁, toMeasureOfZeroLE',\n    s.restrict_apply hi₁ hj₁, Set.inter_comm]\n\n"}
{"name":"MeasureTheory.SignedMeasure.toMeasureOfLEZero_apply","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\ni j : Set α\nhi : LE.le (MeasureTheory.VectorMeasure.restrict s i) (MeasureTheory.VectorMeasure.restrict 0 i)\nhi₁ : MeasurableSet i\nhj₁ : MeasurableSet j\n⊢ Eq ((s.toMeasureOfLEZero i hi₁ hi) j) ↑⟨Neg.neg (↑s (Inter.inter i j)), ⋯⟩","decl":"theorem toMeasureOfLEZero_apply (hi : s ≤[i] 0) (hi₁ : MeasurableSet i) (hj₁ : MeasurableSet j) :\n    s.toMeasureOfLEZero i hi₁ hi j = ((↑) : ℝ≥0 → ℝ≥0∞) ⟨-s (i ∩ j), neg_apply s (i ∩ j) ▸\n      nonneg_of_zero_le_restrict _ (zero_le_restrict_subset _ hi₁ Set.inter_subset_left\n      (@neg_zero (VectorMeasure α ℝ) _ ▸ neg_le_neg _ _ hi₁ hi))⟩ := by\n  erw [toMeasureOfZeroLE_apply]\n  · simp\n  · assumption\n\n"}
{"name":"MeasureTheory.SignedMeasure.toMeasureOfZeroLE_finite","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\ni : Set α\nhi : LE.le (MeasureTheory.VectorMeasure.restrict 0 i) (MeasureTheory.VectorMeasure.restrict s i)\nhi₁ : MeasurableSet i\n⊢ MeasureTheory.IsFiniteMeasure (s.toMeasureOfZeroLE i hi₁ hi)","decl":"/-- `SignedMeasure.toMeasureOfZeroLE` is a finite measure. -/\ninstance toMeasureOfZeroLE_finite (hi : 0 ≤[i] s) (hi₁ : MeasurableSet i) :\n    IsFiniteMeasure (s.toMeasureOfZeroLE i hi₁ hi) where\n  measure_univ_lt_top := by\n    rw [toMeasureOfZeroLE_apply s hi hi₁ MeasurableSet.univ]\n    exact ENNReal.coe_lt_top\n\n"}
{"name":"MeasureTheory.SignedMeasure.toMeasureOfLEZero_finite","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\ni : Set α\nhi : LE.le (MeasureTheory.VectorMeasure.restrict s i) (MeasureTheory.VectorMeasure.restrict 0 i)\nhi₁ : MeasurableSet i\n⊢ MeasureTheory.IsFiniteMeasure (s.toMeasureOfLEZero i hi₁ hi)","decl":"/-- `SignedMeasure.toMeasureOfLEZero` is a finite measure. -/\ninstance toMeasureOfLEZero_finite (hi : s ≤[i] 0) (hi₁ : MeasurableSet i) :\n    IsFiniteMeasure (s.toMeasureOfLEZero i hi₁ hi) where\n  measure_univ_lt_top := by\n    rw [toMeasureOfLEZero_apply s hi hi₁ MeasurableSet.univ]\n    exact ENNReal.coe_lt_top\n\n"}
{"name":"MeasureTheory.SignedMeasure.toMeasureOfZeroLE_toSignedMeasure","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nhs : LE.le (MeasureTheory.VectorMeasure.restrict 0 Set.univ) (MeasureTheory.VectorMeasure.restrict s Set.univ)\n⊢ Eq (s.toMeasureOfZeroLE Set.univ ⋯ hs).toSignedMeasure s","decl":"theorem toMeasureOfZeroLE_toSignedMeasure (hs : 0 ≤[Set.univ] s) :\n    (s.toMeasureOfZeroLE Set.univ MeasurableSet.univ hs).toSignedMeasure = s := by\n  ext i hi\n  simp [hi, toMeasureOfZeroLE_apply _ _ _ hi]\n\n"}
{"name":"MeasureTheory.SignedMeasure.toMeasureOfLEZero_toSignedMeasure","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nhs : LE.le (MeasureTheory.VectorMeasure.restrict s Set.univ) (MeasureTheory.VectorMeasure.restrict 0 Set.univ)\n⊢ Eq (s.toMeasureOfLEZero Set.univ ⋯ hs).toSignedMeasure (Neg.neg s)","decl":"theorem toMeasureOfLEZero_toSignedMeasure (hs : s ≤[Set.univ] 0) :\n    (s.toMeasureOfLEZero Set.univ MeasurableSet.univ hs).toSignedMeasure = -s := by\n  ext i hi\n  simp [hi, toMeasureOfLEZero_apply _ _ _ hi]\n\n"}
{"name":"MeasureTheory.Measure.zero_le_toSignedMeasure","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ LE.le 0 μ.toSignedMeasure","decl":"theorem zero_le_toSignedMeasure : 0 ≤ μ.toSignedMeasure := by\n  rw [← le_restrict_univ_iff_le]\n  refine restrict_le_restrict_of_subset_le _ _ fun j hj₁ _ => ?_\n  simp only [Measure.toSignedMeasure_apply_measurable hj₁, coe_zero, Pi.zero_apply,\n    ENNReal.toReal_nonneg, VectorMeasure.coe_zero]\n\n"}
{"name":"MeasureTheory.Measure.toSignedMeasure_toMeasureOfZeroLE","module":"Mathlib.MeasureTheory.VectorMeasure.Basic","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Eq (μ.toSignedMeasure.toMeasureOfZeroLE Set.univ ⋯ ⋯) μ","decl":"theorem toSignedMeasure_toMeasureOfZeroLE :\n    μ.toSignedMeasure.toMeasureOfZeroLE Set.univ MeasurableSet.univ\n      ((le_restrict_univ_iff_le _ _).2 (zero_le_toSignedMeasure μ)) = μ := by\n  refine Measure.ext fun i hi => ?_\n  lift μ i to ℝ≥0 using (measure_lt_top _ _).ne with m hm\n  rw [SignedMeasure.toMeasureOfZeroLE_apply _ _ _ hi, ENNReal.coe_inj]\n  congr\n  simp [hi, ← hm]\n\n"}
