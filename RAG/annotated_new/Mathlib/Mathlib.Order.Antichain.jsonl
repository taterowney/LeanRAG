{"name":"Symmetric.compl","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\nh : Symmetric r\n⊢ Symmetric (HasCompl.compl r)","decl":"protected theorem Symmetric.compl (h : Symmetric r) : Symmetric rᶜ := fun _ _ hr hr' =>\n  hr <| h hr'\n\n"}
{"name":"IsAntichain.subset","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns t : Set α\nhs : IsAntichain r s\nh : HasSubset.Subset t s\n⊢ IsAntichain r t","decl":"protected theorem subset (hs : IsAntichain r s) (h : t ⊆ s) : IsAntichain r t :=\n  hs.mono h\n\n"}
{"name":"IsAntichain.mono","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr₁ r₂ : α → α → Prop\ns : Set α\nhs : IsAntichain r₁ s\nh : LE.le r₂ r₁\n⊢ IsAntichain r₂ s","decl":"theorem mono (hs : IsAntichain r₁ s) (h : r₂ ≤ r₁) : IsAntichain r₂ s :=\n  hs.mono' <| compl_le_compl h\n\n"}
{"name":"IsAntichain.mono_on","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr₁ r₂ : α → α → Prop\ns : Set α\nhs : IsAntichain r₁ s\nh : s.Pairwise fun ⦃a b⦄ => r₂ a b → r₁ a b\n⊢ IsAntichain r₂ s","decl":"theorem mono_on (hs : IsAntichain r₁ s) (h : s.Pairwise fun ⦃a b⦄ => r₂ a b → r₁ a b) :\n    IsAntichain r₂ s :=\n  hs.imp_on <| h.imp fun _ _ h h₁ h₂ => h₁ <| h h₂\n\n"}
{"name":"IsAntichain.eq","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\nhs : IsAntichain r s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\nh : r a b\n⊢ Eq a b","decl":"protected theorem eq (hs : IsAntichain r s) {a b : α} (ha : a ∈ s) (hb : b ∈ s) (h : r a b) :\n    a = b :=\n  Set.Pairwise.eq hs ha hb <| not_not_intro h\n\n"}
{"name":"IsAntichain.eq'","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\nhs : IsAntichain r s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\nh : r b a\n⊢ Eq a b","decl":"protected theorem eq' (hs : IsAntichain r s) {a b : α} (ha : a ∈ s) (hb : b ∈ s) (h : r b a) :\n    a = b :=\n  (hs.eq hb ha h).symm\n\n"}
{"name":"IsAntichain.isAntisymm","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\nh : IsAntichain r Set.univ\n⊢ IsAntisymm α r","decl":"protected theorem isAntisymm (h : IsAntichain r univ) : IsAntisymm α r :=\n  ⟨fun _ _ ha _ => h.eq trivial trivial ha⟩\n\n"}
{"name":"IsAntichain.subsingleton","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\ninst✝ : IsTrichotomous α r\nh : IsAntichain r s\n⊢ s.Subsingleton","decl":"protected theorem subsingleton [IsTrichotomous α r] (h : IsAntichain r s) : s.Subsingleton := by\n  rintro a ha b hb\n  obtain hab | hab | hab := trichotomous_of r a b\n  · exact h.eq ha hb hab\n  · exact hab\n  · exact h.eq' ha hb hab\n\n"}
{"name":"IsAntichain.flip","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\nhs : IsAntichain r s\n⊢ IsAntichain (flip r) s","decl":"protected theorem flip (hs : IsAntichain r s) : IsAntichain (flip r) s := fun _ ha _ hb h =>\n  hs hb ha h.symm\n\n"}
{"name":"IsAntichain.swap","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\nhs : IsAntichain r s\n⊢ IsAntichain (Function.swap r) s","decl":"theorem swap (hs : IsAntichain r s) : IsAntichain (swap r) s :=\n  hs.flip\n\n"}
{"name":"IsAntichain.image","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\nr' : β → β → Prop\ns : Set α\nhs : IsAntichain r s\nf : α → β\nh : ∀ ⦃a b : α⦄, r' (f a) (f b) → r a b\n⊢ IsAntichain r' (Set.image f s)","decl":"theorem image (hs : IsAntichain r s) (f : α → β) (h : ∀ ⦃a b⦄, r' (f a) (f b) → r a b) :\n    IsAntichain r' (f '' s) := by\n  rintro _ ⟨b, hb, rfl⟩ _ ⟨c, hc, rfl⟩ hbc hr\n  exact hs hb hc (ne_of_apply_ne _ hbc) (h hr)\n\n"}
{"name":"IsAntichain.preimage","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\nr' : β → β → Prop\ns : Set α\nhs : IsAntichain r s\nf : β → α\nhf : Function.Injective f\nh : ∀ ⦃a b : β⦄, r' a b → r (f a) (f b)\n⊢ IsAntichain r' (Set.preimage f s)","decl":"theorem preimage (hs : IsAntichain r s) {f : β → α} (hf : Injective f)\n    (h : ∀ ⦃a b⦄, r' a b → r (f a) (f b)) : IsAntichain r' (f ⁻¹' s) := fun _ hb _ hc hbc hr =>\n  hs hb hc (hf.ne hbc) <| h hr\n\n"}
{"name":"isAntichain_insert","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\na : α\n⊢ Iff (IsAntichain r (Insert.insert a s)) (And (IsAntichain r s) (∀ ⦃b : α⦄, Membership.mem s b → Ne a b → And (Not (r a b)) (Not (r b a))))","decl":"theorem _root_.isAntichain_insert :\n    IsAntichain r (insert a s) ↔ IsAntichain r s ∧ ∀ ⦃b⦄, b ∈ s → a ≠ b → ¬r a b ∧ ¬r b a :=\n  Set.pairwise_insert\n\n"}
{"name":"IsAntichain.insert","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\na : α\nhs : IsAntichain r s\nhl : ∀ ⦃b : α⦄, Membership.mem s b → Ne a b → Not (r b a)\nhr : ∀ ⦃b : α⦄, Membership.mem s b → Ne a b → Not (r a b)\n⊢ IsAntichain r (Insert.insert a s)","decl":"protected theorem insert (hs : IsAntichain r s) (hl : ∀ ⦃b⦄, b ∈ s → a ≠ b → ¬r b a)\n    (hr : ∀ ⦃b⦄, b ∈ s → a ≠ b → ¬r a b) : IsAntichain r (insert a s) :=\n  isAntichain_insert.2 ⟨hs, fun _ hb hab => ⟨hr hb hab, hl hb hab⟩⟩\n\n"}
{"name":"isAntichain_insert_of_symmetric","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\na : α\nhr : Symmetric r\n⊢ Iff (IsAntichain r (Insert.insert a s)) (And (IsAntichain r s) (∀ ⦃b : α⦄, Membership.mem s b → Ne a b → Not (r a b)))","decl":"theorem _root_.isAntichain_insert_of_symmetric (hr : Symmetric r) :\n    IsAntichain r (insert a s) ↔ IsAntichain r s ∧ ∀ ⦃b⦄, b ∈ s → a ≠ b → ¬r a b :=\n  pairwise_insert_of_symmetric hr.compl\n\n"}
{"name":"IsAntichain.insert_of_symmetric","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\na : α\nhs : IsAntichain r s\nhr : Symmetric r\nh : ∀ ⦃b : α⦄, Membership.mem s b → Ne a b → Not (r a b)\n⊢ IsAntichain r (Insert.insert a s)","decl":"theorem insert_of_symmetric (hs : IsAntichain r s) (hr : Symmetric r)\n    (h : ∀ ⦃b⦄, b ∈ s → a ≠ b → ¬r a b) : IsAntichain r (insert a s) :=\n  (isAntichain_insert_of_symmetric hr).2 ⟨hs, h⟩\n\n"}
{"name":"IsAntichain.image_relEmbedding","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\nr' : β → β → Prop\ns : Set α\nhs : IsAntichain r s\nφ : RelEmbedding r r'\n⊢ IsAntichain r' (Set.image (⇑φ) s)","decl":"theorem image_relEmbedding (hs : IsAntichain r s) (φ : r ↪r r') : IsAntichain r' (φ '' s) := by\n  intro b hb b' hb' h₁ h₂\n  rw [Set.mem_image] at hb hb'\n  obtain ⟨⟨a, has, rfl⟩, ⟨a', has', rfl⟩⟩ := hb, hb'\n  exact hs has has' (fun haa' => h₁ (by rw [haa'])) (φ.map_rel_iff.mp h₂)\n\n"}
{"name":"IsAntichain.preimage_relEmbedding","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\nr' : β → β → Prop\nt : Set β\nht : IsAntichain r' t\nφ : RelEmbedding r r'\n⊢ IsAntichain r (Set.preimage (⇑φ) t)","decl":"theorem preimage_relEmbedding {t : Set β} (ht : IsAntichain r' t) (φ : r ↪r r') :\n    IsAntichain r (φ ⁻¹' t) := fun _ ha _s ha' hne hle =>\n  ht ha ha' (fun h => hne (φ.injective h)) (φ.map_rel_iff.mpr hle)\n\n"}
{"name":"IsAntichain.image_relIso","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\nr' : β → β → Prop\ns : Set α\nhs : IsAntichain r s\nφ : RelIso r r'\n⊢ IsAntichain r' (Set.image (⇑φ) s)","decl":"theorem image_relIso (hs : IsAntichain r s) (φ : r ≃r r') : IsAntichain r' (φ '' s) :=\n  hs.image_relEmbedding φ.toRelEmbedding\n\n"}
{"name":"IsAntichain.preimage_relIso","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\nr' : β → β → Prop\nt : Set β\nhs : IsAntichain r' t\nφ : RelIso r r'\n⊢ IsAntichain r (Set.preimage (⇑φ) t)","decl":"theorem preimage_relIso {t : Set β} (hs : IsAntichain r' t) (φ : r ≃r r') :\n    IsAntichain r (φ ⁻¹' t) :=\n  hs.preimage_relEmbedding φ.toRelEmbedding\n\n"}
{"name":"IsAntichain.image_relEmbedding_iff","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\nr' : β → β → Prop\ns : Set α\nφ : RelEmbedding r r'\n⊢ Iff (IsAntichain r' (Set.image (⇑φ) s)) (IsAntichain r s)","decl":"theorem image_relEmbedding_iff {φ : r ↪r r'} : IsAntichain r' (φ '' s) ↔ IsAntichain r s :=\n  ⟨fun h => (φ.injective.preimage_image s).subst (h.preimage_relEmbedding φ), fun h =>\n    h.image_relEmbedding φ⟩\n\n"}
{"name":"IsAntichain.image_relIso_iff","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\nr' : β → β → Prop\ns : Set α\nφ : RelIso r r'\n⊢ Iff (IsAntichain r' (Set.image (⇑φ) s)) (IsAntichain r s)","decl":"theorem image_relIso_iff {φ : r ≃r r'} : IsAntichain r' (φ '' s) ↔ IsAntichain r s :=\n  @image_relEmbedding_iff _ _ _ _ _ (φ : r ↪r r')\n\n"}
{"name":"IsAntichain.image_embedding","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ninst✝¹ : LE α\ninst✝ : LE β\nhs : IsAntichain (fun x1 x2 => LE.le x1 x2) s\nφ : OrderEmbedding α β\n⊢ IsAntichain (fun x1 x2 => LE.le x1 x2) (Set.image (⇑φ) s)","decl":"theorem image_embedding [LE α] [LE β] (hs : IsAntichain (· ≤ ·) s) (φ : α ↪o β) :\n    IsAntichain (· ≤ ·) (φ '' s) :=\n  image_relEmbedding hs _\n\n"}
{"name":"IsAntichain.preimage_embedding","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\nt : Set β\nht : IsAntichain (fun x1 x2 => LE.le x1 x2) t\nφ : OrderEmbedding α β\n⊢ IsAntichain (fun x1 x2 => LE.le x1 x2) (Set.preimage (⇑φ) t)","decl":"theorem preimage_embedding [LE α] [LE β] {t : Set β} (ht : IsAntichain (· ≤ ·) t) (φ : α ↪o β) :\n    IsAntichain (· ≤ ·) (φ ⁻¹' t) :=\n  preimage_relEmbedding ht _\n\n"}
{"name":"IsAntichain.image_embedding_iff","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ninst✝¹ : LE α\ninst✝ : LE β\nφ : OrderEmbedding α β\n⊢ Iff (IsAntichain (fun x1 x2 => LE.le x1 x2) (Set.image (⇑φ) s)) (IsAntichain (fun x1 x2 => LE.le x1 x2) s)","decl":"theorem image_embedding_iff [LE α] [LE β] {φ : α ↪o β} :\n    IsAntichain (· ≤ ·) (φ '' s) ↔ IsAntichain (· ≤ ·) s :=\n  image_relEmbedding_iff\n\n"}
{"name":"IsAntichain.image_iso","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ninst✝¹ : LE α\ninst✝ : LE β\nhs : IsAntichain (fun x1 x2 => LE.le x1 x2) s\nφ : OrderIso α β\n⊢ IsAntichain (fun x1 x2 => LE.le x1 x2) (Set.image (⇑φ) s)","decl":"theorem image_iso [LE α] [LE β] (hs : IsAntichain (· ≤ ·) s) (φ : α ≃o β) :\n    IsAntichain (· ≤ ·) (φ '' s) :=\n  image_relEmbedding hs _\n\n"}
{"name":"IsAntichain.image_iso_iff","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ninst✝¹ : LE α\ninst✝ : LE β\nφ : OrderIso α β\n⊢ Iff (IsAntichain (fun x1 x2 => LE.le x1 x2) (Set.image (⇑φ) s)) (IsAntichain (fun x1 x2 => LE.le x1 x2) s)","decl":"theorem image_iso_iff [LE α] [LE β] {φ : α ≃o β} :\n    IsAntichain (· ≤ ·) (φ '' s) ↔ IsAntichain (· ≤ ·) s :=\n  image_relEmbedding_iff\n\n"}
{"name":"IsAntichain.preimage_iso","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\nt : Set β\nht : IsAntichain (fun x1 x2 => LE.le x1 x2) t\nφ : OrderIso α β\n⊢ IsAntichain (fun x1 x2 => LE.le x1 x2) (Set.preimage (⇑φ) t)","decl":"theorem preimage_iso [LE α] [LE β] {t : Set β} (ht : IsAntichain (· ≤ ·) t) (φ : α ≃o β) :\n    IsAntichain (· ≤ ·) (φ ⁻¹' t) :=\n  preimage_relEmbedding ht _\n\n"}
{"name":"IsAntichain.preimage_iso_iff","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\nt : Set β\nφ : OrderIso α β\n⊢ Iff (IsAntichain (fun x1 x2 => LE.le x1 x2) (Set.preimage (⇑φ) t)) (IsAntichain (fun x1 x2 => LE.le x1 x2) t)","decl":"theorem preimage_iso_iff [LE α] [LE β] {t : Set β} {φ : α ≃o β} :\n    IsAntichain (· ≤ ·) (φ ⁻¹' t) ↔ IsAntichain (· ≤ ·) t :=\n  ⟨fun h => (φ.image_preimage t).subst (h.image_iso φ), fun h => h.preimage_iso _⟩\n\n"}
{"name":"IsAntichain.to_dual","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : LE α\nhs : IsAntichain (fun x1 x2 => LE.le x1 x2) s\n⊢ IsAntichain (fun x1 x2 => LE.le x1 x2) s","decl":"theorem to_dual [LE α] (hs : IsAntichain (· ≤ ·) s) : @IsAntichain αᵒᵈ (· ≤ ·) s :=\n  fun _ ha _ hb hab => hs hb ha hab.symm\n\n"}
{"name":"IsAntichain.to_dual_iff","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : LE α\n⊢ Iff (IsAntichain (fun x1 x2 => LE.le x1 x2) s) (IsAntichain (fun x1 x2 => LE.le x1 x2) s)","decl":"theorem to_dual_iff [LE α] : IsAntichain (· ≤ ·) s ↔ @IsAntichain αᵒᵈ (· ≤ ·) s :=\n  ⟨to_dual, to_dual⟩\n\n"}
{"name":"IsAntichain.image_compl","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : BooleanAlgebra α\nhs : IsAntichain (fun x1 x2 => LE.le x1 x2) s\n⊢ IsAntichain (fun x1 x2 => LE.le x1 x2) (Set.image HasCompl.compl s)","decl":"theorem image_compl [BooleanAlgebra α] (hs : IsAntichain (· ≤ ·) s) :\n    IsAntichain (· ≤ ·) (compl '' s) :=\n  (hs.image_embedding (OrderIso.compl α).toOrderEmbedding).flip\n\n"}
{"name":"IsAntichain.preimage_compl","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : BooleanAlgebra α\nhs : IsAntichain (fun x1 x2 => LE.le x1 x2) s\n⊢ IsAntichain (fun x1 x2 => LE.le x1 x2) (Set.preimage HasCompl.compl s)","decl":"theorem preimage_compl [BooleanAlgebra α] (hs : IsAntichain (· ≤ ·) s) :\n    IsAntichain (· ≤ ·) (compl ⁻¹' s) := fun _ ha _ ha' hne hle =>\n  hs ha' ha (fun h => hne (compl_inj_iff.mp h.symm)) (compl_le_compl hle)\n\n"}
{"name":"isAntichain_singleton","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\na : α\nr : α → α → Prop\n⊢ IsAntichain r (Singleton.singleton a)","decl":"theorem isAntichain_singleton (a : α) (r : α → α → Prop) : IsAntichain r {a} :=\n  pairwise_singleton _ _\n\n"}
{"name":"Set.Subsingleton.isAntichain","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\ns : Set α\nhs : s.Subsingleton\nr : α → α → Prop\n⊢ IsAntichain r s","decl":"theorem Set.Subsingleton.isAntichain (hs : s.Subsingleton) (r : α → α → Prop) : IsAntichain r s :=\n  hs.pairwise _\n\n"}
{"name":"subsingleton_of_isChain_of_isAntichain","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\nhs : IsChain r s\nht : IsAntichain r s\n⊢ s.Subsingleton","decl":"/-- A set which is simultaneously a chain and antichain is subsingleton. -/\nlemma subsingleton_of_isChain_of_isAntichain (hs : IsChain r s) (ht : IsAntichain r s) :\n    s.Subsingleton := by\n  intro x hx y hy\n  by_contra! hne\n  cases hs hx hy hne with\n  | inl h => exact ht hx hy hne h\n  | inr h => exact ht hy hx hne.symm h\n\n"}
{"name":"isChain_and_isAntichain_iff_subsingleton","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\n⊢ Iff (And (IsChain r s) (IsAntichain r s)) s.Subsingleton","decl":"lemma isChain_and_isAntichain_iff_subsingleton : IsChain r s ∧ IsAntichain r s ↔ s.Subsingleton :=\n  ⟨fun h ↦ subsingleton_of_isChain_of_isAntichain h.1 h.2, fun h ↦ ⟨h.isChain, h.isAntichain _⟩⟩\n\n"}
{"name":"inter_subsingleton_of_isChain_of_isAntichain","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns t : Set α\nhs : IsChain r s\nht : IsAntichain r t\n⊢ (Inter.inter s t).Subsingleton","decl":"/-- The intersection of a chain and an antichain is subsingleton.  -/\nlemma inter_subsingleton_of_isChain_of_isAntichain (hs : IsChain r s) (ht : IsAntichain r t) :\n    (s ∩ t).Subsingleton :=\n  subsingleton_of_isChain_of_isAntichain (hs.mono (by simp)) (ht.subset (by simp))\n\n"}
{"name":"inter_subsingleton_of_isAntichain_of_isChain","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns t : Set α\nhs : IsAntichain r s\nht : IsChain r t\n⊢ (Inter.inter s t).Subsingleton","decl":"/-- The intersection of an antichain and a chain is subsingleton.  -/\nlemma inter_subsingleton_of_isAntichain_of_isChain (hs : IsAntichain r s) (ht : IsChain r t) :\n    (s ∩ t).Subsingleton :=\n  inter_comm _ _ ▸ inter_subsingleton_of_isChain_of_isAntichain ht hs\n\n"}
{"name":"IsAntichain.not_lt","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\ns : Set α\na b : α\ninst✝ : Preorder α\nhs : IsAntichain (fun x1 x2 => LE.le x1 x2) s\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ Not (LT.lt a b)","decl":"theorem IsAntichain.not_lt (hs : IsAntichain (· ≤ ·) s) (ha : a ∈ s) (hb : b ∈ s) : ¬a < b :=\n  fun h => hs ha hb h.ne h.le\n\n"}
{"name":"isAntichain_and_least_iff","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\ns : Set α\na : α\ninst✝ : Preorder α\n⊢ Iff (And (IsAntichain (fun x1 x2 => LE.le x1 x2) s) (IsLeast s a)) (Eq s (Singleton.singleton a))","decl":"theorem isAntichain_and_least_iff : IsAntichain (· ≤ ·) s ∧ IsLeast s a ↔ s = {a} :=\n  ⟨fun h => eq_singleton_iff_unique_mem.2 ⟨h.2.1, fun _ hb => h.1.eq' hb h.2.1 (h.2.2 hb)⟩, by\n    rintro rfl\n    exact ⟨isAntichain_singleton _ _, isLeast_singleton⟩⟩\n\n"}
{"name":"isAntichain_and_greatest_iff","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\ns : Set α\na : α\ninst✝ : Preorder α\n⊢ Iff (And (IsAntichain (fun x1 x2 => LE.le x1 x2) s) (IsGreatest s a)) (Eq s (Singleton.singleton a))","decl":"theorem isAntichain_and_greatest_iff : IsAntichain (· ≤ ·) s ∧ IsGreatest s a ↔ s = {a} :=\n  ⟨fun h => eq_singleton_iff_unique_mem.2 ⟨h.2.1, fun _ hb => h.1.eq hb h.2.1 (h.2.2 hb)⟩, by\n    rintro rfl\n    exact ⟨isAntichain_singleton _ _, isGreatest_singleton⟩⟩\n\n"}
{"name":"IsAntichain.least_iff","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\ns : Set α\na : α\ninst✝ : Preorder α\nhs : IsAntichain (fun x1 x2 => LE.le x1 x2) s\n⊢ Iff (IsLeast s a) (Eq s (Singleton.singleton a))","decl":"theorem IsAntichain.least_iff (hs : IsAntichain (· ≤ ·) s) : IsLeast s a ↔ s = {a} :=\n  (and_iff_right hs).symm.trans isAntichain_and_least_iff\n\n"}
{"name":"IsAntichain.greatest_iff","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\ns : Set α\na : α\ninst✝ : Preorder α\nhs : IsAntichain (fun x1 x2 => LE.le x1 x2) s\n⊢ Iff (IsGreatest s a) (Eq s (Singleton.singleton a))","decl":"theorem IsAntichain.greatest_iff (hs : IsAntichain (· ≤ ·) s) : IsGreatest s a ↔ s = {a} :=\n  (and_iff_right hs).symm.trans isAntichain_and_greatest_iff\n\n"}
{"name":"IsLeast.antichain_iff","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\ns : Set α\na : α\ninst✝ : Preorder α\nhs : IsLeast s a\n⊢ Iff (IsAntichain (fun x1 x2 => LE.le x1 x2) s) (Eq s (Singleton.singleton a))","decl":"theorem IsLeast.antichain_iff (hs : IsLeast s a) : IsAntichain (· ≤ ·) s ↔ s = {a} :=\n  (and_iff_left hs).symm.trans isAntichain_and_least_iff\n\n"}
{"name":"IsGreatest.antichain_iff","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\ns : Set α\na : α\ninst✝ : Preorder α\nhs : IsGreatest s a\n⊢ Iff (IsAntichain (fun x1 x2 => LE.le x1 x2) s) (Eq s (Singleton.singleton a))","decl":"theorem IsGreatest.antichain_iff (hs : IsGreatest s a) : IsAntichain (· ≤ ·) s ↔ s = {a} :=\n  (and_iff_left hs).symm.trans isAntichain_and_greatest_iff\n\n"}
{"name":"IsAntichain.bot_mem_iff","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\ns : Set α\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\nhs : IsAntichain (fun x1 x2 => LE.le x1 x2) s\n⊢ Iff (Membership.mem s Bot.bot) (Eq s (Singleton.singleton Bot.bot))","decl":"theorem IsAntichain.bot_mem_iff [OrderBot α] (hs : IsAntichain (· ≤ ·) s) : ⊥ ∈ s ↔ s = {⊥} :=\n  isLeast_bot_iff.symm.trans hs.least_iff\n\n"}
{"name":"IsAntichain.top_mem_iff","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\ns : Set α\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\nhs : IsAntichain (fun x1 x2 => LE.le x1 x2) s\n⊢ Iff (Membership.mem s Top.top) (Eq s (Singleton.singleton Top.top))","decl":"theorem IsAntichain.top_mem_iff [OrderTop α] (hs : IsAntichain (· ≤ ·) s) : ⊤ ∈ s ↔ s = {⊤} :=\n  isGreatest_top_iff.symm.trans hs.greatest_iff\n\n"}
{"name":"isAntichain_iff_forall_not_lt","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : PartialOrder α\n⊢ Iff (IsAntichain (fun x1 x2 => LE.le x1 x2) s) (∀ ⦃a : α⦄, Membership.mem s a → ∀ ⦃b : α⦄, Membership.mem s b → Not (LT.lt a b))","decl":"theorem isAntichain_iff_forall_not_lt :\n    IsAntichain (· ≤ ·) s ↔ ∀ ⦃a⦄, a ∈ s → ∀ ⦃b⦄, b ∈ s → ¬a < b :=\n  ⟨fun hs _ ha _ => hs.not_lt ha, fun hs _ ha _ hb h h' => hs ha hb <| h'.lt_of_ne h⟩\n\n"}
{"name":"IsStrongAntichain.subset","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns t : Set α\nhs : IsStrongAntichain r s\nh : HasSubset.Subset t s\n⊢ IsStrongAntichain r t","decl":"protected theorem subset (hs : IsStrongAntichain r s) (h : t ⊆ s) : IsStrongAntichain r t :=\n  hs.mono h\n\n"}
{"name":"IsStrongAntichain.mono","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr₁ r₂ : α → α → Prop\ns : Set α\nhs : IsStrongAntichain r₁ s\nh : LE.le r₂ r₁\n⊢ IsStrongAntichain r₂ s","decl":"theorem mono (hs : IsStrongAntichain r₁ s) (h : r₂ ≤ r₁) : IsStrongAntichain r₂ s :=\n  hs.mono' fun _ _ hab c => (hab c).imp (compl_le_compl h _ _) (compl_le_compl h _ _)\n\n"}
{"name":"IsStrongAntichain.eq","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\nhs : IsStrongAntichain r s\na b c : α\nha : Membership.mem s a\nhb : Membership.mem s b\nhac : r a c\nhbc : r b c\n⊢ Eq a b","decl":"theorem eq (hs : IsStrongAntichain r s) {a b c : α} (ha : a ∈ s) (hb : b ∈ s) (hac : r a c)\n    (hbc : r b c) : a = b :=\n  (Set.Pairwise.eq hs ha hb) fun h =>\n    False.elim <| (h c).elim (not_not_intro hac) (not_not_intro hbc)\n\n"}
{"name":"IsStrongAntichain.isAntichain","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\ninst✝ : IsRefl α r\nh : IsStrongAntichain r s\n⊢ IsAntichain r s","decl":"protected theorem isAntichain [IsRefl α r] (h : IsStrongAntichain r s) : IsAntichain r s :=\n  h.imp fun _ b hab => (hab b).resolve_right (not_not_intro <| refl _)\n\n"}
{"name":"IsStrongAntichain.subsingleton","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\ninst✝ : IsDirected α r\nh : IsStrongAntichain r s\n⊢ s.Subsingleton","decl":"protected theorem subsingleton [IsDirected α r] (h : IsStrongAntichain r s) : s.Subsingleton :=\n  fun a ha b hb =>\n  let ⟨_, hac, hbc⟩ := directed_of r a b\n  h.eq ha hb hac hbc\n\n"}
{"name":"IsStrongAntichain.flip","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\ninst✝ : IsSymm α r\nhs : IsStrongAntichain r s\n⊢ IsStrongAntichain (flip r) s","decl":"protected theorem flip [IsSymm α r] (hs : IsStrongAntichain r s) : IsStrongAntichain (flip r) s :=\n  fun _ ha _ hb h c => (hs ha hb h c).imp (mt <| symm_of r) (mt <| symm_of r)\n\n"}
{"name":"IsStrongAntichain.swap","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\ninst✝ : IsSymm α r\nhs : IsStrongAntichain r s\n⊢ IsStrongAntichain (Function.swap r) s","decl":"theorem swap [IsSymm α r] (hs : IsStrongAntichain r s) : IsStrongAntichain (swap r) s :=\n  hs.flip\n\n"}
{"name":"IsStrongAntichain.image","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\nr' : β → β → Prop\ns : Set α\nhs : IsStrongAntichain r s\nf : α → β\nhf : Function.Surjective f\nh : ∀ (a b : α), r' (f a) (f b) → r a b\n⊢ IsStrongAntichain r' (Set.image f s)","decl":"theorem image (hs : IsStrongAntichain r s) {f : α → β} (hf : Surjective f)\n    (h : ∀ a b, r' (f a) (f b) → r a b) : IsStrongAntichain r' (f '' s) := by\n  rintro _ ⟨a, ha, rfl⟩ _ ⟨b, hb, rfl⟩ hab c\n  obtain ⟨c, rfl⟩ := hf c\n  exact (hs ha hb (ne_of_apply_ne _ hab) _).imp (mt <| h _ _) (mt <| h _ _)\n\n"}
{"name":"IsStrongAntichain.preimage","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\nr' : β → β → Prop\ns : Set α\nhs : IsStrongAntichain r s\nf : β → α\nhf : Function.Injective f\nh : ∀ (a b : β), r' a b → r (f a) (f b)\n⊢ IsStrongAntichain r' (Set.preimage f s)","decl":"theorem preimage (hs : IsStrongAntichain r s) {f : β → α} (hf : Injective f)\n    (h : ∀ a b, r' a b → r (f a) (f b)) : IsStrongAntichain r' (f ⁻¹' s) := fun _ ha _ hb hab _ =>\n  (hs ha hb (hf.ne hab) _).imp (mt <| h _ _) (mt <| h _ _)\n\n"}
{"name":"isStrongAntichain_insert","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\na : α\n⊢ Iff (IsStrongAntichain r (Insert.insert a s)) (And (IsStrongAntichain r s) (∀ ⦃b : α⦄, Membership.mem s b → Ne a b → ∀ (c : α), Or (Not (r a c)) (Not (r b c))))","decl":"theorem _root_.isStrongAntichain_insert :\n    IsStrongAntichain r (insert a s) ↔\n      IsStrongAntichain r s ∧ ∀ ⦃b⦄, b ∈ s → a ≠ b → ∀ c, ¬r a c ∨ ¬r b c :=\n  Set.pairwise_insert_of_symmetric fun _ _ h c => (h c).symm\n\n"}
{"name":"IsStrongAntichain.insert","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\na : α\nhs : IsStrongAntichain r s\nh : ∀ ⦃b : α⦄, Membership.mem s b → Ne a b → ∀ (c : α), Or (Not (r a c)) (Not (r b c))\n⊢ IsStrongAntichain r (Insert.insert a s)","decl":"protected theorem insert (hs : IsStrongAntichain r s)\n    (h : ∀ ⦃b⦄, b ∈ s → a ≠ b → ∀ c, ¬r a c ∨ ¬r b c) : IsStrongAntichain r (insert a s) :=\n  isStrongAntichain_insert.2 ⟨hs, h⟩\n\n"}
{"name":"Set.Subsingleton.isStrongAntichain","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\ns : Set α\nhs : s.Subsingleton\nr : α → α → Prop\n⊢ IsStrongAntichain r s","decl":"theorem Set.Subsingleton.isStrongAntichain (hs : s.Subsingleton) (r : α → α → Prop) :\n    IsStrongAntichain r s :=\n  hs.pairwise _\n\n"}
{"name":"IsAntichain.of_strictMonoOn_antitoneOn","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\nf : α → β\ns : Set α\nhf : StrictMonoOn f s\nhf' : AntitoneOn f s\n⊢ IsAntichain (fun x1 x2 => LE.le x1 x2) s","decl":"lemma IsAntichain.of_strictMonoOn_antitoneOn (hf : StrictMonoOn f s) (hf' : AntitoneOn f s) :\n    IsAntichain (· ≤ ·) s :=\n  fun _a ha _b hb hab' hab ↦ (hf ha hb <| hab.lt_of_ne hab').not_le (hf' ha hb hab)\n\n"}
{"name":"IsAntichain.of_monotoneOn_strictAntiOn","module":"Mathlib.Order.Antichain","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\nf : α → β\ns : Set α\nhf : MonotoneOn f s\nhf' : StrictAntiOn f s\n⊢ IsAntichain (fun x1 x2 => LE.le x1 x2) s","decl":"lemma IsAntichain.of_monotoneOn_strictAntiOn (hf : MonotoneOn f s) (hf' : StrictAntiOn f s) :\n    IsAntichain (· ≤ ·) s :=\n  fun _a ha _b hb hab' hab ↦ (hf ha hb hab).not_lt (hf' ha hb <| hab.lt_of_ne hab')\n\n"}
{"name":"IsWeakAntichain.subset","module":"Mathlib.Order.Antichain","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → Preorder (α i)\ns t : Set ((i : ι) → α i)\nhs : IsWeakAntichain s\na✝ : HasSubset.Subset t s\n⊢ IsWeakAntichain t","decl":"protected theorem subset (hs : IsWeakAntichain s) : t ⊆ s → IsWeakAntichain t :=\n  IsAntichain.subset hs\n\n"}
{"name":"IsWeakAntichain.eq","module":"Mathlib.Order.Antichain","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → Preorder (α i)\ns : Set ((i : ι) → α i)\na b : (i : ι) → α i\nhs : IsWeakAntichain s\na✝² : Membership.mem s a\na✝¹ : Membership.mem s b\na✝ : StrongLT a b\n⊢ Eq a b","decl":"protected theorem eq (hs : IsWeakAntichain s) : a ∈ s → b ∈ s → a ≺ b → a = b :=\n  IsAntichain.eq hs\n\n"}
{"name":"IsWeakAntichain.insert","module":"Mathlib.Order.Antichain","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → Preorder (α i)\ns : Set ((i : ι) → α i)\na : (i : ι) → α i\nhs : IsWeakAntichain s\na✝¹ : ∀ ⦃b : (i : ι) → α i⦄, Membership.mem s b → Ne a b → Not (StrongLT b a)\na✝ : ∀ ⦃b : (i : ι) → α i⦄, Membership.mem s b → Ne a b → Not (StrongLT a b)\n⊢ IsWeakAntichain (Insert.insert a s)","decl":"protected theorem insert (hs : IsWeakAntichain s) :\n    (∀ ⦃b⦄, b ∈ s → a ≠ b → ¬b ≺ a) →\n      (∀ ⦃b⦄, b ∈ s → a ≠ b → ¬a ≺ b) → IsWeakAntichain (insert a s) :=\n  IsAntichain.insert hs\n\n"}
{"name":"isWeakAntichain_insert","module":"Mathlib.Order.Antichain","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → Preorder (α i)\ns : Set ((i : ι) → α i)\na : (i : ι) → α i\n⊢ Iff (IsWeakAntichain (Insert.insert a s)) (And (IsWeakAntichain s) (∀ ⦃b : (i : ι) → α i⦄, Membership.mem s b → Ne a b → And (Not (StrongLT a b)) (Not (StrongLT b a))))","decl":"theorem _root_.isWeakAntichain_insert :\n    IsWeakAntichain (insert a s) ↔ IsWeakAntichain s ∧ ∀ ⦃b⦄, b ∈ s → a ≠ b → ¬a ≺ b ∧ ¬b ≺ a :=\n  isAntichain_insert\n\n"}
{"name":"IsAntichain.isWeakAntichain","module":"Mathlib.Order.Antichain","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → Preorder (α i)\ns : Set ((i : ι) → α i)\nhs : IsAntichain (fun x1 x2 => LE.le x1 x2) s\n⊢ IsWeakAntichain s","decl":"protected theorem IsAntichain.isWeakAntichain (hs : IsAntichain (· ≤ ·) s) : IsWeakAntichain s :=\n  hs.mono fun _ _ => le_of_strongLT\n\n"}
{"name":"Set.Subsingleton.isWeakAntichain","module":"Mathlib.Order.Antichain","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → Preorder (α i)\ns : Set ((i : ι) → α i)\nhs : s.Subsingleton\n⊢ IsWeakAntichain s","decl":"theorem Set.Subsingleton.isWeakAntichain (hs : s.Subsingleton) : IsWeakAntichain s :=\n  hs.isAntichain _\n\n"}
