{"name":"CompHausLike.LocallyConstant.functorToPresheaves_map_app","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat ‚Üí Prop\nX‚úù Y‚úù : Type (max u w)\nf : Quiver.Hom X‚úù Y‚úù\nx‚úù : Opposite (CompHausLike P)\nt : ((fun X => { obj := fun x => CompHausLike.LocallyConstant.functorToPresheaves.match_1 (fun x => Type (max u w)) x fun S => LocallyConstant (‚ÜëS.toTop) X, map := fun {X_1 Y} f g => LocallyConstant.comap f.unop g, map_id := ‚ãØ, map_comp := ‚ãØ }) X‚úù).obj x‚úù\n‚ä¢ Eq ((CompHausLike.LocallyConstant.functorToPresheaves.map f).app x‚úù t) (LocallyConstant.map f t)","decl":"/--\nThe functor from the category of sets to presheaves on `CompHausLike P` given by locally constant\nmaps.\n-/\n@[simps]\ndef functorToPresheaves : Type (max u w) ‚•§ ((CompHausLike.{u} P)·µí·µñ ‚•§ Type max u w) where\n  obj X := {\n    obj := fun ‚ü®S‚ü© ‚Ü¶ LocallyConstant S X\n    map := fun f g ‚Ü¶ g.comap f.unop }\n  map f := { app := fun _ t ‚Ü¶ t.map f }\n\n"}
{"name":"CompHausLike.LocallyConstant.functorToPresheaves_obj_map","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat ‚Üí Prop\nX : Type (max u w)\nX‚úù Y‚úù : Opposite (CompHausLike P)\nf : Quiver.Hom X‚úù Y‚úù\ng : CompHausLike.LocallyConstant.functorToPresheaves.match_1 (fun x => Type (max u w)) X‚úù fun S => LocallyConstant (‚ÜëS.toTop) X\n‚ä¢ Eq ((CompHausLike.LocallyConstant.functorToPresheaves.obj X).map f g) (LocallyConstant.comap f.unop g)","decl":"/--\nThe functor from the category of sets to presheaves on `CompHausLike P` given by locally constant\nmaps.\n-/\n@[simps]\ndef functorToPresheaves : Type (max u w) ‚•§ ((CompHausLike.{u} P)·µí·µñ ‚•§ Type max u w) where\n  obj X := {\n    obj := fun ‚ü®S‚ü© ‚Ü¶ LocallyConstant S X\n    map := fun f g ‚Ü¶ g.comap f.unop }\n  map f := { app := fun _ t ‚Ü¶ t.map f }\n\n"}
{"name":"CompHausLike.LocallyConstant.functorToPresheaves_obj_obj","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat ‚Üí Prop\nX : Type (max u w)\nx‚úù : Opposite (CompHausLike P)\n‚ä¢ Eq ((CompHausLike.LocallyConstant.functorToPresheaves.obj X).obj x‚úù) (CompHausLike.LocallyConstant.functorToPresheaves.match_1 (fun x => Type (max u w)) x‚úù fun S => LocallyConstant (‚ÜëS.toTop) X)","decl":"/--\nThe functor from the category of sets to presheaves on `CompHausLike P` given by locally constant\nmaps.\n-/\n@[simps]\ndef functorToPresheaves : Type (max u w) ‚•§ ((CompHausLike.{u} P)·µí·µñ ‚•§ Type max u w) where\n  obj X := {\n    obj := fun ‚ü®S‚ü© ‚Ü¶ LocallyConstant S X\n    map := fun f g ‚Ü¶ g.comap f.unop }\n  map f := { app := fun _ t ‚Ü¶ t.map f }\n\n"}
{"name":"CompHausLike.LocallyConstant.locallyConstantIsoContinuousMap_inv_apply","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"Y : Type u_1\nX : Type u_2\ninst‚úù : TopologicalSpace Y\nf : ContinuousMap Y ‚Üë(TopCat.discrete.obj X)\na : Y\n‚ä¢ Eq (((CompHausLike.LocallyConstant.locallyConstantIsoContinuousMap Y X).inv f) a) (f a)","decl":"/--\nLocally constant maps are the same as continuous maps when the target is equipped with the discrete\ntopology\n-/\n@[simps]\ndef locallyConstantIsoContinuousMap (Y X : Type*) [TopologicalSpace Y] :\n    LocallyConstant Y X ‚âÖ C(Y, TopCat.discrete.obj X) :=\n  letI : TopologicalSpace X := ‚ä•\n  haveI : DiscreteTopology X := ‚ü®rfl‚ü©\n  { hom := fun f ‚Ü¶ (f : C(Y, X))\n    inv := fun f ‚Ü¶ ‚ü®f, (IsLocallyConstant.iff_continuous f).mpr f.2‚ü© }\n\n"}
{"name":"CompHausLike.LocallyConstant.locallyConstantIsoContinuousMap_hom","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"Y : Type u_1\nX : Type u_2\ninst‚úù : TopologicalSpace Y\nf : LocallyConstant Y X\n‚ä¢ Eq ((CompHausLike.LocallyConstant.locallyConstantIsoContinuousMap Y X).hom f) ‚Üëf","decl":"/--\nLocally constant maps are the same as continuous maps when the target is equipped with the discrete\ntopology\n-/\n@[simps]\ndef locallyConstantIsoContinuousMap (Y X : Type*) [TopologicalSpace Y] :\n    LocallyConstant Y X ‚âÖ C(Y, TopCat.discrete.obj X) :=\n  letI : TopologicalSpace X := ‚ä•\n  haveI : DiscreteTopology X := ‚ü®rfl‚ü©\n  { hom := fun f ‚Ü¶ (f : C(Y, X))\n    inv := fun f ‚Ü¶ ‚ü®f, (IsLocallyConstant.iff_continuous f).mpr f.2‚ü© }\n\n"}
{"name":"CompHausLike.LocallyConstant.instHasPropŒ±TopologicalSpaceToTopFiber","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat ‚Üí Prop\ninst‚úù : ‚àÄ (S : CompHausLike P) (p : ‚ÜëS.toTop ‚Üí Prop), CompHausLike.HasProp P (Subtype p)\nQ : CompHausLike P\nZ : Type (max u w)\nr : LocallyConstant (‚ÜëQ.toTop) Z\na : Function.Fiber ‚áër\n‚ä¢ CompHausLike.HasProp P ‚Üë(CompHausLike.LocallyConstant.fiber r a).toTop","decl":"instance : HasProp P (fiber r a) := inferInstanceAs (HasProp P (Subtype _))\n\n"}
{"name":"CompHausLike.LocallyConstant.sigmaComparison_comp_sigmaIso","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat ‚Üí Prop\ninst‚úù¬π : ‚àÄ (S : CompHausLike P) (p : ‚ÜëS.toTop ‚Üí Prop), CompHausLike.HasProp P (Subtype p)\nQ : CompHausLike P\nZ : Type (max u w)\nr : LocallyConstant (‚ÜëQ.toTop) Z\na : Function.Fiber ‚áër\ninst‚úù : CompHausLike.HasExplicitFiniteCoproducts P\nX : CategoryTheory.Functor (Opposite (CompHausLike P)) (Type (max u w))\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.mapIso (CompHausLike.LocallyConstant.sigmaIso r).op).hom (CategoryTheory.CategoryStruct.comp (CompHausLike.sigmaComparison X fun a => ‚Üë(CompHausLike.LocallyConstant.fiber r a).toTop) fun g => g a)) (X.map (CompHausLike.LocallyConstant.sigmaIncl r a).op)","decl":"lemma sigmaComparison_comp_sigmaIso [HasExplicitFiniteCoproducts.{u} P]\n    (X : (CompHausLike.{u} P)·µí·µñ ‚•§ Type max u w) :\n    (X.mapIso (sigmaIso r).op).hom ‚â´ sigmaComparison X (fun a ‚Ü¶ (fiber r a).1) ‚â´\n      (fun g ‚Ü¶ g a) = X.map (sigmaIncl r a).op := by\n  ext\n  simp only [Functor.mapIso_hom, Iso.op_hom, types_comp_apply, sigmaComparison, coe_of,\n    ‚Üê FunctorToTypes.map_comp_apply]\n  rfl\n\n"}
{"name":"CompHausLike.LocallyConstant.presheaf_ext","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat ‚Üí Prop\ninst‚úù¬≥ : ‚àÄ (S : CompHausLike P) (p : ‚ÜëS.toTop ‚Üí Prop), CompHausLike.HasProp P (Subtype p)\nS : CompHausLike P\nY : CategoryTheory.Functor (Opposite (CompHausLike P)) (Type (max u w))\ninst‚úù¬≤ : CompHausLike.HasProp P PUnit.{u + 1}\nf : LocallyConstant (‚ÜëS.toTop) (Y.obj { unop := CompHausLike.of P PUnit.{u + 1} })\nX : CategoryTheory.Functor (Opposite (CompHausLike P)) (Type (max u w))\ninst‚úù¬π : CategoryTheory.Limits.PreservesFiniteProducts X\nx y : X.obj { unop := S }\ninst‚úù : CompHausLike.HasExplicitFiniteCoproducts P\nh : ‚àÄ (a : Function.Fiber ‚áëf), Eq (X.map (CompHausLike.LocallyConstant.sigmaIncl f a).op x) (X.map (CompHausLike.LocallyConstant.sigmaIncl f a).op y)\n‚ä¢ Eq x y","decl":"/--\nTo check equality of two elements of `X(S)`, it suffices to check equality after composing with\neach `X(S) ‚Üí X(S·µ¢)`.\n-/\nlemma presheaf_ext (X : (CompHausLike.{u} P)·µí·µñ ‚•§ Type max u w)\n    [PreservesFiniteProducts X] (x y : X.obj ‚ü®S‚ü©)\n    [HasExplicitFiniteCoproducts.{u} P]\n    (h : ‚àÄ (a : Fiber f), X.map (sigmaIncl f a).op x = X.map (sigmaIncl f a).op y) : x = y := by\n  apply injective_of_mono (X.mapIso (sigmaIso f).op).hom\n  apply injective_of_mono (sigmaComparison X (fun a ‚Ü¶ (fiber f a).1))\n  ext a\n  specialize h a\n  rw [‚Üê sigmaComparison_comp_sigmaIso] at h\n  exact h\n\n"}
{"name":"CompHausLike.LocallyConstant.incl_of_counitAppApp","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat ‚Üí Prop\ninst‚úù¬≥ : ‚àÄ (S : CompHausLike P) (p : ‚ÜëS.toTop ‚Üí Prop), CompHausLike.HasProp P (Subtype p)\nS : CompHausLike P\nY : CategoryTheory.Functor (Opposite (CompHausLike P)) (Type (max u w))\ninst‚úù¬≤ : CompHausLike.HasProp P PUnit.{u + 1}\nf : LocallyConstant (‚ÜëS.toTop) (Y.obj { unop := CompHausLike.of P PUnit.{u + 1} })\ninst‚úù¬π : CategoryTheory.Limits.PreservesFiniteProducts Y\ninst‚úù : CompHausLike.HasExplicitFiniteCoproducts P\na : Function.Fiber ‚áëf\n‚ä¢ Eq (Y.map (CompHausLike.LocallyConstant.sigmaIncl f a).op (CompHausLike.LocallyConstant.counitAppApp S Y f)) (CompHausLike.LocallyConstant.counitAppAppImage f a)","decl":"lemma incl_of_counitAppApp [PreservesFiniteProducts Y] [HasExplicitFiniteCoproducts.{u} P]\n    (a : Fiber f) : Y.map (sigmaIncl f a).op (counitAppApp S Y f) = counitAppAppImage f a := by\n  rw [‚Üê sigmaComparison_comp_sigmaIso, Functor.mapIso_hom, Iso.op_hom, types_comp_apply]\n  simp only [counitAppApp, Functor.mapIso_inv, ‚Üê Iso.op_hom, types_comp_apply,\n    ‚Üê FunctorToTypes.map_comp_apply, Iso.inv_hom_id, FunctorToTypes.map_id_apply]\n  exact congrFun (inv_hom_id_apply (asIso (sigmaComparison Y (fun a ‚Ü¶ (fiber f a).1)))\n    (counitAppAppImage f)) _\n\n"}
{"name":"CompHausLike.LocallyConstant.incl_comap","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat ‚Üí Prop\ninst‚úù¬π : ‚àÄ (S : CompHausLike P) (p : ‚ÜëS.toTop ‚Üí Prop), CompHausLike.HasProp P (Subtype p)\nY : CategoryTheory.Functor (Opposite (CompHausLike P)) (Type (max u w))\ninst‚úù : CompHausLike.HasProp P PUnit.{u + 1}\nS T : Opposite (CompHausLike P)\nf : LocallyConstant (‚Üë(Opposite.unop S).toTop) (Y.obj { unop := CompHausLike.of P PUnit.{u + 1} })\ng : Quiver.Hom S T\na : Function.Fiber ‚áë(LocallyConstant.comap g.unop f)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp g (CompHausLike.LocallyConstant.sigmaIncl (LocallyConstant.comap g.unop f) a).op) (CategoryTheory.CategoryStruct.comp (CompHausLike.LocallyConstant.sigmaIncl f (Function.Fiber.mk (‚áëf) (g.unop (Function.Fiber.preimage (‚áë(LocallyConstant.comap g.unop f)) a)))).op (CompHausLike.LocallyConstant.componentHom f g.unop a).op)","decl":"lemma incl_comap {S T : (CompHausLike P)·µí·µñ}\n    (f : LocallyConstant S.unop (Y.obj (op (CompHausLike.of P PUnit.{u+1}))))\n      (g : S ‚ü∂ T) (a : Fiber (f.comap g.unop)) :\n        g ‚â´ (sigmaIncl (f.comap g.unop) a).op =\n          (sigmaIncl f _).op ‚â´ (componentHom f g.unop a).op :=\n  rfl\n\n"}
{"name":"CompHausLike.LocallyConstant.counitApp_app","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat ‚Üí Prop\ninst‚úù¬≥ : ‚àÄ (S : CompHausLike P) (p : ‚ÜëS.toTop ‚Üí Prop), CompHausLike.HasProp P (Subtype p)\ninst‚úù¬≤ : CompHausLike.HasProp P PUnit.{u + 1}\ninst‚úù¬π : CompHausLike.HasExplicitFiniteCoproducts P\nY : CategoryTheory.Functor (Opposite (CompHausLike P)) (Type (max u w))\ninst‚úù : CategoryTheory.Limits.PreservesFiniteProducts Y\nx‚úù : Opposite (CompHausLike P)\na‚úù : (CompHausLike.LocallyConstant.functorToPresheaves.obj (Y.obj { unop := CompHausLike.of P PUnit.{u + 1} })).obj x‚úù\n‚ä¢ Eq ((CompHausLike.LocallyConstant.counitApp Y).app x‚úù a‚úù) (CompHausLike.LocallyConstant.counitAppApp (Opposite.unop x‚úù) Y a‚úù)","decl":"/-- The counit is natural in `S : CompHausLike P` -/\n@[simps!]\nnoncomputable def counitApp [HasExplicitFiniteCoproducts.{u} P]\n    (Y : (CompHausLike.{u} P)·µí·µñ ‚•§ Type max u w) [PreservesFiniteProducts Y] :\n    (functorToPresheaves.obj (Y.obj (op (CompHausLike.of P PUnit.{u+1})))) ‚ü∂ Y where\n  app := fun ‚ü®S‚ü© ‚Ü¶ counitAppApp S Y\n  naturality := by\n    intro S T g\n    ext f\n    apply presheaf_ext (f.comap g.unop)\n    intro a\n    simp only [op_unop, functorToPresheaves_obj_obj, types_comp_apply, functorToPresheaves_obj_map,\n      incl_of_counitAppApp, ‚Üê FunctorToTypes.map_comp_apply, incl_comap]\n    simp only [FunctorToTypes.map_comp_apply, incl_of_counitAppApp]\n    simp only [counitAppAppImage, ‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp,\n      terminal.comp_from]\n    apply congrArg\n    exact image_eq_image_mk (g := g.unop) (a := a)\n\n"}
{"name":"CompHausLike.LocallyConstant.functor_obj_val","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat ‚Üí Prop\ninst‚úù¬π : CompHausLike.HasExplicitFiniteCoproducts P\ninst‚úù : CompHausLike.HasExplicitPullbacks P\nhs : ‚àÄ ‚¶ÉX Y : CompHausLike P‚¶Ñ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f ‚Üí Function.Surjective ‚áëf\nX : Type (max u w)\n‚ä¢ Eq ((CompHausLike.LocallyConstant.functor P hs).obj X).val (CompHausLike.LocallyConstant.functorToPresheaves.obj X)","decl":"/-- `CompHausLike.LocallyConstant.functorToPresheaves` lands in sheaves. -/\n@[simps]\ndef functor :\n    haveI := CompHausLike.preregular hs\n    Type (max u w) ‚•§ Sheaf (coherentTopology (CompHausLike.{u} P)) (Type (max u w)) where\n  obj X := {\n    val := functorToPresheaves.{u, w}.obj X\n    cond := by\n      rw [Presheaf.isSheaf_of_iso_iff (functorToPresheavesIso P hs X)]\n      exact ((TopCat.discrete.obj X).toSheafCompHausLike P hs).cond }\n  map f := ‚ü®functorToPresheaves.{u, w}.map f‚ü©\n\n"}
{"name":"CompHausLike.LocallyConstant.functor_map_val","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat ‚Üí Prop\ninst‚úù¬π : CompHausLike.HasExplicitFiniteCoproducts P\ninst‚úù : CompHausLike.HasExplicitPullbacks P\nhs : ‚àÄ ‚¶ÉX Y : CompHausLike P‚¶Ñ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f ‚Üí Function.Surjective ‚áëf\nX‚úù Y‚úù : Type (max u w)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CompHausLike.LocallyConstant.functor P hs).map f).val (CompHausLike.LocallyConstant.functorToPresheaves.map f)","decl":"/-- `CompHausLike.LocallyConstant.functorToPresheaves` lands in sheaves. -/\n@[simps]\ndef functor :\n    haveI := CompHausLike.preregular hs\n    Type (max u w) ‚•§ Sheaf (coherentTopology (CompHausLike.{u} P)) (Type (max u w)) where\n  obj X := {\n    val := functorToPresheaves.{u, w}.obj X\n    cond := by\n      rw [Presheaf.isSheaf_of_iso_iff (functorToPresheavesIso P hs X)]\n      exact ((TopCat.discrete.obj X).toSheafCompHausLike P hs).cond }\n  map f := ‚ü®functorToPresheaves.{u, w}.map f‚ü©\n\n"}
{"name":"CompHausLike.LocallyConstant.counit_app_val","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat ‚Üí Prop\ninst‚úù‚Å¥ : ‚àÄ (S : CompHausLike P) (p : ‚ÜëS.toTop ‚Üí Prop), CompHausLike.HasProp P (Subtype p)\ninst‚úù¬≥ : CompHausLike.HasProp P PUnit.{u + 1}\ninst‚úù¬≤ : CompHausLike.HasExplicitFiniteCoproducts P\ninst‚úù¬π : CompHausLike.HasExplicitPullbacks P\nhs : ‚àÄ ‚¶ÉX Y : CompHausLike P‚¶Ñ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f ‚Üí Function.Surjective ‚áëf\ninst‚úù : CompHausLike.HasExplicitFiniteCoproducts P\nX : CategoryTheory.Sheaf (CategoryTheory.coherentTopology (CompHausLike P)) (Type (max u w))\n‚ä¢ Eq ((CompHausLike.LocallyConstant.counit P hs).app X).val (CompHausLike.LocallyConstant.counitApp X.val)","decl":"/-- The counit is natural in both `S : CompHausLike P` and\n`Y : Sheaf (coherentTopology (CompHausLike P)) (Type (max u w))` -/\n@[simps]\nnoncomputable def counit [HasExplicitFiniteCoproducts.{u} P] : haveI := CompHausLike.preregular hs\n    (sheafSections _ _).obj ‚ü®CompHausLike.of P PUnit.{u+1}‚ü© ‚ãô functor.{u, w} P hs ‚ü∂\n        ùü≠ (Sheaf (coherentTopology (CompHausLike.{u} P)) (Type (max u w))) where\n  app X := haveI := CompHausLike.preregular hs\n    ‚ü®counitApp X.val‚ü©\n  naturality X Y g := by\n    have := CompHausLike.preregular hs\n    apply Sheaf.hom_ext\n    simp only [functor, id_eq, eq_mpr_eq_cast, Functor.comp_obj, Functor.flip_obj_obj,\n      sheafToPresheaf_obj, Functor.id_obj, Functor.comp_map, Functor.flip_obj_map,\n      sheafToPresheaf_map, Sheaf.instCategorySheaf_comp_val, Functor.id_map]\n    ext S (f : LocallyConstant _ _)\n    simp only [FunctorToTypes.comp, counitApp_app]\n    apply presheaf_ext (f.map (g.val.app (op (CompHausLike.of P PUnit.{u+1}))))\n    intro a\n    simp only [op_unop, functorToPresheaves_map_app, incl_of_counitAppApp]\n    apply presheaf_ext (f.comap (sigmaIncl _ _))\n    intro b\n    simp only [counitAppAppImage, ‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp, CompHausLike.coe_of,\n      map_apply, IsTerminal.comp_from, ‚Üê map_preimage_eq_image_map]\n    change (_ ‚â´ Y.val.map _) _ = (_ ‚â´ Y.val.map _) _\n    simp only [‚Üê g.val.naturality,\n      show sigmaIncl (f.comap (sigmaIncl (f.map _) a)) b ‚â´ sigmaIncl (f.map _) a =\n        (sigmaInclIncl f _ a b) ‚â´ sigmaIncl f (Fiber.mk f _) from rfl]\n    simp only [op_comp, Functor.map_comp, types_comp_apply, incl_of_counitAppApp]\n    simp only [counitAppAppImage, ‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp, terminal.comp_from]\n    rw [mk_image]\n    change (X.val.map _ ‚â´ _) _ = (X.val.map _ ‚â´ _) _\n    simp only [g.val.naturality]\n    simp only [types_comp_apply]\n    have := map_preimage_eq_image (f := g.val.app _ ‚àò f) (a := a)\n    simp only [Function.comp_apply] at this\n    rw [this]\n    apply congrArg\n    symm\n    convert (b.preimage).prop\n    exact (mem_iff_eq_image (g.val.app _ ‚àò f) _ _).symm\n\n"}
{"name":"CompHausLike.LocallyConstant.unit_app","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat ‚Üí Prop\ninst‚úù¬≤ : CompHausLike.HasProp P PUnit.{u + 1}\ninst‚úù¬π : CompHausLike.HasExplicitFiniteCoproducts P\ninst‚úù : CompHausLike.HasExplicitPullbacks P\nhs : ‚àÄ ‚¶ÉX Y : CompHausLike P‚¶Ñ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f ‚Üí Function.Surjective ‚áëf\nx‚úù : Type (max u u_1)\nx : (CategoryTheory.Functor.id (Type (max u u_1))).obj x‚úù\n‚ä¢ Eq ((CompHausLike.LocallyConstant.unit P hs).app x‚úù x) (LocallyConstant.const (‚Üë(CompHausLike.of P PUnit.{u + 1}).toTop) x)","decl":"/--\nThe unit of the adjunciton is given by mapping each element to the corresponding constant map.\n-/\n@[simps]\ndef unit : ùü≠ _ ‚ü∂ functor P hs ‚ãô (sheafSections _ _).obj ‚ü®CompHausLike.of P PUnit.{u+1}‚ü© where\n  app _ x := LocallyConstant.const _ x\n\n"}
{"name":"CompHausLike.LocallyConstant.adjunction_left_triangle","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat ‚Üí Prop\ninst‚úù‚Å¥ : ‚àÄ (S : CompHausLike P) (p : ‚ÜëS.toTop ‚Üí Prop), CompHausLike.HasProp P (Subtype p)\ninst‚úù¬≥ : CompHausLike.HasProp P PUnit.{u + 1}\ninst‚úù¬≤ : CompHausLike.HasExplicitFiniteCoproducts P\ninst‚úù¬π : CompHausLike.HasExplicitPullbacks P\nhs : ‚àÄ ‚¶ÉX Y : CompHausLike P‚¶Ñ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f ‚Üí Function.Surjective ‚áëf\ninst‚úù : CompHausLike.HasExplicitFiniteCoproducts P\nX : Type (max u w)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CompHausLike.LocallyConstant.functorToPresheaves.map ((CompHausLike.LocallyConstant.unit P hs).app X)) ((CompHausLike.LocallyConstant.counit P hs).app ((CompHausLike.LocallyConstant.functor P hs).obj X)).val) (CategoryTheory.CategoryStruct.id (CompHausLike.LocallyConstant.functorToPresheaves.obj X))","decl":"lemma adjunction_left_triangle [HasExplicitFiniteCoproducts.{u} P]\n    (X : Type max u w) : functorToPresheaves.{u, w}.map ((unit P hs).app X) ‚â´\n      ((counit P hs).app ((functor P hs).obj X)).val = ùüô (functorToPresheaves.obj X) := by\n  ext ‚ü®S‚ü© (f : LocallyConstant _ X)\n  simp only [Functor.id_obj, Functor.comp_obj, FunctorToTypes.comp, NatTrans.id_app,\n    functorToPresheaves_obj_obj, types_id_apply]\n  simp only [counit, counitApp_app]\n  have := CompHausLike.preregular hs\n  apply presheaf_ext\n    (X := ((functor P hs).obj X).val) (Y := ((functor.{u, w} P hs).obj X).val)\n      (f.map ((unit P hs).app X))\n  intro a\n  erw [incl_of_counitAppApp]\n  simp only [functor_obj_val, functorToPresheaves_obj_obj, coe_of, Functor.id_obj,\n    counitAppAppImage, LocallyConstant.map_apply, functorToPresheaves_obj_map, Quiver.Hom.unop_op]\n  ext x\n  erw [‚Üê map_eq_image _ a x]\n  rfl\n\n"}
{"name":"CompHausLike.LocallyConstant.adjunction_unit","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat ‚Üí Prop\ninst‚úù‚Å¥ : ‚àÄ (S : CompHausLike P) (p : ‚ÜëS.toTop ‚Üí Prop), CompHausLike.HasProp P (Subtype p)\ninst‚úù¬≥ : CompHausLike.HasProp P PUnit.{u + 1}\ninst‚úù¬≤ : CompHausLike.HasExplicitFiniteCoproducts P\ninst‚úù¬π : CompHausLike.HasExplicitPullbacks P\nhs : ‚àÄ ‚¶ÉX Y : CompHausLike P‚¶Ñ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f ‚Üí Function.Surjective ‚áëf\ninst‚úù : CompHausLike.HasExplicitFiniteCoproducts P\n‚ä¢ Eq (CompHausLike.LocallyConstant.adjunction P hs).unit (CompHausLike.LocallyConstant.unit P hs)","decl":"/--\n`CompHausLike.LocallyConstant.functor` is left adjoint to the forgetful functor.\n-/\n@[simps]\nnoncomputable def adjunction [HasExplicitFiniteCoproducts.{u} P] :\n    functor.{u, w} P hs ‚ä£ (sheafSections _ _).obj ‚ü®CompHausLike.of P PUnit.{u+1}‚ü© where\n  unit := unit P hs\n  counit := counit P hs\n  left_triangle_components := by\n    intro X\n    simp only [Functor.comp_obj, Functor.id_obj, NatTrans.comp_app, Functor.flip_obj_obj,\n      sheafToPresheaf_obj, functor_obj_val, functorToPresheaves_obj_obj, coe_of, whiskerRight_app,\n      Functor.associator_hom_app, whiskerLeft_app, Category.id_comp, NatTrans.id_app']\n    apply Sheaf.hom_ext\n    rw [Sheaf.instCategorySheaf_comp_val, Sheaf.instCategorySheaf_id_val]\n    exact adjunction_left_triangle P hs X\n  right_triangle_components := by\n    intro X\n    ext (x : X.val.obj _)\n    simp only [Functor.comp_obj, Functor.id_obj, Functor.flip_obj_obj, sheafToPresheaf_obj,\n      FunctorToTypes.comp, whiskerLeft_app, unit_app, coe_of, Functor.associator_inv_app,\n      functor_obj_val, functorToPresheaves_obj_obj, types_id_apply, whiskerRight_app,\n      Functor.flip_obj_map, sheafToPresheaf_map, counit_app_val, counitApp_app, NatTrans.id_app']\n    have := CompHausLike.preregular hs\n    letI : PreservesFiniteProducts ((sheafToPresheaf (coherentTopology _) _).obj X) :=\n      inferInstanceAs (PreservesFiniteProducts (Sheaf.val _))\n    apply presheaf_ext ((unit P hs).app _ x)\n    intro a\n    erw [incl_of_counitAppApp]\n    simp only [sheafToPresheaf_obj, unit_app, coe_of, counitAppAppImage, coe_const]\n    erw [‚Üê map_eq_image _ a ‚ü®PUnit.unit, by simp [mem_iff_eq_image, ‚Üê map_preimage_eq_image]‚ü©]\n    rfl\n\n"}
{"name":"CompHausLike.LocallyConstant.adjunction_counit","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat ‚Üí Prop\ninst‚úù‚Å¥ : ‚àÄ (S : CompHausLike P) (p : ‚ÜëS.toTop ‚Üí Prop), CompHausLike.HasProp P (Subtype p)\ninst‚úù¬≥ : CompHausLike.HasProp P PUnit.{u + 1}\ninst‚úù¬≤ : CompHausLike.HasExplicitFiniteCoproducts P\ninst‚úù¬π : CompHausLike.HasExplicitPullbacks P\nhs : ‚àÄ ‚¶ÉX Y : CompHausLike P‚¶Ñ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f ‚Üí Function.Surjective ‚áëf\ninst‚úù : CompHausLike.HasExplicitFiniteCoproducts P\n‚ä¢ Eq (CompHausLike.LocallyConstant.adjunction P hs).counit (CompHausLike.LocallyConstant.counit P hs)","decl":"/--\n`CompHausLike.LocallyConstant.functor` is left adjoint to the forgetful functor.\n-/\n@[simps]\nnoncomputable def adjunction [HasExplicitFiniteCoproducts.{u} P] :\n    functor.{u, w} P hs ‚ä£ (sheafSections _ _).obj ‚ü®CompHausLike.of P PUnit.{u+1}‚ü© where\n  unit := unit P hs\n  counit := counit P hs\n  left_triangle_components := by\n    intro X\n    simp only [Functor.comp_obj, Functor.id_obj, NatTrans.comp_app, Functor.flip_obj_obj,\n      sheafToPresheaf_obj, functor_obj_val, functorToPresheaves_obj_obj, coe_of, whiskerRight_app,\n      Functor.associator_hom_app, whiskerLeft_app, Category.id_comp, NatTrans.id_app']\n    apply Sheaf.hom_ext\n    rw [Sheaf.instCategorySheaf_comp_val, Sheaf.instCategorySheaf_id_val]\n    exact adjunction_left_triangle P hs X\n  right_triangle_components := by\n    intro X\n    ext (x : X.val.obj _)\n    simp only [Functor.comp_obj, Functor.id_obj, Functor.flip_obj_obj, sheafToPresheaf_obj,\n      FunctorToTypes.comp, whiskerLeft_app, unit_app, coe_of, Functor.associator_inv_app,\n      functor_obj_val, functorToPresheaves_obj_obj, types_id_apply, whiskerRight_app,\n      Functor.flip_obj_map, sheafToPresheaf_map, counit_app_val, counitApp_app, NatTrans.id_app']\n    have := CompHausLike.preregular hs\n    letI : PreservesFiniteProducts ((sheafToPresheaf (coherentTopology _) _).obj X) :=\n      inferInstanceAs (PreservesFiniteProducts (Sheaf.val _))\n    apply presheaf_ext ((unit P hs).app _ x)\n    intro a\n    erw [incl_of_counitAppApp]\n    simp only [sheafToPresheaf_obj, unit_app, coe_of, counitAppAppImage, coe_const]\n    erw [‚Üê map_eq_image _ a ‚ü®PUnit.unit, by simp [mem_iff_eq_image, ‚Üê map_preimage_eq_image]‚ü©]\n    rfl\n\n"}
{"name":"CompHausLike.LocallyConstant.instIsIsoFunctorTypeUnitSheafCoherentTopologyAdjunction","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat ‚Üí Prop\ninst‚úù‚Å¥ : ‚àÄ (S : CompHausLike P) (p : ‚ÜëS.toTop ‚Üí Prop), CompHausLike.HasProp P (Subtype p)\ninst‚úù¬≥ : CompHausLike.HasProp P PUnit.{u + 1}\ninst‚úù¬≤ : CompHausLike.HasExplicitFiniteCoproducts P\ninst‚úù¬π : CompHausLike.HasExplicitPullbacks P\nhs : ‚àÄ ‚¶ÉX Y : CompHausLike P‚¶Ñ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f ‚Üí Function.Surjective ‚áëf\ninst‚úù : CompHausLike.HasExplicitFiniteCoproducts P\n‚ä¢ CategoryTheory.IsIso (CompHausLike.LocallyConstant.adjunction P hs).unit","decl":"instance [HasExplicitFiniteCoproducts.{u} P] : IsIso (adjunction P hs).unit :=\n  inferInstanceAs (IsIso (unitIso P hs).hom)\n\n"}
{"name":"CondensedSet.LocallyConstant.instFaithfulFunctor","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"‚ä¢ CondensedSet.LocallyConstant.functor.Faithful","decl":"noncomputable instance : functor.Faithful := functorFullyFaithful.faithful\n\n"}
{"name":"CondensedSet.LocallyConstant.instFullFunctor","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"‚ä¢ CondensedSet.LocallyConstant.functor.Full","decl":"noncomputable instance : functor.Full := functorFullyFaithful.full\n\n"}
{"name":"CondensedSet.LocallyConstant.instFaithfulCondensedTypeDiscrete","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"‚ä¢ (Condensed.discrete (Type (u_1 + 1))).Faithful","decl":"instance : (discrete (Type _)).Faithful := Functor.Faithful.of_iso iso\n\n"}
{"name":"CondensedSet.LocallyConstant.instFullCondensedTypeDiscrete","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"‚ä¢ (Condensed.discrete (Type (u_1 + 1))).Full","decl":"noncomputable instance : (discrete (Type _)).Full := Functor.Full.of_iso iso\n\n"}
{"name":"LightCondSet.LocallyConstant.instHasPropAndTotallyDisconnectedSpaceŒ±TopologicalSpaceSecondCountableTopologySubtypeToTop","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"S : LightProfinite\np : ‚ÜëS.toTop ‚Üí Prop\n‚ä¢ CompHausLike.HasProp (fun X => And (TotallyDisconnectedSpace ‚ÜëX) (SecondCountableTopology ‚ÜëX)) (Subtype p)","decl":"instance (S : LightProfinite.{u}) (p : S ‚Üí Prop) :\n    HasProp (fun X ‚Ü¶ TotallyDisconnectedSpace X ‚àß SecondCountableTopology X) (Subtype p) :=\n  ‚ü®‚ü®(inferInstance : TotallyDisconnectedSpace (Subtype p)),\n    (inferInstance : SecondCountableTopology {s | p s})‚ü©‚ü©\n\n"}
{"name":"LightCondSet.LocallyConstant.instFaithfulFunctor","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"‚ä¢ LightCondSet.LocallyConstant.functor.Faithful","decl":"instance : functor.{u}.Faithful := functorFullyFaithful.faithful\n\n"}
{"name":"LightCondSet.LocallyConstant.instFullFunctor","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"‚ä¢ LightCondSet.LocallyConstant.functor.Full","decl":"instance : LightCondSet.LocallyConstant.functor.Full := functorFullyFaithful.full\n\n"}
{"name":"LightCondSet.LocallyConstant.instFaithfulLightCondensedTypeDiscrete","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"‚ä¢ (LightCondensed.discrete (Type u)).Faithful","decl":"instance : (LightCondensed.discrete (Type u)).Faithful := Functor.Faithful.of_iso iso.{u}\n\n"}
{"name":"LightCondSet.LocallyConstant.instFullLightCondensedTypeDiscrete","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"‚ä¢ (LightCondensed.discrete (Type u)).Full","decl":"instance : (LightCondensed.discrete (Type u)).Full := Functor.Full.of_iso iso.{u}\n\n"}
