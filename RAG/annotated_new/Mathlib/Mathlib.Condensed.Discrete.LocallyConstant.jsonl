{"name":"CompHausLike.LocallyConstant.functorToPresheaves_map_app","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat → Prop\nX✝ Y✝ : Type (max u w)\nf : Quiver.Hom X✝ Y✝\nx✝ : Opposite (CompHausLike P)\nt : ((fun X => { obj := fun x => CompHausLike.LocallyConstant.functorToPresheaves.match_1 (fun x => Type (max u w)) x fun S => LocallyConstant (↑S.toTop) X, map := fun {X_1 Y} f g => LocallyConstant.comap f.unop g, map_id := ⋯, map_comp := ⋯ }) X✝).obj x✝\n⊢ Eq ((CompHausLike.LocallyConstant.functorToPresheaves.map f).app x✝ t) (LocallyConstant.map f t)","decl":"/--\nThe functor from the category of sets to presheaves on `CompHausLike P` given by locally constant\nmaps.\n-/\n@[simps]\ndef functorToPresheaves : Type (max u w) ⥤ ((CompHausLike.{u} P)ᵒᵖ ⥤ Type max u w) where\n  obj X := {\n    obj := fun ⟨S⟩ ↦ LocallyConstant S X\n    map := fun f g ↦ g.comap f.unop }\n  map f := { app := fun _ t ↦ t.map f }\n\n"}
{"name":"CompHausLike.LocallyConstant.functorToPresheaves_obj_map","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat → Prop\nX : Type (max u w)\nX✝ Y✝ : Opposite (CompHausLike P)\nf : Quiver.Hom X✝ Y✝\ng : CompHausLike.LocallyConstant.functorToPresheaves.match_1 (fun x => Type (max u w)) X✝ fun S => LocallyConstant (↑S.toTop) X\n⊢ Eq ((CompHausLike.LocallyConstant.functorToPresheaves.obj X).map f g) (LocallyConstant.comap f.unop g)","decl":"/--\nThe functor from the category of sets to presheaves on `CompHausLike P` given by locally constant\nmaps.\n-/\n@[simps]\ndef functorToPresheaves : Type (max u w) ⥤ ((CompHausLike.{u} P)ᵒᵖ ⥤ Type max u w) where\n  obj X := {\n    obj := fun ⟨S⟩ ↦ LocallyConstant S X\n    map := fun f g ↦ g.comap f.unop }\n  map f := { app := fun _ t ↦ t.map f }\n\n"}
{"name":"CompHausLike.LocallyConstant.functorToPresheaves_obj_obj","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat → Prop\nX : Type (max u w)\nx✝ : Opposite (CompHausLike P)\n⊢ Eq ((CompHausLike.LocallyConstant.functorToPresheaves.obj X).obj x✝) (CompHausLike.LocallyConstant.functorToPresheaves.match_1 (fun x => Type (max u w)) x✝ fun S => LocallyConstant (↑S.toTop) X)","decl":"/--\nThe functor from the category of sets to presheaves on `CompHausLike P` given by locally constant\nmaps.\n-/\n@[simps]\ndef functorToPresheaves : Type (max u w) ⥤ ((CompHausLike.{u} P)ᵒᵖ ⥤ Type max u w) where\n  obj X := {\n    obj := fun ⟨S⟩ ↦ LocallyConstant S X\n    map := fun f g ↦ g.comap f.unop }\n  map f := { app := fun _ t ↦ t.map f }\n\n"}
{"name":"CompHausLike.LocallyConstant.locallyConstantIsoContinuousMap_inv_apply","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"Y : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace Y\nf : ContinuousMap Y ↑(TopCat.discrete.obj X)\na : Y\n⊢ Eq (((CompHausLike.LocallyConstant.locallyConstantIsoContinuousMap Y X).inv f) a) (f a)","decl":"/--\nLocally constant maps are the same as continuous maps when the target is equipped with the discrete\ntopology\n-/\n@[simps]\ndef locallyConstantIsoContinuousMap (Y X : Type*) [TopologicalSpace Y] :\n    LocallyConstant Y X ≅ C(Y, TopCat.discrete.obj X) :=\n  letI : TopologicalSpace X := ⊥\n  haveI : DiscreteTopology X := ⟨rfl⟩\n  { hom := fun f ↦ (f : C(Y, X))\n    inv := fun f ↦ ⟨f, (IsLocallyConstant.iff_continuous f).mpr f.2⟩ }\n\n"}
{"name":"CompHausLike.LocallyConstant.locallyConstantIsoContinuousMap_hom","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"Y : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace Y\nf : LocallyConstant Y X\n⊢ Eq ((CompHausLike.LocallyConstant.locallyConstantIsoContinuousMap Y X).hom f) ↑f","decl":"/--\nLocally constant maps are the same as continuous maps when the target is equipped with the discrete\ntopology\n-/\n@[simps]\ndef locallyConstantIsoContinuousMap (Y X : Type*) [TopologicalSpace Y] :\n    LocallyConstant Y X ≅ C(Y, TopCat.discrete.obj X) :=\n  letI : TopologicalSpace X := ⊥\n  haveI : DiscreteTopology X := ⟨rfl⟩\n  { hom := fun f ↦ (f : C(Y, X))\n    inv := fun f ↦ ⟨f, (IsLocallyConstant.iff_continuous f).mpr f.2⟩ }\n\n"}
{"name":"CompHausLike.LocallyConstant.instHasPropαTopologicalSpaceToTopFiber","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat → Prop\ninst✝ : ∀ (S : CompHausLike P) (p : ↑S.toTop → Prop), CompHausLike.HasProp P (Subtype p)\nQ : CompHausLike P\nZ : Type (max u w)\nr : LocallyConstant (↑Q.toTop) Z\na : Function.Fiber ⇑r\n⊢ CompHausLike.HasProp P ↑(CompHausLike.LocallyConstant.fiber r a).toTop","decl":"instance : HasProp P (fiber r a) := inferInstanceAs (HasProp P (Subtype _))\n\n"}
{"name":"CompHausLike.LocallyConstant.sigmaComparison_comp_sigmaIso","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat → Prop\ninst✝¹ : ∀ (S : CompHausLike P) (p : ↑S.toTop → Prop), CompHausLike.HasProp P (Subtype p)\nQ : CompHausLike P\nZ : Type (max u w)\nr : LocallyConstant (↑Q.toTop) Z\na : Function.Fiber ⇑r\ninst✝ : CompHausLike.HasExplicitFiniteCoproducts P\nX : CategoryTheory.Functor (Opposite (CompHausLike P)) (Type (max u w))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.mapIso (CompHausLike.LocallyConstant.sigmaIso r).op).hom (CategoryTheory.CategoryStruct.comp (CompHausLike.sigmaComparison X fun a => ↑(CompHausLike.LocallyConstant.fiber r a).toTop) fun g => g a)) (X.map (CompHausLike.LocallyConstant.sigmaIncl r a).op)","decl":"lemma sigmaComparison_comp_sigmaIso [HasExplicitFiniteCoproducts.{u} P]\n    (X : (CompHausLike.{u} P)ᵒᵖ ⥤ Type max u w) :\n    (X.mapIso (sigmaIso r).op).hom ≫ sigmaComparison X (fun a ↦ (fiber r a).1) ≫\n      (fun g ↦ g a) = X.map (sigmaIncl r a).op := by\n  ext\n  simp only [Functor.mapIso_hom, Iso.op_hom, types_comp_apply, sigmaComparison, coe_of,\n    ← FunctorToTypes.map_comp_apply]\n  rfl\n\n"}
{"name":"CompHausLike.LocallyConstant.presheaf_ext","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat → Prop\ninst✝³ : ∀ (S : CompHausLike P) (p : ↑S.toTop → Prop), CompHausLike.HasProp P (Subtype p)\nS : CompHausLike P\nY : CategoryTheory.Functor (Opposite (CompHausLike P)) (Type (max u w))\ninst✝² : CompHausLike.HasProp P PUnit.{u + 1}\nf : LocallyConstant (↑S.toTop) (Y.obj { unop := CompHausLike.of P PUnit.{u + 1} })\nX : CategoryTheory.Functor (Opposite (CompHausLike P)) (Type (max u w))\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteProducts X\nx y : X.obj { unop := S }\ninst✝ : CompHausLike.HasExplicitFiniteCoproducts P\nh : ∀ (a : Function.Fiber ⇑f), Eq (X.map (CompHausLike.LocallyConstant.sigmaIncl f a).op x) (X.map (CompHausLike.LocallyConstant.sigmaIncl f a).op y)\n⊢ Eq x y","decl":"/--\nTo check equality of two elements of `X(S)`, it suffices to check equality after composing with\neach `X(S) → X(Sᵢ)`.\n-/\nlemma presheaf_ext (X : (CompHausLike.{u} P)ᵒᵖ ⥤ Type max u w)\n    [PreservesFiniteProducts X] (x y : X.obj ⟨S⟩)\n    [HasExplicitFiniteCoproducts.{u} P]\n    (h : ∀ (a : Fiber f), X.map (sigmaIncl f a).op x = X.map (sigmaIncl f a).op y) : x = y := by\n  apply injective_of_mono (X.mapIso (sigmaIso f).op).hom\n  apply injective_of_mono (sigmaComparison X (fun a ↦ (fiber f a).1))\n  ext a\n  specialize h a\n  rw [← sigmaComparison_comp_sigmaIso] at h\n  exact h\n\n"}
{"name":"CompHausLike.LocallyConstant.incl_of_counitAppApp","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat → Prop\ninst✝³ : ∀ (S : CompHausLike P) (p : ↑S.toTop → Prop), CompHausLike.HasProp P (Subtype p)\nS : CompHausLike P\nY : CategoryTheory.Functor (Opposite (CompHausLike P)) (Type (max u w))\ninst✝² : CompHausLike.HasProp P PUnit.{u + 1}\nf : LocallyConstant (↑S.toTop) (Y.obj { unop := CompHausLike.of P PUnit.{u + 1} })\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteProducts Y\ninst✝ : CompHausLike.HasExplicitFiniteCoproducts P\na : Function.Fiber ⇑f\n⊢ Eq (Y.map (CompHausLike.LocallyConstant.sigmaIncl f a).op (CompHausLike.LocallyConstant.counitAppApp S Y f)) (CompHausLike.LocallyConstant.counitAppAppImage f a)","decl":"lemma incl_of_counitAppApp [PreservesFiniteProducts Y] [HasExplicitFiniteCoproducts.{u} P]\n    (a : Fiber f) : Y.map (sigmaIncl f a).op (counitAppApp S Y f) = counitAppAppImage f a := by\n  rw [← sigmaComparison_comp_sigmaIso, Functor.mapIso_hom, Iso.op_hom, types_comp_apply]\n  simp only [counitAppApp, Functor.mapIso_inv, ← Iso.op_hom, types_comp_apply,\n    ← FunctorToTypes.map_comp_apply, Iso.inv_hom_id, FunctorToTypes.map_id_apply]\n  exact congrFun (inv_hom_id_apply (asIso (sigmaComparison Y (fun a ↦ (fiber f a).1)))\n    (counitAppAppImage f)) _\n\n"}
{"name":"CompHausLike.LocallyConstant.incl_comap","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat → Prop\ninst✝¹ : ∀ (S : CompHausLike P) (p : ↑S.toTop → Prop), CompHausLike.HasProp P (Subtype p)\nY : CategoryTheory.Functor (Opposite (CompHausLike P)) (Type (max u w))\ninst✝ : CompHausLike.HasProp P PUnit.{u + 1}\nS T : Opposite (CompHausLike P)\nf : LocallyConstant (↑(Opposite.unop S).toTop) (Y.obj { unop := CompHausLike.of P PUnit.{u + 1} })\ng : Quiver.Hom S T\na : Function.Fiber ⇑(LocallyConstant.comap g.unop f)\n⊢ Eq (CategoryTheory.CategoryStruct.comp g (CompHausLike.LocallyConstant.sigmaIncl (LocallyConstant.comap g.unop f) a).op) (CategoryTheory.CategoryStruct.comp (CompHausLike.LocallyConstant.sigmaIncl f (Function.Fiber.mk (⇑f) (g.unop (Function.Fiber.preimage (⇑(LocallyConstant.comap g.unop f)) a)))).op (CompHausLike.LocallyConstant.componentHom f g.unop a).op)","decl":"lemma incl_comap {S T : (CompHausLike P)ᵒᵖ}\n    (f : LocallyConstant S.unop (Y.obj (op (CompHausLike.of P PUnit.{u+1}))))\n      (g : S ⟶ T) (a : Fiber (f.comap g.unop)) :\n        g ≫ (sigmaIncl (f.comap g.unop) a).op =\n          (sigmaIncl f _).op ≫ (componentHom f g.unop a).op :=\n  rfl\n\n"}
{"name":"CompHausLike.LocallyConstant.counitApp_app","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat → Prop\ninst✝³ : ∀ (S : CompHausLike P) (p : ↑S.toTop → Prop), CompHausLike.HasProp P (Subtype p)\ninst✝² : CompHausLike.HasProp P PUnit.{u + 1}\ninst✝¹ : CompHausLike.HasExplicitFiniteCoproducts P\nY : CategoryTheory.Functor (Opposite (CompHausLike P)) (Type (max u w))\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts Y\nx✝ : Opposite (CompHausLike P)\na✝ : (CompHausLike.LocallyConstant.functorToPresheaves.obj (Y.obj { unop := CompHausLike.of P PUnit.{u + 1} })).obj x✝\n⊢ Eq ((CompHausLike.LocallyConstant.counitApp Y).app x✝ a✝) (CompHausLike.LocallyConstant.counitAppApp (Opposite.unop x✝) Y a✝)","decl":"/-- The counit is natural in `S : CompHausLike P` -/\n@[simps!]\nnoncomputable def counitApp [HasExplicitFiniteCoproducts.{u} P]\n    (Y : (CompHausLike.{u} P)ᵒᵖ ⥤ Type max u w) [PreservesFiniteProducts Y] :\n    (functorToPresheaves.obj (Y.obj (op (CompHausLike.of P PUnit.{u+1})))) ⟶ Y where\n  app := fun ⟨S⟩ ↦ counitAppApp S Y\n  naturality := by\n    intro S T g\n    ext f\n    apply presheaf_ext (f.comap g.unop)\n    intro a\n    simp only [op_unop, functorToPresheaves_obj_obj, types_comp_apply, functorToPresheaves_obj_map,\n      incl_of_counitAppApp, ← FunctorToTypes.map_comp_apply, incl_comap]\n    simp only [FunctorToTypes.map_comp_apply, incl_of_counitAppApp]\n    simp only [counitAppAppImage, ← FunctorToTypes.map_comp_apply, ← op_comp,\n      terminal.comp_from]\n    apply congrArg\n    exact image_eq_image_mk (g := g.unop) (a := a)\n\n"}
{"name":"CompHausLike.LocallyConstant.functor_obj_val","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat → Prop\ninst✝¹ : CompHausLike.HasExplicitFiniteCoproducts P\ninst✝ : CompHausLike.HasExplicitPullbacks P\nhs : ∀ ⦃X Y : CompHausLike P⦄ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f → Function.Surjective ⇑f\nX : Type (max u w)\n⊢ Eq ((CompHausLike.LocallyConstant.functor P hs).obj X).val (CompHausLike.LocallyConstant.functorToPresheaves.obj X)","decl":"/-- `CompHausLike.LocallyConstant.functorToPresheaves` lands in sheaves. -/\n@[simps]\ndef functor :\n    haveI := CompHausLike.preregular hs\n    Type (max u w) ⥤ Sheaf (coherentTopology (CompHausLike.{u} P)) (Type (max u w)) where\n  obj X := {\n    val := functorToPresheaves.{u, w}.obj X\n    cond := by\n      rw [Presheaf.isSheaf_of_iso_iff (functorToPresheavesIso P hs X)]\n      exact ((TopCat.discrete.obj X).toSheafCompHausLike P hs).cond }\n  map f := ⟨functorToPresheaves.{u, w}.map f⟩\n\n"}
{"name":"CompHausLike.LocallyConstant.functor_map_val","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat → Prop\ninst✝¹ : CompHausLike.HasExplicitFiniteCoproducts P\ninst✝ : CompHausLike.HasExplicitPullbacks P\nhs : ∀ ⦃X Y : CompHausLike P⦄ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f → Function.Surjective ⇑f\nX✝ Y✝ : Type (max u w)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CompHausLike.LocallyConstant.functor P hs).map f).val (CompHausLike.LocallyConstant.functorToPresheaves.map f)","decl":"/-- `CompHausLike.LocallyConstant.functorToPresheaves` lands in sheaves. -/\n@[simps]\ndef functor :\n    haveI := CompHausLike.preregular hs\n    Type (max u w) ⥤ Sheaf (coherentTopology (CompHausLike.{u} P)) (Type (max u w)) where\n  obj X := {\n    val := functorToPresheaves.{u, w}.obj X\n    cond := by\n      rw [Presheaf.isSheaf_of_iso_iff (functorToPresheavesIso P hs X)]\n      exact ((TopCat.discrete.obj X).toSheafCompHausLike P hs).cond }\n  map f := ⟨functorToPresheaves.{u, w}.map f⟩\n\n"}
{"name":"CompHausLike.LocallyConstant.counit_app_val","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat → Prop\ninst✝⁴ : ∀ (S : CompHausLike P) (p : ↑S.toTop → Prop), CompHausLike.HasProp P (Subtype p)\ninst✝³ : CompHausLike.HasProp P PUnit.{u + 1}\ninst✝² : CompHausLike.HasExplicitFiniteCoproducts P\ninst✝¹ : CompHausLike.HasExplicitPullbacks P\nhs : ∀ ⦃X Y : CompHausLike P⦄ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f → Function.Surjective ⇑f\ninst✝ : CompHausLike.HasExplicitFiniteCoproducts P\nX : CategoryTheory.Sheaf (CategoryTheory.coherentTopology (CompHausLike P)) (Type (max u w))\n⊢ Eq ((CompHausLike.LocallyConstant.counit P hs).app X).val (CompHausLike.LocallyConstant.counitApp X.val)","decl":"/-- The counit is natural in both `S : CompHausLike P` and\n`Y : Sheaf (coherentTopology (CompHausLike P)) (Type (max u w))` -/\n@[simps]\nnoncomputable def counit [HasExplicitFiniteCoproducts.{u} P] : haveI := CompHausLike.preregular hs\n    (sheafSections _ _).obj ⟨CompHausLike.of P PUnit.{u+1}⟩ ⋙ functor.{u, w} P hs ⟶\n        𝟭 (Sheaf (coherentTopology (CompHausLike.{u} P)) (Type (max u w))) where\n  app X := haveI := CompHausLike.preregular hs\n    ⟨counitApp X.val⟩\n  naturality X Y g := by\n    have := CompHausLike.preregular hs\n    apply Sheaf.hom_ext\n    simp only [functor, id_eq, eq_mpr_eq_cast, Functor.comp_obj, Functor.flip_obj_obj,\n      sheafToPresheaf_obj, Functor.id_obj, Functor.comp_map, Functor.flip_obj_map,\n      sheafToPresheaf_map, Sheaf.instCategorySheaf_comp_val, Functor.id_map]\n    ext S (f : LocallyConstant _ _)\n    simp only [FunctorToTypes.comp, counitApp_app]\n    apply presheaf_ext (f.map (g.val.app (op (CompHausLike.of P PUnit.{u+1}))))\n    intro a\n    simp only [op_unop, functorToPresheaves_map_app, incl_of_counitAppApp]\n    apply presheaf_ext (f.comap (sigmaIncl _ _))\n    intro b\n    simp only [counitAppAppImage, ← FunctorToTypes.map_comp_apply, ← op_comp, CompHausLike.coe_of,\n      map_apply, IsTerminal.comp_from, ← map_preimage_eq_image_map]\n    change (_ ≫ Y.val.map _) _ = (_ ≫ Y.val.map _) _\n    simp only [← g.val.naturality,\n      show sigmaIncl (f.comap (sigmaIncl (f.map _) a)) b ≫ sigmaIncl (f.map _) a =\n        (sigmaInclIncl f _ a b) ≫ sigmaIncl f (Fiber.mk f _) from rfl]\n    simp only [op_comp, Functor.map_comp, types_comp_apply, incl_of_counitAppApp]\n    simp only [counitAppAppImage, ← FunctorToTypes.map_comp_apply, ← op_comp, terminal.comp_from]\n    rw [mk_image]\n    change (X.val.map _ ≫ _) _ = (X.val.map _ ≫ _) _\n    simp only [g.val.naturality]\n    simp only [types_comp_apply]\n    have := map_preimage_eq_image (f := g.val.app _ ∘ f) (a := a)\n    simp only [Function.comp_apply] at this\n    rw [this]\n    apply congrArg\n    symm\n    convert (b.preimage).prop\n    exact (mem_iff_eq_image (g.val.app _ ∘ f) _ _).symm\n\n"}
{"name":"CompHausLike.LocallyConstant.unit_app","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat → Prop\ninst✝² : CompHausLike.HasProp P PUnit.{u + 1}\ninst✝¹ : CompHausLike.HasExplicitFiniteCoproducts P\ninst✝ : CompHausLike.HasExplicitPullbacks P\nhs : ∀ ⦃X Y : CompHausLike P⦄ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f → Function.Surjective ⇑f\nx✝ : Type (max u u_1)\nx : (CategoryTheory.Functor.id (Type (max u u_1))).obj x✝\n⊢ Eq ((CompHausLike.LocallyConstant.unit P hs).app x✝ x) (LocallyConstant.const (↑(CompHausLike.of P PUnit.{u + 1}).toTop) x)","decl":"/--\nThe unit of the adjunciton is given by mapping each element to the corresponding constant map.\n-/\n@[simps]\ndef unit : 𝟭 _ ⟶ functor P hs ⋙ (sheafSections _ _).obj ⟨CompHausLike.of P PUnit.{u+1}⟩ where\n  app _ x := LocallyConstant.const _ x\n\n"}
{"name":"CompHausLike.LocallyConstant.adjunction_left_triangle","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat → Prop\ninst✝⁴ : ∀ (S : CompHausLike P) (p : ↑S.toTop → Prop), CompHausLike.HasProp P (Subtype p)\ninst✝³ : CompHausLike.HasProp P PUnit.{u + 1}\ninst✝² : CompHausLike.HasExplicitFiniteCoproducts P\ninst✝¹ : CompHausLike.HasExplicitPullbacks P\nhs : ∀ ⦃X Y : CompHausLike P⦄ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f → Function.Surjective ⇑f\ninst✝ : CompHausLike.HasExplicitFiniteCoproducts P\nX : Type (max u w)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CompHausLike.LocallyConstant.functorToPresheaves.map ((CompHausLike.LocallyConstant.unit P hs).app X)) ((CompHausLike.LocallyConstant.counit P hs).app ((CompHausLike.LocallyConstant.functor P hs).obj X)).val) (CategoryTheory.CategoryStruct.id (CompHausLike.LocallyConstant.functorToPresheaves.obj X))","decl":"lemma adjunction_left_triangle [HasExplicitFiniteCoproducts.{u} P]\n    (X : Type max u w) : functorToPresheaves.{u, w}.map ((unit P hs).app X) ≫\n      ((counit P hs).app ((functor P hs).obj X)).val = 𝟙 (functorToPresheaves.obj X) := by\n  ext ⟨S⟩ (f : LocallyConstant _ X)\n  simp only [Functor.id_obj, Functor.comp_obj, FunctorToTypes.comp, NatTrans.id_app,\n    functorToPresheaves_obj_obj, types_id_apply]\n  simp only [counit, counitApp_app]\n  have := CompHausLike.preregular hs\n  apply presheaf_ext\n    (X := ((functor P hs).obj X).val) (Y := ((functor.{u, w} P hs).obj X).val)\n      (f.map ((unit P hs).app X))\n  intro a\n  erw [incl_of_counitAppApp]\n  simp only [functor_obj_val, functorToPresheaves_obj_obj, coe_of, Functor.id_obj,\n    counitAppAppImage, LocallyConstant.map_apply, functorToPresheaves_obj_map, Quiver.Hom.unop_op]\n  ext x\n  erw [← map_eq_image _ a x]\n  rfl\n\n"}
{"name":"CompHausLike.LocallyConstant.adjunction_unit","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat → Prop\ninst✝⁴ : ∀ (S : CompHausLike P) (p : ↑S.toTop → Prop), CompHausLike.HasProp P (Subtype p)\ninst✝³ : CompHausLike.HasProp P PUnit.{u + 1}\ninst✝² : CompHausLike.HasExplicitFiniteCoproducts P\ninst✝¹ : CompHausLike.HasExplicitPullbacks P\nhs : ∀ ⦃X Y : CompHausLike P⦄ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f → Function.Surjective ⇑f\ninst✝ : CompHausLike.HasExplicitFiniteCoproducts P\n⊢ Eq (CompHausLike.LocallyConstant.adjunction P hs).unit (CompHausLike.LocallyConstant.unit P hs)","decl":"/--\n`CompHausLike.LocallyConstant.functor` is left adjoint to the forgetful functor.\n-/\n@[simps]\nnoncomputable def adjunction [HasExplicitFiniteCoproducts.{u} P] :\n    functor.{u, w} P hs ⊣ (sheafSections _ _).obj ⟨CompHausLike.of P PUnit.{u+1}⟩ where\n  unit := unit P hs\n  counit := counit P hs\n  left_triangle_components := by\n    intro X\n    simp only [Functor.comp_obj, Functor.id_obj, NatTrans.comp_app, Functor.flip_obj_obj,\n      sheafToPresheaf_obj, functor_obj_val, functorToPresheaves_obj_obj, coe_of, whiskerRight_app,\n      Functor.associator_hom_app, whiskerLeft_app, Category.id_comp, NatTrans.id_app']\n    apply Sheaf.hom_ext\n    rw [Sheaf.instCategorySheaf_comp_val, Sheaf.instCategorySheaf_id_val]\n    exact adjunction_left_triangle P hs X\n  right_triangle_components := by\n    intro X\n    ext (x : X.val.obj _)\n    simp only [Functor.comp_obj, Functor.id_obj, Functor.flip_obj_obj, sheafToPresheaf_obj,\n      FunctorToTypes.comp, whiskerLeft_app, unit_app, coe_of, Functor.associator_inv_app,\n      functor_obj_val, functorToPresheaves_obj_obj, types_id_apply, whiskerRight_app,\n      Functor.flip_obj_map, sheafToPresheaf_map, counit_app_val, counitApp_app, NatTrans.id_app']\n    have := CompHausLike.preregular hs\n    letI : PreservesFiniteProducts ((sheafToPresheaf (coherentTopology _) _).obj X) :=\n      inferInstanceAs (PreservesFiniteProducts (Sheaf.val _))\n    apply presheaf_ext ((unit P hs).app _ x)\n    intro a\n    erw [incl_of_counitAppApp]\n    simp only [sheafToPresheaf_obj, unit_app, coe_of, counitAppAppImage, coe_const]\n    erw [← map_eq_image _ a ⟨PUnit.unit, by simp [mem_iff_eq_image, ← map_preimage_eq_image]⟩]\n    rfl\n\n"}
{"name":"CompHausLike.LocallyConstant.adjunction_counit","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat → Prop\ninst✝⁴ : ∀ (S : CompHausLike P) (p : ↑S.toTop → Prop), CompHausLike.HasProp P (Subtype p)\ninst✝³ : CompHausLike.HasProp P PUnit.{u + 1}\ninst✝² : CompHausLike.HasExplicitFiniteCoproducts P\ninst✝¹ : CompHausLike.HasExplicitPullbacks P\nhs : ∀ ⦃X Y : CompHausLike P⦄ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f → Function.Surjective ⇑f\ninst✝ : CompHausLike.HasExplicitFiniteCoproducts P\n⊢ Eq (CompHausLike.LocallyConstant.adjunction P hs).counit (CompHausLike.LocallyConstant.counit P hs)","decl":"/--\n`CompHausLike.LocallyConstant.functor` is left adjoint to the forgetful functor.\n-/\n@[simps]\nnoncomputable def adjunction [HasExplicitFiniteCoproducts.{u} P] :\n    functor.{u, w} P hs ⊣ (sheafSections _ _).obj ⟨CompHausLike.of P PUnit.{u+1}⟩ where\n  unit := unit P hs\n  counit := counit P hs\n  left_triangle_components := by\n    intro X\n    simp only [Functor.comp_obj, Functor.id_obj, NatTrans.comp_app, Functor.flip_obj_obj,\n      sheafToPresheaf_obj, functor_obj_val, functorToPresheaves_obj_obj, coe_of, whiskerRight_app,\n      Functor.associator_hom_app, whiskerLeft_app, Category.id_comp, NatTrans.id_app']\n    apply Sheaf.hom_ext\n    rw [Sheaf.instCategorySheaf_comp_val, Sheaf.instCategorySheaf_id_val]\n    exact adjunction_left_triangle P hs X\n  right_triangle_components := by\n    intro X\n    ext (x : X.val.obj _)\n    simp only [Functor.comp_obj, Functor.id_obj, Functor.flip_obj_obj, sheafToPresheaf_obj,\n      FunctorToTypes.comp, whiskerLeft_app, unit_app, coe_of, Functor.associator_inv_app,\n      functor_obj_val, functorToPresheaves_obj_obj, types_id_apply, whiskerRight_app,\n      Functor.flip_obj_map, sheafToPresheaf_map, counit_app_val, counitApp_app, NatTrans.id_app']\n    have := CompHausLike.preregular hs\n    letI : PreservesFiniteProducts ((sheafToPresheaf (coherentTopology _) _).obj X) :=\n      inferInstanceAs (PreservesFiniteProducts (Sheaf.val _))\n    apply presheaf_ext ((unit P hs).app _ x)\n    intro a\n    erw [incl_of_counitAppApp]\n    simp only [sheafToPresheaf_obj, unit_app, coe_of, counitAppAppImage, coe_const]\n    erw [← map_eq_image _ a ⟨PUnit.unit, by simp [mem_iff_eq_image, ← map_preimage_eq_image]⟩]\n    rfl\n\n"}
{"name":"CompHausLike.LocallyConstant.instIsIsoFunctorTypeUnitSheafCoherentTopologyAdjunction","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"P : TopCat → Prop\ninst✝⁴ : ∀ (S : CompHausLike P) (p : ↑S.toTop → Prop), CompHausLike.HasProp P (Subtype p)\ninst✝³ : CompHausLike.HasProp P PUnit.{u + 1}\ninst✝² : CompHausLike.HasExplicitFiniteCoproducts P\ninst✝¹ : CompHausLike.HasExplicitPullbacks P\nhs : ∀ ⦃X Y : CompHausLike P⦄ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f → Function.Surjective ⇑f\ninst✝ : CompHausLike.HasExplicitFiniteCoproducts P\n⊢ CategoryTheory.IsIso (CompHausLike.LocallyConstant.adjunction P hs).unit","decl":"instance [HasExplicitFiniteCoproducts.{u} P] : IsIso (adjunction P hs).unit :=\n  inferInstanceAs (IsIso (unitIso P hs).hom)\n\n"}
{"name":"CondensedSet.LocallyConstant.instFaithfulFunctor","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"⊢ CondensedSet.LocallyConstant.functor.Faithful","decl":"noncomputable instance : functor.Faithful := functorFullyFaithful.faithful\n\n"}
{"name":"CondensedSet.LocallyConstant.instFullFunctor","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"⊢ CondensedSet.LocallyConstant.functor.Full","decl":"noncomputable instance : functor.Full := functorFullyFaithful.full\n\n"}
{"name":"CondensedSet.LocallyConstant.instFaithfulCondensedTypeDiscrete","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"⊢ (Condensed.discrete (Type (u_1 + 1))).Faithful","decl":"instance : (discrete (Type _)).Faithful := Functor.Faithful.of_iso iso\n\n"}
{"name":"CondensedSet.LocallyConstant.instFullCondensedTypeDiscrete","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"⊢ (Condensed.discrete (Type (u_1 + 1))).Full","decl":"noncomputable instance : (discrete (Type _)).Full := Functor.Full.of_iso iso\n\n"}
{"name":"LightCondSet.LocallyConstant.instHasPropAndTotallyDisconnectedSpaceαTopologicalSpaceSecondCountableTopologySubtypeToTop","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"S : LightProfinite\np : ↑S.toTop → Prop\n⊢ CompHausLike.HasProp (fun X => And (TotallyDisconnectedSpace ↑X) (SecondCountableTopology ↑X)) (Subtype p)","decl":"instance (S : LightProfinite.{u}) (p : S → Prop) :\n    HasProp (fun X ↦ TotallyDisconnectedSpace X ∧ SecondCountableTopology X) (Subtype p) :=\n  ⟨⟨(inferInstance : TotallyDisconnectedSpace (Subtype p)),\n    (inferInstance : SecondCountableTopology {s | p s})⟩⟩\n\n"}
{"name":"LightCondSet.LocallyConstant.instFaithfulFunctor","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"⊢ LightCondSet.LocallyConstant.functor.Faithful","decl":"instance : functor.{u}.Faithful := functorFullyFaithful.faithful\n\n"}
{"name":"LightCondSet.LocallyConstant.instFullFunctor","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"⊢ LightCondSet.LocallyConstant.functor.Full","decl":"instance : LightCondSet.LocallyConstant.functor.Full := functorFullyFaithful.full\n\n"}
{"name":"LightCondSet.LocallyConstant.instFaithfulLightCondensedTypeDiscrete","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"⊢ (LightCondensed.discrete (Type u)).Faithful","decl":"instance : (LightCondensed.discrete (Type u)).Faithful := Functor.Faithful.of_iso iso.{u}\n\n"}
{"name":"LightCondSet.LocallyConstant.instFullLightCondensedTypeDiscrete","module":"Mathlib.Condensed.Discrete.LocallyConstant","initialProofState":"⊢ (LightCondensed.discrete (Type u)).Full","decl":"instance : (LightCondensed.discrete (Type u)).Full := Functor.Full.of_iso iso.{u}\n\n"}
