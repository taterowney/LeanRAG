{"name":"HasConstantSpeedOnWith.hasLocallyBoundedVariationOn","module":"Mathlib.Analysis.ConstantSpeed","initialProofState":"E : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : Real → E\ns : Set Real\nl : NNReal\nh : HasConstantSpeedOnWith f s l\n⊢ LocallyBoundedVariationOn f s","decl":"theorem HasConstantSpeedOnWith.hasLocallyBoundedVariationOn (h : HasConstantSpeedOnWith f s l) :\n    LocallyBoundedVariationOn f s := fun x y hx hy => by\n  simp only [BoundedVariationOn, h hx hy, Ne, ENNReal.ofReal_ne_top, not_false_iff]\n\n"}
{"name":"hasConstantSpeedOnWith_of_subsingleton","module":"Mathlib.Analysis.ConstantSpeed","initialProofState":"E : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : Real → E\ns : Set Real\nhs : s.Subsingleton\nl : NNReal\n⊢ HasConstantSpeedOnWith f s l","decl":"theorem hasConstantSpeedOnWith_of_subsingleton (f : ℝ → E) {s : Set ℝ} (hs : s.Subsingleton)\n    (l : ℝ≥0) : HasConstantSpeedOnWith f s l := by\n  rintro x hx y hy; cases hs hx hy\n  rw [eVariationOn.subsingleton f (fun y hy z hz => hs hy.1 hz.1 : (s ∩ Icc x x).Subsingleton)]\n  simp only [sub_self, mul_zero, ENNReal.ofReal_zero]\n\n"}
{"name":"hasConstantSpeedOnWith_iff_ordered","module":"Mathlib.Analysis.ConstantSpeed","initialProofState":"E : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : Real → E\ns : Set Real\nl : NNReal\n⊢ Iff (HasConstantSpeedOnWith f s l) (∀ ⦃x : Real⦄, Membership.mem s x → ∀ ⦃y : Real⦄, Membership.mem s y → LE.le x y → Eq (eVariationOn f (Inter.inter s (Set.Icc x y))) (ENNReal.ofReal (HMul.hMul (↑l) (HSub.hSub y x))))","decl":"theorem hasConstantSpeedOnWith_iff_ordered :\n    HasConstantSpeedOnWith f s l ↔ ∀ ⦃x⦄ (_ : x ∈ s) ⦃y⦄ (_ : y ∈ s),\n      x ≤ y → eVariationOn f (s ∩ Icc x y) = ENNReal.ofReal (l * (y - x)) := by\n  refine ⟨fun h x xs y ys _ => h xs ys, fun h x xs y ys => ?_⟩\n  rcases le_total x y with (xy | yx)\n  · exact h xs ys xy\n  · rw [eVariationOn.subsingleton, ENNReal.ofReal_of_nonpos]\n    · exact mul_nonpos_of_nonneg_of_nonpos l.prop (sub_nonpos_of_le yx)\n    · rintro z ⟨zs, xz, zy⟩ w ⟨ws, xw, wy⟩\n      cases le_antisymm (zy.trans yx) xz\n      cases le_antisymm (wy.trans yx) xw\n      rfl\n\n"}
{"name":"hasConstantSpeedOnWith_iff_variationOnFromTo_eq","module":"Mathlib.Analysis.ConstantSpeed","initialProofState":"E : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : Real → E\ns : Set Real\nl : NNReal\n⊢ Iff (HasConstantSpeedOnWith f s l) (And (LocallyBoundedVariationOn f s) (∀ ⦃x : Real⦄, Membership.mem s x → ∀ ⦃y : Real⦄, Membership.mem s y → Eq (variationOnFromTo f s x y) (HMul.hMul (↑l) (HSub.hSub y x))))","decl":"theorem hasConstantSpeedOnWith_iff_variationOnFromTo_eq :\n    HasConstantSpeedOnWith f s l ↔ LocallyBoundedVariationOn f s ∧\n      ∀ ⦃x⦄ (_ : x ∈ s) ⦃y⦄ (_ : y ∈ s), variationOnFromTo f s x y = l * (y - x) := by\n  constructor\n  · rintro h; refine ⟨h.hasLocallyBoundedVariationOn, fun x xs y ys => ?_⟩\n    rw [hasConstantSpeedOnWith_iff_ordered] at h\n    rcases le_total x y with (xy | yx)\n    · rw [variationOnFromTo.eq_of_le f s xy, h xs ys xy]\n      exact ENNReal.toReal_ofReal (mul_nonneg l.prop (sub_nonneg.mpr xy))\n    · rw [variationOnFromTo.eq_of_ge f s yx, h ys xs yx]\n      have := ENNReal.toReal_ofReal (mul_nonneg l.prop (sub_nonneg.mpr yx))\n      simp_all only [NNReal.val_eq_coe]; ring\n  · rw [hasConstantSpeedOnWith_iff_ordered]\n    rintro h x xs y ys xy\n    rw [← h.2 xs ys, variationOnFromTo.eq_of_le f s xy, ENNReal.ofReal_toReal (h.1 x y xs ys)]\n\n"}
{"name":"HasConstantSpeedOnWith.union","module":"Mathlib.Analysis.ConstantSpeed","initialProofState":"E : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : Real → E\ns : Set Real\nl : NNReal\nt : Set Real\nhfs : HasConstantSpeedOnWith f s l\nhft : HasConstantSpeedOnWith f t l\nx : Real\nhs : IsGreatest s x\nht : IsLeast t x\n⊢ HasConstantSpeedOnWith f (Union.union s t) l","decl":"theorem HasConstantSpeedOnWith.union {t : Set ℝ} (hfs : HasConstantSpeedOnWith f s l)\n    (hft : HasConstantSpeedOnWith f t l) {x : ℝ} (hs : IsGreatest s x) (ht : IsLeast t x) :\n    HasConstantSpeedOnWith f (s ∪ t) l := by\n  rw [hasConstantSpeedOnWith_iff_ordered] at hfs hft ⊢\n  rintro z (zs | zt) y (ys | yt) zy\n  · have : (s ∪ t) ∩ Icc z y = s ∩ Icc z y := by\n      ext w; constructor\n      · rintro ⟨ws | wt, zw, wy⟩\n        · exact ⟨ws, zw, wy⟩\n        · exact ⟨(le_antisymm (wy.trans (hs.2 ys)) (ht.2 wt)).symm ▸ hs.1, zw, wy⟩\n      · rintro ⟨ws, zwy⟩; exact ⟨Or.inl ws, zwy⟩\n    rw [this, hfs zs ys zy]\n  · have : (s ∪ t) ∩ Icc z y = s ∩ Icc z x ∪ t ∩ Icc x y := by\n      ext w; constructor\n      · rintro ⟨ws | wt, zw, wy⟩\n        exacts [Or.inl ⟨ws, zw, hs.2 ws⟩, Or.inr ⟨wt, ht.2 wt, wy⟩]\n      · rintro (⟨ws, zw, wx⟩ | ⟨wt, xw, wy⟩)\n        exacts [⟨Or.inl ws, zw, wx.trans (ht.2 yt)⟩, ⟨Or.inr wt, (hs.2 zs).trans xw, wy⟩]\n    rw [this, @eVariationOn.union _ _ _ _ f _ _ x, hfs zs hs.1 (hs.2 zs), hft ht.1 yt (ht.2 yt)]\n    · have q := ENNReal.ofReal_add (mul_nonneg l.prop (sub_nonneg.mpr (hs.2 zs)))\n        (mul_nonneg l.prop (sub_nonneg.mpr (ht.2 yt)))\n      simp only [NNReal.val_eq_coe] at q\n      rw [← q]\n      ring_nf\n    exacts [⟨⟨hs.1, hs.2 zs, le_rfl⟩, fun w ⟨_, _, wx⟩ => wx⟩,\n      ⟨⟨ht.1, le_rfl, ht.2 yt⟩, fun w ⟨_, xw, _⟩ => xw⟩]\n  · cases le_antisymm zy ((hs.2 ys).trans (ht.2 zt))\n    simp only [Icc_self, sub_self, mul_zero, ENNReal.ofReal_zero]\n    exact eVariationOn.subsingleton _ fun _ ⟨_, uz⟩ _ ⟨_, vz⟩ => uz.trans vz.symm\n  · have : (s ∪ t) ∩ Icc z y = t ∩ Icc z y := by\n      ext w; constructor\n      · rintro ⟨ws | wt, zw, wy⟩\n        · exact ⟨le_antisymm ((ht.2 zt).trans zw) (hs.2 ws) ▸ ht.1, zw, wy⟩\n        · exact ⟨wt, zw, wy⟩\n      · rintro ⟨wt, zwy⟩; exact ⟨Or.inr wt, zwy⟩\n    rw [this, hft zt yt zy]\n\n"}
{"name":"HasConstantSpeedOnWith.Icc_Icc","module":"Mathlib.Analysis.ConstantSpeed","initialProofState":"E : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : Real → E\nl : NNReal\nx y z : Real\nhfs : HasConstantSpeedOnWith f (Set.Icc x y) l\nhft : HasConstantSpeedOnWith f (Set.Icc y z) l\n⊢ HasConstantSpeedOnWith f (Set.Icc x z) l","decl":"theorem HasConstantSpeedOnWith.Icc_Icc {x y z : ℝ} (hfs : HasConstantSpeedOnWith f (Icc x y) l)\n    (hft : HasConstantSpeedOnWith f (Icc y z) l) : HasConstantSpeedOnWith f (Icc x z) l := by\n  rcases le_total x y with (xy | yx)\n  · rcases le_total y z with (yz | zy)\n    · rw [← Set.Icc_union_Icc_eq_Icc xy yz]\n      exact hfs.union hft (isGreatest_Icc xy) (isLeast_Icc yz)\n    · rintro u ⟨xu, uz⟩ v ⟨xv, vz⟩\n      rw [Icc_inter_Icc, sup_of_le_right xu, inf_of_le_right vz, ←\n        hfs ⟨xu, uz.trans zy⟩ ⟨xv, vz.trans zy⟩, Icc_inter_Icc, sup_of_le_right xu,\n        inf_of_le_right (vz.trans zy)]\n  · rintro u ⟨xu, uz⟩ v ⟨xv, vz⟩\n    rw [Icc_inter_Icc, sup_of_le_right xu, inf_of_le_right vz, ←\n      hft ⟨yx.trans xu, uz⟩ ⟨yx.trans xv, vz⟩, Icc_inter_Icc, sup_of_le_right (yx.trans xu),\n      inf_of_le_right vz]\n\n"}
{"name":"hasConstantSpeedOnWith_zero_iff","module":"Mathlib.Analysis.ConstantSpeed","initialProofState":"E : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : Real → E\ns : Set Real\n⊢ Iff (HasConstantSpeedOnWith f s 0) (∀ (x : Real), Membership.mem s x → ∀ (y : Real), Membership.mem s y → Eq (EDist.edist (f x) (f y)) 0)","decl":"theorem hasConstantSpeedOnWith_zero_iff :\n    HasConstantSpeedOnWith f s 0 ↔ ∀ᵉ (x ∈ s) (y ∈ s), edist (f x) (f y) = 0 := by\n  dsimp [HasConstantSpeedOnWith]\n  simp only [zero_mul, ENNReal.ofReal_zero, ← eVariationOn.eq_zero_iff]\n  constructor\n  · by_contra!\n    obtain ⟨h, hfs⟩ := this\n    simp_rw [ne_eq, eVariationOn.eq_zero_iff] at hfs h\n    push_neg at hfs\n    obtain ⟨x, xs, y, ys, hxy⟩ := hfs\n    rcases le_total x y with (xy | yx)\n    · exact hxy (h xs ys x ⟨xs, le_rfl, xy⟩ y ⟨ys, xy, le_rfl⟩)\n    · rw [edist_comm] at hxy\n      exact hxy (h ys xs y ⟨ys, le_rfl, yx⟩ x ⟨xs, yx, le_rfl⟩)\n  · rintro h x _ y _\n    refine le_antisymm ?_ zero_le'\n    rw [← h]\n    exact eVariationOn.mono f inter_subset_left\n\n"}
{"name":"HasConstantSpeedOnWith.ratio","module":"Mathlib.Analysis.ConstantSpeed","initialProofState":"E : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : Real → E\ns : Set Real\nl l' : NNReal\nhl' : Ne l' 0\nφ : Real → Real\nφm : MonotoneOn φ s\nhfφ : HasConstantSpeedOnWith (Function.comp f φ) s l\nhf : HasConstantSpeedOnWith f (Set.image φ s) l'\nx : Real\nxs : Membership.mem s x\n⊢ Set.EqOn φ (fun y => HAdd.hAdd (HMul.hMul (HDiv.hDiv ↑l ↑l') (HSub.hSub y x)) (φ x)) s","decl":"theorem HasConstantSpeedOnWith.ratio {l' : ℝ≥0} (hl' : l' ≠ 0) {φ : ℝ → ℝ} (φm : MonotoneOn φ s)\n    (hfφ : HasConstantSpeedOnWith (f ∘ φ) s l) (hf : HasConstantSpeedOnWith f (φ '' s) l') ⦃x : ℝ⦄\n    (xs : x ∈ s) : EqOn φ (fun y => l / l' * (y - x) + φ x) s := by\n  rintro y ys\n  rw [← sub_eq_iff_eq_add, mul_comm, ← mul_div_assoc, eq_div_iff (NNReal.coe_ne_zero.mpr hl')]\n  rw [hasConstantSpeedOnWith_iff_variationOnFromTo_eq] at hf\n  rw [hasConstantSpeedOnWith_iff_variationOnFromTo_eq] at hfφ\n  symm\n  calc\n    (y - x) * l = l * (y - x) := by rw [mul_comm]\n    _ = variationOnFromTo (f ∘ φ) s x y := (hfφ.2 xs ys).symm\n    _ = variationOnFromTo f (φ '' s) (φ x) (φ y) :=\n      (variationOnFromTo.comp_eq_of_monotoneOn f φ φm xs ys)\n    _ = l' * (φ y - φ x) := (hf.2 ⟨x, xs, rfl⟩ ⟨y, ys, rfl⟩)\n    _ = (φ y - φ x) * l' := by rw [mul_comm]\n\n"}
{"name":"HasUnitSpeedOn.union","module":"Mathlib.Analysis.ConstantSpeed","initialProofState":"E : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : Real → E\ns t : Set Real\nx : Real\nhfs : HasUnitSpeedOn f s\nhft : HasUnitSpeedOn f t\nhs : IsGreatest s x\nht : IsLeast t x\n⊢ HasUnitSpeedOn f (Union.union s t)","decl":"theorem HasUnitSpeedOn.union {t : Set ℝ} {x : ℝ} (hfs : HasUnitSpeedOn f s)\n    (hft : HasUnitSpeedOn f t) (hs : IsGreatest s x) (ht : IsLeast t x) :\n    HasUnitSpeedOn f (s ∪ t) :=\n  HasConstantSpeedOnWith.union hfs hft hs ht\n\n"}
{"name":"HasUnitSpeedOn.Icc_Icc","module":"Mathlib.Analysis.ConstantSpeed","initialProofState":"E : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : Real → E\nx y z : Real\nhfs : HasUnitSpeedOn f (Set.Icc x y)\nhft : HasUnitSpeedOn f (Set.Icc y z)\n⊢ HasUnitSpeedOn f (Set.Icc x z)","decl":"theorem HasUnitSpeedOn.Icc_Icc {x y z : ℝ} (hfs : HasUnitSpeedOn f (Icc x y))\n    (hft : HasUnitSpeedOn f (Icc y z)) : HasUnitSpeedOn f (Icc x z) :=\n  HasConstantSpeedOnWith.Icc_Icc hfs hft\n\n"}
{"name":"unique_unit_speed","module":"Mathlib.Analysis.ConstantSpeed","initialProofState":"E : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : Real → E\ns : Set Real\nφ : Real → Real\nφm : MonotoneOn φ s\nhfφ : HasUnitSpeedOn (Function.comp f φ) s\nhf : HasUnitSpeedOn f (Set.image φ s)\nx : Real\nxs : Membership.mem s x\n⊢ Set.EqOn φ (fun y => HAdd.hAdd (HSub.hSub y x) (φ x)) s","decl":"/-- If both `f` and `f ∘ φ` have unit speed (on `t` and `s` respectively) and `φ`\nmonotonically maps `s` onto `t`, then `φ` is just a translation (on `s`).\n-/\ntheorem unique_unit_speed {φ : ℝ → ℝ} (φm : MonotoneOn φ s) (hfφ : HasUnitSpeedOn (f ∘ φ) s)\n    (hf : HasUnitSpeedOn f (φ '' s)) ⦃x : ℝ⦄ (xs : x ∈ s) : EqOn φ (fun y => y - x + φ x) s := by\n  dsimp only [HasUnitSpeedOn] at hf hfφ\n  convert HasConstantSpeedOnWith.ratio one_ne_zero φm hfφ hf xs using 3\n  norm_num\n\n"}
{"name":"unique_unit_speed_on_Icc_zero","module":"Mathlib.Analysis.ConstantSpeed","initialProofState":"E : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : Real → E\ns t : Real\nhs : LE.le 0 s\nht : LE.le 0 t\nφ : Real → Real\nφm : MonotoneOn φ (Set.Icc 0 s)\nφst : Eq (Set.image φ (Set.Icc 0 s)) (Set.Icc 0 t)\nhfφ : HasUnitSpeedOn (Function.comp f φ) (Set.Icc 0 s)\nhf : HasUnitSpeedOn f (Set.Icc 0 t)\n⊢ Set.EqOn φ id (Set.Icc 0 s)","decl":"/-- If both `f` and `f ∘ φ` have unit speed (on `Icc 0 t` and `Icc 0 s` respectively)\nand `φ` monotonically maps `Icc 0 s` onto `Icc 0 t`, then `φ` is the identity on `Icc 0 s`\n-/\ntheorem unique_unit_speed_on_Icc_zero {s t : ℝ} (hs : 0 ≤ s) (ht : 0 ≤ t) {φ : ℝ → ℝ}\n    (φm : MonotoneOn φ <| Icc 0 s) (φst : φ '' Icc 0 s = Icc 0 t)\n    (hfφ : HasUnitSpeedOn (f ∘ φ) (Icc 0 s)) (hf : HasUnitSpeedOn f (Icc 0 t)) :\n    EqOn φ id (Icc 0 s) := by\n  rw [← φst] at hf\n  convert unique_unit_speed φm hfφ hf ⟨le_rfl, hs⟩ using 1\n  have : φ 0 = 0 := by\n    have hm : 0 ∈ φ '' Icc 0 s := by simp only [φst, ht, mem_Icc, le_refl, and_self]\n    obtain ⟨x, xs, hx⟩ := hm\n    apply le_antisymm ((φm ⟨le_rfl, hs⟩ xs xs.1).trans_eq hx) _\n    have := φst ▸ mapsTo_image φ (Icc 0 s)\n    exact (mem_Icc.mp (@this 0 (by rw [mem_Icc]; exact ⟨le_rfl, hs⟩))).1\n  simp only [tsub_zero, this, add_zero]\n  rfl\n\n"}
{"name":"edist_naturalParameterization_eq_zero","module":"Mathlib.Analysis.ConstantSpeed","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\nhf : LocallyBoundedVariationOn f s\na : α\nas : Membership.mem s a\nb : α\nbs : Membership.mem s b\n⊢ Eq (EDist.edist (naturalParameterization f s a (variationOnFromTo f s a b)) (f b)) 0","decl":"theorem edist_naturalParameterization_eq_zero {f : α → E} {s : Set α}\n    (hf : LocallyBoundedVariationOn f s) {a : α} (as : a ∈ s) {b : α} (bs : b ∈ s) :\n    edist (naturalParameterization f s a (variationOnFromTo f s a b)) (f b) = 0 := by\n  dsimp only [naturalParameterization]\n  haveI : Nonempty α := ⟨a⟩\n  obtain ⟨cs, hc⟩ := Function.invFunOn_pos (b := variationOnFromTo f s a b) ⟨b, bs, rfl⟩\n  rw [variationOnFromTo.eq_left_iff hf as cs bs] at hc\n  apply variationOnFromTo.edist_zero_of_eq_zero hf cs bs hc\n\n"}
{"name":"has_unit_speed_naturalParameterization","module":"Mathlib.Analysis.ConstantSpeed","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\nhf : LocallyBoundedVariationOn f s\na : α\nas : Membership.mem s a\n⊢ HasUnitSpeedOn (naturalParameterization f s a) (Set.image (variationOnFromTo f s a) s)","decl":"theorem has_unit_speed_naturalParameterization (f : α → E) {s : Set α}\n    (hf : LocallyBoundedVariationOn f s) {a : α} (as : a ∈ s) :\n    HasUnitSpeedOn (naturalParameterization f s a) (variationOnFromTo f s a '' s) := by\n  dsimp only [HasUnitSpeedOn]\n  rw [hasConstantSpeedOnWith_iff_ordered]\n  rintro _ ⟨b, bs, rfl⟩ _ ⟨c, cs, rfl⟩ h\n  rcases le_total c b with (cb | bc)\n  · rw [NNReal.coe_one, one_mul, le_antisymm h (variationOnFromTo.monotoneOn hf as cs bs cb),\n      sub_self, ENNReal.ofReal_zero, Icc_self, eVariationOn.subsingleton]\n    exact fun x hx y hy => hx.2.trans hy.2.symm\n  · rw [NNReal.coe_one, one_mul, sub_eq_add_neg, variationOnFromTo.eq_neg_swap, neg_neg, add_comm,\n      variationOnFromTo.add hf bs as cs, ← variationOnFromTo.eq_neg_swap f]\n    rw [←\n      eVariationOn.comp_inter_Icc_eq_of_monotoneOn (naturalParameterization f s a) _\n        (variationOnFromTo.monotoneOn hf as) bs cs]\n    rw [@eVariationOn.eq_of_edist_zero_on _ _ _ _ _ f]\n    · rw [variationOnFromTo.eq_of_le _ _ bc, ENNReal.ofReal_toReal (hf b c bs cs)]\n    · rintro x ⟨xs, _, _⟩\n      exact edist_naturalParameterization_eq_zero hf as xs\n"}
