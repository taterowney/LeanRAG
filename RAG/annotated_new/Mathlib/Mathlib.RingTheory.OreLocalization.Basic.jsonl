{"name":"OreLocalization.zero_oreDiv'","module":"Mathlib.RingTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : MonoidWithZero R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (OreLocalization.oreDiv 0 s) 0","decl":"@[simp]\ntheorem zero_oreDiv' (s : S) : (0 : R) /ₒ s = 0 := by\n  rw [OreLocalization.zero_def, oreDiv_eq_iff]\n  exact ⟨s, 1, by simp [Submonoid.smul_def]⟩\n\n"}
{"name":"OreLocalization.oreDiv_add_oreDiv","module":"Mathlib.RingTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝³ : Monoid R\nS : Submonoid R\ninst✝² : OreLocalization.OreSet S\nX : Type u_2\ninst✝¹ : AddMonoid X\ninst✝ : DistribMulAction R X\nr r' : X\ns s' : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd (OreLocalization.oreDiv r s) (OreLocalization.oreDiv r' s')) (OreLocalization.oreDiv (HAdd.hAdd (HSMul.hSMul (OreLocalization.oreDenom (↑s) s') r) (HSMul.hSMul (OreLocalization.oreNum (↑s) s') r')) (HMul.hMul (OreLocalization.oreDenom (↑s) s') s))","decl":"theorem oreDiv_add_oreDiv {r r' : X} {s s' : S} :\n    r /ₒ s + r' /ₒ s' =\n      (oreDenom (s : R) s' • r + oreNum (s : R) s' • r') /ₒ (oreDenom (s : R) s' * s) := by\n  with_unfolding_all rfl\n\n"}
{"name":"OreLocalization.oreDiv_add_char'","module":"Mathlib.RingTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝³ : Monoid R\nS : Submonoid R\ninst✝² : OreLocalization.OreSet S\nX : Type u_2\ninst✝¹ : AddMonoid X\ninst✝ : DistribMulAction R X\nr r' : X\ns s' : Subtype fun x => Membership.mem S x\nrb sb : R\nh : Eq (HMul.hMul sb ↑s) (HMul.hMul rb ↑s')\nh' : Membership.mem S (HMul.hMul sb ↑s)\n⊢ Eq (HAdd.hAdd (OreLocalization.oreDiv r s) (OreLocalization.oreDiv r' s')) (OreLocalization.oreDiv (HAdd.hAdd (HSMul.hSMul sb r) (HSMul.hSMul rb r')) ⟨HMul.hMul sb ↑s, h'⟩)","decl":"theorem oreDiv_add_char' {r r' : X} (s s' : S) (rb : R) (sb : R)\n    (h : sb * s = rb * s') (h' : sb * s ∈ S) :\n    r /ₒ s + r' /ₒ s' = (sb • r + rb • r') /ₒ ⟨sb * s, h'⟩ := by\n  with_unfolding_all exact add''_char r s r' s' rb sb h h'\n\n"}
{"name":"OreLocalization.oreDiv_add_char","module":"Mathlib.RingTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝³ : Monoid R\nS : Submonoid R\ninst✝² : OreLocalization.OreSet S\nX : Type u_2\ninst✝¹ : AddMonoid X\ninst✝ : DistribMulAction R X\nr r' : X\ns s' : Subtype fun x => Membership.mem S x\nrb : R\nsb : Subtype fun x => Membership.mem S x\nh : Eq (HMul.hMul ↑sb ↑s) (HMul.hMul rb ↑s')\n⊢ Eq (HAdd.hAdd (OreLocalization.oreDiv r s) (OreLocalization.oreDiv r' s')) (OreLocalization.oreDiv (HAdd.hAdd (HSMul.hSMul sb r) (HSMul.hSMul rb r')) (HMul.hMul sb s))","decl":"/-- A characterization of the addition on the Ore localizaion, allowing for arbitrary Ore\nnumerator and Ore denominator. -/\ntheorem oreDiv_add_char {r r' : X} (s s' : S) (rb : R) (sb : S) (h : sb * s = rb * s') :\n    r /ₒ s + r' /ₒ s' = (sb • r + rb • r') /ₒ (sb * s) :=\n  oreDiv_add_char' s s' rb sb h (sb * s).2\n\n"}
{"name":"OreLocalization.add_oreDiv","module":"Mathlib.RingTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝³ : Monoid R\nS : Submonoid R\ninst✝² : OreLocalization.OreSet S\nX : Type u_2\ninst✝¹ : AddMonoid X\ninst✝ : DistribMulAction R X\nr r' : X\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd (OreLocalization.oreDiv r s) (OreLocalization.oreDiv r' s)) (OreLocalization.oreDiv (HAdd.hAdd r r') s)","decl":"@[simp]\ntheorem add_oreDiv {r r' : X} {s : S} : r /ₒ s + r' /ₒ s = (r + r') /ₒ s := by\n  simp [oreDiv_add_char s s 1 1 (by simp)]\n\n"}
{"name":"OreLocalization.add_assoc","module":"Mathlib.RingTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝³ : Monoid R\nS : Submonoid R\ninst✝² : OreLocalization.OreSet S\nX : Type u_2\ninst✝¹ : AddMonoid X\ninst✝ : DistribMulAction R X\nx y z : OreLocalization S X\n⊢ Eq (HAdd.hAdd (HAdd.hAdd x y) z) (HAdd.hAdd x (HAdd.hAdd y z))","decl":"protected theorem add_assoc (x y z : X[S⁻¹]) : x + y + z = x + (y + z) := by\n  induction' x with r₁ s₁\n  induction' y with r₂ s₂\n  induction' z with r₃ s₃\n  rcases oreDivAddChar' r₁ r₂ s₁ s₂ with ⟨ra, sa, ha, ha'⟩; rw [ha']; clear ha'\n  rcases oreDivAddChar' (sa • r₁ + ra • r₂) r₃ (sa * s₁) s₃ with ⟨rc, sc, hc, q⟩; rw [q]; clear q\n  simp only [smul_add, mul_assoc, add_assoc]\n  simp_rw [← add_oreDiv, ← OreLocalization.expand']\n  congr 2\n  · rw [OreLocalization.expand r₂ s₂ ra (ha.symm ▸ (sa * s₁).2)]; congr; ext; exact ha\n  · rw [OreLocalization.expand r₃ s₃ rc (hc.symm ▸ (sc * (sa * s₁)).2)]; congr; ext; exact hc\n\n"}
{"name":"OreLocalization.zero_oreDiv","module":"Mathlib.RingTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝³ : Monoid R\nS : Submonoid R\ninst✝² : OreLocalization.OreSet S\nX : Type u_2\ninst✝¹ : AddMonoid X\ninst✝ : DistribMulAction R X\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (OreLocalization.oreDiv 0 s) 0","decl":"@[simp]\ntheorem zero_oreDiv (s : S) : (0 : X) /ₒ s = 0 := by\n  rw [OreLocalization.zero_def, oreDiv_eq_iff]\n  exact ⟨s, 1, by simp⟩\n\n"}
{"name":"OreLocalization.zero_add","module":"Mathlib.RingTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝³ : Monoid R\nS : Submonoid R\ninst✝² : OreLocalization.OreSet S\nX : Type u_2\ninst✝¹ : AddMonoid X\ninst✝ : DistribMulAction R X\nx : OreLocalization S X\n⊢ Eq (HAdd.hAdd 0 x) x","decl":"protected theorem zero_add (x : X[S⁻¹]) : 0 + x = x := by\n  induction x\n  rw [← zero_oreDiv, add_oreDiv]; simp\n\n"}
{"name":"OreLocalization.add_zero","module":"Mathlib.RingTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝³ : Monoid R\nS : Submonoid R\ninst✝² : OreLocalization.OreSet S\nX : Type u_2\ninst✝¹ : AddMonoid X\ninst✝ : DistribMulAction R X\nx : OreLocalization S X\n⊢ Eq (HAdd.hAdd x 0) x","decl":"protected theorem add_zero (x : X[S⁻¹]) : x + 0 = x := by\n  induction x\n  rw [← zero_oreDiv, add_oreDiv]; simp\n\n"}
{"name":"OreLocalization.smul_zero","module":"Mathlib.RingTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝³ : Monoid R\nS : Submonoid R\ninst✝² : OreLocalization.OreSet S\nX : Type u_2\ninst✝¹ : AddMonoid X\ninst✝ : DistribMulAction R X\nx : OreLocalization S R\n⊢ Eq (HSMul.hSMul x 0) 0","decl":"protected theorem smul_zero (x : R[S⁻¹]) : x • (0 : X[S⁻¹]) = 0 := by\n  induction' x with r s\n  rw [OreLocalization.zero_def, smul_div_one, smul_zero, zero_oreDiv, zero_oreDiv]\n\n"}
{"name":"OreLocalization.smul_add","module":"Mathlib.RingTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝³ : Monoid R\nS : Submonoid R\ninst✝² : OreLocalization.OreSet S\nX : Type u_2\ninst✝¹ : AddMonoid X\ninst✝ : DistribMulAction R X\nz : OreLocalization S R\nx y : OreLocalization S X\n⊢ Eq (HSMul.hSMul z (HAdd.hAdd x y)) (HAdd.hAdd (HSMul.hSMul z x) (HSMul.hSMul z y))","decl":"protected theorem smul_add (z : R[S⁻¹]) (x y : X[S⁻¹]) :\n    z • (x + y) = z • x + z • y := by\n  induction' x with r₁ s₁\n  induction' y with r₂ s₂\n  induction' z with r₃ s₃\n  rcases oreDivAddChar' r₁ r₂ s₁ s₂ with ⟨ra, sa, ha, ha'⟩; rw [ha']; clear ha'; norm_cast at ha\n  rw [OreLocalization.expand' r₁ s₁ sa]\n  rw [OreLocalization.expand r₂ s₂ ra (by rw [← ha]; apply SetLike.coe_mem)]\n  rw [← Subtype.coe_eq_of_eq_mk ha]\n  repeat rw [oreDiv_smul_oreDiv]\n  simp only [smul_add, add_oreDiv]\n\n"}
{"name":"OreLocalization.add_comm","module":"Mathlib.RingTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝³ : Monoid R\nS : Submonoid R\ninst✝² : OreLocalization.OreSet S\nX : Type u_2\ninst✝¹ : AddCommMonoid X\ninst✝ : DistribMulAction R X\nx y : OreLocalization S X\n⊢ Eq (HAdd.hAdd x y) (HAdd.hAdd y x)","decl":"protected theorem add_comm (x y : X[S⁻¹]) : x + y = y + x := by\n  induction' x with r s\n  induction' y with r' s'\n  rcases oreDivAddChar' r r' s s' with ⟨ra, sa, ha, ha'⟩\n  rw [ha', oreDiv_add_char' s' s _ _ ha.symm (ha ▸ (sa * s).2), add_comm]\n  congr; ext; exact ha\n\n"}
{"name":"OreLocalization.neg_def","module":"Mathlib.RingTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝³ : Monoid R\nS : Submonoid R\ninst✝² : OreLocalization.OreSet S\nX : Type u_2\ninst✝¹ : AddGroup X\ninst✝ : DistribMulAction R X\nr : X\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (Neg.neg (OreLocalization.oreDiv r s)) (OreLocalization.oreDiv (Neg.neg r) s)","decl":"@[simp]\nprotected theorem neg_def (r : X) (s : S) : -(r /ₒ s) = -r /ₒ s := by\n  with_unfolding_all rfl\n\n"}
{"name":"OreLocalization.neg_add_cancel","module":"Mathlib.RingTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝³ : Monoid R\nS : Submonoid R\ninst✝² : OreLocalization.OreSet S\nX : Type u_2\ninst✝¹ : AddGroup X\ninst✝ : DistribMulAction R X\nx : OreLocalization S X\n⊢ Eq (HAdd.hAdd (Neg.neg x) x) 0","decl":"protected theorem neg_add_cancel (x : X[S⁻¹]) : -x + x = 0 := by\n  induction' x with r s; simp\n\n"}
