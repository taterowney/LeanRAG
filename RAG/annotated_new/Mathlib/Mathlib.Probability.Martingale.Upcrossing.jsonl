{"name":"MeasureTheory.upperCrossingTime_zero","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nŒπ : Type u_2\ninst‚úù¬≤ : Preorder Œπ\ninst‚úù¬π : OrderBot Œπ\ninst‚úù : InfSet Œπ\na b : Real\nf : Œπ ‚Üí Œ© ‚Üí Real\nN : Œπ\n‚ä¢ Eq (MeasureTheory.upperCrossingTime a b f N 0) Bot.bot","decl":"@[simp]\ntheorem upperCrossingTime_zero : upperCrossingTime a b f N 0 = ‚ä• :=\n  rfl\n\n"}
{"name":"MeasureTheory.lowerCrossingTime_zero","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nŒπ : Type u_2\ninst‚úù¬≤ : Preorder Œπ\ninst‚úù¬π : OrderBot Œπ\ninst‚úù : InfSet Œπ\na b : Real\nf : Œπ ‚Üí Œ© ‚Üí Real\nN : Œπ\n‚ä¢ Eq (MeasureTheory.lowerCrossingTime a b f N 0) (MeasureTheory.hitting f (Set.Iic a) Bot.bot N)","decl":"@[simp]\ntheorem lowerCrossingTime_zero : lowerCrossingTime a b f N 0 = hitting f (Set.Iic a) ‚ä• N :=\n  rfl\n\n"}
{"name":"MeasureTheory.upperCrossingTime_succ","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nŒπ : Type u_2\ninst‚úù¬≤ : Preorder Œπ\ninst‚úù¬π : OrderBot Œπ\ninst‚úù : InfSet Œπ\na b : Real\nf : Œπ ‚Üí Œ© ‚Üí Real\nN : Œπ\nn : Nat\nœâ : Œ©\n‚ä¢ Eq (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) œâ) (MeasureTheory.hitting f (Set.Ici b) (MeasureTheory.lowerCrossingTimeAux a f (MeasureTheory.upperCrossingTime a b f N n œâ) N œâ) N œâ)","decl":"theorem upperCrossingTime_succ : upperCrossingTime a b f N (n + 1) œâ =\n    hitting f (Set.Ici b) (lowerCrossingTimeAux a f (upperCrossingTime a b f N n œâ) N œâ) N œâ := by\n  rw [upperCrossingTime]\n\n"}
{"name":"MeasureTheory.upperCrossingTime_succ_eq","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nŒπ : Type u_2\ninst‚úù¬≤ : Preorder Œπ\ninst‚úù¬π : OrderBot Œπ\ninst‚úù : InfSet Œπ\na b : Real\nf : Œπ ‚Üí Œ© ‚Üí Real\nN : Œπ\nn : Nat\nœâ : Œ©\n‚ä¢ Eq (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) œâ) (MeasureTheory.hitting f (Set.Ici b) (MeasureTheory.lowerCrossingTime a b f N n œâ) N œâ)","decl":"theorem upperCrossingTime_succ_eq (œâ : Œ©) : upperCrossingTime a b f N (n + 1) œâ =\n    hitting f (Set.Ici b) (lowerCrossingTime a b f N n œâ) N œâ := by\n  simp only [upperCrossingTime_succ]\n  rfl\n\n"}
{"name":"MeasureTheory.upperCrossingTime_le","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nŒπ : Type u_2\ninst‚úù : ConditionallyCompleteLinearOrderBot Œπ\na b : Real\nf : Œπ ‚Üí Œ© ‚Üí Real\nN : Œπ\nn : Nat\nœâ : Œ©\n‚ä¢ LE.le (MeasureTheory.upperCrossingTime a b f N n œâ) N","decl":"theorem upperCrossingTime_le : upperCrossingTime a b f N n œâ ‚â§ N := by\n  cases n\n  ¬∑ simp only [upperCrossingTime_zero, Pi.bot_apply, bot_le]\n  ¬∑ simp only [upperCrossingTime_succ, hitting_le]\n\n"}
{"name":"MeasureTheory.upperCrossingTime_zero'","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nŒπ : Type u_2\ninst‚úù : ConditionallyCompleteLinearOrderBot Œπ\na b : Real\nf : Œπ ‚Üí Œ© ‚Üí Real\nn : Nat\nœâ : Œ©\n‚ä¢ Eq (MeasureTheory.upperCrossingTime a b f Bot.bot n œâ) Bot.bot","decl":"@[simp]\ntheorem upperCrossingTime_zero' : upperCrossingTime a b f ‚ä• n œâ = ‚ä• :=\n  eq_bot_iff.2 upperCrossingTime_le\n\n"}
{"name":"MeasureTheory.lowerCrossingTime_le","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nŒπ : Type u_2\ninst‚úù : ConditionallyCompleteLinearOrderBot Œπ\na b : Real\nf : Œπ ‚Üí Œ© ‚Üí Real\nN : Œπ\nn : Nat\nœâ : Œ©\n‚ä¢ LE.le (MeasureTheory.lowerCrossingTime a b f N n œâ) N","decl":"theorem lowerCrossingTime_le : lowerCrossingTime a b f N n œâ ‚â§ N := by\n  simp only [lowerCrossingTime, hitting_le œâ]\n\n"}
{"name":"MeasureTheory.upperCrossingTime_le_lowerCrossingTime","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nŒπ : Type u_2\ninst‚úù : ConditionallyCompleteLinearOrderBot Œπ\na b : Real\nf : Œπ ‚Üí Œ© ‚Üí Real\nN : Œπ\nn : Nat\nœâ : Œ©\n‚ä¢ LE.le (MeasureTheory.upperCrossingTime a b f N n œâ) (MeasureTheory.lowerCrossingTime a b f N n œâ)","decl":"theorem upperCrossingTime_le_lowerCrossingTime :\n    upperCrossingTime a b f N n œâ ‚â§ lowerCrossingTime a b f N n œâ := by\n  simp only [lowerCrossingTime, le_hitting upperCrossingTime_le œâ]\n\n"}
{"name":"MeasureTheory.lowerCrossingTime_le_upperCrossingTime_succ","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nŒπ : Type u_2\ninst‚úù : ConditionallyCompleteLinearOrderBot Œπ\na b : Real\nf : Œπ ‚Üí Œ© ‚Üí Real\nN : Œπ\nn : Nat\nœâ : Œ©\n‚ä¢ LE.le (MeasureTheory.lowerCrossingTime a b f N n œâ) (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) œâ)","decl":"theorem lowerCrossingTime_le_upperCrossingTime_succ :\n    lowerCrossingTime a b f N n œâ ‚â§ upperCrossingTime a b f N (n + 1) œâ := by\n  rw [upperCrossingTime_succ]\n  exact le_hitting lowerCrossingTime_le œâ\n\n"}
{"name":"MeasureTheory.lowerCrossingTime_mono","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nŒπ : Type u_2\ninst‚úù : ConditionallyCompleteLinearOrderBot Œπ\na b : Real\nf : Œπ ‚Üí Œ© ‚Üí Real\nN : Œπ\nn m : Nat\nœâ : Œ©\nhnm : LE.le n m\n‚ä¢ LE.le (MeasureTheory.lowerCrossingTime a b f N n œâ) (MeasureTheory.lowerCrossingTime a b f N m œâ)","decl":"theorem lowerCrossingTime_mono (hnm : n ‚â§ m) :\n    lowerCrossingTime a b f N n œâ ‚â§ lowerCrossingTime a b f N m œâ := by\n  suffices Monotone fun n => lowerCrossingTime a b f N n œâ by exact this hnm\n  exact monotone_nat_of_le_succ fun n =>\n    le_trans lowerCrossingTime_le_upperCrossingTime_succ upperCrossingTime_le_lowerCrossingTime\n\n"}
{"name":"MeasureTheory.upperCrossingTime_mono","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nŒπ : Type u_2\ninst‚úù : ConditionallyCompleteLinearOrderBot Œπ\na b : Real\nf : Œπ ‚Üí Œ© ‚Üí Real\nN : Œπ\nn m : Nat\nœâ : Œ©\nhnm : LE.le n m\n‚ä¢ LE.le (MeasureTheory.upperCrossingTime a b f N n œâ) (MeasureTheory.upperCrossingTime a b f N m œâ)","decl":"theorem upperCrossingTime_mono (hnm : n ‚â§ m) :\n    upperCrossingTime a b f N n œâ ‚â§ upperCrossingTime a b f N m œâ := by\n  suffices Monotone fun n => upperCrossingTime a b f N n œâ by exact this hnm\n  exact monotone_nat_of_le_succ fun n =>\n    le_trans upperCrossingTime_le_lowerCrossingTime lowerCrossingTime_le_upperCrossingTime_succ\n\n"}
{"name":"MeasureTheory.stoppedValue_lowerCrossingTime","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n : Nat\nœâ : Œ©\nh : Ne (MeasureTheory.lowerCrossingTime a b f N n œâ) N\n‚ä¢ LE.le (MeasureTheory.stoppedValue f (MeasureTheory.lowerCrossingTime a b f N n) œâ) a","decl":"theorem stoppedValue_lowerCrossingTime (h : lowerCrossingTime a b f N n œâ ‚â† N) :\n    stoppedValue f (lowerCrossingTime a b f N n) œâ ‚â§ a := by\n  obtain ‚ü®j, hj‚ÇÅ, hj‚ÇÇ‚ü© := (hitting_le_iff_of_lt _ (lt_of_le_of_ne lowerCrossingTime_le h)).1 le_rfl\n  exact stoppedValue_hitting_mem ‚ü®j, ‚ü®hj‚ÇÅ.1, le_trans hj‚ÇÅ.2 lowerCrossingTime_le‚ü©, hj‚ÇÇ‚ü©\n\n"}
{"name":"MeasureTheory.stoppedValue_upperCrossingTime","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n : Nat\nœâ : Œ©\nh : Ne (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) œâ) N\n‚ä¢ LE.le b (MeasureTheory.stoppedValue f (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1)) œâ)","decl":"theorem stoppedValue_upperCrossingTime (h : upperCrossingTime a b f N (n + 1) œâ ‚â† N) :\n    b ‚â§ stoppedValue f (upperCrossingTime a b f N (n + 1)) œâ := by\n  obtain ‚ü®j, hj‚ÇÅ, hj‚ÇÇ‚ü© := (hitting_le_iff_of_lt _ (lt_of_le_of_ne upperCrossingTime_le h)).1 le_rfl\n  exact stoppedValue_hitting_mem ‚ü®j, ‚ü®hj‚ÇÅ.1, le_trans hj‚ÇÅ.2 (hitting_le _)‚ü©, hj‚ÇÇ‚ü©\n\n"}
{"name":"MeasureTheory.upperCrossingTime_lt_lowerCrossingTime","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n : Nat\nœâ : Œ©\nhab : LT.lt a b\nhn : Ne (MeasureTheory.lowerCrossingTime a b f N (HAdd.hAdd n 1) œâ) N\n‚ä¢ LT.lt (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) œâ) (MeasureTheory.lowerCrossingTime a b f N (HAdd.hAdd n 1) œâ)","decl":"theorem upperCrossingTime_lt_lowerCrossingTime (hab : a < b)\n    (hn : lowerCrossingTime a b f N (n + 1) œâ ‚â† N) :\n    upperCrossingTime a b f N (n + 1) œâ < lowerCrossingTime a b f N (n + 1) œâ := by\n  refine lt_of_le_of_ne upperCrossingTime_le_lowerCrossingTime fun h =>\n    not_le.2 hab <| le_trans ?_ (stoppedValue_lowerCrossingTime hn)\n  simp only [stoppedValue]\n  rw [‚Üê h]\n  exact stoppedValue_upperCrossingTime (h.symm ‚ñ∏ hn)\n\n"}
{"name":"MeasureTheory.lowerCrossingTime_lt_upperCrossingTime","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n : Nat\nœâ : Œ©\nhab : LT.lt a b\nhn : Ne (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) œâ) N\n‚ä¢ LT.lt (MeasureTheory.lowerCrossingTime a b f N n œâ) (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) œâ)","decl":"theorem lowerCrossingTime_lt_upperCrossingTime (hab : a < b)\n    (hn : upperCrossingTime a b f N (n + 1) œâ ‚â† N) :\n    lowerCrossingTime a b f N n œâ < upperCrossingTime a b f N (n + 1) œâ := by\n  refine lt_of_le_of_ne lowerCrossingTime_le_upperCrossingTime_succ fun h =>\n    not_le.2 hab <| le_trans (stoppedValue_upperCrossingTime hn) ?_\n  simp only [stoppedValue]\n  rw [‚Üê h]\n  exact stoppedValue_lowerCrossingTime (h.symm ‚ñ∏ hn)\n\n"}
{"name":"MeasureTheory.upperCrossingTime_lt_succ","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n : Nat\nœâ : Œ©\nhab : LT.lt a b\nhn : Ne (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) œâ) N\n‚ä¢ LT.lt (MeasureTheory.upperCrossingTime a b f N n œâ) (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) œâ)","decl":"theorem upperCrossingTime_lt_succ (hab : a < b) (hn : upperCrossingTime a b f N (n + 1) œâ ‚â† N) :\n    upperCrossingTime a b f N n œâ < upperCrossingTime a b f N (n + 1) œâ :=\n  lt_of_le_of_lt upperCrossingTime_le_lowerCrossingTime\n    (lowerCrossingTime_lt_upperCrossingTime hab hn)\n\n"}
{"name":"MeasureTheory.lowerCrossingTime_stabilize","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n m : Nat\nœâ : Œ©\nhnm : LE.le n m\nhn : Eq (MeasureTheory.lowerCrossingTime a b f N n œâ) N\n‚ä¢ Eq (MeasureTheory.lowerCrossingTime a b f N m œâ) N","decl":"theorem lowerCrossingTime_stabilize (hnm : n ‚â§ m) (hn : lowerCrossingTime a b f N n œâ = N) :\n    lowerCrossingTime a b f N m œâ = N :=\n  le_antisymm lowerCrossingTime_le (le_trans (le_of_eq hn.symm) (lowerCrossingTime_mono hnm))\n\n"}
{"name":"MeasureTheory.upperCrossingTime_stabilize","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n m : Nat\nœâ : Œ©\nhnm : LE.le n m\nhn : Eq (MeasureTheory.upperCrossingTime a b f N n œâ) N\n‚ä¢ Eq (MeasureTheory.upperCrossingTime a b f N m œâ) N","decl":"theorem upperCrossingTime_stabilize (hnm : n ‚â§ m) (hn : upperCrossingTime a b f N n œâ = N) :\n    upperCrossingTime a b f N m œâ = N :=\n  le_antisymm upperCrossingTime_le (le_trans (le_of_eq hn.symm) (upperCrossingTime_mono hnm))\n\n"}
{"name":"MeasureTheory.lowerCrossingTime_stabilize'","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n m : Nat\nœâ : Œ©\nhnm : LE.le n m\nhn : LE.le N (MeasureTheory.lowerCrossingTime a b f N n œâ)\n‚ä¢ Eq (MeasureTheory.lowerCrossingTime a b f N m œâ) N","decl":"theorem lowerCrossingTime_stabilize' (hnm : n ‚â§ m) (hn : N ‚â§ lowerCrossingTime a b f N n œâ) :\n    lowerCrossingTime a b f N m œâ = N :=\n  lowerCrossingTime_stabilize hnm (le_antisymm lowerCrossingTime_le hn)\n\n"}
{"name":"MeasureTheory.upperCrossingTime_stabilize'","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n m : Nat\nœâ : Œ©\nhnm : LE.le n m\nhn : LE.le N (MeasureTheory.upperCrossingTime a b f N n œâ)\n‚ä¢ Eq (MeasureTheory.upperCrossingTime a b f N m œâ) N","decl":"theorem upperCrossingTime_stabilize' (hnm : n ‚â§ m) (hn : N ‚â§ upperCrossingTime a b f N n œâ) :\n    upperCrossingTime a b f N m œâ = N :=\n  upperCrossingTime_stabilize hnm (le_antisymm upperCrossingTime_le hn)\n\n-- `upperCrossingTime_bound_eq` provides an explicit bound\n"}
{"name":"MeasureTheory.exists_upperCrossingTime_eq","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN : Nat\nœâ : Œ©\nhab : LT.lt a b\n‚ä¢ Exists fun n => Eq (MeasureTheory.upperCrossingTime a b f N n œâ) N","decl":"theorem exists_upperCrossingTime_eq (f : ‚Ñï ‚Üí Œ© ‚Üí ‚Ñù) (N : ‚Ñï) (œâ : Œ©) (hab : a < b) :\n    ‚àÉ n, upperCrossingTime a b f N n œâ = N := by\n  by_contra h; push_neg at h\n  have : StrictMono fun n => upperCrossingTime a b f N n œâ :=\n    strictMono_nat_of_lt_succ fun n => upperCrossingTime_lt_succ hab (h _)\n  obtain ‚ü®_, ‚ü®k, rfl‚ü©, hk‚ü© :\n      ‚àÉ (m : _) (_ : m ‚àà Set.range fun n => upperCrossingTime a b f N n œâ), N < m :=\n    ‚ü®upperCrossingTime a b f N (N + 1) œâ, ‚ü®N + 1, rfl‚ü©,\n      lt_of_lt_of_le N.lt_succ_self (StrictMono.id_le this (N + 1))‚ü©\n  exact not_le.2 hk upperCrossingTime_le\n\n"}
{"name":"MeasureTheory.upperCrossingTime_lt_bddAbove","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN : Nat\nœâ : Œ©\nhab : LT.lt a b\n‚ä¢ BddAbove (setOf fun n => LT.lt (MeasureTheory.upperCrossingTime a b f N n œâ) N)","decl":"theorem upperCrossingTime_lt_bddAbove (hab : a < b) :\n    BddAbove {n | upperCrossingTime a b f N n œâ < N} := by\n  obtain ‚ü®k, hk‚ü© := exists_upperCrossingTime_eq f N œâ hab\n  refine ‚ü®k, fun n (hn : upperCrossingTime a b f N n œâ < N) => ?_‚ü©\n  by_contra hn'\n  exact hn.ne (upperCrossingTime_stabilize (not_le.1 hn').le hk)\n\n"}
{"name":"MeasureTheory.upperCrossingTime_lt_nonempty","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN : Nat\nœâ : Œ©\nhN : LT.lt 0 N\n‚ä¢ (setOf fun n => LT.lt (MeasureTheory.upperCrossingTime a b f N n œâ) N).Nonempty","decl":"theorem upperCrossingTime_lt_nonempty (hN : 0 < N) :\n    {n | upperCrossingTime a b f N n œâ < N}.Nonempty :=\n  ‚ü®0, hN‚ü©\n\n"}
{"name":"MeasureTheory.upperCrossingTime_bound_eq","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN : Nat\nœâ : Œ©\nhab : LT.lt a b\n‚ä¢ Eq (MeasureTheory.upperCrossingTime a b f N N œâ) N","decl":"theorem upperCrossingTime_bound_eq (f : ‚Ñï ‚Üí Œ© ‚Üí ‚Ñù) (N : ‚Ñï) (œâ : Œ©) (hab : a < b) :\n    upperCrossingTime a b f N N œâ = N := by\n  by_cases hN' : N < Nat.find (exists_upperCrossingTime_eq f N œâ hab)\n  ¬∑ refine le_antisymm upperCrossingTime_le ?_\n    have hmono : StrictMonoOn (fun n => upperCrossingTime a b f N n œâ)\n        (Set.Iic (Nat.find (exists_upperCrossingTime_eq f N œâ hab)).pred) := by\n      refine strictMonoOn_Iic_of_lt_succ fun m hm => upperCrossingTime_lt_succ hab ?_\n      rw [Nat.lt_pred_iff] at hm\n      convert Nat.find_min _ hm\n    convert StrictMonoOn.Iic_id_le hmono N (Nat.le_sub_one_of_lt hN')\n  ¬∑ rw [not_lt] at hN'\n    exact upperCrossingTime_stabilize hN' (Nat.find_spec (exists_upperCrossingTime_eq f N œâ hab))\n\n"}
{"name":"MeasureTheory.upperCrossingTime_eq_of_bound_le","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n : Nat\nœâ : Œ©\nhab : LT.lt a b\nhn : LE.le N n\n‚ä¢ Eq (MeasureTheory.upperCrossingTime a b f N n œâ) N","decl":"theorem upperCrossingTime_eq_of_bound_le (hab : a < b) (hn : N ‚â§ n) :\n    upperCrossingTime a b f N n œâ = N :=\n  le_antisymm upperCrossingTime_le\n    (le_trans (upperCrossingTime_bound_eq f N œâ hab).symm.le (upperCrossingTime_mono hn))\n\n"}
{"name":"MeasureTheory.Adapted.isStoppingTime_crossing","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nm0 : MeasurableSpace Œ©\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n : Nat\n‚Ñ± : MeasureTheory.Filtration Nat m0\nhf : MeasureTheory.Adapted ‚Ñ± f\n‚ä¢ And (MeasureTheory.IsStoppingTime ‚Ñ± (MeasureTheory.upperCrossingTime a b f N n)) (MeasureTheory.IsStoppingTime ‚Ñ± (MeasureTheory.lowerCrossingTime a b f N n))","decl":"theorem Adapted.isStoppingTime_crossing (hf : Adapted ‚Ñ± f) :\n    IsStoppingTime ‚Ñ± (upperCrossingTime a b f N n) ‚àß\n      IsStoppingTime ‚Ñ± (lowerCrossingTime a b f N n) := by\n  induction' n with k ih\n  ¬∑ refine ‚ü®isStoppingTime_const _ 0, ?_‚ü©\n    simp [hitting_isStoppingTime hf measurableSet_Iic]\n  ¬∑ obtain ‚ü®_, ih‚ÇÇ‚ü© := ih\n    have : IsStoppingTime ‚Ñ± (upperCrossingTime a b f N (k + 1)) := by\n      intro n\n      simp_rw [upperCrossingTime_succ_eq]\n      exact isStoppingTime_hitting_isStoppingTime ih‚ÇÇ (fun _ => lowerCrossingTime_le)\n        measurableSet_Ici hf _\n    refine ‚ü®this, ?_‚ü©\n    intro n\n    exact isStoppingTime_hitting_isStoppingTime this (fun _ => upperCrossingTime_le)\n      measurableSet_Iic hf _\n\n"}
{"name":"MeasureTheory.Adapted.isStoppingTime_upperCrossingTime","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nm0 : MeasurableSpace Œ©\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n : Nat\n‚Ñ± : MeasureTheory.Filtration Nat m0\nhf : MeasureTheory.Adapted ‚Ñ± f\n‚ä¢ MeasureTheory.IsStoppingTime ‚Ñ± (MeasureTheory.upperCrossingTime a b f N n)","decl":"theorem Adapted.isStoppingTime_upperCrossingTime (hf : Adapted ‚Ñ± f) :\n    IsStoppingTime ‚Ñ± (upperCrossingTime a b f N n) :=\n  hf.isStoppingTime_crossing.1\n\n"}
{"name":"MeasureTheory.Adapted.isStoppingTime_lowerCrossingTime","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nm0 : MeasurableSpace Œ©\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n : Nat\n‚Ñ± : MeasureTheory.Filtration Nat m0\nhf : MeasureTheory.Adapted ‚Ñ± f\n‚ä¢ MeasureTheory.IsStoppingTime ‚Ñ± (MeasureTheory.lowerCrossingTime a b f N n)","decl":"theorem Adapted.isStoppingTime_lowerCrossingTime (hf : Adapted ‚Ñ± f) :\n    IsStoppingTime ‚Ñ± (lowerCrossingTime a b f N n) :=\n  hf.isStoppingTime_crossing.2\n\n"}
{"name":"MeasureTheory.upcrossingStrat_nonneg","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n : Nat\nœâ : Œ©\n‚ä¢ LE.le 0 (MeasureTheory.upcrossingStrat a b f N n œâ)","decl":"theorem upcrossingStrat_nonneg : 0 ‚â§ upcrossingStrat a b f N n œâ :=\n  Finset.sum_nonneg fun _ _ => Set.indicator_nonneg (fun _ _ => zero_le_one) _\n\n"}
{"name":"MeasureTheory.upcrossingStrat_le_one","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n : Nat\nœâ : Œ©\n‚ä¢ LE.le (MeasureTheory.upcrossingStrat a b f N n œâ) 1","decl":"theorem upcrossingStrat_le_one : upcrossingStrat a b f N n œâ ‚â§ 1 := by\n  rw [upcrossingStrat, ‚Üê Finset.indicator_biUnion_apply]\n  ¬∑ exact Set.indicator_le_self' (fun _ _ => zero_le_one) _\n  intro i _ j _ hij\n  simp only [Set.Ico_disjoint_Ico]\n  obtain hij' | hij' := lt_or_gt_of_ne hij\n  ¬∑ rw [min_eq_left (upperCrossingTime_mono (Nat.succ_le_succ hij'.le) :\n      upperCrossingTime a b f N _ œâ ‚â§ upperCrossingTime a b f N _ œâ),\n      max_eq_right (lowerCrossingTime_mono hij'.le :\n        lowerCrossingTime a b f N _ _ ‚â§ lowerCrossingTime _ _ _ _ _ _)]\n    refine le_trans upperCrossingTime_le_lowerCrossingTime\n      (lowerCrossingTime_mono (Nat.succ_le_of_lt hij'))\n  ¬∑ rw [gt_iff_lt] at hij'\n    rw [min_eq_right (upperCrossingTime_mono (Nat.succ_le_succ hij'.le) :\n      upperCrossingTime a b f N _ œâ ‚â§ upperCrossingTime a b f N _ œâ),\n      max_eq_left (lowerCrossingTime_mono hij'.le :\n        lowerCrossingTime a b f N _ _ ‚â§ lowerCrossingTime _ _ _ _ _ _)]\n    refine le_trans upperCrossingTime_le_lowerCrossingTime\n      (lowerCrossingTime_mono (Nat.succ_le_of_lt hij'))\n\n"}
{"name":"MeasureTheory.Adapted.upcrossingStrat_adapted","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nm0 : MeasurableSpace Œ©\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN : Nat\n‚Ñ± : MeasureTheory.Filtration Nat m0\nhf : MeasureTheory.Adapted ‚Ñ± f\n‚ä¢ MeasureTheory.Adapted ‚Ñ± (MeasureTheory.upcrossingStrat a b f N)","decl":"theorem Adapted.upcrossingStrat_adapted (hf : Adapted ‚Ñ± f) :\n    Adapted ‚Ñ± (upcrossingStrat a b f N) := by\n  intro n\n  change StronglyMeasurable[‚Ñ± n] fun œâ =>\n    ‚àë k ‚àà Finset.range N, ({n | lowerCrossingTime a b f N k œâ ‚â§ n} ‚à©\n      {n | n < upperCrossingTime a b f N (k + 1) œâ}).indicator 1 n\n  refine Finset.stronglyMeasurable_sum _ fun i _ =>\n    stronglyMeasurable_const.indicator ((hf.isStoppingTime_lowerCrossingTime n).inter ?_)\n  simp_rw [‚Üê not_le]\n  exact (hf.isStoppingTime_upperCrossingTime n).compl\n\n"}
{"name":"MeasureTheory.Submartingale.sum_upcrossingStrat_mul","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nm0 : MeasurableSpace Œ©\nŒº : MeasureTheory.Measure Œ©\nf : Nat ‚Üí Œ© ‚Üí Real\n‚Ñ± : MeasureTheory.Filtration Nat m0\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhf : MeasureTheory.Submartingale f ‚Ñ± Œº\na b : Real\nN : Nat\n‚ä¢ MeasureTheory.Submartingale (fun n => (Finset.range n).sum fun k => HMul.hMul (MeasureTheory.upcrossingStrat a b f N k) (HSub.hSub (f (HAdd.hAdd k 1)) (f k))) ‚Ñ± Œº","decl":"theorem Submartingale.sum_upcrossingStrat_mul [IsFiniteMeasure Œº] (hf : Submartingale f ‚Ñ± Œº)\n    (a b : ‚Ñù) (N : ‚Ñï) : Submartingale (fun n : ‚Ñï =>\n      ‚àë k ‚àà Finset.range n, upcrossingStrat a b f N k * (f (k + 1) - f k)) ‚Ñ± Œº :=\n  hf.sum_mul_sub hf.adapted.upcrossingStrat_adapted (fun _ _ => upcrossingStrat_le_one) fun _ _ =>\n    upcrossingStrat_nonneg\n\n"}
{"name":"MeasureTheory.Submartingale.sum_sub_upcrossingStrat_mul","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nm0 : MeasurableSpace Œ©\nŒº : MeasureTheory.Measure Œ©\nf : Nat ‚Üí Œ© ‚Üí Real\n‚Ñ± : MeasureTheory.Filtration Nat m0\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhf : MeasureTheory.Submartingale f ‚Ñ± Œº\na b : Real\nN : Nat\n‚ä¢ MeasureTheory.Submartingale (fun n => (Finset.range n).sum fun k => HMul.hMul (HSub.hSub 1 (MeasureTheory.upcrossingStrat a b f N k)) (HSub.hSub (f (HAdd.hAdd k 1)) (f k))) ‚Ñ± Œº","decl":"theorem Submartingale.sum_sub_upcrossingStrat_mul [IsFiniteMeasure Œº] (hf : Submartingale f ‚Ñ± Œº)\n    (a b : ‚Ñù) (N : ‚Ñï) : Submartingale (fun n : ‚Ñï =>\n      ‚àë k ‚àà Finset.range n, (1 - upcrossingStrat a b f N k) * (f (k + 1) - f k)) ‚Ñ± Œº := by\n  refine hf.sum_mul_sub (fun n => (adapted_const ‚Ñ± 1 n).sub (hf.adapted.upcrossingStrat_adapted n))\n    (?_ : ‚àÄ n œâ, (1 - upcrossingStrat a b f N n) œâ ‚â§ 1) ?_\n  ¬∑ exact fun n œâ => sub_le_self _ upcrossingStrat_nonneg\n  ¬∑ intro n œâ\n    simp [upcrossingStrat_le_one]\n\n"}
{"name":"MeasureTheory.Submartingale.sum_mul_upcrossingStrat_le","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nm0 : MeasurableSpace Œ©\nŒº : MeasureTheory.Measure Œ©\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n : Nat\n‚Ñ± : MeasureTheory.Filtration Nat m0\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhf : MeasureTheory.Submartingale f ‚Ñ± Œº\n‚ä¢ LE.le (MeasureTheory.integral Œº fun x => (Finset.range n).sum (fun k => HMul.hMul (MeasureTheory.upcrossingStrat a b f N k) (HSub.hSub (f (HAdd.hAdd k 1)) (f k))) x) (HSub.hSub (MeasureTheory.integral Œº fun x => f n x) (MeasureTheory.integral Œº fun x => f 0 x))","decl":"theorem Submartingale.sum_mul_upcrossingStrat_le [IsFiniteMeasure Œº] (hf : Submartingale f ‚Ñ± Œº) :\n    Œº[‚àë k ‚àà Finset.range n, upcrossingStrat a b f N k * (f (k + 1) - f k)] ‚â§ Œº[f n] - Œº[f 0] := by\n  have h‚ÇÅ : (0 : ‚Ñù) ‚â§\n      Œº[‚àë k ‚àà Finset.range n, (1 - upcrossingStrat a b f N k) * (f (k + 1) - f k)] := by\n    have := (hf.sum_sub_upcrossingStrat_mul a b N).setIntegral_le (zero_le n) MeasurableSet.univ\n    rw [setIntegral_univ, setIntegral_univ] at this\n    refine le_trans ?_ this\n    simp only [Finset.range_zero, Finset.sum_empty, integral_zero', le_refl]\n  have h‚ÇÇ : Œº[‚àë k ‚àà Finset.range n, (1 - upcrossingStrat a b f N k) * (f (k + 1) - f k)] =\n    Œº[‚àë k ‚àà Finset.range n, (f (k + 1) - f k)] -\n      Œº[‚àë k ‚àà Finset.range n, upcrossingStrat a b f N k * (f (k + 1) - f k)] := by\n    simp only [sub_mul, one_mul, Finset.sum_sub_distrib, Pi.sub_apply, Finset.sum_apply,\n      Pi.mul_apply]\n    refine integral_sub (Integrable.sub (integrable_finset_sum _ fun i _ => hf.integrable _)\n      (integrable_finset_sum _ fun i _ => hf.integrable _)) ?_\n    convert (hf.sum_upcrossingStrat_mul a b N).integrable n using 1\n    ext; simp\n  rw [h‚ÇÇ, sub_nonneg] at h‚ÇÅ\n  refine le_trans h‚ÇÅ ?_\n  simp_rw [Finset.sum_range_sub, integral_sub' (hf.integrable _) (hf.integrable _), le_refl]\n\n"}
{"name":"MeasureTheory.upcrossingsBefore_bot","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nŒπ : Type u_2\ninst‚úù¬≤ : Preorder Œπ\ninst‚úù¬π : OrderBot Œπ\ninst‚úù : InfSet Œπ\na b : Real\nf : Œπ ‚Üí Œ© ‚Üí Real\nœâ : Œ©\n‚ä¢ Eq (MeasureTheory.upcrossingsBefore a b f Bot.bot œâ) Bot.bot","decl":"@[simp]\ntheorem upcrossingsBefore_bot [Preorder Œπ] [OrderBot Œπ] [InfSet Œπ] {a b : ‚Ñù} {f : Œπ ‚Üí Œ© ‚Üí ‚Ñù}\n    {œâ : Œ©} : upcrossingsBefore a b f ‚ä• œâ = ‚ä• := by simp [upcrossingsBefore]\n\n"}
{"name":"MeasureTheory.upcrossingsBefore_zero","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nœâ : Œ©\n‚ä¢ Eq (MeasureTheory.upcrossingsBefore a b f 0 œâ) 0","decl":"theorem upcrossingsBefore_zero : upcrossingsBefore a b f 0 œâ = 0 := by simp [upcrossingsBefore]\n\n"}
{"name":"MeasureTheory.upcrossingsBefore_zero'","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\n‚ä¢ Eq (MeasureTheory.upcrossingsBefore a b f 0) 0","decl":"@[simp]\ntheorem upcrossingsBefore_zero' : upcrossingsBefore a b f 0 = 0 := by\n  ext œâ; exact upcrossingsBefore_zero\n\n"}
{"name":"MeasureTheory.upperCrossingTime_lt_of_le_upcrossingsBefore","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n : Nat\nœâ : Œ©\nhN : LT.lt 0 N\nhab : LT.lt a b\nhn : LE.le n (MeasureTheory.upcrossingsBefore a b f N œâ)\n‚ä¢ LT.lt (MeasureTheory.upperCrossingTime a b f N n œâ) N","decl":"theorem upperCrossingTime_lt_of_le_upcrossingsBefore (hN : 0 < N) (hab : a < b)\n    (hn : n ‚â§ upcrossingsBefore a b f N œâ) : upperCrossingTime a b f N n œâ < N :=\n  haveI : upperCrossingTime a b f N (upcrossingsBefore a b f N œâ) œâ < N :=\n    (upperCrossingTime_lt_nonempty hN).csSup_mem\n      ((OrderBot.bddBelow _).finite_of_bddAbove (upperCrossingTime_lt_bddAbove hab))\n  lt_of_le_of_lt (upperCrossingTime_mono hn) this\n\n"}
{"name":"MeasureTheory.upperCrossingTime_eq_of_upcrossingsBefore_lt","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n : Nat\nœâ : Œ©\nhab : LT.lt a b\nhn : LT.lt (MeasureTheory.upcrossingsBefore a b f N œâ) n\n‚ä¢ Eq (MeasureTheory.upperCrossingTime a b f N n œâ) N","decl":"theorem upperCrossingTime_eq_of_upcrossingsBefore_lt (hab : a < b)\n    (hn : upcrossingsBefore a b f N œâ < n) : upperCrossingTime a b f N n œâ = N := by\n  refine le_antisymm upperCrossingTime_le (not_lt.1 ?_)\n  convert not_mem_of_csSup_lt hn (upperCrossingTime_lt_bddAbove hab) using 1\n\n"}
{"name":"MeasureTheory.upcrossingsBefore_le","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nN : Nat\nf : Nat ‚Üí Œ© ‚Üí Real\nœâ : Œ©\nhab : LT.lt a b\n‚ä¢ LE.le (MeasureTheory.upcrossingsBefore a b f N œâ) N","decl":"theorem upcrossingsBefore_le (f : ‚Ñï ‚Üí Œ© ‚Üí ‚Ñù) (œâ : Œ©) (hab : a < b) :\n    upcrossingsBefore a b f N œâ ‚â§ N := by\n  by_cases hN : N = 0\n  ¬∑ subst hN\n    rw [upcrossingsBefore_zero]\n  ¬∑ refine csSup_le ‚ü®0, zero_lt_iff.2 hN‚ü© fun n (hn : _ < N) => ?_\n    by_contra hnN\n    exact hn.ne (upperCrossingTime_eq_of_bound_le hab (not_le.1 hnN).le)\n\n"}
{"name":"MeasureTheory.crossing_eq_crossing_of_lowerCrossingTime_lt","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n : Nat\nœâ : Œ©\nM : Nat\nhNM : LE.le N M\nh : LT.lt (MeasureTheory.lowerCrossingTime a b f N n œâ) N\n‚ä¢ And (Eq (MeasureTheory.upperCrossingTime a b f M n œâ) (MeasureTheory.upperCrossingTime a b f N n œâ)) (Eq (MeasureTheory.lowerCrossingTime a b f M n œâ) (MeasureTheory.lowerCrossingTime a b f N n œâ))","decl":"theorem crossing_eq_crossing_of_lowerCrossingTime_lt {M : ‚Ñï} (hNM : N ‚â§ M)\n    (h : lowerCrossingTime a b f N n œâ < N) :\n    upperCrossingTime a b f M n œâ = upperCrossingTime a b f N n œâ ‚àß\n      lowerCrossingTime a b f M n œâ = lowerCrossingTime a b f N n œâ := by\n  have h' : upperCrossingTime a b f N n œâ < N :=\n    lt_of_le_of_lt upperCrossingTime_le_lowerCrossingTime h\n  induction' n with k ih\n  ¬∑ simp only [upperCrossingTime_zero, bot_eq_zero', eq_self_iff_true,\n      lowerCrossingTime_zero, true_and, eq_comm]\n    refine hitting_eq_hitting_of_exists hNM ?_\n    rw [lowerCrossingTime, hitting_lt_iff] at h\n    ¬∑ obtain ‚ü®j, hj‚ÇÅ, hj‚ÇÇ‚ü© := h\n      exact ‚ü®j, ‚ü®hj‚ÇÅ.1, hj‚ÇÅ.2.le‚ü©, hj‚ÇÇ‚ü©\n    ¬∑ exact le_rfl\n  ¬∑ specialize ih (lt_of_le_of_lt (lowerCrossingTime_mono (Nat.le_succ _)) h)\n      (lt_of_le_of_lt (upperCrossingTime_mono (Nat.le_succ _)) h')\n    have : upperCrossingTime a b f M k.succ œâ = upperCrossingTime a b f N k.succ œâ := by\n      rw [upperCrossingTime_succ_eq, hitting_lt_iff] at h'\n      ¬∑ simp only [upperCrossingTime_succ_eq]\n        obtain ‚ü®j, hj‚ÇÅ, hj‚ÇÇ‚ü© := h'\n        rw [eq_comm, ih.2]\n        exact hitting_eq_hitting_of_exists hNM ‚ü®j, ‚ü®hj‚ÇÅ.1, hj‚ÇÅ.2.le‚ü©, hj‚ÇÇ‚ü©\n      ¬∑ exact le_rfl\n    refine ‚ü®this, ?_‚ü©\n    simp only [lowerCrossingTime, eq_comm, this, Nat.succ_eq_add_one]\n    refine hitting_eq_hitting_of_exists hNM ?_\n    rw [lowerCrossingTime, hitting_lt_iff _ le_rfl] at h\n    obtain ‚ü®j, hj‚ÇÅ, hj‚ÇÇ‚ü© := h\n    exact ‚ü®j, ‚ü®hj‚ÇÅ.1, hj‚ÇÅ.2.le‚ü©, hj‚ÇÇ‚ü©\n\n"}
{"name":"MeasureTheory.crossing_eq_crossing_of_upperCrossingTime_lt","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n : Nat\nœâ : Œ©\nM : Nat\nhNM : LE.le N M\nh : LT.lt (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) œâ) N\n‚ä¢ And (Eq (MeasureTheory.upperCrossingTime a b f M (HAdd.hAdd n 1) œâ) (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) œâ)) (Eq (MeasureTheory.lowerCrossingTime a b f M n œâ) (MeasureTheory.lowerCrossingTime a b f N n œâ))","decl":"theorem crossing_eq_crossing_of_upperCrossingTime_lt {M : ‚Ñï} (hNM : N ‚â§ M)\n    (h : upperCrossingTime a b f N (n + 1) œâ < N) :\n    upperCrossingTime a b f M (n + 1) œâ = upperCrossingTime a b f N (n + 1) œâ ‚àß\n      lowerCrossingTime a b f M n œâ = lowerCrossingTime a b f N n œâ := by\n  have := (crossing_eq_crossing_of_lowerCrossingTime_lt hNM\n    (lt_of_le_of_lt lowerCrossingTime_le_upperCrossingTime_succ h)).2\n  refine ‚ü®?_, this‚ü©\n  rw [upperCrossingTime_succ_eq, upperCrossingTime_succ_eq, eq_comm, this]\n  refine hitting_eq_hitting_of_exists hNM ?_\n  rw [upperCrossingTime_succ_eq, hitting_lt_iff] at h\n  ¬∑ obtain ‚ü®j, hj‚ÇÅ, hj‚ÇÇ‚ü© := h\n    exact ‚ü®j, ‚ü®hj‚ÇÅ.1, hj‚ÇÅ.2.le‚ü©, hj‚ÇÇ‚ü©\n  ¬∑ exact le_rfl\n\n"}
{"name":"MeasureTheory.upperCrossingTime_eq_upperCrossingTime_of_lt","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n : Nat\nœâ : Œ©\nM : Nat\nhNM : LE.le N M\nh : LT.lt (MeasureTheory.upperCrossingTime a b f N n œâ) N\n‚ä¢ Eq (MeasureTheory.upperCrossingTime a b f M n œâ) (MeasureTheory.upperCrossingTime a b f N n œâ)","decl":"theorem upperCrossingTime_eq_upperCrossingTime_of_lt {M : ‚Ñï} (hNM : N ‚â§ M)\n    (h : upperCrossingTime a b f N n œâ < N) :\n    upperCrossingTime a b f M n œâ = upperCrossingTime a b f N n œâ := by\n  cases n\n  ¬∑ simp\n  ¬∑ exact (crossing_eq_crossing_of_upperCrossingTime_lt hNM h).1\n\n"}
{"name":"MeasureTheory.upcrossingsBefore_mono","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nhab : LT.lt a b\n‚ä¢ Monotone fun N œâ => MeasureTheory.upcrossingsBefore a b f N œâ","decl":"theorem upcrossingsBefore_mono (hab : a < b) : Monotone fun N œâ => upcrossingsBefore a b f N œâ := by\n  intro N M hNM œâ\n  simp only [upcrossingsBefore]\n  by_cases hemp : {n : ‚Ñï | upperCrossingTime a b f N n œâ < N}.Nonempty\n  ¬∑ refine csSup_le_csSup (upperCrossingTime_lt_bddAbove hab) hemp fun n hn => ?_\n    rw [Set.mem_setOf_eq, upperCrossingTime_eq_upperCrossingTime_of_lt hNM hn]\n    exact lt_of_lt_of_le hn hNM\n  ¬∑ rw [Set.not_nonempty_iff_eq_empty] at hemp\n    simp [hemp, csSup_empty, bot_eq_zero', zero_le']\n\n"}
{"name":"MeasureTheory.upcrossingsBefore_lt_of_exists_upcrossing","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN : Nat\nœâ : Œ©\nhab : LT.lt a b\nN‚ÇÅ N‚ÇÇ : Nat\nhN‚ÇÅ : LE.le N N‚ÇÅ\nhN‚ÇÅ' : LT.lt (f N‚ÇÅ œâ) a\nhN‚ÇÇ : LE.le N‚ÇÅ N‚ÇÇ\nhN‚ÇÇ' : LT.lt b (f N‚ÇÇ œâ)\n‚ä¢ LT.lt (MeasureTheory.upcrossingsBefore a b f N œâ) (MeasureTheory.upcrossingsBefore a b f (HAdd.hAdd N‚ÇÇ 1) œâ)","decl":"theorem upcrossingsBefore_lt_of_exists_upcrossing (hab : a < b) {N‚ÇÅ N‚ÇÇ : ‚Ñï} (hN‚ÇÅ : N ‚â§ N‚ÇÅ)\n    (hN‚ÇÅ' : f N‚ÇÅ œâ < a) (hN‚ÇÇ : N‚ÇÅ ‚â§ N‚ÇÇ) (hN‚ÇÇ' : b < f N‚ÇÇ œâ) :\n    upcrossingsBefore a b f N œâ < upcrossingsBefore a b f (N‚ÇÇ + 1) œâ := by\n  refine lt_of_lt_of_le (Nat.lt_succ_self _) (le_csSup (upperCrossingTime_lt_bddAbove hab) ?_)\n  rw [Set.mem_setOf_eq, upperCrossingTime_succ_eq, hitting_lt_iff _ le_rfl]\n  refine ‚ü®N‚ÇÇ, ‚ü®?_, Nat.lt_succ_self _‚ü©, hN‚ÇÇ'.le‚ü©\n  rw [lowerCrossingTime, hitting_le_iff_of_lt _ (Nat.lt_succ_self _)]\n  refine ‚ü®N‚ÇÅ, ‚ü®le_trans ?_ hN‚ÇÅ, hN‚ÇÇ‚ü©, hN‚ÇÅ'.le‚ü©\n  by_cases hN : 0 < N\n  ¬∑ have : upperCrossingTime a b f N (upcrossingsBefore a b f N œâ) œâ < N :=\n      Nat.sSup_mem (upperCrossingTime_lt_nonempty hN) (upperCrossingTime_lt_bddAbove hab)\n    rw [upperCrossingTime_eq_upperCrossingTime_of_lt (hN‚ÇÅ.trans (hN‚ÇÇ.trans <| Nat.le_succ _))\n      this]\n    exact this.le\n  ¬∑ rw [not_lt, Nat.le_zero] at hN\n    rw [hN, upcrossingsBefore_zero, upperCrossingTime_zero, Pi.bot_apply, bot_eq_zero']\n\n"}
{"name":"MeasureTheory.lowerCrossingTime_lt_of_lt_upcrossingsBefore","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n : Nat\nœâ : Œ©\nhN : LT.lt 0 N\nhab : LT.lt a b\nhn : LT.lt n (MeasureTheory.upcrossingsBefore a b f N œâ)\n‚ä¢ LT.lt (MeasureTheory.lowerCrossingTime a b f N n œâ) N","decl":"theorem lowerCrossingTime_lt_of_lt_upcrossingsBefore (hN : 0 < N) (hab : a < b)\n    (hn : n < upcrossingsBefore a b f N œâ) : lowerCrossingTime a b f N n œâ < N :=\n  lt_of_le_of_lt lowerCrossingTime_le_upperCrossingTime_succ\n    (upperCrossingTime_lt_of_le_upcrossingsBefore hN hab hn)\n\n"}
{"name":"MeasureTheory.le_sub_of_le_upcrossingsBefore","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n : Nat\nœâ : Œ©\nhN : LT.lt 0 N\nhab : LT.lt a b\nhn : LT.lt n (MeasureTheory.upcrossingsBefore a b f N œâ)\n‚ä¢ LE.le (HSub.hSub b a) (HSub.hSub (MeasureTheory.stoppedValue f (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1)) œâ) (MeasureTheory.stoppedValue f (MeasureTheory.lowerCrossingTime a b f N n) œâ))","decl":"theorem le_sub_of_le_upcrossingsBefore (hN : 0 < N) (hab : a < b)\n    (hn : n < upcrossingsBefore a b f N œâ) :\n    b - a ‚â§ stoppedValue f (upperCrossingTime a b f N (n + 1)) œâ -\n      stoppedValue f (lowerCrossingTime a b f N n) œâ :=\n  sub_le_sub\n    (stoppedValue_upperCrossingTime (upperCrossingTime_lt_of_le_upcrossingsBefore hN hab hn).ne)\n    (stoppedValue_lowerCrossingTime (lowerCrossingTime_lt_of_lt_upcrossingsBefore hN hab hn).ne)\n\n"}
{"name":"MeasureTheory.sub_eq_zero_of_upcrossingsBefore_lt","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n : Nat\nœâ : Œ©\nhab : LT.lt a b\nhn : LT.lt (MeasureTheory.upcrossingsBefore a b f N œâ) n\n‚ä¢ Eq (HSub.hSub (MeasureTheory.stoppedValue f (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1)) œâ) (MeasureTheory.stoppedValue f (MeasureTheory.lowerCrossingTime a b f N n) œâ)) 0","decl":"theorem sub_eq_zero_of_upcrossingsBefore_lt (hab : a < b) (hn : upcrossingsBefore a b f N œâ < n) :\n    stoppedValue f (upperCrossingTime a b f N (n + 1)) œâ -\n      stoppedValue f (lowerCrossingTime a b f N n) œâ = 0 := by\n  have : N ‚â§ upperCrossingTime a b f N n œâ := by\n    rw [upcrossingsBefore] at hn\n    rw [‚Üê not_lt]\n    exact fun h => not_le.2 hn (le_csSup (upperCrossingTime_lt_bddAbove hab) h)\n  simp [stoppedValue, upperCrossingTime_stabilize' (Nat.le_succ n) this,\n    lowerCrossingTime_stabilize' le_rfl (le_trans this upperCrossingTime_le_lowerCrossingTime)]\n\n"}
{"name":"MeasureTheory.mul_upcrossingsBefore_le","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN : Nat\nœâ : Œ©\nhf : LE.le a (f N œâ)\nhab : LT.lt a b\n‚ä¢ LE.le (HMul.hMul (HSub.hSub b a) ‚Üë(MeasureTheory.upcrossingsBefore a b f N œâ)) ((Finset.range N).sum fun k => HMul.hMul (MeasureTheory.upcrossingStrat a b f N k œâ) (HSub.hSub (f (HAdd.hAdd k 1)) (f k) œâ))","decl":"theorem mul_upcrossingsBefore_le (hf : a ‚â§ f N œâ) (hab : a < b) :\n    (b - a) * upcrossingsBefore a b f N œâ ‚â§\n    ‚àë k ‚àà Finset.range N, upcrossingStrat a b f N k œâ * (f (k + 1) - f k) œâ := by\n  classical\n  by_cases hN : N = 0\n  ¬∑ simp [hN]\n  simp_rw [upcrossingStrat, Finset.sum_mul, ‚Üê\n    Set.indicator_mul_left _ _ (fun x ‚Ü¶ (f (x + 1) - f x) œâ), Pi.one_apply, Pi.sub_apply, one_mul]\n  rw [Finset.sum_comm]\n  have h‚ÇÅ : ‚àÄ k, ‚àë n ‚àà Finset.range N, (Set.Ico (lowerCrossingTime a b f N k œâ)\n      (upperCrossingTime a b f N (k + 1) œâ)).indicator (fun m => f (m + 1) œâ - f m œâ) n =\n      stoppedValue f (upperCrossingTime a b f N (k + 1)) œâ -\n        stoppedValue f (lowerCrossingTime a b f N k) œâ := by\n    intro k\n    rw [Finset.sum_indicator_eq_sum_filter, (_ : Finset.filter (fun i => i ‚àà Set.Ico\n      (lowerCrossingTime a b f N k œâ) (upperCrossingTime a b f N (k + 1) œâ)) (Finset.range N) =\n      Finset.Ico (lowerCrossingTime a b f N k œâ) (upperCrossingTime a b f N (k + 1) œâ)),\n      Finset.sum_Ico_eq_add_neg _ lowerCrossingTime_le_upperCrossingTime_succ,\n      Finset.sum_range_sub fun n => f n œâ, Finset.sum_range_sub fun n => f n œâ, neg_sub,\n      sub_add_sub_cancel]\n    ¬∑ rfl\n    ¬∑ ext i\n      simp only [Set.mem_Ico, Finset.mem_filter, Finset.mem_range, Finset.mem_Ico,\n        and_iff_right_iff_imp, and_imp]\n      exact fun _ h => lt_of_lt_of_le h upperCrossingTime_le\n  simp_rw [h‚ÇÅ]\n  have h‚ÇÇ : ‚àë _k ‚àà Finset.range (upcrossingsBefore a b f N œâ), (b - a) ‚â§\n      ‚àë k ‚àà Finset.range N, (stoppedValue f (upperCrossingTime a b f N (k + 1)) œâ -\n        stoppedValue f (lowerCrossingTime a b f N k) œâ) := by\n    calc\n      ‚àë _k ‚àà Finset.range (upcrossingsBefore a b f N œâ), (b - a) ‚â§\n          ‚àë k ‚àà Finset.range (upcrossingsBefore a b f N œâ),\n            (stoppedValue f (upperCrossingTime a b f N (k + 1)) œâ -\n              stoppedValue f (lowerCrossingTime a b f N k) œâ) := by\n        refine Finset.sum_le_sum fun i hi =>\n          le_sub_of_le_upcrossingsBefore (zero_lt_iff.2 hN) hab ?_\n        rwa [Finset.mem_range] at hi\n      _ ‚â§ ‚àë k ‚àà Finset.range N, (stoppedValue f (upperCrossingTime a b f N (k + 1)) œâ -\n          stoppedValue f (lowerCrossingTime a b f N k) œâ) := by\n        refine Finset.sum_le_sum_of_subset_of_nonneg\n          (Finset.range_subset.2 (upcrossingsBefore_le f œâ hab)) fun i _ hi => ?_\n        by_cases hi' : i = upcrossingsBefore a b f N œâ\n        ¬∑ subst hi'\n          simp only [stoppedValue]\n          rw [upperCrossingTime_eq_of_upcrossingsBefore_lt hab (Nat.lt_succ_self _)]\n          by_cases heq : lowerCrossingTime a b f N (upcrossingsBefore a b f N œâ) œâ = N\n          ¬∑ rw [heq, sub_self]\n          ¬∑ rw [sub_nonneg]\n            exact le_trans (stoppedValue_lowerCrossingTime heq) hf\n        ¬∑ rw [sub_eq_zero_of_upcrossingsBefore_lt hab]\n          rw [Finset.mem_range, not_lt] at hi\n          exact lt_of_le_of_ne hi (Ne.symm hi')\n  refine le_trans ?_ h‚ÇÇ\n  rw [Finset.sum_const, Finset.card_range, nsmul_eq_mul, mul_comm]\n\n"}
{"name":"MeasureTheory.integral_mul_upcrossingsBefore_le_integral","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nm0 : MeasurableSpace Œ©\nŒº : MeasureTheory.Measure Œ©\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN : Nat\n‚Ñ± : MeasureTheory.Filtration Nat m0\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhf : MeasureTheory.Submartingale f ‚Ñ± Œº\nhfN : ‚àÄ (œâ : Œ©), LE.le a (f N œâ)\nhfzero : LE.le 0 (f 0)\nhab : LT.lt a b\n‚ä¢ LE.le (HMul.hMul (HSub.hSub b a) (MeasureTheory.integral Œº fun x => ‚Üë(MeasureTheory.upcrossingsBefore a b f N x))) (MeasureTheory.integral Œº fun x => f N x)","decl":"theorem integral_mul_upcrossingsBefore_le_integral [IsFiniteMeasure Œº] (hf : Submartingale f ‚Ñ± Œº)\n    (hfN : ‚àÄ œâ, a ‚â§ f N œâ) (hfzero : 0 ‚â§ f 0) (hab : a < b) :\n    (b - a) * Œº[upcrossingsBefore a b f N] ‚â§ Œº[f N] :=\n  calc\n    (b - a) * Œº[upcrossingsBefore a b f N] ‚â§\n        Œº[‚àë k ‚àà Finset.range N, upcrossingStrat a b f N k * (f (k + 1) - f k)] := by\n      rw [‚Üê integral_mul_left]\n      refine integral_mono_of_nonneg ?_ ((hf.sum_upcrossingStrat_mul a b N).integrable N) ?_\n      ¬∑ exact Eventually.of_forall fun œâ => mul_nonneg (sub_nonneg.2 hab.le) (Nat.cast_nonneg _)\n      ¬∑ filter_upwards with œâ\n        simpa using mul_upcrossingsBefore_le (hfN œâ) hab\n    _ ‚â§ Œº[f N] - Œº[f 0] := hf.sum_mul_upcrossingStrat_le\n    _ ‚â§ Œº[f N] := (sub_le_self_iff _).2 (integral_nonneg hfzero)\n\n"}
{"name":"MeasureTheory.crossing_pos_eq","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN n : Nat\nhab : LT.lt a b\n‚ä¢ And (Eq (MeasureTheory.upperCrossingTime 0 (HSub.hSub b a) (fun n œâ => PosPart.posPart (HSub.hSub (f n œâ) a)) N n) (MeasureTheory.upperCrossingTime a b f N n)) (Eq (MeasureTheory.lowerCrossingTime 0 (HSub.hSub b a) (fun n œâ => PosPart.posPart (HSub.hSub (f n œâ) a)) N n) (MeasureTheory.lowerCrossingTime a b f N n))","decl":"theorem crossing_pos_eq (hab : a < b) :\n    upperCrossingTime 0 (b - a) (fun n œâ => (f n œâ - a)‚Å∫) N n = upperCrossingTime a b f N n ‚àß\n      lowerCrossingTime 0 (b - a) (fun n œâ => (f n œâ - a)‚Å∫) N n = lowerCrossingTime a b f N n := by\n  have hab' : 0 < b - a := sub_pos.2 hab\n  have hf : ‚àÄ œâ i, b - a ‚â§ (f i œâ - a)‚Å∫ ‚Üî b ‚â§ f i œâ := by\n    intro i œâ\n    refine ‚ü®fun h => ?_, fun h => ?_‚ü©\n    ¬∑ rwa [‚Üê sub_le_sub_iff_right a, ‚Üê\n        posPart_eq_of_posPart_pos (lt_of_lt_of_le hab' h)]\n    ¬∑ rw [‚Üê sub_le_sub_iff_right a] at h\n      rwa [posPart_eq_self.2 (le_trans hab'.le h)]\n  have hf' (œâ i) : (f i œâ - a)‚Å∫ ‚â§ 0 ‚Üî f i œâ ‚â§ a := by rw [posPart_nonpos, sub_nonpos]\n  induction' n with k ih\n  ¬∑ refine ‚ü®rfl, ?_‚ü©\n    simp (config := { unfoldPartialApp := true }) only [lowerCrossingTime_zero, hitting,\n      Set.mem_Icc, Set.mem_Iic]\n    ext œâ\n    split_ifs with h‚ÇÅ h‚ÇÇ h‚ÇÇ\n    ¬∑ simp_rw [hf']\n    ¬∑ simp_rw [Set.mem_Iic, ‚Üê hf' _ _] at h‚ÇÇ\n      exact False.elim (h‚ÇÇ h‚ÇÅ)\n    ¬∑ simp_rw [Set.mem_Iic, hf' _ _] at h‚ÇÅ\n      exact False.elim (h‚ÇÅ h‚ÇÇ)\n    ¬∑ rfl\n  ¬∑ have : upperCrossingTime 0 (b - a) (fun n œâ => (f n œâ - a)‚Å∫) N (k + 1) =\n        upperCrossingTime a b f N (k + 1) := by\n      ext œâ\n      simp only [upperCrossingTime_succ_eq, ‚Üê ih.2, hitting, Set.mem_Ici, tsub_le_iff_right]\n      split_ifs with h‚ÇÅ h‚ÇÇ h‚ÇÇ\n      ¬∑ simp_rw [‚Üê sub_le_iff_le_add, hf œâ]\n      ¬∑ refine False.elim (h‚ÇÇ ?_)\n        simp_all only [Set.mem_Ici, not_true_eq_false]\n      ¬∑ refine False.elim (h‚ÇÅ ?_)\n        simp_all only [Set.mem_Ici]\n      ¬∑ rfl\n    refine ‚ü®this, ?_‚ü©\n    ext œâ\n    simp only [lowerCrossingTime, this, hitting, Set.mem_Iic]\n    split_ifs with h‚ÇÅ h‚ÇÇ h‚ÇÇ\n    ¬∑ simp_rw [hf' œâ]\n    ¬∑ refine False.elim (h‚ÇÇ ?_)\n      simp_all only [Set.mem_Iic, not_true_eq_false]\n    ¬∑ refine False.elim (h‚ÇÅ ?_)\n      simp_all only [Set.mem_Iic]\n    ¬∑ rfl\n\n"}
{"name":"MeasureTheory.upcrossingsBefore_pos_eq","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN : Nat\nœâ : Œ©\nhab : LT.lt a b\n‚ä¢ Eq (MeasureTheory.upcrossingsBefore 0 (HSub.hSub b a) (fun n œâ => PosPart.posPart (HSub.hSub (f n œâ) a)) N œâ) (MeasureTheory.upcrossingsBefore a b f N œâ)","decl":"theorem upcrossingsBefore_pos_eq (hab : a < b) :\n    upcrossingsBefore 0 (b - a) (fun n œâ => (f n œâ - a)‚Å∫) N œâ = upcrossingsBefore a b f N œâ := by\n  simp_rw [upcrossingsBefore, (crossing_pos_eq hab).1]\n\n"}
{"name":"MeasureTheory.mul_integral_upcrossingsBefore_le_integral_pos_part_aux","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nm0 : MeasurableSpace Œ©\nŒº : MeasureTheory.Measure Œ©\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN : Nat\n‚Ñ± : MeasureTheory.Filtration Nat m0\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhf : MeasureTheory.Submartingale f ‚Ñ± Œº\nhab : LT.lt a b\n‚ä¢ LE.le (HMul.hMul (HSub.hSub b a) (MeasureTheory.integral Œº fun x => ‚Üë(MeasureTheory.upcrossingsBefore a b f N x))) (MeasureTheory.integral Œº fun x => (fun œâ => PosPart.posPart (HSub.hSub (f N œâ) a)) x)","decl":"theorem mul_integral_upcrossingsBefore_le_integral_pos_part_aux [IsFiniteMeasure Œº]\n    (hf : Submartingale f ‚Ñ± Œº) (hab : a < b) :\n    (b - a) * Œº[upcrossingsBefore a b f N] ‚â§ Œº[fun œâ => (f N œâ - a)‚Å∫] := by\n  refine le_trans (le_of_eq ?_)\n    (integral_mul_upcrossingsBefore_le_integral (hf.sub_martingale (martingale_const _ _ _)).pos\n      (fun œâ => posPart_nonneg _)\n      (fun œâ => posPart_nonneg _) (sub_pos.2 hab))\n  simp_rw [sub_zero, ‚Üê upcrossingsBefore_pos_eq hab]\n  rfl\n\n"}
{"name":"MeasureTheory.Submartingale.mul_integral_upcrossingsBefore_le_integral_pos_part","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nm0 : MeasurableSpace Œ©\nŒº : MeasureTheory.Measure Œ©\nf : Nat ‚Üí Œ© ‚Üí Real\n‚Ñ± : MeasureTheory.Filtration Nat m0\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\na b : Real\nhf : MeasureTheory.Submartingale f ‚Ñ± Œº\nN : Nat\n‚ä¢ LE.le (HMul.hMul (HSub.hSub b a) (MeasureTheory.integral Œº fun x => ‚Üë(MeasureTheory.upcrossingsBefore a b f N x))) (MeasureTheory.integral Œº fun x => (fun œâ => PosPart.posPart (HSub.hSub (f N œâ) a)) x)","decl":"/-- **Doob's upcrossing estimate**: given a real valued discrete submartingale `f` and real\nvalues `a` and `b`, we have `(b - a) * ùîº[upcrossingsBefore a b f N] ‚â§ ùîº[(f N - a)‚Å∫]` where\n`upcrossingsBefore a b f N` is the number of times the process `f` crossed from below `a` to above\n`b` before the time `N`. -/\ntheorem Submartingale.mul_integral_upcrossingsBefore_le_integral_pos_part [IsFiniteMeasure Œº]\n    (a b : ‚Ñù) (hf : Submartingale f ‚Ñ± Œº) (N : ‚Ñï) :\n    (b - a) * Œº[upcrossingsBefore a b f N] ‚â§ Œº[fun œâ => (f N œâ - a)‚Å∫] := by\n  by_cases hab : a < b\n  ¬∑ exact mul_integral_upcrossingsBefore_le_integral_pos_part_aux hf hab\n  ¬∑ rw [not_lt, ‚Üê sub_nonpos] at hab\n    exact le_trans (mul_nonpos_of_nonpos_of_nonneg hab (by positivity))\n      (integral_nonneg fun œâ => posPart_nonneg _)\n\n"}
{"name":"MeasureTheory.upcrossingsBefore_eq_sum","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN : Nat\nœâ : Œ©\nhab : LT.lt a b\n‚ä¢ Eq (MeasureTheory.upcrossingsBefore a b f N œâ) ((Finset.Ico 1 (HAdd.hAdd N 1)).sum fun i => (setOf fun n => LT.lt (MeasureTheory.upperCrossingTime a b f N n œâ) N).indicator 1 i)","decl":"theorem upcrossingsBefore_eq_sum (hab : a < b) : upcrossingsBefore a b f N œâ =\n    ‚àë i ‚àà Finset.Ico 1 (N + 1), {n | upperCrossingTime a b f N n œâ < N}.indicator 1 i := by\n  by_cases hN : N = 0\n  ¬∑ simp [hN]\n  rw [‚Üê Finset.sum_Ico_consecutive _ (Nat.succ_le_succ zero_le')\n    (Nat.succ_le_succ (upcrossingsBefore_le f œâ hab))]\n  have h‚ÇÅ : ‚àÄ k ‚àà Finset.Ico 1 (upcrossingsBefore a b f N œâ + 1),\n      {n : ‚Ñï | upperCrossingTime a b f N n œâ < N}.indicator 1 k = 1 := by\n    rintro k hk\n    rw [Finset.mem_Ico] at hk\n    rw [Set.indicator_of_mem]\n    ¬∑ rfl\n    ¬∑ exact upperCrossingTime_lt_of_le_upcrossingsBefore (zero_lt_iff.2 hN) hab\n        (Nat.lt_succ_iff.1 hk.2)\n  have h‚ÇÇ : ‚àÄ k ‚àà Finset.Ico (upcrossingsBefore a b f N œâ + 1) (N + 1),\n      {n : ‚Ñï | upperCrossingTime a b f N n œâ < N}.indicator 1 k = 0 := by\n    rintro k hk\n    rw [Finset.mem_Ico, Nat.succ_le_iff] at hk\n    rw [Set.indicator_of_not_mem]\n    simp only [Set.mem_setOf_eq, not_lt]\n    exact (upperCrossingTime_eq_of_upcrossingsBefore_lt hab hk.1).symm.le\n  rw [Finset.sum_congr rfl h‚ÇÅ, Finset.sum_congr rfl h‚ÇÇ, Finset.sum_const, Finset.sum_const,\n    smul_eq_mul, mul_one, smul_eq_mul, mul_zero, Nat.card_Ico, Nat.add_succ_sub_one,\n    add_zero, add_zero]\n\n"}
{"name":"MeasureTheory.Adapted.measurable_upcrossingsBefore","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nm0 : MeasurableSpace Œ©\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN : Nat\n‚Ñ± : MeasureTheory.Filtration Nat m0\nhf : MeasureTheory.Adapted ‚Ñ± f\nhab : LT.lt a b\n‚ä¢ Measurable (MeasureTheory.upcrossingsBefore a b f N)","decl":"theorem Adapted.measurable_upcrossingsBefore (hf : Adapted ‚Ñ± f) (hab : a < b) :\n    Measurable (upcrossingsBefore a b f N) := by\n  have : upcrossingsBefore a b f N = fun œâ =>\n      ‚àë i ‚àà Finset.Ico 1 (N + 1), {n | upperCrossingTime a b f N n œâ < N}.indicator 1 i := by\n    ext œâ\n    exact upcrossingsBefore_eq_sum hab\n  rw [this]\n  exact Finset.measurable_sum _ fun i _ => Measurable.indicator measurable_const <|\n    ‚Ñ±.le N _ (hf.isStoppingTime_upperCrossingTime.measurableSet_lt_of_pred N)\n\n"}
{"name":"MeasureTheory.Adapted.integrable_upcrossingsBefore","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nm0 : MeasurableSpace Œ©\nŒº : MeasureTheory.Measure Œ©\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nN : Nat\n‚Ñ± : MeasureTheory.Filtration Nat m0\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhf : MeasureTheory.Adapted ‚Ñ± f\nhab : LT.lt a b\n‚ä¢ MeasureTheory.Integrable (fun œâ => ‚Üë(MeasureTheory.upcrossingsBefore a b f N œâ)) Œº","decl":"theorem Adapted.integrable_upcrossingsBefore [IsFiniteMeasure Œº] (hf : Adapted ‚Ñ± f) (hab : a < b) :\n    Integrable (fun œâ => (upcrossingsBefore a b f N œâ : ‚Ñù)) Œº :=\n  haveI : ‚àÄ·µê œâ ‚àÇŒº, ‚Äñ(upcrossingsBefore a b f N œâ : ‚Ñù)‚Äñ ‚â§ N := by\n    filter_upwards with œâ\n    rw [Real.norm_eq_abs, Nat.abs_cast, Nat.cast_le]\n    exact upcrossingsBefore_le _ _ hab\n  ‚ü®Measurable.aestronglyMeasurable (measurable_from_top.comp (hf.measurable_upcrossingsBefore hab)),\n    hasFiniteIntegral_of_bounded this‚ü©\n\n"}
{"name":"MeasureTheory.Adapted.measurable_upcrossings","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nm0 : MeasurableSpace Œ©\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\n‚Ñ± : MeasureTheory.Filtration Nat m0\nhf : MeasureTheory.Adapted ‚Ñ± f\nhab : LT.lt a b\n‚ä¢ Measurable (MeasureTheory.upcrossings a b f)","decl":"theorem Adapted.measurable_upcrossings (hf : Adapted ‚Ñ± f) (hab : a < b) :\n    Measurable (upcrossings a b f) :=\n  .iSup fun _ => measurable_from_top.comp (hf.measurable_upcrossingsBefore hab)\n\n"}
{"name":"MeasureTheory.upcrossings_lt_top_iff","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\na b : Real\nf : Nat ‚Üí Œ© ‚Üí Real\nœâ : Œ©\n‚ä¢ Iff (LT.lt (MeasureTheory.upcrossings a b f œâ) Top.top) (Exists fun k => ‚àÄ (N : Nat), LE.le (MeasureTheory.upcrossingsBefore a b f N œâ) k)","decl":"theorem upcrossings_lt_top_iff :\n    upcrossings a b f œâ < ‚àû ‚Üî ‚àÉ k, ‚àÄ N, upcrossingsBefore a b f N œâ ‚â§ k := by\n  have : upcrossings a b f œâ < ‚àû ‚Üî ‚àÉ k : ‚Ñù‚â•0, upcrossings a b f œâ ‚â§ k := by\n    constructor\n    ¬∑ intro h\n      lift upcrossings a b f œâ to ‚Ñù‚â•0 using h.ne with r hr\n      exact ‚ü®r, le_rfl‚ü©\n    ¬∑ rintro ‚ü®k, hk‚ü©\n      exact lt_of_le_of_lt hk ENNReal.coe_lt_top\n  simp_rw [this, upcrossings, iSup_le_iff]\n  constructor <;> rintro ‚ü®k, hk‚ü©\n  ¬∑ obtain ‚ü®m, hm‚ü© := exists_nat_ge k\n    refine ‚ü®m, fun N => Nat.cast_le.1 ((hk N).trans ?_)‚ü©\n    rwa [‚Üê ENNReal.coe_natCast, ENNReal.coe_le_coe]\n  ¬∑ refine ‚ü®k, fun N => ?_‚ü©\n    simp only [ENNReal.coe_natCast, Nat.cast_le, hk N]\n\n"}
{"name":"MeasureTheory.Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Œ© : Type u_1\nm0 : MeasurableSpace Œ©\nŒº : MeasureTheory.Measure Œ©\nf : Nat ‚Üí Œ© ‚Üí Real\n‚Ñ± : MeasureTheory.Filtration Nat m0\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\na b : Real\nhf : MeasureTheory.Submartingale f ‚Ñ± Œº\n‚ä¢ LE.le (HMul.hMul (ENNReal.ofReal (HSub.hSub b a)) (MeasureTheory.lintegral Œº fun œâ => MeasureTheory.upcrossings a b f œâ)) (iSup fun N => MeasureTheory.lintegral Œº fun œâ => ENNReal.ofReal (PosPart.posPart (HSub.hSub (f N œâ) a)))","decl":"/-- A variant of Doob's upcrossing estimate obtained by taking the supremum on both sides. -/\ntheorem Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part [IsFiniteMeasure Œº] (a b : ‚Ñù)\n    (hf : Submartingale f ‚Ñ± Œº) : ENNReal.ofReal (b - a) * ‚à´‚Åª œâ, upcrossings a b f œâ ‚àÇŒº ‚â§\n      ‚®Ü N, ‚à´‚Åª œâ, ENNReal.ofReal ((f N œâ - a)‚Å∫) ‚àÇŒº := by\n  by_cases hab : a < b\n  ¬∑ simp_rw [upcrossings]\n    have : ‚àÄ N, ‚à´‚Åª œâ, ENNReal.ofReal ((f N œâ - a)‚Å∫) ‚àÇŒº = ENNReal.ofReal (‚à´ œâ, (f N œâ - a)‚Å∫ ‚àÇŒº) := by\n      intro N\n      rw [ofReal_integral_eq_lintegral_ofReal]\n      ¬∑ exact (hf.sub_martingale (martingale_const _ _ _)).pos.integrable _\n      ¬∑ exact Eventually.of_forall fun œâ => posPart_nonneg _\n    rw [lintegral_iSup']\n    ¬∑ simp_rw [this, ENNReal.mul_iSup, iSup_le_iff]\n      intro N\n      rw [(by simp :\n          ‚à´‚Åª œâ, upcrossingsBefore a b f N œâ ‚àÇŒº = ‚à´‚Åª œâ, ‚Üë(upcrossingsBefore a b f N œâ : ‚Ñù‚â•0) ‚àÇŒº),\n        lintegral_coe_eq_integral, ‚Üê ENNReal.ofReal_mul (sub_pos.2 hab).le]\n      ¬∑ simp_rw [NNReal.coe_natCast]\n        exact (ENNReal.ofReal_le_ofReal\n          (hf.mul_integral_upcrossingsBefore_le_integral_pos_part a b N)).trans\n            (le_iSup (Œ± := ‚Ñù‚â•0‚àû) _ N)\n      ¬∑ simp only [NNReal.coe_natCast, hf.adapted.integrable_upcrossingsBefore hab]\n    ¬∑ exact fun n => measurable_from_top.comp_aemeasurable\n        (hf.adapted.measurable_upcrossingsBefore hab).aemeasurable\n    ¬∑ filter_upwards with œâ N M hNM\n      rw [Nat.cast_le]\n      exact upcrossingsBefore_mono hab hNM œâ\n  ¬∑ rw [not_lt, ‚Üê sub_nonpos] at hab\n    rw [ENNReal.ofReal_of_nonpos hab, zero_mul]\n    exact zero_le _\n\n"}
