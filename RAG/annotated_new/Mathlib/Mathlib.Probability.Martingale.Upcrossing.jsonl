{"name":"MeasureTheory.upperCrossingTime_zero","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nι : Type u_2\ninst✝² : Preorder ι\ninst✝¹ : OrderBot ι\ninst✝ : InfSet ι\na b : Real\nf : ι → Ω → Real\nN : ι\n⊢ Eq (MeasureTheory.upperCrossingTime a b f N 0) Bot.bot","decl":"@[simp]\ntheorem upperCrossingTime_zero : upperCrossingTime a b f N 0 = ⊥ :=\n  rfl\n\n"}
{"name":"MeasureTheory.lowerCrossingTime_zero","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nι : Type u_2\ninst✝² : Preorder ι\ninst✝¹ : OrderBot ι\ninst✝ : InfSet ι\na b : Real\nf : ι → Ω → Real\nN : ι\n⊢ Eq (MeasureTheory.lowerCrossingTime a b f N 0) (MeasureTheory.hitting f (Set.Iic a) Bot.bot N)","decl":"@[simp]\ntheorem lowerCrossingTime_zero : lowerCrossingTime a b f N 0 = hitting f (Set.Iic a) ⊥ N :=\n  rfl\n\n"}
{"name":"MeasureTheory.upperCrossingTime_succ","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nι : Type u_2\ninst✝² : Preorder ι\ninst✝¹ : OrderBot ι\ninst✝ : InfSet ι\na b : Real\nf : ι → Ω → Real\nN : ι\nn : Nat\nω : Ω\n⊢ Eq (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) ω) (MeasureTheory.hitting f (Set.Ici b) (MeasureTheory.lowerCrossingTimeAux a f (MeasureTheory.upperCrossingTime a b f N n ω) N ω) N ω)","decl":"theorem upperCrossingTime_succ : upperCrossingTime a b f N (n + 1) ω =\n    hitting f (Set.Ici b) (lowerCrossingTimeAux a f (upperCrossingTime a b f N n ω) N ω) N ω := by\n  rw [upperCrossingTime]\n\n"}
{"name":"MeasureTheory.upperCrossingTime_succ_eq","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nι : Type u_2\ninst✝² : Preorder ι\ninst✝¹ : OrderBot ι\ninst✝ : InfSet ι\na b : Real\nf : ι → Ω → Real\nN : ι\nn : Nat\nω : Ω\n⊢ Eq (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) ω) (MeasureTheory.hitting f (Set.Ici b) (MeasureTheory.lowerCrossingTime a b f N n ω) N ω)","decl":"theorem upperCrossingTime_succ_eq (ω : Ω) : upperCrossingTime a b f N (n + 1) ω =\n    hitting f (Set.Ici b) (lowerCrossingTime a b f N n ω) N ω := by\n  simp only [upperCrossingTime_succ]\n  rfl\n\n"}
{"name":"MeasureTheory.upperCrossingTime_le","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nι : Type u_2\ninst✝ : ConditionallyCompleteLinearOrderBot ι\na b : Real\nf : ι → Ω → Real\nN : ι\nn : Nat\nω : Ω\n⊢ LE.le (MeasureTheory.upperCrossingTime a b f N n ω) N","decl":"theorem upperCrossingTime_le : upperCrossingTime a b f N n ω ≤ N := by\n  cases n\n  · simp only [upperCrossingTime_zero, Pi.bot_apply, bot_le]\n  · simp only [upperCrossingTime_succ, hitting_le]\n\n"}
{"name":"MeasureTheory.upperCrossingTime_zero'","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nι : Type u_2\ninst✝ : ConditionallyCompleteLinearOrderBot ι\na b : Real\nf : ι → Ω → Real\nn : Nat\nω : Ω\n⊢ Eq (MeasureTheory.upperCrossingTime a b f Bot.bot n ω) Bot.bot","decl":"@[simp]\ntheorem upperCrossingTime_zero' : upperCrossingTime a b f ⊥ n ω = ⊥ :=\n  eq_bot_iff.2 upperCrossingTime_le\n\n"}
{"name":"MeasureTheory.lowerCrossingTime_le","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nι : Type u_2\ninst✝ : ConditionallyCompleteLinearOrderBot ι\na b : Real\nf : ι → Ω → Real\nN : ι\nn : Nat\nω : Ω\n⊢ LE.le (MeasureTheory.lowerCrossingTime a b f N n ω) N","decl":"theorem lowerCrossingTime_le : lowerCrossingTime a b f N n ω ≤ N := by\n  simp only [lowerCrossingTime, hitting_le ω]\n\n"}
{"name":"MeasureTheory.upperCrossingTime_le_lowerCrossingTime","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nι : Type u_2\ninst✝ : ConditionallyCompleteLinearOrderBot ι\na b : Real\nf : ι → Ω → Real\nN : ι\nn : Nat\nω : Ω\n⊢ LE.le (MeasureTheory.upperCrossingTime a b f N n ω) (MeasureTheory.lowerCrossingTime a b f N n ω)","decl":"theorem upperCrossingTime_le_lowerCrossingTime :\n    upperCrossingTime a b f N n ω ≤ lowerCrossingTime a b f N n ω := by\n  simp only [lowerCrossingTime, le_hitting upperCrossingTime_le ω]\n\n"}
{"name":"MeasureTheory.lowerCrossingTime_le_upperCrossingTime_succ","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nι : Type u_2\ninst✝ : ConditionallyCompleteLinearOrderBot ι\na b : Real\nf : ι → Ω → Real\nN : ι\nn : Nat\nω : Ω\n⊢ LE.le (MeasureTheory.lowerCrossingTime a b f N n ω) (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) ω)","decl":"theorem lowerCrossingTime_le_upperCrossingTime_succ :\n    lowerCrossingTime a b f N n ω ≤ upperCrossingTime a b f N (n + 1) ω := by\n  rw [upperCrossingTime_succ]\n  exact le_hitting lowerCrossingTime_le ω\n\n"}
{"name":"MeasureTheory.lowerCrossingTime_mono","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nι : Type u_2\ninst✝ : ConditionallyCompleteLinearOrderBot ι\na b : Real\nf : ι → Ω → Real\nN : ι\nn m : Nat\nω : Ω\nhnm : LE.le n m\n⊢ LE.le (MeasureTheory.lowerCrossingTime a b f N n ω) (MeasureTheory.lowerCrossingTime a b f N m ω)","decl":"theorem lowerCrossingTime_mono (hnm : n ≤ m) :\n    lowerCrossingTime a b f N n ω ≤ lowerCrossingTime a b f N m ω := by\n  suffices Monotone fun n => lowerCrossingTime a b f N n ω by exact this hnm\n  exact monotone_nat_of_le_succ fun n =>\n    le_trans lowerCrossingTime_le_upperCrossingTime_succ upperCrossingTime_le_lowerCrossingTime\n\n"}
{"name":"MeasureTheory.upperCrossingTime_mono","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nι : Type u_2\ninst✝ : ConditionallyCompleteLinearOrderBot ι\na b : Real\nf : ι → Ω → Real\nN : ι\nn m : Nat\nω : Ω\nhnm : LE.le n m\n⊢ LE.le (MeasureTheory.upperCrossingTime a b f N n ω) (MeasureTheory.upperCrossingTime a b f N m ω)","decl":"theorem upperCrossingTime_mono (hnm : n ≤ m) :\n    upperCrossingTime a b f N n ω ≤ upperCrossingTime a b f N m ω := by\n  suffices Monotone fun n => upperCrossingTime a b f N n ω by exact this hnm\n  exact monotone_nat_of_le_succ fun n =>\n    le_trans upperCrossingTime_le_lowerCrossingTime lowerCrossingTime_le_upperCrossingTime_succ\n\n"}
{"name":"MeasureTheory.stoppedValue_lowerCrossingTime","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN n : Nat\nω : Ω\nh : Ne (MeasureTheory.lowerCrossingTime a b f N n ω) N\n⊢ LE.le (MeasureTheory.stoppedValue f (MeasureTheory.lowerCrossingTime a b f N n) ω) a","decl":"theorem stoppedValue_lowerCrossingTime (h : lowerCrossingTime a b f N n ω ≠ N) :\n    stoppedValue f (lowerCrossingTime a b f N n) ω ≤ a := by\n  obtain ⟨j, hj₁, hj₂⟩ := (hitting_le_iff_of_lt _ (lt_of_le_of_ne lowerCrossingTime_le h)).1 le_rfl\n  exact stoppedValue_hitting_mem ⟨j, ⟨hj₁.1, le_trans hj₁.2 lowerCrossingTime_le⟩, hj₂⟩\n\n"}
{"name":"MeasureTheory.stoppedValue_upperCrossingTime","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN n : Nat\nω : Ω\nh : Ne (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) ω) N\n⊢ LE.le b (MeasureTheory.stoppedValue f (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1)) ω)","decl":"theorem stoppedValue_upperCrossingTime (h : upperCrossingTime a b f N (n + 1) ω ≠ N) :\n    b ≤ stoppedValue f (upperCrossingTime a b f N (n + 1)) ω := by\n  obtain ⟨j, hj₁, hj₂⟩ := (hitting_le_iff_of_lt _ (lt_of_le_of_ne upperCrossingTime_le h)).1 le_rfl\n  exact stoppedValue_hitting_mem ⟨j, ⟨hj₁.1, le_trans hj₁.2 (hitting_le _)⟩, hj₂⟩\n\n"}
{"name":"MeasureTheory.upperCrossingTime_lt_lowerCrossingTime","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN n : Nat\nω : Ω\nhab : LT.lt a b\nhn : Ne (MeasureTheory.lowerCrossingTime a b f N (HAdd.hAdd n 1) ω) N\n⊢ LT.lt (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) ω) (MeasureTheory.lowerCrossingTime a b f N (HAdd.hAdd n 1) ω)","decl":"theorem upperCrossingTime_lt_lowerCrossingTime (hab : a < b)\n    (hn : lowerCrossingTime a b f N (n + 1) ω ≠ N) :\n    upperCrossingTime a b f N (n + 1) ω < lowerCrossingTime a b f N (n + 1) ω := by\n  refine lt_of_le_of_ne upperCrossingTime_le_lowerCrossingTime fun h =>\n    not_le.2 hab <| le_trans ?_ (stoppedValue_lowerCrossingTime hn)\n  simp only [stoppedValue]\n  rw [← h]\n  exact stoppedValue_upperCrossingTime (h.symm ▸ hn)\n\n"}
{"name":"MeasureTheory.lowerCrossingTime_lt_upperCrossingTime","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN n : Nat\nω : Ω\nhab : LT.lt a b\nhn : Ne (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) ω) N\n⊢ LT.lt (MeasureTheory.lowerCrossingTime a b f N n ω) (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) ω)","decl":"theorem lowerCrossingTime_lt_upperCrossingTime (hab : a < b)\n    (hn : upperCrossingTime a b f N (n + 1) ω ≠ N) :\n    lowerCrossingTime a b f N n ω < upperCrossingTime a b f N (n + 1) ω := by\n  refine lt_of_le_of_ne lowerCrossingTime_le_upperCrossingTime_succ fun h =>\n    not_le.2 hab <| le_trans (stoppedValue_upperCrossingTime hn) ?_\n  simp only [stoppedValue]\n  rw [← h]\n  exact stoppedValue_lowerCrossingTime (h.symm ▸ hn)\n\n"}
{"name":"MeasureTheory.upperCrossingTime_lt_succ","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN n : Nat\nω : Ω\nhab : LT.lt a b\nhn : Ne (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) ω) N\n⊢ LT.lt (MeasureTheory.upperCrossingTime a b f N n ω) (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) ω)","decl":"theorem upperCrossingTime_lt_succ (hab : a < b) (hn : upperCrossingTime a b f N (n + 1) ω ≠ N) :\n    upperCrossingTime a b f N n ω < upperCrossingTime a b f N (n + 1) ω :=\n  lt_of_le_of_lt upperCrossingTime_le_lowerCrossingTime\n    (lowerCrossingTime_lt_upperCrossingTime hab hn)\n\n"}
{"name":"MeasureTheory.lowerCrossingTime_stabilize","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN n m : Nat\nω : Ω\nhnm : LE.le n m\nhn : Eq (MeasureTheory.lowerCrossingTime a b f N n ω) N\n⊢ Eq (MeasureTheory.lowerCrossingTime a b f N m ω) N","decl":"theorem lowerCrossingTime_stabilize (hnm : n ≤ m) (hn : lowerCrossingTime a b f N n ω = N) :\n    lowerCrossingTime a b f N m ω = N :=\n  le_antisymm lowerCrossingTime_le (le_trans (le_of_eq hn.symm) (lowerCrossingTime_mono hnm))\n\n"}
{"name":"MeasureTheory.upperCrossingTime_stabilize","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN n m : Nat\nω : Ω\nhnm : LE.le n m\nhn : Eq (MeasureTheory.upperCrossingTime a b f N n ω) N\n⊢ Eq (MeasureTheory.upperCrossingTime a b f N m ω) N","decl":"theorem upperCrossingTime_stabilize (hnm : n ≤ m) (hn : upperCrossingTime a b f N n ω = N) :\n    upperCrossingTime a b f N m ω = N :=\n  le_antisymm upperCrossingTime_le (le_trans (le_of_eq hn.symm) (upperCrossingTime_mono hnm))\n\n"}
{"name":"MeasureTheory.lowerCrossingTime_stabilize'","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN n m : Nat\nω : Ω\nhnm : LE.le n m\nhn : LE.le N (MeasureTheory.lowerCrossingTime a b f N n ω)\n⊢ Eq (MeasureTheory.lowerCrossingTime a b f N m ω) N","decl":"theorem lowerCrossingTime_stabilize' (hnm : n ≤ m) (hn : N ≤ lowerCrossingTime a b f N n ω) :\n    lowerCrossingTime a b f N m ω = N :=\n  lowerCrossingTime_stabilize hnm (le_antisymm lowerCrossingTime_le hn)\n\n"}
{"name":"MeasureTheory.upperCrossingTime_stabilize'","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN n m : Nat\nω : Ω\nhnm : LE.le n m\nhn : LE.le N (MeasureTheory.upperCrossingTime a b f N n ω)\n⊢ Eq (MeasureTheory.upperCrossingTime a b f N m ω) N","decl":"theorem upperCrossingTime_stabilize' (hnm : n ≤ m) (hn : N ≤ upperCrossingTime a b f N n ω) :\n    upperCrossingTime a b f N m ω = N :=\n  upperCrossingTime_stabilize hnm (le_antisymm upperCrossingTime_le hn)\n\n-- `upperCrossingTime_bound_eq` provides an explicit bound\n"}
{"name":"MeasureTheory.exists_upperCrossingTime_eq","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN : Nat\nω : Ω\nhab : LT.lt a b\n⊢ Exists fun n => Eq (MeasureTheory.upperCrossingTime a b f N n ω) N","decl":"theorem exists_upperCrossingTime_eq (f : ℕ → Ω → ℝ) (N : ℕ) (ω : Ω) (hab : a < b) :\n    ∃ n, upperCrossingTime a b f N n ω = N := by\n  by_contra h; push_neg at h\n  have : StrictMono fun n => upperCrossingTime a b f N n ω :=\n    strictMono_nat_of_lt_succ fun n => upperCrossingTime_lt_succ hab (h _)\n  obtain ⟨_, ⟨k, rfl⟩, hk⟩ :\n      ∃ (m : _) (_ : m ∈ Set.range fun n => upperCrossingTime a b f N n ω), N < m :=\n    ⟨upperCrossingTime a b f N (N + 1) ω, ⟨N + 1, rfl⟩,\n      lt_of_lt_of_le N.lt_succ_self (StrictMono.id_le this (N + 1))⟩\n  exact not_le.2 hk upperCrossingTime_le\n\n"}
{"name":"MeasureTheory.upperCrossingTime_lt_bddAbove","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN : Nat\nω : Ω\nhab : LT.lt a b\n⊢ BddAbove (setOf fun n => LT.lt (MeasureTheory.upperCrossingTime a b f N n ω) N)","decl":"theorem upperCrossingTime_lt_bddAbove (hab : a < b) :\n    BddAbove {n | upperCrossingTime a b f N n ω < N} := by\n  obtain ⟨k, hk⟩ := exists_upperCrossingTime_eq f N ω hab\n  refine ⟨k, fun n (hn : upperCrossingTime a b f N n ω < N) => ?_⟩\n  by_contra hn'\n  exact hn.ne (upperCrossingTime_stabilize (not_le.1 hn').le hk)\n\n"}
{"name":"MeasureTheory.upperCrossingTime_lt_nonempty","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN : Nat\nω : Ω\nhN : LT.lt 0 N\n⊢ (setOf fun n => LT.lt (MeasureTheory.upperCrossingTime a b f N n ω) N).Nonempty","decl":"theorem upperCrossingTime_lt_nonempty (hN : 0 < N) :\n    {n | upperCrossingTime a b f N n ω < N}.Nonempty :=\n  ⟨0, hN⟩\n\n"}
{"name":"MeasureTheory.upperCrossingTime_bound_eq","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN : Nat\nω : Ω\nhab : LT.lt a b\n⊢ Eq (MeasureTheory.upperCrossingTime a b f N N ω) N","decl":"theorem upperCrossingTime_bound_eq (f : ℕ → Ω → ℝ) (N : ℕ) (ω : Ω) (hab : a < b) :\n    upperCrossingTime a b f N N ω = N := by\n  by_cases hN' : N < Nat.find (exists_upperCrossingTime_eq f N ω hab)\n  · refine le_antisymm upperCrossingTime_le ?_\n    have hmono : StrictMonoOn (fun n => upperCrossingTime a b f N n ω)\n        (Set.Iic (Nat.find (exists_upperCrossingTime_eq f N ω hab)).pred) := by\n      refine strictMonoOn_Iic_of_lt_succ fun m hm => upperCrossingTime_lt_succ hab ?_\n      rw [Nat.lt_pred_iff] at hm\n      convert Nat.find_min _ hm\n    convert StrictMonoOn.Iic_id_le hmono N (Nat.le_sub_one_of_lt hN')\n  · rw [not_lt] at hN'\n    exact upperCrossingTime_stabilize hN' (Nat.find_spec (exists_upperCrossingTime_eq f N ω hab))\n\n"}
{"name":"MeasureTheory.upperCrossingTime_eq_of_bound_le","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN n : Nat\nω : Ω\nhab : LT.lt a b\nhn : LE.le N n\n⊢ Eq (MeasureTheory.upperCrossingTime a b f N n ω) N","decl":"theorem upperCrossingTime_eq_of_bound_le (hab : a < b) (hn : N ≤ n) :\n    upperCrossingTime a b f N n ω = N :=\n  le_antisymm upperCrossingTime_le\n    (le_trans (upperCrossingTime_bound_eq f N ω hab).symm.le (upperCrossingTime_mono hn))\n\n"}
{"name":"MeasureTheory.Adapted.isStoppingTime_crossing","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\na b : Real\nf : Nat → Ω → Real\nN n : Nat\nℱ : MeasureTheory.Filtration Nat m0\nhf : MeasureTheory.Adapted ℱ f\n⊢ And (MeasureTheory.IsStoppingTime ℱ (MeasureTheory.upperCrossingTime a b f N n)) (MeasureTheory.IsStoppingTime ℱ (MeasureTheory.lowerCrossingTime a b f N n))","decl":"theorem Adapted.isStoppingTime_crossing (hf : Adapted ℱ f) :\n    IsStoppingTime ℱ (upperCrossingTime a b f N n) ∧\n      IsStoppingTime ℱ (lowerCrossingTime a b f N n) := by\n  induction' n with k ih\n  · refine ⟨isStoppingTime_const _ 0, ?_⟩\n    simp [hitting_isStoppingTime hf measurableSet_Iic]\n  · obtain ⟨_, ih₂⟩ := ih\n    have : IsStoppingTime ℱ (upperCrossingTime a b f N (k + 1)) := by\n      intro n\n      simp_rw [upperCrossingTime_succ_eq]\n      exact isStoppingTime_hitting_isStoppingTime ih₂ (fun _ => lowerCrossingTime_le)\n        measurableSet_Ici hf _\n    refine ⟨this, ?_⟩\n    intro n\n    exact isStoppingTime_hitting_isStoppingTime this (fun _ => upperCrossingTime_le)\n      measurableSet_Iic hf _\n\n"}
{"name":"MeasureTheory.Adapted.isStoppingTime_upperCrossingTime","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\na b : Real\nf : Nat → Ω → Real\nN n : Nat\nℱ : MeasureTheory.Filtration Nat m0\nhf : MeasureTheory.Adapted ℱ f\n⊢ MeasureTheory.IsStoppingTime ℱ (MeasureTheory.upperCrossingTime a b f N n)","decl":"theorem Adapted.isStoppingTime_upperCrossingTime (hf : Adapted ℱ f) :\n    IsStoppingTime ℱ (upperCrossingTime a b f N n) :=\n  hf.isStoppingTime_crossing.1\n\n"}
{"name":"MeasureTheory.Adapted.isStoppingTime_lowerCrossingTime","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\na b : Real\nf : Nat → Ω → Real\nN n : Nat\nℱ : MeasureTheory.Filtration Nat m0\nhf : MeasureTheory.Adapted ℱ f\n⊢ MeasureTheory.IsStoppingTime ℱ (MeasureTheory.lowerCrossingTime a b f N n)","decl":"theorem Adapted.isStoppingTime_lowerCrossingTime (hf : Adapted ℱ f) :\n    IsStoppingTime ℱ (lowerCrossingTime a b f N n) :=\n  hf.isStoppingTime_crossing.2\n\n"}
{"name":"MeasureTheory.upcrossingStrat_nonneg","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN n : Nat\nω : Ω\n⊢ LE.le 0 (MeasureTheory.upcrossingStrat a b f N n ω)","decl":"theorem upcrossingStrat_nonneg : 0 ≤ upcrossingStrat a b f N n ω :=\n  Finset.sum_nonneg fun _ _ => Set.indicator_nonneg (fun _ _ => zero_le_one) _\n\n"}
{"name":"MeasureTheory.upcrossingStrat_le_one","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN n : Nat\nω : Ω\n⊢ LE.le (MeasureTheory.upcrossingStrat a b f N n ω) 1","decl":"theorem upcrossingStrat_le_one : upcrossingStrat a b f N n ω ≤ 1 := by\n  rw [upcrossingStrat, ← Finset.indicator_biUnion_apply]\n  · exact Set.indicator_le_self' (fun _ _ => zero_le_one) _\n  intro i _ j _ hij\n  simp only [Set.Ico_disjoint_Ico]\n  obtain hij' | hij' := lt_or_gt_of_ne hij\n  · rw [min_eq_left (upperCrossingTime_mono (Nat.succ_le_succ hij'.le) :\n      upperCrossingTime a b f N _ ω ≤ upperCrossingTime a b f N _ ω),\n      max_eq_right (lowerCrossingTime_mono hij'.le :\n        lowerCrossingTime a b f N _ _ ≤ lowerCrossingTime _ _ _ _ _ _)]\n    refine le_trans upperCrossingTime_le_lowerCrossingTime\n      (lowerCrossingTime_mono (Nat.succ_le_of_lt hij'))\n  · rw [gt_iff_lt] at hij'\n    rw [min_eq_right (upperCrossingTime_mono (Nat.succ_le_succ hij'.le) :\n      upperCrossingTime a b f N _ ω ≤ upperCrossingTime a b f N _ ω),\n      max_eq_left (lowerCrossingTime_mono hij'.le :\n        lowerCrossingTime a b f N _ _ ≤ lowerCrossingTime _ _ _ _ _ _)]\n    refine le_trans upperCrossingTime_le_lowerCrossingTime\n      (lowerCrossingTime_mono (Nat.succ_le_of_lt hij'))\n\n"}
{"name":"MeasureTheory.Adapted.upcrossingStrat_adapted","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\na b : Real\nf : Nat → Ω → Real\nN : Nat\nℱ : MeasureTheory.Filtration Nat m0\nhf : MeasureTheory.Adapted ℱ f\n⊢ MeasureTheory.Adapted ℱ (MeasureTheory.upcrossingStrat a b f N)","decl":"theorem Adapted.upcrossingStrat_adapted (hf : Adapted ℱ f) :\n    Adapted ℱ (upcrossingStrat a b f N) := by\n  intro n\n  change StronglyMeasurable[ℱ n] fun ω =>\n    ∑ k ∈ Finset.range N, ({n | lowerCrossingTime a b f N k ω ≤ n} ∩\n      {n | n < upperCrossingTime a b f N (k + 1) ω}).indicator 1 n\n  refine Finset.stronglyMeasurable_sum _ fun i _ =>\n    stronglyMeasurable_const.indicator ((hf.isStoppingTime_lowerCrossingTime n).inter ?_)\n  simp_rw [← not_le]\n  exact (hf.isStoppingTime_upperCrossingTime n).compl\n\n"}
{"name":"MeasureTheory.Submartingale.sum_upcrossingStrat_mul","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nf : Nat → Ω → Real\nℱ : MeasureTheory.Filtration Nat m0\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Submartingale f ℱ μ\na b : Real\nN : Nat\n⊢ MeasureTheory.Submartingale (fun n => (Finset.range n).sum fun k => HMul.hMul (MeasureTheory.upcrossingStrat a b f N k) (HSub.hSub (f (HAdd.hAdd k 1)) (f k))) ℱ μ","decl":"theorem Submartingale.sum_upcrossingStrat_mul [IsFiniteMeasure μ] (hf : Submartingale f ℱ μ)\n    (a b : ℝ) (N : ℕ) : Submartingale (fun n : ℕ =>\n      ∑ k ∈ Finset.range n, upcrossingStrat a b f N k * (f (k + 1) - f k)) ℱ μ :=\n  hf.sum_mul_sub hf.adapted.upcrossingStrat_adapted (fun _ _ => upcrossingStrat_le_one) fun _ _ =>\n    upcrossingStrat_nonneg\n\n"}
{"name":"MeasureTheory.Submartingale.sum_sub_upcrossingStrat_mul","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nf : Nat → Ω → Real\nℱ : MeasureTheory.Filtration Nat m0\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Submartingale f ℱ μ\na b : Real\nN : Nat\n⊢ MeasureTheory.Submartingale (fun n => (Finset.range n).sum fun k => HMul.hMul (HSub.hSub 1 (MeasureTheory.upcrossingStrat a b f N k)) (HSub.hSub (f (HAdd.hAdd k 1)) (f k))) ℱ μ","decl":"theorem Submartingale.sum_sub_upcrossingStrat_mul [IsFiniteMeasure μ] (hf : Submartingale f ℱ μ)\n    (a b : ℝ) (N : ℕ) : Submartingale (fun n : ℕ =>\n      ∑ k ∈ Finset.range n, (1 - upcrossingStrat a b f N k) * (f (k + 1) - f k)) ℱ μ := by\n  refine hf.sum_mul_sub (fun n => (adapted_const ℱ 1 n).sub (hf.adapted.upcrossingStrat_adapted n))\n    (?_ : ∀ n ω, (1 - upcrossingStrat a b f N n) ω ≤ 1) ?_\n  · exact fun n ω => sub_le_self _ upcrossingStrat_nonneg\n  · intro n ω\n    simp [upcrossingStrat_le_one]\n\n"}
{"name":"MeasureTheory.Submartingale.sum_mul_upcrossingStrat_le","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\na b : Real\nf : Nat → Ω → Real\nN n : Nat\nℱ : MeasureTheory.Filtration Nat m0\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Submartingale f ℱ μ\n⊢ LE.le (MeasureTheory.integral μ fun x => (Finset.range n).sum (fun k => HMul.hMul (MeasureTheory.upcrossingStrat a b f N k) (HSub.hSub (f (HAdd.hAdd k 1)) (f k))) x) (HSub.hSub (MeasureTheory.integral μ fun x => f n x) (MeasureTheory.integral μ fun x => f 0 x))","decl":"theorem Submartingale.sum_mul_upcrossingStrat_le [IsFiniteMeasure μ] (hf : Submartingale f ℱ μ) :\n    μ[∑ k ∈ Finset.range n, upcrossingStrat a b f N k * (f (k + 1) - f k)] ≤ μ[f n] - μ[f 0] := by\n  have h₁ : (0 : ℝ) ≤\n      μ[∑ k ∈ Finset.range n, (1 - upcrossingStrat a b f N k) * (f (k + 1) - f k)] := by\n    have := (hf.sum_sub_upcrossingStrat_mul a b N).setIntegral_le (zero_le n) MeasurableSet.univ\n    rw [setIntegral_univ, setIntegral_univ] at this\n    refine le_trans ?_ this\n    simp only [Finset.range_zero, Finset.sum_empty, integral_zero', le_refl]\n  have h₂ : μ[∑ k ∈ Finset.range n, (1 - upcrossingStrat a b f N k) * (f (k + 1) - f k)] =\n    μ[∑ k ∈ Finset.range n, (f (k + 1) - f k)] -\n      μ[∑ k ∈ Finset.range n, upcrossingStrat a b f N k * (f (k + 1) - f k)] := by\n    simp only [sub_mul, one_mul, Finset.sum_sub_distrib, Pi.sub_apply, Finset.sum_apply,\n      Pi.mul_apply]\n    refine integral_sub (Integrable.sub (integrable_finset_sum _ fun i _ => hf.integrable _)\n      (integrable_finset_sum _ fun i _ => hf.integrable _)) ?_\n    convert (hf.sum_upcrossingStrat_mul a b N).integrable n using 1\n    ext; simp\n  rw [h₂, sub_nonneg] at h₁\n  refine le_trans h₁ ?_\n  simp_rw [Finset.sum_range_sub, integral_sub' (hf.integrable _) (hf.integrable _), le_refl]\n\n"}
{"name":"MeasureTheory.upcrossingsBefore_bot","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nι : Type u_2\ninst✝² : Preorder ι\ninst✝¹ : OrderBot ι\ninst✝ : InfSet ι\na b : Real\nf : ι → Ω → Real\nω : Ω\n⊢ Eq (MeasureTheory.upcrossingsBefore a b f Bot.bot ω) Bot.bot","decl":"@[simp]\ntheorem upcrossingsBefore_bot [Preorder ι] [OrderBot ι] [InfSet ι] {a b : ℝ} {f : ι → Ω → ℝ}\n    {ω : Ω} : upcrossingsBefore a b f ⊥ ω = ⊥ := by simp [upcrossingsBefore]\n\n"}
{"name":"MeasureTheory.upcrossingsBefore_zero","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nω : Ω\n⊢ Eq (MeasureTheory.upcrossingsBefore a b f 0 ω) 0","decl":"theorem upcrossingsBefore_zero : upcrossingsBefore a b f 0 ω = 0 := by simp [upcrossingsBefore]\n\n"}
{"name":"MeasureTheory.upcrossingsBefore_zero'","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\n⊢ Eq (MeasureTheory.upcrossingsBefore a b f 0) 0","decl":"@[simp]\ntheorem upcrossingsBefore_zero' : upcrossingsBefore a b f 0 = 0 := by\n  ext ω; exact upcrossingsBefore_zero\n\n"}
{"name":"MeasureTheory.upperCrossingTime_lt_of_le_upcrossingsBefore","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN n : Nat\nω : Ω\nhN : LT.lt 0 N\nhab : LT.lt a b\nhn : LE.le n (MeasureTheory.upcrossingsBefore a b f N ω)\n⊢ LT.lt (MeasureTheory.upperCrossingTime a b f N n ω) N","decl":"theorem upperCrossingTime_lt_of_le_upcrossingsBefore (hN : 0 < N) (hab : a < b)\n    (hn : n ≤ upcrossingsBefore a b f N ω) : upperCrossingTime a b f N n ω < N :=\n  haveI : upperCrossingTime a b f N (upcrossingsBefore a b f N ω) ω < N :=\n    (upperCrossingTime_lt_nonempty hN).csSup_mem\n      ((OrderBot.bddBelow _).finite_of_bddAbove (upperCrossingTime_lt_bddAbove hab))\n  lt_of_le_of_lt (upperCrossingTime_mono hn) this\n\n"}
{"name":"MeasureTheory.upperCrossingTime_eq_of_upcrossingsBefore_lt","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN n : Nat\nω : Ω\nhab : LT.lt a b\nhn : LT.lt (MeasureTheory.upcrossingsBefore a b f N ω) n\n⊢ Eq (MeasureTheory.upperCrossingTime a b f N n ω) N","decl":"theorem upperCrossingTime_eq_of_upcrossingsBefore_lt (hab : a < b)\n    (hn : upcrossingsBefore a b f N ω < n) : upperCrossingTime a b f N n ω = N := by\n  refine le_antisymm upperCrossingTime_le (not_lt.1 ?_)\n  convert not_mem_of_csSup_lt hn (upperCrossingTime_lt_bddAbove hab) using 1\n\n"}
{"name":"MeasureTheory.upcrossingsBefore_le","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nN : Nat\nf : Nat → Ω → Real\nω : Ω\nhab : LT.lt a b\n⊢ LE.le (MeasureTheory.upcrossingsBefore a b f N ω) N","decl":"theorem upcrossingsBefore_le (f : ℕ → Ω → ℝ) (ω : Ω) (hab : a < b) :\n    upcrossingsBefore a b f N ω ≤ N := by\n  by_cases hN : N = 0\n  · subst hN\n    rw [upcrossingsBefore_zero]\n  · refine csSup_le ⟨0, zero_lt_iff.2 hN⟩ fun n (hn : _ < N) => ?_\n    by_contra hnN\n    exact hn.ne (upperCrossingTime_eq_of_bound_le hab (not_le.1 hnN).le)\n\n"}
{"name":"MeasureTheory.crossing_eq_crossing_of_lowerCrossingTime_lt","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN n : Nat\nω : Ω\nM : Nat\nhNM : LE.le N M\nh : LT.lt (MeasureTheory.lowerCrossingTime a b f N n ω) N\n⊢ And (Eq (MeasureTheory.upperCrossingTime a b f M n ω) (MeasureTheory.upperCrossingTime a b f N n ω)) (Eq (MeasureTheory.lowerCrossingTime a b f M n ω) (MeasureTheory.lowerCrossingTime a b f N n ω))","decl":"theorem crossing_eq_crossing_of_lowerCrossingTime_lt {M : ℕ} (hNM : N ≤ M)\n    (h : lowerCrossingTime a b f N n ω < N) :\n    upperCrossingTime a b f M n ω = upperCrossingTime a b f N n ω ∧\n      lowerCrossingTime a b f M n ω = lowerCrossingTime a b f N n ω := by\n  have h' : upperCrossingTime a b f N n ω < N :=\n    lt_of_le_of_lt upperCrossingTime_le_lowerCrossingTime h\n  induction' n with k ih\n  · simp only [upperCrossingTime_zero, bot_eq_zero', eq_self_iff_true,\n      lowerCrossingTime_zero, true_and, eq_comm]\n    refine hitting_eq_hitting_of_exists hNM ?_\n    rw [lowerCrossingTime, hitting_lt_iff] at h\n    · obtain ⟨j, hj₁, hj₂⟩ := h\n      exact ⟨j, ⟨hj₁.1, hj₁.2.le⟩, hj₂⟩\n    · exact le_rfl\n  · specialize ih (lt_of_le_of_lt (lowerCrossingTime_mono (Nat.le_succ _)) h)\n      (lt_of_le_of_lt (upperCrossingTime_mono (Nat.le_succ _)) h')\n    have : upperCrossingTime a b f M k.succ ω = upperCrossingTime a b f N k.succ ω := by\n      rw [upperCrossingTime_succ_eq, hitting_lt_iff] at h'\n      · simp only [upperCrossingTime_succ_eq]\n        obtain ⟨j, hj₁, hj₂⟩ := h'\n        rw [eq_comm, ih.2]\n        exact hitting_eq_hitting_of_exists hNM ⟨j, ⟨hj₁.1, hj₁.2.le⟩, hj₂⟩\n      · exact le_rfl\n    refine ⟨this, ?_⟩\n    simp only [lowerCrossingTime, eq_comm, this, Nat.succ_eq_add_one]\n    refine hitting_eq_hitting_of_exists hNM ?_\n    rw [lowerCrossingTime, hitting_lt_iff _ le_rfl] at h\n    obtain ⟨j, hj₁, hj₂⟩ := h\n    exact ⟨j, ⟨hj₁.1, hj₁.2.le⟩, hj₂⟩\n\n"}
{"name":"MeasureTheory.crossing_eq_crossing_of_upperCrossingTime_lt","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN n : Nat\nω : Ω\nM : Nat\nhNM : LE.le N M\nh : LT.lt (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) ω) N\n⊢ And (Eq (MeasureTheory.upperCrossingTime a b f M (HAdd.hAdd n 1) ω) (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1) ω)) (Eq (MeasureTheory.lowerCrossingTime a b f M n ω) (MeasureTheory.lowerCrossingTime a b f N n ω))","decl":"theorem crossing_eq_crossing_of_upperCrossingTime_lt {M : ℕ} (hNM : N ≤ M)\n    (h : upperCrossingTime a b f N (n + 1) ω < N) :\n    upperCrossingTime a b f M (n + 1) ω = upperCrossingTime a b f N (n + 1) ω ∧\n      lowerCrossingTime a b f M n ω = lowerCrossingTime a b f N n ω := by\n  have := (crossing_eq_crossing_of_lowerCrossingTime_lt hNM\n    (lt_of_le_of_lt lowerCrossingTime_le_upperCrossingTime_succ h)).2\n  refine ⟨?_, this⟩\n  rw [upperCrossingTime_succ_eq, upperCrossingTime_succ_eq, eq_comm, this]\n  refine hitting_eq_hitting_of_exists hNM ?_\n  rw [upperCrossingTime_succ_eq, hitting_lt_iff] at h\n  · obtain ⟨j, hj₁, hj₂⟩ := h\n    exact ⟨j, ⟨hj₁.1, hj₁.2.le⟩, hj₂⟩\n  · exact le_rfl\n\n"}
{"name":"MeasureTheory.upperCrossingTime_eq_upperCrossingTime_of_lt","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN n : Nat\nω : Ω\nM : Nat\nhNM : LE.le N M\nh : LT.lt (MeasureTheory.upperCrossingTime a b f N n ω) N\n⊢ Eq (MeasureTheory.upperCrossingTime a b f M n ω) (MeasureTheory.upperCrossingTime a b f N n ω)","decl":"theorem upperCrossingTime_eq_upperCrossingTime_of_lt {M : ℕ} (hNM : N ≤ M)\n    (h : upperCrossingTime a b f N n ω < N) :\n    upperCrossingTime a b f M n ω = upperCrossingTime a b f N n ω := by\n  cases n\n  · simp\n  · exact (crossing_eq_crossing_of_upperCrossingTime_lt hNM h).1\n\n"}
{"name":"MeasureTheory.upcrossingsBefore_mono","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nhab : LT.lt a b\n⊢ Monotone fun N ω => MeasureTheory.upcrossingsBefore a b f N ω","decl":"theorem upcrossingsBefore_mono (hab : a < b) : Monotone fun N ω => upcrossingsBefore a b f N ω := by\n  intro N M hNM ω\n  simp only [upcrossingsBefore]\n  by_cases hemp : {n : ℕ | upperCrossingTime a b f N n ω < N}.Nonempty\n  · refine csSup_le_csSup (upperCrossingTime_lt_bddAbove hab) hemp fun n hn => ?_\n    rw [Set.mem_setOf_eq, upperCrossingTime_eq_upperCrossingTime_of_lt hNM hn]\n    exact lt_of_lt_of_le hn hNM\n  · rw [Set.not_nonempty_iff_eq_empty] at hemp\n    simp [hemp, csSup_empty, bot_eq_zero', zero_le']\n\n"}
{"name":"MeasureTheory.upcrossingsBefore_lt_of_exists_upcrossing","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN : Nat\nω : Ω\nhab : LT.lt a b\nN₁ N₂ : Nat\nhN₁ : LE.le N N₁\nhN₁' : LT.lt (f N₁ ω) a\nhN₂ : LE.le N₁ N₂\nhN₂' : LT.lt b (f N₂ ω)\n⊢ LT.lt (MeasureTheory.upcrossingsBefore a b f N ω) (MeasureTheory.upcrossingsBefore a b f (HAdd.hAdd N₂ 1) ω)","decl":"theorem upcrossingsBefore_lt_of_exists_upcrossing (hab : a < b) {N₁ N₂ : ℕ} (hN₁ : N ≤ N₁)\n    (hN₁' : f N₁ ω < a) (hN₂ : N₁ ≤ N₂) (hN₂' : b < f N₂ ω) :\n    upcrossingsBefore a b f N ω < upcrossingsBefore a b f (N₂ + 1) ω := by\n  refine lt_of_lt_of_le (Nat.lt_succ_self _) (le_csSup (upperCrossingTime_lt_bddAbove hab) ?_)\n  rw [Set.mem_setOf_eq, upperCrossingTime_succ_eq, hitting_lt_iff _ le_rfl]\n  refine ⟨N₂, ⟨?_, Nat.lt_succ_self _⟩, hN₂'.le⟩\n  rw [lowerCrossingTime, hitting_le_iff_of_lt _ (Nat.lt_succ_self _)]\n  refine ⟨N₁, ⟨le_trans ?_ hN₁, hN₂⟩, hN₁'.le⟩\n  by_cases hN : 0 < N\n  · have : upperCrossingTime a b f N (upcrossingsBefore a b f N ω) ω < N :=\n      Nat.sSup_mem (upperCrossingTime_lt_nonempty hN) (upperCrossingTime_lt_bddAbove hab)\n    rw [upperCrossingTime_eq_upperCrossingTime_of_lt (hN₁.trans (hN₂.trans <| Nat.le_succ _))\n      this]\n    exact this.le\n  · rw [not_lt, Nat.le_zero] at hN\n    rw [hN, upcrossingsBefore_zero, upperCrossingTime_zero, Pi.bot_apply, bot_eq_zero']\n\n"}
{"name":"MeasureTheory.lowerCrossingTime_lt_of_lt_upcrossingsBefore","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN n : Nat\nω : Ω\nhN : LT.lt 0 N\nhab : LT.lt a b\nhn : LT.lt n (MeasureTheory.upcrossingsBefore a b f N ω)\n⊢ LT.lt (MeasureTheory.lowerCrossingTime a b f N n ω) N","decl":"theorem lowerCrossingTime_lt_of_lt_upcrossingsBefore (hN : 0 < N) (hab : a < b)\n    (hn : n < upcrossingsBefore a b f N ω) : lowerCrossingTime a b f N n ω < N :=\n  lt_of_le_of_lt lowerCrossingTime_le_upperCrossingTime_succ\n    (upperCrossingTime_lt_of_le_upcrossingsBefore hN hab hn)\n\n"}
{"name":"MeasureTheory.le_sub_of_le_upcrossingsBefore","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN n : Nat\nω : Ω\nhN : LT.lt 0 N\nhab : LT.lt a b\nhn : LT.lt n (MeasureTheory.upcrossingsBefore a b f N ω)\n⊢ LE.le (HSub.hSub b a) (HSub.hSub (MeasureTheory.stoppedValue f (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1)) ω) (MeasureTheory.stoppedValue f (MeasureTheory.lowerCrossingTime a b f N n) ω))","decl":"theorem le_sub_of_le_upcrossingsBefore (hN : 0 < N) (hab : a < b)\n    (hn : n < upcrossingsBefore a b f N ω) :\n    b - a ≤ stoppedValue f (upperCrossingTime a b f N (n + 1)) ω -\n      stoppedValue f (lowerCrossingTime a b f N n) ω :=\n  sub_le_sub\n    (stoppedValue_upperCrossingTime (upperCrossingTime_lt_of_le_upcrossingsBefore hN hab hn).ne)\n    (stoppedValue_lowerCrossingTime (lowerCrossingTime_lt_of_lt_upcrossingsBefore hN hab hn).ne)\n\n"}
{"name":"MeasureTheory.sub_eq_zero_of_upcrossingsBefore_lt","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN n : Nat\nω : Ω\nhab : LT.lt a b\nhn : LT.lt (MeasureTheory.upcrossingsBefore a b f N ω) n\n⊢ Eq (HSub.hSub (MeasureTheory.stoppedValue f (MeasureTheory.upperCrossingTime a b f N (HAdd.hAdd n 1)) ω) (MeasureTheory.stoppedValue f (MeasureTheory.lowerCrossingTime a b f N n) ω)) 0","decl":"theorem sub_eq_zero_of_upcrossingsBefore_lt (hab : a < b) (hn : upcrossingsBefore a b f N ω < n) :\n    stoppedValue f (upperCrossingTime a b f N (n + 1)) ω -\n      stoppedValue f (lowerCrossingTime a b f N n) ω = 0 := by\n  have : N ≤ upperCrossingTime a b f N n ω := by\n    rw [upcrossingsBefore] at hn\n    rw [← not_lt]\n    exact fun h => not_le.2 hn (le_csSup (upperCrossingTime_lt_bddAbove hab) h)\n  simp [stoppedValue, upperCrossingTime_stabilize' (Nat.le_succ n) this,\n    lowerCrossingTime_stabilize' le_rfl (le_trans this upperCrossingTime_le_lowerCrossingTime)]\n\n"}
{"name":"MeasureTheory.mul_upcrossingsBefore_le","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN : Nat\nω : Ω\nhf : LE.le a (f N ω)\nhab : LT.lt a b\n⊢ LE.le (HMul.hMul (HSub.hSub b a) ↑(MeasureTheory.upcrossingsBefore a b f N ω)) ((Finset.range N).sum fun k => HMul.hMul (MeasureTheory.upcrossingStrat a b f N k ω) (HSub.hSub (f (HAdd.hAdd k 1)) (f k) ω))","decl":"theorem mul_upcrossingsBefore_le (hf : a ≤ f N ω) (hab : a < b) :\n    (b - a) * upcrossingsBefore a b f N ω ≤\n    ∑ k ∈ Finset.range N, upcrossingStrat a b f N k ω * (f (k + 1) - f k) ω := by\n  classical\n  by_cases hN : N = 0\n  · simp [hN]\n  simp_rw [upcrossingStrat, Finset.sum_mul, ←\n    Set.indicator_mul_left _ _ (fun x ↦ (f (x + 1) - f x) ω), Pi.one_apply, Pi.sub_apply, one_mul]\n  rw [Finset.sum_comm]\n  have h₁ : ∀ k, ∑ n ∈ Finset.range N, (Set.Ico (lowerCrossingTime a b f N k ω)\n      (upperCrossingTime a b f N (k + 1) ω)).indicator (fun m => f (m + 1) ω - f m ω) n =\n      stoppedValue f (upperCrossingTime a b f N (k + 1)) ω -\n        stoppedValue f (lowerCrossingTime a b f N k) ω := by\n    intro k\n    rw [Finset.sum_indicator_eq_sum_filter, (_ : Finset.filter (fun i => i ∈ Set.Ico\n      (lowerCrossingTime a b f N k ω) (upperCrossingTime a b f N (k + 1) ω)) (Finset.range N) =\n      Finset.Ico (lowerCrossingTime a b f N k ω) (upperCrossingTime a b f N (k + 1) ω)),\n      Finset.sum_Ico_eq_add_neg _ lowerCrossingTime_le_upperCrossingTime_succ,\n      Finset.sum_range_sub fun n => f n ω, Finset.sum_range_sub fun n => f n ω, neg_sub,\n      sub_add_sub_cancel]\n    · rfl\n    · ext i\n      simp only [Set.mem_Ico, Finset.mem_filter, Finset.mem_range, Finset.mem_Ico,\n        and_iff_right_iff_imp, and_imp]\n      exact fun _ h => lt_of_lt_of_le h upperCrossingTime_le\n  simp_rw [h₁]\n  have h₂ : ∑ _k ∈ Finset.range (upcrossingsBefore a b f N ω), (b - a) ≤\n      ∑ k ∈ Finset.range N, (stoppedValue f (upperCrossingTime a b f N (k + 1)) ω -\n        stoppedValue f (lowerCrossingTime a b f N k) ω) := by\n    calc\n      ∑ _k ∈ Finset.range (upcrossingsBefore a b f N ω), (b - a) ≤\n          ∑ k ∈ Finset.range (upcrossingsBefore a b f N ω),\n            (stoppedValue f (upperCrossingTime a b f N (k + 1)) ω -\n              stoppedValue f (lowerCrossingTime a b f N k) ω) := by\n        refine Finset.sum_le_sum fun i hi =>\n          le_sub_of_le_upcrossingsBefore (zero_lt_iff.2 hN) hab ?_\n        rwa [Finset.mem_range] at hi\n      _ ≤ ∑ k ∈ Finset.range N, (stoppedValue f (upperCrossingTime a b f N (k + 1)) ω -\n          stoppedValue f (lowerCrossingTime a b f N k) ω) := by\n        refine Finset.sum_le_sum_of_subset_of_nonneg\n          (Finset.range_subset.2 (upcrossingsBefore_le f ω hab)) fun i _ hi => ?_\n        by_cases hi' : i = upcrossingsBefore a b f N ω\n        · subst hi'\n          simp only [stoppedValue]\n          rw [upperCrossingTime_eq_of_upcrossingsBefore_lt hab (Nat.lt_succ_self _)]\n          by_cases heq : lowerCrossingTime a b f N (upcrossingsBefore a b f N ω) ω = N\n          · rw [heq, sub_self]\n          · rw [sub_nonneg]\n            exact le_trans (stoppedValue_lowerCrossingTime heq) hf\n        · rw [sub_eq_zero_of_upcrossingsBefore_lt hab]\n          rw [Finset.mem_range, not_lt] at hi\n          exact lt_of_le_of_ne hi (Ne.symm hi')\n  refine le_trans ?_ h₂\n  rw [Finset.sum_const, Finset.card_range, nsmul_eq_mul, mul_comm]\n\n"}
{"name":"MeasureTheory.integral_mul_upcrossingsBefore_le_integral","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\na b : Real\nf : Nat → Ω → Real\nN : Nat\nℱ : MeasureTheory.Filtration Nat m0\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Submartingale f ℱ μ\nhfN : ∀ (ω : Ω), LE.le a (f N ω)\nhfzero : LE.le 0 (f 0)\nhab : LT.lt a b\n⊢ LE.le (HMul.hMul (HSub.hSub b a) (MeasureTheory.integral μ fun x => ↑(MeasureTheory.upcrossingsBefore a b f N x))) (MeasureTheory.integral μ fun x => f N x)","decl":"theorem integral_mul_upcrossingsBefore_le_integral [IsFiniteMeasure μ] (hf : Submartingale f ℱ μ)\n    (hfN : ∀ ω, a ≤ f N ω) (hfzero : 0 ≤ f 0) (hab : a < b) :\n    (b - a) * μ[upcrossingsBefore a b f N] ≤ μ[f N] :=\n  calc\n    (b - a) * μ[upcrossingsBefore a b f N] ≤\n        μ[∑ k ∈ Finset.range N, upcrossingStrat a b f N k * (f (k + 1) - f k)] := by\n      rw [← integral_mul_left]\n      refine integral_mono_of_nonneg ?_ ((hf.sum_upcrossingStrat_mul a b N).integrable N) ?_\n      · exact Eventually.of_forall fun ω => mul_nonneg (sub_nonneg.2 hab.le) (Nat.cast_nonneg _)\n      · filter_upwards with ω\n        simpa using mul_upcrossingsBefore_le (hfN ω) hab\n    _ ≤ μ[f N] - μ[f 0] := hf.sum_mul_upcrossingStrat_le\n    _ ≤ μ[f N] := (sub_le_self_iff _).2 (integral_nonneg hfzero)\n\n"}
{"name":"MeasureTheory.crossing_pos_eq","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN n : Nat\nhab : LT.lt a b\n⊢ And (Eq (MeasureTheory.upperCrossingTime 0 (HSub.hSub b a) (fun n ω => PosPart.posPart (HSub.hSub (f n ω) a)) N n) (MeasureTheory.upperCrossingTime a b f N n)) (Eq (MeasureTheory.lowerCrossingTime 0 (HSub.hSub b a) (fun n ω => PosPart.posPart (HSub.hSub (f n ω) a)) N n) (MeasureTheory.lowerCrossingTime a b f N n))","decl":"theorem crossing_pos_eq (hab : a < b) :\n    upperCrossingTime 0 (b - a) (fun n ω => (f n ω - a)⁺) N n = upperCrossingTime a b f N n ∧\n      lowerCrossingTime 0 (b - a) (fun n ω => (f n ω - a)⁺) N n = lowerCrossingTime a b f N n := by\n  have hab' : 0 < b - a := sub_pos.2 hab\n  have hf : ∀ ω i, b - a ≤ (f i ω - a)⁺ ↔ b ≤ f i ω := by\n    intro i ω\n    refine ⟨fun h => ?_, fun h => ?_⟩\n    · rwa [← sub_le_sub_iff_right a, ←\n        posPart_eq_of_posPart_pos (lt_of_lt_of_le hab' h)]\n    · rw [← sub_le_sub_iff_right a] at h\n      rwa [posPart_eq_self.2 (le_trans hab'.le h)]\n  have hf' (ω i) : (f i ω - a)⁺ ≤ 0 ↔ f i ω ≤ a := by rw [posPart_nonpos, sub_nonpos]\n  induction' n with k ih\n  · refine ⟨rfl, ?_⟩\n    simp (config := { unfoldPartialApp := true }) only [lowerCrossingTime_zero, hitting,\n      Set.mem_Icc, Set.mem_Iic]\n    ext ω\n    split_ifs with h₁ h₂ h₂\n    · simp_rw [hf']\n    · simp_rw [Set.mem_Iic, ← hf' _ _] at h₂\n      exact False.elim (h₂ h₁)\n    · simp_rw [Set.mem_Iic, hf' _ _] at h₁\n      exact False.elim (h₁ h₂)\n    · rfl\n  · have : upperCrossingTime 0 (b - a) (fun n ω => (f n ω - a)⁺) N (k + 1) =\n        upperCrossingTime a b f N (k + 1) := by\n      ext ω\n      simp only [upperCrossingTime_succ_eq, ← ih.2, hitting, Set.mem_Ici, tsub_le_iff_right]\n      split_ifs with h₁ h₂ h₂\n      · simp_rw [← sub_le_iff_le_add, hf ω]\n      · refine False.elim (h₂ ?_)\n        simp_all only [Set.mem_Ici, not_true_eq_false]\n      · refine False.elim (h₁ ?_)\n        simp_all only [Set.mem_Ici]\n      · rfl\n    refine ⟨this, ?_⟩\n    ext ω\n    simp only [lowerCrossingTime, this, hitting, Set.mem_Iic]\n    split_ifs with h₁ h₂ h₂\n    · simp_rw [hf' ω]\n    · refine False.elim (h₂ ?_)\n      simp_all only [Set.mem_Iic, not_true_eq_false]\n    · refine False.elim (h₁ ?_)\n      simp_all only [Set.mem_Iic]\n    · rfl\n\n"}
{"name":"MeasureTheory.upcrossingsBefore_pos_eq","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN : Nat\nω : Ω\nhab : LT.lt a b\n⊢ Eq (MeasureTheory.upcrossingsBefore 0 (HSub.hSub b a) (fun n ω => PosPart.posPart (HSub.hSub (f n ω) a)) N ω) (MeasureTheory.upcrossingsBefore a b f N ω)","decl":"theorem upcrossingsBefore_pos_eq (hab : a < b) :\n    upcrossingsBefore 0 (b - a) (fun n ω => (f n ω - a)⁺) N ω = upcrossingsBefore a b f N ω := by\n  simp_rw [upcrossingsBefore, (crossing_pos_eq hab).1]\n\n"}
{"name":"MeasureTheory.mul_integral_upcrossingsBefore_le_integral_pos_part_aux","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\na b : Real\nf : Nat → Ω → Real\nN : Nat\nℱ : MeasureTheory.Filtration Nat m0\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Submartingale f ℱ μ\nhab : LT.lt a b\n⊢ LE.le (HMul.hMul (HSub.hSub b a) (MeasureTheory.integral μ fun x => ↑(MeasureTheory.upcrossingsBefore a b f N x))) (MeasureTheory.integral μ fun x => (fun ω => PosPart.posPart (HSub.hSub (f N ω) a)) x)","decl":"theorem mul_integral_upcrossingsBefore_le_integral_pos_part_aux [IsFiniteMeasure μ]\n    (hf : Submartingale f ℱ μ) (hab : a < b) :\n    (b - a) * μ[upcrossingsBefore a b f N] ≤ μ[fun ω => (f N ω - a)⁺] := by\n  refine le_trans (le_of_eq ?_)\n    (integral_mul_upcrossingsBefore_le_integral (hf.sub_martingale (martingale_const _ _ _)).pos\n      (fun ω => posPart_nonneg _)\n      (fun ω => posPart_nonneg _) (sub_pos.2 hab))\n  simp_rw [sub_zero, ← upcrossingsBefore_pos_eq hab]\n  rfl\n\n"}
{"name":"MeasureTheory.Submartingale.mul_integral_upcrossingsBefore_le_integral_pos_part","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nf : Nat → Ω → Real\nℱ : MeasureTheory.Filtration Nat m0\ninst✝ : MeasureTheory.IsFiniteMeasure μ\na b : Real\nhf : MeasureTheory.Submartingale f ℱ μ\nN : Nat\n⊢ LE.le (HMul.hMul (HSub.hSub b a) (MeasureTheory.integral μ fun x => ↑(MeasureTheory.upcrossingsBefore a b f N x))) (MeasureTheory.integral μ fun x => (fun ω => PosPart.posPart (HSub.hSub (f N ω) a)) x)","decl":"/-- **Doob's upcrossing estimate**: given a real valued discrete submartingale `f` and real\nvalues `a` and `b`, we have `(b - a) * 𝔼[upcrossingsBefore a b f N] ≤ 𝔼[(f N - a)⁺]` where\n`upcrossingsBefore a b f N` is the number of times the process `f` crossed from below `a` to above\n`b` before the time `N`. -/\ntheorem Submartingale.mul_integral_upcrossingsBefore_le_integral_pos_part [IsFiniteMeasure μ]\n    (a b : ℝ) (hf : Submartingale f ℱ μ) (N : ℕ) :\n    (b - a) * μ[upcrossingsBefore a b f N] ≤ μ[fun ω => (f N ω - a)⁺] := by\n  by_cases hab : a < b\n  · exact mul_integral_upcrossingsBefore_le_integral_pos_part_aux hf hab\n  · rw [not_lt, ← sub_nonpos] at hab\n    exact le_trans (mul_nonpos_of_nonpos_of_nonneg hab (by positivity))\n      (integral_nonneg fun ω => posPart_nonneg _)\n\n"}
{"name":"MeasureTheory.upcrossingsBefore_eq_sum","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nN : Nat\nω : Ω\nhab : LT.lt a b\n⊢ Eq (MeasureTheory.upcrossingsBefore a b f N ω) ((Finset.Ico 1 (HAdd.hAdd N 1)).sum fun i => (setOf fun n => LT.lt (MeasureTheory.upperCrossingTime a b f N n ω) N).indicator 1 i)","decl":"theorem upcrossingsBefore_eq_sum (hab : a < b) : upcrossingsBefore a b f N ω =\n    ∑ i ∈ Finset.Ico 1 (N + 1), {n | upperCrossingTime a b f N n ω < N}.indicator 1 i := by\n  by_cases hN : N = 0\n  · simp [hN]\n  rw [← Finset.sum_Ico_consecutive _ (Nat.succ_le_succ zero_le')\n    (Nat.succ_le_succ (upcrossingsBefore_le f ω hab))]\n  have h₁ : ∀ k ∈ Finset.Ico 1 (upcrossingsBefore a b f N ω + 1),\n      {n : ℕ | upperCrossingTime a b f N n ω < N}.indicator 1 k = 1 := by\n    rintro k hk\n    rw [Finset.mem_Ico] at hk\n    rw [Set.indicator_of_mem]\n    · rfl\n    · exact upperCrossingTime_lt_of_le_upcrossingsBefore (zero_lt_iff.2 hN) hab\n        (Nat.lt_succ_iff.1 hk.2)\n  have h₂ : ∀ k ∈ Finset.Ico (upcrossingsBefore a b f N ω + 1) (N + 1),\n      {n : ℕ | upperCrossingTime a b f N n ω < N}.indicator 1 k = 0 := by\n    rintro k hk\n    rw [Finset.mem_Ico, Nat.succ_le_iff] at hk\n    rw [Set.indicator_of_not_mem]\n    simp only [Set.mem_setOf_eq, not_lt]\n    exact (upperCrossingTime_eq_of_upcrossingsBefore_lt hab hk.1).symm.le\n  rw [Finset.sum_congr rfl h₁, Finset.sum_congr rfl h₂, Finset.sum_const, Finset.sum_const,\n    smul_eq_mul, mul_one, smul_eq_mul, mul_zero, Nat.card_Ico, Nat.add_succ_sub_one,\n    add_zero, add_zero]\n\n"}
{"name":"MeasureTheory.Adapted.measurable_upcrossingsBefore","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\na b : Real\nf : Nat → Ω → Real\nN : Nat\nℱ : MeasureTheory.Filtration Nat m0\nhf : MeasureTheory.Adapted ℱ f\nhab : LT.lt a b\n⊢ Measurable (MeasureTheory.upcrossingsBefore a b f N)","decl":"theorem Adapted.measurable_upcrossingsBefore (hf : Adapted ℱ f) (hab : a < b) :\n    Measurable (upcrossingsBefore a b f N) := by\n  have : upcrossingsBefore a b f N = fun ω =>\n      ∑ i ∈ Finset.Ico 1 (N + 1), {n | upperCrossingTime a b f N n ω < N}.indicator 1 i := by\n    ext ω\n    exact upcrossingsBefore_eq_sum hab\n  rw [this]\n  exact Finset.measurable_sum _ fun i _ => Measurable.indicator measurable_const <|\n    ℱ.le N _ (hf.isStoppingTime_upperCrossingTime.measurableSet_lt_of_pred N)\n\n"}
{"name":"MeasureTheory.Adapted.integrable_upcrossingsBefore","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\na b : Real\nf : Nat → Ω → Real\nN : Nat\nℱ : MeasureTheory.Filtration Nat m0\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Adapted ℱ f\nhab : LT.lt a b\n⊢ MeasureTheory.Integrable (fun ω => ↑(MeasureTheory.upcrossingsBefore a b f N ω)) μ","decl":"theorem Adapted.integrable_upcrossingsBefore [IsFiniteMeasure μ] (hf : Adapted ℱ f) (hab : a < b) :\n    Integrable (fun ω => (upcrossingsBefore a b f N ω : ℝ)) μ :=\n  haveI : ∀ᵐ ω ∂μ, ‖(upcrossingsBefore a b f N ω : ℝ)‖ ≤ N := by\n    filter_upwards with ω\n    rw [Real.norm_eq_abs, Nat.abs_cast, Nat.cast_le]\n    exact upcrossingsBefore_le _ _ hab\n  ⟨Measurable.aestronglyMeasurable (measurable_from_top.comp (hf.measurable_upcrossingsBefore hab)),\n    hasFiniteIntegral_of_bounded this⟩\n\n"}
{"name":"MeasureTheory.Adapted.measurable_upcrossings","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\na b : Real\nf : Nat → Ω → Real\nℱ : MeasureTheory.Filtration Nat m0\nhf : MeasureTheory.Adapted ℱ f\nhab : LT.lt a b\n⊢ Measurable (MeasureTheory.upcrossings a b f)","decl":"theorem Adapted.measurable_upcrossings (hf : Adapted ℱ f) (hab : a < b) :\n    Measurable (upcrossings a b f) :=\n  .iSup fun _ => measurable_from_top.comp (hf.measurable_upcrossingsBefore hab)\n\n"}
{"name":"MeasureTheory.upcrossings_lt_top_iff","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nω : Ω\n⊢ Iff (LT.lt (MeasureTheory.upcrossings a b f ω) Top.top) (Exists fun k => ∀ (N : Nat), LE.le (MeasureTheory.upcrossingsBefore a b f N ω) k)","decl":"theorem upcrossings_lt_top_iff :\n    upcrossings a b f ω < ∞ ↔ ∃ k, ∀ N, upcrossingsBefore a b f N ω ≤ k := by\n  have : upcrossings a b f ω < ∞ ↔ ∃ k : ℝ≥0, upcrossings a b f ω ≤ k := by\n    constructor\n    · intro h\n      lift upcrossings a b f ω to ℝ≥0 using h.ne with r hr\n      exact ⟨r, le_rfl⟩\n    · rintro ⟨k, hk⟩\n      exact lt_of_le_of_lt hk ENNReal.coe_lt_top\n  simp_rw [this, upcrossings, iSup_le_iff]\n  constructor <;> rintro ⟨k, hk⟩\n  · obtain ⟨m, hm⟩ := exists_nat_ge k\n    refine ⟨m, fun N => Nat.cast_le.1 ((hk N).trans ?_)⟩\n    rwa [← ENNReal.coe_natCast, ENNReal.coe_le_coe]\n  · refine ⟨k, fun N => ?_⟩\n    simp only [ENNReal.coe_natCast, Nat.cast_le, hk N]\n\n"}
{"name":"MeasureTheory.Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part","module":"Mathlib.Probability.Martingale.Upcrossing","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nf : Nat → Ω → Real\nℱ : MeasureTheory.Filtration Nat m0\ninst✝ : MeasureTheory.IsFiniteMeasure μ\na b : Real\nhf : MeasureTheory.Submartingale f ℱ μ\n⊢ LE.le (HMul.hMul (ENNReal.ofReal (HSub.hSub b a)) (MeasureTheory.lintegral μ fun ω => MeasureTheory.upcrossings a b f ω)) (iSup fun N => MeasureTheory.lintegral μ fun ω => ENNReal.ofReal (PosPart.posPart (HSub.hSub (f N ω) a)))","decl":"/-- A variant of Doob's upcrossing estimate obtained by taking the supremum on both sides. -/\ntheorem Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part [IsFiniteMeasure μ] (a b : ℝ)\n    (hf : Submartingale f ℱ μ) : ENNReal.ofReal (b - a) * ∫⁻ ω, upcrossings a b f ω ∂μ ≤\n      ⨆ N, ∫⁻ ω, ENNReal.ofReal ((f N ω - a)⁺) ∂μ := by\n  by_cases hab : a < b\n  · simp_rw [upcrossings]\n    have : ∀ N, ∫⁻ ω, ENNReal.ofReal ((f N ω - a)⁺) ∂μ = ENNReal.ofReal (∫ ω, (f N ω - a)⁺ ∂μ) := by\n      intro N\n      rw [ofReal_integral_eq_lintegral_ofReal]\n      · exact (hf.sub_martingale (martingale_const _ _ _)).pos.integrable _\n      · exact Eventually.of_forall fun ω => posPart_nonneg _\n    rw [lintegral_iSup']\n    · simp_rw [this, ENNReal.mul_iSup, iSup_le_iff]\n      intro N\n      rw [(by simp :\n          ∫⁻ ω, upcrossingsBefore a b f N ω ∂μ = ∫⁻ ω, ↑(upcrossingsBefore a b f N ω : ℝ≥0) ∂μ),\n        lintegral_coe_eq_integral, ← ENNReal.ofReal_mul (sub_pos.2 hab).le]\n      · simp_rw [NNReal.coe_natCast]\n        exact (ENNReal.ofReal_le_ofReal\n          (hf.mul_integral_upcrossingsBefore_le_integral_pos_part a b N)).trans\n            (le_iSup (α := ℝ≥0∞) _ N)\n      · simp only [NNReal.coe_natCast, hf.adapted.integrable_upcrossingsBefore hab]\n    · exact fun n => measurable_from_top.comp_aemeasurable\n        (hf.adapted.measurable_upcrossingsBefore hab).aemeasurable\n    · filter_upwards with ω N M hNM\n      rw [Nat.cast_le]\n      exact upcrossingsBefore_mono hab hNM ω\n  · rw [not_lt, ← sub_nonpos] at hab\n    rw [ENNReal.ofReal_of_nonpos hab, zero_mul]\n    exact zero_le _\n\n"}
