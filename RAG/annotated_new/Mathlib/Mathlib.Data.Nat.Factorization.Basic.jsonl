{"name":"Nat.factorization_eq_zero_of_lt","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\nh : LT.lt n p\n⊢ Eq (n.factorization p) 0","decl":"theorem factorization_eq_zero_of_lt {n p : ℕ} (h : n < p) : n.factorization p = 0 :=\n  Finsupp.not_mem_support_iff.mp (mt le_of_mem_primeFactors (not_le_of_lt h))\n\n"}
{"name":"Nat.factorization_one_right","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n : Nat\n⊢ Eq (n.factorization 1) 0","decl":"@[simp]\ntheorem factorization_one_right (n : ℕ) : n.factorization 1 = 0 :=\n  factorization_eq_zero_of_non_prime _ not_prime_one\n\n"}
{"name":"Nat.dvd_of_factorization_pos","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\nhn : Ne (n.factorization p) 0\n⊢ Dvd.dvd p n","decl":"theorem dvd_of_factorization_pos {n p : ℕ} (hn : n.factorization p ≠ 0) : p ∣ n :=\n  dvd_of_mem_primeFactorsList <| mem_primeFactors_iff_mem_primeFactorsList.1 <| mem_support_iff.2 hn\n\n"}
{"name":"Nat.factorization_eq_zero_iff_remainder","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"p r i : Nat\npp : Nat.Prime p\nhr0 : Ne r 0\n⊢ Iff (Not (Dvd.dvd p r)) (Eq ((HAdd.hAdd (HMul.hMul p i) r).factorization p) 0)","decl":"theorem factorization_eq_zero_iff_remainder {p r : ℕ} (i : ℕ) (pp : p.Prime) (hr0 : r ≠ 0) :\n    ¬p ∣ r ↔ (p * i + r).factorization p = 0 := by\n  refine ⟨factorization_eq_zero_of_remainder i, fun h => ?_⟩\n  rw [factorization_eq_zero_iff] at h\n  contrapose! h\n  refine ⟨pp, ?_, ?_⟩\n  · rwa [← Nat.dvd_add_iff_right (dvd_mul_right p i)]\n  · contrapose! hr0\n    exact (add_eq_zero.1 hr0).2\n\n"}
{"name":"Nat.factorization_eq_zero_iff'","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n : Nat\n⊢ Iff (Eq n.factorization 0) (Or (Eq n 0) (Eq n 1))","decl":"/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem factorization_eq_zero_iff' (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1 := by\n  rw [factorization_eq_primeFactorsList_multiset n]\n  simp [factorization, AddEquiv.map_eq_zero_iff, Multiset.coe_eq_zero]\n\n"}
{"name":"Nat.prod_factorization_eq_prod_primeFactors","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n : Nat\nβ : Type u_1\ninst✝ : CommMonoid β\nf : Nat → Nat → β\n⊢ Eq (n.factorization.prod f) (n.primeFactors.prod fun p => f p (n.factorization p))","decl":"/-- A product over `n.factorization` can be written as a product over `n.primeFactors`; -/\nlemma prod_factorization_eq_prod_primeFactors {β : Type*} [CommMonoid β] (f : ℕ → ℕ → β) :\n    n.factorization.prod f = ∏ p ∈ n.primeFactors, f p (n.factorization p) := rfl\n\n"}
{"name":"Nat.prod_primeFactors_prod_factorization","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n : Nat\nβ : Type u_1\ninst✝ : CommMonoid β\nf : Nat → β\n⊢ Eq (n.primeFactors.prod fun p => f p) (n.factorization.prod fun p x => f p)","decl":"/-- A product over `n.primeFactors` can be written as a product over `n.factorization`; -/\nlemma prod_primeFactors_prod_factorization {β : Type*} [CommMonoid β] (f : ℕ → β) :\n    ∏ p ∈ n.primeFactors, f p = n.factorization.prod (fun p _ ↦ f p) := rfl\n\n"}
{"name":"Nat.Prime.factorization_self","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"p : Nat\nhp : Nat.Prime p\n⊢ Eq (p.factorization p) 1","decl":"/-- The multiplicity of prime `p` in `p` is `1` -/\n@[simp]\ntheorem Prime.factorization_self {p : ℕ} (hp : Prime p) : p.factorization p = 1 := by simp [hp]\n\n"}
{"name":"Nat.eq_pow_of_factorization_eq_single","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p k : Nat\nhn : Ne n 0\nh : Eq n.factorization (Finsupp.single p k)\n⊢ Eq n (HPow.hPow p k)","decl":"/-- If the factorization of `n` contains just one number `p` then `n` is a power of `p` -/\ntheorem eq_pow_of_factorization_eq_single {n p k : ℕ} (hn : n ≠ 0)\n    (h : n.factorization = Finsupp.single p k) : n = p ^ k := by\n  -- Porting note: explicitly added `Finsupp.prod_single_index`\n  rw [← Nat.factorization_prod_pow_eq_self hn, h, Finsupp.prod_single_index]\n  simp\n\n"}
{"name":"Nat.Prime.eq_of_factorization_pos","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"p q : Nat\nhp : Nat.Prime p\nh : Ne (p.factorization q) 0\n⊢ Eq p q","decl":"/-- The only prime factor of prime `p` is `p` itself. -/\ntheorem Prime.eq_of_factorization_pos {p q : ℕ} (hp : Prime p) (h : p.factorization q ≠ 0) :\n    p = q := by simpa [hp.factorization, single_apply] using h\n\n"}
{"name":"Nat.eq_factorization_iff","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n : Nat\nf : Finsupp Nat Nat\nhn : Ne n 0\nhf : ∀ (p : Nat), Membership.mem f.support p → Nat.Prime p\n⊢ Iff (Eq f n.factorization) (Eq (f.prod fun x1 x2 => HPow.hPow x1 x2) n)","decl":"theorem eq_factorization_iff {n : ℕ} {f : ℕ →₀ ℕ} (hn : n ≠ 0) (hf : ∀ p ∈ f.support, Prime p) :\n    f = n.factorization ↔ f.prod (· ^ ·) = n :=\n  ⟨fun h => by rw [h, factorization_prod_pow_eq_self hn], fun h => by\n    rw [← h, prod_pow_factorization_eq_self hf]⟩\n\n"}
{"name":"Nat.factorizationEquiv_inv_apply","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"f : Finsupp Nat Nat\nhf : ∀ (p : Nat), Membership.mem f.support p → Nat.Prime p\n⊢ Eq (↑(Nat.factorizationEquiv.symm ⟨f, hf⟩)) (f.prod fun x1 x2 => HPow.hPow x1 x2)","decl":"theorem factorizationEquiv_inv_apply {f : ℕ →₀ ℕ} (hf : ∀ p ∈ f.support, Prime p) :\n    (factorizationEquiv.symm ⟨f, hf⟩).1 = f.prod (· ^ ·) :=\n  rfl\n\n"}
{"name":"Nat.ordProj_of_not_prime","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\nhp : Not (Nat.Prime p)\n⊢ Eq (HPow.hPow p (n.factorization p)) 1","decl":"@[simp]\ntheorem ordProj_of_not_prime (n p : ℕ) (hp : ¬p.Prime) : ordProj[p] n = 1 := by\n  simp [factorization_eq_zero_of_non_prime n hp]\n\n"}
{"name":"Nat.ord_proj_of_not_prime","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\nhp : Not (Nat.Prime p)\n⊢ Eq (HPow.hPow p (n.factorization p)) 1","decl":"@[deprecated (since := \"2024-10-24\")] alias ord_proj_of_not_prime := ordProj_of_not_prime\n\n"}
{"name":"Nat.ordCompl_of_not_prime","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\nhp : Not (Nat.Prime p)\n⊢ Eq (HDiv.hDiv n (HPow.hPow p (n.factorization p))) n","decl":"@[simp]\ntheorem ordCompl_of_not_prime (n p : ℕ) (hp : ¬p.Prime) : ordCompl[p] n = n := by\n  simp [factorization_eq_zero_of_non_prime n hp]\n\n"}
{"name":"Nat.ord_compl_of_not_prime","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\nhp : Not (Nat.Prime p)\n⊢ Eq (HDiv.hDiv n (HPow.hPow p (n.factorization p))) n","decl":"@[deprecated (since := \"2024-10-24\")] alias ord_compl_of_not_prime := ordCompl_of_not_prime\n\n"}
{"name":"Nat.ordCompl_dvd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\n⊢ Dvd.dvd (HDiv.hDiv n (HPow.hPow p (n.factorization p))) n","decl":"theorem ordCompl_dvd (n p : ℕ) : ordCompl[p] n ∣ n :=\n  div_dvd_of_dvd (ordProj_dvd n p)\n\n"}
{"name":"Nat.ord_compl_dvd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\n⊢ Dvd.dvd (HDiv.hDiv n (HPow.hPow p (n.factorization p))) n","decl":"@[deprecated (since := \"2024-10-24\")] alias ord_compl_dvd := ordCompl_dvd\n\n"}
{"name":"Nat.ordProj_pos","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\n⊢ LT.lt 0 (HPow.hPow p (n.factorization p))","decl":"theorem ordProj_pos (n p : ℕ) : 0 < ordProj[p] n := by\n  if pp : p.Prime then simp [pow_pos pp.pos] else simp [pp]\n\n"}
{"name":"Nat.ord_proj_pos","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\n⊢ LT.lt 0 (HPow.hPow p (n.factorization p))","decl":"@[deprecated (since := \"2024-10-24\")] alias ord_proj_pos := ordProj_pos\n\n"}
{"name":"Nat.ordProj_le","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\nhn : Ne n 0\n⊢ LE.le (HPow.hPow p (n.factorization p)) n","decl":"theorem ordProj_le {n : ℕ} (p : ℕ) (hn : n ≠ 0) : ordProj[p] n ≤ n :=\n  le_of_dvd hn.bot_lt (Nat.ordProj_dvd n p)\n\n"}
{"name":"Nat.ord_proj_le","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\nhn : Ne n 0\n⊢ LE.le (HPow.hPow p (n.factorization p)) n","decl":"@[deprecated (since := \"2024-10-24\")] alias ord_proj_le := ordProj_le\n\n"}
{"name":"Nat.ordCompl_pos","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\nhn : Ne n 0\n⊢ LT.lt 0 (HDiv.hDiv n (HPow.hPow p (n.factorization p)))","decl":"theorem ordCompl_pos {n : ℕ} (p : ℕ) (hn : n ≠ 0) : 0 < ordCompl[p] n := by\n  if pp : p.Prime then\n    exact Nat.div_pos (ordProj_le p hn) (ordProj_pos n p)\n  else\n    simpa [Nat.factorization_eq_zero_of_non_prime n pp] using hn.bot_lt\n\n"}
{"name":"Nat.ord_compl_pos","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\nhn : Ne n 0\n⊢ LT.lt 0 (HDiv.hDiv n (HPow.hPow p (n.factorization p)))","decl":"@[deprecated (since := \"2024-10-24\")] alias ord_compl_pos := ordCompl_pos\n\n"}
{"name":"Nat.ordCompl_le","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\n⊢ LE.le (HDiv.hDiv n (HPow.hPow p (n.factorization p))) n","decl":"theorem ordCompl_le (n p : ℕ) : ordCompl[p] n ≤ n :=\n  Nat.div_le_self _ _\n\n"}
{"name":"Nat.ord_compl_le","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\n⊢ LE.le (HDiv.hDiv n (HPow.hPow p (n.factorization p))) n","decl":"@[deprecated (since := \"2024-10-24\")] alias ord_compl_le := ordCompl_le\n\n"}
{"name":"Nat.ordProj_mul_ordCompl_eq_self","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\n⊢ Eq (HMul.hMul (HPow.hPow p (n.factorization p)) (HDiv.hDiv n (HPow.hPow p (n.factorization p)))) n","decl":"theorem ordProj_mul_ordCompl_eq_self (n p : ℕ) : ordProj[p] n * ordCompl[p] n = n :=\n  Nat.mul_div_cancel' (ordProj_dvd n p)\n\n"}
{"name":"Nat.ord_proj_mul_ord_compl_eq_self","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\n⊢ Eq (HMul.hMul (HPow.hPow p (n.factorization p)) (HDiv.hDiv n (HPow.hPow p (n.factorization p)))) n","decl":"@[deprecated (since := \"2024-10-24\")]\nalias ord_proj_mul_ord_compl_eq_self := ordProj_mul_ordCompl_eq_self\n\n"}
{"name":"Nat.ordProj_mul","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b p : Nat\nha : Ne a 0\nhb : Ne b 0\n⊢ Eq (HPow.hPow p ((HMul.hMul a b).factorization p)) (HMul.hMul (HPow.hPow p (a.factorization p)) (HPow.hPow p (b.factorization p)))","decl":"theorem ordProj_mul {a b : ℕ} (p : ℕ) (ha : a ≠ 0) (hb : b ≠ 0) :\n    ordProj[p] (a * b) = ordProj[p] a * ordProj[p] b := by\n  simp [factorization_mul ha hb, pow_add]\n\n"}
{"name":"Nat.ord_proj_mul","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b p : Nat\nha : Ne a 0\nhb : Ne b 0\n⊢ Eq (HPow.hPow p ((HMul.hMul a b).factorization p)) (HMul.hMul (HPow.hPow p (a.factorization p)) (HPow.hPow p (b.factorization p)))","decl":"@[deprecated (since := \"2024-10-24\")] alias ord_proj_mul := ordProj_mul\n\n"}
{"name":"Nat.ordCompl_mul","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b p : Nat\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) (HPow.hPow p ((HMul.hMul a b).factorization p))) (HMul.hMul (HDiv.hDiv a (HPow.hPow p (a.factorization p))) (HDiv.hDiv b (HPow.hPow p (b.factorization p))))","decl":"theorem ordCompl_mul (a b p : ℕ) : ordCompl[p] (a * b) = ordCompl[p] a * ordCompl[p] b := by\n  if ha : a = 0 then simp [ha] else\n  if hb : b = 0 then simp [hb] else\n  simp only [ordProj_mul p ha hb]\n  rw [div_mul_div_comm (ordProj_dvd a p) (ordProj_dvd b p)]\n\n"}
{"name":"Nat.ord_compl_mul","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b p : Nat\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) (HPow.hPow p ((HMul.hMul a b).factorization p))) (HMul.hMul (HDiv.hDiv a (HPow.hPow p (a.factorization p))) (HDiv.hDiv b (HPow.hPow p (b.factorization p))))","decl":"@[deprecated (since := \"2024-10-24\")] alias ord_compl_mul := ordCompl_mul\n\n"}
{"name":"Nat.factorization_lt","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\nhn : Ne n 0\n⊢ LT.lt (n.factorization p) n","decl":"/-- A crude upper bound on `n.factorization p` -/\ntheorem factorization_lt {n : ℕ} (p : ℕ) (hn : n ≠ 0) : n.factorization p < n := by\n  by_cases pp : p.Prime\n  · exact (Nat.pow_lt_pow_iff_right pp.one_lt).1 <| (ordProj_le p hn).trans_lt <|\n      Nat.lt_pow_self pp.one_lt\n  · simpa only [factorization_eq_zero_of_non_prime n pp] using hn.bot_lt\n\n"}
{"name":"Nat.factorization_le_of_le_pow","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p b : Nat\nhb : LE.le n (HPow.hPow p b)\n⊢ LE.le (n.factorization p) b","decl":"/-- An upper bound on `n.factorization p` -/\ntheorem factorization_le_of_le_pow {n p b : ℕ} (hb : n ≤ p ^ b) : n.factorization p ≤ b := by\n  if hn : n = 0 then simp [hn] else\n  if pp : p.Prime then\n    exact (Nat.pow_le_pow_iff_right pp.one_lt).1 ((ordProj_le p hn).trans hb)\n  else\n    simp [factorization_eq_zero_of_non_prime n pp]\n\n"}
{"name":"Nat.factorization_prime_le_iff_dvd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"d n : Nat\nhd : Ne d 0\nhn : Ne n 0\n⊢ Iff (∀ (p : Nat), Nat.Prime p → LE.le (d.factorization p) (n.factorization p)) (Dvd.dvd d n)","decl":"theorem factorization_prime_le_iff_dvd {d n : ℕ} (hd : d ≠ 0) (hn : n ≠ 0) :\n    (∀ p : ℕ, p.Prime → d.factorization p ≤ n.factorization p) ↔ d ∣ n := by\n  rw [← factorization_le_iff_dvd hd hn]\n  refine ⟨fun h p => (em p.Prime).elim (h p) fun hp => ?_, fun h p _ => h p⟩\n  simp_rw [factorization_eq_zero_of_non_prime _ hp]\n  rfl\n\n"}
{"name":"Nat.factorization_le_factorization_mul_left","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b : Nat\nhb : Ne b 0\n⊢ LE.le a.factorization (HMul.hMul a b).factorization","decl":"theorem factorization_le_factorization_mul_left {a b : ℕ} (hb : b ≠ 0) :\n    a.factorization ≤ (a * b).factorization := by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  · simp\n  rw [factorization_le_iff_dvd ha <| mul_ne_zero ha hb]\n  exact Dvd.intro b rfl\n\n"}
{"name":"Nat.factorization_le_factorization_mul_right","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b : Nat\nha : Ne a 0\n⊢ LE.le b.factorization (HMul.hMul a b).factorization","decl":"theorem factorization_le_factorization_mul_right {a b : ℕ} (ha : a ≠ 0) :\n    b.factorization ≤ (a * b).factorization := by\n  rw [mul_comm]\n  apply factorization_le_factorization_mul_left ha\n\n"}
{"name":"Nat.Prime.pow_dvd_iff_le_factorization","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"p k n : Nat\npp : Nat.Prime p\nhn : Ne n 0\n⊢ Iff (Dvd.dvd (HPow.hPow p k) n) (LE.le k (n.factorization p))","decl":"theorem Prime.pow_dvd_iff_le_factorization {p k n : ℕ} (pp : Prime p) (hn : n ≠ 0) :\n    p ^ k ∣ n ↔ k ≤ n.factorization p := by\n  rw [← factorization_le_iff_dvd (pow_pos pp.pos k).ne' hn, pp.factorization_pow, single_le_iff]\n\n"}
{"name":"Nat.Prime.pow_dvd_iff_dvd_ordProj","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"p k n : Nat\npp : Nat.Prime p\nhn : Ne n 0\n⊢ Iff (Dvd.dvd (HPow.hPow p k) n) (Dvd.dvd (HPow.hPow p k) (HPow.hPow p (n.factorization p)))","decl":"theorem Prime.pow_dvd_iff_dvd_ordProj {p k n : ℕ} (pp : Prime p) (hn : n ≠ 0) :\n    p ^ k ∣ n ↔ p ^ k ∣ ordProj[p] n := by\n  rw [pow_dvd_pow_iff_le_right pp.one_lt, pp.pow_dvd_iff_le_factorization hn]\n\n"}
{"name":"Nat.Prime.pow_dvd_iff_dvd_ord_proj","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"p k n : Nat\npp : Nat.Prime p\nhn : Ne n 0\n⊢ Iff (Dvd.dvd (HPow.hPow p k) n) (Dvd.dvd (HPow.hPow p k) (HPow.hPow p (n.factorization p)))","decl":"@[deprecated (since := \"2024-10-24\")]\nalias Prime.pow_dvd_iff_dvd_ord_proj := Prime.pow_dvd_iff_dvd_ordProj\n\n"}
{"name":"Nat.Prime.dvd_iff_one_le_factorization","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"p n : Nat\npp : Nat.Prime p\nhn : Ne n 0\n⊢ Iff (Dvd.dvd p n) (LE.le 1 (n.factorization p))","decl":"theorem Prime.dvd_iff_one_le_factorization {p n : ℕ} (pp : Prime p) (hn : n ≠ 0) :\n    p ∣ n ↔ 1 ≤ n.factorization p :=\n  Iff.trans (by simp) (pp.pow_dvd_iff_le_factorization hn)\n\n"}
{"name":"Nat.exists_factorization_lt_of_lt","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b : Nat\nha : Ne a 0\nhab : LT.lt a b\n⊢ Exists fun p => LT.lt (a.factorization p) (b.factorization p)","decl":"theorem exists_factorization_lt_of_lt {a b : ℕ} (ha : a ≠ 0) (hab : a < b) :\n    ∃ p : ℕ, a.factorization p < b.factorization p := by\n  have hb : b ≠ 0 := (ha.bot_lt.trans hab).ne'\n  contrapose! hab\n  rw [← Finsupp.le_def, factorization_le_iff_dvd hb ha] at hab\n  exact le_of_dvd ha.bot_lt hab\n\n"}
{"name":"Nat.factorization_div","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"d n : Nat\nh : Dvd.dvd d n\n⊢ Eq (HDiv.hDiv n d).factorization (HSub.hSub n.factorization d.factorization)","decl":"@[simp]\ntheorem factorization_div {d n : ℕ} (h : d ∣ n) :\n    (n / d).factorization = n.factorization - d.factorization := by\n  rcases eq_or_ne d 0 with (rfl | hd); · simp [zero_dvd_iff.mp h]\n  rcases eq_or_ne n 0 with (rfl | hn); · simp [tsub_eq_zero_of_le]\n  apply add_left_injective d.factorization\n  simp only\n  rw [tsub_add_cancel_of_le <| (Nat.factorization_le_iff_dvd hd hn).mpr h, ←\n    Nat.factorization_mul (Nat.div_pos (Nat.le_of_dvd hn.bot_lt h) hd.bot_lt).ne' hd,\n    Nat.div_mul_cancel h]\n\n"}
{"name":"Nat.dvd_ordProj_of_dvd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\nhn : Ne n 0\npp : Nat.Prime p\nh : Dvd.dvd p n\n⊢ Dvd.dvd p (HPow.hPow p (n.factorization p))","decl":"theorem dvd_ordProj_of_dvd {n p : ℕ} (hn : n ≠ 0) (pp : p.Prime) (h : p ∣ n) : p ∣ ordProj[p] n :=\n  dvd_pow_self p (Prime.factorization_pos_of_dvd pp hn h).ne'\n\n"}
{"name":"Nat.dvd_ord_proj_of_dvd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\nhn : Ne n 0\npp : Nat.Prime p\nh : Dvd.dvd p n\n⊢ Dvd.dvd p (HPow.hPow p (n.factorization p))","decl":"@[deprecated (since := \"2024-10-24\")] alias dvd_ord_proj_of_dvd := dvd_ordProj_of_dvd\n\n"}
{"name":"Nat.not_dvd_ordCompl","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\nhp : Nat.Prime p\nhn : Ne n 0\n⊢ Not (Dvd.dvd p (HDiv.hDiv n (HPow.hPow p (n.factorization p))))","decl":"theorem not_dvd_ordCompl {n p : ℕ} (hp : Prime p) (hn : n ≠ 0) : ¬p ∣ ordCompl[p] n := by\n  rw [Nat.Prime.dvd_iff_one_le_factorization hp (ordCompl_pos p hn).ne']\n  rw [Nat.factorization_div (Nat.ordProj_dvd n p)]\n  simp [hp.factorization]\n\n"}
{"name":"Nat.not_dvd_ord_compl","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\nhp : Nat.Prime p\nhn : Ne n 0\n⊢ Not (Dvd.dvd p (HDiv.hDiv n (HPow.hPow p (n.factorization p))))","decl":"@[deprecated (since := \"2024-10-24\")] alias not_dvd_ord_compl := not_dvd_ordCompl\n\n"}
{"name":"Nat.coprime_ordCompl","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\nhp : Nat.Prime p\nhn : Ne n 0\n⊢ p.Coprime (HDiv.hDiv n (HPow.hPow p (n.factorization p)))","decl":"theorem coprime_ordCompl {n p : ℕ} (hp : Prime p) (hn : n ≠ 0) : Coprime p (ordCompl[p] n) :=\n  (or_iff_left (not_dvd_ordCompl hp hn)).mp <| coprime_or_dvd_of_prime hp _\n\n"}
{"name":"Nat.coprime_ord_compl","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\nhp : Nat.Prime p\nhn : Ne n 0\n⊢ p.Coprime (HDiv.hDiv n (HPow.hPow p (n.factorization p)))","decl":"@[deprecated (since := \"2024-10-24\")] alias coprime_ord_compl := coprime_ordCompl\n\n"}
{"name":"Nat.factorization_ordCompl","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\n⊢ Eq (HDiv.hDiv n (HPow.hPow p (n.factorization p))).factorization (Finsupp.erase p n.factorization)","decl":"theorem factorization_ordCompl (n p : ℕ) :\n    (ordCompl[p] n).factorization = n.factorization.erase p := by\n  if hn : n = 0 then simp [hn] else\n  if pp : p.Prime then ?_ else\n    -- Porting note: needed to solve side goal explicitly\n    rw [Finsupp.erase_of_not_mem_support] <;> simp [pp]\n  ext q\n  rcases eq_or_ne q p with (rfl | hqp)\n  · simp only [Finsupp.erase_same, factorization_eq_zero_iff, not_dvd_ordCompl pp hn]\n    simp\n  · rw [Finsupp.erase_ne hqp, factorization_div (ordProj_dvd n p)]\n    simp [pp.factorization, hqp.symm]\n\n"}
{"name":"Nat.factorization_ord_compl","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\n⊢ Eq (HDiv.hDiv n (HPow.hPow p (n.factorization p))).factorization (Finsupp.erase p n.factorization)","decl":"@[deprecated (since := \"2024-10-24\")] alias factorization_ord_compl := factorization_ordCompl\n\n-- `ordCompl[p] n` is the largest divisor of `n` not divisible by `p`.\n"}
{"name":"Nat.dvd_ordCompl_of_dvd_not_dvd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"p d n : Nat\nhdn : Dvd.dvd d n\nhpd : Not (Dvd.dvd p d)\n⊢ Dvd.dvd d (HDiv.hDiv n (HPow.hPow p (n.factorization p)))","decl":"theorem dvd_ordCompl_of_dvd_not_dvd {p d n : ℕ} (hdn : d ∣ n) (hpd : ¬p ∣ d) :\n    d ∣ ordCompl[p] n := by\n  if hn0 : n = 0 then simp [hn0] else\n  if hd0 : d = 0 then simp [hd0] at hpd else\n  rw [← factorization_le_iff_dvd hd0 (ordCompl_pos p hn0).ne', factorization_ordCompl]\n  intro q\n  if hqp : q = p then\n    simp [factorization_eq_zero_iff, hqp, hpd]\n  else\n    simp [hqp, (factorization_le_iff_dvd hd0 hn0).2 hdn q]\n\n"}
{"name":"Nat.dvd_ord_compl_of_dvd_not_dvd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"p d n : Nat\nhdn : Dvd.dvd d n\nhpd : Not (Dvd.dvd p d)\n⊢ Dvd.dvd d (HDiv.hDiv n (HPow.hPow p (n.factorization p)))","decl":"@[deprecated (since := \"2024-10-24\")]\nalias dvd_ord_compl_of_dvd_not_dvd := dvd_ordCompl_of_dvd_not_dvd\n\n"}
{"name":"Nat.exists_eq_pow_mul_and_not_dvd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n : Nat\nhn : Ne n 0\np : Nat\nhp : Ne p 1\n⊢ Exists fun e => Exists fun n' => And (Not (Dvd.dvd p n')) (Eq n (HMul.hMul (HPow.hPow p e) n'))","decl":"/-- If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem exists_eq_pow_mul_and_not_dvd {n : ℕ} (hn : n ≠ 0) (p : ℕ) (hp : p ≠ 1) :\n    ∃ e n' : ℕ, ¬p ∣ n' ∧ n = p ^ e * n' :=\n  let ⟨a', h₁, h₂⟩ :=\n    (Nat.finiteMultiplicity_iff.mpr ⟨hp, Nat.pos_of_ne_zero hn⟩).exists_eq_pow_mul_and_not_dvd\n  ⟨_, a', h₂, h₁⟩\n\n"}
{"name":"Nat.exists_eq_two_pow_mul_odd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n : Nat\nhn : Ne n 0\n⊢ Exists fun k => Exists fun m => And (Odd m) (Eq n (HMul.hMul (HPow.hPow 2 k) m))","decl":"/-- Any nonzero natural number is the product of an odd part `m` and a power of\ntwo `2 ^ k`. -/\ntheorem exists_eq_two_pow_mul_odd {n : ℕ} (hn : n ≠ 0) :\n    ∃ k m : ℕ, Odd m ∧ n = 2 ^ k * m :=\n  let ⟨k, m, hm, hn⟩ := exists_eq_pow_mul_and_not_dvd hn 2 (succ_ne_self 1)\n  ⟨k, m, not_even_iff_odd.1 (mt Even.two_dvd hm), hn⟩\n\n"}
{"name":"Nat.dvd_iff_div_factorization_eq_tsub","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"d n : Nat\nhd : Ne d 0\nhdn : LE.le d n\n⊢ Iff (Dvd.dvd d n) (Eq (HDiv.hDiv n d).factorization (HSub.hSub n.factorization d.factorization))","decl":"theorem dvd_iff_div_factorization_eq_tsub {d n : ℕ} (hd : d ≠ 0) (hdn : d ≤ n) :\n    d ∣ n ↔ (n / d).factorization = n.factorization - d.factorization := by\n  refine ⟨factorization_div, ?_⟩\n  rcases eq_or_lt_of_le hdn with (rfl | hd_lt_n); · simp\n  have h1 : n / d ≠ 0 := by simp [*]\n  intro h\n  rw [dvd_iff_le_div_mul n d]\n  by_contra h2\n  cases' exists_factorization_lt_of_lt (mul_ne_zero h1 hd) (not_le.mp h2) with p hp\n  rwa [factorization_mul h1 hd, add_apply, ← lt_tsub_iff_right, h, tsub_apply,\n   lt_self_iff_false] at hp\n\n"}
{"name":"Nat.ordProj_dvd_ordProj_of_dvd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b : Nat\nhb0 : Ne b 0\nhab : Dvd.dvd a b\np : Nat\n⊢ Dvd.dvd (HPow.hPow p (a.factorization p)) (HPow.hPow p (b.factorization p))","decl":"theorem ordProj_dvd_ordProj_of_dvd {a b : ℕ} (hb0 : b ≠ 0) (hab : a ∣ b) (p : ℕ) :\n    ordProj[p] a ∣ ordProj[p] b := by\n  rcases em' p.Prime with (pp | pp); · simp [pp]\n  rcases eq_or_ne a 0 with (rfl | ha0); · simp\n  rw [pow_dvd_pow_iff_le_right pp.one_lt]\n  exact (factorization_le_iff_dvd ha0 hb0).2 hab p\n\n"}
{"name":"Nat.ord_proj_dvd_ord_proj_of_dvd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b : Nat\nhb0 : Ne b 0\nhab : Dvd.dvd a b\np : Nat\n⊢ Dvd.dvd (HPow.hPow p (a.factorization p)) (HPow.hPow p (b.factorization p))","decl":"@[deprecated (since := \"2024-10-24\")]\nalias ord_proj_dvd_ord_proj_of_dvd := ordProj_dvd_ordProj_of_dvd\n\n"}
{"name":"Nat.ordProj_dvd_ordProj_iff_dvd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b : Nat\nha0 : Ne a 0\nhb0 : Ne b 0\n⊢ Iff (∀ (p : Nat), Dvd.dvd (HPow.hPow p (a.factorization p)) (HPow.hPow p (b.factorization p))) (Dvd.dvd a b)","decl":"theorem ordProj_dvd_ordProj_iff_dvd {a b : ℕ} (ha0 : a ≠ 0) (hb0 : b ≠ 0) :\n    (∀ p : ℕ, ordProj[p] a ∣ ordProj[p] b) ↔ a ∣ b := by\n  refine ⟨fun h => ?_, fun hab p => ordProj_dvd_ordProj_of_dvd hb0 hab p⟩\n  rw [← factorization_le_iff_dvd ha0 hb0]\n  intro q\n  rcases le_or_lt q 1 with (hq_le | hq1)\n  · interval_cases q <;> simp\n  exact (pow_dvd_pow_iff_le_right hq1).1 (h q)\n\n"}
{"name":"Nat.ord_proj_dvd_ord_proj_iff_dvd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b : Nat\nha0 : Ne a 0\nhb0 : Ne b 0\n⊢ Iff (∀ (p : Nat), Dvd.dvd (HPow.hPow p (a.factorization p)) (HPow.hPow p (b.factorization p))) (Dvd.dvd a b)","decl":"@[deprecated (since := \"2024-10-24\")]\nalias ord_proj_dvd_ord_proj_iff_dvd := ordProj_dvd_ordProj_iff_dvd\n\n"}
{"name":"Nat.ordCompl_dvd_ordCompl_of_dvd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b : Nat\nhab : Dvd.dvd a b\np : Nat\n⊢ Dvd.dvd (HDiv.hDiv a (HPow.hPow p (a.factorization p))) (HDiv.hDiv b (HPow.hPow p (b.factorization p)))","decl":"theorem ordCompl_dvd_ordCompl_of_dvd {a b : ℕ} (hab : a ∣ b) (p : ℕ) :\n    ordCompl[p] a ∣ ordCompl[p] b := by\n  rcases em' p.Prime with (pp | pp)\n  · simp [pp, hab]\n  rcases eq_or_ne b 0 with (rfl | hb0)\n  · simp\n  rcases eq_or_ne a 0 with (rfl | ha0)\n  · cases hb0 (zero_dvd_iff.1 hab)\n  have ha := (Nat.div_pos (ordProj_le p ha0) (ordProj_pos a p)).ne'\n  have hb := (Nat.div_pos (ordProj_le p hb0) (ordProj_pos b p)).ne'\n  rw [← factorization_le_iff_dvd ha hb, factorization_ordCompl a p, factorization_ordCompl b p]\n  intro q\n  rcases eq_or_ne q p with (rfl | hqp)\n  · simp\n  simp_rw [erase_ne hqp]\n  exact (factorization_le_iff_dvd ha0 hb0).2 hab q\n\n"}
{"name":"Nat.ord_compl_dvd_ord_compl_of_dvd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b : Nat\nhab : Dvd.dvd a b\np : Nat\n⊢ Dvd.dvd (HDiv.hDiv a (HPow.hPow p (a.factorization p))) (HDiv.hDiv b (HPow.hPow p (b.factorization p)))","decl":"@[deprecated (since := \"2024-10-24\")]\nalias ord_compl_dvd_ord_compl_of_dvd := ordCompl_dvd_ordCompl_of_dvd\n\n"}
{"name":"Nat.ordCompl_dvd_ordCompl_iff_dvd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b : Nat\n⊢ Iff (∀ (p : Nat), Dvd.dvd (HDiv.hDiv a (HPow.hPow p (a.factorization p))) (HDiv.hDiv b (HPow.hPow p (b.factorization p)))) (Dvd.dvd a b)","decl":"theorem ordCompl_dvd_ordCompl_iff_dvd (a b : ℕ) :\n    (∀ p : ℕ, ordCompl[p] a ∣ ordCompl[p] b) ↔ a ∣ b := by\n  refine ⟨fun h => ?_, fun hab p => ordCompl_dvd_ordCompl_of_dvd hab p⟩\n  rcases eq_or_ne b 0 with (rfl | hb0)\n  · simp\n  if pa : a.Prime then ?_ else simpa [pa] using h a\n  if pb : b.Prime then ?_ else simpa [pb] using h b\n  rw [prime_dvd_prime_iff_eq pa pb]\n  by_contra hab\n  apply pa.ne_one\n  rw [← Nat.dvd_one, ← Nat.mul_dvd_mul_iff_left hb0.bot_lt, mul_one]\n  simpa [Prime.factorization_self pb, Prime.factorization pa, hab] using h b\n\n"}
{"name":"Nat.ord_compl_dvd_ord_compl_iff_dvd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b : Nat\n⊢ Iff (∀ (p : Nat), Dvd.dvd (HDiv.hDiv a (HPow.hPow p (a.factorization p))) (HDiv.hDiv b (HPow.hPow p (b.factorization p)))) (Dvd.dvd a b)","decl":"@[deprecated (since := \"2024-10-24\")]\nalias ord_compl_dvd_ord_compl_iff_dvd := ordCompl_dvd_ordCompl_iff_dvd\n\n"}
{"name":"Nat.dvd_iff_prime_pow_dvd_dvd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n d : Nat\n⊢ Iff (Dvd.dvd d n) (∀ (p k : Nat), Nat.Prime p → Dvd.dvd (HPow.hPow p k) d → Dvd.dvd (HPow.hPow p k) n)","decl":"theorem dvd_iff_prime_pow_dvd_dvd (n d : ℕ) :\n    d ∣ n ↔ ∀ p k : ℕ, Prime p → p ^ k ∣ d → p ^ k ∣ n := by\n  rcases eq_or_ne n 0 with (rfl | hn)\n  · simp\n  rcases eq_or_ne d 0 with (rfl | hd)\n  · simp only [zero_dvd_iff, hn, false_iff, not_forall]\n    exact ⟨2, n, prime_two, dvd_zero _, mt (le_of_dvd hn.bot_lt) (n.lt_two_pow_self).not_le⟩\n  refine ⟨fun h p k _ hpkd => dvd_trans hpkd h, ?_⟩\n  rw [← factorization_prime_le_iff_dvd hd hn]\n  intro h p pp\n  simp_rw [← pp.pow_dvd_iff_le_factorization hn]\n  exact h p _ pp (ordProj_dvd _ _)\n\n"}
{"name":"Nat.prod_primeFactors_dvd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n : Nat\n⊢ Dvd.dvd (n.primeFactors.prod fun p => p) n","decl":"theorem prod_primeFactors_dvd (n : ℕ) : ∏ p ∈ n.primeFactors, p ∣ n := by\n  by_cases hn : n = 0\n  · subst hn\n    simp\n  · simpa [prod_primeFactorsList hn] using (n.primeFactorsList : Multiset ℕ).toFinset_prod_dvd_prod\n\n"}
{"name":"Nat.factorization_gcd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b : Nat\nha_pos : Ne a 0\nhb_pos : Ne b 0\n⊢ Eq (a.gcd b).factorization (Min.min a.factorization b.factorization)","decl":"theorem factorization_gcd {a b : ℕ} (ha_pos : a ≠ 0) (hb_pos : b ≠ 0) :\n    (gcd a b).factorization = a.factorization ⊓ b.factorization := by\n  let dfac := a.factorization ⊓ b.factorization\n  let d := dfac.prod (· ^ ·)\n  have dfac_prime : ∀ p : ℕ, p ∈ dfac.support → Prime p := by\n    intro p hp\n    have : p ∈ a.primeFactorsList ∧ p ∈ b.primeFactorsList := by simpa [dfac] using hp\n    exact prime_of_mem_primeFactorsList this.1\n  have h1 : d.factorization = dfac := prod_pow_factorization_eq_self dfac_prime\n  have hd_pos : d ≠ 0 := (factorizationEquiv.invFun ⟨dfac, dfac_prime⟩).2.ne'\n  suffices d = gcd a b by rwa [← this]\n  apply gcd_greatest\n  · rw [← factorization_le_iff_dvd hd_pos ha_pos, h1]\n    exact inf_le_left\n  · rw [← factorization_le_iff_dvd hd_pos hb_pos, h1]\n    exact inf_le_right\n  · intro e hea heb\n    rcases Decidable.eq_or_ne e 0 with (rfl | he_pos)\n    · simp only [zero_dvd_iff] at hea\n      contradiction\n    have hea' := (factorization_le_iff_dvd he_pos ha_pos).mpr hea\n    have heb' := (factorization_le_iff_dvd he_pos hb_pos).mpr heb\n    simp [dfac, ← factorization_le_iff_dvd he_pos hd_pos, h1, hea', heb']\n\n"}
{"name":"Nat.factorization_lcm","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b : Nat\nha : Ne a 0\nhb : Ne b 0\n⊢ Eq (a.lcm b).factorization (Max.max a.factorization b.factorization)","decl":"theorem factorization_lcm {a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) :\n    (a.lcm b).factorization = a.factorization ⊔ b.factorization := by\n  rw [← add_right_inj (a.gcd b).factorization, ←\n    factorization_mul (mt gcd_eq_zero_iff.1 fun h => ha h.1) (lcm_ne_zero ha hb), gcd_mul_lcm,\n    factorization_gcd ha hb, factorization_mul ha hb]\n  ext1\n  exact (min_add_max _ _).symm\n\n"}
{"name":"Nat.factorizationLCMLeft_zero_left","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"b : Nat\n⊢ Eq (Nat.factorizationLCMLeft 0 b) 1","decl":"@[simp]\nlemma factorizationLCMLeft_zero_left : factorizationLCMLeft 0 b = 1 := by\n  simp [factorizationLCMLeft]\n\n"}
{"name":"Nat.factorizationLCMLeft_zero_right","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a : Nat\n⊢ Eq (a.factorizationLCMLeft 0) 1","decl":"@[simp]\nlemma factorizationLCMLeft_zero_right : factorizationLCMLeft a 0 = 1 := by\n  simp [factorizationLCMLeft]\n\n"}
{"name":"Nat.factorizationLCRight_zero_left","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"b : Nat\n⊢ Eq (Nat.factorizationLCMRight 0 b) 1","decl":"@[simp]\nlemma factorizationLCRight_zero_left : factorizationLCMRight 0 b = 1 := by\n  simp [factorizationLCMRight]\n"}
{"name":"Nat.factorizationLCMRight_zero_right","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a : Nat\n⊢ Eq (a.factorizationLCMRight 0) 1","decl":"@[simp]\nlemma factorizationLCMRight_zero_right : factorizationLCMRight a 0 = 1 := by\n  simp [factorizationLCMRight]\n\n"}
{"name":"Nat.factorizationLCMLeft_pos","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b : Nat\n⊢ LT.lt 0 (a.factorizationLCMLeft b)","decl":"lemma factorizationLCMLeft_pos :\n    0 < factorizationLCMLeft a b := by\n  apply Nat.pos_of_ne_zero\n  rw [factorizationLCMLeft, Finsupp.prod_ne_zero_iff]\n  intro p _ H\n  by_cases h : b.factorization p ≤ a.factorization p\n  · simp only [h, reduceIte, pow_eq_zero_iff', ne_eq] at H\n    simpa [H.1] using H.2\n  · simp only [h, reduceIte, one_ne_zero] at H\n\n"}
{"name":"Nat.factorizationLCMRight_pos","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b : Nat\n⊢ LT.lt 0 (a.factorizationLCMRight b)","decl":"lemma factorizationLCMRight_pos :\n    0 < factorizationLCMRight a b := by\n  apply Nat.pos_of_ne_zero\n  rw [factorizationLCMRight, Finsupp.prod_ne_zero_iff]\n  intro p _ H\n  by_cases h : b.factorization p ≤ a.factorization p\n  · simp only [h, reduceIte, pow_eq_zero_iff', ne_eq, reduceCtorEq] at H\n  · simp only [h, ↓reduceIte, pow_eq_zero_iff', ne_eq] at H\n    simpa [H.1] using H.2\n\n"}
{"name":"Nat.coprime_factorizationLCMLeft_factorizationLCMRight","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b : Nat\n⊢ (a.factorizationLCMLeft b).Coprime (a.factorizationLCMRight b)","decl":"lemma coprime_factorizationLCMLeft_factorizationLCMRight :\n    (factorizationLCMLeft a b).Coprime (factorizationLCMRight a b) := by\n  rw [factorizationLCMLeft, factorizationLCMRight]\n  refine coprime_prod_left_iff.mpr fun p hp ↦ coprime_prod_right_iff.mpr fun q hq ↦ ?_\n  dsimp only; split_ifs with h h'\n  any_goals simp only [coprime_one_right_eq_true, coprime_one_left_eq_true]\n  refine coprime_pow_primes _ _ (prime_of_mem_primeFactors hp) (prime_of_mem_primeFactors hq) ?_\n  contrapose! h'; rwa [← h']\n\n"}
{"name":"Nat.factorizationLCMLeft_mul_factorizationLCMRight","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b : Nat\nha : Ne a 0\nhb : Ne b 0\n⊢ Eq (HMul.hMul (a.factorizationLCMLeft b) (a.factorizationLCMRight b)) (a.lcm b)","decl":"lemma factorizationLCMLeft_mul_factorizationLCMRight (ha : a ≠ 0) (hb : b ≠ 0) :\n    (factorizationLCMLeft a b) * (factorizationLCMRight a b) = lcm a b := by\n  rw [← factorization_prod_pow_eq_self (lcm_ne_zero ha hb), factorizationLCMLeft,\n    factorizationLCMRight, ← prod_mul]\n  congr; ext p n; split_ifs <;> simp\n\n"}
{"name":"Nat.factorizationLCMLeft_dvd_left","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b : Nat\n⊢ Dvd.dvd (a.factorizationLCMLeft b) a","decl":"lemma factorizationLCMLeft_dvd_left : factorizationLCMLeft a b ∣ a := by\n  rcases eq_or_ne a 0 with rfl | ha\n  · simp only [dvd_zero]\n  rcases eq_or_ne b 0 with rfl | hb\n  · simp [factorizationLCMLeft]\n  nth_rewrite 2 [← factorization_prod_pow_eq_self ha]\n  rw [prod_of_support_subset (s := (lcm a b).factorization.support)]\n  · apply prod_dvd_prod_of_dvd; rintro p -; dsimp only; split_ifs with le\n    · rw [factorization_lcm ha hb]; apply pow_dvd_pow; exact sup_le le_rfl le\n    · apply one_dvd\n  · intro p hp; rw [mem_support_iff] at hp ⊢\n    rw [factorization_lcm ha hb]; exact (lt_sup_iff.mpr <| .inl <| Nat.pos_of_ne_zero hp).ne'\n  · intros; rw [pow_zero]\n\n"}
{"name":"Nat.factorizationLCMRight_dvd_right","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b : Nat\n⊢ Dvd.dvd (a.factorizationLCMRight b) b","decl":"lemma factorizationLCMRight_dvd_right : factorizationLCMRight a b ∣ b := by\n  rcases eq_or_ne a 0 with rfl | ha\n  · simp [factorizationLCMRight]\n  rcases eq_or_ne b 0 with rfl | hb\n  · simp only [dvd_zero]\n  nth_rewrite 2 [← factorization_prod_pow_eq_self hb]\n  rw [prod_of_support_subset (s := (lcm a b).factorization.support)]\n  · apply Finset.prod_dvd_prod_of_dvd; rintro p -; dsimp only; split_ifs with le\n    · apply one_dvd\n    · rw [factorization_lcm ha hb]; apply pow_dvd_pow; exact sup_le (not_le.1 le).le le_rfl\n  · intro p hp; rw [mem_support_iff] at hp ⊢\n    rw [factorization_lcm ha hb]; exact (lt_sup_iff.mpr <| .inr <| Nat.pos_of_ne_zero hp).ne'\n  · intros; rw [pow_zero]\n\n"}
{"name":"Nat.sum_primeFactors_gcd_add_sum_primeFactors_mul","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"β : Type u_1\ninst✝ : AddCommMonoid β\nm n : Nat\nf : Nat → β\n⊢ Eq (HAdd.hAdd ((m.gcd n).primeFactors.sum f) ((HMul.hMul m n).primeFactors.sum f)) (HAdd.hAdd (m.primeFactors.sum f) (n.primeFactors.sum f))","decl":"@[to_additive sum_primeFactors_gcd_add_sum_primeFactors_mul]\ntheorem prod_primeFactors_gcd_mul_prod_primeFactors_mul {β : Type*} [CommMonoid β] (m n : ℕ)\n    (f : ℕ → β) :\n    (m.gcd n).primeFactors.prod f * (m * n).primeFactors.prod f =\n      m.primeFactors.prod f * n.primeFactors.prod f := by\n  obtain rfl | hm₀ := eq_or_ne m 0\n  · simp\n  obtain rfl | hn₀ := eq_or_ne n 0\n  · simp\n  · rw [primeFactors_mul hm₀ hn₀, primeFactors_gcd hm₀ hn₀, mul_comm, Finset.prod_union_inter]\n\n"}
{"name":"Nat.prod_primeFactors_gcd_mul_prod_primeFactors_mul","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"β : Type u_1\ninst✝ : CommMonoid β\nm n : Nat\nf : Nat → β\n⊢ Eq (HMul.hMul ((m.gcd n).primeFactors.prod f) ((HMul.hMul m n).primeFactors.prod f)) (HMul.hMul (m.primeFactors.prod f) (n.primeFactors.prod f))","decl":"@[to_additive sum_primeFactors_gcd_add_sum_primeFactors_mul]\ntheorem prod_primeFactors_gcd_mul_prod_primeFactors_mul {β : Type*} [CommMonoid β] (m n : ℕ)\n    (f : ℕ → β) :\n    (m.gcd n).primeFactors.prod f * (m * n).primeFactors.prod f =\n      m.primeFactors.prod f * n.primeFactors.prod f := by\n  obtain rfl | hm₀ := eq_or_ne m 0\n  · simp\n  obtain rfl | hn₀ := eq_or_ne n 0\n  · simp\n  · rw [primeFactors_mul hm₀ hn₀, primeFactors_gcd hm₀ hn₀, mul_comm, Finset.prod_union_inter]\n\n"}
{"name":"Nat.setOf_pow_dvd_eq_Icc_factorization","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\npp : Nat.Prime p\nhn : Ne n 0\n⊢ Eq (setOf fun i => And (Ne i 0) (Dvd.dvd (HPow.hPow p i) n)) (Set.Icc 1 (n.factorization p))","decl":"theorem setOf_pow_dvd_eq_Icc_factorization {n p : ℕ} (pp : p.Prime) (hn : n ≠ 0) :\n    { i : ℕ | i ≠ 0 ∧ p ^ i ∣ n } = Set.Icc 1 (n.factorization p) := by\n  ext\n  simp [Nat.lt_succ_iff, one_le_iff_ne_zero, pp.pow_dvd_iff_le_factorization hn]\n\n"}
{"name":"Nat.Icc_factorization_eq_pow_dvd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\npp : Nat.Prime p\n⊢ Eq (Finset.Icc 1 (n.factorization p)) (Finset.filter (fun i => Dvd.dvd (HPow.hPow p i) n) (Finset.Ico 1 n))","decl":"/-- The set of positive powers of prime `p` that divide `n` is exactly the set of\npositive natural numbers up to `n.factorization p`. -/\ntheorem Icc_factorization_eq_pow_dvd (n : ℕ) {p : ℕ} (pp : Prime p) :\n    Icc 1 (n.factorization p) = {i ∈ Ico 1 n | p ^ i ∣ n} := by\n  rcases eq_or_ne n 0 with (rfl | hn)\n  · simp\n  ext x\n  simp only [mem_Icc, Finset.mem_filter, mem_Ico, and_assoc, and_congr_right_iff,\n    pp.pow_dvd_iff_le_factorization hn, iff_and_self]\n  exact fun _ H => lt_of_le_of_lt H (factorization_lt p hn)\n\n"}
{"name":"Nat.factorization_eq_card_pow_dvd","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\npp : Nat.Prime p\n⊢ Eq (n.factorization p) (Finset.filter (fun i => Dvd.dvd (HPow.hPow p i) n) (Finset.Ico 1 n)).card","decl":"theorem factorization_eq_card_pow_dvd (n : ℕ) {p : ℕ} (pp : p.Prime) :\n    n.factorization p = #{i ∈ Ico 1 n | p ^ i ∣ n} := by\n  simp [← Icc_factorization_eq_pow_dvd n pp]\n\n"}
{"name":"Nat.Ico_filter_pow_dvd_eq","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p b : Nat\npp : Nat.Prime p\nhn : Ne n 0\nhb : LE.le n (HPow.hPow p b)\n⊢ Eq (Finset.filter (fun i => Dvd.dvd (HPow.hPow p i) n) (Finset.Ico 1 n)) (Finset.filter (fun i => Dvd.dvd (HPow.hPow p i) n) (Finset.Icc 1 b))","decl":"theorem Ico_filter_pow_dvd_eq {n p b : ℕ} (pp : p.Prime) (hn : n ≠ 0) (hb : n ≤ p ^ b) :\n    {i ∈ Ico 1 n | p ^ i ∣ n} = {i ∈ Icc 1 b | p ^ i ∣ n} := by\n  ext x\n  simp only [Finset.mem_filter, mem_Ico, mem_Icc, and_congr_left_iff, and_congr_right_iff]\n  rintro h1 -\n  exact iff_of_true (lt_of_pow_dvd_right hn pp.two_le h1) <|\n    (Nat.pow_le_pow_iff_right pp.one_lt).1 <| (le_of_dvd hn.bot_lt h1).trans hb\n\n"}
{"name":"Nat.factorization_eq_of_coprime_left","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"p a b : Nat\nhab : a.Coprime b\nhpa : Membership.mem a.primeFactorsList p\n⊢ Eq ((HMul.hMul a b).factorization p) (a.factorization p)","decl":"/-- If `p` is a prime factor of `a` then the power of `p` in `a` is the same that in `a * b`,\nfor any `b` coprime to `a`. -/\ntheorem factorization_eq_of_coprime_left {p a b : ℕ} (hab : Coprime a b)\n    (hpa : p ∈ a.primeFactorsList) : (a * b).factorization p = a.factorization p := by\n  rw [factorization_mul_apply_of_coprime hab, ← primeFactorsList_count_eq,\n    ← primeFactorsList_count_eq,\n    count_eq_zero_of_not_mem (coprime_primeFactorsList_disjoint hab hpa), add_zero]\n\n"}
{"name":"Nat.factorization_eq_of_coprime_right","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"p a b : Nat\nhab : a.Coprime b\nhpb : Membership.mem b.primeFactorsList p\n⊢ Eq ((HMul.hMul a b).factorization p) (b.factorization p)","decl":"/-- If `p` is a prime factor of `b` then the power of `p` in `b` is the same that in `a * b`,\nfor any `a` coprime to `b`. -/\ntheorem factorization_eq_of_coprime_right {p a b : ℕ} (hab : Coprime a b)\n    (hpb : p ∈ b.primeFactorsList) : (a * b).factorization p = b.factorization p := by\n  rw [mul_comm]\n  exact factorization_eq_of_coprime_left (coprime_comm.mp hab) hpb\n\n"}
{"name":"Nat.eq_iff_prime_padicValNat_eq","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"a b : Nat\nha : Ne a 0\nhb : Ne b 0\n⊢ Iff (Eq a b) (∀ (p : Nat), Nat.Prime p → Eq (padicValNat p a) (padicValNat p b))","decl":"/-- Two positive naturals are equal if their prime padic valuations are equal -/\ntheorem eq_iff_prime_padicValNat_eq (a b : ℕ) (ha : a ≠ 0) (hb : b ≠ 0) :\n    a = b ↔ ∀ p : ℕ, p.Prime → padicValNat p a = padicValNat p b := by\n  constructor\n  · rintro rfl\n    simp\n  · intro h\n    refine eq_of_factorization_eq ha hb fun p => ?_\n    by_cases pp : p.Prime\n    · simp [factorization_def, pp, h p pp]\n    · simp [factorization_eq_zero_of_non_prime, pp]\n\n"}
{"name":"Nat.prod_pow_prime_padicValNat","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n : Nat\nhn : Ne n 0\nm : Nat\npr : LT.lt n m\n⊢ Eq ((Finset.filter (fun p => Nat.Prime p) (Finset.range m)).prod fun p => HPow.hPow p (padicValNat p n)) n","decl":"theorem prod_pow_prime_padicValNat (n : Nat) (hn : n ≠ 0) (m : Nat) (pr : n < m) :\n    ∏ p ∈ range m with p.Prime, p ^ padicValNat p n = n := by\n  nth_rw 2 [← factorization_prod_pow_eq_self hn]\n  rw [eq_comm]\n  apply Finset.prod_subset_one_on_sdiff\n  · exact fun p hp => Finset.mem_filter.mpr ⟨Finset.mem_range.2 <| pr.trans_le' <|\n      le_of_mem_primeFactors hp, prime_of_mem_primeFactors hp⟩\n  · intro p hp\n    cases' Finset.mem_sdiff.mp hp with hp1 hp2\n    rw [← factorization_def n (Finset.mem_filter.mp hp1).2]\n    simp [Finsupp.not_mem_support_iff.mp hp2]\n  · intro p hp\n    simp [factorization_def n (prime_of_mem_primeFactors hp)]\n\n"}
{"name":"Nat.card_multiples","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\n⊢ Eq (Finset.filter (fun e => Dvd.dvd p (HAdd.hAdd e 1)) (Finset.range n)).card (HDiv.hDiv n p)","decl":"/-- Exactly `n / p` naturals in `[1, n]` are multiples of `p`.\nSee `Nat.card_multiples'` for an alternative spelling of the statement. -/\ntheorem card_multiples (n p : ℕ) : #{e ∈ range n | p ∣ e + 1} = n / p := by\n  induction' n with n hn\n  · simp\n  simp [Nat.succ_div, add_ite, add_zero, Finset.range_succ, filter_insert, apply_ite card,\n    card_insert_of_not_mem, hn]\n\n"}
{"name":"Nat.Ioc_filter_dvd_card_eq_div","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"n p : Nat\n⊢ Eq (Finset.filter (fun x => Dvd.dvd p x) (Finset.Ioc 0 n)).card (HDiv.hDiv n p)","decl":"/-- Exactly `n / p` naturals in `(0, n]` are multiples of `p`. -/\ntheorem Ioc_filter_dvd_card_eq_div (n p : ℕ) : #{x ∈ Ioc 0 n | p ∣ x} = n / p := by\n  induction' n with n IH\n  · simp\n  -- TODO: Golf away `h1` after Yaël PRs a lemma asserting this\n  have h1 : Ioc 0 n.succ = insert n.succ (Ioc 0 n) := by\n    rcases n.eq_zero_or_pos with (rfl | hn)\n    · simp\n    simp_rw [← Ico_succ_succ, Ico_insert_right (succ_le_succ hn.le), Ico_succ_right]\n  simp [Nat.succ_div, add_ite, add_zero, h1, filter_insert, apply_ite card, card_insert_eq_ite, IH,\n    Finset.mem_filter, mem_Ioc, not_le.2 (lt_add_one n)]\n\n"}
{"name":"Nat.card_multiples'","module":"Mathlib.Data.Nat.Factorization.Basic","initialProofState":"N n : Nat\n⊢ Eq (Finset.filter (fun k => And (Ne k 0) (Dvd.dvd n k)) (Finset.range N.succ)).card (HDiv.hDiv N n)","decl":"/-- There are exactly `⌊N/n⌋` positive multiples of `n` that are `≤ N`.\nSee `Nat.card_multiples` for a \"shifted-by-one\" version. -/\nlemma card_multiples' (N n : ℕ) : #{k ∈ range N.succ | k ≠ 0 ∧ n ∣ k} = N / n := by\n  induction N with\n    | zero => simp [Finset.filter_false_of_mem]\n    | succ N ih =>\n        rw [Finset.range_succ, Finset.filter_insert]\n        by_cases h : n ∣ N.succ\n        · simp [h, succ_div_of_dvd, ih]\n        · simp [h, succ_div_of_not_dvd, ih]\n\n"}
