{"name":"TensorProduct.toMatrix_map","module":"Mathlib.LinearAlgebra.TensorProduct.Matrix","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nM' : Type u_5\nN' : Type u_6\nι : Type u_7\nκ : Type u_8\nι' : Type u_10\nκ' : Type u_11\ninst✝¹⁴ : DecidableEq ι\ninst✝¹³ : DecidableEq κ\ninst✝¹² : Fintype ι\ninst✝¹¹ : Fintype κ\ninst✝¹⁰ : Finite ι'\ninst✝⁹ : Finite κ'\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : AddCommGroup M'\ninst✝⁴ : AddCommGroup N'\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R M'\ninst✝ : Module R N'\nbM : Basis ι R M\nbN : Basis κ R N\nbM' : Basis ι' R M'\nbN' : Basis κ' R N'\nf : LinearMap (RingHom.id R) M M'\ng : LinearMap (RingHom.id R) N N'\n⊢ Eq ((LinearMap.toMatrix (bM.tensorProduct bN) (bM'.tensorProduct bN')) (TensorProduct.map f g)) (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) ((LinearMap.toMatrix bM bM') f) ((LinearMap.toMatrix bN bN') g))","decl":"/-- The linear map built from `TensorProduct.map` corresponds to the matrix built from\n`Matrix.kronecker`. -/\ntheorem TensorProduct.toMatrix_map (f : M →ₗ[R] M') (g : N →ₗ[R] N') :\n    toMatrix (bM.tensorProduct bN) (bM'.tensorProduct bN') (TensorProduct.map f g) =\n      toMatrix bM bM' f ⊗ₖ toMatrix bN bN' g := by\n  ext ⟨i, j⟩ ⟨i', j'⟩\n  simp_rw [Matrix.kroneckerMap_apply, toMatrix_apply, Basis.tensorProduct_apply,\n    TensorProduct.map_tmul, Basis.tensorProduct_repr_tmul_apply]\n  exact mul_comm _ _\n\n"}
{"name":"Matrix.toLin_kronecker","module":"Mathlib.LinearAlgebra.TensorProduct.Matrix","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nM' : Type u_5\nN' : Type u_6\nι : Type u_7\nκ : Type u_8\nι' : Type u_10\nκ' : Type u_11\ninst✝¹⁴ : DecidableEq ι\ninst✝¹³ : DecidableEq κ\ninst✝¹² : Fintype ι\ninst✝¹¹ : Fintype κ\ninst✝¹⁰ : Finite ι'\ninst✝⁹ : Finite κ'\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : AddCommGroup M'\ninst✝⁴ : AddCommGroup N'\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R M'\ninst✝ : Module R N'\nbM : Basis ι R M\nbN : Basis κ R N\nbM' : Basis ι' R M'\nbN' : Basis κ' R N'\nA : Matrix ι' ι R\nB : Matrix κ' κ R\n⊢ Eq ((Matrix.toLin (bM.tensorProduct bN) (bM'.tensorProduct bN')) (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A B)) (TensorProduct.map ((Matrix.toLin bM bM') A) ((Matrix.toLin bN bN') B))","decl":"/-- The matrix built from `Matrix.kronecker` corresponds to the linear map built from\n`TensorProduct.map`. -/\ntheorem Matrix.toLin_kronecker (A : Matrix ι' ι R) (B : Matrix κ' κ R) :\n    toLin (bM.tensorProduct bN) (bM'.tensorProduct bN') (A ⊗ₖ B) =\n      TensorProduct.map (toLin bM bM' A) (toLin bN bN' B) := by\n  rw [← LinearEquiv.eq_symm_apply, toLin_symm, TensorProduct.toMatrix_map, toMatrix_toLin,\n    toMatrix_toLin]\n\n"}
{"name":"TensorProduct.toMatrix_comm","module":"Mathlib.LinearAlgebra.TensorProduct.Matrix","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nι : Type u_7\nκ : Type u_8\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : DecidableEq κ\ninst✝⁶ : Fintype ι\ninst✝⁵ : Fintype κ\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nbM : Basis ι R M\nbN : Basis κ R N\n⊢ Eq ((LinearMap.toMatrix (bM.tensorProduct bN) (bN.tensorProduct bM)) ↑(TensorProduct.comm R M N)) (Matrix.submatrix 1 Prod.swap id)","decl":"/-- `TensorProduct.comm` corresponds to a permutation of the identity matrix. -/\ntheorem TensorProduct.toMatrix_comm :\n    toMatrix (bM.tensorProduct bN) (bN.tensorProduct bM) (TensorProduct.comm R M N) =\n      (1 : Matrix (ι × κ) (ι × κ) R).submatrix Prod.swap _root_.id := by\n  ext ⟨i, j⟩ ⟨i', j'⟩\n  simp only [toMatrix_apply, Basis.tensorProduct_apply, LinearEquiv.coe_coe, comm_tmul,\n    Basis.tensorProduct_repr_tmul_apply, Basis.repr_self, Finsupp.single_apply, @eq_comm _ i',\n    @eq_comm _ j', smul_eq_mul, mul_ite, mul_one, mul_zero, ← ite_and, and_comm, submatrix_apply,\n    Matrix.one_apply, Prod.swap_prod_mk, id_eq, Prod.mk.injEq]\n\n"}
{"name":"TensorProduct.toMatrix_assoc","module":"Mathlib.LinearAlgebra.TensorProduct.Matrix","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nι : Type u_7\nκ : Type u_8\nτ : Type u_9\ninst✝¹² : DecidableEq ι\ninst✝¹¹ : DecidableEq κ\ninst✝¹⁰ : DecidableEq τ\ninst✝⁹ : Fintype ι\ninst✝⁸ : Fintype κ\ninst✝⁷ : Fintype τ\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : AddCommGroup P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nbM : Basis ι R M\nbN : Basis κ R N\nbP : Basis τ R P\n⊢ Eq ((LinearMap.toMatrix ((bM.tensorProduct bN).tensorProduct bP) (bM.tensorProduct (bN.tensorProduct bP))) ↑(TensorProduct.assoc R M N P)) (Matrix.submatrix 1 id ⇑(Equiv.prodAssoc ι κ τ))","decl":"/-- `TensorProduct.assoc` corresponds to a permutation of the identity matrix. -/\ntheorem TensorProduct.toMatrix_assoc :\n    toMatrix ((bM.tensorProduct bN).tensorProduct bP) (bM.tensorProduct (bN.tensorProduct bP))\n        (TensorProduct.assoc R M N P) =\n      (1 : Matrix (ι × κ × τ) (ι × κ × τ) R).submatrix _root_.id (Equiv.prodAssoc _ _ _) := by\n  ext ⟨i, j, k⟩ ⟨⟨i', j'⟩, k'⟩\n  simp only [toMatrix_apply, Basis.tensorProduct_apply, LinearEquiv.coe_coe, assoc_tmul,\n    Basis.tensorProduct_repr_tmul_apply, Basis.repr_self, Finsupp.single_apply, @eq_comm _ k',\n    @eq_comm _ j', smul_eq_mul, mul_ite, mul_one, mul_zero, ← ite_and, @eq_comm _ i',\n    submatrix_apply, Matrix.one_apply, id_eq, Equiv.prodAssoc_apply, Prod.mk.injEq]\n"}
