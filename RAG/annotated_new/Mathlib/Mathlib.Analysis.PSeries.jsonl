{"name":"Finset.le_sum_schlomilch'","module":"Mathlib.Analysis.PSeries","initialProofState":"M : Type u_1\ninst✝ : OrderedAddCommMonoid M\nf : Nat → M\nu : Nat → Nat\nhf : ∀ ⦃m n : Nat⦄, LT.lt 0 m → LE.le m n → LE.le (f n) (f m)\nh_pos : ∀ (n : Nat), LT.lt 0 (u n)\nhu : Monotone u\nn : Nat\n⊢ LE.le ((Finset.Ico (u 0) (u n)).sum fun k => f k) ((Finset.range n).sum fun k => HSMul.hSMul (HSub.hSub (u (HAdd.hAdd k 1)) (u k)) (f (u k)))","decl":"theorem le_sum_schlomilch' (hf : ∀ ⦃m n⦄, 0 < m → m ≤ n → f n ≤ f m) (h_pos : ∀ n, 0 < u n)\n    (hu : Monotone u) (n : ℕ) :\n    (∑ k ∈ Ico (u 0) (u n), f k) ≤ ∑ k ∈ range n, (u (k + 1) - u k) • f (u k) := by\n  induction n with\n  | zero => simp\n  | succ n ihn =>\n    suffices (∑ k ∈ Ico (u n) (u (n + 1)), f k) ≤ (u (n + 1) - u n) • f (u n) by\n      rw [sum_range_succ, ← sum_Ico_consecutive]\n      · exact add_le_add ihn this\n      exacts [hu n.zero_le, hu n.le_succ]\n    have : ∀ k ∈ Ico (u n) (u (n + 1)), f k ≤ f (u n) := fun k hk =>\n      hf (Nat.succ_le_of_lt (h_pos n)) (mem_Ico.mp hk).1\n    convert sum_le_sum this\n    simp [pow_succ, mul_two]\n\n"}
{"name":"Finset.le_sum_condensed'","module":"Mathlib.Analysis.PSeries","initialProofState":"M : Type u_1\ninst✝ : OrderedAddCommMonoid M\nf : Nat → M\nhf : ∀ ⦃m n : Nat⦄, LT.lt 0 m → LE.le m n → LE.le (f n) (f m)\nn : Nat\n⊢ LE.le ((Finset.Ico 1 (HPow.hPow 2 n)).sum fun k => f k) ((Finset.range n).sum fun k => HSMul.hSMul (HPow.hPow 2 k) (f (HPow.hPow 2 k)))","decl":"theorem le_sum_condensed' (hf : ∀ ⦃m n⦄, 0 < m → m ≤ n → f n ≤ f m) (n : ℕ) :\n    (∑ k ∈ Ico 1 (2 ^ n), f k) ≤ ∑ k ∈ range n, 2 ^ k • f (2 ^ k) := by\n  convert le_sum_schlomilch' hf (fun n => pow_pos zero_lt_two n)\n    (fun m n hm => pow_right_mono₀ one_le_two hm) n using 2\n  simp [pow_succ, mul_two, two_mul]\n\n"}
{"name":"Finset.le_sum_schlomilch","module":"Mathlib.Analysis.PSeries","initialProofState":"M : Type u_1\ninst✝ : OrderedAddCommMonoid M\nf : Nat → M\nu : Nat → Nat\nhf : ∀ ⦃m n : Nat⦄, LT.lt 0 m → LE.le m n → LE.le (f n) (f m)\nh_pos : ∀ (n : Nat), LT.lt 0 (u n)\nhu : Monotone u\nn : Nat\n⊢ LE.le ((Finset.range (u n)).sum fun k => f k) (HAdd.hAdd ((Finset.range (u 0)).sum fun k => f k) ((Finset.range n).sum fun k => HSMul.hSMul (HSub.hSub (u (HAdd.hAdd k 1)) (u k)) (f (u k))))","decl":"theorem le_sum_schlomilch (hf : ∀ ⦃m n⦄, 0 < m → m ≤ n → f n ≤ f m) (h_pos : ∀ n, 0 < u n)\n    (hu : Monotone u) (n : ℕ) :\n    (∑ k ∈ range (u n), f k) ≤\n      ∑ k ∈ range (u 0), f k + ∑ k ∈ range n, (u (k + 1) - u k) • f (u k) := by\n  convert add_le_add_left (le_sum_schlomilch' hf h_pos hu n) (∑ k ∈ range (u 0), f k)\n  rw [← sum_range_add_sum_Ico _ (hu n.zero_le)]\n\n"}
{"name":"Finset.le_sum_condensed","module":"Mathlib.Analysis.PSeries","initialProofState":"M : Type u_1\ninst✝ : OrderedAddCommMonoid M\nf : Nat → M\nhf : ∀ ⦃m n : Nat⦄, LT.lt 0 m → LE.le m n → LE.le (f n) (f m)\nn : Nat\n⊢ LE.le ((Finset.range (HPow.hPow 2 n)).sum fun k => f k) (HAdd.hAdd (f 0) ((Finset.range n).sum fun k => HSMul.hSMul (HPow.hPow 2 k) (f (HPow.hPow 2 k))))","decl":"theorem le_sum_condensed (hf : ∀ ⦃m n⦄, 0 < m → m ≤ n → f n ≤ f m) (n : ℕ) :\n    (∑ k ∈ range (2 ^ n), f k) ≤ f 0 + ∑ k ∈ range n, 2 ^ k • f (2 ^ k) := by\n  convert add_le_add_left (le_sum_condensed' hf n) (f 0)\n  rw [← sum_range_add_sum_Ico _ n.one_le_two_pow, sum_range_succ, sum_range_zero, zero_add]\n\n"}
{"name":"Finset.sum_schlomilch_le'","module":"Mathlib.Analysis.PSeries","initialProofState":"M : Type u_1\ninst✝ : OrderedAddCommMonoid M\nf : Nat → M\nu : Nat → Nat\nhf : ∀ ⦃m n : Nat⦄, LT.lt 1 m → LE.le m n → LE.le (f n) (f m)\nh_pos : ∀ (n : Nat), LT.lt 0 (u n)\nhu : Monotone u\nn : Nat\n⊢ LE.le ((Finset.range n).sum fun k => HSMul.hSMul (HSub.hSub (u (HAdd.hAdd k 1)) (u k)) (f (u (HAdd.hAdd k 1)))) ((Finset.Ico (HAdd.hAdd (u 0) 1) (HAdd.hAdd (u n) 1)).sum fun k => f k)","decl":"theorem sum_schlomilch_le' (hf : ∀ ⦃m n⦄, 1 < m → m ≤ n → f n ≤ f m) (h_pos : ∀ n, 0 < u n)\n    (hu : Monotone u) (n : ℕ) :\n    (∑ k ∈ range n, (u (k + 1) - u k) • f (u (k + 1))) ≤ ∑ k ∈ Ico (u 0 + 1) (u n + 1), f k := by\n  induction n with\n  | zero => simp\n  | succ n ihn =>\n    suffices (u (n + 1) - u n) • f (u (n + 1)) ≤ ∑ k ∈ Ico (u n + 1) (u (n + 1) + 1), f k by\n      rw [sum_range_succ, ← sum_Ico_consecutive]\n      exacts [add_le_add ihn this,\n        (add_le_add_right (hu n.zero_le) _ : u 0 + 1 ≤ u n + 1),\n        add_le_add_right (hu n.le_succ) _]\n    have : ∀ k ∈ Ico (u n + 1) (u (n + 1) + 1), f (u (n + 1)) ≤ f k := fun k hk =>\n      hf (Nat.lt_of_le_of_lt (Nat.succ_le_of_lt (h_pos n)) <| (Nat.lt_succ_of_le le_rfl).trans_le\n        (mem_Ico.mp hk).1) (Nat.le_of_lt_succ <| (mem_Ico.mp hk).2)\n    convert sum_le_sum this\n    simp [pow_succ, mul_two]\n\n"}
{"name":"Finset.sum_condensed_le'","module":"Mathlib.Analysis.PSeries","initialProofState":"M : Type u_1\ninst✝ : OrderedAddCommMonoid M\nf : Nat → M\nhf : ∀ ⦃m n : Nat⦄, LT.lt 1 m → LE.le m n → LE.le (f n) (f m)\nn : Nat\n⊢ LE.le ((Finset.range n).sum fun k => HSMul.hSMul (HPow.hPow 2 k) (f (HPow.hPow 2 (HAdd.hAdd k 1)))) ((Finset.Ico 2 (HAdd.hAdd (HPow.hPow 2 n) 1)).sum fun k => f k)","decl":"theorem sum_condensed_le' (hf : ∀ ⦃m n⦄, 1 < m → m ≤ n → f n ≤ f m) (n : ℕ) :\n    (∑ k ∈ range n, 2 ^ k • f (2 ^ (k + 1))) ≤ ∑ k ∈ Ico 2 (2 ^ n + 1), f k := by\n  convert sum_schlomilch_le' hf (fun n => pow_pos zero_lt_two n)\n    (fun m n hm => pow_right_mono₀ one_le_two hm) n using 2\n  simp [pow_succ, mul_two, two_mul]\n\n"}
{"name":"Finset.sum_schlomilch_le","module":"Mathlib.Analysis.PSeries","initialProofState":"M : Type u_1\ninst✝ : OrderedAddCommMonoid M\nf : Nat → M\nu : Nat → Nat\nC : Nat\nhf : ∀ ⦃m n : Nat⦄, LT.lt 1 m → LE.le m n → LE.le (f n) (f m)\nh_pos : ∀ (n : Nat), LT.lt 0 (u n)\nh_nonneg : ∀ (n : Nat), LE.le 0 (f n)\nhu : Monotone u\nh_succ_diff : SuccDiffBounded C u\nn : Nat\n⊢ LE.le ((Finset.range (HAdd.hAdd n 1)).sum fun k => HSMul.hSMul (HSub.hSub (u (HAdd.hAdd k 1)) (u k)) (f (u k))) (HAdd.hAdd (HSMul.hSMul (HSub.hSub (u 1) (u 0)) (f (u 0))) (HSMul.hSMul C ((Finset.Ico (HAdd.hAdd (u 0) 1) (HAdd.hAdd (u n) 1)).sum fun k => f k)))","decl":"theorem sum_schlomilch_le {C : ℕ} (hf : ∀ ⦃m n⦄, 1 < m → m ≤ n → f n ≤ f m) (h_pos : ∀ n, 0 < u n)\n    (h_nonneg : ∀ n, 0 ≤ f n) (hu : Monotone u) (h_succ_diff : SuccDiffBounded C u) (n : ℕ) :\n    ∑ k ∈ range (n + 1), (u (k + 1) - u k) • f (u k) ≤\n    (u 1 - u 0) • f (u 0) + C • ∑ k ∈ Ico (u 0 + 1) (u n + 1), f k := by\n  rw [sum_range_succ', add_comm]\n  gcongr\n  suffices ∑ k ∈ range n, (u (k + 2) - u (k + 1)) • f (u (k + 1)) ≤\n  C • ∑ k ∈ range n, ((u (k + 1) - u k) • f (u (k + 1))) by\n    refine this.trans (nsmul_le_nsmul_right ?_ _)\n    exact sum_schlomilch_le' hf h_pos hu n\n  have : ∀ k ∈ range n, (u (k + 2) - u (k + 1)) • f (u (k + 1)) ≤\n    C • ((u (k + 1) - u k) • f (u (k + 1))) := by\n    intro k _\n    rw [smul_smul]\n    gcongr\n    · exact h_nonneg (u (k + 1))\n    exact mod_cast h_succ_diff k\n  convert sum_le_sum this\n  simp [smul_sum]\n\n"}
{"name":"Finset.sum_condensed_le","module":"Mathlib.Analysis.PSeries","initialProofState":"M : Type u_1\ninst✝ : OrderedAddCommMonoid M\nf : Nat → M\nhf : ∀ ⦃m n : Nat⦄, LT.lt 1 m → LE.le m n → LE.le (f n) (f m)\nn : Nat\n⊢ LE.le ((Finset.range (HAdd.hAdd n 1)).sum fun k => HSMul.hSMul (HPow.hPow 2 k) (f (HPow.hPow 2 k))) (HAdd.hAdd (f 1) (HSMul.hSMul 2 ((Finset.Ico 2 (HAdd.hAdd (HPow.hPow 2 n) 1)).sum fun k => f k)))","decl":"theorem sum_condensed_le (hf : ∀ ⦃m n⦄, 1 < m → m ≤ n → f n ≤ f m) (n : ℕ) :\n    (∑ k ∈ range (n + 1), 2 ^ k • f (2 ^ k)) ≤ f 1 + 2 • ∑ k ∈ Ico 2 (2 ^ n + 1), f k := by\n  convert add_le_add_left (nsmul_le_nsmul_right (sum_condensed_le' hf n) 2) (f 1)\n  simp [sum_range_succ', add_comm, pow_succ', mul_nsmul', sum_nsmul]\n\n"}
{"name":"ENNReal.le_tsum_schlomilch","module":"Mathlib.Analysis.PSeries","initialProofState":"u : Nat → Nat\nf : Nat → ENNReal\nhf : ∀ ⦃m n : Nat⦄, LT.lt 0 m → LE.le m n → LE.le (f n) (f m)\nh_pos : ∀ (n : Nat), LT.lt 0 (u n)\nhu : StrictMono u\n⊢ LE.le (tsum fun k => f k) (HAdd.hAdd ((Finset.range (u 0)).sum fun k => f k) (tsum fun k => HMul.hMul (HSub.hSub ↑(u (HAdd.hAdd k 1)) ↑(u k)) (f (u k))))","decl":"open NNReal in\ntheorem le_tsum_schlomilch (hf : ∀ ⦃m n⦄, 0 < m → m ≤ n → f n ≤ f m) (h_pos : ∀ n, 0 < u n)\n    (hu : StrictMono u) :\n    ∑' k , f k ≤ ∑ k ∈ range (u 0), f k + ∑' k : ℕ, (u (k + 1) - u k) * f (u k) := by\n  rw [ENNReal.tsum_eq_iSup_nat' hu.tendsto_atTop]\n  refine iSup_le fun n =>\n    (Finset.le_sum_schlomilch hf h_pos hu.monotone n).trans (add_le_add_left ?_ _)\n  have (k : ℕ) : (u (k + 1) - u k : ℝ≥0∞) = (u (k + 1) - (u k : ℕ) : ℕ) := by\n    simp [NNReal.coe_sub (Nat.cast_le (α := ℝ≥0).mpr <| (hu k.lt_succ_self).le)]\n  simp only [nsmul_eq_mul, this]\n  apply ENNReal.sum_le_tsum\n\n"}
{"name":"ENNReal.le_tsum_condensed","module":"Mathlib.Analysis.PSeries","initialProofState":"f : Nat → ENNReal\nhf : ∀ ⦃m n : Nat⦄, LT.lt 0 m → LE.le m n → LE.le (f n) (f m)\n⊢ LE.le (tsum fun k => f k) (HAdd.hAdd (f 0) (tsum fun k => HMul.hMul (HPow.hPow 2 k) (f (HPow.hPow 2 k))))","decl":"theorem le_tsum_condensed (hf : ∀ ⦃m n⦄, 0 < m → m ≤ n → f n ≤ f m) :\n    ∑' k, f k ≤ f 0 + ∑' k : ℕ, 2 ^ k * f (2 ^ k) := by\n  rw [ENNReal.tsum_eq_iSup_nat' (Nat.tendsto_pow_atTop_atTop_of_one_lt _root_.one_lt_two)]\n  refine iSup_le fun n => (Finset.le_sum_condensed hf n).trans (add_le_add_left ?_ _)\n  simp only [nsmul_eq_mul, Nat.cast_pow, Nat.cast_two]\n  apply ENNReal.sum_le_tsum\n\n"}
{"name":"ENNReal.tsum_schlomilch_le","module":"Mathlib.Analysis.PSeries","initialProofState":"u : Nat → Nat\nf : Nat → ENNReal\nC : Nat\nhf : ∀ ⦃m n : Nat⦄, LT.lt 1 m → LE.le m n → LE.le (f n) (f m)\nh_pos : ∀ (n : Nat), LT.lt 0 (u n)\nh_nonneg : ∀ (n : Nat), LE.le 0 (f n)\nhu : Monotone u\nh_succ_diff : SuccDiffBounded C u\n⊢ LE.le (tsum fun k => HMul.hMul (HSub.hSub ↑(u (HAdd.hAdd k 1)) ↑(u k)) (f (u k))) (HAdd.hAdd (HMul.hMul (HSub.hSub ↑(u 1) ↑(u 0)) (f (u 0))) (HMul.hMul (↑C) (tsum fun k => f k)))","decl":"theorem tsum_schlomilch_le {C : ℕ} (hf : ∀ ⦃m n⦄, 1 < m → m ≤ n → f n ≤ f m) (h_pos : ∀ n, 0 < u n)\n    (h_nonneg : ∀ n, 0 ≤ f n) (hu : Monotone u) (h_succ_diff : SuccDiffBounded C u) :\n    ∑' k : ℕ, (u (k + 1) - u k) * f (u k) ≤ (u 1 - u 0) * f (u 0) + C * ∑' k, f k := by\n  rw [ENNReal.tsum_eq_iSup_nat' (tendsto_atTop_mono Nat.le_succ tendsto_id)]\n  refine\n    iSup_le fun n =>\n      le_trans ?_\n        (add_le_add_left\n          (mul_le_mul_of_nonneg_left (ENNReal.sum_le_tsum <| Finset.Ico (u 0 + 1) (u n + 1)) ?_) _)\n  · simpa using Finset.sum_schlomilch_le hf h_pos h_nonneg hu h_succ_diff n\n  · exact zero_le _\n\n"}
{"name":"ENNReal.tsum_condensed_le","module":"Mathlib.Analysis.PSeries","initialProofState":"f : Nat → ENNReal\nhf : ∀ ⦃m n : Nat⦄, LT.lt 1 m → LE.le m n → LE.le (f n) (f m)\n⊢ LE.le (tsum fun k => HMul.hMul (HPow.hPow 2 k) (f (HPow.hPow 2 k))) (HAdd.hAdd (f 1) (HMul.hMul 2 (tsum fun k => f k)))","decl":"theorem tsum_condensed_le (hf : ∀ ⦃m n⦄, 1 < m → m ≤ n → f n ≤ f m) :\n    (∑' k : ℕ, 2 ^ k * f (2 ^ k)) ≤ f 1 + 2 * ∑' k, f k := by\n  rw [ENNReal.tsum_eq_iSup_nat' (tendsto_atTop_mono Nat.le_succ tendsto_id), two_mul, ← two_nsmul]\n  refine\n    iSup_le fun n =>\n      le_trans ?_\n        (add_le_add_left\n          (nsmul_le_nsmul_right (ENNReal.sum_le_tsum <| Finset.Ico 2 (2 ^ n + 1)) _) _)\n  simpa using Finset.sum_condensed_le hf n\n\n"}
{"name":"NNReal.summable_schlomilch_iff","module":"Mathlib.Analysis.PSeries","initialProofState":"C : Nat\nu : Nat → Nat\nf : Nat → NNReal\nhf : ∀ ⦃m n : Nat⦄, LT.lt 0 m → LE.le m n → LE.le (f n) (f m)\nh_pos : ∀ (n : Nat), LT.lt 0 (u n)\nhu_strict : StrictMono u\nhC_nonzero : Ne C 0\nh_succ_diff : SuccDiffBounded C u\n⊢ Iff (Summable fun k => HMul.hMul (HSub.hSub ↑(u (HAdd.hAdd k 1)) ↑(u k)) (f (u k))) (Summable f)","decl":"open ENNReal in\n/-- for a series of `NNReal` version. -/\ntheorem summable_schlomilch_iff {C : ℕ} {u : ℕ → ℕ} {f : ℕ → ℝ≥0}\n    (hf : ∀ ⦃m n⦄, 0 < m → m ≤ n → f n ≤ f m)\n    (h_pos : ∀ n, 0 < u n) (hu_strict : StrictMono u)\n    (hC_nonzero : C ≠ 0) (h_succ_diff : SuccDiffBounded C u) :\n    (Summable fun k : ℕ => (u (k + 1) - (u k : ℝ≥0)) * f (u k)) ↔ Summable f := by\n  simp only [← tsum_coe_ne_top_iff_summable, Ne, not_iff_not, ENNReal.coe_mul]\n  constructor <;> intro h\n  · replace hf : ∀ m n, 1 < m → m ≤ n → (f n : ℝ≥0∞) ≤ f m := fun m n hm hmn =>\n      ENNReal.coe_le_coe.2 (hf (zero_lt_one.trans hm) hmn)\n    have h_nonneg : ∀ n, 0 ≤ (f n : ℝ≥0∞) := fun n =>\n      ENNReal.coe_le_coe.2 (f n).2\n    obtain hC := tsum_schlomilch_le hf h_pos h_nonneg hu_strict.monotone h_succ_diff\n    simpa [add_eq_top, mul_ne_top, mul_eq_top, hC_nonzero] using eq_top_mono hC h\n  · replace hf : ∀ m n, 0 < m → m ≤ n → (f n : ℝ≥0∞) ≤ f m := fun m n hm hmn =>\n      ENNReal.coe_le_coe.2 (hf hm hmn)\n    have : ∑ k ∈ range (u 0), (f k : ℝ≥0∞) ≠ ∞ := sum_ne_top.2 fun a _ => coe_ne_top\n    simpa [h, add_eq_top, this] using le_tsum_schlomilch hf h_pos hu_strict\n\n"}
{"name":"NNReal.summable_condensed_iff","module":"Mathlib.Analysis.PSeries","initialProofState":"f : Nat → NNReal\nhf : ∀ ⦃m n : Nat⦄, LT.lt 0 m → LE.le m n → LE.le (f n) (f m)\n⊢ Iff (Summable fun k => HMul.hMul (HPow.hPow 2 k) (f (HPow.hPow 2 k))) (Summable f)","decl":"open ENNReal in\ntheorem summable_condensed_iff {f : ℕ → ℝ≥0} (hf : ∀ ⦃m n⦄, 0 < m → m ≤ n → f n ≤ f m) :\n    (Summable fun k : ℕ => (2 : ℝ≥0) ^ k * f (2 ^ k)) ↔ Summable f := by\n  have h_succ_diff : SuccDiffBounded 2 (2 ^ ·) := by\n    intro n\n    simp [pow_succ, mul_two, two_mul]\n  convert summable_schlomilch_iff hf (pow_pos zero_lt_two) (pow_right_strictMono₀ _root_.one_lt_two)\n    two_ne_zero h_succ_diff\n  simp [pow_succ, mul_two, two_mul]\n\n"}
{"name":"summable_schlomilch_iff_of_nonneg","module":"Mathlib.Analysis.PSeries","initialProofState":"C : Nat\nu : Nat → Nat\nf : Nat → Real\nh_nonneg : ∀ (n : Nat), LE.le 0 (f n)\nhf : ∀ ⦃m n : Nat⦄, LT.lt 0 m → LE.le m n → LE.le (f n) (f m)\nh_pos : ∀ (n : Nat), LT.lt 0 (u n)\nhu_strict : StrictMono u\nhC_nonzero : Ne C 0\nh_succ_diff : SuccDiffBounded C u\n⊢ Iff (Summable fun k => HMul.hMul (HSub.hSub ↑(u (HAdd.hAdd k 1)) ↑(u k)) (f (u k))) (Summable f)","decl":"open NNReal in\n/-- for series of nonnegative real numbers. -/\ntheorem summable_schlomilch_iff_of_nonneg {C : ℕ} {u : ℕ → ℕ} {f : ℕ → ℝ} (h_nonneg : ∀ n, 0 ≤ f n)\n    (hf : ∀ ⦃m n⦄, 0 < m → m ≤ n → f n ≤ f m) (h_pos : ∀ n, 0 < u n)\n    (hu_strict : StrictMono u) (hC_nonzero : C ≠ 0) (h_succ_diff : SuccDiffBounded C u) :\n    (Summable fun k : ℕ => (u (k + 1) - (u k : ℝ)) * f (u k)) ↔ Summable f := by\n  lift f to ℕ → ℝ≥0 using h_nonneg\n  simp only [NNReal.coe_le_coe] at *\n  have (k : ℕ) : (u (k + 1) - (u k : ℝ)) = ((u (k + 1) : ℝ≥0) - (u k : ℝ≥0) : ℝ≥0) := by\n    have := Nat.cast_le (α := ℝ≥0).mpr <| (hu_strict k.lt_succ_self).le\n    simp [NNReal.coe_sub this]\n  simp_rw [this]\n  exact_mod_cast NNReal.summable_schlomilch_iff hf h_pos hu_strict hC_nonzero h_succ_diff\n\n"}
{"name":"summable_condensed_iff_of_nonneg","module":"Mathlib.Analysis.PSeries","initialProofState":"f : Nat → Real\nh_nonneg : ∀ (n : Nat), LE.le 0 (f n)\nh_mono : ∀ ⦃m n : Nat⦄, LT.lt 0 m → LE.le m n → LE.le (f n) (f m)\n⊢ Iff (Summable fun k => HMul.hMul (HPow.hPow 2 k) (f (HPow.hPow 2 k))) (Summable f)","decl":"/-- Cauchy condensation test for antitone series of nonnegative real numbers. -/\ntheorem summable_condensed_iff_of_nonneg {f : ℕ → ℝ} (h_nonneg : ∀ n, 0 ≤ f n)\n    (h_mono : ∀ ⦃m n⦄, 0 < m → m ≤ n → f n ≤ f m) :\n    (Summable fun k : ℕ => (2 : ℝ) ^ k * f (2 ^ k)) ↔ Summable f := by\n  have h_succ_diff : SuccDiffBounded 2 (2 ^ ·) := by\n    intro n\n    simp [pow_succ, mul_two, two_mul]\n  convert summable_schlomilch_iff_of_nonneg h_nonneg h_mono (pow_pos zero_lt_two)\n    (pow_right_strictMono₀ one_lt_two) two_ne_zero h_succ_diff\n  simp [pow_succ, mul_two, two_mul]\n\n"}
{"name":"Real.summable_nat_rpow_inv","module":"Mathlib.Analysis.PSeries","initialProofState":"p : Real\n⊢ Iff (Summable fun n => Inv.inv (HPow.hPow (↑n) p)) (LT.lt 1 p)","decl":"/-- Test for convergence of the `p`-series: the real-valued series `∑' n : ℕ, (n ^ p)⁻¹` converges\nif and only if `1 < p`. -/\n@[simp]\ntheorem summable_nat_rpow_inv {p : ℝ} :\n    Summable (fun n => ((n : ℝ) ^ p)⁻¹ : ℕ → ℝ) ↔ 1 < p := by\n  rcases le_or_lt 0 p with hp | hp\n  /- Cauchy condensation test applies only to antitone sequences, so we consider the\n    cases `0 ≤ p` and `p < 0` separately. -/\n  · rw [← summable_condensed_iff_of_nonneg]\n    · simp_rw [Nat.cast_pow, Nat.cast_two, ← rpow_natCast, ← rpow_mul zero_lt_two.le, mul_comm _ p,\n        rpow_mul zero_lt_two.le, rpow_natCast, ← inv_pow, ← mul_pow,\n        summable_geometric_iff_norm_lt_one]\n      nth_rw 1 [← rpow_one 2]\n      rw [← division_def, ← rpow_sub zero_lt_two, norm_eq_abs,\n        abs_of_pos (rpow_pos_of_pos zero_lt_two _), rpow_lt_one_iff zero_lt_two.le]\n      norm_num\n    · intro n\n      positivity\n    · intro m n hm hmn\n      gcongr\n  -- If `p < 0`, then `1 / n ^ p` tends to infinity, thus the series diverges.\n  · suffices ¬Summable (fun n => ((n : ℝ) ^ p)⁻¹ : ℕ → ℝ) by\n      have : ¬1 < p := fun hp₁ => hp.not_le (zero_le_one.trans hp₁.le)\n      simpa only [this, iff_false]\n    intro h\n    obtain ⟨k : ℕ, hk₁ : ((k : ℝ) ^ p)⁻¹ < 1, hk₀ : k ≠ 0⟩ :=\n      ((h.tendsto_cofinite_zero.eventually (gt_mem_nhds zero_lt_one)).and\n          (eventually_cofinite_ne 0)).exists\n    apply hk₀\n    rw [← pos_iff_ne_zero, ← @Nat.cast_pos ℝ] at hk₀\n    simpa [inv_lt_one₀ (rpow_pos_of_pos hk₀ _), one_lt_rpow_iff_of_pos hk₀, hp,\n      hp.not_lt, hk₀] using hk₁\n\n"}
{"name":"Real.summable_nat_rpow","module":"Mathlib.Analysis.PSeries","initialProofState":"p : Real\n⊢ Iff (Summable fun n => HPow.hPow (↑n) p) (LT.lt p (-1))","decl":"@[simp]\ntheorem summable_nat_rpow {p : ℝ} : Summable (fun n => (n : ℝ) ^ p : ℕ → ℝ) ↔ p < -1 := by\n  rcases neg_surjective p with ⟨p, rfl⟩\n  simp [rpow_neg]\n\n"}
{"name":"Real.summable_one_div_nat_rpow","module":"Mathlib.Analysis.PSeries","initialProofState":"p : Real\n⊢ Iff (Summable fun n => HDiv.hDiv 1 (HPow.hPow (↑n) p)) (LT.lt 1 p)","decl":"/-- Test for convergence of the `p`-series: the real-valued series `∑' n : ℕ, 1 / n ^ p` converges\nif and only if `1 < p`. -/\ntheorem summable_one_div_nat_rpow {p : ℝ} :\n    Summable (fun n => 1 / (n : ℝ) ^ p : ℕ → ℝ) ↔ 1 < p := by\n  simp\n\n"}
{"name":"Real.summable_nat_pow_inv","module":"Mathlib.Analysis.PSeries","initialProofState":"p : Nat\n⊢ Iff (Summable fun n => Inv.inv (HPow.hPow (↑n) p)) (LT.lt 1 p)","decl":"/-- Test for convergence of the `p`-series: the real-valued series `∑' n : ℕ, (n ^ p)⁻¹` converges\nif and only if `1 < p`. -/\n@[simp]\ntheorem summable_nat_pow_inv {p : ℕ} :\n    Summable (fun n => ((n : ℝ) ^ p)⁻¹ : ℕ → ℝ) ↔ 1 < p := by\n  simp only [← rpow_natCast, summable_nat_rpow_inv, Nat.one_lt_cast]\n\n"}
{"name":"Real.summable_one_div_nat_pow","module":"Mathlib.Analysis.PSeries","initialProofState":"p : Nat\n⊢ Iff (Summable fun n => HDiv.hDiv 1 (HPow.hPow (↑n) p)) (LT.lt 1 p)","decl":"/-- Test for convergence of the `p`-series: the real-valued series `∑' n : ℕ, 1 / n ^ p` converges\nif and only if `1 < p`. -/\ntheorem summable_one_div_nat_pow {p : ℕ} :\n    Summable (fun n => 1 / (n : ℝ) ^ p : ℕ → ℝ) ↔ 1 < p := by\n  simp only [one_div, Real.summable_nat_pow_inv]\n\n"}
{"name":"Real.summable_one_div_int_pow","module":"Mathlib.Analysis.PSeries","initialProofState":"p : Nat\n⊢ Iff (Summable fun n => HDiv.hDiv 1 (HPow.hPow (↑n) p)) (LT.lt 1 p)","decl":"/-- Summability of the `p`-series over `ℤ`. -/\ntheorem summable_one_div_int_pow {p : ℕ} :\n    (Summable fun n : ℤ ↦ 1 / (n : ℝ) ^ p) ↔ 1 < p := by\n  refine ⟨fun h ↦ summable_one_div_nat_pow.mp (h.comp_injective Nat.cast_injective),\n    fun h ↦ .of_nat_of_neg (summable_one_div_nat_pow.mpr h)\n      (((summable_one_div_nat_pow.mpr h).mul_left <| 1 / (-1 : ℝ) ^ p).congr fun n ↦ ?_)⟩\n  rw [Int.cast_neg, Int.cast_natCast, neg_eq_neg_one_mul (n : ℝ), mul_pow, mul_one_div, div_div]\n\n"}
{"name":"Real.summable_abs_int_rpow","module":"Mathlib.Analysis.PSeries","initialProofState":"b : Real\nhb : LT.lt 1 b\n⊢ Summable fun n => HPow.hPow (abs ↑n) (Neg.neg b)","decl":"theorem summable_abs_int_rpow {b : ℝ} (hb : 1 < b) :\n    Summable fun n : ℤ => |(n : ℝ)| ^ (-b) := by\n  apply Summable.of_nat_of_neg\n  on_goal 2 => simp_rw [Int.cast_neg, abs_neg]\n  all_goals\n    simp_rw [Int.cast_natCast, fun n : ℕ => abs_of_nonneg (n.cast_nonneg : 0 ≤ (n : ℝ))]\n    rwa [summable_nat_rpow, neg_lt_neg_iff]\n\n"}
{"name":"Real.not_summable_natCast_inv","module":"Mathlib.Analysis.PSeries","initialProofState":"⊢ Not (Summable fun n => Inv.inv ↑n)","decl":"/-- Harmonic series is not unconditionally summable. -/\ntheorem not_summable_natCast_inv : ¬Summable (fun n => n⁻¹ : ℕ → ℝ) := by\n  have : ¬Summable (fun n => ((n : ℝ) ^ 1)⁻¹ : ℕ → ℝ) :=\n    mt (summable_nat_pow_inv (p := 1)).1 (lt_irrefl 1)\n  simpa\n\n"}
{"name":"Real.not_summable_one_div_natCast","module":"Mathlib.Analysis.PSeries","initialProofState":"⊢ Not (Summable fun n => HDiv.hDiv 1 ↑n)","decl":"/-- Harmonic series is not unconditionally summable. -/\ntheorem not_summable_one_div_natCast : ¬Summable (fun n => 1 / n : ℕ → ℝ) := by\n  simpa only [inv_eq_one_div] using not_summable_natCast_inv\n\n"}
{"name":"Real.tendsto_sum_range_one_div_nat_succ_atTop","module":"Mathlib.Analysis.PSeries","initialProofState":"⊢ Filter.Tendsto (fun n => (Finset.range n).sum fun i => HDiv.hDiv 1 (HAdd.hAdd (↑i) 1)) Filter.atTop Filter.atTop","decl":"/-- **Divergence of the Harmonic Series** -/\ntheorem tendsto_sum_range_one_div_nat_succ_atTop :\n    Tendsto (fun n => ∑ i ∈ Finset.range n, (1 / (i + 1) : ℝ)) atTop atTop := by\n  rw [← not_summable_iff_tendsto_nat_atTop_of_nonneg]\n  · exact_mod_cast mt (_root_.summable_nat_add_iff 1).1 not_summable_one_div_natCast\n  · exact fun i => by positivity\n\n"}
{"name":"NNReal.summable_rpow_inv","module":"Mathlib.Analysis.PSeries","initialProofState":"p : Real\n⊢ Iff (Summable fun n => Inv.inv (HPow.hPow (↑n) p)) (LT.lt 1 p)","decl":"@[simp]\ntheorem summable_rpow_inv {p : ℝ} :\n    Summable (fun n => ((n : ℝ≥0) ^ p)⁻¹ : ℕ → ℝ≥0) ↔ 1 < p := by\n  simp [← NNReal.summable_coe]\n\n"}
{"name":"NNReal.summable_rpow","module":"Mathlib.Analysis.PSeries","initialProofState":"p : Real\n⊢ Iff (Summable fun n => HPow.hPow (↑n) p) (LT.lt p (-1))","decl":"@[simp]\ntheorem summable_rpow {p : ℝ} : Summable (fun n => (n : ℝ≥0) ^ p : ℕ → ℝ≥0) ↔ p < -1 := by\n  simp [← NNReal.summable_coe]\n\n"}
{"name":"NNReal.summable_one_div_rpow","module":"Mathlib.Analysis.PSeries","initialProofState":"p : Real\n⊢ Iff (Summable fun n => HDiv.hDiv 1 (HPow.hPow (↑n) p)) (LT.lt 1 p)","decl":"theorem summable_one_div_rpow {p : ℝ} :\n    Summable (fun n => 1 / (n : ℝ≥0) ^ p : ℕ → ℝ≥0) ↔ 1 < p := by\n  simp\n\n"}
{"name":"sum_Ioc_inv_sq_le_sub","module":"Mathlib.Analysis.PSeries","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nk n : Nat\nhk : Ne k 0\nh : LE.le k n\n⊢ LE.le ((Finset.Ioc k n).sum fun i => Inv.inv (HPow.hPow (↑i) 2)) (HSub.hSub (Inv.inv ↑k) (Inv.inv ↑n))","decl":"theorem sum_Ioc_inv_sq_le_sub {k n : ℕ} (hk : k ≠ 0) (h : k ≤ n) :\n    (∑ i ∈ Ioc k n, ((i : α) ^ 2)⁻¹) ≤ (k : α)⁻¹ - (n : α)⁻¹ := by\n  refine Nat.le_induction ?_ ?_ n h\n  · simp only [Ioc_self, sum_empty, sub_self, le_refl]\n  intro n hn IH\n  rw [sum_Ioc_succ_top hn]\n  apply (add_le_add IH le_rfl).trans\n  simp only [sub_eq_add_neg, add_assoc, Nat.cast_add, Nat.cast_one, le_add_neg_iff_add_le,\n    add_le_iff_nonpos_right, neg_add_le_iff_le_add, add_zero]\n  have A : 0 < (n : α) := by simpa using hk.bot_lt.trans_le hn\n  field_simp\n  rw [div_le_div_iff₀ _ A]\n  · linarith\n  · positivity\n\n"}
{"name":"sum_Ioo_inv_sq_le","module":"Mathlib.Analysis.PSeries","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nk n : Nat\n⊢ LE.le ((Finset.Ioo k n).sum fun i => Inv.inv (HPow.hPow (↑i) 2)) (HDiv.hDiv 2 (HAdd.hAdd (↑k) 1))","decl":"theorem sum_Ioo_inv_sq_le (k n : ℕ) : (∑ i ∈ Ioo k n, (i ^ 2 : α)⁻¹) ≤ 2 / (k + 1) :=\n  calc\n    (∑ i ∈ Ioo k n, ((i : α) ^ 2)⁻¹) ≤ ∑ i ∈ Ioc k (max (k + 1) n), ((i : α) ^ 2)⁻¹ := by\n      apply sum_le_sum_of_subset_of_nonneg\n      · intro x hx\n        simp only [mem_Ioo] at hx\n        simp only [hx, hx.2.le, mem_Ioc, le_max_iff, or_true, and_self_iff]\n      · intro i _hi _hident\n        positivity\n    _ ≤ ((k + 1 : α) ^ 2)⁻¹ + ∑ i ∈ Ioc k.succ (max (k + 1) n), ((i : α) ^ 2)⁻¹ := by\n      rw [← Nat.Icc_succ_left, ← Nat.Ico_succ_right, sum_eq_sum_Ico_succ_bot]\n      swap; · exact Nat.succ_lt_succ ((Nat.lt_succ_self k).trans_le (le_max_left _ _))\n      rw [Nat.Ico_succ_right, Nat.Icc_succ_left, Nat.cast_succ]\n    _ ≤ ((k + 1 : α) ^ 2)⁻¹ + (k + 1 : α)⁻¹ := by\n      refine add_le_add le_rfl ((sum_Ioc_inv_sq_le_sub ?_ (le_max_left _ _)).trans ?_)\n      · simp only [Ne, Nat.succ_ne_zero, not_false_iff]\n      · simp only [Nat.cast_succ, one_div, sub_le_self_iff, inv_nonneg, Nat.cast_nonneg]\n    _ ≤ 1 / (k + 1) + 1 / (k + 1) := by\n      have A : (1 : α) ≤ k + 1 := by simp only [le_add_iff_nonneg_left, Nat.cast_nonneg]\n      simp_rw [← one_div]\n      gcongr\n      simpa using pow_right_mono₀ A one_le_two\n    _ = 2 / (k + 1) := by ring\n\n"}
{"name":"Real.not_summable_indicator_one_div_natCast","module":"Mathlib.Analysis.PSeries","initialProofState":"m : Nat\nhm : Ne m 0\nk : ZMod m\n⊢ Not (Summable ((setOf fun n => Eq (↑n) k).indicator fun n => HDiv.hDiv 1 ↑n))","decl":"open Set Nat in\n/-- The harmonic series restricted to a residue class is not summable. -/\nlemma Real.not_summable_indicator_one_div_natCast {m : ℕ} (hm : m ≠ 0) (k : ZMod m) :\n    ¬ Summable ({n : ℕ | (n : ZMod m) = k}.indicator fun n : ℕ ↦ (1 / n : ℝ)) := by\n  have : NeZero m := ⟨hm⟩ -- instance is needed below\n  rw [← summable_nat_add_iff 1] -- shift by one to avoid non-monotonicity at zero\n  have h (n : ℕ) : {n : ℕ | (n : ZMod m) = k - 1}.indicator (fun n : ℕ ↦ (1 / (n + 1 :) : ℝ)) n =\n      if (n : ZMod m) = k - 1 then (1 / (n + 1) : ℝ) else (0 : ℝ) := by\n    simp only [indicator_apply, mem_setOf_eq, cast_add, cast_one]\n  simp_rw [indicator_apply, mem_setOf, cast_add, cast_one, ← eq_sub_iff_add_eq, ← h]\n  rw [summable_indicator_mod_iff (fun n₁ n₂ h ↦ by gcongr) (k - 1)]\n  exact mt (summable_nat_add_iff (f := fun n : ℕ ↦ 1 / (n : ℝ)) 1).mp not_summable_one_div_natCast\n\n"}
{"name":"Real.summable_one_div_nat_add_rpow","module":"Mathlib.Analysis.PSeries","initialProofState":"a s : Real\n⊢ Iff (Summable fun n => HDiv.hDiv 1 (HPow.hPow (abs (HAdd.hAdd (↑n) a)) s)) (LT.lt 1 s)","decl":"lemma Real.summable_one_div_nat_add_rpow (a : ℝ) (s : ℝ) :\n    Summable (fun n : ℕ ↦ 1 / |n + a| ^ s) ↔ 1 < s := by\n  suffices ∀ (b c : ℝ), Summable (fun n : ℕ ↦ 1 / |n + b| ^ s) →\n      Summable (fun n : ℕ ↦ 1 / |n + c| ^ s) by\n    simp_rw [← summable_one_div_nat_rpow, Iff.intro (this a 0) (this 0 a), add_zero, Nat.abs_cast]\n  refine fun b c h ↦ summable_of_isBigO_nat h (isBigO_of_div_tendsto_nhds ?_ 1 ?_)\n  · filter_upwards [eventually_gt_atTop (Nat.ceil |b|)] with n hn hx\n    have hna : 0 < n + b := by linarith [lt_of_abs_lt ((abs_neg b).symm ▸ Nat.lt_of_ceil_lt hn)]\n    exfalso\n    revert hx\n    positivity\n  · simp_rw [Pi.div_def, div_div, mul_one_div, one_div_div]\n    refine (?_ : Tendsto (fun x : ℝ ↦ |x + b| ^ s / |x + c| ^ s) atTop (𝓝 1)).comp\n      tendsto_natCast_atTop_atTop\n    have : Tendsto (fun x : ℝ ↦ 1 + (b - c) / x) atTop (𝓝 1) := by\n      simpa using tendsto_const_nhds.add ((tendsto_const_nhds (X := ℝ)).div_atTop tendsto_id)\n    have : Tendsto (fun x ↦ (x + b) / (x + c)) atTop (𝓝 1) := by\n      refine (this.comp (tendsto_id.atTop_add (tendsto_const_nhds (x := c)))).congr' ?_\n      filter_upwards [eventually_gt_atTop (-c)] with x hx\n      field_simp [(by linarith : 0 < x + c).ne']\n    apply (one_rpow s ▸ (continuousAt_rpow_const _ s (by simp)).tendsto.comp this).congr'\n    filter_upwards [eventually_gt_atTop (-b), eventually_gt_atTop (-c)] with x hb hc\n    rw [neg_lt_iff_pos_add] at hb hc\n    rw [Function.comp_apply, div_rpow hb.le hc.le, abs_of_pos hb, abs_of_pos hc]\n\n"}
{"name":"Real.summable_one_div_int_add_rpow","module":"Mathlib.Analysis.PSeries","initialProofState":"a s : Real\n⊢ Iff (Summable fun n => HDiv.hDiv 1 (HPow.hPow (abs (HAdd.hAdd (↑n) a)) s)) (LT.lt 1 s)","decl":"lemma Real.summable_one_div_int_add_rpow (a : ℝ) (s : ℝ) :\n    Summable (fun n : ℤ ↦ 1 / |n + a| ^ s) ↔ 1 < s := by\n  simp_rw [summable_int_iff_summable_nat_and_neg, ← abs_neg (↑(-_ : ℤ) + a), neg_add,\n    Int.cast_neg, neg_neg, Int.cast_natCast, summable_one_div_nat_add_rpow, and_self]\n\n"}
{"name":"summable_pow_div_add","module":"Mathlib.Analysis.PSeries","initialProofState":"α : Type u_1\nx : α\ninst✝ : RCLike α\nq k : Nat\nhq : LT.lt 1 q\n⊢ Summable fun n => Norm.norm (HDiv.hDiv x (HPow.hPow (HAdd.hAdd ↑n ↑k) q))","decl":"theorem summable_pow_div_add {α : Type*} (x : α) [RCLike α] (q k : ℕ) (hq : 1 < q) :\n    Summable fun n : ℕ => ‖(x / (↑n + k) ^ q)‖ := by\n  simp_rw [norm_div]\n  apply Summable.const_div\n  simpa [hq, Nat.cast_add, one_div, norm_inv, norm_pow, Complex.norm_eq_abs,\n    RCLike.norm_natCast, Real.summable_nat_pow_inv, iff_true]\n    using summable_nat_add_iff (f := fun x => ‖1 / (x ^ q : α)‖) k\n\n"}
