{"name":"ProperSpace.of_nontriviallyNormedField_of_weaklyLocallyCompactSpace","module":"Mathlib.Analysis.Normed.Field.ProperSpace","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ\ninstâœ : WeaklyLocallyCompactSpace ğ•œ\nâŠ¢ ProperSpace ğ•œ","decl":"/-- A weakly locally compact normed field is proper.\nThis is a specialization of `ProperSpace.of_locallyCompactSpace`\nwhich holds for `NormedSpace`s but requires more imports. -/\nlemma ProperSpace.of_nontriviallyNormedField_of_weaklyLocallyCompactSpace\n    (ğ•œ : Type*) [NontriviallyNormedField ğ•œ] [WeaklyLocallyCompactSpace ğ•œ] :\n    ProperSpace ğ•œ := by\n  rcases exists_isCompact_closedBall (0 : ğ•œ) with âŸ¨r, rpos, hrâŸ©\n  rcases NormedField.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©\n  have hC n : IsCompact (closedBall (0 : ğ•œ) (â€–câ€–^n * r)) := by\n    have : c ^ n â‰  0 := pow_ne_zero _ <| fun h â†¦ by simp [h, zero_le_one.not_lt] at hc\n    convert hr.smul (c ^ n)\n    ext\n    simp only [mem_closedBall, dist_zero_right, Set.mem_smul_set_iff_inv_smul_memâ‚€ this,\n      smul_eq_mul, norm_mul, norm_inv, norm_pow,\n      inv_mul_le_iffâ‚€ (by simpa only [norm_pow] using norm_pos_iff.mpr this)]\n  have hTop : Tendsto (fun n â†¦ â€–câ€–^n * r) atTop atTop :=\n    Tendsto.atTop_mul_const rpos (tendsto_pow_atTop_atTop_of_one_lt hc)\n  exact .of_seq_closedBall hTop (Eventually.of_forall hC)\n"}
