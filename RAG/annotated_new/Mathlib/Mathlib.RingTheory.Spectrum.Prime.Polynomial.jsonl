{"name":"isNilpotent_tensor_residueField_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœâµ : CommRing R\ninstâœâ´ : CommRing A\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Module.Free R A\ninstâœÂ¹ : Module.Finite R A\nf : A\nI : Ideal R\ninstâœ : I.IsPrime\nâŠ¢ Iff (IsNilpotent ((algebraMap A (TensorProduct R A I.ResidueField)) f)) (âˆ€ (i : Nat), LT.lt i (Module.finrank R A) â†’ Membership.mem I ((LinearMap.charpoly ((Algebra.lmul R A) f)).coeff i))","decl":"/-- If `A` is a finite free `R`-algebra, then `f : A` is nilpotent on `Îº(ğ”­) âŠ— A` for some\nprime `ğ”­ â—ƒ R` if and only if every non-leading coefficient of `charpoly(f)` is in `ğ”­`. -/\nlemma isNilpotent_tensor_residueField_iff\n    [Module.Free R A] [Module.Finite R A] (f : A) (I : Ideal R) [I.IsPrime] :\n    IsNilpotent (algebraMap A (A âŠ—[R] I.ResidueField) f) â†”\n      âˆ€ i < Module.finrank R A, (Algebra.lmul R A f).charpoly.coeff i âˆˆ I := by\n  cases subsingleton_or_nontrivial R\n  Â· have := (algebraMap R (A âŠ—[R] I.ResidueField)).codomain_trivial\n    simp [Subsingleton.elim I âŠ¤, Subsingleton.elim (f âŠ—â‚œ[R] (1 : I.ResidueField)) 0]\n  have : Module.finrank I.ResidueField (I.ResidueField âŠ—[R] A) = Module.finrank R A := by\n    rw [Module.finrank_tensorProduct, Module.finrank_self, one_mul]\n  rw [â† IsNilpotent.map_iff (Algebra.TensorProduct.comm R A I.ResidueField).injective]\n  simp only [Algebra.TensorProduct.algebraMap_apply, Algebra.id.map_eq_id, RingHom.id_apply,\n    Algebra.coe_lmul_eq_mul, Algebra.TensorProduct.comm_tmul]\n  rw [â† IsNilpotent.map_iff (Algebra.lmul_injective (R := I.ResidueField)),\n    LinearMap.isNilpotent_iff_charpoly, â† Algebra.baseChange_lmul, LinearMap.charpoly_baseChange]\n  simp_rw [this, â† ((LinearMap.mul R A) f).charpoly_natDegree]\n  constructor\n  Â· intro e i hi\n    replace e := congr(($e).coeff i)\n    simpa only [Algebra.coe_lmul_eq_mul, coeff_map, coeff_X_pow, hi.ne, â†“reduceIte,\n      â† RingHom.mem_ker, Ideal.ker_algebraMap_residueField] using e\n  Â· intro H\n    ext i\n    obtain (hi | hi) := eq_or_ne i ((LinearMap.mul R A) f).charpoly.natDegree\n    Â· simp only [Algebra.coe_lmul_eq_mul, hi, coeff_map, coeff_X_pow, â†“reduceIte]\n      rw [â† Polynomial.leadingCoeff, ((LinearMap.mul R A) f).charpoly_monic, map_one]\n    obtain (hi | hi) := lt_or_gt_of_ne hi\n    Â· simpa [hi.ne, â† RingHom.mem_ker, Ideal.ker_algebraMap_residueField] using H i hi\n    Â· simp [hi.ne', coeff_eq_zero_of_natDegree_lt hi]\n\n"}
{"name":"PrimeSpectrum.mem_image_comap_zeroLocus_sdiff","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_2\nA : Type u_1\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing A\ninstâœ : Algebra R A\nf : A\ns : Set A\nx : PrimeSpectrum R\nâŠ¢ Iff (Membership.mem (Set.image (â‡‘(PrimeSpectrum.comap (algebraMap R A))) (SDiff.sdiff (PrimeSpectrum.zeroLocus s) (PrimeSpectrum.zeroLocus (Singleton.singleton f)))) x) (Not (IsNilpotent ((algebraMap A (TensorProduct R (HasQuotient.Quotient A (Ideal.span s)) x.asIdeal.ResidueField)) f)))","decl":"/-- Let `A` be an `R`-algebra.\n`ğ”­ : Spec R` is in the image of `Z(I) âˆ© D(f) âŠ† Spec S`\nif and only if `f` is not nilpotent on `Îº(ğ”­) âŠ— A â§¸ I`. -/\nlemma mem_image_comap_zeroLocus_sdiff (f : A) (s : Set A) (x) :\n    x âˆˆ comap (algebraMap R A) '' (zeroLocus s \\ zeroLocus {f}) â†”\n      Â¬ IsNilpotent (algebraMap A ((A â§¸ Ideal.span s) âŠ—[R] x.asIdeal.ResidueField) f) := by\n  constructor\n  Â· rintro âŸ¨q, âŸ¨hqg, hqfâŸ©, rflâŸ© H\n    simp only [mem_zeroLocus, Set.singleton_subset_iff, SetLike.mem_coe] at hqg hqf\n    have hs : Ideal.span s â‰¤ RingHom.ker (algebraMap A q.asIdeal.ResidueField) := by\n      rwa [Ideal.span_le, Ideal.ker_algebraMap_residueField]\n    let F : (A â§¸ Ideal.span s) âŠ—[R] (q.asIdeal.comap (algebraMap R A)).ResidueField â†’â‚[A]\n        q.asIdeal.ResidueField :=\n      Algebra.TensorProduct.lift\n        (Ideal.Quotient.liftâ‚ (Ideal.span s) (Algebra.ofId A _) hs)\n        (Ideal.ResidueField.mapâ‚ _ _ rfl)\n        fun _ _ â†¦ .all _ _\n    have := H.map F\n    rw [AlgHom.commutes, isNilpotent_iff_eq_zero, â† RingHom.mem_ker,\n      Ideal.ker_algebraMap_residueField] at this\n    exact hqf this\n  Â· intro H\n    rw [â† mem_nilradical, nilradical_eq_sInf, Ideal.mem_sInf] at H\n    simp only [Set.mem_setOf_eq, Algebra.TensorProduct.algebraMap_apply,\n      Ideal.Quotient.algebraMap_eq, not_forall, Classical.not_imp] at H\n    obtain âŸ¨q, hq, hfqâŸ© := H\n    have : âˆ€ a âˆˆ s, Ideal.Quotient.mk (Ideal.span s) a âŠ—â‚œ[R] 1 âˆˆ q := fun a ha â†¦ by\n      simp [Ideal.Quotient.eq_zero_iff_mem.mpr (Ideal.subset_span ha)]\n    refine âŸ¨comap (algebraMap A _) âŸ¨q, hqâŸ©, âŸ¨by simpa [Set.subset_def], by simpaâŸ©, ?_âŸ©\n    rw [â† comap_comp_apply, â† IsScalarTower.algebraMap_eq,\n      â† Algebra.TensorProduct.includeRight.comp_algebraMap, comap_comp_apply,\n      Subsingleton.elim (Î± := PrimeSpectrum x.asIdeal.ResidueField) (comap _ _) âŠ¥]\n    ext a\n    exact congr(a âˆˆ $(Ideal.ker_algebraMap_residueField _))\n\n"}
{"name":"PrimeSpectrum.mem_image_comap_basicOpen","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing A\ninstâœ : Algebra R A\nf : A\nx : PrimeSpectrum R\nâŠ¢ Iff (Membership.mem (Set.image â‡‘(PrimeSpectrum.comap (algebraMap R A)) â†‘(PrimeSpectrum.basicOpen f)) x) (Not (IsNilpotent ((algebraMap A (TensorProduct R A x.asIdeal.ResidueField)) f)))","decl":"/-- Let `A` be an `R`-algebra.\n`ğ”­ : Spec R` is in the image of `D(f) âŠ† Spec S`\nif and only if `f` is not nilpotent on `Îº(ğ”­) âŠ— A`. -/\nlemma mem_image_comap_basicOpen (f : A) (x) :\n    x âˆˆ comap (algebraMap R A) '' basicOpen f â†”\n      Â¬ IsNilpotent (algebraMap A (A âŠ—[R] x.asIdeal.ResidueField) f) := by\n  have e : A âŠ—[R] x.asIdeal.ResidueField â‰ƒâ‚[A]\n      (A â§¸ (Ideal.span âˆ… : Ideal A)) âŠ—[R] x.asIdeal.ResidueField := by\n    refine Algebra.TensorProduct.congr ?f AlgEquiv.refl\n    rw [Ideal.span_empty]\n    exact { __ := (RingEquiv.quotientBot A).symm, __ := Algebra.ofId _ _ }\n  rw [â† IsNilpotent.map_iff e.injective, AlgEquiv.commutes,\n    â† mem_image_comap_zeroLocus_sdiff f âˆ… x, zeroLocus_empty, â† Set.compl_eq_univ_diff,\n    basicOpen_eq_zeroLocus_compl]\n\n"}
{"name":"PrimeSpectrum.exists_image_comap_of_finite_of_free","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_2\nA : Type u_1\ninstâœâ´ : CommRing R\ninstâœÂ³ : CommRing A\ninstâœÂ² : Algebra R A\nf : A\ns : Set A\ninstâœÂ¹ : Module.Finite R (HasQuotient.Quotient A (Ideal.span s))\ninstâœ : Module.Free R (HasQuotient.Quotient A (Ideal.span s))\nâŠ¢ Exists fun t => Eq (Set.image (â‡‘(PrimeSpectrum.comap (algebraMap R A))) (SDiff.sdiff (PrimeSpectrum.zeroLocus s) (PrimeSpectrum.zeroLocus (Singleton.singleton f)))) (HasCompl.compl (PrimeSpectrum.zeroLocus â†‘t))","decl":"/-- Let `A` be an `R`-algebra. If `A â§¸ I` is finite free over `R`,\nthen the image of `Z(I) âˆ© D(f) âŠ† Spec S` in `Spec R` is compact open. -/\nlemma exists_image_comap_of_finite_of_free (f : A) (s : Set A)\n    [Module.Finite R (A â§¸ Ideal.span s)] [Module.Free R (A â§¸ Ideal.span s)] :\n    âˆƒ t : Finset R, comap (algebraMap R A) '' (zeroLocus s \\ zeroLocus {f}) = (zeroLocus t)á¶œ := by\n  classical\n  use (Finset.range (Module.finrank R (A â§¸ Ideal.span s))).image\n    (Algebra.lmul R (A â§¸ Ideal.span s) (Ideal.Quotient.mk _ f)).charpoly.coeff\n  ext x\n  rw [mem_image_comap_zeroLocus_sdiff, IsScalarTower.algebraMap_apply A (A â§¸ Ideal.span s),\n    isNilpotent_tensor_residueField_iff]\n  simp [Set.subset_def]\n\n"}
{"name":"Polynomial.mem_image_comap_C_basicOpen","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_1\ninstâœ : CommRing R\nf : Polynomial R\nx : PrimeSpectrum R\nâŠ¢ Iff (Membership.mem (Set.image â‡‘(PrimeSpectrum.comap Polynomial.C) â†‘(PrimeSpectrum.basicOpen f)) x) (Exists fun i => Not (Membership.mem x.asIdeal (f.coeff i)))","decl":"lemma mem_image_comap_C_basicOpen (f : R[X]) (x : PrimeSpectrum R) :\n    x âˆˆ comap C '' basicOpen f â†” âˆƒ i, f.coeff i âˆ‰ x.asIdeal := by\n  trans f.map (algebraMap R x.asIdeal.ResidueField) â‰  0\n  Â· refine (mem_image_comap_basicOpen _ _).trans (not_iff_not.mpr ?_)\n    let e : R[X] âŠ—[R] x.asIdeal.ResidueField â‰ƒâ‚[R] x.asIdeal.ResidueField[X] :=\n      (Algebra.TensorProduct.comm R _ _).trans (polyEquivTensor R x.asIdeal.ResidueField).symm\n    rw [â† IsNilpotent.map_iff e.injective, isNilpotent_iff_eq_zero]\n    show (e.toAlgHom.toRingHom).comp (algebraMap _ _) f = 0 â†” Polynomial.mapRingHom _ f = 0\n    congr!\n    ext1\n    Â· ext; simp [e]\n    Â· simp [e, monomial_one_one_eq_X]\n  Â· simp [Polynomial.ext_iff]\n\n"}
{"name":"Polynomial.image_comap_C_basicOpen","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_1\ninstâœ : CommRing R\nf : Polynomial R\nâŠ¢ Eq (Set.image â‡‘(PrimeSpectrum.comap Polynomial.C) â†‘(PrimeSpectrum.basicOpen f)) (HasCompl.compl (PrimeSpectrum.zeroLocus (Set.range f.coeff)))","decl":"lemma image_comap_C_basicOpen (f : R[X]) :\n      comap C '' basicOpen f = (zeroLocus (Set.range f.coeff))á¶œ := by\n    ext p\n    rw [mem_image_comap_C_basicOpen]\n    simp [Set.range_subset_iff]\n\n"}
{"name":"Polynomial.isOpenMap_comap_C","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_1\ninstâœ : CommRing R\nâŠ¢ IsOpenMap â‡‘(PrimeSpectrum.comap Polynomial.C)","decl":"lemma isOpenMap_comap_C : IsOpenMap (comap (R := R) C) := by\n  intro U hU\n  obtain âŸ¨S, hS, rflâŸ© := isTopologicalBasis_basic_opens.open_eq_sUnion hU\n  rw [Set.image_sUnion]\n  apply isOpen_sUnion\n  rintro _ âŸ¨t, ht, rflâŸ©\n  obtain âŸ¨r, rflâŸ© := hS ht\n  simp only [image_comap_C_basicOpen]\n  exact (isClosed_zeroLocus _).isOpen_compl\n\n"}
{"name":"Polynomial.comap_C_surjective","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_1\ninstâœ : CommRing R\nâŠ¢ Function.Surjective â‡‘(PrimeSpectrum.comap Polynomial.C)","decl":"lemma comap_C_surjective : Function.Surjective (comap (R := R) C) := by\n  intro x\n  refine âŸ¨comap (evalRingHom 0) x, ?_âŸ©\n  rw [â† comap_comp_apply, (show (evalRingHom 0).comp C = .id R by ext; simp),\n    comap_id, ContinuousMap.id_apply]\n\n"}
{"name":"Polynomial.exists_image_comap_of_monic","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_1\ninstâœ : CommRing R\nf g : Polynomial R\nhg : g.Monic\nâŠ¢ Exists fun t => Eq (Set.image (â‡‘(PrimeSpectrum.comap Polynomial.C)) (SDiff.sdiff (PrimeSpectrum.zeroLocus (Singleton.singleton g)) (PrimeSpectrum.zeroLocus (Singleton.singleton f)))) (HasCompl.compl (PrimeSpectrum.zeroLocus â†‘t))","decl":"lemma exists_image_comap_of_monic (f g : R[X]) (hg : g.Monic) :\n    âˆƒ t : Finset R, comap C '' (zeroLocus {g} \\ zeroLocus {f}) = (zeroLocus t)á¶œ := by\n  apply (config := { allowSynthFailures := true }) exists_image_comap_of_finite_of_free\n  Â· exact .of_basis (AdjoinRoot.powerBasis' hg).basis\n  Â· exact .of_basis (AdjoinRoot.powerBasis' hg).basis\n\n"}
{"name":"Polynomial.isCompact_image_comap_of_monic","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_1\ninstâœ : CommRing R\nf g : Polynomial R\nhg : g.Monic\nâŠ¢ IsCompact (Set.image (â‡‘(PrimeSpectrum.comap Polynomial.C)) (SDiff.sdiff (PrimeSpectrum.zeroLocus (Singleton.singleton g)) (PrimeSpectrum.zeroLocus (Singleton.singleton f))))","decl":"lemma isCompact_image_comap_of_monic (f g : R[X]) (hg : g.Monic) :\n    IsCompact (comap C '' (zeroLocus {g} \\ zeroLocus {f})) := by\n  obtain âŸ¨t, htâŸ© := exists_image_comap_of_monic f g hg\n  rw [ht, â† t.toSet.iUnion_of_singleton_coe, zeroLocus_iUnion, Set.compl_iInter]\n  apply isCompact_iUnion\n  exact fun _ â†¦ by simpa using isCompact_basicOpen _\n\n"}
{"name":"Polynomial.isOpen_image_comap_of_monic","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_1\ninstâœ : CommRing R\nf g : Polynomial R\nhg : g.Monic\nâŠ¢ IsOpen (Set.image (â‡‘(PrimeSpectrum.comap Polynomial.C)) (SDiff.sdiff (PrimeSpectrum.zeroLocus (Singleton.singleton g)) (PrimeSpectrum.zeroLocus (Singleton.singleton f))))","decl":"lemma isOpen_image_comap_of_monic (f g : R[X]) (hg : g.Monic) :\n    IsOpen (comap C '' (zeroLocus {g} \\ zeroLocus {f})) := by\n  obtain âŸ¨t, htâŸ© := exists_image_comap_of_monic f g hg\n  rw [ht]\n  exact (isClosed_zeroLocus (R := R) t).isOpen_compl\n\n"}
{"name":"MvPolynomial.mem_image_comap_C_basicOpen","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_2\ninstâœ : CommRing R\nÏƒ : Type u_1\nf : MvPolynomial Ïƒ R\nx : PrimeSpectrum R\nâŠ¢ Iff (Membership.mem (Set.image â‡‘(PrimeSpectrum.comap MvPolynomial.C) â†‘(PrimeSpectrum.basicOpen f)) x) (Exists fun i => Not (Membership.mem x.asIdeal (MvPolynomial.coeff i f)))","decl":"lemma mem_image_comap_C_basicOpen (f : MvPolynomial Ïƒ R) (x : PrimeSpectrum R) :\n    x âˆˆ comap (C (Ïƒ := Ïƒ)) '' basicOpen f â†” âˆƒ i, f.coeff i âˆ‰ x.asIdeal := by\n  classical\n  trans f.map (algebraMap R x.asIdeal.ResidueField) â‰  0\n  Â· refine (mem_image_comap_basicOpen _ _).trans (not_iff_not.mpr ?_)\n    let e : MvPolynomial Ïƒ R âŠ—[R] x.asIdeal.ResidueField â‰ƒâ‚[R]\n        MvPolynomial Ïƒ x.asIdeal.ResidueField := scalarRTensorAlgEquiv\n    rw [â† IsNilpotent.map_iff e.injective, isNilpotent_iff_eq_zero]\n    show (e.toAlgHom.toRingHom).comp (algebraMap _ _) f = 0 â†” MvPolynomial.map _ f = 0\n    congr!\n    ext\n    Â· simp [scalarRTensorAlgEquiv, e, coeff_map,\n        Algebra.smul_def, apply_ite (f := algebraMap _ _)]\n    Â· simp [e, monomial_one_one_eq_X, scalarRTensorAlgEquiv, coeff_map, coeff_X']\n  Â· simp [MvPolynomial.ext_iff, coeff_map]\n\n"}
{"name":"MvPolynomial.image_comap_C_basicOpen","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_2\ninstâœ : CommRing R\nÏƒ : Type u_1\nf : MvPolynomial Ïƒ R\nâŠ¢ Eq (Set.image â‡‘(PrimeSpectrum.comap MvPolynomial.C) â†‘(PrimeSpectrum.basicOpen f)) (HasCompl.compl (PrimeSpectrum.zeroLocus (Set.range fun m => MvPolynomial.coeff m f)))","decl":"lemma image_comap_C_basicOpen (f : MvPolynomial Ïƒ R) :\n      comap (C (Ïƒ := Ïƒ)) '' basicOpen f = (zeroLocus (Set.range f.coeff))á¶œ := by\n    ext p\n    rw [mem_image_comap_C_basicOpen]\n    simp [Set.range_subset_iff]\n\n"}
{"name":"MvPolynomial.isOpenMap_comap_C","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_2\ninstâœ : CommRing R\nÏƒ : Type u_1\nâŠ¢ IsOpenMap â‡‘(PrimeSpectrum.comap MvPolynomial.C)","decl":"lemma isOpenMap_comap_C : IsOpenMap (comap (R := R) (C (Ïƒ := Ïƒ))) := by\n  intro U hU\n  obtain âŸ¨S, hS, rflâŸ© := isTopologicalBasis_basic_opens.open_eq_sUnion hU\n  rw [Set.image_sUnion]\n  apply isOpen_sUnion\n  rintro _ âŸ¨t, ht, rflâŸ©\n  obtain âŸ¨r, rflâŸ© := hS ht\n  simp only [image_comap_C_basicOpen]\n  exact (isClosed_zeroLocus _).isOpen_compl\n\n"}
{"name":"MvPolynomial.comap_C_surjective","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_2\ninstâœ : CommRing R\nÏƒ : Type u_1\nâŠ¢ Function.Surjective â‡‘(PrimeSpectrum.comap MvPolynomial.C)","decl":"lemma comap_C_surjective : Function.Surjective (comap (R := R) (C (Ïƒ := Ïƒ))) := by\n  intro x\n  refine âŸ¨comap (evalâ‚‚Hom (.id _) 0) x, ?_âŸ©\n  rw [â† comap_comp_apply, (show (evalâ‚‚Hom (.id _) 0).comp C = .id R by ext; simp),\n    comap_id, ContinuousMap.id_apply]\n\n"}
