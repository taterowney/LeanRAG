{"name":"isNilpotent_tensor_residueField_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : Module.Free R A\ninst✝¹ : Module.Finite R A\nf : A\nI : Ideal R\ninst✝ : I.IsPrime\n⊢ Iff (IsNilpotent ((algebraMap A (TensorProduct R A I.ResidueField)) f)) (∀ (i : Nat), LT.lt i (Module.finrank R A) → Membership.mem I ((LinearMap.charpoly ((Algebra.lmul R A) f)).coeff i))","decl":"/-- If `A` is a finite free `R`-algebra, then `f : A` is nilpotent on `κ(𝔭) ⊗ A` for some\nprime `𝔭 ◃ R` if and only if every non-leading coefficient of `charpoly(f)` is in `𝔭`. -/\nlemma isNilpotent_tensor_residueField_iff\n    [Module.Free R A] [Module.Finite R A] (f : A) (I : Ideal R) [I.IsPrime] :\n    IsNilpotent (algebraMap A (A ⊗[R] I.ResidueField) f) ↔\n      ∀ i < Module.finrank R A, (Algebra.lmul R A f).charpoly.coeff i ∈ I := by\n  cases subsingleton_or_nontrivial R\n  · have := (algebraMap R (A ⊗[R] I.ResidueField)).codomain_trivial\n    simp [Subsingleton.elim I ⊤, Subsingleton.elim (f ⊗ₜ[R] (1 : I.ResidueField)) 0]\n  have : Module.finrank I.ResidueField (I.ResidueField ⊗[R] A) = Module.finrank R A := by\n    rw [Module.finrank_tensorProduct, Module.finrank_self, one_mul]\n  rw [← IsNilpotent.map_iff (Algebra.TensorProduct.comm R A I.ResidueField).injective]\n  simp only [Algebra.TensorProduct.algebraMap_apply, Algebra.id.map_eq_id, RingHom.id_apply,\n    Algebra.coe_lmul_eq_mul, Algebra.TensorProduct.comm_tmul]\n  rw [← IsNilpotent.map_iff (Algebra.lmul_injective (R := I.ResidueField)),\n    LinearMap.isNilpotent_iff_charpoly, ← Algebra.baseChange_lmul, LinearMap.charpoly_baseChange]\n  simp_rw [this, ← ((LinearMap.mul R A) f).charpoly_natDegree]\n  constructor\n  · intro e i hi\n    replace e := congr(($e).coeff i)\n    simpa only [Algebra.coe_lmul_eq_mul, coeff_map, coeff_X_pow, hi.ne, ↓reduceIte,\n      ← RingHom.mem_ker, Ideal.ker_algebraMap_residueField] using e\n  · intro H\n    ext i\n    obtain (hi | hi) := eq_or_ne i ((LinearMap.mul R A) f).charpoly.natDegree\n    · simp only [Algebra.coe_lmul_eq_mul, hi, coeff_map, coeff_X_pow, ↓reduceIte]\n      rw [← Polynomial.leadingCoeff, ((LinearMap.mul R A) f).charpoly_monic, map_one]\n    obtain (hi | hi) := lt_or_gt_of_ne hi\n    · simpa [hi.ne, ← RingHom.mem_ker, Ideal.ker_algebraMap_residueField] using H i hi\n    · simp [hi.ne', coeff_eq_zero_of_natDegree_lt hi]\n\n"}
{"name":"PrimeSpectrum.mem_image_comap_zeroLocus_sdiff","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_2\nA : Type u_1\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nf : A\ns : Set A\nx : PrimeSpectrum R\n⊢ Iff (Membership.mem (Set.image (⇑(PrimeSpectrum.comap (algebraMap R A))) (SDiff.sdiff (PrimeSpectrum.zeroLocus s) (PrimeSpectrum.zeroLocus (Singleton.singleton f)))) x) (Not (IsNilpotent ((algebraMap A (TensorProduct R (HasQuotient.Quotient A (Ideal.span s)) x.asIdeal.ResidueField)) f)))","decl":"/-- Let `A` be an `R`-algebra.\n`𝔭 : Spec R` is in the image of `Z(I) ∩ D(f) ⊆ Spec S`\nif and only if `f` is not nilpotent on `κ(𝔭) ⊗ A ⧸ I`. -/\nlemma mem_image_comap_zeroLocus_sdiff (f : A) (s : Set A) (x) :\n    x ∈ comap (algebraMap R A) '' (zeroLocus s \\ zeroLocus {f}) ↔\n      ¬ IsNilpotent (algebraMap A ((A ⧸ Ideal.span s) ⊗[R] x.asIdeal.ResidueField) f) := by\n  constructor\n  · rintro ⟨q, ⟨hqg, hqf⟩, rfl⟩ H\n    simp only [mem_zeroLocus, Set.singleton_subset_iff, SetLike.mem_coe] at hqg hqf\n    have hs : Ideal.span s ≤ RingHom.ker (algebraMap A q.asIdeal.ResidueField) := by\n      rwa [Ideal.span_le, Ideal.ker_algebraMap_residueField]\n    let F : (A ⧸ Ideal.span s) ⊗[R] (q.asIdeal.comap (algebraMap R A)).ResidueField →ₐ[A]\n        q.asIdeal.ResidueField :=\n      Algebra.TensorProduct.lift\n        (Ideal.Quotient.liftₐ (Ideal.span s) (Algebra.ofId A _) hs)\n        (Ideal.ResidueField.mapₐ _ _ rfl)\n        fun _ _ ↦ .all _ _\n    have := H.map F\n    rw [AlgHom.commutes, isNilpotent_iff_eq_zero, ← RingHom.mem_ker,\n      Ideal.ker_algebraMap_residueField] at this\n    exact hqf this\n  · intro H\n    rw [← mem_nilradical, nilradical_eq_sInf, Ideal.mem_sInf] at H\n    simp only [Set.mem_setOf_eq, Algebra.TensorProduct.algebraMap_apply,\n      Ideal.Quotient.algebraMap_eq, not_forall, Classical.not_imp] at H\n    obtain ⟨q, hq, hfq⟩ := H\n    have : ∀ a ∈ s, Ideal.Quotient.mk (Ideal.span s) a ⊗ₜ[R] 1 ∈ q := fun a ha ↦ by\n      simp [Ideal.Quotient.eq_zero_iff_mem.mpr (Ideal.subset_span ha)]\n    refine ⟨comap (algebraMap A _) ⟨q, hq⟩, ⟨by simpa [Set.subset_def], by simpa⟩, ?_⟩\n    rw [← comap_comp_apply, ← IsScalarTower.algebraMap_eq,\n      ← Algebra.TensorProduct.includeRight.comp_algebraMap, comap_comp_apply,\n      Subsingleton.elim (α := PrimeSpectrum x.asIdeal.ResidueField) (comap _ _) ⊥]\n    ext a\n    exact congr(a ∈ $(Ideal.ker_algebraMap_residueField _))\n\n"}
{"name":"PrimeSpectrum.mem_image_comap_basicOpen","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nf : A\nx : PrimeSpectrum R\n⊢ Iff (Membership.mem (Set.image ⇑(PrimeSpectrum.comap (algebraMap R A)) ↑(PrimeSpectrum.basicOpen f)) x) (Not (IsNilpotent ((algebraMap A (TensorProduct R A x.asIdeal.ResidueField)) f)))","decl":"/-- Let `A` be an `R`-algebra.\n`𝔭 : Spec R` is in the image of `D(f) ⊆ Spec S`\nif and only if `f` is not nilpotent on `κ(𝔭) ⊗ A`. -/\nlemma mem_image_comap_basicOpen (f : A) (x) :\n    x ∈ comap (algebraMap R A) '' basicOpen f ↔\n      ¬ IsNilpotent (algebraMap A (A ⊗[R] x.asIdeal.ResidueField) f) := by\n  have e : A ⊗[R] x.asIdeal.ResidueField ≃ₐ[A]\n      (A ⧸ (Ideal.span ∅ : Ideal A)) ⊗[R] x.asIdeal.ResidueField := by\n    refine Algebra.TensorProduct.congr ?f AlgEquiv.refl\n    rw [Ideal.span_empty]\n    exact { __ := (RingEquiv.quotientBot A).symm, __ := Algebra.ofId _ _ }\n  rw [← IsNilpotent.map_iff e.injective, AlgEquiv.commutes,\n    ← mem_image_comap_zeroLocus_sdiff f ∅ x, zeroLocus_empty, ← Set.compl_eq_univ_diff,\n    basicOpen_eq_zeroLocus_compl]\n\n"}
{"name":"PrimeSpectrum.exists_image_comap_of_finite_of_free","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_2\nA : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : Algebra R A\nf : A\ns : Set A\ninst✝¹ : Module.Finite R (HasQuotient.Quotient A (Ideal.span s))\ninst✝ : Module.Free R (HasQuotient.Quotient A (Ideal.span s))\n⊢ Exists fun t => Eq (Set.image (⇑(PrimeSpectrum.comap (algebraMap R A))) (SDiff.sdiff (PrimeSpectrum.zeroLocus s) (PrimeSpectrum.zeroLocus (Singleton.singleton f)))) (HasCompl.compl (PrimeSpectrum.zeroLocus ↑t))","decl":"/-- Let `A` be an `R`-algebra. If `A ⧸ I` is finite free over `R`,\nthen the image of `Z(I) ∩ D(f) ⊆ Spec S` in `Spec R` is compact open. -/\nlemma exists_image_comap_of_finite_of_free (f : A) (s : Set A)\n    [Module.Finite R (A ⧸ Ideal.span s)] [Module.Free R (A ⧸ Ideal.span s)] :\n    ∃ t : Finset R, comap (algebraMap R A) '' (zeroLocus s \\ zeroLocus {f}) = (zeroLocus t)ᶜ := by\n  classical\n  use (Finset.range (Module.finrank R (A ⧸ Ideal.span s))).image\n    (Algebra.lmul R (A ⧸ Ideal.span s) (Ideal.Quotient.mk _ f)).charpoly.coeff\n  ext x\n  rw [mem_image_comap_zeroLocus_sdiff, IsScalarTower.algebraMap_apply A (A ⧸ Ideal.span s),\n    isNilpotent_tensor_residueField_iff]\n  simp [Set.subset_def]\n\n"}
{"name":"Polynomial.mem_image_comap_C_basicOpen","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : Polynomial R\nx : PrimeSpectrum R\n⊢ Iff (Membership.mem (Set.image ⇑(PrimeSpectrum.comap Polynomial.C) ↑(PrimeSpectrum.basicOpen f)) x) (Exists fun i => Not (Membership.mem x.asIdeal (f.coeff i)))","decl":"lemma mem_image_comap_C_basicOpen (f : R[X]) (x : PrimeSpectrum R) :\n    x ∈ comap C '' basicOpen f ↔ ∃ i, f.coeff i ∉ x.asIdeal := by\n  trans f.map (algebraMap R x.asIdeal.ResidueField) ≠ 0\n  · refine (mem_image_comap_basicOpen _ _).trans (not_iff_not.mpr ?_)\n    let e : R[X] ⊗[R] x.asIdeal.ResidueField ≃ₐ[R] x.asIdeal.ResidueField[X] :=\n      (Algebra.TensorProduct.comm R _ _).trans (polyEquivTensor R x.asIdeal.ResidueField).symm\n    rw [← IsNilpotent.map_iff e.injective, isNilpotent_iff_eq_zero]\n    show (e.toAlgHom.toRingHom).comp (algebraMap _ _) f = 0 ↔ Polynomial.mapRingHom _ f = 0\n    congr!\n    ext1\n    · ext; simp [e]\n    · simp [e, monomial_one_one_eq_X]\n  · simp [Polynomial.ext_iff]\n\n"}
{"name":"Polynomial.image_comap_C_basicOpen","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : Polynomial R\n⊢ Eq (Set.image ⇑(PrimeSpectrum.comap Polynomial.C) ↑(PrimeSpectrum.basicOpen f)) (HasCompl.compl (PrimeSpectrum.zeroLocus (Set.range f.coeff)))","decl":"lemma image_comap_C_basicOpen (f : R[X]) :\n      comap C '' basicOpen f = (zeroLocus (Set.range f.coeff))ᶜ := by\n    ext p\n    rw [mem_image_comap_C_basicOpen]\n    simp [Set.range_subset_iff]\n\n"}
{"name":"Polynomial.isOpenMap_comap_C","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ IsOpenMap ⇑(PrimeSpectrum.comap Polynomial.C)","decl":"lemma isOpenMap_comap_C : IsOpenMap (comap (R := R) C) := by\n  intro U hU\n  obtain ⟨S, hS, rfl⟩ := isTopologicalBasis_basic_opens.open_eq_sUnion hU\n  rw [Set.image_sUnion]\n  apply isOpen_sUnion\n  rintro _ ⟨t, ht, rfl⟩\n  obtain ⟨r, rfl⟩ := hS ht\n  simp only [image_comap_C_basicOpen]\n  exact (isClosed_zeroLocus _).isOpen_compl\n\n"}
{"name":"Polynomial.comap_C_surjective","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Function.Surjective ⇑(PrimeSpectrum.comap Polynomial.C)","decl":"lemma comap_C_surjective : Function.Surjective (comap (R := R) C) := by\n  intro x\n  refine ⟨comap (evalRingHom 0) x, ?_⟩\n  rw [← comap_comp_apply, (show (evalRingHom 0).comp C = .id R by ext; simp),\n    comap_id, ContinuousMap.id_apply]\n\n"}
{"name":"Polynomial.exists_image_comap_of_monic","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf g : Polynomial R\nhg : g.Monic\n⊢ Exists fun t => Eq (Set.image (⇑(PrimeSpectrum.comap Polynomial.C)) (SDiff.sdiff (PrimeSpectrum.zeroLocus (Singleton.singleton g)) (PrimeSpectrum.zeroLocus (Singleton.singleton f)))) (HasCompl.compl (PrimeSpectrum.zeroLocus ↑t))","decl":"lemma exists_image_comap_of_monic (f g : R[X]) (hg : g.Monic) :\n    ∃ t : Finset R, comap C '' (zeroLocus {g} \\ zeroLocus {f}) = (zeroLocus t)ᶜ := by\n  apply (config := { allowSynthFailures := true }) exists_image_comap_of_finite_of_free\n  · exact .of_basis (AdjoinRoot.powerBasis' hg).basis\n  · exact .of_basis (AdjoinRoot.powerBasis' hg).basis\n\n"}
{"name":"Polynomial.isCompact_image_comap_of_monic","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf g : Polynomial R\nhg : g.Monic\n⊢ IsCompact (Set.image (⇑(PrimeSpectrum.comap Polynomial.C)) (SDiff.sdiff (PrimeSpectrum.zeroLocus (Singleton.singleton g)) (PrimeSpectrum.zeroLocus (Singleton.singleton f))))","decl":"lemma isCompact_image_comap_of_monic (f g : R[X]) (hg : g.Monic) :\n    IsCompact (comap C '' (zeroLocus {g} \\ zeroLocus {f})) := by\n  obtain ⟨t, ht⟩ := exists_image_comap_of_monic f g hg\n  rw [ht, ← t.toSet.iUnion_of_singleton_coe, zeroLocus_iUnion, Set.compl_iInter]\n  apply isCompact_iUnion\n  exact fun _ ↦ by simpa using isCompact_basicOpen _\n\n"}
{"name":"Polynomial.isOpen_image_comap_of_monic","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf g : Polynomial R\nhg : g.Monic\n⊢ IsOpen (Set.image (⇑(PrimeSpectrum.comap Polynomial.C)) (SDiff.sdiff (PrimeSpectrum.zeroLocus (Singleton.singleton g)) (PrimeSpectrum.zeroLocus (Singleton.singleton f))))","decl":"lemma isOpen_image_comap_of_monic (f g : R[X]) (hg : g.Monic) :\n    IsOpen (comap C '' (zeroLocus {g} \\ zeroLocus {f})) := by\n  obtain ⟨t, ht⟩ := exists_image_comap_of_monic f g hg\n  rw [ht]\n  exact (isClosed_zeroLocus (R := R) t).isOpen_compl\n\n"}
{"name":"MvPolynomial.mem_image_comap_C_basicOpen","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_2\ninst✝ : CommRing R\nσ : Type u_1\nf : MvPolynomial σ R\nx : PrimeSpectrum R\n⊢ Iff (Membership.mem (Set.image ⇑(PrimeSpectrum.comap MvPolynomial.C) ↑(PrimeSpectrum.basicOpen f)) x) (Exists fun i => Not (Membership.mem x.asIdeal (MvPolynomial.coeff i f)))","decl":"lemma mem_image_comap_C_basicOpen (f : MvPolynomial σ R) (x : PrimeSpectrum R) :\n    x ∈ comap (C (σ := σ)) '' basicOpen f ↔ ∃ i, f.coeff i ∉ x.asIdeal := by\n  classical\n  trans f.map (algebraMap R x.asIdeal.ResidueField) ≠ 0\n  · refine (mem_image_comap_basicOpen _ _).trans (not_iff_not.mpr ?_)\n    let e : MvPolynomial σ R ⊗[R] x.asIdeal.ResidueField ≃ₐ[R]\n        MvPolynomial σ x.asIdeal.ResidueField := scalarRTensorAlgEquiv\n    rw [← IsNilpotent.map_iff e.injective, isNilpotent_iff_eq_zero]\n    show (e.toAlgHom.toRingHom).comp (algebraMap _ _) f = 0 ↔ MvPolynomial.map _ f = 0\n    congr!\n    ext\n    · simp [scalarRTensorAlgEquiv, e, coeff_map,\n        Algebra.smul_def, apply_ite (f := algebraMap _ _)]\n    · simp [e, monomial_one_one_eq_X, scalarRTensorAlgEquiv, coeff_map, coeff_X']\n  · simp [MvPolynomial.ext_iff, coeff_map]\n\n"}
{"name":"MvPolynomial.image_comap_C_basicOpen","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_2\ninst✝ : CommRing R\nσ : Type u_1\nf : MvPolynomial σ R\n⊢ Eq (Set.image ⇑(PrimeSpectrum.comap MvPolynomial.C) ↑(PrimeSpectrum.basicOpen f)) (HasCompl.compl (PrimeSpectrum.zeroLocus (Set.range fun m => MvPolynomial.coeff m f)))","decl":"lemma image_comap_C_basicOpen (f : MvPolynomial σ R) :\n      comap (C (σ := σ)) '' basicOpen f = (zeroLocus (Set.range f.coeff))ᶜ := by\n    ext p\n    rw [mem_image_comap_C_basicOpen]\n    simp [Set.range_subset_iff]\n\n"}
{"name":"MvPolynomial.isOpenMap_comap_C","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_2\ninst✝ : CommRing R\nσ : Type u_1\n⊢ IsOpenMap ⇑(PrimeSpectrum.comap MvPolynomial.C)","decl":"lemma isOpenMap_comap_C : IsOpenMap (comap (R := R) (C (σ := σ))) := by\n  intro U hU\n  obtain ⟨S, hS, rfl⟩ := isTopologicalBasis_basic_opens.open_eq_sUnion hU\n  rw [Set.image_sUnion]\n  apply isOpen_sUnion\n  rintro _ ⟨t, ht, rfl⟩\n  obtain ⟨r, rfl⟩ := hS ht\n  simp only [image_comap_C_basicOpen]\n  exact (isClosed_zeroLocus _).isOpen_compl\n\n"}
{"name":"MvPolynomial.comap_C_surjective","module":"Mathlib.RingTheory.Spectrum.Prime.Polynomial","initialProofState":"R : Type u_2\ninst✝ : CommRing R\nσ : Type u_1\n⊢ Function.Surjective ⇑(PrimeSpectrum.comap MvPolynomial.C)","decl":"lemma comap_C_surjective : Function.Surjective (comap (R := R) (C (σ := σ))) := by\n  intro x\n  refine ⟨comap (eval₂Hom (.id _) 0) x, ?_⟩\n  rw [← comap_comp_apply, (show (eval₂Hom (.id _) 0).comp C = .id R by ext; simp),\n    comap_id, ContinuousMap.id_apply]\n\n"}
