{"name":"CategoryTheory.Adjunction.unop_counit","module":"Mathlib.CategoryTheory.Adjunction.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\nG : CategoryTheory.Functor (Opposite D) (Opposite C)\nh : CategoryTheory.Adjunction G F\n⊢ Eq h.unop.counit (CategoryTheory.NatTrans.unop h.unit)","decl":"/-- If `G` is adjoint to `F` then `F.unop` is adjoint to `G.unop`. -/\n@[simps]\ndef unop {F : Cᵒᵖ ⥤ Dᵒᵖ} {G : Dᵒᵖ ⥤ Cᵒᵖ} (h : G ⊣ F) : F.unop ⊣ G.unop where\n  unit := NatTrans.unop h.counit\n  counit := NatTrans.unop h.unit\n  left_triangle_components _ := Quiver.Hom.op_inj (h.right_triangle_components _)\n  right_triangle_components _ := Quiver.Hom.op_inj (h.left_triangle_components _)\n\n"}
{"name":"CategoryTheory.Adjunction.unop_unit","module":"Mathlib.CategoryTheory.Adjunction.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\nG : CategoryTheory.Functor (Opposite D) (Opposite C)\nh : CategoryTheory.Adjunction G F\n⊢ Eq h.unop.unit (CategoryTheory.NatTrans.unop h.counit)","decl":"/-- If `G` is adjoint to `F` then `F.unop` is adjoint to `G.unop`. -/\n@[simps]\ndef unop {F : Cᵒᵖ ⥤ Dᵒᵖ} {G : Dᵒᵖ ⥤ Cᵒᵖ} (h : G ⊣ F) : F.unop ⊣ G.unop where\n  unit := NatTrans.unop h.counit\n  counit := NatTrans.unop h.unit\n  left_triangle_components _ := Quiver.Hom.op_inj (h.right_triangle_components _)\n  right_triangle_components _ := Quiver.Hom.op_inj (h.left_triangle_components _)\n\n"}
{"name":"CategoryTheory.Adjunction.op_unit","module":"Mathlib.CategoryTheory.Adjunction.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction G F\n⊢ Eq h.op.unit (CategoryTheory.NatTrans.op h.counit)","decl":"/-- If `G` is adjoint to `F` then `F.op` is adjoint to `G.op`. -/\n@[simps]\ndef op {F : C ⥤ D} {G : D ⥤ C} (h : G ⊣ F) : F.op ⊣ G.op where\n  unit := NatTrans.op h.counit\n  counit := NatTrans.op h.unit\n  left_triangle_components _ := Quiver.Hom.unop_inj (by simp)\n  right_triangle_components _ := Quiver.Hom.unop_inj (by simp)\n\n"}
{"name":"CategoryTheory.Adjunction.op_counit","module":"Mathlib.CategoryTheory.Adjunction.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction G F\n⊢ Eq h.op.counit (CategoryTheory.NatTrans.op h.unit)","decl":"/-- If `G` is adjoint to `F` then `F.op` is adjoint to `G.op`. -/\n@[simps]\ndef op {F : C ⥤ D} {G : D ⥤ C} (h : G ⊣ F) : F.op ⊣ G.op where\n  unit := NatTrans.op h.counit\n  counit := NatTrans.op h.unit\n  left_triangle_components _ := Quiver.Hom.unop_inj (by simp)\n  right_triangle_components _ := Quiver.Hom.unop_inj (by simp)\n\n"}
