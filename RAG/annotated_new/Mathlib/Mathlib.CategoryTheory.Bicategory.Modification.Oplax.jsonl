{"name":"CategoryTheory.Oplax.Modification.ext","module":"Mathlib.CategoryTheory.Bicategory.Modification.Oplax","initialProofState":"B : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Bicategory B\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nÎ· Î¸ : Quiver.Hom F G\nx y : CategoryTheory.Oplax.Modification Î· Î¸\napp : Eq x.app y.app\nâŠ¢ Eq x y","decl":"/-- A modification `Î“` between oplax natural transformations `Î·` and `Î¸` consists of a family of\n2-morphisms `Î“.app a : Î·.app a âŸ¶ Î¸.app a`, which satisfies the equation\n`(F.map f â— app b) â‰« Î¸.naturality f = Î·.naturality f â‰« (app a â–· G.map f)`\nfor each 1-morphism `f : a âŸ¶ b`.\n-/\n@[ext]\nstructure Modification (Î· Î¸ : F âŸ¶ G) where\n  /-- The underlying family of 2-morphism. -/\n  app (a : B) : Î·.app a âŸ¶ Î¸.app a\n  /-- The naturality condition. -/\n  naturality :\n    âˆ€ {a b : B} (f : a âŸ¶ b),\n      F.map f â— app b â‰« Î¸.naturality f = Î·.naturality f â‰« app a â–· G.map f := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Oplax.Modification.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.Modification.Oplax","initialProofState":"B : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Bicategory B\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nÎ· Î¸ : Quiver.Hom F G\nappâœ : (a : B) â†’ Quiver.Hom (Î·.app a) (Î¸.app a)\nnaturalityâœ : autoParam (âˆ€ {a b : B} (f : Quiver.Hom a b), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (appâœ b)) (Î¸.naturality f)) (CategoryTheory.CategoryStruct.comp (Î·.naturality f) (CategoryTheory.Bicategory.whiskerRight (appâœ a) (G.map f)))) _autoâœ\napp : (a : B) â†’ Quiver.Hom (Î·.app a) (Î¸.app a)\nnaturality : autoParam (âˆ€ {a b : B} (f : Quiver.Hom a b), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (app b)) (Î¸.naturality f)) (CategoryTheory.CategoryStruct.comp (Î·.naturality f) (CategoryTheory.Bicategory.whiskerRight (app a) (G.map f)))) _autoâœ\nâŠ¢ Eq (Eq { app := appâœ, naturality := naturalityâœ } { app := app, naturality := naturality }) (Eq appâœ app)","decl":"/-- A modification `Î“` between oplax natural transformations `Î·` and `Î¸` consists of a family of\n2-morphisms `Î“.app a : Î·.app a âŸ¶ Î¸.app a`, which satisfies the equation\n`(F.map f â— app b) â‰« Î¸.naturality f = Î·.naturality f â‰« (app a â–· G.map f)`\nfor each 1-morphism `f : a âŸ¶ b`.\n-/\n@[ext]\nstructure Modification (Î· Î¸ : F âŸ¶ G) where\n  /-- The underlying family of 2-morphism. -/\n  app (a : B) : Î·.app a âŸ¶ Î¸.app a\n  /-- The naturality condition. -/\n  naturality :\n    âˆ€ {a b : B} (f : a âŸ¶ b),\n      F.map f â— app b â‰« Î¸.naturality f = Î·.naturality f â‰« app a â–· G.map f := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Oplax.Modification.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Modification.Oplax","initialProofState":"B : Type uâ‚\ninstâœÂ³ : CategoryTheory.Bicategory B\nC : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nÎ· Î¸ : Quiver.Hom F G\ninstâœÂ¹ : SizeOf B\ninstâœ : SizeOf C\napp : (a : B) â†’ Quiver.Hom (Î·.app a) (Î¸.app a)\nnaturality : autoParam (âˆ€ {a b : B} (f : Quiver.Hom a b), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (app b)) (Î¸.naturality f)) (CategoryTheory.CategoryStruct.comp (Î·.naturality f) (CategoryTheory.Bicategory.whiskerRight (app a) (G.map f)))) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { app := app, naturality := naturality }) 1","decl":"/-- A modification `Î“` between oplax natural transformations `Î·` and `Î¸` consists of a family of\n2-morphisms `Î“.app a : Î·.app a âŸ¶ Î¸.app a`, which satisfies the equation\n`(F.map f â— app b) â‰« Î¸.naturality f = Î·.naturality f â‰« (app a â–· G.map f)`\nfor each 1-morphism `f : a âŸ¶ b`.\n-/\n@[ext]\nstructure Modification (Î· Î¸ : F âŸ¶ G) where\n  /-- The underlying family of 2-morphism. -/\n  app (a : B) : Î·.app a âŸ¶ Î¸.app a\n  /-- The naturality condition. -/\n  naturality :\n    âˆ€ {a b : B} (f : a âŸ¶ b),\n      F.map f â— app b â‰« Î¸.naturality f = Î·.naturality f â‰« app a â–· G.map f := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Oplax.Modification.naturality","module":"Mathlib.CategoryTheory.Bicategory.Modification.Oplax","initialProofState":"B : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Bicategory B\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nÎ· Î¸ : Quiver.Hom F G\nself : CategoryTheory.Oplax.Modification Î· Î¸\na b : B\nf : Quiver.Hom a b\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (self.app b)) (Î¸.naturality f)) (CategoryTheory.CategoryStruct.comp (Î·.naturality f) (CategoryTheory.Bicategory.whiskerRight (self.app a) (G.map f)))","decl":"/-- A modification `Î“` between oplax natural transformations `Î·` and `Î¸` consists of a family of\n2-morphisms `Î“.app a : Î·.app a âŸ¶ Î¸.app a`, which satisfies the equation\n`(F.map f â— app b) â‰« Î¸.naturality f = Î·.naturality f â‰« (app a â–· G.map f)`\nfor each 1-morphism `f : a âŸ¶ b`.\n-/\n@[ext]\nstructure Modification (Î· Î¸ : F âŸ¶ G) where\n  /-- The underlying family of 2-morphism. -/\n  app (a : B) : Î·.app a âŸ¶ Î¸.app a\n  /-- The naturality condition. -/\n  naturality :\n    âˆ€ {a b : B} (f : a âŸ¶ b),\n      F.map f â— app b â‰« Î¸.naturality f = Î·.naturality f â‰« app a â–· G.map f := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Oplax.Modification.ext_iff","module":"Mathlib.CategoryTheory.Bicategory.Modification.Oplax","initialProofState":"B : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Bicategory B\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nÎ· Î¸ : Quiver.Hom F G\nx y : CategoryTheory.Oplax.Modification Î· Î¸\nâŠ¢ Iff (Eq x y) (Eq x.app y.app)","decl":"/-- A modification `Î“` between oplax natural transformations `Î·` and `Î¸` consists of a family of\n2-morphisms `Î“.app a : Î·.app a âŸ¶ Î¸.app a`, which satisfies the equation\n`(F.map f â— app b) â‰« Î¸.naturality f = Î·.naturality f â‰« (app a â–· G.map f)`\nfor each 1-morphism `f : a âŸ¶ b`.\n-/\n@[ext]\nstructure Modification (Î· Î¸ : F âŸ¶ G) where\n  /-- The underlying family of 2-morphism. -/\n  app (a : B) : Î·.app a âŸ¶ Î¸.app a\n  /-- The naturality condition. -/\n  naturality :\n    âˆ€ {a b : B} (f : a âŸ¶ b),\n      F.map f â— app b â‰« Î¸.naturality f = Î·.naturality f â‰« app a â–· G.map f := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Oplax.Modification.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.Modification.Oplax","initialProofState":"B : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Bicategory B\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nÎ· Î¸ : Quiver.Hom F G\nappâœ : (a : B) â†’ Quiver.Hom (Î·.app a) (Î¸.app a)\nnaturalityâœ : autoParam (âˆ€ {a b : B} (f : Quiver.Hom a b), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (appâœ b)) (Î¸.naturality f)) (CategoryTheory.CategoryStruct.comp (Î·.naturality f) (CategoryTheory.Bicategory.whiskerRight (appâœ a) (G.map f)))) _autoâœ\napp : (a : B) â†’ Quiver.Hom (Î·.app a) (Î¸.app a)\nnaturality : autoParam (âˆ€ {a b : B} (f : Quiver.Hom a b), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (app b)) (Î¸.naturality f)) (CategoryTheory.CategoryStruct.comp (Î·.naturality f) (CategoryTheory.Bicategory.whiskerRight (app a) (G.map f)))) _autoâœ\nxâœ : Eq { app := appâœ, naturality := naturalityâœ } { app := app, naturality := naturality }\nâŠ¢ Eq appâœ app","decl":"/-- A modification `Î“` between oplax natural transformations `Î·` and `Î¸` consists of a family of\n2-morphisms `Î“.app a : Î·.app a âŸ¶ Î¸.app a`, which satisfies the equation\n`(F.map f â— app b) â‰« Î¸.naturality f = Î·.naturality f â‰« (app a â–· G.map f)`\nfor each 1-morphism `f : a âŸ¶ b`.\n-/\n@[ext]\nstructure Modification (Î· Î¸ : F âŸ¶ G) where\n  /-- The underlying family of 2-morphism. -/\n  app (a : B) : Î·.app a âŸ¶ Î¸.app a\n  /-- The naturality condition. -/\n  naturality :\n    âˆ€ {a b : B} (f : a âŸ¶ b),\n      F.map f â— app b â‰« Î¸.naturality f = Î·.naturality f â‰« app a â–· G.map f := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Oplax.Modification.naturality_assoc","module":"Mathlib.CategoryTheory.Bicategory.Modification.Oplax","initialProofState":"B : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Bicategory B\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nÎ· Î¸ : Quiver.Hom F G\nself : CategoryTheory.Oplax.Modification Î· Î¸\na b : B\nf : Quiver.Hom a b\nZ : Quiver.Hom (F.obj a) (G.obj b)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (Î¸.app a) (G.map f)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (self.app b)) (CategoryTheory.CategoryStruct.comp (Î¸.naturality f) h)) (CategoryTheory.CategoryStruct.comp (Î·.naturality f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.app a) (G.map f)) h))","decl":"attribute [reassoc (attr := simp)] Modification.naturality\n\n"}
{"name":"CategoryTheory.Oplax.Modification.id_app","module":"Mathlib.CategoryTheory.Bicategory.Modification.Oplax","initialProofState":"B : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Bicategory B\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nÎ· : Quiver.Hom F G\na : B\nâŠ¢ Eq ((CategoryTheory.Oplax.Modification.id Î·).app a) (CategoryTheory.CategoryStruct.id (Î·.app a))","decl":"/-- The identity modification. -/\n@[simps]\ndef id : Modification Î· Î· where app a := ğŸ™ (Î·.app a)\n\n"}
{"name":"CategoryTheory.Oplax.Modification.whiskerLeft_naturality_assoc","module":"Mathlib.CategoryTheory.Bicategory.Modification.Oplax","initialProofState":"B : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Bicategory B\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nÎ· Î¸ : Quiver.Hom F G\nÎ“ : CategoryTheory.Oplax.Modification Î· Î¸\nb c : B\na' : C\nf : Quiver.Hom a' (F.obj b)\ng : Quiver.Hom b c\nZ : Quiver.Hom a' (G.obj c)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (Î¸.app b) (G.map g))) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerLeft (F.map g) (Î“.app c))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (Î¸.naturality g)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (Î·.naturality g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerRight (Î“.app b) (G.map g))) h))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_naturality (f : a' âŸ¶ F.obj b) (g : b âŸ¶ c) :\n    f â— F.map g â— Î“.app c â‰« f â— Î¸.naturality g = f â— Î·.naturality g â‰« f â— Î“.app b â–· G.map g := by\n  simp_rw [â† Bicategory.whiskerLeft_comp, naturality]\n\n"}
{"name":"CategoryTheory.Oplax.Modification.whiskerLeft_naturality","module":"Mathlib.CategoryTheory.Bicategory.Modification.Oplax","initialProofState":"B : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Bicategory B\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nÎ· Î¸ : Quiver.Hom F G\nÎ“ : CategoryTheory.Oplax.Modification Î· Î¸\nb c : B\na' : C\nf : Quiver.Hom a' (F.obj b)\ng : Quiver.Hom b c\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerLeft (F.map g) (Î“.app c))) (CategoryTheory.Bicategory.whiskerLeft f (Î¸.naturality g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (Î·.naturality g)) (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerRight (Î“.app b) (G.map g))))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_naturality (f : a' âŸ¶ F.obj b) (g : b âŸ¶ c) :\n    f â— F.map g â— Î“.app c â‰« f â— Î¸.naturality g = f â— Î·.naturality g â‰« f â— Î“.app b â–· G.map g := by\n  simp_rw [â† Bicategory.whiskerLeft_comp, naturality]\n\n"}
{"name":"CategoryTheory.Oplax.Modification.whiskerRight_naturality","module":"Mathlib.CategoryTheory.Bicategory.Modification.Oplax","initialProofState":"B : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Bicategory B\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nÎ· Î¸ : Quiver.Hom F G\nÎ“ : CategoryTheory.Oplax.Modification Î· Î¸\na b : B\na' : C\nf : Quiver.Hom a b\ng : Quiver.Hom (G.obj b) a'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (CategoryTheory.Bicategory.whiskerRight (Î“.app b) g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (Î¸.app b) g).inv (CategoryTheory.Bicategory.whiskerRight (Î¸.naturality f) g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (Î·.app b) g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (Î·.naturality f) g) (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight (Î“.app a) (G.map f)) g)))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerRight_naturality (f : a âŸ¶ b) (g : G.obj b âŸ¶ a') :\n    F.map f â— Î“.app b â–· g â‰« (Î±_ _ _ _).inv â‰« Î¸.naturality f â–· g =\n      (Î±_ _ _ _).inv â‰« Î·.naturality f â–· g â‰« Î“.app a â–· G.map f â–· g := by\n  simp_rw [associator_inv_naturality_middle_assoc, â† comp_whiskerRight, naturality]\n\n"}
{"name":"CategoryTheory.Oplax.Modification.whiskerRight_naturality_assoc","module":"Mathlib.CategoryTheory.Bicategory.Modification.Oplax","initialProofState":"B : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Bicategory B\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nÎ· Î¸ : Quiver.Hom F G\nÎ“ : CategoryTheory.Oplax.Modification Î· Î¸\na b : B\na' : C\nf : Quiver.Hom a b\ng : Quiver.Hom (G.obj b) a'\nZ : Quiver.Hom (F.obj a) a'\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (Î¸.app a) (G.map f)) g) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (CategoryTheory.Bicategory.whiskerRight (Î“.app b) g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (Î¸.app b) g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (Î¸.naturality f) g) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (Î·.app b) g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (Î·.naturality f) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight (Î“.app a) (G.map f)) g) h)))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerRight_naturality (f : a âŸ¶ b) (g : G.obj b âŸ¶ a') :\n    F.map f â— Î“.app b â–· g â‰« (Î±_ _ _ _).inv â‰« Î¸.naturality f â–· g =\n      (Î±_ _ _ _).inv â‰« Î·.naturality f â–· g â‰« Î“.app a â–· G.map f â–· g := by\n  simp_rw [associator_inv_naturality_middle_assoc, â† comp_whiskerRight, naturality]\n\n"}
{"name":"CategoryTheory.Oplax.Modification.vcomp_app","module":"Mathlib.CategoryTheory.Bicategory.Modification.Oplax","initialProofState":"B : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Bicategory B\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nÎ· Î¸ Î¹ : Quiver.Hom F G\nÎ“ : CategoryTheory.Oplax.Modification Î· Î¸\nÎ” : CategoryTheory.Oplax.Modification Î¸ Î¹\na : B\nâŠ¢ Eq ((Î“.vcomp Î”).app a) (CategoryTheory.CategoryStruct.comp (Î“.app a) (Î”.app a))","decl":"/-- Vertical composition of modifications. -/\n@[simps]\ndef vcomp (Î“ : Modification Î· Î¸) (Î” : Modification Î¸ Î¹) : Modification Î· Î¹ where\n  app a := Î“.app a â‰« Î”.app a\n\n"}
{"name":"CategoryTheory.Oplax.category_id","module":"Mathlib.CategoryTheory.Bicategory.Modification.Oplax","initialProofState":"B : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Bicategory B\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nÎ· : Quiver.Hom F G\nâŠ¢ Eq (CategoryTheory.CategoryStruct.id Î·) (CategoryTheory.Oplax.Modification.id Î·)","decl":"/-- Category structure on the oplax natural transformations between OplaxFunctors. -/\n@[simps]\ninstance category (F G : OplaxFunctor B C) : Category (F âŸ¶ G) where\n  Hom := Modification\n  id := Modification.id\n  comp := Modification.vcomp\n\n"}
{"name":"CategoryTheory.Oplax.category_comp","module":"Mathlib.CategoryTheory.Bicategory.Modification.Oplax","initialProofState":"B : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Bicategory B\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nXâœ Yâœ Zâœ : Quiver.Hom F G\nÎ“ : CategoryTheory.Oplax.Modification Xâœ Yâœ\nÎ” : CategoryTheory.Oplax.Modification Yâœ Zâœ\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp Î“ Î”) (Î“.vcomp Î”)","decl":"/-- Category structure on the oplax natural transformations between OplaxFunctors. -/\n@[simps]\ninstance category (F G : OplaxFunctor B C) : Category (F âŸ¶ G) where\n  Hom := Modification\n  id := Modification.id\n  comp := Modification.vcomp\n\n"}
{"name":"CategoryTheory.Oplax.ext","module":"Mathlib.CategoryTheory.Bicategory.Modification.Oplax","initialProofState":"B : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Bicategory B\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nÎ± Î² : Quiver.Hom F G\nm n : Quiver.Hom Î± Î²\nw : âˆ€ (b : B), Eq (m.app b) (n.app b)\nâŠ¢ Eq m n","decl":"@[ext]\nlemma ext {F G : OplaxFunctor B C} {Î± Î² : F âŸ¶ G} {m n : Î± âŸ¶ Î²} (w : âˆ€ b, m.app b = n.app b) :\n    m = n := by\n  apply Modification.ext\n  ext\n  apply w\n\n"}
{"name":"CategoryTheory.Oplax.ext_iff","module":"Mathlib.CategoryTheory.Bicategory.Modification.Oplax","initialProofState":"B : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Bicategory B\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nÎ± Î² : Quiver.Hom F G\nm n : Quiver.Hom Î± Î²\nâŠ¢ Iff (Eq m n) (âˆ€ (b : B), Eq (m.app b) (n.app b))","decl":"@[ext]\nlemma ext {F G : OplaxFunctor B C} {Î± Î² : F âŸ¶ G} {m n : Î± âŸ¶ Î²} (w : âˆ€ b, m.app b = n.app b) :\n    m = n := by\n  apply Modification.ext\n  ext\n  apply w\n\n"}
{"name":"CategoryTheory.Oplax.Modification.id_app'","module":"Mathlib.CategoryTheory.Bicategory.Modification.Oplax","initialProofState":"B : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Bicategory B\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Bicategory C\nX : B\nF G : CategoryTheory.OplaxFunctor B C\nÎ± : Quiver.Hom F G\nâŠ¢ Eq ((CategoryTheory.CategoryStruct.id Î±).app X) (CategoryTheory.CategoryStruct.id (Î±.app X))","decl":"/-- Version of `Modification.id_app` using category notation -/\n@[simp]\nlemma Modification.id_app' {X : B} {F G : OplaxFunctor B C} (Î± : F âŸ¶ G) :\n    Modification.app (ğŸ™ Î±) X = ğŸ™ (Î±.app X) := rfl\n\n"}
{"name":"CategoryTheory.Oplax.Modification.comp_app'","module":"Mathlib.CategoryTheory.Bicategory.Modification.Oplax","initialProofState":"B : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Bicategory B\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Bicategory C\nX : B\nF G : CategoryTheory.OplaxFunctor B C\nÎ± Î² Î³ : Quiver.Hom F G\nm : Quiver.Hom Î± Î²\nn : Quiver.Hom Î² Î³\nâŠ¢ Eq ((CategoryTheory.CategoryStruct.comp m n).app X) (CategoryTheory.CategoryStruct.comp (m.app X) (n.app X))","decl":"/-- Version of `Modification.comp_app` using category notation -/\n@[simp]\nlemma Modification.comp_app' {X : B} {F G : OplaxFunctor B C} {Î± Î² Î³ : F âŸ¶ G}\n    (m : Î± âŸ¶ Î²) (n : Î² âŸ¶ Î³) : (m â‰« n).app X = m.app X â‰« n.app X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Oplax.ModificationIso.ofComponents_hom_app","module":"Mathlib.CategoryTheory.Bicategory.Modification.Oplax","initialProofState":"B : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Bicategory B\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nÎ· Î¸ : Quiver.Hom F G\napp : (a : B) â†’ CategoryTheory.Iso (Î·.app a) (Î¸.app a)\nnaturality : âˆ€ {a b : B} (f : Quiver.Hom a b), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (app b).hom) (Î¸.naturality f)) (CategoryTheory.CategoryStruct.comp (Î·.naturality f) (CategoryTheory.Bicategory.whiskerRight (app a).hom (G.map f)))\na : B\nâŠ¢ Eq ((CategoryTheory.Oplax.ModificationIso.ofComponents app naturality).hom.app a) (app a).hom","decl":"/-- Construct a modification isomorphism between oplax natural transformations\nby giving object level isomorphisms, and checking naturality only in the forward direction.\n-/\n@[simps]\ndef ModificationIso.ofComponents (app : âˆ€ a, Î·.app a â‰… Î¸.app a)\n    (naturality :\n      âˆ€ {a b} (f : a âŸ¶ b),\n        F.map f â— (app b).hom â‰« Î¸.naturality f = Î·.naturality f â‰« (app a).hom â–· G.map f) :\n    Î· â‰… Î¸ where\n  hom := { app := fun a => (app a).hom }\n  inv :=\n    { app := fun a => (app a).inv\n      naturality := fun {a b} f => by\n        simpa using congr_arg (fun f => _ â— (app b).inv â‰« f â‰« (app a).inv â–· _) (naturality f).symm }\n\n"}
{"name":"CategoryTheory.Oplax.ModificationIso.ofComponents_inv_app","module":"Mathlib.CategoryTheory.Bicategory.Modification.Oplax","initialProofState":"B : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Bicategory B\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nÎ· Î¸ : Quiver.Hom F G\napp : (a : B) â†’ CategoryTheory.Iso (Î·.app a) (Î¸.app a)\nnaturality : âˆ€ {a b : B} (f : Quiver.Hom a b), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (app b).hom) (Î¸.naturality f)) (CategoryTheory.CategoryStruct.comp (Î·.naturality f) (CategoryTheory.Bicategory.whiskerRight (app a).hom (G.map f)))\na : B\nâŠ¢ Eq ((CategoryTheory.Oplax.ModificationIso.ofComponents app naturality).inv.app a) (app a).inv","decl":"/-- Construct a modification isomorphism between oplax natural transformations\nby giving object level isomorphisms, and checking naturality only in the forward direction.\n-/\n@[simps]\ndef ModificationIso.ofComponents (app : âˆ€ a, Î·.app a â‰… Î¸.app a)\n    (naturality :\n      âˆ€ {a b} (f : a âŸ¶ b),\n        F.map f â— (app b).hom â‰« Î¸.naturality f = Î·.naturality f â‰« (app a).hom â–· G.map f) :\n    Î· â‰… Î¸ where\n  hom := { app := fun a => (app a).hom }\n  inv :=\n    { app := fun a => (app a).inv\n      naturality := fun {a b} f => by\n        simpa using congr_arg (fun f => _ â— (app b).inv â‰« f â‰« (app a).inv â–· _) (naturality f).symm }\n\n"}
