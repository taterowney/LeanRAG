{"name":"Finset.mem_finAntidiagonal","module":"Mathlib.Algebra.Order.Antidiag.Pi","initialProofState":"μ : Type u_2\ninst✝² : AddCommMonoid μ\ninst✝¹ : Finset.HasAntidiagonal μ\ninst✝ : DecidableEq μ\nn : μ\nd : Nat\nf : Fin d → μ\n⊢ Iff (Membership.mem (Finset.finAntidiagonal d n) f) (Eq (Finset.univ.sum fun i => f i) n)","decl":"@[simp] lemma mem_finAntidiagonal {d : ℕ} {f : Fin d → μ} :\n    f ∈ finAntidiagonal d n ↔ ∑ i, f i = n := (finAntidiagonal.aux d n).prop f\n\n"}
{"name":"Finset.mem_piAntidiag","module":"Mathlib.Algebra.Order.Antidiag.Pi","initialProofState":"ι : Type u_1\nμ : Type u_2\ninst✝³ : DecidableEq ι\ninst✝² : AddCommMonoid μ\ninst✝¹ : Finset.HasAntidiagonal μ\ninst✝ : DecidableEq μ\ns : Finset ι\nn : μ\nf : ι → μ\n⊢ Iff (Membership.mem (s.piAntidiag n) f) (And (Eq (s.sum f) n) (∀ (i : ι), Ne (f i) 0 → Membership.mem s i))","decl":"@[simp] lemma mem_piAntidiag : f ∈ piAntidiag s n ↔ s.sum f = n ∧ ∀ i, f i ≠ 0 → i ∈ s := by\n  rw [piAntidiag]\n  induction' Fintype.truncEquivFinOfCardEq (Fintype.card_coe s) using Trunc.ind with e\n  simp only [Trunc.lift_mk, mem_map, mem_finAntidiagonal, Embedding.coeFn_mk]\n  constructor\n  · rintro ⟨f, ⟨hf, rfl⟩, rfl⟩\n    rw [sum_dite_of_true fun _ ↦ id]\n    exact ⟨Fintype.sum_equiv e _ _ (by simp), by simp +contextual⟩\n  · rintro ⟨rfl, hf⟩\n    refine ⟨f ∘ (↑) ∘ e.symm, ?_, by ext i; have := not_imp_comm.1 (hf i); aesop⟩\n    rw [← sum_attach s]\n    exact Fintype.sum_equiv e.symm _ _ (by simp)\n\n"}
{"name":"Finset.piAntidiag_empty_zero","module":"Mathlib.Algebra.Order.Antidiag.Pi","initialProofState":"ι : Type u_1\nμ : Type u_2\ninst✝³ : DecidableEq ι\ninst✝² : AddCommMonoid μ\ninst✝¹ : Finset.HasAntidiagonal μ\ninst✝ : DecidableEq μ\n⊢ Eq (EmptyCollection.emptyCollection.piAntidiag 0) (Singleton.singleton 0)","decl":"@[simp] lemma piAntidiag_empty_zero : piAntidiag (∅ : Finset ι) (0 : μ) = {0} := by\n  ext; simp [Fintype.sum_eq_zero_iff_of_nonneg, funext_iff, not_imp_comm, ← forall_and]\n\n"}
{"name":"Finset.piAntidiag_empty_of_ne_zero","module":"Mathlib.Algebra.Order.Antidiag.Pi","initialProofState":"ι : Type u_1\nμ : Type u_2\ninst✝³ : DecidableEq ι\ninst✝² : AddCommMonoid μ\ninst✝¹ : Finset.HasAntidiagonal μ\ninst✝ : DecidableEq μ\nn : μ\nhn : Ne n 0\n⊢ Eq (EmptyCollection.emptyCollection.piAntidiag n) EmptyCollection.emptyCollection","decl":"@[simp] lemma piAntidiag_empty_of_ne_zero (hn : n ≠ 0) : piAntidiag (∅ : Finset ι) n = ∅ :=\n  eq_empty_of_forall_not_mem (by simp [@eq_comm _ 0, hn.symm])\n\n"}
{"name":"Finset.piAntidiag_empty","module":"Mathlib.Algebra.Order.Antidiag.Pi","initialProofState":"ι : Type u_1\nμ : Type u_2\ninst✝³ : DecidableEq ι\ninst✝² : AddCommMonoid μ\ninst✝¹ : Finset.HasAntidiagonal μ\ninst✝ : DecidableEq μ\nn : μ\n⊢ Eq (EmptyCollection.emptyCollection.piAntidiag n) (ite (Eq n 0) (Singleton.singleton 0) EmptyCollection.emptyCollection)","decl":"lemma piAntidiag_empty (n : μ) : piAntidiag (∅ : Finset ι) n = if n = 0 then {0} else ∅ := by\n  split_ifs with hn <;> simp [*]\n\n"}
{"name":"Finset.finsetCongr_piAntidiag_eq_antidiag","module":"Mathlib.Algebra.Order.Antidiag.Pi","initialProofState":"μ : Type u_2\ninst✝² : AddCommMonoid μ\ninst✝¹ : Finset.HasAntidiagonal μ\ninst✝ : DecidableEq μ\nn : μ\n⊢ Eq ((Equiv.boolArrowEquivProd μ).finsetCongr (Finset.univ.piAntidiag n)) (Finset.HasAntidiagonal.antidiagonal n)","decl":"lemma finsetCongr_piAntidiag_eq_antidiag (n : μ) :\n    Equiv.finsetCongr (Equiv.boolArrowEquivProd _) (piAntidiag univ n) = antidiagonal n := by\n  ext ⟨x₁, x₂⟩\n  simp_rw [Equiv.finsetCongr_apply, mem_map, Equiv.toEmbedding, Function.Embedding.coeFn_mk,\n    ← Equiv.eq_symm_apply]\n  simp [add_comm]\n\n"}
{"name":"Finset.pairwiseDisjoint_piAntidiag_map_addRightEmbedding","module":"Mathlib.Algebra.Order.Antidiag.Pi","initialProofState":"ι : Type u_1\nμ : Type u_2\ninst✝³ : DecidableEq ι\ninst✝² : AddCancelCommMonoid μ\ninst✝¹ : Finset.HasAntidiagonal μ\ninst✝ : DecidableEq μ\ni : ι\ns : Finset ι\nhi : Not (Membership.mem s i)\nn : μ\n⊢ (↑(Finset.HasAntidiagonal.antidiagonal n)).PairwiseDisjoint fun p => Finset.map (addRightEmbedding fun j => ite (Eq j i) p.1 0) (s.piAntidiag p.2)","decl":"lemma pairwiseDisjoint_piAntidiag_map_addRightEmbedding (hi : i ∉ s) (n : μ) :\n    (antidiagonal n : Set (μ × μ)).PairwiseDisjoint fun p ↦\n      map (addRightEmbedding fun j ↦ if j = i then p.1 else 0) (s.piAntidiag p.2) := by\n  rintro ⟨a, b⟩ hab ⟨c, d⟩ hcd\n  simp only [ne_eq, antidiagonal_congr' hab hcd, disjoint_left, mem_map, mem_piAntidiag,\n    addRightEmbedding_apply, not_exists, not_and, and_imp, forall_exists_index]\n  rintro hfg _ f rfl - rfl g rfl - hgf\n  exact hfg <| by simpa [sum_add_distrib, hi] using congr_arg (∑ j ∈ s, · j) hgf.symm\n\n"}
{"name":"Finset.piAntidiag_cons","module":"Mathlib.Algebra.Order.Antidiag.Pi","initialProofState":"ι : Type u_1\nμ : Type u_2\ninst✝³ : DecidableEq ι\ninst✝² : AddCancelCommMonoid μ\ninst✝¹ : Finset.HasAntidiagonal μ\ninst✝ : DecidableEq μ\ni : ι\ns : Finset ι\nhi : Not (Membership.mem s i)\nn : μ\n⊢ Eq ((Finset.cons i s hi).piAntidiag n) ((Finset.HasAntidiagonal.antidiagonal n).disjiUnion (fun p => Finset.map (addRightEmbedding fun t => ite (Eq t i) p.1 0) (s.piAntidiag p.2)) ⋯)","decl":"lemma piAntidiag_cons (hi : i ∉ s) (n : μ) :\n    piAntidiag (cons i s hi) n = (antidiagonal n).disjiUnion (fun p : μ × μ ↦\n      (piAntidiag s p.snd).map (addRightEmbedding fun t ↦ if t = i then p.fst else 0))\n        (pairwiseDisjoint_piAntidiag_map_addRightEmbedding hi _) := by\n  ext f\n  simp only [mem_piAntidiag, sum_cons, ne_eq, mem_cons, mem_disjiUnion, mem_antidiagonal, mem_map,\n    addLeftEmbedding_apply, Prod.exists]\n  constructor\n  · rintro ⟨hn, hf⟩\n    refine ⟨_, _, hn, update f i 0, ⟨sum_update_of_not_mem hi _ _, fun j ↦ ?_⟩, by aesop⟩\n    have := fun h₁ h₂ ↦ (hf j h₁).resolve_left h₂\n    aesop (add simp [update])\n  · rintro ⟨a, _, hn, g, ⟨rfl, hg⟩, rfl⟩\n    have := hg i\n    aesop (add simp [sum_add_distrib])\n\n"}
{"name":"Finset.piAntidiag_insert","module":"Mathlib.Algebra.Order.Antidiag.Pi","initialProofState":"ι : Type u_1\nμ : Type u_2\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCancelCommMonoid μ\ninst✝² : Finset.HasAntidiagonal μ\ninst✝¹ : DecidableEq μ\ni : ι\ns : Finset ι\ninst✝ : DecidableEq (ι → μ)\nhi : Not (Membership.mem s i)\nn : μ\n⊢ Eq ((Insert.insert i s).piAntidiag n) ((Finset.HasAntidiagonal.antidiagonal n).biUnion fun p => Finset.image (fun f j => HAdd.hAdd (f j) (ite (Eq j i) p.1 0)) (s.piAntidiag p.2))","decl":"lemma piAntidiag_insert [DecidableEq (ι → μ)] (hi : i ∉ s) (n : μ) :\n    piAntidiag (insert i s) n = (antidiagonal n).biUnion fun p : μ × μ ↦ (piAntidiag s p.snd).image\n      (fun f j ↦ f j + if j = i then p.fst else 0) := by\n  simpa [map_eq_image, addRightEmbedding] using piAntidiag_cons hi n\n\n"}
{"name":"Finset.piAntidiag_zero","module":"Mathlib.Algebra.Order.Antidiag.Pi","initialProofState":"ι : Type u_1\nμ : Type u_2\ninst✝⁴ : DecidableEq ι\ninst✝³ : OrderedAddCommMonoid μ\ninst✝² : CanonicallyOrderedAdd μ\ninst✝¹ : Finset.HasAntidiagonal μ\ninst✝ : DecidableEq μ\ns : Finset ι\n⊢ Eq (s.piAntidiag 0) (Singleton.singleton 0)","decl":"@[simp] lemma piAntidiag_zero (s : Finset ι) : piAntidiag s (0 : μ) = {0} := by\n  ext; simp [Fintype.sum_eq_zero_iff_of_nonneg, funext_iff, not_imp_comm, ← forall_and]\n\n"}
{"name":"Finset.piAntidiag_univ_fin_eq_antidiagonalTuple","module":"Mathlib.Algebra.Order.Antidiag.Pi","initialProofState":"n k : Nat\n⊢ Eq (Finset.univ.piAntidiag n) (Finset.Nat.antidiagonalTuple k n)","decl":"lemma piAntidiag_univ_fin_eq_antidiagonalTuple (n k : ℕ) :\n    piAntidiag univ n = Nat.antidiagonalTuple k n := by\n  ext; simp [Nat.mem_antidiagonalTuple]\n\n"}
{"name":"Finset.nsmul_piAntidiag","module":"Mathlib.Algebra.Order.Antidiag.Pi","initialProofState":"ι : Type u_1\ninst✝¹ : DecidableEq ι\ninst✝ : DecidableEq (ι → Nat)\ns : Finset ι\nm n : Nat\nhn : Ne n 0\n⊢ Eq (SMul.smul n (s.piAntidiag m)) (Finset.filter (fun f => ∀ (i : ι), Membership.mem s i → Dvd.dvd n (f i)) (s.piAntidiag (HMul.hMul n m)))","decl":"lemma nsmul_piAntidiag [DecidableEq (ι → ℕ)] (s : Finset ι) (m : ℕ) {n : ℕ} (hn : n ≠ 0) :\n    n •ℕ piAntidiag s m = (piAntidiag s (n * m)).filter fun f : ι → ℕ ↦ ∀ i ∈ s, n ∣ f i := by\n  ext f\n  refine mem_smul_finset.trans ?_\n  simp only [mem_smul_finset, mem_filter, mem_piAntidiag, Function.Embedding.coeFn_mk, exists_prop,\n    and_assoc]\n  constructor\n  · rintro ⟨f, rfl, hf, rfl⟩\n    simpa [← mul_sum, hn] using hf\n  rintro ⟨hfsum, hfsup, hfdvd⟩\n  have (i) : n ∣ f i := by\n    by_cases hi : i ∈ s\n    · exact hfdvd _ hi\n    · rw [not_imp_comm.1 (hfsup _) hi]\n      exact dvd_zero _\n  refine ⟨fun i ↦ f i / n, ?_⟩\n  simp [funext_iff, Nat.mul_div_cancel', ← Nat.sum_div, *]\n  aesop\n\n"}
{"name":"Finset.map_nsmul_piAntidiag","module":"Mathlib.Algebra.Order.Antidiag.Pi","initialProofState":"ι : Type u_1\ninst✝ : DecidableEq ι\ns : Finset ι\nm n : Nat\nhn : Ne n 0\n⊢ Eq (Finset.map { toFun := fun x => HSMul.hSMul n x, inj' := ⋯ } (s.piAntidiag m)) (Finset.filter (fun f => ∀ (i : ι), Membership.mem s i → Dvd.dvd n (f i)) (s.piAntidiag (HMul.hMul n m)))","decl":"lemma map_nsmul_piAntidiag (s : Finset ι) (m : ℕ) {n : ℕ} (hn : n ≠ 0) :\n    (piAntidiag s m).map\n      ⟨(n • ·), fun _ _ h ↦ funext fun i ↦ mul_right_injective₀ hn (congr_fun h i)⟩ =\n        (piAntidiag s (n * m)).filter fun f : ι → ℕ ↦ ∀ i ∈ s, n ∣ f i := by\n  classical rw [map_eq_image]; exact nsmul_piAntidiag _ _ hn\n\n"}
{"name":"Finset.nsmul_piAntidiag_univ","module":"Mathlib.Algebra.Order.Antidiag.Pi","initialProofState":"ι : Type u_1\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nm n : Nat\nhn : Ne n 0\n⊢ Eq (SMul.smul n (Finset.univ.piAntidiag m)) (Finset.filter (fun f => ∀ (i : ι), Dvd.dvd n (f i)) (Finset.univ.piAntidiag (HMul.hMul n m)))","decl":"lemma nsmul_piAntidiag_univ [Fintype ι] (m : ℕ) {n : ℕ} (hn : n ≠ 0) :\n    @SMul.smul _ _ Finset.smulFinset n (piAntidiag univ m) =\n      (piAntidiag univ (n * m)).filter fun f : ι → ℕ ↦ ∀ i, n ∣ f i := by\n  simpa using nsmul_piAntidiag (univ : Finset ι) m hn\n\n"}
{"name":"Finset.map_nsmul_piAntidiag_univ","module":"Mathlib.Algebra.Order.Antidiag.Pi","initialProofState":"ι : Type u_1\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nm n : Nat\nhn : Ne n 0\n⊢ Eq (Finset.map { toFun := fun x => HSMul.hSMul n x, inj' := ⋯ } (Finset.univ.piAntidiag m)) (Finset.filter (fun f => ∀ (i : ι), Dvd.dvd n (f i)) (Finset.univ.piAntidiag (HMul.hMul n m)))","decl":"lemma map_nsmul_piAntidiag_univ [Fintype ι] (m : ℕ) {n : ℕ} (hn : n ≠ 0) :\n    (piAntidiag (univ : Finset ι) m).map\n        ⟨(n • ·), fun _ _ h ↦ funext fun i ↦ mul_right_injective₀ hn (congr_fun h i)⟩ =\n      (piAntidiag univ (n * m)).filter fun f : ι → ℕ ↦ ∀ i, n ∣ f i := by\n  simpa using map_nsmul_piAntidiag (univ : Finset ι) m hn\n\n"}
{"name":"Finset.map_sym_eq_piAntidiag","module":"Mathlib.Algebra.Order.Antidiag.Pi","initialProofState":"ι : Type u_1\ninst✝ : DecidableEq ι\ns : Finset ι\nn : Nat\n⊢ Eq (Finset.map { toFun := fun m a => Multiset.count a ↑m, inj' := ⋯ } (s.sym n)) (s.piAntidiag n)","decl":"lemma map_sym_eq_piAntidiag [DecidableEq ι] (s : Finset ι) (n : ℕ) :\n    (s.sym n).map ⟨fun m a ↦ m.1.count a, Multiset.count_injective.comp Sym.coe_injective⟩ =\n      piAntidiag s n := by\n  ext f\n  simp only [Sym.val_eq_coe, mem_map, mem_sym_iff, Embedding.coeFn_mk, funext_iff, Sym.exists,\n    Sym.mem_mk, Sym.coe_mk, exists_and_left, exists_prop, mem_piAntidiag, ne_eq]\n  constructor\n  · rintro ⟨m, hm, rfl, hf⟩\n    simpa [← hf, Multiset.sum_count_eq_card hm]\n  · rintro ⟨rfl, hf⟩\n    refine ⟨∑ a ∈ s, f a • {a}, ?_, ?_⟩\n    · simp +contextual\n    · simpa [Multiset.count_sum', Multiset.count_singleton, not_imp_comm, eq_comm (a := 0)] using hf\n\n"}
