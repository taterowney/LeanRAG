{"name":"MonomialOrder.degree_sub_LTerm_le","module":"Mathlib.RingTheory.MvPolynomial.Groebner","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommRing R\nf : MvPolynomial σ R\n⊢ LE.le (m.toSyn (m.degree (m.subLTerm f))) (m.toSyn (m.degree f))","decl":"theorem degree_sub_LTerm_le (f : MvPolynomial σ R) :\n    m.degree (m.subLTerm f) ≼[m] m.degree f := by\n  apply le_trans degree_sub_le\n  simp only [sup_le_iff, le_refl, true_and]\n  apply degree_monomial_le\n\n"}
{"name":"MonomialOrder.degree_sub_LTerm_lt","module":"Mathlib.RingTheory.MvPolynomial.Groebner","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommRing R\nf : MvPolynomial σ R\nhf : Ne (m.degree f) 0\n⊢ LT.lt (m.toSyn (m.degree (m.subLTerm f))) (m.toSyn (m.degree f))","decl":"theorem degree_sub_LTerm_lt {f : MvPolynomial σ R} (hf : m.degree f ≠ 0) :\n    m.degree (m.subLTerm f) ≺[m] m.degree f := by\n  rw [lt_iff_le_and_ne]\n  refine ⟨degree_sub_LTerm_le f, ?_⟩\n  classical\n  intro hf'\n  simp only [EmbeddingLike.apply_eq_iff_eq] at hf'\n  have : m.subLTerm f ≠ 0 := by\n    intro h\n    simp only [h, degree_zero] at hf'\n    exact hf hf'.symm\n  rw [← coeff_degree_ne_zero_iff (m := m), hf'] at this\n  apply this\n  simp [subLTerm, coeff_monomial, leadingCoeff]\n\n"}
{"name":"MonomialOrder.degree_reduce_lt","module":"Mathlib.RingTheory.MvPolynomial.Groebner","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommRing R\nf b : MvPolynomial σ R\nhb : IsUnit (m.leadingCoeff b)\nhbf : LE.le (m.degree b) (m.degree f)\nhf : Ne (m.degree f) 0\n⊢ LT.lt (m.toSyn (m.degree (m.reduce hb f))) (m.toSyn (m.degree f))","decl":"theorem degree_reduce_lt {f b : MvPolynomial σ R} (hb : IsUnit (m.leadingCoeff b))\n    (hbf : m.degree b ≤ m.degree f) (hf : m.degree f ≠ 0) :\n    m.degree (m.reduce hb f) ≺[m] m.degree f := by\n  have H : m.degree f =\n    m.degree ((monomial (m.degree f - m.degree b)) (hb.unit⁻¹ * m.leadingCoeff f)) +\n      m.degree b := by\n    classical\n    rw [degree_monomial, if_neg]\n    · ext d\n      rw [tsub_add_cancel_of_le hbf]\n    · simp only [Units.mul_right_eq_zero, leadingCoeff_eq_zero_iff]\n      intro hf0\n      apply hf\n      simp [hf0]\n  have H' : coeff (m.degree f) (m.reduce hb f) = 0 := by\n    simp only [reduce, coeff_sub, sub_eq_zero]\n    nth_rewrite 2 [H]\n    rw [coeff_mul_of_degree_add (m := m), leadingCoeff_monomial]\n    rw [mul_comm, ← mul_assoc]\n    simp only [IsUnit.mul_val_inv, one_mul]\n    rfl\n  rw [lt_iff_le_and_ne]\n  constructor\n  · classical\n    apply le_trans degree_sub_le\n    simp only [sup_le_iff, le_refl, true_and]\n    apply le_of_le_of_eq degree_mul_le\n    rw [m.toSyn.injective.eq_iff]\n    exact H.symm\n  · intro K\n    simp only [EmbeddingLike.apply_eq_iff_eq] at K\n    nth_rewrite 1 [← K] at H'\n    change leadingCoeff m _ = 0 at H'\n    rw [leadingCoeff_eq_zero_iff] at H'\n    rw [H', degree_zero] at K\n    exact hf K.symm\n\n"}
{"name":"MonomialOrder.div","module":"Mathlib.RingTheory.MvPolynomial.Groebner","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommRing R\nι : Type u_3\nb : ι → MvPolynomial σ R\nhb : ∀ (i : ι), IsUnit (m.leadingCoeff (b i))\nf : MvPolynomial σ R\n⊢ Exists fun g => Exists fun r => And (Eq f (HAdd.hAdd ((Finsupp.linearCombination (MvPolynomial σ R) b) g) r)) (And (∀ (i : ι), LE.le (m.toSyn (m.degree (HMul.hMul (b i) (g i)))) (m.toSyn (m.degree f))) (∀ (c : Finsupp σ Nat), Membership.mem r.support c → ∀ (i : ι), Not (LE.le (m.degree (b i)) c)))","decl":"theorem div {ι : Type*} {b : ι → MvPolynomial σ R}\n    (hb : ∀ i, IsUnit (m.leadingCoeff (b i))) (f : MvPolynomial σ R) :\n    ∃ (g : ι →₀ (MvPolynomial σ R)) (r : MvPolynomial σ R),\n      f = Finsupp.linearCombination _ b g + r ∧\n        (∀ i, m.degree (b i * (g i)) ≼[m] m.degree f) ∧\n        (∀ c ∈ r.support, ∀ i, ¬ (m.degree (b i) ≤ c)) := by\n  by_cases hb' : ∃ i, m.degree (b i) = 0\n  · obtain ⟨i, hb0⟩ := hb'\n    use Finsupp.single i ((hb i).unit⁻¹ • f), 0\n    constructor\n    · simp only [Finsupp.linearCombination_single, smul_eq_mul, add_zero]\n      simp only [smul_mul_assoc, ← smul_eq_iff_eq_inv_smul, Units.smul_isUnit]\n      nth_rewrite 2 [eq_C_of_degree_eq_zero hb0]\n      rw [mul_comm, smul_eq_C_mul]\n    constructor\n    · intro j\n      by_cases hj : j = i\n      · apply le_trans degree_mul_le\n        simp only [hj, hb0, Finsupp.single_eq_same, zero_add]\n        apply le_of_eq\n        simp only [EmbeddingLike.apply_eq_iff_eq]\n        apply degree_smul (Units.isRegular _)\n      · simp only [Finsupp.single_eq_of_ne (Ne.symm hj), mul_zero, degree_zero, map_zero]\n        apply bot_le\n    · simp\n  push_neg at hb'\n  by_cases hf0 : f = 0\n  · refine ⟨0, 0, by simp [hf0], ?_, by simp⟩\n    intro b\n    simp only [Finsupp.coe_zero, Pi.zero_apply, mul_zero, degree_zero, map_zero]\n    exact bot_le\n  by_cases hf : ∃ i, m.degree (b i) ≤ m.degree f\n  · obtain ⟨i, hf⟩ := hf\n    have deg_reduce : m.degree (m.reduce (hb i) f) ≺[m] m.degree f := by\n      apply degree_reduce_lt (hb i) hf\n      intro hf0'\n      apply hb' i\n      simpa [hf0'] using hf\n    obtain ⟨g', r', H'⟩ := div hb (m.reduce (hb i) f)\n    use g' +\n      Finsupp.single i (monomial (m.degree f - m.degree (b i)) ((hb i).unit⁻¹ * m.leadingCoeff f))\n    use r'\n    constructor\n    · rw [map_add, add_assoc, add_comm _ r', ← add_assoc, ← H'.1]\n      simp [reduce]\n    constructor\n    · rintro j\n      simp only [Finsupp.coe_add, Pi.add_apply]\n      rw [mul_add]\n      apply le_trans degree_add_le\n      simp only [sup_le_iff]\n      constructor\n      · exact le_trans (H'.2.1 _) (le_of_lt deg_reduce)\n      · classical\n        rw [Finsupp.single_apply]\n        split_ifs with hc\n        · apply le_trans degree_mul_le\n          simp only [map_add]\n          apply le_of_le_of_eq (add_le_add_left (degree_monomial_le _) _)\n          simp only [← hc]\n          rw [← map_add, m.toSyn.injective.eq_iff]\n          rw [add_tsub_cancel_of_le]\n          exact hf\n        · simp only [mul_zero, degree_zero, map_zero]\n          exact bot_le\n    · exact H'.2.2\n  · push_neg at hf\n    suffices ∃ (g' : ι →₀ MvPolynomial σ R), ∃ r',\n        (m.subLTerm f = Finsupp.linearCombination (MvPolynomial σ R) b g' + r') ∧\n        (∀ i, m.degree ((b  i) * (g' i)) ≼[m] m.degree (m.subLTerm f)) ∧\n        (∀ c ∈ r'.support, ∀ i, ¬ m.degree (b i) ≤ c) by\n      obtain ⟨g', r', H'⟩ := this\n      use g', r' +  monomial (m.degree f) (m.leadingCoeff f)\n      constructor\n      · simp [← add_assoc, ← H'.1, subLTerm]\n      constructor\n      · exact fun b ↦ le_trans (H'.2.1 b) (degree_sub_LTerm_le f)\n      · intro c hc i\n        by_cases hc' : c ∈ r'.support\n        · exact H'.2.2 c hc' i\n        · convert hf i\n          classical\n          have := MvPolynomial.support_add hc\n          rw [Finset.mem_union, Classical.or_iff_not_imp_left] at this\n          simpa only [Finset.mem_singleton] using support_monomial_subset (this hc')\n    by_cases hf'0 : m.subLTerm f = 0\n    · refine ⟨0, 0, by simp [hf'0], ?_, by simp⟩\n      intro b\n      simp only [Finsupp.coe_zero, Pi.zero_apply, mul_zero, degree_zero, map_zero]\n      exact bot_le\n    · exact (div hb) (m.subLTerm f)\ntermination_by WellFounded.wrap\n  ((isWellFounded_iff m.syn fun x x_1 ↦ x < x_1).mp m.wf) (m.toSyn (m.degree f))\ndecreasing_by\n· exact deg_reduce\n· apply degree_sub_LTerm_lt\n  intro hf0\n  apply hf'0\n  simp only [subLTerm, sub_eq_zero]\n  nth_rewrite 1 [eq_C_of_degree_eq_zero hf0, hf0]\n  simp\n\n"}
{"name":"MonomialOrder.div_set","module":"Mathlib.RingTheory.MvPolynomial.Groebner","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommRing R\nB : Set (MvPolynomial σ R)\nhB : ∀ (b : MvPolynomial σ R), Membership.mem B b → IsUnit (m.leadingCoeff b)\nf : MvPolynomial σ R\n⊢ Exists fun g => Exists fun r => And (Eq f (HAdd.hAdd ((Finsupp.linearCombination (MvPolynomial σ R) fun b => ↑b) g) r)) (And (∀ (b : ↑B), LE.le (m.toSyn (m.degree (HMul.hMul (↑b) (g b)))) (m.toSyn (m.degree f))) (∀ (c : Finsupp σ Nat), Membership.mem r.support c → ∀ (b : MvPolynomial σ R), Membership.mem B b → Not (LE.le (m.degree b) c)))","decl":"theorem div_set {B : Set (MvPolynomial σ R)}\n    (hB : ∀ b ∈ B, IsUnit (m.leadingCoeff b)) (f : MvPolynomial σ R) :\n    ∃ (g : B →₀ (MvPolynomial σ R)) (r : MvPolynomial σ R),\n      f = Finsupp.linearCombination _ (fun (b : B) ↦ (b : MvPolynomial σ R)) g + r ∧\n        (∀ (b : B), m.degree ((b : MvPolynomial σ R) * (g b)) ≼[m] m.degree f) ∧\n        (∀ c ∈ r.support, ∀ b ∈ B, ¬ (m.degree b ≤ c)) := by\n  obtain ⟨g, r, H⟩ := m.div (b := fun (p : B) ↦ p) (fun b ↦ hB b b.prop) f\n  exact ⟨g, r, H.1, H.2.1, fun c hc b hb ↦ H.2.2 c hc ⟨b, hb⟩⟩\n\n"}
