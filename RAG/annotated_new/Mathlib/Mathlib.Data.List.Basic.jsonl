{"name":"List.replicate_append_replicate","module":"Mathlib.Data.List.Basic","initialProofState":"n : Nat\nα✝ : Type u_1\na : α✝\nm : Nat\n⊢ Eq (HAppend.hAppend (List.replicate n a) (List.replicate m a)) (List.replicate (HAdd.hAdd n m) a)","decl":"alias replicate_append_replicate := append_replicate_replicate\n"}
{"name":"List.append_eq_nil_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α✝ : Type u_1\np q : List α✝\n⊢ Iff (Eq (HAppend.hAppend p q) List.nil) (And (Eq p List.nil) (Eq q List.nil))","decl":"alias append_eq_nil_iff := append_eq_nil\n\n"}
{"name":"List.instLawfulIdentityAppendNil","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\n⊢ Std.LawfulIdentity Append.append List.nil","decl":"instance : Std.LawfulIdentity (α := List α) Append.append [] where\n  left_id := nil_append\n  right_id := append_nil\n\n"}
{"name":"List.instAssociativeAppend","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\n⊢ Std.Associative Append.append","decl":"instance : Std.Associative (α := List α) Append.append where\n  assoc := append_assoc\n\n"}
{"name":"List.cons_injective","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\na : α\n⊢ Function.Injective (List.cons a)","decl":"@[simp] theorem cons_injective {a : α} : Injective (cons a) := fun _ _ => tail_eq_of_cons_eq\n\n"}
{"name":"List.singleton_injective","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\n⊢ Function.Injective fun a => List.cons a List.nil","decl":"theorem singleton_injective : Injective fun a : α => [a] := fun _ _ h => (cons_eq_cons.1 h).1\n\n"}
{"name":"List.set_of_mem_cons","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\na : α\n⊢ Eq (setOf fun x => Membership.mem (List.cons a l) x) (Insert.insert a (setOf fun x => Membership.mem l x))","decl":"theorem set_of_mem_cons (l : List α) (a : α) : { x | x ∈ a :: l } = insert a { x | x ∈ l } :=\n  Set.ext fun _ => mem_cons\n\n"}
{"name":"Decidable.List.eq_or_ne_mem_of_mem","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\na b : α\nl : List α\nh : Membership.mem (List.cons b l) a\n⊢ Or (Eq a b) (And (Ne a b) (Membership.mem l a))","decl":"theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]\n    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by\n  by_cases hab : a = b\n  · exact Or.inl hab\n  · exact ((List.mem_cons.1 h).elim Or.inl (fun h => Or.inr ⟨hab, h⟩))\n\n"}
{"name":"List.mem_pair","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\na b c : α\n⊢ Iff (Membership.mem (List.cons b (List.cons c List.nil)) a) (Or (Eq a b) (Eq a c))","decl":"lemma mem_pair {a b c : α} : a ∈ [b, c] ↔ a = b ∨ a = c := by\n  rw [mem_cons, mem_singleton]\n\n\n-- The simpNF linter says that the LHS can be simplified via `List.mem_map`.\n-- However this is a higher priority lemma.\n-- https://github.com/leanprover/std4/issues/207\n"}
{"name":"List.mem_map_of_injective","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nH : Function.Injective f\na : α\nl : List α\n⊢ Iff (Membership.mem (List.map f l) (f a)) (Membership.mem l a)","decl":"@[simp 1100, nolint simpNF]\ntheorem mem_map_of_injective {f : α → β} (H : Injective f) {a : α} {l : List α} :\n    f a ∈ map f l ↔ a ∈ l :=\n  ⟨fun m => let ⟨_, m', e⟩ := exists_of_mem_map m; H e ▸ m', mem_map_of_mem _⟩\n\n"}
{"name":"Function.Involutive.exists_mem_and_apply_eq_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nf : α → α\nhf : Function.Involutive f\nx : α\nl : List α\n⊢ Iff (Exists fun y => And (Membership.mem l y) (Eq (f y) x)) (Membership.mem l (f x))","decl":"@[simp]\ntheorem _root_.Function.Involutive.exists_mem_and_apply_eq_iff {f : α → α}\n    (hf : Function.Involutive f) (x : α) (l : List α) : (∃ y : α, y ∈ l ∧ f y = x) ↔ f x ∈ l :=\n  ⟨by rintro ⟨y, h, rfl⟩; rwa [hf y], fun h => ⟨f x, h, hf _⟩⟩\n\n"}
{"name":"List.mem_map_of_involutive","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nf : α → α\nhf : Function.Involutive f\na : α\nl : List α\n⊢ Iff (Membership.mem (List.map f l) a) (Membership.mem l (f a))","decl":"theorem mem_map_of_involutive {f : α → α} (hf : Involutive f) {a : α} {l : List α} :\n    a ∈ map f l ↔ f a ∈ l := by rw [mem_map, hf.exists_mem_and_apply_eq_iff]\n\n"}
{"name":"List.length_pos_of_ne_nil","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u_1\nl : List α\na✝ : Ne l List.nil\n⊢ LT.lt 0 l.length","decl":"alias ⟨_, length_pos_of_ne_nil⟩ := length_pos\n\n"}
{"name":"List.length_pos_iff_ne_nil","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\n⊢ Iff (LT.lt 0 l.length) (Ne l List.nil)","decl":"theorem length_pos_iff_ne_nil {l : List α} : 0 < length l ↔ l ≠ [] :=\n  ⟨ne_nil_of_length_pos, length_pos_of_ne_nil⟩\n\n"}
{"name":"List.exists_of_length_succ","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nn : Nat\nl : List α\na✝ : Eq l.length (HAdd.hAdd n 1)\n⊢ Exists fun h => Exists fun t => Eq l (List.cons h t)","decl":"theorem exists_of_length_succ {n} : ∀ l : List α, l.length = n + 1 → ∃ h t, l = h :: t\n  | [], H => absurd H.symm <| succ_ne_zero n\n  | h :: t, _ => ⟨h, t, rfl⟩\n\n"}
{"name":"List.length_injective_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\n⊢ Iff (Function.Injective List.length) (Subsingleton α)","decl":"@[simp] lemma length_injective_iff : Injective (List.length : List α → ℕ) ↔ Subsingleton α := by\n  constructor\n  · intro h; refine ⟨fun x y => ?_⟩; (suffices [x] = [y] by simpa using this); apply h; rfl\n  · intros hα l1 l2 hl\n    induction l1 generalizing l2 <;> cases l2\n    · rfl\n    · cases hl\n    · cases hl\n    · next ih _ _ =>\n      congr\n      · subsingleton\n      · apply ih; simpa using hl\n\n"}
{"name":"List.length_injective","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : Subsingleton α\n⊢ Function.Injective List.length","decl":"@[simp default+1] -- Porting note: this used to be just @[simp]\nlemma length_injective [Subsingleton α] : Injective (length : List α → ℕ) :=\n  length_injective_iff.mpr inferInstance\n\n"}
{"name":"List.length_eq_two","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\n⊢ Iff (Eq l.length 2) (Exists fun a => Exists fun b => Eq l (List.cons a (List.cons b List.nil)))","decl":"theorem length_eq_two {l : List α} : l.length = 2 ↔ ∃ a b, l = [a, b] :=\n  ⟨fun _ => let [a, b] := l; ⟨a, b, rfl⟩, fun ⟨_, _, e⟩ => e ▸ rfl⟩\n\n"}
{"name":"List.length_eq_three","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\n⊢ Iff (Eq l.length 3) (Exists fun a => Exists fun b => Exists fun c => Eq l (List.cons a (List.cons b (List.cons c List.nil))))","decl":"theorem length_eq_three {l : List α} : l.length = 3 ↔ ∃ a b c, l = [a, b, c] :=\n  ⟨fun _ => let [a, b, c] := l; ⟨a, b, c, rfl⟩, fun ⟨_, _, _, e⟩ => e ▸ rfl⟩\n\n"}
{"name":"List.instLawfulSingleton","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\n⊢ LawfulSingleton α (List α)","decl":"instance [DecidableEq α] : LawfulSingleton α (List α) :=\n  { insert_emptyc_eq := fun x =>\n      show (if x ∈ ([] : List α) then [] else [x]) = [x] from if_neg (not_mem_nil _) }\n\n"}
{"name":"List.singleton_eq","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nx : α\n⊢ Eq (Singleton.singleton x) (List.cons x List.nil)","decl":"theorem singleton_eq (x : α) : ({x} : List α) = [x] :=\n  rfl\n\n"}
{"name":"List.insert_neg","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\nx : α\nl : List α\nh : Not (Membership.mem l x)\n⊢ Eq (Insert.insert x l) (List.cons x l)","decl":"theorem insert_neg [DecidableEq α] {x : α} {l : List α} (h : x ∉ l) :\n    Insert.insert x l = x :: l :=\n  insert_of_not_mem h\n\n"}
{"name":"List.insert_pos","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\nx : α\nl : List α\nh : Membership.mem l x\n⊢ Eq (Insert.insert x l) l","decl":"theorem insert_pos [DecidableEq α] {x : α} {l : List α} (h : x ∈ l) : Insert.insert x l = l :=\n  insert_of_mem h\n\n"}
{"name":"List.doubleton_eq","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\nx y : α\nh : Ne x y\n⊢ Eq (Insert.insert x (Singleton.singleton y)) (List.cons x (List.cons y List.nil))","decl":"theorem doubleton_eq [DecidableEq α] {x y : α} (h : x ≠ y) : ({x, y} : List α) = [x, y] := by\n  rw [insert_neg, singleton_eq]\n  rwa [singleton_eq, mem_singleton]\n\n"}
{"name":"List.forall_mem_of_forall_mem_cons","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Prop\na : α\nl : List α\nh : ∀ (x : α), Membership.mem (List.cons a l) x → p x\nx : α\na✝ : Membership.mem l x\n⊢ p x","decl":"theorem forall_mem_of_forall_mem_cons {p : α → Prop} {a : α} {l : List α} (h : ∀ x ∈ a :: l, p x) :\n    ∀ x ∈ l, p x := (forall_mem_cons.1 h).2\n\n-- Porting note: bExists in Lean3 and And in Lean4\n"}
{"name":"List.exists_mem_cons_of","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Prop\na : α\nl : List α\nh : p a\n⊢ Exists fun x => And (Membership.mem (List.cons a l) x) (p x)","decl":"theorem exists_mem_cons_of {p : α → Prop} {a : α} (l : List α) (h : p a) : ∃ x ∈ a :: l, p x :=\n  ⟨a, mem_cons_self _ _, h⟩\n\n-- Porting note: bExists in Lean3 and And in Lean4\n"}
{"name":"List.exists_mem_cons_of_exists","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Prop\na : α\nl : List α\na✝ : Exists fun x => And (Membership.mem l x) (p x)\n⊢ Exists fun x => And (Membership.mem (List.cons a l) x) (p x)","decl":"theorem exists_mem_cons_of_exists {p : α → Prop} {a : α} {l : List α} : (∃ x ∈ l, p x) →\n    ∃ x ∈ a :: l, p x :=\n  fun ⟨x, xl, px⟩ => ⟨x, mem_cons_of_mem _ xl, px⟩\n\n-- Porting note: bExists in Lean3 and And in Lean4\n"}
{"name":"List.or_exists_of_exists_mem_cons","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Prop\na : α\nl : List α\na✝ : Exists fun x => And (Membership.mem (List.cons a l) x) (p x)\n⊢ Or (p a) (Exists fun x => And (Membership.mem l x) (p x))","decl":"theorem or_exists_of_exists_mem_cons {p : α → Prop} {a : α} {l : List α} : (∃ x ∈ a :: l, p x) →\n    p a ∨ ∃ x ∈ l, p x :=\n  fun ⟨x, xal, px⟩ =>\n    Or.elim (eq_or_mem_of_mem_cons xal) (fun h : x = a => by rw [← h]; left; exact px)\n      fun h : x ∈ l => Or.inr ⟨x, h, px⟩\n\n"}
{"name":"List.exists_mem_cons_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Prop\na : α\nl : List α\n⊢ Iff (Exists fun x => And (Membership.mem (List.cons a l) x) (p x)) (Or (p a) (Exists fun x => And (Membership.mem l x) (p x)))","decl":"theorem exists_mem_cons_iff (p : α → Prop) (a : α) (l : List α) :\n    (∃ x ∈ a :: l, p x) ↔ p a ∨ ∃ x ∈ l, p x :=\n  Iff.intro or_exists_of_exists_mem_cons fun h =>\n    Or.elim h (exists_mem_cons_of l) exists_mem_cons_of_exists\n\n"}
{"name":"List.cons_subset_of_subset_of_mem","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\na : α\nl m : List α\nainm : Membership.mem m a\nlsubm : HasSubset.Subset l m\n⊢ HasSubset.Subset (List.cons a l) m","decl":"theorem cons_subset_of_subset_of_mem {a : α} {l m : List α}\n    (ainm : a ∈ m) (lsubm : l ⊆ m) : a::l ⊆ m :=\n  cons_subset.2 ⟨ainm, lsubm⟩\n\n"}
{"name":"List.append_subset_of_subset_of_subset","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ l : List α\nl₁subl : HasSubset.Subset l₁ l\nl₂subl : HasSubset.Subset l₂ l\n⊢ HasSubset.Subset (HAppend.hAppend l₁ l₂) l","decl":"theorem append_subset_of_subset_of_subset {l₁ l₂ l : List α} (l₁subl : l₁ ⊆ l) (l₂subl : l₂ ⊆ l) :\n    l₁ ++ l₂ ⊆ l :=\n  fun _ h ↦ (mem_append.1 h).elim (@l₁subl _) (@l₂subl _)\n\n"}
{"name":"List.map_subset_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nl₁ l₂ : List α\nf : α → β\nh : Function.Injective f\n⊢ Iff (HasSubset.Subset (List.map f l₁) (List.map f l₂)) (HasSubset.Subset l₁ l₂)","decl":"theorem map_subset_iff {l₁ l₂ : List α} (f : α → β) (h : Injective f) :\n    map f l₁ ⊆ map f l₂ ↔ l₁ ⊆ l₂ := by\n  refine ⟨?_, map_subset f⟩; intro h2 x hx\n  rcases mem_map.1 (h2 (mem_map_of_mem f hx)) with ⟨x', hx', hxx'⟩\n  cases h hxx'; exact hx'\n\n"}
{"name":"List.append_eq_has_append","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nL₁ L₂ : List α\n⊢ Eq (L₁.append L₂) (HAppend.hAppend L₁ L₂)","decl":"theorem append_eq_has_append {L₁ L₂ : List α} : List.append L₁ L₂ = L₁ ++ L₂ :=\n  rfl\n\n"}
{"name":"List.append_right_injective","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ns : List α\n⊢ Function.Injective fun t => HAppend.hAppend s t","decl":"theorem append_right_injective (s : List α) : Injective fun t ↦ s ++ t :=\n  fun _ _ ↦ append_cancel_left\n\n"}
{"name":"List.append_left_injective","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nt : List α\n⊢ Function.Injective fun s => HAppend.hAppend s t","decl":"theorem append_left_injective (t : List α) : Injective fun s ↦ s ++ t :=\n  fun _ _ ↦ append_cancel_right\n\n"}
{"name":"List.eq_replicate_length","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\na : α\nl : List α\n⊢ Iff (Eq l (List.replicate l.length a)) (∀ (b : α), Membership.mem l b → Eq b a)","decl":"theorem eq_replicate_length {a : α} : ∀ {l : List α}, l = replicate l.length a ↔ ∀ b ∈ l, b = a\n  | [] => by simp\n  | (b :: l) => by simp [eq_replicate_length, replicate_succ]\n\n"}
{"name":"List.replicate_add","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nm n : Nat\na : α\n⊢ Eq (List.replicate (HAdd.hAdd m n) a) (HAppend.hAppend (List.replicate m a) (List.replicate n a))","decl":"theorem replicate_add (m n) (a : α) : replicate (m + n) a = replicate m a ++ replicate n a := by\n  rw [replicate_append_replicate]\n\n"}
{"name":"List.replicate_subset_singleton","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nn : Nat\na : α\n⊢ HasSubset.Subset (List.replicate n a) (List.cons a List.nil)","decl":"theorem replicate_subset_singleton (n) (a : α) : replicate n a ⊆ [a] := fun _ h =>\n  mem_singleton.2 (eq_of_mem_replicate h)\n\n"}
{"name":"List.subset_singleton_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\na : α\nL : List α\n⊢ Iff (HasSubset.Subset L (List.cons a List.nil)) (Exists fun n => Eq L (List.replicate n a))","decl":"theorem subset_singleton_iff {a : α} {L : List α} : L ⊆ [a] ↔ ∃ n, L = replicate n a := by\n  simp only [eq_replicate_iff, subset_def, mem_singleton, exists_eq_left']\n\n"}
{"name":"List.replicate_right_injective","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nn : Nat\nhn : Ne n 0\n⊢ Function.Injective (List.replicate n)","decl":"theorem replicate_right_injective {n : ℕ} (hn : n ≠ 0) : Injective (@replicate α n) :=\n  fun _ _ h => (eq_replicate_iff.1 h).2 _ <| mem_replicate.2 ⟨hn, rfl⟩\n\n"}
{"name":"List.replicate_right_inj","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\na b : α\nn : Nat\nhn : Ne n 0\n⊢ Iff (Eq (List.replicate n a) (List.replicate n b)) (Eq a b)","decl":"theorem replicate_right_inj {a b : α} {n : ℕ} (hn : n ≠ 0) :\n    replicate n a = replicate n b ↔ a = b :=\n  (replicate_right_injective hn).eq_iff\n\n"}
{"name":"List.replicate_right_inj'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\na b : α\nn : Nat\n⊢ Iff (Eq (List.replicate n a) (List.replicate n b)) (Or (Eq n 0) (Eq a b))","decl":"theorem replicate_right_inj' {a b : α} : ∀ {n},\n    replicate n a = replicate n b ↔ n = 0 ∨ a = b\n  | 0 => by simp\n  | n + 1 => (replicate_right_inj n.succ_ne_zero).trans <| by simp only [n.succ_ne_zero, false_or]\n\n"}
{"name":"List.replicate_left_injective","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\na : α\n⊢ Function.Injective fun x => List.replicate x a","decl":"theorem replicate_left_injective (a : α) : Injective (replicate · a) :=\n  LeftInverse.injective (length_replicate · a)\n\n"}
{"name":"List.replicate_left_inj","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\na : α\nn m : Nat\n⊢ Iff (Eq (List.replicate n a) (List.replicate m a)) (Eq n m)","decl":"theorem replicate_left_inj {a : α} {n m : ℕ} : replicate n a = replicate m a ↔ n = m :=\n  (replicate_left_injective a).eq_iff\n\n"}
{"name":"List.mem_pure","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nx y : α\n⊢ Iff (Membership.mem (Pure.pure y) x) (Eq x y)","decl":"theorem mem_pure (x y : α) : x ∈ (pure y : List α) ↔ x = y := by simp\n\n"}
{"name":"List.bind_eq_flatMap","module":"Mathlib.Data.List.Basic","initialProofState":"α β : Type u_2\nf : α → List β\nl : List α\n⊢ Eq (Bind.bind l f) (l.flatMap f)","decl":"@[simp]\ntheorem bind_eq_flatMap {α β} (f : α → List β) (l : List α) : l >>= f = l.flatMap f :=\n  rfl\n\n"}
{"name":"List.bind_eq_bind","module":"Mathlib.Data.List.Basic","initialProofState":"α β : Type u_2\nf : α → List β\nl : List α\n⊢ Eq (Bind.bind l f) (l.flatMap f)","decl":"@[deprecated (since := \"2024-10-16\")] alias bind_eq_bind := bind_eq_flatMap\n\n"}
{"name":"List.reverse_cons'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\na : α\nl : List α\n⊢ Eq (List.cons a l).reverse (l.reverse.concat a)","decl":"theorem reverse_cons' (a : α) (l : List α) : reverse (a :: l) = concat (reverse l) a := by\n  simp only [reverse_cons, concat_eq_append]\n\n"}
{"name":"List.reverse_concat'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\na : α\n⊢ Eq (HAppend.hAppend l (List.cons a List.nil)).reverse (List.cons a l.reverse)","decl":"theorem reverse_concat' (l : List α) (a : α) : (l ++ [a]).reverse = a :: l.reverse := by\n  rw [reverse_append]; rfl\n\n"}
{"name":"List.reverse_singleton","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\na : α\n⊢ Eq (List.cons a List.nil).reverse (List.cons a List.nil)","decl":"@[simp]\ntheorem reverse_singleton (a : α) : reverse [a] = [a] :=\n  rfl\n\n"}
{"name":"List.reverse_involutive","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\n⊢ Function.Involutive List.reverse","decl":"@[simp]\ntheorem reverse_involutive : Involutive (@reverse α) :=\n  reverse_reverse\n\n"}
{"name":"List.reverse_injective","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\n⊢ Function.Injective List.reverse","decl":"@[simp]\ntheorem reverse_injective : Injective (@reverse α) :=\n  reverse_involutive.injective\n\n"}
{"name":"List.reverse_surjective","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\n⊢ Function.Surjective List.reverse","decl":"theorem reverse_surjective : Surjective (@reverse α) :=\n  reverse_involutive.surjective\n\n"}
{"name":"List.reverse_bijective","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\n⊢ Function.Bijective List.reverse","decl":"theorem reverse_bijective : Bijective (@reverse α) :=\n  reverse_involutive.bijective\n\n"}
{"name":"List.concat_eq_reverse_cons","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\na : α\nl : List α\n⊢ Eq (l.concat a) (List.cons a l.reverse).reverse","decl":"theorem concat_eq_reverse_cons (a : α) (l : List α) : concat l a = reverse (a :: reverse l) := by\n  simp only [concat_eq_append, reverse_cons, reverse_reverse]\n\n"}
{"name":"List.map_reverseAux","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nl₁ l₂ : List α\n⊢ Eq (List.map f (l₁.reverseAux l₂)) ((List.map f l₁).reverseAux (List.map f l₂))","decl":"theorem map_reverseAux (f : α → β) (l₁ l₂ : List α) :\n    map f (reverseAux l₁ l₂) = reverseAux (map f l₁) (map f l₂) := by\n  simp only [reverseAux_eq, map_append, map_reverse]\n\n"}
{"name":"List.getLast_append_singleton","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\na : α\nl : List α\n⊢ Eq ((HAppend.hAppend l (List.cons a List.nil)).getLast ⋯) a","decl":"theorem getLast_append_singleton {a : α} (l : List α) :\n    getLast (l ++ [a]) (append_ne_nil_of_right_ne_nil l (cons_ne_nil a _)) = a := by\n  simp [getLast_append]\n\n-- Porting note: name should be fixed upstream\n"}
{"name":"List.getLast_append'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ : List α\nh : Ne l₂ List.nil\n⊢ Eq ((HAppend.hAppend l₁ l₂).getLast ⋯) (l₂.getLast h)","decl":"theorem getLast_append' (l₁ l₂ : List α) (h : l₂ ≠ []) :\n    getLast (l₁ ++ l₂) (append_ne_nil_of_right_ne_nil l₁ h) = getLast l₂ h := by\n  induction l₁ with\n  | nil => simp\n  | cons _ _ ih => simp only [cons_append]; rw [List.getLast_cons]; exact ih\n\n"}
{"name":"List.getLast_concat'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\na : α\nl : List α\n⊢ Eq ((l.concat a).getLast ⋯) a","decl":"theorem getLast_concat' {a : α} (l : List α) : getLast (concat l a) (by simp) = a := by\n  simp\n\n"}
{"name":"List.getLast_singleton'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\na : α\n⊢ Eq ((List.cons a List.nil).getLast ⋯) a","decl":"@[simp]\ntheorem getLast_singleton' (a : α) : getLast [a] (cons_ne_nil a []) = a := rfl\n\n"}
{"name":"List.getLast_cons_cons","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\na₁ a₂ : α\nl : List α\n⊢ Eq ((List.cons a₁ (List.cons a₂ l)).getLast ⋯) ((List.cons a₂ l).getLast ⋯)","decl":"@[simp]\ntheorem getLast_cons_cons (a₁ a₂ : α) (l : List α) :\n    getLast (a₁ :: a₂ :: l) (cons_ne_nil _ _) = getLast (a₂ :: l) (cons_ne_nil a₂ l) :=\n  rfl\n\n"}
{"name":"List.dropLast_append_getLast","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\nh : Ne l List.nil\n⊢ Eq (HAppend.hAppend l.dropLast (List.cons (l.getLast h) List.nil)) l","decl":"theorem dropLast_append_getLast : ∀ {l : List α} (h : l ≠ []), dropLast l ++ [getLast l h] = l\n  | [], h => absurd rfl h\n  | [_], _ => rfl\n  | a :: b :: l, h => by\n    rw [dropLast_cons₂, cons_append, getLast_cons (cons_ne_nil _ _)]\n    congr\n    exact dropLast_append_getLast (cons_ne_nil b l)\n\n"}
{"name":"List.getLast_congr","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ : List α\nh₁ : Ne l₁ List.nil\nh₂ : Ne l₂ List.nil\nh₃ : Eq l₁ l₂\n⊢ Eq (l₁.getLast h₁) (l₂.getLast h₂)","decl":"theorem getLast_congr {l₁ l₂ : List α} (h₁ : l₁ ≠ []) (h₂ : l₂ ≠ []) (h₃ : l₁ = l₂) :\n    getLast l₁ h₁ = getLast l₂ h₂ := by subst l₁; rfl\n\n"}
{"name":"List.getLast_replicate_succ","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nm : Nat\na : α\n⊢ Eq ((List.replicate (HAdd.hAdd m 1) a).getLast ⋯) a","decl":"theorem getLast_replicate_succ (m : ℕ) (a : α) :\n    (replicate (m + 1) a).getLast (ne_nil_of_length_eq_add_one (length_replicate _ _)) = a := by\n  simp only [replicate_succ']\n  exact getLast_append_singleton _\n\n"}
{"name":"List.getLast_filter'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nl : List α\nhlp : Ne (List.filter p l) List.nil\na✝ : Eq (p (l.getLast ⋯)) Bool.true\n⊢ Eq ((List.filter p l).getLast hlp) (l.getLast ⋯)","decl":"/-- If the last element of `l` does not satisfy `p`, then it is also the last element of\n`l.filter p`. -/\nlemma getLast_filter' {p : α → Bool} :\n    ∀ (l : List α) (hlp : l.filter p ≠ []), p (l.getLast (hlp <| ·.symm ▸ rfl)) = true →\n      (l.filter p).getLast hlp = l.getLast (hlp <| ·.symm ▸ rfl)\n  | [a], h, h' => by simp\n  | a :: b :: as, h, h' => by\n    rw [List.getLast_cons_cons] at h' ⊢\n    simp only [List.filter_cons (x := a)] at h ⊢\n    obtain ha | ha := Bool.eq_false_or_eq_true (p a)\n    · simp only [ha, ite_true]\n      rw [getLast_cons, getLast_filter' (b :: as) _ h']\n      exact ne_nil_of_mem <| mem_filter.2 ⟨getLast_mem _, h'⟩\n    · simp only [ha, cond_false] at h ⊢\n      exact getLast_filter' (b :: as) h h'\n\n"}
{"name":"List.getLast?_eq_none","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u_1\nxs : List α\n⊢ Iff (Eq xs.getLast? Option.none) (Eq xs List.nil)","decl":"@[deprecated (since := \"2024-09-06\")] alias getLast?_eq_none := getLast?_eq_none_iff\n\n"}
{"name":"List.mem_getLast?_eq_getLast","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\nx : α\na✝ : Membership.mem l.getLast? x\n⊢ Exists fun h => Eq x (l.getLast h)","decl":"theorem mem_getLast?_eq_getLast : ∀ {l : List α} {x : α}, x ∈ l.getLast? → ∃ h, x = getLast l h\n  | [], x, hx => False.elim <| by simp at hx\n  | [a], x, hx =>\n    have : a = x := by simpa using hx\n    this ▸ ⟨cons_ne_nil a [], rfl⟩\n  | a :: b :: l, x, hx => by\n    rw [getLast?_cons_cons] at hx\n    rcases mem_getLast?_eq_getLast hx with ⟨_, h₂⟩\n    use cons_ne_nil _ _\n    assumption\n\n"}
{"name":"List.getLast?_eq_getLast_of_ne_nil","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\nh : Ne l List.nil\n⊢ Eq l.getLast? (Option.some (l.getLast h))","decl":"theorem getLast?_eq_getLast_of_ne_nil : ∀ {l : List α} (h : l ≠ []), l.getLast? = some (l.getLast h)\n  | [], h => (h rfl).elim\n  | [_], _ => rfl\n  | _ :: b :: l, _ => @getLast?_eq_getLast_of_ne_nil (b :: l) (cons_ne_nil _ _)\n\n"}
{"name":"List.mem_getLast?_cons","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nx y : α\nl : List α\na✝ : Membership.mem l.getLast? x\n⊢ Membership.mem (List.cons y l).getLast? x","decl":"theorem mem_getLast?_cons {x y : α} : ∀ {l : List α}, x ∈ l.getLast? → x ∈ (y :: l).getLast?\n  | [], _ => by contradiction\n  | _ :: _, h => h\n\n"}
{"name":"List.dropLast_append_getLast?","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\na : α\na✝ : Membership.mem l.getLast? a\n⊢ Eq (HAppend.hAppend l.dropLast (List.cons a List.nil)) l","decl":"theorem dropLast_append_getLast? : ∀ {l : List α}, ∀ a ∈ l.getLast?, dropLast l ++ [a] = l\n  | [], a, ha => (Option.not_mem_none a ha).elim\n  | [a], _, rfl => rfl\n  | a :: b :: l, c, hc => by\n    rw [getLast?_cons_cons] at hc\n    rw [dropLast_cons₂, cons_append, dropLast_append_getLast? _ hc]\n\n"}
{"name":"List.getLastI_eq_getLast?","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : Inhabited α\nl : List α\n⊢ Eq l.getLastI l.getLast?.iget","decl":"theorem getLastI_eq_getLast? [Inhabited α] : ∀ l : List α, l.getLastI = l.getLast?.iget\n  | [] => by simp [getLastI, Inhabited.default]\n  | [_] => rfl\n  | [_, _] => rfl\n  | [_, _, _] => rfl\n  | _ :: _ :: c :: l => by simp [getLastI, getLastI_eq_getLast? (c :: l)]\n\n"}
{"name":"List.getLast?_append_cons","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ : List α\na : α\nl₂ : List α\n⊢ Eq (HAppend.hAppend l₁ (List.cons a l₂)).getLast? (List.cons a l₂).getLast?","decl":"theorem getLast?_append_cons :\n    ∀ (l₁ : List α) (a : α) (l₂ : List α), getLast? (l₁ ++ a :: l₂) = getLast? (a :: l₂)\n  | [], _, _ => rfl\n  | [_], _, _ => rfl\n  | b :: c :: l₁, a, l₂ => by rw [cons_append, cons_append, getLast?_cons_cons,\n    ← cons_append, getLast?_append_cons (c :: l₁)]\n\n"}
{"name":"List.getLast?_append_of_ne_nil","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ : List α\nx✝ : Ne l₂ List.nil\n⊢ Eq (HAppend.hAppend l₁ l₂).getLast? l₂.getLast?","decl":"theorem getLast?_append_of_ne_nil (l₁ : List α) :\n    ∀ {l₂ : List α} (_ : l₂ ≠ []), getLast? (l₁ ++ l₂) = getLast? l₂\n  | [], hl₂ => by contradiction\n  | b :: l₂, _ => getLast?_append_cons l₁ b l₂\n\n"}
{"name":"List.mem_getLast?_append_of_mem_getLast?","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ : List α\nx : α\nh : Membership.mem l₂.getLast? x\n⊢ Membership.mem (HAppend.hAppend l₁ l₂).getLast? x","decl":"theorem mem_getLast?_append_of_mem_getLast? {l₁ l₂ : List α} {x : α} (h : x ∈ l₂.getLast?) :\n    x ∈ (l₁ ++ l₂).getLast? := by\n  cases l₂\n  · contradiction\n  · rw [List.getLast?_append_cons]\n    exact h\n\n"}
{"name":"List.head!_nil","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : Inhabited α\n⊢ Eq List.nil.head! Inhabited.default","decl":"@[simp]\ntheorem head!_nil [Inhabited α] : ([] : List α).head! = default := rfl\n\n"}
{"name":"List.head_cons_tail","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nx : List α\nh : Ne x List.nil\n⊢ Eq (List.cons (x.head h) x.tail) x","decl":"@[simp] theorem head_cons_tail (x : List α) (h : x ≠ []) : x.head h :: x.tail = x := by\n  cases x <;> simp at h ⊢\n\n"}
{"name":"List.head_eq_getElem_zero","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\nhl : Ne l List.nil\n⊢ Eq (l.head hl) (GetElem.getElem l 0 ⋯)","decl":"theorem head_eq_getElem_zero {l : List α} (hl : l ≠ []) :\n    l.head hl = l[0]'(length_pos.2 hl) :=\n  (getElem_zero _).symm\n\n"}
{"name":"List.head!_eq_head?","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : Inhabited α\nl : List α\n⊢ Eq l.head! l.head?.iget","decl":"theorem head!_eq_head? [Inhabited α] (l : List α) : head! l = (head? l).iget := by cases l <;> rfl\n\n"}
{"name":"List.surjective_head!","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : Inhabited α\n⊢ Function.Surjective List.head!","decl":"theorem surjective_head! [Inhabited α] : Surjective (@head! α _) := fun x => ⟨[x], rfl⟩\n\n"}
{"name":"List.surjective_head?","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\n⊢ Function.Surjective List.head?","decl":"theorem surjective_head? : Surjective (@head? α) :=\n  Option.forall.2 ⟨⟨[], rfl⟩, fun x => ⟨[x], rfl⟩⟩\n\n"}
{"name":"List.surjective_tail","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\n⊢ Function.Surjective List.tail","decl":"theorem surjective_tail : Surjective (@tail α)\n  | [] => ⟨[], rfl⟩\n  | a :: l => ⟨a :: a :: l, rfl⟩\n\n"}
{"name":"List.eq_cons_of_mem_head?","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nx : α\nl : List α\na✝ : Membership.mem l.head? x\n⊢ Eq l (List.cons x l.tail)","decl":"theorem eq_cons_of_mem_head? {x : α} : ∀ {l : List α}, x ∈ l.head? → l = x :: tail l\n  | [], h => (Option.not_mem_none _ h).elim\n  | a :: l, h => by\n    simp only [head?, Option.mem_def, Option.some_inj] at h\n    exact h ▸ rfl\n\n"}
{"name":"List.head!_cons","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : Inhabited α\na : α\nl : List α\n⊢ Eq (List.cons a l).head! a","decl":"@[simp] theorem head!_cons [Inhabited α] (a : α) (l : List α) : head! (a :: l) = a := rfl\n\n"}
{"name":"List.head!_append","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : Inhabited α\nt s : List α\nh : Ne s List.nil\n⊢ Eq (HAppend.hAppend s t).head! s.head!","decl":"@[simp]\ntheorem head!_append [Inhabited α] (t : List α) {s : List α} (h : s ≠ []) :\n    head! (s ++ t) = head! s := by\n  induction s\n  · contradiction\n  · rfl\n\n"}
{"name":"List.mem_head?_append_of_mem_head?","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ns t : List α\nx : α\nh : Membership.mem s.head? x\n⊢ Membership.mem (HAppend.hAppend s t).head? x","decl":"theorem mem_head?_append_of_mem_head? {s t : List α} {x : α} (h : x ∈ s.head?) :\n    x ∈ (s ++ t).head? := by\n  cases s\n  · contradiction\n  · exact h\n\n"}
{"name":"List.head?_append_of_ne_nil","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ : List α\nx✝ : Ne l₁ List.nil\n⊢ Eq (HAppend.hAppend l₁ l₂).head? l₁.head?","decl":"theorem head?_append_of_ne_nil :\n    ∀ (l₁ : List α) {l₂ : List α} (_ : l₁ ≠ []), head? (l₁ ++ l₂) = head? l₁\n  | _ :: _, _, _ => rfl\n\n"}
{"name":"List.tail_append_singleton_of_ne_nil","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\na : α\nl : List α\nh : Ne l List.nil\n⊢ Eq (HAppend.hAppend l (List.cons a List.nil)).tail (HAppend.hAppend l.tail (List.cons a List.nil))","decl":"theorem tail_append_singleton_of_ne_nil {a : α} {l : List α} (h : l ≠ nil) :\n    tail (l ++ [a]) = tail l ++ [a] := by\n  induction l\n  · contradiction\n  · rw [tail, cons_append, tail]\n\n"}
{"name":"List.cons_head?_tail","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\na : α\na✝ : Membership.mem l.head? a\n⊢ Eq (List.cons a l.tail) l","decl":"theorem cons_head?_tail : ∀ {l : List α} {a : α}, a ∈ head? l → a :: tail l = l\n  | [], a, h => by contradiction\n  | b :: l, a, h => by\n    simp? at h says simp only [head?_cons, Option.mem_def, Option.some.injEq] at h\n    simp [h]\n\n"}
{"name":"List.head!_mem_head?","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : Inhabited α\nl : List α\na✝ : Ne l List.nil\n⊢ Membership.mem l.head? l.head!","decl":"theorem head!_mem_head? [Inhabited α] : ∀ {l : List α}, l ≠ [] → head! l ∈ head? l\n  | [], h => by contradiction\n  | _ :: _, _ => rfl\n\n"}
{"name":"List.cons_head!_tail","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : Inhabited α\nl : List α\nh : Ne l List.nil\n⊢ Eq (List.cons l.head! l.tail) l","decl":"theorem cons_head!_tail [Inhabited α] {l : List α} (h : l ≠ []) : head! l :: tail l = l :=\n  cons_head?_tail (head!_mem_head? h)\n\n"}
{"name":"List.head!_mem_self","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : Inhabited α\nl : List α\nh : Ne l List.nil\n⊢ Membership.mem l l.head!","decl":"theorem head!_mem_self [Inhabited α] {l : List α} (h : l ≠ nil) : l.head! ∈ l := by\n  have h' := mem_cons_self l.head! l.tail\n  rwa [cons_head!_tail h] at h'\n\n"}
{"name":"List.get_eq_get?","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\ni : Fin l.length\n⊢ Eq (l.get i) ((l.get? ↑i).get ⋯)","decl":"theorem get_eq_get? (l : List α) (i : Fin l.length) :\n    l.get i = (l.get? i).get (by simp [getElem?_eq_getElem]) := by\n  simp\n\n"}
{"name":"List.exists_mem_iff_getElem","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\np : α → Prop\n⊢ Iff (Exists fun x => And (Membership.mem l x) (p x)) (Exists fun i => Exists fun x => p (GetElem.getElem l i ⋯))","decl":"theorem exists_mem_iff_getElem {l : List α} {p : α → Prop} :\n    (∃ x ∈ l, p x) ↔ ∃ (i : ℕ) (_ : i < l.length), p l[i] := by\n  simp only [mem_iff_getElem]\n  exact ⟨fun ⟨_x, ⟨i, hi, hix⟩, hxp⟩ ↦ ⟨i, hi, hix ▸ hxp⟩, fun ⟨i, hi, hp⟩ ↦ ⟨_, ⟨i, hi, rfl⟩, hp⟩⟩\n\n"}
{"name":"List.forall_mem_iff_getElem","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\np : α → Prop\n⊢ Iff (∀ (x : α), Membership.mem l x → p x) (∀ (i : Nat), LT.lt i l.length → p (GetElem.getElem l i ⋯))","decl":"theorem forall_mem_iff_getElem {l : List α} {p : α → Prop} :\n    (∀ x ∈ l, p x) ↔ ∀ (i : ℕ) (_ : i < l.length), p l[i] := by\n  simp [mem_iff_getElem, @forall_swap α]\n\n"}
{"name":"List.get_tail","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\ni : Nat\nh : LT.lt i l.tail.length\nh' : optParam (LT.lt (HAdd.hAdd i 1) l.length) ⋯\n⊢ Eq (l.tail.get ⟨i, h⟩) (l.get ⟨HAdd.hAdd i 1, h'⟩)","decl":"theorem get_tail (l : List α) (i) (h : i < l.tail.length)\n    (h' : i + 1 < l.length := (by simp only [length_tail] at h; omega)) :\n    l.tail.get ⟨i, h⟩ = l.get ⟨i + 1, h'⟩ := by\n  cases l <;> [cases h; rfl]\n\n"}
{"name":"List.get_cons","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\na : α\nn : Nat\nhl : LT.lt n (List.cons a l).length\n⊢ Eq ((List.cons a l).get ⟨n, hl⟩) (dite (Eq n 0) (fun hn => a) fun hn => l.get ⟨HSub.hSub n 1, ⋯⟩)","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-08-22\")]\ntheorem get_cons {l : List α} {a : α} {n} (hl) :\n    (a :: l).get ⟨n, hl⟩ = if hn : n = 0 then a else\n      l.get ⟨n - 1, by contrapose! hl; rw [length_cons]; omega⟩ :=\n  getElem_cons hl\n\n"}
{"name":"List.reverseRecOn_nil","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nmotive : List α → Sort u_2\nnil : motive List.nil\nappend_singleton : (l : List α) → (a : α) → motive l → motive (HAppend.hAppend l (List.cons a List.nil))\n⊢ Eq (List.reverseRecOn List.nil nil append_singleton) nil","decl":"@[simp]\ntheorem reverseRecOn_nil {motive : List α → Sort*} (nil : motive [])\n    (append_singleton : ∀ (l : List α) (a : α), motive l → motive (l ++ [a])) :\n    reverseRecOn [] nil append_singleton = nil := reverseRecOn.eq_1 ..\n\n-- `unusedHavesSuffices` is getting confused by the unfolding of `reverseRecOn`\n"}
{"name":"List.reverseRecOn_concat","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nmotive : List α → Sort u_2\nx : α\nxs : List α\nnil : motive List.nil\nappend_singleton : (l : List α) → (a : α) → motive l → motive (HAppend.hAppend l (List.cons a List.nil))\n⊢ Eq (List.reverseRecOn (HAppend.hAppend xs (List.cons x List.nil)) nil append_singleton) (append_singleton xs x (List.reverseRecOn xs nil append_singleton))","decl":"@[simp, nolint unusedHavesSuffices]\ntheorem reverseRecOn_concat {motive : List α → Sort*} (x : α) (xs : List α) (nil : motive [])\n    (append_singleton : ∀ (l : List α) (a : α), motive l → motive (l ++ [a])) :\n    reverseRecOn (motive := motive) (xs ++ [x]) nil append_singleton =\n      append_singleton _ _ (reverseRecOn (motive := motive) xs nil append_singleton) := by\n  suffices ∀ ys (h : reverse (reverse xs) = ys),\n      reverseRecOn (motive := motive) (xs ++ [x]) nil append_singleton =\n        cast (by simp [(reverse_reverse _).symm.trans h])\n          (append_singleton _ x (reverseRecOn (motive := motive) ys nil append_singleton)) by\n    exact this _ (reverse_reverse xs)\n  intros ys hy\n  conv_lhs => unfold reverseRecOn\n  split\n  next h => simp at h\n  next heq =>\n    revert heq\n    simp only [reverse_append, reverse_cons, reverse_nil, nil_append, singleton_append, cons.injEq]\n    rintro ⟨rfl, rfl⟩\n    subst ys\n    rfl\n\n"}
{"name":"List.bidirectionalRec_nil","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nmotive : List α → Sort u_2\nnil : motive List.nil\nsingleton : (a : α) → motive (List.cons a List.nil)\ncons_append : (a : α) → (l : List α) → (b : α) → motive l → motive (List.cons a (HAppend.hAppend l (List.cons b List.nil)))\n⊢ Eq (List.bidirectionalRec nil singleton cons_append List.nil) nil","decl":"@[simp]\ntheorem bidirectionalRec_nil {motive : List α → Sort*}\n    (nil : motive []) (singleton : ∀ a : α, motive [a])\n    (cons_append : ∀ (a : α) (l : List α) (b : α), motive l → motive (a :: (l ++ [b]))) :\n    bidirectionalRec nil singleton cons_append [] = nil := bidirectionalRec.eq_1 ..\n\n\n"}
{"name":"List.bidirectionalRec_singleton","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nmotive : List α → Sort u_2\nnil : motive List.nil\nsingleton : (a : α) → motive (List.cons a List.nil)\ncons_append : (a : α) → (l : List α) → (b : α) → motive l → motive (List.cons a (HAppend.hAppend l (List.cons b List.nil)))\na : α\n⊢ Eq (List.bidirectionalRec nil singleton cons_append (List.cons a List.nil)) (singleton a)","decl":"@[simp]\ntheorem bidirectionalRec_singleton {motive : List α → Sort*}\n    (nil : motive []) (singleton : ∀ a : α, motive [a])\n    (cons_append : ∀ (a : α) (l : List α) (b : α), motive l → motive (a :: (l ++ [b]))) (a : α) :\n    bidirectionalRec nil singleton cons_append [a] = singleton a := by\n  simp [bidirectionalRec]\n\n"}
{"name":"List.bidirectionalRec_cons_append","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nmotive : List α → Sort u_2\nnil : motive List.nil\nsingleton : (a : α) → motive (List.cons a List.nil)\ncons_append : (a : α) → (l : List α) → (b : α) → motive l → motive (List.cons a (HAppend.hAppend l (List.cons b List.nil)))\na : α\nl : List α\nb : α\n⊢ Eq (List.bidirectionalRec nil singleton cons_append (List.cons a (HAppend.hAppend l (List.cons b List.nil)))) (cons_append a l b (List.bidirectionalRec nil singleton cons_append l))","decl":"@[simp]\ntheorem bidirectionalRec_cons_append {motive : List α → Sort*}\n    (nil : motive []) (singleton : ∀ a : α, motive [a])\n    (cons_append : ∀ (a : α) (l : List α) (b : α), motive l → motive (a :: (l ++ [b])))\n    (a : α) (l : List α) (b : α) :\n    bidirectionalRec nil singleton cons_append (a :: (l ++ [b])) =\n      cons_append a l b (bidirectionalRec nil singleton cons_append l) := by\n  conv_lhs => unfold bidirectionalRec\n  cases l with\n  | nil => rfl\n  | cons x xs =>\n  simp only [List.cons_append]\n  dsimp only [← List.cons_append]\n  suffices ∀ (ys init : List α) (hinit : init = ys) (last : α) (hlast : last = b),\n      (cons_append a init last\n        (bidirectionalRec nil singleton cons_append init)) =\n      cast (congr_arg motive <| by simp [hinit, hlast])\n        (cons_append a ys b (bidirectionalRec nil singleton cons_append ys)) by\n    rw [this (x :: xs) _ (by rw [dropLast_append_cons, dropLast_single, append_nil]) _ (by simp)]\n    simp\n  rintro ys init rfl last rfl\n  rfl\n\n"}
{"name":"List.Sublist.cons_cons","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ : List α\na : α\ns : l₁.Sublist l₂\n⊢ (List.cons a l₁).Sublist (List.cons a l₂)","decl":"theorem Sublist.cons_cons {l₁ l₂ : List α} (a : α) (s : l₁ <+ l₂) : a :: l₁ <+ a :: l₂ :=\n  Sublist.cons₂ _ s\n\n"}
{"name":"List.cons_sublist_cons'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ : List α\na b : α\n⊢ Iff ((List.cons a l₁).Sublist (List.cons b l₂)) (Or ((List.cons a l₁).Sublist l₂) (And (Eq a b) (l₁.Sublist l₂)))","decl":"lemma cons_sublist_cons' {a b : α} : a :: l₁ <+ b :: l₂ ↔ a :: l₁ <+ l₂ ∨ a = b ∧ l₁ <+ l₂ := by\n  constructor\n  · rintro (_ | _)\n    · exact Or.inl ‹_›\n    · exact Or.inr ⟨rfl, ‹_›⟩\n  · rintro (h | ⟨rfl, h⟩)\n    · exact h.cons _\n    · rwa [cons_sublist_cons]\n\n"}
{"name":"List.sublist_cons_of_sublist","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ : List α\na : α\nh : l₁.Sublist l₂\n⊢ l₁.Sublist (List.cons a l₂)","decl":"theorem sublist_cons_of_sublist (a : α) (h : l₁ <+ l₂) : l₁ <+ a :: l₂ := h.cons _\n\n-- Porting note: this lemma seems to have been renamed on the occasion of its move to Batteries\n"}
{"name":"List.sublist_nil_iff_eq_nil","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u_1\nl : List α\n⊢ Iff (l.Sublist List.nil) (Eq l List.nil)","decl":"alias sublist_nil_iff_eq_nil := sublist_nil\n\n"}
{"name":"List.sublist_singleton","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\na : α\n⊢ Iff (l.Sublist (List.cons a List.nil)) (Or (Eq l List.nil) (Eq l (List.cons a List.nil)))","decl":"@[simp] lemma sublist_singleton {l : List α} {a : α} : l <+ [a] ↔ l = [] ∨ l = [a] := by\n  constructor <;> rintro (_ | _) <;> aesop\n\n"}
{"name":"List.Sublist.antisymm","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ : List α\ns₁ : l₁.Sublist l₂\ns₂ : l₂.Sublist l₁\n⊢ Eq l₁ l₂","decl":"theorem Sublist.antisymm (s₁ : l₁ <+ l₂) (s₂ : l₂ <+ l₁) : l₁ = l₂ :=\n  s₁.eq_of_length_le s₂.length_le\n\n"}
{"name":"List.Sublist.of_cons_of_ne","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ : List α\na b : α\nh₁ : Ne a b\nh₂ : (List.cons a l₁).Sublist (List.cons b l₂)\n⊢ (List.cons a l₁).Sublist l₂","decl":"/-- If the first element of two lists are different, then a sublist relation can be reduced. -/\ntheorem Sublist.of_cons_of_ne {a b} (h₁ : a ≠ b) (h₂ : a :: l₁ <+ b :: l₂) : a :: l₁ <+ l₂ :=\n  match h₁, h₂ with\n  | _, .cons _ h =>  h\n\n"}
{"name":"List.indexOf_cons_self","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\na : α\nl : List α\n⊢ Eq (List.indexOf a (List.cons a l)) 0","decl":"@[simp]\ntheorem indexOf_cons_self {a : α} {l : List α} : indexOf a (a :: l) = 0 := by\n  rw [indexOf, findIdx_cons, beq_self_eq_true, cond]\n\n-- fun e => if_pos e\n"}
{"name":"List.indexOf_cons_eq","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\na b : α\nl : List α\na✝ : Eq b a\n⊢ Eq (List.indexOf a (List.cons b l)) 0","decl":"theorem indexOf_cons_eq {a b : α} (l : List α) : b = a → indexOf a (b :: l) = 0\n  | e => by rw [← e]; exact indexOf_cons_self\n\n-- fun n => if_neg n\n"}
{"name":"List.indexOf_cons_ne","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\na b : α\nl : List α\na✝ : Ne b a\n⊢ Eq (List.indexOf a (List.cons b l)) (List.indexOf a l).succ","decl":"@[simp]\ntheorem indexOf_cons_ne {a b : α} (l : List α) : b ≠ a → indexOf a (b :: l) = succ (indexOf a l)\n  | h => by simp only [indexOf, findIdx_cons, Bool.cond_eq_ite, beq_iff_eq, h, ite_false]\n\n"}
{"name":"List.indexOf_eq_length_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\na : α\nl : List α\n⊢ Iff (Eq (List.indexOf a l) l.length) (Not (Membership.mem l a))","decl":"theorem indexOf_eq_length_iff {a : α} {l : List α} : indexOf a l = length l ↔ a ∉ l := by\n  induction' l with b l ih\n  · exact iff_of_true rfl (not_mem_nil _)\n  simp only [length, mem_cons, indexOf_cons, eq_comm]\n  rw [cond_eq_if]\n  split_ifs with h <;> simp at h\n  · exact iff_of_false (by rintro ⟨⟩) fun H => H <| Or.inl h.symm\n  · simp only [Ne.symm h, false_or]\n    rw [← ih]\n    exact succ_inj'\n\n"}
{"name":"List.indexOf_eq_length","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\na : α\nl : List α\n⊢ Iff (Eq (List.indexOf a l) l.length) (Not (Membership.mem l a))","decl":"@[deprecated (since := \"2025-01-28\")]\nalias indexOf_eq_length := indexOf_eq_length_iff\n\n"}
{"name":"List.indexOf_of_not_mem","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\nl : List α\na : α\na✝ : Not (Membership.mem l a)\n⊢ Eq (List.indexOf a l) l.length","decl":"@[simp]\ntheorem indexOf_of_not_mem {l : List α} {a : α} : a ∉ l → indexOf a l = length l :=\n  indexOf_eq_length_iff.2\n\n"}
{"name":"List.indexOf_le_length","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\na : α\nl : List α\n⊢ LE.le (List.indexOf a l) l.length","decl":"theorem indexOf_le_length {a : α} {l : List α} : indexOf a l ≤ length l := by\n  induction' l with b l ih; · rfl\n  simp only [length, indexOf_cons, cond_eq_if, beq_iff_eq]\n  by_cases h : b = a\n  · rw [if_pos h]; exact Nat.zero_le _\n  · rw [if_neg h]; exact succ_le_succ ih\n\n"}
{"name":"List.indexOf_lt_length_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\na : α\nl : List α\n⊢ Iff (LT.lt (List.indexOf a l) l.length) (Membership.mem l a)","decl":"theorem indexOf_lt_length_iff {a} {l : List α} : indexOf a l < length l ↔ a ∈ l :=\n  ⟨fun h => Decidable.byContradiction fun al => Nat.ne_of_lt h <| indexOf_eq_length_iff.2 al,\n   fun al => (lt_of_le_of_ne indexOf_le_length) fun h => indexOf_eq_length_iff.1 h al⟩\n\n"}
{"name":"List.indexOf_lt_length","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\na : α\nl : List α\n⊢ Iff (LT.lt (List.indexOf a l) l.length) (Membership.mem l a)","decl":"@[deprecated (since := \"2025-01-22\")] alias indexOf_lt_length := indexOf_lt_length_iff\n\n"}
{"name":"List.indexOf_append_of_mem","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ : List α\ninst✝ : DecidableEq α\na : α\nh : Membership.mem l₁ a\n⊢ Eq (List.indexOf a (HAppend.hAppend l₁ l₂)) (List.indexOf a l₁)","decl":"theorem indexOf_append_of_mem {a : α} (h : a ∈ l₁) : indexOf a (l₁ ++ l₂) = indexOf a l₁ := by\n  induction' l₁ with d₁ t₁ ih\n  · exfalso\n    exact not_mem_nil a h\n  rw [List.cons_append]\n  by_cases hh : d₁ = a\n  · iterate 2 rw [indexOf_cons_eq _ hh]\n  rw [indexOf_cons_ne _ hh, indexOf_cons_ne _ hh, ih (mem_of_ne_of_mem (Ne.symm hh) h)]\n\n"}
{"name":"List.indexOf_append_of_not_mem","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ : List α\ninst✝ : DecidableEq α\na : α\nh : Not (Membership.mem l₁ a)\n⊢ Eq (List.indexOf a (HAppend.hAppend l₁ l₂)) (HAdd.hAdd l₁.length (List.indexOf a l₂))","decl":"theorem indexOf_append_of_not_mem {a : α} (h : a ∉ l₁) :\n    indexOf a (l₁ ++ l₂) = l₁.length + indexOf a l₂ := by\n  induction' l₁ with d₁ t₁ ih\n  · rw [List.nil_append, List.length, Nat.zero_add]\n  rw [List.cons_append, indexOf_cons_ne _ (ne_of_not_mem_cons h).symm, List.length,\n    ih (not_mem_of_not_mem_cons h), Nat.succ_add]\n\n"}
{"name":"List.getElem?_length","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\n⊢ Eq (GetElem?.getElem? l l.length) Option.none","decl":"@[simp]\ntheorem getElem?_length (l : List α) : l[l.length]? = none := getElem?_eq_none le_rfl\n\n"}
{"name":"List.getElem_map_rev","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nl : List α\nn : Nat\nh : LT.lt n l.length\n⊢ Eq (f (GetElem.getElem l n ⋯)) (GetElem.getElem (List.map f l) n ⋯)","decl":"/-- A version of `getElem_map` that can be used for rewriting. -/\ntheorem getElem_map_rev (f : α → β) {l} {n : Nat} {h : n < l.length} :\n    f l[n] = (map f l)[n]'((l.length_map f).symm ▸ h) := Eq.symm (getElem_map _)\n\n"}
{"name":"List.get_length_sub_one","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\nh : LT.lt (HSub.hSub l.length 1) l.length\n⊢ Eq (l.get ⟨HSub.hSub l.length 1, h⟩) (l.getLast ⋯)","decl":"theorem get_length_sub_one {l : List α} (h : l.length - 1 < l.length) :\n    l.get ⟨l.length - 1, h⟩ = l.getLast (by rintro rfl; exact Nat.lt_irrefl 0 h) :=\n  (getLast_eq_getElem l _).symm\n\n"}
{"name":"List.take_one_drop_eq_of_lt_length","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\nn : Nat\nh : LT.lt n l.length\n⊢ Eq (List.take 1 (List.drop n l)) (List.cons (l.get ⟨n, h⟩) List.nil)","decl":"theorem take_one_drop_eq_of_lt_length {l : List α} {n : ℕ} (h : n < l.length) :\n    (l.drop n).take 1 = [l.get ⟨n, h⟩] := by\n  rw [drop_eq_getElem_cons h, take, take]\n  simp\n\n"}
{"name":"List.ext_get?'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ : List α\nh' : ∀ (n : Nat), LT.lt n (Max.max l₁.length l₂.length) → Eq (l₁.get? n) (l₂.get? n)\n⊢ Eq l₁ l₂","decl":"theorem ext_get?' {l₁ l₂ : List α} (h' : ∀ n < max l₁.length l₂.length, l₁.get? n = l₂.get? n) :\n    l₁ = l₂ := by\n  apply ext_get?\n  intro n\n  rcases Nat.lt_or_ge n <| max l₁.length l₂.length with hn | hn\n  · exact h' n hn\n  · simp_all [Nat.max_le, getElem?_eq_none]\n\n"}
{"name":"List.ext_get?_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ : List α\n⊢ Iff (Eq l₁ l₂) (∀ (n : Nat), Eq (l₁.get? n) (l₂.get? n))","decl":"theorem ext_get?_iff {l₁ l₂ : List α} : l₁ = l₂ ↔ ∀ n, l₁.get? n = l₂.get? n :=\n  ⟨by rintro rfl _; rfl, ext_get?⟩\n\n"}
{"name":"List.ext_get_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ : List α\n⊢ Iff (Eq l₁ l₂) (And (Eq l₁.length l₂.length) (∀ (n : Nat) (h₁ : LT.lt n l₁.length) (h₂ : LT.lt n l₂.length), Eq (l₁.get ⟨n, h₁⟩) (l₂.get ⟨n, h₂⟩)))","decl":"theorem ext_get_iff {l₁ l₂ : List α} :\n    l₁ = l₂ ↔ l₁.length = l₂.length ∧ ∀ n h₁ h₂, get l₁ ⟨n, h₁⟩ = get l₂ ⟨n, h₂⟩ := by\n  constructor\n  · rintro rfl\n    exact ⟨rfl, fun _ _ _ ↦ rfl⟩\n  · intro ⟨h₁, h₂⟩\n    exact ext_get h₁ h₂\n\n"}
{"name":"List.ext_get?_iff'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ : List α\n⊢ Iff (Eq l₁ l₂) (∀ (n : Nat), LT.lt n (Max.max l₁.length l₂.length) → Eq (l₁.get? n) (l₂.get? n))","decl":"theorem ext_get?_iff' {l₁ l₂ : List α} : l₁ = l₂ ↔\n    ∀ n < max l₁.length l₂.length, l₁.get? n = l₂.get? n :=\n  ⟨by rintro rfl _ _; rfl, ext_get?'⟩\n\n"}
{"name":"List.ext_getElem!","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ : List α\ninst✝ : Inhabited α\nhl : Eq l₁.length l₂.length\nh : ∀ (n : Nat), Eq (GetElem?.getElem! l₁ n) (GetElem?.getElem! l₂ n)\n⊢ Eq l₁ l₂","decl":"/-- If two lists `l₁` and `l₂` are the same length and `l₁[n]! = l₂[n]!` for all `n`,\nthen the lists are equal. -/\ntheorem ext_getElem! [Inhabited α] (hl : length l₁ = length l₂) (h : ∀ n : ℕ, l₁[n]! = l₂[n]!) :\n    l₁ = l₂ :=\n  ext_getElem hl fun n h₁ h₂ ↦ by simpa only [← getElem!_pos] using h n\n\n"}
{"name":"List.getElem_indexOf","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\na : α\nl : List α\nh : LT.lt (List.indexOf a l) l.length\n⊢ Eq (GetElem.getElem l (List.indexOf a l) ⋯) a","decl":"@[simp]\ntheorem getElem_indexOf [DecidableEq α] {a : α} : ∀ {l : List α} (h : indexOf a l < l.length),\n    l[indexOf a l] = a\n  | b :: l, h => by\n    by_cases h' : b = a <;>\n    simp [h', if_pos, if_false, getElem_indexOf]\n\n-- This is incorrectly named and should be `get_indexOf`;\n-- this already exists, so will require a deprecation dance.\n"}
{"name":"List.indexOf_get","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\na : α\nl : List α\nh : LT.lt (List.indexOf a l) l.length\n⊢ Eq (l.get ⟨List.indexOf a l, h⟩) a","decl":"theorem indexOf_get [DecidableEq α] {a : α} {l : List α} (h) : get l ⟨indexOf a l, h⟩ = a := by\n  simp\n\n"}
{"name":"List.getElem?_indexOf","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\na : α\nl : List α\nh : Membership.mem l a\n⊢ Eq (GetElem?.getElem? l (List.indexOf a l)) (Option.some a)","decl":"@[simp]\ntheorem getElem?_indexOf [DecidableEq α] {a : α} {l : List α} (h : a ∈ l) :\n    l[indexOf a l]? = some a := by\n  rw [getElem?_eq_getElem, getElem_indexOf (indexOf_lt_length_iff.2 h)]\n\n-- This is incorrectly named and should be `get?_indexOf`;\n-- this already exists, so will require a deprecation dance.\n"}
{"name":"List.indexOf_get?","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\na : α\nl : List α\nh : Membership.mem l a\n⊢ Eq (l.get? (List.indexOf a l)) (Option.some a)","decl":"theorem indexOf_get? [DecidableEq α] {a : α} {l : List α} (h : a ∈ l) :\n    get? l (indexOf a l) = some a := by simp [h]\n\n"}
{"name":"List.indexOf_inj","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\nl : List α\nx y : α\nhx : Membership.mem l x\nhy : Membership.mem l y\n⊢ Iff (Eq (List.indexOf x l) (List.indexOf y l)) (Eq x y)","decl":"theorem indexOf_inj [DecidableEq α] {l : List α} {x y : α} (hx : x ∈ l) (hy : y ∈ l) :\n    indexOf x l = indexOf y l ↔ x = y :=\n  ⟨fun h => by\n    have x_eq_y :\n        get l ⟨indexOf x l, indexOf_lt_length_iff.2 hx⟩ =\n        get l ⟨indexOf y l, indexOf_lt_length_iff.2 hy⟩ := by\n      simp only [h]\n    simp only [indexOf_get] at x_eq_y; exact x_eq_y, fun h => by subst h; rfl⟩\n\n"}
{"name":"List.get_reverse'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\nn : Fin l.reverse.length\nhn' : LT.lt (HSub.hSub (HSub.hSub l.length 1) ↑n) l.length\n⊢ Eq (l.reverse.get n) (l.get ⟨HSub.hSub (HSub.hSub l.length 1) ↑n, hn'⟩)","decl":"theorem get_reverse' (l : List α) (n) (hn') :\n    l.reverse.get n = l.get ⟨l.length - 1 - n, hn'⟩ := by\n  simp\n\n"}
{"name":"List.eq_cons_of_length_one","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\nh : Eq l.length 1\n⊢ Eq l (List.cons (l.get ⟨0, ⋯⟩) List.nil)","decl":"theorem eq_cons_of_length_one {l : List α} (h : l.length = 1) : l = [l.get ⟨0, by omega⟩] := by\n  refine ext_get (by convert h) fun n h₁ h₂ => ?_\n  simp\n  congr\n  omega\n\n"}
{"name":"List.modifyNthTail_modifyNthTail_le","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u_1\nf g : List α → List α\nm n : Nat\nl : List α\nh : LE.le n m\n⊢ Eq (List.modifyTailIdx g m (List.modifyTailIdx f n l)) (List.modifyTailIdx (fun l => List.modifyTailIdx g (HSub.hSub m n) (f l)) n l)","decl":"@[deprecated (since := \"2024-10-21\")]\nalias modifyNthTail_modifyNthTail_le := modifyTailIdx_modifyTailIdx_le\n\n"}
{"name":"List.modifyNthTail_modifyNthTail_same","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u_1\nf g : List α → List α\nn : Nat\nl : List α\n⊢ Eq (List.modifyTailIdx g n (List.modifyTailIdx f n l)) (List.modifyTailIdx (Function.comp g f) n l)","decl":"@[deprecated (since := \"2024-10-21\")]\nalias modifyNthTail_modifyNthTail_same := modifyTailIdx_modifyTailIdx_self\n"}
{"name":"List.modifyNth_eq_set","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u_1\ninst✝ : Inhabited α\nf : α → α\nn : Nat\nl : List α\n⊢ Eq (List.modify f n l) (l.set n (f ((GetElem?.getElem? l n).getD Inhabited.default)))","decl":"@[deprecated (since := \"2024-10-21\")] alias modifyNth_eq_set := modify_eq_set\n\n"}
{"name":"List.getElem_set_of_ne","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\ni j : Nat\nh : Ne i j\na : α\nhj : LT.lt j (l.set i a).length\n⊢ Eq (GetElem.getElem (l.set i a) j ⋯) (GetElem.getElem l j ⋯)","decl":"@[simp]\ntheorem getElem_set_of_ne {l : List α} {i j : ℕ} (h : i ≠ j) (a : α)\n    (hj : j < (l.set i a).length) :\n    (l.set i a)[j] = l[j]'(by simpa using hj) := by\n  rw [← Option.some_inj, ← List.getElem?_eq_getElem, List.getElem?_set_ne h,\n    List.getElem?_eq_getElem]\n\n"}
{"name":"List.flatMap_pure_eq_map","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nl : List α\n⊢ Eq (l.flatMap (Function.comp Pure.pure f)) (List.map f l)","decl":"theorem flatMap_pure_eq_map (f : α → β) (l : List α) : l.flatMap (pure ∘ f) = map f l :=\n  .symm <| map_eq_flatMap ..\n\n"}
{"name":"List.bind_pure_eq_map","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nl : List α\n⊢ Eq (l.flatMap (Function.comp Pure.pure f)) (List.map f l)","decl":"@[deprecated (since := \"2024-10-16\")] alias bind_pure_eq_map := flatMap_pure_eq_map\n\n"}
{"name":"List.flatMap_congr","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nl : List α\nf g : α → List β\nh : ∀ (x : α), Membership.mem l x → Eq (f x) (g x)\n⊢ Eq (l.flatMap f) (l.flatMap g)","decl":"theorem flatMap_congr {l : List α} {f g : α → List β} (h : ∀ x ∈ l, f x = g x) :\n    l.flatMap f = l.flatMap g :=\n  (congr_arg List.flatten <| map_congr_left h :)\n\n"}
{"name":"List.bind_congr","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nl : List α\nf g : α → List β\nh : ∀ (x : α), Membership.mem l x → Eq (f x) (g x)\n⊢ Eq (l.flatMap f) (l.flatMap g)","decl":"@[deprecated (since := \"2024-10-16\")] alias bind_congr := flatMap_congr\n\n"}
{"name":"List.infix_flatMap_of_mem","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\na : α\nas : List α\nh : Membership.mem as a\nf : α → List α\n⊢ (f a).IsInfix (as.flatMap f)","decl":"theorem infix_flatMap_of_mem {a : α} {as : List α} (h : a ∈ as) (f : α → List α) :\n    f a <:+: as.flatMap f :=\n  List.infix_of_mem_flatten (List.mem_map_of_mem f h)\n\n"}
{"name":"List.infix_bind_of_mem","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\na : α\nas : List α\nh : Membership.mem as a\nf : α → List α\n⊢ (f a).IsInfix (as.flatMap f)","decl":"@[deprecated (since := \"2024-10-16\")] alias infix_bind_of_mem := infix_flatMap_of_mem\n\n"}
{"name":"List.map_eq_map","module":"Mathlib.Data.List.Basic","initialProofState":"α β : Type u_2\nf : α → β\nl : List α\n⊢ Eq (Functor.map f l) (List.map f l)","decl":"@[simp]\ntheorem map_eq_map {α β} (f : α → β) (l : List α) : f <$> l = map f l :=\n  rfl\n\n"}
{"name":"List.comp_map","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nh : β → γ\ng : α → β\nl : List α\n⊢ Eq (List.map (Function.comp h g) l) (List.map h (List.map g l))","decl":"/-- A single `List.map` of a composition of functions is equal to\ncomposing a `List.map` with another `List.map`, fully applied.\nThis is the reverse direction of `List.map_map`.\n-/\ntheorem comp_map (h : β → γ) (g : α → β) (l : List α) : map (h ∘ g) l = map h (map g l) :=\n  (map_map _ _ _).symm\n\n"}
{"name":"List.map_comp_map","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ng : β → γ\nf : α → β\n⊢ Eq (Function.comp (List.map g) (List.map f)) (List.map (Function.comp g f))","decl":"/-- Composing a `List.map` with another `List.map` is equal to\na single `List.map` of composed functions.\n-/\n@[simp]\ntheorem map_comp_map (g : β → γ) (f : α → β) : map g ∘ map f = map (g ∘ f) := by\n  ext l; rw [comp_map, Function.comp_apply]\n\n"}
{"name":"Function.LeftInverse.list_map","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ng : β → α\nh : Function.LeftInverse f g\n⊢ Function.LeftInverse (List.map f) (List.map g)","decl":"theorem _root_.Function.LeftInverse.list_map {f : α → β} {g : β → α} (h : LeftInverse f g) :\n    LeftInverse (map f) (map g)\n  | [] => by simp_rw [map_nil]\n  | x :: xs => by simp_rw [map_cons, h x, h.list_map xs]\n\n"}
{"name":"Function.RightInverse.list_map","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ng : β → α\nh : Function.RightInverse f g\n⊢ Function.RightInverse (List.map f) (List.map g)","decl":"nonrec theorem _root_.Function.RightInverse.list_map {f : α → β} {g : β → α}\n    (h : RightInverse f g) : RightInverse (map f) (map g) :=\n  h.list_map\n\n"}
{"name":"Function.Involutive.list_map","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nf : α → α\nh : Function.Involutive f\n⊢ Function.Involutive (List.map f)","decl":"nonrec theorem _root_.Function.Involutive.list_map {f : α → α}\n    (h : Involutive f) : Involutive (map f) :=\n  Function.LeftInverse.list_map h\n\n"}
{"name":"List.map_leftInverse_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ng : β → α\n⊢ Iff (Function.LeftInverse (List.map f) (List.map g)) (Function.LeftInverse f g)","decl":"@[simp]\ntheorem map_leftInverse_iff {f : α → β} {g : β → α} :\n    LeftInverse (map f) (map g) ↔ LeftInverse f g :=\n  ⟨fun h x => by injection h [x], (·.list_map)⟩\n\n"}
{"name":"List.map_rightInverse_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ng : β → α\n⊢ Iff (Function.RightInverse (List.map f) (List.map g)) (Function.RightInverse f g)","decl":"@[simp]\ntheorem map_rightInverse_iff {f : α → β} {g : β → α} :\n    RightInverse (map f) (map g) ↔ RightInverse f g := map_leftInverse_iff\n\n"}
{"name":"List.map_involutive_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nf : α → α\n⊢ Iff (Function.Involutive (List.map f)) (Function.Involutive f)","decl":"@[simp]\ntheorem map_involutive_iff {f : α → α} :\n    Involutive (map f) ↔ Involutive f := map_leftInverse_iff\n\n"}
{"name":"Function.Injective.list_map","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nh : Function.Injective f\n⊢ Function.Injective (List.map f)","decl":"theorem _root_.Function.Injective.list_map {f : α → β} (h : Injective f) :\n    Injective (map f)\n  | [], [], _ => rfl\n  | x :: xs, y :: ys, hxy => by\n    injection hxy with hxy hxys\n    rw [h hxy, h.list_map hxys]\n\n"}
{"name":"List.map_injective_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\n⊢ Iff (Function.Injective (List.map f)) (Function.Injective f)","decl":"@[simp]\ntheorem map_injective_iff {f : α → β} : Injective (map f) ↔ Injective f := by\n  refine ⟨fun h x y hxy => ?_, (·.list_map)⟩\n  suffices [x] = [y] by simpa using this\n  apply h\n  simp [hxy]\n\n"}
{"name":"Function.Surjective.list_map","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nh : Function.Surjective f\n⊢ Function.Surjective (List.map f)","decl":"theorem _root_.Function.Surjective.list_map {f : α → β} (h : Surjective f) :\n    Surjective (map f) :=\n  let ⟨_, h⟩ := h.hasRightInverse; h.list_map.surjective\n\n"}
{"name":"List.map_surjective_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\n⊢ Iff (Function.Surjective (List.map f)) (Function.Surjective f)","decl":"@[simp]\ntheorem map_surjective_iff {f : α → β} : Surjective (map f) ↔ Surjective f := by\n  refine ⟨fun h x => ?_, (·.list_map)⟩\n  let ⟨[y], hxy⟩ := h [x]\n  exact ⟨_, List.singleton_injective hxy⟩\n\n"}
{"name":"Function.Bijective.list_map","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nh : Function.Bijective f\n⊢ Function.Bijective (List.map f)","decl":"theorem _root_.Function.Bijective.list_map {f : α → β} (h : Bijective f) : Bijective (map f) :=\n  ⟨h.1.list_map, h.2.list_map⟩\n\n"}
{"name":"List.map_bijective_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\n⊢ Iff (Function.Bijective (List.map f)) (Function.Bijective f)","decl":"@[simp]\ntheorem map_bijective_iff {f : α → β} : Bijective (map f) ↔ Bijective f := by\n  simp_rw [Function.Bijective, map_injective_iff, map_surjective_iff]\n\n"}
{"name":"List.eq_of_mem_map_const","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nb₁ b₂ : β\nl : List α\nh : Membership.mem (List.map (Function.const α b₂) l) b₁\n⊢ Eq b₁ b₂","decl":"theorem eq_of_mem_map_const {b₁ b₂ : β} {l : List α} (h : b₁ ∈ map (const α b₂) l) :\n    b₁ = b₂ := by rw [map_const] at h; exact eq_of_mem_replicate h\n\n"}
{"name":"List.take_eq_self_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nx : List α\nn : Nat\n⊢ Iff (Eq (List.take n x) x) (LE.le x.length n)","decl":"@[simp] lemma take_eq_self_iff (x : List α) {n : ℕ} : x.take n = x ↔ x.length ≤ n :=\n  ⟨fun h ↦ by rw [← h]; simp; omega, take_of_length_le⟩\n\n"}
{"name":"List.take_self_eq_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nx : List α\nn : Nat\n⊢ Iff (Eq x (List.take n x)) (LE.le x.length n)","decl":"@[simp] lemma take_self_eq_iff (x : List α) {n : ℕ} : x = x.take n ↔ x.length ≤ n := by\n  rw [Eq.comm, take_eq_self_iff]\n\n"}
{"name":"List.take_eq_left_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nx y : List α\nn : Nat\n⊢ Iff (Eq (List.take n (HAppend.hAppend x y)) (List.take n x)) (Or (Eq y List.nil) (LE.le n x.length))","decl":"@[simp] lemma take_eq_left_iff {x y : List α} {n : ℕ} :\n    (x ++ y).take n = x.take n ↔ y = [] ∨ n ≤ x.length := by\n  simp [take_append_eq_append_take, Nat.sub_eq_zero_iff_le, Or.comm]\n\n"}
{"name":"List.left_eq_take_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nx y : List α\nn : Nat\n⊢ Iff (Eq (List.take n x) (List.take n (HAppend.hAppend x y))) (Or (Eq y List.nil) (LE.le n x.length))","decl":"@[simp] lemma left_eq_take_iff {x y : List α} {n : ℕ} :\n    x.take n = (x ++ y).take n ↔ y = [] ∨ n ≤ x.length := by\n  rw [Eq.comm]; apply take_eq_left_iff\n\n"}
{"name":"List.drop_take_append_drop","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nx : List α\nm n : Nat\n⊢ Eq (HAppend.hAppend (List.take n (List.drop m x)) (List.drop (HAdd.hAdd m n) x)) (List.drop m x)","decl":"@[simp] lemma drop_take_append_drop (x : List α) (m n : ℕ) :\n    (x.drop m).take n ++ x.drop (m + n) = x.drop m := by rw [← drop_drop, take_append_drop]\n\n"}
{"name":"List.drop_take_append_drop'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nx : List α\nm n : Nat\n⊢ Eq (HAppend.hAppend (List.take n (List.drop m x)) (List.drop (HAdd.hAdd n m) x)) (List.drop m x)","decl":"/-- Compared to `drop_take_append_drop`, the order of summands is swapped. -/\n@[simp] lemma drop_take_append_drop' (x : List α) (m n : ℕ) :\n    (x.drop m).take n ++ x.drop (n + m) = x.drop m := by rw [Nat.add_comm, drop_take_append_drop]\n\n"}
{"name":"List.take_concat_get'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\ni : Nat\nh : LT.lt i l.length\n⊢ Eq (HAppend.hAppend (List.take i l) (List.cons (GetElem.getElem l i ⋯) List.nil)) (List.take (HAdd.hAdd i 1) l)","decl":"/-- `take_concat_get` in simp normal form -/\nlemma take_concat_get' (l : List α) (i : ℕ) (h : i < l.length) :\n  l.take i ++ [l[i]] = l.take (i + 1) := by simp\n\n"}
{"name":"List.eq_nil_or_concat'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\n⊢ Or (Eq l List.nil) (Exists fun L => Exists fun b => Eq l (HAppend.hAppend L (List.cons b List.nil)))","decl":"/-- `eq_nil_or_concat` in simp normal form -/\nlemma eq_nil_or_concat' (l : List α) : l = [] ∨ ∃ L b, l = L ++ [b] := by\n  simpa using l.eq_nil_or_concat\n\n"}
{"name":"List.cons_getElem_drop_succ","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\nn : Nat\nh : LT.lt n l.length\n⊢ Eq (List.cons (GetElem.getElem l n ⋯) (List.drop (HAdd.hAdd n 1) l)) (List.drop n l)","decl":"theorem cons_getElem_drop_succ {l : List α} {n : Nat} {h : n < l.length} :\n    l[n] :: l.drop (n + 1) = l.drop n :=\n  (drop_eq_getElem_cons h).symm\n\n"}
{"name":"List.cons_get_drop_succ","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\nn : Fin l.length\n⊢ Eq (List.cons (l.get n) (List.drop (HAdd.hAdd (↑n) 1) l)) (List.drop (↑n) l)","decl":"theorem cons_get_drop_succ {l : List α} {n} :\n    l.get n :: l.drop (n.1 + 1) = l.drop n.1 :=\n  (drop_eq_getElem_cons n.2).symm\n\n"}
{"name":"List.drop_length_sub_one","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\nh : Ne l List.nil\n⊢ Eq (List.drop (HSub.hSub l.length 1) l) (List.cons (l.getLast h) List.nil)","decl":"lemma drop_length_sub_one {l : List α} (h : l ≠ []) : l.drop (l.length - 1) = [l.getLast h] := by\n  induction l with\n  | nil => aesop\n  | cons a l ih =>\n    by_cases hl : l = []\n    · aesop\n    rw [length_cons, Nat.add_one_sub_one, List.drop_length_cons hl a]\n    aesop\n\n"}
{"name":"List.takeI_length","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : Inhabited α\nn : Nat\nl : List α\n⊢ Eq (List.takeI n l).length n","decl":"@[simp]\ntheorem takeI_length : ∀ n l, length (@takeI α _ n l) = n\n  | 0, _ => rfl\n  | _ + 1, _ => congr_arg succ (takeI_length _ _)\n\n"}
{"name":"List.takeI_nil","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : Inhabited α\nn : Nat\n⊢ Eq (List.takeI n List.nil) (List.replicate n Inhabited.default)","decl":"@[simp]\ntheorem takeI_nil : ∀ n, takeI n (@nil α) = replicate n default\n  | 0 => rfl\n  | _ + 1 => congr_arg (cons _) (takeI_nil _)\n\n"}
{"name":"List.takeI_eq_take","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : Inhabited α\nn : Nat\nl : List α\na✝ : LE.le n l.length\n⊢ Eq (List.takeI n l) (List.take n l)","decl":"theorem takeI_eq_take : ∀ {n} {l : List α}, n ≤ length l → takeI n l = take n l\n  | 0, _, _ => rfl\n  | _ + 1, _ :: _, h => congr_arg (cons _) <| takeI_eq_take <| le_of_succ_le_succ h\n\n"}
{"name":"List.takeI_left","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : Inhabited α\nl₁ l₂ : List α\n⊢ Eq (List.takeI l₁.length (HAppend.hAppend l₁ l₂)) l₁","decl":"@[simp]\ntheorem takeI_left (l₁ l₂ : List α) : takeI (length l₁) (l₁ ++ l₂) = l₁ :=\n  (takeI_eq_take (by simp only [length_append, Nat.le_add_right])).trans (take_left _ _)\n\n"}
{"name":"List.takeI_left'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : Inhabited α\nl₁ l₂ : List α\nn : Nat\nh : Eq l₁.length n\n⊢ Eq (List.takeI n (HAppend.hAppend l₁ l₂)) l₁","decl":"theorem takeI_left' {l₁ l₂ : List α} {n} (h : length l₁ = n) : takeI n (l₁ ++ l₂) = l₁ := by\n  rw [← h]; apply takeI_left\n\n"}
{"name":"List.takeD_length","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nn : Nat\nl : List α\na : α\n⊢ Eq (List.takeD n l a).length n","decl":"@[simp]\ntheorem takeD_length : ∀ n l a, length (@takeD α n l a) = n\n  | 0, _, _ => rfl\n  | _ + 1, _, _ => congr_arg succ (takeD_length _ _ _)\n\n-- `takeD_nil` is already in batteries\n\n"}
{"name":"List.takeD_eq_take","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nn : Nat\nl : List α\na : α\na✝ : LE.le n l.length\n⊢ Eq (List.takeD n l a) (List.take n l)","decl":"theorem takeD_eq_take : ∀ {n} {l : List α} a, n ≤ length l → takeD n l a = take n l\n  | 0, _, _, _ => rfl\n  | _ + 1, _ :: _, a, h => congr_arg (cons _) <| takeD_eq_take a <| le_of_succ_le_succ h\n\n"}
{"name":"List.takeD_left","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ : List α\na : α\n⊢ Eq (List.takeD l₁.length (HAppend.hAppend l₁ l₂) a) l₁","decl":"@[simp]\ntheorem takeD_left (l₁ l₂ : List α) (a : α) : takeD (length l₁) (l₁ ++ l₂) a = l₁ :=\n  (takeD_eq_take a (by simp only [length_append, Nat.le_add_right])).trans (take_left _ _)\n\n"}
{"name":"List.takeD_left'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ : List α\nn : Nat\na : α\nh : Eq l₁.length n\n⊢ Eq (List.takeD n (HAppend.hAppend l₁ l₂) a) l₁","decl":"theorem takeD_left' {l₁ l₂ : List α} {n} {a} (h : length l₁ = n) : takeD n (l₁ ++ l₂) a = l₁ := by\n  rw [← h]; apply takeD_left\n\n"}
{"name":"List.foldl_ext","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf g : α → β → α\na : α\nl : List β\nH : ∀ (a : α) (b : β), Membership.mem l b → Eq (f a b) (g a b)\n⊢ Eq (List.foldl f a l) (List.foldl g a l)","decl":"theorem foldl_ext (f g : α → β → α) (a : α) {l : List β} (H : ∀ a : α, ∀ b ∈ l, f a b = g a b) :\n    foldl f a l = foldl g a l := by\n  induction l generalizing a with\n  | nil => rfl\n  | cons hd tl ih =>\n    unfold foldl\n    rw [ih _ fun a b bin => H a b <| mem_cons_of_mem _ bin, H a hd (mem_cons_self _ _)]\n\n"}
{"name":"List.foldr_ext","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf g : α → β → β\nb : β\nl : List α\nH : ∀ (a : α), Membership.mem l a → ∀ (b : β), Eq (f a b) (g a b)\n⊢ Eq (List.foldr f b l) (List.foldr g b l)","decl":"theorem foldr_ext (f g : α → β → β) (b : β) {l : List α} (H : ∀ a ∈ l, ∀ b : β, f a b = g a b) :\n    foldr f b l = foldr g b l := by\n  induction' l with hd tl ih; · rfl\n  simp only [mem_cons, or_imp, forall_and, forall_eq] at H\n  simp only [foldr, ih H.2, H.1]\n\n"}
{"name":"List.foldl_concat","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : β → α → β\nb : β\nx : α\nxs : List α\n⊢ Eq (List.foldl f b (HAppend.hAppend xs (List.cons x List.nil))) (f (List.foldl f b xs) x)","decl":"theorem foldl_concat\n    (f : β → α → β) (b : β) (x : α) (xs : List α) :\n    List.foldl f b (xs ++ [x]) = f (List.foldl f b xs) x := by\n  simp only [List.foldl_append, List.foldl]\n\n"}
{"name":"List.foldr_concat","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β → β\nb : β\nx : α\nxs : List α\n⊢ Eq (List.foldr f b (HAppend.hAppend xs (List.cons x List.nil))) (List.foldr f (f x b) xs)","decl":"theorem foldr_concat\n    (f : α → β → β) (b : β) (x : α) (xs : List α) :\n    List.foldr f b (xs ++ [x]) = (List.foldr f (f x b) xs) := by\n  simp only [List.foldr_append, List.foldr]\n\n"}
{"name":"List.foldl_fixed'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β → α\na : α\nhf : ∀ (b : β), Eq (f a b) a\nl : List β\n⊢ Eq (List.foldl f a l) a","decl":"theorem foldl_fixed' {f : α → β → α} {a : α} (hf : ∀ b, f a b = a) : ∀ l : List β, foldl f a l = a\n  | [] => rfl\n  | b :: l => by rw [foldl_cons, hf b, foldl_fixed' hf l]\n\n"}
{"name":"List.foldr_fixed'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β → β\nb : β\nhf : ∀ (a : α), Eq (f a b) b\nl : List α\n⊢ Eq (List.foldr f b l) b","decl":"theorem foldr_fixed' {f : α → β → β} {b : β} (hf : ∀ a, f a b = b) : ∀ l : List α, foldr f b l = b\n  | [] => rfl\n  | a :: l => by rw [foldr_cons, foldr_fixed' hf l, hf a]\n\n"}
{"name":"List.foldl_fixed","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\na : α\nl : List β\n⊢ Eq (List.foldl (fun a x => a) a l) a","decl":"@[simp]\ntheorem foldl_fixed {a : α} : ∀ l : List β, foldl (fun a _ => a) a l = a :=\n  foldl_fixed' fun _ => rfl\n\n"}
{"name":"List.foldr_fixed","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nb : β\nl : List α\n⊢ Eq (List.foldr (fun x b => b) b l) b","decl":"@[simp]\ntheorem foldr_fixed {b : β} : ∀ l : List α, foldr (fun _ b => b) b l = b :=\n  foldr_fixed' fun _ => rfl\n\n"}
{"name":"List.foldr_eta","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\n⊢ Eq (List.foldr List.cons List.nil l) l","decl":"theorem foldr_eta : ∀ l : List α, foldr cons [] l = l := by\n  simp only [foldr_cons_eq_append, append_nil, forall_const]\n\n"}
{"name":"List.reverse_foldl","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\n⊢ Eq (List.foldl (fun t h => List.cons h t) List.nil l).reverse l","decl":"theorem reverse_foldl {l : List α} : reverse (foldl (fun t h => h :: t) [] l) = l := by\n  rw [← foldr_reverse]; simp only [foldr_cons_eq_append, append_nil, reverse_reverse]\n\n"}
{"name":"List.foldl_hom₂","module":"Mathlib.Data.List.Basic","initialProofState":"ι : Type u_1\nα : Type u\nβ : Type v\nγ : Type w\nl : List ι\nf : α → β → γ\nop₁ : α → ι → α\nop₂ : β → ι → β\nop₃ : γ → ι → γ\na : α\nb : β\nh : ∀ (a : α) (b : β) (i : ι), Eq (f (op₁ a i) (op₂ b i)) (op₃ (f a b) i)\n⊢ Eq (List.foldl op₃ (f a b) l) (f (List.foldl op₁ a l) (List.foldl op₂ b l))","decl":"theorem foldl_hom₂ (l : List ι) (f : α → β → γ) (op₁ : α → ι → α) (op₂ : β → ι → β)\n    (op₃ : γ → ι → γ) (a : α) (b : β) (h : ∀ a b i, f (op₁ a i) (op₂ b i) = op₃ (f a b) i) :\n    foldl op₃ (f a b) l = f (foldl op₁ a l) (foldl op₂ b l) :=\n  Eq.symm <| by\n    revert a b\n    induction l <;> intros <;> [rfl; simp only [*, foldl]]\n\n"}
{"name":"List.foldr_hom₂","module":"Mathlib.Data.List.Basic","initialProofState":"ι : Type u_1\nα : Type u\nβ : Type v\nγ : Type w\nl : List ι\nf : α → β → γ\nop₁ : ι → α → α\nop₂ : ι → β → β\nop₃ : ι → γ → γ\na : α\nb : β\nh : ∀ (a : α) (b : β) (i : ι), Eq (f (op₁ i a) (op₂ i b)) (op₃ i (f a b))\n⊢ Eq (List.foldr op₃ (f a b) l) (f (List.foldr op₁ a l) (List.foldr op₂ b l))","decl":"theorem foldr_hom₂ (l : List ι) (f : α → β → γ) (op₁ : ι → α → α) (op₂ : ι → β → β)\n    (op₃ : ι → γ → γ) (a : α) (b : β) (h : ∀ a b i, f (op₁ i a) (op₂ i b) = op₃ i (f a b)) :\n    foldr op₃ (f a b) l = f (foldr op₁ a l) (foldr op₂ b l) := by\n  revert a\n  induction l <;> intros <;> [rfl; simp only [*, foldr]]\n\n"}
{"name":"List.injective_foldl_comp","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List (α → α)\nf : α → α\nhl : ∀ (f : α → α), Membership.mem l f → Function.Injective f\nhf : Function.Injective f\n⊢ Function.Injective (List.foldl Function.comp f l)","decl":"theorem injective_foldl_comp {l : List (α → α)} {f : α → α}\n    (hl : ∀ f ∈ l, Function.Injective f) (hf : Function.Injective f) :\n    Function.Injective (@List.foldl (α → α) (α → α) Function.comp f l) := by\n  induction' l with lh lt l_ih generalizing f\n  · exact hf\n  · apply l_ih fun _ h => hl _ (List.mem_cons_of_mem _ h)\n    apply Function.Injective.comp hf\n    apply hl _ (List.mem_cons_self _ _)\n\n"}
{"name":"List.append_cons_inj_of_not_mem","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nx₁ x₂ z₁ z₂ : List α\na₁ a₂ : α\nnotin_x : Not (Membership.mem x₁ a₂)\nnotin_z : Not (Membership.mem z₁ a₂)\n⊢ Iff (Eq (HAppend.hAppend x₁ (List.cons a₁ z₁)) (HAppend.hAppend x₂ (List.cons a₂ z₂))) (And (Eq x₁ x₂) (And (Eq a₁ a₂) (Eq z₁ z₂)))","decl":"/-- Consider two lists `l₁` and `l₂` with designated elements `a₁` and `a₂` somewhere in them:\n`l₁ = x₁ ++ [a₁] ++ z₁` and `l₂ = x₂ ++ [a₂] ++ z₂`.\nAssume the designated element `a₂` is present in neither `x₁` nor `z₁`.\nWe conclude that the lists are equal (`l₁ = l₂`) if and only if their respective parts are equal\n(`x₁ = x₂ ∧ a₁ = a₂ ∧ z₁ = z₂`). -/\nlemma append_cons_inj_of_not_mem {x₁ x₂ z₁ z₂ : List α} {a₁ a₂ : α}\n    (notin_x : a₂ ∉ x₁) (notin_z : a₂ ∉ z₁) :\n    x₁ ++ a₁ :: z₁ = x₂ ++ a₂ :: z₂ ↔ x₁ = x₂ ∧ a₁ = a₂ ∧ z₁ = z₂ := by\n  constructor\n  · simp only [append_eq_append_iff, cons_eq_append_iff, cons_eq_cons]\n    rintro (⟨c, rfl, ⟨rfl, rfl, rfl⟩ | ⟨d, rfl, rfl⟩⟩ |\n      ⟨c, rfl, ⟨rfl, rfl, rfl⟩ | ⟨d, rfl, rfl⟩⟩) <;> simp_all\n  · rintro ⟨rfl, rfl, rfl⟩\n    rfl\n\n"}
{"name":"List.length_scanl","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : β → α → β\na : β\nl : List α\n⊢ Eq (List.scanl f a l).length (HAdd.hAdd l.length 1)","decl":"theorem length_scanl : ∀ a l, length (scanl f a l) = l.length + 1\n  | _, [] => rfl\n  | a, x :: l => by\n    rw [scanl, length_cons, length_cons, ← succ_eq_add_one, congr_arg succ]\n    exact length_scanl _ _\n\n"}
{"name":"List.scanl_nil","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : β → α → β\nb : β\n⊢ Eq (List.scanl f b List.nil) (List.cons b List.nil)","decl":"@[simp]\ntheorem scanl_nil (b : β) : scanl f b nil = [b] :=\n  rfl\n\n"}
{"name":"List.scanl_cons","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : β → α → β\nb : β\na : α\nl : List α\n⊢ Eq (List.scanl f b (List.cons a l)) (HAppend.hAppend (List.cons b List.nil) (List.scanl f (f b a) l))","decl":"@[simp]\ntheorem scanl_cons : scanl f b (a :: l) = [b] ++ scanl f (f b a) l := by\n  simp only [scanl, eq_self_iff_true, singleton_append, and_self_iff]\n\n"}
{"name":"List.getElem?_scanl_zero","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : β → α → β\nb : β\nl : List α\n⊢ Eq (GetElem?.getElem? (List.scanl f b l) 0) (Option.some b)","decl":"@[simp]\ntheorem getElem?_scanl_zero : (scanl f b l)[0]? = some b := by\n  cases l\n  · simp [scanl_nil]\n  · simp [scanl_cons, singleton_append]\n\n"}
{"name":"List.getElem_scanl_zero","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : β → α → β\nb : β\nl : List α\nh : LT.lt 0 (List.scanl f b l).length\n⊢ Eq (GetElem.getElem (List.scanl f b l) 0 ⋯) b","decl":"@[simp]\ntheorem getElem_scanl_zero {h : 0 < (scanl f b l).length} : (scanl f b l)[0] = b := by\n  cases l\n  · simp [scanl_nil]\n  · simp [scanl_cons, singleton_append]\n\n"}
{"name":"List.get?_succ_scanl","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : β → α → β\nb : β\nl : List α\ni : Nat\n⊢ Eq ((List.scanl f b l).get? (HAdd.hAdd i 1)) (((List.scanl f b l).get? i).bind fun x => Option.map (fun y => f x y) (l.get? i))","decl":"theorem get?_succ_scanl {i : ℕ} : (scanl f b l).get? (i + 1) =\n    ((scanl f b l).get? i).bind fun x => (l.get? i).map fun y => f x y := by\n  induction' l with hd tl hl generalizing b i\n  · symm\n    simp only [Option.bind_eq_none', get?, forall₂_true_iff, not_false_iff, Option.map_none',\n      scanl_nil, Option.not_mem_none, forall_true_iff]\n  · simp only [scanl_cons, singleton_append]\n    cases i\n    · simp\n    · simp only [hl, get?]\n\n"}
{"name":"List.getElem_succ_scanl","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : β → α → β\nb : β\nl : List α\ni : Nat\nh : LT.lt (HAdd.hAdd i 1) (List.scanl f b l).length\n⊢ Eq (GetElem.getElem (List.scanl f b l) (HAdd.hAdd i 1) ⋯) (f (GetElem.getElem (List.scanl f b l) i ⋯) (GetElem.getElem l i ⋯))","decl":"theorem getElem_succ_scanl {i : ℕ} (h : i + 1 < (scanl f b l).length) :\n    (scanl f b l)[i + 1] =\n      f ((scanl f b l)[i]'(Nat.lt_of_succ_lt h))\n        (l[i]'(Nat.lt_of_succ_lt_succ (h.trans_eq (length_scanl b l)))) := by\n  induction i generalizing b l with\n  | zero =>\n    cases l\n    · simp only [scanl, length, zero_eq, lt_self_iff_false] at h\n    · simp\n  | succ i hi =>\n    cases l\n    · simp only [scanl, length] at h\n      exact absurd h (by omega)\n    · simp_rw [scanl_cons]\n      rw [getElem_append_right]\n      · simp only [length, Nat.zero_add 1, succ_add_sub_one, hi]; rfl\n      · simp only [length_singleton]; omega\n\n"}
{"name":"List.get_succ_scanl","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : β → α → β\nb : β\nl : List α\ni : Nat\nh : LT.lt (HAdd.hAdd i 1) (List.scanl f b l).length\n⊢ Eq ((List.scanl f b l).get ⟨HAdd.hAdd i 1, h⟩) (f ((List.scanl f b l).get ⟨i, ⋯⟩) (l.get ⟨i, ⋯⟩))","decl":"@[deprecated getElem_succ_scanl (since := \"2024-08-22\")]\ntheorem get_succ_scanl {i : ℕ} {h : i + 1 < (scanl f b l).length} :\n    (scanl f b l).get ⟨i + 1, h⟩ =\n      f ((scanl f b l).get ⟨i, Nat.lt_of_succ_lt h⟩)\n        (l.get ⟨i, Nat.lt_of_succ_lt_succ (lt_of_lt_of_le h (le_of_eq (length_scanl b l)))⟩) :=\n  getElem_succ_scanl h\n\n"}
{"name":"List.scanr_nil","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β → β\nb : β\n⊢ Eq (List.scanr f b List.nil) (List.cons b List.nil)","decl":"@[simp]\ntheorem scanr_nil (f : α → β → β) (b : β) : scanr f b [] = [b] :=\n  rfl\n\n"}
{"name":"List.scanr_cons","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β → β\nb : β\na : α\nl : List α\n⊢ Eq (List.scanr f b (List.cons a l)) (List.cons (List.foldr f b (List.cons a l)) (List.scanr f b l))","decl":"@[simp]\ntheorem scanr_cons (f : α → β → β) (b : β) (a : α) (l : List α) :\n    scanr f b (a :: l) = foldr f b (a :: l) :: scanr f b l := by\n  simp only [scanr, foldr, cons.injEq, and_true]\n  induction l generalizing a with\n  | nil => rfl\n  | cons hd tl ih => simp only [foldr, ih]\n\n"}
{"name":"List.foldl1_eq_foldr1","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nf : α → α → α\nhassoc : Std.Associative f\na b : α\nl : List α\n⊢ Eq (List.foldl f a (HAppend.hAppend l (List.cons b List.nil))) (List.foldr f b (List.cons a l))","decl":"theorem foldl1_eq_foldr1 [hassoc : Std.Associative f] :\n    ∀ a b l, foldl f a (l ++ [b]) = foldr f b (a :: l)\n  | _, _, nil => rfl\n  | a, b, c :: l => by\n    simp only [cons_append, foldl_cons, foldr_cons, foldl1_eq_foldr1 _ _ l]\n    rw [hassoc.assoc]\n\n"}
{"name":"List.foldl_eq_of_comm_of_assoc","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nf : α → α → α\nhcomm : Std.Commutative f\nhassoc : Std.Associative f\na b : α\nl : List α\n⊢ Eq (List.foldl f a (List.cons b l)) (f b (List.foldl f a l))","decl":"theorem foldl_eq_of_comm_of_assoc [hcomm : Std.Commutative f] [hassoc : Std.Associative f] :\n    ∀ a b l, foldl f a (b :: l) = f b (foldl f a l)\n  | a, b, nil => hcomm.comm a b\n  | a, b, c :: l => by\n    simp only [foldl_cons]\n    have : RightCommutative f := inferInstance\n    rw [← foldl_eq_of_comm_of_assoc .., this.right_comm, foldl_cons]\n\n"}
{"name":"List.foldl_eq_foldr","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nf : α → α → α\ninst✝¹ : Std.Commutative f\ninst✝ : Std.Associative f\na : α\nl : List α\n⊢ Eq (List.foldl f a l) (List.foldr f a l)","decl":"theorem foldl_eq_foldr [Std.Commutative f] [Std.Associative f] :\n    ∀ a l, foldl f a l = foldr f a l\n  | _, nil => rfl\n  | a, b :: l => by\n    simp only [foldr_cons, foldl_eq_of_comm_of_assoc]\n    rw [foldl_eq_foldr a l]\n\n"}
{"name":"List.foldl_eq_of_comm'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β → α\nhf : ∀ (a : α) (b c : β), Eq (f (f a b) c) (f (f a c) b)\na : α\nb : β\nl : List β\n⊢ Eq (List.foldl f a (List.cons b l)) (f (List.foldl f a l) b)","decl":"theorem foldl_eq_of_comm' : ∀ a b l, foldl f a (b :: l) = f (foldl f a l) b\n  | _, _, [] => rfl\n  | a, b, c :: l => by rw [foldl, foldl, foldl, ← foldl_eq_of_comm' .., foldl, hf]\n\n"}
{"name":"List.foldl_eq_foldr'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β → α\nhf : ∀ (a : α) (b c : β), Eq (f (f a b) c) (f (f a c) b)\na : α\nl : List β\n⊢ Eq (List.foldl f a l) (List.foldr (flip f) a l)","decl":"theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l\n  | _, [] => rfl\n  | a, b :: l => by rw [foldl_eq_of_comm' hf, foldr, foldl_eq_foldr' ..]; rfl\n\n"}
{"name":"List.foldr_eq_of_comm'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β → β\nhf : ∀ (a b : α) (c : β), Eq (f a (f b c)) (f b (f a c))\na : β\nb : α\nl : List α\n⊢ Eq (List.foldr f a (List.cons b l)) (List.foldr f (f b a) l)","decl":"theorem foldr_eq_of_comm' (hf : ∀ a b c, f a (f b c) = f b (f a c)) :\n    ∀ a b l, foldr f a (b :: l) = foldr f (f b a) l\n  | _, _, [] => rfl\n  | a, b, c :: l => by rw [foldr, foldr, foldr, hf, ← foldr_eq_of_comm' hf ..]; rfl\n\n"}
{"name":"List.foldl_op_eq_op_foldr_assoc","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nop : α → α → α\nha : Std.Associative op\nl : List α\na₁ a₂ : α\n⊢ Eq (op (List.foldl op a₁ l) a₂) (op a₁ (List.foldr (fun x1 x2 => op x1 x2) a₂ l))","decl":"theorem foldl_op_eq_op_foldr_assoc :\n    ∀ {l : List α} {a₁ a₂}, ((l <*> a₁) ⋆ a₂) = a₁ ⋆ l.foldr (· ⋆ ·) a₂\n  | [], _, _ => rfl\n  | a :: l, a₁, a₂ => by\n    simp only [foldl_cons, foldr_cons, foldl_assoc, ha.assoc]; rw [foldl_op_eq_op_foldr_assoc]\n\n"}
{"name":"List.foldl_assoc_comm_cons","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nop : α → α → α\nha : Std.Associative op\nhc : Std.Commutative op\nl : List α\na₁ a₂ : α\n⊢ Eq (List.foldl op a₂ (List.cons a₁ l)) (op a₁ (List.foldl op a₂ l))","decl":"theorem foldl_assoc_comm_cons {l : List α} {a₁ a₂} : ((a₁ :: l) <*> a₂) = a₁ ⋆ l <*> a₂ := by\n  rw [foldl_cons, hc.comm, foldl_assoc]\n\n"}
{"name":"List.foldrM_eq_foldr","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nm : Type v → Type w\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nf : α → β → m β\nb : β\nl : List α\n⊢ Eq (List.foldrM f b l) (List.foldr (fun a mb => Bind.bind mb (f a)) (Pure.pure b) l)","decl":"theorem foldrM_eq_foldr (f : α → β → m β) (b l) :\n    foldrM f b l = foldr (fun a mb => mb >>= f a) (pure b) l := by induction l <;> simp [*]\n\n"}
{"name":"List.foldlM_eq_foldl","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nm : Type v → Type w\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nf : β → α → m β\nb : β\nl : List α\n⊢ Eq (List.foldlM f b l) (List.foldl (fun mb a => Bind.bind mb fun b => f b a) (Pure.pure b) l)","decl":"theorem foldlM_eq_foldl (f : β → α → m β) (b l) :\n    List.foldlM f b l = foldl (fun mb a => mb >>= fun b => f b a) (pure b) l := by\n  suffices h :\n    ∀ mb : m β, (mb >>= fun b => List.foldlM f b l) = foldl (fun mb a => mb >>= fun b => f b a) mb l\n    by simp [← h (pure b)]\n  induction l with\n  | nil => intro; simp\n  | cons _ _ l_ih => intro; simp only [List.foldlM, foldl, ← l_ih, functor_norm]\n\n"}
{"name":"List.intersperse_singleton","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\na b : α\n⊢ Eq (List.intersperse a (List.cons b List.nil)) (List.cons b List.nil)","decl":"@[simp]\ntheorem intersperse_singleton (a b : α) : intersperse a [b] = [b] :=\n  rfl\n\n"}
{"name":"List.intersperse_cons_cons","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\na b c : α\ntl : List α\n⊢ Eq (List.intersperse a (List.cons b (List.cons c tl))) (List.cons b (List.cons a (List.intersperse a (List.cons c tl))))","decl":"@[simp]\ntheorem intersperse_cons_cons (a b c : α) (tl : List α) :\n    intersperse a (b :: c :: tl) = b :: a :: intersperse a (c :: tl) :=\n  rfl\n\n"}
{"name":"List.splitAt_eq_take_drop","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u_1\nn : Nat\nl : List α\n⊢ Eq (List.splitAt n l) { fst := List.take n l, snd := List.drop n l }","decl":"@[deprecated (since := \"2024-08-17\")] alias splitAt_eq_take_drop := splitAt_eq\n\n"}
{"name":"List.splitOn_nil","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\na : α\n⊢ Eq (List.splitOn a List.nil) (List.cons List.nil List.nil)","decl":"@[simp]\ntheorem splitOn_nil [DecidableEq α] (a : α) : [].splitOn a = [[]] :=\n  rfl\n\n"}
{"name":"List.splitOnP_nil","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\n⊢ Eq (List.splitOnP p List.nil) (List.cons List.nil List.nil)","decl":"@[simp]\ntheorem splitOnP_nil : [].splitOnP p = [[]] :=\n  rfl\n\n"}
{"name":"List.splitOnP.go_ne_nil","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nxs acc : List α\n⊢ Ne (List.splitOnP.go p xs acc) List.nil","decl":"theorem splitOnP.go_ne_nil (xs acc : List α) : splitOnP.go p xs acc ≠ [] := by\n  induction xs generalizing acc <;> simp [go]; split <;> simp [*]\n\n"}
{"name":"List.splitOnP.go_acc","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nxs acc : List α\n⊢ Eq (List.splitOnP.go p xs acc) (List.modifyHead (fun x => HAppend.hAppend acc.reverse x) (List.splitOnP p xs))","decl":"theorem splitOnP.go_acc (xs acc : List α) :\n    splitOnP.go p xs acc = modifyHead (acc.reverse ++ ·) (splitOnP p xs) := by\n  induction xs generalizing acc with\n  | nil => simp only [go, modifyHead, splitOnP_nil, append_nil]\n  | cons hd tl ih =>\n    simp only [splitOnP, go]; split\n    · simp only [modifyHead, reverse_nil, append_nil]\n    · rw [ih [hd], modifyHead_modifyHead, ih]\n      congr; funext x; simp only [reverse_cons, append_assoc]; rfl\n\n"}
{"name":"List.splitOnP_ne_nil","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nxs : List α\n⊢ Ne (List.splitOnP p xs) List.nil","decl":"theorem splitOnP_ne_nil (xs : List α) : xs.splitOnP p ≠ [] := splitOnP.go_ne_nil _ _ _\n\n"}
{"name":"List.splitOnP_cons","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nx : α\nxs : List α\n⊢ Eq (List.splitOnP p (List.cons x xs)) (ite (Eq (p x) Bool.true) (List.cons List.nil (List.splitOnP p xs)) (List.modifyHead (List.cons x) (List.splitOnP p xs)))","decl":"@[simp]\ntheorem splitOnP_cons (x : α) (xs : List α) :\n    (x :: xs).splitOnP p =\n      if p x then [] :: xs.splitOnP p else (xs.splitOnP p).modifyHead (cons x) := by\n  rw [splitOnP, splitOnP.go]; split <;> [rfl; simp [splitOnP.go_acc]]\n\n"}
{"name":"List.splitOnP_spec.flatten_zipWith","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nxs ys : List (List α)\na : α\nhxs : Ne xs List.nil\nhys : Ne ys List.nil\n⊢ Eq (List.zipWith (fun x x_1 => HAppend.hAppend x x_1) (List.modifyHead (List.cons a) xs) ys).flatten (List.cons a (List.zipWith (fun x x_1 => HAppend.hAppend x x_1) xs ys).flatten)","decl":"/-- The original list `L` can be recovered by flattening the lists produced by `splitOnP p L`,\ninterspersed with the elements `L.filter p`. -/\ntheorem splitOnP_spec (as : List α) :\n    flatten (zipWith (· ++ ·) (splitOnP p as) (((as.filter p).map fun x => [x]) ++ [[]])) = as := by\n  induction as with\n  | nil => rfl\n  | cons a as' ih =>\n    rw [splitOnP_cons, filter]\n    by_cases h : p a\n    · rw [if_pos h, h, map, cons_append, zipWith, nil_append, flatten, cons_append, cons_inj_right]\n      exact ih\n    · rw [if_neg h, eq_false_of_ne_true h, flatten_zipWith (splitOnP_ne_nil _ _)\n        (append_ne_nil_of_right_ne_nil _ (cons_ne_nil [] [])), cons_inj_right]\n      exact ih\nwhere\n  flatten_zipWith {xs ys : List (List α)} {a : α} (hxs : xs ≠ []) (hys : ys ≠ []) :\n      flatten (zipWith (fun x x_1 ↦ x ++ x_1) (modifyHead (cons a) xs) ys) =\n        a :: flatten (zipWith (fun x x_1 ↦ x ++ x_1) xs ys) := by\n    cases xs with | nil => contradiction | cons =>\n      cases ys with | nil => contradiction | cons => rfl\n\n"}
{"name":"List.splitOnP_spec","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nas : List α\n⊢ Eq (List.zipWith (fun x1 x2 => HAppend.hAppend x1 x2) (List.splitOnP p as) (HAppend.hAppend (List.map (fun x => List.cons x List.nil) (List.filter p as)) (List.cons List.nil List.nil))).flatten as","decl":"/-- The original list `L` can be recovered by flattening the lists produced by `splitOnP p L`,\ninterspersed with the elements `L.filter p`. -/\ntheorem splitOnP_spec (as : List α) :\n    flatten (zipWith (· ++ ·) (splitOnP p as) (((as.filter p).map fun x => [x]) ++ [[]])) = as := by\n  induction as with\n  | nil => rfl\n  | cons a as' ih =>\n    rw [splitOnP_cons, filter]\n    by_cases h : p a\n    · rw [if_pos h, h, map, cons_append, zipWith, nil_append, flatten, cons_append, cons_inj_right]\n      exact ih\n    · rw [if_neg h, eq_false_of_ne_true h, flatten_zipWith (splitOnP_ne_nil _ _)\n        (append_ne_nil_of_right_ne_nil _ (cons_ne_nil [] [])), cons_inj_right]\n      exact ih\nwhere\n  flatten_zipWith {xs ys : List (List α)} {a : α} (hxs : xs ≠ []) (hys : ys ≠ []) :\n      flatten (zipWith (fun x x_1 ↦ x ++ x_1) (modifyHead (cons a) xs) ys) =\n        a :: flatten (zipWith (fun x x_1 ↦ x ++ x_1) xs ys) := by\n    cases xs with | nil => contradiction | cons =>\n      cases ys with | nil => contradiction | cons => rfl\n\n"}
{"name":"List.splitOnP_eq_single","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nxs : List α\nh : ∀ (x : α), Membership.mem xs x → Not (Eq (p x) Bool.true)\n⊢ Eq (List.splitOnP p xs) (List.cons xs List.nil)","decl":"/-- If no element satisfies `p` in the list `xs`, then `xs.splitOnP p = [xs]` -/\ntheorem splitOnP_eq_single (h : ∀ x ∈ xs, ¬p x) : xs.splitOnP p = [xs] := by\n  induction xs with\n  | nil => rfl\n  | cons hd tl ih =>\n    simp only [splitOnP_cons, h hd (mem_cons_self hd tl), if_neg]\n    rw [ih <| forall_mem_of_forall_mem_cons h]\n    rfl\n\n"}
{"name":"List.splitOnP_first","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nxs : List α\nh : ∀ (x : α), Membership.mem xs x → Not (Eq (p x) Bool.true)\nsep : α\nhsep : Eq (p sep) Bool.true\nas : List α\n⊢ Eq (List.splitOnP p (HAppend.hAppend xs (List.cons sep as))) (List.cons xs (List.splitOnP p as))","decl":"/-- When a list of the form `[...xs, sep, ...as]` is split on `p`, the first element is `xs`,\n  assuming no element in `xs` satisfies `p` but `sep` does satisfy `p` -/\ntheorem splitOnP_first (h : ∀ x ∈ xs, ¬p x) (sep : α) (hsep : p sep) (as : List α) :\n    (xs ++ sep :: as).splitOnP p = xs :: as.splitOnP p := by\n  induction xs with\n  | nil => simp [hsep]\n  | cons hd tl ih => simp [h hd _, ih <| forall_mem_of_forall_mem_cons h]\n\n"}
{"name":"List.intercalate_splitOn","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nxs : List α\nx : α\ninst✝ : DecidableEq α\n⊢ Eq ((List.cons x List.nil).intercalate (List.splitOn x xs)) xs","decl":"/-- `intercalate [x]` is the left inverse of `splitOn x`  -/\ntheorem intercalate_splitOn (x : α) [DecidableEq α] : [x].intercalate (xs.splitOn x) = xs := by\n  simp only [intercalate, splitOn]\n  induction' xs with hd tl ih; · simp [flatten]\n  cases' h' : splitOnP (· == x) tl with hd' tl'; · exact (splitOnP_ne_nil _ tl h').elim\n  rw [h'] at ih\n  rw [splitOnP_cons]\n  split_ifs with h\n  · rw [beq_iff_eq] at h\n    subst h\n    simp [ih, flatten, h']\n  cases tl' <;> simpa [flatten, h'] using ih\n\n"}
{"name":"List.splitOn_intercalate","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nls : List (List α)\ninst✝ : DecidableEq α\nx : α\nhx : ∀ (l : List α), Membership.mem ls l → Not (Membership.mem l x)\nhls : Ne ls List.nil\n⊢ Eq (List.splitOn x ((List.cons x List.nil).intercalate ls)) ls","decl":"/-- `splitOn x` is the left inverse of `intercalate [x]`, on the domain\n  consisting of each nonempty list of lists `ls` whose elements do not contain `x`  -/\ntheorem splitOn_intercalate [DecidableEq α] (x : α) (hx : ∀ l ∈ ls, x ∉ l) (hls : ls ≠ []) :\n    ([x].intercalate ls).splitOn x = ls := by\n  simp only [intercalate]\n  induction' ls with hd tl ih; · contradiction\n  cases tl\n  · suffices hd.splitOn x = [hd] by simpa [flatten]\n    refine splitOnP_eq_single _ _ ?_\n    intro y hy H\n    rw [eq_of_beq H] at hy\n    refine hx hd ?_ hy\n    simp\n  · simp only [intersperse_cons_cons, singleton_append, flatten]\n    specialize ih _ _\n    · intro l hl\n      apply hx l\n      simp only [mem_cons] at hl ⊢\n      exact Or.inr hl\n    · exact List.noConfusion\n    have := splitOnP_first (· == x) hd ?h x (beq_self_eq_true _)\n    case h =>\n      intro y hy H\n      rw [eq_of_beq H] at hy\n      exact hx hd (.head _) hy\n    simp only [splitOn] at ih ⊢\n    rw [this, ih]\n\n"}
{"name":"List.modifyLast.go_append_one","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nf : α → α\na : α\ntl : List α\nr : Array α\n⊢ Eq (List.modifyLast.go f (HAppend.hAppend tl (List.cons a List.nil)) r) (r.toListAppend (List.modifyLast.go f (HAppend.hAppend tl (List.cons a List.nil)) List.nil.toArray))","decl":"theorem modifyLast.go_append_one (f : α → α) (a : α) (tl : List α) (r : Array α) :\n    modifyLast.go f (tl ++ [a]) r = (r.toListAppend <| modifyLast.go f (tl ++ [a]) #[]) := by\n  cases tl with\n  | nil =>\n    simp only [nil_append, modifyLast.go]; rfl\n  | cons hd tl =>\n    simp only [cons_append]\n    rw [modifyLast.go, modifyLast.go]\n    case x_3 | x_3 => exact append_ne_nil_of_right_ne_nil tl (cons_ne_nil a [])\n    rw [modifyLast.go_append_one _ _ tl _, modifyLast.go_append_one _ _ tl (Array.push #[] hd)]\n    simp only [Array.toListAppend_eq, Array.push_toList, Array.toList_toArray, nil_append,\n      append_assoc]\n\n"}
{"name":"List.modifyLast_append_one","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nf : α → α\na : α\nl : List α\n⊢ Eq (List.modifyLast f (HAppend.hAppend l (List.cons a List.nil))) (HAppend.hAppend l (List.cons (f a) List.nil))","decl":"theorem modifyLast_append_one (f : α → α) (a : α) (l : List α) :\n    modifyLast f (l ++ [a]) = l ++ [f a] := by\n  cases l with\n  | nil =>\n    simp only [nil_append, modifyLast, modifyLast.go, Array.toListAppend_eq, Array.toList_toArray]\n  | cons _ tl =>\n    simp only [cons_append, modifyLast]\n    rw [modifyLast.go]\n    case x_3 => exact append_ne_nil_of_right_ne_nil tl (cons_ne_nil a [])\n    rw [modifyLast.go_append_one, Array.toListAppend_eq, Array.push_toList, Array.toList_toArray,\n      nil_append, cons_append, nil_append, cons_inj_right]\n    exact modifyLast_append_one _ _ tl\n\n"}
{"name":"List.modifyLast_append","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nf : α → α\nl₁ l₂ : List α\nx✝ : Ne l₂ List.nil\n⊢ Eq (List.modifyLast f (HAppend.hAppend l₁ l₂)) (HAppend.hAppend l₁ (List.modifyLast f l₂))","decl":"theorem modifyLast_append (f : α → α) (l₁ l₂ : List α) (_ : l₂ ≠ []) :\n    modifyLast f (l₁ ++ l₂) = l₁ ++ modifyLast f l₂ := by\n  cases l₂ with\n  | nil => contradiction\n  | cons hd tl =>\n    cases tl with\n    | nil => exact modifyLast_append_one _ hd _\n    | cons hd' tl' =>\n      rw [append_cons, ← nil_append (hd :: hd' :: tl'), append_cons [], nil_append,\n        modifyLast_append _ (l₁ ++ [hd]) (hd' :: tl') _, modifyLast_append _ [hd] (hd' :: tl') _,\n        append_assoc]\n      all_goals { exact cons_ne_nil _ _ }\n\n"}
{"name":"List.sizeOf_lt_sizeOf_of_mem","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : SizeOf α\nx : α\nl : List α\nhx : Membership.mem l x\n⊢ LT.lt (SizeOf.sizeOf x) (SizeOf.sizeOf l)","decl":"theorem sizeOf_lt_sizeOf_of_mem [SizeOf α] {x : α} {l : List α} (hx : x ∈ l) :\n    SizeOf.sizeOf x < SizeOf.sizeOf l := by\n  induction' l with h t ih <;> cases hx <;> rw [cons.sizeOf_spec]\n  · omega\n  · specialize ih ‹_›\n    omega\n\n"}
{"name":"List.lookmap.go_append","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nf : α → Option α\nl : List α\nacc : Array α\n⊢ Eq (List.lookmap.go f l acc) (acc.toListAppend (List.lookmap f l))","decl":"theorem lookmap.go_append (l : List α) (acc : Array α) :\n    lookmap.go f l acc = acc.toListAppend (lookmap f l) := by\n  cases l with\n  | nil => simp [go, lookmap]\n  | cons hd tl =>\n    rw [lookmap, go, go]\n    cases f hd with\n    | none =>\n      simp only [go_append tl _, Array.toListAppend_eq, append_assoc, Array.push_toList]\n      rfl\n    | some a => rfl\n\n"}
{"name":"List.lookmap_nil","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nf : α → Option α\n⊢ Eq (List.lookmap f List.nil) List.nil","decl":"@[simp]\ntheorem lookmap_nil : [].lookmap f = [] :=\n  rfl\n\n"}
{"name":"List.lookmap_cons_none","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nf : α → Option α\na : α\nl : List α\nh : Eq (f a) Option.none\n⊢ Eq (List.lookmap f (List.cons a l)) (List.cons a (List.lookmap f l))","decl":"@[simp]\ntheorem lookmap_cons_none {a : α} (l : List α) (h : f a = none) :\n    (a :: l).lookmap f = a :: l.lookmap f := by\n  simp only [lookmap, lookmap.go, Array.toListAppend_eq, Array.toList_toArray, nil_append]\n  rw [lookmap.go_append, h]; rfl\n\n"}
{"name":"List.lookmap_cons_some","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nf : α → Option α\na b : α\nl : List α\nh : Eq (f a) (Option.some b)\n⊢ Eq (List.lookmap f (List.cons a l)) (List.cons b l)","decl":"@[simp]\ntheorem lookmap_cons_some {a b : α} (l : List α) (h : f a = some b) :\n    (a :: l).lookmap f = b :: l := by\n  simp only [lookmap, lookmap.go, Array.toListAppend_eq, Array.toList_toArray, nil_append]\n  rw [h]\n\n"}
{"name":"List.lookmap_some","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\n⊢ Eq (List.lookmap Option.some l) l","decl":"theorem lookmap_some : ∀ l : List α, l.lookmap some = l\n  | [] => rfl\n  | _ :: _ => rfl\n\n"}
{"name":"List.lookmap_none","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\n⊢ Eq (List.lookmap (fun x => Option.none) l) l","decl":"theorem lookmap_none : ∀ l : List α, (l.lookmap fun _ => none) = l\n  | [] => rfl\n  | a :: l => (lookmap_cons_none _ l rfl).trans (congr_arg (cons a) (lookmap_none l))\n\n"}
{"name":"List.lookmap_congr","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nf g : α → Option α\nl : List α\na✝ : ∀ (a : α), Membership.mem l a → Eq (f a) (g a)\n⊢ Eq (List.lookmap f l) (List.lookmap g l)","decl":"theorem lookmap_congr {f g : α → Option α} :\n    ∀ {l : List α}, (∀ a ∈ l, f a = g a) → l.lookmap f = l.lookmap g\n  | [], _ => rfl\n  | a :: l, H => by\n    cases' forall_mem_cons.1 H with H₁ H₂\n    cases' h : g a with b\n    · simp [h, H₁.trans h, lookmap_congr H₂]\n    · simp [lookmap_cons_some _ _ h, lookmap_cons_some _ _ (H₁.trans h)]\n\n"}
{"name":"List.lookmap_of_forall_not","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nf : α → Option α\nl : List α\nH : ∀ (a : α), Membership.mem l a → Eq (f a) Option.none\n⊢ Eq (List.lookmap f l) l","decl":"theorem lookmap_of_forall_not {l : List α} (H : ∀ a ∈ l, f a = none) : l.lookmap f = l :=\n  (lookmap_congr H).trans (lookmap_none l)\n\n"}
{"name":"List.lookmap_map_eq","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → Option α\ng : α → β\nh : ∀ (a b : α), Membership.mem (f a) b → Eq (g a) (g b)\nl : List α\n⊢ Eq (List.map g (List.lookmap f l)) (List.map g l)","decl":"theorem lookmap_map_eq (g : α → β) (h : ∀ (a), ∀ b ∈ f a, g a = g b) :\n    ∀ l : List α, map g (l.lookmap f) = map g l\n  | [] => rfl\n  | a :: l => by\n    cases' h' : f a with b\n    · simpa [h'] using lookmap_map_eq _ h l\n    · simp [lookmap_cons_some _ _ h', h _ _ h']\n\n"}
{"name":"List.lookmap_id'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nf : α → Option α\nh : ∀ (a b : α), Membership.mem (f a) b → Eq a b\nl : List α\n⊢ Eq (List.lookmap f l) l","decl":"theorem lookmap_id' (h : ∀ (a), ∀ b ∈ f a, a = b) (l : List α) : l.lookmap f = l := by\n  rw [← map_id (l.lookmap f), lookmap_map_eq, map_id]; exact h\n\n"}
{"name":"List.length_lookmap","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nf : α → Option α\nl : List α\n⊢ Eq (List.lookmap f l).length l.length","decl":"theorem length_lookmap (l : List α) : length (l.lookmap f) = length l := by\n  rw [← length_map, lookmap_map_eq _ fun _ => (), length_map]; simp\n\n"}
{"name":"List.length_eq_length_filter_add","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\nf : α → Bool\n⊢ Eq l.length (HAdd.hAdd (List.filter f l).length (List.filter (fun x => (f x).not) l).length)","decl":"theorem length_eq_length_filter_add {l : List (α)} (f : α → Bool) :\n    l.length = (l.filter f).length + (l.filter (! f ·)).length := by\n  simp_rw [← List.countP_eq_length_filter, l.length_eq_countP_add_countP f, Bool.not_eq_true,\n    Bool.decide_eq_false]\n\n"}
{"name":"List.filterMap_eq_flatMap_toList","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → Option β\nl : List α\n⊢ Eq (List.filterMap f l) (l.flatMap fun a => (f a).toList)","decl":"theorem filterMap_eq_flatMap_toList (f : α → Option β) (l : List α) :\n    l.filterMap f = l.flatMap fun a ↦ (f a).toList := by\n  induction' l with a l ih <;> simp [filterMap_cons]\n  rcases f a <;> simp [ih]\n\n"}
{"name":"List.filterMap_eq_bind_toList","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → Option β\nl : List α\n⊢ Eq (List.filterMap f l) (l.flatMap fun a => (f a).toList)","decl":"@[deprecated (since := \"2024-10-16\")] alias filterMap_eq_bind_toList := filterMap_eq_flatMap_toList\n\n"}
{"name":"List.filterMap_congr","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf g : α → Option β\nl : List α\nh : ∀ (x : α), Membership.mem l x → Eq (f x) (g x)\n⊢ Eq (List.filterMap f l) (List.filterMap g l)","decl":"theorem filterMap_congr {f g : α → Option β} {l : List α}\n    (h : ∀ x ∈ l, f x = g x) : l.filterMap f = l.filterMap g := by\n  induction' l with a l ih <;> simp [filterMap_cons]\n  simp [ih (fun x hx ↦ h x (List.mem_cons_of_mem a hx))]\n  cases' hfa : f a with b\n  · have : g a = none := Eq.symm (by simpa [hfa] using h a (by simp))\n    simp [this]\n  · have : g a = some b := Eq.symm (by simpa [hfa] using h a (by simp))\n    simp [this]\n\n"}
{"name":"List.filterMap_eq_map_iff_forall_eq_some","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → Option β\ng : α → β\nl : List α\n⊢ Iff (Eq (List.filterMap f l) (List.map g l)) (∀ (x : α), Membership.mem l x → Eq (f x) (Option.some (g x)))","decl":"theorem filterMap_eq_map_iff_forall_eq_some {f : α → Option β} {g : α → β} {l : List α} :\n    l.filterMap f = l.map g ↔ ∀ x ∈ l, f x = some (g x) where\n  mp := by\n    induction' l with a l ih\n    · simp\n    cases' ha : f a with b <;> simp [ha, filterMap_cons]\n    · intro h\n      simpa [show (filterMap f l).length = l.length + 1 from by simp[h], Nat.add_one_le_iff]\n        using List.length_filterMap_le f l\n    · rintro rfl h\n      exact ⟨rfl, ih h⟩\n  mpr h := Eq.trans (filterMap_congr <| by simpa) (congr_fun (List.filterMap_eq_map _) _)\n\n"}
{"name":"List.filter_singleton","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\na : α\n⊢ Eq (List.filter p (List.cons a List.nil)) (cond (p a) (List.cons a List.nil) List.nil)","decl":"theorem filter_singleton {a : α} : [a].filter p = bif p a then [a] else [] :=\n  rfl\n\n"}
{"name":"List.filter_eq_foldr","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nl : List α\n⊢ Eq (List.filter p l) (List.foldr (fun a out => cond (p a) (List.cons a out) out) List.nil l)","decl":"theorem filter_eq_foldr (p : α → Bool) (l : List α) :\n    filter p l = foldr (fun a out => bif p a then a :: out else out) [] l := by\n  induction l <;> simp [*, filter]; rfl\n\n"}
{"name":"List.filter_subset'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nl : List α\n⊢ HasSubset.Subset (List.filter p l) l","decl":"@[simp]\ntheorem filter_subset' (l : List α) : filter p l ⊆ l :=\n  (filter_sublist l).subset\n\n"}
{"name":"List.of_mem_filter","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\na : α\nl : List α\nh : Membership.mem (List.filter p l) a\n⊢ Eq (p a) Bool.true","decl":"theorem of_mem_filter {a : α} {l} (h : a ∈ filter p l) : p a := (mem_filter.1 h).2\n\n"}
{"name":"List.mem_of_mem_filter","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\na : α\nl : List α\nh : Membership.mem (List.filter p l) a\n⊢ Membership.mem l a","decl":"theorem mem_of_mem_filter {a : α} {l} (h : a ∈ filter p l) : a ∈ l :=\n  filter_subset' l h\n\n"}
{"name":"List.mem_filter_of_mem","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\na : α\nl : List α\nh₁ : Membership.mem l a\nh₂ : Eq (p a) Bool.true\n⊢ Membership.mem (List.filter p l) a","decl":"theorem mem_filter_of_mem {a : α} {l} (h₁ : a ∈ l) (h₂ : p a) : a ∈ filter p l :=\n  mem_filter.2 ⟨h₁, h₂⟩\n\n"}
{"name":"List.monotone_filter_left","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nl l' : List α\nh : HasSubset.Subset l l'\n⊢ HasSubset.Subset (List.filter p l) (List.filter p l')","decl":"theorem monotone_filter_left (p : α → Bool) ⦃l l' : List α⦄ (h : l ⊆ l') :\n    filter p l ⊆ filter p l' := by\n  intro x hx\n  rw [mem_filter] at hx ⊢\n  exact ⟨h hx.left, hx.right⟩\n\n"}
{"name":"List.monotone_filter_right","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\np q : α → Bool\nh : ∀ (a : α), Eq (p a) Bool.true → Eq (q a) Bool.true\n⊢ (List.filter p l).Sublist (List.filter q l)","decl":"theorem monotone_filter_right (l : List α) ⦃p q : α → Bool⦄\n    (h : ∀ a, p a → q a) : l.filter p <+ l.filter q := by\n  induction' l with hd tl IH\n  · rfl\n  · by_cases hp : p hd\n    · rw [filter_cons_of_pos hp, filter_cons_of_pos (h _ hp)]\n      exact IH.cons_cons hd\n    · rw [filter_cons_of_neg hp]\n      by_cases hq : q hd\n      · rw [filter_cons_of_pos hq]\n        exact sublist_cons_of_sublist hd IH\n      · rw [filter_cons_of_neg hq]\n        exact IH\n\n-- TODO rename to `map_filter` when the deprecated `map_filter` is removed from Lean.\n"}
{"name":"List.map_filter'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\np : α → Bool\nf : α → β\nhf : Function.Injective f\nl : List α\ninst✝ : DecidablePred fun b => Exists fun a => And (Eq (p a) Bool.true) (Eq (f a) b)\n⊢ Eq (List.map f (List.filter p l)) (List.filter (fun b => Decidable.decide (Exists fun a => And (Eq (p a) Bool.true) (Eq (f a) b))) (List.map f l))","decl":"lemma map_filter' {f : α → β} (hf : Injective f) (l : List α)\n    [DecidablePred fun b => ∃ a, p a ∧ f a = b] :\n    (l.filter p).map f = (l.map f).filter fun b => ∃ a, p a ∧ f a = b := by\n  simp [comp_def, filter_map, hf.eq_iff]\n\n"}
{"name":"List.filter_attach'","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\np : (Subtype fun a => Membership.mem l a) → Bool\ninst✝ : DecidableEq α\n⊢ Eq (List.filter p l.attach) (List.map (Subtype.map id ⋯) (List.filter (fun x => Decidable.decide (Exists fun h => Eq (p ⟨x, h⟩) Bool.true)) l).attach)","decl":"lemma filter_attach' (l : List α) (p : {a // a ∈ l} → Bool) [DecidableEq α] :\n    l.attach.filter p =\n      (l.filter fun x => ∃ h, p ⟨x, h⟩).attach.map (Subtype.map id fun _ => mem_of_mem_filter) := by\n  classical\n  refine map_injective_iff.2 Subtype.coe_injective ?_\n  simp [comp_def, map_filter' _ Subtype.coe_injective]\n\n-- Porting note: `Lean.Internal.coeM` forces us to type-ascript `{x // x ∈ l}`\n"}
{"name":"List.filter_attach","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\np : α → Bool\n⊢ Eq (List.filter (fun x => p ↑x) l.attach) (List.map (Subtype.map id ⋯) (List.filter p l).attach)","decl":"lemma filter_attach (l : List α) (p : α → Bool) :\n    (l.attach.filter fun x => p x : List {x // x ∈ l}) =\n      (l.filter p).attach.map (Subtype.map id fun _ => mem_of_mem_filter) :=\n  map_injective_iff.2 Subtype.coe_injective <| by\n    simp_rw [map_map, comp_def, Subtype.map, id, ← Function.comp_apply (g := Subtype.val),\n      ← filter_map, attach_map_subtype_val]\n\n"}
{"name":"List.filter_comm","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np q : α → Bool\nl : List α\n⊢ Eq (List.filter p (List.filter q l)) (List.filter q (List.filter p l))","decl":"lemma filter_comm (q) (l : List α) : filter p (filter q l) = filter q (filter p l) := by\n  simp [Bool.and_comm]\n\n"}
{"name":"List.filter_true","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\n⊢ Eq (List.filter (fun x => Bool.true) l) l","decl":"@[simp]\ntheorem filter_true (l : List α) :\n    filter (fun _ => true) l = l := by induction l <;> simp [*, filter]\n\n"}
{"name":"List.filter_false","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl : List α\n⊢ Eq (List.filter (fun x => Bool.false) l) List.nil","decl":"@[simp]\ntheorem filter_false (l : List α) :\n    filter (fun _ => false) l = [] := by induction l <;> simp [*, filter]\n\n/- Porting note: need a helper theorem for span.loop. -/\n"}
{"name":"List.span.loop_eq_take_drop","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nl₁ l₂ : List α\n⊢ Eq (List.span.loop p l₁ l₂) { fst := HAppend.hAppend l₂.reverse (List.takeWhile p l₁), snd := List.dropWhile p l₁ }","decl":"theorem span.loop_eq_take_drop :\n    ∀ l₁ l₂ : List α, span.loop p l₁ l₂ = (l₂.reverse ++ takeWhile p l₁, dropWhile p l₁)\n  | [], l₂ => by simp [span.loop, takeWhile, dropWhile]\n  | (a :: l), l₂ => by\n    cases hp : p a <;> simp [hp, span.loop, span.loop_eq_take_drop, takeWhile, dropWhile]\n\n"}
{"name":"List.span_eq_take_drop","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nl : List α\n⊢ Eq (List.span p l) { fst := List.takeWhile p l, snd := List.dropWhile p l }","decl":"@[simp]\ntheorem span_eq_take_drop (l : List α) : span p l = (takeWhile p l, dropWhile p l) := by\n  simpa using span.loop_eq_take_drop p l []\n\n"}
{"name":"List.dropWhile_get_zero_not","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nl : List α\nhl : LT.lt 0 (List.dropWhile p l).length\n⊢ Not (Eq (p ((List.dropWhile p l).get ⟨0, hl⟩)) Bool.true)","decl":"theorem dropWhile_get_zero_not (l : List α) (hl : 0 < (l.dropWhile p).length) :\n    ¬p ((l.dropWhile p).get ⟨0, hl⟩) := by\n  induction' l with hd tl IH\n  · cases hl\n  · simp only [dropWhile]\n    by_cases hp : p hd\n    · simp_all only [get_eq_getElem]\n      apply IH\n      simp_all only [dropWhile_cons_of_pos]\n    · simp [hp]\n\n"}
{"name":"List.nthLe_cons","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u_1\ni : Nat\na : α\nl : List α\nw : LT.lt i (List.cons a l).length\n⊢ Eq (GetElem.getElem (List.cons a l) i w) (dite (Eq i 0) (fun h => a) fun h => GetElem.getElem l (HSub.hSub i 1) ⋯)","decl":"@[deprecated (since := \"2024-08-19\")] alias nthLe_cons := getElem_cons\n"}
{"name":"List.dropWhile_nthLe_zero_not","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nl : List α\nhl : LT.lt 0 (List.dropWhile p l).length\n⊢ Not (Eq (p ((List.dropWhile p l).get ⟨0, hl⟩)) Bool.true)","decl":"@[deprecated (since := \"2024-08-19\")] alias dropWhile_nthLe_zero_not := dropWhile_get_zero_not\n\n"}
{"name":"List.dropWhile_eq_nil_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nl : List α\n⊢ Iff (Eq (List.dropWhile p l) List.nil) (∀ (x : α), Membership.mem l x → Eq (p x) Bool.true)","decl":"@[simp]\ntheorem dropWhile_eq_nil_iff : dropWhile p l = [] ↔ ∀ x ∈ l, p x := by\n  induction' l with x xs IH\n  · simp [dropWhile]\n  · by_cases hp : p x <;> simp [hp, IH]\n\n"}
{"name":"List.takeWhile_eq_self_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nl : List α\n⊢ Iff (Eq (List.takeWhile p l) l) (∀ (x : α), Membership.mem l x → Eq (p x) Bool.true)","decl":"@[simp]\ntheorem takeWhile_eq_self_iff : takeWhile p l = l ↔ ∀ x ∈ l, p x := by\n  induction' l with x xs IH\n  · simp\n  · by_cases hp : p x <;> simp [hp, IH]\n\n"}
{"name":"List.takeWhile_eq_nil_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nl : List α\n⊢ Iff (Eq (List.takeWhile p l) List.nil) (∀ (hl : LT.lt 0 l.length), Not (Eq (p (l.get ⟨0, hl⟩)) Bool.true))","decl":"@[simp]\ntheorem takeWhile_eq_nil_iff : takeWhile p l = [] ↔ ∀ hl : 0 < l.length, ¬p (l.get ⟨0, hl⟩) := by\n  induction' l with x xs IH\n  · simp only [takeWhile_nil, Bool.not_eq_true, true_iff]\n    intro h\n    simp at h\n  · by_cases hp : p x <;> simp [hp, IH]\n\n"}
{"name":"List.mem_takeWhile_imp","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nl : List α\nx : α\nhx : Membership.mem (List.takeWhile p l) x\n⊢ Eq (p x) Bool.true","decl":"theorem mem_takeWhile_imp {x : α} (hx : x ∈ takeWhile p l) : p x := by\n  induction l with simp [takeWhile] at hx\n  | cons hd tl IH =>\n    cases hp : p hd\n    · simp [hp] at hx\n    · rw [hp, mem_cons] at hx\n      rcases hx with (rfl | hx)\n      · exact hp\n      · exact IH hx\n\n"}
{"name":"List.takeWhile_takeWhile","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np q : α → Bool\nl : List α\n⊢ Eq (List.takeWhile p (List.takeWhile q l)) (List.takeWhile (fun a => Decidable.decide (And (Eq (p a) Bool.true) (Eq (q a) Bool.true))) l)","decl":"theorem takeWhile_takeWhile (p q : α → Bool) (l : List α) :\n    takeWhile p (takeWhile q l) = takeWhile (fun a => p a ∧ q a) l := by\n  induction' l with hd tl IH\n  · simp\n  · by_cases hp : p hd <;> by_cases hq : q hd <;> simp [takeWhile, hp, hq, IH]\n\n"}
{"name":"List.takeWhile_idem","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nl : List α\n⊢ Eq (List.takeWhile p (List.takeWhile p l)) (List.takeWhile p l)","decl":"theorem takeWhile_idem : takeWhile p (takeWhile p l) = takeWhile p l := by\n  simp_rw [takeWhile_takeWhile, and_self_iff, Bool.decide_coe]\n\n"}
{"name":"List.find?_eq_head?_dropWhile_not","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nl : List α\n⊢ Eq (List.find? p l) (List.dropWhile (fun x => (p x).not) l).head?","decl":"lemma find?_eq_head?_dropWhile_not :\n    l.find? p = (l.dropWhile (fun x ↦ ! (p x))).head? := by\n  induction l\n  case nil => simp\n  case cons head tail hi =>\n    set ph := p head with phh\n    rcases ph with rfl | rfl\n    · have phh' : ¬(p head = true) := by simp [phh.symm]\n      rw [find?_cons_of_neg _ phh', dropWhile_cons_of_pos]\n      · exact hi\n      · simpa using phh\n    · rw [find?_cons_of_pos _ phh.symm, dropWhile_cons_of_neg]\n      · simp\n      · simpa using phh\n\n"}
{"name":"List.find?_not_eq_head?_dropWhile","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nl : List α\n⊢ Eq (List.find? (fun x => (p x).not) l) (List.dropWhile p l).head?","decl":"lemma find?_not_eq_head?_dropWhile :\n    l.find? (fun x ↦ ! (p x)) = (l.dropWhile p).head? := by\n  convert l.find?_eq_head?_dropWhile_not ?_\n  simp\n\n"}
{"name":"List.find?_eq_head_dropWhile_not","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nl : List α\nh : Exists fun x => And (Membership.mem l x) (Eq (p x) Bool.true)\n⊢ Eq (List.find? p l) (Option.some ((List.dropWhile (fun x => (p x).not) l).head ⋯))","decl":"lemma find?_eq_head_dropWhile_not (h : ∃ x ∈ l, p x) :\n    l.find? p = some ((l.dropWhile (fun x ↦ ! (p x))).head (by simpa using h)) := by\n  rw [l.find?_eq_head?_dropWhile_not p, ← head_eq_iff_head?_eq_some]\n\n"}
{"name":"List.find?_not_eq_head_dropWhile","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nl : List α\nh : Exists fun x => And (Membership.mem l x) (Not (Eq (p x) Bool.true))\n⊢ Eq (List.find? (fun x => (p x).not) l) (Option.some ((List.dropWhile p l).head ⋯))","decl":"lemma find?_not_eq_head_dropWhile (h : ∃ x ∈ l, ¬p x) :\n    l.find? (fun x ↦ ! (p x)) = some ((l.dropWhile p).head (by simpa using h)) := by\n  convert l.find?_eq_head_dropWhile_not ?_\n  · simp\n  · simpa using h\n\n"}
{"name":"List.length_eraseP_add_one","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Bool\nl : List α\na : α\nal : Membership.mem l a\npa : Eq (p a) Bool.true\n⊢ Eq (HAdd.hAdd (List.eraseP p l).length 1) l.length","decl":"@[simp]\ntheorem length_eraseP_add_one {l : List α} {a} (al : a ∈ l) (pa : p a) :\n    (l.eraseP p).length + 1 = l.length := by\n  let ⟨_, l₁, l₂, _, _, h₁, h₂⟩ := exists_of_eraseP al pa\n  rw [h₂, h₁, length_append, length_append]\n  rfl\n\n"}
{"name":"List.length_erase_add_one","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\na : α\nl : List α\nh : Membership.mem l a\n⊢ Eq (HAdd.hAdd (l.erase a).length 1) l.length","decl":"@[simp] theorem length_erase_add_one {a : α} {l : List α} (h : a ∈ l) :\n    (l.erase a).length + 1 = l.length := by\n  rw [erase_eq_eraseP, length_eraseP_add_one h (decide_eq_true rfl)]\n\n"}
{"name":"List.map_erase","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : α → β\nfinj : Function.Injective f\na : α\nl : List α\n⊢ Eq (List.map f (l.erase a)) ((List.map f l).erase (f a))","decl":"theorem map_erase [DecidableEq β] {f : α → β} (finj : Injective f) {a : α} (l : List α) :\n    map f (l.erase a) = (map f l).erase (f a) := by\n  have this : (a == ·) = (f a == f ·) := by ext b; simp [beq_eq_decide, finj.eq_iff]\n  rw [erase_eq_eraseP, erase_eq_eraseP, eraseP_map, this]; rfl\n\n"}
{"name":"List.map_foldl_erase","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : α → β\nfinj : Function.Injective f\nl₁ l₂ : List α\n⊢ Eq (List.map f (List.foldl List.erase l₁ l₂)) (List.foldl (fun l a => l.erase (f a)) (List.map f l₁) l₂)","decl":"theorem map_foldl_erase [DecidableEq β] {f : α → β} (finj : Injective f) {l₁ l₂ : List α} :\n    map f (foldl List.erase l₁ l₂) = foldl (fun l a => l.erase (f a)) (map f l₁) l₂ := by\n  induction l₂ generalizing l₁ <;> [rfl; simp only [foldl_cons, map_erase finj, *]]\n\n"}
{"name":"List.erase_getElem","module":"Mathlib.Data.List.Basic","initialProofState":"ι : Type u_1\ninst✝ : DecidableEq ι\nl : List ι\ni : Nat\nhi : LT.lt i l.length\n⊢ (l.erase (GetElem.getElem l i ⋯)).Perm (l.eraseIdx i)","decl":"theorem erase_getElem [DecidableEq ι] {l : List ι} {i : ℕ} (hi : i < l.length) :\n    Perm (l.erase l[i]) (l.eraseIdx i) := by\n  induction l generalizing i with\n  | nil => simp\n  | cons a l IH =>\n    cases i with\n    | zero => simp\n    | succ i =>\n      have hi' : i < l.length := by simpa using hi\n      if ha : a = l[i] then\n        simpa [ha] using .trans (perm_cons_erase (getElem_mem _)) (.cons _ (IH hi'))\n      else\n        simpa [ha] using IH hi'\n\n"}
{"name":"List.erase_get","module":"Mathlib.Data.List.Basic","initialProofState":"ι : Type u_1\ninst✝ : DecidableEq ι\nl : List ι\ni : Fin l.length\n⊢ (l.erase (l.get i)).Perm (l.eraseIdx ↑i)","decl":"@[deprecated erase_getElem (since := \"2024-08-03\")]\ntheorem erase_get [DecidableEq ι] {l : List ι} (i : Fin l.length) :\n    Perm (l.erase (l.get i)) (l.eraseIdx ↑i) :=\n  erase_getElem i.isLt\n\n"}
{"name":"List.length_eraseIdx_add_one","module":"Mathlib.Data.List.Basic","initialProofState":"ι : Type u_1\nl : List ι\ni : Nat\nh : LT.lt i l.length\n⊢ Eq (HAdd.hAdd (l.eraseIdx i).length 1) l.length","decl":"theorem length_eraseIdx_add_one {l : List ι} {i : ℕ} (h : i < l.length) :\n    (l.eraseIdx i).length + 1 = l.length := calc\n  (l.eraseIdx i).length + 1\n  _ = (l.take i ++ l.drop (i + 1)).length + 1         := by rw [eraseIdx_eq_take_drop_succ]\n  _ = (l.take i).length + (l.drop (i + 1)).length + 1 := by rw [length_append]\n  _ = i + (l.drop (i + 1)).length + 1                 := by rw [length_take_of_le (le_of_lt h)]\n  _ = i + (l.length - (i + 1)) + 1                    := by rw [length_drop]\n  _ = (i + 1) + (l.length - (i + 1))                  := by omega\n  _ = l.length                                        := Nat.add_sub_cancel' (succ_le_of_lt h)\n\n\n"}
{"name":"List.map_diff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : α → β\nfinj : Function.Injective f\nl₁ l₂ : List α\n⊢ Eq (List.map f (l₁.diff l₂)) ((List.map f l₁).diff (List.map f l₂))","decl":"@[simp]\ntheorem map_diff [DecidableEq β] {f : α → β} (finj : Injective f) {l₁ l₂ : List α} :\n    map f (l₁.diff l₂) = (map f l₁).diff (map f l₂) := by\n  simp only [diff_eq_foldl, foldl_map, map_foldl_erase finj]\n\n"}
{"name":"List.erase_diff_erase_sublist_of_sublist","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\na : α\nl₁ l₂ : List α\na✝ : l₁.Sublist l₂\n⊢ ((l₂.erase a).diff (l₁.erase a)).Sublist (l₂.diff l₁)","decl":"theorem erase_diff_erase_sublist_of_sublist {a : α} :\n    ∀ {l₁ l₂ : List α}, l₁ <+ l₂ → (l₂.erase a).diff (l₁.erase a) <+ l₂.diff l₁\n  | [], _, _ => erase_sublist _ _\n  | b :: l₁, l₂, h =>\n    if heq : b = a then by simp only [heq, erase_cons_head, diff_cons]; rfl\n    else by\n      simp only [erase_cons_head b l₁, erase_cons_tail (not_beq_of_ne heq),\n        diff_cons ((List.erase l₂ a)) (List.erase l₁ a) b, diff_cons l₂ l₁ b, erase_comm a b l₂]\n      have h' := h.erase b\n      rw [erase_cons_head] at h'\n      exact @erase_diff_erase_sublist_of_sublist _ l₁ (l₂.erase b) h'\n\n"}
{"name":"List.choose_spec","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝ : DecidablePred p\nl : List α\nhp : Exists fun a => And (Membership.mem l a) (p a)\n⊢ And (Membership.mem l (List.choose p l hp)) (p (List.choose p l hp))","decl":"theorem choose_spec (hp : ∃ a, a ∈ l ∧ p a) : choose p l hp ∈ l ∧ p (choose p l hp) :=\n  (chooseX p l hp).property\n\n"}
{"name":"List.choose_mem","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝ : DecidablePred p\nl : List α\nhp : Exists fun a => And (Membership.mem l a) (p a)\n⊢ Membership.mem l (List.choose p l hp)","decl":"theorem choose_mem (hp : ∃ a, a ∈ l ∧ p a) : choose p l hp ∈ l :=\n  (choose_spec _ _ _).1\n\n"}
{"name":"List.choose_property","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝ : DecidablePred p\nl : List α\nhp : Exists fun a => And (Membership.mem l a) (p a)\n⊢ p (List.choose p l hp)","decl":"theorem choose_property (hp : ∃ a, a ∈ l ∧ p a) : p (choose p l hp) :=\n  (choose_spec _ _ _).2\n\n"}
{"name":"List.forall_cons","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Prop\nx : α\nl : List α\n⊢ Iff (List.Forall p (List.cons x l)) (And (p x) (List.Forall p l))","decl":"@[simp]\ntheorem forall_cons (p : α → Prop) (x : α) : ∀ l : List α, Forall p (x :: l) ↔ p x ∧ Forall p l\n  | [] => (and_iff_left_of_imp fun _ ↦ trivial).symm\n  | _ :: _ => Iff.rfl\n\n"}
{"name":"List.forall_iff_forall_mem","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np : α → Prop\nl : List α\n⊢ Iff (List.Forall p l) (∀ (x : α), Membership.mem l x → p x)","decl":"theorem forall_iff_forall_mem : ∀ {l : List α}, Forall p l ↔ ∀ x ∈ l, p x\n  | [] => (iff_true_intro <| forall_mem_nil _).symm\n  | x :: l => by rw [forall_mem_cons, forall_cons, forall_iff_forall_mem]\n\n"}
{"name":"List.Forall.imp","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\np q : α → Prop\nh : ∀ (x : α), p x → q x\nl : List α\na✝ : List.Forall p l\n⊢ List.Forall q l","decl":"theorem Forall.imp (h : ∀ x, p x → q x) : ∀ {l : List α}, Forall p l → Forall q l\n  | [] => id\n  | x :: l => by\n    simp only [forall_cons, and_imp]\n    rw [← and_imp]\n    exact And.imp (h x) (Forall.imp h)\n\n"}
{"name":"List.forall_map_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nl : List α\np : β → Prop\nf : α → β\n⊢ Iff (List.Forall p (List.map f l)) (List.Forall (Function.comp p f) l)","decl":"@[simp]\ntheorem forall_map_iff {p : β → Prop} (f : α → β) : Forall p (l.map f) ↔ Forall (p ∘ f) l := by\n  induction l <;> simp [*]\n\n"}
{"name":"List.get_attach","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nL : List α\ni : Fin L.attach.length\n⊢ Eq (↑(L.attach.get i)) (L.get ⟨↑i, ⋯⟩)","decl":"theorem get_attach (L : List α) (i) :\n    (L.attach.get i).1 = L.get ⟨i, length_attach (L := L) ▸ i.2⟩ := by simp\n\n"}
{"name":"List.dropSlice_eq","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nxs : List α\nn m : Nat\n⊢ Eq (List.dropSlice n m xs) (HAppend.hAppend (List.take n xs) (List.drop (HAdd.hAdd n m) xs))","decl":"theorem dropSlice_eq (xs : List α) (n m : ℕ) : dropSlice n m xs = xs.take n ++ xs.drop (n + m) := by\n  induction n generalizing xs\n  · cases xs <;> simp [dropSlice]\n  · cases xs <;> simp [dropSlice, *, Nat.succ_add]\n\n"}
{"name":"List.length_dropSlice","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ni j : Nat\nxs : List α\n⊢ Eq (List.dropSlice i j xs).length (HSub.hSub xs.length (Min.min j (HSub.hSub xs.length i)))","decl":"@[simp]\ntheorem length_dropSlice (i j : ℕ) (xs : List α) :\n    (List.dropSlice i j xs).length = xs.length - min j (xs.length - i) := by\n  induction xs generalizing i j with\n  | nil => simp\n  | cons x xs xs_ih =>\n    cases i <;> simp only [List.dropSlice]\n    · cases j with\n      | zero => simp\n      | succ n => simp_all [xs_ih]; omega\n    · simp [xs_ih]; omega\n\n"}
{"name":"List.length_dropSlice_lt","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\ni j : Nat\nhj : LT.lt 0 j\nxs : List α\nhi : LT.lt i xs.length\n⊢ LT.lt (List.dropSlice i j xs).length xs.length","decl":"theorem length_dropSlice_lt (i j : ℕ) (hj : 0 < j) (xs : List α) (hi : i < xs.length) :\n    (List.dropSlice i j xs).length < xs.length := by\n  simp; omega\n\n"}
{"name":"List.disjoint_pmap","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\np : α → Prop\nf : (a : α) → p a → β\ns t : List α\nhs : ∀ (a : α), Membership.mem s a → p a\nht : ∀ (a : α), Membership.mem t a → p a\nhf : ∀ (a a' : α) (ha : p a) (ha' : p a'), Eq (f a ha) (f a' ha') → Eq a a'\nh : s.Disjoint t\n⊢ (List.pmap f s hs).Disjoint (List.pmap f t ht)","decl":"/-- The images of disjoint lists under a partially defined map are disjoint -/\ntheorem disjoint_pmap {p : α → Prop} {f : ∀ a : α, p a → β} {s t : List α}\n    (hs : ∀ a ∈ s, p a) (ht : ∀ a ∈ t, p a)\n    (hf : ∀ (a a' : α) (ha : p a) (ha' : p a'), f a ha = f a' ha' → a = a')\n    (h : Disjoint s t) :\n    Disjoint (s.pmap f hs) (t.pmap f ht) := by\n  simp only [Disjoint, mem_pmap]\n  rintro b ⟨a, ha, rfl⟩ ⟨a', ha', ha''⟩\n  apply h ha\n  rwa [hf a a' (hs a ha) (ht a' ha') ha''.symm]\n\n"}
{"name":"List.disjoint_map","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns t : List α\nhf : Function.Injective f\nh : s.Disjoint t\n⊢ (List.map f s).Disjoint (List.map f t)","decl":"/-- The images of disjoint lists under an injective map are disjoint -/\ntheorem disjoint_map {f : α → β} {s t : List α} (hf : Function.Injective f)\n    (h : Disjoint s t) : Disjoint (s.map f) (t.map f) := by\n  rw [← pmap_eq_map _ _ _ (fun _ _ ↦ trivial), ← pmap_eq_map _ _ _ (fun _ _ ↦ trivial)]\n  exact disjoint_pmap _ _ (fun _ _ _ _ h' ↦ hf h') h\n\n"}
{"name":"List.Disjoint.map","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns t : List α\nhf : Function.Injective f\nh : s.Disjoint t\n⊢ (List.map f s).Disjoint (List.map f t)","decl":"alias Disjoint.map := disjoint_map\n\n"}
{"name":"List.Disjoint.of_map","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns t : List α\nh : (List.map f s).Disjoint (List.map f t)\n⊢ s.Disjoint t","decl":"theorem Disjoint.of_map {f : α → β} {s t : List α} (h : Disjoint (s.map f) (t.map f)) :\n    Disjoint s t := fun _a has hat ↦\n  h (mem_map_of_mem f has) (mem_map_of_mem f hat)\n\n"}
{"name":"List.Disjoint.map_iff","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns t : List α\nhf : Function.Injective f\n⊢ Iff ((List.map f s).Disjoint (List.map f t)) (s.Disjoint t)","decl":"theorem Disjoint.map_iff {f : α → β} {s t : List α} (hf : Function.Injective f) :\n    Disjoint (s.map f) (t.map f) ↔ Disjoint s t :=\n  ⟨fun h ↦ h.of_map, fun h ↦ h.map hf⟩\n\n"}
{"name":"List.Perm.disjoint_left","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ l : List α\np : l₁.Perm l₂\n⊢ Iff (l₁.Disjoint l) (l₂.Disjoint l)","decl":"theorem Perm.disjoint_left {l₁ l₂ l : List α} (p : List.Perm l₁ l₂) :\n    Disjoint l₁ l ↔ Disjoint l₂ l := by\n  simp_rw [List.disjoint_left, p.mem_iff]\n\n"}
{"name":"List.Perm.disjoint_right","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ l : List α\np : l₁.Perm l₂\n⊢ Iff (l.Disjoint l₁) (l.Disjoint l₂)","decl":"theorem Perm.disjoint_right {l₁ l₂ l : List α} (p : List.Perm l₁ l₂) :\n    Disjoint l l₁ ↔ Disjoint l l₂ := by\n  simp_rw [List.disjoint_right, p.mem_iff]\n\n"}
{"name":"List.disjoint_reverse_left","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ : List α\n⊢ Iff (l₁.reverse.Disjoint l₂) (l₁.Disjoint l₂)","decl":"@[simp]\ntheorem disjoint_reverse_left {l₁ l₂ : List α} : Disjoint l₁.reverse l₂ ↔ Disjoint l₁ l₂ :=\n  reverse_perm _ |>.disjoint_left\n\n"}
{"name":"List.disjoint_reverse_right","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nl₁ l₂ : List α\n⊢ Iff (l₁.Disjoint l₂.reverse) (l₁.Disjoint l₂)","decl":"@[simp]\ntheorem disjoint_reverse_right {l₁ l₂ : List α} : Disjoint l₁ l₂.reverse ↔ Disjoint l₁ l₂ :=\n  reverse_perm _ |>.disjoint_right\n\n"}
{"name":"List.lookup_graph","module":"Mathlib.Data.List.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : BEq α\ninst✝ : LawfulBEq α\nf : α → β\na : α\nas : List α\nh : Membership.mem as a\n⊢ Eq (List.lookup a (List.map (fun x => { fst := x, snd := f x }) as)) (Option.some (f a))","decl":"lemma lookup_graph (f : α → β) {a : α} {as : List α} (h : a ∈ as) :\n    lookup a (as.map fun x => (x, f x)) = some (f a) := by\n  induction' as with a' as ih\n  · exact (List.not_mem_nil _ h).elim\n  · by_cases ha : a = a'\n    · simp [ha, lookup_cons]\n    · simpa [lookup_cons, beq_false_of_ne ha] using ih (List.mem_of_ne_of_mem ha h)\n\n"}
