{"name":"Path.instSubsingletonPUnitUnit","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.PUnit","initialProofState":"⊢ Subsingleton (Path PUnit.unit PUnit.unit)","decl":"instance : Subsingleton (Path PUnit.unit PUnit.unit) :=\n  ⟨fun x y => by ext⟩\n\n"}
{"name":"FundamentalGroupoid.instSubsingletonHomPUnit","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.PUnit","initialProofState":"x y : FundamentalGroupoid PUnit.{u_1 + 1}\n⊢ Subsingleton (Quiver.Hom x y)","decl":"instance {x y : FundamentalGroupoid PUnit} : Subsingleton (x ⟶ y) := by\n  convert_to Subsingleton (Path.Homotopic.Quotient PUnit.unit PUnit.unit)\n  apply Quotient.instSubsingletonQuotient\n\n"}
{"name":"FundamentalGroupoid.punitEquivDiscretePUnit_inverse","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.PUnit","initialProofState":"⊢ Eq FundamentalGroupoid.punitEquivDiscretePUnit.inverse ((CategoryTheory.Functor.const (CategoryTheory.Discrete PUnit.{v + 1})).obj { as := PUnit.unit })","decl":"/-- Equivalence of groupoids between fundamental groupoid of punit and punit -/\n@[simps]\ndef punitEquivDiscretePUnit : FundamentalGroupoid PUnit.{u + 1} ≌ Discrete PUnit.{v + 1} where\n  functor := Functor.star _\n  inverse := (CategoryTheory.Functor.const _).obj ⟨PUnit.unit⟩\n  unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n  counitIso := Iso.refl _\n\n"}
{"name":"FundamentalGroupoid.punitEquivDiscretePUnit_counitIso","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.PUnit","initialProofState":"⊢ Eq FundamentalGroupoid.punitEquivDiscretePUnit.counitIso (CategoryTheory.Iso.refl (((CategoryTheory.Functor.const (CategoryTheory.Discrete PUnit.{v + 1})).obj { as := PUnit.unit }).comp (CategoryTheory.Functor.star (FundamentalGroupoid PUnit.{u + 1}))))","decl":"/-- Equivalence of groupoids between fundamental groupoid of punit and punit -/\n@[simps]\ndef punitEquivDiscretePUnit : FundamentalGroupoid PUnit.{u + 1} ≌ Discrete PUnit.{v + 1} where\n  functor := Functor.star _\n  inverse := (CategoryTheory.Functor.const _).obj ⟨PUnit.unit⟩\n  unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n  counitIso := Iso.refl _\n\n"}
{"name":"FundamentalGroupoid.punitEquivDiscretePUnit_unitIso","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.PUnit","initialProofState":"⊢ Eq FundamentalGroupoid.punitEquivDiscretePUnit.unitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (FundamentalGroupoid PUnit.{u + 1})).obj x)) @FundamentalGroupoid.punitEquivDiscretePUnit.proof_1)","decl":"/-- Equivalence of groupoids between fundamental groupoid of punit and punit -/\n@[simps]\ndef punitEquivDiscretePUnit : FundamentalGroupoid PUnit.{u + 1} ≌ Discrete PUnit.{v + 1} where\n  functor := Functor.star _\n  inverse := (CategoryTheory.Functor.const _).obj ⟨PUnit.unit⟩\n  unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n  counitIso := Iso.refl _\n\n"}
{"name":"FundamentalGroupoid.punitEquivDiscretePUnit_functor","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.PUnit","initialProofState":"⊢ Eq FundamentalGroupoid.punitEquivDiscretePUnit.functor (CategoryTheory.Functor.star (FundamentalGroupoid PUnit.{u + 1}))","decl":"/-- Equivalence of groupoids between fundamental groupoid of punit and punit -/\n@[simps]\ndef punitEquivDiscretePUnit : FundamentalGroupoid PUnit.{u + 1} ≌ Discrete PUnit.{v + 1} where\n  functor := Functor.star _\n  inverse := (CategoryTheory.Functor.const _).obj ⟨PUnit.unit⟩\n  unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n  counitIso := Iso.refl _\n\n"}
