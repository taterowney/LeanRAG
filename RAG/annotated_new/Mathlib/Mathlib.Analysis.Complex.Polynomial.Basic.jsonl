{"name":"Complex.exists_root","module":"Mathlib.Analysis.Complex.Polynomial.Basic","initialProofState":"f : Polynomial Complex\nhf : LT.lt 0 f.degree\n⊢ Exists fun z => f.IsRoot z","decl":"/-- **Fundamental theorem of algebra**: every non constant complex polynomial\n  has a root -/\ntheorem exists_root {f : ℂ[X]} (hf : 0 < degree f) : ∃ z : ℂ, IsRoot f z := by\n  by_contra! hf'\n  /- Since `f` has no roots, `f⁻¹` is differentiable. And since `f` is a polynomial, it tends to\n  infinity at infinity, thus `f⁻¹` tends to zero at infinity. By Liouville's theorem, `f⁻¹ = 0`. -/\n  have (z : ℂ) : (f.eval z)⁻¹ = 0 :=\n    (f.differentiable.inv hf').apply_eq_of_tendsto_cocompact z <|\n      Metric.cobounded_eq_cocompact (α := ℂ) ▸ (Filter.tendsto_inv₀_cobounded.comp <| by\n        simpa only [tendsto_norm_atTop_iff_cobounded]\n          using f.tendsto_norm_atTop hf tendsto_norm_cobounded_atTop)\n  -- Thus `f = 0`, contradicting the fact that `0 < degree f`.\n  obtain rfl : f = C 0 := Polynomial.funext fun z ↦ inv_injective <| by simp [this]\n  simp at hf\n\n"}
{"name":"Complex.isAlgClosed","module":"Mathlib.Analysis.Complex.Polynomial.Basic","initialProofState":"⊢ IsAlgClosed Complex","decl":"instance isAlgClosed : IsAlgClosed ℂ :=\n  IsAlgClosed.of_exists_root _ fun _p _ hp => Complex.exists_root <| degree_pos_of_irreducible hp\n\n"}
{"name":"Polynomial.Gal.splits_ℚ_ℂ","module":"Mathlib.Analysis.Complex.Polynomial.Basic","initialProofState":"p : Polynomial Rat\n⊢ Fact (Polynomial.Splits (algebraMap Rat Complex) p)","decl":"theorem splits_ℚ_ℂ {p : ℚ[X]} : Fact (p.Splits (algebraMap ℚ ℂ)) :=\n  ⟨IsAlgClosed.splits_codomain p⟩\n\n"}
{"name":"Polynomial.Gal.card_complex_roots_eq_card_real_add_card_not_gal_inv","module":"Mathlib.Analysis.Complex.Polynomial.Basic","initialProofState":"p : Polynomial Rat\n⊢ Eq (p.rootSet Complex).toFinset.card (HAdd.hAdd (p.rootSet Real).toFinset.card ((Polynomial.Gal.galActionHom p Complex) ((Polynomial.Gal.restrict p Complex) (AlgEquiv.restrictScalars Rat Complex.conjAe))).support.card)","decl":"/-- The number of complex roots equals the number of real roots plus\n    the number of roots not fixed by complex conjugation (i.e. with some imaginary component). -/\ntheorem card_complex_roots_eq_card_real_add_card_not_gal_inv (p : ℚ[X]) :\n    (p.rootSet ℂ).toFinset.card =\n      (p.rootSet ℝ).toFinset.card +\n        (galActionHom p ℂ (restrict p ℂ\n        (AlgEquiv.restrictScalars ℚ Complex.conjAe))).support.card := by\n  by_cases hp : p = 0\n  · haveI : IsEmpty (p.rootSet ℂ) := by rw [hp, rootSet_zero]; infer_instance\n    simp_rw [(galActionHom p ℂ _).support.eq_empty_of_isEmpty, hp, rootSet_zero,\n      Set.toFinset_empty, Finset.card_empty]\n  have inj : Function.Injective (IsScalarTower.toAlgHom ℚ ℝ ℂ) := (algebraMap ℝ ℂ).injective\n  rw [← Finset.card_image_of_injective _ Subtype.coe_injective, ←\n    Finset.card_image_of_injective _ inj]\n  let a : Finset ℂ := ?_\n  on_goal 1 => let b : Finset ℂ := ?_\n  on_goal 1 => let c : Finset ℂ := ?_\n  -- Porting note: was\n  --   change a.card = b.card + c.card\n  suffices a.card = b.card + c.card by exact this\n  have ha : ∀ z : ℂ, z ∈ a ↔ aeval z p = 0 := by\n    intro z; rw [Set.mem_toFinset, mem_rootSet_of_ne hp]\n  have hb : ∀ z : ℂ, z ∈ b ↔ aeval z p = 0 ∧ z.im = 0 := by\n    intro z\n    simp_rw [b, Finset.mem_image, Set.mem_toFinset, mem_rootSet_of_ne hp]\n    constructor\n    · rintro ⟨w, hw, rfl⟩\n      exact ⟨by rw [aeval_algHom_apply, hw, map_zero], rfl⟩\n    · rintro ⟨hz1, hz2⟩\n      have key : IsScalarTower.toAlgHom ℚ ℝ ℂ z.re = z := by\n        ext\n        · rfl\n        · rw [hz2]; rfl\n      exact ⟨z.re, inj (by rwa [← aeval_algHom_apply, key, map_zero]), key⟩\n  have hc0 :\n    ∀ w : p.rootSet ℂ, galActionHom p ℂ (restrict p ℂ (Complex.conjAe.restrictScalars ℚ)) w = w ↔\n        w.val.im = 0 := by\n    intro w\n    rw [Subtype.ext_iff, galActionHom_restrict]\n    exact Complex.conj_eq_iff_im\n  have hc : ∀ z : ℂ, z ∈ c ↔ aeval z p = 0 ∧ z.im ≠ 0 := by\n    intro z\n    simp_rw [c, Finset.mem_image]\n    constructor\n    · rintro ⟨w, hw, rfl⟩\n      exact ⟨(mem_rootSet.mp w.2).2, mt (hc0 w).mpr (Equiv.Perm.mem_support.mp hw)⟩\n    · rintro ⟨hz1, hz2⟩\n      exact ⟨⟨z, mem_rootSet.mpr ⟨hp, hz1⟩⟩, Equiv.Perm.mem_support.mpr (mt (hc0 _).mp hz2), rfl⟩\n  rw [← Finset.card_union_of_disjoint]\n  · apply congr_arg Finset.card\n    simp_rw [Finset.ext_iff, Finset.mem_union, ha, hb, hc]\n    tauto\n  · rw [Finset.disjoint_left]\n    intro z\n    rw [hb, hc]\n    tauto\n\n"}
{"name":"Polynomial.Gal.galActionHom_bijective_of_prime_degree","module":"Mathlib.Analysis.Complex.Polynomial.Basic","initialProofState":"p : Polynomial Rat\np_irr : Irreducible p\np_deg : Nat.Prime p.natDegree\np_roots : Eq (Fintype.card ↑(p.rootSet Complex)) (HAdd.hAdd (Fintype.card ↑(p.rootSet Real)) 2)\n⊢ Function.Bijective ⇑(Polynomial.Gal.galActionHom p Complex)","decl":"/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem galActionHom_bijective_of_prime_degree {p : ℚ[X]} (p_irr : Irreducible p)\n    (p_deg : p.natDegree.Prime)\n    (p_roots : Fintype.card (p.rootSet ℂ) = Fintype.card (p.rootSet ℝ) + 2) :\n    Function.Bijective (galActionHom p ℂ) := by\n  classical\n  have h1 : Fintype.card (p.rootSet ℂ) = p.natDegree := by\n    simp_rw [rootSet_def, Finset.coe_sort_coe, Fintype.card_coe]\n    rw [Multiset.toFinset_card_of_nodup, ← natDegree_eq_card_roots]\n    · exact IsAlgClosed.splits_codomain p\n    · exact nodup_roots ((separable_map (algebraMap ℚ ℂ)).mpr p_irr.separable)\n  let conj' := restrict p ℂ (Complex.conjAe.restrictScalars ℚ)\n  refine\n    ⟨galActionHom_injective p ℂ, fun x =>\n      (congr_arg (x ∈ ·) (show (galActionHom p ℂ).range = ⊤ from ?_)).mpr\n        (Subgroup.mem_top x)⟩\n  apply Equiv.Perm.subgroup_eq_top_of_swap_mem\n  · rwa [h1]\n  · rw [h1]\n    simpa only [Fintype.card_eq_nat_card,\n      Nat.card_congr (MonoidHom.ofInjective (galActionHom_injective p ℂ)).toEquiv.symm]\n      using prime_degree_dvd_card p_irr p_deg\n  · exact ⟨conj', rfl⟩\n  · rw [← Equiv.Perm.card_support_eq_two]\n    apply Nat.add_left_cancel\n    rw [← p_roots, ← Set.toFinset_card (rootSet p ℝ), ← Set.toFinset_card (rootSet p ℂ)]\n    exact (card_complex_roots_eq_card_real_add_card_not_gal_inv p).symm\n\n"}
{"name":"Polynomial.Gal.galActionHom_bijective_of_prime_degree'","module":"Mathlib.Analysis.Complex.Polynomial.Basic","initialProofState":"p : Polynomial Rat\np_irr : Irreducible p\np_deg : Nat.Prime p.natDegree\np_roots1 : LE.le (HAdd.hAdd (Fintype.card ↑(p.rootSet Real)) 1) (Fintype.card ↑(p.rootSet Complex))\np_roots2 : LE.le (Fintype.card ↑(p.rootSet Complex)) (HAdd.hAdd (Fintype.card ↑(p.rootSet Real)) 3)\n⊢ Function.Bijective ⇑(Polynomial.Gal.galActionHom p Complex)","decl":"/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem galActionHom_bijective_of_prime_degree' {p : ℚ[X]} (p_irr : Irreducible p)\n    (p_deg : p.natDegree.Prime)\n    (p_roots1 : Fintype.card (p.rootSet ℝ) + 1 ≤ Fintype.card (p.rootSet ℂ))\n    (p_roots2 : Fintype.card (p.rootSet ℂ) ≤ Fintype.card (p.rootSet ℝ) + 3) :\n    Function.Bijective (galActionHom p ℂ) := by\n  apply galActionHom_bijective_of_prime_degree p_irr p_deg\n  let n := (galActionHom p ℂ (restrict p ℂ (Complex.conjAe.restrictScalars ℚ))).support.card\n  have hn : 2 ∣ n :=\n    Equiv.Perm.two_dvd_card_support\n      (by\n         rw [← MonoidHom.map_pow, ← MonoidHom.map_pow,\n          show AlgEquiv.restrictScalars ℚ Complex.conjAe ^ 2 = 1 from\n            AlgEquiv.ext Complex.conj_conj,\n          MonoidHom.map_one, MonoidHom.map_one])\n  have key := card_complex_roots_eq_card_real_add_card_not_gal_inv p\n  simp_rw [Set.toFinset_card] at key\n  omega\n\n"}
{"name":"Polynomial.mul_star_dvd_of_aeval_eq_zero_im_ne_zero","module":"Mathlib.Analysis.Complex.Polynomial.Basic","initialProofState":"p : Polynomial Real\nz : Complex\nh0 : Eq ((Polynomial.aeval z) p) 0\nhz : Ne z.im 0\n⊢ Dvd.dvd (HMul.hMul (HSub.hSub Polynomial.X (Polynomial.C ((starRingEnd Complex) z))) (HSub.hSub Polynomial.X (Polynomial.C z))) (Polynomial.map (algebraMap Real Complex) p)","decl":"lemma Polynomial.mul_star_dvd_of_aeval_eq_zero_im_ne_zero (p : ℝ[X]) {z : ℂ} (h0 : aeval z p = 0)\n    (hz : z.im ≠ 0) : (X - C ((starRingEnd ℂ) z)) * (X - C z) ∣ map (algebraMap ℝ ℂ) p := by\n  apply IsCoprime.mul_dvd\n  · exact isCoprime_X_sub_C_of_isUnit_sub <| .mk0 _ <| sub_ne_zero.2 <| mt conj_eq_iff_im.1 hz\n  · simpa [dvd_iff_isRoot, aeval_conj]\n  · simpa [dvd_iff_isRoot]\n\n"}
{"name":"Polynomial.quadratic_dvd_of_aeval_eq_zero_im_ne_zero","module":"Mathlib.Analysis.Complex.Polynomial.Basic","initialProofState":"p : Polynomial Real\nz : Complex\nh0 : Eq ((Polynomial.aeval z) p) 0\nhz : Ne z.im 0\n⊢ Dvd.dvd (HAdd.hAdd (HSub.hSub (HPow.hPow Polynomial.X 2) (HMul.hMul (Polynomial.C (HMul.hMul 2 z.re)) Polynomial.X)) (Polynomial.C (HPow.hPow (Norm.norm z) 2))) p","decl":"/-- If `z` is a non-real complex root of a real polynomial,\nthen `p` is divisible by a quadratic polynomial. -/\nlemma Polynomial.quadratic_dvd_of_aeval_eq_zero_im_ne_zero (p : ℝ[X]) {z : ℂ} (h0 : aeval z p = 0)\n    (hz : z.im ≠ 0) : X ^ 2 - C (2 * z.re) * X + C (‖z‖ ^ 2) ∣ p := by\n  rw [← map_dvd_map' (algebraMap ℝ ℂ)]\n  convert p.mul_star_dvd_of_aeval_eq_zero_im_ne_zero h0 hz\n  calc\n    map (algebraMap ℝ ℂ) (X ^ 2 - C (2 * z.re) * X + C (‖z‖ ^ 2))\n    _ = X ^ 2 - C (↑(2 * z.re) : ℂ) * X + C (‖z‖ ^ 2 : ℂ) := by simp\n    _ = (X - C (conj z)) * (X - C z) := by\n      rw [← add_conj, map_add, ← mul_conj', map_mul]\n      ring\n\n"}
{"name":"Irreducible.degree_le_two","module":"Mathlib.Analysis.Complex.Polynomial.Basic","initialProofState":"p : Polynomial Real\nhp : Irreducible p\n⊢ LE.le p.degree 2","decl":"/-- An irreducible real polynomial has degree at most two. -/\nlemma Irreducible.degree_le_two {p : ℝ[X]} (hp : Irreducible p) : degree p ≤ 2 := by\n  obtain ⟨z, hz⟩ : ∃ z : ℂ, aeval z p = 0 :=\n    IsAlgClosed.exists_aeval_eq_zero _ p (degree_pos_of_irreducible hp).ne'\n  cases eq_or_ne z.im 0 with\n  | inl hz0 =>\n    lift z to ℝ using hz0\n    erw [aeval_ofReal, RCLike.ofReal_eq_zero] at hz\n    exact (degree_eq_one_of_irreducible_of_root hp hz).trans_le one_le_two\n  | inr hz0 =>\n    obtain ⟨q, rfl⟩ := p.quadratic_dvd_of_aeval_eq_zero_im_ne_zero hz hz0\n    have hd : degree (X ^ 2 - C (2 * z.re) * X + C (‖z‖ ^ 2)) = 2 := by\n      compute_degree!\n    have hq : IsUnit q := by\n      refine (of_irreducible_mul hp).resolve_left (mt isUnit_iff_degree_eq_zero.1 ?_)\n      rw [hd]\n      exact two_ne_zero\n    refine (degree_mul_le _ _).trans_eq ?_\n    rwa [isUnit_iff_degree_eq_zero.1 hq, add_zero]\n\n"}
{"name":"Irreducible.natDegree_le_two","module":"Mathlib.Analysis.Complex.Polynomial.Basic","initialProofState":"p : Polynomial Real\nhp : Irreducible p\n⊢ LE.le p.natDegree 2","decl":"/-- An irreducible real polynomial has natural degree at most two. -/\nlemma Irreducible.natDegree_le_two {p : ℝ[X]} (hp : Irreducible p) : natDegree p ≤ 2 :=\n  natDegree_le_iff_degree_le.2 hp.degree_le_two\n"}
