{"name":"BoxIntegral.le_hasIntegralVertices_of_isBounded","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\ninst✝ : Finite ι\ns : Set (ι → Real)\nh : Bornology.IsBounded s\n⊢ Exists fun B => And (BoxIntegral.hasIntegralVertices B) (LE.le s ↑B)","decl":"/-- Any bounded set is contained in a `BoxIntegral.Box` with integral vertices. -/\ntheorem BoxIntegral.le_hasIntegralVertices_of_isBounded [Finite ι] {s : Set (ι → ℝ)}\n    (h : IsBounded s) :\n    ∃ B : BoxIntegral.Box ι, hasIntegralVertices B ∧ s ≤ B := by\n  have := Fintype.ofFinite ι\n  obtain ⟨R, hR₁, hR₂⟩ := IsBounded.subset_ball_lt h 0 0\n  let C : ℕ := ⌈R⌉₊\n  have hC := Nat.ceil_pos.mpr hR₁\n  let I : Box ι := Box.mk (fun _ ↦ - C) (fun _ ↦ C )\n    (fun _ ↦ by simp [C, neg_lt_self_iff, Nat.cast_pos, hC])\n  refine ⟨I, ⟨fun _ ↦ - C, fun _ ↦ C, fun i ↦ (Int.cast_neg_natCast C).symm, fun _ ↦ rfl⟩,\n    le_trans hR₂ ?_⟩\n  suffices Metric.ball (0 : ι → ℝ) C ≤ I from\n    le_trans (Metric.ball_subset_ball (Nat.le_ceil R)) this\n  intro x hx\n  simp_rw [C, mem_ball_zero_iff, pi_norm_lt_iff (Nat.cast_pos.mpr hC),\n    Real.norm_eq_abs, abs_lt] at hx\n  exact fun i ↦ ⟨(hx i).1, le_of_lt (hx i).2⟩\n\n"}
{"name":"BoxIntegral.unitPartition.box_lower","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝ : NeZero n\nν : ι → Int\n⊢ Eq (BoxIntegral.unitPartition.box n ν).lower fun i => HDiv.hDiv ↑(ν i) ↑n","decl":"@[simp]\ntheorem box_lower [NeZero n] (ν : ι → ℤ) :\n    (box n ν).lower = fun i ↦ (ν i / n : ℝ) := rfl\n\n"}
{"name":"BoxIntegral.unitPartition.box_upper","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝ : NeZero n\nν : ι → Int\n⊢ Eq (BoxIntegral.unitPartition.box n ν).upper fun i => HDiv.hDiv (HAdd.hAdd (↑(ν i)) 1) ↑n","decl":"@[simp]\ntheorem box_upper [NeZero n] (ν : ι → ℤ) :\n    (box n ν).upper = fun i ↦ ((ν i + 1)/ n : ℝ) := rfl\n\n"}
{"name":"BoxIntegral.unitPartition.mem_box_iff","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝ : NeZero n\nν : ι → Int\nx : ι → Real\n⊢ Iff (Membership.mem (BoxIntegral.unitPartition.box n ν) x) (∀ (i : ι), And (LT.lt (HDiv.hDiv ↑(ν i) ↑n) (x i)) (LE.le (x i) (HDiv.hDiv (HAdd.hAdd (↑(ν i)) 1) ↑n)))","decl":"variable {n} in\n@[simp]\ntheorem mem_box_iff [NeZero n] {ν : ι → ℤ} {x : ι → ℝ} :\n    x ∈ box n ν ↔ ∀ i, ν i / n < x i ∧ x i ≤ (ν i + 1) / n := by\n  simp_rw [Box.mem_def, box, Set.mem_Ioc]\n\n"}
{"name":"BoxIntegral.unitPartition.mem_box_iff'","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝ : NeZero n\nν : ι → Int\nx : ι → Real\n⊢ Iff (Membership.mem (BoxIntegral.unitPartition.box n ν) x) (∀ (i : ι), And (LT.lt (↑(ν i)) (HMul.hMul (↑n) (x i))) (LE.le (HMul.hMul (↑n) (x i)) (HAdd.hAdd (↑(ν i)) 1)))","decl":"variable {n} in\ntheorem mem_box_iff' [NeZero n] {ν : ι → ℤ} {x : ι → ℝ} :\n    x ∈ box n ν ↔ ∀ i, ν i < n * x i ∧ n * x i ≤ ν i + 1 := by\n  have h : 0 < (n : ℝ) := Nat.cast_pos.mpr <| n.pos_of_neZero\n  simp_rw [mem_box_iff, ← _root_.le_div_iff₀' h, ← div_lt_iff₀' h]\n\n"}
{"name":"BoxIntegral.unitPartition.tag_apply","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\nν : ι → Int\ni : ι\n⊢ Eq (BoxIntegral.unitPartition.tag n ν i) (HDiv.hDiv (HAdd.hAdd (↑(ν i)) 1) ↑n)","decl":"@[simp]\ntheorem tag_apply (ν : ι → ℤ) (i : ι) : tag n ν i = (ν i + 1) / n := rfl\n\n"}
{"name":"BoxIntegral.unitPartition.tag_injective","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝ : NeZero n\n⊢ Function.Injective fun ν => BoxIntegral.unitPartition.tag n ν","decl":"theorem tag_injective : Function.Injective (fun ν : ι → ℤ ↦ tag n ν) := by\n  refine fun _ _ h ↦ funext_iff.mpr fun i ↦ ?_\n  have := congr_arg (fun x ↦ x i) h\n  simp_rw [tag_apply, div_left_inj' (c := (n : ℝ)) (Nat.cast_ne_zero.mpr (NeZero.ne n)),\n    add_left_inj, Int.cast_inj] at this\n  exact this\n\n"}
{"name":"BoxIntegral.unitPartition.tag_mem","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝ : NeZero n\nν : ι → Int\n⊢ Membership.mem (BoxIntegral.unitPartition.box n ν) (BoxIntegral.unitPartition.tag n ν)","decl":"theorem tag_mem (ν : ι → ℤ) :\n    tag n ν ∈ box n ν := by\n  refine mem_box_iff.mpr fun _ ↦ ?_\n  rw [tag, add_div]\n  have h : 0 < (n : ℝ) := Nat.cast_pos.mpr <| n.pos_of_neZero\n  exact ⟨lt_add_of_pos_right _ (by positivity), le_rfl⟩\n\n"}
{"name":"BoxIntegral.unitPartition.index_apply","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nm : Nat\nx : ι → Real\ni : ι\n⊢ Eq (BoxIntegral.unitPartition.index m x i) (HSub.hSub (Int.ceil (HMul.hMul (↑m) (x i))) 1)","decl":"@[simp]\ntheorem index_apply (m : ℕ) {x : ι → ℝ} (i : ι) :\n    index m x i = ⌈m * x i⌉ - 1 := rfl\n\n"}
{"name":"BoxIntegral.unitPartition.mem_box_iff_index","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝ : NeZero n\nx : ι → Real\nν : ι → Int\n⊢ Iff (Membership.mem (BoxIntegral.unitPartition.box n ν) x) (Eq (BoxIntegral.unitPartition.index n x) ν)","decl":"variable {n} in\ntheorem mem_box_iff_index {x : ι → ℝ} {ν : ι → ℤ} :\n    x ∈ box n ν ↔ index n x = ν := by\n  simp_rw [mem_box_iff', funext_iff, index_apply, sub_eq_iff_eq_add, Int.ceil_eq_iff,\n    Int.cast_add, Int.cast_one, add_sub_cancel_right]\n\n"}
{"name":"BoxIntegral.unitPartition.index_tag","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝ : NeZero n\nν : ι → Int\n⊢ Eq (BoxIntegral.unitPartition.index n (BoxIntegral.unitPartition.tag n ν)) ν","decl":"@[simp]\ntheorem index_tag (ν : ι → ℤ) :\n    index n (tag n ν) = ν := mem_box_iff_index.mp (tag_mem n ν)\n\n"}
{"name":"BoxIntegral.unitPartition.disjoint","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝ : NeZero n\nν ν' : ι → Int\n⊢ Iff (Ne ν ν') (Disjoint ↑(BoxIntegral.unitPartition.box n ν) ↑(BoxIntegral.unitPartition.box n ν'))","decl":"variable {n} in\ntheorem disjoint {ν ν' : ι → ℤ} :\n    ν ≠ ν' ↔ Disjoint (box n ν).toSet (box n ν').toSet := by\n  rw [not_iff_comm, Set.not_disjoint_iff]\n  refine ⟨fun ⟨x, hx, hx'⟩ ↦ ?_, fun h ↦ ⟨tag n ν, tag_mem n ν, h ▸ tag_mem n ν⟩⟩\n  rw [← mem_box_iff_index.mp hx, ← mem_box_iff_index.mp hx']\n\n"}
{"name":"BoxIntegral.unitPartition.box_injective","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝ : NeZero n\n⊢ Function.Injective fun ν => BoxIntegral.unitPartition.box n ν","decl":"theorem box_injective : Function.Injective (fun ν : ι → ℤ ↦ box n ν) := by\n  intro _ _ h\n  contrapose! h\n  exact Box.ne_of_disjoint_coe (disjoint.mp h)\n\n"}
{"name":"BoxIntegral.unitPartition.box.upper_sub_lower","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝ : NeZero n\nν : ι → Int\ni : ι\n⊢ Eq (HSub.hSub ((BoxIntegral.unitPartition.box n ν).upper i) ((BoxIntegral.unitPartition.box n ν).lower i)) (HDiv.hDiv 1 ↑n)","decl":"lemma box.upper_sub_lower (ν : ι → ℤ) (i : ι) :\n    (box n ν ).upper i - (box n ν).lower i = 1 / n := by\n  simp_rw [box, add_div, add_sub_cancel_left]\n\n"}
{"name":"BoxIntegral.unitPartition.diam_boxIcc","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝¹ : NeZero n\ninst✝ : Fintype ι\nν : ι → Int\n⊢ LE.le (Metric.diam (BoxIntegral.Box.Icc (BoxIntegral.unitPartition.box n ν))) (HDiv.hDiv 1 ↑n)","decl":"theorem diam_boxIcc (ν : ι → ℤ) :\n    Metric.diam (Box.Icc (box n ν)) ≤ 1 / n := by\n  rw [BoxIntegral.Box.Icc_eq_pi]\n  refine ENNReal.toReal_le_of_le_ofReal (by positivity) <| EMetric.diam_pi_le_of_le (fun i ↦ ?_)\n  simp_rw [Real.ediam_Icc, box.upper_sub_lower, le_rfl]\n\n"}
{"name":"BoxIntegral.unitPartition.volume_box","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝¹ : NeZero n\ninst✝ : Fintype ι\nν : ι → Int\n⊢ Eq (MeasureTheory.MeasureSpace.volume ↑(BoxIntegral.unitPartition.box n ν)) (HDiv.hDiv 1 (HPow.hPow (↑n) (Fintype.card ι)))","decl":"@[simp]\ntheorem volume_box (ν : ι → ℤ) :\n    volume (box n ν : Set (ι → ℝ)) = 1 / n ^ card ι := by\n  simp_rw [volume_pi, BoxIntegral.Box.coe_eq_pi, Measure.pi_pi, Real.volume_Ioc,\n    box.upper_sub_lower, Finset.prod_const, ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr\n    n.pos_of_neZero), ENNReal.ofReal_one, ENNReal.ofReal_natCast, one_div, ENNReal.inv_pow,\n    Finset.card_univ]\n\n"}
{"name":"BoxIntegral.unitPartition.setFinite_index","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝¹ : NeZero n\ninst✝ : Fintype ι\ns : Set (ι → Real)\nhs₁ : MeasureTheory.NullMeasurableSet s MeasureTheory.MeasureSpace.volume\nhs₂ : Ne (MeasureTheory.MeasureSpace.volume s) Top.top\n⊢ (setOf fun ν => HasSubset.Subset (↑(BoxIntegral.unitPartition.box n ν)) s).Finite","decl":"theorem setFinite_index {s : Set (ι → ℝ)} (hs₁ : NullMeasurableSet s) (hs₂ : volume s ≠ ⊤) :\n    Set.Finite {ν : ι → ℤ | ↑(box n ν) ⊆ s} := by\n  refine (Measure.finite_const_le_meas_of_disjoint_iUnion₀ volume (ε := 1 / n ^ card ι)\n    (by norm_num) (As := fun ν : ι → ℤ ↦ (box n ν) ∩ s) (fun ν ↦ ?_) (fun _ _ h ↦ ?_) ?_).subset\n      (fun _ hν ↦ ?_)\n  · refine NullMeasurableSet.inter ?_ hs₁\n    exact (box n ν).measurableSet_coe.nullMeasurableSet\n  · exact ((Disjoint.inter_right _ (disjoint.mp h)).inter_left _ ).aedisjoint\n  · exact lt_top_iff_ne_top.mp <| measure_lt_top_of_subset\n      (by simp only [Set.iUnion_subset_iff, Set.inter_subset_right, implies_true]) hs₂\n  · rw [Set.mem_setOf, Set.inter_eq_self_of_subset_left hν, volume_box]\n\n"}
{"name":"BoxIntegral.unitPartition.mem_admissibleIndex_iff","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝¹ : NeZero n\ninst✝ : Fintype ι\nB : BoxIntegral.Box ι\nν : ι → Int\n⊢ Iff (Membership.mem (BoxIntegral.unitPartition.admissibleIndex n B) ν) (LE.le (BoxIntegral.unitPartition.box n ν) B)","decl":"variable {n} in\ntheorem mem_admissibleIndex_iff {B : Box ι} {ν : ι → ℤ} :\n    ν ∈ admissibleIndex n B ↔ box n ν ≤ B := by\n  rw [admissibleIndex, Set.Finite.mem_toFinset, Set.mem_setOf_eq, Box.coe_subset_coe]\n\n"}
{"name":"BoxIntegral.unitPartition.mem_prepartition_iff","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝¹ : NeZero n\ninst✝ : Fintype ι\nB I : BoxIntegral.Box ι\n⊢ Iff (Membership.mem (BoxIntegral.unitPartition.prepartition n B) I) (Exists fun ν => And (Membership.mem (BoxIntegral.unitPartition.admissibleIndex n B) ν) (Eq (BoxIntegral.unitPartition.box n ν) I))","decl":"variable {n} in\n@[simp]\ntheorem mem_prepartition_iff {B I : Box ι} :\n    I ∈ prepartition n B ↔ ∃ ν ∈ admissibleIndex n B, box n ν = I := by\n  classical\n  rw [prepartition, TaggedPrepartition.mem_mk, Prepartition.mem_mk, Finset.mem_image]\n\n"}
{"name":"BoxIntegral.unitPartition.mem_prepartition_boxes_iff","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝¹ : NeZero n\ninst✝ : Fintype ι\nB I : BoxIntegral.Box ι\n⊢ Iff (Membership.mem (BoxIntegral.unitPartition.prepartition n B).boxes I) (Exists fun ν => And (Membership.mem (BoxIntegral.unitPartition.admissibleIndex n B) ν) (Eq (BoxIntegral.unitPartition.box n ν) I))","decl":"variable {n} in\ntheorem mem_prepartition_boxes_iff {B I : Box ι} :\n    I ∈ (prepartition n B).boxes ↔ ∃ ν ∈ admissibleIndex n B, box n ν = I :=\n  mem_prepartition_iff\n\n"}
{"name":"BoxIntegral.unitPartition.prepartition_tag","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝¹ : NeZero n\ninst✝ : Fintype ι\nν : ι → Int\nB : BoxIntegral.Box ι\nhν : Membership.mem (BoxIntegral.unitPartition.admissibleIndex n B) ν\n⊢ Eq ((BoxIntegral.unitPartition.prepartition n B).tag (BoxIntegral.unitPartition.box n ν)) (BoxIntegral.unitPartition.tag n ν)","decl":"theorem prepartition_tag {ν : ι → ℤ} {B : Box ι} (hν : ν ∈ admissibleIndex n B) :\n    (prepartition n B).tag (box n ν) = tag n ν := by\n  dsimp only [prepartition]\n  have h : ∃ ν' ∈ admissibleIndex n B, box n ν = box n ν' := ⟨ν, hν, rfl⟩\n  rw [dif_pos h, (tag_injective n).eq_iff, ← (box_injective n).eq_iff]\n  exact h.choose_spec.2.symm\n\n"}
{"name":"BoxIntegral.unitPartition.box_index_tag_eq_self","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝¹ : NeZero n\ninst✝ : Fintype ι\nB I : BoxIntegral.Box ι\nhI : Membership.mem (BoxIntegral.unitPartition.prepartition n B).boxes I\n⊢ Eq (BoxIntegral.unitPartition.box n (BoxIntegral.unitPartition.index n ((BoxIntegral.unitPartition.prepartition n B).tag I))) I","decl":"theorem box_index_tag_eq_self {B I : Box ι} (hI : I ∈ (prepartition n B).boxes) :\n    box n (index n ((prepartition n B).tag I)) = I := by\n  obtain ⟨ν, hν, rfl⟩ := mem_prepartition_boxes_iff.mp hI\n  rw [prepartition_tag n hν, index_tag]\n\n"}
{"name":"BoxIntegral.unitPartition.prepartition_isHenstock","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝¹ : NeZero n\ninst✝ : Fintype ι\nB : BoxIntegral.Box ι\n⊢ (BoxIntegral.unitPartition.prepartition n B).IsHenstock","decl":"theorem prepartition_isHenstock (B : Box ι) :\n    (prepartition n B).IsHenstock := by\n  intro _ hI\n  obtain ⟨ν, hν, rfl⟩ := mem_prepartition_iff.mp hI\n  rw [prepartition_tag n hν]\n  exact Box.coe_subset_Icc (tag_mem _ _)\n\n"}
{"name":"BoxIntegral.unitPartition.prepartition_isSubordinate","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝¹ : NeZero n\ninst✝ : Fintype ι\nB : BoxIntegral.Box ι\nr : Real\nhr : LT.lt 0 r\nhn : LE.le (HDiv.hDiv 1 ↑n) r\n⊢ (BoxIntegral.unitPartition.prepartition n B).IsSubordinate fun x => ⟨r, hr⟩","decl":"theorem prepartition_isSubordinate (B : Box ι) {r : ℝ} (hr : 0 < r) (hn : 1 / n ≤ r) :\n    (prepartition n B).IsSubordinate (fun _ ↦ ⟨r, hr⟩) := by\n  intro _ hI\n  obtain ⟨ν, hν, rfl⟩ := mem_prepartition_iff.mp hI\n  refine fun _ h ↦ le_trans (Metric.dist_le_diam_of_mem (Box.isBounded_Icc _) h ?_) ?_\n  · rw [prepartition_tag n hν]\n    exact Box.coe_subset_Icc (tag_mem _ _)\n  · exact le_trans (diam_boxIcc n ν) hn\n\n"}
{"name":"BoxIntegral.unitPartition.mem_admissibleIndex_of_mem_box","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝¹ : NeZero n\ninst✝ : Fintype ι\nB : BoxIntegral.Box ι\nhB : BoxIntegral.hasIntegralVertices B\nx : ι → Real\nhx : Membership.mem B x\n⊢ Membership.mem (BoxIntegral.unitPartition.admissibleIndex n B) (BoxIntegral.unitPartition.index n x)","decl":"/-- If `B : BoxIntegral.Box` has integral vertices and contains the point `x`, then the index of\n`x` is admissible for `B`. -/\ntheorem mem_admissibleIndex_of_mem_box {B : Box ι} (hB : hasIntegralVertices B) {x : ι → ℝ}\n    (hx : x ∈ B) : index n x ∈ admissibleIndex n B := by\n  obtain ⟨l, u, hl, hu⟩ := hB\n  simp_rw [mem_admissibleIndex_iff, Box.le_iff_bounds, box_lower, box_upper, Pi.le_def,\n    index_apply, hl, hu, ← forall_and]\n  push_cast\n  refine fun i ↦ ⟨?_, ?_⟩\n  · exact (mem_admissibleIndex_of_mem_box_aux₁ n (x i) (l i)).mp ((hl i) ▸ (hx i).1)\n  · exact (mem_admissibleIndex_of_mem_box_aux₂ n (x i) (u i)).mp ((hu i) ▸ (hx i).2)\n\n"}
{"name":"BoxIntegral.unitPartition.prepartition_isPartition","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝¹ : NeZero n\ninst✝ : Fintype ι\nB : BoxIntegral.Box ι\nhB : BoxIntegral.hasIntegralVertices B\n⊢ (BoxIntegral.unitPartition.prepartition n B).IsPartition","decl":"/-- If `B : BoxIntegral.Box` has integral vertices, then `prepartition n B` is a partition of\n`B`. -/\ntheorem prepartition_isPartition {B : Box ι} (hB : hasIntegralVertices B) :\n    (prepartition n B).IsPartition := by\n  refine fun x hx ↦ ⟨box n (index n x), ?_, mem_box_iff_index.mpr rfl⟩\n  rw [TaggedPrepartition.mem_toPrepartition, mem_prepartition_iff]\n  exact ⟨index n x, mem_admissibleIndex_of_mem_box n hB hx, rfl⟩\n\n"}
{"name":"BoxIntegral.unitPartition.mem_smul_span_iff","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝¹ : NeZero n\ninst✝ : Fintype ι\nv : ι → Real\n⊢ Iff (Membership.mem (HSMul.hSMul (Inv.inv ↑n) (Submodule.span Int (Set.range ⇑(Pi.basisFun Real ι)))) v) (∀ (i : ι), Membership.mem (Set.range ⇑(algebraMap Int Real)) (HMul.hMul (↑n) (v i)))","decl":"variable {n} in\ntheorem mem_smul_span_iff {v : ι → ℝ} :\n    v ∈ (n : ℝ)⁻¹ • L ↔ ∀ i, n * v i ∈ Set.range (algebraMap ℤ ℝ) := by\n  rw [ZSpan.smul _ (inv_ne_zero (NeZero.ne _)), Basis.mem_span_iff_repr_mem]\n  simp_rw [Basis.repr_isUnitSMul, Pi.basisFun_repr, Units.smul_def, Units.val_inv_eq_inv_val,\n    IsUnit.unit_spec, inv_inv, smul_eq_mul]\n\n"}
{"name":"BoxIntegral.unitPartition.tag_mem_smul_span","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝¹ : NeZero n\ninst✝ : Fintype ι\nν : ι → Int\n⊢ Membership.mem (HSMul.hSMul (Inv.inv ↑n) (Submodule.span Int (Set.range ⇑(Pi.basisFun Real ι)))) (BoxIntegral.unitPartition.tag n ν)","decl":"theorem tag_mem_smul_span (ν : ι → ℤ) :\n    tag n ν ∈ (n : ℝ)⁻¹ • L := by\n  refine mem_smul_span_iff.mpr fun i ↦ ⟨ν i + 1, ?_⟩\n  rw [tag_apply, div_eq_inv_mul, ← mul_assoc, mul_inv_cancel_of_invertible, one_mul, map_add,\n    map_one, eq_intCast]\n\n"}
{"name":"BoxIntegral.unitPartition.tag_index_eq_self_of_mem_smul_span","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝¹ : NeZero n\ninst✝ : Fintype ι\nx : ι → Real\nhx : Membership.mem (HSMul.hSMul (Inv.inv ↑n) (Submodule.span Int (Set.range ⇑(Pi.basisFun Real ι)))) x\n⊢ Eq (BoxIntegral.unitPartition.tag n (BoxIntegral.unitPartition.index n x)) x","decl":"theorem tag_index_eq_self_of_mem_smul_span {x : ι → ℝ} (hx : x ∈ (n : ℝ)⁻¹ • L) :\n    tag n (index n x) = x := by\n  rw [mem_smul_span_iff] at hx\n  ext i\n  obtain ⟨a, ha⟩ : ∃ a : ℤ, a = n * x i := hx i\n  rwa [tag_apply, index_apply, Int.cast_sub, Int.cast_one, sub_add_cancel, ← ha, Int.ceil_intCast,\n    div_eq_iff (NeZero.ne _), mul_comm]\n\n"}
{"name":"BoxIntegral.unitPartition.eq_of_mem_smul_span_of_index_eq_index","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝¹ : NeZero n\ninst✝ : Fintype ι\nx y : ι → Real\nhx : Membership.mem (HSMul.hSMul (Inv.inv ↑n) (Submodule.span Int (Set.range ⇑(Pi.basisFun Real ι)))) x\nhy : Membership.mem (HSMul.hSMul (Inv.inv ↑n) (Submodule.span Int (Set.range ⇑(Pi.basisFun Real ι)))) y\nh : Eq (BoxIntegral.unitPartition.index n x) (BoxIntegral.unitPartition.index n y)\n⊢ Eq x y","decl":"theorem eq_of_mem_smul_span_of_index_eq_index {x y : ι → ℝ} (hx : x ∈ (n : ℝ)⁻¹ • L)\n    (hy : y ∈ (n : ℝ)⁻¹ • L) (h : index n x = index n y) : x = y := by\n  rw [← tag_index_eq_self_of_mem_smul_span n hx, ← tag_index_eq_self_of_mem_smul_span n hy, h]\n\n"}
{"name":"BoxIntegral.unitPartition.integralSum_eq_tsum_div","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\nn : Nat\ninst✝¹ : NeZero n\ninst✝ : Fintype ι\ns : Set (ι → Real)\nF : (ι → Real) → Real\nB : BoxIntegral.Box ι\nhB : BoxIntegral.hasIntegralVertices B\nhs₀ : LE.le s ↑B\n⊢ Eq (BoxIntegral.integralSum (s.indicator F) MeasureTheory.MeasureSpace.volume.toBoxAdditive.toSMul (BoxIntegral.unitPartition.prepartition n B)) (HDiv.hDiv (tsum fun x => F ↑x) (HPow.hPow (↑n) (Fintype.card ι)))","decl":"theorem integralSum_eq_tsum_div {B : Box ι} (hB : hasIntegralVertices B) (hs₀ : s ≤ B) :\n    integralSum (Set.indicator s F) (BoxAdditiveMap.toSMul (Measure.toBoxAdditive volume))\n      (prepartition n B) = (∑' x : ↑(s ∩ (n : ℝ)⁻¹ • L), F x) / n ^ card ι := by\n  classical\n  unfold integralSum\n  have : Fintype ↑(s ∩ (n : ℝ)⁻¹ • L) := by\n    apply Set.Finite.fintype\n    rw [← coe_pointwise_smul, ZSpan.smul _ (inv_ne_zero (NeZero.ne _))]\n    exact ZSpan.setFinite_inter _ (B.isBounded.subset hs₀)\n  rw [tsum_fintype, Finset.sum_set_coe, Finset.sum_div, eq_comm]\n  simp_rw [Set.indicator_apply, apply_ite, BoxAdditiveMap.toSMul_apply, Measure.toBoxAdditive_apply,\n    smul_eq_mul, mul_zero, Finset.sum_ite, Finset.sum_const_zero, add_zero]\n  refine Finset.sum_bij (fun x _ ↦ box n (index n x)) (fun _ hx ↦ Finset.mem_filter.mpr ?_)\n    (fun _ hx _ hy h ↦ ?_) (fun I hI ↦ ?_) (fun _ hx ↦ ?_)\n  · rw [Set.mem_toFinset] at hx\n    refine ⟨mem_prepartition_boxes_iff.mpr\n      ⟨index n _, mem_admissibleIndex_of_mem_box n hB (hs₀ hx.1), rfl⟩, ?_⟩\n    simp_rw [prepartition_tag n (mem_admissibleIndex_of_mem_box n hB (hs₀ hx.1)),\n      tag_index_eq_self_of_mem_smul_span n hx.2, hx.1]\n  · rw [Set.mem_toFinset] at hx hy\n    exact eq_of_mem_smul_span_of_index_eq_index n hx.2 hy.2 (box_injective n h)\n  · rw [Finset.mem_filter] at hI\n    refine ⟨(prepartition n B).tag I, Set.mem_toFinset.mpr ⟨hI.2, ?_⟩, box_index_tag_eq_self n hI.1⟩\n    rw [← box_index_tag_eq_self n hI.1, prepartition_tag n\n      (mem_admissibleIndex_of_mem_box n hB (hs₀ hI.2))]\n    exact tag_mem_smul_span _ _\n  · rw [Set.mem_toFinset] at hx\n    rw [volume_box, prepartition_tag n (mem_admissibleIndex_of_mem_box n hB (hs₀ hx.1)),\n      tag_index_eq_self_of_mem_smul_span n hx.2, ENNReal.toReal_div,\n      ENNReal.one_toReal, ENNReal.toReal_pow, ENNReal.toReal_nat, mul_comm_div, one_mul]\n\n"}
{"name":"tendsto_tsum_div_pow_atTop_integral","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\ns : Set (ι → Real)\nF : (ι → Real) → Real\nhF : Continuous F\nhs₁ : Bornology.IsBounded s\nhs₂ : MeasurableSet s\nhs₃ : Eq (MeasureTheory.MeasureSpace.volume (frontier s)) 0\n⊢ Filter.Tendsto (fun n => HDiv.hDiv (tsum fun x => F ↑x) (HPow.hPow (↑n) (Fintype.card ι))) Filter.atTop (nhds (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict s) fun x => F x))","decl":"/-- Let `s` be a bounded, measurable set of `ι → ℝ` whose frontier has zero volume and let `F`\nbe a continuous function. Then the limit as `n → ∞` of `∑ F x / n ^ card ι`, where the sum is\nover the points in `s ∩ n⁻¹ • (ι → ℤ)`, tends to the integral of `F` over `s`. -/\ntheorem _root_.tendsto_tsum_div_pow_atTop_integral (hF : Continuous F) (hs₁ : IsBounded s)\n    (hs₂ : MeasurableSet s) (hs₃ : volume (frontier s) = 0) :\n    Tendsto (fun n : ℕ ↦ (∑' x : ↑(s ∩ (n : ℝ)⁻¹ • L), F x) / n ^ card ι)\n      atTop (nhds (∫ x in s, F x)) := by\n  obtain ⟨B, hB, hs₀⟩ := le_hasIntegralVertices_of_isBounded hs₁\n  refine Metric.tendsto_atTop.mpr fun ε hε ↦ ?_\n  have h₁ : ∃ C, ∀ x ∈ Box.Icc B, ‖Set.indicator s F x‖ ≤ C := by\n    obtain ⟨C₀, h₀⟩ := (Box.isCompact_Icc B).exists_bound_of_continuousOn hF.continuousOn\n    refine ⟨max 0 C₀, fun x hx ↦ ?_⟩\n    rw [Set.indicator]\n    split_ifs with hs\n    · exact le_max_of_le_right (h₀ x hx)\n    · exact norm_zero.trans_le <|le_max_left 0 _\n  have h₂ : ∀ᵐ x, ContinuousAt (s.indicator F) x := by\n    filter_upwards [compl_mem_ae_iff.mpr hs₃] with _ h\n      using (hF.continuousOn).continuousAt_indicator h\n  obtain ⟨r, hr₁, hr₂⟩ := (hasIntegral_iff.mp <|\n      AEContinuous.hasBoxIntegral (volume : Measure (ι → ℝ)) h₁ h₂\n        IntegrationParams.Riemann) (ε / 2) (half_pos hε)\n  refine ⟨⌈(r 0 0 : ℝ)⁻¹⌉₊, fun n hn ↦ lt_of_le_of_lt ?_ (half_lt_self_iff.mpr hε)⟩\n  have : NeZero n :=\n    ⟨Nat.ne_zero_iff_zero_lt.mpr <| (Nat.ceil_pos.mpr (inv_pos.mpr (r 0 0).prop)).trans_le hn⟩\n  rw [← integralSum_eq_tsum_div _ s F hB hs₀, ← Measure.restrict_restrict_of_subset hs₀,\n    ← integral_indicator hs₂]\n  refine hr₂ 0 _ ⟨?_, fun _ ↦ ?_, fun h ↦ ?_, fun h ↦ ?_⟩ (prepartition_isPartition _ hB)\n  · rw [show r 0 = fun _ ↦ r 0 0 from funext_iff.mpr (hr₁ 0 rfl)]\n    apply prepartition_isSubordinate n B\n    rw [one_div, inv_le_comm₀ (mod_cast (Nat.pos_of_neZero n)) (r 0 0).prop]\n    exact le_trans (Nat.le_ceil _) (Nat.cast_le.mpr hn)\n  · exact prepartition_isHenstock n B\n  · simp only [IntegrationParams.Riemann, Bool.false_eq_true] at h\n  · simp only [IntegrationParams.Riemann, Bool.false_eq_true] at h\n\n"}
{"name":"tendsto_card_div_pow_atTop_volume","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\ns : Set (ι → Real)\nhs₁ : Bornology.IsBounded s\nhs₂ : MeasurableSet s\nhs₃ : Eq (MeasureTheory.MeasureSpace.volume (frontier s)) 0\n⊢ Filter.Tendsto (fun n => HDiv.hDiv (↑(Nat.card ↑(Inter.inter s (HSMul.hSMul (Inv.inv ↑n) ↑(Submodule.span Int (Set.range ⇑(Pi.basisFun Real ι))))))) (HPow.hPow (↑n) (Fintype.card ι))) Filter.atTop (nhds (MeasureTheory.MeasureSpace.volume s).toReal)","decl":"/-- Let `s` be a bounded, measurable set of `ι → ℝ` whose frontier has zero volume. Then the limit\nas `n → ∞` of `card (s ∩ n⁻¹ • (ι → ℤ)) / n ^ card ι` tends to the volume of `s`. This is a\nspecial case of `tendsto_card_div_pow` with `F = 1`. -/\ntheorem _root_.tendsto_card_div_pow_atTop_volume (hs₁ : IsBounded s)\n    (hs₂ : MeasurableSet s) (hs₃ : volume (frontier s) = 0) :\n    Tendsto (fun n : ℕ ↦ (Nat.card ↑(s ∩ (n : ℝ)⁻¹ • L) : ℝ) / n ^ card ι)\n      atTop (nhds (volume s).toReal) := by\n  convert tendsto_tsum_div_pow_atTop_integral s (fun _ ↦ 1) continuous_const hs₁ hs₂ hs₃\n  · rw [tsum_const, nsmul_eq_mul, mul_one, Nat.cast_inj]\n  · rw [setIntegral_const, smul_eq_mul, mul_one]\n\n"}
{"name":"tendsto_card_div_pow_atTop_volume'","module":"Mathlib.Analysis.BoxIntegral.UnitPartition","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\ns : Set (ι → Real)\nhs₁ : Bornology.IsBounded s\nhs₂ : MeasurableSet s\nhs₃ : Eq (MeasureTheory.MeasureSpace.volume (frontier s)) 0\nhs₄ : ∀ ⦃x y : Real⦄, LT.lt 0 x → LE.le x y → HasSubset.Subset (HSMul.hSMul x s) (HSMul.hSMul y s)\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (↑(Nat.card ↑(Inter.inter s (HSMul.hSMul (Inv.inv x) ↑(Submodule.span Int (Set.range ⇑(Pi.basisFun Real ι))))))) (HPow.hPow x (Fintype.card ι))) Filter.atTop (nhds (MeasureTheory.MeasureSpace.volume s).toReal)","decl":"/-- A version of `tendsto_card_div_pow_atTop_volume` for a real variable. -/\ntheorem _root_.tendsto_card_div_pow_atTop_volume' (hs₁ : IsBounded s)\n    (hs₂ : MeasurableSet s) (hs₃ : volume (frontier s) = 0)\n    (hs₄ : ∀ ⦃x y : ℝ⦄, 0 < x → x ≤ y → x • s ⊆ y • s) :\n    Tendsto (fun x : ℝ ↦ (Nat.card ↑(s ∩ x⁻¹ • L) : ℝ) / x ^ card ι)\n      atTop (nhds (volume s).toReal) := by\n  rw [show (volume s).toReal = (volume s).toReal * 1 ^ card ι by ring]\n  refine tendsto_of_tendsto_of_tendsto_of_le_of_le' ?_ ?_\n    (tendsto_card_div_pow₃ s hs₁ hs₄) (tendsto_card_div_pow₄ s hs₁ hs₄)\n  · refine Tendsto.congr' (tendsto_card_div_pow₅ s) (Tendsto.mul ?_ (Tendsto.pow ?_ _))\n    · exact Tendsto.comp (tendsto_card_div_pow_atTop_volume s hs₁ hs₂ hs₃) tendsto_nat_floor_atTop\n    · exact tendsto_nat_floor_div_atTop\n  · refine Tendsto.congr' (tendsto_card_div_pow₆ s) (Tendsto.mul ?_ (Tendsto.pow ?_ _))\n    · exact Tendsto.comp (tendsto_card_div_pow_atTop_volume s hs₁ hs₂ hs₃) tendsto_nat_ceil_atTop\n    · exact tendsto_nat_ceil_div_atTop\n\n"}
