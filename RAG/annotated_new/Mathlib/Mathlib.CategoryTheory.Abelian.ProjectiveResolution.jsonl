{"name":"CategoryTheory.ProjectiveResolution.exact₀","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nZ : C\nP : CategoryTheory.ProjectiveResolution Z\n⊢ (CategoryTheory.ShortComplex.mk (P.complex.d 1 0) (P.π.f 0) ⋯).Exact","decl":"lemma exact₀ {Z : C} (P : ProjectiveResolution Z) :\n    (ShortComplex.mk _ _ P.complex_d_comp_π_f_zero).Exact :=\n  ShortComplex.exact_of_g_is_cokernel _ P.isColimitCokernelCofork\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.liftFOne_zero_comm","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z : C\nf : Quiver.Hom Y Z\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ProjectiveResolution.liftFOne f P Q) (Q.complex.d 1 0)) (CategoryTheory.CategoryStruct.comp (P.complex.d 1 0) (CategoryTheory.ProjectiveResolution.liftFZero f P Q))","decl":"@[simp]\ntheorem liftFOne_zero_comm {Y Z : C} (f : Y ⟶ Z) (P : ProjectiveResolution Y)\n    (Q : ProjectiveResolution Z) :\n    liftFOne f P Q ≫ Q.complex.d 1 0 = P.complex.d 1 0 ≫ liftFZero f P Q := by\n  apply Q.exact₀.liftFromProjective_comp\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.lift_commutes_assoc","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z✝ : C\nf : Quiver.Hom Y Z✝\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z✝\nZ : ChainComplex C Nat\nh : Quiver.Hom ((ChainComplex.single₀ C).obj Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ProjectiveResolution.lift f P Q) (CategoryTheory.CategoryStruct.comp Q.π h)) (CategoryTheory.CategoryStruct.comp P.π (CategoryTheory.CategoryStruct.comp ((ChainComplex.single₀ C).map f) h))","decl":"/-- The resolution maps intertwine the lift of a morphism and that morphism. -/\n@[reassoc (attr := simp)]\ntheorem lift_commutes {Y Z : C} (f : Y ⟶ Z) (P : ProjectiveResolution Y)\n    (Q : ProjectiveResolution Z) : lift f P Q ≫ Q.π = P.π ≫ (ChainComplex.single₀ C).map f := by\n  ext\n  simp [lift, liftFZero, liftFOne]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.lift_commutes","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z : C\nf : Quiver.Hom Y Z\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ProjectiveResolution.lift f P Q) Q.π) (CategoryTheory.CategoryStruct.comp P.π ((ChainComplex.single₀ C).map f))","decl":"/-- The resolution maps intertwine the lift of a morphism and that morphism. -/\n@[reassoc (attr := simp)]\ntheorem lift_commutes {Y Z : C} (f : Y ⟶ Z) (P : ProjectiveResolution Y)\n    (Q : ProjectiveResolution Z) : lift f P Q ≫ Q.π = P.π ≫ (ChainComplex.single₀ C).map f := by\n  ext\n  simp [lift, liftFZero, liftFOne]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.lift_commutes_zero","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z : C\nf : Quiver.Hom Y Z\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ProjectiveResolution.lift f P Q).f 0) (Q.π.f 0)) (CategoryTheory.CategoryStruct.comp (P.π.f 0) f)","decl":"@[reassoc (attr := simp)]\nlemma lift_commutes_zero {Y Z : C} (f : Y ⟶ Z)\n    (P : ProjectiveResolution Y) (Q : ProjectiveResolution Z) :\n    (lift f P Q).f 0 ≫ Q.π.f 0 = P.π.f 0 ≫ f :=\n  (HomologicalComplex.congr_hom (lift_commutes f P Q) 0).trans (by simp)\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.lift_commutes_zero_assoc","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z✝ : C\nf : Quiver.Hom Y Z✝\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z✝\nZ : C\nh : Quiver.Hom (((ChainComplex.single₀ C).obj Z✝).X 0) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ProjectiveResolution.lift f P Q).f 0) (CategoryTheory.CategoryStruct.comp (Q.π.f 0) h)) (CategoryTheory.CategoryStruct.comp (P.π.f 0) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\nlemma lift_commutes_zero {Y Z : C} (f : Y ⟶ Z)\n    (P : ProjectiveResolution Y) (Q : ProjectiveResolution Z) :\n    (lift f P Q).f 0 ≫ Q.π.f 0 = P.π.f 0 ≫ f :=\n  (HomologicalComplex.congr_hom (lift_commutes f P Q) 0).trans (by simp)\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.liftHomotopyZeroZero_comp","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z : C\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z\nf : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp f Q.π) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ProjectiveResolution.liftHomotopyZeroZero f comm) (Q.complex.d 1 0)) (f.f 0)","decl":"@[reassoc (attr := simp)]\nlemma liftHomotopyZeroZero_comp {Y Z : C} {P : ProjectiveResolution Y} {Q : ProjectiveResolution Z}\n    (f : P.complex ⟶ Q.complex) (comm : f ≫ Q.π = 0) :\n    liftHomotopyZeroZero f comm ≫ Q.complex.d 1 0 = f.f 0 :=\n  Q.exact₀.liftFromProjective_comp  _ _\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.liftHomotopyZeroZero_comp_assoc","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z✝ : C\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z✝\nf : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp f Q.π) 0\nZ : C\nh : Quiver.Hom (Q.complex.X 0) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ProjectiveResolution.liftHomotopyZeroZero f comm) (CategoryTheory.CategoryStruct.comp (Q.complex.d 1 0) h)) (CategoryTheory.CategoryStruct.comp (f.f 0) h)","decl":"@[reassoc (attr := simp)]\nlemma liftHomotopyZeroZero_comp {Y Z : C} {P : ProjectiveResolution Y} {Q : ProjectiveResolution Z}\n    (f : P.complex ⟶ Q.complex) (comm : f ≫ Q.π = 0) :\n    liftHomotopyZeroZero f comm ≫ Q.complex.d 1 0 = f.f 0 :=\n  Q.exact₀.liftFromProjective_comp  _ _\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.liftHomotopyZeroOne_comp_assoc","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z✝ : C\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z✝\nf : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp f Q.π) 0\nZ : C\nh : Quiver.Hom (Q.complex.X 1) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ProjectiveResolution.liftHomotopyZeroOne f comm) (CategoryTheory.CategoryStruct.comp (Q.complex.d 2 1) h)) (CategoryTheory.CategoryStruct.comp (HSub.hSub (f.f 1) (CategoryTheory.CategoryStruct.comp (P.complex.d 1 0) (CategoryTheory.ProjectiveResolution.liftHomotopyZeroZero f comm))) h)","decl":"@[reassoc (attr := simp)]\nlemma liftHomotopyZeroOne_comp {Y Z : C} {P : ProjectiveResolution Y} {Q : ProjectiveResolution Z}\n    (f : P.complex ⟶ Q.complex) (comm : f ≫ Q.π = 0) :\n    liftHomotopyZeroOne f comm ≫ Q.complex.d 2 1 =\n      f.f 1 - P.complex.d 1 0 ≫ liftHomotopyZeroZero f comm :=\n  (Q.exact_succ 0).liftFromProjective_comp _ _\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.liftHomotopyZeroOne_comp","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z : C\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z\nf : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp f Q.π) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ProjectiveResolution.liftHomotopyZeroOne f comm) (Q.complex.d 2 1)) (HSub.hSub (f.f 1) (CategoryTheory.CategoryStruct.comp (P.complex.d 1 0) (CategoryTheory.ProjectiveResolution.liftHomotopyZeroZero f comm)))","decl":"@[reassoc (attr := simp)]\nlemma liftHomotopyZeroOne_comp {Y Z : C} {P : ProjectiveResolution Y} {Q : ProjectiveResolution Z}\n    (f : P.complex ⟶ Q.complex) (comm : f ≫ Q.π = 0) :\n    liftHomotopyZeroOne f comm ≫ Q.complex.d 2 1 =\n      f.f 1 - P.complex.d 1 0 ≫ liftHomotopyZeroZero f comm :=\n  (Q.exact_succ 0).liftFromProjective_comp _ _\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.liftHomotopyZeroSucc_comp","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z : C\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z\nf : Quiver.Hom P.complex Q.complex\nn : Nat\ng : Quiver.Hom (P.complex.X n) (Q.complex.X (HAdd.hAdd n 1))\ng' : Quiver.Hom (P.complex.X (HAdd.hAdd n 1)) (Q.complex.X (HAdd.hAdd n 2))\nw : Eq (f.f (HAdd.hAdd n 1)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (P.complex.d (HAdd.hAdd n 1) n) g) (CategoryTheory.CategoryStruct.comp g' (Q.complex.d (HAdd.hAdd n 2) (HAdd.hAdd n 1))))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ProjectiveResolution.liftHomotopyZeroSucc f n g g' w) (Q.complex.d (HAdd.hAdd n 3) (HAdd.hAdd n 2))) (HSub.hSub (f.f (HAdd.hAdd n 2)) (CategoryTheory.CategoryStruct.comp (P.complex.d (HAdd.hAdd n 2) (HAdd.hAdd n 1)) g'))","decl":"@[reassoc (attr := simp)]\nlemma liftHomotopyZeroSucc_comp {Y Z : C} {P : ProjectiveResolution Y} {Q : ProjectiveResolution Z}\n    (f : P.complex ⟶ Q.complex) (n : ℕ) (g : P.complex.X n ⟶ Q.complex.X (n + 1))\n    (g' : P.complex.X (n + 1) ⟶ Q.complex.X (n + 2))\n    (w : f.f (n + 1) = P.complex.d (n + 1) n ≫ g + g' ≫ Q.complex.d (n + 2) (n + 1)) :\n    liftHomotopyZeroSucc f n g g' w ≫ Q.complex.d (n + 3) (n + 2) =\n      f.f (n + 2) - P.complex.d _ _ ≫ g' :=\n  (Q.exact_succ (n+1)).liftFromProjective_comp  _ _\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.liftHomotopyZeroSucc_comp_assoc","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z✝ : C\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z✝\nf : Quiver.Hom P.complex Q.complex\nn : Nat\ng : Quiver.Hom (P.complex.X n) (Q.complex.X (HAdd.hAdd n 1))\ng' : Quiver.Hom (P.complex.X (HAdd.hAdd n 1)) (Q.complex.X (HAdd.hAdd n 2))\nw : Eq (f.f (HAdd.hAdd n 1)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (P.complex.d (HAdd.hAdd n 1) n) g) (CategoryTheory.CategoryStruct.comp g' (Q.complex.d (HAdd.hAdd n 2) (HAdd.hAdd n 1))))\nZ : C\nh : Quiver.Hom (Q.complex.X (HAdd.hAdd n 2)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ProjectiveResolution.liftHomotopyZeroSucc f n g g' w) (CategoryTheory.CategoryStruct.comp (Q.complex.d (HAdd.hAdd n 3) (HAdd.hAdd n 2)) h)) (CategoryTheory.CategoryStruct.comp (HSub.hSub (f.f (HAdd.hAdd n 2)) (CategoryTheory.CategoryStruct.comp (P.complex.d (HAdd.hAdd n 2) (HAdd.hAdd n 1)) g')) h)","decl":"@[reassoc (attr := simp)]\nlemma liftHomotopyZeroSucc_comp {Y Z : C} {P : ProjectiveResolution Y} {Q : ProjectiveResolution Z}\n    (f : P.complex ⟶ Q.complex) (n : ℕ) (g : P.complex.X n ⟶ Q.complex.X (n + 1))\n    (g' : P.complex.X (n + 1) ⟶ Q.complex.X (n + 2))\n    (w : f.f (n + 1) = P.complex.d (n + 1) n ≫ g + g' ≫ Q.complex.d (n + 2) (n + 1)) :\n    liftHomotopyZeroSucc f n g g' w ≫ Q.complex.d (n + 3) (n + 2) =\n      f.f (n + 2) - P.complex.d _ _ ≫ g' :=\n  (Q.exact_succ (n+1)).liftFromProjective_comp  _ _\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.homotopyEquiv_hom_π","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nX : C\nP Q : CategoryTheory.ProjectiveResolution X\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.homotopyEquiv Q).hom Q.π) P.π","decl":"@[reassoc (attr := simp)]\ntheorem homotopyEquiv_hom_π {X : C} (P Q : ProjectiveResolution X) :\n    (homotopyEquiv P Q).hom ≫ Q.π = P.π := by simp [homotopyEquiv]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.homotopyEquiv_hom_π_assoc","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nX : C\nP Q : CategoryTheory.ProjectiveResolution X\nZ : HomologicalComplex C (ComplexShape.down Nat)\nh : Quiver.Hom ((ChainComplex.single₀ C).obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.homotopyEquiv Q).hom (CategoryTheory.CategoryStruct.comp Q.π h)) (CategoryTheory.CategoryStruct.comp P.π h)","decl":"@[reassoc (attr := simp)]\ntheorem homotopyEquiv_hom_π {X : C} (P Q : ProjectiveResolution X) :\n    (homotopyEquiv P Q).hom ≫ Q.π = P.π := by simp [homotopyEquiv]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.homotopyEquiv_inv_π_assoc","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nX : C\nP Q : CategoryTheory.ProjectiveResolution X\nZ : HomologicalComplex C (ComplexShape.down Nat)\nh : Quiver.Hom ((ChainComplex.single₀ C).obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.homotopyEquiv Q).inv (CategoryTheory.CategoryStruct.comp P.π h)) (CategoryTheory.CategoryStruct.comp Q.π h)","decl":"@[reassoc (attr := simp)]\ntheorem homotopyEquiv_inv_π {X : C} (P Q : ProjectiveResolution X) :\n    (homotopyEquiv P Q).inv ≫ P.π = Q.π := by simp [homotopyEquiv]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.homotopyEquiv_inv_π","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nX : C\nP Q : CategoryTheory.ProjectiveResolution X\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.homotopyEquiv Q).inv P.π) Q.π","decl":"@[reassoc (attr := simp)]\ntheorem homotopyEquiv_inv_π {X : C} (P Q : ProjectiveResolution X) :\n    (homotopyEquiv P Q).inv ≫ P.π = Q.π := by simp [homotopyEquiv]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.iso_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasProjectiveResolutions C\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nφ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (φ.f 0) (Q.π.f 0)) (CategoryTheory.CategoryStruct.comp (P.π.f 0) f)\nZ : HomotopyCategory C (ComplexShape.down Nat)\nh : Quiver.Hom ((CategoryTheory.projectiveResolutions C).obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp P.iso.inv (CategoryTheory.CategoryStruct.comp ((CategoryTheory.projectiveResolutions C).map f) h)) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.down Nat)).map φ) (CategoryTheory.CategoryStruct.comp Q.iso.inv h))","decl":"@[reassoc]\nlemma ProjectiveResolution.iso_inv_naturality {X Y : C} (f : X ⟶ Y)\n    (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (φ : P.complex ⟶ Q.complex) (comm : φ.f 0 ≫ Q.π.f 0 = P.π.f 0 ≫ f) :\n    P.iso.inv ≫ (projectiveResolutions C).map f =\n      (HomotopyCategory.quotient _ _).map φ ≫ Q.iso.inv := by\n  apply HomotopyCategory.eq_of_homotopy\n  apply liftHomotopy f\n  all_goals\n    aesop_cat\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.iso_inv_naturality","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasProjectiveResolutions C\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nφ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (φ.f 0) (Q.π.f 0)) (CategoryTheory.CategoryStruct.comp (P.π.f 0) f)\n⊢ Eq (CategoryTheory.CategoryStruct.comp P.iso.inv ((CategoryTheory.projectiveResolutions C).map f)) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.down Nat)).map φ) Q.iso.inv)","decl":"@[reassoc]\nlemma ProjectiveResolution.iso_inv_naturality {X Y : C} (f : X ⟶ Y)\n    (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (φ : P.complex ⟶ Q.complex) (comm : φ.f 0 ≫ Q.π.f 0 = P.π.f 0 ≫ f) :\n    P.iso.inv ≫ (projectiveResolutions C).map f =\n      (HomotopyCategory.quotient _ _).map φ ≫ Q.iso.inv := by\n  apply HomotopyCategory.eq_of_homotopy\n  apply liftHomotopy f\n  all_goals\n    aesop_cat\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.iso_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasProjectiveResolutions C\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nφ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (φ.f 0) (Q.π.f 0)) (CategoryTheory.CategoryStruct.comp (P.π.f 0) f)\nZ : HomotopyCategory C (ComplexShape.down Nat)\nh : Quiver.Hom ((HomotopyCategory.quotient C (ComplexShape.down Nat)).obj Q.complex) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.projectiveResolutions C).map f) (CategoryTheory.CategoryStruct.comp Q.iso.hom h)) (CategoryTheory.CategoryStruct.comp P.iso.hom (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.down Nat)).map φ) h))","decl":"@[reassoc]\nlemma ProjectiveResolution.iso_hom_naturality {X Y : C} (f : X ⟶ Y)\n    (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (φ : P.complex ⟶ Q.complex) (comm : φ.f 0 ≫ Q.π.f 0 = P.π.f 0 ≫ f) :\n    (projectiveResolutions C).map f ≫ Q.iso.hom =\n      P.iso.hom ≫ (HomotopyCategory.quotient _ _).map φ := by\n  rw [← cancel_epi (P.iso).inv, iso_inv_naturality_assoc f P Q φ comm,\n    Iso.inv_hom_id_assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.iso_hom_naturality","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasProjectiveResolutions C\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nφ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (φ.f 0) (Q.π.f 0)) (CategoryTheory.CategoryStruct.comp (P.π.f 0) f)\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.projectiveResolutions C).map f) Q.iso.hom) (CategoryTheory.CategoryStruct.comp P.iso.hom ((HomotopyCategory.quotient C (ComplexShape.down Nat)).map φ))","decl":"@[reassoc]\nlemma ProjectiveResolution.iso_hom_naturality {X Y : C} (f : X ⟶ Y)\n    (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (φ : P.complex ⟶ Q.complex) (comm : φ.f 0 ≫ Q.π.f 0 = P.π.f 0 ≫ f) :\n    (projectiveResolutions C).map f ≫ Q.iso.hom =\n      P.iso.hom ≫ (HomotopyCategory.quotient _ _).map φ := by\n  rw [← cancel_epi (P.iso).inv, iso_inv_naturality_assoc f P Q φ comm,\n    Iso.inv_hom_id_assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.exact_d_f","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.EnoughProjectives C\nX Y : C\nf : Quiver.Hom X Y\n⊢ (CategoryTheory.ShortComplex.mk (CategoryTheory.Projective.d f) f ⋯).Exact","decl":"variable {C} in\ntheorem exact_d_f {X Y : C} (f : X ⟶ Y) :\n    (ShortComplex.mk (d f) f (by simp)).Exact := by\n  let α : ShortComplex.mk (d f) f (by simp) ⟶ ShortComplex.mk (kernel.ι f) f (by simp) :=\n    { τ₁ := Projective.π _\n      τ₂ := 𝟙 _\n      τ₃ := 𝟙 _ }\n  have : Epi α.τ₁ := by dsimp; infer_instance\n  have : IsIso α.τ₂ := by dsimp; infer_instance\n  have : Mono α.τ₃ := by dsimp; infer_instance\n  rw [ShortComplex.exact_iff_of_epi_of_isIso_of_mono α]\n  apply ShortComplex.exact_of_f_is_kernel\n  apply kernelIsKernel\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.ofComplex_d_1_0","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.EnoughProjectives C\nZ : C\n⊢ Eq ((CategoryTheory.ProjectiveResolution.ofComplex Z).d 1 0) (CategoryTheory.Projective.d (CategoryTheory.Projective.π Z))","decl":"lemma ofComplex_d_1_0 :\n    (ofComplex Z).d 1 0 = d (Projective.π Z) := by\n  simp [ofComplex]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.ofComplex_exactAt_succ","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.EnoughProjectives C\nZ : C\nn : Nat\n⊢ HomologicalComplex.ExactAt (CategoryTheory.ProjectiveResolution.ofComplex Z) (HAdd.hAdd n 1)","decl":"lemma ofComplex_exactAt_succ (n : ℕ) :\n    (ofComplex Z).ExactAt (n + 1) := by\n  rw [HomologicalComplex.exactAt_iff' _ (n + 1 + 1) (n + 1) n (by simp) (by simp)]\n  dsimp [ofComplex, HomologicalComplex.sc', HomologicalComplex.shortComplexFunctor',\n      ChainComplex.mk', ChainComplex.mk]\n  simp only [ChainComplex.of_d]\n  -- TODO: this should just be apply exact_d_f so something is missing\n  match n with\n  | 0 => apply exact_d_f\n  | n + 1 => apply exact_d_f\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.instProjectiveXNatOfComplex","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.EnoughProjectives C\nZ : C\nn : Nat\n⊢ CategoryTheory.Projective ((CategoryTheory.ProjectiveResolution.ofComplex Z).X n)","decl":"instance (n : ℕ) : Projective ((ofComplex Z).X n) := by\n  obtain (_ | _ | _ | n) := n <;> apply Projective.projective_over\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.of_def","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.EnoughProjectives C\nZ : C\n⊢ Eq (CategoryTheory.ProjectiveResolution.of Z) (CategoryTheory.ProjectiveResolution.mk (CategoryTheory.ProjectiveResolution.ofComplex Z) ⋯ (((CategoryTheory.ProjectiveResolution.ofComplex Z).toSingle₀Equiv Z).symm ⟨CategoryTheory.Projective.π Z, ⋯⟩) ⋯)","decl":"/-- In any abelian category with enough projectives,\n`ProjectiveResolution.of Z` constructs an projective resolution of the object `Z`.\n-/\nirreducible_def of : ProjectiveResolution Z where\n  complex := ofComplex Z\n  π := (ChainComplex.toSingle₀Equiv _ _).symm ⟨Projective.π Z, by\n          rw [ofComplex_d_1_0, assoc, kernel.condition, comp_zero]⟩\n  quasiIso := ⟨fun n => by\n    cases n\n    · rw [ChainComplex.quasiIsoAt₀_iff, ShortComplex.quasiIso_iff_of_zeros']\n      · dsimp\n        refine (ShortComplex.exact_and_epi_g_iff_of_iso ?_).2\n          ⟨exact_d_f (Projective.π Z), by dsimp; infer_instance⟩\n        exact ShortComplex.isoMk (Iso.refl _) (Iso.refl _) (Iso.refl _)\n          (by simp [ofComplex]) (by simp)\n      all_goals rfl\n    · rw [quasiIsoAt_iff_exactAt']\n      · apply ofComplex_exactAt_succ\n      · apply ChainComplex.exactAt_succ_single_obj⟩\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.instHasProjectiveResolution","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.EnoughProjectives C\nZ : C\n⊢ CategoryTheory.HasProjectiveResolution Z","decl":"instance (priority := 100) (Z : C) : HasProjectiveResolution Z where out := ⟨of Z⟩\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.instHasProjectiveResolutions","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.EnoughProjectives C\n⊢ CategoryTheory.HasProjectiveResolutions C","decl":"instance (priority := 100) : HasProjectiveResolutions C where out _ := inferInstance\n\n"}
