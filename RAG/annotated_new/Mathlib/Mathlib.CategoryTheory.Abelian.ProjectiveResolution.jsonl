{"name":"CategoryTheory.ProjectiveResolution.exact‚ÇÄ","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nZ : C\nP : CategoryTheory.ProjectiveResolution Z\n‚ä¢ (CategoryTheory.ShortComplex.mk (P.complex.d 1 0) (P.œÄ.f 0) ‚ãØ).Exact","decl":"lemma exact‚ÇÄ {Z : C} (P : ProjectiveResolution Z) :\n    (ShortComplex.mk _ _ P.complex_d_comp_œÄ_f_zero).Exact :=\n  ShortComplex.exact_of_g_is_cokernel _ P.isColimitCokernelCofork\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.liftFOne_zero_comm","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z : C\nf : Quiver.Hom Y Z\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ProjectiveResolution.liftFOne f P Q) (Q.complex.d 1 0)) (CategoryTheory.CategoryStruct.comp (P.complex.d 1 0) (CategoryTheory.ProjectiveResolution.liftFZero f P Q))","decl":"@[simp]\ntheorem liftFOne_zero_comm {Y Z : C} (f : Y ‚ü∂ Z) (P : ProjectiveResolution Y)\n    (Q : ProjectiveResolution Z) :\n    liftFOne f P Q ‚â´ Q.complex.d 1 0 = P.complex.d 1 0 ‚â´ liftFZero f P Q := by\n  apply Q.exact‚ÇÄ.liftFromProjective_comp\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.lift_commutes_assoc","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z‚úù : C\nf : Quiver.Hom Y Z‚úù\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z‚úù\nZ : ChainComplex C Nat\nh : Quiver.Hom ((ChainComplex.single‚ÇÄ C).obj Z‚úù) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ProjectiveResolution.lift f P Q) (CategoryTheory.CategoryStruct.comp Q.œÄ h)) (CategoryTheory.CategoryStruct.comp P.œÄ (CategoryTheory.CategoryStruct.comp ((ChainComplex.single‚ÇÄ C).map f) h))","decl":"/-- The resolution maps intertwine the lift of a morphism and that morphism. -/\n@[reassoc (attr := simp)]\ntheorem lift_commutes {Y Z : C} (f : Y ‚ü∂ Z) (P : ProjectiveResolution Y)\n    (Q : ProjectiveResolution Z) : lift f P Q ‚â´ Q.œÄ = P.œÄ ‚â´ (ChainComplex.single‚ÇÄ C).map f := by\n  ext\n  simp [lift, liftFZero, liftFOne]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.lift_commutes","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z : C\nf : Quiver.Hom Y Z\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ProjectiveResolution.lift f P Q) Q.œÄ) (CategoryTheory.CategoryStruct.comp P.œÄ ((ChainComplex.single‚ÇÄ C).map f))","decl":"/-- The resolution maps intertwine the lift of a morphism and that morphism. -/\n@[reassoc (attr := simp)]\ntheorem lift_commutes {Y Z : C} (f : Y ‚ü∂ Z) (P : ProjectiveResolution Y)\n    (Q : ProjectiveResolution Z) : lift f P Q ‚â´ Q.œÄ = P.œÄ ‚â´ (ChainComplex.single‚ÇÄ C).map f := by\n  ext\n  simp [lift, liftFZero, liftFOne]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.lift_commutes_zero","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z : C\nf : Quiver.Hom Y Z\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ProjectiveResolution.lift f P Q).f 0) (Q.œÄ.f 0)) (CategoryTheory.CategoryStruct.comp (P.œÄ.f 0) f)","decl":"@[reassoc (attr := simp)]\nlemma lift_commutes_zero {Y Z : C} (f : Y ‚ü∂ Z)\n    (P : ProjectiveResolution Y) (Q : ProjectiveResolution Z) :\n    (lift f P Q).f 0 ‚â´ Q.œÄ.f 0 = P.œÄ.f 0 ‚â´ f :=\n  (HomologicalComplex.congr_hom (lift_commutes f P Q) 0).trans (by simp)\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.lift_commutes_zero_assoc","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z‚úù : C\nf : Quiver.Hom Y Z‚úù\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z‚úù\nZ : C\nh : Quiver.Hom (((ChainComplex.single‚ÇÄ C).obj Z‚úù).X 0) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ProjectiveResolution.lift f P Q).f 0) (CategoryTheory.CategoryStruct.comp (Q.œÄ.f 0) h)) (CategoryTheory.CategoryStruct.comp (P.œÄ.f 0) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\nlemma lift_commutes_zero {Y Z : C} (f : Y ‚ü∂ Z)\n    (P : ProjectiveResolution Y) (Q : ProjectiveResolution Z) :\n    (lift f P Q).f 0 ‚â´ Q.œÄ.f 0 = P.œÄ.f 0 ‚â´ f :=\n  (HomologicalComplex.congr_hom (lift_commutes f P Q) 0).trans (by simp)\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.liftHomotopyZeroZero_comp","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z : C\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z\nf : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp f Q.œÄ) 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ProjectiveResolution.liftHomotopyZeroZero f comm) (Q.complex.d 1 0)) (f.f 0)","decl":"@[reassoc (attr := simp)]\nlemma liftHomotopyZeroZero_comp {Y Z : C} {P : ProjectiveResolution Y} {Q : ProjectiveResolution Z}\n    (f : P.complex ‚ü∂ Q.complex) (comm : f ‚â´ Q.œÄ = 0) :\n    liftHomotopyZeroZero f comm ‚â´ Q.complex.d 1 0 = f.f 0 :=\n  Q.exact‚ÇÄ.liftFromProjective_comp  _ _\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.liftHomotopyZeroZero_comp_assoc","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z‚úù : C\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z‚úù\nf : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp f Q.œÄ) 0\nZ : C\nh : Quiver.Hom (Q.complex.X 0) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ProjectiveResolution.liftHomotopyZeroZero f comm) (CategoryTheory.CategoryStruct.comp (Q.complex.d 1 0) h)) (CategoryTheory.CategoryStruct.comp (f.f 0) h)","decl":"@[reassoc (attr := simp)]\nlemma liftHomotopyZeroZero_comp {Y Z : C} {P : ProjectiveResolution Y} {Q : ProjectiveResolution Z}\n    (f : P.complex ‚ü∂ Q.complex) (comm : f ‚â´ Q.œÄ = 0) :\n    liftHomotopyZeroZero f comm ‚â´ Q.complex.d 1 0 = f.f 0 :=\n  Q.exact‚ÇÄ.liftFromProjective_comp  _ _\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.liftHomotopyZeroOne_comp_assoc","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z‚úù : C\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z‚úù\nf : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp f Q.œÄ) 0\nZ : C\nh : Quiver.Hom (Q.complex.X 1) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ProjectiveResolution.liftHomotopyZeroOne f comm) (CategoryTheory.CategoryStruct.comp (Q.complex.d 2 1) h)) (CategoryTheory.CategoryStruct.comp (HSub.hSub (f.f 1) (CategoryTheory.CategoryStruct.comp (P.complex.d 1 0) (CategoryTheory.ProjectiveResolution.liftHomotopyZeroZero f comm))) h)","decl":"@[reassoc (attr := simp)]\nlemma liftHomotopyZeroOne_comp {Y Z : C} {P : ProjectiveResolution Y} {Q : ProjectiveResolution Z}\n    (f : P.complex ‚ü∂ Q.complex) (comm : f ‚â´ Q.œÄ = 0) :\n    liftHomotopyZeroOne f comm ‚â´ Q.complex.d 2 1 =\n      f.f 1 - P.complex.d 1 0 ‚â´ liftHomotopyZeroZero f comm :=\n  (Q.exact_succ 0).liftFromProjective_comp _ _\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.liftHomotopyZeroOne_comp","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z : C\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z\nf : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp f Q.œÄ) 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ProjectiveResolution.liftHomotopyZeroOne f comm) (Q.complex.d 2 1)) (HSub.hSub (f.f 1) (CategoryTheory.CategoryStruct.comp (P.complex.d 1 0) (CategoryTheory.ProjectiveResolution.liftHomotopyZeroZero f comm)))","decl":"@[reassoc (attr := simp)]\nlemma liftHomotopyZeroOne_comp {Y Z : C} {P : ProjectiveResolution Y} {Q : ProjectiveResolution Z}\n    (f : P.complex ‚ü∂ Q.complex) (comm : f ‚â´ Q.œÄ = 0) :\n    liftHomotopyZeroOne f comm ‚â´ Q.complex.d 2 1 =\n      f.f 1 - P.complex.d 1 0 ‚â´ liftHomotopyZeroZero f comm :=\n  (Q.exact_succ 0).liftFromProjective_comp _ _\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.liftHomotopyZeroSucc_comp","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z : C\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z\nf : Quiver.Hom P.complex Q.complex\nn : Nat\ng : Quiver.Hom (P.complex.X n) (Q.complex.X (HAdd.hAdd n 1))\ng' : Quiver.Hom (P.complex.X (HAdd.hAdd n 1)) (Q.complex.X (HAdd.hAdd n 2))\nw : Eq (f.f (HAdd.hAdd n 1)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (P.complex.d (HAdd.hAdd n 1) n) g) (CategoryTheory.CategoryStruct.comp g' (Q.complex.d (HAdd.hAdd n 2) (HAdd.hAdd n 1))))\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ProjectiveResolution.liftHomotopyZeroSucc f n g g' w) (Q.complex.d (HAdd.hAdd n 3) (HAdd.hAdd n 2))) (HSub.hSub (f.f (HAdd.hAdd n 2)) (CategoryTheory.CategoryStruct.comp (P.complex.d (HAdd.hAdd n 2) (HAdd.hAdd n 1)) g'))","decl":"@[reassoc (attr := simp)]\nlemma liftHomotopyZeroSucc_comp {Y Z : C} {P : ProjectiveResolution Y} {Q : ProjectiveResolution Z}\n    (f : P.complex ‚ü∂ Q.complex) (n : ‚Ñï) (g : P.complex.X n ‚ü∂ Q.complex.X (n + 1))\n    (g' : P.complex.X (n + 1) ‚ü∂ Q.complex.X (n + 2))\n    (w : f.f (n + 1) = P.complex.d (n + 1) n ‚â´ g + g' ‚â´ Q.complex.d (n + 2) (n + 1)) :\n    liftHomotopyZeroSucc f n g g' w ‚â´ Q.complex.d (n + 3) (n + 2) =\n      f.f (n + 2) - P.complex.d _ _ ‚â´ g' :=\n  (Q.exact_succ (n+1)).liftFromProjective_comp  _ _\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.liftHomotopyZeroSucc_comp_assoc","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z‚úù : C\nP : CategoryTheory.ProjectiveResolution Y\nQ : CategoryTheory.ProjectiveResolution Z‚úù\nf : Quiver.Hom P.complex Q.complex\nn : Nat\ng : Quiver.Hom (P.complex.X n) (Q.complex.X (HAdd.hAdd n 1))\ng' : Quiver.Hom (P.complex.X (HAdd.hAdd n 1)) (Q.complex.X (HAdd.hAdd n 2))\nw : Eq (f.f (HAdd.hAdd n 1)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (P.complex.d (HAdd.hAdd n 1) n) g) (CategoryTheory.CategoryStruct.comp g' (Q.complex.d (HAdd.hAdd n 2) (HAdd.hAdd n 1))))\nZ : C\nh : Quiver.Hom (Q.complex.X (HAdd.hAdd n 2)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ProjectiveResolution.liftHomotopyZeroSucc f n g g' w) (CategoryTheory.CategoryStruct.comp (Q.complex.d (HAdd.hAdd n 3) (HAdd.hAdd n 2)) h)) (CategoryTheory.CategoryStruct.comp (HSub.hSub (f.f (HAdd.hAdd n 2)) (CategoryTheory.CategoryStruct.comp (P.complex.d (HAdd.hAdd n 2) (HAdd.hAdd n 1)) g')) h)","decl":"@[reassoc (attr := simp)]\nlemma liftHomotopyZeroSucc_comp {Y Z : C} {P : ProjectiveResolution Y} {Q : ProjectiveResolution Z}\n    (f : P.complex ‚ü∂ Q.complex) (n : ‚Ñï) (g : P.complex.X n ‚ü∂ Q.complex.X (n + 1))\n    (g' : P.complex.X (n + 1) ‚ü∂ Q.complex.X (n + 2))\n    (w : f.f (n + 1) = P.complex.d (n + 1) n ‚â´ g + g' ‚â´ Q.complex.d (n + 2) (n + 1)) :\n    liftHomotopyZeroSucc f n g g' w ‚â´ Q.complex.d (n + 3) (n + 2) =\n      f.f (n + 2) - P.complex.d _ _ ‚â´ g' :=\n  (Q.exact_succ (n+1)).liftFromProjective_comp  _ _\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.homotopyEquiv_hom_œÄ","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nX : C\nP Q : CategoryTheory.ProjectiveResolution X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.homotopyEquiv Q).hom Q.œÄ) P.œÄ","decl":"@[reassoc (attr := simp)]\ntheorem homotopyEquiv_hom_œÄ {X : C} (P Q : ProjectiveResolution X) :\n    (homotopyEquiv P Q).hom ‚â´ Q.œÄ = P.œÄ := by simp [homotopyEquiv]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.homotopyEquiv_hom_œÄ_assoc","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nX : C\nP Q : CategoryTheory.ProjectiveResolution X\nZ : HomologicalComplex C (ComplexShape.down Nat)\nh : Quiver.Hom ((ChainComplex.single‚ÇÄ C).obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.homotopyEquiv Q).hom (CategoryTheory.CategoryStruct.comp Q.œÄ h)) (CategoryTheory.CategoryStruct.comp P.œÄ h)","decl":"@[reassoc (attr := simp)]\ntheorem homotopyEquiv_hom_œÄ {X : C} (P Q : ProjectiveResolution X) :\n    (homotopyEquiv P Q).hom ‚â´ Q.œÄ = P.œÄ := by simp [homotopyEquiv]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.homotopyEquiv_inv_œÄ_assoc","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nX : C\nP Q : CategoryTheory.ProjectiveResolution X\nZ : HomologicalComplex C (ComplexShape.down Nat)\nh : Quiver.Hom ((ChainComplex.single‚ÇÄ C).obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.homotopyEquiv Q).inv (CategoryTheory.CategoryStruct.comp P.œÄ h)) (CategoryTheory.CategoryStruct.comp Q.œÄ h)","decl":"@[reassoc (attr := simp)]\ntheorem homotopyEquiv_inv_œÄ {X : C} (P Q : ProjectiveResolution X) :\n    (homotopyEquiv P Q).inv ‚â´ P.œÄ = Q.œÄ := by simp [homotopyEquiv]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.homotopyEquiv_inv_œÄ","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nX : C\nP Q : CategoryTheory.ProjectiveResolution X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.homotopyEquiv Q).inv P.œÄ) Q.œÄ","decl":"@[reassoc (attr := simp)]\ntheorem homotopyEquiv_inv_œÄ {X : C} (P Q : ProjectiveResolution X) :\n    (homotopyEquiv P Q).inv ‚â´ P.œÄ = Q.œÄ := by simp [homotopyEquiv]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.iso_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasProjectiveResolutions C\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nœÜ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (œÜ.f 0) (Q.œÄ.f 0)) (CategoryTheory.CategoryStruct.comp (P.œÄ.f 0) f)\nZ : HomotopyCategory C (ComplexShape.down Nat)\nh : Quiver.Hom ((CategoryTheory.projectiveResolutions C).obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp P.iso.inv (CategoryTheory.CategoryStruct.comp ((CategoryTheory.projectiveResolutions C).map f) h)) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.down Nat)).map œÜ) (CategoryTheory.CategoryStruct.comp Q.iso.inv h))","decl":"@[reassoc]\nlemma ProjectiveResolution.iso_inv_naturality {X Y : C} (f : X ‚ü∂ Y)\n    (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (œÜ : P.complex ‚ü∂ Q.complex) (comm : œÜ.f 0 ‚â´ Q.œÄ.f 0 = P.œÄ.f 0 ‚â´ f) :\n    P.iso.inv ‚â´ (projectiveResolutions C).map f =\n      (HomotopyCategory.quotient _ _).map œÜ ‚â´ Q.iso.inv := by\n  apply HomotopyCategory.eq_of_homotopy\n  apply liftHomotopy f\n  all_goals\n    aesop_cat\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.iso_inv_naturality","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasProjectiveResolutions C\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nœÜ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (œÜ.f 0) (Q.œÄ.f 0)) (CategoryTheory.CategoryStruct.comp (P.œÄ.f 0) f)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp P.iso.inv ((CategoryTheory.projectiveResolutions C).map f)) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.down Nat)).map œÜ) Q.iso.inv)","decl":"@[reassoc]\nlemma ProjectiveResolution.iso_inv_naturality {X Y : C} (f : X ‚ü∂ Y)\n    (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (œÜ : P.complex ‚ü∂ Q.complex) (comm : œÜ.f 0 ‚â´ Q.œÄ.f 0 = P.œÄ.f 0 ‚â´ f) :\n    P.iso.inv ‚â´ (projectiveResolutions C).map f =\n      (HomotopyCategory.quotient _ _).map œÜ ‚â´ Q.iso.inv := by\n  apply HomotopyCategory.eq_of_homotopy\n  apply liftHomotopy f\n  all_goals\n    aesop_cat\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.iso_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasProjectiveResolutions C\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nœÜ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (œÜ.f 0) (Q.œÄ.f 0)) (CategoryTheory.CategoryStruct.comp (P.œÄ.f 0) f)\nZ : HomotopyCategory C (ComplexShape.down Nat)\nh : Quiver.Hom ((HomotopyCategory.quotient C (ComplexShape.down Nat)).obj Q.complex) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.projectiveResolutions C).map f) (CategoryTheory.CategoryStruct.comp Q.iso.hom h)) (CategoryTheory.CategoryStruct.comp P.iso.hom (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.down Nat)).map œÜ) h))","decl":"@[reassoc]\nlemma ProjectiveResolution.iso_hom_naturality {X Y : C} (f : X ‚ü∂ Y)\n    (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (œÜ : P.complex ‚ü∂ Q.complex) (comm : œÜ.f 0 ‚â´ Q.œÄ.f 0 = P.œÄ.f 0 ‚â´ f) :\n    (projectiveResolutions C).map f ‚â´ Q.iso.hom =\n      P.iso.hom ‚â´ (HomotopyCategory.quotient _ _).map œÜ := by\n  rw [‚Üê cancel_epi (P.iso).inv, iso_inv_naturality_assoc f P Q œÜ comm,\n    Iso.inv_hom_id_assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.iso_hom_naturality","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasProjectiveResolutions C\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nœÜ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (œÜ.f 0) (Q.œÄ.f 0)) (CategoryTheory.CategoryStruct.comp (P.œÄ.f 0) f)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.projectiveResolutions C).map f) Q.iso.hom) (CategoryTheory.CategoryStruct.comp P.iso.hom ((HomotopyCategory.quotient C (ComplexShape.down Nat)).map œÜ))","decl":"@[reassoc]\nlemma ProjectiveResolution.iso_hom_naturality {X Y : C} (f : X ‚ü∂ Y)\n    (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (œÜ : P.complex ‚ü∂ Q.complex) (comm : œÜ.f 0 ‚â´ Q.œÄ.f 0 = P.œÄ.f 0 ‚â´ f) :\n    (projectiveResolutions C).map f ‚â´ Q.iso.hom =\n      P.iso.hom ‚â´ (HomotopyCategory.quotient _ _).map œÜ := by\n  rw [‚Üê cancel_epi (P.iso).inv, iso_inv_naturality_assoc f P Q œÜ comm,\n    Iso.inv_hom_id_assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.exact_d_f","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.EnoughProjectives C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ (CategoryTheory.ShortComplex.mk (CategoryTheory.Projective.d f) f ‚ãØ).Exact","decl":"variable {C} in\ntheorem exact_d_f {X Y : C} (f : X ‚ü∂ Y) :\n    (ShortComplex.mk (d f) f (by simp)).Exact := by\n  let Œ± : ShortComplex.mk (d f) f (by simp) ‚ü∂ ShortComplex.mk (kernel.Œπ f) f (by simp) :=\n    { œÑ‚ÇÅ := Projective.œÄ _\n      œÑ‚ÇÇ := ùüô _\n      œÑ‚ÇÉ := ùüô _ }\n  have : Epi Œ±.œÑ‚ÇÅ := by dsimp; infer_instance\n  have : IsIso Œ±.œÑ‚ÇÇ := by dsimp; infer_instance\n  have : Mono Œ±.œÑ‚ÇÉ := by dsimp; infer_instance\n  rw [ShortComplex.exact_iff_of_epi_of_isIso_of_mono Œ±]\n  apply ShortComplex.exact_of_f_is_kernel\n  apply kernelIsKernel\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.ofComplex_d_1_0","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.EnoughProjectives C\nZ : C\n‚ä¢ Eq ((CategoryTheory.ProjectiveResolution.ofComplex Z).d 1 0) (CategoryTheory.Projective.d (CategoryTheory.Projective.œÄ Z))","decl":"lemma ofComplex_d_1_0 :\n    (ofComplex Z).d 1 0 = d (Projective.œÄ Z) := by\n  simp [ofComplex]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.ofComplex_exactAt_succ","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.EnoughProjectives C\nZ : C\nn : Nat\n‚ä¢ HomologicalComplex.ExactAt (CategoryTheory.ProjectiveResolution.ofComplex Z) (HAdd.hAdd n 1)","decl":"lemma ofComplex_exactAt_succ (n : ‚Ñï) :\n    (ofComplex Z).ExactAt (n + 1) := by\n  rw [HomologicalComplex.exactAt_iff' _ (n + 1 + 1) (n + 1) n (by simp) (by simp)]\n  dsimp [ofComplex, HomologicalComplex.sc', HomologicalComplex.shortComplexFunctor',\n      ChainComplex.mk', ChainComplex.mk]\n  simp only [ChainComplex.of_d]\n  -- TODO: this should just be apply exact_d_f so something is missing\n  match n with\n  | 0 => apply exact_d_f\n  | n + 1 => apply exact_d_f\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.instProjectiveXNatOfComplex","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.EnoughProjectives C\nZ : C\nn : Nat\n‚ä¢ CategoryTheory.Projective ((CategoryTheory.ProjectiveResolution.ofComplex Z).X n)","decl":"instance (n : ‚Ñï) : Projective ((ofComplex Z).X n) := by\n  obtain (_ | _ | _ | n) := n <;> apply Projective.projective_over\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.of_def","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.EnoughProjectives C\nZ : C\n‚ä¢ Eq (CategoryTheory.ProjectiveResolution.of Z) (CategoryTheory.ProjectiveResolution.mk (CategoryTheory.ProjectiveResolution.ofComplex Z) ‚ãØ (((CategoryTheory.ProjectiveResolution.ofComplex Z).toSingle‚ÇÄEquiv Z).symm ‚ü®CategoryTheory.Projective.œÄ Z, ‚ãØ‚ü©) ‚ãØ)","decl":"/-- In any abelian category with enough projectives,\n`ProjectiveResolution.of Z` constructs an projective resolution of the object `Z`.\n-/\nirreducible_def of : ProjectiveResolution Z where\n  complex := ofComplex Z\n  œÄ := (ChainComplex.toSingle‚ÇÄEquiv _ _).symm ‚ü®Projective.œÄ Z, by\n          rw [ofComplex_d_1_0, assoc, kernel.condition, comp_zero]‚ü©\n  quasiIso := ‚ü®fun n => by\n    cases n\n    ¬∑ rw [ChainComplex.quasiIsoAt‚ÇÄ_iff, ShortComplex.quasiIso_iff_of_zeros']\n      ¬∑ dsimp\n        refine (ShortComplex.exact_and_epi_g_iff_of_iso ?_).2\n          ‚ü®exact_d_f (Projective.œÄ Z), by dsimp; infer_instance‚ü©\n        exact ShortComplex.isoMk (Iso.refl _) (Iso.refl _) (Iso.refl _)\n          (by simp [ofComplex]) (by simp)\n      all_goals rfl\n    ¬∑ rw [quasiIsoAt_iff_exactAt']\n      ¬∑ apply ofComplex_exactAt_succ\n      ¬∑ apply ChainComplex.exactAt_succ_single_obj‚ü©\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.instHasProjectiveResolution","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.EnoughProjectives C\nZ : C\n‚ä¢ CategoryTheory.HasProjectiveResolution Z","decl":"instance (priority := 100) (Z : C) : HasProjectiveResolution Z where out := ‚ü®of Z‚ü©\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.instHasProjectiveResolutions","module":"Mathlib.CategoryTheory.Abelian.ProjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.EnoughProjectives C\n‚ä¢ CategoryTheory.HasProjectiveResolutions C","decl":"instance (priority := 100) : HasProjectiveResolutions C where out _ := inferInstance\n\n"}
