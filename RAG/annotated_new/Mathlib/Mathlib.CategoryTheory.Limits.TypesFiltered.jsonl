{"name":"CategoryTheory.Limits.Types.FilteredColimit.rel_of_quot_rel","module":"Mathlib.CategoryTheory.Limits.TypesFiltered","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\nx y : Sigma fun j => F.obj j\na✝ : CategoryTheory.Limits.Types.Quot.Rel F x y\n⊢ CategoryTheory.Limits.Types.FilteredColimit.Rel F x y","decl":"theorem rel_of_quot_rel (x y : Σ j, F.obj j) :\n    Quot.Rel F x y → FilteredColimit.Rel.{v, u} F x y :=\n  fun ⟨f, h⟩ => ⟨y.1, f, 𝟙 y.1, by rw [← h, FunctorToTypes.map_id_apply]⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.FilteredColimit.eqvGen_quot_rel_of_rel","module":"Mathlib.CategoryTheory.Limits.TypesFiltered","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\nx y : Sigma fun j => F.obj j\na✝ : CategoryTheory.Limits.Types.FilteredColimit.Rel F x y\n⊢ Relation.EqvGen (CategoryTheory.Limits.Types.Quot.Rel F) x y","decl":"theorem eqvGen_quot_rel_of_rel (x y : Σ j, F.obj j) :\n    FilteredColimit.Rel.{v, u} F x y → Relation.EqvGen (Quot.Rel F) x y := fun ⟨k, f, g, h⟩ => by\n  refine Relation.EqvGen.trans _ ⟨k, F.map f x.2⟩ _ ?_ ?_\n  · exact (Relation.EqvGen.rel _ _ ⟨f, rfl⟩)\n  · exact (Relation.EqvGen.symm _ _ (Relation.EqvGen.rel _ _ ⟨g, h⟩))\n\n"}
{"name":"CategoryTheory.Limits.Types.FilteredColimit.rel_equiv","module":"Mathlib.CategoryTheory.Limits.TypesFiltered","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : CategoryTheory.IsFilteredOrEmpty J\n⊢ Equivalence (CategoryTheory.Limits.Types.FilteredColimit.Rel F)","decl":"protected theorem rel_equiv : _root_.Equivalence (FilteredColimit.Rel.{v, u} F) where\n  refl x := ⟨x.1, 𝟙 x.1, 𝟙 x.1, rfl⟩\n  symm := fun ⟨k, f, g, h⟩ => ⟨k, g, f, h.symm⟩\n  trans {x y z} := fun ⟨k, f, g, h⟩ ⟨k', f', g', h'⟩ =>\n    let ⟨l, fl, gl, _⟩ := IsFilteredOrEmpty.cocone_objs k k'\n    let ⟨m, n, hn⟩ := IsFilteredOrEmpty.cocone_maps (g ≫ fl) (f' ≫ gl)\n    ⟨m, f ≫ fl ≫ n, g' ≫ gl ≫ n,\n      calc\n        F.map (f ≫ fl ≫ n) x.2 = F.map (fl ≫ n) (F.map f x.2) := by simp\n        _ = F.map (fl ≫ n) (F.map g y.2) := by rw [h]\n        _ = F.map ((g ≫ fl) ≫ n) y.2 := by simp\n        _ = F.map ((f' ≫ gl) ≫ n) y.2 := by rw [hn]\n        _ = F.map (gl ≫ n) (F.map f' y.2) := by simp\n        _ = F.map (gl ≫ n) (F.map g' z.2) := by rw [h']\n        _ = F.map (g' ≫ gl ≫ n) z.2 := by simp⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.FilteredColimit.rel_eq_eqvGen_quot_rel","module":"Mathlib.CategoryTheory.Limits.TypesFiltered","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : CategoryTheory.IsFilteredOrEmpty J\n⊢ Eq (CategoryTheory.Limits.Types.FilteredColimit.Rel F) (Relation.EqvGen (CategoryTheory.Limits.Types.Quot.Rel F))","decl":"protected theorem rel_eq_eqvGen_quot_rel :\n    FilteredColimit.Rel.{v, u} F = Relation.EqvGen (Quot.Rel F) := by\n  ext ⟨j, x⟩ ⟨j', y⟩\n  constructor\n  · apply eqvGen_quot_rel_of_rel\n  · rw [← (FilteredColimit.rel_equiv F).eqvGen_iff]\n    exact Relation.EqvGen.mono (rel_of_quot_rel F)\n\n"}
{"name":"CategoryTheory.Limits.Types.FilteredColimit.colimit_eq_iff_aux","module":"Mathlib.CategoryTheory.Limits.TypesFiltered","initialProofState":"J : Type v\ninst✝² : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝¹ : CategoryTheory.IsFilteredOrEmpty J\ninst✝ : CategoryTheory.Limits.HasColimit F\ni j : J\nxi : F.obj i\nxj : F.obj j\n⊢ Iff (Eq ((CategoryTheory.Limits.Types.colimitCocone F).ι.app i xi) ((CategoryTheory.Limits.Types.colimitCocone F).ι.app j xj)) (CategoryTheory.Limits.Types.FilteredColimit.Rel F ⟨i, xi⟩ ⟨j, xj⟩)","decl":"theorem colimit_eq_iff_aux {i j : J} {xi : F.obj i} {xj : F.obj j} :\n    (colimitCocone F).ι.app i xi = (colimitCocone F).ι.app j xj ↔\n      FilteredColimit.Rel.{v, u} F ⟨i, xi⟩ ⟨j, xj⟩ := by\n  dsimp\n  rw [← (equivShrink _).symm.injective.eq_iff, Equiv.symm_apply_apply, Equiv.symm_apply_apply,\n    Quot.eq, FilteredColimit.rel_eq_eqvGen_quot_rel]\n\n"}
{"name":"CategoryTheory.Limits.Types.FilteredColimit.isColimit_eq_iff","module":"Mathlib.CategoryTheory.Limits.TypesFiltered","initialProofState":"J : Type v\ninst✝² : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝¹ : CategoryTheory.IsFilteredOrEmpty J\ninst✝ : CategoryTheory.Limits.HasColimit F\nt : CategoryTheory.Limits.Cocone F\nht : CategoryTheory.Limits.IsColimit t\ni j : J\nxi : F.obj i\nxj : F.obj j\n⊢ Iff (Eq (t.ι.app i xi) (t.ι.app j xj)) (Exists fun k => Exists fun f => Exists fun g => Eq (F.map f xi) (F.map g xj))","decl":"theorem isColimit_eq_iff {t : Cocone F} (ht : IsColimit t) {i j : J} {xi : F.obj i} {xj : F.obj j} :\n    t.ι.app i xi = t.ι.app j xj ↔ ∃ (k : _) (f : i ⟶ k) (g : j ⟶ k), F.map f xi = F.map g xj := by\n  refine Iff.trans ?_ (colimit_eq_iff_aux F)\n  rw [← (IsColimit.coconePointUniqueUpToIso ht (colimitCoconeIsColimit F)).toEquiv.injective.eq_iff]\n  convert Iff.rfl\n  · exact (congrFun\n      (IsColimit.comp_coconePointUniqueUpToIso_hom ht (colimitCoconeIsColimit F) _) xi).symm\n  · exact (congrFun\n      (IsColimit.comp_coconePointUniqueUpToIso_hom ht (colimitCoconeIsColimit F) _) xj).symm\n\n"}
{"name":"CategoryTheory.Limits.Types.FilteredColimit.colimit_eq_iff","module":"Mathlib.CategoryTheory.Limits.TypesFiltered","initialProofState":"J : Type v\ninst✝² : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝¹ : CategoryTheory.IsFilteredOrEmpty J\ninst✝ : CategoryTheory.Limits.HasColimit F\ni j : J\nxi : F.obj i\nxj : F.obj j\n⊢ Iff (Eq (CategoryTheory.Limits.colimit.ι F i xi) (CategoryTheory.Limits.colimit.ι F j xj)) (Exists fun k => Exists fun f => Exists fun g => Eq (F.map f xi) (F.map g xj))","decl":"theorem colimit_eq_iff {i j : J} {xi : F.obj i} {xj : F.obj j} :\n    colimit.ι F i xi = colimit.ι F j xj ↔\n      ∃ (k : _) (f : i ⟶ k) (g : j ⟶ k), F.map f xi = F.map g xj :=\n  isColimit_eq_iff _ (colimit.isColimit F)\n\n"}
