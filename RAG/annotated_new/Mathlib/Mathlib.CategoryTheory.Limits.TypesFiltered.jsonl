{"name":"CategoryTheory.Limits.Types.FilteredColimit.rel_of_quot_rel","module":"Mathlib.CategoryTheory.Limits.TypesFiltered","initialProofState":"J : Type v\ninstâœ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\nx y : Sigma fun j => F.obj j\naâœ : CategoryTheory.Limits.Types.Quot.Rel F x y\nâŠ¢ CategoryTheory.Limits.Types.FilteredColimit.Rel F x y","decl":"theorem rel_of_quot_rel (x y : Î£ j, F.obj j) :\n    Quot.Rel F x y â†’ FilteredColimit.Rel.{v, u} F x y :=\n  fun âŸ¨f, hâŸ© => âŸ¨y.1, f, ðŸ™ y.1, by rw [â† h, FunctorToTypes.map_id_apply]âŸ©\n\n"}
{"name":"CategoryTheory.Limits.Types.FilteredColimit.eqvGen_quot_rel_of_rel","module":"Mathlib.CategoryTheory.Limits.TypesFiltered","initialProofState":"J : Type v\ninstâœ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\nx y : Sigma fun j => F.obj j\naâœ : CategoryTheory.Limits.Types.FilteredColimit.Rel F x y\nâŠ¢ Relation.EqvGen (CategoryTheory.Limits.Types.Quot.Rel F) x y","decl":"theorem eqvGen_quot_rel_of_rel (x y : Î£ j, F.obj j) :\n    FilteredColimit.Rel.{v, u} F x y â†’ Relation.EqvGen (Quot.Rel F) x y := fun âŸ¨k, f, g, hâŸ© => by\n  refine Relation.EqvGen.trans _ âŸ¨k, F.map f x.2âŸ© _ ?_ ?_\n  Â· exact (Relation.EqvGen.rel _ _ âŸ¨f, rflâŸ©)\n  Â· exact (Relation.EqvGen.symm _ _ (Relation.EqvGen.rel _ _ âŸ¨g, hâŸ©))\n\n"}
{"name":"CategoryTheory.Limits.Types.FilteredColimit.rel_equiv","module":"Mathlib.CategoryTheory.Limits.TypesFiltered","initialProofState":"J : Type v\ninstâœÂ¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninstâœ : CategoryTheory.IsFilteredOrEmpty J\nâŠ¢ Equivalence (CategoryTheory.Limits.Types.FilteredColimit.Rel F)","decl":"protected theorem rel_equiv : _root_.Equivalence (FilteredColimit.Rel.{v, u} F) where\n  refl x := âŸ¨x.1, ðŸ™ x.1, ðŸ™ x.1, rflâŸ©\n  symm := fun âŸ¨k, f, g, hâŸ© => âŸ¨k, g, f, h.symmâŸ©\n  trans {x y z} := fun âŸ¨k, f, g, hâŸ© âŸ¨k', f', g', h'âŸ© =>\n    let âŸ¨l, fl, gl, _âŸ© := IsFilteredOrEmpty.cocone_objs k k'\n    let âŸ¨m, n, hnâŸ© := IsFilteredOrEmpty.cocone_maps (g â‰« fl) (f' â‰« gl)\n    âŸ¨m, f â‰« fl â‰« n, g' â‰« gl â‰« n,\n      calc\n        F.map (f â‰« fl â‰« n) x.2 = F.map (fl â‰« n) (F.map f x.2) := by simp\n        _ = F.map (fl â‰« n) (F.map g y.2) := by rw [h]\n        _ = F.map ((g â‰« fl) â‰« n) y.2 := by simp\n        _ = F.map ((f' â‰« gl) â‰« n) y.2 := by rw [hn]\n        _ = F.map (gl â‰« n) (F.map f' y.2) := by simp\n        _ = F.map (gl â‰« n) (F.map g' z.2) := by rw [h']\n        _ = F.map (g' â‰« gl â‰« n) z.2 := by simpâŸ©\n\n"}
{"name":"CategoryTheory.Limits.Types.FilteredColimit.rel_eq_eqvGen_quot_rel","module":"Mathlib.CategoryTheory.Limits.TypesFiltered","initialProofState":"J : Type v\ninstâœÂ¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninstâœ : CategoryTheory.IsFilteredOrEmpty J\nâŠ¢ Eq (CategoryTheory.Limits.Types.FilteredColimit.Rel F) (Relation.EqvGen (CategoryTheory.Limits.Types.Quot.Rel F))","decl":"protected theorem rel_eq_eqvGen_quot_rel :\n    FilteredColimit.Rel.{v, u} F = Relation.EqvGen (Quot.Rel F) := by\n  ext âŸ¨j, xâŸ© âŸ¨j', yâŸ©\n  constructor\n  Â· apply eqvGen_quot_rel_of_rel\n  Â· rw [â† (FilteredColimit.rel_equiv F).eqvGen_iff]\n    exact Relation.EqvGen.mono (rel_of_quot_rel F)\n\n"}
{"name":"CategoryTheory.Limits.Types.FilteredColimit.colimit_eq_iff_aux","module":"Mathlib.CategoryTheory.Limits.TypesFiltered","initialProofState":"J : Type v\ninstâœÂ² : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninstâœÂ¹ : CategoryTheory.IsFilteredOrEmpty J\ninstâœ : CategoryTheory.Limits.HasColimit F\ni j : J\nxi : F.obj i\nxj : F.obj j\nâŠ¢ Iff (Eq ((CategoryTheory.Limits.Types.colimitCocone F).Î¹.app i xi) ((CategoryTheory.Limits.Types.colimitCocone F).Î¹.app j xj)) (CategoryTheory.Limits.Types.FilteredColimit.Rel F âŸ¨i, xiâŸ© âŸ¨j, xjâŸ©)","decl":"theorem colimit_eq_iff_aux {i j : J} {xi : F.obj i} {xj : F.obj j} :\n    (colimitCocone F).Î¹.app i xi = (colimitCocone F).Î¹.app j xj â†”\n      FilteredColimit.Rel.{v, u} F âŸ¨i, xiâŸ© âŸ¨j, xjâŸ© := by\n  dsimp\n  rw [â† (equivShrink _).symm.injective.eq_iff, Equiv.symm_apply_apply, Equiv.symm_apply_apply,\n    Quot.eq, FilteredColimit.rel_eq_eqvGen_quot_rel]\n\n"}
{"name":"CategoryTheory.Limits.Types.FilteredColimit.isColimit_eq_iff","module":"Mathlib.CategoryTheory.Limits.TypesFiltered","initialProofState":"J : Type v\ninstâœÂ² : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninstâœÂ¹ : CategoryTheory.IsFilteredOrEmpty J\ninstâœ : CategoryTheory.Limits.HasColimit F\nt : CategoryTheory.Limits.Cocone F\nht : CategoryTheory.Limits.IsColimit t\ni j : J\nxi : F.obj i\nxj : F.obj j\nâŠ¢ Iff (Eq (t.Î¹.app i xi) (t.Î¹.app j xj)) (Exists fun k => Exists fun f => Exists fun g => Eq (F.map f xi) (F.map g xj))","decl":"theorem isColimit_eq_iff {t : Cocone F} (ht : IsColimit t) {i j : J} {xi : F.obj i} {xj : F.obj j} :\n    t.Î¹.app i xi = t.Î¹.app j xj â†” âˆƒ (k : _) (f : i âŸ¶ k) (g : j âŸ¶ k), F.map f xi = F.map g xj := by\n  refine Iff.trans ?_ (colimit_eq_iff_aux F)\n  rw [â† (IsColimit.coconePointUniqueUpToIso ht (colimitCoconeIsColimit F)).toEquiv.injective.eq_iff]\n  convert Iff.rfl\n  Â· exact (congrFun\n      (IsColimit.comp_coconePointUniqueUpToIso_hom ht (colimitCoconeIsColimit F) _) xi).symm\n  Â· exact (congrFun\n      (IsColimit.comp_coconePointUniqueUpToIso_hom ht (colimitCoconeIsColimit F) _) xj).symm\n\n"}
{"name":"CategoryTheory.Limits.Types.FilteredColimit.colimit_eq_iff","module":"Mathlib.CategoryTheory.Limits.TypesFiltered","initialProofState":"J : Type v\ninstâœÂ² : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninstâœÂ¹ : CategoryTheory.IsFilteredOrEmpty J\ninstâœ : CategoryTheory.Limits.HasColimit F\ni j : J\nxi : F.obj i\nxj : F.obj j\nâŠ¢ Iff (Eq (CategoryTheory.Limits.colimit.Î¹ F i xi) (CategoryTheory.Limits.colimit.Î¹ F j xj)) (Exists fun k => Exists fun f => Exists fun g => Eq (F.map f xi) (F.map g xj))","decl":"theorem colimit_eq_iff {i j : J} {xi : F.obj i} {xj : F.obj j} :\n    colimit.Î¹ F i xi = colimit.Î¹ F j xj â†”\n      âˆƒ (k : _) (f : i âŸ¶ k) (g : j âŸ¶ k), F.map f xi = F.map g xj :=\n  isColimit_eq_iff _ (colimit.isColimit F)\n\n"}
