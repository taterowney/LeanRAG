{"name":"CategoryTheory.Functor.ofCocone.map_id","module":"Mathlib.CategoryTheory.SmallObject.Iteration.FunctorOfCocone","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nJ : Type u\ninst‚úù : LinearOrder J\nj : J\nF : CategoryTheory.Functor (‚Üë(Set.Iio j)) C\nc : CategoryTheory.Limits.Cocone F\ni : J\nhi : LE.le i j\n‚ä¢ Eq (CategoryTheory.Functor.ofCocone.map c i i ‚ãØ hi) (CategoryTheory.CategoryStruct.id (CategoryTheory.Functor.ofCocone.obj c i))","decl":"lemma map_id (i : J) (hi : i ‚â§ j) :\n    map c i i (by rfl) hi = ùüô _:= by\n  dsimp [map]\n  obtain hi' | rfl := hi.lt_or_eq\n  ¬∑ rw [dif_pos hi', F.map_id, id_comp, Iso.hom_inv_id]\n  ¬∑ rw [dif_neg (by simp), dif_neg (by simp)]\n\n"}
{"name":"CategoryTheory.Functor.ofCocone.map_comp","module":"Mathlib.CategoryTheory.SmallObject.Iteration.FunctorOfCocone","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nJ : Type u\ninst‚úù : LinearOrder J\nj : J\nF : CategoryTheory.Functor (‚Üë(Set.Iio j)) C\nc : CategoryTheory.Limits.Cocone F\ni‚ÇÅ i‚ÇÇ i‚ÇÉ : J\nhi : LE.le i‚ÇÅ i‚ÇÇ\nhi' : LE.le i‚ÇÇ i‚ÇÉ\nhi‚ÇÉ : LE.le i‚ÇÉ j\n‚ä¢ Eq (CategoryTheory.Functor.ofCocone.map c i‚ÇÅ i‚ÇÉ ‚ãØ hi‚ÇÉ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.ofCocone.map c i‚ÇÅ i‚ÇÇ hi ‚ãØ) (CategoryTheory.Functor.ofCocone.map c i‚ÇÇ i‚ÇÉ hi' hi‚ÇÉ))","decl":"lemma map_comp (i‚ÇÅ i‚ÇÇ i‚ÇÉ : J) (hi : i‚ÇÅ ‚â§ i‚ÇÇ) (hi' : i‚ÇÇ ‚â§ i‚ÇÉ) (hi‚ÇÉ : i‚ÇÉ ‚â§ j) :\n    map c i‚ÇÅ i‚ÇÉ (hi.trans hi') hi‚ÇÉ =\n      map c i‚ÇÅ i‚ÇÇ hi (hi'.trans hi‚ÇÉ) ‚â´\n        map c i‚ÇÇ i‚ÇÉ hi' hi‚ÇÉ := by\n  obtain hi‚ÇÅ‚ÇÇ | rfl := hi.lt_or_eq\n  ¬∑ obtain hi‚ÇÇ‚ÇÉ | rfl := hi'.lt_or_eq\n    ¬∑ dsimp [map]\n      obtain hi‚ÇÉ' | rfl := hi‚ÇÉ.lt_or_eq\n      ¬∑ rw [dif_pos hi‚ÇÉ', dif_pos (hi‚ÇÇ‚ÇÉ.trans hi‚ÇÉ'), dif_pos hi‚ÇÉ', assoc, assoc,\n          Iso.inv_hom_id_assoc, ‚Üê Functor.map_comp_assoc, homOfLE_comp]\n      ¬∑ rw [dif_neg (by simp), dif_pos (hi‚ÇÅ‚ÇÇ.trans hi‚ÇÇ‚ÇÉ), dif_pos hi‚ÇÇ‚ÇÉ, dif_neg (by simp),\n          dif_pos hi‚ÇÇ‚ÇÉ, eqToHom_refl, comp_id, assoc, assoc, Iso.inv_hom_id_assoc,\n          Cocone.w_assoc]\n    ¬∑ rw [map_id, comp_id]\n  ¬∑ rw [map_id, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.ofCocone_map_to_top","module":"Mathlib.CategoryTheory.SmallObject.Iteration.FunctorOfCocone","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nJ : Type u\ninst‚úù : LinearOrder J\nj : J\nF : CategoryTheory.Functor (‚Üë(Set.Iio j)) C\nc : CategoryTheory.Limits.Cocone F\ni : J\nhi : LT.lt i j\n‚ä¢ Eq ((CategoryTheory.Functor.ofCocone c).map (CategoryTheory.homOfLE ‚ãØ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.ofCoconeObjIso c i hi).hom (CategoryTheory.CategoryStruct.comp (c.Œπ.app ‚ü®i, hi‚ü©) (CategoryTheory.Functor.ofCoconeObjIsoPt c).inv))","decl":"lemma ofCocone_map_to_top (i : J) (hi : i < j) :\n    (ofCocone c).map (homOfLE hi.le) =\n      (ofCoconeObjIso c i hi).hom ‚â´ c.Œπ.app ‚ü®i, hi‚ü© ‚â´ (ofCoconeObjIsoPt c).inv := by\n  dsimp [ofCocone, ofCocone.map, ofCoconeObjIso, ofCoconeObjIsoPt]\n  rw [dif_neg (by simp), dif_pos hi, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.ofCocone_map_assoc","module":"Mathlib.CategoryTheory.SmallObject.Iteration.FunctorOfCocone","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nJ : Type u\ninst‚úù : LinearOrder J\nj : J\nF : CategoryTheory.Functor (‚Üë(Set.Iio j)) C\nc : CategoryTheory.Limits.Cocone F\ni‚ÇÅ i‚ÇÇ : J\nhi : LE.le i‚ÇÅ i‚ÇÇ\nhi‚ÇÇ : LT.lt i‚ÇÇ j\nZ : C\nh : Quiver.Hom ((CategoryTheory.Functor.ofCocone c).obj ‚ü®i‚ÇÇ, ‚ãØ‚ü©) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.ofCocone c).map (CategoryTheory.homOfLE hi)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.ofCoconeObjIso c i‚ÇÅ ‚ãØ).hom (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.homOfLE hi)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.ofCoconeObjIso c i‚ÇÇ hi‚ÇÇ).inv h)))","decl":"@[reassoc]\nlemma ofCocone_map (i‚ÇÅ i‚ÇÇ : J) (hi : i‚ÇÅ ‚â§ i‚ÇÇ) (hi‚ÇÇ : i‚ÇÇ < j) :\n    (ofCocone c).map (homOfLE hi : ‚ü®i‚ÇÅ, hi.trans hi‚ÇÇ.le‚ü© ‚ü∂ ‚ü®i‚ÇÇ, hi‚ÇÇ.le‚ü©) =\n      (ofCoconeObjIso c i‚ÇÅ (lt_of_le_of_lt hi hi‚ÇÇ)).hom ‚â´ F.map (homOfLE hi) ‚â´\n        (ofCoconeObjIso c i‚ÇÇ hi‚ÇÇ).inv := by\n  dsimp [ofCocone, ofCoconeObjIso, ofCocone.map]\n  rw [dif_pos hi‚ÇÇ]\n\n"}
{"name":"CategoryTheory.Functor.ofCocone_map","module":"Mathlib.CategoryTheory.SmallObject.Iteration.FunctorOfCocone","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nJ : Type u\ninst‚úù : LinearOrder J\nj : J\nF : CategoryTheory.Functor (‚Üë(Set.Iio j)) C\nc : CategoryTheory.Limits.Cocone F\ni‚ÇÅ i‚ÇÇ : J\nhi : LE.le i‚ÇÅ i‚ÇÇ\nhi‚ÇÇ : LT.lt i‚ÇÇ j\n‚ä¢ Eq ((CategoryTheory.Functor.ofCocone c).map (CategoryTheory.homOfLE hi)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.ofCoconeObjIso c i‚ÇÅ ‚ãØ).hom (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.homOfLE hi)) (CategoryTheory.Functor.ofCoconeObjIso c i‚ÇÇ hi‚ÇÇ).inv))","decl":"@[reassoc]\nlemma ofCocone_map (i‚ÇÅ i‚ÇÇ : J) (hi : i‚ÇÅ ‚â§ i‚ÇÇ) (hi‚ÇÇ : i‚ÇÇ < j) :\n    (ofCocone c).map (homOfLE hi : ‚ü®i‚ÇÅ, hi.trans hi‚ÇÇ.le‚ü© ‚ü∂ ‚ü®i‚ÇÇ, hi‚ÇÇ.le‚ü©) =\n      (ofCoconeObjIso c i‚ÇÅ (lt_of_le_of_lt hi hi‚ÇÇ)).hom ‚â´ F.map (homOfLE hi) ‚â´\n        (ofCoconeObjIso c i‚ÇÇ hi‚ÇÇ).inv := by\n  dsimp [ofCocone, ofCoconeObjIso, ofCocone.map]\n  rw [dif_pos hi‚ÇÇ]\n\n"}
{"name":"CategoryTheory.Functor.ofCoconeObjIso_hom_naturality","module":"Mathlib.CategoryTheory.SmallObject.Iteration.FunctorOfCocone","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nJ : Type u\ninst‚úù : LinearOrder J\nj : J\nF : CategoryTheory.Functor (‚Üë(Set.Iio j)) C\nc : CategoryTheory.Limits.Cocone F\ni‚ÇÅ i‚ÇÇ : J\nhi : LE.le i‚ÇÅ i‚ÇÇ\nhi‚ÇÇ : LT.lt i‚ÇÇ j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.ofCocone c).map (CategoryTheory.homOfLE hi)) (CategoryTheory.Functor.ofCoconeObjIso c i‚ÇÇ hi‚ÇÇ).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.ofCoconeObjIso c i‚ÇÅ ‚ãØ).hom (F.map (CategoryTheory.homOfLE hi)))","decl":"@[reassoc]\nlemma ofCoconeObjIso_hom_naturality (i‚ÇÅ i‚ÇÇ : J) (hi : i‚ÇÅ ‚â§ i‚ÇÇ) (hi‚ÇÇ : i‚ÇÇ < j) :\n    (ofCocone c).map (homOfLE hi : ‚ü®i‚ÇÅ, hi.trans hi‚ÇÇ.le‚ü© ‚ü∂ ‚ü®i‚ÇÇ, hi‚ÇÇ.le‚ü©) ‚â´\n      (ofCoconeObjIso c i‚ÇÇ hi‚ÇÇ).hom =\n      (ofCoconeObjIso c i‚ÇÅ (lt_of_le_of_lt hi hi‚ÇÇ)).hom ‚â´ F.map (homOfLE hi) := by\n  rw [ofCocone_map c i‚ÇÅ i‚ÇÇ hi hi‚ÇÇ, assoc, assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.ofCoconeObjIso_hom_naturality_assoc","module":"Mathlib.CategoryTheory.SmallObject.Iteration.FunctorOfCocone","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nJ : Type u\ninst‚úù : LinearOrder J\nj : J\nF : CategoryTheory.Functor (‚Üë(Set.Iio j)) C\nc : CategoryTheory.Limits.Cocone F\ni‚ÇÅ i‚ÇÇ : J\nhi : LE.le i‚ÇÅ i‚ÇÇ\nhi‚ÇÇ : LT.lt i‚ÇÇ j\nZ : C\nh : Quiver.Hom (F.obj ‚ü®i‚ÇÇ, hi‚ÇÇ‚ü©) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.ofCocone c).map (CategoryTheory.homOfLE hi)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.ofCoconeObjIso c i‚ÇÇ hi‚ÇÇ).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.ofCoconeObjIso c i‚ÇÅ ‚ãØ).hom (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.homOfLE hi)) h))","decl":"@[reassoc]\nlemma ofCoconeObjIso_hom_naturality (i‚ÇÅ i‚ÇÇ : J) (hi : i‚ÇÅ ‚â§ i‚ÇÇ) (hi‚ÇÇ : i‚ÇÇ < j) :\n    (ofCocone c).map (homOfLE hi : ‚ü®i‚ÇÅ, hi.trans hi‚ÇÇ.le‚ü© ‚ü∂ ‚ü®i‚ÇÇ, hi‚ÇÇ.le‚ü©) ‚â´\n      (ofCoconeObjIso c i‚ÇÇ hi‚ÇÇ).hom =\n      (ofCoconeObjIso c i‚ÇÅ (lt_of_le_of_lt hi hi‚ÇÇ)).hom ‚â´ F.map (homOfLE hi) := by\n  rw [ofCocone_map c i‚ÇÅ i‚ÇÇ hi hi‚ÇÇ, assoc, assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.restrictionLTOfCoconeIso_inv_app","module":"Mathlib.CategoryTheory.SmallObject.Iteration.FunctorOfCocone","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nJ : Type u\ninst‚úù : LinearOrder J\nj : J\nF : CategoryTheory.Functor (‚Üë(Set.Iio j)) C\nc : CategoryTheory.Limits.Cocone F\nX : ‚Üë(Set.Iio j)\n‚ä¢ Eq ((CategoryTheory.Functor.restrictionLTOfCoconeIso c).inv.app X) (CategoryTheory.Functor.ofCoconeObjIso c ‚ÜëX ‚ãØ).inv","decl":"/-- The isomorphism expressing that `ofCocone c` extends the functor `F`\nwhen `c : Cocone F`. -/\n@[simps!]\ndef restrictionLTOfCoconeIso :\n    Iteration.restrictionLT (ofCocone c) (Preorder.le_refl j) ‚âÖ F :=\n  NatIso.ofComponents (fun ‚ü®i, hi‚ü© ‚Ü¶ ofCoconeObjIso c i hi)\n    (by intros; apply ofCoconeObjIso_hom_naturality)\n\n"}
{"name":"CategoryTheory.Functor.restrictionLTOfCoconeIso_hom_app","module":"Mathlib.CategoryTheory.SmallObject.Iteration.FunctorOfCocone","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nJ : Type u\ninst‚úù : LinearOrder J\nj : J\nF : CategoryTheory.Functor (‚Üë(Set.Iio j)) C\nc : CategoryTheory.Limits.Cocone F\nX : ‚Üë(Set.Iio j)\n‚ä¢ Eq ((CategoryTheory.Functor.restrictionLTOfCoconeIso c).hom.app X) (CategoryTheory.Functor.ofCoconeObjIso c ‚ÜëX ‚ãØ).hom","decl":"/-- The isomorphism expressing that `ofCocone c` extends the functor `F`\nwhen `c : Cocone F`. -/\n@[simps!]\ndef restrictionLTOfCoconeIso :\n    Iteration.restrictionLT (ofCocone c) (Preorder.le_refl j) ‚âÖ F :=\n  NatIso.ofComponents (fun ‚ü®i, hi‚ü© ‚Ü¶ ofCoconeObjIso c i hi)\n    (by intros; apply ofCoconeObjIso_hom_naturality)\n\n"}
