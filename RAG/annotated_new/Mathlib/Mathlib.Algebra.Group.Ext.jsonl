{"name":"AddMonoid.ext","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\nm₁ m₂ : AddMonoid M\nh_mul : Eq HAdd.hAdd HAdd.hAdd\n⊢ Eq m₁ m₂","decl":"@[to_additive (attr := ext)]\ntheorem Monoid.ext {M : Type u} ⦃m₁ m₂ : Monoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M)) :\n    m₁ = m₂ := by\n  have : m₁.toMulOneClass = m₂.toMulOneClass := MulOneClass.ext h_mul\n  have h₁ : m₁.one = m₂.one := congr_arg (·.one) this\n  let f : @MonoidHom M M m₁.toMulOneClass m₂.toMulOneClass :=\n    @MonoidHom.mk _ _ (_) _ (@OneHom.mk _ _ (_) _ id h₁)\n      (fun x y => congr_fun (congr_fun h_mul x) y)\n  have : m₁.npow = m₂.npow := by\n    ext n x\n    exact @MonoidHom.map_pow M M m₁ m₂ f x n\n  rcases m₁ with @⟨@⟨⟨_⟩⟩, ⟨_⟩⟩\n  rcases m₂ with @⟨@⟨⟨_⟩⟩, ⟨_⟩⟩\n  congr\n\n"}
{"name":"AddMonoid.ext_iff","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\nm₁ m₂ : AddMonoid M\n⊢ Iff (Eq m₁ m₂) (Eq HAdd.hAdd HAdd.hAdd)","decl":"@[to_additive (attr := ext)]\ntheorem Monoid.ext {M : Type u} ⦃m₁ m₂ : Monoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M)) :\n    m₁ = m₂ := by\n  have : m₁.toMulOneClass = m₂.toMulOneClass := MulOneClass.ext h_mul\n  have h₁ : m₁.one = m₂.one := congr_arg (·.one) this\n  let f : @MonoidHom M M m₁.toMulOneClass m₂.toMulOneClass :=\n    @MonoidHom.mk _ _ (_) _ (@OneHom.mk _ _ (_) _ id h₁)\n      (fun x y => congr_fun (congr_fun h_mul x) y)\n  have : m₁.npow = m₂.npow := by\n    ext n x\n    exact @MonoidHom.map_pow M M m₁ m₂ f x n\n  rcases m₁ with @⟨@⟨⟨_⟩⟩, ⟨_⟩⟩\n  rcases m₂ with @⟨@⟨⟨_⟩⟩, ⟨_⟩⟩\n  congr\n\n"}
{"name":"Monoid.ext_iff","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\nm₁ m₂ : Monoid M\n⊢ Iff (Eq m₁ m₂) (Eq HMul.hMul HMul.hMul)","decl":"@[to_additive (attr := ext)]\ntheorem Monoid.ext {M : Type u} ⦃m₁ m₂ : Monoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M)) :\n    m₁ = m₂ := by\n  have : m₁.toMulOneClass = m₂.toMulOneClass := MulOneClass.ext h_mul\n  have h₁ : m₁.one = m₂.one := congr_arg (·.one) this\n  let f : @MonoidHom M M m₁.toMulOneClass m₂.toMulOneClass :=\n    @MonoidHom.mk _ _ (_) _ (@OneHom.mk _ _ (_) _ id h₁)\n      (fun x y => congr_fun (congr_fun h_mul x) y)\n  have : m₁.npow = m₂.npow := by\n    ext n x\n    exact @MonoidHom.map_pow M M m₁ m₂ f x n\n  rcases m₁ with @⟨@⟨⟨_⟩⟩, ⟨_⟩⟩\n  rcases m₂ with @⟨@⟨⟨_⟩⟩, ⟨_⟩⟩\n  congr\n\n"}
{"name":"Monoid.ext","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\nm₁ m₂ : Monoid M\nh_mul : Eq HMul.hMul HMul.hMul\n⊢ Eq m₁ m₂","decl":"@[to_additive (attr := ext)]\ntheorem Monoid.ext {M : Type u} ⦃m₁ m₂ : Monoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M)) :\n    m₁ = m₂ := by\n  have : m₁.toMulOneClass = m₂.toMulOneClass := MulOneClass.ext h_mul\n  have h₁ : m₁.one = m₂.one := congr_arg (·.one) this\n  let f : @MonoidHom M M m₁.toMulOneClass m₂.toMulOneClass :=\n    @MonoidHom.mk _ _ (_) _ (@OneHom.mk _ _ (_) _ id h₁)\n      (fun x y => congr_fun (congr_fun h_mul x) y)\n  have : m₁.npow = m₂.npow := by\n    ext n x\n    exact @MonoidHom.map_pow M M m₁ m₂ f x n\n  rcases m₁ with @⟨@⟨⟨_⟩⟩, ⟨_⟩⟩\n  rcases m₂ with @⟨@⟨⟨_⟩⟩, ⟨_⟩⟩\n  congr\n\n"}
{"name":"AddCommMonoid.toAddMonoid_injective","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\n⊢ Function.Injective (@AddCommMonoid.toAddMonoid M)","decl":"@[to_additive]\ntheorem CommMonoid.toMonoid_injective {M : Type u} :\n    Function.Injective (@CommMonoid.toMonoid M) := by\n  rintro ⟨⟩ ⟨⟩ h\n  congr\n\n"}
{"name":"CommMonoid.toMonoid_injective","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\n⊢ Function.Injective (@CommMonoid.toMonoid M)","decl":"@[to_additive]\ntheorem CommMonoid.toMonoid_injective {M : Type u} :\n    Function.Injective (@CommMonoid.toMonoid M) := by\n  rintro ⟨⟩ ⟨⟩ h\n  congr\n\n"}
{"name":"AddCommMonoid.ext","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u_1\nm₁ m₂ : AddCommMonoid M\nh_mul : Eq HAdd.hAdd HAdd.hAdd\n⊢ Eq m₁ m₂","decl":"@[to_additive (attr := ext)]\ntheorem CommMonoid.ext {M : Type*} ⦃m₁ m₂ : CommMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M)) : m₁ = m₂ :=\n  CommMonoid.toMonoid_injective <| Monoid.ext h_mul\n\n"}
{"name":"AddCommMonoid.ext_iff","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u_1\nm₁ m₂ : AddCommMonoid M\n⊢ Iff (Eq m₁ m₂) (Eq HAdd.hAdd HAdd.hAdd)","decl":"@[to_additive (attr := ext)]\ntheorem CommMonoid.ext {M : Type*} ⦃m₁ m₂ : CommMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M)) : m₁ = m₂ :=\n  CommMonoid.toMonoid_injective <| Monoid.ext h_mul\n\n"}
{"name":"CommMonoid.ext_iff","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u_1\nm₁ m₂ : CommMonoid M\n⊢ Iff (Eq m₁ m₂) (Eq HMul.hMul HMul.hMul)","decl":"@[to_additive (attr := ext)]\ntheorem CommMonoid.ext {M : Type*} ⦃m₁ m₂ : CommMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M)) : m₁ = m₂ :=\n  CommMonoid.toMonoid_injective <| Monoid.ext h_mul\n\n"}
{"name":"CommMonoid.ext","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u_1\nm₁ m₂ : CommMonoid M\nh_mul : Eq HMul.hMul HMul.hMul\n⊢ Eq m₁ m₂","decl":"@[to_additive (attr := ext)]\ntheorem CommMonoid.ext {M : Type*} ⦃m₁ m₂ : CommMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M)) : m₁ = m₂ :=\n  CommMonoid.toMonoid_injective <| Monoid.ext h_mul\n\n"}
{"name":"LeftCancelMonoid.toMonoid_injective","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\n⊢ Function.Injective (@LeftCancelMonoid.toMonoid M)","decl":"@[to_additive]\ntheorem LeftCancelMonoid.toMonoid_injective {M : Type u} :\n    Function.Injective (@LeftCancelMonoid.toMonoid M) := by\n  rintro @⟨@⟨⟩⟩ @⟨@⟨⟩⟩ h\n  congr <;> injection h\n\n"}
{"name":"AddLeftCancelMonoid.toAddMonoid_injective","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\n⊢ Function.Injective (@AddLeftCancelMonoid.toAddMonoid M)","decl":"@[to_additive]\ntheorem LeftCancelMonoid.toMonoid_injective {M : Type u} :\n    Function.Injective (@LeftCancelMonoid.toMonoid M) := by\n  rintro @⟨@⟨⟩⟩ @⟨@⟨⟩⟩ h\n  congr <;> injection h\n\n"}
{"name":"AddLeftCancelMonoid.ext","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\nm₁ m₂ : AddLeftCancelMonoid M\nh_mul : Eq HAdd.hAdd HAdd.hAdd\n⊢ Eq m₁ m₂","decl":"@[to_additive (attr := ext)]\ntheorem LeftCancelMonoid.ext {M : Type u} ⦃m₁ m₂ : LeftCancelMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M)) :\n    m₁ = m₂ :=\n  LeftCancelMonoid.toMonoid_injective <| Monoid.ext h_mul\n\n"}
{"name":"LeftCancelMonoid.ext_iff","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\nm₁ m₂ : LeftCancelMonoid M\n⊢ Iff (Eq m₁ m₂) (Eq HMul.hMul HMul.hMul)","decl":"@[to_additive (attr := ext)]\ntheorem LeftCancelMonoid.ext {M : Type u} ⦃m₁ m₂ : LeftCancelMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M)) :\n    m₁ = m₂ :=\n  LeftCancelMonoid.toMonoid_injective <| Monoid.ext h_mul\n\n"}
{"name":"AddLeftCancelMonoid.ext_iff","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\nm₁ m₂ : AddLeftCancelMonoid M\n⊢ Iff (Eq m₁ m₂) (Eq HAdd.hAdd HAdd.hAdd)","decl":"@[to_additive (attr := ext)]\ntheorem LeftCancelMonoid.ext {M : Type u} ⦃m₁ m₂ : LeftCancelMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M)) :\n    m₁ = m₂ :=\n  LeftCancelMonoid.toMonoid_injective <| Monoid.ext h_mul\n\n"}
{"name":"LeftCancelMonoid.ext","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\nm₁ m₂ : LeftCancelMonoid M\nh_mul : Eq HMul.hMul HMul.hMul\n⊢ Eq m₁ m₂","decl":"@[to_additive (attr := ext)]\ntheorem LeftCancelMonoid.ext {M : Type u} ⦃m₁ m₂ : LeftCancelMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M)) :\n    m₁ = m₂ :=\n  LeftCancelMonoid.toMonoid_injective <| Monoid.ext h_mul\n\n"}
{"name":"AddRightCancelMonoid.toAddMonoid_injective","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\n⊢ Function.Injective (@AddRightCancelMonoid.toAddMonoid M)","decl":"@[to_additive]\ntheorem RightCancelMonoid.toMonoid_injective {M : Type u} :\n    Function.Injective (@RightCancelMonoid.toMonoid M) := by\n  rintro @⟨@⟨⟩⟩ @⟨@⟨⟩⟩ h\n  congr <;> injection h\n\n"}
{"name":"RightCancelMonoid.toMonoid_injective","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\n⊢ Function.Injective (@RightCancelMonoid.toMonoid M)","decl":"@[to_additive]\ntheorem RightCancelMonoid.toMonoid_injective {M : Type u} :\n    Function.Injective (@RightCancelMonoid.toMonoid M) := by\n  rintro @⟨@⟨⟩⟩ @⟨@⟨⟩⟩ h\n  congr <;> injection h\n\n"}
{"name":"RightCancelMonoid.ext","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\nm₁ m₂ : RightCancelMonoid M\nh_mul : Eq HMul.hMul HMul.hMul\n⊢ Eq m₁ m₂","decl":"@[to_additive (attr := ext)]\ntheorem RightCancelMonoid.ext {M : Type u} ⦃m₁ m₂ : RightCancelMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M))  :\n    m₁ = m₂ :=\n  RightCancelMonoid.toMonoid_injective <| Monoid.ext h_mul\n\n"}
{"name":"AddRightCancelMonoid.ext_iff","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\nm₁ m₂ : AddRightCancelMonoid M\n⊢ Iff (Eq m₁ m₂) (Eq HAdd.hAdd HAdd.hAdd)","decl":"@[to_additive (attr := ext)]\ntheorem RightCancelMonoid.ext {M : Type u} ⦃m₁ m₂ : RightCancelMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M))  :\n    m₁ = m₂ :=\n  RightCancelMonoid.toMonoid_injective <| Monoid.ext h_mul\n\n"}
{"name":"AddRightCancelMonoid.ext","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\nm₁ m₂ : AddRightCancelMonoid M\nh_mul : Eq HAdd.hAdd HAdd.hAdd\n⊢ Eq m₁ m₂","decl":"@[to_additive (attr := ext)]\ntheorem RightCancelMonoid.ext {M : Type u} ⦃m₁ m₂ : RightCancelMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M))  :\n    m₁ = m₂ :=\n  RightCancelMonoid.toMonoid_injective <| Monoid.ext h_mul\n\n"}
{"name":"RightCancelMonoid.ext_iff","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\nm₁ m₂ : RightCancelMonoid M\n⊢ Iff (Eq m₁ m₂) (Eq HMul.hMul HMul.hMul)","decl":"@[to_additive (attr := ext)]\ntheorem RightCancelMonoid.ext {M : Type u} ⦃m₁ m₂ : RightCancelMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M))  :\n    m₁ = m₂ :=\n  RightCancelMonoid.toMonoid_injective <| Monoid.ext h_mul\n\n"}
{"name":"CancelMonoid.toLeftCancelMonoid_injective","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\n⊢ Function.Injective (@CancelMonoid.toLeftCancelMonoid M)","decl":"@[to_additive]\ntheorem CancelMonoid.toLeftCancelMonoid_injective {M : Type u} :\n    Function.Injective (@CancelMonoid.toLeftCancelMonoid M) := by\n  rintro ⟨⟩ ⟨⟩ h\n  congr\n\n"}
{"name":"AddCancelMonoid.toAddLeftCancelMonoid_injective","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\n⊢ Function.Injective (@AddCancelMonoid.toAddLeftCancelMonoid M)","decl":"@[to_additive]\ntheorem CancelMonoid.toLeftCancelMonoid_injective {M : Type u} :\n    Function.Injective (@CancelMonoid.toLeftCancelMonoid M) := by\n  rintro ⟨⟩ ⟨⟩ h\n  congr\n\n"}
{"name":"CancelMonoid.ext_iff","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u_1\nm₁ m₂ : CancelMonoid M\n⊢ Iff (Eq m₁ m₂) (Eq HMul.hMul HMul.hMul)","decl":"@[to_additive (attr := ext)]\ntheorem CancelMonoid.ext {M : Type*} ⦃m₁ m₂ : CancelMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M)) :\n    m₁ = m₂ :=\n  CancelMonoid.toLeftCancelMonoid_injective <| LeftCancelMonoid.ext h_mul\n\n"}
{"name":"AddCancelMonoid.ext","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u_1\nm₁ m₂ : AddCancelMonoid M\nh_mul : Eq HAdd.hAdd HAdd.hAdd\n⊢ Eq m₁ m₂","decl":"@[to_additive (attr := ext)]\ntheorem CancelMonoid.ext {M : Type*} ⦃m₁ m₂ : CancelMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M)) :\n    m₁ = m₂ :=\n  CancelMonoid.toLeftCancelMonoid_injective <| LeftCancelMonoid.ext h_mul\n\n"}
{"name":"CancelMonoid.ext","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u_1\nm₁ m₂ : CancelMonoid M\nh_mul : Eq HMul.hMul HMul.hMul\n⊢ Eq m₁ m₂","decl":"@[to_additive (attr := ext)]\ntheorem CancelMonoid.ext {M : Type*} ⦃m₁ m₂ : CancelMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M)) :\n    m₁ = m₂ :=\n  CancelMonoid.toLeftCancelMonoid_injective <| LeftCancelMonoid.ext h_mul\n\n"}
{"name":"AddCancelMonoid.ext_iff","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u_1\nm₁ m₂ : AddCancelMonoid M\n⊢ Iff (Eq m₁ m₂) (Eq HAdd.hAdd HAdd.hAdd)","decl":"@[to_additive (attr := ext)]\ntheorem CancelMonoid.ext {M : Type*} ⦃m₁ m₂ : CancelMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M)) :\n    m₁ = m₂ :=\n  CancelMonoid.toLeftCancelMonoid_injective <| LeftCancelMonoid.ext h_mul\n\n"}
{"name":"CancelCommMonoid.toCommMonoid_injective","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\n⊢ Function.Injective (@CancelCommMonoid.toCommMonoid M)","decl":"@[to_additive]\ntheorem CancelCommMonoid.toCommMonoid_injective {M : Type u} :\n    Function.Injective (@CancelCommMonoid.toCommMonoid M) := by\n  rintro @⟨@⟨@⟨⟩⟩⟩ @⟨@⟨@⟨⟩⟩⟩ h\n  congr <;> {\n    injection h with h'\n    injection h' }\n\n"}
{"name":"AddCancelCommMonoid.toAddCommMonoid_injective","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u\n⊢ Function.Injective (@AddCancelCommMonoid.toAddCommMonoid M)","decl":"@[to_additive]\ntheorem CancelCommMonoid.toCommMonoid_injective {M : Type u} :\n    Function.Injective (@CancelCommMonoid.toCommMonoid M) := by\n  rintro @⟨@⟨@⟨⟩⟩⟩ @⟨@⟨@⟨⟩⟩⟩ h\n  congr <;> {\n    injection h with h'\n    injection h' }\n\n"}
{"name":"CancelCommMonoid.ext","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u_1\nm₁ m₂ : CancelCommMonoid M\nh_mul : Eq HMul.hMul HMul.hMul\n⊢ Eq m₁ m₂","decl":"@[to_additive (attr := ext)]\ntheorem CancelCommMonoid.ext {M : Type*} ⦃m₁ m₂ : CancelCommMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M)) :\n    m₁ = m₂ :=\n  CancelCommMonoid.toCommMonoid_injective <| CommMonoid.ext h_mul\n\n"}
{"name":"AddCancelCommMonoid.ext","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u_1\nm₁ m₂ : AddCancelCommMonoid M\nh_mul : Eq HAdd.hAdd HAdd.hAdd\n⊢ Eq m₁ m₂","decl":"@[to_additive (attr := ext)]\ntheorem CancelCommMonoid.ext {M : Type*} ⦃m₁ m₂ : CancelCommMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M)) :\n    m₁ = m₂ :=\n  CancelCommMonoid.toCommMonoid_injective <| CommMonoid.ext h_mul\n\n"}
{"name":"CancelCommMonoid.ext_iff","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u_1\nm₁ m₂ : CancelCommMonoid M\n⊢ Iff (Eq m₁ m₂) (Eq HMul.hMul HMul.hMul)","decl":"@[to_additive (attr := ext)]\ntheorem CancelCommMonoid.ext {M : Type*} ⦃m₁ m₂ : CancelCommMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M)) :\n    m₁ = m₂ :=\n  CancelCommMonoid.toCommMonoid_injective <| CommMonoid.ext h_mul\n\n"}
{"name":"AddCancelCommMonoid.ext_iff","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u_1\nm₁ m₂ : AddCancelCommMonoid M\n⊢ Iff (Eq m₁ m₂) (Eq HAdd.hAdd HAdd.hAdd)","decl":"@[to_additive (attr := ext)]\ntheorem CancelCommMonoid.ext {M : Type*} ⦃m₁ m₂ : CancelCommMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M)) :\n    m₁ = m₂ :=\n  CancelCommMonoid.toCommMonoid_injective <| CommMonoid.ext h_mul\n\n"}
{"name":"DivInvMonoid.ext_iff","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u_1\nm₁ m₂ : DivInvMonoid M\n⊢ Iff (Eq m₁ m₂) (And (Eq HMul.hMul HMul.hMul) (Eq Inv.inv Inv.inv))","decl":"@[to_additive (attr := ext)]\ntheorem DivInvMonoid.ext {M : Type*} ⦃m₁ m₂ : DivInvMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M))\n    (h_inv : (letI := m₁; Inv.inv : M → M) = (letI := m₂; Inv.inv : M → M)) : m₁ = m₂ := by\n  have h_mon := Monoid.ext h_mul\n  have h₁ : m₁.one = m₂.one := congr_arg (·.one) h_mon\n  let f : @MonoidHom M M m₁.toMulOneClass m₂.toMulOneClass :=\n    @MonoidHom.mk _ _ (_) _ (@OneHom.mk _ _ (_) _ id h₁)\n      (fun x y => congr_fun (congr_fun h_mul x) y)\n  have : m₁.npow = m₂.npow := congr_arg (·.npow) h_mon\n  have : m₁.zpow = m₂.zpow := by\n    ext m x\n    exact @MonoidHom.map_zpow' M M m₁ m₂ f (congr_fun h_inv) x m\n  have : m₁.div = m₂.div := by\n    ext a b\n    exact @map_div' _ _\n      (F := @MonoidHom _ _ (_) _) _ (id _) _\n      (@MonoidHom.instMonoidHomClass _ _ (_) _) f (congr_fun h_inv) a b\n  rcases m₁ with @⟨_, ⟨_⟩, ⟨_⟩⟩\n  rcases m₂ with @⟨_, ⟨_⟩, ⟨_⟩⟩\n  congr\n\n"}
{"name":"SubNegMonoid.ext_iff","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u_1\nm₁ m₂ : SubNegMonoid M\n⊢ Iff (Eq m₁ m₂) (And (Eq HAdd.hAdd HAdd.hAdd) (Eq Neg.neg Neg.neg))","decl":"@[to_additive (attr := ext)]\ntheorem DivInvMonoid.ext {M : Type*} ⦃m₁ m₂ : DivInvMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M))\n    (h_inv : (letI := m₁; Inv.inv : M → M) = (letI := m₂; Inv.inv : M → M)) : m₁ = m₂ := by\n  have h_mon := Monoid.ext h_mul\n  have h₁ : m₁.one = m₂.one := congr_arg (·.one) h_mon\n  let f : @MonoidHom M M m₁.toMulOneClass m₂.toMulOneClass :=\n    @MonoidHom.mk _ _ (_) _ (@OneHom.mk _ _ (_) _ id h₁)\n      (fun x y => congr_fun (congr_fun h_mul x) y)\n  have : m₁.npow = m₂.npow := congr_arg (·.npow) h_mon\n  have : m₁.zpow = m₂.zpow := by\n    ext m x\n    exact @MonoidHom.map_zpow' M M m₁ m₂ f (congr_fun h_inv) x m\n  have : m₁.div = m₂.div := by\n    ext a b\n    exact @map_div' _ _\n      (F := @MonoidHom _ _ (_) _) _ (id _) _\n      (@MonoidHom.instMonoidHomClass _ _ (_) _) f (congr_fun h_inv) a b\n  rcases m₁ with @⟨_, ⟨_⟩, ⟨_⟩⟩\n  rcases m₂ with @⟨_, ⟨_⟩, ⟨_⟩⟩\n  congr\n\n"}
{"name":"DivInvMonoid.ext","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u_1\nm₁ m₂ : DivInvMonoid M\nh_mul : Eq HMul.hMul HMul.hMul\nh_inv : Eq Inv.inv Inv.inv\n⊢ Eq m₁ m₂","decl":"@[to_additive (attr := ext)]\ntheorem DivInvMonoid.ext {M : Type*} ⦃m₁ m₂ : DivInvMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M))\n    (h_inv : (letI := m₁; Inv.inv : M → M) = (letI := m₂; Inv.inv : M → M)) : m₁ = m₂ := by\n  have h_mon := Monoid.ext h_mul\n  have h₁ : m₁.one = m₂.one := congr_arg (·.one) h_mon\n  let f : @MonoidHom M M m₁.toMulOneClass m₂.toMulOneClass :=\n    @MonoidHom.mk _ _ (_) _ (@OneHom.mk _ _ (_) _ id h₁)\n      (fun x y => congr_fun (congr_fun h_mul x) y)\n  have : m₁.npow = m₂.npow := congr_arg (·.npow) h_mon\n  have : m₁.zpow = m₂.zpow := by\n    ext m x\n    exact @MonoidHom.map_zpow' M M m₁ m₂ f (congr_fun h_inv) x m\n  have : m₁.div = m₂.div := by\n    ext a b\n    exact @map_div' _ _\n      (F := @MonoidHom _ _ (_) _) _ (id _) _\n      (@MonoidHom.instMonoidHomClass _ _ (_) _) f (congr_fun h_inv) a b\n  rcases m₁ with @⟨_, ⟨_⟩, ⟨_⟩⟩\n  rcases m₂ with @⟨_, ⟨_⟩, ⟨_⟩⟩\n  congr\n\n"}
{"name":"SubNegMonoid.ext","module":"Mathlib.Algebra.Group.Ext","initialProofState":"M : Type u_1\nm₁ m₂ : SubNegMonoid M\nh_mul : Eq HAdd.hAdd HAdd.hAdd\nh_inv : Eq Neg.neg Neg.neg\n⊢ Eq m₁ m₂","decl":"@[to_additive (attr := ext)]\ntheorem DivInvMonoid.ext {M : Type*} ⦃m₁ m₂ : DivInvMonoid M⦄\n    (h_mul : (letI := m₁; HMul.hMul : M → M → M) = (letI := m₂; HMul.hMul : M → M → M))\n    (h_inv : (letI := m₁; Inv.inv : M → M) = (letI := m₂; Inv.inv : M → M)) : m₁ = m₂ := by\n  have h_mon := Monoid.ext h_mul\n  have h₁ : m₁.one = m₂.one := congr_arg (·.one) h_mon\n  let f : @MonoidHom M M m₁.toMulOneClass m₂.toMulOneClass :=\n    @MonoidHom.mk _ _ (_) _ (@OneHom.mk _ _ (_) _ id h₁)\n      (fun x y => congr_fun (congr_fun h_mul x) y)\n  have : m₁.npow = m₂.npow := congr_arg (·.npow) h_mon\n  have : m₁.zpow = m₂.zpow := by\n    ext m x\n    exact @MonoidHom.map_zpow' M M m₁ m₂ f (congr_fun h_inv) x m\n  have : m₁.div = m₂.div := by\n    ext a b\n    exact @map_div' _ _\n      (F := @MonoidHom _ _ (_) _) _ (id _) _\n      (@MonoidHom.instMonoidHomClass _ _ (_) _) f (congr_fun h_inv) a b\n  rcases m₁ with @⟨_, ⟨_⟩, ⟨_⟩⟩\n  rcases m₂ with @⟨_, ⟨_⟩, ⟨_⟩⟩\n  congr\n\n"}
{"name":"Group.toDivInvMonoid_injective","module":"Mathlib.Algebra.Group.Ext","initialProofState":"G : Type u_1\n⊢ Function.Injective (@Group.toDivInvMonoid G)","decl":"@[to_additive]\nlemma Group.toDivInvMonoid_injective {G : Type*} : Injective (@Group.toDivInvMonoid G) := by\n  rintro ⟨⟩ ⟨⟩ ⟨⟩; rfl\n\n"}
{"name":"AddGroup.toSubNegAddMonoid_injective","module":"Mathlib.Algebra.Group.Ext","initialProofState":"G : Type u_1\n⊢ Function.Injective (@AddGroup.toSubNegMonoid G)","decl":"@[to_additive]\nlemma Group.toDivInvMonoid_injective {G : Type*} : Injective (@Group.toDivInvMonoid G) := by\n  rintro ⟨⟩ ⟨⟩ ⟨⟩; rfl\n\n"}
{"name":"Group.ext","module":"Mathlib.Algebra.Group.Ext","initialProofState":"G : Type u_1\ng₁ g₂ : Group G\nh_mul : Eq Mul.mul Mul.mul\n⊢ Eq g₁ g₂","decl":"@[to_additive (attr := ext)]\ntheorem Group.ext {G : Type*} ⦃g₁ g₂ : Group G⦄ (h_mul : g₁.mul = g₂.mul) : g₁ = g₂ := by\n  have h₁ : g₁.one = g₂.one := congr_arg (·.one) (Monoid.ext h_mul)\n  let f : @MonoidHom G G g₁.toMulOneClass g₂.toMulOneClass :=\n    @MonoidHom.mk _ _ (_) _ (@OneHom.mk _ _ (_) _ id h₁)\n      (fun x y => congr_fun (congr_fun h_mul x) y)\n  exact\n    Group.toDivInvMonoid_injective\n      (DivInvMonoid.ext h_mul\n        (funext <| @MonoidHom.map_inv G G g₁ g₂.toDivisionMonoid f))\n\n"}
{"name":"Group.ext_iff","module":"Mathlib.Algebra.Group.Ext","initialProofState":"G : Type u_1\ng₁ g₂ : Group G\n⊢ Iff (Eq g₁ g₂) (Eq Mul.mul Mul.mul)","decl":"@[to_additive (attr := ext)]\ntheorem Group.ext {G : Type*} ⦃g₁ g₂ : Group G⦄ (h_mul : g₁.mul = g₂.mul) : g₁ = g₂ := by\n  have h₁ : g₁.one = g₂.one := congr_arg (·.one) (Monoid.ext h_mul)\n  let f : @MonoidHom G G g₁.toMulOneClass g₂.toMulOneClass :=\n    @MonoidHom.mk _ _ (_) _ (@OneHom.mk _ _ (_) _ id h₁)\n      (fun x y => congr_fun (congr_fun h_mul x) y)\n  exact\n    Group.toDivInvMonoid_injective\n      (DivInvMonoid.ext h_mul\n        (funext <| @MonoidHom.map_inv G G g₁ g₂.toDivisionMonoid f))\n\n"}
{"name":"AddGroup.ext_iff","module":"Mathlib.Algebra.Group.Ext","initialProofState":"G : Type u_1\ng₁ g₂ : AddGroup G\n⊢ Iff (Eq g₁ g₂) (Eq Add.add Add.add)","decl":"@[to_additive (attr := ext)]\ntheorem Group.ext {G : Type*} ⦃g₁ g₂ : Group G⦄ (h_mul : g₁.mul = g₂.mul) : g₁ = g₂ := by\n  have h₁ : g₁.one = g₂.one := congr_arg (·.one) (Monoid.ext h_mul)\n  let f : @MonoidHom G G g₁.toMulOneClass g₂.toMulOneClass :=\n    @MonoidHom.mk _ _ (_) _ (@OneHom.mk _ _ (_) _ id h₁)\n      (fun x y => congr_fun (congr_fun h_mul x) y)\n  exact\n    Group.toDivInvMonoid_injective\n      (DivInvMonoid.ext h_mul\n        (funext <| @MonoidHom.map_inv G G g₁ g₂.toDivisionMonoid f))\n\n"}
{"name":"AddGroup.ext","module":"Mathlib.Algebra.Group.Ext","initialProofState":"G : Type u_1\ng₁ g₂ : AddGroup G\nh_mul : Eq Add.add Add.add\n⊢ Eq g₁ g₂","decl":"@[to_additive (attr := ext)]\ntheorem Group.ext {G : Type*} ⦃g₁ g₂ : Group G⦄ (h_mul : g₁.mul = g₂.mul) : g₁ = g₂ := by\n  have h₁ : g₁.one = g₂.one := congr_arg (·.one) (Monoid.ext h_mul)\n  let f : @MonoidHom G G g₁.toMulOneClass g₂.toMulOneClass :=\n    @MonoidHom.mk _ _ (_) _ (@OneHom.mk _ _ (_) _ id h₁)\n      (fun x y => congr_fun (congr_fun h_mul x) y)\n  exact\n    Group.toDivInvMonoid_injective\n      (DivInvMonoid.ext h_mul\n        (funext <| @MonoidHom.map_inv G G g₁ g₂.toDivisionMonoid f))\n\n"}
{"name":"CommGroup.toGroup_injective","module":"Mathlib.Algebra.Group.Ext","initialProofState":"G : Type u_1\n⊢ Function.Injective (@CommGroup.toGroup G)","decl":"@[to_additive]\nlemma CommGroup.toGroup_injective {G : Type*} : Injective (@CommGroup.toGroup G) := by\n  rintro ⟨⟩ ⟨⟩ ⟨⟩; rfl\n\n"}
{"name":"AddCommGroup.toAddGroup_injective","module":"Mathlib.Algebra.Group.Ext","initialProofState":"G : Type u_1\n⊢ Function.Injective (@AddCommGroup.toAddGroup G)","decl":"@[to_additive]\nlemma CommGroup.toGroup_injective {G : Type*} : Injective (@CommGroup.toGroup G) := by\n  rintro ⟨⟩ ⟨⟩ ⟨⟩; rfl\n\n"}
{"name":"CommGroup.ext_iff","module":"Mathlib.Algebra.Group.Ext","initialProofState":"G : Type u_1\ng₁ g₂ : CommGroup G\n⊢ Iff (Eq g₁ g₂) (Eq Mul.mul Mul.mul)","decl":"@[to_additive (attr := ext)]\ntheorem CommGroup.ext {G : Type*} ⦃g₁ g₂ : CommGroup G⦄ (h_mul : g₁.mul = g₂.mul) : g₁ = g₂ :=\n  CommGroup.toGroup_injective <| Group.ext h_mul\n"}
{"name":"AddCommGroup.ext","module":"Mathlib.Algebra.Group.Ext","initialProofState":"G : Type u_1\ng₁ g₂ : AddCommGroup G\nh_mul : Eq Add.add Add.add\n⊢ Eq g₁ g₂","decl":"@[to_additive (attr := ext)]\ntheorem CommGroup.ext {G : Type*} ⦃g₁ g₂ : CommGroup G⦄ (h_mul : g₁.mul = g₂.mul) : g₁ = g₂ :=\n  CommGroup.toGroup_injective <| Group.ext h_mul\n"}
{"name":"CommGroup.ext","module":"Mathlib.Algebra.Group.Ext","initialProofState":"G : Type u_1\ng₁ g₂ : CommGroup G\nh_mul : Eq Mul.mul Mul.mul\n⊢ Eq g₁ g₂","decl":"@[to_additive (attr := ext)]\ntheorem CommGroup.ext {G : Type*} ⦃g₁ g₂ : CommGroup G⦄ (h_mul : g₁.mul = g₂.mul) : g₁ = g₂ :=\n  CommGroup.toGroup_injective <| Group.ext h_mul\n"}
{"name":"AddCommGroup.ext_iff","module":"Mathlib.Algebra.Group.Ext","initialProofState":"G : Type u_1\ng₁ g₂ : AddCommGroup G\n⊢ Iff (Eq g₁ g₂) (Eq Add.add Add.add)","decl":"@[to_additive (attr := ext)]\ntheorem CommGroup.ext {G : Type*} ⦃g₁ g₂ : CommGroup G⦄ (h_mul : g₁.mul = g₂.mul) : g₁ = g₂ :=\n  CommGroup.toGroup_injective <| Group.ext h_mul\n"}
