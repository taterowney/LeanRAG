{"name":"MulAction.toPerm_symm_apply","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Group α\ninst✝ : MulAction α β\na : α\nx : β\n⊢ Eq ((Equiv.symm (MulAction.toPerm a)) x) (HSMul.hSMul (Inv.inv a) x)","decl":"/-- Given an action of a group `α` on `β`, each `g : α` defines a permutation of `β`. -/\n@[to_additive (attr := simps)]\ndef MulAction.toPerm (a : α) : Equiv.Perm β :=\n  ⟨fun x => a • x, fun x => a⁻¹ • x, inv_smul_smul a, smul_inv_smul a⟩\n\n"}
{"name":"AddAction.toPerm_apply","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\na : α\nx : β\n⊢ Eq ((AddAction.toPerm a) x) (HVAdd.hVAdd a x)","decl":"/-- Given an action of a group `α` on `β`, each `g : α` defines a permutation of `β`. -/\n@[to_additive (attr := simps)]\ndef MulAction.toPerm (a : α) : Equiv.Perm β :=\n  ⟨fun x => a • x, fun x => a⁻¹ • x, inv_smul_smul a, smul_inv_smul a⟩\n\n"}
{"name":"AddAction.toPerm_symm_apply","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\na : α\nx : β\n⊢ Eq ((Equiv.symm (AddAction.toPerm a)) x) (HVAdd.hVAdd (Neg.neg a) x)","decl":"/-- Given an action of a group `α` on `β`, each `g : α` defines a permutation of `β`. -/\n@[to_additive (attr := simps)]\ndef MulAction.toPerm (a : α) : Equiv.Perm β :=\n  ⟨fun x => a • x, fun x => a⁻¹ • x, inv_smul_smul a, smul_inv_smul a⟩\n\n"}
{"name":"MulAction.toPerm_apply","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Group α\ninst✝ : MulAction α β\na : α\nx : β\n⊢ Eq ((MulAction.toPerm a) x) (HSMul.hSMul a x)","decl":"/-- Given an action of a group `α` on `β`, each `g : α` defines a permutation of `β`. -/\n@[to_additive (attr := simps)]\ndef MulAction.toPerm (a : α) : Equiv.Perm β :=\n  ⟨fun x => a • x, fun x => a⁻¹ • x, inv_smul_smul a, smul_inv_smul a⟩\n\n"}
{"name":"MulAction.toPerm_injective","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Group α\ninst✝¹ : MulAction α β\ninst✝ : FaithfulSMul α β\n⊢ Function.Injective MulAction.toPerm","decl":"/-- `MulAction.toPerm` is injective on faithful actions. -/\n@[to_additive \"`AddAction.toPerm` is injective on faithful actions.\"]\nlemma MulAction.toPerm_injective [FaithfulSMul α β] :\n    Function.Injective (MulAction.toPerm : α → Equiv.Perm β) :=\n  (show Function.Injective (Equiv.toFun ∘ MulAction.toPerm) from smul_left_injective').of_comp\n\n"}
{"name":"AddAction.toPerm_injective","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddGroup α\ninst✝¹ : AddAction α β\ninst✝ : FaithfulVAdd α β\n⊢ Function.Injective AddAction.toPerm","decl":"/-- `MulAction.toPerm` is injective on faithful actions. -/\n@[to_additive \"`AddAction.toPerm` is injective on faithful actions.\"]\nlemma MulAction.toPerm_injective [FaithfulSMul α β] :\n    Function.Injective (MulAction.toPerm : α → Equiv.Perm β) :=\n  (show Function.Injective (Equiv.toFun ∘ MulAction.toPerm) from smul_left_injective').of_comp\n\n"}
{"name":"MulAction.toPermHom_apply","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Group α\ninst✝ : MulAction α β\na : α\n⊢ Eq ((MulAction.toPermHom α β) a) (MulAction.toPerm a)","decl":"/-- Given an action of a group `α` on a set `β`, each `g : α` defines a permutation of `β`. -/\n@[simps]\ndef MulAction.toPermHom : α →* Equiv.Perm β where\n  toFun := MulAction.toPerm\n  map_one' := Equiv.ext <| one_smul α\n  map_mul' u₁ u₂ := Equiv.ext <| mul_smul (u₁ : α) u₂\n\n"}
{"name":"AddAction.toPermHom_apply_apply","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"β : Type u_2\nα : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\na : α\nx : β\n⊢ Eq (((AddAction.toPermHom β α) a) x) (HVAdd.hVAdd a x)","decl":"/-- Given an action of an additive group `α` on a set `β`, each `g : α` defines a permutation of\n`β`. -/\n@[simps!]\ndef AddAction.toPermHom (α : Type*) [AddGroup α] [AddAction α β] :\n    α →+ Additive (Equiv.Perm β) :=\n  MonoidHom.toAdditive'' <| MulAction.toPermHom (Multiplicative α) β\n\n"}
{"name":"AddAction.toPermHom_apply_symm_apply","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"β : Type u_2\nα : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\na : α\nx : β\n⊢ Eq ((Equiv.symm ((AddAction.toPermHom β α) a)) x) (HSMul.hSMul (Inv.inv (Multiplicative.ofAdd a)) x)","decl":"/-- Given an action of an additive group `α` on a set `β`, each `g : α` defines a permutation of\n`β`. -/\n@[simps!]\ndef AddAction.toPermHom (α : Type*) [AddGroup α] [AddAction α β] :\n    α →+ Additive (Equiv.Perm β) :=\n  MonoidHom.toAdditive'' <| MulAction.toPermHom (Multiplicative α) β\n\n"}
{"name":"Equiv.Perm.smul_def","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_3\nf : Equiv.Perm α\na : α\n⊢ Eq (HSMul.hSMul f a) (f a)","decl":"@[simp]\nprotected lemma Equiv.Perm.smul_def {α : Type*} (f : Equiv.Perm α) (a : α) : f • a = f a :=\n  rfl\n\n"}
{"name":"Equiv.Perm.applyFaithfulSMul","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_3\n⊢ FaithfulSMul (Equiv.Perm α) α","decl":"/-- `Equiv.Perm.applyMulAction` is faithful. -/\ninstance Equiv.Perm.applyFaithfulSMul (α : Type*) : FaithfulSMul (Equiv.Perm α) α :=\n  ⟨Equiv.ext⟩\n\n"}
{"name":"MulAction.bijective","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Group α\ninst✝ : MulAction α β\ng : α\n⊢ Function.Bijective fun x => HSMul.hSMul g x","decl":"@[to_additive]\nprotected lemma MulAction.bijective (g : α) : Function.Bijective (g • · : β → β) :=\n  (MulAction.toPerm g).bijective\n\n"}
{"name":"AddAction.bijective","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ng : α\n⊢ Function.Bijective fun x => HVAdd.hVAdd g x","decl":"@[to_additive]\nprotected lemma MulAction.bijective (g : α) : Function.Bijective (g • · : β → β) :=\n  (MulAction.toPerm g).bijective\n\n"}
{"name":"AddAction.injective","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ng : α\n⊢ Function.Injective fun x => HVAdd.hVAdd g x","decl":"@[to_additive]\nprotected lemma MulAction.injective (g : α) : Function.Injective (g • · : β → β) :=\n  (MulAction.bijective g).injective\n\n"}
{"name":"MulAction.injective","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Group α\ninst✝ : MulAction α β\ng : α\n⊢ Function.Injective fun x => HSMul.hSMul g x","decl":"@[to_additive]\nprotected lemma MulAction.injective (g : α) : Function.Injective (g • · : β → β) :=\n  (MulAction.bijective g).injective\n\n"}
{"name":"AddAction.surjective","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ng : α\n⊢ Function.Surjective fun x => HVAdd.hVAdd g x","decl":"@[to_additive]\nprotected lemma MulAction.surjective (g : α) : Function.Surjective (g • · : β → β) :=\n  (MulAction.bijective g).surjective\n\n"}
{"name":"MulAction.surjective","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Group α\ninst✝ : MulAction α β\ng : α\n⊢ Function.Surjective fun x => HSMul.hSMul g x","decl":"@[to_additive]\nprotected lemma MulAction.surjective (g : α) : Function.Surjective (g • · : β → β) :=\n  (MulAction.bijective g).surjective\n\n"}
{"name":"vadd_left_cancel","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ng : α\nx y : β\nh : Eq (HVAdd.hVAdd g x) (HVAdd.hVAdd g y)\n⊢ Eq x y","decl":"@[to_additive]\nlemma smul_left_cancel (g : α) {x y : β} (h : g • x = g • y) : x = y := MulAction.injective g h\n\n"}
{"name":"smul_left_cancel","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Group α\ninst✝ : MulAction α β\ng : α\nx y : β\nh : Eq (HSMul.hSMul g x) (HSMul.hSMul g y)\n⊢ Eq x y","decl":"@[to_additive]\nlemma smul_left_cancel (g : α) {x y : β} (h : g • x = g • y) : x = y := MulAction.injective g h\n\n"}
{"name":"vadd_left_cancel_iff","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ng : α\nx y : β\n⊢ Iff (Eq (HVAdd.hVAdd g x) (HVAdd.hVAdd g y)) (Eq x y)","decl":"@[to_additive (attr := simp)]\nlemma smul_left_cancel_iff (g : α) {x y : β} : g • x = g • y ↔ x = y :=\n  (MulAction.injective g).eq_iff\n\n"}
{"name":"smul_left_cancel_iff","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Group α\ninst✝ : MulAction α β\ng : α\nx y : β\n⊢ Iff (Eq (HSMul.hSMul g x) (HSMul.hSMul g y)) (Eq x y)","decl":"@[to_additive (attr := simp)]\nlemma smul_left_cancel_iff (g : α) {x y : β} : g • x = g • y ↔ x = y :=\n  (MulAction.injective g).eq_iff\n\n"}
{"name":"smul_eq_iff_eq_inv_smul","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Group α\ninst✝ : MulAction α β\ng : α\nx y : β\n⊢ Iff (Eq (HSMul.hSMul g x) y) (Eq x (HSMul.hSMul (Inv.inv g) y))","decl":"@[to_additive]\nlemma smul_eq_iff_eq_inv_smul (g : α) {x y : β} : g • x = y ↔ x = g⁻¹ • y :=\n  (MulAction.toPerm g).apply_eq_iff_eq_symm_apply\n\n"}
{"name":"vadd_eq_iff_eq_neg_vadd","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ng : α\nx y : β\n⊢ Iff (Eq (HVAdd.hVAdd g x) y) (Eq x (HVAdd.hVAdd (Neg.neg g) y))","decl":"@[to_additive]\nlemma smul_eq_iff_eq_inv_smul (g : α) {x y : β} : g • x = y ↔ x = g⁻¹ • y :=\n  (MulAction.toPerm g).apply_eq_iff_eq_symm_apply\n\n"}
{"name":"invOf_smul_smul","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Monoid α\ninst✝¹ : MulAction α β\nc : α\nx : β\ninst✝ : Invertible c\n⊢ Eq (HSMul.hSMul (Invertible.invOf c) (HSMul.hSMul c x)) x","decl":"@[simp] lemma invOf_smul_smul : ⅟c • c • x = x := inv_smul_smul (unitOfInvertible c) _\n"}
{"name":"smul_invOf_smul","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Monoid α\ninst✝¹ : MulAction α β\nc : α\nx : β\ninst✝ : Invertible c\n⊢ Eq (HSMul.hSMul c (HSMul.hSMul (Invertible.invOf c) x)) x","decl":"@[simp] lemma smul_invOf_smul : c • (⅟ c • x) = x := smul_inv_smul (unitOfInvertible c) _\n\n"}
{"name":"invOf_smul_eq_iff","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Monoid α\ninst✝¹ : MulAction α β\nc : α\nx y : β\ninst✝ : Invertible c\n⊢ Iff (Eq (HSMul.hSMul (Invertible.invOf c) x) y) (Eq x (HSMul.hSMul c y))","decl":"lemma invOf_smul_eq_iff : ⅟c • x = y ↔ x = c • y := inv_smul_eq_iff (g := unitOfInvertible c)\n\n"}
{"name":"smul_eq_iff_eq_invOf_smul","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Monoid α\ninst✝¹ : MulAction α β\nc : α\nx y : β\ninst✝ : Invertible c\n⊢ Iff (Eq (HSMul.hSMul c x) y) (Eq x (HSMul.hSMul (Invertible.invOf c) y))","decl":"lemma smul_eq_iff_eq_invOf_smul : c • x = y ↔ x = ⅟c • y :=\n  smul_eq_iff_eq_inv_smul (g := unitOfInvertible c)\n\n"}
{"name":"arrowAction_smul","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"G : Type u_3\nA : Type u_4\nB : Type u_5\ninst✝¹ : DivisionMonoid G\ninst✝ : MulAction G A\ng : G\nF : A → B\na : A\n⊢ Eq (SMul.smul g F a) (F (HSMul.hSMul (Inv.inv g) a))","decl":"/-- If `G` acts on `A`, then it acts also on `A → B`, by `(g • F) a = F (g⁻¹ • a)`. -/\n@[to_additive (attr := simps) arrowAddAction\n      \"If `G` acts on `A`, then it acts also on `A → B`, by `(g +ᵥ F) a = F (g⁻¹ +ᵥ a)`\"]\ndef arrowAction {G A B : Type*} [DivisionMonoid G] [MulAction G A] : MulAction G (A → B) where\n  smul g F a := F (g⁻¹ • a)\n  one_smul f := by\n    show (fun x => f ((1 : G)⁻¹ • x)) = f\n    simp only [inv_one, one_smul]\n  mul_smul x y f := by\n    show (fun a => f ((x*y)⁻¹ • a)) = (fun a => f (y⁻¹ • x⁻¹ • a))\n    simp only [mul_smul, mul_inv_rev]\n\n"}
{"name":"arrowAddAction_vadd","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"G : Type u_3\nA : Type u_4\nB : Type u_5\ninst✝¹ : SubtractionMonoid G\ninst✝ : AddAction G A\ng : G\nF : A → B\na : A\n⊢ Eq (VAdd.vadd g F a) (F (HVAdd.hVAdd (Neg.neg g) a))","decl":"/-- If `G` acts on `A`, then it acts also on `A → B`, by `(g • F) a = F (g⁻¹ • a)`. -/\n@[to_additive (attr := simps) arrowAddAction\n      \"If `G` acts on `A`, then it acts also on `A → B`, by `(g +ᵥ F) a = F (g⁻¹ +ᵥ a)`\"]\ndef arrowAction {G A B : Type*} [DivisionMonoid G] [MulAction G A] : MulAction G (A → B) where\n  smul g F a := F (g⁻¹ • a)\n  one_smul f := by\n    show (fun x => f ((1 : G)⁻¹ • x)) = f\n    simp only [inv_one, one_smul]\n  mul_smul x y f := by\n    show (fun a => f ((x*y)⁻¹ • a)) = (fun a => f (y⁻¹ • x⁻¹ • a))\n    simp only [mul_smul, mul_inv_rev]\n\n"}
{"name":"IsUnit.smul_left_cancel","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Monoid α\ninst✝ : MulAction α β\na : α\nha : IsUnit a\nx y : β\n⊢ Iff (Eq (HSMul.hSMul a x) (HSMul.hSMul a y)) (Eq x y)","decl":"@[to_additive]\nlemma smul_left_cancel {a : α} (ha : IsUnit a) {x y : β} : a • x = a • y ↔ x = y :=\n  let ⟨u, hu⟩ := ha\n  hu ▸ smul_left_cancel_iff u\n\n"}
{"name":"IsAddUnit.vadd_left_cancel","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddMonoid α\ninst✝ : AddAction α β\na : α\nha : IsAddUnit a\nx y : β\n⊢ Iff (Eq (HVAdd.hVAdd a x) (HVAdd.hVAdd a y)) (Eq x y)","decl":"@[to_additive]\nlemma smul_left_cancel {a : α} (ha : IsUnit a) {x y : β} : a • x = a • y ↔ x = y :=\n  let ⟨u, hu⟩ := ha\n  hu ▸ smul_left_cancel_iff u\n\n"}
{"name":"isUnit_smul_iff","module":"Mathlib.Algebra.Group.Action.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Group α\ninst✝³ : Monoid β\ninst✝² : MulAction α β\ninst✝¹ : SMulCommClass α β β\ninst✝ : IsScalarTower α β β\ng : α\nm : β\n⊢ Iff (IsUnit (HSMul.hSMul g m)) (IsUnit m)","decl":"@[simp] lemma isUnit_smul_iff (g : α) (m : β) : IsUnit (g • m) ↔ IsUnit m :=\n  ⟨fun h => inv_smul_smul g m ▸ h.smul g⁻¹, IsUnit.smul g⟩\n\n"}
