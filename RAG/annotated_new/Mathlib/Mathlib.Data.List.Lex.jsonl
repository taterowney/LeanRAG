{"name":"List.Lex.cons_iff","module":"Mathlib.Data.List.Lex","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsIrrefl α r\na : α\nl₁ l₂ : List α\n⊢ Iff (List.Lex r (List.cons a l₁) (List.cons a l₂)) (List.Lex r l₁ l₂)","decl":"theorem cons_iff {r : α → α → Prop} [IsIrrefl α r] {a l₁ l₂} :\n    Lex r (a :: l₁) (a :: l₂) ↔ Lex r l₁ l₂ :=\n  ⟨fun h => by cases' h with _ _ _ _ _ h _ _ _ _ h; exacts [h, (irrefl_of r a h).elim], Lex.cons⟩\n\n"}
{"name":"List.Lex.not_nil_right","module":"Mathlib.Data.List.Lex","initialProofState":"α✝ : Type u_1\nr : α✝ → α✝ → Prop\nl : List α✝\n⊢ Not (List.Lex r l List.nil)","decl":"@[deprecated (since := \"2024-12-21\")] alias not_nil_right := not_lex_nil\n\n"}
{"name":"List.Lex.nil_left_or_eq_nil","module":"Mathlib.Data.List.Lex","initialProofState":"α : Type u\nr : α → α → Prop\nl : List α\n⊢ Or (List.Lex r List.nil l) (Eq l List.nil)","decl":"theorem nil_left_or_eq_nil {r : α → α → Prop} (l : List α) : List.Lex r [] l ∨ l = [] :=\n  match l with\n  | [] => Or.inr rfl\n  | (_ :: _) => Or.inl nil\n\n"}
{"name":"List.Lex.singleton_iff","module":"Mathlib.Data.List.Lex","initialProofState":"α : Type u\nr : α → α → Prop\na b : α\n⊢ Iff (List.Lex r (List.cons a List.nil) (List.cons b List.nil)) (r a b)","decl":"@[simp]\ntheorem singleton_iff {r : α → α → Prop} (a b : α) : List.Lex r [a] [b] ↔ r a b :=\n  ⟨fun | rel h => h, List.Lex.rel⟩\n\n"}
{"name":"List.Lex.isOrderConnected.aux","module":"Mathlib.Data.List.Lex","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsOrderConnected α r\nx✝³ x✝² x✝¹ : List α\nx✝ : List.Lex r x✝³ x✝¹\n⊢ Or (List.Lex r x✝³ x✝²) (List.Lex r x✝² x✝¹)","decl":"instance isOrderConnected (r : α → α → Prop) [IsOrderConnected α r] [IsTrichotomous α r] :\n    IsOrderConnected (List α) (Lex r) where\n  conn := aux where\n    aux\n    | _, [], _ :: _, nil => Or.inr nil\n    | _, [], _ :: _, rel _ => Or.inr nil\n    | _, [], _ :: _, cons _ => Or.inr nil\n    | _, _ :: _, _ :: _, nil => Or.inl nil\n    | _ :: _, b :: _, _ :: _, rel h => (IsOrderConnected.conn _ b _ h).imp rel rel\n    | a :: l₁, b :: l₂, _ :: l₃, cons h => by\n      rcases trichotomous_of r a b with (ab | rfl | ab)\n      · exact Or.inl (rel ab)\n      · exact (aux _ l₂ _ h).imp cons cons\n      · exact Or.inr (rel ab)\n\n"}
{"name":"List.Lex.isOrderConnected","module":"Mathlib.Data.List.Lex","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝¹ : IsOrderConnected α r\ninst✝ : IsTrichotomous α r\n⊢ IsOrderConnected (List α) (List.Lex r)","decl":"instance isOrderConnected (r : α → α → Prop) [IsOrderConnected α r] [IsTrichotomous α r] :\n    IsOrderConnected (List α) (Lex r) where\n  conn := aux where\n    aux\n    | _, [], _ :: _, nil => Or.inr nil\n    | _, [], _ :: _, rel _ => Or.inr nil\n    | _, [], _ :: _, cons _ => Or.inr nil\n    | _, _ :: _, _ :: _, nil => Or.inl nil\n    | _ :: _, b :: _, _ :: _, rel h => (IsOrderConnected.conn _ b _ h).imp rel rel\n    | a :: l₁, b :: l₂, _ :: l₃, cons h => by\n      rcases trichotomous_of r a b with (ab | rfl | ab)\n      · exact Or.inl (rel ab)\n      · exact (aux _ l₂ _ h).imp cons cons\n      · exact Or.inr (rel ab)\n\n"}
{"name":"List.Lex.isTrichotomous","module":"Mathlib.Data.List.Lex","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsTrichotomous α r\n⊢ IsTrichotomous (List α) (List.Lex r)","decl":"instance isTrichotomous (r : α → α → Prop) [IsTrichotomous α r] :\n    IsTrichotomous (List α) (Lex r) where\n  trichotomous := aux where\n    aux\n    | [], [] => Or.inr (Or.inl rfl)\n    | [], _ :: _ => Or.inl nil\n    | _ :: _, [] => Or.inr (Or.inr nil)\n    | a :: l₁, b :: l₂ => by\n      rcases trichotomous_of r a b with (ab | rfl | ab)\n      · exact Or.inl (rel ab)\n      · exact (aux l₁ l₂).imp cons (Or.imp (congr_arg _) cons)\n      · exact Or.inr (Or.inr (rel ab))\n\n"}
{"name":"List.Lex.isTrichotomous.aux","module":"Mathlib.Data.List.Lex","initialProofState":"α : Type u\nr : α → α → Prop\nx✝¹ x✝ : List α\n⊢ Or (List.Lex r x✝¹ x✝) (Or (Eq x✝¹ x✝) (List.Lex r x✝ x✝¹))","decl":"instance isTrichotomous (r : α → α → Prop) [IsTrichotomous α r] :\n    IsTrichotomous (List α) (Lex r) where\n  trichotomous := aux where\n    aux\n    | [], [] => Or.inr (Or.inl rfl)\n    | [], _ :: _ => Or.inl nil\n    | _ :: _, [] => Or.inr (Or.inr nil)\n    | a :: l₁, b :: l₂ => by\n      rcases trichotomous_of r a b with (ab | rfl | ab)\n      · exact Or.inl (rel ab)\n      · exact (aux l₁ l₂).imp cons (Or.imp (congr_arg _) cons)\n      · exact Or.inr (Or.inr (rel ab))\n\n"}
{"name":"List.Lex.isAsymm","module":"Mathlib.Data.List.Lex","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsAsymm α r\n⊢ IsAsymm (List α) (List.Lex r)","decl":"instance isAsymm (r : α → α → Prop) [IsAsymm α r] : IsAsymm (List α) (Lex r) where\n  asymm := aux where\n    aux\n    | _, _, Lex.rel h₁, Lex.rel h₂ => asymm h₁ h₂\n    | _, _, Lex.rel h₁, Lex.cons _ => asymm h₁ h₁\n    | _, _, Lex.cons _, Lex.rel h₂ => asymm h₂ h₂\n    | _, _, Lex.cons h₁, Lex.cons h₂ => aux _ _ h₁ h₂\n\n"}
{"name":"List.Lex.isAsymm.aux","module":"Mathlib.Data.List.Lex","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsAsymm α r\nx✝³ x✝² : List α\nx✝¹ : List.Lex r x✝³ x✝²\nx✝ : List.Lex r x✝² x✝³\n⊢ False","decl":"instance isAsymm (r : α → α → Prop) [IsAsymm α r] : IsAsymm (List α) (Lex r) where\n  asymm := aux where\n    aux\n    | _, _, Lex.rel h₁, Lex.rel h₂ => asymm h₁ h₂\n    | _, _, Lex.rel h₁, Lex.cons _ => asymm h₁ h₁\n    | _, _, Lex.cons _, Lex.rel h₂ => asymm h₂ h₂\n    | _, _, Lex.cons h₁, Lex.cons h₂ => aux _ _ h₁ h₂\n\n"}
{"name":"List.Lex.append_right","module":"Mathlib.Data.List.Lex","initialProofState":"α : Type u\nr : α → α → Prop\ns₁ s₂ t : List α\na✝ : List.Lex r s₁ s₂\n⊢ List.Lex r s₁ (HAppend.hAppend s₂ t)","decl":"theorem append_right (r : α → α → Prop) : ∀ {s₁ s₂} (t), Lex r s₁ s₂ → Lex r s₁ (s₂ ++ t)\n  | _, _, _, nil => nil\n  | _, _, _, cons h => cons (append_right r _ h)\n  | _, _, _, rel r => rel r\n\n"}
{"name":"List.Lex.append_left","module":"Mathlib.Data.List.Lex","initialProofState":"α : Type u\nR : α → α → Prop\nt₁ t₂ : List α\nh : List.Lex R t₁ t₂\ns : List α\n⊢ List.Lex R (HAppend.hAppend s t₁) (HAppend.hAppend s t₂)","decl":"theorem append_left (R : α → α → Prop) {t₁ t₂} (h : Lex R t₁ t₂) : ∀ s, Lex R (s ++ t₁) (s ++ t₂)\n  | [] => h\n  | _ :: l => cons (append_left R h l)\n\n"}
{"name":"List.Lex.imp","module":"Mathlib.Data.List.Lex","initialProofState":"α : Type u\nr s : α → α → Prop\nH : ∀ (a b : α), r a b → s a b\nl₁ l₂ : List α\na✝ : List.Lex r l₁ l₂\n⊢ List.Lex s l₁ l₂","decl":"theorem imp {r s : α → α → Prop} (H : ∀ a b, r a b → s a b) : ∀ l₁ l₂, Lex r l₁ l₂ → Lex s l₁ l₂\n  | _, _, nil => nil\n  | _, _, cons h => cons (imp H _ _ h)\n  | _, _, rel r => rel (H _ _ r)\n\n"}
{"name":"List.Lex.to_ne","module":"Mathlib.Data.List.Lex","initialProofState":"α : Type u\nl₁ l₂ : List α\na✝ : List.Lex (fun x1 x2 => Ne x1 x2) l₁ l₂\n⊢ Ne l₁ l₂","decl":"theorem to_ne : ∀ {l₁ l₂ : List α}, Lex (· ≠ ·) l₁ l₂ → l₁ ≠ l₂\n  | _, _, cons h, e => to_ne h (List.cons.inj e).2\n  | _, _, rel r, e => r (List.cons.inj e).1\n\n"}
{"name":"Decidable.List.Lex.ne_iff","module":"Mathlib.Data.List.Lex","initialProofState":"α : Type u\ninst✝ : DecidableEq α\nl₁ l₂ : List α\nH : LE.le l₁.length l₂.length\n⊢ Iff (List.Lex (fun x1 x2 => Ne x1 x2) l₁ l₂) (Ne l₁ l₂)","decl":"theorem _root_.Decidable.List.Lex.ne_iff [DecidableEq α] {l₁ l₂ : List α}\n    (H : length l₁ ≤ length l₂) : Lex (· ≠ ·) l₁ l₂ ↔ l₁ ≠ l₂ :=\n  ⟨to_ne, fun h => by\n    induction' l₁ with a l₁ IH generalizing l₂ <;> cases' l₂ with b l₂\n    · contradiction\n    · apply nil\n    · exact (not_lt_of_ge H).elim (succ_pos _)\n    · by_cases ab : a = b\n      · subst b\n        apply cons\n        exact IH (le_of_succ_le_succ H) (mt (congr_arg _) h)\n      · exact rel ab ⟩\n\n"}
{"name":"List.Lex.ne_iff","module":"Mathlib.Data.List.Lex","initialProofState":"α : Type u\nl₁ l₂ : List α\nH : LE.le l₁.length l₂.length\n⊢ Iff (List.Lex (fun x1 x2 => Ne x1 x2) l₁ l₂) (Ne l₁ l₂)","decl":"theorem ne_iff {l₁ l₂ : List α} (H : length l₁ ≤ length l₂) : Lex (· ≠ ·) l₁ l₂ ↔ l₁ ≠ l₂ := by\n  classical\n  exact Decidable.List.Lex.ne_iff H\n\n"}
{"name":"List.isStrictTotalOrder","module":"Mathlib.Data.List.Lex","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsStrictTotalOrder α r\n⊢ IsStrictTotalOrder (List α) (List.Lex r)","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-07-30\")]\ninstance isStrictTotalOrder (r : α → α → Prop) [IsStrictTotalOrder α r] :\n    IsStrictTotalOrder (List α) (Lex r) :=\n  { isStrictWeakOrder_of_isOrderConnected with }\n\n"}
{"name":"List.lt_iff_lex_lt","module":"Mathlib.Data.List.Lex","initialProofState":"α : Type u\ninst✝ : LinearOrder α\nl l' : List α\n⊢ Iff (l.lt l') (List.Lex (fun x1 x2 => LT.lt x1 x2) l l')","decl":"theorem lt_iff_lex_lt [LinearOrder α] (l l' : List α) : List.lt l l' ↔ Lex (· < ·) l l' := by\n  rw [List.lt]\n\n"}
{"name":"List.head_le_of_lt","module":"Mathlib.Data.List.Lex","initialProofState":"α : Type u\ninst✝ : Preorder α\na a' : α\nl l' : List α\nh : LT.lt (List.cons a' l') (List.cons a l)\n⊢ LE.le a' a","decl":"theorem head_le_of_lt [Preorder α] {a a' : α} {l l' : List α} (h : (a' :: l') < (a :: l)) :\n    a' ≤ a :=\n  match h with\n  | .cons _ => le_rfl\n  | .rel h => h.le\n\n"}
{"name":"List.head!_le_of_lt","module":"Mathlib.Data.List.Lex","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : Inhabited α\nl l' : List α\nh : LT.lt l' l\nhl' : Ne l' List.nil\n⊢ LE.le l'.head! l.head!","decl":"theorem head!_le_of_lt [Preorder α] [Inhabited α] (l l' : List α) (h : l' < l) (hl' : l' ≠ []) :\n    l'.head! ≤ l.head! := by\n  replace h : List.Lex (· < ·) l' l := h\n  by_cases hl : l = []\n  · simp [hl] at h\n  · rw [← List.cons_head!_tail hl', ← List.cons_head!_tail hl] at h\n    exact head_le_of_lt h\n\n"}
{"name":"List.cons_le_cons","module":"Mathlib.Data.List.Lex","initialProofState":"α : Type u\ninst✝ : LinearOrder α\na : α\nl l' : List α\nh : LE.le l' l\n⊢ LE.le (List.cons a l') (List.cons a l)","decl":"theorem cons_le_cons [LinearOrder α] (a : α) {l l' : List α} (h : l' ≤ l) :\n    a :: l' ≤ a :: l := by\n  rw [le_iff_lt_or_eq] at h ⊢\n  exact h.imp .cons (congr_arg _)\n\n"}
