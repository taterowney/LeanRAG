{"name":"WithBot.nontrivial","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : Nonempty α\n⊢ Nontrivial (WithBot α)","decl":"instance nontrivial [Nonempty α] : Nontrivial (WithBot α) :=\n  Option.nontrivial\n\n"}
{"name":"WithBot.coe_injective","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\n⊢ Function.Injective WithBot.some","decl":"theorem coe_injective : Injective ((↑) : α → WithBot α) :=\n  Option.some_injective _\n\n"}
{"name":"WithBot.coe_inj","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na b : α\n⊢ Iff (Eq ↑a ↑b) (Eq a b)","decl":"@[simp, norm_cast]\ntheorem coe_inj : (a : WithBot α) = b ↔ a = b :=\n  Option.some_inj\n\n"}
{"name":"WithBot.forall","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\np : WithBot α → Prop\n⊢ Iff (∀ (x : WithBot α), p x) (And (p Bot.bot) (∀ (x : α), p ↑x))","decl":"protected theorem «forall» {p : WithBot α → Prop} : (∀ x, p x) ↔ p ⊥ ∧ ∀ x : α, p x :=\n  Option.forall\n\n"}
{"name":"WithBot.exists","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\np : WithBot α → Prop\n⊢ Iff (Exists fun x => p x) (Or (p Bot.bot) (Exists fun x => p ↑x))","decl":"protected theorem «exists» {p : WithBot α → Prop} : (∃ x, p x) ↔ p ⊥ ∨ ∃ x : α, p x :=\n  Option.exists\n\n"}
{"name":"WithBot.none_eq_bot","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\n⊢ Eq Option.none Bot.bot","decl":"theorem none_eq_bot : (none : WithBot α) = (⊥ : WithBot α) :=\n  rfl\n\n"}
{"name":"WithBot.some_eq_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : α\n⊢ Eq (Option.some a) ↑a","decl":"theorem some_eq_coe (a : α) : (Option.some a : WithBot α) = (↑a : WithBot α) :=\n  rfl\n\n"}
{"name":"WithBot.bot_ne_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : α\n⊢ Ne Bot.bot ↑a","decl":"@[simp]\ntheorem bot_ne_coe : ⊥ ≠ (a : WithBot α) :=\n  nofun\n\n"}
{"name":"WithBot.coe_ne_bot","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : α\n⊢ Ne (↑a) Bot.bot","decl":"@[simp]\ntheorem coe_ne_bot : (a : WithBot α) ≠ ⊥ :=\n  nofun\n\n"}
{"name":"WithBot.unbot'_bot","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_5\nd : α\n⊢ Eq (WithBot.unbot' d Bot.bot) d","decl":"@[simp]\ntheorem unbot'_bot {α} (d : α) : unbot' d ⊥ = d :=\n  rfl\n\n"}
{"name":"WithBot.unbot'_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_5\nd x : α\n⊢ Eq (WithBot.unbot' d ↑x) x","decl":"@[simp]\ntheorem unbot'_coe {α} (d x : α) : unbot' d x = x :=\n  rfl\n\n"}
{"name":"WithBot.coe_eq_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na b : α\n⊢ Iff (Eq ↑a ↑b) (Eq a b)","decl":"theorem coe_eq_coe : (a : WithBot α) = b ↔ a = b := coe_inj\n\n"}
{"name":"WithBot.unbot'_eq_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nd y : α\nx : WithBot α\n⊢ Iff (Eq (WithBot.unbot' d x) y) (Or (Eq x ↑y) (And (Eq x Bot.bot) (Eq y d)))","decl":"theorem unbot'_eq_iff {d y : α} {x : WithBot α} : unbot' d x = y ↔ x = y ∨ x = ⊥ ∧ y = d := by\n  induction x <;> simp [@eq_comm _ d]\n\n"}
{"name":"WithBot.unbot'_eq_self_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nd : α\nx : WithBot α\n⊢ Iff (Eq (WithBot.unbot' d x) d) (Or (Eq x ↑d) (Eq x Bot.bot))","decl":"@[simp] theorem unbot'_eq_self_iff {d : α} {x : WithBot α} : unbot' d x = d ↔ x = d ∨ x = ⊥ := by\n  simp [unbot'_eq_iff]\n\n"}
{"name":"WithBot.unbot'_eq_unbot'_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nd : α\nx y : WithBot α\n⊢ Iff (Eq (WithBot.unbot' d x) (WithBot.unbot' d y)) (Or (Eq x y) (Or (And (Eq x ↑d) (Eq y Bot.bot)) (And (Eq x Bot.bot) (Eq y ↑d))))","decl":"theorem unbot'_eq_unbot'_iff {d : α} {x y : WithBot α} :\n    unbot' d x = unbot' d y ↔ x = y ∨ x = d ∧ y = ⊥ ∨ x = ⊥ ∧ y = d := by\n induction y <;> simp [unbot'_eq_iff, or_comm]\n\n"}
{"name":"WithBot.map_bot","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (WithBot.map f Bot.bot) Bot.bot","decl":"@[simp]\ntheorem map_bot (f : α → β) : map f ⊥ = ⊥ :=\n  rfl\n\n"}
{"name":"WithBot.map_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : α\n⊢ Eq (WithBot.map f ↑a) ↑(f a)","decl":"@[simp]\ntheorem map_coe (f : α → β) (a : α) : map f a = f a :=\n  rfl\n\n"}
{"name":"WithBot.map_eq_bot_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : WithBot α\n⊢ Iff (Eq (WithBot.map f a) Bot.bot) (Eq a Bot.bot)","decl":"@[simp]\nlemma map_eq_bot_iff {f : α → β} {a : WithBot α} :\n    map f a = ⊥ ↔ a = ⊥ := Option.map_eq_none'\n\n"}
{"name":"WithBot.map_eq_some_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ny : β\nv : WithBot α\n⊢ Iff (Eq (WithBot.map f v) ↑y) (Exists fun x => And (Eq v ↑x) (Eq (f x) y))","decl":"theorem map_eq_some_iff {f : α → β} {y : β} {v : WithBot α} :\n    WithBot.map f v = .some y ↔ ∃ x, v = .some x ∧ f x = y := Option.map_eq_some'\n\n"}
{"name":"WithBot.some_eq_map_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ny : β\nv : WithBot α\n⊢ Iff (Eq (↑y) (WithBot.map f v)) (Exists fun x => And (Eq v ↑x) (Eq (f x) y))","decl":"theorem some_eq_map_iff {f : α → β} {y : β} {v : WithBot α} :\n    .some y = WithBot.map f v ↔ ∃ x, v = .some x ∧ f x = y := by\n  cases v <;> simp [eq_comm]\n\n"}
{"name":"WithBot.map_comm","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf₁ : α → β\nf₂ : α → γ\ng₁ : β → δ\ng₂ : γ → δ\nh : Eq (Function.comp g₁ f₁) (Function.comp g₂ f₂)\na : α\n⊢ Eq (WithBot.map g₁ (WithBot.map f₁ ↑a)) (WithBot.map g₂ (WithBot.map f₂ ↑a))","decl":"theorem map_comm {f₁ : α → β} {f₂ : α → γ} {g₁ : β → δ} {g₂ : γ → δ}\n    (h : g₁ ∘ f₁ = g₂ ∘ f₂) (a : α) :\n    map g₁ (map f₁ a) = map g₂ (map f₂ a) :=\n  Option.map_comm h _\n\n"}
{"name":"WithBot.map₂_coe_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\na : α\nb : β\n⊢ Eq (WithBot.map₂ f ↑a ↑b) ↑(f a b)","decl":"lemma map₂_coe_coe (f : α → β → γ) (a : α) (b : β) : map₂ f a b = f a b := rfl\n"}
{"name":"WithBot.map₂_bot_left","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\nb : WithBot β\n⊢ Eq (WithBot.map₂ f Bot.bot b) Bot.bot","decl":"@[simp] lemma map₂_bot_left (f : α → β → γ) (b) : map₂ f ⊥ b = ⊥ := rfl\n"}
{"name":"WithBot.map₂_bot_right","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\na : WithBot α\n⊢ Eq (WithBot.map₂ f a Bot.bot) Bot.bot","decl":"@[simp] lemma map₂_bot_right (f : α → β → γ) (a) : map₂ f a ⊥ = ⊥ := by cases a <;> rfl\n"}
{"name":"WithBot.map₂_coe_left","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\na : α\nb : WithBot β\n⊢ Eq (WithBot.map₂ f (↑a) b) (WithBot.map (fun b => f a b) b)","decl":"@[simp] lemma map₂_coe_left (f : α → β → γ) (a : α) (b) : map₂ f a b = b.map fun b ↦ f a b := rfl\n"}
{"name":"WithBot.map₂_coe_right","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\na : WithBot α\nb : β\n⊢ Eq (WithBot.map₂ f a ↑b) (WithBot.map (fun x => f x b) a)","decl":"@[simp] lemma map₂_coe_right (f : α → β → γ) (a) (b : β) : map₂ f a b = a.map (f · b) := by\n  cases a <;> rfl\n\n"}
{"name":"WithBot.map₂_eq_bot_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\na : WithBot α\nb : WithBot β\n⊢ Iff (Eq (WithBot.map₂ f a b) Bot.bot) (Or (Eq a Bot.bot) (Eq b Bot.bot))","decl":"@[simp] lemma map₂_eq_bot_iff {f : α → β → γ} {a : WithBot α} {b : WithBot β} :\n    map₂ f a b = ⊥ ↔ a = ⊥ ∨ b = ⊥ := Option.map₂_eq_none_iff\n\n"}
{"name":"WithBot.ne_bot_iff_exists","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nx : WithBot α\n⊢ Iff (Ne x Bot.bot) (Exists fun a => Eq (↑a) x)","decl":"lemma ne_bot_iff_exists {x : WithBot α} : x ≠ ⊥ ↔ ∃ a : α, ↑a = x := Option.ne_none_iff_exists\n\n"}
{"name":"WithBot.forall_ne_iff_eq_bot","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nx : WithBot α\n⊢ Iff (∀ (a : α), Ne (↑a) x) (Eq x Bot.bot)","decl":"lemma forall_ne_iff_eq_bot {x : WithBot α} : (∀ a : α, ↑a ≠ x) ↔ x = ⊥ :=\n  Option.forall_some_ne_iff_eq_none\n\n"}
{"name":"WithBot.coe_unbot","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nx : WithBot α\nhx : Ne x Bot.bot\n⊢ Eq (↑(x.unbot hx)) x","decl":"@[simp] lemma coe_unbot : ∀ (x : WithBot α) hx, x.unbot hx = x | (x : α), _ => rfl\n\n"}
{"name":"WithBot.unbot_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nx : α\nh : optParam (Ne (↑x) Bot.bot) ⋯\n⊢ Eq ((↑x).unbot h) x","decl":"@[simp]\ntheorem unbot_coe (x : α) (h : (x : WithBot α) ≠ ⊥ := coe_ne_bot) : (x : WithBot α).unbot h = x :=\n  rfl\n\n"}
{"name":"WithBot.canLift","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\n⊢ CanLift (WithBot α) α WithBot.some fun r => Ne r Bot.bot","decl":"instance canLift : CanLift (WithBot α) α (↑) fun r => r ≠ ⊥ where\n  prf x h := ⟨x.unbot h, coe_unbot _ _⟩\n\n"}
{"name":"WithBot.coe_top","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : Top α\n⊢ Eq (↑Top.top) Top.top","decl":"@[simp, norm_cast] lemma coe_top [Top α] : ((⊤ : α) : WithBot α) = ⊤ := rfl\n"}
{"name":"WithBot.coe_eq_top","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : Top α\na : α\n⊢ Iff (Eq (↑a) Top.top) (Eq a Top.top)","decl":"@[simp, norm_cast] lemma coe_eq_top [Top α] {a : α} : (a : WithBot α) = ⊤ ↔ a = ⊤ := coe_eq_coe\n"}
{"name":"WithBot.top_eq_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : Top α\na : α\n⊢ Iff (Eq Top.top ↑a) (Eq Top.top a)","decl":"@[simp, norm_cast] lemma top_eq_coe [Top α] {a : α} : ⊤ = (a : WithBot α) ↔ ⊤ = a := coe_eq_coe\n\n"}
{"name":"WithBot.unbot_eq_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : WithBot α\nb : α\nh : Ne a Bot.bot\n⊢ Iff (Eq (a.unbot h) b) (Eq a ↑b)","decl":"theorem unbot_eq_iff {a : WithBot α} {b : α} (h : a ≠ ⊥) :\n    a.unbot h = b ↔ a = b := by\n  induction a\n  · simpa using h rfl\n  · simp\n\n"}
{"name":"WithBot.eq_unbot_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : α\nb : WithBot α\nh : Ne b Bot.bot\n⊢ Iff (Eq a (b.unbot h)) (Eq (↑a) b)","decl":"theorem eq_unbot_iff {a : α} {b : WithBot α} (h : b ≠ ⊥) :\n    a = b.unbot h ↔ a = b := by\n  induction b\n  · simpa using h rfl\n  · simp\n\n"}
{"name":"Equiv.withBotSubtypeNe_apply","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nx✝ : Subtype fun y => Ne y Bot.bot\n⊢ Eq (Equiv.withBotSubtypeNe x✝) (Equiv.withBotSubtypeNe.match_1 (fun x => α) x✝ fun x h => x.unbot h)","decl":"/-- The equivalence between the non-bottom elements of `WithBot α` and `α`. -/\n@[simps] def _root_.Equiv.withBotSubtypeNe : {y : WithBot α // y ≠ ⊥} ≃ α where\n  toFun := fun ⟨x,h⟩ => WithBot.unbot x h\n  invFun x := ⟨x, WithBot.coe_ne_bot⟩\n  left_inv _ := by simp\n  right_inv _ := by simp\n\n"}
{"name":"Equiv.withBotSubtypeNe_symm_apply_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nx : α\n⊢ Eq ↑(Equiv.withBotSubtypeNe.symm x) ↑x","decl":"/-- The equivalence between the non-bottom elements of `WithBot α` and `α`. -/\n@[simps] def _root_.Equiv.withBotSubtypeNe : {y : WithBot α // y ≠ ⊥} ≃ α where\n  toFun := fun ⟨x,h⟩ => WithBot.unbot x h\n  invFun x := ⟨x, WithBot.coe_ne_bot⟩\n  left_inv _ := by simp\n  right_inv _ := by simp\n\n"}
{"name":"WithBot.coe_le_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na b : α\ninst✝ : LE α\n⊢ Iff (LE.le ↑a ↑b) (LE.le a b)","decl":"@[simp, norm_cast]\ntheorem coe_le_coe : (a : WithBot α) ≤ b ↔ a ≤ b := by\n  simp [LE.le]\n\n"}
{"name":"WithBot.some_le_some","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na b : α\ninst✝ : LE α\n⊢ Iff (LE.le (Option.some a) (Option.some b)) (LE.le a b)","decl":"@[simp, deprecated coe_le_coe \"Don't mix Option and WithBot\" (since := \"2024-05-27\")]\ntheorem some_le_some : @LE.le (WithBot α) _ (Option.some a) (Option.some b) ↔ a ≤ b :=\n  coe_le_coe\n\n-- TODO: This deprecated lemma is still used (through simp)\n"}
{"name":"WithBot.none_le","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na : WithBot α\n⊢ LE.le Option.none a","decl":"@[simp, deprecated bot_le \"Don't mix Option and WithBot\" (since := \"2024-05-27\")]\ntheorem none_le {a : WithBot α} : @LE.le (WithBot α) _ none a := bot_le\n\n"}
{"name":"WithBot.not_coe_le_bot","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\n⊢ Not (LE.le (↑a) Bot.bot)","decl":"theorem not_coe_le_bot (a : α) : ¬(a : WithBot α) ≤ ⊥ := fun h =>\n  let ⟨_, hb, _⟩ := h _ rfl\n  Option.not_mem_none _ hb\n\n"}
{"name":"WithBot.le_bot_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na : WithBot α\n⊢ Iff (LE.le a Bot.bot) (Eq a Bot.bot)","decl":"/-- There is a general version `le_bot_iff`, but this lemma does not require a `PartialOrder`. -/\n@[simp]\nprotected theorem le_bot_iff : ∀ {a : WithBot α}, a ≤ ⊥ ↔ a = ⊥\n  | (a : α) => by simp [not_coe_le_bot _]\n  | ⊥ => by simp\n\n"}
{"name":"WithBot.coe_le","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na b : α\ninst✝ : LE α\no : Option α\na✝ : Membership.mem o b\n⊢ Iff (LE.le (↑a) o) (LE.le a b)","decl":"theorem coe_le : ∀ {o : Option α}, b ∈ o → ((a : WithBot α) ≤ o ↔ a ≤ b)\n  | _, rfl => coe_le_coe\n\n"}
{"name":"WithBot.coe_le_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : α\ninst✝ : LE α\nx : WithBot α\n⊢ Iff (LE.le (↑a) x) (Exists fun b => And (Eq x ↑b) (LE.le a b))","decl":"theorem coe_le_iff : ∀ {x : WithBot α}, (a : WithBot α) ≤ x ↔ ∃ b : α, x = b ∧ a ≤ b\n  | (x : α) => by simp\n  | ⊥ => iff_of_false (not_coe_le_bot _) <| by simp\n\n"}
{"name":"WithBot.le_coe_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nb : α\ninst✝ : LE α\nx : WithBot α\n⊢ Iff (LE.le x ↑b) (∀ (a : α), Eq x ↑a → LE.le a b)","decl":"theorem le_coe_iff : ∀ {x : WithBot α}, x ≤ b ↔ ∀ a : α, x = ↑a → a ≤ b\n  | (b : α) => by simp\n  | ⊥ => by simp\n\n"}
{"name":"IsMax.withBot","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : α\ninst✝ : LE α\nh : IsMax a\n⊢ IsMax ↑a","decl":"protected theorem _root_.IsMax.withBot (h : IsMax a) : IsMax (a : WithBot α)\n  | ⊥, _ => bot_le\n  | (_ : α), hb => coe_le_coe.2 <| h <| coe_le_coe.1 hb\n\n"}
{"name":"WithBot.le_unbot_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\nb : WithBot α\nh : Ne b Bot.bot\n⊢ Iff (LE.le a (b.unbot h)) (LE.le (↑a) b)","decl":"theorem le_unbot_iff {a : α} {b : WithBot α} (h : b ≠ ⊥) :\n    a ≤ unbot b h ↔ (a : WithBot α) ≤ b := by\n  match b, h with\n  | some _, _ => simp only [unbot_coe, coe_le_coe]\n\n"}
{"name":"WithBot.unbot_le_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na : WithBot α\nh : Ne a Bot.bot\nb : α\n⊢ Iff (LE.le (a.unbot h) b) (LE.le a ↑b)","decl":"theorem unbot_le_iff {a : WithBot α} (h : a ≠ ⊥) {b : α} :\n    unbot a h ≤ b ↔ a ≤ (b : WithBot α) := by\n  match a, h with\n  | some _, _ => simp only [unbot_coe, coe_le_coe]\n\n"}
{"name":"WithBot.unbot'_le_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na : WithBot α\nb c : α\nh : Eq a Bot.bot → LE.le b c\n⊢ Iff (LE.le (WithBot.unbot' b a) c) (LE.le a ↑c)","decl":"theorem unbot'_le_iff {a : WithBot α} {b c : α} (h : a = ⊥ → b ≤ c) :\n    a.unbot' b ≤ c ↔ a ≤ c := by\n  induction a\n  · simpa using h rfl\n  · simp\n\n"}
{"name":"WithBot.coe_lt_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na b : α\ninst✝ : LT α\n⊢ Iff (LT.lt ↑a ↑b) (LT.lt a b)","decl":"@[simp, norm_cast]\ntheorem coe_lt_coe : (a : WithBot α) < b ↔ a < b := by\n  simp [LT.lt]\n\n"}
{"name":"WithBot.bot_lt_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : α\n⊢ LT.lt Bot.bot ↑a","decl":"@[simp]\ntheorem bot_lt_coe (a : α) : ⊥ < (a : WithBot α) :=\n  ⟨a, rfl, fun _ hb => (Option.not_mem_none _ hb).elim⟩\n\n"}
{"name":"WithBot.not_lt_bot","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : WithBot α\n⊢ Not (LT.lt a Bot.bot)","decl":"@[simp]\nprotected theorem not_lt_bot (a : WithBot α) : ¬a < ⊥ :=\n  fun ⟨_, h, _⟩ => Option.not_mem_none _ h\n\n-- TODO: This deprecated lemma is still used (through simp)\n"}
{"name":"WithBot.some_lt_some","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na b : α\ninst✝ : LT α\n⊢ Iff (LT.lt (Option.some a) (Option.some b)) (LT.lt a b)","decl":"@[simp, deprecated coe_lt_coe \"Don't mix Option and WithBot\" (since := \"2024-05-27\")]\ntheorem some_lt_some : @LT.lt (WithBot α) _ (Option.some a) (Option.some b) ↔ a < b :=\n  coe_lt_coe\n\n-- TODO: This deprecated lemma is still used (through simp)\n"}
{"name":"WithBot.none_lt_some","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : α\n⊢ LT.lt Option.none ↑a","decl":"@[simp, deprecated bot_lt_coe \"Don't mix Option and WithBot\" (since := \"2024-05-27\")]\ntheorem none_lt_some (a : α) : @LT.lt (WithBot α) _ none (some a) := bot_lt_coe _\n\n-- TODO: This deprecated lemma is still used (through simp)\n"}
{"name":"WithBot.not_lt_none","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : WithBot α\n⊢ Not (LT.lt a Option.none)","decl":"@[simp, deprecated not_lt_bot \"Don't mix Option and WithBot\" (since := \"2024-05-27\")]\ntheorem not_lt_none (a : WithBot α) : ¬@LT.lt (WithBot α) _ a none := WithBot.not_lt_bot _\n\n"}
{"name":"WithBot.lt_iff_exists_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : WithBot α\n⊢ Iff (LT.lt a b) (Exists fun p => And (Eq b ↑p) (LT.lt a ↑p))","decl":"theorem lt_iff_exists_coe : ∀ {a b : WithBot α}, a < b ↔ ∃ p : α, b = p ∧ a < p\n  | a, some b => by simp [coe_eq_coe]\n  | a, ⊥ => iff_of_false (WithBot.not_lt_bot _) <| by simp\n\n"}
{"name":"WithBot.lt_coe_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nb : α\ninst✝ : LT α\nx : WithBot α\n⊢ Iff (LT.lt x ↑b) (∀ (a : α), Eq x ↑a → LT.lt a b)","decl":"theorem lt_coe_iff : ∀ {x : WithBot α}, x < b ↔ ∀ a : α, x = a → a < b\n  | (_ : α) => by simp\n  | ⊥ => by simp [bot_lt_coe]\n\n"}
{"name":"WithBot.bot_lt_iff_ne_bot","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\nx : WithBot α\n⊢ Iff (LT.lt Bot.bot x) (Ne x Bot.bot)","decl":"/-- A version of `bot_lt_iff_ne_bot` for `WithBot` that only requires `LT α`, not\n`PartialOrder α`. -/\nprotected theorem bot_lt_iff_ne_bot : ∀ {x : WithBot α}, ⊥ < x ↔ x ≠ ⊥\n  | ⊥ => iff_of_false (WithBot.not_lt_bot _) <| by simp\n  | (x : α) => by simp [bot_lt_coe]\n\n"}
{"name":"WithBot.lt_unbot_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : α\nb : WithBot α\nh : Ne b Bot.bot\n⊢ Iff (LT.lt a (b.unbot h)) (LT.lt (↑a) b)","decl":"theorem lt_unbot_iff {a : α} {b : WithBot α} (h : b ≠ ⊥) :\n    a < unbot b h ↔ (a : WithBot α) < b := by\n  induction b\n  · simpa [bot_lt_coe] using h rfl\n  · simp\n\n"}
{"name":"WithBot.unbot_lt_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : WithBot α\nh : Ne a Bot.bot\nb : α\n⊢ Iff (LT.lt (a.unbot h) b) (LT.lt a ↑b)","decl":"theorem unbot_lt_iff {a : WithBot α} (h : a ≠ ⊥) {b : α} :\n    unbot a h < b ↔ a < (b : WithBot α) := by\n  induction a\n  · simpa [bot_lt_coe] using h rfl\n  · simp\n\n"}
{"name":"WithBot.unbot'_lt_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : WithBot α\nb c : α\nh : Eq a Bot.bot → LT.lt b c\n⊢ Iff (LT.lt (WithBot.unbot' b a) c) (LT.lt a ↑c)","decl":"theorem unbot'_lt_iff {a : WithBot α} {b c : α} (h : a = ⊥ → b < c) :\n    a.unbot' b < c ↔ a < c := by\n  induction a\n  · simpa [bot_lt_coe] using h rfl\n  · simp\n\n"}
{"name":"WithBot.coe_strictMono","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ StrictMono fun a => ↑a","decl":"theorem coe_strictMono : StrictMono (fun (a : α) => (a : WithBot α)) := fun _ _ => coe_lt_coe.2\n\n"}
{"name":"WithBot.coe_mono","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Monotone fun a => ↑a","decl":"theorem coe_mono : Monotone (fun (a : α) => (a : WithBot α)) := fun _ _ => coe_le_coe.2\n\n"}
{"name":"WithBot.monotone_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : WithBot α → β\n⊢ Iff (Monotone f) (And (Monotone fun a => f ↑a) (∀ (x : α), LE.le (f Bot.bot) (f ↑x)))","decl":"theorem monotone_iff {f : WithBot α → β} :\n    Monotone f ↔ Monotone (fun a ↦ f a : α → β) ∧ ∀ x : α, f ⊥ ≤ f x :=\n  ⟨fun h ↦ ⟨h.comp WithBot.coe_mono, fun _ ↦ h bot_le⟩, fun h ↦\n    WithBot.forall.2\n      ⟨WithBot.forall.2 ⟨fun _ => le_rfl, fun x _ => h.2 x⟩, fun _ =>\n        WithBot.forall.2 ⟨fun h => (not_coe_le_bot _ h).elim,\n          fun _ hle => h.1 (coe_le_coe.1 hle)⟩⟩⟩\n\n"}
{"name":"WithBot.monotone_map_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (Monotone (WithBot.map f)) (Monotone f)","decl":"@[simp]\ntheorem monotone_map_iff {f : α → β} : Monotone (WithBot.map f) ↔ Monotone f :=\n  monotone_iff.trans <| by simp [Monotone]\n\n"}
{"name":"Monotone.withBot_map","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na✝ : Monotone f\n⊢ Monotone (WithBot.map f)","decl":"alias ⟨_, _root_.Monotone.withBot_map⟩ := monotone_map_iff\n\n"}
{"name":"WithBot.strictMono_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : WithBot α → β\n⊢ Iff (StrictMono f) (And (StrictMono fun a => f ↑a) (∀ (x : α), LT.lt (f Bot.bot) (f ↑x)))","decl":"theorem strictMono_iff {f : WithBot α → β} :\n    StrictMono f ↔ StrictMono (fun a => f a : α → β) ∧ ∀ x : α, f ⊥ < f x :=\n  ⟨fun h => ⟨h.comp WithBot.coe_strictMono, fun _ => h (bot_lt_coe _)⟩, fun h =>\n    WithBot.forall.2\n      ⟨WithBot.forall.2 ⟨flip absurd (lt_irrefl _), fun x _ => h.2 x⟩, fun _ =>\n        WithBot.forall.2 ⟨fun h => (not_lt_bot h).elim, fun _ hle => h.1 (coe_lt_coe.1 hle)⟩⟩⟩\n\n"}
{"name":"WithBot.strictAnti_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : WithBot α → β\n⊢ Iff (StrictAnti f) (And (StrictAnti fun a => f ↑a) (∀ (x : α), LT.lt (f ↑x) (f Bot.bot)))","decl":"theorem strictAnti_iff {f : WithBot α → β} :\n    StrictAnti f ↔ StrictAnti (fun a ↦ f a : α → β) ∧ ∀ x : α, f x < f ⊥ :=\n  strictMono_iff (β := βᵒᵈ)\n\n"}
{"name":"WithBot.strictMono_map_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (StrictMono (WithBot.map f)) (StrictMono f)","decl":"@[simp]\ntheorem strictMono_map_iff {f : α → β} :\n    StrictMono (WithBot.map f) ↔ StrictMono f :=\n  strictMono_iff.trans <| by simp [StrictMono, bot_lt_coe]\n\n"}
{"name":"StrictMono.withBot_map","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na✝ : StrictMono f\n⊢ StrictMono (WithBot.map f)","decl":"alias ⟨_, _root_.StrictMono.withBot_map⟩ := strictMono_map_iff\n\n"}
{"name":"WithBot.map_le_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nmono_iff : ∀ {a b : α}, Iff (LE.le (f a) (f b)) (LE.le a b)\na b : WithBot α\n⊢ Iff (LE.le (WithBot.map f a) (WithBot.map f b)) (LE.le a b)","decl":"theorem map_le_iff (f : α → β) (mono_iff : ∀ {a b}, f a ≤ f b ↔ a ≤ b) :\n    ∀ a b : WithBot α, a.map f ≤ b.map f ↔ a ≤ b\n  | ⊥, _ => by simp only [map_bot, bot_le]\n  | (a : α), ⊥ => by simp only [map_coe, map_bot, coe_ne_bot, not_coe_le_bot _]\n  | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff\n\n"}
{"name":"WithBot.le_coe_unbot'","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : WithBot α\nb : α\n⊢ LE.le a ↑(WithBot.unbot' b a)","decl":"theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b\n  | (a : α), _ => le_rfl\n  | ⊥, _ => bot_le\n\n"}
{"name":"WithBot.lt_coe_bot","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\nx : WithBot α\n⊢ Iff (LT.lt x ↑Bot.bot) (Eq x Bot.bot)","decl":"@[simp]\ntheorem lt_coe_bot [OrderBot α] : ∀ {x : WithBot α}, x < (⊥ : α) ↔ x = ⊥\n  | (x : α) => by simp\n  | ⊥ => by simp\n\n"}
{"name":"WithBot.coe_sup","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : SemilatticeSup α\na b : α\n⊢ Eq (↑(Max.max a b)) (Max.max ↑a ↑b)","decl":"theorem coe_sup [SemilatticeSup α] (a b : α) : ((a ⊔ b : α) : WithBot α) = (a : WithBot α) ⊔ b :=\n  rfl\n\n"}
{"name":"WithBot.coe_inf","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : SemilatticeInf α\na b : α\n⊢ Eq (↑(Min.min a b)) (Min.min ↑a ↑b)","decl":"theorem coe_inf [SemilatticeInf α] (a b : α) : ((a ⊓ b : α) : WithBot α) = (a : WithBot α) ⊓ b :=\n  rfl\n\n"}
{"name":"WithBot.isTotal_le","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝¹ : LE α\ninst✝ : IsTotal α fun x1 x2 => LE.le x1 x2\n⊢ IsTotal (WithBot α) fun x1 x2 => LE.le x1 x2","decl":"instance isTotal_le [LE α] [IsTotal α (· ≤ ·)] : IsTotal (WithBot α) (· ≤ ·) :=\n  ⟨fun a b =>\n    match a, b with\n    | none, _ => Or.inl bot_le\n    | _, none => Or.inr bot_le\n    | Option.some x, Option.some y => (total_of (· ≤ ·) x y).imp coe_le_coe.2 coe_le_coe.2⟩\n\n"}
{"name":"WithBot.coe_min","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx y : α\n⊢ Eq (↑(Min.min x y)) (Min.min ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_min [LinearOrder α] (x y : α) : ((min x y : α) : WithBot α) = min (x : WithBot α) y :=\n  rfl\n\n"}
{"name":"WithBot.coe_max","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx y : α\n⊢ Eq (↑(Max.max x y)) (Max.max ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_max [LinearOrder α] (x y : α) : ((max x y : α) : WithBot α) = max (x : WithBot α) y :=\n  rfl\n\n"}
{"name":"WithBot.instWellFoundedLT","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : WellFoundedLT α\n⊢ WellFoundedLT (WithBot α)","decl":"instance instWellFoundedLT [LT α] [WellFoundedLT α] : WellFoundedLT (WithBot α) where\n  wf :=\n  have not_lt_bot : ∀ a : WithBot α, ¬ a < ⊥ := nofun\n  have acc_bot := ⟨_, by simp [not_lt_bot]⟩\n  .intro fun\n    | ⊥ => acc_bot\n    | (a : α) => (wellFounded_lt.1 a).rec fun _ _ ih =>\n      .intro _ fun\n        | ⊥, _ => acc_bot\n        | (b : α), hlt => ih _ (coe_lt_coe.1 hlt)\n\n"}
{"name":"WithBot.instWellFoundedGT","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : WellFoundedGT α\n⊢ WellFoundedGT (WithBot α)","decl":"instance _root_.WithBot.instWellFoundedGT [LT α] [WellFoundedGT α] : WellFoundedGT (WithBot α) where\n  wf :=\n  have acc_some (a : α) : Acc ((· > ·) : WithBot α → WithBot α → Prop) a :=\n    (wellFounded_gt.1 a).rec fun _ _ ih =>\n      .intro _ fun\n        | (b : α), hlt => ih _ (coe_lt_coe.1 hlt)\n        | ⊥, hlt => absurd hlt (WithBot.not_lt_bot _)\n  .intro fun\n    | (a : α) => acc_some a\n    | ⊥ => .intro _ fun\n      | (b : α), _ => acc_some b\n      | ⊥, hlt => absurd hlt (WithBot.not_lt_bot _)\n\n"}
{"name":"WithBot.denselyOrdered","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝² : LT α\ninst✝¹ : DenselyOrdered α\ninst✝ : NoMinOrder α\n⊢ DenselyOrdered (WithBot α)","decl":"instance denselyOrdered [LT α] [DenselyOrdered α] [NoMinOrder α] : DenselyOrdered (WithBot α) :=\n  ⟨fun a b =>\n    match a, b with\n    | a, none => fun h : a < ⊥ => (WithBot.not_lt_bot _ h).elim\n    | none, Option.some b => fun _ =>\n      let ⟨a, ha⟩ := exists_lt b\n      ⟨a, bot_lt_coe a, coe_lt_coe.2 ha⟩\n    | Option.some _, Option.some _ => fun h =>\n      let ⟨a, ha₁, ha₂⟩ := exists_between (coe_lt_coe.1 h)\n      ⟨a, coe_lt_coe.2 ha₁, coe_lt_coe.2 ha₂⟩⟩\n\n"}
{"name":"WithBot.lt_iff_exists_coe_btwn","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : DenselyOrdered α\ninst✝ : NoMinOrder α\na b : WithBot α\n⊢ Iff (LT.lt a b) (Exists fun x => And (LT.lt a ↑x) (LT.lt (↑x) b))","decl":"theorem lt_iff_exists_coe_btwn [Preorder α] [DenselyOrdered α] [NoMinOrder α] {a b : WithBot α} :\n    a < b ↔ ∃ x : α, a < ↑x ∧ ↑x < b :=\n  ⟨fun h =>\n    let ⟨_, hy⟩ := exists_between h\n    let ⟨x, hx⟩ := lt_iff_exists_coe.1 hy.1\n    ⟨x, hx.1 ▸ hy⟩,\n    fun ⟨_, hx⟩ => lt_trans hx.1 hx.2⟩\n\n"}
{"name":"WithBot.noTopOrder","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝² : LE α\ninst✝¹ : NoTopOrder α\ninst✝ : Nonempty α\n⊢ NoTopOrder (WithBot α)","decl":"instance noTopOrder [LE α] [NoTopOrder α] [Nonempty α] : NoTopOrder (WithBot α) :=\n  ⟨by\n    apply recBotCoe\n    · exact ‹Nonempty α›.elim fun a => ⟨a, not_coe_le_bot a⟩\n\n    · intro a\n      obtain ⟨b, h⟩ := exists_not_le a\n      exact ⟨b, by rwa [coe_le_coe]⟩\n      ⟩\n\n"}
{"name":"WithBot.noMaxOrder","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝² : LT α\ninst✝¹ : NoMaxOrder α\ninst✝ : Nonempty α\n⊢ NoMaxOrder (WithBot α)","decl":"instance noMaxOrder [LT α] [NoMaxOrder α] [Nonempty α] : NoMaxOrder (WithBot α) :=\n  ⟨by\n    apply WithBot.recBotCoe\n    · apply ‹Nonempty α›.elim\n      exact fun a => ⟨a, WithBot.bot_lt_coe a⟩\n\n    · intro a\n      obtain ⟨b, ha⟩ := exists_gt a\n      exact ⟨b, coe_lt_coe.mpr ha⟩\n      ⟩\n\n"}
{"name":"WithTop.nontrivial","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : Nonempty α\n⊢ Nontrivial (WithTop α)","decl":"instance nontrivial [Nonempty α] : Nontrivial (WithTop α) :=\n  Option.nontrivial\n\n"}
{"name":"WithTop.coe_injective","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\n⊢ Function.Injective WithTop.some","decl":"theorem coe_injective : Injective ((↑) : α → WithTop α) :=\n  Option.some_injective _\n\n"}
{"name":"WithTop.coe_inj","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na b : α\n⊢ Iff (Eq ↑a ↑b) (Eq a b)","decl":"@[norm_cast]\ntheorem coe_inj : (a : WithTop α) = b ↔ a = b :=\n  Option.some_inj\n\n"}
{"name":"WithTop.forall","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\np : WithTop α → Prop\n⊢ Iff (∀ (x : WithTop α), p x) (And (p Top.top) (∀ (x : α), p ↑x))","decl":"protected theorem «forall» {p : WithTop α → Prop} : (∀ x, p x) ↔ p ⊤ ∧ ∀ x : α, p x :=\n  Option.forall\n\n"}
{"name":"WithTop.exists","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\np : WithTop α → Prop\n⊢ Iff (Exists fun x => p x) (Or (p Top.top) (Exists fun x => p ↑x))","decl":"protected theorem «exists» {p : WithTop α → Prop} : (∃ x, p x) ↔ p ⊤ ∨ ∃ x : α, p x :=\n  Option.exists\n\n"}
{"name":"WithTop.none_eq_top","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\n⊢ Eq Option.none Top.top","decl":"theorem none_eq_top : (none : WithTop α) = (⊤ : WithTop α) :=\n  rfl\n\n"}
{"name":"WithTop.some_eq_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : α\n⊢ Eq (Option.some a) ↑a","decl":"theorem some_eq_coe (a : α) : (Option.some a : WithTop α) = (↑a : WithTop α) :=\n  rfl\n\n"}
{"name":"WithTop.top_ne_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : α\n⊢ Ne Top.top ↑a","decl":"@[simp]\ntheorem top_ne_coe : ⊤ ≠ (a : WithTop α) :=\n  nofun\n\n"}
{"name":"WithTop.coe_ne_top","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : α\n⊢ Ne (↑a) Top.top","decl":"@[simp]\ntheorem coe_ne_top : (a : WithTop α) ≠ ⊤ :=\n  nofun\n\n"}
{"name":"WithTop.toDual_symm_apply","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : WithBot (OrderDual α)\n⊢ Eq (WithTop.toDual.symm a) (WithBot.ofDual a)","decl":"@[simp]\ntheorem toDual_symm_apply (a : WithBot αᵒᵈ) : WithTop.toDual.symm a = WithBot.ofDual a :=\n  rfl\n\n"}
{"name":"WithTop.ofDual_symm_apply","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : WithBot α\n⊢ Eq (WithTop.ofDual.symm a) (WithBot.toDual a)","decl":"@[simp]\ntheorem ofDual_symm_apply (a : WithBot α) : WithTop.ofDual.symm a = WithBot.toDual a :=\n  rfl\n\n"}
{"name":"WithTop.toDual_apply_top","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\n⊢ Eq (WithTop.toDual Top.top) Bot.bot","decl":"@[simp]\ntheorem toDual_apply_top : WithTop.toDual (⊤ : WithTop α) = ⊥ :=\n  rfl\n\n"}
{"name":"WithTop.ofDual_apply_top","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\n⊢ Eq (WithTop.ofDual Top.top) Bot.bot","decl":"@[simp]\ntheorem ofDual_apply_top : WithTop.ofDual (⊤ : WithTop α) = ⊥ :=\n  rfl\n\n"}
{"name":"WithTop.toDual_apply_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : α\n⊢ Eq (WithTop.toDual ↑a) ↑(OrderDual.toDual a)","decl":"@[simp]\ntheorem toDual_apply_coe (a : α) : WithTop.toDual (a : WithTop α) = toDual a :=\n  rfl\n\n"}
{"name":"WithTop.ofDual_apply_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : OrderDual α\n⊢ Eq (WithTop.ofDual ↑a) ↑(OrderDual.ofDual a)","decl":"@[simp]\ntheorem ofDual_apply_coe (a : αᵒᵈ) : WithTop.ofDual (a : WithTop αᵒᵈ) = ofDual a :=\n  rfl\n\n"}
{"name":"WithTop.untop'_top","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_5\nd : α\n⊢ Eq (WithTop.untop' d Top.top) d","decl":"@[simp]\ntheorem untop'_top {α} (d : α) : untop' d ⊤ = d :=\n  rfl\n\n"}
{"name":"WithTop.untop'_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_5\nd x : α\n⊢ Eq (WithTop.untop' d ↑x) x","decl":"@[simp]\ntheorem untop'_coe {α} (d x : α) : untop' d x = x :=\n  rfl\n\n"}
{"name":"WithTop.coe_eq_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na b : α\n⊢ Iff (Eq ↑a ↑b) (Eq a b)","decl":"@[simp, norm_cast] -- Porting note: added `simp`\ntheorem coe_eq_coe : (a : WithTop α) = b ↔ a = b :=\n  Option.some_inj\n\n"}
{"name":"WithTop.untop'_eq_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nd y : α\nx : WithTop α\n⊢ Iff (Eq (WithTop.untop' d x) y) (Or (Eq x ↑y) (And (Eq x Top.top) (Eq y d)))","decl":"theorem untop'_eq_iff {d y : α} {x : WithTop α} : untop' d x = y ↔ x = y ∨ x = ⊤ ∧ y = d :=\n  WithBot.unbot'_eq_iff\n\n"}
{"name":"WithTop.untop'_eq_self_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nd : α\nx : WithTop α\n⊢ Iff (Eq (WithTop.untop' d x) d) (Or (Eq x ↑d) (Eq x Top.top))","decl":"@[simp] theorem untop'_eq_self_iff {d : α} {x : WithTop α} : untop' d x = d ↔ x = d ∨ x = ⊤ :=\n  WithBot.unbot'_eq_self_iff\n\n"}
{"name":"WithTop.untop'_eq_untop'_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nd : α\nx y : WithTop α\n⊢ Iff (Eq (WithTop.untop' d x) (WithTop.untop' d y)) (Or (Eq x y) (Or (And (Eq x ↑d) (Eq y Top.top)) (And (Eq x Top.top) (Eq y ↑d))))","decl":"theorem untop'_eq_untop'_iff {d : α} {x y : WithTop α} :\n    untop' d x = untop' d y ↔ x = y ∨ x = d ∧ y = ⊤ ∨ x = ⊤ ∧ y = d :=\n  WithBot.unbot'_eq_unbot'_iff\n\n"}
{"name":"WithTop.map_top","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (WithTop.map f Top.top) Top.top","decl":"@[simp]\ntheorem map_top (f : α → β) : map f ⊤ = ⊤ :=\n  rfl\n\n"}
{"name":"WithTop.map_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : α\n⊢ Eq (WithTop.map f ↑a) ↑(f a)","decl":"@[simp]\ntheorem map_coe (f : α → β) (a : α) : map f a = f a :=\n  rfl\n\n"}
{"name":"WithTop.map_eq_top_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : WithTop α\n⊢ Iff (Eq (WithTop.map f a) Top.top) (Eq a Top.top)","decl":"@[simp]\nlemma map_eq_top_iff {f : α → β} {a : WithTop α} :\n    map f a = ⊤ ↔ a = ⊤ := Option.map_eq_none'\n\n"}
{"name":"WithTop.map_eq_some_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ny : β\nv : WithTop α\n⊢ Iff (Eq (WithTop.map f v) ↑y) (Exists fun x => And (Eq v ↑x) (Eq (f x) y))","decl":"theorem map_eq_some_iff {f : α → β} {y : β} {v : WithTop α} :\n    WithTop.map f v = .some y ↔ ∃ x, v = .some x ∧ f x = y := Option.map_eq_some'\n\n"}
{"name":"WithTop.some_eq_map_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ny : β\nv : WithTop α\n⊢ Iff (Eq (↑y) (WithTop.map f v)) (Exists fun x => And (Eq v ↑x) (Eq (f x) y))","decl":"theorem some_eq_map_iff {f : α → β} {y : β} {v : WithTop α} :\n    .some y = WithTop.map f v ↔ ∃ x, v = .some x ∧ f x = y := by\n  cases v <;> simp [eq_comm]\n\n"}
{"name":"WithTop.map_comm","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf₁ : α → β\nf₂ : α → γ\ng₁ : β → δ\ng₂ : γ → δ\nh : Eq (Function.comp g₁ f₁) (Function.comp g₂ f₂)\na : α\n⊢ Eq (WithTop.map g₁ (WithTop.map f₁ ↑a)) (WithTop.map g₂ (WithTop.map f₂ ↑a))","decl":"theorem map_comm {f₁ : α → β} {f₂ : α → γ} {g₁ : β → δ} {g₂ : γ → δ}\n    (h : g₁ ∘ f₁ = g₂ ∘ f₂) (a : α) : map g₁ (map f₁ a) = map g₂ (map f₂ a) :=\n  Option.map_comm h _\n\n"}
{"name":"WithTop.map₂_coe_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\na : α\nb : β\n⊢ Eq (WithTop.map₂ f ↑a ↑b) ↑(f a b)","decl":"lemma map₂_coe_coe (f : α → β → γ) (a : α) (b : β) : map₂ f a b = f a b := rfl\n"}
{"name":"WithTop.map₂_top_left","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\nb : WithTop β\n⊢ Eq (WithTop.map₂ f Top.top b) Top.top","decl":"@[simp] lemma map₂_top_left (f : α → β → γ) (b) : map₂ f ⊤ b = ⊤ := rfl\n"}
{"name":"WithTop.map₂_top_right","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\na : WithTop α\n⊢ Eq (WithTop.map₂ f a Top.top) Top.top","decl":"@[simp] lemma map₂_top_right (f : α → β → γ) (a) : map₂ f a ⊤ = ⊤ := by cases a <;> rfl\n"}
{"name":"WithTop.map₂_coe_left","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\na : α\nb : WithTop β\n⊢ Eq (WithTop.map₂ f (↑a) b) (WithTop.map (fun b => f a b) b)","decl":"@[simp] lemma map₂_coe_left (f : α → β → γ) (a : α) (b) : map₂ f a b = b.map fun b ↦ f a b := rfl\n"}
{"name":"WithTop.map₂_coe_right","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\na : WithTop α\nb : β\n⊢ Eq (WithTop.map₂ f a ↑b) (WithTop.map (fun x => f x b) a)","decl":"@[simp] lemma map₂_coe_right (f : α → β → γ) (a) (b : β) : map₂ f a b = a.map (f · b) := by\n  cases a <;> rfl\n\n"}
{"name":"WithTop.map₂_eq_top_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\na : WithTop α\nb : WithTop β\n⊢ Iff (Eq (WithTop.map₂ f a b) Top.top) (Or (Eq a Top.top) (Eq b Top.top))","decl":"@[simp] lemma map₂_eq_top_iff {f : α → β → γ} {a : WithTop α} {b : WithTop β} :\n    map₂ f a b = ⊤ ↔ a = ⊤ ∨ b = ⊤ := Option.map₂_eq_none_iff\n\n"}
{"name":"WithTop.map_toDual","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nf : OrderDual α → OrderDual β\na : WithBot α\n⊢ Eq (WithTop.map f (WithBot.toDual a)) (WithBot.map (Function.comp (⇑OrderDual.toDual) f) a)","decl":"theorem map_toDual (f : αᵒᵈ → βᵒᵈ) (a : WithBot α) :\n    map f (WithBot.toDual a) = a.map (toDual ∘ f) :=\n  rfl\n\n"}
{"name":"WithTop.map_ofDual","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : WithBot (OrderDual α)\n⊢ Eq (WithTop.map f (WithBot.ofDual a)) (WithBot.map (Function.comp (⇑OrderDual.ofDual) f) a)","decl":"theorem map_ofDual (f : α → β) (a : WithBot αᵒᵈ) : map f (WithBot.ofDual a) = a.map (ofDual ∘ f) :=\n  rfl\n\n"}
{"name":"WithTop.toDual_map","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : WithTop α\n⊢ Eq (WithTop.toDual (WithTop.map f a)) (WithBot.map (Function.comp (⇑OrderDual.toDual) (Function.comp f ⇑OrderDual.ofDual)) (WithTop.toDual a))","decl":"theorem toDual_map (f : α → β) (a : WithTop α) :\n    WithTop.toDual (map f a) = WithBot.map (toDual ∘ f ∘ ofDual) (WithTop.toDual a) :=\n  rfl\n\n"}
{"name":"WithTop.ofDual_map","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nf : OrderDual α → OrderDual β\na : WithTop (OrderDual α)\n⊢ Eq (WithTop.ofDual (WithTop.map f a)) (WithBot.map (Function.comp (⇑OrderDual.ofDual) (Function.comp f ⇑OrderDual.toDual)) (WithTop.ofDual a))","decl":"theorem ofDual_map (f : αᵒᵈ → βᵒᵈ) (a : WithTop αᵒᵈ) :\n    WithTop.ofDual (map f a) = WithBot.map (ofDual ∘ f ∘ toDual) (WithTop.ofDual a) :=\n  rfl\n\n"}
{"name":"WithTop.ne_top_iff_exists","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nx : WithTop α\n⊢ Iff (Ne x Top.top) (Exists fun a => Eq (↑a) x)","decl":"lemma ne_top_iff_exists {x : WithTop α} : x ≠ ⊤ ↔ ∃ a : α, ↑a = x := Option.ne_none_iff_exists\n\n"}
{"name":"WithTop.forall_ne_iff_eq_top","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nx : WithTop α\n⊢ Iff (∀ (a : α), Ne (↑a) x) (Eq x Top.top)","decl":"lemma forall_ne_iff_eq_top {x : WithTop α} : (∀ a : α, ↑a ≠ x) ↔ x = ⊤ :=\n  Option.forall_some_ne_iff_eq_none\n\n"}
{"name":"WithTop.coe_untop","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nx : WithTop α\nhx : Ne x Top.top\n⊢ Eq (↑(x.untop hx)) x","decl":"@[simp] lemma coe_untop : ∀ (x : WithTop α) hx, x.untop hx = x | (x : α), _ => rfl\n\n"}
{"name":"WithTop.untop_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nx : α\nh : optParam (Ne (↑x) Top.top) ⋯\n⊢ Eq ((↑x).untop h) x","decl":"@[simp]\ntheorem untop_coe (x : α) (h : (x : WithTop α) ≠ ⊤ := coe_ne_top) : (x : WithTop α).untop h = x :=\n  rfl\n\n"}
{"name":"WithTop.canLift","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\n⊢ CanLift (WithTop α) α WithTop.some fun r => Ne r Top.top","decl":"instance canLift : CanLift (WithTop α) α (↑) fun r => r ≠ ⊤ where\n  prf x h := ⟨x.untop h, coe_untop _ _⟩\n\n"}
{"name":"WithTop.coe_bot","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : Bot α\n⊢ Eq (↑Bot.bot) Bot.bot","decl":"@[simp, norm_cast] lemma coe_bot [Bot α] : ((⊥ : α) : WithTop α) = ⊥ := rfl\n"}
{"name":"WithTop.coe_eq_bot","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : Bot α\na : α\n⊢ Iff (Eq (↑a) Bot.bot) (Eq a Bot.bot)","decl":"@[simp, norm_cast] lemma coe_eq_bot [Bot α] {a : α} : (a : WithTop α) = ⊥ ↔ a = ⊥ := coe_eq_coe\n"}
{"name":"WithTop.bot_eq_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : Bot α\na : α\n⊢ Iff (Eq Bot.bot ↑a) (Eq Bot.bot a)","decl":"@[simp, norm_cast] lemma bot_eq_coe [Bot α] {a : α} : (⊥ : WithTop α) = a ↔ ⊥ = a := coe_eq_coe\n\n"}
{"name":"WithTop.untop_eq_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : WithTop α\nb : α\nh : Ne a Top.top\n⊢ Iff (Eq (a.untop h) b) (Eq a ↑b)","decl":"theorem untop_eq_iff {a : WithTop α} {b : α} (h : a ≠ ⊤) :\n    a.untop h = b ↔ a = b :=\n  WithBot.unbot_eq_iff (α := αᵒᵈ) h\n\n"}
{"name":"WithTop.eq_untop_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : α\nb : WithTop α\nh : Ne b Top.top\n⊢ Iff (Eq a (b.untop h)) (Eq (↑a) b)","decl":"theorem eq_untop_iff {a : α} {b : WithTop α} (h : b ≠ ⊤) :\n    a = b.untop h ↔ a = b :=\n  WithBot.eq_unbot_iff (α := αᵒᵈ) h\n\n"}
{"name":"Equiv.withTopSubtypeNe_symm_apply_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nx : α\n⊢ Eq ↑(Equiv.withTopSubtypeNe.symm x) ↑x","decl":"/-- The equivalence between the non-top elements of `WithTop α` and `α`. -/\n@[simps] def _root_.Equiv.withTopSubtypeNe : {y : WithTop α // y ≠ ⊤} ≃ α where\n  toFun := fun ⟨x,h⟩ => WithTop.untop x h\n  invFun x := ⟨x, WithTop.coe_ne_top⟩\n  left_inv _ := by simp\n  right_inv _:= by simp\n\n"}
{"name":"Equiv.withTopSubtypeNe_apply","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nx✝ : Subtype fun y => Ne y Top.top\n⊢ Eq (Equiv.withTopSubtypeNe x✝) (Equiv.withTopSubtypeNe.match_1 (fun x => α) x✝ fun x h => x.untop h)","decl":"/-- The equivalence between the non-top elements of `WithTop α` and `α`. -/\n@[simps] def _root_.Equiv.withTopSubtypeNe : {y : WithTop α // y ≠ ⊤} ≃ α where\n  toFun := fun ⟨x,h⟩ => WithTop.untop x h\n  invFun x := ⟨x, WithTop.coe_ne_top⟩\n  left_inv _ := by simp\n  right_inv _:= by simp\n\n"}
{"name":"WithTop.toDual_le_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na : WithTop α\nb : WithBot (OrderDual α)\n⊢ Iff (LE.le (WithTop.toDual a) b) (LE.le (WithBot.ofDual b) a)","decl":"theorem toDual_le_iff {a : WithTop α} {b : WithBot αᵒᵈ} :\n    WithTop.toDual a ≤ b ↔ WithBot.ofDual b ≤ a :=\n  Iff.rfl\n\n"}
{"name":"WithTop.le_toDual_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na : WithBot (OrderDual α)\nb : WithTop α\n⊢ Iff (LE.le a (WithTop.toDual b)) (LE.le b (WithBot.ofDual a))","decl":"theorem le_toDual_iff {a : WithBot αᵒᵈ} {b : WithTop α} :\n    a ≤ WithTop.toDual b ↔ b ≤ WithBot.ofDual a :=\n  Iff.rfl\n\n"}
{"name":"WithTop.toDual_le_toDual_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na b : WithTop α\n⊢ Iff (LE.le (WithTop.toDual a) (WithTop.toDual b)) (LE.le b a)","decl":"@[simp]\ntheorem toDual_le_toDual_iff {a b : WithTop α} : WithTop.toDual a ≤ WithTop.toDual b ↔ b ≤ a :=\n  Iff.rfl\n\n"}
{"name":"WithTop.ofDual_le_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na : WithTop (OrderDual α)\nb : WithBot α\n⊢ Iff (LE.le (WithTop.ofDual a) b) (LE.le (WithBot.toDual b) a)","decl":"theorem ofDual_le_iff {a : WithTop αᵒᵈ} {b : WithBot α} :\n    WithTop.ofDual a ≤ b ↔ WithBot.toDual b ≤ a :=\n  Iff.rfl\n\n"}
{"name":"WithTop.le_ofDual_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na : WithBot α\nb : WithTop (OrderDual α)\n⊢ Iff (LE.le a (WithTop.ofDual b)) (LE.le b (WithBot.toDual a))","decl":"theorem le_ofDual_iff {a : WithBot α} {b : WithTop αᵒᵈ} :\n    a ≤ WithTop.ofDual b ↔ b ≤ WithBot.toDual a :=\n  Iff.rfl\n\n"}
{"name":"WithTop.ofDual_le_ofDual_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na b : WithTop (OrderDual α)\n⊢ Iff (LE.le (WithTop.ofDual a) (WithTop.ofDual b)) (LE.le b a)","decl":"@[simp]\ntheorem ofDual_le_ofDual_iff {a b : WithTop αᵒᵈ} : WithTop.ofDual a ≤ WithTop.ofDual b ↔ b ≤ a :=\n  Iff.rfl\n\n"}
{"name":"WithTop.coe_le_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na b : α\ninst✝ : LE α\n⊢ Iff (LE.le ↑a ↑b) (LE.le a b)","decl":"@[simp, norm_cast]\ntheorem coe_le_coe : (a : WithTop α) ≤ b ↔ a ≤ b := by\n  simp only [← toDual_le_toDual_iff, toDual_apply_coe, WithBot.coe_le_coe, toDual_le_toDual]\n\n-- TODO: This deprecated lemma is still used (through simp)\n"}
{"name":"WithTop.some_le_some","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na b : α\ninst✝ : LE α\n⊢ Iff (LE.le (Option.some a) (Option.some b)) (LE.le a b)","decl":"@[simp, deprecated coe_le_coe \"Don't mix Option and WithTop\" (since := \"2024-05-27\")]\ntheorem some_le_some : @LE.le (WithTop α) _ (Option.some a) (Option.some b) ↔ a ≤ b :=\n  coe_le_coe\n\n"}
{"name":"WithTop.le_none","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na : WithTop α\n⊢ LE.le a Option.none","decl":"@[simp, deprecated le_top \"Don't mix Option and WithTop\" (since := \"2024-05-27\")]\ntheorem le_none {a : WithTop α} : @LE.le (WithTop α) _ a none := le_top\n\n"}
{"name":"WithTop.not_top_le_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\n⊢ Not (LE.le Top.top ↑a)","decl":"theorem not_top_le_coe (a : α) : ¬(⊤ : WithTop α) ≤ ↑a :=\n  WithBot.not_coe_le_bot (toDual a)\n\n"}
{"name":"WithTop.top_le_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na : WithTop α\n⊢ Iff (LE.le Top.top a) (Eq a Top.top)","decl":"/-- There is a general version `top_le_iff`, but this lemma does not require a `PartialOrder`. -/\n@[simp]\nprotected theorem top_le_iff : ∀ {a : WithTop α}, ⊤ ≤ a ↔ a = ⊤\n  | (a : α) => by simp [not_top_le_coe _]\n  | ⊤ => by simp\n\n"}
{"name":"WithTop.le_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na b : α\ninst✝ : LE α\no : Option α\na✝ : Membership.mem o a\n⊢ Iff (LE.le o ↑b) (LE.le a b)","decl":"theorem le_coe : ∀ {o : Option α}, a ∈ o → (@LE.le (WithTop α) _ o b ↔ a ≤ b)\n  | _, rfl => coe_le_coe\n\n"}
{"name":"WithTop.le_coe_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nb : α\ninst✝ : LE α\nx : WithTop α\n⊢ Iff (LE.le x ↑b) (Exists fun a => And (Eq x ↑a) (LE.le a b))","decl":"theorem le_coe_iff {x : WithTop α} : x ≤ b ↔ ∃ a : α, x = a ∧ a ≤ b :=\n  @WithBot.coe_le_iff (αᵒᵈ) _ _ (toDual x)\n\n"}
{"name":"WithTop.coe_le_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : α\ninst✝ : LE α\nx : WithTop α\n⊢ Iff (LE.le (↑a) x) (∀ (b : α), Eq x ↑b → LE.le a b)","decl":"theorem coe_le_iff {x : WithTop α} : ↑a ≤ x ↔ ∀ b : α, x = ↑b → a ≤ b :=\n  @WithBot.le_coe_iff (αᵒᵈ) _ _ (toDual x)\n\n"}
{"name":"IsMin.withTop","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : α\ninst✝ : LE α\nh : IsMin a\n⊢ IsMin ↑a","decl":"protected theorem _root_.IsMin.withTop (h : IsMin a) : IsMin (a : WithTop α) := by\n  -- defeq to is_max_to_dual_iff.mp (is_max.with_bot _), but that breaks API boundary\n  intro _ hb\n  rw [← toDual_le_toDual_iff] at hb\n  simpa [toDual_le_iff] using h.toDual.withBot hb\n\n"}
{"name":"WithTop.untop_le_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na : WithTop α\nb : α\nh : Ne a Top.top\n⊢ Iff (LE.le (a.untop h) b) (LE.le a ↑b)","decl":"theorem untop_le_iff {a : WithTop α} {b : α} (h : a ≠ ⊤) :\n    untop a h ≤ b ↔ a ≤ (b : WithTop α) :=\n  @WithBot.le_unbot_iff αᵒᵈ _ _ _ _\n\n"}
{"name":"WithTop.le_untop_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\nb : WithTop α\nh : Ne b Top.top\n⊢ Iff (LE.le a (b.untop h)) (LE.le (↑a) b)","decl":"theorem le_untop_iff {a : α} {b : WithTop α} (h : b ≠ ⊤) :\n    a ≤ untop b h ↔ (a : WithTop α) ≤ b :=\n  @WithBot.unbot_le_iff αᵒᵈ _ _ _ _\n\n"}
{"name":"WithTop.le_untop'_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na : WithTop α\nb c : α\nh : Eq a Top.top → LE.le c b\n⊢ Iff (LE.le c (WithTop.untop' b a)) (LE.le (↑c) a)","decl":"theorem le_untop'_iff {a : WithTop α} {b c : α} (h : a = ⊤ → c ≤ b) :\n    c ≤ a.untop' b ↔ c ≤ a :=\n  WithBot.unbot'_le_iff (α := αᵒᵈ) h\n\n"}
{"name":"WithTop.toDual_lt_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : WithTop α\nb : WithBot (OrderDual α)\n⊢ Iff (LT.lt (WithTop.toDual a) b) (LT.lt (WithBot.ofDual b) a)","decl":"theorem toDual_lt_iff {a : WithTop α} {b : WithBot αᵒᵈ} :\n    WithTop.toDual a < b ↔ WithBot.ofDual b < a :=\n  Iff.rfl\n\n"}
{"name":"WithTop.lt_toDual_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : WithBot (OrderDual α)\nb : WithTop α\n⊢ Iff (LT.lt a (WithTop.toDual b)) (LT.lt b (WithBot.ofDual a))","decl":"theorem lt_toDual_iff {a : WithBot αᵒᵈ} {b : WithTop α} :\n    a < WithTop.toDual b ↔ b < WithBot.ofDual a :=\n  Iff.rfl\n\n"}
{"name":"WithTop.toDual_lt_toDual_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : WithTop α\n⊢ Iff (LT.lt (WithTop.toDual a) (WithTop.toDual b)) (LT.lt b a)","decl":"@[simp]\ntheorem toDual_lt_toDual_iff {a b : WithTop α} : WithTop.toDual a < WithTop.toDual b ↔ b < a :=\n  Iff.rfl\n\n"}
{"name":"WithTop.ofDual_lt_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : WithTop (OrderDual α)\nb : WithBot α\n⊢ Iff (LT.lt (WithTop.ofDual a) b) (LT.lt (WithBot.toDual b) a)","decl":"theorem ofDual_lt_iff {a : WithTop αᵒᵈ} {b : WithBot α} :\n    WithTop.ofDual a < b ↔ WithBot.toDual b < a :=\n  Iff.rfl\n\n"}
{"name":"WithTop.lt_ofDual_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : WithBot α\nb : WithTop (OrderDual α)\n⊢ Iff (LT.lt a (WithTop.ofDual b)) (LT.lt b (WithBot.toDual a))","decl":"theorem lt_ofDual_iff {a : WithBot α} {b : WithTop αᵒᵈ} :\n    a < WithTop.ofDual b ↔ b < WithBot.toDual a :=\n  Iff.rfl\n\n"}
{"name":"WithTop.ofDual_lt_ofDual_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : WithTop (OrderDual α)\n⊢ Iff (LT.lt (WithTop.ofDual a) (WithTop.ofDual b)) (LT.lt b a)","decl":"@[simp]\ntheorem ofDual_lt_ofDual_iff {a b : WithTop αᵒᵈ} : WithTop.ofDual a < WithTop.ofDual b ↔ b < a :=\n  Iff.rfl\n\n"}
{"name":"WithTop.lt_untop_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : α\nb : WithTop α\nh : Ne b Top.top\n⊢ Iff (LT.lt a (b.untop h)) (LT.lt (↑a) b)","decl":"theorem lt_untop_iff {a : α} {b : WithTop α} (h : b ≠ ⊤) :\n    a < b.untop h ↔ a < b :=\n  WithBot.unbot_lt_iff (α := αᵒᵈ) h\n\n"}
{"name":"WithTop.untop_lt_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : WithTop α\nb : α\nh : Ne a Top.top\n⊢ Iff (LT.lt (a.untop h) b) (LT.lt a ↑b)","decl":"theorem untop_lt_iff {a : WithTop α} {b : α} (h : a ≠ ⊤) :\n    a.untop h < b ↔ a < b :=\n  WithBot.lt_unbot_iff (α := αᵒᵈ) h\n\n"}
{"name":"WithTop.lt_untop'_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : WithTop α\nb c : α\nh : Eq a Top.top → LT.lt c b\n⊢ Iff (LT.lt c (WithTop.untop' b a)) (LT.lt (↑c) a)","decl":"theorem lt_untop'_iff {a : WithTop α} {b c : α} (h : a = ⊤ → c < b) :\n    c < a.untop' b ↔ c < a :=\n  WithBot.unbot'_lt_iff (α := αᵒᵈ) h\n\n"}
{"name":"WithBot.toDual_symm_apply","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : WithTop (OrderDual α)\n⊢ Eq (WithBot.toDual.symm a) (WithTop.ofDual a)","decl":"@[simp]\ntheorem toDual_symm_apply (a : WithTop αᵒᵈ) : WithBot.toDual.symm a = WithTop.ofDual a :=\n  rfl\n\n"}
{"name":"WithBot.ofDual_symm_apply","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : WithTop α\n⊢ Eq (WithBot.ofDual.symm a) (WithTop.toDual a)","decl":"@[simp]\ntheorem ofDual_symm_apply (a : WithTop α) : WithBot.ofDual.symm a = WithTop.toDual a :=\n  rfl\n\n"}
{"name":"WithBot.toDual_apply_bot","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\n⊢ Eq (WithBot.toDual Bot.bot) Top.top","decl":"@[simp]\ntheorem toDual_apply_bot : WithBot.toDual (⊥ : WithBot α) = ⊤ :=\n  rfl\n\n"}
{"name":"WithBot.ofDual_apply_bot","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\n⊢ Eq (WithBot.ofDual Bot.bot) Top.top","decl":"@[simp]\ntheorem ofDual_apply_bot : WithBot.ofDual (⊥ : WithBot α) = ⊤ :=\n  rfl\n\n"}
{"name":"WithBot.toDual_apply_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : α\n⊢ Eq (WithBot.toDual ↑a) ↑(OrderDual.toDual a)","decl":"@[simp]\ntheorem toDual_apply_coe (a : α) : WithBot.toDual (a : WithBot α) = toDual a :=\n  rfl\n\n"}
{"name":"WithBot.ofDual_apply_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\na : OrderDual α\n⊢ Eq (WithBot.ofDual ↑a) ↑(OrderDual.ofDual a)","decl":"@[simp]\ntheorem ofDual_apply_coe (a : αᵒᵈ) : WithBot.ofDual (a : WithBot αᵒᵈ) = ofDual a :=\n  rfl\n\n"}
{"name":"WithBot.map_toDual","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nf : OrderDual α → OrderDual β\na : WithTop α\n⊢ Eq (WithBot.map f (WithTop.toDual a)) (WithTop.map (Function.comp (⇑OrderDual.toDual) f) a)","decl":"theorem map_toDual (f : αᵒᵈ → βᵒᵈ) (a : WithTop α) :\n    WithBot.map f (WithTop.toDual a) = a.map (toDual ∘ f) :=\n  rfl\n\n"}
{"name":"WithBot.map_ofDual","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : WithTop (OrderDual α)\n⊢ Eq (WithBot.map f (WithTop.ofDual a)) (WithTop.map (Function.comp (⇑OrderDual.ofDual) f) a)","decl":"theorem map_ofDual (f : α → β) (a : WithTop αᵒᵈ) :\n    WithBot.map f (WithTop.ofDual a) = a.map (ofDual ∘ f) :=\n  rfl\n\n"}
{"name":"WithBot.toDual_map","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : WithBot α\n⊢ Eq (WithBot.toDual (WithBot.map f a)) (WithBot.map (Function.comp (⇑OrderDual.toDual) (Function.comp f ⇑OrderDual.ofDual)) (WithBot.toDual a))","decl":"theorem toDual_map (f : α → β) (a : WithBot α) :\n    WithBot.toDual (WithBot.map f a) = map (toDual ∘ f ∘ ofDual) (WithBot.toDual a) :=\n  rfl\n\n"}
{"name":"WithBot.ofDual_map","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\nf : OrderDual α → OrderDual β\na : WithBot (OrderDual α)\n⊢ Eq (WithBot.ofDual (WithBot.map f a)) (WithBot.map (Function.comp (⇑OrderDual.ofDual) (Function.comp f ⇑OrderDual.toDual)) (WithBot.ofDual a))","decl":"theorem ofDual_map (f : αᵒᵈ → βᵒᵈ) (a : WithBot αᵒᵈ) :\n    WithBot.ofDual (WithBot.map f a) = map (ofDual ∘ f ∘ toDual) (WithBot.ofDual a) :=\n  rfl\n\n"}
{"name":"WithBot.forall_lt_iff_eq_bot","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : WithBot α\n⊢ Iff (∀ (y : α), LT.lt x ↑y) (Eq x Bot.bot)","decl":"lemma forall_lt_iff_eq_bot [Preorder α] {x : WithBot α} :\n    (∀ y : α, x < y) ↔ x = ⊥ :=\n  ⟨fun h ↦ forall_ne_iff_eq_bot.mp (fun x ↦ (h x).ne'), fun h y ↦ h ▸ bot_lt_coe y⟩\n\n"}
{"name":"WithBot.forall_le_iff_eq_bot","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : NoMinOrder α\nx : WithBot α\n⊢ Iff (∀ (y : α), LE.le x ↑y) (Eq x Bot.bot)","decl":"lemma forall_le_iff_eq_bot [Preorder α] [NoMinOrder α] {x : WithBot α} :\n    (∀ y : α, x ≤ y) ↔ x = ⊥ := by\n  refine ⟨fun h ↦ forall_lt_iff_eq_bot.1 fun y ↦ ?_, fun h _ ↦ h ▸ bot_le⟩\n  obtain ⟨w, hw⟩ := exists_lt y\n  exact (h w).trans_lt (coe_lt_coe.2 hw)\n\n"}
{"name":"WithBot.le_of_forall_lt_iff_le","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : DenselyOrdered α\ninst✝ : NoMinOrder α\nx y : WithBot α\n⊢ Iff (∀ (z : α), LT.lt x ↑z → LE.le y ↑z) (LE.le y x)","decl":"lemma le_of_forall_lt_iff_le [LinearOrder α] [DenselyOrdered α] [NoMinOrder α]\n    {x y : WithBot α} : (∀ z : α, x < z → y ≤ z) ↔ y ≤ x := by\n  refine ⟨fun h ↦ ?_, fun h z x_z ↦ h.trans x_z.le⟩\n  induction x with\n  | bot => exact le_of_eq <| forall_le_iff_eq_bot.1 fun z ↦ h z (bot_lt_coe z)\n  | coe x =>\n    rw [le_coe_iff]\n    rintro y rfl\n    exact le_of_forall_gt_imp_ge_of_dense (by exact_mod_cast h)\n\n"}
{"name":"WithBot.ge_of_forall_gt_iff_ge","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : DenselyOrdered α\ninst✝ : NoMinOrder α\nx y : WithBot α\n⊢ Iff (∀ (z : α), LT.lt (↑z) x → LE.le (↑z) y) (LE.le x y)","decl":"lemma ge_of_forall_gt_iff_ge [LinearOrder α] [DenselyOrdered α] [NoMinOrder α]\n    {x y : WithBot α} : (∀ z : α, z < x → z ≤ y) ↔ x ≤ y := by\n  apply Iff.intro _ (fun h _ x_z ↦ x_z.le.trans h)\n  induction y with\n  | bot => simpa using forall_le_iff_eq_bot.1\n  | coe y =>\n    rw [le_coe_iff]\n    rintro h x rfl\n    exact le_of_forall_lt_imp_le_of_dense (by exact_mod_cast h)\n\n"}
{"name":"WithBot.toDual_le_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na : WithBot α\nb : WithTop (OrderDual α)\n⊢ Iff (LE.le (WithBot.toDual a) b) (LE.le (WithTop.ofDual b) a)","decl":"theorem toDual_le_iff {a : WithBot α} {b : WithTop αᵒᵈ} :\n    WithBot.toDual a ≤ b ↔ WithTop.ofDual b ≤ a :=\n  Iff.rfl\n\n"}
{"name":"WithBot.le_toDual_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na : WithTop (OrderDual α)\nb : WithBot α\n⊢ Iff (LE.le a (WithBot.toDual b)) (LE.le b (WithTop.ofDual a))","decl":"theorem le_toDual_iff {a : WithTop αᵒᵈ} {b : WithBot α} :\n    a ≤ WithBot.toDual b ↔ b ≤ WithTop.ofDual a :=\n  Iff.rfl\n\n"}
{"name":"WithBot.toDual_le_toDual_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na b : WithBot α\n⊢ Iff (LE.le (WithBot.toDual a) (WithBot.toDual b)) (LE.le b a)","decl":"@[simp]\ntheorem toDual_le_toDual_iff {a b : WithBot α} : WithBot.toDual a ≤ WithBot.toDual b ↔ b ≤ a :=\n  Iff.rfl\n\n"}
{"name":"WithBot.ofDual_le_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na : WithBot (OrderDual α)\nb : WithTop α\n⊢ Iff (LE.le (WithBot.ofDual a) b) (LE.le (WithTop.toDual b) a)","decl":"theorem ofDual_le_iff {a : WithBot αᵒᵈ} {b : WithTop α} :\n    WithBot.ofDual a ≤ b ↔ WithTop.toDual b ≤ a :=\n  Iff.rfl\n\n"}
{"name":"WithBot.le_ofDual_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na : WithTop α\nb : WithBot (OrderDual α)\n⊢ Iff (LE.le a (WithBot.ofDual b)) (LE.le b (WithTop.toDual a))","decl":"theorem le_ofDual_iff {a : WithTop α} {b : WithBot αᵒᵈ} :\n    a ≤ WithBot.ofDual b ↔ b ≤ WithTop.toDual a :=\n  Iff.rfl\n\n"}
{"name":"WithBot.ofDual_le_ofDual_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LE α\na b : WithBot (OrderDual α)\n⊢ Iff (LE.le (WithBot.ofDual a) (WithBot.ofDual b)) (LE.le b a)","decl":"@[simp]\ntheorem ofDual_le_ofDual_iff {a b : WithBot αᵒᵈ} : WithBot.ofDual a ≤ WithBot.ofDual b ↔ b ≤ a :=\n  Iff.rfl\n\n"}
{"name":"WithBot.toDual_lt_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : WithBot α\nb : WithTop (OrderDual α)\n⊢ Iff (LT.lt (WithBot.toDual a) b) (LT.lt (WithTop.ofDual b) a)","decl":"theorem toDual_lt_iff {a : WithBot α} {b : WithTop αᵒᵈ} :\n    WithBot.toDual a < b ↔ WithTop.ofDual b < a :=\n  Iff.rfl\n\n"}
{"name":"WithBot.lt_toDual_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : WithTop (OrderDual α)\nb : WithBot α\n⊢ Iff (LT.lt a (WithBot.toDual b)) (LT.lt b (WithTop.ofDual a))","decl":"theorem lt_toDual_iff {a : WithTop αᵒᵈ} {b : WithBot α} :\n    a < WithBot.toDual b ↔ b < WithTop.ofDual a :=\n  Iff.rfl\n\n"}
{"name":"WithBot.toDual_lt_toDual_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : WithBot α\n⊢ Iff (LT.lt (WithBot.toDual a) (WithBot.toDual b)) (LT.lt b a)","decl":"@[simp]\ntheorem toDual_lt_toDual_iff {a b : WithBot α} : WithBot.toDual a < WithBot.toDual b ↔ b < a :=\n  Iff.rfl\n\n"}
{"name":"WithBot.ofDual_lt_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : WithBot (OrderDual α)\nb : WithTop α\n⊢ Iff (LT.lt (WithBot.ofDual a) b) (LT.lt (WithTop.toDual b) a)","decl":"theorem ofDual_lt_iff {a : WithBot αᵒᵈ} {b : WithTop α} :\n    WithBot.ofDual a < b ↔ WithTop.toDual b < a :=\n  Iff.rfl\n\n"}
{"name":"WithBot.lt_ofDual_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : WithTop α\nb : WithBot (OrderDual α)\n⊢ Iff (LT.lt a (WithBot.ofDual b)) (LT.lt b (WithTop.toDual a))","decl":"theorem lt_ofDual_iff {a : WithTop α} {b : WithBot αᵒᵈ} :\n    a < WithBot.ofDual b ↔ b < WithTop.toDual a :=\n  Iff.rfl\n\n"}
{"name":"WithBot.ofDual_lt_ofDual_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : WithBot (OrderDual α)\n⊢ Iff (LT.lt (WithBot.ofDual a) (WithBot.ofDual b)) (LT.lt b a)","decl":"@[simp]\ntheorem ofDual_lt_ofDual_iff {a b : WithBot αᵒᵈ} : WithBot.ofDual a < WithBot.ofDual b ↔ b < a :=\n  Iff.rfl\n\n"}
{"name":"WithTop.coe_lt_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : α\n⊢ Iff (LT.lt ↑a ↑b) (LT.lt a b)","decl":"@[simp, norm_cast]\ntheorem coe_lt_coe : (a : WithTop α) < b ↔ a < b := by\n  simp only [← toDual_lt_toDual_iff, toDual_apply_coe, WithBot.coe_lt_coe, toDual_lt_toDual]\n\n"}
{"name":"WithTop.coe_lt_top","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : α\n⊢ LT.lt (↑a) Top.top","decl":"@[simp]\ntheorem coe_lt_top (a : α) : (a : WithTop α) < ⊤ := by\n  simp [← toDual_lt_toDual_iff, WithBot.bot_lt_coe]\n\n"}
{"name":"WithTop.not_top_lt","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : WithTop α\n⊢ Not (LT.lt Top.top a)","decl":"@[simp]\nprotected theorem not_top_lt (a : WithTop α) : ¬⊤ < a := by\n  rw [← toDual_lt_toDual_iff]\n  exact WithBot.not_lt_bot _\n\n-- TODO: This deprecated lemma is still used (through simp)\n"}
{"name":"WithTop.some_lt_some","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : α\n⊢ Iff (LT.lt (Option.some a) (Option.some b)) (LT.lt a b)","decl":"@[simp, deprecated coe_lt_coe \"Don't mix Option and WithTop\" (since := \"2024-05-27\")]\ntheorem some_lt_some : @LT.lt (WithTop α) _ (Option.some a) (Option.some b) ↔ a < b := coe_lt_coe\n\n-- TODO: This deprecated lemma is still used (through simp)\n"}
{"name":"WithTop.some_lt_none","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : α\n⊢ LT.lt (Option.some a) Option.none","decl":"@[simp, deprecated coe_lt_top \"Don't mix Option and WithTop\" (since := \"2024-05-27\")]\ntheorem some_lt_none (a : α) : @LT.lt (WithTop α) _ (Option.some a) none := coe_lt_top a\n\n-- TODO: This deprecated lemma is still used (through simp)\n"}
{"name":"WithTop.not_none_lt","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : WithTop α\n⊢ Not (LT.lt Option.none a)","decl":"@[simp, deprecated not_top_lt \"Don't mix Option and WithTop\" (since := \"2024-05-27\")]\ntheorem not_none_lt (a : WithTop α) : ¬@LT.lt (WithTop α) _ none a := WithTop.not_top_lt _\n\n"}
{"name":"WithTop.lt_iff_exists_coe","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : WithTop α\n⊢ Iff (LT.lt a b) (Exists fun p => And (Eq a ↑p) (LT.lt (↑p) b))","decl":"theorem lt_iff_exists_coe {a b : WithTop α} : a < b ↔ ∃ p : α, a = p ∧ ↑p < b := by\n  rw [← toDual_lt_toDual_iff, WithBot.lt_iff_exists_coe, OrderDual.exists]\n  exact exists_congr fun _ => and_congr_left' Iff.rfl\n\n"}
{"name":"WithTop.coe_lt_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\na : α\nx : WithTop α\n⊢ Iff (LT.lt (↑a) x) (∀ (b : α), Eq x ↑b → LT.lt a b)","decl":"theorem coe_lt_iff {x : WithTop α} : ↑a < x ↔ ∀ b : α, x = ↑b → a < b :=\n  WithBot.lt_coe_iff (α := αᵒᵈ)\n\n"}
{"name":"WithTop.lt_top_iff_ne_top","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LT α\nx : WithTop α\n⊢ Iff (LT.lt x Top.top) (Ne x Top.top)","decl":"/-- A version of `lt_top_iff_ne_top` for `WithTop` that only requires `LT α`, not\n`PartialOrder α`. -/\nprotected theorem lt_top_iff_ne_top {x : WithTop α} : x < ⊤ ↔ x ≠ ⊤ :=\n  @WithBot.bot_lt_iff_ne_bot αᵒᵈ _ x\n\n"}
{"name":"WithTop.coe_strictMono","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ StrictMono fun a => ↑a","decl":"theorem coe_strictMono : StrictMono (fun a : α => (a : WithTop α)) := fun _ _ => coe_lt_coe.2\n\n"}
{"name":"WithTop.coe_mono","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Monotone fun a => ↑a","decl":"theorem coe_mono : Monotone (fun a : α => (a : WithTop α)) := fun _ _ => coe_le_coe.2\n\n"}
{"name":"WithTop.monotone_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : WithTop α → β\n⊢ Iff (Monotone f) (And (Monotone fun a => f ↑a) (∀ (x : α), LE.le (f ↑x) (f Top.top)))","decl":"theorem monotone_iff {f : WithTop α → β} :\n    Monotone f ↔ Monotone (fun (a : α) => f a) ∧ ∀ x : α, f x ≤ f ⊤ :=\n  ⟨fun h => ⟨h.comp WithTop.coe_mono, fun _ => h le_top⟩, fun h =>\n    WithTop.forall.2\n      ⟨WithTop.forall.2 ⟨fun _ => le_rfl, fun _ h => (not_top_le_coe _ h).elim⟩, fun x =>\n        WithTop.forall.2 ⟨fun _ => h.2 x, fun _ hle => h.1 (coe_le_coe.1 hle)⟩⟩⟩\n\n"}
{"name":"WithTop.monotone_map_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (Monotone (WithTop.map f)) (Monotone f)","decl":"@[simp]\ntheorem monotone_map_iff {f : α → β} : Monotone (WithTop.map f) ↔ Monotone f :=\n  monotone_iff.trans <| by simp [Monotone]\n\n"}
{"name":"Monotone.withTop_map","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na✝ : Monotone f\n⊢ Monotone (WithTop.map f)","decl":"alias ⟨_, _root_.Monotone.withTop_map⟩ := monotone_map_iff\n\n"}
{"name":"WithTop.strictMono_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : WithTop α → β\n⊢ Iff (StrictMono f) (And (StrictMono fun a => f ↑a) (∀ (x : α), LT.lt (f ↑x) (f Top.top)))","decl":"theorem strictMono_iff {f : WithTop α → β} :\n    StrictMono f ↔ StrictMono (fun (a : α) => f a) ∧ ∀ x : α, f x < f ⊤ :=\n  ⟨fun h => ⟨h.comp WithTop.coe_strictMono, fun _ => h (coe_lt_top _)⟩, fun h =>\n    WithTop.forall.2\n      ⟨WithTop.forall.2 ⟨flip absurd (lt_irrefl _), fun _ h => (not_top_lt h).elim⟩, fun x =>\n        WithTop.forall.2 ⟨fun _ => h.2 x, fun _ hle => h.1 (coe_lt_coe.1 hle)⟩⟩⟩\n\n"}
{"name":"WithTop.strictAnti_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : WithTop α → β\n⊢ Iff (StrictAnti f) (And (StrictAnti fun a => f ↑a) (∀ (x : α), LT.lt (f Top.top) (f ↑x)))","decl":"theorem strictAnti_iff {f : WithTop α → β} :\n    StrictAnti f ↔ StrictAnti (fun a ↦ f a : α → β) ∧ ∀ x : α, f ⊤ < f x :=\n  strictMono_iff (β := βᵒᵈ)\n\n"}
{"name":"WithTop.strictMono_map_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (StrictMono (WithTop.map f)) (StrictMono f)","decl":"@[simp]\ntheorem strictMono_map_iff {f : α → β} : StrictMono (WithTop.map f) ↔ StrictMono f :=\n  strictMono_iff.trans <| by simp [StrictMono, coe_lt_top]\n\n"}
{"name":"StrictMono.withTop_map","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na✝ : StrictMono f\n⊢ StrictMono (WithTop.map f)","decl":"alias ⟨_, _root_.StrictMono.withTop_map⟩ := strictMono_map_iff\n\n"}
{"name":"WithTop.map_le_iff","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na b : WithTop α\nmono_iff : ∀ {a b : α}, Iff (LE.le (f a) (f b)) (LE.le a b)\n⊢ Iff (LE.le (WithTop.map f a) (WithTop.map f b)) (LE.le a b)","decl":"theorem map_le_iff (f : α → β) (a b : WithTop α)\n    (mono_iff : ∀ {a b}, f a ≤ f b ↔ a ≤ b) :\n    a.map f ≤ b.map f ↔ a ≤ b := by\n  rw [← toDual_le_toDual_iff, toDual_map, toDual_map, WithBot.map_le_iff, toDual_le_toDual_iff]\n  simp [mono_iff]\n\n"}
{"name":"WithTop.coe_untop'_le","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : WithTop α\nb : α\n⊢ LE.le (↑(WithTop.untop' b a)) a","decl":"theorem coe_untop'_le (a : WithTop α) (b : α) : a.untop' b ≤ a :=\n  WithBot.le_coe_unbot' (α := αᵒᵈ) a b\n\n"}
{"name":"WithTop.coe_top_lt","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\nx : WithTop α\n⊢ Iff (LT.lt (↑Top.top) x) (Eq x Top.top)","decl":"@[simp]\ntheorem coe_top_lt [OrderTop α] {x : WithTop α} : (⊤ : α) < x ↔ x = ⊤ :=\n  WithBot.lt_coe_bot (α := αᵒᵈ)\n\n"}
{"name":"WithTop.forall_gt_iff_eq_top","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : WithTop α\n⊢ Iff (∀ (y : α), LT.lt (↑y) x) (Eq x Top.top)","decl":"lemma forall_gt_iff_eq_top {x : WithTop α} : (∀ y : α, y < x) ↔ x = ⊤ :=\n  WithBot.forall_lt_iff_eq_bot (α := αᵒᵈ)\n\n"}
{"name":"WithTop.forall_ge_iff_eq_top","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : NoMaxOrder α\nx : WithTop α\n⊢ Iff (∀ (y : α), LE.le (↑y) x) (Eq x Top.top)","decl":"lemma forall_ge_iff_eq_top [NoMaxOrder α] {x : WithTop α} : (∀ y : α, y ≤ x) ↔ x = ⊤ :=\n  WithBot.forall_le_iff_eq_bot (α := αᵒᵈ)\n\n"}
{"name":"WithTop.le_of_forall_lt_iff_le","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : DenselyOrdered α\ninst✝ : NoMaxOrder α\nx y : WithTop α\n⊢ Iff (∀ (z : α), LT.lt x ↑z → LE.le y ↑z) (LE.le y x)","decl":"lemma le_of_forall_lt_iff_le [LinearOrder α] [DenselyOrdered α] [NoMaxOrder α]\n    {x y : WithTop α} : (∀ z : α, x < z → y ≤ z) ↔ y ≤ x :=\n  WithBot.ge_of_forall_gt_iff_ge (α := αᵒᵈ)\n\n"}
{"name":"WithTop.ge_of_forall_gt_iff_ge","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : DenselyOrdered α\ninst✝ : NoMaxOrder α\nx y : WithTop α\n⊢ Iff (∀ (z : α), LT.lt (↑z) x → LE.le (↑z) y) (LE.le x y)","decl":"lemma ge_of_forall_gt_iff_ge [LinearOrder α] [DenselyOrdered α] [NoMaxOrder α]\n    {x y : WithTop α} : (∀ z : α, z < x → z ≤ y) ↔ x ≤ y :=\n  WithBot.le_of_forall_lt_iff_le (α := αᵒᵈ)\n\n"}
{"name":"WithTop.coe_inf","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : SemilatticeInf α\na b : α\n⊢ Eq (↑(Min.min a b)) (Min.min ↑a ↑b)","decl":"theorem coe_inf [SemilatticeInf α] (a b : α) : ((a ⊓ b : α) : WithTop α) = (a : WithTop α) ⊓ b :=\n  rfl\n\n"}
{"name":"WithTop.coe_sup","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : SemilatticeSup α\na b : α\n⊢ Eq (↑(Max.max a b)) (Max.max ↑a ↑b)","decl":"theorem coe_sup [SemilatticeSup α] (a b : α) : ((a ⊔ b : α) : WithTop α) = (a : WithTop α) ⊔ b :=\n  rfl\n\n"}
{"name":"WithTop.isTotal_le","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝¹ : LE α\ninst✝ : IsTotal α fun x1 x2 => LE.le x1 x2\n⊢ IsTotal (WithTop α) fun x1 x2 => LE.le x1 x2","decl":"instance isTotal_le [LE α] [IsTotal α (· ≤ ·)] : IsTotal (WithTop α) (· ≤ ·) :=\n  ⟨fun _ _ => by\n    simp_rw [← toDual_le_toDual_iff]\n    exact total_of _ _ _⟩\n\n"}
{"name":"WithTop.coe_min","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx y : α\n⊢ Eq (↑(Min.min x y)) (Min.min ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_min [LinearOrder α] (x y : α) : (↑(min x y) : WithTop α) = min (x : WithTop α) y :=\n  rfl\n\n"}
{"name":"WithTop.coe_max","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx y : α\n⊢ Eq (↑(Max.max x y)) (Max.max ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_max [LinearOrder α] (x y : α) : (↑(max x y) : WithTop α) = max (x : WithTop α) y :=\n  rfl\n\n"}
{"name":"WithTop.instWellFoundedLT","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : WellFoundedLT α\n⊢ WellFoundedLT (WithTop α)","decl":"instance instWellFoundedLT [LT α] [WellFoundedLT α] : WellFoundedLT (WithTop α) :=\n  inferInstanceAs <| WellFoundedLT (WithBot αᵒᵈ)ᵒᵈ\n\n"}
{"name":"WithTop.instWellFoundedGT","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : WellFoundedGT α\n⊢ WellFoundedGT (WithTop α)","decl":"instance instWellFoundedGT [LT α] [WellFoundedGT α] : WellFoundedGT (WithTop α) :=\n  inferInstanceAs <| WellFoundedGT (WithBot αᵒᵈ)ᵒᵈ\n\n"}
{"name":"WithTop.trichotomous.lt","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : IsTrichotomous α fun x1 x2 => LT.lt x1 x2\n⊢ IsTrichotomous (WithTop α) fun x1 x2 => LT.lt x1 x2","decl":"instance trichotomous.lt [Preorder α] [IsTrichotomous α (· < ·)] :\n    IsTrichotomous (WithTop α) (· < ·) :=\n  ⟨fun\n    | (a : α), (b : α) => by simp [trichotomous]\n    | ⊤, (b : α) => by simp\n    | (a : α), ⊤ => by simp\n    | ⊤, ⊤ => by simp⟩\n\n"}
{"name":"WithTop.IsWellOrder.lt","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : IsWellOrder α fun x1 x2 => LT.lt x1 x2\n⊢ IsWellOrder (WithTop α) fun x1 x2 => LT.lt x1 x2","decl":"instance IsWellOrder.lt [Preorder α] [IsWellOrder α (· < ·)] : IsWellOrder (WithTop α) (· < ·) where\n\n"}
{"name":"WithTop.trichotomous.gt","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : IsTrichotomous α fun x1 x2 => GT.gt x1 x2\n⊢ IsTrichotomous (WithTop α) fun x1 x2 => GT.gt x1 x2","decl":"instance trichotomous.gt [Preorder α] [IsTrichotomous α (· > ·)] :\n    IsTrichotomous (WithTop α) (· > ·) :=\n  have : IsTrichotomous α (· < ·) := .swap _; .swap _\n\n"}
{"name":"WithTop.IsWellOrder.gt","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : IsWellOrder α fun x1 x2 => GT.gt x1 x2\n⊢ IsWellOrder (WithTop α) fun x1 x2 => GT.gt x1 x2","decl":"instance IsWellOrder.gt [Preorder α] [IsWellOrder α (· > ·)] : IsWellOrder (WithTop α) (· > ·) where\n\n"}
{"name":"WithBot.trichotomous.lt","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nh : IsTrichotomous α fun x1 x2 => LT.lt x1 x2\n⊢ IsTrichotomous (WithBot α) fun x1 x2 => LT.lt x1 x2","decl":"instance _root_.WithBot.trichotomous.lt [Preorder α] [h : IsTrichotomous α (· < ·)] :\n    IsTrichotomous (WithBot α) (· < ·) :=\n  @WithTop.trichotomous.gt αᵒᵈ _ h\n\n"}
{"name":"WithBot.isWellOrder.lt","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : IsWellOrder α fun x1 x2 => LT.lt x1 x2\n⊢ IsWellOrder (WithBot α) fun x1 x2 => LT.lt x1 x2","decl":"instance _root_.WithBot.isWellOrder.lt [Preorder α] [IsWellOrder α (· < ·)] :\n    IsWellOrder (WithBot α) (· < ·) where\n\n"}
{"name":"WithBot.trichotomous.gt","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nh : IsTrichotomous α fun x1 x2 => GT.gt x1 x2\n⊢ IsTrichotomous (WithBot α) fun x1 x2 => GT.gt x1 x2","decl":"instance _root_.WithBot.trichotomous.gt [Preorder α] [h : IsTrichotomous α (· > ·)] :\n    IsTrichotomous (WithBot α) (· > ·) :=\n  @WithTop.trichotomous.lt αᵒᵈ _ h\n\n"}
{"name":"WithBot.isWellOrder.gt","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nh : IsWellOrder α fun x1 x2 => GT.gt x1 x2\n⊢ IsWellOrder (WithBot α) fun x1 x2 => GT.gt x1 x2","decl":"instance _root_.WithBot.isWellOrder.gt [Preorder α] [h : IsWellOrder α (· > ·)] :\n    IsWellOrder (WithBot α) (· > ·) :=\n  @WithTop.IsWellOrder.lt αᵒᵈ _ h\n\n"}
{"name":"WithTop.instDenselyOrderedOfNoMaxOrder","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝² : LT α\ninst✝¹ : DenselyOrdered α\ninst✝ : NoMaxOrder α\n⊢ DenselyOrdered (WithTop α)","decl":"instance [LT α] [DenselyOrdered α] [NoMaxOrder α] : DenselyOrdered (WithTop α) :=\n  OrderDual.denselyOrdered (WithBot αᵒᵈ)\n\n"}
{"name":"WithTop.lt_iff_exists_coe_btwn","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : DenselyOrdered α\ninst✝ : NoMaxOrder α\na b : WithTop α\n⊢ Iff (LT.lt a b) (Exists fun x => And (LT.lt a ↑x) (LT.lt (↑x) b))","decl":"theorem lt_iff_exists_coe_btwn [Preorder α] [DenselyOrdered α] [NoMaxOrder α] {a b : WithTop α} :\n    a < b ↔ ∃ x : α, a < ↑x ∧ ↑x < b :=\n  ⟨fun h =>\n    let ⟨_, hy⟩ := exists_between h\n    let ⟨x, hx⟩ := lt_iff_exists_coe.1 hy.2\n    ⟨x, hx.1 ▸ hy⟩,\n    fun ⟨_, hx⟩ => lt_trans hx.1 hx.2⟩\n\n"}
{"name":"WithTop.noBotOrder","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝² : LE α\ninst✝¹ : NoBotOrder α\ninst✝ : Nonempty α\n⊢ NoBotOrder (WithTop α)","decl":"instance noBotOrder [LE α] [NoBotOrder α] [Nonempty α] : NoBotOrder (WithTop α) :=\n  @OrderDual.noBotOrder (WithBot αᵒᵈ) _ _\n\n"}
{"name":"WithTop.noMinOrder","module":"Mathlib.Order.WithBot","initialProofState":"α : Type u_1\ninst✝² : LT α\ninst✝¹ : NoMinOrder α\ninst✝ : Nonempty α\n⊢ NoMinOrder (WithTop α)","decl":"instance noMinOrder [LT α] [NoMinOrder α] [Nonempty α] : NoMinOrder (WithTop α) :=\n  @OrderDual.noMinOrder (WithBot αᵒᵈ) _ _\n\n"}
