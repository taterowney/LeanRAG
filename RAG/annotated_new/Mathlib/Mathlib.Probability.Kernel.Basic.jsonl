{"name":"ProbabilityTheory.Kernel.deterministic_apply","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\nhf : Measurable f\na : α\n⊢ Eq ((ProbabilityTheory.Kernel.deterministic f hf) a) (MeasureTheory.Measure.dirac (f a))","decl":"theorem deterministic_apply {f : α → β} (hf : Measurable f) (a : α) :\n    deterministic f hf a = Measure.dirac (f a) :=\n  rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.deterministic_apply'","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\nhf : Measurable f\na : α\ns : Set β\nhs : MeasurableSet s\n⊢ Eq (((ProbabilityTheory.Kernel.deterministic f hf) a) s) (s.indicator (fun x => 1) (f a))","decl":"theorem deterministic_apply' {f : α → β} (hf : Measurable f) (a : α) {s : Set β}\n    (hs : MeasurableSet s) : deterministic f hf a s = s.indicator (fun _ => 1) (f a) := by\n  rw [deterministic]\n  change Measure.dirac (f a) s = s.indicator 1 (f a)\n  simp_rw [Measure.dirac_apply' _ hs]\n\n"}
{"name":"ProbabilityTheory.Kernel.isMarkovKernel_deterministic","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\nhf : Measurable f\n⊢ ProbabilityTheory.IsMarkovKernel (ProbabilityTheory.Kernel.deterministic f hf)","decl":"instance isMarkovKernel_deterministic {f : α → β} (hf : Measurable f) :\n    IsMarkovKernel (deterministic f hf) :=\n  ⟨fun a => by rw [deterministic_apply hf]; infer_instance⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.lintegral_deterministic'","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : β → ENNReal\ng : α → β\na : α\nhg : Measurable g\nhf : Measurable f\n⊢ Eq (MeasureTheory.lintegral ((ProbabilityTheory.Kernel.deterministic g hg) a) fun x => f x) (f (g a))","decl":"theorem lintegral_deterministic' {f : β → ℝ≥0∞} {g : α → β} {a : α} (hg : Measurable g)\n    (hf : Measurable f) : ∫⁻ x, f x ∂deterministic g hg a = f (g a) := by\n  rw [deterministic_apply, lintegral_dirac' _ hf]\n\n"}
{"name":"ProbabilityTheory.Kernel.lintegral_deterministic","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : β → ENNReal\ng : α → β\na : α\nhg : Measurable g\ninst✝ : MeasurableSingletonClass β\n⊢ Eq (MeasureTheory.lintegral ((ProbabilityTheory.Kernel.deterministic g hg) a) fun x => f x) (f (g a))","decl":"@[simp]\ntheorem lintegral_deterministic {f : β → ℝ≥0∞} {g : α → β} {a : α} (hg : Measurable g)\n    [MeasurableSingletonClass β] : ∫⁻ x, f x ∂deterministic g hg a = f (g a) := by\n  rw [deterministic_apply, lintegral_dirac (g a) f]\n\n"}
{"name":"ProbabilityTheory.Kernel.setLIntegral_deterministic'","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : β → ENNReal\ng : α → β\na : α\nhg : Measurable g\nhf : Measurable f\ns : Set β\nhs : MeasurableSet s\ninst✝ : Decidable (Membership.mem s (g a))\n⊢ Eq (MeasureTheory.lintegral (((ProbabilityTheory.Kernel.deterministic g hg) a).restrict s) fun x => f x) (ite (Membership.mem s (g a)) (f (g a)) 0)","decl":"theorem setLIntegral_deterministic' {f : β → ℝ≥0∞} {g : α → β} {a : α} (hg : Measurable g)\n    (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) [Decidable (g a ∈ s)] :\n    ∫⁻ x in s, f x ∂deterministic g hg a = if g a ∈ s then f (g a) else 0 := by\n  rw [deterministic_apply, setLIntegral_dirac' hf hs]\n\n"}
{"name":"ProbabilityTheory.Kernel.setLIntegral_deterministic","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : β → ENNReal\ng : α → β\na : α\nhg : Measurable g\ninst✝¹ : MeasurableSingletonClass β\ns : Set β\ninst✝ : Decidable (Membership.mem s (g a))\n⊢ Eq (MeasureTheory.lintegral (((ProbabilityTheory.Kernel.deterministic g hg) a).restrict s) fun x => f x) (ite (Membership.mem s (g a)) (f (g a)) 0)","decl":"@[simp]\ntheorem setLIntegral_deterministic {f : β → ℝ≥0∞} {g : α → β} {a : α} (hg : Measurable g)\n    [MeasurableSingletonClass β] (s : Set β) [Decidable (g a ∈ s)] :\n    ∫⁻ x in s, f x ∂deterministic g hg a = if g a ∈ s then f (g a) else 0 := by\n  rw [deterministic_apply, setLIntegral_dirac f s]\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsMarkovKernelId","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\n⊢ ProbabilityTheory.IsMarkovKernel ProbabilityTheory.Kernel.id","decl":"instance : IsMarkovKernel (Kernel.id : Kernel α α) := by rw [Kernel.id]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.id_apply","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\na : α\n⊢ Eq (ProbabilityTheory.Kernel.id a) (MeasureTheory.Measure.dirac a)","decl":"lemma id_apply (a : α) : Kernel.id a = Measure.dirac a := by\n  rw [Kernel.id, deterministic_apply, id_def]\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsMarkovKernelProdCopy","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\n⊢ ProbabilityTheory.IsMarkovKernel (ProbabilityTheory.Kernel.copy α)","decl":"instance : IsMarkovKernel (copy α) := by rw [copy]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.copy_apply","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\na : α\n⊢ Eq ((ProbabilityTheory.Kernel.copy α) a) (MeasureTheory.Measure.dirac { fst := a, snd := a })","decl":"lemma copy_apply (a : α) : copy α a = Measure.dirac (a, a) := by simp [copy, deterministic_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsMarkovKernelUnitDiscard","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\n⊢ ProbabilityTheory.IsMarkovKernel (ProbabilityTheory.Kernel.discard α)","decl":"instance : IsMarkovKernel (discard α) := by rw [discard]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.discard_apply","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\na : α\n⊢ Eq ((ProbabilityTheory.Kernel.discard α) a) (MeasureTheory.Measure.dirac Unit.unit)","decl":"@[simp]\nlemma discard_apply (a : α) : discard α a = Measure.dirac () := deterministic_apply _ _\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsMarkovKernelProdSwap","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\n⊢ ProbabilityTheory.IsMarkovKernel (ProbabilityTheory.Kernel.swap α β)","decl":"instance : IsMarkovKernel (swap α β) := by rw [swap]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.swap_apply","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nab : Prod α β\n⊢ Eq ((ProbabilityTheory.Kernel.swap α β) ab) (MeasureTheory.Measure.dirac ab.swap)","decl":"/-- See `swap_apply'` for a fully applied version of this lemma. -/\nlemma swap_apply (ab : α × β) : swap α β ab = Measure.dirac ab.swap := by\n  rw [swap, deterministic_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.swap_apply'","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nab : Prod α β\ns : Set (Prod β α)\nhs : MeasurableSet s\n⊢ Eq (((ProbabilityTheory.Kernel.swap α β) ab) s) (s.indicator 1 ab.swap)","decl":"/-- See `swap_apply` for a partially applied version of this lemma. -/\nlemma swap_apply' (ab : α × β) {s : Set (β × α)} (hs : MeasurableSet s) :\n    swap α β ab s = s.indicator 1 ab.swap := by\n  rw [swap_apply, Measure.dirac_apply' _ hs]\n\n"}
{"name":"ProbabilityTheory.Kernel.const_apply","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμβ : MeasureTheory.Measure β\na : α\n⊢ Eq ((ProbabilityTheory.Kernel.const α μβ) a) μβ","decl":"@[simp]\ntheorem const_apply (μβ : Measure β) (a : α) : const α μβ a = μβ :=\n  rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.const_zero","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\n⊢ Eq (ProbabilityTheory.Kernel.const α 0) 0","decl":"@[simp]\nlemma const_zero : const α (0 : Measure β) = 0 := by\n  ext x s _; simp [const_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.const_add","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nβ : Type u_4\ninst✝ : MeasurableSpace β\nμ ν : MeasureTheory.Measure α\n⊢ Eq (ProbabilityTheory.Kernel.const β (HAdd.hAdd μ ν)) (HAdd.hAdd (ProbabilityTheory.Kernel.const β μ) (ProbabilityTheory.Kernel.const β ν))","decl":"lemma const_add (β : Type*) [MeasurableSpace β] (μ ν : Measure α) :\n    const β (μ + ν) = const β μ + const β ν := by ext; simp\n\n"}
{"name":"ProbabilityTheory.Kernel.sum_const","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : Countable ι\nμ : ι → MeasureTheory.Measure β\n⊢ Eq (ProbabilityTheory.Kernel.sum fun n => ProbabilityTheory.Kernel.const α (μ n)) (ProbabilityTheory.Kernel.const α (MeasureTheory.Measure.sum μ))","decl":"lemma sum_const [Countable ι] (μ : ι → Measure β) :\n    Kernel.sum (fun n ↦ const α (μ n)) = const α (Measure.sum μ) := by\n  ext x s hs\n  rw [const_apply, Measure.sum_apply _ hs, Kernel.sum_apply' _ _ hs]\n  simp only [const_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.const.instIsFiniteKernel","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμβ : MeasureTheory.Measure β\ninst✝ : MeasureTheory.IsFiniteMeasure μβ\n⊢ ProbabilityTheory.IsFiniteKernel (ProbabilityTheory.Kernel.const α μβ)","decl":"instance const.instIsFiniteKernel {μβ : Measure β} [IsFiniteMeasure μβ] :\n    IsFiniteKernel (const α μβ) :=\n  ⟨⟨μβ Set.univ, measure_lt_top _ _, fun _ => le_rfl⟩⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.const.instIsSFiniteKernel","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμβ : MeasureTheory.Measure β\ninst✝ : MeasureTheory.SFinite μβ\n⊢ ProbabilityTheory.IsSFiniteKernel (ProbabilityTheory.Kernel.const α μβ)","decl":"instance const.instIsSFiniteKernel {μβ : Measure β} [SFinite μβ] :\n    IsSFiniteKernel (const α μβ) :=\n  ⟨fun n ↦ const α (sfiniteSeq μβ n), fun n ↦ inferInstance, by rw [sum_const, sum_sfiniteSeq]⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.const.instIsMarkovKernel","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμβ : MeasureTheory.Measure β\nhμβ : MeasureTheory.IsProbabilityMeasure μβ\n⊢ ProbabilityTheory.IsMarkovKernel (ProbabilityTheory.Kernel.const α μβ)","decl":"instance const.instIsMarkovKernel {μβ : Measure β} [hμβ : IsProbabilityMeasure μβ] :\n    IsMarkovKernel (const α μβ) :=\n  ⟨fun _ => hμβ⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.const.instIsZeroOrMarkovKernel","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμβ : MeasureTheory.Measure β\nhμβ : MeasureTheory.IsZeroOrProbabilityMeasure μβ\n⊢ ProbabilityTheory.IsZeroOrMarkovKernel (ProbabilityTheory.Kernel.const α μβ)","decl":"instance const.instIsZeroOrMarkovKernel {μβ : Measure β} [hμβ : IsZeroOrProbabilityMeasure μβ] :\n    IsZeroOrMarkovKernel (const α μβ) := by\n  rcases eq_zero_or_isProbabilityMeasure μβ with rfl | h\n  · simp only [const_zero]\n    infer_instance\n  · infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.isSFiniteKernel_const","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : Nonempty α\nμβ : MeasureTheory.Measure β\n⊢ Iff (ProbabilityTheory.IsSFiniteKernel (ProbabilityTheory.Kernel.const α μβ)) (MeasureTheory.SFinite μβ)","decl":"lemma isSFiniteKernel_const [Nonempty α] {μβ : Measure β} :\n    IsSFiniteKernel (const α μβ) ↔ SFinite μβ :=\n  ⟨fun h ↦ h.sFinite (Classical.arbitrary α), fun _ ↦ inferInstance⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.lintegral_const","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : β → ENNReal\nμ : MeasureTheory.Measure β\na : α\n⊢ Eq (MeasureTheory.lintegral ((ProbabilityTheory.Kernel.const α μ) a) fun x => f x) (MeasureTheory.lintegral μ fun x => f x)","decl":"@[simp]\ntheorem lintegral_const {f : β → ℝ≥0∞} {μ : Measure β} {a : α} :\n    ∫⁻ x, f x ∂const α μ a = ∫⁻ x, f x ∂μ := by rw [const_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.setLIntegral_const","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : β → ENNReal\nμ : MeasureTheory.Measure β\na : α\ns : Set β\n⊢ Eq (MeasureTheory.lintegral (((ProbabilityTheory.Kernel.const α μ) a).restrict s) fun x => f x) (MeasureTheory.lintegral (μ.restrict s) fun x => f x)","decl":"@[simp]\ntheorem setLIntegral_const {f : β → ℝ≥0∞} {μ : Measure β} {a : α} {s : Set β} :\n    ∫⁻ x in s, f x ∂const α μ a = ∫⁻ x in s, f x ∂μ := by rw [const_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.restrict_apply","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ns : Set β\nκ : ProbabilityTheory.Kernel α β\nhs : MeasurableSet s\na : α\n⊢ Eq ((κ.restrict hs) a) ((κ a).restrict s)","decl":"theorem restrict_apply (κ : Kernel α β) (hs : MeasurableSet s) (a : α) :\n    κ.restrict hs a = (κ a).restrict s :=\n  rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.restrict_apply'","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ns t : Set β\nκ : ProbabilityTheory.Kernel α β\nhs : MeasurableSet s\na : α\nht : MeasurableSet t\n⊢ Eq (((κ.restrict hs) a) t) ((κ a) (Inter.inter t s))","decl":"theorem restrict_apply' (κ : Kernel α β) (hs : MeasurableSet s) (a : α) (ht : MeasurableSet t) :\n    κ.restrict hs a t = (κ a) (t ∩ s) := by\n  rw [restrict_apply κ hs a, Measure.restrict_apply ht]\n\n"}
{"name":"ProbabilityTheory.Kernel.restrict_univ","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\n⊢ Eq (κ.restrict ⋯) κ","decl":"@[simp]\ntheorem restrict_univ : κ.restrict MeasurableSet.univ = κ := by\n  ext1 a\n  rw [Kernel.restrict_apply, Measure.restrict_univ]\n\n"}
{"name":"ProbabilityTheory.Kernel.lintegral_restrict","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ns : Set β\nκ : ProbabilityTheory.Kernel α β\nhs : MeasurableSet s\na : α\nf : β → ENNReal\n⊢ Eq (MeasureTheory.lintegral ((κ.restrict hs) a) fun b => f b) (MeasureTheory.lintegral ((κ a).restrict s) fun b => f b)","decl":"@[simp]\ntheorem lintegral_restrict (κ : Kernel α β) (hs : MeasurableSet s) (a : α) (f : β → ℝ≥0∞) :\n    ∫⁻ b, f b ∂κ.restrict hs a = ∫⁻ b in s, f b ∂κ a := by rw [restrict_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.setLIntegral_restrict","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ns : Set β\nκ : ProbabilityTheory.Kernel α β\nhs : MeasurableSet s\na : α\nf : β → ENNReal\nt : Set β\n⊢ Eq (MeasureTheory.lintegral (((κ.restrict hs) a).restrict t) fun b => f b) (MeasureTheory.lintegral ((κ a).restrict (Inter.inter t s)) fun b => f b)","decl":"@[simp]\ntheorem setLIntegral_restrict (κ : Kernel α β) (hs : MeasurableSet s) (a : α) (f : β → ℝ≥0∞)\n    (t : Set β) : ∫⁻ b in t, f b ∂κ.restrict hs a = ∫⁻ b in t ∩ s, f b ∂κ a := by\n  rw [restrict_apply, Measure.restrict_restrict' hs]\n\n\n"}
{"name":"ProbabilityTheory.Kernel.IsFiniteKernel.restrict","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ns : Set β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\nhs : MeasurableSet s\n⊢ ProbabilityTheory.IsFiniteKernel (κ.restrict hs)","decl":"instance IsFiniteKernel.restrict (κ : Kernel α β) [IsFiniteKernel κ] (hs : MeasurableSet s) :\n    IsFiniteKernel (κ.restrict hs) := by\n  refine ⟨⟨IsFiniteKernel.bound κ, IsFiniteKernel.bound_lt_top κ, fun a => ?_⟩⟩\n  rw [restrict_apply' κ hs a MeasurableSet.univ]\n  exact measure_le_bound κ a _\n\n"}
{"name":"ProbabilityTheory.Kernel.IsSFiniteKernel.restrict","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ns : Set β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nhs : MeasurableSet s\n⊢ ProbabilityTheory.IsSFiniteKernel (κ.restrict hs)","decl":"instance IsSFiniteKernel.restrict (κ : Kernel α β) [IsSFiniteKernel κ] (hs : MeasurableSet s) :\n    IsSFiniteKernel (κ.restrict hs) := by\n  refine ⟨⟨fun n => Kernel.restrict (seq κ n) hs, inferInstance, ?_⟩⟩\n  ext1 a\n  simp_rw [sum_apply, restrict_apply, ← Measure.restrict_sum _ hs, ← sum_apply, kernel_sum_seq]\n\n"}
{"name":"ProbabilityTheory.Kernel.comapRight_apply","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nf : γ → β\nκ : ProbabilityTheory.Kernel α β\nhf : MeasurableEmbedding f\na : α\n⊢ Eq ((κ.comapRight hf) a) (MeasureTheory.Measure.comap f (κ a))","decl":"theorem comapRight_apply (κ : Kernel α β) (hf : MeasurableEmbedding f) (a : α) :\n    comapRight κ hf a = Measure.comap f (κ a) :=\n  rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.comapRight_apply'","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nf : γ → β\nκ : ProbabilityTheory.Kernel α β\nhf : MeasurableEmbedding f\na : α\nt : Set γ\nht : MeasurableSet t\n⊢ Eq (((κ.comapRight hf) a) t) ((κ a) (Set.image f t))","decl":"theorem comapRight_apply' (κ : Kernel α β) (hf : MeasurableEmbedding f) (a : α) {t : Set γ}\n    (ht : MeasurableSet t) : comapRight κ hf a t = κ a (f '' t) := by\n  rw [comapRight_apply,\n    Measure.comap_apply _ hf.injective (fun s => hf.measurableSet_image.mpr) _ ht]\n\n"}
{"name":"ProbabilityTheory.Kernel.comapRight_id","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\n⊢ Eq (κ.comapRight ⋯) κ","decl":"@[simp]\nlemma comapRight_id (κ : Kernel α β) : comapRight κ MeasurableEmbedding.id = κ := by\n  ext _ _ hs; rw [comapRight_apply' _ _ _ hs]; simp\n\n"}
{"name":"ProbabilityTheory.Kernel.IsMarkovKernel.comapRight","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nf : γ → β\nκ : ProbabilityTheory.Kernel α β\nhf : MeasurableEmbedding f\nhκ : ∀ (a : α), Eq ((κ a) (Set.range f)) 1\n⊢ ProbabilityTheory.IsMarkovKernel (κ.comapRight hf)","decl":"theorem IsMarkovKernel.comapRight (κ : Kernel α β) (hf : MeasurableEmbedding f)\n    (hκ : ∀ a, κ a (Set.range f) = 1) : IsMarkovKernel (comapRight κ hf) := by\n  refine ⟨fun a => ⟨?_⟩⟩\n  rw [comapRight_apply' κ hf a MeasurableSet.univ]\n  simp only [Set.image_univ, Subtype.range_coe_subtype, Set.setOf_mem_eq]\n  exact hκ a\n\n"}
{"name":"ProbabilityTheory.Kernel.IsFiniteKernel.comapRight","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nf : γ → β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\nhf : MeasurableEmbedding f\n⊢ ProbabilityTheory.IsFiniteKernel (κ.comapRight hf)","decl":"instance IsFiniteKernel.comapRight (κ : Kernel α β) [IsFiniteKernel κ]\n    (hf : MeasurableEmbedding f) : IsFiniteKernel (comapRight κ hf) := by\n  refine ⟨⟨IsFiniteKernel.bound κ, IsFiniteKernel.bound_lt_top κ, fun a => ?_⟩⟩\n  rw [comapRight_apply' κ hf a .univ]\n  exact measure_le_bound κ a _\n\n"}
{"name":"ProbabilityTheory.Kernel.IsSFiniteKernel.comapRight","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nf : γ → β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nhf : MeasurableEmbedding f\n⊢ ProbabilityTheory.IsSFiniteKernel (κ.comapRight hf)","decl":"protected instance IsSFiniteKernel.comapRight (κ : Kernel α β) [IsSFiniteKernel κ]\n    (hf : MeasurableEmbedding f) : IsSFiniteKernel (comapRight κ hf) := by\n  refine ⟨⟨fun n => comapRight (seq κ n) hf, inferInstance, ?_⟩⟩\n  ext1 a\n  rw [sum_apply]\n  simp_rw [comapRight_apply _ hf]\n  have :\n    (Measure.sum fun n => Measure.comap f (seq κ n a)) =\n      Measure.comap f (Measure.sum fun n => seq κ n a) := by\n    ext1 t ht\n    rw [Measure.comap_apply _ hf.injective (fun s' => hf.measurableSet_image.mpr) _ ht,\n      Measure.sum_apply _ ht, Measure.sum_apply _ (hf.measurableSet_image.mpr ht)]\n    congr with n : 1\n    rw [Measure.comap_apply _ hf.injective (fun s' => hf.measurableSet_image.mpr) _ ht]\n  rw [this, measure_sum_seq]\n\n"}
{"name":"ProbabilityTheory.Kernel.piecewise_apply","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ η : ProbabilityTheory.Kernel α β\ns : Set α\nhs : MeasurableSet s\ninst✝ : DecidablePred fun x => Membership.mem s x\na : α\n⊢ Eq ((ProbabilityTheory.Kernel.piecewise hs κ η) a) (ite (Membership.mem s a) (κ a) (η a))","decl":"theorem piecewise_apply (a : α) : piecewise hs κ η a = if a ∈ s then κ a else η a :=\n  rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.piecewise_apply'","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ η : ProbabilityTheory.Kernel α β\ns : Set α\nhs : MeasurableSet s\ninst✝ : DecidablePred fun x => Membership.mem s x\na : α\nt : Set β\n⊢ Eq (((ProbabilityTheory.Kernel.piecewise hs κ η) a) t) (ite (Membership.mem s a) ((κ a) t) ((η a) t))","decl":"theorem piecewise_apply' (a : α) (t : Set β) :\n    piecewise hs κ η a t = if a ∈ s then κ a t else η a t := by\n  rw [piecewise_apply]; split_ifs <;> rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.IsMarkovKernel.piecewise","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ η : ProbabilityTheory.Kernel α β\ns : Set α\nhs : MeasurableSet s\ninst✝² : DecidablePred fun x => Membership.mem s x\ninst✝¹ : ProbabilityTheory.IsMarkovKernel κ\ninst✝ : ProbabilityTheory.IsMarkovKernel η\n⊢ ProbabilityTheory.IsMarkovKernel (ProbabilityTheory.Kernel.piecewise hs κ η)","decl":"instance IsMarkovKernel.piecewise [IsMarkovKernel κ] [IsMarkovKernel η] :\n    IsMarkovKernel (piecewise hs κ η) := by\n  refine ⟨fun a => ⟨?_⟩⟩\n  rw [piecewise_apply', measure_univ, measure_univ, ite_self]\n\n"}
{"name":"ProbabilityTheory.Kernel.IsFiniteKernel.piecewise","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ η : ProbabilityTheory.Kernel α β\ns : Set α\nhs : MeasurableSet s\ninst✝² : DecidablePred fun x => Membership.mem s x\ninst✝¹ : ProbabilityTheory.IsFiniteKernel κ\ninst✝ : ProbabilityTheory.IsFiniteKernel η\n⊢ ProbabilityTheory.IsFiniteKernel (ProbabilityTheory.Kernel.piecewise hs κ η)","decl":"instance IsFiniteKernel.piecewise [IsFiniteKernel κ] [IsFiniteKernel η] :\n    IsFiniteKernel (piecewise hs κ η) := by\n  refine ⟨⟨max (IsFiniteKernel.bound κ) (IsFiniteKernel.bound η), ?_, fun a => ?_⟩⟩\n  · exact max_lt (IsFiniteKernel.bound_lt_top κ) (IsFiniteKernel.bound_lt_top η)\n  rw [piecewise_apply']\n  exact (ite_le_sup _ _ _).trans (sup_le_sup (measure_le_bound _ _ _) (measure_le_bound _ _ _))\n\n"}
{"name":"ProbabilityTheory.Kernel.IsSFiniteKernel.piecewise","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ η : ProbabilityTheory.Kernel α β\ns : Set α\nhs : MeasurableSet s\ninst✝² : DecidablePred fun x => Membership.mem s x\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\n⊢ ProbabilityTheory.IsSFiniteKernel (ProbabilityTheory.Kernel.piecewise hs κ η)","decl":"protected instance IsSFiniteKernel.piecewise [IsSFiniteKernel κ] [IsSFiniteKernel η] :\n    IsSFiniteKernel (piecewise hs κ η) := by\n  refine ⟨⟨fun n => piecewise hs (seq κ n) (seq η n), inferInstance, ?_⟩⟩\n  ext1 a\n  simp_rw [sum_apply, Kernel.piecewise_apply]\n  split_ifs <;> exact (measure_sum_seq _ a).symm\n\n"}
{"name":"ProbabilityTheory.Kernel.lintegral_piecewise","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ η : ProbabilityTheory.Kernel α β\ns : Set α\nhs : MeasurableSet s\ninst✝ : DecidablePred fun x => Membership.mem s x\na : α\ng : β → ENNReal\n⊢ Eq (MeasureTheory.lintegral ((ProbabilityTheory.Kernel.piecewise hs κ η) a) fun b => g b) (ite (Membership.mem s a) (MeasureTheory.lintegral (κ a) fun b => g b) (MeasureTheory.lintegral (η a) fun b => g b))","decl":"theorem lintegral_piecewise (a : α) (g : β → ℝ≥0∞) :\n    ∫⁻ b, g b ∂piecewise hs κ η a = if a ∈ s then ∫⁻ b, g b ∂κ a else ∫⁻ b, g b ∂η a := by\n  simp_rw [piecewise_apply]; split_ifs <;> rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.setLIntegral_piecewise","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ η : ProbabilityTheory.Kernel α β\ns : Set α\nhs : MeasurableSet s\ninst✝ : DecidablePred fun x => Membership.mem s x\na : α\ng : β → ENNReal\nt : Set β\n⊢ Eq (MeasureTheory.lintegral (((ProbabilityTheory.Kernel.piecewise hs κ η) a).restrict t) fun b => g b) (ite (Membership.mem s a) (MeasureTheory.lintegral ((κ a).restrict t) fun b => g b) (MeasureTheory.lintegral ((η a).restrict t) fun b => g b))","decl":"theorem setLIntegral_piecewise (a : α) (g : β → ℝ≥0∞) (t : Set β) :\n    ∫⁻ b in t, g b ∂piecewise hs κ η a =\n      if a ∈ s then ∫⁻ b in t, g b ∂κ a else ∫⁻ b in t, g b ∂η a := by\n  simp_rw [piecewise_apply]; split_ifs <;> rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.exists_ae_eq_isMarkovKernel","module":"Mathlib.Probability.Kernel.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nμ : MeasureTheory.Measure α\nh : Filter.Eventually (fun a => MeasureTheory.IsProbabilityMeasure (κ a)) (MeasureTheory.ae μ)\nh' : Ne μ 0\n⊢ Exists fun η => And ((MeasureTheory.ae μ).EventuallyEq ⇑κ ⇑η) (ProbabilityTheory.IsMarkovKernel η)","decl":"lemma exists_ae_eq_isMarkovKernel {μ : Measure α}\n    (h : ∀ᵐ a ∂μ, IsProbabilityMeasure (κ a)) (h' : μ ≠ 0) :\n    ∃ (η : Kernel α β), (κ =ᵐ[μ] η) ∧ IsMarkovKernel η := by\n  classical\n  obtain ⟨s, s_meas, μs, hs⟩ : ∃ s, MeasurableSet s ∧ μ s = 0\n      ∧ ∀ a ∉ s, IsProbabilityMeasure (κ a) := by\n    refine ⟨toMeasurable μ {a | ¬ IsProbabilityMeasure (κ a)}, measurableSet_toMeasurable _ _,\n      by simpa [measure_toMeasurable] using h, ?_⟩\n    intro a ha\n    contrapose! ha\n    exact subset_toMeasurable _ _ ha\n  obtain ⟨a, ha⟩ : sᶜ.Nonempty := by\n    contrapose! h'; simpa [μs, h'] using measure_univ_le_add_compl s (μ := μ)\n  refine ⟨Kernel.piecewise s_meas (Kernel.const _ (κ a)) κ, ?_, ?_⟩\n  · filter_upwards [measure_zero_iff_ae_nmem.1 μs] with b hb\n    simp [hb, piecewise]\n  · refine ⟨fun b ↦ ?_⟩\n    by_cases hb : b ∈ s\n    · simpa [hb, piecewise] using hs _ ha\n    · simpa [hb, piecewise] using hs _ hb\n\n"}
