{"name":"WeakDual.CharacterSpace.instContinuousLinearMapClass","module":"Mathlib.Topology.Algebra.Module.CharacterSpace","initialProofState":"ð•œ : Type u_1\nA : Type u_2\ninstâœâ¶ : CommSemiring ð•œ\ninstâœâµ : TopologicalSpace ð•œ\ninstâœâ´ : ContinuousAdd ð•œ\ninstâœÂ³ : ContinuousConstSMul ð•œ ð•œ\ninstâœÂ² : NonUnitalNonAssocSemiring A\ninstâœÂ¹ : TopologicalSpace A\ninstâœ : Module ð•œ A\nâŠ¢ ContinuousLinearMapClass (â†‘(WeakDual.characterSpace ð•œ A)) ð•œ A ð•œ","decl":"/-- Elements of the character space are continuous linear maps. -/\ninstance instContinuousLinearMapClass : ContinuousLinearMapClass (characterSpace ð•œ A) ð•œ A ð•œ where\n  map_smulâ‚›â‚— Ï† := (Ï† : WeakDual ð•œ A).map_smul\n  map_add Ï† := (Ï† : WeakDual ð•œ A).map_add\n  map_continuous Ï† := (Ï† : WeakDual ð•œ A).cont\n\n-- Porting note: moved because Lean 4 doesn't see the `DFunLike` instance on `characterSpace ð•œ A`\n-- until the `ContinuousLinearMapClass` instance is declared\n"}
{"name":"WeakDual.CharacterSpace.coe_coe","module":"Mathlib.Topology.Algebra.Module.CharacterSpace","initialProofState":"ð•œ : Type u_1\nA : Type u_2\ninstâœâ¶ : CommSemiring ð•œ\ninstâœâµ : TopologicalSpace ð•œ\ninstâœâ´ : ContinuousAdd ð•œ\ninstâœÂ³ : ContinuousConstSMul ð•œ ð•œ\ninstâœÂ² : NonUnitalNonAssocSemiring A\ninstâœÂ¹ : TopologicalSpace A\ninstâœ : Module ð•œ A\nÏ† : â†‘(WeakDual.characterSpace ð•œ A)\nâŠ¢ Eq â‡‘â†‘Ï† â‡‘Ï†","decl":"@[simp, norm_cast]\nprotected theorem coe_coe (Ï† : characterSpace ð•œ A) : â‡‘(Ï† : WeakDual ð•œ A) = (Ï† : A â†’ ð•œ) :=\n  rfl\n\n"}
{"name":"WeakDual.CharacterSpace.ext_iff","module":"Mathlib.Topology.Algebra.Module.CharacterSpace","initialProofState":"ð•œ : Type u_1\nA : Type u_2\ninstâœâ¶ : CommSemiring ð•œ\ninstâœâµ : TopologicalSpace ð•œ\ninstâœâ´ : ContinuousAdd ð•œ\ninstâœÂ³ : ContinuousConstSMul ð•œ ð•œ\ninstâœÂ² : NonUnitalNonAssocSemiring A\ninstâœÂ¹ : TopologicalSpace A\ninstâœ : Module ð•œ A\nÏ† Ïˆ : â†‘(WeakDual.characterSpace ð•œ A)\nâŠ¢ Iff (Eq Ï† Ïˆ) (âˆ€ (x : A), Eq (Ï† x) (Ïˆ x))","decl":"@[ext]\ntheorem ext {Ï† Ïˆ : characterSpace ð•œ A} (h : âˆ€ x, Ï† x = Ïˆ x) : Ï† = Ïˆ :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"WeakDual.CharacterSpace.ext","module":"Mathlib.Topology.Algebra.Module.CharacterSpace","initialProofState":"ð•œ : Type u_1\nA : Type u_2\ninstâœâ¶ : CommSemiring ð•œ\ninstâœâµ : TopologicalSpace ð•œ\ninstâœâ´ : ContinuousAdd ð•œ\ninstâœÂ³ : ContinuousConstSMul ð•œ ð•œ\ninstâœÂ² : NonUnitalNonAssocSemiring A\ninstâœÂ¹ : TopologicalSpace A\ninstâœ : Module ð•œ A\nÏ† Ïˆ : â†‘(WeakDual.characterSpace ð•œ A)\nh : âˆ€ (x : A), Eq (Ï† x) (Ïˆ x)\nâŠ¢ Eq Ï† Ïˆ","decl":"@[ext]\ntheorem ext {Ï† Ïˆ : characterSpace ð•œ A} (h : âˆ€ x, Ï† x = Ïˆ x) : Ï† = Ïˆ :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"WeakDual.CharacterSpace.coe_toCLM","module":"Mathlib.Topology.Algebra.Module.CharacterSpace","initialProofState":"ð•œ : Type u_1\nA : Type u_2\ninstâœâ¶ : CommSemiring ð•œ\ninstâœâµ : TopologicalSpace ð•œ\ninstâœâ´ : ContinuousAdd ð•œ\ninstâœÂ³ : ContinuousConstSMul ð•œ ð•œ\ninstâœÂ² : NonUnitalNonAssocSemiring A\ninstâœÂ¹ : TopologicalSpace A\ninstâœ : Module ð•œ A\nÏ† : â†‘(WeakDual.characterSpace ð•œ A)\nâŠ¢ Eq â‡‘(WeakDual.CharacterSpace.toCLM Ï†) â‡‘Ï†","decl":"@[simp]\ntheorem coe_toCLM (Ï† : characterSpace ð•œ A) : â‡‘(toCLM Ï†) = Ï† :=\n  rfl\n\n"}
{"name":"WeakDual.CharacterSpace.instNonUnitalAlgHomClass","module":"Mathlib.Topology.Algebra.Module.CharacterSpace","initialProofState":"ð•œ : Type u_1\nA : Type u_2\ninstâœâ¶ : CommSemiring ð•œ\ninstâœâµ : TopologicalSpace ð•œ\ninstâœâ´ : ContinuousAdd ð•œ\ninstâœÂ³ : ContinuousConstSMul ð•œ ð•œ\ninstâœÂ² : NonUnitalNonAssocSemiring A\ninstâœÂ¹ : TopologicalSpace A\ninstâœ : Module ð•œ A\nâŠ¢ NonUnitalAlgHomClass (â†‘(WeakDual.characterSpace ð•œ A)) ð•œ A ð•œ","decl":"/-- Elements of the character space are non-unital algebra homomorphisms. -/\ninstance instNonUnitalAlgHomClass : NonUnitalAlgHomClass (characterSpace ð•œ A) ð•œ A ð•œ :=\n  { CharacterSpace.instContinuousLinearMapClass with\n    map_smulâ‚›â‚— := fun Ï† => map_smul Ï†\n    map_zero := fun Ï† => map_zero Ï†\n    map_mul := fun Ï† => Ï†.prop.2 }\n\n"}
{"name":"WeakDual.CharacterSpace.coe_toNonUnitalAlgHom","module":"Mathlib.Topology.Algebra.Module.CharacterSpace","initialProofState":"ð•œ : Type u_1\nA : Type u_2\ninstâœâ¶ : CommSemiring ð•œ\ninstâœâµ : TopologicalSpace ð•œ\ninstâœâ´ : ContinuousAdd ð•œ\ninstâœÂ³ : ContinuousConstSMul ð•œ ð•œ\ninstâœÂ² : NonUnitalNonAssocSemiring A\ninstâœÂ¹ : TopologicalSpace A\ninstâœ : Module ð•œ A\nÏ† : â†‘(WeakDual.characterSpace ð•œ A)\nâŠ¢ Eq â‡‘(WeakDual.CharacterSpace.toNonUnitalAlgHom Ï†) â‡‘Ï†","decl":"@[simp]\ntheorem coe_toNonUnitalAlgHom (Ï† : characterSpace ð•œ A) : â‡‘(toNonUnitalAlgHom Ï†) = Ï† :=\n  rfl\n\n"}
{"name":"WeakDual.CharacterSpace.instIsEmpty","module":"Mathlib.Topology.Algebra.Module.CharacterSpace","initialProofState":"ð•œ : Type u_1\nA : Type u_2\ninstâœâ· : CommSemiring ð•œ\ninstâœâ¶ : TopologicalSpace ð•œ\ninstâœâµ : ContinuousAdd ð•œ\ninstâœâ´ : ContinuousConstSMul ð•œ ð•œ\ninstâœÂ³ : NonUnitalNonAssocSemiring A\ninstâœÂ² : TopologicalSpace A\ninstâœÂ¹ : Module ð•œ A\ninstâœ : Subsingleton A\nâŠ¢ IsEmpty â†‘(WeakDual.characterSpace ð•œ A)","decl":"instance instIsEmpty [Subsingleton A] : IsEmpty (characterSpace ð•œ A) :=\n  âŸ¨fun Ï† => Ï†.prop.1 <|\n    ContinuousLinearMap.ext fun x => by\n      rw [show x = 0 from Subsingleton.elim x 0, map_zero, map_zero] âŸ©\n\n"}
{"name":"WeakDual.CharacterSpace.union_zero","module":"Mathlib.Topology.Algebra.Module.CharacterSpace","initialProofState":"ð•œ : Type u_1\nA : Type u_2\ninstâœâ¶ : CommSemiring ð•œ\ninstâœâµ : TopologicalSpace ð•œ\ninstâœâ´ : ContinuousAdd ð•œ\ninstâœÂ³ : ContinuousConstSMul ð•œ ð•œ\ninstâœÂ² : NonUnitalNonAssocSemiring A\ninstâœÂ¹ : TopologicalSpace A\ninstâœ : Module ð•œ A\nâŠ¢ Eq (Union.union (WeakDual.characterSpace ð•œ A) (Singleton.singleton 0)) (setOf fun Ï† => âˆ€ (x y : A), Eq (Ï† (HMul.hMul x y)) (HMul.hMul (Ï† x) (Ï† y)))","decl":"theorem union_zero :\n    characterSpace ð•œ A âˆª {0} = {Ï† : WeakDual ð•œ A | âˆ€ x y : A, Ï† (x * y) = Ï† x * Ï† y} :=\n  le_antisymm (by\n      rintro Ï† (hÏ† | rfl)\n      Â· exact hÏ†.2\n      Â· exact fun _ _ => by exact (zero_mul (0 : ð•œ)).symm)\n    fun Ï† hÏ† => Or.elim (em <| Ï† = 0) Or.inr fun hâ‚€ => Or.inl âŸ¨hâ‚€, hÏ†âŸ©\n\n"}
{"name":"WeakDual.CharacterSpace.union_zero_isClosed","module":"Mathlib.Topology.Algebra.Module.CharacterSpace","initialProofState":"ð•œ : Type u_1\nA : Type u_2\ninstâœâ¸ : CommSemiring ð•œ\ninstâœâ· : TopologicalSpace ð•œ\ninstâœâ¶ : ContinuousAdd ð•œ\ninstâœâµ : ContinuousConstSMul ð•œ ð•œ\ninstâœâ´ : NonUnitalNonAssocSemiring A\ninstâœÂ³ : TopologicalSpace A\ninstâœÂ² : Module ð•œ A\ninstâœÂ¹ : T2Space ð•œ\ninstâœ : ContinuousMul ð•œ\nâŠ¢ IsClosed (Union.union (WeakDual.characterSpace ð•œ A) (Singleton.singleton 0))","decl":"/-- The `characterSpace ð•œ A` along with `0` is always a closed set in `WeakDual ð•œ A`. -/\ntheorem union_zero_isClosed [T2Space ð•œ] [ContinuousMul ð•œ] :\n    IsClosed (characterSpace ð•œ A âˆª {0}) := by\n  simp only [union_zero, Set.setOf_forall]\n  exact\n    isClosed_iInter fun x =>\n      isClosed_iInter fun y =>\n        isClosed_eq (eval_continuous _) <| (eval_continuous _).mul (eval_continuous _)\n\n"}
{"name":"WeakDual.CharacterSpace.instAlgHomClass","module":"Mathlib.Topology.Algebra.Module.CharacterSpace","initialProofState":"ð•œ : Type u_1\nA : Type u_2\ninstâœâ¶ : CommRing ð•œ\ninstâœâµ : TopologicalSpace ð•œ\ninstâœâ´ : ContinuousAdd ð•œ\ninstâœÂ³ : ContinuousConstSMul ð•œ ð•œ\ninstâœÂ² : TopologicalSpace A\ninstâœÂ¹ : Semiring A\ninstâœ : Algebra ð•œ A\nâŠ¢ AlgHomClass (â†‘(WeakDual.characterSpace ð•œ A)) ð•œ A ð•œ","decl":"/-- In a unital algebra, elements of the character space are algebra homomorphisms. -/\ninstance instAlgHomClass : AlgHomClass (characterSpace ð•œ A) ð•œ A ð•œ :=\n  haveI map_one' : âˆ€ Ï† : characterSpace ð•œ A, Ï† 1 = 1 := fun Ï† => by\n    have hâ‚ : Ï† 1 * (1 - Ï† 1) = 0 := by rw [mul_sub, sub_eq_zero, mul_one, â† map_mul Ï†, one_mul]\n    rcases mul_eq_zero.mp hâ‚ with (hâ‚‚ | hâ‚‚)\n    Â· have : âˆ€ a, Ï† (a * 1) = 0 := fun a => by simp only [map_mul Ï†, hâ‚‚, mul_zero]\n      exact False.elim (Ï†.prop.1 <| ContinuousLinearMap.ext <| by simpa only [mul_one] using this)\n    Â· exact (sub_eq_zero.mp hâ‚‚).symm\n  { CharacterSpace.instNonUnitalAlgHomClass with\n    map_one := map_one'\n    commutes := fun Ï† r => by\n      rw [Algebra.algebraMap_eq_smul_one, Algebra.id.map_eq_id, RingHom.id_apply]\n      rw [map_smul, Algebra.id.smul_eq_mul, map_one' Ï†, mul_one] }\n\n"}
{"name":"WeakDual.CharacterSpace.toAlgHom_apply","module":"Mathlib.Topology.Algebra.Module.CharacterSpace","initialProofState":"ð•œ : Type u_1\nA : Type u_2\ninstâœâ¶ : CommRing ð•œ\ninstâœâµ : TopologicalSpace ð•œ\ninstâœâ´ : ContinuousAdd ð•œ\ninstâœÂ³ : ContinuousConstSMul ð•œ ð•œ\ninstâœÂ² : TopologicalSpace A\ninstâœÂ¹ : Semiring A\ninstâœ : Algebra ð•œ A\nÏ† : â†‘(WeakDual.characterSpace ð•œ A)\naâœ : A\nâŠ¢ Eq ((WeakDual.CharacterSpace.toAlgHom Ï†) aâœ) ((WeakDual.CharacterSpace.toNonUnitalAlgHom Ï†).toFun aâœ)","decl":"/-- An element of the character space of a unital algebra, as an algebra homomorphism. -/\n@[simps]\ndef toAlgHom (Ï† : characterSpace ð•œ A) : A â†’â‚[ð•œ] ð•œ :=\n  { toNonUnitalAlgHom Ï† with\n    map_one' := map_one Ï†\n    commutes' := AlgHomClass.commutes Ï† }\n\n"}
{"name":"WeakDual.CharacterSpace.eq_set_map_one_map_mul","module":"Mathlib.Topology.Algebra.Module.CharacterSpace","initialProofState":"ð•œ : Type u_1\nA : Type u_2\ninstâœâ¸ : CommRing ð•œ\ninstâœâ· : NoZeroDivisors ð•œ\ninstâœâ¶ : TopologicalSpace ð•œ\ninstâœâµ : ContinuousAdd ð•œ\ninstâœâ´ : ContinuousConstSMul ð•œ ð•œ\ninstâœÂ³ : TopologicalSpace A\ninstâœÂ² : Semiring A\ninstâœÂ¹ : Algebra ð•œ A\ninstâœ : Nontrivial ð•œ\nâŠ¢ Eq (WeakDual.characterSpace ð•œ A) (setOf fun Ï† => And (Eq (Ï† 1) 1) (âˆ€ (x y : A), Eq (Ï† (HMul.hMul x y)) (HMul.hMul (Ï† x) (Ï† y))))","decl":"theorem eq_set_map_one_map_mul [Nontrivial ð•œ] :\n    characterSpace ð•œ A = {Ï† : WeakDual ð•œ A | Ï† 1 = 1 âˆ§ âˆ€ x y : A, Ï† (x * y) = Ï† x * Ï† y} := by\n  ext Ï†\n  refine âŸ¨?_, ?_âŸ©\n  Â· rintro hÏ†\n    lift Ï† to characterSpace ð•œ A using hÏ†\n    exact âŸ¨map_one Ï†, map_mul Ï†âŸ©\n  Â· rintro âŸ¨hÏ†â‚, hÏ†â‚‚âŸ©\n    refine âŸ¨?_, hÏ†â‚‚âŸ©\n    rintro rfl\n    exact zero_ne_one hÏ†â‚\n\n"}
{"name":"WeakDual.CharacterSpace.isClosed","module":"Mathlib.Topology.Algebra.Module.CharacterSpace","initialProofState":"ð•œ : Type u_1\nA : Type u_2\ninstâœÂ¹â° : CommRing ð•œ\ninstâœâ¹ : NoZeroDivisors ð•œ\ninstâœâ¸ : TopologicalSpace ð•œ\ninstâœâ· : ContinuousAdd ð•œ\ninstâœâ¶ : ContinuousConstSMul ð•œ ð•œ\ninstâœâµ : TopologicalSpace A\ninstâœâ´ : Semiring A\ninstâœÂ³ : Algebra ð•œ A\ninstâœÂ² : Nontrivial ð•œ\ninstâœÂ¹ : T2Space ð•œ\ninstâœ : ContinuousMul ð•œ\nâŠ¢ IsClosed (WeakDual.characterSpace ð•œ A)","decl":"/-- under suitable mild assumptions on `ð•œ`, the character space is a closed set in\n`WeakDual ð•œ A`. -/\nprotected theorem isClosed [Nontrivial ð•œ] [T2Space ð•œ] [ContinuousMul ð•œ] :\n    IsClosed (characterSpace ð•œ A) := by\n  rw [eq_set_map_one_map_mul, Set.setOf_and]\n  refine IsClosed.inter (isClosed_eq (eval_continuous _) continuous_const) ?_\n  simpa only [(union_zero ð•œ A).symm] using union_zero_isClosed _ _\n\n"}
{"name":"WeakDual.CharacterSpace.apply_mem_spectrum","module":"Mathlib.Topology.Algebra.Module.CharacterSpace","initialProofState":"ð•œ : Type u_1\nA : Type u_2\ninstâœâ¸ : CommRing ð•œ\ninstâœâ· : NoZeroDivisors ð•œ\ninstâœâ¶ : TopologicalSpace ð•œ\ninstâœâµ : ContinuousAdd ð•œ\ninstâœâ´ : ContinuousConstSMul ð•œ ð•œ\ninstâœÂ³ : TopologicalSpace A\ninstâœÂ² : Ring A\ninstâœÂ¹ : Algebra ð•œ A\ninstâœ : Nontrivial ð•œ\nÏ† : â†‘(WeakDual.characterSpace ð•œ A)\na : A\nâŠ¢ Membership.mem (spectrum ð•œ a) (Ï† a)","decl":"theorem apply_mem_spectrum [Nontrivial ð•œ] (Ï† : characterSpace ð•œ A) (a : A) : Ï† a âˆˆ spectrum ð•œ a :=\n  AlgHom.apply_mem_spectrum Ï† a\n\n"}
{"name":"WeakDual.CharacterSpace.ext_ker","module":"Mathlib.Topology.Algebra.Module.CharacterSpace","initialProofState":"ð•œ : Type u_1\nA : Type u_2\ninstâœâ· : CommRing ð•œ\ninstâœâ¶ : NoZeroDivisors ð•œ\ninstâœâµ : TopologicalSpace ð•œ\ninstâœâ´ : ContinuousAdd ð•œ\ninstâœÂ³ : ContinuousConstSMul ð•œ ð•œ\ninstâœÂ² : TopologicalSpace A\ninstâœÂ¹ : Ring A\ninstâœ : Algebra ð•œ A\nÏ† Ïˆ : â†‘(WeakDual.characterSpace ð•œ A)\nh : Eq (RingHom.ker Ï†) (RingHom.ker Ïˆ)\nâŠ¢ Eq Ï† Ïˆ","decl":"theorem ext_ker {Ï† Ïˆ : characterSpace ð•œ A} (h : RingHom.ker Ï† = RingHom.ker Ïˆ) : Ï† = Ïˆ := by\n  ext x\n  have : x - algebraMap ð•œ A (Ïˆ x) âˆˆ RingHom.ker Ï† := by\n    simpa only [h, RingHom.mem_ker, map_sub, AlgHomClass.commutes] using sub_self (Ïˆ x)\n  rwa [RingHom.mem_ker, map_sub, AlgHomClass.commutes, sub_eq_zero] at this\n\n"}
{"name":"WeakDual.ker_isMaximal","module":"Mathlib.Topology.Algebra.Module.CharacterSpace","initialProofState":"ð•œ : Type u_1\nA : Type u_2\ninstâœâ¶ : Field ð•œ\ninstâœâµ : TopologicalSpace ð•œ\ninstâœâ´ : ContinuousAdd ð•œ\ninstâœÂ³ : ContinuousConstSMul ð•œ ð•œ\ninstâœÂ² : Ring A\ninstâœÂ¹ : TopologicalSpace A\ninstâœ : Algebra ð•œ A\nÏ† : â†‘(WeakDual.characterSpace ð•œ A)\nâŠ¢ (RingHom.ker Ï†).IsMaximal","decl":"/-- The `RingHom.ker` of `Ï† : characterSpace ð•œ A` is maximal. -/\ninstance ker_isMaximal (Ï† : characterSpace ð•œ A) : (RingHom.ker Ï†).IsMaximal :=\n  RingHom.ker_isMaximal_of_surjective Ï† fun z =>\n    âŸ¨algebraMap ð•œ A z, by simp only [AlgHomClass.commutes, Algebra.id.map_eq_id, RingHom.id_apply]âŸ©\n\n"}
{"name":"WeakDual.gelfandTransform_apply_apply","module":"Mathlib.Topology.Algebra.Module.CharacterSpace","initialProofState":"ð•œ : Type u_1\nA : Type u_2\ninstâœâµ : CommRing ð•œ\ninstâœâ´ : TopologicalSpace ð•œ\ninstâœÂ³ : TopologicalRing ð•œ\ninstâœÂ² : TopologicalSpace A\ninstâœÂ¹ : Semiring A\ninstâœ : Algebra ð•œ A\na : A\nÏ† : â†‘(WeakDual.characterSpace ð•œ A)\nâŠ¢ Eq (((WeakDual.gelfandTransform ð•œ A) a) Ï†) (Ï† a)","decl":"/-- The **Gelfand transform** is an algebra homomorphism (over `ð•œ`) from a topological `ð•œ`-algebra\n`A` into the `ð•œ`-algebra of continuous `ð•œ`-valued functions on the `characterSpace ð•œ A`.\nThe character space itself consists of all algebra homomorphisms from `A` to `ð•œ`. -/\n@[simps]\ndef gelfandTransform : A â†’â‚[ð•œ] C(characterSpace ð•œ A, ð•œ) where\n  toFun a :=\n    { toFun := fun Ï† => Ï† a\n      continuous_toFun := (eval_continuous a).comp continuous_induced_dom }\n  map_one' := by ext a; simp only [coe_mk, coe_one, Pi.one_apply, map_one a]\n  map_mul' a b := by ext; simp only [map_mul, coe_mk, coe_mul, Pi.mul_apply]\n  map_zero' := by ext; simp only [map_zero, coe_mk, coe_mul, coe_zero, Pi.zero_apply]\n  map_add' a b := by ext; simp only [map_add, coe_mk, coe_add, Pi.add_apply]\n  commutes' k := by ext; simp [AlgHomClass.commutes]\n\n"}
