{"name":"CategoryTheory.HasShift.Induced.zero_hom_app_obj","module":"Mathlib.CategoryTheory.Shift.Induced","initialProofState":"C : Type u_5\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_5} C\ninst✝⁴ : CategoryTheory.Category.{u_1, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ns : A → CategoryTheory.Functor D D\ni : (a : A) → CategoryTheory.Iso (F.comp (s a)) ((CategoryTheory.shiftFunctor C a).comp F)\ninst✝¹ : ((CategoryTheory.whiskeringLeft C D D).obj F).Full\ninst✝ : ((CategoryTheory.whiskeringLeft C D D).obj F).Faithful\nX : C\n⊢ Eq ((CategoryTheory.HasShift.Induced.zero F s i).hom.app (F.obj X)) (CategoryTheory.CategoryStruct.comp ((i 0).hom.app X) (F.map ((CategoryTheory.shiftFunctorZero C A).hom.app X)))","decl":"@[simp]\nlemma zero_hom_app_obj (X : C) :\n    (zero F s i).hom.app (F.obj X) =\n      (i 0).hom.app X ≫ F.map ((shiftFunctorZero C A).hom.app X) := by\n  have h : whiskerLeft F (zero F s i).hom = _ :=\n    ((whiskeringLeft C D D).obj F).map_preimage _\n  exact (NatTrans.congr_app h X).trans (by simp)\n\n"}
{"name":"CategoryTheory.HasShift.Induced.zero_inv_app_obj","module":"Mathlib.CategoryTheory.Shift.Induced","initialProofState":"C : Type u_4\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_4} C\ninst✝⁴ : CategoryTheory.Category.{u_1, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_5\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ns : A → CategoryTheory.Functor D D\ni : (a : A) → CategoryTheory.Iso (F.comp (s a)) ((CategoryTheory.shiftFunctor C a).comp F)\ninst✝¹ : ((CategoryTheory.whiskeringLeft C D D).obj F).Full\ninst✝ : ((CategoryTheory.whiskeringLeft C D D).obj F).Faithful\nX : C\n⊢ Eq ((CategoryTheory.HasShift.Induced.zero F s i).inv.app (F.obj X)) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorZero C A).inv.app X)) ((i 0).inv.app X))","decl":"@[simp]\nlemma zero_inv_app_obj (X : C) :\n    (zero F s i).inv.app (F.obj X) =\n      F.map ((shiftFunctorZero C A).inv.app X) ≫ (i 0).inv.app X := by\n  have h : whiskerLeft F (zero F s i).inv = _ :=\n    ((whiskeringLeft C D D).obj F).map_preimage _\n  exact (NatTrans.congr_app h X).trans (by simp)\n\n"}
{"name":"CategoryTheory.HasShift.Induced.add_hom_app_obj","module":"Mathlib.CategoryTheory.Shift.Induced","initialProofState":"C : Type u_5\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_5} C\ninst✝⁴ : CategoryTheory.Category.{u_1, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ns : A → CategoryTheory.Functor D D\ni : (a : A) → CategoryTheory.Iso (F.comp (s a)) ((CategoryTheory.shiftFunctor C a).comp F)\ninst✝¹ : ((CategoryTheory.whiskeringLeft C D D).obj F).Full\ninst✝ : ((CategoryTheory.whiskeringLeft C D D).obj F).Faithful\na b : A\nX : C\n⊢ Eq ((CategoryTheory.HasShift.Induced.add F s i a b).hom.app (F.obj X)) (CategoryTheory.CategoryStruct.comp ((i (HAdd.hAdd a b)).hom.app X) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorAdd C a b).hom.app X)) (CategoryTheory.CategoryStruct.comp ((i b).inv.app ((CategoryTheory.shiftFunctor C a).obj X)) ((s b).map ((i a).inv.app X)))))","decl":"@[simp]\nlemma add_hom_app_obj (a b : A) (X : C) :\n    (add F s i a b).hom.app (F.obj X) =\n      (i (a + b)).hom.app X ≫ F.map ((shiftFunctorAdd C a b).hom.app X) ≫\n        (i b).inv.app ((shiftFunctor C a).obj X) ≫ (s b).map ((i a).inv.app X) := by\n  have h : whiskerLeft F (add F s i a b).hom = _ :=\n    ((whiskeringLeft C D D).obj F).map_preimage _\n  exact (NatTrans.congr_app h X).trans (by simp)\n\n"}
{"name":"CategoryTheory.HasShift.Induced.add_inv_app_obj","module":"Mathlib.CategoryTheory.Shift.Induced","initialProofState":"C : Type u_4\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_4} C\ninst✝⁴ : CategoryTheory.Category.{u_1, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_5\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ns : A → CategoryTheory.Functor D D\ni : (a : A) → CategoryTheory.Iso (F.comp (s a)) ((CategoryTheory.shiftFunctor C a).comp F)\ninst✝¹ : ((CategoryTheory.whiskeringLeft C D D).obj F).Full\ninst✝ : ((CategoryTheory.whiskeringLeft C D D).obj F).Faithful\na b : A\nX : C\n⊢ Eq ((CategoryTheory.HasShift.Induced.add F s i a b).inv.app (F.obj X)) (CategoryTheory.CategoryStruct.comp ((s b).map ((i a).hom.app X)) (CategoryTheory.CategoryStruct.comp ((i b).hom.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorAdd C a b).inv.app X)) ((i (HAdd.hAdd a b)).inv.app X))))","decl":"@[simp]\nlemma add_inv_app_obj (a b : A) (X : C) :\n    (add F s i a b).inv.app (F.obj X) =\n      (s b).map ((i a).hom.app X) ≫ (i b).hom.app ((shiftFunctor C a).obj X) ≫\n        F.map ((shiftFunctorAdd C a b).inv.app X) ≫ (i (a + b)).inv.app X := by\n  have h : whiskerLeft F (add F s i a b).inv = _ :=\n    ((whiskeringLeft C D D).obj F).map_preimage _\n  exact (NatTrans.congr_app h X).trans (by simp)\n\n"}
{"name":"CategoryTheory.shiftFunctor_of_induced","module":"Mathlib.CategoryTheory.Shift.Induced","initialProofState":"C : Type u_4\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_5, u_4} C\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\nF : CategoryTheory.Functor C D\nA : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ns : A → CategoryTheory.Functor D D\ni : (a : A) → CategoryTheory.Iso (F.comp (s a)) ((CategoryTheory.shiftFunctor C a).comp F)\ninst✝¹ : ((CategoryTheory.whiskeringLeft C D D).obj F).Full\ninst✝ : ((CategoryTheory.whiskeringLeft C D D).obj F).Faithful\na : A\n⊢ Eq (CategoryTheory.shiftFunctor D a) (s a)","decl":"lemma shiftFunctor_of_induced (a : A) :\n    letI := HasShift.induced F A s i\n    shiftFunctor D a = s a := by\n  rfl\n\n"}
{"name":"CategoryTheory.shiftFunctorZero_hom_app_obj_of_induced","module":"Mathlib.CategoryTheory.Shift.Induced","initialProofState":"C : Type u_4\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_4} C\ninst✝⁴ : CategoryTheory.Category.{u_1, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ns : A → CategoryTheory.Functor D D\ni : (a : A) → CategoryTheory.Iso (F.comp (s a)) ((CategoryTheory.shiftFunctor C a).comp F)\ninst✝¹ : ((CategoryTheory.whiskeringLeft C D D).obj F).Full\ninst✝ : ((CategoryTheory.whiskeringLeft C D D).obj F).Faithful\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctorZero D A).hom.app (F.obj X)) (CategoryTheory.CategoryStruct.comp ((i 0).hom.app X) (F.map ((CategoryTheory.shiftFunctorZero C A).hom.app X)))","decl":"@[simp]\nlemma shiftFunctorZero_hom_app_obj_of_induced (X : C) :\n    letI := HasShift.induced F A s i\n    (shiftFunctorZero D A).hom.app (F.obj X) =\n      (i 0).hom.app X ≫ F.map ((shiftFunctorZero C A).hom.app X) := by\n  letI := HasShift.induced F A s i\n  simp only [ShiftMkCore.shiftFunctorZero_eq, HasShift.Induced.zero_hom_app_obj]\n\n"}
{"name":"CategoryTheory.shiftFunctorZero_inv_app_obj_of_induced","module":"Mathlib.CategoryTheory.Shift.Induced","initialProofState":"C : Type u_4\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_4} C\ninst✝⁴ : CategoryTheory.Category.{u_1, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_5\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ns : A → CategoryTheory.Functor D D\ni : (a : A) → CategoryTheory.Iso (F.comp (s a)) ((CategoryTheory.shiftFunctor C a).comp F)\ninst✝¹ : ((CategoryTheory.whiskeringLeft C D D).obj F).Full\ninst✝ : ((CategoryTheory.whiskeringLeft C D D).obj F).Faithful\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctorZero D A).inv.app (F.obj X)) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorZero C A).inv.app X)) ((i 0).inv.app X))","decl":"@[simp]\nlemma shiftFunctorZero_inv_app_obj_of_induced (X : C) :\n    letI := HasShift.induced F A s i\n    (shiftFunctorZero D A).inv.app (F.obj X) =\n      F.map ((shiftFunctorZero C A).inv.app X) ≫ (i 0).inv.app X := by\n  letI := HasShift.induced F A s i\n  simp only [ShiftMkCore.shiftFunctorZero_eq, HasShift.Induced.zero_inv_app_obj]\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd_hom_app_obj_of_induced","module":"Mathlib.CategoryTheory.Shift.Induced","initialProofState":"C : Type u_4\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_4} C\ninst✝⁴ : CategoryTheory.Category.{u_1, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ns : A → CategoryTheory.Functor D D\ni : (a : A) → CategoryTheory.Iso (F.comp (s a)) ((CategoryTheory.shiftFunctor C a).comp F)\ninst✝¹ : ((CategoryTheory.whiskeringLeft C D D).obj F).Full\ninst✝ : ((CategoryTheory.whiskeringLeft C D D).obj F).Faithful\na b : A\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctorAdd D a b).hom.app (F.obj X)) (CategoryTheory.CategoryStruct.comp ((i (HAdd.hAdd a b)).hom.app X) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorAdd C a b).hom.app X)) (CategoryTheory.CategoryStruct.comp ((i b).inv.app ((CategoryTheory.shiftFunctor C a).obj X)) ((s b).map ((i a).inv.app X)))))","decl":"@[simp]\nlemma shiftFunctorAdd_hom_app_obj_of_induced (a b : A) (X : C) :\n    letI := HasShift.induced F A s i\n    (shiftFunctorAdd D a b).hom.app (F.obj X) =\n      (i (a + b)).hom.app X ≫\n        F.map ((shiftFunctorAdd C a b).hom.app X) ≫\n        (i b).inv.app ((shiftFunctor C a).obj X) ≫\n        (s b).map ((i a).inv.app X) := by\n  letI := HasShift.induced F A s i\n  simp only [ShiftMkCore.shiftFunctorAdd_eq, HasShift.Induced.add_hom_app_obj]\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd_inv_app_obj_of_induced","module":"Mathlib.CategoryTheory.Shift.Induced","initialProofState":"C : Type u_4\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_4} C\ninst✝⁴ : CategoryTheory.Category.{u_1, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ns : A → CategoryTheory.Functor D D\ni : (a : A) → CategoryTheory.Iso (F.comp (s a)) ((CategoryTheory.shiftFunctor C a).comp F)\ninst✝¹ : ((CategoryTheory.whiskeringLeft C D D).obj F).Full\ninst✝ : ((CategoryTheory.whiskeringLeft C D D).obj F).Faithful\na b : A\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctorAdd D a b).inv.app (F.obj X)) (CategoryTheory.CategoryStruct.comp ((s b).map ((i a).hom.app X)) (CategoryTheory.CategoryStruct.comp ((i b).hom.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorAdd C a b).inv.app X)) ((i (HAdd.hAdd a b)).inv.app X))))","decl":"@[simp]\nlemma shiftFunctorAdd_inv_app_obj_of_induced (a b : A) (X : C) :\n    letI := HasShift.induced F A s i\n    (shiftFunctorAdd D a b).inv.app (F.obj X) =\n      (s b).map ((i a).hom.app X) ≫\n      (i b).hom.app ((shiftFunctor C a).obj X) ≫\n      F.map ((shiftFunctorAdd C a b).inv.app X) ≫\n      (i (a + b)).inv.app X := by\n  letI := HasShift.induced F A s i\n  simp only [ShiftMkCore.shiftFunctorAdd_eq, HasShift.Induced.add_inv_app_obj]\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_eq_ofInduced","module":"Mathlib.CategoryTheory.Shift.Induced","initialProofState":"C : Type u_1\nD : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_2, u_3} D\nF : CategoryTheory.Functor C D\nA : Type u_5\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ns : A → CategoryTheory.Functor D D\ni : (a : A) → CategoryTheory.Iso (F.comp (s a)) ((CategoryTheory.shiftFunctor C a).comp F)\ninst✝¹ : ((CategoryTheory.whiskeringLeft C D D).obj F).Full\ninst✝ : ((CategoryTheory.whiskeringLeft C D D).obj F).Faithful\na : A\n⊢ Eq (F.commShiftIso a) (i a).symm","decl":"lemma Functor.commShiftIso_eq_ofInduced (a : A) :\n    letI := HasShift.induced F A s i\n    letI := Functor.CommShift.ofInduced F A s i\n    F.commShiftIso a = (i a).symm := rfl\n\n"}
