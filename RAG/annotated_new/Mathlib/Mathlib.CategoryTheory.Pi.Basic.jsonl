{"name":"CategoryTheory.Pi.id_apply","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nX : (i : I) â†’ C i\ni : I\nâŠ¢ Eq (CategoryTheory.CategoryStruct.id X i) (CategoryTheory.CategoryStruct.id (X i))","decl":"@[simp]\ntheorem id_apply (X : âˆ€ i, C i) (i) : (ðŸ™ X : âˆ€ i, X i âŸ¶ X i) i = ðŸ™ (X i) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Pi.comp_apply","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nX Y Z : (i : I) â†’ C i\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ni : I\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f g i) (CategoryTheory.CategoryStruct.comp (f i) (g i))","decl":"@[simp]\ntheorem comp_apply {X Y Z : âˆ€ i, C i} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) (i) :\n    (f â‰« g : âˆ€ i, X i âŸ¶ Z i) i = f i â‰« g i :=\n  rfl\n\n"}
{"name":"CategoryTheory.Pi.ext_iff","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nX Y : (i : I) â†’ C i\nf g : Quiver.Hom X Y\nâŠ¢ Iff (Eq f g) (âˆ€ (i : I), Eq (f i) (g i))","decl":"@[ext]\nlemma ext {X Y : âˆ€ i, C i} {f g : X âŸ¶ Y} (w : âˆ€ i, f i = g i) : f = g :=\n  funext (w Â·)\n\n"}
{"name":"CategoryTheory.Pi.ext","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nX Y : (i : I) â†’ C i\nf g : Quiver.Hom X Y\nw : âˆ€ (i : I), Eq (f i) (g i)\nâŠ¢ Eq f g","decl":"@[ext]\nlemma ext {X Y : âˆ€ i, C i} {f g : X âŸ¶ Y} (w : âˆ€ i, f i = g i) : f = g :=\n  funext (w Â·)\n\n"}
{"name":"CategoryTheory.Pi.eval_map","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\ni : I\nXâœ Yâœ : (i : I) â†’ C i\nÎ± : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Pi.eval C i).map Î±) (Î± i)","decl":"/--\nThe evaluation functor at `i : I`, sending an `I`-indexed family of objects to the object over `i`.\n-/\n@[simps]\ndef eval (i : I) : (âˆ€ i, C i) â¥¤ C i where\n  obj f := f i\n  map Î± := Î± i\n\n"}
{"name":"CategoryTheory.Pi.eval_obj","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\ni : I\nf : (i : I) â†’ C i\nâŠ¢ Eq ((CategoryTheory.Pi.eval C i).obj f) (f i)","decl":"/--\nThe evaluation functor at `i : I`, sending an `I`-indexed family of objects to the object over `i`.\n-/\n@[simps]\ndef eval (i : I) : (âˆ€ i, C i) â¥¤ C i where\n  obj f := f i\n  map Î± := Î± i\n\n"}
{"name":"CategoryTheory.Pi.comap_map","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nJ : Type wâ‚\nh : J â†’ I\nXâœ Yâœ : (i : I) â†’ C i\nÎ± : Quiver.Hom Xâœ Yâœ\ni : J\nâŠ¢ Eq ((CategoryTheory.Pi.comap C h).map Î± i) (Î± (h i))","decl":"/-- Pull back an `I`-indexed family of objects to a `J`-indexed family, along a function `J â†’ I`.\n-/\n@[simps]\ndef comap (h : J â†’ I) : (âˆ€ i, C i) â¥¤ (âˆ€ j, C (h j)) where\n  obj f i := f (h i)\n  map Î± i := Î± (h i)\n\n"}
{"name":"CategoryTheory.Pi.comap_obj","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nJ : Type wâ‚\nh : J â†’ I\nf : (i : I) â†’ C i\ni : J\nâŠ¢ Eq ((CategoryTheory.Pi.comap C h).obj f i) (f (h i))","decl":"/-- Pull back an `I`-indexed family of objects to a `J`-indexed family, along a function `J â†’ I`.\n-/\n@[simps]\ndef comap (h : J â†’ I) : (âˆ€ i, C i) â¥¤ (âˆ€ j, C (h j)) where\n  obj f i := f (h i)\n  map Î± i := Î± (h i)\n\n"}
{"name":"CategoryTheory.Pi.comapId_hom_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nX : (i : I) â†’ C i\ni : I\nâŠ¢ Eq ((CategoryTheory.Pi.comapId I C).hom.app X i) (CategoryTheory.CategoryStruct.id X i)","decl":"/-- The natural isomorphism between\npulling back a grading along the identity function,\nand the identity functor. -/\n@[simps]\ndef comapId : comap C (id : I â†’ I) â‰… ðŸ­ (âˆ€ i, C i) where\n  hom := { app := fun X => ðŸ™ X }\n  inv := { app := fun X => ðŸ™ X }\n\n"}
{"name":"CategoryTheory.Pi.comapId_inv_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nX : (i : I) â†’ C i\ni : I\nâŠ¢ Eq ((CategoryTheory.Pi.comapId I C).inv.app X i) (CategoryTheory.CategoryStruct.id X i)","decl":"/-- The natural isomorphism between\npulling back a grading along the identity function,\nand the identity functor. -/\n@[simps]\ndef comapId : comap C (id : I â†’ I) â‰… ðŸ­ (âˆ€ i, C i) where\n  hom := { app := fun X => ðŸ™ X }\n  inv := { app := fun X => ðŸ™ X }\n\n"}
{"name":"CategoryTheory.Pi.comapComp_hom_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nJ : Type wâ‚\nK : Type wâ‚‚\nf : K â†’ J\ng : J â†’ I\nX : (i : I) â†’ C i\nb : K\nâŠ¢ Eq ((CategoryTheory.Pi.comapComp C f g).hom.app X b) (CategoryTheory.CategoryStruct.id (X (g (f b))))","decl":"/-- The natural isomorphism comparing between\npulling back along two successive functions, and\npulling back along their composition\n-/\n@[simps!]\ndef comapComp (f : K â†’ J) (g : J â†’ I) : comap C g â‹™ comap (C âˆ˜ g) f â‰… comap C (g âˆ˜ f) where\n  hom :=\n  { app := fun X b => ðŸ™ (X (g (f b)))\n    naturality := fun X Y f' => by simp only [comap, Function.comp]; funext; simp }\n  inv :=\n  { app := fun X b => ðŸ™ (X (g (f b)))\n    naturality := fun X Y f' => by simp only [comap, Function.comp]; funext; simp }\n\n"}
{"name":"CategoryTheory.Pi.comapComp_inv_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nJ : Type wâ‚\nK : Type wâ‚‚\nf : K â†’ J\ng : J â†’ I\nX : (i : I) â†’ C i\nb : K\nâŠ¢ Eq ((CategoryTheory.Pi.comapComp C f g).inv.app X b) (CategoryTheory.CategoryStruct.id (X (g (f b))))","decl":"/-- The natural isomorphism comparing between\npulling back along two successive functions, and\npulling back along their composition\n-/\n@[simps!]\ndef comapComp (f : K â†’ J) (g : J â†’ I) : comap C g â‹™ comap (C âˆ˜ g) f â‰… comap C (g âˆ˜ f) where\n  hom :=\n  { app := fun X b => ðŸ™ (X (g (f b)))\n    naturality := fun X Y f' => by simp only [comap, Function.comp]; funext; simp }\n  inv :=\n  { app := fun X b => ðŸ™ (X (g (f b)))\n    naturality := fun X Y f' => by simp only [comap, Function.comp]; funext; simp }\n\n"}
{"name":"CategoryTheory.Pi.comapEvalIsoEval_hom_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nJ : Type wâ‚\nh : J â†’ I\nj : J\nX : (i : I) â†’ C i\nâŠ¢ Eq ((CategoryTheory.Pi.comapEvalIsoEval C h j).hom.app X) (CategoryTheory.CategoryStruct.id (X (h j)))","decl":"/-- The natural isomorphism between pulling back then evaluating, and just evaluating. -/\n@[simps!]\ndef comapEvalIsoEval (h : J â†’ I) (j : J) : comap C h â‹™ eval (C âˆ˜ h) j â‰… eval C (h j) :=\n  NatIso.ofComponents (fun _ => Iso.refl _) (by simp only [Iso.refl]; simp)\n\n"}
{"name":"CategoryTheory.Pi.comapEvalIsoEval_inv_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nJ : Type wâ‚\nh : J â†’ I\nj : J\nX : (i : I) â†’ C i\nâŠ¢ Eq ((CategoryTheory.Pi.comapEvalIsoEval C h j).inv.app X) (CategoryTheory.CategoryStruct.id (X (h j)))","decl":"/-- The natural isomorphism between pulling back then evaluating, and just evaluating. -/\n@[simps!]\ndef comapEvalIsoEval (h : J â†’ I) (j : J) : comap C h â‹™ eval (C âˆ˜ h) j â‰… eval C (h j) :=\n  NatIso.ofComponents (fun _ => Iso.refl _) (by simp only [Iso.refl]; simp)\n\n"}
{"name":"CategoryTheory.Pi.sum_map_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nJ : Type wâ‚€\nD : J â†’ Type uâ‚\ninstâœ : (j : J) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (D j)\nX X' : (i : I) â†’ C i\nf : Quiver.Hom X X'\nY : (j : J) â†’ D j\ns : Sum I J\nâŠ¢ Eq (((CategoryTheory.Pi.sum C).map f).app Y s) (CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Quiver.Hom (((fun X => { obj := fun Y s => CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Sum.elim C D s) s (fun i => X i) fun j => Y j, map := fun {x x_1} f s => CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Quiver.Hom ((fun Y s => CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Sum.elim C D s) s (fun i => X i) fun j => Y j) x s) ((fun Y s => CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Sum.elim C D s) s (fun i => X i) fun j => Y j) x_1 s)) s (fun i => CategoryTheory.CategoryStruct.id (X i)) fun j => f j, map_id := â‹¯, map_comp := â‹¯ }) X).obj Y s) (((fun X => { obj := fun Y s => CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Sum.elim C D s) s (fun i => X i) fun j => Y j, map := fun {x x_1} f s => CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Quiver.Hom ((fun Y s => CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Sum.elim C D s) s (fun i => X i) fun j => Y j) x s) ((fun Y s => CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Sum.elim C D s) s (fun i => X i) fun j => Y j) x_1 s)) s (fun i => CategoryTheory.CategoryStruct.id (X i)) fun j => f j, map_id := â‹¯, map_comp := â‹¯ }) X').obj Y s)) s (fun i => f i) fun j => CategoryTheory.CategoryStruct.id (Y j))","decl":"/-- The bifunctor combining an `I`-indexed family of objects with a `J`-indexed family of objects\nto obtain an `I âŠ• J`-indexed family of objects.\n-/\n@[simps]\ndef sum : (âˆ€ i, C i) â¥¤ (âˆ€ j, D j) â¥¤ âˆ€ s : I âŠ• J, Sum.elim C D s where\n  obj X :=\n    { obj := fun Y s =>\n        match s with\n        | .inl i => X i\n        | .inr j => Y j\n      map := fun {_} {_} f s =>\n        match s with\n        | .inl i => ðŸ™ (X i)\n        | .inr j => f j }\n  map {X} {X'} f :=\n    { app := fun Y s =>\n        match s with\n        | .inl i => f i\n        | .inr j => ðŸ™ (Y j) }\n\n"}
{"name":"CategoryTheory.Pi.sum_obj_obj","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nJ : Type wâ‚€\nD : J â†’ Type uâ‚\ninstâœ : (j : J) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (D j)\nX : (i : I) â†’ C i\nY : (j : J) â†’ D j\ns : Sum I J\nâŠ¢ Eq (((CategoryTheory.Pi.sum C).obj X).obj Y s) (CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Sum.elim C D s) s (fun i => X i) fun j => Y j)","decl":"/-- The bifunctor combining an `I`-indexed family of objects with a `J`-indexed family of objects\nto obtain an `I âŠ• J`-indexed family of objects.\n-/\n@[simps]\ndef sum : (âˆ€ i, C i) â¥¤ (âˆ€ j, D j) â¥¤ âˆ€ s : I âŠ• J, Sum.elim C D s where\n  obj X :=\n    { obj := fun Y s =>\n        match s with\n        | .inl i => X i\n        | .inr j => Y j\n      map := fun {_} {_} f s =>\n        match s with\n        | .inl i => ðŸ™ (X i)\n        | .inr j => f j }\n  map {X} {X'} f :=\n    { app := fun Y s =>\n        match s with\n        | .inl i => f i\n        | .inr j => ðŸ™ (Y j) }\n\n"}
{"name":"CategoryTheory.Pi.sum_obj_map","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nJ : Type wâ‚€\nD : J â†’ Type uâ‚\ninstâœ : (j : J) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (D j)\nX : (i : I) â†’ C i\nxâœÂ¹ xâœ : (j : J) â†’ D j\nf : Quiver.Hom xâœÂ¹ xâœ\ns : Sum I J\nâŠ¢ Eq (((CategoryTheory.Pi.sum C).obj X).map f s) (CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Quiver.Hom ((fun Y s => CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Sum.elim C D s) s (fun i => X i) fun j => Y j) xâœÂ¹ s) ((fun Y s => CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Sum.elim C D s) s (fun i => X i) fun j => Y j) xâœ s)) s (fun i => CategoryTheory.CategoryStruct.id (X i)) fun j => f j)","decl":"/-- The bifunctor combining an `I`-indexed family of objects with a `J`-indexed family of objects\nto obtain an `I âŠ• J`-indexed family of objects.\n-/\n@[simps]\ndef sum : (âˆ€ i, C i) â¥¤ (âˆ€ j, D j) â¥¤ âˆ€ s : I âŠ• J, Sum.elim C D s where\n  obj X :=\n    { obj := fun Y s =>\n        match s with\n        | .inl i => X i\n        | .inr j => Y j\n      map := fun {_} {_} f s =>\n        match s with\n        | .inl i => ðŸ™ (X i)\n        | .inr j => f j }\n  map {X} {X'} f :=\n    { app := fun Y s =>\n        match s with\n        | .inl i => f i\n        | .inr j => ðŸ™ (Y j) }\n\n"}
{"name":"CategoryTheory.Pi.isoApp_inv","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nX Y : (i : I) â†’ C i\nf : CategoryTheory.Iso X Y\ni : I\nâŠ¢ Eq (CategoryTheory.Pi.isoApp f i).inv (f.inv i)","decl":"/-- An isomorphism between `I`-indexed objects gives an isomorphism between each\npair of corresponding components. -/\n@[simps]\ndef isoApp {X Y : âˆ€ i, C i} (f : X â‰… Y) (i : I) : X i â‰… Y i :=\n  âŸ¨f.hom i, f.inv i,\n    by rw [â† comp_apply, Iso.hom_inv_id, id_apply], by rw [â† comp_apply, Iso.inv_hom_id, id_apply]âŸ©\n\n"}
{"name":"CategoryTheory.Pi.isoApp_hom","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nX Y : (i : I) â†’ C i\nf : CategoryTheory.Iso X Y\ni : I\nâŠ¢ Eq (CategoryTheory.Pi.isoApp f i).hom (f.hom i)","decl":"/-- An isomorphism between `I`-indexed objects gives an isomorphism between each\npair of corresponding components. -/\n@[simps]\ndef isoApp {X Y : âˆ€ i, C i} (f : X â‰… Y) (i : I) : X i â‰… Y i :=\n  âŸ¨f.hom i, f.inv i,\n    by rw [â† comp_apply, Iso.hom_inv_id, id_apply], by rw [â† comp_apply, Iso.inv_hom_id, id_apply]âŸ©\n\n"}
{"name":"CategoryTheory.Pi.isoApp_refl","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nX : (i : I) â†’ C i\ni : I\nâŠ¢ Eq (CategoryTheory.Pi.isoApp (CategoryTheory.Iso.refl X) i) (CategoryTheory.Iso.refl (X i))","decl":"@[simp]\ntheorem isoApp_refl (X : âˆ€ i, C i) (i : I) : isoApp (Iso.refl X) i = Iso.refl (X i) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Pi.isoApp_symm","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nX Y : (i : I) â†’ C i\nf : CategoryTheory.Iso X Y\ni : I\nâŠ¢ Eq (CategoryTheory.Pi.isoApp f.symm i) (CategoryTheory.Pi.isoApp f i).symm","decl":"@[simp]\ntheorem isoApp_symm {X Y : âˆ€ i, C i} (f : X â‰… Y) (i : I) : isoApp f.symm i = (isoApp f i).symm :=\n  rfl\n\n"}
{"name":"CategoryTheory.Pi.isoApp_trans","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nX Y Z : (i : I) â†’ C i\nf : CategoryTheory.Iso X Y\ng : CategoryTheory.Iso Y Z\ni : I\nâŠ¢ Eq (CategoryTheory.Pi.isoApp (f.trans g) i) ((CategoryTheory.Pi.isoApp f i).trans (CategoryTheory.Pi.isoApp g i))","decl":"@[simp]\ntheorem isoApp_trans {X Y Z : âˆ€ i, C i} (f : X â‰… Y) (g : Y â‰… Z) (i : I) :\n    isoApp (f â‰ªâ‰« g) i = isoApp f i â‰ªâ‰« isoApp g i :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.pi_obj","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nD : I â†’ Type uâ‚‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚‚, uâ‚‚} (D i)\nF : (i : I) â†’ CategoryTheory.Functor (C i) (D i)\nf : (i : I) â†’ C i\ni : I\nâŠ¢ Eq ((CategoryTheory.Functor.pi F).obj f i) ((F i).obj (f i))","decl":"/-- Assemble an `I`-indexed family of functors into a functor between the pi types.\n-/\n@[simps]\ndef pi (F : âˆ€ i, C i â¥¤ D i) : (âˆ€ i, C i) â¥¤ âˆ€ i, D i where\n  obj f i := (F i).obj (f i)\n  map Î± i := (F i).map (Î± i)\n\n"}
{"name":"CategoryTheory.Functor.pi_map","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nD : I â†’ Type uâ‚‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚‚, uâ‚‚} (D i)\nF : (i : I) â†’ CategoryTheory.Functor (C i) (D i)\nXâœ Yâœ : (i : I) â†’ C i\nÎ± : Quiver.Hom Xâœ Yâœ\ni : I\nâŠ¢ Eq ((CategoryTheory.Functor.pi F).map Î± i) ((F i).map (Î± i))","decl":"/-- Assemble an `I`-indexed family of functors into a functor between the pi types.\n-/\n@[simps]\ndef pi (F : âˆ€ i, C i â¥¤ D i) : (âˆ€ i, C i) â¥¤ âˆ€ i, D i where\n  obj f i := (F i).obj (f i)\n  map Î± i := (F i).map (Î± i)\n\n"}
{"name":"CategoryTheory.Functor.pi'_map","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nA : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} A\nf : (i : I) â†’ CategoryTheory.Functor A (C i)\nXâœ Yâœ : A\nh : Quiver.Hom Xâœ Yâœ\ni : I\nâŠ¢ Eq ((CategoryTheory.Functor.pi' f).map h i) ((f i).map h)","decl":"/-- Similar to `pi`, but all functors come from the same category `A`\n-/\n@[simps]\ndef pi' (f : âˆ€ i, A â¥¤ C i) : A â¥¤ âˆ€ i, C i where\n  obj a i := (f i).obj a\n  map h i := (f i).map h\n\n"}
{"name":"CategoryTheory.Functor.pi'_obj","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nA : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} A\nf : (i : I) â†’ CategoryTheory.Functor A (C i)\na : A\ni : I\nâŠ¢ Eq ((CategoryTheory.Functor.pi' f).obj a i) ((f i).obj a)","decl":"/-- Similar to `pi`, but all functors come from the same category `A`\n-/\n@[simps]\ndef pi' (f : âˆ€ i, A â¥¤ C i) : A â¥¤ âˆ€ i, C i where\n  obj a i := (f i).obj a\n  map h i := (f i).map h\n\n"}
{"name":"CategoryTheory.Functor.pi'CompEval_inv_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nA : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} A\nF : (i : I) â†’ CategoryTheory.Functor A (C i)\ni : I\nX : A\nâŠ¢ Eq ((CategoryTheory.Functor.pi'CompEval F i).inv.app X) (CategoryTheory.CategoryStruct.id ((F i).obj X))","decl":"/-- The projections of `Functor.pi' F` are isomorphic to the functors of the family `F` -/\n@[simps!]\ndef pi'CompEval {A : Type*} [Category A] (F : âˆ€ i, A â¥¤ C i) (i : I) :\n    pi' F â‹™ Pi.eval C i â‰… F i :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.pi'CompEval_hom_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nA : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} A\nF : (i : I) â†’ CategoryTheory.Functor A (C i)\ni : I\nX : A\nâŠ¢ Eq ((CategoryTheory.Functor.pi'CompEval F i).hom.app X) (CategoryTheory.CategoryStruct.id ((F i).obj X))","decl":"/-- The projections of `Functor.pi' F` are isomorphic to the functors of the family `F` -/\n@[simps!]\ndef pi'CompEval {A : Type*} [Category A] (F : âˆ€ i, A â¥¤ C i) (i : I) :\n    pi' F â‹™ Pi.eval C i â‰… F i :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.eqToHom_proj","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nx x' : (i : I) â†’ C i\nh : Eq x x'\ni : I\nâŠ¢ Eq (CategoryTheory.eqToHom h i) (CategoryTheory.eqToHom â‹¯)","decl":"@[simp]\ntheorem eqToHom_proj {x x' : âˆ€ i, C i} (h : x = x') (i : I) :\n    (eqToHom h : x âŸ¶ x') i = eqToHom (funext_iff.mp h i) := by\n  subst h\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.pi'_eval","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nA : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} A\nf : (i : I) â†’ CategoryTheory.Functor A (C i)\ni : I\nâŠ¢ Eq ((CategoryTheory.Functor.pi' f).comp (CategoryTheory.Pi.eval C i)) (f i)","decl":"@[simp]\ntheorem pi'_eval (f : âˆ€ i, A â¥¤ C i) (i : I) : pi' f â‹™ Pi.eval C i = f i := by\n  apply Functor.ext\n  Â· intro _ _ _\n    simp\n  Â· intro _\n    rfl\n\n"}
{"name":"CategoryTheory.Functor.pi_ext","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nA : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} A\nf f' : CategoryTheory.Functor A ((i : I) â†’ C i)\nh : âˆ€ (i : I), Eq (f.comp (CategoryTheory.Pi.eval C i)) (f'.comp (CategoryTheory.Pi.eval C i))\nâŠ¢ Eq f f'","decl":"/-- Two functors to a product category are equal iff they agree on every coordinate. -/\ntheorem pi_ext (f f' : A â¥¤ âˆ€ i, C i) (h : âˆ€ i, f â‹™ (Pi.eval C i) = f' â‹™ (Pi.eval C i)) :\n    f = f' := by\n  apply Functor.ext; rotate_left\n  Â· intro X\n    ext i\n    specialize h i\n    have := congr_obj h X\n    simpa\n  Â· intro X Y g\n    dsimp\n    funext i\n    specialize h i\n    have := congr_hom h g\n    simpa\n\n"}
{"name":"CategoryTheory.NatTrans.pi_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nD : I â†’ Type uâ‚‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚‚, uâ‚‚} (D i)\nF G : (i : I) â†’ CategoryTheory.Functor (C i) (D i)\nÎ± : (i : I) â†’ Quiver.Hom (F i) (G i)\nf : (i : I) â†’ C i\ni : I\nâŠ¢ Eq ((CategoryTheory.NatTrans.pi Î±).app f i) ((Î± i).app (f i))","decl":"/-- Assemble an `I`-indexed family of natural transformations into a single natural transformation.\n-/\n@[simps!]\ndef pi (Î± : âˆ€ i, F i âŸ¶ G i) : Functor.pi F âŸ¶ Functor.pi G where\n  app f i := (Î± i).app (f i)\n\n"}
{"name":"CategoryTheory.NatTrans.pi'_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nE : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} E\nF G : CategoryTheory.Functor E ((i : I) â†’ C i)\nÏ„ : (i : I) â†’ Quiver.Hom (F.comp (CategoryTheory.Pi.eval C i)) (G.comp (CategoryTheory.Pi.eval C i))\nX : E\ni : I\nâŠ¢ Eq ((CategoryTheory.NatTrans.pi' Ï„).app X i) ((Ï„ i).app X)","decl":"/-- Assemble an `I`-indexed family of natural transformations into a single natural transformation.\n-/\n@[simps]\ndef pi' {E : Type*} [Category E] {F G : E â¥¤ âˆ€ i, C i}\n    (Ï„ : âˆ€ i, F â‹™ Pi.eval C i âŸ¶ G â‹™ Pi.eval C i) : F âŸ¶ G where\n  app := fun X i => (Ï„ i).app X\n  naturality _ _ f := by\n    ext i\n    exact (Ï„ i).naturality f\n\n"}
{"name":"CategoryTheory.NatIso.pi_hom","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nD : I â†’ Type uâ‚‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚‚, uâ‚‚} (D i)\nF G : (i : I) â†’ CategoryTheory.Functor (C i) (D i)\ne : (i : I) â†’ CategoryTheory.Iso (F i) (G i)\nâŠ¢ Eq (CategoryTheory.NatIso.pi e).hom (CategoryTheory.NatTrans.pi fun i => (e i).hom)","decl":"/-- Assemble an `I`-indexed family of natural isomorphisms into a single natural isomorphism.\n-/\n@[simps]\ndef pi (e : âˆ€ i, F i â‰… G i) : Functor.pi F â‰… Functor.pi G where\n  hom := NatTrans.pi (fun i => (e i).hom)\n  inv := NatTrans.pi (fun i => (e i).inv)\n\n"}
{"name":"CategoryTheory.NatIso.pi_inv","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nD : I â†’ Type uâ‚‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚‚, uâ‚‚} (D i)\nF G : (i : I) â†’ CategoryTheory.Functor (C i) (D i)\ne : (i : I) â†’ CategoryTheory.Iso (F i) (G i)\nâŠ¢ Eq (CategoryTheory.NatIso.pi e).inv (CategoryTheory.NatTrans.pi fun i => (e i).inv)","decl":"/-- Assemble an `I`-indexed family of natural isomorphisms into a single natural isomorphism.\n-/\n@[simps]\ndef pi (e : âˆ€ i, F i â‰… G i) : Functor.pi F â‰… Functor.pi G where\n  hom := NatTrans.pi (fun i => (e i).hom)\n  inv := NatTrans.pi (fun i => (e i).inv)\n\n"}
{"name":"CategoryTheory.NatIso.pi'_inv","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nE : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} E\nF G : CategoryTheory.Functor E ((i : I) â†’ C i)\ne : (i : I) â†’ CategoryTheory.Iso (F.comp (CategoryTheory.Pi.eval C i)) (G.comp (CategoryTheory.Pi.eval C i))\nâŠ¢ Eq (CategoryTheory.NatIso.pi' e).inv (CategoryTheory.NatTrans.pi' fun i => (e i).inv)","decl":"/-- Assemble an `I`-indexed family of natural isomorphisms into a single natural isomorphism.\n-/\n@[simps]\ndef pi' {E : Type*} [Category E] {F G : E â¥¤ âˆ€ i, C i}\n    (e : âˆ€ i, F â‹™ Pi.eval C i â‰… G â‹™ Pi.eval C i) : F â‰… G where\n  hom := NatTrans.pi' (fun i => (e i).hom)\n  inv := NatTrans.pi' (fun i => (e i).inv)\n\n"}
{"name":"CategoryTheory.NatIso.pi'_hom","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nE : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} E\nF G : CategoryTheory.Functor E ((i : I) â†’ C i)\ne : (i : I) â†’ CategoryTheory.Iso (F.comp (CategoryTheory.Pi.eval C i)) (G.comp (CategoryTheory.Pi.eval C i))\nâŠ¢ Eq (CategoryTheory.NatIso.pi' e).hom (CategoryTheory.NatTrans.pi' fun i => (e i).hom)","decl":"/-- Assemble an `I`-indexed family of natural isomorphisms into a single natural isomorphism.\n-/\n@[simps]\ndef pi' {E : Type*} [Category E] {F G : E â¥¤ âˆ€ i, C i}\n    (e : âˆ€ i, F â‹™ Pi.eval C i â‰… G â‹™ Pi.eval C i) : F â‰… G where\n  hom := NatTrans.pi' (fun i => (e i).hom)\n  inv := NatTrans.pi' (fun i => (e i).inv)\n\n"}
{"name":"CategoryTheory.isIso_pi_iff","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nX Y : (i : I) â†’ C i\nf : Quiver.Hom X Y\nâŠ¢ Iff (CategoryTheory.IsIso f) (âˆ€ (i : I), CategoryTheory.IsIso (f i))","decl":"lemma isIso_pi_iff {X Y : âˆ€ i, C i} (f : X âŸ¶ Y) :\n    IsIso f â†” âˆ€ i, IsIso (f i) := by\n  constructor\n  Â· intro _ i\n    exact (Pi.isoApp (asIso f) i).isIso_hom\n  Â· intro\n    exact âŸ¨fun i => inv (f i), by aesop_cat, by aesop_catâŸ©\n\n"}
{"name":"CategoryTheory.Pi.evalCompEqToEquivalenceFunctor_inv","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\ni j : I\nh : Eq i j\nâŠ¢ Eq (CategoryTheory.Pi.evalCompEqToEquivalenceFunctor C h).inv (CategoryTheory.eqToHom â‹¯)","decl":"/-- When `i = j`, projections `Pi.eval C i` and `Pi.eval C j` are related by the equivalence\n`Pi.eqToEquivalence C h : C i â‰Œ C j`. -/\n@[simps!]\ndef Pi.evalCompEqToEquivalenceFunctor {i j : I} (h : i = j) :\n    Pi.eval C i â‹™ (Pi.eqToEquivalence C h).functor â‰…\n      Pi.eval C j :=\n  eqToIso (by subst h; rfl)\n\n"}
{"name":"CategoryTheory.Pi.evalCompEqToEquivalenceFunctor_hom","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\ni j : I\nh : Eq i j\nâŠ¢ Eq (CategoryTheory.Pi.evalCompEqToEquivalenceFunctor C h).hom (CategoryTheory.eqToHom â‹¯)","decl":"/-- When `i = j`, projections `Pi.eval C i` and `Pi.eval C j` are related by the equivalence\n`Pi.eqToEquivalence C h : C i â‰Œ C j`. -/\n@[simps!]\ndef Pi.evalCompEqToEquivalenceFunctor {i j : I} (h : i = j) :\n    Pi.eval C i â‹™ (Pi.eqToEquivalence C h).functor â‰…\n      Pi.eval C j :=\n  eqToIso (by subst h; rfl)\n\n"}
{"name":"CategoryTheory.Pi.eqToEquivalenceFunctorIso_inv","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nJ : Type wâ‚\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nf : J â†’ I\ni' j' : J\nh : Eq i' j'\nâŠ¢ Eq (CategoryTheory.Pi.eqToEquivalenceFunctorIso C f h).inv (CategoryTheory.eqToHom â‹¯)","decl":"/-- The equivalences given by `Pi.eqToEquivalence` are compatible with reindexing. -/\n@[simps!]\ndef Pi.eqToEquivalenceFunctorIso (f : J â†’ I) {i' j' : J} (h : i' = j') :\n    (Pi.eqToEquivalence C (congr_arg f h)).functor â‰…\n      (Pi.eqToEquivalence (fun i' => C (f i')) h).functor :=\n  eqToIso (by subst h; rfl)\n\n"}
{"name":"CategoryTheory.Pi.eqToEquivalenceFunctorIso_hom","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nJ : Type wâ‚\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nf : J â†’ I\ni' j' : J\nh : Eq i' j'\nâŠ¢ Eq (CategoryTheory.Pi.eqToEquivalenceFunctorIso C f h).hom (CategoryTheory.eqToHom â‹¯)","decl":"/-- The equivalences given by `Pi.eqToEquivalence` are compatible with reindexing. -/\n@[simps!]\ndef Pi.eqToEquivalenceFunctorIso (f : J â†’ I) {i' j' : J} (h : i' = j') :\n    (Pi.eqToEquivalence C (congr_arg f h)).functor â‰…\n      (Pi.eqToEquivalence (fun i' => C (f i')) h).functor :=\n  eqToIso (by subst h; rfl)\n\n"}
{"name":"CategoryTheory.Pi.equivalenceOfEquiv_inverse","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nJ : Type wâ‚\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\ne : Equiv J I\nâŠ¢ Eq (CategoryTheory.Pi.equivalenceOfEquiv C e).inverse (CategoryTheory.Functor.pi' fun i' => CategoryTheory.Pi.eval C (e i'))","decl":"/-- Reindexing a family of categories gives equivalent `Pi` categories. -/\n@[simps]\nnoncomputable def Pi.equivalenceOfEquiv (e : J â‰ƒ I) :\n    (âˆ€ j, C (e j)) â‰Œ (âˆ€ i, C i) where\n  functor := Functor.pi' (fun i => Pi.eval _ (e.symm i) â‹™\n    (Pi.eqToEquivalence C (by simp)).functor)\n  inverse := Functor.pi' (fun i' => Pi.eval _ (e i'))\n  unitIso := NatIso.pi' (fun i' => Functor.leftUnitor _ â‰ªâ‰«\n    (Pi.evalCompEqToEquivalenceFunctor (fun j => C (e j)) (e.symm_apply_apply i')).symm â‰ªâ‰«\n    isoWhiskerLeft _ ((Pi.eqToEquivalenceFunctorIso C e (e.symm_apply_apply i')).symm) â‰ªâ‰«\n    (Functor.pi'CompEval _ _).symm â‰ªâ‰« isoWhiskerLeft _ (Functor.pi'CompEval _ _).symm â‰ªâ‰«\n    (Functor.associator _ _ _).symm)\n  counitIso := NatIso.pi' (fun i => (Functor.associator _ _ _).symm â‰ªâ‰«\n    isoWhiskerRight (Functor.pi'CompEval _ _) _ â‰ªâ‰«\n    Pi.evalCompEqToEquivalenceFunctor C (e.apply_symm_apply i) â‰ªâ‰«\n    (Functor.leftUnitor _).symm)\n\n"}
{"name":"CategoryTheory.Pi.equivalenceOfEquiv_unitIso","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nJ : Type wâ‚\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\ne : Equiv J I\nâŠ¢ Eq (CategoryTheory.Pi.equivalenceOfEquiv C e).unitIso (CategoryTheory.NatIso.pi' fun i' => (CategoryTheory.Pi.eval (fun i => C (e i)) i').leftUnitor.trans ((CategoryTheory.Pi.evalCompEqToEquivalenceFunctor (fun j => C (e j)) â‹¯).symm.trans ((CategoryTheory.isoWhiskerLeft (CategoryTheory.Pi.eval (fun j => C (e j)) (e.symm (e i'))) (CategoryTheory.Pi.eqToEquivalenceFunctorIso C â‡‘e â‹¯).symm).trans ((CategoryTheory.Functor.pi'CompEval (CategoryTheory.Pi.eval (fun j => C (e j)) (e.symm (e i'))).comp (CategoryTheory.Pi.eqToEquivalence C â‹¯).functor).symm.trans ((CategoryTheory.isoWhiskerLeft (CategoryTheory.Functor.pi' (CategoryTheory.Pi.eval (fun j => C (e j)) (e.symm (e i'))).comp) (CategoryTheory.Functor.pi'CompEval (CategoryTheory.Pi.eval fun i => C (e i')) (CategoryTheory.Pi.eqToEquivalence C â‹¯).functor).symm).trans ((CategoryTheory.Functor.pi' (CategoryTheory.Pi.eval (fun j => C (e j)) (e.symm (e i'))).comp).associator (CategoryTheory.Functor.pi' (CategoryTheory.Pi.eval fun i => C (e i'))) (CategoryTheory.Pi.eval (fun i => C (e i')) (CategoryTheory.Pi.eqToEquivalence C â‹¯).functor)).symm)))))","decl":"/-- Reindexing a family of categories gives equivalent `Pi` categories. -/\n@[simps]\nnoncomputable def Pi.equivalenceOfEquiv (e : J â‰ƒ I) :\n    (âˆ€ j, C (e j)) â‰Œ (âˆ€ i, C i) where\n  functor := Functor.pi' (fun i => Pi.eval _ (e.symm i) â‹™\n    (Pi.eqToEquivalence C (by simp)).functor)\n  inverse := Functor.pi' (fun i' => Pi.eval _ (e i'))\n  unitIso := NatIso.pi' (fun i' => Functor.leftUnitor _ â‰ªâ‰«\n    (Pi.evalCompEqToEquivalenceFunctor (fun j => C (e j)) (e.symm_apply_apply i')).symm â‰ªâ‰«\n    isoWhiskerLeft _ ((Pi.eqToEquivalenceFunctorIso C e (e.symm_apply_apply i')).symm) â‰ªâ‰«\n    (Functor.pi'CompEval _ _).symm â‰ªâ‰« isoWhiskerLeft _ (Functor.pi'CompEval _ _).symm â‰ªâ‰«\n    (Functor.associator _ _ _).symm)\n  counitIso := NatIso.pi' (fun i => (Functor.associator _ _ _).symm â‰ªâ‰«\n    isoWhiskerRight (Functor.pi'CompEval _ _) _ â‰ªâ‰«\n    Pi.evalCompEqToEquivalenceFunctor C (e.apply_symm_apply i) â‰ªâ‰«\n    (Functor.leftUnitor _).symm)\n\n"}
{"name":"CategoryTheory.Pi.equivalenceOfEquiv_counitIso","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nJ : Type wâ‚\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\ne : Equiv J I\nâŠ¢ Eq (CategoryTheory.Pi.equivalenceOfEquiv C e).counitIso (CategoryTheory.NatIso.pi' fun i => ((CategoryTheory.Functor.pi' fun i' => CategoryTheory.Pi.eval C (e i')).associator (CategoryTheory.Pi.eval (fun j => C (e j)) (e.symm i)) (CategoryTheory.Pi.eqToEquivalence C â‹¯).functor).symm.trans ((CategoryTheory.isoWhiskerRight (CategoryTheory.Functor.pi'CompEval (fun i' => CategoryTheory.Pi.eval C (e i')) (e.symm i)) (CategoryTheory.Pi.eqToEquivalence C â‹¯).functor).trans ((CategoryTheory.Pi.evalCompEqToEquivalenceFunctor C â‹¯).trans (CategoryTheory.Pi.eval C i).leftUnitor.symm)))","decl":"/-- Reindexing a family of categories gives equivalent `Pi` categories. -/\n@[simps]\nnoncomputable def Pi.equivalenceOfEquiv (e : J â‰ƒ I) :\n    (âˆ€ j, C (e j)) â‰Œ (âˆ€ i, C i) where\n  functor := Functor.pi' (fun i => Pi.eval _ (e.symm i) â‹™\n    (Pi.eqToEquivalence C (by simp)).functor)\n  inverse := Functor.pi' (fun i' => Pi.eval _ (e i'))\n  unitIso := NatIso.pi' (fun i' => Functor.leftUnitor _ â‰ªâ‰«\n    (Pi.evalCompEqToEquivalenceFunctor (fun j => C (e j)) (e.symm_apply_apply i')).symm â‰ªâ‰«\n    isoWhiskerLeft _ ((Pi.eqToEquivalenceFunctorIso C e (e.symm_apply_apply i')).symm) â‰ªâ‰«\n    (Functor.pi'CompEval _ _).symm â‰ªâ‰« isoWhiskerLeft _ (Functor.pi'CompEval _ _).symm â‰ªâ‰«\n    (Functor.associator _ _ _).symm)\n  counitIso := NatIso.pi' (fun i => (Functor.associator _ _ _).symm â‰ªâ‰«\n    isoWhiskerRight (Functor.pi'CompEval _ _) _ â‰ªâ‰«\n    Pi.evalCompEqToEquivalenceFunctor C (e.apply_symm_apply i) â‰ªâ‰«\n    (Functor.leftUnitor _).symm)\n\n"}
{"name":"CategoryTheory.Pi.equivalenceOfEquiv_functor","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nJ : Type wâ‚\nC : I â†’ Type uâ‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\ne : Equiv J I\nâŠ¢ Eq (CategoryTheory.Pi.equivalenceOfEquiv C e).functor (CategoryTheory.Functor.pi' fun i => (CategoryTheory.Pi.eval (fun j => C (e j)) (e.symm i)).comp (CategoryTheory.Pi.eqToEquivalence C â‹¯).functor)","decl":"/-- Reindexing a family of categories gives equivalent `Pi` categories. -/\n@[simps]\nnoncomputable def Pi.equivalenceOfEquiv (e : J â‰ƒ I) :\n    (âˆ€ j, C (e j)) â‰Œ (âˆ€ i, C i) where\n  functor := Functor.pi' (fun i => Pi.eval _ (e.symm i) â‹™\n    (Pi.eqToEquivalence C (by simp)).functor)\n  inverse := Functor.pi' (fun i' => Pi.eval _ (e i'))\n  unitIso := NatIso.pi' (fun i' => Functor.leftUnitor _ â‰ªâ‰«\n    (Pi.evalCompEqToEquivalenceFunctor (fun j => C (e j)) (e.symm_apply_apply i')).symm â‰ªâ‰«\n    isoWhiskerLeft _ ((Pi.eqToEquivalenceFunctorIso C e (e.symm_apply_apply i')).symm) â‰ªâ‰«\n    (Functor.pi'CompEval _ _).symm â‰ªâ‰« isoWhiskerLeft _ (Functor.pi'CompEval _ _).symm â‰ªâ‰«\n    (Functor.associator _ _ _).symm)\n  counitIso := NatIso.pi' (fun i => (Functor.associator _ _ _).symm â‰ªâ‰«\n    isoWhiskerRight (Functor.pi'CompEval _ _) _ â‰ªâ‰«\n    Pi.evalCompEqToEquivalenceFunctor C (e.apply_symm_apply i) â‰ªâ‰«\n    (Functor.leftUnitor _).symm)\n\n"}
{"name":"CategoryTheory.Pi.optionEquivalence_functor","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"J : Type wâ‚\nC' : Option J â†’ Type uâ‚\ninstâœ : (i : Option J) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C' i)\nâŠ¢ Eq (CategoryTheory.Pi.optionEquivalence C').functor ((CategoryTheory.Pi.eval C' Option.none).prod' (CategoryTheory.Functor.pi' fun i => CategoryTheory.Pi.eval C' (Option.some i)))","decl":"/-- A product of categories indexed by `Option J` identifies to a binary product. -/\n@[simps]\ndef Pi.optionEquivalence (C' : Option J â†’ Type uâ‚) [âˆ€ i, Category.{vâ‚} (C' i)] :\n    (âˆ€ i, C' i) â‰Œ C' none Ã— (âˆ€ (j : J), C' (some j)) where\n  functor := Functor.prod' (Pi.eval C' none)\n    (Functor.pi' (fun i => (Pi.eval _ (some i))))\n  inverse := Functor.pi' (fun i => match i with\n    | none => Prod.fst _ _\n    | some i => Prod.snd _ _ â‹™ (Pi.eval _ i))\n  unitIso := NatIso.pi' (fun i => match i with\n    | none => Iso.refl _\n    | some _ => Iso.refl _)\n  counitIso := by exact Iso.refl _\n\n"}
{"name":"CategoryTheory.Pi.optionEquivalence_counitIso","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"J : Type wâ‚\nC' : Option J â†’ Type uâ‚\ninstâœ : (i : Option J) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C' i)\nâŠ¢ Eq (CategoryTheory.Pi.optionEquivalence C').counitIso (CategoryTheory.Iso.refl ((CategoryTheory.Functor.pi' fun i => CategoryTheory.Pi.optionEquivalence.match_1 (fun i => CategoryTheory.Functor (Prod (C' Option.none) ((j : J) â†’ C' (Option.some j))) (C' i)) i (fun _ => CategoryTheory.Prod.fst (C' Option.none) ((j : J) â†’ C' (Option.some j))) fun i => (CategoryTheory.Prod.snd (C' Option.none) ((j : J) â†’ C' (Option.some j))).comp (CategoryTheory.Pi.eval (fun j => C' (Option.some j)) i)).comp ((CategoryTheory.Pi.eval C' Option.none).prod' (CategoryTheory.Functor.pi' fun i => CategoryTheory.Pi.eval C' (Option.some i)))))","decl":"/-- A product of categories indexed by `Option J` identifies to a binary product. -/\n@[simps]\ndef Pi.optionEquivalence (C' : Option J â†’ Type uâ‚) [âˆ€ i, Category.{vâ‚} (C' i)] :\n    (âˆ€ i, C' i) â‰Œ C' none Ã— (âˆ€ (j : J), C' (some j)) where\n  functor := Functor.prod' (Pi.eval C' none)\n    (Functor.pi' (fun i => (Pi.eval _ (some i))))\n  inverse := Functor.pi' (fun i => match i with\n    | none => Prod.fst _ _\n    | some i => Prod.snd _ _ â‹™ (Pi.eval _ i))\n  unitIso := NatIso.pi' (fun i => match i with\n    | none => Iso.refl _\n    | some _ => Iso.refl _)\n  counitIso := by exact Iso.refl _\n\n"}
{"name":"CategoryTheory.Pi.optionEquivalence_inverse","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"J : Type wâ‚\nC' : Option J â†’ Type uâ‚\ninstâœ : (i : Option J) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C' i)\nâŠ¢ Eq (CategoryTheory.Pi.optionEquivalence C').inverse (CategoryTheory.Functor.pi' fun i => CategoryTheory.Pi.optionEquivalence.match_1 (fun i => CategoryTheory.Functor (Prod (C' Option.none) ((j : J) â†’ C' (Option.some j))) (C' i)) i (fun _ => CategoryTheory.Prod.fst (C' Option.none) ((j : J) â†’ C' (Option.some j))) fun i => (CategoryTheory.Prod.snd (C' Option.none) ((j : J) â†’ C' (Option.some j))).comp (CategoryTheory.Pi.eval (fun j => C' (Option.some j)) i))","decl":"/-- A product of categories indexed by `Option J` identifies to a binary product. -/\n@[simps]\ndef Pi.optionEquivalence (C' : Option J â†’ Type uâ‚) [âˆ€ i, Category.{vâ‚} (C' i)] :\n    (âˆ€ i, C' i) â‰Œ C' none Ã— (âˆ€ (j : J), C' (some j)) where\n  functor := Functor.prod' (Pi.eval C' none)\n    (Functor.pi' (fun i => (Pi.eval _ (some i))))\n  inverse := Functor.pi' (fun i => match i with\n    | none => Prod.fst _ _\n    | some i => Prod.snd _ _ â‹™ (Pi.eval _ i))\n  unitIso := NatIso.pi' (fun i => match i with\n    | none => Iso.refl _\n    | some _ => Iso.refl _)\n  counitIso := by exact Iso.refl _\n\n"}
{"name":"CategoryTheory.Pi.optionEquivalence_unitIso","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"J : Type wâ‚\nC' : Option J â†’ Type uâ‚\ninstâœ : (i : Option J) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C' i)\nâŠ¢ Eq (CategoryTheory.Pi.optionEquivalence C').unitIso (CategoryTheory.NatIso.pi' fun i => CategoryTheory.Pi.optionEquivalence.match_1 (fun i => CategoryTheory.Iso ((CategoryTheory.Functor.id ((i : Option J) â†’ C' i)).comp (CategoryTheory.Pi.eval C' i)) ((((CategoryTheory.Pi.eval C' Option.none).prod' (CategoryTheory.Functor.pi' fun i => CategoryTheory.Pi.eval C' (Option.some i))).comp (CategoryTheory.Functor.pi' fun i => CategoryTheory.Pi.optionEquivalence.match_1 (fun i => CategoryTheory.Functor (Prod (C' Option.none) ((j : J) â†’ C' (Option.some j))) (C' i)) i (fun _ => CategoryTheory.Prod.fst (C' Option.none) ((j : J) â†’ C' (Option.some j))) fun i => (CategoryTheory.Prod.snd (C' Option.none) ((j : J) â†’ C' (Option.some j))).comp (CategoryTheory.Pi.eval (fun j => C' (Option.some j)) i))).comp (CategoryTheory.Pi.eval C' i))) i (fun _ => CategoryTheory.Iso.refl ((CategoryTheory.Functor.id ((i : Option J) â†’ C' i)).comp (CategoryTheory.Pi.eval C' Option.none))) fun val => CategoryTheory.Iso.refl ((CategoryTheory.Functor.id ((i : Option J) â†’ C' i)).comp (CategoryTheory.Pi.eval C' (Option.some val))))","decl":"/-- A product of categories indexed by `Option J` identifies to a binary product. -/\n@[simps]\ndef Pi.optionEquivalence (C' : Option J â†’ Type uâ‚) [âˆ€ i, Category.{vâ‚} (C' i)] :\n    (âˆ€ i, C' i) â‰Œ C' none Ã— (âˆ€ (j : J), C' (some j)) where\n  functor := Functor.prod' (Pi.eval C' none)\n    (Functor.pi' (fun i => (Pi.eval _ (some i))))\n  inverse := Functor.pi' (fun i => match i with\n    | none => Prod.fst _ _\n    | some i => Prod.snd _ _ â‹™ (Pi.eval _ i))\n  unitIso := NatIso.pi' (fun i => match i with\n    | none => Iso.refl _\n    | some _ => Iso.refl _)\n  counitIso := by exact Iso.refl _\n\n"}
{"name":"CategoryTheory.Equivalence.pi_unitIso","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nD : I â†’ Type uâ‚‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚‚, uâ‚‚} (D i)\nE : (i : I) â†’ CategoryTheory.Equivalence (C i) (D i)\nâŠ¢ Eq (CategoryTheory.Equivalence.pi E).unitIso (CategoryTheory.NatIso.pi fun i => (E i).unitIso)","decl":"/-- Assemble an `I`-indexed family of equivalences of categories\ninto a single equivalence. -/\n@[simps]\ndef pi (E : âˆ€ i, C i â‰Œ D i) : (âˆ€ i, C i) â‰Œ (âˆ€ i, D i) where\n  functor := Functor.pi (fun i => (E i).functor)\n  inverse := Functor.pi (fun i => (E i).inverse)\n  unitIso := NatIso.pi (fun i => (E i).unitIso)\n  counitIso := NatIso.pi (fun i => (E i).counitIso)\n\n"}
{"name":"CategoryTheory.Equivalence.pi_inverse","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nD : I â†’ Type uâ‚‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚‚, uâ‚‚} (D i)\nE : (i : I) â†’ CategoryTheory.Equivalence (C i) (D i)\nâŠ¢ Eq (CategoryTheory.Equivalence.pi E).inverse (CategoryTheory.Functor.pi fun i => (E i).inverse)","decl":"/-- Assemble an `I`-indexed family of equivalences of categories\ninto a single equivalence. -/\n@[simps]\ndef pi (E : âˆ€ i, C i â‰Œ D i) : (âˆ€ i, C i) â‰Œ (âˆ€ i, D i) where\n  functor := Functor.pi (fun i => (E i).functor)\n  inverse := Functor.pi (fun i => (E i).inverse)\n  unitIso := NatIso.pi (fun i => (E i).unitIso)\n  counitIso := NatIso.pi (fun i => (E i).counitIso)\n\n"}
{"name":"CategoryTheory.Equivalence.pi_counitIso","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nD : I â†’ Type uâ‚‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚‚, uâ‚‚} (D i)\nE : (i : I) â†’ CategoryTheory.Equivalence (C i) (D i)\nâŠ¢ Eq (CategoryTheory.Equivalence.pi E).counitIso (CategoryTheory.NatIso.pi fun i => (E i).counitIso)","decl":"/-- Assemble an `I`-indexed family of equivalences of categories\ninto a single equivalence. -/\n@[simps]\ndef pi (E : âˆ€ i, C i â‰Œ D i) : (âˆ€ i, C i) â‰Œ (âˆ€ i, D i) where\n  functor := Functor.pi (fun i => (E i).functor)\n  inverse := Functor.pi (fun i => (E i).inverse)\n  unitIso := NatIso.pi (fun i => (E i).unitIso)\n  counitIso := NatIso.pi (fun i => (E i).counitIso)\n\n"}
{"name":"CategoryTheory.Equivalence.pi_functor","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nD : I â†’ Type uâ‚‚\ninstâœ : (i : I) â†’ CategoryTheory.Category.{vâ‚‚, uâ‚‚} (D i)\nE : (i : I) â†’ CategoryTheory.Equivalence (C i) (D i)\nâŠ¢ Eq (CategoryTheory.Equivalence.pi E).functor (CategoryTheory.Functor.pi fun i => (E i).functor)","decl":"/-- Assemble an `I`-indexed family of equivalences of categories\ninto a single equivalence. -/\n@[simps]\ndef pi (E : âˆ€ i, C i â‰Œ D i) : (âˆ€ i, C i) â‰Œ (âˆ€ i, D i) where\n  functor := Functor.pi (fun i => (E i).functor)\n  inverse := Functor.pi (fun i => (E i).inverse)\n  unitIso := NatIso.pi (fun i => (E i).unitIso)\n  counitIso := NatIso.pi (fun i => (E i).counitIso)\n\n"}
{"name":"CategoryTheory.Equivalence.instIsEquivalenceForallPi","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type wâ‚€\nC : I â†’ Type uâ‚\ninstâœÂ² : (i : I) â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C i)\nD : I â†’ Type uâ‚‚\ninstâœÂ¹ : (i : I) â†’ CategoryTheory.Category.{vâ‚‚, uâ‚‚} (D i)\nF : (i : I) â†’ CategoryTheory.Functor (C i) (D i)\ninstâœ : âˆ€ (i : I), (F i).IsEquivalence\nâŠ¢ (CategoryTheory.Functor.pi F).IsEquivalence","decl":"instance (F : âˆ€ i, C i â¥¤ D i) [âˆ€ i, (F i).IsEquivalence] :\n    (Functor.pi F).IsEquivalence :=\n  (pi (fun i => (F i).asEquivalence)).isEquivalence_functor\n\n"}
