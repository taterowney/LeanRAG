{"name":"CategoryTheory.Pi.id_apply","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nX : (i : I) → C i\ni : I\n⊢ Eq (CategoryTheory.CategoryStruct.id X i) (CategoryTheory.CategoryStruct.id (X i))","decl":"@[simp]\ntheorem id_apply (X : ∀ i, C i) (i) : (𝟙 X : ∀ i, X i ⟶ X i) i = 𝟙 (X i) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Pi.comp_apply","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nX Y Z : (i : I) → C i\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ni : I\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g i) (CategoryTheory.CategoryStruct.comp (f i) (g i))","decl":"@[simp]\ntheorem comp_apply {X Y Z : ∀ i, C i} (f : X ⟶ Y) (g : Y ⟶ Z) (i) :\n    (f ≫ g : ∀ i, X i ⟶ Z i) i = f i ≫ g i :=\n  rfl\n\n"}
{"name":"CategoryTheory.Pi.ext_iff","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nX Y : (i : I) → C i\nf g : Quiver.Hom X Y\n⊢ Iff (Eq f g) (∀ (i : I), Eq (f i) (g i))","decl":"@[ext]\nlemma ext {X Y : ∀ i, C i} {f g : X ⟶ Y} (w : ∀ i, f i = g i) : f = g :=\n  funext (w ·)\n\n"}
{"name":"CategoryTheory.Pi.ext","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nX Y : (i : I) → C i\nf g : Quiver.Hom X Y\nw : ∀ (i : I), Eq (f i) (g i)\n⊢ Eq f g","decl":"@[ext]\nlemma ext {X Y : ∀ i, C i} {f g : X ⟶ Y} (w : ∀ i, f i = g i) : f = g :=\n  funext (w ·)\n\n"}
{"name":"CategoryTheory.Pi.eval_map","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\ni : I\nX✝ Y✝ : (i : I) → C i\nα : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Pi.eval C i).map α) (α i)","decl":"/--\nThe evaluation functor at `i : I`, sending an `I`-indexed family of objects to the object over `i`.\n-/\n@[simps]\ndef eval (i : I) : (∀ i, C i) ⥤ C i where\n  obj f := f i\n  map α := α i\n\n"}
{"name":"CategoryTheory.Pi.eval_obj","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\ni : I\nf : (i : I) → C i\n⊢ Eq ((CategoryTheory.Pi.eval C i).obj f) (f i)","decl":"/--\nThe evaluation functor at `i : I`, sending an `I`-indexed family of objects to the object over `i`.\n-/\n@[simps]\ndef eval (i : I) : (∀ i, C i) ⥤ C i where\n  obj f := f i\n  map α := α i\n\n"}
{"name":"CategoryTheory.Pi.comap_map","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nJ : Type w₁\nh : J → I\nX✝ Y✝ : (i : I) → C i\nα : Quiver.Hom X✝ Y✝\ni : J\n⊢ Eq ((CategoryTheory.Pi.comap C h).map α i) (α (h i))","decl":"/-- Pull back an `I`-indexed family of objects to a `J`-indexed family, along a function `J → I`.\n-/\n@[simps]\ndef comap (h : J → I) : (∀ i, C i) ⥤ (∀ j, C (h j)) where\n  obj f i := f (h i)\n  map α i := α (h i)\n\n"}
{"name":"CategoryTheory.Pi.comap_obj","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nJ : Type w₁\nh : J → I\nf : (i : I) → C i\ni : J\n⊢ Eq ((CategoryTheory.Pi.comap C h).obj f i) (f (h i))","decl":"/-- Pull back an `I`-indexed family of objects to a `J`-indexed family, along a function `J → I`.\n-/\n@[simps]\ndef comap (h : J → I) : (∀ i, C i) ⥤ (∀ j, C (h j)) where\n  obj f i := f (h i)\n  map α i := α (h i)\n\n"}
{"name":"CategoryTheory.Pi.comapId_hom_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nX : (i : I) → C i\ni : I\n⊢ Eq ((CategoryTheory.Pi.comapId I C).hom.app X i) (CategoryTheory.CategoryStruct.id X i)","decl":"/-- The natural isomorphism between\npulling back a grading along the identity function,\nand the identity functor. -/\n@[simps]\ndef comapId : comap C (id : I → I) ≅ 𝟭 (∀ i, C i) where\n  hom := { app := fun X => 𝟙 X }\n  inv := { app := fun X => 𝟙 X }\n\n"}
{"name":"CategoryTheory.Pi.comapId_inv_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nX : (i : I) → C i\ni : I\n⊢ Eq ((CategoryTheory.Pi.comapId I C).inv.app X i) (CategoryTheory.CategoryStruct.id X i)","decl":"/-- The natural isomorphism between\npulling back a grading along the identity function,\nand the identity functor. -/\n@[simps]\ndef comapId : comap C (id : I → I) ≅ 𝟭 (∀ i, C i) where\n  hom := { app := fun X => 𝟙 X }\n  inv := { app := fun X => 𝟙 X }\n\n"}
{"name":"CategoryTheory.Pi.comapComp_hom_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nJ : Type w₁\nK : Type w₂\nf : K → J\ng : J → I\nX : (i : I) → C i\nb : K\n⊢ Eq ((CategoryTheory.Pi.comapComp C f g).hom.app X b) (CategoryTheory.CategoryStruct.id (X (g (f b))))","decl":"/-- The natural isomorphism comparing between\npulling back along two successive functions, and\npulling back along their composition\n-/\n@[simps!]\ndef comapComp (f : K → J) (g : J → I) : comap C g ⋙ comap (C ∘ g) f ≅ comap C (g ∘ f) where\n  hom :=\n  { app := fun X b => 𝟙 (X (g (f b)))\n    naturality := fun X Y f' => by simp only [comap, Function.comp]; funext; simp }\n  inv :=\n  { app := fun X b => 𝟙 (X (g (f b)))\n    naturality := fun X Y f' => by simp only [comap, Function.comp]; funext; simp }\n\n"}
{"name":"CategoryTheory.Pi.comapComp_inv_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nJ : Type w₁\nK : Type w₂\nf : K → J\ng : J → I\nX : (i : I) → C i\nb : K\n⊢ Eq ((CategoryTheory.Pi.comapComp C f g).inv.app X b) (CategoryTheory.CategoryStruct.id (X (g (f b))))","decl":"/-- The natural isomorphism comparing between\npulling back along two successive functions, and\npulling back along their composition\n-/\n@[simps!]\ndef comapComp (f : K → J) (g : J → I) : comap C g ⋙ comap (C ∘ g) f ≅ comap C (g ∘ f) where\n  hom :=\n  { app := fun X b => 𝟙 (X (g (f b)))\n    naturality := fun X Y f' => by simp only [comap, Function.comp]; funext; simp }\n  inv :=\n  { app := fun X b => 𝟙 (X (g (f b)))\n    naturality := fun X Y f' => by simp only [comap, Function.comp]; funext; simp }\n\n"}
{"name":"CategoryTheory.Pi.comapEvalIsoEval_hom_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nJ : Type w₁\nh : J → I\nj : J\nX : (i : I) → C i\n⊢ Eq ((CategoryTheory.Pi.comapEvalIsoEval C h j).hom.app X) (CategoryTheory.CategoryStruct.id (X (h j)))","decl":"/-- The natural isomorphism between pulling back then evaluating, and just evaluating. -/\n@[simps!]\ndef comapEvalIsoEval (h : J → I) (j : J) : comap C h ⋙ eval (C ∘ h) j ≅ eval C (h j) :=\n  NatIso.ofComponents (fun _ => Iso.refl _) (by simp only [Iso.refl]; simp)\n\n"}
{"name":"CategoryTheory.Pi.comapEvalIsoEval_inv_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nJ : Type w₁\nh : J → I\nj : J\nX : (i : I) → C i\n⊢ Eq ((CategoryTheory.Pi.comapEvalIsoEval C h j).inv.app X) (CategoryTheory.CategoryStruct.id (X (h j)))","decl":"/-- The natural isomorphism between pulling back then evaluating, and just evaluating. -/\n@[simps!]\ndef comapEvalIsoEval (h : J → I) (j : J) : comap C h ⋙ eval (C ∘ h) j ≅ eval C (h j) :=\n  NatIso.ofComponents (fun _ => Iso.refl _) (by simp only [Iso.refl]; simp)\n\n"}
{"name":"CategoryTheory.Pi.sum_map_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nJ : Type w₀\nD : J → Type u₁\ninst✝ : (j : J) → CategoryTheory.Category.{v₁, u₁} (D j)\nX X' : (i : I) → C i\nf : Quiver.Hom X X'\nY : (j : J) → D j\ns : Sum I J\n⊢ Eq (((CategoryTheory.Pi.sum C).map f).app Y s) (CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Quiver.Hom (((fun X => { obj := fun Y s => CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Sum.elim C D s) s (fun i => X i) fun j => Y j, map := fun {x x_1} f s => CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Quiver.Hom ((fun Y s => CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Sum.elim C D s) s (fun i => X i) fun j => Y j) x s) ((fun Y s => CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Sum.elim C D s) s (fun i => X i) fun j => Y j) x_1 s)) s (fun i => CategoryTheory.CategoryStruct.id (X i)) fun j => f j, map_id := ⋯, map_comp := ⋯ }) X).obj Y s) (((fun X => { obj := fun Y s => CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Sum.elim C D s) s (fun i => X i) fun j => Y j, map := fun {x x_1} f s => CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Quiver.Hom ((fun Y s => CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Sum.elim C D s) s (fun i => X i) fun j => Y j) x s) ((fun Y s => CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Sum.elim C D s) s (fun i => X i) fun j => Y j) x_1 s)) s (fun i => CategoryTheory.CategoryStruct.id (X i)) fun j => f j, map_id := ⋯, map_comp := ⋯ }) X').obj Y s)) s (fun i => f i) fun j => CategoryTheory.CategoryStruct.id (Y j))","decl":"/-- The bifunctor combining an `I`-indexed family of objects with a `J`-indexed family of objects\nto obtain an `I ⊕ J`-indexed family of objects.\n-/\n@[simps]\ndef sum : (∀ i, C i) ⥤ (∀ j, D j) ⥤ ∀ s : I ⊕ J, Sum.elim C D s where\n  obj X :=\n    { obj := fun Y s =>\n        match s with\n        | .inl i => X i\n        | .inr j => Y j\n      map := fun {_} {_} f s =>\n        match s with\n        | .inl i => 𝟙 (X i)\n        | .inr j => f j }\n  map {X} {X'} f :=\n    { app := fun Y s =>\n        match s with\n        | .inl i => f i\n        | .inr j => 𝟙 (Y j) }\n\n"}
{"name":"CategoryTheory.Pi.sum_obj_obj","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nJ : Type w₀\nD : J → Type u₁\ninst✝ : (j : J) → CategoryTheory.Category.{v₁, u₁} (D j)\nX : (i : I) → C i\nY : (j : J) → D j\ns : Sum I J\n⊢ Eq (((CategoryTheory.Pi.sum C).obj X).obj Y s) (CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Sum.elim C D s) s (fun i => X i) fun j => Y j)","decl":"/-- The bifunctor combining an `I`-indexed family of objects with a `J`-indexed family of objects\nto obtain an `I ⊕ J`-indexed family of objects.\n-/\n@[simps]\ndef sum : (∀ i, C i) ⥤ (∀ j, D j) ⥤ ∀ s : I ⊕ J, Sum.elim C D s where\n  obj X :=\n    { obj := fun Y s =>\n        match s with\n        | .inl i => X i\n        | .inr j => Y j\n      map := fun {_} {_} f s =>\n        match s with\n        | .inl i => 𝟙 (X i)\n        | .inr j => f j }\n  map {X} {X'} f :=\n    { app := fun Y s =>\n        match s with\n        | .inl i => f i\n        | .inr j => 𝟙 (Y j) }\n\n"}
{"name":"CategoryTheory.Pi.sum_obj_map","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nJ : Type w₀\nD : J → Type u₁\ninst✝ : (j : J) → CategoryTheory.Category.{v₁, u₁} (D j)\nX : (i : I) → C i\nx✝¹ x✝ : (j : J) → D j\nf : Quiver.Hom x✝¹ x✝\ns : Sum I J\n⊢ Eq (((CategoryTheory.Pi.sum C).obj X).map f s) (CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Quiver.Hom ((fun Y s => CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Sum.elim C D s) s (fun i => X i) fun j => Y j) x✝¹ s) ((fun Y s => CategoryTheory.Pi.sumElimCategory.match_1 (fun s => Sum.elim C D s) s (fun i => X i) fun j => Y j) x✝ s)) s (fun i => CategoryTheory.CategoryStruct.id (X i)) fun j => f j)","decl":"/-- The bifunctor combining an `I`-indexed family of objects with a `J`-indexed family of objects\nto obtain an `I ⊕ J`-indexed family of objects.\n-/\n@[simps]\ndef sum : (∀ i, C i) ⥤ (∀ j, D j) ⥤ ∀ s : I ⊕ J, Sum.elim C D s where\n  obj X :=\n    { obj := fun Y s =>\n        match s with\n        | .inl i => X i\n        | .inr j => Y j\n      map := fun {_} {_} f s =>\n        match s with\n        | .inl i => 𝟙 (X i)\n        | .inr j => f j }\n  map {X} {X'} f :=\n    { app := fun Y s =>\n        match s with\n        | .inl i => f i\n        | .inr j => 𝟙 (Y j) }\n\n"}
{"name":"CategoryTheory.Pi.isoApp_inv","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nX Y : (i : I) → C i\nf : CategoryTheory.Iso X Y\ni : I\n⊢ Eq (CategoryTheory.Pi.isoApp f i).inv (f.inv i)","decl":"/-- An isomorphism between `I`-indexed objects gives an isomorphism between each\npair of corresponding components. -/\n@[simps]\ndef isoApp {X Y : ∀ i, C i} (f : X ≅ Y) (i : I) : X i ≅ Y i :=\n  ⟨f.hom i, f.inv i,\n    by rw [← comp_apply, Iso.hom_inv_id, id_apply], by rw [← comp_apply, Iso.inv_hom_id, id_apply]⟩\n\n"}
{"name":"CategoryTheory.Pi.isoApp_hom","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nX Y : (i : I) → C i\nf : CategoryTheory.Iso X Y\ni : I\n⊢ Eq (CategoryTheory.Pi.isoApp f i).hom (f.hom i)","decl":"/-- An isomorphism between `I`-indexed objects gives an isomorphism between each\npair of corresponding components. -/\n@[simps]\ndef isoApp {X Y : ∀ i, C i} (f : X ≅ Y) (i : I) : X i ≅ Y i :=\n  ⟨f.hom i, f.inv i,\n    by rw [← comp_apply, Iso.hom_inv_id, id_apply], by rw [← comp_apply, Iso.inv_hom_id, id_apply]⟩\n\n"}
{"name":"CategoryTheory.Pi.isoApp_refl","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nX : (i : I) → C i\ni : I\n⊢ Eq (CategoryTheory.Pi.isoApp (CategoryTheory.Iso.refl X) i) (CategoryTheory.Iso.refl (X i))","decl":"@[simp]\ntheorem isoApp_refl (X : ∀ i, C i) (i : I) : isoApp (Iso.refl X) i = Iso.refl (X i) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Pi.isoApp_symm","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nX Y : (i : I) → C i\nf : CategoryTheory.Iso X Y\ni : I\n⊢ Eq (CategoryTheory.Pi.isoApp f.symm i) (CategoryTheory.Pi.isoApp f i).symm","decl":"@[simp]\ntheorem isoApp_symm {X Y : ∀ i, C i} (f : X ≅ Y) (i : I) : isoApp f.symm i = (isoApp f i).symm :=\n  rfl\n\n"}
{"name":"CategoryTheory.Pi.isoApp_trans","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nX Y Z : (i : I) → C i\nf : CategoryTheory.Iso X Y\ng : CategoryTheory.Iso Y Z\ni : I\n⊢ Eq (CategoryTheory.Pi.isoApp (f.trans g) i) ((CategoryTheory.Pi.isoApp f i).trans (CategoryTheory.Pi.isoApp g i))","decl":"@[simp]\ntheorem isoApp_trans {X Y Z : ∀ i, C i} (f : X ≅ Y) (g : Y ≅ Z) (i : I) :\n    isoApp (f ≪≫ g) i = isoApp f i ≪≫ isoApp g i :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.pi_obj","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nD : I → Type u₂\ninst✝ : (i : I) → CategoryTheory.Category.{v₂, u₂} (D i)\nF : (i : I) → CategoryTheory.Functor (C i) (D i)\nf : (i : I) → C i\ni : I\n⊢ Eq ((CategoryTheory.Functor.pi F).obj f i) ((F i).obj (f i))","decl":"/-- Assemble an `I`-indexed family of functors into a functor between the pi types.\n-/\n@[simps]\ndef pi (F : ∀ i, C i ⥤ D i) : (∀ i, C i) ⥤ ∀ i, D i where\n  obj f i := (F i).obj (f i)\n  map α i := (F i).map (α i)\n\n"}
{"name":"CategoryTheory.Functor.pi_map","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nD : I → Type u₂\ninst✝ : (i : I) → CategoryTheory.Category.{v₂, u₂} (D i)\nF : (i : I) → CategoryTheory.Functor (C i) (D i)\nX✝ Y✝ : (i : I) → C i\nα : Quiver.Hom X✝ Y✝\ni : I\n⊢ Eq ((CategoryTheory.Functor.pi F).map α i) ((F i).map (α i))","decl":"/-- Assemble an `I`-indexed family of functors into a functor between the pi types.\n-/\n@[simps]\ndef pi (F : ∀ i, C i ⥤ D i) : (∀ i, C i) ⥤ ∀ i, D i where\n  obj f i := (F i).obj (f i)\n  map α i := (F i).map (α i)\n\n"}
{"name":"CategoryTheory.Functor.pi'_map","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nA : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} A\nf : (i : I) → CategoryTheory.Functor A (C i)\nX✝ Y✝ : A\nh : Quiver.Hom X✝ Y✝\ni : I\n⊢ Eq ((CategoryTheory.Functor.pi' f).map h i) ((f i).map h)","decl":"/-- Similar to `pi`, but all functors come from the same category `A`\n-/\n@[simps]\ndef pi' (f : ∀ i, A ⥤ C i) : A ⥤ ∀ i, C i where\n  obj a i := (f i).obj a\n  map h i := (f i).map h\n\n"}
{"name":"CategoryTheory.Functor.pi'_obj","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nA : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} A\nf : (i : I) → CategoryTheory.Functor A (C i)\na : A\ni : I\n⊢ Eq ((CategoryTheory.Functor.pi' f).obj a i) ((f i).obj a)","decl":"/-- Similar to `pi`, but all functors come from the same category `A`\n-/\n@[simps]\ndef pi' (f : ∀ i, A ⥤ C i) : A ⥤ ∀ i, C i where\n  obj a i := (f i).obj a\n  map h i := (f i).map h\n\n"}
{"name":"CategoryTheory.Functor.pi'CompEval_inv_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nA : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} A\nF : (i : I) → CategoryTheory.Functor A (C i)\ni : I\nX : A\n⊢ Eq ((CategoryTheory.Functor.pi'CompEval F i).inv.app X) (CategoryTheory.CategoryStruct.id ((F i).obj X))","decl":"/-- The projections of `Functor.pi' F` are isomorphic to the functors of the family `F` -/\n@[simps!]\ndef pi'CompEval {A : Type*} [Category A] (F : ∀ i, A ⥤ C i) (i : I) :\n    pi' F ⋙ Pi.eval C i ≅ F i :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.pi'CompEval_hom_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nA : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} A\nF : (i : I) → CategoryTheory.Functor A (C i)\ni : I\nX : A\n⊢ Eq ((CategoryTheory.Functor.pi'CompEval F i).hom.app X) (CategoryTheory.CategoryStruct.id ((F i).obj X))","decl":"/-- The projections of `Functor.pi' F` are isomorphic to the functors of the family `F` -/\n@[simps!]\ndef pi'CompEval {A : Type*} [Category A] (F : ∀ i, A ⥤ C i) (i : I) :\n    pi' F ⋙ Pi.eval C i ≅ F i :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.eqToHom_proj","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nx x' : (i : I) → C i\nh : Eq x x'\ni : I\n⊢ Eq (CategoryTheory.eqToHom h i) (CategoryTheory.eqToHom ⋯)","decl":"@[simp]\ntheorem eqToHom_proj {x x' : ∀ i, C i} (h : x = x') (i : I) :\n    (eqToHom h : x ⟶ x') i = eqToHom (funext_iff.mp h i) := by\n  subst h\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.pi'_eval","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nA : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} A\nf : (i : I) → CategoryTheory.Functor A (C i)\ni : I\n⊢ Eq ((CategoryTheory.Functor.pi' f).comp (CategoryTheory.Pi.eval C i)) (f i)","decl":"@[simp]\ntheorem pi'_eval (f : ∀ i, A ⥤ C i) (i : I) : pi' f ⋙ Pi.eval C i = f i := by\n  apply Functor.ext\n  · intro _ _ _\n    simp\n  · intro _\n    rfl\n\n"}
{"name":"CategoryTheory.Functor.pi_ext","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nA : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} A\nf f' : CategoryTheory.Functor A ((i : I) → C i)\nh : ∀ (i : I), Eq (f.comp (CategoryTheory.Pi.eval C i)) (f'.comp (CategoryTheory.Pi.eval C i))\n⊢ Eq f f'","decl":"/-- Two functors to a product category are equal iff they agree on every coordinate. -/\ntheorem pi_ext (f f' : A ⥤ ∀ i, C i) (h : ∀ i, f ⋙ (Pi.eval C i) = f' ⋙ (Pi.eval C i)) :\n    f = f' := by\n  apply Functor.ext; rotate_left\n  · intro X\n    ext i\n    specialize h i\n    have := congr_obj h X\n    simpa\n  · intro X Y g\n    dsimp\n    funext i\n    specialize h i\n    have := congr_hom h g\n    simpa\n\n"}
{"name":"CategoryTheory.NatTrans.pi_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nD : I → Type u₂\ninst✝ : (i : I) → CategoryTheory.Category.{v₂, u₂} (D i)\nF G : (i : I) → CategoryTheory.Functor (C i) (D i)\nα : (i : I) → Quiver.Hom (F i) (G i)\nf : (i : I) → C i\ni : I\n⊢ Eq ((CategoryTheory.NatTrans.pi α).app f i) ((α i).app (f i))","decl":"/-- Assemble an `I`-indexed family of natural transformations into a single natural transformation.\n-/\n@[simps!]\ndef pi (α : ∀ i, F i ⟶ G i) : Functor.pi F ⟶ Functor.pi G where\n  app f i := (α i).app (f i)\n\n"}
{"name":"CategoryTheory.NatTrans.pi'_app","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nE : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} E\nF G : CategoryTheory.Functor E ((i : I) → C i)\nτ : (i : I) → Quiver.Hom (F.comp (CategoryTheory.Pi.eval C i)) (G.comp (CategoryTheory.Pi.eval C i))\nX : E\ni : I\n⊢ Eq ((CategoryTheory.NatTrans.pi' τ).app X i) ((τ i).app X)","decl":"/-- Assemble an `I`-indexed family of natural transformations into a single natural transformation.\n-/\n@[simps]\ndef pi' {E : Type*} [Category E] {F G : E ⥤ ∀ i, C i}\n    (τ : ∀ i, F ⋙ Pi.eval C i ⟶ G ⋙ Pi.eval C i) : F ⟶ G where\n  app := fun X i => (τ i).app X\n  naturality _ _ f := by\n    ext i\n    exact (τ i).naturality f\n\n"}
{"name":"CategoryTheory.NatIso.pi_hom","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nD : I → Type u₂\ninst✝ : (i : I) → CategoryTheory.Category.{v₂, u₂} (D i)\nF G : (i : I) → CategoryTheory.Functor (C i) (D i)\ne : (i : I) → CategoryTheory.Iso (F i) (G i)\n⊢ Eq (CategoryTheory.NatIso.pi e).hom (CategoryTheory.NatTrans.pi fun i => (e i).hom)","decl":"/-- Assemble an `I`-indexed family of natural isomorphisms into a single natural isomorphism.\n-/\n@[simps]\ndef pi (e : ∀ i, F i ≅ G i) : Functor.pi F ≅ Functor.pi G where\n  hom := NatTrans.pi (fun i => (e i).hom)\n  inv := NatTrans.pi (fun i => (e i).inv)\n\n"}
{"name":"CategoryTheory.NatIso.pi_inv","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nD : I → Type u₂\ninst✝ : (i : I) → CategoryTheory.Category.{v₂, u₂} (D i)\nF G : (i : I) → CategoryTheory.Functor (C i) (D i)\ne : (i : I) → CategoryTheory.Iso (F i) (G i)\n⊢ Eq (CategoryTheory.NatIso.pi e).inv (CategoryTheory.NatTrans.pi fun i => (e i).inv)","decl":"/-- Assemble an `I`-indexed family of natural isomorphisms into a single natural isomorphism.\n-/\n@[simps]\ndef pi (e : ∀ i, F i ≅ G i) : Functor.pi F ≅ Functor.pi G where\n  hom := NatTrans.pi (fun i => (e i).hom)\n  inv := NatTrans.pi (fun i => (e i).inv)\n\n"}
{"name":"CategoryTheory.NatIso.pi'_inv","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nE : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} E\nF G : CategoryTheory.Functor E ((i : I) → C i)\ne : (i : I) → CategoryTheory.Iso (F.comp (CategoryTheory.Pi.eval C i)) (G.comp (CategoryTheory.Pi.eval C i))\n⊢ Eq (CategoryTheory.NatIso.pi' e).inv (CategoryTheory.NatTrans.pi' fun i => (e i).inv)","decl":"/-- Assemble an `I`-indexed family of natural isomorphisms into a single natural isomorphism.\n-/\n@[simps]\ndef pi' {E : Type*} [Category E] {F G : E ⥤ ∀ i, C i}\n    (e : ∀ i, F ⋙ Pi.eval C i ≅ G ⋙ Pi.eval C i) : F ≅ G where\n  hom := NatTrans.pi' (fun i => (e i).hom)\n  inv := NatTrans.pi' (fun i => (e i).inv)\n\n"}
{"name":"CategoryTheory.NatIso.pi'_hom","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nE : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} E\nF G : CategoryTheory.Functor E ((i : I) → C i)\ne : (i : I) → CategoryTheory.Iso (F.comp (CategoryTheory.Pi.eval C i)) (G.comp (CategoryTheory.Pi.eval C i))\n⊢ Eq (CategoryTheory.NatIso.pi' e).hom (CategoryTheory.NatTrans.pi' fun i => (e i).hom)","decl":"/-- Assemble an `I`-indexed family of natural isomorphisms into a single natural isomorphism.\n-/\n@[simps]\ndef pi' {E : Type*} [Category E] {F G : E ⥤ ∀ i, C i}\n    (e : ∀ i, F ⋙ Pi.eval C i ≅ G ⋙ Pi.eval C i) : F ≅ G where\n  hom := NatTrans.pi' (fun i => (e i).hom)\n  inv := NatTrans.pi' (fun i => (e i).inv)\n\n"}
{"name":"CategoryTheory.isIso_pi_iff","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nX Y : (i : I) → C i\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.IsIso f) (∀ (i : I), CategoryTheory.IsIso (f i))","decl":"lemma isIso_pi_iff {X Y : ∀ i, C i} (f : X ⟶ Y) :\n    IsIso f ↔ ∀ i, IsIso (f i) := by\n  constructor\n  · intro _ i\n    exact (Pi.isoApp (asIso f) i).isIso_hom\n  · intro\n    exact ⟨fun i => inv (f i), by aesop_cat, by aesop_cat⟩\n\n"}
{"name":"CategoryTheory.Pi.evalCompEqToEquivalenceFunctor_inv","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\ni j : I\nh : Eq i j\n⊢ Eq (CategoryTheory.Pi.evalCompEqToEquivalenceFunctor C h).inv (CategoryTheory.eqToHom ⋯)","decl":"/-- When `i = j`, projections `Pi.eval C i` and `Pi.eval C j` are related by the equivalence\n`Pi.eqToEquivalence C h : C i ≌ C j`. -/\n@[simps!]\ndef Pi.evalCompEqToEquivalenceFunctor {i j : I} (h : i = j) :\n    Pi.eval C i ⋙ (Pi.eqToEquivalence C h).functor ≅\n      Pi.eval C j :=\n  eqToIso (by subst h; rfl)\n\n"}
{"name":"CategoryTheory.Pi.evalCompEqToEquivalenceFunctor_hom","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\ni j : I\nh : Eq i j\n⊢ Eq (CategoryTheory.Pi.evalCompEqToEquivalenceFunctor C h).hom (CategoryTheory.eqToHom ⋯)","decl":"/-- When `i = j`, projections `Pi.eval C i` and `Pi.eval C j` are related by the equivalence\n`Pi.eqToEquivalence C h : C i ≌ C j`. -/\n@[simps!]\ndef Pi.evalCompEqToEquivalenceFunctor {i j : I} (h : i = j) :\n    Pi.eval C i ⋙ (Pi.eqToEquivalence C h).functor ≅\n      Pi.eval C j :=\n  eqToIso (by subst h; rfl)\n\n"}
{"name":"CategoryTheory.Pi.eqToEquivalenceFunctorIso_inv","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nJ : Type w₁\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nf : J → I\ni' j' : J\nh : Eq i' j'\n⊢ Eq (CategoryTheory.Pi.eqToEquivalenceFunctorIso C f h).inv (CategoryTheory.eqToHom ⋯)","decl":"/-- The equivalences given by `Pi.eqToEquivalence` are compatible with reindexing. -/\n@[simps!]\ndef Pi.eqToEquivalenceFunctorIso (f : J → I) {i' j' : J} (h : i' = j') :\n    (Pi.eqToEquivalence C (congr_arg f h)).functor ≅\n      (Pi.eqToEquivalence (fun i' => C (f i')) h).functor :=\n  eqToIso (by subst h; rfl)\n\n"}
{"name":"CategoryTheory.Pi.eqToEquivalenceFunctorIso_hom","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nJ : Type w₁\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nf : J → I\ni' j' : J\nh : Eq i' j'\n⊢ Eq (CategoryTheory.Pi.eqToEquivalenceFunctorIso C f h).hom (CategoryTheory.eqToHom ⋯)","decl":"/-- The equivalences given by `Pi.eqToEquivalence` are compatible with reindexing. -/\n@[simps!]\ndef Pi.eqToEquivalenceFunctorIso (f : J → I) {i' j' : J} (h : i' = j') :\n    (Pi.eqToEquivalence C (congr_arg f h)).functor ≅\n      (Pi.eqToEquivalence (fun i' => C (f i')) h).functor :=\n  eqToIso (by subst h; rfl)\n\n"}
{"name":"CategoryTheory.Pi.equivalenceOfEquiv_inverse","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nJ : Type w₁\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\ne : Equiv J I\n⊢ Eq (CategoryTheory.Pi.equivalenceOfEquiv C e).inverse (CategoryTheory.Functor.pi' fun i' => CategoryTheory.Pi.eval C (e i'))","decl":"/-- Reindexing a family of categories gives equivalent `Pi` categories. -/\n@[simps]\nnoncomputable def Pi.equivalenceOfEquiv (e : J ≃ I) :\n    (∀ j, C (e j)) ≌ (∀ i, C i) where\n  functor := Functor.pi' (fun i => Pi.eval _ (e.symm i) ⋙\n    (Pi.eqToEquivalence C (by simp)).functor)\n  inverse := Functor.pi' (fun i' => Pi.eval _ (e i'))\n  unitIso := NatIso.pi' (fun i' => Functor.leftUnitor _ ≪≫\n    (Pi.evalCompEqToEquivalenceFunctor (fun j => C (e j)) (e.symm_apply_apply i')).symm ≪≫\n    isoWhiskerLeft _ ((Pi.eqToEquivalenceFunctorIso C e (e.symm_apply_apply i')).symm) ≪≫\n    (Functor.pi'CompEval _ _).symm ≪≫ isoWhiskerLeft _ (Functor.pi'CompEval _ _).symm ≪≫\n    (Functor.associator _ _ _).symm)\n  counitIso := NatIso.pi' (fun i => (Functor.associator _ _ _).symm ≪≫\n    isoWhiskerRight (Functor.pi'CompEval _ _) _ ≪≫\n    Pi.evalCompEqToEquivalenceFunctor C (e.apply_symm_apply i) ≪≫\n    (Functor.leftUnitor _).symm)\n\n"}
{"name":"CategoryTheory.Pi.equivalenceOfEquiv_unitIso","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nJ : Type w₁\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\ne : Equiv J I\n⊢ Eq (CategoryTheory.Pi.equivalenceOfEquiv C e).unitIso (CategoryTheory.NatIso.pi' fun i' => (CategoryTheory.Pi.eval (fun i => C (e i)) i').leftUnitor.trans ((CategoryTheory.Pi.evalCompEqToEquivalenceFunctor (fun j => C (e j)) ⋯).symm.trans ((CategoryTheory.isoWhiskerLeft (CategoryTheory.Pi.eval (fun j => C (e j)) (e.symm (e i'))) (CategoryTheory.Pi.eqToEquivalenceFunctorIso C ⇑e ⋯).symm).trans ((CategoryTheory.Functor.pi'CompEval (CategoryTheory.Pi.eval (fun j => C (e j)) (e.symm (e i'))).comp (CategoryTheory.Pi.eqToEquivalence C ⋯).functor).symm.trans ((CategoryTheory.isoWhiskerLeft (CategoryTheory.Functor.pi' (CategoryTheory.Pi.eval (fun j => C (e j)) (e.symm (e i'))).comp) (CategoryTheory.Functor.pi'CompEval (CategoryTheory.Pi.eval fun i => C (e i')) (CategoryTheory.Pi.eqToEquivalence C ⋯).functor).symm).trans ((CategoryTheory.Functor.pi' (CategoryTheory.Pi.eval (fun j => C (e j)) (e.symm (e i'))).comp).associator (CategoryTheory.Functor.pi' (CategoryTheory.Pi.eval fun i => C (e i'))) (CategoryTheory.Pi.eval (fun i => C (e i')) (CategoryTheory.Pi.eqToEquivalence C ⋯).functor)).symm)))))","decl":"/-- Reindexing a family of categories gives equivalent `Pi` categories. -/\n@[simps]\nnoncomputable def Pi.equivalenceOfEquiv (e : J ≃ I) :\n    (∀ j, C (e j)) ≌ (∀ i, C i) where\n  functor := Functor.pi' (fun i => Pi.eval _ (e.symm i) ⋙\n    (Pi.eqToEquivalence C (by simp)).functor)\n  inverse := Functor.pi' (fun i' => Pi.eval _ (e i'))\n  unitIso := NatIso.pi' (fun i' => Functor.leftUnitor _ ≪≫\n    (Pi.evalCompEqToEquivalenceFunctor (fun j => C (e j)) (e.symm_apply_apply i')).symm ≪≫\n    isoWhiskerLeft _ ((Pi.eqToEquivalenceFunctorIso C e (e.symm_apply_apply i')).symm) ≪≫\n    (Functor.pi'CompEval _ _).symm ≪≫ isoWhiskerLeft _ (Functor.pi'CompEval _ _).symm ≪≫\n    (Functor.associator _ _ _).symm)\n  counitIso := NatIso.pi' (fun i => (Functor.associator _ _ _).symm ≪≫\n    isoWhiskerRight (Functor.pi'CompEval _ _) _ ≪≫\n    Pi.evalCompEqToEquivalenceFunctor C (e.apply_symm_apply i) ≪≫\n    (Functor.leftUnitor _).symm)\n\n"}
{"name":"CategoryTheory.Pi.equivalenceOfEquiv_counitIso","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nJ : Type w₁\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\ne : Equiv J I\n⊢ Eq (CategoryTheory.Pi.equivalenceOfEquiv C e).counitIso (CategoryTheory.NatIso.pi' fun i => ((CategoryTheory.Functor.pi' fun i' => CategoryTheory.Pi.eval C (e i')).associator (CategoryTheory.Pi.eval (fun j => C (e j)) (e.symm i)) (CategoryTheory.Pi.eqToEquivalence C ⋯).functor).symm.trans ((CategoryTheory.isoWhiskerRight (CategoryTheory.Functor.pi'CompEval (fun i' => CategoryTheory.Pi.eval C (e i')) (e.symm i)) (CategoryTheory.Pi.eqToEquivalence C ⋯).functor).trans ((CategoryTheory.Pi.evalCompEqToEquivalenceFunctor C ⋯).trans (CategoryTheory.Pi.eval C i).leftUnitor.symm)))","decl":"/-- Reindexing a family of categories gives equivalent `Pi` categories. -/\n@[simps]\nnoncomputable def Pi.equivalenceOfEquiv (e : J ≃ I) :\n    (∀ j, C (e j)) ≌ (∀ i, C i) where\n  functor := Functor.pi' (fun i => Pi.eval _ (e.symm i) ⋙\n    (Pi.eqToEquivalence C (by simp)).functor)\n  inverse := Functor.pi' (fun i' => Pi.eval _ (e i'))\n  unitIso := NatIso.pi' (fun i' => Functor.leftUnitor _ ≪≫\n    (Pi.evalCompEqToEquivalenceFunctor (fun j => C (e j)) (e.symm_apply_apply i')).symm ≪≫\n    isoWhiskerLeft _ ((Pi.eqToEquivalenceFunctorIso C e (e.symm_apply_apply i')).symm) ≪≫\n    (Functor.pi'CompEval _ _).symm ≪≫ isoWhiskerLeft _ (Functor.pi'CompEval _ _).symm ≪≫\n    (Functor.associator _ _ _).symm)\n  counitIso := NatIso.pi' (fun i => (Functor.associator _ _ _).symm ≪≫\n    isoWhiskerRight (Functor.pi'CompEval _ _) _ ≪≫\n    Pi.evalCompEqToEquivalenceFunctor C (e.apply_symm_apply i) ≪≫\n    (Functor.leftUnitor _).symm)\n\n"}
{"name":"CategoryTheory.Pi.equivalenceOfEquiv_functor","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nJ : Type w₁\nC : I → Type u₁\ninst✝ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\ne : Equiv J I\n⊢ Eq (CategoryTheory.Pi.equivalenceOfEquiv C e).functor (CategoryTheory.Functor.pi' fun i => (CategoryTheory.Pi.eval (fun j => C (e j)) (e.symm i)).comp (CategoryTheory.Pi.eqToEquivalence C ⋯).functor)","decl":"/-- Reindexing a family of categories gives equivalent `Pi` categories. -/\n@[simps]\nnoncomputable def Pi.equivalenceOfEquiv (e : J ≃ I) :\n    (∀ j, C (e j)) ≌ (∀ i, C i) where\n  functor := Functor.pi' (fun i => Pi.eval _ (e.symm i) ⋙\n    (Pi.eqToEquivalence C (by simp)).functor)\n  inverse := Functor.pi' (fun i' => Pi.eval _ (e i'))\n  unitIso := NatIso.pi' (fun i' => Functor.leftUnitor _ ≪≫\n    (Pi.evalCompEqToEquivalenceFunctor (fun j => C (e j)) (e.symm_apply_apply i')).symm ≪≫\n    isoWhiskerLeft _ ((Pi.eqToEquivalenceFunctorIso C e (e.symm_apply_apply i')).symm) ≪≫\n    (Functor.pi'CompEval _ _).symm ≪≫ isoWhiskerLeft _ (Functor.pi'CompEval _ _).symm ≪≫\n    (Functor.associator _ _ _).symm)\n  counitIso := NatIso.pi' (fun i => (Functor.associator _ _ _).symm ≪≫\n    isoWhiskerRight (Functor.pi'CompEval _ _) _ ≪≫\n    Pi.evalCompEqToEquivalenceFunctor C (e.apply_symm_apply i) ≪≫\n    (Functor.leftUnitor _).symm)\n\n"}
{"name":"CategoryTheory.Pi.optionEquivalence_functor","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"J : Type w₁\nC' : Option J → Type u₁\ninst✝ : (i : Option J) → CategoryTheory.Category.{v₁, u₁} (C' i)\n⊢ Eq (CategoryTheory.Pi.optionEquivalence C').functor ((CategoryTheory.Pi.eval C' Option.none).prod' (CategoryTheory.Functor.pi' fun i => CategoryTheory.Pi.eval C' (Option.some i)))","decl":"/-- A product of categories indexed by `Option J` identifies to a binary product. -/\n@[simps]\ndef Pi.optionEquivalence (C' : Option J → Type u₁) [∀ i, Category.{v₁} (C' i)] :\n    (∀ i, C' i) ≌ C' none × (∀ (j : J), C' (some j)) where\n  functor := Functor.prod' (Pi.eval C' none)\n    (Functor.pi' (fun i => (Pi.eval _ (some i))))\n  inverse := Functor.pi' (fun i => match i with\n    | none => Prod.fst _ _\n    | some i => Prod.snd _ _ ⋙ (Pi.eval _ i))\n  unitIso := NatIso.pi' (fun i => match i with\n    | none => Iso.refl _\n    | some _ => Iso.refl _)\n  counitIso := by exact Iso.refl _\n\n"}
{"name":"CategoryTheory.Pi.optionEquivalence_counitIso","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"J : Type w₁\nC' : Option J → Type u₁\ninst✝ : (i : Option J) → CategoryTheory.Category.{v₁, u₁} (C' i)\n⊢ Eq (CategoryTheory.Pi.optionEquivalence C').counitIso (CategoryTheory.Iso.refl ((CategoryTheory.Functor.pi' fun i => CategoryTheory.Pi.optionEquivalence.match_1 (fun i => CategoryTheory.Functor (Prod (C' Option.none) ((j : J) → C' (Option.some j))) (C' i)) i (fun _ => CategoryTheory.Prod.fst (C' Option.none) ((j : J) → C' (Option.some j))) fun i => (CategoryTheory.Prod.snd (C' Option.none) ((j : J) → C' (Option.some j))).comp (CategoryTheory.Pi.eval (fun j => C' (Option.some j)) i)).comp ((CategoryTheory.Pi.eval C' Option.none).prod' (CategoryTheory.Functor.pi' fun i => CategoryTheory.Pi.eval C' (Option.some i)))))","decl":"/-- A product of categories indexed by `Option J` identifies to a binary product. -/\n@[simps]\ndef Pi.optionEquivalence (C' : Option J → Type u₁) [∀ i, Category.{v₁} (C' i)] :\n    (∀ i, C' i) ≌ C' none × (∀ (j : J), C' (some j)) where\n  functor := Functor.prod' (Pi.eval C' none)\n    (Functor.pi' (fun i => (Pi.eval _ (some i))))\n  inverse := Functor.pi' (fun i => match i with\n    | none => Prod.fst _ _\n    | some i => Prod.snd _ _ ⋙ (Pi.eval _ i))\n  unitIso := NatIso.pi' (fun i => match i with\n    | none => Iso.refl _\n    | some _ => Iso.refl _)\n  counitIso := by exact Iso.refl _\n\n"}
{"name":"CategoryTheory.Pi.optionEquivalence_inverse","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"J : Type w₁\nC' : Option J → Type u₁\ninst✝ : (i : Option J) → CategoryTheory.Category.{v₁, u₁} (C' i)\n⊢ Eq (CategoryTheory.Pi.optionEquivalence C').inverse (CategoryTheory.Functor.pi' fun i => CategoryTheory.Pi.optionEquivalence.match_1 (fun i => CategoryTheory.Functor (Prod (C' Option.none) ((j : J) → C' (Option.some j))) (C' i)) i (fun _ => CategoryTheory.Prod.fst (C' Option.none) ((j : J) → C' (Option.some j))) fun i => (CategoryTheory.Prod.snd (C' Option.none) ((j : J) → C' (Option.some j))).comp (CategoryTheory.Pi.eval (fun j => C' (Option.some j)) i))","decl":"/-- A product of categories indexed by `Option J` identifies to a binary product. -/\n@[simps]\ndef Pi.optionEquivalence (C' : Option J → Type u₁) [∀ i, Category.{v₁} (C' i)] :\n    (∀ i, C' i) ≌ C' none × (∀ (j : J), C' (some j)) where\n  functor := Functor.prod' (Pi.eval C' none)\n    (Functor.pi' (fun i => (Pi.eval _ (some i))))\n  inverse := Functor.pi' (fun i => match i with\n    | none => Prod.fst _ _\n    | some i => Prod.snd _ _ ⋙ (Pi.eval _ i))\n  unitIso := NatIso.pi' (fun i => match i with\n    | none => Iso.refl _\n    | some _ => Iso.refl _)\n  counitIso := by exact Iso.refl _\n\n"}
{"name":"CategoryTheory.Pi.optionEquivalence_unitIso","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"J : Type w₁\nC' : Option J → Type u₁\ninst✝ : (i : Option J) → CategoryTheory.Category.{v₁, u₁} (C' i)\n⊢ Eq (CategoryTheory.Pi.optionEquivalence C').unitIso (CategoryTheory.NatIso.pi' fun i => CategoryTheory.Pi.optionEquivalence.match_1 (fun i => CategoryTheory.Iso ((CategoryTheory.Functor.id ((i : Option J) → C' i)).comp (CategoryTheory.Pi.eval C' i)) ((((CategoryTheory.Pi.eval C' Option.none).prod' (CategoryTheory.Functor.pi' fun i => CategoryTheory.Pi.eval C' (Option.some i))).comp (CategoryTheory.Functor.pi' fun i => CategoryTheory.Pi.optionEquivalence.match_1 (fun i => CategoryTheory.Functor (Prod (C' Option.none) ((j : J) → C' (Option.some j))) (C' i)) i (fun _ => CategoryTheory.Prod.fst (C' Option.none) ((j : J) → C' (Option.some j))) fun i => (CategoryTheory.Prod.snd (C' Option.none) ((j : J) → C' (Option.some j))).comp (CategoryTheory.Pi.eval (fun j => C' (Option.some j)) i))).comp (CategoryTheory.Pi.eval C' i))) i (fun _ => CategoryTheory.Iso.refl ((CategoryTheory.Functor.id ((i : Option J) → C' i)).comp (CategoryTheory.Pi.eval C' Option.none))) fun val => CategoryTheory.Iso.refl ((CategoryTheory.Functor.id ((i : Option J) → C' i)).comp (CategoryTheory.Pi.eval C' (Option.some val))))","decl":"/-- A product of categories indexed by `Option J` identifies to a binary product. -/\n@[simps]\ndef Pi.optionEquivalence (C' : Option J → Type u₁) [∀ i, Category.{v₁} (C' i)] :\n    (∀ i, C' i) ≌ C' none × (∀ (j : J), C' (some j)) where\n  functor := Functor.prod' (Pi.eval C' none)\n    (Functor.pi' (fun i => (Pi.eval _ (some i))))\n  inverse := Functor.pi' (fun i => match i with\n    | none => Prod.fst _ _\n    | some i => Prod.snd _ _ ⋙ (Pi.eval _ i))\n  unitIso := NatIso.pi' (fun i => match i with\n    | none => Iso.refl _\n    | some _ => Iso.refl _)\n  counitIso := by exact Iso.refl _\n\n"}
{"name":"CategoryTheory.Equivalence.pi_unitIso","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nD : I → Type u₂\ninst✝ : (i : I) → CategoryTheory.Category.{v₂, u₂} (D i)\nE : (i : I) → CategoryTheory.Equivalence (C i) (D i)\n⊢ Eq (CategoryTheory.Equivalence.pi E).unitIso (CategoryTheory.NatIso.pi fun i => (E i).unitIso)","decl":"/-- Assemble an `I`-indexed family of equivalences of categories\ninto a single equivalence. -/\n@[simps]\ndef pi (E : ∀ i, C i ≌ D i) : (∀ i, C i) ≌ (∀ i, D i) where\n  functor := Functor.pi (fun i => (E i).functor)\n  inverse := Functor.pi (fun i => (E i).inverse)\n  unitIso := NatIso.pi (fun i => (E i).unitIso)\n  counitIso := NatIso.pi (fun i => (E i).counitIso)\n\n"}
{"name":"CategoryTheory.Equivalence.pi_inverse","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nD : I → Type u₂\ninst✝ : (i : I) → CategoryTheory.Category.{v₂, u₂} (D i)\nE : (i : I) → CategoryTheory.Equivalence (C i) (D i)\n⊢ Eq (CategoryTheory.Equivalence.pi E).inverse (CategoryTheory.Functor.pi fun i => (E i).inverse)","decl":"/-- Assemble an `I`-indexed family of equivalences of categories\ninto a single equivalence. -/\n@[simps]\ndef pi (E : ∀ i, C i ≌ D i) : (∀ i, C i) ≌ (∀ i, D i) where\n  functor := Functor.pi (fun i => (E i).functor)\n  inverse := Functor.pi (fun i => (E i).inverse)\n  unitIso := NatIso.pi (fun i => (E i).unitIso)\n  counitIso := NatIso.pi (fun i => (E i).counitIso)\n\n"}
{"name":"CategoryTheory.Equivalence.pi_counitIso","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nD : I → Type u₂\ninst✝ : (i : I) → CategoryTheory.Category.{v₂, u₂} (D i)\nE : (i : I) → CategoryTheory.Equivalence (C i) (D i)\n⊢ Eq (CategoryTheory.Equivalence.pi E).counitIso (CategoryTheory.NatIso.pi fun i => (E i).counitIso)","decl":"/-- Assemble an `I`-indexed family of equivalences of categories\ninto a single equivalence. -/\n@[simps]\ndef pi (E : ∀ i, C i ≌ D i) : (∀ i, C i) ≌ (∀ i, D i) where\n  functor := Functor.pi (fun i => (E i).functor)\n  inverse := Functor.pi (fun i => (E i).inverse)\n  unitIso := NatIso.pi (fun i => (E i).unitIso)\n  counitIso := NatIso.pi (fun i => (E i).counitIso)\n\n"}
{"name":"CategoryTheory.Equivalence.pi_functor","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nD : I → Type u₂\ninst✝ : (i : I) → CategoryTheory.Category.{v₂, u₂} (D i)\nE : (i : I) → CategoryTheory.Equivalence (C i) (D i)\n⊢ Eq (CategoryTheory.Equivalence.pi E).functor (CategoryTheory.Functor.pi fun i => (E i).functor)","decl":"/-- Assemble an `I`-indexed family of equivalences of categories\ninto a single equivalence. -/\n@[simps]\ndef pi (E : ∀ i, C i ≌ D i) : (∀ i, C i) ≌ (∀ i, D i) where\n  functor := Functor.pi (fun i => (E i).functor)\n  inverse := Functor.pi (fun i => (E i).inverse)\n  unitIso := NatIso.pi (fun i => (E i).unitIso)\n  counitIso := NatIso.pi (fun i => (E i).counitIso)\n\n"}
{"name":"CategoryTheory.Equivalence.instIsEquivalenceForallPi","module":"Mathlib.CategoryTheory.Pi.Basic","initialProofState":"I : Type w₀\nC : I → Type u₁\ninst✝² : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nD : I → Type u₂\ninst✝¹ : (i : I) → CategoryTheory.Category.{v₂, u₂} (D i)\nF : (i : I) → CategoryTheory.Functor (C i) (D i)\ninst✝ : ∀ (i : I), (F i).IsEquivalence\n⊢ (CategoryTheory.Functor.pi F).IsEquivalence","decl":"instance (F : ∀ i, C i ⥤ D i) [∀ i, (F i).IsEquivalence] :\n    (Functor.pi F).IsEquivalence :=\n  (pi (fun i => (F i).asEquivalence)).isEquivalence_functor\n\n"}
