{"name":"LinearIndependent.linearIndependent_of_exact_of_retraction","module":"Mathlib.LinearAlgebra.Basis.Exact","initialProofState":"R : Type u_1\nM : Type u_2\nK : Type u_3\nP : Type u_4\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup K\ninst✝³ : AddCommGroup P\ninst✝² : Module R M\ninst✝¹ : Module R K\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) K M\ng : LinearMap (RingHom.id R) M P\ns : LinearMap (RingHom.id R) M K\nhs : Eq (s.comp f) LinearMap.id\nhfg : Function.Exact ⇑f ⇑g\nι : Type u_5\nκ : Type u_6\nv : ι → M\na : κ → ι\nhainj : Function.Injective a\nhsa : ∀ (i : κ), Eq (s (v (a i))) 0\nhli : LinearIndependent R v\n⊢ LinearIndependent R (Function.comp (⇑g) (Function.comp v a))","decl":"lemma LinearIndependent.linearIndependent_of_exact_of_retraction\n    (hainj : Function.Injective a) (hsa : ∀ i, s (v (a i)) = 0)\n    (hli : LinearIndependent R v) :\n    LinearIndependent R (g ∘ v ∘ a) := by\n  apply (LinearIndependent.comp hli a hainj).map\n  rw [Submodule.disjoint_def, hfg.linearMap_ker_eq]\n  rintro - hy ⟨y, rfl⟩\n  have hz : s (f y) = 0 := by\n    revert hy\n    generalize f y = x\n    intro hy\n    induction' hy using Submodule.span_induction with m hm\n    · obtain ⟨i, rfl⟩ := hm\n      apply hsa\n    all_goals simp_all\n  replace hs := DFunLike.congr_fun hs y\n  simp only [LinearMap.coe_comp, Function.comp_apply, LinearMap.id_coe, id_eq] at hs\n  rw [← hs, hz, map_zero]\n\n"}
{"name":"Submodule.top_le_span_of_exact_of_retraction","module":"Mathlib.LinearAlgebra.Basis.Exact","initialProofState":"R : Type u_1\nM : Type u_2\nK : Type u_3\nP : Type u_4\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup K\ninst✝³ : AddCommGroup P\ninst✝² : Module R M\ninst✝¹ : Module R K\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) K M\ng : LinearMap (RingHom.id R) M P\ns : LinearMap (RingHom.id R) M K\nhs : Eq (s.comp f) LinearMap.id\nhfg : Function.Exact ⇑f ⇑g\nι : Type u_5\nκ : Type u_6\nσ : Type u_7\nv : ι → M\na : κ → ι\nb : σ → ι\nhg : Function.Surjective ⇑g\nhsa : ∀ (i : κ), Eq (s (v (a i))) 0\nhlib : LinearIndependent R (Function.comp (⇑s) (Function.comp v b))\nhab : Codisjoint (Set.range a) (Set.range b)\nhsp : LE.le Top.top (Submodule.span R (Set.range v))\n⊢ LE.le Top.top (Submodule.span R (Set.range (Function.comp (⇑g) (Function.comp v a))))","decl":"lemma Submodule.top_le_span_of_exact_of_retraction (hg : Function.Surjective g)\n    (hsa : ∀ i, s (v (a i)) = 0) (hlib : LinearIndependent R (s ∘ v ∘ b))\n    (hab : Codisjoint (Set.range a) (Set.range b))\n    (hsp : ⊤ ≤ Submodule.span R (Set.range v)) :\n    ⊤ ≤ Submodule.span R (Set.range <| g ∘ v ∘ a) := by\n  apply top_le_span_of_aux hs hfg (Sum.elim (v ∘ a) (v ∘ b)) hg hsa hlib\n  simp only [codisjoint_iff, Set.sup_eq_union, Set.top_eq_univ] at hab\n  rwa [Set.Sum.elim_range, Set.range_comp, Set.range_comp, ← Set.image_union, hab, Set.image_univ]\n\n"}
