{"name":"Finset.sup_univ_eq_iSup","module":"Mathlib.Data.Fintype.Lattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Fintype α\ninst✝ : CompleteLattice β\nf : α → β\n⊢ Eq (Finset.univ.sup f) (iSup f)","decl":"/-- A special case of `Finset.sup_eq_iSup` that omits the useless `x ∈ univ` binder. -/\ntheorem sup_univ_eq_iSup [CompleteLattice β] (f : α → β) : Finset.univ.sup f = iSup f :=\n  (sup_eq_iSup _ f).trans <| congr_arg _ <| funext fun _ => iSup_pos (mem_univ _)\n\n"}
{"name":"Finset.inf_univ_eq_iInf","module":"Mathlib.Data.Fintype.Lattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Fintype α\ninst✝ : CompleteLattice β\nf : α → β\n⊢ Eq (Finset.univ.inf f) (iInf f)","decl":"/-- A special case of `Finset.inf_eq_iInf` that omits the useless `x ∈ univ` binder. -/\ntheorem inf_univ_eq_iInf [CompleteLattice β] (f : α → β) : Finset.univ.inf f = iInf f :=\n  @sup_univ_eq_iSup _ βᵒᵈ _ _ (f : α → βᵒᵈ)\n\n"}
{"name":"Finset.fold_inf_univ","module":"Mathlib.Data.Fintype.Lattice","initialProofState":"α : Type u_2\ninst✝² : Fintype α\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderBot α\na : α\n⊢ Eq (Finset.fold (fun x1 x2 => Min.min x1 x2) a (fun x => x) Finset.univ) Bot.bot","decl":"@[simp]\ntheorem fold_inf_univ [SemilatticeInf α] [OrderBot α] (a : α) :\n    -- Porting note: added `haveI`\n    haveI : Std.Commutative (α := α) (· ⊓ ·) := inferInstance\n    (Finset.univ.fold (· ⊓ ·) a fun x => x) = ⊥ :=\n  eq_bot_iff.2 <|\n    ((Finset.fold_op_rel_iff_and <| @le_inf_iff α _).1 le_rfl).2 ⊥ <| Finset.mem_univ _\n\n"}
{"name":"Finset.fold_sup_univ","module":"Mathlib.Data.Fintype.Lattice","initialProofState":"α : Type u_2\ninst✝² : Fintype α\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderTop α\na : α\n⊢ Eq (Finset.fold (fun x1 x2 => Max.max x1 x2) a (fun x => x) Finset.univ) Top.top","decl":"@[simp]\ntheorem fold_sup_univ [SemilatticeSup α] [OrderTop α] (a : α) :\n    -- Porting note: added `haveI`\n    haveI : Std.Commutative (α := α) (· ⊔ ·) := inferInstance\n    (Finset.univ.fold (· ⊔ ·) a fun x => x) = ⊤ :=\n  @fold_inf_univ αᵒᵈ _ _ _ _\n\n"}
{"name":"Finset.mem_inf","module":"Mathlib.Data.Fintype.Lattice","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ns : Finset ι\nf : ι → Finset α\na : α\n⊢ Iff (Membership.mem (s.inf f) a) (∀ (i : ι), Membership.mem s i → Membership.mem (f i) a)","decl":"lemma mem_inf [DecidableEq α] {s : Finset ι} {f : ι → Finset α} {a : α} :\n    a ∈ s.inf f ↔ ∀ i ∈ s, a ∈ f i := by induction' s using Finset.cons_induction <;> simp [*]\n\n"}
{"name":"Finite.exists_max","module":"Mathlib.Data.Fintype.Lattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Finite α\ninst✝¹ : Nonempty α\ninst✝ : LinearOrder β\nf : α → β\n⊢ Exists fun x₀ => ∀ (x : α), LE.le (f x) (f x₀)","decl":"theorem Finite.exists_max [Finite α] [Nonempty α] [LinearOrder β] (f : α → β) :\n    ∃ x₀ : α, ∀ x, f x ≤ f x₀ := by\n  cases nonempty_fintype α\n  simpa using exists_max_image univ f univ_nonempty\n\n"}
{"name":"Finite.exists_min","module":"Mathlib.Data.Fintype.Lattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Finite α\ninst✝¹ : Nonempty α\ninst✝ : LinearOrder β\nf : α → β\n⊢ Exists fun x₀ => ∀ (x : α), LE.le (f x₀) (f x)","decl":"theorem Finite.exists_min [Finite α] [Nonempty α] [LinearOrder β] (f : α → β) :\n    ∃ x₀ : α, ∀ x, f x₀ ≤ f x := by\n  cases nonempty_fintype α\n  simpa using exists_min_image univ f univ_nonempty\n"}
