{"name":"IsHausdorff.haus'","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nself : IsHausdorff I M\nx : M\na✝ : ∀ (n : Nat), SModEq (HSMul.hSMul (HPow.hPow I n) Top.top) x 0\n⊢ Eq x 0","decl":"/-- A module `M` is Hausdorff with respect to an ideal `I` if `⋂ I^n M = 0`. -/\nclass IsHausdorff : Prop where\n  haus' : ∀ x : M, (∀ n : ℕ, x ≡ 0 [SMOD (I ^ n • ⊤ : Submodule R M)]) → x = 0\n\n"}
{"name":"IsPrecomplete.prec'","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nself : IsPrecomplete I M\nf : Nat → M\na✝ : ∀ {m n : Nat}, LE.le m n → SModEq (HSMul.hSMul (HPow.hPow I m) Top.top) (f m) (f n)\n⊢ Exists fun L => ∀ (n : Nat), SModEq (HSMul.hSMul (HPow.hPow I n) Top.top) (f n) L","decl":"/-- A module `M` is precomplete with respect to an ideal `I` if every Cauchy sequence converges. -/\nclass IsPrecomplete : Prop where\n  prec' : ∀ f : ℕ → M, (∀ {m n}, m ≤ n → f m ≡ f n [SMOD (I ^ m • ⊤ : Submodule R M)]) →\n    ∃ L : M, ∀ n, f n ≡ L [SMOD (I ^ n • ⊤ : Submodule R M)]\n\n"}
{"name":"IsAdicComplete.toIsPrecomplete","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nself : IsAdicComplete I M\n⊢ IsPrecomplete I M","decl":"/-- A module `M` is `I`-adically complete if it is Hausdorff and precomplete. -/\nclass IsAdicComplete extends IsHausdorff I M, IsPrecomplete I M : Prop\n\n"}
{"name":"IsAdicComplete.toIsHausdorff","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nself : IsAdicComplete I M\n⊢ IsHausdorff I M","decl":"/-- A module `M` is `I`-adically complete if it is Hausdorff and precomplete. -/\nclass IsAdicComplete extends IsHausdorff I M, IsPrecomplete I M : Prop\n\n"}
{"name":"IsHausdorff.haus","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx✝ : IsHausdorff I M\nx : M\na✝ : ∀ (n : Nat), SModEq (HSMul.hSMul (HPow.hPow I n) Top.top) x 0\n⊢ Eq x 0","decl":"theorem IsHausdorff.haus (_ : IsHausdorff I M) :\n    ∀ x : M, (∀ n : ℕ, x ≡ 0 [SMOD (I ^ n • ⊤ : Submodule R M)]) → x = 0 :=\n  IsHausdorff.haus'\n\n"}
{"name":"isHausdorff_iff","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (IsHausdorff I M) (∀ (x : M), (∀ (n : Nat), SModEq (HSMul.hSMul (HPow.hPow I n) Top.top) x 0) → Eq x 0)","decl":"theorem isHausdorff_iff :\n    IsHausdorff I M ↔ ∀ x : M, (∀ n : ℕ, x ≡ 0 [SMOD (I ^ n • ⊤ : Submodule R M)]) → x = 0 :=\n  ⟨IsHausdorff.haus, fun h => ⟨h⟩⟩\n\n"}
{"name":"IsPrecomplete.prec","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx✝ : IsPrecomplete I M\nf : Nat → M\na✝ : ∀ {m n : Nat}, LE.le m n → SModEq (HSMul.hSMul (HPow.hPow I m) Top.top) (f m) (f n)\n⊢ Exists fun L => ∀ (n : Nat), SModEq (HSMul.hSMul (HPow.hPow I n) Top.top) (f n) L","decl":"theorem IsPrecomplete.prec (_ : IsPrecomplete I M) {f : ℕ → M} :\n    (∀ {m n}, m ≤ n → f m ≡ f n [SMOD (I ^ m • ⊤ : Submodule R M)]) →\n      ∃ L : M, ∀ n, f n ≡ L [SMOD (I ^ n • ⊤ : Submodule R M)] :=\n  IsPrecomplete.prec' _\n\n"}
{"name":"isPrecomplete_iff","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (IsPrecomplete I M) (∀ (f : Nat → M), (∀ {m n : Nat}, LE.le m n → SModEq (HSMul.hSMul (HPow.hPow I m) Top.top) (f m) (f n)) → Exists fun L => ∀ (n : Nat), SModEq (HSMul.hSMul (HPow.hPow I n) Top.top) (f n) L)","decl":"theorem isPrecomplete_iff :\n    IsPrecomplete I M ↔\n      ∀ f : ℕ → M,\n        (∀ {m n}, m ≤ n → f m ≡ f n [SMOD (I ^ m • ⊤ : Submodule R M)]) →\n          ∃ L : M, ∀ n, f n ≡ L [SMOD (I ^ n • ⊤ : Submodule R M)] :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n\n"}
{"name":"IsHausdorff.bot","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ IsHausdorff Bot.bot M","decl":"instance bot : IsHausdorff (⊥ : Ideal R) M :=\n  ⟨fun x hx => by simpa only [pow_one ⊥, bot_smul, SModEq.bot] using hx 1⟩\n\n"}
{"name":"IsHausdorff.subsingleton","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nh : IsHausdorff Top.top M\n⊢ Subsingleton M","decl":"protected theorem subsingleton (h : IsHausdorff (⊤ : Ideal R) M) : Subsingleton M :=\n  ⟨fun x y => eq_of_sub_eq_zero <| h.haus (x - y) fun n => by\n    rw [Ideal.top_pow, top_smul]\n    exact SModEq.top⟩\n\n"}
{"name":"IsHausdorff.of_subsingleton","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Subsingleton M\n⊢ IsHausdorff I M","decl":"instance (priority := 100) of_subsingleton [Subsingleton M] : IsHausdorff I M :=\n  ⟨fun _ _ => Subsingleton.elim _ _⟩\n\n"}
{"name":"IsHausdorff.iInf_pow_smul","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nh : IsHausdorff I M\n⊢ Eq (iInf fun n => HSMul.hSMul (HPow.hPow I n) Top.top) Bot.bot","decl":"theorem iInf_pow_smul (h : IsHausdorff I M) : (⨅ n : ℕ, I ^ n • ⊤ : Submodule R M) = ⊥ :=\n  eq_bot_iff.2 fun x hx =>\n    (mem_bot _).2 <| h.haus x fun n => SModEq.zero.2 <| (mem_iInf fun n : ℕ => I ^ n • ⊤).1 hx n\n\n"}
{"name":"Hausdorffification.induction_on","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nC : Hausdorffification I M → Prop\nx : Hausdorffification I M\nih : ∀ (x : M), C ((Hausdorffification.of I M) x)\n⊢ C x","decl":"@[elab_as_elim]\ntheorem induction_on {C : Hausdorffification I M → Prop} (x : Hausdorffification I M)\n    (ih : ∀ x, C (of I M x)) : C x :=\n  Quotient.inductionOn' x ih\n\n"}
{"name":"Hausdorffification.instIsHausdorff","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ IsHausdorff I (Hausdorffification I M)","decl":"instance : IsHausdorff I (Hausdorffification I M) :=\n  ⟨fun x => Quotient.inductionOn' x fun x hx =>\n    (Quotient.mk_eq_zero _).2 <| (mem_iInf _).2 fun n => by\n      have := comap_map_mkQ (⨅ n : ℕ, I ^ n • ⊤ : Submodule R M) (I ^ n • ⊤)\n      simp only [sup_of_le_right (iInf_le (fun n => (I ^ n • ⊤ : Submodule R M)) n)] at this\n      rw [← this, map_smul'', mem_comap, Submodule.map_top, range_mkQ, ← SModEq.zero]\n      exact hx n⟩\n\n"}
{"name":"Hausdorffification.lift_of","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_5\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nh : IsHausdorff I N\nf : LinearMap (RingHom.id R) M N\nx : M\n⊢ Eq ((Hausdorffification.lift I f) ((Hausdorffification.of I M) x)) (f x)","decl":"theorem lift_of (f : M →ₗ[R] N) (x : M) : lift I f (of I M x) = f x :=\n  rfl\n\n"}
{"name":"Hausdorffification.lift_comp_of","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_5\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nh : IsHausdorff I N\nf : LinearMap (RingHom.id R) M N\n⊢ Eq ((Hausdorffification.lift I f).comp (Hausdorffification.of I M)) f","decl":"theorem lift_comp_of (f : M →ₗ[R] N) : (lift I f).comp (of I M) = f :=\n  LinearMap.ext fun _ => rfl\n\n"}
{"name":"Hausdorffification.lift_eq","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_5\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nh : IsHausdorff I N\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) (Hausdorffification I M) N\nhg : Eq (g.comp (Hausdorffification.of I M)) f\n⊢ Eq g (Hausdorffification.lift I f)","decl":"/-- Uniqueness of lift. -/\ntheorem lift_eq (f : M →ₗ[R] N) (g : Hausdorffification I M →ₗ[R] N) (hg : g.comp (of I M) = f) :\n    g = lift I f :=\n  LinearMap.ext fun x => induction_on x fun x => by rw [lift_of, ← hg, LinearMap.comp_apply]\n\n"}
{"name":"IsPrecomplete.bot","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ IsPrecomplete Bot.bot M","decl":"instance bot : IsPrecomplete (⊥ : Ideal R) M := by\n  refine ⟨fun f hf => ⟨f 1, fun n => ?_⟩⟩\n  cases' n with n\n  · rw [pow_zero, Ideal.one_eq_top, top_smul]\n    exact SModEq.top\n  specialize hf (Nat.le_add_left 1 n)\n  rw [pow_one, bot_smul, SModEq.bot] at hf; rw [hf]\n\n"}
{"name":"IsPrecomplete.top","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ IsPrecomplete Top.top M","decl":"instance top : IsPrecomplete (⊤ : Ideal R) M :=\n  ⟨fun f _ =>\n    ⟨0, fun n => by\n      rw [Ideal.top_pow, top_smul]\n      exact SModEq.top⟩⟩\n\n"}
{"name":"IsPrecomplete.of_subsingleton","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Subsingleton M\n⊢ IsPrecomplete I M","decl":"instance (priority := 100) of_subsingleton [Subsingleton M] : IsPrecomplete I M :=\n  ⟨fun f _ => ⟨0, fun n => by rw [Subsingleton.elim (f n) 0]⟩⟩\n\n"}
{"name":"AdicCompletion.val_zero","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast] lemma val_zero : (0 : AdicCompletion I M).val = 0 := rfl\n\n"}
{"name":"AdicCompletion.val_zero_apply","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\n⊢ Eq (↑0 n) 0","decl":"lemma val_zero_apply (n : ℕ) : (0 : AdicCompletion I M).val n = 0 := rfl\n\n"}
{"name":"AdicCompletion.val_add","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf g : AdicCompletion I M\n⊢ Eq (↑(HAdd.hAdd f g)) (HAdd.hAdd ↑f ↑g)","decl":"@[simp, norm_cast] lemma val_add (f g : AdicCompletion I M) : (f + g).val = f.val + g.val := rfl\n"}
{"name":"AdicCompletion.val_sub","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf g : AdicCompletion I M\n⊢ Eq (↑(HSub.hSub f g)) (HSub.hSub ↑f ↑g)","decl":"@[simp, norm_cast] lemma val_sub (f g : AdicCompletion I M) : (f - g).val = f.val - g.val := rfl\n"}
{"name":"AdicCompletion.val_neg","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : AdicCompletion I M\n⊢ Eq (↑(Neg.neg f)) (Neg.neg ↑f)","decl":"@[simp, norm_cast] lemma val_neg (f : AdicCompletion I M) : (-f).val = -f.val := rfl\n\n"}
{"name":"AdicCompletion.val_add_apply","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf g : AdicCompletion I M\nn : Nat\n⊢ Eq (↑(HAdd.hAdd f g) n) (HAdd.hAdd (↑f n) (↑g n))","decl":"lemma val_add_apply (f g : AdicCompletion I M) (n : ℕ) : (f + g).val n = f.val n + g.val n := rfl\n"}
{"name":"AdicCompletion.val_sub_apply","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf g : AdicCompletion I M\nn : Nat\n⊢ Eq (↑(HSub.hSub f g) n) (HSub.hSub (↑f n) (↑g n))","decl":"lemma val_sub_apply (f g : AdicCompletion I M) (n : ℕ) : (f - g).val n = f.val n - g.val n := rfl\n"}
{"name":"AdicCompletion.val_neg_apply","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : AdicCompletion I M\nn : Nat\n⊢ Eq (↑(Neg.neg f) n) (Neg.neg (↑f n))","decl":"lemma val_neg_apply (f : AdicCompletion I M) (n : ℕ) : (-f).val n = -f.val n := rfl\n\n/- No `simp` attribute, since it causes `simp` unification timeouts when considering\nthe `Module (AdicCompletion I R) (AdicCompletion I M)` instance (see `AdicCompletion/Algebra`). -/\n"}
{"name":"AdicCompletion.val_smul","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁵ : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : SMul S R\ninst✝¹ : SMul S M\ninst✝ : IsScalarTower S R M\ns : S\nf : AdicCompletion I M\n⊢ Eq (↑(HSMul.hSMul s f)) (HSMul.hSMul s ↑f)","decl":"@[norm_cast]\nlemma val_smul [SMul S R] [SMul S M] [IsScalarTower S R M] (s : S) (f : AdicCompletion I M) :\n    (s • f).val = s • f.val := rfl\n\n"}
{"name":"AdicCompletion.val_smul_apply","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁵ : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : SMul S R\ninst✝¹ : SMul S M\ninst✝ : IsScalarTower S R M\ns : S\nf : AdicCompletion I M\nn : Nat\n⊢ Eq (↑(HSMul.hSMul s f) n) (HSMul.hSMul s (↑f n))","decl":"lemma val_smul_apply [SMul S R] [SMul S M] [IsScalarTower S R M] (s : S) (f : AdicCompletion I M)\n    (n : ℕ) : (s • f).val n = s • f.val n := rfl\n\n"}
{"name":"AdicCompletion.ext","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : AdicCompletion I M\nh : ∀ (n : Nat), Eq (↑x n) (↑y n)\n⊢ Eq x y","decl":"@[ext]\nlemma ext {x y : AdicCompletion I M} (h : ∀ n, x.val n = y.val n) : x = y := Subtype.eq <| funext h\n\n"}
{"name":"AdicCompletion.ext_iff","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : AdicCompletion I M\n⊢ Iff (Eq x y) (∀ (n : Nat), Eq (↑x n) (↑y n))","decl":"@[ext]\nlemma ext {x y : AdicCompletion I M} (h : ∀ n, x.val n = y.val n) : x = y := Subtype.eq <| funext h\n\n"}
{"name":"AdicCompletion.instIsScalarTower","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝¹⁰ : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝⁹ : AddCommGroup M\ninst✝⁸ : Module R M\ninst✝⁷ : SMul S T\ninst✝⁶ : SMul S R\ninst✝⁵ : SMul T R\ninst✝⁴ : SMul S M\ninst✝³ : SMul T M\ninst✝² : IsScalarTower S R M\ninst✝¹ : IsScalarTower T R M\ninst✝ : IsScalarTower S T M\n⊢ IsScalarTower S T (AdicCompletion I M)","decl":"instance instIsScalarTower [SMul S T] [SMul S R] [SMul T R] [SMul S M] [SMul T M]\n    [IsScalarTower S R M] [IsScalarTower T R M] [IsScalarTower S T M] :\n    IsScalarTower S T (AdicCompletion I M) where\n  smul_assoc s t f := by ext; simp [val_smul]\n\n"}
{"name":"AdicCompletion.instSMulCommClass","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝⁹ : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : SMul S R\ninst✝⁵ : SMul T R\ninst✝⁴ : SMul S M\ninst✝³ : SMul T M\ninst✝² : IsScalarTower S R M\ninst✝¹ : IsScalarTower T R M\ninst✝ : SMulCommClass S T M\n⊢ SMulCommClass S T (AdicCompletion I M)","decl":"instance instSMulCommClass [SMul S R] [SMul T R] [SMul S M] [SMul T M]\n    [IsScalarTower S R M] [IsScalarTower T R M] [SMulCommClass S T M] :\n    SMulCommClass S T (AdicCompletion I M) where\n  smul_comm s t f := by ext; simp [val_smul, smul_comm]\n\n"}
{"name":"AdicCompletion.instIsCentralScalar","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁹ : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : SMul S R\ninst✝⁵ : SMul (MulOpposite S) R\ninst✝⁴ : SMul S M\ninst✝³ : SMul (MulOpposite S) M\ninst✝² : IsScalarTower S R M\ninst✝¹ : IsScalarTower (MulOpposite S) R M\ninst✝ : IsCentralScalar S M\n⊢ IsCentralScalar S (AdicCompletion I M)","decl":"instance instIsCentralScalar [SMul S R] [SMul Sᵐᵒᵖ R] [SMul S M] [SMul Sᵐᵒᵖ M]\n    [IsScalarTower S R M] [IsScalarTower Sᵐᵒᵖ R M] [IsCentralScalar S M] :\n    IsCentralScalar S (AdicCompletion I M) where\n  op_smul_eq_smul s f := by ext; simp [val_smul, op_smul_eq_smul]\n\n"}
{"name":"AdicCompletion.incl_apply","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : AdicCompletion I M\nn : Nat\n⊢ Eq ((AdicCompletion.incl I M) x n) (↑x n)","decl":"/-- The canonical inclusion from the completion to the product. -/\n@[simps]\ndef incl : AdicCompletion I M →ₗ[R] (∀ n, M ⧸ (I ^ n • ⊤ : Submodule R M)) where\n  toFun x := x.val\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\n"}
{"name":"AdicCompletion.val_sum","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nι : Type u_6\ns : Finset ι\nf : ι → AdicCompletion I M\n⊢ Eq (↑(s.sum fun i => f i)) (s.sum fun i => ↑(f i))","decl":"@[simp, norm_cast]\nlemma val_sum {ι : Type*} (s : Finset ι) (f : ι → AdicCompletion I M) :\n    (∑ i ∈ s, f i).val = ∑ i ∈ s, (f i).val := by\n  simp_rw [← funext (incl_apply _ _ _), map_sum]\n\n"}
{"name":"AdicCompletion.val_sum_apply","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nι : Type u_6\ns : Finset ι\nf : ι → AdicCompletion I M\nn : Nat\n⊢ Eq (↑(s.sum fun i => f i) n) (s.sum fun i => ↑(f i) n)","decl":"lemma val_sum_apply {ι : Type*} (s : Finset ι) (f : ι → AdicCompletion I M) (n : ℕ) :\n    (∑ i ∈ s, f i).val n = ∑ i ∈ s, (f i).val n := by simp\n\n"}
{"name":"AdicCompletion.of_apply","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : M\nn : Nat\n⊢ Eq (↑((AdicCompletion.of I M) x) n) ((HSMul.hSMul (HPow.hPow I n) Top.top).mkQ x)","decl":"@[simp]\ntheorem of_apply (x : M) (n : ℕ) : (of I M x).1 n = mkQ (I ^ n • ⊤ : Submodule R M) x :=\n  rfl\n\n"}
{"name":"AdicCompletion.coe_eval","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\n⊢ Eq ⇑(AdicCompletion.eval I M n) fun f => ↑f n","decl":"@[simp]\ntheorem coe_eval (n : ℕ) :\n    (eval I M n : AdicCompletion I M → M ⧸ (I ^ n • ⊤ : Submodule R M)) = fun f => f.1 n :=\n  rfl\n\n"}
{"name":"AdicCompletion.eval_apply","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nf : AdicCompletion I M\n⊢ Eq ((AdicCompletion.eval I M n) f) (↑f n)","decl":"theorem eval_apply (n : ℕ) (f : AdicCompletion I M) : eval I M n f = f.1 n :=\n  rfl\n\n"}
{"name":"AdicCompletion.eval_of","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nx : M\n⊢ Eq ((AdicCompletion.eval I M n) ((AdicCompletion.of I M) x)) ((HSMul.hSMul (HPow.hPow I n) Top.top).mkQ x)","decl":"theorem eval_of (n : ℕ) (x : M) : eval I M n (of I M x) = mkQ (I ^ n • ⊤ : Submodule R M) x :=\n  rfl\n\n"}
{"name":"AdicCompletion.eval_comp_of","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\n⊢ Eq ((AdicCompletion.eval I M n).comp (AdicCompletion.of I M)) (HSMul.hSMul (HPow.hPow I n) Top.top).mkQ","decl":"@[simp]\ntheorem eval_comp_of (n : ℕ) : (eval I M n).comp (of I M) = mkQ _ :=\n  rfl\n\n"}
{"name":"AdicCompletion.eval_surjective","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\n⊢ Function.Surjective ⇑(AdicCompletion.eval I M n)","decl":"theorem eval_surjective (n : ℕ) : Function.Surjective (eval I M n) := fun x ↦\n  Quotient.inductionOn' x fun x ↦ ⟨of I M x, rfl⟩\n\n"}
{"name":"AdicCompletion.range_eval","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\n⊢ Eq (LinearMap.range (AdicCompletion.eval I M n)) Top.top","decl":"@[simp]\ntheorem range_eval (n : ℕ) : LinearMap.range (eval I M n) = ⊤ :=\n  LinearMap.range_eq_top.2 (eval_surjective I M n)\n\n"}
{"name":"AdicCompletion.instIsHausdorff","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ IsHausdorff I (AdicCompletion I M)","decl":"instance : IsHausdorff I (AdicCompletion I M) where\n  haus' x h := ext fun n ↦ by\n    refine smul_induction_on (SModEq.zero.1 <| h n) (fun r hr x _ ↦ ?_) (fun x y hx hy ↦ ?_)\n    · simp only [val_smul_apply, val_zero]\n      exact Quotient.inductionOn' (x.val n)\n        (fun a ↦ SModEq.zero.2 <| smul_mem_smul hr mem_top)\n    · simp only [val_add_apply, hx, val_zero_apply, hy, add_zero]\n\n"}
{"name":"AdicCompletion.transitionMap_mk","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nm n : Nat\nhmn : LE.le m n\nx : M\n⊢ Eq ((AdicCompletion.transitionMap I M hmn) (Submodule.Quotient.mk x)) (Submodule.Quotient.mk x)","decl":"@[simp]\ntheorem transitionMap_mk {m n : ℕ} (hmn : m ≤ n) (x : M) :\n    transitionMap I M hmn\n      (Submodule.Quotient.mk (p := (I ^ n • ⊤ : Submodule R M)) x) =\n      Submodule.Quotient.mk (p := (I ^ m • ⊤ : Submodule R M)) x := by\n  rfl\n\n"}
{"name":"AdicCompletion.transitionMap_eq","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\n⊢ Eq (AdicCompletion.transitionMap I M ⋯) LinearMap.id","decl":"@[simp]\ntheorem transitionMap_eq (n : ℕ) : transitionMap I M (Nat.le_refl n) = LinearMap.id := by\n  ext\n  simp\n\n"}
{"name":"AdicCompletion.transitionMap_comp","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nm n k : Nat\nhmn : LE.le m n\nhnk : LE.le n k\n⊢ Eq ((AdicCompletion.transitionMap I M hmn).comp (AdicCompletion.transitionMap I M hnk)) (AdicCompletion.transitionMap I M ⋯)","decl":"@[simp]\ntheorem transitionMap_comp {m n k : ℕ} (hmn : m ≤ n) (hnk : n ≤ k) :\n    transitionMap I M hmn ∘ₗ transitionMap I M hnk = transitionMap I M (hmn.trans hnk) := by\n  ext\n  simp\n\n"}
{"name":"AdicCompletion.transitionMap_comp_apply","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nm n k : Nat\nhmn : LE.le m n\nhnk : LE.le n k\nx : HasQuotient.Quotient M (HSMul.hSMul (HPow.hPow I k) Top.top)\n⊢ Eq ((AdicCompletion.transitionMap I M hmn) ((AdicCompletion.transitionMap I M hnk) x)) ((AdicCompletion.transitionMap I M ⋯) x)","decl":"@[simp]\ntheorem transitionMap_comp_apply {m n k : ℕ} (hmn : m ≤ n) (hnk : n ≤ k)\n    (x : M ⧸ (I ^ k • ⊤ : Submodule R M)) :\n    transitionMap I M hmn (transitionMap I M hnk x) = transitionMap I M (hmn.trans hnk) x := by\n  change (transitionMap I M hmn ∘ₗ transitionMap I M hnk) x = transitionMap I M (hmn.trans hnk) x\n  simp\n\n"}
{"name":"AdicCompletion.transitionMap_comp_eval_apply","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nm n : Nat\nhmn : LE.le m n\nx : AdicCompletion I M\n⊢ Eq ((AdicCompletion.transitionMap I M hmn) (↑x n)) (↑x m)","decl":"@[simp]\ntheorem transitionMap_comp_eval_apply {m n : ℕ} (hmn : m ≤ n) (x : AdicCompletion I M) :\n    transitionMap I M hmn (x.val n) = x.val m :=\n  x.property hmn\n\n"}
{"name":"AdicCompletion.transitionMap_comp_eval","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nm n : Nat\nhmn : LE.le m n\n⊢ Eq ((AdicCompletion.transitionMap I M hmn).comp (AdicCompletion.eval I M n)) (AdicCompletion.eval I M m)","decl":"@[simp]\ntheorem transitionMap_comp_eval {m n : ℕ} (hmn : m ≤ n) :\n    transitionMap I M hmn ∘ₗ eval I M n = eval I M m := by\n  ext x\n  simp\n\n"}
{"name":"AdicCompletion.AdicCauchySequence.zero_apply","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\n⊢ Eq (↑0 n) 0","decl":"@[simp]\ntheorem zero_apply (n : ℕ) : (0 : AdicCauchySequence I M) n = 0 :=\n  rfl\n\n"}
{"name":"AdicCompletion.AdicCauchySequence.add_apply","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nf g : AdicCompletion.AdicCauchySequence I M\n⊢ Eq (↑(HAdd.hAdd f g) n) (HAdd.hAdd (↑f n) (↑g n))","decl":"@[simp]\ntheorem add_apply (n : ℕ) (f g : AdicCauchySequence I M) : (f + g) n = f n + g n :=\n  rfl\n\n"}
{"name":"AdicCompletion.AdicCauchySequence.sub_apply","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nf g : AdicCompletion.AdicCauchySequence I M\n⊢ Eq (↑(HSub.hSub f g) n) (HSub.hSub (↑f n) (↑g n))","decl":"@[simp]\ntheorem sub_apply (n : ℕ) (f g : AdicCauchySequence I M) : (f - g) n = f n - g n :=\n  rfl\n\n"}
{"name":"AdicCompletion.AdicCauchySequence.smul_apply","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nr : R\nf : AdicCompletion.AdicCauchySequence I M\n⊢ Eq (↑(HSMul.hSMul r f) n) (HSMul.hSMul r (↑f n))","decl":"@[simp]\ntheorem smul_apply (n : ℕ) (r : R) (f : AdicCauchySequence I M) : (r • f) n = r • f n :=\n  rfl\n\n"}
{"name":"AdicCompletion.AdicCauchySequence.ext","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : AdicCompletion.AdicCauchySequence I M\nh : ∀ (n : Nat), Eq (↑x n) (↑y n)\n⊢ Eq x y","decl":"@[ext]\ntheorem ext {x y : AdicCauchySequence I M} (h : ∀ n, x n = y n) : x = y :=\n  Subtype.eq <| funext h\n\n"}
{"name":"AdicCompletion.AdicCauchySequence.ext_iff","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : AdicCompletion.AdicCauchySequence I M\n⊢ Iff (Eq x y) (∀ (n : Nat), Eq (↑x n) (↑y n))","decl":"@[ext]\ntheorem ext {x y : AdicCauchySequence I M} (h : ∀ n, x n = y n) : x = y :=\n  Subtype.eq <| funext h\n\n"}
{"name":"AdicCompletion.AdicCauchySequence.mk_eq_mk","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nm n : Nat\nhmn : LE.le m n\nf : AdicCompletion.AdicCauchySequence I M\n⊢ Eq (Submodule.Quotient.mk (↑f n)) (Submodule.Quotient.mk (↑f m))","decl":"/-- The defining property of an adic cauchy sequence unwrapped. -/\ntheorem mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (f : AdicCauchySequence I M) :\n    Submodule.Quotient.mk (p := (I ^ m • ⊤ : Submodule R M)) (f n) =\n      Submodule.Quotient.mk (p := (I ^ m • ⊤ : Submodule R M)) (f m) :=\n  (f.property hmn).symm\n\n"}
{"name":"AdicCompletion.isAdicCauchy_iff","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Nat → M\n⊢ Iff (AdicCompletion.IsAdicCauchy I M f) (∀ (n : Nat), SModEq (HSMul.hSMul (HPow.hPow I n) Top.top) (f n) (f (HAdd.hAdd n 1)))","decl":"/-- The `I`-adic cauchy condition can be checked on successive `n`.-/\ntheorem isAdicCauchy_iff (f : ℕ → M) :\n    IsAdicCauchy I M f ↔ ∀ n, f n ≡ f (n + 1) [SMOD (I ^ n • ⊤ : Submodule R M)] := by\n  constructor\n  · intro h n\n    exact h (Nat.le_succ n)\n  · intro h m n hmn\n    induction n, hmn using Nat.le_induction with\n    | base => rfl\n    | succ n hmn ih =>\n        trans\n        · exact ih\n        · refine SModEq.mono (smul_mono (Ideal.pow_le_pow_right hmn) (by rfl)) (h n)\n\n"}
{"name":"AdicCompletion.AdicCauchySequence.mk_coe","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Nat → M\nh : ∀ (n : Nat), SModEq (HSMul.hSMul (HPow.hPow I n) Top.top) (f n) (f (HAdd.hAdd n 1))\na✝ : Nat\n⊢ Eq (↑(AdicCompletion.AdicCauchySequence.mk I M f h) a✝) (f a✝)","decl":"/-- Construct `I`-adic cauchy sequence from sequence satisfying the successive cauchy condition. -/\n@[simps]\ndef AdicCauchySequence.mk (f : ℕ → M)\n    (h : ∀ n, f n ≡ f (n + 1) [SMOD (I ^ n • ⊤ : Submodule R M)]) : AdicCauchySequence I M where\n  val := f\n  property := by rwa [isAdicCauchy_iff]\n\n"}
{"name":"AdicCompletion.mk_apply_coe","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : AdicCompletion.AdicCauchySequence I M\nn : Nat\n⊢ Eq (↑((AdicCompletion.mk I M) f) n) ((HSMul.hSMul (HPow.hPow I n) Top.top).mkQ (↑f n))","decl":"/-- The canonical linear map from cauchy sequences to the completion. -/\n@[simps]\ndef mk : AdicCauchySequence I M →ₗ[R] AdicCompletion I M where\n  toFun f := ⟨fun n ↦ Submodule.mkQ (I ^ n • ⊤ : Submodule R M) (f n), by\n    intro m n hmn\n    simp only [mkQ_apply, transitionMap_mk]\n    exact (f.property hmn).symm⟩\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\n"}
{"name":"AdicCompletion.mk_zero_of","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : AdicCompletion.AdicCauchySequence I M\nh : Exists fun k => ∀ (n : Nat), GE.ge n k → Exists fun m => And (GE.ge m n) (Exists fun l => And (GE.ge l n) (Membership.mem (HSMul.hSMul (HPow.hPow I l) Top.top) (↑f m)))\n⊢ Eq ((AdicCompletion.mk I M) f) 0","decl":"/-- Criterion for checking that an adic cauchy sequence is mapped to zero in the adic completion. -/\ntheorem mk_zero_of (f : AdicCauchySequence I M)\n    (h : ∃ k : ℕ, ∀ n ≥ k, ∃ m ≥ n, ∃ l ≥ n, f m ∈ (I ^ l • ⊤ : Submodule R M)) :\n    AdicCompletion.mk I M f = 0 := by\n  obtain ⟨k, h⟩ := h\n  ext n\n  obtain ⟨m, hnm, l, hnl, hl⟩ := h (n + k) (by omega)\n  rw [mk_apply_coe, Submodule.mkQ_apply, val_zero,\n    ← AdicCauchySequence.mk_eq_mk (show n ≤ m by omega)]\n  simpa using (Submodule.smul_mono_left (Ideal.pow_le_pow_right (by omega))) hl\n\n"}
{"name":"AdicCompletion.mk_surjective","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Function.Surjective ⇑(AdicCompletion.mk I M)","decl":"/-- Every element in the adic completion is represented by a Cauchy sequence. -/\ntheorem mk_surjective : Function.Surjective (mk I M) := by\n  intro x\n  choose a ha using fun n ↦ Submodule.Quotient.mk_surjective _ (x.val n)\n  refine ⟨⟨a, ?_⟩, ?_⟩\n  · intro m n hmn\n    rw [SModEq.def, ha m, ← transitionMap_mk I M hmn, ha n, x.property hmn]\n  · ext n\n    simp [ha n]\n\n"}
{"name":"AdicCompletion.induction_on","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : AdicCompletion I M → Prop\nx : AdicCompletion I M\nh : ∀ (f : AdicCompletion.AdicCauchySequence I M), p ((AdicCompletion.mk I M) f)\n⊢ p x","decl":"/-- To show a statement about an element of `adicCompletion I M`, it suffices to check it\non Cauchy sequences. -/\ntheorem induction_on {p : AdicCompletion I M → Prop} (x : AdicCompletion I M)\n    (h : ∀ (f : AdicCauchySequence I M), p (mk I M f)) : p x := by\n  obtain ⟨f, rfl⟩ := mk_surjective I M x\n  exact h f\n\n"}
{"name":"AdicCompletion.eval_lift","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_5\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : (n : Nat) → LinearMap (RingHom.id R) M (HasQuotient.Quotient N (HSMul.hSMul (HPow.hPow I n) Top.top))\nh : ∀ {m n : Nat} (hle : LE.le m n), Eq ((AdicCompletion.transitionMap I N hle).comp (f n)) (f m)\nn : Nat\n⊢ Eq ((AdicCompletion.eval I N n).comp (AdicCompletion.lift I f ⋯)) (f n)","decl":"@[simp]\nlemma eval_lift (f : ∀ (n : ℕ), M →ₗ[R] N ⧸ (I ^ n • ⊤ : Submodule R N))\n    (h : ∀ {m n : ℕ} (hle : m ≤ n), transitionMap I N hle ∘ₗ f n = f m)\n    (n : ℕ) : eval I N n ∘ₗ lift I f h = f n :=\n  rfl\n\n"}
{"name":"AdicCompletion.eval_lift_apply","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_5\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : (n : Nat) → LinearMap (RingHom.id R) M (HasQuotient.Quotient N (HSMul.hSMul (HPow.hPow I n) Top.top))\nh : ∀ {m n : Nat} (hle : LE.le m n), Eq ((AdicCompletion.transitionMap I N hle).comp (f n)) (f m)\nn : Nat\nx : M\n⊢ Eq (↑((AdicCompletion.lift I f ⋯) x) n) ((f n) x)","decl":"@[simp]\nlemma eval_lift_apply (f : ∀ (n : ℕ), M →ₗ[R] N ⧸ (I ^ n • ⊤ : Submodule R N))\n    (h : ∀ {m n : ℕ} (hle : m ≤ n), transitionMap I N hle ∘ₗ f n = f m)\n    (n : ℕ) (x : M) : (lift I f h x).val n = f n x :=\n  rfl\n\n"}
{"name":"IsAdicComplete.bot","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ IsAdicComplete Bot.bot M","decl":"instance bot : IsAdicComplete (⊥ : Ideal R) M where\n\n"}
{"name":"IsAdicComplete.subsingleton","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nh : IsAdicComplete Top.top M\n⊢ Subsingleton M","decl":"protected theorem subsingleton (h : IsAdicComplete (⊤ : Ideal R) M) : Subsingleton M :=\n  h.1.subsingleton\n\n"}
{"name":"IsAdicComplete.of_subsingleton","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nI : Ideal R\nM : Type u_4\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Subsingleton M\n⊢ IsAdicComplete I M","decl":"instance (priority := 100) of_subsingleton [Subsingleton M] : IsAdicComplete I M where\n\n"}
{"name":"IsAdicComplete.le_jacobson_bot","module":"Mathlib.RingTheory.AdicCompletion.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nI : Ideal R\ninst✝ : IsAdicComplete I R\n⊢ LE.le I Bot.bot.jacobson","decl":"theorem le_jacobson_bot [IsAdicComplete I R] : I ≤ (⊥ : Ideal R).jacobson := by\n  intro x hx\n  rw [← Ideal.neg_mem_iff, Ideal.mem_jacobson_bot]\n  intro y\n  rw [add_comm]\n  let f : ℕ → R := fun n => ∑ i ∈ range n, (x * y) ^ i\n  have hf : ∀ m n, m ≤ n → f m ≡ f n [SMOD I ^ m • (⊤ : Submodule R R)] := by\n    intro m n h\n    simp only [f, Algebra.id.smul_eq_mul, Ideal.mul_top, SModEq.sub_mem]\n    rw [← add_tsub_cancel_of_le h, Finset.sum_range_add, ← sub_sub, sub_self, zero_sub,\n      @neg_mem_iff]\n    apply Submodule.sum_mem\n    intro n _\n    rw [mul_pow, pow_add, mul_assoc]\n    exact Ideal.mul_mem_right _ (I ^ m) (Ideal.pow_mem_pow hx m)\n  obtain ⟨L, hL⟩ := IsPrecomplete.prec toIsPrecomplete @hf\n  rw [isUnit_iff_exists_inv]\n  use L\n  rw [← sub_eq_zero, neg_mul]\n  apply IsHausdorff.haus (toIsHausdorff : IsHausdorff I R)\n  intro n\n  specialize hL n\n  rw [SModEq.sub_mem, Algebra.id.smul_eq_mul, Ideal.mul_top] at hL ⊢\n  rw [sub_zero]\n  suffices (1 - x * y) * f n - 1 ∈ I ^ n by\n    convert Ideal.sub_mem _ this (Ideal.mul_mem_left _ (1 + -(x * y)) hL) using 1\n    ring\n  cases n\n  · simp only [Ideal.one_eq_top, pow_zero, mem_top]\n  · rw [← neg_sub _ (1 : R), neg_mul, mul_geom_sum, neg_sub, sub_sub, add_comm (_ ^ _), ← sub_sub,\n      sub_self, zero_sub, @neg_mem_iff, mul_pow]\n    exact Ideal.mul_mem_right _ (I ^ _) (Ideal.pow_mem_pow hx _)\n\n"}
