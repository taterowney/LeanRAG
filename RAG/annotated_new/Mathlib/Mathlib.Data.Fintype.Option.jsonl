{"name":"univ_option","module":"Mathlib.Data.Fintype.Option","initialProofState":"α : Type u_3\ninst✝ : Fintype α\n⊢ Eq Finset.univ (Finset.insertNone Finset.univ)","decl":"theorem univ_option (α : Type*) [Fintype α] : (univ : Finset (Option α)) = insertNone univ :=\n  rfl\n\n"}
{"name":"Fintype.card_option","module":"Mathlib.Data.Fintype.Option","initialProofState":"α : Type u_3\ninst✝ : Fintype α\n⊢ Eq (Fintype.card (Option α)) (HAdd.hAdd (Fintype.card α) 1)","decl":"@[simp]\ntheorem Fintype.card_option {α : Type*} [Fintype α] :\n    Fintype.card (Option α) = Fintype.card α + 1 :=\n  (Finset.card_cons (by simp)).trans <| congr_arg₂ _ (card_map _) rfl\n\n"}
{"name":"Fintype.induction_empty_option","module":"Mathlib.Data.Fintype.Option","initialProofState":"P : (α : Type u) → [inst : Fintype α] → Prop\nof_equiv : ∀ (α β : Type u) [inst : Fintype β] (e : Equiv α β), P α → P β\nh_empty : P PEmpty.{u + 1}\nh_option : ∀ (α : Type u) [inst : Fintype α], P α → P (Option α)\nα : Type u\nh_fintype : Fintype α\n⊢ P α","decl":"/-- An induction principle for finite types, analogous to `Nat.rec`. It effectively says\nthat every `Fintype` is either `Empty` or `Option α`, up to an `Equiv`. -/\n@[elab_as_elim]\ntheorem induction_empty_option {P : ∀ (α : Type u) [Fintype α], Prop}\n    (of_equiv : ∀ (α β) [Fintype β] (e : α ≃ β), @P α (@Fintype.ofEquiv α β ‹_› e.symm) → @P β ‹_›)\n    (h_empty : P PEmpty) (h_option : ∀ (α) [Fintype α], P α → P (Option α)) (α : Type u)\n    [h_fintype : Fintype α] : P α := by\n  obtain ⟨p⟩ :=\n    let f_empty := fun i => by convert h_empty\n    let h_option : ∀ {α : Type u} [Fintype α] [DecidableEq α],\n          (∀ (h : Fintype α), P α) → ∀ (h : Fintype (Option α)), P (Option α)  := by\n      rintro α hα - Pα hα'\n      convert h_option α (Pα _)\n    @truncRecEmptyOption (fun α => ∀ h, @P α h) (@fun α β e hα hβ => @of_equiv α β hβ e (hα _))\n      f_empty h_option α _ (Classical.decEq α)\n  exact p _\n  -- ·\n\n"}
{"name":"Finite.induction_empty_option","module":"Mathlib.Data.Fintype.Option","initialProofState":"P : Type u → Prop\nof_equiv : ∀ {α β : Type u}, Equiv α β → P α → P β\nh_empty : P PEmpty.{u + 1}\nh_option : ∀ {α : Type u} [inst : Fintype α], P α → P (Option α)\nα : Type u\ninst✝ : Finite α\n⊢ P α","decl":"/-- An induction principle for finite types, analogous to `Nat.rec`. It effectively says\nthat every `Fintype` is either `Empty` or `Option α`, up to an `Equiv`. -/\ntheorem Finite.induction_empty_option {P : Type u → Prop} (of_equiv : ∀ {α β}, α ≃ β → P α → P β)\n    (h_empty : P PEmpty) (h_option : ∀ {α} [Fintype α], P α → P (Option α)) (α : Type u)\n    [Finite α] : P α := by\n  cases nonempty_fintype α\n  refine Fintype.induction_empty_option ?_ ?_ ?_ α\n  exacts [fun α β _ => of_equiv, h_empty, @h_option]\n"}
