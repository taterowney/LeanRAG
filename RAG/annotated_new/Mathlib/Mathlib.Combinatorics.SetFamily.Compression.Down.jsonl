{"name":"Finset.mem_nonMemberSubfamily","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ns : Finset Î±\na : Î±\nâŠ¢ Iff (Membership.mem (Finset.nonMemberSubfamily a ğ’œ) s) (And (Membership.mem ğ’œ s) (Not (Membership.mem s a)))","decl":"@[simp]\ntheorem mem_nonMemberSubfamily : s âˆˆ ğ’œ.nonMemberSubfamily a â†” s âˆˆ ğ’œ âˆ§ a âˆ‰ s := by\n  simp [nonMemberSubfamily]\n\n"}
{"name":"Finset.mem_memberSubfamily","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ns : Finset Î±\na : Î±\nâŠ¢ Iff (Membership.mem (Finset.memberSubfamily a ğ’œ) s) (And (Membership.mem ğ’œ (Insert.insert a s)) (Not (Membership.mem s a)))","decl":"@[simp]\ntheorem mem_memberSubfamily : s âˆˆ ğ’œ.memberSubfamily a â†” insert a s âˆˆ ğ’œ âˆ§ a âˆ‰ s := by\n  simp_rw [memberSubfamily, mem_image, mem_filter]\n  refine âŸ¨?_, fun h => âŸ¨insert a s, âŸ¨h.1, by simpâŸ©, erase_insert h.2âŸ©âŸ©\n  rintro âŸ¨s, âŸ¨hs1, hs2âŸ©, rflâŸ©\n  rw [insert_erase hs2]\n  exact âŸ¨hs1, not_mem_erase _ _âŸ©\n\n"}
{"name":"Finset.nonMemberSubfamily_inter","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\na : Î±\nğ’œ â„¬ : Finset (Finset Î±)\nâŠ¢ Eq (Finset.nonMemberSubfamily a (Inter.inter ğ’œ â„¬)) (Inter.inter (Finset.nonMemberSubfamily a ğ’œ) (Finset.nonMemberSubfamily a â„¬))","decl":"theorem nonMemberSubfamily_inter (a : Î±) (ğ’œ â„¬ : Finset (Finset Î±)) :\n    (ğ’œ âˆ© â„¬).nonMemberSubfamily a = ğ’œ.nonMemberSubfamily a âˆ© â„¬.nonMemberSubfamily a :=\n  filter_inter_distrib _ _ _\n\n"}
{"name":"Finset.memberSubfamily_inter","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\na : Î±\nğ’œ â„¬ : Finset (Finset Î±)\nâŠ¢ Eq (Finset.memberSubfamily a (Inter.inter ğ’œ â„¬)) (Inter.inter (Finset.memberSubfamily a ğ’œ) (Finset.memberSubfamily a â„¬))","decl":"theorem memberSubfamily_inter (a : Î±) (ğ’œ â„¬ : Finset (Finset Î±)) :\n    (ğ’œ âˆ© â„¬).memberSubfamily a = ğ’œ.memberSubfamily a âˆ© â„¬.memberSubfamily a := by\n  unfold memberSubfamily\n  rw [filter_inter_distrib, image_inter_of_injOn _ _ ((erase_injOn' _).mono _)]\n  simp\n\n"}
{"name":"Finset.nonMemberSubfamily_union","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\na : Î±\nğ’œ â„¬ : Finset (Finset Î±)\nâŠ¢ Eq (Finset.nonMemberSubfamily a (Union.union ğ’œ â„¬)) (Union.union (Finset.nonMemberSubfamily a ğ’œ) (Finset.nonMemberSubfamily a â„¬))","decl":"theorem nonMemberSubfamily_union (a : Î±) (ğ’œ â„¬ : Finset (Finset Î±)) :\n    (ğ’œ âˆª â„¬).nonMemberSubfamily a = ğ’œ.nonMemberSubfamily a âˆª â„¬.nonMemberSubfamily a :=\n  filter_union _ _ _\n\n"}
{"name":"Finset.memberSubfamily_union","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\na : Î±\nğ’œ â„¬ : Finset (Finset Î±)\nâŠ¢ Eq (Finset.memberSubfamily a (Union.union ğ’œ â„¬)) (Union.union (Finset.memberSubfamily a ğ’œ) (Finset.memberSubfamily a â„¬))","decl":"theorem memberSubfamily_union (a : Î±) (ğ’œ â„¬ : Finset (Finset Î±)) :\n    (ğ’œ âˆª â„¬).memberSubfamily a = ğ’œ.memberSubfamily a âˆª â„¬.memberSubfamily a := by\n  simp_rw [memberSubfamily, filter_union, image_union]\n\n"}
{"name":"Finset.card_memberSubfamily_add_card_nonMemberSubfamily","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\na : Î±\nğ’œ : Finset (Finset Î±)\nâŠ¢ Eq (HAdd.hAdd (Finset.memberSubfamily a ğ’œ).card (Finset.nonMemberSubfamily a ğ’œ).card) ğ’œ.card","decl":"theorem card_memberSubfamily_add_card_nonMemberSubfamily (a : Î±) (ğ’œ : Finset (Finset Î±)) :\n    #(ğ’œ.memberSubfamily a) + #(ğ’œ.nonMemberSubfamily a) = #ğ’œ := by\n  rw [memberSubfamily, nonMemberSubfamily, card_image_of_injOn]\n  Â· conv_rhs => rw [â† filter_card_add_filter_neg_card_eq_card (fun s => (a âˆˆ s))]\n  Â· apply (erase_injOn' _).mono\n    simp\n\n"}
{"name":"Finset.memberSubfamily_union_nonMemberSubfamily","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\na : Î±\nğ’œ : Finset (Finset Î±)\nâŠ¢ Eq (Union.union (Finset.memberSubfamily a ğ’œ) (Finset.nonMemberSubfamily a ğ’œ)) (Finset.image (fun s => s.erase a) ğ’œ)","decl":"theorem memberSubfamily_union_nonMemberSubfamily (a : Î±) (ğ’œ : Finset (Finset Î±)) :\n    ğ’œ.memberSubfamily a âˆª ğ’œ.nonMemberSubfamily a = ğ’œ.image fun s => s.erase a := by\n  ext s\n  simp only [mem_union, mem_memberSubfamily, mem_nonMemberSubfamily, mem_image, exists_prop]\n  constructor\n  Â· rintro (h | h)\n    Â· exact âŸ¨_, h.1, erase_insert h.2âŸ©\n    Â· exact âŸ¨_, h.1, erase_eq_of_not_mem h.2âŸ©\n  Â· rintro âŸ¨s, hs, rflâŸ©\n    by_cases ha : a âˆˆ s\n    Â· exact Or.inl âŸ¨by rwa [insert_erase ha], not_mem_erase _ _âŸ©\n    Â· exact Or.inr âŸ¨by rwa [erase_eq_of_not_mem ha], not_mem_erase _ _âŸ©\n\n"}
{"name":"Finset.memberSubfamily_memberSubfamily","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\na : Î±\nâŠ¢ Eq (Finset.memberSubfamily a (Finset.memberSubfamily a ğ’œ)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem memberSubfamily_memberSubfamily : (ğ’œ.memberSubfamily a).memberSubfamily a = âˆ… := by\n  ext\n  simp\n\n"}
{"name":"Finset.memberSubfamily_nonMemberSubfamily","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\na : Î±\nâŠ¢ Eq (Finset.memberSubfamily a (Finset.nonMemberSubfamily a ğ’œ)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem memberSubfamily_nonMemberSubfamily : (ğ’œ.nonMemberSubfamily a).memberSubfamily a = âˆ… := by\n  ext\n  simp\n\n"}
{"name":"Finset.nonMemberSubfamily_memberSubfamily","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\na : Î±\nâŠ¢ Eq (Finset.nonMemberSubfamily a (Finset.memberSubfamily a ğ’œ)) (Finset.memberSubfamily a ğ’œ)","decl":"@[simp]\ntheorem nonMemberSubfamily_memberSubfamily :\n    (ğ’œ.memberSubfamily a).nonMemberSubfamily a = ğ’œ.memberSubfamily a := by\n  ext\n  simp\n\n"}
{"name":"Finset.nonMemberSubfamily_nonMemberSubfamily","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\na : Î±\nâŠ¢ Eq (Finset.nonMemberSubfamily a (Finset.nonMemberSubfamily a ğ’œ)) (Finset.nonMemberSubfamily a ğ’œ)","decl":"@[simp]\ntheorem nonMemberSubfamily_nonMemberSubfamily :\n    (ğ’œ.nonMemberSubfamily a).nonMemberSubfamily a = ğ’œ.nonMemberSubfamily a := by\n  ext\n  simp\n\n"}
{"name":"Finset.memberSubfamily_image_insert","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\na : Î±\nhğ’œ : âˆ€ (s : Finset Î±), Membership.mem ğ’œ s â†’ Not (Membership.mem s a)\nâŠ¢ Eq (Finset.memberSubfamily a (Finset.image (Insert.insert a) ğ’œ)) ğ’œ","decl":"lemma memberSubfamily_image_insert (hğ’œ : âˆ€ s âˆˆ ğ’œ, a âˆ‰ s) :\n    (ğ’œ.image <| insert a).memberSubfamily a = ğ’œ := by\n  ext s\n  simp only [mem_memberSubfamily, mem_image]\n  refine âŸ¨?_, fun hs â†¦ âŸ¨âŸ¨s, hs, rflâŸ©, hğ’œ _ hsâŸ©âŸ©\n  rintro âŸ¨âŸ¨t, ht, htsâŸ©, hsâŸ©\n  rwa [â† insert_erase_invOn.2.injOn (hğ’œ _ ht) hs hts]\n\n"}
{"name":"Finset.nonMemberSubfamily_image_insert","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\na : Î±\nâŠ¢ Eq (Finset.nonMemberSubfamily a (Finset.image (Insert.insert a) ğ’œ)) EmptyCollection.emptyCollection","decl":"@[simp] lemma nonMemberSubfamily_image_insert : (ğ’œ.image <| insert a).nonMemberSubfamily a = âˆ… := by\n  simp [eq_empty_iff_forall_not_mem]\n\n"}
{"name":"Finset.memberSubfamily_image_erase","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\na : Î±\nâŠ¢ Eq (Finset.memberSubfamily a (Finset.image (fun x => x.erase a) ğ’œ)) EmptyCollection.emptyCollection","decl":"@[simp] lemma memberSubfamily_image_erase : (ğ’œ.image (erase Â· a)).memberSubfamily a = âˆ… := by\n  simp [eq_empty_iff_forall_not_mem,\n    (ne_of_mem_of_not_mem' (mem_insert_self _ _) (not_mem_erase _ _)).symm]\n\n"}
{"name":"Finset.image_insert_memberSubfamily","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\na : Î±\nâŠ¢ Eq (Finset.image (Insert.insert a) (Finset.memberSubfamily a ğ’œ)) (Finset.filter (fun s => Membership.mem s a) ğ’œ)","decl":"lemma image_insert_memberSubfamily (ğ’œ : Finset (Finset Î±)) (a : Î±) :\n    (ğ’œ.memberSubfamily a).image (insert a) = {s âˆˆ ğ’œ | a âˆˆ s} := by\n  ext s\n  simp only [mem_memberSubfamily, mem_image, mem_filter]\n  refine âŸ¨?_, fun âŸ¨hs, haâŸ© â†¦ âŸ¨erase s a, âŸ¨?_, not_mem_erase _ _âŸ©, insert_erase haâŸ©âŸ©\n  Â· rintro âŸ¨s, âŸ¨hs, -âŸ©, rflâŸ©\n    exact âŸ¨hs, mem_insert_self _ _âŸ©\n  Â· rwa [insert_erase ha]\n\n"}
{"name":"Finset.memberFamily_induction_on","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\np : Finset (Finset Î±) â†’ Prop\nğ’œ : Finset (Finset Î±)\nempty : p EmptyCollection.emptyCollection\nsingleton_empty : p (Singleton.singleton EmptyCollection.emptyCollection)\nsubfamily : âˆ€ (a : Î±) â¦ƒğ’œ : Finset (Finset Î±)â¦„, p (Finset.nonMemberSubfamily a ğ’œ) â†’ p (Finset.memberSubfamily a ğ’œ) â†’ p ğ’œ\nâŠ¢ p ğ’œ","decl":"/-- Induction principle for finset families. To prove a statement for every finset family,\nit suffices to prove it for\n* the empty finset family.\n* the finset family which only contains the empty finset.\n* `â„¬ âˆª {s âˆª {a} | s âˆˆ ğ’}` assuming the property for `â„¬` and `ğ’`, where `a` is an element of the\n  ground type and `ğ’œ` and `â„¬` are families of finsets not containing `a`.\n  Note that instead of giving `â„¬` and `ğ’`, the `subfamily` case gives you\n  `ğ’œ = â„¬ âˆª {s âˆª {a} | s âˆˆ ğ’}`, so that `â„¬ = ğ’œ.nonMemberSubfamily` and `ğ’ = ğ’œ.memberSubfamily`.\n\nThis is a way of formalising induction on `n` where `ğ’œ` is a finset family on `n` elements.\n\nSee also `Finset.family_induction_on.`-/\n@[elab_as_elim]\nlemma memberFamily_induction_on {p : Finset (Finset Î±) â†’ Prop}\n    (ğ’œ : Finset (Finset Î±)) (empty : p âˆ…) (singleton_empty : p {âˆ…})\n    (subfamily : âˆ€ (a : Î±) â¦ƒğ’œ : Finset (Finset Î±)â¦„,\n      p (ğ’œ.nonMemberSubfamily a) â†’ p (ğ’œ.memberSubfamily a) â†’ p ğ’œ) : p ğ’œ := by\n  set u := ğ’œ.sup id\n  have hu : âˆ€ s âˆˆ ğ’œ, s âŠ† u := fun s â†¦ le_sup (f := id)\n  clear_value u\n  induction' u using Finset.induction with a u _ ih generalizing ğ’œ\n  Â· simp_rw [subset_empty] at hu\n    rw [â† subset_singleton_iff', subset_singleton_iff] at hu\n    obtain rfl | rfl := hu <;> assumption\n  refine subfamily a (ih _ ?_) (ih _ ?_)\n  Â· simp only [mem_nonMemberSubfamily, and_imp]\n    exact fun s hs has â†¦ (subset_insert_iff_of_not_mem has).1 <| hu _ hs\n  Â· simp only [mem_memberSubfamily, and_imp]\n    exact fun s hs ha â†¦ (insert_subset_insert_iff ha).1 <| hu _ hs\n\n"}
{"name":"Finset.family_induction_on","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\np : Finset (Finset Î±) â†’ Prop\nğ’œ : Finset (Finset Î±)\nempty : p EmptyCollection.emptyCollection\nsingleton_empty : p (Singleton.singleton EmptyCollection.emptyCollection)\nimage_insert : âˆ€ (a : Î±) â¦ƒğ’œ : Finset (Finset Î±)â¦„, (âˆ€ (s : Finset Î±), Membership.mem ğ’œ s â†’ Not (Membership.mem s a)) â†’ p ğ’œ â†’ p (Finset.image (Insert.insert a) ğ’œ)\nsubfamily : âˆ€ (a : Î±) â¦ƒğ’œ : Finset (Finset Î±)â¦„, p (Finset.filter (fun s => Not (Membership.mem s a)) ğ’œ) â†’ p (Finset.filter (fun s => Membership.mem s a) ğ’œ) â†’ p ğ’œ\nâŠ¢ p ğ’œ","decl":"/-- Induction principle for finset families. To prove a statement for every finset family,\nit suffices to prove it for\n* the empty finset family.\n* the finset family which only contains the empty finset.\n* `{s âˆª {a} | s âˆˆ ğ’œ}` assuming the property for `ğ’œ` a family of finsets not containing `a`.\n* `â„¬ âˆª ğ’` assuming the property for `â„¬` and `ğ’`, where `a` is an element of the ground type and\n  `â„¬`is a family of finsets not containing `a` and `ğ’` a family of finsets containing `a`.\n  Note that instead of giving `â„¬` and `ğ’`, the `subfamily` case gives you `ğ’œ = â„¬ âˆª ğ’`, so that\n  `â„¬ = {s âˆˆ ğ’œ | a âˆ‰ s}` and `ğ’ = {s âˆˆ ğ’œ | a âˆˆ s}`.\n\nThis is a way of formalising induction on `n` where `ğ’œ` is a finset family on `n` elements.\n\nSee also `Finset.memberFamily_induction_on.`-/\n@[elab_as_elim]\nprotected lemma family_induction_on {p : Finset (Finset Î±) â†’ Prop}\n    (ğ’œ : Finset (Finset Î±)) (empty : p âˆ…) (singleton_empty : p {âˆ…})\n    (image_insert : âˆ€ (a : Î±) â¦ƒğ’œ : Finset (Finset Î±)â¦„,\n      (âˆ€ s âˆˆ ğ’œ, a âˆ‰ s) â†’ p ğ’œ â†’ p (ğ’œ.image <| insert a))\n    (subfamily : âˆ€ (a : Î±) â¦ƒğ’œ : Finset (Finset Î±)â¦„,\n      p {s âˆˆ ğ’œ | a âˆ‰ s} â†’ p {s âˆˆ ğ’œ | a âˆˆ s} â†’ p ğ’œ) : p ğ’œ := by\n  refine memberFamily_induction_on ğ’œ empty singleton_empty fun a ğ’œ hğ’œâ‚€ hğ’œâ‚ â†¦ subfamily a hğ’œâ‚€ ?_\n  rw [â† image_insert_memberSubfamily]\n  exact image_insert _ (by simp) hğ’œâ‚\n\n"}
{"name":"Down.mem_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ns : Finset Î±\na : Î±\nâŠ¢ Iff (Membership.mem (Down.compression a ğ’œ) s) (Or (And (Membership.mem ğ’œ s) (Membership.mem ğ’œ (s.erase a))) (And (Not (Membership.mem ğ’œ s)) (Membership.mem ğ’œ (Insert.insert a s))))","decl":"/-- `a` is in the down-compressed family iff it's in the original and its compression is in the\noriginal, or it's not in the original but it's the compression of something in the original. -/\ntheorem mem_compression : s âˆˆ ğ““ a ğ’œ â†” s âˆˆ ğ’œ âˆ§ s.erase a âˆˆ ğ’œ âˆ¨ s âˆ‰ ğ’œ âˆ§ insert a s âˆˆ ğ’œ := by\n  simp_rw [compression, mem_disjUnion, mem_filter, mem_image, and_comm (a := (Â¬ s âˆˆ ğ’œ))]\n  refine\n    or_congr_right\n      (and_congr_left fun hs =>\n        âŸ¨?_, fun h => âŸ¨_, h, erase_insert <| insert_ne_self.1 <| ne_of_mem_of_not_mem h hsâŸ©âŸ©)\n  rintro âŸ¨t, ht, rflâŸ©\n  rwa [insert_erase (erase_ne_self.1 (ne_of_mem_of_not_mem ht hs).symm)]\n\n"}
{"name":"Down.erase_mem_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ns : Finset Î±\na : Î±\nhs : Membership.mem ğ’œ s\nâŠ¢ Membership.mem (Down.compression a ğ’œ) (s.erase a)","decl":"theorem erase_mem_compression (hs : s âˆˆ ğ’œ) : s.erase a âˆˆ ğ““ a ğ’œ := by\n  simp_rw [mem_compression, erase_idem, and_self_iff]\n  refine (em _).imp_right fun h => âŸ¨h, ?_âŸ©\n  rwa [insert_erase (erase_ne_self.1 (ne_of_mem_of_not_mem hs h).symm)]\n\n-- This is a special case of `erase_mem_compression` once we have `compression_idem`.\n"}
{"name":"Down.erase_mem_compression_of_mem_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ns : Finset Î±\na : Î±\naâœ : Membership.mem (Down.compression a ğ’œ) s\nâŠ¢ Membership.mem (Down.compression a ğ’œ) (s.erase a)","decl":"theorem erase_mem_compression_of_mem_compression : s âˆˆ ğ““ a ğ’œ â†’ s.erase a âˆˆ ğ““ a ğ’œ := by\n  simp_rw [mem_compression, erase_idem]\n  refine Or.imp (fun h => âŸ¨h.2, h.2âŸ©) fun h => ?_\n  rwa [erase_eq_of_not_mem (insert_ne_self.1 <| ne_of_mem_of_not_mem h.2 h.1)]\n\n"}
{"name":"Down.mem_compression_of_insert_mem_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ns : Finset Î±\na : Î±\nh : Membership.mem (Down.compression a ğ’œ) (Insert.insert a s)\nâŠ¢ Membership.mem (Down.compression a ğ’œ) s","decl":"theorem mem_compression_of_insert_mem_compression (h : insert a s âˆˆ ğ““ a ğ’œ) : s âˆˆ ğ““ a ğ’œ := by\n  by_cases ha : a âˆˆ s\n  Â· rwa [insert_eq_of_mem ha] at h\n  Â· rw [â† erase_insert ha]\n    exact erase_mem_compression_of_mem_compression h\n\n"}
{"name":"Down.compression_idem","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\na : Î±\nğ’œ : Finset (Finset Î±)\nâŠ¢ Eq (Down.compression a (Down.compression a ğ’œ)) (Down.compression a ğ’œ)","decl":"/-- Down-compressing a family is idempotent. -/\n@[simp]\ntheorem compression_idem (a : Î±) (ğ’œ : Finset (Finset Î±)) : ğ““ a (ğ““ a ğ’œ) = ğ““ a ğ’œ := by\n  ext s\n  refine mem_compression.trans âŸ¨?_, fun h => Or.inl âŸ¨h, erase_mem_compression_of_mem_compression hâŸ©âŸ©\n  rintro (h | h)\n  Â· exact h.1\n  Â· cases h.1 (mem_compression_of_insert_mem_compression h.2)\n\n"}
{"name":"Down.card_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\na : Î±\nğ’œ : Finset (Finset Î±)\nâŠ¢ Eq (Down.compression a ğ’œ).card ğ’œ.card","decl":"/-- Down-compressing a family doesn't change its size. -/\n@[simp]\ntheorem card_compression (a : Î±) (ğ’œ : Finset (Finset Î±)) : #(ğ““ a ğ’œ) = #ğ’œ := by\n  rw [compression, card_disjUnion, filter_image,\n    card_image_of_injOn ((erase_injOn' _).mono fun s hs => _), â† card_union_of_disjoint]\n  Â· conv_rhs => rw [â† filter_union_filter_neg_eq (fun s => (erase s a âˆˆ ğ’œ)) ğ’œ]\n  Â· exact disjoint_filter_filter_neg ğ’œ ğ’œ (fun s => (erase s a âˆˆ ğ’œ))\n  intro s hs\n  rw [mem_coe, mem_filter] at hs\n  exact not_imp_comm.1 erase_eq_of_not_mem (ne_of_mem_of_not_mem hs.1 hs.2).symm\n\n"}
