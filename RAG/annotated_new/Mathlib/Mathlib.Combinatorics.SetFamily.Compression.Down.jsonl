{"name":"Finset.mem_nonMemberSubfamily","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\ns : Finset α\na : α\n⊢ Iff (Membership.mem (Finset.nonMemberSubfamily a 𝒜) s) (And (Membership.mem 𝒜 s) (Not (Membership.mem s a)))","decl":"@[simp]\ntheorem mem_nonMemberSubfamily : s ∈ 𝒜.nonMemberSubfamily a ↔ s ∈ 𝒜 ∧ a ∉ s := by\n  simp [nonMemberSubfamily]\n\n"}
{"name":"Finset.mem_memberSubfamily","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\ns : Finset α\na : α\n⊢ Iff (Membership.mem (Finset.memberSubfamily a 𝒜) s) (And (Membership.mem 𝒜 (Insert.insert a s)) (Not (Membership.mem s a)))","decl":"@[simp]\ntheorem mem_memberSubfamily : s ∈ 𝒜.memberSubfamily a ↔ insert a s ∈ 𝒜 ∧ a ∉ s := by\n  simp_rw [memberSubfamily, mem_image, mem_filter]\n  refine ⟨?_, fun h => ⟨insert a s, ⟨h.1, by simp⟩, erase_insert h.2⟩⟩\n  rintro ⟨s, ⟨hs1, hs2⟩, rfl⟩\n  rw [insert_erase hs2]\n  exact ⟨hs1, not_mem_erase _ _⟩\n\n"}
{"name":"Finset.nonMemberSubfamily_inter","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n𝒜 ℬ : Finset (Finset α)\n⊢ Eq (Finset.nonMemberSubfamily a (Inter.inter 𝒜 ℬ)) (Inter.inter (Finset.nonMemberSubfamily a 𝒜) (Finset.nonMemberSubfamily a ℬ))","decl":"theorem nonMemberSubfamily_inter (a : α) (𝒜 ℬ : Finset (Finset α)) :\n    (𝒜 ∩ ℬ).nonMemberSubfamily a = 𝒜.nonMemberSubfamily a ∩ ℬ.nonMemberSubfamily a :=\n  filter_inter_distrib _ _ _\n\n"}
{"name":"Finset.memberSubfamily_inter","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n𝒜 ℬ : Finset (Finset α)\n⊢ Eq (Finset.memberSubfamily a (Inter.inter 𝒜 ℬ)) (Inter.inter (Finset.memberSubfamily a 𝒜) (Finset.memberSubfamily a ℬ))","decl":"theorem memberSubfamily_inter (a : α) (𝒜 ℬ : Finset (Finset α)) :\n    (𝒜 ∩ ℬ).memberSubfamily a = 𝒜.memberSubfamily a ∩ ℬ.memberSubfamily a := by\n  unfold memberSubfamily\n  rw [filter_inter_distrib, image_inter_of_injOn _ _ ((erase_injOn' _).mono _)]\n  simp\n\n"}
{"name":"Finset.nonMemberSubfamily_union","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n𝒜 ℬ : Finset (Finset α)\n⊢ Eq (Finset.nonMemberSubfamily a (Union.union 𝒜 ℬ)) (Union.union (Finset.nonMemberSubfamily a 𝒜) (Finset.nonMemberSubfamily a ℬ))","decl":"theorem nonMemberSubfamily_union (a : α) (𝒜 ℬ : Finset (Finset α)) :\n    (𝒜 ∪ ℬ).nonMemberSubfamily a = 𝒜.nonMemberSubfamily a ∪ ℬ.nonMemberSubfamily a :=\n  filter_union _ _ _\n\n"}
{"name":"Finset.memberSubfamily_union","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n𝒜 ℬ : Finset (Finset α)\n⊢ Eq (Finset.memberSubfamily a (Union.union 𝒜 ℬ)) (Union.union (Finset.memberSubfamily a 𝒜) (Finset.memberSubfamily a ℬ))","decl":"theorem memberSubfamily_union (a : α) (𝒜 ℬ : Finset (Finset α)) :\n    (𝒜 ∪ ℬ).memberSubfamily a = 𝒜.memberSubfamily a ∪ ℬ.memberSubfamily a := by\n  simp_rw [memberSubfamily, filter_union, image_union]\n\n"}
{"name":"Finset.card_memberSubfamily_add_card_nonMemberSubfamily","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n𝒜 : Finset (Finset α)\n⊢ Eq (HAdd.hAdd (Finset.memberSubfamily a 𝒜).card (Finset.nonMemberSubfamily a 𝒜).card) 𝒜.card","decl":"theorem card_memberSubfamily_add_card_nonMemberSubfamily (a : α) (𝒜 : Finset (Finset α)) :\n    #(𝒜.memberSubfamily a) + #(𝒜.nonMemberSubfamily a) = #𝒜 := by\n  rw [memberSubfamily, nonMemberSubfamily, card_image_of_injOn]\n  · conv_rhs => rw [← filter_card_add_filter_neg_card_eq_card (fun s => (a ∈ s))]\n  · apply (erase_injOn' _).mono\n    simp\n\n"}
{"name":"Finset.memberSubfamily_union_nonMemberSubfamily","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n𝒜 : Finset (Finset α)\n⊢ Eq (Union.union (Finset.memberSubfamily a 𝒜) (Finset.nonMemberSubfamily a 𝒜)) (Finset.image (fun s => s.erase a) 𝒜)","decl":"theorem memberSubfamily_union_nonMemberSubfamily (a : α) (𝒜 : Finset (Finset α)) :\n    𝒜.memberSubfamily a ∪ 𝒜.nonMemberSubfamily a = 𝒜.image fun s => s.erase a := by\n  ext s\n  simp only [mem_union, mem_memberSubfamily, mem_nonMemberSubfamily, mem_image, exists_prop]\n  constructor\n  · rintro (h | h)\n    · exact ⟨_, h.1, erase_insert h.2⟩\n    · exact ⟨_, h.1, erase_eq_of_not_mem h.2⟩\n  · rintro ⟨s, hs, rfl⟩\n    by_cases ha : a ∈ s\n    · exact Or.inl ⟨by rwa [insert_erase ha], not_mem_erase _ _⟩\n    · exact Or.inr ⟨by rwa [erase_eq_of_not_mem ha], not_mem_erase _ _⟩\n\n"}
{"name":"Finset.memberSubfamily_memberSubfamily","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\na : α\n⊢ Eq (Finset.memberSubfamily a (Finset.memberSubfamily a 𝒜)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem memberSubfamily_memberSubfamily : (𝒜.memberSubfamily a).memberSubfamily a = ∅ := by\n  ext\n  simp\n\n"}
{"name":"Finset.memberSubfamily_nonMemberSubfamily","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\na : α\n⊢ Eq (Finset.memberSubfamily a (Finset.nonMemberSubfamily a 𝒜)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem memberSubfamily_nonMemberSubfamily : (𝒜.nonMemberSubfamily a).memberSubfamily a = ∅ := by\n  ext\n  simp\n\n"}
{"name":"Finset.nonMemberSubfamily_memberSubfamily","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\na : α\n⊢ Eq (Finset.nonMemberSubfamily a (Finset.memberSubfamily a 𝒜)) (Finset.memberSubfamily a 𝒜)","decl":"@[simp]\ntheorem nonMemberSubfamily_memberSubfamily :\n    (𝒜.memberSubfamily a).nonMemberSubfamily a = 𝒜.memberSubfamily a := by\n  ext\n  simp\n\n"}
{"name":"Finset.nonMemberSubfamily_nonMemberSubfamily","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\na : α\n⊢ Eq (Finset.nonMemberSubfamily a (Finset.nonMemberSubfamily a 𝒜)) (Finset.nonMemberSubfamily a 𝒜)","decl":"@[simp]\ntheorem nonMemberSubfamily_nonMemberSubfamily :\n    (𝒜.nonMemberSubfamily a).nonMemberSubfamily a = 𝒜.nonMemberSubfamily a := by\n  ext\n  simp\n\n"}
{"name":"Finset.memberSubfamily_image_insert","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\na : α\nh𝒜 : ∀ (s : Finset α), Membership.mem 𝒜 s → Not (Membership.mem s a)\n⊢ Eq (Finset.memberSubfamily a (Finset.image (Insert.insert a) 𝒜)) 𝒜","decl":"lemma memberSubfamily_image_insert (h𝒜 : ∀ s ∈ 𝒜, a ∉ s) :\n    (𝒜.image <| insert a).memberSubfamily a = 𝒜 := by\n  ext s\n  simp only [mem_memberSubfamily, mem_image]\n  refine ⟨?_, fun hs ↦ ⟨⟨s, hs, rfl⟩, h𝒜 _ hs⟩⟩\n  rintro ⟨⟨t, ht, hts⟩, hs⟩\n  rwa [← insert_erase_invOn.2.injOn (h𝒜 _ ht) hs hts]\n\n"}
{"name":"Finset.nonMemberSubfamily_image_insert","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\na : α\n⊢ Eq (Finset.nonMemberSubfamily a (Finset.image (Insert.insert a) 𝒜)) EmptyCollection.emptyCollection","decl":"@[simp] lemma nonMemberSubfamily_image_insert : (𝒜.image <| insert a).nonMemberSubfamily a = ∅ := by\n  simp [eq_empty_iff_forall_not_mem]\n\n"}
{"name":"Finset.memberSubfamily_image_erase","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\na : α\n⊢ Eq (Finset.memberSubfamily a (Finset.image (fun x => x.erase a) 𝒜)) EmptyCollection.emptyCollection","decl":"@[simp] lemma memberSubfamily_image_erase : (𝒜.image (erase · a)).memberSubfamily a = ∅ := by\n  simp [eq_empty_iff_forall_not_mem,\n    (ne_of_mem_of_not_mem' (mem_insert_self _ _) (not_mem_erase _ _)).symm]\n\n"}
{"name":"Finset.image_insert_memberSubfamily","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\na : α\n⊢ Eq (Finset.image (Insert.insert a) (Finset.memberSubfamily a 𝒜)) (Finset.filter (fun s => Membership.mem s a) 𝒜)","decl":"lemma image_insert_memberSubfamily (𝒜 : Finset (Finset α)) (a : α) :\n    (𝒜.memberSubfamily a).image (insert a) = {s ∈ 𝒜 | a ∈ s} := by\n  ext s\n  simp only [mem_memberSubfamily, mem_image, mem_filter]\n  refine ⟨?_, fun ⟨hs, ha⟩ ↦ ⟨erase s a, ⟨?_, not_mem_erase _ _⟩, insert_erase ha⟩⟩\n  · rintro ⟨s, ⟨hs, -⟩, rfl⟩\n    exact ⟨hs, mem_insert_self _ _⟩\n  · rwa [insert_erase ha]\n\n"}
{"name":"Finset.memberFamily_induction_on","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\np : Finset (Finset α) → Prop\n𝒜 : Finset (Finset α)\nempty : p EmptyCollection.emptyCollection\nsingleton_empty : p (Singleton.singleton EmptyCollection.emptyCollection)\nsubfamily : ∀ (a : α) ⦃𝒜 : Finset (Finset α)⦄, p (Finset.nonMemberSubfamily a 𝒜) → p (Finset.memberSubfamily a 𝒜) → p 𝒜\n⊢ p 𝒜","decl":"/-- Induction principle for finset families. To prove a statement for every finset family,\nit suffices to prove it for\n* the empty finset family.\n* the finset family which only contains the empty finset.\n* `ℬ ∪ {s ∪ {a} | s ∈ 𝒞}` assuming the property for `ℬ` and `𝒞`, where `a` is an element of the\n  ground type and `𝒜` and `ℬ` are families of finsets not containing `a`.\n  Note that instead of giving `ℬ` and `𝒞`, the `subfamily` case gives you\n  `𝒜 = ℬ ∪ {s ∪ {a} | s ∈ 𝒞}`, so that `ℬ = 𝒜.nonMemberSubfamily` and `𝒞 = 𝒜.memberSubfamily`.\n\nThis is a way of formalising induction on `n` where `𝒜` is a finset family on `n` elements.\n\nSee also `Finset.family_induction_on.`-/\n@[elab_as_elim]\nlemma memberFamily_induction_on {p : Finset (Finset α) → Prop}\n    (𝒜 : Finset (Finset α)) (empty : p ∅) (singleton_empty : p {∅})\n    (subfamily : ∀ (a : α) ⦃𝒜 : Finset (Finset α)⦄,\n      p (𝒜.nonMemberSubfamily a) → p (𝒜.memberSubfamily a) → p 𝒜) : p 𝒜 := by\n  set u := 𝒜.sup id\n  have hu : ∀ s ∈ 𝒜, s ⊆ u := fun s ↦ le_sup (f := id)\n  clear_value u\n  induction' u using Finset.induction with a u _ ih generalizing 𝒜\n  · simp_rw [subset_empty] at hu\n    rw [← subset_singleton_iff', subset_singleton_iff] at hu\n    obtain rfl | rfl := hu <;> assumption\n  refine subfamily a (ih _ ?_) (ih _ ?_)\n  · simp only [mem_nonMemberSubfamily, and_imp]\n    exact fun s hs has ↦ (subset_insert_iff_of_not_mem has).1 <| hu _ hs\n  · simp only [mem_memberSubfamily, and_imp]\n    exact fun s hs ha ↦ (insert_subset_insert_iff ha).1 <| hu _ hs\n\n"}
{"name":"Finset.family_induction_on","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\np : Finset (Finset α) → Prop\n𝒜 : Finset (Finset α)\nempty : p EmptyCollection.emptyCollection\nsingleton_empty : p (Singleton.singleton EmptyCollection.emptyCollection)\nimage_insert : ∀ (a : α) ⦃𝒜 : Finset (Finset α)⦄, (∀ (s : Finset α), Membership.mem 𝒜 s → Not (Membership.mem s a)) → p 𝒜 → p (Finset.image (Insert.insert a) 𝒜)\nsubfamily : ∀ (a : α) ⦃𝒜 : Finset (Finset α)⦄, p (Finset.filter (fun s => Not (Membership.mem s a)) 𝒜) → p (Finset.filter (fun s => Membership.mem s a) 𝒜) → p 𝒜\n⊢ p 𝒜","decl":"/-- Induction principle for finset families. To prove a statement for every finset family,\nit suffices to prove it for\n* the empty finset family.\n* the finset family which only contains the empty finset.\n* `{s ∪ {a} | s ∈ 𝒜}` assuming the property for `𝒜` a family of finsets not containing `a`.\n* `ℬ ∪ 𝒞` assuming the property for `ℬ` and `𝒞`, where `a` is an element of the ground type and\n  `ℬ`is a family of finsets not containing `a` and `𝒞` a family of finsets containing `a`.\n  Note that instead of giving `ℬ` and `𝒞`, the `subfamily` case gives you `𝒜 = ℬ ∪ 𝒞`, so that\n  `ℬ = {s ∈ 𝒜 | a ∉ s}` and `𝒞 = {s ∈ 𝒜 | a ∈ s}`.\n\nThis is a way of formalising induction on `n` where `𝒜` is a finset family on `n` elements.\n\nSee also `Finset.memberFamily_induction_on.`-/\n@[elab_as_elim]\nprotected lemma family_induction_on {p : Finset (Finset α) → Prop}\n    (𝒜 : Finset (Finset α)) (empty : p ∅) (singleton_empty : p {∅})\n    (image_insert : ∀ (a : α) ⦃𝒜 : Finset (Finset α)⦄,\n      (∀ s ∈ 𝒜, a ∉ s) → p 𝒜 → p (𝒜.image <| insert a))\n    (subfamily : ∀ (a : α) ⦃𝒜 : Finset (Finset α)⦄,\n      p {s ∈ 𝒜 | a ∉ s} → p {s ∈ 𝒜 | a ∈ s} → p 𝒜) : p 𝒜 := by\n  refine memberFamily_induction_on 𝒜 empty singleton_empty fun a 𝒜 h𝒜₀ h𝒜₁ ↦ subfamily a h𝒜₀ ?_\n  rw [← image_insert_memberSubfamily]\n  exact image_insert _ (by simp) h𝒜₁\n\n"}
{"name":"Down.mem_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\ns : Finset α\na : α\n⊢ Iff (Membership.mem (Down.compression a 𝒜) s) (Or (And (Membership.mem 𝒜 s) (Membership.mem 𝒜 (s.erase a))) (And (Not (Membership.mem 𝒜 s)) (Membership.mem 𝒜 (Insert.insert a s))))","decl":"/-- `a` is in the down-compressed family iff it's in the original and its compression is in the\noriginal, or it's not in the original but it's the compression of something in the original. -/\ntheorem mem_compression : s ∈ 𝓓 a 𝒜 ↔ s ∈ 𝒜 ∧ s.erase a ∈ 𝒜 ∨ s ∉ 𝒜 ∧ insert a s ∈ 𝒜 := by\n  simp_rw [compression, mem_disjUnion, mem_filter, mem_image, and_comm (a := (¬ s ∈ 𝒜))]\n  refine\n    or_congr_right\n      (and_congr_left fun hs =>\n        ⟨?_, fun h => ⟨_, h, erase_insert <| insert_ne_self.1 <| ne_of_mem_of_not_mem h hs⟩⟩)\n  rintro ⟨t, ht, rfl⟩\n  rwa [insert_erase (erase_ne_self.1 (ne_of_mem_of_not_mem ht hs).symm)]\n\n"}
{"name":"Down.erase_mem_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\ns : Finset α\na : α\nhs : Membership.mem 𝒜 s\n⊢ Membership.mem (Down.compression a 𝒜) (s.erase a)","decl":"theorem erase_mem_compression (hs : s ∈ 𝒜) : s.erase a ∈ 𝓓 a 𝒜 := by\n  simp_rw [mem_compression, erase_idem, and_self_iff]\n  refine (em _).imp_right fun h => ⟨h, ?_⟩\n  rwa [insert_erase (erase_ne_self.1 (ne_of_mem_of_not_mem hs h).symm)]\n\n-- This is a special case of `erase_mem_compression` once we have `compression_idem`.\n"}
{"name":"Down.erase_mem_compression_of_mem_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\ns : Finset α\na : α\na✝ : Membership.mem (Down.compression a 𝒜) s\n⊢ Membership.mem (Down.compression a 𝒜) (s.erase a)","decl":"theorem erase_mem_compression_of_mem_compression : s ∈ 𝓓 a 𝒜 → s.erase a ∈ 𝓓 a 𝒜 := by\n  simp_rw [mem_compression, erase_idem]\n  refine Or.imp (fun h => ⟨h.2, h.2⟩) fun h => ?_\n  rwa [erase_eq_of_not_mem (insert_ne_self.1 <| ne_of_mem_of_not_mem h.2 h.1)]\n\n"}
{"name":"Down.mem_compression_of_insert_mem_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\ns : Finset α\na : α\nh : Membership.mem (Down.compression a 𝒜) (Insert.insert a s)\n⊢ Membership.mem (Down.compression a 𝒜) s","decl":"theorem mem_compression_of_insert_mem_compression (h : insert a s ∈ 𝓓 a 𝒜) : s ∈ 𝓓 a 𝒜 := by\n  by_cases ha : a ∈ s\n  · rwa [insert_eq_of_mem ha] at h\n  · rw [← erase_insert ha]\n    exact erase_mem_compression_of_mem_compression h\n\n"}
{"name":"Down.compression_idem","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n𝒜 : Finset (Finset α)\n⊢ Eq (Down.compression a (Down.compression a 𝒜)) (Down.compression a 𝒜)","decl":"/-- Down-compressing a family is idempotent. -/\n@[simp]\ntheorem compression_idem (a : α) (𝒜 : Finset (Finset α)) : 𝓓 a (𝓓 a 𝒜) = 𝓓 a 𝒜 := by\n  ext s\n  refine mem_compression.trans ⟨?_, fun h => Or.inl ⟨h, erase_mem_compression_of_mem_compression h⟩⟩\n  rintro (h | h)\n  · exact h.1\n  · cases h.1 (mem_compression_of_insert_mem_compression h.2)\n\n"}
{"name":"Down.card_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.Down","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n𝒜 : Finset (Finset α)\n⊢ Eq (Down.compression a 𝒜).card 𝒜.card","decl":"/-- Down-compressing a family doesn't change its size. -/\n@[simp]\ntheorem card_compression (a : α) (𝒜 : Finset (Finset α)) : #(𝓓 a 𝒜) = #𝒜 := by\n  rw [compression, card_disjUnion, filter_image,\n    card_image_of_injOn ((erase_injOn' _).mono fun s hs => _), ← card_union_of_disjoint]\n  · conv_rhs => rw [← filter_union_filter_neg_eq (fun s => (erase s a ∈ 𝒜)) 𝒜]\n  · exact disjoint_filter_filter_neg 𝒜 𝒜 (fun s => (erase s a ∈ 𝒜))\n  intro s hs\n  rw [mem_coe, mem_filter] at hs\n  exact not_imp_comm.1 erase_eq_of_not_mem (ne_of_mem_of_not_mem hs.1 hs.2).symm\n\n"}
