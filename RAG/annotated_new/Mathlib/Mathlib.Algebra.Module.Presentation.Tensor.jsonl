{"name":"Module.Relations.tensor_R","module":"Mathlib.Algebra.Module.Presentation.Tensor","initialProofState":"A : Type u\ninst✝ : CommRing A\nrelations₁ : Module.Relations A\nrelations₂ : Module.Relations A\n⊢ Eq (relations₁.tensor relations₂).R (Sum (Prod relations₁.R relations₂.G) (Prod relations₁.G relations₂.R))","decl":"/-- The tensor product of systems of linear equations. -/\n@[simps]\nnoncomputable def tensor :\n    Relations A where\n  G := relations₁.G × relations₂.G\n  R := Sum (relations₁.R × relations₂.G) (relations₁.G × relations₂.R)\n  relation\n    | .inl ⟨r₁, g₂⟩ => Finsupp.embDomain (Function.Embedding.sectL relations₁.G g₂)\n        (relations₁.relation r₁)\n    | .inr ⟨g₁, r₂⟩ => Finsupp.embDomain (Function.Embedding.sectR g₁ relations₂.G)\n        (relations₂.relation r₂)\n\n"}
{"name":"Module.Relations.tensor_G","module":"Mathlib.Algebra.Module.Presentation.Tensor","initialProofState":"A : Type u\ninst✝ : CommRing A\nrelations₁ : Module.Relations A\nrelations₂ : Module.Relations A\n⊢ Eq (relations₁.tensor relations₂).G (Prod relations₁.G relations₂.G)","decl":"/-- The tensor product of systems of linear equations. -/\n@[simps]\nnoncomputable def tensor :\n    Relations A where\n  G := relations₁.G × relations₂.G\n  R := Sum (relations₁.R × relations₂.G) (relations₁.G × relations₂.R)\n  relation\n    | .inl ⟨r₁, g₂⟩ => Finsupp.embDomain (Function.Embedding.sectL relations₁.G g₂)\n        (relations₁.relation r₁)\n    | .inr ⟨g₁, r₂⟩ => Finsupp.embDomain (Function.Embedding.sectR g₁ relations₂.G)\n        (relations₂.relation r₂)\n\n"}
{"name":"Module.Relations.tensor_relation","module":"Mathlib.Algebra.Module.Presentation.Tensor","initialProofState":"A : Type u\ninst✝ : CommRing A\nrelations₁ : Module.Relations A\nrelations₂ : Module.Relations A\nx✝ : Sum (Prod relations₁.R relations₂.G) (Prod relations₁.G relations₂.R)\n⊢ Eq ((relations₁.tensor relations₂).relation x✝) (Module.Relations.tensor.match_1 relations₁ relations₂ (fun x => Finsupp (Prod relations₁.G relations₂.G) A) x✝ (fun r₁ g₂ => Finsupp.embDomain (Function.Embedding.sectL relations₁.G g₂) (relations₁.relation r₁)) fun g₁ r₂ => Finsupp.embDomain (Function.Embedding.sectR g₁ relations₂.G) (relations₂.relation r₂))","decl":"/-- The tensor product of systems of linear equations. -/\n@[simps]\nnoncomputable def tensor :\n    Relations A where\n  G := relations₁.G × relations₂.G\n  R := Sum (relations₁.R × relations₂.G) (relations₁.G × relations₂.R)\n  relation\n    | .inl ⟨r₁, g₂⟩ => Finsupp.embDomain (Function.Embedding.sectL relations₁.G g₂)\n        (relations₁.relation r₁)\n    | .inr ⟨g₁, r₂⟩ => Finsupp.embDomain (Function.Embedding.sectR g₁ relations₂.G)\n        (relations₂.relation r₂)\n\n"}
{"name":"Module.Relations.Solution.tensor_var","module":"Mathlib.Algebra.Module.Presentation.Tensor","initialProofState":"A : Type u\ninst✝⁴ : CommRing A\nM₁ : Type v₁\nM₂ : Type v₂\ninst✝³ : AddCommGroup M₁\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module A M₁\ninst✝ : Module A M₂\nrelations₁ : Module.Relations A\nrelations₂ : Module.Relations A\nsolution₁ : relations₁.Solution M₁\nsolution₂ : relations₂.Solution M₂\nx✝ : (relations₁.tensor relations₂).G\n⊢ Eq ((solution₁.tensor solution₂).var x✝) (Module.Relations.Solution.tensor.match_1 (fun x => TensorProduct A M₁ M₂) x✝ fun g₁ g₂ => TensorProduct.tmul A (solution₁.var g₁) (solution₂.var g₂))","decl":"/-- Given solutions in `M₁` and `M₂` to systems of linear equations, this is the obvious\nsolution to the tensor product of these systems in `M₁ ⊗[A] M₂`. -/\n@[simps]\nnoncomputable def tensor : (relations₁.tensor relations₂).Solution (M₁ ⊗[A] M₂) where\n  var := fun ⟨g₁, g₂⟩ => solution₁.var g₁ ⊗ₜ solution₂.var g₂\n  linearCombination_var_relation := by\n    rintro (⟨r₁, g₂⟩ | ⟨g₁, r₂⟩)\n    · dsimp\n      rw [Finsupp.linearCombination_embDomain]\n      exact (solution₁.postcomp (curry (TensorProduct.comm A M₂ M₁).toLinearMap\n        (solution₂.var g₂))).linearCombination_var_relation r₁\n    · dsimp\n      rw [Finsupp.linearCombination_embDomain]\n      exact (solution₂.postcomp (curry .id (solution₁.var g₁))).linearCombination_var_relation r₂\n\n"}
{"name":"Module.Relations.Solution.IsPresentation.tensor","module":"Mathlib.Algebra.Module.Presentation.Tensor","initialProofState":"A : Type u\ninst✝⁴ : CommRing A\nM₁ : Type v₁\nM₂ : Type v₂\ninst✝³ : AddCommGroup M₁\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module A M₁\ninst✝ : Module A M₂\nrelations₁ : Module.Relations A\nrelations₂ : Module.Relations A\nsolution₁ : relations₁.Solution M₁\nsolution₂ : relations₂.Solution M₂\nh₁ : solution₁.IsPresentation\nh₂ : solution₂.IsPresentation\n⊢ (solution₁.tensor solution₂).IsPresentation","decl":"include h₁ h₂ in\nlemma IsPresentation.tensor : (solution₁.tensor solution₂).IsPresentation :=\n  (isPresentationCoreTensor h₁ h₂).isPresentation\n\n"}
{"name":"Module.Presentation.tensor_relation","module":"Mathlib.Algebra.Module.Presentation.Tensor","initialProofState":"A : Type u\ninst✝⁴ : CommRing A\nM₁ : Type v₁\nM₂ : Type v₂\ninst✝³ : AddCommGroup M₁\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module A M₁\ninst✝ : Module A M₂\npres₁ : Module.Presentation A M₁\npres₂ : Module.Presentation A M₂\nx✝ : Sum (Prod pres₁.R pres₂.G) (Prod pres₁.G pres₂.R)\n⊢ Eq ((pres₁.tensor pres₂).relation x✝) (Module.Relations.tensor.match_1 pres₁.toRelations pres₂.toRelations (fun x => Finsupp (Prod pres₁.G pres₂.G) A) x✝ (fun r₁ g₂ => Finsupp.embDomain (Function.Embedding.sectL pres₁.G g₂) (pres₁.relation r₁)) fun g₁ r₂ => Finsupp.embDomain (Function.Embedding.sectR g₁ pres₂.G) (pres₂.relation r₂))","decl":"/-- The presentation of the `A`-module `M₁ ⊗[A] M₂` that is deduced from\na presentation of `M₁` and a presentation of `M₂`. -/\n@[simps!]\nnoncomputable def tensor : Presentation A (M₁ ⊗[A] M₂) where\n  toSolution := pres₁.toSolution.tensor pres₂.toSolution\n  toIsPresentation := pres₁.toIsPresentation.tensor pres₂.toIsPresentation\n\n"}
{"name":"Module.Presentation.tensor_G","module":"Mathlib.Algebra.Module.Presentation.Tensor","initialProofState":"A : Type u\ninst✝⁴ : CommRing A\nM₁ : Type v₁\nM₂ : Type v₂\ninst✝³ : AddCommGroup M₁\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module A M₁\ninst✝ : Module A M₂\npres₁ : Module.Presentation A M₁\npres₂ : Module.Presentation A M₂\n⊢ Eq (pres₁.tensor pres₂).G (Prod pres₁.G pres₂.G)","decl":"/-- The presentation of the `A`-module `M₁ ⊗[A] M₂` that is deduced from\na presentation of `M₁` and a presentation of `M₂`. -/\n@[simps!]\nnoncomputable def tensor : Presentation A (M₁ ⊗[A] M₂) where\n  toSolution := pres₁.toSolution.tensor pres₂.toSolution\n  toIsPresentation := pres₁.toIsPresentation.tensor pres₂.toIsPresentation\n\n"}
{"name":"Module.Presentation.tensor_var","module":"Mathlib.Algebra.Module.Presentation.Tensor","initialProofState":"A : Type u\ninst✝⁴ : CommRing A\nM₁ : Type v₁\nM₂ : Type v₂\ninst✝³ : AddCommGroup M₁\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module A M₁\ninst✝ : Module A M₂\npres₁ : Module.Presentation A M₁\npres₂ : Module.Presentation A M₂\nx✝ : (pres₁.tensor pres₂.toRelations).G\n⊢ Eq ((pres₁.tensor pres₂).var x✝) (Module.Relations.Solution.tensor.match_1 (fun x => TensorProduct A M₁ M₂) x✝ fun g₁ g₂ => TensorProduct.tmul A (pres₁.var g₁) (pres₂.var g₂))","decl":"/-- The presentation of the `A`-module `M₁ ⊗[A] M₂` that is deduced from\na presentation of `M₁` and a presentation of `M₂`. -/\n@[simps!]\nnoncomputable def tensor : Presentation A (M₁ ⊗[A] M₂) where\n  toSolution := pres₁.toSolution.tensor pres₂.toSolution\n  toIsPresentation := pres₁.toIsPresentation.tensor pres₂.toIsPresentation\n\n"}
{"name":"Module.Presentation.tensor_R","module":"Mathlib.Algebra.Module.Presentation.Tensor","initialProofState":"A : Type u\ninst✝⁴ : CommRing A\nM₁ : Type v₁\nM₂ : Type v₂\ninst✝³ : AddCommGroup M₁\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module A M₁\ninst✝ : Module A M₂\npres₁ : Module.Presentation A M₁\npres₂ : Module.Presentation A M₂\n⊢ Eq (pres₁.tensor pres₂).R (Sum (Prod pres₁.R pres₂.G) (Prod pres₁.G pres₂.R))","decl":"/-- The presentation of the `A`-module `M₁ ⊗[A] M₂` that is deduced from\na presentation of `M₁` and a presentation of `M₂`. -/\n@[simps!]\nnoncomputable def tensor : Presentation A (M₁ ⊗[A] M₂) where\n  toSolution := pres₁.toSolution.tensor pres₂.toSolution\n  toIsPresentation := pres₁.toIsPresentation.tensor pres₂.toIsPresentation\n\n"}
