{"name":"EuclideanDomain.toMulDivCancelClass","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\n⊢ MulDivCancelClass R","decl":"instance (priority := 100) toMulDivCancelClass : MulDivCancelClass R where\n  mul_div_cancel a b hb := by\n    refine (eq_of_sub_eq_zero ?_).symm\n    by_contra h\n    have := mul_right_not_lt b h\n    rw [sub_mul, mul_comm (_ / _), sub_eq_iff_eq_add'.2 (div_add_mod (a * b) b).symm] at this\n    exact this (mod_lt _ hb)\n\n"}
{"name":"EuclideanDomain.mod_eq_zero","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\na b : R\n⊢ Iff (Eq (HMod.hMod a b) 0) (Dvd.dvd b a)","decl":"@[simp]\ntheorem mod_eq_zero {a b : R} : a % b = 0 ↔ b ∣ a :=\n  ⟨fun h => by\n    rw [← div_add_mod a b, h, add_zero]\n    exact dvd_mul_right _ _, fun ⟨c, e⟩ => by\n    rw [e, ← add_left_cancel_iff, div_add_mod, add_zero]\n    haveI := Classical.dec\n    by_cases b0 : b = 0\n    · simp only [b0, zero_mul]\n    · rw [mul_div_cancel_left₀ _ b0]⟩\n\n"}
{"name":"EuclideanDomain.mod_self","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\na : R\n⊢ Eq (HMod.hMod a a) 0","decl":"@[simp]\ntheorem mod_self (a : R) : a % a = 0 :=\n  mod_eq_zero.2 dvd_rfl\n\n"}
{"name":"EuclideanDomain.dvd_mod_iff","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\na b c : R\nh : Dvd.dvd c b\n⊢ Iff (Dvd.dvd c (HMod.hMod a b)) (Dvd.dvd c a)","decl":"theorem dvd_mod_iff {a b c : R} (h : c ∣ b) : c ∣ a % b ↔ c ∣ a := by\n  rw [← dvd_add_right (h.mul_right _), div_add_mod]\n\n"}
{"name":"EuclideanDomain.mod_one","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\na : R\n⊢ Eq (HMod.hMod a 1) 0","decl":"@[simp]\ntheorem mod_one (a : R) : a % 1 = 0 :=\n  mod_eq_zero.2 (one_dvd _)\n\n"}
{"name":"EuclideanDomain.zero_mod","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\nb : R\n⊢ Eq (HMod.hMod 0 b) 0","decl":"@[simp]\ntheorem zero_mod (b : R) : 0 % b = 0 :=\n  mod_eq_zero.2 (dvd_zero _)\n\n"}
{"name":"EuclideanDomain.zero_div","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\na : R\n⊢ Eq (HDiv.hDiv 0 a) 0","decl":"@[simp]\ntheorem zero_div {a : R} : 0 / a = 0 :=\n  by_cases (fun a0 : a = 0 => a0.symm ▸ div_zero 0) fun a0 => by\n    simpa only [zero_mul] using mul_div_cancel_right₀ 0 a0\n\n"}
{"name":"EuclideanDomain.div_self","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\na : R\na0 : Ne a 0\n⊢ Eq (HDiv.hDiv a a) 1","decl":"@[simp]\ntheorem div_self {a : R} (a0 : a ≠ 0) : a / a = 1 := by\n  simpa only [one_mul] using mul_div_cancel_right₀ 1 a0\n\n"}
{"name":"EuclideanDomain.eq_div_of_mul_eq_left","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\na b c : R\nhb : Ne b 0\nh : Eq (HMul.hMul a b) c\n⊢ Eq a (HDiv.hDiv c b)","decl":"theorem eq_div_of_mul_eq_left {a b c : R} (hb : b ≠ 0) (h : a * b = c) : a = c / b := by\n  rw [← h, mul_div_cancel_right₀ _ hb]\n\n"}
{"name":"EuclideanDomain.eq_div_of_mul_eq_right","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\na b c : R\nha : Ne a 0\nh : Eq (HMul.hMul a b) c\n⊢ Eq b (HDiv.hDiv c a)","decl":"theorem eq_div_of_mul_eq_right {a b c : R} (ha : a ≠ 0) (h : a * b = c) : b = c / a := by\n  rw [← h, mul_div_cancel_left₀ _ ha]\n\n"}
{"name":"EuclideanDomain.mul_div_assoc","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\nx y z : R\nh : Dvd.dvd z y\n⊢ Eq (HDiv.hDiv (HMul.hMul x y) z) (HMul.hMul x (HDiv.hDiv y z))","decl":"theorem mul_div_assoc (x : R) {y z : R} (h : z ∣ y) : x * y / z = x * (y / z) := by\n  by_cases hz : z = 0\n  · subst hz\n    rw [div_zero, div_zero, mul_zero]\n  rcases h with ⟨p, rfl⟩\n  rw [mul_div_cancel_left₀ _ hz, mul_left_comm, mul_div_cancel_left₀ _ hz]\n\n"}
{"name":"EuclideanDomain.mul_div_cancel'","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\na b : R\nhb : Ne b 0\nhab : Dvd.dvd b a\n⊢ Eq (HMul.hMul b (HDiv.hDiv a b)) a","decl":"protected theorem mul_div_cancel' {a b : R} (hb : b ≠ 0) (hab : b ∣ a) : b * (a / b) = a := by\n  rw [← mul_div_assoc _ hab, mul_div_cancel_left₀ _ hb]\n\n-- This generalizes `Int.div_one`, see note [simp-normal form]\n"}
{"name":"EuclideanDomain.div_one","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\np : R\n⊢ Eq (HDiv.hDiv p 1) p","decl":"@[simp]\ntheorem div_one (p : R) : p / 1 = p :=\n  (EuclideanDomain.eq_div_of_mul_eq_left (one_ne_zero' R) (mul_one p)).symm\n\n"}
{"name":"EuclideanDomain.div_dvd_of_dvd","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\np q : R\nhpq : Dvd.dvd q p\n⊢ Dvd.dvd (HDiv.hDiv p q) p","decl":"theorem div_dvd_of_dvd {p q : R} (hpq : q ∣ p) : p / q ∣ p := by\n  by_cases hq : q = 0\n  · rw [hq, zero_dvd_iff] at hpq\n    rw [hpq]\n    exact dvd_zero _\n  use q\n  rw [mul_comm, ← EuclideanDomain.mul_div_assoc _ hpq, mul_comm, mul_div_cancel_right₀ _ hq]\n\n"}
{"name":"EuclideanDomain.dvd_div_of_mul_dvd","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\na b c : R\nh : Dvd.dvd (HMul.hMul a b) c\n⊢ Dvd.dvd b (HDiv.hDiv c a)","decl":"theorem dvd_div_of_mul_dvd {a b c : R} (h : a * b ∣ c) : b ∣ c / a := by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  · simp only [div_zero, dvd_zero]\n  rcases h with ⟨d, rfl⟩\n  refine ⟨d, ?_⟩\n  rw [mul_assoc, mul_div_cancel_left₀ _ ha]\n\n"}
{"name":"EuclideanDomain.gcd_zero_right","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\na : R\n⊢ Eq (EuclideanDomain.gcd a 0) a","decl":"@[simp]\ntheorem gcd_zero_right (a : R) : gcd a 0 = a := by\n  rw [gcd]\n  split_ifs with h <;> simp only [h, zero_mod, gcd_zero_left]\n\n"}
{"name":"EuclideanDomain.gcd_val","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\na b : R\n⊢ Eq (EuclideanDomain.gcd a b) (EuclideanDomain.gcd (HMod.hMod b a) a)","decl":"theorem gcd_val (a b : R) : gcd a b = gcd (b % a) a := by\n  rw [gcd]\n  split_ifs with h <;> [simp only [h, mod_zero, gcd_zero_right]; rfl]\n\n"}
{"name":"EuclideanDomain.gcd_dvd","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\na b : R\n⊢ And (Dvd.dvd (EuclideanDomain.gcd a b) a) (Dvd.dvd (EuclideanDomain.gcd a b) b)","decl":"theorem gcd_dvd (a b : R) : gcd a b ∣ a ∧ gcd a b ∣ b :=\n  GCD.induction a b\n    (fun b => by\n      rw [gcd_zero_left]\n      exact ⟨dvd_zero _, dvd_rfl⟩)\n    fun a b _ ⟨IH₁, IH₂⟩ => by\n    rw [gcd_val]\n    exact ⟨IH₂, (dvd_mod_iff IH₂).1 IH₁⟩\n\n"}
{"name":"EuclideanDomain.gcd_dvd_left","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\na b : R\n⊢ Dvd.dvd (EuclideanDomain.gcd a b) a","decl":"theorem gcd_dvd_left (a b : R) : gcd a b ∣ a :=\n  (gcd_dvd a b).left\n\n"}
{"name":"EuclideanDomain.gcd_dvd_right","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\na b : R\n⊢ Dvd.dvd (EuclideanDomain.gcd a b) b","decl":"theorem gcd_dvd_right (a b : R) : gcd a b ∣ b :=\n  (gcd_dvd a b).right\n\n"}
{"name":"EuclideanDomain.gcd_eq_zero_iff","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\na b : R\n⊢ Iff (Eq (EuclideanDomain.gcd a b) 0) (And (Eq a 0) (Eq b 0))","decl":"protected theorem gcd_eq_zero_iff {a b : R} : gcd a b = 0 ↔ a = 0 ∧ b = 0 :=\n  ⟨fun h => by simpa [h] using gcd_dvd a b, by\n    rintro ⟨rfl, rfl⟩\n    exact gcd_zero_right _⟩\n\n"}
{"name":"EuclideanDomain.dvd_gcd","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\na b c : R\na✝¹ : Dvd.dvd c a\na✝ : Dvd.dvd c b\n⊢ Dvd.dvd c (EuclideanDomain.gcd a b)","decl":"theorem dvd_gcd {a b c : R} : c ∣ a → c ∣ b → c ∣ gcd a b :=\n  GCD.induction a b (fun _ _ H => by simpa only [gcd_zero_left] using H) fun a b _ IH ca cb => by\n    rw [gcd_val]\n    exact IH ((dvd_mod_iff ca).2 cb) ca\n\n"}
{"name":"EuclideanDomain.gcd_eq_left","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\na b : R\n⊢ Iff (Eq (EuclideanDomain.gcd a b) a) (Dvd.dvd a b)","decl":"theorem gcd_eq_left {a b : R} : gcd a b = a ↔ a ∣ b :=\n  ⟨fun h => by\n    rw [← h]\n    apply gcd_dvd_right, fun h => by rw [gcd_val, mod_eq_zero.2 h, gcd_zero_left]⟩\n\n"}
{"name":"EuclideanDomain.gcd_one_left","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\na : R\n⊢ Eq (EuclideanDomain.gcd 1 a) 1","decl":"@[simp]\ntheorem gcd_one_left (a : R) : gcd 1 a = 1 :=\n  gcd_eq_left.2 (one_dvd _)\n\n"}
{"name":"EuclideanDomain.gcd_self","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\na : R\n⊢ Eq (EuclideanDomain.gcd a a) a","decl":"@[simp]\ntheorem gcd_self (a : R) : gcd a a = a :=\n  gcd_eq_left.2 dvd_rfl\n\n"}
{"name":"EuclideanDomain.xgcdAux_fst","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\nx y s t s' t' : R\n⊢ Eq (EuclideanDomain.xgcdAux x s t y s' t').1 (EuclideanDomain.gcd x y)","decl":"@[simp]\ntheorem xgcdAux_fst (x y : R) : ∀ s t s' t', (xgcdAux x s t y s' t').1 = gcd x y :=\n  GCD.induction x y\n    (by\n      intros\n      rw [xgcd_zero_left, gcd_zero_left])\n    fun x y h IH s t s' t' => by\n    simp only [xgcdAux_rec h, if_neg h, IH]\n    rw [← gcd_val]\n\n"}
{"name":"EuclideanDomain.xgcdAux_val","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\nx y : R\n⊢ Eq (EuclideanDomain.xgcdAux x 1 0 y 0 1) { fst := EuclideanDomain.gcd x y, snd := EuclideanDomain.xgcd x y }","decl":"theorem xgcdAux_val (x y : R) : xgcdAux x 1 0 y 0 1 = (gcd x y, xgcd x y) := by\n  rw [xgcd, ← xgcdAux_fst x y 1 0 0 1]\n\n"}
{"name":"EuclideanDomain.xgcdAux_P","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\na b r r' s t s' t' : R\np : EuclideanDomain.P a b { fst := r, snd := { fst := s, snd := t } }\np' : EuclideanDomain.P a b { fst := r', snd := { fst := s', snd := t' } }\n⊢ EuclideanDomain.P a b (EuclideanDomain.xgcdAux r s t r' s' t')","decl":"theorem xgcdAux_P (a b : R) {r r' : R} {s t s' t'} (p : P a b (r, s, t))\n    (p' : P a b (r', s', t')) : P a b (xgcdAux r s t r' s' t') := by\n  induction r, r' using GCD.induction generalizing s t s' t' with\n  | H0 n => simpa only [xgcd_zero_left]\n  | H1 _ _ h IH =>\n    rw [xgcdAux_rec h]\n    refine IH ?_ p\n    unfold P at p p' ⊢\n    dsimp\n    rw [mul_sub, mul_sub, add_sub, sub_add_eq_add_sub, ← p', sub_sub, mul_comm _ s, ← mul_assoc,\n      mul_comm _ t, ← mul_assoc, ← add_mul, ← p, mod_eq_sub_mul_div]\n\n"}
{"name":"EuclideanDomain.gcd_eq_gcd_ab","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\na b : R\n⊢ Eq (EuclideanDomain.gcd a b) (HAdd.hAdd (HMul.hMul a (EuclideanDomain.gcdA a b)) (HMul.hMul b (EuclideanDomain.gcdB a b)))","decl":"/-- An explicit version of **Bézout's lemma** for Euclidean domains. -/\ntheorem gcd_eq_gcd_ab (a b : R) : (gcd a b : R) = a * gcdA a b + b * gcdB a b := by\n  have :=\n    @xgcdAux_P _ _ _ a b a b 1 0 0 1 (by dsimp [P]; rw [mul_one, mul_zero, add_zero])\n      (by dsimp [P]; rw [mul_one, mul_zero, zero_add])\n  rwa [xgcdAux_val, xgcd_val] at this\n\n-- see Note [lower instance priority]\n"}
{"name":"EuclideanDomain.instNoZeroDivisors","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u_1\ne : EuclideanDomain R\n⊢ NoZeroDivisors R","decl":"instance (priority := 70) (R : Type*) [e : EuclideanDomain R] : NoZeroDivisors R :=\n  haveI := Classical.decEq R\n  { eq_zero_or_eq_zero_of_mul_eq_zero := fun {a b} h =>\n      or_iff_not_and_not.2 fun h0 => h0.1 <| by rw [← mul_div_cancel_right₀ a h0.2, h, zero_div] }\n\n-- see Note [lower instance priority]\n"}
{"name":"EuclideanDomain.instIsDomain","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u_1\ne : EuclideanDomain R\n⊢ IsDomain R","decl":"instance (priority := 70) (R : Type*) [e : EuclideanDomain R] : IsDomain R :=\n  { e, NoZeroDivisors.to_isDomain R with }\n\n"}
{"name":"EuclideanDomain.dvd_lcm_left","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\nx y : R\n⊢ Dvd.dvd x (EuclideanDomain.lcm x y)","decl":"theorem dvd_lcm_left (x y : R) : x ∣ lcm x y :=\n  by_cases\n    (fun hxy : gcd x y = 0 => by\n      rw [lcm, hxy, div_zero]\n      exact dvd_zero _)\n    fun hxy =>\n    let ⟨z, hz⟩ := (gcd_dvd x y).2\n    ⟨z, Eq.symm <| eq_div_of_mul_eq_left hxy <| by rw [mul_right_comm, mul_assoc, ← hz]⟩\n\n"}
{"name":"EuclideanDomain.dvd_lcm_right","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\nx y : R\n⊢ Dvd.dvd y (EuclideanDomain.lcm x y)","decl":"theorem dvd_lcm_right (x y : R) : y ∣ lcm x y :=\n  by_cases\n    (fun hxy : gcd x y = 0 => by\n      rw [lcm, hxy, div_zero]\n      exact dvd_zero _)\n    fun hxy =>\n    let ⟨z, hz⟩ := (gcd_dvd x y).1\n    ⟨z, Eq.symm <| eq_div_of_mul_eq_right hxy <| by rw [← mul_assoc, mul_right_comm, ← hz]⟩\n\n"}
{"name":"EuclideanDomain.lcm_dvd","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\nx y z : R\nhxz : Dvd.dvd x z\nhyz : Dvd.dvd y z\n⊢ Dvd.dvd (EuclideanDomain.lcm x y) z","decl":"theorem lcm_dvd {x y z : R} (hxz : x ∣ z) (hyz : y ∣ z) : lcm x y ∣ z := by\n  rw [lcm]\n  by_cases hxy : gcd x y = 0\n  · rw [hxy, div_zero]\n    rw [EuclideanDomain.gcd_eq_zero_iff] at hxy\n    rwa [hxy.1] at hxz\n  rcases gcd_dvd x y with ⟨⟨r, hr⟩, ⟨s, hs⟩⟩\n  suffices x * y ∣ z * gcd x y by\n    obtain ⟨p, hp⟩ := this\n    use p\n    generalize gcd x y = g at hxy hs hp ⊢\n    subst hs\n    rw [mul_left_comm, mul_div_cancel_left₀ _ hxy, ← mul_left_inj' hxy, hp]\n    rw [← mul_assoc]\n    simp only [mul_right_comm]\n  rw [gcd_eq_gcd_ab, mul_add]\n  apply dvd_add\n  · rw [mul_left_comm]\n    exact mul_dvd_mul_left _ (hyz.mul_right _)\n  · rw [mul_left_comm, mul_comm]\n    exact mul_dvd_mul_left _ (hxz.mul_right _)\n\n"}
{"name":"EuclideanDomain.lcm_dvd_iff","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\nx y z : R\n⊢ Iff (Dvd.dvd (EuclideanDomain.lcm x y) z) (And (Dvd.dvd x z) (Dvd.dvd y z))","decl":"@[simp]\ntheorem lcm_dvd_iff {x y z : R} : lcm x y ∣ z ↔ x ∣ z ∧ y ∣ z :=\n  ⟨fun hz => ⟨(dvd_lcm_left _ _).trans hz, (dvd_lcm_right _ _).trans hz⟩, fun ⟨hxz, hyz⟩ =>\n    lcm_dvd hxz hyz⟩\n\n"}
{"name":"EuclideanDomain.lcm_zero_left","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\nx : R\n⊢ Eq (EuclideanDomain.lcm 0 x) 0","decl":"@[simp]\ntheorem lcm_zero_left (x : R) : lcm 0 x = 0 := by rw [lcm, zero_mul, zero_div]\n\n"}
{"name":"EuclideanDomain.lcm_zero_right","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\nx : R\n⊢ Eq (EuclideanDomain.lcm x 0) 0","decl":"@[simp]\ntheorem lcm_zero_right (x : R) : lcm x 0 = 0 := by rw [lcm, mul_zero, zero_div]\n\n"}
{"name":"EuclideanDomain.lcm_eq_zero_iff","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\nx y : R\n⊢ Iff (Eq (EuclideanDomain.lcm x y) 0) (Or (Eq x 0) (Eq y 0))","decl":"@[simp]\ntheorem lcm_eq_zero_iff {x y : R} : lcm x y = 0 ↔ x = 0 ∨ y = 0 := by\n  constructor\n  · intro hxy\n    rw [lcm, mul_div_assoc _ (gcd_dvd_right _ _), mul_eq_zero] at hxy\n    apply Or.imp_right _ hxy\n    intro hy\n    by_cases hgxy : gcd x y = 0\n    · rw [EuclideanDomain.gcd_eq_zero_iff] at hgxy\n      exact hgxy.2\n    · rcases gcd_dvd x y with ⟨⟨r, hr⟩, ⟨s, hs⟩⟩\n      generalize gcd x y = g at hr hs hy hgxy ⊢\n      subst hs\n      rw [mul_div_cancel_left₀ _ hgxy] at hy\n      rw [hy, mul_zero]\n  rintro (hx | hy)\n  · rw [hx, lcm_zero_left]\n  · rw [hy, lcm_zero_right]\n\n"}
{"name":"EuclideanDomain.gcd_mul_lcm","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\nx y : R\n⊢ Eq (HMul.hMul (EuclideanDomain.gcd x y) (EuclideanDomain.lcm x y)) (HMul.hMul x y)","decl":"@[simp]\ntheorem gcd_mul_lcm (x y : R) : gcd x y * lcm x y = x * y := by\n  rw [lcm]; by_cases h : gcd x y = 0\n  · rw [h, zero_mul]\n    rw [EuclideanDomain.gcd_eq_zero_iff] at h\n    rw [h.1, zero_mul]\n  rcases gcd_dvd x y with ⟨⟨r, hr⟩, ⟨s, hs⟩⟩\n  generalize gcd x y = g at h hr ⊢; subst hr\n  rw [mul_assoc, mul_div_cancel_left₀ _ h]\n\n"}
{"name":"EuclideanDomain.mul_div_mul_cancel","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\na b c : R\nha : Ne a 0\nhcb : Dvd.dvd c b\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) (HMul.hMul a c)) (HDiv.hDiv b c)","decl":"theorem mul_div_mul_cancel {a b c : R} (ha : a ≠ 0) (hcb : c ∣ b) : a * b / (a * c) = b / c := by\n  by_cases hc : c = 0; · simp [hc]\n  refine eq_div_of_mul_eq_right hc (mul_left_cancel₀ ha ?_)\n  rw [← mul_assoc, ← mul_div_assoc _ (mul_dvd_mul_left a hcb),\n    mul_div_cancel_left₀ _ (mul_ne_zero ha hc)]\n\n"}
{"name":"EuclideanDomain.mul_div_mul_comm_of_dvd_dvd","module":"Mathlib.Algebra.EuclideanDomain.Basic","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\na b c d : R\nhac : Dvd.dvd c a\nhbd : Dvd.dvd d b\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) (HMul.hMul c d)) (HMul.hMul (HDiv.hDiv a c) (HDiv.hDiv b d))","decl":"theorem mul_div_mul_comm_of_dvd_dvd {a b c d : R} (hac : c ∣ a) (hbd : d ∣ b) :\n    a * b / (c * d) = a / c * (b / d) := by\n  rcases eq_or_ne c 0 with (rfl | hc0); · simp\n  rcases eq_or_ne d 0 with (rfl | hd0); · simp\n  obtain ⟨k1, rfl⟩ := hac\n  obtain ⟨k2, rfl⟩ := hbd\n  rw [mul_div_cancel_left₀ _ hc0, mul_div_cancel_left₀ _ hd0, mul_mul_mul_comm,\n    mul_div_cancel_left₀ _ (mul_ne_zero hc0 hd0)]\n\n"}
