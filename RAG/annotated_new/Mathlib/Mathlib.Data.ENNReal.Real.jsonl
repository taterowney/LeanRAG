{"name":"ENNReal.toReal_add","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\nha : Ne a Top.top\nhb : Ne b Top.top\n⊢ Eq (HAdd.hAdd a b).toReal (HAdd.hAdd a.toReal b.toReal)","decl":"theorem toReal_add (ha : a ≠ ∞) (hb : b ≠ ∞) : (a + b).toReal = a.toReal + b.toReal := by\n  lift a to ℝ≥0 using ha\n  lift b to ℝ≥0 using hb\n  rfl\n\n"}
{"name":"ENNReal.toReal_sub_of_le","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\nh : LE.le b a\nha : Ne a Top.top\n⊢ Eq (HSub.hSub a b).toReal (HSub.hSub a.toReal b.toReal)","decl":"theorem toReal_sub_of_le {a b : ℝ≥0∞} (h : b ≤ a) (ha : a ≠ ∞) :\n    (a - b).toReal = a.toReal - b.toReal := by\n  lift b to ℝ≥0 using ne_top_of_le_ne_top ha h\n  lift a to ℝ≥0 using ha\n  simp only [← ENNReal.coe_sub, ENNReal.coe_toReal, NNReal.coe_sub (ENNReal.coe_le_coe.mp h)]\n\n"}
{"name":"ENNReal.le_toReal_sub","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\nhb : Ne b Top.top\n⊢ LE.le (HSub.hSub a.toReal b.toReal) (HSub.hSub a b).toReal","decl":"theorem le_toReal_sub {a b : ℝ≥0∞} (hb : b ≠ ∞) : a.toReal - b.toReal ≤ (a - b).toReal := by\n  lift b to ℝ≥0 using hb\n  induction a\n  · simp\n  · simp only [← coe_sub, NNReal.sub_def, Real.coe_toNNReal', coe_toReal]\n    exact le_max_left _ _\n\n"}
{"name":"ENNReal.toReal_add_le","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\n⊢ LE.le (HAdd.hAdd a b).toReal (HAdd.hAdd a.toReal b.toReal)","decl":"theorem toReal_add_le : (a + b).toReal ≤ a.toReal + b.toReal :=\n  if ha : a = ∞ then by simp only [ha, top_add, top_toReal, zero_add, toReal_nonneg]\n  else\n    if hb : b = ∞ then by simp only [hb, add_top, top_toReal, add_zero, toReal_nonneg]\n    else le_of_eq (toReal_add ha hb)\n\n"}
{"name":"ENNReal.ofReal_add","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p q : Real\nhp : LE.le 0 p\nhq : LE.le 0 q\n⊢ Eq (ENNReal.ofReal (HAdd.hAdd p q)) (HAdd.hAdd (ENNReal.ofReal p) (ENNReal.ofReal q))","decl":"theorem ofReal_add {p q : ℝ} (hp : 0 ≤ p) (hq : 0 ≤ q) :\n    ENNReal.ofReal (p + q) = ENNReal.ofReal p + ENNReal.ofReal q := by\n  rw [ENNReal.ofReal, ENNReal.ofReal, ENNReal.ofReal, ← coe_add, coe_inj,\n    Real.toNNReal_add hp hq]\n\n"}
{"name":"ENNReal.ofReal_add_le","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p q : Real\n⊢ LE.le (ENNReal.ofReal (HAdd.hAdd p q)) (HAdd.hAdd (ENNReal.ofReal p) (ENNReal.ofReal q))","decl":"theorem ofReal_add_le {p q : ℝ} : ENNReal.ofReal (p + q) ≤ ENNReal.ofReal p + ENNReal.ofReal q :=\n  coe_le_coe.2 Real.toNNReal_add_le\n\n"}
{"name":"ENNReal.toReal_le_toReal","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\nha : Ne a Top.top\nhb : Ne b Top.top\n⊢ Iff (LE.le a.toReal b.toReal) (LE.le a b)","decl":"@[simp]\ntheorem toReal_le_toReal (ha : a ≠ ∞) (hb : b ≠ ∞) : a.toReal ≤ b.toReal ↔ a ≤ b := by\n  lift a to ℝ≥0 using ha\n  lift b to ℝ≥0 using hb\n  norm_cast\n\n"}
{"name":"ENNReal.toReal_mono","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\nhb : Ne b Top.top\nh : LE.le a b\n⊢ LE.le a.toReal b.toReal","decl":"@[gcongr]\ntheorem toReal_mono (hb : b ≠ ∞) (h : a ≤ b) : a.toReal ≤ b.toReal :=\n  (toReal_le_toReal (ne_top_of_le_ne_top hb h) hb).2 h\n\n"}
{"name":"ENNReal.toReal_mono'","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\nh : LE.le a b\nht : Eq b Top.top → Eq a Top.top\n⊢ LE.le a.toReal b.toReal","decl":"theorem toReal_mono' (h : a ≤ b) (ht : b = ∞ → a = ∞) : a.toReal ≤ b.toReal := by\n  rcases eq_or_ne a ∞ with rfl | ha\n  · exact toReal_nonneg\n  · exact toReal_mono (mt ht ha) h\n\n"}
{"name":"ENNReal.toReal_lt_toReal","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\nha : Ne a Top.top\nhb : Ne b Top.top\n⊢ Iff (LT.lt a.toReal b.toReal) (LT.lt a b)","decl":"@[simp]\ntheorem toReal_lt_toReal (ha : a ≠ ∞) (hb : b ≠ ∞) : a.toReal < b.toReal ↔ a < b := by\n  lift a to ℝ≥0 using ha\n  lift b to ℝ≥0 using hb\n  norm_cast\n\n"}
{"name":"ENNReal.toReal_strict_mono","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\nhb : Ne b Top.top\nh : LT.lt a b\n⊢ LT.lt a.toReal b.toReal","decl":"@[gcongr]\ntheorem toReal_strict_mono (hb : b ≠ ∞) (h : a < b) : a.toReal < b.toReal :=\n  (toReal_lt_toReal h.ne_top hb).2 h\n\n"}
{"name":"ENNReal.toNNReal_mono","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\nhb : Ne b Top.top\nh : LE.le a b\n⊢ LE.le a.toNNReal b.toNNReal","decl":"@[gcongr]\ntheorem toNNReal_mono (hb : b ≠ ∞) (h : a ≤ b) : a.toNNReal ≤ b.toNNReal :=\n  toReal_mono hb h\n\n"}
{"name":"ENNReal.le_toNNReal_of_coe_le","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : ENNReal\np : NNReal\nh : LE.le (↑p) a\nha : Ne a Top.top\n⊢ LE.le p a.toNNReal","decl":"theorem le_toNNReal_of_coe_le (h : p ≤ a) (ha : a ≠ ∞) : p ≤ a.toNNReal :=\n  @toNNReal_coe p ▸ toNNReal_mono ha h\n\n"}
{"name":"ENNReal.toReal_le_add'","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b c : ENNReal\nhle : LE.le a (HAdd.hAdd b c)\nhb : Eq b Top.top → Eq a Top.top\nhc : Eq c Top.top → Eq a Top.top\n⊢ LE.le a.toReal (HAdd.hAdd b.toReal c.toReal)","decl":"/-- If `a ≤ b + c` and `a = ∞` whenever `b = ∞` or `c = ∞`, then\n`ENNReal.toReal a ≤ ENNReal.toReal b + ENNReal.toReal c`. This lemma is useful to transfer\ntriangle-like inequalities from `ENNReal`s to `Real`s. -/\ntheorem toReal_le_add' (hle : a ≤ b + c) (hb : b = ∞ → a = ∞) (hc : c = ∞ → a = ∞) :\n    a.toReal ≤ b.toReal + c.toReal := by\n  refine le_trans (toReal_mono' hle ?_) toReal_add_le\n  simpa only [add_eq_top, or_imp] using And.intro hb hc\n\n"}
{"name":"ENNReal.toReal_le_add","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b c : ENNReal\nhle : LE.le a (HAdd.hAdd b c)\nhb : Ne b Top.top\nhc : Ne c Top.top\n⊢ LE.le a.toReal (HAdd.hAdd b.toReal c.toReal)","decl":"/-- If `a ≤ b + c`, `b ≠ ∞`, and `c ≠ ∞`, then\n`ENNReal.toReal a ≤ ENNReal.toReal b + ENNReal.toReal c`. This lemma is useful to transfer\ntriangle-like inequalities from `ENNReal`s to `Real`s. -/\ntheorem toReal_le_add (hle : a ≤ b + c) (hb : b ≠ ∞) (hc : c ≠ ∞) :\n    a.toReal ≤ b.toReal + c.toReal :=\n  toReal_le_add' hle (flip absurd hb) (flip absurd hc)\n\n"}
{"name":"ENNReal.toNNReal_le_toNNReal","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\nha : Ne a Top.top\nhb : Ne b Top.top\n⊢ Iff (LE.le a.toNNReal b.toNNReal) (LE.le a b)","decl":"@[simp]\ntheorem toNNReal_le_toNNReal (ha : a ≠ ∞) (hb : b ≠ ∞) : a.toNNReal ≤ b.toNNReal ↔ a ≤ b :=\n  ⟨fun h => by rwa [← coe_toNNReal ha, ← coe_toNNReal hb, coe_le_coe], toNNReal_mono hb⟩\n\n"}
{"name":"ENNReal.toNNReal_strict_mono","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\nhb : Ne b Top.top\nh : LT.lt a b\n⊢ LT.lt a.toNNReal b.toNNReal","decl":"@[gcongr]\ntheorem toNNReal_strict_mono (hb : b ≠ ∞) (h : a < b) : a.toNNReal < b.toNNReal := by\n  simpa [← ENNReal.coe_lt_coe, hb, h.ne_top]\n\n"}
{"name":"ENNReal.toNNReal_lt_toNNReal","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\nha : Ne a Top.top\nhb : Ne b Top.top\n⊢ Iff (LT.lt a.toNNReal b.toNNReal) (LT.lt a b)","decl":"@[simp]\ntheorem toNNReal_lt_toNNReal (ha : a ≠ ∞) (hb : b ≠ ∞) : a.toNNReal < b.toNNReal ↔ a < b :=\n  ⟨fun h => by rwa [← coe_toNNReal ha, ← coe_toNNReal hb, coe_lt_coe], toNNReal_strict_mono hb⟩\n\n"}
{"name":"ENNReal.toNNReal_lt_of_lt_coe","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : ENNReal\np : NNReal\nh : LT.lt a ↑p\n⊢ LT.lt a.toNNReal p","decl":"theorem toNNReal_lt_of_lt_coe (h : a < p) : a.toNNReal < p :=\n  @toNNReal_coe p ▸ toNNReal_strict_mono coe_ne_top h\n\n"}
{"name":"ENNReal.toReal_max","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\nhr : Ne a Top.top\nhp : Ne b Top.top\n⊢ Eq (Max.max a b).toReal (Max.max a.toReal b.toReal)","decl":"theorem toReal_max (hr : a ≠ ∞) (hp : b ≠ ∞) :\n    ENNReal.toReal (max a b) = max (ENNReal.toReal a) (ENNReal.toReal b) :=\n  (le_total a b).elim\n    (fun h => by simp only [h, ENNReal.toReal_mono hp h, max_eq_right]) fun h => by\n    simp only [h, ENNReal.toReal_mono hr h, max_eq_left]\n\n"}
{"name":"ENNReal.toReal_min","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\nhr : Ne a Top.top\nhp : Ne b Top.top\n⊢ Eq (Min.min a b).toReal (Min.min a.toReal b.toReal)","decl":"theorem toReal_min {a b : ℝ≥0∞} (hr : a ≠ ∞) (hp : b ≠ ∞) :\n    ENNReal.toReal (min a b) = min (ENNReal.toReal a) (ENNReal.toReal b) :=\n  (le_total a b).elim (fun h => by simp only [h, ENNReal.toReal_mono hp h, min_eq_left])\n    fun h => by simp only [h, ENNReal.toReal_mono hr h, min_eq_right]\n\n"}
{"name":"ENNReal.toReal_sup","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\na✝¹ : Ne a Top.top\na✝ : Ne b Top.top\n⊢ Eq (Max.max a b).toReal (Max.max a.toReal b.toReal)","decl":"theorem toReal_sup {a b : ℝ≥0∞} : a ≠ ∞ → b ≠ ∞ → (a ⊔ b).toReal = a.toReal ⊔ b.toReal :=\n  toReal_max\n\n"}
{"name":"ENNReal.toReal_inf","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\na✝¹ : Ne a Top.top\na✝ : Ne b Top.top\n⊢ Eq (Min.min a b).toReal (Min.min a.toReal b.toReal)","decl":"theorem toReal_inf {a b : ℝ≥0∞} : a ≠ ∞ → b ≠ ∞ → (a ⊓ b).toReal = a.toReal ⊓ b.toReal :=\n  toReal_min\n\n"}
{"name":"ENNReal.toNNReal_pos_iff","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : ENNReal\n⊢ Iff (LT.lt 0 a.toNNReal) (And (LT.lt 0 a) (LT.lt a Top.top))","decl":"theorem toNNReal_pos_iff : 0 < a.toNNReal ↔ 0 < a ∧ a < ∞ := by\n  induction a <;> simp\n\n"}
{"name":"ENNReal.toNNReal_pos","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : ENNReal\nha₀ : Ne a 0\nha_top : Ne a Top.top\n⊢ LT.lt 0 a.toNNReal","decl":"theorem toNNReal_pos {a : ℝ≥0∞} (ha₀ : a ≠ 0) (ha_top : a ≠ ∞) : 0 < a.toNNReal :=\n  toNNReal_pos_iff.mpr ⟨bot_lt_iff_ne_bot.mpr ha₀, lt_top_iff_ne_top.mpr ha_top⟩\n\n"}
{"name":"ENNReal.toReal_pos_iff","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : ENNReal\n⊢ Iff (LT.lt 0 a.toReal) (And (LT.lt 0 a) (LT.lt a Top.top))","decl":"theorem toReal_pos_iff : 0 < a.toReal ↔ 0 < a ∧ a < ∞ :=\n  NNReal.coe_pos.trans toNNReal_pos_iff\n\n"}
{"name":"ENNReal.toReal_pos","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : ENNReal\nha₀ : Ne a 0\nha_top : Ne a Top.top\n⊢ LT.lt 0 a.toReal","decl":"theorem toReal_pos {a : ℝ≥0∞} (ha₀ : a ≠ 0) (ha_top : a ≠ ∞) : 0 < a.toReal :=\n  toReal_pos_iff.mpr ⟨bot_lt_iff_ne_bot.mpr ha₀, lt_top_iff_ne_top.mpr ha_top⟩\n\n"}
{"name":"ENNReal.ofReal_le_ofReal","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p q : Real\nh : LE.le p q\n⊢ LE.le (ENNReal.ofReal p) (ENNReal.ofReal q)","decl":"@[gcongr, bound]\ntheorem ofReal_le_ofReal {p q : ℝ} (h : p ≤ q) : ENNReal.ofReal p ≤ ENNReal.ofReal q := by\n  simp [ENNReal.ofReal, Real.toNNReal_le_toNNReal h]\n\n"}
{"name":"ENNReal.ofReal_le_of_le_toReal","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : Real\nb : ENNReal\nh : LE.le a b.toReal\n⊢ LE.le (ENNReal.ofReal a) b","decl":"theorem ofReal_le_of_le_toReal {a : ℝ} {b : ℝ≥0∞} (h : a ≤ ENNReal.toReal b) :\n    ENNReal.ofReal a ≤ b :=\n  (ofReal_le_ofReal h).trans ofReal_toReal_le\n\n"}
{"name":"ENNReal.ofReal_le_ofReal_iff","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p q : Real\nh : LE.le 0 q\n⊢ Iff (LE.le (ENNReal.ofReal p) (ENNReal.ofReal q)) (LE.le p q)","decl":"@[simp]\ntheorem ofReal_le_ofReal_iff {p q : ℝ} (h : 0 ≤ q) :\n    ENNReal.ofReal p ≤ ENNReal.ofReal q ↔ p ≤ q := by\n  rw [ENNReal.ofReal, ENNReal.ofReal, coe_le_coe, Real.toNNReal_le_toNNReal_iff h]\n\n"}
{"name":"ENNReal.ofReal_le_ofReal_iff'","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p q : Real\n⊢ Iff (LE.le (ENNReal.ofReal p) (ENNReal.ofReal q)) (Or (LE.le p q) (LE.le p 0))","decl":"lemma ofReal_le_ofReal_iff' {p q : ℝ} : ENNReal.ofReal p ≤ .ofReal q ↔ p ≤ q ∨ p ≤ 0 :=\n  coe_le_coe.trans Real.toNNReal_le_toNNReal_iff'\n\n"}
{"name":"ENNReal.ofReal_lt_ofReal_iff'","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p q : Real\n⊢ Iff (LT.lt (ENNReal.ofReal p) (ENNReal.ofReal q)) (And (LT.lt p q) (LT.lt 0 q))","decl":"lemma ofReal_lt_ofReal_iff' {p q : ℝ} : ENNReal.ofReal p < .ofReal q ↔ p < q ∧ 0 < q :=\n  coe_lt_coe.trans Real.toNNReal_lt_toNNReal_iff'\n\n"}
{"name":"ENNReal.ofReal_eq_ofReal_iff","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p q : Real\nhp : LE.le 0 p\nhq : LE.le 0 q\n⊢ Iff (Eq (ENNReal.ofReal p) (ENNReal.ofReal q)) (Eq p q)","decl":"@[simp]\ntheorem ofReal_eq_ofReal_iff {p q : ℝ} (hp : 0 ≤ p) (hq : 0 ≤ q) :\n    ENNReal.ofReal p = ENNReal.ofReal q ↔ p = q := by\n  rw [ENNReal.ofReal, ENNReal.ofReal, coe_inj, Real.toNNReal_eq_toNNReal_iff hp hq]\n\n"}
{"name":"ENNReal.ofReal_lt_ofReal_iff","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p q : Real\nh : LT.lt 0 q\n⊢ Iff (LT.lt (ENNReal.ofReal p) (ENNReal.ofReal q)) (LT.lt p q)","decl":"@[simp]\ntheorem ofReal_lt_ofReal_iff {p q : ℝ} (h : 0 < q) :\n    ENNReal.ofReal p < ENNReal.ofReal q ↔ p < q := by\n  rw [ENNReal.ofReal, ENNReal.ofReal, coe_lt_coe, Real.toNNReal_lt_toNNReal_iff h]\n\n"}
{"name":"ENNReal.ofReal_lt_ofReal_iff_of_nonneg","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p q : Real\nhp : LE.le 0 p\n⊢ Iff (LT.lt (ENNReal.ofReal p) (ENNReal.ofReal q)) (LT.lt p q)","decl":"theorem ofReal_lt_ofReal_iff_of_nonneg {p q : ℝ} (hp : 0 ≤ p) :\n    ENNReal.ofReal p < ENNReal.ofReal q ↔ p < q := by\n  rw [ENNReal.ofReal, ENNReal.ofReal, coe_lt_coe, Real.toNNReal_lt_toNNReal_iff_of_nonneg hp]\n\n"}
{"name":"ENNReal.ofReal_pos","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p : Real\n⊢ Iff (LT.lt 0 (ENNReal.ofReal p)) (LT.lt 0 p)","decl":"@[simp]\ntheorem ofReal_pos {p : ℝ} : 0 < ENNReal.ofReal p ↔ 0 < p := by simp [ENNReal.ofReal]\n\n"}
{"name":"ENNReal.ofReal_eq_zero","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p : Real\n⊢ Iff (Eq (ENNReal.ofReal p) 0) (LE.le p 0)","decl":"@[simp]\ntheorem ofReal_eq_zero {p : ℝ} : ENNReal.ofReal p = 0 ↔ p ≤ 0 := by simp [ENNReal.ofReal]\n\n"}
{"name":"ENNReal.zero_eq_ofReal","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p : Real\n⊢ Iff (Eq 0 (ENNReal.ofReal p)) (LE.le p 0)","decl":"@[simp]\ntheorem zero_eq_ofReal {p : ℝ} : 0 = ENNReal.ofReal p ↔ p ≤ 0 :=\n  eq_comm.trans ofReal_eq_zero\n\n"}
{"name":"ENNReal.ofReal_of_nonpos","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p : Real\na✝ : LE.le p 0\n⊢ Eq (ENNReal.ofReal p) 0","decl":"alias ⟨_, ofReal_of_nonpos⟩ := ofReal_eq_zero\n\n"}
{"name":"ENNReal.ofReal_lt_natCast","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p : Real\nn : Nat\nhn : Ne n 0\n⊢ Iff (LT.lt (ENNReal.ofReal p) ↑n) (LT.lt p ↑n)","decl":"@[simp]\nlemma ofReal_lt_natCast {p : ℝ} {n : ℕ} (hn : n ≠ 0) : ENNReal.ofReal p < n ↔ p < n := by\n  exact mod_cast ofReal_lt_ofReal_iff (Nat.cast_pos.2 hn.bot_lt)\n\n"}
{"name":"ENNReal.ofReal_lt_one","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p : Real\n⊢ Iff (LT.lt (ENNReal.ofReal p) 1) (LT.lt p 1)","decl":"@[simp]\nlemma ofReal_lt_one {p : ℝ} : ENNReal.ofReal p < 1 ↔ p < 1 := by\n  exact mod_cast ofReal_lt_natCast one_ne_zero\n\n"}
{"name":"ENNReal.ofReal_lt_ofNat","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p : Real\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (LT.lt (ENNReal.ofReal p) (OfNat.ofNat n)) (LT.lt p (OfNat.ofNat n))","decl":"@[simp]\nlemma ofReal_lt_ofNat {p : ℝ} {n : ℕ} [n.AtLeastTwo] :\n    ENNReal.ofReal p < ofNat(n) ↔ p < OfNat.ofNat n :=\n  ofReal_lt_natCast (NeZero.ne n)\n\n"}
{"name":"ENNReal.natCast_le_ofReal","module":"Mathlib.Data.ENNReal.Real","initialProofState":"n : Nat\np : Real\nhn : Ne n 0\n⊢ Iff (LE.le (↑n) (ENNReal.ofReal p)) (LE.le (↑n) p)","decl":"@[simp]\nlemma natCast_le_ofReal {n : ℕ} {p : ℝ} (hn : n ≠ 0) : n ≤ ENNReal.ofReal p ↔ n ≤ p := by\n  simp only [← not_lt, ofReal_lt_natCast hn]\n\n"}
{"name":"ENNReal.one_le_ofReal","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p : Real\n⊢ Iff (LE.le 1 (ENNReal.ofReal p)) (LE.le 1 p)","decl":"@[simp]\nlemma one_le_ofReal {p : ℝ} : 1 ≤ ENNReal.ofReal p ↔ 1 ≤ p := by\n  exact mod_cast natCast_le_ofReal one_ne_zero\n\n"}
{"name":"ENNReal.ofNat_le_ofReal","module":"Mathlib.Data.ENNReal.Real","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\np : Real\n⊢ Iff (LE.le (OfNat.ofNat n) (ENNReal.ofReal p)) (LE.le (OfNat.ofNat n) p)","decl":"@[simp]\nlemma ofNat_le_ofReal {n : ℕ} [n.AtLeastTwo] {p : ℝ} :\n    ofNat(n) ≤ ENNReal.ofReal p ↔ OfNat.ofNat n ≤ p :=\n  natCast_le_ofReal (NeZero.ne n)\n\n"}
{"name":"ENNReal.ofReal_le_natCast","module":"Mathlib.Data.ENNReal.Real","initialProofState":"r : Real\nn : Nat\n⊢ Iff (LE.le (ENNReal.ofReal r) ↑n) (LE.le r ↑n)","decl":"@[simp, norm_cast]\nlemma ofReal_le_natCast {r : ℝ} {n : ℕ} : ENNReal.ofReal r ≤ n ↔ r ≤ n :=\n  coe_le_coe.trans Real.toNNReal_le_natCast\n\n"}
{"name":"ENNReal.ofReal_le_one","module":"Mathlib.Data.ENNReal.Real","initialProofState":"r : Real\n⊢ Iff (LE.le (ENNReal.ofReal r) 1) (LE.le r 1)","decl":"@[simp]\nlemma ofReal_le_one {r : ℝ} : ENNReal.ofReal r ≤ 1 ↔ r ≤ 1 :=\n  coe_le_coe.trans Real.toNNReal_le_one\n\n"}
{"name":"ENNReal.ofReal_le_ofNat","module":"Mathlib.Data.ENNReal.Real","initialProofState":"r : Real\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (LE.le (ENNReal.ofReal r) (OfNat.ofNat n)) (LE.le r (OfNat.ofNat n))","decl":"@[simp]\nlemma ofReal_le_ofNat {r : ℝ} {n : ℕ} [n.AtLeastTwo] :\n    ENNReal.ofReal r ≤ ofNat(n) ↔ r ≤ OfNat.ofNat n :=\n  ofReal_le_natCast\n\n"}
{"name":"ENNReal.natCast_lt_ofReal","module":"Mathlib.Data.ENNReal.Real","initialProofState":"n : Nat\nr : Real\n⊢ Iff (LT.lt (↑n) (ENNReal.ofReal r)) (LT.lt (↑n) r)","decl":"@[simp]\nlemma natCast_lt_ofReal {n : ℕ} {r : ℝ} : n < ENNReal.ofReal r ↔ n < r :=\n  coe_lt_coe.trans Real.natCast_lt_toNNReal\n\n"}
{"name":"ENNReal.one_lt_ofReal","module":"Mathlib.Data.ENNReal.Real","initialProofState":"r : Real\n⊢ Iff (LT.lt 1 (ENNReal.ofReal r)) (LT.lt 1 r)","decl":"@[simp]\nlemma one_lt_ofReal {r : ℝ} : 1 < ENNReal.ofReal r ↔ 1 < r := coe_lt_coe.trans Real.one_lt_toNNReal\n\n"}
{"name":"ENNReal.ofNat_lt_ofReal","module":"Mathlib.Data.ENNReal.Real","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\nr : Real\n⊢ Iff (LT.lt (OfNat.ofNat n) (ENNReal.ofReal r)) (LT.lt (OfNat.ofNat n) r)","decl":"@[simp]\nlemma ofNat_lt_ofReal {n : ℕ} [n.AtLeastTwo] {r : ℝ} :\n    ofNat(n) < ENNReal.ofReal r ↔ OfNat.ofNat n < r :=\n  natCast_lt_ofReal\n\n"}
{"name":"ENNReal.ofReal_eq_natCast","module":"Mathlib.Data.ENNReal.Real","initialProofState":"r : Real\nn : Nat\nh : Ne n 0\n⊢ Iff (Eq (ENNReal.ofReal r) ↑n) (Eq r ↑n)","decl":"@[simp]\nlemma ofReal_eq_natCast {r : ℝ} {n : ℕ} (h : n ≠ 0) : ENNReal.ofReal r = n ↔ r = n :=\n  ENNReal.coe_inj.trans <| Real.toNNReal_eq_natCast h\n\n"}
{"name":"ENNReal.ofReal_eq_one","module":"Mathlib.Data.ENNReal.Real","initialProofState":"r : Real\n⊢ Iff (Eq (ENNReal.ofReal r) 1) (Eq r 1)","decl":"@[simp]\nlemma ofReal_eq_one {r : ℝ} : ENNReal.ofReal r = 1 ↔ r = 1 :=\n  ENNReal.coe_inj.trans Real.toNNReal_eq_one\n\n"}
{"name":"ENNReal.ofReal_eq_ofNat","module":"Mathlib.Data.ENNReal.Real","initialProofState":"r : Real\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (Eq (ENNReal.ofReal r) (OfNat.ofNat n)) (Eq r (OfNat.ofNat n))","decl":"@[simp]\nlemma ofReal_eq_ofNat {r : ℝ} {n : ℕ} [n.AtLeastTwo] :\n    ENNReal.ofReal r = ofNat(n) ↔ r = OfNat.ofNat n :=\n  ofReal_eq_natCast (NeZero.ne n)\n\n"}
{"name":"ENNReal.ofReal_sub","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p q : Real\nhq : LE.le 0 q\n⊢ Eq (ENNReal.ofReal (HSub.hSub p q)) (HSub.hSub (ENNReal.ofReal p) (ENNReal.ofReal q))","decl":"theorem ofReal_sub (p : ℝ) {q : ℝ} (hq : 0 ≤ q) :\n    ENNReal.ofReal (p - q) = ENNReal.ofReal p - ENNReal.ofReal q := by\n  obtain h | h := le_total p q\n  · rw [ofReal_of_nonpos (sub_nonpos_of_le h), tsub_eq_zero_of_le (ofReal_le_ofReal h)]\n  refine ENNReal.eq_sub_of_add_eq ofReal_ne_top ?_\n  rw [← ofReal_add (sub_nonneg_of_le h) hq, sub_add_cancel]\n\n"}
{"name":"ENNReal.ofReal_le_iff_le_toReal","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : Real\nb : ENNReal\nhb : Ne b Top.top\n⊢ Iff (LE.le (ENNReal.ofReal a) b) (LE.le a b.toReal)","decl":"theorem ofReal_le_iff_le_toReal {a : ℝ} {b : ℝ≥0∞} (hb : b ≠ ∞) :\n    ENNReal.ofReal a ≤ b ↔ a ≤ ENNReal.toReal b := by\n  lift b to ℝ≥0 using hb\n  simpa [ENNReal.ofReal, ENNReal.toReal] using Real.toNNReal_le_iff_le_coe\n\n"}
{"name":"ENNReal.ofReal_lt_iff_lt_toReal","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : Real\nb : ENNReal\nha : LE.le 0 a\nhb : Ne b Top.top\n⊢ Iff (LT.lt (ENNReal.ofReal a) b) (LT.lt a b.toReal)","decl":"theorem ofReal_lt_iff_lt_toReal {a : ℝ} {b : ℝ≥0∞} (ha : 0 ≤ a) (hb : b ≠ ∞) :\n    ENNReal.ofReal a < b ↔ a < ENNReal.toReal b := by\n  lift b to ℝ≥0 using hb\n  simpa [ENNReal.ofReal, ENNReal.toReal] using Real.toNNReal_lt_iff_lt_coe ha\n\n"}
{"name":"ENNReal.ofReal_lt_coe_iff","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : Real\nb : NNReal\nha : LE.le 0 a\n⊢ Iff (LT.lt (ENNReal.ofReal a) ↑b) (LT.lt a ↑b)","decl":"theorem ofReal_lt_coe_iff {a : ℝ} {b : ℝ≥0} (ha : 0 ≤ a) : ENNReal.ofReal a < b ↔ a < b :=\n  (ofReal_lt_iff_lt_toReal ha coe_ne_top).trans <| by rw [coe_toReal]\n\n"}
{"name":"ENNReal.le_ofReal_iff_toReal_le","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : ENNReal\nb : Real\nha : Ne a Top.top\nhb : LE.le 0 b\n⊢ Iff (LE.le a (ENNReal.ofReal b)) (LE.le a.toReal b)","decl":"theorem le_ofReal_iff_toReal_le {a : ℝ≥0∞} {b : ℝ} (ha : a ≠ ∞) (hb : 0 ≤ b) :\n    a ≤ ENNReal.ofReal b ↔ ENNReal.toReal a ≤ b := by\n  lift a to ℝ≥0 using ha\n  simpa [ENNReal.ofReal, ENNReal.toReal] using Real.le_toNNReal_iff_coe_le hb\n\n"}
{"name":"ENNReal.toReal_le_of_le_ofReal","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : ENNReal\nb : Real\nhb : LE.le 0 b\nh : LE.le a (ENNReal.ofReal b)\n⊢ LE.le a.toReal b","decl":"theorem toReal_le_of_le_ofReal {a : ℝ≥0∞} {b : ℝ} (hb : 0 ≤ b) (h : a ≤ ENNReal.ofReal b) :\n    ENNReal.toReal a ≤ b :=\n  have ha : a ≠ ∞ := ne_top_of_le_ne_top ofReal_ne_top h\n  (le_ofReal_iff_toReal_le ha hb).1 h\n\n"}
{"name":"ENNReal.lt_ofReal_iff_toReal_lt","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : ENNReal\nb : Real\nha : Ne a Top.top\n⊢ Iff (LT.lt a (ENNReal.ofReal b)) (LT.lt a.toReal b)","decl":"theorem lt_ofReal_iff_toReal_lt {a : ℝ≥0∞} {b : ℝ} (ha : a ≠ ∞) :\n    a < ENNReal.ofReal b ↔ ENNReal.toReal a < b := by\n  lift a to ℝ≥0 using ha\n  simpa [ENNReal.ofReal, ENNReal.toReal] using Real.lt_toNNReal_iff_coe_lt\n\n"}
{"name":"ENNReal.toReal_lt_of_lt_ofReal","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : ENNReal\nb : Real\nh : LT.lt a (ENNReal.ofReal b)\n⊢ LT.lt a.toReal b","decl":"theorem toReal_lt_of_lt_ofReal {b : ℝ} (h : a < ENNReal.ofReal b) : ENNReal.toReal a < b :=\n  (lt_ofReal_iff_toReal_lt h.ne_top).1 h\n\n"}
{"name":"ENNReal.ofReal_mul","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p q : Real\nhp : LE.le 0 p\n⊢ Eq (ENNReal.ofReal (HMul.hMul p q)) (HMul.hMul (ENNReal.ofReal p) (ENNReal.ofReal q))","decl":"theorem ofReal_mul {p q : ℝ} (hp : 0 ≤ p) :\n    ENNReal.ofReal (p * q) = ENNReal.ofReal p * ENNReal.ofReal q := by\n  simp only [ENNReal.ofReal, ← coe_mul, Real.toNNReal_mul hp]\n\n"}
{"name":"ENNReal.ofReal_mul'","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p q : Real\nhq : LE.le 0 q\n⊢ Eq (ENNReal.ofReal (HMul.hMul p q)) (HMul.hMul (ENNReal.ofReal p) (ENNReal.ofReal q))","decl":"theorem ofReal_mul' {p q : ℝ} (hq : 0 ≤ q) :\n    ENNReal.ofReal (p * q) = ENNReal.ofReal p * ENNReal.ofReal q := by\n  rw [mul_comm, ofReal_mul hq, mul_comm]\n\n"}
{"name":"ENNReal.ofReal_pow","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p : Real\nhp : LE.le 0 p\nn : Nat\n⊢ Eq (ENNReal.ofReal (HPow.hPow p n)) (HPow.hPow (ENNReal.ofReal p) n)","decl":"theorem ofReal_pow {p : ℝ} (hp : 0 ≤ p) (n : ℕ) :\n    ENNReal.ofReal (p ^ n) = ENNReal.ofReal p ^ n := by\n  rw [ofReal_eq_coe_nnreal hp, ← coe_pow, ← ofReal_coe_nnreal, NNReal.coe_pow, NNReal.coe_mk]\n\n"}
{"name":"ENNReal.ofReal_nsmul","module":"Mathlib.Data.ENNReal.Real","initialProofState":"x : Real\nn : Nat\n⊢ Eq (ENNReal.ofReal (HSMul.hSMul n x)) (HSMul.hSMul n (ENNReal.ofReal x))","decl":"theorem ofReal_nsmul {x : ℝ} {n : ℕ} : ENNReal.ofReal (n • x) = n • ENNReal.ofReal x := by\n  simp only [nsmul_eq_mul, ← ofReal_natCast n, ← ofReal_mul n.cast_nonneg]\n\n"}
{"name":"ENNReal.ofReal_inv_of_pos","module":"Mathlib.Data.ENNReal.Real","initialProofState":"x : Real\nhx : LT.lt 0 x\n⊢ Eq (ENNReal.ofReal (Inv.inv x)) (Inv.inv (ENNReal.ofReal x))","decl":"theorem ofReal_inv_of_pos {x : ℝ} (hx : 0 < x) : ENNReal.ofReal x⁻¹ = (ENNReal.ofReal x)⁻¹ := by\n  rw [ENNReal.ofReal, ENNReal.ofReal, ← @coe_inv (Real.toNNReal x) (by simp [hx]), coe_inj,\n    ← Real.toNNReal_inv]\n\n"}
{"name":"ENNReal.ofReal_div_of_pos","module":"Mathlib.Data.ENNReal.Real","initialProofState":"x y : Real\nhy : LT.lt 0 y\n⊢ Eq (ENNReal.ofReal (HDiv.hDiv x y)) (HDiv.hDiv (ENNReal.ofReal x) (ENNReal.ofReal y))","decl":"theorem ofReal_div_of_pos {x y : ℝ} (hy : 0 < y) :\n    ENNReal.ofReal (x / y) = ENNReal.ofReal x / ENNReal.ofReal y := by\n  rw [div_eq_mul_inv, div_eq_mul_inv, ofReal_mul' (inv_nonneg.2 hy.le), ofReal_inv_of_pos hy]\n\n"}
{"name":"ENNReal.toNNReal_mul","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\n⊢ Eq (HMul.hMul a b).toNNReal (HMul.hMul a.toNNReal b.toNNReal)","decl":"@[simp]\ntheorem toNNReal_mul {a b : ℝ≥0∞} : (a * b).toNNReal = a.toNNReal * b.toNNReal :=\n  WithTop.untop'_zero_mul a b\n\n"}
{"name":"ENNReal.toNNReal_mul_top","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : ENNReal\n⊢ Eq (HMul.hMul a Top.top).toNNReal 0","decl":"theorem toNNReal_mul_top (a : ℝ≥0∞) : ENNReal.toNNReal (a * ∞) = 0 := by simp\n\n"}
{"name":"ENNReal.toNNReal_top_mul","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : ENNReal\n⊢ Eq (HMul.hMul Top.top a).toNNReal 0","decl":"theorem toNNReal_top_mul (a : ℝ≥0∞) : ENNReal.toNNReal (∞ * a) = 0 := by simp\n\n"}
{"name":"ENNReal.smul_toNNReal","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : NNReal\nb : ENNReal\n⊢ Eq (HSMul.hSMul a b).toNNReal (HMul.hMul a b.toNNReal)","decl":"@[simp]\ntheorem smul_toNNReal (a : ℝ≥0) (b : ℝ≥0∞) : (a • b).toNNReal = a * b.toNNReal := by\n  change ((a : ℝ≥0∞) * b).toNNReal = a * b.toNNReal\n  simp only [ENNReal.toNNReal_mul, ENNReal.toNNReal_coe]\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: upgrade to `→*₀`\n"}
{"name":"ENNReal.toNNReal_pow","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : ENNReal\nn : Nat\n⊢ Eq (HPow.hPow a n).toNNReal (HPow.hPow a.toNNReal n)","decl":"@[simp]\ntheorem toNNReal_pow (a : ℝ≥0∞) (n : ℕ) : (a ^ n).toNNReal = a.toNNReal ^ n :=\n  toNNRealHom.map_pow a n\n\n"}
{"name":"ENNReal.toNNReal_prod","module":"Mathlib.Data.ENNReal.Real","initialProofState":"ι : Type u_1\ns : Finset ι\nf : ι → ENNReal\n⊢ Eq (s.prod fun i => f i).toNNReal (s.prod fun i => (f i).toNNReal)","decl":"@[simp]\ntheorem toNNReal_prod {ι : Type*} {s : Finset ι} {f : ι → ℝ≥0∞} :\n    (∏ i ∈ s, f i).toNNReal = ∏ i ∈ s, (f i).toNNReal :=\n  map_prod toNNRealHom _ _\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: upgrade to `→*₀`\n"}
{"name":"ENNReal.toReal_mul","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\n⊢ Eq (HMul.hMul a b).toReal (HMul.hMul a.toReal b.toReal)","decl":"@[simp]\ntheorem toReal_mul : (a * b).toReal = a.toReal * b.toReal :=\n  toRealHom.map_mul a b\n\n"}
{"name":"ENNReal.toReal_nsmul","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : ENNReal\nn : Nat\n⊢ Eq (HSMul.hSMul n a).toReal (HSMul.hSMul n a.toReal)","decl":"theorem toReal_nsmul (a : ℝ≥0∞) (n : ℕ) : (n • a).toReal = n • a.toReal := by simp\n\n"}
{"name":"ENNReal.toReal_pow","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : ENNReal\nn : Nat\n⊢ Eq (HPow.hPow a n).toReal (HPow.hPow a.toReal n)","decl":"@[simp]\ntheorem toReal_pow (a : ℝ≥0∞) (n : ℕ) : (a ^ n).toReal = a.toReal ^ n :=\n  toRealHom.map_pow a n\n\n"}
{"name":"ENNReal.toReal_prod","module":"Mathlib.Data.ENNReal.Real","initialProofState":"ι : Type u_1\ns : Finset ι\nf : ι → ENNReal\n⊢ Eq (s.prod fun i => f i).toReal (s.prod fun i => (f i).toReal)","decl":"@[simp]\ntheorem toReal_prod {ι : Type*} {s : Finset ι} {f : ι → ℝ≥0∞} :\n    (∏ i ∈ s, f i).toReal = ∏ i ∈ s, (f i).toReal :=\n  map_prod toRealHom _ _\n\n"}
{"name":"ENNReal.toReal_ofReal_mul","module":"Mathlib.Data.ENNReal.Real","initialProofState":"c : Real\na : ENNReal\nh : LE.le 0 c\n⊢ Eq (HMul.hMul (ENNReal.ofReal c) a).toReal (HMul.hMul c a.toReal)","decl":"theorem toReal_ofReal_mul (c : ℝ) (a : ℝ≥0∞) (h : 0 ≤ c) :\n    ENNReal.toReal (ENNReal.ofReal c * a) = c * ENNReal.toReal a := by\n  rw [ENNReal.toReal_mul, ENNReal.toReal_ofReal h]\n\n"}
{"name":"ENNReal.toReal_mul_top","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : ENNReal\n⊢ Eq (HMul.hMul a Top.top).toReal 0","decl":"theorem toReal_mul_top (a : ℝ≥0∞) : ENNReal.toReal (a * ∞) = 0 := by\n  rw [toReal_mul, top_toReal, mul_zero]\n\n"}
{"name":"ENNReal.toReal_top_mul","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : ENNReal\n⊢ Eq (HMul.hMul Top.top a).toReal 0","decl":"theorem toReal_top_mul (a : ℝ≥0∞) : ENNReal.toReal (∞ * a) = 0 := by\n  rw [mul_comm]\n  exact toReal_mul_top _\n\n"}
{"name":"ENNReal.toReal_eq_toReal","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\nha : Ne a Top.top\nhb : Ne b Top.top\n⊢ Iff (Eq a.toReal b.toReal) (Eq a b)","decl":"theorem toReal_eq_toReal (ha : a ≠ ∞) (hb : b ≠ ∞) : a.toReal = b.toReal ↔ a = b := by\n  lift a to ℝ≥0 using ha\n  lift b to ℝ≥0 using hb\n  simp only [coe_inj, NNReal.coe_inj, coe_toReal]\n\n"}
{"name":"ENNReal.toReal_smul","module":"Mathlib.Data.ENNReal.Real","initialProofState":"r : NNReal\ns : ENNReal\n⊢ Eq (HSMul.hSMul r s).toReal (HSMul.hSMul r s.toReal)","decl":"theorem toReal_smul (r : ℝ≥0) (s : ℝ≥0∞) : (r • s).toReal = r • s.toReal := by\n  rw [ENNReal.smul_def, smul_eq_mul, toReal_mul, coe_toReal]\n  rfl\n\n"}
{"name":"ENNReal.trichotomy","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p : ENNReal\n⊢ Or (Eq p 0) (Or (Eq p Top.top) (LT.lt 0 p.toReal))","decl":"protected theorem trichotomy (p : ℝ≥0∞) : p = 0 ∨ p = ∞ ∨ 0 < p.toReal := by\n  simpa only [or_iff_not_imp_left] using toReal_pos\n\n"}
{"name":"ENNReal.trichotomy₂","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p q : ENNReal\nhpq : LE.le p q\n⊢ Or (And (Eq p 0) (Eq q 0)) (Or (And (Eq p 0) (Eq q Top.top)) (Or (And (Eq p 0) (LT.lt 0 q.toReal)) (Or (And (Eq p Top.top) (Eq q Top.top)) (Or (And (LT.lt 0 p.toReal) (Eq q Top.top)) (And (LT.lt 0 p.toReal) (And (LT.lt 0 q.toReal) (LE.le p.toReal q.toReal)))))))","decl":"protected theorem trichotomy₂ {p q : ℝ≥0∞} (hpq : p ≤ q) :\n    p = 0 ∧ q = 0 ∨\n      p = 0 ∧ q = ∞ ∨\n        p = 0 ∧ 0 < q.toReal ∨\n          p = ∞ ∧ q = ∞ ∨\n            0 < p.toReal ∧ q = ∞ ∨ 0 < p.toReal ∧ 0 < q.toReal ∧ p.toReal ≤ q.toReal := by\n  rcases eq_or_lt_of_le (bot_le : 0 ≤ p) with ((rfl : 0 = p) | (hp : 0 < p))\n  · simpa using q.trichotomy\n  rcases eq_or_lt_of_le (le_top : q ≤ ∞) with (rfl | hq)\n  · simpa using p.trichotomy\n  repeat' right\n  have hq' : 0 < q := lt_of_lt_of_le hp hpq\n  have hp' : p < ∞ := lt_of_le_of_lt hpq hq\n  simp [ENNReal.toReal_mono hq.ne hpq, ENNReal.toReal_pos_iff, hp, hp', hq', hq]\n\n"}
{"name":"ENNReal.dichotomy","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p : ENNReal\ninst✝ : Fact (LE.le 1 p)\n⊢ Or (Eq p Top.top) (LE.le 1 p.toReal)","decl":"protected theorem dichotomy (p : ℝ≥0∞) [Fact (1 ≤ p)] : p = ∞ ∨ 1 ≤ p.toReal :=\n  haveI : p = ⊤ ∨ 0 < p.toReal ∧ 1 ≤ p.toReal := by\n    simpa using ENNReal.trichotomy₂ (Fact.out : 1 ≤ p)\n  this.imp_right fun h => h.2\n\n"}
{"name":"ENNReal.toReal_pos_iff_ne_top","module":"Mathlib.Data.ENNReal.Real","initialProofState":"p : ENNReal\ninst✝ : Fact (LE.le 1 p)\n⊢ Iff (LT.lt 0 p.toReal) (Ne p Top.top)","decl":"theorem toReal_pos_iff_ne_top (p : ℝ≥0∞) [Fact (1 ≤ p)] : 0 < p.toReal ↔ p ≠ ∞ :=\n  ⟨fun h hp =>\n    have : (0 : ℝ) ≠ 0 := top_toReal ▸ (hp ▸ h.ne : 0 ≠ ∞.toReal)\n    this rfl,\n    fun h => zero_lt_one.trans_le (p.dichotomy.resolve_left h)⟩\n\n"}
{"name":"ENNReal.toNNReal_inv","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : ENNReal\n⊢ Eq (Inv.inv a).toNNReal (Inv.inv a.toNNReal)","decl":"@[simp] theorem toNNReal_inv (a : ℝ≥0∞) : a⁻¹.toNNReal = a.toNNReal⁻¹ := by\n  induction' a with a; · simp\n  rcases eq_or_ne a 0 with (rfl | ha); · simp\n  rw [← coe_inv ha, toNNReal_coe, toNNReal_coe]\n\n"}
{"name":"ENNReal.toNNReal_div","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\n⊢ Eq (HDiv.hDiv a b).toNNReal (HDiv.hDiv a.toNNReal b.toNNReal)","decl":"@[simp] theorem toNNReal_div (a b : ℝ≥0∞) : (a / b).toNNReal = a.toNNReal / b.toNNReal := by\n  rw [div_eq_mul_inv, toNNReal_mul, toNNReal_inv, div_eq_mul_inv]\n\n"}
{"name":"ENNReal.toReal_inv","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : ENNReal\n⊢ Eq (Inv.inv a).toReal (Inv.inv a.toReal)","decl":"@[simp] theorem toReal_inv (a : ℝ≥0∞) : a⁻¹.toReal = a.toReal⁻¹ := by\n  simp only [ENNReal.toReal, toNNReal_inv, NNReal.coe_inv]\n\n"}
{"name":"ENNReal.toReal_div","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\n⊢ Eq (HDiv.hDiv a b).toReal (HDiv.hDiv a.toReal b.toReal)","decl":"@[simp] theorem toReal_div (a b : ℝ≥0∞) : (a / b).toReal = a.toReal / b.toReal := by\n  rw [div_eq_mul_inv, toReal_mul, toReal_inv, div_eq_mul_inv]\n\n"}
{"name":"ENNReal.ofReal_prod_of_nonneg","module":"Mathlib.Data.ENNReal.Real","initialProofState":"α : Type u_1\ns : Finset α\nf : α → Real\nhf : ∀ (i : α), Membership.mem s i → LE.le 0 (f i)\n⊢ Eq (ENNReal.ofReal (s.prod fun i => f i)) (s.prod fun i => ENNReal.ofReal (f i))","decl":"theorem ofReal_prod_of_nonneg {α : Type*} {s : Finset α} {f : α → ℝ} (hf : ∀ i, i ∈ s → 0 ≤ f i) :\n    ENNReal.ofReal (∏ i ∈ s, f i) = ∏ i ∈ s, ENNReal.ofReal (f i) := by\n  simp_rw [ENNReal.ofReal, ← coe_finset_prod, coe_inj]\n  exact Real.toNNReal_prod_of_nonneg hf\n\n"}
{"name":"ENNReal.toNNReal_iInf","module":"Mathlib.Data.ENNReal.Real","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\nhf : ∀ (i : ι), Ne (f i) Top.top\n⊢ Eq (iInf f).toNNReal (iInf fun i => (f i).toNNReal)","decl":"theorem toNNReal_iInf (hf : ∀ i, f i ≠ ∞) : (iInf f).toNNReal = ⨅ i, (f i).toNNReal := by\n  cases isEmpty_or_nonempty ι\n  · rw [iInf_of_empty, top_toNNReal, NNReal.iInf_empty]\n  · lift f to ι → ℝ≥0 using hf\n    simp_rw [← coe_iInf, toNNReal_coe]\n\n"}
{"name":"ENNReal.toNNReal_sInf","module":"Mathlib.Data.ENNReal.Real","initialProofState":"s : Set ENNReal\nhs : ∀ (r : ENNReal), Membership.mem s r → Ne r Top.top\n⊢ Eq (InfSet.sInf s).toNNReal (InfSet.sInf (Set.image ENNReal.toNNReal s))","decl":"theorem toNNReal_sInf (s : Set ℝ≥0∞) (hs : ∀ r ∈ s, r ≠ ∞) :\n    (sInf s).toNNReal = sInf (ENNReal.toNNReal '' s) := by\n  have hf : ∀ i, ((↑) : s → ℝ≥0∞) i ≠ ∞ := fun ⟨r, rs⟩ => hs r rs\n  -- Porting note: `← sInf_image'` had to be replaced by `← image_eq_range` as the lemmas are used\n  -- in a different order.\n  simpa only [← sInf_range, ← image_eq_range, Subtype.range_coe_subtype] using (toNNReal_iInf hf)\n\n"}
{"name":"ENNReal.toNNReal_iSup","module":"Mathlib.Data.ENNReal.Real","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\nhf : ∀ (i : ι), Ne (f i) Top.top\n⊢ Eq (iSup f).toNNReal (iSup fun i => (f i).toNNReal)","decl":"theorem toNNReal_iSup (hf : ∀ i, f i ≠ ∞) : (iSup f).toNNReal = ⨆ i, (f i).toNNReal := by\n  lift f to ι → ℝ≥0 using hf\n  simp_rw [toNNReal_coe]\n  by_cases h : BddAbove (range f)\n  · rw [← coe_iSup h, toNNReal_coe]\n  · rw [NNReal.iSup_of_not_bddAbove h, iSup_coe_eq_top.2 h, top_toNNReal]\n\n"}
{"name":"ENNReal.toNNReal_sSup","module":"Mathlib.Data.ENNReal.Real","initialProofState":"s : Set ENNReal\nhs : ∀ (r : ENNReal), Membership.mem s r → Ne r Top.top\n⊢ Eq (SupSet.sSup s).toNNReal (SupSet.sSup (Set.image ENNReal.toNNReal s))","decl":"theorem toNNReal_sSup (s : Set ℝ≥0∞) (hs : ∀ r ∈ s, r ≠ ∞) :\n    (sSup s).toNNReal = sSup (ENNReal.toNNReal '' s) := by\n  have hf : ∀ i, ((↑) : s → ℝ≥0∞) i ≠ ∞ := fun ⟨r, rs⟩ => hs r rs\n  -- Porting note: `← sSup_image'` had to be replaced by `← image_eq_range` as the lemmas are used\n  -- in a different order.\n  simpa only [← sSup_range, ← image_eq_range, Subtype.range_coe_subtype] using (toNNReal_iSup hf)\n\n"}
{"name":"ENNReal.toReal_iInf","module":"Mathlib.Data.ENNReal.Real","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\nhf : ∀ (i : ι), Ne (f i) Top.top\n⊢ Eq (iInf f).toReal (iInf fun i => (f i).toReal)","decl":"theorem toReal_iInf (hf : ∀ i, f i ≠ ∞) : (iInf f).toReal = ⨅ i, (f i).toReal := by\n  simp only [ENNReal.toReal, toNNReal_iInf hf, NNReal.coe_iInf]\n\n"}
{"name":"ENNReal.toReal_sInf","module":"Mathlib.Data.ENNReal.Real","initialProofState":"s : Set ENNReal\nhf : ∀ (r : ENNReal), Membership.mem s r → Ne r Top.top\n⊢ Eq (InfSet.sInf s).toReal (InfSet.sInf (Set.image ENNReal.toReal s))","decl":"theorem toReal_sInf (s : Set ℝ≥0∞) (hf : ∀ r ∈ s, r ≠ ∞) :\n    (sInf s).toReal = sInf (ENNReal.toReal '' s) := by\n  simp only [ENNReal.toReal, toNNReal_sInf s hf, NNReal.coe_sInf, Set.image_image]\n\n"}
{"name":"ENNReal.toReal_iSup","module":"Mathlib.Data.ENNReal.Real","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\nhf : ∀ (i : ι), Ne (f i) Top.top\n⊢ Eq (iSup f).toReal (iSup fun i => (f i).toReal)","decl":"theorem toReal_iSup (hf : ∀ i, f i ≠ ∞) : (iSup f).toReal = ⨆ i, (f i).toReal := by\n  simp only [ENNReal.toReal, toNNReal_iSup hf, NNReal.coe_iSup]\n\n"}
{"name":"ENNReal.toReal_sSup","module":"Mathlib.Data.ENNReal.Real","initialProofState":"s : Set ENNReal\nhf : ∀ (r : ENNReal), Membership.mem s r → Ne r Top.top\n⊢ Eq (SupSet.sSup s).toReal (SupSet.sSup (Set.image ENNReal.toReal s))","decl":"theorem toReal_sSup (s : Set ℝ≥0∞) (hf : ∀ r ∈ s, r ≠ ∞) :\n    (sSup s).toReal = sSup (ENNReal.toReal '' s) := by\n  simp only [ENNReal.toReal, toNNReal_sSup s hf, NNReal.coe_sSup, Set.image_image]\n\n"}
{"name":"ENNReal.ofReal_iInf","module":"Mathlib.Data.ENNReal.Real","initialProofState":"ι : Sort u_1\ninst✝ : Nonempty ι\nf : ι → Real\n⊢ Eq (ENNReal.ofReal (iInf fun i => f i)) (iInf fun i => ENNReal.ofReal (f i))","decl":"@[simp] lemma ofReal_iInf [Nonempty ι] (f : ι → ℝ) :\n    ENNReal.ofReal (⨅ i, f i) = ⨅ i, ENNReal.ofReal (f i) := by\n  obtain ⟨i, hi⟩ | h := em (∃ i, f i ≤ 0)\n  · rw [(iInf_eq_bot _).2 fun _ _ ↦ ⟨i, by simpa [ofReal_of_nonpos hi]⟩]\n    simp [Real.iInf_nonpos' ⟨i, hi⟩]\n  replace h i : 0 ≤ f i := le_of_not_le fun hi ↦ h ⟨i, hi⟩\n  refine eq_of_forall_le_iff fun a ↦ ?_\n  obtain rfl | ha := eq_or_ne a ∞\n  · simp\n  rw [le_iInf_iff, le_ofReal_iff_toReal_le ha, le_ciInf_iff ⟨0, by simpa [mem_lowerBounds]⟩]\n  · exact forall_congr' fun i ↦ (le_ofReal_iff_toReal_le ha (h _)).symm\n  · exact Real.iInf_nonneg h\n\n"}
{"name":"ENNReal.iInf_add","module":"Mathlib.Data.ENNReal.Real","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\na : ENNReal\n⊢ Eq (HAdd.hAdd (iInf f) a) (iInf fun i => HAdd.hAdd (f i) a)","decl":"theorem iInf_add : iInf f + a = ⨅ i, f i + a :=\n  le_antisymm (le_iInf fun _ => add_le_add (iInf_le _ _) <| le_rfl)\n    (tsub_le_iff_right.1 <| le_iInf fun _ => tsub_le_iff_right.2 <| iInf_le _ _)\n\n"}
{"name":"ENNReal.iSup_sub","module":"Mathlib.Data.ENNReal.Real","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\na : ENNReal\n⊢ Eq (HSub.hSub (iSup fun i => f i) a) (iSup fun i => HSub.hSub (f i) a)","decl":"theorem iSup_sub : (⨆ i, f i) - a = ⨆ i, f i - a :=\n  le_antisymm (tsub_le_iff_right.2 <| iSup_le fun i => tsub_le_iff_right.1 <| le_iSup (f · - a) i)\n    (iSup_le fun _ => tsub_le_tsub (le_iSup _ _) (le_refl a))\n\n"}
{"name":"ENNReal.sub_iInf","module":"Mathlib.Data.ENNReal.Real","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\na : ENNReal\n⊢ Eq (HSub.hSub a (iInf fun i => f i)) (iSup fun i => HSub.hSub a (f i))","decl":"theorem sub_iInf : (a - ⨅ i, f i) = ⨆ i, a - f i := by\n  refine eq_of_forall_ge_iff fun c => ?_\n  rw [tsub_le_iff_right, add_comm, iInf_add]\n  simp [tsub_le_iff_right, sub_eq_add_neg, add_comm]\n\n"}
{"name":"ENNReal.sInf_add","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a : ENNReal\ns : Set ENNReal\n⊢ Eq (HAdd.hAdd (InfSet.sInf s) a) (iInf fun b => iInf fun h => HAdd.hAdd b a)","decl":"theorem sInf_add {s : Set ℝ≥0∞} : sInf s + a = ⨅ b ∈ s, b + a := by simp [sInf_eq_iInf, iInf_add]\n\n"}
{"name":"ENNReal.add_iInf","module":"Mathlib.Data.ENNReal.Real","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\na : ENNReal\n⊢ Eq (HAdd.hAdd a (iInf f)) (iInf fun b => HAdd.hAdd a (f b))","decl":"theorem add_iInf {a : ℝ≥0∞} : a + iInf f = ⨅ b, a + f b := by\n  rw [add_comm, iInf_add]; simp [add_comm]\n\n"}
{"name":"ENNReal.iInf_add_iInf","module":"Mathlib.Data.ENNReal.Real","initialProofState":"ι : Sort u_1\nf g : ι → ENNReal\nh : ∀ (i j : ι), Exists fun k => LE.le (HAdd.hAdd (f k) (g k)) (HAdd.hAdd (f i) (g j))\n⊢ Eq (HAdd.hAdd (iInf f) (iInf g)) (iInf fun a => HAdd.hAdd (f a) (g a))","decl":"theorem iInf_add_iInf (h : ∀ i j, ∃ k, f k + g k ≤ f i + g j) : iInf f + iInf g = ⨅ a, f a + g a :=\n  suffices ⨅ a, f a + g a ≤ iInf f + iInf g from\n    le_antisymm (le_iInf fun _ => add_le_add (iInf_le _ _) (iInf_le _ _)) this\n  calc\n    ⨅ a, f a + g a ≤ ⨅ (a) (a'), f a + g a' :=\n      le_iInf₂ fun a a' => let ⟨k, h⟩ := h a a'; iInf_le_of_le k h\n    _ = iInf f + iInf g := by simp_rw [iInf_add, add_iInf]\n\n"}
{"name":"ENNReal.iInf_sum","module":"Mathlib.Data.ENNReal.Real","initialProofState":"ι : Sort u_1\nα : Type u_2\nf : ι → α → ENNReal\ns : Finset α\ninst✝ : Nonempty ι\nh : ∀ (t : Finset α) (i j : ι), Exists fun k => ∀ (a : α), Membership.mem t a → And (LE.le (f k a) (f i a)) (LE.le (f k a) (f j a))\n⊢ Eq (iInf fun i => s.sum fun a => f i a) (s.sum fun a => iInf fun i => f i a)","decl":"theorem iInf_sum {α : Type*} {f : ι → α → ℝ≥0∞} {s : Finset α} [Nonempty ι]\n    (h : ∀ (t : Finset α) (i j : ι), ∃ k, ∀ a ∈ t, f k a ≤ f i a ∧ f k a ≤ f j a) :\n    ⨅ i, ∑ a ∈ s, f i a = ∑ a ∈ s, ⨅ i, f i a := by\n  induction' s using Finset.cons_induction_on with a s ha ih\n  · simp only [Finset.sum_empty, ciInf_const]\n  · simp only [Finset.sum_cons, ← ih]\n    refine (iInf_add_iInf fun i j => ?_).symm\n    refine (h (Finset.cons a s ha) i j).imp fun k hk => ?_\n    rw [Finset.forall_mem_cons] at hk\n    exact add_le_add hk.1.1 (Finset.sum_le_sum fun a ha => (hk.2 a ha).2)\n\n"}
{"name":"ENNReal.sup_eq_zero","module":"Mathlib.Data.ENNReal.Real","initialProofState":"a b : ENNReal\n⊢ Iff (Eq (Max.max a b) 0) (And (Eq a 0) (Eq b 0))","decl":"theorem sup_eq_zero {a b : ℝ≥0∞} : a ⊔ b = 0 ↔ a = 0 ∧ b = 0 :=\n  sup_eq_bot_iff\n\n"}
