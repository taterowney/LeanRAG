{"name":"tendsto_div_of_monotone_of_exists_subseq_tendsto_div","module":"Mathlib.Analysis.SpecificLimits.FloorPow","initialProofState":"u : Nat ‚Üí Real\nl : Real\nhmono : Monotone u\nhlim : ‚àÄ (a : Real), LT.lt 1 a ‚Üí Exists fun c => And (Filter.Eventually (fun n => LE.le (‚Üë(c (HAdd.hAdd n 1))) (HMul.hMul a ‚Üë(c n))) Filter.atTop) (And (Filter.Tendsto c Filter.atTop Filter.atTop) (Filter.Tendsto (fun n => HDiv.hDiv (u (c n)) ‚Üë(c n)) Filter.atTop (nhds l)))\n‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv (u n) ‚Üën) Filter.atTop (nhds l)","decl":"/-- If a monotone sequence `u` is such that `u n / n` tends to a limit `l` along subsequences with\nexponential growth rate arbitrarily close to `1`, then `u n / n` tends to `l`. -/\ntheorem tendsto_div_of_monotone_of_exists_subseq_tendsto_div (u : ‚Ñï ‚Üí ‚Ñù) (l : ‚Ñù)\n    (hmono : Monotone u)\n    (hlim : ‚àÄ a : ‚Ñù, 1 < a ‚Üí ‚àÉ c : ‚Ñï ‚Üí ‚Ñï, (‚àÄ·∂† n in atTop, (c (n + 1) : ‚Ñù) ‚â§ a * c n) ‚àß\n      Tendsto c atTop atTop ‚àß Tendsto (fun n => u (c n) / c n) atTop (ùìù l)) :\n    Tendsto (fun n => u n / n) atTop (ùìù l) := by\n  /- To check the result up to some `Œµ > 0`, we use a sequence `c` for which the ratio\n    `c (N+1) / c N` is bounded by `1 + Œµ`. Sandwiching a given `n` between two consecutive values of\n    `c`, say `c N` and `c (N+1)`, one can then bound `u n / n` from above by `u (c N) / c (N - 1)`\n    and from below by `u (c (N - 1)) / c N` (using that `u` is monotone), which are both comparable\n    to the limit `l` up to `1 + Œµ`.\n    We give a version of this proof by clearing out denominators first, to avoid discussing the sign\n    of different quantities. -/\n  have lnonneg : 0 ‚â§ l := by\n    rcases hlim 2 one_lt_two with ‚ü®c, _, ctop, clim‚ü©\n    have : Tendsto (fun n => u 0 / c n) atTop (ùìù 0) :=\n      tendsto_const_nhds.div_atTop (tendsto_natCast_atTop_iff.2 ctop)\n    apply le_of_tendsto_of_tendsto' this clim fun n => ?_\n    gcongr\n    exact hmono (zero_le _)\n  have A : ‚àÄ Œµ : ‚Ñù, 0 < Œµ ‚Üí ‚àÄ·∂† n in atTop, u n - n * l ‚â§ Œµ * (1 + Œµ + l) * n := by\n    intro Œµ Œµpos\n    rcases hlim (1 + Œµ) ((lt_add_iff_pos_right _).2 Œµpos) with ‚ü®c, cgrowth, ctop, clim‚ü©\n    have L : ‚àÄ·∂† n in atTop, u (c n) - c n * l ‚â§ Œµ * c n := by\n      rw [‚Üê tendsto_sub_nhds_zero_iff, ‚Üê Asymptotics.isLittleO_one_iff ‚Ñù,\n        Asymptotics.isLittleO_iff] at clim\n      filter_upwards [clim Œµpos, ctop (Ioi_mem_atTop 0)] with n hn cnpos'\n      have cnpos : 0 < c n := cnpos'\n      calc\n        u (c n) - c n * l = (u (c n) / c n - l) * c n := by\n          simp only [cnpos.ne', Ne, Nat.cast_eq_zero, not_false_iff, field_simps]\n        _ ‚â§ Œµ * c n := by\n          gcongr\n          refine (le_abs_self _).trans ?_\n          simpa using hn\n    obtain ‚ü®a, ha‚ü© :\n      ‚àÉ a : ‚Ñï, ‚àÄ b : ‚Ñï, a ‚â§ b ‚Üí (c (b + 1) : ‚Ñù) ‚â§ (1 + Œµ) * c b ‚àß u (c b) - c b * l ‚â§ Œµ * c b :=\n      eventually_atTop.1 (cgrowth.and L)\n    let M := ((Finset.range (a + 1)).image fun i => c i).max' (by simp)\n    filter_upwards [Ici_mem_atTop M] with n hn\n    have exN : ‚àÉ N, n < c N := by\n      rcases (tendsto_atTop.1 ctop (n + 1)).exists with ‚ü®N, hN‚ü©\n      exact ‚ü®N, by omega‚ü©\n    let N := Nat.find exN\n    have ncN : n < c N := Nat.find_spec exN\n    have aN : a + 1 ‚â§ N := by\n      by_contra! h\n      have cNM : c N ‚â§ M := by\n        apply le_max'\n        apply mem_image_of_mem\n        exact mem_range.2 h\n      exact lt_irrefl _ ((cNM.trans hn).trans_lt ncN)\n    have Npos : 0 < N := lt_of_lt_of_le Nat.succ_pos' aN\n    have cNn : c (N - 1) ‚â§ n := by\n      have : N - 1 < N := Nat.pred_lt Npos.ne'\n      simpa only [not_lt] using Nat.find_min exN this\n    have IcN : (c N : ‚Ñù) ‚â§ (1 + Œµ) * c (N - 1) := by\n      have A : a ‚â§ N - 1 := by\n        apply @Nat.le_of_add_le_add_right a 1 (N - 1)\n        rw [Nat.sub_add_cancel Npos]\n        exact aN\n      have B : N - 1 + 1 = N := Nat.succ_pred_eq_of_pos Npos\n      have := (ha _ A).1\n      rwa [B] at this\n    calc\n      u n - n * l ‚â§ u (c N) - c (N - 1) * l := by gcongr; exact hmono ncN.le\n      _ = u (c N) - c N * l + (c N - c (N - 1)) * l := by ring\n      _ ‚â§ Œµ * c N + Œµ * c (N - 1) * l := by\n        gcongr\n        ¬∑ exact (ha N (a.le_succ.trans aN)).2\n        ¬∑ linarith only [IcN]\n      _ ‚â§ Œµ * ((1 + Œµ) * c (N - 1)) + Œµ * c (N - 1) * l := by gcongr\n      _ = Œµ * (1 + Œµ + l) * c (N - 1) := by ring\n      _ ‚â§ Œµ * (1 + Œµ + l) * n := by gcongr\n  have B : ‚àÄ Œµ : ‚Ñù, 0 < Œµ ‚Üí ‚àÄ·∂† n : ‚Ñï in atTop, (n : ‚Ñù) * l - u n ‚â§ Œµ * (1 + l) * n := by\n    intro Œµ Œµpos\n    rcases hlim (1 + Œµ) ((lt_add_iff_pos_right _).2 Œµpos) with ‚ü®c, cgrowth, ctop, clim‚ü©\n    have L : ‚àÄ·∂† n : ‚Ñï in atTop, (c n : ‚Ñù) * l - u (c n) ‚â§ Œµ * c n := by\n      rw [‚Üê tendsto_sub_nhds_zero_iff, ‚Üê Asymptotics.isLittleO_one_iff ‚Ñù,\n        Asymptotics.isLittleO_iff] at clim\n      filter_upwards [clim Œµpos, ctop (Ioi_mem_atTop 0)] with n hn cnpos'\n      have cnpos : 0 < c n := cnpos'\n      calc\n        (c n : ‚Ñù) * l - u (c n) = -(u (c n) / c n - l) * c n := by\n          simp only [cnpos.ne', Ne, Nat.cast_eq_zero, not_false_iff, neg_sub, field_simps]\n        _ ‚â§ Œµ * c n := by\n          gcongr\n          refine le_trans (neg_le_abs _) ?_\n          simpa using hn\n    obtain ‚ü®a, ha‚ü© :\n      ‚àÉ a : ‚Ñï,\n        ‚àÄ b : ‚Ñï, a ‚â§ b ‚Üí (c (b + 1) : ‚Ñù) ‚â§ (1 + Œµ) * c b ‚àß (c b : ‚Ñù) * l - u (c b) ‚â§ Œµ * c b :=\n      eventually_atTop.1 (cgrowth.and L)\n    let M := ((Finset.range (a + 1)).image fun i => c i).max' (by simp)\n    filter_upwards [Ici_mem_atTop M] with n hn\n    have exN : ‚àÉ N, n < c N := by\n      rcases (tendsto_atTop.1 ctop (n + 1)).exists with ‚ü®N, hN‚ü©\n      exact ‚ü®N, by omega‚ü©\n    let N := Nat.find exN\n    have ncN : n < c N := Nat.find_spec exN\n    have aN : a + 1 ‚â§ N := by\n      by_contra! h\n      have cNM : c N ‚â§ M := by\n        apply le_max'\n        apply mem_image_of_mem\n        exact mem_range.2 h\n      exact lt_irrefl _ ((cNM.trans hn).trans_lt ncN)\n    have Npos : 0 < N := lt_of_lt_of_le Nat.succ_pos' aN\n    have aN' : a ‚â§ N - 1 := by\n      apply @Nat.le_of_add_le_add_right a 1 (N - 1)\n      rw [Nat.sub_add_cancel Npos]\n      exact aN\n    have cNn : c (N - 1) ‚â§ n := by\n      have : N - 1 < N := Nat.pred_lt Npos.ne'\n      simpa only [not_lt] using Nat.find_min exN this\n    calc\n      (n : ‚Ñù) * l - u n ‚â§ c N * l - u (c (N - 1)) := by\n        gcongr\n        exact hmono cNn\n      _ ‚â§ (1 + Œµ) * c (N - 1) * l - u (c (N - 1)) := by\n        gcongr\n        have B : N - 1 + 1 = N := Nat.succ_pred_eq_of_pos Npos\n        simpa [B] using (ha _ aN').1\n      _ = c (N - 1) * l - u (c (N - 1)) + Œµ * c (N - 1) * l := by ring\n      _ ‚â§ Œµ * c (N - 1) + Œµ * c (N - 1) * l := add_le_add (ha _ aN').2 le_rfl\n      _ = Œµ * (1 + l) * c (N - 1) := by ring\n      _ ‚â§ Œµ * (1 + l) * n := by gcongr\n  refine tendsto_order.2 ‚ü®fun d hd => ?_, fun d hd => ?_‚ü©\n  ¬∑ obtain ‚ü®Œµ, hŒµ, Œµpos‚ü© : ‚àÉ Œµ : ‚Ñù, d + Œµ * (1 + l) < l ‚àß 0 < Œµ := by\n      have L : Tendsto (fun Œµ => d + Œµ * (1 + l)) (ùìù[>] 0) (ùìù (d + 0 * (1 + l))) := by\n        apply Tendsto.mono_left _ nhdsWithin_le_nhds\n        exact tendsto_const_nhds.add (tendsto_id.mul tendsto_const_nhds)\n      simp only [zero_mul, add_zero] at L\n      exact (((tendsto_order.1 L).2 l hd).and self_mem_nhdsWithin).exists\n    filter_upwards [B Œµ Œµpos, Ioi_mem_atTop 0] with n hn npos\n    simp_rw [div_eq_inv_mul]\n    calc\n      d < (n : ‚Ñù)‚Åª¬π * n * (l - Œµ * (1 + l)) := by\n        rw [inv_mul_cancel‚ÇÄ, one_mul]\n        ¬∑ linarith only [hŒµ]\n        ¬∑ exact Nat.cast_ne_zero.2 (ne_of_gt npos)\n      _ = (n : ‚Ñù)‚Åª¬π * (n * l - Œµ * (1 + l) * n) := by ring\n      _ ‚â§ (n : ‚Ñù)‚Åª¬π * u n := by gcongr; linarith only [hn]\n  ¬∑ obtain ‚ü®Œµ, hŒµ, Œµpos‚ü© : ‚àÉ Œµ : ‚Ñù, l + Œµ * (1 + Œµ + l) < d ‚àß 0 < Œµ := by\n      have L : Tendsto (fun Œµ => l + Œµ * (1 + Œµ + l)) (ùìù[>] 0) (ùìù (l + 0 * (1 + 0 + l))) := by\n        apply Tendsto.mono_left _ nhdsWithin_le_nhds\n        exact\n          tendsto_const_nhds.add\n            (tendsto_id.mul ((tendsto_const_nhds.add tendsto_id).add tendsto_const_nhds))\n      simp only [zero_mul, add_zero] at L\n      exact (((tendsto_order.1 L).2 d hd).and self_mem_nhdsWithin).exists\n    filter_upwards [A Œµ Œµpos, Ioi_mem_atTop 0] with n hn (npos : 0 < n)\n    calc\n      u n / n ‚â§ (n * l + Œµ * (1 + Œµ + l) * n) / n := by gcongr; linarith only [hn]\n      _ = (l + Œµ * (1 + Œµ + l)) := by field_simp; ring\n      _ < d := hŒµ\n\n"}
{"name":"tendsto_div_of_monotone_of_tendsto_div_floor_pow","module":"Mathlib.Analysis.SpecificLimits.FloorPow","initialProofState":"u : Nat ‚Üí Real\nl : Real\nhmono : Monotone u\nc : Nat ‚Üí Real\ncone : ‚àÄ (k : Nat), LT.lt 1 (c k)\nclim : Filter.Tendsto c Filter.atTop (nhds 1)\nhc : ‚àÄ (k : Nat), Filter.Tendsto (fun n => HDiv.hDiv (u (Nat.floor (HPow.hPow (c k) n))) ‚Üë(Nat.floor (HPow.hPow (c k) n))) Filter.atTop (nhds l)\n‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv (u n) ‚Üën) Filter.atTop (nhds l)","decl":"/-- If a monotone sequence `u` is such that `u ‚åäc^n‚åã‚Çä / ‚åäc^n‚åã‚Çä` converges to a limit `l` for all\n`c > 1`, then `u n / n` tends to `l`. It is even enough to have the assumption for a sequence of\n`c`s converging to `1`. -/\ntheorem tendsto_div_of_monotone_of_tendsto_div_floor_pow (u : ‚Ñï ‚Üí ‚Ñù) (l : ‚Ñù) (hmono : Monotone u)\n    (c : ‚Ñï ‚Üí ‚Ñù) (cone : ‚àÄ k, 1 < c k) (clim : Tendsto c atTop (ùìù 1))\n    (hc : ‚àÄ k, Tendsto (fun n : ‚Ñï => u ‚åäc k ^ n‚åã‚Çä / ‚åäc k ^ n‚åã‚Çä) atTop (ùìù l)) :\n    Tendsto (fun n => u n / n) atTop (ùìù l) := by\n  apply tendsto_div_of_monotone_of_exists_subseq_tendsto_div u l hmono\n  intro a ha\n  obtain ‚ü®k, hk‚ü© : ‚àÉ k, c k < a := ((tendsto_order.1 clim).2 a ha).exists\n  refine\n    ‚ü®fun n => ‚åäc k ^ n‚åã‚Çä, ?_,\n      (tendsto_nat_floor_atTop (Œ± := ‚Ñù)).comp (tendsto_pow_atTop_atTop_of_one_lt (cone k)), hc k‚ü©\n  have H : ‚àÄ n : ‚Ñï, (0 : ‚Ñù) < ‚åäc k ^ n‚åã‚Çä := by\n    intro n\n    refine zero_lt_one.trans_le ?_\n    simp only [Real.rpow_natCast, Nat.one_le_cast, Nat.one_le_floor_iff, one_le_pow‚ÇÄ (cone k).le]\n  have A :\n    Tendsto (fun n : ‚Ñï => (‚åäc k ^ (n + 1)‚åã‚Çä : ‚Ñù) / c k ^ (n + 1) * c k / (‚åäc k ^ n‚åã‚Çä / c k ^ n))\n      atTop (ùìù (1 * c k / 1)) := by\n    refine Tendsto.div (Tendsto.mul ?_ tendsto_const_nhds) ?_ one_ne_zero\n    ¬∑ refine tendsto_nat_floor_div_atTop.comp ?_\n      exact (tendsto_pow_atTop_atTop_of_one_lt (cone k)).comp (tendsto_add_atTop_nat 1)\n    ¬∑ refine tendsto_nat_floor_div_atTop.comp ?_\n      exact tendsto_pow_atTop_atTop_of_one_lt (cone k)\n  have B : Tendsto (fun n : ‚Ñï => (‚åäc k ^ (n + 1)‚åã‚Çä : ‚Ñù) / ‚åäc k ^ n‚åã‚Çä) atTop (ùìù (c k)) := by\n    simp only [one_mul, div_one] at A\n    convert A using 1\n    ext1 n\n    field_simp [(zero_lt_one.trans (cone k)).ne', (H n).ne']\n    ring\n  filter_upwards [(tendsto_order.1 B).2 a hk] with n hn\n  exact (div_le_iff‚ÇÄ (H n)).1 hn.le\n\n"}
{"name":"sum_div_pow_sq_le_div_sq","module":"Mathlib.Analysis.SpecificLimits.FloorPow","initialProofState":"N : Nat\nj : Real\nhj : LT.lt 0 j\nc : Real\nhc : LT.lt 1 c\n‚ä¢ LE.le ((Finset.filter (fun i => LT.lt j (HPow.hPow c i)) (Finset.range N)).sum fun i => HDiv.hDiv 1 (HPow.hPow (HPow.hPow c i) 2)) (HDiv.hDiv (HMul.hMul (HPow.hPow c 3) (Inv.inv (HSub.hSub c 1))) (HPow.hPow j 2))","decl":"/-- The sum of `1/(c^i)^2` above a threshold `j` is comparable to `1/j^2`, up to a multiplicative\nconstant. -/\ntheorem sum_div_pow_sq_le_div_sq (N : ‚Ñï) {j : ‚Ñù} (hj : 0 < j) {c : ‚Ñù} (hc : 1 < c) :\n    (‚àë i ‚àà range N with j < c ^ i, (1 : ‚Ñù) / (c ^ i) ^ 2) ‚â§ c ^ 3 * (c - 1)‚Åª¬π / j ^ 2 := by\n  have cpos : 0 < c := zero_lt_one.trans hc\n  have A : (0 : ‚Ñù) < c‚Åª¬π ^ 2 := sq_pos_of_pos (inv_pos.2 cpos)\n  have B : c ^ 2 * ((1 : ‚Ñù) - c‚Åª¬π ^ 2)‚Åª¬π ‚â§ c ^ 3 * (c - 1)‚Åª¬π := by\n    rw [‚Üê div_eq_mul_inv, ‚Üê div_eq_mul_inv, div_le_div_iff‚ÇÄ _ (sub_pos.2 hc)]\n    swap\n    ¬∑ exact sub_pos.2 (pow_lt_one‚ÇÄ (inv_nonneg.2 cpos.le) (inv_lt_one_of_one_lt‚ÇÄ hc) two_ne_zero)\n    have : c ^ 3 = c ^ 2 * c := by ring\n    simp only [mul_sub, this, mul_one, inv_pow, sub_le_sub_iff_left]\n    rw [mul_assoc, mul_comm c, ‚Üê mul_assoc, mul_inv_cancel‚ÇÄ (sq_pos_of_pos cpos).ne', one_mul]\n    simpa using pow_right_mono‚ÇÄ hc.le one_le_two\n  have C : c‚Åª¬π ^ 2 < 1 := pow_lt_one‚ÇÄ (inv_nonneg.2 cpos.le) (inv_lt_one_of_one_lt‚ÇÄ hc) two_ne_zero\n  calc\n    (‚àë i ‚àà range N with j < c ^ i, (1 : ‚Ñù) / (c ^ i) ^ 2) ‚â§\n        ‚àë i ‚àà Ico ‚åäReal.log j / Real.log c‚åã‚Çä N, (1 : ‚Ñù) / (c ^ i) ^ 2 := by\n      refine sum_le_sum_of_subset_of_nonneg (fun i hi ‚Ü¶ ?_) (by intros; positivity)\n      simp only [mem_filter, mem_range] at hi\n      simp only [hi.1, mem_Ico, and_true]\n      apply Nat.floor_le_of_le\n      apply le_of_lt\n      rw [div_lt_iff‚ÇÄ (Real.log_pos hc), ‚Üê Real.log_pow]\n      exact Real.log_lt_log hj hi.2\n    _ = ‚àë i ‚àà Ico ‚åäReal.log j / Real.log c‚åã‚Çä N, (c‚Åª¬π ^ 2) ^ i := by\n      congr 1 with i\n      simp [‚Üê pow_mul, mul_comm]\n    _ ‚â§ (c‚Åª¬π ^ 2) ^ ‚åäReal.log j / Real.log c‚åã‚Çä / ((1 : ‚Ñù) - c‚Åª¬π ^ 2) :=\n      geom_sum_Ico_le_of_lt_one (sq_nonneg _) C\n    _ ‚â§ (c‚Åª¬π ^ 2) ^ (Real.log j / Real.log c - 1) / ((1 : ‚Ñù) - c‚Åª¬π ^ 2) := by\n      gcongr\n      ¬∑ exact sub_nonneg.2 C.le\n      ¬∑ rw [‚Üê Real.rpow_natCast]\n        exact Real.rpow_le_rpow_of_exponent_ge A C.le (Nat.sub_one_lt_floor _).le\n    _ = c ^ 2 * ((1 : ‚Ñù) - c‚Åª¬π ^ 2)‚Åª¬π / j ^ 2 := by\n      have I : (c‚Åª¬π ^ 2) ^ (Real.log j / Real.log c) = (1 : ‚Ñù) / j ^ 2 := by\n        apply Real.log_injOn_pos (Real.rpow_pos_of_pos A _)\n        ¬∑ rw [Set.mem_Ioi]; positivity\n        rw [Real.log_rpow A]\n        simp only [one_div, Real.log_inv, Real.log_pow, Nat.cast_one, mul_neg, neg_inj]\n        field_simp [(Real.log_pos hc).ne']\n        ring\n      rw [Real.rpow_sub A, I]\n      have : c ^ 2 - 1 ‚â† 0 := (sub_pos.2 (one_lt_pow‚ÇÄ hc two_ne_zero)).ne'\n      field_simp [hj.ne', (zero_lt_one.trans hc).ne']\n      ring\n    _ ‚â§ c ^ 3 * (c - 1)‚Åª¬π / j ^ 2 := by gcongr\n\n"}
{"name":"mul_pow_le_nat_floor_pow","module":"Mathlib.Analysis.SpecificLimits.FloorPow","initialProofState":"c : Real\nhc : LT.lt 1 c\ni : Nat\n‚ä¢ LE.le (HMul.hMul (HSub.hSub 1 (Inv.inv c)) (HPow.hPow c i)) ‚Üë(Nat.floor (HPow.hPow c i))","decl":"theorem mul_pow_le_nat_floor_pow {c : ‚Ñù} (hc : 1 < c) (i : ‚Ñï) : (1 - c‚Åª¬π) * c ^ i ‚â§ ‚åäc ^ i‚åã‚Çä := by\n  have cpos : 0 < c := zero_lt_one.trans hc\n  rcases eq_or_ne i 0 with (rfl | hi)\n  ¬∑ simp only [pow_zero, Nat.floor_one, Nat.cast_one, mul_one, sub_le_self_iff, inv_nonneg, cpos.le]\n  calc\n    (1 - c‚Åª¬π) * c ^ i = c ^ i - c ^ i * c‚Åª¬π := by ring\n    _ ‚â§ c ^ i - 1 := by\n      gcongr\n      simpa only [‚Üê div_eq_mul_inv, one_le_div cpos, pow_one] using le_self_pow‚ÇÄ hc.le hi\n    _ ‚â§ ‚åäc ^ i‚åã‚Çä := (Nat.sub_one_lt_floor _).le\n\n"}
{"name":"sum_div_nat_floor_pow_sq_le_div_sq","module":"Mathlib.Analysis.SpecificLimits.FloorPow","initialProofState":"N : Nat\nj : Real\nhj : LT.lt 0 j\nc : Real\nhc : LT.lt 1 c\n‚ä¢ LE.le ((Finset.filter (fun i => LT.lt j ‚Üë(Nat.floor (HPow.hPow c i))) (Finset.range N)).sum fun i => HDiv.hDiv 1 (HPow.hPow (‚Üë(Nat.floor (HPow.hPow c i))) 2)) (HDiv.hDiv (HMul.hMul (HPow.hPow c 5) (HPow.hPow (Inv.inv (HSub.hSub c 1)) 3)) (HPow.hPow j 2))","decl":"/-- The sum of `1/‚åäc^i‚åã‚Çä^2` above a threshold `j` is comparable to `1/j^2`, up to a multiplicative\nconstant. -/\ntheorem sum_div_nat_floor_pow_sq_le_div_sq (N : ‚Ñï) {j : ‚Ñù} (hj : 0 < j) {c : ‚Ñù} (hc : 1 < c) :\n    (‚àë i ‚àà range N with j < ‚åäc ^ i‚åã‚Çä, (1 : ‚Ñù) / (‚åäc ^ i‚åã‚Çä : ‚Ñù) ^ 2) ‚â§\n      c ^ 5 * (c - 1)‚Åª¬π ^ 3 / j ^ 2 := by\n  have cpos : 0 < c := zero_lt_one.trans hc\n  have A : 0 < 1 - c‚Åª¬π := sub_pos.2 (inv_lt_one_of_one_lt‚ÇÄ hc)\n  calc\n    (‚àë i ‚àà range N with j < ‚åäc ^ i‚åã‚Çä, (1 : ‚Ñù) / (‚åäc ^ i‚åã‚Çä : ‚Ñù) ^ 2) ‚â§\n        ‚àë i ‚àà range N with j < c ^ i, (1 : ‚Ñù) / (‚åäc ^ i‚åã‚Çä : ‚Ñù) ^ 2 := by\n      gcongr\n      exact fun k hk ‚Ü¶ hk.trans_le <| Nat.floor_le (by positivity)\n    _ ‚â§ ‚àë i ‚àà range N with j < c ^ i, (1 - c‚Åª¬π)‚Åª¬π ^ 2 * ((1 : ‚Ñù) / (c ^ i) ^ 2) := by\n      refine sum_le_sum fun i _hi => ?_\n      rw [mul_div_assoc', mul_one, div_le_div_iff‚ÇÄ]; rotate_left\n      ¬∑ apply sq_pos_of_pos\n        refine zero_lt_one.trans_le ?_\n        simp only [Nat.le_floor, one_le_pow‚ÇÄ, hc.le, Nat.one_le_cast, Nat.cast_one]\n      ¬∑ exact sq_pos_of_pos (pow_pos cpos _)\n      rw [one_mul, ‚Üê mul_pow]\n      gcongr\n      rw [‚Üê div_eq_inv_mul, le_div_iff‚ÇÄ A, mul_comm]\n      exact mul_pow_le_nat_floor_pow hc i\n    _ ‚â§ (1 - c‚Åª¬π)‚Åª¬π ^ 2 * (c ^ 3 * (c - 1)‚Åª¬π) / j ^ 2 := by\n      rw [‚Üê mul_sum, ‚Üê mul_div_assoc']\n      gcongr\n      exact sum_div_pow_sq_le_div_sq N hj hc\n    _ = c ^ 5 * (c - 1)‚Åª¬π ^ 3 / j ^ 2 := by\n      congr 1\n      field_simp [(sub_pos.2 hc).ne']\n      ring!\n"}
