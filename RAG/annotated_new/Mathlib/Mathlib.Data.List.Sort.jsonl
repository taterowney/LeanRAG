{"name":"List.Sorted.le_of_lt","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\ninst✝ : Preorder α\nl : List α\nh : List.Sorted (fun x1 x2 => LT.lt x1 x2) l\n⊢ List.Sorted (fun x1 x2 => LE.le x1 x2) l","decl":"protected theorem Sorted.le_of_lt [Preorder α] {l : List α} (h : l.Sorted (· < ·)) :\n    l.Sorted (· ≤ ·) :=\n  h.imp le_of_lt\n\n"}
{"name":"List.Sorted.lt_of_le","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\ninst✝ : PartialOrder α\nl : List α\nh₁ : List.Sorted (fun x1 x2 => LE.le x1 x2) l\nh₂ : l.Nodup\n⊢ List.Sorted (fun x1 x2 => LT.lt x1 x2) l","decl":"protected theorem Sorted.lt_of_le [PartialOrder α] {l : List α} (h₁ : l.Sorted (· ≤ ·))\n    (h₂ : l.Nodup) : l.Sorted (· < ·) :=\n  h₁.imp₂ (fun _ _ => lt_of_le_of_ne) h₂\n\n"}
{"name":"List.Sorted.ge_of_gt","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\ninst✝ : Preorder α\nl : List α\nh : List.Sorted (fun x1 x2 => GT.gt x1 x2) l\n⊢ List.Sorted (fun x1 x2 => GE.ge x1 x2) l","decl":"protected theorem Sorted.ge_of_gt [Preorder α] {l : List α} (h : l.Sorted (· > ·)) :\n    l.Sorted (· ≥ ·) :=\n  h.imp le_of_lt\n\n"}
{"name":"List.Sorted.gt_of_ge","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\ninst✝ : PartialOrder α\nl : List α\nh₁ : List.Sorted (fun x1 x2 => GE.ge x1 x2) l\nh₂ : l.Nodup\n⊢ List.Sorted (fun x1 x2 => GT.gt x1 x2) l","decl":"protected theorem Sorted.gt_of_ge [PartialOrder α] {l : List α} (h₁ : l.Sorted (· ≥ ·))\n    (h₂ : l.Nodup) : l.Sorted (· > ·) :=\n  h₁.imp₂ (fun _ _ => lt_of_le_of_ne) <| by simp_rw [ne_comm]; exact h₂\n\n"}
{"name":"List.sorted_nil","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\n⊢ List.Sorted r List.nil","decl":"@[simp]\ntheorem sorted_nil : Sorted r [] :=\n  Pairwise.nil\n\n"}
{"name":"List.Sorted.of_cons","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\na : α\nl : List α\na✝ : List.Sorted r (List.cons a l)\n⊢ List.Sorted r l","decl":"theorem Sorted.of_cons : Sorted r (a :: l) → Sorted r l :=\n  Pairwise.of_cons\n\n"}
{"name":"List.Sorted.tail","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\nl : List α\nh : List.Sorted r l\n⊢ List.Sorted r l.tail","decl":"theorem Sorted.tail {r : α → α → Prop} {l : List α} (h : Sorted r l) : Sorted r l.tail :=\n  Pairwise.tail h\n\n"}
{"name":"List.rel_of_sorted_cons","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\na : α\nl : List α\na✝¹ : List.Sorted r (List.cons a l)\nb : α\na✝ : Membership.mem l b\n⊢ r a b","decl":"theorem rel_of_sorted_cons {a : α} {l : List α} : Sorted r (a :: l) → ∀ b ∈ l, r a b :=\n  rel_of_pairwise_cons\n\n"}
{"name":"List.Sorted.cons","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsTrans α r\nl : List α\na b : α\nhab : r a b\nh : List.Sorted r (List.cons b l)\n⊢ List.Sorted r (List.cons a (List.cons b l))","decl":"nonrec theorem Sorted.cons {r : α → α → Prop} [IsTrans α r] {l : List α} {a b : α}\n    (hab : r a b) (h : Sorted r (b :: l)) : Sorted r (a :: b :: l) :=\n  h.cons <| forall_mem_cons.2 ⟨hab, fun _ hx => _root_.trans hab <| rel_of_sorted_cons h _ hx⟩\n\n"}
{"name":"List.sorted_cons_cons","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsTrans α r\nl : List α\na b : α\n⊢ Iff (List.Sorted r (List.cons b (List.cons a l))) (And (r b a) (List.Sorted r (List.cons a l)))","decl":"theorem sorted_cons_cons {r : α → α → Prop} [IsTrans α r] {l : List α} {a b : α} :\n    Sorted r (b :: a :: l) ↔ r b a ∧ Sorted r (a :: l) := by\n  constructor\n  · intro h\n    exact ⟨rel_of_sorted_cons h _ (mem_cons_self a _), h.of_cons⟩\n  · rintro ⟨h, ha⟩\n    exact ha.cons h\n\n"}
{"name":"List.Sorted.head!_le","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\ninst✝¹ : Inhabited α\ninst✝ : Preorder α\na : α\nl : List α\nh : List.Sorted (fun x1 x2 => LT.lt x1 x2) l\nha : Membership.mem l a\n⊢ LE.le l.head! a","decl":"theorem Sorted.head!_le [Inhabited α] [Preorder α] {a : α} {l : List α} (h : Sorted (· < ·) l)\n    (ha : a ∈ l) : l.head! ≤ a := by\n  rw [← List.cons_head!_tail (List.ne_nil_of_mem ha)] at h ha\n  cases ha\n  · exact le_rfl\n  · exact le_of_lt (rel_of_sorted_cons h a (by assumption))\n\n"}
{"name":"List.Sorted.le_head!","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\ninst✝¹ : Inhabited α\ninst✝ : Preorder α\na : α\nl : List α\nh : List.Sorted (fun x1 x2 => GT.gt x1 x2) l\nha : Membership.mem l a\n⊢ LE.le a l.head!","decl":"theorem Sorted.le_head! [Inhabited α] [Preorder α] {a : α} {l : List α} (h : Sorted (· > ·) l)\n    (ha : a ∈ l) : a ≤ l.head! := by\n  rw [← List.cons_head!_tail (List.ne_nil_of_mem ha)] at h ha\n  cases ha\n  · exact le_rfl\n  · exact le_of_lt (rel_of_sorted_cons h a (by assumption))\n\n"}
{"name":"List.sorted_cons","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\na : α\nl : List α\n⊢ Iff (List.Sorted r (List.cons a l)) (And (∀ (b : α), Membership.mem l b → r a b) (List.Sorted r l))","decl":"@[simp]\ntheorem sorted_cons {a : α} {l : List α} : Sorted r (a :: l) ↔ (∀ b ∈ l, r a b) ∧ Sorted r l :=\n  pairwise_cons\n\n"}
{"name":"List.Sorted.nodup","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsIrrefl α r\nl : List α\nh : List.Sorted r l\n⊢ l.Nodup","decl":"protected theorem Sorted.nodup {r : α → α → Prop} [IsIrrefl α r] {l : List α} (h : Sorted r l) :\n    Nodup l :=\n  Pairwise.nodup h\n\n"}
{"name":"List.Sorted.filter","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\nl : List α\nf : α → Bool\nh : List.Sorted r l\n⊢ List.Sorted r (List.filter f l)","decl":"protected theorem Sorted.filter {l : List α} (f : α → Bool) (h : Sorted r l) :\n    Sorted r (filter f l) :=\n  h.sublist (filter_sublist l)\n\n"}
{"name":"List.eq_of_perm_of_sorted","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsAntisymm α r\nl₁ l₂ : List α\nhp : l₁.Perm l₂\nhs₁ : List.Sorted r l₁\nhs₂ : List.Sorted r l₂\n⊢ Eq l₁ l₂","decl":"theorem eq_of_perm_of_sorted [IsAntisymm α r] {l₁ l₂ : List α} (hp : l₁ ~ l₂) (hs₁ : Sorted r l₁)\n    (hs₂ : Sorted r l₂) : l₁ = l₂ := by\n  induction' hs₁ with a l₁ h₁ hs₁ IH generalizing l₂\n  · exact hp.nil_eq\n  · have : a ∈ l₂ := hp.subset (mem_cons_self _ _)\n    rcases append_of_mem this with ⟨u₂, v₂, rfl⟩\n    have hp' := (perm_cons a).1 (hp.trans perm_middle)\n    obtain rfl := IH hp' (hs₂.sublist <| by simp)\n    change a :: u₂ ++ v₂ = u₂ ++ ([a] ++ v₂)\n    rw [← append_assoc]\n    congr\n    have : ∀ x ∈ u₂, x = a := fun x m =>\n      antisymm ((pairwise_append.1 hs₂).2.2 _ m a (mem_cons_self _ _)) (h₁ _ (by simp [m]))\n    rw [(@eq_replicate_iff _ a (length u₂ + 1) (a :: u₂)).2,\n        (@eq_replicate_iff _ a (length u₂ + 1) (u₂ ++ [a])).2] <;>\n        constructor <;>\n      simp [iff_true_intro this, or_comm]\n\n"}
{"name":"List.sublist_of_subperm_of_sorted","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsAntisymm α r\nl₁ l₂ : List α\nhp : l₁.Subperm l₂\nhs₁ : List.Sorted r l₁\nhs₂ : List.Sorted r l₂\n⊢ l₁.Sublist l₂","decl":"theorem sublist_of_subperm_of_sorted [IsAntisymm α r] {l₁ l₂ : List α} (hp : l₁ <+~ l₂)\n    (hs₁ : l₁.Sorted r) (hs₂ : l₂.Sorted r) : l₁ <+ l₂ := by\n  let ⟨_, h, h'⟩ := hp\n  rwa [← eq_of_perm_of_sorted h (hs₂.sublist h') hs₁]\n\n"}
{"name":"List.sorted_singleton","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\na : α\n⊢ List.Sorted r (List.cons a List.nil)","decl":"@[simp 1100] -- Porting note: higher priority for linter\ntheorem sorted_singleton (a : α) : Sorted r [a] :=\n  pairwise_singleton _ _\n\n"}
{"name":"List.sorted_lt_range","module":"Mathlib.Data.List.Sort","initialProofState":"n : Nat\n⊢ List.Sorted (fun x1 x2 => LT.lt x1 x2) (List.range n)","decl":"theorem sorted_lt_range (n : ℕ) : Sorted (· < ·) (range n) := by\n  rw [Sorted, pairwise_iff_get]\n  simp\n\n"}
{"name":"List.sorted_le_range","module":"Mathlib.Data.List.Sort","initialProofState":"n : Nat\n⊢ List.Sorted (fun x1 x2 => LE.le x1 x2) (List.range n)","decl":"theorem sorted_le_range (n : ℕ) : Sorted (· ≤ ·) (range n) :=\n  (sorted_lt_range n).le_of_lt\n\n"}
{"name":"List.Sorted.rel_get_of_lt","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\nl : List α\nh : List.Sorted r l\na b : Fin l.length\nhab : LT.lt a b\n⊢ r (l.get a) (l.get b)","decl":"theorem Sorted.rel_get_of_lt {l : List α} (h : l.Sorted r) {a b : Fin l.length} (hab : a < b) :\n    r (l.get a) (l.get b) :=\n  List.pairwise_iff_get.1 h _ _ hab\n\n"}
{"name":"List.Sorted.rel_get_of_le","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsRefl α r\nl : List α\nh : List.Sorted r l\na b : Fin l.length\nhab : LE.le a b\n⊢ r (l.get a) (l.get b)","decl":"theorem Sorted.rel_get_of_le [IsRefl α r] {l : List α} (h : l.Sorted r) {a b : Fin l.length}\n    (hab : a ≤ b) : r (l.get a) (l.get b) := by\n  obtain rfl | hlt := Fin.eq_or_lt_of_le hab; exacts [refl _, h.rel_get_of_lt hlt]\n\n"}
{"name":"List.Sorted.rel_of_mem_take_of_mem_drop","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\nl : List α\nh : List.Sorted r l\nk : Nat\nx y : α\nhx : Membership.mem (List.take k l) x\nhy : Membership.mem (List.drop k l) y\n⊢ r x y","decl":"theorem Sorted.rel_of_mem_take_of_mem_drop {l : List α} (h : List.Sorted r l) {k : ℕ} {x y : α}\n    (hx : x ∈ List.take k l) (hy : y ∈ List.drop k l) : r x y := by\n  obtain ⟨iy, hiy, rfl⟩ := getElem_of_mem hy\n  obtain ⟨ix, hix, rfl⟩ := getElem_of_mem hx\n  rw [getElem_take, getElem_drop]\n  rw [length_take] at hix\n  exact h.rel_get_of_lt (Nat.lt_add_right _ (Nat.lt_min.mp hix).left)\n\n"}
{"name":"List.Sorted.decide","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : DecidableRel r\nl : List α\nh : List.Sorted r l\n⊢ List.Sorted (fun a b => Eq (Decidable.decide (r a b)) Bool.true) l","decl":"/--\nIf a list is sorted with respect to a decidable relation,\nthen it is sorted with respect to the corresponding Bool-valued relation.\n-/\ntheorem Sorted.decide [DecidableRel r] (l : List α) (h : Sorted r l) :\n    Sorted (fun a b => decide (r a b) = true) l := by\n  refine h.imp fun {a b} h => by simpa using h\n\n"}
{"name":"List.sorted_ofFn_iff","module":"Mathlib.Data.List.Sort","initialProofState":"n : Nat\nα : Type u\nf : Fin n → α\nr : α → α → Prop\n⊢ Iff (List.Sorted r (List.ofFn f)) (Relator.LiftFun (fun x1 x2 => LT.lt x1 x2) r f f)","decl":"theorem sorted_ofFn_iff {r : α → α → Prop} : (ofFn f).Sorted r ↔ ((· < ·) ⇒ r) f f := by\n  simp_rw [Sorted, pairwise_iff_get, get_ofFn, Relator.LiftFun]\n  exact Iff.symm (Fin.rightInverse_cast _).surjective.forall₂\n\n"}
{"name":"List.sorted_lt_ofFn_iff","module":"Mathlib.Data.List.Sort","initialProofState":"n : Nat\nα : Type u\nf : Fin n → α\ninst✝ : Preorder α\n⊢ Iff (List.Sorted (fun x1 x2 => LT.lt x1 x2) (List.ofFn f)) (StrictMono f)","decl":"/-- The list `List.ofFn f` is strictly sorted with respect to `(· ≤ ·)` if and only if `f` is\nstrictly monotone. -/\n@[simp] theorem sorted_lt_ofFn_iff : (ofFn f).Sorted (· < ·) ↔ StrictMono f := sorted_ofFn_iff\n\n"}
{"name":"List.sorted_le_ofFn_iff","module":"Mathlib.Data.List.Sort","initialProofState":"n : Nat\nα : Type u\nf : Fin n → α\ninst✝ : Preorder α\n⊢ Iff (List.Sorted (fun x1 x2 => LE.le x1 x2) (List.ofFn f)) (Monotone f)","decl":"/-- The list `List.ofFn f` is sorted with respect to `(· ≤ ·)` if and only if `f` is monotone. -/\n@[simp] theorem sorted_le_ofFn_iff : (ofFn f).Sorted (· ≤ ·) ↔ Monotone f :=\n  sorted_ofFn_iff.trans monotone_iff_forall_lt.symm\n\n"}
{"name":"Monotone.ofFn_sorted","module":"Mathlib.Data.List.Sort","initialProofState":"n : Nat\nα : Type u\nf : Fin n → α\ninst✝ : Preorder α\na✝ : Monotone f\n⊢ List.Sorted (fun x1 x2 => LE.le x1 x2) (List.ofFn f)","decl":"/-- The list obtained from a monotone tuple is sorted. -/\nalias ⟨_, _root_.Monotone.ofFn_sorted⟩ := sorted_le_ofFn_iff\n\n"}
{"name":"List.orderedInsert_of_le","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : DecidableRel r\na b : α\nl : List α\nh : r a b\n⊢ Eq (List.orderedInsert r a (List.cons b l)) (List.cons a (List.cons b l))","decl":"theorem orderedInsert_of_le {a b : α} (l : List α) (h : a ≼ b) :\n    orderedInsert r a (b :: l) = a :: b :: l :=\n  dif_pos h\n\n"}
{"name":"List.orderedInsert_nil","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : DecidableRel r\na : α\n⊢ Eq (List.orderedInsert r a List.nil) (List.cons a List.nil)","decl":"@[simp]\ntheorem orderedInsert_nil (a : α) : [].orderedInsert r a = [a] :=\n  rfl\n\n"}
{"name":"List.orderedInsert_length","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : DecidableRel r\nL : List α\na : α\n⊢ Eq (List.orderedInsert r a L).length (HAdd.hAdd L.length 1)","decl":"theorem orderedInsert_length : ∀ (L : List α) (a : α), (L.orderedInsert r a).length = L.length + 1\n  | [], _ => rfl\n  | hd :: tl, a => by\n    dsimp [orderedInsert]\n    split_ifs <;> simp [orderedInsert_length tl]\n\n"}
{"name":"List.orderedInsert_eq_take_drop","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : DecidableRel r\na : α\nl : List α\n⊢ Eq (List.orderedInsert r a l) (HAppend.hAppend (List.takeWhile (fun b => Decidable.decide (Not (r a b))) l) (List.cons a (List.dropWhile (fun b => Decidable.decide (Not (r a b))) l)))","decl":"/-- An alternative definition of `orderedInsert` using `takeWhile` and `dropWhile`. -/\ntheorem orderedInsert_eq_take_drop (a : α) :\n    ∀ l : List α,\n      l.orderedInsert r a = (l.takeWhile fun b => ¬a ≼ b) ++ a :: l.dropWhile fun b => ¬a ≼ b\n  | [] => rfl\n  | b :: l => by\n    dsimp only [orderedInsert]\n    split_ifs with h <;> simp [takeWhile, dropWhile, *, orderedInsert_eq_take_drop a l]\n\n"}
{"name":"List.insertionSort_cons_eq_take_drop","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : DecidableRel r\na : α\nl : List α\n⊢ Eq (List.insertionSort r (List.cons a l)) (HAppend.hAppend (List.takeWhile (fun b => Decidable.decide (Not (r a b))) (List.insertionSort r l)) (List.cons a (List.dropWhile (fun b => Decidable.decide (Not (r a b))) (List.insertionSort r l))))","decl":"theorem insertionSort_cons_eq_take_drop (a : α) (l : List α) :\n    insertionSort r (a :: l) =\n      ((insertionSort r l).takeWhile fun b => ¬a ≼ b) ++\n        a :: (insertionSort r l).dropWhile fun b => ¬a ≼ b :=\n  orderedInsert_eq_take_drop r a _\n\n"}
{"name":"List.mem_orderedInsert","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : DecidableRel r\na b : α\nl : List α\n⊢ Iff (Membership.mem (List.orderedInsert r b l) a) (Or (Eq a b) (Membership.mem l a))","decl":"@[simp]\ntheorem mem_orderedInsert {a b : α} {l : List α} :\n    a ∈ orderedInsert r b l ↔ a = b ∨ a ∈ l :=\n  match l with\n  | [] => by simp [orderedInsert]\n  | x :: xs => by\n    rw [orderedInsert]\n    split_ifs\n    · simp [orderedInsert]\n    · rw [mem_cons, mem_cons, mem_orderedInsert, or_left_comm]\n\n"}
{"name":"List.map_orderedInsert","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : DecidableRel r\ninst✝ : DecidableRel s\nf : α → β\nl : List α\nx : α\nhl₁ : ∀ (a : α), Membership.mem l a → Iff (r a x) (s (f a) (f x))\nhl₂ : ∀ (a : α), Membership.mem l a → Iff (r x a) (s (f x) (f a))\n⊢ Eq (List.map f (List.orderedInsert r x l)) (List.orderedInsert s (f x) (List.map f l))","decl":"theorem map_orderedInsert (f : α → β) (l : List α) (x : α)\n    (hl₁ : ∀ a ∈ l, a ≼ x ↔ f a ≼ f x) (hl₂ : ∀ a ∈ l, x ≼ a ↔ f x ≼ f a) :\n    (l.orderedInsert r x).map f = (l.map f).orderedInsert s (f x) := by\n  induction l with\n  | nil => simp\n  | cons x xs ih =>\n    rw [List.forall_mem_cons] at hl₁ hl₂\n    simp only [List.map, List.orderedInsert, ← hl₁.1, ← hl₂.1]\n    split_ifs\n    · rw [List.map, List.map]\n    · rw [List.map, ih (fun _ ha => hl₁.2 _ ha) (fun _ ha => hl₂.2 _ ha)]\n\n"}
{"name":"List.perm_orderedInsert","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : DecidableRel r\na : α\nl : List α\n⊢ (List.orderedInsert r a l).Perm (List.cons a l)","decl":"theorem perm_orderedInsert (a) : ∀ l : List α, orderedInsert r a l ~ a :: l\n  | [] => Perm.refl _\n  | b :: l => by\n    by_cases h : a ≼ b\n    · simp [orderedInsert, h]\n    · simpa [orderedInsert, h] using ((perm_orderedInsert a l).cons _).trans (Perm.swap _ _ _)\n\n"}
{"name":"List.orderedInsert_count","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝¹ : DecidableRel r\ninst✝ : DecidableEq α\nL : List α\na b : α\n⊢ Eq (List.count a (List.orderedInsert r b L)) (HAdd.hAdd (List.count a L) (ite (Eq b a) 1 0))","decl":"theorem orderedInsert_count [DecidableEq α] (L : List α) (a b : α) :\n    count a (L.orderedInsert r b) = count a L + if b = a then 1 else 0 := by\n  rw [(L.perm_orderedInsert r b).count_eq, count_cons]\n  simp\n\n"}
{"name":"List.perm_insertionSort","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : DecidableRel r\nl : List α\n⊢ (List.insertionSort r l).Perm l","decl":"theorem perm_insertionSort : ∀ l : List α, insertionSort r l ~ l\n  | [] => Perm.nil\n  | b :: l => by\n    simpa [insertionSort] using (perm_orderedInsert _ _ _).trans ((perm_insertionSort l).cons b)\n\n"}
{"name":"List.mem_insertionSort","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : DecidableRel r\nl : List α\nx : α\n⊢ Iff (Membership.mem (List.insertionSort r l) x) (Membership.mem l x)","decl":"@[simp]\ntheorem mem_insertionSort {l : List α} {x : α} : x ∈ l.insertionSort r ↔ x ∈ l :=\n  (perm_insertionSort r l).mem_iff\n\n"}
{"name":"List.length_insertionSort","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : DecidableRel r\nl : List α\n⊢ Eq (List.insertionSort r l).length l.length","decl":"@[simp]\ntheorem length_insertionSort (l : List α) : (insertionSort r l).length = l.length :=\n  (perm_insertionSort r _).length_eq\n\n"}
{"name":"List.insertionSort_cons","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : DecidableRel r\na : α\nl : List α\nh : ∀ (b : α), Membership.mem l b → r a b\n⊢ Eq (List.insertionSort r (List.cons a l)) (List.cons a (List.insertionSort r l))","decl":"theorem insertionSort_cons {a : α} {l : List α} (h : ∀ b ∈ l, r a b) :\n    insertionSort r (a :: l) = a :: insertionSort r l := by\n  rw [insertionSort]\n  cases hi : insertionSort r l with\n  | nil => rfl\n  | cons b m =>\n    rw [orderedInsert_of_le]\n    apply h b <| (mem_insertionSort r).1 _\n    rw [hi]\n    exact mem_cons_self b m\n\n"}
{"name":"List.map_insertionSort","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : DecidableRel r\ninst✝ : DecidableRel s\nf : α → β\nl : List α\nhl : ∀ (a : α), Membership.mem l a → ∀ (b : α), Membership.mem l b → Iff (r a b) (s (f a) (f b))\n⊢ Eq (List.map f (List.insertionSort r l)) (List.insertionSort s (List.map f l))","decl":"theorem map_insertionSort (f : α → β) (l : List α) (hl : ∀ a ∈ l, ∀ b ∈ l, a ≼ b ↔ f a ≼ f b) :\n    (l.insertionSort r).map f = (l.map f).insertionSort s := by\n  induction l with\n  | nil => simp\n  | cons x xs ih =>\n    simp_rw [List.forall_mem_cons, forall_and] at hl\n    simp_rw [List.map, List.insertionSort]\n    rw [List.map_orderedInsert _ s, ih hl.2.2]\n    · simpa only [mem_insertionSort] using hl.2.1\n    · simpa only [mem_insertionSort] using hl.1.2\n\n"}
{"name":"List.Sorted.insertionSort_eq","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : DecidableRel r\nl : List α\na✝ : List.Sorted r l\n⊢ Eq (List.insertionSort r l) l","decl":"/-- If `l` is already `List.Sorted` with respect to `r`, then `insertionSort` does not change\nit. -/\ntheorem Sorted.insertionSort_eq : ∀ {l : List α}, Sorted r l → insertionSort r l = l\n  | [], _ => rfl\n  | [_], _ => rfl\n  | a :: b :: l, h => by\n    rw [insertionSort, Sorted.insertionSort_eq, orderedInsert, if_pos]\n    exacts [rel_of_sorted_cons h _ (mem_cons_self _ _), h.tail]\n\n"}
{"name":"List.erase_orderedInsert","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝² : DecidableRel r\ninst✝¹ : DecidableEq α\ninst✝ : IsRefl α r\nx : α\nxs : List α\n⊢ Eq ((List.orderedInsert r x xs).erase x) xs","decl":"/-- For a reflexive relation, insert then erasing is the identity. -/\ntheorem erase_orderedInsert [DecidableEq α] [IsRefl α r] (x : α) (xs : List α) :\n    (xs.orderedInsert r x).erase x = xs := by\n  rw [orderedInsert_eq_take_drop, erase_append_right, List.erase_cons_head,\n    takeWhile_append_dropWhile]\n  intro h\n  replace h := mem_takeWhile_imp h\n  simp [refl x] at h\n\n"}
{"name":"List.erase_orderedInsert_of_not_mem","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝¹ : DecidableRel r\ninst✝ : DecidableEq α\nx : α\nxs : List α\nhx : Not (Membership.mem xs x)\n⊢ Eq ((List.orderedInsert r x xs).erase x) xs","decl":"/-- Inserting then erasing an element that is absent is the identity. -/\ntheorem erase_orderedInsert_of_not_mem [DecidableEq α]\n    {x : α} {xs : List α} (hx : x ∉ xs) :\n    (xs.orderedInsert r x).erase x = xs := by\n  rw [orderedInsert_eq_take_drop, erase_append_right, List.erase_cons_head,\n    takeWhile_append_dropWhile]\n  exact mt ((takeWhile_prefix _).sublist.subset ·) hx\n\n"}
{"name":"List.orderedInsert_erase","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝² : DecidableRel r\ninst✝¹ : DecidableEq α\ninst✝ : IsAntisymm α r\nx : α\nxs : List α\nhx : Membership.mem xs x\nhxs : List.Sorted r xs\n⊢ Eq (List.orderedInsert r x (xs.erase x)) xs","decl":"/-- For an antisymmetric relation, erasing then inserting is the identity. -/\ntheorem orderedInsert_erase [DecidableEq α] [IsAntisymm α r] (x : α) (xs : List α) (hx : x ∈ xs)\n    (hxs : Sorted r xs) :\n    (xs.erase x).orderedInsert r x = xs := by\n  induction xs generalizing x with\n  | nil => cases hx\n  | cons y ys ih =>\n    rw [sorted_cons] at hxs\n    obtain rfl | hxy := Decidable.eq_or_ne x y\n    · rw [erase_cons_head]\n      cases ys with\n      | nil => rfl\n      | cons z zs =>\n        rw [orderedInsert, if_pos (hxs.1 _ (.head zs))]\n    · rw [mem_cons] at hx\n      replace hx := hx.resolve_left hxy\n      rw [erase_cons_tail (not_beq_of_ne hxy.symm), orderedInsert, ih _ hx hxs.2, if_neg]\n      refine mt (fun hrxy => ?_) hxy\n      exact antisymm hrxy (hxs.1 _ hx)\n\n"}
{"name":"List.sublist_orderedInsert","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : DecidableRel r\nx : α\nxs : List α\n⊢ xs.Sublist (List.orderedInsert r x xs)","decl":"theorem sublist_orderedInsert (x : α) (xs : List α) : xs <+ xs.orderedInsert r x := by\n  rw [orderedInsert_eq_take_drop]\n  refine Sublist.trans ?_ (.append_left (.cons _ (.refl _)) _)\n  rw [takeWhile_append_dropWhile]\n\n"}
{"name":"List.cons_sublist_orderedInsert","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : DecidableRel r\nl c : List α\na : α\nhl : c.Sublist l\nha : ∀ (a' : α), Membership.mem c a' → r a a'\n⊢ (List.cons a c).Sublist (List.orderedInsert r a l)","decl":"theorem cons_sublist_orderedInsert {l c : List α} {a : α} (hl : c <+ l) (ha : ∀ a' ∈ c, a ≼ a') :\n    a :: c <+ orderedInsert r a l := by\n  induction l with\n  | nil         => simp_all only [sublist_nil, orderedInsert, Sublist.refl]\n  | cons _ _ ih =>\n    unfold orderedInsert\n    split_ifs with hr\n    · exact .cons₂ _ hl\n    · cases hl with\n      | cons _ h => exact .cons _ <| ih h\n      | cons₂    => exact absurd (ha _ <| mem_cons_self ..) hr\n\n"}
{"name":"List.Sublist.orderedInsert_sublist","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝¹ : DecidableRel r\ninst✝ : IsTrans α r\nas bs : List α\nx : α\nhs : as.Sublist bs\nhb : List.Sorted r bs\n⊢ (List.orderedInsert r x as).Sublist (List.orderedInsert r x bs)","decl":"theorem Sublist.orderedInsert_sublist [IsTrans α r] {as bs} (x) (hs : as <+ bs) (hb : bs.Sorted r) :\n    orderedInsert r x as <+ orderedInsert r x bs := by\n  cases as with\n  | nil => simp\n  | cons a as =>\n    cases bs with\n    | nil => contradiction\n    | cons b bs =>\n      unfold orderedInsert\n      cases hs <;> split_ifs with hr\n      · exact .cons₂ _ <| .cons _ ‹a :: as <+ bs›\n      · have ih := orderedInsert_sublist x ‹a :: as <+ bs›  hb.of_cons\n        simp only [hr, orderedInsert, ite_true] at ih\n        exact .trans ih <| .cons _ (.refl _)\n      · have hba := pairwise_cons.mp hb |>.left _ (mem_of_cons_sublist ‹a :: as <+ bs›)\n        exact absurd (trans_of _ ‹r x b› hba) hr\n      · have ih := orderedInsert_sublist x ‹a :: as <+ bs› hb.of_cons\n        rw [orderedInsert, if_neg hr] at ih\n        exact .cons _ ih\n      · simp_all only [sorted_cons, cons_sublist_cons]\n      · exact .cons₂ _ <| orderedInsert_sublist x ‹as <+ bs› hb.of_cons\n\n"}
{"name":"List.Sorted.orderedInsert","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝² : DecidableRel r\ninst✝¹ : IsTotal α r\ninst✝ : IsTrans α r\na : α\nl : List α\na✝ : List.Sorted r l\n⊢ List.Sorted r (List.orderedInsert r a l)","decl":"theorem Sorted.orderedInsert (a : α) : ∀ l, Sorted r l → Sorted r (orderedInsert r a l)\n  | [], _ => sorted_singleton a\n  | b :: l, h => by\n    by_cases h' : a ≼ b\n    · -- Porting note: was\n      -- `simpa [orderedInsert, h', h] using fun b' bm => trans h' (rel_of_sorted_cons h _ bm)`\n      rw [List.orderedInsert, if_pos h', sorted_cons]\n      exact ⟨forall_mem_cons.2 ⟨h', fun c hc => _root_.trans h' (rel_of_sorted_cons h _ hc)⟩, h⟩\n    · suffices ∀ b' : α, b' ∈ List.orderedInsert r a l → r b b' by\n        simpa [orderedInsert, h', h.of_cons.orderedInsert a l]\n      intro b' bm\n      cases' (mem_orderedInsert r).mp bm with be bm\n      · subst b'\n        exact (total_of r _ _).resolve_left h'\n      · exact rel_of_sorted_cons h _ bm\n\n"}
{"name":"List.sorted_insertionSort","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝² : DecidableRel r\ninst✝¹ : IsTotal α r\ninst✝ : IsTrans α r\nl : List α\n⊢ List.Sorted r (List.insertionSort r l)","decl":"/-- The list `List.insertionSort r l` is `List.Sorted` with respect to `r`. -/\ntheorem sorted_insertionSort : ∀ l, Sorted r (insertionSort r l)\n  | [] => sorted_nil\n  | a :: l => (sorted_insertionSort l).orderedInsert a _\n\n"}
{"name":"List.sublist_insertionSort","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : DecidableRel r\nl c : List α\nhr : List.Pairwise r c\nhc : c.Sublist l\n⊢ c.Sublist (List.insertionSort r l)","decl":"/--\nIf `c` is a sorted sublist of `l`, then `c` is still a sublist of `insertionSort r l`.\n-/\ntheorem sublist_insertionSort {l c : List α} (hr : c.Pairwise r) (hc : c <+ l) :\n    c <+ insertionSort r l := by\n  induction l generalizing c with\n  | nil         => simp_all only [sublist_nil, insertionSort, Sublist.refl]\n  | cons _ _ ih =>\n    cases hc with\n    | cons  _ h => exact ih hr h |>.trans (sublist_orderedInsert ..)\n    | cons₂ _ h =>\n      obtain ⟨hr, hp⟩ := pairwise_cons.mp hr\n      exact cons_sublist_orderedInsert (ih hp h) hr\n\n"}
{"name":"List.pair_sublist_insertionSort","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : DecidableRel r\na b : α\nl : List α\nhab : r a b\nh : (List.cons a (List.cons b List.nil)).Sublist l\n⊢ (List.cons a (List.cons b List.nil)).Sublist (List.insertionSort r l)","decl":"/--\nAnother statement of stability of insertion sort.\nIf a pair `[a, b]` is a sublist of `l` and `r a b`,\nthen `[a, b]` is still a sublist of `insertionSort r l`.\n-/\ntheorem pair_sublist_insertionSort {a b : α} {l : List α} (hab : r a b) (h : [a, b] <+ l) :\n    [a, b] <+ insertionSort r l :=\n  sublist_insertionSort (pairwise_pair.mpr hab) h\n\n"}
{"name":"List.sublist_insertionSort'","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝³ : DecidableRel r\ninst✝² : IsAntisymm α r\ninst✝¹ : IsTotal α r\ninst✝ : IsTrans α r\nl c : List α\nhs : List.Sorted r c\nhc : c.Subperm l\n⊢ c.Sublist (List.insertionSort r l)","decl":"/--\nA version of `insertionSort_stable` which only assumes `c <+~ l` (instead of `c <+ l`), but\nadditionally requires `IsAntisymm α r`, `IsTotal α r` and `IsTrans α r`.\n-/\ntheorem sublist_insertionSort' {l c : List α} (hs : c.Sorted r) (hc : c <+~ l) :\n    c <+ insertionSort r l := by\n  classical\n  obtain ⟨d, hc, hd⟩ := hc\n  induction l generalizing c d with\n  | nil         => simp_all only [sublist_nil, insertionSort, nil_perm]\n  | cons a _ ih =>\n    cases hd with\n    | cons  _ h => exact ih hs _ hc h |>.trans (sublist_orderedInsert ..)\n    | cons₂ _ h =>\n      specialize ih (hs.erase _) _ (erase_cons_head a ‹List _› ▸ hc.erase a) h\n      have hm := hc.mem_iff.mp <| mem_cons_self ..\n      have he := orderedInsert_erase _ _ hm hs\n      exact he ▸ Sublist.orderedInsert_sublist _ ih (sorted_insertionSort ..)\n\n"}
{"name":"List.pair_sublist_insertionSort'","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝³ : DecidableRel r\ninst✝² : IsAntisymm α r\ninst✝¹ : IsTotal α r\ninst✝ : IsTrans α r\na b : α\nl : List α\nhab : r a b\nh : (List.cons a (List.cons b List.nil)).Subperm l\n⊢ (List.cons a (List.cons b List.nil)).Sublist (List.insertionSort r l)","decl":"/--\nAnother statement of stability of insertion sort.\nIf a pair `[a, b]` is a sublist of a permutation of `l` and `a ≼ b`,\nthen `[a, b]` is still a sublist of `insertionSort r l`.\n-/\ntheorem pair_sublist_insertionSort' {a b : α} {l : List α} (hab : a ≼ b) (h : [a, b] <+~ l) :\n    [a, b] <+ insertionSort r l :=\n  sublist_insertionSort' (pairwise_pair.mpr hab) h\n\n"}
{"name":"List.Sorted.merge","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝² : DecidableRel r\ninst✝¹ : IsTotal α r\ninst✝ : IsTrans α r\nl l' : List α\nh : List.Sorted r l\nh' : List.Sorted r l'\n⊢ List.Sorted r (l.merge l' fun x1 x2 => Decidable.decide (r x1 x2))","decl":"theorem Sorted.merge {l l' : List α} (h : Sorted r l) (h' : Sorted r l') :\n    Sorted r (merge l l' (r · ·)) := by\n  simpa using sorted_merge (le := (r · ·))\n    (fun a b c h₁ h₂ => by simpa using _root_.trans (by simpa using h₁) (by simpa using h₂))\n    (fun a b => by simpa using IsTotal.total a b)\n    l l' (by simpa using h) (by simpa using h')\n\n"}
{"name":"List.sorted_mergeSort'","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\ninst✝² : Preorder α\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : IsTotal α fun x1 x2 => LE.le x1 x2\nl : List α\n⊢ List.Sorted (fun x1 x2 => LE.le x1 x2) (l.mergeSort fun a b => Decidable.decide (LE.le a b))","decl":"/-- Variant of `sorted_mergeSort` using order typeclasses. -/\ntheorem sorted_mergeSort' [Preorder α] [DecidableRel ((· : α) ≤ ·)] [IsTotal α (· ≤ ·)]\n    (l : List α) : Sorted (· ≤ ·) (mergeSort l) := by\n  simpa using sorted_mergeSort (le := fun a b => a ≤ b)\n    (fun a b c h₁ h₂ => by simpa using le_trans (by simpa using h₁) (by simpa using h₂))\n    (fun a b => by simpa using IsTotal.total a b)\n    l\n\n"}
{"name":"List.mergeSort_eq_self","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\ninst✝ : LinearOrder α\nl : List α\na✝ : List.Sorted (fun x1 x2 => LE.le x1 x2) l\n⊢ Eq (l.mergeSort fun a b => Decidable.decide (LE.le a b)) l","decl":"theorem mergeSort_eq_self [LinearOrder α] {l : List α} : Sorted (· ≤ ·) l → mergeSort l = l :=\n  eq_of_perm_of_sorted (mergeSort_perm _ _) (sorted_mergeSort' l)\n\n"}
{"name":"List.mergeSort_eq_insertionSort","module":"Mathlib.Data.List.Sort","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝³ : DecidableRel r\ninst✝² : IsTotal α r\ninst✝¹ : IsTrans α r\ninst✝ : IsAntisymm α r\nl : List α\n⊢ Eq (l.mergeSort fun x1 x2 => Decidable.decide (r x1 x2)) (List.insertionSort r l)","decl":"theorem mergeSort_eq_insertionSort [IsAntisymm α r] (l : List α) :\n    mergeSort l (r · ·) = insertionSort r l :=\n  eq_of_perm_of_sorted ((mergeSort_perm l _).trans (perm_insertionSort r l).symm)\n    (sorted_mergeSort (le := (r · ·))\n      (fun a b c h₁ h₂ => by simpa using _root_.trans (by simpa using h₁) (by simpa using h₂))\n      (fun a b => by simpa using IsTotal.total a b)\n      l)\n    (sorted_insertionSort r l).decide\n\n"}
