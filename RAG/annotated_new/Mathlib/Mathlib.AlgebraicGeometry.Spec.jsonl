{"name":"AlgebraicGeometry.Spec.topObj_forget","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R : CommRingCat\n⊢ Eq ((CategoryTheory.forget TopCat).obj (AlgebraicGeometry.Spec.topObj R)) (PrimeSpectrum ↑R)","decl":"@[simp] theorem Spec.topObj_forget {R} : (forget TopCat).obj (Spec.topObj R) = PrimeSpectrum R :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Spec.topMap_id","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R : CommRingCat\n⊢ Eq (AlgebraicGeometry.Spec.topMap (CategoryTheory.CategoryStruct.id R)) (CategoryTheory.CategoryStruct.id (AlgebraicGeometry.Spec.topObj R))","decl":"@[simp]\ntheorem Spec.topMap_id (R : CommRingCat.{u}) : Spec.topMap (𝟙 R) = 𝟙 (Spec.topObj R) :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Spec.topMap_comp","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R S T : CommRingCat\nf : Quiver.Hom R S\ng : Quiver.Hom S T\n⊢ Eq (AlgebraicGeometry.Spec.topMap (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.topMap g) (AlgebraicGeometry.Spec.topMap f))","decl":"@[simp]\ntheorem Spec.topMap_comp {R S T : CommRingCat.{u}} (f : R ⟶ S) (g : S ⟶ T) :\n    Spec.topMap (f ≫ g) = Spec.topMap g ≫ Spec.topMap f :=\n  rfl\n\n-- Porting note: `simps!` generate some garbage lemmas, so choose manually,\n-- if more is needed, add them here\n"}
{"name":"AlgebraicGeometry.Spec.toTop_obj_α","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R : Opposite CommRingCat\n⊢ Eq (↑(AlgebraicGeometry.Spec.toTop.obj R)) (PrimeSpectrum ↑(Opposite.unop R))","decl":"/-- The spectrum, as a contravariant functor from commutative rings to topological spaces.\n-/\n@[simps!]\ndef Spec.toTop : CommRingCat.{u}ᵒᵖ ⥤ TopCat where\n  obj R := Spec.topObj (unop R)\n  map {_ _} f := Spec.topMap f.unop\n\n"}
{"name":"AlgebraicGeometry.Spec.toTop_obj_str_IsOpen","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R : Opposite CommRingCat\nX : Set (PrimeSpectrum ↑(Opposite.unop R))\n⊢ Eq (TopologicalSpace.IsOpen X) (Exists fun y => Eq (PrimeSpectrum.zeroLocus y) (HasCompl.compl X))","decl":"/-- The spectrum, as a contravariant functor from commutative rings to topological spaces.\n-/\n@[simps!]\ndef Spec.toTop : CommRingCat.{u}ᵒᵖ ⥤ TopCat where\n  obj R := Spec.topObj (unop R)\n  map {_ _} f := Spec.topMap f.unop\n\n"}
{"name":"AlgebraicGeometry.Spec.coe_toTop_map_apply_asIdeal","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"x✝¹ x✝ : Opposite CommRingCat\nf : Quiver.Hom x✝¹ x✝\na✝ : PrimeSpectrum ↑(Opposite.unop x✝¹)\n⊢ Eq (↑((AlgebraicGeometry.Spec.toTop.map f) a✝).asIdeal) (Set.preimage ⇑(CommRingCat.Hom.hom f.unop) ↑a✝.asIdeal)","decl":"/-- The spectrum, as a contravariant functor from commutative rings to topological spaces.\n-/\n@[simps!]\ndef Spec.toTop : CommRingCat.{u}ᵒᵖ ⥤ TopCat where\n  obj R := Spec.topObj (unop R)\n  map {_ _} f := Spec.topMap f.unop\n\n"}
{"name":"AlgebraicGeometry.Spec.sheafedSpaceObj_carrier","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R : CommRingCat\n⊢ Eq (↑(AlgebraicGeometry.Spec.sheafedSpaceObj R).toPresheafedSpace) (AlgebraicGeometry.Spec.topObj R)","decl":"/-- The spectrum of a commutative ring, as a `SheafedSpace`.\n-/\n@[simps]\ndef Spec.sheafedSpaceObj (R : CommRingCat.{u}) : SheafedSpace CommRingCat where\n  carrier := Spec.topObj R\n  presheaf := (structureSheaf R).1\n  IsSheaf := (structureSheaf R).2\n\n"}
{"name":"AlgebraicGeometry.Spec.sheafedSpaceObj_presheaf","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R : CommRingCat\n⊢ Eq (AlgebraicGeometry.Spec.sheafedSpaceObj R).presheaf (AlgebraicGeometry.Spec.structureSheaf ↑R).val","decl":"/-- The spectrum of a commutative ring, as a `SheafedSpace`.\n-/\n@[simps]\ndef Spec.sheafedSpaceObj (R : CommRingCat.{u}) : SheafedSpace CommRingCat where\n  carrier := Spec.topObj R\n  presheaf := (structureSheaf R).1\n  IsSheaf := (structureSheaf R).2\n\n"}
{"name":"AlgebraicGeometry.Spec.sheafedSpaceMap_c_app","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\nU : Opposite (TopologicalSpace.Opens ↑↑(AlgebraicGeometry.Spec.sheafedSpaceObj R).toPresheafedSpace)\n⊢ Eq ((AlgebraicGeometry.Spec.sheafedSpaceMap f).c.app U) (CommRingCat.ofHom (AlgebraicGeometry.StructureSheaf.comap (CommRingCat.Hom.hom f) (Opposite.unop U) ((TopologicalSpace.Opens.map (AlgebraicGeometry.Spec.topMap f)).obj (Opposite.unop U)) ⋯))","decl":"/-- The induced map of a ring homomorphism on the ring spectra, as a morphism of sheafed spaces.\n-/\n@[simps base c_app]\ndef Spec.sheafedSpaceMap {R S : CommRingCat.{u}} (f : R ⟶ S) :\n    Spec.sheafedSpaceObj S ⟶ Spec.sheafedSpaceObj R where\n  base := Spec.topMap f\n  c :=\n    { app := fun U => CommRingCat.ofHom <|\n        comap f.hom (unop U) ((TopologicalSpace.Opens.map (Spec.topMap f)).obj (unop U)) fun _ => id\n      naturality := fun {_ _} _ => by ext; rfl }\n\n"}
{"name":"AlgebraicGeometry.Spec.sheafedSpaceMap_base","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\n⊢ Eq (AlgebraicGeometry.Spec.sheafedSpaceMap f).base (AlgebraicGeometry.Spec.topMap f)","decl":"/-- The induced map of a ring homomorphism on the ring spectra, as a morphism of sheafed spaces.\n-/\n@[simps base c_app]\ndef Spec.sheafedSpaceMap {R S : CommRingCat.{u}} (f : R ⟶ S) :\n    Spec.sheafedSpaceObj S ⟶ Spec.sheafedSpaceObj R where\n  base := Spec.topMap f\n  c :=\n    { app := fun U => CommRingCat.ofHom <|\n        comap f.hom (unop U) ((TopologicalSpace.Opens.map (Spec.topMap f)).obj (unop U)) fun _ => id\n      naturality := fun {_ _} _ => by ext; rfl }\n\n"}
{"name":"AlgebraicGeometry.Spec.sheafedSpaceMap_id","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R : CommRingCat\n⊢ Eq (AlgebraicGeometry.Spec.sheafedSpaceMap (CategoryTheory.CategoryStruct.id R)) (CategoryTheory.CategoryStruct.id (AlgebraicGeometry.Spec.sheafedSpaceObj R))","decl":"@[simp]\ntheorem Spec.sheafedSpaceMap_id {R : CommRingCat.{u}} :\n    Spec.sheafedSpaceMap (𝟙 R) = 𝟙 (Spec.sheafedSpaceObj R) :=\n  AlgebraicGeometry.PresheafedSpace.Hom.ext _ _ (Spec.topMap_id R) <| by\n    ext\n    dsimp\n    rw [comap_id (by simp)]\n    simp\n    rfl\n\n"}
{"name":"AlgebraicGeometry.Spec.sheafedSpaceMap_comp","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R S T : CommRingCat\nf : Quiver.Hom R S\ng : Quiver.Hom S T\n⊢ Eq (AlgebraicGeometry.Spec.sheafedSpaceMap (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.sheafedSpaceMap g) (AlgebraicGeometry.Spec.sheafedSpaceMap f))","decl":"theorem Spec.sheafedSpaceMap_comp {R S T : CommRingCat.{u}} (f : R ⟶ S) (g : S ⟶ T) :\n    Spec.sheafedSpaceMap (f ≫ g) = Spec.sheafedSpaceMap g ≫ Spec.sheafedSpaceMap f :=\n  AlgebraicGeometry.PresheafedSpace.Hom.ext _ _ (Spec.topMap_comp f g) <| by\n    ext\n    -- Porting note: was one liner\n    -- `dsimp, rw category_theory.functor.map_id, rw category.comp_id, erw comap_comp f g, refl`\n    rw [NatTrans.comp_app, sheafedSpaceMap_c_app, whiskerRight_app, eqToHom_refl]\n    erw [(sheafedSpaceObj T).presheaf.map_id, Category.comp_id, comap_comp]\n    rfl\n\n"}
{"name":"AlgebraicGeometry.Spec.toSheafedSpace_obj","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R : Opposite CommRingCat\n⊢ Eq (AlgebraicGeometry.Spec.toSheafedSpace.obj R) (AlgebraicGeometry.Spec.sheafedSpaceObj (Opposite.unop R))","decl":"/-- Spec, as a contravariant functor from commutative rings to sheafed spaces.\n-/\n@[simps]\ndef Spec.toSheafedSpace : CommRingCat.{u}ᵒᵖ ⥤ SheafedSpace CommRingCat where\n  obj R := Spec.sheafedSpaceObj (unop R)\n  map f := Spec.sheafedSpaceMap f.unop\n  map_comp f g := by simp [Spec.sheafedSpaceMap_comp]\n\n"}
{"name":"AlgebraicGeometry.Spec.toSheafedSpace_map","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"X✝ Y✝ : Opposite CommRingCat\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (AlgebraicGeometry.Spec.toSheafedSpace.map f) (AlgebraicGeometry.Spec.sheafedSpaceMap f.unop)","decl":"/-- Spec, as a contravariant functor from commutative rings to sheafed spaces.\n-/\n@[simps]\ndef Spec.toSheafedSpace : CommRingCat.{u}ᵒᵖ ⥤ SheafedSpace CommRingCat where\n  obj R := Spec.sheafedSpaceObj (unop R)\n  map f := Spec.sheafedSpaceMap f.unop\n  map_comp f g := by simp [Spec.sheafedSpaceMap_comp]\n\n"}
{"name":"AlgebraicGeometry.Spec.toPresheafedSpace_obj","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R : Opposite CommRingCat\n⊢ Eq (AlgebraicGeometry.Spec.toPresheafedSpace.obj R) (AlgebraicGeometry.Spec.sheafedSpaceObj (Opposite.unop R)).toPresheafedSpace","decl":"@[simp]\ntheorem Spec.toPresheafedSpace_obj (R : CommRingCat.{u}ᵒᵖ) :\n    Spec.toPresheafedSpace.obj R = (Spec.sheafedSpaceObj (unop R)).toPresheafedSpace :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Spec.toPresheafedSpace_obj_op","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R : CommRingCat\n⊢ Eq (AlgebraicGeometry.Spec.toPresheafedSpace.obj { unop := R }) (AlgebraicGeometry.Spec.sheafedSpaceObj R).toPresheafedSpace","decl":"theorem Spec.toPresheafedSpace_obj_op (R : CommRingCat.{u}) :\n    Spec.toPresheafedSpace.obj (op R) = (Spec.sheafedSpaceObj R).toPresheafedSpace :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Spec.toPresheafedSpace_map","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R S : Opposite CommRingCat\nf : Quiver.Hom R S\n⊢ Eq (AlgebraicGeometry.Spec.toPresheafedSpace.map f) (AlgebraicGeometry.Spec.sheafedSpaceMap f.unop)","decl":"@[simp]\ntheorem Spec.toPresheafedSpace_map (R S : CommRingCat.{u}ᵒᵖ) (f : R ⟶ S) :\n    Spec.toPresheafedSpace.map f = Spec.sheafedSpaceMap f.unop :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Spec.toPresheafedSpace_map_op","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\n⊢ Eq (AlgebraicGeometry.Spec.toPresheafedSpace.map f.op) (AlgebraicGeometry.Spec.sheafedSpaceMap f)","decl":"theorem Spec.toPresheafedSpace_map_op (R S : CommRingCat.{u}) (f : R ⟶ S) :\n    Spec.toPresheafedSpace.map f.op = Spec.sheafedSpaceMap f :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Spec.basicOpen_hom_ext","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"X : AlgebraicGeometry.RingedSpace\nR : CommRingCat\nα β : Quiver.Hom X (AlgebraicGeometry.Spec.sheafedSpaceObj R)\nw : Eq α.base β.base\nh :\n  ∀ (r : ↑R),\n    let U := PrimeSpectrum.basicOpen r;\n    Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toOpen (↑R) U) (α.c.app { unop := U })) (X.presheaf.map (CategoryTheory.eqToHom ⋯))) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toOpen (↑R) U) (β.c.app { unop := U }))\n⊢ Eq α β","decl":"theorem Spec.basicOpen_hom_ext {X : RingedSpace.{u}} {R : CommRingCat.{u}}\n    {α β : X ⟶ Spec.sheafedSpaceObj R} (w : α.base = β.base)\n    (h : ∀ r : R,\n      let U := PrimeSpectrum.basicOpen r\n      (toOpen R U ≫ α.c.app (op U)) ≫ X.presheaf.map (eqToHom (by rw [w])) =\n        toOpen R U ≫ β.c.app (op U)) :\n    α = β := by\n  ext : 1\n  · exact w\n  · apply\n      ((TopCat.Sheaf.pushforward _ β.base).obj X.sheaf).hom_ext _ PrimeSpectrum.isBasis_basic_opens\n    intro r\n    apply (StructureSheaf.to_basicOpen_epi R r).1\n    simpa using h r\n\n-- Porting note: `simps!` generate some garbage lemmas, so choose manually,\n-- if more is needed, add them here\n"}
{"name":"AlgebraicGeometry.Spec.locallyRingedSpaceObj_presheaf","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R : CommRingCat\n⊢ Eq (AlgebraicGeometry.Spec.locallyRingedSpaceObj R).presheaf (AlgebraicGeometry.Spec.structureSheaf ↑R).val","decl":"/-- The spectrum of a commutative ring, as a `LocallyRingedSpace`.\n-/\n@[simps! toSheafedSpace presheaf]\ndef Spec.locallyRingedSpaceObj (R : CommRingCat.{u}) : LocallyRingedSpace :=\n  { Spec.sheafedSpaceObj R with\n    isLocalRing := fun x =>\n      RingEquiv.isLocalRing (A := Localization.AtPrime x.asIdeal)\n        (Iso.commRingCatIsoToRingEquiv <| stalkIso R x).symm }\n\n"}
{"name":"AlgebraicGeometry.Spec.locallyRingedSpaceObj_toSheafedSpace","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R : CommRingCat\n⊢ Eq (AlgebraicGeometry.Spec.locallyRingedSpaceObj R).toSheafedSpace (AlgebraicGeometry.Spec.sheafedSpaceObj R)","decl":"/-- The spectrum of a commutative ring, as a `LocallyRingedSpace`.\n-/\n@[simps! toSheafedSpace presheaf]\ndef Spec.locallyRingedSpaceObj (R : CommRingCat.{u}) : LocallyRingedSpace :=\n  { Spec.sheafedSpaceObj R with\n    isLocalRing := fun x =>\n      RingEquiv.isLocalRing (A := Localization.AtPrime x.asIdeal)\n        (Iso.commRingCatIsoToRingEquiv <| stalkIso R x).symm }\n\n"}
{"name":"AlgebraicGeometry.Spec.locallyRingedSpaceObj_sheaf","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R : CommRingCat\n⊢ Eq (AlgebraicGeometry.Spec.locallyRingedSpaceObj R).sheaf (AlgebraicGeometry.Spec.structureSheaf ↑R)","decl":"lemma Spec.locallyRingedSpaceObj_sheaf (R : CommRingCat.{u}) :\n    (Spec.locallyRingedSpaceObj R).sheaf = structureSheaf R := rfl\n\n"}
{"name":"AlgebraicGeometry.Spec.locallyRingedSpaceObj_sheaf'","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R : Type u\ninst✝ : CommRing R\n⊢ Eq (AlgebraicGeometry.Spec.locallyRingedSpaceObj (CommRingCat.of R)).sheaf (AlgebraicGeometry.Spec.structureSheaf R)","decl":"lemma Spec.locallyRingedSpaceObj_sheaf' (R : Type u) [CommRing R] :\n    (Spec.locallyRingedSpaceObj <| CommRingCat.of R).sheaf = structureSheaf R := rfl\n\n"}
{"name":"AlgebraicGeometry.Spec.locallyRingedSpaceObj_presheaf_map","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R : CommRingCat\nU V : Opposite (TopologicalSpace.Opens ↑↑(AlgebraicGeometry.Spec.locallyRingedSpaceObj R).toPresheafedSpace)\ni : Quiver.Hom U V\n⊢ Eq ((AlgebraicGeometry.Spec.locallyRingedSpaceObj R).presheaf.map i) ((AlgebraicGeometry.Spec.structureSheaf ↑R).val.map i)","decl":"lemma Spec.locallyRingedSpaceObj_presheaf_map (R : CommRingCat.{u}) {U V} (i : U ⟶ V) :\n    (Spec.locallyRingedSpaceObj R).presheaf.map i =\n    (structureSheaf R).1.map i := rfl\n\n"}
{"name":"AlgebraicGeometry.Spec.locallyRingedSpaceObj_presheaf'","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R : Type u\ninst✝ : CommRing R\n⊢ Eq (AlgebraicGeometry.Spec.locallyRingedSpaceObj (CommRingCat.of R)).presheaf (AlgebraicGeometry.Spec.structureSheaf R).val","decl":"lemma Spec.locallyRingedSpaceObj_presheaf' (R : Type u) [CommRing R] :\n    (Spec.locallyRingedSpaceObj <| CommRingCat.of R).presheaf = (structureSheaf R).1 := rfl\n\n"}
{"name":"AlgebraicGeometry.Spec.locallyRingedSpaceObj_presheaf_map'","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R : Type u\ninst✝ : CommRing R\nU V : Opposite (TopologicalSpace.Opens ↑↑(AlgebraicGeometry.Spec.locallyRingedSpaceObj (CommRingCat.of R)).toPresheafedSpace)\ni : Quiver.Hom U V\n⊢ Eq ((AlgebraicGeometry.Spec.locallyRingedSpaceObj (CommRingCat.of R)).presheaf.map i) ((AlgebraicGeometry.Spec.structureSheaf R).val.map i)","decl":"lemma Spec.locallyRingedSpaceObj_presheaf_map' (R : Type u) [CommRing R] {U V} (i : U ⟶ V) :\n    (Spec.locallyRingedSpaceObj <| CommRingCat.of R).presheaf.map i =\n    (structureSheaf R).1.map i := rfl\n\n"}
{"name":"AlgebraicGeometry.stalkMap_toStalk","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\np : PrimeSpectrum ↑S\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toStalk (↑R) ((PrimeSpectrum.comap (CommRingCat.Hom.hom f)) p)) (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap (AlgebraicGeometry.Spec.sheafedSpaceMap f) p)) (CategoryTheory.CategoryStruct.comp f (AlgebraicGeometry.StructureSheaf.toStalk (↑S) p))","decl":"@[elementwise]\ntheorem stalkMap_toStalk {R S : CommRingCat.{u}} (f : R ⟶ S) (p : PrimeSpectrum S) :\n    toStalk R (PrimeSpectrum.comap f.hom p) ≫ (Spec.sheafedSpaceMap f).stalkMap p =\n      f ≫ toStalk S p := by\n  rw [← toOpen_germ S ⊤ p trivial, ← toOpen_germ R ⊤ (PrimeSpectrum.comap f.hom p) trivial,\n    Category.assoc]\n  erw [PresheafedSpace.stalkMap_germ (Spec.sheafedSpaceMap f) ⊤ p trivial]\n  rw [Spec.sheafedSpaceMap_c_app]\n  erw [toOpen_comp_comap_assoc]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.stalkMap_toStalk_apply","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\np : PrimeSpectrum ↑S\nx : CategoryTheory.ToType (CommRingCat.of ↑R)\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap (AlgebraicGeometry.Spec.sheafedSpaceMap f) p)) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.toStalk (↑R) ((PrimeSpectrum.comap (CommRingCat.Hom.hom f)) p))) x)) ((CategoryTheory.CategoryStruct.comp f (AlgebraicGeometry.StructureSheaf.toStalk (↑S) p)) x)","decl":"@[elementwise]\ntheorem stalkMap_toStalk {R S : CommRingCat.{u}} (f : R ⟶ S) (p : PrimeSpectrum S) :\n    toStalk R (PrimeSpectrum.comap f.hom p) ≫ (Spec.sheafedSpaceMap f).stalkMap p =\n      f ≫ toStalk S p := by\n  rw [← toOpen_germ S ⊤ p trivial, ← toOpen_germ R ⊤ (PrimeSpectrum.comap f.hom p) trivial,\n    Category.assoc]\n  erw [PresheafedSpace.stalkMap_germ (Spec.sheafedSpaceMap f) ⊤ p trivial]\n  rw [Spec.sheafedSpaceMap_c_app]\n  erw [toOpen_comp_comap_assoc]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.localRingHom_comp_stalkIso","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\np : PrimeSpectrum ↑S\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.stalkIso (↑R) ((PrimeSpectrum.comap (CommRingCat.Hom.hom f)) p)).hom (CategoryTheory.CategoryStruct.comp (CommRingCat.ofHom (Localization.localRingHom ((PrimeSpectrum.comap (CommRingCat.Hom.hom f)) p).asIdeal p.asIdeal (CommRingCat.Hom.hom f) ⋯)) (AlgebraicGeometry.StructureSheaf.stalkIso (↑S) p).inv)) (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap (AlgebraicGeometry.Spec.sheafedSpaceMap f) p)","decl":"/-- Under the isomorphisms `stalkIso`, the map `stalkMap (Spec.sheafedSpaceMap f) p` corresponds\nto the induced local ring homomorphism `Localization.localRingHom`.\n-/\n@[elementwise]\ntheorem localRingHom_comp_stalkIso {R S : CommRingCat.{u}} (f : R ⟶ S) (p : PrimeSpectrum S) :\n    (stalkIso R (PrimeSpectrum.comap f.hom p)).hom ≫\n      (CommRingCat.ofHom (Localization.localRingHom (PrimeSpectrum.comap f.hom p).asIdeal p.asIdeal\n          f.hom rfl)) ≫\n        (stalkIso S p).inv =\n      (Spec.sheafedSpaceMap f).stalkMap p :=\n  (stalkIso R (PrimeSpectrum.comap f.hom p)).eq_inv_comp.mp <|\n    (stalkIso S p).comp_inv_eq.mpr <| CommRingCat.hom_ext <|\n      Localization.localRingHom_unique _ _ _ (PrimeSpectrum.comap_asIdeal _ _) fun x => by\n        -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644 and https://github.com/leanprover-community/mathlib4/pull/8386\n        rw [stalkIso_hom, stalkIso_inv, CommRingCat.comp_apply, CommRingCat.comp_apply,\n            localizationToStalk_of]\n        erw [stalkMap_toStalk_apply f p x, stalkToFiberRingHom_toStalk]\n        rfl\n\n"}
{"name":"AlgebraicGeometry.localRingHom_comp_stalkIso_apply","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\np : PrimeSpectrum ↑S\nx : CategoryTheory.ToType ((AlgebraicGeometry.Spec.structureSheaf ↑R).presheaf.stalk ((PrimeSpectrum.comap (CommRingCat.Hom.hom f)) p))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.localizationToStalk (↑S) p)) ((Localization.localRingHom (Ideal.comap (CommRingCat.Hom.hom f) p.asIdeal) p.asIdeal (CommRingCat.Hom.hom f) ⋯) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom (↑R) ((PrimeSpectrum.comap (CommRingCat.Hom.hom f)) p))) x))) ((AlgebraicGeometry.PresheafedSpace.Hom.stalkMap (AlgebraicGeometry.Spec.sheafedSpaceMap f) p) x)","decl":"/-- Under the isomorphisms `stalkIso`, the map `stalkMap (Spec.sheafedSpaceMap f) p` corresponds\nto the induced local ring homomorphism `Localization.localRingHom`.\n-/\n@[elementwise]\ntheorem localRingHom_comp_stalkIso {R S : CommRingCat.{u}} (f : R ⟶ S) (p : PrimeSpectrum S) :\n    (stalkIso R (PrimeSpectrum.comap f.hom p)).hom ≫\n      (CommRingCat.ofHom (Localization.localRingHom (PrimeSpectrum.comap f.hom p).asIdeal p.asIdeal\n          f.hom rfl)) ≫\n        (stalkIso S p).inv =\n      (Spec.sheafedSpaceMap f).stalkMap p :=\n  (stalkIso R (PrimeSpectrum.comap f.hom p)).eq_inv_comp.mp <|\n    (stalkIso S p).comp_inv_eq.mpr <| CommRingCat.hom_ext <|\n      Localization.localRingHom_unique _ _ _ (PrimeSpectrum.comap_asIdeal _ _) fun x => by\n        -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644 and https://github.com/leanprover-community/mathlib4/pull/8386\n        rw [stalkIso_hom, stalkIso_inv, CommRingCat.comp_apply, CommRingCat.comp_apply,\n            localizationToStalk_of]\n        erw [stalkMap_toStalk_apply f p x, stalkToFiberRingHom_toStalk]\n        rfl\n\n"}
{"name":"AlgebraicGeometry.localRingHom_comp_stalkIso_apply'","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\np : PrimeSpectrum ↑S\nx : ↑((AlgebraicGeometry.Spec.structureSheaf ↑R).presheaf.stalk ((PrimeSpectrum.comap (CommRingCat.Hom.hom f)) p))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.stalkIso (↑S) p).inv) ((Localization.localRingHom ((PrimeSpectrum.comap (CommRingCat.Hom.hom f)) p).asIdeal p.asIdeal (CommRingCat.Hom.hom f) ⋯) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.stalkIso (↑R) ((PrimeSpectrum.comap (CommRingCat.Hom.hom f)) p)).hom) x))) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap (AlgebraicGeometry.Spec.sheafedSpaceMap f) p)) x)","decl":"/-- Version of `localRingHom_comp_stalkIso_apply` using `CommRingCat.Hom.hom` -/\ntheorem localRingHom_comp_stalkIso_apply' {R S : CommRingCat.{u}} (f : R ⟶ S) (p : PrimeSpectrum S)\n    (x) :\n    (stalkIso S p).inv ((Localization.localRingHom (PrimeSpectrum.comap f.hom p).asIdeal p.asIdeal\n          f.hom rfl) ((stalkIso R (PrimeSpectrum.comap f.hom p)).hom x)) =\n      (Spec.sheafedSpaceMap f).stalkMap p x :=\n  localRingHom_comp_stalkIso_apply _ _ _\n\n"}
{"name":"AlgebraicGeometry.Spec.locallyRingedSpaceMap_toShHom","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\n⊢ Eq (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom (AlgebraicGeometry.Spec.locallyRingedSpaceMap f)) (AlgebraicGeometry.Spec.sheafedSpaceMap f)","decl":"/--\nThe induced map of a ring homomorphism on the prime spectra, as a morphism of locally ringed spaces.\n-/\n@[simps toShHom]\ndef Spec.locallyRingedSpaceMap {R S : CommRingCat.{u}} (f : R ⟶ S) :\n    Spec.locallyRingedSpaceObj S ⟶ Spec.locallyRingedSpaceObj R :=\n  LocallyRingedSpace.Hom.mk (Spec.sheafedSpaceMap f) fun p =>\n    IsLocalHom.mk fun a ha => by\n      -- Here, we are showing that the map on prime spectra induced by `f` is really a morphism of\n      -- *locally* ringed spaces, i.e. that the induced map on the stalks is a local ring\n      -- homomorphism.\n\n      #adaptation_note /-- nightly-2024-04-01\n      It's this `erw` that is blowing up. The implicit arguments differ significantly. -/\n      erw [← localRingHom_comp_stalkIso_apply' f p a] at ha\n\n      have : IsLocalHom (stalkIso (↑S) p).inv.hom := isLocalHom_of_isIso _\n      replace ha := (isUnit_map_iff (stalkIso S p).inv.hom _).mp ha\n      replace ha := IsLocalHom.map_nonunit\n        ((stalkIso R ((PrimeSpectrum.comap f.hom) p)).hom a) ha\n      convert RingHom.isUnit_map (stalkIso R (PrimeSpectrum.comap f.hom p)).inv.hom ha\n      rw [← CommRingCat.comp_apply, Iso.hom_inv_id, CommRingCat.id_apply]\n\n"}
{"name":"AlgebraicGeometry.Spec.locallyRingedSpaceMap_id","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R : CommRingCat\n⊢ Eq (AlgebraicGeometry.Spec.locallyRingedSpaceMap (CategoryTheory.CategoryStruct.id R)) (CategoryTheory.CategoryStruct.id (AlgebraicGeometry.Spec.locallyRingedSpaceObj R))","decl":"@[simp]\ntheorem Spec.locallyRingedSpaceMap_id (R : CommRingCat.{u}) :\n    Spec.locallyRingedSpaceMap (𝟙 R) = 𝟙 (Spec.locallyRingedSpaceObj R) :=\n  LocallyRingedSpace.Hom.ext' <| by\n    rw [Spec.locallyRingedSpaceMap_toShHom, Spec.sheafedSpaceMap_id]; rfl\n\n"}
{"name":"AlgebraicGeometry.Spec.locallyRingedSpaceMap_comp","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R S T : CommRingCat\nf : Quiver.Hom R S\ng : Quiver.Hom S T\n⊢ Eq (AlgebraicGeometry.Spec.locallyRingedSpaceMap (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.locallyRingedSpaceMap g) (AlgebraicGeometry.Spec.locallyRingedSpaceMap f))","decl":"theorem Spec.locallyRingedSpaceMap_comp {R S T : CommRingCat.{u}} (f : R ⟶ S) (g : S ⟶ T) :\n    Spec.locallyRingedSpaceMap (f ≫ g) =\n      Spec.locallyRingedSpaceMap g ≫ Spec.locallyRingedSpaceMap f :=\n  LocallyRingedSpace.Hom.ext' <| by\n    rw [Spec.locallyRingedSpaceMap_toShHom, Spec.sheafedSpaceMap_comp]; rfl\n\n"}
{"name":"AlgebraicGeometry.Spec.toLocallyRingedSpace_obj","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R : Opposite CommRingCat\n⊢ Eq (AlgebraicGeometry.Spec.toLocallyRingedSpace.obj R) (AlgebraicGeometry.Spec.locallyRingedSpaceObj (Opposite.unop R))","decl":"/-- Spec, as a contravariant functor from commutative rings to locally ringed spaces.\n-/\n@[simps]\ndef Spec.toLocallyRingedSpace : CommRingCat.{u}ᵒᵖ ⥤ LocallyRingedSpace where\n  obj R := Spec.locallyRingedSpaceObj (unop R)\n  map f := Spec.locallyRingedSpaceMap f.unop\n  map_id R := by dsimp; rw [Spec.locallyRingedSpaceMap_id]\n  map_comp f g := by dsimp; rw [Spec.locallyRingedSpaceMap_comp]\n\n"}
{"name":"AlgebraicGeometry.Spec.toLocallyRingedSpace_map","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"X✝ Y✝ : Opposite CommRingCat\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (AlgebraicGeometry.Spec.toLocallyRingedSpace.map f) (AlgebraicGeometry.Spec.locallyRingedSpaceMap f.unop)","decl":"/-- Spec, as a contravariant functor from commutative rings to locally ringed spaces.\n-/\n@[simps]\ndef Spec.toLocallyRingedSpace : CommRingCat.{u}ᵒᵖ ⥤ LocallyRingedSpace where\n  obj R := Spec.locallyRingedSpaceObj (unop R)\n  map f := Spec.locallyRingedSpaceMap f.unop\n  map_id R := by dsimp; rw [Spec.locallyRingedSpaceMap_id]\n  map_comp f g := by dsimp; rw [Spec.locallyRingedSpaceMap_comp]\n\n"}
{"name":"AlgebraicGeometry.isIso_toSpecΓ","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R : CommRingCat\n⊢ CategoryTheory.IsIso (AlgebraicGeometry.toSpecΓ R)","decl":"instance isIso_toSpecΓ (R : CommRingCat.{u}) : IsIso (toSpecΓ R) := by\n  cases R; apply StructureSheaf.isIso_to_global\n\n"}
{"name":"AlgebraicGeometry.Spec_Γ_naturality_assoc","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\nZ : CommRingCat\nh : Quiver.Hom (AlgebraicGeometry.LocallyRingedSpace.Γ.obj { unop := AlgebraicGeometry.Spec.toLocallyRingedSpace.obj { unop := S } }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.toSpecΓ S) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.toSpecΓ R) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.LocallyRingedSpace.Γ.map (AlgebraicGeometry.Spec.toLocallyRingedSpace.map f.op).op) h))","decl":"@[reassoc]\ntheorem Spec_Γ_naturality {R S : CommRingCat.{u}} (f : R ⟶ S) :\n    f ≫ toSpecΓ S = toSpecΓ R ≫ Γ.map (Spec.toLocallyRingedSpace.map f.op).op := by\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` failed to pick up one of the three lemmas\n  ext : 2\n  refine Subtype.ext <| funext fun x' => ?_; symm\n  apply Localization.localRingHom_to_map\n\n"}
{"name":"AlgebraicGeometry.Spec_Γ_naturality","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (AlgebraicGeometry.toSpecΓ S)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.toSpecΓ R) (AlgebraicGeometry.LocallyRingedSpace.Γ.map (AlgebraicGeometry.Spec.toLocallyRingedSpace.map f.op).op))","decl":"@[reassoc]\ntheorem Spec_Γ_naturality {R S : CommRingCat.{u}} (f : R ⟶ S) :\n    f ≫ toSpecΓ S = toSpecΓ R ≫ Γ.map (Spec.toLocallyRingedSpace.map f.op).op := by\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` failed to pick up one of the three lemmas\n  ext : 2\n  refine Subtype.ext <| funext fun x' => ?_; symm\n  apply Localization.localRingHom_to_map\n\n"}
{"name":"AlgebraicGeometry.LocallyRingedSpace.SpecΓIdentity_inv_app","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"X : CommRingCat\n⊢ Eq (AlgebraicGeometry.LocallyRingedSpace.SpecΓIdentity.inv.app X) (AlgebraicGeometry.toSpecΓ X)","decl":"/-- The counit (`SpecΓIdentity.inv.op`) of the adjunction `Γ ⊣ Spec` is an isomorphism. -/\n@[simps! hom_app inv_app]\ndef LocallyRingedSpace.SpecΓIdentity : Spec.toLocallyRingedSpace.rightOp ⋙ Γ ≅ 𝟭 _ :=\n  Iso.symm <| NatIso.ofComponents.{u,u,u+1,u+1} (fun R =>\n    -- Porting note: In Lean3, this `IsIso` is synthesized automatically\n    letI : IsIso (toSpecΓ R) := StructureSheaf.isIso_to_global _\n    asIso (toSpecΓ R)) fun {X Y} f => by convert Spec_Γ_naturality (R := X) (S := Y) f\n\n"}
{"name":"AlgebraicGeometry.LocallyRingedSpace.SpecΓIdentity_hom_app","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"X : CommRingCat\n⊢ Eq (AlgebraicGeometry.LocallyRingedSpace.SpecΓIdentity.hom.app X) (CategoryTheory.inv (AlgebraicGeometry.toSpecΓ X))","decl":"/-- The counit (`SpecΓIdentity.inv.op`) of the adjunction `Γ ⊣ Spec` is an isomorphism. -/\n@[simps! hom_app inv_app]\ndef LocallyRingedSpace.SpecΓIdentity : Spec.toLocallyRingedSpace.rightOp ⋙ Γ ≅ 𝟭 _ :=\n  Iso.symm <| NatIso.ofComponents.{u,u,u+1,u+1} (fun R =>\n    -- Porting note: In Lean3, this `IsIso` is synthesized automatically\n    letI : IsIso (toSpecΓ R) := StructureSheaf.isIso_to_global _\n    asIso (toSpecΓ R)) fun {X Y} f => by convert Spec_Γ_naturality (R := X) (S := Y) f\n\n"}
{"name":"AlgebraicGeometry.Spec_map_localization_isIso","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R : CommRingCat\nM : Submonoid ↑R\nx : PrimeSpectrum (Localization M)\n⊢ CategoryTheory.IsIso (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap (AlgebraicGeometry.Spec.toPresheafedSpace.map (CommRingCat.ofHom (algebraMap (↑R) (Localization M))).op) x)","decl":"/-- The stalk map of `Spec M⁻¹R ⟶ Spec R` is an iso for each `p : Spec M⁻¹R`. -/\ntheorem Spec_map_localization_isIso (R : CommRingCat.{u}) (M : Submonoid R)\n    (x : PrimeSpectrum (Localization M)) :\n    IsIso\n      ((Spec.toPresheafedSpace.map\n        (CommRingCat.ofHom (algebraMap R (Localization M))).op).stalkMap x) := by\n  erw [← localRingHom_comp_stalkIso]\n  -- Porting note: replaced `apply (config := { instances := false })`.\n  -- See https://github.com/leanprover/lean4/issues/2273\n  refine IsIso.comp_isIso' inferInstance (IsIso.comp_isIso' ?_ inferInstance)\n  /- I do not know why this is defeq to the goal, but I'm happy to accept that it is. -/\n  show\n    IsIso (IsLocalization.localizationLocalizationAtPrimeIsoLocalization M\n      x.asIdeal).toRingEquiv.toCommRingCatIso.hom\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.toPushforwardStalk_comp_assoc","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\np : PrimeSpectrum ↑R\nZ : CommRingCat\nh : Quiver.Hom (((TopCat.Presheaf.pushforward CommRingCat (AlgebraicGeometry.Spec.topMap f)).obj (AlgebraicGeometry.Spec.structureSheaf ↑S).val).stalk p) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toPushforwardStalk f p) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toStalk (↑R) p) (CategoryTheory.CategoryStruct.comp ((TopCat.Presheaf.stalkFunctor CommRingCat p).map (AlgebraicGeometry.Spec.sheafedSpaceMap f).c) h))","decl":"@[reassoc]\ntheorem toPushforwardStalk_comp :\n    f ≫ StructureSheaf.toPushforwardStalk f p =\n      StructureSheaf.toStalk R p ≫\n        (TopCat.Presheaf.stalkFunctor _ _).map (Spec.sheafedSpaceMap f).c := by\n  rw [StructureSheaf.toStalk, Category.assoc, TopCat.Presheaf.stalkFunctor_map_germ]\n  exact Spec_Γ_naturality_assoc f _\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.toPushforwardStalk_comp","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\np : PrimeSpectrum ↑R\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (AlgebraicGeometry.StructureSheaf.toPushforwardStalk f p)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toStalk (↑R) p) ((TopCat.Presheaf.stalkFunctor CommRingCat p).map (AlgebraicGeometry.Spec.sheafedSpaceMap f).c))","decl":"@[reassoc]\ntheorem toPushforwardStalk_comp :\n    f ≫ StructureSheaf.toPushforwardStalk f p =\n      StructureSheaf.toStalk R p ≫\n        (TopCat.Presheaf.stalkFunctor _ _).map (Spec.sheafedSpaceMap f).c := by\n  rw [StructureSheaf.toStalk, Category.assoc, TopCat.Presheaf.stalkFunctor_map_germ]\n  exact Spec_Γ_naturality_assoc f _\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.algebraMap_pushforward_stalk","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\np : PrimeSpectrum ↑R\n⊢ Eq (algebraMap ↑R ↑(((TopCat.Presheaf.pushforward CommRingCat (AlgebraicGeometry.Spec.topMap f)).obj (AlgebraicGeometry.Spec.structureSheaf ↑S).val).stalk p)) (CommRingCat.Hom.hom (CategoryTheory.CategoryStruct.comp f (AlgebraicGeometry.StructureSheaf.toPushforwardStalk f p)))","decl":"theorem algebraMap_pushforward_stalk :\n    algebraMap R ((Spec.topMap f _* (structureSheaf S).1).stalk p) =\n      (f ≫ StructureSheaf.toPushforwardStalk f p).hom :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.toPushforwardStalkAlgHom_apply","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R S : CommRingCat\np : PrimeSpectrum ↑R\ninst✝ : Algebra ↑R ↑S\na✝ : ↑(CommRingCat.of ↑S)\n⊢ Eq ((AlgebraicGeometry.StructureSheaf.toPushforwardStalkAlgHom R S p) a✝) ((((TopCat.Presheaf.pushforward CommRingCat (AlgebraicGeometry.Spec.topMap (CommRingCat.ofHom (algebraMap ↑R ↑S)))).obj (AlgebraicGeometry.Spec.structureSheaf ↑S).val).germ Top.top p trivial).hom' ((AlgebraicGeometry.StructureSheaf.toOpen (↑S) Top.top).hom' a✝))","decl":"/--\nThis is the `AlgHom` version of `toPushforwardStalk`, which is the map `S ⟶ (f∗ 𝒪ₛ)ₚ` for some\nalgebra `R ⟶ S` and some `p : Spec R`.\n-/\n@[simps!]\ndef toPushforwardStalkAlgHom :\n    S →ₐ[R] (Spec.topMap (CommRingCat.ofHom (algebraMap R S)) _* (structureSheaf S).1).stalk p :=\n  { (StructureSheaf.toPushforwardStalk (CommRingCat.ofHom (algebraMap R S)) p).hom with\n    commutes' := fun _ => rfl }\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.isLocalizedModule_toPushforwardStalkAlgHom_aux","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R S : CommRingCat\np : PrimeSpectrum ↑R\ninst✝ : Algebra ↑R ↑S\ny : ↑(((TopCat.Presheaf.pushforward CommRingCat (AlgebraicGeometry.Spec.topMap (CommRingCat.ofHom (algebraMap ↑R ↑S)))).obj (AlgebraicGeometry.Spec.structureSheaf ↑S).val).stalk p)\n⊢ Exists fun x => Eq (HSMul.hSMul x.2 y) ((AlgebraicGeometry.StructureSheaf.toPushforwardStalkAlgHom R S p) x.1)","decl":"theorem isLocalizedModule_toPushforwardStalkAlgHom_aux (y) :\n    ∃ x : S × p.asIdeal.primeCompl, x.2 • y = toPushforwardStalkAlgHom R S p x.1 := by\n  obtain ⟨U, hp, s, e⟩ := TopCat.Presheaf.germ_exist\n    -- Porting note: originally the first variable does not need to be explicit\n    (Spec.topMap (CommRingCat.ofHom (algebraMap ↑R ↑S)) _* (structureSheaf S).val) _ y\n  obtain ⟨_, ⟨r, rfl⟩, hpr : p ∈ PrimeSpectrum.basicOpen r, hrU : PrimeSpectrum.basicOpen r ≤ U⟩ :=\n    PrimeSpectrum.isTopologicalBasis_basic_opens.exists_subset_of_mem_open (show p ∈ U from hp) U.2\n  change PrimeSpectrum.basicOpen r ≤ U at hrU\n  replace e :=\n    ((Spec.topMap (CommRingCat.ofHom (algebraMap R S)) _* (structureSheaf S).1).germ_res_apply\n      (homOfLE hrU) p hpr _).trans e\n  set s' := (Spec.topMap (CommRingCat.ofHom (algebraMap R S)) _* (structureSheaf S).1).map\n      (homOfLE hrU).op s with h\n  replace e : ((Spec.topMap (CommRingCat.ofHom (algebraMap R S)) _* (structureSheaf S).val).germ _\n      p hpr) s' = y := by\n    rw [h]; exact e\n  clear_value s'; clear! U\n  obtain ⟨⟨s, ⟨_, n, rfl⟩⟩, hsn⟩ :=\n    @IsLocalization.surj _ _ _ _ _ _\n      (StructureSheaf.IsLocalization.to_basicOpen S <| algebraMap R S r) s'\n  refine ⟨⟨s, ⟨r, hpr⟩ ^ n⟩, ?_⟩\n  rw [Submonoid.smul_def, Algebra.smul_def, algebraMap_pushforward_stalk, toPushforwardStalk,\n    CommRingCat.comp_apply, CommRingCat.comp_apply]\n  iterate 2\n    erw [← (Spec.topMap (CommRingCat.ofHom (algebraMap R S)) _* (structureSheaf S).1).germ_res_apply\n      (homOfLE le_top) p hpr]\n  rw [← e]\n  -- Porting note: without this `change`, Lean doesn't know how to rewrite `map_mul`\n  let f := TopCat.Presheaf.germ (Spec.topMap (CommRingCat.ofHom (algebraMap R S)) _*\n      (structureSheaf S).val) _ p hpr\n  change f _ * f _ = f _\n  rw [← map_mul, mul_comm]\n  dsimp only [Subtype.coe_mk] at hsn\n  rw [← map_pow (algebraMap R S)] at hsn\n  congr 1\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.isLocalizedModule_toPushforwardStalkAlgHom","module":"Mathlib.AlgebraicGeometry.Spec","initialProofState":"R S : CommRingCat\np : PrimeSpectrum ↑R\ninst✝ : Algebra ↑R ↑S\n⊢ IsLocalizedModule p.asIdeal.primeCompl (AlgebraicGeometry.StructureSheaf.toPushforwardStalkAlgHom R S p).toLinearMap","decl":"instance isLocalizedModule_toPushforwardStalkAlgHom :\n    IsLocalizedModule p.asIdeal.primeCompl (toPushforwardStalkAlgHom R S p).toLinearMap := by\n  apply IsLocalizedModule.mkOfAlgebra\n  · intro x hx; rw [algebraMap_pushforward_stalk, toPushforwardStalk_comp]\n    change IsUnit ((TopCat.Presheaf.stalkFunctor CommRingCat p).map\n      (Spec.sheafedSpaceMap (CommRingCat.ofHom (algebraMap ↑R ↑S))).c _)\n    exact (IsLocalization.map_units ((structureSheaf R).presheaf.stalk p) ⟨x, hx⟩).map _\n  · apply isLocalizedModule_toPushforwardStalkAlgHom_aux\n  · intro x hx\n    rw [toPushforwardStalkAlgHom_apply,\n      ← (toPushforwardStalk (CommRingCat.ofHom (algebraMap ↑R ↑S)) p).hom.map_zero,\n      toPushforwardStalk] at hx\n    -- Porting note: this `change` is manually rewriting `comp_apply`\n    change _ = (TopCat.Presheaf.germ (Spec.topMap (CommRingCat.ofHom (algebraMap ↑R ↑S)) _*\n      (structureSheaf ↑S).val) ⊤ p trivial (toOpen S ⊤ 0)) at hx\n    rw [map_zero] at hx\n    change (forget CommRingCat).map _ _ = (forget _).map _ _ at hx\n    obtain ⟨U, hpU, i₁, i₂, e⟩ := TopCat.Presheaf.germ_eq _ _ _ _ _ _ hx\n    obtain ⟨_, ⟨r, rfl⟩, hpr, hrU⟩ :=\n      PrimeSpectrum.isTopologicalBasis_basic_opens.exists_subset_of_mem_open (show p ∈ U.1 from hpU)\n        U.2\n    change PrimeSpectrum.basicOpen r ≤ U at hrU\n    apply_fun (Spec.topMap (CommRingCat.ofHom (algebraMap R S)) _* (structureSheaf S).1).map\n        (homOfLE hrU).op at e\n    simp only [Functor.op_map, map_zero, ← CategoryTheory.comp_apply, toOpen_res] at e\n    have : toOpen S (PrimeSpectrum.basicOpen <| algebraMap R S r) x = 0 := by\n      refine Eq.trans ?_ e; rfl\n    have :=\n      (@IsLocalization.mk'_one _ _ _ _ _ _\n            (StructureSheaf.IsLocalization.to_basicOpen S <| algebraMap R S r) x).trans\n        this\n    obtain ⟨⟨_, n, rfl⟩, e⟩ := (IsLocalization.mk'_eq_zero_iff _ _).mp this\n    refine ⟨⟨r, hpr⟩ ^ n, ?_⟩\n    rw [Submonoid.smul_def, Algebra.smul_def]\n    -- Porting note: manually rewrite `Submonoid.coe_pow`\n    change (algebraMap R S) (r ^ n) * x = 0\n    rw [map_pow]\n    exact e\n\n"}
