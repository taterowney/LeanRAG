{"name":"CategoryTheory.GrothendieckTopology.PreservesSheafification.le","module":"Mathlib.CategoryTheory.Sites.PreservesSheafification","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u_1\nB : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} A\ninst✝ : CategoryTheory.Category.{u_4, u_2} B\nF : CategoryTheory.Functor A B\nself : J.PreservesSheafification F\n⊢ LE.le J.W (J.W.inverseImage ((CategoryTheory.whiskeringRight (Opposite C) A B).obj F))","decl":"/-- A functor `F : A ⥤ B` preserves the sheafification for the Grothendieck\ntopology `J` on a category `C` if whenever a morphism of presheaves `f : P₁ ⟶ P₂`\nin `Cᵒᵖ ⥤ A` is such that becomes an iso after sheafification, then it is\nalso the case of `whiskerRight f F : P₁ ⋙ F ⟶ P₂ ⋙ F`. -/\nclass PreservesSheafification : Prop where\n  le : J.W ≤ J.W.inverseImage ((whiskeringRight Cᵒᵖ A B).obj F)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.W_of_preservesSheafification","module":"Mathlib.CategoryTheory.Sites.PreservesSheafification","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u_1\nB : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} A\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} B\nF : CategoryTheory.Functor A B\ninst✝ : J.PreservesSheafification F\nP₁ P₂ : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom P₁ P₂\nhf : J.W f\n⊢ J.W (CategoryTheory.whiskerRight f F)","decl":"lemma W_of_preservesSheafification\n    {P₁ P₂ : Cᵒᵖ ⥤ A} (f : P₁ ⟶ P₂) (hf : J.W f) :\n    J.W (whiskerRight f F) :=\n  PreservesSheafification.le _ hf\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.W_isInvertedBy_whiskeringRight_presheafToSheaf","module":"Mathlib.CategoryTheory.Sites.PreservesSheafification","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u_1\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} A\ninst✝² : CategoryTheory.Category.{u_4, u_2} B\nF : CategoryTheory.Functor A B\ninst✝¹ : J.PreservesSheafification F\ninst✝ : CategoryTheory.HasWeakSheafify J B\n⊢ J.W.IsInvertedBy (((CategoryTheory.whiskeringRight (Opposite C) A B).obj F).comp (CategoryTheory.presheafToSheaf J B))","decl":"lemma W_isInvertedBy_whiskeringRight_presheafToSheaf :\n    J.W.IsInvertedBy (((whiskeringRight Cᵒᵖ A B).obj F) ⋙ presheafToSheaf J B) := by\n  intro P₁ P₂ f hf\n  dsimp\n  rw [← W_iff]\n  exact J.W_of_preservesSheafification F _ hf\n\n"}
{"name":"CategoryTheory.toPresheafToSheafCompComposeAndSheafify_app","module":"Mathlib.CategoryTheory.Sites.PreservesSheafification","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u_1\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} A\ninst✝² : CategoryTheory.Category.{u_4, u_2} B\nF : CategoryTheory.Functor A B\ninst✝¹ : CategoryTheory.HasWeakSheafify J B\ninst✝ : CategoryTheory.HasWeakSheafify J A\nX : CategoryTheory.Functor (Opposite C) A\n⊢ Eq ((CategoryTheory.toPresheafToSheafCompComposeAndSheafify J F).app X) ((CategoryTheory.presheafToSheaf J B).map (CategoryTheory.whiskerRight (CategoryTheory.toSheafify J X) F))","decl":"/-- The canonical natural transformation from\n`(whiskeringRight Cᵒᵖ A B).obj F ⋙ presheafToSheaf J B` to\n`presheafToSheaf J A ⋙ Sheaf.composeAndSheafify J F`. -/\n@[simps!]\nnoncomputable def toPresheafToSheafCompComposeAndSheafify :\n    (whiskeringRight Cᵒᵖ A B).obj F ⋙ presheafToSheaf J B ⟶\n      presheafToSheaf J A ⋙ Sheaf.composeAndSheafify J F :=\n  whiskerRight (sheafificationAdjunction J A).unit\n    ((whiskeringRight _ _ _).obj F ⋙ presheafToSheaf J B)\n\n"}
{"name":"CategoryTheory.instIsIsoFunctorOppositeSheafToPresheafToSheafCompComposeAndSheafify","module":"Mathlib.CategoryTheory.Sites.PreservesSheafification","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u_1\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} A\ninst✝² : CategoryTheory.Category.{u_4, u_2} B\nF : CategoryTheory.Functor A B\ninst✝¹ : CategoryTheory.HasWeakSheafify J B\ninst✝ : CategoryTheory.HasWeakSheafify J A\n⊢ CategoryTheory.IsIso (CategoryTheory.toPresheafToSheafCompComposeAndSheafify J F)","decl":"instance : IsIso (toPresheafToSheafCompComposeAndSheafify J F) := by\n  have : J.PreservesSheafification F := inferInstance\n  rw [NatTrans.isIso_iff_isIso_app]\n  intro X\n  dsimp\n  simpa only [← J.W_iff] using J.W_of_preservesSheafification F _ (J.W_toSheafify X)\n\n"}
{"name":"CategoryTheory.presheafToSheafCompComposeAndSheafifyIso_inv_app","module":"Mathlib.CategoryTheory.Sites.PreservesSheafification","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u_1\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} A\ninst✝² : CategoryTheory.Category.{u_4, u_2} B\nF : CategoryTheory.Functor A B\ninst✝¹ : CategoryTheory.HasWeakSheafify J B\ninst✝ : CategoryTheory.HasWeakSheafify J A\nX : CategoryTheory.Functor (Opposite C) A\n⊢ Eq ((CategoryTheory.presheafToSheafCompComposeAndSheafifyIso J F).inv.app X) ((CategoryTheory.presheafToSheaf J B).map (CategoryTheory.whiskerRight (CategoryTheory.toSheafify J X) F))","decl":"/-- The canonical isomorphism between `presheafToSheaf J A ⋙ Sheaf.composeAndSheafify J F`\nand `(whiskeringRight Cᵒᵖ A B).obj F ⋙ presheafToSheaf J B` when `F : A ⥤ B`\npreserves sheafification. -/\n@[simps! inv_app]\nnoncomputable def presheafToSheafCompComposeAndSheafifyIso :\n    presheafToSheaf J A ⋙ Sheaf.composeAndSheafify J F ≅\n      (whiskeringRight Cᵒᵖ A B).obj F ⋙ presheafToSheaf J B :=\n  (asIso (toPresheafToSheafCompComposeAndSheafify J F)).symm\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.preservesSheafification_iff_of_adjunctions","module":"Mathlib.CategoryTheory.Sites.PreservesSheafification","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u_1\nB : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} A\ninst✝ : CategoryTheory.Category.{u_3, u_2} B\nF : CategoryTheory.Functor A B\nG₁ : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) A) (CategoryTheory.Sheaf J A)\nadj₁ : CategoryTheory.Adjunction G₁ (CategoryTheory.sheafToPresheaf J A)\nG₂ : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) B) (CategoryTheory.Sheaf J B)\nadj₂ : CategoryTheory.Adjunction G₂ (CategoryTheory.sheafToPresheaf J B)\n⊢ Iff (J.PreservesSheafification F) (∀ (P : CategoryTheory.Functor (Opposite C) A), CategoryTheory.IsIso (G₂.map (CategoryTheory.whiskerRight (adj₁.unit.app P) F)))","decl":"lemma GrothendieckTopology.preservesSheafification_iff_of_adjunctions\n    (adj₂ : G₂ ⊣ sheafToPresheaf J B) :\n    J.PreservesSheafification F ↔ ∀ (P : Cᵒᵖ ⥤ A),\n      IsIso (G₂.map (whiskerRight (adj₁.unit.app P) F)) := by\n  simp only [← J.W_iff_isIso_map_of_adjunction adj₂]\n  constructor\n  · intro _ P\n    apply W_of_preservesSheafification\n    rw [J.W_iff_isIso_map_of_adjunction adj₁]\n    infer_instance\n  · intro h\n    constructor\n    intro P₁ P₂ f hf\n    rw [J.W_iff_isIso_map_of_adjunction adj₁] at hf\n    dsimp [MorphismProperty.inverseImage]\n    rw [← (W _).postcomp_iff _ _ (h P₂), ← whiskerRight_comp]\n    erw [adj₁.unit.naturality f]\n    dsimp only [Functor.comp_map]\n    rw [whiskerRight_comp, (W _).precomp_iff _ _ (h P₁)]\n    apply Localization.LeftBousfield.W_of_isIso\n\n"}
{"name":"CategoryTheory.sheafComposeNatTrans_fac","module":"Mathlib.CategoryTheory.Sites.PreservesSheafification","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u_1\nB : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} A\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} B\nF : CategoryTheory.Functor A B\nG₁ : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) A) (CategoryTheory.Sheaf J A)\nadj₁ : CategoryTheory.Adjunction G₁ (CategoryTheory.sheafToPresheaf J A)\nG₂ : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) B) (CategoryTheory.Sheaf J B)\nadj₂ : CategoryTheory.Adjunction G₂ (CategoryTheory.sheafToPresheaf J B)\ninst✝ : J.HasSheafCompose F\nP : CategoryTheory.Functor (Opposite C) A\n⊢ Eq (CategoryTheory.CategoryStruct.comp (adj₂.unit.app (P.comp F)) ((CategoryTheory.sheafToPresheaf J B).map ((CategoryTheory.sheafComposeNatTrans J F adj₁ adj₂).app P))) (CategoryTheory.whiskerRight (adj₁.unit.app P) F)","decl":"lemma sheafComposeNatTrans_fac (P : Cᵒᵖ ⥤ A) :\n    adj₂.unit.app (P ⋙ F) ≫\n      (sheafToPresheaf J B).map ((sheafComposeNatTrans J F adj₁ adj₂).app P) =\n        whiskerRight (adj₁.unit.app P) F  := by\n  simp [sheafComposeNatTrans, -sheafToPresheaf_obj, -sheafToPresheaf_map,\n    Adjunction.homEquiv_counit]\n\n"}
{"name":"CategoryTheory.sheafComposeNatTrans_app_uniq","module":"Mathlib.CategoryTheory.Sites.PreservesSheafification","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u_1\nB : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} A\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} B\nF : CategoryTheory.Functor A B\nG₁ : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) A) (CategoryTheory.Sheaf J A)\nadj₁ : CategoryTheory.Adjunction G₁ (CategoryTheory.sheafToPresheaf J A)\nG₂ : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) B) (CategoryTheory.Sheaf J B)\nadj₂ : CategoryTheory.Adjunction G₂ (CategoryTheory.sheafToPresheaf J B)\ninst✝ : J.HasSheafCompose F\nP : CategoryTheory.Functor (Opposite C) A\nα : Quiver.Hom (G₂.obj (P.comp F)) ((CategoryTheory.sheafCompose J F).obj (G₁.obj P))\nhα : Eq (CategoryTheory.CategoryStruct.comp (adj₂.unit.app (P.comp F)) ((CategoryTheory.sheafToPresheaf J B).map α)) (CategoryTheory.whiskerRight (adj₁.unit.app P) F)\n⊢ Eq α ((CategoryTheory.sheafComposeNatTrans J F adj₁ adj₂).app P)","decl":"lemma sheafComposeNatTrans_app_uniq (P : Cᵒᵖ ⥤ A)\n    (α : G₂.obj (P ⋙ F) ⟶ (sheafCompose J F).obj (G₁.obj P))\n    (hα : adj₂.unit.app (P ⋙ F) ≫ (sheafToPresheaf J B).map α =\n        whiskerRight (adj₁.unit.app P) F) :\n    α = (sheafComposeNatTrans J F adj₁ adj₂).app P := by\n  apply (adj₂.homEquiv _ _).injective\n  dsimp [sheafComposeNatTrans]\n  erw [Equiv.apply_symm_apply]\n  rw [← hα]\n  apply adj₂.homEquiv_unit\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.preservesSheafification_iff_of_adjunctions_of_hasSheafCompose","module":"Mathlib.CategoryTheory.Sites.PreservesSheafification","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u_1\nB : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} A\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} B\nF : CategoryTheory.Functor A B\nG₁ : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) A) (CategoryTheory.Sheaf J A)\nadj₁ : CategoryTheory.Adjunction G₁ (CategoryTheory.sheafToPresheaf J A)\nG₂ : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) B) (CategoryTheory.Sheaf J B)\nadj₂ : CategoryTheory.Adjunction G₂ (CategoryTheory.sheafToPresheaf J B)\ninst✝ : J.HasSheafCompose F\n⊢ Iff (J.PreservesSheafification F) (CategoryTheory.IsIso (CategoryTheory.sheafComposeNatTrans J F adj₁ adj₂))","decl":"lemma GrothendieckTopology.preservesSheafification_iff_of_adjunctions_of_hasSheafCompose :\n    J.PreservesSheafification F ↔ IsIso (sheafComposeNatTrans J F adj₁ adj₂) := by\n  rw [J.preservesSheafification_iff_of_adjunctions F adj₁ adj₂,\n    NatTrans.isIso_iff_isIso_app]\n  apply forall_congr'\n  intro P\n  rw [← J.W_iff_isIso_map_of_adjunction adj₂, ← J.W_sheafToPreheaf_map_iff_isIso,\n    ← sheafComposeNatTrans_fac J F adj₁ adj₂,\n    (W _).precomp_iff _ _ (J.W_adj_unit_app adj₂ (P ⋙ F))]\n\n"}
{"name":"CategoryTheory.instIsIsoFunctorOppositeSheafSheafComposeNatTrans","module":"Mathlib.CategoryTheory.Sites.PreservesSheafification","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u_1\nB : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} A\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} B\nF : CategoryTheory.Functor A B\nG₁ : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) A) (CategoryTheory.Sheaf J A)\nadj₁ : CategoryTheory.Adjunction G₁ (CategoryTheory.sheafToPresheaf J A)\nG₂ : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) B) (CategoryTheory.Sheaf J B)\nadj₂ : CategoryTheory.Adjunction G₂ (CategoryTheory.sheafToPresheaf J B)\ninst✝ : J.HasSheafCompose F\n⊢ CategoryTheory.IsIso (CategoryTheory.sheafComposeNatTrans J F adj₁ adj₂)","decl":"instance : IsIso (sheafComposeNatTrans J F adj₁ adj₂) := by\n  rw [← J.preservesSheafification_iff_of_adjunctions_of_hasSheafCompose]\n  infer_instance\n\n"}
{"name":"CategoryTheory.sheafComposeIso_hom_fac_assoc","module":"Mathlib.CategoryTheory.Sites.PreservesSheafification","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u_1\nB : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} A\ninst✝⁴ : CategoryTheory.Category.{u_3, u_2} B\nF : CategoryTheory.Functor A B\ninst✝³ : CategoryTheory.HasWeakSheafify J A\ninst✝² : CategoryTheory.HasWeakSheafify J B\ninst✝¹ : J.HasSheafCompose F\ninst✝ : J.PreservesSheafification F\nP : CategoryTheory.Functor (Opposite C) A\nZ : CategoryTheory.Functor (Opposite C) B\nh : Quiver.Hom ((CategoryTheory.sheafify J P).comp F) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.toSheafify J (P.comp F)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.sheafifyComposeIso J F P).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.toSheafify J P) F) h)","decl":"@[reassoc (attr := simp)]\nlemma sheafComposeIso_hom_fac :\n    toSheafify J (P ⋙ F) ≫ (sheafifyComposeIso J F P).hom =\n      whiskerRight (toSheafify J P) F :=\n  sheafComposeNatTrans_fac J F (sheafificationAdjunction J A) (sheafificationAdjunction J B) P\n\n"}
{"name":"CategoryTheory.sheafComposeIso_hom_fac","module":"Mathlib.CategoryTheory.Sites.PreservesSheafification","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u_1\nB : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} A\ninst✝⁴ : CategoryTheory.Category.{u_3, u_2} B\nF : CategoryTheory.Functor A B\ninst✝³ : CategoryTheory.HasWeakSheafify J A\ninst✝² : CategoryTheory.HasWeakSheafify J B\ninst✝¹ : J.HasSheafCompose F\ninst✝ : J.PreservesSheafification F\nP : CategoryTheory.Functor (Opposite C) A\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.toSheafify J (P.comp F)) (CategoryTheory.sheafifyComposeIso J F P).hom) (CategoryTheory.whiskerRight (CategoryTheory.toSheafify J P) F)","decl":"@[reassoc (attr := simp)]\nlemma sheafComposeIso_hom_fac :\n    toSheafify J (P ⋙ F) ≫ (sheafifyComposeIso J F P).hom =\n      whiskerRight (toSheafify J P) F :=\n  sheafComposeNatTrans_fac J F (sheafificationAdjunction J A) (sheafificationAdjunction J B) P\n\n"}
{"name":"CategoryTheory.sheafComposeIso_inv_fac_assoc","module":"Mathlib.CategoryTheory.Sites.PreservesSheafification","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u_1\nB : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} A\ninst✝⁴ : CategoryTheory.Category.{u_3, u_2} B\nF : CategoryTheory.Functor A B\ninst✝³ : CategoryTheory.HasWeakSheafify J A\ninst✝² : CategoryTheory.HasWeakSheafify J B\ninst✝¹ : J.HasSheafCompose F\ninst✝ : J.PreservesSheafification F\nP : CategoryTheory.Functor (Opposite C) A\nZ : CategoryTheory.Functor (Opposite C) B\nh : Quiver.Hom (CategoryTheory.sheafify J (P.comp F)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.toSheafify J P) F) (CategoryTheory.CategoryStruct.comp (CategoryTheory.sheafifyComposeIso J F P).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.toSheafify J (P.comp F)) h)","decl":"@[reassoc (attr := simp)]\nlemma sheafComposeIso_inv_fac :\n    whiskerRight (toSheafify J P) F ≫ (sheafifyComposeIso J F P).inv =\n      toSheafify J (P ⋙ F) := by\n  rw [← sheafComposeIso_hom_fac, assoc, Iso.hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.sheafComposeIso_inv_fac","module":"Mathlib.CategoryTheory.Sites.PreservesSheafification","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u_1\nB : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} A\ninst✝⁴ : CategoryTheory.Category.{u_3, u_2} B\nF : CategoryTheory.Functor A B\ninst✝³ : CategoryTheory.HasWeakSheafify J A\ninst✝² : CategoryTheory.HasWeakSheafify J B\ninst✝¹ : J.HasSheafCompose F\ninst✝ : J.PreservesSheafification F\nP : CategoryTheory.Functor (Opposite C) A\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.toSheafify J P) F) (CategoryTheory.sheafifyComposeIso J F P).inv) (CategoryTheory.toSheafify J (P.comp F))","decl":"@[reassoc (attr := simp)]\nlemma sheafComposeIso_inv_fac :\n    whiskerRight (toSheafify J P) F ≫ (sheafifyComposeIso J F P).inv =\n      toSheafify J (P ⋙ F) := by\n  rw [← sheafComposeIso_hom_fac, assoc, Iso.hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.sheafToPresheaf_map_sheafComposeNatTrans_eq_sheafifyCompIso_inv","module":"Mathlib.CategoryTheory.Sites.PreservesSheafification","initialProofState":"C : Type u\ninst✝¹⁶ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_3\nE : Type u_4\ninst✝¹⁵ : CategoryTheory.Category.{max v u, u_3} D\ninst✝¹⁴ : CategoryTheory.Category.{max v u, u_4} E\nF : CategoryTheory.Functor D E\ninst✝¹³ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D\ninst✝¹² : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E\ninst✝¹¹ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹⁰ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) E\ninst✝⁹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) F\ninst✝⁸ : ∀ (X : C) (W : J.Cover X) (P : CategoryTheory.Functor (Opposite C) D), CategoryTheory.Limits.PreservesLimit (W.index P).multicospan F\ninst✝⁷ : CategoryTheory.HasForget D\ninst✝⁶ : CategoryTheory.HasForget E\ninst✝⁵ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst✝⁴ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget E)\ninst✝³ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝² : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget E)\ninst✝¹ : (CategoryTheory.forget D).ReflectsIsomorphisms\ninst✝ : (CategoryTheory.forget E).ReflectsIsomorphisms\nP : CategoryTheory.Functor (Opposite C) D\n⊢ Eq ((CategoryTheory.sheafToPresheaf J E).map ((CategoryTheory.sheafComposeNatTrans J F (CategoryTheory.plusPlusAdjunction J D) (CategoryTheory.plusPlusAdjunction J E)).app P)) (J.sheafifyCompIso F P).inv","decl":"lemma sheafToPresheaf_map_sheafComposeNatTrans_eq_sheafifyCompIso_inv (P : Cᵒᵖ ⥤ D) :\n    (sheafToPresheaf J E).map\n      ((sheafComposeNatTrans J F (plusPlusAdjunction J D) (plusPlusAdjunction J E)).app P) =\n      (sheafifyCompIso J F P).inv := by\n  suffices (sheafComposeNatTrans J F (plusPlusAdjunction J D) (plusPlusAdjunction J E)).app P =\n    ⟨(sheafifyCompIso J F P).inv⟩ by\n    rw [this]\n    rfl\n  apply ((plusPlusAdjunction J E).homEquiv _ _).injective\n  convert sheafComposeNatTrans_fac J F (plusPlusAdjunction J D) (plusPlusAdjunction J E) P\n  dsimp [plusPlusAdjunction]\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.instIsIsoSheafAppFunctorOppositeSheafComposeNatTransPlusPlusAdjunction","module":"Mathlib.CategoryTheory.Sites.PreservesSheafification","initialProofState":"C : Type u\ninst✝¹⁵ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_3\nE : Type u_4\ninst✝¹⁴ : CategoryTheory.Category.{max v u, u_3} D\ninst✝¹³ : CategoryTheory.Category.{max v u, u_4} E\nF : CategoryTheory.Functor D E\ninst✝¹² : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D\ninst✝¹¹ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E\ninst✝¹⁰ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝⁹ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) E\ninst✝⁸ : ∀ (X : C) (W : J.Cover X) (P : CategoryTheory.Functor (Opposite C) D), CategoryTheory.Limits.PreservesLimit (W.index P).multicospan F\ninst✝⁷ : CategoryTheory.HasForget D\ninst✝⁶ : CategoryTheory.HasForget E\ninst✝⁵ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst✝⁴ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget E)\ninst✝³ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝² : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget E)\ninst✝¹ : (CategoryTheory.forget D).ReflectsIsomorphisms\ninst✝ : (CategoryTheory.forget E).ReflectsIsomorphisms\nP : CategoryTheory.Functor (Opposite C) D\n⊢ CategoryTheory.IsIso ((CategoryTheory.sheafComposeNatTrans J F (CategoryTheory.plusPlusAdjunction J D) (CategoryTheory.plusPlusAdjunction J E)).app P)","decl":"instance (P : Cᵒᵖ ⥤ D) :\n    IsIso ((sheafComposeNatTrans J F (plusPlusAdjunction J D) (plusPlusAdjunction J E)).app P) := by\n  rw [← isIso_iff_of_reflects_iso _ (sheafToPresheaf J E),\n    sheafToPresheaf_map_sheafComposeNatTrans_eq_sheafifyCompIso_inv]\n  infer_instance\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.instIsIsoFunctorOppositeSheafSheafComposeNatTransPlusPlusAdjunction","module":"Mathlib.CategoryTheory.Sites.PreservesSheafification","initialProofState":"C : Type u\ninst✝¹⁵ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_3\nE : Type u_4\ninst✝¹⁴ : CategoryTheory.Category.{max v u, u_3} D\ninst✝¹³ : CategoryTheory.Category.{max v u, u_4} E\nF : CategoryTheory.Functor D E\ninst✝¹² : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D\ninst✝¹¹ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E\ninst✝¹⁰ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝⁹ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) E\ninst✝⁸ : ∀ (X : C) (W : J.Cover X) (P : CategoryTheory.Functor (Opposite C) D), CategoryTheory.Limits.PreservesLimit (W.index P).multicospan F\ninst✝⁷ : CategoryTheory.HasForget D\ninst✝⁶ : CategoryTheory.HasForget E\ninst✝⁵ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst✝⁴ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget E)\ninst✝³ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝² : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget E)\ninst✝¹ : (CategoryTheory.forget D).ReflectsIsomorphisms\ninst✝ : (CategoryTheory.forget E).ReflectsIsomorphisms\n⊢ CategoryTheory.IsIso (CategoryTheory.sheafComposeNatTrans J F (CategoryTheory.plusPlusAdjunction J D) (CategoryTheory.plusPlusAdjunction J E))","decl":"instance : IsIso (sheafComposeNatTrans J F (plusPlusAdjunction J D) (plusPlusAdjunction J E)) :=\n  NatIso.isIso_of_isIso_app _\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.instPreservesSheafification","module":"Mathlib.CategoryTheory.Sites.PreservesSheafification","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_3\nE : Type u_4\ninst✝¹ : CategoryTheory.Category.{max v u, u_3} D\ninst✝ : CategoryTheory.Category.{max v u, u_4} E\nF : CategoryTheory.Functor D E\n⊢ J.PreservesSheafification F","decl":"instance : PreservesSheafification J F := by\n  rw [preservesSheafification_iff_of_adjunctions_of_hasSheafCompose _ _\n    (plusPlusAdjunction J D) (plusPlusAdjunction J E)]\n  infer_instance\n\n"}
