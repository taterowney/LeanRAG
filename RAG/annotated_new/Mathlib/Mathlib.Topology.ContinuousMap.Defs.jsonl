{"name":"ContinuousMap.mk.sizeOf_spec","module":"Mathlib.Topology.ContinuousMap.Defs","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : SizeOf X\ninst✝ : SizeOf Y\ntoFun : X → Y\ncontinuous_toFun : autoParam (Continuous toFun) _auto✝\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, continuous_toFun := continuous_toFun }) (HAdd.hAdd 1 (SizeOf.sizeOf continuous_toFun))","decl":"/-- The type of continuous maps from `X` to `Y`.\n\nWhen possible, instead of parametrizing results over `(f : C(X, Y))`,\nyou should parametrize over `{F : Type*} [ContinuousMapClass F X Y] (f : F)`.\n\nWhen you extend this structure, make sure to extend `ContinuousMapClass`. -/\nstructure ContinuousMap (X Y : Type*) [TopologicalSpace X] [TopologicalSpace Y] where\n  /-- The function `X → Y` -/\n  protected toFun : X → Y\n  /-- Proposition that `toFun` is continuous -/\n  protected continuous_toFun : Continuous toFun := by continuity\n\n"}
{"name":"ContinuousMap.continuous_toFun","module":"Mathlib.Topology.ContinuousMap.Defs","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nself : ContinuousMap X Y\n⊢ Continuous self.toFun","decl":"/-- The type of continuous maps from `X` to `Y`.\n\nWhen possible, instead of parametrizing results over `(f : C(X, Y))`,\nyou should parametrize over `{F : Type*} [ContinuousMapClass F X Y] (f : F)`.\n\nWhen you extend this structure, make sure to extend `ContinuousMapClass`. -/\nstructure ContinuousMap (X Y : Type*) [TopologicalSpace X] [TopologicalSpace Y] where\n  /-- The function `X → Y` -/\n  protected toFun : X → Y\n  /-- Proposition that `toFun` is continuous -/\n  protected continuous_toFun : Continuous toFun := by continuity\n\n"}
{"name":"ContinuousMap.mk.injEq","module":"Mathlib.Topology.ContinuousMap.Defs","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ntoFun✝ : X → Y\ncontinuous_toFun✝ : autoParam (Continuous toFun✝) _auto✝\ntoFun : X → Y\ncontinuous_toFun : autoParam (Continuous toFun) _auto✝\n⊢ Eq (Eq { toFun := toFun✝, continuous_toFun := continuous_toFun✝ } { toFun := toFun, continuous_toFun := continuous_toFun }) (Eq toFun✝ toFun)","decl":"/-- The type of continuous maps from `X` to `Y`.\n\nWhen possible, instead of parametrizing results over `(f : C(X, Y))`,\nyou should parametrize over `{F : Type*} [ContinuousMapClass F X Y] (f : F)`.\n\nWhen you extend this structure, make sure to extend `ContinuousMapClass`. -/\nstructure ContinuousMap (X Y : Type*) [TopologicalSpace X] [TopologicalSpace Y] where\n  /-- The function `X → Y` -/\n  protected toFun : X → Y\n  /-- Proposition that `toFun` is continuous -/\n  protected continuous_toFun : Continuous toFun := by continuity\n\n"}
{"name":"ContinuousMap.mk.inj","module":"Mathlib.Topology.ContinuousMap.Defs","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ntoFun✝ : X → Y\ncontinuous_toFun✝ : autoParam (Continuous toFun✝) _auto✝\ntoFun : X → Y\ncontinuous_toFun : autoParam (Continuous toFun) _auto✝\nx✝ : Eq { toFun := toFun✝, continuous_toFun := continuous_toFun✝ } { toFun := toFun, continuous_toFun := continuous_toFun }\n⊢ Eq toFun✝ toFun","decl":"/-- The type of continuous maps from `X` to `Y`.\n\nWhen possible, instead of parametrizing results over `(f : C(X, Y))`,\nyou should parametrize over `{F : Type*} [ContinuousMapClass F X Y] (f : F)`.\n\nWhen you extend this structure, make sure to extend `ContinuousMapClass`. -/\nstructure ContinuousMap (X Y : Type*) [TopologicalSpace X] [TopologicalSpace Y] where\n  /-- The function `X → Y` -/\n  protected toFun : X → Y\n  /-- Proposition that `toFun` is continuous -/\n  protected continuous_toFun : Continuous toFun := by continuity\n\n"}
{"name":"ContinuousMapClass.map_continuous","module":"Mathlib.Topology.ContinuousMap.Defs","initialProofState":"F : Type u_1\nX : outParam (Type u_2)\nY : outParam (Type u_3)\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : FunLike F X Y\nself : ContinuousMapClass F X Y\nf : F\n⊢ Continuous ⇑f","decl":"/-- `ContinuousMapClass F X Y` states that `F` is a type of continuous maps.\n\nYou should extend this class when you extend `ContinuousMap`. -/\nclass ContinuousMapClass (F : Type*) (X Y : outParam Type*)\n    [TopologicalSpace X] [TopologicalSpace Y] [FunLike F X Y] : Prop where\n  /-- Continuity -/\n  map_continuous (f : F) : Continuous f\n\n"}
{"name":"ContinuousMap.instContinuousMapClass","module":"Mathlib.Topology.ContinuousMap.Defs","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ ContinuousMapClass (ContinuousMap X Y) X Y","decl":"instance instContinuousMapClass : ContinuousMapClass C(X, Y) X Y where\n  map_continuous := ContinuousMap.continuous_toFun\n\n"}
{"name":"ContinuousMap.toFun_eq_coe","module":"Mathlib.Topology.ContinuousMap.Defs","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\n⊢ Eq f.toFun ⇑f","decl":"@[simp]\ntheorem toFun_eq_coe {f : C(X, Y)} : f.toFun = (f : X → Y) :=\n  rfl\n\n"}
{"name":"ContinuousMap.instCanLiftForallCoeContinuous","module":"Mathlib.Topology.ContinuousMap.Defs","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ CanLift (X → Y) (ContinuousMap X Y) DFunLike.coe Continuous","decl":"instance : CanLift (X → Y) C(X, Y) DFunLike.coe Continuous := ⟨fun f hf ↦ ⟨⟨f, hf⟩, rfl⟩⟩\n\n"}
{"name":"ContinuousMap.coe_coe","module":"Mathlib.Topology.ContinuousMap.Defs","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\nF : Type u_3\ninst✝¹ : FunLike F X Y\ninst✝ : ContinuousMapClass F X Y\nf : F\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp] -- Porting note: removed `norm_cast` attribute\nprotected theorem coe_coe {F : Type*} [FunLike F X Y] [ContinuousMapClass F X Y] (f : F) :\n    ⇑(f : C(X, Y)) = f :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_apply","module":"Mathlib.Topology.ContinuousMap.Defs","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\nF : Type u_3\ninst✝¹ : FunLike F X Y\ninst✝ : ContinuousMapClass F X Y\nf : F\nx : X\n⊢ Eq (↑f x) (f x)","decl":"protected theorem coe_apply {F : Type*} [FunLike F X Y] [ContinuousMapClass F X Y] (f : F) (x : X) :\n    (f : C(X, Y)) x = f x :=\n  rfl\n\n"}
{"name":"ContinuousMap.ext_iff","module":"Mathlib.Topology.ContinuousMap.Defs","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf g : ContinuousMap X Y\n⊢ Iff (Eq f g) (∀ (a : X), Eq (f a) (g a))","decl":"@[ext]\ntheorem ext {f g : C(X, Y)} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"ContinuousMap.ext","module":"Mathlib.Topology.ContinuousMap.Defs","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf g : ContinuousMap X Y\nh : ∀ (a : X), Eq (f a) (g a)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : C(X, Y)} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"ContinuousMap.coe_copy","module":"Mathlib.Topology.ContinuousMap.Defs","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\nf' : X → Y\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[simp]\ntheorem coe_copy (f : C(X, Y)) (f' : X → Y) (h : f' = f) : ⇑(f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"ContinuousMap.copy_eq","module":"Mathlib.Topology.ContinuousMap.Defs","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\nf' : X → Y\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"theorem copy_eq (f : C(X, Y)) (f' : X → Y) (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"ContinuousMap.continuous","module":"Mathlib.Topology.ContinuousMap.Defs","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\n⊢ Continuous ⇑f","decl":"/-- Deprecated. Use `map_continuous` instead. -/\nprotected theorem continuous (f : C(X, Y)) : Continuous f :=\n  f.continuous_toFun\n\n"}
{"name":"ContinuousMap.continuous_set_coe","module":"Mathlib.Topology.ContinuousMap.Defs","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set (ContinuousMap X Y)\nf : ↑s\n⊢ Continuous ⇑↑f","decl":"@[deprecated map_continuous (since := \"2024-09-29\")]\ntheorem continuous_set_coe (s : Set C(X, Y)) (f : s) : Continuous (f : X → Y) :=\n  map_continuous _\n\n"}
{"name":"ContinuousMap.congr_fun","module":"Mathlib.Topology.ContinuousMap.Defs","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf g : ContinuousMap X Y\nH : Eq f g\nx : X\n⊢ Eq (f x) (g x)","decl":"/-- Deprecated. Use `DFunLike.congr_fun` instead. -/\nprotected theorem congr_fun {f g : C(X, Y)} (H : f = g) (x : X) : f x = g x :=\n  H ▸ rfl\n\n"}
{"name":"ContinuousMap.congr_arg","module":"Mathlib.Topology.ContinuousMap.Defs","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\nx y : X\nh : Eq x y\n⊢ Eq (f x) (f y)","decl":"/-- Deprecated. Use `DFunLike.congr_arg` instead. -/\nprotected theorem congr_arg (f : C(X, Y)) {x y : X} (h : x = y) : f x = f y :=\n  h ▸ rfl\n\n"}
{"name":"ContinuousMap.coe_injective","module":"Mathlib.Topology.ContinuousMap.Defs","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Function.Injective DFunLike.coe","decl":"theorem coe_injective : Function.Injective (DFunLike.coe : C(X, Y) → (X → Y)) :=\n  DFunLike.coe_injective\n\n"}
{"name":"ContinuousMap.coe_mk","module":"Mathlib.Topology.ContinuousMap.Defs","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nh : Continuous f\n⊢ Eq (⇑{ toFun := f, continuous_toFun := h }) f","decl":"@[simp]\ntheorem coe_mk (f : X → Y) (h : Continuous f) : ⇑(⟨f, h⟩ : C(X, Y)) = f :=\n  rfl\n\n"}
