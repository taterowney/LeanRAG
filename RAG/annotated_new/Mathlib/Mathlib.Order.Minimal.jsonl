{"name":"minimal_toDual","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\ninst✝ : LE α\n⊢ Iff (Minimal (fun x => P (OrderDual.ofDual x)) (OrderDual.toDual x)) (Maximal P x)","decl":"@[simp] theorem minimal_toDual : Minimal (fun x ↦ P (ofDual x)) (toDual x) ↔ Maximal P x :=\n  Iff.rfl\n\n"}
{"name":"Minimal.of_dual","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\ninst✝ : LE α\na✝ : Minimal (fun x => P (OrderDual.ofDual x)) (OrderDual.toDual x)\n⊢ Maximal P x","decl":"alias ⟨Minimal.of_dual, Minimal.dual⟩ := minimal_toDual\n\n"}
{"name":"Minimal.dual","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\ninst✝ : LE α\na✝ : Maximal P x\n⊢ Minimal (fun x => P (OrderDual.ofDual x)) (OrderDual.toDual x)","decl":"alias ⟨Minimal.of_dual, Minimal.dual⟩ := minimal_toDual\n\n"}
{"name":"maximal_toDual","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\ninst✝ : LE α\n⊢ Iff (Maximal (fun x => P (OrderDual.ofDual x)) (OrderDual.toDual x)) (Minimal P x)","decl":"@[simp] theorem maximal_toDual : Maximal (fun x ↦ P (ofDual x)) (toDual x) ↔ Minimal P x :=\n  Iff.rfl\n\n"}
{"name":"Maximal.of_dual","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\ninst✝ : LE α\na✝ : Maximal (fun x => P (OrderDual.ofDual x)) (OrderDual.toDual x)\n⊢ Minimal P x","decl":"alias ⟨Maximal.of_dual, Maximal.dual⟩ := maximal_toDual\n\n"}
{"name":"Maximal.dual","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\ninst✝ : LE α\na✝ : Minimal P x\n⊢ Maximal (fun x => P (OrderDual.ofDual x)) (OrderDual.toDual x)","decl":"alias ⟨Maximal.of_dual, Maximal.dual⟩ := maximal_toDual\n\n"}
{"name":"minimal_false","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝ : LE α\n⊢ Not (Minimal (fun x => False) x)","decl":"@[simp] theorem minimal_false : ¬ Minimal (fun _ ↦ False) x := by\n  simp [Minimal]\n\n"}
{"name":"maximal_false","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝ : LE α\n⊢ Not (Maximal (fun x => False) x)","decl":"@[simp] theorem maximal_false : ¬ Maximal (fun _ ↦ False) x := by\n  simp [Maximal]\n\n"}
{"name":"minimal_true","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝ : LE α\n⊢ Iff (Minimal (fun x => True) x) (IsMin x)","decl":"@[simp] theorem minimal_true : Minimal (fun _ ↦ True) x ↔ IsMin x := by\n  simp [IsMin, Minimal]\n\n"}
{"name":"maximal_true","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝ : LE α\n⊢ Iff (Maximal (fun x => True) x) (IsMax x)","decl":"@[simp] theorem maximal_true : Maximal (fun _ ↦ True) x ↔ IsMax x :=\n  minimal_true (α := αᵒᵈ)\n\n"}
{"name":"minimal_subtype","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP Q : α → Prop\ninst✝ : LE α\nx : Subtype Q\n⊢ Iff (Minimal (fun x => P ↑x) x) (Minimal (Min.min P Q) ↑x)","decl":"@[simp] theorem minimal_subtype {x : Subtype Q} :\n    Minimal (fun x ↦ P x.1) x ↔ Minimal (P ⊓ Q) x := by\n  obtain ⟨x, hx⟩ := x\n  simp only [Minimal, Subtype.forall, Subtype.mk_le_mk, Pi.inf_apply, inf_Prop_eq]\n  tauto\n\n"}
{"name":"maximal_subtype","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP Q : α → Prop\ninst✝ : LE α\nx : Subtype Q\n⊢ Iff (Maximal (fun x => P ↑x) x) (Maximal (Min.min P Q) ↑x)","decl":"@[simp] theorem maximal_subtype {x : Subtype Q} :\n    Maximal (fun x ↦ P x.1) x ↔ Maximal (P ⊓ Q) x :=\n  minimal_subtype (α := αᵒᵈ)\n\n"}
{"name":"maximal_true_subtype","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\ninst✝ : LE α\nx : Subtype P\n⊢ Iff (Maximal (fun x => True) x) (Maximal P ↑x)","decl":"theorem maximal_true_subtype {x : Subtype P} : Maximal (fun _ ↦ True) x ↔ Maximal P x := by\n  obtain ⟨x, hx⟩ := x\n  simp [Maximal, hx]\n\n"}
{"name":"minimal_true_subtype","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\ninst✝ : LE α\nx : Subtype P\n⊢ Iff (Minimal (fun x => True) x) (Minimal P ↑x)","decl":"theorem minimal_true_subtype {x : Subtype P} : Minimal (fun _ ↦ True) x ↔ Minimal P x := by\n  obtain ⟨x, hx⟩ := x\n  simp [Minimal, hx]\n\n"}
{"name":"minimal_minimal","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\ninst✝ : LE α\n⊢ Iff (Minimal (Minimal P) x) (Minimal P x)","decl":"@[simp] theorem minimal_minimal : Minimal (Minimal P) x ↔ Minimal P x :=\n  ⟨fun h ↦ h.prop, fun h ↦ ⟨h, fun _ hy hyx ↦ h.le_of_le hy.prop hyx⟩⟩\n\n"}
{"name":"maximal_maximal","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\ninst✝ : LE α\n⊢ Iff (Maximal (Maximal P) x) (Maximal P x)","decl":"@[simp] theorem maximal_maximal : Maximal (Maximal P) x ↔ Maximal P x :=\n  minimal_minimal (α := αᵒᵈ)\n\n"}
{"name":"minimal_iff_isMin","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\ninst✝ : LE α\nhP : ∀ ⦃x y : α⦄, P y → LE.le x y → P x\n⊢ Iff (Minimal P x) (And (P x) (IsMin x))","decl":"/-- If `P` is down-closed, then minimal elements satisfying `P` are exactly the globally minimal\nelements satisfying `P`. -/\ntheorem minimal_iff_isMin (hP : ∀ ⦃x y⦄, P y → x ≤ y → P x) : Minimal P x ↔ P x ∧ IsMin x :=\n  ⟨fun h ↦ ⟨h.prop, fun _ h' ↦ h.le_of_le (hP h.prop h') h'⟩, fun h ↦ ⟨h.1, fun _ _  h' ↦ h.2 h'⟩⟩\n\n"}
{"name":"maximal_iff_isMax","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\ninst✝ : LE α\nhP : ∀ ⦃x y : α⦄, P y → LE.le y x → P x\n⊢ Iff (Maximal P x) (And (P x) (IsMax x))","decl":"/-- If `P` is up-closed, then maximal elements satisfying `P` are exactly the globally maximal\nelements satisfying `P`. -/\ntheorem maximal_iff_isMax (hP : ∀ ⦃x y⦄, P y → y ≤ x → P x) : Maximal P x ↔ P x ∧ IsMax x :=\n  ⟨fun h ↦ ⟨h.prop, fun _ h' ↦ h.le_of_ge (hP h.prop h') h'⟩, fun h ↦ ⟨h.1, fun _ _  h' ↦ h.2 h'⟩⟩\n\n"}
{"name":"Minimal.mono","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP Q : α → Prop\nx : α\ninst✝ : LE α\nh : Minimal P x\nhle : LE.le Q P\nhQ : Q x\n⊢ Minimal Q x","decl":"theorem Minimal.mono (h : Minimal P x) (hle : Q ≤ P) (hQ : Q x) : Minimal Q x :=\n  ⟨hQ, fun y hQy ↦ h.le_of_le (hle y hQy)⟩\n\n"}
{"name":"Maximal.mono","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP Q : α → Prop\nx : α\ninst✝ : LE α\nh : Maximal P x\nhle : LE.le Q P\nhQ : Q x\n⊢ Maximal Q x","decl":"theorem Maximal.mono (h : Maximal P x) (hle : Q ≤ P) (hQ : Q x) : Maximal Q x :=\n  ⟨hQ, fun y hQy ↦ h.le_of_ge (hle y hQy)⟩\n\n"}
{"name":"Minimal.and_right","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP Q : α → Prop\nx : α\ninst✝ : LE α\nh : Minimal P x\nhQ : Q x\n⊢ Minimal (fun x => And (P x) (Q x)) x","decl":"theorem Minimal.and_right (h : Minimal P x) (hQ : Q x) : Minimal (fun x ↦ P x ∧ Q x) x :=\n  h.mono (fun _ ↦ And.left) ⟨h.prop, hQ⟩\n\n"}
{"name":"Minimal.and_left","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP Q : α → Prop\nx : α\ninst✝ : LE α\nh : Minimal P x\nhQ : Q x\n⊢ Minimal (fun x => And (Q x) (P x)) x","decl":"theorem Minimal.and_left (h : Minimal P x) (hQ : Q x) : Minimal (fun x ↦ (Q x ∧ P x)) x :=\n  h.mono (fun _ ↦ And.right) ⟨hQ, h.prop⟩\n\n"}
{"name":"Maximal.and_right","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP Q : α → Prop\nx : α\ninst✝ : LE α\nh : Maximal P x\nhQ : Q x\n⊢ Maximal (fun x => And (P x) (Q x)) x","decl":"theorem Maximal.and_right (h : Maximal P x) (hQ : Q x) : Maximal (fun x ↦ (P x ∧ Q x)) x :=\n  h.mono (fun _ ↦ And.left) ⟨h.prop, hQ⟩\n\n"}
{"name":"Maximal.and_left","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP Q : α → Prop\nx : α\ninst✝ : LE α\nh : Maximal P x\nhQ : Q x\n⊢ Maximal (fun x => And (Q x) (P x)) x","decl":"theorem Maximal.and_left (h : Maximal P x) (hQ : Q x) : Maximal (fun x ↦ (Q x ∧ P x)) x :=\n  h.mono (fun _ ↦ And.right) ⟨hQ, h.prop⟩\n\n"}
{"name":"minimal_eq_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx y : α\ninst✝ : LE α\n⊢ Iff (Minimal (fun x => Eq x y) x) (Eq x y)","decl":"@[simp] theorem minimal_eq_iff : Minimal (· = y) x ↔ x = y := by\n  simp (config := {contextual := true}) [Minimal]\n\n"}
{"name":"maximal_eq_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx y : α\ninst✝ : LE α\n⊢ Iff (Maximal (fun x => Eq x y) x) (Eq x y)","decl":"@[simp] theorem maximal_eq_iff : Maximal (· = y) x ↔ x = y := by\n  simp (config := {contextual := true}) [Maximal]\n\n"}
{"name":"not_minimal_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\ninst✝ : LE α\nhx : P x\n⊢ Iff (Not (Minimal P x)) (Exists fun y => And (P y) (And (LE.le y x) (Not (LE.le x y))))","decl":"theorem not_minimal_iff (hx : P x) : ¬ Minimal P x ↔ ∃ y, P y ∧ y ≤ x ∧ ¬ (x ≤ y) := by\n  simp [Minimal, hx]\n\n"}
{"name":"not_maximal_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\ninst✝ : LE α\nhx : P x\n⊢ Iff (Not (Maximal P x)) (Exists fun y => And (P y) (And (LE.le x y) (Not (LE.le y x))))","decl":"theorem not_maximal_iff (hx : P x) : ¬ Maximal P x ↔ ∃ y, P y ∧ x ≤ y ∧ ¬ (y ≤ x) :=\n  not_minimal_iff (α := αᵒᵈ) hx\n\n"}
{"name":"Minimal.or","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP Q : α → Prop\nx : α\ninst✝ : LE α\nh : Minimal (fun x => Or (P x) (Q x)) x\n⊢ Or (Minimal P x) (Minimal Q x)","decl":"theorem Minimal.or (h : Minimal (fun x ↦ P x ∨ Q x) x) : Minimal P x ∨ Minimal Q x := by\n  obtain ⟨h | h, hmin⟩ := h\n  · exact .inl ⟨h, fun y hy hyx ↦ hmin (Or.inl hy) hyx⟩\n  exact .inr ⟨h, fun y hy hyx ↦ hmin (Or.inr hy) hyx⟩\n\n"}
{"name":"Maximal.or","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP Q : α → Prop\nx : α\ninst✝ : LE α\nh : Maximal (fun x => Or (P x) (Q x)) x\n⊢ Or (Maximal P x) (Maximal Q x)","decl":"theorem Maximal.or (h : Maximal (fun x ↦ P x ∨ Q x) x) : Maximal P x ∨ Maximal Q x :=\n  Minimal.or (α := αᵒᵈ) h\n\n"}
{"name":"minimal_and_iff_right_of_imp","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP Q : α → Prop\nx : α\ninst✝ : LE α\nhPQ : ∀ ⦃x : α⦄, P x → Q x\n⊢ Iff (Minimal (fun x => And (P x) (Q x)) x) (And (Minimal P x) (Q x))","decl":"theorem minimal_and_iff_right_of_imp (hPQ : ∀ ⦃x⦄, P x → Q x) :\n    Minimal (fun x ↦ P x ∧ Q x) x ↔ (Minimal P x) ∧ Q x := by\n  simp_rw [and_iff_left_of_imp (fun x ↦ hPQ x), iff_self_and]\n  exact fun h ↦ hPQ h.prop\n\n"}
{"name":"minimal_and_iff_left_of_imp","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP Q : α → Prop\nx : α\ninst✝ : LE α\nhPQ : ∀ ⦃x : α⦄, P x → Q x\n⊢ Iff (Minimal (fun x => And (Q x) (P x)) x) (And (Q x) (Minimal P x))","decl":"theorem minimal_and_iff_left_of_imp (hPQ : ∀ ⦃x⦄, P x → Q x) :\n    Minimal (fun x ↦ Q x ∧ P x) x ↔ Q x ∧ (Minimal P x) := by\n  simp_rw [iff_comm, and_comm, minimal_and_iff_right_of_imp hPQ, and_comm]\n\n"}
{"name":"maximal_and_iff_right_of_imp","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP Q : α → Prop\nx : α\ninst✝ : LE α\nhPQ : ∀ ⦃x : α⦄, P x → Q x\n⊢ Iff (Maximal (fun x => And (P x) (Q x)) x) (And (Maximal P x) (Q x))","decl":"theorem maximal_and_iff_right_of_imp (hPQ : ∀ ⦃x⦄, P x → Q x) :\n    Maximal (fun x ↦ P x ∧ Q x) x ↔ (Maximal P x) ∧ Q x :=\n  minimal_and_iff_right_of_imp (α := αᵒᵈ) hPQ\n\n"}
{"name":"maximal_and_iff_left_of_imp","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP Q : α → Prop\nx : α\ninst✝ : LE α\nhPQ : ∀ ⦃x : α⦄, P x → Q x\n⊢ Iff (Maximal (fun x => And (Q x) (P x)) x) (And (Q x) (Maximal P x))","decl":"theorem maximal_and_iff_left_of_imp (hPQ : ∀ ⦃x⦄, P x → Q x) :\n    Maximal (fun x ↦ Q x ∧ P x) x ↔ Q x ∧ (Maximal P x) :=\n  minimal_and_iff_left_of_imp (α := αᵒᵈ) hPQ\n\n"}
{"name":"minimal_iff_forall_lt","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\ninst✝ : Preorder α\n⊢ Iff (Minimal P x) (And (P x) (∀ ⦃y : α⦄, LT.lt y x → Not (P y)))","decl":"theorem minimal_iff_forall_lt : Minimal P x ↔ P x ∧ ∀ ⦃y⦄, y < x → ¬ P y := by\n  simp [Minimal, lt_iff_le_not_le, not_imp_not, imp.swap]\n\n"}
{"name":"maximal_iff_forall_gt","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\ninst✝ : Preorder α\n⊢ Iff (Maximal P x) (And (P x) (∀ ⦃y : α⦄, LT.lt x y → Not (P y)))","decl":"theorem maximal_iff_forall_gt : Maximal P x ↔ P x ∧ ∀ ⦃y⦄, x < y → ¬ P y :=\n  minimal_iff_forall_lt (α := αᵒᵈ)\n\n"}
{"name":"Minimal.not_prop_of_lt","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx y : α\ninst✝ : Preorder α\nh : Minimal P x\nhlt : LT.lt y x\n⊢ Not (P y)","decl":"theorem Minimal.not_prop_of_lt (h : Minimal P x) (hlt : y < x) : ¬ P y :=\n  (minimal_iff_forall_lt.1 h).2 hlt\n\n"}
{"name":"Maximal.not_prop_of_gt","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx y : α\ninst✝ : Preorder α\nh : Maximal P x\nhlt : LT.lt x y\n⊢ Not (P y)","decl":"theorem Maximal.not_prop_of_gt (h : Maximal P x) (hlt : x < y) : ¬ P y :=\n  (maximal_iff_forall_gt.1 h).2 hlt\n\n"}
{"name":"Minimal.not_lt","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx y : α\ninst✝ : Preorder α\nh : Minimal P x\nhy : P y\n⊢ Not (LT.lt y x)","decl":"theorem Minimal.not_lt (h : Minimal P x) (hy : P y) : ¬ (y < x) :=\n  fun hlt ↦ h.not_prop_of_lt hlt hy\n\n"}
{"name":"Maximal.not_gt","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx y : α\ninst✝ : Preorder α\nh : Maximal P x\nhy : P y\n⊢ Not (LT.lt x y)","decl":"theorem Maximal.not_gt (h : Maximal P x) (hy : P y) : ¬ (x < y) :=\n  fun hlt ↦ h.not_prop_of_gt hlt hy\n\n"}
{"name":"minimal_le_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx y : α\ninst✝ : Preorder α\n⊢ Iff (Minimal (fun x => LE.le x y) x) (And (LE.le x y) (IsMin x))","decl":"@[simp] theorem minimal_le_iff : Minimal (· ≤ y) x ↔ x ≤ y ∧ IsMin x :=\n  minimal_iff_isMin (fun _ _ h h' ↦ h'.trans h)\n\n"}
{"name":"maximal_ge_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx y : α\ninst✝ : Preorder α\n⊢ Iff (Maximal (fun x => LE.le y x) x) (And (LE.le y x) (IsMax x))","decl":"@[simp] theorem maximal_ge_iff : Maximal (y ≤ ·) x ↔ y ≤ x ∧ IsMax x :=\n  minimal_le_iff (α := αᵒᵈ)\n\n"}
{"name":"minimal_lt_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx y : α\ninst✝ : Preorder α\n⊢ Iff (Minimal (fun x => LT.lt x y) x) (And (LT.lt x y) (IsMin x))","decl":"@[simp] theorem minimal_lt_iff : Minimal (· < y) x ↔ x < y ∧ IsMin x :=\n  minimal_iff_isMin (fun _ _ h h' ↦ h'.trans_lt h)\n\n"}
{"name":"maximal_gt_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx y : α\ninst✝ : Preorder α\n⊢ Iff (Maximal (fun x => LT.lt y x) x) (And (LT.lt y x) (IsMax x))","decl":"@[simp] theorem maximal_gt_iff : Maximal (y < ·) x ↔ y < x ∧ IsMax x :=\n  minimal_lt_iff (α := αᵒᵈ)\n\n"}
{"name":"not_minimal_iff_exists_lt","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\ninst✝ : Preorder α\nhx : P x\n⊢ Iff (Not (Minimal P x)) (Exists fun y => And (LT.lt y x) (P y))","decl":"theorem not_minimal_iff_exists_lt (hx : P x) : ¬ Minimal P x ↔ ∃ y, y < x ∧ P y := by\n  simp_rw [not_minimal_iff hx, lt_iff_le_not_le, and_comm]\n\n"}
{"name":"exists_lt_of_not_minimal","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\ninst✝ : Preorder α\nhx : P x\na✝ : Not (Minimal P x)\n⊢ Exists fun y => And (LT.lt y x) (P y)","decl":"alias ⟨exists_lt_of_not_minimal, _⟩ := not_minimal_iff_exists_lt\n\n"}
{"name":"not_maximal_iff_exists_gt","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\ninst✝ : Preorder α\nhx : P x\n⊢ Iff (Not (Maximal P x)) (Exists fun y => And (LT.lt x y) (P y))","decl":"theorem not_maximal_iff_exists_gt (hx : P x) : ¬ Maximal P x ↔ ∃ y, x < y ∧ P y :=\n  not_minimal_iff_exists_lt (α := αᵒᵈ) hx\n\n"}
{"name":"exists_gt_of_not_maximal","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\ninst✝ : Preorder α\nhx : P x\na✝ : Not (Maximal P x)\n⊢ Exists fun y => And (LT.lt x y) (P y)","decl":"alias ⟨exists_gt_of_not_maximal, _⟩ := not_maximal_iff_exists_gt\n\n"}
{"name":"Minimal.eq_of_ge","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx y : α\ninst✝ : PartialOrder α\nhx : Minimal P x\nhy : P y\nhge : LE.le y x\n⊢ Eq x y","decl":"theorem Minimal.eq_of_ge (hx : Minimal P x) (hy : P y) (hge : y ≤ x) : x = y :=\n  (hx.2 hy hge).antisymm hge\n\n"}
{"name":"Minimal.eq_of_le","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx y : α\ninst✝ : PartialOrder α\nhx : Minimal P x\nhy : P y\nhle : LE.le y x\n⊢ Eq y x","decl":"theorem Minimal.eq_of_le (hx : Minimal P x) (hy : P y) (hle : y ≤ x) : y = x :=\n  (hx.eq_of_ge hy hle).symm\n\n"}
{"name":"Maximal.eq_of_le","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx y : α\ninst✝ : PartialOrder α\nhx : Maximal P x\nhy : P y\nhle : LE.le x y\n⊢ Eq x y","decl":"theorem Maximal.eq_of_le (hx : Maximal P x) (hy : P y) (hle : x ≤ y) : x = y :=\n  hle.antisymm <| hx.2 hy hle\n\n"}
{"name":"Maximal.eq_of_ge","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx y : α\ninst✝ : PartialOrder α\nhx : Maximal P x\nhy : P y\nhge : LE.le x y\n⊢ Eq y x","decl":"theorem Maximal.eq_of_ge (hx : Maximal P x) (hy : P y) (hge : x ≤ y) : y = x :=\n  (hx.eq_of_le hy hge).symm\n\n"}
{"name":"minimal_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\ninst✝ : PartialOrder α\n⊢ Iff (Minimal P x) (And (P x) (∀ ⦃y : α⦄, P y → LE.le y x → Eq x y))","decl":"theorem minimal_iff : Minimal P x ↔ P x ∧ ∀ ⦃y⦄, P y → y ≤ x → x = y :=\n  ⟨fun h ↦ ⟨h.1, fun _ ↦ h.eq_of_ge⟩, fun h ↦ ⟨h.1, fun _ hy hle ↦ (h.2 hy hle).le⟩⟩\n\n"}
{"name":"maximal_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\ninst✝ : PartialOrder α\n⊢ Iff (Maximal P x) (And (P x) (∀ ⦃y : α⦄, P y → LE.le x y → Eq x y))","decl":"theorem maximal_iff : Maximal P x ↔ P x ∧ ∀ ⦃y⦄, P y → x ≤ y → x = y :=\n  minimal_iff (α := αᵒᵈ)\n\n"}
{"name":"minimal_mem_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝ : PartialOrder α\ns : Set α\n⊢ Iff (Minimal (fun x => Membership.mem s x) x) (And (Membership.mem s x) (∀ ⦃y : α⦄, Membership.mem s y → LE.le y x → Eq x y))","decl":"theorem minimal_mem_iff {s : Set α} : Minimal (· ∈ s) x ↔ x ∈ s ∧ ∀ ⦃y⦄, y ∈ s → y ≤ x → x = y :=\n  minimal_iff\n\n"}
{"name":"maximal_mem_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝ : PartialOrder α\ns : Set α\n⊢ Iff (Maximal (fun x => Membership.mem s x) x) (And (Membership.mem s x) (∀ ⦃y : α⦄, Membership.mem s y → LE.le x y → Eq x y))","decl":"theorem maximal_mem_iff {s : Set α} : Maximal (· ∈ s) x ↔ x ∈ s ∧ ∀ ⦃y⦄, y ∈ s → x ≤ y → x = y :=\n  maximal_iff\n\n"}
{"name":"minimal_iff_eq","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx y : α\ninst✝ : PartialOrder α\nhy : P y\nhP : ∀ ⦃x : α⦄, P x → LE.le y x\n⊢ Iff (Minimal P x) (Eq x y)","decl":"/-- If `P y` holds, and everything satisfying `P` is above `y`, then `y` is the unique minimal\nelement satisfying `P`. -/\ntheorem minimal_iff_eq (hy : P y) (hP : ∀ ⦃x⦄, P x → y ≤ x) : Minimal P x ↔ x = y :=\n  ⟨fun h ↦ h.eq_of_ge hy (hP h.prop), by rintro rfl; exact ⟨hy, fun z hz _ ↦ hP hz⟩⟩\n\n"}
{"name":"maximal_iff_eq","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\nx y : α\ninst✝ : PartialOrder α\nhy : P y\nhP : ∀ ⦃x : α⦄, P x → LE.le x y\n⊢ Iff (Maximal P x) (Eq x y)","decl":"/-- If `P y` holds, and everything satisfying `P` is below `y`, then `y` is the unique maximal\nelement satisfying `P`. -/\ntheorem maximal_iff_eq (hy : P y) (hP : ∀ ⦃x⦄, P x → x ≤ y) : Maximal P x ↔ x = y :=\n  minimal_iff_eq (α := αᵒᵈ) hy hP\n\n"}
{"name":"minimal_ge_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx y : α\ninst✝ : PartialOrder α\n⊢ Iff (Minimal (fun x => LE.le y x) x) (Eq x y)","decl":"@[simp] theorem minimal_ge_iff : Minimal (y ≤ ·) x ↔ x = y :=\n  minimal_iff_eq rfl.le fun _ ↦ id\n\n"}
{"name":"maximal_le_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx y : α\ninst✝ : PartialOrder α\n⊢ Iff (Maximal (fun x => LE.le x y) x) (Eq x y)","decl":"@[simp] theorem maximal_le_iff : Maximal (· ≤ y) x ↔ x = y :=\n  maximal_iff_eq rfl.le fun _ ↦ id\n\n"}
{"name":"minimal_iff_minimal_of_imp_of_forall","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP Q : α → Prop\nx : α\ninst✝ : PartialOrder α\nhPQ : ∀ ⦃x : α⦄, Q x → P x\nh : ∀ ⦃x : α⦄, P x → Exists fun y => And (LE.le y x) (Q y)\n⊢ Iff (Minimal P x) (Minimal Q x)","decl":"theorem minimal_iff_minimal_of_imp_of_forall (hPQ : ∀ ⦃x⦄, Q x → P x)\n    (h : ∀ ⦃x⦄, P x → ∃ y, y ≤ x ∧ Q y) : Minimal P x ↔ Minimal Q x := by\n  refine ⟨fun h' ↦ ⟨?_, fun y hy hyx ↦ h'.le_of_le (hPQ hy) hyx⟩,\n    fun h' ↦ ⟨hPQ h'.prop, fun y hy hyx ↦ ?_⟩⟩\n  · obtain ⟨y, hyx, hy⟩ := h h'.prop\n    rwa [((h'.le_of_le (hPQ hy)) hyx).antisymm hyx]\n  obtain ⟨z, hzy, hz⟩ := h hy\n  exact (h'.le_of_le hz (hzy.trans hyx)).trans hzy\n\n"}
{"name":"maximal_iff_maximal_of_imp_of_forall","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP Q : α → Prop\nx : α\ninst✝ : PartialOrder α\nhPQ : ∀ ⦃x : α⦄, Q x → P x\nh : ∀ ⦃x : α⦄, P x → Exists fun y => And (LE.le x y) (Q y)\n⊢ Iff (Maximal P x) (Maximal Q x)","decl":"theorem maximal_iff_maximal_of_imp_of_forall (hPQ : ∀ ⦃x⦄, Q x → P x)\n    (h : ∀ ⦃x⦄, P x → ∃ y, x ≤ y ∧ Q y) : Maximal P x ↔ Maximal Q x :=\n  minimal_iff_minimal_of_imp_of_forall (α := αᵒᵈ) hPQ h\n\n"}
{"name":"Minimal.eq_of_superset","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : Set α → Prop\ns t : Set α\nh : Minimal P s\nht : P t\nhts : HasSubset.Subset t s\n⊢ Eq s t","decl":"theorem Minimal.eq_of_superset (h : Minimal P s) (ht : P t) (hts : t ⊆ s) : s = t :=\n  h.eq_of_ge ht hts\n\n"}
{"name":"Maximal.eq_of_subset","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : Set α → Prop\ns t : Set α\nh : Maximal P s\nht : P t\nhst : HasSubset.Subset s t\n⊢ Eq s t","decl":"theorem Maximal.eq_of_subset (h : Maximal P s) (ht : P t) (hst : s ⊆ t) : s = t :=\n  h.eq_of_le ht hst\n\n"}
{"name":"Minimal.eq_of_subset","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : Set α → Prop\ns t : Set α\nh : Minimal P s\nht : P t\nhts : HasSubset.Subset t s\n⊢ Eq t s","decl":"theorem Minimal.eq_of_subset (h : Minimal P s) (ht : P t) (hts : t ⊆ s) : t = s :=\n  h.eq_of_le ht hts\n\n"}
{"name":"Maximal.eq_of_superset","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : Set α → Prop\ns t : Set α\nh : Maximal P s\nht : P t\nhst : HasSubset.Subset s t\n⊢ Eq t s","decl":"theorem Maximal.eq_of_superset (h : Maximal P s) (ht : P t) (hst : s ⊆ t) : t = s :=\n  h.eq_of_ge ht hst\n\n"}
{"name":"minimal_subset_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : Set α → Prop\ns : Set α\n⊢ Iff (Minimal P s) (And (P s) (∀ ⦃t : Set α⦄, P t → HasSubset.Subset t s → Eq s t))","decl":"theorem minimal_subset_iff : Minimal P s ↔ P s ∧ ∀ ⦃t⦄, P t → t ⊆ s → s = t :=\n  _root_.minimal_iff\n\n"}
{"name":"maximal_subset_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : Set α → Prop\ns : Set α\n⊢ Iff (Maximal P s) (And (P s) (∀ ⦃t : Set α⦄, P t → HasSubset.Subset s t → Eq s t))","decl":"theorem maximal_subset_iff : Maximal P s ↔ P s ∧ ∀ ⦃t⦄, P t → s ⊆ t → s = t :=\n  _root_.maximal_iff\n\n"}
{"name":"minimal_subset_iff'","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : Set α → Prop\ns : Set α\n⊢ Iff (Minimal P s) (And (P s) (∀ ⦃t : Set α⦄, P t → HasSubset.Subset t s → HasSubset.Subset s t))","decl":"theorem minimal_subset_iff' : Minimal P s ↔ P s ∧ ∀ ⦃t⦄, P t → t ⊆ s → s ⊆ t :=\n  Iff.rfl\n\n"}
{"name":"maximal_subset_iff'","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : Set α → Prop\ns : Set α\n⊢ Iff (Maximal P s) (And (P s) (∀ ⦃t : Set α⦄, P t → HasSubset.Subset s t → HasSubset.Subset t s))","decl":"theorem maximal_subset_iff' : Maximal P s ↔ P s ∧ ∀ ⦃t⦄, P t → s ⊆ t → t ⊆ s :=\n  Iff.rfl\n\n"}
{"name":"not_minimal_subset_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : Set α → Prop\ns : Set α\nhs : P s\n⊢ Iff (Not (Minimal P s)) (Exists fun t => And (HasSSubset.SSubset t s) (P t))","decl":"theorem not_minimal_subset_iff (hs : P s) : ¬ Minimal P s ↔ ∃ t, t ⊂ s ∧ P t :=\n  not_minimal_iff_exists_lt hs\n\n"}
{"name":"not_maximal_subset_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : Set α → Prop\ns : Set α\nhs : P s\n⊢ Iff (Not (Maximal P s)) (Exists fun t => And (HasSSubset.SSubset s t) (P t))","decl":"theorem not_maximal_subset_iff (hs : P s) : ¬ Maximal P s ↔ ∃ t, s ⊂ t ∧ P t :=\n  not_maximal_iff_exists_gt hs\n\n"}
{"name":"Set.minimal_iff_forall_ssubset","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : Set α → Prop\ns : Set α\n⊢ Iff (Minimal P s) (And (P s) (∀ ⦃t : Set α⦄, HasSSubset.SSubset t s → Not (P t)))","decl":"theorem Set.minimal_iff_forall_ssubset : Minimal P s ↔ P s ∧ ∀ ⦃t⦄, t ⊂ s → ¬ P t :=\n  minimal_iff_forall_lt\n\n"}
{"name":"Minimal.not_prop_of_ssubset","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : Set α → Prop\ns t : Set α\nh : Minimal P s\nht : HasSSubset.SSubset t s\n⊢ Not (P t)","decl":"theorem Minimal.not_prop_of_ssubset (h : Minimal P s) (ht : t ⊂ s) : ¬ P t :=\n  (minimal_iff_forall_lt.1 h).2 ht\n\n"}
{"name":"Minimal.not_ssubset","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : Set α → Prop\ns t : Set α\nh : Minimal P s\nht : P t\n⊢ Not (HasSSubset.SSubset t s)","decl":"theorem Minimal.not_ssubset (h : Minimal P s) (ht : P t) : ¬ t ⊂ s :=\n  h.not_lt ht\n\n"}
{"name":"Maximal.mem_of_prop_insert","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\nP : Set α → Prop\ns : Set α\nh : Maximal P s\nhx : P (Insert.insert x s)\n⊢ Membership.mem s x","decl":"theorem Maximal.mem_of_prop_insert (h : Maximal P s) (hx : P (insert x s)) : x ∈ s :=\n  h.eq_of_subset hx (subset_insert _ _) ▸ mem_insert ..\n\n"}
{"name":"Minimal.not_mem_of_prop_diff_singleton","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\nP : Set α → Prop\ns : Set α\nh : Minimal P s\nhx : P (SDiff.sdiff s (Singleton.singleton x))\n⊢ Not (Membership.mem s x)","decl":"theorem Minimal.not_mem_of_prop_diff_singleton (h : Minimal P s) (hx : P (s \\ {x})) : x ∉ s :=\n  fun hxs ↦ ((h.eq_of_superset hx diff_subset).subset hxs).2 rfl\n\n"}
{"name":"Set.minimal_iff_forall_diff_singleton","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : Set α → Prop\ns : Set α\nhP : ∀ ⦃s t : Set α⦄, P t → HasSubset.Subset t s → P s\n⊢ Iff (Minimal P s) (And (P s) (∀ (x : α), Membership.mem s x → Not (P (SDiff.sdiff s (Singleton.singleton x)))))","decl":"theorem Set.minimal_iff_forall_diff_singleton (hP : ∀ ⦃s t⦄, P t → t ⊆ s → P s) :\n    Minimal P s ↔ P s ∧ ∀ x ∈ s, ¬ P (s \\ {x}) :=\n  ⟨fun h ↦ ⟨h.1, fun _ hx hP ↦ h.not_mem_of_prop_diff_singleton hP hx⟩,\n    fun h ↦ ⟨h.1, fun _ ht hts x hxs ↦ by_contra fun hxt ↦\n      h.2 x hxs (hP ht <| subset_diff_singleton hts hxt)⟩⟩\n\n"}
{"name":"Set.exists_diff_singleton_of_not_minimal","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : Set α → Prop\ns : Set α\nhP : ∀ ⦃s t : Set α⦄, P t → HasSubset.Subset t s → P s\nhs : P s\nh : Not (Minimal P s)\n⊢ Exists fun x => And (Membership.mem s x) (P (SDiff.sdiff s (Singleton.singleton x)))","decl":"theorem Set.exists_diff_singleton_of_not_minimal (hP : ∀ ⦃s t⦄, P t → t ⊆ s → P s) (hs : P s)\n    (h : ¬ Minimal P s) : ∃ x ∈ s, P (s \\ {x}) := by\n  simpa [Set.minimal_iff_forall_diff_singleton hP, hs] using h\n\n"}
{"name":"Set.maximal_iff_forall_ssuperset","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : Set α → Prop\ns : Set α\n⊢ Iff (Maximal P s) (And (P s) (∀ ⦃t : Set α⦄, HasSSubset.SSubset s t → Not (P t)))","decl":"theorem Set.maximal_iff_forall_ssuperset : Maximal P s ↔ P s ∧ ∀ ⦃t⦄, s ⊂ t → ¬ P t :=\n  maximal_iff_forall_gt\n\n"}
{"name":"Maximal.not_prop_of_ssuperset","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : Set α → Prop\ns t : Set α\nh : Maximal P s\nht : HasSSubset.SSubset s t\n⊢ Not (P t)","decl":"theorem Maximal.not_prop_of_ssuperset (h : Maximal P s) (ht : s ⊂ t) : ¬ P t :=\n  (maximal_iff_forall_gt.1 h).2 ht\n\n"}
{"name":"Maximal.not_ssuperset","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : Set α → Prop\ns t : Set α\nh : Maximal P s\nht : P t\n⊢ Not (HasSSubset.SSubset s t)","decl":"theorem Maximal.not_ssuperset (h : Maximal P s) (ht : P t) : ¬ s ⊂ t :=\n  h.not_gt ht\n\n"}
{"name":"Set.maximal_iff_forall_insert","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : Set α → Prop\ns : Set α\nhP : ∀ ⦃s t : Set α⦄, P t → HasSubset.Subset s t → P s\n⊢ Iff (Maximal P s) (And (P s) (∀ (x : α), Not (Membership.mem s x) → Not (P (Insert.insert x s))))","decl":"theorem Set.maximal_iff_forall_insert (hP : ∀ ⦃s t⦄, P t → s ⊆ t → P s) :\n    Maximal P s ↔ P s ∧ ∀ x ∉ s, ¬ P (insert x s) := by\n  simp only [not_imp_not]\n  exact ⟨fun h ↦ ⟨h.1, fun x ↦ h.mem_of_prop_insert⟩,\n    fun h ↦ ⟨h.1, fun t ht hst x hxt ↦ h.2 x (hP ht <| insert_subset hxt hst)⟩⟩\n\n"}
{"name":"Set.exists_insert_of_not_maximal","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : Set α → Prop\ns : Set α\nhP : ∀ ⦃s t : Set α⦄, P t → HasSubset.Subset s t → P s\nhs : P s\nh : Not (Maximal P s)\n⊢ Exists fun x => And (Not (Membership.mem s x)) (P (Insert.insert x s))","decl":"theorem Set.exists_insert_of_not_maximal (hP : ∀ ⦃s t⦄, P t → s ⊆ t → P s) (hs : P s)\n    (h : ¬ Maximal P s) : ∃ x ∉ s, P (insert x s) := by\n  simpa [Set.maximal_iff_forall_insert hP, hs] using h\n\n/- TODO : generalize `minimal_iff_forall_diff_singleton` and `maximal_iff_forall_insert`\nto `IsStronglyCoatomic`/`IsStronglyAtomic` orders. -/\n\n"}
{"name":"setOf_minimal_subset","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ HasSubset.Subset (setOf fun x => Minimal (fun x => Membership.mem s x) x) s","decl":"theorem setOf_minimal_subset (s : Set α) : {x | Minimal (· ∈ s) x} ⊆ s :=\n  sep_subset ..\n\n"}
{"name":"setOf_maximal_subset","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ HasSubset.Subset (setOf fun x => Maximal (fun x => Membership.mem s x) x) s","decl":"theorem setOf_maximal_subset (s : Set α) : {x | Maximal (· ∈ s) x} ⊆ s :=\n  sep_subset ..\n\n"}
{"name":"Set.Subsingleton.maximal_mem_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ns : Set α\ninst✝ : Preorder α\nh : s.Subsingleton\n⊢ Iff (Maximal (fun x => Membership.mem s x) x) (Membership.mem s x)","decl":"theorem Set.Subsingleton.maximal_mem_iff (h : s.Subsingleton) : Maximal (· ∈ s) x ↔ x ∈ s := by\n  obtain (rfl | ⟨x, rfl⟩) := h.eq_empty_or_singleton <;> simp\n\n"}
{"name":"Set.Subsingleton.minimal_mem_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ns : Set α\ninst✝ : Preorder α\nh : s.Subsingleton\n⊢ Iff (Minimal (fun x => Membership.mem s x) x) (Membership.mem s x)","decl":"theorem Set.Subsingleton.minimal_mem_iff (h : s.Subsingleton) : Minimal (· ∈ s) x ↔ x ∈ s := by\n  obtain (rfl | ⟨x, rfl⟩) := h.eq_empty_or_singleton <;> simp\n\n"}
{"name":"IsLeast.minimal","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ns : Set α\ninst✝ : Preorder α\nh : IsLeast s x\n⊢ Minimal (fun x => Membership.mem s x) x","decl":"theorem IsLeast.minimal (h : IsLeast s x) : Minimal (· ∈ s) x :=\n  ⟨h.1, fun _b hb _ ↦ h.2 hb⟩\n\n"}
{"name":"IsGreatest.maximal","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ns : Set α\ninst✝ : Preorder α\nh : IsGreatest s x\n⊢ Maximal (fun x => Membership.mem s x) x","decl":"theorem IsGreatest.maximal (h : IsGreatest s x) : Maximal (· ∈ s) x :=\n  ⟨h.1, fun _b hb _ ↦ h.2 hb⟩\n\n"}
{"name":"IsAntichain.minimal_mem_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ns : Set α\ninst✝ : Preorder α\nhs : IsAntichain (fun x1 x2 => LE.le x1 x2) s\n⊢ Iff (Minimal (fun x => Membership.mem s x) x) (Membership.mem s x)","decl":"theorem IsAntichain.minimal_mem_iff (hs : IsAntichain (· ≤ ·) s) : Minimal (· ∈ s) x ↔ x ∈ s :=\n  ⟨fun h ↦ h.prop, fun h ↦ ⟨h, fun _ hys hyx ↦ (hs.eq hys h hyx).symm.le⟩⟩\n\n"}
{"name":"IsAntichain.maximal_mem_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ns : Set α\ninst✝ : Preorder α\nhs : IsAntichain (fun x1 x2 => LE.le x1 x2) s\n⊢ Iff (Maximal (fun x => Membership.mem s x) x) (Membership.mem s x)","decl":"theorem IsAntichain.maximal_mem_iff (hs : IsAntichain (· ≤ ·) s) : Maximal (· ∈ s) x ↔ x ∈ s :=\n  hs.to_dual.minimal_mem_iff\n\n"}
{"name":"IsAntichain.eq_setOf_maximal","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\ns t : Set α\ninst✝ : Preorder α\nht : IsAntichain (fun x1 x2 => LE.le x1 x2) t\nh : ∀ (x : α), Maximal (fun x => Membership.mem s x) x → Membership.mem t x\nhs : ∀ (a : α), Membership.mem t a → Exists fun b => And (LE.le b a) (Maximal (fun x => Membership.mem s x) b)\n⊢ Eq (setOf fun x => Maximal (fun x => Membership.mem s x) x) t","decl":"/-- If `t` is an antichain shadowing and including the set of maximal elements of `s`,\nthen `t` *is* the set of maximal elements of `s`. -/\ntheorem IsAntichain.eq_setOf_maximal (ht : IsAntichain (· ≤ ·) t)\n    (h : ∀ x, Maximal (· ∈ s) x → x ∈ t) (hs : ∀ a ∈ t, ∃ b, b ≤ a ∧ Maximal (· ∈ s) b) :\n    {x | Maximal (· ∈ s) x} = t := by\n  refine Set.ext fun x ↦ ⟨h _, fun hx ↦ ?_⟩\n  obtain ⟨y, hyx, hy⟩ := hs x hx\n  rwa [← ht.eq (h y hy) hx hyx]\n\n"}
{"name":"IsAntichain.eq_setOf_minimal","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\ns t : Set α\ninst✝ : Preorder α\nht : IsAntichain (fun x1 x2 => LE.le x1 x2) t\nh : ∀ (x : α), Minimal (fun x => Membership.mem s x) x → Membership.mem t x\nhs : ∀ (a : α), Membership.mem t a → Exists fun b => And (LE.le a b) (Minimal (fun x => Membership.mem s x) b)\n⊢ Eq (setOf fun x => Minimal (fun x => Membership.mem s x) x) t","decl":"/-- If `t` is an antichain shadowed by and including the set of minimal elements of `s`,\nthen `t` *is* the set of minimal elements of `s`. -/\ntheorem IsAntichain.eq_setOf_minimal (ht : IsAntichain (· ≤ ·) t)\n    (h : ∀ x, Minimal (· ∈ s) x → x ∈ t) (hs : ∀ a ∈ t, ∃ b, a ≤ b ∧ Minimal (· ∈ s) b) :\n    {x | Minimal (· ∈ s) x} = t :=\n  ht.to_dual.eq_setOf_maximal h hs\n\n"}
{"name":"setOf_maximal_antichain","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nP : α → Prop\n⊢ IsAntichain (fun x1 x2 => LE.le x1 x2) (setOf fun x => Maximal P x)","decl":"theorem setOf_maximal_antichain (P : α → Prop) : IsAntichain (· ≤ ·) {x | Maximal P x} :=\n  fun _ hx _ ⟨hy, _⟩ hne hle ↦ hne (hle.antisymm <| hx.2 hy hle)\n\n"}
{"name":"setOf_minimal_antichain","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nP : α → Prop\n⊢ IsAntichain (fun x1 x2 => LE.le x1 x2) (setOf fun x => Minimal P x)","decl":"theorem setOf_minimal_antichain (P : α → Prop) : IsAntichain (· ≤ ·) {x | Minimal P x} :=\n  (setOf_maximal_antichain (α := αᵒᵈ) P).swap\n\n"}
{"name":"IsAntichain.minimal_mem_upperClosure_iff_mem","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ns : Set α\ninst✝ : PartialOrder α\nhs : IsAntichain (fun x1 x2 => LE.le x1 x2) s\n⊢ Iff (Minimal (fun x => Membership.mem (upperClosure s) x) x) (Membership.mem s x)","decl":"theorem IsAntichain.minimal_mem_upperClosure_iff_mem (hs : IsAntichain (· ≤ ·) s) :\n    Minimal (· ∈ upperClosure s) x ↔ x ∈ s := by\n  simp only [upperClosure, UpperSet.mem_mk, mem_setOf_eq]\n  refine ⟨fun h ↦ ?_, fun h ↦ ⟨⟨x, h, rfl.le⟩, fun b ⟨a, has, hab⟩ hbx ↦ ?_⟩⟩\n  · obtain ⟨a, has, hax⟩ := h.prop\n    rwa [h.eq_of_ge ⟨a, has, rfl.le⟩ hax]\n  rwa [← hs.eq has h (hab.trans hbx)]\n\n"}
{"name":"IsAntichain.maximal_mem_lowerClosure_iff_mem","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ns : Set α\ninst✝ : PartialOrder α\nhs : IsAntichain (fun x1 x2 => LE.le x1 x2) s\n⊢ Iff (Maximal (fun x => Membership.mem (lowerClosure s) x) x) (Membership.mem s x)","decl":"theorem IsAntichain.maximal_mem_lowerClosure_iff_mem (hs : IsAntichain (· ≤ ·) s) :\n    Maximal (· ∈ lowerClosure s) x ↔ x ∈ s :=\n  hs.to_dual.minimal_mem_upperClosure_iff_mem\n\n"}
{"name":"IsLeast.minimal_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\na x : α\ns : Set α\ninst✝ : PartialOrder α\nh : IsLeast s a\n⊢ Iff (Minimal (fun x => Membership.mem s x) x) (Eq x a)","decl":"theorem IsLeast.minimal_iff (h : IsLeast s a) : Minimal (· ∈ s) x ↔ x = a :=\n  ⟨fun h' ↦ h'.eq_of_ge h.1 (h.2 h'.prop), fun h' ↦ h' ▸ h.minimal⟩\n\n"}
{"name":"IsGreatest.maximal_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\na x : α\ns : Set α\ninst✝ : PartialOrder α\nh : IsGreatest s a\n⊢ Iff (Maximal (fun x => Membership.mem s x) x) (Eq x a)","decl":"theorem IsGreatest.maximal_iff (h : IsGreatest s a) : Maximal (· ∈ s) x ↔ x = a :=\n  ⟨fun h' ↦ h'.eq_of_le h.1 (h.2 h'.prop), fun h' ↦ h' ▸ h.maximal⟩\n\n"}
{"name":"minimal_mem_image_monotone","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nf : α → β\nhf : ∀ ⦃x y : α⦄, Membership.mem s x → Membership.mem s y → Iff (LE.le (f x) (f y)) (LE.le x y)\nhx : Minimal (fun x => Membership.mem s x) x\n⊢ Minimal (fun x => Membership.mem (Set.image f s) x) (f x)","decl":"theorem minimal_mem_image_monotone (hf : ∀ ⦃x y⦄, x ∈ s → y ∈ s → (f x ≤ f y ↔ x ≤ y))\n    (hx : Minimal (· ∈ s) x) : Minimal (· ∈ f '' s) (f x) := by\n  refine ⟨mem_image_of_mem f hx.prop, ?_⟩\n  rintro _ ⟨y, hy, rfl⟩\n  rw [hf hx.prop hy, hf hy hx.prop]\n  exact hx.le_of_le hy\n\n"}
{"name":"maximal_mem_image_monotone","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nf : α → β\nhf : ∀ ⦃x y : α⦄, Membership.mem s x → Membership.mem s y → Iff (LE.le (f x) (f y)) (LE.le x y)\nhx : Maximal (fun x => Membership.mem s x) x\n⊢ Maximal (fun x => Membership.mem (Set.image f s) x) (f x)","decl":"theorem maximal_mem_image_monotone (hf : ∀ ⦃x y⦄, x ∈ s → y ∈ s → (f x ≤ f y ↔ x ≤ y))\n    (hx : Maximal (· ∈ s) x) : Maximal (· ∈ f '' s) (f x) :=\n  minimal_mem_image_monotone (α := αᵒᵈ) (β := βᵒᵈ) (s := s) (fun _ _ hx hy ↦ hf hy hx) hx\n\n"}
{"name":"minimal_mem_image_monotone_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\na : α\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nf : α → β\nha : Membership.mem s a\nhf : ∀ ⦃x y : α⦄, Membership.mem s x → Membership.mem s y → Iff (LE.le (f x) (f y)) (LE.le x y)\n⊢ Iff (Minimal (fun x => Membership.mem (Set.image f s) x) (f a)) (Minimal (fun x => Membership.mem s x) a)","decl":"theorem minimal_mem_image_monotone_iff (ha : a ∈ s)\n    (hf : ∀ ⦃x y⦄, x ∈ s → y ∈ s → (f x ≤ f y ↔ x ≤ y)) :\n    Minimal (· ∈ f '' s) (f a) ↔ Minimal (· ∈ s) a := by\n  refine ⟨fun h ↦ ⟨ha, fun y hys ↦ ?_⟩, minimal_mem_image_monotone hf⟩\n  rw [← hf ha hys, ← hf hys ha]\n  exact h.le_of_le (mem_image_of_mem f hys)\n\n"}
{"name":"maximal_mem_image_monotone_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\na : α\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nf : α → β\nha : Membership.mem s a\nhf : ∀ ⦃x y : α⦄, Membership.mem s x → Membership.mem s y → Iff (LE.le (f x) (f y)) (LE.le x y)\n⊢ Iff (Maximal (fun x => Membership.mem (Set.image f s) x) (f a)) (Maximal (fun x => Membership.mem s x) a)","decl":"theorem maximal_mem_image_monotone_iff (ha : a ∈ s)\n    (hf : ∀ ⦃x y⦄, x ∈ s → y ∈ s → (f x ≤ f y ↔ x ≤ y)) :\n    Maximal (· ∈ f '' s) (f a) ↔ Maximal (· ∈ s) a :=\n  minimal_mem_image_monotone_iff (α := αᵒᵈ) (β := βᵒᵈ) (s := s) ha fun _ _ hx hy ↦ hf hy hx\n\n"}
{"name":"minimal_mem_image_antitone","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nf : α → β\nhf : ∀ ⦃x y : α⦄, Membership.mem s x → Membership.mem s y → Iff (LE.le (f x) (f y)) (LE.le y x)\nhx : Minimal (fun x => Membership.mem s x) x\n⊢ Maximal (fun x => Membership.mem (Set.image f s) x) (f x)","decl":"theorem minimal_mem_image_antitone (hf : ∀ ⦃x y⦄, x ∈ s → y ∈ s → (f x ≤ f y ↔ y ≤ x))\n    (hx : Minimal (· ∈ s) x) : Maximal (· ∈ f '' s) (f x) :=\n  minimal_mem_image_monotone (β := βᵒᵈ) (fun _ _ h h' ↦ hf h' h) hx\n\n"}
{"name":"maximal_mem_image_antitone","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nf : α → β\nhf : ∀ ⦃x y : α⦄, Membership.mem s x → Membership.mem s y → Iff (LE.le (f x) (f y)) (LE.le y x)\nhx : Maximal (fun x => Membership.mem s x) x\n⊢ Minimal (fun x => Membership.mem (Set.image f s) x) (f x)","decl":"theorem maximal_mem_image_antitone (hf : ∀ ⦃x y⦄, x ∈ s → y ∈ s → (f x ≤ f y ↔ y ≤ x))\n    (hx : Maximal (· ∈ s) x) : Minimal (· ∈ f '' s) (f x) :=\n  maximal_mem_image_monotone (β := βᵒᵈ) (fun _ _ h h' ↦ hf h' h) hx\n\n"}
{"name":"minimal_mem_image_antitone_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\na : α\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nf : α → β\nha : Membership.mem s a\nhf : ∀ ⦃x y : α⦄, Membership.mem s x → Membership.mem s y → Iff (LE.le (f x) (f y)) (LE.le y x)\n⊢ Iff (Minimal (fun x => Membership.mem (Set.image f s) x) (f a)) (Maximal (fun x => Membership.mem s x) a)","decl":"theorem minimal_mem_image_antitone_iff (ha : a ∈ s)\n    (hf : ∀ ⦃x y⦄, x ∈ s → y ∈ s → (f x ≤ f y ↔ y ≤ x)) :\n    Minimal (· ∈ f '' s) (f a) ↔ Maximal (· ∈ s) a :=\n  maximal_mem_image_monotone_iff (β := βᵒᵈ) ha (fun _ _ h h' ↦ hf h' h)\n\n"}
{"name":"maximal_mem_image_antitone_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\na : α\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nf : α → β\nha : Membership.mem s a\nhf : ∀ ⦃x y : α⦄, Membership.mem s x → Membership.mem s y → Iff (LE.le (f x) (f y)) (LE.le y x)\n⊢ Iff (Maximal (fun x => Membership.mem (Set.image f s) x) (f a)) (Minimal (fun x => Membership.mem s x) a)","decl":"theorem maximal_mem_image_antitone_iff (ha : a ∈ s)\n    (hf : ∀ ⦃x y⦄, x ∈ s → y ∈ s → (f x ≤ f y ↔ y ≤ x)) :\n    Maximal (· ∈ f '' s) (f a) ↔ Minimal (· ∈ s) a :=\n  minimal_mem_image_monotone_iff (β := βᵒᵈ) ha (fun _ _ h h' ↦ hf h' h)\n\n"}
{"name":"image_monotone_setOf_minimal","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\nf : α → β\nhf : ∀ ⦃x y : α⦄, P x → P y → Iff (LE.le (f x) (f y)) (LE.le x y)\n⊢ Eq (Set.image f (setOf fun x => Minimal P x)) (setOf fun x => Minimal (fun x => Exists fun x₀ => And (P x₀) (Eq (f x₀) x)) x)","decl":"theorem image_monotone_setOf_minimal (hf : ∀ ⦃x y⦄, P x → P y → (f x ≤ f y ↔ x ≤ y)) :\n    f '' {x | Minimal P x} = {x | Minimal (∃ x₀, P x₀ ∧ f x₀ = ·) x} := by\n  refine Set.ext fun x ↦ ⟨?_, fun h ↦ ?_⟩\n  · rintro ⟨x, (hx : Minimal _ x), rfl⟩\n    exact (minimal_mem_image_monotone_iff hx.prop hf).2 hx\n  obtain ⟨y, hy, rfl⟩ := (mem_setOf_eq ▸ h).prop\n  exact mem_image_of_mem _ <| (minimal_mem_image_monotone_iff (s := setOf P) hy hf).1 h\n\n"}
{"name":"image_monotone_setOf_maximal","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\nf : α → β\nhf : ∀ ⦃x y : α⦄, P x → P y → Iff (LE.le (f x) (f y)) (LE.le x y)\n⊢ Eq (Set.image f (setOf fun x => Maximal P x)) (setOf fun x => Maximal (fun x => Exists fun x₀ => And (P x₀) (Eq (f x₀) x)) x)","decl":"theorem image_monotone_setOf_maximal (hf : ∀ ⦃x y⦄, P x → P y → (f x ≤ f y ↔ x ≤ y)) :\n    f '' {x | Maximal P x} = {x | Maximal (∃ x₀, P x₀ ∧ f x₀ = ·) x} :=\n  image_monotone_setOf_minimal (α := αᵒᵈ) (β := βᵒᵈ) (fun _ _ hx hy ↦ hf hy hx)\n\n"}
{"name":"image_antitone_setOf_minimal","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\nf : α → β\nhf : ∀ ⦃x y : α⦄, P x → P y → Iff (LE.le (f x) (f y)) (LE.le y x)\n⊢ Eq (Set.image f (setOf fun x => Minimal P x)) (setOf fun x => Maximal (fun x => Exists fun x₀ => And (P x₀) (Eq (f x₀) x)) x)","decl":"theorem image_antitone_setOf_minimal (hf : ∀ ⦃x y⦄, P x → P y → (f x ≤ f y ↔ y ≤ x)) :\n    f '' {x | Minimal P x} = {x | Maximal (∃ x₀, P x₀ ∧ f x₀ = ·) x} :=\n  image_monotone_setOf_minimal (β := βᵒᵈ) (fun _ _ hx hy ↦ hf hy hx)\n\n"}
{"name":"image_antitone_setOf_maximal","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nP : α → Prop\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\nf : α → β\nhf : ∀ ⦃x y : α⦄, P x → P y → Iff (LE.le (f x) (f y)) (LE.le y x)\n⊢ Eq (Set.image f (setOf fun x => Maximal P x)) (setOf fun x => Minimal (fun x => Exists fun x₀ => And (P x₀) (Eq (f x₀) x)) x)","decl":"theorem image_antitone_setOf_maximal (hf : ∀ ⦃x y⦄, P x → P y → (f x ≤ f y ↔ y ≤ x)) :\n    f '' {x | Maximal P x} = {x | Minimal (∃ x₀, P x₀ ∧ f x₀ = ·) x} :=\n  image_monotone_setOf_maximal (β := βᵒᵈ) (fun _ _ hx hy ↦ hf hy hx)\n\n"}
{"name":"image_monotone_setOf_minimal_mem","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nf : α → β\nhf : ∀ ⦃x y : α⦄, Membership.mem s x → Membership.mem s y → Iff (LE.le (f x) (f y)) (LE.le x y)\n⊢ Eq (Set.image f (setOf fun x => Minimal (fun x => Membership.mem s x) x)) (setOf fun x => Minimal (fun x => Membership.mem (Set.image f s) x) x)","decl":"theorem image_monotone_setOf_minimal_mem (hf : ∀ ⦃x y⦄, x ∈ s → y ∈ s → (f x ≤ f y ↔ x ≤ y)) :\n    f '' {x | Minimal (· ∈ s) x} = {x | Minimal (· ∈ f '' s) x} :=\n  image_monotone_setOf_minimal hf\n\n"}
{"name":"image_monotone_setOf_maximal_mem","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nf : α → β\nhf : ∀ ⦃x y : α⦄, Membership.mem s x → Membership.mem s y → Iff (LE.le (f x) (f y)) (LE.le x y)\n⊢ Eq (Set.image f (setOf fun x => Maximal (fun x => Membership.mem s x) x)) (setOf fun x => Maximal (fun x => Membership.mem (Set.image f s) x) x)","decl":"theorem image_monotone_setOf_maximal_mem (hf : ∀ ⦃x y⦄, x ∈ s → y ∈ s → (f x ≤ f y ↔ x ≤ y)) :\n    f '' {x | Maximal (· ∈ s) x} = {x | Maximal (· ∈ f '' s) x} :=\n  image_monotone_setOf_maximal hf\n\n"}
{"name":"image_antitone_setOf_minimal_mem","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nf : α → β\nhf : ∀ ⦃x y : α⦄, Membership.mem s x → Membership.mem s y → Iff (LE.le (f x) (f y)) (LE.le y x)\n⊢ Eq (Set.image f (setOf fun x => Minimal (fun x => Membership.mem s x) x)) (setOf fun x => Maximal (fun x => Membership.mem (Set.image f s) x) x)","decl":"theorem image_antitone_setOf_minimal_mem (hf : ∀ ⦃x y⦄, x ∈ s → y ∈ s → (f x ≤ f y ↔ y ≤ x)) :\n    f '' {x | Minimal (· ∈ s) x} = {x | Maximal (· ∈ f '' s) x} :=\n  image_antitone_setOf_minimal hf\n\n"}
{"name":"image_antitone_setOf_maximal_mem","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nf : α → β\nhf : ∀ ⦃x y : α⦄, Membership.mem s x → Membership.mem s y → Iff (LE.le (f x) (f y)) (LE.le y x)\n⊢ Eq (Set.image f (setOf fun x => Maximal (fun x => Membership.mem s x) x)) (setOf fun x => Minimal (fun x => Membership.mem (Set.image f s) x) x)","decl":"theorem image_antitone_setOf_maximal_mem (hf : ∀ ⦃x y⦄, x ∈ s → y ∈ s → (f x ≤ f y ↔ y ≤ x)) :\n    f '' {x | Maximal (· ∈ s) x} = {x | Minimal (· ∈ f '' s) x} :=\n  image_antitone_setOf_maximal hf\n\n"}
{"name":"OrderEmbedding.minimal_mem_image","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nf : OrderEmbedding α β\nhx : Minimal (fun x => Membership.mem s x) x\n⊢ Minimal (fun x => Membership.mem (Set.image (⇑f) s) x) (f x)","decl":"theorem minimal_mem_image (f : α ↪o β) (hx : Minimal (· ∈ s) x) : Minimal (· ∈ f '' s) (f x) :=\n  _root_.minimal_mem_image_monotone (by simp [f.le_iff_le]) hx\n\n"}
{"name":"OrderEmbedding.maximal_mem_image","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nf : OrderEmbedding α β\nhx : Maximal (fun x => Membership.mem s x) x\n⊢ Maximal (fun x => Membership.mem (Set.image (⇑f) s) x) (f x)","decl":"theorem maximal_mem_image (f : α ↪o β) (hx : Maximal (· ∈ s) x) : Maximal (· ∈ f '' s) (f x) :=\n  _root_.maximal_mem_image_monotone (by simp [f.le_iff_le]) hx\n\n"}
{"name":"OrderEmbedding.minimal_mem_image_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\na : α\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nf : OrderEmbedding α β\nha : Membership.mem s a\n⊢ Iff (Minimal (fun x => Membership.mem (Set.image (⇑f) s) x) (f a)) (Minimal (fun x => Membership.mem s x) a)","decl":"theorem minimal_mem_image_iff (ha : a ∈ s) : Minimal (· ∈ f '' s) (f a) ↔ Minimal (· ∈ s) a :=\n  _root_.minimal_mem_image_monotone_iff ha (by simp [f.le_iff_le])\n\n"}
{"name":"OrderEmbedding.maximal_mem_image_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\na : α\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nf : OrderEmbedding α β\nha : Membership.mem s a\n⊢ Iff (Maximal (fun x => Membership.mem (Set.image (⇑f) s) x) (f a)) (Maximal (fun x => Membership.mem s x) a)","decl":"theorem maximal_mem_image_iff (ha : a ∈ s) : Maximal (· ∈ f '' s) (f a) ↔ Maximal (· ∈ s) a :=\n  _root_.maximal_mem_image_monotone_iff ha (by simp [f.le_iff_le])\n\n"}
{"name":"OrderEmbedding.minimal_apply_mem_inter_range_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\nf : OrderEmbedding α β\nt : Set β\n⊢ Iff (Minimal (fun x => Membership.mem (Inter.inter t (Set.range ⇑f)) x) (f x)) (Minimal (fun x => Membership.mem t (f x)) x)","decl":"theorem minimal_apply_mem_inter_range_iff :\n    Minimal (· ∈ t ∩ range f) (f x) ↔ Minimal (fun x ↦ f x ∈ t) x := by\n  refine ⟨fun h ↦ ⟨h.prop.1, fun y hy ↦ ?_⟩, fun h ↦ ⟨⟨h.prop, by simp⟩, ?_⟩⟩\n  · rw [← f.le_iff_le, ← f.le_iff_le]\n    exact h.le_of_le ⟨hy, by simp⟩\n  rintro _ ⟨hyt, ⟨y, rfl⟩⟩\n  simp_rw [f.le_iff_le]\n  exact h.le_of_le hyt\n\n"}
{"name":"OrderEmbedding.maximal_apply_mem_inter_range_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\nf : OrderEmbedding α β\nt : Set β\n⊢ Iff (Maximal (fun x => Membership.mem (Inter.inter t (Set.range ⇑f)) x) (f x)) (Maximal (fun x => Membership.mem t (f x)) x)","decl":"theorem maximal_apply_mem_inter_range_iff :\n    Maximal (· ∈ t ∩ range f) (f x) ↔ Maximal (fun x ↦ f x ∈ t) x :=\n  f.dual.minimal_apply_mem_inter_range_iff\n\n"}
{"name":"OrderEmbedding.minimal_apply_mem_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\nf : OrderEmbedding α β\nt : Set β\nht : HasSubset.Subset t (Set.range ⇑f)\n⊢ Iff (Minimal (fun x => Membership.mem t x) (f x)) (Minimal (fun x => Membership.mem t (f x)) x)","decl":"theorem minimal_apply_mem_iff (ht : t ⊆ Set.range f) :\n    Minimal (· ∈ t) (f x) ↔ Minimal (fun x ↦ f x ∈ t) x := by\n  rw [← f.minimal_apply_mem_inter_range_iff, inter_eq_self_of_subset_left ht]\n\n"}
{"name":"OrderEmbedding.maximal_apply_iff","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\nf : OrderEmbedding α β\nt : Set β\nht : HasSubset.Subset t (Set.range ⇑f)\n⊢ Iff (Maximal (fun x => Membership.mem t x) (f x)) (Maximal (fun x => Membership.mem t (f x)) x)","decl":"theorem maximal_apply_iff (ht : t ⊆ Set.range f) :\n    Maximal (· ∈ t) (f x) ↔ Maximal (fun x ↦ f x ∈ t) x :=\n  f.dual.minimal_apply_mem_iff ht\n\n"}
{"name":"OrderEmbedding.image_setOf_minimal","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nf : OrderEmbedding α β\n⊢ Eq (Set.image (⇑f) (setOf fun x => Minimal (fun x => Membership.mem s x) x)) (setOf fun x => Minimal (fun x => Membership.mem (Set.image (⇑f) s) x) x)","decl":"@[simp] theorem image_setOf_minimal : f '' {x | Minimal (· ∈ s) x} = {x | Minimal (· ∈ f '' s) x} :=\n  _root_.image_monotone_setOf_minimal (by simp [f.le_iff_le])\n\n"}
{"name":"OrderEmbedding.image_setOf_maximal","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nf : OrderEmbedding α β\n⊢ Eq (Set.image (⇑f) (setOf fun x => Maximal (fun x => Membership.mem s x) x)) (setOf fun x => Maximal (fun x => Membership.mem (Set.image (⇑f) s) x) x)","decl":"@[simp] theorem image_setOf_maximal : f '' {x | Maximal (· ∈ s) x} = {x | Maximal (· ∈ f '' s) x} :=\n  _root_.image_monotone_setOf_maximal (by simp [f.le_iff_le])\n\n"}
{"name":"OrderEmbedding.inter_preimage_setOf_minimal_eq_of_subset","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nf : OrderEmbedding α β\nt : Set β\nhts : HasSubset.Subset t (Set.image (⇑f) s)\n⊢ Iff (Membership.mem (Inter.inter s (Set.preimage (⇑f) (setOf fun y => Minimal (fun x => Membership.mem t x) y))) x) (Minimal (fun x => Membership.mem (Inter.inter s (Set.preimage (⇑f) t)) x) x)","decl":"theorem inter_preimage_setOf_minimal_eq_of_subset (hts : t ⊆ f '' s) :\n    x ∈ s ∩ f ⁻¹' {y | Minimal (· ∈ t) y} ↔ Minimal (· ∈ s ∩ f ⁻¹' t) x := by\n  simp_rw [mem_inter_iff, preimage_setOf_eq, mem_setOf_eq, mem_preimage,\n    f.minimal_apply_mem_iff (hts.trans (image_subset_range _ _)),\n    minimal_and_iff_left_of_imp (fun _ hx ↦ f.injective.mem_set_image.1 <| hts hx)]\n\n"}
{"name":"OrderEmbedding.inter_preimage_setOf_maximal_eq_of_subset","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nf : OrderEmbedding α β\nt : Set β\nhts : HasSubset.Subset t (Set.image (⇑f) s)\n⊢ Iff (Membership.mem (Inter.inter s (Set.preimage (⇑f) (setOf fun y => Maximal (fun x => Membership.mem t x) y))) x) (Maximal (fun x => Membership.mem (Inter.inter s (Set.preimage (⇑f) t)) x) x)","decl":"theorem inter_preimage_setOf_maximal_eq_of_subset (hts : t ⊆ f '' s) :\n    x ∈ s ∩ f ⁻¹' {y | Maximal (· ∈ t) y} ↔ Maximal (· ∈ s ∩ f ⁻¹' t) x :=\n  f.dual.inter_preimage_setOf_minimal_eq_of_subset hts\n\n"}
{"name":"OrderIso.image_setOf_minimal","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\nf : OrderIso α β\nP : α → Prop\n⊢ Eq (Set.image (⇑f) (setOf fun x => Minimal P x)) (setOf fun x => Minimal (fun x => P (f.symm x)) x)","decl":"theorem image_setOf_minimal (f : α ≃o β) (P : α → Prop) :\n    f '' {x | Minimal P x} = {x | Minimal (fun x ↦ P (f.symm x)) x} := by\n  convert _root_.image_monotone_setOf_minimal (f := f) (by simp [f.le_iff_le])\n  aesop\n\n"}
{"name":"OrderIso.image_setOf_maximal","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\nf : OrderIso α β\nP : α → Prop\n⊢ Eq (Set.image (⇑f) (setOf fun x => Maximal P x)) (setOf fun x => Maximal (fun x => P (f.symm x)) x)","decl":"theorem image_setOf_maximal (f : α ≃o β) (P : α → Prop) :\n    f '' {x | Maximal P x} = {x | Maximal (fun x ↦ P (f.symm x)) x} := by\n  convert _root_.image_monotone_setOf_maximal (f := f) (by simp [f.le_iff_le])\n  aesop\n\n"}
{"name":"OrderIso.map_minimal_mem","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nt : Set β\nf : OrderIso ↑s ↑t\nhx : Minimal (fun x => Membership.mem s x) x\n⊢ Minimal (fun x => Membership.mem t x) ↑(f ⟨x, ⋯⟩)","decl":"theorem map_minimal_mem (f : s ≃o t) (hx : Minimal (· ∈ s) x) :\n    Minimal (· ∈ t) (f ⟨x, hx.prop⟩) := by\n  simpa only [show t = range (Subtype.val ∘ f) by simp, mem_univ, minimal_true_subtype, hx,\n    true_imp_iff, image_univ] using OrderEmbedding.minimal_mem_image\n    (f.toOrderEmbedding.trans (OrderEmbedding.subtype t)) (s := univ) (x := ⟨x, hx.prop⟩)\n\n"}
{"name":"OrderIso.map_maximal_mem","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\ns : Set α\nt : Set β\nf : OrderIso ↑s ↑t\nhx : Maximal (fun x => Membership.mem s x) x\n⊢ Maximal (fun x => Membership.mem t x) ↑(f ⟨x, ⋯⟩)","decl":"theorem map_maximal_mem (f : s ≃o t) (hx : Maximal (· ∈ s) x) :\n    Maximal (· ∈ t) (f ⟨x, hx.prop⟩) := by\n  simpa only [show t = range (Subtype.val ∘ f) by simp, mem_univ, maximal_true_subtype, hx,\n    true_imp_iff, image_univ] using OrderEmbedding.maximal_mem_image\n    (f.toOrderEmbedding.trans (OrderEmbedding.subtype t)) (s := univ) (x := ⟨x, hx.prop⟩)\n\n"}
{"name":"minimal_mem_Icc","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝ : PartialOrder α\na b : α\nhab : LE.le a b\n⊢ Iff (Minimal (fun x => Membership.mem (Set.Icc a b) x) x) (Eq x a)","decl":"theorem minimal_mem_Icc (hab : a ≤ b) : Minimal (· ∈ Icc a b) x ↔ x = a :=\n  minimal_iff_eq ⟨rfl.le, hab⟩ (fun _ ↦ And.left)\n\n"}
{"name":"maximal_mem_Icc","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝ : PartialOrder α\na b : α\nhab : LE.le a b\n⊢ Iff (Maximal (fun x => Membership.mem (Set.Icc a b) x) x) (Eq x b)","decl":"theorem maximal_mem_Icc (hab : a ≤ b) : Maximal (· ∈ Icc a b) x ↔ x = b :=\n  maximal_iff_eq ⟨hab, rfl.le⟩ (fun _ ↦ And.right)\n\n"}
{"name":"minimal_mem_Ico","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝ : PartialOrder α\na b : α\nhab : LT.lt a b\n⊢ Iff (Minimal (fun x => Membership.mem (Set.Ico a b) x) x) (Eq x a)","decl":"theorem minimal_mem_Ico (hab : a < b) : Minimal (· ∈ Ico a b) x ↔ x = a :=\n  minimal_iff_eq ⟨rfl.le, hab⟩ (fun _ ↦ And.left)\n\n"}
{"name":"maximal_mem_Ioc","module":"Mathlib.Order.Minimal","initialProofState":"α : Type u_1\nx : α\ninst✝ : PartialOrder α\na b : α\nhab : LT.lt a b\n⊢ Iff (Maximal (fun x => Membership.mem (Set.Ioc a b) x) x) (Eq x b)","decl":"theorem maximal_mem_Ioc (hab : a < b) : Maximal (· ∈ Ioc a b) x ↔ x = b :=\n  maximal_iff_eq ⟨hab, rfl.le⟩ (fun _ ↦ And.right)\n\n/- Note : The one-sided interval versions of these lemmas are unnecessary,\nsince `simp` handles them with `maximal_le_iff` and `minimal_ge_iff`. -/\n\n"}
