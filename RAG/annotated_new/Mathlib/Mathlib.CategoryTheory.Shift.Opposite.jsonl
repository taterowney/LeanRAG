{"name":"CategoryTheory.instHasZeroObjectOppositeShift","module":"Mathlib.CategoryTheory.Shift.Opposite","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\nA : Type u_2\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.Limits.HasZeroObject C\n⊢ CategoryTheory.Limits.HasZeroObject (CategoryTheory.OppositeShift C A)","decl":"instance [HasZeroObject C] : HasZeroObject (OppositeShift C A) := by\n  dsimp only [OppositeShift]\n  infer_instance\n\n"}
{"name":"CategoryTheory.instAdditiveOppositeShiftShiftFunctor","module":"Mathlib.CategoryTheory.Shift.Opposite","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\nA : Type u_2\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.Preadditive C\nn : A\ninst✝ : (CategoryTheory.shiftFunctor C n).Additive\n⊢ (CategoryTheory.shiftFunctor (CategoryTheory.OppositeShift C A) n).Additive","decl":"instance [Preadditive C] (n : A) [(shiftFunctor C n).Additive] :\n    (shiftFunctor (OppositeShift C A) n).Additive := by\n  change (shiftFunctor C n).op.Additive\n  infer_instance\n\n"}
{"name":"CategoryTheory.oppositeShiftFunctorZero_inv_app","module":"Mathlib.CategoryTheory.Shift.Opposite","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nA : Type u_2\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\nX : CategoryTheory.OppositeShift C A\n⊢ Eq ((CategoryTheory.shiftFunctorZero (CategoryTheory.OppositeShift C A) A).inv.app X) ((CategoryTheory.shiftFunctorZero C A).hom.app (Opposite.unop X)).op","decl":"lemma oppositeShiftFunctorZero_inv_app (X : OppositeShift C A) :\n    (shiftFunctorZero (OppositeShift C A) A).inv.app X =\n      ((shiftFunctorZero C A).hom.app X.unop).op := rfl\n\n"}
{"name":"CategoryTheory.oppositeShiftFunctorZero_hom_app","module":"Mathlib.CategoryTheory.Shift.Opposite","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nA : Type u_2\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\nX : CategoryTheory.OppositeShift C A\n⊢ Eq ((CategoryTheory.shiftFunctorZero (CategoryTheory.OppositeShift C A) A).hom.app X) ((CategoryTheory.shiftFunctorZero C A).inv.app (Opposite.unop X)).op","decl":"lemma oppositeShiftFunctorZero_hom_app (X : OppositeShift C A) :\n    (shiftFunctorZero (OppositeShift C A) A).hom.app X =\n      ((shiftFunctorZero C A).inv.app X.unop).op := by\n  rw [← cancel_mono ((shiftFunctorZero (OppositeShift C A) A).inv.app X),\n    Iso.hom_inv_id_app, oppositeShiftFunctorZero_inv_app, ← op_comp,\n    Iso.hom_inv_id_app, op_id]\n  rfl\n\n"}
{"name":"CategoryTheory.oppositeShiftFunctorAdd_inv_app","module":"Mathlib.CategoryTheory.Shift.Opposite","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nA : Type u_2\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\nX : CategoryTheory.OppositeShift C A\na b : A\n⊢ Eq ((CategoryTheory.shiftFunctorAdd (CategoryTheory.OppositeShift C A) a b).inv.app X) ((CategoryTheory.shiftFunctorAdd C a b).hom.app (Opposite.unop X)).op","decl":"lemma oppositeShiftFunctorAdd_inv_app :\n    (shiftFunctorAdd (OppositeShift C A) a b).inv.app X =\n      ((shiftFunctorAdd C a b).hom.app X.unop).op := rfl\n\n"}
{"name":"CategoryTheory.oppositeShiftFunctorAdd_hom_app","module":"Mathlib.CategoryTheory.Shift.Opposite","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nA : Type u_2\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\nX : CategoryTheory.OppositeShift C A\na b : A\n⊢ Eq ((CategoryTheory.shiftFunctorAdd (CategoryTheory.OppositeShift C A) a b).hom.app X) ((CategoryTheory.shiftFunctorAdd C a b).inv.app (Opposite.unop X)).op","decl":"lemma oppositeShiftFunctorAdd_hom_app :\n    (shiftFunctorAdd (OppositeShift C A) a b).hom.app X =\n      ((shiftFunctorAdd C a b).inv.app X.unop).op := by\n  rw [← cancel_mono ((shiftFunctorAdd (OppositeShift C A) a b).inv.app X),\n    Iso.hom_inv_id_app, oppositeShiftFunctorAdd_inv_app, ← op_comp,\n    Iso.hom_inv_id_app, op_id]\n  rfl\n\n"}
{"name":"CategoryTheory.oppositeShiftFunctorAdd'_inv_app","module":"Mathlib.CategoryTheory.Shift.Opposite","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nA : Type u_2\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\nX : CategoryTheory.OppositeShift C A\na b c : A\nh : Eq (HAdd.hAdd a b) c\n⊢ Eq ((CategoryTheory.shiftFunctorAdd' (CategoryTheory.OppositeShift C A) a b c h).inv.app X) ((CategoryTheory.shiftFunctorAdd' C a b c h).hom.app (Opposite.unop X)).op","decl":"lemma oppositeShiftFunctorAdd'_inv_app :\n    (shiftFunctorAdd' (OppositeShift C A) a b c h).inv.app X =\n      ((shiftFunctorAdd' C a b c h).hom.app X.unop).op := by\n  subst h\n  simp only [shiftFunctorAdd'_eq_shiftFunctorAdd, oppositeShiftFunctorAdd_inv_app]\n\n"}
{"name":"CategoryTheory.oppositeShiftFunctorAdd'_hom_app","module":"Mathlib.CategoryTheory.Shift.Opposite","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nA : Type u_2\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\nX : CategoryTheory.OppositeShift C A\na b c : A\nh : Eq (HAdd.hAdd a b) c\n⊢ Eq ((CategoryTheory.shiftFunctorAdd' (CategoryTheory.OppositeShift C A) a b c h).hom.app X) ((CategoryTheory.shiftFunctorAdd' C a b c h).inv.app (Opposite.unop X)).op","decl":"lemma oppositeShiftFunctorAdd'_hom_app :\n    (shiftFunctorAdd' (OppositeShift C A) a b c h).hom.app X =\n      ((shiftFunctorAdd' C a b c h).inv.app X.unop).op := by\n  subst h\n  simp only [shiftFunctorAdd'_eq_shiftFunctorAdd, oppositeShiftFunctorAdd_hom_app]\n\n"}
{"name":"CategoryTheory.Functor.commShiftOp_iso_eq","module":"Mathlib.CategoryTheory.Shift.Opposite","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} D\nA : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift A\na : A\n⊢ Eq ((CategoryTheory.OppositeShift.functor A F).commShiftIso a) (CategoryTheory.NatIso.op (F.commShiftIso a)).symm","decl":"lemma commShiftOp_iso_eq [CommShift F A] (a : A) :\n    (OppositeShift.functor A F).commShiftIso a = (NatIso.op (F.commShiftIso a)).symm := rfl\n\n"}
{"name":"CategoryTheory.Functor.commShiftUnop_iso","module":"Mathlib.CategoryTheory.Shift.Opposite","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} D\nA : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\nF : CategoryTheory.Functor C D\ninst✝ : (CategoryTheory.OppositeShift.functor A F).CommShift A\na : A\n⊢ Eq (CategoryTheory.Functor.CommShift.iso a) (CategoryTheory.NatIso.removeOp ((CategoryTheory.OppositeShift.functor A F).commShiftIso a).symm)","decl":"/--\nGiven a `CommShift` structure on `OppositeShift.functor F` (for the naive shifts on the opposite\ncategories), this is the corresponding `CommShift` structure on `F`.\n-/\n@[simps]\nnoncomputable def commShiftUnop\n    [CommShift (OppositeShift.functor A F) A] : CommShift F A where\n  iso a := NatIso.removeOp ((OppositeShift.functor A F).commShiftIso a).symm\n  zero := by\n    simp only\n    rw [commShiftIso_zero]\n    ext\n    simp only [comp_obj, NatIso.removeOp_hom, Iso.symm_hom, NatTrans.removeOp_app, op_obj,\n      CommShift.isoZero_inv_app, op_map, unop_comp, Quiver.Hom.unop_op, CommShift.isoZero_hom_app]\n    erw [oppositeShiftFunctorZero_hom_app, oppositeShiftFunctorZero_inv_app]\n    rfl\n  add a b := by\n    simp only\n    rw [commShiftIso_add]\n    ext\n    simp only [comp_obj, NatIso.removeOp_hom, Iso.symm_hom, NatTrans.removeOp_app, op_obj,\n      CommShift.isoAdd_inv_app, op_map, unop_comp, Quiver.Hom.unop_op, Category.assoc,\n      CommShift.isoAdd_hom_app]\n    erw [oppositeShiftFunctorAdd_hom_app, oppositeShiftFunctorAdd_inv_app]\n    rfl\n\n"}
{"name":"CategoryTheory.NatTrans.commShift_op","module":"Mathlib.CategoryTheory.Shift.Opposite","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_4, u_2} D\nA : Type u_3\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\nF G : CategoryTheory.Functor C D\ninst✝² : F.CommShift A\ninst✝¹ : G.CommShift A\nτ : Quiver.Hom F G\ninst✝ : CategoryTheory.NatTrans.CommShift τ A\n⊢ CategoryTheory.NatTrans.CommShift (CategoryTheory.OppositeShift.natTrans A τ) A","decl":"open Opposite in\ninstance commShift_op (τ : F ⟶ G) [NatTrans.CommShift τ A] :\n    NatTrans.CommShift (OppositeShift.natTrans A τ) A where\n  shift_comm _ := by\n    ext\n    rw [← cancel_mono (((OppositeShift.functor A F).commShiftIso _ ).inv.app _),\n      ← cancel_epi (((OppositeShift.functor A G).commShiftIso _).inv.app _)]\n    dsimp\n    simp only [assoc, Iso.inv_hom_id_app_assoc, Iso.hom_inv_id_app, Functor.comp_obj,\n      Functor.op_obj, comp_id]\n    exact (op_inj_iff _ _).mpr (NatTrans.shift_app_comm τ _ (unop _))\n\n"}
{"name":"CategoryTheory.NatTrans.instCommShiftOppositeShiftHomFunctorNatIsoId","module":"Mathlib.CategoryTheory.Shift.Opposite","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\nA : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\n⊢ CategoryTheory.NatTrans.CommShift (CategoryTheory.NatTrans.OppositeShift.natIsoId C A).hom A","decl":"/--\nThe natural isomorphism `NatTrans.OppositeShift.natIsoId C A` commutes with shifts.\n-/\ninstance : NatTrans.CommShift (OppositeShift.natIsoId C A).hom A where\n  shift_comm _ := by\n    ext\n    dsimp [OppositeShift.natIsoId, Functor.commShiftOp_iso_eq]\n    simp only [Functor.commShiftIso_id_hom_app, Functor.comp_obj, Functor.id_obj, Functor.map_id,\n      comp_id, Functor.commShiftIso_id_inv_app, CategoryTheory.op_id, id_comp]\n    rfl\n\n"}
{"name":"CategoryTheory.NatTrans.instCommShiftOppositeShiftHomFunctorNatIsoComp","module":"Mathlib.CategoryTheory.Shift.Opposite","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_3\ninst✝⁶ : AddMonoid A\ninst✝⁵ : CategoryTheory.HasShift C A\ninst✝⁴ : CategoryTheory.HasShift D A\nF : CategoryTheory.Functor C D\nE : Type u_4\ninst✝³ : CategoryTheory.Category.{u_7, u_4} E\ninst✝² : CategoryTheory.HasShift E A\nG : CategoryTheory.Functor D E\ninst✝¹ : F.CommShift A\ninst✝ : G.CommShift A\n⊢ CategoryTheory.NatTrans.CommShift (CategoryTheory.NatTrans.OppositeShift.natIsoComp A F G).hom A","decl":"instance [F.CommShift A] [G.CommShift A] :\n    NatTrans.CommShift (OppositeShift.natIsoComp A F G).hom A where\n  shift_comm _ := by\n    ext\n    dsimp [OppositeShift.natIsoComp, Functor.commShiftOp_iso_eq]\n    simp only [Functor.map_id, comp_id, id_comp]\n    rfl\n\n"}
{"name":"CategoryTheory.OppositeShift.adjunction_counit","module":"Mathlib.CategoryTheory.Shift.Opposite","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\nA : Type u_3\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.HasShift D A\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\n⊢ Eq (CategoryTheory.OppositeShift.adjunction A adj).counit (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.OppositeShift.natIsoComp A F G).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.OppositeShift.natTrans A adj.unit) (CategoryTheory.NatTrans.OppositeShift.natIsoId C A).inv))","decl":"/--\nThe adjunction `adj`, seen as an adjunction between `OppositeShift.functor G`\nand `OppositeShift.functor F`.\n-/\n@[simps (config := .lemmasOnly)]\ndef OppositeShift.adjunction {F} {G : D ⥤ C} (adj : F ⊣ G) :\n    OppositeShift.functor A G ⊣ OppositeShift.functor A F where\n  unit := (NatTrans.OppositeShift.natIsoId D A).hom ≫\n    OppositeShift.natTrans A adj.counit ≫ (NatTrans.OppositeShift.natIsoComp A G F).hom\n  counit := (NatTrans.OppositeShift.natIsoComp A F G).inv ≫\n    OppositeShift.natTrans A adj.unit ≫ (NatTrans.OppositeShift.natIsoId C A).inv\n  left_triangle_components _ := by\n    dsimp [OppositeShift.natTrans, NatTrans.OppositeShift.natIsoComp,\n      NatTrans.OppositeShift.natIsoId, OppositeShift.functor]\n    simp only [comp_id, id_comp, Quiver.Hom.unop_op]\n    rw [← op_comp, adj.right_triangle_components]\n    rfl\n  right_triangle_components _ := by\n    dsimp [OppositeShift.natTrans, NatTrans.OppositeShift.natIsoComp,\n      NatTrans.OppositeShift.natIsoId, OppositeShift.functor]\n    simp only [comp_id, id_comp, Quiver.Hom.unop_op]\n    rw [← op_comp, adj.left_triangle_components]\n    rfl\n\n"}
{"name":"CategoryTheory.OppositeShift.adjunction_unit","module":"Mathlib.CategoryTheory.Shift.Opposite","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\nA : Type u_3\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.HasShift D A\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\n⊢ Eq (CategoryTheory.OppositeShift.adjunction A adj).unit (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.OppositeShift.natIsoId D A).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.OppositeShift.natTrans A adj.counit) (CategoryTheory.NatTrans.OppositeShift.natIsoComp A G F).hom))","decl":"/--\nThe adjunction `adj`, seen as an adjunction between `OppositeShift.functor G`\nand `OppositeShift.functor F`.\n-/\n@[simps (config := .lemmasOnly)]\ndef OppositeShift.adjunction {F} {G : D ⥤ C} (adj : F ⊣ G) :\n    OppositeShift.functor A G ⊣ OppositeShift.functor A F where\n  unit := (NatTrans.OppositeShift.natIsoId D A).hom ≫\n    OppositeShift.natTrans A adj.counit ≫ (NatTrans.OppositeShift.natIsoComp A G F).hom\n  counit := (NatTrans.OppositeShift.natIsoComp A F G).inv ≫\n    OppositeShift.natTrans A adj.unit ≫ (NatTrans.OppositeShift.natIsoId C A).inv\n  left_triangle_components _ := by\n    dsimp [OppositeShift.natTrans, NatTrans.OppositeShift.natIsoComp,\n      NatTrans.OppositeShift.natIsoId, OppositeShift.functor]\n    simp only [comp_id, id_comp, Quiver.Hom.unop_op]\n    rw [← op_comp, adj.right_triangle_components]\n    rfl\n  right_triangle_components _ := by\n    dsimp [OppositeShift.natTrans, NatTrans.OppositeShift.natIsoComp,\n      NatTrans.OppositeShift.natIsoId, OppositeShift.functor]\n    simp only [comp_id, id_comp, Quiver.Hom.unop_op]\n    rw [← op_comp, adj.left_triangle_components]\n    rfl\n\n"}
{"name":"CategoryTheory.Adjunction.commShift_op","module":"Mathlib.CategoryTheory.Shift.Opposite","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\nA : Type u_3\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝² : F.CommShift A\ninst✝¹ : G.CommShift A\ninst✝ : adj.CommShift A\n⊢ (CategoryTheory.OppositeShift.adjunction A adj).CommShift A","decl":"/--\nIf an adjunction `F ⊣ G` is compatible with `CommShift` structures on `F` and `G`, then\nthe opposite adjunction `OppositeShift.adjunction adj` is compatible with the opposite\n`CommShift` structures.\n-/\ninstance commShift_op [F.CommShift A] [G.CommShift A]  [adj.CommShift A] :\n    Adjunction.CommShift (OppositeShift.adjunction A adj) A where\n  commShift_unit := by dsimp [OppositeShift.adjunction]; infer_instance\n  commShift_counit := by dsimp [OppositeShift.adjunction]; infer_instance\n\n"}
