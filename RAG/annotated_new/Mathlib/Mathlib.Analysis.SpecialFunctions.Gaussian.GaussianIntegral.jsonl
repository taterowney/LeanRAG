{"name":"exp_neg_mul_rpow_isLittleO_exp_neg","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"p b : Real\nhb : LT.lt 0 b\nhp : LT.lt 1 p\n‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun x => Real.exp (HMul.hMul (Neg.neg b) (HPow.hPow x p))) fun x => Real.exp (Neg.neg x)","decl":"theorem exp_neg_mul_rpow_isLittleO_exp_neg {p b : ‚Ñù} (hb : 0 < b) (hp : 1 < p) :\n    (fun x : ‚Ñù => exp (- b * x ^ p)) =o[atTop] fun x : ‚Ñù => exp (-x) := by\n  rw [isLittleO_exp_comp_exp_comp]\n  suffices Tendsto (fun x => x * (b * x ^ (p - 1) + -1)) atTop atTop by\n    refine Tendsto.congr' ?_ this\n    refine eventuallyEq_of_mem (Ioi_mem_atTop (0 : ‚Ñù)) (fun x hx => ?_)\n    rw [mem_Ioi] at hx\n    rw [rpow_sub_one hx.ne']\n    field_simp [hx.ne']\n    ring\n  apply Tendsto.atTop_mul_atTop tendsto_id\n  refine tendsto_atTop_add_const_right atTop (-1 : ‚Ñù) ?_\n  exact Tendsto.const_mul_atTop hb (tendsto_rpow_atTop (by linarith))\n\n"}
{"name":"exp_neg_mul_sq_isLittleO_exp_neg","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"b : Real\nhb : LT.lt 0 b\n‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun x => Real.exp (HMul.hMul (Neg.neg b) (HPow.hPow x 2))) fun x => Real.exp (Neg.neg x)","decl":"theorem exp_neg_mul_sq_isLittleO_exp_neg {b : ‚Ñù} (hb : 0 < b) :\n    (fun x : ‚Ñù => exp (-b * x ^ 2)) =o[atTop] fun x : ‚Ñù => exp (-x) := by\n  simp_rw [‚Üê rpow_two]\n  exact exp_neg_mul_rpow_isLittleO_exp_neg hb one_lt_two\n\n"}
{"name":"rpow_mul_exp_neg_mul_rpow_isLittleO_exp_neg","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"s b p : Real\nhp : LT.lt 1 p\nhb : LT.lt 0 b\n‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun x => HMul.hMul (HPow.hPow x s) (Real.exp (HMul.hMul (Neg.neg b) (HPow.hPow x p)))) fun x => Real.exp (HMul.hMul (Neg.neg (1 / 2)) x)","decl":"theorem rpow_mul_exp_neg_mul_rpow_isLittleO_exp_neg (s : ‚Ñù) {b p : ‚Ñù} (hp : 1 < p) (hb : 0 < b) :\n    (fun x : ‚Ñù => x ^ s * exp (- b * x ^ p)) =o[atTop] fun x : ‚Ñù => exp (-(1 / 2) * x) := by\n  apply ((isBigO_refl (fun x : ‚Ñù => x ^ s) atTop).mul_isLittleO\n      (exp_neg_mul_rpow_isLittleO_exp_neg hb hp)).trans\n  simpa only [mul_comm] using Real.Gamma_integrand_isLittleO s\n\n"}
{"name":"rpow_mul_exp_neg_mul_sq_isLittleO_exp_neg","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"b : Real\nhb : LT.lt 0 b\ns : Real\n‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun x => HMul.hMul (HPow.hPow x s) (Real.exp (HMul.hMul (Neg.neg b) (HPow.hPow x 2)))) fun x => Real.exp (HMul.hMul (Neg.neg (1 / 2)) x)","decl":"theorem rpow_mul_exp_neg_mul_sq_isLittleO_exp_neg {b : ‚Ñù} (hb : 0 < b) (s : ‚Ñù) :\n    (fun x : ‚Ñù => x ^ s * exp (-b * x ^ 2)) =o[atTop] fun x : ‚Ñù => exp (-(1 / 2) * x) := by\n  simp_rw [‚Üê rpow_two]\n  exact rpow_mul_exp_neg_mul_rpow_isLittleO_exp_neg s one_lt_two hb\n\n"}
{"name":"integrableOn_rpow_mul_exp_neg_rpow","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"p s : Real\nhs : LT.lt (-1) s\nhp : LE.le 1 p\n‚ä¢ MeasureTheory.IntegrableOn (fun x => HMul.hMul (HPow.hPow x s) (Real.exp (Neg.neg (HPow.hPow x p)))) (Set.Ioi 0) MeasureTheory.MeasureSpace.volume","decl":"theorem integrableOn_rpow_mul_exp_neg_rpow {p s : ‚Ñù} (hs : -1 < s) (hp : 1 ‚â§ p) :\n    IntegrableOn (fun x : ‚Ñù => x ^ s * exp (- x ^ p)) (Ioi 0) := by\n  obtain hp | hp := le_iff_lt_or_eq.mp hp\n  ¬∑ have h_exp : ‚àÄ x, ContinuousAt (fun x => exp (- x)) x := fun x => continuousAt_neg.rexp\n    rw [‚Üê Ioc_union_Ioi_eq_Ioi zero_le_one, integrableOn_union]\n    constructor\n    ¬∑ rw [‚Üê integrableOn_Icc_iff_integrableOn_Ioc]\n      refine IntegrableOn.mul_continuousOn ?_ ?_ isCompact_Icc\n      ¬∑ refine (intervalIntegrable_iff_integrableOn_Icc_of_le zero_le_one).mp ?_\n        exact intervalIntegral.intervalIntegrable_rpow' hs\n      ¬∑ intro x _\n        change ContinuousWithinAt ((fun x => exp (- x)) ‚àò (fun x => x ^ p)) (Icc 0 1) x\n        refine ContinuousAt.comp_continuousWithinAt (h_exp _) ?_\n        exact continuousWithinAt_id.rpow_const (Or.inr (le_of_lt (lt_trans zero_lt_one hp)))\n    ¬∑ have h_rpow : ‚àÄ (x r : ‚Ñù), x ‚àà Ici 1 ‚Üí ContinuousWithinAt (fun x => x ^ r) (Ici 1) x := by\n        intro _ _ hx\n        refine continuousWithinAt_id.rpow_const (Or.inl ?_)\n        exact ne_of_gt (lt_of_lt_of_le zero_lt_one hx)\n      refine integrable_of_isBigO_exp_neg (by norm_num : (0 : ‚Ñù) < 1 / 2)\n        (ContinuousOn.mul (fun x hx => h_rpow x s hx) (fun x hx => ?_)) (IsLittleO.isBigO ?_)\n      ¬∑ change ContinuousWithinAt ((fun x => exp (- x)) ‚àò (fun x => x ^ p)) (Ici 1) x\n        exact ContinuousAt.comp_continuousWithinAt (h_exp _) (h_rpow x p hx)\n      ¬∑ convert rpow_mul_exp_neg_mul_rpow_isLittleO_exp_neg s hp (by norm_num : (0 : ‚Ñù) < 1) using 3\n        rw [neg_mul, one_mul]\n  ¬∑ simp_rw [‚Üê hp, Real.rpow_one]\n    convert Real.GammaIntegral_convergent (by linarith : 0 < s + 1) using 2\n    rw [add_sub_cancel_right, mul_comm]\n\n"}
{"name":"integrableOn_rpow_mul_exp_neg_mul_rpow","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"p s b : Real\nhs : LT.lt (-1) s\nhp : LE.le 1 p\nhb : LT.lt 0 b\n‚ä¢ MeasureTheory.IntegrableOn (fun x => HMul.hMul (HPow.hPow x s) (Real.exp (HMul.hMul (Neg.neg b) (HPow.hPow x p)))) (Set.Ioi 0) MeasureTheory.MeasureSpace.volume","decl":"theorem integrableOn_rpow_mul_exp_neg_mul_rpow {p s b : ‚Ñù} (hs : -1 < s) (hp : 1 ‚â§ p) (hb : 0 < b) :\n    IntegrableOn (fun x : ‚Ñù => x ^ s * exp (- b * x ^ p)) (Ioi 0) := by\n  have hib : 0 < b ^ (-p‚Åª¬π) := rpow_pos_of_pos hb _\n  suffices IntegrableOn (fun x ‚Ü¶ (b ^ (-p‚Åª¬π)) ^ s * (x ^ s * exp (-x ^ p))) (Ioi 0) by\n    rw [show 0 = b ^ (-p‚Åª¬π) * 0 by rw [mul_zero], ‚Üê integrableOn_Ioi_comp_mul_left_iff _ _ hib]\n    refine this.congr_fun (fun _ hx => ?_) measurableSet_Ioi\n    rw [‚Üê mul_assoc, mul_rpow, mul_rpow, ‚Üê rpow_mul (z := p), neg_mul, neg_mul, inv_mul_cancel‚ÇÄ,\n      rpow_neg_one, mul_inv_cancel_left‚ÇÄ]\n    all_goals linarith [mem_Ioi.mp hx]\n  refine Integrable.const_mul ?_ _\n  rw [‚Üê IntegrableOn]\n  exact integrableOn_rpow_mul_exp_neg_rpow hs hp\n\n"}
{"name":"integrableOn_rpow_mul_exp_neg_mul_sq","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"b : Real\nhb : LT.lt 0 b\ns : Real\nhs : LT.lt (-1) s\n‚ä¢ MeasureTheory.IntegrableOn (fun x => HMul.hMul (HPow.hPow x s) (Real.exp (HMul.hMul (Neg.neg b) (HPow.hPow x 2)))) (Set.Ioi 0) MeasureTheory.MeasureSpace.volume","decl":"theorem integrableOn_rpow_mul_exp_neg_mul_sq {b : ‚Ñù} (hb : 0 < b) {s : ‚Ñù} (hs : -1 < s) :\n    IntegrableOn (fun x : ‚Ñù => x ^ s * exp (-b * x ^ 2)) (Ioi 0) := by\n  simp_rw [‚Üê rpow_two]\n  exact integrableOn_rpow_mul_exp_neg_mul_rpow hs one_le_two hb\n\n"}
{"name":"integrable_rpow_mul_exp_neg_mul_sq","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"b : Real\nhb : LT.lt 0 b\ns : Real\nhs : LT.lt (-1) s\n‚ä¢ MeasureTheory.Integrable (fun x => HMul.hMul (HPow.hPow x s) (Real.exp (HMul.hMul (Neg.neg b) (HPow.hPow x 2)))) MeasureTheory.MeasureSpace.volume","decl":"theorem integrable_rpow_mul_exp_neg_mul_sq {b : ‚Ñù} (hb : 0 < b) {s : ‚Ñù} (hs : -1 < s) :\n    Integrable fun x : ‚Ñù => x ^ s * exp (-b * x ^ 2) := by\n  rw [‚Üê integrableOn_univ, ‚Üê @Iio_union_Ici _ _ (0 : ‚Ñù), integrableOn_union,\n    integrableOn_Ici_iff_integrableOn_Ioi]\n  refine ‚ü®?_, integrableOn_rpow_mul_exp_neg_mul_sq hb hs‚ü©\n  rw [‚Üê (Measure.measurePreserving_neg (volume : Measure ‚Ñù)).integrableOn_comp_preimage\n      (Homeomorph.neg ‚Ñù).measurableEmbedding]\n  simp only [Function.comp_def, neg_sq, neg_preimage, neg_Iio, neg_neg, neg_zero]\n  apply Integrable.mono' (integrableOn_rpow_mul_exp_neg_mul_sq hb hs)\n  ¬∑ apply Measurable.aestronglyMeasurable\n    exact (measurable_id'.neg.pow measurable_const).mul\n      ((measurable_id'.pow measurable_const).const_mul (-b)).exp\n  ¬∑ have : MeasurableSet (Ioi (0 : ‚Ñù)) := measurableSet_Ioi\n    filter_upwards [ae_restrict_mem this] with x hx\n    have h'x : 0 ‚â§ x := le_of_lt hx\n    rw [Real.norm_eq_abs, abs_mul, abs_of_nonneg (exp_pos _).le]\n    apply mul_le_mul_of_nonneg_right _ (exp_pos _).le\n    simpa [abs_of_nonneg h'x] using abs_rpow_le_abs_rpow (-x) s\n\n"}
{"name":"integrable_exp_neg_mul_sq","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"b : Real\nhb : LT.lt 0 b\n‚ä¢ MeasureTheory.Integrable (fun x => Real.exp (HMul.hMul (Neg.neg b) (HPow.hPow x 2))) MeasureTheory.MeasureSpace.volume","decl":"theorem integrable_exp_neg_mul_sq {b : ‚Ñù} (hb : 0 < b) :\n    Integrable fun x : ‚Ñù => exp (-b * x ^ 2) := by\n  simpa using integrable_rpow_mul_exp_neg_mul_sq hb (by norm_num : (-1 : ‚Ñù) < 0)\n\n"}
{"name":"integrableOn_Ioi_exp_neg_mul_sq_iff","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"b : Real\n‚ä¢ Iff (MeasureTheory.IntegrableOn (fun x => Real.exp (HMul.hMul (Neg.neg b) (HPow.hPow x 2))) (Set.Ioi 0) MeasureTheory.MeasureSpace.volume) (LT.lt 0 b)","decl":"theorem integrableOn_Ioi_exp_neg_mul_sq_iff {b : ‚Ñù} :\n    IntegrableOn (fun x : ‚Ñù => exp (-b * x ^ 2)) (Ioi 0) ‚Üî 0 < b := by\n  refine ‚ü®fun h => ?_, fun h => (integrable_exp_neg_mul_sq h).integrableOn‚ü©\n  by_contra! hb\n  have : ‚à´‚Åª _ : ‚Ñù in Ioi 0, 1 ‚â§ ‚à´‚Åª x : ‚Ñù in Ioi 0, ‚Äñexp (-b * x ^ 2)‚Äñ‚Çä := by\n    apply lintegral_mono (fun x ‚Ü¶ _)\n    simp only [neg_mul, ENNReal.one_le_coe_iff, ‚Üê toNNReal_one, toNNReal_le_iff_le_coe,\n      Real.norm_of_nonneg (exp_pos _).le, coe_nnnorm, one_le_exp_iff, Right.nonneg_neg_iff]\n    exact fun x ‚Ü¶ mul_nonpos_of_nonpos_of_nonneg hb (sq_nonneg x)\n  simpa using this.trans_lt h.2\n\n"}
{"name":"integrable_exp_neg_mul_sq_iff","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"b : Real\n‚ä¢ Iff (MeasureTheory.Integrable (fun x => Real.exp (HMul.hMul (Neg.neg b) (HPow.hPow x 2))) MeasureTheory.MeasureSpace.volume) (LT.lt 0 b)","decl":"theorem integrable_exp_neg_mul_sq_iff {b : ‚Ñù} :\n    (Integrable fun x : ‚Ñù => exp (-b * x ^ 2)) ‚Üî 0 < b :=\n  ‚ü®fun h => integrableOn_Ioi_exp_neg_mul_sq_iff.mp h.integrableOn, integrable_exp_neg_mul_sq‚ü©\n\n"}
{"name":"integrable_mul_exp_neg_mul_sq","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"b : Real\nhb : LT.lt 0 b\n‚ä¢ MeasureTheory.Integrable (fun x => HMul.hMul x (Real.exp (HMul.hMul (Neg.neg b) (HPow.hPow x 2)))) MeasureTheory.MeasureSpace.volume","decl":"theorem integrable_mul_exp_neg_mul_sq {b : ‚Ñù} (hb : 0 < b) :\n    Integrable fun x : ‚Ñù => x * exp (-b * x ^ 2) := by\n  simpa using integrable_rpow_mul_exp_neg_mul_sq hb (by norm_num : (-1 : ‚Ñù) < 1)\n\n"}
{"name":"norm_cexp_neg_mul_sq","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"b : Complex\nx : Real\n‚ä¢ Eq (Norm.norm (Complex.exp (HMul.hMul (Neg.neg b) (HPow.hPow (‚Üëx) 2)))) (Real.exp (HMul.hMul (Neg.neg b.re) (HPow.hPow x 2)))","decl":"theorem norm_cexp_neg_mul_sq (b : ‚ÑÇ) (x : ‚Ñù) :\n    ‚ÄñComplex.exp (-b * (x : ‚ÑÇ) ^ 2)‚Äñ = exp (-b.re * x ^ 2) := by\n  rw [Complex.norm_eq_abs, Complex.abs_exp, ‚Üê ofReal_pow, mul_comm (-b) _, re_ofReal_mul, neg_re,\n    mul_comm]\n\n"}
{"name":"integrable_cexp_neg_mul_sq","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"b : Complex\nhb : LT.lt 0 b.re\n‚ä¢ MeasureTheory.Integrable (fun x => Complex.exp (HMul.hMul (Neg.neg b) (HPow.hPow (‚Üëx) 2))) MeasureTheory.MeasureSpace.volume","decl":"theorem integrable_cexp_neg_mul_sq {b : ‚ÑÇ} (hb : 0 < b.re) :\n    Integrable fun x : ‚Ñù => cexp (-b * (x : ‚ÑÇ) ^ 2) := by\n  refine ‚ü®(Complex.continuous_exp.comp\n    (continuous_const.mul (continuous_ofReal.pow 2))).aestronglyMeasurable, ?_‚ü©\n  rw [‚Üê hasFiniteIntegral_norm_iff]\n  simp_rw [norm_cexp_neg_mul_sq]\n  exact (integrable_exp_neg_mul_sq hb).2\n\n"}
{"name":"integrable_mul_cexp_neg_mul_sq","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"b : Complex\nhb : LT.lt 0 b.re\n‚ä¢ MeasureTheory.Integrable (fun x => HMul.hMul (‚Üëx) (Complex.exp (HMul.hMul (Neg.neg b) (HPow.hPow (‚Üëx) 2)))) MeasureTheory.MeasureSpace.volume","decl":"theorem integrable_mul_cexp_neg_mul_sq {b : ‚ÑÇ} (hb : 0 < b.re) :\n    Integrable fun x : ‚Ñù => ‚Üëx * cexp (-b * (x : ‚ÑÇ) ^ 2) := by\n  refine ‚ü®(continuous_ofReal.mul (Complex.continuous_exp.comp ?_)).aestronglyMeasurable, ?_‚ü©\n  ¬∑ exact continuous_const.mul (continuous_ofReal.pow 2)\n  have := (integrable_mul_exp_neg_mul_sq hb).hasFiniteIntegral\n  rw [‚Üê hasFiniteIntegral_norm_iff] at this ‚ä¢\n  convert this\n  rw [norm_mul, norm_mul, norm_cexp_neg_mul_sq b, Complex.norm_eq_abs, abs_ofReal, Real.norm_eq_abs,\n    norm_of_nonneg (exp_pos _).le]\n\n"}
{"name":"integral_mul_cexp_neg_mul_sq","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"b : Complex\nhb : LT.lt 0 b.re\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun r => HMul.hMul (‚Üër) (Complex.exp (HMul.hMul (Neg.neg b) (HPow.hPow (‚Üër) 2)))) (Inv.inv (HMul.hMul 2 b))","decl":"theorem integral_mul_cexp_neg_mul_sq {b : ‚ÑÇ} (hb : 0 < b.re) :\n    ‚à´ r : ‚Ñù in Ioi 0, (r : ‚ÑÇ) * cexp (-b * (r : ‚ÑÇ) ^ 2) = (2 * b)‚Åª¬π := by\n  have hb' : b ‚â† 0 := by contrapose! hb; rw [hb, zero_re]\n  have A : ‚àÄ x : ‚ÑÇ, HasDerivAt (fun x => -(2 * b)‚Åª¬π * cexp (-b * x ^ 2))\n    (x * cexp (-b * x ^ 2)) x := by\n    intro x\n    convert ((hasDerivAt_pow 2 x).const_mul (-b)).cexp.const_mul (-(2 * b)‚Åª¬π) using 1\n    field_simp [hb']\n    ring\n  have B : Tendsto (fun y : ‚Ñù ‚Ü¶ -(2 * b)‚Åª¬π * cexp (-b * (y : ‚ÑÇ) ^ 2))\n    atTop (ùìù (-(2 * b)‚Åª¬π * 0)) := by\n    refine Tendsto.const_mul _ (tendsto_zero_iff_norm_tendsto_zero.mpr ?_)\n    simp_rw [norm_cexp_neg_mul_sq b]\n    exact tendsto_exp_atBot.comp\n      ((tendsto_pow_atTop two_ne_zero).const_mul_atTop_of_neg (neg_lt_zero.2 hb))\n  convert integral_Ioi_of_hasDerivAt_of_tendsto' (fun x _ => (A ‚Üëx).comp_ofReal)\n    (integrable_mul_cexp_neg_mul_sq hb).integrableOn B using 1\n  simp only [mul_zero, ofReal_zero, zero_pow, Ne, Nat.one_ne_zero,\n    not_false_iff, Complex.exp_zero, mul_one, sub_neg_eq_add, zero_add, reduceCtorEq]\n\n"}
{"name":"integral_gaussian_sq_complex","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"b : Complex\nhb : LT.lt 0 b.re\n‚ä¢ Eq (HPow.hPow (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => Complex.exp (HMul.hMul (Neg.neg b) (HPow.hPow (‚Üëx) 2))) 2) (HDiv.hDiv (‚ÜëReal.pi) b)","decl":"/-- The *square* of the Gaussian integral `‚à´ x:‚Ñù, exp (-b * x^2)` is equal to `œÄ / b`. -/\ntheorem integral_gaussian_sq_complex {b : ‚ÑÇ} (hb : 0 < b.re) :\n    (‚à´ x : ‚Ñù, cexp (-b * (x : ‚ÑÇ) ^ 2)) ^ 2 = œÄ / b := by\n  /- We compute `(‚à´ exp (-b x^2))^2` as an integral over `‚Ñù^2`, and then make a polar change\n  of coordinates. We are left with `‚à´ r * exp (-b r^2)`, which has been computed in\n  `integral_mul_cexp_neg_mul_sq` using the fact that this function has an obvious primitive. -/\n  calc\n    (‚à´ x : ‚Ñù, cexp (-b * (x : ‚ÑÇ) ^ 2)) ^ 2 =\n        ‚à´ p : ‚Ñù √ó ‚Ñù, cexp (-b * (p.1 : ‚ÑÇ) ^ 2) * cexp (-b * (p.2 : ‚ÑÇ) ^ 2) := by\n      rw [pow_two, ‚Üê integral_prod_mul]; rfl\n    _ = ‚à´ p : ‚Ñù √ó ‚Ñù, cexp (-b * ((p.1 : ‚ÑÇ)^ 2 + (p.2 : ‚ÑÇ) ^ 2)) := by\n      congr\n      ext1 p\n      rw [‚Üê Complex.exp_add, mul_add]\n    _ = ‚à´ p in polarCoord.target, p.1 ‚Ä¢\n        cexp (-b * ((p.1 * Complex.cos p.2) ^ 2 + (p.1 * Complex.sin p.2) ^ 2)) := by\n      rw [‚Üê integral_comp_polarCoord_symm]\n      simp only [polarCoord_symm_apply, ofReal_mul, ofReal_cos, ofReal_sin]\n    _ = (‚à´ r in Ioi (0 : ‚Ñù), r * cexp (-b * (r : ‚ÑÇ) ^ 2)) * ‚à´ Œ∏ in Ioo (-œÄ) œÄ, 1 := by\n      rw [‚Üê setIntegral_prod_mul]\n      congr with p : 1\n      rw [mul_one]\n      congr\n      conv_rhs => rw [‚Üê one_mul ((p.1 : ‚ÑÇ) ^ 2), ‚Üê sin_sq_add_cos_sq (p.2 : ‚ÑÇ)]\n      ring\n    _ = ‚ÜëœÄ / b := by\n      have : 0 ‚â§ œÄ + œÄ := by positivity\n      simp only [integral_const, Measure.restrict_apply', measurableSet_Ioo, univ_inter, volume_Ioo,\n        sub_neg_eq_add, ENNReal.toReal_ofReal, this]\n      rw [‚Üê two_mul, real_smul, mul_one, ofReal_mul, ofReal_ofNat, integral_mul_cexp_neg_mul_sq hb]\n      field_simp [(by contrapose! hb; rw [hb, zero_re] : b ‚â† 0)]\n      ring\n\n"}
{"name":"integral_gaussian","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"b : Real\n‚ä¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => Real.exp (HMul.hMul (Neg.neg b) (HPow.hPow x 2))) (HDiv.hDiv Real.pi b).sqrt","decl":"theorem integral_gaussian (b : ‚Ñù) : ‚à´ x : ‚Ñù, exp (-b * x ^ 2) = ‚àö(œÄ / b) := by\n  -- First we deal with the crazy case where `b ‚â§ 0`: then both sides vanish.\n  rcases le_or_lt b 0 with (hb | hb)\n  ¬∑ rw [integral_undef, sqrt_eq_zero_of_nonpos]\n    ¬∑ exact div_nonpos_of_nonneg_of_nonpos pi_pos.le hb\n    ¬∑ simpa only [not_lt, integrable_exp_neg_mul_sq_iff] using hb\n  -- Assume now `b > 0`. Then both sides are non-negative and their squares agree.\n  refine (sq_eq_sq‚ÇÄ (by positivity) (by positivity)).1 ?_\n  rw [‚Üê ofReal_inj, ofReal_pow, ‚Üê coe_algebraMap, RCLike.algebraMap_eq_ofReal, ‚Üê integral_ofReal,\n    sq_sqrt (div_pos pi_pos hb).le, ‚Üê RCLike.algebraMap_eq_ofReal, coe_algebraMap, ofReal_div]\n  convert integral_gaussian_sq_complex (by rwa [ofReal_re] : 0 < (b : ‚ÑÇ).re) with _ x\n  rw [ofReal_exp, ofReal_mul, ofReal_pow, ofReal_neg]\n\n"}
{"name":"continuousAt_gaussian_integral","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"b : Complex\nhb : LT.lt 0 b.re\n‚ä¢ ContinuousAt (fun c => MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => Complex.exp (HMul.hMul (Neg.neg c) (HPow.hPow (‚Üëx) 2))) b","decl":"theorem continuousAt_gaussian_integral (b : ‚ÑÇ) (hb : 0 < re b) :\n    ContinuousAt (fun c : ‚ÑÇ => ‚à´ x : ‚Ñù, cexp (-c * (x : ‚ÑÇ) ^ 2)) b := by\n  let f : ‚ÑÇ ‚Üí ‚Ñù ‚Üí ‚ÑÇ := fun (c : ‚ÑÇ) (x : ‚Ñù) => cexp (-c * (x : ‚ÑÇ) ^ 2)\n  obtain ‚ü®d, hd, hd'‚ü© := exists_between hb\n  have f_meas : ‚àÄ c : ‚ÑÇ, AEStronglyMeasurable (f c) volume := fun c => by\n    apply Continuous.aestronglyMeasurable\n    exact Complex.continuous_exp.comp (continuous_const.mul (continuous_ofReal.pow 2))\n  have f_cts : ‚àÄ x : ‚Ñù, ContinuousAt (fun c => f c x) b := fun x =>\n    (Complex.continuous_exp.comp (continuous_id'.neg.mul continuous_const)).continuousAt\n  have f_le_bd : ‚àÄ·∂† c : ‚ÑÇ in ùìù b, ‚àÄ·µê x : ‚Ñù, ‚Äñf c x‚Äñ ‚â§ exp (-d * x ^ 2) := by\n    refine eventually_of_mem ((continuous_re.isOpen_preimage _ isOpen_Ioi).mem_nhds hd') ?_\n    intro c hc; filter_upwards with x\n    rw [norm_cexp_neg_mul_sq]\n    gcongr\n    exact le_of_lt hc\n  exact\n    continuousAt_of_dominated (Eventually.of_forall f_meas) f_le_bd (integrable_exp_neg_mul_sq hd)\n      (ae_of_all _ f_cts)\n\n"}
{"name":"integral_gaussian_complex","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"b : Complex\nhb : LT.lt 0 b.re\n‚ä¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => Complex.exp (HMul.hMul (Neg.neg b) (HPow.hPow (‚Üëx) 2))) (HPow.hPow (HDiv.hDiv (‚ÜëReal.pi) b) (1 / 2))","decl":"theorem integral_gaussian_complex {b : ‚ÑÇ} (hb : 0 < re b) :\n    ‚à´ x : ‚Ñù, cexp (-b * (x : ‚ÑÇ) ^ 2) = (œÄ / b) ^ (1 / 2 : ‚ÑÇ) := by\n  have nv : ‚àÄ {b : ‚ÑÇ}, 0 < re b ‚Üí b ‚â† 0 := by intro b hb; contrapose! hb; rw [hb]; simp\n  apply\n    (convex_halfSpace_re_gt 0).isPreconnected.eq_of_sq_eq ?_ ?_ (fun c hc => ?_) (fun {c} hc => ?_)\n      (by simp : 0 < re (1 : ‚ÑÇ)) ?_ hb\n  ¬∑ -- integral is continuous\n    exact continuousOn_of_forall_continuousAt continuousAt_gaussian_integral\n  ¬∑ -- `(œÄ / b) ^ (1 / 2 : ‚ÑÇ)` is continuous\n    refine\n      continuousOn_of_forall_continuousAt fun b hb =>\n        (continuousAt_cpow_const (Or.inl ?_)).comp (continuousAt_const.div continuousAt_id (nv hb))\n    rw [div_re, ofReal_im, ofReal_re, zero_mul, zero_div, add_zero]\n    exact div_pos (mul_pos pi_pos hb) (normSq_pos.mpr (nv hb))\n  ¬∑ -- equality at 1\n    have : ‚àÄ x : ‚Ñù, cexp (-(1 : ‚ÑÇ) * (x : ‚ÑÇ) ^ 2) = exp (-(1 : ‚Ñù) * x ^ 2) := by\n      intro x\n      simp only [ofReal_exp, neg_mul, one_mul, ofReal_neg, ofReal_pow]\n    simp_rw [this, ‚Üê coe_algebraMap, RCLike.algebraMap_eq_ofReal, integral_ofReal,\n      ‚Üê RCLike.algebraMap_eq_ofReal, coe_algebraMap]\n    conv_rhs =>\n      congr\n      ¬∑ rw [‚Üê ofReal_one, ‚Üê ofReal_div]\n      ¬∑ rw [‚Üê ofReal_one, ‚Üê ofReal_ofNat, ‚Üê ofReal_div]\n    rw [‚Üê ofReal_cpow, ofReal_inj]\n    ¬∑ convert integral_gaussian (1 : ‚Ñù) using 1\n      rw [sqrt_eq_rpow]\n    ¬∑ rw [div_one]; exact pi_pos.le\n  ¬∑ -- squares of both sides agree\n    dsimp only [Pi.pow_apply]\n    rw [integral_gaussian_sq_complex hc, sq]\n    conv_lhs => rw [‚Üê cpow_one (‚ÜëœÄ / c)]\n    rw [‚Üê cpow_add _ _ (div_ne_zero (ofReal_ne_zero.mpr pi_ne_zero) (nv hc))]\n    norm_num\n  ¬∑ -- RHS doesn't vanish\n    rw [Ne, cpow_eq_zero_iff, not_and_or]\n    exact Or.inl (div_ne_zero (ofReal_ne_zero.mpr pi_ne_zero) (nv hc))\n\n-- The Gaussian integral on the half-line, `‚à´ x in Ioi 0, exp (-b * x^2)`, for complex `b`.\n"}
{"name":"integral_gaussian_complex_Ioi","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"b : Complex\nhb : LT.lt 0 b.re\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun x => Complex.exp (HMul.hMul (Neg.neg b) (HPow.hPow (‚Üëx) 2))) (HDiv.hDiv (HPow.hPow (HDiv.hDiv (‚ÜëReal.pi) b) (1 / 2)) 2)","decl":"theorem integral_gaussian_complex_Ioi {b : ‚ÑÇ} (hb : 0 < re b) :\n    ‚à´ x : ‚Ñù in Ioi 0, cexp (-b * (x : ‚ÑÇ) ^ 2) = (œÄ / b) ^ (1 / 2 : ‚ÑÇ) / 2 := by\n  have full_integral := integral_gaussian_complex hb\n  have : MeasurableSet (Ioi (0 : ‚Ñù)) := measurableSet_Ioi\n  rw [‚Üê integral_add_compl this (integrable_cexp_neg_mul_sq hb), compl_Ioi] at full_integral\n  suffices ‚à´ x : ‚Ñù in Iic 0, cexp (-b * (x : ‚ÑÇ) ^ 2) = ‚à´ x : ‚Ñù in Ioi 0, cexp (-b * (x : ‚ÑÇ) ^ 2) by\n    rw [this, ‚Üê mul_two] at full_integral\n    rwa [eq_div_iff]; exact two_ne_zero\n  have : ‚àÄ c : ‚Ñù, ‚à´ x in (0 : ‚Ñù)..c, cexp (-b * (x : ‚ÑÇ) ^ 2) =\n      ‚à´ x in -c..0, cexp (-b * (x : ‚ÑÇ) ^ 2) := by\n    intro c\n    have := intervalIntegral.integral_comp_sub_left (a := 0) (b := c)\n      (fun x => cexp (-b * (x : ‚ÑÇ) ^ 2)) 0\n    simpa [zero_sub, neg_sq, neg_zero] using this\n  have t1 :=\n    intervalIntegral_tendsto_integral_Ioi 0 (integrable_cexp_neg_mul_sq hb).integrableOn tendsto_id\n  have t2 :\n    Tendsto (fun c : ‚Ñù => ‚à´ x : ‚Ñù in (0 : ‚Ñù)..c, cexp (-b * (x : ‚ÑÇ) ^ 2)) atTop\n      (ùìù (‚à´ x : ‚Ñù in Iic 0, cexp (-b * (x : ‚ÑÇ) ^ 2))) := by\n    simp_rw [this]\n    refine intervalIntegral_tendsto_integral_Iic _ ?_ tendsto_neg_atTop_atBot\n    apply (integrable_cexp_neg_mul_sq hb).integrableOn\n  exact tendsto_nhds_unique t2 t1\n\n-- The Gaussian integral on the half-line, `‚à´ x in Ioi 0, exp (-b * x^2)`, for real `b`.\n"}
{"name":"integral_gaussian_Ioi","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"b : Real\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun x => Real.exp (HMul.hMul (Neg.neg b) (HPow.hPow x 2))) (HDiv.hDiv (HDiv.hDiv Real.pi b).sqrt 2)","decl":"theorem integral_gaussian_Ioi (b : ‚Ñù) :\n    ‚à´ x in Ioi (0 : ‚Ñù), exp (-b * x ^ 2) = ‚àö(œÄ / b) / 2 := by\n  rcases le_or_lt b 0 with (hb | hb)\n  ¬∑ rw [integral_undef, sqrt_eq_zero_of_nonpos, zero_div]\n    ¬∑ exact div_nonpos_of_nonneg_of_nonpos pi_pos.le hb\n    ¬∑ rwa [‚Üê IntegrableOn, integrableOn_Ioi_exp_neg_mul_sq_iff, not_lt]\n  rw [‚Üê RCLike.ofReal_inj (K := ‚ÑÇ), ‚Üê integral_ofReal, ‚Üê RCLike.algebraMap_eq_ofReal,\n    coe_algebraMap]\n  convert integral_gaussian_complex_Ioi (by rwa [ofReal_re] : 0 < (b : ‚ÑÇ).re)\n  ¬∑ simp\n  ¬∑ rw [sqrt_eq_rpow, ‚Üê ofReal_div, ofReal_div, ofReal_cpow]\n    ¬∑ norm_num\n    ¬∑ exact (div_pos pi_pos hb).le\n\n"}
{"name":"Real.Gamma_one_half_eq","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"‚ä¢ Eq (Real.Gamma (1 / 2)) Real.pi.sqrt","decl":"/-- The special-value formula `Œì(1/2) = ‚àöœÄ`, which is equivalent to the Gaussian integral. -/\ntheorem Real.Gamma_one_half_eq : Real.Gamma (1 / 2) = ‚àöœÄ := by\n  rw [Gamma_eq_integral one_half_pos, ‚Üê integral_comp_rpow_Ioi_of_pos zero_lt_two]\n  convert congr_arg (fun x : ‚Ñù => 2 * x) (integral_gaussian_Ioi 1) using 1\n  ¬∑ rw [‚Üê integral_mul_left]\n    refine setIntegral_congr_fun measurableSet_Ioi fun x hx => ?_\n    dsimp only\n    have : (x ^ (2 : ‚Ñù)) ^ (1 / (2 : ‚Ñù) - 1) = x‚Åª¬π := by\n      rw [‚Üê rpow_mul (le_of_lt hx)]\n      norm_num\n      rw [rpow_neg (le_of_lt hx), rpow_one]\n    rw [smul_eq_mul, this]\n    field_simp [(ne_of_lt (show 0 < x from hx)).symm]\n    norm_num; ring\n  ¬∑ rw [div_one, ‚Üê mul_div_assoc, mul_comm, mul_div_cancel_right‚ÇÄ _ (two_ne_zero' ‚Ñù)]\n\n"}
{"name":"Complex.Gamma_one_half_eq","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"‚ä¢ Eq (Complex.Gamma (1 / 2)) (HPow.hPow (‚ÜëReal.pi) (1 / 2))","decl":"/-- The special-value formula `Œì(1/2) = ‚àöœÄ`, which is equivalent to the Gaussian integral. -/\ntheorem Complex.Gamma_one_half_eq : Complex.Gamma (1 / 2) = (œÄ : ‚ÑÇ) ^ (1 / 2 : ‚ÑÇ) := by\n  convert congr_arg ((‚Üë) : ‚Ñù ‚Üí ‚ÑÇ) Real.Gamma_one_half_eq\n  ¬∑ simpa only [one_div, ofReal_inv, ofReal_ofNat] using Gamma_ofReal (1 / 2)\n  ¬∑ rw [sqrt_eq_rpow, ofReal_cpow pi_pos.le, ofReal_div, ofReal_ofNat, ofReal_one]\n\n"}
{"name":"Real.Gamma_nat_add_one_add_half","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"k : Nat\n‚ä¢ Eq (Real.Gamma (HAdd.hAdd (HAdd.hAdd (‚Üëk) 1) (1 / 2))) (HDiv.hDiv (HMul.hMul (‚Üë(HAdd.hAdd (HMul.hMul 2 k) 1).doubleFactorial) Real.pi.sqrt) (HPow.hPow 2 (HAdd.hAdd k 1)))","decl":"open scoped Nat in\n/-- The special-value formula `Œì(k + 1 + 1/2) = (2 * k + 1)‚Äº * ‚àöœÄ / (2 ^ (k + 1))` for half-integer\nvalues of the gamma function in terms of `Nat.doubleFactorial`. -/\nlemma Real.Gamma_nat_add_one_add_half (k : ‚Ñï) :\n    Gamma (k + 1 + 1 / 2) = (2 * k + 1 : ‚Ñï)‚Äº * ‚àöœÄ / (2 ^ (k + 1)) := by\n  induction k with\n  | zero => simp [-one_div, add_comm (1 : ‚Ñù), Gamma_add_one, Gamma_one_half_eq]; ring\n  | succ k ih =>\n    rw [add_right_comm, Gamma_add_one (by positivity), Nat.cast_add, Nat.cast_one, ih, Nat.mul_add]\n    field_simp\n    ring\n\n"}
{"name":"Real.Gamma_nat_add_half","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral","initialProofState":"k : Nat\n‚ä¢ Eq (Real.Gamma (HAdd.hAdd (‚Üëk) (1 / 2))) (HDiv.hDiv (HMul.hMul (‚Üë(HSub.hSub (HMul.hMul 2 k) 1).doubleFactorial) Real.pi.sqrt) (HPow.hPow 2 k))","decl":"open scoped Nat in\n/-- The special-value formula `Œì(k + 1/2) = (2 * k - 1)‚Äº * ‚àöœÄ / (2 ^ k))` for half-integer\nvalues of the gamma function in terms of `Nat.doubleFactorial`. -/\nlemma Real.Gamma_nat_add_half (k : ‚Ñï) :\n    Gamma (k + 1 / 2) = (2 * k - 1 : ‚Ñï)‚Äº * ‚àöœÄ / (2 ^ k) := by\n  cases k with\n  | zero => simp [- one_div, Gamma_one_half_eq]\n  | succ k => simpa [-one_div, mul_add] using Gamma_nat_add_one_add_half k\n"}
