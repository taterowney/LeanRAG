{"name":"RieszExtension.step","module":"Mathlib.Analysis.Convex.Cone.Extension","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : ConvexCone Real E\nf : LinearPMap Real E Real\nnonneg : ∀ (x : Subtype fun x => Membership.mem f.domain x), Membership.mem s ↑x → LE.le 0 (↑f x)\ndense : ∀ (y : E), Exists fun x => Membership.mem s (HAdd.hAdd (↑x) y)\nhdom : Ne f.domain Top.top\n⊢ Exists fun g => And (LT.lt f g) (∀ (x : Subtype fun x => Membership.mem g.domain x), Membership.mem s ↑x → LE.le 0 (↑g x))","decl":"/-- Induction step in M. Riesz extension theorem. Given a convex cone `s` in a vector space `E`,\na partially defined linear map `f : f.domain → ℝ`, assume that `f` is nonnegative on `f.domain ∩ p`\nand `p + s = E`. If `f` is not defined on the whole `E`, then we can extend it to a larger\nsubmodule without breaking the non-negativity condition. -/\ntheorem step (nonneg : ∀ x : f.domain, (x : E) ∈ s → 0 ≤ f x)\n    (dense : ∀ y, ∃ x : f.domain, (x : E) + y ∈ s) (hdom : f.domain ≠ ⊤) :\n    ∃ g, f < g ∧ ∀ x : g.domain, (x : E) ∈ s → 0 ≤ g x := by\n  obtain ⟨y, -, hy⟩ : ∃ y ∈ ⊤, y ∉ f.domain := SetLike.exists_of_lt (lt_top_iff_ne_top.2 hdom)\n  obtain ⟨c, le_c, c_le⟩ :\n      ∃ c, (∀ x : f.domain, -(x : E) - y ∈ s → f x ≤ c) ∧\n        ∀ x : f.domain, (x : E) + y ∈ s → c ≤ f x := by\n    set Sp := f '' { x : f.domain | (x : E) + y ∈ s }\n    set Sn := f '' { x : f.domain | -(x : E) - y ∈ s }\n    suffices (upperBounds Sn ∩ lowerBounds Sp).Nonempty by\n      simpa only [Sp, Sn, Set.Nonempty, upperBounds, lowerBounds, forall_mem_image] using this\n    refine exists_between_of_forall_le (Nonempty.image f ?_) (Nonempty.image f (dense y)) ?_\n    · rcases dense (-y) with ⟨x, hx⟩\n      rw [← neg_neg x, NegMemClass.coe_neg, ← sub_eq_add_neg] at hx\n      exact ⟨_, hx⟩\n    rintro a ⟨xn, hxn, rfl⟩ b ⟨xp, hxp, rfl⟩\n    have := s.add_mem hxp hxn\n    rw [add_assoc, add_sub_cancel, ← sub_eq_add_neg, ← AddSubgroupClass.coe_sub] at this\n    replace := nonneg _ this\n    rwa [f.map_sub, sub_nonneg] at this\n  -- Porting note: removed an unused `have`\n  refine ⟨f.supSpanSingleton y (-c) hy, ?_, ?_⟩\n  · refine lt_iff_le_not_le.2 ⟨f.left_le_sup _ _, fun H => ?_⟩\n    replace H := LinearPMap.domain_mono.monotone H\n    rw [LinearPMap.domain_supSpanSingleton, sup_le_iff, span_le, singleton_subset_iff] at H\n    exact hy H.2\n  · rintro ⟨z, hz⟩ hzs\n    rcases mem_sup.1 hz with ⟨x, hx, y', hy', rfl⟩\n    rcases mem_span_singleton.1 hy' with ⟨r, rfl⟩\n    simp only [Subtype.coe_mk] at hzs\n    rw [LinearPMap.supSpanSingleton_apply_mk _ _ _ _ _ hx, smul_neg, ← sub_eq_add_neg, sub_nonneg]\n    rcases lt_trichotomy r 0 with (hr | hr | hr)\n    · have : -(r⁻¹ • x) - y ∈ s := by\n        rwa [← s.smul_mem_iff (neg_pos.2 hr), smul_sub, smul_neg, neg_smul, neg_neg, smul_smul,\n          mul_inv_cancel₀ hr.ne, one_smul, sub_eq_add_neg, neg_smul, neg_neg]\n      -- Porting note: added type annotation and `by exact`\n      replace : f (r⁻¹ • ⟨x, hx⟩) ≤ c := le_c (r⁻¹ • ⟨x, hx⟩) (by exact this)\n      rwa [← mul_le_mul_left (neg_pos.2 hr), neg_mul, neg_mul, neg_le_neg_iff, f.map_smul,\n        smul_eq_mul, ← mul_assoc, mul_inv_cancel₀ hr.ne, one_mul] at this\n    · subst r\n      simp only [zero_smul, add_zero] at hzs ⊢\n      apply nonneg\n      exact hzs\n    · have : r⁻¹ • x + y ∈ s := by\n        rwa [← s.smul_mem_iff hr, smul_add, smul_smul, mul_inv_cancel₀ hr.ne', one_smul]\n      -- Porting note: added type annotation and `by exact`\n      replace : c ≤ f (r⁻¹ • ⟨x, hx⟩) := c_le (r⁻¹ • ⟨x, hx⟩) (by exact this)\n      rwa [← mul_le_mul_left hr, f.map_smul, smul_eq_mul, ← mul_assoc, mul_inv_cancel₀ hr.ne',\n        one_mul] at this\n\n"}
{"name":"RieszExtension.exists_top","module":"Mathlib.Analysis.Convex.Cone.Extension","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : ConvexCone Real E\np : LinearPMap Real E Real\nhp_nonneg : ∀ (x : Subtype fun x => Membership.mem p.domain x), Membership.mem s ↑x → LE.le 0 (↑p x)\nhp_dense : ∀ (y : E), Exists fun x => Membership.mem s (HAdd.hAdd (↑x) y)\n⊢ Exists fun q => And (GE.ge q p) (And (Eq q.domain Top.top) (∀ (x : Subtype fun x => Membership.mem q.domain x), Membership.mem s ↑x → LE.le 0 (↑q x)))","decl":"theorem exists_top (p : E →ₗ.[ℝ] ℝ) (hp_nonneg : ∀ x : p.domain, (x : E) ∈ s → 0 ≤ p x)\n    (hp_dense : ∀ y, ∃ x : p.domain, (x : E) + y ∈ s) :\n    ∃ q ≥ p, q.domain = ⊤ ∧ ∀ x : q.domain, (x : E) ∈ s → 0 ≤ q x := by\n  set S := { p : E →ₗ.[ℝ] ℝ | ∀ x : p.domain, (x : E) ∈ s → 0 ≤ p x }\n  have hSc : ∀ c, c ⊆ S → IsChain (· ≤ ·) c → ∀ y ∈ c, ∃ ub ∈ S, ∀ z ∈ c, z ≤ ub := by\n    intro c hcs c_chain y hy\n    clear hp_nonneg hp_dense p\n    have cne : c.Nonempty := ⟨y, hy⟩\n    have hcd : DirectedOn (· ≤ ·) c := c_chain.directedOn\n    refine ⟨LinearPMap.sSup c hcd, ?_, fun _ ↦ LinearPMap.le_sSup hcd⟩\n    rintro ⟨x, hx⟩ hxs\n    have hdir : DirectedOn (· ≤ ·) (LinearPMap.domain '' c) :=\n      directedOn_image.2 (hcd.mono LinearPMap.domain_mono.monotone)\n    rcases (mem_sSup_of_directed (cne.image _) hdir).1 hx with ⟨_, ⟨f, hfc, rfl⟩, hfx⟩\n    have : f ≤ LinearPMap.sSup c hcd := LinearPMap.le_sSup _ hfc\n    convert ← hcs hfc ⟨x, hfx⟩ hxs using 1\n    exact this.2 rfl\n  obtain ⟨q, hpq, hqs, hq⟩ := zorn_le_nonempty₀ S hSc p hp_nonneg\n  refine ⟨q, hpq, ?_, hqs⟩\n  contrapose! hq\n  have hqd : ∀ y, ∃ x : q.domain, (x : E) + y ∈ s := fun y ↦\n    let ⟨x, hx⟩ := hp_dense y\n    ⟨Submodule.inclusion hpq.left x, hx⟩\n  rcases step s q hqs hqd hq with ⟨r, hqr, hr⟩\n  exact ⟨r, hr, hqr.le, fun hrq ↦ hqr.ne' <| hrq.antisymm hqr.le⟩\n\n"}
{"name":"riesz_extension","module":"Mathlib.Analysis.Convex.Cone.Extension","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : ConvexCone Real E\nf : LinearPMap Real E Real\nnonneg : ∀ (x : Subtype fun x => Membership.mem f.domain x), Membership.mem s ↑x → LE.le 0 (↑f x)\ndense : ∀ (y : E), Exists fun x => Membership.mem s (HAdd.hAdd (↑x) y)\n⊢ Exists fun g => And (∀ (x : Subtype fun x => Membership.mem f.domain x), Eq (g ↑x) (↑f x)) (∀ (x : E), Membership.mem s x → LE.le 0 (g x))","decl":"/-- M. **Riesz extension theorem**: given a convex cone `s` in a vector space `E`, a submodule `p`,\nand a linear `f : p → ℝ`, assume that `f` is nonnegative on `p ∩ s` and `p + s = E`. Then\nthere exists a globally defined linear function `g : E → ℝ` that agrees with `f` on `p`,\nand is nonnegative on `s`. -/\ntheorem riesz_extension (s : ConvexCone ℝ E) (f : E →ₗ.[ℝ] ℝ)\n    (nonneg : ∀ x : f.domain, (x : E) ∈ s → 0 ≤ f x)\n    (dense : ∀ y, ∃ x : f.domain, (x : E) + y ∈ s) :\n    ∃ g : E →ₗ[ℝ] ℝ, (∀ x : f.domain, g x = f x) ∧ ∀ x ∈ s, 0 ≤ g x := by\n  rcases RieszExtension.exists_top s f nonneg dense\n    with ⟨⟨g_dom, g⟩, ⟨-, hfg⟩, rfl : g_dom = ⊤, hgs⟩\n  refine ⟨g.comp (LinearMap.id.codRestrict ⊤ fun _ ↦ trivial), ?_, ?_⟩\n  · exact fun x => (hfg rfl).symm\n  · exact fun x hx => hgs ⟨x, _⟩ hx\n\n"}
{"name":"exists_extension_of_le_sublinear","module":"Mathlib.Analysis.Convex.Cone.Extension","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\nf : LinearPMap Real E Real\nN : E → Real\nN_hom : ∀ (c : Real), LT.lt 0 c → ∀ (x : E), Eq (N (HSMul.hSMul c x)) (HMul.hMul c (N x))\nN_add : ∀ (x y : E), LE.le (N (HAdd.hAdd x y)) (HAdd.hAdd (N x) (N y))\nhf : ∀ (x : Subtype fun x => Membership.mem f.domain x), LE.le (↑f x) (N ↑x)\n⊢ Exists fun g => And (∀ (x : Subtype fun x => Membership.mem f.domain x), Eq (g ↑x) (↑f x)) (∀ (x : E), LE.le (g x) (N x))","decl":"/-- **Hahn-Banach theorem**: if `N : E → ℝ` is a sublinear map, `f` is a linear map\ndefined on a subspace of `E`, and `f x ≤ N x` for all `x` in the domain of `f`,\nthen `f` can be extended to the whole space to a linear map `g` such that `g x ≤ N x`\nfor all `x`. -/\ntheorem exists_extension_of_le_sublinear (f : E →ₗ.[ℝ] ℝ) (N : E → ℝ)\n    (N_hom : ∀ c : ℝ, 0 < c → ∀ x, N (c • x) = c * N x) (N_add : ∀ x y, N (x + y) ≤ N x + N y)\n    (hf : ∀ x : f.domain, f x ≤ N x) :\n    ∃ g : E →ₗ[ℝ] ℝ, (∀ x : f.domain, g x = f x) ∧ ∀ x, g x ≤ N x := by\n  let s : ConvexCone ℝ (E × ℝ) :=\n    { carrier := { p : E × ℝ | N p.1 ≤ p.2 }\n      smul_mem' := fun c hc p hp =>\n        calc\n          N (c • p.1) = c * N p.1 := N_hom c hc p.1\n          _ ≤ c * p.2 := mul_le_mul_of_nonneg_left hp hc.le\n      add_mem' := fun x hx y hy => (N_add _ _).trans (add_le_add hx hy) }\n  set f' := (-f).coprod (LinearMap.id.toPMap ⊤)\n  have hf'_nonneg : ∀ x : f'.domain, x.1 ∈ s → 0 ≤ f' x := fun x (hx : N x.1.1 ≤ x.1.2) ↦ by\n    simpa [f'] using le_trans (hf ⟨x.1.1, x.2.1⟩) hx\n  have hf'_dense : ∀ y : E × ℝ, ∃ x : f'.domain, ↑x + y ∈ s := by\n    rintro ⟨x, y⟩\n    refine ⟨⟨(0, N x - y), ⟨f.domain.zero_mem, trivial⟩⟩, ?_⟩\n    simp only [s, ConvexCone.mem_mk, mem_setOf_eq, Prod.fst_add, Prod.snd_add, zero_add,\n      sub_add_cancel, le_rfl]\n  obtain ⟨g, g_eq, g_nonneg⟩ := riesz_extension s f' hf'_nonneg hf'_dense\n  replace g_eq : ∀ (x : f.domain) (y : ℝ), g (x, y) = y - f x := fun x y ↦\n    (g_eq ⟨(x, y), ⟨x.2, trivial⟩⟩).trans (sub_eq_neg_add _ _).symm\n  refine ⟨-g.comp (inl ℝ E ℝ), fun x ↦ ?_, fun x ↦ ?_⟩\n  · simp [g_eq x 0]\n  · calc -g (x, 0) = g (0, N x) - g (x, N x) := by simp [← map_sub, ← map_neg]\n      _ = N x - g (x, N x) := by simpa using g_eq 0 (N x)\n      _ ≤ N x := by simpa using g_nonneg ⟨x, N x⟩ (le_refl (N x))\n"}
