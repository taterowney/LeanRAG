{"name":"DilationEquivClass.edist_eq'","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"F : Type u_1\nX : outParam (Type u_2)\nY : outParam (Type u_3)\ninst✝² : PseudoEMetricSpace X\ninst✝¹ : PseudoEMetricSpace Y\ninst✝ : EquivLike F X Y\nself : DilationEquivClass F X Y\nf : F\n⊢ Exists fun r => And (Ne r 0) (∀ (x y : X), Eq (EDist.edist (f x) (f y)) (HMul.hMul (↑r) (EDist.edist x y)))","decl":"/-- Typeclass saying that `F` is a type of bundled equivalences such that all `e : F` are\ndilations. -/\nclass DilationEquivClass [EquivLike F X Y] : Prop where\n  edist_eq' : ∀ f : F, ∃ r : ℝ≥0, r ≠ 0 ∧ ∀ x y : X, edist (f x) (f y) = r * edist x y\n\n"}
{"name":"instDilationClassOfDilationEquivClass","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"F : Type u_1\nX : outParam (Type u_2)\nY : outParam (Type u_3)\ninst✝³ : PseudoEMetricSpace X\ninst✝² : PseudoEMetricSpace Y\ninst✝¹ : EquivLike F X Y\ninst✝ : DilationEquivClass F X Y\n⊢ DilationClass F X Y","decl":"instance (priority := 100) [EquivLike F X Y] [DilationEquivClass F X Y] : DilationClass F X Y :=\n  { inferInstanceAs (FunLike F X Y), ‹DilationEquivClass F X Y› with }\n\n"}
{"name":"DilationEquiv.mk.sizeOf_spec","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : PseudoEMetricSpace X\ninst✝² : PseudoEMetricSpace Y\ninst✝¹ : SizeOf X\ninst✝ : SizeOf Y\ntoEquiv : Equiv X Y\nedist_eq' : Exists fun r => And (Ne r 0) (∀ (x y : X), Eq (EDist.edist (toEquiv.toFun x) (toEquiv.toFun y)) (HMul.hMul (↑r) (EDist.edist x y)))\n⊢ Eq (SizeOf.sizeOf { toEquiv := toEquiv, edist_eq' := edist_eq' }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toEquiv)) (SizeOf.sizeOf edist_eq'))","decl":"/-- Type of equivalences `X ≃ Y` such that `∀ x y, edist (f x) (f y) = r * edist x y` for some\n`r : ℝ≥0`, `r ≠ 0`. -/\nstructure DilationEquiv (X Y : Type*) [PseudoEMetricSpace X] [PseudoEMetricSpace Y]\n    extends X ≃ Y, Dilation X Y\n\n"}
{"name":"DilationEquiv.edist_eq'","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\nself : DilationEquiv X Y\n⊢ Exists fun r => And (Ne r 0) (∀ (x y : X), Eq (EDist.edist (self.toFun x) (self.toFun y)) (HMul.hMul (↑r) (EDist.edist x y)))","decl":"/-- Type of equivalences `X ≃ Y` such that `∀ x y, edist (f x) (f y) = r * edist x y` for some\n`r : ℝ≥0`, `r ≠ 0`. -/\nstructure DilationEquiv (X Y : Type*) [PseudoEMetricSpace X] [PseudoEMetricSpace Y]\n    extends X ≃ Y, Dilation X Y\n\n"}
{"name":"DilationEquiv.mk.inj","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ntoEquiv✝ : Equiv X Y\nedist_eq'✝ : Exists fun r => And (Ne r 0) (∀ (x y : X), Eq (EDist.edist (toEquiv✝.toFun x) (toEquiv✝.toFun y)) (HMul.hMul (↑r) (EDist.edist x y)))\ntoEquiv : Equiv X Y\nedist_eq' : Exists fun r => And (Ne r 0) (∀ (x y : X), Eq (EDist.edist (toEquiv.toFun x) (toEquiv.toFun y)) (HMul.hMul (↑r) (EDist.edist x y)))\nx✝ : Eq { toEquiv := toEquiv✝, edist_eq' := edist_eq'✝ } { toEquiv := toEquiv, edist_eq' := edist_eq' }\n⊢ Eq toEquiv✝ toEquiv","decl":"/-- Type of equivalences `X ≃ Y` such that `∀ x y, edist (f x) (f y) = r * edist x y` for some\n`r : ℝ≥0`, `r ≠ 0`. -/\nstructure DilationEquiv (X Y : Type*) [PseudoEMetricSpace X] [PseudoEMetricSpace Y]\n    extends X ≃ Y, Dilation X Y\n\n"}
{"name":"DilationEquiv.mk.injEq","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ntoEquiv✝ : Equiv X Y\nedist_eq'✝ : Exists fun r => And (Ne r 0) (∀ (x y : X), Eq (EDist.edist (toEquiv✝.toFun x) (toEquiv✝.toFun y)) (HMul.hMul (↑r) (EDist.edist x y)))\ntoEquiv : Equiv X Y\nedist_eq' : Exists fun r => And (Ne r 0) (∀ (x y : X), Eq (EDist.edist (toEquiv.toFun x) (toEquiv.toFun y)) (HMul.hMul (↑r) (EDist.edist x y)))\n⊢ Eq (Eq { toEquiv := toEquiv✝, edist_eq' := edist_eq'✝ } { toEquiv := toEquiv, edist_eq' := edist_eq' }) (Eq toEquiv✝ toEquiv)","decl":"/-- Type of equivalences `X ≃ Y` such that `∀ x y, edist (f x) (f y) = r * edist x y` for some\n`r : ℝ≥0`, `r ≠ 0`. -/\nstructure DilationEquiv (X Y : Type*) [PseudoEMetricSpace X] [PseudoEMetricSpace Y]\n    extends X ≃ Y, Dilation X Y\n\n"}
{"name":"DilationEquiv.instDilationEquivClass","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\n⊢ DilationEquivClass (DilationEquiv X Y) X Y","decl":"instance : DilationEquivClass (X ≃ᵈ Y) X Y where\n  edist_eq' f := f.edist_eq'\n\n"}
{"name":"DilationEquiv.coe_toEquiv","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ne : DilationEquiv X Y\n⊢ Eq ⇑e.toEquiv ⇑e","decl":"@[simp] theorem coe_toEquiv (e : X ≃ᵈ Y) : ⇑e.toEquiv = e := rfl\n\n"}
{"name":"DilationEquiv.ext","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ne e' : DilationEquiv X Y\nh : ∀ (x : X), Eq (e x) (e' x)\n⊢ Eq e e'","decl":"@[ext]\nprotected theorem ext {e e' : X ≃ᵈ Y} (h : ∀ x, e x = e' x) : e = e' :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"DilationEquiv.ext_iff","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ne e' : DilationEquiv X Y\n⊢ Iff (Eq e e') (∀ (x : X), Eq (e x) (e' x))","decl":"@[ext]\nprotected theorem ext {e e' : X ≃ᵈ Y} (h : ∀ x, e x = e' x) : e = e' :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"DilationEquiv.symm_symm","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ne : DilationEquiv X Y\n⊢ Eq e.symm.symm e","decl":"@[simp] theorem symm_symm (e : X ≃ᵈ Y) : e.symm.symm = e := rfl\n\n"}
{"name":"DilationEquiv.symm_bijective","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\n⊢ Function.Bijective DilationEquiv.symm","decl":"theorem symm_bijective : Function.Bijective (DilationEquiv.symm : (X ≃ᵈ Y) → Y ≃ᵈ X) :=\n  Function.bijective_iff_has_inverse.mpr ⟨_, symm_symm, symm_symm⟩\n\n"}
{"name":"DilationEquiv.apply_symm_apply","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ne : DilationEquiv X Y\nx : Y\n⊢ Eq (e (e.symm x)) x","decl":"@[simp] theorem apply_symm_apply (e : X ≃ᵈ Y) (x : Y) : e (e.symm x) = x := e.right_inv x\n"}
{"name":"DilationEquiv.symm_apply_apply","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ne : DilationEquiv X Y\nx : X\n⊢ Eq (e.symm (e x)) x","decl":"@[simp] theorem symm_apply_apply (e : X ≃ᵈ Y) (x : X) : e.symm (e x) = x := e.left_inv x\n\n"}
{"name":"DilationEquiv.ratio_toDilation","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ne : DilationEquiv X Y\n⊢ Eq (Dilation.ratio e.toDilation) (Dilation.ratio e)","decl":"lemma ratio_toDilation (e : X ≃ᵈ Y) : ratio e.toDilation = ratio e := rfl\n\n"}
{"name":"DilationEquiv.refl_apply","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_4\ninst✝ : PseudoEMetricSpace X\n⊢ Eq (⇑(DilationEquiv.refl X)) id","decl":"/-- Identity map as a `DilationEquiv`. -/\n@[simps! (config := .asFn) apply]\ndef refl (X : Type*) [PseudoEMetricSpace X] : X ≃ᵈ X where\n  toEquiv := .refl X\n  edist_eq' := ⟨1, one_ne_zero, fun _ _ ↦ by simp⟩\n\n"}
{"name":"DilationEquiv.refl_symm","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\ninst✝ : PseudoEMetricSpace X\n⊢ Eq (DilationEquiv.refl X).symm (DilationEquiv.refl X)","decl":"@[simp] theorem refl_symm : (refl X).symm = refl X := rfl\n"}
{"name":"DilationEquiv.ratio_refl","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\ninst✝ : PseudoEMetricSpace X\n⊢ Eq (Dilation.ratio (DilationEquiv.refl X)) 1","decl":"@[simp] theorem ratio_refl : ratio (refl X) = 1 := Dilation.ratio_id\n\n"}
{"name":"DilationEquiv.trans_apply","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst✝² : PseudoEMetricSpace X\ninst✝¹ : PseudoEMetricSpace Y\ninst✝ : PseudoEMetricSpace Z\ne₁ : DilationEquiv X Y\ne₂ : DilationEquiv Y Z\n⊢ Eq (⇑(e₁.trans e₂)) (Function.comp ⇑e₂ ⇑e₁)","decl":"/-- Composition of `DilationEquiv`s. -/\n@[simps! (config := .asFn) apply]\ndef trans (e₁ : X ≃ᵈ Y) (e₂ : Y ≃ᵈ Z) : X ≃ᵈ Z where\n  toEquiv := e₁.1.trans e₂.1\n  __ := e₂.toDilation.comp e₁.toDilation\n\n"}
{"name":"DilationEquiv.refl_trans","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ne : DilationEquiv X Y\n⊢ Eq ((DilationEquiv.refl X).trans e) e","decl":"@[simp] theorem refl_trans (e : X ≃ᵈ Y) : (refl X).trans e = e := rfl\n"}
{"name":"DilationEquiv.trans_refl","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ne : DilationEquiv X Y\n⊢ Eq (e.trans (DilationEquiv.refl Y)) e","decl":"@[simp] theorem trans_refl (e : X ≃ᵈ Y) : e.trans (refl Y) = e := rfl\n\n"}
{"name":"DilationEquiv.symm_trans_self","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ne : DilationEquiv X Y\n⊢ Eq (e.symm.trans e) (DilationEquiv.refl Y)","decl":"@[simp] theorem symm_trans_self (e : X ≃ᵈ Y) : e.symm.trans e = refl Y :=\n  DilationEquiv.ext e.apply_symm_apply\n\n"}
{"name":"DilationEquiv.self_trans_symm","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ne : DilationEquiv X Y\n⊢ Eq (e.trans e.symm) (DilationEquiv.refl X)","decl":"@[simp] theorem self_trans_symm (e : X ≃ᵈ Y) : e.trans e.symm = refl X :=\n  DilationEquiv.ext e.symm_apply_apply\n\n"}
{"name":"DilationEquiv.surjective","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ne : DilationEquiv X Y\n⊢ Function.Surjective ⇑e","decl":"protected theorem surjective (e : X ≃ᵈ Y) : Surjective e := e.1.surjective\n"}
{"name":"DilationEquiv.bijective","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ne : DilationEquiv X Y\n⊢ Function.Bijective ⇑e","decl":"protected theorem bijective (e : X ≃ᵈ Y) : Bijective e := e.1.bijective\n"}
{"name":"DilationEquiv.injective","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ne : DilationEquiv X Y\n⊢ Function.Injective ⇑e","decl":"protected theorem injective (e : X ≃ᵈ Y) : Injective e := e.1.injective\n\n"}
{"name":"DilationEquiv.ratio_trans","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst✝² : PseudoEMetricSpace X\ninst✝¹ : PseudoEMetricSpace Y\ninst✝ : PseudoEMetricSpace Z\ne : DilationEquiv X Y\ne' : DilationEquiv Y Z\n⊢ Eq (Dilation.ratio (e.trans e')) (HMul.hMul (Dilation.ratio e) (Dilation.ratio e'))","decl":"@[simp]\ntheorem ratio_trans (e : X ≃ᵈ Y) (e' : Y ≃ᵈ Z) : ratio (e.trans e') = ratio e * ratio e' := by\n  -- If `X` is trivial, then so is `Y`, otherwise we apply `Dilation.ratio_comp'`\n  by_cases hX : ∀ x y : X, edist x y = 0 ∨ edist x y = ∞\n  · have hY : ∀ x y : Y, edist x y = 0 ∨ edist x y = ∞ := e.surjective.forall₂.2 fun x y ↦ by\n      refine (hX x y).imp (fun h ↦ ?_) fun h ↦ ?_ <;> simp [*, Dilation.ratio_ne_zero]\n    simp [Dilation.ratio_of_trivial, *]\n  push_neg at hX\n  exact (Dilation.ratio_comp' (g := e'.toDilation) (f := e.toDilation) hX).trans (mul_comm _ _)\n\n"}
{"name":"DilationEquiv.ratio_symm","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ne : DilationEquiv X Y\n⊢ Eq (Dilation.ratio e.symm) (Inv.inv (Dilation.ratio e))","decl":"@[simp]\ntheorem ratio_symm (e : X ≃ᵈ Y) : ratio e.symm = (ratio e)⁻¹ :=\n  eq_inv_of_mul_eq_one_left <| by rw [← ratio_trans, symm_trans_self, ratio_refl]\n\n"}
{"name":"DilationEquiv.mul_def","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\ninst✝ : PseudoEMetricSpace X\ne e' : DilationEquiv X X\n⊢ Eq (HMul.hMul e e') (e'.trans e)","decl":"theorem mul_def (e e' : X ≃ᵈ X) : e * e' = e'.trans e := rfl\n"}
{"name":"DilationEquiv.one_def","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\ninst✝ : PseudoEMetricSpace X\n⊢ Eq 1 (DilationEquiv.refl X)","decl":"theorem one_def : (1 : X ≃ᵈ X) = refl X := rfl\n"}
{"name":"DilationEquiv.inv_def","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\ninst✝ : PseudoEMetricSpace X\ne : DilationEquiv X X\n⊢ Eq (Inv.inv e) e.symm","decl":"theorem inv_def (e : X ≃ᵈ X) : e⁻¹ = e.symm := rfl\n\n"}
{"name":"DilationEquiv.coe_mul","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\ninst✝ : PseudoEMetricSpace X\ne e' : DilationEquiv X X\n⊢ Eq (⇑(HMul.hMul e e')) (Function.comp ⇑e ⇑e')","decl":"@[simp] theorem coe_mul (e e' : X ≃ᵈ X) : ⇑(e * e') = e ∘ e' := rfl\n"}
{"name":"DilationEquiv.coe_one","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\ninst✝ : PseudoEMetricSpace X\n⊢ Eq (⇑1) id","decl":"@[simp] theorem coe_one : ⇑(1 : X ≃ᵈ X) = id := rfl\n"}
{"name":"DilationEquiv.coe_inv","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\ninst✝ : PseudoEMetricSpace X\ne : DilationEquiv X X\n⊢ Eq ⇑(Inv.inv e) ⇑e.symm","decl":"theorem coe_inv (e : X ≃ᵈ X) : ⇑(e⁻¹) = e.symm := rfl\n\n"}
{"name":"DilationEquiv.ratio_inv","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\ninst✝ : PseudoEMetricSpace X\ne : DilationEquiv X X\n⊢ Eq (Dilation.ratio (Inv.inv e)) (Inv.inv (Dilation.ratio e))","decl":"@[simp]\ntheorem ratio_inv (e : X ≃ᵈ X) : ratio (e⁻¹) = (ratio e)⁻¹ := ratio_symm e\n\n"}
{"name":"DilationEquiv.ratio_pow","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\ninst✝ : PseudoEMetricSpace X\ne : DilationEquiv X X\nn : Nat\n⊢ Eq (Dilation.ratio (HPow.hPow e n)) (HPow.hPow (Dilation.ratio e) n)","decl":"@[simp]\ntheorem ratio_pow (e : X ≃ᵈ X) (n : ℕ) : ratio (e ^ n) = ratio e ^ n :=\n  ratioHom.map_pow _ _\n\n"}
{"name":"DilationEquiv.ratio_zpow","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\ninst✝ : PseudoEMetricSpace X\ne : DilationEquiv X X\nn : Int\n⊢ Eq (Dilation.ratio (HPow.hPow e n)) (HPow.hPow (Dilation.ratio e) n)","decl":"@[simp]\ntheorem ratio_zpow (e : X ≃ᵈ X) (n : ℤ) : ratio (e ^ n) = ratio e ^ n :=\n  ratioHom.map_zpow _ _\n\n"}
{"name":"DilationEquiv.toPerm_apply","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\ninst✝ : PseudoEMetricSpace X\ne : DilationEquiv X X\n⊢ Eq (DilationEquiv.toPerm e) e.toEquiv","decl":"/-- `DilationEquiv.toEquiv` as a monoid homomorphism. -/\n@[simps]\ndef toPerm : (X ≃ᵈ X) →* Equiv.Perm X where\n  toFun e := e.1\n  map_mul' _ _ := rfl\n  map_one' := rfl\n\n"}
{"name":"DilationEquiv.coe_pow","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\ninst✝ : PseudoEMetricSpace X\ne : DilationEquiv X X\nn : Nat\n⊢ Eq (⇑(HPow.hPow e n)) (Nat.iterate (⇑e) n)","decl":"@[norm_cast]\ntheorem coe_pow (e : X ≃ᵈ X) (n : ℕ) : ⇑(e ^ n) = e^[n] := by\n  rw [← coe_toEquiv, ← toPerm_apply, map_pow, Equiv.Perm.coe_pow]; rfl\n\n-- TODO: Once `IsometryEquiv` follows the `*EquivClass` pattern, replace this with an instance\n-- of `DilationEquivClass` assuming `IsometryEquivClass`.\n"}
{"name":"IsometryEquiv.toDilationEquiv_apply","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ne : IsometryEquiv X Y\nx : X\n⊢ Eq (e.toDilationEquiv x) (e x)","decl":"@[simp]\nlemma _root_.IsometryEquiv.toDilationEquiv_apply (e : X ≃ᵢ Y) (x : X) :\n    e.toDilationEquiv x = e x :=\n  rfl\n\n"}
{"name":"IsometryEquiv.toDilationEquiv_symm","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ne : IsometryEquiv X Y\n⊢ Eq e.toDilationEquiv.symm e.symm.toDilationEquiv","decl":"@[simp]\nlemma _root_.IsometryEquiv.toDilationEquiv_symm (e : X ≃ᵢ Y) :\n    e.toDilationEquiv.symm = e.symm.toDilationEquiv :=\n  rfl\n\n"}
{"name":"IsometryEquiv.toDilationEquiv_toDilation","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ne : IsometryEquiv X Y\n⊢ Eq e.toDilationEquiv.toDilation (Isometry.toDilation ⇑e ⋯)","decl":"@[simp]\nlemma _root_.IsometryEquiv.toDilationEquiv_toDilation (e : X ≃ᵢ Y) :\n    (e.toDilationEquiv.toDilation : X →ᵈ Y) = e.isometry.toDilation :=\n  rfl\n\n"}
{"name":"IsometryEquiv.toDilationEquiv_ratio","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ne : IsometryEquiv X Y\n⊢ Eq (Dilation.ratio e.toDilationEquiv) 1","decl":"@[simp]\nlemma _root_.IsometryEquiv.toDilationEquiv_ratio (e : X ≃ᵢ Y) : ratio e.toDilationEquiv = 1 := by\n  rw [← ratio_toDilation, IsometryEquiv.toDilationEquiv_toDilation, Isometry.toDilation_ratio]\n\n"}
{"name":"DilationEquiv.coe_toHomeomorph","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ne : DilationEquiv X Y\n⊢ Eq ⇑e.toHomeomorph ⇑e","decl":"@[simp]\nlemma coe_toHomeomorph (e : X ≃ᵈ Y) : ⇑e.toHomeomorph = e :=\n  rfl\n\n"}
{"name":"DilationEquiv.toHomeomorph_symm","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\ne : DilationEquiv X Y\n⊢ Eq e.toHomeomorph.symm e.symm.toHomeomorph","decl":"@[simp]\nlemma toHomeomorph_symm (e : X ≃ᵈ Y) : e.toHomeomorph.symm = e.symm.toHomeomorph :=\n  rfl\n\n"}
{"name":"DilationEquiv.map_cobounded","module":"Mathlib.Topology.MetricSpace.DilationEquiv","initialProofState":"X : Type u_1\nY : Type u_2\nF : Type u_3\ninst✝³ : PseudoMetricSpace X\ninst✝² : PseudoMetricSpace Y\ninst✝¹ : EquivLike F X Y\ninst✝ : DilationEquivClass F X Y\ne : F\n⊢ Eq (Filter.map (⇑e) (Bornology.cobounded X)) (Bornology.cobounded Y)","decl":"@[simp]\nlemma map_cobounded (e : F) : map e (cobounded X) = cobounded Y := by\n  rw [← Dilation.comap_cobounded e, map_comap_of_surjective (EquivLike.surjective e)]\n\n"}
