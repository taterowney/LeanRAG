{"name":"Algebra.FormallySmooth.of_pi","module":"Mathlib.RingTheory.Smooth.Pi","initialProofState":"R : Type (max u v)\nI : Type u\nA : I → Type (max u v)\ninst✝³ : CommRing R\ninst✝² : (i : I) → CommRing (A i)\ninst✝¹ : (i : I) → Algebra R (A i)\ninst✝ : Algebra.FormallySmooth R ((i : I) → A i)\ni : I\n⊢ Algebra.FormallySmooth R (A i)","decl":"theorem of_pi [FormallySmooth R (Π i, A i)] (i) :\n    FormallySmooth R (A i) := by\n  classical\n  fapply FormallySmooth.of_split (Pi.evalAlgHom R A i)\n  · apply AlgHom.ofLinearMap\n      ((Ideal.Quotient.mkₐ R _).toLinearMap.comp (LinearMap.single _ _ i))\n    · show Ideal.Quotient.mk _ (Pi.single i 1) = 1\n      rw [← (Ideal.Quotient.mk _).map_one, ← sub_eq_zero, ← map_sub,\n        Ideal.Quotient.eq_zero_iff_mem]\n      have : Pi.single i 1 - 1 ∈ RingHom.ker (Pi.evalAlgHom R A i).toRingHom := by\n        simp [RingHom.mem_ker]\n      convert neg_mem (Ideal.pow_mem_pow this 2) using 1\n      simp [pow_two, sub_mul, mul_sub, ← Pi.single_mul]\n    · intro x y\n      show Ideal.Quotient.mk _ _ = Ideal.Quotient.mk _ _ * Ideal.Quotient.mk _ _\n      simp only [AlgHom.toRingHom_eq_coe, LinearMap.coe_single, Pi.single_mul, map_mul]\n  · ext x\n    show (Pi.single i x) i = x\n    simp\n\n"}
{"name":"Algebra.FormallySmooth.pi_iff","module":"Mathlib.RingTheory.Smooth.Pi","initialProofState":"R : Type (max u v)\nI : Type u\nA : I → Type (max u v)\ninst✝³ : CommRing R\ninst✝² : (i : I) → CommRing (A i)\ninst✝¹ : (i : I) → Algebra R (A i)\ninst✝ : Finite I\n⊢ Iff (Algebra.FormallySmooth R ((i : I) → A i)) (∀ (i : I), Algebra.FormallySmooth R (A i))","decl":"theorem pi_iff [Finite I] :\n    FormallySmooth R (Π i, A i) ↔ ∀ i, FormallySmooth R (A i) := by\n  classical\n  cases nonempty_fintype I\n  constructor\n  · exact fun _ ↦ of_pi A\n  · intro H\n    constructor\n    intros B _ _ J hJ g\n    have hJ' (x) (hx : x ∈ RingHom.ker (Ideal.Quotient.mk J)) : IsNilpotent x := by\n      refine ⟨2, show x ^ 2 ∈ (⊥ : Ideal B) from ?_⟩\n      rw [← hJ]\n      exact Ideal.pow_mem_pow (by simpa using hx) 2\n    obtain ⟨e, he, he'⟩ := ((CompleteOrthogonalIdempotents.single A).map\n      g.toRingHom).lift_of_isNilpotent_ker (Ideal.Quotient.mk J) hJ'\n        fun _ ↦ Ideal.Quotient.mk_surjective _\n    replace he' : ∀ i, Ideal.Quotient.mk J (e i) = g (Pi.single i 1) := congr_fun he'\n    let iso : B ≃ₐ[R] ∀ i, B ⧸ Ideal.span {1 - e i} :=\n      { __ := Pi.algHom _ _ fun i ↦ Ideal.Quotient.mkₐ R _\n        __ := Equiv.ofBijective _ he.bijective_pi }\n    let J' := fun i ↦ J.map (Ideal.Quotient.mk (Ideal.span {1 - e i}))\n    let ι : ∀ i, (B ⧸ J →ₐ[R] (B ⧸ _) ⧸ J' i) := fun i ↦ Ideal.quotientMapₐ _\n      (IsScalarTower.toAlgHom R B _) Ideal.le_comap_map\n    have hι : ∀ i x, ι i x = 0 → (e i) * x = 0 := by\n      intros i x hix\n      have : x ∈ (Ideal.span {1 - e i}).map (Ideal.Quotient.mk J) := by\n        rw [← Ideal.ker_quotientMap_mk]; exact hix\n      rw [Ideal.map_span, Set.image_singleton, Ideal.mem_span_singleton] at this\n      obtain ⟨c, rfl⟩ := this\n      rw [← mul_assoc, ← map_mul, mul_sub, mul_one, (he.idem i).eq, sub_self, map_zero, zero_mul]\n    have : ∀ i : I, ∃ a : A i →ₐ[R] B ⧸ Ideal.span {1 - e i}, ∀ x,\n        Ideal.Quotient.mk (J' i) (a x) = ι i (g (Pi.single i x)) := by\n      intro i\n      let g' : A i →ₐ[R] (B ⧸ _) ⧸ (J' i) := by\n        apply AlgHom.ofLinearMap (((ι i).comp g).toLinearMap ∘ₗ LinearMap.single _ _ i)\n        · suffices Ideal.Quotient.mk (Ideal.span {1 - e i}) (e i) = 1 by simp [ι, ← he', this]\n          rw [← (Ideal.Quotient.mk _).map_one, eq_comm, Ideal.Quotient.mk_eq_mk_iff_sub_mem,\n            Ideal.mem_span_singleton]\n        · intros x y; simp [Pi.single_mul]\n      obtain ⟨a, ha⟩ := FormallySmooth.comp_surjective (I := J' i)\n        (by rw [← Ideal.map_pow, hJ, Ideal.map_bot]) g'\n      exact ⟨a, AlgHom.congr_fun ha⟩\n    choose a ha using this\n    use iso.symm.toAlgHom.comp (Pi.algHom _ _ fun i ↦ (a i).comp (Pi.evalAlgHom R A i))\n    ext x; rw [← AlgHom.toLinearMap_apply, ← AlgHom.toLinearMap_apply]; congr 1\n    ext i x\n    simp only [AlgEquiv.toAlgHom_eq_coe, AlgHom.comp_toLinearMap, AlgEquiv.toAlgHom_toLinearMap,\n      LinearMap.coe_comp, LinearMap.coe_single, Function.comp_apply, AlgHom.toLinearMap_apply,\n      AlgEquiv.toLinearMap_apply, Ideal.Quotient.mkₐ_eq_mk]\n    obtain ⟨y, hy⟩ := Ideal.Quotient.mk_surjective (a i x)\n    have hy' : Ideal.Quotient.mk (Ideal.span {1 - e i}) (y * e i) = a i x := by\n      have : Ideal.Quotient.mk (Ideal.span {1 - e i}) (e i) = 1 := by\n        rw [← (Ideal.Quotient.mk _).map_one, eq_comm, Ideal.Quotient.mk_eq_mk_iff_sub_mem,\n          Ideal.mem_span_singleton]\n      rw [map_mul, this, hy, mul_one]\n    trans Ideal.Quotient.mk J (y * e i)\n    · congr 1; apply iso.injective; ext j\n      suffices a j (Pi.single i x j) = Ideal.Quotient.mk _ (y * e i) by simpa using this\n      by_cases hij : i = j\n      · subst hij\n        rw [Pi.single_eq_same, hy']\n      · have : Ideal.Quotient.mk (Ideal.span {1 - e j}) (e i) = 0 := by\n          rw [Ideal.Quotient.eq_zero_iff_mem, Ideal.mem_span_singleton]\n          refine ⟨e i, by simp [he.ortho (Ne.symm hij), sub_mul]⟩\n        rw [Pi.single_eq_of_ne (Ne.symm hij), map_zero, map_mul, this, mul_zero]\n    · have : ι i (Ideal.Quotient.mk J (y * e i)) = ι i (g (Pi.single i x)) := by\n        rw [← ha, ← hy']\n        simp only [Ideal.quotient_map_mkₐ, IsScalarTower.coe_toAlgHom',\n          Ideal.Quotient.algebraMap_eq, Ideal.Quotient.mkₐ_eq_mk, ι]\n      rw [← sub_eq_zero, ← map_sub] at this\n      replace this := hι _ _ this\n      rwa [mul_sub, ← map_mul, mul_comm, mul_assoc, (he.idem i).eq, he', ← map_mul, ← Pi.single_mul,\n        one_mul, sub_eq_zero] at this\n\n"}
{"name":"Algebra.FormallySmooth.instForallOfFinite","module":"Mathlib.RingTheory.Smooth.Pi","initialProofState":"R : Type (max u v)\nI : Type u\nA : I → Type (max u v)\ninst✝⁴ : CommRing R\ninst✝³ : (i : I) → CommRing (A i)\ninst✝² : (i : I) → Algebra R (A i)\ninst✝¹ : Finite I\ninst✝ : ∀ (i : I), Algebra.FormallySmooth R (A i)\n⊢ Algebra.FormallySmooth R ((i : I) → A i)","decl":"instance [Finite I] [∀ i, FormallySmooth R (A i)] : FormallySmooth R (Π i, A i) :=\n  (pi_iff _).mpr ‹_›\n\n"}
