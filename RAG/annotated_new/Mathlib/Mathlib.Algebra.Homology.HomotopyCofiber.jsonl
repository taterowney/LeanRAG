{"name":"HomologicalComplex.HasHomotopyCofiber.hasBinaryBiproduct","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\nself : HomologicalComplex.HasHomotopyCofiber φ\ni j : ι\nhij : c.Rel i j\n⊢ CategoryTheory.Limits.HasBinaryBiproduct (F.X j) (G.X i)","decl":"/-- A morphism of homological complexes `φ : F ⟶ G` has a homotopy cofiber if for all\nindices `i` and `j` such that `c.Rel i j`, the binary biproduct `F.X j ⊞ G.X i` exists. -/\nclass HasHomotopyCofiber (φ : F ⟶ G) : Prop where\n  hasBinaryBiproduct (i j : ι) (hij : c.Rel i j) : HasBinaryBiproduct (F.X j) (G.X i)\n\n"}
{"name":"HomologicalComplex.instHasHomotopyCofiberOfHasBinaryBiproducts","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\n⊢ HomologicalComplex.HasHomotopyCofiber φ","decl":"instance [HasBinaryBiproducts C] : HasHomotopyCofiber φ where\n  hasBinaryBiproduct _ _ _ := inferInstance\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrX_sndX","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX φ i) (HomologicalComplex.homotopyCofiber.sndX φ i)) (CategoryTheory.CategoryStruct.id (G.X i))","decl":"@[reassoc (attr := simp)]\nlemma inrX_sndX (i : ι) : inrX φ i ≫ sndX φ i = 𝟙 _ := by\n  dsimp [sndX, inrX]\n  split_ifs with hi <;> simp\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrX_sndX_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni : ι\nZ : C\nh : Quiver.Hom (G.X i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX φ i) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.sndX φ i) h)) h","decl":"@[reassoc (attr := simp)]\nlemma inrX_sndX (i : ι) : inrX φ i ≫ sndX φ i = 𝟙 _ := by\n  dsimp [sndX, inrX]\n  split_ifs with hi <;> simp\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.sndX_inrX_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni : ι\nhi : Not (c.Rel i (c.next i))\nZ : C\nh : Quiver.Hom (HomologicalComplex.homotopyCofiber.X φ i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.sndX φ i) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX φ i) h)) h","decl":"@[reassoc]\nlemma sndX_inrX (i : ι) (hi : ¬ c.Rel i (c.next i)) :\n    sndX φ i ≫ inrX φ i = 𝟙 _ := by\n  dsimp [sndX, inrX]\n  simp only [dif_neg hi, Iso.hom_inv_id]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.sndX_inrX","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni : ι\nhi : Not (c.Rel i (c.next i))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.sndX φ i) (HomologicalComplex.homotopyCofiber.inrX φ i)) (CategoryTheory.CategoryStruct.id (HomologicalComplex.homotopyCofiber.X φ i))","decl":"@[reassoc]\nlemma sndX_inrX (i : ι) (hi : ¬ c.Rel i (c.next i)) :\n    sndX φ i ≫ inrX φ i = 𝟙 _ := by\n  dsimp [sndX, inrX]\n  simp only [dif_neg hi, Iso.hom_inv_id]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inlX_fstX_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni j : ι\nhij : c.Rel j i\nZ : C\nh : Quiver.Hom (F.X i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX φ i j hij) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.fstX φ j i hij) h)) h","decl":"@[reassoc (attr := simp)]\nlemma inlX_fstX (i j : ι ) (hij : c.Rel j i) :\n    inlX φ i j hij ≫ fstX φ j i hij = 𝟙 _ := by\n  simp [inlX, fstX]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inlX_fstX","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni j : ι\nhij : c.Rel j i\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX φ i j hij) (HomologicalComplex.homotopyCofiber.fstX φ j i hij)) (CategoryTheory.CategoryStruct.id (F.X i))","decl":"@[reassoc (attr := simp)]\nlemma inlX_fstX (i j : ι ) (hij : c.Rel j i) :\n    inlX φ i j hij ≫ fstX φ j i hij = 𝟙 _ := by\n  simp [inlX, fstX]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inlX_sndX","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni j : ι\nhij : c.Rel j i\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX φ i j hij) (HomologicalComplex.homotopyCofiber.sndX φ j)) 0","decl":"@[reassoc (attr := simp)]\nlemma inlX_sndX (i j : ι) (hij : c.Rel j i) :\n    inlX φ i j hij ≫ sndX φ j = 0 := by\n  obtain rfl := c.next_eq' hij\n  simp [inlX, sndX, dif_pos hij]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inlX_sndX_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni j : ι\nhij : c.Rel j i\nZ : C\nh : Quiver.Hom (G.X j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX φ i j hij) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.sndX φ j) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma inlX_sndX (i j : ι) (hij : c.Rel j i) :\n    inlX φ i j hij ≫ sndX φ j = 0 := by\n  obtain rfl := c.next_eq' hij\n  simp [inlX, sndX, dif_pos hij]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrX_fstX_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni j : ι\nhij : c.Rel i j\nZ : C\nh : Quiver.Hom (F.X j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX φ i) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.fstX φ i j hij) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma inrX_fstX (i j : ι) (hij : c.Rel i j) :\n    inrX φ i ≫ fstX φ i j hij = 0 := by\n  obtain rfl := c.next_eq' hij\n  simp [inrX, fstX, dif_pos hij]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrX_fstX","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni j : ι\nhij : c.Rel i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX φ i) (HomologicalComplex.homotopyCofiber.fstX φ i j hij)) 0","decl":"@[reassoc (attr := simp)]\nlemma inrX_fstX (i j : ι) (hij : c.Rel i j) :\n    inrX φ i ≫ fstX φ i j hij = 0 := by\n  obtain rfl := c.next_eq' hij\n  simp [inrX, fstX, dif_pos hij]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.ext_to_X","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni j : ι\nhij : c.Rel i j\nA : C\nf g : Quiver.Hom A (HomologicalComplex.homotopyCofiber.X φ i)\nh₁ : Eq (CategoryTheory.CategoryStruct.comp f (HomologicalComplex.homotopyCofiber.fstX φ i j hij)) (CategoryTheory.CategoryStruct.comp g (HomologicalComplex.homotopyCofiber.fstX φ i j hij))\nh₂ : Eq (CategoryTheory.CategoryStruct.comp f (HomologicalComplex.homotopyCofiber.sndX φ i)) (CategoryTheory.CategoryStruct.comp g (HomologicalComplex.homotopyCofiber.sndX φ i))\n⊢ Eq f g","decl":"lemma ext_to_X (i j : ι) (hij : c.Rel i j) {A : C} {f g : A ⟶ X φ i}\n    (h₁ : f ≫ fstX φ i j hij = g ≫ fstX φ i j hij) (h₂ : f ≫ sndX φ i = g ≫ sndX φ i) :\n    f = g := by\n  haveI := HasHomotopyCofiber.hasBinaryBiproduct φ _ _ hij\n  rw [← cancel_mono (XIsoBiprod φ i j hij).hom]\n  apply biprod.hom_ext\n  · simpa using h₁\n  · obtain rfl := c.next_eq' hij\n    simpa [sndX, dif_pos hij] using h₂\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.ext_to_X'","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni : ι\nhi : Not (c.Rel i (c.next i))\nA : C\nf g : Quiver.Hom A (HomologicalComplex.homotopyCofiber.X φ i)\nh : Eq (CategoryTheory.CategoryStruct.comp f (HomologicalComplex.homotopyCofiber.sndX φ i)) (CategoryTheory.CategoryStruct.comp g (HomologicalComplex.homotopyCofiber.sndX φ i))\n⊢ Eq f g","decl":"lemma ext_to_X' (i : ι) (hi : ¬ c.Rel i (c.next i)) {A : C} {f g : A ⟶ X φ i}\n    (h : f ≫ sndX φ i = g ≫ sndX φ i) : f = g := by\n  rw [← cancel_mono (XIso φ i hi).hom]\n  simpa only [sndX, dif_neg hi] using h\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.ext_from_X","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni j : ι\nhij : c.Rel j i\nA : C\nf g : Quiver.Hom (HomologicalComplex.homotopyCofiber.X φ j) A\nh₁ : Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX φ i j hij) f) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX φ i j hij) g)\nh₂ : Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX φ j) f) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX φ j) g)\n⊢ Eq f g","decl":"lemma ext_from_X (i j : ι) (hij : c.Rel j i) {A : C} {f g : X φ j ⟶ A}\n    (h₁ : inlX φ i j hij ≫ f = inlX φ i j hij ≫ g) (h₂ : inrX φ j ≫ f = inrX φ j ≫ g) :\n    f = g := by\n  haveI := HasHomotopyCofiber.hasBinaryBiproduct φ _ _ hij\n  rw [← cancel_epi (XIsoBiprod φ j i hij).inv]\n  apply biprod.hom_ext'\n  · simpa [inlX] using h₁\n  · obtain rfl := c.next_eq' hij\n    simpa [inrX, dif_pos hij] using h₂\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.ext_from_X'","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni : ι\nhi : Not (c.Rel i (c.next i))\nA : C\nf g : Quiver.Hom (HomologicalComplex.homotopyCofiber.X φ i) A\nh : Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX φ i) f) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX φ i) g)\n⊢ Eq f g","decl":"lemma ext_from_X' (i : ι) (hi : ¬ c.Rel i (c.next i)) {A : C} {f g : X φ i ⟶ A}\n    (h : inrX φ i ≫ f = inrX φ i ≫ g) : f = g := by\n  rw [← cancel_epi (XIso φ i hi).inv]\n  simpa only [inrX, dif_neg hi] using h\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.d_fstX","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni j k : ι\nhij : c.Rel i j\nhjk : c.Rel j k\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.d φ i j) (HomologicalComplex.homotopyCofiber.fstX φ j k hjk)) (Neg.neg (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.fstX φ i j hij) (F.d j k)))","decl":"@[reassoc]\nlemma d_fstX (i j k : ι) (hij : c.Rel i j) (hjk : c.Rel j k) :\n    d φ i j ≫ fstX φ j k hjk = -fstX φ i j hij ≫ F.d j k := by\n  obtain rfl := c.next_eq' hjk\n  simp [d, dif_pos hij, dif_pos hjk]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.d_fstX_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni j k : ι\nhij : c.Rel i j\nhjk : c.Rel j k\nZ : C\nh : Quiver.Hom (F.X k) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.d φ i j) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.fstX φ j k hjk) h)) (CategoryTheory.CategoryStruct.comp (Neg.neg (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.fstX φ i j hij) (F.d j k))) h)","decl":"@[reassoc]\nlemma d_fstX (i j k : ι) (hij : c.Rel i j) (hjk : c.Rel j k) :\n    d φ i j ≫ fstX φ j k hjk = -fstX φ i j hij ≫ F.d j k := by\n  obtain rfl := c.next_eq' hjk\n  simp [d, dif_pos hij, dif_pos hjk]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.d_sndX_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni j : ι\nhij : c.Rel i j\nZ : C\nh : Quiver.Hom (G.X j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.d φ i j) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.sndX φ j) h)) (CategoryTheory.CategoryStruct.comp (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.fstX φ i j hij) (φ.f j)) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.sndX φ i) (G.d i j))) h)","decl":"@[reassoc]\nlemma d_sndX (i j : ι) (hij : c.Rel i j) :\n    d φ i j ≫ sndX φ j = fstX φ i j hij ≫ φ.f j + sndX φ i ≫ G.d i j := by\n  dsimp [d]\n  split_ifs with hij <;> simp\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.d_sndX","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni j : ι\nhij : c.Rel i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.d φ i j) (HomologicalComplex.homotopyCofiber.sndX φ j)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.fstX φ i j hij) (φ.f j)) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.sndX φ i) (G.d i j)))","decl":"@[reassoc]\nlemma d_sndX (i j : ι) (hij : c.Rel i j) :\n    d φ i j ≫ sndX φ j = fstX φ i j hij ≫ φ.f j + sndX φ i ≫ G.d i j := by\n  dsimp [d]\n  split_ifs with hij <;> simp\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inlX_d_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni j k : ι\nhij : c.Rel i j\nhjk : c.Rel j k\nZ : C\nh : Quiver.Hom (HomologicalComplex.homotopyCofiber.X φ j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX φ j i hij) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.d φ i j) h)) (CategoryTheory.CategoryStruct.comp (HAdd.hAdd (Neg.neg (CategoryTheory.CategoryStruct.comp (F.d j k) (HomologicalComplex.homotopyCofiber.inlX φ k j hjk))) (CategoryTheory.CategoryStruct.comp (φ.f j) (HomologicalComplex.homotopyCofiber.inrX φ j))) h)","decl":"@[reassoc]\nlemma inlX_d (i j k : ι) (hij : c.Rel i j) (hjk : c.Rel j k) :\n    inlX φ j i hij ≫ d φ i j = -F.d j k ≫ inlX φ k j hjk + φ.f j ≫ inrX φ j := by\n  apply ext_to_X φ j k hjk\n  · dsimp\n    simp [d_fstX φ  _ _ _ hij hjk]\n  · simp [d_sndX φ _ _ hij]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inlX_d","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni j k : ι\nhij : c.Rel i j\nhjk : c.Rel j k\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX φ j i hij) (HomologicalComplex.homotopyCofiber.d φ i j)) (HAdd.hAdd (Neg.neg (CategoryTheory.CategoryStruct.comp (F.d j k) (HomologicalComplex.homotopyCofiber.inlX φ k j hjk))) (CategoryTheory.CategoryStruct.comp (φ.f j) (HomologicalComplex.homotopyCofiber.inrX φ j)))","decl":"@[reassoc]\nlemma inlX_d (i j k : ι) (hij : c.Rel i j) (hjk : c.Rel j k) :\n    inlX φ j i hij ≫ d φ i j = -F.d j k ≫ inlX φ k j hjk + φ.f j ≫ inrX φ j := by\n  apply ext_to_X φ j k hjk\n  · dsimp\n    simp [d_fstX φ  _ _ _ hij hjk]\n  · simp [d_sndX φ _ _ hij]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inlX_d'_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni j : ι\nhij : c.Rel i j\nhj : Not (c.Rel j (c.next j))\nZ : C\nh : Quiver.Hom (HomologicalComplex.homotopyCofiber.X φ j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX φ j i hij) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.d φ i j) h)) (CategoryTheory.CategoryStruct.comp (φ.f j) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX φ j) h))","decl":"@[reassoc]\nlemma inlX_d' (i j : ι) (hij : c.Rel i j) (hj : ¬ c.Rel j (c.next j)) :\n    inlX φ j i hij ≫ d φ i j = φ.f j ≫ inrX φ j := by\n  apply ext_to_X' _ _ hj\n  simp [d_sndX φ i j hij]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inlX_d'","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni j : ι\nhij : c.Rel i j\nhj : Not (c.Rel j (c.next j))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX φ j i hij) (HomologicalComplex.homotopyCofiber.d φ i j)) (CategoryTheory.CategoryStruct.comp (φ.f j) (HomologicalComplex.homotopyCofiber.inrX φ j))","decl":"@[reassoc]\nlemma inlX_d' (i j : ι) (hij : c.Rel i j) (hj : ¬ c.Rel j (c.next j)) :\n    inlX φ j i hij ≫ d φ i j = φ.f j ≫ inrX φ j := by\n  apply ext_to_X' _ _ hj\n  simp [d_sndX φ i j hij]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.shape","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni j : ι\nhij : Not (c.Rel i j)\n⊢ Eq (HomologicalComplex.homotopyCofiber.d φ i j) 0","decl":"lemma shape (i j : ι) (hij : ¬ c.Rel i j) :\n    d φ i j = 0 :=\n  dif_neg hij\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrX_d","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni j : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX φ i) (HomologicalComplex.homotopyCofiber.d φ i j)) (CategoryTheory.CategoryStruct.comp (G.d i j) (HomologicalComplex.homotopyCofiber.inrX φ j))","decl":"@[reassoc (attr := simp)]\nlemma inrX_d (i j : ι) :\n    inrX φ i ≫ d φ i j = G.d i j ≫ inrX φ j := by\n  by_cases hij : c.Rel i j\n  · by_cases hj : c.Rel j (c.next j)\n    · apply ext_to_X _ _ _ hj\n      · simp [d_fstX φ _ _ _ hij]\n      · simp [d_sndX φ _ _ hij]\n    · apply ext_to_X' _ _ hj\n      simp [d_sndX φ _ _ hij]\n  · rw [shape φ _ _ hij, G.shape _ _ hij, zero_comp, comp_zero]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrX_d_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni j : ι\nZ : C\nh : Quiver.Hom (HomologicalComplex.homotopyCofiber.X φ j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX φ i) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.d φ i j) h)) (CategoryTheory.CategoryStruct.comp (G.d i j) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX φ j) h))","decl":"@[reassoc (attr := simp)]\nlemma inrX_d (i j : ι) :\n    inrX φ i ≫ d φ i j = G.d i j ≫ inrX φ j := by\n  by_cases hij : c.Rel i j\n  · by_cases hj : c.Rel j (c.next j)\n    · apply ext_to_X _ _ _ hj\n      · simp [d_fstX φ _ _ _ hij]\n      · simp [d_sndX φ _ _ hij]\n    · apply ext_to_X' _ _ hj\n      simp [d_sndX φ _ _ hij]\n  · rw [shape φ _ _ hij, G.shape _ _ hij, zero_comp, comp_zero]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber_d","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni j : ι\n⊢ Eq ((HomologicalComplex.homotopyCofiber φ).d i j) (HomologicalComplex.homotopyCofiber.d φ i j)","decl":"/-- The homotopy cofiber of a morphism of homological complexes,\nalso known as the mapping cone. -/\n@[simps]\nnoncomputable def homotopyCofiber : HomologicalComplex C c where\n  X i := homotopyCofiber.X φ i\n  d i j := homotopyCofiber.d φ i j\n  shape i j hij := homotopyCofiber.shape φ i j hij\n  d_comp_d' i j k hij hjk := by\n    apply homotopyCofiber.ext_from_X φ j i hij\n    · dsimp\n      simp only [comp_zero, homotopyCofiber.inlX_d_assoc φ i j k hij hjk,\n        add_comp, assoc, homotopyCofiber.inrX_d, Hom.comm_assoc, neg_comp]\n      by_cases hk : c.Rel k (c.next k)\n      · simp [homotopyCofiber.inlX_d φ j k _ hjk hk]\n      · simp [homotopyCofiber.inlX_d' φ j k hjk hk]\n    · simp\n\n"}
{"name":"HomologicalComplex.homotopyCofiber_X","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni : ι\n⊢ Eq ((HomologicalComplex.homotopyCofiber φ).X i) (HomologicalComplex.homotopyCofiber.X φ i)","decl":"/-- The homotopy cofiber of a morphism of homological complexes,\nalso known as the mapping cone. -/\n@[simps]\nnoncomputable def homotopyCofiber : HomologicalComplex C c where\n  X i := homotopyCofiber.X φ i\n  d i j := homotopyCofiber.d φ i j\n  shape i j hij := homotopyCofiber.shape φ i j hij\n  d_comp_d' i j k hij hjk := by\n    apply homotopyCofiber.ext_from_X φ j i hij\n    · dsimp\n      simp only [comp_zero, homotopyCofiber.inlX_d_assoc φ i j k hij hjk,\n        add_comp, assoc, homotopyCofiber.inrX_d, Hom.comm_assoc, neg_comp]\n      by_cases hk : c.Rel k (c.next k)\n      · simp [homotopyCofiber.inlX_d φ j k _ hjk hk]\n      · simp [homotopyCofiber.inlX_d' φ j k hjk hk]\n    · simp\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inr_f","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\ni : ι\n⊢ Eq ((HomologicalComplex.homotopyCofiber.inr φ).f i) (HomologicalComplex.homotopyCofiber.inrX φ i)","decl":"/-- The right inclusion `G ⟶ homotopyCofiber φ`. -/\n@[simps!]\nnoncomputable def inr : G ⟶ homotopyCofiber φ where\n  f i := inrX φ i\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrCompHomotopy_hom","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\nhc : ∀ (j : ι), Exists fun i => c.Rel i j\ni j : ι\nhij : c.Rel j i\n⊢ Eq ((HomologicalComplex.homotopyCofiber.inrCompHomotopy φ hc).hom i j) (HomologicalComplex.homotopyCofiber.inlX φ i j hij)","decl":"lemma inrCompHomotopy_hom (i j : ι) (hij : c.Rel j i) :\n    (inrCompHomotopy φ hc).hom i j = inlX φ i j hij := dif_pos hij\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrCompHomotopy_hom_eq_zero","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\nhc : ∀ (j : ι), Exists fun i => c.Rel i j\ni j : ι\nhij : Not (c.Rel j i)\n⊢ Eq ((HomologicalComplex.homotopyCofiber.inrCompHomotopy φ hc).hom i j) 0","decl":"lemma inrCompHomotopy_hom_eq_zero (i j : ι) (hij : ¬ c.Rel j i) :\n    (inrCompHomotopy φ hc).hom i j = 0 := dif_neg hij\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.desc_f","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G K : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\nα : Quiver.Hom G K\nhα : Homotopy (CategoryTheory.CategoryStruct.comp φ α) 0\nj k : ι\nhjk : c.Rel j k\n⊢ Eq ((HomologicalComplex.homotopyCofiber.desc φ α hα).f j) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.fstX φ j k hjk) (hα.hom k j)) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.sndX φ j) (α.f j)))","decl":"lemma desc_f (j k : ι) (hjk : c.Rel j k) :\n    (desc φ α hα).f j = fstX φ j _ hjk ≫ hα.hom _ j + sndX φ j ≫ α.f j := by\n  obtain rfl := c.next_eq' hjk\n  apply dif_pos hjk\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.desc_f'","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G K : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\nα : Quiver.Hom G K\nhα : Homotopy (CategoryTheory.CategoryStruct.comp φ α) 0\nj : ι\nhj : Not (c.Rel j (c.next j))\n⊢ Eq ((HomologicalComplex.homotopyCofiber.desc φ α hα).f j) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.sndX φ j) (α.f j))","decl":"lemma desc_f' (j : ι) (hj : ¬ c.Rel j (c.next j)) :\n    (desc φ α hα).f j = sndX φ j ≫ α.f j := by\n  apply dif_neg hj\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inlX_desc_f_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G K : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\nα : Quiver.Hom G K\nhα : Homotopy (CategoryTheory.CategoryStruct.comp φ α) 0\ni j : ι\nhjk : c.Rel j i\nZ : C\nh : Quiver.Hom (K.X j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX φ i j hjk) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homotopyCofiber.desc φ α hα).f j) h)) (CategoryTheory.CategoryStruct.comp (hα.hom i j) h)","decl":"@[reassoc (attr := simp)]\nlemma inlX_desc_f (i j : ι) (hjk : c.Rel j i) :\n    inlX φ i j hjk ≫ (desc φ α hα).f j = hα.hom i j := by\n  obtain rfl := c.next_eq' hjk\n  dsimp [desc]\n  rw [dif_pos hjk, comp_add, inlX_fstX_assoc, inlX_sndX_assoc, zero_comp, add_zero]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inlX_desc_f","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G K : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\nα : Quiver.Hom G K\nhα : Homotopy (CategoryTheory.CategoryStruct.comp φ α) 0\ni j : ι\nhjk : c.Rel j i\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX φ i j hjk) ((HomologicalComplex.homotopyCofiber.desc φ α hα).f j)) (hα.hom i j)","decl":"@[reassoc (attr := simp)]\nlemma inlX_desc_f (i j : ι) (hjk : c.Rel j i) :\n    inlX φ i j hjk ≫ (desc φ α hα).f j = hα.hom i j := by\n  obtain rfl := c.next_eq' hjk\n  dsimp [desc]\n  rw [dif_pos hjk, comp_add, inlX_fstX_assoc, inlX_sndX_assoc, zero_comp, add_zero]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrX_desc_f_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G K : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\nα : Quiver.Hom G K\nhα : Homotopy (CategoryTheory.CategoryStruct.comp φ α) 0\ni : ι\nZ : C\nh : Quiver.Hom (K.X i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX φ i) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homotopyCofiber.desc φ α hα).f i) h)) (CategoryTheory.CategoryStruct.comp (α.f i) h)","decl":"@[reassoc (attr := simp)]\nlemma inrX_desc_f (i : ι) :\n    inrX φ i ≫ (desc φ α hα).f i = α.f i := by\n  dsimp [desc]\n  split_ifs <;> simp\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrX_desc_f","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G K : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\nα : Quiver.Hom G K\nhα : Homotopy (CategoryTheory.CategoryStruct.comp φ α) 0\ni : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX φ i) ((HomologicalComplex.homotopyCofiber.desc φ α hα).f i)) (α.f i)","decl":"@[reassoc (attr := simp)]\nlemma inrX_desc_f (i : ι) :\n    inrX φ i ≫ (desc φ α hα).f i = α.f i := by\n  dsimp [desc]\n  split_ifs <;> simp\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inr_desc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G K : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\nα : Quiver.Hom G K\nhα : Homotopy (CategoryTheory.CategoryStruct.comp φ α) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inr φ) (HomologicalComplex.homotopyCofiber.desc φ α hα)) α","decl":"@[reassoc (attr := simp)]\nlemma inr_desc :\n    inr φ ≫ desc φ α hα = α := by aesop_cat\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inr_desc_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G K : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\nα : Quiver.Hom G K\nhα : Homotopy (CategoryTheory.CategoryStruct.comp φ α) 0\nZ : HomologicalComplex C c\nh : Quiver.Hom K Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inr φ) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.desc φ α hα) h)) (CategoryTheory.CategoryStruct.comp α h)","decl":"@[reassoc (attr := simp)]\nlemma inr_desc :\n    inr φ ≫ desc φ α hα = α := by aesop_cat\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrCompHomotopy_hom_desc_hom","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G K : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\nα : Quiver.Hom G K\nhα : Homotopy (CategoryTheory.CategoryStruct.comp φ α) 0\nhc : ∀ (j : ι), Exists fun i => c.Rel i j\ni j : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homotopyCofiber.inrCompHomotopy φ hc).hom i j) ((HomologicalComplex.homotopyCofiber.desc φ α hα).f j)) (hα.hom i j)","decl":"@[reassoc (attr := simp)]\nlemma inrCompHomotopy_hom_desc_hom (hc : ∀ j, ∃ i, c.Rel i j) (i j : ι) :\n    (inrCompHomotopy φ hc).hom i j ≫ (desc φ α hα).f j = hα.hom i j := by\n  by_cases hij : c.Rel j i\n  · dsimp\n    simp only [inrCompHomotopy_hom φ hc i j hij, desc_f φ α hα _ _ hij,\n      comp_add, inlX_fstX_assoc, inlX_sndX_assoc, zero_comp, add_zero]\n  · simp only [Homotopy.zero _ _ _ hij, zero_comp]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrCompHomotopy_hom_desc_hom_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G K : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\nα : Quiver.Hom G K\nhα : Homotopy (CategoryTheory.CategoryStruct.comp φ α) 0\nhc : ∀ (j : ι), Exists fun i => c.Rel i j\ni j : ι\nZ : C\nh : Quiver.Hom (K.X j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homotopyCofiber.inrCompHomotopy φ hc).hom i j) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homotopyCofiber.desc φ α hα).f j) h)) (CategoryTheory.CategoryStruct.comp (hα.hom i j) h)","decl":"@[reassoc (attr := simp)]\nlemma inrCompHomotopy_hom_desc_hom (hc : ∀ j, ∃ i, c.Rel i j) (i j : ι) :\n    (inrCompHomotopy φ hc).hom i j ≫ (desc φ α hα).f j = hα.hom i j := by\n  by_cases hij : c.Rel j i\n  · dsimp\n    simp only [inrCompHomotopy_hom φ hc i j hij, desc_f φ α hα _ _ hij,\n      comp_add, inlX_fstX_assoc, inlX_sndX_assoc, zero_comp, add_zero]\n  · simp only [Homotopy.zero _ _ _ hij, zero_comp]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.eq_desc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G K : HomologicalComplex C c\nφ : Quiver.Hom F G\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber φ\ninst✝ : DecidableRel c.Rel\nf : Quiver.Hom (HomologicalComplex.homotopyCofiber φ) K\nhc : ∀ (j : ι), Exists fun i => c.Rel i j\n⊢ Eq f (HomologicalComplex.homotopyCofiber.desc φ (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inr φ) f) ((Homotopy.ofEq ⋯).trans (((HomologicalComplex.homotopyCofiber.inrCompHomotopy φ hc).compRight f).trans (Homotopy.ofEq ⋯))))","decl":"lemma eq_desc (f : homotopyCofiber φ ⟶ K) (hc : ∀ j, ∃ i, c.Rel i j) :\n    f = desc φ (inr φ ≫ f) (Homotopy.trans (Homotopy.ofEq (by simp))\n      (((inrCompHomotopy φ hc).compRight f).trans (Homotopy.ofEq (by simp)))) := by\n  ext j\n  by_cases hj : c.Rel j (c.next j)\n  · apply ext_from_X φ _ _ hj\n    · simp [inrCompHomotopy_hom _ _ _ _ hj]\n    · simp\n  · apply ext_from_X' φ _ hj\n    simp\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.descSigma_ext_iff","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\ninst✝ : DecidableRel c.Rel\nφ : Quiver.Hom F G\nK : HomologicalComplex C c\nx y : Sigma fun α => Homotopy (CategoryTheory.CategoryStruct.comp φ α) 0\n⊢ Iff (Eq x y) (And (Eq x.fst y.fst) (∀ (i j : ι), c.Rel j i → Eq (x.snd.hom i j) (y.snd.hom i j)))","decl":"lemma descSigma_ext_iff {φ : F ⟶ G} {K : HomologicalComplex C c}\n    (x y : Σ (α : G ⟶ K), Homotopy (φ ≫ α) 0) :\n    x = y ↔ x.1 = y.1 ∧ (∀ (i j : ι) (_ : c.Rel j i), x.2.hom i j = y.2.hom i j) := by\n  constructor\n  · rintro rfl\n    tauto\n  · obtain ⟨x₁, x₂⟩ := x\n    obtain ⟨y₁, y₂⟩ := y\n    rintro ⟨rfl, h⟩\n    simp only [Sigma.mk.inj_iff, heq_eq_eq, true_and]\n    ext i j\n    by_cases hij : c.Rel j i\n    · exact h _ _ hij\n    · simp only [Homotopy.zero _ _ _ hij]\n\n"}
{"name":"HomologicalComplex.cylinder.ι₀_desc_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF K : HomologicalComplex C c\ninst✝² : DecidableRel c.Rel\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninst✝ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\nφ₀ φ₁ : Quiver.Hom K F\nh✝ : Homotopy φ₀ φ₁\nZ : HomologicalComplex C c\nh : Quiver.Hom F Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.ι₀ K) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.desc φ₀ φ₁ h✝) h)) (CategoryTheory.CategoryStruct.comp φ₀ h)","decl":"@[reassoc (attr := simp)]\nlemma ι₀_desc : ι₀ K ≫ desc φ₀ φ₁ h = φ₀ := by simp [ι₀, desc]\n\n"}
{"name":"HomologicalComplex.cylinder.ι₀_desc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF K : HomologicalComplex C c\ninst✝² : DecidableRel c.Rel\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninst✝ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\nφ₀ φ₁ : Quiver.Hom K F\nh : Homotopy φ₀ φ₁\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.ι₀ K) (HomologicalComplex.cylinder.desc φ₀ φ₁ h)) φ₀","decl":"@[reassoc (attr := simp)]\nlemma ι₀_desc : ι₀ K ≫ desc φ₀ φ₁ h = φ₀ := by simp [ι₀, desc]\n\n"}
{"name":"HomologicalComplex.cylinder.ι₁_desc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF K : HomologicalComplex C c\ninst✝² : DecidableRel c.Rel\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninst✝ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\nφ₀ φ₁ : Quiver.Hom K F\nh : Homotopy φ₀ φ₁\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.ι₁ K) (HomologicalComplex.cylinder.desc φ₀ φ₁ h)) φ₁","decl":"@[reassoc (attr := simp)]\nlemma ι₁_desc : ι₁ K ≫ desc φ₀ φ₁ h = φ₁ := by simp [ι₁, desc]\n\n"}
{"name":"HomologicalComplex.cylinder.ι₁_desc_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF K : HomologicalComplex C c\ninst✝² : DecidableRel c.Rel\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninst✝ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\nφ₀ φ₁ : Quiver.Hom K F\nh✝ : Homotopy φ₀ φ₁\nZ : HomologicalComplex C c\nh : Quiver.Hom F Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.ι₁ K) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.desc φ₀ φ₁ h✝) h)) (CategoryTheory.CategoryStruct.comp φ₁ h)","decl":"@[reassoc (attr := simp)]\nlemma ι₁_desc : ι₁ K ≫ desc φ₀ φ₁ h = φ₁ := by simp [ι₁, desc]\n\n"}
{"name":"HomologicalComplex.cylinder.ι₀_π_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nK : HomologicalComplex C c\ninst✝² : DecidableRel c.Rel\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninst✝ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\nZ : HomologicalComplex C c\nh : Quiver.Hom K Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.ι₀ K) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.π K) h)) h","decl":"@[reassoc (attr := simp)]\nlemma ι₀_π : ι₀ K ≫ π K = 𝟙 K := by simp [π]\n\n"}
{"name":"HomologicalComplex.cylinder.ι₀_π","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nK : HomologicalComplex C c\ninst✝² : DecidableRel c.Rel\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninst✝ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.ι₀ K) (HomologicalComplex.cylinder.π K)) (CategoryTheory.CategoryStruct.id K)","decl":"@[reassoc (attr := simp)]\nlemma ι₀_π : ι₀ K ≫ π K = 𝟙 K := by simp [π]\n\n"}
{"name":"HomologicalComplex.cylinder.ι₁_π_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nK : HomologicalComplex C c\ninst✝² : DecidableRel c.Rel\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninst✝ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\nZ : HomologicalComplex C c\nh : Quiver.Hom K Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.ι₁ K) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.π K) h)) h","decl":"@[reassoc (attr := simp)]\nlemma ι₁_π : ι₁ K ≫ π K = 𝟙 K := by simp [π]\n\n"}
{"name":"HomologicalComplex.cylinder.ι₁_π","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nK : HomologicalComplex C c\ninst✝² : DecidableRel c.Rel\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninst✝ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.ι₁ K) (HomologicalComplex.cylinder.π K)) (CategoryTheory.CategoryStruct.id K)","decl":"@[reassoc (attr := simp)]\nlemma ι₁_π : ι₁ K ≫ π K = 𝟙 K := by simp [π]\n\n"}
{"name":"HomologicalComplex.cylinder.inlX_π","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nK : HomologicalComplex C c\ninst✝² : DecidableRel c.Rel\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninst✝ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\ni j : ι\nhij : c.Rel j i\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.inlX K i j hij) ((HomologicalComplex.cylinder.π K).f j)) 0","decl":"@[reassoc (attr := simp)]\nlemma inlX_π (i j : ι) (hij : c.Rel j i) :\n    inlX K i j hij ≫ (π K).f j = 0 := by\n  erw [homotopyCofiber.inlX_desc_f]\n  simp [Homotopy.equivSubZero]\n\n"}
{"name":"HomologicalComplex.cylinder.inlX_π_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nK : HomologicalComplex C c\ninst✝² : DecidableRel c.Rel\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninst✝ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\ni j : ι\nhij : c.Rel j i\nZ : C\nh : Quiver.Hom (K.X j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.inlX K i j hij) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.cylinder.π K).f j) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma inlX_π (i j : ι) (hij : c.Rel j i) :\n    inlX K i j hij ≫ (π K).f j = 0 := by\n  erw [homotopyCofiber.inlX_desc_f]\n  simp [Homotopy.equivSubZero]\n\n"}
{"name":"HomologicalComplex.cylinder.inrX_π_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nK : HomologicalComplex C c\ninst✝² : DecidableRel c.Rel\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninst✝ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\ni : ι\nZ : C\nh : Quiver.Hom (K.X i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.inrX K i) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.cylinder.π K).f i) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.biprod.desc (CategoryTheory.CategoryStruct.id K) (CategoryTheory.CategoryStruct.id K)).f i) h)","decl":"@[reassoc (attr := simp)]\nlemma inrX_π (i : ι) :\n    inrX K i ≫ (π K).f i = (biprod.desc (𝟙 _) (𝟙 K)).f i :=\n  homotopyCofiber.inrX_desc_f _ _ _ _\n\n"}
{"name":"HomologicalComplex.cylinder.inrX_π","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nK : HomologicalComplex C c\ninst✝² : DecidableRel c.Rel\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninst✝ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\ni : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.inrX K i) ((HomologicalComplex.cylinder.π K).f i)) ((CategoryTheory.Limits.biprod.desc (CategoryTheory.CategoryStruct.id K) (CategoryTheory.CategoryStruct.id K)).f i)","decl":"@[reassoc (attr := simp)]\nlemma inrX_π (i : ι) :\n    inrX K i ≫ (π K).f i = (biprod.desc (𝟙 _) (𝟙 K)).f i :=\n  homotopyCofiber.inrX_desc_f _ _ _ _\n\n"}
{"name":"HomologicalComplex.cylinder.πCompι₀Homotopy.inlX_nullHomotopy_f","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nK : HomologicalComplex C c\ninst✝² : DecidableRel c.Rel\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninst✝ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\ni j : ι\nhij : c.Rel j i\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.inlX K i j hij) ((HomologicalComplex.cylinder.πCompι₀Homotopy.nullHomotopicMap K).f j)) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.inlX K i j hij) ((HSub.hSub (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.π K) (HomologicalComplex.cylinder.ι₀ K)) (CategoryTheory.CategoryStruct.id K.cylinder)).f j))","decl":"lemma inlX_nullHomotopy_f (i j : ι) (hij : c.Rel j i) :\n    inlX K i j hij ≫ (nullHomotopicMap K).f j =\n      inlX K i j hij ≫ (π K ≫ ι₀ K - 𝟙 _).f j := by\n  dsimp [nullHomotopicMap]\n  by_cases hj : ∃ (k : ι), c.Rel k j\n  · obtain ⟨k, hjk⟩ := hj\n    simp only [assoc, Homotopy.nullHomotopicMap'_f hjk hij, homotopyCofiber_X, homotopyCofiber_d,\n      homotopyCofiber.d_sndX_assoc _ _ _ hij, add_comp, comp_add, homotopyCofiber.inlX_fstX_assoc,\n      homotopyCofiber.inlX_sndX_assoc, zero_comp, add_zero, comp_sub, inlX_π_assoc, comp_id,\n      zero_sub, ← HomologicalComplex.comp_f_assoc, biprod.lift_snd, neg_f_apply, id_f,\n      neg_comp, id_comp]\n  · simp only [not_exists] at hj\n    simp only [Homotopy.nullHomotopicMap'_f_of_not_rel_right hij hj,\n      homotopyCofiber_X, homotopyCofiber_d, assoc, comp_sub, comp_id,\n      homotopyCofiber.d_sndX_assoc _ _ _ hij, add_comp, comp_add, zero_comp, add_zero,\n      homotopyCofiber.inlX_fstX_assoc, homotopyCofiber.inlX_sndX_assoc,\n      ← HomologicalComplex.comp_f_assoc, biprod.lift_snd, neg_f_apply, id_f, neg_comp,\n      id_comp, inlX_π_assoc, zero_sub]\n\n"}
{"name":"HomologicalComplex.cylinder.πCompι₀Homotopy.inrX_nullHomotopy_f","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nK : HomologicalComplex C c\ninst✝² : DecidableRel c.Rel\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninst✝ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\nhc : ∀ (j : ι), Exists fun i => c.Rel i j\nj : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.inrX K j) ((HomologicalComplex.cylinder.πCompι₀Homotopy.nullHomotopicMap K).f j)) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.inrX K j) ((HSub.hSub (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.π K) (HomologicalComplex.cylinder.ι₀ K)) (CategoryTheory.CategoryStruct.id K.cylinder)).f j))","decl":"lemma inrX_nullHomotopy_f (j : ι) :\n    inrX K j ≫ (nullHomotopicMap K).f j = inrX K j ≫ (π K ≫ ι₀ K - 𝟙 _).f j := by\n  have : biprod.lift (𝟙 K) (-𝟙 K) = biprod.inl - biprod.inr :=\n    biprod.hom_ext _ _ (by simp) (by simp)\n  obtain ⟨i, hij⟩ := hc j\n  dsimp [nullHomotopicMap]\n  by_cases hj : ∃ (k : ι), c.Rel j k\n  · obtain ⟨k, hjk⟩ := hj\n    simp only [Homotopy.nullHomotopicMap'_f hij hjk,\n      homotopyCofiber_X, homotopyCofiber_d, assoc, comp_add,\n      homotopyCofiber.inrX_d_assoc, homotopyCofiber.inrX_sndX_assoc, comp_sub,\n      inrX_π_assoc, comp_id, ← Hom.comm_assoc, homotopyCofiber.inlX_d _ _ _ _ _ hjk,\n      comp_neg, add_neg_cancel_left]\n    rw [← cancel_epi (biprodXIso K K j).inv]\n    ext\n    · simp [ι₀]\n    · dsimp\n      simp only [inr_biprodXIso_inv_assoc, biprod_inr_snd_f_assoc, comp_sub,\n        biprod_inr_desc_f_assoc, id_f, id_comp, ι₀, comp_f, this,\n        sub_f_apply, sub_comp, homotopyCofiber_X, homotopyCofiber.inr_f]\n  · simp only [not_exists] at hj\n    simp only [assoc, Homotopy.nullHomotopicMap'_f_of_not_rel_left hij hj, homotopyCofiber_X,\n      homotopyCofiber_d, homotopyCofiber.inlX_d' _ _ _ _ (hj _), homotopyCofiber.inrX_sndX_assoc,\n      comp_sub, inrX_π_assoc, comp_id, ι₀, comp_f, homotopyCofiber.inr_f]\n    rw [← cancel_epi (biprodXIso K K j).inv]\n    ext\n    · simp\n    · simp [this]\n\n"}
{"name":"HomologicalComplex.cylinder.πCompι₀Homotopy.nullHomotopicMap_eq","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nK : HomologicalComplex C c\ninst✝² : DecidableRel c.Rel\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninst✝ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\nhc : ∀ (j : ι), Exists fun i => c.Rel i j\n⊢ Eq (HomologicalComplex.cylinder.πCompι₀Homotopy.nullHomotopicMap K) (HSub.hSub (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.π K) (HomologicalComplex.cylinder.ι₀ K)) (CategoryTheory.CategoryStruct.id K.cylinder))","decl":"lemma nullHomotopicMap_eq : nullHomotopicMap K = π K ≫ ι₀ K - 𝟙 _ := by\n  ext i\n  by_cases hi : c.Rel i (c.next i)\n  · exact homotopyCofiber.ext_from_X (biprod.lift (𝟙 K) (-𝟙 K)) (c.next i) i hi\n      (inlX_nullHomotopy_f _ _ _ _) (inrX_nullHomotopy_f _ hc _)\n  · exact homotopyCofiber.ext_from_X' (biprod.lift (𝟙 K) (-𝟙 K)) _ hi (inrX_nullHomotopy_f _ hc _)\n\n"}
{"name":"HomologicalComplex.cylinder.map_ι₀_eq_map_ι₁","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nK : HomologicalComplex C c\ninst✝³ : DecidableRel c.Rel\ninst✝² : ∀ (i : ι), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\nhc : ∀ (j : ι), Exists fun i => c.Rel i j\nD : Type u_3\ninst✝ : CategoryTheory.Category.{u_4, u_3} D\nH : CategoryTheory.Functor (HomologicalComplex C c) D\nhH : (HomologicalComplex.homotopyEquivalences C c).IsInvertedBy H\n⊢ Eq (H.map (HomologicalComplex.cylinder.ι₀ K)) (H.map (HomologicalComplex.cylinder.ι₁ K))","decl":"include hc in\nlemma map_ι₀_eq_map_ι₁ {D : Type*} [Category D] (H : HomologicalComplex C c ⥤ D)\n    (hH : (homotopyEquivalences C c).IsInvertedBy H) :\n    H.map (ι₀ K) = H.map (ι₁ K) := by\n  have : IsIso (H.map (cylinder.π K)) := hH _ ⟨homotopyEquiv K hc, rfl⟩\n  simp only [← cancel_mono (H.map (cylinder.π K)), ← H.map_comp, ι₀_π, H.map_id, ι₁_π]\n\n"}
{"name":"Homotopy.map_eq_of_inverts_homotopyEquivalences","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\nι : Type u_2\nc : ComplexShape ι\nF G : HomologicalComplex C c\ninst✝³ : DecidableRel c.Rel\nφ₀ φ₁ : Quiver.Hom F G\nh : Homotopy φ₀ φ₁\nhc : ∀ (j : ι), Exists fun i => c.Rel i j\ninst✝² : ∀ (i : ι), CategoryTheory.Limits.HasBinaryBiproduct (F.X i) (F.X i)\ninst✝¹ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id F) (Neg.neg (CategoryTheory.CategoryStruct.id F)))\nD : Type u_3\ninst✝ : CategoryTheory.Category.{u_5, u_3} D\nH : CategoryTheory.Functor (HomologicalComplex C c) D\nhH : (HomologicalComplex.homotopyEquivalences C c).IsInvertedBy H\n⊢ Eq (H.map φ₀) (H.map φ₁)","decl":"/-- If a functor inverts homotopy equivalences, it sends homotopic maps to the same map. -/\nlemma _root_.Homotopy.map_eq_of_inverts_homotopyEquivalences\n    {φ₀ φ₁ : F ⟶ G} (h : Homotopy φ₀ φ₁)(hc : ∀ j, ∃ i, c.Rel i j)\n    [∀ i, HasBinaryBiproduct (F.X i) (F.X i)]\n    [HasHomotopyCofiber (biprod.lift (𝟙 F) (-𝟙 F))]\n    {D : Type*} [Category D] (H : HomologicalComplex C c ⥤ D)\n    (hH : (homotopyEquivalences C c).IsInvertedBy H) :\n    H.map φ₀ = H.map φ₁ := by\n  simp only [← cylinder.ι₀_desc _ _ h, ← cylinder.ι₁_desc _ _ h, H.map_comp,\n    cylinder.map_ι₀_eq_map_ι₁ _ hc _ hH]\n\n"}
