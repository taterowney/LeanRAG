{"name":"HomologicalComplex.HasHomotopyCofiber.hasBinaryBiproduct","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_3, u_1} C\ninstâœ : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\nself : HomologicalComplex.HasHomotopyCofiber Ï†\ni j : Î¹\nhij : c.Rel i j\nâŠ¢ CategoryTheory.Limits.HasBinaryBiproduct (F.X j) (G.X i)","decl":"/-- A morphism of homological complexes `Ï† : F âŸ¶ G` has a homotopy cofiber if for all\nindices `i` and `j` such that `c.Rel i j`, the binary biproduct `F.X j âŠ G.X i` exists. -/\nclass HasHomotopyCofiber (Ï† : F âŸ¶ G) : Prop where\n  hasBinaryBiproduct (i j : Î¹) (hij : c.Rel i j) : HasBinaryBiproduct (F.X j) (G.X i)\n\n"}
{"name":"HomologicalComplex.instHasHomotopyCofiberOfHasBinaryBiproducts","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nâŠ¢ HomologicalComplex.HasHomotopyCofiber Ï†","decl":"instance [HasBinaryBiproducts C] : HasHomotopyCofiber Ï† where\n  hasBinaryBiproduct _ _ _ := inferInstance\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrX_sndX","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni : Î¹\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX Ï† i) (HomologicalComplex.homotopyCofiber.sndX Ï† i)) (CategoryTheory.CategoryStruct.id (G.X i))","decl":"@[reassoc (attr := simp)]\nlemma inrX_sndX (i : Î¹) : inrX Ï† i â‰« sndX Ï† i = ğŸ™ _ := by\n  dsimp [sndX, inrX]\n  split_ifs with hi <;> simp\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrX_sndX_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni : Î¹\nZ : C\nh : Quiver.Hom (G.X i) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX Ï† i) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.sndX Ï† i) h)) h","decl":"@[reassoc (attr := simp)]\nlemma inrX_sndX (i : Î¹) : inrX Ï† i â‰« sndX Ï† i = ğŸ™ _ := by\n  dsimp [sndX, inrX]\n  split_ifs with hi <;> simp\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.sndX_inrX_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni : Î¹\nhi : Not (c.Rel i (c.next i))\nZ : C\nh : Quiver.Hom (HomologicalComplex.homotopyCofiber.X Ï† i) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.sndX Ï† i) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX Ï† i) h)) h","decl":"@[reassoc]\nlemma sndX_inrX (i : Î¹) (hi : Â¬ c.Rel i (c.next i)) :\n    sndX Ï† i â‰« inrX Ï† i = ğŸ™ _ := by\n  dsimp [sndX, inrX]\n  simp only [dif_neg hi, Iso.hom_inv_id]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.sndX_inrX","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni : Î¹\nhi : Not (c.Rel i (c.next i))\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.sndX Ï† i) (HomologicalComplex.homotopyCofiber.inrX Ï† i)) (CategoryTheory.CategoryStruct.id (HomologicalComplex.homotopyCofiber.X Ï† i))","decl":"@[reassoc]\nlemma sndX_inrX (i : Î¹) (hi : Â¬ c.Rel i (c.next i)) :\n    sndX Ï† i â‰« inrX Ï† i = ğŸ™ _ := by\n  dsimp [sndX, inrX]\n  simp only [dif_neg hi, Iso.hom_inv_id]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inlX_fstX_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni j : Î¹\nhij : c.Rel j i\nZ : C\nh : Quiver.Hom (F.X i) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX Ï† i j hij) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.fstX Ï† j i hij) h)) h","decl":"@[reassoc (attr := simp)]\nlemma inlX_fstX (i j : Î¹ ) (hij : c.Rel j i) :\n    inlX Ï† i j hij â‰« fstX Ï† j i hij = ğŸ™ _ := by\n  simp [inlX, fstX]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inlX_fstX","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni j : Î¹\nhij : c.Rel j i\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX Ï† i j hij) (HomologicalComplex.homotopyCofiber.fstX Ï† j i hij)) (CategoryTheory.CategoryStruct.id (F.X i))","decl":"@[reassoc (attr := simp)]\nlemma inlX_fstX (i j : Î¹ ) (hij : c.Rel j i) :\n    inlX Ï† i j hij â‰« fstX Ï† j i hij = ğŸ™ _ := by\n  simp [inlX, fstX]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inlX_sndX","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni j : Î¹\nhij : c.Rel j i\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX Ï† i j hij) (HomologicalComplex.homotopyCofiber.sndX Ï† j)) 0","decl":"@[reassoc (attr := simp)]\nlemma inlX_sndX (i j : Î¹) (hij : c.Rel j i) :\n    inlX Ï† i j hij â‰« sndX Ï† j = 0 := by\n  obtain rfl := c.next_eq' hij\n  simp [inlX, sndX, dif_pos hij]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inlX_sndX_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni j : Î¹\nhij : c.Rel j i\nZ : C\nh : Quiver.Hom (G.X j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX Ï† i j hij) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.sndX Ï† j) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma inlX_sndX (i j : Î¹) (hij : c.Rel j i) :\n    inlX Ï† i j hij â‰« sndX Ï† j = 0 := by\n  obtain rfl := c.next_eq' hij\n  simp [inlX, sndX, dif_pos hij]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrX_fstX_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni j : Î¹\nhij : c.Rel i j\nZ : C\nh : Quiver.Hom (F.X j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX Ï† i) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.fstX Ï† i j hij) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma inrX_fstX (i j : Î¹) (hij : c.Rel i j) :\n    inrX Ï† i â‰« fstX Ï† i j hij = 0 := by\n  obtain rfl := c.next_eq' hij\n  simp [inrX, fstX, dif_pos hij]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrX_fstX","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni j : Î¹\nhij : c.Rel i j\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX Ï† i) (HomologicalComplex.homotopyCofiber.fstX Ï† i j hij)) 0","decl":"@[reassoc (attr := simp)]\nlemma inrX_fstX (i j : Î¹) (hij : c.Rel i j) :\n    inrX Ï† i â‰« fstX Ï† i j hij = 0 := by\n  obtain rfl := c.next_eq' hij\n  simp [inrX, fstX, dif_pos hij]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.ext_to_X","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni j : Î¹\nhij : c.Rel i j\nA : C\nf g : Quiver.Hom A (HomologicalComplex.homotopyCofiber.X Ï† i)\nhâ‚ : Eq (CategoryTheory.CategoryStruct.comp f (HomologicalComplex.homotopyCofiber.fstX Ï† i j hij)) (CategoryTheory.CategoryStruct.comp g (HomologicalComplex.homotopyCofiber.fstX Ï† i j hij))\nhâ‚‚ : Eq (CategoryTheory.CategoryStruct.comp f (HomologicalComplex.homotopyCofiber.sndX Ï† i)) (CategoryTheory.CategoryStruct.comp g (HomologicalComplex.homotopyCofiber.sndX Ï† i))\nâŠ¢ Eq f g","decl":"lemma ext_to_X (i j : Î¹) (hij : c.Rel i j) {A : C} {f g : A âŸ¶ X Ï† i}\n    (hâ‚ : f â‰« fstX Ï† i j hij = g â‰« fstX Ï† i j hij) (hâ‚‚ : f â‰« sndX Ï† i = g â‰« sndX Ï† i) :\n    f = g := by\n  haveI := HasHomotopyCofiber.hasBinaryBiproduct Ï† _ _ hij\n  rw [â† cancel_mono (XIsoBiprod Ï† i j hij).hom]\n  apply biprod.hom_ext\n  Â· simpa using hâ‚\n  Â· obtain rfl := c.next_eq' hij\n    simpa [sndX, dif_pos hij] using hâ‚‚\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.ext_to_X'","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni : Î¹\nhi : Not (c.Rel i (c.next i))\nA : C\nf g : Quiver.Hom A (HomologicalComplex.homotopyCofiber.X Ï† i)\nh : Eq (CategoryTheory.CategoryStruct.comp f (HomologicalComplex.homotopyCofiber.sndX Ï† i)) (CategoryTheory.CategoryStruct.comp g (HomologicalComplex.homotopyCofiber.sndX Ï† i))\nâŠ¢ Eq f g","decl":"lemma ext_to_X' (i : Î¹) (hi : Â¬ c.Rel i (c.next i)) {A : C} {f g : A âŸ¶ X Ï† i}\n    (h : f â‰« sndX Ï† i = g â‰« sndX Ï† i) : f = g := by\n  rw [â† cancel_mono (XIso Ï† i hi).hom]\n  simpa only [sndX, dif_neg hi] using h\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.ext_from_X","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni j : Î¹\nhij : c.Rel j i\nA : C\nf g : Quiver.Hom (HomologicalComplex.homotopyCofiber.X Ï† j) A\nhâ‚ : Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX Ï† i j hij) f) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX Ï† i j hij) g)\nhâ‚‚ : Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX Ï† j) f) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX Ï† j) g)\nâŠ¢ Eq f g","decl":"lemma ext_from_X (i j : Î¹) (hij : c.Rel j i) {A : C} {f g : X Ï† j âŸ¶ A}\n    (hâ‚ : inlX Ï† i j hij â‰« f = inlX Ï† i j hij â‰« g) (hâ‚‚ : inrX Ï† j â‰« f = inrX Ï† j â‰« g) :\n    f = g := by\n  haveI := HasHomotopyCofiber.hasBinaryBiproduct Ï† _ _ hij\n  rw [â† cancel_epi (XIsoBiprod Ï† j i hij).inv]\n  apply biprod.hom_ext'\n  Â· simpa [inlX] using hâ‚\n  Â· obtain rfl := c.next_eq' hij\n    simpa [inrX, dif_pos hij] using hâ‚‚\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.ext_from_X'","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni : Î¹\nhi : Not (c.Rel i (c.next i))\nA : C\nf g : Quiver.Hom (HomologicalComplex.homotopyCofiber.X Ï† i) A\nh : Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX Ï† i) f) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX Ï† i) g)\nâŠ¢ Eq f g","decl":"lemma ext_from_X' (i : Î¹) (hi : Â¬ c.Rel i (c.next i)) {A : C} {f g : X Ï† i âŸ¶ A}\n    (h : inrX Ï† i â‰« f = inrX Ï† i â‰« g) : f = g := by\n  rw [â† cancel_epi (XIso Ï† i hi).inv]\n  simpa only [inrX, dif_neg hi] using h\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.d_fstX","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni j k : Î¹\nhij : c.Rel i j\nhjk : c.Rel j k\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.d Ï† i j) (HomologicalComplex.homotopyCofiber.fstX Ï† j k hjk)) (Neg.neg (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.fstX Ï† i j hij) (F.d j k)))","decl":"@[reassoc]\nlemma d_fstX (i j k : Î¹) (hij : c.Rel i j) (hjk : c.Rel j k) :\n    d Ï† i j â‰« fstX Ï† j k hjk = -fstX Ï† i j hij â‰« F.d j k := by\n  obtain rfl := c.next_eq' hjk\n  simp [d, dif_pos hij, dif_pos hjk]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.d_fstX_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni j k : Î¹\nhij : c.Rel i j\nhjk : c.Rel j k\nZ : C\nh : Quiver.Hom (F.X k) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.d Ï† i j) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.fstX Ï† j k hjk) h)) (CategoryTheory.CategoryStruct.comp (Neg.neg (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.fstX Ï† i j hij) (F.d j k))) h)","decl":"@[reassoc]\nlemma d_fstX (i j k : Î¹) (hij : c.Rel i j) (hjk : c.Rel j k) :\n    d Ï† i j â‰« fstX Ï† j k hjk = -fstX Ï† i j hij â‰« F.d j k := by\n  obtain rfl := c.next_eq' hjk\n  simp [d, dif_pos hij, dif_pos hjk]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.d_sndX_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni j : Î¹\nhij : c.Rel i j\nZ : C\nh : Quiver.Hom (G.X j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.d Ï† i j) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.sndX Ï† j) h)) (CategoryTheory.CategoryStruct.comp (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.fstX Ï† i j hij) (Ï†.f j)) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.sndX Ï† i) (G.d i j))) h)","decl":"@[reassoc]\nlemma d_sndX (i j : Î¹) (hij : c.Rel i j) :\n    d Ï† i j â‰« sndX Ï† j = fstX Ï† i j hij â‰« Ï†.f j + sndX Ï† i â‰« G.d i j := by\n  dsimp [d]\n  split_ifs with hij <;> simp\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.d_sndX","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni j : Î¹\nhij : c.Rel i j\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.d Ï† i j) (HomologicalComplex.homotopyCofiber.sndX Ï† j)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.fstX Ï† i j hij) (Ï†.f j)) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.sndX Ï† i) (G.d i j)))","decl":"@[reassoc]\nlemma d_sndX (i j : Î¹) (hij : c.Rel i j) :\n    d Ï† i j â‰« sndX Ï† j = fstX Ï† i j hij â‰« Ï†.f j + sndX Ï† i â‰« G.d i j := by\n  dsimp [d]\n  split_ifs with hij <;> simp\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inlX_d_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni j k : Î¹\nhij : c.Rel i j\nhjk : c.Rel j k\nZ : C\nh : Quiver.Hom (HomologicalComplex.homotopyCofiber.X Ï† j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX Ï† j i hij) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.d Ï† i j) h)) (CategoryTheory.CategoryStruct.comp (HAdd.hAdd (Neg.neg (CategoryTheory.CategoryStruct.comp (F.d j k) (HomologicalComplex.homotopyCofiber.inlX Ï† k j hjk))) (CategoryTheory.CategoryStruct.comp (Ï†.f j) (HomologicalComplex.homotopyCofiber.inrX Ï† j))) h)","decl":"@[reassoc]\nlemma inlX_d (i j k : Î¹) (hij : c.Rel i j) (hjk : c.Rel j k) :\n    inlX Ï† j i hij â‰« d Ï† i j = -F.d j k â‰« inlX Ï† k j hjk + Ï†.f j â‰« inrX Ï† j := by\n  apply ext_to_X Ï† j k hjk\n  Â· dsimp\n    simp [d_fstX Ï†  _ _ _ hij hjk]\n  Â· simp [d_sndX Ï† _ _ hij]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inlX_d","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni j k : Î¹\nhij : c.Rel i j\nhjk : c.Rel j k\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX Ï† j i hij) (HomologicalComplex.homotopyCofiber.d Ï† i j)) (HAdd.hAdd (Neg.neg (CategoryTheory.CategoryStruct.comp (F.d j k) (HomologicalComplex.homotopyCofiber.inlX Ï† k j hjk))) (CategoryTheory.CategoryStruct.comp (Ï†.f j) (HomologicalComplex.homotopyCofiber.inrX Ï† j)))","decl":"@[reassoc]\nlemma inlX_d (i j k : Î¹) (hij : c.Rel i j) (hjk : c.Rel j k) :\n    inlX Ï† j i hij â‰« d Ï† i j = -F.d j k â‰« inlX Ï† k j hjk + Ï†.f j â‰« inrX Ï† j := by\n  apply ext_to_X Ï† j k hjk\n  Â· dsimp\n    simp [d_fstX Ï†  _ _ _ hij hjk]\n  Â· simp [d_sndX Ï† _ _ hij]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inlX_d'_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni j : Î¹\nhij : c.Rel i j\nhj : Not (c.Rel j (c.next j))\nZ : C\nh : Quiver.Hom (HomologicalComplex.homotopyCofiber.X Ï† j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX Ï† j i hij) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.d Ï† i j) h)) (CategoryTheory.CategoryStruct.comp (Ï†.f j) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX Ï† j) h))","decl":"@[reassoc]\nlemma inlX_d' (i j : Î¹) (hij : c.Rel i j) (hj : Â¬ c.Rel j (c.next j)) :\n    inlX Ï† j i hij â‰« d Ï† i j = Ï†.f j â‰« inrX Ï† j := by\n  apply ext_to_X' _ _ hj\n  simp [d_sndX Ï† i j hij]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inlX_d'","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni j : Î¹\nhij : c.Rel i j\nhj : Not (c.Rel j (c.next j))\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX Ï† j i hij) (HomologicalComplex.homotopyCofiber.d Ï† i j)) (CategoryTheory.CategoryStruct.comp (Ï†.f j) (HomologicalComplex.homotopyCofiber.inrX Ï† j))","decl":"@[reassoc]\nlemma inlX_d' (i j : Î¹) (hij : c.Rel i j) (hj : Â¬ c.Rel j (c.next j)) :\n    inlX Ï† j i hij â‰« d Ï† i j = Ï†.f j â‰« inrX Ï† j := by\n  apply ext_to_X' _ _ hj\n  simp [d_sndX Ï† i j hij]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.shape","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni j : Î¹\nhij : Not (c.Rel i j)\nâŠ¢ Eq (HomologicalComplex.homotopyCofiber.d Ï† i j) 0","decl":"lemma shape (i j : Î¹) (hij : Â¬ c.Rel i j) :\n    d Ï† i j = 0 :=\n  dif_neg hij\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrX_d","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni j : Î¹\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX Ï† i) (HomologicalComplex.homotopyCofiber.d Ï† i j)) (CategoryTheory.CategoryStruct.comp (G.d i j) (HomologicalComplex.homotopyCofiber.inrX Ï† j))","decl":"@[reassoc (attr := simp)]\nlemma inrX_d (i j : Î¹) :\n    inrX Ï† i â‰« d Ï† i j = G.d i j â‰« inrX Ï† j := by\n  by_cases hij : c.Rel i j\n  Â· by_cases hj : c.Rel j (c.next j)\n    Â· apply ext_to_X _ _ _ hj\n      Â· simp [d_fstX Ï† _ _ _ hij]\n      Â· simp [d_sndX Ï† _ _ hij]\n    Â· apply ext_to_X' _ _ hj\n      simp [d_sndX Ï† _ _ hij]\n  Â· rw [shape Ï† _ _ hij, G.shape _ _ hij, zero_comp, comp_zero]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrX_d_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni j : Î¹\nZ : C\nh : Quiver.Hom (HomologicalComplex.homotopyCofiber.X Ï† j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX Ï† i) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.d Ï† i j) h)) (CategoryTheory.CategoryStruct.comp (G.d i j) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX Ï† j) h))","decl":"@[reassoc (attr := simp)]\nlemma inrX_d (i j : Î¹) :\n    inrX Ï† i â‰« d Ï† i j = G.d i j â‰« inrX Ï† j := by\n  by_cases hij : c.Rel i j\n  Â· by_cases hj : c.Rel j (c.next j)\n    Â· apply ext_to_X _ _ _ hj\n      Â· simp [d_fstX Ï† _ _ _ hij]\n      Â· simp [d_sndX Ï† _ _ hij]\n    Â· apply ext_to_X' _ _ hj\n      simp [d_sndX Ï† _ _ hij]\n  Â· rw [shape Ï† _ _ hij, G.shape _ _ hij, zero_comp, comp_zero]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber_d","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni j : Î¹\nâŠ¢ Eq ((HomologicalComplex.homotopyCofiber Ï†).d i j) (HomologicalComplex.homotopyCofiber.d Ï† i j)","decl":"/-- The homotopy cofiber of a morphism of homological complexes,\nalso known as the mapping cone. -/\n@[simps]\nnoncomputable def homotopyCofiber : HomologicalComplex C c where\n  X i := homotopyCofiber.X Ï† i\n  d i j := homotopyCofiber.d Ï† i j\n  shape i j hij := homotopyCofiber.shape Ï† i j hij\n  d_comp_d' i j k hij hjk := by\n    apply homotopyCofiber.ext_from_X Ï† j i hij\n    Â· dsimp\n      simp only [comp_zero, homotopyCofiber.inlX_d_assoc Ï† i j k hij hjk,\n        add_comp, assoc, homotopyCofiber.inrX_d, Hom.comm_assoc, neg_comp]\n      by_cases hk : c.Rel k (c.next k)\n      Â· simp [homotopyCofiber.inlX_d Ï† j k _ hjk hk]\n      Â· simp [homotopyCofiber.inlX_d' Ï† j k hjk hk]\n    Â· simp\n\n"}
{"name":"HomologicalComplex.homotopyCofiber_X","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni : Î¹\nâŠ¢ Eq ((HomologicalComplex.homotopyCofiber Ï†).X i) (HomologicalComplex.homotopyCofiber.X Ï† i)","decl":"/-- The homotopy cofiber of a morphism of homological complexes,\nalso known as the mapping cone. -/\n@[simps]\nnoncomputable def homotopyCofiber : HomologicalComplex C c where\n  X i := homotopyCofiber.X Ï† i\n  d i j := homotopyCofiber.d Ï† i j\n  shape i j hij := homotopyCofiber.shape Ï† i j hij\n  d_comp_d' i j k hij hjk := by\n    apply homotopyCofiber.ext_from_X Ï† j i hij\n    Â· dsimp\n      simp only [comp_zero, homotopyCofiber.inlX_d_assoc Ï† i j k hij hjk,\n        add_comp, assoc, homotopyCofiber.inrX_d, Hom.comm_assoc, neg_comp]\n      by_cases hk : c.Rel k (c.next k)\n      Â· simp [homotopyCofiber.inlX_d Ï† j k _ hjk hk]\n      Â· simp [homotopyCofiber.inlX_d' Ï† j k hjk hk]\n    Â· simp\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inr_f","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni : Î¹\nâŠ¢ Eq ((HomologicalComplex.homotopyCofiber.inr Ï†).f i) (HomologicalComplex.homotopyCofiber.inrX Ï† i)","decl":"/-- The right inclusion `G âŸ¶ homotopyCofiber Ï†`. -/\n@[simps!]\nnoncomputable def inr : G âŸ¶ homotopyCofiber Ï† where\n  f i := inrX Ï† i\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrCompHomotopy_hom","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\nhc : âˆ€ (j : Î¹), Exists fun i => c.Rel i j\ni j : Î¹\nhij : c.Rel j i\nâŠ¢ Eq ((HomologicalComplex.homotopyCofiber.inrCompHomotopy Ï† hc).hom i j) (HomologicalComplex.homotopyCofiber.inlX Ï† i j hij)","decl":"lemma inrCompHomotopy_hom (i j : Î¹) (hij : c.Rel j i) :\n    (inrCompHomotopy Ï† hc).hom i j = inlX Ï† i j hij := dif_pos hij\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrCompHomotopy_hom_eq_zero","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\nhc : âˆ€ (j : Î¹), Exists fun i => c.Rel i j\ni j : Î¹\nhij : Not (c.Rel j i)\nâŠ¢ Eq ((HomologicalComplex.homotopyCofiber.inrCompHomotopy Ï† hc).hom i j) 0","decl":"lemma inrCompHomotopy_hom_eq_zero (i j : Î¹) (hij : Â¬ c.Rel j i) :\n    (inrCompHomotopy Ï† hc).hom i j = 0 := dif_neg hij\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.desc_f","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G K : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\nÎ± : Quiver.Hom G K\nhÎ± : Homotopy (CategoryTheory.CategoryStruct.comp Ï† Î±) 0\nj k : Î¹\nhjk : c.Rel j k\nâŠ¢ Eq ((HomologicalComplex.homotopyCofiber.desc Ï† Î± hÎ±).f j) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.fstX Ï† j k hjk) (hÎ±.hom k j)) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.sndX Ï† j) (Î±.f j)))","decl":"lemma desc_f (j k : Î¹) (hjk : c.Rel j k) :\n    (desc Ï† Î± hÎ±).f j = fstX Ï† j _ hjk â‰« hÎ±.hom _ j + sndX Ï† j â‰« Î±.f j := by\n  obtain rfl := c.next_eq' hjk\n  apply dif_pos hjk\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.desc_f'","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G K : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\nÎ± : Quiver.Hom G K\nhÎ± : Homotopy (CategoryTheory.CategoryStruct.comp Ï† Î±) 0\nj : Î¹\nhj : Not (c.Rel j (c.next j))\nâŠ¢ Eq ((HomologicalComplex.homotopyCofiber.desc Ï† Î± hÎ±).f j) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.sndX Ï† j) (Î±.f j))","decl":"lemma desc_f' (j : Î¹) (hj : Â¬ c.Rel j (c.next j)) :\n    (desc Ï† Î± hÎ±).f j = sndX Ï† j â‰« Î±.f j := by\n  apply dif_neg hj\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inlX_desc_f_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G K : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\nÎ± : Quiver.Hom G K\nhÎ± : Homotopy (CategoryTheory.CategoryStruct.comp Ï† Î±) 0\ni j : Î¹\nhjk : c.Rel j i\nZ : C\nh : Quiver.Hom (K.X j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX Ï† i j hjk) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homotopyCofiber.desc Ï† Î± hÎ±).f j) h)) (CategoryTheory.CategoryStruct.comp (hÎ±.hom i j) h)","decl":"@[reassoc (attr := simp)]\nlemma inlX_desc_f (i j : Î¹) (hjk : c.Rel j i) :\n    inlX Ï† i j hjk â‰« (desc Ï† Î± hÎ±).f j = hÎ±.hom i j := by\n  obtain rfl := c.next_eq' hjk\n  dsimp [desc]\n  rw [dif_pos hjk, comp_add, inlX_fstX_assoc, inlX_sndX_assoc, zero_comp, add_zero]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inlX_desc_f","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G K : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\nÎ± : Quiver.Hom G K\nhÎ± : Homotopy (CategoryTheory.CategoryStruct.comp Ï† Î±) 0\ni j : Î¹\nhjk : c.Rel j i\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inlX Ï† i j hjk) ((HomologicalComplex.homotopyCofiber.desc Ï† Î± hÎ±).f j)) (hÎ±.hom i j)","decl":"@[reassoc (attr := simp)]\nlemma inlX_desc_f (i j : Î¹) (hjk : c.Rel j i) :\n    inlX Ï† i j hjk â‰« (desc Ï† Î± hÎ±).f j = hÎ±.hom i j := by\n  obtain rfl := c.next_eq' hjk\n  dsimp [desc]\n  rw [dif_pos hjk, comp_add, inlX_fstX_assoc, inlX_sndX_assoc, zero_comp, add_zero]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrX_desc_f_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G K : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\nÎ± : Quiver.Hom G K\nhÎ± : Homotopy (CategoryTheory.CategoryStruct.comp Ï† Î±) 0\ni : Î¹\nZ : C\nh : Quiver.Hom (K.X i) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX Ï† i) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homotopyCofiber.desc Ï† Î± hÎ±).f i) h)) (CategoryTheory.CategoryStruct.comp (Î±.f i) h)","decl":"@[reassoc (attr := simp)]\nlemma inrX_desc_f (i : Î¹) :\n    inrX Ï† i â‰« (desc Ï† Î± hÎ±).f i = Î±.f i := by\n  dsimp [desc]\n  split_ifs <;> simp\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrX_desc_f","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G K : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\nÎ± : Quiver.Hom G K\nhÎ± : Homotopy (CategoryTheory.CategoryStruct.comp Ï† Î±) 0\ni : Î¹\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inrX Ï† i) ((HomologicalComplex.homotopyCofiber.desc Ï† Î± hÎ±).f i)) (Î±.f i)","decl":"@[reassoc (attr := simp)]\nlemma inrX_desc_f (i : Î¹) :\n    inrX Ï† i â‰« (desc Ï† Î± hÎ±).f i = Î±.f i := by\n  dsimp [desc]\n  split_ifs <;> simp\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inr_desc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G K : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\nÎ± : Quiver.Hom G K\nhÎ± : Homotopy (CategoryTheory.CategoryStruct.comp Ï† Î±) 0\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inr Ï†) (HomologicalComplex.homotopyCofiber.desc Ï† Î± hÎ±)) Î±","decl":"@[reassoc (attr := simp)]\nlemma inr_desc :\n    inr Ï† â‰« desc Ï† Î± hÎ± = Î± := by aesop_cat\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inr_desc_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G K : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\nÎ± : Quiver.Hom G K\nhÎ± : Homotopy (CategoryTheory.CategoryStruct.comp Ï† Î±) 0\nZ : HomologicalComplex C c\nh : Quiver.Hom K Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inr Ï†) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.desc Ï† Î± hÎ±) h)) (CategoryTheory.CategoryStruct.comp Î± h)","decl":"@[reassoc (attr := simp)]\nlemma inr_desc :\n    inr Ï† â‰« desc Ï† Î± hÎ± = Î± := by aesop_cat\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrCompHomotopy_hom_desc_hom","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G K : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\nÎ± : Quiver.Hom G K\nhÎ± : Homotopy (CategoryTheory.CategoryStruct.comp Ï† Î±) 0\nhc : âˆ€ (j : Î¹), Exists fun i => c.Rel i j\ni j : Î¹\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homotopyCofiber.inrCompHomotopy Ï† hc).hom i j) ((HomologicalComplex.homotopyCofiber.desc Ï† Î± hÎ±).f j)) (hÎ±.hom i j)","decl":"@[reassoc (attr := simp)]\nlemma inrCompHomotopy_hom_desc_hom (hc : âˆ€ j, âˆƒ i, c.Rel i j) (i j : Î¹) :\n    (inrCompHomotopy Ï† hc).hom i j â‰« (desc Ï† Î± hÎ±).f j = hÎ±.hom i j := by\n  by_cases hij : c.Rel j i\n  Â· dsimp\n    simp only [inrCompHomotopy_hom Ï† hc i j hij, desc_f Ï† Î± hÎ± _ _ hij,\n      comp_add, inlX_fstX_assoc, inlX_sndX_assoc, zero_comp, add_zero]\n  Â· simp only [Homotopy.zero _ _ _ hij, zero_comp]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.inrCompHomotopy_hom_desc_hom_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G K : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\nÎ± : Quiver.Hom G K\nhÎ± : Homotopy (CategoryTheory.CategoryStruct.comp Ï† Î±) 0\nhc : âˆ€ (j : Î¹), Exists fun i => c.Rel i j\ni j : Î¹\nZ : C\nh : Quiver.Hom (K.X j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homotopyCofiber.inrCompHomotopy Ï† hc).hom i j) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homotopyCofiber.desc Ï† Î± hÎ±).f j) h)) (CategoryTheory.CategoryStruct.comp (hÎ±.hom i j) h)","decl":"@[reassoc (attr := simp)]\nlemma inrCompHomotopy_hom_desc_hom (hc : âˆ€ j, âˆƒ i, c.Rel i j) (i j : Î¹) :\n    (inrCompHomotopy Ï† hc).hom i j â‰« (desc Ï† Î± hÎ±).f j = hÎ±.hom i j := by\n  by_cases hij : c.Rel j i\n  Â· dsimp\n    simp only [inrCompHomotopy_hom Ï† hc i j hij, desc_f Ï† Î± hÎ± _ _ hij,\n      comp_add, inlX_fstX_assoc, inlX_sndX_assoc, zero_comp, add_zero]\n  Â· simp only [Homotopy.zero _ _ _ hij, zero_comp]\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.eq_desc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G K : HomologicalComplex C c\nÏ† : Quiver.Hom F G\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\nf : Quiver.Hom (HomologicalComplex.homotopyCofiber Ï†) K\nhc : âˆ€ (j : Î¹), Exists fun i => c.Rel i j\nâŠ¢ Eq f (HomologicalComplex.homotopyCofiber.desc Ï† (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homotopyCofiber.inr Ï†) f) ((Homotopy.ofEq â‹¯).trans (((HomologicalComplex.homotopyCofiber.inrCompHomotopy Ï† hc).compRight f).trans (Homotopy.ofEq â‹¯))))","decl":"lemma eq_desc (f : homotopyCofiber Ï† âŸ¶ K) (hc : âˆ€ j, âˆƒ i, c.Rel i j) :\n    f = desc Ï† (inr Ï† â‰« f) (Homotopy.trans (Homotopy.ofEq (by simp))\n      (((inrCompHomotopy Ï† hc).compRight f).trans (Homotopy.ofEq (by simp)))) := by\n  ext j\n  by_cases hj : c.Rel j (c.next j)\n  Â· apply ext_from_X Ï† _ _ hj\n    Â· simp [inrCompHomotopy_hom _ _ _ _ hj]\n    Â· simp\n  Â· apply ext_from_X' Ï† _ hj\n    simp\n\n"}
{"name":"HomologicalComplex.homotopyCofiber.descSigma_ext_iff","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\ninstâœ : DecidableRel c.Rel\nÏ† : Quiver.Hom F G\nK : HomologicalComplex C c\nx y : Sigma fun Î± => Homotopy (CategoryTheory.CategoryStruct.comp Ï† Î±) 0\nâŠ¢ Iff (Eq x y) (And (Eq x.fst y.fst) (âˆ€ (i j : Î¹), c.Rel j i â†’ Eq (x.snd.hom i j) (y.snd.hom i j)))","decl":"lemma descSigma_ext_iff {Ï† : F âŸ¶ G} {K : HomologicalComplex C c}\n    (x y : Î£ (Î± : G âŸ¶ K), Homotopy (Ï† â‰« Î±) 0) :\n    x = y â†” x.1 = y.1 âˆ§ (âˆ€ (i j : Î¹) (_ : c.Rel j i), x.2.hom i j = y.2.hom i j) := by\n  constructor\n  Â· rintro rfl\n    tauto\n  Â· obtain âŸ¨xâ‚, xâ‚‚âŸ© := x\n    obtain âŸ¨yâ‚, yâ‚‚âŸ© := y\n    rintro âŸ¨rfl, hâŸ©\n    simp only [Sigma.mk.inj_iff, heq_eq_eq, true_and]\n    ext i j\n    by_cases hij : c.Rel j i\n    Â· exact h _ _ hij\n    Â· simp only [Homotopy.zero _ _ _ hij]\n\n"}
{"name":"HomologicalComplex.cylinder.Î¹â‚€_desc_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF K : HomologicalComplex C c\ninstâœÂ² : DecidableRel c.Rel\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninstâœ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\nÏ†â‚€ Ï†â‚ : Quiver.Hom K F\nhâœ : Homotopy Ï†â‚€ Ï†â‚\nZ : HomologicalComplex C c\nh : Quiver.Hom F Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.Î¹â‚€ K) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.desc Ï†â‚€ Ï†â‚ hâœ) h)) (CategoryTheory.CategoryStruct.comp Ï†â‚€ h)","decl":"@[reassoc (attr := simp)]\nlemma Î¹â‚€_desc : Î¹â‚€ K â‰« desc Ï†â‚€ Ï†â‚ h = Ï†â‚€ := by simp [Î¹â‚€, desc]\n\n"}
{"name":"HomologicalComplex.cylinder.Î¹â‚€_desc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF K : HomologicalComplex C c\ninstâœÂ² : DecidableRel c.Rel\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninstâœ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\nÏ†â‚€ Ï†â‚ : Quiver.Hom K F\nh : Homotopy Ï†â‚€ Ï†â‚\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.Î¹â‚€ K) (HomologicalComplex.cylinder.desc Ï†â‚€ Ï†â‚ h)) Ï†â‚€","decl":"@[reassoc (attr := simp)]\nlemma Î¹â‚€_desc : Î¹â‚€ K â‰« desc Ï†â‚€ Ï†â‚ h = Ï†â‚€ := by simp [Î¹â‚€, desc]\n\n"}
{"name":"HomologicalComplex.cylinder.Î¹â‚_desc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF K : HomologicalComplex C c\ninstâœÂ² : DecidableRel c.Rel\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninstâœ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\nÏ†â‚€ Ï†â‚ : Quiver.Hom K F\nh : Homotopy Ï†â‚€ Ï†â‚\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.Î¹â‚ K) (HomologicalComplex.cylinder.desc Ï†â‚€ Ï†â‚ h)) Ï†â‚","decl":"@[reassoc (attr := simp)]\nlemma Î¹â‚_desc : Î¹â‚ K â‰« desc Ï†â‚€ Ï†â‚ h = Ï†â‚ := by simp [Î¹â‚, desc]\n\n"}
{"name":"HomologicalComplex.cylinder.Î¹â‚_desc_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF K : HomologicalComplex C c\ninstâœÂ² : DecidableRel c.Rel\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninstâœ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\nÏ†â‚€ Ï†â‚ : Quiver.Hom K F\nhâœ : Homotopy Ï†â‚€ Ï†â‚\nZ : HomologicalComplex C c\nh : Quiver.Hom F Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.Î¹â‚ K) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.desc Ï†â‚€ Ï†â‚ hâœ) h)) (CategoryTheory.CategoryStruct.comp Ï†â‚ h)","decl":"@[reassoc (attr := simp)]\nlemma Î¹â‚_desc : Î¹â‚ K â‰« desc Ï†â‚€ Ï†â‚ h = Ï†â‚ := by simp [Î¹â‚, desc]\n\n"}
{"name":"HomologicalComplex.cylinder.Î¹â‚€_Ï€_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nK : HomologicalComplex C c\ninstâœÂ² : DecidableRel c.Rel\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninstâœ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\nZ : HomologicalComplex C c\nh : Quiver.Hom K Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.Î¹â‚€ K) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.Ï€ K) h)) h","decl":"@[reassoc (attr := simp)]\nlemma Î¹â‚€_Ï€ : Î¹â‚€ K â‰« Ï€ K = ğŸ™ K := by simp [Ï€]\n\n"}
{"name":"HomologicalComplex.cylinder.Î¹â‚€_Ï€","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nK : HomologicalComplex C c\ninstâœÂ² : DecidableRel c.Rel\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninstâœ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.Î¹â‚€ K) (HomologicalComplex.cylinder.Ï€ K)) (CategoryTheory.CategoryStruct.id K)","decl":"@[reassoc (attr := simp)]\nlemma Î¹â‚€_Ï€ : Î¹â‚€ K â‰« Ï€ K = ğŸ™ K := by simp [Ï€]\n\n"}
{"name":"HomologicalComplex.cylinder.Î¹â‚_Ï€_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nK : HomologicalComplex C c\ninstâœÂ² : DecidableRel c.Rel\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninstâœ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\nZ : HomologicalComplex C c\nh : Quiver.Hom K Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.Î¹â‚ K) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.Ï€ K) h)) h","decl":"@[reassoc (attr := simp)]\nlemma Î¹â‚_Ï€ : Î¹â‚ K â‰« Ï€ K = ğŸ™ K := by simp [Ï€]\n\n"}
{"name":"HomologicalComplex.cylinder.Î¹â‚_Ï€","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nK : HomologicalComplex C c\ninstâœÂ² : DecidableRel c.Rel\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninstâœ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.Î¹â‚ K) (HomologicalComplex.cylinder.Ï€ K)) (CategoryTheory.CategoryStruct.id K)","decl":"@[reassoc (attr := simp)]\nlemma Î¹â‚_Ï€ : Î¹â‚ K â‰« Ï€ K = ğŸ™ K := by simp [Ï€]\n\n"}
{"name":"HomologicalComplex.cylinder.inlX_Ï€","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nK : HomologicalComplex C c\ninstâœÂ² : DecidableRel c.Rel\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninstâœ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\ni j : Î¹\nhij : c.Rel j i\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.inlX K i j hij) ((HomologicalComplex.cylinder.Ï€ K).f j)) 0","decl":"@[reassoc (attr := simp)]\nlemma inlX_Ï€ (i j : Î¹) (hij : c.Rel j i) :\n    inlX K i j hij â‰« (Ï€ K).f j = 0 := by\n  erw [homotopyCofiber.inlX_desc_f]\n  simp [Homotopy.equivSubZero]\n\n"}
{"name":"HomologicalComplex.cylinder.inlX_Ï€_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nK : HomologicalComplex C c\ninstâœÂ² : DecidableRel c.Rel\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninstâœ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\ni j : Î¹\nhij : c.Rel j i\nZ : C\nh : Quiver.Hom (K.X j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.inlX K i j hij) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.cylinder.Ï€ K).f j) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma inlX_Ï€ (i j : Î¹) (hij : c.Rel j i) :\n    inlX K i j hij â‰« (Ï€ K).f j = 0 := by\n  erw [homotopyCofiber.inlX_desc_f]\n  simp [Homotopy.equivSubZero]\n\n"}
{"name":"HomologicalComplex.cylinder.inrX_Ï€_assoc","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nK : HomologicalComplex C c\ninstâœÂ² : DecidableRel c.Rel\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninstâœ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\ni : Î¹\nZ : C\nh : Quiver.Hom (K.X i) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.inrX K i) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.cylinder.Ï€ K).f i) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.biprod.desc (CategoryTheory.CategoryStruct.id K) (CategoryTheory.CategoryStruct.id K)).f i) h)","decl":"@[reassoc (attr := simp)]\nlemma inrX_Ï€ (i : Î¹) :\n    inrX K i â‰« (Ï€ K).f i = (biprod.desc (ğŸ™ _) (ğŸ™ K)).f i :=\n  homotopyCofiber.inrX_desc_f _ _ _ _\n\n"}
{"name":"HomologicalComplex.cylinder.inrX_Ï€","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nK : HomologicalComplex C c\ninstâœÂ² : DecidableRel c.Rel\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninstâœ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\ni : Î¹\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.inrX K i) ((HomologicalComplex.cylinder.Ï€ K).f i)) ((CategoryTheory.Limits.biprod.desc (CategoryTheory.CategoryStruct.id K) (CategoryTheory.CategoryStruct.id K)).f i)","decl":"@[reassoc (attr := simp)]\nlemma inrX_Ï€ (i : Î¹) :\n    inrX K i â‰« (Ï€ K).f i = (biprod.desc (ğŸ™ _) (ğŸ™ K)).f i :=\n  homotopyCofiber.inrX_desc_f _ _ _ _\n\n"}
{"name":"HomologicalComplex.cylinder.Ï€CompÎ¹â‚€Homotopy.inlX_nullHomotopy_f","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nK : HomologicalComplex C c\ninstâœÂ² : DecidableRel c.Rel\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninstâœ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\ni j : Î¹\nhij : c.Rel j i\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.inlX K i j hij) ((HomologicalComplex.cylinder.Ï€CompÎ¹â‚€Homotopy.nullHomotopicMap K).f j)) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.inlX K i j hij) ((HSub.hSub (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.Ï€ K) (HomologicalComplex.cylinder.Î¹â‚€ K)) (CategoryTheory.CategoryStruct.id K.cylinder)).f j))","decl":"lemma inlX_nullHomotopy_f (i j : Î¹) (hij : c.Rel j i) :\n    inlX K i j hij â‰« (nullHomotopicMap K).f j =\n      inlX K i j hij â‰« (Ï€ K â‰« Î¹â‚€ K - ğŸ™ _).f j := by\n  dsimp [nullHomotopicMap]\n  by_cases hj : âˆƒ (k : Î¹), c.Rel k j\n  Â· obtain âŸ¨k, hjkâŸ© := hj\n    simp only [assoc, Homotopy.nullHomotopicMap'_f hjk hij, homotopyCofiber_X, homotopyCofiber_d,\n      homotopyCofiber.d_sndX_assoc _ _ _ hij, add_comp, comp_add, homotopyCofiber.inlX_fstX_assoc,\n      homotopyCofiber.inlX_sndX_assoc, zero_comp, add_zero, comp_sub, inlX_Ï€_assoc, comp_id,\n      zero_sub, â† HomologicalComplex.comp_f_assoc, biprod.lift_snd, neg_f_apply, id_f,\n      neg_comp, id_comp]\n  Â· simp only [not_exists] at hj\n    simp only [Homotopy.nullHomotopicMap'_f_of_not_rel_right hij hj,\n      homotopyCofiber_X, homotopyCofiber_d, assoc, comp_sub, comp_id,\n      homotopyCofiber.d_sndX_assoc _ _ _ hij, add_comp, comp_add, zero_comp, add_zero,\n      homotopyCofiber.inlX_fstX_assoc, homotopyCofiber.inlX_sndX_assoc,\n      â† HomologicalComplex.comp_f_assoc, biprod.lift_snd, neg_f_apply, id_f, neg_comp,\n      id_comp, inlX_Ï€_assoc, zero_sub]\n\n"}
{"name":"HomologicalComplex.cylinder.Ï€CompÎ¹â‚€Homotopy.inrX_nullHomotopy_f","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nK : HomologicalComplex C c\ninstâœÂ² : DecidableRel c.Rel\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninstâœ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\nhc : âˆ€ (j : Î¹), Exists fun i => c.Rel i j\nj : Î¹\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.inrX K j) ((HomologicalComplex.cylinder.Ï€CompÎ¹â‚€Homotopy.nullHomotopicMap K).f j)) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.inrX K j) ((HSub.hSub (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.Ï€ K) (HomologicalComplex.cylinder.Î¹â‚€ K)) (CategoryTheory.CategoryStruct.id K.cylinder)).f j))","decl":"lemma inrX_nullHomotopy_f (j : Î¹) :\n    inrX K j â‰« (nullHomotopicMap K).f j = inrX K j â‰« (Ï€ K â‰« Î¹â‚€ K - ğŸ™ _).f j := by\n  have : biprod.lift (ğŸ™ K) (-ğŸ™ K) = biprod.inl - biprod.inr :=\n    biprod.hom_ext _ _ (by simp) (by simp)\n  obtain âŸ¨i, hijâŸ© := hc j\n  dsimp [nullHomotopicMap]\n  by_cases hj : âˆƒ (k : Î¹), c.Rel j k\n  Â· obtain âŸ¨k, hjkâŸ© := hj\n    simp only [Homotopy.nullHomotopicMap'_f hij hjk,\n      homotopyCofiber_X, homotopyCofiber_d, assoc, comp_add,\n      homotopyCofiber.inrX_d_assoc, homotopyCofiber.inrX_sndX_assoc, comp_sub,\n      inrX_Ï€_assoc, comp_id, â† Hom.comm_assoc, homotopyCofiber.inlX_d _ _ _ _ _ hjk,\n      comp_neg, add_neg_cancel_left]\n    rw [â† cancel_epi (biprodXIso K K j).inv]\n    ext\n    Â· simp [Î¹â‚€]\n    Â· dsimp\n      simp only [inr_biprodXIso_inv_assoc, biprod_inr_snd_f_assoc, comp_sub,\n        biprod_inr_desc_f_assoc, id_f, id_comp, Î¹â‚€, comp_f, this,\n        sub_f_apply, sub_comp, homotopyCofiber_X, homotopyCofiber.inr_f]\n  Â· simp only [not_exists] at hj\n    simp only [assoc, Homotopy.nullHomotopicMap'_f_of_not_rel_left hij hj, homotopyCofiber_X,\n      homotopyCofiber_d, homotopyCofiber.inlX_d' _ _ _ _ (hj _), homotopyCofiber.inrX_sndX_assoc,\n      comp_sub, inrX_Ï€_assoc, comp_id, Î¹â‚€, comp_f, homotopyCofiber.inr_f]\n    rw [â† cancel_epi (biprodXIso K K j).inv]\n    ext\n    Â· simp\n    Â· simp [this]\n\n"}
{"name":"HomologicalComplex.cylinder.Ï€CompÎ¹â‚€Homotopy.nullHomotopicMap_eq","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nK : HomologicalComplex C c\ninstâœÂ² : DecidableRel c.Rel\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninstâœ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\nhc : âˆ€ (j : Î¹), Exists fun i => c.Rel i j\nâŠ¢ Eq (HomologicalComplex.cylinder.Ï€CompÎ¹â‚€Homotopy.nullHomotopicMap K) (HSub.hSub (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cylinder.Ï€ K) (HomologicalComplex.cylinder.Î¹â‚€ K)) (CategoryTheory.CategoryStruct.id K.cylinder))","decl":"lemma nullHomotopicMap_eq : nullHomotopicMap K = Ï€ K â‰« Î¹â‚€ K - ğŸ™ _ := by\n  ext i\n  by_cases hi : c.Rel i (c.next i)\n  Â· exact homotopyCofiber.ext_from_X (biprod.lift (ğŸ™ K) (-ğŸ™ K)) (c.next i) i hi\n      (inlX_nullHomotopy_f _ _ _ _) (inrX_nullHomotopy_f _ hc _)\n  Â· exact homotopyCofiber.ext_from_X' (biprod.lift (ğŸ™ K) (-ğŸ™ K)) _ hi (inrX_nullHomotopy_f _ hc _)\n\n"}
{"name":"HomologicalComplex.cylinder.map_Î¹â‚€_eq_map_Î¹â‚","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nK : HomologicalComplex C c\ninstâœÂ³ : DecidableRel c.Rel\ninstâœÂ² : âˆ€ (i : Î¹), CategoryTheory.Limits.HasBinaryBiproduct (K.X i) (K.X i)\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id K) (Neg.neg (CategoryTheory.CategoryStruct.id K)))\nhc : âˆ€ (j : Î¹), Exists fun i => c.Rel i j\nD : Type u_3\ninstâœ : CategoryTheory.Category.{u_4, u_3} D\nH : CategoryTheory.Functor (HomologicalComplex C c) D\nhH : (HomologicalComplex.homotopyEquivalences C c).IsInvertedBy H\nâŠ¢ Eq (H.map (HomologicalComplex.cylinder.Î¹â‚€ K)) (H.map (HomologicalComplex.cylinder.Î¹â‚ K))","decl":"include hc in\nlemma map_Î¹â‚€_eq_map_Î¹â‚ {D : Type*} [Category D] (H : HomologicalComplex C c â¥¤ D)\n    (hH : (homotopyEquivalences C c).IsInvertedBy H) :\n    H.map (Î¹â‚€ K) = H.map (Î¹â‚ K) := by\n  have : IsIso (H.map (cylinder.Ï€ K)) := hH _ âŸ¨homotopyEquiv K hc, rflâŸ©\n  simp only [â† cancel_mono (H.map (cylinder.Ï€ K)), â† H.map_comp, Î¹â‚€_Ï€, H.map_id, Î¹â‚_Ï€]\n\n"}
{"name":"Homotopy.map_eq_of_inverts_homotopyEquivalences","module":"Mathlib.Algebra.Homology.HomotopyCofiber","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G : HomologicalComplex C c\ninstâœÂ³ : DecidableRel c.Rel\nÏ†â‚€ Ï†â‚ : Quiver.Hom F G\nh : Homotopy Ï†â‚€ Ï†â‚\nhc : âˆ€ (j : Î¹), Exists fun i => c.Rel i j\ninstâœÂ² : âˆ€ (i : Î¹), CategoryTheory.Limits.HasBinaryBiproduct (F.X i) (F.X i)\ninstâœÂ¹ : HomologicalComplex.HasHomotopyCofiber (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id F) (Neg.neg (CategoryTheory.CategoryStruct.id F)))\nD : Type u_3\ninstâœ : CategoryTheory.Category.{u_5, u_3} D\nH : CategoryTheory.Functor (HomologicalComplex C c) D\nhH : (HomologicalComplex.homotopyEquivalences C c).IsInvertedBy H\nâŠ¢ Eq (H.map Ï†â‚€) (H.map Ï†â‚)","decl":"/-- If a functor inverts homotopy equivalences, it sends homotopic maps to the same map. -/\nlemma _root_.Homotopy.map_eq_of_inverts_homotopyEquivalences\n    {Ï†â‚€ Ï†â‚ : F âŸ¶ G} (h : Homotopy Ï†â‚€ Ï†â‚)(hc : âˆ€ j, âˆƒ i, c.Rel i j)\n    [âˆ€ i, HasBinaryBiproduct (F.X i) (F.X i)]\n    [HasHomotopyCofiber (biprod.lift (ğŸ™ F) (-ğŸ™ F))]\n    {D : Type*} [Category D] (H : HomologicalComplex C c â¥¤ D)\n    (hH : (homotopyEquivalences C c).IsInvertedBy H) :\n    H.map Ï†â‚€ = H.map Ï†â‚ := by\n  simp only [â† cylinder.Î¹â‚€_desc _ _ h, â† cylinder.Î¹â‚_desc _ _ h, H.map_comp,\n    cylinder.map_Î¹â‚€_eq_map_Î¹â‚ _ hc _ hH]\n\n"}
