{"name":"Finsupp.mem_support_toFun","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_13\nM : Type u_14\ninst✝ : Zero M\nself : Finsupp α M\na : α\n⊢ Iff (Membership.mem self.support a) (Ne (self.toFun a) 0)","decl":"/-- `Finsupp α M`, denoted `α →₀ M`, is the type of functions `f : α → M` such that\n  `f x = 0` for all but finitely many `x`. -/\nstructure Finsupp (α : Type*) (M : Type*) [Zero M] where\n  /-- The support of a finitely supported function (aka `Finsupp`). -/\n  support : Finset α\n  /-- The underlying function of a bundled finitely supported function (aka `Finsupp`). -/\n  toFun : α → M\n  /-- The witness that the support of a `Finsupp` is indeed the exact locus where its\n  underlying function is nonzero. -/\n  mem_support_toFun : ∀ a, a ∈ support ↔ toFun a ≠ 0\n\n"}
{"name":"Finsupp.mk.injEq","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_13\nM : Type u_14\ninst✝ : Zero M\nsupport✝ : Finset α\ntoFun✝ : α → M\nmem_support_toFun✝ : ∀ (a : α), Iff (Membership.mem support✝ a) (Ne (toFun✝ a) 0)\nsupport : Finset α\ntoFun : α → M\nmem_support_toFun : ∀ (a : α), Iff (Membership.mem support a) (Ne (toFun a) 0)\n⊢ Eq (Eq { support := support✝, toFun := toFun✝, mem_support_toFun := mem_support_toFun✝ } { support := support, toFun := toFun, mem_support_toFun := mem_support_toFun }) (And (Eq support✝ support) (Eq toFun✝ toFun))","decl":"/-- `Finsupp α M`, denoted `α →₀ M`, is the type of functions `f : α → M` such that\n  `f x = 0` for all but finitely many `x`. -/\nstructure Finsupp (α : Type*) (M : Type*) [Zero M] where\n  /-- The support of a finitely supported function (aka `Finsupp`). -/\n  support : Finset α\n  /-- The underlying function of a bundled finitely supported function (aka `Finsupp`). -/\n  toFun : α → M\n  /-- The witness that the support of a `Finsupp` is indeed the exact locus where its\n  underlying function is nonzero. -/\n  mem_support_toFun : ∀ a, a ∈ support ↔ toFun a ≠ 0\n\n"}
{"name":"Finsupp.mk.sizeOf_spec","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_13\nM : Type u_14\ninst✝² : Zero M\ninst✝¹ : SizeOf α\ninst✝ : SizeOf M\nsupport : Finset α\ntoFun : α → M\nmem_support_toFun : ∀ (a : α), Iff (Membership.mem support a) (Ne (toFun a) 0)\n⊢ Eq (SizeOf.sizeOf { support := support, toFun := toFun, mem_support_toFun := mem_support_toFun }) (HAdd.hAdd 1 (SizeOf.sizeOf support))","decl":"/-- `Finsupp α M`, denoted `α →₀ M`, is the type of functions `f : α → M` such that\n  `f x = 0` for all but finitely many `x`. -/\nstructure Finsupp (α : Type*) (M : Type*) [Zero M] where\n  /-- The support of a finitely supported function (aka `Finsupp`). -/\n  support : Finset α\n  /-- The underlying function of a bundled finitely supported function (aka `Finsupp`). -/\n  toFun : α → M\n  /-- The witness that the support of a `Finsupp` is indeed the exact locus where its\n  underlying function is nonzero. -/\n  mem_support_toFun : ∀ a, a ∈ support ↔ toFun a ≠ 0\n\n"}
{"name":"Finsupp.mk.inj","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_13\nM : Type u_14\ninst✝ : Zero M\nsupport✝ : Finset α\ntoFun✝ : α → M\nmem_support_toFun✝ : ∀ (a : α), Iff (Membership.mem support✝ a) (Ne (toFun✝ a) 0)\nsupport : Finset α\ntoFun : α → M\nmem_support_toFun : ∀ (a : α), Iff (Membership.mem support a) (Ne (toFun a) 0)\nx✝ : Eq { support := support✝, toFun := toFun✝, mem_support_toFun := mem_support_toFun✝ } { support := support, toFun := toFun, mem_support_toFun := mem_support_toFun }\n⊢ And (Eq support✝ support) (Eq toFun✝ toFun)","decl":"/-- `Finsupp α M`, denoted `α →₀ M`, is the type of functions `f : α → M` such that\n  `f x = 0` for all but finitely many `x`. -/\nstructure Finsupp (α : Type*) (M : Type*) [Zero M] where\n  /-- The support of a finitely supported function (aka `Finsupp`). -/\n  support : Finset α\n  /-- The underlying function of a bundled finitely supported function (aka `Finsupp`). -/\n  toFun : α → M\n  /-- The witness that the support of a `Finsupp` is indeed the exact locus where its\n  underlying function is nonzero. -/\n  mem_support_toFun : ∀ a, a ∈ support ↔ toFun a ≠ 0\n\n"}
{"name":"Finsupp.ext_iff","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf g : Finsupp α M\n⊢ Iff (Eq f g) (∀ (a : α), Eq (f a) (g a))","decl":"@[ext]\ntheorem ext {f g : α →₀ M} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"Finsupp.ext","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf g : Finsupp α M\nh : ∀ (a : α), Eq (f a) (g a)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : α →₀ M} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"Finsupp.ne_iff","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf g : Finsupp α M\n⊢ Iff (Ne f g) (Exists fun a => Ne (f a) (g a))","decl":"lemma ne_iff {f g : α →₀ M} : f ≠ g ↔ ∃ a, f a ≠ g a := DFunLike.ne_iff\n\n"}
{"name":"Finsupp.coe_mk","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : α → M\ns : Finset α\nh : ∀ (a : α), Iff (Membership.mem s a) (Ne (f a) 0)\n⊢ Eq (⇑{ support := s, toFun := f, mem_support_toFun := h }) f","decl":"@[simp, norm_cast]\ntheorem coe_mk (f : α → M) (s : Finset α) (h : ∀ a, a ∈ s ↔ f a ≠ 0) : ⇑(⟨s, f, h⟩ : α →₀ M) = f :=\n  rfl\n\n"}
{"name":"Finsupp.coe_zero","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\n⊢ Eq (⇑0) 0","decl":"@[simp, norm_cast] lemma coe_zero : ⇑(0 : α →₀ M) = 0 := rfl\n\n"}
{"name":"Finsupp.zero_apply","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na : α\n⊢ Eq (0 a) 0","decl":"theorem zero_apply {a : α} : (0 : α →₀ M) a = 0 :=\n  rfl\n\n"}
{"name":"Finsupp.support_zero","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\n⊢ Eq (Finsupp.support 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem support_zero : (0 : α →₀ M).support = ∅ :=\n  rfl\n\n"}
{"name":"Finsupp.mem_support_iff","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\na : α\n⊢ Iff (Membership.mem f.support a) (Ne (f a) 0)","decl":"@[simp]\ntheorem mem_support_iff {f : α →₀ M} : ∀ {a : α}, a ∈ f.support ↔ f a ≠ 0 :=\n  @(f.mem_support_toFun)\n\n"}
{"name":"Finsupp.fun_support_eq","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\n⊢ Eq (Function.support ⇑f) ↑f.support","decl":"@[simp, norm_cast]\ntheorem fun_support_eq (f : α →₀ M) : Function.support f = f.support :=\n  Set.ext fun _x => mem_support_iff.symm\n\n"}
{"name":"Finsupp.not_mem_support_iff","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\na : α\n⊢ Iff (Not (Membership.mem f.support a)) (Eq (f a) 0)","decl":"theorem not_mem_support_iff {f : α →₀ M} {a} : a ∉ f.support ↔ f a = 0 :=\n  not_iff_comm.1 mem_support_iff.symm\n\n"}
{"name":"Finsupp.coe_eq_zero","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\n⊢ Iff (Eq (⇑f) 0) (Eq f 0)","decl":"@[simp, norm_cast]\ntheorem coe_eq_zero {f : α →₀ M} : (f : α → M) = 0 ↔ f = 0 := by rw [← coe_zero, DFunLike.coe_fn_eq]\n\n"}
{"name":"Finsupp.ext_iff'","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf g : Finsupp α M\n⊢ Iff (Eq f g) (And (Eq f.support g.support) (∀ (x : α), Membership.mem f.support x → Eq (f x) (g x)))","decl":"theorem ext_iff' {f g : α →₀ M} : f = g ↔ f.support = g.support ∧ ∀ x ∈ f.support, f x = g x :=\n  ⟨fun h => h ▸ ⟨rfl, fun _ _ => rfl⟩, fun ⟨h₁, h₂⟩ =>\n    ext fun a => by\n      classical\n      exact if h : a ∈ f.support then h₂ a h else by\n        have hf : f a = 0 := not_mem_support_iff.1 h\n        have hg : g a = 0 := by rwa [h₁, not_mem_support_iff] at h\n        rw [hf, hg]⟩\n\n"}
{"name":"Finsupp.support_eq_empty","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\n⊢ Iff (Eq f.support EmptyCollection.emptyCollection) (Eq f 0)","decl":"@[simp]\ntheorem support_eq_empty {f : α →₀ M} : f.support = ∅ ↔ f = 0 :=\n  mod_cast @Function.support_eq_empty_iff _ _ _ f\n\n"}
{"name":"Finsupp.support_nonempty_iff","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\n⊢ Iff f.support.Nonempty (Ne f 0)","decl":"theorem support_nonempty_iff {f : α →₀ M} : f.support.Nonempty ↔ f ≠ 0 := by\n  simp only [Finsupp.support_eq_empty, Finset.nonempty_iff_ne_empty, Ne]\n\n"}
{"name":"Finsupp.card_support_eq_zero","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\n⊢ Iff (Eq f.support.card 0) (Eq f 0)","decl":"theorem card_support_eq_zero {f : α →₀ M} : #f.support = 0 ↔ f = 0 := by simp\n\n"}
{"name":"Finsupp.finite_support","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\n⊢ (Function.support ⇑f).Finite","decl":"theorem finite_support (f : α →₀ M) : Set.Finite (Function.support f) :=\n  f.fun_support_eq.symm ▸ f.support.finite_toSet\n\n"}
{"name":"Finsupp.support_subset_iff","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\ns : Set α\nf : Finsupp α M\n⊢ Iff (HasSubset.Subset (↑f.support) s) (∀ (a : α), Not (Membership.mem s a) → Eq (f a) 0)","decl":"theorem support_subset_iff {s : Set α} {f : α →₀ M} :\n    ↑f.support ⊆ s ↔ ∀ a ∉ s, f a = 0 := by\n  simp only [Set.subset_def, mem_coe, mem_support_iff]; exact forall_congr' fun a => not_imp_comm\n\n"}
{"name":"Finsupp.equivFunOnFinite_symm_apply_support","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\ninst✝ : Finite α\nf : α → M\n⊢ Eq (Finsupp.equivFunOnFinite.symm f).support ⋯.toFinset","decl":"/-- Given `Finite α`, `equivFunOnFinite` is the `Equiv` between `α →₀ β` and `α → β`.\n  (All functions on a finite type are finitely supported.) -/\n@[simps]\ndef equivFunOnFinite [Finite α] : (α →₀ M) ≃ (α → M) where\n  toFun := (⇑)\n  invFun f := mk (Function.support f).toFinite.toFinset f fun _a => Set.Finite.mem_toFinset _\n  left_inv _f := ext fun _x => rfl\n  right_inv _f := rfl\n\n"}
{"name":"Finsupp.equivFunOnFinite_apply","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\ninst✝ : Finite α\na✝ : Finsupp α M\na : α\n⊢ Eq (Finsupp.equivFunOnFinite a✝ a) (a✝ a)","decl":"/-- Given `Finite α`, `equivFunOnFinite` is the `Equiv` between `α →₀ β` and `α → β`.\n  (All functions on a finite type are finitely supported.) -/\n@[simps]\ndef equivFunOnFinite [Finite α] : (α →₀ M) ≃ (α → M) where\n  toFun := (⇑)\n  invFun f := mk (Function.support f).toFinite.toFinset f fun _a => Set.Finite.mem_toFinset _\n  left_inv _f := ext fun _x => rfl\n  right_inv _f := rfl\n\n"}
{"name":"Finsupp.equivFunOnFinite_symm_apply_toFun","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\ninst✝ : Finite α\nf : α → M\na✝ : α\n⊢ Eq ((Finsupp.equivFunOnFinite.symm f) a✝) (f a✝)","decl":"/-- Given `Finite α`, `equivFunOnFinite` is the `Equiv` between `α →₀ β` and `α → β`.\n  (All functions on a finite type are finitely supported.) -/\n@[simps]\ndef equivFunOnFinite [Finite α] : (α →₀ M) ≃ (α → M) where\n  toFun := (⇑)\n  invFun f := mk (Function.support f).toFinite.toFinset f fun _a => Set.Finite.mem_toFinset _\n  left_inv _f := ext fun _x => rfl\n  right_inv _f := rfl\n\n"}
{"name":"Finsupp.equivFunOnFinite_symm_coe","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"M : Type u_5\ninst✝¹ : Zero M\nα : Type u_13\ninst✝ : Finite α\nf : Finsupp α M\n⊢ Eq (Finsupp.equivFunOnFinite.symm ⇑f) f","decl":"@[simp]\ntheorem equivFunOnFinite_symm_coe {α} [Finite α] (f : α →₀ M) : equivFunOnFinite.symm f = f :=\n  equivFunOnFinite.symm_apply_apply f\n\n"}
{"name":"Finsupp.coe_equivFunOnFinite_symm","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"M : Type u_5\ninst✝¹ : Zero M\nα : Type u_13\ninst✝ : Finite α\nf : α → M\n⊢ Eq (⇑(Finsupp.equivFunOnFinite.symm f)) f","decl":"@[simp]\nlemma coe_equivFunOnFinite_symm {α} [Finite α] (f : α → M) : ⇑(equivFunOnFinite.symm f) = f := rfl\n\n"}
{"name":"Equiv.finsuppUnique_apply","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"M : Type u_5\ninst✝¹ : Zero M\nι : Type u_13\ninst✝ : Unique ι\na✝ : Finsupp ι M\n⊢ Eq (Equiv.finsuppUnique a✝) (a✝ Inhabited.default)","decl":"/--\nIf `α` has a unique term, the type of finitely supported functions `α →₀ β` is equivalent to `β`.\n-/\n@[simps!]\nnoncomputable def _root_.Equiv.finsuppUnique {ι : Type*} [Unique ι] : (ι →₀ M) ≃ M :=\n  Finsupp.equivFunOnFinite.trans (Equiv.funUnique ι M)\n\n"}
{"name":"Equiv.finsuppUnique_symm_apply_toFun","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"M : Type u_5\ninst✝¹ : Zero M\nι : Type u_13\ninst✝ : Unique ι\na✝¹ : M\na✝ : ι\n⊢ Eq ((Equiv.finsuppUnique.symm a✝¹) a✝) a✝¹","decl":"/--\nIf `α` has a unique term, the type of finitely supported functions `α →₀ β` is equivalent to `β`.\n-/\n@[simps!]\nnoncomputable def _root_.Equiv.finsuppUnique {ι : Type*} [Unique ι] : (ι →₀ M) ≃ M :=\n  Finsupp.equivFunOnFinite.trans (Equiv.funUnique ι M)\n\n"}
{"name":"Equiv.finsuppUnique_symm_apply_support_val","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"M : Type u_5\ninst✝¹ : Zero M\nι : Type u_13\ninst✝ : Unique ι\na✝ : M\n⊢ Eq (Equiv.finsuppUnique.symm a✝).support.val (Multiset.map Subtype.val Finset.univ.val)","decl":"/--\nIf `α` has a unique term, the type of finitely supported functions `α →₀ β` is equivalent to `β`.\n-/\n@[simps!]\nnoncomputable def _root_.Equiv.finsuppUnique {ι : Type*} [Unique ι] : (ι →₀ M) ≃ M :=\n  Finsupp.equivFunOnFinite.trans (Equiv.funUnique ι M)\n\n"}
{"name":"Finsupp.unique_ext","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\ninst✝ : Unique α\nf g : Finsupp α M\nh : Eq (f Inhabited.default) (g Inhabited.default)\n⊢ Eq f g","decl":"@[ext]\ntheorem unique_ext [Unique α] {f g : α →₀ M} (h : f default = g default) : f = g :=\n  ext fun a => by rwa [Unique.eq_default a]\n\n"}
{"name":"Finsupp.unique_ext_iff","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\ninst✝ : Unique α\nf g : Finsupp α M\n⊢ Iff (Eq f g) (Eq (f Inhabited.default) (g Inhabited.default))","decl":"@[ext]\ntheorem unique_ext [Unique α] {f g : α →₀ M} (h : f default = g default) : f = g :=\n  ext fun a => by rwa [Unique.eq_default a]\n\n"}
{"name":"Finsupp.coe_onFinset","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\ns : Finset α\nf : α → M\nhf : ∀ (a : α), Ne (f a) 0 → Membership.mem s a\n⊢ Eq (⇑(Finsupp.onFinset s f hf)) f","decl":"@[simp, norm_cast] lemma coe_onFinset (s : Finset α) (f : α → M) (hf) : onFinset s f hf = f := rfl\n\n"}
{"name":"Finsupp.onFinset_apply","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\ns : Finset α\nf : α → M\nhf : ∀ (a : α), Ne (f a) 0 → Membership.mem s a\na : α\n⊢ Eq ((Finsupp.onFinset s f hf) a) (f a)","decl":"@[simp]\ntheorem onFinset_apply {s : Finset α} {f : α → M} {hf a} : (onFinset s f hf : α →₀ M) a = f a :=\n  rfl\n\n"}
{"name":"Finsupp.support_onFinset_subset","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\ns : Finset α\nf : α → M\nhf : ∀ (a : α), Ne (f a) 0 → Membership.mem s a\n⊢ HasSubset.Subset (Finsupp.onFinset s f hf).support s","decl":"@[simp]\ntheorem support_onFinset_subset {s : Finset α} {f : α → M} {hf} :\n    (onFinset s f hf).support ⊆ s := by\n  classical convert filter_subset (f · ≠ 0) s\n\n"}
{"name":"Finsupp.mem_support_onFinset","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\ns : Finset α\nf : α → M\nhf : ∀ (a : α), Ne (f a) 0 → Membership.mem s a\na : α\n⊢ Iff (Membership.mem (Finsupp.onFinset s f hf).support a) (Ne (f a) 0)","decl":"theorem mem_support_onFinset {s : Finset α} {f : α → M} (hf : ∀ a : α, f a ≠ 0 → a ∈ s) {a : α} :\n    a ∈ (Finsupp.onFinset s f hf).support ↔ f a ≠ 0 := by\n  rw [Finsupp.mem_support_iff, Finsupp.onFinset_apply]\n\n"}
{"name":"Finsupp.support_onFinset","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\ninst✝ : DecidableEq M\ns : Finset α\nf : α → M\nhf : ∀ (a : α), Ne (f a) 0 → Membership.mem s a\n⊢ Eq (Finsupp.onFinset s f hf).support (Finset.filter (fun a => Ne (f a) 0) s)","decl":"theorem support_onFinset [DecidableEq M] {s : Finset α} {f : α → M}\n    (hf : ∀ a : α, f a ≠ 0 → a ∈ s) :\n    (Finsupp.onFinset s f hf).support = {a ∈ s | f a ≠ 0} := by\n  dsimp [onFinset]; congr\n\n"}
{"name":"Finsupp.ofSupportFinite_coe","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : α → M\nhf : (Function.support f).Finite\n⊢ Eq (⇑(Finsupp.ofSupportFinite f hf)) f","decl":"theorem ofSupportFinite_coe {f : α → M} {hf : (Function.support f).Finite} :\n    (ofSupportFinite f hf : α → M) = f :=\n  rfl\n\n"}
{"name":"Finsupp.instCanLift","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\n⊢ CanLift (α → M) (Finsupp α M) DFunLike.coe fun f => (Function.support f).Finite","decl":"instance instCanLift : CanLift (α → M) (α →₀ M) (⇑) fun f => (Function.support f).Finite where\n  prf f hf := ⟨ofSupportFinite f hf, rfl⟩\n\n"}
{"name":"Finsupp.mapRange_apply","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\ninst✝ : Zero N\nf : M → N\nhf : Eq (f 0) 0\ng : Finsupp α M\na : α\n⊢ Eq ((Finsupp.mapRange f hf g) a) (f (g a))","decl":"@[simp]\ntheorem mapRange_apply {f : M → N} {hf : f 0 = 0} {g : α →₀ M} {a : α} :\n    mapRange f hf g a = f (g a) :=\n  rfl\n\n"}
{"name":"Finsupp.mapRange_zero","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\ninst✝ : Zero N\nf : M → N\nhf : Eq (f 0) 0\n⊢ Eq (Finsupp.mapRange f hf 0) 0","decl":"@[simp]\ntheorem mapRange_zero {f : M → N} {hf : f 0 = 0} : mapRange f hf (0 : α →₀ M) = 0 :=\n  ext fun _ => by simp only [hf, zero_apply, mapRange_apply]\n\n"}
{"name":"Finsupp.mapRange_id","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\ng : Finsupp α M\n⊢ Eq (Finsupp.mapRange id ⋯ g) g","decl":"@[simp]\ntheorem mapRange_id (g : α →₀ M) : mapRange id rfl g = g :=\n  ext fun _ => rfl\n\n"}
{"name":"Finsupp.mapRange_comp","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\nP : Type u_8\ninst✝² : Zero M\ninst✝¹ : Zero N\ninst✝ : Zero P\nf : N → P\nhf : Eq (f 0) 0\nf₂ : M → N\nhf₂ : Eq (f₂ 0) 0\nh : Eq (Function.comp f f₂ 0) 0\ng : Finsupp α M\n⊢ Eq (Finsupp.mapRange (Function.comp f f₂) h g) (Finsupp.mapRange f hf (Finsupp.mapRange f₂ hf₂ g))","decl":"theorem mapRange_comp (f : N → P) (hf : f 0 = 0) (f₂ : M → N) (hf₂ : f₂ 0 = 0) (h : (f ∘ f₂) 0 = 0)\n    (g : α →₀ M) : mapRange (f ∘ f₂) h g = mapRange f hf (mapRange f₂ hf₂ g) :=\n  ext fun _ => rfl\n\n"}
{"name":"Finsupp.mapRange_mapRange","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\nP : Type u_8\ninst✝² : Zero M\ninst✝¹ : Zero N\ninst✝ : Zero P\ne₁ : N → P\ne₂ : M → N\nhe₁ : Eq (e₁ 0) 0\nhe₂ : Eq (e₂ 0) 0\nf : Finsupp α M\n⊢ Eq (Finsupp.mapRange e₁ he₁ (Finsupp.mapRange e₂ he₂ f)) (Finsupp.mapRange (Function.comp e₁ e₂) ⋯ f)","decl":"@[simp]\nlemma mapRange_mapRange (e₁ : N → P) (e₂ : M → N) (he₁ he₂) (f : α →₀ M) :\n    mapRange e₁ he₁ (mapRange e₂ he₂ f) = mapRange (e₁ ∘ e₂) (by simp [*]) f := ext fun _ ↦ rfl\n\n"}
{"name":"Finsupp.support_mapRange","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\ninst✝ : Zero N\nf : M → N\nhf : Eq (f 0) 0\ng : Finsupp α M\n⊢ HasSubset.Subset (Finsupp.mapRange f hf g).support g.support","decl":"theorem support_mapRange {f : M → N} {hf : f 0 = 0} {g : α →₀ M} :\n    (mapRange f hf g).support ⊆ g.support :=\n  support_onFinset_subset\n\n"}
{"name":"Finsupp.support_mapRange_of_injective","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"ι : Type u_4\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\ninst✝ : Zero N\ne : M → N\nhe0 : Eq (e 0) 0\nf : Finsupp ι M\nhe : Function.Injective e\n⊢ Eq (Finsupp.mapRange e he0 f).support f.support","decl":"theorem support_mapRange_of_injective {e : M → N} (he0 : e 0 = 0) (f : ι →₀ M)\n    (he : Function.Injective e) : (Finsupp.mapRange e he0 f).support = f.support := by\n  ext\n  simp only [Finsupp.mem_support_iff, Ne, Finsupp.mapRange_apply]\n  exact he.ne_iff' he0\n\n"}
{"name":"Finsupp.range_mapRange","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\ninst✝ : Zero N\ne : M → N\nhe₀ : Eq (e 0) 0\n⊢ Eq (Set.range (Finsupp.mapRange e he₀)) (setOf fun g => ∀ (i : α), Membership.mem (Set.range e) (g i))","decl":"lemma range_mapRange (e : M → N) (he₀ : e 0 = 0) :\n    Set.range (Finsupp.mapRange (α := α) e he₀) = {g | ∀ i, g i ∈ Set.range e} := by\n  ext g\n  simp only [Set.mem_range, Set.mem_setOf]\n  constructor\n  · rintro ⟨g, rfl⟩ i\n    simp\n  · intro h\n    classical\n    choose f h using h\n    use onFinset g.support (Set.indicator g.support f) (by aesop)\n    ext i\n    simp only [mapRange_apply, onFinset_apply, Set.indicator_apply]\n    split_ifs <;> simp_all\n\n"}
{"name":"Finsupp.mapRange_injective","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\ninst✝ : Zero N\ne : M → N\nhe₀ : Eq (e 0) 0\nhe : Function.Injective e\n⊢ Function.Injective (Finsupp.mapRange e he₀)","decl":"/-- `Finsupp.mapRange` of a injective function is injective. -/\nlemma mapRange_injective (e : M → N) (he₀ : e 0 = 0) (he : Injective e) :\n    Injective (Finsupp.mapRange (α := α) e he₀) := by\n  intro a b h\n  rw [Finsupp.ext_iff] at h ⊢\n  simpa only [mapRange_apply, he.eq_iff] using h\n\n"}
{"name":"Finsupp.mapRange_surjective","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\ninst✝ : Zero N\ne : M → N\nhe₀ : Eq (e 0) 0\nhe : Function.Surjective e\n⊢ Function.Surjective (Finsupp.mapRange e he₀)","decl":"/-- `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma mapRange_surjective (e : M → N) (he₀ : e 0 = 0) (he : Surjective e) :\n    Surjective (Finsupp.mapRange (α := α) e he₀) := by\n  rw [← Set.range_eq_univ, range_mapRange, he.range_eq]\n  simp\n\n"}
{"name":"Finsupp.support_embDomain","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : Function.Embedding α β\nv : Finsupp α M\n⊢ Eq (Finsupp.embDomain f v).support (Finset.map f v.support)","decl":"@[simp]\ntheorem support_embDomain (f : α ↪ β) (v : α →₀ M) : (embDomain f v).support = v.support.map f :=\n  rfl\n\n"}
{"name":"Finsupp.embDomain_zero","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : Function.Embedding α β\n⊢ Eq (Finsupp.embDomain f 0) 0","decl":"@[simp]\ntheorem embDomain_zero (f : α ↪ β) : (embDomain f 0 : β →₀ M) = 0 :=\n  rfl\n\n"}
{"name":"Finsupp.embDomain_apply","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : Function.Embedding α β\nv : Finsupp α M\na : α\n⊢ Eq ((Finsupp.embDomain f v) (f a)) (v a)","decl":"@[simp]\ntheorem embDomain_apply (f : α ↪ β) (v : α →₀ M) (a : α) : embDomain f v (f a) = v a := by\n  classical\n    change dite _ _ _ = _\n    split_ifs with h <;> rw [Finset.mem_map' f] at h\n    · refine congr_arg (v : α → M) (f.inj' ?_)\n      exact Finset.choose_property (fun a₁ => f a₁ = f a) _ _\n    · exact (not_mem_support_iff.1 h).symm\n\n"}
{"name":"Finsupp.embDomain_notin_range","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : Function.Embedding α β\nv : Finsupp α M\na : β\nh : Not (Membership.mem (Set.range ⇑f) a)\n⊢ Eq ((Finsupp.embDomain f v) a) 0","decl":"theorem embDomain_notin_range (f : α ↪ β) (v : α →₀ M) (a : β) (h : a ∉ Set.range f) :\n    embDomain f v a = 0 := by\n  classical\n    refine dif_neg (mt (fun h => ?_) h)\n    rcases Finset.mem_map.1 h with ⟨a, _h, rfl⟩\n    exact Set.mem_range_self a\n\n"}
{"name":"Finsupp.embDomain_injective","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : Function.Embedding α β\n⊢ Function.Injective (Finsupp.embDomain f)","decl":"theorem embDomain_injective (f : α ↪ β) : Function.Injective (embDomain f : (α →₀ M) → β →₀ M) :=\n  fun l₁ l₂ h => ext fun a => by simpa only [embDomain_apply] using DFunLike.ext_iff.1 h (f a)\n\n"}
{"name":"Finsupp.embDomain_inj","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : Function.Embedding α β\nl₁ l₂ : Finsupp α M\n⊢ Iff (Eq (Finsupp.embDomain f l₁) (Finsupp.embDomain f l₂)) (Eq l₁ l₂)","decl":"@[simp]\ntheorem embDomain_inj {f : α ↪ β} {l₁ l₂ : α →₀ M} : embDomain f l₁ = embDomain f l₂ ↔ l₁ = l₂ :=\n  (embDomain_injective f).eq_iff\n\n"}
{"name":"Finsupp.embDomain_eq_zero","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : Function.Embedding α β\nl : Finsupp α M\n⊢ Iff (Eq (Finsupp.embDomain f l) 0) (Eq l 0)","decl":"@[simp]\ntheorem embDomain_eq_zero {f : α ↪ β} {l : α →₀ M} : embDomain f l = 0 ↔ l = 0 :=\n  (embDomain_injective f).eq_iff' <| embDomain_zero f\n\n"}
{"name":"Finsupp.embDomain_mapRange","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\ninst✝ : Zero N\nf : Function.Embedding α β\ng : M → N\np : Finsupp α M\nhg : Eq (g 0) 0\n⊢ Eq (Finsupp.embDomain f (Finsupp.mapRange g hg p)) (Finsupp.mapRange g hg (Finsupp.embDomain f p))","decl":"theorem embDomain_mapRange (f : α ↪ β) (g : M → N) (p : α →₀ M) (hg : g 0 = 0) :\n    embDomain f (mapRange g hg p) = mapRange g hg (embDomain f p) := by\n  ext a\n  by_cases h : a ∈ Set.range f\n  · rcases h with ⟨a', rfl⟩\n    rw [mapRange_apply, embDomain_apply, embDomain_apply, mapRange_apply]\n  · rw [mapRange_apply, embDomain_notin_range, embDomain_notin_range, ← hg] <;> assumption\n\n"}
{"name":"Finsupp.zipWith_apply","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\nP : Type u_8\ninst✝² : Zero M\ninst✝¹ : Zero N\ninst✝ : Zero P\nf : M → N → P\nhf : Eq (f 0 0) 0\ng₁ : Finsupp α M\ng₂ : Finsupp α N\na : α\n⊢ Eq ((Finsupp.zipWith f hf g₁ g₂) a) (f (g₁ a) (g₂ a))","decl":"@[simp]\ntheorem zipWith_apply {f : M → N → P} {hf : f 0 0 = 0} {g₁ : α →₀ M} {g₂ : α →₀ N} {a : α} :\n    zipWith f hf g₁ g₂ a = f (g₁ a) (g₂ a) :=\n  rfl\n\n"}
{"name":"Finsupp.support_zipWith","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\nP : Type u_8\ninst✝² : Zero M\ninst✝¹ : Zero N\ninst✝ : Zero P\nD : DecidableEq α\nf : M → N → P\nhf : Eq (f 0 0) 0\ng₁ : Finsupp α M\ng₂ : Finsupp α N\n⊢ HasSubset.Subset (Finsupp.zipWith f hf g₁ g₂).support (Union.union g₁.support g₂.support)","decl":"theorem support_zipWith [D : DecidableEq α] {f : M → N → P} {hf : f 0 0 = 0} {g₁ : α →₀ M}\n    {g₂ : α →₀ N} : (zipWith f hf g₁ g₂).support ⊆ g₁.support ∪ g₂.support := by\n  convert support_onFinset_subset\n\n"}
{"name":"Finsupp.coe_add","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddZeroClass M\nf g : Finsupp α M\n⊢ Eq (⇑(HAdd.hAdd f g)) (HAdd.hAdd ⇑f ⇑g)","decl":"@[simp, norm_cast] lemma coe_add (f g : α →₀ M) : ⇑(f + g) = f + g := rfl\n\n"}
{"name":"Finsupp.add_apply","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddZeroClass M\ng₁ g₂ : Finsupp α M\na : α\n⊢ Eq ((HAdd.hAdd g₁ g₂) a) (HAdd.hAdd (g₁ a) (g₂ a))","decl":"theorem add_apply (g₁ g₂ : α →₀ M) (a : α) : (g₁ + g₂) a = g₁ a + g₂ a :=\n  rfl\n\n"}
{"name":"Finsupp.support_add","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : DecidableEq α\ng₁ g₂ : Finsupp α M\n⊢ HasSubset.Subset (HAdd.hAdd g₁ g₂).support (Union.union g₁.support g₂.support)","decl":"theorem support_add [DecidableEq α] {g₁ g₂ : α →₀ M} :\n    (g₁ + g₂).support ⊆ g₁.support ∪ g₂.support :=\n  support_zipWith\n\n"}
{"name":"Finsupp.support_add_eq","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : DecidableEq α\ng₁ g₂ : Finsupp α M\nh : Disjoint g₁.support g₂.support\n⊢ Eq (HAdd.hAdd g₁ g₂).support (Union.union g₁.support g₂.support)","decl":"theorem support_add_eq [DecidableEq α] {g₁ g₂ : α →₀ M} (h : Disjoint g₁.support g₂.support) :\n    (g₁ + g₂).support = g₁.support ∪ g₂.support :=\n  le_antisymm support_zipWith fun a ha =>\n    (Finset.mem_union.1 ha).elim\n      (fun ha => by\n        have : a ∉ g₂.support := disjoint_left.1 h ha\n        simp only [mem_support_iff, not_not] at *; simpa only [add_apply, this, add_zero] )\n      fun ha => by\n      have : a ∉ g₁.support := disjoint_right.1 h ha\n      simp only [mem_support_iff, not_not] at *; simpa only [add_apply, this, zero_add]\n\n"}
{"name":"Finsupp.instIsLeftCancelAdd","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : IsLeftCancelAdd M\n⊢ IsLeftCancelAdd (Finsupp α M)","decl":"instance instIsLeftCancelAdd [IsLeftCancelAdd M] : IsLeftCancelAdd (α →₀ M) where\n  add_left_cancel _ _ _ h := ext fun x => add_left_cancel <| DFunLike.congr_fun h x\n\n"}
{"name":"Finsupp.instIsRightCancelAdd","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : IsRightCancelAdd M\n⊢ IsRightCancelAdd (Finsupp α M)","decl":"instance instIsRightCancelAdd [IsRightCancelAdd M] : IsRightCancelAdd (α →₀ M) where\n  add_right_cancel _ _ _ h := ext fun x => add_right_cancel <| DFunLike.congr_fun h x\n\n"}
{"name":"Finsupp.instIsCancelAdd","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : IsCancelAdd M\n⊢ IsCancelAdd (Finsupp α M)","decl":"instance instIsCancelAdd [IsCancelAdd M] : IsCancelAdd (α →₀ M) where\n\n"}
{"name":"Finsupp.applyAddHom_apply","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddZeroClass M\na : α\ng : Finsupp α M\n⊢ Eq ((Finsupp.applyAddHom a) g) (g a)","decl":"/-- Evaluation of a function `f : α →₀ M` at a point as an additive monoid homomorphism.\n\nSee `Finsupp.lapply` in `LinearAlgebra/Finsupp` for the stronger version as a linear map. -/\n@[simps apply]\ndef applyAddHom (a : α) : (α →₀ M) →+ M where\n  toFun g := g a\n  map_zero' := zero_apply\n  map_add' _ _ := add_apply _ _ _\n\n"}
{"name":"Finsupp.coeFnAddHom_apply","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddZeroClass M\na✝ : Finsupp α M\na : α\n⊢ Eq (Finsupp.coeFnAddHom a✝ a) (a✝ a)","decl":"/-- Coercion from a `Finsupp` to a function type is an `AddMonoidHom`. -/\n@[simps]\nnoncomputable def coeFnAddHom : (α →₀ M) →+ α → M where\n  toFun := (⇑)\n  map_zero' := coe_zero\n  map_add' := coe_add\n\n"}
{"name":"Finsupp.mapRange_add","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : M → N\nhf : Eq (f 0) 0\nhf' : ∀ (x y : M), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\nv₁ v₂ : Finsupp α M\n⊢ Eq (Finsupp.mapRange f hf (HAdd.hAdd v₁ v₂)) (HAdd.hAdd (Finsupp.mapRange f hf v₁) (Finsupp.mapRange f hf v₂))","decl":"theorem mapRange_add [AddZeroClass N] {f : M → N} {hf : f 0 = 0}\n    (hf' : ∀ x y, f (x + y) = f x + f y) (v₁ v₂ : α →₀ M) :\n    mapRange f hf (v₁ + v₂) = mapRange f hf v₁ + mapRange f hf v₂ :=\n  ext fun _ => by simp only [hf', add_apply, mapRange_apply]\n\n"}
{"name":"Finsupp.mapRange_add'","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\nN : Type u_7\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : FunLike β M N\ninst✝ : AddMonoidHomClass β M N\nf : β\nv₁ v₂ : Finsupp α M\n⊢ Eq (Finsupp.mapRange ⇑f ⋯ (HAdd.hAdd v₁ v₂)) (HAdd.hAdd (Finsupp.mapRange ⇑f ⋯ v₁) (Finsupp.mapRange ⇑f ⋯ v₂))","decl":"theorem mapRange_add' [AddZeroClass N] [FunLike β M N] [AddMonoidHomClass β M N]\n    {f : β} (v₁ v₂ : α →₀ M) :\n    mapRange f (map_zero f) (v₁ + v₂) = mapRange f (map_zero f) v₁ + mapRange f (map_zero f) v₂ :=\n  mapRange_add (map_add f) v₁ v₂\n\n"}
{"name":"Finsupp.embDomain.addMonoidHom_apply","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddZeroClass M\nf : Function.Embedding α β\nv : Finsupp α M\n⊢ Eq ((Finsupp.embDomain.addMonoidHom f) v) (Finsupp.embDomain f v)","decl":"/-- Bundle `Finsupp.embDomain f` as an additive map from `α →₀ M` to `β →₀ M`. -/\n@[simps]\ndef embDomain.addMonoidHom (f : α ↪ β) : (α →₀ M) →+ β →₀ M where\n  toFun v := embDomain f v\n  map_zero' := by simp\n  map_add' v w := by\n    ext b\n    by_cases h : b ∈ Set.range f\n    · rcases h with ⟨a, rfl⟩\n      simp\n    · simp only [Set.mem_range, not_exists, coe_add, Pi.add_apply,\n        embDomain_notin_range _ _ _ h, add_zero]\n\n"}
{"name":"Finsupp.embDomain_add","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddZeroClass M\nf : Function.Embedding α β\nv w : Finsupp α M\n⊢ Eq (Finsupp.embDomain f (HAdd.hAdd v w)) (HAdd.hAdd (Finsupp.embDomain f v) (Finsupp.embDomain f w))","decl":"@[simp]\ntheorem embDomain_add (f : α ↪ β) (v w : α →₀ M) :\n    embDomain f (v + w) = embDomain f v + embDomain f w :=\n  (embDomain.addMonoidHom f).map_add v w\n\n"}
{"name":"Finsupp.coe_neg","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝ : NegZeroClass G\ng : Finsupp α G\n⊢ Eq (⇑(Neg.neg g)) (Neg.neg ⇑g)","decl":"@[simp, norm_cast] lemma coe_neg [NegZeroClass G] (g : α →₀ G) : ⇑(-g) = -g := rfl\n\n"}
{"name":"Finsupp.neg_apply","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝ : NegZeroClass G\ng : Finsupp α G\na : α\n⊢ Eq ((Neg.neg g) a) (Neg.neg (g a))","decl":"theorem neg_apply [NegZeroClass G] (g : α →₀ G) (a : α) : (-g) a = -g a :=\n  rfl\n\n"}
{"name":"Finsupp.mapRange_neg","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nG : Type u_9\nH : Type u_10\ninst✝¹ : NegZeroClass G\ninst✝ : NegZeroClass H\nf : G → H\nhf : Eq (f 0) 0\nhf' : ∀ (x : G), Eq (f (Neg.neg x)) (Neg.neg (f x))\nv : Finsupp α G\n⊢ Eq (Finsupp.mapRange f hf (Neg.neg v)) (Neg.neg (Finsupp.mapRange f hf v))","decl":"theorem mapRange_neg [NegZeroClass G] [NegZeroClass H] {f : G → H} {hf : f 0 = 0}\n    (hf' : ∀ x, f (-x) = -f x) (v : α →₀ G) : mapRange f hf (-v) = -mapRange f hf v :=\n  ext fun _ => by simp only [hf', neg_apply, mapRange_apply]\n\n"}
{"name":"Finsupp.mapRange_neg'","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nG : Type u_9\nH : Type u_10\ninst✝³ : AddGroup G\ninst✝² : SubtractionMonoid H\ninst✝¹ : FunLike β G H\ninst✝ : AddMonoidHomClass β G H\nf : β\nv : Finsupp α G\n⊢ Eq (Finsupp.mapRange ⇑f ⋯ (Neg.neg v)) (Neg.neg (Finsupp.mapRange ⇑f ⋯ v))","decl":"theorem mapRange_neg' [AddGroup G] [SubtractionMonoid H] [FunLike β G H] [AddMonoidHomClass β G H]\n    {f : β} (v : α →₀ G) :\n    mapRange f (map_zero f) (-v) = -mapRange f (map_zero f) v :=\n  mapRange_neg (map_neg f) v\n\n"}
{"name":"Finsupp.coe_sub","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝ : SubNegZeroMonoid G\ng₁ g₂ : Finsupp α G\n⊢ Eq (⇑(HSub.hSub g₁ g₂)) (HSub.hSub ⇑g₁ ⇑g₂)","decl":"@[simp, norm_cast] lemma coe_sub [SubNegZeroMonoid G] (g₁ g₂ : α →₀ G) : ⇑(g₁ - g₂) = g₁ - g₂ := rfl\n\n"}
{"name":"Finsupp.sub_apply","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝ : SubNegZeroMonoid G\ng₁ g₂ : Finsupp α G\na : α\n⊢ Eq ((HSub.hSub g₁ g₂) a) (HSub.hSub (g₁ a) (g₂ a))","decl":"theorem sub_apply [SubNegZeroMonoid G] (g₁ g₂ : α →₀ G) (a : α) : (g₁ - g₂) a = g₁ a - g₂ a :=\n  rfl\n\n"}
{"name":"Finsupp.mapRange_sub","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nG : Type u_9\nH : Type u_10\ninst✝¹ : SubNegZeroMonoid G\ninst✝ : SubNegZeroMonoid H\nf : G → H\nhf : Eq (f 0) 0\nhf' : ∀ (x y : G), Eq (f (HSub.hSub x y)) (HSub.hSub (f x) (f y))\nv₁ v₂ : Finsupp α G\n⊢ Eq (Finsupp.mapRange f hf (HSub.hSub v₁ v₂)) (HSub.hSub (Finsupp.mapRange f hf v₁) (Finsupp.mapRange f hf v₂))","decl":"theorem mapRange_sub [SubNegZeroMonoid G] [SubNegZeroMonoid H] {f : G → H} {hf : f 0 = 0}\n    (hf' : ∀ x y, f (x - y) = f x - f y) (v₁ v₂ : α →₀ G) :\n    mapRange f hf (v₁ - v₂) = mapRange f hf v₁ - mapRange f hf v₂ :=\n  ext fun _ => by simp only [hf', sub_apply, mapRange_apply]\n\n"}
{"name":"Finsupp.mapRange_sub'","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nG : Type u_9\nH : Type u_10\ninst✝³ : AddGroup G\ninst✝² : SubtractionMonoid H\ninst✝¹ : FunLike β G H\ninst✝ : AddMonoidHomClass β G H\nf : β\nv₁ v₂ : Finsupp α G\n⊢ Eq (Finsupp.mapRange ⇑f ⋯ (HSub.hSub v₁ v₂)) (HSub.hSub (Finsupp.mapRange ⇑f ⋯ v₁) (Finsupp.mapRange ⇑f ⋯ v₂))","decl":"theorem mapRange_sub' [AddGroup G] [SubtractionMonoid H] [FunLike β G H] [AddMonoidHomClass β G H]\n    {f : β} (v₁ v₂ : α →₀ G) :\n    mapRange f (map_zero f) (v₁ - v₂) = mapRange f (map_zero f) v₁ - mapRange f (map_zero f) v₂ :=\n  mapRange_sub (map_sub f) v₁ v₂\n\n"}
{"name":"Finsupp.support_neg","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝ : AddGroup G\nf : Finsupp α G\n⊢ Eq (Neg.neg f).support f.support","decl":"@[simp]\ntheorem support_neg [AddGroup G] (f : α →₀ G) : support (-f) = support f :=\n  Finset.Subset.antisymm support_mapRange\n    (calc\n      support f = support (- -f) := congr_arg support (neg_neg _).symm\n      _ ⊆ support (-f) := support_mapRange\n      )\n\n"}
{"name":"Finsupp.support_sub","module":"Mathlib.Data.Finsupp.Defs","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup G\nf g : Finsupp α G\n⊢ HasSubset.Subset (HSub.hSub f g).support (Union.union f.support g.support)","decl":"theorem support_sub [DecidableEq α] [AddGroup G] {f g : α →₀ G} :\n    support (f - g) ⊆ support f ∪ support g := by\n  rw [sub_eq_add_neg, ← support_neg g]\n  exact support_add\n\n"}
