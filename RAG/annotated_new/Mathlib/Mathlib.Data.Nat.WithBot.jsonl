{"name":"Nat.WithBot.add_eq_zero_iff","module":"Mathlib.Data.Nat.WithBot","initialProofState":"n m : WithBot Nat\n⊢ Iff (Eq (HAdd.hAdd n m) 0) (And (Eq n 0) (Eq m 0))","decl":"theorem add_eq_zero_iff {n m : WithBot ℕ} : n + m = 0 ↔ n = 0 ∧ m = 0 := by\n  cases n\n  · simp [WithBot.bot_add]\n  cases m\n  · simp [WithBot.add_bot]\n  simp [← WithBot.coe_add, add_eq_zero_iff_of_nonneg]\n\n"}
{"name":"Nat.WithBot.add_eq_one_iff","module":"Mathlib.Data.Nat.WithBot","initialProofState":"n m : WithBot Nat\n⊢ Iff (Eq (HAdd.hAdd n m) 1) (Or (And (Eq n 0) (Eq m 1)) (And (Eq n 1) (Eq m 0)))","decl":"theorem add_eq_one_iff {n m : WithBot ℕ} : n + m = 1 ↔ n = 0 ∧ m = 1 ∨ n = 1 ∧ m = 0 := by\n  cases n\n  · simp only [WithBot.bot_add, WithBot.bot_ne_one, WithBot.bot_ne_zero, false_and, or_self]\n  cases m\n  · simp [WithBot.add_bot]\n  simp [← WithBot.coe_add, Nat.add_eq_one_iff]\n\n"}
{"name":"Nat.WithBot.add_eq_two_iff","module":"Mathlib.Data.Nat.WithBot","initialProofState":"n m : WithBot Nat\n⊢ Iff (Eq (HAdd.hAdd n m) 2) (Or (And (Eq n 0) (Eq m 2)) (Or (And (Eq n 1) (Eq m 1)) (And (Eq n 2) (Eq m 0))))","decl":"theorem add_eq_two_iff {n m : WithBot ℕ} :\n    n + m = 2 ↔ n = 0 ∧ m = 2 ∨ n = 1 ∧ m = 1 ∨ n = 2 ∧ m = 0 := by\n  cases n\n  · simp [WithBot.bot_add]\n  cases m\n  · simp [WithBot.add_bot]\n  simp [← WithBot.coe_add, Nat.add_eq_two_iff]\n\n"}
{"name":"Nat.WithBot.add_eq_three_iff","module":"Mathlib.Data.Nat.WithBot","initialProofState":"n m : WithBot Nat\n⊢ Iff (Eq (HAdd.hAdd n m) 3) (Or (And (Eq n 0) (Eq m 3)) (Or (And (Eq n 1) (Eq m 2)) (Or (And (Eq n 2) (Eq m 1)) (And (Eq n 3) (Eq m 0)))))","decl":"theorem add_eq_three_iff {n m : WithBot ℕ} :\n    n + m = 3 ↔ n = 0 ∧ m = 3 ∨ n = 1 ∧ m = 2 ∨ n = 2 ∧ m = 1 ∨ n = 3 ∧ m = 0 := by\n  cases n\n  · simp [WithBot.bot_add]\n  cases m\n  · simp [WithBot.add_bot]\n  simp [← WithBot.coe_add, Nat.add_eq_three_iff]\n\n"}
{"name":"Nat.WithBot.coe_nonneg","module":"Mathlib.Data.Nat.WithBot","initialProofState":"n : Nat\n⊢ LE.le 0 ↑n","decl":"theorem coe_nonneg {n : ℕ} : 0 ≤ (n : WithBot ℕ) := by\n  rw [← WithBot.coe_zero, cast_withBot, WithBot.coe_le_coe]\n  exact n.zero_le\n\n"}
{"name":"Nat.WithBot.lt_zero_iff","module":"Mathlib.Data.Nat.WithBot","initialProofState":"n : WithBot Nat\n⊢ Iff (LT.lt n 0) (Eq n Bot.bot)","decl":"@[simp]\ntheorem lt_zero_iff {n : WithBot ℕ} : n < 0 ↔ n = ⊥ := WithBot.lt_coe_bot\n\n"}
{"name":"Nat.WithBot.one_le_iff_zero_lt","module":"Mathlib.Data.Nat.WithBot","initialProofState":"x : WithBot Nat\n⊢ Iff (LE.le 1 x) (LT.lt 0 x)","decl":"theorem one_le_iff_zero_lt {x : WithBot ℕ} : 1 ≤ x ↔ 0 < x := by\n  refine ⟨zero_lt_one.trans_le, fun h => ?_⟩\n  cases x\n  · exact (not_lt_bot h).elim\n  · rwa [← WithBot.coe_zero, WithBot.coe_lt_coe, ← Nat.add_one_le_iff, zero_add,\n      ← WithBot.coe_le_coe, WithBot.coe_one] at h\n\n"}
{"name":"Nat.WithBot.lt_one_iff_le_zero","module":"Mathlib.Data.Nat.WithBot","initialProofState":"x : WithBot Nat\n⊢ Iff (LT.lt x 1) (LE.le x 0)","decl":"theorem lt_one_iff_le_zero {x : WithBot ℕ} : x < 1 ↔ x ≤ 0 :=\n  not_iff_not.mp (by simpa using one_le_iff_zero_lt)\n\n"}
{"name":"Nat.WithBot.add_one_le_of_lt","module":"Mathlib.Data.Nat.WithBot","initialProofState":"n m : WithBot Nat\nh : LT.lt n m\n⊢ LE.le (HAdd.hAdd n 1) m","decl":"theorem add_one_le_of_lt {n m : WithBot ℕ} (h : n < m) : n + 1 ≤ m := by\n  cases n\n  · simp only [WithBot.bot_add, bot_le]\n  cases m\n  · exact (not_lt_bot h).elim\n  · rwa [WithBot.coe_lt_coe, ← Nat.add_one_le_iff, ← WithBot.coe_le_coe, WithBot.coe_add,\n      WithBot.coe_one] at h\n\n"}
