{"name":"Submodule.mem_colon","module":"Mathlib.RingTheory.Ideal.Colon","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN P : Submodule R M\nr : R\n⊢ Iff (Membership.mem (N.colon P) r) (∀ (p : M), Membership.mem P p → Membership.mem N (HSMul.hSMul r p))","decl":"theorem mem_colon {r} : r ∈ N.colon P ↔ ∀ p ∈ P, r • p ∈ N := Set.smul_set_subset_iff\n\n"}
{"name":"Submodule.mem_colon'","module":"Mathlib.RingTheory.Ideal.Colon","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN P : Submodule R M\nr : R\n⊢ Iff (Membership.mem (N.colon P) r) (LE.le P (Submodule.comap (HSMul.hSMul r LinearMap.id) N))","decl":"theorem mem_colon' {r} : r ∈ N.colon P ↔ P ≤ comap (r • (LinearMap.id : M →ₗ[R] M)) N :=\n  mem_colon\n\n"}
{"name":"Submodule.colon_top","module":"Mathlib.RingTheory.Ideal.Colon","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ Eq (Submodule.colon I Top.top) I","decl":"@[simp]\ntheorem colon_top {I : Ideal R} : I.colon ⊤ = I := by\n  simp_rw [SetLike.ext_iff, mem_colon, smul_eq_mul]\n  exact fun x ↦ ⟨fun h ↦ mul_one x ▸ h 1 trivial, fun h _ _ ↦ I.mul_mem_right _ h⟩\n\n"}
{"name":"Submodule.colon_bot","module":"Mathlib.RingTheory.Ideal.Colon","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN : Submodule R M\n⊢ Eq (Bot.bot.colon N) N.annihilator","decl":"@[simp]\ntheorem colon_bot : colon ⊥ N = N.annihilator := by\n  simp_rw [SetLike.ext_iff, mem_colon, mem_annihilator, mem_bot, forall_const]\n\n"}
{"name":"Submodule.colon_mono","module":"Mathlib.RingTheory.Ideal.Colon","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN₁ N₂ P₁ P₂ : Submodule R M\nhn : LE.le N₁ N₂\nhp : LE.le P₁ P₂\n⊢ LE.le (N₁.colon P₂) (N₂.colon P₁)","decl":"theorem colon_mono (hn : N₁ ≤ N₂) (hp : P₁ ≤ P₂) : N₁.colon P₂ ≤ N₂.colon P₁ := fun _ hrnp =>\n  mem_colon.2 fun p₁ hp₁ => hn <| mem_colon.1 hrnp p₁ <| hp hp₁\n\n"}
{"name":"Submodule.iInf_colon_iSup","module":"Mathlib.RingTheory.Ideal.Colon","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι₁ : Sort u_6\nf : ι₁ → Submodule R M\nι₂ : Sort u_7\ng : ι₂ → Submodule R M\n⊢ Eq ((iInf fun i => f i).colon (iSup fun j => g j)) (iInf fun i => iInf fun j => (f i).colon (g j))","decl":"theorem iInf_colon_iSup (ι₁ : Sort*) (f : ι₁ → Submodule R M) (ι₂ : Sort*)\n    (g : ι₂ → Submodule R M) : (⨅ i, f i).colon (⨆ j, g j) = ⨅ (i) (j), (f i).colon (g j) :=\n  le_antisymm (le_iInf fun _ => le_iInf fun _ => colon_mono (iInf_le _ _) (le_iSup _ _)) fun _ H =>\n    mem_colon'.2 <|\n      iSup_le fun j =>\n        map_le_iff_le_comap.1 <|\n          le_iInf fun i =>\n            map_le_iff_le_comap.2 <|\n              mem_colon'.1 <|\n                have := (mem_iInf _).1 H i\n                have := (mem_iInf _).1 this j\n                this\n\n"}
{"name":"Submodule.mem_colon_singleton","module":"Mathlib.RingTheory.Ideal.Colon","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN : Submodule R M\nx : M\nr : R\n⊢ Iff (Membership.mem (N.colon (Submodule.span R (Singleton.singleton x))) r) (Membership.mem N (HSMul.hSMul r x))","decl":"@[simp]\ntheorem mem_colon_singleton {N : Submodule R M} {x : M} {r : R} :\n    r ∈ N.colon (Submodule.span R {x}) ↔ r • x ∈ N :=\n  calc\n    r ∈ N.colon (Submodule.span R {x}) ↔ ∀ a : R, r • a • x ∈ N := by\n      simp [Submodule.mem_colon, Submodule.mem_span_singleton]\n    _ ↔ r • x ∈ N := by simp_rw [fun (a : R) ↦ smul_comm r a x]; exact SetLike.forall_smul_mem_iff\n\n"}
{"name":"Ideal.mem_colon_singleton","module":"Mathlib.RingTheory.Ideal.Colon","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\nx r : R\n⊢ Iff (Membership.mem (Submodule.colon I (Ideal.span (Singleton.singleton x))) r) (Membership.mem I (HMul.hMul r x))","decl":"@[simp]\ntheorem _root_.Ideal.mem_colon_singleton {I : Ideal R} {x r : R} :\n    r ∈ I.colon (Ideal.span {x}) ↔ r * x ∈ I := by\n  simp only [← Ideal.submodule_span_eq, Submodule.mem_colon_singleton, smul_eq_mul]\n\n"}
{"name":"Submodule.annihilator_map_mkQ_eq_colon","module":"Mathlib.RingTheory.Ideal.Colon","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN P : Submodule R M\n⊢ Eq (Submodule.map N.mkQ P).annihilator (N.colon P)","decl":"@[simp]\nlemma annihilator_map_mkQ_eq_colon : annihilator (P.map N.mkQ) = N.colon P := by\n  ext\n  rw [mem_annihilator, mem_colon]\n  exact ⟨fun H p hp ↦ (Quotient.mk_eq_zero N).1 (H (Quotient.mk p) (mem_map_of_mem hp)),\n    fun H _ ⟨p, hp, hpm⟩ ↦ hpm ▸ ((Quotient.mk_eq_zero N).2 <| H p hp)⟩\n\n"}
{"name":"Submodule.annihilator_quotient","module":"Mathlib.RingTheory.Ideal.Colon","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN : Submodule R M\n⊢ Eq (Module.annihilator R (HasQuotient.Quotient M N)) (N.colon Top.top)","decl":"theorem annihilator_quotient {N : Submodule R M} :\n    Module.annihilator R (M ⧸ N) = N.colon ⊤ := by\n  simp_rw [SetLike.ext_iff, Module.mem_annihilator, ←annihilator_map_mkQ_eq_colon, mem_annihilator,\n      map_top, LinearMap.range_eq_top.mpr (mkQ_surjective N), mem_top, forall_true_left,\n      forall_const]\n\n"}
{"name":"Ideal.annihilator_quotient","module":"Mathlib.RingTheory.Ideal.Colon","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal R\n⊢ Eq (Module.annihilator R (HasQuotient.Quotient R I)) I","decl":"theorem _root_.Ideal.annihilator_quotient {I : Ideal R} : Module.annihilator R (R ⧸ I) = I := by\n  rw [Submodule.annihilator_quotient, colon_top]\n\n"}
