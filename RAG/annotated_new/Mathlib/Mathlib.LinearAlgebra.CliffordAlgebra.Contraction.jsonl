{"name":"CliffordAlgebra.contractLeftAux_apply_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nd : Module.Dual R M\na✝ : M\na : Prod (CliffordAlgebra Q) (CliffordAlgebra Q)\n⊢ Eq (((CliffordAlgebra.contractLeftAux Q d) a✝) a) (HSub.hSub (HSMul.hSMul (d a✝) a.1) (HMul.hMul ((CliffordAlgebra.ι Q) a✝) a.2))","decl":"/-- Auxiliary construction for `CliffordAlgebra.contractLeft` -/\n@[simps!]\ndef contractLeftAux (d : Module.Dual R M) :\n    M →ₗ[R] CliffordAlgebra Q × CliffordAlgebra Q →ₗ[R] CliffordAlgebra Q :=\n  haveI v_mul := (Algebra.lmul R (CliffordAlgebra Q)).toLinearMap ∘ₗ ι Q\n  d.smulRight (LinearMap.fst _ (CliffordAlgebra Q) (CliffordAlgebra Q)) -\n    v_mul.compl₂ (LinearMap.snd _ (CliffordAlgebra Q) _)\n\n"}
{"name":"CliffordAlgebra.contractLeftAux_contractLeftAux","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nd : Module.Dual R M\nv : M\nx fx : CliffordAlgebra Q\n⊢ Eq (((CliffordAlgebra.contractLeftAux Q d) v) { fst := HMul.hMul ((CliffordAlgebra.ι Q) v) x, snd := ((CliffordAlgebra.contractLeftAux Q d) v) { fst := x, snd := fx } }) (HSMul.hSMul (Q v) fx)","decl":"theorem contractLeftAux_contractLeftAux (v : M) (x : CliffordAlgebra Q) (fx : CliffordAlgebra Q) :\n    contractLeftAux Q d v (ι Q v * x, contractLeftAux Q d v (x, fx)) = Q v • fx := by\n  simp only [contractLeftAux_apply_apply]\n  rw [mul_sub, ← mul_assoc, ι_sq_scalar, ← Algebra.smul_def, ← sub_add, mul_smul_comm, sub_self,\n    zero_add]\n\n"}
{"name":"CliffordAlgebra.contractRight_eq","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nd : Module.Dual R M\nx : CliffordAlgebra Q\n⊢ Eq ((CliffordAlgebra.contractRight x) d) (CliffordAlgebra.reverse ((CliffordAlgebra.contractLeft d) (CliffordAlgebra.reverse x)))","decl":"theorem contractRight_eq (x : CliffordAlgebra Q) :\n    contractRight (Q := Q) x d = reverse (contractLeft (R := R) (M := M) d <| reverse x) :=\n  rfl\n\n"}
{"name":"CliffordAlgebra.contractLeft_ι_mul","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nd : Module.Dual R M\na : M\nb : CliffordAlgebra Q\n⊢ Eq ((CliffordAlgebra.contractLeft d) (HMul.hMul ((CliffordAlgebra.ι Q) a) b)) (HSub.hSub (HSMul.hSMul (d a) b) (HMul.hMul ((CliffordAlgebra.ι Q) a) ((CliffordAlgebra.contractLeft d) b)))","decl":"/-- This is [grinberg_clifford_2016][] Theorem 6  -/\ntheorem contractLeft_ι_mul (a : M) (b : CliffordAlgebra Q) :\n    d⌋(ι Q a * b) = d a • b - ι Q a * (d⌋b) := by\n-- Porting note: Lean cannot figure out anymore the third argument\n  refine foldr'_ι_mul _ _ ?_ _ _ _\n  exact fun m x fx ↦ contractLeftAux_contractLeftAux Q d m x fx\n\n"}
{"name":"CliffordAlgebra.contractRight_mul_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nd : Module.Dual R M\na : M\nb : CliffordAlgebra Q\n⊢ Eq ((CliffordAlgebra.contractRight (HMul.hMul b ((CliffordAlgebra.ι Q) a))) d) (HSub.hSub (HSMul.hSMul (d a) b) (HMul.hMul ((CliffordAlgebra.contractRight b) d) ((CliffordAlgebra.ι Q) a)))","decl":"/-- This is [grinberg_clifford_2016][] Theorem 12  -/\ntheorem contractRight_mul_ι (a : M) (b : CliffordAlgebra Q) :\n    b * ι Q a⌊d = d a • b - b⌊d * ι Q a := by\n  rw [contractRight_eq, reverse.map_mul, reverse_ι, contractLeft_ι_mul, map_sub, map_smul,\n    reverse_reverse, reverse.map_mul, reverse_ι, contractRight_eq]\n\n"}
{"name":"CliffordAlgebra.contractLeft_algebraMap_mul","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nd : Module.Dual R M\nr : R\nb : CliffordAlgebra Q\n⊢ Eq ((CliffordAlgebra.contractLeft d) (HMul.hMul ((algebraMap R (CliffordAlgebra Q)) r) b)) (HMul.hMul ((algebraMap R (CliffordAlgebra Q)) r) ((CliffordAlgebra.contractLeft d) b))","decl":"theorem contractLeft_algebraMap_mul (r : R) (b : CliffordAlgebra Q) :\n    d⌋(algebraMap _ _ r * b) = algebraMap _ _ r * (d⌋b) := by\n  rw [← Algebra.smul_def, map_smul, Algebra.smul_def]\n\n"}
{"name":"CliffordAlgebra.contractLeft_mul_algebraMap","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nd : Module.Dual R M\na : CliffordAlgebra Q\nr : R\n⊢ Eq ((CliffordAlgebra.contractLeft d) (HMul.hMul a ((algebraMap R (CliffordAlgebra Q)) r))) (HMul.hMul ((CliffordAlgebra.contractLeft d) a) ((algebraMap R (CliffordAlgebra Q)) r))","decl":"theorem contractLeft_mul_algebraMap (a : CliffordAlgebra Q) (r : R) :\n    d⌋(a * algebraMap _ _ r) = d⌋a * algebraMap _ _ r := by\n  rw [← Algebra.commutes, contractLeft_algebraMap_mul, Algebra.commutes]\n\n"}
{"name":"CliffordAlgebra.contractRight_algebraMap_mul","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nd : Module.Dual R M\nr : R\nb : CliffordAlgebra Q\n⊢ Eq ((CliffordAlgebra.contractRight (HMul.hMul ((algebraMap R (CliffordAlgebra Q)) r) b)) d) (HMul.hMul ((algebraMap R (CliffordAlgebra Q)) r) ((CliffordAlgebra.contractRight b) d))","decl":"theorem contractRight_algebraMap_mul (r : R) (b : CliffordAlgebra Q) :\n    algebraMap _ _ r * b⌊d = algebraMap _ _ r * (b⌊d) := by\n  rw [← Algebra.smul_def, LinearMap.map_smul₂, Algebra.smul_def]\n\n"}
{"name":"CliffordAlgebra.contractRight_mul_algebraMap","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nd : Module.Dual R M\na : CliffordAlgebra Q\nr : R\n⊢ Eq ((CliffordAlgebra.contractRight (HMul.hMul a ((algebraMap R (CliffordAlgebra Q)) r))) d) (HMul.hMul ((CliffordAlgebra.contractRight a) d) ((algebraMap R (CliffordAlgebra Q)) r))","decl":"theorem contractRight_mul_algebraMap (a : CliffordAlgebra Q) (r : R) :\n    a * algebraMap _ _ r⌊d = a⌊d * algebraMap _ _ r := by\n  rw [← Algebra.commutes, contractRight_algebraMap_mul, Algebra.commutes]\n\n"}
{"name":"CliffordAlgebra.contractLeft_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nd : Module.Dual R M\nx : M\n⊢ Eq ((CliffordAlgebra.contractLeft d) ((CliffordAlgebra.ι Q) x)) ((algebraMap R (CliffordAlgebra Q)) (d x))","decl":"@[simp]\ntheorem contractLeft_ι (x : M) : d⌋ι Q x = algebraMap R _ (d x) := by\n-- Porting note: Lean cannot figure out anymore the third argument\n  refine (foldr'_ι _ _ ?_ _ _).trans <| by\n    simp_rw [contractLeftAux_apply_apply, mul_zero, sub_zero,\n      Algebra.algebraMap_eq_smul_one]\n  exact fun m x fx ↦ contractLeftAux_contractLeftAux Q d m x fx\n\n"}
{"name":"CliffordAlgebra.contractRight_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nd : Module.Dual R M\nx : M\n⊢ Eq ((CliffordAlgebra.contractRight ((CliffordAlgebra.ι Q) x)) d) ((algebraMap R (CliffordAlgebra Q)) (d x))","decl":"@[simp]\ntheorem contractRight_ι (x : M) : ι Q x⌊d = algebraMap R _ (d x) := by\n  rw [contractRight_eq, reverse_ι, contractLeft_ι, reverse.commutes]\n\n"}
{"name":"CliffordAlgebra.contractLeft_algebraMap","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nd : Module.Dual R M\nr : R\n⊢ Eq ((CliffordAlgebra.contractLeft d) ((algebraMap R (CliffordAlgebra Q)) r)) 0","decl":"@[simp]\ntheorem contractLeft_algebraMap (r : R) : d⌋algebraMap R (CliffordAlgebra Q) r = 0 := by\n-- Porting note: Lean cannot figure out anymore the third argument\n  refine (foldr'_algebraMap _ _ ?_ _ _).trans <| smul_zero _\n  exact fun m x fx ↦ contractLeftAux_contractLeftAux Q d m x fx\n\n"}
{"name":"CliffordAlgebra.contractRight_algebraMap","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nd : Module.Dual R M\nr : R\n⊢ Eq ((CliffordAlgebra.contractRight ((algebraMap R (CliffordAlgebra Q)) r)) d) 0","decl":"@[simp]\ntheorem contractRight_algebraMap (r : R) : algebraMap R (CliffordAlgebra Q) r⌊d = 0 := by\n  rw [contractRight_eq, reverse.commutes, contractLeft_algebraMap, map_zero]\n\n"}
{"name":"CliffordAlgebra.contractLeft_one","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nd : Module.Dual R M\n⊢ Eq ((CliffordAlgebra.contractLeft d) 1) 0","decl":"@[simp]\ntheorem contractLeft_one : d⌋(1 : CliffordAlgebra Q) = 0 := by\n  simpa only [map_one] using contractLeft_algebraMap Q d 1\n\n"}
{"name":"CliffordAlgebra.contractRight_one","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nd : Module.Dual R M\n⊢ Eq ((CliffordAlgebra.contractRight 1) d) 0","decl":"@[simp]\ntheorem contractRight_one : (1 : CliffordAlgebra Q)⌊d = 0 := by\n  simpa only [map_one] using contractRight_algebraMap Q d 1\n\n"}
{"name":"CliffordAlgebra.contractLeft_contractLeft","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nd : Module.Dual R M\nx : CliffordAlgebra Q\n⊢ Eq ((CliffordAlgebra.contractLeft d) ((CliffordAlgebra.contractLeft d) x)) 0","decl":"/-- This is [grinberg_clifford_2016][] Theorem 7 -/\ntheorem contractLeft_contractLeft (x : CliffordAlgebra Q) : d⌋(d⌋x) = 0 := by\n  induction' x using CliffordAlgebra.left_induction with r x y hx hy m x hx\n  · simp_rw [contractLeft_algebraMap, map_zero]\n  · rw [map_add, map_add, hx, hy, add_zero]\n  · rw [contractLeft_ι_mul, map_sub, contractLeft_ι_mul, hx, LinearMap.map_smul,\n      mul_zero, sub_zero, sub_self]\n\n"}
{"name":"CliffordAlgebra.contractRight_contractRight","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nd : Module.Dual R M\nx : CliffordAlgebra Q\n⊢ Eq ((CliffordAlgebra.contractRight ((CliffordAlgebra.contractRight x) d)) d) 0","decl":"/-- This is [grinberg_clifford_2016][] Theorem 13 -/\ntheorem contractRight_contractRight (x : CliffordAlgebra Q) : x⌊d⌊d = 0 := by\n  rw [contractRight_eq, contractRight_eq, reverse_reverse, contractLeft_contractLeft, map_zero]\n\n"}
{"name":"CliffordAlgebra.contractLeft_comm","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nd d' : Module.Dual R M\nx : CliffordAlgebra Q\n⊢ Eq ((CliffordAlgebra.contractLeft d) ((CliffordAlgebra.contractLeft d') x)) (Neg.neg ((CliffordAlgebra.contractLeft d') ((CliffordAlgebra.contractLeft d) x)))","decl":"/-- This is [grinberg_clifford_2016][] Theorem 8 -/\ntheorem contractLeft_comm (x : CliffordAlgebra Q) : d⌋(d'⌋x) = -(d'⌋(d⌋x)) := by\n  induction' x using CliffordAlgebra.left_induction with r x y hx hy m x hx\n  · simp_rw [contractLeft_algebraMap, map_zero, neg_zero]\n  · rw [map_add, map_add, map_add, map_add, hx, hy, neg_add]\n  · simp only [contractLeft_ι_mul, map_sub, LinearMap.map_smul]\n    rw [neg_sub, sub_sub_eq_add_sub, hx, mul_neg, ← sub_eq_add_neg]\n\n"}
{"name":"CliffordAlgebra.contractRight_comm","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nd d' : Module.Dual R M\nx : CliffordAlgebra Q\n⊢ Eq ((CliffordAlgebra.contractRight ((CliffordAlgebra.contractRight x) d)) d') (Neg.neg ((CliffordAlgebra.contractRight ((CliffordAlgebra.contractRight x) d')) d))","decl":"/-- This is [grinberg_clifford_2016][] Theorem 14 -/\ntheorem contractRight_comm (x : CliffordAlgebra Q) : x⌊d⌊d' = -(x⌊d'⌊d) := by\n  rw [contractRight_eq, contractRight_eq, contractRight_eq, contractRight_eq, reverse_reverse,\n    reverse_reverse, contractLeft_comm, map_neg]\n\n/- TODO:\nlemma contractRight_contractLeft (x : CliffordAlgebra Q) : (d ⌋ x) ⌊ d' = d ⌋ (x ⌊ d') :=\n-/\n"}
{"name":"CliffordAlgebra.changeFormAux_apply_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nB : LinearMap.BilinForm R M\na✝ : M\na : CliffordAlgebra Q\n⊢ Eq (((CliffordAlgebra.changeFormAux Q B) a✝) a) (HSub.hSub (HMul.hMul ((CliffordAlgebra.ι Q) a✝) a) ((CliffordAlgebra.contractLeft (B a✝)) a))","decl":"/-- Auxiliary construction for `CliffordAlgebra.changeForm` -/\n@[simps!]\ndef changeFormAux (B : BilinForm R M) : M →ₗ[R] CliffordAlgebra Q →ₗ[R] CliffordAlgebra Q :=\n  haveI v_mul := (Algebra.lmul R (CliffordAlgebra Q)).toLinearMap ∘ₗ ι Q\n  v_mul - contractLeft ∘ₗ B\n\n"}
{"name":"CliffordAlgebra.changeFormAux_changeFormAux","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nB : LinearMap.BilinForm R M\nv : M\nx : CliffordAlgebra Q\n⊢ Eq (((CliffordAlgebra.changeFormAux Q B) v) (((CliffordAlgebra.changeFormAux Q B) v) x)) (HSMul.hSMul (HSub.hSub (Q v) ((B v) v)) x)","decl":"theorem changeFormAux_changeFormAux (B : BilinForm R M) (v : M) (x : CliffordAlgebra Q) :\n    changeFormAux Q B v (changeFormAux Q B v x) = (Q v - B v v) • x := by\n  simp only [changeFormAux_apply_apply]\n  rw [mul_sub, ← mul_assoc, ι_sq_scalar, map_sub, contractLeft_ι_mul, ← sub_add, sub_sub_sub_comm,\n    ← Algebra.smul_def, sub_self, sub_zero, contractLeft_contractLeft, add_zero, sub_smul]\n\n"}
{"name":"CliffordAlgebra.changeForm.zero_proof","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Eq (LinearMap.BilinMap.toQuadraticMap 0) (HSub.hSub Q Q)","decl":"/-- Auxiliary lemma used as an argument to `CliffordAlgebra.changeForm` -/\ntheorem changeForm.zero_proof : (0 : BilinForm R M).toQuadraticMap = Q - Q :=\n  (sub_self _).symm\n\n"}
{"name":"CliffordAlgebra.changeForm.add_proof","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ Q' Q'' : QuadraticForm R M\nB B' : LinearMap.BilinForm R M\nh : Eq (LinearMap.BilinMap.toQuadraticMap B) (HSub.hSub Q' Q)\nh' : Eq (LinearMap.BilinMap.toQuadraticMap B') (HSub.hSub Q'' Q')\n⊢ Eq (LinearMap.BilinMap.toQuadraticMap (HAdd.hAdd B B')) (HSub.hSub Q'' Q)","decl":"include h h' in\n/-- Auxiliary lemma used as an argument to `CliffordAlgebra.changeForm` -/\ntheorem changeForm.add_proof : (B + B').toQuadraticMap = Q'' - Q :=\n  (congr_arg₂ (· + ·) h h').trans <| sub_add_sub_cancel' _ _ _\n\n"}
{"name":"CliffordAlgebra.changeForm.neg_proof","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ Q' : QuadraticForm R M\nB : LinearMap.BilinForm R M\nh : Eq (LinearMap.BilinMap.toQuadraticMap B) (HSub.hSub Q' Q)\n⊢ Eq (LinearMap.BilinMap.toQuadraticMap (Neg.neg B)) (HSub.hSub Q Q')","decl":"include h in\n/-- Auxiliary lemma used as an argument to `CliffordAlgebra.changeForm` -/\ntheorem changeForm.neg_proof : (-B).toQuadraticMap = Q - Q' :=\n  (congr_arg Neg.neg h).trans <| neg_sub _ _\n\n"}
{"name":"CliffordAlgebra.changeForm.associated_neg_proof","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝³ : CommRing R\nM : Type u2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nQ : QuadraticForm R M\ninst✝ : Invertible 2\n⊢ Eq (QuadraticMap.associated (Neg.neg Q)).toQuadraticMap (HSub.hSub 0 Q)","decl":"theorem changeForm.associated_neg_proof [Invertible (2 : R)] :\n    (QuadraticMap.associated (R := R) (M := M) (-Q)).toQuadraticMap = 0 - Q := by\n  simp [QuadraticMap.toQuadraticMap_associated]\n\n"}
{"name":"CliffordAlgebra.changeForm_algebraMap","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ Q' : QuadraticForm R M\nB : LinearMap.BilinForm R M\nh : Eq (LinearMap.BilinMap.toQuadraticMap B) (HSub.hSub Q' Q)\nr : R\n⊢ Eq ((CliffordAlgebra.changeForm h) ((algebraMap R (CliffordAlgebra Q)) r)) ((algebraMap R (CliffordAlgebra Q')) r)","decl":"@[simp]\ntheorem changeForm_algebraMap (r : R) : changeForm h (algebraMap R _ r) = algebraMap R _ r :=\n  (foldr_algebraMap _ _ _ _ _).trans <| Eq.symm <| Algebra.algebraMap_eq_smul_one r\n\n"}
{"name":"CliffordAlgebra.changeForm_one","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ Q' : QuadraticForm R M\nB : LinearMap.BilinForm R M\nh : Eq (LinearMap.BilinMap.toQuadraticMap B) (HSub.hSub Q' Q)\n⊢ Eq ((CliffordAlgebra.changeForm h) 1) 1","decl":"@[simp]\ntheorem changeForm_one : changeForm h (1 : CliffordAlgebra Q) = 1 := by\n  simpa using changeForm_algebraMap h (1 : R)\n\n"}
{"name":"CliffordAlgebra.changeForm_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ Q' : QuadraticForm R M\nB : LinearMap.BilinForm R M\nh : Eq (LinearMap.BilinMap.toQuadraticMap B) (HSub.hSub Q' Q)\nm : M\n⊢ Eq ((CliffordAlgebra.changeForm h) ((CliffordAlgebra.ι Q) m)) ((CliffordAlgebra.ι Q') m)","decl":"@[simp]\ntheorem changeForm_ι (m : M) : changeForm h (ι (M := M) Q m) = ι (M := M) Q' m :=\n  (foldr_ι _ _ _ _ _).trans <|\n    Eq.symm <| by rw [changeFormAux_apply_apply, mul_one, contractLeft_one, sub_zero]\n\n"}
{"name":"CliffordAlgebra.changeForm_ι_mul","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ Q' : QuadraticForm R M\nB : LinearMap.BilinForm R M\nh : Eq (LinearMap.BilinMap.toQuadraticMap B) (HSub.hSub Q' Q)\nm : M\nx : CliffordAlgebra Q\n⊢ Eq ((CliffordAlgebra.changeForm h) (HMul.hMul ((CliffordAlgebra.ι Q) m) x)) (HSub.hSub (HMul.hMul ((CliffordAlgebra.ι Q') m) ((CliffordAlgebra.changeForm h) x)) ((CliffordAlgebra.contractLeft (B m)) ((CliffordAlgebra.changeForm h) x)))","decl":"theorem changeForm_ι_mul (m : M) (x : CliffordAlgebra Q) :\n    changeForm h (ι (M := M) Q m * x) = ι (M := M) Q' m * changeForm h x\n    - contractLeft (Q := Q') (B m) (changeForm h x) :=\n-- Porting note: original statement\n--    - BilinForm.toLin B m⌋changeForm h x :=\n  (foldr_mul _ _ _ _ _ _).trans <| by rw [foldr_ι]; rfl\n\n"}
{"name":"CliffordAlgebra.changeForm_ι_mul_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ Q' : QuadraticForm R M\nB : LinearMap.BilinForm R M\nh : Eq (LinearMap.BilinMap.toQuadraticMap B) (HSub.hSub Q' Q)\nm₁ m₂ : M\n⊢ Eq ((CliffordAlgebra.changeForm h) (HMul.hMul ((CliffordAlgebra.ι Q) m₁) ((CliffordAlgebra.ι Q) m₂))) (HSub.hSub (HMul.hMul ((CliffordAlgebra.ι Q') m₁) ((CliffordAlgebra.ι Q') m₂)) ((algebraMap R (CliffordAlgebra Q')) ((B m₁) m₂)))","decl":"theorem changeForm_ι_mul_ι (m₁ m₂ : M) :\n    changeForm h (ι Q m₁ * ι Q m₂) = ι Q' m₁ * ι Q' m₂ - algebraMap _ _ (B m₁ m₂) := by\n  rw [changeForm_ι_mul, changeForm_ι, contractLeft_ι]\n\n"}
{"name":"CliffordAlgebra.changeForm_contractLeft","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ Q' : QuadraticForm R M\nB : LinearMap.BilinForm R M\nh : Eq (LinearMap.BilinMap.toQuadraticMap B) (HSub.hSub Q' Q)\nd : Module.Dual R M\nx : CliffordAlgebra Q\n⊢ Eq ((CliffordAlgebra.changeForm h) ((CliffordAlgebra.contractLeft d) x)) ((CliffordAlgebra.contractLeft d) ((CliffordAlgebra.changeForm h) x))","decl":"/-- Theorem 23 of [grinberg_clifford_2016][] -/\ntheorem changeForm_contractLeft (d : Module.Dual R M) (x : CliffordAlgebra Q) :\n    -- Porting note: original statement\n    --    changeForm h (d⌋x) = d⌋changeForm h x := by\n    changeForm h (contractLeft (Q := Q) d x) = contractLeft (Q := Q') d (changeForm h x) := by\n  induction' x using CliffordAlgebra.left_induction with r x y hx hy m x hx\n  · simp only [contractLeft_algebraMap, changeForm_algebraMap, map_zero]\n  · rw [map_add, map_add, map_add, map_add, hx, hy]\n  · simp only [contractLeft_ι_mul, changeForm_ι_mul, map_sub, LinearMap.map_smul]\n    rw [← hx, contractLeft_comm, ← sub_add, sub_neg_eq_add, ← hx]\n\n"}
{"name":"CliffordAlgebra.changeForm_self_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\n⊢ Eq ((CliffordAlgebra.changeForm ⋯) x) x","decl":"theorem changeForm_self_apply (x : CliffordAlgebra Q) : changeForm (Q' := Q)\n    changeForm.zero_proof x = x := by\n  induction' x using CliffordAlgebra.left_induction with r x y hx hy m x hx\n  · simp_rw [changeForm_algebraMap]\n  · rw [map_add, hx, hy]\n  · rw [changeForm_ι_mul, hx, LinearMap.zero_apply, map_zero, LinearMap.zero_apply,\n      sub_zero]\n\n"}
{"name":"CliffordAlgebra.changeForm_self","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Eq (CliffordAlgebra.changeForm ⋯) LinearMap.id","decl":"@[simp]\ntheorem changeForm_self :\n    changeForm changeForm.zero_proof = (LinearMap.id : CliffordAlgebra Q →ₗ[R] _) :=\n  LinearMap.ext <| changeForm_self_apply\n\n"}
{"name":"CliffordAlgebra.changeForm_changeForm","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ Q' Q'' : QuadraticForm R M\nB B' : LinearMap.BilinForm R M\nh : Eq (LinearMap.BilinMap.toQuadraticMap B) (HSub.hSub Q' Q)\nh' : Eq (LinearMap.BilinMap.toQuadraticMap B') (HSub.hSub Q'' Q')\nx : CliffordAlgebra Q\n⊢ Eq ((CliffordAlgebra.changeForm h') ((CliffordAlgebra.changeForm h) x)) ((CliffordAlgebra.changeForm ⋯) x)","decl":"/-- This is [bourbaki2007][] $9 Lemma 3. -/\ntheorem changeForm_changeForm (x : CliffordAlgebra Q) :\n    changeForm h' (changeForm h x) = changeForm (changeForm.add_proof h h') x := by\n  induction' x using CliffordAlgebra.left_induction with r x y hx hy m x hx\n  · simp_rw [changeForm_algebraMap]\n  · rw [map_add, map_add, map_add, hx, hy]\n  · rw [changeForm_ι_mul, map_sub, changeForm_ι_mul, changeForm_ι_mul, hx, sub_sub,\n      LinearMap.add_apply, map_add, LinearMap.add_apply, changeForm_contractLeft, hx,\n      add_comm (_ : CliffordAlgebra Q'')]\n\n"}
{"name":"CliffordAlgebra.changeForm_comp_changeForm","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ Q' Q'' : QuadraticForm R M\nB B' : LinearMap.BilinForm R M\nh : Eq (LinearMap.BilinMap.toQuadraticMap B) (HSub.hSub Q' Q)\nh' : Eq (LinearMap.BilinMap.toQuadraticMap B') (HSub.hSub Q'' Q')\n⊢ Eq ((CliffordAlgebra.changeForm h').comp (CliffordAlgebra.changeForm h)) (CliffordAlgebra.changeForm ⋯)","decl":"theorem changeForm_comp_changeForm :\n    (changeForm h').comp (changeForm h) = changeForm (changeForm.add_proof h h') :=\n  LinearMap.ext <| changeForm_changeForm _ h'\n\n"}
{"name":"CliffordAlgebra.changeFormEquiv_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ Q' : QuadraticForm R M\nB : LinearMap.BilinForm R M\nh : Eq (LinearMap.BilinMap.toQuadraticMap B) (HSub.hSub Q' Q)\na : CliffordAlgebra Q\n⊢ Eq ((CliffordAlgebra.changeFormEquiv h) a) ((CliffordAlgebra.changeForm h) a)","decl":"/-- Any two algebras whose quadratic forms differ by a bilinear form are isomorphic as modules.\n\nThis is $\\bar \\lambda_B$ from [bourbaki2007][] $9 Proposition 3. -/\n@[simps apply]\ndef changeFormEquiv : CliffordAlgebra Q ≃ₗ[R] CliffordAlgebra Q' :=\n  { changeForm h with\n    toFun := changeForm h\n    invFun := changeForm (changeForm.neg_proof h)\n    left_inv := fun x => by\n      dsimp only\n      exact (changeForm_changeForm _ _ x).trans <|\n        by simp_rw [(add_neg_cancel B), changeForm_self_apply]\n    right_inv := fun x => by\n      dsimp only\n      exact (changeForm_changeForm _ _ x).trans <|\n        by simp_rw [(neg_add_cancel B), changeForm_self_apply] }\n\n"}
{"name":"CliffordAlgebra.changeFormEquiv_symm","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝² : CommRing R\nM : Type u2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ Q' : QuadraticForm R M\nB : LinearMap.BilinForm R M\nh : Eq (LinearMap.BilinMap.toQuadraticMap B) (HSub.hSub Q' Q)\n⊢ Eq (CliffordAlgebra.changeFormEquiv h).symm (CliffordAlgebra.changeFormEquiv ⋯)","decl":"@[simp]\ntheorem changeFormEquiv_symm :\n    (changeFormEquiv h).symm = changeFormEquiv (changeForm.neg_proof h) :=\n  LinearEquiv.ext fun _ => rfl\n\n"}
{"name":"CliffordAlgebra.instNontrivialOfInvertibleOfNat","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Contraction","initialProofState":"R : Type u1\ninst✝⁴ : CommRing R\nM : Type u2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\ninst✝¹ : Nontrivial R\ninst✝ : Invertible 2\n⊢ Nontrivial (CliffordAlgebra Q)","decl":"/-- A `CliffordAlgebra` over a nontrivial ring is nontrivial, in characteristic not two. -/\ninstance [Nontrivial R] [Invertible (2 : R)] :\n    Nontrivial (CliffordAlgebra Q) := (equivExterior Q).symm.injective.nontrivial\n\n"}
