{"name":"IsUltrametricDist.isUltrametricDist_of_forall_norm_add_one_le_max_norm_one","module":"Mathlib.Analysis.Normed.Field.Ultra","initialProofState":"R : Type u_1\ninst✝ : NormedDivisionRing R\nh : ∀ (x : R), LE.le (Norm.norm (HAdd.hAdd x 1)) (Max.max (Norm.norm x) 1)\n⊢ IsUltrametricDist R","decl":"lemma isUltrametricDist_of_forall_norm_add_one_le_max_norm_one\n    (h : ∀ x : R, ‖x + 1‖ ≤ max ‖x‖ 1) : IsUltrametricDist R := by\n  refine isUltrametricDist_of_forall_norm_add_le_max_norm (fun x y ↦ ?_)\n  rcases eq_or_ne y 0 with rfl | hy\n  · simpa only [add_zero] using le_max_left _ _\n  · have p : 0 < ‖y‖ := norm_pos_iff.mpr hy\n    simpa only [div_add_one hy, norm_div, div_le_iff₀ p, max_mul_of_nonneg _ _ p.le, one_mul,\n      div_mul_cancel₀ _ p.ne'] using h (x / y)\n\n"}
{"name":"IsUltrametricDist.isUltrametricDist_of_forall_norm_add_one_of_norm_le_one","module":"Mathlib.Analysis.Normed.Field.Ultra","initialProofState":"R : Type u_1\ninst✝ : NormedDivisionRing R\nh : ∀ (x : R), LE.le (Norm.norm x) 1 → LE.le (Norm.norm (HAdd.hAdd x 1)) 1\n⊢ IsUltrametricDist R","decl":"lemma isUltrametricDist_of_forall_norm_add_one_of_norm_le_one\n    (h : ∀ x : R, ‖x‖ ≤ 1 → ‖x + 1‖ ≤ 1) : IsUltrametricDist R := by\n  refine isUltrametricDist_of_forall_norm_add_one_le_max_norm_one fun x ↦ ?_\n  rcases le_or_lt ‖x‖ 1 with H|H\n  · exact (h _ H).trans (le_max_right _ _)\n  · suffices ‖x + 1‖ ≤ ‖x‖ from this.trans (le_max_left _ _)\n    rw [← div_le_one (by positivity), ← norm_div, add_div,\n      div_self (by simpa using H.trans' zero_lt_one), add_comm]\n    apply h\n    simp [inv_le_one_iff₀, H.le]\n\n"}
{"name":"IsUltrametricDist.isUltrametricDist_of_forall_norm_sub_one_of_norm_le_one","module":"Mathlib.Analysis.Normed.Field.Ultra","initialProofState":"R : Type u_1\ninst✝ : NormedDivisionRing R\nh : ∀ (x : R), LE.le (Norm.norm x) 1 → LE.le (Norm.norm (HSub.hSub x 1)) 1\n⊢ IsUltrametricDist R","decl":"lemma isUltrametricDist_of_forall_norm_sub_one_of_norm_le_one\n    (h : ∀ x : R, ‖x‖ ≤ 1 → ‖x - 1‖ ≤ 1) : IsUltrametricDist R := by\n  have (x : R) (hx : ‖x‖ ≤ 1) : ‖x + 1‖ ≤ 1 := by\n    simpa only [← neg_add', norm_neg] using h (-x) (norm_neg x ▸ hx)\n  exact isUltrametricDist_of_forall_norm_add_one_of_norm_le_one this\n\n"}
{"name":"IsUltrametricDist.isUltrametricDist_of_forall_pow_norm_le_nsmul_pow_max_one_norm","module":"Mathlib.Analysis.Normed.Field.Ultra","initialProofState":"R : Type u_1\ninst✝ : NormedDivisionRing R\nh : ∀ (x : R) (m : Nat), LE.le (HPow.hPow (Norm.norm (HAdd.hAdd x 1)) m) (HSMul.hSMul (HAdd.hAdd m 1) (Max.max 1 (HPow.hPow (Norm.norm x) m)))\n⊢ IsUltrametricDist R","decl":"/-- This technical lemma is used in the proof of\n`isUltrametricDist_of_forall_norm_natCast_le_one`. -/\nlemma isUltrametricDist_of_forall_pow_norm_le_nsmul_pow_max_one_norm\n    (h : ∀ (x : R) (m : ℕ), ‖x + 1‖ ^ m ≤ (m + 1) • max 1 (‖x‖ ^ m)) :\n    IsUltrametricDist R := by\n  -- it will suffice to prove that `‖x + 1‖ ≤ max 1 ‖x‖`\n  refine isUltrametricDist_of_forall_norm_add_one_le_max_norm_one fun x ↦ ?_\n  -- Morally, we want to deduce this from the hypothesis `h` by taking an `m`-th root and showing\n  -- that `(m + 1) ^ (1 / m)` gets arbitrarily close to 1, although we will formalise this in a way\n  -- that avoids explicitly mentioning `m`-th roots.\n  -- First note it suffices to show that `‖x + 1‖ ≤ a` for all `a : ℝ` with `max ‖x‖ 1 < a`.\n  rw [max_comm]\n  refine le_of_forall_gt_imp_ge_of_dense fun a ha ↦ ?_\n  have ha' : 1 < a := (max_lt_iff.mp ha).left\n  -- `max 1 ‖x‖ < a`, so there must be some `m : ℕ` such that `m + 1 < (a / max 1 ‖x‖) ^ m`\n  -- by the virtue of exponential growth being faster than linear growth\n  obtain ⟨m, hm⟩ : ∃ m : ℕ, ((m + 1) : ℕ) < (a / (max 1 ‖x‖)) ^ m := by\n    apply_mod_cast Real.exists_natCast_add_one_lt_pow_of_one_lt\n    rwa [one_lt_div (by positivity)]\n  -- and we rearrange again to get `(m + 1) • max 1 ‖x‖ ^ m < a ^ m`\n  rw [div_pow, lt_div_iff₀ (by positivity), ← nsmul_eq_mul] at hm\n  -- which squeezes down to get our `‖x + 1‖ ≤ a` using our to-be-proven hypothesis of\n  -- `‖x + 1‖ ^ m ≤ (m + 1) • max 1 ‖x‖ ^ m`, so we're done\n  -- we can distribute powers into the right term of `max`\n  have hp : max 1 ‖x‖ ^ m = max 1 (‖x‖ ^ m) := by\n    rw [pow_left_monotoneOn.map_max (by simp [zero_le_one]) (norm_nonneg x), one_pow]\n  rw [hp] at hm\n  refine le_of_pow_le_pow_left₀ (fun h ↦ ?_) (zero_lt_one.trans ha').le ((h _ _).trans hm.le)\n  simp only [h, zero_add, pow_zero, max_self, one_smul, lt_self_iff_false] at hm\n\n"}
{"name":"IsUltrametricDist.isUltrametricDist_of_forall_norm_natCast_le_one","module":"Mathlib.Analysis.Normed.Field.Ultra","initialProofState":"R : Type u_1\ninst✝ : NormedDivisionRing R\nh : ∀ (n : Nat), LE.le (Norm.norm ↑n) 1\n⊢ IsUltrametricDist R","decl":"/-- To prove that a normed division ring is nonarchimedean, it suffices to prove that the norm\nof the image of any natural is less than or equal to one. -/\nlemma isUltrametricDist_of_forall_norm_natCast_le_one\n    (h : ∀ n : ℕ, ‖(n : R)‖ ≤ 1) : IsUltrametricDist R := by\n  -- from a previous lemma, suffices to prove that for all `m`, we have\n  -- `‖x + 1‖ ^ m ≤ (m + 1) • max 1 ‖x‖ ^ m`\n  refine isUltrametricDist_of_forall_pow_norm_le_nsmul_pow_max_one_norm (fun x m ↦ ?_)\n  -- we first use our hypothesis about the norm of naturals to have that multiplication by\n  -- naturals keeps the norm small\n  replace h (x : R) (n : ℕ) : ‖n • x‖ ≤ ‖x‖ := by\n    rw [nsmul_eq_mul, norm_mul]\n    rcases (norm_nonneg x).eq_or_lt with hx | hx\n    · simp only [← hx, mul_zero, le_refl]\n    · simpa only [mul_le_iff_le_one_left hx] using h _\n  -- we expand the LHS using the binomial theorem, and apply the hypothesis to bound each term by\n  -- a power of ‖x‖\n  transitivity ∑ k ∈ Finset.range (m + 1), ‖x‖ ^ k\n  · simpa only [← norm_pow, (Commute.one_right x).add_pow, one_pow, mul_one, nsmul_eq_mul,\n      Nat.cast_comm] using (norm_sum_le _ _).trans (Finset.sum_le_sum fun _ _ ↦ h _ _)\n  -- the nature of the norm means that one of `1` and `‖x‖ ^ m` is the largest of the two, so the\n  -- other terms in the binomial expansion are bounded by the max of these, and the number of terms\n  -- in the sum is precisely `m + 1`\n  rw [← Finset.card_range (m + 1), ← Finset.sum_const, Finset.card_range]\n  rcases max_cases 1 (‖x‖ ^ m) with (⟨hm, hx⟩|⟨hm, hx⟩) <;> rw [hm] <;>\n  -- which we show by comparing the terms in the sum one by one\n  refine Finset.sum_le_sum fun i hi ↦ ?_\n  · rcases eq_or_ne m 0 with rfl | hm\n    · simp only [pow_zero, le_refl,\n        show i = 0 by simpa only [zero_add, Finset.range_one, Finset.mem_singleton] using hi]\n    · rw [pow_le_one_iff_of_nonneg (norm_nonneg _) hm] at hx\n      exact pow_le_one₀ (norm_nonneg _) hx\n  · refine pow_le_pow_right₀ ?_ (by simpa only [Finset.mem_range, Nat.lt_succ] using hi)\n    contrapose! hx\n    exact pow_le_one₀ (norm_nonneg _) hx.le\n\n"}
{"name":"isUltrametricDist_iff_forall_norm_natCast_le_one","module":"Mathlib.Analysis.Normed.Field.Ultra","initialProofState":"R : Type u_1\ninst✝ : NormedDivisionRing R\n⊢ Iff (IsUltrametricDist R) (∀ (n : Nat), LE.le (Norm.norm ↑n) 1)","decl":"theorem isUltrametricDist_iff_forall_norm_natCast_le_one {R : Type*}\n    [NormedDivisionRing R] : IsUltrametricDist R ↔ ∀ n : ℕ, ‖(n : R)‖ ≤ 1 :=\n  ⟨fun _ => IsUltrametricDist.norm_natCast_le_one R,\n      IsUltrametricDist.isUltrametricDist_of_forall_norm_natCast_le_one⟩\n"}
