{"name":"CategoryTheory.BraidedCategory.braiding_naturality_right","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nself : CategoryTheory.BraidedCategory C\nX Y Z : C\nf : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (CategoryTheory.BraidedCategory.braiding X Z).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X Y).hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X))","decl":"/-- A braided monoidal category is a monoidal category equipped with a braiding isomorphism\n`β_ X Y : X ⊗ Y ≅ Y ⊗ X`\nwhich is natural in both arguments,\nand also satisfies the two hexagon identities.\n-/\nclass BraidedCategory (C : Type u) [Category.{v} C] [MonoidalCategory.{v} C] where\n  /-- The braiding natural isomorphism. -/\n  braiding : ∀ X Y : C, X ⊗ Y ≅ Y ⊗ X\n  braiding_naturality_right :\n    ∀ (X : C) {Y Z : C} (f : Y ⟶ Z),\n      X ◁ f ≫ (braiding X Z).hom = (braiding X Y).hom ≫ f ▷ X := by\n    aesop_cat\n  braiding_naturality_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (Z : C),\n      f ▷ Z ≫ (braiding Y Z).hom = (braiding X Z).hom ≫ Z ◁ f := by\n    aesop_cat\n  /-- The first hexagon identity. -/\n  hexagon_forward :\n    ∀ X Y Z : C,\n      (α_ X Y Z).hom ≫ (braiding X (Y ⊗ Z)).hom ≫ (α_ Y Z X).hom =\n        ((braiding X Y).hom ▷ Z) ≫ (α_ Y X Z).hom ≫ (Y ◁ (braiding X Z).hom) := by\n    aesop_cat\n  /-- The second hexagon identity. -/\n  hexagon_reverse :\n    ∀ X Y Z : C,\n      (α_ X Y Z).inv ≫ (braiding (X ⊗ Y) Z).hom ≫ (α_ Z X Y).inv =\n        (X ◁ (braiding Y Z).hom) ≫ (α_ X Z Y).inv ≫ ((braiding X Z).hom ▷ Y) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.BraidedCategory.hexagon_reverse","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nself : CategoryTheory.BraidedCategory C\nX Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).hom (CategoryTheory.MonoidalCategoryStruct.associator Z X Y).inv)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.BraidedCategory.braiding Y Z).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Z Y).inv (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Z).hom Y)))","decl":"/-- A braided monoidal category is a monoidal category equipped with a braiding isomorphism\n`β_ X Y : X ⊗ Y ≅ Y ⊗ X`\nwhich is natural in both arguments,\nand also satisfies the two hexagon identities.\n-/\nclass BraidedCategory (C : Type u) [Category.{v} C] [MonoidalCategory.{v} C] where\n  /-- The braiding natural isomorphism. -/\n  braiding : ∀ X Y : C, X ⊗ Y ≅ Y ⊗ X\n  braiding_naturality_right :\n    ∀ (X : C) {Y Z : C} (f : Y ⟶ Z),\n      X ◁ f ≫ (braiding X Z).hom = (braiding X Y).hom ≫ f ▷ X := by\n    aesop_cat\n  braiding_naturality_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (Z : C),\n      f ▷ Z ≫ (braiding Y Z).hom = (braiding X Z).hom ≫ Z ◁ f := by\n    aesop_cat\n  /-- The first hexagon identity. -/\n  hexagon_forward :\n    ∀ X Y Z : C,\n      (α_ X Y Z).hom ≫ (braiding X (Y ⊗ Z)).hom ≫ (α_ Y Z X).hom =\n        ((braiding X Y).hom ▷ Z) ≫ (α_ Y X Z).hom ≫ (Y ◁ (braiding X Z).hom) := by\n    aesop_cat\n  /-- The second hexagon identity. -/\n  hexagon_reverse :\n    ∀ X Y Z : C,\n      (α_ X Y Z).inv ≫ (braiding (X ⊗ Y) Z).hom ≫ (α_ Z X Y).inv =\n        (X ◁ (braiding Y Z).hom) ≫ (α_ X Z Y).inv ≫ ((braiding X Z).hom ▷ Y) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.BraidedCategory.hexagon_forward","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nself : CategoryTheory.BraidedCategory C\nX Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).hom (CategoryTheory.MonoidalCategoryStruct.associator Y Z X).hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Y).hom Z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y X Z).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.BraidedCategory.braiding X Z).hom)))","decl":"/-- A braided monoidal category is a monoidal category equipped with a braiding isomorphism\n`β_ X Y : X ⊗ Y ≅ Y ⊗ X`\nwhich is natural in both arguments,\nand also satisfies the two hexagon identities.\n-/\nclass BraidedCategory (C : Type u) [Category.{v} C] [MonoidalCategory.{v} C] where\n  /-- The braiding natural isomorphism. -/\n  braiding : ∀ X Y : C, X ⊗ Y ≅ Y ⊗ X\n  braiding_naturality_right :\n    ∀ (X : C) {Y Z : C} (f : Y ⟶ Z),\n      X ◁ f ≫ (braiding X Z).hom = (braiding X Y).hom ≫ f ▷ X := by\n    aesop_cat\n  braiding_naturality_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (Z : C),\n      f ▷ Z ≫ (braiding Y Z).hom = (braiding X Z).hom ≫ Z ◁ f := by\n    aesop_cat\n  /-- The first hexagon identity. -/\n  hexagon_forward :\n    ∀ X Y Z : C,\n      (α_ X Y Z).hom ≫ (braiding X (Y ⊗ Z)).hom ≫ (α_ Y Z X).hom =\n        ((braiding X Y).hom ▷ Z) ≫ (α_ Y X Z).hom ≫ (Y ◁ (braiding X Z).hom) := by\n    aesop_cat\n  /-- The second hexagon identity. -/\n  hexagon_reverse :\n    ∀ X Y Z : C,\n      (α_ X Y Z).inv ≫ (braiding (X ⊗ Y) Z).hom ≫ (α_ Z X Y).inv =\n        (X ◁ (braiding Y Z).hom) ≫ (α_ X Z Y).inv ≫ ((braiding X Z).hom ▷ Y) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.BraidedCategory.braiding_naturality_left","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nself : CategoryTheory.BraidedCategory C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z) (CategoryTheory.BraidedCategory.braiding Y Z).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X Z).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z f))","decl":"/-- A braided monoidal category is a monoidal category equipped with a braiding isomorphism\n`β_ X Y : X ⊗ Y ≅ Y ⊗ X`\nwhich is natural in both arguments,\nand also satisfies the two hexagon identities.\n-/\nclass BraidedCategory (C : Type u) [Category.{v} C] [MonoidalCategory.{v} C] where\n  /-- The braiding natural isomorphism. -/\n  braiding : ∀ X Y : C, X ⊗ Y ≅ Y ⊗ X\n  braiding_naturality_right :\n    ∀ (X : C) {Y Z : C} (f : Y ⟶ Z),\n      X ◁ f ≫ (braiding X Z).hom = (braiding X Y).hom ≫ f ▷ X := by\n    aesop_cat\n  braiding_naturality_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (Z : C),\n      f ▷ Z ≫ (braiding Y Z).hom = (braiding X Z).hom ≫ Z ◁ f := by\n    aesop_cat\n  /-- The first hexagon identity. -/\n  hexagon_forward :\n    ∀ X Y Z : C,\n      (α_ X Y Z).hom ≫ (braiding X (Y ⊗ Z)).hom ≫ (α_ Y Z X).hom =\n        ((braiding X Y).hom ▷ Z) ≫ (α_ Y X Z).hom ≫ (Y ◁ (braiding X Z).hom) := by\n    aesop_cat\n  /-- The second hexagon identity. -/\n  hexagon_reverse :\n    ∀ X Y Z : C,\n      (α_ X Y Z).inv ≫ (braiding (X ⊗ Y) Z).hom ≫ (α_ Z X Y).inv =\n        (X ◁ (braiding Y Z).hom) ≫ (α_ X Z Y).inv ≫ ((braiding X Z).hom ▷ Y) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.BraidedCategory.braiding_naturality_left_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nself : CategoryTheory.BraidedCategory C\nX Y : C\nf : Quiver.Hom X Y\nZ✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Z✝ Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding Y Z✝).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z✝ f) h))","decl":"attribute [reassoc (attr := simp)]\n  BraidedCategory.braiding_naturality_left\n  BraidedCategory.braiding_naturality_right\n"}
{"name":"CategoryTheory.BraidedCategory.braiding_naturality_right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nself : CategoryTheory.BraidedCategory C\nX Y Z✝ : C\nf : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Z✝ X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X Z✝).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X Y).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X) h))","decl":"attribute [reassoc (attr := simp)]\n  BraidedCategory.braiding_naturality_left\n  BraidedCategory.braiding_naturality_right\n"}
{"name":"CategoryTheory.BraidedCategory.hexagon_reverse_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nself : CategoryTheory.BraidedCategory C\nX Y Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj Z✝ X) Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Z✝ X Y).inv h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.BraidedCategory.braiding Y Z✝).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Z✝ Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Z✝).hom Y) h)))","decl":"attribute [reassoc] BraidedCategory.hexagon_forward BraidedCategory.hexagon_reverse\n\n"}
{"name":"CategoryTheory.BraidedCategory.hexagon_forward_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nself : CategoryTheory.BraidedCategory C\nX Y Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Y (CategoryTheory.MonoidalCategoryStruct.tensorObj Z✝ X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y Z✝ X).hom h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Y).hom Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y X Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.BraidedCategory.braiding X Z✝).hom) h)))","decl":"attribute [reassoc] BraidedCategory.hexagon_forward BraidedCategory.hexagon_reverse\n\n"}
{"name":"CategoryTheory.BraidedCategory.braiding_tensor_left_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Z✝ (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.BraidedCategory.braiding Y Z✝).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Z✝ Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Z✝).hom Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Z✝ X Y).hom h)))))","decl":"@[simp, reassoc]\ntheorem braiding_tensor_left (X Y Z : C) :\n    (β_ (X ⊗ Y) Z).hom  =\n      (α_ X Y Z).hom ≫ X ◁ (β_ Y Z).hom ≫ (α_ X Z Y).inv ≫\n        (β_ X Z).hom ▷ Y ≫ (α_ Z X Y).hom := by\n  apply (cancel_epi (α_ X Y Z).inv).1\n  apply (cancel_mono (α_ Z X Y).inv).1\n  simp [hexagon_reverse]\n\n"}
{"name":"CategoryTheory.BraidedCategory.braiding_tensor_left","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y Z : C\n⊢ Eq (CategoryTheory.BraidedCategory.braiding (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.BraidedCategory.braiding Y Z).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Z Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Z).hom Y) (CategoryTheory.MonoidalCategoryStruct.associator Z X Y).hom))))","decl":"@[simp, reassoc]\ntheorem braiding_tensor_left (X Y Z : C) :\n    (β_ (X ⊗ Y) Z).hom  =\n      (α_ X Y Z).hom ≫ X ◁ (β_ Y Z).hom ≫ (α_ X Z Y).inv ≫\n        (β_ X Z).hom ▷ Y ≫ (α_ Z X Y).hom := by\n  apply (cancel_epi (α_ X Y Z).inv).1\n  apply (cancel_mono (α_ Z X Y).inv).1\n  simp [hexagon_reverse]\n\n"}
{"name":"CategoryTheory.BraidedCategory.braiding_tensor_right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝) X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Y).hom Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y X Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.BraidedCategory.braiding X Z✝).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y Z✝ X).inv h)))))","decl":"@[simp, reassoc]\ntheorem braiding_tensor_right (X Y Z : C) :\n    (β_ X (Y ⊗ Z)).hom  =\n      (α_ X Y Z).inv ≫ (β_ X Y).hom ▷ Z ≫ (α_ Y X Z).hom ≫\n        Y ◁ (β_ X Z).hom ≫ (α_ Y Z X).inv := by\n  apply (cancel_epi (α_ X Y Z).hom).1\n  apply (cancel_mono (α_ Y Z X).hom).1\n  simp [hexagon_forward]\n\n"}
{"name":"CategoryTheory.BraidedCategory.braiding_tensor_right","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y Z : C\n⊢ Eq (CategoryTheory.BraidedCategory.braiding X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Y).hom Z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y X Z).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.BraidedCategory.braiding X Z).hom) (CategoryTheory.MonoidalCategoryStruct.associator Y Z X).inv))))","decl":"@[simp, reassoc]\ntheorem braiding_tensor_right (X Y Z : C) :\n    (β_ X (Y ⊗ Z)).hom  =\n      (α_ X Y Z).inv ≫ (β_ X Y).hom ▷ Z ≫ (α_ Y X Z).hom ≫\n        Y ◁ (β_ X Z).hom ≫ (α_ Y Z X).inv := by\n  apply (cancel_epi (α_ X Y Z).hom).1\n  apply (cancel_mono (α_ Y Z X).hom).1\n  simp [hexagon_forward]\n\n"}
{"name":"CategoryTheory.BraidedCategory.braiding_inv_tensor_left_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝).inv h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Z✝ X Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Z✝).inv Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Z✝ Y).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.BraidedCategory.braiding Y Z✝).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv h)))))","decl":"@[simp, reassoc]\ntheorem braiding_inv_tensor_left (X Y Z : C) :\n    (β_ (X ⊗ Y) Z).inv  =\n      (α_ Z X Y).inv ≫ (β_ X Z).inv ▷ Y ≫ (α_ X Z Y).hom ≫\n        X ◁ (β_ Y Z).inv ≫ (α_ X Y Z).inv :=\n  eq_of_inv_eq_inv (by simp)\n\n"}
{"name":"CategoryTheory.BraidedCategory.braiding_inv_tensor_left","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y Z : C\n⊢ Eq (CategoryTheory.BraidedCategory.braiding (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Z X Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Z).inv Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Z Y).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.BraidedCategory.braiding Y Z).inv) (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv))))","decl":"@[simp, reassoc]\ntheorem braiding_inv_tensor_left (X Y Z : C) :\n    (β_ (X ⊗ Y) Z).inv  =\n      (α_ Z X Y).inv ≫ (β_ X Z).inv ▷ Y ≫ (α_ X Z Y).hom ≫\n        X ◁ (β_ Y Z).inv ≫ (α_ X Y Z).inv :=\n  eq_of_inv_eq_inv (by simp)\n\n"}
{"name":"CategoryTheory.BraidedCategory.braiding_inv_tensor_right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)).inv h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y Z✝ X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.BraidedCategory.braiding X Z✝).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y X Z✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Y).inv Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).hom h)))))","decl":"@[simp, reassoc]\ntheorem braiding_inv_tensor_right (X Y Z : C) :\n    (β_ X (Y ⊗ Z)).inv  =\n      (α_ Y Z X).hom ≫ Y ◁ (β_ X Z).inv ≫ (α_ Y X Z).inv ≫\n        (β_ X Y).inv ▷ Z ≫ (α_ X Y Z).hom :=\n  eq_of_inv_eq_inv (by simp)\n\n"}
{"name":"CategoryTheory.BraidedCategory.braiding_inv_tensor_right","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y Z : C\n⊢ Eq (CategoryTheory.BraidedCategory.braiding X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y Z X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.BraidedCategory.braiding X Z).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y X Z).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Y).inv Z) (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom))))","decl":"@[simp, reassoc]\ntheorem braiding_inv_tensor_right (X Y Z : C) :\n    (β_ X (Y ⊗ Z)).inv  =\n      (α_ Y Z X).hom ≫ Y ◁ (β_ X Z).inv ≫ (α_ Y X Z).inv ≫\n        (β_ X Y).inv ▷ Z ≫ (α_ X Y Z).hom :=\n  eq_of_inv_eq_inv (by simp)\n\n"}
{"name":"CategoryTheory.BraidedCategory.braiding_naturality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX X' Y Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Y' Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding Y Y').hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X X').hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g f) h))","decl":"@[reassoc (attr := simp)]\ntheorem braiding_naturality {X X' Y Y' : C} (f : X ⟶ Y) (g : X' ⟶ Y') :\n    (f ⊗ g) ≫ (braiding Y Y').hom = (braiding X X').hom ≫ (g ⊗ f) := by\n  rw [tensorHom_def' f g, tensorHom_def g f]\n  simp_rw [Category.assoc, braiding_naturality_left, braiding_naturality_right_assoc]\n\n"}
{"name":"CategoryTheory.BraidedCategory.braiding_naturality","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX X' Y Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) (CategoryTheory.BraidedCategory.braiding Y Y').hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X X').hom (CategoryTheory.MonoidalCategoryStruct.tensorHom g f))","decl":"@[reassoc (attr := simp)]\ntheorem braiding_naturality {X X' Y Y' : C} (f : X ⟶ Y) (g : X' ⟶ Y') :\n    (f ⊗ g) ≫ (braiding Y Y').hom = (braiding X X').hom ≫ (g ⊗ f) := by\n  rw [tensorHom_def' f g, tensorHom_def g f]\n  simp_rw [Category.assoc, braiding_naturality_left, braiding_naturality_right_assoc]\n\n"}
{"name":"CategoryTheory.BraidedCategory.braiding_inv_naturality_right","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y Z : C\nf : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (CategoryTheory.BraidedCategory.braiding Z X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding Y X).inv (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X))","decl":"@[reassoc (attr := simp)]\ntheorem braiding_inv_naturality_right (X : C) {Y Z : C} (f : Y ⟶ Z) :\n    X ◁ f ≫ (β_ Z X).inv = (β_ Y X).inv ≫ f ▷ X :=\n  CommSq.w <| .vert_inv <| .mk <| braiding_naturality_left f X\n\n"}
{"name":"CategoryTheory.BraidedCategory.braiding_inv_naturality_right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y Z✝ : C\nf : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Z✝ X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding Z✝ X).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding Y X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X) h))","decl":"@[reassoc (attr := simp)]\ntheorem braiding_inv_naturality_right (X : C) {Y Z : C} (f : Y ⟶ Z) :\n    X ◁ f ≫ (β_ Z X).inv = (β_ Y X).inv ≫ f ▷ X :=\n  CommSq.w <| .vert_inv <| .mk <| braiding_naturality_left f X\n\n"}
{"name":"CategoryTheory.BraidedCategory.braiding_inv_naturality_left","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z) (CategoryTheory.BraidedCategory.braiding Z Y).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding Z X).inv (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z f))","decl":"@[reassoc (attr := simp)]\ntheorem braiding_inv_naturality_left {X Y : C} (f : X ⟶ Y) (Z : C) :\n    f ▷ Z ≫ (β_ Z Y).inv = (β_ Z X).inv ≫ Z ◁ f :=\n  CommSq.w <| .vert_inv <| .mk <| braiding_naturality_right Z f\n\n"}
{"name":"CategoryTheory.BraidedCategory.braiding_inv_naturality_left_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : C\nf : Quiver.Hom X Y\nZ✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Z✝ Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding Z✝ Y).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding Z✝ X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z✝ f) h))","decl":"@[reassoc (attr := simp)]\ntheorem braiding_inv_naturality_left {X Y : C} (f : X ⟶ Y) (Z : C) :\n    f ▷ Z ≫ (β_ Z Y).inv = (β_ Z X).inv ≫ Z ◁ f :=\n  CommSq.w <| .vert_inv <| .mk <| braiding_naturality_right Z f\n\n"}
{"name":"CategoryTheory.BraidedCategory.braiding_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX X' Y Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Y' Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding Y' Y).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X' X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g f) h))","decl":"@[reassoc (attr := simp)]\ntheorem braiding_inv_naturality {X X' Y Y' : C} (f : X ⟶ Y) (g : X' ⟶ Y') :\n    (f ⊗ g) ≫ (β_ Y' Y).inv = (β_ X' X).inv ≫ (g ⊗ f) :=\n  CommSq.w <| .vert_inv <| .mk <| braiding_naturality g f\n\n"}
{"name":"CategoryTheory.BraidedCategory.braiding_inv_naturality","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX X' Y Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) (CategoryTheory.BraidedCategory.braiding Y' Y).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X' X).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom g f))","decl":"@[reassoc (attr := simp)]\ntheorem braiding_inv_naturality {X X' Y Y' : C} (f : X ⟶ Y) (g : X' ⟶ Y') :\n    (f ⊗ g) ≫ (β_ Y' Y).inv = (β_ X' X).inv ≫ (g ⊗ f) :=\n  CommSq.w <| .vert_inv <| .mk <| braiding_naturality g f\n\n"}
{"name":"CategoryTheory.BraidedCategory.yang_baxter_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Z✝ (CategoryTheory.MonoidalCategoryStruct.tensorObj Y X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Y).hom Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y X Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.BraidedCategory.braiding X Z✝).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y Z✝ X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding Y Z✝).hom X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Z✝ Y X).hom h))))))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.BraidedCategory.braiding Y Z✝).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Z✝ Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Z✝).hom Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Z✝ X Y).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z✝ (CategoryTheory.BraidedCategory.braiding X Y).hom) h)))))","decl":"@[reassoc]\ntheorem yang_baxter (X Y Z : C) :\n    (α_ X Y Z).inv ≫ (β_ X Y).hom ▷ Z ≫ (α_ Y X Z).hom ≫\n    Y ◁ (β_ X Z).hom ≫ (α_ Y Z X).inv ≫ (β_ Y Z).hom ▷ X ≫ (α_ Z Y X).hom =\n      X ◁ (β_ Y Z).hom ≫ (α_ X Z Y).inv ≫ (β_ X Z).hom ▷ Y ≫\n      (α_ Z X Y).hom ≫ Z ◁ (β_ X Y).hom := by\n  rw [← braiding_tensor_right_assoc X Y Z, ← cancel_mono (α_ Z Y X).inv]\n  repeat rw [assoc]\n  rw [Iso.hom_inv_id, comp_id, ← braiding_naturality_right, braiding_tensor_right]\n\n"}
{"name":"CategoryTheory.BraidedCategory.yang_baxter","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Y).hom Z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y X Z).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.BraidedCategory.braiding X Z).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y Z X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding Y Z).hom X) (CategoryTheory.MonoidalCategoryStruct.associator Z Y X).hom)))))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.BraidedCategory.braiding Y Z).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Z Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Z).hom Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Z X Y).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z (CategoryTheory.BraidedCategory.braiding X Y).hom)))))","decl":"@[reassoc]\ntheorem yang_baxter (X Y Z : C) :\n    (α_ X Y Z).inv ≫ (β_ X Y).hom ▷ Z ≫ (α_ Y X Z).hom ≫\n    Y ◁ (β_ X Z).hom ≫ (α_ Y Z X).inv ≫ (β_ Y Z).hom ▷ X ≫ (α_ Z Y X).hom =\n      X ◁ (β_ Y Z).hom ≫ (α_ X Z Y).inv ≫ (β_ X Z).hom ▷ Y ≫\n      (α_ Z X Y).hom ≫ Z ◁ (β_ X Y).hom := by\n  rw [← braiding_tensor_right_assoc X Y Z, ← cancel_mono (α_ Z Y X).inv]\n  repeat rw [assoc]\n  rw [Iso.hom_inv_id, comp_id, ← braiding_naturality_right, braiding_tensor_right]\n\n"}
{"name":"CategoryTheory.BraidedCategory.yang_baxter'","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y Z : C\n⊢ Eq (CategoryTheory.monoidalComp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Y).hom Z) (CategoryTheory.monoidalComp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.BraidedCategory.braiding X Z).hom) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding Y Z).hom X))) (CategoryTheory.monoidalComp (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z)) (CategoryTheory.monoidalComp (CategoryTheory.monoidalComp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.BraidedCategory.braiding Y Z).hom) (CategoryTheory.monoidalComp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Z).hom Y) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z (CategoryTheory.BraidedCategory.braiding X Y).hom))) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj Z Y) X))))","decl":"theorem yang_baxter' (X Y Z : C) :\n    (β_ X Y).hom ▷ Z ⊗≫ Y ◁ (β_ X Z).hom ⊗≫ (β_ Y Z).hom ▷ X =\n      𝟙 _ ⊗≫ (X ◁ (β_ Y Z).hom ⊗≫ (β_ X Z).hom ▷ Y ⊗≫ Z ◁ (β_ X Y).hom) ⊗≫ 𝟙 _ := by\n  rw [← cancel_epi (α_ X Y Z).inv, ← cancel_mono (α_ Z Y X).hom]\n  convert yang_baxter X Y Z using 1\n  all_goals monoidal\n\n"}
{"name":"CategoryTheory.BraidedCategory.yang_baxter_iso","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y Z : C\n⊢ Eq ((CategoryTheory.MonoidalCategoryStruct.associator X Y Z).symm.trans ((CategoryTheory.MonoidalCategory.whiskerRightIso (CategoryTheory.BraidedCategory.braiding X Y) Z).trans ((CategoryTheory.MonoidalCategoryStruct.associator Y X Z).trans ((CategoryTheory.MonoidalCategory.whiskerLeftIso Y (CategoryTheory.BraidedCategory.braiding X Z)).trans ((CategoryTheory.MonoidalCategoryStruct.associator Y Z X).symm.trans ((CategoryTheory.MonoidalCategory.whiskerRightIso (CategoryTheory.BraidedCategory.braiding Y Z) X).trans (CategoryTheory.MonoidalCategoryStruct.associator Z Y X))))))) ((CategoryTheory.MonoidalCategory.whiskerLeftIso X (CategoryTheory.BraidedCategory.braiding Y Z)).trans ((CategoryTheory.MonoidalCategoryStruct.associator X Z Y).symm.trans ((CategoryTheory.MonoidalCategory.whiskerRightIso (CategoryTheory.BraidedCategory.braiding X Z) Y).trans ((CategoryTheory.MonoidalCategoryStruct.associator Z X Y).trans (CategoryTheory.MonoidalCategory.whiskerLeftIso Z (CategoryTheory.BraidedCategory.braiding X Y))))))","decl":"theorem yang_baxter_iso (X Y Z : C) :\n    (α_ X Y Z).symm ≪≫ whiskerRightIso (β_ X Y) Z ≪≫ α_ Y X Z ≪≫\n    whiskerLeftIso Y (β_ X Z) ≪≫ (α_ Y Z X).symm ≪≫\n    whiskerRightIso (β_ Y Z) X ≪≫ (α_ Z Y X) =\n      whiskerLeftIso X (β_ Y Z) ≪≫ (α_ X Z Y).symm ≪≫\n      whiskerRightIso (β_ X Z) Y ≪≫ α_ Z X Y ≪≫\n      whiskerLeftIso Z (β_ X Y) := Iso.ext (yang_baxter X Y Z)\n\n"}
{"name":"CategoryTheory.BraidedCategory.hexagon_forward_iso","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y Z : C\n⊢ Eq ((CategoryTheory.MonoidalCategoryStruct.associator X Y Z).trans ((CategoryTheory.BraidedCategory.braiding X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).trans (CategoryTheory.MonoidalCategoryStruct.associator Y Z X))) ((CategoryTheory.MonoidalCategory.whiskerRightIso (CategoryTheory.BraidedCategory.braiding X Y) Z).trans ((CategoryTheory.MonoidalCategoryStruct.associator Y X Z).trans (CategoryTheory.MonoidalCategory.whiskerLeftIso Y (CategoryTheory.BraidedCategory.braiding X Z))))","decl":"theorem hexagon_forward_iso (X Y Z : C) :\n    α_ X Y Z ≪≫ β_ X (Y ⊗ Z) ≪≫ α_ Y Z X =\n      whiskerRightIso (β_ X Y) Z ≪≫ α_ Y X Z ≪≫ whiskerLeftIso Y (β_ X Z) :=\n  Iso.ext (hexagon_forward X Y Z)\n\n"}
{"name":"CategoryTheory.BraidedCategory.hexagon_reverse_iso","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y Z : C\n⊢ Eq ((CategoryTheory.MonoidalCategoryStruct.associator X Y Z).symm.trans ((CategoryTheory.BraidedCategory.braiding (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).trans (CategoryTheory.MonoidalCategoryStruct.associator Z X Y).symm)) ((CategoryTheory.MonoidalCategory.whiskerLeftIso X (CategoryTheory.BraidedCategory.braiding Y Z)).trans ((CategoryTheory.MonoidalCategoryStruct.associator X Z Y).symm.trans (CategoryTheory.MonoidalCategory.whiskerRightIso (CategoryTheory.BraidedCategory.braiding X Z) Y)))","decl":"theorem hexagon_reverse_iso (X Y Z : C) :\n    (α_ X Y Z).symm ≪≫ β_ (X ⊗ Y) Z ≪≫ (α_ Z X Y).symm =\n      whiskerLeftIso X (β_ Y Z) ≪≫ (α_ X Z Y).symm ≪≫ whiskerRightIso (β_ X Z) Y :=\n  Iso.ext (hexagon_reverse X Y Z)\n\n"}
{"name":"CategoryTheory.BraidedCategory.hexagon_forward_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y Z✝ X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.BraidedCategory.braiding X Z✝).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y X Z✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Y).inv Z✝) h)))","decl":"@[reassoc]\ntheorem hexagon_forward_inv (X Y Z : C) :\n    (α_ Y Z X).inv ≫ (β_ X (Y ⊗ Z)).inv ≫ (α_ X Y Z).inv =\n      Y ◁ (β_ X Z).inv ≫ (α_ Y X Z).inv ≫ (β_ X Y).inv ▷ Z := by\n  simp\n\n"}
{"name":"CategoryTheory.BraidedCategory.hexagon_forward_inv","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y Z X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).inv (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.BraidedCategory.braiding X Z).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y X Z).inv (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Y).inv Z)))","decl":"@[reassoc]\ntheorem hexagon_forward_inv (X Y Z : C) :\n    (α_ Y Z X).inv ≫ (β_ X (Y ⊗ Z)).inv ≫ (α_ X Y Z).inv =\n      Y ◁ (β_ X Z).inv ≫ (α_ Y X Z).inv ≫ (β_ X Y).inv ▷ Z := by\n  simp\n\n"}
{"name":"CategoryTheory.BraidedCategory.hexagon_reverse_inv","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Z X Y).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).inv (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Z).inv Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Z Y).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.BraidedCategory.braiding Y Z).inv)))","decl":"@[reassoc]\ntheorem hexagon_reverse_inv (X Y Z : C) :\n    (α_ Z X Y).hom ≫ (β_ (X ⊗ Y) Z).inv ≫ (α_ X Y Z).hom =\n      (β_ X Z).inv ▷ Y ≫ (α_ X Z Y).hom ≫ X ◁ (β_ Y Z).inv := by\n  simp\n\n"}
{"name":"CategoryTheory.BraidedCategory.hexagon_reverse_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Z✝ X Y).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).hom h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X Z✝).inv Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Z✝ Y).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.BraidedCategory.braiding Y Z✝).inv) h)))","decl":"@[reassoc]\ntheorem hexagon_reverse_inv (X Y Z : C) :\n    (α_ Z X Y).hom ≫ (β_ (X ⊗ Y) Z).inv ≫ (α_ X Y Z).hom =\n      (β_ X Z).inv ▷ Y ≫ (α_ X Z Y).hom ≫ X ◁ (β_ Y Z).inv := by\n  simp\n\n"}
{"name":"CategoryTheory.braiding_leftUnitor_aux₁","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator CategoryTheory.MonoidalCategoryStruct.tensorUnit CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft CategoryTheory.MonoidalCategoryStruct.tensorUnit (CategoryTheory.BraidedCategory.braiding X CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator CategoryTheory.MonoidalCategoryStruct.tensorUnit X CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom CategoryTheory.MonoidalCategoryStruct.tensorUnit)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom X) (CategoryTheory.BraidedCategory.braiding X CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv)","decl":"theorem braiding_leftUnitor_aux₁ (X : C) :\n    (α_ (𝟙_ C) (𝟙_ C) X).hom ≫\n        (𝟙_ C ◁ (β_ X (𝟙_ C)).inv) ≫ (α_ _ X _).inv ≫ ((λ_ X).hom ▷ _) =\n      ((λ_ _).hom ▷ X) ≫ (β_ X (𝟙_ C)).inv := by\n  monoidal\n\n"}
{"name":"CategoryTheory.braiding_leftUnitor_aux₂","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom CategoryTheory.MonoidalCategoryStruct.tensorUnit)) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"theorem braiding_leftUnitor_aux₂ (X : C) :\n    ((β_ X (𝟙_ C)).hom ▷ 𝟙_ C) ≫ ((λ_ X).hom ▷ 𝟙_ C) = (ρ_ X).hom ▷ 𝟙_ C :=\n  calc\n    ((β_ X (𝟙_ C)).hom ▷ 𝟙_ C) ≫ ((λ_ X).hom ▷ 𝟙_ C) =\n      ((β_ X (𝟙_ C)).hom ▷ 𝟙_ C) ≫ (α_ _ _ _).hom ≫ (α_ _ _ _).inv ≫ ((λ_ X).hom ▷ 𝟙_ C) := by\n      monoidal\n    _ = ((β_ X (𝟙_ C)).hom ▷ 𝟙_ C) ≫ (α_ _ _ _).hom ≫ (_ ◁ (β_ X _).hom) ≫\n          (_ ◁ (β_ X _).inv) ≫ (α_ _ _ _).inv ≫ ((λ_ X).hom ▷ 𝟙_ C) := by simp\n    _ = (α_ _ _ _).hom ≫ (β_ _ _).hom ≫ (α_ _ _ _).hom ≫ (_ ◁ (β_ X _).inv) ≫ (α_ _ _ _).inv ≫\n          ((λ_ X).hom ▷ 𝟙_ C) := by simp\n    _ = (α_ _ _ _).hom ≫ (β_ _ _).hom ≫ ((λ_ _).hom ▷ X) ≫ (β_ X _).inv := by\n      rw [braiding_leftUnitor_aux₁]\n    _ = (α_ _ _ _).hom ≫ (_ ◁ (λ_ _).hom) ≫ (β_ _ _).hom ≫ (β_ X _).inv := by\n      (slice_lhs 2 3 => rw [← braiding_naturality_right]); simp only [assoc]\n    _ = (α_ _ _ _).hom ≫ (_ ◁ (λ_ _).hom) := by rw [Iso.hom_inv_id, comp_id]\n    _ = (ρ_ X).hom ▷ 𝟙_ C := by rw [triangle]\n\n"}
{"name":"CategoryTheory.braiding_leftUnitor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Z : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom h)","decl":"@[reassoc]\ntheorem braiding_leftUnitor (X : C) : (β_ X (𝟙_ C)).hom ≫ (λ_ X).hom = (ρ_ X).hom := by\n  rw [← whiskerRight_iff, comp_whiskerRight, braiding_leftUnitor_aux₂]\n\n"}
{"name":"CategoryTheory.braiding_leftUnitor","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom","decl":"@[reassoc]\ntheorem braiding_leftUnitor (X : C) : (β_ X (𝟙_ C)).hom ≫ (λ_ X).hom = (ρ_ X).hom := by\n  rw [← whiskerRight_iff, comp_whiskerRight, braiding_leftUnitor_aux₂]\n\n"}
{"name":"CategoryTheory.braiding_rightUnitor_aux₁","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X CategoryTheory.MonoidalCategoryStruct.tensorUnit CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding CategoryTheory.MonoidalCategoryStruct.tensorUnit X).inv CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator CategoryTheory.MonoidalCategoryStruct.tensorUnit X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft CategoryTheory.MonoidalCategoryStruct.tensorUnit (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.rightUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom) (CategoryTheory.BraidedCategory.braiding CategoryTheory.MonoidalCategoryStruct.tensorUnit X).inv)","decl":"theorem braiding_rightUnitor_aux₁ (X : C) :\n    (α_ X (𝟙_ C) (𝟙_ C)).inv ≫\n        ((β_ (𝟙_ C) X).inv ▷ 𝟙_ C) ≫ (α_ _ X _).hom ≫ (_ ◁ (ρ_ X).hom) =\n      (X ◁ (ρ_ _).hom) ≫ (β_ (𝟙_ C) X).inv := by\n  monoidal\n\n"}
{"name":"CategoryTheory.braiding_rightUnitor_aux₂","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft CategoryTheory.MonoidalCategoryStruct.tensorUnit (CategoryTheory.BraidedCategory.braiding CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft CategoryTheory.MonoidalCategoryStruct.tensorUnit (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft CategoryTheory.MonoidalCategoryStruct.tensorUnit (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom)","decl":"theorem braiding_rightUnitor_aux₂ (X : C) :\n    (𝟙_ C ◁ (β_ (𝟙_ C) X).hom) ≫ (𝟙_ C ◁ (ρ_ X).hom) = 𝟙_ C ◁ (λ_ X).hom :=\n  calc\n    (𝟙_ C ◁ (β_ (𝟙_ C) X).hom) ≫ (𝟙_ C ◁ (ρ_ X).hom) =\n      (𝟙_ C ◁ (β_ (𝟙_ C) X).hom) ≫ (α_ _ _ _).inv ≫ (α_ _ _ _).hom ≫ (𝟙_ C ◁ (ρ_ X).hom) := by\n      monoidal\n    _ = (𝟙_ C ◁ (β_ (𝟙_ C) X).hom) ≫ (α_ _ _ _).inv ≫ ((β_ _ X).hom ▷ _) ≫\n          ((β_ _ X).inv ▷ _) ≫ (α_ _ _ _).hom ≫ (𝟙_ C ◁ (ρ_ X).hom) := by\n      simp\n    _ = (α_ _ _ _).inv ≫ (β_ _ _).hom ≫ (α_ _ _ _).inv ≫ ((β_ _ X).inv ▷ _) ≫ (α_ _ _ _).hom ≫\n          (𝟙_ C ◁ (ρ_ X).hom) := by\n      (slice_lhs 1 3 => rw [← hexagon_reverse]); simp only [assoc]\n    _ = (α_ _ _ _).inv ≫ (β_ _ _).hom ≫ (X ◁ (ρ_ _).hom) ≫ (β_ _ X).inv := by simp\n    _ = (α_ _ _ _).inv ≫ ((ρ_ _).hom ▷ _) ≫ (β_ _ X).hom ≫ (β_ _ _).inv := by\n      (slice_lhs 2 3 => rw [← braiding_naturality_left]); simp only [assoc]\n    _ = (α_ _ _ _).inv ≫ ((ρ_ _).hom ▷ _) := by rw [Iso.hom_inv_id, comp_id]\n    _ = 𝟙_ C ◁ (λ_ X).hom := by rw [triangle_assoc_comp_right]\n\n"}
{"name":"CategoryTheory.braiding_rightUnitor","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom","decl":"@[reassoc]\ntheorem braiding_rightUnitor (X : C) : (β_ (𝟙_ C) X).hom ≫ (ρ_ X).hom = (λ_ X).hom := by\n  rw [← whiskerLeft_iff, MonoidalCategory.whiskerLeft_comp, braiding_rightUnitor_aux₂]\n\n"}
{"name":"CategoryTheory.braiding_rightUnitor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Z : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom h)","decl":"@[reassoc]\ntheorem braiding_rightUnitor (X : C) : (β_ (𝟙_ C) X).hom ≫ (ρ_ X).hom = (λ_ X).hom := by\n  rw [← whiskerLeft_iff, MonoidalCategory.whiskerLeft_comp, braiding_rightUnitor_aux₂]\n\n"}
{"name":"CategoryTheory.braiding_tensorUnit_left_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv h))","decl":"@[reassoc, simp]\ntheorem braiding_tensorUnit_left (X : C) : (β_ (𝟙_ C) X).hom = (λ_ X).hom ≫ (ρ_ X).inv := by\n  simp [← braiding_rightUnitor]\n\n"}
{"name":"CategoryTheory.braiding_tensorUnit_left","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX : C\n⊢ Eq (CategoryTheory.BraidedCategory.braiding CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv)","decl":"@[reassoc, simp]\ntheorem braiding_tensorUnit_left (X : C) : (β_ (𝟙_ C) X).hom = (λ_ X).hom ≫ (ρ_ X).inv := by\n  simp [← braiding_rightUnitor]\n\n"}
{"name":"CategoryTheory.braiding_inv_tensorUnit_left","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX : C\n⊢ Eq (CategoryTheory.BraidedCategory.braiding CategoryTheory.MonoidalCategoryStruct.tensorUnit X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv)","decl":"@[reassoc, simp]\ntheorem braiding_inv_tensorUnit_left (X : C) : (β_ (𝟙_ C) X).inv = (ρ_ X).hom ≫ (λ_ X).inv := by\n  rw [Iso.inv_ext]\n  rw [braiding_tensorUnit_left]\n  monoidal\n\n"}
{"name":"CategoryTheory.braiding_inv_tensorUnit_left_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding CategoryTheory.MonoidalCategoryStruct.tensorUnit X).inv h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv h))","decl":"@[reassoc, simp]\ntheorem braiding_inv_tensorUnit_left (X : C) : (β_ (𝟙_ C) X).inv = (ρ_ X).hom ≫ (λ_ X).inv := by\n  rw [Iso.inv_ext]\n  rw [braiding_tensorUnit_left]\n  monoidal\n\n"}
{"name":"CategoryTheory.leftUnitor_inv_braiding_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv h)","decl":"@[reassoc]\ntheorem leftUnitor_inv_braiding (X : C) : (λ_ X).inv ≫ (β_ (𝟙_ C) X).hom = (ρ_ X).inv := by\n  simp\n\n"}
{"name":"CategoryTheory.leftUnitor_inv_braiding","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv (CategoryTheory.BraidedCategory.braiding CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv","decl":"@[reassoc]\ntheorem leftUnitor_inv_braiding (X : C) : (λ_ X).inv ≫ (β_ (𝟙_ C) X).hom = (ρ_ X).inv := by\n  simp\n\n"}
{"name":"CategoryTheory.rightUnitor_inv_braiding","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv (CategoryTheory.BraidedCategory.braiding X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv","decl":"@[reassoc]\ntheorem rightUnitor_inv_braiding (X : C) : (ρ_ X).inv ≫ (β_ X (𝟙_ C)).hom = (λ_ X).inv := by\n  apply (cancel_mono (λ_ X).hom).1\n  simp only [assoc, braiding_leftUnitor, Iso.inv_hom_id]\n\n"}
{"name":"CategoryTheory.rightUnitor_inv_braiding_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv h)","decl":"@[reassoc]\ntheorem rightUnitor_inv_braiding (X : C) : (ρ_ X).inv ≫ (β_ X (𝟙_ C)).hom = (λ_ X).inv := by\n  apply (cancel_mono (λ_ X).hom).1\n  simp only [assoc, braiding_leftUnitor, Iso.inv_hom_id]\n\n"}
{"name":"CategoryTheory.braiding_tensorUnit_right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv h))","decl":"@[reassoc, simp]\ntheorem braiding_tensorUnit_right (X : C) : (β_ X (𝟙_ C)).hom = (ρ_ X).hom ≫ (λ_ X).inv := by\n  simp [← rightUnitor_inv_braiding]\n\n"}
{"name":"CategoryTheory.braiding_tensorUnit_right","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX : C\n⊢ Eq (CategoryTheory.BraidedCategory.braiding X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv)","decl":"@[reassoc, simp]\ntheorem braiding_tensorUnit_right (X : C) : (β_ X (𝟙_ C)).hom = (ρ_ X).hom ≫ (λ_ X).inv := by\n  simp [← rightUnitor_inv_braiding]\n\n"}
{"name":"CategoryTheory.braiding_inv_tensorUnit_right","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX : C\n⊢ Eq (CategoryTheory.BraidedCategory.braiding X CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv)","decl":"@[reassoc, simp]\ntheorem braiding_inv_tensorUnit_right (X : C) : (β_ X (𝟙_ C)).inv = (λ_ X).hom ≫ (ρ_ X).inv := by\n  rw [Iso.inv_ext]\n  rw [braiding_tensorUnit_right]\n  monoidal\n\n"}
{"name":"CategoryTheory.braiding_inv_tensorUnit_right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv h))","decl":"@[reassoc, simp]\ntheorem braiding_inv_tensorUnit_right (X : C) : (β_ X (𝟙_ C)).inv = (λ_ X).hom ≫ (ρ_ X).inv := by\n  rw [Iso.inv_ext]\n  rw [braiding_tensorUnit_right]\n  monoidal\n\n"}
{"name":"CategoryTheory.SymmetricCategory.symmetry","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nself : CategoryTheory.SymmetricCategory C\nX Y : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X Y).hom (CategoryTheory.BraidedCategory.braiding Y X).hom) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))","decl":"/--\nA symmetric monoidal category is a braided monoidal category for which the braiding is symmetric. -/\n@[stacks 0FFW]\nclass SymmetricCategory (C : Type u) [Category.{v} C] [MonoidalCategory.{v} C] extends\n    BraidedCategory.{v} C where\n  -- braiding symmetric:\n  symmetry : ∀ X Y : C, (β_ X Y).hom ≫ (β_ Y X).hom = 𝟙 (X ⊗ Y) := by aesop_cat\n\n"}
{"name":"CategoryTheory.SymmetricCategory.symmetry_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nself : CategoryTheory.SymmetricCategory C\nX Y Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding X Y).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding Y X).hom h)) h","decl":"attribute [reassoc (attr := simp)] SymmetricCategory.symmetry\n\n"}
{"name":"CategoryTheory.SymmetricCategory.braiding_swap_eq_inv_braiding","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.SymmetricCategory C\nX Y : C\n⊢ Eq (CategoryTheory.BraidedCategory.braiding Y X).hom (CategoryTheory.BraidedCategory.braiding X Y).inv","decl":"lemma SymmetricCategory.braiding_swap_eq_inv_braiding {C : Type u₁}\n    [Category.{v₁} C] [MonoidalCategory C] [SymmetricCategory C] (X Y : C) :\n    (β_ Y X).hom = (β_ X Y).inv := Iso.inv_ext' (symmetry X Y)\n\n"}
{"name":"CategoryTheory.Functor.LaxBraided.braided","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\ninst✝³ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nF : CategoryTheory.Functor C D\nself : F.LaxBraided\nX Y : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X Y) (F.map (CategoryTheory.BraidedCategory.braiding X Y).hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding (F.obj X) (F.obj Y)).hom (CategoryTheory.Functor.LaxMonoidal.μ F Y X))","decl":"/-- A lax braided functor between braided monoidal categories is a lax monoidal functor\nwhich preserves the braiding.\n-/\nclass Functor.LaxBraided (F : C ⥤ D) extends F.LaxMonoidal where\n  braided : ∀ X Y : C, μ F X Y ≫ F.map (β_ X Y).hom =\n    (β_ (F.obj X) (F.obj Y)).hom ≫ μ F Y X := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.LaxBraided.braided_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\ninst✝³ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nF : CategoryTheory.Functor C D\nself : F.LaxBraided\nX Y : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj Y X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X Y) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.BraidedCategory.braiding X Y).hom) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding (F.obj X) (F.obj Y)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F Y X) h))","decl":"attribute [reassoc] braided\n\n"}
{"name":"CategoryTheory.LaxBraidedFunctor.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\ninst✝³ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\ntoFunctor✝ : CategoryTheory.Functor C D\nlaxBraided✝ : autoParam toFunctor✝.LaxBraided _auto✝\ntoFunctor : CategoryTheory.Functor C D\nlaxBraided : autoParam toFunctor.LaxBraided _auto✝\nx✝ : Eq { toFunctor := toFunctor✝, laxBraided := laxBraided✝ } { toFunctor := toFunctor, laxBraided := laxBraided }\n⊢ And (Eq toFunctor✝ toFunctor) (HEq laxBraided✝ laxBraided)","decl":"/-- Bundled version of lax braided functors. -/\nstructure LaxBraidedFunctor extends C ⥤ D where\n  laxBraided : toFunctor.LaxBraided := by infer_instance\n\n"}
{"name":"CategoryTheory.LaxBraidedFunctor.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁶ : CategoryTheory.MonoidalCategory C\ninst✝⁵ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\ninst✝² : CategoryTheory.BraidedCategory D\ninst✝¹ : SizeOf C\ninst✝ : SizeOf D\ntoFunctor : CategoryTheory.Functor C D\nlaxBraided : autoParam toFunctor.LaxBraided _auto✝\n⊢ Eq (SizeOf.sizeOf { toFunctor := toFunctor, laxBraided := laxBraided }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toFunctor)) (SizeOf.sizeOf laxBraided))","decl":"/-- Bundled version of lax braided functors. -/\nstructure LaxBraidedFunctor extends C ⥤ D where\n  laxBraided : toFunctor.LaxBraided := by infer_instance\n\n"}
{"name":"CategoryTheory.LaxBraidedFunctor.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\ninst✝³ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\ntoFunctor✝ : CategoryTheory.Functor C D\nlaxBraided✝ : autoParam toFunctor✝.LaxBraided _auto✝\ntoFunctor : CategoryTheory.Functor C D\nlaxBraided : autoParam toFunctor.LaxBraided _auto✝\n⊢ Eq (Eq { toFunctor := toFunctor✝, laxBraided := laxBraided✝ } { toFunctor := toFunctor, laxBraided := laxBraided }) (And (Eq toFunctor✝ toFunctor) (HEq laxBraided✝ laxBraided))","decl":"/-- Bundled version of lax braided functors. -/\nstructure LaxBraidedFunctor extends C ⥤ D where\n  laxBraided : toFunctor.LaxBraided := by infer_instance\n\n"}
{"name":"CategoryTheory.LaxBraidedFunctor.of_toFunctor","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\ninst✝⁴ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.MonoidalCategory D\ninst✝¹ : CategoryTheory.BraidedCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.LaxBraided\n⊢ Eq (CategoryTheory.LaxBraidedFunctor.of F).toFunctor F","decl":"/-- Constructor for `LaxBraidedFunctor C D`. -/\n@[simps toFunctor]\ndef of (F : C ⥤ D) [F.LaxBraided] : LaxBraidedFunctor C D where\n  toFunctor := F\n\n"}
{"name":"CategoryTheory.LaxBraidedFunctor.toLaxMonoidalFunctor_toFunctor","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\ninst✝³ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nF : CategoryTheory.LaxBraidedFunctor C D\n⊢ Eq F.toLaxMonoidalFunctor.toFunctor F.toFunctor","decl":"/-- The lax monoidal functor induced by a lax braided functor. -/\n@[simps toFunctor]\ndef toLaxMonoidalFunctor (F : LaxBraidedFunctor C D) : LaxMonoidalFunctor C D where\n  toFunctor := F.toFunctor\n\n"}
{"name":"CategoryTheory.LaxBraidedFunctor.id_hom","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\ninst✝³ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nF : CategoryTheory.LaxBraidedFunctor C D\n⊢ Eq (CategoryTheory.CategoryStruct.id F).hom (CategoryTheory.CategoryStruct.id F.toLaxMonoidalFunctor.toFunctor)","decl":"@[simp]\nlemma id_hom (F : LaxBraidedFunctor C D) : LaxMonoidalFunctor.Hom.hom (𝟙 F) = 𝟙 _ := rfl\n\n"}
{"name":"CategoryTheory.LaxBraidedFunctor.comp_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\ninst✝³ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nF G H : CategoryTheory.LaxBraidedFunctor C D\nα : Quiver.Hom F G\nβ : Quiver.Hom G H\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom H.toLaxMonoidalFunctor.toFunctor Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp α β).hom h) (CategoryTheory.CategoryStruct.comp α.hom (CategoryTheory.CategoryStruct.comp β.hom h))","decl":"@[reassoc, simp]\nlemma comp_hom {F G H : LaxBraidedFunctor C D} (α : F ⟶ G) (β : G ⟶ H) :\n    (α ≫ β).hom = α.hom ≫ β.hom := rfl\n\n"}
{"name":"CategoryTheory.LaxBraidedFunctor.comp_hom","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\ninst✝³ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nF G H : CategoryTheory.LaxBraidedFunctor C D\nα : Quiver.Hom F G\nβ : Quiver.Hom G H\n⊢ Eq (CategoryTheory.CategoryStruct.comp α β).hom (CategoryTheory.CategoryStruct.comp α.hom β.hom)","decl":"@[reassoc, simp]\nlemma comp_hom {F G H : LaxBraidedFunctor C D} (α : F ⟶ G) (β : G ⟶ H) :\n    (α ≫ β).hom = α.hom ≫ β.hom := rfl\n\n"}
{"name":"CategoryTheory.LaxBraidedFunctor.hom_ext_iff","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\ninst✝³ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nF G : CategoryTheory.LaxBraidedFunctor C D\nα β : Quiver.Hom F G\n⊢ Iff (Eq α β) (Eq α.hom β.hom)","decl":"@[ext]\nlemma hom_ext {F G : LaxBraidedFunctor C D} {α β : F ⟶ G} (h : α.hom = β.hom) : α = β :=\n  LaxMonoidalFunctor.hom_ext h\n\n"}
{"name":"CategoryTheory.LaxBraidedFunctor.hom_ext","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\ninst✝³ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nF G : CategoryTheory.LaxBraidedFunctor C D\nα β : Quiver.Hom F G\nh : Eq α.hom β.hom\n⊢ Eq α β","decl":"@[ext]\nlemma hom_ext {F G : LaxBraidedFunctor C D} {α β : F ⟶ G} (h : α.hom = β.hom) : α = β :=\n  LaxMonoidalFunctor.hom_ext h\n\n"}
{"name":"CategoryTheory.LaxBraidedFunctor.homMk_hom","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\ninst✝⁴ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.MonoidalCategory D\ninst✝¹ : CategoryTheory.BraidedCategory D\nF G : CategoryTheory.LaxBraidedFunctor C D\nf : Quiver.Hom F.toFunctor G.toFunctor\ninst✝ : CategoryTheory.NatTrans.IsMonoidal f\n⊢ Eq (CategoryTheory.LaxBraidedFunctor.homMk f).hom f","decl":"/-- Constructor for morphisms in the category `LaxBraiededFunctor C D`. -/\n@[simps]\ndef homMk {F G : LaxBraidedFunctor C D} (f : F.toFunctor ⟶ G.toFunctor) [NatTrans.IsMonoidal f] :\n    F ⟶ G := ⟨f, inferInstance⟩\n\n"}
{"name":"CategoryTheory.LaxBraidedFunctor.isoMk_inv","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\ninst✝⁴ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.MonoidalCategory D\ninst✝¹ : CategoryTheory.BraidedCategory D\nF G : CategoryTheory.LaxBraidedFunctor C D\ne : CategoryTheory.Iso F.toFunctor G.toFunctor\ninst✝ : CategoryTheory.NatTrans.IsMonoidal e.hom\n⊢ Eq (CategoryTheory.LaxBraidedFunctor.isoMk e).inv (CategoryTheory.LaxBraidedFunctor.homMk e.inv)","decl":"/-- Constructor for isomorphisms in the category `LaxBraidedFunctor C D`. -/\n@[simps]\ndef isoMk {F G : LaxBraidedFunctor C D} (e : F.toFunctor ≅ G.toFunctor)\n    [NatTrans.IsMonoidal e.hom] :\n    F ≅ G where\n  hom := homMk e.hom\n  inv := homMk e.inv\n\n"}
{"name":"CategoryTheory.LaxBraidedFunctor.isoMk_hom","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\ninst✝⁴ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.MonoidalCategory D\ninst✝¹ : CategoryTheory.BraidedCategory D\nF G : CategoryTheory.LaxBraidedFunctor C D\ne : CategoryTheory.Iso F.toFunctor G.toFunctor\ninst✝ : CategoryTheory.NatTrans.IsMonoidal e.hom\n⊢ Eq (CategoryTheory.LaxBraidedFunctor.isoMk e).hom (CategoryTheory.LaxBraidedFunctor.homMk e.hom)","decl":"/-- Constructor for isomorphisms in the category `LaxBraidedFunctor C D`. -/\n@[simps]\ndef isoMk {F G : LaxBraidedFunctor C D} (e : F.toFunctor ≅ G.toFunctor)\n    [NatTrans.IsMonoidal e.hom] :\n    F ≅ G where\n  hom := homMk e.hom\n  inv := homMk e.inv\n\n"}
{"name":"CategoryTheory.LaxBraidedFunctor.forget_obj","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\ninst✝³ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nF : CategoryTheory.LaxBraidedFunctor C D\n⊢ Eq (CategoryTheory.LaxBraidedFunctor.forget.obj F) F.toLaxMonoidalFunctor","decl":"/-- The forgetful functor from lax braided functors to lax monoidal functors. -/\n@[simps! obj map]\ndef forget : LaxBraidedFunctor C D ⥤ LaxMonoidalFunctor C D :=\n  inducedFunctor _\n\n"}
{"name":"CategoryTheory.LaxBraidedFunctor.forget_map","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\ninst✝³ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nX✝ Y✝ : CategoryTheory.InducedCategory (CategoryTheory.LaxMonoidalFunctor C D) CategoryTheory.LaxBraidedFunctor.toLaxMonoidalFunctor\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.LaxBraidedFunctor.forget.map f) f","decl":"/-- The forgetful functor from lax braided functors to lax monoidal functors. -/\n@[simps! obj map]\ndef forget : LaxBraidedFunctor C D ⥤ LaxMonoidalFunctor C D :=\n  inducedFunctor _\n\n"}
{"name":"CategoryTheory.LaxBraidedFunctor.isoOfComponents_hom_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\ninst✝³ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nF G : CategoryTheory.LaxBraidedFunctor C D\ne : (X : C) → CategoryTheory.Iso (F.obj X) (G.obj X)\nnaturality : autoParam (∀ {X Y : C} (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (e Y).hom) (CategoryTheory.CategoryStruct.comp (e X).hom (G.map f))) _auto✝\nunit : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.ε F.toFunctor) (e CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom) (CategoryTheory.Functor.LaxMonoidal.ε G.toFunctor)) _auto✝\ntensor : autoParam (∀ (X Y : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F.toFunctor X Y) (e (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (e X).hom (e Y).hom) (CategoryTheory.Functor.LaxMonoidal.μ G.toFunctor X Y))) _auto✝\nX : C\n⊢ Eq ((CategoryTheory.LaxBraidedFunctor.isoOfComponents e ⋯ unit tensor).hom.hom.app X) (e X).hom","decl":"@[simp]\nlemma isoOfComponents_hom_hom_app (X : C) :\n    (isoOfComponents e naturality unit tensor).hom.hom.app X = (e X).hom := rfl\n\n"}
{"name":"CategoryTheory.LaxBraidedFunctor.isoOfComponents_inv_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\ninst✝³ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nF G : CategoryTheory.LaxBraidedFunctor C D\ne : (X : C) → CategoryTheory.Iso (F.obj X) (G.obj X)\nnaturality : autoParam (∀ {X Y : C} (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (e Y).hom) (CategoryTheory.CategoryStruct.comp (e X).hom (G.map f))) _auto✝\nunit : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.ε F.toFunctor) (e CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom) (CategoryTheory.Functor.LaxMonoidal.ε G.toFunctor)) _auto✝\ntensor : autoParam (∀ (X Y : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F.toFunctor X Y) (e (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (e X).hom (e Y).hom) (CategoryTheory.Functor.LaxMonoidal.μ G.toFunctor X Y))) _auto✝\nX : C\n⊢ Eq ((CategoryTheory.LaxBraidedFunctor.isoOfComponents e ⋯ unit tensor).inv.hom.app X) (e X).inv","decl":"@[simp]\nlemma isoOfComponents_inv_hom_app (X : C) :\n    (isoOfComponents e naturality unit tensor).inv.hom.app X = (e X).inv := rfl\n\n"}
{"name":"CategoryTheory.Functor.Braided.braided","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\ninst✝³ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\ninst✝ : CategoryTheory.BraidedCategory D\nF : CategoryTheory.Functor C D\nself : F.Braided\nX Y : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X Y) (F.map (CategoryTheory.BraidedCategory.braiding X Y).hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding (F.obj X) (F.obj Y)).hom (CategoryTheory.Functor.LaxMonoidal.μ F Y X))","decl":"/-- A braided functor between braided monoidal categories is a monoidal functor\nwhich preserves the braiding.\n-/\nclass Functor.Braided (F : C ⥤ D) extends F.Monoidal, F.LaxBraided where\n\n"}
{"name":"CategoryTheory.Functor.map_braiding","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\ninst✝⁴ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.MonoidalCategory D\ninst✝¹ : CategoryTheory.BraidedCategory D\nF : CategoryTheory.Functor C D\nX Y : C\ninst✝ : F.Braided\n⊢ Eq (F.map (CategoryTheory.BraidedCategory.braiding X Y).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding (F.obj X) (F.obj Y)).hom (CategoryTheory.Functor.LaxMonoidal.μ F Y X)))","decl":"@[simp, reassoc]\nlemma Functor.map_braiding (F : C ⥤ D) (X Y : C) [F.Braided] :\n    F.map (β_ X Y).hom =\n    δ F X Y ≫ (β_ (F.obj X) (F.obj Y)).hom ≫ μ F Y X := by\n  rw [← Functor.Braided.braided, δ_μ_assoc]\n\n"}
{"name":"CategoryTheory.Functor.map_braiding_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\ninst✝⁴ : CategoryTheory.BraidedCategory C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.MonoidalCategory D\ninst✝¹ : CategoryTheory.BraidedCategory D\nF : CategoryTheory.Functor C D\nX Y : C\ninst✝ : F.Braided\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj Y X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.BraidedCategory.braiding X Y).hom) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding (F.obj X) (F.obj Y)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F Y X) h)))","decl":"@[simp, reassoc]\nlemma Functor.map_braiding (F : C ⥤ D) (X Y : C) [F.Braided] :\n    F.map (β_ X Y).hom =\n    δ F X Y ≫ (β_ (F.obj X) (F.obj Y)).hom ≫ μ F Y X := by\n  rw [← Functor.Braided.braided, δ_μ_assoc]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorμ_tensorδ","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX₁ X₂ Y₁ Y₂ : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ X₁ X₂ Y₁ Y₂) (CategoryTheory.MonoidalCategory.tensorδ X₁ X₂ Y₁ Y₂)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂) (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₁ Y₂)))","decl":"@[reassoc (attr := simp)]\nlemma tensorμ_tensorδ (X₁ X₂ Y₁ Y₂ : C) :\n    tensorμ X₁ X₂ Y₁ Y₂ ≫ tensorδ X₁ X₂ Y₁ Y₂ = 𝟙 _ := by\n  simp only [tensorμ, tensorδ, assoc, Iso.inv_hom_id_assoc,\n    ← MonoidalCategory.whiskerLeft_comp_assoc, Iso.hom_inv_id_assoc,\n    hom_inv_whiskerRight_assoc, Iso.hom_inv_id, Iso.inv_hom_id,\n    MonoidalCategory.whiskerLeft_id, id_comp]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorμ_tensorδ_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX₁ X₂ Y₁ Y₂ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂) (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₁ Y₂)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ X₁ X₂ Y₁ Y₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorδ X₁ X₂ Y₁ Y₂) h)) h","decl":"@[reassoc (attr := simp)]\nlemma tensorμ_tensorδ (X₁ X₂ Y₁ Y₂ : C) :\n    tensorμ X₁ X₂ Y₁ Y₂ ≫ tensorδ X₁ X₂ Y₁ Y₂ = 𝟙 _ := by\n  simp only [tensorμ, tensorδ, assoc, Iso.inv_hom_id_assoc,\n    ← MonoidalCategory.whiskerLeft_comp_assoc, Iso.hom_inv_id_assoc,\n    hom_inv_whiskerRight_assoc, Iso.hom_inv_id, Iso.inv_hom_id,\n    MonoidalCategory.whiskerLeft_id, id_comp]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorδ_tensorμ_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX₁ X₂ Y₁ Y₂ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ Y₁) (CategoryTheory.MonoidalCategoryStruct.tensorObj X₂ Y₂)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorδ X₁ X₂ Y₁ Y₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ X₁ X₂ Y₁ Y₂) h)) h","decl":"@[reassoc (attr := simp)]\nlemma tensorδ_tensorμ (X₁ X₂ Y₁ Y₂ : C) :\n    tensorδ X₁ X₂ Y₁ Y₂ ≫ tensorμ X₁ X₂ Y₁ Y₂ = 𝟙 _ := by\n  simp only [tensorμ, tensorδ, assoc, Iso.inv_hom_id_assoc,\n    ← MonoidalCategory.whiskerLeft_comp_assoc, Iso.hom_inv_id_assoc,\n    inv_hom_whiskerRight_assoc, Iso.inv_hom_id, Iso.hom_inv_id,\n    MonoidalCategory.whiskerLeft_id, id_comp]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorδ_tensorμ","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX₁ X₂ Y₁ Y₂ : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorδ X₁ X₂ Y₁ Y₂) (CategoryTheory.MonoidalCategory.tensorμ X₁ X₂ Y₁ Y₂)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ Y₁) (CategoryTheory.MonoidalCategoryStruct.tensorObj X₂ Y₂)))","decl":"@[reassoc (attr := simp)]\nlemma tensorδ_tensorμ (X₁ X₂ Y₁ Y₂ : C) :\n    tensorδ X₁ X₂ Y₁ Y₂ ≫ tensorμ X₁ X₂ Y₁ Y₂ = 𝟙 _ := by\n  simp only [tensorμ, tensorδ, assoc, Iso.inv_hom_id_assoc,\n    ← MonoidalCategory.whiskerLeft_comp_assoc, Iso.hom_inv_id_assoc,\n    inv_hom_whiskerRight_assoc, Iso.inv_hom_id, Iso.hom_inv_id,\n    MonoidalCategory.whiskerLeft_id, id_comp]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorμ_natural","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX₁ X₂ Y₁ Y₂ U₁ U₂ V₁ V₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₂\ng₁ : Quiver.Hom U₁ V₁\ng₂ : Quiver.Hom U₂ V₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.tensorHom f₁ f₂) (CategoryTheory.MonoidalCategoryStruct.tensorHom g₁ g₂)) (CategoryTheory.MonoidalCategory.tensorμ Y₁ Y₂ V₁ V₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ X₁ X₂ U₁ U₂) (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.tensorHom f₁ g₁) (CategoryTheory.MonoidalCategoryStruct.tensorHom f₂ g₂)))","decl":"@[reassoc]\ntheorem tensorμ_natural {X₁ X₂ Y₁ Y₂ U₁ U₂ V₁ V₂ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (g₁ : U₁ ⟶ V₁)\n    (g₂ : U₂ ⟶ V₂) :\n    ((f₁ ⊗ f₂) ⊗ g₁ ⊗ g₂) ≫ tensorμ Y₁ Y₂ V₁ V₂ =\n      tensorμ X₁ X₂ U₁ U₂ ≫ ((f₁ ⊗ g₁) ⊗ f₂ ⊗ g₂) := by\n  dsimp only [tensorμ]\n  simp_rw [← id_tensorHom, ← tensorHom_id]\n  slice_lhs 1 2 => rw [associator_naturality]\n  slice_lhs 2 3 =>\n    rw [← tensor_comp, comp_id f₁, ← id_comp f₁, associator_inv_naturality, tensor_comp]\n  slice_lhs 3 4 =>\n    rw [← tensor_comp, ← tensor_comp, comp_id f₁, ← id_comp f₁, comp_id g₂, ← id_comp g₂,\n      braiding_naturality, tensor_comp, tensor_comp]\n  slice_lhs 4 5 => rw [← tensor_comp, comp_id f₁, ← id_comp f₁, associator_naturality, tensor_comp]\n  slice_lhs 5 6 => rw [associator_inv_naturality]\n  simp only [assoc]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorμ_natural_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX₁ X₂ Y₁ Y₂ U₁ U₂ V₁ V₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₂\ng₁ : Quiver.Hom U₁ V₁\ng₂ : Quiver.Hom U₂ V₂\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₁ V₁) (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₂ V₂)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.tensorHom f₁ f₂) (CategoryTheory.MonoidalCategoryStruct.tensorHom g₁ g₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ Y₁ Y₂ V₁ V₂) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ X₁ X₂ U₁ U₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.tensorHom f₁ g₁) (CategoryTheory.MonoidalCategoryStruct.tensorHom f₂ g₂)) h))","decl":"@[reassoc]\ntheorem tensorμ_natural {X₁ X₂ Y₁ Y₂ U₁ U₂ V₁ V₂ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (g₁ : U₁ ⟶ V₁)\n    (g₂ : U₂ ⟶ V₂) :\n    ((f₁ ⊗ f₂) ⊗ g₁ ⊗ g₂) ≫ tensorμ Y₁ Y₂ V₁ V₂ =\n      tensorμ X₁ X₂ U₁ U₂ ≫ ((f₁ ⊗ g₁) ⊗ f₂ ⊗ g₂) := by\n  dsimp only [tensorμ]\n  simp_rw [← id_tensorHom, ← tensorHom_id]\n  slice_lhs 1 2 => rw [associator_naturality]\n  slice_lhs 2 3 =>\n    rw [← tensor_comp, comp_id f₁, ← id_comp f₁, associator_inv_naturality, tensor_comp]\n  slice_lhs 3 4 =>\n    rw [← tensor_comp, ← tensor_comp, comp_id f₁, ← id_comp f₁, comp_id g₂, ← id_comp g₂,\n      braiding_naturality, tensor_comp, tensor_comp]\n  slice_lhs 4 5 => rw [← tensor_comp, comp_id f₁, ← id_comp f₁, associator_naturality, tensor_comp]\n  slice_lhs 5 6 => rw [associator_inv_naturality]\n  simp only [assoc]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorμ_natural_left_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX₁ X₂ Y₁ Y₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₂\nZ₁ Z₂ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₁ Z₁) (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₂ Z₂)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.tensorHom f₁ f₂) (CategoryTheory.MonoidalCategoryStruct.tensorObj Z₁ Z₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ Y₁ Y₂ Z₁ Z₂) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ X₁ X₂ Z₁ Z₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f₁ Z₁) (CategoryTheory.MonoidalCategoryStruct.whiskerRight f₂ Z₂)) h))","decl":"@[reassoc]\ntheorem tensorμ_natural_left {X₁ X₂ Y₁ Y₂ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (Z₁ Z₂ : C) :\n    (f₁ ⊗ f₂) ▷ (Z₁ ⊗ Z₂) ≫ tensorμ Y₁ Y₂ Z₁ Z₂ =\n      tensorμ X₁ X₂ Z₁ Z₂ ≫ (f₁ ▷ Z₁ ⊗ f₂ ▷ Z₂) := by\n  convert tensorμ_natural f₁ f₂ (𝟙 Z₁) (𝟙 Z₂) using 1 <;> simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorμ_natural_left","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX₁ X₂ Y₁ Y₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₂\nZ₁ Z₂ : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.tensorHom f₁ f₂) (CategoryTheory.MonoidalCategoryStruct.tensorObj Z₁ Z₂)) (CategoryTheory.MonoidalCategory.tensorμ Y₁ Y₂ Z₁ Z₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ X₁ X₂ Z₁ Z₂) (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f₁ Z₁) (CategoryTheory.MonoidalCategoryStruct.whiskerRight f₂ Z₂)))","decl":"@[reassoc]\ntheorem tensorμ_natural_left {X₁ X₂ Y₁ Y₂ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (Z₁ Z₂ : C) :\n    (f₁ ⊗ f₂) ▷ (Z₁ ⊗ Z₂) ≫ tensorμ Y₁ Y₂ Z₁ Z₂ =\n      tensorμ X₁ X₂ Z₁ Z₂ ≫ (f₁ ▷ Z₁ ⊗ f₂ ▷ Z₂) := by\n  convert tensorμ_natural f₁ f₂ (𝟙 Z₁) (𝟙 Z₂) using 1 <;> simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorμ_natural_right","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nZ₁ Z₂ X₁ X₂ Y₁ Y₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj Z₁ Z₂) (CategoryTheory.MonoidalCategoryStruct.tensorHom f₁ f₂)) (CategoryTheory.MonoidalCategory.tensorμ Z₁ Z₂ Y₁ Y₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ Z₁ Z₂ X₁ X₂) (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z₁ f₁) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z₂ f₂)))","decl":"@[reassoc]\ntheorem tensorμ_natural_right (Z₁ Z₂ : C) {X₁ X₂ Y₁ Y₂ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) :\n    (Z₁ ⊗ Z₂) ◁ (f₁ ⊗ f₂) ≫ tensorμ Z₁ Z₂ Y₁ Y₂ =\n      tensorμ Z₁ Z₂ X₁ X₂ ≫ (Z₁ ◁ f₁ ⊗ Z₂ ◁ f₂) := by\n  convert tensorμ_natural (𝟙 Z₁) (𝟙 Z₂) f₁ f₂ using 1 <;> simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorμ_natural_right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nZ₁ Z₂ X₁ X₂ Y₁ Y₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₂\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj Z₁ Y₁) (CategoryTheory.MonoidalCategoryStruct.tensorObj Z₂ Y₂)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj Z₁ Z₂) (CategoryTheory.MonoidalCategoryStruct.tensorHom f₁ f₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ Z₁ Z₂ Y₁ Y₂) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ Z₁ Z₂ X₁ X₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z₁ f₁) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z₂ f₂)) h))","decl":"@[reassoc]\ntheorem tensorμ_natural_right (Z₁ Z₂ : C) {X₁ X₂ Y₁ Y₂ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) :\n    (Z₁ ⊗ Z₂) ◁ (f₁ ⊗ f₂) ≫ tensorμ Z₁ Z₂ Y₁ Y₂ =\n      tensorμ Z₁ Z₂ X₁ X₂ ≫ (Z₁ ◁ f₁ ⊗ Z₂ ◁ f₂) := by\n  convert tensorμ_natural (𝟙 Z₁) (𝟙 Z₂) f₁ f₂ using 1 <;> simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_left_unitality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX₁ X₂ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂)).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ CategoryTheory.MonoidalCategoryStruct.tensorUnit CategoryTheory.MonoidalCategoryStruct.tensorUnit X₁ X₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.leftUnitor X₁).hom (CategoryTheory.MonoidalCategoryStruct.leftUnitor X₂).hom) h)))","decl":"@[reassoc]\ntheorem tensor_left_unitality (X₁ X₂ : C) :\n    (λ_ (X₁ ⊗ X₂)).hom =\n      ((λ_ (𝟙_ C)).inv ▷ (X₁ ⊗ X₂)) ≫\n        tensorμ (𝟙_ C) (𝟙_ C) X₁ X₂ ≫ ((λ_ X₁).hom ⊗ (λ_ X₂).hom) := by\n  dsimp only [tensorμ]\n  have :\n    ((λ_ (𝟙_ C)).inv ▷ (X₁ ⊗ X₂)) ≫\n        (α_ (𝟙_ C) (𝟙_ C) (X₁ ⊗ X₂)).hom ≫ (𝟙_ C ◁ (α_ (𝟙_ C) X₁ X₂).inv) =\n      𝟙_ C ◁ (λ_ X₁).inv ▷ X₂ := by\n    monoidal\n  slice_rhs 1 3 => rw [this]\n  clear this\n  slice_rhs 1 2 => rw [← MonoidalCategory.whiskerLeft_comp, ← comp_whiskerRight,\n    leftUnitor_inv_braiding]\n  simp [tensorHom_id, id_tensorHom, tensorHom_def]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_left_unitality","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX₁ X₂ : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ CategoryTheory.MonoidalCategoryStruct.tensorUnit CategoryTheory.MonoidalCategoryStruct.tensorUnit X₁ X₂) (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.leftUnitor X₁).hom (CategoryTheory.MonoidalCategoryStruct.leftUnitor X₂).hom)))","decl":"@[reassoc]\ntheorem tensor_left_unitality (X₁ X₂ : C) :\n    (λ_ (X₁ ⊗ X₂)).hom =\n      ((λ_ (𝟙_ C)).inv ▷ (X₁ ⊗ X₂)) ≫\n        tensorμ (𝟙_ C) (𝟙_ C) X₁ X₂ ≫ ((λ_ X₁).hom ⊗ (λ_ X₂).hom) := by\n  dsimp only [tensorμ]\n  have :\n    ((λ_ (𝟙_ C)).inv ▷ (X₁ ⊗ X₂)) ≫\n        (α_ (𝟙_ C) (𝟙_ C) (X₁ ⊗ X₂)).hom ≫ (𝟙_ C ◁ (α_ (𝟙_ C) X₁ X₂).inv) =\n      𝟙_ C ◁ (λ_ X₁).inv ▷ X₂ := by\n    monoidal\n  slice_rhs 1 3 => rw [this]\n  clear this\n  slice_rhs 1 2 => rw [← MonoidalCategory.whiskerLeft_comp, ← comp_whiskerRight,\n    leftUnitor_inv_braiding]\n  simp [tensorHom_id, id_tensorHom, tensorHom_def]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_right_unitality","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX₁ X₂ : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂) (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ X₁ X₂ CategoryTheory.MonoidalCategoryStruct.tensorUnit CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.rightUnitor X₁).hom (CategoryTheory.MonoidalCategoryStruct.rightUnitor X₂).hom)))","decl":"@[reassoc]\ntheorem tensor_right_unitality (X₁ X₂ : C) :\n    (ρ_ (X₁ ⊗ X₂)).hom =\n      ((X₁ ⊗ X₂) ◁ (λ_ (𝟙_ C)).inv) ≫\n        tensorμ X₁ X₂ (𝟙_ C) (𝟙_ C) ≫ ((ρ_ X₁).hom ⊗ (ρ_ X₂).hom) := by\n  dsimp only [tensorμ]\n  have :\n    ((X₁ ⊗ X₂) ◁ (λ_ (𝟙_ C)).inv) ≫\n        (α_ X₁ X₂ (𝟙_ C ⊗ 𝟙_ C)).hom ≫ (X₁ ◁ (α_ X₂ (𝟙_ C) (𝟙_ C)).inv) =\n      (α_ X₁ X₂ (𝟙_ C)).hom ≫ (X₁ ◁ (ρ_ X₂).inv ▷ 𝟙_ C) := by\n    monoidal\n  slice_rhs 1 3 => rw [this]\n  clear this\n  slice_rhs 2 3 => rw [← MonoidalCategory.whiskerLeft_comp, ← comp_whiskerRight,\n    rightUnitor_inv_braiding]\n  simp [tensorHom_id, id_tensorHom, tensorHom_def]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_right_unitality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX₁ X₂ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂)).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂) (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ X₁ X₂ CategoryTheory.MonoidalCategoryStruct.tensorUnit CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.rightUnitor X₁).hom (CategoryTheory.MonoidalCategoryStruct.rightUnitor X₂).hom) h)))","decl":"@[reassoc]\ntheorem tensor_right_unitality (X₁ X₂ : C) :\n    (ρ_ (X₁ ⊗ X₂)).hom =\n      ((X₁ ⊗ X₂) ◁ (λ_ (𝟙_ C)).inv) ≫\n        tensorμ X₁ X₂ (𝟙_ C) (𝟙_ C) ≫ ((ρ_ X₁).hom ⊗ (ρ_ X₂).hom) := by\n  dsimp only [tensorμ]\n  have :\n    ((X₁ ⊗ X₂) ◁ (λ_ (𝟙_ C)).inv) ≫\n        (α_ X₁ X₂ (𝟙_ C ⊗ 𝟙_ C)).hom ≫ (X₁ ◁ (α_ X₂ (𝟙_ C) (𝟙_ C)).inv) =\n      (α_ X₁ X₂ (𝟙_ C)).hom ≫ (X₁ ◁ (ρ_ X₂).inv ▷ 𝟙_ C) := by\n    monoidal\n  slice_rhs 1 3 => rw [this]\n  clear this\n  slice_rhs 2 3 => rw [← MonoidalCategory.whiskerLeft_comp, ← comp_whiskerRight,\n    rightUnitor_inv_braiding]\n  simp [tensorHom_id, id_tensorHom, tensorHom_def]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_associativity_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX₁ X₂ Y₁ Y₂ Z₁ Z₂ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₁ Z₁)) (CategoryTheory.MonoidalCategoryStruct.tensorObj X₂ (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₂ Z₂))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategory.tensorμ X₁ X₂ Y₁ Y₂) (CategoryTheory.MonoidalCategoryStruct.tensorObj Z₁ Z₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ Y₁) (CategoryTheory.MonoidalCategoryStruct.tensorObj X₂ Y₂) Z₁ Z₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.associator X₁ Y₁ Z₁).hom (CategoryTheory.MonoidalCategoryStruct.associator X₂ Y₂ Z₂).hom) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂) (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₁ Y₂) (CategoryTheory.MonoidalCategoryStruct.tensorObj Z₁ Z₂)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂) (CategoryTheory.MonoidalCategory.tensorμ Y₁ Y₂ Z₁ Z₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ X₁ X₂ (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₁ Z₁) (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₂ Z₂)) h)))","decl":"@[reassoc]\ntheorem tensor_associativity (X₁ X₂ Y₁ Y₂ Z₁ Z₂ : C) :\n    (tensorμ X₁ X₂ Y₁ Y₂ ▷ (Z₁ ⊗ Z₂)) ≫\n        tensorμ (X₁ ⊗ Y₁) (X₂ ⊗ Y₂) Z₁ Z₂ ≫ ((α_ X₁ Y₁ Z₁).hom ⊗ (α_ X₂ Y₂ Z₂).hom) =\n      (α_ (X₁ ⊗ X₂) (Y₁ ⊗ Y₂) (Z₁ ⊗ Z₂)).hom ≫\n        ((X₁ ⊗ X₂) ◁ tensorμ Y₁ Y₂ Z₁ Z₂) ≫ tensorμ X₁ X₂ (Y₁ ⊗ Z₁) (Y₂ ⊗ Z₂) := by\n  dsimp only [tensor_obj, prodMonoidal_tensorObj, tensorμ]\n  simp only [braiding_tensor_left, braiding_tensor_right]\n  calc\n    _ = 𝟙 _ ⊗≫\n      X₁ ◁ ((β_ X₂ Y₁).hom ▷ (Y₂ ⊗ Z₁) ≫ (Y₁ ⊗ X₂) ◁ (β_ Y₂ Z₁).hom) ▷ Z₂ ⊗≫\n        X₁ ◁ Y₁ ◁ (β_ X₂ Z₁).hom ▷ Y₂ ▷ Z₂ ⊗≫ 𝟙 _ := by monoidal\n    _ = _ := by rw [← whisker_exchange]; monoidal\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_associativity","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX₁ X₂ Y₁ Y₂ Z₁ Z₂ : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategory.tensorμ X₁ X₂ Y₁ Y₂) (CategoryTheory.MonoidalCategoryStruct.tensorObj Z₁ Z₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ Y₁) (CategoryTheory.MonoidalCategoryStruct.tensorObj X₂ Y₂) Z₁ Z₂) (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.associator X₁ Y₁ Z₁).hom (CategoryTheory.MonoidalCategoryStruct.associator X₂ Y₂ Z₂).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂) (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₁ Y₂) (CategoryTheory.MonoidalCategoryStruct.tensorObj Z₁ Z₂)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂) (CategoryTheory.MonoidalCategory.tensorμ Y₁ Y₂ Z₁ Z₂)) (CategoryTheory.MonoidalCategory.tensorμ X₁ X₂ (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₁ Z₁) (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₂ Z₂))))","decl":"@[reassoc]\ntheorem tensor_associativity (X₁ X₂ Y₁ Y₂ Z₁ Z₂ : C) :\n    (tensorμ X₁ X₂ Y₁ Y₂ ▷ (Z₁ ⊗ Z₂)) ≫\n        tensorμ (X₁ ⊗ Y₁) (X₂ ⊗ Y₂) Z₁ Z₂ ≫ ((α_ X₁ Y₁ Z₁).hom ⊗ (α_ X₂ Y₂ Z₂).hom) =\n      (α_ (X₁ ⊗ X₂) (Y₁ ⊗ Y₂) (Z₁ ⊗ Z₂)).hom ≫\n        ((X₁ ⊗ X₂) ◁ tensorμ Y₁ Y₂ Z₁ Z₂) ≫ tensorμ X₁ X₂ (Y₁ ⊗ Z₁) (Y₂ ⊗ Z₂) := by\n  dsimp only [tensor_obj, prodMonoidal_tensorObj, tensorμ]\n  simp only [braiding_tensor_left, braiding_tensor_right]\n  calc\n    _ = 𝟙 _ ⊗≫\n      X₁ ◁ ((β_ X₂ Y₁).hom ▷ (Y₂ ⊗ Z₁) ≫ (Y₁ ⊗ X₂) ◁ (β_ Y₂ Z₁).hom) ▷ Z₂ ⊗≫\n        X₁ ◁ Y₁ ◁ (β_ X₂ Z₁).hom ▷ Y₂ ▷ Z₂ ⊗≫ 𝟙 _ := by monoidal\n    _ = _ := by rw [← whisker_exchange]; monoidal\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_ε","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.ε (CategoryTheory.MonoidalCategory.tensor C)) (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv","decl":"@[simp] lemma tensor_ε : ε (tensor C) = (λ_ (𝟙_ C)).inv := rfl\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_η","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.η (CategoryTheory.MonoidalCategory.tensor C)) (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom","decl":"@[simp] lemma tensor_η : η (tensor C) = (λ_ (𝟙_ C)).hom := rfl\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_μ","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : Prod C C\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.μ (CategoryTheory.MonoidalCategory.tensor C) X Y) (CategoryTheory.MonoidalCategory.tensorμ X.1 X.2 Y.1 Y.2)","decl":"@[simp] lemma tensor_μ (X Y : C × C) : μ (tensor C) X Y = tensorμ X.1 X.2 Y.1 Y.2 := rfl\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_δ","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : Prod C C\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.δ (CategoryTheory.MonoidalCategory.tensor C) X Y) (CategoryTheory.MonoidalCategory.tensorδ X.1 X.2 Y.1 Y.2)","decl":"@[simp] lemma tensor_δ (X Y : C × C) : δ (tensor C) X Y = tensorδ X.1 X.2 Y.1 Y.2 := rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.leftUnitor_monoidal","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX₁ X₂ : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.leftUnitor X₁).hom (CategoryTheory.MonoidalCategoryStruct.leftUnitor X₂).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ CategoryTheory.MonoidalCategoryStruct.tensorUnit X₁ CategoryTheory.MonoidalCategoryStruct.tensorUnit X₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂)) (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂)).hom))","decl":"@[reassoc]\ntheorem leftUnitor_monoidal (X₁ X₂ : C) :\n    (λ_ X₁).hom ⊗ (λ_ X₂).hom =\n      tensorμ (𝟙_ C) X₁ (𝟙_ C) X₂ ≫ ((λ_ (𝟙_ C)).hom ▷ (X₁ ⊗ X₂)) ≫ (λ_ (X₁ ⊗ X₂)).hom := by\n  dsimp only [tensorμ]\n  have :\n    (λ_ X₁).hom ⊗ (λ_ X₂).hom =\n      (α_ (𝟙_ C) X₁ (𝟙_ C ⊗ X₂)).hom ≫\n        (𝟙_ C ◁ (α_ X₁ (𝟙_ C) X₂).inv) ≫ (λ_ ((X₁ ⊗ 𝟙_ C) ⊗ X₂)).hom ≫ ((ρ_ X₁).hom ▷ X₂) := by\n    monoidal\n  rw [this]; clear this\n  rw [← braiding_leftUnitor]\n  monoidal\n\n"}
{"name":"CategoryTheory.MonoidalCategory.leftUnitor_monoidal_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX₁ X₂ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.leftUnitor X₁).hom (CategoryTheory.MonoidalCategoryStruct.leftUnitor X₂).hom) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ CategoryTheory.MonoidalCategoryStruct.tensorUnit X₁ CategoryTheory.MonoidalCategoryStruct.tensorUnit X₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂)).hom h)))","decl":"@[reassoc]\ntheorem leftUnitor_monoidal (X₁ X₂ : C) :\n    (λ_ X₁).hom ⊗ (λ_ X₂).hom =\n      tensorμ (𝟙_ C) X₁ (𝟙_ C) X₂ ≫ ((λ_ (𝟙_ C)).hom ▷ (X₁ ⊗ X₂)) ≫ (λ_ (X₁ ⊗ X₂)).hom := by\n  dsimp only [tensorμ]\n  have :\n    (λ_ X₁).hom ⊗ (λ_ X₂).hom =\n      (α_ (𝟙_ C) X₁ (𝟙_ C ⊗ X₂)).hom ≫\n        (𝟙_ C ◁ (α_ X₁ (𝟙_ C) X₂).inv) ≫ (λ_ ((X₁ ⊗ 𝟙_ C) ⊗ X₂)).hom ≫ ((ρ_ X₁).hom ▷ X₂) := by\n    monoidal\n  rw [this]; clear this\n  rw [← braiding_leftUnitor]\n  monoidal\n\n"}
{"name":"CategoryTheory.MonoidalCategory.rightUnitor_monoidal_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX₁ X₂ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.rightUnitor X₁).hom (CategoryTheory.MonoidalCategoryStruct.rightUnitor X₂).hom) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ X₁ CategoryTheory.MonoidalCategoryStruct.tensorUnit X₂ CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂) (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂)).hom h)))","decl":"@[reassoc]\ntheorem rightUnitor_monoidal (X₁ X₂ : C) :\n    (ρ_ X₁).hom ⊗ (ρ_ X₂).hom =\n      tensorμ X₁ (𝟙_ C) X₂ (𝟙_ C) ≫ ((X₁ ⊗ X₂) ◁ (λ_ (𝟙_ C)).hom) ≫ (ρ_ (X₁ ⊗ X₂)).hom := by\n  dsimp only [tensorμ]\n  have :\n    (ρ_ X₁).hom ⊗ (ρ_ X₂).hom =\n      (α_ X₁ (𝟙_ C) (X₂ ⊗ 𝟙_ C)).hom ≫\n        (X₁ ◁ (α_ (𝟙_ C) X₂ (𝟙_ C)).inv) ≫ (X₁ ◁ (ρ_ (𝟙_ C ⊗ X₂)).hom) ≫ (X₁ ◁ (λ_ X₂).hom) := by\n    monoidal\n  rw [this]; clear this\n  rw [← braiding_rightUnitor]\n  monoidal\n\n"}
{"name":"CategoryTheory.MonoidalCategory.rightUnitor_monoidal","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX₁ X₂ : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.rightUnitor X₁).hom (CategoryTheory.MonoidalCategoryStruct.rightUnitor X₂).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ X₁ CategoryTheory.MonoidalCategoryStruct.tensorUnit X₂ CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂) (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom) (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂)).hom))","decl":"@[reassoc]\ntheorem rightUnitor_monoidal (X₁ X₂ : C) :\n    (ρ_ X₁).hom ⊗ (ρ_ X₂).hom =\n      tensorμ X₁ (𝟙_ C) X₂ (𝟙_ C) ≫ ((X₁ ⊗ X₂) ◁ (λ_ (𝟙_ C)).hom) ≫ (ρ_ (X₁ ⊗ X₂)).hom := by\n  dsimp only [tensorμ]\n  have :\n    (ρ_ X₁).hom ⊗ (ρ_ X₂).hom =\n      (α_ X₁ (𝟙_ C) (X₂ ⊗ 𝟙_ C)).hom ≫\n        (X₁ ◁ (α_ (𝟙_ C) X₂ (𝟙_ C)).inv) ≫ (X₁ ◁ (ρ_ (𝟙_ C ⊗ X₂)).hom) ≫ (X₁ ◁ (λ_ X₂).hom) := by\n    monoidal\n  rw [this]; clear this\n  rw [← braiding_rightUnitor]\n  monoidal\n\n"}
{"name":"CategoryTheory.MonoidalCategory.associator_monoidal_assoc","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX₁ X₂ X₃ Y₁ Y₂ Y₃ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ Y₁) (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X₂ Y₂) (CategoryTheory.MonoidalCategoryStruct.tensorObj X₃ Y₃))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂) X₃ (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₁ Y₂) Y₃) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategory.tensorμ X₁ X₂ Y₁ Y₂) (CategoryTheory.MonoidalCategoryStruct.tensorObj X₃ Y₃)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ Y₁) (CategoryTheory.MonoidalCategoryStruct.tensorObj X₂ Y₂) (CategoryTheory.MonoidalCategoryStruct.tensorObj X₃ Y₃)).hom h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.associator X₁ X₂ X₃).hom (CategoryTheory.MonoidalCategoryStruct.associator Y₁ Y₂ Y₃).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ X₁ (CategoryTheory.MonoidalCategoryStruct.tensorObj X₂ X₃) Y₁ (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₂ Y₃)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ Y₁) (CategoryTheory.MonoidalCategory.tensorμ X₂ X₃ Y₂ Y₃)) h)))","decl":"@[reassoc]\ntheorem associator_monoidal (X₁ X₂ X₃ Y₁ Y₂ Y₃ : C) :\n    tensorμ (X₁ ⊗ X₂) X₃ (Y₁ ⊗ Y₂) Y₃ ≫\n        (tensorμ X₁ X₂ Y₁ Y₂ ▷ (X₃ ⊗ Y₃)) ≫ (α_ (X₁ ⊗ Y₁) (X₂ ⊗ Y₂) (X₃ ⊗ Y₃)).hom =\n      ((α_ X₁ X₂ X₃).hom ⊗ (α_ Y₁ Y₂ Y₃).hom) ≫\n        tensorμ X₁ (X₂ ⊗ X₃) Y₁ (Y₂ ⊗ Y₃) ≫ ((X₁ ⊗ Y₁) ◁ tensorμ X₂ X₃ Y₂ Y₃) := by\n  dsimp only [tensorμ]\n  calc\n    _ = 𝟙 _ ⊗≫ X₁ ◁ X₂ ◁ (β_ X₃ Y₁).hom ▷ Y₂ ▷ Y₃ ⊗≫\n      X₁ ◁ ((X₂ ⊗ Y₁) ◁ (β_ X₃ Y₂).hom ≫\n        (β_ X₂ Y₁).hom ▷ (Y₂ ⊗ X₃)) ▷ Y₃ ⊗≫ 𝟙 _ := by\n          rw [braiding_tensor_right]; monoidal\n    _ = _ := by rw [whisker_exchange, braiding_tensor_left]; monoidal\n\n"}
{"name":"CategoryTheory.MonoidalCategory.associator_monoidal","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX₁ X₂ X₃ Y₁ Y₂ Y₃ : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂) X₃ (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₁ Y₂) Y₃) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategory.tensorμ X₁ X₂ Y₁ Y₂) (CategoryTheory.MonoidalCategoryStruct.tensorObj X₃ Y₃)) (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ Y₁) (CategoryTheory.MonoidalCategoryStruct.tensorObj X₂ Y₂) (CategoryTheory.MonoidalCategoryStruct.tensorObj X₃ Y₃)).hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.associator X₁ X₂ X₃).hom (CategoryTheory.MonoidalCategoryStruct.associator Y₁ Y₂ Y₃).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ X₁ (CategoryTheory.MonoidalCategoryStruct.tensorObj X₂ X₃) Y₁ (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₂ Y₃)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ Y₁) (CategoryTheory.MonoidalCategory.tensorμ X₂ X₃ Y₂ Y₃))))","decl":"@[reassoc]\ntheorem associator_monoidal (X₁ X₂ X₃ Y₁ Y₂ Y₃ : C) :\n    tensorμ (X₁ ⊗ X₂) X₃ (Y₁ ⊗ Y₂) Y₃ ≫\n        (tensorμ X₁ X₂ Y₁ Y₂ ▷ (X₃ ⊗ Y₃)) ≫ (α_ (X₁ ⊗ Y₁) (X₂ ⊗ Y₂) (X₃ ⊗ Y₃)).hom =\n      ((α_ X₁ X₂ X₃).hom ⊗ (α_ Y₁ Y₂ Y₃).hom) ≫\n        tensorμ X₁ (X₂ ⊗ X₃) Y₁ (Y₂ ⊗ Y₃) ≫ ((X₁ ⊗ Y₁) ◁ tensorμ X₂ X₃ Y₂ Y₃) := by\n  dsimp only [tensorμ]\n  calc\n    _ = 𝟙 _ ⊗≫ X₁ ◁ X₂ ◁ (β_ X₃ Y₁).hom ▷ Y₂ ▷ Y₃ ⊗≫\n      X₁ ◁ ((X₂ ⊗ Y₁) ◁ (β_ X₃ Y₂).hom ≫\n        (β_ X₂ Y₁).hom ▷ (Y₂ ⊗ X₃)) ▷ Y₃ ⊗≫ 𝟙 _ := by\n          rw [braiding_tensor_right]; monoidal\n    _ = _ := by rw [whisker_exchange, braiding_tensor_left]; monoidal\n\n"}
{"name":"CategoryTheory.op_braiding","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : C\n⊢ Eq (CategoryTheory.BraidedCategory.braiding X Y).op (CategoryTheory.BraidedCategory.braiding { unop := Y } { unop := X })","decl":"@[simp] lemma op_braiding (X Y : C) : (β_ X Y).op = β_ (op Y) (op X) := rfl\n"}
{"name":"CategoryTheory.unop_braiding","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : Opposite C\n⊢ Eq (CategoryTheory.BraidedCategory.braiding X Y).unop (CategoryTheory.BraidedCategory.braiding (Opposite.unop Y) (Opposite.unop X))","decl":"@[simp] lemma unop_braiding (X Y : Cᵒᵖ) : (β_ X Y).unop = β_ (unop Y) (unop X) := rfl\n\n"}
{"name":"CategoryTheory.op_hom_braiding","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : C\n⊢ Eq (CategoryTheory.BraidedCategory.braiding X Y).hom.op (CategoryTheory.BraidedCategory.braiding { unop := Y } { unop := X }).hom","decl":"@[simp] lemma op_hom_braiding (X Y : C) : (β_ X Y).hom.op = (β_ (op Y) (op X)).hom := rfl\n"}
{"name":"CategoryTheory.unop_hom_braiding","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : Opposite C\n⊢ Eq (CategoryTheory.BraidedCategory.braiding X Y).hom.unop (CategoryTheory.BraidedCategory.braiding (Opposite.unop Y) (Opposite.unop X)).hom","decl":"@[simp] lemma unop_hom_braiding (X Y : Cᵒᵖ) : (β_ X Y).hom.unop = (β_ (unop Y) (unop X)).hom := rfl\n\n"}
{"name":"CategoryTheory.op_inv_braiding","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : C\n⊢ Eq (CategoryTheory.BraidedCategory.braiding X Y).inv.op (CategoryTheory.BraidedCategory.braiding { unop := Y } { unop := X }).inv","decl":"@[simp] lemma op_inv_braiding (X Y : C) : (β_ X Y).inv.op = (β_ (op Y) (op X)).inv := rfl\n"}
{"name":"CategoryTheory.unop_inv_braiding","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : Opposite C\n⊢ Eq (CategoryTheory.BraidedCategory.braiding X Y).inv.unop (CategoryTheory.BraidedCategory.braiding (Opposite.unop Y) (Opposite.unop X)).inv","decl":"@[simp] lemma unop_inv_braiding (X Y : Cᵒᵖ) : (β_ X Y).inv.unop = (β_ (unop Y) (unop X)).inv := rfl\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.mop_braiding","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : C\n⊢ Eq (CategoryTheory.BraidedCategory.braiding X Y).mop (CategoryTheory.BraidedCategory.braiding { unmop := Y } { unmop := X })","decl":"@[simp] lemma mop_braiding (X Y : C) : (β_ X Y).mop = β_ (mop Y) (mop X) := rfl\n"}
{"name":"CategoryTheory.MonoidalOpposite.unmop_braiding","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : CategoryTheory.MonoidalOpposite C\n⊢ Eq (CategoryTheory.BraidedCategory.braiding X Y).unmop (CategoryTheory.BraidedCategory.braiding Y.unmop X.unmop)","decl":"@[simp] lemma unmop_braiding (X Y : Cᴹᵒᵖ) : (β_ X Y).unmop = β_ (unmop Y) (unmop X) := rfl\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.mop_hom_braiding","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : C\n⊢ Eq (CategoryTheory.BraidedCategory.braiding X Y).hom.mop (CategoryTheory.BraidedCategory.braiding { unmop := Y } { unmop := X }).hom","decl":"@[simp] lemma mop_hom_braiding (X Y : C) : (β_ X Y).hom.mop = (β_ (mop Y) (mop X)).hom := rfl\n"}
{"name":"CategoryTheory.MonoidalOpposite.unmop_hom_braiding","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : CategoryTheory.MonoidalOpposite C\n⊢ Eq (CategoryTheory.BraidedCategory.braiding X Y).hom.unmop (CategoryTheory.BraidedCategory.braiding Y.unmop X.unmop).hom","decl":"@[simp]\nlemma unmop_hom_braiding (X Y : Cᴹᵒᵖ) : (β_ X Y).hom.unmop = (β_ (unmop Y) (unmop X)).hom := rfl\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.mop_inv_braiding","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : C\n⊢ Eq (CategoryTheory.BraidedCategory.braiding X Y).inv.mop (CategoryTheory.BraidedCategory.braiding { unmop := Y } { unmop := X }).inv","decl":"@[simp] lemma mop_inv_braiding (X Y : C) : (β_ X Y).inv.mop = (β_ (mop Y) (mop X)).inv := rfl\n"}
{"name":"CategoryTheory.MonoidalOpposite.unmop_inv_braiding","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : CategoryTheory.MonoidalOpposite C\n⊢ Eq (CategoryTheory.BraidedCategory.braiding X Y).inv.unmop (CategoryTheory.BraidedCategory.braiding Y.unmop X.unmop).inv","decl":"@[simp]\nlemma unmop_inv_braiding (X Y : Cᴹᵒᵖ) : (β_ X Y).inv.unmop = (β_ (unmop Y) (unmop X)).inv := rfl\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.mopFunctor_ε","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.ε (CategoryTheory.mopFunctor C)) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"@[simp] lemma mopFunctor_ε : ε (mopFunctor C) = 𝟙 _ := rfl\n"}
{"name":"CategoryTheory.MonoidalOpposite.mopFunctor_η","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.η (CategoryTheory.mopFunctor C)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.mopFunctor C).obj CategoryTheory.MonoidalCategoryStruct.tensorUnit))","decl":"@[simp] lemma mopFunctor_η : η (mopFunctor C) = 𝟙 _ := rfl\n"}
{"name":"CategoryTheory.MonoidalOpposite.mopFunctor_μ","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : C\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.μ (CategoryTheory.mopFunctor C) X Y) (CategoryTheory.BraidedCategory.braiding { unmop := X } { unmop := Y }).hom","decl":"@[simp] lemma mopFunctor_μ (X Y : C) : μ (mopFunctor C) X Y = (β_ (mop X) (mop Y)).hom := rfl\n"}
{"name":"CategoryTheory.MonoidalOpposite.mopFunctor_δ","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : C\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.δ (CategoryTheory.mopFunctor C) X Y) (CategoryTheory.BraidedCategory.braiding { unmop := X } { unmop := Y }).inv","decl":"@[simp] lemma mopFunctor_δ (X Y : C) : δ (mopFunctor C) X Y = (β_ (mop X) (mop Y)).inv := rfl\n\n"}
{"name":"CategoryTheory.MonoidalOpposite.unmopFunctor_ε","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.ε (CategoryTheory.unmopFunctor C)) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"@[simp] lemma unmopFunctor_ε : ε (unmopFunctor C) = 𝟙 _ := rfl\n"}
{"name":"CategoryTheory.MonoidalOpposite.unmopFunctor_η","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.η (CategoryTheory.unmopFunctor C)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.unmopFunctor C).obj CategoryTheory.MonoidalCategoryStruct.tensorUnit))","decl":"@[simp] lemma unmopFunctor_η : η (unmopFunctor C) = 𝟙 _ := rfl\n"}
{"name":"CategoryTheory.MonoidalOpposite.unmopFunctor_μ","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : CategoryTheory.MonoidalOpposite C\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.μ (CategoryTheory.unmopFunctor C) X Y) (CategoryTheory.BraidedCategory.braiding X.unmop Y.unmop).hom","decl":"@[simp] lemma unmopFunctor_μ (X Y : Cᴹᵒᵖ) :\n    μ (unmopFunctor C) X Y = (β_ (unmop X) (unmop Y)).hom := rfl\n"}
{"name":"CategoryTheory.MonoidalOpposite.unmopFunctor_δ","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : CategoryTheory.MonoidalOpposite C\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.δ (CategoryTheory.unmopFunctor C) X Y) (CategoryTheory.BraidedCategory.braiding X.unmop Y.unmop).inv","decl":"@[simp] lemma unmopFunctor_δ (X Y : Cᴹᵒᵖ) :\n    δ (unmopFunctor C) X Y = (β_ (unmop X) (unmop Y)).inv := rfl\n\n"}
{"name":"CategoryTheory.SymmetricCategory.reverseBraiding_eq","module":"Mathlib.CategoryTheory.Monoidal.Braided.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\ni : CategoryTheory.SymmetricCategory C\n⊢ Eq (CategoryTheory.reverseBraiding C) CategoryTheory.SymmetricCategory.toBraidedCategory","decl":"lemma SymmetricCategory.reverseBraiding_eq (C : Type u₁) [Category.{v₁} C]\n    [MonoidalCategory C] [i : SymmetricCategory C] :\n    reverseBraiding C = i.toBraidedCategory := by\n  dsimp only [reverseBraiding]\n  congr\n  funext X Y\n  exact Iso.ext (braiding_swap_eq_inv_braiding Y X).symm\n\n"}
