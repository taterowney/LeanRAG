{"name":"IsFractional.map","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝³ : CommRing P\ninst✝² : Algebra R P\nP' : Type u_3\ninst✝¹ : CommRing P'\ninst✝ : Algebra R P'\ng : AlgHom R P P'\nI : Submodule R P\na✝ : IsFractional S I\n⊢ IsFractional S (Submodule.map g.toLinearMap I)","decl":"theorem _root_.IsFractional.map (g : P →ₐ[R] P') {I : Submodule R P} :\n    IsFractional S I → IsFractional S (Submodule.map g.toLinearMap I)\n  | ⟨a, a_nonzero, hI⟩ =>\n    ⟨a, a_nonzero, fun b hb => by\n      obtain ⟨b', b'_mem, hb'⟩ := Submodule.mem_map.mp hb\n      rw [AlgHom.toLinearMap_apply] at hb'\n      obtain ⟨x, hx⟩ := hI b' b'_mem\n      use x\n      rw [← g.commutes, hx, _root_.map_smul, hb']⟩\n\n"}
{"name":"FractionalIdeal.coe_map","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝³ : CommRing P\ninst✝² : Algebra R P\nP' : Type u_3\ninst✝¹ : CommRing P'\ninst✝ : Algebra R P'\ng : AlgHom R P P'\nI : FractionalIdeal S P\n⊢ Eq (↑(FractionalIdeal.map g I)) (Submodule.map g.toLinearMap ↑I)","decl":"@[simp, norm_cast]\ntheorem coe_map (g : P →ₐ[R] P') (I : FractionalIdeal S P) :\n    ↑(map g I) = Submodule.map g.toLinearMap I :=\n  rfl\n\n"}
{"name":"FractionalIdeal.mem_map","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝³ : CommRing P\ninst✝² : Algebra R P\nP' : Type u_3\ninst✝¹ : CommRing P'\ninst✝ : Algebra R P'\nI : FractionalIdeal S P\ng : AlgHom R P P'\ny : P'\n⊢ Iff (Membership.mem (FractionalIdeal.map g I) y) (Exists fun x => And (Membership.mem I x) (Eq (g x) y))","decl":"@[simp]\ntheorem mem_map {I : FractionalIdeal S P} {g : P →ₐ[R] P'} {y : P'} :\n    y ∈ I.map g ↔ ∃ x, x ∈ I ∧ g x = y :=\n  Submodule.mem_map\n\n"}
{"name":"FractionalIdeal.map_id","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : FractionalIdeal S P\n⊢ Eq (FractionalIdeal.map (AlgHom.id R P) I) I","decl":"@[simp]\ntheorem map_id : I.map (AlgHom.id _ _) = I :=\n  coeToSubmodule_injective (Submodule.map_id (I : Submodule R P))\n\n"}
{"name":"FractionalIdeal.map_comp","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝⁵ : CommRing P\ninst✝⁴ : Algebra R P\nP' : Type u_3\ninst✝³ : CommRing P'\ninst✝² : Algebra R P'\nP'' : Type u_4\ninst✝¹ : CommRing P''\ninst✝ : Algebra R P''\nI : FractionalIdeal S P\ng : AlgHom R P P'\ng' : AlgHom R P' P''\n⊢ Eq (FractionalIdeal.map (g'.comp g) I) (FractionalIdeal.map g' (FractionalIdeal.map g I))","decl":"@[simp]\ntheorem map_comp (g' : P' →ₐ[R] P'') : I.map (g'.comp g) = (I.map g).map g' :=\n  coeToSubmodule_injective (Submodule.map_comp g.toLinearMap g'.toLinearMap I)\n\n"}
{"name":"FractionalIdeal.map_coeIdeal","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝³ : CommRing P\ninst✝² : Algebra R P\nP' : Type u_3\ninst✝¹ : CommRing P'\ninst✝ : Algebra R P'\ng : AlgHom R P P'\nI : Ideal R\n⊢ Eq (FractionalIdeal.map g ↑I) ↑I","decl":"@[simp, norm_cast]\ntheorem map_coeIdeal (I : Ideal R) : (I : FractionalIdeal S P).map g = I := by\n  ext x\n  simp only [mem_coeIdeal]\n  constructor\n  · rintro ⟨_, ⟨y, hy, rfl⟩, rfl⟩\n    exact ⟨y, hy, (g.commutes y).symm⟩\n  · rintro ⟨y, hy, rfl⟩\n    exact ⟨_, ⟨y, hy, rfl⟩, g.commutes y⟩\n\n"}
{"name":"FractionalIdeal.map_one","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝³ : CommRing P\ninst✝² : Algebra R P\nP' : Type u_3\ninst✝¹ : CommRing P'\ninst✝ : Algebra R P'\ng : AlgHom R P P'\n⊢ Eq (FractionalIdeal.map g 1) 1","decl":"@[simp]\ntheorem map_one : (1 : FractionalIdeal S P).map g = 1 :=\n  map_coeIdeal g ⊤\n\n"}
{"name":"FractionalIdeal.map_zero","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝³ : CommRing P\ninst✝² : Algebra R P\nP' : Type u_3\ninst✝¹ : CommRing P'\ninst✝ : Algebra R P'\ng : AlgHom R P P'\n⊢ Eq (FractionalIdeal.map g 0) 0","decl":"@[simp]\ntheorem map_zero : (0 : FractionalIdeal S P).map g = 0 :=\n  map_coeIdeal g 0\n\n"}
{"name":"FractionalIdeal.map_add","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝³ : CommRing P\ninst✝² : Algebra R P\nP' : Type u_3\ninst✝¹ : CommRing P'\ninst✝ : Algebra R P'\nI J : FractionalIdeal S P\ng : AlgHom R P P'\n⊢ Eq (FractionalIdeal.map g (HAdd.hAdd I J)) (HAdd.hAdd (FractionalIdeal.map g I) (FractionalIdeal.map g J))","decl":"@[simp]\ntheorem map_add : (I + J).map g = I.map g + J.map g :=\n  coeToSubmodule_injective (Submodule.map_sup _ _ _)\n\n"}
{"name":"FractionalIdeal.map_mul","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝³ : CommRing P\ninst✝² : Algebra R P\nP' : Type u_3\ninst✝¹ : CommRing P'\ninst✝ : Algebra R P'\nI J : FractionalIdeal S P\ng : AlgHom R P P'\n⊢ Eq (FractionalIdeal.map g (HMul.hMul I J)) (HMul.hMul (FractionalIdeal.map g I) (FractionalIdeal.map g J))","decl":"@[simp]\ntheorem map_mul : (I * J).map g = I.map g * J.map g := by\n  simp only [mul_def]\n  exact coeToSubmodule_injective (Submodule.map_mul _ _ _)\n\n"}
{"name":"FractionalIdeal.map_map_symm","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝³ : CommRing P\ninst✝² : Algebra R P\nP' : Type u_3\ninst✝¹ : CommRing P'\ninst✝ : Algebra R P'\nI : FractionalIdeal S P\ng : AlgEquiv R P P'\n⊢ Eq (FractionalIdeal.map (↑g.symm) (FractionalIdeal.map (↑g) I)) I","decl":"@[simp]\ntheorem map_map_symm (g : P ≃ₐ[R] P') : (I.map (g : P →ₐ[R] P')).map (g.symm : P' →ₐ[R] P) = I := by\n  rw [← map_comp, g.symm_comp, map_id]\n\n"}
{"name":"FractionalIdeal.map_symm_map","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝³ : CommRing P\ninst✝² : Algebra R P\nP' : Type u_3\ninst✝¹ : CommRing P'\ninst✝ : Algebra R P'\nI : FractionalIdeal S P'\ng : AlgEquiv R P P'\n⊢ Eq (FractionalIdeal.map (↑g) (FractionalIdeal.map (↑g.symm) I)) I","decl":"@[simp]\ntheorem map_symm_map (I : FractionalIdeal S P') (g : P ≃ₐ[R] P') :\n    (I.map (g.symm : P' →ₐ[R] P)).map (g : P →ₐ[R] P') = I := by\n  rw [← map_comp, g.comp_symm, map_id]\n\n"}
{"name":"FractionalIdeal.map_mem_map","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝³ : CommRing P\ninst✝² : Algebra R P\nP' : Type u_3\ninst✝¹ : CommRing P'\ninst✝ : Algebra R P'\nf : AlgHom R P P'\nh : Function.Injective ⇑f\nx : P\nI : FractionalIdeal S P\n⊢ Iff (Membership.mem (FractionalIdeal.map f I) (f x)) (Membership.mem I x)","decl":"theorem map_mem_map {f : P →ₐ[R] P'} (h : Function.Injective f) {x : P} {I : FractionalIdeal S P} :\n    f x ∈ map f I ↔ x ∈ I :=\n  mem_map.trans ⟨fun ⟨_, hx', x'_eq⟩ => h x'_eq ▸ hx', fun h => ⟨x, h, rfl⟩⟩\n\n"}
{"name":"FractionalIdeal.map_injective","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝³ : CommRing P\ninst✝² : Algebra R P\nP' : Type u_3\ninst✝¹ : CommRing P'\ninst✝ : Algebra R P'\nf : AlgHom R P P'\nh : Function.Injective ⇑f\n⊢ Function.Injective (FractionalIdeal.map f)","decl":"theorem map_injective (f : P →ₐ[R] P') (h : Function.Injective f) :\n    Function.Injective (map f : FractionalIdeal S P → FractionalIdeal S P') := fun _ _ hIJ =>\n  ext fun _ => (map_mem_map h).symm.trans (hIJ.symm ▸ map_mem_map h)\n\n"}
{"name":"FractionalIdeal.coeFun_mapEquiv","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝³ : CommRing P\ninst✝² : Algebra R P\nP' : Type u_3\ninst✝¹ : CommRing P'\ninst✝ : Algebra R P'\ng : AlgEquiv R P P'\n⊢ Eq (⇑(FractionalIdeal.mapEquiv g)) (FractionalIdeal.map ↑g)","decl":"@[simp]\ntheorem coeFun_mapEquiv (g : P ≃ₐ[R] P') :\n    (mapEquiv g : FractionalIdeal S P → FractionalIdeal S P') = map g :=\n  rfl\n\n"}
{"name":"FractionalIdeal.mapEquiv_apply","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝³ : CommRing P\ninst✝² : Algebra R P\nP' : Type u_3\ninst✝¹ : CommRing P'\ninst✝ : Algebra R P'\ng : AlgEquiv R P P'\nI : FractionalIdeal S P\n⊢ Eq ((FractionalIdeal.mapEquiv g) I) (FractionalIdeal.map (↑g) I)","decl":"@[simp]\ntheorem mapEquiv_apply (g : P ≃ₐ[R] P') (I : FractionalIdeal S P) : mapEquiv g I = map (↑g) I :=\n  rfl\n\n"}
{"name":"FractionalIdeal.mapEquiv_symm","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝³ : CommRing P\ninst✝² : Algebra R P\nP' : Type u_3\ninst✝¹ : CommRing P'\ninst✝ : Algebra R P'\ng : AlgEquiv R P P'\n⊢ Eq (FractionalIdeal.mapEquiv g).symm (FractionalIdeal.mapEquiv g.symm)","decl":"@[simp]\ntheorem mapEquiv_symm (g : P ≃ₐ[R] P') :\n    ((mapEquiv g).symm : FractionalIdeal S P' ≃+* _) = mapEquiv g.symm :=\n  rfl\n\n"}
{"name":"FractionalIdeal.mapEquiv_refl","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\n⊢ Eq (FractionalIdeal.mapEquiv AlgEquiv.refl) (RingEquiv.refl (FractionalIdeal S P))","decl":"@[simp]\ntheorem mapEquiv_refl : mapEquiv AlgEquiv.refl = RingEquiv.refl (FractionalIdeal S P) :=\n  RingEquiv.ext fun x => by simp\n\n"}
{"name":"FractionalIdeal.isFractional_span_iff","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\ns : Set P\n⊢ Iff (IsFractional S (Submodule.span R s)) (Exists fun a => And (Membership.mem S a) (∀ (b : P), Membership.mem s b → IsLocalization.IsInteger R (HSMul.hSMul a b)))","decl":"theorem isFractional_span_iff {s : Set P} :\n    IsFractional S (span R s) ↔ ∃ a ∈ S, ∀ b : P, b ∈ s → IsInteger R (a • b) :=\n  ⟨fun ⟨a, a_mem, h⟩ => ⟨a, a_mem, fun b hb => h b (subset_span hb)⟩, fun ⟨a, a_mem, h⟩ =>\n    ⟨a, a_mem, fun _ hb =>\n      span_induction (hx := hb) h\n        (by\n          rw [smul_zero]\n          exact isInteger_zero)\n        (fun x y _ _ hx hy => by\n          rw [smul_add]\n          exact isInteger_add hx hy)\n        fun s x _ hx => by\n        rw [smul_comm]\n        exact isInteger_smul hx⟩⟩\n\n"}
{"name":"FractionalIdeal.isFractional_of_fg","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nI : Submodule R P\nhI : I.FG\n⊢ IsFractional S I","decl":"theorem isFractional_of_fg [IsLocalization S P] {I : Submodule R P} (hI : I.FG) :\n    IsFractional S I := by\n  rcases hI with ⟨I, rfl⟩\n  rcases exist_integer_multiples_of_finset S I with ⟨⟨s, hs1⟩, hs⟩\n  rw [isFractional_span_iff]\n  exact ⟨s, hs1, hs⟩\n\n"}
{"name":"FractionalIdeal.mem_span_mul_finite_of_mem_mul","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : FractionalIdeal S P\nx : P\nhx : Membership.mem (HMul.hMul I J) x\n⊢ Exists fun T => Exists fun T' => And (HasSubset.Subset ↑T ↑I) (And (HasSubset.Subset ↑T' ↑J) (Membership.mem (Submodule.span R (HMul.hMul ↑T ↑T')) x))","decl":"theorem mem_span_mul_finite_of_mem_mul {I J : FractionalIdeal S P} {x : P} (hx : x ∈ I * J) :\n    ∃ T T' : Finset P, (T : Set P) ⊆ I ∧ (T' : Set P) ⊆ J ∧ x ∈ span R (T * T' : Set P) :=\n  Submodule.mem_span_mul_finite_of_mem_mul (by simpa using mem_coe.mpr hx)\n\n"}
{"name":"FractionalIdeal.coeIdeal_fg","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\ninj : Function.Injective ⇑(algebraMap R P)\nI : Ideal R\n⊢ Iff (↑↑I).FG I.FG","decl":"theorem coeIdeal_fg (inj : Function.Injective (algebraMap R P)) (I : Ideal R) :\n    FG ((I : FractionalIdeal S P) : Submodule R P) ↔ I.FG :=\n  coeSubmodule_fg _ inj _\n\n"}
{"name":"FractionalIdeal.fg_unit","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : Units (FractionalIdeal S P)\n⊢ (↑↑I).FG","decl":"theorem fg_unit (I : (FractionalIdeal S P)ˣ) : FG (I : Submodule R P) :=\n  Submodule.fg_unit <| Units.map (coeSubmoduleHom S P).toMonoidHom I\n\n"}
{"name":"FractionalIdeal.fg_of_isUnit","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : FractionalIdeal S P\nh : IsUnit I\n⊢ (↑I).FG","decl":"theorem fg_of_isUnit (I : FractionalIdeal S P) (h : IsUnit I) : FG (I : Submodule R P) :=\n  fg_unit h.unit\n\n"}
{"name":"Ideal.fg_of_isUnit","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\ninj : Function.Injective ⇑(algebraMap R P)\nI : Ideal R\nh : IsUnit ↑I\n⊢ I.FG","decl":"theorem _root_.Ideal.fg_of_isUnit (inj : Function.Injective (algebraMap R P)) (I : Ideal R)\n    (h : IsUnit (I : FractionalIdeal S P)) : I.FG := by\n  rw [← coeIdeal_fg S inj I]\n  exact FractionalIdeal.fg_of_isUnit (R := R) I h\n\n"}
{"name":"FractionalIdeal.canonicalEquiv_def","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_5\ninst✝⁶ : CommRing R\nS : Submonoid R\nP : Type u_6\ninst✝⁵ : CommRing P\ninst✝⁴ : Algebra R P\nP' : Type u_7\ninst✝³ : CommRing P'\ninst✝² : Algebra R P'\ninst✝¹ : IsLocalization S P\ninst✝ : IsLocalization S P'\n⊢ Eq (FractionalIdeal.canonicalEquiv S P P')\n    (FractionalIdeal.mapEquiv\n      (let __src := IsLocalization.ringEquivOfRingEquiv P P' (RingEquiv.refl R) ⋯;\n      { toEquiv := __src.toEquiv, map_mul' := ⋯, map_add' := ⋯, commutes' := ⋯ }))","decl":"/-- `canonicalEquiv f f'` is the canonical equivalence between the fractional\nideals in `P` and in `P'`, which are both localizations of `R` at `S`. -/\nnoncomputable irreducible_def canonicalEquiv : FractionalIdeal S P ≃+* FractionalIdeal S P' :=\n  mapEquiv\n    { ringEquivOfRingEquiv P P' (RingEquiv.refl R)\n        (show S.map _ = S by rw [RingEquiv.toMonoidHom_refl, Submonoid.map_id]) with\n      commutes' := fun _ => ringEquivOfRingEquiv_eq _ _ }\n\n"}
{"name":"FractionalIdeal.mem_canonicalEquiv_apply","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝⁵ : CommRing P\ninst✝⁴ : Algebra R P\nP' : Type u_3\ninst✝³ : CommRing P'\ninst✝² : Algebra R P'\ninst✝¹ : IsLocalization S P\ninst✝ : IsLocalization S P'\nI : FractionalIdeal S P\nx : P'\n⊢ Iff (Membership.mem ((FractionalIdeal.canonicalEquiv S P P') I) x) (Exists fun y => And (Membership.mem I y) (Eq ((IsLocalization.map P' (RingHom.id R) ⋯) y) x))","decl":"@[simp]\ntheorem mem_canonicalEquiv_apply {I : FractionalIdeal S P} {x : P'} :\n    x ∈ canonicalEquiv S P P' I ↔\n      ∃ y ∈ I,\n        IsLocalization.map P' (RingHom.id R) (fun y (hy : y ∈ S) => show RingHom.id R y ∈ S from hy)\n            (y : P) =\n          x := by\n  rw [canonicalEquiv, mapEquiv_apply, mem_map]\n  exact ⟨fun ⟨y, mem, Eq⟩ => ⟨y, mem, Eq⟩, fun ⟨y, mem, Eq⟩ => ⟨y, mem, Eq⟩⟩\n\n"}
{"name":"FractionalIdeal.canonicalEquiv_symm","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝⁵ : CommRing P\ninst✝⁴ : Algebra R P\nP' : Type u_3\ninst✝³ : CommRing P'\ninst✝² : Algebra R P'\ninst✝¹ : IsLocalization S P\ninst✝ : IsLocalization S P'\n⊢ Eq (FractionalIdeal.canonicalEquiv S P P').symm (FractionalIdeal.canonicalEquiv S P' P)","decl":"@[simp]\ntheorem canonicalEquiv_symm : (canonicalEquiv S P P').symm = canonicalEquiv S P' P :=\n  RingEquiv.ext fun I =>\n    SetLike.ext_iff.mpr fun x => by\n      rw [mem_canonicalEquiv_apply, canonicalEquiv, mapEquiv_symm, mapEquiv_apply,\n        mem_map]\n      exact ⟨fun ⟨y, mem, Eq⟩ => ⟨y, mem, Eq⟩, fun ⟨y, mem, Eq⟩ => ⟨y, mem, Eq⟩⟩\n\n"}
{"name":"FractionalIdeal.canonicalEquiv_flip","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝⁵ : CommRing P\ninst✝⁴ : Algebra R P\nP' : Type u_3\ninst✝³ : CommRing P'\ninst✝² : Algebra R P'\ninst✝¹ : IsLocalization S P\ninst✝ : IsLocalization S P'\nI : FractionalIdeal S P'\n⊢ Eq ((FractionalIdeal.canonicalEquiv S P P') ((FractionalIdeal.canonicalEquiv S P' P) I)) I","decl":"theorem canonicalEquiv_flip (I) : canonicalEquiv S P P' (canonicalEquiv S P' P I) = I := by\n  rw [← canonicalEquiv_symm, RingEquiv.symm_apply_apply]\n\n"}
{"name":"FractionalIdeal.canonicalEquiv_canonicalEquiv","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁹ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝⁸ : CommRing P\ninst✝⁷ : Algebra R P\nP' : Type u_3\ninst✝⁶ : CommRing P'\ninst✝⁵ : Algebra R P'\ninst✝⁴ : IsLocalization S P\ninst✝³ : IsLocalization S P'\nP'' : Type u_5\ninst✝² : CommRing P''\ninst✝¹ : Algebra R P''\ninst✝ : IsLocalization S P''\nI : FractionalIdeal S P\n⊢ Eq ((FractionalIdeal.canonicalEquiv S P' P'') ((FractionalIdeal.canonicalEquiv S P P') I)) ((FractionalIdeal.canonicalEquiv S P P'') I)","decl":"@[simp]\ntheorem canonicalEquiv_canonicalEquiv (P'' : Type*) [CommRing P''] [Algebra R P'']\n    [IsLocalization S P''] (I : FractionalIdeal S P) :\n    canonicalEquiv S P' P'' (canonicalEquiv S P P' I) = canonicalEquiv S P P'' I := by\n  ext\n  simp only [IsLocalization.map_map, RingHomInvPair.comp_eq₂, mem_canonicalEquiv_apply,\n    exists_prop, exists_exists_and_eq_and]\n\n"}
{"name":"FractionalIdeal.canonicalEquiv_trans_canonicalEquiv","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁹ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝⁸ : CommRing P\ninst✝⁷ : Algebra R P\nP' : Type u_3\ninst✝⁶ : CommRing P'\ninst✝⁵ : Algebra R P'\ninst✝⁴ : IsLocalization S P\ninst✝³ : IsLocalization S P'\nP'' : Type u_5\ninst✝² : CommRing P''\ninst✝¹ : Algebra R P''\ninst✝ : IsLocalization S P''\n⊢ Eq ((FractionalIdeal.canonicalEquiv S P P').trans (FractionalIdeal.canonicalEquiv S P' P'')) (FractionalIdeal.canonicalEquiv S P P'')","decl":"theorem canonicalEquiv_trans_canonicalEquiv (P'' : Type*) [CommRing P''] [Algebra R P'']\n    [IsLocalization S P''] :\n    (canonicalEquiv S P P').trans (canonicalEquiv S P' P'') = canonicalEquiv S P P'' :=\n  RingEquiv.ext (canonicalEquiv_canonicalEquiv S P P' P'')\n\n"}
{"name":"FractionalIdeal.canonicalEquiv_coeIdeal","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝⁵ : CommRing P\ninst✝⁴ : Algebra R P\nP' : Type u_3\ninst✝³ : CommRing P'\ninst✝² : Algebra R P'\ninst✝¹ : IsLocalization S P\ninst✝ : IsLocalization S P'\nI : Ideal R\n⊢ Eq ((FractionalIdeal.canonicalEquiv S P P') ↑I) ↑I","decl":"@[simp]\ntheorem canonicalEquiv_coeIdeal (I : Ideal R) : canonicalEquiv S P P' I = I := by\n  ext\n  simp [IsLocalization.map_eq]\n\n"}
{"name":"FractionalIdeal.canonicalEquiv_self","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\n⊢ Eq (FractionalIdeal.canonicalEquiv S P P) (RingEquiv.refl (FractionalIdeal S P))","decl":"@[simp]\ntheorem canonicalEquiv_self : canonicalEquiv S P P = RingEquiv.refl _ := by\n  rw [← canonicalEquiv_trans_canonicalEquiv S P P]\n  convert (canonicalEquiv S P P).symm_trans_self\n  exact (canonicalEquiv_symm S P P).symm\n\n"}
{"name":"FractionalIdeal.exists_ne_zero_mem_isInteger","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_3\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\nI : FractionalIdeal (nonZeroDivisors R) K\ninst✝ : Nontrivial R\nhI : Ne I 0\n⊢ Exists fun x => And (Ne x 0) (Membership.mem I ((algebraMap R K) x))","decl":"/-- Nonzero fractional ideals contain a nonzero integer. -/\ntheorem exists_ne_zero_mem_isInteger [Nontrivial R] (hI : I ≠ 0) :\n    ∃ x, x ≠ 0 ∧ algebraMap R K x ∈ I := by\n  obtain ⟨y : K, y_mem, y_not_mem⟩ :=\n    SetLike.exists_of_lt (by simpa only using bot_lt_iff_ne_bot.mpr hI)\n  have y_ne_zero : y ≠ 0 := by simpa using y_not_mem\n  obtain ⟨z, ⟨x, hx⟩⟩ := exists_integer_multiple R⁰ y\n  refine ⟨x, ?_, ?_⟩\n  · rw [Ne, ← @IsFractionRing.to_map_eq_zero_iff R _ K, hx, Algebra.smul_def]\n    exact mul_ne_zero (IsFractionRing.to_map_ne_zero_of_mem_nonZeroDivisors z.2) y_ne_zero\n  · rw [hx]\n    exact smul_mem _ _ y_mem\n\n"}
{"name":"FractionalIdeal.map_ne_zero","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁷ : CommRing R\nK : Type u_3\nK' : Type u_4\ninst✝⁶ : Field K\ninst✝⁵ : Field K'\ninst✝⁴ : Algebra R K\ninst✝³ : IsFractionRing R K\ninst✝² : Algebra R K'\ninst✝¹ : IsFractionRing R K'\nI : FractionalIdeal (nonZeroDivisors R) K\nh : AlgHom R K K'\ninst✝ : Nontrivial R\nhI : Ne I 0\n⊢ Ne (FractionalIdeal.map h I) 0","decl":"theorem map_ne_zero [Nontrivial R] (hI : I ≠ 0) : I.map h ≠ 0 := by\n  obtain ⟨x, x_ne_zero, hx⟩ := exists_ne_zero_mem_isInteger hI\n  contrapose! x_ne_zero with map_eq_zero\n  refine IsFractionRing.to_map_eq_zero_iff.mp (eq_zero_iff.mp map_eq_zero _ (mem_map.mpr ?_))\n  exact ⟨algebraMap R K x, hx, h.commutes x⟩\n\n"}
{"name":"FractionalIdeal.map_eq_zero_iff","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁷ : CommRing R\nK : Type u_3\nK' : Type u_4\ninst✝⁶ : Field K\ninst✝⁵ : Field K'\ninst✝⁴ : Algebra R K\ninst✝³ : IsFractionRing R K\ninst✝² : Algebra R K'\ninst✝¹ : IsFractionRing R K'\nI : FractionalIdeal (nonZeroDivisors R) K\nh : AlgHom R K K'\ninst✝ : Nontrivial R\n⊢ Iff (Eq (FractionalIdeal.map h I) 0) (Eq I 0)","decl":"@[simp]\ntheorem map_eq_zero_iff [Nontrivial R] : I.map h = 0 ↔ I = 0 :=\n  ⟨not_imp_not.mp (map_ne_zero _), fun hI => hI.symm ▸ map_zero h⟩\n\n"}
{"name":"FractionalIdeal.coeIdeal_injective","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nK : Type u_3\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ Function.Injective fun I => ↑I","decl":"theorem coeIdeal_injective : Function.Injective (fun (I : Ideal R) ↦ (I : FractionalIdeal R⁰ K)) :=\n  coeIdeal_injective' le_rfl\n\n"}
{"name":"FractionalIdeal.coeIdeal_inj","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nK : Type u_3\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nI J : Ideal R\n⊢ Iff (Eq ↑I ↑J) (Eq I J)","decl":"theorem coeIdeal_inj {I J : Ideal R} :\n    (I : FractionalIdeal R⁰ K) = (J : FractionalIdeal R⁰ K) ↔ I = J :=\n  coeIdeal_inj' le_rfl\n\n"}
{"name":"FractionalIdeal.coeIdeal_eq_zero","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nK : Type u_3\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nI : Ideal R\n⊢ Iff (Eq (↑I) 0) (Eq I Bot.bot)","decl":"@[simp]\ntheorem coeIdeal_eq_zero {I : Ideal R} : (I : FractionalIdeal R⁰ K) = 0 ↔ I = ⊥ :=\n  coeIdeal_eq_zero' le_rfl\n\n"}
{"name":"FractionalIdeal.coeIdeal_ne_zero","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nK : Type u_3\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nI : Ideal R\n⊢ Iff (Ne (↑I) 0) (Ne I Bot.bot)","decl":"theorem coeIdeal_ne_zero {I : Ideal R} : (I : FractionalIdeal R⁰ K) ≠ 0 ↔ I ≠ ⊥ :=\n  coeIdeal_ne_zero' le_rfl\n\n"}
{"name":"FractionalIdeal.coeIdeal_eq_one","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nK : Type u_3\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nI : Ideal R\n⊢ Iff (Eq (↑I) 1) (Eq I 1)","decl":"@[simp]\ntheorem coeIdeal_eq_one {I : Ideal R} : (I : FractionalIdeal R⁰ K) = 1 ↔ I = 1 := by\n  simpa only [Ideal.one_eq_top] using coeIdeal_inj\n\n"}
{"name":"FractionalIdeal.coeIdeal_ne_one","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nK : Type u_3\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nI : Ideal R\n⊢ Iff (Ne (↑I) 1) (Ne I 1)","decl":"theorem coeIdeal_ne_one {I : Ideal R} : (I : FractionalIdeal R⁰ K) ≠ 1 ↔ I ≠ 1 :=\n  not_iff_not.mpr coeIdeal_eq_one\n\n"}
{"name":"FractionalIdeal.num_eq_zero_iff","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_3\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : Nontrivial R\nI : FractionalIdeal (nonZeroDivisors R) K\n⊢ Iff (Eq I.num 0) (Eq I 0)","decl":"theorem num_eq_zero_iff [Nontrivial R] {I : FractionalIdeal R⁰ K} : I.num = 0 ↔ I = 0 :=\n   ⟨fun h ↦ zero_of_num_eq_bot zero_not_mem_nonZeroDivisors h,\n     fun h ↦ h ▸ num_zero_eq (IsFractionRing.injective R K)⟩\n\n"}
{"name":"FractionalIdeal.instNontrivialNonZeroDivisors","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝² : CommRing R₁\nK : Type u_4\ninst✝¹ : Field K\ninst✝ : Algebra R₁ K\n⊢ Nontrivial (FractionalIdeal (nonZeroDivisors R₁) K)","decl":"instance : Nontrivial (FractionalIdeal R₁⁰ K) :=\n  ⟨⟨0, 1, fun h =>\n      have this : (1 : K) ∈ (0 : FractionalIdeal R₁⁰ K) := by\n        rw [← (algebraMap R₁ K).map_one]\n        simpa only [h] using coe_mem_one R₁⁰ 1\n      one_ne_zero ((mem_zero_iff _).mp this)⟩⟩\n\n"}
{"name":"FractionalIdeal.ne_zero_of_mul_eq_one","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝² : CommRing R₁\nK : Type u_4\ninst✝¹ : Field K\ninst✝ : Algebra R₁ K\nI J : FractionalIdeal (nonZeroDivisors R₁) K\nh : Eq (HMul.hMul I J) 1\n⊢ Ne I 0","decl":"theorem ne_zero_of_mul_eq_one (I J : FractionalIdeal R₁⁰ K) (h : I * J = 1) : I ≠ 0 := fun hI =>\n  zero_ne_one' (FractionalIdeal R₁⁰ K)\n    (by\n      convert h\n      simp [hI])\n\n"}
{"name":"IsFractional.div_of_nonzero","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝⁴ : CommRing R₁\nK : Type u_4\ninst✝³ : Field K\ninst✝² : Algebra R₁ K\ninst✝¹ : IsFractionRing R₁ K\ninst✝ : IsDomain R₁\nI J : Submodule R₁ K\na✝² : IsFractional (nonZeroDivisors R₁) I\na✝¹ : IsFractional (nonZeroDivisors R₁) J\na✝ : Ne J 0\n⊢ IsFractional (nonZeroDivisors R₁) (HDiv.hDiv I J)","decl":"theorem _root_.IsFractional.div_of_nonzero {I J : Submodule R₁ K} :\n    IsFractional R₁⁰ I → IsFractional R₁⁰ J → J ≠ 0 → IsFractional R₁⁰ (I / J)\n  | ⟨aI, haI, hI⟩, ⟨aJ, haJ, hJ⟩, h => by\n    obtain ⟨y, mem_J, not_mem_zero⟩ :=\n      SetLike.exists_of_lt (show 0 < J by simpa only using bot_lt_iff_ne_bot.mpr h)\n    obtain ⟨y', hy'⟩ := hJ y mem_J\n    use aI * y'\n    constructor\n    · apply (nonZeroDivisors R₁).mul_mem haI (mem_nonZeroDivisors_iff_ne_zero.mpr _)\n      intro y'_eq_zero\n      have : algebraMap R₁ K aJ * y = 0 := by\n        rw [← Algebra.smul_def, ← hy', y'_eq_zero, RingHom.map_zero]\n      have y_zero :=\n        (mul_eq_zero.mp this).resolve_left\n          (mt ((injective_iff_map_eq_zero (algebraMap R₁ K)).1 (IsFractionRing.injective _ _) _)\n            (mem_nonZeroDivisors_iff_ne_zero.mp haJ))\n      apply not_mem_zero\n      simpa\n    intro b hb\n    convert hI _ (hb _ (Submodule.smul_mem _ aJ mem_J)) using 1\n    rw [← hy', mul_comm b, ← Algebra.smul_def, mul_smul]\n\n"}
{"name":"FractionalIdeal.fractional_div_of_nonzero","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝⁴ : CommRing R₁\nK : Type u_4\ninst✝³ : Field K\ninst✝² : Algebra R₁ K\ninst✝¹ : IsFractionRing R₁ K\ninst✝ : IsDomain R₁\nI J : FractionalIdeal (nonZeroDivisors R₁) K\nh : Ne J 0\n⊢ IsFractional (nonZeroDivisors R₁) (HDiv.hDiv ↑I ↑J)","decl":"theorem fractional_div_of_nonzero {I J : FractionalIdeal R₁⁰ K} (h : J ≠ 0) :\n    IsFractional R₁⁰ (I / J : Submodule R₁ K) :=\n  I.isFractional.div_of_nonzero J.isFractional fun H =>\n    h <| coeToSubmodule_injective <| H.trans coe_zero.symm\n\n"}
{"name":"FractionalIdeal.div_zero","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝⁴ : CommRing R₁\nK : Type u_4\ninst✝³ : Field K\ninst✝² : Algebra R₁ K\ninst✝¹ : IsFractionRing R₁ K\ninst✝ : IsDomain R₁\nI : FractionalIdeal (nonZeroDivisors R₁) K\n⊢ Eq (HDiv.hDiv I 0) 0","decl":"@[simp]\ntheorem div_zero {I : FractionalIdeal R₁⁰ K} : I / 0 = 0 :=\n  dif_pos rfl\n\n"}
{"name":"FractionalIdeal.div_nonzero","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝⁴ : CommRing R₁\nK : Type u_4\ninst✝³ : Field K\ninst✝² : Algebra R₁ K\ninst✝¹ : IsFractionRing R₁ K\ninst✝ : IsDomain R₁\nI J : FractionalIdeal (nonZeroDivisors R₁) K\nh : Ne J 0\n⊢ Eq (HDiv.hDiv I J) ⟨HDiv.hDiv ↑I ↑J, ⋯⟩","decl":"theorem div_nonzero {I J : FractionalIdeal R₁⁰ K} (h : J ≠ 0) :\n    I / J = ⟨I / J, fractional_div_of_nonzero h⟩ :=\n  dif_neg h\n\n"}
{"name":"FractionalIdeal.coe_div","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝⁴ : CommRing R₁\nK : Type u_4\ninst✝³ : Field K\ninst✝² : Algebra R₁ K\ninst✝¹ : IsFractionRing R₁ K\ninst✝ : IsDomain R₁\nI J : FractionalIdeal (nonZeroDivisors R₁) K\nhJ : Ne J 0\n⊢ Eq (↑(HDiv.hDiv I J)) (HDiv.hDiv ↑I ↑J)","decl":"@[simp]\ntheorem coe_div {I J : FractionalIdeal R₁⁰ K} (hJ : J ≠ 0) :\n    (↑(I / J) : Submodule R₁ K) = ↑I / (↑J : Submodule R₁ K) :=\n  congr_arg _ (dif_neg hJ)\n\n"}
{"name":"FractionalIdeal.mem_div_iff_of_nonzero","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝⁴ : CommRing R₁\nK : Type u_4\ninst✝³ : Field K\ninst✝² : Algebra R₁ K\ninst✝¹ : IsFractionRing R₁ K\ninst✝ : IsDomain R₁\nI J : FractionalIdeal (nonZeroDivisors R₁) K\nh : Ne J 0\nx : K\n⊢ Iff (Membership.mem (HDiv.hDiv I J) x) (∀ (y : K), Membership.mem J y → Membership.mem I (HMul.hMul x y))","decl":"theorem mem_div_iff_of_nonzero {I J : FractionalIdeal R₁⁰ K} (h : J ≠ 0) {x} :\n    x ∈ I / J ↔ ∀ y ∈ J, x * y ∈ I := by\n  rw [div_nonzero h]\n  exact Submodule.mem_div_iff_forall_mul_mem\n\n"}
{"name":"FractionalIdeal.mul_one_div_le_one","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝⁴ : CommRing R₁\nK : Type u_4\ninst✝³ : Field K\ninst✝² : Algebra R₁ K\ninst✝¹ : IsFractionRing R₁ K\ninst✝ : IsDomain R₁\nI : FractionalIdeal (nonZeroDivisors R₁) K\n⊢ LE.le (HMul.hMul I (HDiv.hDiv 1 I)) 1","decl":"theorem mul_one_div_le_one {I : FractionalIdeal R₁⁰ K} : I * (1 / I) ≤ 1 := by\n  by_cases hI : I = 0\n  · rw [hI, div_zero, mul_zero]\n    exact zero_le 1\n  · rw [← coe_le_coe, coe_mul, coe_div hI, coe_one]\n    apply Submodule.mul_one_div_le_one\n\n"}
{"name":"FractionalIdeal.le_self_mul_one_div","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝⁴ : CommRing R₁\nK : Type u_4\ninst✝³ : Field K\ninst✝² : Algebra R₁ K\ninst✝¹ : IsFractionRing R₁ K\ninst✝ : IsDomain R₁\nI : FractionalIdeal (nonZeroDivisors R₁) K\nhI : LE.le I 1\n⊢ LE.le I (HMul.hMul I (HDiv.hDiv 1 I))","decl":"theorem le_self_mul_one_div {I : FractionalIdeal R₁⁰ K} (hI : I ≤ (1 : FractionalIdeal R₁⁰ K)) :\n    I ≤ I * (1 / I) := by\n  by_cases hI_nz : I = 0\n  · rw [hI_nz, div_zero, mul_zero]\n  · rw [← coe_le_coe, coe_mul, coe_div hI_nz, coe_one]\n    rw [← coe_le_coe, coe_one] at hI\n    exact Submodule.le_self_mul_one_div hI\n\n"}
{"name":"FractionalIdeal.le_div_iff_of_nonzero","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝⁴ : CommRing R₁\nK : Type u_4\ninst✝³ : Field K\ninst✝² : Algebra R₁ K\ninst✝¹ : IsFractionRing R₁ K\ninst✝ : IsDomain R₁\nI J J' : FractionalIdeal (nonZeroDivisors R₁) K\nhJ' : Ne J' 0\n⊢ Iff (LE.le I (HDiv.hDiv J J')) (∀ (x : K), Membership.mem I x → ∀ (y : K), Membership.mem J' y → Membership.mem J (HMul.hMul x y))","decl":"theorem le_div_iff_of_nonzero {I J J' : FractionalIdeal R₁⁰ K} (hJ' : J' ≠ 0) :\n    I ≤ J / J' ↔ ∀ x ∈ I, ∀ y ∈ J', x * y ∈ J :=\n  ⟨fun h _ hx => (mem_div_iff_of_nonzero hJ').mp (h hx), fun h x hx =>\n    (mem_div_iff_of_nonzero hJ').mpr (h x hx)⟩\n\n"}
{"name":"FractionalIdeal.le_div_iff_mul_le","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝⁴ : CommRing R₁\nK : Type u_4\ninst✝³ : Field K\ninst✝² : Algebra R₁ K\ninst✝¹ : IsFractionRing R₁ K\ninst✝ : IsDomain R₁\nI J J' : FractionalIdeal (nonZeroDivisors R₁) K\nhJ' : Ne J' 0\n⊢ Iff (LE.le I (HDiv.hDiv J J')) (LE.le (HMul.hMul I J') J)","decl":"theorem le_div_iff_mul_le {I J J' : FractionalIdeal R₁⁰ K} (hJ' : J' ≠ 0) :\n    I ≤ J / J' ↔ I * J' ≤ J := by\n  rw [div_nonzero hJ']\n  -- Porting note: this used to be { convert; rw }, flipped the order.\n  rw [← coe_le_coe (I := I * J') (J := J), coe_mul]\n  exact Submodule.le_div_iff_mul_le\n\n"}
{"name":"FractionalIdeal.div_one","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝⁴ : CommRing R₁\nK : Type u_4\ninst✝³ : Field K\ninst✝² : Algebra R₁ K\ninst✝¹ : IsFractionRing R₁ K\ninst✝ : IsDomain R₁\nI : FractionalIdeal (nonZeroDivisors R₁) K\n⊢ Eq (HDiv.hDiv I 1) I","decl":"@[simp]\ntheorem div_one {I : FractionalIdeal R₁⁰ K} : I / 1 = I := by\n  rw [div_nonzero (one_ne_zero' (FractionalIdeal R₁⁰ K))]\n  ext\n  constructor <;> intro h\n  · simpa using mem_div_iff_forall_mul_mem.mp h 1 ((algebraMap R₁ K).map_one ▸ coe_mem_one R₁⁰ 1)\n  · apply mem_div_iff_forall_mul_mem.mpr\n    rintro y ⟨y', _, rfl⟩\n    -- Porting note: this used to be { convert; rw }, flipped the order.\n    rw [mul_comm, Algebra.linearMap_apply, ← Algebra.smul_def]\n    exact Submodule.smul_mem _ y' h\n\n"}
{"name":"FractionalIdeal.eq_one_div_of_mul_eq_one_right","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝⁴ : CommRing R₁\nK : Type u_4\ninst✝³ : Field K\ninst✝² : Algebra R₁ K\ninst✝¹ : IsFractionRing R₁ K\ninst✝ : IsDomain R₁\nI J : FractionalIdeal (nonZeroDivisors R₁) K\nh : Eq (HMul.hMul I J) 1\n⊢ Eq J (HDiv.hDiv 1 I)","decl":"theorem eq_one_div_of_mul_eq_one_right (I J : FractionalIdeal R₁⁰ K) (h : I * J = 1) :\n    J = 1 / I := by\n  have hI : I ≠ 0 := ne_zero_of_mul_eq_one I J h\n  suffices h' : I * (1 / I) = 1 from\n    congr_arg Units.inv <| @Units.ext _ _ (Units.mkOfMulEqOne _ _ h) (Units.mkOfMulEqOne _ _ h') rfl\n  apply le_antisymm\n  · apply mul_le.mpr _\n    intro x hx y hy\n    rw [mul_comm]\n    exact (mem_div_iff_of_nonzero hI).mp hy x hx\n  rw [← h]\n  apply mul_left_mono I\n  apply (le_div_iff_of_nonzero hI).mpr _\n  intro y hy x hx\n  rw [mul_comm]\n  exact mul_mem_mul hy hx\n\n"}
{"name":"FractionalIdeal.mul_div_self_cancel_iff","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝⁴ : CommRing R₁\nK : Type u_4\ninst✝³ : Field K\ninst✝² : Algebra R₁ K\ninst✝¹ : IsFractionRing R₁ K\ninst✝ : IsDomain R₁\nI : FractionalIdeal (nonZeroDivisors R₁) K\n⊢ Iff (Eq (HMul.hMul I (HDiv.hDiv 1 I)) 1) (Exists fun J => Eq (HMul.hMul I J) 1)","decl":"theorem mul_div_self_cancel_iff {I : FractionalIdeal R₁⁰ K} : I * (1 / I) = 1 ↔ ∃ J, I * J = 1 :=\n  ⟨fun h => ⟨1 / I, h⟩, fun ⟨J, hJ⟩ => by rwa [← eq_one_div_of_mul_eq_one_right I J hJ]⟩\n\n"}
{"name":"FractionalIdeal.map_div","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝⁷ : CommRing R₁\nK : Type u_4\ninst✝⁶ : Field K\ninst✝⁵ : Algebra R₁ K\ninst✝⁴ : IsFractionRing R₁ K\ninst✝³ : IsDomain R₁\nK' : Type u_5\ninst✝² : Field K'\ninst✝¹ : Algebra R₁ K'\ninst✝ : IsFractionRing R₁ K'\nI J : FractionalIdeal (nonZeroDivisors R₁) K\nh : AlgEquiv R₁ K K'\n⊢ Eq (FractionalIdeal.map (↑h) (HDiv.hDiv I J)) (HDiv.hDiv (FractionalIdeal.map (↑h) I) (FractionalIdeal.map (↑h) J))","decl":"@[simp]\ntheorem map_div (I J : FractionalIdeal R₁⁰ K) (h : K ≃ₐ[R₁] K') :\n    (I / J).map (h : K →ₐ[R₁] K') = I.map h / J.map h := by\n  by_cases H : J = 0\n  · rw [H, div_zero, map_zero, div_zero]\n  · -- Porting note: `simp` wouldn't apply these lemmas so do them manually using `rw`\n    rw [← coeToSubmodule_inj, div_nonzero H, div_nonzero (map_ne_zero _ H)]\n    simp [Submodule.map_div]\n\n-- Porting note: doesn't need to be @[simp] because this follows from `map_one` and `map_div`\n"}
{"name":"FractionalIdeal.map_one_div","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝⁷ : CommRing R₁\nK : Type u_4\ninst✝⁶ : Field K\ninst✝⁵ : Algebra R₁ K\ninst✝⁴ : IsFractionRing R₁ K\ninst✝³ : IsDomain R₁\nK' : Type u_5\ninst✝² : Field K'\ninst✝¹ : Algebra R₁ K'\ninst✝ : IsFractionRing R₁ K'\nI : FractionalIdeal (nonZeroDivisors R₁) K\nh : AlgEquiv R₁ K K'\n⊢ Eq (FractionalIdeal.map (↑h) (HDiv.hDiv 1 I)) (HDiv.hDiv 1 (FractionalIdeal.map (↑h) I))","decl":"theorem map_one_div (I : FractionalIdeal R₁⁰ K) (h : K ≃ₐ[R₁] K') :\n    (1 / I).map (h : K →ₐ[R₁] K') = 1 / I.map h := by rw [map_div, map_one]\n\n"}
{"name":"FractionalIdeal.eq_zero_or_one","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : IsFractionRing K L\nI : FractionalIdeal (nonZeroDivisors K) L\n⊢ Or (Eq I 0) (Eq I 1)","decl":"theorem eq_zero_or_one (I : FractionalIdeal K⁰ L) : I = 0 ∨ I = 1 := by\n  rw [or_iff_not_imp_left]\n  intro hI\n  simp_rw [@SetLike.ext_iff _ _ _ I 1, mem_one_iff]\n  intro x\n  constructor\n  · intro x_mem\n    obtain ⟨n, d, rfl⟩ := IsLocalization.mk'_surjective K⁰ x\n    refine ⟨n / d, ?_⟩\n    rw [map_div₀, IsFractionRing.mk'_eq_div]\n  · rintro ⟨x, rfl⟩\n    obtain ⟨y, y_ne, y_mem⟩ := exists_ne_zero_mem_isInteger hI\n    rw [← div_mul_cancel₀ x y_ne, RingHom.map_mul, ← Algebra.smul_def]\n    exact smul_mem (M := L) I (x / y) y_mem\n\n"}
{"name":"FractionalIdeal.eq_zero_or_one_of_isField","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\nK : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : Field K\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nhF : IsField R₁\nI : FractionalIdeal (nonZeroDivisors R₁) K\n⊢ Or (Eq I 0) (Eq I 1)","decl":"theorem eq_zero_or_one_of_isField (hF : IsField R₁) (I : FractionalIdeal R₁⁰ K) : I = 0 ∨ I = 1 :=\n  letI : Field R₁ := hF.toField\n  eq_zero_or_one I\n\n"}
{"name":"FractionalIdeal.spanFinset_coe","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝³ : CommRing R₁\nK : Type u_4\ninst✝² : Field K\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nι : Type u_5\ns : Finset ι\nf : ι → K\n⊢ Eq (↑(FractionalIdeal.spanFinset R₁ s f)) (Submodule.span R₁ (Set.image f ↑s))","decl":"@[simp] lemma spanFinset_coe {ι : Type*} (s : Finset ι) (f : ι → K) :\n    (spanFinset R₁ s f : Submodule R₁ K) = Submodule.span R₁ (f '' s) :=\n  rfl\n\n"}
{"name":"FractionalIdeal.spanFinset_eq_zero","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝³ : CommRing R₁\nK : Type u_4\ninst✝² : Field K\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nι : Type u_5\ns : Finset ι\nf : ι → K\n⊢ Iff (Eq (FractionalIdeal.spanFinset R₁ s f) 0) (∀ (j : ι), Membership.mem s j → Eq (f j) 0)","decl":"@[simp]\ntheorem spanFinset_eq_zero {ι : Type*} {s : Finset ι} {f : ι → K} :\n    spanFinset R₁ s f = 0 ↔ ∀ j ∈ s, f j = 0 := by\n  simp only [← coeToSubmodule_inj, spanFinset_coe, coe_zero, Submodule.span_eq_bot,\n    Set.mem_image, Finset.mem_coe, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂]\n\n"}
{"name":"FractionalIdeal.spanFinset_ne_zero","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝³ : CommRing R₁\nK : Type u_4\ninst✝² : Field K\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nι : Type u_5\ns : Finset ι\nf : ι → K\n⊢ Iff (Ne (FractionalIdeal.spanFinset R₁ s f) 0) (Exists fun j => And (Membership.mem s j) (Ne (f j) 0))","decl":"theorem spanFinset_ne_zero {ι : Type*} {s : Finset ι} {f : ι → K} :\n    spanFinset R₁ s f ≠ 0 ↔ ∃ j ∈ s, f j ≠ 0 := by simp\n\n"}
{"name":"FractionalIdeal.isFractional_span_singleton","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nx : P\n⊢ IsFractional S (Submodule.span R (Singleton.singleton x))","decl":"theorem isFractional_span_singleton (x : P) : IsFractional S (span R {x} : Submodule R P) :=\n  let ⟨a, ha⟩ := exists_integer_multiple S x\n  isFractional_span_iff.mpr ⟨a, a.2, fun _ hx' => (Set.mem_singleton_iff.mp hx').symm ▸ ha⟩\n\n"}
{"name":"FractionalIdeal.spanSingleton_def","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_5\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_6\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nx : P\n⊢ Eq (FractionalIdeal.spanSingleton S x) ⟨Submodule.span R (Singleton.singleton x), ⋯⟩","decl":"/-- `spanSingleton x` is the fractional ideal generated by `x` if `0 ∉ S` -/\nirreducible_def spanSingleton (x : P) : FractionalIdeal S P :=\n  ⟨span R {x}, isFractional_span_singleton x⟩\n\n-- local attribute [semireducible] span_singleton\n"}
{"name":"FractionalIdeal.coe_spanSingleton","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nx : P\n⊢ Eq (↑(FractionalIdeal.spanSingleton S x)) (Submodule.span R (Singleton.singleton x))","decl":"@[simp]\ntheorem coe_spanSingleton (x : P) : (spanSingleton S x : Submodule R P) = span R {x} := by\n  rw [spanSingleton]\n  rfl\n\n"}
{"name":"FractionalIdeal.mem_spanSingleton","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nx y : P\n⊢ Iff (Membership.mem (FractionalIdeal.spanSingleton S y) x) (Exists fun z => Eq (HSMul.hSMul z y) x)","decl":"@[simp]\ntheorem mem_spanSingleton {x y : P} : x ∈ spanSingleton S y ↔ ∃ z : R, z • y = x := by\n  rw [spanSingleton]\n  exact Submodule.mem_span_singleton\n\n"}
{"name":"FractionalIdeal.mem_spanSingleton_self","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nx : P\n⊢ Membership.mem (FractionalIdeal.spanSingleton S x) x","decl":"theorem mem_spanSingleton_self (x : P) : x ∈ spanSingleton S x :=\n  (mem_spanSingleton S).mpr ⟨1, one_smul _ _⟩\n\n"}
{"name":"FractionalIdeal.den_mul_self_eq_num'","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nI : FractionalIdeal S P\n⊢ Eq (HMul.hMul (FractionalIdeal.spanSingleton S ((algebraMap R P) ↑I.den)) I) ↑I.num","decl":"variable (P) in\n/-- A version of `FractionalIdeal.den_mul_self_eq_num` in terms of fractional ideals. -/\ntheorem den_mul_self_eq_num' (I : FractionalIdeal S P) :\n    spanSingleton S (algebraMap R P I.den) * I = I.num := by\n  apply coeToSubmodule_injective\n  dsimp only\n  rw [coe_mul, ← smul_eq_mul, coe_spanSingleton, smul_eq_mul, Submodule.span_singleton_mul]\n  convert I.den_mul_self_eq_num using 1\n  ext\n  erw [Set.mem_smul_set, Set.mem_smul_set]\n  simp [Algebra.smul_def]\n\n"}
{"name":"FractionalIdeal.spanSingleton_le_iff_mem","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nx : P\nI : FractionalIdeal S P\n⊢ Iff (LE.le (FractionalIdeal.spanSingleton S x) I) (Membership.mem I x)","decl":"@[simp]\ntheorem spanSingleton_le_iff_mem {x : P} {I : FractionalIdeal S P} :\n    spanSingleton S x ≤ I ↔ x ∈ I := by\n  rw [← coe_le_coe, coe_spanSingleton, Submodule.span_singleton_le_iff_mem, mem_coe]\n\n"}
{"name":"FractionalIdeal.spanSingleton_eq_spanSingleton","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝³ : CommRing P\ninst✝² : Algebra R P\ninst✝¹ : IsLocalization S P\ninst✝ : NoZeroSMulDivisors R P\nx y : P\n⊢ Iff (Eq (FractionalIdeal.spanSingleton S x) (FractionalIdeal.spanSingleton S y)) (Exists fun z => Eq (HSMul.hSMul z x) y)","decl":"theorem spanSingleton_eq_spanSingleton [NoZeroSMulDivisors R P] {x y : P} :\n    spanSingleton S x = spanSingleton S y ↔ ∃ z : Rˣ, z • x = y := by\n  rw [← Submodule.span_singleton_eq_span_singleton, spanSingleton, spanSingleton]\n  exact Subtype.mk_eq_mk\n\n"}
{"name":"FractionalIdeal.eq_spanSingleton_of_principal","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝³ : CommRing P\ninst✝² : Algebra R P\ninst✝¹ : IsLocalization S P\nI : FractionalIdeal S P\ninst✝ : (↑I).IsPrincipal\n⊢ Eq I (FractionalIdeal.spanSingleton S (Submodule.IsPrincipal.generator ↑I))","decl":"theorem eq_spanSingleton_of_principal (I : FractionalIdeal S P) [IsPrincipal (I : Submodule R P)] :\n    I = spanSingleton S (generator (I : Submodule R P)) := by\n  -- Porting note: this used to be `coeToSubmodule_injective (span_singleton_generator ↑I).symm`\n  -- but Lean 4 struggled to unify everything. Turned it into an explicit `rw`.\n  rw [spanSingleton, ← coeToSubmodule_inj, coe_mk, span_singleton_generator]\n\n"}
{"name":"FractionalIdeal.isPrincipal_iff","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nI : FractionalIdeal S P\n⊢ Iff (↑I).IsPrincipal (Exists fun x => Eq I (FractionalIdeal.spanSingleton S x))","decl":"theorem isPrincipal_iff (I : FractionalIdeal S P) :\n    IsPrincipal (I : Submodule R P) ↔ ∃ x, I = spanSingleton S x :=\n  ⟨fun _ => ⟨generator (I : Submodule R P), eq_spanSingleton_of_principal I⟩,\n    fun ⟨x, hx⟩ => { principal' := ⟨x, Eq.trans (congr_arg _ hx) (coe_spanSingleton _ x)⟩ }⟩\n\n"}
{"name":"FractionalIdeal.spanSingleton_zero","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\n⊢ Eq (FractionalIdeal.spanSingleton S 0) 0","decl":"@[simp]\ntheorem spanSingleton_zero : spanSingleton S (0 : P) = 0 := by\n  ext\n  simp [Submodule.mem_span_singleton, eq_comm]\n\n"}
{"name":"FractionalIdeal.spanSingleton_eq_zero_iff","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\ny : P\n⊢ Iff (Eq (FractionalIdeal.spanSingleton S y) 0) (Eq y 0)","decl":"theorem spanSingleton_eq_zero_iff {y : P} : spanSingleton S y = 0 ↔ y = 0 :=\n  ⟨fun h =>\n    span_eq_bot.mp (by simpa using congr_arg Subtype.val h : span R {y} = ⊥) y (mem_singleton y),\n    fun h => by simp [h]⟩\n\n"}
{"name":"FractionalIdeal.spanSingleton_ne_zero_iff","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\ny : P\n⊢ Iff (Ne (FractionalIdeal.spanSingleton S y) 0) (Ne y 0)","decl":"theorem spanSingleton_ne_zero_iff {y : P} : spanSingleton S y ≠ 0 ↔ y ≠ 0 :=\n  not_congr spanSingleton_eq_zero_iff\n\n"}
{"name":"FractionalIdeal.spanSingleton_one","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\n⊢ Eq (FractionalIdeal.spanSingleton S 1) 1","decl":"@[simp]\ntheorem spanSingleton_one : spanSingleton S (1 : P) = 1 := by\n  ext\n  refine (mem_spanSingleton S).trans ((exists_congr ?_).trans (mem_one_iff S).symm)\n  intro x'\n  rw [Algebra.smul_def, mul_one]\n\n"}
{"name":"FractionalIdeal.spanSingleton_mul_spanSingleton","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nx y : P\n⊢ Eq (HMul.hMul (FractionalIdeal.spanSingleton S x) (FractionalIdeal.spanSingleton S y)) (FractionalIdeal.spanSingleton S (HMul.hMul x y))","decl":"@[simp]\ntheorem spanSingleton_mul_spanSingleton (x y : P) :\n    spanSingleton S x * spanSingleton S y = spanSingleton S (x * y) := by\n  apply coeToSubmodule_injective\n  simp only [coe_mul, coe_spanSingleton, span_mul_span, singleton_mul_singleton]\n\n"}
{"name":"FractionalIdeal.spanSingleton_pow","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nx : P\nn : Nat\n⊢ Eq (HPow.hPow (FractionalIdeal.spanSingleton S x) n) (FractionalIdeal.spanSingleton S (HPow.hPow x n))","decl":"@[simp]\ntheorem spanSingleton_pow (x : P) (n : ℕ) : spanSingleton S x ^ n = spanSingleton S (x ^ n) := by\n  induction' n with n hn\n  · rw [pow_zero, pow_zero, spanSingleton_one]\n  · rw [pow_succ, hn, spanSingleton_mul_spanSingleton, pow_succ]\n\n"}
{"name":"FractionalIdeal.coeIdeal_span_singleton","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nx : R\n⊢ Eq (↑(Ideal.span (Singleton.singleton x))) (FractionalIdeal.spanSingleton S ((algebraMap R P) x))","decl":"@[simp]\ntheorem coeIdeal_span_singleton (x : R) :\n    (↑(Ideal.span {x} : Ideal R) : FractionalIdeal S P) = spanSingleton S (algebraMap R P x) := by\n  ext y\n  refine (mem_coeIdeal S).trans (Iff.trans ?_ (mem_spanSingleton S).symm)\n  constructor\n  · rintro ⟨y', hy', rfl⟩\n    obtain ⟨x', rfl⟩ := Submodule.mem_span_singleton.mp hy'\n    use x'\n    rw [smul_eq_mul, RingHom.map_mul, Algebra.smul_def]\n  · rintro ⟨y', rfl⟩\n    refine ⟨y' * x, Submodule.mem_span_singleton.mpr ⟨y', rfl⟩, ?_⟩\n    rw [RingHom.map_mul, Algebra.smul_def]\n\n"}
{"name":"FractionalIdeal.canonicalEquiv_spanSingleton","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝⁵ : CommRing P\ninst✝⁴ : Algebra R P\ninst✝³ : IsLocalization S P\nP' : Type u_5\ninst✝² : CommRing P'\ninst✝¹ : Algebra R P'\ninst✝ : IsLocalization S P'\nx : P\n⊢ Eq ((FractionalIdeal.canonicalEquiv S P P') (FractionalIdeal.spanSingleton S x)) (FractionalIdeal.spanSingleton S ((IsLocalization.map P' (RingHom.id R) ⋯) x))","decl":"@[simp]\ntheorem canonicalEquiv_spanSingleton {P'} [CommRing P'] [Algebra R P'] [IsLocalization S P']\n    (x : P) :\n    canonicalEquiv S P P' (spanSingleton S x) =\n      spanSingleton S\n        (IsLocalization.map P' (RingHom.id R)\n          (fun y (hy : y ∈ S) => show RingHom.id R y ∈ S from hy) x) := by\n  apply SetLike.ext_iff.mpr\n  intro y\n  constructor <;> intro h\n  · rw [mem_spanSingleton]\n    obtain ⟨x', hx', rfl⟩ := (mem_canonicalEquiv_apply _ _ _).mp h\n    obtain ⟨z, rfl⟩ := (mem_spanSingleton _).mp hx'\n    use z\n    rw [IsLocalization.map_smul, RingHom.id_apply]\n  · rw [mem_canonicalEquiv_apply]\n    obtain ⟨z, rfl⟩ := (mem_spanSingleton _).mp h\n    use z • x\n    use (mem_spanSingleton _).mpr ⟨z, rfl⟩\n    simp [IsLocalization.map_smul]\n\n"}
{"name":"FractionalIdeal.mem_singleton_mul","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nx y : P\nI : FractionalIdeal S P\n⊢ Iff (Membership.mem (HMul.hMul (FractionalIdeal.spanSingleton S x) I) y) (Exists fun y' => And (Membership.mem I y') (Eq y (HMul.hMul x y')))","decl":"theorem mem_singleton_mul {x y : P} {I : FractionalIdeal S P} :\n    y ∈ spanSingleton S x * I ↔ ∃ y' ∈ I, y = x * y' := by\n  constructor\n  · intro h\n    refine FractionalIdeal.mul_induction_on h ?_ ?_\n    · intro x' hx' y' hy'\n      obtain ⟨a, ha⟩ := (mem_spanSingleton S).mp hx'\n      use a • y', Submodule.smul_mem (I : Submodule R P) a hy'\n      rw [← ha, Algebra.mul_smul_comm, Algebra.smul_mul_assoc]\n    · rintro _ _ ⟨y, hy, rfl⟩ ⟨y', hy', rfl⟩\n      exact ⟨y + y', Submodule.add_mem (I : Submodule R P) hy hy', (mul_add _ _ _).symm⟩\n  · rintro ⟨y', hy', rfl⟩\n    exact mul_mem_mul ((mem_spanSingleton S).mpr ⟨1, one_smul _ _⟩) hy'\n\n"}
{"name":"FractionalIdeal.mk'_mul_coeIdeal_eq_coeIdeal","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝³ : CommRing R₁\nK : Type u_4\ninst✝² : Field K\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nI J : Ideal R₁\nx y : R₁\nhy : Membership.mem (nonZeroDivisors R₁) y\n⊢ Iff (Eq (HMul.hMul (FractionalIdeal.spanSingleton (nonZeroDivisors R₁) (IsLocalization.mk' K x ⟨y, hy⟩)) ↑I) ↑J) (Eq (HMul.hMul (Ideal.span (Singleton.singleton x)) I) (HMul.hMul (Ideal.span (Singleton.singleton y)) J))","decl":"theorem mk'_mul_coeIdeal_eq_coeIdeal {I J : Ideal R₁} {x y : R₁} (hy : y ∈ R₁⁰) :\n    spanSingleton R₁⁰ (IsLocalization.mk' K x ⟨y, hy⟩) * I = (J : FractionalIdeal R₁⁰ K) ↔\n      Ideal.span {x} * I = Ideal.span {y} * J := by\n  have :\n    spanSingleton R₁⁰ (IsLocalization.mk' _ (1 : R₁) ⟨y, hy⟩) *\n        spanSingleton R₁⁰ (algebraMap R₁ K y) =\n      1 := by\n    rw [spanSingleton_mul_spanSingleton, mul_comm, ← IsLocalization.mk'_eq_mul_mk'_one,\n      IsLocalization.mk'_self, spanSingleton_one]\n  let y' : (FractionalIdeal R₁⁰ K)ˣ := Units.mkOfMulEqOne _ _ this\n  have coe_y' : ↑y' = spanSingleton R₁⁰ (IsLocalization.mk' K (1 : R₁) ⟨y, hy⟩) := rfl\n  refine Iff.trans ?_ (y'.mul_right_inj.trans coeIdeal_inj)\n  rw [coe_y', coeIdeal_mul, coeIdeal_span_singleton, coeIdeal_mul, coeIdeal_span_singleton, ←\n    mul_assoc, spanSingleton_mul_spanSingleton, ← mul_assoc, spanSingleton_mul_spanSingleton,\n    mul_comm (mk' _ _ _), ← IsLocalization.mk'_eq_mul_mk'_one, mul_comm (mk' _ _ _), ←\n    IsLocalization.mk'_eq_mul_mk'_one, IsLocalization.mk'_self, spanSingleton_one, one_mul]\n\n"}
{"name":"FractionalIdeal.spanSingleton_mul_coeIdeal_eq_coeIdeal","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝³ : CommRing R₁\nK : Type u_4\ninst✝² : Field K\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nI J : Ideal R₁\nz : K\n⊢ Iff (Eq (HMul.hMul (FractionalIdeal.spanSingleton (nonZeroDivisors R₁) z) ↑I) ↑J) (Eq (HMul.hMul (Ideal.span (Singleton.singleton (IsLocalization.sec (nonZeroDivisors R₁) z).1)) I) (HMul.hMul (Ideal.span (Singleton.singleton ↑(IsLocalization.sec (nonZeroDivisors R₁) z).2)) J))","decl":"theorem spanSingleton_mul_coeIdeal_eq_coeIdeal {I J : Ideal R₁} {z : K} :\n    spanSingleton R₁⁰ z * (I : FractionalIdeal R₁⁰ K) = J ↔\n      Ideal.span {((IsLocalization.sec R₁⁰ z).1 : R₁)} * I =\n        Ideal.span {((IsLocalization.sec R₁⁰ z).2 : R₁)} * J := by\n  rw [← mk'_mul_coeIdeal_eq_coeIdeal K (IsLocalization.sec R₁⁰ z).2.prop,\n    IsLocalization.mk'_sec K z]\n\n"}
{"name":"FractionalIdeal.one_div_spanSingleton","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝⁴ : CommRing R₁\nK : Type u_4\ninst✝³ : Field K\ninst✝² : Algebra R₁ K\ninst✝¹ : IsFractionRing R₁ K\ninst✝ : IsDomain R₁\nx : K\n⊢ Eq (HDiv.hDiv 1 (FractionalIdeal.spanSingleton (nonZeroDivisors R₁) x)) (FractionalIdeal.spanSingleton (nonZeroDivisors R₁) (Inv.inv x))","decl":"theorem one_div_spanSingleton (x : K) : 1 / spanSingleton R₁⁰ x = spanSingleton R₁⁰ x⁻¹ := by\n  classical\n  exact if h : x = 0 then by simp [h] else (eq_one_div_of_mul_eq_one_right _ _ (by simp [h])).symm\n\n"}
{"name":"FractionalIdeal.div_spanSingleton","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝⁴ : CommRing R₁\nK : Type u_4\ninst✝³ : Field K\ninst✝² : Algebra R₁ K\ninst✝¹ : IsFractionRing R₁ K\ninst✝ : IsDomain R₁\nJ : FractionalIdeal (nonZeroDivisors R₁) K\nd : K\n⊢ Eq (HDiv.hDiv J (FractionalIdeal.spanSingleton (nonZeroDivisors R₁) d)) (HMul.hMul (FractionalIdeal.spanSingleton (nonZeroDivisors R₁) (Inv.inv d)) J)","decl":"@[simp]\ntheorem div_spanSingleton (J : FractionalIdeal R₁⁰ K) (d : K) :\n    J / spanSingleton R₁⁰ d = spanSingleton R₁⁰ d⁻¹ * J := by\n  rw [← one_div_spanSingleton]\n  by_cases hd : d = 0\n  · simp only [hd, spanSingleton_zero, div_zero, zero_mul]\n  have h_spand : spanSingleton R₁⁰ d ≠ 0 := mt spanSingleton_eq_zero_iff.mp hd\n  apply le_antisymm\n  · intro x hx\n    dsimp only [val_eq_coe] at hx ⊢ -- Porting note: get rid of the partially applied `coe`s\n    rw [coe_div h_spand, Submodule.mem_div_iff_forall_mul_mem] at hx\n    specialize hx d (mem_spanSingleton_self R₁⁰ d)\n    have h_xd : x = d⁻¹ * (x * d) := by field_simp\n    rw [coe_mul, one_div_spanSingleton, h_xd]\n    exact Submodule.mul_mem_mul (mem_spanSingleton_self R₁⁰ _) hx\n  · rw [le_div_iff_mul_le h_spand, mul_assoc, mul_left_comm, one_div_spanSingleton,\n      spanSingleton_mul_spanSingleton, inv_mul_cancel₀ hd, spanSingleton_one, mul_one]\n\n"}
{"name":"FractionalIdeal.exists_eq_spanSingleton_mul","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝⁴ : CommRing R₁\nK : Type u_4\ninst✝³ : Field K\ninst✝² : Algebra R₁ K\ninst✝¹ : IsFractionRing R₁ K\ninst✝ : IsDomain R₁\nI : FractionalIdeal (nonZeroDivisors R₁) K\n⊢ Exists fun a => Exists fun aI => And (Ne a 0) (Eq I (HMul.hMul (FractionalIdeal.spanSingleton (nonZeroDivisors R₁) (Inv.inv ((algebraMap R₁ K) a))) ↑aI))","decl":"theorem exists_eq_spanSingleton_mul (I : FractionalIdeal R₁⁰ K) :\n    ∃ (a : R₁) (aI : Ideal R₁), a ≠ 0 ∧ I = spanSingleton R₁⁰ (algebraMap R₁ K a)⁻¹ * aI := by\n  obtain ⟨a_inv, nonzero, ha⟩ := I.isFractional\n  have nonzero := mem_nonZeroDivisors_iff_ne_zero.mp nonzero\n  have map_a_nonzero : algebraMap R₁ K a_inv ≠ 0 :=\n    mt IsFractionRing.to_map_eq_zero_iff.mp nonzero\n  refine\n    ⟨a_inv,\n      Submodule.comap (Algebra.linearMap R₁ K) ↑(spanSingleton R₁⁰ (algebraMap R₁ K a_inv) * I),\n      nonzero, ext fun x => Iff.trans ⟨?_, ?_⟩ mem_singleton_mul.symm⟩\n  · intro hx\n    obtain ⟨x', hx'⟩ := ha x hx\n    rw [Algebra.smul_def] at hx'\n    refine ⟨algebraMap R₁ K x', (mem_coeIdeal _).mpr ⟨x', mem_singleton_mul.mpr ?_, rfl⟩, ?_⟩\n    · exact ⟨x, hx, hx'⟩\n    · rw [hx', ← mul_assoc, inv_mul_cancel₀ map_a_nonzero, one_mul]\n  · rintro ⟨y, hy, rfl⟩\n    obtain ⟨x', hx', rfl⟩ := (mem_coeIdeal _).mp hy\n    obtain ⟨y', hy', hx'⟩ := mem_singleton_mul.mp hx'\n    rw [Algebra.linearMap_apply] at hx'\n    rwa [hx', ← mul_assoc, inv_mul_cancel₀ map_a_nonzero, one_mul]\n\n\n"}
{"name":"FractionalIdeal.ideal_factor_ne_zero","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_6\ninst✝³ : CommRing R\nK : Type u_5\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nI : FractionalIdeal (nonZeroDivisors R) K\nhI : Ne I 0\na : R\nJ : Ideal R\nhaJ : Eq I (HMul.hMul (FractionalIdeal.spanSingleton (nonZeroDivisors R) (Inv.inv ((algebraMap R K) a))) ↑J)\n⊢ Ne J 0","decl":"/-- If `I` is a nonzero fractional ideal, `a ∈ R`, and `J` is an ideal of `R` such that\n`I = a⁻¹J`, then `J` is nonzero. -/\ntheorem ideal_factor_ne_zero {R} [CommRing R] {K : Type*} [Field K] [Algebra R K]\n    [IsFractionRing R K] {I : FractionalIdeal R⁰ K} (hI : I ≠ 0) {a : R} {J : Ideal R}\n    (haJ : I = spanSingleton R⁰ ((algebraMap R K) a)⁻¹ * ↑J) : J ≠ 0 := fun h ↦ by\n  rw [h, Ideal.zero_eq_bot, coeIdeal_bot, MulZeroClass.mul_zero] at haJ\n  exact hI haJ\n\n"}
{"name":"FractionalIdeal.constant_factor_ne_zero","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_6\ninst✝³ : CommRing R\nK : Type u_5\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nI : FractionalIdeal (nonZeroDivisors R) K\nhI : Ne I 0\na : R\nJ : Ideal R\nhaJ : Eq I (HMul.hMul (FractionalIdeal.spanSingleton (nonZeroDivisors R) (Inv.inv ((algebraMap R K) a))) ↑J)\n⊢ Ne (Ideal.span (Singleton.singleton a)) 0","decl":"/-- If `I` is a nonzero fractional ideal, `a ∈ R`, and `J` is an ideal of `R` such that\n`I = a⁻¹J`, then `a` is nonzero. -/\ntheorem constant_factor_ne_zero {R} [CommRing R] {K : Type*} [Field K] [Algebra R K]\n    [IsFractionRing R K] {I : FractionalIdeal R⁰ K} (hI : I ≠ 0) {a : R} {J : Ideal R}\n    (haJ : I = spanSingleton R⁰ ((algebraMap R K) a)⁻¹ * ↑J) :\n    (Ideal.span {a} : Ideal R) ≠ 0 := fun h ↦ by\n  rw [Ideal.zero_eq_bot, Ideal.span_singleton_eq_bot] at h\n  rw [h, RingHom.map_zero, inv_zero, spanSingleton_zero, MulZeroClass.zero_mul] at haJ\n  exact hI haJ\n\n"}
{"name":"FractionalIdeal.isPrincipal","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"K : Type u_4\ninst✝⁵ : Field K\nR : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\ninst✝² : IsPrincipalIdealRing R\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nI : FractionalIdeal (nonZeroDivisors R) K\n⊢ (↑I).IsPrincipal","decl":"instance isPrincipal {R} [CommRing R] [IsDomain R] [IsPrincipalIdealRing R] [Algebra R K]\n    [IsFractionRing R K] (I : FractionalIdeal R⁰ K) : (I : Submodule R K).IsPrincipal := by\n  obtain ⟨a, aI, -, ha⟩ := exists_eq_spanSingleton_mul I\n  use (algebraMap R K a)⁻¹ * algebraMap R K (generator aI)\n  suffices I = spanSingleton R⁰ ((algebraMap R K a)⁻¹ * algebraMap R K (generator aI)) by\n    rw [spanSingleton] at this\n    exact congr_arg Subtype.val this\n  conv_lhs => rw [ha, ← span_singleton_generator aI]\n  rw [Ideal.submodule_span_eq, coeIdeal_span_singleton (generator aI),\n    spanSingleton_mul_spanSingleton]\n\n"}
{"name":"FractionalIdeal.le_spanSingleton_mul_iff","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nx : P\nI J : FractionalIdeal S P\n⊢ Iff (LE.le I (HMul.hMul (FractionalIdeal.spanSingleton S x) J)) (∀ (zI : P), Membership.mem I zI → Exists fun zJ => And (Membership.mem J zJ) (Eq (HMul.hMul x zJ) zI))","decl":"theorem le_spanSingleton_mul_iff {x : P} {I J : FractionalIdeal S P} :\n    I ≤ spanSingleton S x * J ↔ ∀ zI ∈ I, ∃ zJ ∈ J, x * zJ = zI :=\n  show (∀ {zI} (_ : zI ∈ I), zI ∈ spanSingleton _ x * J) ↔ ∀ zI ∈ I, ∃ zJ ∈ J, x * zJ = zI by\n    simp only [mem_singleton_mul, eq_comm]\n\n"}
{"name":"FractionalIdeal.spanSingleton_mul_le_iff","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nx : P\nI J : FractionalIdeal S P\n⊢ Iff (LE.le (HMul.hMul (FractionalIdeal.spanSingleton S x) I) J) (∀ (z : P), Membership.mem I z → Membership.mem J (HMul.hMul x z))","decl":"theorem spanSingleton_mul_le_iff {x : P} {I J : FractionalIdeal S P} :\n    spanSingleton _ x * I ≤ J ↔ ∀ z ∈ I, x * z ∈ J := by\n  simp only [mul_le, mem_singleton_mul, mem_spanSingleton]\n  constructor\n  · intro h zI hzI\n    exact h x ⟨1, one_smul _ _⟩ zI hzI\n  · rintro h _ ⟨z, rfl⟩ zI hzI\n    rw [Algebra.smul_mul_assoc]\n    exact Submodule.smul_mem J.1 _ (h zI hzI)\n\n"}
{"name":"FractionalIdeal.eq_spanSingleton_mul","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nx : P\nI J : FractionalIdeal S P\n⊢ Iff (Eq I (HMul.hMul (FractionalIdeal.spanSingleton S x) J)) (And (∀ (zI : P), Membership.mem I zI → Exists fun zJ => And (Membership.mem J zJ) (Eq (HMul.hMul x zJ) zI)) (∀ (z : P), Membership.mem J z → Membership.mem I (HMul.hMul x z)))","decl":"theorem eq_spanSingleton_mul {x : P} {I J : FractionalIdeal S P} :\n    I = spanSingleton _ x * J ↔ (∀ zI ∈ I, ∃ zJ ∈ J, x * zJ = zI) ∧ ∀ z ∈ J, x * z ∈ I := by\n  simp only [le_antisymm_iff, le_spanSingleton_mul_iff, spanSingleton_mul_le_iff]\n\n"}
{"name":"FractionalIdeal.num_le","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nI : FractionalIdeal S P\n⊢ LE.le (↑I.num) I","decl":"theorem num_le (I : FractionalIdeal S P) :\n    (I.num : FractionalIdeal S P) ≤ I := by\n  rw [← I.den_mul_self_eq_num', spanSingleton_mul_le_iff]\n  intro _ h\n  rw [← Algebra.smul_def]\n  exact Submodule.smul_mem _ _ h\n\n"}
{"name":"FractionalIdeal.isNoetherian_zero","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝² : CommRing R₁\nK : Type u_4\ninst✝¹ : Field K\ninst✝ : Algebra R₁ K\n⊢ IsNoetherian R₁ (Subtype fun x => Membership.mem (↑0) x)","decl":"theorem isNoetherian_zero : IsNoetherian R₁ (0 : FractionalIdeal R₁⁰ K) :=\n  isNoetherian_submodule.mpr fun I (hI : I ≤ (0 : FractionalIdeal R₁⁰ K)) => by\n    rw [coe_zero, le_bot_iff] at hI\n    rw [hI]\n    exact fg_bot\n\n"}
{"name":"FractionalIdeal.isNoetherian_iff","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝² : CommRing R₁\nK : Type u_4\ninst✝¹ : Field K\ninst✝ : Algebra R₁ K\nI : FractionalIdeal (nonZeroDivisors R₁) K\n⊢ Iff (IsNoetherian R₁ (Subtype fun x => Membership.mem (↑I) x)) (∀ (J : FractionalIdeal (nonZeroDivisors R₁) K), LE.le J I → (↑J).FG)","decl":"theorem isNoetherian_iff {I : FractionalIdeal R₁⁰ K} :\n    IsNoetherian R₁ I ↔ ∀ J ≤ I, (J : Submodule R₁ K).FG :=\n  isNoetherian_submodule.trans ⟨fun h _ hJ => h _ hJ, fun h J hJ => h ⟨J, isFractional_of_le hJ⟩ hJ⟩\n\n"}
{"name":"FractionalIdeal.isNoetherian_coeIdeal","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝³ : CommRing R₁\nK : Type u_4\ninst✝² : Field K\ninst✝¹ : Algebra R₁ K\ninst✝ : IsNoetherianRing R₁\nI : Ideal R₁\n⊢ IsNoetherian R₁ (Subtype fun x => Membership.mem (↑↑I) x)","decl":"theorem isNoetherian_coeIdeal [IsNoetherianRing R₁] (I : Ideal R₁) :\n    IsNoetherian R₁ (I : FractionalIdeal R₁⁰ K) := by\n  rw [isNoetherian_iff]\n  intro J hJ\n  obtain ⟨J, rfl⟩ := le_one_iff_exists_coeIdeal.mp (le_trans hJ coeIdeal_le_one)\n  exact (IsNoetherian.noetherian J).map _\n\n"}
{"name":"FractionalIdeal.isNoetherian_spanSingleton_inv_to_map_mul","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝⁴ : CommRing R₁\nK : Type u_4\ninst✝³ : Field K\ninst✝² : Algebra R₁ K\ninst✝¹ : IsFractionRing R₁ K\ninst✝ : IsDomain R₁\nx : R₁\nI : FractionalIdeal (nonZeroDivisors R₁) K\nhI : IsNoetherian R₁ (Subtype fun x => Membership.mem (↑I) x)\n⊢ IsNoetherian R₁ (Subtype fun x_1 => Membership.mem (↑(HMul.hMul (FractionalIdeal.spanSingleton (nonZeroDivisors R₁) (Inv.inv ((algebraMap R₁ K) x))) I)) x_1)","decl":"theorem isNoetherian_spanSingleton_inv_to_map_mul (x : R₁) {I : FractionalIdeal R₁⁰ K}\n    (hI : IsNoetherian R₁ I) :\n    IsNoetherian R₁ (spanSingleton R₁⁰ (algebraMap R₁ K x)⁻¹ * I : FractionalIdeal R₁⁰ K) := by\n  by_cases hx : x = 0\n  · rw [hx, RingHom.map_zero, inv_zero, spanSingleton_zero, zero_mul]\n    exact isNoetherian_zero\n  have h_gx : algebraMap R₁ K x ≠ 0 :=\n    mt ((injective_iff_map_eq_zero (algebraMap R₁ K)).mp (IsFractionRing.injective _ _) x) hx\n  have h_spanx : spanSingleton R₁⁰ (algebraMap R₁ K x) ≠ 0 := spanSingleton_ne_zero_iff.mpr h_gx\n  rw [isNoetherian_iff] at hI ⊢\n  intro J hJ\n  rw [← div_spanSingleton, le_div_iff_mul_le h_spanx] at hJ\n  obtain ⟨s, hs⟩ := hI _ hJ\n  use s * {(algebraMap R₁ K x)⁻¹}\n  rw [Finset.coe_mul, Finset.coe_singleton, ← span_mul_span, hs, ← coe_spanSingleton R₁⁰, ←\n    coe_mul, mul_assoc, spanSingleton_mul_spanSingleton, mul_inv_cancel₀ h_gx, spanSingleton_one,\n    mul_one]\n\n"}
{"name":"FractionalIdeal.isNoetherian","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R₁ : Type u_3\ninst✝⁵ : CommRing R₁\nK : Type u_4\ninst✝⁴ : Field K\ninst✝³ : Algebra R₁ K\ninst✝² : IsFractionRing R₁ K\ninst✝¹ : IsDomain R₁\ninst✝ : IsNoetherianRing R₁\nI : FractionalIdeal (nonZeroDivisors R₁) K\n⊢ IsNoetherian R₁ (Subtype fun x => Membership.mem (↑I) x)","decl":"/-- Every fractional ideal of a noetherian integral domain is noetherian. -/\ntheorem isNoetherian [IsNoetherianRing R₁] (I : FractionalIdeal R₁⁰ K) : IsNoetherian R₁ I := by\n  obtain ⟨d, J, _, rfl⟩ := exists_eq_spanSingleton_mul I\n  apply isNoetherian_spanSingleton_inv_to_map_mul\n  apply isNoetherian_coeIdeal\n\n"}
{"name":"FractionalIdeal.isFractional_adjoin_integral","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nx : P\nhx : IsIntegral R x\n⊢ IsFractional S (Subalgebra.toSubmodule (Algebra.adjoin R (Singleton.singleton x)))","decl":"/-- `A[x]` is a fractional ideal for every integral `x`. -/\ntheorem isFractional_adjoin_integral (hx : IsIntegral R x) :\n    IsFractional S (Subalgebra.toSubmodule (Algebra.adjoin R ({x} : Set P))) :=\n  isFractional_of_fg hx.fg_adjoin_singleton\n\n"}
{"name":"FractionalIdeal.adjoinIntegral_coe","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nx : P\nhx : IsIntegral R x\n⊢ Eq (↑(FractionalIdeal.adjoinIntegral S x hx)) (Subalgebra.toSubmodule (Algebra.adjoin R (Singleton.singleton x)))","decl":"@[simp]\ntheorem adjoinIntegral_coe (hx : IsIntegral R x) :\n    (adjoinIntegral S x hx : Submodule R P) =\n      (Subalgebra.toSubmodule (Algebra.adjoin R ({x} : Set P))) :=\n  rfl\n\n"}
{"name":"FractionalIdeal.mem_adjoinIntegral_self","module":"Mathlib.RingTheory.FractionalIdeal.Operations","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nx : P\nhx : IsIntegral R x\n⊢ Membership.mem (FractionalIdeal.adjoinIntegral S x hx) x","decl":"theorem mem_adjoinIntegral_self (hx : IsIntegral R x) : x ∈ adjoinIntegral S x hx :=\n  Algebra.subset_adjoin (Set.mem_singleton x)\n\n"}
