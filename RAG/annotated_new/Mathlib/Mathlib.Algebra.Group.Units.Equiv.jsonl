{"name":"val_toUnits_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : Group G\nx : G\n⊢ Eq (↑(toUnits x)) x","decl":"/-- A group is isomorphic to its group of units. -/\n@[to_additive (attr := simps apply_val symm_apply)\n\"An additive group is isomorphic to its group of additive units\"]\ndef toUnits [Group G] : G ≃* Gˣ where\n  toFun x := ⟨x, x⁻¹, mul_inv_cancel _, inv_mul_cancel _⟩\n  invFun x := x\n  left_inv _ := rfl\n  right_inv _ := Units.ext rfl\n  map_mul' _ _ := Units.ext rfl\n\n"}
{"name":"val_toAddUnits_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : AddGroup G\nx : G\n⊢ Eq (↑(toAddUnits x)) x","decl":"/-- A group is isomorphic to its group of units. -/\n@[to_additive (attr := simps apply_val symm_apply)\n\"An additive group is isomorphic to its group of additive units\"]\ndef toUnits [Group G] : G ≃* Gˣ where\n  toFun x := ⟨x, x⁻¹, mul_inv_cancel _, inv_mul_cancel _⟩\n  invFun x := x\n  left_inv _ := rfl\n  right_inv _ := Units.ext rfl\n  map_mul' _ _ := Units.ext rfl\n\n"}
{"name":"toAddUnits_symm_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : AddGroup G\nx : AddUnits G\n⊢ Eq (toAddUnits.symm x) ↑x","decl":"/-- A group is isomorphic to its group of units. -/\n@[to_additive (attr := simps apply_val symm_apply)\n\"An additive group is isomorphic to its group of additive units\"]\ndef toUnits [Group G] : G ≃* Gˣ where\n  toFun x := ⟨x, x⁻¹, mul_inv_cancel _, inv_mul_cancel _⟩\n  invFun x := x\n  left_inv _ := rfl\n  right_inv _ := Units.ext rfl\n  map_mul' _ _ := Units.ext rfl\n\n"}
{"name":"toUnits_symm_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : Group G\nx : Units G\n⊢ Eq (toUnits.symm x) ↑x","decl":"/-- A group is isomorphic to its group of units. -/\n@[to_additive (attr := simps apply_val symm_apply)\n\"An additive group is isomorphic to its group of additive units\"]\ndef toUnits [Group G] : G ≃* Gˣ where\n  toFun x := ⟨x, x⁻¹, mul_inv_cancel _, inv_mul_cancel _⟩\n  invFun x := x\n  left_inv _ := rfl\n  right_inv _ := Units.ext rfl\n  map_mul' _ _ := Units.ext rfl\n\n"}
{"name":"toUnits_val_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_6\ninst✝ : Group G\nx : Units G\n⊢ Eq (toUnits ↑x) x","decl":"@[to_additive (attr := simp)]\nlemma toUnits_val_apply {G : Type*} [Group G] (x : Gˣ) : toUnits (x : G) = x := by\n  simp_rw [MulEquiv.apply_eq_iff_symm_apply, toUnits_symm_apply]\n\n"}
{"name":"toAddUnits_val_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\nx : AddUnits G\n⊢ Eq (toAddUnits ↑x) x","decl":"@[to_additive (attr := simp)]\nlemma toUnits_val_apply {G : Type*} [Group G] (x : Gˣ) : toUnits (x : G) = x := by\n  simp_rw [MulEquiv.apply_eq_iff_symm_apply, toUnits_symm_apply]\n\n"}
{"name":"Units.mapEquiv_symm","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nh : MulEquiv M N\n⊢ Eq (Units.mapEquiv h).symm (Units.mapEquiv h.symm)","decl":"@[simp]\ntheorem mapEquiv_symm (h : M ≃* N) : (mapEquiv h).symm = mapEquiv h.symm :=\n  rfl\n\n"}
{"name":"Units.coe_mapEquiv","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nh : MulEquiv M N\nx : Units M\n⊢ Eq (↑((Units.mapEquiv h) x)) (h ↑x)","decl":"@[simp]\ntheorem coe_mapEquiv (h : M ≃* N) (x : Mˣ) : (mapEquiv h x : N) = h x :=\n  rfl\n\n"}
{"name":"AddUnits.addLeft_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"M : Type u_3\ninst✝ : AddMonoid M\nu : AddUnits M\n⊢ Eq ⇑u.addLeft fun x => HAdd.hAdd (↑u) x","decl":"/-- Left multiplication by a unit of a monoid is a permutation of the underlying type. -/\n@[to_additive (attr := simps (config := .asFn) apply)\n  \"Left addition of an additive unit is a permutation of the underlying type.\"]\ndef mulLeft (u : Mˣ) : Equiv.Perm M where\n  toFun x := u * x\n  invFun x := u⁻¹ * x\n  left_inv := u.inv_mul_cancel_left\n  right_inv := u.mul_inv_cancel_left\n\n"}
{"name":"Units.mulLeft_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"M : Type u_3\ninst✝ : Monoid M\nu : Units M\n⊢ Eq ⇑u.mulLeft fun x => HMul.hMul (↑u) x","decl":"/-- Left multiplication by a unit of a monoid is a permutation of the underlying type. -/\n@[to_additive (attr := simps (config := .asFn) apply)\n  \"Left addition of an additive unit is a permutation of the underlying type.\"]\ndef mulLeft (u : Mˣ) : Equiv.Perm M where\n  toFun x := u * x\n  invFun x := u⁻¹ * x\n  left_inv := u.inv_mul_cancel_left\n  right_inv := u.mul_inv_cancel_left\n\n"}
{"name":"Units.mulLeft_symm","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"M : Type u_3\ninst✝ : Monoid M\nu : Units M\n⊢ Eq (Equiv.symm u.mulLeft) (Inv.inv u).mulLeft","decl":"@[to_additive (attr := simp)]\ntheorem mulLeft_symm (u : Mˣ) : u.mulLeft.symm = u⁻¹.mulLeft :=\n  Equiv.ext fun _ => rfl\n\n"}
{"name":"AddUnits.addLeft_symm","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"M : Type u_3\ninst✝ : AddMonoid M\nu : AddUnits M\n⊢ Eq (Equiv.symm u.addLeft) (Neg.neg u).addLeft","decl":"@[to_additive (attr := simp)]\ntheorem mulLeft_symm (u : Mˣ) : u.mulLeft.symm = u⁻¹.mulLeft :=\n  Equiv.ext fun _ => rfl\n\n"}
{"name":"AddUnits.addLeft_bijective","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"M : Type u_3\ninst✝ : AddMonoid M\na : AddUnits M\n⊢ Function.Bijective fun x => HAdd.hAdd (↑a) x","decl":"@[to_additive]\ntheorem mulLeft_bijective (a : Mˣ) : Function.Bijective ((a * ·) : M → M) :=\n  (mulLeft a).bijective\n\n"}
{"name":"Units.mulLeft_bijective","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"M : Type u_3\ninst✝ : Monoid M\na : Units M\n⊢ Function.Bijective fun x => HMul.hMul (↑a) x","decl":"@[to_additive]\ntheorem mulLeft_bijective (a : Mˣ) : Function.Bijective ((a * ·) : M → M) :=\n  (mulLeft a).bijective\n\n"}
{"name":"AddUnits.addRight_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"M : Type u_3\ninst✝ : AddMonoid M\nu : AddUnits M\n⊢ Eq ⇑u.addRight fun x => HAdd.hAdd x ↑u","decl":"/-- Right multiplication by a unit of a monoid is a permutation of the underlying type. -/\n@[to_additive (attr := simps (config := .asFn) apply)\n\"Right addition of an additive unit is a permutation of the underlying type.\"]\ndef mulRight (u : Mˣ) : Equiv.Perm M where\n  toFun x := x * u\n  invFun x := x * ↑u⁻¹\n  left_inv x := mul_inv_cancel_right x u\n  right_inv x := inv_mul_cancel_right x u\n\n"}
{"name":"Units.mulRight_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"M : Type u_3\ninst✝ : Monoid M\nu : Units M\n⊢ Eq ⇑u.mulRight fun x => HMul.hMul x ↑u","decl":"/-- Right multiplication by a unit of a monoid is a permutation of the underlying type. -/\n@[to_additive (attr := simps (config := .asFn) apply)\n\"Right addition of an additive unit is a permutation of the underlying type.\"]\ndef mulRight (u : Mˣ) : Equiv.Perm M where\n  toFun x := x * u\n  invFun x := x * ↑u⁻¹\n  left_inv x := mul_inv_cancel_right x u\n  right_inv x := inv_mul_cancel_right x u\n\n"}
{"name":"Units.mulRight_symm","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"M : Type u_3\ninst✝ : Monoid M\nu : Units M\n⊢ Eq (Equiv.symm u.mulRight) (Inv.inv u).mulRight","decl":"@[to_additive (attr := simp)]\ntheorem mulRight_symm (u : Mˣ) : u.mulRight.symm = u⁻¹.mulRight :=\n  Equiv.ext fun _ => rfl\n\n"}
{"name":"AddUnits.addRight_symm","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"M : Type u_3\ninst✝ : AddMonoid M\nu : AddUnits M\n⊢ Eq (Equiv.symm u.addRight) (Neg.neg u).addRight","decl":"@[to_additive (attr := simp)]\ntheorem mulRight_symm (u : Mˣ) : u.mulRight.symm = u⁻¹.mulRight :=\n  Equiv.ext fun _ => rfl\n\n"}
{"name":"Units.mulRight_bijective","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"M : Type u_3\ninst✝ : Monoid M\na : Units M\n⊢ Function.Bijective fun x => HMul.hMul x ↑a","decl":"@[to_additive]\ntheorem mulRight_bijective (a : Mˣ) : Function.Bijective ((· * a) : M → M) :=\n  (mulRight a).bijective\n\n"}
{"name":"AddUnits.addRight_bijective","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"M : Type u_3\ninst✝ : AddMonoid M\na : AddUnits M\n⊢ Function.Bijective fun x => HAdd.hAdd x ↑a","decl":"@[to_additive]\ntheorem mulRight_bijective (a : Mˣ) : Function.Bijective ((· * a) : M → M) :=\n  (mulRight a).bijective\n\n"}
{"name":"Equiv.coe_addLeft","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : AddGroup G\na : G\n⊢ Eq ⇑(Equiv.addLeft a) fun x => HAdd.hAdd a x","decl":"@[to_additive (attr := simp)]\ntheorem coe_mulLeft (a : G) : ⇑(Equiv.mulLeft a) = (a * ·) :=\n  rfl\n\n"}
{"name":"Equiv.coe_mulLeft","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : Group G\na : G\n⊢ Eq ⇑(Equiv.mulLeft a) fun x => HMul.hMul a x","decl":"@[to_additive (attr := simp)]\ntheorem coe_mulLeft (a : G) : ⇑(Equiv.mulLeft a) = (a * ·) :=\n  rfl\n\n"}
{"name":"Equiv.mulLeft_symm_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : Group G\na : G\n⊢ Eq ⇑(Equiv.symm (Equiv.mulLeft a)) fun x => HMul.hMul (Inv.inv a) x","decl":"/-- Extra simp lemma that `dsimp` can use. `simp` will never use this. -/\n@[to_additive (attr := simp) \"Extra simp lemma that `dsimp` can use. `simp` will never use this.\"]\ntheorem mulLeft_symm_apply (a : G) : ((Equiv.mulLeft a).symm : G → G) = (a⁻¹ * ·) :=\n  rfl\n\n"}
{"name":"Equiv.addLeft_symm_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : AddGroup G\na : G\n⊢ Eq ⇑(Equiv.symm (Equiv.addLeft a)) fun x => HAdd.hAdd (Neg.neg a) x","decl":"/-- Extra simp lemma that `dsimp` can use. `simp` will never use this. -/\n@[to_additive (attr := simp) \"Extra simp lemma that `dsimp` can use. `simp` will never use this.\"]\ntheorem mulLeft_symm_apply (a : G) : ((Equiv.mulLeft a).symm : G → G) = (a⁻¹ * ·) :=\n  rfl\n\n"}
{"name":"Equiv.mulLeft_symm","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : Group G\na : G\n⊢ Eq (Equiv.symm (Equiv.mulLeft a)) (Equiv.mulLeft (Inv.inv a))","decl":"@[to_additive (attr := simp)]\ntheorem mulLeft_symm (a : G) : (Equiv.mulLeft a).symm = Equiv.mulLeft a⁻¹ :=\n  ext fun _ => rfl\n\n"}
{"name":"Equiv.addLeft_symm","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : AddGroup G\na : G\n⊢ Eq (Equiv.symm (Equiv.addLeft a)) (Equiv.addLeft (Neg.neg a))","decl":"@[to_additive (attr := simp)]\ntheorem mulLeft_symm (a : G) : (Equiv.mulLeft a).symm = Equiv.mulLeft a⁻¹ :=\n  ext fun _ => rfl\n\n"}
{"name":"AddGroup.addLeft_bijective","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : AddGroup G\na : G\n⊢ Function.Bijective fun x => HAdd.hAdd a x","decl":"@[to_additive]\ntheorem _root_.Group.mulLeft_bijective (a : G) : Function.Bijective (a * ·) :=\n  (Equiv.mulLeft a).bijective\n\n"}
{"name":"Group.mulLeft_bijective","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : Group G\na : G\n⊢ Function.Bijective fun x => HMul.hMul a x","decl":"@[to_additive]\ntheorem _root_.Group.mulLeft_bijective (a : G) : Function.Bijective (a * ·) :=\n  (Equiv.mulLeft a).bijective\n\n"}
{"name":"Equiv.coe_mulRight","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : Group G\na : G\n⊢ Eq ⇑(Equiv.mulRight a) fun x => HMul.hMul x a","decl":"@[to_additive (attr := simp)]\ntheorem coe_mulRight (a : G) : ⇑(Equiv.mulRight a) = fun x => x * a :=\n  rfl\n\n"}
{"name":"Equiv.coe_addRight","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : AddGroup G\na : G\n⊢ Eq ⇑(Equiv.addRight a) fun x => HAdd.hAdd x a","decl":"@[to_additive (attr := simp)]\ntheorem coe_mulRight (a : G) : ⇑(Equiv.mulRight a) = fun x => x * a :=\n  rfl\n\n"}
{"name":"Equiv.mulRight_symm","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : Group G\na : G\n⊢ Eq (Equiv.symm (Equiv.mulRight a)) (Equiv.mulRight (Inv.inv a))","decl":"@[to_additive (attr := simp)]\ntheorem mulRight_symm (a : G) : (Equiv.mulRight a).symm = Equiv.mulRight a⁻¹ :=\n  ext fun _ => rfl\n\n"}
{"name":"Equiv.addRight_symm","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : AddGroup G\na : G\n⊢ Eq (Equiv.symm (Equiv.addRight a)) (Equiv.addRight (Neg.neg a))","decl":"@[to_additive (attr := simp)]\ntheorem mulRight_symm (a : G) : (Equiv.mulRight a).symm = Equiv.mulRight a⁻¹ :=\n  ext fun _ => rfl\n\n"}
{"name":"Equiv.addRight_symm_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : AddGroup G\na : G\n⊢ Eq ⇑(Equiv.symm (Equiv.addRight a)) fun x => HAdd.hAdd x (Neg.neg a)","decl":"/-- Extra simp lemma that `dsimp` can use. `simp` will never use this. -/\n@[to_additive (attr := simp) \"Extra simp lemma that `dsimp` can use. `simp` will never use this.\"]\ntheorem mulRight_symm_apply (a : G) : ((Equiv.mulRight a).symm : G → G) = fun x => x * a⁻¹ :=\n  rfl\n\n"}
{"name":"Equiv.mulRight_symm_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : Group G\na : G\n⊢ Eq ⇑(Equiv.symm (Equiv.mulRight a)) fun x => HMul.hMul x (Inv.inv a)","decl":"/-- Extra simp lemma that `dsimp` can use. `simp` will never use this. -/\n@[to_additive (attr := simp) \"Extra simp lemma that `dsimp` can use. `simp` will never use this.\"]\ntheorem mulRight_symm_apply (a : G) : ((Equiv.mulRight a).symm : G → G) = fun x => x * a⁻¹ :=\n  rfl\n\n"}
{"name":"Group.mulRight_bijective","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : Group G\na : G\n⊢ Function.Bijective fun x => HMul.hMul x a","decl":"@[to_additive]\ntheorem _root_.Group.mulRight_bijective (a : G) : Function.Bijective (· * a) :=\n  (Equiv.mulRight a).bijective\n\n"}
{"name":"AddGroup.addRight_bijective","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : AddGroup G\na : G\n⊢ Function.Bijective fun x => HAdd.hAdd x a","decl":"@[to_additive]\ntheorem _root_.Group.mulRight_bijective (a : G) : Function.Bijective (· * a) :=\n  (Equiv.mulRight a).bijective\n\n"}
{"name":"Equiv.divLeft_symm_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : Group G\na b : G\n⊢ Eq ((Equiv.divLeft a).symm b) (HMul.hMul (Inv.inv b) a)","decl":"/-- A version of `Equiv.mulLeft a b⁻¹` that is defeq to `a / b`. -/\n@[to_additive (attr := simps) \" A version of `Equiv.addLeft a (-b)` that is defeq to `a - b`. \"]\nprotected def divLeft (a : G) : G ≃ G where\n  toFun b := a / b\n  invFun b := b⁻¹ * a\n  left_inv b := by simp [div_eq_mul_inv]\n  right_inv b := by simp [div_eq_mul_inv]\n\n"}
{"name":"Equiv.divLeft_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : Group G\na b : G\n⊢ Eq ((Equiv.divLeft a) b) (HDiv.hDiv a b)","decl":"/-- A version of `Equiv.mulLeft a b⁻¹` that is defeq to `a / b`. -/\n@[to_additive (attr := simps) \" A version of `Equiv.addLeft a (-b)` that is defeq to `a - b`. \"]\nprotected def divLeft (a : G) : G ≃ G where\n  toFun b := a / b\n  invFun b := b⁻¹ * a\n  left_inv b := by simp [div_eq_mul_inv]\n  right_inv b := by simp [div_eq_mul_inv]\n\n"}
{"name":"Equiv.subLeft_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : AddGroup G\na b : G\n⊢ Eq ((Equiv.subLeft a) b) (HSub.hSub a b)","decl":"/-- A version of `Equiv.mulLeft a b⁻¹` that is defeq to `a / b`. -/\n@[to_additive (attr := simps) \" A version of `Equiv.addLeft a (-b)` that is defeq to `a - b`. \"]\nprotected def divLeft (a : G) : G ≃ G where\n  toFun b := a / b\n  invFun b := b⁻¹ * a\n  left_inv b := by simp [div_eq_mul_inv]\n  right_inv b := by simp [div_eq_mul_inv]\n\n"}
{"name":"Equiv.subLeft_symm_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : AddGroup G\na b : G\n⊢ Eq ((Equiv.subLeft a).symm b) (HAdd.hAdd (Neg.neg b) a)","decl":"/-- A version of `Equiv.mulLeft a b⁻¹` that is defeq to `a / b`. -/\n@[to_additive (attr := simps) \" A version of `Equiv.addLeft a (-b)` that is defeq to `a - b`. \"]\nprotected def divLeft (a : G) : G ≃ G where\n  toFun b := a / b\n  invFun b := b⁻¹ * a\n  left_inv b := by simp [div_eq_mul_inv]\n  right_inv b := by simp [div_eq_mul_inv]\n\n"}
{"name":"Equiv.divLeft_eq_inv_trans_mulLeft","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : Group G\na : G\n⊢ Eq (Equiv.divLeft a) (Equiv.trans (Equiv.inv G) (Equiv.mulLeft a))","decl":"@[to_additive]\ntheorem divLeft_eq_inv_trans_mulLeft (a : G) :\n    Equiv.divLeft a = (Equiv.inv G).trans (Equiv.mulLeft a) :=\n  ext fun _ => div_eq_mul_inv _ _\n\n"}
{"name":"Equiv.subLeft_eq_neg_trans_addLeft","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : AddGroup G\na : G\n⊢ Eq (Equiv.subLeft a) (Equiv.trans (Equiv.neg G) (Equiv.addLeft a))","decl":"@[to_additive]\ntheorem divLeft_eq_inv_trans_mulLeft (a : G) :\n    Equiv.divLeft a = (Equiv.inv G).trans (Equiv.mulLeft a) :=\n  ext fun _ => div_eq_mul_inv _ _\n\n"}
{"name":"Equiv.subRight_symm_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : AddGroup G\na b : G\n⊢ Eq ((Equiv.subRight a).symm b) (HAdd.hAdd b a)","decl":"/-- A version of `Equiv.mulRight a⁻¹ b` that is defeq to `b / a`. -/\n@[to_additive (attr := simps) \" A version of `Equiv.addRight (-a) b` that is defeq to `b - a`. \"]\nprotected def divRight (a : G) : G ≃ G where\n  toFun b := b / a\n  invFun b := b * a\n  left_inv b := by simp [div_eq_mul_inv]\n  right_inv b := by simp [div_eq_mul_inv]\n\n"}
{"name":"Equiv.divRight_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : Group G\na b : G\n⊢ Eq ((Equiv.divRight a) b) (HDiv.hDiv b a)","decl":"/-- A version of `Equiv.mulRight a⁻¹ b` that is defeq to `b / a`. -/\n@[to_additive (attr := simps) \" A version of `Equiv.addRight (-a) b` that is defeq to `b - a`. \"]\nprotected def divRight (a : G) : G ≃ G where\n  toFun b := b / a\n  invFun b := b * a\n  left_inv b := by simp [div_eq_mul_inv]\n  right_inv b := by simp [div_eq_mul_inv]\n\n"}
{"name":"Equiv.subRight_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : AddGroup G\na b : G\n⊢ Eq ((Equiv.subRight a) b) (HSub.hSub b a)","decl":"/-- A version of `Equiv.mulRight a⁻¹ b` that is defeq to `b / a`. -/\n@[to_additive (attr := simps) \" A version of `Equiv.addRight (-a) b` that is defeq to `b - a`. \"]\nprotected def divRight (a : G) : G ≃ G where\n  toFun b := b / a\n  invFun b := b * a\n  left_inv b := by simp [div_eq_mul_inv]\n  right_inv b := by simp [div_eq_mul_inv]\n\n"}
{"name":"Equiv.divRight_symm_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : Group G\na b : G\n⊢ Eq ((Equiv.divRight a).symm b) (HMul.hMul b a)","decl":"/-- A version of `Equiv.mulRight a⁻¹ b` that is defeq to `b / a`. -/\n@[to_additive (attr := simps) \" A version of `Equiv.addRight (-a) b` that is defeq to `b - a`. \"]\nprotected def divRight (a : G) : G ≃ G where\n  toFun b := b / a\n  invFun b := b * a\n  left_inv b := by simp [div_eq_mul_inv]\n  right_inv b := by simp [div_eq_mul_inv]\n\n"}
{"name":"Equiv.divRight_eq_mulRight_inv","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : Group G\na : G\n⊢ Eq (Equiv.divRight a) (Equiv.mulRight (Inv.inv a))","decl":"@[to_additive]\ntheorem divRight_eq_mulRight_inv (a : G) : Equiv.divRight a = Equiv.mulRight a⁻¹ :=\n  ext fun _ => div_eq_mul_inv _ _\n\n"}
{"name":"Equiv.subRight_eq_addRight_neg","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_5\ninst✝ : AddGroup G\na : G\n⊢ Eq (Equiv.subRight a) (Equiv.addRight (Neg.neg a))","decl":"@[to_additive]\ntheorem divRight_eq_mulRight_inv (a : G) : Equiv.divRight a = Equiv.mulRight a⁻¹ :=\n  ext fun _ => div_eq_mul_inv _ _\n\n"}
{"name":"val_inv_unitsEquivProdSubtype_symm_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"α : Type u_2\ninst✝ : Monoid α\np : Subtype fun p => And (Eq (HMul.hMul p.1 p.2) 1) (Eq (HMul.hMul p.2 p.1) 1)\n⊢ Eq (↑(Inv.inv ((unitsEquivProdSubtype α).symm p))) (↑p).2","decl":"variable (α) in\n/-- The `αˣ` type is equivalent to a subtype of `α × α`. -/\n@[simps]\ndef unitsEquivProdSubtype [Monoid α] : αˣ ≃ {p : α × α // p.1 * p.2 = 1 ∧ p.2 * p.1 = 1} where\n  toFun u := ⟨(u, ↑u⁻¹), u.val_inv, u.inv_val⟩\n  invFun p := Units.mk (p : α × α).1 (p : α × α).2 p.prop.1 p.prop.2\n  left_inv _ := Units.ext rfl\n  right_inv _ := Subtype.ext <| Prod.ext rfl rfl\n\n"}
{"name":"val_unitsEquivProdSubtype_symm_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"α : Type u_2\ninst✝ : Monoid α\np : Subtype fun p => And (Eq (HMul.hMul p.1 p.2) 1) (Eq (HMul.hMul p.2 p.1) 1)\n⊢ Eq (↑((unitsEquivProdSubtype α).symm p)) (↑p).1","decl":"variable (α) in\n/-- The `αˣ` type is equivalent to a subtype of `α × α`. -/\n@[simps]\ndef unitsEquivProdSubtype [Monoid α] : αˣ ≃ {p : α × α // p.1 * p.2 = 1 ∧ p.2 * p.1 = 1} where\n  toFun u := ⟨(u, ↑u⁻¹), u.val_inv, u.inv_val⟩\n  invFun p := Units.mk (p : α × α).1 (p : α × α).2 p.prop.1 p.prop.2\n  left_inv _ := Units.ext rfl\n  right_inv _ := Subtype.ext <| Prod.ext rfl rfl\n\n"}
{"name":"unitsEquivProdSubtype_apply_coe","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"α : Type u_2\ninst✝ : Monoid α\nu : Units α\n⊢ Eq ↑((unitsEquivProdSubtype α) u) { fst := ↑u, snd := ↑(Inv.inv u) }","decl":"variable (α) in\n/-- The `αˣ` type is equivalent to a subtype of `α × α`. -/\n@[simps]\ndef unitsEquivProdSubtype [Monoid α] : αˣ ≃ {p : α × α // p.1 * p.2 = 1 ∧ p.2 * p.1 = 1} where\n  toFun u := ⟨(u, ↑u⁻¹), u.val_inv, u.inv_val⟩\n  invFun p := Units.mk (p : α × α).1 (p : α × α).2 p.prop.1 p.prop.2\n  left_inv _ := Units.ext rfl\n  right_inv _ := Subtype.ext <| Prod.ext rfl rfl\n\n"}
{"name":"AddEquiv.neg_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_6\ninst✝ : SubtractionCommMonoid G\na✝ : G\n⊢ Eq ((AddEquiv.neg G) a✝) (Neg.neg a✝)","decl":"/-- In a `DivisionCommMonoid`, `Equiv.inv` is a `MulEquiv`. There is a variant of this\n`MulEquiv.inv' G : G ≃* Gᵐᵒᵖ` for the non-commutative case. -/\n@[to_additive (attr := simps apply)\n  \"When the `AddGroup` is commutative, `Equiv.neg` is an `AddEquiv`.\"]\ndef MulEquiv.inv (G : Type*) [DivisionCommMonoid G] : G ≃* G :=\n  { Equiv.inv G with toFun := Inv.inv, invFun := Inv.inv, map_mul' := mul_inv }\n\n"}
{"name":"MulEquiv.inv_apply","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_6\ninst✝ : DivisionCommMonoid G\na✝ : G\n⊢ Eq ((MulEquiv.inv G) a✝) (Inv.inv a✝)","decl":"/-- In a `DivisionCommMonoid`, `Equiv.inv` is a `MulEquiv`. There is a variant of this\n`MulEquiv.inv' G : G ≃* Gᵐᵒᵖ` for the non-commutative case. -/\n@[to_additive (attr := simps apply)\n  \"When the `AddGroup` is commutative, `Equiv.neg` is an `AddEquiv`.\"]\ndef MulEquiv.inv (G : Type*) [DivisionCommMonoid G] : G ≃* G :=\n  { Equiv.inv G with toFun := Inv.inv, invFun := Inv.inv, map_mul' := mul_inv }\n\n"}
{"name":"AddEquiv.neg_symm","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_6\ninst✝ : SubtractionCommMonoid G\n⊢ Eq (AddEquiv.neg G).symm (AddEquiv.neg G)","decl":"@[to_additive (attr := simp)]\ntheorem MulEquiv.inv_symm (G : Type*) [DivisionCommMonoid G] :\n    (MulEquiv.inv G).symm = MulEquiv.inv G :=\n  rfl\n\n"}
{"name":"MulEquiv.inv_symm","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"G : Type u_6\ninst✝ : DivisionCommMonoid G\n⊢ Eq (MulEquiv.inv G).symm (MulEquiv.inv G)","decl":"@[to_additive (attr := simp)]\ntheorem MulEquiv.inv_symm (G : Type*) [DivisionCommMonoid G] :\n    (MulEquiv.inv G).symm = MulEquiv.inv G :=\n  rfl\n\n"}
{"name":"isLocalHom_equiv","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"F : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝³ : Monoid M\ninst✝² : Monoid N\ninst✝¹ : EquivLike F M N\ninst✝ : MulEquivClass F M N\nf : F\n⊢ IsLocalHom f","decl":"@[instance]\ntheorem isLocalHom_equiv [Monoid M] [Monoid N] [EquivLike F M N]\n    [MulEquivClass F M N] (f : F) : IsLocalHom f where\n  map_nonunit a ha := by\n    convert ha.map (f : M ≃* N).symm\n    rw [MulEquiv.eq_symm_apply]\n    rfl -- note to reviewers: ugly `rfl`\n\n"}
{"name":"isLocalRingHom_equiv","module":"Mathlib.Algebra.Group.Units.Equiv","initialProofState":"F : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝³ : Monoid M\ninst✝² : Monoid N\ninst✝¹ : EquivLike F M N\ninst✝ : MulEquivClass F M N\nf : F\n⊢ IsLocalHom f","decl":"@[deprecated (since := \"2024-10-10\")]\nalias isLocalRingHom_equiv := isLocalHom_equiv\n"}
