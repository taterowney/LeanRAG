{"name":"Rat.pos","module":"Mathlib.Data.Rat.Defs","initialProofState":"a : Rat\n⊢ LT.lt 0 a.den","decl":"theorem pos (a : ℚ) : 0 < a.den := Nat.pos_of_ne_zero a.den_nz\n\n"}
{"name":"Rat.mk'_num_den","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\n⊢ Eq { num := q.num, den := q.den, den_nz := ⋯, reduced := ⋯ } q","decl":"lemma mk'_num_den (q : ℚ) : mk' q.num q.den q.den_nz q.reduced = q := rfl\n\n"}
{"name":"Rat.ofInt_eq_cast","module":"Mathlib.Data.Rat.Defs","initialProofState":"n : Int\n⊢ Eq (Rat.ofInt n) ↑n","decl":"@[simp]\ntheorem ofInt_eq_cast (n : ℤ) : ofInt n = Int.cast n :=\n  rfl\n\n-- TODO: Replace `Rat.ofNat_num`/`Rat.ofNat_den` in Batteries\n"}
{"name":"Rat.num_ofNat","module":"Mathlib.Data.Rat.Defs","initialProofState":"n : Nat\n⊢ Eq (OfNat.ofNat n).num (OfNat.ofNat n)","decl":"@[simp] lemma num_ofNat (n : ℕ) : num ofNat(n) = ofNat(n) := rfl\n"}
{"name":"Rat.den_ofNat","module":"Mathlib.Data.Rat.Defs","initialProofState":"n : Nat\n⊢ Eq (OfNat.ofNat n).den 1","decl":"@[simp] lemma den_ofNat (n : ℕ) : den ofNat(n) = 1 := rfl\n\n"}
{"name":"Rat.num_natCast","module":"Mathlib.Data.Rat.Defs","initialProofState":"n : Nat\n⊢ Eq (↑n).num ↑n","decl":"@[simp, norm_cast] lemma num_natCast (n : ℕ) : num n = n := rfl\n\n"}
{"name":"Rat.den_natCast","module":"Mathlib.Data.Rat.Defs","initialProofState":"n : Nat\n⊢ Eq (↑n).den 1","decl":"@[simp, norm_cast] lemma den_natCast (n : ℕ) : den n = 1 := rfl\n\n-- TODO: Replace `intCast_num`/`intCast_den` the names in Batteries\n"}
{"name":"Rat.num_intCast","module":"Mathlib.Data.Rat.Defs","initialProofState":"n : Int\n⊢ Eq (↑n).num n","decl":"@[simp, norm_cast] lemma num_intCast (n : ℤ) : (n : ℚ).num = n := rfl\n\n"}
{"name":"Rat.den_intCast","module":"Mathlib.Data.Rat.Defs","initialProofState":"n : Int\n⊢ Eq (↑n).den 1","decl":"@[simp, norm_cast] lemma den_intCast (n : ℤ) : (n : ℚ).den = 1 := rfl\n\n"}
{"name":"Rat.intCast_injective","module":"Mathlib.Data.Rat.Defs","initialProofState":"⊢ Function.Injective Int.cast","decl":"lemma intCast_injective : Injective (Int.cast : ℤ → ℚ) := fun _ _ ↦ congr_arg num\n"}
{"name":"Rat.natCast_injective","module":"Mathlib.Data.Rat.Defs","initialProofState":"⊢ Function.Injective Nat.cast","decl":"lemma natCast_injective : Injective (Nat.cast : ℕ → ℚ) :=\n  intCast_injective.comp fun _ _ ↦ Int.natCast_inj.1\n\n-- We want to use these lemmas earlier than the lemmas simp can prove them with\n"}
{"name":"Rat.natCast_inj","module":"Mathlib.Data.Rat.Defs","initialProofState":"m n : Nat\n⊢ Iff (Eq ↑m ↑n) (Eq m n)","decl":"@[simp, nolint simpNF, norm_cast] lemma natCast_inj {m n : ℕ} : (m : ℚ) = n ↔ m = n :=\n  natCast_injective.eq_iff\n"}
{"name":"Rat.intCast_eq_zero","module":"Mathlib.Data.Rat.Defs","initialProofState":"n : Int\n⊢ Iff (Eq (↑n) 0) (Eq n 0)","decl":"@[simp, nolint simpNF, norm_cast] lemma intCast_eq_zero {n : ℤ} : (n : ℚ) = 0 ↔ n = 0 := intCast_inj\n"}
{"name":"Rat.natCast_eq_zero","module":"Mathlib.Data.Rat.Defs","initialProofState":"n : Nat\n⊢ Iff (Eq (↑n) 0) (Eq n 0)","decl":"@[simp, nolint simpNF, norm_cast] lemma natCast_eq_zero {n : ℕ} : (n : ℚ) = 0 ↔ n = 0 := natCast_inj\n"}
{"name":"Rat.intCast_eq_one","module":"Mathlib.Data.Rat.Defs","initialProofState":"n : Int\n⊢ Iff (Eq (↑n) 1) (Eq n 1)","decl":"@[simp, nolint simpNF, norm_cast] lemma intCast_eq_one {n : ℤ} : (n : ℚ) = 1 ↔ n = 1 := intCast_inj\n"}
{"name":"Rat.natCast_eq_one","module":"Mathlib.Data.Rat.Defs","initialProofState":"n : Nat\n⊢ Iff (Eq (↑n) 1) (Eq n 1)","decl":"@[simp, nolint simpNF, norm_cast] lemma natCast_eq_one {n : ℕ} : (n : ℚ) = 1 ↔ n = 1 := natCast_inj\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO Should this be namespaced?\n\n"}
{"name":"Rat.mkRat_eq_divInt","module":"Mathlib.Data.Rat.Defs","initialProofState":"n : Int\nd : Nat\n⊢ Eq (mkRat n d) (Rat.divInt n ↑d)","decl":"lemma mkRat_eq_divInt (n d) : mkRat n d = n /. d := rfl\n\n"}
{"name":"Rat.mk'_zero","module":"Mathlib.Data.Rat.Defs","initialProofState":"d : Nat\nh : Ne d 0\nw : (Int.natAbs 0).Coprime d\n⊢ Eq { num := 0, den := d, den_nz := h, reduced := w } 0","decl":"@[simp] lemma mk'_zero (d) (h : d ≠ 0) (w) : mk' 0 d h w = 0 := by congr; simp_all\n\n"}
{"name":"Rat.num_eq_zero","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\n⊢ Iff (Eq q.num 0) (Eq q 0)","decl":"@[simp]\nlemma num_eq_zero {q : ℚ} : q.num = 0 ↔ q = 0 := by\n  induction q\n  constructor\n  · rintro rfl\n    exact mk'_zero _ _ _\n  · exact congr_arg num\n\n"}
{"name":"Rat.num_ne_zero","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\n⊢ Iff (Ne q.num 0) (Ne q 0)","decl":"lemma num_ne_zero {q : ℚ} : q.num ≠ 0 ↔ q ≠ 0 := num_eq_zero.not\n\n"}
{"name":"Rat.den_ne_zero","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\n⊢ Ne q.den 0","decl":"@[simp] lemma den_ne_zero (q : ℚ) : q.den ≠ 0 := q.den_pos.ne'\n\n"}
{"name":"Rat.num_nonneg","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\n⊢ Iff (LE.le 0 q.num) (LE.le 0 q)","decl":"@[simp] lemma num_nonneg : 0 ≤ q.num ↔ 0 ≤ q := by\n  simp [Int.le_iff_lt_or_eq, instLE, Rat.blt, Int.not_lt]; tauto\n\n"}
{"name":"Rat.divInt_eq_zero","module":"Mathlib.Data.Rat.Defs","initialProofState":"a b : Int\nb0 : Ne b 0\n⊢ Iff (Eq (Rat.divInt a b) 0) (Eq a 0)","decl":"@[simp]\ntheorem divInt_eq_zero {a b : ℤ} (b0 : b ≠ 0) : a /. b = 0 ↔ a = 0 := by\n  rw [← zero_divInt b, divInt_eq_iff b0 b0, Int.zero_mul, Int.mul_eq_zero, or_iff_left b0]\n\n"}
{"name":"Rat.divInt_ne_zero","module":"Mathlib.Data.Rat.Defs","initialProofState":"a b : Int\nb0 : Ne b 0\n⊢ Iff (Ne (Rat.divInt a b) 0) (Ne a 0)","decl":"theorem divInt_ne_zero {a b : ℤ} (b0 : b ≠ 0) : a /. b ≠ 0 ↔ a ≠ 0 :=\n  (divInt_eq_zero b0).not\n\n-- Porting note: this can move to Batteries\n"}
{"name":"Rat.normalize_eq_mk'","module":"Mathlib.Data.Rat.Defs","initialProofState":"n : Int\nd : Nat\nh : Ne d 0\nc : Eq (n.natAbs.gcd d) 1\n⊢ Eq (Rat.normalize n d h) { num := n, den := d, den_nz := h, reduced := c }","decl":"theorem normalize_eq_mk' (n : Int) (d : Nat) (h : d ≠ 0) (c : Nat.gcd (Int.natAbs n) d = 1) :\n    normalize n d h = mk' n d h c := (mk_eq_normalize ..).symm\n\n-- TODO: Rename `mkRat_num_den` in Batteries\n"}
{"name":"Rat.mkRat_num_den'","module":"Mathlib.Data.Rat.Defs","initialProofState":"a : Rat\n⊢ Eq (mkRat a.num a.den) a","decl":"@[simp] alias mkRat_num_den' := mkRat_self\n\n-- TODO: Rename `Rat.divInt_self` to `Rat.num_divInt_den` in Batteries\n"}
{"name":"Rat.num_divInt_den","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\n⊢ Eq (Rat.divInt q.num ↑q.den) q","decl":"lemma num_divInt_den (q : ℚ) : q.num /. q.den = q := divInt_self _\n\n"}
{"name":"Rat.mk'_eq_divInt","module":"Mathlib.Data.Rat.Defs","initialProofState":"n : Int\nd : Nat\nh : Ne d 0\nc : n.natAbs.Coprime d\n⊢ Eq { num := n, den := d, den_nz := h, reduced := c } (Rat.divInt n ↑d)","decl":"lemma mk'_eq_divInt {n d h c} : (⟨n, d, h, c⟩ : ℚ) = n /. d := (num_divInt_den _).symm\n\n"}
{"name":"Rat.intCast_eq_divInt","module":"Mathlib.Data.Rat.Defs","initialProofState":"z : Int\n⊢ Eq (↑z) (Rat.divInt z 1)","decl":"theorem intCast_eq_divInt (z : ℤ) : (z : ℚ) = z /. 1 := mk'_eq_divInt\n\n-- TODO: Rename `divInt_self` in Batteries to `num_divInt_den`\n"}
{"name":"Rat.divInt_self'","module":"Mathlib.Data.Rat.Defs","initialProofState":"n : Int\nhn : Ne n 0\n⊢ Eq (Rat.divInt n n) 1","decl":"@[simp] lemma divInt_self' {n : ℤ} (hn : n ≠ 0) : n /. n = 1 := by\n  simpa using divInt_mul_right (n := 1) (d := 1) hn\n\n"}
{"name":"Rat.lift_binop_eq","module":"Mathlib.Data.Rat.Defs","initialProofState":"f : Rat → Rat → Rat\nf₁ f₂ : Int → Int → Int → Int → Int\nfv : ∀ {n₁ : Int} {d₁ : Nat} {h₁ : Ne d₁ 0} {c₁ : n₁.natAbs.Coprime d₁} {n₂ : Int} {d₂ : Nat} {h₂ : Ne d₂ 0} {c₂ : n₂.natAbs.Coprime d₂}, Eq (f { num := n₁, den := d₁, den_nz := h₁, reduced := c₁ } { num := n₂, den := d₂, den_nz := h₂, reduced := c₂ }) (Rat.divInt (f₁ n₁ (↑d₁) n₂ ↑d₂) (f₂ n₁ (↑d₁) n₂ ↑d₂))\nf0 : ∀ {n₁ d₁ n₂ d₂ : Int}, Ne d₁ 0 → Ne d₂ 0 → Ne (f₂ n₁ d₁ n₂ d₂) 0\na b c d : Int\nb0 : Ne b 0\nd0 : Ne d 0\nH : ∀ {n₁ d₁ n₂ d₂ : Int}, Eq (HMul.hMul a d₁) (HMul.hMul n₁ b) → Eq (HMul.hMul c d₂) (HMul.hMul n₂ d) → Eq (HMul.hMul (f₁ n₁ d₁ n₂ d₂) (f₂ a b c d)) (HMul.hMul (f₁ a b c d) (f₂ n₁ d₁ n₂ d₂))\n⊢ Eq (f (Rat.divInt a b) (Rat.divInt c d)) (Rat.divInt (f₁ a b c d) (f₂ a b c d))","decl":"theorem lift_binop_eq (f : ℚ → ℚ → ℚ) (f₁ : ℤ → ℤ → ℤ → ℤ → ℤ) (f₂ : ℤ → ℤ → ℤ → ℤ → ℤ)\n    (fv :\n      ∀ {n₁ d₁ h₁ c₁ n₂ d₂ h₂ c₂},\n        f ⟨n₁, d₁, h₁, c₁⟩ ⟨n₂, d₂, h₂, c₂⟩ = f₁ n₁ d₁ n₂ d₂ /. f₂ n₁ d₁ n₂ d₂)\n    (f0 : ∀ {n₁ d₁ n₂ d₂}, d₁ ≠ 0 → d₂ ≠ 0 → f₂ n₁ d₁ n₂ d₂ ≠ 0) (a b c d : ℤ)\n    (b0 : b ≠ 0) (d0 : d ≠ 0)\n    (H :\n      ∀ {n₁ d₁ n₂ d₂}, a * d₁ = n₁ * b → c * d₂ = n₂ * d →\n        f₁ n₁ d₁ n₂ d₂ * f₂ a b c d = f₁ a b c d * f₂ n₁ d₁ n₂ d₂) :\n    f (a /. b) (c /. d) = f₁ a b c d /. f₂ a b c d := by\n  generalize ha : a /. b = x; cases' x with n₁ d₁ h₁ c₁; rw [mk'_eq_divInt] at ha\n  generalize hc : c /. d = x; cases' x with n₂ d₂ h₂ c₂; rw [mk'_eq_divInt] at hc\n  rw [fv]\n  have d₁0 := Int.ofNat_ne_zero.2 h₁\n  have d₂0 := Int.ofNat_ne_zero.2 h₂\n  exact (divInt_eq_iff (f0 d₁0 d₂0) (f0 b0 d0)).2\n    (H ((divInt_eq_iff b0 d₁0).1 ha) ((divInt_eq_iff d0 d₂0).1 hc))\n\n"}
{"name":"Rat.neg_def","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\n⊢ Eq (Neg.neg q) (Rat.divInt (Neg.neg q.num) ↑q.den)","decl":"lemma neg_def (q : ℚ) : -q = -q.num /. q.den := by rw [← neg_divInt, num_divInt_den]\n\n"}
{"name":"Rat.divInt_neg","module":"Mathlib.Data.Rat.Defs","initialProofState":"n d : Int\n⊢ Eq (Rat.divInt n (Neg.neg d)) (Rat.divInt (Neg.neg n) d)","decl":"@[simp] lemma divInt_neg (n d : ℤ) : n /. -d = -n /. d := divInt_neg' ..\n\n"}
{"name":"Rat.divInt_mul_divInt'","module":"Mathlib.Data.Rat.Defs","initialProofState":"n₁ d₁ n₂ d₂ : Int\n⊢ Eq (HMul.hMul (Rat.divInt n₁ d₁) (Rat.divInt n₂ d₂)) (Rat.divInt (HMul.hMul n₁ n₂) (HMul.hMul d₁ d₂))","decl":"@[simp]\nlemma divInt_mul_divInt' (n₁ d₁ n₂ d₂ : ℤ) : (n₁ /. d₁) * (n₂ /. d₂) = (n₁ * n₂) /. (d₁ * d₂) := by\n  obtain rfl | h₁ := eq_or_ne d₁ 0\n  · simp\n  obtain rfl | h₂ := eq_or_ne d₂ 0\n  · simp\n  exact divInt_mul_divInt _ _ h₁ h₂\n\n"}
{"name":"Rat.mk'_mul_mk'","module":"Mathlib.Data.Rat.Defs","initialProofState":"n₁ n₂ : Int\nd₁ d₂ : Nat\nhd₁ : Ne d₁ 0\nhd₂ : Ne d₂ 0\nhnd₁ : n₁.natAbs.Coprime d₁\nhnd₂ : n₂.natAbs.Coprime d₂\nh₁₂ : n₁.natAbs.Coprime d₂\nh₂₁ : n₂.natAbs.Coprime d₁\n⊢ Eq (HMul.hMul { num := n₁, den := d₁, den_nz := hd₁, reduced := hnd₁ } { num := n₂, den := d₂, den_nz := hd₂, reduced := hnd₂ }) { num := HMul.hMul n₁ n₂, den := HMul.hMul d₁ d₂, den_nz := ⋯, reduced := ⋯ }","decl":"lemma mk'_mul_mk' (n₁ n₂ : ℤ) (d₁ d₂ : ℕ) (hd₁ hd₂ hnd₁ hnd₂) (h₁₂ : n₁.natAbs.Coprime d₂)\n    (h₂₁ : n₂.natAbs.Coprime d₁) :\n    mk' n₁ d₁ hd₁ hnd₁ * mk' n₂ d₂ hd₂ hnd₂ = mk' (n₁ * n₂) (d₁ * d₂) (Nat.mul_ne_zero hd₁ hd₂) (by\n      rw [Int.natAbs_mul]; exact (hnd₁.mul h₂₁).mul_right (h₁₂.mul hnd₂)) := by\n  rw [mul_def]; dsimp; simp [mk_eq_normalize]\n\n"}
{"name":"Rat.mul_eq_mkRat","module":"Mathlib.Data.Rat.Defs","initialProofState":"q r : Rat\n⊢ Eq (HMul.hMul q r) (mkRat (HMul.hMul q.num r.num) (HMul.hMul q.den r.den))","decl":"lemma mul_eq_mkRat (q r : ℚ) : q * r = mkRat (q.num * r.num) (q.den * r.den) := by\n  rw [mul_def, normalize_eq_mkRat]\n\n-- TODO: Rename `divInt_eq_iff` in Batteries to `divInt_eq_divInt`\n"}
{"name":"Rat.divInt_eq_divInt","module":"Mathlib.Data.Rat.Defs","initialProofState":"d₁ d₂ n₁ n₂ : Int\nz₁ : Ne d₁ 0\nz₂ : Ne d₂ 0\n⊢ Iff (Eq (Rat.divInt n₁ d₁) (Rat.divInt n₂ d₂)) (Eq (HMul.hMul n₁ d₂) (HMul.hMul n₂ d₁))","decl":"alias divInt_eq_divInt := divInt_eq_iff\n\n"}
{"name":"Rat.pow_def","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\nn : Nat\n⊢ Eq (HPow.hPow q n) { num := HPow.hPow q.num n, den := HPow.hPow q.den n, den_nz := ⋯, reduced := ⋯ }","decl":"lemma pow_def (q : ℚ) (n : ℕ) :\n    q ^ n = ⟨q.num ^ n, q.den ^ n,\n      by simp [Nat.pow_eq_zero],\n      by rw [Int.natAbs_pow]; exact q.reduced.pow _ _⟩ := rfl\n\n"}
{"name":"Rat.pow_eq_mkRat","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\nn : Nat\n⊢ Eq (HPow.hPow q n) (mkRat (HPow.hPow q.num n) (HPow.hPow q.den n))","decl":"lemma pow_eq_mkRat (q : ℚ) (n : ℕ) : q ^ n = mkRat (q.num ^ n) (q.den ^ n) := by\n  rw [pow_def, mk_eq_mkRat]\n\n"}
{"name":"Rat.pow_eq_divInt","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\nn : Nat\n⊢ Eq (HPow.hPow q n) (Rat.divInt (HPow.hPow q.num n) (HPow.hPow (↑q.den) n))","decl":"lemma pow_eq_divInt (q : ℚ) (n : ℕ) : q ^ n = q.num ^ n /. q.den ^ n := by\n  rw [pow_def, mk_eq_divInt, Int.natCast_pow]\n\n"}
{"name":"Rat.num_pow","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\nn : Nat\n⊢ Eq (HPow.hPow q n).num (HPow.hPow q.num n)","decl":"@[simp] lemma num_pow (q : ℚ) (n : ℕ) : (q ^ n).num = q.num ^ n := rfl\n"}
{"name":"Rat.den_pow","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\nn : Nat\n⊢ Eq (HPow.hPow q n).den (HPow.hPow q.den n)","decl":"@[simp] lemma den_pow (q : ℚ) (n : ℕ) : (q ^ n).den = q.den ^ n := rfl\n\n"}
{"name":"Rat.mk'_pow","module":"Mathlib.Data.Rat.Defs","initialProofState":"num : Int\nden : Nat\nhd : Ne den 0\nhdn : num.natAbs.Coprime den\nn : Nat\n⊢ Eq (HPow.hPow { num := num, den := den, den_nz := hd, reduced := hdn } n) { num := HPow.hPow num n, den := HPow.hPow den n, den_nz := ⋯, reduced := ⋯ }","decl":"@[simp] lemma mk'_pow (num : ℤ) (den : ℕ) (hd hdn) (n : ℕ) :\n    mk' num den hd hdn ^ n = mk' (num ^ n) (den ^ n)\n      (by simp [Nat.pow_eq_zero, hd]) (by rw [Int.natAbs_pow]; exact hdn.pow _ _) := rfl\n\n"}
{"name":"Rat.inv_divInt'","module":"Mathlib.Data.Rat.Defs","initialProofState":"a b : Int\n⊢ Eq (Inv.inv (Rat.divInt a b)) (Rat.divInt b a)","decl":"@[simp] lemma inv_divInt' (a b : ℤ) : (a /. b)⁻¹ = b /. a := inv_divInt ..\n\n"}
{"name":"Rat.inv_mkRat","module":"Mathlib.Data.Rat.Defs","initialProofState":"a : Int\nb : Nat\n⊢ Eq (Inv.inv (mkRat a b)) (Rat.divInt (↑b) a)","decl":"@[simp] lemma inv_mkRat (a : ℤ) (b : ℕ) : (mkRat a b)⁻¹ = b /. a := by\n  rw [mkRat_eq_divInt, inv_divInt']\n\n"}
{"name":"Rat.inv_def'","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\n⊢ Eq (Inv.inv q) (Rat.divInt (↑q.den) q.num)","decl":"lemma inv_def' (q : ℚ) : q⁻¹ = q.den /. q.num := by rw [← inv_divInt', num_divInt_den]\n\n"}
{"name":"Rat.divInt_div_divInt","module":"Mathlib.Data.Rat.Defs","initialProofState":"n₁ d₁ n₂ d₂ : Int\n⊢ Eq (HDiv.hDiv (Rat.divInt n₁ d₁) (Rat.divInt n₂ d₂)) (Rat.divInt (HMul.hMul n₁ d₂) (HMul.hMul d₁ n₂))","decl":"@[simp] lemma divInt_div_divInt (n₁ d₁ n₂ d₂) :\n    (n₁ /. d₁) / (n₂ /. d₂) = (n₁ * d₂) /. (d₁ * n₂) := by\n  rw [div_def, inv_divInt, divInt_mul_divInt']\n\n"}
{"name":"Rat.div_def'","module":"Mathlib.Data.Rat.Defs","initialProofState":"q r : Rat\n⊢ Eq (HDiv.hDiv q r) (Rat.divInt (HMul.hMul q.num ↑r.den) (HMul.hMul (↑q.den) r.num))","decl":"lemma div_def' (q r : ℚ) : q / r = (q.num * r.den) /. (q.den * r.num) := by\n  rw [← divInt_div_divInt, num_divInt_den, num_divInt_den]\n\n"}
{"name":"Rat.add_zero","module":"Mathlib.Data.Rat.Defs","initialProofState":"a : Rat\n⊢ Eq (HAdd.hAdd a 0) a","decl":"protected lemma add_zero : a + 0 = a := by simp [add_def, normalize_eq_mkRat]\n\n"}
{"name":"Rat.zero_add","module":"Mathlib.Data.Rat.Defs","initialProofState":"a : Rat\n⊢ Eq (HAdd.hAdd 0 a) a","decl":"protected lemma zero_add : 0 + a = a := by simp [add_def, normalize_eq_mkRat]\n\n"}
{"name":"Rat.add_comm","module":"Mathlib.Data.Rat.Defs","initialProofState":"a b : Rat\n⊢ Eq (HAdd.hAdd a b) (HAdd.hAdd b a)","decl":"protected lemma add_comm : a + b = b + a := by\n  simp [add_def, Int.add_comm, Int.mul_comm, Nat.mul_comm]\n\n"}
{"name":"Rat.add_assoc","module":"Mathlib.Data.Rat.Defs","initialProofState":"a b c : Rat\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a b) c) (HAdd.hAdd a (HAdd.hAdd b c))","decl":"protected theorem add_assoc : a + b + c = a + (b + c) :=\n  numDenCasesOn' a fun n₁ d₁ h₁ ↦ numDenCasesOn' b fun n₂ d₂ h₂ ↦ numDenCasesOn' c fun n₃ d₃ h₃ ↦ by\n    simp only [ne_eq, Int.natCast_eq_zero, h₁, not_false_eq_true, h₂, divInt_add_divInt,\n      Int.mul_eq_zero, or_self, h₃]\n    rw [Int.mul_assoc, Int.add_mul, Int.add_mul, Int.mul_assoc, Int.add_assoc]\n    congr 2\n    ac_rfl\n\n"}
{"name":"Rat.neg_add_cancel","module":"Mathlib.Data.Rat.Defs","initialProofState":"a : Rat\n⊢ Eq (HAdd.hAdd (Neg.neg a) a) 0","decl":"protected lemma neg_add_cancel : -a + a = 0 := by\n  simp [add_def, normalize_eq_mkRat, Int.neg_mul, Int.add_comm, ← Int.sub_eq_add_neg]\n\n"}
{"name":"Rat.divInt_one","module":"Mathlib.Data.Rat.Defs","initialProofState":"n : Int\n⊢ Eq (Rat.divInt n 1) ↑n","decl":"@[simp] lemma divInt_one (n : ℤ) : n /. 1 = n := by simp [divInt, mkRat, normalize]\n"}
{"name":"Rat.mkRat_one","module":"Mathlib.Data.Rat.Defs","initialProofState":"n : Int\n⊢ Eq (mkRat n 1) ↑n","decl":"@[simp] lemma mkRat_one (n : ℤ) : mkRat n 1 = n := by simp [mkRat_eq_divInt]\n\n"}
{"name":"Rat.divInt_one_one","module":"Mathlib.Data.Rat.Defs","initialProofState":"⊢ Eq (Rat.divInt 1 1) 1","decl":"lemma divInt_one_one : 1 /. 1 = 1 := by rw [divInt_one, intCast_one]\n\n"}
{"name":"Rat.mul_assoc","module":"Mathlib.Data.Rat.Defs","initialProofState":"a b c : Rat\n⊢ Eq (HMul.hMul (HMul.hMul a b) c) (HMul.hMul a (HMul.hMul b c))","decl":"protected theorem mul_assoc : a * b * c = a * (b * c) :=\n  numDenCasesOn' a fun n₁ d₁ h₁ =>\n    numDenCasesOn' b fun n₂ d₂ h₂ =>\n      numDenCasesOn' c fun n₃ d₃ h₃ => by\n        simp [h₁, h₂, h₃, Int.mul_comm, Nat.mul_assoc, Int.mul_left_comm]\n\n"}
{"name":"Rat.add_mul","module":"Mathlib.Data.Rat.Defs","initialProofState":"a b c : Rat\n⊢ Eq (HMul.hMul (HAdd.hAdd a b) c) (HAdd.hAdd (HMul.hMul a c) (HMul.hMul b c))","decl":"protected theorem add_mul : (a + b) * c = a * c + b * c :=\n  numDenCasesOn' a fun n₁ d₁ h₁ ↦ numDenCasesOn' b fun n₂ d₂ h₂ ↦ numDenCasesOn' c fun n₃ d₃ h₃ ↦ by\n    simp only [ne_eq, Int.natCast_eq_zero, h₁, not_false_eq_true, h₂, divInt_add_divInt,\n      Int.mul_eq_zero, or_self, h₃, divInt_mul_divInt]\n    rw [← divInt_mul_right (Int.natCast_ne_zero.2 h₃), Int.add_mul, Int.add_mul]\n    ac_rfl\n\n"}
{"name":"Rat.mul_add","module":"Mathlib.Data.Rat.Defs","initialProofState":"a b c : Rat\n⊢ Eq (HMul.hMul a (HAdd.hAdd b c)) (HAdd.hAdd (HMul.hMul a b) (HMul.hMul a c))","decl":"protected theorem mul_add : a * (b + c) = a * b + a * c := by\n  rw [Rat.mul_comm, Rat.add_mul, Rat.mul_comm, Rat.mul_comm c a]\n\n"}
{"name":"Rat.zero_ne_one","module":"Mathlib.Data.Rat.Defs","initialProofState":"⊢ Ne 0 1","decl":"protected theorem zero_ne_one : 0 ≠ (1 : ℚ) := by\n  rw [ne_comm, ← divInt_one_one, divInt_ne_zero] <;> omega\n\n"}
{"name":"Rat.mul_inv_cancel","module":"Mathlib.Data.Rat.Defs","initialProofState":"a : Rat\na✝ : Ne a 0\n⊢ Eq (HMul.hMul a (Inv.inv a)) 1","decl":"protected theorem mul_inv_cancel : a ≠ 0 → a * a⁻¹ = 1 :=\n  numDenCasesOn' a fun n d hd hn ↦ by\n    simp only [divInt_ofNat, ne_eq, hd, not_false_eq_true, mkRat_eq_zero] at hn\n    simp [-divInt_ofNat, mkRat_eq_divInt, Int.mul_comm, Int.mul_ne_zero hn (Int.ofNat_ne_zero.2 hd)]\n\n"}
{"name":"Rat.inv_mul_cancel","module":"Mathlib.Data.Rat.Defs","initialProofState":"a : Rat\nh : Ne a 0\n⊢ Eq (HMul.hMul (Inv.inv a) a) 1","decl":"protected theorem inv_mul_cancel (h : a ≠ 0) : a⁻¹ * a = 1 :=\n  Eq.trans (Rat.mul_comm _ _) (Rat.mul_inv_cancel _ h)\n\n-- Porting note: we already have a `DecidableEq ℚ`.\n\n-- Extra instances to short-circuit type class resolution\n-- TODO(Mario): this instance slows down Mathlib.Data.Real.Basic\n"}
{"name":"Rat.nontrivial","module":"Mathlib.Data.Rat.Defs","initialProofState":"⊢ Nontrivial Rat","decl":"instance nontrivial : Nontrivial ℚ where exists_pair_ne := ⟨1, 0, by decide⟩\n\n"}
{"name":"Rat.eq_iff_mul_eq_mul","module":"Mathlib.Data.Rat.Defs","initialProofState":"p q : Rat\n⊢ Iff (Eq p q) (Eq (HMul.hMul p.num ↑q.den) (HMul.hMul q.num ↑p.den))","decl":"theorem eq_iff_mul_eq_mul {p q : ℚ} : p = q ↔ p.num * q.den = q.num * p.den := by\n  conv =>\n    lhs\n    rw [← num_divInt_den p, ← num_divInt_den q]\n  apply Rat.divInt_eq_iff <;>\n    · rw [← Int.natCast_zero, Ne, Int.ofNat_inj]\n      apply den_nz\n\n"}
{"name":"Rat.den_neg_eq_den","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\n⊢ Eq (Neg.neg q).den q.den","decl":"@[simp]\ntheorem den_neg_eq_den (q : ℚ) : (-q).den = q.den :=\n  rfl\n\n"}
{"name":"Rat.num_neg_eq_neg_num","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\n⊢ Eq (Neg.neg q).num (Neg.neg q.num)","decl":"@[simp]\ntheorem num_neg_eq_neg_num (q : ℚ) : (-q).num = -q.num :=\n  rfl\n\n-- Not `@[simp]` as `num_ofNat` is stronger.\n"}
{"name":"Rat.num_zero","module":"Mathlib.Data.Rat.Defs","initialProofState":"⊢ Eq (Rat.num 0) 0","decl":"theorem num_zero : Rat.num 0 = 0 :=\n  rfl\n\n-- Not `@[simp]` as `den_ofNat` is stronger.\n"}
{"name":"Rat.den_zero","module":"Mathlib.Data.Rat.Defs","initialProofState":"⊢ Eq (Rat.den 0) 1","decl":"theorem den_zero : Rat.den 0 = 1 :=\n  rfl\n\n"}
{"name":"Rat.zero_of_num_zero","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\nhq : Eq q.num 0\n⊢ Eq q 0","decl":"lemma zero_of_num_zero {q : ℚ} (hq : q.num = 0) : q = 0 := by simpa [hq] using q.num_divInt_den.symm\n\n"}
{"name":"Rat.zero_iff_num_zero","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\n⊢ Iff (Eq q 0) (Eq q.num 0)","decl":"theorem zero_iff_num_zero {q : ℚ} : q = 0 ↔ q.num = 0 :=\n  ⟨fun _ => by simp [*], zero_of_num_zero⟩\n\n-- `Not `@[simp]` as `num_ofNat` is stronger.\n"}
{"name":"Rat.num_one","module":"Mathlib.Data.Rat.Defs","initialProofState":"⊢ Eq (Rat.num 1) 1","decl":"theorem num_one : (1 : ℚ).num = 1 :=\n  rfl\n\n"}
{"name":"Rat.den_one","module":"Mathlib.Data.Rat.Defs","initialProofState":"⊢ Eq (Rat.den 1) 1","decl":"@[simp]\ntheorem den_one : (1 : ℚ).den = 1 :=\n  rfl\n\n"}
{"name":"Rat.mk_num_ne_zero_of_ne_zero","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\nn d : Int\nhq : Ne q 0\nhqnd : Eq q (Rat.divInt n d)\n⊢ Ne n 0","decl":"theorem mk_num_ne_zero_of_ne_zero {q : ℚ} {n d : ℤ} (hq : q ≠ 0) (hqnd : q = n /. d) : n ≠ 0 :=\n  fun this => hq <| by simpa [this] using hqnd\n\n"}
{"name":"Rat.mk_denom_ne_zero_of_ne_zero","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\nn d : Int\nhq : Ne q 0\nhqnd : Eq q (Rat.divInt n d)\n⊢ Ne d 0","decl":"theorem mk_denom_ne_zero_of_ne_zero {q : ℚ} {n d : ℤ} (hq : q ≠ 0) (hqnd : q = n /. d) : d ≠ 0 :=\n  fun this => hq <| by simpa [this] using hqnd\n\n"}
{"name":"Rat.divInt_ne_zero_of_ne_zero","module":"Mathlib.Data.Rat.Defs","initialProofState":"n d : Int\nh : Ne n 0\nhd : Ne d 0\n⊢ Ne (Rat.divInt n d) 0","decl":"theorem divInt_ne_zero_of_ne_zero {n d : ℤ} (h : n ≠ 0) (hd : d ≠ 0) : n /. d ≠ 0 :=\n  (divInt_ne_zero hd).mpr h\n\n"}
{"name":"Rat.nonneg_antisymm","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\na✝¹ : LE.le 0 q\na✝ : LE.le 0 (Neg.neg q)\n⊢ Eq q 0","decl":"protected lemma nonneg_antisymm : 0 ≤ q → 0 ≤ -q → q = 0 := by\n  simp_rw [← num_eq_zero, Int.le_antisymm_iff, ← num_nonneg, num_neg_eq_neg_num, Int.neg_nonneg]\n  tauto\n\n"}
{"name":"Rat.nonneg_total","module":"Mathlib.Data.Rat.Defs","initialProofState":"a : Rat\n⊢ Or (LE.le 0 a) (LE.le 0 (Neg.neg a))","decl":"protected lemma nonneg_total (a : ℚ) : 0 ≤ a ∨ 0 ≤ -a := by\n  simp_rw [← num_nonneg, num_neg_eq_neg_num, Int.neg_nonneg]; exact Int.le_total _ _\n\n"}
{"name":"Rat.add_divInt","module":"Mathlib.Data.Rat.Defs","initialProofState":"a b c : Int\n⊢ Eq (Rat.divInt (HAdd.hAdd a b) c) (HAdd.hAdd (Rat.divInt a c) (Rat.divInt b c))","decl":"protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=\n  if h : c = 0 then by simp [h]\n  else by\n    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]\n    simp [Int.add_mul, Int.mul_assoc]\n\n"}
{"name":"Rat.divInt_eq_div","module":"Mathlib.Data.Rat.Defs","initialProofState":"n d : Int\n⊢ Eq (Rat.divInt n d) (HDiv.hDiv ↑n ↑d)","decl":"theorem divInt_eq_div (n d : ℤ) : n /. d = (n : ℚ) / d := by simp [div_def']\n\n"}
{"name":"Rat.intCast_div_eq_divInt","module":"Mathlib.Data.Rat.Defs","initialProofState":"n d : Int\n⊢ Eq (HDiv.hDiv ↑n ↑d) (Rat.divInt n d)","decl":"lemma intCast_div_eq_divInt (n d : ℤ) : (n : ℚ) / (d) = n /. d := by rw [divInt_eq_div]\n\n"}
{"name":"Rat.natCast_div_eq_divInt","module":"Mathlib.Data.Rat.Defs","initialProofState":"n d : Nat\n⊢ Eq (HDiv.hDiv ↑n ↑d) (Rat.divInt ↑n ↑d)","decl":"theorem natCast_div_eq_divInt (n d : ℕ) : (n : ℚ) / d = n /. d := Rat.intCast_div_eq_divInt n d\n\n"}
{"name":"Rat.divInt_mul_divInt_cancel","module":"Mathlib.Data.Rat.Defs","initialProofState":"x : Int\nhx : Ne x 0\nn d : Int\n⊢ Eq (HMul.hMul (Rat.divInt n x) (Rat.divInt x d)) (Rat.divInt n d)","decl":"theorem divInt_mul_divInt_cancel {x : ℤ} (hx : x ≠ 0) (n d : ℤ) : n /. x * (x /. d) = n /. d := by\n  by_cases hd : d = 0\n  · rw [hd]\n    simp\n  rw [divInt_mul_divInt _ _ hx hd, x.mul_comm, divInt_mul_right hx]\n\n"}
{"name":"Rat.coe_int_num_of_den_eq_one","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\nhq : Eq q.den 1\n⊢ Eq (↑q.num) q","decl":"theorem coe_int_num_of_den_eq_one {q : ℚ} (hq : q.den = 1) : (q.num : ℚ) = q := by\n  conv_rhs => rw [← num_divInt_den q, hq]\n  rw [intCast_eq_divInt]\n  rfl\n\n"}
{"name":"Rat.eq_num_of_isInt","module":"Mathlib.Data.Rat.Defs","initialProofState":"q : Rat\nh : Eq q.isInt Bool.true\n⊢ Eq q ↑q.num","decl":"lemma eq_num_of_isInt {q : ℚ} (h : q.isInt) : q = q.num := by\n  rw [Rat.isInt, Nat.beq_eq_true_eq] at h\n  exact (Rat.coe_int_num_of_den_eq_one h).symm\n\n"}
{"name":"Rat.den_eq_one_iff","module":"Mathlib.Data.Rat.Defs","initialProofState":"r : Rat\n⊢ Iff (Eq r.den 1) (Eq (↑r.num) r)","decl":"theorem den_eq_one_iff (r : ℚ) : r.den = 1 ↔ ↑r.num = r :=\n  ⟨Rat.coe_int_num_of_den_eq_one, fun h => h ▸ Rat.den_intCast r.num⟩\n\n"}
{"name":"Rat.canLift","module":"Mathlib.Data.Rat.Defs","initialProofState":"⊢ CanLift Rat Int Int.cast fun q => Eq q.den 1","decl":"instance canLift : CanLift ℚ ℤ (↑) fun q => q.den = 1 :=\n  ⟨fun q hq => ⟨q.num, coe_int_num_of_den_eq_one hq⟩⟩\n\n-- Will be subsumed by `Int.coe_inj` after we have defined\n-- `LinearOrderedField ℚ` (which implies characteristic zero).\n"}
{"name":"Rat.coe_int_inj","module":"Mathlib.Data.Rat.Defs","initialProofState":"m n : Int\n⊢ Iff (Eq ↑m ↑n) (Eq m n)","decl":"theorem coe_int_inj (m n : ℤ) : (m : ℚ) = n ↔ m = n :=\n  ⟨congr_arg num, congr_arg _⟩\n\n"}
