{"name":"Multiset.bell_zero","module":"Mathlib.Combinatorics.Enumerative.Bell","initialProofState":"⊢ Eq (Multiset.bell 0) 1","decl":"@[simp]\ntheorem bell_zero : bell 0 = 1 := rfl\n\n"}
{"name":"Multiset.bell_mul_eq","module":"Mathlib.Combinatorics.Enumerative.Bell","initialProofState":"m : Multiset Nat\n⊢ Eq (HMul.hMul (HMul.hMul m.bell (Multiset.map (fun j => j.factorial) m).prod) ((m.toFinset.erase 0).prod fun j => (Multiset.count j m).factorial)) m.sum.factorial","decl":"theorem bell_mul_eq (m : Multiset ℕ) :\n    m.bell * (m.map (fun j ↦ j !)).prod * ∏ j ∈ (m.toFinset.erase 0), (m.count j)!\n      = m.sum ! := by\n  unfold bell\n  rw [← Nat.mul_right_inj (a := ∏ i ∈ m.toFinset, (i * count i m)!) (by positivity)]\n  simp only [← mul_assoc]\n  rw [Nat.multinomial_spec]\n  simp only [mul_assoc]\n  rw [mul_comm]\n  apply congr_arg₂\n  · rw [mul_comm, mul_assoc, ← Finset.prod_mul_distrib, Finset.prod_multiset_map_count]\n    suffices this : _ by\n      by_cases hm : 0 ∈ m.toFinset\n      · rw [← Finset.prod_erase_mul _ _ hm]\n        rw [← Finset.prod_erase_mul _ _ hm]\n        simp only [factorial_zero, one_pow, mul_one, zero_mul]\n        exact this\n      · nth_rewrite 1 [← Finset.erase_eq_of_not_mem hm]\n        nth_rewrite 3 [← Finset.erase_eq_of_not_mem hm]\n        exact this\n    rw [← Finset.prod_mul_distrib]\n    apply Finset.prod_congr rfl\n    intro x hx\n    rw [← mul_assoc, bell_mul_eq_lemma]\n    simp only [Finset.mem_erase, ne_eq, mem_toFinset] at hx\n    simp only [ne_eq, hx.1, not_false_eq_true]\n  · apply congr_arg\n    rw [Finset.sum_multiset_count]\n    simp only [smul_eq_mul, mul_comm]\n\n"}
{"name":"Multiset.bell_eq","module":"Mathlib.Combinatorics.Enumerative.Bell","initialProofState":"m : Multiset Nat\n⊢ Eq m.bell (HDiv.hDiv m.sum.factorial (HMul.hMul (Multiset.map (fun j => j.factorial) m).prod ((m.toFinset.erase 0).prod fun j => (Multiset.count j m).factorial)))","decl":"theorem bell_eq (m : Multiset ℕ) :\n    m.bell = m.sum ! / ((m.map (fun j ↦ j !)).prod *\n      ∏ j ∈ (m.toFinset.erase 0), (m.count j)!) := by\n  rw [← Nat.mul_left_inj, Nat.div_mul_cancel _]\n  · rw [← mul_assoc]\n    exact bell_mul_eq m\n  · rw [← bell_mul_eq, mul_assoc]\n    apply Nat.dvd_mul_left\n  · rw [← Nat.pos_iff_ne_zero]\n    apply Nat.mul_pos\n    · simp only [gt_iff_lt, CanonicallyOrderedAdd.multiset_prod_pos, mem_map,\n      forall_exists_index, and_imp, forall_apply_eq_imp_iff₂]\n      exact fun _ _ ↦ Nat.factorial_pos _\n    · apply Finset.prod_pos\n      exact fun _ _ ↦ Nat.factorial_pos _\n\n"}
{"name":"Nat.uniformBell_eq","module":"Mathlib.Combinatorics.Enumerative.Bell","initialProofState":"m n : Nat\n⊢ Eq (m.uniformBell n) ((Finset.range m).prod fun p => (HSub.hSub (HAdd.hAdd (HMul.hMul p n) n) 1).choose (HSub.hSub n 1))","decl":"theorem uniformBell_eq (m n : ℕ) : m.uniformBell n =\n    ∏ p ∈ (Finset.range m), Nat.choose (p * n + n - 1) (n - 1) := by\n  unfold uniformBell bell\n  rw [toFinset_replicate]\n  split_ifs with hm\n  · simp  [hm]\n  · by_cases hn : n = 0\n    · simp [hn]\n    · rw [show ({n} : Finset ℕ).erase 0 = {n} by simp [Ne.symm hn]]\n      simp [count_replicate]\n\n"}
{"name":"Nat.uniformBell_zero_left","module":"Mathlib.Combinatorics.Enumerative.Bell","initialProofState":"n : Nat\n⊢ Eq (Nat.uniformBell 0 n) 1","decl":"theorem uniformBell_zero_left (n : ℕ) : uniformBell 0 n = 1 := by\n  simp [uniformBell_eq]\n\n"}
{"name":"Nat.uniformBell_zero_right","module":"Mathlib.Combinatorics.Enumerative.Bell","initialProofState":"m : Nat\n⊢ Eq (m.uniformBell 0) 1","decl":"theorem uniformBell_zero_right (m : ℕ) : uniformBell m 0 = 1 := by\n  simp [uniformBell_eq]\n\n"}
{"name":"Nat.uniformBell_succ_left","module":"Mathlib.Combinatorics.Enumerative.Bell","initialProofState":"m n : Nat\n⊢ Eq ((HAdd.hAdd m 1).uniformBell n) (HMul.hMul ((HSub.hSub (HAdd.hAdd (HMul.hMul m n) n) 1).choose (HSub.hSub n 1)) (m.uniformBell n))","decl":"theorem uniformBell_succ_left (m n : ℕ) :\n    uniformBell (m+1) n = choose (m * n + n - 1) (n - 1) * uniformBell m n := by\n  simp only [uniformBell_eq, Finset.prod_range_succ, mul_comm]\n\n"}
{"name":"Nat.uniformBell_one_left","module":"Mathlib.Combinatorics.Enumerative.Bell","initialProofState":"n : Nat\n⊢ Eq (Nat.uniformBell 1 n) 1","decl":"theorem uniformBell_one_left (n : ℕ) : uniformBell 1 n = 1 := by\n  simp only [uniformBell_eq, Finset.range_one, Finset.prod_singleton, zero_mul,\n    zero_add, choose_self]\n\n"}
{"name":"Nat.uniformBell_one_right","module":"Mathlib.Combinatorics.Enumerative.Bell","initialProofState":"m : Nat\n⊢ Eq (m.uniformBell 1) 1","decl":"theorem uniformBell_one_right (m : ℕ) : uniformBell m 1 = 1 := by\n  simp only [uniformBell_eq, mul_one, add_tsub_cancel_right, ge_iff_le, le_refl,\n    tsub_eq_zero_of_le, choose_zero_right, Finset.prod_const_one]\n\n"}
{"name":"Nat.uniformBell_mul_eq","module":"Mathlib.Combinatorics.Enumerative.Bell","initialProofState":"m n : Nat\nhn : Ne n 0\n⊢ Eq (HMul.hMul (HMul.hMul (m.uniformBell n) (HPow.hPow n.factorial m)) m.factorial) (HMul.hMul m n).factorial","decl":"theorem uniformBell_mul_eq (m : ℕ) {n : ℕ} (hn : n ≠ 0) :\n    uniformBell m n * n ! ^ m * m ! = (m * n)! := by\n  convert bell_mul_eq (replicate m n)\n  · simp only [map_replicate, prod_replicate]\n  · simp only [toFinset_replicate]\n    split_ifs with hm\n    · rw [hm, factorial_zero, eq_comm]\n      rw [show (∅ : Finset ℕ).erase 0 = ∅ from rfl,  Finset.prod_empty]\n    · rw [show ({n} : Finset ℕ).erase 0 = {n} by simp [Ne.symm hn]]\n      simp only [Finset.prod_singleton, count_replicate_self]\n  · simp\n\n"}
{"name":"Nat.uniformBell_eq_div","module":"Mathlib.Combinatorics.Enumerative.Bell","initialProofState":"m n : Nat\nhn : Ne n 0\n⊢ Eq (m.uniformBell n) (HDiv.hDiv (HMul.hMul m n).factorial (HMul.hMul (HPow.hPow n.factorial m) m.factorial))","decl":"theorem uniformBell_eq_div (m : ℕ) {n : ℕ} (hn : n ≠ 0) :\n    uniformBell m n = (m * n) ! / (n ! ^ m * m !) := by\n  rw [eq_comm]\n  apply Nat.div_eq_of_eq_mul_left\n  · exact Nat.mul_pos (Nat.pow_pos (Nat.factorial_pos n)) m.factorial_pos\n  · rw [← mul_assoc, ← uniformBell_mul_eq _ hn]\n\n"}
