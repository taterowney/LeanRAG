{"name":"CategoryTheory.Functor.mapDerivedCategoryFactorsh_hom_app","module":"Mathlib.Algebra.Homology.DerivedCategory.ExactFunctor","initialProofState":"C₁ : Type u₁\ninst✝⁸ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝⁷ : CategoryTheory.Abelian C₁\ninst✝⁶ : HasDerivedCategory C₁\nC₂ : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝⁴ : CategoryTheory.Abelian C₂\ninst✝³ : HasDerivedCategory C₂\nF : CategoryTheory.Functor C₁ C₂\ninst✝² : F.Additive\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteLimits F\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\nK : CochainComplex C₁ Int\n⊢ Eq (F.mapDerivedCategoryFactorsh.hom.app ((HomotopyCategory.quotient C₁ (ComplexShape.up Int)).obj K)) (CategoryTheory.CategoryStruct.comp (F.mapDerivedCategory.map ((DerivedCategory.quotientCompQhIso C₁).hom.app K)) (CategoryTheory.CategoryStruct.comp (F.mapDerivedCategoryFactors.hom.app K) (CategoryTheory.CategoryStruct.comp ((DerivedCategory.quotientCompQhIso C₂).inv.app ((F.mapHomologicalComplex (ComplexShape.up Int)).obj K)) (DerivedCategory.Qh.map ((F.mapHomotopyCategoryFactors (ComplexShape.up Int)).inv.app K)))))","decl":"lemma mapDerivedCategoryFactorsh_hom_app (K : CochainComplex C₁ ℤ) :\n    F.mapDerivedCategoryFactorsh.hom.app ((HomotopyCategory.quotient _ _).obj K) =\n      F.mapDerivedCategory.map ((DerivedCategory.quotientCompQhIso C₁).hom.app K) ≫\n        F.mapDerivedCategoryFactors.hom.app K ≫\n        (DerivedCategory.quotientCompQhIso C₂).inv.app _ ≫\n        DerivedCategory.Qh.map ((F.mapHomotopyCategoryFactors (ComplexShape.up ℤ)).inv.app K) :=\n  F.mapHomologicalComplexUpToQuasiIsoFactorsh_hom_app K\n\n"}
{"name":"CategoryTheory.Functor.instCommShiftHomotopyCategoryIntUpDerivedCategoryHomMapDerivedCategoryFactorsh","module":"Mathlib.Algebra.Homology.DerivedCategory.ExactFunctor","initialProofState":"C₁ : Type u₁\ninst✝⁸ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝⁷ : CategoryTheory.Abelian C₁\ninst✝⁶ : HasDerivedCategory C₁\nC₂ : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝⁴ : CategoryTheory.Abelian C₂\ninst✝³ : HasDerivedCategory C₂\nF : CategoryTheory.Functor C₁ C₂\ninst✝² : F.Additive\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteLimits F\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\n⊢ CategoryTheory.NatTrans.CommShift F.mapDerivedCategoryFactorsh.hom Int","decl":"instance : NatTrans.CommShift F.mapDerivedCategoryFactorsh.hom ℤ :=\n  inferInstanceAs (NatTrans.CommShift (Localization.Lifting.iso\n      DerivedCategory.Qh (HomotopyCategory.quasiIso C₁ (ComplexShape.up ℤ))\n        (F.mapHomotopyCategory _ ⋙ DerivedCategory.Qh)\n          F.mapDerivedCategory).hom ℤ)\n\n"}
{"name":"CategoryTheory.Functor.instCommShiftCochainComplexIntDerivedCategoryHomMapDerivedCategoryFactors","module":"Mathlib.Algebra.Homology.DerivedCategory.ExactFunctor","initialProofState":"C₁ : Type u₁\ninst✝⁸ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝⁷ : CategoryTheory.Abelian C₁\ninst✝⁶ : HasDerivedCategory C₁\nC₂ : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝⁴ : CategoryTheory.Abelian C₂\ninst✝³ : HasDerivedCategory C₂\nF : CategoryTheory.Functor C₁ C₂\ninst✝² : F.Additive\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteLimits F\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\n⊢ CategoryTheory.NatTrans.CommShift F.mapDerivedCategoryFactors.hom Int","decl":"instance : NatTrans.CommShift F.mapDerivedCategoryFactors.hom ℤ :=\n  NatTrans.CommShift.verticalComposition (DerivedCategory.quotientCompQhIso C₁).inv\n    (DerivedCategory.quotientCompQhIso C₂).hom\n    (F.mapHomotopyCategoryFactors (ComplexShape.up ℤ)).hom\n    F.mapDerivedCategoryFactorsh.hom F.mapDerivedCategoryFactors.hom ℤ (by\n      ext K\n      dsimp\n      simp only [id_comp, mapDerivedCategoryFactorsh_hom_app, assoc, comp_id,\n        ← Functor.map_comp_assoc, Iso.inv_hom_id_app, map_id, comp_obj])\n\n"}
{"name":"CategoryTheory.Functor.instIsTriangulatedDerivedCategoryMapDerivedCategory","module":"Mathlib.Algebra.Homology.DerivedCategory.ExactFunctor","initialProofState":"C₁ : Type u₁\ninst✝⁸ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝⁷ : CategoryTheory.Abelian C₁\ninst✝⁶ : HasDerivedCategory C₁\nC₂ : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝⁴ : CategoryTheory.Abelian C₂\ninst✝³ : HasDerivedCategory C₂\nF : CategoryTheory.Functor C₁ C₂\ninst✝² : F.Additive\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteLimits F\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\n⊢ F.mapDerivedCategory.IsTriangulated","decl":"instance : F.mapDerivedCategory.IsTriangulated :=\n  Functor.isTriangulated_of_precomp_iso F.mapDerivedCategoryFactorsh\n\n"}
