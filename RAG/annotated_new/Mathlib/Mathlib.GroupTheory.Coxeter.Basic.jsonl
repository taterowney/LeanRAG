{"name":"CoxeterMatrix.reindex_relationsSet","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nB' : Type u_2\nM : CoxeterMatrix B\ne : Equiv B B'\n⊢ Eq (CoxeterMatrix.reindex e M).relationsSet (Set.image (⇑(FreeGroup.freeGroupCongr e)) M.relationsSet)","decl":"theorem reindex_relationsSet :\n    (M.reindex e).relationsSet =\n    FreeGroup.freeGroupCongr e '' M.relationsSet := let M' := M.reindex e; calc\n  Set.range (uncurry M'.relation)\n  _ = Set.range (uncurry M'.relation ∘ Prod.map e e) := by simp [Set.range_comp]\n  _ = Set.range (FreeGroup.freeGroupCongr e ∘ uncurry M.relation) := by\n      apply congrArg Set.range\n      ext ⟨i, i'⟩\n      simp [relation, reindex_apply, M']\n  _ = _ := by simp [Set.range_comp, relationsSet]\n\n"}
{"name":"CoxeterMatrix.reindexGroupEquiv_apply_simple","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nB' : Type u_2\nM : CoxeterMatrix B\ne : Equiv B B'\ni : B'\n⊢ Eq ((M.reindexGroupEquiv e) ((CoxeterMatrix.reindex e M).simple i)) (M.simple (e.symm i))","decl":"theorem reindexGroupEquiv_apply_simple (i : B') :\n    (M.reindexGroupEquiv e) ((M.reindex e).simple i) = M.simple (e.symm i) := rfl\n\n"}
{"name":"CoxeterMatrix.reindexGroupEquiv_symm_apply_simple","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nB' : Type u_2\nM : CoxeterMatrix B\ne : Equiv B B'\ni : B\n⊢ Eq ((M.reindexGroupEquiv e).symm (M.simple i)) ((CoxeterMatrix.reindex e M).simple (e i))","decl":"theorem reindexGroupEquiv_symm_apply_simple (i : B) :\n    (M.reindexGroupEquiv e).symm (M.simple i) = (M.reindex e).simple (e i) := rfl\n\n"}
{"name":"CoxeterSystem.ext","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nM : CoxeterMatrix B\nW : Type u_2\ninst✝ : Group W\nx y : CoxeterSystem M W\nmulEquiv : Eq x.mulEquiv y.mulEquiv\n⊢ Eq x y","decl":"/-- A Coxeter system `CoxeterSystem M W` is a structure recording the isomorphism between\na group `W` and the Coxeter group associated to a Coxeter matrix `M`. -/\n@[ext]\nstructure CoxeterSystem (W : Type*) [Group W] where\n  /-- The isomorphism between `W` and the Coxeter group associated to `M`. -/\n  mulEquiv : W ≃* M.Group\n\n"}
{"name":"CoxeterSystem.mk.inj","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nM : CoxeterMatrix B\nW : Type u_2\ninst✝ : Group W\nmulEquiv✝ mulEquiv : MulEquiv W M.Group\nx✝ : Eq { mulEquiv := mulEquiv✝ } { mulEquiv := mulEquiv }\n⊢ Eq mulEquiv✝ mulEquiv","decl":"/-- A Coxeter system `CoxeterSystem M W` is a structure recording the isomorphism between\na group `W` and the Coxeter group associated to a Coxeter matrix `M`. -/\n@[ext]\nstructure CoxeterSystem (W : Type*) [Group W] where\n  /-- The isomorphism between `W` and the Coxeter group associated to `M`. -/\n  mulEquiv : W ≃* M.Group\n\n"}
{"name":"CoxeterSystem.ext_iff","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nM : CoxeterMatrix B\nW : Type u_2\ninst✝ : Group W\nx y : CoxeterSystem M W\n⊢ Iff (Eq x y) (Eq x.mulEquiv y.mulEquiv)","decl":"/-- A Coxeter system `CoxeterSystem M W` is a structure recording the isomorphism between\na group `W` and the Coxeter group associated to a Coxeter matrix `M`. -/\n@[ext]\nstructure CoxeterSystem (W : Type*) [Group W] where\n  /-- The isomorphism between `W` and the Coxeter group associated to `M`. -/\n  mulEquiv : W ≃* M.Group\n\n"}
{"name":"CoxeterSystem.mk.sizeOf_spec","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nM : CoxeterMatrix B\nW : Type u_2\ninst✝² : Group W\ninst✝¹ : SizeOf B\ninst✝ : SizeOf W\nmulEquiv : MulEquiv W M.Group\n⊢ Eq (SizeOf.sizeOf { mulEquiv := mulEquiv }) (HAdd.hAdd 1 (SizeOf.sizeOf mulEquiv))","decl":"/-- A Coxeter system `CoxeterSystem M W` is a structure recording the isomorphism between\na group `W` and the Coxeter group associated to a Coxeter matrix `M`. -/\n@[ext]\nstructure CoxeterSystem (W : Type*) [Group W] where\n  /-- The isomorphism between `W` and the Coxeter group associated to `M`. -/\n  mulEquiv : W ≃* M.Group\n\n"}
{"name":"CoxeterSystem.mk.injEq","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nM : CoxeterMatrix B\nW : Type u_2\ninst✝ : Group W\nmulEquiv✝ mulEquiv : MulEquiv W M.Group\n⊢ Eq (Eq { mulEquiv := mulEquiv✝ } { mulEquiv := mulEquiv }) (Eq mulEquiv✝ mulEquiv)","decl":"/-- A Coxeter system `CoxeterSystem M W` is a structure recording the isomorphism between\na group `W` and the Coxeter group associated to a Coxeter matrix `M`. -/\n@[ext]\nstructure CoxeterSystem (W : Type*) [Group W] where\n  /-- The isomorphism between `W` and the Coxeter group associated to `M`. -/\n  mulEquiv : W ≃* M.Group\n\n"}
{"name":"IsCoxeterGroup.nonempty_system","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"W : Type u\ninst✝ : Group W\nself : IsCoxeterGroup W\n⊢ Exists fun B => Exists fun M => Nonempty (CoxeterSystem M W)","decl":"/-- A group is a Coxeter group if it admits a Coxeter system for some Coxeter matrix `M`. -/\nclass IsCoxeterGroup.{u} (W : Type u) [Group W] : Prop where\n  nonempty_system : ∃ B : Type u, ∃ M : CoxeterMatrix B, Nonempty (CoxeterSystem M W)\n\n"}
{"name":"CoxeterSystem.reindex_mulEquiv","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nB' : Type u_2\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ne : Equiv B B'\n⊢ Eq (cs.reindex e).mulEquiv (cs.mulEquiv.trans (M.reindexGroupEquiv e).symm)","decl":"/-- Reindex a Coxeter system through a bijection of the indexing sets. -/\n@[simps]\nprotected def reindex (e : B ≃ B') : CoxeterSystem (M.reindex e) W :=\n  ⟨cs.mulEquiv.trans (M.reindexGroupEquiv e).symm⟩\n\n"}
{"name":"CoxeterSystem.map_mulEquiv","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\nH : Type u_4\ninst✝¹ : Group W\ninst✝ : Group H\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ne : MulEquiv W H\n⊢ Eq (cs.map e).mulEquiv (e.symm.trans cs.mulEquiv)","decl":"/-- Push a Coxeter system through a group isomorphism. -/\n@[simps]\nprotected def map (e : W ≃* H) : CoxeterSystem M H := ⟨e.symm.trans cs.mulEquiv⟩\n\n"}
{"name":"CoxeterMatrix.toCoxeterSystem_simple","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nM : CoxeterMatrix B\n⊢ Eq M.toCoxeterSystem.simple M.simple","decl":"@[simp]\ntheorem _root_.CoxeterMatrix.toCoxeterSystem_simple (M : CoxeterMatrix B) :\n    M.toCoxeterSystem.simple = M.simple := rfl\n\n"}
{"name":"CoxeterSystem.reindex_simple","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nB' : Type u_2\ne : Equiv B B'\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni' : B'\n⊢ Eq ((cs.reindex e).simple i') (cs.simple (e.symm i'))","decl":"@[simp] theorem reindex_simple (i' : B') : (cs.reindex e).simple i' = cs.simple (e.symm i') := rfl\n\n"}
{"name":"CoxeterSystem.map_simple","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\nH : Type u_4\ninst✝¹ : Group W\ninst✝ : Group H\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ne : MulEquiv W H\ni : B\n⊢ Eq ((cs.map e).simple i) (e (cs.simple i))","decl":"@[simp] theorem map_simple (e : W ≃* H) (i : B) : (cs.map e).simple i = e (cs.simple i) := rfl\n\n"}
{"name":"CoxeterSystem.simple_mul_simple_self","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni : B\n⊢ Eq (HMul.hMul (cs.simple i) (cs.simple i)) 1","decl":"@[simp]\ntheorem simple_mul_simple_self (i : B) : s i * s i = 1 := by\n  have : (FreeGroup.of i) * (FreeGroup.of i) ∈ M.relationsSet := ⟨(i, i), by simp [relation]⟩\n  have : (PresentedGroup.mk _ (FreeGroup.of i * FreeGroup.of i) : M.Group) = 1 :=\n    (QuotientGroup.eq_one_iff _).mpr (Subgroup.subset_normalClosure this)\n  unfold simple\n  rw [← map_mul, PresentedGroup.of, map_mul]\n  exact map_mul_eq_one cs.mulEquiv.symm this\n\n"}
{"name":"CoxeterSystem.simple_mul_simple_cancel_right","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n⊢ Eq (HMul.hMul (HMul.hMul w (cs.simple i)) (cs.simple i)) w","decl":"@[simp]\ntheorem simple_mul_simple_cancel_right {w : W} (i : B) : w * s i * s i = w := by\n  simp [mul_assoc]\n\n"}
{"name":"CoxeterSystem.simple_mul_simple_cancel_left","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n⊢ Eq (HMul.hMul (cs.simple i) (HMul.hMul (cs.simple i) w)) w","decl":"@[simp]\ntheorem simple_mul_simple_cancel_left {w : W} (i : B) : s i * (s i * w) = w := by\n  simp [← mul_assoc]\n\n"}
{"name":"CoxeterSystem.simple_sq","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni : B\n⊢ Eq (HPow.hPow (cs.simple i) 2) 1","decl":"@[simp] theorem simple_sq (i : B) : s i ^ 2 = 1 := pow_two (s i) ▸ cs.simple_mul_simple_self i\n\n"}
{"name":"CoxeterSystem.inv_simple","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni : B\n⊢ Eq (Inv.inv (cs.simple i)) (cs.simple i)","decl":"@[simp]\ntheorem inv_simple (i : B) : (s i)⁻¹ = s i :=\n  (eq_inv_of_mul_eq_one_right (cs.simple_mul_simple_self i)).symm\n\n"}
{"name":"CoxeterSystem.simple_mul_simple_pow","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni i' : B\n⊢ Eq (HPow.hPow (HMul.hMul (cs.simple i) (cs.simple i')) (M.M i i')) 1","decl":"@[simp]\ntheorem simple_mul_simple_pow (i i' : B) : (s i * s i') ^ M i i' = 1 := by\n  have : (FreeGroup.of i * FreeGroup.of i') ^ M i i' ∈ M.relationsSet := ⟨(i, i'), rfl⟩\n  have : (PresentedGroup.mk _ ((FreeGroup.of i * FreeGroup.of i') ^ M i i') : M.Group) = 1 :=\n    (QuotientGroup.eq_one_iff _).mpr (Subgroup.subset_normalClosure this)\n  unfold simple\n  rw [← map_mul, ← map_pow]\n  exact (MulEquiv.map_eq_one_iff cs.mulEquiv.symm).mpr this\n\n"}
{"name":"CoxeterSystem.simple_mul_simple_pow'","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni i' : B\n⊢ Eq (HPow.hPow (HMul.hMul (cs.simple i') (cs.simple i)) (M.M i i')) 1","decl":"@[simp] theorem simple_mul_simple_pow' (i i' : B) : (s i' * s i) ^ M i i' = 1 :=\n  M.symmetric i' i ▸ cs.simple_mul_simple_pow i' i\n\n"}
{"name":"CoxeterSystem.subgroup_closure_range_simple","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\n⊢ Eq (Subgroup.closure (Set.range cs.simple)) Top.top","decl":"/-- The simple reflections of `W` generate `W` as a group. -/\ntheorem subgroup_closure_range_simple : Subgroup.closure (range cs.simple) = ⊤ := by\n  have : cs.simple = cs.mulEquiv.symm ∘ PresentedGroup.of := rfl\n  rw [this, Set.range_comp, ← MulEquiv.coe_toMonoidHom, ← MonoidHom.map_closure,\n    PresentedGroup.closure_range_of, ← MonoidHom.range_eq_map]\n  exact MonoidHom.range_eq_top.2 (MulEquiv.surjective _)\n\n"}
{"name":"CoxeterSystem.submonoid_closure_range_simple","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\n⊢ Eq (Submonoid.closure (Set.range cs.simple)) Top.top","decl":"/-- The simple reflections of `W` generate `W` as a monoid. -/\ntheorem submonoid_closure_range_simple : Submonoid.closure (range cs.simple) = ⊤ := by\n  have : range cs.simple = range cs.simple ∪ (range cs.simple)⁻¹ := by\n    simp_rw [inv_range, inv_simple, union_self]\n  rw [this, ← Subgroup.closure_toSubmonoid, subgroup_closure_range_simple, Subgroup.top_toSubmonoid]\n\n"}
{"name":"CoxeterSystem.simple_induction","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\np : W → Prop\nw : W\nsimple : ∀ (i : B), p (cs.simple i)\none : p 1\nmul : ∀ (w w' : W), p w → p w' → p (HMul.hMul w w')\n⊢ p w","decl":"/-- If `p : W → Prop` holds for all simple reflections, it holds for the identity, and it is\npreserved under multiplication, then it holds for all elements of `W`. -/\ntheorem simple_induction {p : W → Prop} (w : W) (simple : ∀ i : B, p (s i)) (one : p 1)\n    (mul : ∀ w w' : W, p w → p w' → p (w * w')) : p w := by\n  have := cs.submonoid_closure_range_simple.symm ▸ Submonoid.mem_top w\n  exact Submonoid.closure_induction (fun x ⟨i, hi⟩ ↦ hi ▸ simple i) one (fun _ _ _ _ ↦ mul _ _)\n    this\n\n"}
{"name":"CoxeterSystem.simple_induction_left","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\np : W → Prop\nw : W\none : p 1\nmul_simple_left : ∀ (w : W) (i : B), p w → p (HMul.hMul (cs.simple i) w)\n⊢ p w","decl":"/-- If `p : W → Prop` holds for the identity and it is preserved under multiplying on the left\nby a simple reflection, then it holds for all elements of `W`. -/\ntheorem simple_induction_left {p : W → Prop} (w : W) (one : p 1)\n    (mul_simple_left : ∀ (w : W) (i : B), p w → p (s i * w)) : p w := by\n  let p' : (w : W) → w ∈ Submonoid.closure (Set.range cs.simple) → Prop :=\n    fun w _ ↦ p w\n  have := cs.submonoid_closure_range_simple.symm ▸ Submonoid.mem_top w\n  apply Submonoid.closure_induction_left (p := p')\n  · exact one\n  · rintro _ ⟨i, rfl⟩ y _\n    exact mul_simple_left y i\n  · exact this\n\n"}
{"name":"CoxeterSystem.simple_induction_right","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\np : W → Prop\nw : W\none : p 1\nmul_simple_right : ∀ (w : W) (i : B), p w → p (HMul.hMul w (cs.simple i))\n⊢ p w","decl":"/-- If `p : W → Prop` holds for the identity and it is preserved under multiplying on the right\nby a simple reflection, then it holds for all elements of `W`. -/\ntheorem simple_induction_right {p : W → Prop} (w : W) (one : p 1)\n    (mul_simple_right : ∀ (w : W) (i : B), p w → p (w * s i)) : p w := by\n  let p' : ((w : W) → w ∈ Submonoid.closure (Set.range cs.simple) → Prop) :=\n    fun w _ ↦ p w\n  have := cs.submonoid_closure_range_simple.symm ▸ Submonoid.mem_top w\n  apply Submonoid.closure_induction_right (p := p')\n  · exact one\n  · rintro x _ _ ⟨i, rfl⟩\n    exact mul_simple_right x i\n  · exact this\n\n"}
{"name":"CoxeterSystem.ext_simple","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝¹ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nG : Type u_5\ninst✝ : Monoid G\nφ₁ φ₂ : MonoidHom W G\nh : ∀ (i : B), Eq (φ₁ (cs.simple i)) (φ₂ (cs.simple i))\n⊢ Eq φ₁ φ₂","decl":"/-- If two homomorphisms with domain `W` agree on all simple reflections, then they are equal. -/\ntheorem ext_simple {G : Type*} [Monoid G] {φ₁ φ₂ : W →* G} (h : ∀ i : B, φ₁ (s i) = φ₂ (s i)) :\n    φ₁ = φ₂ :=\n  MonoidHom.eq_of_eqOn_denseM cs.submonoid_closure_range_simple (fun _ ⟨i, hi⟩ ↦ hi ▸ h i)\n\n"}
{"name":"CoxeterSystem.lift_apply_simple","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝¹ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nG : Type u_5\ninst✝ : Monoid G\nf : B → G\nhf : M.IsLiftable f\ni : B\n⊢ Eq ((cs.lift ⟨f, hf⟩) (cs.simple i)) (f i)","decl":"@[simp]\ntheorem lift_apply_simple {G : Type*} [Monoid G] {f : B → G} (hf : IsLiftable M f) (i : B) :\n    cs.lift ⟨f, hf⟩ (s i) = f i := congrFun (congrArg Subtype.val (cs.lift.left_inv ⟨f, hf⟩)) i\n\n"}
{"name":"CoxeterSystem.simple_determines_coxeterSystem","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\n⊢ Function.Injective CoxeterSystem.simple","decl":"/-- If two Coxeter systems on the same group `W` have the same Coxeter matrix `M : Matrix B B ℕ`\nand the same simple reflection map `B → W`, then they are identical. -/\ntheorem simple_determines_coxeterSystem :\n    Injective (simple : CoxeterSystem M W → B → W) := by\n  intro cs1 cs2 h\n  apply CoxeterSystem.ext\n  apply MulEquiv.toMonoidHom_injective\n  apply cs1.ext_simple\n  intro i\n  nth_rw 2 [h]\n  simp [simple]\n\n"}
{"name":"CoxeterSystem.wordProd_nil","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\n⊢ Eq (cs.wordProd List.nil) 1","decl":"@[simp] theorem wordProd_nil : π [] = 1 := by simp [wordProd]\n\n"}
{"name":"CoxeterSystem.wordProd_cons","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni : B\nω : List B\n⊢ Eq (cs.wordProd (List.cons i ω)) (HMul.hMul (cs.simple i) (cs.wordProd ω))","decl":"theorem wordProd_cons (i : B) (ω : List B) : π (i :: ω) = s i * π ω := by simp [wordProd]\n\n"}
{"name":"CoxeterSystem.wordProd_singleton","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni : B\n⊢ Eq (cs.wordProd (List.cons i List.nil)) (cs.simple i)","decl":"@[simp] theorem wordProd_singleton (i : B) : π ([i]) = s i := by simp [wordProd]\n\n"}
{"name":"CoxeterSystem.wordProd_concat","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni : B\nω : List B\n⊢ Eq (cs.wordProd (ω.concat i)) (HMul.hMul (cs.wordProd ω) (cs.simple i))","decl":"theorem wordProd_concat (i : B) (ω : List B) : π (ω.concat i) = π ω * s i := by simp [wordProd]\n\n"}
{"name":"CoxeterSystem.wordProd_append","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω ω' : List B\n⊢ Eq (cs.wordProd (HAppend.hAppend ω ω')) (HMul.hMul (cs.wordProd ω) (cs.wordProd ω'))","decl":"theorem wordProd_append (ω ω' : List B) : π (ω ++ ω') = π ω * π ω' := by simp [wordProd]\n\n"}
{"name":"CoxeterSystem.wordProd_reverse","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\n⊢ Eq (cs.wordProd ω.reverse) (Inv.inv (cs.wordProd ω))","decl":"@[simp] theorem wordProd_reverse (ω : List B) : π (reverse ω) = (π ω)⁻¹ := by\n  induction' ω with x ω' ih\n  · simp\n  · simpa [wordProd_cons, wordProd_append] using ih\n\n"}
{"name":"CoxeterSystem.wordProd_surjective","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\n⊢ Function.Surjective cs.wordProd","decl":"theorem wordProd_surjective : Surjective cs.wordProd := by\n  intro w\n  apply cs.simple_induction_left w\n  · use []\n    rw [wordProd_nil]\n  · rintro _ i ⟨ω, rfl⟩\n    use i :: ω\n    rw [wordProd_cons]\n\n"}
{"name":"CoxeterSystem.alternatingWord_succ","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\ni i' : B\nm : Nat\n⊢ Eq (CoxeterSystem.alternatingWord i i' (HAdd.hAdd m 1)) ((CoxeterSystem.alternatingWord i' i m).concat i')","decl":"theorem alternatingWord_succ (i i' : B) (m : ℕ) :\n    alternatingWord i i' (m + 1) = (alternatingWord i' i m).concat i' := rfl\n\n"}
{"name":"CoxeterSystem.alternatingWord_succ'","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\ni i' : B\nm : Nat\n⊢ Eq (CoxeterSystem.alternatingWord i i' (HAdd.hAdd m 1)) (List.cons (ite (Even m) i' i) (CoxeterSystem.alternatingWord i i' m))","decl":"theorem alternatingWord_succ' (i i' : B) (m : ℕ) :\n    alternatingWord i i' (m + 1) = (if Even m then i' else i) :: alternatingWord i i' m := by\n  induction' m with m ih generalizing i i'\n  · simp [alternatingWord]\n  · rw [alternatingWord]\n    nth_rw 1 [ih i' i]\n    rw [alternatingWord]\n    simp [Nat.even_add_one, ← Nat.not_even_iff_odd]\n\n"}
{"name":"CoxeterSystem.length_alternatingWord","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\ni i' : B\nm : Nat\n⊢ Eq (CoxeterSystem.alternatingWord i i' m).length m","decl":"@[simp]\ntheorem length_alternatingWord (i i' : B) (m : ℕ) :\n    List.length (alternatingWord i i' m) = m := by\n  induction' m with m ih generalizing i i'\n  · dsimp [alternatingWord]\n  · simpa [alternatingWord] using ih i' i\n\n"}
{"name":"CoxeterSystem.getElem_alternatingWord","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\ni j : B\np k : Nat\nhk : LT.lt k p\n⊢ Eq (GetElem.getElem (CoxeterSystem.alternatingWord i j p) k ⋯) (ite (Even (HAdd.hAdd p k)) i j)","decl":"lemma getElem_alternatingWord (i j : B) (p k : ℕ) (hk : k < p) :\n    (alternatingWord i j p)[k]'(by simp; exact hk) =  (if Even (p + k) then i else j) := by\n  revert k\n  induction p with\n  | zero =>\n    intro k hk\n    simp only [not_lt_zero'] at hk\n  | succ n h =>\n    intro k hk\n    simp_rw [alternatingWord_succ' i j n]\n    match k with\n    | 0 =>\n      by_cases h2 : Even n\n      · simp only [h2, ↓reduceIte, getElem_cons_zero, add_zero,\n        (by simp [Even.add_one, h2] : ¬Even (n + 1))]\n      · simp only [h2, ↓reduceIte, getElem_cons_zero, add_zero,\n        Odd.add_one (Nat.not_even_iff_odd.mp h2)]\n    | k + 1 =>\n      simp only [add_lt_add_iff_right] at hk h\n      simp only [getElem_cons_succ, h k hk]\n      ring_nf\n      have even_add_two (m : ℕ) : Even (2 + m) ↔ Even m := by\n        simp only [add_tsub_cancel_right, even_two, (Nat.even_sub (by omega : m ≤ 2 + m)).mp]\n      by_cases h_even : Even (n + k)\n      · rw [if_pos h_even]\n        rw [← even_add_two (n+k), ← Nat.add_assoc 2 n k] at h_even\n        rw [if_pos h_even]\n      · rw [if_neg h_even]\n        rw [← even_add_two (n+k), ← Nat.add_assoc 2 n k] at h_even\n        rw [if_neg h_even]\n\n"}
{"name":"CoxeterSystem.getElem_alternatingWord_swapIndices","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\ni j : B\np k : Nat\nh : LT.lt (HAdd.hAdd k 1) p\n⊢ Eq (GetElem.getElem (CoxeterSystem.alternatingWord i j p) (HAdd.hAdd k 1) ⋯) (GetElem.getElem (CoxeterSystem.alternatingWord j i p) k ⋯)","decl":"lemma getElem_alternatingWord_swapIndices (i j : B) (p k : ℕ) (h : k + 1 < p) :\n   (alternatingWord i j p)[k+1]'(by simp; exact h) =\n   (alternatingWord j i p)[k]'(by simp [h]; omega) := by\n  rw [getElem_alternatingWord i j p (k+1) (by omega), getElem_alternatingWord j i p k (by omega)]\n  by_cases h_even : Even (p + k)\n  · rw [if_pos h_even, ← add_assoc]\n    simp only [ite_eq_right_iff, isEmpty_Prop, Nat.not_even_iff_odd, Even.add_one h_even,\n      IsEmpty.forall_iff]\n  · rw [if_neg h_even, ← add_assoc]\n    simp [Odd.add_one (Nat.not_even_iff_odd.mp h_even)]\n\n"}
{"name":"CoxeterSystem.listTake_alternatingWord","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\ni j : B\np k : Nat\nh : LT.lt k (HMul.hMul 2 p)\n⊢ Eq (List.take k (CoxeterSystem.alternatingWord i j (HMul.hMul 2 p))) (ite (Even k) (CoxeterSystem.alternatingWord i j k) (CoxeterSystem.alternatingWord j i k))","decl":"lemma listTake_alternatingWord (i j : B) (p k : ℕ) (h : k < 2 * p) :\n    List.take k (alternatingWord i j (2 * p)) =\n    if Even k then alternatingWord i j k else alternatingWord j i k := by\n  induction k with\n    | zero =>\n      simp only [take_zero, Even.zero, ↓reduceIte, alternatingWord]\n    | succ k h' =>\n      have hk : k < 2 * p := by omega\n      apply h' at hk\n      by_cases h_even : Even k\n      · simp only [h_even, ↓reduceIte] at hk\n        simp only [Nat.not_even_iff_odd.mpr (Even.add_one h_even), ↓reduceIte]\n        rw [← List.take_concat_get _ _ (by simp[h]; omega), alternatingWord_succ, ← hk]\n        apply congr_arg\n        rw [getElem_alternatingWord i j (2*p) k (by omega)]\n        simp [(by apply Nat.even_add.mpr; simp[h_even]: Even (2 * p + k))]\n      · simp only [h_even, ↓reduceIte] at hk\n        simp only [(by simp at h_even; exact Odd.add_one h_even : Even (k + 1)), ↓reduceIte]\n        rw [← List.take_concat_get _ _ (by simp[h]; omega), alternatingWord_succ, hk]\n        apply congr_arg\n        rw [getElem_alternatingWord i j (2*p) k (by omega)]\n        simp [(by apply Nat.odd_add.mpr; simp[h_even]: Odd (2 * p + k))]\n\n"}
{"name":"CoxeterSystem.listTake_succ_alternatingWord","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\ni j : B\np k : Nat\nh : LT.lt (HAdd.hAdd k 1) (HMul.hMul 2 p)\n⊢ Eq (List.take (HAdd.hAdd k 1) (CoxeterSystem.alternatingWord i j (HMul.hMul 2 p))) (List.cons i (List.take k (CoxeterSystem.alternatingWord j i (HMul.hMul 2 p))))","decl":"lemma listTake_succ_alternatingWord (i j : B) (p : ℕ) (k : ℕ) (h : k + 1 < 2 * p) :\n    List.take (k + 1) (alternatingWord i j (2 * p)) =\n    i :: (List.take k (alternatingWord j i (2 * p))) := by\n  rw [listTake_alternatingWord j i p k (by omega), listTake_alternatingWord i j p (k+1) h]\n\n  by_cases h_even : Even k\n  · simp [h_even, Nat.not_even_iff_odd.mpr (Even.add_one h_even), alternatingWord_succ', h_even]\n  · simp [h_even, (by simp at h_even; exact Odd.add_one h_even: Even (k + 1)),\n    alternatingWord_succ', h_even]\n\n"}
{"name":"CoxeterSystem.prod_alternatingWord_eq_mul_pow","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni i' : B\nm : Nat\n⊢ Eq (cs.wordProd (CoxeterSystem.alternatingWord i i' m)) (HMul.hMul (ite (Even m) 1 (cs.simple i')) (HPow.hPow (HMul.hMul (cs.simple i) (cs.simple i')) (HDiv.hDiv m 2)))","decl":"theorem prod_alternatingWord_eq_mul_pow (i i' : B) (m : ℕ) :\n    π (alternatingWord i i' m) = (if Even m then 1 else s i') * (s i * s i') ^ (m / 2) := by\n  induction' m with m ih\n  · simp [alternatingWord]\n  · rw [alternatingWord_succ', wordProd_cons, ih]\n    by_cases hm : Even m\n    · have h₁ : ¬ Even (m + 1) := by simp [hm, parity_simps]\n      have h₂ : (m + 1) / 2 = m / 2 := Nat.succ_div_of_not_dvd <| by rwa [← even_iff_two_dvd]\n      simp [hm, h₁, h₂]\n    · have h₁ : Even (m + 1) := by simp [hm, parity_simps]\n      have h₂ : (m + 1) / 2 = m / 2 + 1 := Nat.succ_div_of_dvd h₁.two_dvd\n      simp [hm, h₁, h₂, ← pow_succ', ← mul_assoc]\n\n"}
{"name":"CoxeterSystem.prod_alternatingWord_eq_prod_alternatingWord_sub","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni i' : B\nm : Nat\nhm : LE.le m (HMul.hMul (M.M i i') 2)\n⊢ Eq (cs.wordProd (CoxeterSystem.alternatingWord i i' m)) (cs.wordProd (CoxeterSystem.alternatingWord i' i (HSub.hSub (HMul.hMul (M.M i i') 2) m)))","decl":"theorem prod_alternatingWord_eq_prod_alternatingWord_sub (i i' : B) (m : ℕ) (hm : m ≤ M i i' * 2) :\n    π (alternatingWord i i' m) = π (alternatingWord i' i (M i i' * 2 - m)) := by\n  simp_rw [prod_alternatingWord_eq_mul_pow, ← Int.even_coe_nat]\n\n  /- Rewrite everything in terms of an integer m' which is equal to m.\n  The resulting equation holds for all integers m'. -/\n  simp_rw [← zpow_natCast, Int.ofNat_ediv, Int.ofNat_sub hm]\n  generalize (m : ℤ) = m'\n  clear hm\n  push_cast\n\n  rcases Int.even_or_odd' m' with ⟨k, rfl | rfl⟩\n  · rw [if_pos (by use k; ring), if_pos (by use -k + (M i i'); ring), mul_comm 2 k, ← sub_mul]\n    repeat rw [Int.mul_ediv_cancel _ (by norm_num)]\n    rw [zpow_sub, zpow_natCast, simple_mul_simple_pow' cs i i', ← inv_zpow]\n    simp\n  · have : ¬Even (2 * k + 1) := Int.not_even_iff_odd.2 ⟨k, rfl⟩\n    rw [if_neg this]\n    have : ¬Even (↑(M i i') * 2 - (2 * k + 1)) :=\n      Int.not_even_iff_odd.2 ⟨↑(M i i') - k - 1, by ring⟩\n    rw [if_neg this]\n\n    rw [(by ring : ↑(M i i') * 2 - (2 * k + 1) = -1 + (-k + ↑(M i i')) * 2),\n      (by ring : 2 * k + 1 = 1 + k * 2)]\n    repeat rw [Int.add_mul_ediv_right _ _ (by norm_num)]\n    norm_num\n\n    rw [zpow_add, zpow_add, zpow_natCast, simple_mul_simple_pow', zpow_neg, ← inv_zpow, zpow_neg,\n      ← inv_zpow]\n    simp [← mul_assoc]\n\n"}
{"name":"CoxeterSystem.wordProd_braidWord_eq","module":"Mathlib.GroupTheory.Coxeter.Basic","initialProofState":"B : Type u_1\nW : Type u_3\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni i' : B\n⊢ Eq (cs.wordProd (CoxeterSystem.braidWord M i i')) (cs.wordProd (CoxeterSystem.braidWord M i' i))","decl":"/-- The two words of length `M i i'` that alternate between `i` and `i'` have the same product.\nThis is known as the \"braid relation\" or \"Artin-Tits relation\". -/\ntheorem wordProd_braidWord_eq (i i' : B) :\n    π (braidWord M i i') = π (braidWord M i' i) := by\n  have := cs.prod_alternatingWord_eq_prod_alternatingWord_sub i i' (M i i')\n    (Nat.le_mul_of_pos_right _ (by norm_num))\n  rw [tsub_eq_of_eq_add (mul_two (M i i'))] at this\n  nth_rw 2 [M.symmetric i i'] at this\n  exact this\n\n"}
