{"name":"Matroid.Flat.subset_of_basis_of_basis","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nF : Set α\nself : M.Flat F\nI X : Set α\na✝¹ : M.Basis I F\na✝ : M.Basis I X\n⊢ HasSubset.Subset X F","decl":"/-- A flat is a maximal set having a given basis  -/\n@[mk_iff]\nstructure Flat (M : Matroid α) (F : Set α) : Prop where\n  subset_of_basis_of_basis : ∀ ⦃I X⦄, M.Basis I F → M.Basis I X → X ⊆ F\n  subset_ground : F ⊆ M.E\n\n"}
{"name":"Matroid.flat_iff","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nF : Set α\n⊢ Iff (M.Flat F) (And (∀ ⦃I X : Set α⦄, M.Basis I F → M.Basis I X → HasSubset.Subset X F) (HasSubset.Subset F M.E))","decl":"/-- A flat is a maximal set having a given basis  -/\n@[mk_iff]\nstructure Flat (M : Matroid α) (F : Set α) : Prop where\n  subset_of_basis_of_basis : ∀ ⦃I X⦄, M.Basis I F → M.Basis I X → X ⊆ F\n  subset_ground : F ⊆ M.E\n\n"}
{"name":"Matroid.Flat.subset_ground","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nF : Set α\nself : M.Flat F\n⊢ HasSubset.Subset F M.E","decl":"/-- A flat is a maximal set having a given basis  -/\n@[mk_iff]\nstructure Flat (M : Matroid α) (F : Set α) : Prop where\n  subset_of_basis_of_basis : ∀ ⦃I X⦄, M.Basis I F → M.Basis I X → X ⊆ F\n  subset_ground : F ⊆ M.E\n\n"}
{"name":"Matroid.ground_flat","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\n⊢ M.Flat M.E","decl":"@[simp] lemma ground_flat (M : Matroid α) : M.Flat M.E :=\n  ⟨fun _ _ _ ↦ Basis.subset_ground, Subset.rfl⟩\n\n"}
{"name":"Matroid.Flat.iInter","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nι : Type u_3\ninst✝ : Nonempty ι\nFs : ι → Set α\nhFs : ∀ (i : ι), M.Flat (Fs i)\n⊢ M.Flat (Set.iInter fun i => Fs i)","decl":"lemma Flat.iInter {ι : Type*} [Nonempty ι] {Fs : ι → Set α}\n    (hFs : ∀ i, M.Flat (Fs i)) : M.Flat (⋂ i, Fs i) := by\n  refine ⟨fun I X hI hIX ↦ subset_iInter fun i ↦ ?_,\n    (iInter_subset _ (Classical.arbitrary _)).trans (hFs _).subset_ground⟩\n  obtain ⟨J, hIJ, hJ⟩ := hI.indep.subset_basis_of_subset (hI.subset.trans (iInter_subset _ i))\n  refine subset_union_right.trans ((hFs i).1 (X := Fs i ∪ X) hIJ ?_)\n  convert hIJ.basis_union (hIX.basis_union_of_subset hIJ.indep hJ) using 1\n  rw [← union_assoc, union_eq_self_of_subset_right hIJ.subset]\n\n"}
{"name":"Matroid.flat_iff_isClosed","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nF : Set α\n⊢ Iff (M.Flat F) (Exists fun h => M.subtypeClosure.IsClosed ⟨F, h⟩)","decl":"lemma flat_iff_isClosed : M.Flat F ↔ ∃ h : F ⊆ M.E, M.subtypeClosure.IsClosed ⟨F, h⟩ := by\n  simpa [subtypeClosure] using Flat.subset_ground\n\n"}
{"name":"Matroid.isClosed_iff_flat","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nF : ↑(Set.Iic M.E)\n⊢ Iff (M.subtypeClosure.IsClosed F) (M.Flat ↑F)","decl":"lemma isClosed_iff_flat {F : Iic M.E} : M.subtypeClosure.IsClosed F ↔ M.Flat F := by\n  simp [subtypeClosure]\n\n"}
{"name":"Matroid.closure_def","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\n⊢ Eq (M.closure X) (setOf fun F => And (M.Flat F) (HasSubset.Subset (Inter.inter X M.E) F)).sInter","decl":"lemma closure_def (M : Matroid α) (X : Set α) : M.closure X = ⋂₀ {F | M.Flat F ∧ X ∩ M.E ⊆ F} := rfl\n\n"}
{"name":"Matroid.closure_def'","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ Eq (M.closure X) (setOf fun F => And (M.Flat F) (HasSubset.Subset X F)).sInter","decl":"lemma closure_def' (M : Matroid α) (X : Set α) (hX : X ⊆ M.E := by aesop_mat) :\n    M.closure X = ⋂₀ {F | M.Flat F ∧ X ⊆ F} := by\n  rw [closure, inter_eq_self_of_subset_left hX]\n\n"}
{"name":"Matroid.closure_eq_subtypeClosure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\n⊢ Eq (M.closure X) ↑(M.subtypeClosure ⟨Inter.inter X M.E, ⋯⟩)","decl":"lemma closure_eq_subtypeClosure (M : Matroid α) (X : Set α) :\n    M.closure X = M.subtypeClosure ⟨X ∩ M.E, inter_subset_right⟩  := by\n  suffices ∀ (x : α), (∀ (t : Set α), M.Flat t → X ∩ M.E ⊆ t → x ∈ t) ↔\n    (x ∈ M.E ∧ ∀ a ⊆ M.E, X ∩ M.E ⊆ a → M.Flat a → x ∈ a) by\n    simpa [closure, subtypeClosure, Set.ext_iff]\n  exact fun x ↦ ⟨fun h ↦ ⟨h _ M.ground_flat inter_subset_right, fun F _ hXF hF ↦ h F hF hXF⟩,\n    fun ⟨_, h⟩ F hF hXF ↦ h F hF.subset_ground hXF hF⟩\n\n"}
{"name":"Matroid.closure_subset_ground","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\n⊢ HasSubset.Subset (M.closure X) M.E","decl":"@[aesop unsafe 10% (rule_sets := [Matroid])]\nlemma closure_subset_ground (M : Matroid α) (X : Set α) : M.closure X ⊆ M.E :=\n  sInter_subset_of_mem ⟨M.ground_flat, inter_subset_right⟩\n\n"}
{"name":"Matroid.ground_subset_closure_iff","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\n⊢ Iff (HasSubset.Subset M.E (M.closure X)) (Eq (M.closure X) M.E)","decl":"@[simp] lemma ground_subset_closure_iff : M.E ⊆ M.closure X ↔ M.closure X = M.E := by\n  simp [M.closure_subset_ground X, subset_antisymm_iff]\n\n"}
{"name":"Matroid.closure_inter_ground","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\n⊢ Eq (M.closure (Inter.inter X M.E)) (M.closure X)","decl":"@[simp] lemma closure_inter_ground (M : Matroid α) (X : Set α) :\n    M.closure (X ∩ M.E) = M.closure X := by\n  simp_rw [closure_def, inter_assoc, inter_self]\n\n"}
{"name":"Matroid.inter_ground_subset_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\n⊢ HasSubset.Subset (Inter.inter X M.E) (M.closure X)","decl":"lemma inter_ground_subset_closure (M : Matroid α) (X : Set α) : X ∩ M.E ⊆ M.closure X := by\n  simp_rw [closure_def, subset_sInter_iff]; simp\n\n"}
{"name":"Matroid.mem_closure_iff_forall_mem_flat","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\ne : α\nX : Set α\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ Iff (Membership.mem (M.closure X) e) (∀ (F : Set α), M.Flat F → HasSubset.Subset X F → Membership.mem F e)","decl":"lemma mem_closure_iff_forall_mem_flat (X : Set α) (hX : X ⊆ M.E := by aesop_mat) :\n    e ∈ M.closure X ↔ ∀ F, M.Flat F → X ⊆ F → e ∈ F := by\n  simp_rw [M.closure_def' X, mem_sInter, mem_setOf, and_imp]\n\n"}
{"name":"Matroid.subset_closure_iff_forall_subset_flat","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nY X : Set α\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ Iff (HasSubset.Subset Y (M.closure X)) (∀ (F : Set α), M.Flat F → HasSubset.Subset X F → HasSubset.Subset Y F)","decl":"lemma subset_closure_iff_forall_subset_flat (X : Set α) (hX : X ⊆ M.E := by aesop_mat) :\n    Y ⊆ M.closure X ↔ ∀ F, M.Flat F → X ⊆ F → Y ⊆ F := by\n  simp_rw [M.closure_def' X, subset_sInter_iff, mem_setOf, and_imp]\n\n"}
{"name":"Matroid.subset_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ HasSubset.Subset X (M.closure X)","decl":"lemma subset_closure (M : Matroid α) (X : Set α) (hX : X ⊆ M.E := by aesop_mat) :\n    X ⊆ M.closure X := by\n  simp [M.closure_def' X, subset_sInter_iff]\n\n"}
{"name":"Matroid.Flat.closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nF : Set α\nhF : M.Flat F\n⊢ Eq (M.closure F) F","decl":"lemma Flat.closure (hF : M.Flat F) : M.closure F = F :=\n  (sInter_subset_of_mem (by simpa)).antisymm (M.subset_closure F)\n\n"}
{"name":"Matroid.closure_ground","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\n⊢ Eq (M.closure M.E) M.E","decl":"@[simp] lemma closure_ground (M : Matroid α) : M.closure M.E = M.E :=\n  (M.closure_subset_ground M.E).antisymm (M.subset_closure M.E)\n\n"}
{"name":"Matroid.closure_univ","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\n⊢ Eq (M.closure Set.univ) M.E","decl":"@[simp] lemma closure_univ (M : Matroid α) : M.closure univ = M.E := by\n  rw [← closure_inter_ground, univ_inter, closure_ground]\n\n"}
{"name":"Matroid.closure_subset_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nX Y : Set α\nM : Matroid α\nh : HasSubset.Subset X Y\n⊢ HasSubset.Subset (M.closure X) (M.closure Y)","decl":"@[gcongr]\nlemma closure_subset_closure (M : Matroid α) (h : X ⊆ Y) : M.closure X ⊆ M.closure Y :=\n  subset_sInter (fun _ h' ↦ sInter_subset_of_mem\n    ⟨h'.1, subset_trans (inter_subset_inter_left _ h) h'.2⟩)\n\n"}
{"name":"Matroid.closure_mono","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\n⊢ Monotone M.closure","decl":"lemma closure_mono (M : Matroid α) : Monotone M.closure :=\n  fun _ _ ↦ M.closure_subset_closure\n\n"}
{"name":"Matroid.closure_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\n⊢ Eq (M.closure (M.closure X)) (M.closure X)","decl":"@[simp] lemma closure_closure (M : Matroid α) (X : Set α) : M.closure (M.closure X) = M.closure X :=\n  (M.subset_closure _).antisymm' (subset_sInter\n    (fun F hF ↦ (closure_subset_closure _ (sInter_subset_of_mem hF)).trans hF.1.closure.subset))\n\n"}
{"name":"Matroid.closure_subset_closure_of_subset_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX Y : Set α\nhXY : HasSubset.Subset X (M.closure Y)\n⊢ HasSubset.Subset (M.closure X) (M.closure Y)","decl":"lemma closure_subset_closure_of_subset_closure (hXY : X ⊆ M.closure Y) :\n    M.closure X ⊆ M.closure Y :=\n  (M.closure_subset_closure hXY).trans_eq (M.closure_closure Y)\n\n"}
{"name":"Matroid.closure_subset_closure_iff_subset_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX Y : Set α\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ Iff (HasSubset.Subset (M.closure X) (M.closure Y)) (HasSubset.Subset X (M.closure Y))","decl":"lemma closure_subset_closure_iff_subset_closure (hX : X ⊆ M.E := by aesop_mat) :\n    M.closure X ⊆ M.closure Y ↔ X ⊆ M.closure Y :=\n  ⟨(M.subset_closure X).trans, closure_subset_closure_of_subset_closure⟩\n\n"}
{"name":"Matroid.subset_closure_of_subset","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nX Y : Set α\nM : Matroid α\nhXY : HasSubset.Subset X Y\nhY : autoParam (HasSubset.Subset Y M.E) _auto✝\n⊢ HasSubset.Subset X (M.closure Y)","decl":"lemma subset_closure_of_subset (M : Matroid α) (hXY : X ⊆ Y) (hY : Y ⊆ M.E := by aesop_mat) :\n    X ⊆ M.closure Y :=\n  hXY.trans (M.subset_closure Y)\n\n"}
{"name":"Matroid.subset_closure_of_subset'","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nX Y : Set α\nM : Matroid α\nhXY : HasSubset.Subset X Y\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ HasSubset.Subset X (M.closure Y)","decl":"lemma subset_closure_of_subset' (M : Matroid α) (hXY : X ⊆ Y) (hX : X ⊆ M.E := by aesop_mat) :\n    X ⊆ M.closure Y := by\n  rw [← closure_inter_ground]; exact M.subset_closure_of_subset (subset_inter hXY hX)\n\n"}
{"name":"Matroid.exists_of_closure_ssubset","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX Y : Set α\nhXY : HasSSubset.SSubset (M.closure X) (M.closure Y)\n⊢ Exists fun e => And (Membership.mem Y e) (Not (Membership.mem (M.closure X) e))","decl":"lemma exists_of_closure_ssubset (hXY : M.closure X ⊂ M.closure Y) : ∃ e ∈ Y, e ∉ M.closure X := by\n  by_contra! hcon\n  exact hXY.not_subset (M.closure_subset_closure_of_subset_closure hcon)\n\n"}
{"name":"Matroid.mem_closure_of_mem","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nX : Set α\ne : α\nM : Matroid α\nh : Membership.mem X e\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ Membership.mem (M.closure X) e","decl":"lemma mem_closure_of_mem (M : Matroid α) (h : e ∈ X) (hX : X ⊆ M.E := by aesop_mat) :\n    e ∈ M.closure X :=\n  (M.subset_closure X) h\n\n"}
{"name":"Matroid.mem_closure_of_mem'","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nX : Set α\ne : α\nM : Matroid α\nheX : Membership.mem X e\nh : autoParam (Membership.mem M.E e) _auto✝\n⊢ Membership.mem (M.closure X) e","decl":"lemma mem_closure_of_mem' (M : Matroid α) (heX : e ∈ X) (h : e ∈ M.E := by aesop_mat) :\n    e ∈ M.closure X := by\n  rw [← closure_inter_ground]\n  exact M.mem_closure_of_mem ⟨heX, h⟩\n\n"}
{"name":"Matroid.not_mem_of_mem_diff_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\ne : α\nhe : Membership.mem (SDiff.sdiff M.E (M.closure X)) e\n⊢ Not (Membership.mem X e)","decl":"lemma not_mem_of_mem_diff_closure (he : e ∈ M.E \\ M.closure X) : e ∉ X :=\n  fun heX ↦ he.2 <| M.mem_closure_of_mem' heX he.1\n\n"}
{"name":"Matroid.mem_ground_of_mem_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\ne : α\nhe : Membership.mem (M.closure X) e\n⊢ Membership.mem M.E e","decl":"@[aesop unsafe 10% (rule_sets := [Matroid])]\nlemma mem_ground_of_mem_closure (he : e ∈ M.closure X) : e ∈ M.E :=\n  (M.closure_subset_ground _) he\n\n"}
{"name":"Matroid.closure_iUnion_closure_eq_closure_iUnion","module":"Mathlib.Data.Matroid.Closure","initialProofState":"ι : Type u_1\nα : Type u_2\nM : Matroid α\nXs : ι → Set α\n⊢ Eq (M.closure (Set.iUnion fun i => M.closure (Xs i))) (M.closure (Set.iUnion fun i => Xs i))","decl":"lemma closure_iUnion_closure_eq_closure_iUnion (M : Matroid α) (Xs : ι → Set α) :\n    M.closure (⋃ i, M.closure (Xs i)) = M.closure (⋃ i, Xs i) := by\n  simp_rw [closure_eq_subtypeClosure, iUnion_inter, Subtype.coe_inj]\n  convert M.subtypeClosure.closure_iSup_closure (fun i ↦ ⟨Xs i ∩ M.E, inter_subset_right⟩) <;>\n  simp [← iUnion_inter, subtypeClosure]\n\n"}
{"name":"Matroid.closure_iUnion_congr","module":"Mathlib.Data.Matroid.Closure","initialProofState":"ι : Type u_1\nα : Type u_2\nM : Matroid α\nXs Ys : ι → Set α\nh : ∀ (i : ι), Eq (M.closure (Xs i)) (M.closure (Ys i))\n⊢ Eq (M.closure (Set.iUnion fun i => Xs i)) (M.closure (Set.iUnion fun i => Ys i))","decl":"lemma closure_iUnion_congr (Xs Ys : ι → Set α) (h : ∀ i, M.closure (Xs i) = M.closure (Ys i)) :\n    M.closure (⋃ i, Xs i) = M.closure (⋃ i, Ys i) := by\n  simp [h, ← M.closure_iUnion_closure_eq_closure_iUnion]\n\n"}
{"name":"Matroid.closure_biUnion_closure_eq_closure_sUnion","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nXs : Set (Set α)\n⊢ Eq (M.closure (Set.iUnion fun X => Set.iUnion fun h => M.closure X)) (M.closure Xs.sUnion)","decl":"lemma closure_biUnion_closure_eq_closure_sUnion (M : Matroid α) (Xs : Set (Set α)) :\n    M.closure (⋃ X ∈ Xs, M.closure X) = M.closure (⋃₀ Xs) := by\n  rw [sUnion_eq_iUnion, biUnion_eq_iUnion, closure_iUnion_closure_eq_closure_iUnion]\n\n"}
{"name":"Matroid.closure_biUnion_closure_eq_closure_biUnion","module":"Mathlib.Data.Matroid.Closure","initialProofState":"ι : Type u_1\nα : Type u_2\nM : Matroid α\nXs : ι → Set α\nA : Set ι\n⊢ Eq (M.closure (Set.iUnion fun i => Set.iUnion fun h => M.closure (Xs i))) (M.closure (Set.iUnion fun i => Set.iUnion fun h => Xs i))","decl":"lemma closure_biUnion_closure_eq_closure_biUnion (M : Matroid α) (Xs : ι → Set α) (A : Set ι) :\n    M.closure (⋃ i ∈ A, M.closure (Xs i)) = M.closure (⋃ i ∈ A, Xs i) := by\n  rw [biUnion_eq_iUnion, M.closure_iUnion_closure_eq_closure_iUnion, biUnion_eq_iUnion]\n\n"}
{"name":"Matroid.closure_biUnion_congr","module":"Mathlib.Data.Matroid.Closure","initialProofState":"ι : Type u_1\nα : Type u_2\nM : Matroid α\nXs Ys : ι → Set α\nA : Set ι\nh : ∀ (i : ι), Membership.mem A i → Eq (M.closure (Xs i)) (M.closure (Ys i))\n⊢ Eq (M.closure (Set.iUnion fun i => Set.iUnion fun h => Xs i)) (M.closure (Set.iUnion fun i => Set.iUnion fun h => Ys i))","decl":"lemma closure_biUnion_congr (M : Matroid α) (Xs Ys : ι → Set α) (A : Set ι)\n    (h : ∀ i ∈ A, M.closure (Xs i) = M.closure (Ys i)) :\n    M.closure (⋃ i ∈ A, Xs i) = M.closure (⋃ i ∈ A, Ys i) := by\n  rw [← closure_biUnion_closure_eq_closure_biUnion, iUnion₂_congr h,\n    closure_biUnion_closure_eq_closure_biUnion]\n\n"}
{"name":"Matroid.closure_closure_union_closure_eq_closure_union","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX Y : Set α\n⊢ Eq (M.closure (Union.union (M.closure X) (M.closure Y))) (M.closure (Union.union X Y))","decl":"lemma closure_closure_union_closure_eq_closure_union (M : Matroid α) (X Y : Set α) :\n    M.closure (M.closure X ∪ M.closure Y) = M.closure (X ∪ Y) := by\n  rw [eq_comm, union_eq_iUnion, ← closure_iUnion_closure_eq_closure_iUnion, union_eq_iUnion]\n  simp_rw [Bool.cond_eq_ite, apply_ite]\n\n"}
{"name":"Matroid.closure_union_closure_right_eq","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX Y : Set α\n⊢ Eq (M.closure (Union.union X (M.closure Y))) (M.closure (Union.union X Y))","decl":"@[simp] lemma closure_union_closure_right_eq (M : Matroid α) (X Y : Set α) :\n    M.closure (X ∪ M.closure Y) = M.closure (X ∪ Y) := by\n  rw [← closure_closure_union_closure_eq_closure_union, closure_closure,\n    closure_closure_union_closure_eq_closure_union]\n\n"}
{"name":"Matroid.closure_union_closure_left_eq","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX Y : Set α\n⊢ Eq (M.closure (Union.union (M.closure X) Y)) (M.closure (Union.union X Y))","decl":"@[simp] lemma closure_union_closure_left_eq (M : Matroid α) (X Y : Set α) :\n    M.closure (M.closure X ∪ Y) = M.closure (X ∪ Y) := by\n  rw [← closure_closure_union_closure_eq_closure_union, closure_closure,\n    closure_closure_union_closure_eq_closure_union]\n\n"}
{"name":"Matroid.closure_insert_closure_eq_closure_insert","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\ne : α\nX : Set α\n⊢ Eq (M.closure (Insert.insert e (M.closure X))) (M.closure (Insert.insert e X))","decl":"@[simp] lemma closure_insert_closure_eq_closure_insert (M : Matroid α) (e : α) (X : Set α) :\n    M.closure (insert e (M.closure X)) = M.closure (insert e X) := by\n  simp_rw [← singleton_union, closure_union_closure_right_eq]\n\n"}
{"name":"Matroid.closure_union_congr_left","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX Y X' : Set α\nh : Eq (M.closure X) (M.closure X')\n⊢ Eq (M.closure (Union.union X Y)) (M.closure (Union.union X' Y))","decl":"lemma closure_union_congr_left {X' : Set α} (h : M.closure X = M.closure X') :\n    M.closure (X ∪ Y) = M.closure (X' ∪ Y) := by\n  rw [← M.closure_union_closure_left_eq, h, M.closure_union_closure_left_eq]\n\n"}
{"name":"Matroid.closure_union_congr_right","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX Y Y' : Set α\nh : Eq (M.closure Y) (M.closure Y')\n⊢ Eq (M.closure (Union.union X Y)) (M.closure (Union.union X Y'))","decl":"lemma closure_union_congr_right {Y' : Set α} (h : M.closure Y = M.closure Y') :\n    M.closure (X ∪ Y) = M.closure (X ∪ Y') := by\n  rw [← M.closure_union_closure_right_eq, h, M.closure_union_closure_right_eq]\n\n"}
{"name":"Matroid.closure_insert_congr_right","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX Y : Set α\ne : α\nh : Eq (M.closure X) (M.closure Y)\n⊢ Eq (M.closure (Insert.insert e X)) (M.closure (Insert.insert e Y))","decl":"lemma closure_insert_congr_right (h : M.closure X = M.closure Y) :\n    M.closure (insert e X) = M.closure (insert e Y) := by\n  simp [← union_singleton, closure_union_congr_left h]\n\n"}
{"name":"Matroid.closure_union_closure_empty_eq","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\n⊢ Eq (Union.union (M.closure X) (M.closure EmptyCollection.emptyCollection)) (M.closure X)","decl":"@[simp] lemma closure_union_closure_empty_eq (M : Matroid α) (X : Set α) :\n    M.closure X ∪ M.closure ∅ = M.closure X :=\n  union_eq_self_of_subset_right (M.closure_subset_closure (empty_subset _))\n\n"}
{"name":"Matroid.closure_empty_union_closure_eq","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\n⊢ Eq (Union.union (M.closure EmptyCollection.emptyCollection) (M.closure X)) (M.closure X)","decl":"@[simp] lemma closure_empty_union_closure_eq (M : Matroid α) (X : Set α) :\n    M.closure ∅ ∪ M.closure X = M.closure X :=\n  union_eq_self_of_subset_left (M.closure_subset_closure (empty_subset _))\n\n"}
{"name":"Matroid.closure_insert_eq_of_mem_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\ne : α\nhe : Membership.mem (M.closure X) e\n⊢ Eq (M.closure (Insert.insert e X)) (M.closure X)","decl":"lemma closure_insert_eq_of_mem_closure (he : e ∈ M.closure X) :\n    M.closure (insert e X) = M.closure X := by\n  rw [← closure_insert_closure_eq_closure_insert, insert_eq_of_mem he, closure_closure]\n\n"}
{"name":"Matroid.mem_closure_self","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\ne : α\nhe : autoParam (Membership.mem M.E e) _auto✝\n⊢ Membership.mem (M.closure (Singleton.singleton e)) e","decl":"lemma mem_closure_self (M : Matroid α) (e : α) (he : e ∈ M.E := by aesop_mat) : e ∈ M.closure {e} :=\n  mem_closure_of_mem' M rfl\n\n"}
{"name":"Matroid.Indep.closure_eq_setOf_basis_insert","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI : Set α\nhI : M.Indep I\n⊢ Eq (M.closure I) (setOf fun x => M.Basis I (Insert.insert x I))","decl":"lemma Indep.closure_eq_setOf_basis_insert (hI : M.Indep I) :\n    M.closure I = {x | M.Basis I (insert x I)} := by\n  set F := {x | M.Basis I (insert x I)}\n  have hIF : M.Basis I F := hI.basis_setOf_insert_basis\n\n  have hF : M.Flat F := by\n    refine ⟨fun J X hJF hJX e heX ↦ show M.Basis _ _ from ?_, hIF.subset_ground⟩\n    exact (hIF.basis_of_basis_of_subset_of_subset (hJX.basis_union hJF) hJF.subset\n      (hIF.subset.trans subset_union_right)).basis_subset (subset_insert _ _)\n      (insert_subset (Or.inl heX) (hIF.subset.trans subset_union_right))\n\n  rw [subset_antisymm_iff, closure_def, subset_sInter_iff, and_iff_right (sInter_subset_of_mem _)]\n  · rintro F' ⟨hF', hIF'⟩ e (he : M.Basis I (insert e I))\n    rw [inter_eq_left.mpr (hIF.subset.trans hIF.subset_ground)] at hIF'\n    obtain ⟨J, hJ, hIJ⟩ := hI.subset_basis_of_subset hIF' hF'.2\n    exact (hF'.1 hJ (he.basis_union_of_subset hJ.indep hIJ)) (Or.inr (mem_insert _ _))\n  exact ⟨hF, inter_subset_left.trans hIF.subset⟩\n\n"}
{"name":"Matroid.Indep.insert_basis_iff_mem_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\ne : α\nI : Set α\nhI : M.Indep I\n⊢ Iff (M.Basis I (Insert.insert e I)) (Membership.mem (M.closure I) e)","decl":"lemma Indep.insert_basis_iff_mem_closure (hI : M.Indep I) :\n    M.Basis I (insert e I) ↔ e ∈ M.closure I := by\n  rw [hI.closure_eq_setOf_basis_insert, mem_setOf]\n\n"}
{"name":"Matroid.Indep.basis_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI : Set α\nhI : M.Indep I\n⊢ M.Basis I (M.closure I)","decl":"lemma Indep.basis_closure (hI : M.Indep I) : M.Basis I (M.closure I) := by\n  rw [hI.closure_eq_setOf_basis_insert]; exact hI.basis_setOf_insert_basis\n\n"}
{"name":"Matroid.Basis.closure_eq_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX I : Set α\nh : M.Basis I X\n⊢ Eq (M.closure I) (M.closure X)","decl":"lemma Basis.closure_eq_closure (h : M.Basis I X) : M.closure I = M.closure X := by\n  refine subset_antisymm (M.closure_subset_closure h.subset) ?_\n  rw [← M.closure_closure I, h.indep.closure_eq_setOf_basis_insert]\n  exact M.closure_subset_closure fun e he ↦ (h.basis_subset (subset_insert _ _)\n    (insert_subset he h.subset))\n\n"}
{"name":"Matroid.Basis.closure_eq_right","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX I : Set α\nh : M.Basis I (M.closure X)\n⊢ Eq (M.closure I) (M.closure X)","decl":"lemma Basis.closure_eq_right (h : M.Basis I (M.closure X)) : M.closure I = M.closure X :=\n  M.closure_closure X ▸ h.closure_eq_closure\n\n"}
{"name":"Matroid.Basis'.closure_eq_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX I : Set α\nh : M.Basis' I X\n⊢ Eq (M.closure I) (M.closure X)","decl":"lemma Basis'.closure_eq_closure (h : M.Basis' I X) : M.closure I = M.closure X := by\n  rw [← closure_inter_ground _ X, h.basis_inter_ground.closure_eq_closure]\n\n"}
{"name":"Matroid.Basis.subset_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX I : Set α\nh : M.Basis I X\n⊢ HasSubset.Subset X (M.closure I)","decl":"lemma Basis.subset_closure (h : M.Basis I X) : X ⊆ M.closure I := by\n  rw [← closure_subset_closure_iff_subset_closure, h.closure_eq_closure]\n\n"}
{"name":"Matroid.Basis'.basis_closure_right","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX I : Set α\nh : M.Basis' I X\n⊢ M.Basis I (M.closure X)","decl":"lemma Basis'.basis_closure_right (h : M.Basis' I X) : M.Basis I (M.closure X) := by\n  rw [← h.closure_eq_closure]; exact h.indep.basis_closure\n\n"}
{"name":"Matroid.Basis.basis_closure_right","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX I : Set α\nh : M.Basis I X\n⊢ M.Basis I (M.closure X)","decl":"lemma Basis.basis_closure_right (h : M.Basis I X) : M.Basis I (M.closure X) :=\n  h.basis'.basis_closure_right\n\n"}
{"name":"Matroid.Indep.mem_closure_iff","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI : Set α\nx : α\nhI : M.Indep I\n⊢ Iff (Membership.mem (M.closure I) x) (Or (M.Dep (Insert.insert x I)) (Membership.mem I x))","decl":"lemma Indep.mem_closure_iff (hI : M.Indep I) :\n    x ∈ M.closure I ↔ M.Dep (insert x I) ∨ x ∈ I := by\n  rwa [hI.closure_eq_setOf_basis_insert, mem_setOf, basis_insert_iff]\n\n"}
{"name":"Matroid.Indep.mem_closure_iff'","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI : Set α\nx : α\nhI : M.Indep I\n⊢ Iff (Membership.mem (M.closure I) x) (And (Membership.mem M.E x) (M.Indep (Insert.insert x I) → Membership.mem I x))","decl":"lemma Indep.mem_closure_iff' (hI : M.Indep I) :\n    x ∈ M.closure I ↔ x ∈ M.E ∧ (M.Indep (insert x I) → x ∈ I) := by\n  rw [hI.mem_closure_iff, dep_iff, insert_subset_iff, and_iff_left hI.subset_ground,\n    imp_iff_not_or]\n  have := hI.subset_ground\n  aesop\n\n"}
{"name":"Matroid.Indep.insert_dep_iff","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\ne : α\nI : Set α\nhI : M.Indep I\n⊢ Iff (M.Dep (Insert.insert e I)) (Membership.mem (SDiff.sdiff (M.closure I) I) e)","decl":"lemma Indep.insert_dep_iff (hI : M.Indep I) : M.Dep (insert e I) ↔ e ∈ M.closure I \\ I := by\n  rw [mem_diff, hI.mem_closure_iff, or_and_right, and_not_self_iff, or_false,\n    iff_self_and, imp_not_comm]\n  intro heI; rw [insert_eq_of_mem heI]; exact hI.not_dep\n\n"}
{"name":"Matroid.Indep.mem_closure_iff_of_not_mem","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\ne : α\nI : Set α\nhI : M.Indep I\nheI : Not (Membership.mem I e)\n⊢ Iff (Membership.mem (M.closure I) e) (M.Dep (Insert.insert e I))","decl":"lemma Indep.mem_closure_iff_of_not_mem (hI : M.Indep I) (heI : e ∉ I) :\n    e ∈ M.closure I ↔ M.Dep (insert e I) := by\n  rw [hI.insert_dep_iff, mem_diff, and_iff_left heI]\n\n"}
{"name":"Matroid.Indep.not_mem_closure_iff","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\ne : α\nI : Set α\nhI : M.Indep I\nhe : autoParam (Membership.mem M.E e) _auto✝\n⊢ Iff (Not (Membership.mem (M.closure I) e)) (And (M.Indep (Insert.insert e I)) (Not (Membership.mem I e)))","decl":"lemma Indep.not_mem_closure_iff (hI : M.Indep I) (he : e ∈ M.E := by aesop_mat) :\n    e ∉ M.closure I ↔ M.Indep (insert e I) ∧ e ∉ I := by\n  rw [hI.mem_closure_iff, dep_iff, insert_subset_iff, and_iff_right he,\n    and_iff_left hI.subset_ground]; tauto\n\n"}
{"name":"Matroid.Indep.not_mem_closure_iff_of_not_mem","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\ne : α\nI : Set α\nhI : M.Indep I\nheI : Not (Membership.mem I e)\nhe : autoParam (Membership.mem M.E e) _auto✝\n⊢ Iff (Not (Membership.mem (M.closure I) e)) (M.Indep (Insert.insert e I))","decl":"lemma Indep.not_mem_closure_iff_of_not_mem (hI : M.Indep I) (heI : e ∉ I)\n    (he : e ∈ M.E := by aesop_mat) : e ∉ M.closure I ↔ M.Indep (insert e I) := by\n  rw [hI.not_mem_closure_iff, and_iff_left heI]\n\n"}
{"name":"Matroid.Indep.insert_indep_iff_of_not_mem","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\ne : α\nI : Set α\nhI : M.Indep I\nheI : Not (Membership.mem I e)\n⊢ Iff (M.Indep (Insert.insert e I)) (Membership.mem (SDiff.sdiff M.E (M.closure I)) e)","decl":"lemma Indep.insert_indep_iff_of_not_mem (hI : M.Indep I) (heI : e ∉ I) :\n    M.Indep (insert e I) ↔ e ∈ M.E \\ M.closure I := by\n  rw [mem_diff, hI.mem_closure_iff_of_not_mem heI, dep_iff, not_and, not_imp_not, insert_subset_iff,\n    and_iff_left hI.subset_ground]\n  exact ⟨fun h ↦ ⟨h.subset_ground (mem_insert e I), fun _ ↦ h⟩, fun h ↦ h.2 h.1⟩\n\n"}
{"name":"Matroid.Indep.insert_indep_iff","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\ne : α\nI : Set α\nhI : M.Indep I\n⊢ Iff (M.Indep (Insert.insert e I)) (Or (Membership.mem (SDiff.sdiff M.E (M.closure I)) e) (Membership.mem I e))","decl":"lemma Indep.insert_indep_iff (hI : M.Indep I) :\n    M.Indep (insert e I) ↔ e ∈ M.E \\ M.closure I ∨ e ∈ I := by\n  obtain (h | h) := em (e ∈ I)\n  · simp_rw [insert_eq_of_mem h, iff_true_intro hI, true_iff, iff_true_intro h, or_true]\n  rw [hI.insert_indep_iff_of_not_mem h, or_iff_left h]\n\n"}
{"name":"Matroid.insert_indep_iff","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\ne : α\nI : Set α\n⊢ Iff (M.Indep (Insert.insert e I)) (And (M.Indep I) (Not (Membership.mem I e) → Membership.mem (SDiff.sdiff M.E (M.closure I)) e))","decl":"lemma insert_indep_iff : M.Indep (insert e I) ↔ M.Indep I ∧ (e ∉ I → e ∈ M.E \\ M.closure I) := by\n  by_cases hI : M.Indep I\n  · rw [hI.insert_indep_iff, and_iff_right hI, or_iff_not_imp_right]\n  simp [hI, show ¬ M.Indep (insert e I) from fun h ↦ hI <| h.subset <| subset_insert _ _]\n\n"}
{"name":"Matroid.Indep.insert_diff_indep_iff","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\ne f : α\nI : Set α\nhI : M.Indep (SDiff.sdiff I (Singleton.singleton e))\nheI : Membership.mem I e\n⊢ Iff (M.Indep (SDiff.sdiff (Insert.insert f I) (Singleton.singleton e))) (Or (Membership.mem (SDiff.sdiff M.E (M.closure (SDiff.sdiff I (Singleton.singleton e)))) f) (Membership.mem I f))","decl":"/-- This can be used for rewriting if the LHS is inside a binder and whether `f = e` is unknown.-/\nlemma Indep.insert_diff_indep_iff (hI : M.Indep (I \\ {e})) (heI : e ∈ I) :\n    M.Indep (insert f I \\ {e}) ↔ f ∈ M.E \\ M.closure (I \\ {e}) ∨ f ∈ I := by\n  obtain rfl | hne := eq_or_ne e f\n  · simp [hI, heI]\n  rw [← insert_diff_singleton_comm hne.symm, hI.insert_indep_iff, mem_diff_singleton,\n    and_iff_left hne.symm]\n\n"}
{"name":"Matroid.Indep.basis_of_subset_of_subset_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX I : Set α\nhI : M.Indep I\nhIX : HasSubset.Subset I X\nhXI : HasSubset.Subset X (M.closure I)\n⊢ M.Basis I X","decl":"lemma Indep.basis_of_subset_of_subset_closure (hI : M.Indep I) (hIX : I ⊆ X)\n    (hXI : X ⊆ M.closure I) : M.Basis I X :=\n  hI.basis_closure.basis_subset hIX hXI\n\n"}
{"name":"Matroid.basis_iff_indep_subset_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX I : Set α\n⊢ Iff (M.Basis I X) (And (M.Indep I) (And (HasSubset.Subset I X) (HasSubset.Subset X (M.closure I))))","decl":"lemma basis_iff_indep_subset_closure : M.Basis I X ↔ M.Indep I ∧ I ⊆ X ∧ X ⊆ M.closure I :=\n  ⟨fun h ↦ ⟨h.indep, h.subset, h.subset_closure⟩,\n    fun h ↦ h.1.basis_of_subset_of_subset_closure h.2.1 h.2.2⟩\n\n"}
{"name":"Matroid.Indep.base_of_ground_subset_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI : Set α\nhI : M.Indep I\nh : HasSubset.Subset M.E (M.closure I)\n⊢ M.Base I","decl":"lemma Indep.base_of_ground_subset_closure (hI : M.Indep I) (h : M.E ⊆ M.closure I) : M.Base I := by\n  rw [← basis_ground_iff]; exact hI.basis_of_subset_of_subset_closure hI.subset_ground h\n\n"}
{"name":"Matroid.Base.closure_eq","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nB : Set α\nhB : M.Base B\n⊢ Eq (M.closure B) M.E","decl":"lemma Base.closure_eq (hB : M.Base B) : M.closure B = M.E := by\n  rw [← basis_ground_iff] at hB; rw [hB.closure_eq_closure, closure_ground]\n\n"}
{"name":"Matroid.Base.closure_of_superset","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX B : Set α\nhB : M.Base B\nhBX : HasSubset.Subset B X\n⊢ Eq (M.closure X) M.E","decl":"lemma Base.closure_of_superset (hB : M.Base B) (hBX : B ⊆ X) : M.closure X = M.E :=\n  (M.closure_subset_ground _).antisymm (hB.closure_eq ▸ M.closure_subset_closure hBX)\n\n"}
{"name":"Matroid.base_iff_indep_closure_eq","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nB : Set α\n⊢ Iff (M.Base B) (And (M.Indep B) (Eq (M.closure B) M.E))","decl":"lemma base_iff_indep_closure_eq : M.Base B ↔ M.Indep B ∧ M.closure B = M.E := by\n  rw [← basis_ground_iff, basis_iff_indep_subset_closure, and_congr_right_iff]\n  exact fun hI ↦ ⟨fun h ↦ (M.closure_subset_ground _).antisymm h.2,\n    fun h ↦ ⟨(M.subset_closure B).trans_eq h, h.symm.subset⟩⟩\n\n"}
{"name":"Matroid.Indep.base_iff_ground_subset_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI : Set α\nhI : M.Indep I\n⊢ Iff (M.Base I) (HasSubset.Subset M.E (M.closure I))","decl":"lemma Indep.base_iff_ground_subset_closure (hI : M.Indep I) : M.Base I ↔ M.E ⊆ M.closure I :=\n  ⟨fun h ↦ h.closure_eq.symm.subset, hI.base_of_ground_subset_closure⟩\n\n"}
{"name":"Matroid.Indep.closure_inter_eq_self_of_subset","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI J : Set α\nhI : M.Indep I\nhJI : HasSubset.Subset J I\n⊢ Eq (Inter.inter (M.closure J) I) J","decl":"lemma Indep.closure_inter_eq_self_of_subset (hI : M.Indep I) (hJI : J ⊆ I) :\n    M.closure J ∩ I = J := by\n  have hJ := hI.subset hJI\n  rw [subset_antisymm_iff, and_iff_left (subset_inter (M.subset_closure _) hJI)]\n  rintro e ⟨heJ, heI⟩\n  exact hJ.basis_closure.mem_of_insert_indep heJ (hI.subset (insert_subset heI hJI))\n\n"}
{"name":"Matroid.Indep.closure_sInter_eq_biInter_closure_of_forall_subset","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI : Set α\nJs : Set (Set α)\nhI : M.Indep I\nhne : Js.Nonempty\nhIs : ∀ (J : Set α), Membership.mem Js J → HasSubset.Subset J I\n⊢ Eq (M.closure Js.sInter) (Set.iInter fun J => Set.iInter fun h => M.closure J)","decl":"/-- For a nonempty collection of subsets of a given independent set,\nthe closure of the intersection is the intersection of the closure. -/\nlemma Indep.closure_sInter_eq_biInter_closure_of_forall_subset {Js : Set (Set α)} (hI : M.Indep I)\n    (hne : Js.Nonempty) (hIs : ∀ J ∈ Js, J ⊆ I) : M.closure (⋂₀ Js) = (⋂ J ∈ Js, M.closure J)  := by\n  rw [subset_antisymm_iff, subset_iInter₂_iff]\n  have hiX : ⋂₀ Js ⊆ I := (sInter_subset_of_mem hne.some_mem).trans (hIs _ hne.some_mem)\n  have hiI := hI.subset hiX\n  refine ⟨ fun X hX ↦ M.closure_subset_closure (sInter_subset_of_mem hX),\n    fun e he ↦ by_contra fun he' ↦ ?_⟩\n  rw [mem_iInter₂] at he\n  have heEI : e ∈ M.E \\ I := by\n    refine ⟨M.closure_subset_ground _ (he _ hne.some_mem), fun heI ↦ he' ?_⟩\n    refine mem_closure_of_mem _ (fun X hX' ↦ ?_) hiI.subset_ground\n    rw [← hI.closure_inter_eq_self_of_subset (hIs X hX')]\n    exact ⟨he X hX', heI⟩\n\n  rw [hiI.not_mem_closure_iff_of_not_mem (not_mem_subset hiX heEI.2)] at he'\n  obtain ⟨J, hJI, heJ⟩ := he'.subset_basis_of_subset (insert_subset_insert hiX)\n    (insert_subset heEI.1 hI.subset_ground)\n\n  have hIb : M.Basis I (insert e I) := by\n    rw [hI.insert_basis_iff_mem_closure]\n    exact (M.closure_subset_closure (hIs _ hne.some_mem)) (he _ hne.some_mem)\n\n  obtain ⟨f, hfIJ, hfb⟩ :=  hJI.exchange hIb ⟨heJ (mem_insert e _), heEI.2⟩\n  obtain rfl := hI.eq_of_basis (hfb.basis_subset (insert_subset hfIJ.1\n    (by (rw [diff_subset_iff, singleton_union]; exact hJI.subset))) (subset_insert _ _))\n\n  refine hfIJ.2 (heJ (mem_insert_of_mem _ fun X hX' ↦ by_contra fun hfX ↦ ?_))\n\n  obtain (hd | heX) := ((hI.subset (hIs X hX')).mem_closure_iff).mp (he _ hX')\n  · refine (hJI.indep.subset (insert_subset (heJ (mem_insert _ _)) ?_)).not_dep hd\n    specialize hIs _ hX'\n    rw [← singleton_union, ← diff_subset_iff, diff_singleton_eq_self hfX] at hIs\n    exact hIs.trans diff_subset\n  exact heEI.2 (hIs _ hX' heX)\n\n"}
{"name":"Matroid.closure_iInter_eq_iInter_closure_of_iUnion_indep","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nι : Sort u_3\nhι : Nonempty ι\nIs : ι → Set α\nh : M.Indep (Set.iUnion fun i => Is i)\n⊢ Eq (M.closure (Set.iInter fun i => Is i)) (Set.iInter fun i => M.closure (Is i))","decl":"lemma closure_iInter_eq_iInter_closure_of_iUnion_indep [hι : Nonempty ι] (Is : ι → Set α)\n    (h : M.Indep (⋃ i, Is i)) : M.closure (⋂ i, Is i) = (⋂ i, M.closure (Is i)) := by\n  convert h.closure_sInter_eq_biInter_closure_of_forall_subset (range_nonempty Is)\n    (by simp [subset_iUnion])\n  simp\n\n"}
{"name":"Matroid.closure_sInter_eq_biInter_closure_of_sUnion_indep","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nIs : Set (Set α)\nhIs : Is.Nonempty\nh : M.Indep Is.sUnion\n⊢ Eq (M.closure Is.sInter) (Set.iInter fun I => Set.iInter fun h => M.closure I)","decl":"lemma closure_sInter_eq_biInter_closure_of_sUnion_indep (Is : Set (Set α)) (hIs : Is.Nonempty)\n    (h : M.Indep (⋃₀ Is)) :  M.closure (⋂₀ Is) = (⋂ I ∈ Is, M.closure I) :=\n  h.closure_sInter_eq_biInter_closure_of_forall_subset hIs (fun _ ↦ subset_sUnion_of_mem)\n\n"}
{"name":"Matroid.closure_biInter_eq_biInter_closure_of_biUnion_indep","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nι : Type u_4\nA : Set ι\nhA : A.Nonempty\nI : ι → Set α\nh : M.Indep (Set.iUnion fun i => Set.iUnion fun h => I i)\n⊢ Eq (M.closure (Set.iInter fun i => Set.iInter fun h => I i)) (Set.iInter fun i => Set.iInter fun h => M.closure (I i))","decl":"lemma closure_biInter_eq_biInter_closure_of_biUnion_indep {ι : Type*} {A : Set ι} (hA : A.Nonempty)\n    {I : ι → Set α} (h : M.Indep (⋃ i ∈ A, I i)) :\n    M.closure (⋂ i ∈ A, I i) = ⋂ i ∈ A, M.closure (I i) := by\n  have := hA.coe_sort\n  convert closure_iInter_eq_iInter_closure_of_iUnion_indep (Is := fun i : A ↦ I i) (by simpa) <;>\n  simp\n\n"}
{"name":"Matroid.Indep.closure_iInter_eq_biInter_closure_of_forall_subset","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nι : Sort u_3\nI : Set α\ninst✝ : Nonempty ι\nJs : ι → Set α\nhI : M.Indep I\nhJs : ∀ (i : ι), HasSubset.Subset (Js i) I\n⊢ Eq (M.closure (Set.iInter fun i => Js i)) (Set.iInter fun i => M.closure (Js i))","decl":"lemma Indep.closure_iInter_eq_biInter_closure_of_forall_subset [Nonempty ι] {Js : ι → Set α}\n    (hI : M.Indep I) (hJs : ∀ i, Js i ⊆ I) : M.closure (⋂ i, Js i) = ⋂ i, M.closure (Js i) :=\n  closure_iInter_eq_iInter_closure_of_iUnion_indep _ (hI.subset <| by simpa)\n\n"}
{"name":"Matroid.Indep.closure_inter_eq_inter_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI J : Set α\nh : M.Indep (Union.union I J)\n⊢ Eq (M.closure (Inter.inter I J)) (Inter.inter (M.closure I) (M.closure J))","decl":"lemma Indep.closure_inter_eq_inter_closure (h : M.Indep (I ∪ J)) :\n    M.closure (I ∩ J) = M.closure I ∩ M.closure J := by\n  rw [inter_eq_iInter, closure_iInter_eq_iInter_closure_of_iUnion_indep, inter_eq_iInter]\n  · exact iInter_congr (by simp)\n  rwa [← union_eq_iUnion]\n\n"}
{"name":"Matroid.Indep.inter_Basis_biInter","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI : Set α\nι : Type u_4\nhI : M.Indep I\nX : ι → Set α\nA : Set ι\nhA : A.Nonempty\nh : ∀ (i : ι), Membership.mem A i → M.Basis (Inter.inter (X i) I) (X i)\n⊢ M.Basis (Inter.inter (Set.iInter fun i => Set.iInter fun h => X i) I) (Set.iInter fun i => Set.iInter fun h => X i)","decl":"lemma Indep.inter_Basis_biInter {ι : Type*} (hI : M.Indep I) {X : ι → Set α} {A : Set ι}\n    (hA : A.Nonempty) (h : ∀ i ∈ A, M.Basis ((X i) ∩ I) (X i)) :\n    M.Basis ((⋂ i ∈ A, X i) ∩ I) (⋂ i ∈ A, X i) := by\n  refine (hI.inter_left _).basis_of_subset_of_subset_closure inter_subset_left ?_\n  simp_rw [← biInter_inter hA,\n  closure_biInter_eq_biInter_closure_of_biUnion_indep hA (I := fun i ↦ (X i) ∩ I)\n      (hI.subset (by simp)), subset_iInter_iff]\n  exact fun i hiA ↦ (biInter_subset_of_mem hiA).trans (h i hiA).subset_closure\n\n"}
{"name":"Matroid.Indep.inter_Basis_iInter","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nι : Sort u_3\nI : Set α\ninst✝ : Nonempty ι\nX : ι → Set α\nhI : M.Indep I\nh : ∀ (i : ι), M.Basis (Inter.inter (X i) I) (X i)\n⊢ M.Basis (Inter.inter (Set.iInter fun i => X i) I) (Set.iInter fun i => X i)","decl":"lemma Indep.inter_Basis_iInter [Nonempty ι] {X : ι → Set α} (hI : M.Indep I)\n    (h : ∀ i, M.Basis ((X i) ∩ I) (X i)) : M.Basis ((⋂ i, X i) ∩ I) (⋂ i, X i) := by\n  convert hI.inter_Basis_biInter (ι := PLift ι) univ_nonempty (X := fun i ↦ X i.down)\n    (by simpa using fun (i : PLift ι) ↦ h i.down) <;>\n  · simp only [mem_univ, iInter_true]\n    exact (iInter_plift_down X).symm\n\n"}
{"name":"Matroid.Indep.inter_Basis_sInter","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI : Set α\nXs : Set (Set α)\nhI : M.Indep I\nhXs : Xs.Nonempty\nh : ∀ (X : Set α), Membership.mem Xs X → M.Basis (Inter.inter X I) X\n⊢ M.Basis (Inter.inter Xs.sInter I) Xs.sInter","decl":"lemma Indep.inter_Basis_sInter {Xs : Set (Set α)} (hI : M.Indep I) (hXs : Xs.Nonempty)\n    (h : ∀ X ∈ Xs, M.Basis (X ∩ I) X) : M.Basis (⋂₀ Xs ∩ I) (⋂₀ Xs) := by\n  rw [sInter_eq_biInter]\n  exact hI.inter_Basis_biInter hXs h\n\n"}
{"name":"Matroid.basis_iff_basis_closure_of_subset","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX I : Set α\nhIX : HasSubset.Subset I X\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ Iff (M.Basis I X) (M.Basis I (M.closure X))","decl":"lemma basis_iff_basis_closure_of_subset (hIX : I ⊆ X) (hX : X ⊆ M.E := by aesop_mat) :\n    M.Basis I X ↔ M.Basis I (M.closure X) :=\n  ⟨fun h ↦ h.basis_closure_right, fun h ↦ h.basis_subset hIX (M.subset_closure X hX)⟩\n\n"}
{"name":"Matroid.basis_iff_basis_closure_of_subset'","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX I : Set α\nhIX : HasSubset.Subset I X\n⊢ Iff (M.Basis I X) (And (M.Basis I (M.closure X)) (HasSubset.Subset X M.E))","decl":"lemma basis_iff_basis_closure_of_subset' (hIX : I ⊆ X) :\n    M.Basis I X ↔ M.Basis I (M.closure X) ∧ X ⊆ M.E :=\n  ⟨fun h ↦ ⟨h.basis_closure_right, h.subset_ground⟩,\n    fun h ↦ h.1.basis_subset hIX (M.subset_closure X h.2)⟩\n\n"}
{"name":"Matroid.basis'_iff_basis_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX I : Set α\n⊢ Iff (M.Basis' I X) (And (M.Basis I (M.closure X)) (HasSubset.Subset I X))","decl":"lemma basis'_iff_basis_closure : M.Basis' I X ↔ M.Basis I (M.closure X) ∧ I ⊆ X := by\n  rw [← closure_inter_ground, basis'_iff_basis_inter_ground]\n  exact ⟨fun h ↦ ⟨h.basis_closure_right, h.subset.trans inter_subset_left⟩,\n    fun h ↦ h.1.basis_subset (subset_inter h.2 h.1.indep.subset_ground) (M.subset_closure _)⟩\n\n"}
{"name":"Matroid.exists_basis_inter_ground_basis_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\n⊢ Exists fun I => And (M.Basis I (Inter.inter X M.E)) (M.Basis I (M.closure X))","decl":"lemma exists_basis_inter_ground_basis_closure (M : Matroid α) (X : Set α) :\n    ∃ I, M.Basis I (X ∩ M.E) ∧ M.Basis I (M.closure X) := by\n  obtain ⟨I, hI⟩ := M.exists_basis (X ∩ M.E)\n  have hI' := hI.basis_closure_right; rw [closure_inter_ground] at hI'\n  exact ⟨_, hI, hI'⟩\n\n"}
{"name":"Matroid.Basis.basis_of_closure_eq_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX Y I : Set α\nhI : M.Basis I X\nhY : HasSubset.Subset I Y\nh : Eq (M.closure X) (M.closure Y)\nhYE : autoParam (HasSubset.Subset Y M.E) _auto✝\n⊢ M.Basis I Y","decl":"lemma Basis.basis_of_closure_eq_closure (hI : M.Basis I X) (hY : I ⊆ Y)\n    (h : M.closure X = M.closure Y) (hYE : Y ⊆ M.E := by aesop_mat) : M.Basis I Y := by\n  refine hI.indep.basis_of_subset_of_subset_closure hY ?_\n  rw [hI.closure_eq_closure, h]\n  exact M.subset_closure Y\n\n"}
{"name":"Matroid.basis_union_iff_indep_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX I : Set α\n⊢ Iff (M.Basis I (Union.union I X)) (And (M.Indep I) (HasSubset.Subset X (M.closure I)))","decl":"lemma basis_union_iff_indep_closure : M.Basis I (I ∪ X) ↔ M.Indep I ∧ X ⊆ M.closure I :=\n  ⟨fun h ↦ ⟨h.indep, subset_union_right.trans h.subset_closure⟩, fun ⟨hI, hXI⟩ ↦\n    hI.basis_closure.basis_subset subset_union_left (union_subset (M.subset_closure I) hXI)⟩\n\n"}
{"name":"Matroid.basis_iff_indep_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX I : Set α\n⊢ Iff (M.Basis I X) (And (M.Indep I) (And (HasSubset.Subset X (M.closure I)) (HasSubset.Subset I X)))","decl":"lemma basis_iff_indep_closure : M.Basis I X ↔ M.Indep I ∧ X ⊆ M.closure I ∧ I ⊆ X :=\n  ⟨fun h ↦ ⟨h.indep, h.subset_closure, h.subset⟩, fun h ↦\n    (basis_union_iff_indep_closure.mpr ⟨h.1, h.2.1⟩).basis_subset h.2.2 subset_union_right⟩\n\n"}
{"name":"Matroid.Indep.inter_basis_closure_iff_subset_closure_inter","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI X : Set α\nhI : M.Indep I\n⊢ Iff (M.Basis (Inter.inter X I) X) (HasSubset.Subset X (M.closure (Inter.inter X I)))","decl":"lemma Indep.inter_basis_closure_iff_subset_closure_inter {X : Set α} (hI : M.Indep I) :\n    M.Basis (X ∩ I) X ↔ X ⊆ M.closure (X ∩ I) :=\n  ⟨Basis.subset_closure, (hI.inter_left X).basis_of_subset_of_subset_closure inter_subset_left⟩\n\n"}
{"name":"Matroid.Basis.closure_inter_basis_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX I : Set α\nh : M.Basis (Inter.inter X I) X\nhI : M.Indep I\n⊢ M.Basis (Inter.inter (M.closure X) I) (M.closure X)","decl":"lemma Basis.closure_inter_basis_closure (h : M.Basis (X ∩ I) X) (hI : M.Indep I) :\n    M.Basis (M.closure X ∩ I) (M.closure X) := by\n  rw [hI.inter_basis_closure_iff_subset_closure_inter] at h ⊢\n  exact (M.closure_subset_closure_of_subset_closure h).trans (M.closure_subset_closure\n    (inter_subset_inter_left _ (h.trans (M.closure_subset_closure inter_subset_left))))\n\n"}
{"name":"Matroid.Basis.eq_of_closure_subset","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX I J : Set α\nhI : M.Basis I X\nhJI : HasSubset.Subset J I\nhJ : HasSubset.Subset X (M.closure J)\n⊢ Eq J I","decl":"lemma Basis.eq_of_closure_subset (hI : M.Basis I X) (hJI : J ⊆ I) (hJ : X ⊆ M.closure J) :\n    J = I := by\n  rw [← hI.indep.closure_inter_eq_self_of_subset hJI, inter_eq_self_of_subset_right]\n  exact hI.subset.trans hJ\n\n"}
{"name":"Matroid.Basis.insert_basis_insert_of_not_mem_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\ne : α\nI : Set α\nhIX : M.Basis I X\nheI : Not (Membership.mem (M.closure I) e)\nheE : autoParam (Membership.mem M.E e) _auto✝\n⊢ M.Basis (Insert.insert e I) (Insert.insert e X)","decl":"lemma Basis.insert_basis_insert_of_not_mem_closure (hIX : M.Basis I X) (heI : e ∉ M.closure I)\n    (heE : e ∈ M.E := by aesop_mat) : M.Basis (insert e I) (insert e X) :=\n  hIX.insert_basis_insert <| hIX.indep.insert_indep_iff.2 <| .inl ⟨heE, heI⟩\n\n"}
{"name":"Matroid.empty_basis_iff","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\n⊢ Iff (M.Basis EmptyCollection.emptyCollection X) (HasSubset.Subset X (M.closure EmptyCollection.emptyCollection))","decl":"@[simp] lemma empty_basis_iff : M.Basis ∅ X ↔ X ⊆ M.closure ∅ := by\n  rw [basis_iff_indep_closure, and_iff_right M.empty_indep, and_iff_left (empty_subset _)]\n\n"}
{"name":"Matroid.indep_iff_forall_not_mem_closure_diff","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI : Set α\nhI : autoParam (HasSubset.Subset I M.E) _auto✝\n⊢ Iff (M.Indep I) (∀ ⦃e : α⦄, Membership.mem I e → Not (Membership.mem (M.closure (SDiff.sdiff I (Singleton.singleton e))) e))","decl":"lemma indep_iff_forall_not_mem_closure_diff (hI : I ⊆ M.E := by aesop_mat) :\n    M.Indep I ↔ ∀ ⦃e⦄, e ∈ I → e ∉ M.closure (I \\ {e}) := by\n  use fun h e heI he ↦ ((h.closure_inter_eq_self_of_subset diff_subset).subset ⟨he, heI⟩).2 rfl\n  intro h\n  obtain ⟨J, hJ⟩ := M.exists_basis I\n  convert hJ.indep\n  refine hJ.subset.antisymm' (fun e he ↦ by_contra fun heJ ↦ h he ?_)\n  exact mem_of_mem_of_subset\n    (hJ.subset_closure he) (M.closure_subset_closure (subset_diff_singleton hJ.subset heJ))\n\n"}
{"name":"Matroid.indep_iff_forall_not_mem_closure_diff'","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI : Set α\n⊢ Iff (M.Indep I) (And (HasSubset.Subset I M.E) (∀ (e : α), Membership.mem I e → Not (Membership.mem (M.closure (SDiff.sdiff I (Singleton.singleton e))) e)))","decl":"/-- An alternative version of `Matroid.indep_iff_forall_not_mem_closure_diff` where the\nhypothesis that `I ⊆ M.E` is contained in the RHS rather than the hypothesis. -/\nlemma indep_iff_forall_not_mem_closure_diff' :\n    M.Indep I ↔ I ⊆ M.E ∧ ∀ e ∈ I, e ∉ M.closure (I \\ {e}) :=\n  ⟨fun h ↦ ⟨h.subset_ground, (indep_iff_forall_not_mem_closure_diff h.subset_ground).mp h⟩, fun h ↦\n    (indep_iff_forall_not_mem_closure_diff h.1).mpr h.2⟩\n\n"}
{"name":"Matroid.Indep.not_mem_closure_diff_of_mem","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\ne : α\nI : Set α\nhI : M.Indep I\nhe : Membership.mem I e\n⊢ Not (Membership.mem (M.closure (SDiff.sdiff I (Singleton.singleton e))) e)","decl":"lemma Indep.not_mem_closure_diff_of_mem (hI : M.Indep I) (he : e ∈ I) : e ∉ M.closure (I \\ {e}) :=\n  (indep_iff_forall_not_mem_closure_diff'.1 hI).2 e he\n\n"}
{"name":"Matroid.indep_iff_forall_closure_diff_ne","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI : Set α\n⊢ Iff (M.Indep I) (∀ ⦃e : α⦄, Membership.mem I e → Ne (M.closure (SDiff.sdiff I (Singleton.singleton e))) (M.closure I))","decl":"lemma indep_iff_forall_closure_diff_ne :\n    M.Indep I ↔ ∀ ⦃e⦄, e ∈ I → M.closure (I \\ {e}) ≠ M.closure I := by\n  rw [indep_iff_forall_not_mem_closure_diff']\n  refine ⟨fun ⟨hIE, h⟩ e heI h_eq ↦ h e heI (h_eq.symm.subset (M.mem_closure_of_mem heI)),\n    fun h ↦ ⟨fun e heI ↦ by_contra fun heE ↦ h heI ?_,fun e heI hin ↦ h heI ?_⟩⟩\n  · rw [← closure_inter_ground, inter_comm, inter_diff_distrib_left,\n      inter_singleton_eq_empty.mpr heE, diff_empty, inter_comm, closure_inter_ground]\n  nth_rw 2 [show I = insert e (I \\ {e}) by simp [heI]]\n  rw [← closure_insert_closure_eq_closure_insert, insert_eq_of_mem hin, closure_closure]\n\n"}
{"name":"Matroid.Indep.union_indep_iff_forall_not_mem_closure_right","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI J : Set α\nhI : M.Indep I\nhJ : M.Indep J\n⊢ Iff (M.Indep (Union.union I J)) (∀ (e : α), Membership.mem (SDiff.sdiff J I) e → Not (Membership.mem (M.closure (Union.union I (SDiff.sdiff J (Singleton.singleton e)))) e))","decl":"lemma Indep.union_indep_iff_forall_not_mem_closure_right (hI : M.Indep I) (hJ : M.Indep J) :\n    M.Indep (I ∪ J) ↔ ∀ e ∈ J \\ I, e ∉ M.closure (I ∪ (J \\ {e})) := by\n  refine ⟨fun h e heJ hecl ↦ h.not_mem_closure_diff_of_mem (.inr heJ.1) ?_, fun h ↦ ?_⟩\n  · rwa [union_diff_distrib, diff_singleton_eq_self heJ.2]\n  obtain ⟨K, hKIJ, hK⟩ := hI.subset_basis_of_subset (show I ⊆ I ∪ J from subset_union_left)\n  obtain rfl | hssu := hKIJ.subset.eq_or_ssubset\n  · exact hKIJ.indep\n  exfalso\n  obtain ⟨e, heI, heK⟩ := exists_of_ssubset hssu\n  have heJI : e ∈ J \\ I := by\n    rw [← union_diff_right, union_comm]\n    exact ⟨heI, not_mem_subset hK heK⟩\n  refine h _ heJI ?_\n  rw [← diff_singleton_eq_self heJI.2, ← union_diff_distrib]\n  exact M.closure_subset_closure (subset_diff_singleton hKIJ.subset heK) <| hKIJ.subset_closure heI\n\n"}
{"name":"Matroid.Indep.union_indep_iff_forall_not_mem_closure_left","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI J : Set α\nhI : M.Indep I\nhJ : M.Indep J\n⊢ Iff (M.Indep (Union.union I J)) (∀ (e : α), Membership.mem (SDiff.sdiff I J) e → Not (Membership.mem (M.closure (Union.union (SDiff.sdiff I (Singleton.singleton e)) J)) e))","decl":"lemma Indep.union_indep_iff_forall_not_mem_closure_left (hI : M.Indep I) (hJ : M.Indep J) :\n    M.Indep (I ∪ J) ↔ ∀ e ∈ I \\ J, e ∉ M.closure ((I \\ {e}) ∪ J) := by\n  simp_rw [union_comm I J, hJ.union_indep_iff_forall_not_mem_closure_right hI, union_comm]\n\n"}
{"name":"Matroid.Indep.closure_ssubset_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI J : Set α\nhI : M.Indep I\nhJI : HasSSubset.SSubset J I\n⊢ HasSSubset.SSubset (M.closure J) (M.closure I)","decl":"lemma Indep.closure_ssubset_closure (hI : M.Indep I) (hJI : J ⊂ I) : M.closure J ⊂ M.closure I := by\n  obtain ⟨e, heI, heJ⟩ := exists_of_ssubset hJI\n  exact (M.closure_subset_closure hJI.subset).ssubset_of_not_subset fun hss ↦ heJ <|\n    (hI.closure_inter_eq_self_of_subset hJI.subset).subset ⟨hss (M.mem_closure_of_mem heI), heI⟩\n\n"}
{"name":"Matroid.indep_iff_forall_closure_ssubset_of_ssubset","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI : Set α\nhI : autoParam (HasSubset.Subset I M.E) _auto✝\n⊢ Iff (M.Indep I) (∀ ⦃J : Set α⦄, HasSSubset.SSubset J I → HasSSubset.SSubset (M.closure J) (M.closure I))","decl":"lemma indep_iff_forall_closure_ssubset_of_ssubset (hI : I ⊆ M.E := by aesop_mat) :\n    M.Indep I ↔ ∀ ⦃J⦄, J ⊂ I → M.closure J ⊂ M.closure I := by\n  refine ⟨fun h _ ↦ h.closure_ssubset_closure,\n    fun h ↦ (indep_iff_forall_not_mem_closure_diff hI).2 fun e heI hecl ↦ ?_⟩\n  refine (h (diff_singleton_sSubset.2 heI)).ne ?_\n  rw [show I = insert e (I \\ {e}) by simp [heI], ← closure_insert_closure_eq_closure_insert,\n    insert_eq_of_mem hecl]\n  simp\n\n"}
{"name":"Matroid.Indep.closure_diff_ssubset","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX I : Set α\nhI : M.Indep I\nhX : (Inter.inter I X).Nonempty\n⊢ HasSSubset.SSubset (M.closure (SDiff.sdiff I X)) (M.closure I)","decl":"lemma Indep.closure_diff_ssubset (hI : M.Indep I) (hX : (I ∩ X).Nonempty) :\n    M.closure (I \\ X) ⊂ M.closure I := by\n  refine hI.closure_ssubset_closure <| diff_subset.ssubset_of_ne fun h ↦ ?_\n  rw [sdiff_eq_left, disjoint_iff_inter_eq_empty] at h\n  simp [h] at hX\n\n"}
{"name":"Matroid.Indep.closure_diff_singleton_ssubset","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\ne : α\nI : Set α\nhI : M.Indep I\nhe : Membership.mem I e\n⊢ HasSSubset.SSubset (M.closure (SDiff.sdiff I (Singleton.singleton e))) (M.closure I)","decl":"lemma Indep.closure_diff_singleton_ssubset (hI : M.Indep I) (he : e ∈ I) :\n    M.closure (I \\ {e}) ⊂ M.closure I :=\n  hI.closure_ssubset_closure <| by simpa\n\n"}
{"name":"Matroid.mem_closure_insert","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\ne f : α\nhe : Not (Membership.mem (M.closure X) e)\nhef : Membership.mem (M.closure (Insert.insert f X)) e\n⊢ Membership.mem (M.closure (Insert.insert e X)) f","decl":"lemma mem_closure_insert (he : e ∉ M.closure X) (hef : e ∈ M.closure (insert f X)) :\n    f ∈ M.closure (insert e X) := by\n  rw [← closure_inter_ground] at *\n  have hfE : f ∈ M.E := by\n    by_contra! hfE; rw [insert_inter_of_not_mem hfE] at hef; exact he hef\n  have heE : e ∈ M.E := (M.closure_subset_ground _) hef\n  rw [insert_inter_of_mem hfE] at hef; rw [insert_inter_of_mem heE]\n\n  obtain ⟨I, hI⟩ := M.exists_basis (X ∩ M.E)\n  rw [← hI.closure_eq_closure, hI.indep.not_mem_closure_iff] at he\n  rw [← closure_insert_closure_eq_closure_insert, ← hI.closure_eq_closure,\n    closure_insert_closure_eq_closure_insert, he.1.mem_closure_iff] at *\n  rw [or_iff_not_imp_left, dep_iff, insert_comm,\n    and_iff_left (insert_subset heE (insert_subset hfE hI.indep.subset_ground)), not_not]\n  intro h\n  rw [(h.subset (subset_insert _ _)).mem_closure_iff, or_iff_right (h.not_dep), mem_insert_iff,\n    or_iff_left he.2] at hef\n  subst hef; apply mem_insert\n\n"}
{"name":"Matroid.closure_exchange","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\ne f : α\nhe : Membership.mem (SDiff.sdiff (M.closure (Insert.insert f X)) (M.closure X)) e\n⊢ Membership.mem (SDiff.sdiff (M.closure (Insert.insert e X)) (M.closure X)) f","decl":"lemma closure_exchange (he : e ∈ M.closure (insert f X) \\ M.closure X) :\n    f ∈ M.closure (insert e X) \\ M.closure X :=\n  ⟨mem_closure_insert he.2 he.1, fun hf ↦ by\n    rwa [closure_insert_eq_of_mem_closure hf, diff_self, iff_false_intro (not_mem_empty _)] at he⟩\n\n"}
{"name":"Matroid.closure_exchange_iff","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\ne f : α\n⊢ Iff (Membership.mem (SDiff.sdiff (M.closure (Insert.insert f X)) (M.closure X)) e) (Membership.mem (SDiff.sdiff (M.closure (Insert.insert e X)) (M.closure X)) f)","decl":"lemma closure_exchange_iff :\n    e ∈ M.closure (insert f X) \\ M.closure X ↔ f ∈ M.closure (insert e X) \\ M.closure X :=\n  ⟨closure_exchange, closure_exchange⟩\n\n"}
{"name":"Matroid.closure_insert_congr","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\ne f : α\nhe : Membership.mem (SDiff.sdiff (M.closure (Insert.insert f X)) (M.closure X)) e\n⊢ Eq (M.closure (Insert.insert e X)) (M.closure (Insert.insert f X))","decl":"lemma closure_insert_congr (he : e ∈ M.closure (insert f X) \\ M.closure X) :\n    M.closure (insert e X) = M.closure (insert f X) := by\n  have hf := closure_exchange he\n  rw [eq_comm, ← closure_closure, ← insert_eq_of_mem he.1, closure_insert_closure_eq_closure_insert,\n    insert_comm, ← closure_closure, ← closure_insert_closure_eq_closure_insert,\n    insert_eq_of_mem hf.1, closure_closure, closure_closure]\n\n"}
{"name":"Matroid.closure_diff_eq_self","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX Y : Set α\nh : HasSubset.Subset Y (M.closure (SDiff.sdiff X Y))\n⊢ Eq (M.closure (SDiff.sdiff X Y)) (M.closure X)","decl":"lemma closure_diff_eq_self (h : Y ⊆ M.closure (X \\ Y)) : M.closure (X \\ Y) = M.closure X := by\n  rw [← diff_union_inter X Y, ← closure_union_closure_left_eq,\n    union_eq_self_of_subset_right (inter_subset_right.trans h), closure_closure, diff_union_inter]\n\n"}
{"name":"Matroid.closure_diff_singleton_eq_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\ne : α\nh : Membership.mem (M.closure (SDiff.sdiff X (Singleton.singleton e))) e\n⊢ Eq (M.closure (SDiff.sdiff X (Singleton.singleton e))) (M.closure X)","decl":"lemma closure_diff_singleton_eq_closure (h : e ∈ M.closure (X \\ {e})) :\n    M.closure (X \\ {e}) = M.closure X :=\n  closure_diff_eq_self (by simpa)\n\n"}
{"name":"Matroid.subset_closure_diff_iff_closure_eq","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX Y : Set α\nh : HasSubset.Subset Y X\nhY : autoParam (HasSubset.Subset Y M.E) _auto✝\n⊢ Iff (HasSubset.Subset Y (M.closure (SDiff.sdiff X Y))) (Eq (M.closure (SDiff.sdiff X Y)) (M.closure X))","decl":"lemma subset_closure_diff_iff_closure_eq (h : Y ⊆ X) (hY : Y ⊆ M.E := by aesop_mat) :\n    Y ⊆ M.closure (X \\ Y) ↔ M.closure (X \\ Y) = M.closure X :=\n  ⟨closure_diff_eq_self, fun h' ↦ (M.subset_closure_of_subset' h).trans h'.symm.subset⟩\n\n"}
{"name":"Matroid.mem_closure_diff_singleton_iff_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\ne : α\nhe : Membership.mem X e\nheE : autoParam (Membership.mem M.E e) _auto✝\n⊢ Iff (Membership.mem (M.closure (SDiff.sdiff X (Singleton.singleton e))) e) (Eq (M.closure (SDiff.sdiff X (Singleton.singleton e))) (M.closure X))","decl":"lemma mem_closure_diff_singleton_iff_closure (he : e ∈ X) (heE : e ∈ M.E := by aesop_mat) :\n    e ∈ M.closure (X \\ {e}) ↔ M.closure (X \\ {e}) = M.closure X := by\n  simpa using subset_closure_diff_iff_closure_eq (Y := {e}) (X := X) (by simpa)\n\n"}
{"name":"Matroid.ext_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM₁ M₂ : Matroid α\nh : ∀ (X : Set α), Eq (M₁.closure X) (M₂.closure X)\n⊢ Eq M₁ M₂","decl":"lemma ext_closure {M₁ M₂ : Matroid α} (h : ∀ X, M₁.closure X = M₂.closure X) : M₁ = M₂ :=\n  ext_indep (by simpa using h univ)\n    (fun _ _ ↦ by simp_rw [indep_iff_forall_closure_diff_ne, h])\n\n\n"}
{"name":"Matroid.Spanning.closure_eq","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nS : Set α\nself : M.Spanning S\n⊢ Eq (M.closure S) M.E","decl":"/-- A set is `spanning` in `M` if its closure is equal to `M.E`, or equivalently if it contains\n  a base of `M`. -/\n@[mk_iff]\nstructure Spanning (M : Matroid α) (S : Set α) : Prop where\n  closure_eq : M.closure S = M.E\n  subset_ground : S ⊆ M.E\n\n"}
{"name":"Matroid.spanning_iff","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nS : Set α\n⊢ Iff (M.Spanning S) (And (Eq (M.closure S) M.E) (HasSubset.Subset S M.E))","decl":"/-- A set is `spanning` in `M` if its closure is equal to `M.E`, or equivalently if it contains\n  a base of `M`. -/\n@[mk_iff]\nstructure Spanning (M : Matroid α) (S : Set α) : Prop where\n  closure_eq : M.closure S = M.E\n  subset_ground : S ⊆ M.E\n\n"}
{"name":"Matroid.Spanning.subset_ground","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nS : Set α\nself : M.Spanning S\n⊢ HasSubset.Subset S M.E","decl":"/-- A set is `spanning` in `M` if its closure is equal to `M.E`, or equivalently if it contains\n  a base of `M`. -/\n@[mk_iff]\nstructure Spanning (M : Matroid α) (S : Set α) : Prop where\n  closure_eq : M.closure S = M.E\n  subset_ground : S ⊆ M.E\n\n"}
{"name":"Matroid.spanning_iff_closure_eq","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nS : Set α\nhS : autoParam (HasSubset.Subset S M.E) _auto✝\n⊢ Iff (M.Spanning S) (Eq (M.closure S) M.E)","decl":"lemma spanning_iff_closure_eq (hS : S ⊆ M.E := by aesop_mat) :\n    M.Spanning S ↔ M.closure S = M.E := by\n  rw [spanning_iff, and_iff_left hS]\n\n"}
{"name":"Matroid.closure_spanning_iff","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nS : Set α\nhS : autoParam (HasSubset.Subset S M.E) _auto✝\n⊢ Iff (M.Spanning (M.closure S)) (M.Spanning S)","decl":"@[simp] lemma closure_spanning_iff (hS : S ⊆ M.E := by aesop_mat) :\n    M.Spanning (M.closure S) ↔ M.Spanning S := by\n  rw [spanning_iff_closure_eq, closure_closure, ← spanning_iff_closure_eq]\n\n"}
{"name":"Matroid.spanning_iff_ground_subset_closure","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nS : Set α\nhS : autoParam (HasSubset.Subset S M.E) _auto✝\n⊢ Iff (M.Spanning S) (HasSubset.Subset M.E (M.closure S))","decl":"lemma spanning_iff_ground_subset_closure (hS : S ⊆ M.E := by aesop_mat) :\n    M.Spanning S ↔ M.E ⊆ M.closure S := by\n  rw [spanning_iff_closure_eq, subset_antisymm_iff, and_iff_right (closure_subset_ground _ _)]\n\n"}
{"name":"Matroid.not_spanning_iff_closure_ssubset","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nS : Set α\nhS : autoParam (HasSubset.Subset S M.E) _auto✝\n⊢ Iff (Not (M.Spanning S)) (HasSSubset.SSubset (M.closure S) M.E)","decl":"lemma not_spanning_iff_closure_ssubset (hS : S ⊆ M.E := by aesop_mat) :\n    ¬M.Spanning S ↔ M.closure S ⊂ M.E := by\n  rw [spanning_iff_closure_eq, ssubset_iff_subset_ne, iff_and_self,\n    iff_true_intro (M.closure_subset_ground _)]\n  exact fun _ ↦ trivial\n\n"}
{"name":"Matroid.Spanning.superset","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nS T : Set α\nhS : M.Spanning S\nhST : HasSubset.Subset S T\nhT : autoParam (HasSubset.Subset T M.E) _auto✝\n⊢ M.Spanning T","decl":"lemma Spanning.superset (hS : M.Spanning S) (hST : S ⊆ T) (hT : T ⊆ M.E := by aesop_mat) :\n    M.Spanning T :=\n  ⟨(M.closure_subset_ground _).antisymm\n    (by rw [← hS.closure_eq]; exact M.closure_subset_closure hST), hT⟩\n\n"}
{"name":"Matroid.Spanning.closure_eq_of_superset","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nS T : Set α\nhS : M.Spanning S\nhST : HasSubset.Subset S T\n⊢ Eq (M.closure T) M.E","decl":"lemma Spanning.closure_eq_of_superset (hS : M.Spanning S) (hST : S ⊆ T) : M.closure T = M.E := by\n  rw [← closure_inter_ground, ← spanning_iff_closure_eq]\n  exact hS.superset (subset_inter hST hS.subset_ground)\n\n"}
{"name":"Matroid.Spanning.union_left","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX S : Set α\nhS : M.Spanning S\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ M.Spanning (Union.union S X)","decl":"lemma Spanning.union_left (hS : M.Spanning S) (hX : X ⊆ M.E := by aesop_mat) : M.Spanning (S ∪ X) :=\n  hS.superset subset_union_left\n\n"}
{"name":"Matroid.Spanning.union_right","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX S : Set α\nhS : M.Spanning S\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ M.Spanning (Union.union X S)","decl":"lemma Spanning.union_right (hS : M.Spanning S) (hX : X ⊆ M.E := by aesop_mat) :\n    M.Spanning (X ∪ S) :=\n  hS.superset subset_union_right\n\n"}
{"name":"Matroid.Base.spanning","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nB : Set α\nhB : M.Base B\n⊢ M.Spanning B","decl":"lemma Base.spanning (hB : M.Base B) : M.Spanning B :=\n  ⟨hB.closure_eq, hB.subset_ground⟩\n\n"}
{"name":"Matroid.ground_spanning","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\n⊢ M.Spanning M.E","decl":"lemma ground_spanning (M : Matroid α) : M.Spanning M.E :=\n  ⟨M.closure_ground, rfl.subset⟩\n\n"}
{"name":"Matroid.Base.spanning_of_superset","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX B : Set α\nhB : M.Base B\nhBX : HasSubset.Subset B X\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ M.Spanning X","decl":"lemma Base.spanning_of_superset (hB : M.Base B) (hBX : B ⊆ X) (hX : X ⊆ M.E := by aesop_mat) :\n    M.Spanning X :=\n  hB.spanning.superset hBX\n\n"}
{"name":"Matroid.spanning_iff_exists_base_subset'","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nS : Set α\n⊢ Iff (M.Spanning S) (And (Exists fun B => And (M.Base B) (HasSubset.Subset B S)) (HasSubset.Subset S M.E))","decl":"/-- A version of `Matroid.spanning_iff_exists_base_subset` in which the `S ⊆ M.E` condition\nappears in the RHS of the equivalence rather than as a hypothesis. -/\nlemma spanning_iff_exists_base_subset' : M.Spanning S ↔ (∃ B, M.Base B ∧ B ⊆ S) ∧ S ⊆ M.E := by\n  refine ⟨fun h ↦ ⟨?_, h.subset_ground⟩, fun ⟨⟨B, hB, hBS⟩, hSE⟩ ↦ hB.spanning.superset hBS⟩\n  obtain ⟨B, hB⟩ := M.exists_basis S\n  have hB' := hB.basis_closure_right\n  rw [h.closure_eq, basis_ground_iff] at hB'\n  exact ⟨B, hB', hB.subset⟩\n\n"}
{"name":"Matroid.spanning_iff_exists_base_subset","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nS : Set α\nhS : autoParam (HasSubset.Subset S M.E) _auto✝\n⊢ Iff (M.Spanning S) (Exists fun B => And (M.Base B) (HasSubset.Subset B S))","decl":"lemma spanning_iff_exists_base_subset (hS : S ⊆ M.E := by aesop_mat) :\n    M.Spanning S ↔ ∃ B, M.Base B ∧ B ⊆ S := by\n  rw [spanning_iff_exists_base_subset', and_iff_left hS]\n\n"}
{"name":"Matroid.Spanning.exists_base_subset","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nS : Set α\nhS : M.Spanning S\n⊢ Exists fun B => And (M.Base B) (HasSubset.Subset B S)","decl":"lemma Spanning.exists_base_subset (hS : M.Spanning S) : ∃ B, M.Base B ∧ B ⊆ S := by\n  rwa [spanning_iff_exists_base_subset] at hS\n\n"}
{"name":"Matroid.coindep_iff_compl_spanning","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI : Set α\nhI : autoParam (HasSubset.Subset I M.E) _auto✝\n⊢ Iff (M.Coindep I) (M.Spanning (SDiff.sdiff M.E I))","decl":"lemma coindep_iff_compl_spanning (hI : I ⊆ M.E := by aesop_mat) :\n    M.Coindep I ↔ M.Spanning (M.E \\ I) := by\n  rw [coindep_iff_exists, spanning_iff_exists_base_subset]\n\n"}
{"name":"Matroid.spanning_iff_compl_coindep","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nS : Set α\nhS : autoParam (HasSubset.Subset S M.E) _auto✝\n⊢ Iff (M.Spanning S) (M.Coindep (SDiff.sdiff M.E S))","decl":"lemma spanning_iff_compl_coindep (hS : S ⊆ M.E := by aesop_mat) :\n    M.Spanning S ↔ M.Coindep (M.E \\ S) := by\n  rw [coindep_iff_compl_spanning, diff_diff_cancel_left hS]\n\n"}
{"name":"Matroid.Coindep.compl_spanning","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI : Set α\nhI : M.Coindep I\n⊢ M.Spanning (SDiff.sdiff M.E I)","decl":"lemma Coindep.compl_spanning (hI : M.Coindep I) : M.Spanning (M.E \\ I) :=\n  (coindep_iff_compl_spanning hI.subset_ground).mp hI\n\n"}
{"name":"Matroid.coindep_iff_closure_compl_eq_ground","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\nhK : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ Iff (M.Coindep X) (Eq (M.closure (SDiff.sdiff M.E X)) M.E)","decl":"lemma coindep_iff_closure_compl_eq_ground (hK : X ⊆ M.E := by aesop_mat) :\n    M.Coindep X ↔ M.closure (M.E \\ X) = M.E := by\n  rw [coindep_iff_compl_spanning, spanning_iff_closure_eq]\n\n"}
{"name":"Matroid.Coindep.closure_compl","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX : Set α\nhX : M.Coindep X\n⊢ Eq (M.closure (SDiff.sdiff M.E X)) M.E","decl":"lemma Coindep.closure_compl (hX : M.Coindep X) : M.closure (M.E \\ X) = M.E :=\n  (coindep_iff_closure_compl_eq_ground hX.subset_ground).mp hX\n\n"}
{"name":"Matroid.Indep.base_of_spanning","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI : Set α\nhI : M.Indep I\nhIs : M.Spanning I\n⊢ M.Base I","decl":"lemma Indep.base_of_spanning (hI : M.Indep I) (hIs : M.Spanning I) : M.Base I := by\n  obtain ⟨B, hB, hBI⟩ := hIs.exists_base_subset; rwa [← hB.eq_of_subset_indep hI hBI]\n\n"}
{"name":"Matroid.Spanning.base_of_indep","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nI : Set α\nhIs : M.Spanning I\nhI : M.Indep I\n⊢ M.Base I","decl":"lemma Spanning.base_of_indep (hIs : M.Spanning I) (hI : M.Indep I) : M.Base I :=\n  hI.base_of_spanning hIs\n\n"}
{"name":"Matroid.Indep.eq_of_spanning_subset","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nS I : Set α\nhI : M.Indep I\nhS : M.Spanning S\nhSI : HasSubset.Subset S I\n⊢ Eq S I","decl":"lemma Indep.eq_of_spanning_subset (hI : M.Indep I) (hS : M.Spanning S) (hSI : S ⊆ I) : S = I :=\n  ((hI.subset hSI).base_of_spanning hS).eq_of_subset_indep hI hSI\n\n"}
{"name":"Matroid.Basis.spanning_iff_spanning","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX I : Set α\nhIX : M.Basis I X\n⊢ Iff (M.Spanning I) (M.Spanning X)","decl":"lemma Basis.spanning_iff_spanning (hIX : M.Basis I X) : M.Spanning I ↔ M.Spanning X := by\n  rw [spanning_iff_closure_eq, spanning_iff_closure_eq, hIX.closure_eq_closure]\n\n"}
{"name":"Matroid.Spanning.base_restrict_iff","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nS B : Set α\nhS : M.Spanning S\n⊢ Iff ((M.restrict S).Base B) (And (M.Base B) (HasSubset.Subset B S))","decl":"lemma Spanning.base_restrict_iff (hS : M.Spanning S) : (M ↾ S).Base B ↔ M.Base B ∧ B ⊆ S := by\n  rw [base_restrict_iff', basis'_iff_basis]\n  refine ⟨fun h ↦ ⟨?_, h.subset⟩, fun h ↦ h.1.indep.basis_of_subset_of_subset_closure h.2 ?_⟩\n  · exact h.indep.base_of_spanning <| by rwa [h.spanning_iff_spanning]\n  rw [h.1.closure_eq]\n  exact hS.subset_ground\n\n"}
{"name":"Matroid.Spanning.compl_coindep","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nS : Set α\nhS : M.Spanning S\n⊢ M.Coindep (SDiff.sdiff M.E S)","decl":"lemma Spanning.compl_coindep (hS : M.Spanning S) : M.Coindep (M.E \\ S) := by\n  rwa [← spanning_iff_compl_coindep]\n\n"}
{"name":"Matroid.Basis.base_of_spanning","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX I : Set α\nhIX : M.Basis I X\nhX : M.Spanning X\n⊢ M.Base I","decl":"lemma Basis.base_of_spanning (hIX : M.Basis I X) (hX : M.Spanning X) : M.Base I :=\n  hIX.indep.base_of_spanning <| by rwa [hIX.spanning_iff_spanning]\n\n"}
{"name":"Matroid.Indep.exists_base_subset_spanning","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nS I : Set α\nhI : M.Indep I\nhS : M.Spanning S\nhIS : HasSubset.Subset I S\n⊢ Exists fun B => And (M.Base B) (And (HasSubset.Subset I B) (HasSubset.Subset B S))","decl":"lemma Indep.exists_base_subset_spanning (hI : M.Indep I) (hS : M.Spanning S) (hIS : I ⊆ S) :\n    ∃ B, M.Base B ∧ I ⊆ B ∧ B ⊆ S := by\n  obtain ⟨B, hB⟩ := hI.subset_basis_of_subset hIS\n  exact ⟨B, hB.1.base_of_spanning hS, hB.2, hB.1.subset⟩\n\n"}
{"name":"Matroid.Restriction.base_iff_of_spanning","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nB : Set α\nN : Matroid α\nhR : N.Restriction M\nhN : M.Spanning N.E\n⊢ Iff (N.Base B) (And (M.Base B) (HasSubset.Subset B N.E))","decl":"lemma Restriction.base_iff_of_spanning {N : Matroid α} (hR : N ≤r M) (hN : M.Spanning N.E) :\n    N.Base B ↔ (M.Base B ∧ B ⊆ N.E) := by\n  obtain ⟨R, hR : R ⊆ M.E, rfl⟩ := hR\n  rw [Spanning.base_restrict_iff (show M.Spanning R from hN), restrict_ground_eq]\n\n"}
{"name":"Matroid.ext_spanning","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM M' : Matroid α\nh : Eq M.E M'.E\nhsp : ∀ (S : Set α), HasSubset.Subset S M.E → Iff (M.Spanning S) (M'.Spanning S)\n⊢ Eq M M'","decl":"lemma ext_spanning {M M' : Matroid α} (h : M.E = M'.E)\n    (hsp : ∀ S, S ⊆ M.E → (M.Spanning S ↔ M'.Spanning S )) : M = M' := by\n  have hsp' : M.Spanning = M'.Spanning := by\n    ext S\n    refine (em (S ⊆ M.E)).elim (fun hSE ↦ by rw [hsp _ hSE] )\n      (fun hSE ↦ iff_of_false (fun h ↦ hSE h.subset_ground)\n      (fun h' ↦ hSE (h'.subset_ground.trans h.symm.subset)))\n  rw [← dual_inj, ext_iff_indep, dual_ground, dual_ground, and_iff_right h]\n  intro I hIE\n  rw [← coindep_def, ← coindep_def, coindep_iff_compl_spanning, coindep_iff_compl_spanning, hsp', h]\n\n"}
{"name":"Matroid.restrict_closure_eq'","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nX R : Set α\n⊢ Eq ((M.restrict R).closure X) (Union.union (Inter.inter (M.closure (Inter.inter X R)) R) (SDiff.sdiff R M.E))","decl":"@[simp] lemma restrict_closure_eq' (M : Matroid α) (X R : Set α) :\n    (M ↾ R).closure X = (M.closure (X ∩ R) ∩ R) ∪ (R \\ M.E) := by\n  obtain ⟨I, hI⟩ := (M ↾ R).exists_basis' X\n  obtain ⟨hI', hIR⟩ := basis'_restrict_iff.1 hI\n  ext e\n  rw [← hI.closure_eq_closure, ← hI'.closure_eq_closure, hI.indep.mem_closure_iff', mem_union,\n    mem_inter_iff, hI'.indep.mem_closure_iff', restrict_ground_eq, restrict_indep_iff, mem_diff]\n  by_cases he : M.Indep (insert e I)\n  · simp [he, and_comm, insert_subset_iff, hIR, (he.subset_ground (mem_insert ..)), imp_or]\n  tauto\n\n"}
{"name":"Matroid.restrict_closure_eq","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nX R : Set α\nM : Matroid α\nhXR : HasSubset.Subset X R\nhR : autoParam (HasSubset.Subset R M.E) _auto✝\n⊢ Eq ((M.restrict R).closure X) (Inter.inter (M.closure X) R)","decl":"lemma restrict_closure_eq (M : Matroid α) (hXR : X ⊆ R) (hR : R ⊆ M.E := by aesop_mat) :\n    (M ↾ R).closure X = M.closure X ∩ R := by\n  rw [restrict_closure_eq', diff_eq_empty.mpr hR, union_empty, inter_eq_self_of_subset_left hXR]\n\n"}
{"name":"Matroid.emptyOn_closure_eq","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nX : Set α\n⊢ Eq ((Matroid.emptyOn α).closure X) EmptyCollection.emptyCollection","decl":"@[simp] lemma emptyOn_closure_eq (X : Set α) : (emptyOn α).closure X = ∅ :=\n  (closure_subset_ground ..).antisymm <| empty_subset _\n\n"}
{"name":"Matroid.loopyOn_closure_eq","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nE X : Set α\n⊢ Eq ((Matroid.loopyOn E).closure X) E","decl":"@[simp] lemma loopyOn_closure_eq (E X : Set α) : (loopyOn E).closure X = E := by\n  simp [loopyOn, restrict_closure_eq']\n\n"}
{"name":"Matroid.loopyOn_spanning_iff","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nX E : Set α\n⊢ Iff ((Matroid.loopyOn E).Spanning X) (HasSubset.Subset X E)","decl":"@[simp] lemma loopyOn_spanning_iff {E : Set α} : (loopyOn E).Spanning X ↔ X ⊆ E := by\n  rw [spanning_iff, loopyOn_closure_eq, loopyOn_ground, and_iff_right rfl]\n\n"}
{"name":"Matroid.freeOn_closure_eq","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nE X : Set α\n⊢ Eq ((Matroid.freeOn E).closure X) (Inter.inter X E)","decl":"@[simp] lemma freeOn_closure_eq (E X : Set α) : (freeOn E).closure X = X ∩ E := by\n  simp (config := {contextual := true}) [← closure_inter_ground _ X, Set.ext_iff, and_comm,\n    insert_subset_iff, freeOn_indep_iff, (freeOn_indep inter_subset_right).mem_closure_iff']\n\n"}
{"name":"Matroid.uniqueBaseOn_closure_eq","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nI E X : Set α\n⊢ Eq ((Matroid.uniqueBaseOn I E).closure X) (Union.union (Inter.inter (Inter.inter X I) E) (SDiff.sdiff E I))","decl":"@[simp] lemma uniqueBaseOn_closure_eq (I E X : Set α) :\n    (uniqueBaseOn I E).closure X = (X ∩ I ∩ E) ∪ (E \\ I) := by\n  rw [uniqueBaseOn, restrict_closure_eq', freeOn_closure_eq, inter_right_comm,\n    inter_assoc (c := E), inter_self, inter_right_comm, freeOn_ground]\n\n"}
{"name":"Matroid.closure_empty_eq_ground_iff","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\n⊢ Iff (Eq (M.closure EmptyCollection.emptyCollection) M.E) (Eq M (Matroid.loopyOn M.E))","decl":"lemma closure_empty_eq_ground_iff : M.closure ∅ = M.E ↔ M = loopyOn M.E := by\n  refine ⟨fun h ↦ ext_closure ?_, fun h ↦ by rw [h, loopyOn_closure_eq, loopyOn_ground]⟩\n  refine fun X ↦ subset_antisymm (by simp [closure_subset_ground]) ?_\n  rw [loopyOn_closure_eq, ← h]\n  exact M.closure_mono (empty_subset _)\n\n"}
{"name":"Matroid.comap_closure_eq","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nβ : Type u_3\nM : Matroid β\nf : α → β\nX : Set α\n⊢ Eq ((M.comap f).closure X) (Set.preimage f (M.closure (Set.image f X)))","decl":"@[simp] lemma comap_closure_eq {β : Type*} (M : Matroid β) (f : α → β) (X : Set α) :\n    (M.comap f).closure X = f ⁻¹' M.closure (f '' X) := by\n  -- Use a choice of basis and extensionality to change the goal to a statement about independence.\n  obtain ⟨I, hI⟩ := (M.comap f).exists_basis' X\n  obtain ⟨hI', hIinj, -⟩ := comap_basis'_iff.1 hI\n  simp_rw [← hI.closure_eq_closure, ← hI'.closure_eq_closure, Set.ext_iff,\n    hI.indep.mem_closure_iff', comap_ground_eq, mem_preimage, hI'.indep.mem_closure_iff',\n    comap_indep_iff, and_imp, mem_image, and_congr_right_iff, ← image_insert_eq]\n  -- the lemma now easily follows by considering elements/non-elements of `I` separately.\n  intro x hxE\n  by_cases hxI : x ∈ I\n  · simp [hxI, show ∃ y ∈ I, f y = f x from ⟨x, hxI, rfl⟩]\n  simp [hxI, injOn_insert hxI, hIinj]\n\n"}
{"name":"Matroid.map_closure_eq","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nβ : Type u_3\nM : Matroid α\nf : α → β\nhf : Set.InjOn f M.E\nX : Set β\n⊢ Eq ((M.map f hf).closure X) (Set.image f (M.closure (Set.preimage f X)))","decl":"@[simp] lemma map_closure_eq {β : Type*} (M : Matroid α) (f : α → β) (hf) (X : Set β) :\n    (M.map f hf).closure X = f '' M.closure (f ⁻¹' X) := by\n  -- It is enough to prove that `map` and `closure` commute for `M`-independent sets.\n  suffices aux : ∀ ⦃I⦄, M.Indep I → (M.map f hf).closure (f '' I) = f '' (M.closure I) by\n    obtain ⟨I, hI⟩ := M.exists_basis (f ⁻¹' X ∩ M.E)\n    rw [← closure_inter_ground, map_ground, ← M.closure_inter_ground, ← hI.closure_eq_closure,\n      ← aux hI.indep, ← image_preimage_inter, ← (hI.map hf).closure_eq_closure]\n  -- Let `I` be independent, and transform the goal using closure/independence lemmas\n  refine fun I hI ↦ Set.ext fun e ↦ ?_\n  simp only [(hI.map f hf).mem_closure_iff', map_ground, mem_image, map_indep_iff,\n    forall_exists_index, and_imp, hI.mem_closure_iff']\n  -- The goal now easily follows from the invariance of independence under maps.\n  constructor\n  · rintro ⟨⟨x, hxE, rfl⟩, h2⟩\n    refine ⟨x, ⟨hxE, fun hI' ↦ ?_⟩, rfl⟩\n    obtain ⟨y, hyI, hfy⟩ := h2 _ hI' image_insert_eq.symm\n    rw [hf.eq_iff (hI.subset_ground hyI) hxE] at hfy\n    rwa [← hfy]\n  rintro ⟨x, ⟨hxE, hxi⟩, rfl⟩\n  refine ⟨⟨x, hxE, rfl⟩, fun J hJ hJI ↦ ⟨x, hxi ?_, rfl⟩⟩\n  replace hJ := hJ.map f hf\n  have hrw := image_insert_eq ▸ hJI\n  rwa [← hrw, map_image_indep_iff (insert_subset hxE hI.subset_ground)] at hJ\n\n"}
{"name":"Matroid.restrict_spanning_iff","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nR S : Set α\nhSR : HasSubset.Subset S R\nhR : autoParam (HasSubset.Subset R M.E) _auto✝\n⊢ Iff ((M.restrict R).Spanning S) (HasSubset.Subset R (M.closure S))","decl":"lemma restrict_spanning_iff (hSR : S ⊆ R) (hR : R ⊆ M.E := by aesop_mat) :\n    (M ↾ R).Spanning S ↔ R ⊆ M.closure S := by\n  rw [spanning_iff, restrict_ground_eq, and_iff_left hSR, restrict_closure_eq _ hSR, inter_eq_right]\n\n"}
{"name":"Matroid.restrict_spanning_iff'","module":"Mathlib.Data.Matroid.Closure","initialProofState":"α : Type u_2\nM : Matroid α\nR S : Set α\n⊢ Iff ((M.restrict R).Spanning S) (And (HasSubset.Subset (Inter.inter R M.E) (M.closure S)) (HasSubset.Subset S R))","decl":"lemma restrict_spanning_iff' : (M ↾ R).Spanning S ↔ R ∩ M.E ⊆ M.closure S ∧ S ⊆ R := by\n  rw [spanning_iff, restrict_closure_eq', restrict_ground_eq, and_congr_left_iff,\n    diff_eq_compl_inter, ← union_inter_distrib_right, inter_eq_right, union_comm,\n    ← diff_subset_iff, diff_compl]\n  intro hSR\n  rw [inter_eq_self_of_subset_left hSR]\n\n"}
