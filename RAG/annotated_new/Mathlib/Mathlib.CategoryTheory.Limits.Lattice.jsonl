{"name":"CategoryTheory.Limits.CompleteLattice.hasFiniteLimits_of_semilatticeInf_orderTop","module":"Mathlib.CategoryTheory.Limits.Lattice","initialProofState":"Œ± : Type u\ninst‚úù¬π : SemilatticeInf Œ±\ninst‚úù : OrderTop Œ±\n‚ä¢ CategoryTheory.Limits.HasFiniteLimits Œ±","decl":"instance (priority := 100) hasFiniteLimits_of_semilatticeInf_orderTop [SemilatticeInf Œ±]\n    [OrderTop Œ±] : HasFiniteLimits Œ± := ‚ü®by\n  intro J ùí•‚ÇÅ ùí•‚ÇÇ\n  exact { has_limit := fun F => HasLimit.mk (finiteLimitCone F) }‚ü©\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.CompleteLattice.hasFiniteColimits_of_semilatticeSup_orderBot","module":"Mathlib.CategoryTheory.Limits.Lattice","initialProofState":"Œ± : Type u\ninst‚úù¬π : SemilatticeSup Œ±\ninst‚úù : OrderBot Œ±\n‚ä¢ CategoryTheory.Limits.HasFiniteColimits Œ±","decl":"instance (priority := 100) hasFiniteColimits_of_semilatticeSup_orderBot [SemilatticeSup Œ±]\n    [OrderBot Œ±] : HasFiniteColimits Œ± := ‚ü®by\n  intro J ùí•‚ÇÅ ùí•‚ÇÇ\n  exact { has_colimit := fun F => HasColimit.mk (finiteColimitCocone F) }‚ü©\n\n"}
{"name":"CategoryTheory.Limits.CompleteLattice.finite_limit_eq_finset_univ_inf","module":"Mathlib.CategoryTheory.Limits.Lattice","initialProofState":"Œ± : Type u\nJ : Type w\ninst‚úù¬≥ : CategoryTheory.SmallCategory J\ninst‚úù¬≤ : CategoryTheory.FinCategory J\ninst‚úù¬π : SemilatticeInf Œ±\ninst‚úù : OrderTop Œ±\nF : CategoryTheory.Functor J Œ±\n‚ä¢ Eq (CategoryTheory.Limits.limit F) (Finset.univ.inf F.obj)","decl":"/-- The limit of a functor from a finite diagram into a `SemilatticeInf` with `OrderTop` is the\ninfimum of the objects in the image.\n-/\ntheorem finite_limit_eq_finset_univ_inf [SemilatticeInf Œ±] [OrderTop Œ±] (F : J ‚•§ Œ±) :\n    limit F = Finset.univ.inf F.obj :=\n  (IsLimit.conePointUniqueUpToIso (limit.isLimit F) (finiteLimitCone F).isLimit).to_eq\n\n"}
{"name":"CategoryTheory.Limits.CompleteLattice.finite_colimit_eq_finset_univ_sup","module":"Mathlib.CategoryTheory.Limits.Lattice","initialProofState":"Œ± : Type u\nJ : Type w\ninst‚úù¬≥ : CategoryTheory.SmallCategory J\ninst‚úù¬≤ : CategoryTheory.FinCategory J\ninst‚úù¬π : SemilatticeSup Œ±\ninst‚úù : OrderBot Œ±\nF : CategoryTheory.Functor J Œ±\n‚ä¢ Eq (CategoryTheory.Limits.colimit F) (Finset.univ.sup F.obj)","decl":"/-- The colimit of a functor from a finite diagram into a `SemilatticeSup` with `OrderBot`\nis the supremum of the objects in the image.\n-/\ntheorem finite_colimit_eq_finset_univ_sup [SemilatticeSup Œ±] [OrderBot Œ±] (F : J ‚•§ Œ±) :\n    colimit F = Finset.univ.sup F.obj :=\n  (IsColimit.coconePointUniqueUpToIso (colimit.isColimit F) (finiteColimitCocone F).isColimit).to_eq\n\n"}
{"name":"CategoryTheory.Limits.CompleteLattice.finite_product_eq_finset_inf","module":"Mathlib.CategoryTheory.Limits.Lattice","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : SemilatticeInf Œ±\ninst‚úù¬π : OrderTop Œ±\nŒπ : Type u\ninst‚úù : Fintype Œπ\nf : Œπ ‚Üí Œ±\n‚ä¢ Eq (CategoryTheory.Limits.piObj f) (Fintype.elems.inf f)","decl":"/--\nA finite product in the category of a `SemilatticeInf` with `OrderTop` is the same as the infimum.\n-/\ntheorem finite_product_eq_finset_inf [SemilatticeInf Œ±] [OrderTop Œ±] {Œπ : Type u} [Fintype Œπ]\n    (f : Œπ ‚Üí Œ±) : ‚àè·∂ú f = Fintype.elems.inf f := by\n  trans\n  ¬∑ exact\n      (IsLimit.conePointUniqueUpToIso (limit.isLimit _)\n          (finiteLimitCone (Discrete.functor f)).isLimit).to_eq\n  change Finset.univ.inf (f ‚àò discreteEquiv.toEmbedding) = Fintype.elems.inf f\n  simp only [‚Üê Finset.inf_map, Finset.univ_map_equiv_to_embedding]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.CompleteLattice.finite_coproduct_eq_finset_sup","module":"Mathlib.CategoryTheory.Limits.Lattice","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : SemilatticeSup Œ±\ninst‚úù¬π : OrderBot Œ±\nŒπ : Type u\ninst‚úù : Fintype Œπ\nf : Œπ ‚Üí Œ±\n‚ä¢ Eq (CategoryTheory.Limits.sigmaObj f) (Fintype.elems.sup f)","decl":"/-- A finite coproduct in the category of a `SemilatticeSup` with `OrderBot` is the same as the\nsupremum.\n-/\ntheorem finite_coproduct_eq_finset_sup [SemilatticeSup Œ±] [OrderBot Œ±] {Œπ : Type u} [Fintype Œπ]\n    (f : Œπ ‚Üí Œ±) : ‚àê f = Fintype.elems.sup f := by\n  trans\n  ¬∑ exact\n      (IsColimit.coconePointUniqueUpToIso (colimit.isColimit _)\n          (finiteColimitCocone (Discrete.functor f)).isColimit).to_eq\n  change Finset.univ.sup (f ‚àò discreteEquiv.toEmbedding) = Fintype.elems.sup f\n  simp only [‚Üê Finset.sup_map, Finset.univ_map_equiv_to_embedding]\n  rfl\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.CompleteLattice.instHasBinaryProductsOfOrderTop","module":"Mathlib.CategoryTheory.Limits.Lattice","initialProofState":"Œ± : Type u\ninst‚úù¬π : SemilatticeInf Œ±\ninst‚úù : OrderTop Œ±\n‚ä¢ CategoryTheory.Limits.HasBinaryProducts Œ±","decl":"instance (priority := 100) [SemilatticeInf Œ±] [OrderTop Œ±] : HasBinaryProducts Œ± := by\n  have : ‚àÄ x y : Œ±, HasLimit (pair x y) := by\n    letI := hasFiniteLimits_of_hasFiniteLimits_of_size.{u} Œ±\n    infer_instance\n  apply hasBinaryProducts_of_hasLimit_pair\n\n"}
{"name":"CategoryTheory.Limits.CompleteLattice.prod_eq_inf","module":"Mathlib.CategoryTheory.Limits.Lattice","initialProofState":"Œ± : Type u\ninst‚úù¬π : SemilatticeInf Œ±\ninst‚úù : OrderTop Œ±\nx y : Œ±\n‚ä¢ Eq (CategoryTheory.Limits.prod x y) (Min.min x y)","decl":"/-- The binary product in the category of a `SemilatticeInf` with `OrderTop` is the same as the\ninfimum.\n-/\n@[simp]\ntheorem prod_eq_inf [SemilatticeInf Œ±] [OrderTop Œ±] (x y : Œ±) : Limits.prod x y = x ‚äì y :=\n  calc\n    Limits.prod x y = limit (pair x y) := rfl\n    _ = Finset.univ.inf (pair x y).obj := by rw [finite_limit_eq_finset_univ_inf (pair.{u} x y)]\n    _ = x ‚äì (y ‚äì ‚ä§) := rfl\n    -- Note: finset.inf is realized as a fold, hence the definitional equality\n    _ = x ‚äì y := by rw [inf_top_eq]\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.CompleteLattice.instHasBinaryCoproductsOfOrderBot","module":"Mathlib.CategoryTheory.Limits.Lattice","initialProofState":"Œ± : Type u\ninst‚úù¬π : SemilatticeSup Œ±\ninst‚úù : OrderBot Œ±\n‚ä¢ CategoryTheory.Limits.HasBinaryCoproducts Œ±","decl":"instance (priority := 100) [SemilatticeSup Œ±] [OrderBot Œ±] : HasBinaryCoproducts Œ± := by\n  have : ‚àÄ x y : Œ±, HasColimit (pair x y) := by\n    letI := hasFiniteColimits_of_hasFiniteColimits_of_size.{u} Œ±\n    infer_instance\n  apply hasBinaryCoproducts_of_hasColimit_pair\n\n"}
{"name":"CategoryTheory.Limits.CompleteLattice.coprod_eq_sup","module":"Mathlib.CategoryTheory.Limits.Lattice","initialProofState":"Œ± : Type u\ninst‚úù¬π : SemilatticeSup Œ±\ninst‚úù : OrderBot Œ±\nx y : Œ±\n‚ä¢ Eq (CategoryTheory.Limits.coprod x y) (Max.max x y)","decl":"/-- The binary coproduct in the category of a `SemilatticeSup` with `OrderBot` is the same as the\nsupremum.\n-/\n@[simp]\ntheorem coprod_eq_sup [SemilatticeSup Œ±] [OrderBot Œ±] (x y : Œ±) : Limits.coprod x y = x ‚äî y :=\n  calc\n    Limits.coprod x y = colimit (pair x y) := rfl\n    _ = Finset.univ.sup (pair x y).obj := by rw [finite_colimit_eq_finset_univ_sup (pair x y)]\n    _ = x ‚äî (y ‚äî ‚ä•) := rfl\n    -- Note: Finset.sup is realized as a fold, hence the definitional equality\n    _ = x ‚äî y := by rw [sup_bot_eq]\n\n"}
{"name":"CategoryTheory.Limits.CompleteLattice.pullback_eq_inf","module":"Mathlib.CategoryTheory.Limits.Lattice","initialProofState":"Œ± : Type u\ninst‚úù¬π : SemilatticeInf Œ±\ninst‚úù : OrderTop Œ±\nx y z : Œ±\nf : Quiver.Hom x z\ng : Quiver.Hom y z\n‚ä¢ Eq (CategoryTheory.Limits.pullback f g) (Min.min x y)","decl":"/-- The pullback in the category of a `SemilatticeInf` with `OrderTop` is the same as the infimum\nover the objects.\n-/\n@[simp]\ntheorem pullback_eq_inf [SemilatticeInf Œ±] [OrderTop Œ±] {x y z : Œ±} (f : x ‚ü∂ z) (g : y ‚ü∂ z) :\n    pullback f g = x ‚äì y :=\n  calc\n    pullback f g = limit (cospan f g) := rfl\n    _ = Finset.univ.inf (cospan f g).obj := by rw [finite_limit_eq_finset_univ_inf]\n    _ = z ‚äì (x ‚äì (y ‚äì ‚ä§)) := rfl\n    _ = z ‚äì (x ‚äì y) := by rw [inf_top_eq]\n    _ = x ‚äì y := inf_eq_right.mpr (inf_le_of_left_le f.le)\n\n"}
{"name":"CategoryTheory.Limits.CompleteLattice.pushout_eq_sup","module":"Mathlib.CategoryTheory.Limits.Lattice","initialProofState":"Œ± : Type u\ninst‚úù¬π : SemilatticeSup Œ±\ninst‚úù : OrderBot Œ±\nx y z : Œ±\nf : Quiver.Hom z x\ng : Quiver.Hom z y\n‚ä¢ Eq (CategoryTheory.Limits.pushout f g) (Max.max x y)","decl":"/-- The pushout in the category of a `SemilatticeSup` with `OrderBot` is the same as the supremum\nover the objects.\n-/\n@[simp]\ntheorem pushout_eq_sup [SemilatticeSup Œ±] [OrderBot Œ±] (x y z : Œ±) (f : z ‚ü∂ x) (g : z ‚ü∂ y) :\n    pushout f g = x ‚äî y :=\n  calc\n    pushout f g = colimit (span f g) := rfl\n    _ = Finset.univ.sup (span f g).obj := by rw [finite_colimit_eq_finset_univ_sup]\n    _ = z ‚äî (x ‚äî (y ‚äî ‚ä•)) := rfl\n    _ = z ‚äî (x ‚äî y) := by rw [sup_bot_eq]\n    _ = x ‚äî y := sup_eq_right.mpr (le_sup_of_le_left f.le)\n\n"}
{"name":"CategoryTheory.Limits.CompleteLattice.hasLimits_of_completeLattice","module":"Mathlib.CategoryTheory.Limits.Lattice","initialProofState":"Œ± : Type u\ninst‚úù : CompleteLattice Œ±\n‚ä¢ CategoryTheory.Limits.HasLimits Œ±","decl":"instance (priority := 100) hasLimits_of_completeLattice : HasLimits Œ± where\n  has_limits_of_shape _ := { has_limit := fun F => HasLimit.mk (limitCone F) }\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.CompleteLattice.hasColimits_of_completeLattice","module":"Mathlib.CategoryTheory.Limits.Lattice","initialProofState":"Œ± : Type u\ninst‚úù : CompleteLattice Œ±\n‚ä¢ CategoryTheory.Limits.HasColimits Œ±","decl":"instance (priority := 100) hasColimits_of_completeLattice : HasColimits Œ± where\n  has_colimits_of_shape _ := { has_colimit := fun F => HasColimit.mk (colimitCocone F) }\n\n"}
{"name":"CategoryTheory.Limits.CompleteLattice.limit_eq_iInf","module":"Mathlib.CategoryTheory.Limits.Lattice","initialProofState":"Œ± : Type u\ninst‚úù¬π : CompleteLattice Œ±\nJ : Type u\ninst‚úù : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J Œ±\n‚ä¢ Eq (CategoryTheory.Limits.limit F) (iInf F.obj)","decl":"/-- The limit of a functor into a complete lattice is the infimum of the objects in the image.\n-/\ntheorem limit_eq_iInf (F : J ‚•§ Œ±) : limit F = iInf F.obj :=\n  (IsLimit.conePointUniqueUpToIso (limit.isLimit F) (limitCone F).isLimit).to_eq\n\n"}
{"name":"CategoryTheory.Limits.CompleteLattice.colimit_eq_iSup","module":"Mathlib.CategoryTheory.Limits.Lattice","initialProofState":"Œ± : Type u\ninst‚úù¬π : CompleteLattice Œ±\nJ : Type u\ninst‚úù : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J Œ±\n‚ä¢ Eq (CategoryTheory.Limits.colimit F) (iSup F.obj)","decl":"/-- The colimit of a functor into a complete lattice is the supremum of the objects in the image.\n-/\ntheorem colimit_eq_iSup (F : J ‚•§ Œ±) : colimit F = iSup F.obj :=\n  (IsColimit.coconePointUniqueUpToIso (colimit.isColimit F) (colimitCocone F).isColimit).to_eq\n\n"}
