{"name":"CategoryTheory.Equivalence.instIsCoverDenseOfIsEquivalence","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\ninst‚úù : G.IsEquivalence\n‚ä¢ G.IsCoverDense J","decl":"instance (priority := 900) [G.IsEquivalence] : IsCoverDense G J where\n  is_cover U := by\n    let e := (asEquivalence G).symm\n    convert J.top_mem U\n    ext Y f\n    simp only [Sieve.functorPushforward_apply, Presieve.functorPushforward, exists_and_left,\n      Sieve.top_apply, iff_true]\n    let g : e.inverse.obj _ ‚ü∂ U := (e.unitInv.app Y) ‚â´ f\n    have : (Sieve.coverByImage e.inverse U).arrows g := Presieve.in_coverByImage _ g\n    replace := Sieve.downward_closed _ this (e.unit.app Y)\n    simpa [g] using this\n\n"}
{"name":"CategoryTheory.Equivalence.instIsDenseSubsiteInducedTopologyInverseFunctor","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\n‚ä¢ CategoryTheory.Functor.IsDenseSubsite J (e.inverse.inducedTopology J) e.functor","decl":"instance : e.functor.IsDenseSubsite J (e.inverse.inducedTopology J) := by\n  have : J = e.functor.inducedTopology (e.inverse.inducedTopology J) := by\n    ext X S\n    rw [show S ‚àà (e.functor.inducedTopology (e.inverse.inducedTopology J)) X ‚Üî _\n      from (GrothendieckTopology.pullback_mem_iff_of_isIso (i := e.unit.app X)).symm]\n    congr!; ext Y f; simp\n  nth_rw 1 [this]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Equivalence.eq_inducedTopology_of_isDenseSubsite","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\ne : CategoryTheory.Equivalence C D\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite K J e.inverse\n‚ä¢ Eq K (e.inverse.inducedTopology J)","decl":"lemma eq_inducedTopology_of_isDenseSubsite [e.inverse.IsDenseSubsite K J] :\n    K = e.inverse.inducedTopology J := by\n  ext\n  exact (e.inverse.functorPushforward_mem_iff K J).symm\n\n"}
{"name":"CategoryTheory.Equivalence.instIsDenseSubsiteFunctor","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\ne : CategoryTheory.Equivalence C D\n‚ä¢ CategoryTheory.Functor.IsDenseSubsite J K e.functor","decl":"instance : e.functor.IsDenseSubsite J K := by\n  rw [e.eq_inducedTopology_of_isDenseSubsite J K]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongr.functor_obj_val_obj","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\ne : CategoryTheory.Equivalence C D\nA : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite K J e.inverse\nF : CategoryTheory.Sheaf J A\nX : Opposite D\n‚ä¢ Eq (((CategoryTheory.Equivalence.sheafCongr.functor J K e A).obj F).val.obj X) (F.val.obj { unop := e.inverse.obj (Opposite.unop X) })","decl":"/-- The functor in the equivalence of sheaf categories. -/\n@[simps!]\ndef sheafCongr.functor : Sheaf J A ‚•§ Sheaf K A where\n  obj F := ‚ü®e.inverse.op ‚ãô F.val, e.inverse.op_comp_isSheaf _ _ _‚ü©\n  map f := ‚ü®whiskerLeft e.inverse.op f.val‚ü©\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongr.functor_map_val_app","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\ne : CategoryTheory.Equivalence C D\nA : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite K J e.inverse\nX‚úù Y‚úù : CategoryTheory.Sheaf J A\nf : Quiver.Hom X‚úù Y‚úù\nX : Opposite D\n‚ä¢ Eq (((CategoryTheory.Equivalence.sheafCongr.functor J K e A).map f).val.app X) (f.val.app { unop := e.inverse.obj (Opposite.unop X) })","decl":"/-- The functor in the equivalence of sheaf categories. -/\n@[simps!]\ndef sheafCongr.functor : Sheaf J A ‚•§ Sheaf K A where\n  obj F := ‚ü®e.inverse.op ‚ãô F.val, e.inverse.op_comp_isSheaf _ _ _‚ü©\n  map f := ‚ü®whiskerLeft e.inverse.op f.val‚ü©\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongr.functor_obj_val_map","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\ne : CategoryTheory.Equivalence C D\nA : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite K J e.inverse\nF : CategoryTheory.Sheaf J A\nX‚úù Y‚úù : Opposite D\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((CategoryTheory.Equivalence.sheafCongr.functor J K e A).obj F).val.map f) (F.val.map (e.inverse.map f.unop).op)","decl":"/-- The functor in the equivalence of sheaf categories. -/\n@[simps!]\ndef sheafCongr.functor : Sheaf J A ‚•§ Sheaf K A where\n  obj F := ‚ü®e.inverse.op ‚ãô F.val, e.inverse.op_comp_isSheaf _ _ _‚ü©\n  map f := ‚ü®whiskerLeft e.inverse.op f.val‚ü©\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongr.inverse_obj_val_map","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\ne : CategoryTheory.Equivalence C D\nA : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nF : CategoryTheory.Sheaf K A\nX‚úù Y‚úù : Opposite C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((CategoryTheory.Equivalence.sheafCongr.inverse J K e A).obj F).val.map f) (F.val.map (e.functor.map f.unop).op)","decl":"/-- The inverse in the equivalence of sheaf categories. -/\n@[simps!]\ndef sheafCongr.inverse : Sheaf K A ‚•§ Sheaf J A where\n  obj F := ‚ü®e.functor.op ‚ãô F.val, e.functor.op_comp_isSheaf _ _ _‚ü©\n  map f := ‚ü®whiskerLeft e.functor.op f.val‚ü©\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongr.inverse_obj_val_obj","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\ne : CategoryTheory.Equivalence C D\nA : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nF : CategoryTheory.Sheaf K A\nX : Opposite C\n‚ä¢ Eq (((CategoryTheory.Equivalence.sheafCongr.inverse J K e A).obj F).val.obj X) (F.val.obj { unop := e.functor.obj (Opposite.unop X) })","decl":"/-- The inverse in the equivalence of sheaf categories. -/\n@[simps!]\ndef sheafCongr.inverse : Sheaf K A ‚•§ Sheaf J A where\n  obj F := ‚ü®e.functor.op ‚ãô F.val, e.functor.op_comp_isSheaf _ _ _‚ü©\n  map f := ‚ü®whiskerLeft e.functor.op f.val‚ü©\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongr.inverse_map_val_app","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\ne : CategoryTheory.Equivalence C D\nA : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nX‚úù Y‚úù : CategoryTheory.Sheaf K A\nf : Quiver.Hom X‚úù Y‚úù\nX : Opposite C\n‚ä¢ Eq (((CategoryTheory.Equivalence.sheafCongr.inverse J K e A).map f).val.app X) (f.val.app { unop := e.functor.obj (Opposite.unop X) })","decl":"/-- The inverse in the equivalence of sheaf categories. -/\n@[simps!]\ndef sheafCongr.inverse : Sheaf K A ‚•§ Sheaf J A where\n  obj F := ‚ü®e.functor.op ‚ãô F.val, e.functor.op_comp_isSheaf _ _ _‚ü©\n  map f := ‚ü®whiskerLeft e.functor.op f.val‚ü©\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongr.unitIso_hom_app_val_app","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\ne : CategoryTheory.Equivalence C D\nA : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite K J e.inverse\nX‚úù : CategoryTheory.Sheaf J A\nX : Opposite C\n‚ä¢ Eq (((CategoryTheory.Equivalence.sheafCongr.unitIso J K e A).hom.app X‚úù).val.app X) (X‚úù.val.map (e.unitIso.inv.app (Opposite.unop X)).op)","decl":"/-- The unit iso in the equivalence of sheaf categories. -/\n@[simps!]\ndef sheafCongr.unitIso : ùü≠ (Sheaf J A) ‚âÖ functor J K e A ‚ãô inverse J K e A :=\n  NatIso.ofComponents (fun F ‚Ü¶ ‚ü®‚ü®(isoWhiskerRight e.op.unitIso F.val).hom‚ü©,\n    ‚ü®(isoWhiskerRight e.op.unitIso F.val).inv‚ü©,\n    Sheaf.hom_ext _ _ (isoWhiskerRight e.op.unitIso F.val).hom_inv_id,\n    Sheaf.hom_ext _ _ (isoWhiskerRight e.op.unitIso F.val).inv_hom_id‚ü© ) (by aesop)\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongr.unitIso_inv_app_val_app","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\ne : CategoryTheory.Equivalence C D\nA : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite K J e.inverse\nX‚úù : CategoryTheory.Sheaf J A\nX : Opposite C\n‚ä¢ Eq (((CategoryTheory.Equivalence.sheafCongr.unitIso J K e A).inv.app X‚úù).val.app X) (X‚úù.val.map (e.unitIso.hom.app (Opposite.unop X)).op)","decl":"/-- The unit iso in the equivalence of sheaf categories. -/\n@[simps!]\ndef sheafCongr.unitIso : ùü≠ (Sheaf J A) ‚âÖ functor J K e A ‚ãô inverse J K e A :=\n  NatIso.ofComponents (fun F ‚Ü¶ ‚ü®‚ü®(isoWhiskerRight e.op.unitIso F.val).hom‚ü©,\n    ‚ü®(isoWhiskerRight e.op.unitIso F.val).inv‚ü©,\n    Sheaf.hom_ext _ _ (isoWhiskerRight e.op.unitIso F.val).hom_inv_id,\n    Sheaf.hom_ext _ _ (isoWhiskerRight e.op.unitIso F.val).inv_hom_id‚ü© ) (by aesop)\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongr.counitIso_hom_app_val_app","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\ne : CategoryTheory.Equivalence C D\nA : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite K J e.inverse\nX‚úù : CategoryTheory.Sheaf K A\nX : Opposite D\n‚ä¢ Eq (((CategoryTheory.Equivalence.sheafCongr.counitIso J K e A).hom.app X‚úù).val.app X) (X‚úù.val.map (e.counitIso.inv.app (Opposite.unop X)).op)","decl":"/-- The counit iso in the equivalence of sheaf categories. -/\n@[simps!]\ndef sheafCongr.counitIso : inverse J K e A ‚ãô functor J K e A ‚âÖ ùü≠ (Sheaf _ A) :=\n  NatIso.ofComponents (fun F ‚Ü¶ ‚ü®‚ü®(isoWhiskerRight e.op.counitIso F.val).hom‚ü©,\n    ‚ü®(isoWhiskerRight e.op.counitIso F.val).inv‚ü©,\n    Sheaf.hom_ext _ _ (isoWhiskerRight e.op.counitIso F.val).hom_inv_id,\n    Sheaf.hom_ext _ _ (isoWhiskerRight e.op.counitIso F.val).inv_hom_id‚ü© ) (by aesop)\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongr.counitIso_inv_app_val_app","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\ne : CategoryTheory.Equivalence C D\nA : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite K J e.inverse\nX‚úù : CategoryTheory.Sheaf K A\nX : Opposite D\n‚ä¢ Eq (((CategoryTheory.Equivalence.sheafCongr.counitIso J K e A).inv.app X‚úù).val.app X) (X‚úù.val.map (e.counitIso.hom.app (Opposite.unop X)).op)","decl":"/-- The counit iso in the equivalence of sheaf categories. -/\n@[simps!]\ndef sheafCongr.counitIso : inverse J K e A ‚ãô functor J K e A ‚âÖ ùü≠ (Sheaf _ A) :=\n  NatIso.ofComponents (fun F ‚Ü¶ ‚ü®‚ü®(isoWhiskerRight e.op.counitIso F.val).hom‚ü©,\n    ‚ü®(isoWhiskerRight e.op.counitIso F.val).inv‚ü©,\n    Sheaf.hom_ext _ _ (isoWhiskerRight e.op.counitIso F.val).hom_inv_id,\n    Sheaf.hom_ext _ _ (isoWhiskerRight e.op.counitIso F.val).inv_hom_id‚ü© ) (by aesop)\n\n"}
{"name":"CategoryTheory.Equivalence.instPreservesFiniteLimitsFunctorOppositeSheafTransportAndSheafify","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\ne : CategoryTheory.Equivalence C D\nA : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\ninst‚úù¬π : CategoryTheory.Functor.IsDenseSubsite K J e.inverse\ninst‚úù : CategoryTheory.HasSheafify K A\n‚ä¢ CategoryTheory.Limits.PreservesFiniteLimits (CategoryTheory.Equivalence.transportAndSheafify J K e A)","decl":"noncomputable instance : PreservesFiniteLimits <| transportAndSheafify J K e A where\n  preservesFiniteLimits _ := comp_preservesLimitsOfShape _ _\n\n"}
{"name":"CategoryTheory.Equivalence.hasSheafify","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\ne : CategoryTheory.Equivalence C D\nA : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\ninst‚úù¬π : CategoryTheory.Functor.IsDenseSubsite K J e.inverse\ninst‚úù : CategoryTheory.HasSheafify K A\n‚ä¢ CategoryTheory.HasSheafify J A","decl":"include K e in\n/-- Transport `HasSheafify` along an equivalence of sites. -/\ntheorem hasSheafify : HasSheafify J A :=\n  HasSheafify.mk' J A (transportSheafificationAdjunction J K e A)\n\n"}
{"name":"CategoryTheory.Equivalence.hasSheafCompose","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\ne : CategoryTheory.Equivalence C D\ninst‚úù¬≥ : CategoryTheory.Functor.IsDenseSubsite K J e.inverse\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} A\nB : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_2} B\nF : CategoryTheory.Functor A B\ninst‚úù : K.HasSheafCompose F\n‚ä¢ J.HasSheafCompose F","decl":"include K e in\ntheorem hasSheafCompose : J.HasSheafCompose F where\n  isSheaf P hP := by\n    have hP' : Presheaf.IsSheaf K (e.inverse.op ‚ãô P ‚ãô F) := by\n      change Presheaf.IsSheaf K ((_ ‚ãô _) ‚ãô _)\n      apply HasSheafCompose.isSheaf\n      exact e.inverse.op_comp_isSheaf K J ‚ü®P, hP‚ü©\n    replace hP' : Presheaf.IsSheaf J (e.functor.op ‚ãô e.inverse.op ‚ãô P ‚ãô F) :=\n      e.functor.op_comp_isSheaf _ _ ‚ü®_, hP'‚ü©\n    exact (Presheaf.isSheaf_of_iso_iff ((isoWhiskerRight e.op.unitIso.symm (P ‚ãô F)))).mp hP'\n\n"}
{"name":"CategoryTheory.hasSheafifyEssentiallySmallSite","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\ninst‚úù¬π : CategoryTheory.EssentiallySmall.{w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.HasSheafify ((CategoryTheory.equivSmallModel C).inverse.inducedTopology J) A\n‚ä¢ CategoryTheory.HasSheafify J A","decl":"noncomputable instance hasSheafifyEssentiallySmallSite : HasSheafify J A :=\n  (equivSmallModel C).hasSheafify J ((equivSmallModel C).inverse.inducedTopology J) A\n\n"}
{"name":"CategoryTheory.hasSheafComposeEssentiallySmallSite","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nB : Type u‚ÇÑ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nF : CategoryTheory.Functor A B\ninst‚úù¬π : CategoryTheory.EssentiallySmall.{w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : ((CategoryTheory.equivSmallModel C).inverse.inducedTopology J).HasSheafCompose F\n‚ä¢ J.HasSheafCompose F","decl":"instance hasSheafComposeEssentiallySmallSite : HasSheafCompose J F :=\n  (equivSmallModel C).hasSheafCompose J ((equivSmallModel C).inverse.inducedTopology J) F\n\n"}
{"name":"CategoryTheory.hasLimitsEssentiallySmallSite","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\ninst‚úù¬π : CategoryTheory.EssentiallySmall.{w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasLimits (CategoryTheory.Sheaf ((CategoryTheory.equivSmallModel C).inverse.inducedTopology J) A)\n‚ä¢ CategoryTheory.Limits.HasLimitsOfSize.{max v‚ÇÉ w, max v‚ÇÉ w, max u‚ÇÅ v‚ÇÉ, max (max (max u‚ÇÉ u‚ÇÅ) v‚ÇÉ) v‚ÇÅ} (CategoryTheory.Sheaf J A)","decl":"instance hasLimitsEssentiallySmallSite\n    [HasLimits <| Sheaf ((equivSmallModel C).inverse.inducedTopology J) A] :\n    HasLimitsOfSize.{max v‚ÇÉ w, max v‚ÇÉ w} <| Sheaf J A :=\n  Adjunction.has_limits_of_equivalence ((equivSmallModel C).sheafCongr J\n    ((equivSmallModel C).inverse.inducedTopology J) A).functor\n\n"}
{"name":"CategoryTheory.hasColimitsEssentiallySmallSite","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\ninst‚úù¬π : CategoryTheory.EssentiallySmall.{w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasColimits (CategoryTheory.Sheaf ((CategoryTheory.equivSmallModel C).inverse.inducedTopology J) A)\n‚ä¢ CategoryTheory.Limits.HasColimitsOfSize.{max v‚ÇÉ w, max v‚ÇÉ w, max u‚ÇÅ v‚ÇÉ, max (max (max u‚ÇÉ u‚ÇÅ) v‚ÇÉ) v‚ÇÅ} (CategoryTheory.Sheaf J A)","decl":"instance hasColimitsEssentiallySmallSite\n    [HasColimits <| Sheaf ((equivSmallModel C).inverse.inducedTopology J) A] :\n    HasColimitsOfSize.{max v‚ÇÉ w, max v‚ÇÉ w} <| Sheaf J A :=\n  Adjunction.has_colimits_of_equivalence ((equivSmallModel C).sheafCongr J\n    ((equivSmallModel C).inverse.inducedTopology J) A).functor\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.W_inverseImage_whiskeringLeft","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor D C\nA : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\ninst‚úù¬≥ : G.IsCoverDense J\ninst‚úù¬≤ : G.Full\ninst‚úù¬π : G.IsContinuous K J\ninst‚úù : (G.sheafPushforwardContinuous A K J).EssSurj\n‚ä¢ Eq (K.W.inverseImage ((CategoryTheory.whiskeringLeft (Opposite D) (Opposite C) A).obj G.op)) J.W","decl":"lemma W_inverseImage_whiskeringLeft :\n    K.W.inverseImage ((whiskeringLeft D·µí·µñ C·µí·µñ A).obj G.op) = J.W := by\n  ext P Q f\n  have h‚ÇÅ : K.W (A := A) =\n    Localization.LeftBousfield.W (¬∑ ‚àà Set.range (sheafToPresheaf J A ‚ãô\n      ((whiskeringLeft D·µí·µñ C·µí·µñ A).obj G.op)).obj) := by\n    rw [W_eq_W_range_sheafToPresheaf_obj, ‚Üê LeftBousfield.W_isoClosure]\n    conv_rhs => rw [‚Üê LeftBousfield.W_isoClosure]\n    apply congr_arg\n    ext P\n    constructor\n    ¬∑ rintro ‚ü®_, ‚ü®R, rfl‚ü©, ‚ü®e‚ü©‚ü©\n      exact ‚ü®_, ‚ü®_, rfl‚ü©, ‚ü®e.trans ((sheafToPresheaf _ _).mapIso\n        ((G.sheafPushforwardContinuous A K J).objObjPreimageIso R).symm)‚ü©‚ü©\n    ¬∑ rintro ‚ü®_, ‚ü®R, rfl‚ü©, ‚ü®e‚ü©‚ü©\n      exact ‚ü®G.op ‚ãô R.val, ‚ü®(G.sheafPushforwardContinuous A K J).obj R, rfl‚ü©, ‚ü®e‚ü©‚ü©\n  have h‚ÇÇ : ‚àÄ (R : Sheaf J A),\n    Function.Bijective (fun (g : G.op ‚ãô Q ‚ü∂ G.op ‚ãô R.val) ‚Ü¶ whiskerLeft G.op f ‚â´ g) ‚Üî\n      Function.Bijective (fun (g : Q ‚ü∂ R.val) ‚Ü¶ f ‚â´ g) := fun R ‚Ü¶ by\n    rw [‚Üê Function.Bijective.of_comp_iff _\n      (Functor.whiskerLeft_obj_map_bijective_of_isCoverDense J G Q R.val R.cond)]\n    exact Function.Bijective.of_comp_iff'\n      (Functor.whiskerLeft_obj_map_bijective_of_isCoverDense J G P R.val R.cond)\n        (fun g ‚Ü¶ f ‚â´ g)\n  rw [h‚ÇÅ, J.W_eq_W_range_sheafToPresheaf_obj, MorphismProperty.inverseImage_iff]\n  constructor\n  ¬∑ rintro h _ ‚ü®R, rfl‚ü©\n    exact (h‚ÇÇ R).1 (h _ ‚ü®R, rfl‚ü©)\n  ¬∑ rintro h _ ‚ü®R, rfl‚ü©\n    exact (h‚ÇÇ R).2 (h _ ‚ü®R, rfl‚ü©)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.W_whiskerLeft_iff","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor D C\nA : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\ninst‚úù¬≥ : G.IsCoverDense J\ninst‚úù¬≤ : G.Full\ninst‚úù¬π : G.IsContinuous K J\ninst‚úù : (G.sheafPushforwardContinuous A K J).EssSurj\nP Q : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom P Q\n‚ä¢ Iff (K.W (CategoryTheory.whiskerLeft G.op f)) (J.W f)","decl":"lemma W_whiskerLeft_iff {P Q : C·µí·µñ ‚•§ A} (f : P ‚ü∂ Q) :\n    K.W (whiskerLeft G.op f) ‚Üî J.W f := by\n  rw [‚Üê W_inverseImage_whiskeringLeft J K G]\n  rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.PreservesSheafification.transport","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π‚Å∞ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù‚Åπ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor D C\nA : Type u‚ÇÉ\ninst‚úù‚Å∏ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nB : Type u‚ÇÑ\ninst‚úù‚Å∑ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nF : CategoryTheory.Functor A B\ninst‚úù‚Å∂ : G.IsCoverDense J\ninst‚úù‚Åµ : G.Full\ninst‚úù‚Å¥ : G.IsContinuous K J\ninst‚úù¬≥ : G.IsContinuous K J\ninst‚úù¬≤ : (G.sheafPushforwardContinuous B K J).EssSurj\ninst‚úù¬π : (G.sheafPushforwardContinuous A K J).EssSurj\ninst‚úù : K.PreservesSheafification F\n‚ä¢ J.PreservesSheafification F","decl":"lemma PreservesSheafification.transport\n    [Functor.IsContinuous.{v‚ÇÑ} G K J] [Functor.IsContinuous.{v‚ÇÉ} G K J]\n    [(G.sheafPushforwardContinuous B K J).EssSurj]\n    [(G.sheafPushforwardContinuous A K J).EssSurj]\n    [K.PreservesSheafification F] : J.PreservesSheafification F where\n  le P Q f hf := by\n    rw [‚Üê J.W_whiskerLeft_iff (G := G) (K := K)] at hf\n    have := K.W_of_preservesSheafification F (whiskerLeft G.op f) hf\n    rwa [whiskerRight_left,\n      K.W_whiskerLeft_iff (G := G) (J := J) (f := whiskerRight f F)] at this\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.WEqualsLocallyBijective.transport","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åπ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù‚Å∏ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor D C\nA : Type u‚ÇÉ\ninst‚úù‚Å∑ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\ninst‚úù‚Å∂ : G.IsCoverDense J\ninst‚úù‚Åµ : G.Full\ninst‚úù‚Å¥ : G.IsContinuous K J\ninst‚úù¬≥ : (G.sheafPushforwardContinuous A K J).EssSurj\ninst‚úù¬≤ : G.IsCocontinuous K J\ninst‚úù¬π : CategoryTheory.HasForget A\ninst‚úù : K.WEqualsLocallyBijective A\nhG : CategoryTheory.CoverPreserving K J G\n‚ä¢ J.WEqualsLocallyBijective A","decl":"lemma WEqualsLocallyBijective.transport (hG : CoverPreserving K J G) :\n    J.WEqualsLocallyBijective A where\n  iff f := by\n    rw [‚Üê W_whiskerLeft_iff J K G f, ‚Üê Presheaf.isLocallyInjective_whisker_iff K J G f hG,\n      ‚Üê Presheaf.isLocallySurjective_whisker_iff K J G f hG, W_iff_isLocallyBijective]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.instWEqualsLocallyBijectiveOfSmallModelInducedTopologyInverseEquivSmallModel","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\ninst‚úù¬≥ : CategoryTheory.HasForget A\ninst‚úù¬≤ : CategoryTheory.EssentiallySmall.{w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : ‚àÄ (X : Opposite C), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.StructuredArrow X (CategoryTheory.equivSmallModel C).inverse.op) A\ninst‚úù : ((CategoryTheory.equivSmallModel C).inverse.inducedTopology J).WEqualsLocallyBijective A\n‚ä¢ J.WEqualsLocallyBijective A","decl":"instance [((equivSmallModel C).inverse.inducedTopology J).WEqualsLocallyBijective A] :\n    J.WEqualsLocallyBijective A :=\n  WEqualsLocallyBijective.transport J ((equivSmallModel C).inverse.inducedTopology J)\n    (equivSmallModel C).inverse (IsDenseSubsite.coverPreserving _ _ _)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.instPreservesSheafification_1","module":"Mathlib.CategoryTheory.Sites.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÉ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nB : Type u‚ÇÑ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nF : CategoryTheory.Functor A B\ninst‚úù¬≥ : CategoryTheory.EssentiallySmall.{w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : ‚àÄ (X : Opposite C), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.StructuredArrow X (CategoryTheory.equivSmallModel C).inverse.op) A\ninst‚úù¬π : ‚àÄ (X : Opposite C), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.StructuredArrow X (CategoryTheory.equivSmallModel C).inverse.op) B\ninst‚úù : ((CategoryTheory.equivSmallModel C).inverse.inducedTopology J).PreservesSheafification F\n‚ä¢ J.PreservesSheafification F","decl":"instance : PreservesSheafification J F :=\n  PreservesSheafification.transport (A := A) J\n    ((equivSmallModel C).inverse.inducedTopology J) (equivSmallModel C).inverse B F\n\n"}
