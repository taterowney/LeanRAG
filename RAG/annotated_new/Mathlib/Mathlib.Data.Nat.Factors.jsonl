{"name":"Nat.primeFactorsList_zero","module":"Mathlib.Data.Nat.Factors","initialProofState":"⊢ Eq (Nat.primeFactorsList 0) List.nil","decl":"@[simp]\ntheorem primeFactorsList_zero : primeFactorsList 0 = [] := by rw [primeFactorsList]\n\n"}
{"name":"Nat.primeFactorsList_one","module":"Mathlib.Data.Nat.Factors","initialProofState":"⊢ Eq (Nat.primeFactorsList 1) List.nil","decl":"@[simp]\ntheorem primeFactorsList_one : primeFactorsList 1 = [] := by rw [primeFactorsList]\n\n"}
{"name":"Nat.primeFactorsList_two","module":"Mathlib.Data.Nat.Factors","initialProofState":"⊢ Eq (Nat.primeFactorsList 2) (List.cons 2 List.nil)","decl":"@[simp]\ntheorem primeFactorsList_two : primeFactorsList 2 = [2] := by simp [primeFactorsList]\n\n"}
{"name":"Nat.prime_of_mem_primeFactorsList","module":"Mathlib.Data.Nat.Factors","initialProofState":"n p : Nat\na✝ : Membership.mem n.primeFactorsList p\n⊢ Nat.Prime p","decl":"theorem prime_of_mem_primeFactorsList {n : ℕ} : ∀ {p : ℕ}, p ∈ primeFactorsList n → Prime p := by\n  match n with\n  | 0 => simp\n  | 1 => simp\n  | k + 2 =>\n      intro p h\n      let m := minFac (k + 2)\n      have : (k + 2) / m < (k + 2) := factors_lemma\n      have h₁ : p = m ∨ p ∈ primeFactorsList ((k + 2) / m) :=\n        List.mem_cons.1 (by rwa [primeFactorsList] at h)\n      exact Or.casesOn h₁ (fun h₂ => h₂.symm ▸ minFac_prime (by simp)) prime_of_mem_primeFactorsList\n\n"}
{"name":"Nat.pos_of_mem_primeFactorsList","module":"Mathlib.Data.Nat.Factors","initialProofState":"n p : Nat\nh : Membership.mem n.primeFactorsList p\n⊢ LT.lt 0 p","decl":"theorem pos_of_mem_primeFactorsList {n p : ℕ} (h : p ∈ primeFactorsList n) : 0 < p :=\n  Prime.pos (prime_of_mem_primeFactorsList h)\n\n"}
{"name":"Nat.prod_primeFactorsList","module":"Mathlib.Data.Nat.Factors","initialProofState":"n : Nat\na✝ : Ne n 0\n⊢ Eq n.primeFactorsList.prod n","decl":"theorem prod_primeFactorsList : ∀ {n}, n ≠ 0 → List.prod (primeFactorsList n) = n\n  | 0 => by simp\n  | 1 => by simp\n  | k + 2 => fun _ =>\n    let m := minFac (k + 2)\n    have : (k + 2) / m < (k + 2) := factors_lemma\n    show (primeFactorsList (k + 2)).prod = (k + 2) by\n      have h₁ : (k + 2) / m ≠ 0 := fun h => by\n        have : (k + 2) = 0 * m := (Nat.div_eq_iff_eq_mul_left (minFac_pos _) (minFac_dvd _)).1 h\n        rw [zero_mul] at this; exact (show k + 2 ≠ 0 by simp) this\n      rw [primeFactorsList, List.prod_cons, prod_primeFactorsList h₁,\n        Nat.mul_div_cancel' (minFac_dvd _)]\n\n"}
{"name":"Nat.primeFactorsList_prime","module":"Mathlib.Data.Nat.Factors","initialProofState":"p : Nat\nhp : Nat.Prime p\n⊢ Eq p.primeFactorsList (List.cons p List.nil)","decl":"theorem primeFactorsList_prime {p : ℕ} (hp : Nat.Prime p) : p.primeFactorsList = [p] := by\n  have : p = p - 2 + 2 := Nat.eq_add_of_sub_eq hp.two_le rfl\n  rw [this, primeFactorsList]\n  simp only [Eq.symm this]\n  have : Nat.minFac p = p := (Nat.prime_def_minFac.mp hp).2\n  simp only [this, primeFactorsList, Nat.div_self (Nat.Prime.pos hp)]\n\n"}
{"name":"Nat.primeFactorsList_chain","module":"Mathlib.Data.Nat.Factors","initialProofState":"n a : Nat\na✝ : ∀ (p : Nat), Nat.Prime p → Dvd.dvd p n → LE.le a p\n⊢ List.Chain (fun x1 x2 => LE.le x1 x2) a n.primeFactorsList","decl":"theorem primeFactorsList_chain {n : ℕ} :\n    ∀ {a}, (∀ p, Prime p → p ∣ n → a ≤ p) → List.Chain (· ≤ ·) a (primeFactorsList n) := by\n  match n with\n  | 0 => simp\n  | 1 => simp\n  | k + 2 =>\n      intro a h\n      let m := minFac (k + 2)\n      have : (k + 2) / m < (k + 2) := factors_lemma\n      rw [primeFactorsList]\n      refine List.Chain.cons ((le_minFac.2 h).resolve_left (by simp)) (primeFactorsList_chain ?_)\n      exact fun p pp d => minFac_le_of_dvd pp.two_le (d.trans <| div_dvd_of_dvd <| minFac_dvd _)\n\n"}
{"name":"Nat.primeFactorsList_chain_2","module":"Mathlib.Data.Nat.Factors","initialProofState":"n : Nat\n⊢ List.Chain (fun x1 x2 => LE.le x1 x2) 2 n.primeFactorsList","decl":"theorem primeFactorsList_chain_2 (n) : List.Chain (· ≤ ·) 2 (primeFactorsList n) :=\n  primeFactorsList_chain fun _ pp _ => pp.two_le\n\n"}
{"name":"Nat.primeFactorsList_chain'","module":"Mathlib.Data.Nat.Factors","initialProofState":"n : Nat\n⊢ List.Chain' (fun x1 x2 => LE.le x1 x2) n.primeFactorsList","decl":"theorem primeFactorsList_chain' (n) : List.Chain' (· ≤ ·) (primeFactorsList n) :=\n  @List.Chain'.tail _ _ (_ :: _) (primeFactorsList_chain_2 _)\n\n"}
{"name":"Nat.primeFactorsList_sorted","module":"Mathlib.Data.Nat.Factors","initialProofState":"n : Nat\n⊢ List.Sorted (fun x1 x2 => LE.le x1 x2) n.primeFactorsList","decl":"theorem primeFactorsList_sorted (n : ℕ) : List.Sorted (· ≤ ·) (primeFactorsList n) :=\n  List.chain'_iff_pairwise.1 (primeFactorsList_chain' _)\n\n"}
{"name":"Nat.primeFactorsList_add_two","module":"Mathlib.Data.Nat.Factors","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd n 2).primeFactorsList (List.cons (HAdd.hAdd n 2).minFac (HDiv.hDiv (HAdd.hAdd n 2) (HAdd.hAdd n 2).minFac).primeFactorsList)","decl":"/-- `primeFactorsList` can be constructed inductively by extracting `minFac`, for sufficiently\nlarge `n`. -/\ntheorem primeFactorsList_add_two (n : ℕ) :\n    primeFactorsList (n + 2) = minFac (n + 2) :: primeFactorsList ((n + 2) / minFac (n + 2)) := by\n  rw [primeFactorsList]\n\n"}
{"name":"Nat.primeFactorsList_eq_nil","module":"Mathlib.Data.Nat.Factors","initialProofState":"n : Nat\n⊢ Iff (Eq n.primeFactorsList List.nil) (Or (Eq n 0) (Eq n 1))","decl":"@[simp]\ntheorem primeFactorsList_eq_nil (n : ℕ) : n.primeFactorsList = [] ↔ n = 0 ∨ n = 1 := by\n  constructor <;> intro h\n  · rcases n with (_ | _ | n)\n    · exact Or.inl rfl\n    · exact Or.inr rfl\n    · rw [primeFactorsList] at h\n      injection h\n  · rcases h with (rfl | rfl)\n    · exact primeFactorsList_zero\n    · exact primeFactorsList_one\n\n"}
{"name":"Nat.eq_of_perm_primeFactorsList","module":"Mathlib.Data.Nat.Factors","initialProofState":"a b : Nat\nha : Ne a 0\nhb : Ne b 0\nh : a.primeFactorsList.Perm b.primeFactorsList\n⊢ Eq a b","decl":"open scoped List in\ntheorem eq_of_perm_primeFactorsList {a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0)\n    (h : a.primeFactorsList ~ b.primeFactorsList) : a = b := by\n  simpa [prod_primeFactorsList ha, prod_primeFactorsList hb] using List.Perm.prod_eq h\n\n"}
{"name":"Nat.mem_primeFactorsList_iff_dvd","module":"Mathlib.Data.Nat.Factors","initialProofState":"n p : Nat\nhn : Ne n 0\nhp : Nat.Prime p\n⊢ Iff (Membership.mem n.primeFactorsList p) (Dvd.dvd p n)","decl":"theorem mem_primeFactorsList_iff_dvd {n p : ℕ} (hn : n ≠ 0) (hp : Prime p) :\n    p ∈ primeFactorsList n ↔ p ∣ n where\n  mp h := prod_primeFactorsList hn ▸ List.dvd_prod h\n  mpr h := mem_list_primes_of_dvd_prod (prime_iff.mp hp)\n    (fun _ h ↦ prime_iff.mp (prime_of_mem_primeFactorsList h)) ((prod_primeFactorsList hn).symm ▸ h)\n\n"}
{"name":"Nat.dvd_of_mem_primeFactorsList","module":"Mathlib.Data.Nat.Factors","initialProofState":"n p : Nat\nh : Membership.mem n.primeFactorsList p\n⊢ Dvd.dvd p n","decl":"theorem dvd_of_mem_primeFactorsList {n p : ℕ} (h : p ∈ n.primeFactorsList) : p ∣ n := by\n  rcases n.eq_zero_or_pos with (rfl | hn)\n  · exact dvd_zero p\n  · rwa [← mem_primeFactorsList_iff_dvd hn.ne' (prime_of_mem_primeFactorsList h)]\n\n"}
{"name":"Nat.mem_primeFactorsList","module":"Mathlib.Data.Nat.Factors","initialProofState":"n p : Nat\nhn : Ne n 0\n⊢ Iff (Membership.mem n.primeFactorsList p) (And (Nat.Prime p) (Dvd.dvd p n))","decl":"theorem mem_primeFactorsList {n p} (hn : n ≠ 0) : p ∈ primeFactorsList n ↔ Prime p ∧ p ∣ n :=\n  ⟨fun h => ⟨prime_of_mem_primeFactorsList h, dvd_of_mem_primeFactorsList h⟩, fun ⟨hprime, hdvd⟩ =>\n    (mem_primeFactorsList_iff_dvd hn hprime).mpr hdvd⟩\n\n"}
{"name":"Nat.mem_primeFactorsList'","module":"Mathlib.Data.Nat.Factors","initialProofState":"n p : Nat\n⊢ Iff (Membership.mem n.primeFactorsList p) (And (Nat.Prime p) (And (Dvd.dvd p n) (Ne n 0)))","decl":"@[simp] lemma mem_primeFactorsList' {n p} : p ∈ n.primeFactorsList ↔ p.Prime ∧ p ∣ n ∧ n ≠ 0 := by\n  cases n <;> simp [mem_primeFactorsList, *]\n\n"}
{"name":"Nat.le_of_mem_primeFactorsList","module":"Mathlib.Data.Nat.Factors","initialProofState":"n p : Nat\nh : Membership.mem n.primeFactorsList p\n⊢ LE.le p n","decl":"theorem le_of_mem_primeFactorsList {n p : ℕ} (h : p ∈ n.primeFactorsList) : p ≤ n := by\n  rcases n.eq_zero_or_pos with (rfl | hn)\n  · rw [primeFactorsList_zero] at h\n    cases h\n  · exact le_of_dvd hn (dvd_of_mem_primeFactorsList h)\n\n"}
{"name":"Nat.primeFactorsList_unique","module":"Mathlib.Data.Nat.Factors","initialProofState":"n : Nat\nl : List Nat\nh₁ : Eq l.prod n\nh₂ : ∀ (p : Nat), Membership.mem l p → Nat.Prime p\n⊢ l.Perm n.primeFactorsList","decl":"/-- **Fundamental theorem of arithmetic**-/\ntheorem primeFactorsList_unique {n : ℕ} {l : List ℕ} (h₁ : prod l = n) (h₂ : ∀ p ∈ l, Prime p) :\n    l ~ primeFactorsList n := by\n  refine perm_of_prod_eq_prod ?_ ?_ ?_\n  · rw [h₁]\n    refine (prod_primeFactorsList ?_).symm\n    rintro rfl\n    rw [prod_eq_zero_iff] at h₁\n    exact Prime.ne_zero (h₂ 0 h₁) rfl\n  · simp_rw [← prime_iff]\n    exact h₂\n  · simp_rw [← prime_iff]\n    exact fun p => prime_of_mem_primeFactorsList\n\n"}
{"name":"Nat.Prime.primeFactorsList_pow","module":"Mathlib.Data.Nat.Factors","initialProofState":"p : Nat\nhp : Nat.Prime p\nn : Nat\n⊢ Eq (HPow.hPow p n).primeFactorsList (List.replicate n p)","decl":"theorem Prime.primeFactorsList_pow {p : ℕ} (hp : p.Prime) (n : ℕ) :\n    (p ^ n).primeFactorsList = List.replicate n p := by\n  symm\n  rw [← List.replicate_perm]\n  apply Nat.primeFactorsList_unique (List.prod_replicate n p)\n  intro q hq\n  rwa [eq_of_mem_replicate hq]\n\n"}
{"name":"Nat.eq_prime_pow_of_unique_prime_dvd","module":"Mathlib.Data.Nat.Factors","initialProofState":"n p : Nat\nhpos : Ne n 0\nh : ∀ {d : Nat}, Nat.Prime d → Dvd.dvd d n → Eq d p\n⊢ Eq n (HPow.hPow p n.primeFactorsList.length)","decl":"theorem eq_prime_pow_of_unique_prime_dvd {n p : ℕ} (hpos : n ≠ 0)\n    (h : ∀ {d}, Nat.Prime d → d ∣ n → d = p) : n = p ^ n.primeFactorsList.length := by\n  set k := n.primeFactorsList.length\n  rw [← prod_primeFactorsList hpos, ← prod_replicate k p, eq_replicate_of_mem fun d hd =>\n    h (prime_of_mem_primeFactorsList hd) (dvd_of_mem_primeFactorsList hd)]\n\n"}
{"name":"Nat.perm_primeFactorsList_mul","module":"Mathlib.Data.Nat.Factors","initialProofState":"a b : Nat\nha : Ne a 0\nhb : Ne b 0\n⊢ (HMul.hMul a b).primeFactorsList.Perm (HAppend.hAppend a.primeFactorsList b.primeFactorsList)","decl":"/-- For positive `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` -/\ntheorem perm_primeFactorsList_mul {a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) :\n    (a * b).primeFactorsList ~ a.primeFactorsList ++ b.primeFactorsList := by\n  refine (primeFactorsList_unique ?_ ?_).symm\n  · rw [List.prod_append, prod_primeFactorsList ha, prod_primeFactorsList hb]\n  · intro p hp\n    rw [List.mem_append] at hp\n    cases' hp with hp' hp' <;> exact prime_of_mem_primeFactorsList hp'\n\n"}
{"name":"Nat.perm_primeFactorsList_mul_of_coprime","module":"Mathlib.Data.Nat.Factors","initialProofState":"a b : Nat\nhab : a.Coprime b\n⊢ (HMul.hMul a b).primeFactorsList.Perm (HAppend.hAppend a.primeFactorsList b.primeFactorsList)","decl":"/-- For coprime `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` -/\ntheorem perm_primeFactorsList_mul_of_coprime {a b : ℕ} (hab : Coprime a b) :\n    (a * b).primeFactorsList ~ a.primeFactorsList ++ b.primeFactorsList := by\n  rcases a.eq_zero_or_pos with (rfl | ha)\n  · simp [(coprime_zero_left _).mp hab]\n  rcases b.eq_zero_or_pos with (rfl | hb)\n  · simp [(coprime_zero_right _).mp hab]\n  exact perm_primeFactorsList_mul ha.ne' hb.ne'\n\n"}
{"name":"Nat.primeFactorsList_sublist_right","module":"Mathlib.Data.Nat.Factors","initialProofState":"n k : Nat\nh : Ne k 0\n⊢ n.primeFactorsList.Sublist (HMul.hMul n k).primeFactorsList","decl":"theorem primeFactorsList_sublist_right {n k : ℕ} (h : k ≠ 0) :\n    n.primeFactorsList <+ (n * k).primeFactorsList := by\n  cases' n with hn\n  · simp [zero_mul]\n  apply sublist_of_subperm_of_sorted _ (primeFactorsList_sorted _) (primeFactorsList_sorted _)\n  simp only [(perm_primeFactorsList_mul (Nat.succ_ne_zero _) h).subperm_left]\n  exact (sublist_append_left _ _).subperm\n\n"}
{"name":"Nat.primeFactorsList_sublist_of_dvd","module":"Mathlib.Data.Nat.Factors","initialProofState":"n k : Nat\nh : Dvd.dvd n k\nh' : Ne k 0\n⊢ n.primeFactorsList.Sublist k.primeFactorsList","decl":"theorem primeFactorsList_sublist_of_dvd {n k : ℕ} (h : n ∣ k) (h' : k ≠ 0) :\n    n.primeFactorsList <+ k.primeFactorsList := by\n  obtain ⟨a, rfl⟩ := h\n  exact primeFactorsList_sublist_right (right_ne_zero_of_mul h')\n\n"}
{"name":"Nat.primeFactorsList_subset_right","module":"Mathlib.Data.Nat.Factors","initialProofState":"n k : Nat\nh : Ne k 0\n⊢ HasSubset.Subset n.primeFactorsList (HMul.hMul n k).primeFactorsList","decl":"theorem primeFactorsList_subset_right {n k : ℕ} (h : k ≠ 0) :\n    n.primeFactorsList ⊆ (n * k).primeFactorsList :=\n  (primeFactorsList_sublist_right h).subset\n\n"}
{"name":"Nat.primeFactorsList_subset_of_dvd","module":"Mathlib.Data.Nat.Factors","initialProofState":"n k : Nat\nh : Dvd.dvd n k\nh' : Ne k 0\n⊢ HasSubset.Subset n.primeFactorsList k.primeFactorsList","decl":"theorem primeFactorsList_subset_of_dvd {n k : ℕ} (h : n ∣ k) (h' : k ≠ 0) :\n    n.primeFactorsList ⊆ k.primeFactorsList :=\n  (primeFactorsList_sublist_of_dvd h h').subset\n\n"}
{"name":"Nat.dvd_of_primeFactorsList_subperm","module":"Mathlib.Data.Nat.Factors","initialProofState":"a b : Nat\nha : Ne a 0\nh : a.primeFactorsList.Subperm b.primeFactorsList\n⊢ Dvd.dvd a b","decl":"theorem dvd_of_primeFactorsList_subperm {a b : ℕ} (ha : a ≠ 0)\n    (h : a.primeFactorsList <+~ b.primeFactorsList) : a ∣ b := by\n  rcases b.eq_zero_or_pos with (rfl | hb)\n  · exact dvd_zero _\n  rcases a with (_ | _ | a)\n  · exact (ha rfl).elim\n  · exact one_dvd _\n  -- Porting note: previous proof\n  --use (b.primeFactorsList.diff a.succ.succ.primeFactorsList).prod\n  use (@List.diff _ instBEqOfDecidableEq b.primeFactorsList a.succ.succ.primeFactorsList).prod\n  nth_rw 1 [← Nat.prod_primeFactorsList ha]\n  rw [← List.prod_append,\n    List.Perm.prod_eq <| List.subperm_append_diff_self_of_count_le <| List.subperm_ext_iff.mp h,\n    Nat.prod_primeFactorsList hb.ne']\n\n"}
{"name":"Nat.replicate_subperm_primeFactorsList_iff","module":"Mathlib.Data.Nat.Factors","initialProofState":"a b n : Nat\nha : Nat.Prime a\nhb : Ne b 0\n⊢ Iff ((List.replicate n a).Subperm b.primeFactorsList) (Dvd.dvd (HPow.hPow a n) b)","decl":"theorem replicate_subperm_primeFactorsList_iff {a b n : ℕ} (ha : Prime a) (hb : b ≠ 0) :\n    replicate n a <+~ primeFactorsList b ↔ a ^ n ∣ b := by\n  induction n generalizing b with\n  | zero => simp\n  | succ n ih =>\n    constructor\n    · rw [List.subperm_iff]\n      rintro ⟨u, hu1, hu2⟩\n      rw [← Nat.prod_primeFactorsList hb, ← hu1.prod_eq, ← prod_replicate]\n      exact hu2.prod_dvd_prod\n    · rintro ⟨c, rfl⟩\n      rw [Ne, pow_succ', mul_assoc, mul_eq_zero, _root_.not_or] at hb\n      rw [pow_succ', mul_assoc, replicate_succ,\n        (Nat.perm_primeFactorsList_mul hb.1 hb.2).subperm_left, primeFactorsList_prime ha,\n        singleton_append, subperm_cons, ih hb.2]\n      exact dvd_mul_right _ _\n\n"}
{"name":"Nat.mem_primeFactorsList_mul","module":"Mathlib.Data.Nat.Factors","initialProofState":"a b : Nat\nha : Ne a 0\nhb : Ne b 0\np : Nat\n⊢ Iff (Membership.mem (HMul.hMul a b).primeFactorsList p) (Or (Membership.mem a.primeFactorsList p) (Membership.mem b.primeFactorsList p))","decl":"theorem mem_primeFactorsList_mul {a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) {p : ℕ} :\n    p ∈ (a * b).primeFactorsList ↔ p ∈ a.primeFactorsList ∨ p ∈ b.primeFactorsList := by\n  rw [mem_primeFactorsList (mul_ne_zero ha hb), mem_primeFactorsList ha, mem_primeFactorsList hb,\n    ← and_or_left]\n  simpa only [and_congr_right_iff] using Prime.dvd_mul\n\n"}
{"name":"Nat.coprime_primeFactorsList_disjoint","module":"Mathlib.Data.Nat.Factors","initialProofState":"a b : Nat\nhab : a.Coprime b\n⊢ a.primeFactorsList.Disjoint b.primeFactorsList","decl":"/-- The sets of factors of coprime `a` and `b` are disjoint -/\ntheorem coprime_primeFactorsList_disjoint {a b : ℕ} (hab : a.Coprime b) :\n    List.Disjoint a.primeFactorsList b.primeFactorsList := by\n  intro q hqa hqb\n  apply not_prime_one\n  rw [← eq_one_of_dvd_coprimes hab (dvd_of_mem_primeFactorsList hqa)\n    (dvd_of_mem_primeFactorsList hqb)]\n  exact prime_of_mem_primeFactorsList hqa\n\n"}
{"name":"Nat.mem_primeFactorsList_mul_of_coprime","module":"Mathlib.Data.Nat.Factors","initialProofState":"a b : Nat\nhab : a.Coprime b\np : Nat\n⊢ Iff (Membership.mem (HMul.hMul a b).primeFactorsList p) (Membership.mem (Union.union a.primeFactorsList b.primeFactorsList) p)","decl":"theorem mem_primeFactorsList_mul_of_coprime {a b : ℕ} (hab : Coprime a b) (p : ℕ) :\n    p ∈ (a * b).primeFactorsList ↔ p ∈ a.primeFactorsList ∪ b.primeFactorsList := by\n  rcases a.eq_zero_or_pos with (rfl | ha)\n  · simp [(coprime_zero_left _).mp hab]\n  rcases b.eq_zero_or_pos with (rfl | hb)\n  · simp [(coprime_zero_right _).mp hab]\n  rw [mem_primeFactorsList_mul ha.ne' hb.ne', List.mem_union_iff]\n\n"}
{"name":"Nat.mem_primeFactorsList_mul_left","module":"Mathlib.Data.Nat.Factors","initialProofState":"p a b : Nat\nhpa : Membership.mem a.primeFactorsList p\nhb : Ne b 0\n⊢ Membership.mem (HMul.hMul a b).primeFactorsList p","decl":"/-- If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` -/\ntheorem mem_primeFactorsList_mul_left {p a b : ℕ} (hpa : p ∈ a.primeFactorsList) (hb : b ≠ 0) :\n    p ∈ (a * b).primeFactorsList := by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  · simp at hpa\n  apply (mem_primeFactorsList_mul ha hb).2 (Or.inl hpa)\n\n"}
{"name":"Nat.mem_primeFactorsList_mul_right","module":"Mathlib.Data.Nat.Factors","initialProofState":"p a b : Nat\nhpb : Membership.mem b.primeFactorsList p\nha : Ne a 0\n⊢ Membership.mem (HMul.hMul a b).primeFactorsList p","decl":"/-- If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` -/\ntheorem mem_primeFactorsList_mul_right {p a b : ℕ} (hpb : p ∈ b.primeFactorsList) (ha : a ≠ 0) :\n    p ∈ (a * b).primeFactorsList := by\n  rw [mul_comm]\n  exact mem_primeFactorsList_mul_left hpb ha\n\n"}
{"name":"Nat.eq_two_pow_or_exists_odd_prime_and_dvd","module":"Mathlib.Data.Nat.Factors","initialProofState":"n : Nat\n⊢ Or (Exists fun k => Eq n (HPow.hPow 2 k)) (Exists fun p => And (Nat.Prime p) (And (Dvd.dvd p n) (Odd p)))","decl":"theorem eq_two_pow_or_exists_odd_prime_and_dvd (n : ℕ) :\n    (∃ k : ℕ, n = 2 ^ k) ∨ ∃ p, Nat.Prime p ∧ p ∣ n ∧ Odd p :=\n  (eq_or_ne n 0).elim (fun hn => Or.inr ⟨3, prime_three, hn.symm ▸ dvd_zero 3, ⟨1, rfl⟩⟩) fun hn =>\n    or_iff_not_imp_right.mpr fun H =>\n      ⟨n.primeFactorsList.length,\n        eq_prime_pow_of_unique_prime_dvd hn fun {_} hprime hdvd =>\n          hprime.eq_two_or_odd'.resolve_right fun hodd => H ⟨_, hprime, hdvd, hodd⟩⟩\n\n"}
{"name":"Nat.four_dvd_or_exists_odd_prime_and_dvd_of_two_lt","module":"Mathlib.Data.Nat.Factors","initialProofState":"n : Nat\nn2 : LT.lt 2 n\n⊢ Or (Dvd.dvd 4 n) (Exists fun p => And (Nat.Prime p) (And (Dvd.dvd p n) (Odd p)))","decl":"theorem four_dvd_or_exists_odd_prime_and_dvd_of_two_lt {n : ℕ} (n2 : 2 < n) :\n    4 ∣ n ∨ ∃ p, Prime p ∧ p ∣ n ∧ Odd p := by\n  obtain ⟨_ | _ | k, rfl⟩ | ⟨p, hp, hdvd, hodd⟩ := n.eq_two_pow_or_exists_odd_prime_and_dvd\n  · contradiction\n  · contradiction\n  · simp [Nat.pow_succ, mul_assoc]\n  · exact Or.inr ⟨p, hp, hdvd, hodd⟩\n\n"}
