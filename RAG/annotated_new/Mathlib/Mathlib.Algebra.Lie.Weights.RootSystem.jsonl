{"name":"LieAlgebra.IsKilling.chainLength_of_isZero","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nhα : α.IsZero\n⊢ Eq (LieAlgebra.IsKilling.chainLength α β) 0","decl":"lemma chainLength_of_isZero (hα : α.IsZero) : chainLength α β = 0 := dif_pos hα\n\n"}
{"name":"LieAlgebra.IsKilling.chainLength_nsmul","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nx : L\nhx : Membership.mem (LieAlgebra.rootSpace H ⇑(LieModule.chainTop (⇑α) β)) x\n⊢ Eq (HSMul.hSMul (LieAlgebra.IsKilling.chainLength α β) x) (Bracket.bracket (LieAlgebra.IsKilling.coroot α) x)","decl":"lemma chainLength_nsmul {x} (hx : x ∈ rootSpace H (chainTop α β)) :\n    chainLength α β • x = ⁅coroot α, x⁆ := by\n  by_cases hα : α.IsZero\n  · rw [coroot_eq_zero_iff.mpr hα, chainLength_of_isZero _ _ hα, zero_smul, zero_lie]\n  let x' := (chainTop α β).exists_ne_zero.choose\n  have h : x' ∈ rootSpace H (chainTop α β) ∧ x' ≠ 0 :=\n    (chainTop α β).exists_ne_zero.choose_spec\n  obtain ⟨k, rfl⟩ : ∃ k : K, k • x' = x := by\n    simpa using (finrank_eq_one_iff_of_nonzero' ⟨x', h.1⟩ (by simpa using h.2)).mp\n      (finrank_rootSpace_eq_one _ (chainTop_isNonZero α β hα)) ⟨_, hx⟩\n  rw [lie_smul, smul_comm, chainLength, dif_neg hα, (chainLength_aux α β hα h.1).choose_spec]\n\n"}
{"name":"LieAlgebra.IsKilling.chainLength_smul","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nx : L\nhx : Membership.mem (LieAlgebra.rootSpace H ⇑(LieModule.chainTop (⇑α) β)) x\n⊢ Eq (HSMul.hSMul (↑(LieAlgebra.IsKilling.chainLength α β)) x) (Bracket.bracket (LieAlgebra.IsKilling.coroot α) x)","decl":"lemma chainLength_smul {x} (hx : x ∈ rootSpace H (chainTop α β)) :\n    (chainLength α β : K) • x = ⁅coroot α, x⁆ := by\n  rw [Nat.cast_smul_eq_nsmul, chainLength_nsmul _ _ hx]\n\n"}
{"name":"LieAlgebra.IsKilling.apply_coroot_eq_cast'","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\n⊢ Eq (β (LieAlgebra.IsKilling.coroot α)) ↑(HSub.hSub (↑(LieAlgebra.IsKilling.chainLength α β)) (HMul.hMul 2 ↑(LieModule.chainTopCoeff (⇑α) β)))","decl":"lemma apply_coroot_eq_cast' :\n    β (coroot α) = ↑(chainLength α β - 2 * chainTopCoeff α β : ℤ) := by\n  by_cases hα : α.IsZero\n  · rw [coroot_eq_zero_iff.mpr hα, chainLength, dif_pos hα, hα.eq, chainTopCoeff_zero, map_zero,\n      CharP.cast_eq_zero, mul_zero, sub_self, Int.cast_zero]\n  obtain ⟨x, hx, x_ne0⟩ := (chainTop α β).exists_ne_zero\n  have := chainLength_smul _ _ hx\n  rw [lie_eq_smul_of_mem_rootSpace hx, ← sub_eq_zero, ← sub_smul,\n    smul_eq_zero_iff_left x_ne0, sub_eq_zero, coe_chainTop', nsmul_eq_mul, Pi.natCast_def,\n    Pi.add_apply, Pi.mul_apply, root_apply_coroot hα] at this\n  simp only [Int.cast_sub, Int.cast_natCast, Int.cast_mul, Int.cast_ofNat, eq_sub_iff_add_eq',\n    this, mul_comm (2 : K)]\n\n"}
{"name":"LieAlgebra.IsKilling.rootSpace_neg_nsmul_add_chainTop_of_le","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nn : Nat\nhn : LE.le n (LieAlgebra.IsKilling.chainLength α β)\n⊢ Ne (LieAlgebra.rootSpace H (HAdd.hAdd (Neg.neg (HSMul.hSMul n ⇑α)) ⇑(LieModule.chainTop (⇑α) β))) Bot.bot","decl":"lemma rootSpace_neg_nsmul_add_chainTop_of_le {n : ℕ} (hn : n ≤ chainLength α β) :\n    rootSpace H (- (n • α) + chainTop α β) ≠ ⊥ := by\n  by_cases hα : α.IsZero\n  · simpa only [hα.eq, smul_zero, neg_zero, chainTop_zero, zero_add, ne_eq] using β.2\n  obtain ⟨x, hx, x_ne0⟩ := (chainTop α β).exists_ne_zero\n  obtain ⟨h, e, f, isSl2, he, hf⟩ := exists_isSl2Triple_of_weight_isNonZero hα\n  obtain rfl := isSl2.h_eq_coroot hα he hf\n  have prim : isSl2.HasPrimitiveVectorWith x (chainLength α β : K) :=\n    have := lie_mem_genWeightSpace_of_mem_genWeightSpace he hx\n    ⟨x_ne0, (chainLength_smul _ _ hx).symm, by rwa [genWeightSpace_add_chainTop _ _ hα] at this⟩\n  simp only [← smul_neg, ne_eq, LieSubmodule.eq_bot_iff, not_forall]\n  exact ⟨_, toEnd_pow_apply_mem hf hx n, prim.pow_toEnd_f_ne_zero_of_eq_nat rfl hn⟩\n\n"}
{"name":"LieAlgebra.IsKilling.rootSpace_neg_nsmul_add_chainTop_of_lt","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nhα : α.IsNonZero\nn : Nat\nhn : LT.lt (LieAlgebra.IsKilling.chainLength α β) n\n⊢ Eq (LieAlgebra.rootSpace H (HAdd.hAdd (Neg.neg (HSMul.hSMul n ⇑α)) ⇑(LieModule.chainTop (⇑α) β))) Bot.bot","decl":"lemma rootSpace_neg_nsmul_add_chainTop_of_lt (hα : α.IsNonZero) {n : ℕ} (hn : chainLength α β < n) :\n    rootSpace H (- (n • α) + chainTop α β) = ⊥ := by\n  by_contra e\n  let W : Weight K H L := ⟨_, e⟩\n  have hW : (W : H → K) = - (n • α) + chainTop α β := rfl\n  have H₁ : 1 + n + chainTopCoeff (-α) W ≤ chainLength (-α) W := by\n    have := apply_coroot_eq_cast' (-α) W\n    simp only [coroot_neg, map_neg, hW, nsmul_eq_mul, Pi.natCast_def, coe_chainTop, zsmul_eq_mul,\n      Int.cast_natCast, Pi.add_apply, Pi.neg_apply, Pi.mul_apply, root_apply_coroot hα, mul_two,\n      neg_add_rev, apply_coroot_eq_cast' α β, Int.cast_sub, Int.cast_mul, Int.cast_ofNat,\n      mul_comm (2 : K), add_sub_cancel, neg_neg, add_sub, Nat.cast_inj,\n      eq_sub_iff_add_eq, ← Nat.cast_add, ← sub_eq_neg_add, sub_eq_iff_eq_add] at this\n    omega\n  have H₂ : ((1 + n + chainTopCoeff (-α) W) • α + chainTop (-α) W : H → K) =\n      (chainTopCoeff α β + 1) • α + β := by\n    simp only [Weight.coe_neg, ← Nat.cast_smul_eq_nsmul ℤ, Nat.cast_add, Nat.cast_one, coe_chainTop,\n      smul_neg, ← neg_smul, hW, ← add_assoc, ← add_smul, ← sub_eq_add_neg]\n    congr 2\n    ring\n  have := rootSpace_neg_nsmul_add_chainTop_of_le (-α) W H₁\n  rw [Weight.coe_neg, ← smul_neg, neg_neg, ← Weight.coe_neg, H₂] at this\n  exact this (genWeightSpace_chainTopCoeff_add_one_nsmul_add α β hα)\n\n"}
{"name":"LieAlgebra.IsKilling.chainTopCoeff_le_chainLength","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\n⊢ LE.le (LieModule.chainTopCoeff (⇑α) β) (LieAlgebra.IsKilling.chainLength α β)","decl":"lemma chainTopCoeff_le_chainLength : chainTopCoeff α β ≤ chainLength α β := by\n  by_cases hα : α.IsZero\n  · simp only [hα.eq, chainTopCoeff_zero, zero_le]\n  rw [← not_lt, ← Nat.succ_le]\n  intro e\n  apply genWeightSpace_nsmul_add_ne_bot_of_le α β\n    (Nat.sub_le (chainTopCoeff α β) (chainLength α β).succ)\n  rw [← Nat.cast_smul_eq_nsmul ℤ, Nat.cast_sub e, sub_smul, sub_eq_neg_add,\n    add_assoc, ← coe_chainTop, Nat.cast_smul_eq_nsmul]\n  exact rootSpace_neg_nsmul_add_chainTop_of_lt α β hα (Nat.lt_succ_self _)\n\n"}
{"name":"LieAlgebra.IsKilling.chainBotCoeff_add_chainTopCoeff","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\n⊢ Eq (HAdd.hAdd (LieModule.chainBotCoeff (⇑α) β) (LieModule.chainTopCoeff (⇑α) β)) (LieAlgebra.IsKilling.chainLength α β)","decl":"lemma chainBotCoeff_add_chainTopCoeff :\n    chainBotCoeff α β + chainTopCoeff α β = chainLength α β := by\n  by_cases hα : α.IsZero\n  · rw [hα.eq, chainTopCoeff_zero, chainBotCoeff_zero, zero_add, chainLength_of_isZero α β hα]\n  apply le_antisymm\n  · rw [← Nat.le_sub_iff_add_le (chainTopCoeff_le_chainLength α β),\n      ← not_lt, ← Nat.succ_le, chainBotCoeff, ← Weight.coe_neg]\n    intro e\n    apply genWeightSpace_nsmul_add_ne_bot_of_le _ _ e\n    rw [← Nat.cast_smul_eq_nsmul ℤ, Nat.cast_succ, Nat.cast_sub (chainTopCoeff_le_chainLength α β),\n      LieModule.Weight.coe_neg, smul_neg, ← neg_smul, neg_add_rev, neg_sub, sub_eq_neg_add,\n      ← add_assoc, ← neg_add_rev, add_smul, add_assoc, ← coe_chainTop, neg_smul,\n      ← @Nat.cast_one ℤ, ← Nat.cast_add, Nat.cast_smul_eq_nsmul]\n    exact rootSpace_neg_nsmul_add_chainTop_of_lt α β hα (Nat.lt_succ_self _)\n  · rw [← not_lt]\n    intro e\n    apply rootSpace_neg_nsmul_add_chainTop_of_le α β e\n    rw [← Nat.succ_add, ← Nat.cast_smul_eq_nsmul ℤ, ← neg_smul, coe_chainTop, ← add_assoc,\n      ← add_smul, Nat.cast_add, neg_add, add_assoc, neg_add_cancel, add_zero, neg_smul, ← smul_neg,\n      Nat.cast_smul_eq_nsmul]\n    exact genWeightSpace_chainTopCoeff_add_one_nsmul_add (-α) β (Weight.IsNonZero.neg hα)\n\n"}
{"name":"LieAlgebra.IsKilling.chainTopCoeff_add_chainBotCoeff","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\n⊢ Eq (HAdd.hAdd (LieModule.chainTopCoeff (⇑α) β) (LieModule.chainBotCoeff (⇑α) β)) (LieAlgebra.IsKilling.chainLength α β)","decl":"lemma chainTopCoeff_add_chainBotCoeff :\n    chainTopCoeff α β + chainBotCoeff α β = chainLength α β := by\n  rw [add_comm, chainBotCoeff_add_chainTopCoeff]\n\n"}
{"name":"LieAlgebra.IsKilling.chainBotCoeff_le_chainLength","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\n⊢ LE.le (LieModule.chainBotCoeff (⇑α) β) (LieAlgebra.IsKilling.chainLength α β)","decl":"lemma chainBotCoeff_le_chainLength : chainBotCoeff α β ≤ chainLength α β :=\n  (Nat.le_add_left _ _).trans_eq (chainTopCoeff_add_chainBotCoeff α β)\n\n"}
{"name":"LieAlgebra.IsKilling.chainLength_neg","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\n⊢ Eq (LieAlgebra.IsKilling.chainLength (Neg.neg α) β) (LieAlgebra.IsKilling.chainLength α β)","decl":"@[simp]\nlemma chainLength_neg :\n    chainLength (-α) β = chainLength α β := by\n  rw [← chainBotCoeff_add_chainTopCoeff, ← chainBotCoeff_add_chainTopCoeff, add_comm,\n    Weight.coe_neg, chainTopCoeff_neg, chainBotCoeff_neg]\n\n"}
{"name":"LieAlgebra.IsKilling.chainLength_zero","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁸ : Field K\ninst✝⁷ : CharZero K\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : LieAlgebra.IsKilling K L\ninst✝³ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝² : H.IsCartanSubalgebra\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nβ : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\ninst✝ : Nontrivial L\n⊢ Eq (LieAlgebra.IsKilling.chainLength 0 β) 0","decl":"@[simp]\nlemma chainLength_zero [Nontrivial L] : chainLength 0 β = 0 := by\n  simp [← chainBotCoeff_add_chainTopCoeff]\n\n"}
{"name":"LieAlgebra.IsKilling.apply_coroot_eq_cast","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\n⊢ Eq (β (LieAlgebra.IsKilling.coroot α)) ↑(HSub.hSub ↑(LieModule.chainBotCoeff (⇑α) β) ↑(LieModule.chainTopCoeff (⇑α) β))","decl":"/-- If `β - qα ... β ... β + rα` is the `α`-chain through `β`, then\n  `β (coroot α) = q - r`. In particular, it is an integer. -/\nlemma apply_coroot_eq_cast :\n    β (coroot α) = (chainBotCoeff α β - chainTopCoeff α β : ℤ) := by\n  rw [apply_coroot_eq_cast', ← chainTopCoeff_add_chainBotCoeff]; congr 1; omega\n\n"}
{"name":"LieAlgebra.IsKilling.le_chainBotCoeff_of_rootSpace_ne_top","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nhα : α.IsNonZero\nn : Int\nhn : Ne (LieAlgebra.rootSpace H (HAdd.hAdd (HSMul.hSMul (Neg.neg n) ⇑α) ⇑β)) Bot.bot\n⊢ LE.le n ↑(LieModule.chainBotCoeff (⇑α) β)","decl":"lemma le_chainBotCoeff_of_rootSpace_ne_top\n    (hα : α.IsNonZero) (n : ℤ) (hn : rootSpace H (-n • α + β) ≠ ⊥) :\n    n ≤ chainBotCoeff α β := by\n  contrapose! hn\n  lift n to ℕ using (Nat.cast_nonneg _).trans hn.le\n  rw [Nat.cast_lt, ← @Nat.add_lt_add_iff_right (chainTopCoeff α β),\n    chainBotCoeff_add_chainTopCoeff] at hn\n  have := rootSpace_neg_nsmul_add_chainTop_of_lt α β hα hn\n  rwa [← Nat.cast_smul_eq_nsmul ℤ, ← neg_smul, coe_chainTop, ← add_assoc,\n    ← add_smul, Nat.cast_add, neg_add, add_assoc, neg_add_cancel, add_zero] at this\n\n"}
{"name":"LieAlgebra.IsKilling.rootSpace_zsmul_add_ne_bot_iff","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nhα : α.IsNonZero\nn : Int\n⊢ Iff (Ne (LieAlgebra.rootSpace H (HAdd.hAdd (HSMul.hSMul n ⇑α) ⇑β)) Bot.bot) (And (LE.le n ↑(LieModule.chainTopCoeff (⇑α) β)) (LE.le (Neg.neg n) ↑(LieModule.chainBotCoeff (⇑α) β)))","decl":"/-- Members of the `α`-chain through `β` are the only roots of the form `β - kα`. -/\nlemma rootSpace_zsmul_add_ne_bot_iff (hα : α.IsNonZero) (n : ℤ) :\n    rootSpace H (n • α + β) ≠ ⊥ ↔ n ≤ chainTopCoeff α β ∧ -n ≤ chainBotCoeff α β := by\n  constructor\n  · refine (fun hn ↦ ⟨?_, le_chainBotCoeff_of_rootSpace_ne_top α β hα _ (by rwa [neg_neg])⟩)\n    rw [← chainBotCoeff_neg, ← Weight.coe_neg]\n    apply le_chainBotCoeff_of_rootSpace_ne_top _ _ hα.neg\n    rwa [neg_smul, Weight.coe_neg, smul_neg, neg_neg]\n  · rintro ⟨h₁, h₂⟩\n    set k := chainTopCoeff α β - n with hk; clear_value k\n    lift k to ℕ using (by rw [hk, le_sub_iff_add_le, zero_add]; exact h₁)\n    rw [eq_sub_iff_add_eq, ← eq_sub_iff_add_eq'] at hk\n    subst hk\n    simp only [neg_sub, tsub_le_iff_right, ← Nat.cast_add, Nat.cast_le,\n      chainBotCoeff_add_chainTopCoeff] at h₂\n    have := rootSpace_neg_nsmul_add_chainTop_of_le α β h₂\n    rwa [coe_chainTop, ← Nat.cast_smul_eq_nsmul ℤ, ← neg_smul,\n      ← add_assoc, ← add_smul, ← sub_eq_neg_add] at this\n\n"}
{"name":"LieAlgebra.IsKilling.rootSpace_zsmul_add_ne_bot_iff_mem","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nhα : α.IsNonZero\nn : Int\n⊢ Iff (Ne (LieAlgebra.rootSpace H (HAdd.hAdd (HSMul.hSMul n ⇑α) ⇑β)) Bot.bot) (Membership.mem (Finset.Icc (Neg.neg ↑(LieModule.chainBotCoeff (⇑α) β)) ↑(LieModule.chainTopCoeff (⇑α) β)) n)","decl":"lemma rootSpace_zsmul_add_ne_bot_iff_mem (hα : α.IsNonZero) (n : ℤ) :\n    rootSpace H (n • α + β) ≠ ⊥ ↔ n ∈ Finset.Icc (-chainBotCoeff α β : ℤ) (chainTopCoeff α β) := by\n  rw [rootSpace_zsmul_add_ne_bot_iff α β hα n, Finset.mem_Icc, and_comm, neg_le]\n\n"}
{"name":"LieAlgebra.IsKilling.chainTopCoeff_of_eq_zsmul_add","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nhα : α.IsNonZero\nβ' : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nn : Int\nhβ' : Eq (⇑β') (HAdd.hAdd (HSMul.hSMul n ⇑α) ⇑β)\n⊢ Eq (↑(LieModule.chainTopCoeff (⇑α) β')) (HSub.hSub (↑(LieModule.chainTopCoeff (⇑α) β)) n)","decl":"lemma chainTopCoeff_of_eq_zsmul_add\n    (hα : α.IsNonZero) (β' : Weight K H L) (n : ℤ) (hβ' : (β' : H → K) = n • α + β) :\n    chainTopCoeff α β' = chainTopCoeff α β - n := by\n  apply le_antisymm\n  · refine le_sub_iff_add_le.mpr ((rootSpace_zsmul_add_ne_bot_iff α β hα _).mp ?_).1\n    rw [add_smul, add_assoc, ← hβ', ← coe_chainTop]\n    exact (chainTop α β').2\n  · refine ((rootSpace_zsmul_add_ne_bot_iff α β' hα _).mp ?_).1\n    rw [hβ', ← add_assoc, ← add_smul, sub_add_cancel, ← coe_chainTop]\n    exact (chainTop α β).2\n\n"}
{"name":"LieAlgebra.IsKilling.chainBotCoeff_of_eq_zsmul_add","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nhα : α.IsNonZero\nβ' : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nn : Int\nhβ' : Eq (⇑β') (HAdd.hAdd (HSMul.hSMul n ⇑α) ⇑β)\n⊢ Eq (↑(LieModule.chainBotCoeff (⇑α) β')) (HAdd.hAdd (↑(LieModule.chainBotCoeff (⇑α) β)) n)","decl":"lemma chainBotCoeff_of_eq_zsmul_add\n    (hα : α.IsNonZero) (β' : Weight K H L) (n : ℤ) (hβ' : (β' : H → K) = n • α + β) :\n    chainBotCoeff α β' = chainBotCoeff α β + n := by\n  have : (β' : H → K) = -n • (-α) + β := by rwa [neg_smul, smul_neg, neg_neg]\n  rw [chainBotCoeff, chainBotCoeff, ← Weight.coe_neg,\n    chainTopCoeff_of_eq_zsmul_add (-α) β hα.neg β' (-n) this, sub_neg_eq_add]\n\n"}
{"name":"LieAlgebra.IsKilling.chainLength_of_eq_zsmul_add","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β β' : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nn : Int\nhβ' : Eq (⇑β') (HAdd.hAdd (HSMul.hSMul n ⇑α) ⇑β)\n⊢ Eq (LieAlgebra.IsKilling.chainLength α β') (LieAlgebra.IsKilling.chainLength α β)","decl":"lemma chainLength_of_eq_zsmul_add (β' : Weight K H L) (n : ℤ) (hβ' : (β' : H → K) = n • α + β) :\n    chainLength α β' = chainLength α β := by\n  by_cases hα : α.IsZero\n  · rw [chainLength_of_isZero _ _ hα, chainLength_of_isZero _ _ hα]\n  · apply Nat.cast_injective (R := ℤ)\n    rw [← chainTopCoeff_add_chainBotCoeff, ← chainTopCoeff_add_chainBotCoeff,\n      Nat.cast_add, Nat.cast_add, chainTopCoeff_of_eq_zsmul_add α β hα β' n hβ',\n      chainBotCoeff_of_eq_zsmul_add α β hα β' n hβ', sub_eq_add_neg, add_add_add_comm,\n      neg_add_cancel, add_zero]\n\n"}
{"name":"LieAlgebra.IsKilling.chainTopCoeff_zero_right","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁸ : Field K\ninst✝⁷ : CharZero K\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : LieAlgebra.IsKilling K L\ninst✝³ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝² : H.IsCartanSubalgebra\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\ninst✝ : Nontrivial L\nhα : α.IsNonZero\n⊢ Eq (LieModule.chainTopCoeff (⇑α) 0) 1","decl":"lemma chainTopCoeff_zero_right [Nontrivial L] (hα : α.IsNonZero) :\n    chainTopCoeff α (0 : Weight K H L) = 1 := by\n  symm\n  apply eq_of_le_of_not_lt\n  · rw [Nat.one_le_iff_ne_zero]\n    intro e\n    exact α.2 (by simpa [e, Weight.coe_zero] using\n      genWeightSpace_chainTopCoeff_add_one_nsmul_add α (0 : Weight K H L) hα)\n  obtain ⟨x, hx, x_ne0⟩ := (chainTop α (0 : Weight K H L)).exists_ne_zero\n  obtain ⟨h, e, f, isSl2, he, hf⟩ := exists_isSl2Triple_of_weight_isNonZero hα\n  obtain rfl := isSl2.h_eq_coroot hα he hf\n  have prim : isSl2.HasPrimitiveVectorWith x (chainLength α (0 : Weight K H L) : K) :=\n    have := lie_mem_genWeightSpace_of_mem_genWeightSpace he hx\n    ⟨x_ne0, (chainLength_smul _ _ hx).symm, by rwa [genWeightSpace_add_chainTop _ _ hα] at this⟩\n  obtain ⟨k, hk⟩ : ∃ k : K, k • f =\n      (toEnd K L L f ^ (chainTopCoeff α (0 : Weight K H L) + 1)) x := by\n    have : (toEnd K L L f ^ (chainTopCoeff α (0 : Weight K H L) + 1)) x ∈ rootSpace H (-α) := by\n      convert toEnd_pow_apply_mem hf hx (chainTopCoeff α (0 : Weight K H L) + 1) using 2\n      rw [coe_chainTop', Weight.coe_zero, add_zero, succ_nsmul',\n        add_assoc, smul_neg, neg_add_cancel, add_zero]\n    simpa using (finrank_eq_one_iff_of_nonzero' ⟨f, hf⟩ (by simpa using isSl2.f_ne_zero)).mp\n      (finrank_rootSpace_eq_one _ hα.neg) ⟨_, this⟩\n  apply_fun (⁅f, ·⁆) at hk\n  simp only [lie_smul, lie_self, smul_zero, prim.lie_f_pow_toEnd_f] at hk\n  intro e\n  refine prim.pow_toEnd_f_ne_zero_of_eq_nat rfl ?_ hk.symm\n  have := (apply_coroot_eq_cast' α 0).symm\n  simp only [← @Nat.cast_two ℤ, ← Nat.cast_mul, Weight.zero_apply, Int.cast_eq_zero, sub_eq_zero,\n    Nat.cast_inj] at this\n  rwa [this, Nat.succ_le, two_mul, add_lt_add_iff_left]\n\n"}
{"name":"LieAlgebra.IsKilling.chainBotCoeff_zero_right","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁸ : Field K\ninst✝⁷ : CharZero K\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : LieAlgebra.IsKilling K L\ninst✝³ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝² : H.IsCartanSubalgebra\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\ninst✝ : Nontrivial L\nhα : α.IsNonZero\n⊢ Eq (LieModule.chainBotCoeff (⇑α) 0) 1","decl":"lemma chainBotCoeff_zero_right [Nontrivial L] (hα : α.IsNonZero) :\n    chainBotCoeff α (0 : Weight K H L) = 1 :=\n  chainTopCoeff_zero_right (-α) hα.neg\n\n"}
{"name":"LieAlgebra.IsKilling.chainLength_zero_right","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁸ : Field K\ninst✝⁷ : CharZero K\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : LieAlgebra.IsKilling K L\ninst✝³ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝² : H.IsCartanSubalgebra\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\ninst✝ : Nontrivial L\nhα : α.IsNonZero\n⊢ Eq (LieAlgebra.IsKilling.chainLength α 0) 2","decl":"lemma chainLength_zero_right [Nontrivial L] (hα : α.IsNonZero) : chainLength α 0 = 2 := by\n  rw [← chainBotCoeff_add_chainTopCoeff, chainTopCoeff_zero_right α hα,\n    chainBotCoeff_zero_right α hα]\n\n"}
{"name":"LieAlgebra.IsKilling.rootSpace_two_smul","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nhα : α.IsNonZero\n⊢ Eq (LieAlgebra.rootSpace H (HSMul.hSMul 2 ⇑α)) Bot.bot","decl":"lemma rootSpace_two_smul (hα : α.IsNonZero) : rootSpace H (2 • α) = ⊥ := by\n  cases subsingleton_or_nontrivial L\n  · exact IsEmpty.elim inferInstance α\n  simpa [chainTopCoeff_zero_right α hα] using\n    genWeightSpace_chainTopCoeff_add_one_nsmul_add α (0 : Weight K H L) hα\n\n"}
{"name":"LieAlgebra.IsKilling.rootSpace_one_div_two_smul","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nhα : α.IsNonZero\n⊢ Eq (LieAlgebra.rootSpace H (HSMul.hSMul (Inv.inv 2) ⇑α)) Bot.bot","decl":"lemma rootSpace_one_div_two_smul (hα : α.IsNonZero) : rootSpace H ((2⁻¹ : K) • α) = ⊥ := by\n  by_contra h\n  let W : Weight K H L := ⟨_, h⟩\n  have hW : 2 • (W : H → K) = α := by\n    show 2 • (2⁻¹ : K) • (α : H → K) = α\n    rw [← Nat.cast_smul_eq_nsmul K, smul_smul]; simp\n  apply α.genWeightSpace_ne_bot\n  have := rootSpace_two_smul W (fun (e : (W : H → K) = 0) ↦ hα <| by\n    apply_fun (2 • ·) at e; simpa [hW] using e)\n  rwa [hW] at this\n\n"}
{"name":"LieAlgebra.IsKilling.eq_neg_one_or_eq_zero_or_eq_one_of_eq_smul","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nhα : α.IsNonZero\nk : K\nh : Eq (⇑β) (HSMul.hSMul k ⇑α)\n⊢ Or (Eq k (-1)) (Or (Eq k 0) (Eq k 1))","decl":"lemma eq_neg_one_or_eq_zero_or_eq_one_of_eq_smul\n    (hα : α.IsNonZero) (k : K) (h : (β : H → K) = k • α) :\n    k = -1 ∨ k = 0 ∨ k = 1 := by\n  cases subsingleton_or_nontrivial L\n  · exact IsEmpty.elim inferInstance α\n  have H := apply_coroot_eq_cast' α β\n  rw [h] at H\n  simp only [Pi.smul_apply, root_apply_coroot hα] at H\n  rcases (chainLength α β).even_or_odd with (⟨n, hn⟩|⟨n, hn⟩)\n  · rw [hn, ← two_mul] at H\n    simp only [smul_eq_mul, Nat.cast_mul, Nat.cast_ofNat, ← mul_sub, ← mul_comm (2 : K),\n      Int.cast_sub, Int.cast_mul, Int.cast_ofNat, Int.cast_natCast,\n      mul_eq_mul_left_iff, OfNat.ofNat_ne_zero, or_false] at H\n    rw [← Int.cast_natCast, ← Int.cast_natCast (chainTopCoeff α β), ← Int.cast_sub] at H\n    have := (rootSpace_zsmul_add_ne_bot_iff_mem α 0 hα (n - chainTopCoeff α β)).mp\n      (by rw [← Int.cast_smul_eq_zsmul K, ← H, ← h, Weight.coe_zero, add_zero]; exact β.2)\n    rw [chainTopCoeff_zero_right α hα, chainBotCoeff_zero_right α hα, Nat.cast_one] at this\n    set k' : ℤ := n - chainTopCoeff α β\n    subst H\n    have : k' ∈ ({-1, 0, 1} : Finset ℤ) := by\n      show k' ∈ Finset.Icc (-1 : ℤ) (1 : ℤ)\n      exact this\n    simpa only [Int.reduceNeg, Finset.mem_insert, Finset.mem_singleton, ← @Int.cast_inj K,\n      Int.cast_zero, Int.cast_neg, Int.cast_one] using this\n  · apply_fun (· / 2) at H\n    rw [hn, smul_eq_mul] at H\n    have hk : k = n + 2⁻¹ - chainTopCoeff α β := by simpa [sub_div, add_div] using H\n    have := (rootSpace_zsmul_add_ne_bot_iff α β hα (chainTopCoeff α β - n)).mpr ?_\n    swap\n    · simp only [tsub_le_iff_right, le_add_iff_nonneg_right, Nat.cast_nonneg, neg_sub, true_and]\n      rw [← Nat.cast_add, chainBotCoeff_add_chainTopCoeff, hn]\n      omega\n    rw [h, hk, ← Int.cast_smul_eq_zsmul K, ← add_smul] at this\n    simp only [Int.cast_sub, Int.cast_natCast,\n      sub_add_sub_cancel', add_sub_cancel_left, ne_eq] at this\n    cases this (rootSpace_one_div_two_smul α hα)\n\n"}
{"name":"LieAlgebra.IsKilling.eq_neg_or_eq_of_eq_smul","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nhβ : β.IsNonZero\nk : K\nh : Eq (⇑β) (HSMul.hSMul k ⇑α)\n⊢ Or (Eq β (Neg.neg α)) (Eq β α)","decl":"/-- `±α` are the only `K`-multiples of a root `α` that are also (non-zero) roots. -/\nlemma eq_neg_or_eq_of_eq_smul (hβ : β.IsNonZero) (k : K) (h : (β : H → K) = k • α) :\n    β = -α ∨ β = α := by\n  by_cases hα : α.IsZero\n  · rw [hα, smul_zero] at h; cases hβ h\n  rcases eq_neg_one_or_eq_zero_or_eq_one_of_eq_smul α β hα k h with (rfl | rfl | rfl)\n  · exact .inl (by ext; rw [h, neg_one_smul]; rfl)\n  · cases hβ (by rwa [zero_smul] at h)\n  · exact .inr (by ext; rw [h, one_smul])\n\n"}
{"name":"LieAlgebra.IsKilling.reflectRoot_isNonZero","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nhβ : β.IsNonZero\n⊢ (LieAlgebra.IsKilling.reflectRoot α β).IsNonZero","decl":"lemma reflectRoot_isNonZero (α β : Weight K H L) (hβ : β.IsNonZero) :\n    (reflectRoot α β).IsNonZero := by\n  intro e\n  have : β (coroot α) = 0 := by\n    by_cases hα : α.IsZero\n    · simp [coroot_eq_zero_iff.mpr hα]\n    apply add_left_injective (β (coroot α))\n    simpa [root_apply_coroot hα, mul_two] using congr_fun (sub_eq_zero.mp e) (coroot α)\n  have : reflectRoot α β = β := by ext; simp [reflectRoot, this]\n  exact hβ (this ▸ e)\n\n"}
{"name":"LieAlgebra.IsKilling.corootForm_rootSystem_eq_killing","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\n⊢ Eq (LieAlgebra.IsKilling.rootSystem H).CorootForm ((killingForm K L).restrict H.toSubmodule)","decl":"@[simp]\nlemma corootForm_rootSystem_eq_killing :\n    (rootSystem H).CorootForm = (killingForm K L).restrict H := by\n  rw [restrict_killingForm_eq_sum, RootPairing.CorootForm, ← Finset.sum_coe_sort (s := H.root)]\n  rfl\n\n"}
{"name":"LieAlgebra.IsKilling.rootSystem_toPerfectPairing_apply","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nf : Module.Dual K (Subtype fun x => Membership.mem H x)\nx : Subtype fun x => Membership.mem H x\n⊢ Eq (((LieAlgebra.IsKilling.rootSystem H).toPerfectPairing f) x) (f x)","decl":"@[simp] lemma rootSystem_toPerfectPairing_apply (f x) : (rootSystem H).toPerfectPairing f x = f x :=\n  rfl\n"}
{"name":"LieAlgebra.IsKilling.rootSystem_toLin_apply","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nf : Module.Dual K (Subtype fun x => Membership.mem H x)\nx : Subtype fun x => Membership.mem H x\n⊢ Eq (((LieAlgebra.IsKilling.rootSystem H).toPerfectPairing f) x) (f x)","decl":"@[deprecated (since := \"2024-09-09\")]\nalias rootSystem_toLin_apply := rootSystem_toPerfectPairing_apply\n"}
{"name":"LieAlgebra.IsKilling.rootSystem_pairing_apply","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : Subtype fun x => Membership.mem LieSubalgebra.root x\n⊢ Eq ((LieAlgebra.IsKilling.rootSystem H).pairing β α) (↑β (LieAlgebra.IsKilling.coroot ↑α))","decl":"@[simp] lemma rootSystem_pairing_apply (α β) : (rootSystem H).pairing β α = β.1 (coroot α.1) := rfl\n"}
{"name":"LieAlgebra.IsKilling.rootSystem_root_apply","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα : Subtype fun x => Membership.mem LieSubalgebra.root x\n⊢ Eq ((LieAlgebra.IsKilling.rootSystem H).root α) (LieModule.Weight.toLinear K (Subtype fun x => Membership.mem H x) L ↑α)","decl":"@[simp] lemma rootSystem_root_apply (α) : (rootSystem H).root α = α := rfl\n"}
{"name":"LieAlgebra.IsKilling.rootSystem_coroot_apply","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα : Subtype fun x => Membership.mem LieSubalgebra.root x\n⊢ Eq ((LieAlgebra.IsKilling.rootSystem H).coroot α) (LieAlgebra.IsKilling.coroot ↑α)","decl":"@[simp] lemma rootSystem_coroot_apply (α) : (rootSystem H).coroot α = coroot α := rfl\n\n"}
{"name":"LieAlgebra.IsKilling.instIsCrystallographicSubtypeWeightMemLieSubalgebraFinsetRootDualRootSystem","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁶ : Field K\ninst✝⁵ : CharZero K\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra K L\ninst✝² : LieAlgebra.IsKilling K L\ninst✝¹ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝ : H.IsCartanSubalgebra\n⊢ (LieAlgebra.IsKilling.rootSystem H).IsCrystallographic","decl":"instance : (rootSystem H).IsCrystallographic where\n  exists_value α β :=\n    ⟨chainBotCoeff β.1 α.1 - chainTopCoeff β.1 α.1, by simp [apply_coroot_eq_cast β.1 α.1]⟩\n\n"}
{"name":"LieAlgebra.IsKilling.isReduced_rootSystem","module":"Mathlib.Algebra.Lie.Weights.RootSystem","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁷ : Field K\ninst✝⁶ : CharZero K\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra K L\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\n⊢ (LieAlgebra.IsKilling.rootSystem H).IsReduced","decl":"theorem isReduced_rootSystem : (rootSystem H).IsReduced := by\n  intro ⟨α, hα⟩ ⟨β, hβ⟩ e\n  rw [LinearIndependent.pair_iff' ((rootSystem H).ne_zero _), not_forall] at e\n  simp only [Nat.succ_eq_add_one, Nat.reduceAdd, rootSystem_root_apply, ne_eq, not_not] at e\n  obtain ⟨u, hu⟩ := e\n  obtain (h | h) :=\n    eq_neg_or_eq_of_eq_smul α β (by simpa using hβ) u (by ext x; exact DFunLike.congr_fun hu.symm x)\n  · right; ext x; simpa [neg_eq_iff_eq_neg] using DFunLike.congr_fun h.symm x\n  · left; ext x; simpa using DFunLike.congr_fun h.symm x\n\n"}
