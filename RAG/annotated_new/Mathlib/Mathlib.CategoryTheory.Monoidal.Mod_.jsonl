{"name":"Mod_.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nX‚úù : C\nact‚úù : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X X‚úù) X‚úù\none_act‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one X‚úù) act‚úù) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X‚úù).hom) _auto‚úù\nassoc‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul X‚úù) act‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X X‚úù).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X act‚úù) act‚úù))) _auto‚úù\nX : C\nact : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X X) X\none_act : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one X) act) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) _auto‚úù\nassoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul X) act) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X act) act))) _auto‚úù\n‚ä¢ Eq (Eq { X := X‚úù, act := act‚úù, one_act := one_act‚úù, assoc := assoc‚úù } { X := X, act := act, one_act := one_act, assoc := assoc }) (And (Eq X‚úù X) (HEq act‚úù act))","decl":"/-- A module object for a monoid object, all internal to some monoidal category. -/\nstructure Mod_ (A : Mon_ C) where\n  X : C\n  act : A.X ‚äó X ‚ü∂ X\n  one_act : (A.one ‚ñ∑ X) ‚â´ act = (Œª_ X).hom := by aesop_cat\n  assoc : (A.mul ‚ñ∑ X) ‚â´ act = (Œ±_ A.X A.X X).hom ‚â´ (A.X ‚óÅ act) ‚â´ act := by aesop_cat\n\n"}
{"name":"Mod_.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nA : Mon_ C\ninst‚úù : SizeOf C\nX : C\nact : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X X) X\none_act : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one X) act) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) _auto‚úù\nassoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul X) act) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X act) act))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { X := X, act := act, one_act := one_act, assoc := assoc }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf X)) (SizeOf.sizeOf act)) (SizeOf.sizeOf one_act)) (SizeOf.sizeOf assoc))","decl":"/-- A module object for a monoid object, all internal to some monoidal category. -/\nstructure Mod_ (A : Mon_ C) where\n  X : C\n  act : A.X ‚äó X ‚ü∂ X\n  one_act : (A.one ‚ñ∑ X) ‚â´ act = (Œª_ X).hom := by aesop_cat\n  assoc : (A.mul ‚ñ∑ X) ‚â´ act = (Œ±_ A.X A.X X).hom ‚â´ (A.X ‚óÅ act) ‚â´ act := by aesop_cat\n\n"}
{"name":"Mod_.one_act","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nself : Mod_ A\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one self.X) self.act) (CategoryTheory.MonoidalCategoryStruct.leftUnitor self.X).hom","decl":"/-- A module object for a monoid object, all internal to some monoidal category. -/\nstructure Mod_ (A : Mon_ C) where\n  X : C\n  act : A.X ‚äó X ‚ü∂ X\n  one_act : (A.one ‚ñ∑ X) ‚â´ act = (Œª_ X).hom := by aesop_cat\n  assoc : (A.mul ‚ñ∑ X) ‚â´ act = (Œ±_ A.X A.X X).hom ‚â´ (A.X ‚óÅ act) ‚â´ act := by aesop_cat\n\n"}
{"name":"Mod_.assoc","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nself : Mod_ A\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul self.X) self.act) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X self.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X self.act) self.act))","decl":"/-- A module object for a monoid object, all internal to some monoidal category. -/\nstructure Mod_ (A : Mon_ C) where\n  X : C\n  act : A.X ‚äó X ‚ü∂ X\n  one_act : (A.one ‚ñ∑ X) ‚â´ act = (Œª_ X).hom := by aesop_cat\n  assoc : (A.mul ‚ñ∑ X) ‚â´ act = (Œ±_ A.X A.X X).hom ‚â´ (A.X ‚óÅ act) ‚â´ act := by aesop_cat\n\n"}
{"name":"Mod_.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nX‚úù : C\nact‚úù : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X X‚úù) X‚úù\none_act‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one X‚úù) act‚úù) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X‚úù).hom) _auto‚úù\nassoc‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul X‚úù) act‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X X‚úù).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X act‚úù) act‚úù))) _auto‚úù\nX : C\nact : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X X) X\none_act : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one X) act) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) _auto‚úù\nassoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul X) act) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X act) act))) _auto‚úù\nx‚úù : Eq { X := X‚úù, act := act‚úù, one_act := one_act‚úù, assoc := assoc‚úù } { X := X, act := act, one_act := one_act, assoc := assoc }\n‚ä¢ And (Eq X‚úù X) (HEq act‚úù act)","decl":"/-- A module object for a monoid object, all internal to some monoidal category. -/\nstructure Mod_ (A : Mon_ C) where\n  X : C\n  act : A.X ‚äó X ‚ü∂ X\n  one_act : (A.one ‚ñ∑ X) ‚â´ act = (Œª_ X).hom := by aesop_cat\n  assoc : (A.mul ‚ñ∑ X) ‚â´ act = (Œ±_ A.X A.X X).hom ‚â´ (A.X ‚óÅ act) ‚â´ act := by aesop_cat\n\n"}
{"name":"Mod_.assoc_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nself : Mod_ A\nZ : C\nh : Quiver.Hom self.X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul self.X) (CategoryTheory.CategoryStruct.comp self.act h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X self.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X self.act) (CategoryTheory.CategoryStruct.comp self.act h)))","decl":"attribute [reassoc (attr := simp)] Mod_.one_act Mod_.assoc\n\n"}
{"name":"Mod_.one_act_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nself : Mod_ A\nZ : C\nh : Quiver.Hom self.X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one self.X) (CategoryTheory.CategoryStruct.comp self.act h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor self.X).hom h)","decl":"attribute [reassoc (attr := simp)] Mod_.one_act Mod_.assoc\n\n"}
{"name":"Mod_.assoc_flip","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM : Mod_ A\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X M.act) M.act) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X M.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul M.X) M.act))","decl":"theorem assoc_flip :\n    (A.X ‚óÅ M.act) ‚â´ M.act = (Œ±_ A.X A.X M.X).inv ‚â´ (A.mul ‚ñ∑ M.X) ‚â´ M.act := by simp\n\n"}
{"name":"Mod_.Hom.ext","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N : Mod_ A\nx y : M.Hom N\nhom : Eq x.hom y.hom\n‚ä¢ Eq x y","decl":"/-- A morphism of module objects. -/\n@[ext]\nstructure Hom (M N : Mod_ A) where\n  hom : M.X ‚ü∂ N.X\n  act_hom : M.act ‚â´ hom = (A.X ‚óÅ hom) ‚â´ N.act := by aesop_cat\n\n"}
{"name":"Mod_.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N : Mod_ A\nhom‚úù : Quiver.Hom M.X N.X\nact_hom‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.act hom‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X hom‚úù) N.act)) _auto‚úù\nhom : Quiver.Hom M.X N.X\nact_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.act hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X hom) N.act)) _auto‚úù\n‚ä¢ Eq (Eq { hom := hom‚úù, act_hom := act_hom‚úù } { hom := hom, act_hom := act_hom }) (Eq hom‚úù hom)","decl":"/-- A morphism of module objects. -/\n@[ext]\nstructure Hom (M N : Mod_ A) where\n  hom : M.X ‚ü∂ N.X\n  act_hom : M.act ‚â´ hom = (A.X ‚óÅ hom) ‚â´ N.act := by aesop_cat\n\n"}
{"name":"Mod_.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N : Mod_ A\ninst‚úù : SizeOf C\nhom : Quiver.Hom M.X N.X\nact_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.act hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X hom) N.act)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { hom := hom, act_hom := act_hom }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf hom)) (SizeOf.sizeOf act_hom))","decl":"/-- A morphism of module objects. -/\n@[ext]\nstructure Hom (M N : Mod_ A) where\n  hom : M.X ‚ü∂ N.X\n  act_hom : M.act ‚â´ hom = (A.X ‚óÅ hom) ‚â´ N.act := by aesop_cat\n\n"}
{"name":"Mod_.Hom.act_hom","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N : Mod_ A\nself : M.Hom N\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.act self.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X self.hom) N.act)","decl":"/-- A morphism of module objects. -/\n@[ext]\nstructure Hom (M N : Mod_ A) where\n  hom : M.X ‚ü∂ N.X\n  act_hom : M.act ‚â´ hom = (A.X ‚óÅ hom) ‚â´ N.act := by aesop_cat\n\n"}
{"name":"Mod_.Hom.ext_iff","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N : Mod_ A\nx y : M.Hom N\n‚ä¢ Iff (Eq x y) (Eq x.hom y.hom)","decl":"/-- A morphism of module objects. -/\n@[ext]\nstructure Hom (M N : Mod_ A) where\n  hom : M.X ‚ü∂ N.X\n  act_hom : M.act ‚â´ hom = (A.X ‚óÅ hom) ‚â´ N.act := by aesop_cat\n\n"}
{"name":"Mod_.Hom.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N : Mod_ A\nhom‚úù : Quiver.Hom M.X N.X\nact_hom‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.act hom‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X hom‚úù) N.act)) _auto‚úù\nhom : Quiver.Hom M.X N.X\nact_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.act hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X hom) N.act)) _auto‚úù\nx‚úù : Eq { hom := hom‚úù, act_hom := act_hom‚úù } { hom := hom, act_hom := act_hom }\n‚ä¢ Eq hom‚úù hom","decl":"/-- A morphism of module objects. -/\n@[ext]\nstructure Hom (M N : Mod_ A) where\n  hom : M.X ‚ü∂ N.X\n  act_hom : M.act ‚â´ hom = (A.X ‚óÅ hom) ‚â´ N.act := by aesop_cat\n\n"}
{"name":"Mod_.Hom.act_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N : Mod_ A\nself : M.Hom N\nZ : C\nh : Quiver.Hom N.X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.act (CategoryTheory.CategoryStruct.comp self.hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X self.hom) (CategoryTheory.CategoryStruct.comp N.act h))","decl":"attribute [reassoc (attr := simp)] Hom.act_hom\n\n"}
{"name":"Mod_.id_hom","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM : Mod_ A\n‚ä¢ Eq M.id.hom (CategoryTheory.CategoryStruct.id M.X)","decl":"/-- The identity morphism on a module object. -/\n@[simps]\ndef id (M : Mod_ A) : Hom M M where hom := ùüô M.X\n\n"}
{"name":"Mod_.comp_hom","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N O : Mod_ A\nf : M.Hom N\ng : N.Hom O\n‚ä¢ Eq (Mod_.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"/-- Composition of module object morphisms. -/\n@[simps]\ndef comp {M N O : Mod_ A} (f : Hom M N) (g : Hom N O) : Hom M O where hom := f.hom ‚â´ g.hom\n\n"}
{"name":"Mod_.hom_ext_iff","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N : Mod_ A\nf‚ÇÅ f‚ÇÇ : Quiver.Hom M N\n‚ä¢ Iff (Eq f‚ÇÅ f‚ÇÇ) (Eq f‚ÇÅ.hom f‚ÇÇ.hom)","decl":"@[ext]\nlemma hom_ext {M N : Mod_ A} (f‚ÇÅ f‚ÇÇ : M ‚ü∂ N) (h : f‚ÇÅ.hom = f‚ÇÇ.hom) : f‚ÇÅ = f‚ÇÇ :=\n  Hom.ext h\n\n"}
{"name":"Mod_.hom_ext","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N : Mod_ A\nf‚ÇÅ f‚ÇÇ : Quiver.Hom M N\nh : Eq f‚ÇÅ.hom f‚ÇÇ.hom\n‚ä¢ Eq f‚ÇÅ f‚ÇÇ","decl":"@[ext]\nlemma hom_ext {M N : Mod_ A} (f‚ÇÅ f‚ÇÇ : M ‚ü∂ N) (h : f‚ÇÅ.hom = f‚ÇÇ.hom) : f‚ÇÅ = f‚ÇÇ :=\n  Hom.ext h\n\n"}
{"name":"Mod_.id_hom'","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM : Mod_ A\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id M).hom (CategoryTheory.CategoryStruct.id M.X)","decl":"@[simp]\ntheorem id_hom' (M : Mod_ A) : (ùüô M : M ‚ü∂ M).hom = ùüô M.X := by\n  rfl\n\n"}
{"name":"Mod_.comp_hom'","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N K : Mod_ A\nf : Quiver.Hom M N\ng : Quiver.Hom N K\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"@[simp]\ntheorem comp_hom' {M N K : Mod_ A} (f : M ‚ü∂ N) (g : N ‚ü∂ K) :\n    (f ‚â´ g).hom = f.hom ‚â´ g.hom :=\n  rfl\n\n"}
{"name":"Mod_.regular_act","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\n‚ä¢ Eq (Mod_.regular A).act A.mul","decl":"/-- A monoid object as a module over itself. -/\n@[simps]\ndef regular : Mod_ A where\n  X := A.X\n  act := A.mul\n\n"}
{"name":"Mod_.regular_X","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ C\n‚ä¢ Eq (Mod_.regular A).X A.X","decl":"/-- A monoid object as a module over itself. -/\n@[simps]\ndef regular : Mod_ A where\n  X := A.X\n  act := A.mul\n\n"}
{"name":"Mod_.comap_obj_X","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nf : Quiver.Hom A B\nM : Mod_ B\n‚ä¢ Eq ((Mod_.comap f).obj M).X M.X","decl":"/-- A morphism of monoid objects induces a \"restriction\" or \"comap\" functor\nbetween the categories of module objects.\n-/\n@[simps]\ndef comap {A B : Mon_ C} (f : A ‚ü∂ B) : Mod_ B ‚•§ Mod_ A where\n  obj M :=\n    { X := M.X\n      act := (f.hom ‚ñ∑ M.X) ‚â´ M.act\n      one_act := by\n        slice_lhs 1 2 => rw [‚Üê comp_whiskerRight]\n        rw [f.one_hom, one_act]\n      assoc := by\n        -- oh, for homotopy.io in a widget!\n        slice_rhs 2 3 => rw [whisker_exchange]\n        simp only [whiskerRight_tensor, MonoidalCategory.whiskerLeft_comp, Category.assoc,\n          Iso.hom_inv_id_assoc]\n        slice_rhs 4 5 => rw [Mod_.assoc_flip]\n        slice_rhs 3 4 => rw [associator_inv_naturality_middle]\n        slice_rhs 2 4 => rw [Iso.hom_inv_id_assoc]\n        slice_rhs 1 2 => rw [‚Üê MonoidalCategory.comp_whiskerRight, ‚Üê whisker_exchange]\n        slice_rhs 1 2 => rw [‚Üê MonoidalCategory.comp_whiskerRight, ‚Üê tensorHom_def', ‚Üê f.mul_hom]\n        rw [comp_whiskerRight, Category.assoc] }\n  map g :=\n    { hom := g.hom\n      act_hom := by\n        dsimp\n        slice_rhs 1 2 => rw [whisker_exchange]\n        slice_rhs 2 3 => rw [‚Üê g.act_hom]\n        rw [Category.assoc] }\n  map_id _ := rfl -- the `aesop_cat` autoparam solves this but it's slow\n  map_comp _ _ := rfl -- the `aesop_cat` autoparam solves this but it's slow\n\n-- Lots more could be said about `comap`, e.g. how it interacts with\n-- identities, compositions, and equalities of monoid object morphisms.\n"}
{"name":"Mod_.comap_map_hom","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nf : Quiver.Hom A B\nX‚úù Y‚úù : Mod_ B\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((Mod_.comap f).map g).hom g.hom","decl":"/-- A morphism of monoid objects induces a \"restriction\" or \"comap\" functor\nbetween the categories of module objects.\n-/\n@[simps]\ndef comap {A B : Mon_ C} (f : A ‚ü∂ B) : Mod_ B ‚•§ Mod_ A where\n  obj M :=\n    { X := M.X\n      act := (f.hom ‚ñ∑ M.X) ‚â´ M.act\n      one_act := by\n        slice_lhs 1 2 => rw [‚Üê comp_whiskerRight]\n        rw [f.one_hom, one_act]\n      assoc := by\n        -- oh, for homotopy.io in a widget!\n        slice_rhs 2 3 => rw [whisker_exchange]\n        simp only [whiskerRight_tensor, MonoidalCategory.whiskerLeft_comp, Category.assoc,\n          Iso.hom_inv_id_assoc]\n        slice_rhs 4 5 => rw [Mod_.assoc_flip]\n        slice_rhs 3 4 => rw [associator_inv_naturality_middle]\n        slice_rhs 2 4 => rw [Iso.hom_inv_id_assoc]\n        slice_rhs 1 2 => rw [‚Üê MonoidalCategory.comp_whiskerRight, ‚Üê whisker_exchange]\n        slice_rhs 1 2 => rw [‚Üê MonoidalCategory.comp_whiskerRight, ‚Üê tensorHom_def', ‚Üê f.mul_hom]\n        rw [comp_whiskerRight, Category.assoc] }\n  map g :=\n    { hom := g.hom\n      act_hom := by\n        dsimp\n        slice_rhs 1 2 => rw [whisker_exchange]\n        slice_rhs 2 3 => rw [‚Üê g.act_hom]\n        rw [Category.assoc] }\n  map_id _ := rfl -- the `aesop_cat` autoparam solves this but it's slow\n  map_comp _ _ := rfl -- the `aesop_cat` autoparam solves this but it's slow\n\n-- Lots more could be said about `comap`, e.g. how it interacts with\n-- identities, compositions, and equalities of monoid object morphisms.\n"}
{"name":"Mod_.comap_obj_act","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nf : Quiver.Hom A B\nM : Mod_ B\n‚ä¢ Eq ((Mod_.comap f).obj M).act (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.hom M.X) M.act)","decl":"/-- A morphism of monoid objects induces a \"restriction\" or \"comap\" functor\nbetween the categories of module objects.\n-/\n@[simps]\ndef comap {A B : Mon_ C} (f : A ‚ü∂ B) : Mod_ B ‚•§ Mod_ A where\n  obj M :=\n    { X := M.X\n      act := (f.hom ‚ñ∑ M.X) ‚â´ M.act\n      one_act := by\n        slice_lhs 1 2 => rw [‚Üê comp_whiskerRight]\n        rw [f.one_hom, one_act]\n      assoc := by\n        -- oh, for homotopy.io in a widget!\n        slice_rhs 2 3 => rw [whisker_exchange]\n        simp only [whiskerRight_tensor, MonoidalCategory.whiskerLeft_comp, Category.assoc,\n          Iso.hom_inv_id_assoc]\n        slice_rhs 4 5 => rw [Mod_.assoc_flip]\n        slice_rhs 3 4 => rw [associator_inv_naturality_middle]\n        slice_rhs 2 4 => rw [Iso.hom_inv_id_assoc]\n        slice_rhs 1 2 => rw [‚Üê MonoidalCategory.comp_whiskerRight, ‚Üê whisker_exchange]\n        slice_rhs 1 2 => rw [‚Üê MonoidalCategory.comp_whiskerRight, ‚Üê tensorHom_def', ‚Üê f.mul_hom]\n        rw [comp_whiskerRight, Category.assoc] }\n  map g :=\n    { hom := g.hom\n      act_hom := by\n        dsimp\n        slice_rhs 1 2 => rw [whisker_exchange]\n        slice_rhs 2 3 => rw [‚Üê g.act_hom]\n        rw [Category.assoc] }\n  map_id _ := rfl -- the `aesop_cat` autoparam solves this but it's slow\n  map_comp _ _ := rfl -- the `aesop_cat` autoparam solves this but it's slow\n\n-- Lots more could be said about `comap`, e.g. how it interacts with\n-- identities, compositions, and equalities of monoid object morphisms.\n"}
