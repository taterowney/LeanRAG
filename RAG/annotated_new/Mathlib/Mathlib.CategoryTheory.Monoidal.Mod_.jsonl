{"name":"Mod_.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nX✝ : C\nact✝ : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X X✝) X✝\none_act✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one X✝) act✝) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X✝).hom) _auto✝\nassoc✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul X✝) act✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X X✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X act✝) act✝))) _auto✝\nX : C\nact : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X X) X\none_act : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one X) act) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) _auto✝\nassoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul X) act) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X act) act))) _auto✝\n⊢ Eq (Eq { X := X✝, act := act✝, one_act := one_act✝, assoc := assoc✝ } { X := X, act := act, one_act := one_act, assoc := assoc }) (And (Eq X✝ X) (HEq act✝ act))","decl":"/-- A module object for a monoid object, all internal to some monoidal category. -/\nstructure Mod_ (A : Mon_ C) where\n  X : C\n  act : A.X ⊗ X ⟶ X\n  one_act : (A.one ▷ X) ≫ act = (λ_ X).hom := by aesop_cat\n  assoc : (A.mul ▷ X) ≫ act = (α_ A.X A.X X).hom ≫ (A.X ◁ act) ≫ act := by aesop_cat\n\n"}
{"name":"Mod_.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\ninst✝ : SizeOf C\nX : C\nact : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X X) X\none_act : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one X) act) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) _auto✝\nassoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul X) act) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X act) act))) _auto✝\n⊢ Eq (SizeOf.sizeOf { X := X, act := act, one_act := one_act, assoc := assoc }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf X)) (SizeOf.sizeOf act)) (SizeOf.sizeOf one_act)) (SizeOf.sizeOf assoc))","decl":"/-- A module object for a monoid object, all internal to some monoidal category. -/\nstructure Mod_ (A : Mon_ C) where\n  X : C\n  act : A.X ⊗ X ⟶ X\n  one_act : (A.one ▷ X) ≫ act = (λ_ X).hom := by aesop_cat\n  assoc : (A.mul ▷ X) ≫ act = (α_ A.X A.X X).hom ≫ (A.X ◁ act) ≫ act := by aesop_cat\n\n"}
{"name":"Mod_.one_act","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nself : Mod_ A\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one self.X) self.act) (CategoryTheory.MonoidalCategoryStruct.leftUnitor self.X).hom","decl":"/-- A module object for a monoid object, all internal to some monoidal category. -/\nstructure Mod_ (A : Mon_ C) where\n  X : C\n  act : A.X ⊗ X ⟶ X\n  one_act : (A.one ▷ X) ≫ act = (λ_ X).hom := by aesop_cat\n  assoc : (A.mul ▷ X) ≫ act = (α_ A.X A.X X).hom ≫ (A.X ◁ act) ≫ act := by aesop_cat\n\n"}
{"name":"Mod_.assoc","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nself : Mod_ A\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul self.X) self.act) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X self.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X self.act) self.act))","decl":"/-- A module object for a monoid object, all internal to some monoidal category. -/\nstructure Mod_ (A : Mon_ C) where\n  X : C\n  act : A.X ⊗ X ⟶ X\n  one_act : (A.one ▷ X) ≫ act = (λ_ X).hom := by aesop_cat\n  assoc : (A.mul ▷ X) ≫ act = (α_ A.X A.X X).hom ≫ (A.X ◁ act) ≫ act := by aesop_cat\n\n"}
{"name":"Mod_.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nX✝ : C\nact✝ : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X X✝) X✝\none_act✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one X✝) act✝) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X✝).hom) _auto✝\nassoc✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul X✝) act✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X X✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X act✝) act✝))) _auto✝\nX : C\nact : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X X) X\none_act : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one X) act) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) _auto✝\nassoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul X) act) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X act) act))) _auto✝\nx✝ : Eq { X := X✝, act := act✝, one_act := one_act✝, assoc := assoc✝ } { X := X, act := act, one_act := one_act, assoc := assoc }\n⊢ And (Eq X✝ X) (HEq act✝ act)","decl":"/-- A module object for a monoid object, all internal to some monoidal category. -/\nstructure Mod_ (A : Mon_ C) where\n  X : C\n  act : A.X ⊗ X ⟶ X\n  one_act : (A.one ▷ X) ≫ act = (λ_ X).hom := by aesop_cat\n  assoc : (A.mul ▷ X) ≫ act = (α_ A.X A.X X).hom ≫ (A.X ◁ act) ≫ act := by aesop_cat\n\n"}
{"name":"Mod_.assoc_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nself : Mod_ A\nZ : C\nh : Quiver.Hom self.X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul self.X) (CategoryTheory.CategoryStruct.comp self.act h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X self.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X self.act) (CategoryTheory.CategoryStruct.comp self.act h)))","decl":"attribute [reassoc (attr := simp)] Mod_.one_act Mod_.assoc\n\n"}
{"name":"Mod_.one_act_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nself : Mod_ A\nZ : C\nh : Quiver.Hom self.X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one self.X) (CategoryTheory.CategoryStruct.comp self.act h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor self.X).hom h)","decl":"attribute [reassoc (attr := simp)] Mod_.one_act Mod_.assoc\n\n"}
{"name":"Mod_.assoc_flip","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM : Mod_ A\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X M.act) M.act) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X M.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul M.X) M.act))","decl":"theorem assoc_flip :\n    (A.X ◁ M.act) ≫ M.act = (α_ A.X A.X M.X).inv ≫ (A.mul ▷ M.X) ≫ M.act := by simp\n\n"}
{"name":"Mod_.Hom.ext","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N : Mod_ A\nx y : M.Hom N\nhom : Eq x.hom y.hom\n⊢ Eq x y","decl":"/-- A morphism of module objects. -/\n@[ext]\nstructure Hom (M N : Mod_ A) where\n  hom : M.X ⟶ N.X\n  act_hom : M.act ≫ hom = (A.X ◁ hom) ≫ N.act := by aesop_cat\n\n"}
{"name":"Mod_.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N : Mod_ A\nhom✝ : Quiver.Hom M.X N.X\nact_hom✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.act hom✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X hom✝) N.act)) _auto✝\nhom : Quiver.Hom M.X N.X\nact_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.act hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X hom) N.act)) _auto✝\n⊢ Eq (Eq { hom := hom✝, act_hom := act_hom✝ } { hom := hom, act_hom := act_hom }) (Eq hom✝ hom)","decl":"/-- A morphism of module objects. -/\n@[ext]\nstructure Hom (M N : Mod_ A) where\n  hom : M.X ⟶ N.X\n  act_hom : M.act ≫ hom = (A.X ◁ hom) ≫ N.act := by aesop_cat\n\n"}
{"name":"Mod_.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N : Mod_ A\ninst✝ : SizeOf C\nhom : Quiver.Hom M.X N.X\nact_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.act hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X hom) N.act)) _auto✝\n⊢ Eq (SizeOf.sizeOf { hom := hom, act_hom := act_hom }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf hom)) (SizeOf.sizeOf act_hom))","decl":"/-- A morphism of module objects. -/\n@[ext]\nstructure Hom (M N : Mod_ A) where\n  hom : M.X ⟶ N.X\n  act_hom : M.act ≫ hom = (A.X ◁ hom) ≫ N.act := by aesop_cat\n\n"}
{"name":"Mod_.Hom.act_hom","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N : Mod_ A\nself : M.Hom N\n⊢ Eq (CategoryTheory.CategoryStruct.comp M.act self.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X self.hom) N.act)","decl":"/-- A morphism of module objects. -/\n@[ext]\nstructure Hom (M N : Mod_ A) where\n  hom : M.X ⟶ N.X\n  act_hom : M.act ≫ hom = (A.X ◁ hom) ≫ N.act := by aesop_cat\n\n"}
{"name":"Mod_.Hom.ext_iff","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N : Mod_ A\nx y : M.Hom N\n⊢ Iff (Eq x y) (Eq x.hom y.hom)","decl":"/-- A morphism of module objects. -/\n@[ext]\nstructure Hom (M N : Mod_ A) where\n  hom : M.X ⟶ N.X\n  act_hom : M.act ≫ hom = (A.X ◁ hom) ≫ N.act := by aesop_cat\n\n"}
{"name":"Mod_.Hom.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N : Mod_ A\nhom✝ : Quiver.Hom M.X N.X\nact_hom✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.act hom✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X hom✝) N.act)) _auto✝\nhom : Quiver.Hom M.X N.X\nact_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.act hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X hom) N.act)) _auto✝\nx✝ : Eq { hom := hom✝, act_hom := act_hom✝ } { hom := hom, act_hom := act_hom }\n⊢ Eq hom✝ hom","decl":"/-- A morphism of module objects. -/\n@[ext]\nstructure Hom (M N : Mod_ A) where\n  hom : M.X ⟶ N.X\n  act_hom : M.act ≫ hom = (A.X ◁ hom) ≫ N.act := by aesop_cat\n\n"}
{"name":"Mod_.Hom.act_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N : Mod_ A\nself : M.Hom N\nZ : C\nh : Quiver.Hom N.X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp M.act (CategoryTheory.CategoryStruct.comp self.hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X self.hom) (CategoryTheory.CategoryStruct.comp N.act h))","decl":"attribute [reassoc (attr := simp)] Hom.act_hom\n\n"}
{"name":"Mod_.id_hom","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM : Mod_ A\n⊢ Eq M.id.hom (CategoryTheory.CategoryStruct.id M.X)","decl":"/-- The identity morphism on a module object. -/\n@[simps]\ndef id (M : Mod_ A) : Hom M M where hom := 𝟙 M.X\n\n"}
{"name":"Mod_.comp_hom","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N O : Mod_ A\nf : M.Hom N\ng : N.Hom O\n⊢ Eq (Mod_.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"/-- Composition of module object morphisms. -/\n@[simps]\ndef comp {M N O : Mod_ A} (f : Hom M N) (g : Hom N O) : Hom M O where hom := f.hom ≫ g.hom\n\n"}
{"name":"Mod_.hom_ext_iff","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N : Mod_ A\nf₁ f₂ : Quiver.Hom M N\n⊢ Iff (Eq f₁ f₂) (Eq f₁.hom f₂.hom)","decl":"@[ext]\nlemma hom_ext {M N : Mod_ A} (f₁ f₂ : M ⟶ N) (h : f₁.hom = f₂.hom) : f₁ = f₂ :=\n  Hom.ext h\n\n"}
{"name":"Mod_.hom_ext","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N : Mod_ A\nf₁ f₂ : Quiver.Hom M N\nh : Eq f₁.hom f₂.hom\n⊢ Eq f₁ f₂","decl":"@[ext]\nlemma hom_ext {M N : Mod_ A} (f₁ f₂ : M ⟶ N) (h : f₁.hom = f₂.hom) : f₁ = f₂ :=\n  Hom.ext h\n\n"}
{"name":"Mod_.id_hom'","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM : Mod_ A\n⊢ Eq (CategoryTheory.CategoryStruct.id M).hom (CategoryTheory.CategoryStruct.id M.X)","decl":"@[simp]\ntheorem id_hom' (M : Mod_ A) : (𝟙 M : M ⟶ M).hom = 𝟙 M.X := by\n  rfl\n\n"}
{"name":"Mod_.comp_hom'","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nM N K : Mod_ A\nf : Quiver.Hom M N\ng : Quiver.Hom N K\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"@[simp]\ntheorem comp_hom' {M N K : Mod_ A} (f : M ⟶ N) (g : N ⟶ K) :\n    (f ≫ g).hom = f.hom ≫ g.hom :=\n  rfl\n\n"}
{"name":"Mod_.regular_act","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\n⊢ Eq (Mod_.regular A).act A.mul","decl":"/-- A monoid object as a module over itself. -/\n@[simps]\ndef regular : Mod_ A where\n  X := A.X\n  act := A.mul\n\n"}
{"name":"Mod_.regular_X","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\n⊢ Eq (Mod_.regular A).X A.X","decl":"/-- A monoid object as a module over itself. -/\n@[simps]\ndef regular : Mod_ A where\n  X := A.X\n  act := A.mul\n\n"}
{"name":"Mod_.comap_obj_X","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nf : Quiver.Hom A B\nM : Mod_ B\n⊢ Eq ((Mod_.comap f).obj M).X M.X","decl":"/-- A morphism of monoid objects induces a \"restriction\" or \"comap\" functor\nbetween the categories of module objects.\n-/\n@[simps]\ndef comap {A B : Mon_ C} (f : A ⟶ B) : Mod_ B ⥤ Mod_ A where\n  obj M :=\n    { X := M.X\n      act := (f.hom ▷ M.X) ≫ M.act\n      one_act := by\n        slice_lhs 1 2 => rw [← comp_whiskerRight]\n        rw [f.one_hom, one_act]\n      assoc := by\n        -- oh, for homotopy.io in a widget!\n        slice_rhs 2 3 => rw [whisker_exchange]\n        simp only [whiskerRight_tensor, MonoidalCategory.whiskerLeft_comp, Category.assoc,\n          Iso.hom_inv_id_assoc]\n        slice_rhs 4 5 => rw [Mod_.assoc_flip]\n        slice_rhs 3 4 => rw [associator_inv_naturality_middle]\n        slice_rhs 2 4 => rw [Iso.hom_inv_id_assoc]\n        slice_rhs 1 2 => rw [← MonoidalCategory.comp_whiskerRight, ← whisker_exchange]\n        slice_rhs 1 2 => rw [← MonoidalCategory.comp_whiskerRight, ← tensorHom_def', ← f.mul_hom]\n        rw [comp_whiskerRight, Category.assoc] }\n  map g :=\n    { hom := g.hom\n      act_hom := by\n        dsimp\n        slice_rhs 1 2 => rw [whisker_exchange]\n        slice_rhs 2 3 => rw [← g.act_hom]\n        rw [Category.assoc] }\n  map_id _ := rfl -- the `aesop_cat` autoparam solves this but it's slow\n  map_comp _ _ := rfl -- the `aesop_cat` autoparam solves this but it's slow\n\n-- Lots more could be said about `comap`, e.g. how it interacts with\n-- identities, compositions, and equalities of monoid object morphisms.\n"}
{"name":"Mod_.comap_map_hom","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nf : Quiver.Hom A B\nX✝ Y✝ : Mod_ B\ng : Quiver.Hom X✝ Y✝\n⊢ Eq ((Mod_.comap f).map g).hom g.hom","decl":"/-- A morphism of monoid objects induces a \"restriction\" or \"comap\" functor\nbetween the categories of module objects.\n-/\n@[simps]\ndef comap {A B : Mon_ C} (f : A ⟶ B) : Mod_ B ⥤ Mod_ A where\n  obj M :=\n    { X := M.X\n      act := (f.hom ▷ M.X) ≫ M.act\n      one_act := by\n        slice_lhs 1 2 => rw [← comp_whiskerRight]\n        rw [f.one_hom, one_act]\n      assoc := by\n        -- oh, for homotopy.io in a widget!\n        slice_rhs 2 3 => rw [whisker_exchange]\n        simp only [whiskerRight_tensor, MonoidalCategory.whiskerLeft_comp, Category.assoc,\n          Iso.hom_inv_id_assoc]\n        slice_rhs 4 5 => rw [Mod_.assoc_flip]\n        slice_rhs 3 4 => rw [associator_inv_naturality_middle]\n        slice_rhs 2 4 => rw [Iso.hom_inv_id_assoc]\n        slice_rhs 1 2 => rw [← MonoidalCategory.comp_whiskerRight, ← whisker_exchange]\n        slice_rhs 1 2 => rw [← MonoidalCategory.comp_whiskerRight, ← tensorHom_def', ← f.mul_hom]\n        rw [comp_whiskerRight, Category.assoc] }\n  map g :=\n    { hom := g.hom\n      act_hom := by\n        dsimp\n        slice_rhs 1 2 => rw [whisker_exchange]\n        slice_rhs 2 3 => rw [← g.act_hom]\n        rw [Category.assoc] }\n  map_id _ := rfl -- the `aesop_cat` autoparam solves this but it's slow\n  map_comp _ _ := rfl -- the `aesop_cat` autoparam solves this but it's slow\n\n-- Lots more could be said about `comap`, e.g. how it interacts with\n-- identities, compositions, and equalities of monoid object morphisms.\n"}
{"name":"Mod_.comap_obj_act","module":"Mathlib.CategoryTheory.Monoidal.Mod_","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nf : Quiver.Hom A B\nM : Mod_ B\n⊢ Eq ((Mod_.comap f).obj M).act (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.hom M.X) M.act)","decl":"/-- A morphism of monoid objects induces a \"restriction\" or \"comap\" functor\nbetween the categories of module objects.\n-/\n@[simps]\ndef comap {A B : Mon_ C} (f : A ⟶ B) : Mod_ B ⥤ Mod_ A where\n  obj M :=\n    { X := M.X\n      act := (f.hom ▷ M.X) ≫ M.act\n      one_act := by\n        slice_lhs 1 2 => rw [← comp_whiskerRight]\n        rw [f.one_hom, one_act]\n      assoc := by\n        -- oh, for homotopy.io in a widget!\n        slice_rhs 2 3 => rw [whisker_exchange]\n        simp only [whiskerRight_tensor, MonoidalCategory.whiskerLeft_comp, Category.assoc,\n          Iso.hom_inv_id_assoc]\n        slice_rhs 4 5 => rw [Mod_.assoc_flip]\n        slice_rhs 3 4 => rw [associator_inv_naturality_middle]\n        slice_rhs 2 4 => rw [Iso.hom_inv_id_assoc]\n        slice_rhs 1 2 => rw [← MonoidalCategory.comp_whiskerRight, ← whisker_exchange]\n        slice_rhs 1 2 => rw [← MonoidalCategory.comp_whiskerRight, ← tensorHom_def', ← f.mul_hom]\n        rw [comp_whiskerRight, Category.assoc] }\n  map g :=\n    { hom := g.hom\n      act_hom := by\n        dsimp\n        slice_rhs 1 2 => rw [whisker_exchange]\n        slice_rhs 2 3 => rw [← g.act_hom]\n        rw [Category.assoc] }\n  map_id _ := rfl -- the `aesop_cat` autoparam solves this but it's slow\n  map_comp _ _ := rfl -- the `aesop_cat` autoparam solves this but it's slow\n\n-- Lots more could be said about `comap`, e.g. how it interacts with\n-- identities, compositions, and equalities of monoid object morphisms.\n"}
