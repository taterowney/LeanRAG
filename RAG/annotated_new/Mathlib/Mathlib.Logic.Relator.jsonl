{"name":"Relator.RightTotal.rel_forall","module":"Mathlib.Logic.Relator","initialProofState":"α : Type u₁\nβ : Type u₂\nR : α → β → Prop\nh : Relator.RightTotal R\n⊢ Relator.LiftFun (Relator.LiftFun R fun x1 x2 => x1 → x2) (fun x1 x2 => x1 → x2) (fun p => (i : α) → p i) fun q => ∀ (i : β), q i","decl":"lemma RightTotal.rel_forall (h : RightTotal R) :\n    ((R ⇒ (· → ·)) ⇒ (· → ·)) (fun p => ∀i, p i) (fun q => ∀i, q i) :=\n  fun _ _ Hrel H b => Exists.elim (h b) (fun _ Rab => Hrel Rab (H _))\n\n"}
{"name":"Relator.LeftTotal.rel_exists","module":"Mathlib.Logic.Relator","initialProofState":"α : Type u₁\nβ : Type u₂\nR : α → β → Prop\nh : Relator.LeftTotal R\n⊢ Relator.LiftFun (Relator.LiftFun R fun x1 x2 => x1 → x2) (fun x1 x2 => x1 → x2) (fun p => Exists fun i => p i) fun q => Exists fun i => q i","decl":"lemma LeftTotal.rel_exists (h : LeftTotal R) :\n    ((R ⇒ (· → ·)) ⇒ (· → ·)) (fun p => ∃i, p i) (fun q => ∃i, q i) :=\n  fun _ _ Hrel ⟨a, pa⟩ => (h a).imp fun _ Rab => Hrel Rab pa\n\n"}
{"name":"Relator.BiTotal.rel_forall","module":"Mathlib.Logic.Relator","initialProofState":"α : Type u₁\nβ : Type u₂\nR : α → β → Prop\nh : Relator.BiTotal R\n⊢ Relator.LiftFun (Relator.LiftFun R Iff) Iff (fun p => ∀ (i : α), p i) fun q => ∀ (i : β), q i","decl":"lemma BiTotal.rel_forall (h : BiTotal R) :\n    ((R ⇒ Iff) ⇒ Iff) (fun p => ∀i, p i) (fun q => ∀i, q i) :=\n  fun _ _ Hrel =>\n    ⟨fun H b => Exists.elim (h.right b) (fun _ Rab => (Hrel Rab).mp (H _)),\n      fun H a => Exists.elim (h.left a) (fun _ Rab => (Hrel Rab).mpr (H _))⟩\n\n"}
{"name":"Relator.BiTotal.rel_exists","module":"Mathlib.Logic.Relator","initialProofState":"α : Type u₁\nβ : Type u₂\nR : α → β → Prop\nh : Relator.BiTotal R\n⊢ Relator.LiftFun (Relator.LiftFun R Iff) Iff (fun p => Exists fun i => p i) fun q => Exists fun i => q i","decl":"lemma BiTotal.rel_exists (h : BiTotal R) :\n    ((R ⇒ Iff) ⇒ Iff) (fun p => ∃i, p i) (fun q => ∃i, q i) :=\n  fun _ _ Hrel =>\n    ⟨fun ⟨a, pa⟩ => (h.left a).imp fun _ Rab => (Hrel Rab).1 pa,\n      fun ⟨b, qb⟩ => (h.right b).imp fun _ Rab => (Hrel Rab).2 qb⟩\n\n"}
{"name":"Relator.left_unique_of_rel_eq","module":"Mathlib.Logic.Relator","initialProofState":"α : Type u₁\nβ : Type u₂\nR : α → β → Prop\neq' : β → β → Prop\nhe : Relator.LiftFun R (Relator.LiftFun R Iff) Eq eq'\n⊢ Relator.LeftUnique R","decl":"lemma left_unique_of_rel_eq {eq' : β → β → Prop} (he : (R ⇒ (R ⇒ Iff)) Eq eq') : LeftUnique R :=\n  fun a b c (ac : R a c) (bc : R b c) => (he ac bc).mpr ((he bc bc).mp rfl)\n\n"}
{"name":"Relator.rel_imp","module":"Mathlib.Logic.Relator","initialProofState":"⊢ Relator.LiftFun Iff (Relator.LiftFun Iff Iff) (fun x1 x2 => x1 → x2) fun x1 x2 => x1 → x2","decl":"lemma rel_imp : (Iff ⇒ (Iff ⇒ Iff)) (· → ·) (· → ·) :=\n  fun _ _ h _ _ l => imp_congr h l\n\n"}
{"name":"Relator.rel_not","module":"Mathlib.Logic.Relator","initialProofState":"⊢ Relator.LiftFun Iff Iff Not Not","decl":"lemma rel_not : (Iff ⇒ Iff) Not Not :=\n  fun _ _ h => not_congr h\n\n"}
{"name":"Relator.bi_total_eq","module":"Mathlib.Logic.Relator","initialProofState":"α : Type u₁\n⊢ Relator.BiTotal Eq","decl":"lemma bi_total_eq {α : Type u₁} : Relator.BiTotal (@Eq α) :=\n  { left := fun a => ⟨a, rfl⟩, right := fun a => ⟨a, rfl⟩ }\n\n"}
{"name":"Relator.LeftUnique.flip","module":"Mathlib.Logic.Relator","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → β → Prop\nh : Relator.LeftUnique r\n⊢ Relator.RightUnique (flip r)","decl":"lemma LeftUnique.flip (h : LeftUnique r) : RightUnique (flip r) :=\n  fun _ _ _ h₁ h₂ => h h₁ h₂\n\n"}
{"name":"Relator.rel_and","module":"Mathlib.Logic.Relator","initialProofState":"⊢ Relator.LiftFun (fun x1 x2 => Iff x1 x2) (Relator.LiftFun (fun x1 x2 => Iff x1 x2) fun x1 x2 => Iff x1 x2) (fun x1 x2 => And x1 x2) fun x1 x2 => And x1 x2","decl":"lemma rel_and : ((·↔·) ⇒ (·↔·) ⇒ (·↔·)) (·∧·) (·∧·) :=\n  fun _ _ h₁ _ _ h₂ => and_congr h₁ h₂\n\n"}
{"name":"Relator.rel_or","module":"Mathlib.Logic.Relator","initialProofState":"⊢ Relator.LiftFun (fun x1 x2 => Iff x1 x2) (Relator.LiftFun (fun x1 x2 => Iff x1 x2) fun x1 x2 => Iff x1 x2) (fun x1 x2 => Or x1 x2) fun x1 x2 => Or x1 x2","decl":"lemma rel_or : ((·↔·) ⇒ (·↔·) ⇒ (·↔·)) (·∨·) (·∨·) :=\n  fun _ _ h₁ _ _ h₂ => or_congr h₁ h₂\n\n"}
{"name":"Relator.rel_iff","module":"Mathlib.Logic.Relator","initialProofState":"⊢ Relator.LiftFun (fun x1 x2 => Iff x1 x2) (Relator.LiftFun (fun x1 x2 => Iff x1 x2) fun x1 x2 => Iff x1 x2) (fun x1 x2 => Iff x1 x2) fun x1 x2 => Iff x1 x2","decl":"lemma rel_iff : ((·↔·) ⇒ (·↔·) ⇒ (·↔·)) (·↔·) (·↔·) :=\n  fun _ _ h₁ _ _ h₂ => iff_congr h₁ h₂\n\n"}
{"name":"Relator.rel_eq","module":"Mathlib.Logic.Relator","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → β → Prop\nhr : Relator.BiUnique r\n⊢ Relator.LiftFun r (Relator.LiftFun r fun x1 x2 => Iff x1 x2) (fun x1 x2 => Eq x1 x2) fun x1 x2 => Eq x1 x2","decl":"lemma rel_eq {r : α → β → Prop} (hr : BiUnique r) : (r ⇒ r ⇒ (·↔·)) (·=·) (·=·) :=\n  fun _ _ h₁ _ _ h₂ => ⟨fun h => hr.right h₁ <| h.symm ▸ h₂, fun h => hr.left h₁ <| h.symm ▸ h₂⟩\n\n"}
{"name":"Relator.LeftTotal.refl","module":"Mathlib.Logic.Relator","initialProofState":"α : Type u_1\nr₁₁ : α → α → Prop\nhr : ∀ (a : α), r₁₁ a a\n⊢ Relator.LeftTotal r₁₁","decl":"protected lemma refl (hr : ∀ a : α, r₁₁ a a) :\n    LeftTotal r₁₁ :=\n  fun a ↦ ⟨a, hr _⟩\n\n"}
{"name":"Relator.LeftTotal.symm","module":"Mathlib.Logic.Relator","initialProofState":"α : Type u_1\nβ : Type u_2\nr₁₂ : α → β → Prop\nr₂₁ : β → α → Prop\nhr : ∀ (a : α) (b : β), r₁₂ a b → r₂₁ b a\na✝ : Relator.LeftTotal r₁₂\n⊢ Relator.RightTotal r₂₁","decl":"protected lemma symm (hr : ∀ (a : α) (b : β), r₁₂ a b → r₂₁ b a) :\n    LeftTotal r₁₂ → RightTotal r₂₁ :=\n  fun h a ↦ (h a).imp (fun _ ↦ hr _ _)\n\n"}
{"name":"Relator.LeftTotal.trans","module":"Mathlib.Logic.Relator","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr₁₂ : α → β → Prop\nr₂₃ : β → γ → Prop\nr₁₃ : α → γ → Prop\nhr : ∀ (a : α) (b : β) (c : γ), r₁₂ a b → r₂₃ b c → r₁₃ a c\na✝¹ : Relator.LeftTotal r₁₂\na✝ : Relator.LeftTotal r₂₃\n⊢ Relator.LeftTotal r₁₃","decl":"protected lemma trans (hr : ∀ (a : α) (b : β) (c : γ), r₁₂ a b → r₂₃ b c → r₁₃ a c) :\n    LeftTotal r₁₂ → LeftTotal r₂₃ → LeftTotal r₁₃ :=\n  fun h₁ h₂ a ↦ let ⟨b, hab⟩ := h₁ a; let ⟨c, hbc⟩ := h₂ b; ⟨c, hr _ _ _ hab hbc⟩\n\n"}
{"name":"Relator.RightTotal.refl","module":"Mathlib.Logic.Relator","initialProofState":"α : Type u_1\nr₁₁ : α → α → Prop\nhr : ∀ (a : α), r₁₁ a a\n⊢ Relator.RightTotal r₁₁","decl":"protected lemma refl (hr : ∀ a : α, r₁₁ a a) : RightTotal r₁₁ :=\n  LeftTotal.refl hr\n\n"}
{"name":"Relator.RightTotal.symm","module":"Mathlib.Logic.Relator","initialProofState":"α : Type u_1\nβ : Type u_2\nr₁₂ : α → β → Prop\nr₂₁ : β → α → Prop\nhr : ∀ (a : α) (b : β), r₁₂ a b → r₂₁ b a\na✝ : Relator.RightTotal r₁₂\n⊢ Relator.LeftTotal r₂₁","decl":"protected lemma symm (hr : ∀ (a : α) (b : β), r₁₂ a b → r₂₁ b a) :\n    RightTotal r₁₂ → LeftTotal r₂₁ :=\n  LeftTotal.symm (fun _ _ ↦ hr _ _)\n\n"}
{"name":"Relator.RightTotal.trans","module":"Mathlib.Logic.Relator","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr₁₂ : α → β → Prop\nr₂₃ : β → γ → Prop\nr₁₃ : α → γ → Prop\nhr : ∀ (a : α) (b : β) (c : γ), r₁₂ a b → r₂₃ b c → r₁₃ a c\na✝¹ : Relator.RightTotal r₁₂\na✝ : Relator.RightTotal r₂₃\n⊢ Relator.RightTotal r₁₃","decl":"protected lemma trans (hr : ∀ (a : α) (b : β) (c : γ), r₁₂ a b → r₂₃ b c → r₁₃ a c) :\n    RightTotal r₁₂ → RightTotal r₂₃ → RightTotal r₁₃ :=\n  swap <| LeftTotal.trans (fun _ _ _ ↦ swap <| hr _ _ _)\n\n"}
{"name":"Relator.BiTotal.refl","module":"Mathlib.Logic.Relator","initialProofState":"α : Type u_1\nr₁₁ : α → α → Prop\nhr : ∀ (a : α), r₁₁ a a\n⊢ Relator.BiTotal r₁₁","decl":"protected lemma refl (hr : ∀ a : α, r₁₁ a a) :\n    BiTotal r₁₁ :=\n  ⟨LeftTotal.refl hr, RightTotal.refl hr⟩\n\n"}
{"name":"Relator.BiTotal.symm","module":"Mathlib.Logic.Relator","initialProofState":"α : Type u_1\nβ : Type u_2\nr₁₂ : α → β → Prop\nr₂₁ : β → α → Prop\nhr : ∀ (a : α) (b : β), r₁₂ a b → r₂₁ b a\na✝ : Relator.BiTotal r₁₂\n⊢ Relator.BiTotal r₂₁","decl":"protected lemma symm (hr : ∀ (a : α) (b : β), r₁₂ a b → r₂₁ b a) :\n    BiTotal r₁₂ → BiTotal r₂₁ :=\n  fun h ↦ ⟨h.2.symm hr, h.1.symm hr⟩\n\n"}
{"name":"Relator.BiTotal.trans","module":"Mathlib.Logic.Relator","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr₁₂ : α → β → Prop\nr₂₃ : β → γ → Prop\nr₁₃ : α → γ → Prop\nhr : ∀ (a : α) (b : β) (c : γ), r₁₂ a b → r₂₃ b c → r₁₃ a c\na✝¹ : Relator.BiTotal r₁₂\na✝ : Relator.BiTotal r₂₃\n⊢ Relator.BiTotal r₁₃","decl":"protected lemma trans (hr : ∀ (a : α) (b : β) (c : γ), r₁₂ a b → r₂₃ b c → r₁₃ a c) :\n    BiTotal r₁₂ → BiTotal r₂₃ → BiTotal r₁₃ :=\n  fun h₁ h₂ ↦ ⟨h₁.1.trans hr h₂.1, h₁.2.trans hr h₂.2⟩\n\n"}
