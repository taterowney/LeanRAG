{"name":"Nat.filter_dvd_eq_divisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\nh : Ne n 0\n⊢ Eq (Finset.filter (fun d => Dvd.dvd d n) (Finset.range n.succ)) n.divisors","decl":"@[simp]\ntheorem filter_dvd_eq_divisors (h : n ≠ 0) : {d ∈ range n.succ | d ∣ n} = n.divisors := by\n  ext\n  simp only [divisors, mem_filter, mem_range, mem_Ico, and_congr_left_iff, iff_and_self]\n  exact fun ha _ => succ_le_iff.mpr (pos_of_dvd_of_pos ha h.bot_lt)\n\n"}
{"name":"Nat.filter_dvd_eq_properDivisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\nh : Ne n 0\n⊢ Eq (Finset.filter (fun d => Dvd.dvd d n) (Finset.range n)) n.properDivisors","decl":"@[simp]\ntheorem filter_dvd_eq_properDivisors (h : n ≠ 0) : {d ∈ range n | d ∣ n} = n.properDivisors := by\n  ext\n  simp only [properDivisors, mem_filter, mem_range, mem_Ico, and_congr_left_iff, iff_and_self]\n  exact fun ha _ => succ_le_iff.mpr (pos_of_dvd_of_pos ha h.bot_lt)\n\n"}
{"name":"Nat.properDivisors.not_self_mem","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\n⊢ Not (Membership.mem n.properDivisors n)","decl":"theorem properDivisors.not_self_mem : ¬n ∈ properDivisors n := by simp [properDivisors]\n\n"}
{"name":"Nat.mem_properDivisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n m : Nat\n⊢ Iff (Membership.mem m.properDivisors n) (And (Dvd.dvd n m) (LT.lt n m))","decl":"@[simp]\ntheorem mem_properDivisors {m : ℕ} : n ∈ properDivisors m ↔ n ∣ m ∧ n < m := by\n  rcases eq_or_ne m 0 with (rfl | hm); · simp [properDivisors]\n  simp only [and_comm, ← filter_dvd_eq_properDivisors hm, mem_filter, mem_range]\n\n"}
{"name":"Nat.insert_self_properDivisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\nh : Ne n 0\n⊢ Eq (Insert.insert n n.properDivisors) n.divisors","decl":"theorem insert_self_properDivisors (h : n ≠ 0) : insert n (properDivisors n) = divisors n := by\n  rw [divisors, properDivisors, Ico_succ_right_eq_insert_Ico (one_le_iff_ne_zero.2 h),\n    Finset.filter_insert, if_pos (dvd_refl n)]\n\n"}
{"name":"Nat.cons_self_properDivisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\nh : Ne n 0\n⊢ Eq (Finset.cons n n.properDivisors ⋯) n.divisors","decl":"theorem cons_self_properDivisors (h : n ≠ 0) :\n    cons n (properDivisors n) properDivisors.not_self_mem = divisors n := by\n  rw [cons_eq_insert, insert_self_properDivisors h]\n\n"}
{"name":"Nat.mem_divisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n m : Nat\n⊢ Iff (Membership.mem m.divisors n) (And (Dvd.dvd n m) (Ne m 0))","decl":"@[simp]\ntheorem mem_divisors {m : ℕ} : n ∈ divisors m ↔ n ∣ m ∧ m ≠ 0 := by\n  rcases eq_or_ne m 0 with (rfl | hm); · simp [divisors]\n  simp only [hm, Ne, not_false_iff, and_true, ← filter_dvd_eq_divisors hm, mem_filter,\n    mem_range, and_iff_right_iff_imp, Nat.lt_succ_iff]\n  exact le_of_dvd hm.bot_lt\n\n"}
{"name":"Nat.one_mem_divisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\n⊢ Iff (Membership.mem n.divisors 1) (Ne n 0)","decl":"theorem one_mem_divisors : 1 ∈ divisors n ↔ n ≠ 0 := by simp\n\n"}
{"name":"Nat.mem_divisors_self","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\nh : Ne n 0\n⊢ Membership.mem n.divisors n","decl":"theorem mem_divisors_self (n : ℕ) (h : n ≠ 0) : n ∈ n.divisors :=\n  mem_divisors.2 ⟨dvd_rfl, h⟩\n\n"}
{"name":"Nat.dvd_of_mem_divisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n m : Nat\nh : Membership.mem m.divisors n\n⊢ Dvd.dvd n m","decl":"theorem dvd_of_mem_divisors {m : ℕ} (h : n ∈ divisors m) : n ∣ m := by\n  cases m\n  · apply dvd_zero\n  · simp [mem_divisors.1 h]\n\n"}
{"name":"Nat.mem_divisorsAntidiagonal","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\nx : Prod Nat Nat\n⊢ Iff (Membership.mem n.divisorsAntidiagonal x) (And (Eq (HMul.hMul x.1 x.2) n) (Ne n 0))","decl":"@[simp]\ntheorem mem_divisorsAntidiagonal {x : ℕ × ℕ} :\n    x ∈ divisorsAntidiagonal n ↔ x.fst * x.snd = n ∧ n ≠ 0 := by\n  simp only [divisorsAntidiagonal, Finset.mem_Ico, Ne, Finset.mem_filter, Finset.mem_product]\n  rw [and_comm]\n  apply and_congr_right\n  rintro rfl\n  constructor <;> intro h\n  · contrapose! h\n    simp [h]\n  · rw [Nat.lt_add_one_iff, Nat.lt_add_one_iff]\n    rw [mul_eq_zero, not_or] at h\n    simp only [succ_le_of_lt (Nat.pos_of_ne_zero h.1), succ_le_of_lt (Nat.pos_of_ne_zero h.2),\n      true_and]\n    exact\n      ⟨Nat.le_mul_of_pos_right _ (Nat.pos_of_ne_zero h.2),\n        Nat.le_mul_of_pos_left _ (Nat.pos_of_ne_zero h.1)⟩\n\n"}
{"name":"Nat.ne_zero_of_mem_divisorsAntidiagonal","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\np : Prod Nat Nat\nhp : Membership.mem n.divisorsAntidiagonal p\n⊢ And (Ne p.1 0) (Ne p.2 0)","decl":"lemma ne_zero_of_mem_divisorsAntidiagonal {p : ℕ × ℕ} (hp : p ∈ n.divisorsAntidiagonal) :\n    p.1 ≠ 0 ∧ p.2 ≠ 0 := by\n  obtain ⟨hp₁, hp₂⟩ := Nat.mem_divisorsAntidiagonal.mp hp\n  exact mul_ne_zero_iff.mp (hp₁.symm ▸ hp₂)\n\n"}
{"name":"Nat.left_ne_zero_of_mem_divisorsAntidiagonal","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\np : Prod Nat Nat\nhp : Membership.mem n.divisorsAntidiagonal p\n⊢ Ne p.1 0","decl":"lemma left_ne_zero_of_mem_divisorsAntidiagonal {p : ℕ × ℕ} (hp : p ∈ n.divisorsAntidiagonal) :\n    p.1 ≠ 0 :=\n  (ne_zero_of_mem_divisorsAntidiagonal hp).1\n\n"}
{"name":"Nat.right_ne_zero_of_mem_divisorsAntidiagonal","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\np : Prod Nat Nat\nhp : Membership.mem n.divisorsAntidiagonal p\n⊢ Ne p.2 0","decl":"lemma right_ne_zero_of_mem_divisorsAntidiagonal {p : ℕ × ℕ} (hp : p ∈ n.divisorsAntidiagonal) :\n    p.2 ≠ 0 :=\n  (ne_zero_of_mem_divisorsAntidiagonal hp).2\n\n"}
{"name":"Nat.divisor_le","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n m : Nat\na✝ : Membership.mem m.divisors n\n⊢ LE.le n m","decl":"theorem divisor_le {m : ℕ} : n ∈ divisors m → n ≤ m := by\n  cases' m with m\n  · simp\n  · simp only [mem_divisors, Nat.succ_ne_zero m, and_true, Ne, not_false_iff]\n    exact Nat.le_of_dvd (Nat.succ_pos m)\n\n"}
{"name":"Nat.divisors_subset_of_dvd","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n m : Nat\nhzero : Ne n 0\nh : Dvd.dvd m n\n⊢ HasSubset.Subset m.divisors n.divisors","decl":"theorem divisors_subset_of_dvd {m : ℕ} (hzero : n ≠ 0) (h : m ∣ n) : divisors m ⊆ divisors n :=\n  Finset.subset_iff.2 fun _x hx => Nat.mem_divisors.mpr ⟨(Nat.mem_divisors.mp hx).1.trans h, hzero⟩\n\n"}
{"name":"Nat.card_divisors_le_self","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\n⊢ LE.le n.divisors.card n","decl":"theorem card_divisors_le_self (n : ℕ) : #n.divisors ≤ n := calc\n  _ ≤ #(Ico 1 (n + 1)) := by\n    apply card_le_card\n    simp only [divisors, filter_subset]\n  _ = n := by rw [card_Ico, add_tsub_cancel_right]\n\n"}
{"name":"Nat.divisors_subset_properDivisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n m : Nat\nhzero : Ne n 0\nh : Dvd.dvd m n\nhdiff : Ne m n\n⊢ HasSubset.Subset m.divisors n.properDivisors","decl":"theorem divisors_subset_properDivisors {m : ℕ} (hzero : n ≠ 0) (h : m ∣ n) (hdiff : m ≠ n) :\n    divisors m ⊆ properDivisors n := by\n  apply Finset.subset_iff.2\n  intro x hx\n  exact\n    Nat.mem_properDivisors.2\n      ⟨(Nat.mem_divisors.1 hx).1.trans h,\n        lt_of_le_of_lt (divisor_le hx)\n          (lt_of_le_of_ne (divisor_le (Nat.mem_divisors.2 ⟨h, hzero⟩)) hdiff)⟩\n\n"}
{"name":"Nat.divisors_filter_dvd_of_dvd","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n m : Nat\nhn : Ne n 0\nhm : Dvd.dvd m n\n⊢ Eq (Finset.filter (fun d => Dvd.dvd d m) n.divisors) m.divisors","decl":"lemma divisors_filter_dvd_of_dvd {n m : ℕ} (hn : n ≠ 0) (hm : m ∣ n) :\n    {d ∈ n.divisors | d ∣ m} = m.divisors := by\n  ext k\n  simp_rw [mem_filter, mem_divisors]\n  exact ⟨fun ⟨_, hkm⟩ ↦ ⟨hkm, ne_zero_of_dvd_ne_zero hn hm⟩, fun ⟨hk, _⟩ ↦ ⟨⟨hk.trans hm, hn⟩, hk⟩⟩\n\n"}
{"name":"Nat.divisors_zero","module":"Mathlib.NumberTheory.Divisors","initialProofState":"⊢ Eq (Nat.divisors 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem divisors_zero : divisors 0 = ∅ := by\n  ext\n  simp\n\n"}
{"name":"Nat.properDivisors_zero","module":"Mathlib.NumberTheory.Divisors","initialProofState":"⊢ Eq (Nat.properDivisors 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem properDivisors_zero : properDivisors 0 = ∅ := by\n  ext\n  simp\n\n"}
{"name":"Nat.nonempty_divisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\n⊢ Iff n.divisors.Nonempty (Ne n 0)","decl":"@[simp]\nlemma nonempty_divisors : (divisors n).Nonempty ↔ n ≠ 0 :=\n  ⟨fun ⟨m, hm⟩ hn ↦ by simp [hn] at hm, fun hn ↦ ⟨1, one_mem_divisors.2 hn⟩⟩\n\n"}
{"name":"Nat.divisors_eq_empty","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\n⊢ Iff (Eq n.divisors EmptyCollection.emptyCollection) (Eq n 0)","decl":"@[simp]\nlemma divisors_eq_empty : divisors n = ∅ ↔ n = 0 :=\n  not_nonempty_iff_eq_empty.symm.trans nonempty_divisors.not_left\n\n"}
{"name":"Nat.properDivisors_subset_divisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\n⊢ HasSubset.Subset n.properDivisors n.divisors","decl":"theorem properDivisors_subset_divisors : properDivisors n ⊆ divisors n :=\n  filter_subset_filter _ <| Ico_subset_Ico_right n.le_succ\n\n"}
{"name":"Nat.divisors_one","module":"Mathlib.NumberTheory.Divisors","initialProofState":"⊢ Eq (Nat.divisors 1) (Singleton.singleton 1)","decl":"@[simp]\ntheorem divisors_one : divisors 1 = {1} := by\n  ext\n  simp\n\n"}
{"name":"Nat.properDivisors_one","module":"Mathlib.NumberTheory.Divisors","initialProofState":"⊢ Eq (Nat.properDivisors 1) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem properDivisors_one : properDivisors 1 = ∅ := by rw [properDivisors, Ico_self, filter_empty]\n\n"}
{"name":"Nat.pos_of_mem_divisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n m : Nat\nh : Membership.mem n.divisors m\n⊢ LT.lt 0 m","decl":"theorem pos_of_mem_divisors {m : ℕ} (h : m ∈ n.divisors) : 0 < m := by\n  cases m\n  · rw [mem_divisors, zero_dvd_iff (a := n)] at h\n    cases h.2 h.1\n  apply Nat.succ_pos\n\n"}
{"name":"Nat.pos_of_mem_properDivisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n m : Nat\nh : Membership.mem n.properDivisors m\n⊢ LT.lt 0 m","decl":"theorem pos_of_mem_properDivisors {m : ℕ} (h : m ∈ n.properDivisors) : 0 < m :=\n  pos_of_mem_divisors (properDivisors_subset_divisors h)\n\n"}
{"name":"Nat.one_mem_properDivisors_iff_one_lt","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\n⊢ Iff (Membership.mem n.properDivisors 1) (LT.lt 1 n)","decl":"theorem one_mem_properDivisors_iff_one_lt : 1 ∈ n.properDivisors ↔ 1 < n := by\n  rw [mem_properDivisors, and_iff_right (one_dvd _)]\n\n"}
{"name":"Nat.sup_divisors_id","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\n⊢ Eq (n.divisors.sup id) n","decl":"@[simp]\nlemma sup_divisors_id (n : ℕ) : n.divisors.sup id = n := by\n  refine le_antisymm (Finset.sup_le fun _ ↦ divisor_le) ?_\n  rcases Decidable.eq_or_ne n 0 with rfl | hn\n  · apply zero_le\n  · exact Finset.le_sup (f := id) <| mem_divisors_self n hn\n\n"}
{"name":"Nat.one_lt_of_mem_properDivisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"m n : Nat\nh : Membership.mem n.properDivisors m\n⊢ LT.lt 1 n","decl":"lemma one_lt_of_mem_properDivisors {m n : ℕ} (h : m ∈ n.properDivisors) : 1 < n :=\n  lt_of_le_of_lt (pos_of_mem_properDivisors h) (mem_properDivisors.1 h).2\n\n"}
{"name":"Nat.one_lt_div_of_mem_properDivisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"m n : Nat\nh : Membership.mem n.properDivisors m\n⊢ LT.lt 1 (HDiv.hDiv n m)","decl":"lemma one_lt_div_of_mem_properDivisors {m n : ℕ} (h : m ∈ n.properDivisors) :\n    1 < n / m := by\n  obtain ⟨h_dvd, h_lt⟩ := mem_properDivisors.mp h\n  rwa [Nat.lt_div_iff_mul_lt' h_dvd, mul_one]\n\n"}
{"name":"Nat.mem_properDivisors_iff_exists","module":"Mathlib.NumberTheory.Divisors","initialProofState":"m n : Nat\nhn : Ne n 0\n⊢ Iff (Membership.mem n.properDivisors m) (Exists fun k => And (GT.gt k 1) (Eq n (HMul.hMul m k)))","decl":"/-- See also `Nat.mem_properDivisors`. -/\nlemma mem_properDivisors_iff_exists {m n : ℕ} (hn : n ≠ 0) :\n    m ∈ n.properDivisors ↔ ∃ k > 1, n = m * k := by\n  refine ⟨fun h ↦ ⟨n / m, one_lt_div_of_mem_properDivisors h, ?_⟩, ?_⟩\n  · exact (Nat.mul_div_cancel' (mem_properDivisors.mp h).1).symm\n  · rintro ⟨k, hk, rfl⟩\n    rw [mul_ne_zero_iff] at hn\n    exact mem_properDivisors.mpr ⟨⟨k, rfl⟩, lt_mul_of_one_lt_right (Nat.pos_of_ne_zero hn.1) hk⟩\n\n"}
{"name":"Nat.nonempty_properDivisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\n⊢ Iff n.properDivisors.Nonempty (LT.lt 1 n)","decl":"@[simp]\nlemma nonempty_properDivisors : n.properDivisors.Nonempty ↔ 1 < n :=\n  ⟨fun ⟨_m, hm⟩ ↦ one_lt_of_mem_properDivisors hm, fun hn ↦\n    ⟨1, one_mem_properDivisors_iff_one_lt.2 hn⟩⟩\n\n"}
{"name":"Nat.properDivisors_eq_empty","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\n⊢ Iff (Eq n.properDivisors EmptyCollection.emptyCollection) (LE.le n 1)","decl":"@[simp]\nlemma properDivisors_eq_empty : n.properDivisors = ∅ ↔ n ≤ 1 := by\n  rw [← not_nonempty_iff_eq_empty, nonempty_properDivisors, not_lt]\n\n"}
{"name":"Nat.divisorsAntidiagonal_zero","module":"Mathlib.NumberTheory.Divisors","initialProofState":"⊢ Eq (Nat.divisorsAntidiagonal 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem divisorsAntidiagonal_zero : divisorsAntidiagonal 0 = ∅ := by\n  ext\n  simp\n\n"}
{"name":"Nat.divisorsAntidiagonal_one","module":"Mathlib.NumberTheory.Divisors","initialProofState":"⊢ Eq (Nat.divisorsAntidiagonal 1) (Singleton.singleton { fst := 1, snd := 1 })","decl":"@[simp]\ntheorem divisorsAntidiagonal_one : divisorsAntidiagonal 1 = {(1, 1)} := by\n  ext\n  simp [mul_eq_one, Prod.ext_iff]\n\n-- The left hand side is not in simp normal form, see the variant below.\n"}
{"name":"Nat.swap_mem_divisorsAntidiagonal","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\nx : Prod Nat Nat\n⊢ Iff (Membership.mem n.divisorsAntidiagonal x.swap) (Membership.mem n.divisorsAntidiagonal x)","decl":"theorem swap_mem_divisorsAntidiagonal {x : ℕ × ℕ} :\n    x.swap ∈ divisorsAntidiagonal n ↔ x ∈ divisorsAntidiagonal n := by\n  rw [mem_divisorsAntidiagonal, mem_divisorsAntidiagonal, mul_comm, Prod.swap]\n\n"}
{"name":"Nat.swap_mem_divisorsAntidiagonal_aux","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\nx : Prod Nat Nat\n⊢ Iff (And (Eq (HMul.hMul x.2 x.1) n) (Not (Eq n 0))) (Membership.mem n.divisorsAntidiagonal x)","decl":"@[simp]\ntheorem swap_mem_divisorsAntidiagonal_aux {x : ℕ × ℕ} :\n    x.snd * x.fst = n ∧ ¬n = 0 ↔ x ∈ divisorsAntidiagonal n := by\n  rw [mem_divisorsAntidiagonal, mul_comm]\n\n"}
{"name":"Nat.fst_mem_divisors_of_mem_antidiagonal","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\nx : Prod Nat Nat\nh : Membership.mem n.divisorsAntidiagonal x\n⊢ Membership.mem n.divisors x.1","decl":"theorem fst_mem_divisors_of_mem_antidiagonal {x : ℕ × ℕ} (h : x ∈ divisorsAntidiagonal n) :\n    x.fst ∈ divisors n := by\n  rw [mem_divisorsAntidiagonal] at h\n  simp [Dvd.intro _ h.1, h.2]\n\n"}
{"name":"Nat.snd_mem_divisors_of_mem_antidiagonal","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\nx : Prod Nat Nat\nh : Membership.mem n.divisorsAntidiagonal x\n⊢ Membership.mem n.divisors x.2","decl":"theorem snd_mem_divisors_of_mem_antidiagonal {x : ℕ × ℕ} (h : x ∈ divisorsAntidiagonal n) :\n    x.snd ∈ divisors n := by\n  rw [mem_divisorsAntidiagonal] at h\n  simp [Dvd.intro_left _ h.1, h.2]\n\n"}
{"name":"Nat.map_swap_divisorsAntidiagonal","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\n⊢ Eq (Finset.map (Equiv.prodComm Nat Nat).toEmbedding n.divisorsAntidiagonal) n.divisorsAntidiagonal","decl":"@[simp]\ntheorem map_swap_divisorsAntidiagonal :\n    (divisorsAntidiagonal n).map (Equiv.prodComm _ _).toEmbedding = divisorsAntidiagonal n := by\n  rw [← coe_inj, coe_map, Equiv.coe_toEmbedding, Equiv.coe_prodComm,\n    Set.image_swap_eq_preimage_swap]\n  ext\n  exact swap_mem_divisorsAntidiagonal\n\n"}
{"name":"Nat.image_fst_divisorsAntidiagonal","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\n⊢ Eq (Finset.image Prod.fst n.divisorsAntidiagonal) n.divisors","decl":"@[simp]\ntheorem image_fst_divisorsAntidiagonal : (divisorsAntidiagonal n).image Prod.fst = divisors n := by\n  ext\n  simp [Dvd.dvd, @eq_comm _ n (_ * _)]\n\n"}
{"name":"Nat.image_snd_divisorsAntidiagonal","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\n⊢ Eq (Finset.image Prod.snd n.divisorsAntidiagonal) n.divisors","decl":"@[simp]\ntheorem image_snd_divisorsAntidiagonal : (divisorsAntidiagonal n).image Prod.snd = divisors n := by\n  rw [← map_swap_divisorsAntidiagonal, map_eq_image, image_image]\n  exact image_fst_divisorsAntidiagonal\n\n"}
{"name":"Nat.map_div_right_divisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\n⊢ Eq (Finset.map { toFun := fun d => { fst := d, snd := HDiv.hDiv n d }, inj' := ⋯ } n.divisors) n.divisorsAntidiagonal","decl":"theorem map_div_right_divisors :\n    n.divisors.map ⟨fun d => (d, n / d), fun _ _ => congr_arg Prod.fst⟩ =\n      n.divisorsAntidiagonal := by\n  ext ⟨d, nd⟩\n  simp only [mem_map, mem_divisorsAntidiagonal, Function.Embedding.coeFn_mk, mem_divisors,\n    Prod.ext_iff, exists_prop, and_left_comm, exists_eq_left]\n  constructor\n  · rintro ⟨⟨⟨k, rfl⟩, hn⟩, rfl⟩\n    rw [Nat.mul_div_cancel_left _ (left_ne_zero_of_mul hn).bot_lt]\n    exact ⟨rfl, hn⟩\n  · rintro ⟨rfl, hn⟩\n    exact ⟨⟨dvd_mul_right _ _, hn⟩, Nat.mul_div_cancel_left _ (left_ne_zero_of_mul hn).bot_lt⟩\n\n"}
{"name":"Nat.map_div_left_divisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\n⊢ Eq (Finset.map { toFun := fun d => { fst := HDiv.hDiv n d, snd := d }, inj' := ⋯ } n.divisors) n.divisorsAntidiagonal","decl":"theorem map_div_left_divisors :\n    n.divisors.map ⟨fun d => (n / d, d), fun _ _ => congr_arg Prod.snd⟩ =\n      n.divisorsAntidiagonal := by\n  apply Finset.map_injective (Equiv.prodComm _ _).toEmbedding\n  ext\n  rw [map_swap_divisorsAntidiagonal, ← map_div_right_divisors, Finset.map_map]\n  simp\n\n"}
{"name":"Nat.sum_divisors_eq_sum_properDivisors_add_self","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\n⊢ Eq (n.divisors.sum fun i => i) (HAdd.hAdd (n.properDivisors.sum fun i => i) n)","decl":"theorem sum_divisors_eq_sum_properDivisors_add_self :\n    ∑ i ∈ divisors n, i = (∑ i ∈ properDivisors n, i) + n := by\n  rcases Decidable.eq_or_ne n 0 with (rfl | hn)\n  · simp\n  · rw [← cons_self_properDivisors hn, Finset.sum_cons, add_comm]\n\n"}
{"name":"Nat.perfect_iff_sum_properDivisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\nh : LT.lt 0 n\n⊢ Iff n.Perfect (Eq (n.properDivisors.sum fun i => i) n)","decl":"theorem perfect_iff_sum_properDivisors (h : 0 < n) : Perfect n ↔ ∑ i ∈ properDivisors n, i = n :=\n  and_iff_left h\n\n"}
{"name":"Nat.perfect_iff_sum_divisors_eq_two_mul","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\nh : LT.lt 0 n\n⊢ Iff n.Perfect (Eq (n.divisors.sum fun i => i) (HMul.hMul 2 n))","decl":"theorem perfect_iff_sum_divisors_eq_two_mul (h : 0 < n) :\n    Perfect n ↔ ∑ i ∈ divisors n, i = 2 * n := by\n  rw [perfect_iff_sum_properDivisors h, sum_divisors_eq_sum_properDivisors_add_self, two_mul]\n  constructor <;> intro h\n  · rw [h]\n  · apply add_right_cancel h\n\n"}
{"name":"Nat.mem_divisors_prime_pow","module":"Mathlib.NumberTheory.Divisors","initialProofState":"p : Nat\npp : Nat.Prime p\nk x : Nat\n⊢ Iff (Membership.mem (HPow.hPow p k).divisors x) (Exists fun j => And (LE.le j k) (Eq x (HPow.hPow p j)))","decl":"theorem mem_divisors_prime_pow {p : ℕ} (pp : p.Prime) (k : ℕ) {x : ℕ} :\n    x ∈ divisors (p ^ k) ↔ ∃ j ≤ k, x = p ^ j := by\n  rw [mem_divisors, Nat.dvd_prime_pow pp, and_iff_left (ne_of_gt (pow_pos pp.pos k))]\n\n"}
{"name":"Nat.Prime.divisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"p : Nat\npp : Nat.Prime p\n⊢ Eq p.divisors (Insert.insert 1 (Singleton.singleton p))","decl":"theorem Prime.divisors {p : ℕ} (pp : p.Prime) : divisors p = {1, p} := by\n  ext\n  rw [mem_divisors, dvd_prime pp, and_iff_left pp.ne_zero, Finset.mem_insert, Finset.mem_singleton]\n\n"}
{"name":"Nat.Prime.properDivisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"p : Nat\npp : Nat.Prime p\n⊢ Eq p.properDivisors (Singleton.singleton 1)","decl":"theorem Prime.properDivisors {p : ℕ} (pp : p.Prime) : properDivisors p = {1} := by\n  rw [← erase_insert properDivisors.not_self_mem, insert_self_properDivisors pp.ne_zero,\n    pp.divisors, pair_comm, erase_insert fun con => pp.ne_one (mem_singleton.1 con)]\n\n"}
{"name":"Nat.divisors_prime_pow","module":"Mathlib.NumberTheory.Divisors","initialProofState":"p : Nat\npp : Nat.Prime p\nk : Nat\n⊢ Eq (HPow.hPow p k).divisors (Finset.map { toFun := fun x => HPow.hPow p x, inj' := ⋯ } (Finset.range (HAdd.hAdd k 1)))","decl":"theorem divisors_prime_pow {p : ℕ} (pp : p.Prime) (k : ℕ) :\n    divisors (p ^ k) = (Finset.range (k + 1)).map ⟨(p ^ ·), Nat.pow_right_injective pp.two_le⟩ := by\n  ext a\n  rw [mem_divisors_prime_pow pp]\n  simp [Nat.lt_succ, eq_comm]\n\n"}
{"name":"Nat.divisors_injective","module":"Mathlib.NumberTheory.Divisors","initialProofState":"⊢ Function.Injective Nat.divisors","decl":"theorem divisors_injective : Function.Injective divisors :=\n  Function.LeftInverse.injective sup_divisors_id\n\n"}
{"name":"Nat.divisors_inj","module":"Mathlib.NumberTheory.Divisors","initialProofState":"a b : Nat\n⊢ Iff (Eq a.divisors b.divisors) (Eq a b)","decl":"@[simp]\ntheorem divisors_inj {a b : ℕ} : a.divisors = b.divisors ↔ a = b :=\n  divisors_injective.eq_iff\n\n"}
{"name":"Nat.eq_properDivisors_of_subset_of_sum_eq_sum","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\ns : Finset Nat\nhsub : HasSubset.Subset s n.properDivisors\na✝ : Eq (s.sum fun x => x) (n.properDivisors.sum fun x => x)\n⊢ Eq s n.properDivisors","decl":"theorem eq_properDivisors_of_subset_of_sum_eq_sum {s : Finset ℕ} (hsub : s ⊆ n.properDivisors) :\n    ((∑ x ∈ s, x) = ∑ x ∈ n.properDivisors, x) → s = n.properDivisors := by\n  cases n\n  · rw [properDivisors_zero, subset_empty] at hsub\n    simp [hsub]\n  classical\n    rw [← sum_sdiff hsub]\n    intro h\n    apply Subset.antisymm hsub\n    rw [← sdiff_eq_empty_iff_subset]\n    contrapose h\n    rw [← Ne, ← nonempty_iff_ne_empty] at h\n    apply ne_of_lt\n    rw [← zero_add (∑ x ∈ s, x), ← add_assoc, add_zero]\n    apply add_lt_add_right\n    have hlt :=\n      sum_lt_sum_of_nonempty h fun x hx => pos_of_mem_properDivisors (sdiff_subset hx)\n    simp only [sum_const_zero] at hlt\n    apply hlt\n\n"}
{"name":"Nat.sum_properDivisors_dvd","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\nh : Dvd.dvd (n.properDivisors.sum fun x => x) n\n⊢ Or (Eq (n.properDivisors.sum fun x => x) 1) (Eq (n.properDivisors.sum fun x => x) n)","decl":"theorem sum_properDivisors_dvd (h : (∑ x ∈ n.properDivisors, x) ∣ n) :\n    ∑ x ∈ n.properDivisors, x = 1 ∨ ∑ x ∈ n.properDivisors, x = n := by\n  cases' n with n\n  · simp\n  · cases' n with n\n    · simp at h\n    · rw [or_iff_not_imp_right]\n      intro ne_n\n      have hlt : ∑ x ∈ n.succ.succ.properDivisors, x < n.succ.succ :=\n        lt_of_le_of_ne (Nat.le_of_dvd (Nat.succ_pos _) h) ne_n\n      symm\n      rw [← mem_singleton, eq_properDivisors_of_subset_of_sum_eq_sum (singleton_subset_iff.2\n        (mem_properDivisors.2 ⟨h, hlt⟩)) (sum_singleton _ _), mem_properDivisors]\n      exact ⟨one_dvd _, Nat.succ_lt_succ (Nat.succ_pos _)⟩\n\n"}
{"name":"Nat.Prime.prod_properDivisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\np : Nat\nf : Nat → α\nh : Nat.Prime p\n⊢ Eq (p.properDivisors.prod fun x => f x) (f 1)","decl":"@[to_additive (attr := simp)]\ntheorem Prime.prod_properDivisors {α : Type*} [CommMonoid α] {p : ℕ} {f : ℕ → α} (h : p.Prime) :\n    ∏ x ∈ p.properDivisors, f x = f 1 := by simp [h.properDivisors]\n\n"}
{"name":"Nat.Prime.sum_properDivisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"α : Type u_1\ninst✝ : AddCommMonoid α\np : Nat\nf : Nat → α\nh : Nat.Prime p\n⊢ Eq (p.properDivisors.sum fun x => f x) (f 1)","decl":"@[to_additive (attr := simp)]\ntheorem Prime.prod_properDivisors {α : Type*} [CommMonoid α] {p : ℕ} {f : ℕ → α} (h : p.Prime) :\n    ∏ x ∈ p.properDivisors, f x = f 1 := by simp [h.properDivisors]\n\n"}
{"name":"Nat.Prime.prod_divisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\np : Nat\nf : Nat → α\nh : Nat.Prime p\n⊢ Eq (p.divisors.prod fun x => f x) (HMul.hMul (f p) (f 1))","decl":"@[to_additive (attr := simp)]\ntheorem Prime.prod_divisors {α : Type*} [CommMonoid α] {p : ℕ} {f : ℕ → α} (h : p.Prime) :\n    ∏ x ∈ p.divisors, f x = f p * f 1 := by\n  rw [← cons_self_properDivisors h.ne_zero, prod_cons, h.prod_properDivisors]\n\n"}
{"name":"Nat.Prime.sum_divisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"α : Type u_1\ninst✝ : AddCommMonoid α\np : Nat\nf : Nat → α\nh : Nat.Prime p\n⊢ Eq (p.divisors.sum fun x => f x) (HAdd.hAdd (f p) (f 1))","decl":"@[to_additive (attr := simp)]\ntheorem Prime.prod_divisors {α : Type*} [CommMonoid α] {p : ℕ} {f : ℕ → α} (h : p.Prime) :\n    ∏ x ∈ p.divisors, f x = f p * f 1 := by\n  rw [← cons_self_properDivisors h.ne_zero, prod_cons, h.prod_properDivisors]\n\n"}
{"name":"Nat.properDivisors_eq_singleton_one_iff_prime","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\n⊢ Iff (Eq n.properDivisors (Singleton.singleton 1)) (Nat.Prime n)","decl":"theorem properDivisors_eq_singleton_one_iff_prime : n.properDivisors = {1} ↔ n.Prime := by\n  refine ⟨?_, ?_⟩\n  · intro h\n    refine Nat.prime_def.mpr ⟨?_, fun m hdvd => ?_⟩\n    · match n with\n      | 0 => contradiction\n      | 1 => contradiction\n      | Nat.succ (Nat.succ n) => simp [succ_le_succ]\n    · rw [← mem_singleton, ← h, mem_properDivisors]\n      have := Nat.le_of_dvd ?_ hdvd\n      · simpa [hdvd, this] using (le_iff_eq_or_lt.mp this).symm\n      · by_contra!\n        simp only [nonpos_iff_eq_zero.mp this, this] at h\n        contradiction\n  · exact fun h => Prime.properDivisors h\n\n"}
{"name":"Nat.sum_properDivisors_eq_one_iff_prime","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\n⊢ Iff (Eq (n.properDivisors.sum fun x => x) 1) (Nat.Prime n)","decl":"theorem sum_properDivisors_eq_one_iff_prime : ∑ x ∈ n.properDivisors, x = 1 ↔ n.Prime := by\n  cases' n with n\n  · simp [Nat.not_prime_zero]\n  · cases n\n    · simp [Nat.not_prime_one]\n    · rw [← properDivisors_eq_singleton_one_iff_prime]\n      refine ⟨fun h => ?_, fun h => h.symm ▸ sum_singleton _ _⟩\n      rw [@eq_comm (Finset ℕ) _ _]\n      apply\n        eq_properDivisors_of_subset_of_sum_eq_sum\n          (singleton_subset_iff.2\n            (one_mem_properDivisors_iff_one_lt.2 (succ_lt_succ (Nat.succ_pos _))))\n          ((sum_singleton _ _).trans h.symm)\n\n"}
{"name":"Nat.mem_properDivisors_prime_pow","module":"Mathlib.NumberTheory.Divisors","initialProofState":"p : Nat\npp : Nat.Prime p\nk x : Nat\n⊢ Iff (Membership.mem (HPow.hPow p k).properDivisors x) (Exists fun j => Exists fun x_1 => Eq x (HPow.hPow p j))","decl":"theorem mem_properDivisors_prime_pow {p : ℕ} (pp : p.Prime) (k : ℕ) {x : ℕ} :\n    x ∈ properDivisors (p ^ k) ↔ ∃ (j : ℕ) (_ : j < k), x = p ^ j := by\n  rw [mem_properDivisors, Nat.dvd_prime_pow pp, ← exists_and_right]\n  simp only [exists_prop, and_assoc]\n  apply exists_congr\n  intro a\n  constructor <;> intro h\n  · rcases h with ⟨_h_left, rfl, h_right⟩\n    rw [Nat.pow_lt_pow_iff_right pp.one_lt] at h_right\n    exact ⟨h_right, rfl⟩\n  · rcases h with ⟨h_left, rfl⟩\n    rw [Nat.pow_lt_pow_iff_right pp.one_lt]\n    simp [h_left, le_of_lt]\n\n"}
{"name":"Nat.properDivisors_prime_pow","module":"Mathlib.NumberTheory.Divisors","initialProofState":"p : Nat\npp : Nat.Prime p\nk : Nat\n⊢ Eq (HPow.hPow p k).properDivisors (Finset.map { toFun := fun x => HPow.hPow p x, inj' := ⋯ } (Finset.range k))","decl":"theorem properDivisors_prime_pow {p : ℕ} (pp : p.Prime) (k : ℕ) :\n    properDivisors (p ^ k) = (Finset.range k).map ⟨(p ^ ·), Nat.pow_right_injective pp.two_le⟩ := by\n  ext a\n  simp only [mem_properDivisors, Nat.isUnit_iff, mem_map, mem_range, Function.Embedding.coeFn_mk,\n    pow_eq]\n  have := mem_properDivisors_prime_pow pp k (x := a)\n  rw [mem_properDivisors] at this\n  rw [this]\n  refine ⟨?_, ?_⟩\n  · intro h; rcases h with ⟨j, hj, hap⟩; use j; tauto\n  · tauto\n\n"}
{"name":"Nat.sum_properDivisors_prime_nsmul","module":"Mathlib.NumberTheory.Divisors","initialProofState":"α : Type u_1\ninst✝ : AddCommMonoid α\nk p : Nat\nf : Nat → α\nh : Nat.Prime p\n⊢ Eq ((HPow.hPow p k).properDivisors.sum fun x => f x) ((Finset.range k).sum fun x => f (HPow.hPow p x))","decl":"@[to_additive (attr := simp)]\ntheorem prod_properDivisors_prime_pow {α : Type*} [CommMonoid α] {k p : ℕ} {f : ℕ → α}\n    (h : p.Prime) : (∏ x ∈ (p ^ k).properDivisors, f x) = ∏ x ∈ range k, f (p ^ x) := by\n  simp [h, properDivisors_prime_pow]\n\n"}
{"name":"Nat.prod_properDivisors_prime_pow","module":"Mathlib.NumberTheory.Divisors","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\nk p : Nat\nf : Nat → α\nh : Nat.Prime p\n⊢ Eq ((HPow.hPow p k).properDivisors.prod fun x => f x) ((Finset.range k).prod fun x => f (HPow.hPow p x))","decl":"@[to_additive (attr := simp)]\ntheorem prod_properDivisors_prime_pow {α : Type*} [CommMonoid α] {k p : ℕ} {f : ℕ → α}\n    (h : p.Prime) : (∏ x ∈ (p ^ k).properDivisors, f x) = ∏ x ∈ range k, f (p ^ x) := by\n  simp [h, properDivisors_prime_pow]\n\n"}
{"name":"Nat.prod_divisors_prime_pow","module":"Mathlib.NumberTheory.Divisors","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\nk p : Nat\nf : Nat → α\nh : Nat.Prime p\n⊢ Eq ((HPow.hPow p k).divisors.prod fun x => f x) ((Finset.range (HAdd.hAdd k 1)).prod fun x => f (HPow.hPow p x))","decl":"@[to_additive (attr := simp) sum_divisors_prime_pow]\ntheorem prod_divisors_prime_pow {α : Type*} [CommMonoid α] {k p : ℕ} {f : ℕ → α} (h : p.Prime) :\n    (∏ x ∈ (p ^ k).divisors, f x) = ∏ x ∈ range (k + 1), f (p ^ x) := by\n  simp [h, divisors_prime_pow]\n\n"}
{"name":"Nat.sum_divisors_prime_pow","module":"Mathlib.NumberTheory.Divisors","initialProofState":"α : Type u_1\ninst✝ : AddCommMonoid α\nk p : Nat\nf : Nat → α\nh : Nat.Prime p\n⊢ Eq ((HPow.hPow p k).divisors.sum fun x => f x) ((Finset.range (HAdd.hAdd k 1)).sum fun x => f (HPow.hPow p x))","decl":"@[to_additive (attr := simp) sum_divisors_prime_pow]\ntheorem prod_divisors_prime_pow {α : Type*} [CommMonoid α] {k p : ℕ} {f : ℕ → α} (h : p.Prime) :\n    (∏ x ∈ (p ^ k).divisors, f x) = ∏ x ∈ range (k + 1), f (p ^ x) := by\n  simp [h, divisors_prime_pow]\n\n"}
{"name":"Nat.prod_divisorsAntidiagonal","module":"Mathlib.NumberTheory.Divisors","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nf : Nat → Nat → M\nn : Nat\n⊢ Eq (n.divisorsAntidiagonal.prod fun i => f i.1 i.2) (n.divisors.prod fun i => f i (HDiv.hDiv n i))","decl":"@[to_additive]\ntheorem prod_divisorsAntidiagonal {M : Type*} [CommMonoid M] (f : ℕ → ℕ → M) {n : ℕ} :\n    ∏ i ∈ n.divisorsAntidiagonal, f i.1 i.2 = ∏ i ∈ n.divisors, f i (n / i) := by\n  rw [← map_div_right_divisors, Finset.prod_map]\n  rfl\n\n"}
{"name":"Nat.sum_divisorsAntidiagonal","module":"Mathlib.NumberTheory.Divisors","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nf : Nat → Nat → M\nn : Nat\n⊢ Eq (n.divisorsAntidiagonal.sum fun i => f i.1 i.2) (n.divisors.sum fun i => f i (HDiv.hDiv n i))","decl":"@[to_additive]\ntheorem prod_divisorsAntidiagonal {M : Type*} [CommMonoid M] (f : ℕ → ℕ → M) {n : ℕ} :\n    ∏ i ∈ n.divisorsAntidiagonal, f i.1 i.2 = ∏ i ∈ n.divisors, f i (n / i) := by\n  rw [← map_div_right_divisors, Finset.prod_map]\n  rfl\n\n"}
{"name":"Nat.prod_divisorsAntidiagonal'","module":"Mathlib.NumberTheory.Divisors","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nf : Nat → Nat → M\nn : Nat\n⊢ Eq (n.divisorsAntidiagonal.prod fun i => f i.1 i.2) (n.divisors.prod fun i => f (HDiv.hDiv n i) i)","decl":"@[to_additive]\ntheorem prod_divisorsAntidiagonal' {M : Type*} [CommMonoid M] (f : ℕ → ℕ → M) {n : ℕ} :\n    ∏ i ∈ n.divisorsAntidiagonal, f i.1 i.2 = ∏ i ∈ n.divisors, f (n / i) i := by\n  rw [← map_swap_divisorsAntidiagonal, Finset.prod_map]\n  exact prod_divisorsAntidiagonal fun i j => f j i\n\n"}
{"name":"Nat.sum_divisorsAntidiagonal'","module":"Mathlib.NumberTheory.Divisors","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nf : Nat → Nat → M\nn : Nat\n⊢ Eq (n.divisorsAntidiagonal.sum fun i => f i.1 i.2) (n.divisors.sum fun i => f (HDiv.hDiv n i) i)","decl":"@[to_additive]\ntheorem prod_divisorsAntidiagonal' {M : Type*} [CommMonoid M] (f : ℕ → ℕ → M) {n : ℕ} :\n    ∏ i ∈ n.divisorsAntidiagonal, f i.1 i.2 = ∏ i ∈ n.divisors, f (n / i) i := by\n  rw [← map_swap_divisorsAntidiagonal, Finset.prod_map]\n  exact prod_divisorsAntidiagonal fun i j => f j i\n\n"}
{"name":"Nat.primeFactors_eq_to_filter_divisors_prime","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\n⊢ Eq n.primeFactors (Finset.filter (fun p => Nat.Prime p) n.divisors)","decl":"/-- The factors of `n` are the prime divisors -/\ntheorem primeFactors_eq_to_filter_divisors_prime (n : ℕ) :\n    n.primeFactors = {p ∈ divisors n | p.Prime} := by\n  rcases n.eq_zero_or_pos with (rfl | hn)\n  · simp\n  · ext q\n    simpa [hn, hn.ne', mem_primeFactorsList] using and_comm\n\n"}
{"name":"Nat.primeFactors_filter_dvd_of_dvd","module":"Mathlib.NumberTheory.Divisors","initialProofState":"m n : Nat\nhn : Ne n 0\nhmn : Dvd.dvd m n\n⊢ Eq (Finset.filter (fun p => Dvd.dvd p m) n.primeFactors) m.primeFactors","decl":"lemma primeFactors_filter_dvd_of_dvd {m n : ℕ} (hn : n ≠ 0) (hmn : m ∣ n) :\n    {p ∈ n.primeFactors | p ∣ m} = m.primeFactors := by\n  simp_rw [primeFactors_eq_to_filter_divisors_prime, filter_comm,\n    divisors_filter_dvd_of_dvd hn hmn]\n\n"}
{"name":"Nat.image_div_divisors_eq_divisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"n : Nat\n⊢ Eq (Finset.image (fun x => HDiv.hDiv n x) n.divisors) n.divisors","decl":"@[simp]\ntheorem image_div_divisors_eq_divisors (n : ℕ) :\n    image (fun x : ℕ => n / x) n.divisors = n.divisors := by\n  by_cases hn : n = 0\n  · simp [hn]\n  ext a\n  constructor\n  · rw [mem_image]\n    rintro ⟨x, hx1, hx2⟩\n    rw [mem_divisors] at *\n    refine ⟨?_, hn⟩\n    rw [← hx2]\n    exact div_dvd_of_dvd hx1.1\n  · rw [mem_divisors, mem_image]\n    rintro ⟨h1, -⟩\n    exact ⟨n / a, mem_divisors.mpr ⟨div_dvd_of_dvd h1, hn⟩, Nat.div_div_self h1 hn⟩\n\n/- Porting note: Removed simp; simp_nf linter:\nLeft-hand side does not simplify, when using the simp lemma on itself.\nThis usually means that it will never apply. -/\n"}
{"name":"Nat.prod_div_divisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\nn : Nat\nf : Nat → α\n⊢ Eq (n.divisors.prod fun d => f (HDiv.hDiv n d)) (n.divisors.prod f)","decl":"@[to_additive sum_div_divisors]\ntheorem prod_div_divisors {α : Type*} [CommMonoid α] (n : ℕ) (f : ℕ → α) :\n    (∏ d ∈ n.divisors, f (n / d)) = n.divisors.prod f := by\n  by_cases hn : n = 0; · simp [hn]\n  rw [← prod_image]\n  · exact prod_congr (image_div_divisors_eq_divisors n) (by simp)\n  · intro x hx y hy h\n    rw [mem_divisors] at hx hy\n    exact (div_eq_iff_eq_of_dvd_dvd hn hx.1 hy.1).mp h\n\n"}
{"name":"Nat.sum_div_divisors","module":"Mathlib.NumberTheory.Divisors","initialProofState":"α : Type u_1\ninst✝ : AddCommMonoid α\nn : Nat\nf : Nat → α\n⊢ Eq (n.divisors.sum fun d => f (HDiv.hDiv n d)) (n.divisors.sum f)","decl":"@[to_additive sum_div_divisors]\ntheorem prod_div_divisors {α : Type*} [CommMonoid α] (n : ℕ) (f : ℕ → α) :\n    (∏ d ∈ n.divisors, f (n / d)) = n.divisors.prod f := by\n  by_cases hn : n = 0; · simp [hn]\n  rw [← prod_image]\n  · exact prod_congr (image_div_divisors_eq_divisors n) (by simp)\n  · intro x hx y hy h\n    rw [mem_divisors] at hx hy\n    exact (div_eq_iff_eq_of_dvd_dvd hn hx.1 hy.1).mp h\n\n"}
{"name":"Nat.disjoint_divisors_filter_isPrimePow","module":"Mathlib.NumberTheory.Divisors","initialProofState":"a b : Nat\nhab : a.Coprime b\n⊢ Disjoint (Finset.filter IsPrimePow a.divisors) (Finset.filter IsPrimePow b.divisors)","decl":"theorem disjoint_divisors_filter_isPrimePow {a b : ℕ} (hab : a.Coprime b) :\n    Disjoint (a.divisors.filter IsPrimePow) (b.divisors.filter IsPrimePow) := by\n  simp only [Finset.disjoint_left, Finset.mem_filter, and_imp, Nat.mem_divisors, not_and]\n  rintro n han _ha hn hbn _hb -\n  exact hn.ne_one (Nat.eq_one_of_dvd_coprimes hab han hbn)\n\n"}
