{"name":"Int.le_rfl","module":"Mathlib.Data.Int.Defs","initialProofState":"a : Int\n⊢ LE.le a a","decl":"protected lemma le_rfl : a ≤ a := a.le_refl\n"}
{"name":"Int.lt_or_lt_of_ne","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\na✝ : Ne a b\n⊢ Or (LT.lt a b) (LT.lt b a)","decl":"protected lemma lt_or_lt_of_ne : a ≠ b → a < b ∨ b < a := Int.lt_or_gt_of_ne\n"}
{"name":"Int.lt_or_le","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\n⊢ Or (LT.lt a b) (LE.le b a)","decl":"protected lemma lt_or_le (a b : ℤ) : a < b ∨ b ≤ a := by rw [← Int.not_lt]; exact em _\n"}
{"name":"Int.le_or_lt","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\n⊢ Or (LE.le a b) (LT.lt b a)","decl":"protected lemma le_or_lt (a b : ℤ) : a ≤ b ∨ b < a := (b.lt_or_le a).symm\n"}
{"name":"Int.lt_asymm","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\na✝ : LT.lt a b\n⊢ Not (LT.lt b a)","decl":"protected lemma lt_asymm : a < b → ¬ b < a := by rw [Int.not_lt]; exact Int.le_of_lt\n"}
{"name":"Int.le_of_eq","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\nhab : Eq a b\n⊢ LE.le a b","decl":"protected lemma le_of_eq (hab : a = b) : a ≤ b := by rw [hab]; exact Int.le_rfl\n"}
{"name":"Int.ge_of_eq","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\nhab : Eq a b\n⊢ LE.le b a","decl":"protected lemma ge_of_eq (hab : a = b) : b ≤ a := Int.le_of_eq hab.symm\n"}
{"name":"Int.le_antisymm_iff","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\n⊢ Iff (Eq a b) (And (LE.le a b) (LE.le b a))","decl":"protected lemma le_antisymm_iff : a = b ↔ a ≤ b ∧ b ≤ a :=\n  ⟨fun h ↦ ⟨Int.le_of_eq h, Int.ge_of_eq h⟩, fun h ↦ Int.le_antisymm h.1 h.2⟩\n"}
{"name":"Int.le_iff_eq_or_lt","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\n⊢ Iff (LE.le a b) (Or (Eq a b) (LT.lt a b))","decl":"protected lemma le_iff_eq_or_lt : a ≤ b ↔ a = b ∨ a < b := by\n  rw [Int.le_antisymm_iff, Int.lt_iff_le_not_le, ← and_or_left]; simp [em]\n\n"}
{"name":"Int.le_iff_lt_or_eq","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\n⊢ Iff (LE.le a b) (Or (LT.lt a b) (Eq a b))","decl":"protected lemma le_iff_lt_or_eq : a ≤ b ↔ a < b ∨ a = b := by rw [Int.le_iff_eq_or_lt, or_comm]\n\n"}
{"name":"Int.one_pos","module":"Mathlib.Data.Int.Defs","initialProofState":"⊢ LT.lt 0 1","decl":"protected lemma one_pos : 0 < (1 : Int) := Int.zero_lt_one\n\n"}
{"name":"Int.one_ne_zero","module":"Mathlib.Data.Int.Defs","initialProofState":"⊢ Ne 1 0","decl":"protected lemma one_ne_zero : (1 : ℤ) ≠ 0 := by decide\n\n"}
{"name":"Int.one_nonneg","module":"Mathlib.Data.Int.Defs","initialProofState":"⊢ LE.le 0 1","decl":"protected lemma one_nonneg : 0 ≤ (1 : ℤ) := Int.le_of_lt Int.zero_lt_one\n\n"}
{"name":"Int.zero_le_ofNat","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Nat\n⊢ LE.le 0 (Int.ofNat n)","decl":"lemma zero_le_ofNat (n : ℕ) : 0 ≤ ofNat n := @le.intro _ _ n (by rw [Int.zero_add]; rfl)\n\n"}
{"name":"Int.neg_eq_neg","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\nh : Eq (Neg.neg a) (Neg.neg b)\n⊢ Eq a b","decl":"protected theorem neg_eq_neg {a b : ℤ} (h : -a = -b) : a = b := Int.neg_inj.1 h\n\n-- We want to use these lemmas earlier than the lemmas simp can prove them with\n"}
{"name":"Int.neg_pos","module":"Mathlib.Data.Int.Defs","initialProofState":"a : Int\n⊢ Iff (LT.lt 0 (Neg.neg a)) (LT.lt a 0)","decl":"@[simp, nolint simpNF]\nprotected lemma neg_pos : 0 < -a ↔ a < 0 := ⟨Int.neg_of_neg_pos, Int.neg_pos_of_neg⟩\n\n"}
{"name":"Int.neg_nonneg","module":"Mathlib.Data.Int.Defs","initialProofState":"a : Int\n⊢ Iff (LE.le 0 (Neg.neg a)) (LE.le a 0)","decl":"@[simp, nolint simpNF]\nprotected lemma neg_nonneg : 0 ≤ -a ↔ a ≤ 0 := ⟨Int.nonpos_of_neg_nonneg, Int.neg_nonneg_of_nonpos⟩\n\n"}
{"name":"Int.neg_neg_iff_pos","module":"Mathlib.Data.Int.Defs","initialProofState":"a : Int\n⊢ Iff (LT.lt (Neg.neg a) 0) (LT.lt 0 a)","decl":"@[simp, nolint simpNF]\nprotected lemma neg_neg_iff_pos : -a < 0 ↔ 0 < a := ⟨Int.pos_of_neg_neg, Int.neg_neg_of_pos⟩\n\n"}
{"name":"Int.neg_nonpos_iff_nonneg","module":"Mathlib.Data.Int.Defs","initialProofState":"a : Int\n⊢ Iff (LE.le (Neg.neg a) 0) (LE.le 0 a)","decl":"@[simp, nolint simpNF]\nprotected lemma neg_nonpos_iff_nonneg : -a ≤ 0 ↔ 0 ≤ a :=\n  ⟨Int.nonneg_of_neg_nonpos, Int.neg_nonpos_of_nonneg⟩\n\n"}
{"name":"Int.sub_pos","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\n⊢ Iff (LT.lt 0 (HSub.hSub a b)) (LT.lt b a)","decl":"@[simp, nolint simpNF]\nprotected lemma sub_pos : 0 < a - b ↔ b < a := ⟨Int.lt_of_sub_pos, Int.sub_pos_of_lt⟩\n\n"}
{"name":"Int.sub_nonneg","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\n⊢ Iff (LE.le 0 (HSub.hSub a b)) (LE.le b a)","decl":"@[simp, nolint simpNF]\nprotected lemma sub_nonneg : 0 ≤ a - b ↔ b ≤ a := ⟨Int.le_of_sub_nonneg, Int.sub_nonneg_of_le⟩\n\n"}
{"name":"Int.instNontrivial","module":"Mathlib.Data.Int.Defs","initialProofState":"⊢ Nontrivial Int","decl":"instance instNontrivial : Nontrivial ℤ := ⟨⟨0, 1, Int.zero_ne_one⟩⟩\n\n"}
{"name":"Int.ofNat_add_out","module":"Mathlib.Data.Int.Defs","initialProofState":"m n : Nat\n⊢ Eq (HAdd.hAdd ↑m ↑n) ↑(HAdd.hAdd m n)","decl":"protected theorem ofNat_add_out (m n : ℕ) : ↑m + ↑n = (↑(m + n) : ℤ) := rfl\n\n"}
{"name":"Int.ofNat_mul_out","module":"Mathlib.Data.Int.Defs","initialProofState":"m n : Nat\n⊢ Eq (HMul.hMul ↑m ↑n) ↑(HMul.hMul m n)","decl":"protected theorem ofNat_mul_out (m n : ℕ) : ↑m * ↑n = (↑(m * n) : ℤ) := rfl\n\n"}
{"name":"Int.ofNat_add_one_out","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd (↑n) 1) ↑n.succ","decl":"protected theorem ofNat_add_one_out (n : ℕ) : ↑n + (1 : ℤ) = ↑(succ n) := rfl\n\n"}
{"name":"Int.ofNat_injective","module":"Mathlib.Data.Int.Defs","initialProofState":"⊢ Function.Injective Int.ofNat","decl":"@[simp] lemma ofNat_injective : Function.Injective ofNat := @Int.ofNat.inj\n\n"}
{"name":"Int.ofNat_eq_natCast","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Nat\n⊢ Eq (Int.ofNat n) ↑n","decl":"@[simp] lemma ofNat_eq_natCast (n : ℕ) : Int.ofNat n = n := rfl\n\n"}
{"name":"Int.natCast_inj","module":"Mathlib.Data.Int.Defs","initialProofState":"m n : Nat\n⊢ Iff (Eq ↑m ↑n) (Eq m n)","decl":"@[norm_cast] lemma natCast_inj {m n : ℕ} : (m : ℤ) = (n : ℤ) ↔ m = n := ofNat_inj\n\n"}
{"name":"Int.natAbs_cast","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Nat\n⊢ Eq (↑n).natAbs n","decl":"@[simp, norm_cast] lemma natAbs_cast (n : ℕ) : natAbs ↑n = n := rfl\n\n"}
{"name":"Int.natCast_sub","module":"Mathlib.Data.Int.Defs","initialProofState":"n m : Nat\na✝ : LE.le n m\n⊢ Eq (↑(HSub.hSub m n)) (HSub.hSub ↑m ↑n)","decl":"@[norm_cast]\nprotected lemma natCast_sub {n m : ℕ} : n ≤ m → (↑(m - n) : ℤ) = ↑m - ↑n := ofNat_sub\n\n-- We want to use this lemma earlier than the lemmas simp can prove it with\n"}
{"name":"Int.natCast_eq_zero","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Nat\n⊢ Iff (Eq (↑n) 0) (Eq n 0)","decl":"@[simp, nolint simpNF] lemma natCast_eq_zero {n : ℕ} : (n : ℤ) = 0 ↔ n = 0 := by omega\n\n"}
{"name":"Int.natCast_ne_zero","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Nat\n⊢ Iff (Ne (↑n) 0) (Ne n 0)","decl":"lemma natCast_ne_zero {n : ℕ} : (n : ℤ) ≠ 0 ↔ n ≠ 0 := by omega\n\n"}
{"name":"Int.natCast_ne_zero_iff_pos","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Nat\n⊢ Iff (Ne (↑n) 0) (LT.lt 0 n)","decl":"lemma natCast_ne_zero_iff_pos {n : ℕ} : (n : ℤ) ≠ 0 ↔ 0 < n := by omega\n\n-- We want to use this lemma earlier than the lemmas simp can prove it with\n"}
{"name":"Int.natCast_pos","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Nat\n⊢ Iff (LT.lt 0 ↑n) (LT.lt 0 n)","decl":"@[simp, nolint simpNF] lemma natCast_pos {n : ℕ} : (0 : ℤ) < n ↔ 0 < n := by omega\n\n"}
{"name":"Int.natCast_succ_pos","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Nat\n⊢ LT.lt 0 ↑n.succ","decl":"lemma natCast_succ_pos (n : ℕ) : 0 < (n.succ : ℤ) := natCast_pos.2 n.succ_pos\n\n-- We want to use this lemma earlier than the lemmas simp can prove it with\n"}
{"name":"Int.natCast_nonpos_iff","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Nat\n⊢ Iff (LE.le (↑n) 0) (Eq n 0)","decl":"@[simp, nolint simpNF] lemma natCast_nonpos_iff {n : ℕ} : (n : ℤ) ≤ 0 ↔ n = 0 := by omega\n\n"}
{"name":"Int.natCast_nonneg","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Nat\n⊢ LE.le 0 ↑n","decl":"lemma natCast_nonneg (n : ℕ) : 0 ≤ (n : ℤ) := ofNat_le.2 (Nat.zero_le _)\n\n"}
{"name":"Int.sign_natCast_add_one","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd (↑n) 1).sign 1","decl":"@[simp] lemma sign_natCast_add_one (n : ℕ) : sign (n + 1) = 1 := rfl\n\n"}
{"name":"Int.cast_id","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Int\n⊢ Eq (↑n) n","decl":"@[simp, norm_cast] lemma cast_id {n : ℤ} : Int.cast n = n := rfl\n\n"}
{"name":"Int.two_mul","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Int\n⊢ Eq (HMul.hMul 2 n) (HAdd.hAdd n n)","decl":"protected lemma two_mul : ∀ n : ℤ, 2 * n = n + n\n  | (n : ℕ) => by norm_cast; exact n.two_mul\n  | -[n+1] => by\n    change (2 : ℕ) * (_ : ℤ) = _\n    rw [Int.ofNat_mul_negSucc, Nat.two_mul, ofNat_add, Int.neg_add]\n    rfl\n\n"}
{"name":"Int.mul_le_mul_iff_of_pos_right","module":"Mathlib.Data.Int.Defs","initialProofState":"a b c : Int\nha : LT.lt 0 a\n⊢ Iff (LE.le (HMul.hMul b a) (HMul.hMul c a)) (LE.le b c)","decl":"protected lemma mul_le_mul_iff_of_pos_right (ha : 0 < a) : b * a ≤ c * a ↔ b ≤ c :=\n  ⟨(le_of_mul_le_mul_right · ha), (Int.mul_le_mul_of_nonneg_right · (Int.le_of_lt ha))⟩\n\n"}
{"name":"Int.mul_nonneg_iff_of_pos_right","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\nhb : LT.lt 0 b\n⊢ Iff (LE.le 0 (HMul.hMul a b)) (LE.le 0 a)","decl":"protected lemma mul_nonneg_iff_of_pos_right (hb : 0 < b) : 0 ≤ a * b ↔ 0 ≤ a := by\n  simpa using (Int.mul_le_mul_iff_of_pos_right hb : 0 * b ≤ a * b ↔ 0 ≤ a)\n\n"}
{"name":"Int.natCast_succ","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Nat\n⊢ Eq (↑n.succ) (↑n).succ","decl":"lemma natCast_succ (n : ℕ) : (Nat.succ n : ℤ) = Int.succ n := rfl\n\n"}
{"name":"Int.pred_succ","module":"Mathlib.Data.Int.Defs","initialProofState":"a : Int\n⊢ Eq a.succ.pred a","decl":"lemma pred_succ (a : ℤ) : pred (succ a) = a := Int.add_sub_cancel _ _\n\n"}
{"name":"Int.succ_pred","module":"Mathlib.Data.Int.Defs","initialProofState":"a : Int\n⊢ Eq a.pred.succ a","decl":"lemma succ_pred (a : ℤ) : succ (pred a) = a := Int.sub_add_cancel _ _\n\n"}
{"name":"Int.neg_succ","module":"Mathlib.Data.Int.Defs","initialProofState":"a : Int\n⊢ Eq (Neg.neg a.succ) (Neg.neg a).pred","decl":"lemma neg_succ (a : ℤ) : -succ a = pred (-a) := Int.neg_add\n\n"}
{"name":"Int.succ_neg_succ","module":"Mathlib.Data.Int.Defs","initialProofState":"a : Int\n⊢ Eq (Neg.neg a.succ).succ (Neg.neg a)","decl":"lemma succ_neg_succ (a : ℤ) : succ (-succ a) = -a := by rw [neg_succ, succ_pred]\n\n"}
{"name":"Int.neg_pred","module":"Mathlib.Data.Int.Defs","initialProofState":"a : Int\n⊢ Eq (Neg.neg a.pred) (Neg.neg a).succ","decl":"lemma neg_pred (a : ℤ) : -pred a = succ (-a) := by\n  rw [← Int.neg_eq_comm.mp (neg_succ (-a)), Int.neg_neg]\n\n"}
{"name":"Int.pred_neg_pred","module":"Mathlib.Data.Int.Defs","initialProofState":"a : Int\n⊢ Eq (Neg.neg a.pred).pred (Neg.neg a)","decl":"lemma pred_neg_pred (a : ℤ) : pred (-pred a) = -a := by rw [neg_pred, pred_succ]\n\n"}
{"name":"Int.pred_nat_succ","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Nat\n⊢ Eq (↑n.succ).pred ↑n","decl":"lemma pred_nat_succ (n : ℕ) : pred (Nat.succ n) = n := pred_succ n\n\n"}
{"name":"Int.neg_nat_succ","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Nat\n⊢ Eq (Neg.neg ↑n.succ) (Neg.neg ↑n).pred","decl":"lemma neg_nat_succ (n : ℕ) : -(Nat.succ n : ℤ) = pred (-n) := neg_succ n\n\n"}
{"name":"Int.succ_neg_natCast_succ","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Nat\n⊢ Eq (Neg.neg ↑n.succ).succ (Neg.neg ↑n)","decl":"lemma succ_neg_natCast_succ (n : ℕ) : succ (-Nat.succ n) = -n := succ_neg_succ n\n\n"}
{"name":"Int.natCast_pred_of_pos","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Nat\nh : LT.lt 0 n\n⊢ Eq (↑(HSub.hSub n 1)) (HSub.hSub (↑n) 1)","decl":"@[norm_cast] lemma natCast_pred_of_pos {n : ℕ} (h : 0 < n) : ((n - 1 : ℕ) : ℤ) = (n : ℤ) - 1 := by\n  cases n; cases h; simp [ofNat_succ]\n\n"}
{"name":"Int.lt_succ_self","module":"Mathlib.Data.Int.Defs","initialProofState":"a : Int\n⊢ LT.lt a a.succ","decl":"lemma lt_succ_self (a : ℤ) : a < succ a := by unfold succ; omega\n\n"}
{"name":"Int.pred_self_lt","module":"Mathlib.Data.Int.Defs","initialProofState":"a : Int\n⊢ LT.lt a.pred a","decl":"lemma pred_self_lt (a : ℤ) : pred a < a := by unfold pred; omega\n\n"}
{"name":"Int.le_add_one_iff","module":"Mathlib.Data.Int.Defs","initialProofState":"m n : Int\n⊢ Iff (LE.le m (HAdd.hAdd n 1)) (Or (LE.le m n) (Eq m (HAdd.hAdd n 1)))","decl":"lemma le_add_one_iff : m ≤ n + 1 ↔ m ≤ n ∨ m = n + 1 := by omega\n\n"}
{"name":"Int.sub_one_lt_iff","module":"Mathlib.Data.Int.Defs","initialProofState":"m n : Int\n⊢ Iff (LT.lt (HSub.hSub m 1) n) (LE.le m n)","decl":"lemma sub_one_lt_iff : m - 1 < n ↔ m ≤ n := by omega\n\n"}
{"name":"Int.le_sub_one_iff","module":"Mathlib.Data.Int.Defs","initialProofState":"m n : Int\n⊢ Iff (LE.le m (HSub.hSub n 1)) (LT.lt m n)","decl":"lemma le_sub_one_iff : m ≤ n - 1 ↔ m < n := by omega\n\n"}
{"name":"Int.add_le_iff_le_sub","module":"Mathlib.Data.Int.Defs","initialProofState":"a b c : Int\n⊢ Iff (LE.le (HAdd.hAdd a b) c) (LE.le a (HSub.hSub c b))","decl":"protected lemma add_le_iff_le_sub : a + b ≤ c ↔ a ≤ c - b := add_le_iff_le_sub ..\n"}
{"name":"Int.le_add_iff_sub_le","module":"Mathlib.Data.Int.Defs","initialProofState":"a b c : Int\n⊢ Iff (LE.le a (HAdd.hAdd b c)) (LE.le (HSub.hSub a c) b)","decl":"protected lemma le_add_iff_sub_le : a ≤ b + c ↔ a - c ≤ b := le_add_iff_sub_le ..\n"}
{"name":"Int.add_le_zero_iff_le_neg","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\n⊢ Iff (LE.le (HAdd.hAdd a b) 0) (LE.le a (Neg.neg b))","decl":"protected lemma add_le_zero_iff_le_neg : a + b ≤ 0 ↔ a ≤ - b := add_le_zero_iff_le_neg ..\n"}
{"name":"Int.add_le_zero_iff_le_neg'","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\n⊢ Iff (LE.le (HAdd.hAdd a b) 0) (LE.le b (Neg.neg a))","decl":"protected lemma add_le_zero_iff_le_neg' : a + b ≤ 0 ↔ b ≤ -a := add_le_zero_iff_le_neg' ..\n"}
{"name":"Int.add_nonnneg_iff_neg_le","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\n⊢ Iff (LE.le 0 (HAdd.hAdd a b)) (LE.le (Neg.neg b) a)","decl":"protected lemma add_nonnneg_iff_neg_le : 0 ≤ a + b ↔ -b ≤ a := add_nonnneg_iff_neg_le ..\n"}
{"name":"Int.add_nonnneg_iff_neg_le'","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\n⊢ Iff (LE.le 0 (HAdd.hAdd a b)) (LE.le (Neg.neg a) b)","decl":"protected lemma add_nonnneg_iff_neg_le' : 0 ≤ a + b ↔ -a ≤ b := add_nonnneg_iff_neg_le' ..\n\n"}
{"name":"Int.induction_on","module":"Mathlib.Data.Int.Defs","initialProofState":"p : Int → Prop\ni : Int\nhz : p 0\nhp : ∀ (i : Nat), p ↑i → p (HAdd.hAdd (↑i) 1)\nhn : ∀ (i : Nat), p (Neg.neg ↑i) → p (HSub.hSub (Neg.neg ↑i) 1)\n⊢ p i","decl":"@[elab_as_elim] protected lemma induction_on {p : ℤ → Prop} (i : ℤ)\n    (hz : p 0) (hp : ∀ i : ℕ, p i → p (i + 1)) (hn : ∀ i : ℕ, p (-i) → p (-i - 1)) : p i := by\n  induction i with\n  | ofNat i =>\n    induction i with\n    | zero => exact hz\n    | succ i ih => exact hp _ ih\n  | negSucc i =>\n    suffices ∀ n : ℕ, p (-n) from this (i + 1)\n    intro n; induction n with\n    | zero => simp [hz]\n    | succ n ih => convert hn _ ih using 1; simp [ofNat_succ, Int.neg_add, Int.sub_eq_add_neg]\n\n"}
{"name":"Int.inductionOn'_self","module":"Mathlib.Data.Int.Defs","initialProofState":"C : Int → Sort u_1\nb : Int\nH0 : C b\nHs : (k : Int) → LE.le b k → C k → C (HAdd.hAdd k 1)\nHp : (k : Int) → LE.le k b → C k → C (HSub.hSub k 1)\n⊢ Eq (b.inductionOn' b H0 Hs Hp) H0","decl":"lemma inductionOn'_self : b.inductionOn' b H0 Hs Hp = H0 :=\n  cast_eq_iff_heq.mpr <| .symm <| by rw [b.sub_self, ← cast_eq_iff_heq]; rfl\n\n"}
{"name":"Int.inductionOn'_add_one","module":"Mathlib.Data.Int.Defs","initialProofState":"C : Int → Sort u_1\nz b : Int\nH0 : C b\nHs : (k : Int) → LE.le b k → C k → C (HAdd.hAdd k 1)\nHp : (k : Int) → LE.le k b → C k → C (HSub.hSub k 1)\nhz : LE.le b z\n⊢ Eq ((HAdd.hAdd z 1).inductionOn' b H0 Hs Hp) (Hs z hz (z.inductionOn' b H0 Hs Hp))","decl":"lemma inductionOn'_add_one (hz : b ≤ z) :\n    (z + 1).inductionOn' b H0 Hs Hp = Hs z hz (z.inductionOn' b H0 Hs Hp) := by\n  apply cast_eq_iff_heq.mpr\n  lift z - b to ℕ using Int.sub_nonneg.mpr hz with zb hzb\n  rw [show z + 1 - b = zb + 1 by omega]\n  have : b + zb = z := by omega\n  subst this\n  convert cast_heq _ _\n  rw [Int.inductionOn', cast_eq_iff_heq, ← hzb]\n\n"}
{"name":"Int.inductionOn'_sub_one","module":"Mathlib.Data.Int.Defs","initialProofState":"C : Int → Sort u_1\nz b : Int\nH0 : C b\nHs : (k : Int) → LE.le b k → C k → C (HAdd.hAdd k 1)\nHp : (k : Int) → LE.le k b → C k → C (HSub.hSub k 1)\nhz : LE.le z b\n⊢ Eq ((HSub.hSub z 1).inductionOn' b H0 Hs Hp) (Hp z hz (z.inductionOn' b H0 Hs Hp))","decl":"lemma inductionOn'_sub_one (hz : z ≤ b) :\n    (z - 1).inductionOn' b H0 Hs Hp = Hp z hz (z.inductionOn' b H0 Hs Hp) := by\n  apply cast_eq_iff_heq.mpr\n  obtain ⟨n, hn⟩ := Int.eq_negSucc_of_lt_zero (show z - 1 - b < 0 by omega)\n  rw [hn]\n  obtain _|n := n\n  · change _ = -1 at hn\n    have : z = b := by omega\n    subst this; rw [inductionOn'_self]; exact heq_of_eq rfl\n  · have : z = b + -[n+1] := by rw [Int.negSucc_eq] at hn ⊢; omega\n    subst this\n    convert cast_heq _ _\n    rw [Int.inductionOn', cast_eq_iff_heq, show b + -[n+1] - b = -[n+1] by omega]\n\n"}
{"name":"Int.le_induction","module":"Mathlib.Data.Int.Defs","initialProofState":"P : Int → Prop\nm : Int\nh0 : P m\nh1 : ∀ (n : Int), LE.le m n → P n → P (HAdd.hAdd n 1)\nn : Int\na✝ : LE.le m n\n⊢ P n","decl":"/-- See `Int.inductionOn'` for an induction in both directions. -/\nprotected lemma le_induction {P : ℤ → Prop} {m : ℤ} (h0 : P m)\n    (h1 : ∀ n : ℤ, m ≤ n → P n → P (n + 1)) (n : ℤ) : m ≤ n → P n := by\n  refine Int.inductionOn' n m ?_ ?_ ?_\n  · intro\n    exact h0\n  · intro k hle hi _\n    exact h1 k hle (hi hle)\n  · intro k hle _ hle'\n    omega\n\n"}
{"name":"Int.le_induction_down","module":"Mathlib.Data.Int.Defs","initialProofState":"P : Int → Prop\nm : Int\nh0 : P m\nh1 : ∀ (n : Int), LE.le n m → P n → P (HSub.hSub n 1)\nn : Int\na✝ : LE.le n m\n⊢ P n","decl":"/-- See `Int.inductionOn'` for an induction in both directions. -/\nprotected theorem le_induction_down {P : ℤ → Prop} {m : ℤ} (h0 : P m)\n    (h1 : ∀ n : ℤ, n ≤ m → P n → P (n - 1)) (n : ℤ) : n ≤ m → P n :=\n  Int.inductionOn' n m (fun _ ↦ h0) (fun k hle _ hle' ↦ by omega)\n    fun k hle hi _ ↦ h1 k hle (hi hle)\n\n"}
{"name":"Int.strongRec_of_lt","module":"Mathlib.Data.Int.Defs","initialProofState":"m n : Int\nP : Int → Sort u_1\nlt : (n : Int) → LT.lt n m → P n\nge : (n : Int) → GE.ge n m → ((k : Int) → LT.lt k n → P k) → P n\nhn : LT.lt n m\n⊢ Eq (Int.strongRec lt ge n) (lt n hn)","decl":"lemma strongRec_of_lt (hn : n < m) : m.strongRec lt ge n = lt n hn := dif_pos _\n\n"}
{"name":"Int.strongRec_of_ge","module":"Mathlib.Data.Int.Defs","initialProofState":"m n : Int\nP : Int → Sort u_1\nlt : (n : Int) → LT.lt n m → P n\nge : (n : Int) → GE.ge n m → ((k : Int) → LT.lt k n → P k) → P n\nhn : LE.le m n\n⊢ Eq (Int.strongRec lt ge n) (ge n hn fun k x => Int.strongRec lt ge k)","decl":"lemma strongRec_of_ge :\n    ∀ hn : m ≤ n, m.strongRec lt ge n = ge n hn fun k _ ↦ m.strongRec lt ge k := by\n  refine m.strongRec (fun n hnm hmn ↦ (Int.not_lt.mpr hmn hnm).elim) (fun n _ ih hn ↦ ?_) n\n  rw [Int.strongRec, dif_neg (Int.not_lt.mpr hn)]\n  congr; revert ih\n  refine n.inductionOn' m (fun _ ↦ ?_) (fun k hmk ih' ih ↦ ?_) (fun k hkm ih' _ ↦ ?_) <;> ext l hl\n  · rw [inductionOn'_self, strongRec_of_lt hl]\n  · rw [inductionOn'_add_one hmk]; split_ifs with hlm\n    · rw [strongRec_of_lt hlm]\n    · rw [ih' fun l hl ↦ ih l (Int.lt_trans hl k.lt_succ), ih _ hl]\n  · rw [inductionOn'_sub_one hkm, ih']\n    exact fun l hlk hml ↦ (Int.not_lt.mpr hkm <| Int.lt_of_le_of_lt hml hlk).elim\n\n"}
{"name":"Int.natAbs_ofNat'","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Nat\n⊢ Eq (Int.ofNat n).natAbs n","decl":"@[simp] lemma natAbs_ofNat' (n : ℕ) : natAbs (ofNat n) = n := rfl\n\n"}
{"name":"Int.natAbs_add_of_nonneg","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\na✝¹ : LE.le 0 a\na✝ : LE.le 0 b\n⊢ Eq (HAdd.hAdd a b).natAbs (HAdd.hAdd a.natAbs b.natAbs)","decl":"lemma natAbs_add_of_nonneg : ∀ {a b : Int}, 0 ≤ a → 0 ≤ b → natAbs (a + b) = natAbs a + natAbs b\n  | ofNat _, ofNat _, _, _ => rfl\n\n"}
{"name":"Int.natAbs_add_of_nonpos","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\nha : LE.le a 0\nhb : LE.le b 0\n⊢ Eq (HAdd.hAdd a b).natAbs (HAdd.hAdd a.natAbs b.natAbs)","decl":"lemma natAbs_add_of_nonpos {a b : Int} (ha : a ≤ 0) (hb : b ≤ 0) :\n    natAbs (a + b) = natAbs a + natAbs b := by\n  omega\n\n"}
{"name":"Int.natAbs_surjective","module":"Mathlib.Data.Int.Defs","initialProofState":"⊢ Function.Surjective Int.natAbs","decl":"lemma natAbs_surjective : natAbs.Surjective := fun n => ⟨n, natAbs_ofNat n⟩\n\n"}
{"name":"Int.natAbs_pow","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Int\nk : Nat\n⊢ Eq (HPow.hPow n k).natAbs (HPow.hPow n.natAbs k)","decl":"lemma natAbs_pow (n : ℤ) (k : ℕ) : Int.natAbs (n ^ k) = Int.natAbs n ^ k := by\n  induction k with\n  | zero => rfl\n  | succ k ih => rw [Int.pow_succ, natAbs_mul, Nat.pow_succ, ih, Nat.mul_comm]\n\n"}
{"name":"Int.pow_right_injective","module":"Mathlib.Data.Int.Defs","initialProofState":"a : Int\nh : LT.lt 1 a.natAbs\n⊢ Function.Injective fun x => HPow.hPow a x","decl":"lemma pow_right_injective (h : 1 < a.natAbs) : ((a ^ ·) : ℕ → ℤ).Injective := by\n  refine (?_ : (natAbs ∘ (a ^ · : ℕ → ℤ)).Injective).of_comp\n  convert Nat.pow_right_injective h using 2\n  rw [Function.comp_apply, natAbs_pow]\n\n"}
{"name":"Int.natAbs_sq","module":"Mathlib.Data.Int.Defs","initialProofState":"x : Int\n⊢ Eq (HPow.hPow (↑x.natAbs) 2) (HPow.hPow x 2)","decl":"lemma natAbs_sq (x : ℤ) : (x.natAbs : ℤ) ^ 2 = x ^ 2 := by\n  simp [Int.pow_succ, Int.pow_zero, Int.natAbs_mul_self']\n\n"}
{"name":"Int.natAbs_pow_two","module":"Mathlib.Data.Int.Defs","initialProofState":"x : Int\n⊢ Eq (HPow.hPow (↑x.natAbs) 2) (HPow.hPow x 2)","decl":"alias natAbs_pow_two := natAbs_sq\n\n"}
{"name":"Int.sign_mul_self_eq_natAbs","module":"Mathlib.Data.Int.Defs","initialProofState":"a : Int\n⊢ Eq (HMul.hMul a.sign a) ↑a.natAbs","decl":"theorem sign_mul_self_eq_natAbs : ∀ a : Int, sign a * a = natAbs a\n  | 0      => rfl\n  | Nat.succ _ => Int.one_mul _\n  | -[_+1] => (Int.neg_eq_neg_one_mul _).symm\n\n"}
{"name":"Int.natCast_div","module":"Mathlib.Data.Int.Defs","initialProofState":"m n : Nat\n⊢ Eq (↑(HDiv.hDiv m n)) (HDiv.hDiv ↑m ↑n)","decl":"@[simp, norm_cast] lemma natCast_div (m n : ℕ) : ((m / n : ℕ) : ℤ) = m / n := rfl\n\n"}
{"name":"Int.natCast_ediv","module":"Mathlib.Data.Int.Defs","initialProofState":"m n : Nat\n⊢ Eq (↑(HDiv.hDiv m n)) ((↑m).ediv ↑n)","decl":"lemma natCast_ediv (m n : ℕ) : ((m / n : ℕ) : ℤ) = ediv m n := rfl\n\n"}
{"name":"Int.ediv_of_neg_of_pos","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\nHa : LT.lt a 0\nHb : LT.lt 0 b\n⊢ Eq (a.ediv b) (Neg.neg (HAdd.hAdd (HDiv.hDiv (HSub.hSub (Neg.neg a) 1) b) 1))","decl":"lemma ediv_of_neg_of_pos {a b : ℤ} (Ha : a < 0) (Hb : 0 < b) : ediv a b = -((-a - 1) / b + 1) :=\n  match a, b, eq_negSucc_of_lt_zero Ha, eq_succ_of_zero_lt Hb with\n  | _, _, ⟨m, rfl⟩, ⟨n, rfl⟩ => by\n    rw [show (- -[m+1] : ℤ) = (m + 1 : ℤ) by rfl]; rw [Int.add_sub_cancel]; rfl\n\n"}
{"name":"Int.natCast_mod","module":"Mathlib.Data.Int.Defs","initialProofState":"m n : Nat\n⊢ Eq (↑(HMod.hMod m n)) (HMod.hMod ↑m ↑n)","decl":"@[simp, norm_cast] lemma natCast_mod (m n : ℕ) : (↑(m % n) : ℤ) = ↑m % ↑n := rfl\n\n"}
{"name":"Int.add_emod_eq_add_mod_right","module":"Mathlib.Data.Int.Defs","initialProofState":"m n k i : Int\nH : Eq (HMod.hMod m n) (HMod.hMod k n)\n⊢ Eq (HMod.hMod (HAdd.hAdd m i) n) (HMod.hMod (HAdd.hAdd k i) n)","decl":"lemma add_emod_eq_add_mod_right {m n k : ℤ} (i : ℤ) (H : m % n = k % n) :\n    (m + i) % n = (k + i) % n := by rw [← emod_add_emod, ← emod_add_emod k, H]\n\n"}
{"name":"Int.neg_emod_two","module":"Mathlib.Data.Int.Defs","initialProofState":"i : Int\n⊢ Eq (HMod.hMod (Neg.neg i) 2) (HMod.hMod i 2)","decl":"@[simp] lemma neg_emod_two (i : ℤ) : -i % 2 = i % 2 := by omega\n\n"}
{"name":"Int.emod_two_eq_zero_or_one","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Int\n⊢ Or (Eq (HMod.hMod n 2) 0) (Eq (HMod.hMod n 2) 1)","decl":"lemma emod_two_eq_zero_or_one (n : ℤ) : n % 2 = 0 ∨ n % 2 = 1 := by omega\n\n"}
{"name":"Int.mul_dvd_mul","module":"Mathlib.Data.Int.Defs","initialProofState":"a b c d : Int\na✝¹ : Dvd.dvd a b\na✝ : Dvd.dvd c d\n⊢ Dvd.dvd (HMul.hMul a c) (HMul.hMul b d)","decl":"protected lemma mul_dvd_mul : a ∣ b → c ∣ d → a * c ∣ b * d\n  | ⟨e, he⟩, ⟨f, hf⟩ => ⟨e * f, by simp [he, hf, Int.mul_assoc, Int.mul_left_comm, Nat.mul_comm]⟩\n\n"}
{"name":"Int.mul_dvd_mul_left","module":"Mathlib.Data.Int.Defs","initialProofState":"b c a : Int\nh : Dvd.dvd b c\n⊢ Dvd.dvd (HMul.hMul a b) (HMul.hMul a c)","decl":"protected lemma mul_dvd_mul_left (a : ℤ) (h : b ∣ c) : a * b ∣ a * c := Int.mul_dvd_mul a.dvd_refl h\n\n"}
{"name":"Int.mul_dvd_mul_right","module":"Mathlib.Data.Int.Defs","initialProofState":"b c a : Int\nh : Dvd.dvd b c\n⊢ Dvd.dvd (HMul.hMul b a) (HMul.hMul c a)","decl":"protected lemma mul_dvd_mul_right (a : ℤ) (h : b ∣ c) : b * a ∣ c * a :=\n  Int.mul_dvd_mul h a.dvd_refl\n\n"}
{"name":"Int.dvd_mul_of_div_dvd","module":"Mathlib.Data.Int.Defs","initialProofState":"a b c : Int\nh : Dvd.dvd b a\nhdiv : Dvd.dvd (HDiv.hDiv a b) c\n⊢ Dvd.dvd a (HMul.hMul b c)","decl":"lemma dvd_mul_of_div_dvd (h : b ∣ a) (hdiv : a / b ∣ c) : a ∣ b * c := by\n  obtain ⟨e, rfl⟩ := hdiv\n  rw [← Int.mul_assoc, Int.mul_comm _ (a / b), Int.ediv_mul_cancel h]\n  exact Int.dvd_mul_right a e\n\n"}
{"name":"Int.div_dvd_iff_dvd_mul","module":"Mathlib.Data.Int.Defs","initialProofState":"a b c : Int\nh : Dvd.dvd b a\nhb : Ne b 0\n⊢ Iff (Dvd.dvd (HDiv.hDiv a b) c) (Dvd.dvd a (HMul.hMul b c))","decl":"@[simp] lemma div_dvd_iff_dvd_mul (h : b ∣ a) (hb : b ≠ 0) : a / b ∣ c ↔ a ∣ b * c :=\n  exists_congr <| fun d ↦ by\n  have := Int.dvd_trans (Int.dvd_mul_left _ _) (Int.mul_dvd_mul_left d h)\n  rw [eq_comm, Int.mul_comm, ← Int.mul_ediv_assoc d h, Int.ediv_eq_iff_eq_mul_right hb this,\n    Int.mul_comm, eq_comm]\n\n"}
{"name":"Int.mul_dvd_of_dvd_div","module":"Mathlib.Data.Int.Defs","initialProofState":"a b c : Int\nhcb : Dvd.dvd c b\nh : Dvd.dvd a (HDiv.hDiv b c)\n⊢ Dvd.dvd (HMul.hMul c a) b","decl":"lemma mul_dvd_of_dvd_div (hcb : c ∣ b) (h : a ∣ b / c) : c * a ∣ b :=\n  have ⟨d, hd⟩ := h\n  ⟨d, by simpa [Int.mul_comm, Int.mul_left_comm] using Int.eq_mul_of_ediv_eq_left hcb hd⟩\n\n"}
{"name":"Int.dvd_div_of_mul_dvd","module":"Mathlib.Data.Int.Defs","initialProofState":"a b c : Int\nh : Dvd.dvd (HMul.hMul a b) c\n⊢ Dvd.dvd b (HDiv.hDiv c a)","decl":"lemma dvd_div_of_mul_dvd (h : a * b ∣ c) : b ∣ c / a := by\n  obtain rfl | ha := eq_or_ne a 0\n  · simp\n  · obtain ⟨d, rfl⟩ := h\n    simp [Int.mul_assoc, ha]\n\n"}
{"name":"Int.dvd_div_iff_mul_dvd","module":"Mathlib.Data.Int.Defs","initialProofState":"a b c : Int\nhbc : Dvd.dvd c b\n⊢ Iff (Dvd.dvd a (HDiv.hDiv b c)) (Dvd.dvd (HMul.hMul c a) b)","decl":"@[simp] lemma dvd_div_iff_mul_dvd (hbc : c ∣ b) : a ∣ b / c ↔ c * a ∣ b :=\n  ⟨mul_dvd_of_dvd_div hbc, dvd_div_of_mul_dvd⟩\n\n"}
{"name":"Int.ediv_dvd_ediv","module":"Mathlib.Data.Int.Defs","initialProofState":"a b c : Int\na✝¹ : Dvd.dvd a b\na✝ : Dvd.dvd b c\n⊢ Dvd.dvd (HDiv.hDiv b a) (HDiv.hDiv c a)","decl":"lemma ediv_dvd_ediv : ∀ {a b c : ℤ}, a ∣ b → b ∣ c → b / a ∣ c / a\n  | a, _, _, ⟨b, rfl⟩, ⟨c, rfl⟩ =>\n    if az : a = 0 then by simp [az]\n    else by\n      rw [Int.mul_ediv_cancel_left _ az, Int.mul_assoc, Int.mul_ediv_cancel_left _ az]\n      apply Int.dvd_mul_right\n\n"}
{"name":"Int.exists_lt_and_lt_iff_not_dvd","module":"Mathlib.Data.Int.Defs","initialProofState":"n m : Int\nhn : LT.lt 0 n\n⊢ Iff (Exists fun k => And (LT.lt (HMul.hMul n k) m) (LT.lt m (HMul.hMul n (HAdd.hAdd k 1)))) (Not (Dvd.dvd n m))","decl":"/-- If `n > 0` then `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)`\n  for some `k`. -/\nlemma exists_lt_and_lt_iff_not_dvd (m : ℤ) (hn : 0 < n) :\n    (∃ k, n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m := by\n  refine ⟨?_, fun h ↦ ?_⟩\n  · rintro ⟨k, h1k, h2k⟩ ⟨l, rfl⟩\n    replace h1k := lt_of_mul_lt_mul_left h1k (by omega)\n    replace h2k := lt_of_mul_lt_mul_left h2k (by omega)\n    rw [Int.lt_add_one_iff, ← Int.not_lt] at h2k\n    exact h2k h1k\n  · rw [dvd_iff_emod_eq_zero, ← Ne] at h\n    rw [← emod_add_ediv m n]\n    refine ⟨m / n, Int.lt_add_of_pos_left _ ?_, ?_⟩\n    · have := emod_nonneg m (Int.ne_of_gt hn)\n      omega\n    · rw [Int.add_comm _ (1 : ℤ), Int.mul_add, Int.mul_one]\n      exact Int.add_lt_add_right (emod_lt_of_pos _ hn) _\n\n"}
{"name":"Int.natCast_dvd_natCast","module":"Mathlib.Data.Int.Defs","initialProofState":"m n : Nat\n⊢ Iff (Dvd.dvd ↑m ↑n) (Dvd.dvd m n)","decl":"@[norm_cast] lemma natCast_dvd_natCast {m n : ℕ} : (↑m : ℤ) ∣ ↑n ↔ m ∣ n where\n  mp := by\n    rintro ⟨a, h⟩\n    obtain rfl | hm := m.eq_zero_or_pos\n    · simpa using h\n    have ha : 0 ≤ a := Int.not_lt.1 fun ha ↦ by\n      simpa [← h, Int.not_lt.2 (Int.natCast_nonneg _)]\n        using Int.mul_neg_of_pos_of_neg (natCast_pos.2 hm) ha\n    lift a to ℕ using ha\n    norm_cast at h\n    exact ⟨a, h⟩\n  mpr := by rintro ⟨a, rfl⟩; simp [Int.dvd_mul_right]\n\n"}
{"name":"Int.natCast_dvd","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Int\nm : Nat\n⊢ Iff (Dvd.dvd (↑m) n) (Dvd.dvd m n.natAbs)","decl":"lemma natCast_dvd {m : ℕ} : (m : ℤ) ∣ n ↔ m ∣ n.natAbs := by\n  obtain hn | hn := natAbs_eq n <;> rw [hn] <;> simp [← natCast_dvd_natCast, Int.dvd_neg]\n\n"}
{"name":"Int.dvd_natCast","module":"Mathlib.Data.Int.Defs","initialProofState":"m : Int\nn : Nat\n⊢ Iff (Dvd.dvd m ↑n) (Dvd.dvd m.natAbs n)","decl":"lemma dvd_natCast {n : ℕ} : m ∣ (n : ℤ) ↔ m.natAbs ∣ n := by\n  obtain hn | hn := natAbs_eq m <;> rw [hn] <;> simp [← natCast_dvd_natCast, Int.neg_dvd]\n\n"}
{"name":"Int.natAbs_ediv","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\nH : Dvd.dvd b a\n⊢ Eq (HDiv.hDiv a b).natAbs (HDiv.hDiv a.natAbs b.natAbs)","decl":"lemma natAbs_ediv (a b : ℤ) (H : b ∣ a) : natAbs (a / b) = natAbs a / natAbs b := by\n  rcases Nat.eq_zero_or_pos (natAbs b) with (h | h)\n  · rw [natAbs_eq_zero.1 h]\n    simp [Int.ediv_zero]\n  calc\n    natAbs (a / b) = natAbs (a / b) * 1 := by rw [Nat.mul_one]\n    _ = natAbs (a / b) * (natAbs b / natAbs b) := by rw [Nat.div_self h]\n    _ = natAbs (a / b) * natAbs b / natAbs b := by rw [Nat.mul_div_assoc _ b.natAbs.dvd_refl]\n    _ = natAbs (a / b * b) / natAbs b := by rw [natAbs_mul (a / b) b]\n    _ = natAbs a / natAbs b := by rw [Int.ediv_mul_cancel H]\n\n"}
{"name":"Int.dvd_of_mul_dvd_mul_left","module":"Mathlib.Data.Int.Defs","initialProofState":"a m n : Int\nha : Ne a 0\nh : Dvd.dvd (HMul.hMul a m) (HMul.hMul a n)\n⊢ Dvd.dvd m n","decl":"lemma dvd_of_mul_dvd_mul_left (ha : a ≠ 0) (h : a * m ∣ a * n) : m ∣ n := by\n  obtain ⟨b, hb⟩ := h\n  rw [Int.mul_assoc, Int.mul_eq_mul_left_iff ha] at hb\n  exact ⟨_, hb⟩\n\n"}
{"name":"Int.dvd_of_mul_dvd_mul_right","module":"Mathlib.Data.Int.Defs","initialProofState":"a m n : Int\nha : Ne a 0\nh : Dvd.dvd (HMul.hMul m a) (HMul.hMul n a)\n⊢ Dvd.dvd m n","decl":"lemma dvd_of_mul_dvd_mul_right (ha : a ≠ 0) (h : m * a ∣ n * a) : m ∣ n :=\n  dvd_of_mul_dvd_mul_left ha (by simpa [Int.mul_comm] using h)\n\n"}
{"name":"Int.eq_mul_div_of_mul_eq_mul_of_dvd_left","module":"Mathlib.Data.Int.Defs","initialProofState":"a b c d : Int\nhb : Ne b 0\nhbc : Dvd.dvd b c\nh : Eq (HMul.hMul b a) (HMul.hMul c d)\n⊢ Eq a (HMul.hMul (HDiv.hDiv c b) d)","decl":"lemma eq_mul_div_of_mul_eq_mul_of_dvd_left (hb : b ≠ 0) (hbc : b ∣ c) (h : b * a = c * d) :\n    a = c / b * d := by\n  obtain ⟨k, rfl⟩ := hbc\n  rw [Int.mul_ediv_cancel_left _ hb]\n  rwa [Int.mul_assoc, Int.mul_eq_mul_left_iff hb] at h\n\n"}
{"name":"Int.eq_zero_of_dvd_of_natAbs_lt_natAbs","module":"Mathlib.Data.Int.Defs","initialProofState":"m n : Int\nhmn : Dvd.dvd m n\nhnm : LT.lt n.natAbs m.natAbs\n⊢ Eq n 0","decl":"/-- If an integer with larger absolute value divides an integer, it is zero. -/\nlemma eq_zero_of_dvd_of_natAbs_lt_natAbs (hmn : m ∣ n) (hnm : natAbs n < natAbs m) : n = 0 := by\n  rw [← natAbs_dvd, ← dvd_natAbs, natCast_dvd_natCast] at hmn\n  rw [← natAbs_eq_zero]\n  exact Nat.eq_zero_of_dvd_of_lt hmn hnm\n\n"}
{"name":"Int.eq_zero_of_dvd_of_nonneg_of_lt","module":"Mathlib.Data.Int.Defs","initialProofState":"m n : Int\nhm : LE.le 0 m\nhmn : LT.lt m n\nhnm : Dvd.dvd n m\n⊢ Eq m 0","decl":"lemma eq_zero_of_dvd_of_nonneg_of_lt (hm : 0 ≤ m) (hmn : m < n) (hnm : n ∣ m) : m = 0 :=\n  eq_zero_of_dvd_of_natAbs_lt_natAbs hnm (natAbs_lt_natAbs_of_nonneg_of_lt hm hmn)\n\n"}
{"name":"Int.eq_of_mod_eq_of_natAbs_sub_lt_natAbs","module":"Mathlib.Data.Int.Defs","initialProofState":"a b c : Int\nh1 : Eq (HMod.hMod a b) c\nh2 : LT.lt (HSub.hSub a c).natAbs b.natAbs\n⊢ Eq a c","decl":"/-- If two integers are congruent to a sufficiently large modulus, they are equal. -/\nlemma eq_of_mod_eq_of_natAbs_sub_lt_natAbs {a b c : ℤ} (h1 : a % b = c)\n    (h2 : natAbs (a - c) < natAbs b) : a = c :=\n  Int.eq_of_sub_eq_zero (eq_zero_of_dvd_of_natAbs_lt_natAbs (dvd_sub_of_emod_eq h1) h2)\n\n"}
{"name":"Int.ofNat_add_negSucc_of_ge","module":"Mathlib.Data.Int.Defs","initialProofState":"m n : Nat\nh : LE.le n.succ m\n⊢ Eq (HAdd.hAdd (Int.ofNat m) (Int.negSucc n)) (Int.ofNat (HSub.hSub m n.succ))","decl":"lemma ofNat_add_negSucc_of_ge {m n : ℕ} (h : n.succ ≤ m) :\n    ofNat m + -[n+1] = ofNat (m - n.succ) := by\n  rw [negSucc_eq, ofNat_eq_natCast, ofNat_eq_natCast, ← natCast_one, ← natCast_add,\n    ← Int.sub_eq_add_neg, ← Int.natCast_sub h]\n\n"}
{"name":"Int.natAbs_le_of_dvd_ne_zero","module":"Mathlib.Data.Int.Defs","initialProofState":"m n : Int\nhmn : Dvd.dvd m n\nhn : Ne n 0\n⊢ LE.le m.natAbs n.natAbs","decl":"lemma natAbs_le_of_dvd_ne_zero (hmn : m ∣ n) (hn : n ≠ 0) : natAbs m ≤ natAbs n :=\n  not_lt.mp (mt (eq_zero_of_dvd_of_natAbs_lt_natAbs hmn) hn)\n\n"}
{"name":"Int.natAbs_eq_of_dvd_dvd","module":"Mathlib.Data.Int.Defs","initialProofState":"m n : Int\nhmn : Dvd.dvd m n\nhnm : Dvd.dvd n m\n⊢ Eq m.natAbs n.natAbs","decl":"lemma natAbs_eq_of_dvd_dvd (hmn : m ∣ n) (hnm : n ∣ m) : natAbs m = natAbs n :=\n  Nat.dvd_antisymm (natAbs_dvd_natAbs.2 hmn) (natAbs_dvd_natAbs.2 hnm)\n\n"}
{"name":"Int.ediv_dvd_of_dvd","module":"Mathlib.Data.Int.Defs","initialProofState":"m n : Int\nhmn : Dvd.dvd m n\n⊢ Dvd.dvd (HDiv.hDiv n m) n","decl":"lemma ediv_dvd_of_dvd (hmn : m ∣ n) : n / m ∣ n := by\n  obtain rfl | hm := eq_or_ne m 0\n  · simpa using hmn\n  · obtain ⟨a, ha⟩ := hmn\n    simp [ha, Int.mul_ediv_cancel_left _ hm, Int.dvd_mul_left]\n\n"}
{"name":"Int.le_iff_pos_of_dvd","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\nha : LT.lt 0 a\nhab : Dvd.dvd a b\n⊢ Iff (LE.le a b) (LT.lt 0 b)","decl":"lemma le_iff_pos_of_dvd (ha : 0 < a) (hab : a ∣ b) : a ≤ b ↔ 0 < b :=\n  ⟨Int.lt_of_lt_of_le ha, (Int.le_of_dvd · hab)⟩\n\n"}
{"name":"Int.le_add_iff_lt_of_dvd_sub","module":"Mathlib.Data.Int.Defs","initialProofState":"a b c : Int\nha : LT.lt 0 a\nhab : Dvd.dvd a (HSub.hSub c b)\n⊢ Iff (LE.le (HAdd.hAdd a b) c) (LT.lt b c)","decl":"lemma le_add_iff_lt_of_dvd_sub (ha : 0 < a) (hab : a ∣ c - b) : a + b ≤ c ↔ b < c := by\n  rw [Int.add_le_iff_le_sub, ← Int.sub_pos, le_iff_pos_of_dvd ha hab]\n\n"}
{"name":"Int.sign_natCast_of_ne_zero","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Nat\nhn : Ne n 0\n⊢ Eq (↑n).sign 1","decl":"lemma sign_natCast_of_ne_zero {n : ℕ} (hn : n ≠ 0) : Int.sign n = 1 := sign_ofNat_of_nonzero hn\n\n"}
{"name":"Int.sign_add_eq_of_sign_eq","module":"Mathlib.Data.Int.Defs","initialProofState":"m n : Int\na✝ : Eq m.sign n.sign\n⊢ Eq (HAdd.hAdd m n).sign n.sign","decl":"lemma sign_add_eq_of_sign_eq : ∀ {m n : ℤ}, m.sign = n.sign → (m + n).sign = n.sign := by\n  have : (1 : ℤ) ≠ -1 := by decide\n  rintro ((_ | m) | m) ((_ | n) | n) <;> simp [this, this.symm, Int.negSucc_add_negSucc]\n  rw [Int.sign_eq_one_iff_pos]\n  omega\n\n"}
{"name":"Int.toNat_natCast","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Nat\n⊢ Eq (↑n).toNat n","decl":"@[simp] lemma toNat_natCast (n : ℕ) : toNat ↑n = n := rfl\n\n"}
{"name":"Int.toNat_natCast_add_one","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd (↑n) 1).toNat (HAdd.hAdd n 1)","decl":"@[simp] lemma toNat_natCast_add_one {n : ℕ} : ((n : ℤ) + 1).toNat = n + 1 := rfl\n\n"}
{"name":"Int.toNat_le","module":"Mathlib.Data.Int.Defs","initialProofState":"m : Int\nn : Nat\n⊢ Iff (LE.le m.toNat n) (LE.le m ↑n)","decl":"@[simp] lemma toNat_le {n : ℕ} : toNat m ≤ n ↔ m ≤ n := by\n  rw [ofNat_le.symm, toNat_eq_max, Int.max_le]; exact and_iff_left (ofNat_zero_le _)\n\n"}
{"name":"Int.lt_toNat","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Int\nm : Nat\n⊢ Iff (LT.lt m n.toNat) (LT.lt (↑m) n)","decl":"@[simp]\nlemma lt_toNat {m : ℕ} : m < toNat n ↔ (m : ℤ) < n := by rw [← Int.not_le, ← Nat.not_le, toNat_le]\n\n"}
{"name":"Int.toNat_le_toNat","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\nh : LE.le a b\n⊢ LE.le a.toNat b.toNat","decl":"lemma toNat_le_toNat {a b : ℤ} (h : a ≤ b) : toNat a ≤ toNat b := by\n  rw [toNat_le]; exact Int.le_trans h (self_le_toNat b)\n\n"}
{"name":"Int.toNat_lt_toNat","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\nhb : LT.lt 0 b\n⊢ Iff (LT.lt a.toNat b.toNat) (LT.lt a b)","decl":"lemma toNat_lt_toNat {a b : ℤ} (hb : 0 < b) : toNat a < toNat b ↔ a < b where\n  mp h := by cases a; exacts [lt_toNat.1 h, Int.lt_trans (neg_of_sign_eq_neg_one rfl) hb]\n  mpr h := by rw [lt_toNat]; cases a; exacts [h, hb]\n\n"}
{"name":"Int.lt_of_toNat_lt","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\nh : LT.lt a.toNat b.toNat\n⊢ LT.lt a b","decl":"lemma lt_of_toNat_lt {a b : ℤ} (h : toNat a < toNat b) : a < b :=\n  (toNat_lt_toNat <| lt_toNat.1 <| Nat.lt_of_le_of_lt (Nat.zero_le _) h).1 h\n\n"}
{"name":"Int.toNat_pred_coe_of_pos","module":"Mathlib.Data.Int.Defs","initialProofState":"i : Int\nh : LT.lt 0 i\n⊢ Eq (↑(HSub.hSub i.toNat 1)) (HSub.hSub i 1)","decl":"@[simp] lemma toNat_pred_coe_of_pos {i : ℤ} (h : 0 < i) : ((i.toNat - 1 : ℕ) : ℤ) = i - 1 := by\n  simp only [lt_toNat, Nat.cast_ofNat_Int, h, natCast_pred_of_pos, Int.le_of_lt h, toNat_of_nonneg]\n\n"}
{"name":"Int.toNat_eq_zero","module":"Mathlib.Data.Int.Defs","initialProofState":"n : Int\n⊢ Iff (Eq n.toNat 0) (LE.le n 0)","decl":"@[simp] lemma toNat_eq_zero : ∀ {n : ℤ}, n.toNat = 0 ↔ n ≤ 0\n  | (n : ℕ) => by simp\n  | -[n+1] => by simpa [toNat] using Int.le_of_lt (negSucc_lt_zero n)\n\n"}
{"name":"Int.toNat_sub_of_le","module":"Mathlib.Data.Int.Defs","initialProofState":"a b : Int\nh : LE.le b a\n⊢ Eq (↑(HSub.hSub a b).toNat) (HSub.hSub a b)","decl":"theorem toNat_sub_of_le {a b : ℤ} (h : b ≤ a) : (toNat (a - b) : ℤ) = a - b :=\n  Int.toNat_of_nonneg (Int.sub_nonneg_of_le h)\n\n"}
{"name":"Int.toNat_lt'","module":"Mathlib.Data.Int.Defs","initialProofState":"m : Int\nn : Nat\nhn : Ne n 0\n⊢ Iff (LT.lt m.toNat n) (LT.lt m ↑n)","decl":"lemma toNat_lt' {n : ℕ} (hn : n ≠ 0) : m.toNat < n ↔ m < n := by\n  rw [← toNat_lt_toNat, toNat_natCast]; omega\n\n"}
{"name":"Int.natMod_lt","module":"Mathlib.Data.Int.Defs","initialProofState":"m : Int\nn : Nat\nhn : Ne n 0\n⊢ LT.lt (m.natMod ↑n) n","decl":"lemma natMod_lt {n : ℕ} (hn : n ≠ 0) : m.natMod n < n :=\n  (toNat_lt' hn).2 <| emod_lt_of_pos _ <| by omega\n\n"}
{"name":"Int.pow_eq","module":"Mathlib.Data.Int.Defs","initialProofState":"m : Int\nn : Nat\n⊢ Eq (m.pow n) (HPow.hPow m n)","decl":"@[simp] lemma pow_eq (m : ℤ) (n : ℕ) : m.pow n = m ^ n := rfl\n\n"}
