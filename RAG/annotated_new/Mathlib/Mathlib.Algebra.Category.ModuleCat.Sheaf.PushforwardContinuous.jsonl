{"name":"SheafOfModules.pushforward_map_val","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.PushforwardContinuous","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nF : CategoryTheory.Functor C D\nS : CategoryTheory.Sheaf J RingCat\nR : CategoryTheory.Sheaf K RingCat\ninst✝¹ : F.IsContinuous J K\ninst✝ : F.IsContinuous J K\nφ : Quiver.Hom S ((F.sheafPushforwardContinuous RingCat J K).obj R)\nX✝ Y✝ : SheafOfModules R\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((SheafOfModules.pushforward φ).map f).val ((PresheafOfModules.pushforward φ.val).map f.val)","decl":"/-- The pushforward of sheaves of modules that is induced by a continuous functor `F`\nand a morphism of sheaves of rings `φ : S ⟶ (F.sheafPushforwardContinuous RingCat J K).obj R`. -/\n@[simps]\nnoncomputable def pushforward : SheafOfModules.{v} R ⥤ SheafOfModules.{v} S where\n  obj M :=\n    { val := (PresheafOfModules.pushforward φ.val).obj M.val\n      isSheaf := ((F.sheafPushforwardContinuous _ J K).obj ⟨_, M.isSheaf⟩).cond }\n  map f :=\n    { val := (PresheafOfModules.pushforward φ.val).map f.val }\n\n"}
{"name":"SheafOfModules.pushforward_obj_val","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.PushforwardContinuous","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nF : CategoryTheory.Functor C D\nS : CategoryTheory.Sheaf J RingCat\nR : CategoryTheory.Sheaf K RingCat\ninst✝¹ : F.IsContinuous J K\ninst✝ : F.IsContinuous J K\nφ : Quiver.Hom S ((F.sheafPushforwardContinuous RingCat J K).obj R)\nM : SheafOfModules R\n⊢ Eq ((SheafOfModules.pushforward φ).obj M).val ((PresheafOfModules.pushforward φ.val).obj M.val)","decl":"/-- The pushforward of sheaves of modules that is induced by a continuous functor `F`\nand a morphism of sheaves of rings `φ : S ⟶ (F.sheafPushforwardContinuous RingCat J K).obj R`. -/\n@[simps]\nnoncomputable def pushforward : SheafOfModules.{v} R ⥤ SheafOfModules.{v} S where\n  obj M :=\n    { val := (PresheafOfModules.pushforward φ.val).obj M.val\n      isSheaf := ((F.sheafPushforwardContinuous _ J K).obj ⟨_, M.isSheaf⟩).cond }\n  map f :=\n    { val := (PresheafOfModules.pushforward φ.val).map f.val }\n\n"}
