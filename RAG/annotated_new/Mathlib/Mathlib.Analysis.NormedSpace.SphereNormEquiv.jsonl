{"name":"homeomorphUnitSphereProd_apply_snd_coe","module":"Mathlib.Analysis.NormedSpace.SphereNormEquiv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nx : ↑(HasCompl.compl (Singleton.singleton 0))\n⊢ Eq (↑((homeomorphUnitSphereProd E) x).2) (Norm.norm ↑x)","decl":"/-- The natural homeomorphism between nonzero elements of a normed space `E`\nand `Metric.sphere (0 : E) 1 × Set.Ioi (0 : ℝ)`.\n\nThe forward map sends `⟨x, hx⟩` to `⟨‖x‖⁻¹ • x, ‖x‖⟩`,\nthe inverse map sends `(x, r)` to `r • x`.\n\nOne may think about it as generalization of polar coordinates to any normed space. -/\n@[simps apply_fst_coe apply_snd_coe symm_apply_coe]\nnoncomputable def homeomorphUnitSphereProd :\n    ({0}ᶜ : Set E) ≃ₜ (sphere (0 : E) 1 × Ioi (0 : ℝ)) where\n  toFun x := (⟨‖x.1‖⁻¹ • x.1, by\n    rw [mem_sphere_zero_iff_norm, norm_smul, norm_inv, norm_norm,\n      inv_mul_cancel₀ (norm_ne_zero_iff.2 x.2)]⟩, ⟨‖x.1‖, norm_pos_iff.2 x.2⟩)\n  invFun x := ⟨x.2.1 • x.1.1, smul_ne_zero x.2.2.out.ne' (ne_of_mem_sphere x.1.2 one_ne_zero)⟩\n  left_inv x := Subtype.eq <| by simp [smul_inv_smul₀ (norm_ne_zero_iff.2 x.2)]\n  right_inv\n  | (⟨x, hx⟩, ⟨r, hr⟩) => by\n    rw [mem_sphere_zero_iff_norm] at hx\n    rw [mem_Ioi] at hr\n    ext <;> simp [hx, norm_smul, hr.le, abs_of_pos hr, hr.ne']\n  continuous_toFun := by\n    refine .prod_mk (.codRestrict (.smul (.inv₀ ?_ ?_) ?_) _) ?_\n    · fun_prop\n    · simp\n    · fun_prop\n    · fun_prop\n  continuous_invFun := by apply Continuous.subtype_mk (by fun_prop)\n"}
{"name":"homeomorphUnitSphereProd_symm_apply_coe","module":"Mathlib.Analysis.NormedSpace.SphereNormEquiv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nx : Prod ↑(Metric.sphere 0 1) ↑(Set.Ioi 0)\n⊢ Eq (↑((homeomorphUnitSphereProd E).symm x)) (HSMul.hSMul ↑x.2 ↑x.1)","decl":"/-- The natural homeomorphism between nonzero elements of a normed space `E`\nand `Metric.sphere (0 : E) 1 × Set.Ioi (0 : ℝ)`.\n\nThe forward map sends `⟨x, hx⟩` to `⟨‖x‖⁻¹ • x, ‖x‖⟩`,\nthe inverse map sends `(x, r)` to `r • x`.\n\nOne may think about it as generalization of polar coordinates to any normed space. -/\n@[simps apply_fst_coe apply_snd_coe symm_apply_coe]\nnoncomputable def homeomorphUnitSphereProd :\n    ({0}ᶜ : Set E) ≃ₜ (sphere (0 : E) 1 × Ioi (0 : ℝ)) where\n  toFun x := (⟨‖x.1‖⁻¹ • x.1, by\n    rw [mem_sphere_zero_iff_norm, norm_smul, norm_inv, norm_norm,\n      inv_mul_cancel₀ (norm_ne_zero_iff.2 x.2)]⟩, ⟨‖x.1‖, norm_pos_iff.2 x.2⟩)\n  invFun x := ⟨x.2.1 • x.1.1, smul_ne_zero x.2.2.out.ne' (ne_of_mem_sphere x.1.2 one_ne_zero)⟩\n  left_inv x := Subtype.eq <| by simp [smul_inv_smul₀ (norm_ne_zero_iff.2 x.2)]\n  right_inv\n  | (⟨x, hx⟩, ⟨r, hr⟩) => by\n    rw [mem_sphere_zero_iff_norm] at hx\n    rw [mem_Ioi] at hr\n    ext <;> simp [hx, norm_smul, hr.le, abs_of_pos hr, hr.ne']\n  continuous_toFun := by\n    refine .prod_mk (.codRestrict (.smul (.inv₀ ?_ ?_) ?_) _) ?_\n    · fun_prop\n    · simp\n    · fun_prop\n    · fun_prop\n  continuous_invFun := by apply Continuous.subtype_mk (by fun_prop)\n"}
{"name":"homeomorphUnitSphereProd_apply_fst_coe","module":"Mathlib.Analysis.NormedSpace.SphereNormEquiv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nx : ↑(HasCompl.compl (Singleton.singleton 0))\n⊢ Eq (↑((homeomorphUnitSphereProd E) x).1) (HSMul.hSMul (Inv.inv (Norm.norm ↑x)) ↑x)","decl":"/-- The natural homeomorphism between nonzero elements of a normed space `E`\nand `Metric.sphere (0 : E) 1 × Set.Ioi (0 : ℝ)`.\n\nThe forward map sends `⟨x, hx⟩` to `⟨‖x‖⁻¹ • x, ‖x‖⟩`,\nthe inverse map sends `(x, r)` to `r • x`.\n\nOne may think about it as generalization of polar coordinates to any normed space. -/\n@[simps apply_fst_coe apply_snd_coe symm_apply_coe]\nnoncomputable def homeomorphUnitSphereProd :\n    ({0}ᶜ : Set E) ≃ₜ (sphere (0 : E) 1 × Ioi (0 : ℝ)) where\n  toFun x := (⟨‖x.1‖⁻¹ • x.1, by\n    rw [mem_sphere_zero_iff_norm, norm_smul, norm_inv, norm_norm,\n      inv_mul_cancel₀ (norm_ne_zero_iff.2 x.2)]⟩, ⟨‖x.1‖, norm_pos_iff.2 x.2⟩)\n  invFun x := ⟨x.2.1 • x.1.1, smul_ne_zero x.2.2.out.ne' (ne_of_mem_sphere x.1.2 one_ne_zero)⟩\n  left_inv x := Subtype.eq <| by simp [smul_inv_smul₀ (norm_ne_zero_iff.2 x.2)]\n  right_inv\n  | (⟨x, hx⟩, ⟨r, hr⟩) => by\n    rw [mem_sphere_zero_iff_norm] at hx\n    rw [mem_Ioi] at hr\n    ext <;> simp [hx, norm_smul, hr.le, abs_of_pos hr, hr.ne']\n  continuous_toFun := by\n    refine .prod_mk (.codRestrict (.smul (.inv₀ ?_ ?_) ?_) _) ?_\n    · fun_prop\n    · simp\n    · fun_prop\n    · fun_prop\n  continuous_invFun := by apply Continuous.subtype_mk (by fun_prop)\n"}
