{"name":"MvPolynomial.degrees_def","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\np : MvPolynomial σ R\n⊢ Eq p.degrees (p.support.sup fun s => Finsupp.toMultiset s)","decl":"theorem degrees_def [DecidableEq σ] (p : MvPolynomial σ R) :\n    p.degrees = p.support.sup fun s : σ →₀ ℕ => Finsupp.toMultiset s := by rw [degrees]; convert rfl\n\n"}
{"name":"MvPolynomial.degrees_monomial","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ns : Finsupp σ Nat\na : R\n⊢ LE.le ((MvPolynomial.monomial s) a).degrees (Finsupp.toMultiset s)","decl":"theorem degrees_monomial (s : σ →₀ ℕ) (a : R) : degrees (monomial s a) ≤ toMultiset s := by\n  classical\n    refine (supDegree_single s a).trans_le ?_\n    split_ifs\n    exacts [bot_le, le_rfl]\n\n"}
{"name":"MvPolynomial.degrees_monomial_eq","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ns : Finsupp σ Nat\na : R\nha : Ne a 0\n⊢ Eq ((MvPolynomial.monomial s) a).degrees (Finsupp.toMultiset s)","decl":"theorem degrees_monomial_eq (s : σ →₀ ℕ) (a : R) (ha : a ≠ 0) :\n    degrees (monomial s a) = toMultiset s := by\n  classical\n    exact (supDegree_single s a).trans (if_neg ha)\n\n"}
{"name":"MvPolynomial.degrees_C","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\na : R\n⊢ Eq (MvPolynomial.C a).degrees 0","decl":"theorem degrees_C (a : R) : degrees (C a : MvPolynomial σ R) = 0 :=\n  Multiset.le_zero.1 <| degrees_monomial _ _\n\n"}
{"name":"MvPolynomial.degrees_X'","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nn : σ\n⊢ LE.le (MvPolynomial.X n).degrees (Singleton.singleton n)","decl":"theorem degrees_X' (n : σ) : degrees (X n : MvPolynomial σ R) ≤ {n} :=\n  le_trans (degrees_monomial _ _) <| le_of_eq <| toMultiset_single _ _\n\n"}
{"name":"MvPolynomial.degrees_X","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\nn : σ\n⊢ Eq (MvPolynomial.X n).degrees (Singleton.singleton n)","decl":"@[simp]\ntheorem degrees_X [Nontrivial R] (n : σ) : degrees (X n : MvPolynomial σ R) = {n} :=\n  (degrees_monomial_eq _ (1 : R) one_ne_zero).trans (toMultiset_single _ _)\n\n"}
{"name":"MvPolynomial.degrees_zero","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.degrees 0) 0","decl":"@[simp]\ntheorem degrees_zero : degrees (0 : MvPolynomial σ R) = 0 := by\n  rw [← C_0]\n  exact degrees_C 0\n\n"}
{"name":"MvPolynomial.degrees_one","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.degrees 1) 0","decl":"@[simp]\ntheorem degrees_one : degrees (1 : MvPolynomial σ R) = 0 :=\n  degrees_C 1\n\n"}
{"name":"MvPolynomial.degrees_add_le","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\np q : MvPolynomial σ R\n⊢ LE.le (HAdd.hAdd p q).degrees (Max.max p.degrees q.degrees)","decl":"theorem degrees_add_le [DecidableEq σ] {p q : MvPolynomial σ R} :\n    (p + q).degrees ≤ p.degrees ⊔ q.degrees := by\n  simp_rw [degrees_def]; exact supDegree_add_le\n\n"}
{"name":"MvPolynomial.degrees_sum_le","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\nι : Type u_3\ninst✝ : DecidableEq σ\ns : Finset ι\nf : ι → MvPolynomial σ R\n⊢ LE.le (s.sum fun i => f i).degrees (s.sup fun i => (f i).degrees)","decl":"theorem degrees_sum_le {ι : Type*} [DecidableEq σ] (s : Finset ι) (f : ι → MvPolynomial σ R) :\n    (∑ i ∈ s, f i).degrees ≤ s.sup fun i => (f i).degrees := by\n  simp_rw [degrees_def]; exact supDegree_sum_le\n\n"}
{"name":"MvPolynomial.degrees_mul_le","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np q : MvPolynomial σ R\n⊢ LE.le (HMul.hMul p q).degrees (HAdd.hAdd p.degrees q.degrees)","decl":"theorem degrees_mul_le {p q : MvPolynomial σ R} : (p * q).degrees ≤ p.degrees + q.degrees := by\n  classical\n  simp_rw [degrees_def]\n  exact supDegree_mul_le (map_add _)\n\n"}
{"name":"MvPolynomial.degrees_prod_le","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nι : Type u_3\ns : Finset ι\nf : ι → MvPolynomial σ R\n⊢ LE.le (s.prod fun i => f i).degrees (s.sum fun i => (f i).degrees)","decl":"theorem degrees_prod_le {ι : Type*} {s : Finset ι} {f : ι → MvPolynomial σ R} :\n    (∏ i ∈ s, f i).degrees ≤ ∑ i ∈ s, (f i).degrees := by\n  classical exact supDegree_prod_le (map_zero _) (map_add _)\n\n"}
{"name":"MvPolynomial.degrees_pow_le","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\nn : Nat\n⊢ LE.le (HPow.hPow p n).degrees (HSMul.hSMul n p.degrees)","decl":"theorem degrees_pow_le {p : MvPolynomial σ R} {n : ℕ} : (p ^ n).degrees ≤ n • p.degrees := by\n  simpa using degrees_prod_le (s := .range n) (f := fun _ ↦ p)\n\n"}
{"name":"MvPolynomial.degrees_add","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\np q : MvPolynomial σ R\n⊢ LE.le (HAdd.hAdd p q).degrees (Max.max p.degrees q.degrees)","decl":"@[deprecated (since := \"2024-12-28\")] alias degrees_add := degrees_add_le\n"}
{"name":"MvPolynomial.degrees_sum","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\nι : Type u_3\ninst✝ : DecidableEq σ\ns : Finset ι\nf : ι → MvPolynomial σ R\n⊢ LE.le (s.sum fun i => f i).degrees (s.sup fun i => (f i).degrees)","decl":"@[deprecated (since := \"2024-12-28\")] alias degrees_sum := degrees_sum_le\n"}
{"name":"MvPolynomial.degrees_mul","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np q : MvPolynomial σ R\n⊢ LE.le (HMul.hMul p q).degrees (HAdd.hAdd p.degrees q.degrees)","decl":"@[deprecated (since := \"2024-12-28\")] alias degrees_mul := degrees_mul_le\n"}
{"name":"MvPolynomial.degrees_prod","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nι : Type u_3\ns : Finset ι\nf : ι → MvPolynomial σ R\n⊢ LE.le (s.prod fun i => f i).degrees (s.sum fun i => (f i).degrees)","decl":"@[deprecated (since := \"2024-12-28\")] alias degrees_prod := degrees_prod_le\n"}
{"name":"MvPolynomial.degrees_pow","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\nn : Nat\n⊢ LE.le (HPow.hPow p n).degrees (HSMul.hSMul n p.degrees)","decl":"@[deprecated (since := \"2024-12-28\")] alias degrees_pow := degrees_pow_le\n\n"}
{"name":"MvPolynomial.mem_degrees","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\ni : σ\n⊢ Iff (Membership.mem p.degrees i) (Exists fun d => And (Ne (MvPolynomial.coeff d p) 0) (Membership.mem d.support i))","decl":"theorem mem_degrees {p : MvPolynomial σ R} {i : σ} :\n    i ∈ p.degrees ↔ ∃ d, p.coeff d ≠ 0 ∧ i ∈ d.support := by\n  classical\n  simp only [degrees_def, Multiset.mem_sup, ← mem_support_iff, Finsupp.mem_toMultiset, exists_prop]\n\n"}
{"name":"MvPolynomial.le_degrees_add_left","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np q : MvPolynomial σ R\nh : Disjoint p.degrees q.degrees\n⊢ LE.le p.degrees (HAdd.hAdd p q).degrees","decl":"theorem le_degrees_add_left (h : Disjoint p.degrees q.degrees) : p.degrees ≤ (p + q).degrees := by\n  classical\n  apply Finset.sup_le\n  intro d hd\n  rw [Multiset.disjoint_iff_ne] at h\n  obtain rfl | h0 := eq_or_ne d 0\n  · rw [toMultiset_zero]; apply Multiset.zero_le\n  · refine Finset.le_sup_of_le (b := d) ?_ le_rfl\n    rw [mem_support_iff, coeff_add]\n    suffices q.coeff d = 0 by rwa [this, add_zero, coeff, ← Finsupp.mem_support_iff]\n    rw [Ne, ← Finsupp.support_eq_empty, ← Ne, ← Finset.nonempty_iff_ne_empty] at h0\n    obtain ⟨j, hj⟩ := h0\n    contrapose! h\n    rw [mem_support_iff] at hd\n    refine ⟨j, ?_, j, ?_, rfl⟩\n    all_goals rw [mem_degrees]; refine ⟨d, ?_, hj⟩; assumption\n\n"}
{"name":"MvPolynomial.le_degrees_add","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np q : MvPolynomial σ R\nh : Disjoint p.degrees q.degrees\n⊢ LE.le p.degrees (HAdd.hAdd p q).degrees","decl":"@[deprecated (since := \"2024-12-28\")] alias le_degrees_add := le_degrees_add_left\n\n"}
{"name":"MvPolynomial.le_degrees_add_right","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np q : MvPolynomial σ R\nh : Disjoint p.degrees q.degrees\n⊢ LE.le q.degrees (HAdd.hAdd p q).degrees","decl":"lemma le_degrees_add_right (h : Disjoint p.degrees q.degrees) : q.degrees ≤ (p + q).degrees := by\n  simpa [add_comm] using le_degrees_add_left h.symm\n\n"}
{"name":"MvPolynomial.degrees_add_of_disjoint","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\np q : MvPolynomial σ R\ninst✝ : DecidableEq σ\nh : Disjoint p.degrees q.degrees\n⊢ Eq (HAdd.hAdd p q).degrees (Union.union p.degrees q.degrees)","decl":"theorem degrees_add_of_disjoint [DecidableEq σ] (h : Disjoint p.degrees q.degrees) :\n    (p + q).degrees = p.degrees ∪ q.degrees :=\n  degrees_add_le.antisymm <| Multiset.union_le (le_degrees_add_left h) (le_degrees_add_right h)\n\n"}
{"name":"MvPolynomial.degrees_map_le","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nS : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\np : MvPolynomial σ R\ninst✝ : CommSemiring S\nf : RingHom R S\n⊢ LE.le ((MvPolynomial.map f) p).degrees p.degrees","decl":"lemma degrees_map_le [CommSemiring S] {f : R →+* S} : (map f p).degrees ≤ p.degrees := by\n  classical exact Finset.sup_mono <| support_map_subset ..\n\n"}
{"name":"MvPolynomial.degrees_map","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nS : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\np : MvPolynomial σ R\ninst✝ : CommSemiring S\nf : RingHom R S\n⊢ LE.le ((MvPolynomial.map f) p).degrees p.degrees","decl":"@[deprecated (since := \"2024-12-28\")] alias degrees_map := degrees_map_le\n\n"}
{"name":"MvPolynomial.degrees_rename","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\nτ : Type u_2\ninst✝ : CommSemiring R\nf : σ → τ\nφ : MvPolynomial σ R\n⊢ HasSubset.Subset ((MvPolynomial.rename f) φ).degrees (Multiset.map f φ.degrees)","decl":"theorem degrees_rename (f : σ → τ) (φ : MvPolynomial σ R) :\n    (rename f φ).degrees ⊆ φ.degrees.map f := by\n  classical\n  intro i\n  rw [mem_degrees, Multiset.mem_map]\n  rintro ⟨d, hd, hi⟩\n  obtain ⟨x, rfl, hx⟩ := coeff_rename_ne_zero _ _ _ hd\n  simp only [Finsupp.mapDomain, Finsupp.mem_support_iff] at hi\n  rw [sum_apply, Finsupp.sum] at hi\n  contrapose! hi\n  rw [Finset.sum_eq_zero]\n  intro j hj\n  simp only [exists_prop, mem_degrees] at hi\n  specialize hi j ⟨x, hx, hj⟩\n  rw [Finsupp.single_apply, if_neg hi]\n\n"}
{"name":"MvPolynomial.degrees_map_of_injective","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nS : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\np : MvPolynomial σ R\nf : RingHom R S\nhf : Function.Injective ⇑f\n⊢ Eq ((MvPolynomial.map f) p).degrees p.degrees","decl":"theorem degrees_map_of_injective [CommSemiring S] (p : MvPolynomial σ R) {f : R →+* S}\n    (hf : Injective f) : (map f p).degrees = p.degrees := by\n  simp only [degrees, MvPolynomial.support_map_of_injective _ hf]\n\n"}
{"name":"MvPolynomial.degrees_rename_of_injective","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\nτ : Type u_2\ninst✝ : CommSemiring R\np : MvPolynomial σ R\nf : σ → τ\nh : Function.Injective f\n⊢ Eq ((MvPolynomial.rename f) p).degrees (Multiset.map f p.degrees)","decl":"theorem degrees_rename_of_injective {p : MvPolynomial σ R} {f : σ → τ} (h : Function.Injective f) :\n    degrees (rename f p) = (degrees p).map f := by\n  classical\n  simp only [degrees, Multiset.map_finset_sup p.support Finsupp.toMultiset f h,\n    support_rename_of_injective h, Finset.sup_image]\n  refine Finset.sup_congr rfl fun x _ => ?_\n  exact (Finsupp.toMultiset_map _ _).symm\n\n"}
{"name":"MvPolynomial.degreeOf_def","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\nn : σ\np : MvPolynomial σ R\n⊢ Eq (MvPolynomial.degreeOf n p) (Multiset.count n p.degrees)","decl":"theorem degreeOf_def [DecidableEq σ] (n : σ) (p : MvPolynomial σ R) :\n    p.degreeOf n = p.degrees.count n := by rw [degreeOf]; convert rfl\n\n"}
{"name":"MvPolynomial.degreeOf_eq_sup","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nn : σ\nf : MvPolynomial σ R\n⊢ Eq (MvPolynomial.degreeOf n f) (f.support.sup fun m => m n)","decl":"theorem degreeOf_eq_sup (n : σ) (f : MvPolynomial σ R) :\n    degreeOf n f = f.support.sup fun m => m n := by\n  classical\n  rw [degreeOf_def, degrees, Multiset.count_finset_sup]\n  congr\n  ext\n  simp only [count_toMultiset]\n\n"}
{"name":"MvPolynomial.degreeOf_lt_iff","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nn : σ\nf : MvPolynomial σ R\nd : Nat\nh : LT.lt 0 d\n⊢ Iff (LT.lt (MvPolynomial.degreeOf n f) d) (∀ (m : Finsupp σ Nat), Membership.mem f.support m → LT.lt (m n) d)","decl":"theorem degreeOf_lt_iff {n : σ} {f : MvPolynomial σ R} {d : ℕ} (h : 0 < d) :\n    degreeOf n f < d ↔ ∀ m : σ →₀ ℕ, m ∈ f.support → m n < d := by\n  rwa [degreeOf_eq_sup, Finset.sup_lt_iff]\n\n"}
{"name":"MvPolynomial.degreeOf_le_iff","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nn : σ\nf : MvPolynomial σ R\nd : Nat\n⊢ Iff (LE.le (MvPolynomial.degreeOf n f) d) (∀ (m : Finsupp σ Nat), Membership.mem f.support m → LE.le (m n) d)","decl":"lemma degreeOf_le_iff {n : σ} {f : MvPolynomial σ R} {d : ℕ} :\n    degreeOf n f ≤ d ↔ ∀ m ∈ support f, m n ≤ d := by\n  rw [degreeOf_eq_sup, Finset.sup_le_iff]\n\n"}
{"name":"MvPolynomial.degreeOf_zero","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nn : σ\n⊢ Eq (MvPolynomial.degreeOf n 0) 0","decl":"@[simp]\ntheorem degreeOf_zero (n : σ) : degreeOf n (0 : MvPolynomial σ R) = 0 := by\n  classical simp only [degreeOf_def, degrees_zero, Multiset.count_zero]\n\n"}
{"name":"MvPolynomial.degreeOf_C","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\na : R\nx : σ\n⊢ Eq (MvPolynomial.degreeOf x (MvPolynomial.C a)) 0","decl":"@[simp]\ntheorem degreeOf_C (a : R) (x : σ) : degreeOf x (C a : MvPolynomial σ R) = 0 := by\n  classical simp [degreeOf_def, degrees_C]\n\n"}
{"name":"MvPolynomial.degreeOf_X","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : DecidableEq σ\ni j : σ\ninst✝ : Nontrivial R\n⊢ Eq (MvPolynomial.degreeOf i (MvPolynomial.X j)) (ite (Eq i j) 1 0)","decl":"theorem degreeOf_X [DecidableEq σ] (i j : σ) [Nontrivial R] :\n    degreeOf i (X j : MvPolynomial σ R) = if i = j then 1 else 0 := by\n  classical\n  by_cases c : i = j\n  · simp only [c, if_true, eq_self_iff_true, degreeOf_def, degrees_X, Multiset.count_singleton]\n  simp [c, if_false, degreeOf_def, degrees_X]\n\n"}
{"name":"MvPolynomial.degreeOf_add_le","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nn : σ\nf g : MvPolynomial σ R\n⊢ LE.le (MvPolynomial.degreeOf n (HAdd.hAdd f g)) (Max.max (MvPolynomial.degreeOf n f) (MvPolynomial.degreeOf n g))","decl":"theorem degreeOf_add_le (n : σ) (f g : MvPolynomial σ R) :\n    degreeOf n (f + g) ≤ max (degreeOf n f) (degreeOf n g) := by\n  simp_rw [degreeOf_eq_sup]; exact supDegree_add_le\n\n"}
{"name":"MvPolynomial.monomial_le_degreeOf","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ni : σ\nf : MvPolynomial σ R\nm : Finsupp σ Nat\nh_m : Membership.mem f.support m\n⊢ LE.le (m i) (MvPolynomial.degreeOf i f)","decl":"theorem monomial_le_degreeOf (i : σ) {f : MvPolynomial σ R} {m : σ →₀ ℕ} (h_m : m ∈ f.support) :\n    m i ≤ degreeOf i f := by\n  rw [degreeOf_eq_sup i]\n  apply Finset.le_sup h_m\n\n"}
{"name":"MvPolynomial.degreeOf_monomial_eq","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ns : Finsupp σ Nat\ni : σ\na : R\nha : Ne a 0\n⊢ Eq (MvPolynomial.degreeOf i ((MvPolynomial.monomial s) a)) (s i)","decl":"lemma degreeOf_monomial_eq (s : σ →₀ ℕ) (i : σ) {a : R} (ha : a ≠ 0) :\n    (monomial s a).degreeOf i = s i := by\n  classical rw [degreeOf_def, degrees_monomial_eq _ _ ha, Finsupp.count_toMultiset]\n\n-- TODO we can prove equality with `NoZeroDivisors R`\n"}
{"name":"MvPolynomial.degreeOf_mul_le","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ni : σ\nf g : MvPolynomial σ R\n⊢ LE.le (MvPolynomial.degreeOf i (HMul.hMul f g)) (HAdd.hAdd (MvPolynomial.degreeOf i f) (MvPolynomial.degreeOf i g))","decl":"theorem degreeOf_mul_le (i : σ) (f g : MvPolynomial σ R) :\n    degreeOf i (f * g) ≤ degreeOf i f + degreeOf i g := by\n  classical\n  simp only [degreeOf]\n  convert Multiset.count_le_of_le i degrees_mul_le\n  rw [Multiset.count_add]\n\n"}
{"name":"MvPolynomial.degreeOf_sum_le","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nι : Type u_3\ni : σ\ns : Finset ι\nf : ι → MvPolynomial σ R\n⊢ LE.le (MvPolynomial.degreeOf i (s.sum fun j => f j)) (s.sup fun j => MvPolynomial.degreeOf i (f j))","decl":"theorem degreeOf_sum_le {ι : Type*} (i : σ) (s : Finset ι) (f : ι → MvPolynomial σ R) :\n    degreeOf i (∑ j ∈ s, f j) ≤ s.sup fun j => degreeOf i (f j) := by\n  simp_rw [degreeOf_eq_sup]\n  exact supDegree_sum_le\n\n-- TODO we can prove equality with `NoZeroDivisors R`\n"}
{"name":"MvPolynomial.degreeOf_prod_le","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nι : Type u_3\ni : σ\ns : Finset ι\nf : ι → MvPolynomial σ R\n⊢ LE.le (MvPolynomial.degreeOf i (s.prod fun j => f j)) (s.sum fun j => MvPolynomial.degreeOf i (f j))","decl":"theorem degreeOf_prod_le {ι : Type*} (i : σ) (s : Finset ι) (f : ι → MvPolynomial σ R) :\n    degreeOf i (∏ j ∈ s, f j) ≤ ∑ j ∈ s, (f j).degreeOf i := by\n  simp_rw [degreeOf_eq_sup]\n  exact supDegree_prod_le (by simp only [coe_zero, Pi.zero_apply])\n    (fun _ _ => by simp only [coe_add, Pi.add_apply])\n\n-- TODO we can prove equality with `NoZeroDivisors R`\n"}
{"name":"MvPolynomial.degreeOf_pow_le","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ni : σ\np : MvPolynomial σ R\nn : Nat\n⊢ LE.le (MvPolynomial.degreeOf i (HPow.hPow p n)) (HMul.hMul n (MvPolynomial.degreeOf i p))","decl":"theorem degreeOf_pow_le (i : σ) (p : MvPolynomial σ R) (n : ℕ) :\n    degreeOf i (p ^ n) ≤ n * degreeOf i p := by\n  simpa using degreeOf_prod_le i (Finset.range n) (fun _ => p)\n\n"}
{"name":"MvPolynomial.degreeOf_mul_X_of_ne","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ni j : σ\nf : MvPolynomial σ R\nh : Ne i j\n⊢ Eq (MvPolynomial.degreeOf i (HMul.hMul f (MvPolynomial.X j))) (MvPolynomial.degreeOf i f)","decl":"theorem degreeOf_mul_X_of_ne {i j : σ} (f : MvPolynomial σ R) (h : i ≠ j) :\n    degreeOf i (f * X j) = degreeOf i f := by\n  classical\n  simp only [degreeOf_eq_sup i, support_mul_X, Finset.sup_map]\n  congr\n  ext\n  simp only [Finsupp.single, add_right_eq_self, addRightEmbedding_apply, coe_mk,\n    Pi.add_apply, comp_apply, ite_eq_right_iff, Finsupp.coe_add, Pi.single_eq_of_ne h]\n\n"}
{"name":"MvPolynomial.degreeOf_mul_X_ne","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ni j : σ\nf : MvPolynomial σ R\nh : Ne i j\n⊢ Eq (MvPolynomial.degreeOf i (HMul.hMul f (MvPolynomial.X j))) (MvPolynomial.degreeOf i f)","decl":"@[deprecated (since := \"2024-12-01\")] alias degreeOf_mul_X_ne := degreeOf_mul_X_of_ne\n\n"}
{"name":"MvPolynomial.degreeOf_mul_X_self","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nj : σ\nf : MvPolynomial σ R\n⊢ LE.le (MvPolynomial.degreeOf j (HMul.hMul f (MvPolynomial.X j))) (HAdd.hAdd (MvPolynomial.degreeOf j f) 1)","decl":"theorem degreeOf_mul_X_self (j : σ) (f : MvPolynomial σ R) :\n    degreeOf j (f * X j) ≤ degreeOf j f + 1 := by\n  classical\n  simp only [degreeOf]\n  apply (Multiset.count_le_of_le j degrees_mul_le).trans\n  simp only [Multiset.count_add, add_le_add_iff_left]\n  convert Multiset.count_le_of_le j <| degrees_X' j\n  rw [Multiset.count_singleton_self]\n\n"}
{"name":"MvPolynomial.degreeOf_mul_X_eq","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nj : σ\nf : MvPolynomial σ R\n⊢ LE.le (MvPolynomial.degreeOf j (HMul.hMul f (MvPolynomial.X j))) (HAdd.hAdd (MvPolynomial.degreeOf j f) 1)","decl":"@[deprecated (since := \"2024-12-01\")] alias degreeOf_mul_X_eq := degreeOf_mul_X_self\n\n"}
{"name":"MvPolynomial.degreeOf_mul_X_eq_degreeOf_add_one_iff","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nj : σ\nf : MvPolynomial σ R\n⊢ Iff (Eq (MvPolynomial.degreeOf j (HMul.hMul f (MvPolynomial.X j))) (HAdd.hAdd (MvPolynomial.degreeOf j f) 1)) (Ne f 0)","decl":"theorem degreeOf_mul_X_eq_degreeOf_add_one_iff (j : σ) (f : MvPolynomial σ R) :\n    degreeOf j (f * X j) = degreeOf j f + 1 ↔ f ≠ 0 := by\n  refine ⟨fun h => by by_contra ha; simp [ha] at h, fun h => ?_⟩\n  apply Nat.le_antisymm (degreeOf_mul_X_self j f)\n  have : (f.support.sup fun m ↦ m j) + 1 = (f.support.sup fun m ↦ (m j + 1)) :=\n    Finset.comp_sup_eq_sup_comp_of_nonempty @Nat.succ_le_succ (support_nonempty.mpr h)\n  simp only [degreeOf_eq_sup, support_mul_X, this]\n  apply Finset.sup_le\n  intro x hx\n  simp only [Finset.sup_map, bot_eq_zero', add_pos_iff, zero_lt_one, or_true, Finset.le_sup_iff]\n  use x\n  simpa using mem_support_iff.mp hx\n\n"}
{"name":"MvPolynomial.degreeOf_C_mul_le","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\ni : σ\nc : R\n⊢ LE.le (MvPolynomial.degreeOf i (HMul.hMul (MvPolynomial.C c) p)) (MvPolynomial.degreeOf i p)","decl":"theorem degreeOf_C_mul_le (p : MvPolynomial σ R) (i : σ) (c : R) :\n    (C c * p).degreeOf i ≤ p.degreeOf i := by\n  unfold degreeOf\n  convert Multiset.count_le_of_le i degrees_mul_le\n  simp only [degrees_C, zero_add]\n\n"}
{"name":"MvPolynomial.degreeOf_mul_C_le","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\ni : σ\nc : R\n⊢ LE.le (MvPolynomial.degreeOf i (HMul.hMul p (MvPolynomial.C c))) (MvPolynomial.degreeOf i p)","decl":"theorem degreeOf_mul_C_le (p : MvPolynomial σ R) (i : σ) (c : R) :\n    (p * C c).degreeOf i ≤ p.degreeOf i := by\n  unfold degreeOf\n  convert Multiset.count_le_of_le i degrees_mul_le\n  simp only [degrees_C, add_zero]\n\n"}
{"name":"MvPolynomial.degreeOf_rename_of_injective","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\nτ : Type u_2\ninst✝ : CommSemiring R\np : MvPolynomial σ R\nf : σ → τ\nh : Function.Injective f\ni : σ\n⊢ Eq (MvPolynomial.degreeOf (f i) ((MvPolynomial.rename f) p)) (MvPolynomial.degreeOf i p)","decl":"theorem degreeOf_rename_of_injective {p : MvPolynomial σ R} {f : σ → τ} (h : Function.Injective f)\n    (i : σ) : degreeOf (f i) (rename f p) = degreeOf i p := by\n  classical\n  simp only [degreeOf, degrees_rename_of_injective h, Multiset.count_map_eq_count' f p.degrees h]\n\n"}
{"name":"MvPolynomial.totalDegree_eq","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ Eq p.totalDegree (p.support.sup fun m => (Finsupp.toMultiset m).card)","decl":"theorem totalDegree_eq (p : MvPolynomial σ R) :\n    p.totalDegree = p.support.sup fun m => Multiset.card (toMultiset m) := by\n  rw [totalDegree]\n  congr; funext m\n  exact (Finsupp.card_toMultiset _).symm\n\n"}
{"name":"MvPolynomial.le_totalDegree","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\ns : Finsupp σ Nat\nh : Membership.mem p.support s\n⊢ LE.le (s.sum fun x e => e) p.totalDegree","decl":"theorem le_totalDegree {p : MvPolynomial σ R} {s : σ →₀ ℕ} (h : s ∈ p.support) :\n    (s.sum fun _ e => e) ≤ totalDegree p :=\n  Finset.le_sup (α := ℕ) (f := fun s => sum s fun _ e => e) h\n\n"}
{"name":"MvPolynomial.totalDegree_le_degrees_card","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ LE.le p.totalDegree p.degrees.card","decl":"theorem totalDegree_le_degrees_card (p : MvPolynomial σ R) :\n    p.totalDegree ≤ Multiset.card p.degrees := by\n  classical\n  rw [totalDegree_eq]\n  exact Finset.sup_le fun s hs => Multiset.card_le_card <| Finset.le_sup hs\n\n"}
{"name":"MvPolynomial.totalDegree_le_of_support_subset","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np q : MvPolynomial σ R\nh : HasSubset.Subset p.support q.support\n⊢ LE.le p.totalDegree q.totalDegree","decl":"theorem totalDegree_le_of_support_subset (h : p.support ⊆ q.support) :\n    totalDegree p ≤ totalDegree q :=\n  Finset.sup_mono h\n\n"}
{"name":"MvPolynomial.totalDegree_C","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\na : R\n⊢ Eq (MvPolynomial.C a).totalDegree 0","decl":"@[simp]\ntheorem totalDegree_C (a : R) : (C a : MvPolynomial σ R).totalDegree = 0 :=\n  (supDegree_single 0 a).trans <| by rw [sum_zero_index, bot_eq_zero', ite_self]\n\n"}
{"name":"MvPolynomial.totalDegree_zero","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.totalDegree 0) 0","decl":"@[simp]\ntheorem totalDegree_zero : (0 : MvPolynomial σ R).totalDegree = 0 := by\n  rw [← C_0]; exact totalDegree_C (0 : R)\n\n"}
{"name":"MvPolynomial.totalDegree_one","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.totalDegree 1) 0","decl":"@[simp]\ntheorem totalDegree_one : (1 : MvPolynomial σ R).totalDegree = 0 :=\n  totalDegree_C (1 : R)\n\n"}
{"name":"MvPolynomial.totalDegree_X","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\ns : σ\n⊢ Eq (MvPolynomial.X s).totalDegree 1","decl":"@[simp]\ntheorem totalDegree_X {R} [CommSemiring R] [Nontrivial R] (s : σ) :\n    (X s : MvPolynomial σ R).totalDegree = 1 := by\n  rw [totalDegree, support_X]\n  simp only [Finset.sup, Finsupp.sum_single_index, Finset.fold_singleton, sup_bot_eq]\n\n"}
{"name":"MvPolynomial.totalDegree_add","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\na b : MvPolynomial σ R\n⊢ LE.le (HAdd.hAdd a b).totalDegree (Max.max a.totalDegree b.totalDegree)","decl":"theorem totalDegree_add (a b : MvPolynomial σ R) :\n    (a + b).totalDegree ≤ max a.totalDegree b.totalDegree :=\n  sup_support_add_le _ _ _\n\n"}
{"name":"MvPolynomial.totalDegree_add_eq_left_of_totalDegree_lt","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np q : MvPolynomial σ R\nh : LT.lt q.totalDegree p.totalDegree\n⊢ Eq (HAdd.hAdd p q).totalDegree p.totalDegree","decl":"theorem totalDegree_add_eq_left_of_totalDegree_lt {p q : MvPolynomial σ R}\n    (h : q.totalDegree < p.totalDegree) : (p + q).totalDegree = p.totalDegree := by\n  classical\n    apply le_antisymm\n    · rw [← max_eq_left_of_lt h]\n      exact totalDegree_add p q\n    by_cases hp : p = 0\n    · simp [hp]\n    obtain ⟨b, hb₁, hb₂⟩ :=\n      p.support.exists_mem_eq_sup (Finsupp.support_nonempty_iff.mpr hp) fun m : σ →₀ ℕ =>\n        Multiset.card (toMultiset m)\n    have hb : ¬b ∈ q.support := by\n      contrapose! h\n      rw [totalDegree_eq p, hb₂, totalDegree_eq]\n      apply Finset.le_sup h\n    have hbb : b ∈ (p + q).support := by\n      apply support_sdiff_support_subset_support_add\n      rw [Finset.mem_sdiff]\n      exact ⟨hb₁, hb⟩\n    rw [totalDegree_eq, hb₂, totalDegree_eq]\n    exact Finset.le_sup (f := fun m => Multiset.card (Finsupp.toMultiset m)) hbb\n\n"}
{"name":"MvPolynomial.totalDegree_add_eq_right_of_totalDegree_lt","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np q : MvPolynomial σ R\nh : LT.lt q.totalDegree p.totalDegree\n⊢ Eq (HAdd.hAdd q p).totalDegree p.totalDegree","decl":"theorem totalDegree_add_eq_right_of_totalDegree_lt {p q : MvPolynomial σ R}\n    (h : q.totalDegree < p.totalDegree) : (q + p).totalDegree = p.totalDegree := by\n  rw [add_comm, totalDegree_add_eq_left_of_totalDegree_lt h]\n\n"}
{"name":"MvPolynomial.totalDegree_mul","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\na b : MvPolynomial σ R\n⊢ LE.le (HMul.hMul a b).totalDegree (HAdd.hAdd a.totalDegree b.totalDegree)","decl":"theorem totalDegree_mul (a b : MvPolynomial σ R) :\n    (a * b).totalDegree ≤ a.totalDegree + b.totalDegree :=\n  sup_support_mul_le (by exact (Finsupp.sum_add_index' (fun _ => rfl) (fun _ _ _ => rfl)).le) _ _\n\n"}
{"name":"MvPolynomial.totalDegree_smul_le","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nS : Type v\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : DistribMulAction R S\na : R\nf : MvPolynomial σ S\n⊢ LE.le (HSMul.hSMul a f).totalDegree f.totalDegree","decl":"theorem totalDegree_smul_le [CommSemiring S] [DistribMulAction R S] (a : R) (f : MvPolynomial σ S) :\n    (a • f).totalDegree ≤ f.totalDegree :=\n  Finset.sup_mono support_smul\n\n"}
{"name":"MvPolynomial.totalDegree_pow","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\na : MvPolynomial σ R\nn : Nat\n⊢ LE.le (HPow.hPow a n).totalDegree (HMul.hMul n a.totalDegree)","decl":"theorem totalDegree_pow (a : MvPolynomial σ R) (n : ℕ) :\n    (a ^ n).totalDegree ≤ n * a.totalDegree := by\n  rw [Finset.pow_eq_prod_const, ← Nat.nsmul_eq_mul, Finset.nsmul_eq_sum_const]\n  refine supDegree_prod_le rfl (fun _ _ => ?_)\n  exact Finsupp.sum_add_index' (fun _ => rfl) (fun _ _ _ => rfl)\n\n"}
{"name":"MvPolynomial.totalDegree_monomial","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ns : Finsupp σ Nat\nc : R\nhc : Ne c 0\n⊢ Eq ((MvPolynomial.monomial s) c).totalDegree (s.sum fun x e => e)","decl":"@[simp]\ntheorem totalDegree_monomial (s : σ →₀ ℕ) {c : R} (hc : c ≠ 0) :\n    (monomial s c : MvPolynomial σ R).totalDegree = s.sum fun _ e => e := by\n  classical simp [totalDegree, support_monomial, if_neg hc]\n\n"}
{"name":"MvPolynomial.totalDegree_monomial_le","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ns : Finsupp σ Nat\nc : R\n⊢ LE.le ((MvPolynomial.monomial s) c).totalDegree (s.sum fun x => id)","decl":"theorem totalDegree_monomial_le (s : σ →₀ ℕ) (c : R) :\n    (monomial s c).totalDegree ≤ s.sum fun _ ↦ id := by\n  if hc : c = 0 then\n    simp only [hc, map_zero, totalDegree_zero, zero_le]\n  else\n    rw [totalDegree_monomial _ hc, Function.id_def]\n\n"}
{"name":"MvPolynomial.totalDegree_X_pow","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\ns : σ\nn : Nat\n⊢ Eq (HPow.hPow (MvPolynomial.X s) n).totalDegree n","decl":"@[simp]\ntheorem totalDegree_X_pow [Nontrivial R] (s : σ) (n : ℕ) :\n    (X s ^ n : MvPolynomial σ R).totalDegree = n := by simp [X_pow_eq_monomial, one_ne_zero]\n\n"}
{"name":"MvPolynomial.totalDegree_list_prod","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ns : List (MvPolynomial σ R)\n⊢ LE.le s.prod.totalDegree (List.map MvPolynomial.totalDegree s).sum","decl":"theorem totalDegree_list_prod :\n    ∀ s : List (MvPolynomial σ R), s.prod.totalDegree ≤ (s.map MvPolynomial.totalDegree).sum\n  | [] => by rw [List.prod_nil, totalDegree_one, List.map_nil, List.sum_nil]\n  | p::ps => by\n    rw [List.prod_cons, List.map, List.sum_cons]\n    exact le_trans (totalDegree_mul _ _) (add_le_add_left (totalDegree_list_prod ps) _)\n\n"}
{"name":"MvPolynomial.totalDegree_multiset_prod","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ns : Multiset (MvPolynomial σ R)\n⊢ LE.le s.prod.totalDegree (Multiset.map MvPolynomial.totalDegree s).sum","decl":"theorem totalDegree_multiset_prod (s : Multiset (MvPolynomial σ R)) :\n    s.prod.totalDegree ≤ (s.map MvPolynomial.totalDegree).sum := by\n  refine Quotient.inductionOn s fun l => ?_\n  rw [Multiset.quot_mk_to_coe, Multiset.prod_coe, Multiset.map_coe, Multiset.sum_coe]\n  exact totalDegree_list_prod l\n\n"}
{"name":"MvPolynomial.totalDegree_finset_prod","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nι : Type u_3\ns : Finset ι\nf : ι → MvPolynomial σ R\n⊢ LE.le (s.prod f).totalDegree (s.sum fun i => (f i).totalDegree)","decl":"theorem totalDegree_finset_prod {ι : Type*} (s : Finset ι) (f : ι → MvPolynomial σ R) :\n    (s.prod f).totalDegree ≤ ∑ i ∈ s, (f i).totalDegree := by\n  refine le_trans (totalDegree_multiset_prod _) ?_\n  simp only [Multiset.map_map, comp_apply, Finset.sum_map_val, le_refl]\n\n"}
{"name":"MvPolynomial.totalDegree_finset_sum","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nι : Type u_3\ns : Finset ι\nf : ι → MvPolynomial σ R\n⊢ LE.le (s.sum f).totalDegree (s.sup fun i => (f i).totalDegree)","decl":"theorem totalDegree_finset_sum {ι : Type*} (s : Finset ι) (f : ι → MvPolynomial σ R) :\n    (s.sum f).totalDegree ≤ Finset.sup s fun i => (f i).totalDegree := by\n  induction' s using Finset.cons_induction with a s has hind\n  · exact zero_le _\n  · rw [Finset.sum_cons, Finset.sup_cons]\n    exact (MvPolynomial.totalDegree_add _ _).trans (max_le_max le_rfl hind)\n\n"}
{"name":"MvPolynomial.totalDegree_finsetSum_le","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nι : Type u_3\ns : Finset ι\nf : ι → MvPolynomial σ R\nd : Nat\nhf : ∀ (i : ι), Membership.mem s i → LE.le (f i).totalDegree d\n⊢ LE.le (s.sum f).totalDegree d","decl":"lemma totalDegree_finsetSum_le {ι : Type*} {s : Finset ι} {f : ι → MvPolynomial σ R} {d : ℕ}\n    (hf : ∀ i ∈ s, (f i).totalDegree ≤ d) : (s.sum f).totalDegree ≤ d :=\n  (totalDegree_finset_sum ..).trans <| Finset.sup_le hf\n\n"}
{"name":"MvPolynomial.degreeOf_le_totalDegree","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nf : MvPolynomial σ R\ni : σ\n⊢ LE.le (MvPolynomial.degreeOf i f) f.totalDegree","decl":"lemma degreeOf_le_totalDegree (f : MvPolynomial σ R) (i : σ) : f.degreeOf i ≤ f.totalDegree :=\n  degreeOf_le_iff.mpr fun d hd ↦ (eq_or_ne (d i) 0).elim (·.trans_le zero_le') fun h ↦\n    (Finset.single_le_sum (fun _ _ ↦ zero_le') <| Finsupp.mem_support_iff.mpr h).trans\n    (le_totalDegree hd)\n\n"}
{"name":"MvPolynomial.exists_degree_lt","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\nf : MvPolynomial σ R\nn : Nat\nh : LT.lt f.totalDegree (HMul.hMul n (Fintype.card σ))\nd : Finsupp σ Nat\nhd : Membership.mem f.support d\n⊢ Exists fun i => LT.lt (d i) n","decl":"theorem exists_degree_lt [Fintype σ] (f : MvPolynomial σ R) (n : ℕ)\n    (h : f.totalDegree < n * Fintype.card σ) {d : σ →₀ ℕ} (hd : d ∈ f.support) : ∃ i, d i < n := by\n  contrapose! h\n  calc\n    n * Fintype.card σ = ∑ _s : σ, n := by\n      rw [Finset.sum_const, Nat.nsmul_eq_mul, mul_comm, Finset.card_univ]\n    _ ≤ ∑ s, d s := Finset.sum_le_sum fun s _ => h s\n    _ ≤ d.sum fun _ e => e := by\n      rw [Finsupp.sum_fintype]\n      intros\n      rfl\n    _ ≤ f.totalDegree := le_totalDegree hd\n\n"}
{"name":"MvPolynomial.coeff_eq_zero_of_totalDegree_lt","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nf : MvPolynomial σ R\nd : Finsupp σ Nat\nh : LT.lt f.totalDegree (d.support.sum fun i => d i)\n⊢ Eq (MvPolynomial.coeff d f) 0","decl":"theorem coeff_eq_zero_of_totalDegree_lt {f : MvPolynomial σ R} {d : σ →₀ ℕ}\n    (h : f.totalDegree < ∑ i ∈ d.support, d i) : coeff d f = 0 := by\n  classical\n    rw [totalDegree, Finset.sup_lt_iff] at h\n    · specialize h d\n      rw [mem_support_iff] at h\n      refine not_not.mp (mt h ?_)\n      exact lt_irrefl _\n    · exact lt_of_le_of_lt (Nat.zero_le _) h\n\n"}
{"name":"MvPolynomial.totalDegree_eq_zero_iff_eq_C","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ Iff (Eq p.totalDegree 0) (Eq p (MvPolynomial.C (MvPolynomial.coeff 0 p)))","decl":"theorem totalDegree_eq_zero_iff_eq_C {p : MvPolynomial σ R} :\n    p.totalDegree = 0 ↔ p = C (p.coeff 0) := by\n  constructor <;> intro h\n  · ext m; classical rw [coeff_C]; split_ifs with hm; · rw [← hm]\n    apply coeff_eq_zero_of_totalDegree_lt; rw [h]\n    exact Finset.sum_pos (fun i hi ↦ Nat.pos_of_ne_zero <| Finsupp.mem_support_iff.mp hi)\n      (Finsupp.support_nonempty_iff.mpr <| Ne.symm hm)\n  · rw [h, totalDegree_C]\n\n"}
{"name":"MvPolynomial.totalDegree_rename_le","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\nτ : Type u_2\ninst✝ : CommSemiring R\nf : σ → τ\np : MvPolynomial σ R\n⊢ LE.le ((MvPolynomial.rename f) p).totalDegree p.totalDegree","decl":"theorem totalDegree_rename_le (f : σ → τ) (p : MvPolynomial σ R) :\n    (rename f p).totalDegree ≤ p.totalDegree :=\n  Finset.sup_le fun b => by\n    classical\n    intro h\n    rw [rename_eq] at h\n    have h' := Finsupp.mapDomain_support h\n    rw [Finset.mem_image] at h'\n    rcases h' with ⟨s, hs, rfl⟩\n    exact (sum_mapDomain_index (fun _ => rfl) (fun _ _ _ => rfl)).trans_le (le_totalDegree hs)\n\n"}
{"name":"MvPolynomial.mem_degreesLE","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\ns : Multiset σ\n⊢ Iff (Membership.mem (MvPolynomial.degreesLE R σ s) p) (LE.le p.degrees s)","decl":"@[simp] lemma mem_degreesLE : p ∈ degreesLE R σ s ↔ p.degrees ≤ s := Iff.rfl\n\n"}
{"name":"MvPolynomial.degreesLE_add","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ns t : Multiset σ\n⊢ Eq (MvPolynomial.degreesLE R σ (HAdd.hAdd s t)) (HMul.hMul (MvPolynomial.degreesLE R σ s) (MvPolynomial.degreesLE R σ t))","decl":"variable (s t) in\nlemma degreesLE_add : degreesLE R σ (s + t) = degreesLE R σ s * degreesLE R σ t := by\n  classical\n  rw [le_antisymm_iff, Submodule.mul_le]\n  refine ⟨fun x hx ↦ x.as_sum ▸ sum_mem fun i hi ↦ ?_,\n    fun x hx y hy ↦ degrees_mul_le.trans (add_le_add hx hy)⟩\n  replace hi : i.toMultiset ≤ s + t := (Finset.le_sup hi).trans hx\n  let a := (i.toMultiset - t).toFinsupp\n  let b := (i.toMultiset ⊓ t).toFinsupp\n  have : a + b = i := Multiset.toFinsupp.symm.injective (by simp [a, b, Multiset.sub_add_inter])\n  have ha : a.toMultiset ≤ s := by simpa [a, add_comm (a := t)] using hi\n  have hb : b.toMultiset ≤ t := by simp [b, Multiset.inter_le_right]\n  rw [show monomial i (x.coeff i) = monomial a (x.coeff i) * monomial b 1 by simp [this]]\n  exact Submodule.mul_mem_mul ((degrees_monomial _ _).trans ha) ((degrees_monomial _ _).trans hb)\n\n"}
{"name":"MvPolynomial.degreesLE_zero","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.degreesLE R σ 0) 1","decl":"@[simp] lemma degreesLE_zero : degreesLE R σ 0 = 1 := by\n  refine le_antisymm (fun x hx ↦ ?_) (by simp)\n  simp only [mem_degreesLE, nonpos_iff_eq_zero] at hx\n  have := (totalDegree_eq_zero_iff_eq_C (p := x)).mp\n    (Nat.eq_zero_of_le_zero (x.totalDegree_le_degrees_card.trans (by simp [hx])))\n  exact ⟨x.coeff 0, by simp [Algebra.smul_def, ← this]⟩\n\n"}
{"name":"MvPolynomial.degreesLE_nsmul","module":"Mathlib.Algebra.MvPolynomial.Degrees","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ns : Multiset σ\nn : Nat\n⊢ Eq (MvPolynomial.degreesLE R σ (HSMul.hSMul n s)) (HPow.hPow (MvPolynomial.degreesLE R σ s) n)","decl":"variable (s) in\nlemma degreesLE_nsmul : ∀ n, degreesLE R σ (n • s) = degreesLE R σ s ^ n\n  | 0 => by simp\n  | k + 1 => by simp only [pow_succ, degreesLE_nsmul, degreesLE_add, add_smul, one_smul]\n\n"}
