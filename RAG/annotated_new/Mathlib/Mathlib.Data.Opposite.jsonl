{"name":"Opposite.op.inj","module":"Mathlib.Data.Opposite","initialProofState":"α : Sort u\nunop✝ unop : α\nx✝ : Eq { unop := unop✝ } { unop := unop }\n⊢ Eq unop✝ unop","decl":"/-- The type of objects of the opposite of `α`; used to define the opposite category.\n\n  Now that Lean 4 supports definitional eta equality for records,\n  both `unop (op X) = X` and `op (unop X) = X` are definitional equalities.\n\n-/\nstructure Opposite where\n  /-- The canonical map `α → αᵒᵖ`. -/\n  op ::\n  /-- The canonical map `αᵒᵖ → α`. -/\n  unop : α\n\n"}
{"name":"Opposite.op.sizeOf_spec","module":"Mathlib.Data.Opposite","initialProofState":"α : Sort u\ninst✝ : SizeOf α\nunop : α\n⊢ Eq (SizeOf.sizeOf { unop := unop }) (HAdd.hAdd 1 (SizeOf.sizeOf unop))","decl":"/-- The type of objects of the opposite of `α`; used to define the opposite category.\n\n  Now that Lean 4 supports definitional eta equality for records,\n  both `unop (op X) = X` and `op (unop X) = X` are definitional equalities.\n\n-/\nstructure Opposite where\n  /-- The canonical map `α → αᵒᵖ`. -/\n  op ::\n  /-- The canonical map `αᵒᵖ → α`. -/\n  unop : α\n\n"}
{"name":"Opposite.op.injEq","module":"Mathlib.Data.Opposite","initialProofState":"α : Sort u\nunop✝ unop : α\n⊢ Eq (Eq { unop := unop✝ } { unop := unop }) (Eq unop✝ unop)","decl":"/-- The type of objects of the opposite of `α`; used to define the opposite category.\n\n  Now that Lean 4 supports definitional eta equality for records,\n  both `unop (op X) = X` and `op (unop X) = X` are definitional equalities.\n\n-/\nstructure Opposite where\n  /-- The canonical map `α → αᵒᵖ`. -/\n  op ::\n  /-- The canonical map `αᵒᵖ → α`. -/\n  unop : α\n\n"}
{"name":"Opposite.op_injective","module":"Mathlib.Data.Opposite","initialProofState":"α : Sort u\n⊢ Function.Injective Opposite.op","decl":"theorem op_injective : Function.Injective (op : α → αᵒᵖ) := fun _ _ => congr_arg Opposite.unop\n\n"}
{"name":"Opposite.unop_injective","module":"Mathlib.Data.Opposite","initialProofState":"α : Sort u\n⊢ Function.Injective Opposite.unop","decl":"theorem unop_injective : Function.Injective (unop : αᵒᵖ → α) := fun ⟨_⟩⟨_⟩ => by simp\n\n"}
{"name":"Opposite.op_unop","module":"Mathlib.Data.Opposite","initialProofState":"α : Sort u\nx : Opposite α\n⊢ Eq { unop := Opposite.unop x } x","decl":"@[simp]\ntheorem op_unop (x : αᵒᵖ) : op (unop x) = x :=\n  rfl\n\n"}
{"name":"Opposite.unop_op","module":"Mathlib.Data.Opposite","initialProofState":"α : Sort u\nx : α\n⊢ Eq (Opposite.unop { unop := x }) x","decl":"theorem unop_op (x : α) : unop (op x) = x :=\n  rfl\n\n-- We could prove these by `Iff.rfl`, but that would make these eligible for `dsimp`. That would be\n-- a bad idea because `Opposite` is irreducible.\n"}
{"name":"Opposite.op_inj_iff","module":"Mathlib.Data.Opposite","initialProofState":"α : Sort u\nx y : α\n⊢ Iff (Eq { unop := x } { unop := y }) (Eq x y)","decl":"theorem op_inj_iff (x y : α) : op x = op y ↔ x = y :=\n  op_injective.eq_iff\n\n"}
{"name":"Opposite.unop_inj_iff","module":"Mathlib.Data.Opposite","initialProofState":"α : Sort u\nx y : Opposite α\n⊢ Iff (Eq (Opposite.unop x) (Opposite.unop y)) (Eq x y)","decl":"@[simp]\ntheorem unop_inj_iff (x y : αᵒᵖ) : unop x = unop y ↔ x = y :=\n  unop_injective.eq_iff\n\n"}
{"name":"Opposite.op_surjective","module":"Mathlib.Data.Opposite","initialProofState":"α : Sort u\n⊢ Function.Surjective Opposite.op","decl":"theorem op_surjective : Function.Surjective (op : α → αᵒᵖ) := equivToOpposite.surjective\n\n"}
{"name":"Opposite.unop_surjective","module":"Mathlib.Data.Opposite","initialProofState":"α : Sort u\n⊢ Function.Surjective Opposite.unop","decl":"theorem unop_surjective : Function.Surjective (unop : αᵒᵖ → α) := equivToOpposite.symm.surjective\n\n"}
{"name":"Opposite.equivToOpposite_coe","module":"Mathlib.Data.Opposite","initialProofState":"α : Sort u\n⊢ Eq (⇑Opposite.equivToOpposite) Opposite.op","decl":"@[simp]\ntheorem equivToOpposite_coe : (equivToOpposite : α → αᵒᵖ) = op :=\n  rfl\n\n"}
{"name":"Opposite.equivToOpposite_symm_coe","module":"Mathlib.Data.Opposite","initialProofState":"α : Sort u\n⊢ Eq (⇑Opposite.equivToOpposite.symm) Opposite.unop","decl":"@[simp]\ntheorem equivToOpposite_symm_coe : (equivToOpposite.symm : αᵒᵖ → α) = unop :=\n  rfl\n\n"}
{"name":"Opposite.op_eq_iff_eq_unop","module":"Mathlib.Data.Opposite","initialProofState":"α : Sort u\nx : α\ny : Opposite α\n⊢ Iff (Eq { unop := x } y) (Eq x (Opposite.unop y))","decl":"theorem op_eq_iff_eq_unop {x : α} {y} : op x = y ↔ x = unop y :=\n  equivToOpposite.apply_eq_iff_eq_symm_apply\n\n"}
{"name":"Opposite.unop_eq_iff_eq_op","module":"Mathlib.Data.Opposite","initialProofState":"α : Sort u\nx : Opposite α\ny : α\n⊢ Iff (Eq (Opposite.unop x) y) (Eq x { unop := y })","decl":"theorem unop_eq_iff_eq_op {x} {y : α} : unop x = y ↔ x = op y :=\n  equivToOpposite.symm.apply_eq_iff_eq_symm_apply\n\n"}
{"name":"Opposite.instNonempty","module":"Mathlib.Data.Opposite","initialProofState":"α : Sort u\ninst✝ : Nonempty α\n⊢ Nonempty (Opposite α)","decl":"instance [Nonempty α] : Nonempty αᵒᵖ := Nonempty.map op ‹_›\n\n"}
{"name":"Opposite.instSubsingleton","module":"Mathlib.Data.Opposite","initialProofState":"α : Sort u\ninst✝ : Subsingleton α\n⊢ Subsingleton (Opposite α)","decl":"instance [Subsingleton α] : Subsingleton αᵒᵖ := unop_injective.subsingleton\n\n"}
