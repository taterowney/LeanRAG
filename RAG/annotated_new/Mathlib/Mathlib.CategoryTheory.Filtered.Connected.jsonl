{"name":"CategoryTheory.IsFilteredOrEmpty.isPreconnected","module":"Mathlib.CategoryTheory.Filtered.Connected","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\n⊢ CategoryTheory.IsPreconnected C","decl":"theorem IsFilteredOrEmpty.isPreconnected [IsFilteredOrEmpty C] : IsPreconnected C :=\n  zigzag_isPreconnected fun j j' => .trans\n    (.single <| .inl <| .intro <| IsFiltered.leftToMax j j')\n    (.single <| .inr <| .intro <| IsFiltered.rightToMax j j')\n\n"}
{"name":"CategoryTheory.IsCofilteredOrEmpty.isPreconnected","module":"Mathlib.CategoryTheory.Filtered.Connected","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsCofilteredOrEmpty C\n⊢ CategoryTheory.IsPreconnected C","decl":"theorem IsCofilteredOrEmpty.isPreconnected [IsCofilteredOrEmpty C] : IsPreconnected C :=\n  zigzag_isPreconnected fun j j' => .trans\n    (.single <| .inr <| .intro <| IsCofiltered.minToLeft j j')\n    (.single <| .inl <| .intro <| IsCofiltered.minToRight j j')\n\n"}
{"name":"CategoryTheory.IsFiltered.isConnected","module":"Mathlib.CategoryTheory.Filtered.Connected","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFiltered C\n⊢ CategoryTheory.IsConnected C","decl":"attribute [local instance] IsFiltered.nonempty in\ntheorem IsFiltered.isConnected [IsFiltered C] : IsConnected C :=\n  { IsFilteredOrEmpty.isPreconnected C with }\n\n"}
{"name":"CategoryTheory.IsCofiltered.isConnected","module":"Mathlib.CategoryTheory.Filtered.Connected","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsCofiltered C\n⊢ CategoryTheory.IsConnected C","decl":"attribute [local instance] IsCofiltered.nonempty in\ntheorem IsCofiltered.isConnected [IsCofiltered C] : IsConnected C :=\n  { IsCofilteredOrEmpty.isPreconnected C with }\n\n"}
