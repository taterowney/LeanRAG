{"name":"IsLocalization.Away.span_range_mulNumerator_eq_top","module":"Mathlib.RingTheory.Localization.Away.Lemmas","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ns : Set R\nhsone : Eq (Ideal.span s) Top.top\nRₜ : ↑s → Type u_2\ninst✝² : (t : ↑s) → CommRing (Rₜ t)\ninst✝¹ : (t : ↑s) → Algebra R (Rₜ t)\ninst✝ : ∀ (t : ↑s), IsLocalization.Away (↑t) (Rₜ t)\np : (t : ↑s) → Set (Rₜ t)\nhtone : ∀ (r : ↑s), Eq (Ideal.span (p r)) Top.top\n⊢ Eq (Ideal.span (Set.range (IsLocalization.Away.mulNumerator s p))) Top.top","decl":"lemma span_range_mulNumerator_eq_top {s : Set R}\n    (hsone : Ideal.span s = ⊤) {Rₜ : s → Type*} [∀ t, CommRing (Rₜ t)] [∀ t, Algebra R (Rₜ t)]\n    [∀ t, IsLocalization.Away t.val (Rₜ t)]\n    {p : (t : s) → Set (Rₜ t)} (htone : ∀ (r : s), Ideal.span (p r) = ⊤) :\n    Ideal.span (Set.range (IsLocalization.Away.mulNumerator s p)) = ⊤ := by\n  rw [← Ideal.radical_eq_top, eq_top_iff, ← hsone, Ideal.span_le]\n  intro a ha\n  haveI : IsLocalization (Submonoid.powers a) (Rₜ ⟨a, ha⟩) :=\n    inferInstanceAs <| IsLocalization.Away (⟨a, ha⟩ : s).val (Rₜ ⟨a, ha⟩)\n  have h₁ : Ideal.span (p ⟨a, ha⟩) ≤ Ideal.span\n      (algebraMap R (Rₜ ⟨a, ha⟩) '' Set.range (IsLocalization.Away.mulNumerator s p)) := by\n    rw [Ideal.span_le]\n    intro x hx\n    rw [SetLike.mem_coe, IsLocalization.mem_span_map (Submonoid.powers a)]\n    refine ⟨a * (IsLocalization.Away.sec a x).1, Ideal.subset_span ⟨⟨⟨a, ha⟩, ⟨x, hx⟩⟩, rfl⟩, ?_⟩\n    use ⟨a ^ ((IsLocalization.Away.sec a x).2 + 1), _, rfl⟩\n    rw [IsLocalization.eq_mk'_iff_mul_eq, map_pow, map_mul, ← map_pow, pow_add, map_mul,\n      ← mul_assoc, IsLocalization.Away.sec_spec a x, mul_comm, pow_one]\n  have h₂ : IsLocalization.mk' (Rₜ ⟨a, ha⟩) 1 (1 : Submonoid.powers a) ∈ Ideal.span\n      (algebraMap R (Rₜ ⟨a, ha⟩) ''\n        (Set.range <| IsLocalization.Away.mulNumerator s p)) := by\n    rw [IsLocalization.mk'_one]\n    apply h₁\n    simp [htone]\n  rw [IsLocalization.mem_span_map (Submonoid.powers a)] at h₂\n  obtain ⟨y, hy, ⟨-, m, rfl⟩, hyz⟩ := h₂\n  rw [IsLocalization.eq] at hyz\n  obtain ⟨⟨-, n, rfl⟩, hc⟩ := hyz\n  simp only [← mul_assoc, OneMemClass.coe_one, one_mul, mul_one] at hc\n  use n + m\n  simpa [pow_add, hc] using Ideal.mul_mem_left _ _ hy\n\n"}
{"name":"IsLocalization.Away.quotient_of_isIdempotentElem","module":"Mathlib.RingTheory.Localization.Away.Lemmas","initialProofState":"R : Type u_1\ninst✝ : CommRing R\ne : R\nhe : IsIdempotentElem e\n⊢ IsLocalization.Away e (HasQuotient.Quotient R (Ideal.span (Singleton.singleton (HSub.hSub 1 e))))","decl":"lemma quotient_of_isIdempotentElem {e : R} (he : IsIdempotentElem e) :\n    IsLocalization.Away e (R ⧸ Ideal.span {1 - e}) :=\n  away_of_isIdempotentElem he Ideal.mk_ker Quotient.mk_surjective\n\n"}
