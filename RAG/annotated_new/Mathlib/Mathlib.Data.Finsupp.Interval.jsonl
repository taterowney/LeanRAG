{"name":"Finsupp.rangeSingleton_toFun","module":"Mathlib.Data.Finsupp.Interval","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Zero α\nf : Finsupp ι α\ni : ι\n⊢ Eq (f.rangeSingleton i) (Singleton.singleton (f i))","decl":"/-- Pointwise `Singleton.singleton` bundled as a `Finsupp`. -/\n@[simps]\ndef rangeSingleton (f : ι →₀ α) : ι →₀ Finset α where\n  toFun i := {f i}\n  support := f.support\n  mem_support_toFun i := by\n    rw [← not_iff_not, not_mem_support_iff, not_ne_iff]\n    exact singleton_injective.eq_iff.symm\n\n"}
{"name":"Finsupp.rangeSingleton_support","module":"Mathlib.Data.Finsupp.Interval","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Zero α\nf : Finsupp ι α\n⊢ Eq f.rangeSingleton.support f.support","decl":"/-- Pointwise `Singleton.singleton` bundled as a `Finsupp`. -/\n@[simps]\ndef rangeSingleton (f : ι →₀ α) : ι →₀ Finset α where\n  toFun i := {f i}\n  support := f.support\n  mem_support_toFun i := by\n    rw [← not_iff_not, not_mem_support_iff, not_ne_iff]\n    exact singleton_injective.eq_iff.symm\n\n"}
{"name":"Finsupp.mem_rangeSingleton_apply_iff","module":"Mathlib.Data.Finsupp.Interval","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Zero α\nf : Finsupp ι α\ni : ι\na : α\n⊢ Iff (Membership.mem (f.rangeSingleton i) a) (Eq a (f i))","decl":"theorem mem_rangeSingleton_apply_iff : a ∈ f.rangeSingleton i ↔ a = f i :=\n  mem_singleton\n\n"}
{"name":"Finsupp.rangeIcc_toFun","module":"Mathlib.Data.Finsupp.Interval","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : Zero α\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrder α\nf g : Finsupp ι α\ni : ι\n⊢ Eq ((f.rangeIcc g) i) (Finset.Icc (f i) (g i))","decl":"open scoped Classical in\n/-- Pointwise `Finset.Icc` bundled as a `Finsupp`. -/\n@[simps toFun]\ndef rangeIcc (f g : ι →₀ α) : ι →₀ Finset α where\n  toFun i := Icc (f i) (g i)\n  support :=\n    -- Porting note: Not needed (due to open scoped Classical), in mathlib3 too\n    -- haveI := Classical.decEq ι\n    f.support ∪ g.support\n  mem_support_toFun i := by\n    rw [mem_union, ← not_iff_not, not_or, not_mem_support_iff, not_mem_support_iff, not_ne_iff]\n    exact Icc_eq_singleton_iff.symm\n\n-- Porting note: Added as alternative to rangeIcc_toFun to be used in proof of card_Icc\n"}
{"name":"Finsupp.coe_rangeIcc","module":"Mathlib.Data.Finsupp.Interval","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : Zero α\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrder α\ni : ι\nf g : Finsupp ι α\n⊢ Eq ((f.rangeIcc g) i) (Finset.Icc (f i) (g i))","decl":"lemma coe_rangeIcc (f g : ι →₀ α) : rangeIcc f g i = Icc (f i) (g i) := rfl\n\n"}
{"name":"Finsupp.rangeIcc_support","module":"Mathlib.Data.Finsupp.Interval","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : Zero α\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrder α\nf g : Finsupp ι α\n⊢ Eq (f.rangeIcc g).support (Union.union f.support g.support)","decl":"open scoped Classical in\n@[simp]\ntheorem rangeIcc_support (f g : ι →₀ α) :\n    (rangeIcc f g).support = f.support ∪ g.support := rfl\n\n"}
{"name":"Finsupp.mem_rangeIcc_apply_iff","module":"Mathlib.Data.Finsupp.Interval","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : Zero α\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrder α\nf g : Finsupp ι α\ni : ι\na : α\n⊢ Iff (Membership.mem ((f.rangeIcc g) i) a) (And (LE.le (f i) a) (LE.le a (g i)))","decl":"theorem mem_rangeIcc_apply_iff : a ∈ f.rangeIcc g i ↔ f i ≤ a ∧ a ≤ g i := mem_Icc\n\n"}
{"name":"Finsupp.Icc_eq","module":"Mathlib.Data.Finsupp.Interval","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : Zero α\ninst✝ : LocallyFiniteOrder α\nf g : Finsupp ι α\n⊢ Eq (Finset.Icc f g) ((Union.union f.support g.support).finsupp ⇑(f.rangeIcc g))","decl":"open scoped Classical in\ntheorem Icc_eq : Icc f g = (f.support ∪ g.support).finsupp (f.rangeIcc g) := rfl\n\n"}
{"name":"Finsupp.card_Icc","module":"Mathlib.Data.Finsupp.Interval","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : Zero α\ninst✝ : LocallyFiniteOrder α\nf g : Finsupp ι α\n⊢ Eq (Finset.Icc f g).card ((Union.union f.support g.support).prod fun i => (Finset.Icc (f i) (g i)).card)","decl":"open scoped Classical in\n-- Porting note: removed [DecidableEq ι]\ntheorem card_Icc : #(Icc f g) = ∏ i ∈ f.support ∪ g.support, #(Icc (f i) (g i)):= by\n  simp_rw [Icc_eq, card_finsupp, coe_rangeIcc]\n\n"}
{"name":"Finsupp.card_Ico","module":"Mathlib.Data.Finsupp.Interval","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : Zero α\ninst✝ : LocallyFiniteOrder α\nf g : Finsupp ι α\n⊢ Eq (Finset.Ico f g).card (HSub.hSub ((Union.union f.support g.support).prod fun i => (Finset.Icc (f i) (g i)).card) 1)","decl":"open scoped Classical in\n-- Porting note: removed [DecidableEq ι]\ntheorem card_Ico : #(Ico f g) = ∏ i ∈ f.support ∪ g.support, #(Icc (f i) (g i)) - 1 := by\n  rw [card_Ico_eq_card_Icc_sub_one, card_Icc]\n\n"}
{"name":"Finsupp.card_Ioc","module":"Mathlib.Data.Finsupp.Interval","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : Zero α\ninst✝ : LocallyFiniteOrder α\nf g : Finsupp ι α\n⊢ Eq (Finset.Ioc f g).card (HSub.hSub ((Union.union f.support g.support).prod fun i => (Finset.Icc (f i) (g i)).card) 1)","decl":"open scoped Classical in\n-- Porting note: removed [DecidableEq ι]\ntheorem card_Ioc : #(Ioc f g) = ∏ i ∈ f.support ∪ g.support, #(Icc (f i) (g i)) - 1 := by\n  rw [card_Ioc_eq_card_Icc_sub_one, card_Icc]\n\n"}
{"name":"Finsupp.card_Ioo","module":"Mathlib.Data.Finsupp.Interval","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : Zero α\ninst✝ : LocallyFiniteOrder α\nf g : Finsupp ι α\n⊢ Eq (Finset.Ioo f g).card (HSub.hSub ((Union.union f.support g.support).prod fun i => (Finset.Icc (f i) (g i)).card) 2)","decl":"open scoped Classical in\n-- Porting note: removed [DecidableEq ι]\ntheorem card_Ioo : #(Ioo f g) = ∏ i ∈ f.support ∪ g.support, #(Icc (f i) (g i)) - 2 := by\n  rw [card_Ioo_eq_card_Icc_sub_two, card_Icc]\n\n"}
{"name":"Finsupp.card_uIcc","module":"Mathlib.Data.Finsupp.Interval","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : Lattice α\ninst✝¹ : Zero α\ninst✝ : LocallyFiniteOrder α\nf g : Finsupp ι α\n⊢ Eq (Finset.uIcc f g).card ((Union.union f.support g.support).prod fun i => (Finset.uIcc (f i) (g i)).card)","decl":"open scoped Classical in\n-- Porting note: removed [DecidableEq ι]\ntheorem card_uIcc :\n    #(uIcc f g) = ∏ i ∈ f.support ∪ g.support, #(uIcc (f i) (g i)) := by\n  rw [← support_inf_union_support_sup]; exact card_Icc (_ : ι →₀ α) _\n\n"}
{"name":"Finsupp.card_Iic","module":"Mathlib.Data.Finsupp.Interval","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝³ : AddCommMonoid α\ninst✝² : PartialOrder α\ninst✝¹ : CanonicallyOrderedAdd α\ninst✝ : LocallyFiniteOrder α\nf : Finsupp ι α\n⊢ Eq (Finset.Iic f).card (f.support.prod fun i => (Finset.Iic (f i)).card)","decl":"theorem card_Iic : #(Iic f) = ∏ i ∈ f.support, #(Iic (f i)) := by\n  classical simp_rw [Iic_eq_Icc, card_Icc, Finsupp.bot_eq_zero, support_zero, empty_union,\n      zero_apply, bot_eq_zero]\n\n"}
{"name":"Finsupp.card_Iio","module":"Mathlib.Data.Finsupp.Interval","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝³ : AddCommMonoid α\ninst✝² : PartialOrder α\ninst✝¹ : CanonicallyOrderedAdd α\ninst✝ : LocallyFiniteOrder α\nf : Finsupp ι α\n⊢ Eq (Finset.Iio f).card (HSub.hSub (f.support.prod fun i => (Finset.Iic (f i)).card) 1)","decl":"theorem card_Iio : #(Iio f) = ∏ i ∈ f.support, #(Iic (f i)) - 1 := by\n  rw [card_Iio_eq_card_Iic_sub_one, card_Iic]\n\n"}
