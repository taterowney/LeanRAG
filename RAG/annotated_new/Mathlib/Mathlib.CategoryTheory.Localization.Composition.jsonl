{"name":"CategoryTheory.Functor.IsLocalization.comp","module":"Mathlib.CategoryTheory.Localization.Composition","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝³ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝² : CategoryTheory.Category.{v₃, u₃} C₃\nL₁ : CategoryTheory.Functor C₁ C₂\nL₂ : CategoryTheory.Functor C₂ C₃\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\ninst✝¹ : L₁.IsLocalization W₁\ninst✝ : L₂.IsLocalization W₂\nW₃ : CategoryTheory.MorphismProperty C₁\nhW₃ : W₃.IsInvertedBy (L₁.comp L₂)\nhW₁₃ : LE.le W₁ W₃\nhW₂₃ : LE.le W₂ (W₃.map L₁)\n⊢ (L₁.comp L₂).IsLocalization W₃","decl":"lemma comp [L₁.IsLocalization W₁] [L₂.IsLocalization W₂]\n    (W₃ : MorphismProperty C₁) (hW₃ : W₃.IsInvertedBy (L₁ ⋙ L₂))\n    (hW₁₃ : W₁ ≤ W₃) (hW₂₃ : W₂ ≤ W₃.map L₁) :\n    (L₁ ⋙ L₂).IsLocalization W₃ := by\n  -- The proof proceeds by reducing to the case of the constructed\n  -- localized categories, which satisfy the strict universal property\n  -- of the localization. In order to do this, we introduce\n  -- an equivalence of categories `E₂ : C₂ ≅ W₁.Localization`. Via\n  -- this equivalence, we introduce `W₂' : MorphismProperty W₁.Localization`\n  -- which corresponds to `W₂` via the equivalence `E₂`.\n  -- Then, we have a localizer morphism `Φ : LocalizerMorphism W₂ W₂'` which\n  -- is a localized equivalence (because `E₂` is an equivalence).\n  let E₂ := Localization.uniq L₁ W₁.Q W₁\n  let W₂' := W₂.map E₂.functor\n  let Φ : LocalizerMorphism W₂ W₂' :=\n    { functor := E₂.functor\n      map := by\n        have eq := W₂.isoClosure.inverseImage_map_eq_of_isEquivalence E₂.functor\n        rw [MorphismProperty.map_isoClosure] at eq\n        rw [eq]\n        apply W₂.le_isoClosure }\n  have := LocalizerMorphism.IsLocalizedEquivalence.of_equivalence Φ (by rfl)\n  -- The fact that `Φ` is a localized equivalence allows to consider\n  -- the induced equivalence of categories `E₃ : C₃ ≅ W₂'.Localization`, and\n  -- the isomorphism `iso : (W₁.Q ⋙ W₂'.Q) ⋙ E₃.inverse ≅ L₁ ⋙ L₂`\n  let E₃ := (Φ.localizedFunctor L₂ W₂'.Q).asEquivalence\n  let iso : (W₁.Q ⋙ W₂'.Q) ⋙ E₃.inverse ≅ L₁ ⋙ L₂ := by\n    calc\n      _ ≅ L₁ ⋙ E₂.functor ⋙ W₂'.Q ⋙ E₃.inverse :=\n          Functor.associator _ _ _ ≪≫ isoWhiskerRight (compUniqFunctor L₁ W₁.Q W₁).symm _ ≪≫\n            Functor.associator _ _ _\n      _ ≅ L₁ ⋙ L₂ ⋙ E₃.functor ⋙ E₃.inverse :=\n          isoWhiskerLeft _ ((Functor.associator _ _ _).symm ≪≫\n            isoWhiskerRight (Φ.catCommSq L₂ W₂'.Q).iso E₃.inverse ≪≫ Functor.associator _ _ _)\n      _ ≅ L₁ ⋙ L₂ := isoWhiskerLeft _ (isoWhiskerLeft _ E₃.unitIso.symm ≪≫ L₂.rightUnitor)\n  -- In order to show `(W₁.Q ⋙ W₂'.Q).IsLocalization W₃`, we need\n  -- to check the assumptions of `StrictUniversalPropertyFixedTarget.comp`\n  have hW₃' : W₃.IsInvertedBy (W₁.Q ⋙ W₂'.Q) := by\n    simpa only [← MorphismProperty.IsInvertedBy.iff_comp _ _ E₃.inverse,\n      MorphismProperty.IsInvertedBy.iff_of_iso W₃ iso] using hW₃\n  have hW₂₃' : W₂' ≤ W₃.map W₁.Q := (MorphismProperty.monotone_map E₂.functor hW₂₃).trans\n    (by simpa only [W₃.map_map]\n      using le_of_eq (W₃.map_eq_of_iso (compUniqFunctor L₁ W₁.Q W₁)))\n  have : (W₁.Q ⋙ W₂'.Q).IsLocalization W₃ := by\n    refine IsLocalization.mk' _ _ ?_ ?_\n    all_goals\n      exact (StrictUniversalPropertyFixedTarget.comp\n        (strictUniversalPropertyFixedTargetQ W₁ _)\n        (strictUniversalPropertyFixedTargetQ W₂' _) W₃ hW₃' hW₁₃ hW₂₃')\n  -- Finally, the previous result can be transported via the equivalence `E₃`\n  exact IsLocalization.of_equivalence_target _ W₃ _ E₃.symm iso\n\n"}
{"name":"CategoryTheory.Functor.IsLocalization.of_comp","module":"Mathlib.CategoryTheory.Localization.Composition","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝³ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝² : CategoryTheory.Category.{v₃, u₃} C₃\nL₁ : CategoryTheory.Functor C₁ C₂\nL₂ : CategoryTheory.Functor C₂ C₃\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nW₃ : CategoryTheory.MorphismProperty C₁\ninst✝¹ : L₁.IsLocalization W₁\ninst✝ : (L₁.comp L₂).IsLocalization W₃\nhW₁₃ : LE.le W₁ W₃\nhW₂₃ : Eq W₂ (W₃.map L₁)\n⊢ L₂.IsLocalization W₂","decl":"lemma of_comp (W₃ : MorphismProperty C₁)\n    [L₁.IsLocalization W₁] [(L₁ ⋙ L₂).IsLocalization W₃]\n    (hW₁₃ : W₁ ≤ W₃) (hW₂₃ : W₂ = W₃.map L₁) :\n    L₂.IsLocalization W₂ := by\n    have : (L₁ ⋙ W₂.Q).IsLocalization W₃ :=\n      comp L₁ W₂.Q W₁ W₂ W₃ (fun X Y f hf => Localization.inverts W₂.Q W₂ _\n        (by simpa only [hW₂₃] using W₃.map_mem_map _ _ hf)) hW₁₃\n        (by rw [hW₂₃])\n    exact IsLocalization.of_equivalence_target W₂.Q W₂ L₂\n      (Localization.uniq (L₁ ⋙ W₂.Q) (L₁ ⋙ L₂) W₃)\n      (liftNatIso L₁ W₁ _ _ _ _\n        ((Functor.associator _ _ _).symm ≪≫\n          Localization.compUniqFunctor (L₁ ⋙ W₂.Q) (L₁ ⋙ L₂) W₃))\n\n"}
