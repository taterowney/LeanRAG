{"name":"Quiver.SingleObj.ext","module":"Mathlib.Combinatorics.Quiver.SingleObj","initialProofState":"Œ± : Type u_1\nx y : Quiver.SingleObj Œ±\n‚ä¢ Eq x y","decl":"lemma ext {x y : SingleObj Œ±} : x = y := Unit.ext x y\n\n-- See note [reducible non-instances]\n"}
{"name":"Quiver.SingleObj.toHom_symm_apply","module":"Mathlib.Combinatorics.Quiver.SingleObj","initialProofState":"Œ± : Type u_1\na : Œ±\n‚ä¢ Eq (Quiver.SingleObj.toHom.symm a) a","decl":"/-- The type of arrows from `star Œ±` to itself is equivalent to the original type `Œ±`. -/\n@[simps!]\ndef toHom : Œ± ‚âÉ (star Œ± ‚ü∂ star Œ±) :=\n  Equiv.refl _\n\n"}
{"name":"Quiver.SingleObj.toHom_apply","module":"Mathlib.Combinatorics.Quiver.SingleObj","initialProofState":"Œ± : Type u_1\na : Œ±\n‚ä¢ Eq (Quiver.SingleObj.toHom a) a","decl":"/-- The type of arrows from `star Œ±` to itself is equivalent to the original type `Œ±`. -/\n@[simps!]\ndef toHom : Œ± ‚âÉ (star Œ± ‚ü∂ star Œ±) :=\n  Equiv.refl _\n\n"}
{"name":"Quiver.SingleObj.toPrefunctor_apply_obj","module":"Mathlib.Combinatorics.Quiver.SingleObj","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Œ± ‚Üí Œ≤\na : Quiver.SingleObj Œ±\n‚ä¢ Eq ((Quiver.SingleObj.toPrefunctor f).obj a) (id a)","decl":"/-- Prefunctors between two `SingleObj` quivers correspond to functions between the corresponding\narrows types.\n-/\n@[simps]\ndef toPrefunctor : (Œ± ‚Üí Œ≤) ‚âÉ SingleObj Œ± ‚•§q SingleObj Œ≤ where\n  toFun f := ‚ü®id, f‚ü©\n  invFun f a := f.map (toHom a)\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"Quiver.SingleObj.toPrefunctor_apply_map","module":"Mathlib.Combinatorics.Quiver.SingleObj","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Œ± ‚Üí Œ≤\nX‚úù Y‚úù : Quiver.SingleObj Œ±\na‚úù : Œ±\n‚ä¢ Eq ((Quiver.SingleObj.toPrefunctor f).map a‚úù) (f a‚úù)","decl":"/-- Prefunctors between two `SingleObj` quivers correspond to functions between the corresponding\narrows types.\n-/\n@[simps]\ndef toPrefunctor : (Œ± ‚Üí Œ≤) ‚âÉ SingleObj Œ± ‚•§q SingleObj Œ≤ where\n  toFun f := ‚ü®id, f‚ü©\n  invFun f a := f.map (toHom a)\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"Quiver.SingleObj.toPrefunctor_symm_apply","module":"Mathlib.Combinatorics.Quiver.SingleObj","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Prefunctor (Quiver.SingleObj Œ±) (Quiver.SingleObj Œ≤)\na : Œ±\n‚ä¢ Eq (Quiver.SingleObj.toPrefunctor.symm f a) (f.map (Quiver.SingleObj.toHom a))","decl":"/-- Prefunctors between two `SingleObj` quivers correspond to functions between the corresponding\narrows types.\n-/\n@[simps]\ndef toPrefunctor : (Œ± ‚Üí Œ≤) ‚âÉ SingleObj Œ± ‚•§q SingleObj Œ≤ where\n  toFun f := ‚ü®id, f‚ü©\n  invFun f a := f.map (toHom a)\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"Quiver.SingleObj.toPrefunctor_id","module":"Mathlib.Combinatorics.Quiver.SingleObj","initialProofState":"Œ± : Type u_1\n‚ä¢ Eq (Quiver.SingleObj.toPrefunctor id) (Prefunctor.id (Quiver.SingleObj Œ±))","decl":"theorem toPrefunctor_id : toPrefunctor id = ùü≠q (SingleObj Œ±) :=\n  rfl\n\n"}
{"name":"Quiver.SingleObj.toPrefunctor_symm_id","module":"Mathlib.Combinatorics.Quiver.SingleObj","initialProofState":"Œ± : Type u_1\n‚ä¢ Eq (Quiver.SingleObj.toPrefunctor.symm (Prefunctor.id (Quiver.SingleObj Œ±))) id","decl":"@[simp]\ntheorem toPrefunctor_symm_id : toPrefunctor.symm (ùü≠q (SingleObj Œ±)) = id :=\n  rfl\n\n"}
{"name":"Quiver.SingleObj.toPrefunctor_comp","module":"Mathlib.Combinatorics.Quiver.SingleObj","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nf : Œ± ‚Üí Œ≤\ng : Œ≤ ‚Üí Œ≥\n‚ä¢ Eq (Quiver.SingleObj.toPrefunctor (Function.comp g f)) ((Quiver.SingleObj.toPrefunctor f).comp (Quiver.SingleObj.toPrefunctor g))","decl":"theorem toPrefunctor_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) :\n    toPrefunctor (g ‚àò f) = toPrefunctor f ‚ãôq toPrefunctor g :=\n  rfl\n\n"}
{"name":"Quiver.SingleObj.toPrefunctor_symm_comp","module":"Mathlib.Combinatorics.Quiver.SingleObj","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nf : Prefunctor (Quiver.SingleObj Œ±) (Quiver.SingleObj Œ≤)\ng : Prefunctor (Quiver.SingleObj Œ≤) (Quiver.SingleObj Œ≥)\n‚ä¢ Eq (Quiver.SingleObj.toPrefunctor.symm (f.comp g)) (Function.comp (Quiver.SingleObj.toPrefunctor.symm g) (Quiver.SingleObj.toPrefunctor.symm f))","decl":"@[simp]\ntheorem toPrefunctor_symm_comp (f : SingleObj Œ± ‚•§q SingleObj Œ≤) (g : SingleObj Œ≤ ‚•§q SingleObj Œ≥) :\n    toPrefunctor.symm (f ‚ãôq g) = toPrefunctor.symm g ‚àò toPrefunctor.symm f := by\n  simp only [Equiv.symm_apply_eq, toPrefunctor_comp, Equiv.apply_symm_apply]\n\n"}
{"name":"Quiver.SingleObj.listToPath_pathToList","module":"Mathlib.Combinatorics.Quiver.SingleObj","initialProofState":"Œ± : Type u_1\nx : Quiver.SingleObj Œ±\np : Quiver.Path (Quiver.SingleObj.star Œ±) x\n‚ä¢ Eq (Quiver.SingleObj.listToPath (Quiver.SingleObj.pathToList p)) (Quiver.Path.cast ‚ãØ ‚ãØ p)","decl":"theorem listToPath_pathToList {x : SingleObj Œ±} (p : Path (star Œ±) x) :\n    listToPath (pathToList p) = p.cast rfl ext := by\n  induction p with\n  | nil => rfl\n  | cons _ _ ih => dsimp [pathToList] at *; rw [ih]\n\n"}
{"name":"Quiver.SingleObj.pathToList_listToPath","module":"Mathlib.Combinatorics.Quiver.SingleObj","initialProofState":"Œ± : Type u_1\nl : List Œ±\n‚ä¢ Eq (Quiver.SingleObj.pathToList (Quiver.SingleObj.listToPath l)) l","decl":"theorem pathToList_listToPath (l : List Œ±) : pathToList (listToPath l) = l := by\n  induction l with\n  | nil => rfl\n  | cons a l ih => change a :: pathToList (listToPath l) = a :: l; rw [ih]\n\n"}
{"name":"Quiver.SingleObj.pathEquivList_nil","module":"Mathlib.Combinatorics.Quiver.SingleObj","initialProofState":"Œ± : Type u_1\n‚ä¢ Eq (Quiver.SingleObj.pathEquivList Quiver.Path.nil) List.nil","decl":"@[simp]\ntheorem pathEquivList_nil : pathEquivList Path.nil = ([] : List Œ±) :=\n  rfl\n\n"}
{"name":"Quiver.SingleObj.pathEquivList_cons","module":"Mathlib.Combinatorics.Quiver.SingleObj","initialProofState":"Œ± : Type u_1\np : Quiver.Path (Quiver.SingleObj.star Œ±) (Quiver.SingleObj.star Œ±)\na : Quiver.Hom (Quiver.SingleObj.star Œ±) (Quiver.SingleObj.star Œ±)\n‚ä¢ Eq (Quiver.SingleObj.pathEquivList (p.cons a)) (List.cons a (Quiver.SingleObj.pathToList p))","decl":"@[simp]\ntheorem pathEquivList_cons (p : Path (star Œ±) (star Œ±)) (a : star Œ± ‚ü∂ star Œ±) :\n    pathEquivList (Path.cons p a) = a :: pathToList p :=\n  rfl\n\n"}
{"name":"Quiver.SingleObj.pathEquivList_symm_nil","module":"Mathlib.Combinatorics.Quiver.SingleObj","initialProofState":"Œ± : Type u_1\n‚ä¢ Eq (Quiver.SingleObj.pathEquivList.symm List.nil) Quiver.Path.nil","decl":"@[simp]\ntheorem pathEquivList_symm_nil : pathEquivList.symm ([] : List Œ±) = Path.nil :=\n  rfl\n\n"}
{"name":"Quiver.SingleObj.pathEquivList_symm_cons","module":"Mathlib.Combinatorics.Quiver.SingleObj","initialProofState":"Œ± : Type u_1\nl : List Œ±\na : Œ±\n‚ä¢ Eq (Quiver.SingleObj.pathEquivList.symm (List.cons a l)) ((Quiver.SingleObj.pathEquivList.symm l).cons a)","decl":"@[simp]\ntheorem pathEquivList_symm_cons (l : List Œ±) (a : Œ±) :\n    pathEquivList.symm (a :: l) = Path.cons (pathEquivList.symm l) a :=\n  rfl\n\n"}
