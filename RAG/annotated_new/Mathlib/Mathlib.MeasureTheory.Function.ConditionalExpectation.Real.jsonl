{"name":"MeasureTheory.rnDeriv_ae_eq_condExp","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhm : LE.le m m0\nhμm : MeasureTheory.SigmaFinite (μ.trim hm)\nf : α → Real\nhf : MeasureTheory.Integrable f μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.SignedMeasure.rnDeriv ((μ.withDensityᵥ f).trim hm) (μ.trim hm)) (MeasureTheory.condExp m μ f)","decl":"theorem rnDeriv_ae_eq_condExp {hm : m ≤ m0} [hμm : SigmaFinite (μ.trim hm)] {f : α → ℝ}\n    (hf : Integrable f μ) :\n    SignedMeasure.rnDeriv ((μ.withDensityᵥ f).trim hm) (μ.trim hm) =ᵐ[μ] μ[f|m] := by\n  refine ae_eq_condExp_of_forall_setIntegral_eq hm hf ?_ ?_ ?_\n  · exact fun _ _ _ => (integrable_of_integrable_trim hm\n      (SignedMeasure.integrable_rnDeriv ((μ.withDensityᵥ f).trim hm) (μ.trim hm))).integrableOn\n  · intro s hs _\n    conv_rhs => rw [← hf.withDensityᵥ_trim_eq_integral hm hs,\n      ← SignedMeasure.withDensityᵥ_rnDeriv_eq ((μ.withDensityᵥ f).trim hm) (μ.trim hm)\n        (hf.withDensityᵥ_trim_absolutelyContinuous hm)]\n    rw [withDensityᵥ_apply\n      (SignedMeasure.integrable_rnDeriv ((μ.withDensityᵥ f).trim hm) (μ.trim hm)) hs,\n      ← setIntegral_trim hm _ hs]\n    exact (SignedMeasure.measurable_rnDeriv _ _).stronglyMeasurable\n  · exact (SignedMeasure.measurable_rnDeriv _ _).stronglyMeasurable.aestronglyMeasurable\n\n"}
{"name":"MeasureTheory.rnDeriv_ae_eq_condexp","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhm : LE.le m m0\nhμm : MeasureTheory.SigmaFinite (μ.trim hm)\nf : α → Real\nhf : MeasureTheory.Integrable f μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.SignedMeasure.rnDeriv ((μ.withDensityᵥ f).trim hm) (μ.trim hm)) (MeasureTheory.condExp m μ f)","decl":"@[deprecated (since := \"2025-01-21\")] alias rnDeriv_ae_eq_condexp := rnDeriv_ae_eq_condExp\n\n-- TODO: the following couple of lemmas should be generalized and proved using Jensen's inequality\n-- for the conditional expectation (not in mathlib yet) .\n"}
{"name":"MeasureTheory.eLpNorm_one_condExp_le_eLpNorm","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\n⊢ LE.le (MeasureTheory.eLpNorm (MeasureTheory.condExp m μ f) 1 μ) (MeasureTheory.eLpNorm f 1 μ)","decl":"theorem eLpNorm_one_condExp_le_eLpNorm (f : α → ℝ) : eLpNorm (μ[f|m]) 1 μ ≤ eLpNorm f 1 μ := by\n  by_cases hf : Integrable f μ\n  swap; · rw [condExp_of_not_integrable hf, eLpNorm_zero]; exact zero_le _\n  by_cases hm : m ≤ m0\n  swap; · rw [condExp_of_not_le hm, eLpNorm_zero]; exact zero_le _\n  by_cases hsig : SigmaFinite (μ.trim hm)\n  swap; · rw [condExp_of_not_sigmaFinite hm hsig, eLpNorm_zero]; exact zero_le _\n  calc\n    eLpNorm (μ[f|m]) 1 μ ≤ eLpNorm (μ[(|f|)|m]) 1 μ := by\n      refine eLpNorm_mono_ae ?_\n      filter_upwards [condExp_mono hf hf.abs\n        (ae_of_all μ (fun x => le_abs_self (f x) : ∀ x, f x ≤ |f x|)),\n        (condExp_neg ..).symm.le.trans (condExp_mono hf.neg hf.abs\n          (ae_of_all μ (fun x => neg_le_abs (f x) : ∀ x, -f x ≤ |f x|)))] with x hx₁ hx₂\n      exact abs_le_abs hx₁ hx₂\n    _ = eLpNorm f 1 μ := by\n      rw [eLpNorm_one_eq_lintegral_enorm, eLpNorm_one_eq_lintegral_enorm,\n        ← ENNReal.toReal_eq_toReal (hasFiniteIntegral_iff_enorm.mp integrable_condExp.2).ne\n          (hasFiniteIntegral_iff_enorm.mp hf.2).ne,\n        ← integral_norm_eq_lintegral_enorm\n          (stronglyMeasurable_condExp.mono hm).aestronglyMeasurable,\n        ← integral_norm_eq_lintegral_enorm hf.1]\n      simp_rw [Real.norm_eq_abs]\n      rw (config := {occs := .pos [2]}) [← integral_condExp hm]\n      refine integral_congr_ae ?_\n      have : 0 ≤ᵐ[μ] μ[(|f|)|m] := by\n        rw [← condExp_zero]\n        exact condExp_mono (integrable_zero _ _ _) hf.abs\n          (ae_of_all μ (fun x => abs_nonneg (f x) : ∀ x, 0 ≤ |f x|))\n      filter_upwards [this] with x hx\n      exact abs_eq_self.2 hx\n\n"}
{"name":"MeasureTheory.eLpNorm_one_condexp_le_eLpNorm","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\n⊢ LE.le (MeasureTheory.eLpNorm (MeasureTheory.condExp m μ f) 1 μ) (MeasureTheory.eLpNorm f 1 μ)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias eLpNorm_one_condexp_le_eLpNorm := eLpNorm_one_condExp_le_eLpNorm\n\n"}
{"name":"MeasureTheory.integral_abs_condExp_le","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\n⊢ LE.le (MeasureTheory.integral μ fun x => abs (MeasureTheory.condExp m μ f x)) (MeasureTheory.integral μ fun x => abs (f x))","decl":"theorem integral_abs_condExp_le (f : α → ℝ) : ∫ x, |(μ[f|m]) x| ∂μ ≤ ∫ x, |f x| ∂μ := by\n  by_cases hm : m ≤ m0\n  swap\n  · simp_rw [condExp_of_not_le hm, Pi.zero_apply, abs_zero, integral_zero]\n    positivity\n  by_cases hfint : Integrable f μ\n  swap\n  · simp only [condExp_of_not_integrable hfint, Pi.zero_apply, abs_zero, integral_const,\n      Algebra.id.smul_eq_mul, mul_zero]\n    positivity\n  rw [integral_eq_lintegral_of_nonneg_ae, integral_eq_lintegral_of_nonneg_ae]\n  · apply ENNReal.toReal_mono <;> simp_rw [← Real.norm_eq_abs, ofReal_norm_eq_enorm]\n    · exact hfint.2.ne\n    · rw [← eLpNorm_one_eq_lintegral_enorm, ← eLpNorm_one_eq_lintegral_enorm]\n      exact eLpNorm_one_condExp_le_eLpNorm _\n  · filter_upwards with x using abs_nonneg _\n  · simp_rw [← Real.norm_eq_abs]\n    exact hfint.1.norm\n  · filter_upwards with x using abs_nonneg _\n  · simp_rw [← Real.norm_eq_abs]\n    exact (stronglyMeasurable_condExp.mono hm).aestronglyMeasurable.norm\n\n"}
{"name":"MeasureTheory.integral_abs_condexp_le","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\n⊢ LE.le (MeasureTheory.integral μ fun x => abs (MeasureTheory.condExp m μ f x)) (MeasureTheory.integral μ fun x => abs (f x))","decl":"@[deprecated (since := \"2025-01-21\")] alias integral_abs_condexp_le := integral_abs_condExp_le\n\n"}
{"name":"MeasureTheory.setIntegral_abs_condExp_le","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\nf : α → Real\n⊢ LE.le (MeasureTheory.integral (μ.restrict s) fun x => abs (MeasureTheory.condExp m μ f x)) (MeasureTheory.integral (μ.restrict s) fun x => abs (f x))","decl":"theorem setIntegral_abs_condExp_le {s : Set α} (hs : MeasurableSet[m] s) (f : α → ℝ) :\n    ∫ x in s, |(μ[f|m]) x| ∂μ ≤ ∫ x in s, |f x| ∂μ := by\n  by_cases hnm : m ≤ m0\n  swap\n  · simp_rw [condExp_of_not_le hnm, Pi.zero_apply, abs_zero, integral_zero]\n    positivity\n  by_cases hfint : Integrable f μ\n  swap\n  · simp only [condExp_of_not_integrable hfint, Pi.zero_apply, abs_zero, integral_const,\n      Algebra.id.smul_eq_mul, mul_zero]\n    positivity\n  have : ∫ x in s, |(μ[f|m]) x| ∂μ = ∫ x, |(μ[s.indicator f|m]) x| ∂μ := by\n    rw [← integral_indicator (hnm _ hs)]\n    refine integral_congr_ae ?_\n    have : (fun x => |(μ[s.indicator f|m]) x|) =ᵐ[μ] fun x => |s.indicator (μ[f|m]) x| :=\n      (condExp_indicator hfint hs).fun_comp abs\n    refine EventuallyEq.trans (Eventually.of_forall fun x => ?_) this.symm\n    rw [← Real.norm_eq_abs, norm_indicator_eq_indicator_norm]\n    simp only [Real.norm_eq_abs]\n  rw [this, ← integral_indicator (hnm _ hs)]\n  refine (integral_abs_condExp_le _).trans\n    (le_of_eq <| integral_congr_ae <| Eventually.of_forall fun x => ?_)\n  simp_rw [← Real.norm_eq_abs, norm_indicator_eq_indicator_norm]\n\n"}
{"name":"MeasureTheory.setIntegral_abs_condexp_le","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\nf : α → Real\n⊢ LE.le (MeasureTheory.integral (μ.restrict s) fun x => abs (MeasureTheory.condExp m μ f x)) (MeasureTheory.integral (μ.restrict s) fun x => abs (f x))","decl":"@[deprecated (since := \"2025-01-21\")] alias setIntegral_abs_condexp_le := setIntegral_abs_condExp_le\n\n"}
{"name":"MeasureTheory.ae_bdd_condExp_of_ae_bdd","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nR : NNReal\nf : α → Real\nhbdd : Filter.Eventually (fun x => LE.le (abs (f x)) ↑R) (MeasureTheory.ae μ)\n⊢ Filter.Eventually (fun x => LE.le (abs (MeasureTheory.condExp m μ f x)) ↑R) (MeasureTheory.ae μ)","decl":"/-- If the real valued function `f` is bounded almost everywhere by `R`, then so is its conditional\nexpectation. -/\ntheorem ae_bdd_condExp_of_ae_bdd {R : ℝ≥0} {f : α → ℝ} (hbdd : ∀ᵐ x ∂μ, |f x| ≤ R) :\n    ∀ᵐ x ∂μ, |(μ[f|m]) x| ≤ R := by\n  by_cases hnm : m ≤ m0\n  swap\n  · simp_rw [condExp_of_not_le hnm, Pi.zero_apply, abs_zero]\n    exact Eventually.of_forall fun _ => R.coe_nonneg\n  by_cases hfint : Integrable f μ\n  swap\n  · simp_rw [condExp_of_not_integrable hfint]\n    filter_upwards [hbdd] with x hx\n    rw [Pi.zero_apply, abs_zero]\n    exact (abs_nonneg _).trans hx\n  by_contra h\n  change μ _ ≠ 0 at h\n  simp only [← zero_lt_iff, Set.compl_def, Set.mem_setOf_eq, not_le] at h\n  suffices (μ {x | ↑R < |(μ[f|m]) x|}).toReal * ↑R < (μ {x | ↑R < |(μ[f|m]) x|}).toReal * ↑R by\n    exact this.ne rfl\n  refine lt_of_lt_of_le (setIntegral_gt_gt R.coe_nonneg ?_ h.ne') ?_\n  · exact integrable_condExp.abs.integrableOn\n  refine (setIntegral_abs_condExp_le ?_ _).trans ?_\n  · simp_rw [← Real.norm_eq_abs]\n    exact @measurableSet_lt _ _ _ _ _ m _ _ _ _ _ measurable_const\n      stronglyMeasurable_condExp.norm.measurable\n  simp only [← smul_eq_mul, ← setIntegral_const, NNReal.val_eq_coe, RCLike.ofReal_real_eq_id,\n    _root_.id]\n  refine setIntegral_mono_ae hfint.abs.integrableOn ?_ hbdd\n  refine ⟨aestronglyMeasurable_const, lt_of_le_of_lt ?_\n    (integrable_condExp.integrableOn : IntegrableOn (μ[f|m]) {x | ↑R < |(μ[f|m]) x|} μ).2⟩\n  refine setLIntegral_mono\n    (stronglyMeasurable_condExp.mono hnm).measurable.nnnorm.coe_nnreal_ennreal fun x hx => ?_\n  rw [enorm_eq_nnnorm, enorm_eq_nnnorm, ENNReal.coe_le_coe, Real.nnnorm_of_nonneg R.coe_nonneg]\n  exact Subtype.mk_le_mk.2 (le_of_lt hx)\n\n"}
{"name":"MeasureTheory.ae_bdd_condexp_of_ae_bdd","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nR : NNReal\nf : α → Real\nhbdd : Filter.Eventually (fun x => LE.le (abs (f x)) ↑R) (MeasureTheory.ae μ)\n⊢ Filter.Eventually (fun x => LE.le (abs (MeasureTheory.condExp m μ f x)) ↑R) (MeasureTheory.ae μ)","decl":"@[deprecated (since := \"2025-01-21\")] alias ae_bdd_condexp_of_ae_bdd := ae_bdd_condExp_of_ae_bdd\n\n"}
{"name":"MeasureTheory.Integrable.uniformIntegrable_condExp","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nι : Type u_2\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ng : α → Real\nhint : MeasureTheory.Integrable g μ\nℱ : ι → MeasurableSpace α\nhℱ : ∀ (i : ι), LE.le (ℱ i) m0\n⊢ MeasureTheory.UniformIntegrable (fun i => MeasureTheory.condExp (ℱ i) μ g) 1 μ","decl":"/-- Given an integrable function `g`, the conditional expectations of `g` with respect to\na sequence of sub-σ-algebras is uniformly integrable. -/\ntheorem Integrable.uniformIntegrable_condExp {ι : Type*} [IsFiniteMeasure μ] {g : α → ℝ}\n    (hint : Integrable g μ) {ℱ : ι → MeasurableSpace α} (hℱ : ∀ i, ℱ i ≤ m0) :\n    UniformIntegrable (fun i => μ[g|ℱ i]) 1 μ := by\n  let A : MeasurableSpace α := m0\n  have hmeas : ∀ n, ∀ C, MeasurableSet {x | C ≤ ‖(μ[g|ℱ n]) x‖₊} := fun n C =>\n    measurableSet_le measurable_const (stronglyMeasurable_condExp.mono (hℱ n)).measurable.nnnorm\n  have hg : Memℒp g 1 μ := memℒp_one_iff_integrable.2 hint\n  refine uniformIntegrable_of le_rfl ENNReal.one_ne_top\n    (fun n => (stronglyMeasurable_condExp.mono (hℱ n)).aestronglyMeasurable) fun ε hε => ?_\n  by_cases hne : eLpNorm g 1 μ = 0\n  · rw [eLpNorm_eq_zero_iff hg.1 one_ne_zero] at hne\n    refine ⟨0, fun n => (le_of_eq <|\n      (eLpNorm_eq_zero_iff ((stronglyMeasurable_condExp.mono (hℱ n)).aestronglyMeasurable.indicator\n        (hmeas n 0)) one_ne_zero).2 ?_).trans (zero_le _)⟩\n    filter_upwards [condExp_congr_ae (m := ℱ n) hne] with x hx\n    simp only [zero_le', Set.setOf_true, Set.indicator_univ, Pi.zero_apply, hx, condExp_zero]\n  obtain ⟨δ, hδ, h⟩ := hg.eLpNorm_indicator_le le_rfl ENNReal.one_ne_top hε\n  set C : ℝ≥0 := ⟨δ, hδ.le⟩⁻¹ * (eLpNorm g 1 μ).toNNReal with hC\n  have hCpos : 0 < C := mul_pos (inv_pos.2 hδ) (ENNReal.toNNReal_pos hne hg.eLpNorm_lt_top.ne)\n  have : ∀ n, μ {x : α | C ≤ ‖(μ[g|ℱ n]) x‖₊} ≤ ENNReal.ofReal δ := by\n    intro n\n    have := mul_meas_ge_le_pow_eLpNorm' μ one_ne_zero ENNReal.one_ne_top\n      ((stronglyMeasurable_condExp (m := ℱ n) (μ := μ) (f := g)).mono (hℱ n)).aestronglyMeasurable C\n    rw [ENNReal.one_toReal, ENNReal.rpow_one, ENNReal.rpow_one, mul_comm, ←\n      ENNReal.le_div_iff_mul_le (Or.inl (ENNReal.coe_ne_zero.2 hCpos.ne'))\n        (Or.inl ENNReal.coe_lt_top.ne)] at this\n    simp_rw [ENNReal.coe_le_coe] at this\n    refine this.trans ?_\n    rw [ENNReal.div_le_iff_le_mul (Or.inl (ENNReal.coe_ne_zero.2 hCpos.ne'))\n        (Or.inl ENNReal.coe_lt_top.ne),\n      hC, Nonneg.inv_mk, ENNReal.coe_mul, ENNReal.coe_toNNReal hg.eLpNorm_lt_top.ne, ← mul_assoc, ←\n      ENNReal.ofReal_eq_coe_nnreal, ← ENNReal.ofReal_mul hδ.le, mul_inv_cancel₀ hδ.ne',\n      ENNReal.ofReal_one, one_mul]\n    exact eLpNorm_one_condExp_le_eLpNorm _\n  refine ⟨C, fun n => le_trans ?_ (h {x : α | C ≤ ‖(μ[g|ℱ n]) x‖₊} (hmeas n C) (this n))⟩\n  have hmeasℱ : MeasurableSet[ℱ n] {x : α | C ≤ ‖(μ[g|ℱ n]) x‖₊} :=\n    @measurableSet_le _ _ _ _ _ (ℱ n) _ _ _ _ _ measurable_const\n      (@Measurable.nnnorm _ _ _ _ _ (ℱ n) _ stronglyMeasurable_condExp.measurable)\n  rw [← eLpNorm_congr_ae (condExp_indicator hint hmeasℱ)]\n  exact eLpNorm_one_condExp_le_eLpNorm _\n\n"}
{"name":"MeasureTheory.Integrable.uniformIntegrable_condexp","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nι : Type u_2\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ng : α → Real\nhint : MeasureTheory.Integrable g μ\nℱ : ι → MeasurableSpace α\nhℱ : ∀ (i : ι), LE.le (ℱ i) m0\n⊢ MeasureTheory.UniformIntegrable (fun i => MeasureTheory.condExp (ℱ i) μ g) 1 μ","decl":"@[deprecated (since := \"2025-01-21\")]\nalias Integrable.uniformIntegrable_condexp := Integrable.uniformIntegrable_condExp\n\n"}
{"name":"MeasureTheory.condExp_stronglyMeasurable_simpleFunc_mul","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhm : LE.le m m0\nf : MeasureTheory.SimpleFunc α Real\ng : α → Real\nhg : MeasureTheory.Integrable g μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m μ (HMul.hMul (⇑f) g)) (HMul.hMul (⇑f) (MeasureTheory.condExp m μ g))","decl":"/-- Auxiliary lemma for `condExp_mul_of_stronglyMeasurable_left`. -/\ntheorem condExp_stronglyMeasurable_simpleFunc_mul (hm : m ≤ m0) (f : @SimpleFunc α m ℝ) {g : α → ℝ}\n    (hg : Integrable g μ) : μ[(f * g : α → ℝ)|m] =ᵐ[μ] f * μ[g|m] := by\n  have : ∀ (s c) (f : α → ℝ), Set.indicator s (Function.const α c) * f = s.indicator (c • f) := by\n    intro s c f\n    ext1 x\n    by_cases hx : x ∈ s\n    · simp only [hx, Pi.mul_apply, Set.indicator_of_mem, Pi.smul_apply, Algebra.id.smul_eq_mul,\n        Function.const_apply]\n    · simp only [hx, Pi.mul_apply, Set.indicator_of_not_mem, not_false_iff, zero_mul]\n  apply @SimpleFunc.induction _ _ m _ (fun f => _)\n    (fun c s hs => ?_) (fun g₁ g₂ _ h_eq₁ h_eq₂ => ?_) f\n  · -- Porting note: if not classical, `DecidablePred fun x ↦ x ∈ s` cannot be synthesised\n    -- for `Set.piecewise_eq_indicator`\n    classical simp only [@SimpleFunc.const_zero _ _ m, @SimpleFunc.coe_piecewise _ _ m,\n      @SimpleFunc.coe_const _ _ m, @SimpleFunc.coe_zero _ _ m, Set.piecewise_eq_indicator]\n    rw [this, this]\n    refine (condExp_indicator (hg.smul c) hs).trans ?_\n    filter_upwards [condExp_smul c g m] with x hx\n    classical simp_rw [Set.indicator_apply, hx]\n  · have h_add := @SimpleFunc.coe_add _ _ m _ g₁ g₂\n    calc\n      μ[⇑(g₁ + g₂) * g|m] =ᵐ[μ] μ[(⇑g₁ + ⇑g₂) * g|m] := by\n        refine condExp_congr_ae (EventuallyEq.mul ?_ EventuallyEq.rfl); rw [h_add]\n      _ =ᵐ[μ] μ[⇑g₁ * g|m] + μ[⇑g₂ * g|m] := by\n        rw [add_mul]; exact condExp_add (hg.simpleFunc_mul' hm _) (hg.simpleFunc_mul' hm _) _\n      _ =ᵐ[μ] ⇑g₁ * μ[g|m] + ⇑g₂ * μ[g|m] := EventuallyEq.add h_eq₁ h_eq₂\n      _ =ᵐ[μ] ⇑(g₁ + g₂) * μ[g|m] := by rw [h_add, add_mul]\n\n"}
{"name":"MeasureTheory.condexp_stronglyMeasurable_simpleFunc_mul","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhm : LE.le m m0\nf : MeasureTheory.SimpleFunc α Real\ng : α → Real\nhg : MeasureTheory.Integrable g μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m μ (HMul.hMul (⇑f) g)) (HMul.hMul (⇑f) (MeasureTheory.condExp m μ g))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_stronglyMeasurable_simpleFunc_mul := condExp_stronglyMeasurable_simpleFunc_mul\n\n"}
{"name":"MeasureTheory.condExp_stronglyMeasurable_mul_of_bound","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhm : LE.le m m0\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf g : α → Real\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.Integrable g μ\nc : Real\nhf_bound : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) c) (MeasureTheory.ae μ)\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m μ (HMul.hMul f g)) (HMul.hMul f (MeasureTheory.condExp m μ g))","decl":"theorem condExp_stronglyMeasurable_mul_of_bound (hm : m ≤ m0) [IsFiniteMeasure μ] {f g : α → ℝ}\n    (hf : StronglyMeasurable[m] f) (hg : Integrable g μ) (c : ℝ) (hf_bound : ∀ᵐ x ∂μ, ‖f x‖ ≤ c) :\n    μ[f * g|m] =ᵐ[μ] f * μ[g|m] := by\n  let fs := hf.approxBounded c\n  have hfs_tendsto : ∀ᵐ x ∂μ, Tendsto (fs · x) atTop (𝓝 (f x)) :=\n    hf.tendsto_approxBounded_ae hf_bound\n  by_cases hμ : μ = 0\n  · simp only [hμ, ae_zero]; norm_cast\n  have : (ae μ).NeBot := ae_neBot.2 hμ\n  have hc : 0 ≤ c := by\n    rcases hf_bound.exists with ⟨_x, hx⟩\n    exact (norm_nonneg _).trans hx\n  have hfs_bound : ∀ n x, ‖fs n x‖ ≤ c := hf.norm_approxBounded_le hc\n  have : μ[f * μ[g|m]|m] = f * μ[g|m] := by\n    refine condExp_of_stronglyMeasurable hm (hf.mul stronglyMeasurable_condExp) ?_\n    exact integrable_condExp.bdd_mul' (hf.mono hm).aestronglyMeasurable hf_bound\n  rw [← this]\n  refine tendsto_condExp_unique (fun n x => fs n x * g x) (fun n x => fs n x * (μ[g|m]) x) (f * g)\n    (f * μ[g|m]) ?_ ?_ ?_ ?_ (c * ‖g ·‖) ?_ (c * ‖(μ[g|m]) ·‖) ?_ ?_ ?_ ?_\n  · exact fun n => hg.bdd_mul' ((SimpleFunc.stronglyMeasurable (fs n)).mono hm).aestronglyMeasurable\n      (Eventually.of_forall (hfs_bound n))\n  · exact fun n => integrable_condExp.bdd_mul'\n      ((SimpleFunc.stronglyMeasurable (fs n)).mono hm).aestronglyMeasurable\n      (Eventually.of_forall (hfs_bound n))\n  · filter_upwards [hfs_tendsto] with x hx\n    exact hx.mul tendsto_const_nhds\n  · filter_upwards [hfs_tendsto] with x hx\n    exact hx.mul tendsto_const_nhds\n  · exact hg.norm.const_mul c\n  · fun_prop\n  · refine fun n => Eventually.of_forall fun x => ?_\n    exact (norm_mul_le _ _).trans (mul_le_mul_of_nonneg_right (hfs_bound n x) (norm_nonneg _))\n  · refine fun n => Eventually.of_forall fun x => ?_\n    exact (norm_mul_le _ _).trans (mul_le_mul_of_nonneg_right (hfs_bound n x) (norm_nonneg _))\n  · intro n\n    simp_rw [← Pi.mul_apply]\n    refine (condExp_stronglyMeasurable_simpleFunc_mul hm _ hg).trans ?_\n    rw [condExp_of_stronglyMeasurable hm\n      ((SimpleFunc.stronglyMeasurable _).mul stronglyMeasurable_condExp) _]\n    exact integrable_condExp.bdd_mul'\n      ((SimpleFunc.stronglyMeasurable (fs n)).mono hm).aestronglyMeasurable\n      (Eventually.of_forall (hfs_bound n))\n\n"}
{"name":"MeasureTheory.condexp_stronglyMeasurable_mul_of_bound","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhm : LE.le m m0\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf g : α → Real\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.Integrable g μ\nc : Real\nhf_bound : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) c) (MeasureTheory.ae μ)\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m μ (HMul.hMul f g)) (HMul.hMul f (MeasureTheory.condExp m μ g))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_stronglyMeasurable_mul_of_bound := condExp_stronglyMeasurable_mul_of_bound\n\n"}
{"name":"MeasureTheory.condExp_stronglyMeasurable_mul_of_bound₀","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhm : LE.le m m0\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf g : α → Real\nhf : MeasureTheory.AEStronglyMeasurable f μ\nhg : MeasureTheory.Integrable g μ\nc : Real\nhf_bound : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) c) (MeasureTheory.ae μ)\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m μ (HMul.hMul f g)) (HMul.hMul f (MeasureTheory.condExp m μ g))","decl":"theorem condExp_stronglyMeasurable_mul_of_bound₀ (hm : m ≤ m0) [IsFiniteMeasure μ] {f g : α → ℝ}\n    (hf : AEStronglyMeasurable[m] f μ) (hg : Integrable g μ) (c : ℝ)\n    (hf_bound : ∀ᵐ x ∂μ, ‖f x‖ ≤ c) : μ[f * g|m] =ᵐ[μ] f * μ[g|m] := by\n  have : μ[f * g|m] =ᵐ[μ] μ[hf.mk f * g|m] :=\n    condExp_congr_ae (EventuallyEq.mul hf.ae_eq_mk EventuallyEq.rfl)\n  refine this.trans ?_\n  have : f * μ[g|m] =ᵐ[μ] hf.mk f * μ[g|m] := EventuallyEq.mul hf.ae_eq_mk EventuallyEq.rfl\n  refine EventuallyEq.trans ?_ this.symm\n  refine condExp_stronglyMeasurable_mul_of_bound hm hf.stronglyMeasurable_mk hg c ?_\n  filter_upwards [hf_bound, hf.ae_eq_mk] with x hxc hx_eq\n  rwa [← hx_eq]\n\n"}
{"name":"MeasureTheory.condexp_stronglyMeasurable_mul_of_bound₀","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhm : LE.le m m0\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf g : α → Real\nhf : MeasureTheory.AEStronglyMeasurable f μ\nhg : MeasureTheory.Integrable g μ\nc : Real\nhf_bound : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) c) (MeasureTheory.ae μ)\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m μ (HMul.hMul f g)) (HMul.hMul f (MeasureTheory.condExp m μ g))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_stronglyMeasurable_mul_of_bound₀ := condExp_stronglyMeasurable_mul_of_bound₀\n\n"}
{"name":"MeasureTheory.condExp_mul_of_stronglyMeasurable_left","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → Real\nhf : MeasureTheory.StronglyMeasurable f\nhfg : MeasureTheory.Integrable (HMul.hMul f g) μ\nhg : MeasureTheory.Integrable g μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m μ (HMul.hMul f g)) (HMul.hMul f (MeasureTheory.condExp m μ g))","decl":"/-- Pull-out property of the conditional expectation. -/\ntheorem condExp_mul_of_stronglyMeasurable_left {f g : α → ℝ} (hf : StronglyMeasurable[m] f)\n    (hfg : Integrable (f * g) μ) (hg : Integrable g μ) : μ[f * g|m] =ᵐ[μ] f * μ[g|m] := by\n  by_cases hm : m ≤ m0; swap; · simp_rw [condExp_of_not_le hm]; rw [mul_zero]\n  by_cases hμm : SigmaFinite (μ.trim hm)\n  swap; · simp_rw [condExp_of_not_sigmaFinite hm hμm]; rw [mul_zero]\n  haveI : SigmaFinite (μ.trim hm) := hμm\n  obtain ⟨sets, sets_prop, h_univ⟩ := hf.exists_spanning_measurableSet_norm_le hm μ\n  simp_rw [forall_and] at sets_prop\n  obtain ⟨h_meas, h_finite, h_norm⟩ := sets_prop\n  suffices ∀ n, ∀ᵐ x ∂μ, x ∈ sets n → (μ[f * g|m]) x = f x * (μ[g|m]) x by\n    rw [← ae_all_iff] at this\n    filter_upwards [this] with x hx\n    obtain ⟨i, hi⟩ : ∃ i, x ∈ sets i := by\n      have h_mem : x ∈ ⋃ i, sets i := by rw [h_univ]; exact Set.mem_univ _\n      simpa using h_mem\n    exact hx i hi\n  refine fun n => ae_imp_of_ae_restrict ?_\n  suffices (μ.restrict (sets n))[f * g|m] =ᵐ[μ.restrict (sets n)] f * (μ.restrict (sets n))[g|m] by\n    refine (condExp_restrict_ae_eq_restrict hm (h_meas n) hfg).symm.trans ?_\n    exact this.trans (EventuallyEq.rfl.mul (condExp_restrict_ae_eq_restrict hm (h_meas n) hg))\n  suffices (μ.restrict (sets n))[(sets n).indicator f * g|m] =ᵐ[μ.restrict (sets n)]\n      (sets n).indicator f * (μ.restrict (sets n))[g|m] by\n    refine EventuallyEq.trans ?_ (this.trans ?_)\n    · exact\n        condExp_congr_ae ((indicator_ae_eq_restrict <| hm _ <| h_meas n).symm.mul EventuallyEq.rfl)\n    · exact (indicator_ae_eq_restrict <| hm _ <| h_meas n).mul EventuallyEq.rfl\n  have : IsFiniteMeasure (μ.restrict (sets n)) := by\n    constructor\n    rw [Measure.restrict_apply_univ]\n    exact h_finite n\n  refine condExp_stronglyMeasurable_mul_of_bound hm (hf.indicator (h_meas n)) hg.integrableOn n ?_\n  filter_upwards with x\n  by_cases hxs : x ∈ sets n\n  · simpa only [hxs, Set.indicator_of_mem] using h_norm n x hxs\n  · simp only [hxs, Set.indicator_of_not_mem, not_false_iff, _root_.norm_zero, Nat.cast_nonneg]\n\n"}
{"name":"MeasureTheory.condexp_stronglyMeasurable_mul","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → Real\nhf : MeasureTheory.StronglyMeasurable f\nhfg : MeasureTheory.Integrable (HMul.hMul f g) μ\nhg : MeasureTheory.Integrable g μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m μ (HMul.hMul f g)) (HMul.hMul f (MeasureTheory.condExp m μ g))","decl":"@[deprecated (since := \"2025-01-22\")]\nalias condexp_stronglyMeasurable_mul := condExp_mul_of_stronglyMeasurable_left\n\n"}
{"name":"MeasureTheory.condExp_mul_of_stronglyMeasurable_right","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → Real\nhg : MeasureTheory.StronglyMeasurable g\nhfg : MeasureTheory.Integrable (HMul.hMul f g) μ\nhf : MeasureTheory.Integrable f μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m μ (HMul.hMul f g)) (HMul.hMul (MeasureTheory.condExp m μ f) g)","decl":"/-- Pull-out property of the conditional expectation. -/\nlemma condExp_mul_of_stronglyMeasurable_right {f g : α → ℝ} (hg : StronglyMeasurable[m] g)\n    (hfg : Integrable (f * g) μ) (hf : Integrable f μ) : μ[f * g | m] =ᵐ[μ] μ[f | m] * g := by\n  simpa [mul_comm] using condExp_mul_of_stronglyMeasurable_left hg (mul_comm f g ▸ hfg) hf\n\n"}
{"name":"MeasureTheory.condExp_mul_of_aestronglyMeasurable_left","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → Real\nhf : MeasureTheory.AEStronglyMeasurable f μ\nhfg : MeasureTheory.Integrable (HMul.hMul f g) μ\nhg : MeasureTheory.Integrable g μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m μ (HMul.hMul f g)) (HMul.hMul f (MeasureTheory.condExp m μ g))","decl":"/-- Pull-out property of the conditional expectation. -/\ntheorem condExp_mul_of_aestronglyMeasurable_left {f g : α → ℝ} (hf : AEStronglyMeasurable[m] f μ)\n    (hfg : Integrable (f * g) μ) (hg : Integrable g μ) : μ[f * g|m] =ᵐ[μ] f * μ[g|m] := by\n  have : μ[f * g|m] =ᵐ[μ] μ[hf.mk f * g|m] :=\n    condExp_congr_ae (hf.ae_eq_mk.mul EventuallyEq.rfl)\n  refine this.trans ?_\n  have : f * μ[g|m] =ᵐ[μ] hf.mk f * μ[g|m] := hf.ae_eq_mk.mul EventuallyEq.rfl\n  refine (condExp_mul_of_stronglyMeasurable_left hf.stronglyMeasurable_mk ?_ hg).trans this.symm\n  refine (integrable_congr ?_).mp hfg\n  exact hf.ae_eq_mk.mul EventuallyEq.rfl\n\n"}
{"name":"MeasureTheory.condexp_stronglyMeasurable_mul₀","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → Real\nhf : MeasureTheory.AEStronglyMeasurable f μ\nhfg : MeasureTheory.Integrable (HMul.hMul f g) μ\nhg : MeasureTheory.Integrable g μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m μ (HMul.hMul f g)) (HMul.hMul f (MeasureTheory.condExp m μ g))","decl":"@[deprecated (since := \"2025-01-22\")]\nalias condexp_stronglyMeasurable_mul₀ := condExp_mul_of_aestronglyMeasurable_left\n\n"}
{"name":"MeasureTheory.condExp_mul_of_aestronglyMeasurable_right","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → Real\nhg : MeasureTheory.AEStronglyMeasurable g μ\nhfg : MeasureTheory.Integrable (HMul.hMul f g) μ\nhf : MeasureTheory.Integrable f μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m μ (HMul.hMul f g)) (HMul.hMul (MeasureTheory.condExp m μ f) g)","decl":"/-- Pull-out property of the conditional expectation. -/\nlemma condExp_mul_of_aestronglyMeasurable_right {f g : α → ℝ} (hg : AEStronglyMeasurable[m] g μ)\n    (hfg : Integrable (f * g) μ) (hf : Integrable f μ) : μ[f * g | m] =ᵐ[μ] μ[f | m] * g := by\n  simpa [mul_comm] using condExp_mul_of_aestronglyMeasurable_left hg (mul_comm f g ▸ hfg) hf\n\n"}
