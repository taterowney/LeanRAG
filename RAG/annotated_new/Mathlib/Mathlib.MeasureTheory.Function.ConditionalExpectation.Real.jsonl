{"name":"MeasureTheory.rnDeriv_ae_eq_condExp","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nhm : LE.le m m0\nhÎ¼m : MeasureTheory.SigmaFinite (Î¼.trim hm)\nf : Î± â†’ Real\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.SignedMeasure.rnDeriv ((Î¼.withDensityáµ¥ f).trim hm) (Î¼.trim hm)) (MeasureTheory.condExp m Î¼ f)","decl":"theorem rnDeriv_ae_eq_condExp {hm : m â‰¤ m0} [hÎ¼m : SigmaFinite (Î¼.trim hm)] {f : Î± â†’ â„}\n    (hf : Integrable f Î¼) :\n    SignedMeasure.rnDeriv ((Î¼.withDensityáµ¥ f).trim hm) (Î¼.trim hm) =áµ[Î¼] Î¼[f|m] := by\n  refine ae_eq_condExp_of_forall_setIntegral_eq hm hf ?_ ?_ ?_\n  Â· exact fun _ _ _ => (integrable_of_integrable_trim hm\n      (SignedMeasure.integrable_rnDeriv ((Î¼.withDensityáµ¥ f).trim hm) (Î¼.trim hm))).integrableOn\n  Â· intro s hs _\n    conv_rhs => rw [â† hf.withDensityáµ¥_trim_eq_integral hm hs,\n      â† SignedMeasure.withDensityáµ¥_rnDeriv_eq ((Î¼.withDensityáµ¥ f).trim hm) (Î¼.trim hm)\n        (hf.withDensityáµ¥_trim_absolutelyContinuous hm)]\n    rw [withDensityáµ¥_apply\n      (SignedMeasure.integrable_rnDeriv ((Î¼.withDensityáµ¥ f).trim hm) (Î¼.trim hm)) hs,\n      â† setIntegral_trim hm _ hs]\n    exact (SignedMeasure.measurable_rnDeriv _ _).stronglyMeasurable\n  Â· exact (SignedMeasure.measurable_rnDeriv _ _).stronglyMeasurable.aestronglyMeasurable\n\n"}
{"name":"MeasureTheory.rnDeriv_ae_eq_condexp","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nhm : LE.le m m0\nhÎ¼m : MeasureTheory.SigmaFinite (Î¼.trim hm)\nf : Î± â†’ Real\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.SignedMeasure.rnDeriv ((Î¼.withDensityáµ¥ f).trim hm) (Î¼.trim hm)) (MeasureTheory.condExp m Î¼ f)","decl":"@[deprecated (since := \"2025-01-21\")] alias rnDeriv_ae_eq_condexp := rnDeriv_ae_eq_condExp\n\n-- TODO: the following couple of lemmas should be generalized and proved using Jensen's inequality\n-- for the conditional expectation (not in mathlib yet) .\n"}
{"name":"MeasureTheory.eLpNorm_one_condExp_le_eLpNorm","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nâŠ¢ LE.le (MeasureTheory.eLpNorm (MeasureTheory.condExp m Î¼ f) 1 Î¼) (MeasureTheory.eLpNorm f 1 Î¼)","decl":"theorem eLpNorm_one_condExp_le_eLpNorm (f : Î± â†’ â„) : eLpNorm (Î¼[f|m]) 1 Î¼ â‰¤ eLpNorm f 1 Î¼ := by\n  by_cases hf : Integrable f Î¼\n  swap; Â· rw [condExp_of_not_integrable hf, eLpNorm_zero]; exact zero_le _\n  by_cases hm : m â‰¤ m0\n  swap; Â· rw [condExp_of_not_le hm, eLpNorm_zero]; exact zero_le _\n  by_cases hsig : SigmaFinite (Î¼.trim hm)\n  swap; Â· rw [condExp_of_not_sigmaFinite hm hsig, eLpNorm_zero]; exact zero_le _\n  calc\n    eLpNorm (Î¼[f|m]) 1 Î¼ â‰¤ eLpNorm (Î¼[(|f|)|m]) 1 Î¼ := by\n      refine eLpNorm_mono_ae ?_\n      filter_upwards [condExp_mono hf hf.abs\n        (ae_of_all Î¼ (fun x => le_abs_self (f x) : âˆ€ x, f x â‰¤ |f x|)),\n        (condExp_neg ..).symm.le.trans (condExp_mono hf.neg hf.abs\n          (ae_of_all Î¼ (fun x => neg_le_abs (f x) : âˆ€ x, -f x â‰¤ |f x|)))] with x hxâ‚ hxâ‚‚\n      exact abs_le_abs hxâ‚ hxâ‚‚\n    _ = eLpNorm f 1 Î¼ := by\n      rw [eLpNorm_one_eq_lintegral_enorm, eLpNorm_one_eq_lintegral_enorm,\n        â† ENNReal.toReal_eq_toReal (hasFiniteIntegral_iff_enorm.mp integrable_condExp.2).ne\n          (hasFiniteIntegral_iff_enorm.mp hf.2).ne,\n        â† integral_norm_eq_lintegral_enorm\n          (stronglyMeasurable_condExp.mono hm).aestronglyMeasurable,\n        â† integral_norm_eq_lintegral_enorm hf.1]\n      simp_rw [Real.norm_eq_abs]\n      rw (config := {occs := .pos [2]}) [â† integral_condExp hm]\n      refine integral_congr_ae ?_\n      have : 0 â‰¤áµ[Î¼] Î¼[(|f|)|m] := by\n        rw [â† condExp_zero]\n        exact condExp_mono (integrable_zero _ _ _) hf.abs\n          (ae_of_all Î¼ (fun x => abs_nonneg (f x) : âˆ€ x, 0 â‰¤ |f x|))\n      filter_upwards [this] with x hx\n      exact abs_eq_self.2 hx\n\n"}
{"name":"MeasureTheory.eLpNorm_one_condexp_le_eLpNorm","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nâŠ¢ LE.le (MeasureTheory.eLpNorm (MeasureTheory.condExp m Î¼ f) 1 Î¼) (MeasureTheory.eLpNorm f 1 Î¼)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias eLpNorm_one_condexp_le_eLpNorm := eLpNorm_one_condExp_le_eLpNorm\n\n"}
{"name":"MeasureTheory.integral_abs_condExp_le","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nâŠ¢ LE.le (MeasureTheory.integral Î¼ fun x => abs (MeasureTheory.condExp m Î¼ f x)) (MeasureTheory.integral Î¼ fun x => abs (f x))","decl":"theorem integral_abs_condExp_le (f : Î± â†’ â„) : âˆ« x, |(Î¼[f|m]) x| âˆ‚Î¼ â‰¤ âˆ« x, |f x| âˆ‚Î¼ := by\n  by_cases hm : m â‰¤ m0\n  swap\n  Â· simp_rw [condExp_of_not_le hm, Pi.zero_apply, abs_zero, integral_zero]\n    positivity\n  by_cases hfint : Integrable f Î¼\n  swap\n  Â· simp only [condExp_of_not_integrable hfint, Pi.zero_apply, abs_zero, integral_const,\n      Algebra.id.smul_eq_mul, mul_zero]\n    positivity\n  rw [integral_eq_lintegral_of_nonneg_ae, integral_eq_lintegral_of_nonneg_ae]\n  Â· apply ENNReal.toReal_mono <;> simp_rw [â† Real.norm_eq_abs, ofReal_norm_eq_enorm]\n    Â· exact hfint.2.ne\n    Â· rw [â† eLpNorm_one_eq_lintegral_enorm, â† eLpNorm_one_eq_lintegral_enorm]\n      exact eLpNorm_one_condExp_le_eLpNorm _\n  Â· filter_upwards with x using abs_nonneg _\n  Â· simp_rw [â† Real.norm_eq_abs]\n    exact hfint.1.norm\n  Â· filter_upwards with x using abs_nonneg _\n  Â· simp_rw [â† Real.norm_eq_abs]\n    exact (stronglyMeasurable_condExp.mono hm).aestronglyMeasurable.norm\n\n"}
{"name":"MeasureTheory.integral_abs_condexp_le","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nâŠ¢ LE.le (MeasureTheory.integral Î¼ fun x => abs (MeasureTheory.condExp m Î¼ f x)) (MeasureTheory.integral Î¼ fun x => abs (f x))","decl":"@[deprecated (since := \"2025-01-21\")] alias integral_abs_condexp_le := integral_abs_condExp_le\n\n"}
{"name":"MeasureTheory.setIntegral_abs_condExp_le","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhs : MeasurableSet s\nf : Î± â†’ Real\nâŠ¢ LE.le (MeasureTheory.integral (Î¼.restrict s) fun x => abs (MeasureTheory.condExp m Î¼ f x)) (MeasureTheory.integral (Î¼.restrict s) fun x => abs (f x))","decl":"theorem setIntegral_abs_condExp_le {s : Set Î±} (hs : MeasurableSet[m] s) (f : Î± â†’ â„) :\n    âˆ« x in s, |(Î¼[f|m]) x| âˆ‚Î¼ â‰¤ âˆ« x in s, |f x| âˆ‚Î¼ := by\n  by_cases hnm : m â‰¤ m0\n  swap\n  Â· simp_rw [condExp_of_not_le hnm, Pi.zero_apply, abs_zero, integral_zero]\n    positivity\n  by_cases hfint : Integrable f Î¼\n  swap\n  Â· simp only [condExp_of_not_integrable hfint, Pi.zero_apply, abs_zero, integral_const,\n      Algebra.id.smul_eq_mul, mul_zero]\n    positivity\n  have : âˆ« x in s, |(Î¼[f|m]) x| âˆ‚Î¼ = âˆ« x, |(Î¼[s.indicator f|m]) x| âˆ‚Î¼ := by\n    rw [â† integral_indicator (hnm _ hs)]\n    refine integral_congr_ae ?_\n    have : (fun x => |(Î¼[s.indicator f|m]) x|) =áµ[Î¼] fun x => |s.indicator (Î¼[f|m]) x| :=\n      (condExp_indicator hfint hs).fun_comp abs\n    refine EventuallyEq.trans (Eventually.of_forall fun x => ?_) this.symm\n    rw [â† Real.norm_eq_abs, norm_indicator_eq_indicator_norm]\n    simp only [Real.norm_eq_abs]\n  rw [this, â† integral_indicator (hnm _ hs)]\n  refine (integral_abs_condExp_le _).trans\n    (le_of_eq <| integral_congr_ae <| Eventually.of_forall fun x => ?_)\n  simp_rw [â† Real.norm_eq_abs, norm_indicator_eq_indicator_norm]\n\n"}
{"name":"MeasureTheory.setIntegral_abs_condexp_le","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhs : MeasurableSet s\nf : Î± â†’ Real\nâŠ¢ LE.le (MeasureTheory.integral (Î¼.restrict s) fun x => abs (MeasureTheory.condExp m Î¼ f x)) (MeasureTheory.integral (Î¼.restrict s) fun x => abs (f x))","decl":"@[deprecated (since := \"2025-01-21\")] alias setIntegral_abs_condexp_le := setIntegral_abs_condExp_le\n\n"}
{"name":"MeasureTheory.ae_bdd_condExp_of_ae_bdd","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nR : NNReal\nf : Î± â†’ Real\nhbdd : Filter.Eventually (fun x => LE.le (abs (f x)) â†‘R) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Eventually (fun x => LE.le (abs (MeasureTheory.condExp m Î¼ f x)) â†‘R) (MeasureTheory.ae Î¼)","decl":"/-- If the real valued function `f` is bounded almost everywhere by `R`, then so is its conditional\nexpectation. -/\ntheorem ae_bdd_condExp_of_ae_bdd {R : â„â‰¥0} {f : Î± â†’ â„} (hbdd : âˆ€áµ x âˆ‚Î¼, |f x| â‰¤ R) :\n    âˆ€áµ x âˆ‚Î¼, |(Î¼[f|m]) x| â‰¤ R := by\n  by_cases hnm : m â‰¤ m0\n  swap\n  Â· simp_rw [condExp_of_not_le hnm, Pi.zero_apply, abs_zero]\n    exact Eventually.of_forall fun _ => R.coe_nonneg\n  by_cases hfint : Integrable f Î¼\n  swap\n  Â· simp_rw [condExp_of_not_integrable hfint]\n    filter_upwards [hbdd] with x hx\n    rw [Pi.zero_apply, abs_zero]\n    exact (abs_nonneg _).trans hx\n  by_contra h\n  change Î¼ _ â‰  0 at h\n  simp only [â† zero_lt_iff, Set.compl_def, Set.mem_setOf_eq, not_le] at h\n  suffices (Î¼ {x | â†‘R < |(Î¼[f|m]) x|}).toReal * â†‘R < (Î¼ {x | â†‘R < |(Î¼[f|m]) x|}).toReal * â†‘R by\n    exact this.ne rfl\n  refine lt_of_lt_of_le (setIntegral_gt_gt R.coe_nonneg ?_ h.ne') ?_\n  Â· exact integrable_condExp.abs.integrableOn\n  refine (setIntegral_abs_condExp_le ?_ _).trans ?_\n  Â· simp_rw [â† Real.norm_eq_abs]\n    exact @measurableSet_lt _ _ _ _ _ m _ _ _ _ _ measurable_const\n      stronglyMeasurable_condExp.norm.measurable\n  simp only [â† smul_eq_mul, â† setIntegral_const, NNReal.val_eq_coe, RCLike.ofReal_real_eq_id,\n    _root_.id]\n  refine setIntegral_mono_ae hfint.abs.integrableOn ?_ hbdd\n  refine âŸ¨aestronglyMeasurable_const, lt_of_le_of_lt ?_\n    (integrable_condExp.integrableOn : IntegrableOn (Î¼[f|m]) {x | â†‘R < |(Î¼[f|m]) x|} Î¼).2âŸ©\n  refine setLIntegral_mono\n    (stronglyMeasurable_condExp.mono hnm).measurable.nnnorm.coe_nnreal_ennreal fun x hx => ?_\n  rw [enorm_eq_nnnorm, enorm_eq_nnnorm, ENNReal.coe_le_coe, Real.nnnorm_of_nonneg R.coe_nonneg]\n  exact Subtype.mk_le_mk.2 (le_of_lt hx)\n\n"}
{"name":"MeasureTheory.ae_bdd_condexp_of_ae_bdd","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nR : NNReal\nf : Î± â†’ Real\nhbdd : Filter.Eventually (fun x => LE.le (abs (f x)) â†‘R) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Eventually (fun x => LE.le (abs (MeasureTheory.condExp m Î¼ f x)) â†‘R) (MeasureTheory.ae Î¼)","decl":"@[deprecated (since := \"2025-01-21\")] alias ae_bdd_condexp_of_ae_bdd := ae_bdd_condExp_of_ae_bdd\n\n"}
{"name":"MeasureTheory.Integrable.uniformIntegrable_condExp","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¹ : Type u_2\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\ng : Î± â†’ Real\nhint : MeasureTheory.Integrable g Î¼\nâ„± : Î¹ â†’ MeasurableSpace Î±\nhâ„± : âˆ€ (i : Î¹), LE.le (â„± i) m0\nâŠ¢ MeasureTheory.UniformIntegrable (fun i => MeasureTheory.condExp (â„± i) Î¼ g) 1 Î¼","decl":"/-- Given an integrable function `g`, the conditional expectations of `g` with respect to\na sequence of sub-Ïƒ-algebras is uniformly integrable. -/\ntheorem Integrable.uniformIntegrable_condExp {Î¹ : Type*} [IsFiniteMeasure Î¼] {g : Î± â†’ â„}\n    (hint : Integrable g Î¼) {â„± : Î¹ â†’ MeasurableSpace Î±} (hâ„± : âˆ€ i, â„± i â‰¤ m0) :\n    UniformIntegrable (fun i => Î¼[g|â„± i]) 1 Î¼ := by\n  let A : MeasurableSpace Î± := m0\n  have hmeas : âˆ€ n, âˆ€ C, MeasurableSet {x | C â‰¤ â€–(Î¼[g|â„± n]) xâ€–â‚Š} := fun n C =>\n    measurableSet_le measurable_const (stronglyMeasurable_condExp.mono (hâ„± n)).measurable.nnnorm\n  have hg : Memâ„’p g 1 Î¼ := memâ„’p_one_iff_integrable.2 hint\n  refine uniformIntegrable_of le_rfl ENNReal.one_ne_top\n    (fun n => (stronglyMeasurable_condExp.mono (hâ„± n)).aestronglyMeasurable) fun Îµ hÎµ => ?_\n  by_cases hne : eLpNorm g 1 Î¼ = 0\n  Â· rw [eLpNorm_eq_zero_iff hg.1 one_ne_zero] at hne\n    refine âŸ¨0, fun n => (le_of_eq <|\n      (eLpNorm_eq_zero_iff ((stronglyMeasurable_condExp.mono (hâ„± n)).aestronglyMeasurable.indicator\n        (hmeas n 0)) one_ne_zero).2 ?_).trans (zero_le _)âŸ©\n    filter_upwards [condExp_congr_ae (m := â„± n) hne] with x hx\n    simp only [zero_le', Set.setOf_true, Set.indicator_univ, Pi.zero_apply, hx, condExp_zero]\n  obtain âŸ¨Î´, hÎ´, hâŸ© := hg.eLpNorm_indicator_le le_rfl ENNReal.one_ne_top hÎµ\n  set C : â„â‰¥0 := âŸ¨Î´, hÎ´.leâŸ©â»Â¹ * (eLpNorm g 1 Î¼).toNNReal with hC\n  have hCpos : 0 < C := mul_pos (inv_pos.2 hÎ´) (ENNReal.toNNReal_pos hne hg.eLpNorm_lt_top.ne)\n  have : âˆ€ n, Î¼ {x : Î± | C â‰¤ â€–(Î¼[g|â„± n]) xâ€–â‚Š} â‰¤ ENNReal.ofReal Î´ := by\n    intro n\n    have := mul_meas_ge_le_pow_eLpNorm' Î¼ one_ne_zero ENNReal.one_ne_top\n      ((stronglyMeasurable_condExp (m := â„± n) (Î¼ := Î¼) (f := g)).mono (hâ„± n)).aestronglyMeasurable C\n    rw [ENNReal.one_toReal, ENNReal.rpow_one, ENNReal.rpow_one, mul_comm, â†\n      ENNReal.le_div_iff_mul_le (Or.inl (ENNReal.coe_ne_zero.2 hCpos.ne'))\n        (Or.inl ENNReal.coe_lt_top.ne)] at this\n    simp_rw [ENNReal.coe_le_coe] at this\n    refine this.trans ?_\n    rw [ENNReal.div_le_iff_le_mul (Or.inl (ENNReal.coe_ne_zero.2 hCpos.ne'))\n        (Or.inl ENNReal.coe_lt_top.ne),\n      hC, Nonneg.inv_mk, ENNReal.coe_mul, ENNReal.coe_toNNReal hg.eLpNorm_lt_top.ne, â† mul_assoc, â†\n      ENNReal.ofReal_eq_coe_nnreal, â† ENNReal.ofReal_mul hÎ´.le, mul_inv_cancelâ‚€ hÎ´.ne',\n      ENNReal.ofReal_one, one_mul]\n    exact eLpNorm_one_condExp_le_eLpNorm _\n  refine âŸ¨C, fun n => le_trans ?_ (h {x : Î± | C â‰¤ â€–(Î¼[g|â„± n]) xâ€–â‚Š} (hmeas n C) (this n))âŸ©\n  have hmeasâ„± : MeasurableSet[â„± n] {x : Î± | C â‰¤ â€–(Î¼[g|â„± n]) xâ€–â‚Š} :=\n    @measurableSet_le _ _ _ _ _ (â„± n) _ _ _ _ _ measurable_const\n      (@Measurable.nnnorm _ _ _ _ _ (â„± n) _ stronglyMeasurable_condExp.measurable)\n  rw [â† eLpNorm_congr_ae (condExp_indicator hint hmeasâ„±)]\n  exact eLpNorm_one_condExp_le_eLpNorm _\n\n"}
{"name":"MeasureTheory.Integrable.uniformIntegrable_condexp","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¹ : Type u_2\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\ng : Î± â†’ Real\nhint : MeasureTheory.Integrable g Î¼\nâ„± : Î¹ â†’ MeasurableSpace Î±\nhâ„± : âˆ€ (i : Î¹), LE.le (â„± i) m0\nâŠ¢ MeasureTheory.UniformIntegrable (fun i => MeasureTheory.condExp (â„± i) Î¼ g) 1 Î¼","decl":"@[deprecated (since := \"2025-01-21\")]\nalias Integrable.uniformIntegrable_condexp := Integrable.uniformIntegrable_condExp\n\n"}
{"name":"MeasureTheory.condExp_stronglyMeasurable_simpleFunc_mul","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nhm : LE.le m m0\nf : MeasureTheory.SimpleFunc Î± Real\ng : Î± â†’ Real\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (HMul.hMul (â‡‘f) g)) (HMul.hMul (â‡‘f) (MeasureTheory.condExp m Î¼ g))","decl":"/-- Auxiliary lemma for `condExp_mul_of_stronglyMeasurable_left`. -/\ntheorem condExp_stronglyMeasurable_simpleFunc_mul (hm : m â‰¤ m0) (f : @SimpleFunc Î± m â„) {g : Î± â†’ â„}\n    (hg : Integrable g Î¼) : Î¼[(f * g : Î± â†’ â„)|m] =áµ[Î¼] f * Î¼[g|m] := by\n  have : âˆ€ (s c) (f : Î± â†’ â„), Set.indicator s (Function.const Î± c) * f = s.indicator (c â€¢ f) := by\n    intro s c f\n    ext1 x\n    by_cases hx : x âˆˆ s\n    Â· simp only [hx, Pi.mul_apply, Set.indicator_of_mem, Pi.smul_apply, Algebra.id.smul_eq_mul,\n        Function.const_apply]\n    Â· simp only [hx, Pi.mul_apply, Set.indicator_of_not_mem, not_false_iff, zero_mul]\n  apply @SimpleFunc.induction _ _ m _ (fun f => _)\n    (fun c s hs => ?_) (fun gâ‚ gâ‚‚ _ h_eqâ‚ h_eqâ‚‚ => ?_) f\n  Â· -- Porting note: if not classical, `DecidablePred fun x â†¦ x âˆˆ s` cannot be synthesised\n    -- for `Set.piecewise_eq_indicator`\n    classical simp only [@SimpleFunc.const_zero _ _ m, @SimpleFunc.coe_piecewise _ _ m,\n      @SimpleFunc.coe_const _ _ m, @SimpleFunc.coe_zero _ _ m, Set.piecewise_eq_indicator]\n    rw [this, this]\n    refine (condExp_indicator (hg.smul c) hs).trans ?_\n    filter_upwards [condExp_smul c g m] with x hx\n    classical simp_rw [Set.indicator_apply, hx]\n  Â· have h_add := @SimpleFunc.coe_add _ _ m _ gâ‚ gâ‚‚\n    calc\n      Î¼[â‡‘(gâ‚ + gâ‚‚) * g|m] =áµ[Î¼] Î¼[(â‡‘gâ‚ + â‡‘gâ‚‚) * g|m] := by\n        refine condExp_congr_ae (EventuallyEq.mul ?_ EventuallyEq.rfl); rw [h_add]\n      _ =áµ[Î¼] Î¼[â‡‘gâ‚ * g|m] + Î¼[â‡‘gâ‚‚ * g|m] := by\n        rw [add_mul]; exact condExp_add (hg.simpleFunc_mul' hm _) (hg.simpleFunc_mul' hm _) _\n      _ =áµ[Î¼] â‡‘gâ‚ * Î¼[g|m] + â‡‘gâ‚‚ * Î¼[g|m] := EventuallyEq.add h_eqâ‚ h_eqâ‚‚\n      _ =áµ[Î¼] â‡‘(gâ‚ + gâ‚‚) * Î¼[g|m] := by rw [h_add, add_mul]\n\n"}
{"name":"MeasureTheory.condexp_stronglyMeasurable_simpleFunc_mul","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nhm : LE.le m m0\nf : MeasureTheory.SimpleFunc Î± Real\ng : Î± â†’ Real\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (HMul.hMul (â‡‘f) g)) (HMul.hMul (â‡‘f) (MeasureTheory.condExp m Î¼ g))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_stronglyMeasurable_simpleFunc_mul := condExp_stronglyMeasurable_simpleFunc_mul\n\n"}
{"name":"MeasureTheory.condExp_stronglyMeasurable_mul_of_bound","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nhm : LE.le m m0\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nf g : Î± â†’ Real\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.Integrable g Î¼\nc : Real\nhf_bound : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) c) (MeasureTheory.ae Î¼)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (HMul.hMul f g)) (HMul.hMul f (MeasureTheory.condExp m Î¼ g))","decl":"theorem condExp_stronglyMeasurable_mul_of_bound (hm : m â‰¤ m0) [IsFiniteMeasure Î¼] {f g : Î± â†’ â„}\n    (hf : StronglyMeasurable[m] f) (hg : Integrable g Î¼) (c : â„) (hf_bound : âˆ€áµ x âˆ‚Î¼, â€–f xâ€– â‰¤ c) :\n    Î¼[f * g|m] =áµ[Î¼] f * Î¼[g|m] := by\n  let fs := hf.approxBounded c\n  have hfs_tendsto : âˆ€áµ x âˆ‚Î¼, Tendsto (fs Â· x) atTop (ğ“ (f x)) :=\n    hf.tendsto_approxBounded_ae hf_bound\n  by_cases hÎ¼ : Î¼ = 0\n  Â· simp only [hÎ¼, ae_zero]; norm_cast\n  have : (ae Î¼).NeBot := ae_neBot.2 hÎ¼\n  have hc : 0 â‰¤ c := by\n    rcases hf_bound.exists with âŸ¨_x, hxâŸ©\n    exact (norm_nonneg _).trans hx\n  have hfs_bound : âˆ€ n x, â€–fs n xâ€– â‰¤ c := hf.norm_approxBounded_le hc\n  have : Î¼[f * Î¼[g|m]|m] = f * Î¼[g|m] := by\n    refine condExp_of_stronglyMeasurable hm (hf.mul stronglyMeasurable_condExp) ?_\n    exact integrable_condExp.bdd_mul' (hf.mono hm).aestronglyMeasurable hf_bound\n  rw [â† this]\n  refine tendsto_condExp_unique (fun n x => fs n x * g x) (fun n x => fs n x * (Î¼[g|m]) x) (f * g)\n    (f * Î¼[g|m]) ?_ ?_ ?_ ?_ (c * â€–g Â·â€–) ?_ (c * â€–(Î¼[g|m]) Â·â€–) ?_ ?_ ?_ ?_\n  Â· exact fun n => hg.bdd_mul' ((SimpleFunc.stronglyMeasurable (fs n)).mono hm).aestronglyMeasurable\n      (Eventually.of_forall (hfs_bound n))\n  Â· exact fun n => integrable_condExp.bdd_mul'\n      ((SimpleFunc.stronglyMeasurable (fs n)).mono hm).aestronglyMeasurable\n      (Eventually.of_forall (hfs_bound n))\n  Â· filter_upwards [hfs_tendsto] with x hx\n    exact hx.mul tendsto_const_nhds\n  Â· filter_upwards [hfs_tendsto] with x hx\n    exact hx.mul tendsto_const_nhds\n  Â· exact hg.norm.const_mul c\n  Â· fun_prop\n  Â· refine fun n => Eventually.of_forall fun x => ?_\n    exact (norm_mul_le _ _).trans (mul_le_mul_of_nonneg_right (hfs_bound n x) (norm_nonneg _))\n  Â· refine fun n => Eventually.of_forall fun x => ?_\n    exact (norm_mul_le _ _).trans (mul_le_mul_of_nonneg_right (hfs_bound n x) (norm_nonneg _))\n  Â· intro n\n    simp_rw [â† Pi.mul_apply]\n    refine (condExp_stronglyMeasurable_simpleFunc_mul hm _ hg).trans ?_\n    rw [condExp_of_stronglyMeasurable hm\n      ((SimpleFunc.stronglyMeasurable _).mul stronglyMeasurable_condExp) _]\n    exact integrable_condExp.bdd_mul'\n      ((SimpleFunc.stronglyMeasurable (fs n)).mono hm).aestronglyMeasurable\n      (Eventually.of_forall (hfs_bound n))\n\n"}
{"name":"MeasureTheory.condexp_stronglyMeasurable_mul_of_bound","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nhm : LE.le m m0\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nf g : Î± â†’ Real\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.Integrable g Î¼\nc : Real\nhf_bound : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) c) (MeasureTheory.ae Î¼)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (HMul.hMul f g)) (HMul.hMul f (MeasureTheory.condExp m Î¼ g))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_stronglyMeasurable_mul_of_bound := condExp_stronglyMeasurable_mul_of_bound\n\n"}
{"name":"MeasureTheory.condExp_stronglyMeasurable_mul_of_boundâ‚€","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nhm : LE.le m m0\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nf g : Î± â†’ Real\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nc : Real\nhf_bound : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) c) (MeasureTheory.ae Î¼)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (HMul.hMul f g)) (HMul.hMul f (MeasureTheory.condExp m Î¼ g))","decl":"theorem condExp_stronglyMeasurable_mul_of_boundâ‚€ (hm : m â‰¤ m0) [IsFiniteMeasure Î¼] {f g : Î± â†’ â„}\n    (hf : AEStronglyMeasurable[m] f Î¼) (hg : Integrable g Î¼) (c : â„)\n    (hf_bound : âˆ€áµ x âˆ‚Î¼, â€–f xâ€– â‰¤ c) : Î¼[f * g|m] =áµ[Î¼] f * Î¼[g|m] := by\n  have : Î¼[f * g|m] =áµ[Î¼] Î¼[hf.mk f * g|m] :=\n    condExp_congr_ae (EventuallyEq.mul hf.ae_eq_mk EventuallyEq.rfl)\n  refine this.trans ?_\n  have : f * Î¼[g|m] =áµ[Î¼] hf.mk f * Î¼[g|m] := EventuallyEq.mul hf.ae_eq_mk EventuallyEq.rfl\n  refine EventuallyEq.trans ?_ this.symm\n  refine condExp_stronglyMeasurable_mul_of_bound hm hf.stronglyMeasurable_mk hg c ?_\n  filter_upwards [hf_bound, hf.ae_eq_mk] with x hxc hx_eq\n  rwa [â† hx_eq]\n\n"}
{"name":"MeasureTheory.condexp_stronglyMeasurable_mul_of_boundâ‚€","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nhm : LE.le m m0\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nf g : Î± â†’ Real\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nc : Real\nhf_bound : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) c) (MeasureTheory.ae Î¼)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (HMul.hMul f g)) (HMul.hMul f (MeasureTheory.condExp m Î¼ g))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_stronglyMeasurable_mul_of_boundâ‚€ := condExp_stronglyMeasurable_mul_of_boundâ‚€\n\n"}
{"name":"MeasureTheory.condExp_mul_of_stronglyMeasurable_left","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ Real\nhf : MeasureTheory.StronglyMeasurable f\nhfg : MeasureTheory.Integrable (HMul.hMul f g) Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (HMul.hMul f g)) (HMul.hMul f (MeasureTheory.condExp m Î¼ g))","decl":"/-- Pull-out property of the conditional expectation. -/\ntheorem condExp_mul_of_stronglyMeasurable_left {f g : Î± â†’ â„} (hf : StronglyMeasurable[m] f)\n    (hfg : Integrable (f * g) Î¼) (hg : Integrable g Î¼) : Î¼[f * g|m] =áµ[Î¼] f * Î¼[g|m] := by\n  by_cases hm : m â‰¤ m0; swap; Â· simp_rw [condExp_of_not_le hm]; rw [mul_zero]\n  by_cases hÎ¼m : SigmaFinite (Î¼.trim hm)\n  swap; Â· simp_rw [condExp_of_not_sigmaFinite hm hÎ¼m]; rw [mul_zero]\n  haveI : SigmaFinite (Î¼.trim hm) := hÎ¼m\n  obtain âŸ¨sets, sets_prop, h_univâŸ© := hf.exists_spanning_measurableSet_norm_le hm Î¼\n  simp_rw [forall_and] at sets_prop\n  obtain âŸ¨h_meas, h_finite, h_normâŸ© := sets_prop\n  suffices âˆ€ n, âˆ€áµ x âˆ‚Î¼, x âˆˆ sets n â†’ (Î¼[f * g|m]) x = f x * (Î¼[g|m]) x by\n    rw [â† ae_all_iff] at this\n    filter_upwards [this] with x hx\n    obtain âŸ¨i, hiâŸ© : âˆƒ i, x âˆˆ sets i := by\n      have h_mem : x âˆˆ â‹ƒ i, sets i := by rw [h_univ]; exact Set.mem_univ _\n      simpa using h_mem\n    exact hx i hi\n  refine fun n => ae_imp_of_ae_restrict ?_\n  suffices (Î¼.restrict (sets n))[f * g|m] =áµ[Î¼.restrict (sets n)] f * (Î¼.restrict (sets n))[g|m] by\n    refine (condExp_restrict_ae_eq_restrict hm (h_meas n) hfg).symm.trans ?_\n    exact this.trans (EventuallyEq.rfl.mul (condExp_restrict_ae_eq_restrict hm (h_meas n) hg))\n  suffices (Î¼.restrict (sets n))[(sets n).indicator f * g|m] =áµ[Î¼.restrict (sets n)]\n      (sets n).indicator f * (Î¼.restrict (sets n))[g|m] by\n    refine EventuallyEq.trans ?_ (this.trans ?_)\n    Â· exact\n        condExp_congr_ae ((indicator_ae_eq_restrict <| hm _ <| h_meas n).symm.mul EventuallyEq.rfl)\n    Â· exact (indicator_ae_eq_restrict <| hm _ <| h_meas n).mul EventuallyEq.rfl\n  have : IsFiniteMeasure (Î¼.restrict (sets n)) := by\n    constructor\n    rw [Measure.restrict_apply_univ]\n    exact h_finite n\n  refine condExp_stronglyMeasurable_mul_of_bound hm (hf.indicator (h_meas n)) hg.integrableOn n ?_\n  filter_upwards with x\n  by_cases hxs : x âˆˆ sets n\n  Â· simpa only [hxs, Set.indicator_of_mem] using h_norm n x hxs\n  Â· simp only [hxs, Set.indicator_of_not_mem, not_false_iff, _root_.norm_zero, Nat.cast_nonneg]\n\n"}
{"name":"MeasureTheory.condexp_stronglyMeasurable_mul","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ Real\nhf : MeasureTheory.StronglyMeasurable f\nhfg : MeasureTheory.Integrable (HMul.hMul f g) Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (HMul.hMul f g)) (HMul.hMul f (MeasureTheory.condExp m Î¼ g))","decl":"@[deprecated (since := \"2025-01-22\")]\nalias condexp_stronglyMeasurable_mul := condExp_mul_of_stronglyMeasurable_left\n\n"}
{"name":"MeasureTheory.condExp_mul_of_stronglyMeasurable_right","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ Real\nhg : MeasureTheory.StronglyMeasurable g\nhfg : MeasureTheory.Integrable (HMul.hMul f g) Î¼\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (HMul.hMul f g)) (HMul.hMul (MeasureTheory.condExp m Î¼ f) g)","decl":"/-- Pull-out property of the conditional expectation. -/\nlemma condExp_mul_of_stronglyMeasurable_right {f g : Î± â†’ â„} (hg : StronglyMeasurable[m] g)\n    (hfg : Integrable (f * g) Î¼) (hf : Integrable f Î¼) : Î¼[f * g | m] =áµ[Î¼] Î¼[f | m] * g := by\n  simpa [mul_comm] using condExp_mul_of_stronglyMeasurable_left hg (mul_comm f g â–¸ hfg) hf\n\n"}
{"name":"MeasureTheory.condExp_mul_of_aestronglyMeasurable_left","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ Real\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nhfg : MeasureTheory.Integrable (HMul.hMul f g) Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (HMul.hMul f g)) (HMul.hMul f (MeasureTheory.condExp m Î¼ g))","decl":"/-- Pull-out property of the conditional expectation. -/\ntheorem condExp_mul_of_aestronglyMeasurable_left {f g : Î± â†’ â„} (hf : AEStronglyMeasurable[m] f Î¼)\n    (hfg : Integrable (f * g) Î¼) (hg : Integrable g Î¼) : Î¼[f * g|m] =áµ[Î¼] f * Î¼[g|m] := by\n  have : Î¼[f * g|m] =áµ[Î¼] Î¼[hf.mk f * g|m] :=\n    condExp_congr_ae (hf.ae_eq_mk.mul EventuallyEq.rfl)\n  refine this.trans ?_\n  have : f * Î¼[g|m] =áµ[Î¼] hf.mk f * Î¼[g|m] := hf.ae_eq_mk.mul EventuallyEq.rfl\n  refine (condExp_mul_of_stronglyMeasurable_left hf.stronglyMeasurable_mk ?_ hg).trans this.symm\n  refine (integrable_congr ?_).mp hfg\n  exact hf.ae_eq_mk.mul EventuallyEq.rfl\n\n"}
{"name":"MeasureTheory.condexp_stronglyMeasurable_mulâ‚€","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ Real\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nhfg : MeasureTheory.Integrable (HMul.hMul f g) Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (HMul.hMul f g)) (HMul.hMul f (MeasureTheory.condExp m Î¼ g))","decl":"@[deprecated (since := \"2025-01-22\")]\nalias condexp_stronglyMeasurable_mulâ‚€ := condExp_mul_of_aestronglyMeasurable_left\n\n"}
{"name":"MeasureTheory.condExp_mul_of_aestronglyMeasurable_right","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Real","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ Real\nhg : MeasureTheory.AEStronglyMeasurable g Î¼\nhfg : MeasureTheory.Integrable (HMul.hMul f g) Î¼\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (HMul.hMul f g)) (HMul.hMul (MeasureTheory.condExp m Î¼ f) g)","decl":"/-- Pull-out property of the conditional expectation. -/\nlemma condExp_mul_of_aestronglyMeasurable_right {f g : Î± â†’ â„} (hg : AEStronglyMeasurable[m] g Î¼)\n    (hfg : Integrable (f * g) Î¼) (hf : Integrable f Î¼) : Î¼[f * g | m] =áµ[Î¼] Î¼[f | m] * g := by\n  simpa [mul_comm] using condExp_mul_of_aestronglyMeasurable_left hg (mul_comm f g â–¸ hfg) hf\n\n"}
