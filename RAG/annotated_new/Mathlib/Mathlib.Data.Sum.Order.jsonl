{"name":"Sum.LiftRel.refl","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsRefl α r\ninst✝ : IsRefl β s\nx : Sum α β\n⊢ Sum.LiftRel r s x x","decl":"@[refl]\ntheorem LiftRel.refl [IsRefl α r] [IsRefl β s] : ∀ x, LiftRel r s x x\n  | inl a => LiftRel.inl (_root_.refl a)\n  | inr a => LiftRel.inr (_root_.refl a)\n\n"}
{"name":"Sum.instIsReflLiftRel","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsRefl α r\ninst✝ : IsRefl β s\n⊢ IsRefl (Sum α β) (Sum.LiftRel r s)","decl":"instance [IsRefl α r] [IsRefl β s] : IsRefl (α ⊕ β) (LiftRel r s) :=\n  ⟨LiftRel.refl _ _⟩\n\n"}
{"name":"Sum.instIsIrreflLiftRel","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsIrrefl α r\ninst✝ : IsIrrefl β s\n⊢ IsIrrefl (Sum α β) (Sum.LiftRel r s)","decl":"instance [IsIrrefl α r] [IsIrrefl β s] : IsIrrefl (α ⊕ β) (LiftRel r s) :=\n  ⟨by rintro _ (⟨h⟩ | ⟨h⟩) <;> exact irrefl _ h⟩\n\n"}
{"name":"Sum.LiftRel.trans","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsTrans α r\ninst✝ : IsTrans β s\na b c : Sum α β\na✝¹ : Sum.LiftRel r s a b\na✝ : Sum.LiftRel r s b c\n⊢ Sum.LiftRel r s a c","decl":"@[trans]\ntheorem LiftRel.trans [IsTrans α r] [IsTrans β s] :\n    ∀ {a b c}, LiftRel r s a b → LiftRel r s b c → LiftRel r s a c\n  | _, _, _, LiftRel.inl hab, LiftRel.inl hbc => LiftRel.inl <| _root_.trans hab hbc\n  | _, _, _, LiftRel.inr hab, LiftRel.inr hbc => LiftRel.inr <| _root_.trans hab hbc\n\n"}
{"name":"Sum.instIsTransLiftRel","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsTrans α r\ninst✝ : IsTrans β s\n⊢ IsTrans (Sum α β) (Sum.LiftRel r s)","decl":"instance [IsTrans α r] [IsTrans β s] : IsTrans (α ⊕ β) (LiftRel r s) :=\n  ⟨fun _ _ _ => LiftRel.trans _ _⟩\n\n"}
{"name":"Sum.instIsAntisymmLiftRel","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsAntisymm α r\ninst✝ : IsAntisymm β s\n⊢ IsAntisymm (Sum α β) (Sum.LiftRel r s)","decl":"instance [IsAntisymm α r] [IsAntisymm β s] : IsAntisymm (α ⊕ β) (LiftRel r s) :=\n  ⟨by rintro _ _ (⟨hab⟩ | ⟨hab⟩) (⟨hba⟩ | ⟨hba⟩) <;> rw [antisymm hab hba]⟩\n\n"}
{"name":"Sum.instIsReflLex","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsRefl α r\ninst✝ : IsRefl β s\n⊢ IsRefl (Sum α β) (Sum.Lex r s)","decl":"instance [IsRefl α r] [IsRefl β s] : IsRefl (α ⊕ β) (Lex r s) :=\n  ⟨by\n    rintro (a | a)\n    exacts [Lex.inl (refl _), Lex.inr (refl _)]⟩\n\n"}
{"name":"Sum.instIsIrreflLex","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsIrrefl α r\ninst✝ : IsIrrefl β s\n⊢ IsIrrefl (Sum α β) (Sum.Lex r s)","decl":"instance [IsIrrefl α r] [IsIrrefl β s] : IsIrrefl (α ⊕ β) (Lex r s) :=\n  ⟨by rintro _ (⟨h⟩ | ⟨h⟩) <;> exact irrefl _ h⟩\n\n"}
{"name":"Sum.instIsTransLex","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsTrans α r\ninst✝ : IsTrans β s\n⊢ IsTrans (Sum α β) (Sum.Lex r s)","decl":"instance [IsTrans α r] [IsTrans β s] : IsTrans (α ⊕ β) (Lex r s) :=\n  ⟨by\n    rintro _ _ _ (⟨hab⟩ | ⟨hab⟩) (⟨hbc⟩ | ⟨hbc⟩)\n    exacts [.inl (_root_.trans hab hbc), .sep _ _, .inr (_root_.trans hab hbc), .sep _ _]⟩\n\n"}
{"name":"Sum.instIsAntisymmLex","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsAntisymm α r\ninst✝ : IsAntisymm β s\n⊢ IsAntisymm (Sum α β) (Sum.Lex r s)","decl":"instance [IsAntisymm α r] [IsAntisymm β s] : IsAntisymm (α ⊕ β) (Lex r s) :=\n  ⟨by rintro _ _ (⟨hab⟩ | ⟨hab⟩) (⟨hba⟩ | ⟨hba⟩) <;> rw [antisymm hab hba]⟩\n\n"}
{"name":"Sum.instIsTotalLex","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsTotal α r\ninst✝ : IsTotal β s\n⊢ IsTotal (Sum α β) (Sum.Lex r s)","decl":"instance [IsTotal α r] [IsTotal β s] : IsTotal (α ⊕ β) (Lex r s) :=\n  ⟨fun a b =>\n    match a, b with\n    | inl a, inl b => (total_of r a b).imp Lex.inl Lex.inl\n    | inl _, inr _ => Or.inl (Lex.sep _ _)\n    | inr _, inl _ => Or.inr (Lex.sep _ _)\n    | inr a, inr b => (total_of s a b).imp Lex.inr Lex.inr⟩\n\n"}
{"name":"Sum.instIsTrichotomousLex","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsTrichotomous α r\ninst✝ : IsTrichotomous β s\n⊢ IsTrichotomous (Sum α β) (Sum.Lex r s)","decl":"instance [IsTrichotomous α r] [IsTrichotomous β s] : IsTrichotomous (α ⊕ β) (Lex r s) :=\n  ⟨fun a b =>\n    match a, b with\n    | inl a, inl b => (trichotomous_of r a b).imp3 Lex.inl (congr_arg _) Lex.inl\n    | inl _, inr _ => Or.inl (Lex.sep _ _)\n    | inr _, inl _ => Or.inr (Or.inr <| Lex.sep _ _)\n    | inr a, inr b => (trichotomous_of s a b).imp3 Lex.inr (congr_arg _) Lex.inr⟩\n\n"}
{"name":"Sum.instIsWellOrderLex","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\n⊢ IsWellOrder (Sum α β) (Sum.Lex r s)","decl":"instance [IsWellOrder α r] [IsWellOrder β s] :\n    IsWellOrder (α ⊕ β) (Sum.Lex r s) where wf := Sum.lex_wf IsWellFounded.wf IsWellFounded.wf\n\n"}
{"name":"Sum.le_def","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\na b : Sum α β\n⊢ Iff (LE.le a b) (Sum.LiftRel (fun x1 x2 => LE.le x1 x2) (fun x1 x2 => LE.le x1 x2) a b)","decl":"theorem le_def [LE α] [LE β] {a b : α ⊕ β} : a ≤ b ↔ LiftRel (· ≤ ·) (· ≤ ·) a b :=\n  Iff.rfl\n\n"}
{"name":"Sum.lt_def","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\na b : Sum α β\n⊢ Iff (LT.lt a b) (Sum.LiftRel (fun x1 x2 => LT.lt x1 x2) (fun x1 x2 => LT.lt x1 x2) a b)","decl":"theorem lt_def [LT α] [LT β] {a b : α ⊕ β} : a < b ↔ LiftRel (· < ·) (· < ·) a b :=\n  Iff.rfl\n\n"}
{"name":"Sum.inl_le_inl_iff","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\na b : α\n⊢ Iff (LE.le (Sum.inl a) (Sum.inl b)) (LE.le a b)","decl":"@[simp]\ntheorem inl_le_inl_iff [LE α] [LE β] {a b : α} : (inl a : α ⊕ β) ≤ inl b ↔ a ≤ b :=\n  liftRel_inl_inl\n\n"}
{"name":"Sum.inr_le_inr_iff","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\na b : β\n⊢ Iff (LE.le (Sum.inr a) (Sum.inr b)) (LE.le a b)","decl":"@[simp]\ntheorem inr_le_inr_iff [LE α] [LE β] {a b : β} : (inr a : α ⊕ β) ≤ inr b ↔ a ≤ b :=\n  liftRel_inr_inr\n\n"}
{"name":"Sum.inl_lt_inl_iff","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\na b : α\n⊢ Iff (LT.lt (Sum.inl a) (Sum.inl b)) (LT.lt a b)","decl":"@[simp]\ntheorem inl_lt_inl_iff [LT α] [LT β] {a b : α} : (inl a : α ⊕ β) < inl b ↔ a < b :=\n  liftRel_inl_inl\n\n"}
{"name":"Sum.inr_lt_inr_iff","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\na b : β\n⊢ Iff (LT.lt (Sum.inr a) (Sum.inr b)) (LT.lt a b)","decl":"@[simp]\ntheorem inr_lt_inr_iff [LT α] [LT β] {a b : β} : (inr a : α ⊕ β) < inr b ↔ a < b :=\n  liftRel_inr_inr\n\n"}
{"name":"Sum.not_inl_le_inr","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\na : α\nb : β\n⊢ Not (LE.le (Sum.inl b) (Sum.inr a))","decl":"@[simp]\ntheorem not_inl_le_inr [LE α] [LE β] {a : α} {b : β} : ¬inl b ≤ inr a :=\n  not_liftRel_inl_inr\n\n"}
{"name":"Sum.not_inl_lt_inr","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\na : α\nb : β\n⊢ Not (LT.lt (Sum.inl b) (Sum.inr a))","decl":"@[simp]\ntheorem not_inl_lt_inr [LT α] [LT β] {a : α} {b : β} : ¬inl b < inr a :=\n  not_liftRel_inl_inr\n\n"}
{"name":"Sum.not_inr_le_inl","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\na : α\nb : β\n⊢ Not (LE.le (Sum.inr b) (Sum.inl a))","decl":"@[simp]\ntheorem not_inr_le_inl [LE α] [LE β] {a : α} {b : β} : ¬inr b ≤ inl a :=\n  not_liftRel_inr_inl\n\n"}
{"name":"Sum.not_inr_lt_inl","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\na : α\nb : β\n⊢ Not (LT.lt (Sum.inr b) (Sum.inl a))","decl":"@[simp]\ntheorem not_inr_lt_inl [LT α] [LT β] {a : α} {b : β} : ¬inr b < inl a :=\n  not_liftRel_inr_inl\n\n"}
{"name":"Sum.inl_mono","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\n⊢ Monotone Sum.inl","decl":"theorem inl_mono : Monotone (inl : α → α ⊕ β) := fun _ _ => LiftRel.inl\n\n"}
{"name":"Sum.inr_mono","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\n⊢ Monotone Sum.inr","decl":"theorem inr_mono : Monotone (inr : β → α ⊕ β) := fun _ _ => LiftRel.inr\n\n"}
{"name":"Sum.inl_strictMono","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\n⊢ StrictMono Sum.inl","decl":"theorem inl_strictMono : StrictMono (inl : α → α ⊕ β) := fun _ _ => LiftRel.inl\n\n"}
{"name":"Sum.inr_strictMono","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\n⊢ StrictMono Sum.inr","decl":"theorem inr_strictMono : StrictMono (inr : β → α ⊕ β) := fun _ _ => LiftRel.inr\n\n"}
{"name":"Sum.noMinOrder","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : LT α\ninst✝² : LT β\ninst✝¹ : NoMinOrder α\ninst✝ : NoMinOrder β\n⊢ NoMinOrder (Sum α β)","decl":"instance noMinOrder [LT α] [LT β] [NoMinOrder α] [NoMinOrder β] : NoMinOrder (α ⊕ β) :=\n  ⟨fun a =>\n    match a with\n    | inl a =>\n      let ⟨b, h⟩ := exists_lt a\n      ⟨inl b, inl_lt_inl_iff.2 h⟩\n    | inr a =>\n      let ⟨b, h⟩ := exists_lt a\n      ⟨inr b, inr_lt_inr_iff.2 h⟩⟩\n\n"}
{"name":"Sum.noMaxOrder","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : LT α\ninst✝² : LT β\ninst✝¹ : NoMaxOrder α\ninst✝ : NoMaxOrder β\n⊢ NoMaxOrder (Sum α β)","decl":"instance noMaxOrder [LT α] [LT β] [NoMaxOrder α] [NoMaxOrder β] : NoMaxOrder (α ⊕ β) :=\n  ⟨fun a =>\n    match a with\n    | inl a =>\n      let ⟨b, h⟩ := exists_gt a\n      ⟨inl b, inl_lt_inl_iff.2 h⟩\n    | inr a =>\n      let ⟨b, h⟩ := exists_gt a\n      ⟨inr b, inr_lt_inr_iff.2 h⟩⟩\n\n"}
{"name":"Sum.noMinOrder_iff","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\n⊢ Iff (NoMinOrder (Sum α β)) (And (NoMinOrder α) (NoMinOrder β))","decl":"@[simp]\ntheorem noMinOrder_iff [LT α] [LT β] : NoMinOrder (α ⊕ β) ↔ NoMinOrder α ∧ NoMinOrder β :=\n  ⟨fun _ =>\n    ⟨⟨fun a => by\n        obtain ⟨b | b, h⟩ := exists_lt (inl a : α ⊕ β)\n        · exact ⟨b, inl_lt_inl_iff.1 h⟩\n        · exact (not_inr_lt_inl h).elim⟩,\n      ⟨fun a => by\n        obtain ⟨b | b, h⟩ := exists_lt (inr a : α ⊕ β)\n        · exact (not_inl_lt_inr h).elim\n        · exact ⟨b, inr_lt_inr_iff.1 h⟩⟩⟩,\n    fun h => @Sum.noMinOrder _ _ _ _ h.1 h.2⟩\n\n"}
{"name":"Sum.noMaxOrder_iff","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\n⊢ Iff (NoMaxOrder (Sum α β)) (And (NoMaxOrder α) (NoMaxOrder β))","decl":"@[simp]\ntheorem noMaxOrder_iff [LT α] [LT β] : NoMaxOrder (α ⊕ β) ↔ NoMaxOrder α ∧ NoMaxOrder β :=\n  ⟨fun _ =>\n    ⟨⟨fun a => by\n        obtain ⟨b | b, h⟩ := exists_gt (inl a : α ⊕ β)\n        · exact ⟨b, inl_lt_inl_iff.1 h⟩\n        · exact (not_inl_lt_inr h).elim⟩,\n      ⟨fun a => by\n        obtain ⟨b | b, h⟩ := exists_gt (inr a : α ⊕ β)\n        · exact (not_inr_lt_inl h).elim\n        · exact ⟨b, inr_lt_inr_iff.1 h⟩⟩⟩,\n    fun h => @Sum.noMaxOrder _ _ _ _ h.1 h.2⟩\n\n"}
{"name":"Sum.denselyOrdered","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : LT α\ninst✝² : LT β\ninst✝¹ : DenselyOrdered α\ninst✝ : DenselyOrdered β\n⊢ DenselyOrdered (Sum α β)","decl":"instance denselyOrdered [LT α] [LT β] [DenselyOrdered α] [DenselyOrdered β] :\n    DenselyOrdered (α ⊕ β) :=\n  ⟨fun a b h =>\n    match a, b, h with\n    | inl _, inl _, LiftRel.inl h =>\n      let ⟨c, ha, hb⟩ := exists_between h\n      ⟨toLex (inl c), LiftRel.inl ha, LiftRel.inl hb⟩\n    | inr _, inr _, LiftRel.inr h =>\n      let ⟨c, ha, hb⟩ := exists_between h\n      ⟨toLex (inr c), LiftRel.inr ha, LiftRel.inr hb⟩⟩\n\n"}
{"name":"Sum.denselyOrdered_iff","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\n⊢ Iff (DenselyOrdered (Sum α β)) (And (DenselyOrdered α) (DenselyOrdered β))","decl":"@[simp]\ntheorem denselyOrdered_iff [LT α] [LT β] :\n    DenselyOrdered (α ⊕ β) ↔ DenselyOrdered α ∧ DenselyOrdered β :=\n  ⟨fun _ =>\n    ⟨⟨fun a b h => by\n        obtain ⟨c | c, ha, hb⟩ := @exists_between (α ⊕ β) _ _ _ _ (inl_lt_inl_iff.2 h)\n        · exact ⟨c, inl_lt_inl_iff.1 ha, inl_lt_inl_iff.1 hb⟩\n        · exact (not_inl_lt_inr ha).elim⟩,\n      ⟨fun a b h => by\n        obtain ⟨c | c, ha, hb⟩ := @exists_between (α ⊕ β) _ _ _ _ (inr_lt_inr_iff.2 h)\n        · exact (not_inl_lt_inr hb).elim\n        · exact ⟨c, inr_lt_inr_iff.1 ha, inr_lt_inr_iff.1 hb⟩⟩⟩,\n    fun h => @Sum.denselyOrdered _ _ _ _ h.1 h.2⟩\n\n"}
{"name":"Sum.swap_le_swap_iff","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\na b : Sum α β\n⊢ Iff (LE.le a.swap b.swap) (LE.le a b)","decl":"@[simp]\ntheorem swap_le_swap_iff [LE α] [LE β] {a b : α ⊕ β} : a.swap ≤ b.swap ↔ a ≤ b :=\n  liftRel_swap_iff\n\n"}
{"name":"Sum.swap_lt_swap_iff","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\na b : Sum α β\n⊢ Iff (LT.lt a.swap b.swap) (LT.lt a b)","decl":"@[simp]\ntheorem swap_lt_swap_iff [LT α] [LT β] {a b : α ⊕ β} : a.swap < b.swap ↔ a < b :=\n  liftRel_swap_iff\n\n"}
{"name":"Sum.Lex.toLex_le_toLex","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\na b : Sum α β\n⊢ Iff (LE.le (toLex a) (toLex b)) (Sum.Lex (fun x1 x2 => LE.le x1 x2) (fun x1 x2 => LE.le x1 x2) a b)","decl":"@[simp]\ntheorem toLex_le_toLex [LE α] [LE β] {a b : α ⊕ β} :\n    toLex a ≤ toLex b ↔ Lex (· ≤ ·) (· ≤ ·) a b :=\n  Iff.rfl\n\n"}
{"name":"Sum.Lex.toLex_lt_toLex","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\na b : Sum α β\n⊢ Iff (LT.lt (toLex a) (toLex b)) (Sum.Lex (fun x1 x2 => LT.lt x1 x2) (fun x1 x2 => LT.lt x1 x2) a b)","decl":"@[simp]\ntheorem toLex_lt_toLex [LT α] [LT β] {a b : α ⊕ β} :\n    toLex a < toLex b ↔ Lex (· < ·) (· < ·) a b :=\n  Iff.rfl\n\n"}
{"name":"Sum.Lex.le_def","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\na b : Lex (Sum α β)\n⊢ Iff (LE.le a b) (Sum.Lex (fun x1 x2 => LE.le x1 x2) (fun x1 x2 => LE.le x1 x2) (ofLex a) (ofLex b))","decl":"theorem le_def [LE α] [LE β] {a b : α ⊕ₗ β} : a ≤ b ↔ Lex (· ≤ ·) (· ≤ ·) (ofLex a) (ofLex b) :=\n  Iff.rfl\n\n"}
{"name":"Sum.Lex.lt_def","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\na b : Lex (Sum α β)\n⊢ Iff (LT.lt a b) (Sum.Lex (fun x1 x2 => LT.lt x1 x2) (fun x1 x2 => LT.lt x1 x2) (ofLex a) (ofLex b))","decl":"theorem lt_def [LT α] [LT β] {a b : α ⊕ₗ β} : a < b ↔ Lex (· < ·) (· < ·) (ofLex a) (ofLex b) :=\n  Iff.rfl\n\n"}
{"name":"Sum.Lex.inl_le_inl_iff","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\na b : α\n⊢ Iff (LE.le (toLex (Sum.inl a)) (toLex (Sum.inl b))) (LE.le a b)","decl":"theorem inl_le_inl_iff [LE α] [LE β] {a b : α} : toLex (inl a : α ⊕ β) ≤ toLex (inl b) ↔ a ≤ b :=\n  lex_inl_inl\n\n"}
{"name":"Sum.Lex.inr_le_inr_iff","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\na b : β\n⊢ Iff (LE.le (toLex (Sum.inr a)) (toLex (Sum.inr b))) (LE.le a b)","decl":"theorem inr_le_inr_iff [LE α] [LE β] {a b : β} : toLex (inr a : α ⊕ β) ≤ toLex (inr b) ↔ a ≤ b :=\n  lex_inr_inr\n\n"}
{"name":"Sum.Lex.inl_lt_inl_iff","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\na b : α\n⊢ Iff (LT.lt (toLex (Sum.inl a)) (toLex (Sum.inl b))) (LT.lt a b)","decl":"theorem inl_lt_inl_iff [LT α] [LT β] {a b : α} : toLex (inl a : α ⊕ β) < toLex (inl b) ↔ a < b :=\n  lex_inl_inl\n\n"}
{"name":"Sum.Lex.inr_lt_inr_iff","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\na b : β\n⊢ Iff (LT.lt (toLex (Sum.inr a)) (toLex (Sum.inr b))) (LT.lt a b)","decl":"theorem inr_lt_inr_iff [LT α] [LT β] {a b : β} : toLex (inr a : α ⊕ₗ β) < toLex (inr b) ↔ a < b :=\n  lex_inr_inr\n\n"}
{"name":"Sum.Lex.inl_le_inr","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\na : α\nb : β\n⊢ LE.le (toLex (Sum.inl a)) (toLex (Sum.inr b))","decl":"theorem inl_le_inr [LE α] [LE β] (a : α) (b : β) : toLex (inl a) ≤ toLex (inr b) :=\n  Lex.sep _ _\n\n"}
{"name":"Sum.Lex.inl_lt_inr","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\na : α\nb : β\n⊢ LT.lt (toLex (Sum.inl a)) (toLex (Sum.inr b))","decl":"theorem inl_lt_inr [LT α] [LT β] (a : α) (b : β) : toLex (inl a) < toLex (inr b) :=\n  Lex.sep _ _\n\n"}
{"name":"Sum.Lex.not_inr_le_inl","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\na : α\nb : β\n⊢ Not (LE.le (toLex (Sum.inr b)) (toLex (Sum.inl a)))","decl":"theorem not_inr_le_inl [LE α] [LE β] {a : α} {b : β} : ¬toLex (inr b) ≤ toLex (inl a) :=\n  lex_inr_inl\n\n"}
{"name":"Sum.Lex.not_inr_lt_inl","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\na : α\nb : β\n⊢ Not (LT.lt (toLex (Sum.inr b)) (toLex (Sum.inl a)))","decl":"theorem not_inr_lt_inl [LT α] [LT β] {a : α} {b : β} : ¬toLex (inr b) < toLex (inl a) :=\n  lex_inr_inl\n\n"}
{"name":"Sum.Lex.toLex_mono","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\n⊢ Monotone ⇑toLex","decl":"theorem toLex_mono : Monotone (@toLex (α ⊕ β)) := fun _ _ h => h.lex\n\n"}
{"name":"Sum.Lex.toLex_strictMono","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\n⊢ StrictMono ⇑toLex","decl":"theorem toLex_strictMono : StrictMono (@toLex (α ⊕ β)) := fun _ _ h => h.lex\n\n"}
{"name":"Sum.Lex.inl_mono","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\n⊢ Monotone (Function.comp (⇑toLex) Sum.inl)","decl":"theorem inl_mono : Monotone (toLex ∘ inl : α → α ⊕ₗ β) :=\n  toLex_mono.comp Sum.inl_mono\n\n"}
{"name":"Sum.Lex.inr_mono","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\n⊢ Monotone (Function.comp (⇑toLex) Sum.inr)","decl":"theorem inr_mono : Monotone (toLex ∘ inr : β → α ⊕ₗ β) :=\n  toLex_mono.comp Sum.inr_mono\n\n"}
{"name":"Sum.Lex.inl_strictMono","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\n⊢ StrictMono (Function.comp (⇑toLex) Sum.inl)","decl":"theorem inl_strictMono : StrictMono (toLex ∘ inl : α → α ⊕ₗ β) :=\n  toLex_strictMono.comp Sum.inl_strictMono\n\n"}
{"name":"Sum.Lex.inr_strictMono","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\n⊢ StrictMono (Function.comp (⇑toLex) Sum.inr)","decl":"theorem inr_strictMono : StrictMono (toLex ∘ inr : β → α ⊕ₗ β) :=\n  toLex_strictMono.comp Sum.inr_strictMono\n\n"}
{"name":"Sum.Lex.inl_bot","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LE α\ninst✝¹ : OrderBot α\ninst✝ : LE β\n⊢ Eq (toLex (Sum.inl Bot.bot)) Bot.bot","decl":"@[simp]\ntheorem inl_bot [LE α] [OrderBot α] [LE β] : toLex (inl ⊥ : α ⊕ β) = ⊥ :=\n  rfl\n\n"}
{"name":"Sum.Lex.inr_top","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LE α\ninst✝¹ : LE β\ninst✝ : OrderTop β\n⊢ Eq (toLex (Sum.inr Top.top)) Top.top","decl":"@[simp]\ntheorem inr_top [LE α] [LE β] [OrderTop β] : toLex (inr ⊤ : α ⊕ β) = ⊤ :=\n  rfl\n\n"}
{"name":"Sum.Lex.noMinOrder","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : LT α\ninst✝² : LT β\ninst✝¹ : NoMinOrder α\ninst✝ : NoMinOrder β\n⊢ NoMinOrder (Lex (Sum α β))","decl":"instance noMinOrder [LT α] [LT β] [NoMinOrder α] [NoMinOrder β] : NoMinOrder (α ⊕ₗ β) :=\n  ⟨fun a =>\n    match a with\n    | inl a =>\n      let ⟨b, h⟩ := exists_lt a\n      ⟨toLex (inl b), inl_lt_inl_iff.2 h⟩\n    | inr a =>\n      let ⟨b, h⟩ := exists_lt a\n      ⟨toLex (inr b), inr_lt_inr_iff.2 h⟩⟩\n\n"}
{"name":"Sum.Lex.noMaxOrder","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : LT α\ninst✝² : LT β\ninst✝¹ : NoMaxOrder α\ninst✝ : NoMaxOrder β\n⊢ NoMaxOrder (Lex (Sum α β))","decl":"instance noMaxOrder [LT α] [LT β] [NoMaxOrder α] [NoMaxOrder β] : NoMaxOrder (α ⊕ₗ β) :=\n  ⟨fun a =>\n    match a with\n    | inl a =>\n      let ⟨b, h⟩ := exists_gt a\n      ⟨toLex (inl b), inl_lt_inl_iff.2 h⟩\n    | inr a =>\n      let ⟨b, h⟩ := exists_gt a\n      ⟨toLex (inr b), inr_lt_inr_iff.2 h⟩⟩\n\n"}
{"name":"Sum.Lex.noMinOrder_of_nonempty","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : LT α\ninst✝² : LT β\ninst✝¹ : NoMinOrder α\ninst✝ : Nonempty α\n⊢ NoMinOrder (Lex (Sum α β))","decl":"instance noMinOrder_of_nonempty [LT α] [LT β] [NoMinOrder α] [Nonempty α] : NoMinOrder (α ⊕ₗ β) :=\n  ⟨fun a =>\n    match a with\n    | inl a =>\n      let ⟨b, h⟩ := exists_lt a\n      ⟨toLex (inl b), inl_lt_inl_iff.2 h⟩\n    | inr _ => ⟨toLex (inl <| Classical.arbitrary α), inl_lt_inr _ _⟩⟩\n\n"}
{"name":"Sum.Lex.noMaxOrder_of_nonempty","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : LT α\ninst✝² : LT β\ninst✝¹ : NoMaxOrder β\ninst✝ : Nonempty β\n⊢ NoMaxOrder (Lex (Sum α β))","decl":"instance noMaxOrder_of_nonempty [LT α] [LT β] [NoMaxOrder β] [Nonempty β] : NoMaxOrder (α ⊕ₗ β) :=\n  ⟨fun a =>\n    match a with\n    | inl _ => ⟨toLex (inr <| Classical.arbitrary β), inl_lt_inr _ _⟩\n    | inr a =>\n      let ⟨b, h⟩ := exists_gt a\n      ⟨toLex (inr b), inr_lt_inr_iff.2 h⟩⟩\n\n"}
{"name":"Sum.Lex.denselyOrdered_of_noMaxOrder","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : LT α\ninst✝³ : LT β\ninst✝² : DenselyOrdered α\ninst✝¹ : DenselyOrdered β\ninst✝ : NoMaxOrder α\n⊢ DenselyOrdered (Lex (Sum α β))","decl":"instance denselyOrdered_of_noMaxOrder [LT α] [LT β] [DenselyOrdered α] [DenselyOrdered β]\n    [NoMaxOrder α] : DenselyOrdered (α ⊕ₗ β) :=\n  ⟨fun a b h =>\n    match a, b, h with\n    | inl _, inl _, Lex.inl h =>\n      let ⟨c, ha, hb⟩ := exists_between h\n      ⟨toLex (inl c), inl_lt_inl_iff.2 ha, inl_lt_inl_iff.2 hb⟩\n    | inl a, inr _, Lex.sep _ _ =>\n      let ⟨c, h⟩ := exists_gt a\n      ⟨toLex (inl c), inl_lt_inl_iff.2 h, inl_lt_inr _ _⟩\n    | inr _, inr _, Lex.inr h =>\n      let ⟨c, ha, hb⟩ := exists_between h\n      ⟨toLex (inr c), inr_lt_inr_iff.2 ha, inr_lt_inr_iff.2 hb⟩⟩\n\n"}
{"name":"Sum.Lex.denselyOrdered_of_noMinOrder","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : LT α\ninst✝³ : LT β\ninst✝² : DenselyOrdered α\ninst✝¹ : DenselyOrdered β\ninst✝ : NoMinOrder β\n⊢ DenselyOrdered (Lex (Sum α β))","decl":"instance denselyOrdered_of_noMinOrder [LT α] [LT β] [DenselyOrdered α] [DenselyOrdered β]\n    [NoMinOrder β] : DenselyOrdered (α ⊕ₗ β) :=\n  ⟨fun a b h =>\n    match a, b, h with\n    | inl _, inl _, Lex.inl h =>\n      let ⟨c, ha, hb⟩ := exists_between h\n      ⟨toLex (inl c), inl_lt_inl_iff.2 ha, inl_lt_inl_iff.2 hb⟩\n    | inl _, inr b, Lex.sep _ _ =>\n      let ⟨c, h⟩ := exists_lt b\n      ⟨toLex (inr c), inl_lt_inr _ _, inr_lt_inr_iff.2 h⟩\n    | inr _, inr _, Lex.inr h =>\n      let ⟨c, ha, hb⟩ := exists_between h\n      ⟨toLex (inr c), inr_lt_inr_iff.2 ha, inr_lt_inr_iff.2 hb⟩⟩\n\n"}
{"name":"OrderIso.sumComm_apply","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : LE α\ninst✝ : LE β\na✝ : Sum α β\n⊢ Eq ((OrderIso.sumComm α β) a✝) a✝.swap","decl":"/-- `Equiv.sumComm` promoted to an order isomorphism. -/\n@[simps! apply]\ndef sumComm (α β : Type*) [LE α] [LE β] : α ⊕ β ≃o β ⊕ α :=\n  { Equiv.sumComm α β with map_rel_iff' := swap_le_swap_iff }\n\n"}
{"name":"OrderIso.sumComm_symm","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : LE α\ninst✝ : LE β\n⊢ Eq (OrderIso.sumComm α β).symm (OrderIso.sumComm β α)","decl":"@[simp]\ntheorem sumComm_symm (α β : Type*) [LE α] [LE β] :\n    (OrderIso.sumComm α β).symm = OrderIso.sumComm β α :=\n  rfl\n\n"}
{"name":"OrderIso.sumAssoc_apply_inl_inl","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : LE α\ninst✝¹ : LE β\ninst✝ : LE γ\na : α\n⊢ Eq ((OrderIso.sumAssoc α β γ) (Sum.inl (Sum.inl a))) (Sum.inl a)","decl":"@[simp]\ntheorem sumAssoc_apply_inl_inl : sumAssoc α β γ (inl (inl a)) = inl a :=\n  rfl\n\n"}
{"name":"OrderIso.sumAssoc_apply_inl_inr","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : LE α\ninst✝¹ : LE β\ninst✝ : LE γ\nb : β\n⊢ Eq ((OrderIso.sumAssoc α β γ) (Sum.inl (Sum.inr b))) (Sum.inr (Sum.inl b))","decl":"@[simp]\ntheorem sumAssoc_apply_inl_inr : sumAssoc α β γ (inl (inr b)) = inr (inl b) :=\n  rfl\n\n"}
{"name":"OrderIso.sumAssoc_apply_inr","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : LE α\ninst✝¹ : LE β\ninst✝ : LE γ\nc : γ\n⊢ Eq ((OrderIso.sumAssoc α β γ) (Sum.inr c)) (Sum.inr (Sum.inr c))","decl":"@[simp]\ntheorem sumAssoc_apply_inr : sumAssoc α β γ (inr c) = inr (inr c) :=\n  rfl\n\n"}
{"name":"OrderIso.sumAssoc_symm_apply_inl","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : LE α\ninst✝¹ : LE β\ninst✝ : LE γ\na : α\n⊢ Eq ((OrderIso.sumAssoc α β γ).symm (Sum.inl a)) (Sum.inl (Sum.inl a))","decl":"@[simp]\ntheorem sumAssoc_symm_apply_inl : (sumAssoc α β γ).symm (inl a) = inl (inl a) :=\n  rfl\n\n"}
{"name":"OrderIso.sumAssoc_symm_apply_inr_inl","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : LE α\ninst✝¹ : LE β\ninst✝ : LE γ\nb : β\n⊢ Eq ((OrderIso.sumAssoc α β γ).symm (Sum.inr (Sum.inl b))) (Sum.inl (Sum.inr b))","decl":"@[simp]\ntheorem sumAssoc_symm_apply_inr_inl : (sumAssoc α β γ).symm (inr (inl b)) = inl (inr b) :=\n  rfl\n\n"}
{"name":"OrderIso.sumAssoc_symm_apply_inr_inr","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : LE α\ninst✝¹ : LE β\ninst✝ : LE γ\nc : γ\n⊢ Eq ((OrderIso.sumAssoc α β γ).symm (Sum.inr (Sum.inr c))) (Sum.inr c)","decl":"@[simp]\ntheorem sumAssoc_symm_apply_inr_inr : (sumAssoc α β γ).symm (inr (inr c)) = inr c :=\n  rfl\n\n"}
{"name":"OrderIso.sumDualDistrib_inl","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\na : α\n⊢ Eq ((OrderIso.sumDualDistrib α β) (OrderDual.toDual (Sum.inl a))) (Sum.inl (OrderDual.toDual a))","decl":"@[simp]\ntheorem sumDualDistrib_inl : sumDualDistrib α β (toDual (inl a)) = inl (toDual a) :=\n  rfl\n\n"}
{"name":"OrderIso.sumDualDistrib_inr","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\nb : β\n⊢ Eq ((OrderIso.sumDualDistrib α β) (OrderDual.toDual (Sum.inr b))) (Sum.inr (OrderDual.toDual b))","decl":"@[simp]\ntheorem sumDualDistrib_inr : sumDualDistrib α β (toDual (inr b)) = inr (toDual b) :=\n  rfl\n\n"}
{"name":"OrderIso.sumDualDistrib_symm_inl","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\na : α\n⊢ Eq ((OrderIso.sumDualDistrib α β).symm (Sum.inl (OrderDual.toDual a))) (OrderDual.toDual (Sum.inl a))","decl":"@[simp]\ntheorem sumDualDistrib_symm_inl : (sumDualDistrib α β).symm (inl (toDual a)) = toDual (inl a) :=\n  rfl\n\n"}
{"name":"OrderIso.sumDualDistrib_symm_inr","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\nb : β\n⊢ Eq ((OrderIso.sumDualDistrib α β).symm (Sum.inr (OrderDual.toDual b))) (OrderDual.toDual (Sum.inr b))","decl":"@[simp]\ntheorem sumDualDistrib_symm_inr : (sumDualDistrib α β).symm (inr (toDual b)) = toDual (inr b) :=\n  rfl\n\n"}
{"name":"OrderIso.sumLexAssoc_apply_inl_inl","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : LE α\ninst✝¹ : LE β\ninst✝ : LE γ\na : α\n⊢ Eq ((OrderIso.sumLexAssoc α β γ) (toLex (Sum.inl (toLex (Sum.inl a))))) (toLex (Sum.inl a))","decl":"@[simp]\ntheorem sumLexAssoc_apply_inl_inl :\n    sumLexAssoc α β γ (toLex <| inl <| toLex <| inl a) = toLex (inl a) :=\n  rfl\n\n"}
{"name":"OrderIso.sumLexAssoc_apply_inl_inr","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : LE α\ninst✝¹ : LE β\ninst✝ : LE γ\nb : β\n⊢ Eq ((OrderIso.sumLexAssoc α β γ) (toLex (Sum.inl (toLex (Sum.inr b))))) (toLex (Sum.inr (toLex (Sum.inl b))))","decl":"@[simp]\ntheorem sumLexAssoc_apply_inl_inr :\n    sumLexAssoc α β γ (toLex <| inl <| toLex <| inr b) = toLex (inr <| toLex <| inl b) :=\n  rfl\n\n"}
{"name":"OrderIso.sumLexAssoc_apply_inr","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : LE α\ninst✝¹ : LE β\ninst✝ : LE γ\nc : γ\n⊢ Eq ((OrderIso.sumLexAssoc α β γ) (toLex (Sum.inr c))) (toLex (Sum.inr (toLex (Sum.inr c))))","decl":"@[simp]\ntheorem sumLexAssoc_apply_inr :\n    sumLexAssoc α β γ (toLex <| inr c) = toLex (inr <| toLex <| inr c) :=\n  rfl\n\n"}
{"name":"OrderIso.sumLexAssoc_symm_apply_inl","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : LE α\ninst✝¹ : LE β\ninst✝ : LE γ\na : α\n⊢ Eq ((OrderIso.sumLexAssoc α β γ).symm (Sum.inl a)) (Sum.inl (Sum.inl a))","decl":"@[simp]\ntheorem sumLexAssoc_symm_apply_inl : (sumLexAssoc α β γ).symm (inl a) = inl (inl a) :=\n  rfl\n\n"}
{"name":"OrderIso.sumLexAssoc_symm_apply_inr_inl","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : LE α\ninst✝¹ : LE β\ninst✝ : LE γ\nb : β\n⊢ Eq ((OrderIso.sumLexAssoc α β γ).symm (Sum.inr (Sum.inl b))) (Sum.inl (Sum.inr b))","decl":"@[simp]\ntheorem sumLexAssoc_symm_apply_inr_inl : (sumLexAssoc α β γ).symm (inr (inl b)) = inl (inr b) :=\n  rfl\n\n"}
{"name":"OrderIso.sumLexAssoc_symm_apply_inr_inr","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : LE α\ninst✝¹ : LE β\ninst✝ : LE γ\nc : γ\n⊢ Eq ((OrderIso.sumLexAssoc α β γ).symm (Sum.inr (Sum.inr c))) (Sum.inr c)","decl":"@[simp]\ntheorem sumLexAssoc_symm_apply_inr_inr : (sumLexAssoc α β γ).symm (inr (inr c)) = inr c :=\n  rfl\n\n"}
{"name":"OrderIso.sumLexDualAntidistrib_inl","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\na : α\n⊢ Eq ((OrderIso.sumLexDualAntidistrib α β) (OrderDual.toDual (Sum.inl a))) (Sum.inr (OrderDual.toDual a))","decl":"@[simp]\ntheorem sumLexDualAntidistrib_inl :\n    sumLexDualAntidistrib α β (toDual (inl a)) = inr (toDual a) :=\n  rfl\n\n"}
{"name":"OrderIso.sumLexDualAntidistrib_inr","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\nb : β\n⊢ Eq ((OrderIso.sumLexDualAntidistrib α β) (OrderDual.toDual (Sum.inr b))) (Sum.inl (OrderDual.toDual b))","decl":"@[simp]\ntheorem sumLexDualAntidistrib_inr :\n    sumLexDualAntidistrib α β (toDual (inr b)) = inl (toDual b) :=\n  rfl\n\n"}
{"name":"OrderIso.sumLexDualAntidistrib_symm_inl","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\nb : β\n⊢ Eq ((OrderIso.sumLexDualAntidistrib α β).symm (Sum.inl (OrderDual.toDual b))) (OrderDual.toDual (Sum.inr b))","decl":"@[simp]\ntheorem sumLexDualAntidistrib_symm_inl :\n    (sumLexDualAntidistrib α β).symm (inl (toDual b)) = toDual (inr b) :=\n  rfl\n\n"}
{"name":"OrderIso.sumLexDualAntidistrib_symm_inr","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LE α\ninst✝ : LE β\na : α\n⊢ Eq ((OrderIso.sumLexDualAntidistrib α β).symm (Sum.inr (OrderDual.toDual a))) (OrderDual.toDual (Sum.inl a))","decl":"@[simp]\ntheorem sumLexDualAntidistrib_symm_inr :\n    (sumLexDualAntidistrib α β).symm (inr (toDual a)) = toDual (inl a) :=\n  rfl\n\n"}
{"name":"WithBot.orderIsoPUnitSumLex_bot","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\ninst✝ : LE α\n⊢ Eq (WithBot.orderIsoPUnitSumLex Bot.bot) (toLex (Sum.inl PUnit.unit))","decl":"@[simp]\ntheorem orderIsoPUnitSumLex_bot : @orderIsoPUnitSumLex α _ ⊥ = toLex (inl PUnit.unit) :=\n  rfl\n\n"}
{"name":"WithBot.orderIsoPUnitSumLex_toLex","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\n⊢ Eq (WithBot.orderIsoPUnitSumLex ↑a) (toLex (Sum.inr a))","decl":"@[simp]\ntheorem orderIsoPUnitSumLex_toLex (a : α) : orderIsoPUnitSumLex ↑a = toLex (inr a) :=\n  rfl\n\n"}
{"name":"WithBot.orderIsoPUnitSumLex_symm_inl","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\ninst✝ : LE α\nx : PUnit.{u_4 + 1}\n⊢ Eq (WithBot.orderIsoPUnitSumLex.symm (toLex (Sum.inl x))) Bot.bot","decl":"@[simp]\ntheorem orderIsoPUnitSumLex_symm_inl (x : PUnit) :\n    (@orderIsoPUnitSumLex α _).symm (toLex <| inl x) = ⊥ :=\n  rfl\n\n"}
{"name":"WithBot.orderIsoPUnitSumLex_symm_inr","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\n⊢ Eq (WithBot.orderIsoPUnitSumLex.symm (toLex (Sum.inr a))) ↑a","decl":"@[simp]\ntheorem orderIsoPUnitSumLex_symm_inr (a : α) : orderIsoPUnitSumLex.symm (toLex <| inr a) = a :=\n  rfl\n\n"}
{"name":"WithTop.orderIsoSumLexPUnit_top","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\ninst✝ : LE α\n⊢ Eq (WithTop.orderIsoSumLexPUnit Top.top) (toLex (Sum.inr PUnit.unit))","decl":"@[simp]\ntheorem orderIsoSumLexPUnit_top : @orderIsoSumLexPUnit α _ ⊤ = toLex (inr PUnit.unit) :=\n  rfl\n\n"}
{"name":"WithTop.orderIsoSumLexPUnit_toLex","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\n⊢ Eq (WithTop.orderIsoSumLexPUnit ↑a) (toLex (Sum.inl a))","decl":"@[simp]\ntheorem orderIsoSumLexPUnit_toLex (a : α) : orderIsoSumLexPUnit ↑a = toLex (inl a) :=\n  rfl\n\n"}
{"name":"WithTop.orderIsoSumLexPUnit_symm_inr","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\ninst✝ : LE α\nx : PUnit.{u_4 + 1}\n⊢ Eq (WithTop.orderIsoSumLexPUnit.symm (toLex (Sum.inr x))) Top.top","decl":"@[simp]\ntheorem orderIsoSumLexPUnit_symm_inr (x : PUnit) :\n    (@orderIsoSumLexPUnit α _).symm (toLex <| inr x) = ⊤ :=\n  rfl\n\n"}
{"name":"WithTop.orderIsoSumLexPUnit_symm_inl","module":"Mathlib.Data.Sum.Order","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\n⊢ Eq (WithTop.orderIsoSumLexPUnit.symm (toLex (Sum.inl a))) ↑a","decl":"@[simp]\ntheorem orderIsoSumLexPUnit_symm_inl (a : α) : orderIsoSumLexPUnit.symm (toLex <| inl a) = a :=\n  rfl\n\n"}
