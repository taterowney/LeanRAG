{"name":"PreOpposite.op'.sizeOf_spec","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_3\ninst✝ : SizeOf α\nunop' : α\n⊢ Eq (SizeOf.sizeOf { unop' := unop' }) (HAdd.hAdd 1 (SizeOf.sizeOf unop'))","decl":"/-- Auxiliary type to implement `MulOpposite` and `AddOpposite`.\n\nIt turns out to be convenient to have `MulOpposite α = AddOpposite α` true by definition, in the\nsame way that it is convenient to have `Additive α = α`; this means that we also get the defeq\n`AddOpposite (Additive α) = MulOpposite α`, which is convenient when working with quotients.\n\nThis is a compromise between making `MulOpposite α = AddOpposite α = α` (what we had in Lean 3) and\nhaving no defeqs within those three types (which we had as of https://github.com/leanprover-community/mathlib4/pull/1036). -/\nstructure PreOpposite (α : Type*) : Type _ where\n  /-- The element of `PreOpposite α` that represents `x : α`. -/ op' ::\n  /-- The element of `α` represented by `x : PreOpposite α`. -/ unop' : α\n\n"}
{"name":"PreOpposite.op'.inj","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_3\nunop'✝ unop' : α\nx✝ : Eq { unop' := unop'✝ } { unop' := unop' }\n⊢ Eq unop'✝ unop'","decl":"/-- Auxiliary type to implement `MulOpposite` and `AddOpposite`.\n\nIt turns out to be convenient to have `MulOpposite α = AddOpposite α` true by definition, in the\nsame way that it is convenient to have `Additive α = α`; this means that we also get the defeq\n`AddOpposite (Additive α) = MulOpposite α`, which is convenient when working with quotients.\n\nThis is a compromise between making `MulOpposite α = AddOpposite α = α` (what we had in Lean 3) and\nhaving no defeqs within those three types (which we had as of https://github.com/leanprover-community/mathlib4/pull/1036). -/\nstructure PreOpposite (α : Type*) : Type _ where\n  /-- The element of `PreOpposite α` that represents `x : α`. -/ op' ::\n  /-- The element of `α` represented by `x : PreOpposite α`. -/ unop' : α\n\n"}
{"name":"PreOpposite.op'.injEq","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_3\nunop'✝ unop' : α\n⊢ Eq (Eq { unop' := unop'✝ } { unop' := unop' }) (Eq unop'✝ unop')","decl":"/-- Auxiliary type to implement `MulOpposite` and `AddOpposite`.\n\nIt turns out to be convenient to have `MulOpposite α = AddOpposite α` true by definition, in the\nsame way that it is convenient to have `Additive α = α`; this means that we also get the defeq\n`AddOpposite (Additive α) = MulOpposite α`, which is convenient when working with quotients.\n\nThis is a compromise between making `MulOpposite α = AddOpposite α = α` (what we had in Lean 3) and\nhaving no defeqs within those three types (which we had as of https://github.com/leanprover-community/mathlib4/pull/1036). -/\nstructure PreOpposite (α : Type*) : Type _ where\n  /-- The element of `PreOpposite α` that represents `x : α`. -/ op' ::\n  /-- The element of `α` represented by `x : PreOpposite α`. -/ unop' : α\n\n"}
{"name":"MulOpposite.unop_op","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\nx : α\n⊢ Eq (MulOpposite.unop (MulOpposite.op x)) x","decl":"@[to_additive (attr := simp)]\ntheorem unop_op (x : α) : unop (op x) = x := rfl\n\n"}
{"name":"AddOpposite.unop_op","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\nx : α\n⊢ Eq (AddOpposite.unop (AddOpposite.op x)) x","decl":"@[to_additive (attr := simp)]\ntheorem unop_op (x : α) : unop (op x) = x := rfl\n\n"}
{"name":"MulOpposite.op_unop","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\nx : MulOpposite α\n⊢ Eq (MulOpposite.op (MulOpposite.unop x)) x","decl":"@[to_additive (attr := simp)]\ntheorem op_unop (x : αᵐᵒᵖ) : op (unop x) = x :=\n  rfl\n\n"}
{"name":"AddOpposite.op_unop","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\nx : AddOpposite α\n⊢ Eq (AddOpposite.op (AddOpposite.unop x)) x","decl":"@[to_additive (attr := simp)]\ntheorem op_unop (x : αᵐᵒᵖ) : op (unop x) = x :=\n  rfl\n\n"}
{"name":"AddOpposite.op_comp_unop","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\n⊢ Eq (Function.comp AddOpposite.op AddOpposite.unop) id","decl":"@[to_additive (attr := simp)]\ntheorem op_comp_unop : (op : α → αᵐᵒᵖ) ∘ unop = id :=\n  rfl\n\n"}
{"name":"MulOpposite.op_comp_unop","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\n⊢ Eq (Function.comp MulOpposite.op MulOpposite.unop) id","decl":"@[to_additive (attr := simp)]\ntheorem op_comp_unop : (op : α → αᵐᵒᵖ) ∘ unop = id :=\n  rfl\n\n"}
{"name":"MulOpposite.unop_comp_op","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\n⊢ Eq (Function.comp MulOpposite.unop MulOpposite.op) id","decl":"@[to_additive (attr := simp)]\ntheorem unop_comp_op : (unop : αᵐᵒᵖ → α) ∘ op = id :=\n  rfl\n\n"}
{"name":"AddOpposite.unop_comp_op","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\n⊢ Eq (Function.comp AddOpposite.unop AddOpposite.op) id","decl":"@[to_additive (attr := simp)]\ntheorem unop_comp_op : (unop : αᵐᵒᵖ → α) ∘ op = id :=\n  rfl\n\n"}
{"name":"AddOpposite.opEquiv_apply","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\n⊢ Eq (⇑AddOpposite.opEquiv) AddOpposite.op","decl":"/-- The canonical bijection between `α` and `αᵐᵒᵖ`. -/\n@[to_additive (attr := simps (config := .asFn) apply symm_apply)\n  \"The canonical bijection between `α` and `αᵃᵒᵖ`.\"]\ndef opEquiv : α ≃ αᵐᵒᵖ :=\n  ⟨op, unop, unop_op, op_unop⟩\n\n"}
{"name":"MulOpposite.opEquiv_apply","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\n⊢ Eq (⇑MulOpposite.opEquiv) MulOpposite.op","decl":"/-- The canonical bijection between `α` and `αᵐᵒᵖ`. -/\n@[to_additive (attr := simps (config := .asFn) apply symm_apply)\n  \"The canonical bijection between `α` and `αᵃᵒᵖ`.\"]\ndef opEquiv : α ≃ αᵐᵒᵖ :=\n  ⟨op, unop, unop_op, op_unop⟩\n\n"}
{"name":"AddOpposite.opEquiv_symm_apply","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\n⊢ Eq (⇑AddOpposite.opEquiv.symm) AddOpposite.unop","decl":"/-- The canonical bijection between `α` and `αᵐᵒᵖ`. -/\n@[to_additive (attr := simps (config := .asFn) apply symm_apply)\n  \"The canonical bijection between `α` and `αᵃᵒᵖ`.\"]\ndef opEquiv : α ≃ αᵐᵒᵖ :=\n  ⟨op, unop, unop_op, op_unop⟩\n\n"}
{"name":"MulOpposite.opEquiv_symm_apply","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\n⊢ Eq (⇑MulOpposite.opEquiv.symm) MulOpposite.unop","decl":"/-- The canonical bijection between `α` and `αᵐᵒᵖ`. -/\n@[to_additive (attr := simps (config := .asFn) apply symm_apply)\n  \"The canonical bijection between `α` and `αᵃᵒᵖ`.\"]\ndef opEquiv : α ≃ αᵐᵒᵖ :=\n  ⟨op, unop, unop_op, op_unop⟩\n\n"}
{"name":"AddOpposite.op_bijective","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\n⊢ Function.Bijective AddOpposite.op","decl":"@[to_additive]\ntheorem op_bijective : Bijective (op : α → αᵐᵒᵖ) :=\n  opEquiv.bijective\n\n"}
{"name":"MulOpposite.op_bijective","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\n⊢ Function.Bijective MulOpposite.op","decl":"@[to_additive]\ntheorem op_bijective : Bijective (op : α → αᵐᵒᵖ) :=\n  opEquiv.bijective\n\n"}
{"name":"MulOpposite.unop_bijective","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\n⊢ Function.Bijective MulOpposite.unop","decl":"@[to_additive]\ntheorem unop_bijective : Bijective (unop : αᵐᵒᵖ → α) :=\n  opEquiv.symm.bijective\n\n"}
{"name":"AddOpposite.unop_bijective","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\n⊢ Function.Bijective AddOpposite.unop","decl":"@[to_additive]\ntheorem unop_bijective : Bijective (unop : αᵐᵒᵖ → α) :=\n  opEquiv.symm.bijective\n\n"}
{"name":"AddOpposite.op_injective","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\n⊢ Function.Injective AddOpposite.op","decl":"@[to_additive]\ntheorem op_injective : Injective (op : α → αᵐᵒᵖ) :=\n  op_bijective.injective\n\n"}
{"name":"MulOpposite.op_injective","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\n⊢ Function.Injective MulOpposite.op","decl":"@[to_additive]\ntheorem op_injective : Injective (op : α → αᵐᵒᵖ) :=\n  op_bijective.injective\n\n"}
{"name":"AddOpposite.op_surjective","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\n⊢ Function.Surjective AddOpposite.op","decl":"@[to_additive]\ntheorem op_surjective : Surjective (op : α → αᵐᵒᵖ) :=\n  op_bijective.surjective\n\n"}
{"name":"MulOpposite.op_surjective","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\n⊢ Function.Surjective MulOpposite.op","decl":"@[to_additive]\ntheorem op_surjective : Surjective (op : α → αᵐᵒᵖ) :=\n  op_bijective.surjective\n\n"}
{"name":"AddOpposite.unop_injective","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\n⊢ Function.Injective AddOpposite.unop","decl":"@[to_additive]\ntheorem unop_injective : Injective (unop : αᵐᵒᵖ → α) :=\n  unop_bijective.injective\n\n"}
{"name":"MulOpposite.unop_injective","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\n⊢ Function.Injective MulOpposite.unop","decl":"@[to_additive]\ntheorem unop_injective : Injective (unop : αᵐᵒᵖ → α) :=\n  unop_bijective.injective\n\n"}
{"name":"AddOpposite.unop_surjective","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\n⊢ Function.Surjective AddOpposite.unop","decl":"@[to_additive]\ntheorem unop_surjective : Surjective (unop : αᵐᵒᵖ → α) :=\n  unop_bijective.surjective\n\n"}
{"name":"MulOpposite.unop_surjective","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\n⊢ Function.Surjective MulOpposite.unop","decl":"@[to_additive]\ntheorem unop_surjective : Surjective (unop : αᵐᵒᵖ → α) :=\n  unop_bijective.surjective\n\n"}
{"name":"AddOpposite.op_inj","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\nx y : α\n⊢ Iff (Eq (AddOpposite.op x) (AddOpposite.op y)) (Eq x y)","decl":"@[to_additive (attr := simp)]\ntheorem op_inj {x y : α} : op x = op y ↔ x = y := iff_of_eq <| PreOpposite.op'.injEq _ _\n\n"}
{"name":"MulOpposite.op_inj","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\nx y : α\n⊢ Iff (Eq (MulOpposite.op x) (MulOpposite.op y)) (Eq x y)","decl":"@[to_additive (attr := simp)]\ntheorem op_inj {x y : α} : op x = op y ↔ x = y := iff_of_eq <| PreOpposite.op'.injEq _ _\n\n"}
{"name":"AddOpposite.unop_inj","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\nx y : AddOpposite α\n⊢ Iff (Eq (AddOpposite.unop x) (AddOpposite.unop y)) (Eq x y)","decl":"@[to_additive (attr := simp, nolint simpComm)]\ntheorem unop_inj {x y : αᵐᵒᵖ} : unop x = unop y ↔ x = y :=\n  unop_injective.eq_iff\n\n"}
{"name":"MulOpposite.unop_inj","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\nx y : MulOpposite α\n⊢ Iff (Eq (MulOpposite.unop x) (MulOpposite.unop y)) (Eq x y)","decl":"@[to_additive (attr := simp, nolint simpComm)]\ntheorem unop_inj {x y : αᵐᵒᵖ} : unop x = unop y ↔ x = y :=\n  unop_injective.eq_iff\n\n"}
{"name":"MulOpposite.forall","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\np : MulOpposite α → Prop\n⊢ Iff (∀ (a : MulOpposite α), p a) (∀ (a : α), p (MulOpposite.op a))","decl":"@[to_additive (attr := simp)] lemma «forall» {p : αᵐᵒᵖ → Prop} : (∀ a, p a) ↔ ∀ a, p (op a) :=\n  op_surjective.forall\n\n"}
{"name":"AddOpposite.forall","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\np : AddOpposite α → Prop\n⊢ Iff (∀ (a : AddOpposite α), p a) (∀ (a : α), p (AddOpposite.op a))","decl":"@[to_additive (attr := simp)] lemma «forall» {p : αᵐᵒᵖ → Prop} : (∀ a, p a) ↔ ∀ a, p (op a) :=\n  op_surjective.forall\n\n"}
{"name":"MulOpposite.exists","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\np : MulOpposite α → Prop\n⊢ Iff (Exists fun a => p a) (Exists fun a => p (MulOpposite.op a))","decl":"@[to_additive (attr := simp)] lemma «exists» {p : αᵐᵒᵖ → Prop} : (∃ a, p a) ↔ ∃ a, p (op a) :=\n  op_surjective.exists\n\n"}
{"name":"AddOpposite.exists","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\np : AddOpposite α → Prop\n⊢ Iff (Exists fun a => p a) (Exists fun a => p (AddOpposite.op a))","decl":"@[to_additive (attr := simp)] lemma «exists» {p : αᵐᵒᵖ → Prop} : (∃ a, p a) ↔ ∃ a, p (op a) :=\n  op_surjective.exists\n\n"}
{"name":"AddOpposite.instNontrivial","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Nontrivial α\n⊢ Nontrivial (AddOpposite α)","decl":"@[to_additive] instance instNontrivial [Nontrivial α] : Nontrivial αᵐᵒᵖ := op_injective.nontrivial\n\n"}
{"name":"MulOpposite.instNontrivial","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Nontrivial α\n⊢ Nontrivial (MulOpposite α)","decl":"@[to_additive] instance instNontrivial [Nontrivial α] : Nontrivial αᵐᵒᵖ := op_injective.nontrivial\n\n"}
{"name":"MulOpposite.instSubsingleton","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Subsingleton α\n⊢ Subsingleton (MulOpposite α)","decl":"@[to_additive]\ninstance instSubsingleton [Subsingleton α] : Subsingleton αᵐᵒᵖ := unop_injective.subsingleton\n\n"}
{"name":"AddOpposite.instSubsingleton","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Subsingleton α\n⊢ Subsingleton (AddOpposite α)","decl":"@[to_additive]\ninstance instSubsingleton [Subsingleton α] : Subsingleton αᵐᵒᵖ := unop_injective.subsingleton\n\n"}
{"name":"AddOpposite.instIsEmpty","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : IsEmpty α\n⊢ IsEmpty (AddOpposite α)","decl":"@[to_additive] instance instIsEmpty [IsEmpty α] : IsEmpty αᵐᵒᵖ := Function.isEmpty unop\n\n"}
{"name":"MulOpposite.instIsEmpty","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : IsEmpty α\n⊢ IsEmpty (MulOpposite α)","decl":"@[to_additive] instance instIsEmpty [IsEmpty α] : IsEmpty αᵐᵒᵖ := Function.isEmpty unop\n\n"}
{"name":"MulOpposite.op_zero","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Zero α\n⊢ Eq (MulOpposite.op 0) 0","decl":"@[simp] lemma op_zero [Zero α] : op (0 : α) = 0 := rfl\n\n"}
{"name":"MulOpposite.unop_zero","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Zero α\n⊢ Eq (MulOpposite.unop 0) 0","decl":"@[simp] lemma unop_zero [Zero α] : unop (0 : αᵐᵒᵖ) = 0 := rfl\n\n"}
{"name":"MulOpposite.op_one","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : One α\n⊢ Eq (MulOpposite.op 1) 1","decl":"@[to_additive (attr := simp)] lemma op_one [One α] : op (1 : α) = 1 := rfl\n\n"}
{"name":"AddOpposite.op_zero","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Zero α\n⊢ Eq (AddOpposite.op 0) 0","decl":"@[to_additive (attr := simp)] lemma op_one [One α] : op (1 : α) = 1 := rfl\n\n"}
{"name":"AddOpposite.unop_zero","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Zero α\n⊢ Eq (AddOpposite.unop 0) 0","decl":"@[to_additive (attr := simp)] lemma unop_one [One α] : unop (1 : αᵐᵒᵖ) = 1 := rfl\n\n"}
{"name":"MulOpposite.unop_one","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : One α\n⊢ Eq (MulOpposite.unop 1) 1","decl":"@[to_additive (attr := simp)] lemma unop_one [One α] : unop (1 : αᵐᵒᵖ) = 1 := rfl\n\n"}
{"name":"MulOpposite.op_add","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Add α\nx y : α\n⊢ Eq (MulOpposite.op (HAdd.hAdd x y)) (HAdd.hAdd (MulOpposite.op x) (MulOpposite.op y))","decl":"@[simp] lemma op_add [Add α] (x y : α) : op (x + y) = op x + op y := rfl\n\n"}
{"name":"MulOpposite.unop_add","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Add α\nx y : MulOpposite α\n⊢ Eq (MulOpposite.unop (HAdd.hAdd x y)) (HAdd.hAdd (MulOpposite.unop x) (MulOpposite.unop y))","decl":"@[simp] lemma unop_add [Add α] (x y : αᵐᵒᵖ) : unop (x + y) = unop x + unop y := rfl\n\n"}
{"name":"MulOpposite.op_neg","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Neg α\nx : α\n⊢ Eq (MulOpposite.op (Neg.neg x)) (Neg.neg (MulOpposite.op x))","decl":"@[simp] lemma op_neg [Neg α] (x : α) : op (-x) = -op x := rfl\n\n"}
{"name":"MulOpposite.unop_neg","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Neg α\nx : MulOpposite α\n⊢ Eq (MulOpposite.unop (Neg.neg x)) (Neg.neg (MulOpposite.unop x))","decl":"@[simp] lemma unop_neg [Neg α] (x : αᵐᵒᵖ) : unop (-x) = -unop x := rfl\n\n"}
{"name":"AddOpposite.op_add","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Add α\nx y : α\n⊢ Eq (AddOpposite.op (HAdd.hAdd x y)) (HAdd.hAdd (AddOpposite.op y) (AddOpposite.op x))","decl":"@[to_additive (attr := simp)] lemma op_mul [Mul α] (x y : α) : op (x * y) = op y * op x := rfl\n\n"}
{"name":"MulOpposite.op_mul","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Mul α\nx y : α\n⊢ Eq (MulOpposite.op (HMul.hMul x y)) (HMul.hMul (MulOpposite.op y) (MulOpposite.op x))","decl":"@[to_additive (attr := simp)] lemma op_mul [Mul α] (x y : α) : op (x * y) = op y * op x := rfl\n\n"}
{"name":"MulOpposite.unop_mul","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Mul α\nx y : MulOpposite α\n⊢ Eq (MulOpposite.unop (HMul.hMul x y)) (HMul.hMul (MulOpposite.unop y) (MulOpposite.unop x))","decl":"@[to_additive (attr := simp)]\nlemma unop_mul [Mul α] (x y : αᵐᵒᵖ) : unop (x * y) = unop y * unop x := rfl\n\n"}
{"name":"AddOpposite.unop_add","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Add α\nx y : AddOpposite α\n⊢ Eq (AddOpposite.unop (HAdd.hAdd x y)) (HAdd.hAdd (AddOpposite.unop y) (AddOpposite.unop x))","decl":"@[to_additive (attr := simp)]\nlemma unop_mul [Mul α] (x y : αᵐᵒᵖ) : unop (x * y) = unop y * unop x := rfl\n\n"}
{"name":"AddOpposite.op_neg","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Neg α\nx : α\n⊢ Eq (AddOpposite.op (Neg.neg x)) (Neg.neg (AddOpposite.op x))","decl":"@[to_additive (attr := simp)] lemma op_inv [Inv α] (x : α) : op x⁻¹ = (op x)⁻¹ := rfl\n\n"}
{"name":"MulOpposite.op_inv","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Inv α\nx : α\n⊢ Eq (MulOpposite.op (Inv.inv x)) (Inv.inv (MulOpposite.op x))","decl":"@[to_additive (attr := simp)] lemma op_inv [Inv α] (x : α) : op x⁻¹ = (op x)⁻¹ := rfl\n\n"}
{"name":"MulOpposite.unop_inv","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Inv α\nx : MulOpposite α\n⊢ Eq (MulOpposite.unop (Inv.inv x)) (Inv.inv (MulOpposite.unop x))","decl":"@[to_additive (attr := simp)] lemma unop_inv [Inv α] (x : αᵐᵒᵖ) : unop x⁻¹ = (unop x)⁻¹ := rfl\n\n"}
{"name":"AddOpposite.unop_neg","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Neg α\nx : AddOpposite α\n⊢ Eq (AddOpposite.unop (Neg.neg x)) (Neg.neg (AddOpposite.unop x))","decl":"@[to_additive (attr := simp)] lemma unop_inv [Inv α] (x : αᵐᵒᵖ) : unop x⁻¹ = (unop x)⁻¹ := rfl\n\n"}
{"name":"MulOpposite.op_sub","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Sub α\nx y : α\n⊢ Eq (MulOpposite.op (HSub.hSub x y)) (HSub.hSub (MulOpposite.op x) (MulOpposite.op y))","decl":"@[simp] lemma op_sub [Sub α] (x y : α) : op (x - y) = op x - op y := rfl\n\n"}
{"name":"MulOpposite.unop_sub","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Sub α\nx y : MulOpposite α\n⊢ Eq (MulOpposite.unop (HSub.hSub x y)) (HSub.hSub (MulOpposite.unop x) (MulOpposite.unop y))","decl":"@[simp] lemma unop_sub [Sub α] (x y : αᵐᵒᵖ) : unop (x - y) = unop x - unop y := rfl\n\n"}
{"name":"AddOpposite.op_vadd","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : VAdd α β\na : α\nb : β\n⊢ Eq (AddOpposite.op (HVAdd.hVAdd a b)) (HVAdd.hVAdd a (AddOpposite.op b))","decl":"@[to_additive (attr := simp)]\nlemma op_smul [SMul α β] (a : α) (b : β) : op (a • b) = a • op b := rfl\n\n"}
{"name":"MulOpposite.op_smul","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : SMul α β\na : α\nb : β\n⊢ Eq (MulOpposite.op (HSMul.hSMul a b)) (HSMul.hSMul a (MulOpposite.op b))","decl":"@[to_additive (attr := simp)]\nlemma op_smul [SMul α β] (a : α) (b : β) : op (a • b) = a • op b := rfl\n\n"}
{"name":"AddOpposite.unop_vadd","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : VAdd α β\na : α\nb : AddOpposite β\n⊢ Eq (AddOpposite.unop (HVAdd.hVAdd a b)) (HVAdd.hVAdd a (AddOpposite.unop b))","decl":"@[to_additive (attr := simp)]\nlemma unop_smul [SMul α β] (a : α) (b : βᵐᵒᵖ) : unop (a • b) = a • unop b := rfl\n\n"}
{"name":"MulOpposite.unop_smul","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : SMul α β\na : α\nb : MulOpposite β\n⊢ Eq (MulOpposite.unop (HSMul.hSMul a b)) (HSMul.hSMul a (MulOpposite.unop b))","decl":"@[to_additive (attr := simp)]\nlemma unop_smul [SMul α β] (a : α) (b : βᵐᵒᵖ) : unop (a • b) = a • unop b := rfl\n\n"}
{"name":"MulOpposite.unop_eq_zero_iff","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Zero α\na : MulOpposite α\n⊢ Iff (Eq (MulOpposite.unop a) 0) (Eq a 0)","decl":"@[simp, nolint simpComm]\ntheorem unop_eq_zero_iff [Zero α] (a : αᵐᵒᵖ) : a.unop = (0 : α) ↔ a = (0 : αᵐᵒᵖ) :=\n  unop_injective.eq_iff' rfl\n\n"}
{"name":"MulOpposite.op_eq_zero_iff","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Zero α\na : α\n⊢ Iff (Eq (MulOpposite.op a) 0) (Eq a 0)","decl":"@[simp]\ntheorem op_eq_zero_iff [Zero α] (a : α) : op a = (0 : αᵐᵒᵖ) ↔ a = (0 : α) :=\n  op_injective.eq_iff' rfl\n\n"}
{"name":"MulOpposite.unop_ne_zero_iff","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Zero α\na : MulOpposite α\n⊢ Iff (Ne (MulOpposite.unop a) 0) (Ne a 0)","decl":"theorem unop_ne_zero_iff [Zero α] (a : αᵐᵒᵖ) : a.unop ≠ (0 : α) ↔ a ≠ (0 : αᵐᵒᵖ) :=\n  not_congr <| unop_eq_zero_iff a\n\n"}
{"name":"MulOpposite.op_ne_zero_iff","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Zero α\na : α\n⊢ Iff (Ne (MulOpposite.op a) 0) (Ne a 0)","decl":"theorem op_ne_zero_iff [Zero α] (a : α) : op a ≠ (0 : αᵐᵒᵖ) ↔ a ≠ (0 : α) :=\n  not_congr <| op_eq_zero_iff a\n\n"}
{"name":"AddOpposite.unop_eq_zero_iff","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Zero α\na : AddOpposite α\n⊢ Iff (Eq (AddOpposite.unop a) 0) (Eq a 0)","decl":"@[to_additive (attr := simp, nolint simpComm)]\ntheorem unop_eq_one_iff [One α] (a : αᵐᵒᵖ) : a.unop = 1 ↔ a = 1 :=\n  unop_injective.eq_iff' rfl\n\n"}
{"name":"MulOpposite.unop_eq_one_iff","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : One α\na : MulOpposite α\n⊢ Iff (Eq (MulOpposite.unop a) 1) (Eq a 1)","decl":"@[to_additive (attr := simp, nolint simpComm)]\ntheorem unop_eq_one_iff [One α] (a : αᵐᵒᵖ) : a.unop = 1 ↔ a = 1 :=\n  unop_injective.eq_iff' rfl\n\n"}
{"name":"MulOpposite.op_eq_one_iff","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : One α\na : α\n⊢ Iff (Eq (MulOpposite.op a) 1) (Eq a 1)","decl":"@[to_additive (attr := simp)]\nlemma op_eq_one_iff [One α] (a : α) : op a = 1 ↔ a = 1 := op_injective.eq_iff\n\n"}
{"name":"AddOpposite.op_eq_zero_iff","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Zero α\na : α\n⊢ Iff (Eq (AddOpposite.op a) 0) (Eq a 0)","decl":"@[to_additive (attr := simp)]\nlemma op_eq_one_iff [One α] (a : α) : op a = 1 ↔ a = 1 := op_injective.eq_iff\n\n"}
{"name":"AddOpposite.op_one","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : One α\n⊢ Eq (AddOpposite.op 1) 1","decl":"@[simp] lemma op_one [One α] : op (1 : α) = 1 := rfl\n\n"}
{"name":"AddOpposite.unop_one","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : One α\n⊢ Eq (AddOpposite.unop 1) 1","decl":"@[simp] lemma unop_one [One α] : unop 1 = (1 : α) := rfl\n\n"}
{"name":"AddOpposite.op_eq_one_iff","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : One α\na : α\n⊢ Iff (Eq (AddOpposite.op a) 1) (Eq a 1)","decl":"@[simp] lemma op_eq_one_iff [One α] {a : α} : op a = 1 ↔ a = 1 := op_injective.eq_iff\n\n"}
{"name":"AddOpposite.unop_eq_one_iff","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : One α\na : AddOpposite α\n⊢ Iff (Eq (AddOpposite.unop a) 1) (Eq a 1)","decl":"@[simp] lemma unop_eq_one_iff [One α] {a : αᵃᵒᵖ} : unop a = 1 ↔ a = 1 := unop_injective.eq_iff\n\n"}
{"name":"AddOpposite.op_mul","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Mul α\na b : α\n⊢ Eq (AddOpposite.op (HMul.hMul a b)) (HMul.hMul (AddOpposite.op a) (AddOpposite.op b))","decl":"@[simp] lemma op_mul [Mul α] (a b : α) : op (a * b) = op a * op b := rfl\n\n"}
{"name":"AddOpposite.unop_mul","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Mul α\na b : AddOpposite α\n⊢ Eq (AddOpposite.unop (HMul.hMul a b)) (HMul.hMul (AddOpposite.unop a) (AddOpposite.unop b))","decl":"@[simp] lemma unop_mul [Mul α] (a b : αᵃᵒᵖ) : unop (a * b) = unop a * unop b := rfl\n\n"}
{"name":"AddOpposite.op_inv","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Inv α\na : α\n⊢ Eq (AddOpposite.op (Inv.inv a)) (Inv.inv (AddOpposite.op a))","decl":"@[simp] lemma op_inv [Inv α] (a : α) : op a⁻¹ = (op a)⁻¹ := rfl\n\n"}
{"name":"AddOpposite.unop_inv","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Inv α\na : AddOpposite α\n⊢ Eq (AddOpposite.unop (Inv.inv a)) (Inv.inv (AddOpposite.unop a))","decl":"@[simp] lemma unop_inv [Inv α] (a : αᵃᵒᵖ) : unop a⁻¹ = (unop a)⁻¹ := rfl\n\n"}
{"name":"AddOpposite.op_div","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Div α\na b : α\n⊢ Eq (AddOpposite.op (HDiv.hDiv a b)) (HDiv.hDiv (AddOpposite.op a) (AddOpposite.op b))","decl":"@[simp] lemma op_div [Div α] (a b : α) : op (a / b) = op a / op b := rfl\n\n"}
{"name":"AddOpposite.unop_div","module":"Mathlib.Algebra.Opposites","initialProofState":"α : Type u_1\ninst✝ : Div α\na b : AddOpposite α\n⊢ Eq (AddOpposite.unop (HDiv.hDiv a b)) (HDiv.hDiv (AddOpposite.unop a) (AddOpposite.unop b))","decl":"@[simp] lemma unop_div [Div α] (a b : αᵃᵒᵖ) : unop (a / b) = unop a / unop b := rfl\n\n"}
