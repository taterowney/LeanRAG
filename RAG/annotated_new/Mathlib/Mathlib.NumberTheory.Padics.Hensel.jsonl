{"name":"padic_polynomial_dist","module":"Mathlib.NumberTheory.Padics.Hensel","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nF : Polynomial (PadicInt p)\nx y : PadicInt p\n⊢ LE.le (Norm.norm (HSub.hSub (Polynomial.eval x F) (Polynomial.eval y F))) (Norm.norm (HSub.hSub x y))","decl":"theorem padic_polynomial_dist {p : ℕ} [Fact p.Prime] (F : Polynomial ℤ_[p]) (x y : ℤ_[p]) :\n    ‖F.eval x - F.eval y‖ ≤ ‖x - y‖ :=\n  let ⟨z, hz⟩ := F.evalSubFactor x y\n  calc\n    ‖F.eval x - F.eval y‖ = ‖z‖ * ‖x - y‖ := by simp [hz]\n    _ ≤ 1 * ‖x - y‖ := by gcongr; apply PadicInt.norm_le_one\n    _ = ‖x - y‖ := by simp\n\n"}
{"name":"limit_zero_of_norm_tendsto_zero","module":"Mathlib.NumberTheory.Padics.Hensel","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nncs : CauSeq (PadicInt p) Norm.norm\nF : Polynomial (PadicInt p)\nhnorm : Filter.Tendsto (fun i => Norm.norm (Polynomial.eval (↑ncs i) F)) Filter.atTop (nhds 0)\n⊢ Eq (Polynomial.eval ncs.lim F) 0","decl":"theorem limit_zero_of_norm_tendsto_zero : F.eval ncs.lim = 0 :=\n  tendsto_nhds_unique (comp_tendsto_lim _) (tendsto_zero_of_norm_tendsto_zero hnorm)\n\n"}
{"name":"hensels_lemma","module":"Mathlib.NumberTheory.Padics.Hensel","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nF : Polynomial (PadicInt p)\na : PadicInt p\nhnorm : LT.lt (Norm.norm (Polynomial.eval a F)) (HPow.hPow (Norm.norm (Polynomial.eval a (Polynomial.derivative F))) 2)\n⊢ Exists fun z => And (Eq (Polynomial.eval z F) 0) (And (LT.lt (Norm.norm (HSub.hSub z a)) (Norm.norm (Polynomial.eval a (Polynomial.derivative F)))) (And (Eq (Norm.norm (Polynomial.eval z (Polynomial.derivative F))) (Norm.norm (Polynomial.eval a (Polynomial.derivative F)))) (∀ (z' : PadicInt p), Eq (Polynomial.eval z' F) 0 → LT.lt (Norm.norm (HSub.hSub z' a)) (Norm.norm (Polynomial.eval a (Polynomial.derivative F))) → Eq z' z)))","decl":"theorem hensels_lemma :\n    ∃ z : ℤ_[p],\n      F.eval z = 0 ∧\n        ‖z - a‖ < ‖F.derivative.eval a‖ ∧\n          ‖F.derivative.eval z‖ = ‖F.derivative.eval a‖ ∧\n            ∀ z', F.eval z' = 0 → ‖z' - a‖ < ‖F.derivative.eval a‖ → z' = z := by\n  classical\n  exact if ha : F.eval a = 0 then ⟨a, a_is_soln hnorm ha⟩\n  else by\n    exact ⟨soln_gen hnorm, eval_soln hnorm,\n      soln_dist_to_a_lt_deriv hnorm ha, soln_deriv_norm hnorm, fun z => soln_unique hnorm ha z⟩\n"}
