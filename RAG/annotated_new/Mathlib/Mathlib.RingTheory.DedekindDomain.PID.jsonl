{"name":"Ideal.eq_span_singleton_of_mem_of_not_mem_sq_of_not_mem_prime_ne","module":"Mathlib.RingTheory.DedekindDomain.PID","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nP : Ideal R\nhP : P.IsPrime\ninst✝ : IsDedekindDomain R\nx : R\nx_mem : Membership.mem P x\nhxP2 : Not (Membership.mem (HPow.hPow P 2) x)\nhxQ : ∀ (Q : Ideal R), Q.IsPrime → Ne Q P → Not (Membership.mem Q x)\n⊢ Eq P (Ideal.span (Singleton.singleton x))","decl":"/-- Let `P` be a prime ideal, `x ∈ P \\ P²` and `x ∉ Q` for all prime ideals `Q ≠ P`.\nThen `P` is generated by `x`. -/\ntheorem Ideal.eq_span_singleton_of_mem_of_not_mem_sq_of_not_mem_prime_ne {P : Ideal R}\n    (hP : P.IsPrime) [IsDedekindDomain R] {x : R} (x_mem : x ∈ P) (hxP2 : x ∉ P ^ 2)\n    (hxQ : ∀ Q : Ideal R, IsPrime Q → Q ≠ P → x ∉ Q) : P = Ideal.span {x} := by\n  letI := Classical.decEq (Ideal R)\n  have hx0 : x ≠ 0 := by\n    rintro rfl\n    exact hxP2 (zero_mem _)\n  by_cases hP0 : P = ⊥\n  · subst hP0\n    rwa [eq_comm, span_singleton_eq_bot, ← mem_bot]\n  have hspan0 : span ({x} : Set R) ≠ ⊥ := mt Ideal.span_singleton_eq_bot.mp hx0\n  have span_le := (Ideal.span_singleton_le_iff_mem _).mpr x_mem\n  refine\n    associated_iff_eq.mp\n      ((associated_iff_normalizedFactors_eq_normalizedFactors hP0 hspan0).mpr\n        (le_antisymm ((dvd_iff_normalizedFactors_le_normalizedFactors hP0 hspan0).mp ?_) ?_))\n  · rwa [Ideal.dvd_iff_le, Ideal.span_singleton_le_iff_mem]\n  simp only [normalizedFactors_irreducible (Ideal.prime_of_isPrime hP0 hP).irreducible,\n    normalize_eq, Multiset.le_iff_count, Multiset.count_singleton]\n  intro Q\n  split_ifs with hQ\n  · subst hQ\n    refine (Ideal.count_normalizedFactors_eq ?_ ?_).le <;>\n        simp only [Ideal.span_singleton_le_iff_mem, pow_one] <;>\n      assumption\n  by_cases hQp : IsPrime Q\n  · refine (Ideal.count_normalizedFactors_eq ?_ ?_).le <;>\n      -- Porting note: included `zero_add` in the simp arguments\n      simp only [Ideal.span_singleton_le_iff_mem, zero_add, pow_one, pow_zero, one_eq_top,\n                 Submodule.mem_top]\n    exact hxQ _ hQp hQ\n  · exact\n      (Multiset.count_eq_zero.mpr fun hQi =>\n          hQp\n            (isPrime_of_prime\n              (irreducible_iff_prime.mp (irreducible_of_normalized_factor _ hQi)))).le\n\n-- Porting note: replaced three implicit coercions of `I` with explicit `(I : Submodule R A)`\n"}
{"name":"FractionalIdeal.isPrincipal_of_unit_of_comap_mul_span_singleton_eq_top","module":"Mathlib.RingTheory.DedekindDomain.PID","initialProofState":"R : Type u_2\nA : Type u_3\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\nS : Submonoid R\ninst✝ : IsLocalization S A\nI : Units (FractionalIdeal S A)\nv : A\nhv : Membership.mem (↑(Inv.inv I)) v\nh : Eq (Submodule.comap (Algebra.linearMap R A) (HMul.hMul (↑↑I) (Submodule.span R (Singleton.singleton v)))) Top.top\n⊢ (↑↑I).IsPrincipal","decl":"theorem FractionalIdeal.isPrincipal_of_unit_of_comap_mul_span_singleton_eq_top {R A : Type*}\n    [CommRing R] [CommRing A] [Algebra R A] {S : Submonoid R} [IsLocalization S A]\n    (I : (FractionalIdeal S A)ˣ) {v : A} (hv : v ∈ (↑I⁻¹ : FractionalIdeal S A))\n    (h : Submodule.comap (Algebra.linearMap R A) ((I : Submodule R A) * Submodule.span R {v}) = ⊤) :\n    Submodule.IsPrincipal (I : Submodule R A) := by\n  have hinv := I.mul_inv\n  set J := Submodule.comap (Algebra.linearMap R A) ((I : Submodule R A) * Submodule.span R {v})\n  have hJ : IsLocalization.coeSubmodule A J = ↑I * Submodule.span R {v} := by\n    -- Porting note: had to insert `val_eq_coe` into this rewrite.\n    -- Arguably this is because `Subtype.ext_iff` is breaking the `FractionalIdeal` API.\n    rw [Subtype.ext_iff, val_eq_coe, coe_mul, val_eq_coe, coe_one] at hinv\n    apply Submodule.map_comap_eq_self\n    rw [← Submodule.one_eq_range, ← hinv]\n    exact Submodule.mul_le_mul_right ((Submodule.span_singleton_le_iff_mem _ _).2 hv)\n  have : (1 : A) ∈ ↑I * Submodule.span R {v} := by\n    rw [← hJ, h, IsLocalization.coeSubmodule_top, Submodule.mem_one]\n    exact ⟨1, (algebraMap R _).map_one⟩\n  obtain ⟨w, hw, hvw⟩ := Submodule.mem_mul_span_singleton.1 this\n  refine ⟨⟨w, ?_⟩⟩\n  rw [← FractionalIdeal.coe_spanSingleton S, ← inv_inv I, eq_comm]\n  refine congr_arg coeToSubmodule (Units.eq_inv_of_mul_eq_one_left (le_antisymm ?_ ?_))\n  · conv_rhs => rw [← hinv, mul_comm]\n    apply FractionalIdeal.mul_le_mul_left (FractionalIdeal.spanSingleton_le_iff_mem.mpr hw)\n  · rw [FractionalIdeal.one_le, ← hvw, mul_comm]\n    exact FractionalIdeal.mul_mem_mul (FractionalIdeal.mem_spanSingleton_self _ _) hv\n\n"}
{"name":"FractionalIdeal.isPrincipal.of_finite_maximals_of_inv","module":"Mathlib.RingTheory.DedekindDomain.PID","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nA : Type u_2\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\nS : Submonoid R\ninst✝ : IsLocalization S A\nhS : LE.le S (nonZeroDivisors R)\nhf : (setOf fun I => I.IsMaximal).Finite\nI I' : FractionalIdeal S A\nhinv : Eq (HMul.hMul I I') 1\n⊢ (↑I).IsPrincipal","decl":"/--\nAn invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem FractionalIdeal.isPrincipal.of_finite_maximals_of_inv {A : Type*} [CommRing A]\n    [Algebra R A] {S : Submonoid R} [IsLocalization S A] (hS : S ≤ R⁰)\n    (hf : {I : Ideal R | I.IsMaximal}.Finite) (I I' : FractionalIdeal S A) (hinv : I * I' = 1) :\n    Submodule.IsPrincipal (I : Submodule R A) := by\n  have hinv' := hinv\n  rw [Subtype.ext_iff, val_eq_coe, coe_mul] at hinv\n  let s := hf.toFinset\n  haveI := Classical.decEq (Ideal R)\n  have coprime : ∀ M ∈ s, ∀ M' ∈ s.erase M, M ⊔ M' = ⊤ := by\n    simp_rw [s, Finset.mem_erase, hf.mem_toFinset]\n    rintro M hM M' ⟨hne, hM'⟩\n    exact Ideal.IsMaximal.coprime_of_ne hM hM' hne.symm\n  have nle : ∀ M ∈ s, ¬⨅ M' ∈ s.erase M, M' ≤ M := fun M hM =>\n    left_lt_sup.1\n      ((hf.mem_toFinset.1 hM).ne_top.lt_top.trans_eq (Ideal.sup_iInf_eq_top <| coprime M hM).symm)\n  have : ∀ M ∈ s, ∃ a ∈ I, ∃ b ∈ I', a * b ∉ IsLocalization.coeSubmodule A M := by\n    intro M hM; by_contra! h\n    obtain ⟨x, hx, hxM⟩ :=\n      SetLike.exists_of_lt\n        ((IsLocalization.coeSubmodule_strictMono hS (hf.mem_toFinset.1 hM).ne_top.lt_top).trans_eq\n          hinv.symm)\n    exact hxM (Submodule.mul_le.2 h hx)\n  choose! a ha b hb hm using this\n  choose! u hu hum using fun M hM => SetLike.not_le_iff_exists.1 (nle M hM)\n  let v := ∑ M ∈ s, u M • b M\n  have hv : v ∈ I' := Submodule.sum_mem _ fun M hM => Submodule.smul_mem _ _ <| hb M hM\n  refine\n    FractionalIdeal.isPrincipal_of_unit_of_comap_mul_span_singleton_eq_top\n      (Units.mkOfMulEqOne I I' hinv') hv (of_not_not fun h => ?_)\n  obtain ⟨M, hM, hJM⟩ := Ideal.exists_le_maximal _ h\n  replace hM := hf.mem_toFinset.2 hM\n  have : ∀ a ∈ I, ∀ b ∈ I', ∃ c, algebraMap R _ c = a * b := by\n    intro a ha b hb; have hi := hinv.le\n    obtain ⟨c, -, hc⟩ := hi (Submodule.mul_mem_mul ha hb)\n    exact ⟨c, hc⟩\n  have hmem : a M * v ∈ IsLocalization.coeSubmodule A M := by\n    obtain ⟨c, hc⟩ := this _ (ha M hM) v hv\n    refine IsLocalization.coeSubmodule_mono _ hJM ⟨c, ?_, hc⟩\n    have := Submodule.mul_mem_mul (ha M hM) (Submodule.mem_span_singleton_self v)\n    rwa [← hc] at this\n  simp_rw [v, Finset.mul_sum, mul_smul_comm] at hmem\n  rw [← s.add_sum_erase _ hM, Submodule.add_mem_iff_left] at hmem\n  · refine hm M hM ?_\n    obtain ⟨c, hc : algebraMap R A c = a M * b M⟩ := this _ (ha M hM) _ (hb M hM)\n    rw [← hc] at hmem ⊢\n    rw [Algebra.smul_def, ← _root_.map_mul] at hmem\n    obtain ⟨d, hdM, he⟩ := hmem\n    rw [IsLocalization.injective _ hS he] at hdM\n    -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to specify the value of `f`\n    exact Submodule.mem_map_of_mem (f := Algebra.linearMap _ _)\n        (((hf.mem_toFinset.1 hM).isPrime.mem_or_mem hdM).resolve_left <| hum M hM)\n  · refine Submodule.sum_mem _ fun M' hM' => ?_\n    rw [Finset.mem_erase] at hM'\n    obtain ⟨c, hc⟩ := this _ (ha M hM) _ (hb M' hM'.2)\n    rw [← hc, Algebra.smul_def, ← _root_.map_mul]\n    specialize hu M' hM'.2\n    simp_rw [Ideal.mem_iInf, Finset.mem_erase] at hu\n    -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to specify the value of `f`\n    exact Submodule.mem_map_of_mem (f := Algebra.linearMap _ _)\n      (M.mul_mem_right _ <| hu M ⟨hM'.1.symm, hM⟩)\n\n"}
{"name":"Ideal.IsPrincipal.of_finite_maximals_of_isUnit","module":"Mathlib.RingTheory.DedekindDomain.PID","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nhf : (setOf fun I => I.IsMaximal).Finite\nI : Ideal R\nhI : IsUnit ↑I\n⊢ Submodule.IsPrincipal I","decl":"/-- An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem Ideal.IsPrincipal.of_finite_maximals_of_isUnit (hf : {I : Ideal R | I.IsMaximal}.Finite)\n    {I : Ideal R} (hI : IsUnit (I : FractionalIdeal R⁰ (FractionRing R))) : I.IsPrincipal :=\n  (IsLocalization.coeSubmodule_isPrincipal _ le_rfl).mp\n    (FractionalIdeal.isPrincipal.of_finite_maximals_of_inv le_rfl hf I\n      (↑hI.unit⁻¹ : FractionalIdeal R⁰ (FractionRing R)) hI.unit.mul_inv)\n\n"}
{"name":"IsPrincipalIdealRing.of_finite_primes","module":"Mathlib.RingTheory.DedekindDomain.PID","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nh : (setOf fun I => I.IsPrime).Finite\n⊢ IsPrincipalIdealRing R","decl":"/-- A Dedekind domain is a PID if its set of primes is finite. -/\ntheorem IsPrincipalIdealRing.of_finite_primes [IsDedekindDomain R]\n    (h : {I : Ideal R | I.IsPrime}.Finite) : IsPrincipalIdealRing R :=\n  ⟨fun I => by\n    obtain rfl | hI := eq_or_ne I ⊥\n    · exact bot_isPrincipal\n    apply Ideal.IsPrincipal.of_finite_maximals_of_isUnit\n    · apply h.subset; exact @Ideal.IsMaximal.isPrime _ _\n    · exact isUnit_of_mul_eq_one _ _ (FractionalIdeal.coe_ideal_mul_inv I hI)⟩\n\n"}
{"name":"IsLocalization.OverPrime.mem_normalizedFactors_of_isPrime","module":"Mathlib.RingTheory.DedekindDomain.PID","initialProofState":"R : Type u_1\ninst✝¹³ : CommRing R\ninst✝¹² : IsDedekindDomain R\nS : Type u_2\ninst✝¹¹ : CommRing S\ninst✝¹⁰ : Algebra R S\ninst✝⁹ : NoZeroSMulDivisors R S\ninst✝⁸ : Module.Finite R S\np : Ideal R\nhp0 : Ne p Bot.bot\ninst✝⁷ : p.IsPrime\nSₚ : Type u_3\ninst✝⁶ : CommRing Sₚ\ninst✝⁵ : Algebra S Sₚ\ninst✝⁴ : IsLocalization (Algebra.algebraMapSubmonoid S p.primeCompl) Sₚ\ninst✝³ : Algebra R Sₚ\ninst✝² : IsScalarTower R S Sₚ\ninst✝¹ : IsDedekindDomain Sₚ\ninst✝ : IsDomain S\nP : Ideal Sₚ\nhP : P.IsPrime\nhP0 : Ne P Bot.bot\n⊢ Membership.mem (UniqueFactorizationMonoid.normalizedFactors (Ideal.map (algebraMap R Sₚ) p)) P","decl":"/-- If `p` is a prime in the Dedekind domain `R`, `S` an extension of `R` and `Sₚ` the localization\nof `S` at `p`, then all primes in `Sₚ` are factors of the image of `p` in `Sₚ`. -/\ntheorem IsLocalization.OverPrime.mem_normalizedFactors_of_isPrime [IsDomain S]\n    {P : Ideal Sₚ} (hP : IsPrime P) (hP0 : P ≠ ⊥) :\n    P ∈ normalizedFactors (Ideal.map (algebraMap R Sₚ) p) := by\n  have non_zero_div : Algebra.algebraMapSubmonoid S p.primeCompl ≤ S⁰ :=\n    map_le_nonZeroDivisors_of_injective _ (NoZeroSMulDivisors.algebraMap_injective _ _)\n      p.primeCompl_le_nonZeroDivisors\n  letI : Algebra (Localization.AtPrime p) Sₚ := localizationAlgebra p.primeCompl S\n  haveI : IsScalarTower R (Localization.AtPrime p) Sₚ :=\n    IsScalarTower.of_algebraMap_eq fun x => by\n      -- Porting note: replaced `erw` with a `rw` followed by `exact` to help infer implicits\n      rw [IsScalarTower.algebraMap_apply R S]\n      exact (IsLocalization.map_eq (T := Algebra.algebraMapSubmonoid S (primeCompl p))\n        (Submonoid.le_comap_map _) x).symm\n  obtain ⟨pid, p', ⟨hp'0, hp'p⟩, hpu⟩ :=\n    (IsDiscreteValuationRing.iff_pid_with_one_nonzero_prime (Localization.AtPrime p)).mp\n      (IsLocalization.AtPrime.isDiscreteValuationRing_of_dedekind_domain R hp0 _)\n  have : IsLocalRing.maximalIdeal (Localization.AtPrime p) ≠ ⊥ := by\n    rw [Submodule.ne_bot_iff] at hp0 ⊢\n    obtain ⟨x, x_mem, x_ne⟩ := hp0\n    exact\n      ⟨algebraMap _ _ x, (IsLocalization.AtPrime.to_map_mem_maximal_iff _ _ _).mpr x_mem,\n        IsLocalization.to_map_ne_zero_of_mem_nonZeroDivisors _ p.primeCompl_le_nonZeroDivisors\n          (mem_nonZeroDivisors_of_ne_zero x_ne)⟩\n  rw [← Multiset.singleton_le, ← normalize_eq P, ←\n    normalizedFactors_irreducible (Ideal.prime_of_isPrime hP0 hP).irreducible, ←\n    dvd_iff_normalizedFactors_le_normalizedFactors hP0, dvd_iff_le,\n    IsScalarTower.algebraMap_eq R (Localization.AtPrime p) Sₚ, ← Ideal.map_map,\n    Localization.AtPrime.map_eq_maximalIdeal, Ideal.map_le_iff_le_comap,\n    hpu (IsLocalRing.maximalIdeal _) ⟨this, _⟩, hpu (comap _ _) ⟨_, _⟩]\n  · have : Algebra.IsIntegral (Localization.AtPrime p) Sₚ := ⟨isIntegral_localization⟩\n    exact mt (Ideal.eq_bot_of_comap_eq_bot ) hP0\n  · exact Ideal.comap_isPrime (algebraMap (Localization.AtPrime p) Sₚ) P\n  · exact (IsLocalRing.maximalIdeal.isMaximal _).isPrime\n  · rw [Ne, zero_eq_bot, Ideal.map_eq_bot_iff_of_injective]\n    · assumption\n    rw [IsScalarTower.algebraMap_eq R S Sₚ]\n    exact\n      (IsLocalization.injective Sₚ non_zero_div).comp (NoZeroSMulDivisors.algebraMap_injective _ _)\n\n"}
{"name":"IsDedekindDomain.isPrincipalIdealRing_localization_over_prime","module":"Mathlib.RingTheory.DedekindDomain.PID","initialProofState":"R : Type u_1\ninst✝¹³ : CommRing R\ninst✝¹² : IsDedekindDomain R\nS : Type u_2\ninst✝¹¹ : CommRing S\ninst✝¹⁰ : Algebra R S\ninst✝⁹ : NoZeroSMulDivisors R S\ninst✝⁸ : Module.Finite R S\np : Ideal R\nhp0 : Ne p Bot.bot\ninst✝⁷ : p.IsPrime\nSₚ : Type u_3\ninst✝⁶ : CommRing Sₚ\ninst✝⁵ : Algebra S Sₚ\ninst✝⁴ : IsLocalization (Algebra.algebraMapSubmonoid S p.primeCompl) Sₚ\ninst✝³ : Algebra R Sₚ\ninst✝² : IsScalarTower R S Sₚ\ninst✝¹ : IsDedekindDomain Sₚ\ninst✝ : IsDomain S\n⊢ IsPrincipalIdealRing Sₚ","decl":"/-- Let `p` be a prime in the Dedekind domain `R` and `S` be an integral extension of `R`,\nthen the localization `Sₚ` of `S` at `p` is a PID. -/\ntheorem IsDedekindDomain.isPrincipalIdealRing_localization_over_prime [IsDomain S] :\n    IsPrincipalIdealRing Sₚ := by\n  letI := Classical.decEq (Ideal Sₚ)\n  letI := Classical.decPred fun P : Ideal Sₚ => P.IsPrime\n  refine\n    IsPrincipalIdealRing.of_finite_primes\n      (Set.Finite.ofFinset\n        (Finset.filter (fun P => P.IsPrime)\n          ({⊥} ∪ (normalizedFactors (Ideal.map (algebraMap R Sₚ) p)).toFinset))\n        fun P => ?_)\n  rw [Finset.mem_filter, Finset.mem_union, Finset.mem_singleton, Set.mem_setOf,\n    Multiset.mem_toFinset]\n  exact\n    and_iff_right_of_imp fun hP =>\n      or_iff_not_imp_left.mpr (IsLocalization.OverPrime.mem_normalizedFactors_of_isPrime S p hp0 hP)\n"}
