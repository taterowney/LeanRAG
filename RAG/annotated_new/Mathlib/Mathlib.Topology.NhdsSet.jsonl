{"name":"nhdsSet_diagonal","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_3\ninst✝ : TopologicalSpace (Prod X X)\n⊢ Eq (nhdsSet (Set.diagonal X)) (iSup fun x => nhds { fst := x, snd := x })","decl":"theorem nhdsSet_diagonal (X) [TopologicalSpace (X × X)] :\n    𝓝ˢ (diagonal X) = ⨆ (x : X), 𝓝 (x, x) := by\n  rw [nhdsSet, ← range_diag, ← range_comp]\n  rfl\n\n"}
{"name":"mem_nhdsSet_iff_forall","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns t : Set X\n⊢ Iff (Membership.mem (nhdsSet t) s) (∀ (x : X), Membership.mem t x → Membership.mem (nhds x) s)","decl":"theorem mem_nhdsSet_iff_forall : s ∈ 𝓝ˢ t ↔ ∀ x : X, x ∈ t → s ∈ 𝓝 x := by\n  simp_rw [nhdsSet, Filter.mem_sSup, forall_mem_image]\n\n"}
{"name":"nhdsSet_le","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nf : Filter X\ns : Set X\n⊢ Iff (LE.le (nhdsSet s) f) (∀ (x : X), Membership.mem s x → LE.le (nhds x) f)","decl":"lemma nhdsSet_le : 𝓝ˢ s ≤ f ↔ ∀ x ∈ s, 𝓝 x ≤ f := by simp [nhdsSet]\n\n"}
{"name":"bUnion_mem_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\nt : X → Set X\nh : ∀ (x : X), Membership.mem s x → Membership.mem (nhds x) (t x)\n⊢ Membership.mem (nhdsSet s) (Set.iUnion fun x => Set.iUnion fun h => t x)","decl":"theorem bUnion_mem_nhdsSet {t : X → Set X} (h : ∀ x ∈ s, t x ∈ 𝓝 x) : (⋃ x ∈ s, t x) ∈ 𝓝ˢ s :=\n  mem_nhdsSet_iff_forall.2 fun x hx => mem_of_superset (h x hx) <|\n    subset_iUnion₂ (s := fun x _ => t x) x hx -- Porting note: fails to find `s`\n\n"}
{"name":"subset_interior_iff_mem_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns t : Set X\n⊢ Iff (HasSubset.Subset s (interior t)) (Membership.mem (nhdsSet s) t)","decl":"theorem subset_interior_iff_mem_nhdsSet : s ⊆ interior t ↔ t ∈ 𝓝ˢ s := by\n  simp_rw [mem_nhdsSet_iff_forall, subset_interior_iff_nhds]\n\n"}
{"name":"disjoint_principal_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns t : Set X\n⊢ Iff (Disjoint (Filter.principal s) (nhdsSet t)) (Disjoint (closure s) t)","decl":"theorem disjoint_principal_nhdsSet : Disjoint (𝓟 s) (𝓝ˢ t) ↔ Disjoint (closure s) t := by\n  rw [disjoint_principal_left, ← subset_interior_iff_mem_nhdsSet, interior_compl,\n    subset_compl_iff_disjoint_left]\n\n"}
{"name":"disjoint_nhdsSet_principal","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns t : Set X\n⊢ Iff (Disjoint (nhdsSet s) (Filter.principal t)) (Disjoint s (closure t))","decl":"theorem disjoint_nhdsSet_principal : Disjoint (𝓝ˢ s) (𝓟 t) ↔ Disjoint s (closure t) := by\n  rw [disjoint_comm, disjoint_principal_nhdsSet, disjoint_comm]\n\n"}
{"name":"mem_nhdsSet_iff_exists","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns t : Set X\n⊢ Iff (Membership.mem (nhdsSet t) s) (Exists fun U => And (IsOpen U) (And (HasSubset.Subset t U) (HasSubset.Subset U s)))","decl":"theorem mem_nhdsSet_iff_exists : s ∈ 𝓝ˢ t ↔ ∃ U : Set X, IsOpen U ∧ t ⊆ U ∧ U ⊆ s := by\n  rw [← subset_interior_iff_mem_nhdsSet, subset_interior_iff]\n\n"}
{"name":"eventually_nhdsSet_iff_exists","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\np : X → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) (nhdsSet s)) (Exists fun t => And (IsOpen t) (And (HasSubset.Subset s t) (∀ (x : X), Membership.mem t x → p x)))","decl":"/-- A proposition is true on a set neighborhood of `s` iff it is true on a larger open set -/\ntheorem eventually_nhdsSet_iff_exists {p : X → Prop} :\n    (∀ᶠ x in 𝓝ˢ s, p x) ↔ ∃ t, IsOpen t ∧ s ⊆ t ∧ ∀ x, x ∈ t → p x :=\n  mem_nhdsSet_iff_exists\n\n"}
{"name":"eventually_nhdsSet_iff_forall","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\np : X → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) (nhdsSet s)) (∀ (x : X), Membership.mem s x → Filter.Eventually (fun y => p y) (nhds x))","decl":"/-- A proposition is true on a set neighborhood of `s`\niff it is eventually true near each point in the set. -/\ntheorem eventually_nhdsSet_iff_forall {p : X → Prop} :\n    (∀ᶠ x in 𝓝ˢ s, p x) ↔ ∀ x, x ∈ s → ∀ᶠ y in 𝓝 x, p y :=\n  mem_nhdsSet_iff_forall\n\n"}
{"name":"hasBasis_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ (nhdsSet s).HasBasis (fun U => And (IsOpen U) (HasSubset.Subset s U)) fun U => U","decl":"theorem hasBasis_nhdsSet (s : Set X) : (𝓝ˢ s).HasBasis (fun U => IsOpen U ∧ s ⊆ U) fun U => U :=\n  ⟨fun t => by simp [mem_nhdsSet_iff_exists, and_assoc]⟩\n\n"}
{"name":"lift'_nhdsSet_interior","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Eq ((nhdsSet s).lift' interior) (nhdsSet s)","decl":"@[simp]\nlemma lift'_nhdsSet_interior (s : Set X) : (𝓝ˢ s).lift' interior = 𝓝ˢ s :=\n  (hasBasis_nhdsSet s).lift'_interior_eq_self fun _ ↦ And.left\n\n"}
{"name":"Filter.HasBasis.nhdsSet_interior","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nι : Sort u_3\np : ι → Prop\ns : ι → Set X\nt : Set X\nh : (nhdsSet t).HasBasis p s\n⊢ (nhdsSet t).HasBasis p fun x => interior (s x)","decl":"lemma Filter.HasBasis.nhdsSet_interior {ι : Sort*} {p : ι → Prop} {s : ι → Set X} {t : Set X}\n    (h : (𝓝ˢ t).HasBasis p s) : (𝓝ˢ t).HasBasis p (interior <| s ·) :=\n  lift'_nhdsSet_interior t ▸ h.lift'_interior\n\n"}
{"name":"IsOpen.mem_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns t : Set X\nhU : IsOpen s\n⊢ Iff (Membership.mem (nhdsSet t) s) (HasSubset.Subset t s)","decl":"theorem IsOpen.mem_nhdsSet (hU : IsOpen s) : s ∈ 𝓝ˢ t ↔ t ⊆ s := by\n  rw [← subset_interior_iff_mem_nhdsSet, hU.interior_eq]\n\n"}
{"name":"IsOpen.mem_nhdsSet_self","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\nho : IsOpen s\n⊢ Membership.mem (nhdsSet s) s","decl":"/-- An open set belongs to its own set neighborhoods filter. -/\ntheorem IsOpen.mem_nhdsSet_self (ho : IsOpen s) : s ∈ 𝓝ˢ s := ho.mem_nhdsSet.mpr Subset.rfl\n\n"}
{"name":"principal_le_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ LE.le (Filter.principal s) (nhdsSet s)","decl":"theorem principal_le_nhdsSet : 𝓟 s ≤ 𝓝ˢ s := fun _s hs =>\n  (subset_interior_iff_mem_nhdsSet.mpr hs).trans interior_subset\n\n"}
{"name":"subset_of_mem_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns t : Set X\nh : Membership.mem (nhdsSet s) t\n⊢ HasSubset.Subset s t","decl":"theorem subset_of_mem_nhdsSet (h : t ∈ 𝓝ˢ s) : s ⊆ t := principal_le_nhdsSet h\n\n"}
{"name":"Filter.Eventually.self_of_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\np : X → Prop\nh : Filter.Eventually (fun x => p x) (nhdsSet s)\nx : X\na✝ : Membership.mem s x\n⊢ p x","decl":"theorem Filter.Eventually.self_of_nhdsSet {p : X → Prop} (h : ∀ᶠ x in 𝓝ˢ s, p x) : ∀ x ∈ s, p x :=\n  principal_le_nhdsSet h\n\n"}
{"name":"Filter.EventuallyEq.self_of_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\nY : Type u_3\nf g : X → Y\nh : (nhdsSet s).EventuallyEq f g\n⊢ Set.EqOn f g s","decl":"nonrec theorem Filter.EventuallyEq.self_of_nhdsSet {Y} {f g : X → Y} (h : f =ᶠ[𝓝ˢ s] g) :\n    EqOn f g s :=\n  h.self_of_nhdsSet\n\n"}
{"name":"nhdsSet_eq_principal_iff","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (Eq (nhdsSet s) (Filter.principal s)) (IsOpen s)","decl":"@[simp]\ntheorem nhdsSet_eq_principal_iff : 𝓝ˢ s = 𝓟 s ↔ IsOpen s := by\n  rw [← principal_le_nhdsSet.le_iff_eq, le_principal_iff, mem_nhdsSet_iff_forall,\n    isOpen_iff_mem_nhds]\n\n"}
{"name":"IsOpen.nhdsSet_eq","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\na✝ : IsOpen s\n⊢ Eq (nhdsSet s) (Filter.principal s)","decl":"alias ⟨_, IsOpen.nhdsSet_eq⟩ := nhdsSet_eq_principal_iff\n\n"}
{"name":"nhdsSet_interior","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Eq (nhdsSet (interior s)) (Filter.principal (interior s))","decl":"@[simp]\ntheorem nhdsSet_interior : 𝓝ˢ (interior s) = 𝓟 (interior s) :=\n  isOpen_interior.nhdsSet_eq\n\n"}
{"name":"nhdsSet_singleton","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ Eq (nhdsSet (Singleton.singleton x)) (nhds x)","decl":"@[simp]\ntheorem nhdsSet_singleton : 𝓝ˢ {x} = 𝓝 x := by simp [nhdsSet]\n\n"}
{"name":"mem_nhdsSet_interior","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Membership.mem (nhdsSet (interior s)) s","decl":"theorem mem_nhdsSet_interior : s ∈ 𝓝ˢ (interior s) :=\n  subset_interior_iff_mem_nhdsSet.mp Subset.rfl\n\n"}
{"name":"nhdsSet_empty","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Eq (nhdsSet EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem nhdsSet_empty : 𝓝ˢ (∅ : Set X) = ⊥ := by rw [isOpen_empty.nhdsSet_eq, principal_empty]\n\n"}
{"name":"mem_nhdsSet_empty","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Membership.mem (nhdsSet EmptyCollection.emptyCollection) s","decl":"theorem mem_nhdsSet_empty : s ∈ 𝓝ˢ (∅ : Set X) := by simp\n\n"}
{"name":"nhdsSet_univ","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Eq (nhdsSet Set.univ) Top.top","decl":"@[simp]\ntheorem nhdsSet_univ : 𝓝ˢ (univ : Set X) = ⊤ := by rw [isOpen_univ.nhdsSet_eq, principal_univ]\n\n"}
{"name":"nhdsSet_mono","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns t : Set X\nh : HasSubset.Subset s t\n⊢ LE.le (nhdsSet s) (nhdsSet t)","decl":"@[gcongr, mono]\ntheorem nhdsSet_mono (h : s ⊆ t) : 𝓝ˢ s ≤ 𝓝ˢ t :=\n  sSup_le_sSup <| image_subset _ h\n\n"}
{"name":"monotone_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Monotone nhdsSet","decl":"theorem monotone_nhdsSet : Monotone (𝓝ˢ : Set X → Filter X) := fun _ _ => nhdsSet_mono\n\n"}
{"name":"nhds_le_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\nx : X\nh : Membership.mem s x\n⊢ LE.le (nhds x) (nhdsSet s)","decl":"theorem nhds_le_nhdsSet (h : x ∈ s) : 𝓝 x ≤ 𝓝ˢ s :=\n  le_sSup <| mem_image_of_mem _ h\n\n"}
{"name":"nhdsSet_union","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns t : Set X\n⊢ Eq (nhdsSet (Union.union s t)) (Max.max (nhdsSet s) (nhdsSet t))","decl":"@[simp]\ntheorem nhdsSet_union (s t : Set X) : 𝓝ˢ (s ∪ t) = 𝓝ˢ s ⊔ 𝓝ˢ t := by\n  simp only [nhdsSet, image_union, sSup_union]\n\n"}
{"name":"union_mem_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns₁ s₂ t₁ t₂ : Set X\nh₁ : Membership.mem (nhdsSet t₁) s₁\nh₂ : Membership.mem (nhdsSet t₂) s₂\n⊢ Membership.mem (nhdsSet (Union.union t₁ t₂)) (Union.union s₁ s₂)","decl":"theorem union_mem_nhdsSet (h₁ : s₁ ∈ 𝓝ˢ t₁) (h₂ : s₂ ∈ 𝓝ˢ t₂) : s₁ ∪ s₂ ∈ 𝓝ˢ (t₁ ∪ t₂) := by\n  rw [nhdsSet_union]\n  exact union_mem_sup h₁ h₂\n\n"}
{"name":"nhdsSet_insert","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\ns : Set X\n⊢ Eq (nhdsSet (Insert.insert x s)) (Max.max (nhds x) (nhdsSet s))","decl":"@[simp]\ntheorem nhdsSet_insert (x : X) (s : Set X) : 𝓝ˢ (insert x s) = 𝓝 x ⊔ 𝓝ˢ s := by\n  rw [insert_eq, nhdsSet_union, nhdsSet_singleton]\n\n/- This inequality cannot be improved to an equality. For instance,\nif `X` has two elements and the coarse topology and `s` and `t` are distinct singletons then\n`𝓝ˢ (s ∩ t) = ⊥` while `𝓝ˢ s ⊓ 𝓝ˢ t = ⊤` and those are different. -/\n"}
{"name":"nhdsSet_inter_le","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns t : Set X\n⊢ LE.le (nhdsSet (Inter.inter s t)) (Min.min (nhdsSet s) (nhdsSet t))","decl":"theorem nhdsSet_inter_le (s t : Set X) : 𝓝ˢ (s ∩ t) ≤ 𝓝ˢ s ⊓ 𝓝ˢ t :=\n  (monotone_nhdsSet (X := X)).map_inf_le s t\n\n"}
{"name":"nhdsSet_iInter_le","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nι : Sort u_3\ns : ι → Set X\n⊢ LE.le (nhdsSet (Set.iInter fun i => s i)) (iInf fun i => nhdsSet (s i))","decl":"theorem nhdsSet_iInter_le {ι : Sort*} (s : ι → Set X) : 𝓝ˢ (⋂ i, s i) ≤ ⨅ i, 𝓝ˢ (s i) :=\n  (monotone_nhdsSet (X := X)).map_iInf_le\n\n"}
{"name":"nhdsSet_sInter_le","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set (Set X)\n⊢ LE.le (nhdsSet s.sInter) (iInf fun x => iInf fun h => nhdsSet x)","decl":"theorem nhdsSet_sInter_le (s : Set (Set X)) : 𝓝ˢ (⋂₀ s) ≤ ⨅ x ∈ s, 𝓝ˢ x :=\n  (monotone_nhdsSet (X := X)).map_sInf_le\n\n"}
{"name":"IsClosed.nhdsSet_le_sup","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns t : Set X\nh : IsClosed t\n⊢ LE.le (nhdsSet s) (Max.max (nhdsSet (Inter.inter s t)) (Filter.principal (HasCompl.compl t)))","decl":"variable (s) in\ntheorem IsClosed.nhdsSet_le_sup (h : IsClosed t) : 𝓝ˢ s ≤ 𝓝ˢ (s ∩ t) ⊔ 𝓟 (tᶜ) :=\n  calc\n    𝓝ˢ s = 𝓝ˢ (s ∩ t ∪ s ∩ tᶜ) := by rw [Set.inter_union_compl s t]\n    _ = 𝓝ˢ (s ∩ t) ⊔ 𝓝ˢ (s ∩ tᶜ) := by rw [nhdsSet_union]\n    _ ≤ 𝓝ˢ (s ∩ t) ⊔ 𝓝ˢ (tᶜ) := sup_le_sup_left (monotone_nhdsSet inter_subset_right) _\n    _ = 𝓝ˢ (s ∩ t) ⊔ 𝓟 (tᶜ) := by rw [h.isOpen_compl.nhdsSet_eq]\n\n"}
{"name":"IsClosed.nhdsSet_le_sup'","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns t : Set X\nh : IsClosed t\n⊢ LE.le (nhdsSet s) (Max.max (nhdsSet (Inter.inter t s)) (Filter.principal (HasCompl.compl t)))","decl":"variable (s) in\ntheorem IsClosed.nhdsSet_le_sup' (h : IsClosed t) :\n    𝓝ˢ s ≤ 𝓝ˢ (t ∩ s) ⊔ 𝓟 (tᶜ) := by rw [Set.inter_comm]; exact h.nhdsSet_le_sup s\n\n"}
{"name":"Filter.Eventually.eventually_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\np : X → Prop\nh : Filter.Eventually (fun y => p y) (nhdsSet s)\n⊢ Filter.Eventually (fun y => Filter.Eventually (fun x => p x) (nhds y)) (nhdsSet s)","decl":"theorem Filter.Eventually.eventually_nhdsSet {p : X → Prop} (h : ∀ᶠ y in 𝓝ˢ s, p y) :\n    ∀ᶠ y in 𝓝ˢ s, ∀ᶠ x in 𝓝 y, p x :=\n  eventually_nhdsSet_iff_forall.mpr fun x x_in ↦\n    (eventually_nhdsSet_iff_forall.mp h x x_in).eventually_nhds\n\n"}
{"name":"Filter.Eventually.union_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns t : Set X\np : X → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) (nhdsSet (Union.union s t))) (And (Filter.Eventually (fun x => p x) (nhdsSet s)) (Filter.Eventually (fun x => p x) (nhdsSet t)))","decl":"theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :\n    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by\n  rw [nhdsSet_union, eventually_sup]\n\n"}
{"name":"Filter.Eventually.union","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns t : Set X\np : X → Prop\nhs : Filter.Eventually (fun x => p x) (nhdsSet s)\nht : Filter.Eventually (fun x => p x) (nhdsSet t)\n⊢ Filter.Eventually (fun x => p x) (nhdsSet (Union.union s t))","decl":"theorem Filter.Eventually.union {p : X → Prop} (hs : ∀ᶠ x in 𝓝ˢ s, p x) (ht : ∀ᶠ x in 𝓝ˢ t, p x) :\n    ∀ᶠ x in 𝓝ˢ (s ∪ t), p x :=\n  Filter.Eventually.union_nhdsSet.mpr ⟨hs, ht⟩\n\n"}
{"name":"nhdsSet_iUnion","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nι : Sort u_3\ns : ι → Set X\n⊢ Eq (nhdsSet (Set.iUnion fun i => s i)) (iSup fun i => nhdsSet (s i))","decl":"theorem nhdsSet_iUnion {ι : Sort*} (s : ι → Set X) : 𝓝ˢ (⋃ i, s i) = ⨆ i, 𝓝ˢ (s i) := by\n  simp only [nhdsSet, image_iUnion, sSup_iUnion (β := Filter X)]\n\n"}
{"name":"eventually_nhdsSet_iUnion₂","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nι : Sort u_3\np : ι → Prop\ns : ι → Set X\nP : X → Prop\n⊢ Iff (Filter.Eventually (fun x => P x) (nhdsSet (Set.iUnion fun i => Set.iUnion fun x => s i))) (∀ (i : ι), p i → Filter.Eventually (fun x => P x) (nhdsSet (s i)))","decl":"theorem eventually_nhdsSet_iUnion₂ {ι : Sort*} {p : ι → Prop} {s : ι → Set X} {P : X → Prop} :\n    (∀ᶠ x in 𝓝ˢ (⋃ (i) (_ : p i), s i), P x) ↔ ∀ i, p i → ∀ᶠ x in 𝓝ˢ (s i), P x := by\n  simp only [nhdsSet_iUnion, eventually_iSup]\n\n"}
{"name":"eventually_nhdsSet_iUnion","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nι : Sort u_3\ns : ι → Set X\nP : X → Prop\n⊢ Iff (Filter.Eventually (fun x => P x) (nhdsSet (Set.iUnion fun i => s i))) (∀ (i : ι), Filter.Eventually (fun x => P x) (nhdsSet (s i)))","decl":"theorem eventually_nhdsSet_iUnion {ι : Sort*} {s : ι → Set X} {P : X → Prop} :\n    (∀ᶠ x in 𝓝ˢ (⋃ i, s i), P x) ↔ ∀ i, ∀ᶠ x in 𝓝ˢ (s i), P x := by\n  simp only [nhdsSet_iUnion, eventually_iSup]\n"}
