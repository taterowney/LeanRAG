{"name":"nhdsSet_diagonal","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_3\ninstâœ : TopologicalSpace (Prod X X)\nâŠ¢ Eq (nhdsSet (Set.diagonal X)) (iSup fun x => nhds { fst := x, snd := x })","decl":"theorem nhdsSet_diagonal (X) [TopologicalSpace (X Ã— X)] :\n    ğ“Ë¢ (diagonal X) = â¨† (x : X), ğ“ (x, x) := by\n  rw [nhdsSet, â† range_diag, â† range_comp]\n  rfl\n\n"}
{"name":"mem_nhdsSet_iff_forall","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns t : Set X\nâŠ¢ Iff (Membership.mem (nhdsSet t) s) (âˆ€ (x : X), Membership.mem t x â†’ Membership.mem (nhds x) s)","decl":"theorem mem_nhdsSet_iff_forall : s âˆˆ ğ“Ë¢ t â†” âˆ€ x : X, x âˆˆ t â†’ s âˆˆ ğ“ x := by\n  simp_rw [nhdsSet, Filter.mem_sSup, forall_mem_image]\n\n"}
{"name":"nhdsSet_le","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nf : Filter X\ns : Set X\nâŠ¢ Iff (LE.le (nhdsSet s) f) (âˆ€ (x : X), Membership.mem s x â†’ LE.le (nhds x) f)","decl":"lemma nhdsSet_le : ğ“Ë¢ s â‰¤ f â†” âˆ€ x âˆˆ s, ğ“ x â‰¤ f := by simp [nhdsSet]\n\n"}
{"name":"bUnion_mem_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns : Set X\nt : X â†’ Set X\nh : âˆ€ (x : X), Membership.mem s x â†’ Membership.mem (nhds x) (t x)\nâŠ¢ Membership.mem (nhdsSet s) (Set.iUnion fun x => Set.iUnion fun h => t x)","decl":"theorem bUnion_mem_nhdsSet {t : X â†’ Set X} (h : âˆ€ x âˆˆ s, t x âˆˆ ğ“ x) : (â‹ƒ x âˆˆ s, t x) âˆˆ ğ“Ë¢ s :=\n  mem_nhdsSet_iff_forall.2 fun x hx => mem_of_superset (h x hx) <|\n    subset_iUnionâ‚‚ (s := fun x _ => t x) x hx -- Porting note: fails to find `s`\n\n"}
{"name":"subset_interior_iff_mem_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns t : Set X\nâŠ¢ Iff (HasSubset.Subset s (interior t)) (Membership.mem (nhdsSet s) t)","decl":"theorem subset_interior_iff_mem_nhdsSet : s âŠ† interior t â†” t âˆˆ ğ“Ë¢ s := by\n  simp_rw [mem_nhdsSet_iff_forall, subset_interior_iff_nhds]\n\n"}
{"name":"disjoint_principal_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns t : Set X\nâŠ¢ Iff (Disjoint (Filter.principal s) (nhdsSet t)) (Disjoint (closure s) t)","decl":"theorem disjoint_principal_nhdsSet : Disjoint (ğ“Ÿ s) (ğ“Ë¢ t) â†” Disjoint (closure s) t := by\n  rw [disjoint_principal_left, â† subset_interior_iff_mem_nhdsSet, interior_compl,\n    subset_compl_iff_disjoint_left]\n\n"}
{"name":"disjoint_nhdsSet_principal","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns t : Set X\nâŠ¢ Iff (Disjoint (nhdsSet s) (Filter.principal t)) (Disjoint s (closure t))","decl":"theorem disjoint_nhdsSet_principal : Disjoint (ğ“Ë¢ s) (ğ“Ÿ t) â†” Disjoint s (closure t) := by\n  rw [disjoint_comm, disjoint_principal_nhdsSet, disjoint_comm]\n\n"}
{"name":"mem_nhdsSet_iff_exists","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns t : Set X\nâŠ¢ Iff (Membership.mem (nhdsSet t) s) (Exists fun U => And (IsOpen U) (And (HasSubset.Subset t U) (HasSubset.Subset U s)))","decl":"theorem mem_nhdsSet_iff_exists : s âˆˆ ğ“Ë¢ t â†” âˆƒ U : Set X, IsOpen U âˆ§ t âŠ† U âˆ§ U âŠ† s := by\n  rw [â† subset_interior_iff_mem_nhdsSet, subset_interior_iff]\n\n"}
{"name":"eventually_nhdsSet_iff_exists","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns : Set X\np : X â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => p x) (nhdsSet s)) (Exists fun t => And (IsOpen t) (And (HasSubset.Subset s t) (âˆ€ (x : X), Membership.mem t x â†’ p x)))","decl":"/-- A proposition is true on a set neighborhood of `s` iff it is true on a larger open set -/\ntheorem eventually_nhdsSet_iff_exists {p : X â†’ Prop} :\n    (âˆ€á¶  x in ğ“Ë¢ s, p x) â†” âˆƒ t, IsOpen t âˆ§ s âŠ† t âˆ§ âˆ€ x, x âˆˆ t â†’ p x :=\n  mem_nhdsSet_iff_exists\n\n"}
{"name":"eventually_nhdsSet_iff_forall","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns : Set X\np : X â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => p x) (nhdsSet s)) (âˆ€ (x : X), Membership.mem s x â†’ Filter.Eventually (fun y => p y) (nhds x))","decl":"/-- A proposition is true on a set neighborhood of `s`\niff it is eventually true near each point in the set. -/\ntheorem eventually_nhdsSet_iff_forall {p : X â†’ Prop} :\n    (âˆ€á¶  x in ğ“Ë¢ s, p x) â†” âˆ€ x, x âˆˆ s â†’ âˆ€á¶  y in ğ“ x, p y :=\n  mem_nhdsSet_iff_forall\n\n"}
{"name":"hasBasis_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns : Set X\nâŠ¢ (nhdsSet s).HasBasis (fun U => And (IsOpen U) (HasSubset.Subset s U)) fun U => U","decl":"theorem hasBasis_nhdsSet (s : Set X) : (ğ“Ë¢ s).HasBasis (fun U => IsOpen U âˆ§ s âŠ† U) fun U => U :=\n  âŸ¨fun t => by simp [mem_nhdsSet_iff_exists, and_assoc]âŸ©\n\n"}
{"name":"lift'_nhdsSet_interior","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns : Set X\nâŠ¢ Eq ((nhdsSet s).lift' interior) (nhdsSet s)","decl":"@[simp]\nlemma lift'_nhdsSet_interior (s : Set X) : (ğ“Ë¢ s).lift' interior = ğ“Ë¢ s :=\n  (hasBasis_nhdsSet s).lift'_interior_eq_self fun _ â†¦ And.left\n\n"}
{"name":"Filter.HasBasis.nhdsSet_interior","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nÎ¹ : Sort u_3\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set X\nt : Set X\nh : (nhdsSet t).HasBasis p s\nâŠ¢ (nhdsSet t).HasBasis p fun x => interior (s x)","decl":"lemma Filter.HasBasis.nhdsSet_interior {Î¹ : Sort*} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set X} {t : Set X}\n    (h : (ğ“Ë¢ t).HasBasis p s) : (ğ“Ë¢ t).HasBasis p (interior <| s Â·) :=\n  lift'_nhdsSet_interior t â–¸ h.lift'_interior\n\n"}
{"name":"IsOpen.mem_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns t : Set X\nhU : IsOpen s\nâŠ¢ Iff (Membership.mem (nhdsSet t) s) (HasSubset.Subset t s)","decl":"theorem IsOpen.mem_nhdsSet (hU : IsOpen s) : s âˆˆ ğ“Ë¢ t â†” t âŠ† s := by\n  rw [â† subset_interior_iff_mem_nhdsSet, hU.interior_eq]\n\n"}
{"name":"IsOpen.mem_nhdsSet_self","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns : Set X\nho : IsOpen s\nâŠ¢ Membership.mem (nhdsSet s) s","decl":"/-- An open set belongs to its own set neighborhoods filter. -/\ntheorem IsOpen.mem_nhdsSet_self (ho : IsOpen s) : s âˆˆ ğ“Ë¢ s := ho.mem_nhdsSet.mpr Subset.rfl\n\n"}
{"name":"principal_le_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns : Set X\nâŠ¢ LE.le (Filter.principal s) (nhdsSet s)","decl":"theorem principal_le_nhdsSet : ğ“Ÿ s â‰¤ ğ“Ë¢ s := fun _s hs =>\n  (subset_interior_iff_mem_nhdsSet.mpr hs).trans interior_subset\n\n"}
{"name":"subset_of_mem_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns t : Set X\nh : Membership.mem (nhdsSet s) t\nâŠ¢ HasSubset.Subset s t","decl":"theorem subset_of_mem_nhdsSet (h : t âˆˆ ğ“Ë¢ s) : s âŠ† t := principal_le_nhdsSet h\n\n"}
{"name":"Filter.Eventually.self_of_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns : Set X\np : X â†’ Prop\nh : Filter.Eventually (fun x => p x) (nhdsSet s)\nx : X\naâœ : Membership.mem s x\nâŠ¢ p x","decl":"theorem Filter.Eventually.self_of_nhdsSet {p : X â†’ Prop} (h : âˆ€á¶  x in ğ“Ë¢ s, p x) : âˆ€ x âˆˆ s, p x :=\n  principal_le_nhdsSet h\n\n"}
{"name":"Filter.EventuallyEq.self_of_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns : Set X\nY : Type u_3\nf g : X â†’ Y\nh : (nhdsSet s).EventuallyEq f g\nâŠ¢ Set.EqOn f g s","decl":"nonrec theorem Filter.EventuallyEq.self_of_nhdsSet {Y} {f g : X â†’ Y} (h : f =á¶ [ğ“Ë¢ s] g) :\n    EqOn f g s :=\n  h.self_of_nhdsSet\n\n"}
{"name":"nhdsSet_eq_principal_iff","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns : Set X\nâŠ¢ Iff (Eq (nhdsSet s) (Filter.principal s)) (IsOpen s)","decl":"@[simp]\ntheorem nhdsSet_eq_principal_iff : ğ“Ë¢ s = ğ“Ÿ s â†” IsOpen s := by\n  rw [â† principal_le_nhdsSet.le_iff_eq, le_principal_iff, mem_nhdsSet_iff_forall,\n    isOpen_iff_mem_nhds]\n\n"}
{"name":"IsOpen.nhdsSet_eq","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns : Set X\naâœ : IsOpen s\nâŠ¢ Eq (nhdsSet s) (Filter.principal s)","decl":"alias âŸ¨_, IsOpen.nhdsSet_eqâŸ© := nhdsSet_eq_principal_iff\n\n"}
{"name":"nhdsSet_interior","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns : Set X\nâŠ¢ Eq (nhdsSet (interior s)) (Filter.principal (interior s))","decl":"@[simp]\ntheorem nhdsSet_interior : ğ“Ë¢ (interior s) = ğ“Ÿ (interior s) :=\n  isOpen_interior.nhdsSet_eq\n\n"}
{"name":"nhdsSet_singleton","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nx : X\nâŠ¢ Eq (nhdsSet (Singleton.singleton x)) (nhds x)","decl":"@[simp]\ntheorem nhdsSet_singleton : ğ“Ë¢ {x} = ğ“ x := by simp [nhdsSet]\n\n"}
{"name":"mem_nhdsSet_interior","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns : Set X\nâŠ¢ Membership.mem (nhdsSet (interior s)) s","decl":"theorem mem_nhdsSet_interior : s âˆˆ ğ“Ë¢ (interior s) :=\n  subset_interior_iff_mem_nhdsSet.mp Subset.rfl\n\n"}
{"name":"nhdsSet_empty","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nâŠ¢ Eq (nhdsSet EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem nhdsSet_empty : ğ“Ë¢ (âˆ… : Set X) = âŠ¥ := by rw [isOpen_empty.nhdsSet_eq, principal_empty]\n\n"}
{"name":"mem_nhdsSet_empty","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns : Set X\nâŠ¢ Membership.mem (nhdsSet EmptyCollection.emptyCollection) s","decl":"theorem mem_nhdsSet_empty : s âˆˆ ğ“Ë¢ (âˆ… : Set X) := by simp\n\n"}
{"name":"nhdsSet_univ","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nâŠ¢ Eq (nhdsSet Set.univ) Top.top","decl":"@[simp]\ntheorem nhdsSet_univ : ğ“Ë¢ (univ : Set X) = âŠ¤ := by rw [isOpen_univ.nhdsSet_eq, principal_univ]\n\n"}
{"name":"nhdsSet_mono","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns t : Set X\nh : HasSubset.Subset s t\nâŠ¢ LE.le (nhdsSet s) (nhdsSet t)","decl":"@[gcongr, mono]\ntheorem nhdsSet_mono (h : s âŠ† t) : ğ“Ë¢ s â‰¤ ğ“Ë¢ t :=\n  sSup_le_sSup <| image_subset _ h\n\n"}
{"name":"monotone_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nâŠ¢ Monotone nhdsSet","decl":"theorem monotone_nhdsSet : Monotone (ğ“Ë¢ : Set X â†’ Filter X) := fun _ _ => nhdsSet_mono\n\n"}
{"name":"nhds_le_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns : Set X\nx : X\nh : Membership.mem s x\nâŠ¢ LE.le (nhds x) (nhdsSet s)","decl":"theorem nhds_le_nhdsSet (h : x âˆˆ s) : ğ“ x â‰¤ ğ“Ë¢ s :=\n  le_sSup <| mem_image_of_mem _ h\n\n"}
{"name":"nhdsSet_union","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns t : Set X\nâŠ¢ Eq (nhdsSet (Union.union s t)) (Max.max (nhdsSet s) (nhdsSet t))","decl":"@[simp]\ntheorem nhdsSet_union (s t : Set X) : ğ“Ë¢ (s âˆª t) = ğ“Ë¢ s âŠ” ğ“Ë¢ t := by\n  simp only [nhdsSet, image_union, sSup_union]\n\n"}
{"name":"union_mem_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nsâ‚ sâ‚‚ tâ‚ tâ‚‚ : Set X\nhâ‚ : Membership.mem (nhdsSet tâ‚) sâ‚\nhâ‚‚ : Membership.mem (nhdsSet tâ‚‚) sâ‚‚\nâŠ¢ Membership.mem (nhdsSet (Union.union tâ‚ tâ‚‚)) (Union.union sâ‚ sâ‚‚)","decl":"theorem union_mem_nhdsSet (hâ‚ : sâ‚ âˆˆ ğ“Ë¢ tâ‚) (hâ‚‚ : sâ‚‚ âˆˆ ğ“Ë¢ tâ‚‚) : sâ‚ âˆª sâ‚‚ âˆˆ ğ“Ë¢ (tâ‚ âˆª tâ‚‚) := by\n  rw [nhdsSet_union]\n  exact union_mem_sup hâ‚ hâ‚‚\n\n"}
{"name":"nhdsSet_insert","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nx : X\ns : Set X\nâŠ¢ Eq (nhdsSet (Insert.insert x s)) (Max.max (nhds x) (nhdsSet s))","decl":"@[simp]\ntheorem nhdsSet_insert (x : X) (s : Set X) : ğ“Ë¢ (insert x s) = ğ“ x âŠ” ğ“Ë¢ s := by\n  rw [insert_eq, nhdsSet_union, nhdsSet_singleton]\n\n/- This inequality cannot be improved to an equality. For instance,\nif `X` has two elements and the coarse topology and `s` and `t` are distinct singletons then\n`ğ“Ë¢ (s âˆ© t) = âŠ¥` while `ğ“Ë¢ s âŠ“ ğ“Ë¢ t = âŠ¤` and those are different. -/\n"}
{"name":"nhdsSet_inter_le","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns t : Set X\nâŠ¢ LE.le (nhdsSet (Inter.inter s t)) (Min.min (nhdsSet s) (nhdsSet t))","decl":"theorem nhdsSet_inter_le (s t : Set X) : ğ“Ë¢ (s âˆ© t) â‰¤ ğ“Ë¢ s âŠ“ ğ“Ë¢ t :=\n  (monotone_nhdsSet (X := X)).map_inf_le s t\n\n"}
{"name":"nhdsSet_iInter_le","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nÎ¹ : Sort u_3\ns : Î¹ â†’ Set X\nâŠ¢ LE.le (nhdsSet (Set.iInter fun i => s i)) (iInf fun i => nhdsSet (s i))","decl":"theorem nhdsSet_iInter_le {Î¹ : Sort*} (s : Î¹ â†’ Set X) : ğ“Ë¢ (â‹‚ i, s i) â‰¤ â¨… i, ğ“Ë¢ (s i) :=\n  (monotone_nhdsSet (X := X)).map_iInf_le\n\n"}
{"name":"nhdsSet_sInter_le","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns : Set (Set X)\nâŠ¢ LE.le (nhdsSet s.sInter) (iInf fun x => iInf fun h => nhdsSet x)","decl":"theorem nhdsSet_sInter_le (s : Set (Set X)) : ğ“Ë¢ (â‹‚â‚€ s) â‰¤ â¨… x âˆˆ s, ğ“Ë¢ x :=\n  (monotone_nhdsSet (X := X)).map_sInf_le\n\n"}
{"name":"IsClosed.nhdsSet_le_sup","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns t : Set X\nh : IsClosed t\nâŠ¢ LE.le (nhdsSet s) (Max.max (nhdsSet (Inter.inter s t)) (Filter.principal (HasCompl.compl t)))","decl":"variable (s) in\ntheorem IsClosed.nhdsSet_le_sup (h : IsClosed t) : ğ“Ë¢ s â‰¤ ğ“Ë¢ (s âˆ© t) âŠ” ğ“Ÿ (tá¶œ) :=\n  calc\n    ğ“Ë¢ s = ğ“Ë¢ (s âˆ© t âˆª s âˆ© tá¶œ) := by rw [Set.inter_union_compl s t]\n    _ = ğ“Ë¢ (s âˆ© t) âŠ” ğ“Ë¢ (s âˆ© tá¶œ) := by rw [nhdsSet_union]\n    _ â‰¤ ğ“Ë¢ (s âˆ© t) âŠ” ğ“Ë¢ (tá¶œ) := sup_le_sup_left (monotone_nhdsSet inter_subset_right) _\n    _ = ğ“Ë¢ (s âˆ© t) âŠ” ğ“Ÿ (tá¶œ) := by rw [h.isOpen_compl.nhdsSet_eq]\n\n"}
{"name":"IsClosed.nhdsSet_le_sup'","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns t : Set X\nh : IsClosed t\nâŠ¢ LE.le (nhdsSet s) (Max.max (nhdsSet (Inter.inter t s)) (Filter.principal (HasCompl.compl t)))","decl":"variable (s) in\ntheorem IsClosed.nhdsSet_le_sup' (h : IsClosed t) :\n    ğ“Ë¢ s â‰¤ ğ“Ë¢ (t âˆ© s) âŠ” ğ“Ÿ (tá¶œ) := by rw [Set.inter_comm]; exact h.nhdsSet_le_sup s\n\n"}
{"name":"Filter.Eventually.eventually_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns : Set X\np : X â†’ Prop\nh : Filter.Eventually (fun y => p y) (nhdsSet s)\nâŠ¢ Filter.Eventually (fun y => Filter.Eventually (fun x => p x) (nhds y)) (nhdsSet s)","decl":"theorem Filter.Eventually.eventually_nhdsSet {p : X â†’ Prop} (h : âˆ€á¶  y in ğ“Ë¢ s, p y) :\n    âˆ€á¶  y in ğ“Ë¢ s, âˆ€á¶  x in ğ“ y, p x :=\n  eventually_nhdsSet_iff_forall.mpr fun x x_in â†¦\n    (eventually_nhdsSet_iff_forall.mp h x x_in).eventually_nhds\n\n"}
{"name":"Filter.Eventually.union_nhdsSet","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns t : Set X\np : X â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => p x) (nhdsSet (Union.union s t))) (And (Filter.Eventually (fun x => p x) (nhdsSet s)) (Filter.Eventually (fun x => p x) (nhdsSet t)))","decl":"theorem Filter.Eventually.union_nhdsSet {p : X â†’ Prop} :\n    (âˆ€á¶  x in ğ“Ë¢ (s âˆª t), p x) â†” (âˆ€á¶  x in ğ“Ë¢ s, p x) âˆ§ âˆ€á¶  x in ğ“Ë¢ t, p x := by\n  rw [nhdsSet_union, eventually_sup]\n\n"}
{"name":"Filter.Eventually.union","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns t : Set X\np : X â†’ Prop\nhs : Filter.Eventually (fun x => p x) (nhdsSet s)\nht : Filter.Eventually (fun x => p x) (nhdsSet t)\nâŠ¢ Filter.Eventually (fun x => p x) (nhdsSet (Union.union s t))","decl":"theorem Filter.Eventually.union {p : X â†’ Prop} (hs : âˆ€á¶  x in ğ“Ë¢ s, p x) (ht : âˆ€á¶  x in ğ“Ë¢ t, p x) :\n    âˆ€á¶  x in ğ“Ë¢ (s âˆª t), p x :=\n  Filter.Eventually.union_nhdsSet.mpr âŸ¨hs, htâŸ©\n\n"}
{"name":"nhdsSet_iUnion","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nÎ¹ : Sort u_3\ns : Î¹ â†’ Set X\nâŠ¢ Eq (nhdsSet (Set.iUnion fun i => s i)) (iSup fun i => nhdsSet (s i))","decl":"theorem nhdsSet_iUnion {Î¹ : Sort*} (s : Î¹ â†’ Set X) : ğ“Ë¢ (â‹ƒ i, s i) = â¨† i, ğ“Ë¢ (s i) := by\n  simp only [nhdsSet, image_iUnion, sSup_iUnion (Î² := Filter X)]\n\n"}
{"name":"eventually_nhdsSet_iUnionâ‚‚","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nÎ¹ : Sort u_3\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set X\nP : X â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => P x) (nhdsSet (Set.iUnion fun i => Set.iUnion fun x => s i))) (âˆ€ (i : Î¹), p i â†’ Filter.Eventually (fun x => P x) (nhdsSet (s i)))","decl":"theorem eventually_nhdsSet_iUnionâ‚‚ {Î¹ : Sort*} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set X} {P : X â†’ Prop} :\n    (âˆ€á¶  x in ğ“Ë¢ (â‹ƒ (i) (_ : p i), s i), P x) â†” âˆ€ i, p i â†’ âˆ€á¶  x in ğ“Ë¢ (s i), P x := by\n  simp only [nhdsSet_iUnion, eventually_iSup]\n\n"}
{"name":"eventually_nhdsSet_iUnion","module":"Mathlib.Topology.NhdsSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nÎ¹ : Sort u_3\ns : Î¹ â†’ Set X\nP : X â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => P x) (nhdsSet (Set.iUnion fun i => s i))) (âˆ€ (i : Î¹), Filter.Eventually (fun x => P x) (nhdsSet (s i)))","decl":"theorem eventually_nhdsSet_iUnion {Î¹ : Sort*} {s : Î¹ â†’ Set X} {P : X â†’ Prop} :\n    (âˆ€á¶  x in ğ“Ë¢ (â‹ƒ i, s i), P x) â†” âˆ€ i, âˆ€á¶  x in ğ“Ë¢ (s i), P x := by\n  simp only [nhdsSet_iUnion, eventually_iSup]\n"}
