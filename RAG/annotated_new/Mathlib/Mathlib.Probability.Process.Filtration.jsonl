{"name":"MeasureTheory.Filtration.mk.injEq","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_2\ninst✝ : Preorder ι\nm : MeasurableSpace Ω\nseq✝ : ι → MeasurableSpace Ω\nmono'✝ : Monotone seq✝\nle'✝ : ∀ (i : ι), LE.le (seq✝ i) m\nseq : ι → MeasurableSpace Ω\nmono' : Monotone seq\nle' : ∀ (i : ι), LE.le (seq i) m\n⊢ Eq (Eq { seq := seq✝, mono' := mono'✝, le' := le'✝ } { seq := seq, mono' := mono', le' := le' }) (Eq seq✝ seq)","decl":"/-- A `Filtration` on a measurable space `Ω` with σ-algebra `m` is a monotone\nsequence of sub-σ-algebras of `m`. -/\nstructure Filtration {Ω : Type*} (ι : Type*) [Preorder ι] (m : MeasurableSpace Ω) where\n  seq : ι → MeasurableSpace Ω\n  mono' : Monotone seq\n  le' : ∀ i : ι, seq i ≤ m\n\n"}
{"name":"MeasureTheory.Filtration.mk.inj","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_2\ninst✝ : Preorder ι\nm : MeasurableSpace Ω\nseq✝ : ι → MeasurableSpace Ω\nmono'✝ : Monotone seq✝\nle'✝ : ∀ (i : ι), LE.le (seq✝ i) m\nseq : ι → MeasurableSpace Ω\nmono' : Monotone seq\nle' : ∀ (i : ι), LE.le (seq i) m\nx✝ : Eq { seq := seq✝, mono' := mono'✝, le' := le'✝ } { seq := seq, mono' := mono', le' := le' }\n⊢ Eq seq✝ seq","decl":"/-- A `Filtration` on a measurable space `Ω` with σ-algebra `m` is a monotone\nsequence of sub-σ-algebras of `m`. -/\nstructure Filtration {Ω : Type*} (ι : Type*) [Preorder ι] (m : MeasurableSpace Ω) where\n  seq : ι → MeasurableSpace Ω\n  mono' : Monotone seq\n  le' : ∀ i : ι, seq i ≤ m\n\n"}
{"name":"MeasureTheory.Filtration.le'","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_2\ninst✝ : Preorder ι\nm : MeasurableSpace Ω\nself : MeasureTheory.Filtration ι m\ni : ι\n⊢ LE.le (self.seq i) m","decl":"/-- A `Filtration` on a measurable space `Ω` with σ-algebra `m` is a monotone\nsequence of sub-σ-algebras of `m`. -/\nstructure Filtration {Ω : Type*} (ι : Type*) [Preorder ι] (m : MeasurableSpace Ω) where\n  seq : ι → MeasurableSpace Ω\n  mono' : Monotone seq\n  le' : ∀ i : ι, seq i ≤ m\n\n"}
{"name":"MeasureTheory.Filtration.mk.sizeOf_spec","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_2\ninst✝² : Preorder ι\nm : MeasurableSpace Ω\ninst✝¹ : SizeOf Ω\ninst✝ : SizeOf ι\nseq : ι → MeasurableSpace Ω\nmono' : Monotone seq\nle' : ∀ (i : ι), LE.le (seq i) m\n⊢ Eq (SizeOf.sizeOf { seq := seq, mono' := mono', le' := le' }) 1","decl":"/-- A `Filtration` on a measurable space `Ω` with σ-algebra `m` is a monotone\nsequence of sub-σ-algebras of `m`. -/\nstructure Filtration {Ω : Type*} (ι : Type*) [Preorder ι] (m : MeasurableSpace Ω) where\n  seq : ι → MeasurableSpace Ω\n  mono' : Monotone seq\n  le' : ∀ i : ι, seq i ≤ m\n\n"}
{"name":"MeasureTheory.Filtration.mono'","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_2\ninst✝ : Preorder ι\nm : MeasurableSpace Ω\nself : MeasureTheory.Filtration ι m\n⊢ Monotone self.seq","decl":"/-- A `Filtration` on a measurable space `Ω` with σ-algebra `m` is a monotone\nsequence of sub-σ-algebras of `m`. -/\nstructure Filtration {Ω : Type*} (ι : Type*) [Preorder ι] (m : MeasurableSpace Ω) where\n  seq : ι → MeasurableSpace Ω\n  mono' : Monotone seq\n  le' : ∀ i : ι, seq i ≤ m\n\n"}
{"name":"MeasureTheory.Filtration.mono","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\ni j : ι\nf : MeasureTheory.Filtration ι m\nhij : LE.le i j\n⊢ LE.le (↑f i) (↑f j)","decl":"protected theorem mono {i j : ι} (f : Filtration ι m) (hij : i ≤ j) : f i ≤ f j :=\n  f.mono' hij\n\n"}
{"name":"MeasureTheory.Filtration.le","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\nf : MeasureTheory.Filtration ι m\ni : ι\n⊢ LE.le (↑f i) m","decl":"protected theorem le (f : Filtration ι m) (i : ι) : f i ≤ m :=\n  f.le' i\n\n"}
{"name":"MeasureTheory.Filtration.ext_iff","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\nf g : MeasureTheory.Filtration ι m\n⊢ Iff (Eq f g) (Eq ↑f ↑g)","decl":"@[ext]\nprotected theorem ext {f g : Filtration ι m} (h : (f : ι → MeasurableSpace Ω) = g) : f = g := by\n  cases f; cases g; congr\n\n"}
{"name":"MeasureTheory.Filtration.ext","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\nf g : MeasureTheory.Filtration ι m\nh : Eq ↑f ↑g\n⊢ Eq f g","decl":"@[ext]\nprotected theorem ext {f g : Filtration ι m} (h : (f : ι → MeasurableSpace Ω) = g) : f = g := by\n  cases f; cases g; congr\n\n"}
{"name":"MeasureTheory.Filtration.const_apply","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\nm' : MeasurableSpace Ω\nhm' : LE.le m' m\ni : ι\n⊢ Eq (↑(MeasureTheory.Filtration.const ι m' hm') i) m'","decl":"@[simp]\ntheorem const_apply {m' : MeasurableSpace Ω} {hm' : m' ≤ m} (i : ι) : const ι m' hm' i = m' :=\n  rfl\n\n"}
{"name":"MeasureTheory.Filtration.coeFn_sup","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\nf g : MeasureTheory.Filtration ι m\n⊢ Eq (↑(Max.max f g)) (Max.max ↑f ↑g)","decl":"@[norm_cast]\ntheorem coeFn_sup {f g : Filtration ι m} : ⇑(f ⊔ g) = ⇑f ⊔ ⇑g :=\n  rfl\n\n"}
{"name":"MeasureTheory.Filtration.coeFn_inf","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\nf g : MeasureTheory.Filtration ι m\n⊢ Eq (↑(Min.min f g)) (Min.min ↑f ↑g)","decl":"@[norm_cast]\ntheorem coeFn_inf {f g : Filtration ι m} : ⇑(f ⊓ g) = ⇑f ⊓ ⇑g :=\n  rfl\n\n"}
{"name":"MeasureTheory.Filtration.sSup_def","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\ns : Set (MeasureTheory.Filtration ι m)\ni : ι\n⊢ Eq (↑(SupSet.sSup s) i) (SupSet.sSup (Set.image (fun f => ↑f i) s))","decl":"theorem sSup_def (s : Set (Filtration ι m)) (i : ι) :\n    sSup s i = sSup ((fun f : Filtration ι m => f i) '' s) :=\n  rfl\n\n"}
{"name":"MeasureTheory.Filtration.sInf_def","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\ns : Set (MeasureTheory.Filtration ι m)\ni : ι\n⊢ Eq (↑(InfSet.sInf s) i) (ite s.Nonempty (InfSet.sInf (Set.image (fun f => ↑f i) s)) m)","decl":"open scoped Classical in\ntheorem sInf_def (s : Set (Filtration ι m)) (i : ι) :\n    sInf s i = if Set.Nonempty s then sInf ((fun f : Filtration ι m => f i) '' s) else m :=\n  rfl\n\n"}
{"name":"MeasureTheory.measurableSet_of_filtration","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\nf : MeasureTheory.Filtration ι m\ns : Set Ω\ni : ι\nhs : MeasurableSet s\n⊢ MeasurableSet s","decl":"theorem measurableSet_of_filtration [Preorder ι] {f : Filtration ι m} {s : Set Ω} {i : ι}\n    (hs : MeasurableSet[f i] s) : MeasurableSet[m] s :=\n  f.le i s hs\n\n"}
{"name":"MeasureTheory.SigmaFiniteFiltration.SigmaFinite","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\nμ : MeasureTheory.Measure Ω\nf : MeasureTheory.Filtration ι m\nself : MeasureTheory.SigmaFiniteFiltration μ f\ni : ι\n⊢ MeasureTheory.SigmaFinite (μ.trim ⋯)","decl":"/-- A measure is σ-finite with respect to filtration if it is σ-finite with respect\nto all the sub-σ-algebra of the filtration. -/\nclass SigmaFiniteFiltration [Preorder ι] (μ : Measure Ω) (f : Filtration ι m) : Prop where\n  SigmaFinite : ∀ i : ι, SigmaFinite (μ.trim (f.le i))\n\n"}
{"name":"MeasureTheory.sigmaFinite_of_sigmaFiniteFiltration","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\nμ : MeasureTheory.Measure Ω\nf : MeasureTheory.Filtration ι m\nhf : MeasureTheory.SigmaFiniteFiltration μ f\ni : ι\n⊢ MeasureTheory.SigmaFinite (μ.trim ⋯)","decl":"instance sigmaFinite_of_sigmaFiniteFiltration [Preorder ι] (μ : Measure Ω) (f : Filtration ι m)\n    [hf : SigmaFiniteFiltration μ f] (i : ι) : SigmaFinite (μ.trim (f.le i)) :=\n  hf.SigmaFinite _\n\n"}
{"name":"MeasureTheory.IsFiniteMeasure.sigmaFiniteFiltration","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝¹ : Preorder ι\nμ : MeasureTheory.Measure Ω\nf : MeasureTheory.Filtration ι m\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ MeasureTheory.SigmaFiniteFiltration μ f","decl":"instance (priority := 100) IsFiniteMeasure.sigmaFiniteFiltration [Preorder ι] (μ : Measure Ω)\n    (f : Filtration ι m) [IsFiniteMeasure μ] : SigmaFiniteFiltration μ f :=\n  ⟨fun n => by infer_instance⟩\n\n"}
{"name":"MeasureTheory.Integrable.uniformIntegrable_condExp_filtration","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝¹ : Preorder ι\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : MeasureTheory.Filtration ι m\ng : Ω → Real\nhg : MeasureTheory.Integrable g μ\n⊢ MeasureTheory.UniformIntegrable (fun i => MeasureTheory.condExp (↑f i) μ g) 1 μ","decl":"/-- Given an integrable function `g`, the conditional expectations of `g` with respect to a\nfiltration is uniformly integrable. -/\ntheorem Integrable.uniformIntegrable_condExp_filtration [Preorder ι] {μ : Measure Ω}\n    [IsFiniteMeasure μ] {f : Filtration ι m} {g : Ω → ℝ} (hg : Integrable g μ) :\n    UniformIntegrable (fun i => μ[g|f i]) 1 μ :=\n  hg.uniformIntegrable_condExp f.le\n\n"}
{"name":"MeasureTheory.Integrable.uniformIntegrable_condexp_filtration","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝¹ : Preorder ι\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : MeasureTheory.Filtration ι m\ng : Ω → Real\nhg : MeasureTheory.Integrable g μ\n⊢ MeasureTheory.UniformIntegrable (fun i => MeasureTheory.condExp (↑f i) μ g) 1 μ","decl":"@[deprecated (since := \"2025-01-21\")]\nalias Integrable.uniformIntegrable_condexp_filtration :=\n  Integrable.uniformIntegrable_condExp_filtration\n\n"}
{"name":"MeasureTheory.measurableSet_filtrationOfSet","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\ns : ι → Set Ω\nhsm : ∀ (i : ι), MeasurableSet (s i)\ni j : ι\nhj : LE.le j i\n⊢ MeasurableSet (s j)","decl":"theorem measurableSet_filtrationOfSet {s : ι → Set Ω} (hsm : ∀ i, MeasurableSet[m] (s i)) (i : ι)\n    {j : ι} (hj : j ≤ i) : MeasurableSet[filtrationOfSet hsm i] (s j) :=\n  MeasurableSpace.measurableSet_generateFrom ⟨j, hj, rfl⟩\n\n"}
{"name":"MeasureTheory.measurableSet_filtrationOfSet'","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\ns : ι → Set Ω\nhsm : ∀ (n : ι), MeasurableSet (s n)\ni : ι\n⊢ MeasurableSet (s i)","decl":"theorem measurableSet_filtrationOfSet' {s : ι → Set Ω} (hsm : ∀ n, MeasurableSet[m] (s n))\n    (i : ι) : MeasurableSet[filtrationOfSet hsm i] (s i) :=\n  measurableSet_filtrationOfSet hsm i le_rfl\n\n"}
{"name":"MeasureTheory.Filtration.filtrationOfSet_eq_natural","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁵ : TopologicalSpace β\ninst✝⁴ : TopologicalSpace.MetrizableSpace β\nmβ : MeasurableSpace β\ninst✝³ : BorelSpace β\ninst✝² : Preorder ι\ninst✝¹ : MulZeroOneClass β\ninst✝ : Nontrivial β\ns : ι → Set Ω\nhsm : ∀ (i : ι), MeasurableSet (s i)\n⊢ Eq (MeasureTheory.filtrationOfSet hsm) (MeasureTheory.Filtration.natural (fun i => (s i).indicator fun x => 1) ⋯)","decl":"theorem filtrationOfSet_eq_natural [MulZeroOneClass β] [Nontrivial β] {s : ι → Set Ω}\n    (hsm : ∀ i, MeasurableSet[m] (s i)) :\n    filtrationOfSet hsm = natural (fun i => (s i).indicator (fun _ => 1 : Ω → β)) fun i =>\n      stronglyMeasurable_one.indicator (hsm i) := by\n  simp only [filtrationOfSet, natural, measurableSpace_iSup_eq, exists_prop, mk.injEq]\n  ext1 i\n  refine le_antisymm (generateFrom_le ?_) (generateFrom_le ?_)\n  · rintro _ ⟨j, hij, rfl⟩\n    refine measurableSet_generateFrom ⟨j, measurableSet_generateFrom ⟨hij, ?_⟩⟩\n    rw [comap_eq_generateFrom]\n    refine measurableSet_generateFrom ⟨{1}, measurableSet_singleton 1, ?_⟩\n    ext x\n    simp [Set.indicator_const_preimage_eq_union]\n  · rintro t ⟨n, ht⟩\n    suffices MeasurableSpace.generateFrom {t | n ≤ i ∧\n      MeasurableSet[MeasurableSpace.comap ((s n).indicator (fun _ => 1 : Ω → β)) mβ] t} ≤\n        MeasurableSpace.generateFrom {t | ∃ (j : ι), j ≤ i ∧ s j = t} by\n      exact this _ ht\n    refine generateFrom_le ?_\n    rintro t ⟨hn, u, _, hu'⟩\n    obtain heq | heq | heq | heq := Set.indicator_const_preimage (s n) u (1 : β)\n    on_goal 4 => rw [Set.mem_singleton_iff] at heq\n    all_goals rw [heq] at hu'; rw [← hu']\n    exacts [MeasurableSet.univ, measurableSet_generateFrom ⟨n, hn, rfl⟩,\n      MeasurableSet.compl (measurableSet_generateFrom ⟨n, hn, rfl⟩), measurableSet_empty _]\n\n"}
{"name":"MeasureTheory.Filtration.stronglyMeasurable_limitProcess","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝² : Preorder ι\nE : Type u_4\ninst✝¹ : Zero E\ninst✝ : TopologicalSpace E\nℱ : MeasureTheory.Filtration ι m\nf : ι → Ω → E\nμ : MeasureTheory.Measure Ω\n⊢ MeasureTheory.StronglyMeasurable (MeasureTheory.Filtration.limitProcess f ℱ μ)","decl":"theorem stronglyMeasurable_limitProcess : StronglyMeasurable[⨆ n, ℱ n] (limitProcess f ℱ μ) := by\n  rw [limitProcess]\n  split_ifs with h\n  exacts [(Classical.choose_spec h).1, stronglyMeasurable_zero]\n\n"}
{"name":"MeasureTheory.Filtration.stronglyMeasurable_limit_process'","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝² : Preorder ι\nE : Type u_4\ninst✝¹ : Zero E\ninst✝ : TopologicalSpace E\nℱ : MeasureTheory.Filtration ι m\nf : ι → Ω → E\nμ : MeasureTheory.Measure Ω\n⊢ MeasureTheory.StronglyMeasurable (MeasureTheory.Filtration.limitProcess f ℱ μ)","decl":"theorem stronglyMeasurable_limit_process' : StronglyMeasurable[m] (limitProcess f ℱ μ) :=\n  stronglyMeasurable_limitProcess.mono (sSup_le fun _ ⟨_, hn⟩ => hn ▸ ℱ.le _)\n\n"}
{"name":"MeasureTheory.Filtration.memℒp_limitProcess_of_eLpNorm_bdd","module":"Mathlib.Probability.Process.Filtration","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nR : NNReal\np : ENNReal\nF : Type u_5\ninst✝ : NormedAddCommGroup F\nℱ : MeasureTheory.Filtration Nat m\nf : Nat → Ω → F\nhfm : ∀ (n : Nat), MeasureTheory.AEStronglyMeasurable (f n) μ\nhbdd : ∀ (n : Nat), LE.le (MeasureTheory.eLpNorm (f n) p μ) ↑R\n⊢ MeasureTheory.Memℒp (MeasureTheory.Filtration.limitProcess f ℱ μ) p μ","decl":"theorem memℒp_limitProcess_of_eLpNorm_bdd {R : ℝ≥0} {p : ℝ≥0∞} {F : Type*} [NormedAddCommGroup F]\n    {ℱ : Filtration ℕ m} {f : ℕ → Ω → F} (hfm : ∀ n, AEStronglyMeasurable (f n) μ)\n    (hbdd : ∀ n, eLpNorm (f n) p μ ≤ R) : Memℒp (limitProcess f ℱ μ) p μ := by\n  rw [limitProcess]\n  split_ifs with h\n  · refine ⟨StronglyMeasurable.aestronglyMeasurable\n      ((Classical.choose_spec h).1.mono (sSup_le fun m ⟨n, hn⟩ => hn ▸ ℱ.le _)),\n      lt_of_le_of_lt (Lp.eLpNorm_lim_le_liminf_eLpNorm hfm _ (Classical.choose_spec h).2)\n        (lt_of_le_of_lt ?_ (ENNReal.coe_lt_top : ↑R < ∞))⟩\n    simp_rw [liminf_eq, eventually_atTop]\n    exact sSup_le fun b ⟨a, ha⟩ => (ha a le_rfl).trans (hbdd _)\n  · exact Memℒp.zero\n\n"}
