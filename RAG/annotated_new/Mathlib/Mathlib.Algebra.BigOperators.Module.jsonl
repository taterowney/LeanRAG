{"name":"Finset.sum_Ico_by_parts","module":"Mathlib.Algebra.BigOperators.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Nat → R\ng : Nat → M\nm n : Nat\nhmn : LT.lt m n\n⊢ Eq ((Finset.Ico m n).sum fun i => HSMul.hSMul (f i) (g i)) (HSub.hSub (HSub.hSub (HSMul.hSMul (f (HSub.hSub n 1)) ((Finset.range n).sum fun i => g i)) (HSMul.hSMul (f m) ((Finset.range m).sum fun i => g i))) ((Finset.Ico m (HSub.hSub n 1)).sum fun i => HSMul.hSMul (HSub.hSub (f (HAdd.hAdd i 1)) (f i)) ((Finset.range (HAdd.hAdd i 1)).sum fun i => g i)))","decl":"/-- **Summation by parts**, also known as **Abel's lemma** or an **Abel transformation** -/\ntheorem sum_Ico_by_parts (hmn : m < n) :\n    ∑ i ∈ Ico m n, f i • g i =\n      f (n - 1) • G n - f m • G m - ∑ i ∈ Ico m (n - 1), (f (i + 1) - f i) • G (i + 1) := by\n  have h₁ : (∑ i ∈ Ico (m + 1) n, f i • G i) = ∑ i ∈ Ico m (n - 1), f (i + 1) • G (i + 1) := by\n    rw [← Nat.sub_add_cancel (Nat.one_le_of_lt hmn), ← sum_Ico_add']\n    simp only [tsub_le_iff_right, add_le_iff_nonpos_left, nonpos_iff_eq_zero,\n      tsub_eq_zero_iff_le, add_tsub_cancel_right]\n  have h₂ :\n    (∑ i ∈ Ico (m + 1) n, f i • G (i + 1)) =\n      (∑ i ∈ Ico m (n - 1), f i • G (i + 1)) + f (n - 1) • G n - f m • G (m + 1) := by\n    rw [← sum_Ico_sub_bot _ hmn, ← sum_Ico_succ_sub_top _ (Nat.le_sub_one_of_lt hmn),\n      Nat.sub_add_cancel (pos_of_gt hmn), sub_add_cancel]\n  rw [sum_eq_sum_Ico_succ_bot hmn]\n  conv in (occs := 3) (f _ • g _) => rw [← sum_range_succ_sub_sum g]\n  simp_rw [smul_sub, sum_sub_distrib, h₂, h₁]\n  conv_lhs => congr; rfl; rw [← add_sub, add_comm, ← add_sub, ← sum_sub_distrib]\n  have : ∀ i, f i • G (i + 1) - f (i + 1) • G (i + 1) = -((f (i + 1) - f i) • G (i + 1)) := by\n    intro i\n    rw [sub_smul]\n    abel\n  simp_rw [this, sum_neg_distrib, sum_range_succ, smul_add]\n  abel\n\n"}
{"name":"Finset.sum_Ioc_by_parts","module":"Mathlib.Algebra.BigOperators.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Nat → R\ng : Nat → M\nm n : Nat\nhmn : LT.lt m n\n⊢ Eq ((Finset.Ioc m n).sum fun i => HSMul.hSMul (f i) (g i)) (HSub.hSub (HSub.hSub (HSMul.hSMul (f n) ((Finset.range (HAdd.hAdd n 1)).sum fun i => g i)) (HSMul.hSMul (f (HAdd.hAdd m 1)) ((Finset.range (HAdd.hAdd m 1)).sum fun i => g i))) ((Finset.Ioc m (HSub.hSub n 1)).sum fun i => HSMul.hSMul (HSub.hSub (f (HAdd.hAdd i 1)) (f i)) ((Finset.range (HAdd.hAdd i 1)).sum fun i => g i)))","decl":"theorem sum_Ioc_by_parts (hmn : m < n) :\n    ∑ i ∈ Ioc m n, f i • g i =\n      f n • G (n + 1) - f (m + 1) • G (m + 1)\n        - ∑ i ∈ Ioc m (n - 1), (f (i + 1) - f i) • G (i + 1) := by\n  simpa only [← Nat.Ico_succ_succ, Nat.succ_eq_add_one, Nat.sub_add_cancel (Nat.one_le_of_lt hmn),\n    add_tsub_cancel_right] using sum_Ico_by_parts f g (Nat.succ_lt_succ hmn)\n\n"}
{"name":"Finset.sum_range_by_parts","module":"Mathlib.Algebra.BigOperators.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Nat → R\ng : Nat → M\nn : Nat\n⊢ Eq ((Finset.range n).sum fun i => HSMul.hSMul (f i) (g i)) (HSub.hSub (HSMul.hSMul (f (HSub.hSub n 1)) ((Finset.range n).sum fun i => g i)) ((Finset.range (HSub.hSub n 1)).sum fun i => HSMul.hSMul (HSub.hSub (f (HAdd.hAdd i 1)) (f i)) ((Finset.range (HAdd.hAdd i 1)).sum fun i => g i)))","decl":"/-- **Summation by parts** for ranges -/\ntheorem sum_range_by_parts :\n    ∑ i ∈ range n, f i • g i =\n      f (n - 1) • G n - ∑ i ∈ range (n - 1), (f (i + 1) - f i) • G (i + 1) := by\n  by_cases hn : n = 0\n  · simp [hn]\n  · rw [range_eq_Ico, sum_Ico_by_parts f g (Nat.pos_of_ne_zero hn), sum_range_zero, smul_zero,\n      sub_zero, range_eq_Ico]\n\n"}
