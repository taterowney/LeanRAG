{"name":"CategoryTheory.hasExt_iff","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : HasDerivedCategory C\n⊢ Iff (CategoryTheory.HasExt C) (∀ (X Y : C) (n : Int), Small.{w, w'} (Quiver.Hom ((DerivedCategory.singleFunctor C 0).obj X) ((CategoryTheory.shiftFunctor (DerivedCategory C) n).obj ((DerivedCategory.singleFunctor C 0).obj Y))))","decl":"lemma hasExt_iff [HasDerivedCategory.{w'} C] :\n    HasExt.{w} C ↔ ∀ (X Y : C) (n : ℤ), Small.{w}\n      ((singleFunctor C 0).obj X ⟶\n        (((singleFunctor C 0).obj Y)⟦n⟧)) := by\n  dsimp [HasExt]\n  simp only [hasSmallLocalizedShiftedHom_iff _ _ Q]\n  constructor\n  · intro h X Y n\n    exact (small_congr ((shiftFunctorZero _ ℤ).app\n      ((singleFunctor C 0).obj X)).homFromEquiv).1 (h X Y 0 n)\n  · intro h X Y a b\n    refine (small_congr ?_).1 (h X Y (b - a))\n    exact (Functor.FullyFaithful.ofFullyFaithful\n      (shiftFunctor _ a)).homEquiv.trans\n      ((shiftFunctorAdd' _ _ _ _ (Int.sub_add_cancel b a)).symm.app _).homToEquiv\n\n"}
{"name":"CategoryTheory.hasExt_of_hasDerivedCategory","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : HasDerivedCategory C\n⊢ CategoryTheory.HasExt C","decl":"lemma hasExt_of_hasDerivedCategory [HasDerivedCategory.{w} C] : HasExt.{w} C := by\n  rw [hasExt_iff.{w}]\n  infer_instance\n\n"}
{"name":"CategoryTheory.HasExt.standard","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\n⊢ CategoryTheory.HasExt C","decl":"lemma HasExt.standard : HasExt.{max u v} C := by\n  letI := HasDerivedCategory.standard\n  exact hasExt_of_hasDerivedCategory _\n\n"}
{"name":"CategoryTheory.Abelian.Ext.comp_assoc","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasExt C\nX Y Z T : C\na₁ a₂ a₃ a₁₂ a₂₃ a : Nat\nα : CategoryTheory.Abelian.Ext X Y a₁\nβ : CategoryTheory.Abelian.Ext Y Z a₂\nγ : CategoryTheory.Abelian.Ext Z T a₃\nh₁₂ : Eq (HAdd.hAdd a₁ a₂) a₁₂\nh₂₃ : Eq (HAdd.hAdd a₂ a₃) a₂₃\nh : Eq (HAdd.hAdd (HAdd.hAdd a₁ a₂) a₃) a\n⊢ Eq ((α.comp β h₁₂).comp γ ⋯) (α.comp (β.comp γ h₂₃) ⋯)","decl":"lemma comp_assoc {a₁ a₂ a₃ a₁₂ a₂₃ a : ℕ} (α : Ext X Y a₁) (β : Ext Y Z a₂) (γ : Ext Z T a₃)\n    (h₁₂ : a₁ + a₂ = a₁₂) (h₂₃ : a₂ + a₃ = a₂₃) (h : a₁ + a₂ + a₃ = a) :\n    (α.comp β h₁₂).comp γ (show a₁₂ + a₃ = a by omega) =\n      α.comp (β.comp γ h₂₃) (by omega) :=\n  SmallShiftedHom.comp_assoc _ _ _ _ _ _ (by omega)\n\n"}
{"name":"CategoryTheory.Abelian.Ext.comp_assoc_of_second_deg_zero","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasExt C\nX Y Z T : C\na₁ a₃ a₁₃ : Nat\nα : CategoryTheory.Abelian.Ext X Y a₁\nβ : CategoryTheory.Abelian.Ext Y Z 0\nγ : CategoryTheory.Abelian.Ext Z T a₃\nh₁₃ : Eq (HAdd.hAdd a₁ a₃) a₁₃\n⊢ Eq ((α.comp β ⋯).comp γ h₁₃) (α.comp (β.comp γ ⋯) h₁₃)","decl":"@[simp]\nlemma comp_assoc_of_second_deg_zero\n    {a₁ a₃ a₁₃ : ℕ} (α : Ext X Y a₁) (β : Ext Y Z 0) (γ : Ext Z T a₃)\n    (h₁₃ : a₁ + a₃ = a₁₃) :\n    (α.comp β (add_zero _)).comp γ h₁₃ = α.comp (β.comp γ (zero_add _)) h₁₃ := by\n  apply comp_assoc\n  omega\n\n"}
{"name":"CategoryTheory.Abelian.Ext.comp_assoc_of_third_deg_zero","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasExt C\nX Y Z T : C\na₁ a₂ a₁₂ : Nat\nα : CategoryTheory.Abelian.Ext X Y a₁\nβ : CategoryTheory.Abelian.Ext Y Z a₂\nγ : CategoryTheory.Abelian.Ext Z T 0\nh₁₂ : Eq (HAdd.hAdd a₁ a₂) a₁₂\n⊢ Eq ((α.comp β h₁₂).comp γ ⋯) (α.comp (β.comp γ ⋯) h₁₂)","decl":"@[simp]\nlemma comp_assoc_of_third_deg_zero\n    {a₁ a₂ a₁₂ : ℕ} (α : Ext X Y a₁) (β : Ext Y Z a₂) (γ : Ext Z T 0)\n    (h₁₂ : a₁ + a₂ = a₁₂) :\n    (α.comp β h₁₂).comp γ (add_zero _) = α.comp (β.comp γ (add_zero _)) h₁₂ := by\n  apply comp_assoc\n  omega\n\n"}
{"name":"CategoryTheory.Abelian.Ext.comp_hom","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.HasExt C\nX Y Z : C\ninst✝ : HasDerivedCategory C\na b : Nat\nα : CategoryTheory.Abelian.Ext X Y a\nβ : CategoryTheory.Abelian.Ext Y Z b\nc : Nat\nh : Eq (HAdd.hAdd a b) c\n⊢ Eq (α.comp β h).hom (α.hom.comp β.hom ⋯)","decl":"@[simp]\nlemma comp_hom {a b : ℕ} (α : Ext X Y a) (β : Ext Y Z b) {c : ℕ} (h : a + b = c) :\n    (α.comp β h).hom = α.hom.comp β.hom (by omega) := by\n  apply SmallShiftedHom.equiv_comp\n\n"}
{"name":"CategoryTheory.Abelian.Ext.ext","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.HasExt C\nX Y : C\ninst✝ : HasDerivedCategory C\nn : Nat\nα β : CategoryTheory.Abelian.Ext X Y n\nh : Eq α.hom β.hom\n⊢ Eq α β","decl":"@[ext]\nlemma ext {n : ℕ} {α β : Ext X Y n} (h : α.hom = β.hom) : α = β :=\n  homEquiv.injective h\n\n"}
{"name":"CategoryTheory.Abelian.Ext.ext_iff","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.HasExt C\nX Y : C\ninst✝ : HasDerivedCategory C\nn : Nat\nα β : CategoryTheory.Abelian.Ext X Y n\n⊢ Iff (Eq α β) (Eq α.hom β.hom)","decl":"@[ext]\nlemma ext {n : ℕ} {α β : Ext X Y n} (h : α.hom = β.hom) : α = β :=\n  homEquiv.injective h\n\n"}
{"name":"CategoryTheory.Abelian.Ext.mk₀_hom","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.HasExt C\nX Y : C\ninst✝ : HasDerivedCategory C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Abelian.Ext.mk₀ f).hom (CategoryTheory.ShiftedHom.mk₀ ↑0 ⋯ ((DerivedCategory.singleFunctor C 0).map f))","decl":"@[simp]\nlemma mk₀_hom [HasDerivedCategory.{w'} C] (f : X ⟶ Y) :\n    (mk₀ f).hom = ShiftedHom.mk₀ _ (by simp) ((singleFunctor C 0).map f) := by\n  apply SmallShiftedHom.equiv_mk₀\n\n"}
{"name":"CategoryTheory.Abelian.Ext.mk₀_comp_mk₀","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasExt C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq ((CategoryTheory.Abelian.Ext.mk₀ f).comp (CategoryTheory.Abelian.Ext.mk₀ g) ⋯) (CategoryTheory.Abelian.Ext.mk₀ (CategoryTheory.CategoryStruct.comp f g))","decl":"@[simp]\nlemma mk₀_comp_mk₀ (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (mk₀ f).comp (mk₀ g) (zero_add 0) = mk₀ (f ≫ g) := by\n  letI := HasDerivedCategory.standard C; ext; simp\n\n"}
{"name":"CategoryTheory.Abelian.Ext.mk₀_comp_mk₀_assoc","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasExt C\nX Y Z T : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nn : Nat\nα : CategoryTheory.Abelian.Ext Z T n\n⊢ Eq ((CategoryTheory.Abelian.Ext.mk₀ f).comp ((CategoryTheory.Abelian.Ext.mk₀ g).comp α ⋯) ⋯) ((CategoryTheory.Abelian.Ext.mk₀ (CategoryTheory.CategoryStruct.comp f g)).comp α ⋯)","decl":"@[simp]\nlemma mk₀_comp_mk₀_assoc (f : X ⟶ Y) (g : Y ⟶ Z) {n : ℕ} (α : Ext Z T n) :\n    (mk₀ f).comp ((mk₀ g).comp α (zero_add n)) (zero_add n) =\n      (mk₀ (f ≫ g)).comp α (zero_add n) := by\n  rw [← mk₀_comp_mk₀, comp_assoc]\n  omega\n\n"}
{"name":"CategoryTheory.Abelian.Ext.add_comp","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasExt C\nX Y Z : C\nn : Nat\nα₁ α₂ : CategoryTheory.Abelian.Ext X Y n\nm : Nat\nβ : CategoryTheory.Abelian.Ext Y Z m\np : Nat\nh : Eq (HAdd.hAdd n m) p\n⊢ Eq ((HAdd.hAdd α₁ α₂).comp β h) (HAdd.hAdd (α₁.comp β h) (α₂.comp β h))","decl":"@[simp]\nlemma add_comp (α₁ α₂ : Ext X Y n) {m : ℕ} (β : Ext Y Z m) {p : ℕ} (h : n + m = p) :\n    (α₁ + α₂).comp β h = α₁.comp β h + α₂.comp β h := by\n  letI := HasDerivedCategory.standard C; ext; simp [this, add_hom']\n\n"}
{"name":"CategoryTheory.Abelian.Ext.comp_add","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasExt C\nX Y Z : C\nn : Nat\nα : CategoryTheory.Abelian.Ext X Y n\nm : Nat\nβ₁ β₂ : CategoryTheory.Abelian.Ext Y Z m\np : Nat\nh : Eq (HAdd.hAdd n m) p\n⊢ Eq (α.comp (HAdd.hAdd β₁ β₂) h) (HAdd.hAdd (α.comp β₁ h) (α.comp β₂ h))","decl":"@[simp]\nlemma comp_add (α : Ext X Y n) {m : ℕ} (β₁ β₂ : Ext Y Z m) {p : ℕ} (h : n + m = p) :\n    α.comp (β₁ + β₂) h = α.comp β₁ h + α.comp β₂ h := by\n  letI := HasDerivedCategory.standard C; ext; simp [this, add_hom']\n\n"}
{"name":"CategoryTheory.Abelian.Ext.neg_comp","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasExt C\nX Y Z : C\nn : Nat\nα : CategoryTheory.Abelian.Ext X Y n\nm : Nat\nβ : CategoryTheory.Abelian.Ext Y Z m\np : Nat\nh : Eq (HAdd.hAdd n m) p\n⊢ Eq ((Neg.neg α).comp β h) (Neg.neg (α.comp β h))","decl":"@[simp]\nlemma neg_comp (α : Ext X Y n) {m : ℕ} (β : Ext Y Z m) {p : ℕ} (h : n + m = p) :\n    (-α).comp β h = -α.comp β h := by\n  letI := HasDerivedCategory.standard C; ext; simp [this, neg_hom']\n\n"}
{"name":"CategoryTheory.Abelian.Ext.comp_neg","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasExt C\nX Y Z : C\nn : Nat\nα : CategoryTheory.Abelian.Ext X Y n\nm : Nat\nβ : CategoryTheory.Abelian.Ext Y Z m\np : Nat\nh : Eq (HAdd.hAdd n m) p\n⊢ Eq (α.comp (Neg.neg β) h) (Neg.neg (α.comp β h))","decl":"@[simp]\nlemma comp_neg (α : Ext X Y n) {m : ℕ} (β : Ext Y Z m) {p : ℕ} (h : n + m = p) :\n    α.comp (-β) h = -α.comp β h := by\n  letI := HasDerivedCategory.standard C; ext; simp [this, neg_hom']\n\n"}
{"name":"CategoryTheory.Abelian.Ext.zero_comp","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasExt C\nX Y Z : C\nn m : Nat\nβ : CategoryTheory.Abelian.Ext Y Z m\np : Nat\nh : Eq (HAdd.hAdd n m) p\n⊢ Eq (CategoryTheory.Abelian.Ext.comp 0 β h) 0","decl":"variable (X n) in\n@[simp]\nlemma zero_comp {m : ℕ} (β : Ext Y Z m) (p : ℕ) (h : n + m = p) :\n    (0 : Ext X Y n).comp β h = 0 := by\n  letI := HasDerivedCategory.standard C; ext; simp [this, zero_hom']\n\n"}
{"name":"CategoryTheory.Abelian.Ext.comp_zero","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasExt C\nX Y : C\nn : Nat\nα : CategoryTheory.Abelian.Ext X Y n\nZ : C\nm p : Nat\nh : Eq (HAdd.hAdd n m) p\n⊢ Eq (α.comp 0 h) 0","decl":"@[simp]\nlemma comp_zero (α : Ext X Y n) (Z : C) (m : ℕ) (p : ℕ) (h : n + m = p) :\n    α.comp (0 : Ext Y Z m) h = 0 := by\n  letI := HasDerivedCategory.standard C; ext; simp [this, zero_hom']\n\n"}
{"name":"CategoryTheory.Abelian.Ext.mk₀_id_comp","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasExt C\nX Y : C\nn : Nat\nα : CategoryTheory.Abelian.Ext X Y n\n⊢ Eq ((CategoryTheory.Abelian.Ext.mk₀ (CategoryTheory.CategoryStruct.id X)).comp α ⋯) α","decl":"@[simp]\nlemma mk₀_id_comp (α : Ext X Y n) :\n    (mk₀ (𝟙 X)).comp α (zero_add n) = α := by\n  letI := HasDerivedCategory.standard C; ext; simp\n\n"}
{"name":"CategoryTheory.Abelian.Ext.comp_mk₀_id","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasExt C\nX Y : C\nn : Nat\nα : CategoryTheory.Abelian.Ext X Y n\n⊢ Eq (α.comp (CategoryTheory.Abelian.Ext.mk₀ (CategoryTheory.CategoryStruct.id Y)) ⋯) α","decl":"@[simp]\nlemma comp_mk₀_id (α : Ext X Y n) :\n    α.comp (mk₀ (𝟙 Y)) (add_zero n) = α := by\n  letI := HasDerivedCategory.standard C; ext; simp\n\n"}
{"name":"CategoryTheory.Abelian.Ext.mk₀_zero","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasExt C\nX Y : C\n⊢ Eq (CategoryTheory.Abelian.Ext.mk₀ 0) 0","decl":"variable (X Y) in\n@[simp]\nlemma mk₀_zero : mk₀ (0 : X ⟶ Y) = 0 := by\n  letI := HasDerivedCategory.standard C; ext; simp [this, zero_hom']\n\n"}
{"name":"CategoryTheory.Abelian.Ext.biprod_ext","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasExt C\nY : C\nn : Nat\nX₁ X₂ : C\nα β : CategoryTheory.Abelian.Ext (CategoryTheory.Limits.biprod X₁ X₂) Y n\nh₁ : Eq ((CategoryTheory.Abelian.Ext.mk₀ CategoryTheory.Limits.biprod.inl).comp α ⋯) ((CategoryTheory.Abelian.Ext.mk₀ CategoryTheory.Limits.biprod.inl).comp β ⋯)\nh₂ : Eq ((CategoryTheory.Abelian.Ext.mk₀ CategoryTheory.Limits.biprod.inr).comp α ⋯) ((CategoryTheory.Abelian.Ext.mk₀ CategoryTheory.Limits.biprod.inr).comp β ⋯)\n⊢ Eq α β","decl":"attribute [local instance] preservesBinaryBiproducts_of_preservesBiproducts in\nlemma biprod_ext {X₁ X₂ : C} {α β : Ext (X₁ ⊞ X₂) Y n}\n    (h₁ : (mk₀ biprod.inl).comp α (zero_add n) = (mk₀ biprod.inl).comp β (zero_add n))\n    (h₂ : (mk₀ biprod.inr).comp α (zero_add n) = (mk₀ biprod.inr).comp β (zero_add n)) :\n    α = β := by\n  letI := HasDerivedCategory.standard C\n  rw [Ext.ext_iff] at h₁ h₂ ⊢\n  simp only [comp_hom, mk₀_hom, ShiftedHom.mk₀_comp] at h₁ h₂\n  apply BinaryCofan.IsColimit.hom_ext\n    (isBinaryBilimitOfPreserves (singleFunctor C 0)\n      (BinaryBiproduct.isBilimit X₁ X₂)).isColimit\n  all_goals assumption\n\n"}
{"name":"CategoryTheory.Abelian.Ext.zero_hom","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.HasExt C\nX Y : C\nn : Nat\ninst✝ : HasDerivedCategory C\n⊢ Eq (CategoryTheory.Abelian.Ext.hom 0) 0","decl":"variable (X Y n) in\n@[simp]\nlemma zero_hom : (0 : Ext X Y n).hom = 0 := by\n  let β : Ext 0 Y n := 0\n  have hβ : β.hom = 0 := by apply (Functor.map_isZero _ (isZero_zero C)).eq_of_src\n  have : (0 : Ext X Y n) = (0 : Ext X 0 0).comp β (zero_add n) := by simp [β]\n  rw [this, comp_hom, hβ, ShiftedHom.comp_zero]\n\n"}
{"name":"CategoryTheory.Abelian.Ext.add_hom","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.HasExt C\nX Y : C\nn : Nat\ninst✝ : HasDerivedCategory C\nα β : CategoryTheory.Abelian.Ext X Y n\n⊢ Eq (HAdd.hAdd α β).hom (HAdd.hAdd α.hom β.hom)","decl":"@[simp]\nlemma add_hom (α β : Ext X Y n) : (α + β).hom = α.hom + β.hom := by\n  let α' : Ext (X ⊞ X) Y n := (mk₀ biprod.fst).comp α (zero_add n)\n  let β' : Ext (X ⊞ X) Y n := (mk₀ biprod.snd).comp β (zero_add n)\n  have eq₁ : α + β = (mk₀ (biprod.lift (𝟙 X) (𝟙 X))).comp (α' + β') (zero_add n) := by\n    simp [α', β']\n  have eq₂ : α' + β' = homEquiv.symm (α'.hom + β'.hom) := by\n    apply biprod_ext\n    all_goals ext; simp [α', β', ← Functor.map_comp]\n  simp only [eq₁, eq₂, comp_hom, Equiv.apply_symm_apply, ShiftedHom.comp_add]\n  congr\n  · dsimp [α']\n    rw [comp_hom, mk₀_hom, mk₀_hom]\n    dsimp\n    rw [ShiftedHom.mk₀_comp_mk₀_assoc, ← Functor.map_comp,\n      biprod.lift_fst, Functor.map_id, ShiftedHom.mk₀_id_comp]\n  · dsimp [β']\n    rw [comp_hom, mk₀_hom, mk₀_hom]\n    dsimp\n    rw [ShiftedHom.mk₀_comp_mk₀_assoc, ← Functor.map_comp,\n      biprod.lift_snd, Functor.map_id, ShiftedHom.mk₀_id_comp]\n\n"}
{"name":"CategoryTheory.Abelian.Ext.neg_hom","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.HasExt C\nX Y : C\nn : Nat\ninst✝ : HasDerivedCategory C\nα : CategoryTheory.Abelian.Ext X Y n\n⊢ Eq (Neg.neg α).hom (Neg.neg α.hom)","decl":"lemma neg_hom (α : Ext X Y n) : (-α).hom = -α.hom := by\n  rw [← add_right_inj α.hom, ← add_hom, add_neg_cancel, add_neg_cancel, zero_hom]\n\n"}
{"name":"CategoryTheory.Abelian.Ext.homAddEquiv_apply","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.HasExt C\nX Y : C\nn : Nat\ninst✝ : HasDerivedCategory C\nα : CategoryTheory.Abelian.Ext X Y n\n⊢ Eq (CategoryTheory.Abelian.Ext.homAddEquiv α) α.hom","decl":"@[simp]\nlemma homAddEquiv_apply (α : Ext X Y n) : homAddEquiv α = α.hom := rfl\n\n"}
{"name":"CategoryTheory.Abelian.Ext.bilinearComp_apply_apply","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasExt C\nX Y Z : C\na b c : Nat\nh : Eq (HAdd.hAdd a b) c\nα : CategoryTheory.Abelian.Ext X Y a\nβ : CategoryTheory.Abelian.Ext Y Z b\n⊢ Eq (((CategoryTheory.Abelian.Ext.bilinearComp X Y Z a b c h) α) β) (α.comp β h)","decl":"variable (X Y Z) in\n/-- The composition of `Ext`, as a bilinear map. -/\n@[simps!]\nnoncomputable def bilinearComp (a b c : ℕ) (h : a + b = c) :\n    Ext X Y a →+ Ext Y Z b →+ Ext X Z c :=\n  AddMonoidHom.mk' (fun α ↦ AddMonoidHom.mk' (fun β ↦ α.comp β h) (by simp)) (by aesop)\n\n"}
{"name":"CategoryTheory.Abelian.extFunctorObj_obj_coe","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasExt C\nX : C\nn : Nat\nY : C\n⊢ Eq (↑((CategoryTheory.Abelian.extFunctorObj X n).obj Y)) (CategoryTheory.Abelian.Ext X Y n)","decl":"/-- Auxiliary definition for `extFunctor`. -/\n@[simps]\nnoncomputable def extFunctorObj (X : C) (n : ℕ) : C ⥤ AddCommGrp.{w} where\n  obj Y := AddCommGrp.of (Ext X Y n)\n  map f := AddCommGrp.ofHom ((Ext.mk₀ f).postcomp _ (add_zero n))\n  map_comp f f' := by\n    ext α\n    dsimp [AddCommGrp.ofHom]\n    rw [← Ext.mk₀_comp_mk₀]\n    symm\n    apply Ext.comp_assoc\n    omega\n\n"}
{"name":"CategoryTheory.Abelian.extFunctorObj_map","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasExt C\nX : C\nn : Nat\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Abelian.extFunctorObj X n).map f) (AddCommGrp.ofHom ((CategoryTheory.Abelian.Ext.mk₀ f).postcomp X ⋯))","decl":"/-- Auxiliary definition for `extFunctor`. -/\n@[simps]\nnoncomputable def extFunctorObj (X : C) (n : ℕ) : C ⥤ AddCommGrp.{w} where\n  obj Y := AddCommGrp.of (Ext X Y n)\n  map f := AddCommGrp.ofHom ((Ext.mk₀ f).postcomp _ (add_zero n))\n  map_comp f f' := by\n    ext α\n    dsimp [AddCommGrp.ofHom]\n    rw [← Ext.mk₀_comp_mk₀]\n    symm\n    apply Ext.comp_assoc\n    omega\n\n"}
{"name":"CategoryTheory.Abelian.extFunctor_obj","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasExt C\nn : Nat\nX : Opposite C\n⊢ Eq ((CategoryTheory.Abelian.extFunctor n).obj X) (CategoryTheory.Abelian.extFunctorObj (Opposite.unop X) n)","decl":"/-- The functor `Cᵒᵖ ⥤ C ⥤ AddCommGrp` which sends `X : C` and `Y : C`\nto `Ext X Y n`. -/\n@[simps]\nnoncomputable def extFunctor (n : ℕ) : Cᵒᵖ ⥤ C ⥤ AddCommGrp.{w} where\n  obj X := extFunctorObj X.unop n\n  map {X₁ X₂} f :=\n    { app := fun Y ↦ AddCommGrp.ofHom (AddMonoidHom.mk'\n        (fun α ↦ (Ext.mk₀ f.unop).comp α (zero_add _)) (by simp))\n      naturality := fun {Y₁ Y₂} g ↦ by\n        ext α\n        dsimp\n        symm\n        apply Ext.comp_assoc\n        all_goals omega }\n  map_comp {X₁ X₂ X₃} f f' := by\n    ext Y α\n    dsimp\n    rw [← Ext.mk₀_comp_mk₀]\n    apply Ext.comp_assoc\n    all_goals omega\n\n"}
{"name":"CategoryTheory.Abelian.extFunctor_map_app","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasExt C\nn : Nat\nX₁ X₂ : Opposite C\nf : Quiver.Hom X₁ X₂\nY : C\n⊢ Eq (((CategoryTheory.Abelian.extFunctor n).map f).app Y) (AddCommGrp.ofHom (AddMonoidHom.mk' (fun α => (CategoryTheory.Abelian.Ext.mk₀ f.unop).comp α ⋯) ⋯))","decl":"/-- The functor `Cᵒᵖ ⥤ C ⥤ AddCommGrp` which sends `X : C` and `Y : C`\nto `Ext X Y n`. -/\n@[simps]\nnoncomputable def extFunctor (n : ℕ) : Cᵒᵖ ⥤ C ⥤ AddCommGrp.{w} where\n  obj X := extFunctorObj X.unop n\n  map {X₁ X₂} f :=\n    { app := fun Y ↦ AddCommGrp.ofHom (AddMonoidHom.mk'\n        (fun α ↦ (Ext.mk₀ f.unop).comp α (zero_add _)) (by simp))\n      naturality := fun {Y₁ Y₂} g ↦ by\n        ext α\n        dsimp\n        symm\n        apply Ext.comp_assoc\n        all_goals omega }\n  map_comp {X₁ X₂ X₃} f f' := by\n    ext Y α\n    dsimp\n    rw [← Ext.mk₀_comp_mk₀]\n    apply Ext.comp_assoc\n    all_goals omega\n\n"}
{"name":"CategoryTheory.Abelian.Ext.homEquiv_chgUniv","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasExt C\ninst✝¹ : CategoryTheory.HasExt C\nX Y : C\nn : Nat\ninst✝ : HasDerivedCategory C\ne : CategoryTheory.Abelian.Ext X Y n\n⊢ Eq (CategoryTheory.Abelian.Ext.homEquiv (CategoryTheory.Abelian.Ext.chgUniv e)) (CategoryTheory.Abelian.Ext.homEquiv e)","decl":"lemma homEquiv_chgUniv [HasDerivedCategory.{w''} C] (e : Ext.{w} X Y n) :\n    homEquiv.{w'', w'} (chgUniv.{w'} e) = homEquiv.{w'', w} e := by\n  apply SmallShiftedHom.equiv_chgUniv\n\n"}
