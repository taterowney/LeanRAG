{"name":"CategoryTheory.hasExt_iff","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : HasDerivedCategory C\n‚ä¢ Iff (CategoryTheory.HasExt C) (‚àÄ (X Y : C) (n : Int), Small.{w, w'} (Quiver.Hom ((DerivedCategory.singleFunctor C 0).obj X) ((CategoryTheory.shiftFunctor (DerivedCategory C) n).obj ((DerivedCategory.singleFunctor C 0).obj Y))))","decl":"lemma hasExt_iff [HasDerivedCategory.{w'} C] :\n    HasExt.{w} C ‚Üî ‚àÄ (X Y : C) (n : ‚Ñ§), Small.{w}\n      ((singleFunctor C 0).obj X ‚ü∂\n        (((singleFunctor C 0).obj Y)‚ü¶n‚üß)) := by\n  dsimp [HasExt]\n  simp only [hasSmallLocalizedShiftedHom_iff _ _ Q]\n  constructor\n  ¬∑ intro h X Y n\n    exact (small_congr ((shiftFunctorZero _ ‚Ñ§).app\n      ((singleFunctor C 0).obj X)).homFromEquiv).1 (h X Y 0 n)\n  ¬∑ intro h X Y a b\n    refine (small_congr ?_).1 (h X Y (b - a))\n    exact (Functor.FullyFaithful.ofFullyFaithful\n      (shiftFunctor _ a)).homEquiv.trans\n      ((shiftFunctorAdd' _ _ _ _ (Int.sub_add_cancel b a)).symm.app _).homToEquiv\n\n"}
{"name":"CategoryTheory.hasExt_of_hasDerivedCategory","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : HasDerivedCategory C\n‚ä¢ CategoryTheory.HasExt C","decl":"lemma hasExt_of_hasDerivedCategory [HasDerivedCategory.{w} C] : HasExt.{w} C := by\n  rw [hasExt_iff.{w}]\n  infer_instance\n\n"}
{"name":"CategoryTheory.HasExt.standard","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\n‚ä¢ CategoryTheory.HasExt C","decl":"lemma HasExt.standard : HasExt.{max u v} C := by\n  letI := HasDerivedCategory.standard\n  exact hasExt_of_hasDerivedCategory _\n\n"}
{"name":"CategoryTheory.Abelian.Ext.comp_assoc","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasExt C\nX Y Z T : C\na‚ÇÅ a‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ a‚ÇÇ‚ÇÉ a : Nat\nŒ± : CategoryTheory.Abelian.Ext X Y a‚ÇÅ\nŒ≤ : CategoryTheory.Abelian.Ext Y Z a‚ÇÇ\nŒ≥ : CategoryTheory.Abelian.Ext Z T a‚ÇÉ\nh‚ÇÅ‚ÇÇ : Eq (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÅ‚ÇÇ\nh‚ÇÇ‚ÇÉ : Eq (HAdd.hAdd a‚ÇÇ a‚ÇÉ) a‚ÇÇ‚ÇÉ\nh : Eq (HAdd.hAdd (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÉ) a\n‚ä¢ Eq ((Œ±.comp Œ≤ h‚ÇÅ‚ÇÇ).comp Œ≥ ‚ãØ) (Œ±.comp (Œ≤.comp Œ≥ h‚ÇÇ‚ÇÉ) ‚ãØ)","decl":"lemma comp_assoc {a‚ÇÅ a‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ a‚ÇÇ‚ÇÉ a : ‚Ñï} (Œ± : Ext X Y a‚ÇÅ) (Œ≤ : Ext Y Z a‚ÇÇ) (Œ≥ : Ext Z T a‚ÇÉ)\n    (h‚ÇÅ‚ÇÇ : a‚ÇÅ + a‚ÇÇ = a‚ÇÅ‚ÇÇ) (h‚ÇÇ‚ÇÉ : a‚ÇÇ + a‚ÇÉ = a‚ÇÇ‚ÇÉ) (h : a‚ÇÅ + a‚ÇÇ + a‚ÇÉ = a) :\n    (Œ±.comp Œ≤ h‚ÇÅ‚ÇÇ).comp Œ≥ (show a‚ÇÅ‚ÇÇ + a‚ÇÉ = a by omega) =\n      Œ±.comp (Œ≤.comp Œ≥ h‚ÇÇ‚ÇÉ) (by omega) :=\n  SmallShiftedHom.comp_assoc _ _ _ _ _ _ (by omega)\n\n"}
{"name":"CategoryTheory.Abelian.Ext.comp_assoc_of_second_deg_zero","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasExt C\nX Y Z T : C\na‚ÇÅ a‚ÇÉ a‚ÇÅ‚ÇÉ : Nat\nŒ± : CategoryTheory.Abelian.Ext X Y a‚ÇÅ\nŒ≤ : CategoryTheory.Abelian.Ext Y Z 0\nŒ≥ : CategoryTheory.Abelian.Ext Z T a‚ÇÉ\nh‚ÇÅ‚ÇÉ : Eq (HAdd.hAdd a‚ÇÅ a‚ÇÉ) a‚ÇÅ‚ÇÉ\n‚ä¢ Eq ((Œ±.comp Œ≤ ‚ãØ).comp Œ≥ h‚ÇÅ‚ÇÉ) (Œ±.comp (Œ≤.comp Œ≥ ‚ãØ) h‚ÇÅ‚ÇÉ)","decl":"@[simp]\nlemma comp_assoc_of_second_deg_zero\n    {a‚ÇÅ a‚ÇÉ a‚ÇÅ‚ÇÉ : ‚Ñï} (Œ± : Ext X Y a‚ÇÅ) (Œ≤ : Ext Y Z 0) (Œ≥ : Ext Z T a‚ÇÉ)\n    (h‚ÇÅ‚ÇÉ : a‚ÇÅ + a‚ÇÉ = a‚ÇÅ‚ÇÉ) :\n    (Œ±.comp Œ≤ (add_zero _)).comp Œ≥ h‚ÇÅ‚ÇÉ = Œ±.comp (Œ≤.comp Œ≥ (zero_add _)) h‚ÇÅ‚ÇÉ := by\n  apply comp_assoc\n  omega\n\n"}
{"name":"CategoryTheory.Abelian.Ext.comp_assoc_of_third_deg_zero","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasExt C\nX Y Z T : C\na‚ÇÅ a‚ÇÇ a‚ÇÅ‚ÇÇ : Nat\nŒ± : CategoryTheory.Abelian.Ext X Y a‚ÇÅ\nŒ≤ : CategoryTheory.Abelian.Ext Y Z a‚ÇÇ\nŒ≥ : CategoryTheory.Abelian.Ext Z T 0\nh‚ÇÅ‚ÇÇ : Eq (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÅ‚ÇÇ\n‚ä¢ Eq ((Œ±.comp Œ≤ h‚ÇÅ‚ÇÇ).comp Œ≥ ‚ãØ) (Œ±.comp (Œ≤.comp Œ≥ ‚ãØ) h‚ÇÅ‚ÇÇ)","decl":"@[simp]\nlemma comp_assoc_of_third_deg_zero\n    {a‚ÇÅ a‚ÇÇ a‚ÇÅ‚ÇÇ : ‚Ñï} (Œ± : Ext X Y a‚ÇÅ) (Œ≤ : Ext Y Z a‚ÇÇ) (Œ≥ : Ext Z T 0)\n    (h‚ÇÅ‚ÇÇ : a‚ÇÅ + a‚ÇÇ = a‚ÇÅ‚ÇÇ) :\n    (Œ±.comp Œ≤ h‚ÇÅ‚ÇÇ).comp Œ≥ (add_zero _) = Œ±.comp (Œ≤.comp Œ≥ (add_zero _)) h‚ÇÅ‚ÇÇ := by\n  apply comp_assoc\n  omega\n\n"}
{"name":"CategoryTheory.Abelian.Ext.comp_hom","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Abelian C\ninst‚úù¬π : CategoryTheory.HasExt C\nX Y Z : C\ninst‚úù : HasDerivedCategory C\na b : Nat\nŒ± : CategoryTheory.Abelian.Ext X Y a\nŒ≤ : CategoryTheory.Abelian.Ext Y Z b\nc : Nat\nh : Eq (HAdd.hAdd a b) c\n‚ä¢ Eq (Œ±.comp Œ≤ h).hom (Œ±.hom.comp Œ≤.hom ‚ãØ)","decl":"@[simp]\nlemma comp_hom {a b : ‚Ñï} (Œ± : Ext X Y a) (Œ≤ : Ext Y Z b) {c : ‚Ñï} (h : a + b = c) :\n    (Œ±.comp Œ≤ h).hom = Œ±.hom.comp Œ≤.hom (by omega) := by\n  apply SmallShiftedHom.equiv_comp\n\n"}
{"name":"CategoryTheory.Abelian.Ext.ext","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Abelian C\ninst‚úù¬π : CategoryTheory.HasExt C\nX Y : C\ninst‚úù : HasDerivedCategory C\nn : Nat\nŒ± Œ≤ : CategoryTheory.Abelian.Ext X Y n\nh : Eq Œ±.hom Œ≤.hom\n‚ä¢ Eq Œ± Œ≤","decl":"@[ext]\nlemma ext {n : ‚Ñï} {Œ± Œ≤ : Ext X Y n} (h : Œ±.hom = Œ≤.hom) : Œ± = Œ≤ :=\n  homEquiv.injective h\n\n"}
{"name":"CategoryTheory.Abelian.Ext.ext_iff","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Abelian C\ninst‚úù¬π : CategoryTheory.HasExt C\nX Y : C\ninst‚úù : HasDerivedCategory C\nn : Nat\nŒ± Œ≤ : CategoryTheory.Abelian.Ext X Y n\n‚ä¢ Iff (Eq Œ± Œ≤) (Eq Œ±.hom Œ≤.hom)","decl":"@[ext]\nlemma ext {n : ‚Ñï} {Œ± Œ≤ : Ext X Y n} (h : Œ±.hom = Œ≤.hom) : Œ± = Œ≤ :=\n  homEquiv.injective h\n\n"}
{"name":"CategoryTheory.Abelian.Ext.mk‚ÇÄ_hom","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Abelian C\ninst‚úù¬π : CategoryTheory.HasExt C\nX Y : C\ninst‚úù : HasDerivedCategory C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.Abelian.Ext.mk‚ÇÄ f).hom (CategoryTheory.ShiftedHom.mk‚ÇÄ ‚Üë0 ‚ãØ ((DerivedCategory.singleFunctor C 0).map f))","decl":"@[simp]\nlemma mk‚ÇÄ_hom [HasDerivedCategory.{w'} C] (f : X ‚ü∂ Y) :\n    (mk‚ÇÄ f).hom = ShiftedHom.mk‚ÇÄ _ (by simp) ((singleFunctor C 0).map f) := by\n  apply SmallShiftedHom.equiv_mk‚ÇÄ\n\n"}
{"name":"CategoryTheory.Abelian.Ext.mk‚ÇÄ_comp_mk‚ÇÄ","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasExt C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq ((CategoryTheory.Abelian.Ext.mk‚ÇÄ f).comp (CategoryTheory.Abelian.Ext.mk‚ÇÄ g) ‚ãØ) (CategoryTheory.Abelian.Ext.mk‚ÇÄ (CategoryTheory.CategoryStruct.comp f g))","decl":"@[simp]\nlemma mk‚ÇÄ_comp_mk‚ÇÄ (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    (mk‚ÇÄ f).comp (mk‚ÇÄ g) (zero_add 0) = mk‚ÇÄ (f ‚â´ g) := by\n  letI := HasDerivedCategory.standard C; ext; simp\n\n"}
{"name":"CategoryTheory.Abelian.Ext.mk‚ÇÄ_comp_mk‚ÇÄ_assoc","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasExt C\nX Y Z T : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nn : Nat\nŒ± : CategoryTheory.Abelian.Ext Z T n\n‚ä¢ Eq ((CategoryTheory.Abelian.Ext.mk‚ÇÄ f).comp ((CategoryTheory.Abelian.Ext.mk‚ÇÄ g).comp Œ± ‚ãØ) ‚ãØ) ((CategoryTheory.Abelian.Ext.mk‚ÇÄ (CategoryTheory.CategoryStruct.comp f g)).comp Œ± ‚ãØ)","decl":"@[simp]\nlemma mk‚ÇÄ_comp_mk‚ÇÄ_assoc (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) {n : ‚Ñï} (Œ± : Ext Z T n) :\n    (mk‚ÇÄ f).comp ((mk‚ÇÄ g).comp Œ± (zero_add n)) (zero_add n) =\n      (mk‚ÇÄ (f ‚â´ g)).comp Œ± (zero_add n) := by\n  rw [‚Üê mk‚ÇÄ_comp_mk‚ÇÄ, comp_assoc]\n  omega\n\n"}
{"name":"CategoryTheory.Abelian.Ext.add_comp","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasExt C\nX Y Z : C\nn : Nat\nŒ±‚ÇÅ Œ±‚ÇÇ : CategoryTheory.Abelian.Ext X Y n\nm : Nat\nŒ≤ : CategoryTheory.Abelian.Ext Y Z m\np : Nat\nh : Eq (HAdd.hAdd n m) p\n‚ä¢ Eq ((HAdd.hAdd Œ±‚ÇÅ Œ±‚ÇÇ).comp Œ≤ h) (HAdd.hAdd (Œ±‚ÇÅ.comp Œ≤ h) (Œ±‚ÇÇ.comp Œ≤ h))","decl":"@[simp]\nlemma add_comp (Œ±‚ÇÅ Œ±‚ÇÇ : Ext X Y n) {m : ‚Ñï} (Œ≤ : Ext Y Z m) {p : ‚Ñï} (h : n + m = p) :\n    (Œ±‚ÇÅ + Œ±‚ÇÇ).comp Œ≤ h = Œ±‚ÇÅ.comp Œ≤ h + Œ±‚ÇÇ.comp Œ≤ h := by\n  letI := HasDerivedCategory.standard C; ext; simp [this, add_hom']\n\n"}
{"name":"CategoryTheory.Abelian.Ext.comp_add","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasExt C\nX Y Z : C\nn : Nat\nŒ± : CategoryTheory.Abelian.Ext X Y n\nm : Nat\nŒ≤‚ÇÅ Œ≤‚ÇÇ : CategoryTheory.Abelian.Ext Y Z m\np : Nat\nh : Eq (HAdd.hAdd n m) p\n‚ä¢ Eq (Œ±.comp (HAdd.hAdd Œ≤‚ÇÅ Œ≤‚ÇÇ) h) (HAdd.hAdd (Œ±.comp Œ≤‚ÇÅ h) (Œ±.comp Œ≤‚ÇÇ h))","decl":"@[simp]\nlemma comp_add (Œ± : Ext X Y n) {m : ‚Ñï} (Œ≤‚ÇÅ Œ≤‚ÇÇ : Ext Y Z m) {p : ‚Ñï} (h : n + m = p) :\n    Œ±.comp (Œ≤‚ÇÅ + Œ≤‚ÇÇ) h = Œ±.comp Œ≤‚ÇÅ h + Œ±.comp Œ≤‚ÇÇ h := by\n  letI := HasDerivedCategory.standard C; ext; simp [this, add_hom']\n\n"}
{"name":"CategoryTheory.Abelian.Ext.neg_comp","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasExt C\nX Y Z : C\nn : Nat\nŒ± : CategoryTheory.Abelian.Ext X Y n\nm : Nat\nŒ≤ : CategoryTheory.Abelian.Ext Y Z m\np : Nat\nh : Eq (HAdd.hAdd n m) p\n‚ä¢ Eq ((Neg.neg Œ±).comp Œ≤ h) (Neg.neg (Œ±.comp Œ≤ h))","decl":"@[simp]\nlemma neg_comp (Œ± : Ext X Y n) {m : ‚Ñï} (Œ≤ : Ext Y Z m) {p : ‚Ñï} (h : n + m = p) :\n    (-Œ±).comp Œ≤ h = -Œ±.comp Œ≤ h := by\n  letI := HasDerivedCategory.standard C; ext; simp [this, neg_hom']\n\n"}
{"name":"CategoryTheory.Abelian.Ext.comp_neg","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasExt C\nX Y Z : C\nn : Nat\nŒ± : CategoryTheory.Abelian.Ext X Y n\nm : Nat\nŒ≤ : CategoryTheory.Abelian.Ext Y Z m\np : Nat\nh : Eq (HAdd.hAdd n m) p\n‚ä¢ Eq (Œ±.comp (Neg.neg Œ≤) h) (Neg.neg (Œ±.comp Œ≤ h))","decl":"@[simp]\nlemma comp_neg (Œ± : Ext X Y n) {m : ‚Ñï} (Œ≤ : Ext Y Z m) {p : ‚Ñï} (h : n + m = p) :\n    Œ±.comp (-Œ≤) h = -Œ±.comp Œ≤ h := by\n  letI := HasDerivedCategory.standard C; ext; simp [this, neg_hom']\n\n"}
{"name":"CategoryTheory.Abelian.Ext.zero_comp","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasExt C\nX Y Z : C\nn m : Nat\nŒ≤ : CategoryTheory.Abelian.Ext Y Z m\np : Nat\nh : Eq (HAdd.hAdd n m) p\n‚ä¢ Eq (CategoryTheory.Abelian.Ext.comp 0 Œ≤ h) 0","decl":"variable (X n) in\n@[simp]\nlemma zero_comp {m : ‚Ñï} (Œ≤ : Ext Y Z m) (p : ‚Ñï) (h : n + m = p) :\n    (0 : Ext X Y n).comp Œ≤ h = 0 := by\n  letI := HasDerivedCategory.standard C; ext; simp [this, zero_hom']\n\n"}
{"name":"CategoryTheory.Abelian.Ext.comp_zero","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasExt C\nX Y : C\nn : Nat\nŒ± : CategoryTheory.Abelian.Ext X Y n\nZ : C\nm p : Nat\nh : Eq (HAdd.hAdd n m) p\n‚ä¢ Eq (Œ±.comp 0 h) 0","decl":"@[simp]\nlemma comp_zero (Œ± : Ext X Y n) (Z : C) (m : ‚Ñï) (p : ‚Ñï) (h : n + m = p) :\n    Œ±.comp (0 : Ext Y Z m) h = 0 := by\n  letI := HasDerivedCategory.standard C; ext; simp [this, zero_hom']\n\n"}
{"name":"CategoryTheory.Abelian.Ext.mk‚ÇÄ_id_comp","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasExt C\nX Y : C\nn : Nat\nŒ± : CategoryTheory.Abelian.Ext X Y n\n‚ä¢ Eq ((CategoryTheory.Abelian.Ext.mk‚ÇÄ (CategoryTheory.CategoryStruct.id X)).comp Œ± ‚ãØ) Œ±","decl":"@[simp]\nlemma mk‚ÇÄ_id_comp (Œ± : Ext X Y n) :\n    (mk‚ÇÄ (ùüô X)).comp Œ± (zero_add n) = Œ± := by\n  letI := HasDerivedCategory.standard C; ext; simp\n\n"}
{"name":"CategoryTheory.Abelian.Ext.comp_mk‚ÇÄ_id","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasExt C\nX Y : C\nn : Nat\nŒ± : CategoryTheory.Abelian.Ext X Y n\n‚ä¢ Eq (Œ±.comp (CategoryTheory.Abelian.Ext.mk‚ÇÄ (CategoryTheory.CategoryStruct.id Y)) ‚ãØ) Œ±","decl":"@[simp]\nlemma comp_mk‚ÇÄ_id (Œ± : Ext X Y n) :\n    Œ±.comp (mk‚ÇÄ (ùüô Y)) (add_zero n) = Œ± := by\n  letI := HasDerivedCategory.standard C; ext; simp\n\n"}
{"name":"CategoryTheory.Abelian.Ext.mk‚ÇÄ_zero","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasExt C\nX Y : C\n‚ä¢ Eq (CategoryTheory.Abelian.Ext.mk‚ÇÄ 0) 0","decl":"variable (X Y) in\n@[simp]\nlemma mk‚ÇÄ_zero : mk‚ÇÄ (0 : X ‚ü∂ Y) = 0 := by\n  letI := HasDerivedCategory.standard C; ext; simp [this, zero_hom']\n\n"}
{"name":"CategoryTheory.Abelian.Ext.biprod_ext","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasExt C\nY : C\nn : Nat\nX‚ÇÅ X‚ÇÇ : C\nŒ± Œ≤ : CategoryTheory.Abelian.Ext (CategoryTheory.Limits.biprod X‚ÇÅ X‚ÇÇ) Y n\nh‚ÇÅ : Eq ((CategoryTheory.Abelian.Ext.mk‚ÇÄ CategoryTheory.Limits.biprod.inl).comp Œ± ‚ãØ) ((CategoryTheory.Abelian.Ext.mk‚ÇÄ CategoryTheory.Limits.biprod.inl).comp Œ≤ ‚ãØ)\nh‚ÇÇ : Eq ((CategoryTheory.Abelian.Ext.mk‚ÇÄ CategoryTheory.Limits.biprod.inr).comp Œ± ‚ãØ) ((CategoryTheory.Abelian.Ext.mk‚ÇÄ CategoryTheory.Limits.biprod.inr).comp Œ≤ ‚ãØ)\n‚ä¢ Eq Œ± Œ≤","decl":"attribute [local instance] preservesBinaryBiproducts_of_preservesBiproducts in\nlemma biprod_ext {X‚ÇÅ X‚ÇÇ : C} {Œ± Œ≤ : Ext (X‚ÇÅ ‚äû X‚ÇÇ) Y n}\n    (h‚ÇÅ : (mk‚ÇÄ biprod.inl).comp Œ± (zero_add n) = (mk‚ÇÄ biprod.inl).comp Œ≤ (zero_add n))\n    (h‚ÇÇ : (mk‚ÇÄ biprod.inr).comp Œ± (zero_add n) = (mk‚ÇÄ biprod.inr).comp Œ≤ (zero_add n)) :\n    Œ± = Œ≤ := by\n  letI := HasDerivedCategory.standard C\n  rw [Ext.ext_iff] at h‚ÇÅ h‚ÇÇ ‚ä¢\n  simp only [comp_hom, mk‚ÇÄ_hom, ShiftedHom.mk‚ÇÄ_comp] at h‚ÇÅ h‚ÇÇ\n  apply BinaryCofan.IsColimit.hom_ext\n    (isBinaryBilimitOfPreserves (singleFunctor C 0)\n      (BinaryBiproduct.isBilimit X‚ÇÅ X‚ÇÇ)).isColimit\n  all_goals assumption\n\n"}
{"name":"CategoryTheory.Abelian.Ext.zero_hom","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Abelian C\ninst‚úù¬π : CategoryTheory.HasExt C\nX Y : C\nn : Nat\ninst‚úù : HasDerivedCategory C\n‚ä¢ Eq (CategoryTheory.Abelian.Ext.hom 0) 0","decl":"variable (X Y n) in\n@[simp]\nlemma zero_hom : (0 : Ext X Y n).hom = 0 := by\n  let Œ≤ : Ext 0 Y n := 0\n  have hŒ≤ : Œ≤.hom = 0 := by apply (Functor.map_isZero _ (isZero_zero C)).eq_of_src\n  have : (0 : Ext X Y n) = (0 : Ext X 0 0).comp Œ≤ (zero_add n) := by simp [Œ≤]\n  rw [this, comp_hom, hŒ≤, ShiftedHom.comp_zero]\n\n"}
{"name":"CategoryTheory.Abelian.Ext.add_hom","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Abelian C\ninst‚úù¬π : CategoryTheory.HasExt C\nX Y : C\nn : Nat\ninst‚úù : HasDerivedCategory C\nŒ± Œ≤ : CategoryTheory.Abelian.Ext X Y n\n‚ä¢ Eq (HAdd.hAdd Œ± Œ≤).hom (HAdd.hAdd Œ±.hom Œ≤.hom)","decl":"@[simp]\nlemma add_hom (Œ± Œ≤ : Ext X Y n) : (Œ± + Œ≤).hom = Œ±.hom + Œ≤.hom := by\n  let Œ±' : Ext (X ‚äû X) Y n := (mk‚ÇÄ biprod.fst).comp Œ± (zero_add n)\n  let Œ≤' : Ext (X ‚äû X) Y n := (mk‚ÇÄ biprod.snd).comp Œ≤ (zero_add n)\n  have eq‚ÇÅ : Œ± + Œ≤ = (mk‚ÇÄ (biprod.lift (ùüô X) (ùüô X))).comp (Œ±' + Œ≤') (zero_add n) := by\n    simp [Œ±', Œ≤']\n  have eq‚ÇÇ : Œ±' + Œ≤' = homEquiv.symm (Œ±'.hom + Œ≤'.hom) := by\n    apply biprod_ext\n    all_goals ext; simp [Œ±', Œ≤', ‚Üê Functor.map_comp]\n  simp only [eq‚ÇÅ, eq‚ÇÇ, comp_hom, Equiv.apply_symm_apply, ShiftedHom.comp_add]\n  congr\n  ¬∑ dsimp [Œ±']\n    rw [comp_hom, mk‚ÇÄ_hom, mk‚ÇÄ_hom]\n    dsimp\n    rw [ShiftedHom.mk‚ÇÄ_comp_mk‚ÇÄ_assoc, ‚Üê Functor.map_comp,\n      biprod.lift_fst, Functor.map_id, ShiftedHom.mk‚ÇÄ_id_comp]\n  ¬∑ dsimp [Œ≤']\n    rw [comp_hom, mk‚ÇÄ_hom, mk‚ÇÄ_hom]\n    dsimp\n    rw [ShiftedHom.mk‚ÇÄ_comp_mk‚ÇÄ_assoc, ‚Üê Functor.map_comp,\n      biprod.lift_snd, Functor.map_id, ShiftedHom.mk‚ÇÄ_id_comp]\n\n"}
{"name":"CategoryTheory.Abelian.Ext.neg_hom","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Abelian C\ninst‚úù¬π : CategoryTheory.HasExt C\nX Y : C\nn : Nat\ninst‚úù : HasDerivedCategory C\nŒ± : CategoryTheory.Abelian.Ext X Y n\n‚ä¢ Eq (Neg.neg Œ±).hom (Neg.neg Œ±.hom)","decl":"lemma neg_hom (Œ± : Ext X Y n) : (-Œ±).hom = -Œ±.hom := by\n  rw [‚Üê add_right_inj Œ±.hom, ‚Üê add_hom, add_neg_cancel, add_neg_cancel, zero_hom]\n\n"}
{"name":"CategoryTheory.Abelian.Ext.homAddEquiv_apply","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Abelian C\ninst‚úù¬π : CategoryTheory.HasExt C\nX Y : C\nn : Nat\ninst‚úù : HasDerivedCategory C\nŒ± : CategoryTheory.Abelian.Ext X Y n\n‚ä¢ Eq (CategoryTheory.Abelian.Ext.homAddEquiv Œ±) Œ±.hom","decl":"@[simp]\nlemma homAddEquiv_apply (Œ± : Ext X Y n) : homAddEquiv Œ± = Œ±.hom := rfl\n\n"}
{"name":"CategoryTheory.Abelian.Ext.bilinearComp_apply_apply","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasExt C\nX Y Z : C\na b c : Nat\nh : Eq (HAdd.hAdd a b) c\nŒ± : CategoryTheory.Abelian.Ext X Y a\nŒ≤ : CategoryTheory.Abelian.Ext Y Z b\n‚ä¢ Eq (((CategoryTheory.Abelian.Ext.bilinearComp X Y Z a b c h) Œ±) Œ≤) (Œ±.comp Œ≤ h)","decl":"variable (X Y Z) in\n/-- The composition of `Ext`, as a bilinear map. -/\n@[simps!]\nnoncomputable def bilinearComp (a b c : ‚Ñï) (h : a + b = c) :\n    Ext X Y a ‚Üí+ Ext Y Z b ‚Üí+ Ext X Z c :=\n  AddMonoidHom.mk' (fun Œ± ‚Ü¶ AddMonoidHom.mk' (fun Œ≤ ‚Ü¶ Œ±.comp Œ≤ h) (by simp)) (by aesop)\n\n"}
{"name":"CategoryTheory.Abelian.extFunctorObj_obj_coe","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasExt C\nX : C\nn : Nat\nY : C\n‚ä¢ Eq (‚Üë((CategoryTheory.Abelian.extFunctorObj X n).obj Y)) (CategoryTheory.Abelian.Ext X Y n)","decl":"/-- Auxiliary definition for `extFunctor`. -/\n@[simps]\nnoncomputable def extFunctorObj (X : C) (n : ‚Ñï) : C ‚•§ AddCommGrp.{w} where\n  obj Y := AddCommGrp.of (Ext X Y n)\n  map f := AddCommGrp.ofHom ((Ext.mk‚ÇÄ f).postcomp _ (add_zero n))\n  map_comp f f' := by\n    ext Œ±\n    dsimp [AddCommGrp.ofHom]\n    rw [‚Üê Ext.mk‚ÇÄ_comp_mk‚ÇÄ]\n    symm\n    apply Ext.comp_assoc\n    omega\n\n"}
{"name":"CategoryTheory.Abelian.extFunctorObj_map","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasExt C\nX : C\nn : Nat\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Abelian.extFunctorObj X n).map f) (AddCommGrp.ofHom ((CategoryTheory.Abelian.Ext.mk‚ÇÄ f).postcomp X ‚ãØ))","decl":"/-- Auxiliary definition for `extFunctor`. -/\n@[simps]\nnoncomputable def extFunctorObj (X : C) (n : ‚Ñï) : C ‚•§ AddCommGrp.{w} where\n  obj Y := AddCommGrp.of (Ext X Y n)\n  map f := AddCommGrp.ofHom ((Ext.mk‚ÇÄ f).postcomp _ (add_zero n))\n  map_comp f f' := by\n    ext Œ±\n    dsimp [AddCommGrp.ofHom]\n    rw [‚Üê Ext.mk‚ÇÄ_comp_mk‚ÇÄ]\n    symm\n    apply Ext.comp_assoc\n    omega\n\n"}
{"name":"CategoryTheory.Abelian.extFunctor_obj","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasExt C\nn : Nat\nX : Opposite C\n‚ä¢ Eq ((CategoryTheory.Abelian.extFunctor n).obj X) (CategoryTheory.Abelian.extFunctorObj (Opposite.unop X) n)","decl":"/-- The functor `C·µí·µñ ‚•§ C ‚•§ AddCommGrp` which sends `X : C` and `Y : C`\nto `Ext X Y n`. -/\n@[simps]\nnoncomputable def extFunctor (n : ‚Ñï) : C·µí·µñ ‚•§ C ‚•§ AddCommGrp.{w} where\n  obj X := extFunctorObj X.unop n\n  map {X‚ÇÅ X‚ÇÇ} f :=\n    { app := fun Y ‚Ü¶ AddCommGrp.ofHom (AddMonoidHom.mk'\n        (fun Œ± ‚Ü¶ (Ext.mk‚ÇÄ f.unop).comp Œ± (zero_add _)) (by simp))\n      naturality := fun {Y‚ÇÅ Y‚ÇÇ} g ‚Ü¶ by\n        ext Œ±\n        dsimp\n        symm\n        apply Ext.comp_assoc\n        all_goals omega }\n  map_comp {X‚ÇÅ X‚ÇÇ X‚ÇÉ} f f' := by\n    ext Y Œ±\n    dsimp\n    rw [‚Üê Ext.mk‚ÇÄ_comp_mk‚ÇÄ]\n    apply Ext.comp_assoc\n    all_goals omega\n\n"}
{"name":"CategoryTheory.Abelian.extFunctor_map_app","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasExt C\nn : Nat\nX‚ÇÅ X‚ÇÇ : Opposite C\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\nY : C\n‚ä¢ Eq (((CategoryTheory.Abelian.extFunctor n).map f).app Y) (AddCommGrp.ofHom (AddMonoidHom.mk' (fun Œ± => (CategoryTheory.Abelian.Ext.mk‚ÇÄ f.unop).comp Œ± ‚ãØ) ‚ãØ))","decl":"/-- The functor `C·µí·µñ ‚•§ C ‚•§ AddCommGrp` which sends `X : C` and `Y : C`\nto `Ext X Y n`. -/\n@[simps]\nnoncomputable def extFunctor (n : ‚Ñï) : C·µí·µñ ‚•§ C ‚•§ AddCommGrp.{w} where\n  obj X := extFunctorObj X.unop n\n  map {X‚ÇÅ X‚ÇÇ} f :=\n    { app := fun Y ‚Ü¶ AddCommGrp.ofHom (AddMonoidHom.mk'\n        (fun Œ± ‚Ü¶ (Ext.mk‚ÇÄ f.unop).comp Œ± (zero_add _)) (by simp))\n      naturality := fun {Y‚ÇÅ Y‚ÇÇ} g ‚Ü¶ by\n        ext Œ±\n        dsimp\n        symm\n        apply Ext.comp_assoc\n        all_goals omega }\n  map_comp {X‚ÇÅ X‚ÇÇ X‚ÇÉ} f f' := by\n    ext Y Œ±\n    dsimp\n    rw [‚Üê Ext.mk‚ÇÄ_comp_mk‚ÇÄ]\n    apply Ext.comp_assoc\n    all_goals omega\n\n"}
{"name":"CategoryTheory.Abelian.Ext.homEquiv_chgUniv","module":"Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasExt C\ninst‚úù¬π : CategoryTheory.HasExt C\nX Y : C\nn : Nat\ninst‚úù : HasDerivedCategory C\ne : CategoryTheory.Abelian.Ext X Y n\n‚ä¢ Eq (CategoryTheory.Abelian.Ext.homEquiv (CategoryTheory.Abelian.Ext.chgUniv e)) (CategoryTheory.Abelian.Ext.homEquiv e)","decl":"lemma homEquiv_chgUniv [HasDerivedCategory.{w''} C] (e : Ext.{w} X Y n) :\n    homEquiv.{w'', w'} (chgUniv.{w'} e) = homEquiv.{w'', w} e := by\n  apply SmallShiftedHom.equiv_chgUniv\n\n"}
