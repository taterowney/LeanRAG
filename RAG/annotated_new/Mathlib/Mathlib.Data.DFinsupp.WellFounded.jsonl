{"name":"DFinsupp.lex_fibration","module":"Mathlib.Data.DFinsupp.WellFounded","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : (i : ι) → Zero (α i)\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\ninst✝ : (i : ι) → (s : Set ι) → Decidable (Membership.mem s i)\n⊢ Relation.Fibration (InvImage (Prod.GameAdd (DFinsupp.Lex r s) (DFinsupp.Lex r s)) Prod.snd) (DFinsupp.Lex r s) fun x => x.2.1.piecewise x.2.2 x.1","decl":"/-- This key lemma says that if a finitely supported dependent function `x₀` is obtained by merging\n  two such functions `x₁` and `x₂`, and if we evolve `x₀` down the `DFinsupp.Lex` relation one\n  step and get `x`, we can always evolve one of `x₁` and `x₂` down the `DFinsupp.Lex` relation\n  one step while keeping the other unchanged, and merge them back (possibly in a different way)\n  to get back `x`. In other words, the two parts evolve essentially independently under\n  `DFinsupp.Lex`. This is used to show that a function `x` is accessible if\n  `DFinsupp.single i (x i)` is accessible for each `i` in the (finite) support of `x`\n  (`DFinsupp.Lex.acc_of_single`). -/\ntheorem lex_fibration [∀ (i) (s : Set ι), Decidable (i ∈ s)] :\n    Fibration (InvImage (GameAdd (DFinsupp.Lex r s) (DFinsupp.Lex r s)) snd) (DFinsupp.Lex r s)\n      fun x => piecewise x.2.1 x.2.2 x.1 := by\n  rintro ⟨p, x₁, x₂⟩ x ⟨i, hr, hs⟩\n  simp_rw [piecewise_apply] at hs hr\n  split_ifs at hs with hp\n  · refine ⟨⟨{ j | r j i → j ∈ p }, piecewise x₁ x { j | r j i }, x₂⟩,\n      .fst ⟨i, fun j hj ↦ ?_, ?_⟩, ?_⟩ <;> simp only [piecewise_apply, Set.mem_setOf_eq]\n    · simp only [if_pos hj]\n    · split_ifs with hi\n      · rwa [hr i hi, if_pos hp] at hs\n      · assumption\n    · ext1 j\n      simp only [piecewise_apply, Set.mem_setOf_eq]\n      split_ifs with h₁ h₂ <;> try rfl\n      · rw [hr j h₂, if_pos (h₁ h₂)]\n      · rw [Classical.not_imp] at h₁\n        rw [hr j h₁.1, if_neg h₁.2]\n  · refine ⟨⟨{ j | r j i ∧ j ∈ p }, x₁, piecewise x₂ x { j | r j i }⟩,\n      .snd ⟨i, fun j hj ↦ ?_, ?_⟩, ?_⟩ <;> simp only [piecewise_apply, Set.mem_setOf_eq]\n    · exact if_pos hj\n    · split_ifs with hi\n      · rwa [hr i hi, if_neg hp] at hs\n      · assumption\n    · ext1 j\n      simp only [piecewise_apply, Set.mem_setOf_eq]\n      split_ifs with h₁ h₂ <;> try rfl\n      · rw [hr j h₁.1, if_pos h₁.2]\n      · rw [hr j h₂, if_neg]\n        simpa [h₂] using h₁\n\n"}
{"name":"DFinsupp.Lex.acc_of_single_erase","module":"Mathlib.Data.DFinsupp.WellFounded","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : (i : ι) → Zero (α i)\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\ninst✝ : DecidableEq ι\nx : DFinsupp fun i => α i\ni : ι\nhs : Acc (DFinsupp.Lex r s) (DFinsupp.single i (x i))\nhu : Acc (DFinsupp.Lex r s) (DFinsupp.erase i x)\n⊢ Acc (DFinsupp.Lex r s) x","decl":"theorem Lex.acc_of_single_erase [DecidableEq ι] {x : Π₀ i, α i} (i : ι)\n    (hs : Acc (DFinsupp.Lex r s) <| single i (x i)) (hu : Acc (DFinsupp.Lex r s) <| x.erase i) :\n    Acc (DFinsupp.Lex r s) x := by\n  classical\n    convert ← @Acc.of_fibration _ _ _ _ _ (lex_fibration r s) ⟨{i}, _⟩\n      (InvImage.accessible snd <| hs.prod_gameAdd hu)\n    convert piecewise_single_erase x i\n\n\n"}
{"name":"DFinsupp.Lex.acc_zero","module":"Mathlib.Data.DFinsupp.WellFounded","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → Zero (α i)\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\nhbot : ∀ ⦃i : ι⦄ ⦃a : α i⦄, Not (s i a 0)\n⊢ Acc (DFinsupp.Lex r s) 0","decl":"theorem Lex.acc_zero (hbot : ∀ ⦃i a⦄, ¬s i a 0) : Acc (DFinsupp.Lex r s) 0 :=\n  Acc.intro 0 fun _ ⟨_, _, h⟩ => (hbot h).elim\n\n"}
{"name":"DFinsupp.Lex.acc_of_single","module":"Mathlib.Data.DFinsupp.WellFounded","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝² : (i : ι) → Zero (α i)\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\nhbot : ∀ ⦃i : ι⦄ ⦃a : α i⦄, Not (s i a 0)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → (x : α i) → Decidable (Ne x 0)\nx : DFinsupp fun i => α i\na✝ : ∀ (i : ι), Membership.mem x.support i → Acc (DFinsupp.Lex r s) (DFinsupp.single i (x i))\n⊢ Acc (DFinsupp.Lex r s) x","decl":"theorem Lex.acc_of_single (hbot : ∀ ⦃i a⦄, ¬s i a 0) [DecidableEq ι]\n    [∀ (i) (x : α i), Decidable (x ≠ 0)] (x : Π₀ i, α i) :\n    (∀ i ∈ x.support, Acc (DFinsupp.Lex r s) <| single i (x i)) → Acc (DFinsupp.Lex r s) x := by\n  generalize ht : x.support = t; revert x\n  classical\n    induction' t using Finset.induction with b t hb ih\n    · intro x ht\n      rw [support_eq_empty.1 ht]\n      exact fun _ => Lex.acc_zero hbot\n    refine fun x ht h => Lex.acc_of_single_erase b (h b <| t.mem_insert_self b) ?_\n    refine ih _ (by rw [support_erase, ht, Finset.erase_insert hb]) fun a ha => ?_\n    rw [erase_ne (ha.ne_of_not_mem hb)]\n    exact h a (Finset.mem_insert_of_mem ha)\n\n"}
{"name":"DFinsupp.Lex.acc_single","module":"Mathlib.Data.DFinsupp.WellFounded","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : (i : ι) → Zero (α i)\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\nhbot : ∀ ⦃i : ι⦄ ⦃a : α i⦄, Not (s i a 0)\nhs : ∀ (i : ι), WellFounded (s i)\ninst✝ : DecidableEq ι\ni : ι\nhi : Acc (Min.min (HasCompl.compl r) fun x1 x2 => Ne x1 x2) i\na : α i\n⊢ Acc (DFinsupp.Lex r s) (DFinsupp.single i a)","decl":"theorem Lex.acc_single (hbot : ∀ ⦃i a⦄, ¬s i a 0) (hs : ∀ i, WellFounded (s i))\n    [DecidableEq ι] {i : ι} (hi : Acc (rᶜ ⊓ (· ≠ ·)) i) :\n    ∀ a, Acc (DFinsupp.Lex r s) (single i a) := by\n  induction' hi with i _ ih\n  refine fun a => WellFounded.induction (hs i)\n    (C := fun x ↦ Acc (DFinsupp.Lex r s) (single i x)) a fun a ha ↦ ?_\n  refine Acc.intro _ fun x ↦ ?_\n  rintro ⟨k, hr, hs⟩\n  rw [single_apply] at hs\n  split_ifs at hs with hik\n  swap\n  · exact (hbot hs).elim\n  subst hik\n  classical\n    refine Lex.acc_of_single hbot x fun j hj ↦ ?_\n    obtain rfl | hij := eq_or_ne i j\n    · exact ha _ hs\n    by_cases h : r j i\n    · rw [hr j h, single_eq_of_ne hij, single_zero]\n      exact Lex.acc_zero hbot\n    · exact ih _ ⟨h, hij.symm⟩ _\n\n"}
{"name":"DFinsupp.Lex.acc","module":"Mathlib.Data.DFinsupp.WellFounded","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝² : (i : ι) → Zero (α i)\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\nhbot : ∀ ⦃i : ι⦄ ⦃a : α i⦄, Not (s i a 0)\nhs : ∀ (i : ι), WellFounded (s i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → (x : α i) → Decidable (Ne x 0)\nx : DFinsupp fun i => α i\nh : ∀ (i : ι), Membership.mem x.support i → Acc (Min.min (HasCompl.compl r) fun x1 x2 => Ne x1 x2) i\n⊢ Acc (DFinsupp.Lex r s) x","decl":"theorem Lex.acc (hbot : ∀ ⦃i a⦄, ¬s i a 0) (hs : ∀ i, WellFounded (s i))\n    [DecidableEq ι] [∀ (i) (x : α i), Decidable (x ≠ 0)] (x : Π₀ i, α i)\n    (h : ∀ i ∈ x.support, Acc (rᶜ ⊓ (· ≠ ·)) i) : Acc (DFinsupp.Lex r s) x :=\n  Lex.acc_of_single hbot x fun i hi => Lex.acc_single hbot hs (h i hi) _\n\n"}
{"name":"DFinsupp.Lex.wellFounded","module":"Mathlib.Data.DFinsupp.WellFounded","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → Zero (α i)\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\nhbot : ∀ ⦃i : ι⦄ ⦃a : α i⦄, Not (s i a 0)\nhs : ∀ (i : ι), WellFounded (s i)\nhr : WellFounded (Min.min (HasCompl.compl r) fun x1 x2 => Ne x1 x2)\n⊢ WellFounded (DFinsupp.Lex r s)","decl":"theorem Lex.wellFounded (hbot : ∀ ⦃i a⦄, ¬s i a 0) (hs : ∀ i, WellFounded (s i))\n    (hr : WellFounded <| rᶜ ⊓ (· ≠ ·)) : WellFounded (DFinsupp.Lex r s) :=\n  ⟨fun x => by classical exact Lex.acc hbot hs x fun i _ => hr.apply i⟩\n\n"}
{"name":"DFinsupp.Lex.wellFounded'","module":"Mathlib.Data.DFinsupp.WellFounded","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : (i : ι) → Zero (α i)\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\nhbot : ∀ ⦃i : ι⦄ ⦃a : α i⦄, Not (s i a 0)\nhs : ∀ (i : ι), WellFounded (s i)\ninst✝ : IsTrichotomous ι r\nhr : WellFounded (Function.swap r)\n⊢ WellFounded (DFinsupp.Lex r s)","decl":"theorem Lex.wellFounded' (hbot : ∀ ⦃i a⦄, ¬s i a 0) (hs : ∀ i, WellFounded (s i))\n    [IsTrichotomous ι r] (hr : WellFounded (Function.swap r)) :\n    WellFounded (DFinsupp.Lex r s) :=\n  Lex.wellFounded hbot hs <| Subrelation.wf\n   (fun {i j} h => ((@IsTrichotomous.trichotomous ι r _ i j).resolve_left h.1).resolve_left h.2) hr\n\n"}
{"name":"DFinsupp.Lex.wellFoundedLT","module":"Mathlib.Data.DFinsupp.WellFounded","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝⁴ : LT ι\ninst✝³ : IsTrichotomous ι fun x1 x2 => LT.lt x1 x2\nhι : WellFoundedGT ι\ninst✝² : (i : ι) → AddMonoid (α i)\ninst✝¹ : (i : ι) → PartialOrder (α i)\ninst✝ : ∀ (i : ι), CanonicallyOrderedAdd (α i)\nhα : ∀ (i : ι), WellFoundedLT (α i)\n⊢ WellFoundedLT (Lex (DFinsupp fun i => α i))","decl":"instance Lex.wellFoundedLT [LT ι] [IsTrichotomous ι (· < ·)] [hι : WellFoundedGT ι]\n    [∀ i, AddMonoid (α i)] [∀ i, PartialOrder (α i)] [∀ i, CanonicallyOrderedAdd (α i)]\n    [hα : ∀ i, WellFoundedLT (α i)] :\n    WellFoundedLT (Lex (Π₀ i, α i)) :=\n  ⟨Lex.wellFounded' (fun _ a => (zero_le a).not_lt) (fun i => (hα i).wf) hι.wf⟩\n\n"}
{"name":"Pi.Lex.wellFounded","module":"Mathlib.Data.DFinsupp.WellFounded","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\ninst✝¹ : IsStrictTotalOrder ι r\ninst✝ : Finite ι\nhs : ∀ (i : ι), WellFounded (s i)\n⊢ WellFounded (Pi.Lex r fun {i} => s i)","decl":"theorem Pi.Lex.wellFounded [IsStrictTotalOrder ι r] [Finite ι] (hs : ∀ i, WellFounded (s i)) :\n    WellFounded (Pi.Lex r (fun {i} ↦ s i)) := by\n  obtain h | ⟨⟨x⟩⟩ := isEmpty_or_nonempty (∀ i, α i)\n  · convert emptyWf.wf\n  letI : ∀ i, Zero (α i) := fun i => ⟨(hs i).min ⊤ ⟨x i, trivial⟩⟩\n  haveI := IsTrans.swap r; haveI := IsIrrefl.swap r; haveI := Fintype.ofFinite ι\n  refine InvImage.wf equivFunOnFintype.symm (Lex.wellFounded' (fun i a => ?_) hs ?_)\n  exacts [(hs i).not_lt_min ⊤ _ trivial, Finite.wellFounded_of_trans_of_irrefl (Function.swap r)]\n\n"}
{"name":"Pi.Lex.wellFoundedLT","module":"Mathlib.Data.DFinsupp.WellFounded","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝² : LinearOrder ι\ninst✝¹ : Finite ι\ninst✝ : (i : ι) → LT (α i)\nhwf : ∀ (i : ι), WellFoundedLT (α i)\n⊢ WellFoundedLT (Lex ((i : ι) → α i))","decl":"instance Pi.Lex.wellFoundedLT [LinearOrder ι] [Finite ι] [∀ i, LT (α i)]\n    [hwf : ∀ i, WellFoundedLT (α i)] : WellFoundedLT (Lex (∀ i, α i)) :=\n  ⟨Pi.Lex.wellFounded (· < ·) fun i => (hwf i).1⟩\n\n"}
{"name":"Function.Lex.wellFoundedLT","module":"Mathlib.Data.DFinsupp.WellFounded","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝³ : LinearOrder ι\ninst✝² : Finite ι\ninst✝¹ : LT α\ninst✝ : WellFoundedLT α\n⊢ WellFoundedLT (Lex (ι → α))","decl":"instance Function.Lex.wellFoundedLT {α} [LinearOrder ι] [Finite ι] [LT α] [WellFoundedLT α] :\n    WellFoundedLT (Lex (ι → α)) :=\n  Pi.Lex.wellFoundedLT\n\n"}
{"name":"DFinsupp.Lex.wellFounded_of_finite","module":"Mathlib.Data.DFinsupp.WellFounded","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\ninst✝² : IsStrictTotalOrder ι r\ninst✝¹ : Finite ι\ninst✝ : (i : ι) → Zero (α i)\nhs : ∀ (i : ι), WellFounded (s i)\n⊢ WellFounded (DFinsupp.Lex r s)","decl":"theorem DFinsupp.Lex.wellFounded_of_finite [IsStrictTotalOrder ι r] [Finite ι] [∀ i, Zero (α i)]\n    (hs : ∀ i, WellFounded (s i)) : WellFounded (DFinsupp.Lex r s) :=\n  have := Fintype.ofFinite ι\n  InvImage.wf equivFunOnFintype (Pi.Lex.wellFounded r hs)\n\n"}
{"name":"DFinsupp.Lex.wellFoundedLT_of_finite","module":"Mathlib.Data.DFinsupp.WellFounded","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝³ : LinearOrder ι\ninst✝² : Finite ι\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → LT (α i)\nhwf : ∀ (i : ι), WellFoundedLT (α i)\n⊢ WellFoundedLT (Lex (DFinsupp fun i => α i))","decl":"instance DFinsupp.Lex.wellFoundedLT_of_finite [LinearOrder ι] [Finite ι] [∀ i, Zero (α i)]\n    [∀ i, LT (α i)] [hwf : ∀ i, WellFoundedLT (α i)] : WellFoundedLT (Lex (Π₀ i, α i)) :=\n  ⟨DFinsupp.Lex.wellFounded_of_finite (· < ·) fun i => (hwf i).1⟩\n\n"}
{"name":"DFinsupp.wellFoundedLT","module":"Mathlib.Data.DFinsupp.WellFounded","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝² : (i : ι) → Zero (α i)\ninst✝¹ : (i : ι) → Preorder (α i)\ninst✝ : ∀ (i : ι), WellFoundedLT (α i)\nhbot : ∀ ⦃i : ι⦄ ⦃a : α i⦄, Not (LT.lt a 0)\n⊢ WellFoundedLT (DFinsupp fun i => α i)","decl":"protected theorem DFinsupp.wellFoundedLT [∀ i, Zero (α i)] [∀ i, Preorder (α i)]\n    [∀ i, WellFoundedLT (α i)] (hbot : ∀ ⦃i⦄ ⦃a : α i⦄, ¬a < 0) : WellFoundedLT (Π₀ i, α i) :=\n  ⟨by\n    set β := fun i ↦ Antisymmetrization (α i) (· ≤ ·)\n    set e : (i : ι) → α i → β i := fun i ↦ toAntisymmetrization (· ≤ ·)\n    let _ : ∀ i, Zero (β i) := fun i ↦ ⟨e i 0⟩\n    have : WellFounded (DFinsupp.Lex (Function.swap <| @WellOrderingRel ι)\n        (fun _ ↦ (· < ·) : (i : ι) → β i → β i → Prop)) := by\n      have := IsTrichotomous.swap (@WellOrderingRel ι)\n      refine Lex.wellFounded' ?_ (fun i ↦ IsWellFounded.wf) ?_\n      · rintro i ⟨a⟩\n        apply hbot\n      · simp +unfoldPartialApp only [Function.swap]\n        exact IsWellFounded.wf\n    refine Subrelation.wf (fun h => ?_) <| InvImage.wf (mapRange e fun _ ↦ rfl) this\n    have := IsStrictOrder.swap (@WellOrderingRel ι)\n    obtain ⟨i, he, hl⟩ := lex_lt_of_lt_of_preorder (Function.swap WellOrderingRel) h\n    exact ⟨i, fun j hj ↦ Quot.sound (he j hj), hl⟩⟩\n\n"}
{"name":"DFinsupp.wellFoundedLT'","module":"Mathlib.Data.DFinsupp.WellFounded","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝³ : (i : ι) → AddMonoid (α i)\ninst✝² : (i : ι) → PartialOrder (α i)\ninst✝¹ : ∀ (i : ι), CanonicallyOrderedAdd (α i)\ninst✝ : ∀ (i : ι), WellFoundedLT (α i)\n⊢ WellFoundedLT (DFinsupp fun i => α i)","decl":"instance DFinsupp.wellFoundedLT'\n    [∀ i, AddMonoid (α i)] [∀ i, PartialOrder (α i)] [∀ i, CanonicallyOrderedAdd (α i)]\n    [∀ i, WellFoundedLT (α i)] : WellFoundedLT (Π₀ i, α i) :=\n  DFinsupp.wellFoundedLT fun _i a => (zero_le a).not_lt\n\n"}
{"name":"Pi.wellFoundedLT","module":"Mathlib.Data.DFinsupp.WellFounded","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : Finite ι\ninst✝ : (i : ι) → Preorder (α i)\nhw : ∀ (i : ι), WellFoundedLT (α i)\n⊢ WellFoundedLT ((i : ι) → α i)","decl":"instance Pi.wellFoundedLT [Finite ι] [∀ i, Preorder (α i)] [hw : ∀ i, WellFoundedLT (α i)] :\n    WellFoundedLT (∀ i, α i) :=\n  ⟨by\n    obtain h | ⟨⟨x⟩⟩ := isEmpty_or_nonempty (∀ i, α i)\n    · convert emptyWf.wf\n    letI : ∀ i, Zero (α i) := fun i => ⟨(hw i).wf.min ⊤ ⟨x i, trivial⟩⟩\n    haveI := Fintype.ofFinite ι\n    refine InvImage.wf equivFunOnFintype.symm (DFinsupp.wellFoundedLT fun i a => ?_).wf\n    exact (hw i).wf.not_lt_min ⊤ _ trivial⟩\n\n"}
{"name":"Function.wellFoundedLT","module":"Mathlib.Data.DFinsupp.WellFounded","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝² : Finite ι\ninst✝¹ : Preorder α\ninst✝ : WellFoundedLT α\n⊢ WellFoundedLT (ι → α)","decl":"instance Function.wellFoundedLT {α} [Finite ι] [Preorder α] [WellFoundedLT α] :\n    WellFoundedLT (ι → α) :=\n  Pi.wellFoundedLT\n\n"}
{"name":"DFinsupp.wellFoundedLT_of_finite","module":"Mathlib.Data.DFinsupp.WellFounded","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝³ : Finite ι\ninst✝² : (i : ι) → Zero (α i)\ninst✝¹ : (i : ι) → Preorder (α i)\ninst✝ : ∀ (i : ι), WellFoundedLT (α i)\n⊢ WellFoundedLT (DFinsupp fun i => α i)","decl":"instance DFinsupp.wellFoundedLT_of_finite [Finite ι] [∀ i, Zero (α i)] [∀ i, Preorder (α i)]\n    [∀ i, WellFoundedLT (α i)] : WellFoundedLT (Π₀ i, α i) :=\n  have := Fintype.ofFinite ι\n  ⟨InvImage.wf equivFunOnFintype Pi.wellFoundedLT.wf⟩\n"}
