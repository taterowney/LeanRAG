{"name":"toArithmeticFunction_congr","module":"Mathlib.NumberTheory.LSeries.Convolution","initialProofState":"R : Type u_1\ninst✝ : Zero R\nf f' : Nat → R\nh : ∀ {n : Nat}, Ne n 0 → Eq (f n) (f' n)\n⊢ Eq (toArithmeticFunction f) (toArithmeticFunction f')","decl":"lemma toArithmeticFunction_congr {R : Type*} [Zero R] {f f' : ℕ → R}\n    (h : ∀ {n}, n ≠ 0 → f n = f' n) :\n    toArithmeticFunction f = toArithmeticFunction f' := by\n  ext\n  simp_all [toArithmeticFunction]\n\n"}
{"name":"ArithmeticFunction.toArithmeticFunction_eq_self","module":"Mathlib.NumberTheory.LSeries.Convolution","initialProofState":"R : Type u_1\ninst✝ : Zero R\nf : ArithmeticFunction R\n⊢ Eq (toArithmeticFunction ⇑f) f","decl":"/-- If we consider an arithmetic function just as a function and turn it back into an\narithmetic function, it is the same as before. -/\n@[simp]\nlemma ArithmeticFunction.toArithmeticFunction_eq_self {R : Type*} [Zero R]\n    (f : ArithmeticFunction R) :\n    toArithmeticFunction f = f := by\n  ext n\n  simp +contextual [toArithmeticFunction]\n\n"}
{"name":"LSeries.convolution_congr","module":"Mathlib.NumberTheory.LSeries.Convolution","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf f' g g' : Nat → R\nhf : ∀ {n : Nat}, Ne n 0 → Eq (f n) (f' n)\nhg : ∀ {n : Nat}, Ne n 0 → Eq (g n) (g' n)\n⊢ Eq (LSeries.convolution f g) (LSeries.convolution f' g')","decl":"lemma LSeries.convolution_congr {R : Type*} [Semiring R] {f f' g g' : ℕ → R}\n    (hf : ∀ {n}, n ≠ 0 → f n = f' n) (hg : ∀ {n}, n ≠ 0 → g n = g' n) :\n    f ⍟ g = f' ⍟ g' := by\n  simp [convolution, toArithmeticFunction_congr hf, toArithmeticFunction_congr hg]\n\n"}
{"name":"ArithmeticFunction.coe_mul","module":"Mathlib.NumberTheory.LSeries.Convolution","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf g : ArithmeticFunction R\n⊢ Eq (LSeries.convolution ⇑f ⇑g) ⇑(HMul.hMul f g)","decl":"/-- The product of two arithmetic functions defines the same function as the Dirichlet convolution\nof the functions defined by them. -/\nlemma ArithmeticFunction.coe_mul {R : Type*} [Semiring R] (f g : ArithmeticFunction R) :\n    f ⍟ g = ⇑(f * g) := by\n  simp [convolution]\n\n"}
{"name":"LSeries.convolution_def","module":"Mathlib.NumberTheory.LSeries.Convolution","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf g : Nat → R\n⊢ Eq (LSeries.convolution f g) fun n => n.divisorsAntidiagonal.sum fun p => HMul.hMul (f p.1) (g p.2)","decl":"lemma convolution_def {R : Type*} [Semiring R] (f g : ℕ → R) :\n    f ⍟ g = fun n ↦ ∑ p ∈ n.divisorsAntidiagonal, f p.1 * g p.2 := by\n  ext n\n  simpa [convolution, toArithmeticFunction] using\n    Finset.sum_congr rfl fun p hp ↦ by simp [ne_zero_of_mem_divisorsAntidiagonal hp]\n\n"}
{"name":"LSeries.convolution_map_zero","module":"Mathlib.NumberTheory.LSeries.Convolution","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf g : Nat → R\n⊢ Eq (LSeries.convolution f g 0) 0","decl":"@[simp]\nlemma convolution_map_zero {R : Type*} [Semiring R] (f g : ℕ → R) : (f ⍟ g) 0 = 0 := by\n  simp [convolution_def]\n\n\n"}
{"name":"LSeries.term_convolution","module":"Mathlib.NumberTheory.LSeries.Convolution","initialProofState":"f g : Nat → Complex\ns : Complex\nn : Nat\n⊢ Eq (LSeries.term (LSeries.convolution f g) s n) (n.divisorsAntidiagonal.sum fun p => HMul.hMul (LSeries.term f s p.1) (LSeries.term g s p.2))","decl":"/-- We give an expression of the `LSeries.term` of the convolution of two functions\nin terms of a sum over `Nat.divisorsAntidiagonal`. -/\nlemma term_convolution (f g : ℕ → ℂ) (s : ℂ) (n : ℕ) :\n    term (f ⍟ g) s n = ∑ p ∈ n.divisorsAntidiagonal, term f s p.1 * term g s p.2 := by\n  rcases eq_or_ne n 0 with rfl | hn\n  · simp\n  -- now `n ≠ 0`\n  rw [term_of_ne_zero hn, convolution_def, Finset.sum_div]\n  refine Finset.sum_congr rfl fun p hp ↦ ?_\n  have ⟨hp₁, hp₂⟩ := ne_zero_of_mem_divisorsAntidiagonal hp\n  rw [term_of_ne_zero hp₁, term_of_ne_zero hp₂, mul_comm_div, div_div, ← mul_div_assoc,\n    ← natCast_mul_natCast_cpow, ← cast_mul, mul_comm p.2, (mem_divisorsAntidiagonal.mp hp).1]\n\n"}
{"name":"LSeries.term_convolution'","module":"Mathlib.NumberTheory.LSeries.Convolution","initialProofState":"f g : Nat → Complex\ns : Complex\n⊢ Eq (LSeries.term (LSeries.convolution f g) s) fun n => tsum fun b => HMul.hMul (LSeries.term f s (↑b).1) (LSeries.term g s (↑b).2)","decl":"open Set in\n/-- We give an expression of the `LSeries.term` of the convolution of two functions\nin terms of an a priori infinite sum over all pairs `(k, m)` with `k * m = n`\n(the set we sum over is infinite when `n = 0`). This is the version needed for the\nproof that `L (f ⍟ g) = L f * L g`. -/\nlemma term_convolution' (f g : ℕ → ℂ) (s : ℂ) :\n    term (f ⍟ g) s = fun n ↦\n      ∑' (b : (fun p : ℕ × ℕ ↦ p.1 * p.2) ⁻¹' {n}), term f s b.val.1 * term g s b.val.2 := by\n  ext n\n  rcases eq_or_ne n 0 with rfl | hn\n  · -- show that both sides vanish when `n = 0`; this is the hardest part of the proof!\n    refine (term_zero ..).trans ?_\n    -- the right hand sum is over the union below, but in each term, one factor is always zero\n    have hS : (fun p ↦ p.1 * p.2) ⁻¹' {0} = {0} ×ˢ univ ∪ univ ×ˢ {0} := by\n      ext\n      simp [Nat.mul_eq_zero, -singleton_prod, -prod_singleton]\n    have : ∀ p : (fun p : ℕ × ℕ ↦ p.1 * p.2) ⁻¹' {0}, term f s p.val.1 * term g s p.val.2 = 0 := by\n      rintro ⟨⟨_, _⟩, hp⟩\n      rcases hS ▸ hp with ⟨rfl, -⟩ | ⟨-, rfl⟩ <;> simp\n    simp [this]\n  -- now `n ≠ 0`\n  rw [show (fun p : ℕ × ℕ ↦ p.1 * p.2) ⁻¹' {n} = n.divisorsAntidiagonal by ext; simp [hn],\n    Finset.tsum_subtype' n.divisorsAntidiagonal fun p ↦ term f s p.1 * term g s p.2,\n    term_convolution f g s n]\n\n"}
{"name":"LSeriesHasSum.convolution","module":"Mathlib.NumberTheory.LSeries.Convolution","initialProofState":"f g : Nat → Complex\ns a b : Complex\nhf : LSeriesHasSum f s a\nhg : LSeriesHasSum g s b\n⊢ LSeriesHasSum (LSeries.convolution f g) s (HMul.hMul a b)","decl":"open Set in\n/-- The L-series of the convolution product `f ⍟ g` of two sequences `f` and `g`\nequals the product of their L-series, assuming both L-series converge. -/\nlemma LSeriesHasSum.convolution {f g : ℕ → ℂ} {s a b : ℂ} (hf : LSeriesHasSum f s a)\n    (hg : LSeriesHasSum g s b) :\n    LSeriesHasSum (f ⍟ g) s (a * b) := by\n  have hsum := summable_mul_of_summable_norm hf.summable.norm hg.summable.norm\n  -- NB: this `simpa` is quite slow if un-squeezed\n  simpa only [LSeriesHasSum, term_convolution'] using (hf.mul hg hsum).tsum_fiberwise _\n\n"}
{"name":"LSeries_convolution'","module":"Mathlib.NumberTheory.LSeries.Convolution","initialProofState":"f g : Nat → Complex\ns : Complex\nhf : LSeriesSummable f s\nhg : LSeriesSummable g s\n⊢ Eq (LSeries (LSeries.convolution f g) s) (HMul.hMul (LSeries f s) (LSeries g s))","decl":"/-- The L-series of the convolution product `f ⍟ g` of two sequences `f` and `g`\nequals the product of their L-series, assuming both L-series converge. -/\nlemma LSeries_convolution' {f g : ℕ → ℂ} {s : ℂ} (hf : LSeriesSummable f s)\n    (hg : LSeriesSummable g s) :\n    LSeries (f ⍟ g) s = LSeries f s * LSeries g s :=\n  (LSeriesHasSum.convolution hf.LSeriesHasSum hg.LSeriesHasSum).LSeries_eq\n\n"}
{"name":"LSeries_convolution","module":"Mathlib.NumberTheory.LSeries.Convolution","initialProofState":"f g : Nat → Complex\ns : Complex\nhf : LT.lt (LSeries.abscissaOfAbsConv f) ↑s.re\nhg : LT.lt (LSeries.abscissaOfAbsConv g) ↑s.re\n⊢ Eq (LSeries (LSeries.convolution f g) s) (HMul.hMul (LSeries f s) (LSeries g s))","decl":"/-- The L-series of the convolution product `f ⍟ g` of two sequences `f` and `g`\nequals the product of their L-series in their common half-plane of absolute convergence. -/\nlemma LSeries_convolution {f g : ℕ → ℂ} {s : ℂ}\n    (hf : abscissaOfAbsConv f < s.re) (hg : abscissaOfAbsConv g < s.re) :\n    LSeries (f ⍟ g) s = LSeries f s * LSeries g s :=\n  LSeries_convolution' (LSeriesSummable_of_abscissaOfAbsConv_lt_re hf)\n    (LSeriesSummable_of_abscissaOfAbsConv_lt_re hg)\n\n"}
{"name":"LSeriesSummable.convolution","module":"Mathlib.NumberTheory.LSeries.Convolution","initialProofState":"f g : Nat → Complex\ns : Complex\nhf : LSeriesSummable f s\nhg : LSeriesSummable g s\n⊢ LSeriesSummable (LSeries.convolution f g) s","decl":"/-- The L-series of the convolution product `f ⍟ g` of two sequences `f` and `g`\nis summable when both L-series are summable. -/\nlemma LSeriesSummable.convolution {f g : ℕ → ℂ} {s : ℂ} (hf : LSeriesSummable f s)\n    (hg : LSeriesSummable g s) :\n    LSeriesSummable (f ⍟ g) s :=\n  (LSeriesHasSum.convolution hf.LSeriesHasSum hg.LSeriesHasSum).LSeriesSummable\n\n"}
{"name":"LSeries.abscissaOfAbsConv_convolution_le","module":"Mathlib.NumberTheory.LSeries.Convolution","initialProofState":"f g : Nat → Complex\n⊢ LE.le (LSeries.abscissaOfAbsConv (LSeries.convolution f g)) (Max.max (LSeries.abscissaOfAbsConv f) (LSeries.abscissaOfAbsConv g))","decl":"/-- The abscissa of absolute convergence of `f ⍟ g` is at most the maximum of those\nof `f` and `g`. -/\nlemma LSeries.abscissaOfAbsConv_convolution_le (f g : ℕ → ℂ) :\n    abscissaOfAbsConv (f ⍟ g) ≤ max (abscissaOfAbsConv f) (abscissaOfAbsConv g) :=\n  abscissaOfAbsConv_binop_le LSeriesSummable.convolution f g\n\n"}
{"name":"ArithmeticFunction.LSeriesHasSum_mul","module":"Mathlib.NumberTheory.LSeries.Convolution","initialProofState":"f g : ArithmeticFunction Complex\ns a b : Complex\nhf : LSeriesHasSum (fun n => f n) s a\nhg : LSeriesHasSum (fun n => g n) s b\n⊢ LSeriesHasSum (fun n => (HMul.hMul f g) n) s (HMul.hMul a b)","decl":"/-- The L-series of the (convolution) product of two `ℂ`-valued arithmetic functions `f` and `g`\nequals the product of their L-series, assuming both L-series converge. -/\nlemma LSeriesHasSum_mul {f g : ArithmeticFunction ℂ} {s a b : ℂ} (hf : LSeriesHasSum ↗f s a)\n    (hg : LSeriesHasSum ↗g s b) :\n    LSeriesHasSum ↗(f * g) s (a * b) :=\n  coe_mul f g ▸ hf.convolution hg\n\n"}
{"name":"ArithmeticFunction.LSeries_mul'","module":"Mathlib.NumberTheory.LSeries.Convolution","initialProofState":"f g : ArithmeticFunction Complex\ns : Complex\nhf : LSeriesSummable (fun n => f n) s\nhg : LSeriesSummable (fun n => g n) s\n⊢ Eq (LSeries (fun n => (HMul.hMul f g) n) s) (HMul.hMul (LSeries (fun n => f n) s) (LSeries (fun n => g n) s))","decl":"/-- The L-series of the (convolution) product of two `ℂ`-valued arithmetic functions `f` and `g`\nequals the product of their L-series, assuming both L-series converge. -/\nlemma LSeries_mul' {f g : ArithmeticFunction ℂ} {s : ℂ} (hf : LSeriesSummable ↗f s)\n    (hg : LSeriesSummable ↗g s) :\n    LSeries ↗(f * g) s = LSeries ↗f s * LSeries ↗g s :=\n  coe_mul f g ▸ LSeries_convolution' hf hg\n\n"}
{"name":"ArithmeticFunction.LSeries_mul","module":"Mathlib.NumberTheory.LSeries.Convolution","initialProofState":"f g : ArithmeticFunction Complex\ns : Complex\nhf : LT.lt (LSeries.abscissaOfAbsConv fun n => f n) ↑s.re\nhg : LT.lt (LSeries.abscissaOfAbsConv fun n => g n) ↑s.re\n⊢ Eq (LSeries (fun n => (HMul.hMul f g) n) s) (HMul.hMul (LSeries (fun n => f n) s) (LSeries (fun n => g n) s))","decl":"/-- The L-series of the (convolution) product of two `ℂ`-valued arithmetic functions `f` and `g`\nequals the product of their L-series in their common half-plane of absolute convergence. -/\nlemma LSeries_mul {f g : ArithmeticFunction ℂ} {s : ℂ}\n    (hf : abscissaOfAbsConv ↗f < s.re) (hg : abscissaOfAbsConv ↗g < s.re) :\n    LSeries ↗(f * g) s = LSeries ↗f s * LSeries ↗g s :=\n  coe_mul f g ▸ LSeries_convolution hf hg\n\n"}
{"name":"ArithmeticFunction.LSeriesSummable_mul","module":"Mathlib.NumberTheory.LSeries.Convolution","initialProofState":"f g : ArithmeticFunction Complex\ns : Complex\nhf : LSeriesSummable (fun n => f n) s\nhg : LSeriesSummable (fun n => g n) s\n⊢ LSeriesSummable (fun n => (HMul.hMul f g) n) s","decl":"/-- The L-series of the (convolution) product of two `ℂ`-valued arithmetic functions `f` and `g`\nis summable when both L-series are summable. -/\nlemma LSeriesSummable_mul {f g : ArithmeticFunction ℂ} {s : ℂ} (hf : LSeriesSummable ↗f s)\n    (hg : LSeriesSummable ↗g s) :\n    LSeriesSummable ↗(f * g) s :=\n  coe_mul f g ▸ hf.convolution hg\n\n"}
