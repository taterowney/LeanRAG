{"name":"CategoryTheory.Abelian.mono_of_epi_of_mono_of_mono'","module":"Mathlib.CategoryTheory.Abelian.DiagramLemmas.Four","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nR‚ÇÅ R‚ÇÇ : CategoryTheory.ComposableArrows C 3\nœÜ : Quiver.Hom R‚ÇÅ R‚ÇÇ\nhR‚ÇÅ : Eq (R‚ÇÅ.map' 0 2 ‚ãØ ‚ãØ) 0\nhR‚ÇÅ' : (CategoryTheory.ComposableArrows.mk‚ÇÇ (R‚ÇÅ.map' 1 2 ‚ãØ ‚ãØ) (R‚ÇÅ.map' 2 3 ‚ãØ ‚ãØ)).Exact\nhR‚ÇÇ : (CategoryTheory.ComposableArrows.mk‚ÇÇ (R‚ÇÇ.map' 0 1 ‚ãØ ‚ãØ) (R‚ÇÇ.map' 1 2 ‚ãØ ‚ãØ)).Exact\nh‚ÇÄ : CategoryTheory.Epi (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ)\nh‚ÇÅ : CategoryTheory.Mono (CategoryTheory.ComposableArrows.app' œÜ 1 ‚ãØ)\nh‚ÇÉ : CategoryTheory.Mono (CategoryTheory.ComposableArrows.app' œÜ 3 ‚ãØ)\n‚ä¢ CategoryTheory.Mono (CategoryTheory.ComposableArrows.app' œÜ 2 ‚ãØ)","decl":"theorem mono_of_epi_of_mono_of_mono' (hR‚ÇÅ : R‚ÇÅ.map' 0 2 = 0)\n    (hR‚ÇÅ' : (mk‚ÇÇ (R‚ÇÅ.map' 1 2) (R‚ÇÅ.map' 2 3)).Exact)\n    (hR‚ÇÇ : (mk‚ÇÇ (R‚ÇÇ.map' 0 1) (R‚ÇÇ.map' 1 2)).Exact)\n    (h‚ÇÄ : Epi (app' œÜ 0)) (h‚ÇÅ : Mono (app' œÜ 1)) (h‚ÇÉ : Mono (app' œÜ 3)) :\n    Mono (app' œÜ 2) := by\n  apply mono_of_cancel_zero\n  intro A f‚ÇÇ h‚ÇÅ\n  have h‚ÇÇ : f‚ÇÇ ‚â´ R‚ÇÅ.map' 2 3 = 0 := by\n    rw [‚Üê cancel_mono (app' œÜ 3 _), assoc, NatTrans.naturality, reassoc_of% h‚ÇÅ,\n      zero_comp, zero_comp]\n  obtain ‚ü®A‚ÇÅ, œÄ‚ÇÅ, _, f‚ÇÅ, hf‚ÇÅ‚ü© := (hR‚ÇÅ'.exact 0).exact_up_to_refinements f‚ÇÇ h‚ÇÇ\n  dsimp at hf‚ÇÅ\n  have h‚ÇÉ : (f‚ÇÅ ‚â´ app' œÜ 1) ‚â´ R‚ÇÇ.map' 1 2 = 0 := by\n    rw [assoc, ‚Üê NatTrans.naturality, ‚Üê reassoc_of% hf‚ÇÅ, h‚ÇÅ, comp_zero]\n  obtain ‚ü®A‚ÇÇ, œÄ‚ÇÇ, _, g‚ÇÄ, hg‚ÇÄ‚ü© := (hR‚ÇÇ.exact 0).exact_up_to_refinements _ h‚ÇÉ\n  obtain ‚ü®A‚ÇÉ, œÄ‚ÇÉ, _, f‚ÇÄ, hf‚ÇÄ‚ü© := surjective_up_to_refinements_of_epi (app' œÜ 0 _) g‚ÇÄ\n  have h‚ÇÑ : f‚ÇÄ ‚â´ R‚ÇÅ.map' 0 1 = œÄ‚ÇÉ ‚â´ œÄ‚ÇÇ ‚â´ f‚ÇÅ := by\n    rw [‚Üê cancel_mono (app' œÜ 1 _), assoc, assoc, assoc, NatTrans.naturality,\n      ‚Üê reassoc_of% hf‚ÇÄ, hg‚ÇÄ]\n    rfl\n  rw [‚Üê cancel_epi œÄ‚ÇÅ, comp_zero, hf‚ÇÅ, ‚Üê cancel_epi œÄ‚ÇÇ, ‚Üê cancel_epi œÄ‚ÇÉ, comp_zero,\n    comp_zero, ‚Üê reassoc_of% h‚ÇÑ, ‚Üê R‚ÇÅ.map'_comp 0 1 2, hR‚ÇÅ, comp_zero]\n\n"}
{"name":"CategoryTheory.Abelian.mono_of_epi_of_mono_of_mono","module":"Mathlib.CategoryTheory.Abelian.DiagramLemmas.Four","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nR‚ÇÅ R‚ÇÇ : CategoryTheory.ComposableArrows C 3\nœÜ : Quiver.Hom R‚ÇÅ R‚ÇÇ\nhR‚ÇÅ : R‚ÇÅ.Exact\nhR‚ÇÇ : R‚ÇÇ.Exact\nh‚ÇÄ : CategoryTheory.Epi (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ)\nh‚ÇÅ : CategoryTheory.Mono (CategoryTheory.ComposableArrows.app' œÜ 1 ‚ãØ)\nh‚ÇÉ : CategoryTheory.Mono (CategoryTheory.ComposableArrows.app' œÜ 3 ‚ãØ)\n‚ä¢ CategoryTheory.Mono (CategoryTheory.ComposableArrows.app' œÜ 2 ‚ãØ)","decl":"theorem mono_of_epi_of_mono_of_mono (hR‚ÇÅ : R‚ÇÅ.Exact) (hR‚ÇÇ : R‚ÇÇ.Exact)\n    (h‚ÇÄ : Epi (app' œÜ 0)) (h‚ÇÅ : Mono (app' œÜ 1)) (h‚ÇÉ : Mono (app' œÜ 3)) :\n    Mono (app' œÜ 2) :=\n  mono_of_epi_of_mono_of_mono' œÜ\n    (by simpa only [R‚ÇÅ.map'_comp 0 1 2] using hR‚ÇÅ.toIsComplex.zero 0)\n    (hR‚ÇÅ.exact 1).exact_toComposableArrows (hR‚ÇÇ.exact 0).exact_toComposableArrows h‚ÇÄ h‚ÇÅ h‚ÇÉ\n\n"}
{"name":"CategoryTheory.Abelian.epi_of_epi_of_epi_of_mono'","module":"Mathlib.CategoryTheory.Abelian.DiagramLemmas.Four","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nR‚ÇÅ R‚ÇÇ : CategoryTheory.ComposableArrows C 3\nœÜ : Quiver.Hom R‚ÇÅ R‚ÇÇ\nhR‚ÇÅ : (CategoryTheory.ComposableArrows.mk‚ÇÇ (R‚ÇÅ.map' 1 2 ‚ãØ ‚ãØ) (R‚ÇÅ.map' 2 3 ‚ãØ ‚ãØ)).Exact\nhR‚ÇÇ : (CategoryTheory.ComposableArrows.mk‚ÇÇ (R‚ÇÇ.map' 0 1 ‚ãØ ‚ãØ) (R‚ÇÇ.map' 1 2 ‚ãØ ‚ãØ)).Exact\nhR‚ÇÇ' : Eq (R‚ÇÇ.map' 1 3 ‚ãØ ‚ãØ) 0\nh‚ÇÄ : CategoryTheory.Epi (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ)\nh‚ÇÇ : CategoryTheory.Epi (CategoryTheory.ComposableArrows.app' œÜ 2 ‚ãØ)\nh‚ÇÉ : CategoryTheory.Mono (CategoryTheory.ComposableArrows.app' œÜ 3 ‚ãØ)\n‚ä¢ CategoryTheory.Epi (CategoryTheory.ComposableArrows.app' œÜ 1 ‚ãØ)","decl":"theorem epi_of_epi_of_epi_of_mono'\n    (hR‚ÇÅ : (mk‚ÇÇ (R‚ÇÅ.map' 1 2) (R‚ÇÅ.map' 2 3)).Exact)\n    (hR‚ÇÇ : (mk‚ÇÇ (R‚ÇÇ.map' 0 1) (R‚ÇÇ.map' 1 2)).Exact) (hR‚ÇÇ' : R‚ÇÇ.map' 1 3 = 0)\n    (h‚ÇÄ : Epi (app' œÜ 0)) (h‚ÇÇ : Epi (app' œÜ 2)) (h‚ÇÉ : Mono (app' œÜ 3)) :\n    Epi (app' œÜ 1) := by\n  rw [epi_iff_surjective_up_to_refinements]\n  intro A g‚ÇÅ\n  obtain ‚ü®A‚ÇÅ, œÄ‚ÇÅ, _, f‚ÇÇ, h‚ÇÅ‚ü© :=\n    surjective_up_to_refinements_of_epi (app' œÜ 2 _) (g‚ÇÅ ‚â´ R‚ÇÇ.map' 1 2)\n  have h‚ÇÇ : f‚ÇÇ ‚â´ R‚ÇÅ.map' 2 3 = 0 := by\n    rw [‚Üê cancel_mono (app' œÜ 3 _), assoc, zero_comp, NatTrans.naturality, ‚Üê reassoc_of% h‚ÇÅ,\n      ‚Üê R‚ÇÇ.map'_comp 1 2 3, hR‚ÇÇ', comp_zero, comp_zero]\n  obtain ‚ü®A‚ÇÇ, œÄ‚ÇÇ, _, f‚ÇÅ, h‚ÇÉ‚ü© := (hR‚ÇÅ.exact 0).exact_up_to_refinements _ h‚ÇÇ\n  dsimp at f‚ÇÅ h‚ÇÉ\n  have h‚ÇÑ : (œÄ‚ÇÇ ‚â´ œÄ‚ÇÅ ‚â´ g‚ÇÅ - f‚ÇÅ ‚â´ app' œÜ 1 _) ‚â´ R‚ÇÇ.map' 1 2 = 0 := by\n    rw [sub_comp, assoc, assoc, assoc, ‚Üê NatTrans.naturality, ‚Üê reassoc_of% h‚ÇÉ, h‚ÇÅ, sub_self]\n  obtain ‚ü®A‚ÇÉ, œÄ‚ÇÉ, _, g‚ÇÄ, h‚ÇÖ‚ü© := (hR‚ÇÇ.exact 0).exact_up_to_refinements _ h‚ÇÑ\n  dsimp at g‚ÇÄ h‚ÇÖ\n  rw [comp_sub] at h‚ÇÖ\n  obtain ‚ü®A‚ÇÑ, œÄ‚ÇÑ, _, f‚ÇÄ, h‚ÇÜ‚ü© := surjective_up_to_refinements_of_epi (app' œÜ 0 _) g‚ÇÄ\n  refine ‚ü®A‚ÇÑ, œÄ‚ÇÑ ‚â´ œÄ‚ÇÉ ‚â´ œÄ‚ÇÇ ‚â´ œÄ‚ÇÅ, inferInstance,\n    œÄ‚ÇÑ ‚â´ œÄ‚ÇÉ ‚â´ f‚ÇÅ + f‚ÇÄ ‚â´ (by exact R‚ÇÅ.map' 0 1), ?_‚ü©\n  rw [assoc, assoc, assoc, add_comp, assoc, assoc, assoc, NatTrans.naturality,\n    ‚Üê reassoc_of% h‚ÇÜ, ‚Üê h‚ÇÖ, comp_sub]\n  dsimp\n  rw [add_sub_cancel]\n\n"}
{"name":"CategoryTheory.Abelian.epi_of_epi_of_epi_of_mono","module":"Mathlib.CategoryTheory.Abelian.DiagramLemmas.Four","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nR‚ÇÅ R‚ÇÇ : CategoryTheory.ComposableArrows C 3\nœÜ : Quiver.Hom R‚ÇÅ R‚ÇÇ\nhR‚ÇÅ : R‚ÇÅ.Exact\nhR‚ÇÇ : R‚ÇÇ.Exact\nh‚ÇÄ : CategoryTheory.Epi (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ)\nh‚ÇÇ : CategoryTheory.Epi (CategoryTheory.ComposableArrows.app' œÜ 2 ‚ãØ)\nh‚ÇÉ : CategoryTheory.Mono (CategoryTheory.ComposableArrows.app' œÜ 3 ‚ãØ)\n‚ä¢ CategoryTheory.Epi (CategoryTheory.ComposableArrows.app' œÜ 1 ‚ãØ)","decl":"theorem epi_of_epi_of_epi_of_mono (hR‚ÇÅ : R‚ÇÅ.Exact) (hR‚ÇÇ : R‚ÇÇ.Exact)\n    (h‚ÇÄ : Epi (app' œÜ 0)) (h‚ÇÇ : Epi (app' œÜ 2)) (h‚ÇÉ : Mono (app' œÜ 3)) :\n    Epi (app' œÜ 1) :=\n  epi_of_epi_of_epi_of_mono' œÜ (hR‚ÇÅ.exact 1).exact_toComposableArrows\n    (hR‚ÇÇ.exact 0).exact_toComposableArrows\n    (by simpa only [R‚ÇÇ.map'_comp 1 2 3] using hR‚ÇÇ.toIsComplex.zero 1) h‚ÇÄ h‚ÇÇ h‚ÇÉ\n\n"}
{"name":"CategoryTheory.Abelian.isIso_of_epi_of_isIso_of_isIso_of_mono","module":"Mathlib.CategoryTheory.Abelian.DiagramLemmas.Four","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nR‚ÇÅ R‚ÇÇ : CategoryTheory.ComposableArrows C 4\nhR‚ÇÅ : R‚ÇÅ.Exact\nhR‚ÇÇ : R‚ÇÇ.Exact\nœÜ : Quiver.Hom R‚ÇÅ R‚ÇÇ\nh‚ÇÄ : CategoryTheory.Epi (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ)\nh‚ÇÅ : CategoryTheory.IsIso (CategoryTheory.ComposableArrows.app' œÜ 1 ‚ãØ)\nh‚ÇÇ : CategoryTheory.IsIso (CategoryTheory.ComposableArrows.app' œÜ 3 ‚ãØ)\nh‚ÇÉ : CategoryTheory.Mono (CategoryTheory.ComposableArrows.app' œÜ 4 ‚ãØ)\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.ComposableArrows.app' œÜ 2 ‚ãØ)","decl":"/-- The five lemma. -/\ntheorem isIso_of_epi_of_isIso_of_isIso_of_mono (h‚ÇÄ : Epi (app' œÜ 0)) (h‚ÇÅ : IsIso (app' œÜ 1))\n    (h‚ÇÇ : IsIso (app' œÜ 3)) (h‚ÇÉ : Mono (app' œÜ 4)) : IsIso (app' œÜ 2) := by\n  dsimp at h‚ÇÄ h‚ÇÅ h‚ÇÇ h‚ÇÉ\n  have : Mono (app' œÜ 2) := by\n    apply mono_of_epi_of_mono_of_mono (Œ¥lastFunctor.map œÜ) (R‚ÇÅ.exact_iff_Œ¥last.1 hR‚ÇÅ).1\n      (R‚ÇÇ.exact_iff_Œ¥last.1 hR‚ÇÇ).1 <;> dsimp <;> infer_instance\n  have : Epi (app' œÜ 2) := by\n    apply epi_of_epi_of_epi_of_mono (Œ¥‚ÇÄFunctor.map œÜ) (R‚ÇÅ.exact_iff_Œ¥‚ÇÄ.1 hR‚ÇÅ).2\n      (R‚ÇÇ.exact_iff_Œ¥‚ÇÄ.1 hR‚ÇÇ).2 <;> dsimp <;> infer_instance\n  apply isIso_of_mono_of_epi\n\n"}
{"name":"CategoryTheory.Abelian.mono_of_epi_of_epi_mono'","module":"Mathlib.CategoryTheory.Abelian.DiagramLemmas.Four","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nR‚ÇÅ R‚ÇÇ : CategoryTheory.ComposableArrows C 2\nœÜ : Quiver.Hom R‚ÇÅ R‚ÇÇ\nhR‚ÇÅ : Eq (R‚ÇÅ.map' 0 2 ‚ãØ ‚ãØ) 0\nhR‚ÇÅ' : CategoryTheory.Epi (R‚ÇÅ.map' 1 2 ‚ãØ ‚ãØ)\nhR‚ÇÇ : R‚ÇÇ.Exact\nh‚ÇÄ : CategoryTheory.Epi (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ)\nh‚ÇÅ : CategoryTheory.Mono (CategoryTheory.ComposableArrows.app' œÜ 1 ‚ãØ)\n‚ä¢ CategoryTheory.Mono (CategoryTheory.ComposableArrows.app' œÜ 2 ‚ãØ)","decl":"theorem mono_of_epi_of_epi_mono' (hR‚ÇÅ : R‚ÇÅ.map' 0 2 = 0) (hR‚ÇÅ' : Epi (R‚ÇÅ.map' 1 2))\n    (hR‚ÇÇ : R‚ÇÇ.Exact) (h‚ÇÄ : Epi (app' œÜ 0)) (h‚ÇÅ : Mono (app' œÜ 1)) :\n    Mono (app' œÜ 2) := by\n  let œà : mk‚ÇÉ (R‚ÇÅ.map' 0 1) (R‚ÇÅ.map' 1 2) (0 : _ ‚ü∂ R‚ÇÅ.obj' 0) ‚ü∂\n    mk‚ÇÉ (R‚ÇÇ.map' 0 1) (R‚ÇÇ.map' 1 2) (0 : _ ‚ü∂ R‚ÇÅ.obj' 0) := homMk‚ÇÉ (app' œÜ 0) (app' œÜ 1)\n      (app' œÜ 2) (ùüô _) (naturality' œÜ 0 1) (naturality' œÜ 1 2) (by simp)\n  refine mono_of_epi_of_mono_of_mono' œà ?_ (exact‚ÇÇ_mk _ (by simp) ?_)\n    (hR‚ÇÇ.exact 0).exact_toComposableArrows h‚ÇÄ h‚ÇÅ (by dsimp [œà]; infer_instance)\n  ¬∑ dsimp\n    rw [‚Üê Functor.map_comp]\n    exact hR‚ÇÅ\n  ¬∑ rw [ShortComplex.exact_iff_epi _ (by simp)]\n    exact hR‚ÇÅ'\n\n"}
{"name":"CategoryTheory.Abelian.mono_of_epi_of_epi_of_mono","module":"Mathlib.CategoryTheory.Abelian.DiagramLemmas.Four","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nR‚ÇÅ R‚ÇÇ : CategoryTheory.ComposableArrows C 2\nœÜ : Quiver.Hom R‚ÇÅ R‚ÇÇ\nhR‚ÇÅ : R‚ÇÅ.Exact\nhR‚ÇÇ : R‚ÇÇ.Exact\nhR‚ÇÅ' : CategoryTheory.Epi (R‚ÇÅ.map' 1 2 ‚ãØ ‚ãØ)\nh‚ÇÄ : CategoryTheory.Epi (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ)\nh‚ÇÅ : CategoryTheory.Mono (CategoryTheory.ComposableArrows.app' œÜ 1 ‚ãØ)\n‚ä¢ CategoryTheory.Mono (CategoryTheory.ComposableArrows.app' œÜ 2 ‚ãØ)","decl":"theorem mono_of_epi_of_epi_of_mono (hR‚ÇÅ : R‚ÇÅ.Exact) (hR‚ÇÇ : R‚ÇÇ.Exact)\n    (hR‚ÇÅ' : Epi (R‚ÇÅ.map' 1 2)) (h‚ÇÄ : Epi (app' œÜ 0)) (h‚ÇÅ : Mono (app' œÜ 1)) :\n    Mono (app' œÜ 2) :=\n  mono_of_epi_of_epi_mono' œÜ (by simpa only [map'_comp R‚ÇÅ 0 1 2] using hR‚ÇÅ.toIsComplex.zero 0)\n    hR‚ÇÅ' hR‚ÇÇ h‚ÇÄ h‚ÇÅ\n\n"}
{"name":"CategoryTheory.Abelian.epi_of_mono_of_epi_of_mono'","module":"Mathlib.CategoryTheory.Abelian.DiagramLemmas.Four","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nR‚ÇÅ R‚ÇÇ : CategoryTheory.ComposableArrows C 2\nœÜ : Quiver.Hom R‚ÇÅ R‚ÇÇ\nhR‚ÇÅ : R‚ÇÅ.Exact\nhR‚ÇÇ : Eq (R‚ÇÇ.map' 0 2 ‚ãØ ‚ãØ) 0\nhR‚ÇÇ' : CategoryTheory.Mono (R‚ÇÇ.map' 0 1 ‚ãØ ‚ãØ)\nh‚ÇÄ : CategoryTheory.Epi (CategoryTheory.ComposableArrows.app' œÜ 1 ‚ãØ)\nh‚ÇÅ : CategoryTheory.Mono (CategoryTheory.ComposableArrows.app' œÜ 2 ‚ãØ)\n‚ä¢ CategoryTheory.Epi (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ)","decl":"theorem epi_of_mono_of_epi_of_mono' (hR‚ÇÅ : R‚ÇÅ.Exact) (hR‚ÇÇ : R‚ÇÇ.map' 0 2 = 0)\n    (hR‚ÇÇ' : Mono (R‚ÇÇ.map' 0 1)) (h‚ÇÄ : Epi (app' œÜ 1)) (h‚ÇÅ : Mono (app' œÜ 2)) :\n    Epi (app' œÜ 0) := by\n  let œà : mk‚ÇÉ (0 : R‚ÇÅ.obj' 0 ‚ü∂ _) (R‚ÇÅ.map' 0 1) (R‚ÇÅ.map' 1 2) ‚ü∂\n    mk‚ÇÉ (0 : R‚ÇÅ.obj' 0 ‚ü∂ _) (R‚ÇÇ.map' 0 1) (R‚ÇÇ.map' 1 2) := homMk‚ÇÉ (ùüô _) (app' œÜ 0) (app' œÜ 1)\n      (app' œÜ 2) (by simp) (naturality' œÜ 0 1) (naturality' œÜ 1 2)\n  refine epi_of_epi_of_epi_of_mono' œà (hR‚ÇÅ.exact 0).exact_toComposableArrows\n    (exact‚ÇÇ_mk _ (by simp) ?_) ?_ (by dsimp [œà]; infer_instance) h‚ÇÄ h‚ÇÅ\n  ¬∑ rw [ShortComplex.exact_iff_mono _ (by simp)]\n    exact hR‚ÇÇ'\n  ¬∑ dsimp\n    rw [‚Üê Functor.map_comp]\n    exact hR‚ÇÇ\n\n"}
{"name":"CategoryTheory.Abelian.epi_of_mono_of_epi_of_mono","module":"Mathlib.CategoryTheory.Abelian.DiagramLemmas.Four","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nR‚ÇÅ R‚ÇÇ : CategoryTheory.ComposableArrows C 2\nœÜ : Quiver.Hom R‚ÇÅ R‚ÇÇ\nhR‚ÇÅ : R‚ÇÅ.Exact\nhR‚ÇÇ : R‚ÇÇ.Exact\nhR‚ÇÇ' : CategoryTheory.Mono (R‚ÇÇ.map' 0 1 ‚ãØ ‚ãØ)\nh‚ÇÄ : CategoryTheory.Epi (CategoryTheory.ComposableArrows.app' œÜ 1 ‚ãØ)\nh‚ÇÅ : CategoryTheory.Mono (CategoryTheory.ComposableArrows.app' œÜ 2 ‚ãØ)\n‚ä¢ CategoryTheory.Epi (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ)","decl":"theorem epi_of_mono_of_epi_of_mono (hR‚ÇÅ : R‚ÇÅ.Exact) (hR‚ÇÇ : R‚ÇÇ.Exact)\n    (hR‚ÇÇ' : Mono (R‚ÇÇ.map' 0 1)) (h‚ÇÄ : Epi (app' œÜ 1)) (h‚ÇÅ : Mono (app' œÜ 2)) :\n    Epi (app' œÜ 0) :=\n  epi_of_mono_of_epi_of_mono' œÜ hR‚ÇÅ\n    (by simpa only [map'_comp R‚ÇÇ 0 1 2] using hR‚ÇÇ.toIsComplex.zero 0) hR‚ÇÇ' h‚ÇÄ h‚ÇÅ\n\n"}
{"name":"CategoryTheory.Abelian.mono_of_mono_of_mono_of_mono","module":"Mathlib.CategoryTheory.Abelian.DiagramLemmas.Four","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nR‚ÇÅ R‚ÇÇ : CategoryTheory.ComposableArrows C 2\nœÜ : Quiver.Hom R‚ÇÅ R‚ÇÇ\nhR‚ÇÅ : R‚ÇÅ.Exact\nhR‚ÇÇ' : CategoryTheory.Mono (R‚ÇÇ.map' 0 1 ‚ãØ ‚ãØ)\nh‚ÇÄ : CategoryTheory.Mono (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ)\nh‚ÇÅ : CategoryTheory.Mono (CategoryTheory.ComposableArrows.app' œÜ 2 ‚ãØ)\n‚ä¢ CategoryTheory.Mono (CategoryTheory.ComposableArrows.app' œÜ 1 ‚ãØ)","decl":"theorem mono_of_mono_of_mono_of_mono (hR‚ÇÅ : R‚ÇÅ.Exact)\n    (hR‚ÇÇ' : Mono (R‚ÇÇ.map' 0 1))\n    (h‚ÇÄ : Mono (app' œÜ 0))\n    (h‚ÇÅ : Mono (app' œÜ 2)) :\n    Mono (app' œÜ 1) := by\n  let œà : mk‚ÇÉ (0 : R‚ÇÅ.obj' 0 ‚ü∂ _) (R‚ÇÅ.map' 0 1) (R‚ÇÅ.map' 1 2) ‚ü∂\n    mk‚ÇÉ (0 : R‚ÇÅ.obj' 0 ‚ü∂ _) (R‚ÇÇ.map' 0 1) (R‚ÇÇ.map' 1 2) := homMk‚ÇÉ (ùüô _) (app' œÜ 0) (app' œÜ 1)\n      (app' œÜ 2) (by simp) (naturality' œÜ 0 1) (naturality' œÜ 1 2)\n  refine mono_of_epi_of_mono_of_mono' œà (by simp)\n    (hR‚ÇÅ.exact 0).exact_toComposableArrows\n    (exact‚ÇÇ_mk _ (by simp) ?_) (by dsimp [œà]; infer_instance) h‚ÇÄ h‚ÇÅ\n  rw [ShortComplex.exact_iff_mono _ (by simp)]\n  exact hR‚ÇÇ'\n\n"}
{"name":"CategoryTheory.Abelian.epi_of_epi_of_epi_of_epi","module":"Mathlib.CategoryTheory.Abelian.DiagramLemmas.Four","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nR‚ÇÅ R‚ÇÇ : CategoryTheory.ComposableArrows C 2\nœÜ : Quiver.Hom R‚ÇÅ R‚ÇÇ\nhR‚ÇÇ : R‚ÇÇ.Exact\nhR‚ÇÅ' : CategoryTheory.Epi (R‚ÇÅ.map' 1 2 ‚ãØ ‚ãØ)\nh‚ÇÄ : CategoryTheory.Epi (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ)\nh‚ÇÅ : CategoryTheory.Epi (CategoryTheory.ComposableArrows.app' œÜ 2 ‚ãØ)\n‚ä¢ CategoryTheory.Epi (CategoryTheory.ComposableArrows.app' œÜ 1 ‚ãØ)","decl":"theorem epi_of_epi_of_epi_of_epi (hR‚ÇÇ : R‚ÇÇ.Exact) (hR‚ÇÅ' : Epi (R‚ÇÅ.map' 1 2))\n    (h‚ÇÄ : Epi (app' œÜ 0)) (h‚ÇÅ : Epi (app' œÜ 2)) :\n    Epi (app' œÜ 1) := by\n  let œà : mk‚ÇÉ (R‚ÇÅ.map' 0 1) (R‚ÇÅ.map' 1 2) (0 : _ ‚ü∂ R‚ÇÅ.obj' 0) ‚ü∂\n    mk‚ÇÉ (R‚ÇÇ.map' 0 1) (R‚ÇÇ.map' 1 2) (0 : _ ‚ü∂ R‚ÇÅ.obj' 0) := homMk‚ÇÉ (app' œÜ 0) (app' œÜ 1)\n      (app' œÜ 2) (ùüô _) (naturality' œÜ 0 1) (naturality' œÜ 1 2) (by simp)\n  refine epi_of_epi_of_epi_of_mono' œà (exact‚ÇÇ_mk _ (by simp) ?_)\n    (hR‚ÇÇ.exact 0).exact_toComposableArrows (by simp)\n    h‚ÇÄ h‚ÇÅ (by dsimp [œà]; infer_instance)\n  rw [ShortComplex.exact_iff_epi _ (by simp)]\n  exact hR‚ÇÅ'\n\n"}
