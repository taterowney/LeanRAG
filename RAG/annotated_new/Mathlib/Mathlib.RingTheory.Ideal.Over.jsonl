{"name":"Ideal.comap_map_eq_self_iff_of_isPrime","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\nS : Type u_2\ninstâœÂ¹ : CommRing S\nf : RingHom R S\np : Ideal R\ninstâœ : p.IsPrime\nâŠ¢ Iff (Eq (Ideal.comap f (Ideal.map f p)) p) (Exists fun q => And q.IsPrime (Eq (Ideal.comap f q) p))","decl":"/-- For a prime ideal `p` of `R`, `p` extended to `S` and\nrestricted back to `R` is `p` if and only if `p` is the restriction of a prime in `S`. -/\nlemma comap_map_eq_self_iff_of_isPrime (p : Ideal R) [p.IsPrime] :\n    (p.map f).comap f = p â†” (âˆƒ (q : Ideal S), q.IsPrime âˆ§ q.comap f = p) := by\n  refine âŸ¨fun hp â†¦ ?_, ?_âŸ©\n  Â· obtain âŸ¨q, hqâ‚, hqâ‚‚, hqâ‚ƒâŸ© := Ideal.exists_le_prime_disjoint _ _\n      (disjoint_map_primeCompl_iff_comap_le.mpr hp.le)\n    exact âŸ¨q, hqâ‚, le_antisymm (disjoint_map_primeCompl_iff_comap_le.mp hqâ‚ƒ)\n      (map_le_iff_le_comap.mp hqâ‚‚)âŸ©\n  Â· rintro âŸ¨q, hq, rflâŸ©\n    simp\n\n"}
{"name":"Ideal.coeff_zero_mem_comap_of_root_mem_of_eval_mem","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœÂ¹ : CommRing R\nS : Type u_2\ninstâœ : CommRing S\nf : RingHom R S\nI : Ideal S\nr : S\nhr : Membership.mem I r\np : Polynomial R\nhp : Membership.mem I (Polynomial.evalâ‚‚ f r p)\nâŠ¢ Membership.mem (Ideal.comap f I) (p.coeff 0)","decl":"theorem coeff_zero_mem_comap_of_root_mem_of_eval_mem {r : S} (hr : r âˆˆ I) {p : R[X]}\n    (hp : p.evalâ‚‚ f r âˆˆ I) : p.coeff 0 âˆˆ I.comap f := by\n  rw [â† p.divX_mul_X_add, evalâ‚‚_add, evalâ‚‚_C, evalâ‚‚_mul, evalâ‚‚_X] at hp\n  refine mem_comap.mpr ((I.add_mem_iff_right ?_).mp hp)\n  exact I.mul_mem_left _ hr\n\n"}
{"name":"Ideal.coeff_zero_mem_comap_of_root_mem","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœÂ¹ : CommRing R\nS : Type u_2\ninstâœ : CommRing S\nf : RingHom R S\nI : Ideal S\nr : S\nhr : Membership.mem I r\np : Polynomial R\nhp : Eq (Polynomial.evalâ‚‚ f r p) 0\nâŠ¢ Membership.mem (Ideal.comap f I) (p.coeff 0)","decl":"theorem coeff_zero_mem_comap_of_root_mem {r : S} (hr : r âˆˆ I) {p : R[X]} (hp : p.evalâ‚‚ f r = 0) :\n    p.coeff 0 âˆˆ I.comap f :=\n  coeff_zero_mem_comap_of_root_mem_of_eval_mem hr (hp.symm â–¸ I.zero_mem)\n\n"}
{"name":"Ideal.exists_coeff_ne_zero_mem_comap_of_non_zero_divisor_root_mem","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœÂ¹ : CommRing R\nS : Type u_2\ninstâœ : CommRing S\nf : RingHom R S\nI : Ideal S\nr : S\nr_non_zero_divisor : âˆ€ {x : S}, Eq (HMul.hMul x r) 0 â†’ Eq x 0\nhr : Membership.mem I r\np : Polynomial R\naâœÂ¹ : Ne p 0\naâœ : Eq (Polynomial.evalâ‚‚ f r p) 0\nâŠ¢ Exists fun i => And (Ne (p.coeff i) 0) (Membership.mem (Ideal.comap f I) (p.coeff i))","decl":"theorem exists_coeff_ne_zero_mem_comap_of_non_zero_divisor_root_mem {r : S}\n    (r_non_zero_divisor : âˆ€ {x}, x * r = 0 â†’ x = 0) (hr : r âˆˆ I) {p : R[X]} :\n    p â‰  0 â†’ p.evalâ‚‚ f r = 0 â†’ âˆƒ i, p.coeff i â‰  0 âˆ§ p.coeff i âˆˆ I.comap f := by\n  refine p.recOnHorner ?_ ?_ ?_\n  Â· intro h\n    contradiction\n  Â· intro p a coeff_eq_zero a_ne_zero _ _ hp\n    refine âŸ¨0, ?_, coeff_zero_mem_comap_of_root_mem hr hpâŸ©\n    simp [coeff_eq_zero, a_ne_zero]\n  Â· intro p p_nonzero ih _ hp\n    rw [evalâ‚‚_mul, evalâ‚‚_X] at hp\n    obtain âŸ¨i, hi, memâŸ© := ih p_nonzero (r_non_zero_divisor hp)\n    refine âŸ¨i + 1, ?_, ?_âŸ©\n    Â· simp [hi, mem]\n    Â· simpa [hi] using mem\n\n"}
{"name":"Ideal.injective_quotient_le_comap_map","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœ : CommRing R\nP : Ideal (Polynomial R)\nâŠ¢ Function.Injective â‡‘(Ideal.quotientMap (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P) (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) â‹¯)","decl":"/-- Let `P` be an ideal in `R[x]`.  The map\n`R[x]/P â†’ (R / (P âˆ© R))[x] / (P / (P âˆ© R))`\nis injective.\n-/\ntheorem injective_quotient_le_comap_map (P : Ideal R[X]) :\n    Function.Injective <|\n      Ideal.quotientMap\n        (Ideal.map (Polynomial.mapRingHom (Quotient.mk (P.comap (C : R â†’+* R[X])))) P)\n        (Polynomial.mapRingHom (Ideal.Quotient.mk (P.comap (C : R â†’+* R[X]))))\n        le_comap_map := by\n  refine quotientMap_injective' (le_of_eq ?_)\n  rw [comap_map_of_surjective (mapRingHom (Ideal.Quotient.mk (P.comap (C : R â†’+* R[X]))))\n      (map_surjective (Ideal.Quotient.mk (P.comap (C : R â†’+* R[X]))) Ideal.Quotient.mk_surjective)]\n  refine le_antisymm (sup_le le_rfl ?_) (le_sup_of_le_left le_rfl)\n  refine fun p hp =>\n    polynomial_mem_ideal_of_coeff_mem_ideal P p fun n => Ideal.Quotient.eq_zero_iff_mem.mp ?_\n  simpa only [coeff_map, coe_mapRingHom] using ext_iff.mp (Ideal.mem_bot.mp (mem_comap.mp hp)) n\n\n"}
{"name":"Ideal.quotient_mk_maps_eq","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœ : CommRing R\nP : Ideal (Polynomial R)\nâŠ¢ Eq (((Ideal.Quotient.mk (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P)).comp Polynomial.C).comp (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) ((Ideal.quotientMap (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P) (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) â‹¯).comp ((Ideal.Quotient.mk P).comp Polynomial.C))","decl":"/-- The identity in this lemma asserts that the \"obvious\" square\n```\n    R    â†’ (R / (P âˆ© R))\n    â†“          â†“\nR[x] / P â†’ (R / (P âˆ© R))[x] / (P / (P âˆ© R))\n```\ncommutes.  It is used, for instance, in the proof of `quotient_mk_comp_C_is_integral_of_jacobson`,\nin the file `Mathlib.RingTheory.Jacobson.Polynomial`.\n-/\ntheorem quotient_mk_maps_eq (P : Ideal R[X]) :\n    ((Quotient.mk (map (mapRingHom (Quotient.mk (P.comap (C : R â†’+* R[X])))) P)).comp C).comp\n        (Quotient.mk (P.comap (C : R â†’+* R[X]))) =\n      (Ideal.quotientMap (map (mapRingHom (Quotient.mk (P.comap (C : R â†’+* R[X])))) P)\n            (mapRingHom (Quotient.mk (P.comap (C : R â†’+* R[X])))) le_comap_map).comp\n        ((Quotient.mk P).comp C) := by\n  refine RingHom.ext fun x => ?_\n  repeat' rw [RingHom.coe_comp, Function.comp_apply]\n  rw [quotientMap_mk, coe_mapRingHom, map_C]\n\n"}
{"name":"Ideal.exists_nonzero_mem_of_ne_bot","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœ : CommRing R\nP : Ideal (Polynomial R)\nPb : Ne P Bot.bot\nhP : âˆ€ (x : R), Membership.mem P (Polynomial.C x) â†’ Eq x 0\nâŠ¢ Exists fun p => And (Membership.mem P p) (Ne (Polynomial.map (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)) p) 0)","decl":"/-- This technical lemma asserts the existence of a polynomial `p` in an ideal `P âŠ‚ R[x]`\nthat is non-zero in the quotient `R / (P âˆ© R) [x]`.  The assumptions are equivalent to\n`P â‰  0` and `P âˆ© R = (0)`.\n-/\ntheorem exists_nonzero_mem_of_ne_bot {P : Ideal R[X]} (Pb : P â‰  âŠ¥) (hP : âˆ€ x : R, C x âˆˆ P â†’ x = 0) :\n    âˆƒ p : R[X], p âˆˆ P âˆ§ Polynomial.map (Quotient.mk (P.comap (C : R â†’+* R[X]))) p â‰  0 := by\n  obtain âŸ¨m, hmâŸ© := Submodule.nonzero_mem_of_bot_lt (bot_lt_iff_ne_bot.mpr Pb)\n  refine âŸ¨m, Submodule.coe_mem m, fun pp0 => hm (Submodule.coe_eq_zero.mp ?_)âŸ©\n  refine\n    (injective_iff_map_eq_zero (Polynomial.mapRingHom (Ideal.Quotient.mk\n      (P.comap (C : R â†’+* R[X]))))).mp\n      ?_ _ pp0\n  refine map_injective _ ((Ideal.Quotient.mk (P.comap C)).injective_iff_ker_eq_bot.mpr ?_)\n  rw [mk_ker]\n  exact (Submodule.eq_bot_iff _).mpr fun x hx => hP x (mem_comap.mp hx)\n\n"}
{"name":"Ideal.comap_eq_of_scalar_tower_quotient","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nS : Type u_2\ninstâœÂ³ : CommRing S\np : Ideal R\nP : Ideal S\ninstâœÂ² : Algebra R S\ninstâœÂ¹ : Algebra (HasQuotient.Quotient R p) (HasQuotient.Quotient S P)\ninstâœ : IsScalarTower R (HasQuotient.Quotient R p) (HasQuotient.Quotient S P)\nh : Function.Injective â‡‘(algebraMap (HasQuotient.Quotient R p) (HasQuotient.Quotient S P))\nâŠ¢ Eq (Ideal.comap (algebraMap R S) P) p","decl":"/-- If there is an injective map `R/p â†’ S/P` such that following diagram commutes:\n```\nR   â†’ S\nâ†“     â†“\nR/p â†’ S/P\n```\nthen `P` lies over `p`.\n-/\ntheorem comap_eq_of_scalar_tower_quotient [Algebra R S] [Algebra (R â§¸ p) (S â§¸ P)]\n    [IsScalarTower R (R â§¸ p) (S â§¸ P)] (h : Function.Injective (algebraMap (R â§¸ p) (S â§¸ P))) :\n    comap (algebraMap R S) P = p := by\n  ext x\n  rw [mem_comap, â† Quotient.eq_zero_iff_mem, â† Quotient.eq_zero_iff_mem, Quotient.mk_algebraMap,\n    IsScalarTower.algebraMap_apply R (R â§¸ p) (S â§¸ P), Quotient.algebraMap_eq]\n  constructor\n  Â· intro hx\n    exact (injective_iff_map_eq_zero (algebraMap (R â§¸ p) (S â§¸ P))).mp h _ hx\n  Â· intro hx\n    rw [hx, RingHom.map_zero]\n\n"}
{"name":"Ideal.Quotient.algebraMap_quotient_map_quotient","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\nS : Type u_2\ninstâœÂ¹ : CommRing S\np : Ideal R\ninstâœ : Algebra R S\nx : R\nâŠ¢ Eq ((algebraMap (HasQuotient.Quotient R p) (HasQuotient.Quotient S (Ideal.map (algebraMap R S) p))) ((Ideal.Quotient.mk p) x)) ((Ideal.Quotient.mk (Ideal.map (algebraMap R S) p)) ((algebraMap R S) x))","decl":"@[simp]\ntheorem Quotient.algebraMap_quotient_map_quotient (x : R) :\n    letI f := algebraMap R S\n    algebraMap (R â§¸ p) (S â§¸ map f p) (Ideal.Quotient.mk p x) =\n    Ideal.Quotient.mk (map f p) (f x) :=\n  rfl\n\n"}
{"name":"Ideal.Quotient.mk_smul_mk_quotient_map_quotient","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\nS : Type u_2\ninstâœÂ¹ : CommRing S\np : Ideal R\ninstâœ : Algebra R S\nx : R\ny : S\nâŠ¢ Eq (HSMul.hSMul ((Ideal.Quotient.mk p) x) ((Ideal.Quotient.mk (Ideal.map (algebraMap R S) p)) y)) ((Ideal.Quotient.mk (Ideal.map (algebraMap R S) p)) (HMul.hMul ((algebraMap R S) x) y))","decl":"@[simp]\ntheorem Quotient.mk_smul_mk_quotient_map_quotient (x : R) (y : S) :\n    letI f := algebraMap R S\n    Quotient.mk p x â€¢ Quotient.mk (map f p) y = Quotient.mk (map f p) (f x * y) :=\n  Algebra.smul_def _ _\n\n"}
{"name":"Ideal.Quotient.tower_quotient_map_quotient","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\nS : Type u_2\ninstâœÂ¹ : CommRing S\np : Ideal R\ninstâœ : Algebra R S\nâŠ¢ IsScalarTower R (HasQuotient.Quotient R p) (HasQuotient.Quotient S (Ideal.map (algebraMap R S) p))","decl":"instance Quotient.tower_quotient_map_quotient [Algebra R S] :\n    IsScalarTower R (R â§¸ p) (S â§¸ map (algebraMap R S) p) :=\n  IsScalarTower.of_algebraMap_eq fun x => by\n    rw [Quotient.algebraMap_eq, Quotient.algebraMap_quotient_map_quotient,\n      Quotient.mk_algebraMap]\n\n"}
{"name":"Ideal.QuotientMapQuotient.isNoetherian","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœÂ³ : CommRing R\nS : Type u_2\ninstâœÂ² : CommRing S\ninstâœÂ¹ : Algebra R S\ninstâœ : IsNoetherian R S\nI : Ideal R\nâŠ¢ IsNoetherian (HasQuotient.Quotient R I) (HasQuotient.Quotient S (Ideal.map (algebraMap R S) I))","decl":"instance QuotientMapQuotient.isNoetherian [Algebra R S] [IsNoetherian R S] (I : Ideal R) :\n    IsNoetherian (R â§¸ I) (S â§¸ I.map (algebraMap R S)) :=\n  isNoetherian_of_tower R <|\n    isNoetherian_of_surjective S (Ideal.Quotient.mkâ‚ R _).toLinearMap <|\n      LinearMap.range_eq_top.mpr Ideal.Quotient.mk_surjective\n\n"}
{"name":"Ideal.exists_coeff_ne_zero_mem_comap_of_root_mem","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\nS : Type u_2\ninstâœÂ¹ : CommRing S\nf : RingHom R S\nI : Ideal S\ninstâœ : IsDomain S\nr : S\nr_ne_zero : Ne r 0\nhr : Membership.mem I r\np : Polynomial R\naâœÂ¹ : Ne p 0\naâœ : Eq (Polynomial.evalâ‚‚ f r p) 0\nâŠ¢ Exists fun i => And (Ne (p.coeff i) 0) (Membership.mem (Ideal.comap f I) (p.coeff i))","decl":"theorem exists_coeff_ne_zero_mem_comap_of_root_mem [IsDomain S] {r : S} (r_ne_zero : r â‰  0)\n    (hr : r âˆˆ I) {p : R[X]} :\n    p â‰  0 â†’ p.evalâ‚‚ f r = 0 â†’ âˆƒ i, p.coeff i â‰  0 âˆ§ p.coeff i âˆˆ I.comap f :=\n  exists_coeff_ne_zero_mem_comap_of_non_zero_divisor_root_mem\n    (fun {_} h => Or.resolve_right (mul_eq_zero.mp h) r_ne_zero) hr\n\n"}
{"name":"Ideal.exists_coeff_mem_comap_sdiff_comap_of_root_mem_sdiff","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\nS : Type u_2\ninstâœÂ¹ : CommRing S\nf : RingHom R S\nI J : Ideal S\ninstâœ : I.IsPrime\nhIJ : LE.le I J\nr : S\nhr : Membership.mem (SDiff.sdiff â†‘J â†‘I) r\np : Polynomial R\np_ne_zero : Ne (Polynomial.map (Ideal.Quotient.mk (Ideal.comap f I)) p) 0\nhpI : Membership.mem I (Polynomial.evalâ‚‚ f r p)\nâŠ¢ Exists fun i => Membership.mem (SDiff.sdiff â†‘(Ideal.comap f J) â†‘(Ideal.comap f I)) (p.coeff i)","decl":"theorem exists_coeff_mem_comap_sdiff_comap_of_root_mem_sdiff [IsPrime I] (hIJ : I â‰¤ J) {r : S}\n    (hr : r âˆˆ (J : Set S) \\ I) {p : R[X]} (p_ne_zero : p.map (Quotient.mk (I.comap f)) â‰  0)\n    (hpI : p.evalâ‚‚ f r âˆˆ I) : âˆƒ i, p.coeff i âˆˆ (J.comap f : Set R) \\ I.comap f := by\n  obtain âŸ¨hrJ, hrIâŸ© := hr\n  have rbar_ne_zero : Ideal.Quotient.mk I r â‰  0 := mt (Quotient.mk_eq_zero I).mp hrI\n  have rbar_mem_J : Ideal.Quotient.mk I r âˆˆ J.map (Ideal.Quotient.mk I) := mem_map_of_mem _ hrJ\n  have quotient_f : âˆ€ x âˆˆ I.comap f, (Ideal.Quotient.mk I).comp f x = 0 := by\n    simp [Quotient.eq_zero_iff_mem]\n  have rbar_root :\n    (p.map (Ideal.Quotient.mk (I.comap f))).evalâ‚‚ (Quotient.lift (I.comap f) _ quotient_f)\n        (Ideal.Quotient.mk I r) =\n      0 := by\n    convert Quotient.eq_zero_iff_mem.mpr hpI\n    exact _root_.trans (evalâ‚‚_map _ _ _) (hom_evalâ‚‚ p f (Ideal.Quotient.mk I) r).symm\n  obtain âŸ¨i, ne_zero, memâŸ© :=\n    exists_coeff_ne_zero_mem_comap_of_root_mem rbar_ne_zero rbar_mem_J p_ne_zero rbar_root\n  rw [coeff_map] at ne_zero mem\n  refine âŸ¨i, (mem_quotient_iff_mem hIJ).mp ?_, mt ?_ ne_zeroâŸ©\n  Â· simpa using mem\n  simp [Quotient.eq_zero_iff_mem]\n\n"}
{"name":"Ideal.comap_lt_comap_of_root_mem_sdiff","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\nS : Type u_2\ninstâœÂ¹ : CommRing S\nf : RingHom R S\nI J : Ideal S\ninstâœ : I.IsPrime\nhIJ : LE.le I J\nr : S\nhr : Membership.mem (SDiff.sdiff â†‘J â†‘I) r\np : Polynomial R\np_ne_zero : Ne (Polynomial.map (Ideal.Quotient.mk (Ideal.comap f I)) p) 0\nhp : Membership.mem I (Polynomial.evalâ‚‚ f r p)\nâŠ¢ LT.lt (Ideal.comap f I) (Ideal.comap f J)","decl":"theorem comap_lt_comap_of_root_mem_sdiff [I.IsPrime] (hIJ : I â‰¤ J) {r : S}\n    (hr : r âˆˆ (J : Set S) \\ I) {p : R[X]} (p_ne_zero : p.map (Quotient.mk (I.comap f)) â‰  0)\n    (hp : p.evalâ‚‚ f r âˆˆ I) : I.comap f < J.comap f :=\n  let âŸ¨i, hJ, hIâŸ© := exists_coeff_mem_comap_sdiff_comap_of_root_mem_sdiff hIJ hr p_ne_zero hp\n  SetLike.lt_iff_le_and_exists.mpr âŸ¨comap_mono hIJ, p.coeff i, hJ, hIâŸ©\n\n"}
{"name":"Ideal.mem_of_one_mem","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"S : Type u_2\ninstâœ : CommRing S\nI : Ideal S\nh : Membership.mem I 1\nx : S\nâŠ¢ Membership.mem I x","decl":"theorem mem_of_one_mem (h : (1 : S) âˆˆ I) (x) : x âˆˆ I :=\n  (I.eq_top_iff_one.mpr h).symm â–¸ mem_top\n\n"}
{"name":"Ideal.comap_lt_comap_of_integral_mem_sdiff","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\nS : Type u_2\ninstâœÂ¹ : CommRing S\nI J : Ideal S\ninstâœ : Algebra R S\nhI : I.IsPrime\nhIJ : LE.le I J\nx : S\nmem : Membership.mem (SDiff.sdiff â†‘J â†‘I) x\nintegral : IsIntegral R x\nâŠ¢ LT.lt (Ideal.comap (algebraMap R S) I) (Ideal.comap (algebraMap R S) J)","decl":"theorem comap_lt_comap_of_integral_mem_sdiff [Algebra R S] [hI : I.IsPrime] (hIJ : I â‰¤ J) {x : S}\n    (mem : x âˆˆ (J : Set S) \\ I) (integral : IsIntegral R x) :\n    I.comap (algebraMap R S) < J.comap (algebraMap R S) := by\n  obtain âŸ¨p, p_monic, hpxâŸ© := integral\n  refine comap_lt_comap_of_root_mem_sdiff hIJ mem (map_monic_ne_zero p_monic) ?_\n  convert I.zero_mem\n\n"}
{"name":"Ideal.comap_ne_bot_of_root_mem","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\nS : Type u_2\ninstâœÂ¹ : CommRing S\nf : RingHom R S\nI : Ideal S\ninstâœ : IsDomain S\nr : S\nr_ne_zero : Ne r 0\nhr : Membership.mem I r\np : Polynomial R\np_ne_zero : Ne p 0\nhp : Eq (Polynomial.evalâ‚‚ f r p) 0\nâŠ¢ Ne (Ideal.comap f I) Bot.bot","decl":"theorem comap_ne_bot_of_root_mem [IsDomain S] {r : S} (r_ne_zero : r â‰  0) (hr : r âˆˆ I) {p : R[X]}\n    (p_ne_zero : p â‰  0) (hp : p.evalâ‚‚ f r = 0) : I.comap f â‰  âŠ¥ := fun h =>\n  let âŸ¨_, hi, memâŸ© := exists_coeff_ne_zero_mem_comap_of_root_mem r_ne_zero hr p_ne_zero hp\n  absurd (mem_bot.mp (eq_bot_iff.mp h mem)) hi\n\n"}
{"name":"Ideal.isMaximal_of_isIntegral_of_isMaximal_comap","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nS : Type u_2\ninstâœÂ³ : CommRing S\ninstâœÂ² : Algebra R S\ninstâœÂ¹ : Algebra.IsIntegral R S\nI : Ideal S\ninstâœ : I.IsPrime\nhI : (Ideal.comap (algebraMap R S) I).IsMaximal\nâŠ¢ I.IsMaximal","decl":"theorem isMaximal_of_isIntegral_of_isMaximal_comap [Algebra R S] [Algebra.IsIntegral R S]\n    (I : Ideal S) [I.IsPrime] (hI : IsMaximal (I.comap (algebraMap R S))) : IsMaximal I :=\n  âŸ¨âŸ¨mt comap_eq_top_iff.mpr hI.1.1, fun _ I_lt_J =>\n      let âŸ¨I_le_J, x, hxJ, hxIâŸ© := SetLike.lt_iff_le_and_exists.mp I_lt_J\n      comap_eq_top_iff.1 <|\n        hI.1.2 _ (comap_lt_comap_of_integral_mem_sdiff I_le_J âŸ¨hxJ, hxIâŸ©\n          (Algebra.IsIntegral.isIntegral x))âŸ©âŸ©\n\n"}
{"name":"Ideal.isMaximal_of_isIntegral_of_isMaximal_comap'","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\nS : Type u_2\ninstâœÂ¹ : CommRing S\nf : RingHom R S\nhf : f.IsIntegral\nI : Ideal S\ninstâœ : I.IsPrime\nhI : (Ideal.comap f I).IsMaximal\nâŠ¢ I.IsMaximal","decl":"theorem isMaximal_of_isIntegral_of_isMaximal_comap' (f : R â†’+* S) (hf : f.IsIntegral) (I : Ideal S)\n    [I.IsPrime] (hI : IsMaximal (I.comap f)) : IsMaximal I :=\n  let _ : Algebra R S := f.toAlgebra\n  have : Algebra.IsIntegral R S := âŸ¨hfâŸ©\n  isMaximal_of_isIntegral_of_isMaximal_comap (R := R) (S := S) I hI\n\n"}
{"name":"Ideal.comap_ne_bot_of_algebraic_mem","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœÂ³ : CommRing R\nS : Type u_2\ninstâœÂ² : CommRing S\nI : Ideal S\ninstâœÂ¹ : Algebra R S\ninstâœ : IsDomain S\nx : S\nx_ne_zero : Ne x 0\nx_mem : Membership.mem I x\nhx : IsAlgebraic R x\nâŠ¢ Ne (Ideal.comap (algebraMap R S) I) Bot.bot","decl":"theorem comap_ne_bot_of_algebraic_mem [IsDomain S] {x : S} (x_ne_zero : x â‰  0) (x_mem : x âˆˆ I)\n    (hx : IsAlgebraic R x) : I.comap (algebraMap R S) â‰  âŠ¥ :=\n  let âŸ¨_, p_ne_zero, hpâŸ© := hx\n  comap_ne_bot_of_root_mem x_ne_zero x_mem p_ne_zero hp\n\n"}
{"name":"Ideal.comap_ne_bot_of_integral_mem","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nS : Type u_2\ninstâœÂ³ : CommRing S\nI : Ideal S\ninstâœÂ² : Algebra R S\ninstâœÂ¹ : Nontrivial R\ninstâœ : IsDomain S\nx : S\nx_ne_zero : Ne x 0\nx_mem : Membership.mem I x\nhx : IsIntegral R x\nâŠ¢ Ne (Ideal.comap (algebraMap R S) I) Bot.bot","decl":"theorem comap_ne_bot_of_integral_mem [Nontrivial R] [IsDomain S] {x : S} (x_ne_zero : x â‰  0)\n    (x_mem : x âˆˆ I) (hx : IsIntegral R x) : I.comap (algebraMap R S) â‰  âŠ¥ :=\n  comap_ne_bot_of_algebraic_mem x_ne_zero x_mem hx.isAlgebraic\n\n"}
{"name":"Ideal.eq_bot_of_comap_eq_bot","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœâµ : CommRing R\nS : Type u_2\ninstâœâ´ : CommRing S\nI : Ideal S\ninstâœÂ³ : Algebra R S\ninstâœÂ² : Nontrivial R\ninstâœÂ¹ : IsDomain S\ninstâœ : Algebra.IsIntegral R S\nhI : Eq (Ideal.comap (algebraMap R S) I) Bot.bot\nâŠ¢ Eq I Bot.bot","decl":"theorem eq_bot_of_comap_eq_bot [Nontrivial R] [IsDomain S] [Algebra.IsIntegral R S]\n    (hI : I.comap (algebraMap R S) = âŠ¥) : I = âŠ¥ := by\n  refine eq_bot_iff.2 fun x hx => ?_\n  by_cases hx0 : x = 0\n  Â· exact hx0.symm â–¸ Ideal.zero_mem âŠ¥\n  Â· exact absurd hI (comap_ne_bot_of_integral_mem hx0 hx (Algebra.IsIntegral.isIntegral x))\n\n"}
{"name":"Ideal.isMaximal_comap_of_isIntegral_of_isMaximal","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœÂ³ : CommRing R\nS : Type u_2\ninstâœÂ² : CommRing S\ninstâœÂ¹ : Algebra R S\ninstâœ : Algebra.IsIntegral R S\nI : Ideal S\nhI : I.IsMaximal\nâŠ¢ (Ideal.comap (algebraMap R S) I).IsMaximal","decl":"theorem isMaximal_comap_of_isIntegral_of_isMaximal [Algebra.IsIntegral R S] (I : Ideal S)\n    [hI : I.IsMaximal] : IsMaximal (I.comap (algebraMap R S)) := by\n  refine Ideal.Quotient.maximal_of_isField _ ?_\n  haveI : IsPrime (I.comap (algebraMap R S)) := comap_isPrime _ _\n  exact isField_of_isIntegral_of_isField\n    algebraMap_quotient_injective (by rwa [â† Quotient.maximal_ideal_iff_isField_quotient])\n\n"}
{"name":"Ideal.isMaximal_comap_of_isIntegral_of_isMaximal'","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_3\nS : Type u_4\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\nf : RingHom R S\nhf : f.IsIntegral\nI : Ideal S\ninstâœ : I.IsMaximal\nâŠ¢ (Ideal.comap f I).IsMaximal","decl":"theorem isMaximal_comap_of_isIntegral_of_isMaximal' {R S : Type*} [CommRing R] [CommRing S]\n    (f : R â†’+* S) (hf : f.IsIntegral) (I : Ideal S) [I.IsMaximal] : IsMaximal (I.comap f) :=\n  let _ : Algebra R S := f.toAlgebra\n  have : Algebra.IsIntegral R S := âŸ¨hfâŸ©\n  isMaximal_comap_of_isIntegral_of_isMaximal (R := R) (S := S) I\n\n"}
{"name":"Ideal.IsIntegralClosure.comap_lt_comap","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœâ¸ : CommRing R\nS : Type u_2\ninstâœâ· : CommRing S\ninstâœâ¶ : Algebra R S\nA : Type u_3\ninstâœâµ : CommRing A\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Algebra A S\ninstâœÂ² : IsScalarTower R A S\ninstâœÂ¹ : IsIntegralClosure A R S\nI J : Ideal A\ninstâœ : I.IsPrime\nI_lt_J : LT.lt I J\nâŠ¢ LT.lt (Ideal.comap (algebraMap R A) I) (Ideal.comap (algebraMap R A) J)","decl":"theorem IsIntegralClosure.comap_lt_comap {I J : Ideal A} [I.IsPrime] (I_lt_J : I < J) :\n    I.comap (algebraMap R A) < J.comap (algebraMap R A) :=\n  let âŸ¨I_le_J, x, hxJ, hxIâŸ© := SetLike.lt_iff_le_and_exists.mp I_lt_J\n  comap_lt_comap_of_integral_mem_sdiff I_le_J âŸ¨hxJ, hxIâŸ© (IsIntegralClosure.isIntegral R S x)\n\n"}
{"name":"Ideal.IsIntegralClosure.isMaximal_of_isMaximal_comap","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœâ¸ : CommRing R\nS : Type u_2\ninstâœâ· : CommRing S\ninstâœâ¶ : Algebra R S\nA : Type u_3\ninstâœâµ : CommRing A\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Algebra A S\ninstâœÂ² : IsScalarTower R A S\ninstâœÂ¹ : IsIntegralClosure A R S\nI : Ideal A\ninstâœ : I.IsPrime\nhI : (Ideal.comap (algebraMap R A) I).IsMaximal\nâŠ¢ I.IsMaximal","decl":"theorem IsIntegralClosure.isMaximal_of_isMaximal_comap (I : Ideal A) [I.IsPrime]\n    (hI : IsMaximal (I.comap (algebraMap R A))) : IsMaximal I :=\n  have : Algebra.IsIntegral R A := IsIntegralClosure.isIntegral_algebra R S\n  isMaximal_of_isIntegral_of_isMaximal_comap I hI\n\n"}
{"name":"Ideal.IsIntegralClosure.comap_ne_bot","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœâ¹ : CommRing R\nS : Type u_2\ninstâœâ¸ : CommRing S\ninstâœâ· : Algebra R S\nA : Type u_3\ninstâœâ¶ : CommRing A\ninstâœâµ : Algebra R A\ninstâœâ´ : Algebra A S\ninstâœÂ³ : IsScalarTower R A S\ninstâœÂ² : IsIntegralClosure A R S\ninstâœÂ¹ : IsDomain A\ninstâœ : Nontrivial R\nI : Ideal A\nI_ne_bot : Ne I Bot.bot\nâŠ¢ Ne (Ideal.comap (algebraMap R A) I) Bot.bot","decl":"theorem IsIntegralClosure.comap_ne_bot [Nontrivial R] {I : Ideal A} (I_ne_bot : I â‰  âŠ¥) :\n    I.comap (algebraMap R A) â‰  âŠ¥ :=\n  let âŸ¨x, x_mem, x_ne_zeroâŸ© := I.ne_bot_iff.mp I_ne_bot\n  comap_ne_bot_of_integral_mem x_ne_zero x_mem (IsIntegralClosure.isIntegral R S x)\n\n"}
{"name":"Ideal.IsIntegralClosure.eq_bot_of_comap_eq_bot","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœâ¹ : CommRing R\nS : Type u_2\ninstâœâ¸ : CommRing S\ninstâœâ· : Algebra R S\nA : Type u_3\ninstâœâ¶ : CommRing A\ninstâœâµ : Algebra R A\ninstâœâ´ : Algebra A S\ninstâœÂ³ : IsScalarTower R A S\ninstâœÂ² : IsIntegralClosure A R S\ninstâœÂ¹ : IsDomain A\ninstâœ : Nontrivial R\nI : Ideal A\naâœ : Eq (Ideal.comap (algebraMap R A) I) Bot.bot\nâŠ¢ Eq I Bot.bot","decl":"theorem IsIntegralClosure.eq_bot_of_comap_eq_bot [Nontrivial R] {I : Ideal A} :\n    I.comap (algebraMap R A) = âŠ¥ â†’ I = âŠ¥ := by\n  -- Porting note: `imp_of_not_imp_not` seems not existing\n  contrapose; exact (IsIntegralClosure.comap_ne_bot S)\n\n"}
{"name":"Ideal.IntegralClosure.comap_lt_comap","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœÂ³ : CommRing R\nS : Type u_2\ninstâœÂ² : CommRing S\ninstâœÂ¹ : Algebra R S\nI J : Ideal (Subtype fun x => Membership.mem (integralClosure R S) x)\ninstâœ : I.IsPrime\nI_lt_J : LT.lt I J\nâŠ¢ LT.lt (Ideal.comap (algebraMap R (Subtype fun x => Membership.mem (integralClosure R S) x)) I) (Ideal.comap (algebraMap R (Subtype fun x => Membership.mem (integralClosure R S) x)) J)","decl":"theorem IntegralClosure.comap_lt_comap {I J : Ideal (integralClosure R S)} [I.IsPrime]\n    (I_lt_J : I < J) :\n    I.comap (algebraMap R (integralClosure R S)) < J.comap (algebraMap R (integralClosure R S)) :=\n  IsIntegralClosure.comap_lt_comap S I_lt_J\n\n"}
{"name":"Ideal.IntegralClosure.isMaximal_of_isMaximal_comap","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœÂ³ : CommRing R\nS : Type u_2\ninstâœÂ² : CommRing S\ninstâœÂ¹ : Algebra R S\nI : Ideal (Subtype fun x => Membership.mem (integralClosure R S) x)\ninstâœ : I.IsPrime\nhI : (Ideal.comap (algebraMap R (Subtype fun x => Membership.mem (integralClosure R S) x)) I).IsMaximal\nâŠ¢ I.IsMaximal","decl":"theorem IntegralClosure.isMaximal_of_isMaximal_comap (I : Ideal (integralClosure R S)) [I.IsPrime]\n    (hI : IsMaximal (I.comap (algebraMap R (integralClosure R S)))) : IsMaximal I :=\n  IsIntegralClosure.isMaximal_of_isMaximal_comap S I hI\n\n"}
{"name":"Ideal.IntegralClosure.comap_ne_bot","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nS : Type u_2\ninstâœÂ³ : CommRing S\ninstâœÂ² : Algebra R S\ninstâœÂ¹ : IsDomain S\ninstâœ : Nontrivial R\nI : Ideal (Subtype fun x => Membership.mem (integralClosure R S) x)\nI_ne_bot : Ne I Bot.bot\nâŠ¢ Ne (Ideal.comap (algebraMap R (Subtype fun x => Membership.mem (integralClosure R S) x)) I) Bot.bot","decl":"theorem IntegralClosure.comap_ne_bot [Nontrivial R] {I : Ideal (integralClosure R S)}\n    (I_ne_bot : I â‰  âŠ¥) : I.comap (algebraMap R (integralClosure R S)) â‰  âŠ¥ :=\n  IsIntegralClosure.comap_ne_bot S I_ne_bot\n\n"}
{"name":"Ideal.IntegralClosure.eq_bot_of_comap_eq_bot","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nS : Type u_2\ninstâœÂ³ : CommRing S\ninstâœÂ² : Algebra R S\ninstâœÂ¹ : IsDomain S\ninstâœ : Nontrivial R\nI : Ideal (Subtype fun x => Membership.mem (integralClosure R S) x)\naâœ : Eq (Ideal.comap (algebraMap R (Subtype fun x => Membership.mem (integralClosure R S) x)) I) Bot.bot\nâŠ¢ Eq I Bot.bot","decl":"theorem IntegralClosure.eq_bot_of_comap_eq_bot [Nontrivial R] {I : Ideal (integralClosure R S)} :\n    I.comap (algebraMap R (integralClosure R S)) = âŠ¥ â†’ I = âŠ¥ :=\n  IsIntegralClosure.eq_bot_of_comap_eq_bot S\n\n"}
{"name":"Ideal.exists_ideal_over_prime_of_isIntegral_of_isDomain","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœâµ : CommRing R\nS : Type u_2\ninstâœâ´ : CommRing S\ninstâœÂ³ : Algebra R S\ninstâœÂ² : IsDomain S\ninstâœÂ¹ : Algebra.IsIntegral R S\nP : Ideal R\ninstâœ : P.IsPrime\nhP : LE.le (RingHom.ker (algebraMap R S)) P\nâŠ¢ Exists fun Q => And Q.IsPrime (Eq (Ideal.comap (algebraMap R S) Q) P)","decl":"/-- `comap (algebraMap R S)` is a surjection from the prime spec of `R` to prime spec of `S`.\n`hP : (algebraMap R S).ker â‰¤ P` is a slight generalization of the extension being injective -/\ntheorem exists_ideal_over_prime_of_isIntegral_of_isDomain [Algebra.IsIntegral R S] (P : Ideal R)\n    [IsPrime P] (hP : RingHom.ker (algebraMap R S) â‰¤ P) :\n    âˆƒ Q : Ideal S, IsPrime Q âˆ§ Q.comap (algebraMap R S) = P := by\n  have hP0 : (0 : S) âˆ‰ Algebra.algebraMapSubmonoid S P.primeCompl := by\n    rintro âŸ¨x, âŸ¨hx, x0âŸ©âŸ©\n    exact absurd (hP x0) hx\n  let Râ‚š := Localization P.primeCompl\n  let Sâ‚š := Localization (Algebra.algebraMapSubmonoid S P.primeCompl)\n  letI : IsDomain (Localization (Algebra.algebraMapSubmonoid S P.primeCompl)) :=\n    IsLocalization.isDomain_localization (le_nonZeroDivisors_of_noZeroDivisors hP0)\n  obtain âŸ¨Qâ‚š : Ideal Sâ‚š, Qâ‚š_maximalâŸ© := exists_maximal Sâ‚š\n  let _ : Algebra Râ‚š Sâ‚š := localizationAlgebra P.primeCompl S\n  have : Algebra.IsIntegral Râ‚š Sâ‚š := âŸ¨isIntegral_localizationâŸ©\n  have Qâ‚š_max : IsMaximal (comap _ Qâ‚š) :=\n    isMaximal_comap_of_isIntegral_of_isMaximal (R := Râ‚š) (S := Sâ‚š) Qâ‚š\n  refine âŸ¨comap (algebraMap S Sâ‚š) Qâ‚š, âŸ¨comap_isPrime _ Qâ‚š, ?_âŸ©âŸ©\n  convert Localization.AtPrime.comap_maximalIdeal (I := P)\n  rw [comap_comap, â† IsLocalRing.eq_maximalIdeal Qâ‚š_max,\n    â† IsLocalization.map_comp (P := S) (Q := Sâ‚š) (g := algebraMap R S)\n    (M := P.primeCompl) (T := Algebra.algebraMapSubmonoid S P.primeCompl) (S := Râ‚š)\n    (fun p hp => Algebra.mem_algebraMapSubmonoid_of_mem âŸ¨p, hpâŸ©) ]\n  rfl\n\n"}
{"name":"Ideal.exists_ideal_over_prime_of_isIntegral_of_isPrime","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœâµ : CommRing R\nS : Type u_2\ninstâœâ´ : CommRing S\ninstâœÂ³ : Algebra R S\ninstâœÂ² : Algebra.IsIntegral R S\nP : Ideal R\ninstâœÂ¹ : P.IsPrime\nI : Ideal S\ninstâœ : I.IsPrime\nhIP : LE.le (Ideal.comap (algebraMap R S) I) P\nâŠ¢ Exists fun Q => And (GE.ge Q I) (And Q.IsPrime (Eq (Ideal.comap (algebraMap R S) Q) P))","decl":"/-- More general going-up theorem than `exists_ideal_over_prime_of_isIntegral_of_isDomain`.\nTODO: Version of going-up theorem with arbitrary length chains (by induction on this)?\n  Not sure how best to write an ascending chain in Lean -/\ntheorem exists_ideal_over_prime_of_isIntegral_of_isPrime\n    [Algebra.IsIntegral R S] (P : Ideal R) [IsPrime P]\n    (I : Ideal S) [IsPrime I] (hIP : I.comap (algebraMap R S) â‰¤ P) :\n    âˆƒ Q â‰¥ I, IsPrime Q âˆ§ Q.comap (algebraMap R S) = P := by\n  obtain âŸ¨Q' : Ideal (S â§¸ I), âŸ¨Q'_prime, hQ'âŸ©âŸ© :=\n    @exists_ideal_over_prime_of_isIntegral_of_isDomain (R â§¸ I.comap (algebraMap R S)) _ (S â§¸ I) _\n      Ideal.quotientAlgebra _ _\n      (map (Ideal.Quotient.mk (I.comap (algebraMap R S))) P)\n      (map_isPrime_of_surjective Quotient.mk_surjective (by simp [hIP]))\n      (le_trans (le_of_eq ((RingHom.injective_iff_ker_eq_bot _).1 algebraMap_quotient_injective))\n        bot_le)\n  refine âŸ¨Q'.comap _, le_trans (le_of_eq mk_ker.symm) (ker_le_comap _), âŸ¨comap_isPrime _ Q', ?_âŸ©âŸ©\n  rw [comap_comap]\n  refine _root_.trans ?_ (_root_.trans (congr_arg (comap (Ideal.Quotient.mk\n    (comap (algebraMap R S) I))) hQ') ?_)\n  Â· rw [comap_comap]\n    exact congr_arg (comap Â· Q') (RingHom.ext fun r => rfl)\n  Â· refine _root_.trans (comap_map_of_surjective _ Quotient.mk_surjective _) (sup_eq_left.2 ?_)\n    simpa [â† RingHom.ker_eq_comap_bot] using hIP\n\n"}
{"name":"Ideal.exists_ideal_comap_le_prime","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœÂ³ : CommRing R\nS : Type u_2\ninstâœÂ² : CommRing S\ninstâœÂ¹ : Algebra R S\nP : Ideal R\ninstâœ : P.IsPrime\nI : Ideal S\nhI : LE.le (Ideal.comap (algebraMap R S) I) P\nâŠ¢ Exists fun Q => And (GE.ge Q I) (And Q.IsPrime (LE.le (Ideal.comap (algebraMap R S) Q) P))","decl":"lemma exists_ideal_comap_le_prime (P : Ideal R) [P.IsPrime]\n    (I : Ideal S) (hI : I.comap (algebraMap R S) â‰¤ P) :\n    âˆƒ Q â‰¥ I, Q.IsPrime âˆ§ Q.comap (algebraMap R S) â‰¤ P := by\n  let Sâ‚š := Localization (Algebra.algebraMapSubmonoid S P.primeCompl)\n  let Iâ‚š := I.map (algebraMap S Sâ‚š)\n  have hI' : Disjoint (Algebra.algebraMapSubmonoid S P.primeCompl : Set S) I := by\n    rw [Set.disjoint_iff]\n    rintro _ âŸ¨âŸ¨x, hx : x âˆ‰ P, rflâŸ©, hx'âŸ©\n    exact (hx (hI hx')).elim\n  have : Iâ‚š â‰  âŠ¤ := by\n    rw [Ne, Ideal.eq_top_iff_one, IsLocalization.mem_map_algebraMap_iff\n      (Algebra.algebraMapSubmonoid S P.primeCompl) Sâ‚š, not_exists]\n    simp only [one_mul, IsLocalization.eq_iff_exists (Algebra.algebraMapSubmonoid S P.primeCompl),\n      not_exists]\n    exact fun x c â†¦ hI'.ne_of_mem (mul_mem c.2 x.2.2) (I.mul_mem_left c x.1.2)\n  obtain âŸ¨M, hM, hM'âŸ© := Ideal.exists_le_maximal _ this\n  refine âŸ¨_, Ideal.map_le_iff_le_comap.mp hM', hM.isPrime.comap _, ?_âŸ©\n  intro x hx\n  by_contra hx'\n  exact Set.disjoint_left.mp ((IsLocalization.isPrime_iff_isPrime_disjoint\n    (Algebra.algebraMapSubmonoid S P.primeCompl) Sâ‚š M).mp hM.isPrime).2 âŸ¨_, hx', rflâŸ© hx\n\n"}
{"name":"Ideal.exists_ideal_over_prime_of_isIntegral","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nS : Type u_2\ninstâœÂ³ : CommRing S\ninstâœÂ² : Algebra R S\ninstâœÂ¹ : Algebra.IsIntegral R S\nP : Ideal R\ninstâœ : P.IsPrime\nI : Ideal S\nhIP : LE.le (Ideal.comap (algebraMap R S) I) P\nâŠ¢ Exists fun Q => And (GE.ge Q I) (And Q.IsPrime (Eq (Ideal.comap (algebraMap R S) Q) P))","decl":"theorem exists_ideal_over_prime_of_isIntegral [Algebra.IsIntegral R S] (P : Ideal R) [IsPrime P]\n    (I : Ideal S) (hIP : I.comap (algebraMap R S) â‰¤ P) :\n    âˆƒ Q â‰¥ I, IsPrime Q âˆ§ Q.comap (algebraMap R S) = P := by\n  have âŸ¨P', hP, hP', hP''âŸ© := exists_ideal_comap_le_prime P I hIP\n  obtain âŸ¨Q, hQ, hQ', hQ''âŸ© := exists_ideal_over_prime_of_isIntegral_of_isPrime P P' hP''\n  exact âŸ¨Q, hP.trans hQ, hQ', hQ''âŸ©\n\n"}
{"name":"Ideal.exists_ideal_over_maximal_of_isIntegral","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_1\ninstâœÂ³ : CommRing R\nS : Type u_2\ninstâœÂ² : CommRing S\ninstâœÂ¹ : Algebra R S\ninstâœ : Algebra.IsIntegral R S\nP : Ideal R\nP_max : P.IsMaximal\nhP : LE.le (RingHom.ker (algebraMap R S)) P\nâŠ¢ Exists fun Q => And Q.IsMaximal (Eq (Ideal.comap (algebraMap R S) Q) P)","decl":"/-- `comap (algebraMap R S)` is a surjection from the max spec of `S` to max spec of `R`.\n`hP : (algebraMap R S).ker â‰¤ P` is a slight generalization of the extension being injective -/\ntheorem exists_ideal_over_maximal_of_isIntegral [Algebra.IsIntegral R S]\n    (P : Ideal R) [P_max : IsMaximal P] (hP : RingHom.ker (algebraMap R S) â‰¤ P) :\n    âˆƒ Q : Ideal S, IsMaximal Q âˆ§ Q.comap (algebraMap R S) = P := by\n  obtain âŸ¨Q, -, Q_prime, hQâŸ© := exists_ideal_over_prime_of_isIntegral P âŠ¥ hP\n  exact âŸ¨Q, isMaximal_of_isIntegral_of_isMaximal_comap _ (hQ.symm â–¸ P_max), hQâŸ©\n\n"}
{"name":"Ideal.map_eq_top_iff_of_ker_le","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_3\nS : Type u_4\ninstâœÂ¹ : CommRing R\ninstâœ : CommRing S\nf : RingHom R S\nI : Ideal R\nhfâ‚ : LE.le (RingHom.ker f) I\nhfâ‚‚ : f.IsIntegral\nâŠ¢ Iff (Eq (Ideal.map f I) Top.top) (Eq I Top.top)","decl":"lemma map_eq_top_iff_of_ker_le {R S} [CommRing R] [CommRing S]\n    (f : R â†’+* S) {I : Ideal R} (hfâ‚ : RingHom.ker f â‰¤ I) (hfâ‚‚ : f.IsIntegral) :\n    I.map f = âŠ¤ â†” I = âŠ¤ := by\n  constructor; swap\n  Â· rintro rfl; exact Ideal.map_top _\n  contrapose\n  intro h\n  obtain âŸ¨m, _, hmâŸ© := Ideal.exists_le_maximal I h\n  let _ := f.toAlgebra\n  have : Algebra.IsIntegral _ _ := âŸ¨hfâ‚‚âŸ©\n  obtain âŸ¨m', _, rflâŸ© := exists_ideal_over_maximal_of_isIntegral m (hfâ‚.trans hm)\n  rw [â† map_le_iff_le_comap] at hm\n  exact (hm.trans_lt (lt_top_iff_ne_top.mpr (IsMaximal.ne_top â€¹_â€º))).ne\n\n"}
{"name":"Ideal.map_eq_top_iff","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_3\nS : Type u_4\ninstâœÂ¹ : CommRing R\ninstâœ : CommRing S\nf : RingHom R S\nI : Ideal R\nhfâ‚ : Function.Injective â‡‘f\nhfâ‚‚ : f.IsIntegral\nâŠ¢ Iff (Eq (Ideal.map f I) Top.top) (Eq I Top.top)","decl":"lemma map_eq_top_iff {R S} [CommRing R] [CommRing S]\n    (f : R â†’+* S) {I : Ideal R} (hfâ‚ : Function.Injective f) (hfâ‚‚ : f.IsIntegral) :\n    I.map f = âŠ¤ â†” I = âŠ¤ :=\n  map_eq_top_iff_of_ker_le f (by simp [f.injective_iff_ker_eq_bot.mp hfâ‚]) hfâ‚‚\n\n"}
{"name":"Ideal.under_def","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœÂ² : CommSemiring A\nB : Type u_3\ninstâœÂ¹ : Semiring B\ninstâœ : Algebra A B\nP : Ideal B\nâŠ¢ Eq (Ideal.under A P) (Ideal.comap (algebraMap A B) P)","decl":"theorem under_def : P.under A = Ideal.comap (algebraMap A B) P := rfl\n\n"}
{"name":"Ideal.IsPrime.under","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœÂ² : CommSemiring A\nB : Type u_3\ninstâœÂ¹ : Semiring B\ninstâœ : Algebra A B\nP : Ideal B\nhP : P.IsPrime\nâŠ¢ (Ideal.under A P).IsPrime","decl":"instance IsPrime.under [hP : P.IsPrime] : (P.under A).IsPrime :=\n  hP.comap (algebraMap A B)\n\n"}
{"name":"Ideal.under_smul","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœâµ : CommSemiring A\nB : Type u_3\ninstâœâ´ : Semiring B\ninstâœÂ³ : Algebra A B\nP : Ideal B\nG : Type u_5\ninstâœÂ² : Group G\ninstâœÂ¹ : MulSemiringAction G B\ninstâœ : SMulCommClass G A B\ng : G\nâŠ¢ Eq (Ideal.under A (HSMul.hSMul g P)) (Ideal.under A P)","decl":"@[simp]\nlemma under_smul {G : Type*} [Group G] [MulSemiringAction G B] [SMulCommClass G A B] (g : G) :\n    (g â€¢ P : Ideal B).under A = P.under A := by\n  ext a\n  rw [mem_comap, mem_comap, mem_pointwise_smul_iff_inv_smul_mem, smul_algebraMap]\n\n"}
{"name":"Ideal.under_top","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœÂ² : CommSemiring A\nB : Type u_3\ninstâœÂ¹ : Semiring B\ninstâœ : Algebra A B\nâŠ¢ Eq (Ideal.under A Top.top) Top.top","decl":"variable (B) in\ntheorem under_top : under A (âŠ¤ : Ideal B) = âŠ¤ := comap_top\n\n"}
{"name":"Ideal.LiesOver.over","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœÂ² : CommSemiring A\nB : Type u_3\ninstâœÂ¹ : Semiring B\ninstâœ : Algebra A B\nP : Ideal B\np : Ideal A\nself : P.LiesOver p\nâŠ¢ Eq p (Ideal.under A P)","decl":"/-- `P` lies over `p` if `p` is the preimage of `P` of the `algebraMap`. -/\nclass LiesOver : Prop where\n  over : p = P.under A\n\n"}
{"name":"Ideal.over_under","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœÂ² : CommSemiring A\nB : Type u_3\ninstâœÂ¹ : Semiring B\ninstâœ : Algebra A B\nP : Ideal B\nâŠ¢ P.LiesOver (Ideal.under A P)","decl":"instance over_under : P.LiesOver (P.under A) where over := rfl\n\n"}
{"name":"Ideal.over_def","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœÂ³ : CommSemiring A\nB : Type u_3\ninstâœÂ² : Semiring B\ninstâœÂ¹ : Algebra A B\nP : Ideal B\np : Ideal A\ninstâœ : P.LiesOver p\nâŠ¢ Eq p (Ideal.under A P)","decl":"theorem over_def [P.LiesOver p] : p = P.under A := LiesOver.over\n\n"}
{"name":"Ideal.mem_of_liesOver","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœÂ³ : CommSemiring A\nB : Type u_3\ninstâœÂ² : Semiring B\ninstâœÂ¹ : Algebra A B\nP : Ideal B\np : Ideal A\ninstâœ : P.LiesOver p\nx : A\nâŠ¢ Iff (Membership.mem p x) (Membership.mem P ((algebraMap A B) x))","decl":"theorem mem_of_liesOver [P.LiesOver p] (x : A) : x âˆˆ p â†” algebraMap A B x âˆˆ P := by\n  rw [P.over_def p]\n  rfl\n\n"}
{"name":"Ideal.top_liesOver_top","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœÂ² : CommSemiring A\nB : Type u_3\ninstâœÂ¹ : Semiring B\ninstâœ : Algebra A B\nâŠ¢ Top.top.LiesOver Top.top","decl":"variable (A B) in\ninstance top_liesOver_top : (âŠ¤ : Ideal B).LiesOver (âŠ¤ : Ideal A) where\n  over := (under_top A B).symm\n\n"}
{"name":"Ideal.eq_top_iff_of_liesOver","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœÂ³ : CommSemiring A\nB : Type u_3\ninstâœÂ² : Semiring B\ninstâœÂ¹ : Algebra A B\nP : Ideal B\np : Ideal A\ninstâœ : P.LiesOver p\nâŠ¢ Iff (Eq P Top.top) (Eq p Top.top)","decl":"theorem eq_top_iff_of_liesOver [P.LiesOver p] : P = âŠ¤ â†” p = âŠ¤ := by\n  rw [P.over_def p]\n  exact comap_eq_top_iff.symm\n\n"}
{"name":"Ideal.LiesOver.of_eq_comap","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœâ· : CommSemiring A\nB : Type u_3\nC : Type u_4\ninstâœâ¶ : Semiring B\ninstâœâµ : Semiring C\ninstâœâ´ : Algebra A B\ninstâœÂ³ : Algebra A C\nP : Ideal B\nQ : Ideal C\np : Ideal A\ninstâœÂ² : Q.LiesOver p\nF : Type u_5\ninstâœÂ¹ : FunLike F B C\ninstâœ : AlgHomClass F A B C\nf : F\nh : Eq P (Ideal.comap f Q)\nâŠ¢ P.LiesOver p","decl":"theorem LiesOver.of_eq_comap [Q.LiesOver p] {F : Type*} [FunLike F B C]\n    [AlgHomClass F A B C] (f : F) (h : P = Q.comap f) : P.LiesOver p where\n  over := by\n    rw [h]\n    exact (over_def Q p).trans <|\n      congrFun (congrFun (congrArg comap ((f : B â†’â‚[A] C).comp_algebraMap.symm)) _) Q\n\n"}
{"name":"Ideal.LiesOver.of_eq_map_equiv","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœâ· : CommSemiring A\nB : Type u_3\nC : Type u_4\ninstâœâ¶ : Semiring B\ninstâœâµ : Semiring C\ninstâœâ´ : Algebra A B\ninstâœÂ³ : Algebra A C\nP : Ideal B\nQ : Ideal C\np : Ideal A\ninstâœÂ² : P.LiesOver p\nE : Type u_5\ninstâœÂ¹ : EquivLike E B C\ninstâœ : AlgEquivClass E A B C\nÏƒ : E\nh : Eq Q (Ideal.map Ïƒ P)\nâŠ¢ Q.LiesOver p","decl":"theorem LiesOver.of_eq_map_equiv [P.LiesOver p] {E : Type*} [EquivLike E B C]\n    [AlgEquivClass E A B C] (Ïƒ : E) (h : Q = P.map Ïƒ) : Q.LiesOver p := by\n  rw [â† show _ = P.map Ïƒ from comap_symm (Ïƒ : B â‰ƒ+* C)] at h\n  exact of_eq_comap p (Ïƒ : B â‰ƒâ‚[A] C).symm h\n\n"}
{"name":"Ideal.comap_liesOver","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœâ· : CommSemiring A\nB : Type u_3\nC : Type u_4\ninstâœâ¶ : Semiring B\ninstâœâµ : Semiring C\ninstâœâ´ : Algebra A B\ninstâœÂ³ : Algebra A C\nQ : Ideal C\np : Ideal A\ninstâœÂ² : Q.LiesOver p\nF : Type u_5\ninstâœÂ¹ : FunLike F B C\ninstâœ : AlgHomClass F A B C\nf : F\nâŠ¢ (Ideal.comap f Q).LiesOver p","decl":"instance comap_liesOver [Q.LiesOver p] {F : Type*} [FunLike F B C] [AlgHomClass F A B C]\n    (f : F) : (Q.comap f).LiesOver p :=\n  LiesOver.of_eq_comap p f rfl\n\n"}
{"name":"Ideal.map_equiv_liesOver","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœâ· : CommSemiring A\nB : Type u_3\nC : Type u_4\ninstâœâ¶ : Semiring B\ninstâœâµ : Semiring C\ninstâœâ´ : Algebra A B\ninstâœÂ³ : Algebra A C\nP : Ideal B\np : Ideal A\ninstâœÂ² : P.LiesOver p\nE : Type u_5\ninstâœÂ¹ : EquivLike E B C\ninstâœ : AlgEquivClass E A B C\nÏƒ : E\nâŠ¢ (Ideal.map Ïƒ P).LiesOver p","decl":"instance map_equiv_liesOver [P.LiesOver p] {E : Type*} [EquivLike E B C] [AlgEquivClass E A B C]\n    (Ïƒ : E) : (P.map Ïƒ).LiesOver p :=\n  LiesOver.of_eq_map_equiv p Ïƒ rfl\n\n"}
{"name":"Ideal.under_under","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœâ¶ : CommSemiring A\nB : Type u_3\ninstâœâµ : CommSemiring B\nC : Type u_4\ninstâœâ´ : Semiring C\ninstâœÂ³ : Algebra A B\ninstâœÂ² : Algebra B C\ninstâœÂ¹ : Algebra A C\ninstâœ : IsScalarTower A B C\nğ”“ : Ideal C\nâŠ¢ Eq (Ideal.under A (Ideal.under B ğ”“)) (Ideal.under A ğ”“)","decl":"@[simp]\ntheorem under_under : (ğ”“.under B).under A  = ğ”“.under A := by\n  simp_rw [comap_comap, â† IsScalarTower.algebraMap_eq]\n\n"}
{"name":"Ideal.LiesOver.trans","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœâ¸ : CommSemiring A\nB : Type u_3\ninstâœâ· : CommSemiring B\nC : Type u_4\ninstâœâ¶ : Semiring C\ninstâœâµ : Algebra A B\ninstâœâ´ : Algebra B C\ninstâœÂ³ : Algebra A C\ninstâœÂ² : IsScalarTower A B C\nğ”“ : Ideal C\nP : Ideal B\np : Ideal A\ninstâœÂ¹ : ğ”“.LiesOver P\ninstâœ : P.LiesOver p\nâŠ¢ ğ”“.LiesOver p","decl":"theorem LiesOver.trans [ğ”“.LiesOver P] [P.LiesOver p] : ğ”“.LiesOver p where\n  over := by rw [P.over_def p, ğ”“.over_def P, under_under]\n\n"}
{"name":"Ideal.LiesOver.tower_bot","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœâ¶ : CommSemiring A\nB : Type u_3\ninstâœâµ : CommSemiring B\nC : Type u_4\ninstâœâ´ : Semiring C\ninstâœÂ³ : Algebra A B\ninstâœÂ² : Algebra B C\ninstâœÂ¹ : Algebra A C\ninstâœ : IsScalarTower A B C\nğ”“ : Ideal C\nP : Ideal B\np : Ideal A\nhp : ğ”“.LiesOver p\nhP : ğ”“.LiesOver P\nâŠ¢ P.LiesOver p","decl":"theorem LiesOver.tower_bot [hp : ğ”“.LiesOver p] [hP : ğ”“.LiesOver P] : P.LiesOver p where\n  over := by rw [ğ”“.over_def p, ğ”“.over_def P, under_under]\n\n"}
{"name":"Ideal.under_liesOver_of_liesOver","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœâ· : CommSemiring A\nB : Type u_3\ninstâœâ¶ : CommSemiring B\nC : Type u_4\ninstâœâµ : Semiring C\ninstâœâ´ : Algebra A B\ninstâœÂ³ : Algebra B C\ninstâœÂ² : Algebra A C\ninstâœÂ¹ : IsScalarTower A B C\nğ”“ : Ideal C\np : Ideal A\ninstâœ : ğ”“.LiesOver p\nâŠ¢ (Ideal.under B ğ”“).LiesOver p","decl":"instance under_liesOver_of_liesOver [ğ”“.LiesOver p] : (ğ”“.under B).LiesOver p :=\n  LiesOver.tower_bot ğ”“ (ğ”“.under B) p\n\n"}
{"name":"Ideal.under_bot","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœâ´ : CommRing A\nB : Type u_3\ninstâœÂ³ : Ring B\ninstâœÂ² : Nontrivial B\ninstâœÂ¹ : Algebra A B\ninstâœ : NoZeroSMulDivisors A B\nâŠ¢ Eq (Ideal.under A Bot.bot) Bot.bot","decl":"@[simp]\ntheorem under_bot : under A (âŠ¥ : Ideal B) = âŠ¥ :=\n  comap_bot_of_injective (algebraMap A B) (NoZeroSMulDivisors.algebraMap_injective A B)\n\n"}
{"name":"Ideal.bot_liesOver_bot","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœâ´ : CommRing A\nB : Type u_3\ninstâœÂ³ : Ring B\ninstâœÂ² : Nontrivial B\ninstâœÂ¹ : Algebra A B\ninstâœ : NoZeroSMulDivisors A B\nâŠ¢ Bot.bot.LiesOver Bot.bot","decl":"instance bot_liesOver_bot : (âŠ¥ : Ideal B).LiesOver (âŠ¥ : Ideal A) where\n  over := (under_bot A B).symm\n\n"}
{"name":"Ideal.ne_bot_of_liesOver_of_ne_bot","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœâµ : CommRing A\nB : Type u_3\ninstâœâ´ : Ring B\ninstâœÂ³ : Nontrivial B\ninstâœÂ² : Algebra A B\ninstâœÂ¹ : NoZeroSMulDivisors A B\np : Ideal A\nhp : Ne p Bot.bot\nP : Ideal B\ninstâœ : P.LiesOver p\nâŠ¢ Ne P Bot.bot","decl":"variable {A B} in\ntheorem ne_bot_of_liesOver_of_ne_bot (hp : p â‰  âŠ¥) (P : Ideal B) [P.LiesOver p] : P â‰  âŠ¥ := by\n  contrapose! hp\n  rw [over_def P p, hp, under_bot]\n\n"}
{"name":"Ideal.Quotient.isScalarTower_of_liesOver","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"R : Type u_2\ninstâœâ· : CommSemiring R\nA : Type u_3\nB : Type u_4\ninstâœâ¶ : CommRing A\ninstâœâµ : CommRing B\ninstâœâ´ : Algebra A B\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Algebra R B\ninstâœÂ¹ : IsScalarTower R A B\nP : Ideal B\np : Ideal A\ninstâœ : P.LiesOver p\nâŠ¢ IsScalarTower R (HasQuotient.Quotient A p) (HasQuotient.Quotient B P)","decl":"instance isScalarTower_of_liesOver : IsScalarTower R (A â§¸ p) (B â§¸ P) :=\n  IsScalarTower.of_algebraMap_eq' <|\n    congrArg (algebraMap B (B â§¸ P)).comp (IsScalarTower.algebraMap_eq R A B)\n\n"}
{"name":"Ideal.Quotient.module_finite_of_liesOver","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_3\nB : Type u_4\ninstâœâ´ : CommRing A\ninstâœÂ³ : CommRing B\ninstâœÂ² : Algebra A B\nP : Ideal B\np : Ideal A\ninstâœÂ¹ : P.LiesOver p\ninstâœ : Module.Finite A B\nâŠ¢ Module.Finite (HasQuotient.Quotient A p) (HasQuotient.Quotient B P)","decl":"/-- `B â§¸ P` is a finite `A â§¸ p`-module if `B` is a finite `A`-module. -/\ninstance module_finite_of_liesOver [Module.Finite A B] : Module.Finite (A â§¸ p) (B â§¸ P) :=\n  Module.Finite.of_restrictScalars_finite A (A â§¸ p) (B â§¸ P)\n\n"}
{"name":"Ideal.Quotient.algebra_finiteType_of_liesOver","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_3\nB : Type u_4\ninstâœâ´ : CommRing A\ninstâœÂ³ : CommRing B\ninstâœÂ² : Algebra A B\nP : Ideal B\np : Ideal A\ninstâœÂ¹ : P.LiesOver p\ninstâœ : Algebra.FiniteType A B\nâŠ¢ Algebra.FiniteType (HasQuotient.Quotient A p) (HasQuotient.Quotient B P)","decl":"/-- `B â§¸ P` is a finitely generated `A â§¸ p`-algebra if `B` is a finitely generated `A`-algebra. -/\ninstance algebra_finiteType_of_liesOver [Algebra.FiniteType A B] :\n    Algebra.FiniteType (A â§¸ p) (B â§¸ P) :=\n  Algebra.FiniteType.of_restrictScalars_finiteType A (A â§¸ p) (B â§¸ P)\n\n"}
{"name":"Ideal.Quotient.isNoetherian_of_liesOver","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_3\nB : Type u_4\ninstâœâ´ : CommRing A\ninstâœÂ³ : CommRing B\ninstâœÂ² : Algebra A B\nP : Ideal B\np : Ideal A\ninstâœÂ¹ : P.LiesOver p\ninstâœ : IsNoetherian A B\nâŠ¢ IsNoetherian (HasQuotient.Quotient A p) (HasQuotient.Quotient B P)","decl":"/-- `B â§¸ P` is a Noetherian `A â§¸ p`-module if `B` is a Noetherian `A`-module. -/\ninstance isNoetherian_of_liesOver [IsNoetherian A B] : IsNoetherian (A â§¸ p) (B â§¸ P) :=\n  isNoetherian_of_tower A inferInstance\n\n"}
{"name":"Ideal.Quotient.algebraMap_injective_of_liesOver","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_3\nB : Type u_4\ninstâœÂ³ : CommRing A\ninstâœÂ² : CommRing B\ninstâœÂ¹ : Algebra A B\nP : Ideal B\np : Ideal A\ninstâœ : P.LiesOver p\nâŠ¢ Function.Injective â‡‘(algebraMap (HasQuotient.Quotient A p) (HasQuotient.Quotient B P))","decl":"theorem algebraMap_injective_of_liesOver : Function.Injective (algebraMap (A â§¸ p) (B â§¸ P)) := by\n  rintro âŸ¨aâŸ© âŸ¨bâŸ© hab\n  apply Quotient.eq.mpr ((mem_of_liesOver P p (a - b)).mpr _)\n  rw [RingHom.map_sub]\n  exact Quotient.eq.mp hab\n\n"}
{"name":"Ideal.Quotient.instNoZeroSMulDivisorsQuotientOfIsPrime","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_3\nB : Type u_4\ninstâœâ´ : CommRing A\ninstâœÂ³ : CommRing B\ninstâœÂ² : Algebra A B\nP : Ideal B\np : Ideal A\ninstâœÂ¹ : P.LiesOver p\ninstâœ : P.IsPrime\nâŠ¢ NoZeroSMulDivisors (HasQuotient.Quotient A p) (HasQuotient.Quotient B P)","decl":"instance [P.IsPrime] : NoZeroSMulDivisors (A â§¸ p) (B â§¸ P) :=\n  NoZeroSMulDivisors.of_algebraMap_injective (algebraMap_injective_of_liesOver P p)\n\n"}
{"name":"Ideal.Quotient.nontrivial_of_liesOver_of_ne_top","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_3\nB : Type u_4\ninstâœÂ³ : CommRing A\ninstâœÂ² : CommRing B\ninstâœÂ¹ : Algebra A B\nP : Ideal B\np : Ideal A\ninstâœ : P.LiesOver p\nhp : Ne p Top.top\nâŠ¢ Nontrivial (HasQuotient.Quotient B P)","decl":"variable {p} in\ntheorem nontrivial_of_liesOver_of_ne_top (hp : p â‰  âŠ¤) : Nontrivial (B â§¸ P) :=\n  Quotient.nontrivial ((eq_top_iff_of_liesOver P p).mp.mt hp)\n\n"}
{"name":"Ideal.Quotient.nontrivial_of_liesOver_of_isPrime","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_3\nB : Type u_4\ninstâœÂ³ : CommRing A\ninstâœÂ² : CommRing B\ninstâœÂ¹ : Algebra A B\nP : Ideal B\np : Ideal A\ninstâœ : P.LiesOver p\nhp : p.IsPrime\nâŠ¢ Nontrivial (HasQuotient.Quotient B P)","decl":"theorem nontrivial_of_liesOver_of_isPrime [hp : p.IsPrime] : Nontrivial (B â§¸ P) :=\n  nontrivial_of_liesOver_of_ne_top P hp.ne_top\n\n"}
{"name":"Ideal.Quotient.algEquivOfEqMap_apply","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_3\nB : Type u_4\nC : Type u_5\ninstâœâ¸ : CommRing A\ninstâœâ· : CommRing B\ninstâœâ¶ : CommRing C\ninstâœâµ : Algebra A B\ninstâœâ´ : Algebra A C\nP : Ideal B\nQ : Ideal C\np : Ideal A\ninstâœÂ³ : Q.LiesOver p\ninstâœÂ² : P.LiesOver p\nE : Type u_7\ninstâœÂ¹ : EquivLike E B C\ninstâœ : AlgEquivClass E A B C\nÏƒ : E\nh : Eq Q (Ideal.map Ïƒ P)\nx : B\nâŠ¢ Eq ((Ideal.Quotient.algEquivOfEqMap p Ïƒ h) ((Ideal.Quotient.mk P) x)) ((Ideal.Quotient.mk Q) (Ïƒ x))","decl":"@[simp]\ntheorem algEquivOfEqMap_apply (h : Q = P.map Ïƒ) (x : B) : algEquivOfEqMap p Ïƒ h x = Ïƒ x :=\n  rfl\n\n"}
{"name":"Ideal.Quotient.algEquivOfEqComap_apply","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_3\nB : Type u_4\nC : Type u_5\ninstâœâ¸ : CommRing A\ninstâœâ· : CommRing B\ninstâœâ¶ : CommRing C\ninstâœâµ : Algebra A B\ninstâœâ´ : Algebra A C\nP : Ideal B\nQ : Ideal C\np : Ideal A\ninstâœÂ³ : Q.LiesOver p\ninstâœÂ² : P.LiesOver p\nE : Type u_7\ninstâœÂ¹ : EquivLike E B C\ninstâœ : AlgEquivClass E A B C\nÏƒ : E\nh : Eq P (Ideal.comap Ïƒ Q)\nx : B\nâŠ¢ Eq ((Ideal.Quotient.algEquivOfEqComap p Ïƒ h) ((Ideal.Quotient.mk P) x)) ((Ideal.Quotient.mk Q) (Ïƒ x))","decl":"@[simp]\ntheorem algEquivOfEqComap_apply (h : P = Q.comap Ïƒ) (x : B) : algEquivOfEqComap p Ïƒ h x = Ïƒ x :=\n  rfl\n\n"}
{"name":"Ideal.Quotient.stabilizerHom_apply","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_3\nB : Type u_4\ninstâœâ¶ : CommRing A\ninstâœâµ : CommRing B\ninstâœâ´ : Algebra A B\nP : Ideal B\np : Ideal A\ninstâœÂ³ : P.LiesOver p\nG : Type u_6\ninstâœÂ² : Group G\ninstâœÂ¹ : MulSemiringAction G B\ninstâœ : SMulCommClass G A B\ng : Subtype fun x => Membership.mem (MulAction.stabilizer G P) x\nb : B\nâŠ¢ Eq (((Ideal.Quotient.stabilizerHom P p G) g) ((Ideal.Quotient.mk P) b)) ((Ideal.Quotient.mk P) (HSMul.hSMul g b))","decl":"@[simp] theorem stabilizerHom_apply (g : MulAction.stabilizer G P) (b : B) :\n    stabilizerHom P p G g b = â†‘(g â€¢ b) :=\n  rfl\n\n"}
{"name":"Ideal.IsMaximal.under","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœâ´ : CommRing A\nB : Type u_3\ninstâœÂ³ : CommRing B\ninstâœÂ² : Algebra A B\ninstâœÂ¹ : Algebra.IsIntegral A B\nP : Ideal B\ninstâœ : P.IsMaximal\nâŠ¢ (Ideal.under A P).IsMaximal","decl":"variable (A) in\n/-- If `B` is an integral `A`-algebra, `P` is a maximal ideal of `B`, then the pull back of\n  `P` is also a maximal ideal of `A`. -/\ninstance IsMaximal.under [P.IsMaximal] : (P.under A).IsMaximal :=\n  isMaximal_comap_of_isIntegral_of_isMaximal P\n\n"}
{"name":"Ideal.IsMaximal.of_liesOver_isMaximal","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœâµ : CommRing A\nB : Type u_3\ninstâœâ´ : CommRing B\ninstâœÂ³ : Algebra A B\ninstâœÂ² : Algebra.IsIntegral A B\nP : Ideal B\np : Ideal A\ninstâœÂ¹ : P.LiesOver p\nhpm : p.IsMaximal\ninstâœ : P.IsPrime\nâŠ¢ P.IsMaximal","decl":"theorem IsMaximal.of_liesOver_isMaximal [hpm : p.IsMaximal] [P.IsPrime] : P.IsMaximal := by\n  rw [P.over_def p] at hpm\n  exact isMaximal_of_isIntegral_of_isMaximal_comap P hpm\n\n"}
{"name":"Ideal.IsMaximal.of_isMaximal_liesOver","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœâµ : CommRing A\nB : Type u_3\ninstâœâ´ : CommRing B\ninstâœÂ³ : Algebra A B\ninstâœÂ² : Algebra.IsIntegral A B\nP : Ideal B\np : Ideal A\ninstâœÂ¹ : P.LiesOver p\ninstâœ : P.IsMaximal\nâŠ¢ p.IsMaximal","decl":"theorem IsMaximal.of_isMaximal_liesOver [P.IsMaximal] : p.IsMaximal := by\n  rw [P.over_def p]\n  exact isMaximal_comap_of_isIntegral_of_isMaximal P\n\n"}
{"name":"Ideal.Quotient.algebra_isIntegral_of_liesOver","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœâ´ : CommRing A\nB : Type u_3\ninstâœÂ³ : CommRing B\ninstâœÂ² : Algebra A B\ninstâœÂ¹ : Algebra.IsIntegral A B\nP : Ideal B\np : Ideal A\ninstâœ : P.LiesOver p\nâŠ¢ Algebra.IsIntegral (HasQuotient.Quotient A p) (HasQuotient.Quotient B P)","decl":"/-- `B â§¸ P` is an integral `A â§¸ p`-algebra if `B` is a integral `A`-algebra. -/\ninstance Quotient.algebra_isIntegral_of_liesOver : Algebra.IsIntegral (A â§¸ p) (B â§¸ P) :=\n  Algebra.IsIntegral.tower_top A\n\n"}
{"name":"Ideal.exists_ideal_liesOver_maximal_of_isIntegral","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœâ¶ : CommRing A\np : Ideal A\ninstâœâµ : p.IsMaximal\nB : Type u_4\ninstâœâ´ : CommRing B\ninstâœÂ³ : Nontrivial B\ninstâœÂ² : Algebra A B\ninstâœÂ¹ : NoZeroSMulDivisors A B\ninstâœ : Algebra.IsIntegral A B\nâŠ¢ Exists fun P => And P.IsMaximal (P.LiesOver p)","decl":"theorem exists_ideal_liesOver_maximal_of_isIntegral [p.IsMaximal] (B : Type*) [CommRing B]\n    [Nontrivial B] [Algebra A B] [NoZeroSMulDivisors A B] [Algebra.IsIntegral A B] :\n    âˆƒ P : Ideal B, P.IsMaximal âˆ§ P.LiesOver p := by\n  rcases exists_ideal_over_maximal_of_isIntegral p <|\n    (NoZeroSMulDivisors.ker_algebraMap_eq_bot A B).trans_le bot_le with âŸ¨P, hm, hPâŸ©\n  exact âŸ¨P, hm, âŸ¨hP.symmâŸ©âŸ©\n\n"}
{"name":"primesOver.isPrime","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœÂ² : CommSemiring A\np : Ideal A\nB : Type u_3\ninstâœÂ¹ : Semiring B\ninstâœ : Algebra A B\nQ : â†‘(primesOver p B)\nâŠ¢ (â†‘Q).IsPrime","decl":"instance primesOver.isPrime (Q : primesOver p B) : Q.1.IsPrime :=\n  Q.2.1\n\n"}
{"name":"primesOver.liesOver","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœÂ² : CommSemiring A\np : Ideal A\nB : Type u_3\ninstâœÂ¹ : Semiring B\ninstâœ : Algebra A B\nQ : â†‘(primesOver p B)\nâŠ¢ (â†‘Q).LiesOver p","decl":"instance primesOver.liesOver (Q : primesOver p B) : Q.1.LiesOver p :=\n  Q.2.2\n\n"}
{"name":"primesOver.isMaximal","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœâ´ : CommRing A\np : Ideal A\ninstâœÂ³ : p.IsMaximal\nB : Type u_3\ninstâœÂ² : CommRing B\ninstâœÂ¹ : Algebra A B\ninstâœ : Algebra.IsIntegral A B\nQ : â†‘(primesOver p B)\nâŠ¢ (â†‘Q).IsMaximal","decl":"instance primesOver.isMaximal : Q.1.IsMaximal :=\n  Ideal.IsMaximal.of_liesOver_isMaximal Q.1 p\n\n"}
{"name":"primesOver_bot","module":"Mathlib.RingTheory.Ideal.Over","initialProofState":"A : Type u_2\ninstâœâ¶ : CommRing A\nB : Type u_3\ninstâœâµ : CommRing B\ninstâœâ´ : Algebra A B\ninstâœÂ³ : NoZeroSMulDivisors A B\ninstâœÂ² : Algebra.IsIntegral A B\ninstâœÂ¹ : Nontrivial A\ninstâœ : IsDomain B\nâŠ¢ Eq (primesOver Bot.bot B) (Singleton.singleton Bot.bot)","decl":"variable (A B) in\nlemma primesOver_bot [Nontrivial A] [IsDomain B] : primesOver (âŠ¥ : Ideal A) B = {âŠ¥} := by\n  ext p\n  refine âŸ¨fun âŸ¨_, âŸ¨hâŸ©âŸ© â†¦ p.eq_bot_of_comap_eq_bot h.symm, ?_âŸ©\n  rintro rfl\n  exact âŸ¨Ideal.bot_prime, Ideal.bot_liesOver_bot A BâŸ©\n\n"}
