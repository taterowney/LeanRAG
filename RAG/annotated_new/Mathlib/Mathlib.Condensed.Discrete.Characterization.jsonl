{"name":"CondensedSet.mem_locallyConstant_essImage_of_isColimit_mapCocone","module":"Mathlib.Condensed.Discrete.Characterization","initialProofState":"X : CondensedSet\nh : (S : Profinite) → CategoryTheory.Limits.IsColimit ((profiniteToCompHaus.op.comp X.val).mapCocone S.asLimitCone.op)\n⊢ Membership.mem CondensedSet.LocallyConstant.functor.essImage X","decl":"lemma mem_locallyConstant_essImage_of_isColimit_mapCocone (X : CondensedSet.{u})\n    (h : ∀ S : Profinite.{u}, IsColimit <|\n      (profiniteToCompHaus.op ⋙ X.val).mapCocone S.asLimitCone.op) :\n    X ∈ CondensedSet.LocallyConstant.functor.essImage := by\n  let e : CondensedSet.{u} ≌ Sheaf (coherentTopology Profinite) _ :=\n    (Condensed.ProfiniteCompHaus.equivalence (Type (u + 1))).symm\n  let i : (e.functor.obj X).val ≅ (e.functor.obj (LocallyConstant.functor.obj _)).val :=\n    Condensed.isoLocallyConstantOfIsColimit _ h\n  exact ⟨_, ⟨e.functor.preimageIso ((sheafToPresheaf _ _).preimageIso i.symm)⟩⟩\n\n"}
{"name":"CondensedSet.mem_locallyContant_essImage_of_isColimit_mapCocone","module":"Mathlib.Condensed.Discrete.Characterization","initialProofState":"X : CondensedSet\nh : (S : Profinite) → CategoryTheory.Limits.IsColimit ((profiniteToCompHaus.op.comp X.val).mapCocone S.asLimitCone.op)\n⊢ Membership.mem CondensedSet.LocallyConstant.functor.essImage X","decl":"@[deprecated (since := \"2024-12-25\")]\nalias mem_locallyContant_essImage_of_isColimit_mapCocone :=\n  mem_locallyConstant_essImage_of_isColimit_mapCocone\n\n"}
{"name":"CondensedSet.isDiscrete_tfae","module":"Mathlib.Condensed.Discrete.Characterization","initialProofState":"X : CondensedSet\n⊢ (List.cons (Condensed.IsDiscrete X) (List.cons (CategoryTheory.IsIso ((Condensed.discreteUnderlyingAdj (Type (u + 1))).counit.app X)) (List.cons (Membership.mem (Condensed.discrete (Type (u + 1))).essImage X) (List.cons (Membership.mem CondensedSet.LocallyConstant.functor.essImage X) (List.cons (CategoryTheory.IsIso (CondensedSet.LocallyConstant.adjunction.counit.app X)) (List.cons (CategoryTheory.Sheaf.IsConstant (CategoryTheory.coherentTopology Profinite) ((Condensed.ProfiniteCompHaus.equivalence (Type (u + 1))).inverse.obj X)) (List.cons (∀ (S : Profinite), Nonempty (CategoryTheory.Limits.IsColimit ((profiniteToCompHaus.op.comp X.val).mapCocone S.asLimitCone.op))) List.nil))))))).TFAE","decl":"open CondensedSet.LocallyConstant List in\ntheorem isDiscrete_tfae  (X : CondensedSet.{u}) :\n    TFAE\n    [ X.IsDiscrete\n    , IsIso ((Condensed.discreteUnderlyingAdj _).counit.app X)\n    , X ∈ (Condensed.discrete _).essImage\n    , X ∈ CondensedSet.LocallyConstant.functor.essImage\n    , IsIso (CondensedSet.LocallyConstant.adjunction.counit.app X)\n    , Sheaf.IsConstant (coherentTopology Profinite)\n        ((Condensed.ProfiniteCompHaus.equivalence _).inverse.obj X)\n    , ∀ S : Profinite.{u}, Nonempty\n        (IsColimit <| (profiniteToCompHaus.op ⋙ X.val).mapCocone S.asLimitCone.op)\n    ] := by\n  tfae_have 1 ↔ 2 := Sheaf.isConstant_iff_isIso_counit_app _ _ _\n  tfae_have 1 ↔ 3 := ⟨fun ⟨h⟩ ↦ h, fun h ↦ ⟨h⟩⟩\n  tfae_have 1 ↔ 4 := Sheaf.isConstant_iff_mem_essImage _ CompHaus.isTerminalPUnit adjunction _\n  tfae_have 1 ↔ 5 :=\n    have : functor.Faithful := inferInstance\n    have : functor.Full := inferInstance\n    -- These `have` statements above shouldn't be needed, but they are.\n    Sheaf.isConstant_iff_isIso_counit_app' _ CompHaus.isTerminalPUnit adjunction _\n  tfae_have 1 ↔ 6 :=\n    (Sheaf.isConstant_iff_of_equivalence (coherentTopology Profinite)\n      (coherentTopology CompHaus) profiniteToCompHaus Profinite.isTerminalPUnit\n      CompHaus.isTerminalPUnit _).symm\n  tfae_have 7 → 4 := fun h ↦\n    mem_locallyConstant_essImage_of_isColimit_mapCocone X (fun S ↦ (h S).some)\n  tfae_have 4 → 7 := fun ⟨Y, ⟨i⟩⟩ S ↦\n    ⟨IsColimit.mapCoconeEquiv (isoWhiskerLeft profiniteToCompHaus.op\n      ((sheafToPresheaf _ _).mapIso i))\n      (Condensed.isColimitLocallyConstantPresheafDiagram Y S)⟩\n  tfae_finish\n\n"}
{"name":"CondensedMod.isDiscrete_iff_isDiscrete_forget","module":"Mathlib.Condensed.Discrete.Characterization","initialProofState":"R : Type (u + 1)\ninst✝ : Ring R\nM : CondensedMod R\n⊢ Iff (Condensed.IsDiscrete M) (Condensed.IsDiscrete ((Condensed.forget R).obj M))","decl":"lemma isDiscrete_iff_isDiscrete_forget (M : CondensedMod R) :\n    M.IsDiscrete ↔ ((Condensed.forget R).obj M).IsDiscrete  :=\n  Sheaf.isConstant_iff_forget (coherentTopology CompHaus)\n    (forget (ModuleCat R)) M CompHaus.isTerminalPUnit\n\n"}
{"name":"CondensedMod.instHasLimitsOfSizeModuleCat","module":"Mathlib.Condensed.Discrete.Characterization","initialProofState":"R : Type (u + 1)\ninst✝ : Ring R\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{u, u + 1, u + 1, u + 2} (ModuleCat R)","decl":"instance : HasLimitsOfSize.{u, u+1} (ModuleCat.{u+1} R) :=\n  hasLimitsOfSizeShrink.{u, u+1, u+1, u+1} _\n\n"}
{"name":"CondensedMod.isDiscrete_tfae","module":"Mathlib.Condensed.Discrete.Characterization","initialProofState":"R : Type (u + 1)\ninst✝ : Ring R\nM : CondensedMod R\n⊢ (List.cons (Condensed.IsDiscrete M) (List.cons (CategoryTheory.IsIso ((Condensed.discreteUnderlyingAdj (ModuleCat R)).counit.app M)) (List.cons (Membership.mem (Condensed.discrete (ModuleCat R)).essImage M) (List.cons (Membership.mem (CondensedMod.LocallyConstant.functor R).essImage M) (List.cons (CategoryTheory.IsIso ((CondensedMod.LocallyConstant.adjunction R).counit.app M)) (List.cons (CategoryTheory.Sheaf.IsConstant (CategoryTheory.coherentTopology Profinite) ((Condensed.ProfiniteCompHaus.equivalence (ModuleCat R)).inverse.obj M)) (List.cons (∀ (S : Profinite), Nonempty (CategoryTheory.Limits.IsColimit ((profiniteToCompHaus.op.comp M.val).mapCocone S.asLimitCone.op))) List.nil))))))).TFAE","decl":"open CondensedMod.LocallyConstant List in\ntheorem isDiscrete_tfae  (M : CondensedMod.{u} R) :\n    TFAE\n    [ M.IsDiscrete\n    , IsIso ((Condensed.discreteUnderlyingAdj _).counit.app M)\n    , M ∈ (Condensed.discrete _).essImage\n    , M ∈ (CondensedMod.LocallyConstant.functor R).essImage\n    , IsIso ((CondensedMod.LocallyConstant.adjunction R).counit.app M)\n    , Sheaf.IsConstant (coherentTopology Profinite)\n        ((Condensed.ProfiniteCompHaus.equivalence _).inverse.obj M)\n    , ∀ S : Profinite.{u}, Nonempty\n        (IsColimit <| (profiniteToCompHaus.op ⋙ M.val).mapCocone S.asLimitCone.op)\n    ] := by\n  tfae_have 1 ↔ 2 := Sheaf.isConstant_iff_isIso_counit_app _ _ _\n  tfae_have 1 ↔ 3 := ⟨fun ⟨h⟩ ↦ h, fun h ↦ ⟨h⟩⟩\n  tfae_have 1 ↔ 4 := Sheaf.isConstant_iff_mem_essImage _ CompHaus.isTerminalPUnit (adjunction R) _\n  tfae_have 1 ↔ 5 :=\n    have : (functor R).Faithful := inferInstance\n    have : (functor R).Full := inferInstance\n    -- These `have` statements above shouldn't be needed, but they are.\n    Sheaf.isConstant_iff_isIso_counit_app' _ CompHaus.isTerminalPUnit (adjunction R) _\n  tfae_have 1 ↔ 6 :=\n    (Sheaf.isConstant_iff_of_equivalence (coherentTopology Profinite)\n      (coherentTopology CompHaus) profiniteToCompHaus Profinite.isTerminalPUnit\n      CompHaus.isTerminalPUnit _).symm\n  tfae_have 7 → 1 := by\n    intro h\n    rw [isDiscrete_iff_isDiscrete_forget, ((CondensedSet.isDiscrete_tfae _).out 0 6:)]\n    intro S\n    letI : PreservesFilteredColimitsOfSize.{u, u} (forget (ModuleCat R)) :=\n      preservesFilteredColimitsOfSize_shrink.{u, u+1, u, u+1} _\n    exact ⟨isColimitOfPreserves (forget (ModuleCat R)) (h S).some⟩\n  tfae_have 1 → 7 := by\n    intro h S\n    rw [isDiscrete_iff_isDiscrete_forget, ((CondensedSet.isDiscrete_tfae _).out 0 6:)] at h\n    letI : ReflectsFilteredColimitsOfSize.{u, u} (forget (ModuleCat R)) :=\n      reflectsFilteredColimitsOfSize_shrink.{u, u+1, u, u+1} _\n    exact ⟨isColimitOfReflects (forget (ModuleCat R)) (h S).some⟩\n  tfae_finish\n\n"}
{"name":"LightCondSet.mem_locallyConstant_essImage_of_isColimit_mapCocone","module":"Mathlib.Condensed.Discrete.Characterization","initialProofState":"X : LightCondSet\nh : (S : LightProfinite) → CategoryTheory.Limits.IsColimit (X.val.mapCocone (CategoryTheory.Limits.coconeRightOpOfCone S.asLimitCone))\n⊢ Membership.mem LightCondSet.LocallyConstant.functor.essImage X","decl":"lemma mem_locallyConstant_essImage_of_isColimit_mapCocone (X : LightCondSet.{u})\n    (h : ∀ S : LightProfinite.{u}, IsColimit <|\n      X.val.mapCocone (coconeRightOpOfCone S.asLimitCone)) :\n    X ∈ LightCondSet.LocallyConstant.functor.essImage := by\n  let i : X.val ≅ (LightCondSet.LocallyConstant.functor.obj _).val :=\n    LightCondensed.isoLocallyConstantOfIsColimit _ h\n  exact ⟨_, ⟨((sheafToPresheaf _ _).preimageIso i.symm)⟩⟩\n\n"}
{"name":"LightCondSet.mem_locallyContant_essImage_of_isColimit_mapCocone","module":"Mathlib.Condensed.Discrete.Characterization","initialProofState":"X : LightCondSet\nh : (S : LightProfinite) → CategoryTheory.Limits.IsColimit (X.val.mapCocone (CategoryTheory.Limits.coconeRightOpOfCone S.asLimitCone))\n⊢ Membership.mem LightCondSet.LocallyConstant.functor.essImage X","decl":"@[deprecated (since := \"2024-12-25\")]\nalias mem_locallyContant_essImage_of_isColimit_mapCocone :=\n  mem_locallyConstant_essImage_of_isColimit_mapCocone\n\n"}
{"name":"LightCondSet.isDiscrete_tfae","module":"Mathlib.Condensed.Discrete.Characterization","initialProofState":"X : LightCondSet\n⊢ (List.cons (LightCondensed.IsDiscrete X) (List.cons (CategoryTheory.IsIso ((LightCondensed.discreteUnderlyingAdj (Type u)).counit.app X)) (List.cons (Membership.mem (LightCondensed.discrete (Type u)).essImage X) (List.cons (Membership.mem LightCondSet.LocallyConstant.functor.essImage X) (List.cons (CategoryTheory.IsIso (LightCondSet.LocallyConstant.adjunction.counit.app X)) (List.cons (∀ (S : LightProfinite), Nonempty (CategoryTheory.Limits.IsColimit (X.val.mapCocone (CategoryTheory.Limits.coconeRightOpOfCone S.asLimitCone)))) List.nil)))))).TFAE","decl":"open LightCondSet.LocallyConstant List in\ntheorem isDiscrete_tfae  (X : LightCondSet.{u}) :\n    TFAE\n    [ X.IsDiscrete\n    , IsIso ((LightCondensed.discreteUnderlyingAdj _).counit.app X)\n    , X ∈ (LightCondensed.discrete _).essImage\n    , X ∈ LightCondSet.LocallyConstant.functor.essImage\n    , IsIso (LightCondSet.LocallyConstant.adjunction.counit.app X)\n    , ∀ S : LightProfinite.{u}, Nonempty\n        (IsColimit <| X.val.mapCocone (coconeRightOpOfCone S.asLimitCone))\n    ] := by\n  tfae_have 1 ↔ 2 := Sheaf.isConstant_iff_isIso_counit_app _ _ _\n  tfae_have 1 ↔ 3 := ⟨fun ⟨h⟩ ↦ h, fun h ↦ ⟨h⟩⟩\n  tfae_have 1 ↔ 4 := Sheaf.isConstant_iff_mem_essImage _ LightProfinite.isTerminalPUnit adjunction X\n  tfae_have 1 ↔ 5 :=\n    have : functor.Faithful := inferInstance\n    have : functor.Full := inferInstance\n    -- These `have` statements above shouldn't be needed, but they are.\n    Sheaf.isConstant_iff_isIso_counit_app' _ LightProfinite.isTerminalPUnit adjunction X\n  tfae_have 6 → 4 := fun h ↦\n    mem_locallyConstant_essImage_of_isColimit_mapCocone X (fun S ↦ (h S).some)\n  tfae_have 4 → 6 := fun ⟨Y, ⟨i⟩⟩ S ↦\n    ⟨IsColimit.mapCoconeEquiv ((sheafToPresheaf _ _).mapIso i)\n      (LightCondensed.isColimitLocallyConstantPresheafDiagram Y S)⟩\n  tfae_finish\n\n"}
{"name":"LightCondMod.isDiscrete_iff_isDiscrete_forget","module":"Mathlib.Condensed.Discrete.Characterization","initialProofState":"R : Type u\ninst✝ : Ring R\nM : LightCondMod R\n⊢ Iff (LightCondensed.IsDiscrete M) (LightCondensed.IsDiscrete ((LightCondensed.forget R).obj M))","decl":"lemma isDiscrete_iff_isDiscrete_forget (M : LightCondMod R) :\n    M.IsDiscrete ↔ ((LightCondensed.forget R).obj M).IsDiscrete  :=\n  Sheaf.isConstant_iff_forget (coherentTopology LightProfinite)\n    (forget (ModuleCat R)) M LightProfinite.isTerminalPUnit\n\n"}
{"name":"LightCondMod.isDiscrete_tfae","module":"Mathlib.Condensed.Discrete.Characterization","initialProofState":"R : Type u\ninst✝ : Ring R\nM : LightCondMod R\n⊢ (List.cons (LightCondensed.IsDiscrete M) (List.cons (CategoryTheory.IsIso ((LightCondensed.discreteUnderlyingAdj (ModuleCat R)).counit.app M)) (List.cons (Membership.mem (LightCondensed.discrete (ModuleCat R)).essImage M) (List.cons (Membership.mem (LightCondMod.LocallyConstant.functor R).essImage M) (List.cons (CategoryTheory.IsIso ((LightCondMod.LocallyConstant.adjunction R).counit.app M)) (List.cons (∀ (S : LightProfinite), Nonempty (CategoryTheory.Limits.IsColimit (M.val.mapCocone (CategoryTheory.Limits.coconeRightOpOfCone S.asLimitCone)))) List.nil)))))).TFAE","decl":"open LightCondMod.LocallyConstant List in\ntheorem isDiscrete_tfae  (M : LightCondMod.{u} R) :\n    TFAE\n    [ M.IsDiscrete\n    , IsIso ((LightCondensed.discreteUnderlyingAdj _).counit.app M)\n    , M ∈ (LightCondensed.discrete _).essImage\n    , M ∈ (LightCondMod.LocallyConstant.functor R).essImage\n    , IsIso ((LightCondMod.LocallyConstant.adjunction R).counit.app M)\n    , ∀ S : LightProfinite.{u}, Nonempty\n        (IsColimit <| M.val.mapCocone (coconeRightOpOfCone S.asLimitCone))\n    ] := by\n  tfae_have 1 ↔ 2 := Sheaf.isConstant_iff_isIso_counit_app _ _ _\n  tfae_have 1 ↔ 3 := ⟨fun ⟨h⟩ ↦ h, fun h ↦ ⟨h⟩⟩\n  tfae_have 1 ↔ 4 := Sheaf.isConstant_iff_mem_essImage _\n    LightProfinite.isTerminalPUnit (adjunction R) _\n  tfae_have 1 ↔ 5 :=\n    have : (functor R).Faithful := inferInstance\n    have : (functor R).Full := inferInstance\n    -- These `have` statements above shouldn't be needed, but they are.\n    Sheaf.isConstant_iff_isIso_counit_app' _ LightProfinite.isTerminalPUnit (adjunction R) _\n  tfae_have 6 → 1 := by\n    intro h\n    rw [isDiscrete_iff_isDiscrete_forget, ((LightCondSet.isDiscrete_tfae _).out 0 5:)]\n    intro S\n    letI : PreservesFilteredColimitsOfSize.{0, 0} (forget (ModuleCat R)) :=\n      preservesFilteredColimitsOfSize_shrink.{0, u, 0, u} _\n    exact ⟨isColimitOfPreserves (forget (ModuleCat R)) (h S).some⟩\n  tfae_have 1 → 6 := by\n    intro h S\n    rw [isDiscrete_iff_isDiscrete_forget, ((LightCondSet.isDiscrete_tfae _).out 0 5:)] at h\n    letI : ReflectsFilteredColimitsOfSize.{0, 0} (forget (ModuleCat R)) :=\n      reflectsFilteredColimitsOfSize_shrink.{0, u, 0, u} _\n    exact ⟨isColimitOfReflects (forget (ModuleCat R)) (h S).some⟩\n  tfae_finish\n\n"}
